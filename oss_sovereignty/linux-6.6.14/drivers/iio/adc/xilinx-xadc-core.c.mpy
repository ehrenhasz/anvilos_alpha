{
  "module_name": "xilinx-xadc-core.c",
  "hash_id": "ba18f4a20bad301fa7725a2ed7fa938f167c409537f5b9694ed62d9adce99d45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/xilinx-xadc-core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/overflow.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#include \"xilinx-xadc.h\"\n\nstatic const unsigned int XADC_ZYNQ_UNMASK_TIMEOUT = 500;\n\n \n#define XADC_ZYNQ_REG_CFG\t0x00\n#define XADC_ZYNQ_REG_INTSTS\t0x04\n#define XADC_ZYNQ_REG_INTMSK\t0x08\n#define XADC_ZYNQ_REG_STATUS\t0x0c\n#define XADC_ZYNQ_REG_CFIFO\t0x10\n#define XADC_ZYNQ_REG_DFIFO\t0x14\n#define XADC_ZYNQ_REG_CTL\t\t0x18\n\n#define XADC_ZYNQ_CFG_ENABLE\t\tBIT(31)\n#define XADC_ZYNQ_CFG_CFIFOTH_MASK\t(0xf << 20)\n#define XADC_ZYNQ_CFG_CFIFOTH_OFFSET\t20\n#define XADC_ZYNQ_CFG_DFIFOTH_MASK\t(0xf << 16)\n#define XADC_ZYNQ_CFG_DFIFOTH_OFFSET\t16\n#define XADC_ZYNQ_CFG_WEDGE\t\tBIT(13)\n#define XADC_ZYNQ_CFG_REDGE\t\tBIT(12)\n#define XADC_ZYNQ_CFG_TCKRATE_MASK\t(0x3 << 8)\n#define XADC_ZYNQ_CFG_TCKRATE_DIV2\t(0x0 << 8)\n#define XADC_ZYNQ_CFG_TCKRATE_DIV4\t(0x1 << 8)\n#define XADC_ZYNQ_CFG_TCKRATE_DIV8\t(0x2 << 8)\n#define XADC_ZYNQ_CFG_TCKRATE_DIV16\t(0x3 << 8)\n#define XADC_ZYNQ_CFG_IGAP_MASK\t\t0x1f\n#define XADC_ZYNQ_CFG_IGAP(x)\t\t(x)\n\n#define XADC_ZYNQ_INT_CFIFO_LTH\t\tBIT(9)\n#define XADC_ZYNQ_INT_DFIFO_GTH\t\tBIT(8)\n#define XADC_ZYNQ_INT_ALARM_MASK\t0xff\n#define XADC_ZYNQ_INT_ALARM_OFFSET\t0\n\n#define XADC_ZYNQ_STATUS_CFIFO_LVL_MASK\t(0xf << 16)\n#define XADC_ZYNQ_STATUS_CFIFO_LVL_OFFSET\t16\n#define XADC_ZYNQ_STATUS_DFIFO_LVL_MASK\t(0xf << 12)\n#define XADC_ZYNQ_STATUS_DFIFO_LVL_OFFSET\t12\n#define XADC_ZYNQ_STATUS_CFIFOF\t\tBIT(11)\n#define XADC_ZYNQ_STATUS_CFIFOE\t\tBIT(10)\n#define XADC_ZYNQ_STATUS_DFIFOF\t\tBIT(9)\n#define XADC_ZYNQ_STATUS_DFIFOE\t\tBIT(8)\n#define XADC_ZYNQ_STATUS_OT\t\tBIT(7)\n#define XADC_ZYNQ_STATUS_ALM(x)\t\tBIT(x)\n\n#define XADC_ZYNQ_CTL_RESET\t\tBIT(4)\n\n#define XADC_ZYNQ_CMD_NOP\t\t0x00\n#define XADC_ZYNQ_CMD_READ\t\t0x01\n#define XADC_ZYNQ_CMD_WRITE\t\t0x02\n\n#define XADC_ZYNQ_CMD(cmd, addr, data) (((cmd) << 26) | ((addr) << 16) | (data))\n\n \n#define XADC_AXI_REG_RESET\t\t0x00\n#define XADC_AXI_REG_STATUS\t\t0x04\n#define XADC_AXI_REG_ALARM_STATUS\t0x08\n#define XADC_AXI_REG_CONVST\t\t0x0c\n#define XADC_AXI_REG_XADC_RESET\t\t0x10\n#define XADC_AXI_REG_GIER\t\t0x5c\n#define XADC_AXI_REG_IPISR\t\t0x60\n#define XADC_AXI_REG_IPIER\t\t0x68\n\n \n#define XADC_7S_AXI_ADC_REG_OFFSET\t0x200\n\n \n#define XADC_US_AXI_ADC_REG_OFFSET\t0x400\n\n#define XADC_AXI_RESET_MAGIC\t\t0xa\n#define XADC_AXI_GIER_ENABLE\t\tBIT(31)\n\n#define XADC_AXI_INT_EOS\t\tBIT(4)\n#define XADC_AXI_INT_ALARM_MASK\t\t0x3c0f\n\n#define XADC_FLAGS_BUFFERED BIT(0)\n#define XADC_FLAGS_IRQ_OPTIONAL BIT(1)\n\n \n#define XADC_MAX_SAMPLERATE 150000\n\nstatic void xadc_write_reg(struct xadc *xadc, unsigned int reg,\n\tuint32_t val)\n{\n\twritel(val, xadc->base + reg);\n}\n\nstatic void xadc_read_reg(struct xadc *xadc, unsigned int reg,\n\tuint32_t *val)\n{\n\t*val = readl(xadc->base + reg);\n}\n\n \n\nstatic void xadc_zynq_write_fifo(struct xadc *xadc, uint32_t *cmd,\n\tunsigned int n)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n; i++)\n\t\txadc_write_reg(xadc, XADC_ZYNQ_REG_CFIFO, cmd[i]);\n}\n\nstatic void xadc_zynq_drain_fifo(struct xadc *xadc)\n{\n\tuint32_t status, tmp;\n\n\txadc_read_reg(xadc, XADC_ZYNQ_REG_STATUS, &status);\n\n\twhile (!(status & XADC_ZYNQ_STATUS_DFIFOE)) {\n\t\txadc_read_reg(xadc, XADC_ZYNQ_REG_DFIFO, &tmp);\n\t\txadc_read_reg(xadc, XADC_ZYNQ_REG_STATUS, &status);\n\t}\n}\n\nstatic void xadc_zynq_update_intmsk(struct xadc *xadc, unsigned int mask,\n\tunsigned int val)\n{\n\txadc->zynq_intmask &= ~mask;\n\txadc->zynq_intmask |= val;\n\n\txadc_write_reg(xadc, XADC_ZYNQ_REG_INTMSK,\n\t\txadc->zynq_intmask | xadc->zynq_masked_alarm);\n}\n\nstatic int xadc_zynq_write_adc_reg(struct xadc *xadc, unsigned int reg,\n\tuint16_t val)\n{\n\tuint32_t cmd[1];\n\tuint32_t tmp;\n\tint ret;\n\n\tspin_lock_irq(&xadc->lock);\n\txadc_zynq_update_intmsk(xadc, XADC_ZYNQ_INT_DFIFO_GTH,\n\t\t\tXADC_ZYNQ_INT_DFIFO_GTH);\n\n\treinit_completion(&xadc->completion);\n\n\tcmd[0] = XADC_ZYNQ_CMD(XADC_ZYNQ_CMD_WRITE, reg, val);\n\txadc_zynq_write_fifo(xadc, cmd, ARRAY_SIZE(cmd));\n\txadc_read_reg(xadc, XADC_ZYNQ_REG_CFG, &tmp);\n\ttmp &= ~XADC_ZYNQ_CFG_DFIFOTH_MASK;\n\ttmp |= 0 << XADC_ZYNQ_CFG_DFIFOTH_OFFSET;\n\txadc_write_reg(xadc, XADC_ZYNQ_REG_CFG, tmp);\n\n\txadc_zynq_update_intmsk(xadc, XADC_ZYNQ_INT_DFIFO_GTH, 0);\n\tspin_unlock_irq(&xadc->lock);\n\n\tret = wait_for_completion_interruptible_timeout(&xadc->completion, HZ);\n\tif (ret == 0)\n\t\tret = -EIO;\n\telse\n\t\tret = 0;\n\n\txadc_read_reg(xadc, XADC_ZYNQ_REG_DFIFO, &tmp);\n\n\treturn ret;\n}\n\nstatic int xadc_zynq_read_adc_reg(struct xadc *xadc, unsigned int reg,\n\tuint16_t *val)\n{\n\tuint32_t cmd[2];\n\tuint32_t resp, tmp;\n\tint ret;\n\n\tcmd[0] = XADC_ZYNQ_CMD(XADC_ZYNQ_CMD_READ, reg, 0);\n\tcmd[1] = XADC_ZYNQ_CMD(XADC_ZYNQ_CMD_NOP, 0, 0);\n\n\tspin_lock_irq(&xadc->lock);\n\txadc_zynq_update_intmsk(xadc, XADC_ZYNQ_INT_DFIFO_GTH,\n\t\t\tXADC_ZYNQ_INT_DFIFO_GTH);\n\txadc_zynq_drain_fifo(xadc);\n\treinit_completion(&xadc->completion);\n\n\txadc_zynq_write_fifo(xadc, cmd, ARRAY_SIZE(cmd));\n\txadc_read_reg(xadc, XADC_ZYNQ_REG_CFG, &tmp);\n\ttmp &= ~XADC_ZYNQ_CFG_DFIFOTH_MASK;\n\ttmp |= 1 << XADC_ZYNQ_CFG_DFIFOTH_OFFSET;\n\txadc_write_reg(xadc, XADC_ZYNQ_REG_CFG, tmp);\n\n\txadc_zynq_update_intmsk(xadc, XADC_ZYNQ_INT_DFIFO_GTH, 0);\n\tspin_unlock_irq(&xadc->lock);\n\tret = wait_for_completion_interruptible_timeout(&xadc->completion, HZ);\n\tif (ret == 0)\n\t\tret = -EIO;\n\tif (ret < 0)\n\t\treturn ret;\n\n\txadc_read_reg(xadc, XADC_ZYNQ_REG_DFIFO, &resp);\n\txadc_read_reg(xadc, XADC_ZYNQ_REG_DFIFO, &resp);\n\n\t*val = resp & 0xffff;\n\n\treturn 0;\n}\n\nstatic unsigned int xadc_zynq_transform_alarm(unsigned int alarm)\n{\n\treturn ((alarm & 0x80) >> 4) |\n\t\t((alarm & 0x78) << 1) |\n\t\t(alarm & 0x07);\n}\n\n \nstatic void xadc_zynq_unmask_worker(struct work_struct *work)\n{\n\tstruct xadc *xadc = container_of(work, struct xadc, zynq_unmask_work.work);\n\tunsigned int misc_sts, unmask;\n\n\txadc_read_reg(xadc, XADC_ZYNQ_REG_STATUS, &misc_sts);\n\n\tmisc_sts &= XADC_ZYNQ_INT_ALARM_MASK;\n\n\tspin_lock_irq(&xadc->lock);\n\n\t \n\tunmask = (xadc->zynq_masked_alarm ^ misc_sts) & xadc->zynq_masked_alarm;\n\txadc->zynq_masked_alarm &= misc_sts;\n\n\t \n\txadc->zynq_masked_alarm &= ~xadc->zynq_intmask;\n\n\t \n\txadc_write_reg(xadc, XADC_ZYNQ_REG_INTSTS, unmask);\n\n\txadc_zynq_update_intmsk(xadc, 0, 0);\n\n\tspin_unlock_irq(&xadc->lock);\n\n\t \n\tif (xadc->zynq_masked_alarm) {\n\t\tschedule_delayed_work(&xadc->zynq_unmask_work,\n\t\t\t\tmsecs_to_jiffies(XADC_ZYNQ_UNMASK_TIMEOUT));\n\t}\n\n}\n\nstatic irqreturn_t xadc_zynq_interrupt_handler(int irq, void *devid)\n{\n\tstruct iio_dev *indio_dev = devid;\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\tuint32_t status;\n\n\txadc_read_reg(xadc, XADC_ZYNQ_REG_INTSTS, &status);\n\n\tstatus &= ~(xadc->zynq_intmask | xadc->zynq_masked_alarm);\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&xadc->lock);\n\n\txadc_write_reg(xadc, XADC_ZYNQ_REG_INTSTS, status);\n\n\tif (status & XADC_ZYNQ_INT_DFIFO_GTH) {\n\t\txadc_zynq_update_intmsk(xadc, XADC_ZYNQ_INT_DFIFO_GTH,\n\t\t\tXADC_ZYNQ_INT_DFIFO_GTH);\n\t\tcomplete(&xadc->completion);\n\t}\n\n\tstatus &= XADC_ZYNQ_INT_ALARM_MASK;\n\tif (status) {\n\t\txadc->zynq_masked_alarm |= status;\n\t\t \n\t\txadc_zynq_update_intmsk(xadc, 0, 0);\n\n\t\txadc_handle_events(indio_dev,\n\t\t\t\txadc_zynq_transform_alarm(status));\n\n\t\t \n\t\tschedule_delayed_work(&xadc->zynq_unmask_work,\n\t\t\t\tmsecs_to_jiffies(XADC_ZYNQ_UNMASK_TIMEOUT));\n\t}\n\tspin_unlock(&xadc->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n#define XADC_ZYNQ_TCK_RATE_MAX 50000000\n#define XADC_ZYNQ_IGAP_DEFAULT 20\n#define XADC_ZYNQ_PCAP_RATE_MAX 200000000\n\nstatic int xadc_zynq_setup(struct platform_device *pdev,\n\tstruct iio_dev *indio_dev, int irq)\n{\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\tunsigned long pcap_rate;\n\tunsigned int tck_div;\n\tunsigned int div;\n\tunsigned int igap;\n\tunsigned int tck_rate;\n\tint ret;\n\n\t \n\tigap = XADC_ZYNQ_IGAP_DEFAULT;\n\ttck_rate = XADC_ZYNQ_TCK_RATE_MAX;\n\n\txadc->zynq_intmask = ~0;\n\n\tpcap_rate = clk_get_rate(xadc->clk);\n\tif (!pcap_rate)\n\t\treturn -EINVAL;\n\n\tif (pcap_rate > XADC_ZYNQ_PCAP_RATE_MAX) {\n\t\tret = clk_set_rate(xadc->clk,\n\t\t\t\t   (unsigned long)XADC_ZYNQ_PCAP_RATE_MAX);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (tck_rate > pcap_rate / 2) {\n\t\tdiv = 2;\n\t} else {\n\t\tdiv = pcap_rate / tck_rate;\n\t\tif (pcap_rate / div > XADC_ZYNQ_TCK_RATE_MAX)\n\t\t\tdiv++;\n\t}\n\n\tif (div <= 3)\n\t\ttck_div = XADC_ZYNQ_CFG_TCKRATE_DIV2;\n\telse if (div <= 7)\n\t\ttck_div = XADC_ZYNQ_CFG_TCKRATE_DIV4;\n\telse if (div <= 15)\n\t\ttck_div = XADC_ZYNQ_CFG_TCKRATE_DIV8;\n\telse\n\t\ttck_div = XADC_ZYNQ_CFG_TCKRATE_DIV16;\n\n\txadc_write_reg(xadc, XADC_ZYNQ_REG_CTL, XADC_ZYNQ_CTL_RESET);\n\txadc_write_reg(xadc, XADC_ZYNQ_REG_CTL, 0);\n\txadc_write_reg(xadc, XADC_ZYNQ_REG_INTSTS, ~0);\n\txadc_write_reg(xadc, XADC_ZYNQ_REG_INTMSK, xadc->zynq_intmask);\n\txadc_write_reg(xadc, XADC_ZYNQ_REG_CFG, XADC_ZYNQ_CFG_ENABLE |\n\t\t\tXADC_ZYNQ_CFG_REDGE | XADC_ZYNQ_CFG_WEDGE |\n\t\t\ttck_div | XADC_ZYNQ_CFG_IGAP(igap));\n\n\tif (pcap_rate > XADC_ZYNQ_PCAP_RATE_MAX) {\n\t\tret = clk_set_rate(xadc->clk, pcap_rate);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long xadc_zynq_get_dclk_rate(struct xadc *xadc)\n{\n\tunsigned int div;\n\tuint32_t val;\n\n\txadc_read_reg(xadc, XADC_ZYNQ_REG_CFG, &val);\n\n\tswitch (val & XADC_ZYNQ_CFG_TCKRATE_MASK) {\n\tcase XADC_ZYNQ_CFG_TCKRATE_DIV4:\n\t\tdiv = 4;\n\t\tbreak;\n\tcase XADC_ZYNQ_CFG_TCKRATE_DIV8:\n\t\tdiv = 8;\n\t\tbreak;\n\tcase XADC_ZYNQ_CFG_TCKRATE_DIV16:\n\t\tdiv = 16;\n\t\tbreak;\n\tdefault:\n\t\tdiv = 2;\n\t\tbreak;\n\t}\n\n\treturn clk_get_rate(xadc->clk) / div;\n}\n\nstatic void xadc_zynq_update_alarm(struct xadc *xadc, unsigned int alarm)\n{\n\tunsigned long flags;\n\tuint32_t status;\n\n\t \n\talarm = ((alarm & 0x08) << 4) | ((alarm & 0xf0) >> 1) | (alarm & 0x07);\n\n\tspin_lock_irqsave(&xadc->lock, flags);\n\n\t \n\txadc_read_reg(xadc, XADC_ZYNQ_REG_INTSTS, &status);\n\txadc_write_reg(xadc, XADC_ZYNQ_REG_INTSTS, status & alarm);\n\n\txadc_zynq_update_intmsk(xadc, XADC_ZYNQ_INT_ALARM_MASK,\n\t\t~alarm & XADC_ZYNQ_INT_ALARM_MASK);\n\n\tspin_unlock_irqrestore(&xadc->lock, flags);\n}\n\nstatic const struct xadc_ops xadc_zynq_ops = {\n\t.read = xadc_zynq_read_adc_reg,\n\t.write = xadc_zynq_write_adc_reg,\n\t.setup = xadc_zynq_setup,\n\t.get_dclk_rate = xadc_zynq_get_dclk_rate,\n\t.interrupt_handler = xadc_zynq_interrupt_handler,\n\t.update_alarm = xadc_zynq_update_alarm,\n\t.type = XADC_TYPE_S7,\n\t \n\t.temp_scale = 503975,\n\t.temp_offset = 273150,\n};\n\nstatic const unsigned int xadc_axi_reg_offsets[] = {\n\t[XADC_TYPE_S7] = XADC_7S_AXI_ADC_REG_OFFSET,\n\t[XADC_TYPE_US] = XADC_US_AXI_ADC_REG_OFFSET,\n};\n\nstatic int xadc_axi_read_adc_reg(struct xadc *xadc, unsigned int reg,\n\tuint16_t *val)\n{\n\tuint32_t val32;\n\n\txadc_read_reg(xadc, xadc_axi_reg_offsets[xadc->ops->type] + reg * 4,\n\t\t&val32);\n\t*val = val32 & 0xffff;\n\n\treturn 0;\n}\n\nstatic int xadc_axi_write_adc_reg(struct xadc *xadc, unsigned int reg,\n\tuint16_t val)\n{\n\txadc_write_reg(xadc, xadc_axi_reg_offsets[xadc->ops->type] + reg * 4,\n\t\tval);\n\n\treturn 0;\n}\n\nstatic int xadc_axi_setup(struct platform_device *pdev,\n\tstruct iio_dev *indio_dev, int irq)\n{\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\n\txadc_write_reg(xadc, XADC_AXI_REG_RESET, XADC_AXI_RESET_MAGIC);\n\txadc_write_reg(xadc, XADC_AXI_REG_GIER, XADC_AXI_GIER_ENABLE);\n\n\treturn 0;\n}\n\nstatic irqreturn_t xadc_axi_interrupt_handler(int irq, void *devid)\n{\n\tstruct iio_dev *indio_dev = devid;\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\tuint32_t status, mask;\n\tunsigned int events;\n\n\txadc_read_reg(xadc, XADC_AXI_REG_IPISR, &status);\n\txadc_read_reg(xadc, XADC_AXI_REG_IPIER, &mask);\n\tstatus &= mask;\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tif ((status & XADC_AXI_INT_EOS) && xadc->trigger)\n\t\tiio_trigger_poll(xadc->trigger);\n\n\tif (status & XADC_AXI_INT_ALARM_MASK) {\n\t\t \n\t\tevents = (status & 0x000e) >> 1;\n\t\tevents |= (status & 0x0001) << 3;\n\t\tevents |= (status & 0x3c00) >> 6;\n\t\txadc_handle_events(indio_dev, events);\n\t}\n\n\txadc_write_reg(xadc, XADC_AXI_REG_IPISR, status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void xadc_axi_update_alarm(struct xadc *xadc, unsigned int alarm)\n{\n\tuint32_t val;\n\tunsigned long flags;\n\n\t \n\talarm = ((alarm & 0x07) << 1) | ((alarm & 0x08) >> 3) |\n\t\t\t((alarm & 0xf0) << 6);\n\n\tspin_lock_irqsave(&xadc->lock, flags);\n\txadc_read_reg(xadc, XADC_AXI_REG_IPIER, &val);\n\tval &= ~XADC_AXI_INT_ALARM_MASK;\n\tval |= alarm;\n\txadc_write_reg(xadc, XADC_AXI_REG_IPIER, val);\n\tspin_unlock_irqrestore(&xadc->lock, flags);\n}\n\nstatic unsigned long xadc_axi_get_dclk(struct xadc *xadc)\n{\n\treturn clk_get_rate(xadc->clk);\n}\n\nstatic const struct xadc_ops xadc_7s_axi_ops = {\n\t.read = xadc_axi_read_adc_reg,\n\t.write = xadc_axi_write_adc_reg,\n\t.setup = xadc_axi_setup,\n\t.get_dclk_rate = xadc_axi_get_dclk,\n\t.update_alarm = xadc_axi_update_alarm,\n\t.interrupt_handler = xadc_axi_interrupt_handler,\n\t.flags = XADC_FLAGS_BUFFERED | XADC_FLAGS_IRQ_OPTIONAL,\n\t.type = XADC_TYPE_S7,\n\t \n\t.temp_scale = 503975,\n\t.temp_offset = 273150,\n};\n\nstatic const struct xadc_ops xadc_us_axi_ops = {\n\t.read = xadc_axi_read_adc_reg,\n\t.write = xadc_axi_write_adc_reg,\n\t.setup = xadc_axi_setup,\n\t.get_dclk_rate = xadc_axi_get_dclk,\n\t.update_alarm = xadc_axi_update_alarm,\n\t.interrupt_handler = xadc_axi_interrupt_handler,\n\t.flags = XADC_FLAGS_BUFFERED | XADC_FLAGS_IRQ_OPTIONAL,\n\t.type = XADC_TYPE_US,\n\t \n\t.temp_scale = 509314,\n\t.temp_offset = 280231,\n};\n\nstatic int _xadc_update_adc_reg(struct xadc *xadc, unsigned int reg,\n\tuint16_t mask, uint16_t val)\n{\n\tuint16_t tmp;\n\tint ret;\n\n\tret = _xadc_read_adc_reg(xadc, reg, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn _xadc_write_adc_reg(xadc, reg, (tmp & ~mask) | val);\n}\n\nstatic int xadc_update_adc_reg(struct xadc *xadc, unsigned int reg,\n\tuint16_t mask, uint16_t val)\n{\n\tint ret;\n\n\tmutex_lock(&xadc->mutex);\n\tret = _xadc_update_adc_reg(xadc, reg, mask, val);\n\tmutex_unlock(&xadc->mutex);\n\n\treturn ret;\n}\n\nstatic unsigned long xadc_get_dclk_rate(struct xadc *xadc)\n{\n\treturn xadc->ops->get_dclk_rate(xadc);\n}\n\nstatic int xadc_update_scan_mode(struct iio_dev *indio_dev,\n\tconst unsigned long *mask)\n{\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\tsize_t n;\n\tvoid *data;\n\n\tn = bitmap_weight(mask, indio_dev->masklength);\n\n\tdata = devm_krealloc_array(indio_dev->dev.parent, xadc->data,\n\t\t\t\t   n, sizeof(*xadc->data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmemset(data, 0, n * sizeof(*xadc->data));\n\txadc->data = data;\n\n\treturn 0;\n}\n\nstatic unsigned int xadc_scan_index_to_channel(unsigned int scan_index)\n{\n\tswitch (scan_index) {\n\tcase 5:\n\t\treturn XADC_REG_VCCPINT;\n\tcase 6:\n\t\treturn XADC_REG_VCCPAUX;\n\tcase 7:\n\t\treturn XADC_REG_VCCO_DDR;\n\tcase 8:\n\t\treturn XADC_REG_TEMP;\n\tcase 9:\n\t\treturn XADC_REG_VCCINT;\n\tcase 10:\n\t\treturn XADC_REG_VCCAUX;\n\tcase 11:\n\t\treturn XADC_REG_VPVN;\n\tcase 12:\n\t\treturn XADC_REG_VREFP;\n\tcase 13:\n\t\treturn XADC_REG_VREFN;\n\tcase 14:\n\t\treturn XADC_REG_VCCBRAM;\n\tdefault:\n\t\treturn XADC_REG_VAUX(scan_index - 16);\n\t}\n}\n\nstatic irqreturn_t xadc_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\tunsigned int chan;\n\tint i, j;\n\n\tif (!xadc->data)\n\t\tgoto out;\n\n\tj = 0;\n\tfor_each_set_bit(i, indio_dev->active_scan_mask,\n\t\tindio_dev->masklength) {\n\t\tchan = xadc_scan_index_to_channel(i);\n\t\txadc_read_adc_reg(xadc, chan, &xadc->data[j]);\n\t\tj++;\n\t}\n\n\tiio_push_to_buffers(indio_dev, xadc->data);\n\nout:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int xadc_trigger_set_state(struct iio_trigger *trigger, bool state)\n{\n\tstruct xadc *xadc = iio_trigger_get_drvdata(trigger);\n\tunsigned long flags;\n\tunsigned int convst;\n\tunsigned int val;\n\tint ret = 0;\n\n\tmutex_lock(&xadc->mutex);\n\n\tif (state) {\n\t\t \n\t\tif (xadc->trigger != NULL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_out;\n\t\t} else {\n\t\t\txadc->trigger = trigger;\n\t\t\tif (trigger == xadc->convst_trigger)\n\t\t\t\tconvst = XADC_CONF0_EC;\n\t\t\telse\n\t\t\t\tconvst = 0;\n\t\t}\n\t\tret = _xadc_update_adc_reg(xadc, XADC_REG_CONF1, XADC_CONF0_EC,\n\t\t\t\t\tconvst);\n\t\tif (ret)\n\t\t\tgoto err_out;\n\t} else {\n\t\txadc->trigger = NULL;\n\t}\n\n\tspin_lock_irqsave(&xadc->lock, flags);\n\txadc_read_reg(xadc, XADC_AXI_REG_IPIER, &val);\n\txadc_write_reg(xadc, XADC_AXI_REG_IPISR, XADC_AXI_INT_EOS);\n\tif (state)\n\t\tval |= XADC_AXI_INT_EOS;\n\telse\n\t\tval &= ~XADC_AXI_INT_EOS;\n\txadc_write_reg(xadc, XADC_AXI_REG_IPIER, val);\n\tspin_unlock_irqrestore(&xadc->lock, flags);\n\nerr_out:\n\tmutex_unlock(&xadc->mutex);\n\n\treturn ret;\n}\n\nstatic const struct iio_trigger_ops xadc_trigger_ops = {\n\t.set_trigger_state = &xadc_trigger_set_state,\n};\n\nstatic struct iio_trigger *xadc_alloc_trigger(struct iio_dev *indio_dev,\n\tconst char *name)\n{\n\tstruct device *dev = indio_dev->dev.parent;\n\tstruct iio_trigger *trig;\n\tint ret;\n\n\ttrig = devm_iio_trigger_alloc(dev, \"%s%d-%s\", indio_dev->name,\n\t\t\t\t      iio_device_id(indio_dev), name);\n\tif (trig == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttrig->ops = &xadc_trigger_ops;\n\tiio_trigger_set_drvdata(trig, iio_priv(indio_dev));\n\n\tret = devm_iio_trigger_register(dev, trig);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn trig;\n}\n\nstatic int xadc_power_adc_b(struct xadc *xadc, unsigned int seq_mode)\n{\n\tuint16_t val;\n\n\t \n\tif (xadc->ops->type == XADC_TYPE_US)\n\t\treturn 0;\n\n\t \n\tswitch (seq_mode) {\n\tcase XADC_CONF1_SEQ_SIMULTANEOUS:\n\tcase XADC_CONF1_SEQ_INDEPENDENT:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\tval = XADC_CONF2_PD_ADC_B;\n\t\tbreak;\n\t}\n\n\treturn xadc_update_adc_reg(xadc, XADC_REG_CONF2, XADC_CONF2_PD_MASK,\n\t\tval);\n}\n\nstatic int xadc_get_seq_mode(struct xadc *xadc, unsigned long scan_mode)\n{\n\tunsigned int aux_scan_mode = scan_mode >> 16;\n\n\t \n\tif (xadc->ops->type == XADC_TYPE_US)\n\t\treturn XADC_CONF1_SEQ_CONTINUOUS;\n\n\tif (xadc->external_mux_mode == XADC_EXTERNAL_MUX_DUAL)\n\t\treturn XADC_CONF1_SEQ_SIMULTANEOUS;\n\n\tif ((aux_scan_mode & 0xff00) == 0 ||\n\t\t(aux_scan_mode & 0x00ff) == 0)\n\t\treturn XADC_CONF1_SEQ_CONTINUOUS;\n\n\treturn XADC_CONF1_SEQ_SIMULTANEOUS;\n}\n\nstatic int xadc_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\tunsigned long scan_mask;\n\tint ret;\n\tint i;\n\n\tscan_mask = 1;  \n\tfor (i = 0; i < indio_dev->num_channels; i++)\n\t\tscan_mask |= BIT(indio_dev->channels[i].scan_index);\n\n\t \n\tret = xadc_write_adc_reg(xadc, XADC_REG_SEQ(0), scan_mask & 0xffff);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xadc_write_adc_reg(xadc, XADC_REG_SEQ(1), scan_mask >> 16);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xadc_update_adc_reg(xadc, XADC_REG_CONF1, XADC_CONF1_SEQ_MASK,\n\t\tXADC_CONF1_SEQ_CONTINUOUS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn xadc_power_adc_b(xadc, XADC_CONF1_SEQ_CONTINUOUS);\n}\n\nstatic int xadc_preenable(struct iio_dev *indio_dev)\n{\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\tunsigned long scan_mask;\n\tint seq_mode;\n\tint ret;\n\n\tret = xadc_update_adc_reg(xadc, XADC_REG_CONF1, XADC_CONF1_SEQ_MASK,\n\t\tXADC_CONF1_SEQ_DEFAULT);\n\tif (ret)\n\t\tgoto err;\n\n\tscan_mask = *indio_dev->active_scan_mask;\n\tseq_mode = xadc_get_seq_mode(xadc, scan_mask);\n\n\tret = xadc_write_adc_reg(xadc, XADC_REG_SEQ(0), scan_mask & 0xffff);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (seq_mode == XADC_CONF1_SEQ_SIMULTANEOUS)\n\t\tscan_mask = ((scan_mask >> 8) | scan_mask) & 0xff0000;\n\n\tret = xadc_write_adc_reg(xadc, XADC_REG_SEQ(1), scan_mask >> 16);\n\tif (ret)\n\t\tgoto err;\n\n\tret = xadc_power_adc_b(xadc, seq_mode);\n\tif (ret)\n\t\tgoto err;\n\n\tret = xadc_update_adc_reg(xadc, XADC_REG_CONF1, XADC_CONF1_SEQ_MASK,\n\t\tseq_mode);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\txadc_postdisable(indio_dev);\n\treturn ret;\n}\n\nstatic const struct iio_buffer_setup_ops xadc_buffer_ops = {\n\t.preenable = &xadc_preenable,\n\t.postdisable = &xadc_postdisable,\n};\n\nstatic int xadc_read_samplerate(struct xadc *xadc)\n{\n\tunsigned int div;\n\tuint16_t val16;\n\tint ret;\n\n\tret = xadc_read_adc_reg(xadc, XADC_REG_CONF2, &val16);\n\tif (ret)\n\t\treturn ret;\n\n\tdiv = (val16 & XADC_CONF2_DIV_MASK) >> XADC_CONF2_DIV_OFFSET;\n\tif (div < 2)\n\t\tdiv = 2;\n\n\treturn xadc_get_dclk_rate(xadc) / div / 26;\n}\n\nstatic int xadc_read_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int *val, int *val2, long info)\n{\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\tunsigned int bits = chan->scan_type.realbits;\n\tuint16_t val16;\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (iio_buffer_enabled(indio_dev))\n\t\t\treturn -EBUSY;\n\t\tret = xadc_read_adc_reg(xadc, chan->address, &val16);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval16 >>= chan->scan_type.shift;\n\t\tif (chan->scan_type.sign == 'u')\n\t\t\t*val = val16;\n\t\telse\n\t\t\t*val = sign_extend32(val16, bits - 1);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\t \n\t\t\tswitch (chan->address) {\n\t\t\tcase XADC_REG_VCCINT:\n\t\t\tcase XADC_REG_VCCAUX:\n\t\t\tcase XADC_REG_VREFP:\n\t\t\tcase XADC_REG_VREFN:\n\t\t\tcase XADC_REG_VCCBRAM:\n\t\t\tcase XADC_REG_VCCPINT:\n\t\t\tcase XADC_REG_VCCPAUX:\n\t\t\tcase XADC_REG_VCCO_DDR:\n\t\t\t\t*val = 3000;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*val = 1000;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*val2 = bits;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\tcase IIO_TEMP:\n\t\t\t*val = xadc->ops->temp_scale;\n\t\t\t*val2 = bits;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\t*val = -((xadc->ops->temp_offset << bits) / xadc->ops->temp_scale);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = xadc_read_samplerate(xadc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int xadc_write_samplerate(struct xadc *xadc, int val)\n{\n\tunsigned long clk_rate = xadc_get_dclk_rate(xadc);\n\tunsigned int div;\n\n\tif (!clk_rate)\n\t\treturn -EINVAL;\n\n\tif (val <= 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (val > XADC_MAX_SAMPLERATE)\n\t\tval = XADC_MAX_SAMPLERATE;\n\n\tval *= 26;\n\n\t \n\tif (val < 1000000)\n\t\tval = 1000000;\n\n\t \n\tdiv = clk_rate / val;\n\tif (clk_rate / div / 26 > XADC_MAX_SAMPLERATE)\n\t\tdiv++;\n\tif (div < 2)\n\t\tdiv = 2;\n\telse if (div > 0xff)\n\t\tdiv = 0xff;\n\n\treturn xadc_update_adc_reg(xadc, XADC_REG_CONF2, XADC_CONF2_DIV_MASK,\n\t\tdiv << XADC_CONF2_DIV_OFFSET);\n}\n\nstatic int xadc_write_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int val, int val2, long info)\n{\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\n\tif (info != IIO_CHAN_INFO_SAMP_FREQ)\n\t\treturn -EINVAL;\n\n\treturn xadc_write_samplerate(xadc, val);\n}\n\nstatic const struct iio_event_spec xadc_temp_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t\tBIT(IIO_EV_INFO_VALUE) |\n\t\t\t\tBIT(IIO_EV_INFO_HYSTERESIS),\n\t},\n};\n\n \nstatic const struct iio_event_spec xadc_voltage_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\n#define XADC_CHAN_TEMP(_chan, _scan_index, _addr, _bits) { \\\n\t.type = IIO_TEMP, \\\n\t.indexed = 1, \\\n\t.channel = (_chan), \\\n\t.address = (_addr), \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\tBIT(IIO_CHAN_INFO_SCALE) | \\\n\t\tBIT(IIO_CHAN_INFO_OFFSET), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.event_spec = xadc_temp_events, \\\n\t.num_event_specs = ARRAY_SIZE(xadc_temp_events), \\\n\t.scan_index = (_scan_index), \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = (_bits), \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 16 - (_bits), \\\n\t\t.endianness = IIO_CPU, \\\n\t}, \\\n}\n\n#define XADC_CHAN_VOLTAGE(_chan, _scan_index, _addr, _bits, _ext, _alarm) { \\\n\t.type = IIO_VOLTAGE, \\\n\t.indexed = 1, \\\n\t.channel = (_chan), \\\n\t.address = (_addr), \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\tBIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.event_spec = (_alarm) ? xadc_voltage_events : NULL, \\\n\t.num_event_specs = (_alarm) ? ARRAY_SIZE(xadc_voltage_events) : 0, \\\n\t.scan_index = (_scan_index), \\\n\t.scan_type = { \\\n\t\t.sign = ((_addr) == XADC_REG_VREFN) ? 's' : 'u', \\\n\t\t.realbits = (_bits), \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 16 - (_bits), \\\n\t\t.endianness = IIO_CPU, \\\n\t}, \\\n\t.extend_name = _ext, \\\n}\n\n \n#define XADC_7S_CHAN_TEMP(_chan, _scan_index, _addr) \\\n\tXADC_CHAN_TEMP(_chan, _scan_index, _addr, 12)\n#define XADC_7S_CHAN_VOLTAGE(_chan, _scan_index, _addr, _ext, _alarm) \\\n\tXADC_CHAN_VOLTAGE(_chan, _scan_index, _addr, 12, _ext, _alarm)\n\nstatic const struct iio_chan_spec xadc_7s_channels[] = {\n\tXADC_7S_CHAN_TEMP(0, 8, XADC_REG_TEMP),\n\tXADC_7S_CHAN_VOLTAGE(0, 9, XADC_REG_VCCINT, \"vccint\", true),\n\tXADC_7S_CHAN_VOLTAGE(1, 10, XADC_REG_VCCAUX, \"vccaux\", true),\n\tXADC_7S_CHAN_VOLTAGE(2, 14, XADC_REG_VCCBRAM, \"vccbram\", true),\n\tXADC_7S_CHAN_VOLTAGE(3, 5, XADC_REG_VCCPINT, \"vccpint\", true),\n\tXADC_7S_CHAN_VOLTAGE(4, 6, XADC_REG_VCCPAUX, \"vccpaux\", true),\n\tXADC_7S_CHAN_VOLTAGE(5, 7, XADC_REG_VCCO_DDR, \"vccoddr\", true),\n\tXADC_7S_CHAN_VOLTAGE(6, 12, XADC_REG_VREFP, \"vrefp\", false),\n\tXADC_7S_CHAN_VOLTAGE(7, 13, XADC_REG_VREFN, \"vrefn\", false),\n\tXADC_7S_CHAN_VOLTAGE(8, 11, XADC_REG_VPVN, NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(9, 16, XADC_REG_VAUX(0), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(10, 17, XADC_REG_VAUX(1), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(11, 18, XADC_REG_VAUX(2), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(12, 19, XADC_REG_VAUX(3), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(13, 20, XADC_REG_VAUX(4), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(14, 21, XADC_REG_VAUX(5), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(15, 22, XADC_REG_VAUX(6), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(16, 23, XADC_REG_VAUX(7), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(17, 24, XADC_REG_VAUX(8), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(18, 25, XADC_REG_VAUX(9), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(19, 26, XADC_REG_VAUX(10), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(20, 27, XADC_REG_VAUX(11), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(21, 28, XADC_REG_VAUX(12), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(22, 29, XADC_REG_VAUX(13), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(23, 30, XADC_REG_VAUX(14), NULL, false),\n\tXADC_7S_CHAN_VOLTAGE(24, 31, XADC_REG_VAUX(15), NULL, false),\n};\n\n \n#define XADC_US_CHAN_TEMP(_chan, _scan_index, _addr) \\\n\tXADC_CHAN_TEMP(_chan, _scan_index, _addr, 10)\n#define XADC_US_CHAN_VOLTAGE(_chan, _scan_index, _addr, _ext, _alarm) \\\n\tXADC_CHAN_VOLTAGE(_chan, _scan_index, _addr, 10, _ext, _alarm)\n\nstatic const struct iio_chan_spec xadc_us_channels[] = {\n\tXADC_US_CHAN_TEMP(0, 8, XADC_REG_TEMP),\n\tXADC_US_CHAN_VOLTAGE(0, 9, XADC_REG_VCCINT, \"vccint\", true),\n\tXADC_US_CHAN_VOLTAGE(1, 10, XADC_REG_VCCAUX, \"vccaux\", true),\n\tXADC_US_CHAN_VOLTAGE(2, 14, XADC_REG_VCCBRAM, \"vccbram\", true),\n\tXADC_US_CHAN_VOLTAGE(3, 5, XADC_REG_VCCPINT, \"vccpsintlp\", true),\n\tXADC_US_CHAN_VOLTAGE(4, 6, XADC_REG_VCCPAUX, \"vccpsintfp\", true),\n\tXADC_US_CHAN_VOLTAGE(5, 7, XADC_REG_VCCO_DDR, \"vccpsaux\", true),\n\tXADC_US_CHAN_VOLTAGE(6, 12, XADC_REG_VREFP, \"vrefp\", false),\n\tXADC_US_CHAN_VOLTAGE(7, 13, XADC_REG_VREFN, \"vrefn\", false),\n\tXADC_US_CHAN_VOLTAGE(8, 11, XADC_REG_VPVN, NULL, false),\n\tXADC_US_CHAN_VOLTAGE(9, 16, XADC_REG_VAUX(0), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(10, 17, XADC_REG_VAUX(1), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(11, 18, XADC_REG_VAUX(2), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(12, 19, XADC_REG_VAUX(3), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(13, 20, XADC_REG_VAUX(4), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(14, 21, XADC_REG_VAUX(5), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(15, 22, XADC_REG_VAUX(6), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(16, 23, XADC_REG_VAUX(7), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(17, 24, XADC_REG_VAUX(8), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(18, 25, XADC_REG_VAUX(9), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(19, 26, XADC_REG_VAUX(10), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(20, 27, XADC_REG_VAUX(11), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(21, 28, XADC_REG_VAUX(12), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(22, 29, XADC_REG_VAUX(13), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(23, 30, XADC_REG_VAUX(14), NULL, false),\n\tXADC_US_CHAN_VOLTAGE(24, 31, XADC_REG_VAUX(15), NULL, false),\n};\n\nstatic const struct iio_info xadc_info = {\n\t.read_raw = &xadc_read_raw,\n\t.write_raw = &xadc_write_raw,\n\t.read_event_config = &xadc_read_event_config,\n\t.write_event_config = &xadc_write_event_config,\n\t.read_event_value = &xadc_read_event_value,\n\t.write_event_value = &xadc_write_event_value,\n\t.update_scan_mode = &xadc_update_scan_mode,\n};\n\nstatic const struct of_device_id xadc_of_match_table[] = {\n\t{\n\t\t.compatible = \"xlnx,zynq-xadc-1.00.a\",\n\t\t.data = &xadc_zynq_ops\n\t}, {\n\t\t.compatible = \"xlnx,axi-xadc-1.00.a\",\n\t\t.data = &xadc_7s_axi_ops\n\t}, {\n\t\t.compatible = \"xlnx,system-management-wiz-1.3\",\n\t\t.data = &xadc_us_axi_ops\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, xadc_of_match_table);\n\nstatic int xadc_parse_dt(struct iio_dev *indio_dev, unsigned int *conf, int irq)\n{\n\tstruct device *dev = indio_dev->dev.parent;\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\tconst struct iio_chan_spec *channel_templates;\n\tstruct iio_chan_spec *channels, *chan;\n\tstruct fwnode_handle *chan_node, *child;\n\tunsigned int max_channels;\n\tunsigned int num_channels;\n\tconst char *external_mux;\n\tu32 ext_mux_chan;\n\tu32 reg;\n\tint ret;\n\tint i;\n\n\t*conf = 0;\n\n\tret = device_property_read_string(dev, \"xlnx,external-mux\", &external_mux);\n\tif (ret < 0 || strcasecmp(external_mux, \"none\") == 0)\n\t\txadc->external_mux_mode = XADC_EXTERNAL_MUX_NONE;\n\telse if (strcasecmp(external_mux, \"single\") == 0)\n\t\txadc->external_mux_mode = XADC_EXTERNAL_MUX_SINGLE;\n\telse if (strcasecmp(external_mux, \"dual\") == 0)\n\t\txadc->external_mux_mode = XADC_EXTERNAL_MUX_DUAL;\n\telse\n\t\treturn -EINVAL;\n\n\tif (xadc->external_mux_mode != XADC_EXTERNAL_MUX_NONE) {\n\t\tret = device_property_read_u32(dev, \"xlnx,external-mux-channel\", &ext_mux_chan);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (xadc->external_mux_mode == XADC_EXTERNAL_MUX_SINGLE) {\n\t\t\tif (ext_mux_chan == 0)\n\t\t\t\text_mux_chan = XADC_REG_VPVN;\n\t\t\telse if (ext_mux_chan <= 16)\n\t\t\t\text_mux_chan = XADC_REG_VAUX(ext_mux_chan - 1);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (ext_mux_chan > 0 && ext_mux_chan <= 8)\n\t\t\t\text_mux_chan = XADC_REG_VAUX(ext_mux_chan - 1);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*conf |= XADC_CONF0_MUX | XADC_CONF0_CHAN(ext_mux_chan);\n\t}\n\tif (xadc->ops->type == XADC_TYPE_S7) {\n\t\tchannel_templates = xadc_7s_channels;\n\t\tmax_channels = ARRAY_SIZE(xadc_7s_channels);\n\t} else {\n\t\tchannel_templates = xadc_us_channels;\n\t\tmax_channels = ARRAY_SIZE(xadc_us_channels);\n\t}\n\tchannels = devm_kmemdup(dev, channel_templates,\n\t\t\t\tsizeof(channels[0]) * max_channels, GFP_KERNEL);\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\tnum_channels = 9;\n\tchan = &channels[9];\n\n\tchan_node = device_get_named_child_node(dev, \"xlnx,channels\");\n\tfwnode_for_each_child_node(chan_node, child) {\n\t\tif (num_channels >= max_channels) {\n\t\t\tfwnode_handle_put(child);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\tif (ret || reg > 16)\n\t\t\tcontinue;\n\n\t\tif (fwnode_property_read_bool(child, \"xlnx,bipolar\"))\n\t\t\tchan->scan_type.sign = 's';\n\n\t\tif (reg == 0) {\n\t\t\tchan->scan_index = 11;\n\t\t\tchan->address = XADC_REG_VPVN;\n\t\t} else {\n\t\t\tchan->scan_index = 15 + reg;\n\t\t\tchan->address = XADC_REG_VAUX(reg - 1);\n\t\t}\n\t\tnum_channels++;\n\t\tchan++;\n\t}\n\tfwnode_handle_put(chan_node);\n\n\t \n\tif (irq <= 0) {\n\t\tfor (i = 0; i < num_channels; i++) {\n\t\t\tchannels[i].event_spec = NULL;\n\t\t\tchannels[i].num_event_specs = 0;\n\t\t}\n\t}\n\n\tindio_dev->num_channels = num_channels;\n\tindio_dev->channels = devm_krealloc_array(dev, channels,\n\t\t\t\t\t\t  num_channels, sizeof(*channels),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t \n\tif (!indio_dev->channels)\n\t\tindio_dev->channels = channels;\n\n\treturn 0;\n}\n\nstatic const char * const xadc_type_names[] = {\n\t[XADC_TYPE_S7] = \"xadc\",\n\t[XADC_TYPE_US] = \"xilinx-system-monitor\",\n};\n\nstatic void xadc_cancel_delayed_work(void *data)\n{\n\tstruct delayed_work *work = data;\n\n\tcancel_delayed_work_sync(work);\n}\n\nstatic int xadc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct xadc_ops *ops;\n\tstruct iio_dev *indio_dev;\n\tunsigned int bipolar_mask;\n\tunsigned int conf0;\n\tstruct xadc *xadc;\n\tint ret;\n\tint irq;\n\tint i;\n\n\tops = device_get_match_data(dev);\n\tif (!ops)\n\t\treturn -EINVAL;\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq < 0 &&\n\t    (irq != -ENXIO || !(ops->flags & XADC_FLAGS_IRQ_OPTIONAL)))\n\t\treturn irq;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*xadc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\txadc = iio_priv(indio_dev);\n\txadc->ops = ops;\n\tinit_completion(&xadc->completion);\n\tmutex_init(&xadc->mutex);\n\tspin_lock_init(&xadc->lock);\n\tINIT_DELAYED_WORK(&xadc->zynq_unmask_work, xadc_zynq_unmask_worker);\n\n\txadc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(xadc->base))\n\t\treturn PTR_ERR(xadc->base);\n\n\tindio_dev->name = xadc_type_names[xadc->ops->type];\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &xadc_info;\n\n\tret = xadc_parse_dt(indio_dev, &conf0, irq);\n\tif (ret)\n\t\treturn ret;\n\n\tif (xadc->ops->flags & XADC_FLAGS_BUFFERED) {\n\t\tret = devm_iio_triggered_buffer_setup(dev, indio_dev,\n\t\t\t\t\t\t      &iio_pollfunc_store_time,\n\t\t\t\t\t\t      &xadc_trigger_handler,\n\t\t\t\t\t\t      &xadc_buffer_ops);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (irq > 0) {\n\t\t\txadc->convst_trigger = xadc_alloc_trigger(indio_dev, \"convst\");\n\t\t\tif (IS_ERR(xadc->convst_trigger))\n\t\t\t\treturn PTR_ERR(xadc->convst_trigger);\n\n\t\t\txadc->samplerate_trigger = xadc_alloc_trigger(indio_dev,\n\t\t\t\t\"samplerate\");\n\t\t\tif (IS_ERR(xadc->samplerate_trigger))\n\t\t\t\treturn PTR_ERR(xadc->samplerate_trigger);\n\t\t}\n\t}\n\n\txadc->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(xadc->clk))\n\t\treturn PTR_ERR(xadc->clk);\n\n\t \n\tif (xadc->ops->flags & XADC_FLAGS_BUFFERED) {\n\t\tret = xadc_read_samplerate(xadc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret > XADC_MAX_SAMPLERATE) {\n\t\t\tret = xadc_write_samplerate(xadc, XADC_MAX_SAMPLERATE);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (irq > 0) {\n\t\tret = devm_request_irq(dev, irq, xadc->ops->interrupt_handler,\n\t\t\t\t       0, dev_name(dev), indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(dev, xadc_cancel_delayed_work,\n\t\t\t\t\t       &xadc->zynq_unmask_work);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = xadc->ops->setup(pdev, indio_dev, irq);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < 16; i++)\n\t\txadc_read_adc_reg(xadc, XADC_REG_THRESHOLD(i),\n\t\t\t&xadc->threshold[i]);\n\n\tret = xadc_write_adc_reg(xadc, XADC_REG_CONF0, conf0);\n\tif (ret)\n\t\treturn ret;\n\n\tbipolar_mask = 0;\n\tfor (i = 0; i < indio_dev->num_channels; i++) {\n\t\tif (indio_dev->channels[i].scan_type.sign == 's')\n\t\t\tbipolar_mask |= BIT(indio_dev->channels[i].scan_index);\n\t}\n\n\tret = xadc_write_adc_reg(xadc, XADC_REG_INPUT_MODE(0), bipolar_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xadc_write_adc_reg(xadc, XADC_REG_INPUT_MODE(1),\n\t\tbipolar_mask >> 16);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\txadc_postdisable(indio_dev);\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic struct platform_driver xadc_driver = {\n\t.probe = xadc_probe,\n\t.driver = {\n\t\t.name = \"xadc\",\n\t\t.of_match_table = xadc_of_match_table,\n\t},\n};\nmodule_platform_driver(xadc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Xilinx XADC IIO driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}