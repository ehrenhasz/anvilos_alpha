{
  "module_name": "axp288_adc.c",
  "hash_id": "d63029418a2e12d2d6d51e44c408b4086a91775eba3e9634adf7129cf30fa5d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/axp288_adc.c",
  "human_readable_source": "\n \n\n#include <linux/dmi.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/regmap.h>\n#include <linux/mfd/axp20x.h>\n#include <linux/platform_device.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/machine.h>\n#include <linux/iio/driver.h>\n\n \n#define AXP288_ADC_EN_MASK\t\t\t\t0xF0\n#define AXP288_ADC_TS_ENABLE\t\t\t\t0x01\n\n#define AXP288_ADC_TS_BIAS_MASK\t\t\t\tGENMASK(5, 4)\n#define AXP288_ADC_TS_BIAS_20UA\t\t\t\t(0 << 4)\n#define AXP288_ADC_TS_BIAS_40UA\t\t\t\t(1 << 4)\n#define AXP288_ADC_TS_BIAS_60UA\t\t\t\t(2 << 4)\n#define AXP288_ADC_TS_BIAS_80UA\t\t\t\t(3 << 4)\n#define AXP288_ADC_TS_CURRENT_ON_OFF_MASK\t\tGENMASK(1, 0)\n#define AXP288_ADC_TS_CURRENT_OFF\t\t\t(0 << 0)\n#define AXP288_ADC_TS_CURRENT_ON_WHEN_CHARGING\t\t(1 << 0)\n#define AXP288_ADC_TS_CURRENT_ON_ONDEMAND\t\t(2 << 0)\n#define AXP288_ADC_TS_CURRENT_ON\t\t\t(3 << 0)\n\nenum axp288_adc_id {\n\tAXP288_ADC_TS,\n\tAXP288_ADC_PMIC,\n\tAXP288_ADC_GP,\n\tAXP288_ADC_BATT_CHRG_I,\n\tAXP288_ADC_BATT_DISCHRG_I,\n\tAXP288_ADC_BATT_V,\n\tAXP288_ADC_NR_CHAN,\n};\n\nstruct axp288_adc_info {\n\tint irq;\n\tstruct regmap *regmap;\n\t \n\tstruct mutex lock;\n\tbool ts_enabled;\n};\n\nstatic const struct iio_chan_spec axp288_adc_channels[] = {\n\t{\n\t\t.indexed = 1,\n\t\t.type = IIO_TEMP,\n\t\t.channel = 0,\n\t\t.address = AXP288_TS_ADC_H,\n\t\t.datasheet_name = \"TS_PIN\",\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t}, {\n\t\t.indexed = 1,\n\t\t.type = IIO_TEMP,\n\t\t.channel = 1,\n\t\t.address = AXP288_PMIC_ADC_H,\n\t\t.datasheet_name = \"PMIC_TEMP\",\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t}, {\n\t\t.indexed = 1,\n\t\t.type = IIO_TEMP,\n\t\t.channel = 2,\n\t\t.address = AXP288_GP_ADC_H,\n\t\t.datasheet_name = \"GPADC\",\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t}, {\n\t\t.indexed = 1,\n\t\t.type = IIO_CURRENT,\n\t\t.channel = 3,\n\t\t.address = AXP20X_BATT_CHRG_I_H,\n\t\t.datasheet_name = \"BATT_CHG_I\",\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t}, {\n\t\t.indexed = 1,\n\t\t.type = IIO_CURRENT,\n\t\t.channel = 4,\n\t\t.address = AXP20X_BATT_DISCHRG_I_H,\n\t\t.datasheet_name = \"BATT_DISCHRG_I\",\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t}, {\n\t\t.indexed = 1,\n\t\t.type = IIO_VOLTAGE,\n\t\t.channel = 5,\n\t\t.address = AXP20X_BATT_V_H,\n\t\t.datasheet_name = \"BATT_V\",\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t},\n};\n\n \nstatic struct iio_map axp288_adc_default_maps[] = {\n\tIIO_MAP(\"TS_PIN\", \"axp288-batt\", \"axp288-batt-temp\"),\n\tIIO_MAP(\"PMIC_TEMP\", \"axp288-pmic\", \"axp288-pmic-temp\"),\n\tIIO_MAP(\"GPADC\", \"axp288-gpadc\", \"axp288-system-temp\"),\n\tIIO_MAP(\"BATT_CHG_I\", \"axp288-chrg\", \"axp288-chrg-curr\"),\n\tIIO_MAP(\"BATT_DISCHRG_I\", \"axp288-chrg\", \"axp288-chrg-d-curr\"),\n\tIIO_MAP(\"BATT_V\", \"axp288-batt\", \"axp288-batt-volt\"),\n\t{},\n};\n\nstatic int axp288_adc_read_channel(int *val, unsigned long address,\n\t\t\t\tstruct regmap *regmap)\n{\n\tu8 buf[2];\n\n\tif (regmap_bulk_read(regmap, address, buf, 2))\n\t\treturn -EIO;\n\t*val = (buf[0] << 4) + ((buf[1] >> 4) & 0x0F);\n\n\treturn IIO_VAL_INT;\n}\n\n \nstatic int axp288_adc_set_ts(struct axp288_adc_info *info,\n\t\t\t     unsigned int mode, unsigned long address)\n{\n\tint ret;\n\n\t \n\tif (!info->ts_enabled)\n\t\treturn 0;\n\n\t \n\tif (address != AXP288_GP_ADC_H)\n\t\treturn 0;\n\n\tret = regmap_update_bits(info->regmap, AXP288_ADC_TS_PIN_CTRL,\n\t\t\t\t AXP288_ADC_TS_CURRENT_ON_OFF_MASK, mode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (mode == AXP288_ADC_TS_CURRENT_ON_ONDEMAND)\n\t\tusleep_range(6000, 10000);\n\n\treturn 0;\n}\n\nstatic int axp288_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint *val, int *val2, long mask)\n{\n\tint ret;\n\tstruct axp288_adc_info *info = iio_priv(indio_dev);\n\n\tmutex_lock(&info->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (axp288_adc_set_ts(info, AXP288_ADC_TS_CURRENT_ON_ONDEMAND,\n\t\t\t\t\tchan->address)) {\n\t\t\tdev_err(&indio_dev->dev, \"GPADC mode\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = axp288_adc_read_channel(val, chan->address, info->regmap);\n\t\tif (axp288_adc_set_ts(info, AXP288_ADC_TS_CURRENT_ON,\n\t\t\t\t\t\tchan->address))\n\t\t\tdev_err(&indio_dev->dev, \"TS pin restore\\n\");\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&info->lock);\n\n\treturn ret;\n}\n\n \nstatic const struct dmi_system_id axp288_adc_ts_bias_override[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t  DMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t  DMI_MATCH(DMI_PRODUCT_VERSION, \"Lenovo ideapad 100S-11IBY\"),\n\t\t},\n\t\t.driver_data = (void *)(uintptr_t)AXP288_ADC_TS_BIAS_80UA,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t  DMI_MATCH(DMI_SYS_VENDOR, \"TMAX\"),\n\t\t  DMI_MATCH(DMI_PRODUCT_NAME, \"TM101W610L\"),\n\t\t},\n\t\t.driver_data = (void *)(uintptr_t)AXP288_ADC_TS_BIAS_80UA,\n\t},\n\t{}\n};\n\nstatic int axp288_adc_initialize(struct axp288_adc_info *info)\n{\n\tconst struct dmi_system_id *bias_override;\n\tint ret, adc_enable_val;\n\n\tbias_override = dmi_first_match(axp288_adc_ts_bias_override);\n\tif (bias_override) {\n\t\tret = regmap_update_bits(info->regmap, AXP288_ADC_TS_PIN_CTRL,\n\t\t\t\t\t AXP288_ADC_TS_BIAS_MASK,\n\t\t\t\t\t (uintptr_t)bias_override->driver_data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_read(info->regmap, AXP20X_ADC_EN1, &adc_enable_val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adc_enable_val & AXP288_ADC_TS_ENABLE) {\n\t\tinfo->ts_enabled = true;\n\t\tret = regmap_update_bits(info->regmap, AXP288_ADC_TS_PIN_CTRL,\n\t\t\t\t\t AXP288_ADC_TS_CURRENT_ON_OFF_MASK,\n\t\t\t\t\t AXP288_ADC_TS_CURRENT_ON);\n\t} else {\n\t\tinfo->ts_enabled = false;\n\t\tret = regmap_update_bits(info->regmap, AXP288_ADC_TS_PIN_CTRL,\n\t\t\t\t\t AXP288_ADC_TS_CURRENT_ON_OFF_MASK,\n\t\t\t\t\t AXP288_ADC_TS_CURRENT_OFF);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(info->regmap, AXP20X_ADC_EN1,\n\t\t\t\t  AXP288_ADC_EN_MASK, AXP288_ADC_EN_MASK);\n}\n\nstatic const struct iio_info axp288_adc_iio_info = {\n\t.read_raw = &axp288_adc_read_raw,\n};\n\nstatic int axp288_adc_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct axp288_adc_info *info;\n\tstruct iio_dev *indio_dev;\n\tstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*info));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tinfo = iio_priv(indio_dev);\n\tinfo->irq = platform_get_irq(pdev, 0);\n\tif (info->irq < 0)\n\t\treturn info->irq;\n\n\tinfo->regmap = axp20x->regmap;\n\t \n\tret = axp288_adc_initialize(info);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to enable ADC device\\n\");\n\t\treturn ret;\n\t}\n\n\tindio_dev->name = pdev->name;\n\tindio_dev->channels = axp288_adc_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(axp288_adc_channels);\n\tindio_dev->info = &axp288_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = devm_iio_map_array_register(&pdev->dev, indio_dev, axp288_adc_default_maps);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_init(&info->lock);\n\n\treturn devm_iio_device_register(&pdev->dev, indio_dev);\n}\n\nstatic const struct platform_device_id axp288_adc_id_table[] = {\n\t{ .name = \"axp288_adc\" },\n\t{},\n};\n\nstatic struct platform_driver axp288_adc_driver = {\n\t.probe = axp288_adc_probe,\n\t.id_table = axp288_adc_id_table,\n\t.driver = {\n\t\t.name = \"axp288_adc\",\n\t},\n};\n\nMODULE_DEVICE_TABLE(platform, axp288_adc_id_table);\n\nmodule_platform_driver(axp288_adc_driver);\n\nMODULE_AUTHOR(\"Jacob Pan <jacob.jun.pan@linux.intel.com>\");\nMODULE_DESCRIPTION(\"X-Powers AXP288 ADC Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}