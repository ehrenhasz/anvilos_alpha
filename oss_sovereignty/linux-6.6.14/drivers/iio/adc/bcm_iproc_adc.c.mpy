{
  "module_name": "bcm_iproc_adc.c",
  "hash_id": "ab517dad64f9849062d5bb393d27d66560b46a4126cf5ac19f8bc17492a26ce9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/bcm_iproc_adc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n\n#include <linux/iio/iio.h>\n\n \n#define IPROC_REGCTL1\t\t\t0x00\n#define IPROC_REGCTL2\t\t\t0x04\n#define IPROC_INTERRUPT_THRES\t\t0x08\n#define IPROC_INTERRUPT_MASK\t\t0x0c\n#define IPROC_INTERRUPT_STATUS\t\t0x10\n#define IPROC_ANALOG_CONTROL\t\t0x1c\n#define IPROC_CONTROLLER_STATUS\t\t0x14\n#define IPROC_AUX_DATA\t\t\t0x20\n#define IPROC_SOFT_BYPASS_CONTROL\t0x38\n#define IPROC_SOFT_BYPASS_DATA\t\t0x3C\n\n \n#define IPROC_ADC_CHANNEL_REGCTL1\t\t0x800\n#define IPROC_ADC_CHANNEL_REGCTL2\t\t0x804\n#define IPROC_ADC_CHANNEL_STATUS\t\t0x808\n#define IPROC_ADC_CHANNEL_INTERRUPT_STATUS\t0x80c\n#define IPROC_ADC_CHANNEL_INTERRUPT_MASK\t0x810\n#define IPROC_ADC_CHANNEL_DATA\t\t\t0x814\n#define IPROC_ADC_CHANNEL_OFFSET\t\t0x20\n\n \n#define IPROC_ADC_AUXIN_SCAN_ENA\tBIT(0)\n#define IPROC_ADC_PWR_LDO\t\tBIT(5)\n#define IPROC_ADC_PWR_ADC\t\tBIT(4)\n#define IPROC_ADC_PWR_BG\t\tBIT(3)\n#define IPROC_ADC_CONTROLLER_EN\t\tBIT(17)\n\n \n#define IPROC_ADC_AUXDATA_RDY_INTR\tBIT(3)\n#define IPROC_ADC_INTR\t\t\t9\n#define IPROC_ADC_INTR_MASK\t\t(0xFF << IPROC_ADC_INTR)\n\n \n#define IPROC_ADC_CHANNEL_SEL\t\t11\n#define IPROC_ADC_CHANNEL_SEL_MASK\t(0x7 << IPROC_ADC_CHANNEL_SEL)\n\n \n#define IPROC_ADC_CHANNEL_ROUNDS\t0x2\n#define IPROC_ADC_CHANNEL_ROUNDS_MASK\t(0x3F << IPROC_ADC_CHANNEL_ROUNDS)\n#define IPROC_ADC_CHANNEL_MODE\t\t0x1\n#define IPROC_ADC_CHANNEL_MODE_MASK\t(0x1 << IPROC_ADC_CHANNEL_MODE)\n#define IPROC_ADC_CHANNEL_MODE_TDM\t0x1\n#define IPROC_ADC_CHANNEL_MODE_SNAPSHOT 0x0\n#define IPROC_ADC_CHANNEL_ENABLE\t0x0\n#define IPROC_ADC_CHANNEL_ENABLE_MASK\t0x1\n\n \n#define IPROC_ADC_CHANNEL_WATERMARK\t0x0\n#define IPROC_ADC_CHANNEL_WATERMARK_MASK \\\n\t\t(0x3F << IPROC_ADC_CHANNEL_WATERMARK)\n\n#define IPROC_ADC_WATER_MARK_LEVEL\t0x1\n\n \n#define IPROC_ADC_CHANNEL_DATA_LOST\t\t0x0\n#define IPROC_ADC_CHANNEL_DATA_LOST_MASK\t\\\n\t\t(0x0 << IPROC_ADC_CHANNEL_DATA_LOST)\n#define IPROC_ADC_CHANNEL_VALID_ENTERIES\t0x1\n#define IPROC_ADC_CHANNEL_VALID_ENTERIES_MASK\t\\\n\t\t(0xFF << IPROC_ADC_CHANNEL_VALID_ENTERIES)\n#define IPROC_ADC_CHANNEL_TOTAL_ENTERIES\t0x9\n#define IPROC_ADC_CHANNEL_TOTAL_ENTERIES_MASK\t\\\n\t\t(0xFF << IPROC_ADC_CHANNEL_TOTAL_ENTERIES)\n\n \n#define IPROC_ADC_CHANNEL_WTRMRK_INTR\t\t\t0x0\n#define IPROC_ADC_CHANNEL_WTRMRK_INTR_MASK\t\t\\\n\t\t(0x1 << IPROC_ADC_CHANNEL_WTRMRK_INTR)\n#define IPROC_ADC_CHANNEL_FULL_INTR\t\t\t0x1\n#define IPROC_ADC_CHANNEL_FULL_INTR_MASK\t\t\\\n\t\t(0x1 << IPROC_ADC_IPROC_ADC_CHANNEL_FULL_INTR)\n#define IPROC_ADC_CHANNEL_EMPTY_INTR\t\t\t0x2\n#define IPROC_ADC_CHANNEL_EMPTY_INTR_MASK\t\t\\\n\t\t(0x1 << IPROC_ADC_CHANNEL_EMPTY_INTR)\n\n#define IPROC_ADC_WATER_MARK_INTR_ENABLE\t\t0x1\n\n \n#define IPROC_ADC_INTMASK_RETRY_ATTEMPTS\t\t10\n\n#define IPROC_ADC_READ_TIMEOUT        (HZ*2)\n\n#define iproc_adc_dbg_reg(dev, priv, reg) \\\ndo { \\\n\tu32 val; \\\n\tregmap_read(priv->regmap, reg, &val); \\\n\tdev_dbg(dev, \"%20s= 0x%08x\\n\", #reg, val); \\\n} while (0)\n\nstruct iproc_adc_priv {\n\tstruct regmap *regmap;\n\tstruct clk *adc_clk;\n\tstruct mutex mutex;\n\tint  irqno;\n\tint chan_val;\n\tint chan_id;\n\tstruct completion completion;\n};\n\nstatic void iproc_adc_reg_dump(struct iio_dev *indio_dev)\n{\n\tstruct device *dev = &indio_dev->dev;\n\tstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\n\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_REGCTL1);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_REGCTL2);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_INTERRUPT_THRES);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_INTERRUPT_MASK);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_INTERRUPT_STATUS);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_CONTROLLER_STATUS);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_ANALOG_CONTROL);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_AUX_DATA);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_SOFT_BYPASS_CONTROL);\n\tiproc_adc_dbg_reg(dev, adc_priv, IPROC_SOFT_BYPASS_DATA);\n}\n\nstatic irqreturn_t iproc_adc_interrupt_thread(int irq, void *data)\n{\n\tu32 channel_intr_status;\n\tu32 intr_status;\n\tu32 intr_mask;\n\tstruct iio_dev *indio_dev = data;\n\tstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\n\n\t \n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_STATUS, &intr_status);\n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_MASK, &intr_mask);\n\tintr_status = intr_status & intr_mask;\n\tchannel_intr_status = (intr_status & IPROC_ADC_INTR_MASK) >>\n\t\t\t\tIPROC_ADC_INTR;\n\tif (channel_intr_status)\n\t\treturn IRQ_WAKE_THREAD;\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t iproc_adc_interrupt_handler(int irq, void *data)\n{\n\tirqreturn_t retval = IRQ_NONE;\n\tstruct iproc_adc_priv *adc_priv;\n\tstruct iio_dev *indio_dev = data;\n\tunsigned int valid_entries;\n\tu32 intr_status;\n\tu32 intr_channels;\n\tu32 channel_status;\n\tu32 ch_intr_status;\n\n\tadc_priv = iio_priv(indio_dev);\n\n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_STATUS, &intr_status);\n\tdev_dbg(&indio_dev->dev, \"iproc_adc_interrupt_handler(),INTRPT_STS:%x\\n\",\n\t\t\tintr_status);\n\n\tintr_channels = (intr_status & IPROC_ADC_INTR_MASK) >> IPROC_ADC_INTR;\n\tif (intr_channels) {\n\t\tregmap_read(adc_priv->regmap,\n\t\t\t    IPROC_ADC_CHANNEL_INTERRUPT_STATUS +\n\t\t\t    IPROC_ADC_CHANNEL_OFFSET * adc_priv->chan_id,\n\t\t\t    &ch_intr_status);\n\n\t\tif (ch_intr_status & IPROC_ADC_CHANNEL_WTRMRK_INTR_MASK) {\n\t\t\tregmap_read(adc_priv->regmap,\n\t\t\t\t\tIPROC_ADC_CHANNEL_STATUS +\n\t\t\t\t\tIPROC_ADC_CHANNEL_OFFSET *\n\t\t\t\t\tadc_priv->chan_id,\n\t\t\t\t\t&channel_status);\n\n\t\t\tvalid_entries = ((channel_status &\n\t\t\t\tIPROC_ADC_CHANNEL_VALID_ENTERIES_MASK) >>\n\t\t\t\tIPROC_ADC_CHANNEL_VALID_ENTERIES);\n\t\t\tif (valid_entries >= 1) {\n\t\t\t\tregmap_read(adc_priv->regmap,\n\t\t\t\t\tIPROC_ADC_CHANNEL_DATA +\n\t\t\t\t\tIPROC_ADC_CHANNEL_OFFSET *\n\t\t\t\t\tadc_priv->chan_id,\n\t\t\t\t\t&adc_priv->chan_val);\n\t\t\t\tcomplete(&adc_priv->completion);\n\t\t\t} else {\n\t\t\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\t\"No data rcvd on channel %d\\n\",\n\t\t\t\t\tadc_priv->chan_id);\n\t\t\t}\n\t\t\tregmap_write(adc_priv->regmap,\n\t\t\t\t\tIPROC_ADC_CHANNEL_INTERRUPT_MASK +\n\t\t\t\t\tIPROC_ADC_CHANNEL_OFFSET *\n\t\t\t\t\tadc_priv->chan_id,\n\t\t\t\t\t(ch_intr_status &\n\t\t\t\t\t~(IPROC_ADC_CHANNEL_WTRMRK_INTR_MASK)));\n\t\t}\n\t\tregmap_write(adc_priv->regmap,\n\t\t\t\tIPROC_ADC_CHANNEL_INTERRUPT_STATUS +\n\t\t\t\tIPROC_ADC_CHANNEL_OFFSET * adc_priv->chan_id,\n\t\t\t\tch_intr_status);\n\t\tregmap_write(adc_priv->regmap, IPROC_INTERRUPT_STATUS,\n\t\t\t\tintr_channels);\n\t\tretval = IRQ_HANDLED;\n\t}\n\n\treturn retval;\n}\n\nstatic int iproc_adc_do_read(struct iio_dev *indio_dev,\n\t\t\t   int channel,\n\t\t\t   u16 *p_adc_data)\n{\n\tint read_len = 0;\n\tu32 val;\n\tu32 mask;\n\tu32 val_check;\n\tint failed_cnt = 0;\n\tstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\n\n\tmutex_lock(&adc_priv->mutex);\n\n\t \n\tadc_priv->chan_val = -1;\n\tadc_priv->chan_id = channel;\n\n\treinit_completion(&adc_priv->completion);\n\t \n\tregmap_update_bits(adc_priv->regmap, IPROC_INTERRUPT_STATUS,\n\t\t\tIPROC_ADC_INTR_MASK | IPROC_ADC_AUXDATA_RDY_INTR,\n\t\t\t((0x0 << channel) << IPROC_ADC_INTR) |\n\t\t\tIPROC_ADC_AUXDATA_RDY_INTR);\n\n\t \n\tval = (BIT(IPROC_ADC_CHANNEL_ROUNDS) |\n\t\t(IPROC_ADC_CHANNEL_MODE_SNAPSHOT << IPROC_ADC_CHANNEL_MODE) |\n\t\t(0x1 << IPROC_ADC_CHANNEL_ENABLE));\n\n\tmask = IPROC_ADC_CHANNEL_ROUNDS_MASK | IPROC_ADC_CHANNEL_MODE_MASK |\n\t\tIPROC_ADC_CHANNEL_ENABLE_MASK;\n\tregmap_update_bits(adc_priv->regmap, (IPROC_ADC_CHANNEL_REGCTL1 +\n\t\t\t\tIPROC_ADC_CHANNEL_OFFSET * channel),\n\t\t\t\tmask, val);\n\n\t \n\tregmap_update_bits(adc_priv->regmap, (IPROC_ADC_CHANNEL_REGCTL2 +\n\t\t\t\t\tIPROC_ADC_CHANNEL_OFFSET * channel),\n\t\t\t\t\tIPROC_ADC_CHANNEL_WATERMARK_MASK,\n\t\t\t\t\t0x1);\n\n\t \n\tregmap_update_bits(adc_priv->regmap, (IPROC_ADC_CHANNEL_INTERRUPT_MASK +\n\t\t\t\t\tIPROC_ADC_CHANNEL_OFFSET *\n\t\t\t\t\tchannel),\n\t\t\t\t\tIPROC_ADC_CHANNEL_WTRMRK_INTR_MASK,\n\t\t\t\t\tIPROC_ADC_WATER_MARK_INTR_ENABLE);\n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_MASK, &val);\n\n\t \n\tval |= (BIT(channel) << IPROC_ADC_INTR);\n\tregmap_write(adc_priv->regmap, IPROC_INTERRUPT_MASK, val);\n\n\t \n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_MASK, &val_check);\n\twhile (val_check != val) {\n\t\tfailed_cnt++;\n\n\t\tif (failed_cnt > IPROC_ADC_INTMASK_RETRY_ATTEMPTS)\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t\tregmap_update_bits(adc_priv->regmap, IPROC_INTERRUPT_MASK,\n\t\t\t\tIPROC_ADC_INTR_MASK,\n\t\t\t\t((0x1 << channel) <<\n\t\t\t\tIPROC_ADC_INTR));\n\n\t\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_MASK, &val_check);\n\t}\n\n\tif (failed_cnt) {\n\t\tdev_dbg(&indio_dev->dev,\n\t\t\t\"IntMask failed (%d times)\", failed_cnt);\n\t\tif (failed_cnt > IPROC_ADC_INTMASK_RETRY_ATTEMPTS) {\n\t\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\"IntMask set failed. Read will likely fail.\");\n\t\t\tread_len = -EIO;\n\t\t\tgoto adc_err;\n\t\t}\n\t}\n\tregmap_read(adc_priv->regmap, IPROC_INTERRUPT_MASK, &val_check);\n\n\tif (wait_for_completion_timeout(&adc_priv->completion,\n\t\tIPROC_ADC_READ_TIMEOUT) > 0) {\n\n\t\t \n\t\t*p_adc_data = adc_priv->chan_val & 0xFFFF;\n\t\tread_len = sizeof(*p_adc_data);\n\n\t} else {\n\t\t \n\t\tread_len = -ETIMEDOUT;\n\t\tgoto adc_err;\n\t}\n\tmutex_unlock(&adc_priv->mutex);\n\n\treturn read_len;\n\nadc_err:\n\tregmap_update_bits(adc_priv->regmap, IPROC_INTERRUPT_MASK,\n\t\t\t   IPROC_ADC_INTR_MASK,\n\t\t\t   ((0x0 << channel) << IPROC_ADC_INTR));\n\n\tregmap_update_bits(adc_priv->regmap, IPROC_INTERRUPT_STATUS,\n\t\t\t   IPROC_ADC_INTR_MASK,\n\t\t\t   ((0x0 << channel) << IPROC_ADC_INTR));\n\n\tdev_err(&indio_dev->dev, \"Timed out waiting for ADC data!\\n\");\n\tiproc_adc_reg_dump(indio_dev);\n\tmutex_unlock(&adc_priv->mutex);\n\n\treturn read_len;\n}\n\nstatic int iproc_adc_enable(struct iio_dev *indio_dev)\n{\n\tu32 val;\n\tu32 channel_id;\n\tstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\n\tint ret;\n\n\t \n\tret = regmap_update_bits(adc_priv->regmap, IPROC_ANALOG_CONTROL,\n\t\t\t\tIPROC_ADC_CHANNEL_SEL_MASK, 0);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\"failed to write IPROC_ANALOG_CONTROL %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tadc_priv->chan_val = -1;\n\n\t \n\tret = regmap_read(adc_priv->regmap, IPROC_REGCTL2, &val);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\"failed to read IPROC_REGCTL2 %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tval &= ~(IPROC_ADC_PWR_LDO | IPROC_ADC_PWR_ADC | IPROC_ADC_PWR_BG);\n\n\tret = regmap_write(adc_priv->regmap, IPROC_REGCTL2, val);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\"failed to write IPROC_REGCTL2 %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(adc_priv->regmap, IPROC_REGCTL2, &val);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\"failed to read IPROC_REGCTL2 %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tval |= IPROC_ADC_CONTROLLER_EN;\n\tret = regmap_write(adc_priv->regmap, IPROC_REGCTL2, val);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\"failed to write IPROC_REGCTL2 %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (channel_id = 0; channel_id < indio_dev->num_channels;\n\t\tchannel_id++) {\n\t\tret = regmap_write(adc_priv->regmap,\n\t\t\t\tIPROC_ADC_CHANNEL_INTERRUPT_MASK +\n\t\t\t\tIPROC_ADC_CHANNEL_OFFSET * channel_id, 0);\n\t\tif (ret) {\n\t\t\tdev_err(&indio_dev->dev,\n\t\t\t    \"failed to write ADC_CHANNEL_INTERRUPT_MASK %d\\n\",\n\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_write(adc_priv->regmap,\n\t\t\t\tIPROC_ADC_CHANNEL_INTERRUPT_STATUS +\n\t\t\t\tIPROC_ADC_CHANNEL_OFFSET * channel_id, 0);\n\t\tif (ret) {\n\t\t\tdev_err(&indio_dev->dev,\n\t\t\t    \"failed to write ADC_CHANNEL_INTERRUPT_STATUS %d\\n\",\n\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void iproc_adc_disable(struct iio_dev *indio_dev)\n{\n\tu32 val;\n\tint ret;\n\tstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\n\n\tret = regmap_read(adc_priv->regmap, IPROC_REGCTL2, &val);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\"failed to read IPROC_REGCTL2 %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tval &= ~IPROC_ADC_CONTROLLER_EN;\n\tret = regmap_write(adc_priv->regmap, IPROC_REGCTL2, val);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\"failed to write IPROC_REGCTL2 %d\\n\", ret);\n\t\treturn;\n\t}\n}\n\nstatic int iproc_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t  int *val,\n\t\t\t  int *val2,\n\t\t\t  long mask)\n{\n\tu16 adc_data;\n\tint err;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\terr =  iproc_adc_do_read(indio_dev, chan->channel, &adc_data);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = adc_data;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\t*val = 1800;\n\t\t\t*val2 = 10;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info iproc_adc_iio_info = {\n\t.read_raw = &iproc_adc_read_raw,\n};\n\n#define IPROC_ADC_CHANNEL(_index, _id) {                \\\n\t.type = IIO_VOLTAGE,                            \\\n\t.indexed = 1,                                   \\\n\t.channel = _index,                              \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),   \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t.datasheet_name = _id,                          \\\n}\n\nstatic const struct iio_chan_spec iproc_adc_iio_channels[] = {\n\tIPROC_ADC_CHANNEL(0, \"adc0\"),\n\tIPROC_ADC_CHANNEL(1, \"adc1\"),\n\tIPROC_ADC_CHANNEL(2, \"adc2\"),\n\tIPROC_ADC_CHANNEL(3, \"adc3\"),\n\tIPROC_ADC_CHANNEL(4, \"adc4\"),\n\tIPROC_ADC_CHANNEL(5, \"adc5\"),\n\tIPROC_ADC_CHANNEL(6, \"adc6\"),\n\tIPROC_ADC_CHANNEL(7, \"adc7\"),\n};\n\nstatic int iproc_adc_probe(struct platform_device *pdev)\n{\n\tstruct iproc_adc_priv *adc_priv;\n\tstruct iio_dev *indio_dev = NULL;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev,\n\t\t\t\t\tsizeof(*adc_priv));\n\tif (!indio_dev) {\n\t\tdev_err(&pdev->dev, \"failed to allocate iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tadc_priv = iio_priv(indio_dev);\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tmutex_init(&adc_priv->mutex);\n\n\tinit_completion(&adc_priv->completion);\n\n\tadc_priv->regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t   \"adc-syscon\");\n\tif (IS_ERR(adc_priv->regmap)) {\n\t\tdev_err(&pdev->dev, \"failed to get handle for tsc syscon\\n\");\n\t\tret = PTR_ERR(adc_priv->regmap);\n\t\treturn ret;\n\t}\n\n\tadc_priv->adc_clk = devm_clk_get(&pdev->dev, \"tsc_clk\");\n\tif (IS_ERR(adc_priv->adc_clk)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed getting clock tsc_clk\\n\");\n\t\tret = PTR_ERR(adc_priv->adc_clk);\n\t\treturn ret;\n\t}\n\n\tadc_priv->irqno = platform_get_irq(pdev, 0);\n\tif (adc_priv->irqno < 0)\n\t\treturn adc_priv->irqno;\n\n\tret = regmap_update_bits(adc_priv->regmap, IPROC_REGCTL2,\n\t\t\t\tIPROC_ADC_AUXIN_SCAN_ENA, 0);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to write IPROC_REGCTL2 %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, adc_priv->irqno,\n\t\t\t\tiproc_adc_interrupt_handler,\n\t\t\t\tiproc_adc_interrupt_thread,\n\t\t\t\tIRQF_SHARED, \"iproc-adc\", indio_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request_irq error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(adc_priv->adc_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"clk_prepare_enable failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = iproc_adc_enable(indio_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable adc %d\\n\", ret);\n\t\tgoto err_adc_enable;\n\t}\n\n\tindio_dev->name = \"iproc-static-adc\";\n\tindio_dev->info = &iproc_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = iproc_adc_iio_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(iproc_adc_iio_channels);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"iio_device_register failed:err %d\\n\", ret);\n\t\tgoto err_clk;\n\t}\n\n\treturn 0;\n\nerr_clk:\n\tiproc_adc_disable(indio_dev);\nerr_adc_enable:\n\tclk_disable_unprepare(adc_priv->adc_clk);\n\n\treturn ret;\n}\n\nstatic int iproc_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tiproc_adc_disable(indio_dev);\n\tclk_disable_unprepare(adc_priv->adc_clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id iproc_adc_of_match[] = {\n\t{.compatible = \"brcm,iproc-static-adc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, iproc_adc_of_match);\n\nstatic struct platform_driver iproc_adc_driver = {\n\t.probe  = iproc_adc_probe,\n\t.remove\t= iproc_adc_remove,\n\t.driver\t= {\n\t\t.name\t= \"iproc-static-adc\",\n\t\t.of_match_table = iproc_adc_of_match,\n\t},\n};\nmodule_platform_driver(iproc_adc_driver);\n\nMODULE_DESCRIPTION(\"Broadcom iProc ADC controller driver\");\nMODULE_AUTHOR(\"Raveendra Padasalagi <raveendra.padasalagi@broadcom.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}