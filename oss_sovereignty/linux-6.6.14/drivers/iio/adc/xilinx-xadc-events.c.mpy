{
  "module_name": "xilinx-xadc-events.c",
  "hash_id": "4e8c22f9138440deb9c704c0d78007eac255904d10126c4f1c6cc51e34cfca69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/xilinx-xadc-events.c",
  "human_readable_source": "\n \n\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/kernel.h>\n\n#include \"xilinx-xadc.h\"\n\nstatic const struct iio_chan_spec *xadc_event_to_channel(\n\tstruct iio_dev *indio_dev, unsigned int event)\n{\n\tswitch (event) {\n\tcase XADC_THRESHOLD_OT_MAX:\n\tcase XADC_THRESHOLD_TEMP_MAX:\n\t\treturn &indio_dev->channels[0];\n\tcase XADC_THRESHOLD_VCCINT_MAX:\n\tcase XADC_THRESHOLD_VCCAUX_MAX:\n\t\treturn &indio_dev->channels[event];\n\tdefault:\n\t\treturn &indio_dev->channels[event-1];\n\t}\n}\n\nstatic void xadc_handle_event(struct iio_dev *indio_dev, unsigned int event)\n{\n\tconst struct iio_chan_spec *chan;\n\n\t \n\tif (event == 0)\n\t\treturn;\n\n\tchan = xadc_event_to_channel(indio_dev, event);\n\n\tif (chan->type == IIO_TEMP) {\n\t\t \n\t\tiio_push_event(indio_dev,\n\t\t\tIIO_UNMOD_EVENT_CODE(chan->type, chan->channel,\n\t\t\t\tIIO_EV_TYPE_THRESH, IIO_EV_DIR_RISING),\n\t\t\tiio_get_time_ns(indio_dev));\n\t} else {\n\t\t \n\t\tiio_push_event(indio_dev,\n\t\t\tIIO_UNMOD_EVENT_CODE(chan->type, chan->channel,\n\t\t\t\tIIO_EV_TYPE_THRESH, IIO_EV_DIR_EITHER),\n\t\t\tiio_get_time_ns(indio_dev));\n\t}\n}\n\nvoid xadc_handle_events(struct iio_dev *indio_dev, unsigned long events)\n{\n\tunsigned int i;\n\n\tfor_each_set_bit(i, &events, 8)\n\t\txadc_handle_event(indio_dev, i);\n}\n\nstatic unsigned int xadc_get_threshold_offset(const struct iio_chan_spec *chan,\n\tenum iio_event_direction dir)\n{\n\tunsigned int offset;\n\n\tif (chan->type == IIO_TEMP) {\n\t\toffset = XADC_THRESHOLD_OT_MAX;\n\t} else {\n\t\tif (chan->channel < 2)\n\t\t\toffset = chan->channel + 1;\n\t\telse\n\t\t\toffset = chan->channel + 6;\n\t}\n\n\tif (dir == IIO_EV_DIR_FALLING)\n\t\toffset += 4;\n\n\treturn offset;\n}\n\nstatic unsigned int xadc_get_alarm_mask(const struct iio_chan_spec *chan)\n{\n\tif (chan->type == IIO_TEMP)\n\t\treturn XADC_ALARM_OT_MASK;\n\tswitch (chan->channel) {\n\tcase 0:\n\t\treturn XADC_ALARM_VCCINT_MASK;\n\tcase 1:\n\t\treturn XADC_ALARM_VCCAUX_MASK;\n\tcase 2:\n\t\treturn XADC_ALARM_VCCBRAM_MASK;\n\tcase 3:\n\t\treturn XADC_ALARM_VCCPINT_MASK;\n\tcase 4:\n\t\treturn XADC_ALARM_VCCPAUX_MASK;\n\tcase 5:\n\t\treturn XADC_ALARM_VCCODDR_MASK;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n}\n\nint xadc_read_event_config(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir)\n{\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\n\treturn (bool)(xadc->alarm_mask & xadc_get_alarm_mask(chan));\n}\n\nint xadc_write_event_config(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, int state)\n{\n\tunsigned int alarm = xadc_get_alarm_mask(chan);\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\tuint16_t cfg, old_cfg;\n\tint ret;\n\n\tmutex_lock(&xadc->mutex);\n\n\tif (state)\n\t\txadc->alarm_mask |= alarm;\n\telse\n\t\txadc->alarm_mask &= ~alarm;\n\n\txadc->ops->update_alarm(xadc, xadc->alarm_mask);\n\n\tret = _xadc_read_adc_reg(xadc, XADC_REG_CONF1, &cfg);\n\tif (ret)\n\t\tgoto err_out;\n\n\told_cfg = cfg;\n\tcfg |= XADC_CONF1_ALARM_MASK;\n\tcfg &= ~((xadc->alarm_mask & 0xf0) << 4);  \n\tcfg &= ~((xadc->alarm_mask & 0x08) >> 3);  \n\tcfg &= ~((xadc->alarm_mask & 0x07) << 1);  \n\tif (old_cfg != cfg)\n\t\tret = _xadc_write_adc_reg(xadc, XADC_REG_CONF1, cfg);\n\nerr_out:\n\tmutex_unlock(&xadc->mutex);\n\n\treturn ret;\n}\n\nint xadc_read_event_value(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, enum iio_event_info info,\n\tint *val, int *val2)\n{\n\tunsigned int offset = xadc_get_threshold_offset(chan, dir);\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\t*val = xadc->threshold[offset];\n\t\tbreak;\n\tcase IIO_EV_INFO_HYSTERESIS:\n\t\t*val = xadc->temp_hysteresis;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t*val >>= 16 - chan->scan_type.realbits;\n\n\treturn IIO_VAL_INT;\n}\n\nint xadc_write_event_value(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\tenum iio_event_direction dir, enum iio_event_info info,\n\tint val, int val2)\n{\n\tunsigned int offset = xadc_get_threshold_offset(chan, dir);\n\tstruct xadc *xadc = iio_priv(indio_dev);\n\tint ret = 0;\n\n\t \n\tval <<= 16 - chan->scan_type.realbits;\n\n\tif (val < 0 || val > 0xffff)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&xadc->mutex);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\txadc->threshold[offset] = val;\n\t\tbreak;\n\tcase IIO_EV_INFO_HYSTERESIS:\n\t\txadc->temp_hysteresis = val;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&xadc->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tif (chan->type == IIO_TEMP) {\n\t\t \n\t\tval |= 0x3;\n\n\t\t \n\t\tif (xadc->threshold[offset] < xadc->temp_hysteresis)\n\t\t\txadc->threshold[offset + 4] = 0;\n\t\telse\n\t\t\txadc->threshold[offset + 4] = xadc->threshold[offset] -\n\t\t\t\t\txadc->temp_hysteresis;\n\t\tret = _xadc_write_adc_reg(xadc, XADC_REG_THRESHOLD(offset + 4),\n\t\t\txadc->threshold[offset + 4]);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (info == IIO_EV_INFO_VALUE)\n\t\tret = _xadc_write_adc_reg(xadc, XADC_REG_THRESHOLD(offset), val);\n\nout_unlock:\n\tmutex_unlock(&xadc->mutex);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}