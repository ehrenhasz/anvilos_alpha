{
  "module_name": "ina2xx-adc.c",
  "hash_id": "96d6222ae7c83b1098b00f0ed564636897b1bc199f15c64f320f7ff0b8963316",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ina2xx-adc.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/kfifo_buf.h>\n#include <linux/iio/sysfs.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/sched/task.h>\n#include <linux/util_macros.h>\n\n#include <linux/platform_data/ina2xx.h>\n\n \n#define INA2XX_CONFIG                   0x00\n#define INA2XX_SHUNT_VOLTAGE            0x01\t \n#define INA2XX_BUS_VOLTAGE              0x02\t \n#define INA2XX_POWER                    0x03\t \n#define INA2XX_CURRENT                  0x04\t \n#define INA2XX_CALIBRATION              0x05\n\n#define INA226_MASK_ENABLE\t\t0x06\n#define INA226_CVRF\t\t\tBIT(3)\n\n#define INA2XX_MAX_REGISTERS            8\n\n \n#define INA219_CONFIG_DEFAULT           0x399F\t \n#define INA219_DEFAULT_IT\t\t532\n#define INA219_DEFAULT_BRNG             1    \n#define INA219_DEFAULT_PGA              125  \n#define INA226_CONFIG_DEFAULT           0x4327\n#define INA226_DEFAULT_AVG              4\n#define INA226_DEFAULT_IT\t\t1110\n\n#define INA2XX_RSHUNT_DEFAULT           10000\n\n \n#define INA2XX_MODE_MASK\tGENMASK(3, 0)\n\n \n#define INA219_PGA_MASK\t\tGENMASK(12, 11)\n#define INA219_SHIFT_PGA(val)\t((val) << 11)\n\n \n#define INA219_BRNG_MASK\tBIT(13)\n#define INA219_SHIFT_BRNG(val)\t((val) << 13)\n\n \n#define INA226_AVG_MASK\t\tGENMASK(11, 9)\n#define INA226_SHIFT_AVG(val)\t((val) << 9)\n\n \n#define INA219_ITB_MASK\t\tGENMASK(10, 7)\n#define INA219_SHIFT_ITB(val)\t((val) << 7)\n#define INA226_ITB_MASK\t\tGENMASK(8, 6)\n#define INA226_SHIFT_ITB(val)\t((val) << 6)\n\n \n#define INA219_ITS_MASK\t\tGENMASK(6, 3)\n#define INA219_SHIFT_ITS(val)\t((val) << 3)\n#define INA226_ITS_MASK\t\tGENMASK(5, 3)\n#define INA226_SHIFT_ITS(val)\t((val) << 3)\n\n \n#define INA219_OVF\t\tBIT(0)\n#define INA219_CNVR\t\tBIT(1)\n#define INA219_BUS_VOLTAGE_SHIFT\t3\n\n \n#define SAMPLING_PERIOD(c)\t((c->int_time_vbus + c->int_time_vshunt) \\\n\t\t\t\t * c->avg)\n\nstatic bool ina2xx_is_writeable_reg(struct device *dev, unsigned int reg)\n{\n\treturn (reg == INA2XX_CONFIG) || (reg > INA2XX_CURRENT);\n}\n\nstatic bool ina2xx_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn (reg != INA2XX_CONFIG);\n}\n\nstatic inline bool is_signed_reg(unsigned int reg)\n{\n\treturn (reg == INA2XX_SHUNT_VOLTAGE) || (reg == INA2XX_CURRENT);\n}\n\nstatic const struct regmap_config ina2xx_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = INA2XX_MAX_REGISTERS,\n\t.writeable_reg = ina2xx_is_writeable_reg,\n\t.volatile_reg = ina2xx_is_volatile_reg,\n};\n\nenum ina2xx_ids { ina219, ina226 };\n\nstruct ina2xx_config {\n\tconst char *name;\n\tu16 config_default;\n\tint calibration_value;\n\tint shunt_voltage_lsb;\t \n\tint bus_voltage_shift;\t \n\tint bus_voltage_lsb;\t \n\t \n\tint power_lsb_factor;\n\tenum ina2xx_ids chip_id;\n};\n\nstruct ina2xx_chip_info {\n\tstruct regmap *regmap;\n\tstruct task_struct *task;\n\tconst struct ina2xx_config *config;\n\tstruct mutex state_lock;\n\tunsigned int shunt_resistor_uohm;\n\tint avg;\n\tint int_time_vbus;  \n\tint int_time_vshunt;  \n\tint range_vbus;  \n\tint pga_gain_vshunt;  \n\tbool allow_async_readout;\n\t \n\tstruct {\n\t\tu16 chan[4];\n\t\tu64 ts __aligned(8);\n\t} scan;\n};\n\nstatic const struct ina2xx_config ina2xx_config[] = {\n\t[ina219] = {\n\t\t.name = \"ina219\",\n\t\t.config_default = INA219_CONFIG_DEFAULT,\n\t\t.calibration_value = 4096,\n\t\t.shunt_voltage_lsb = 10000,\n\t\t.bus_voltage_shift = INA219_BUS_VOLTAGE_SHIFT,\n\t\t.bus_voltage_lsb = 4000,\n\t\t.power_lsb_factor = 20,\n\t\t.chip_id = ina219,\n\t},\n\t[ina226] = {\n\t\t.name = \"ina226\",\n\t\t.config_default = INA226_CONFIG_DEFAULT,\n\t\t.calibration_value = 2048,\n\t\t.shunt_voltage_lsb = 2500,\n\t\t.bus_voltage_shift = 0,\n\t\t.bus_voltage_lsb = 1250,\n\t\t.power_lsb_factor = 25,\n\t\t.chip_id = ina226,\n\t},\n};\n\nstatic int ina2xx_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tint ret;\n\tstruct ina2xx_chip_info *chip = iio_priv(indio_dev);\n\tunsigned int regval;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = regmap_read(chip->regmap, chan->address, &regval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (is_signed_reg(chan->address))\n\t\t\t*val = (s16) regval;\n\t\telse\n\t\t\t*val  = regval;\n\n\t\tif (chan->address == INA2XX_BUS_VOLTAGE)\n\t\t\t*val >>= chip->config->bus_voltage_shift;\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t*val = chip->avg;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\t*val = 0;\n\t\tif (chan->address == INA2XX_SHUNT_VOLTAGE)\n\t\t\t*val2 = chip->int_time_vshunt;\n\t\telse\n\t\t\t*val2 = chip->int_time_vbus;\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t \n\t\t*val = DIV_ROUND_CLOSEST(1000000, SAMPLING_PERIOD(chip));\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->address) {\n\t\tcase INA2XX_SHUNT_VOLTAGE:\n\t\t\t \n\t\t\t*val = chip->config->shunt_voltage_lsb;\n\t\t\t*val2 = 1000000;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\n\t\tcase INA2XX_BUS_VOLTAGE:\n\t\t\t \n\t\t\t*val = chip->config->bus_voltage_lsb;\n\t\t\t*val2 = 1000;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\n\t\tcase INA2XX_CURRENT:\n\t\t\t \n\t\t\t*val = chip->config->shunt_voltage_lsb;\n\t\t\t*val2 = chip->shunt_resistor_uohm;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\n\t\tcase INA2XX_POWER:\n\t\t\t \n\t\t\t*val = chip->config->power_lsb_factor *\n\t\t\t       chip->config->shunt_voltage_lsb;\n\t\t\t*val2 = chip->shunt_resistor_uohm;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\t}\n\t\treturn -EINVAL;\n\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tswitch (chan->address) {\n\t\tcase INA2XX_SHUNT_VOLTAGE:\n\t\t\t*val = chip->pga_gain_vshunt;\n\t\t\t*val2 = 1000;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\n\t\tcase INA2XX_BUS_VOLTAGE:\n\t\t\t*val = chip->range_vbus == 32 ? 1 : 2;\n\t\t\treturn IIO_VAL_INT;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic const int ina226_avg_tab[] = { 1, 4, 16, 64, 128, 256, 512, 1024 };\n\nstatic int ina226_set_average(struct ina2xx_chip_info *chip, unsigned int val,\n\t\t\t      unsigned int *config)\n{\n\tint bits;\n\n\tif (val > 1024 || val < 1)\n\t\treturn -EINVAL;\n\n\tbits = find_closest(val, ina226_avg_tab,\n\t\t\t    ARRAY_SIZE(ina226_avg_tab));\n\n\tchip->avg = ina226_avg_tab[bits];\n\n\t*config &= ~INA226_AVG_MASK;\n\t*config |= INA226_SHIFT_AVG(bits) & INA226_AVG_MASK;\n\n\treturn 0;\n}\n\n \nstatic const int ina226_conv_time_tab[] = { 140, 204, 332, 588, 1100,\n\t\t\t\t\t    2116, 4156, 8244 };\n\nstatic int ina226_set_int_time_vbus(struct ina2xx_chip_info *chip,\n\t\t\t\t    unsigned int val_us, unsigned int *config)\n{\n\tint bits;\n\n\tif (val_us > 8244 || val_us < 140)\n\t\treturn -EINVAL;\n\n\tbits = find_closest(val_us, ina226_conv_time_tab,\n\t\t\t    ARRAY_SIZE(ina226_conv_time_tab));\n\n\tchip->int_time_vbus = ina226_conv_time_tab[bits];\n\n\t*config &= ~INA226_ITB_MASK;\n\t*config |= INA226_SHIFT_ITB(bits) & INA226_ITB_MASK;\n\n\treturn 0;\n}\n\nstatic int ina226_set_int_time_vshunt(struct ina2xx_chip_info *chip,\n\t\t\t\t      unsigned int val_us, unsigned int *config)\n{\n\tint bits;\n\n\tif (val_us > 8244 || val_us < 140)\n\t\treturn -EINVAL;\n\n\tbits = find_closest(val_us, ina226_conv_time_tab,\n\t\t\t    ARRAY_SIZE(ina226_conv_time_tab));\n\n\tchip->int_time_vshunt = ina226_conv_time_tab[bits];\n\n\t*config &= ~INA226_ITS_MASK;\n\t*config |= INA226_SHIFT_ITS(bits) & INA226_ITS_MASK;\n\n\treturn 0;\n}\n\n \nstatic const int ina219_conv_time_tab_subsample[] = { 84, 148, 276, 532 };\nstatic const int ina219_conv_time_tab_average[] = { 532, 1060, 2130, 4260,\n\t\t\t\t\t\t    8510, 17020, 34050, 68100};\n\nstatic int ina219_lookup_int_time(unsigned int *val_us, int *bits)\n{\n\tif (*val_us > 68100 || *val_us < 84)\n\t\treturn -EINVAL;\n\n\tif (*val_us <= 532) {\n\t\t*bits = find_closest(*val_us, ina219_conv_time_tab_subsample,\n\t\t\t\t    ARRAY_SIZE(ina219_conv_time_tab_subsample));\n\t\t*val_us = ina219_conv_time_tab_subsample[*bits];\n\t} else {\n\t\t*bits = find_closest(*val_us, ina219_conv_time_tab_average,\n\t\t\t\t    ARRAY_SIZE(ina219_conv_time_tab_average));\n\t\t*val_us = ina219_conv_time_tab_average[*bits];\n\t\t*bits |= 0x8;\n\t}\n\n\treturn 0;\n}\n\nstatic int ina219_set_int_time_vbus(struct ina2xx_chip_info *chip,\n\t\t\t\t    unsigned int val_us, unsigned int *config)\n{\n\tint bits, ret;\n\tunsigned int val_us_best = val_us;\n\n\tret = ina219_lookup_int_time(&val_us_best, &bits);\n\tif (ret)\n\t\treturn ret;\n\n\tchip->int_time_vbus = val_us_best;\n\n\t*config &= ~INA219_ITB_MASK;\n\t*config |= INA219_SHIFT_ITB(bits) & INA219_ITB_MASK;\n\n\treturn 0;\n}\n\nstatic int ina219_set_int_time_vshunt(struct ina2xx_chip_info *chip,\n\t\t\t\t      unsigned int val_us, unsigned int *config)\n{\n\tint bits, ret;\n\tunsigned int val_us_best = val_us;\n\n\tret = ina219_lookup_int_time(&val_us_best, &bits);\n\tif (ret)\n\t\treturn ret;\n\n\tchip->int_time_vshunt = val_us_best;\n\n\t*config &= ~INA219_ITS_MASK;\n\t*config |= INA219_SHIFT_ITS(bits) & INA219_ITS_MASK;\n\n\treturn 0;\n}\n\nstatic const int ina219_vbus_range_tab[] = { 1, 2 };\nstatic int ina219_set_vbus_range_denom(struct ina2xx_chip_info *chip,\n\t\t\t\t       unsigned int range,\n\t\t\t\t       unsigned int *config)\n{\n\tif (range == 1)\n\t\tchip->range_vbus = 32;\n\telse if (range == 2)\n\t\tchip->range_vbus = 16;\n\telse\n\t\treturn -EINVAL;\n\n\t*config &= ~INA219_BRNG_MASK;\n\t*config |= INA219_SHIFT_BRNG(range == 1 ? 1 : 0) & INA219_BRNG_MASK;\n\n\treturn 0;\n}\n\nstatic const int ina219_vshunt_gain_tab[] = { 125, 250, 500, 1000 };\nstatic const int ina219_vshunt_gain_frac[] = {\n\t125, 1000, 250, 1000, 500, 1000, 1000, 1000 };\n\nstatic int ina219_set_vshunt_pga_gain(struct ina2xx_chip_info *chip,\n\t\t\t\t      unsigned int gain,\n\t\t\t\t      unsigned int *config)\n{\n\tint bits;\n\n\tif (gain < 125 || gain > 1000)\n\t\treturn -EINVAL;\n\n\tbits = find_closest(gain, ina219_vshunt_gain_tab,\n\t\t\t    ARRAY_SIZE(ina219_vshunt_gain_tab));\n\n\tchip->pga_gain_vshunt = ina219_vshunt_gain_tab[bits];\n\tbits = 3 - bits;\n\n\t*config &= ~INA219_PGA_MASK;\n\t*config |= INA219_SHIFT_PGA(bits) & INA219_PGA_MASK;\n\n\treturn 0;\n}\n\nstatic int ina2xx_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type, int *length,\n\t\t\t     long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tswitch (chan->address) {\n\t\tcase INA2XX_SHUNT_VOLTAGE:\n\t\t\t*type = IIO_VAL_FRACTIONAL;\n\t\t\t*length = sizeof(ina219_vshunt_gain_frac) / sizeof(int);\n\t\t\t*vals = ina219_vshunt_gain_frac;\n\t\t\treturn IIO_AVAIL_LIST;\n\n\t\tcase INA2XX_BUS_VOLTAGE:\n\t\t\t*type = IIO_VAL_INT;\n\t\t\t*length = sizeof(ina219_vbus_range_tab) / sizeof(int);\n\t\t\t*vals = ina219_vbus_range_tab;\n\t\t\treturn IIO_AVAIL_LIST;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ina2xx_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct ina2xx_chip_info *chip = iio_priv(indio_dev);\n\tunsigned int config, tmp;\n\tint ret;\n\n\tif (iio_buffer_enabled(indio_dev))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&chip->state_lock);\n\n\tret = regmap_read(chip->regmap, INA2XX_CONFIG, &config);\n\tif (ret)\n\t\tgoto err;\n\n\ttmp = config;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tret = ina226_set_average(chip, val, &tmp);\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tif (chip->config->chip_id == ina226) {\n\t\t\tif (chan->address == INA2XX_SHUNT_VOLTAGE)\n\t\t\t\tret = ina226_set_int_time_vshunt(chip, val2,\n\t\t\t\t\t\t\t\t &tmp);\n\t\t\telse\n\t\t\t\tret = ina226_set_int_time_vbus(chip, val2,\n\t\t\t\t\t\t\t       &tmp);\n\t\t} else {\n\t\t\tif (chan->address == INA2XX_SHUNT_VOLTAGE)\n\t\t\t\tret = ina219_set_int_time_vshunt(chip, val2,\n\t\t\t\t\t\t\t\t &tmp);\n\t\t\telse\n\t\t\t\tret = ina219_set_int_time_vbus(chip, val2,\n\t\t\t\t\t\t\t       &tmp);\n\t\t}\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tif (chan->address == INA2XX_SHUNT_VOLTAGE)\n\t\t\tret = ina219_set_vshunt_pga_gain(chip, val * 1000 +\n\t\t\t\t\t\t\t val2 / 1000, &tmp);\n\t\telse\n\t\t\tret = ina219_set_vbus_range_denom(chip, val, &tmp);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (!ret && (tmp != config))\n\t\tret = regmap_write(chip->regmap, INA2XX_CONFIG, tmp);\nerr:\n\tmutex_unlock(&chip->state_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t ina2xx_allow_async_readout_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct ina2xx_chip_info *chip = iio_priv(dev_to_iio_dev(dev));\n\n\treturn sysfs_emit(buf, \"%d\\n\", chip->allow_async_readout);\n}\n\nstatic ssize_t ina2xx_allow_async_readout_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct ina2xx_chip_info *chip = iio_priv(dev_to_iio_dev(dev));\n\tbool val;\n\tint ret;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tchip->allow_async_readout = val;\n\n\treturn len;\n}\n\n \nstatic int ina2xx_set_calibration(struct ina2xx_chip_info *chip)\n{\n\treturn regmap_write(chip->regmap, INA2XX_CALIBRATION,\n\t\t\t    chip->config->calibration_value);\n}\n\nstatic int set_shunt_resistor(struct ina2xx_chip_info *chip, unsigned int val)\n{\n\tif (val == 0 || val > INT_MAX)\n\t\treturn -EINVAL;\n\n\tchip->shunt_resistor_uohm = val;\n\n\treturn 0;\n}\n\nstatic ssize_t ina2xx_shunt_resistor_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct ina2xx_chip_info *chip = iio_priv(dev_to_iio_dev(dev));\n\tint vals[2] = { chip->shunt_resistor_uohm, 1000000 };\n\n\treturn iio_format_value(buf, IIO_VAL_FRACTIONAL, 1, vals);\n}\n\nstatic ssize_t ina2xx_shunt_resistor_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t len)\n{\n\tstruct ina2xx_chip_info *chip = iio_priv(dev_to_iio_dev(dev));\n\tint val, val_fract, ret;\n\n\tret = iio_str_to_fixpoint(buf, 100000, &val, &val_fract);\n\tif (ret)\n\t\treturn ret;\n\n\tret = set_shunt_resistor(chip, val * 1000000 + val_fract);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\n#define INA219_CHAN(_type, _index, _address) { \\\n\t.type = (_type), \\\n\t.address = (_address), \\\n\t.indexed = 1, \\\n\t.channel = (_index), \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.scan_index = (_index), \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 16, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_CPU, \\\n\t} \\\n}\n\n#define INA226_CHAN(_type, _index, _address) { \\\n\t.type = (_type), \\\n\t.address = (_address), \\\n\t.indexed = 1, \\\n\t.channel = (_index), \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\t\t\t   BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \\\n\t.scan_index = (_index), \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 16, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_CPU, \\\n\t} \\\n}\n\n \n#define INA219_CHAN_VOLTAGE(_index, _address, _shift) { \\\n\t.type = IIO_VOLTAGE, \\\n\t.address = (_address), \\\n\t.indexed = 1, \\\n\t.channel = (_index), \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_INT_TIME) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_HARDWAREGAIN), \\\n\t.info_mask_separate_available = \\\n\t\t\t      BIT(IIO_CHAN_INFO_HARDWAREGAIN), \\\n\t.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.scan_index = (_index), \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.shift = _shift, \\\n\t\t.realbits = 16 - _shift, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_LE, \\\n\t} \\\n}\n\n#define INA226_CHAN_VOLTAGE(_index, _address) { \\\n\t.type = IIO_VOLTAGE, \\\n\t.address = (_address), \\\n\t.indexed = 1, \\\n\t.channel = (_index), \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_INT_TIME), \\\n\t.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\t\t\t   BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \\\n\t.scan_index = (_index), \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 16, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_LE, \\\n\t} \\\n}\n\n\nstatic const struct iio_chan_spec ina226_channels[] = {\n\tINA226_CHAN_VOLTAGE(0, INA2XX_SHUNT_VOLTAGE),\n\tINA226_CHAN_VOLTAGE(1, INA2XX_BUS_VOLTAGE),\n\tINA226_CHAN(IIO_POWER, 2, INA2XX_POWER),\n\tINA226_CHAN(IIO_CURRENT, 3, INA2XX_CURRENT),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic const struct iio_chan_spec ina219_channels[] = {\n\tINA219_CHAN_VOLTAGE(0, INA2XX_SHUNT_VOLTAGE, 0),\n\tINA219_CHAN_VOLTAGE(1, INA2XX_BUS_VOLTAGE, INA219_BUS_VOLTAGE_SHIFT),\n\tINA219_CHAN(IIO_POWER, 2, INA2XX_POWER),\n\tINA219_CHAN(IIO_CURRENT, 3, INA2XX_CURRENT),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic int ina2xx_conversion_ready(struct iio_dev *indio_dev)\n{\n\tstruct ina2xx_chip_info *chip = iio_priv(indio_dev);\n\tint ret;\n\tunsigned int alert;\n\n\t \n\tif (chip->config->chip_id == ina226) {\n\t\tret = regmap_read(chip->regmap,\n\t\t\t\t  INA226_MASK_ENABLE, &alert);\n\t\talert &= INA226_CVRF;\n\t} else {\n\t\tret = regmap_read(chip->regmap,\n\t\t\t\t  INA2XX_BUS_VOLTAGE, &alert);\n\t\talert &= INA219_CNVR;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!alert;\n}\n\nstatic int ina2xx_work_buffer(struct iio_dev *indio_dev)\n{\n\tstruct ina2xx_chip_info *chip = iio_priv(indio_dev);\n\tint bit, ret, i = 0;\n\ts64 time;\n\n\ttime = iio_get_time_ns(indio_dev);\n\n\t \n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\tunsigned int val;\n\n\t\tret = regmap_read(chip->regmap,\n\t\t\t\t  INA2XX_SHUNT_VOLTAGE + bit, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tchip->scan.chan[i++] = val;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &chip->scan, time);\n\n\treturn 0;\n};\n\nstatic int ina2xx_capture_thread(void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct ina2xx_chip_info *chip = iio_priv(indio_dev);\n\tint sampling_us = SAMPLING_PERIOD(chip);\n\tint ret;\n\tstruct timespec64 next, now, delta;\n\ts64 delay_us;\n\n\t \n\tif (!chip->allow_async_readout)\n\t\tsampling_us -= 200;\n\n\tktime_get_ts64(&next);\n\n\tdo {\n\t\twhile (!chip->allow_async_readout) {\n\t\t\tret = ina2xx_conversion_ready(indio_dev);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tif (ret == 0)\n\t\t\t\tktime_get_ts64(&next);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tret = ina2xx_work_buffer(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tktime_get_ts64(&now);\n\n\t\t \n\t\tdo {\n\t\t\ttimespec64_add_ns(&next, 1000 * sampling_us);\n\t\t\tdelta = timespec64_sub(next, now);\n\t\t\tdelay_us = div_s64(timespec64_to_ns(&delta), 1000);\n\t\t} while (delay_us <= 0);\n\n\t\tusleep_range(delay_us, (delay_us * 3) >> 1);\n\n\t} while (!kthread_should_stop());\n\n\treturn 0;\n}\n\nstatic int ina2xx_buffer_enable(struct iio_dev *indio_dev)\n{\n\tstruct ina2xx_chip_info *chip = iio_priv(indio_dev);\n\tunsigned int sampling_us = SAMPLING_PERIOD(chip);\n\tstruct task_struct *task;\n\n\tdev_dbg(&indio_dev->dev, \"Enabling buffer w/ scan_mask %02x, freq = %d, avg =%u\\n\",\n\t\t(unsigned int)(*indio_dev->active_scan_mask),\n\t\t1000000 / sampling_us, chip->avg);\n\n\tdev_dbg(&indio_dev->dev, \"Expected work period: %u us\\n\", sampling_us);\n\tdev_dbg(&indio_dev->dev, \"Async readout mode: %d\\n\",\n\t\tchip->allow_async_readout);\n\n\ttask = kthread_run(ina2xx_capture_thread, (void *)indio_dev,\n\t\t\t   \"%s:%d-%uus\", indio_dev->name,\n\t\t\t   iio_device_id(indio_dev),\n\t\t\t   sampling_us);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\n\tchip->task = task;\n\n\treturn 0;\n}\n\nstatic int ina2xx_buffer_disable(struct iio_dev *indio_dev)\n{\n\tstruct ina2xx_chip_info *chip = iio_priv(indio_dev);\n\n\tif (chip->task) {\n\t\tkthread_stop(chip->task);\n\t\tchip->task = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops ina2xx_setup_ops = {\n\t.postenable = &ina2xx_buffer_enable,\n\t.predisable = &ina2xx_buffer_disable,\n};\n\nstatic int ina2xx_debug_reg(struct iio_dev *indio_dev,\n\t\t\t    unsigned reg, unsigned writeval, unsigned *readval)\n{\n\tstruct ina2xx_chip_info *chip = iio_priv(indio_dev);\n\n\tif (!readval)\n\t\treturn regmap_write(chip->regmap, reg, writeval);\n\n\treturn regmap_read(chip->regmap, reg, readval);\n}\n\n \nstatic IIO_CONST_ATTR_NAMED(ina219_integration_time_available,\n\t\t\t    integration_time_available,\n\t\t\t    \"0.000084 0.000148 0.000276 0.000532 0.001060 0.002130 0.004260 0.008510 0.017020 0.034050 0.068100\");\n\nstatic IIO_CONST_ATTR_NAMED(ina226_integration_time_available,\n\t\t\t    integration_time_available,\n\t\t\t    \"0.000140 0.000204 0.000332 0.000588 0.001100 0.002116 0.004156 0.008244\");\n\nstatic IIO_DEVICE_ATTR(in_allow_async_readout, S_IRUGO | S_IWUSR,\n\t\t       ina2xx_allow_async_readout_show,\n\t\t       ina2xx_allow_async_readout_store, 0);\n\nstatic IIO_DEVICE_ATTR(in_shunt_resistor, S_IRUGO | S_IWUSR,\n\t\t       ina2xx_shunt_resistor_show,\n\t\t       ina2xx_shunt_resistor_store, 0);\n\nstatic struct attribute *ina219_attributes[] = {\n\t&iio_dev_attr_in_allow_async_readout.dev_attr.attr,\n\t&iio_const_attr_ina219_integration_time_available.dev_attr.attr,\n\t&iio_dev_attr_in_shunt_resistor.dev_attr.attr,\n\tNULL,\n};\n\nstatic struct attribute *ina226_attributes[] = {\n\t&iio_dev_attr_in_allow_async_readout.dev_attr.attr,\n\t&iio_const_attr_ina226_integration_time_available.dev_attr.attr,\n\t&iio_dev_attr_in_shunt_resistor.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ina219_attribute_group = {\n\t.attrs = ina219_attributes,\n};\n\nstatic const struct attribute_group ina226_attribute_group = {\n\t.attrs = ina226_attributes,\n};\n\nstatic const struct iio_info ina219_info = {\n\t.attrs = &ina219_attribute_group,\n\t.read_raw = ina2xx_read_raw,\n\t.read_avail = ina2xx_read_avail,\n\t.write_raw = ina2xx_write_raw,\n\t.debugfs_reg_access = ina2xx_debug_reg,\n};\n\nstatic const struct iio_info ina226_info = {\n\t.attrs = &ina226_attribute_group,\n\t.read_raw = ina2xx_read_raw,\n\t.write_raw = ina2xx_write_raw,\n\t.debugfs_reg_access = ina2xx_debug_reg,\n};\n\n \nstatic int ina2xx_init(struct ina2xx_chip_info *chip, unsigned int config)\n{\n\tint ret = regmap_write(chip->regmap, INA2XX_CONFIG, config);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ina2xx_set_calibration(chip);\n}\n\nstatic int ina2xx_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct ina2xx_chip_info *chip;\n\tstruct iio_dev *indio_dev;\n\tunsigned int val;\n\tenum ina2xx_ids type;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tchip = iio_priv(indio_dev);\n\n\t \n\ti2c_set_clientdata(client, indio_dev);\n\n\tchip->regmap = devm_regmap_init_i2c(client, &ina2xx_regmap_config);\n\tif (IS_ERR(chip->regmap)) {\n\t\tdev_err(&client->dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(chip->regmap);\n\t}\n\n\tif (client->dev.of_node)\n\t\ttype = (uintptr_t)of_device_get_match_data(&client->dev);\n\telse\n\t\ttype = id->driver_data;\n\tchip->config = &ina2xx_config[type];\n\n\tmutex_init(&chip->state_lock);\n\n\tif (of_property_read_u32(client->dev.of_node,\n\t\t\t\t \"shunt-resistor\", &val) < 0) {\n\t\tstruct ina2xx_platform_data *pdata =\n\t\t    dev_get_platdata(&client->dev);\n\n\t\tif (pdata)\n\t\t\tval = pdata->shunt_uohms;\n\t\telse\n\t\t\tval = INA2XX_RSHUNT_DEFAULT;\n\t}\n\n\tret = set_shunt_resistor(chip, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = chip->config->config_default;\n\n\tif (type == ina226) {\n\t\tina226_set_average(chip, INA226_DEFAULT_AVG, &val);\n\t\tina226_set_int_time_vbus(chip, INA226_DEFAULT_IT, &val);\n\t\tina226_set_int_time_vshunt(chip, INA226_DEFAULT_IT, &val);\n\t} else {\n\t\tchip->avg = 1;\n\t\tina219_set_int_time_vbus(chip, INA219_DEFAULT_IT, &val);\n\t\tina219_set_int_time_vshunt(chip, INA219_DEFAULT_IT, &val);\n\t\tina219_set_vbus_range_denom(chip, INA219_DEFAULT_BRNG, &val);\n\t\tina219_set_vshunt_pga_gain(chip, INA219_DEFAULT_PGA, &val);\n\t}\n\n\tret = ina2xx_init(chip, val);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"error configuring the device\\n\");\n\t\treturn ret;\n\t}\n\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tif (type == ina226) {\n\t\tindio_dev->channels = ina226_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(ina226_channels);\n\t\tindio_dev->info = &ina226_info;\n\t} else {\n\t\tindio_dev->channels = ina219_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(ina219_channels);\n\t\tindio_dev->info = &ina219_info;\n\t}\n\tindio_dev->name = id ? id->name : chip->config->name;\n\n\tret = devm_iio_kfifo_buffer_setup(&client->dev, indio_dev,\n\t\t\t\t\t  &ina2xx_setup_ops);\n\tif (ret)\n\t\treturn ret;\n\n\treturn iio_device_register(indio_dev);\n}\n\nstatic void ina2xx_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct ina2xx_chip_info *chip = iio_priv(indio_dev);\n\tint ret;\n\n\tiio_device_unregister(indio_dev);\n\n\t \n\tret = regmap_update_bits(chip->regmap, INA2XX_CONFIG,\n\t\t\t\t INA2XX_MODE_MASK, 0);\n\tif (ret)\n\t\tdev_warn(&client->dev, \"Failed to power down device (%pe)\\n\",\n\t\t\t ERR_PTR(ret));\n}\n\nstatic const struct i2c_device_id ina2xx_id[] = {\n\t{\"ina219\", ina219},\n\t{\"ina220\", ina219},\n\t{\"ina226\", ina226},\n\t{\"ina230\", ina226},\n\t{\"ina231\", ina226},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ina2xx_id);\n\nstatic const struct of_device_id ina2xx_of_match[] = {\n\t{\n\t\t.compatible = \"ti,ina219\",\n\t\t.data = (void *)ina219\n\t},\n\t{\n\t\t.compatible = \"ti,ina220\",\n\t\t.data = (void *)ina219\n\t},\n\t{\n\t\t.compatible = \"ti,ina226\",\n\t\t.data = (void *)ina226\n\t},\n\t{\n\t\t.compatible = \"ti,ina230\",\n\t\t.data = (void *)ina226\n\t},\n\t{\n\t\t.compatible = \"ti,ina231\",\n\t\t.data = (void *)ina226\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ina2xx_of_match);\n\nstatic struct i2c_driver ina2xx_driver = {\n\t.driver = {\n\t\t   .name = KBUILD_MODNAME,\n\t\t   .of_match_table = ina2xx_of_match,\n\t},\n\t.probe = ina2xx_probe,\n\t.remove = ina2xx_remove,\n\t.id_table = ina2xx_id,\n};\nmodule_i2c_driver(ina2xx_driver);\n\nMODULE_AUTHOR(\"Marc Titinger <marc.titinger@baylibre.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments INA2XX ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}