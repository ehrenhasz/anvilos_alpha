{
  "module_name": "dln2-adc.c",
  "hash_id": "117f79a0754faa35762b02ba5dbe52238120daf48d204731bd67c20b84293e67",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/dln2-adc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/dln2.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/kfifo_buf.h>\n\n#define DLN2_ADC_MOD_NAME \"dln2-adc\"\n\n#define DLN2_ADC_ID             0x06\n\n#define DLN2_ADC_GET_CHANNEL_COUNT\tDLN2_CMD(0x01, DLN2_ADC_ID)\n#define DLN2_ADC_ENABLE\t\t\tDLN2_CMD(0x02, DLN2_ADC_ID)\n#define DLN2_ADC_DISABLE\t\tDLN2_CMD(0x03, DLN2_ADC_ID)\n#define DLN2_ADC_CHANNEL_ENABLE\t\tDLN2_CMD(0x05, DLN2_ADC_ID)\n#define DLN2_ADC_CHANNEL_DISABLE\tDLN2_CMD(0x06, DLN2_ADC_ID)\n#define DLN2_ADC_SET_RESOLUTION\t\tDLN2_CMD(0x08, DLN2_ADC_ID)\n#define DLN2_ADC_CHANNEL_GET_VAL\tDLN2_CMD(0x0A, DLN2_ADC_ID)\n#define DLN2_ADC_CHANNEL_GET_ALL_VAL\tDLN2_CMD(0x0B, DLN2_ADC_ID)\n#define DLN2_ADC_CHANNEL_SET_CFG\tDLN2_CMD(0x0C, DLN2_ADC_ID)\n#define DLN2_ADC_CHANNEL_GET_CFG\tDLN2_CMD(0x0D, DLN2_ADC_ID)\n#define DLN2_ADC_CONDITION_MET_EV\tDLN2_CMD(0x10, DLN2_ADC_ID)\n\n#define DLN2_ADC_EVENT_NONE\t\t0\n#define DLN2_ADC_EVENT_BELOW\t\t1\n#define DLN2_ADC_EVENT_LEVEL_ABOVE\t2\n#define DLN2_ADC_EVENT_OUTSIDE\t\t3\n#define DLN2_ADC_EVENT_INSIDE\t\t4\n#define DLN2_ADC_EVENT_ALWAYS\t\t5\n\n#define DLN2_ADC_MAX_CHANNELS 8\n#define DLN2_ADC_DATA_BITS 10\n\n \nstruct dln2_adc_demux_table {\n\tunsigned int from;\n\tunsigned int to;\n\tunsigned int length;\n};\n\nstruct dln2_adc {\n\tstruct platform_device *pdev;\n\tstruct iio_chan_spec iio_channels[DLN2_ADC_MAX_CHANNELS + 1];\n\tint port, trigger_chan;\n\tstruct iio_trigger *trig;\n\tstruct mutex mutex;\n\t \n\tunsigned int sample_period;\n\t \n\tunsigned int demux_count;\n\tstruct dln2_adc_demux_table demux[DLN2_ADC_MAX_CHANNELS];\n\t \n\tunsigned int ts_pad_offset, ts_pad_length;\n};\n\nstruct dln2_adc_port_chan {\n\tu8 port;\n\tu8 chan;\n};\n\nstruct dln2_adc_get_all_vals {\n\t__le16 channel_mask;\n\t__le16 values[DLN2_ADC_MAX_CHANNELS];\n};\n\nstatic void dln2_adc_add_demux(struct dln2_adc *dln2,\n\tunsigned int in_loc, unsigned int out_loc,\n\tunsigned int length)\n{\n\tstruct dln2_adc_demux_table *p = dln2->demux_count ?\n\t\t&dln2->demux[dln2->demux_count - 1] : NULL;\n\n\tif (p && p->from + p->length == in_loc &&\n\t\tp->to + p->length == out_loc) {\n\t\tp->length += length;\n\t} else if (dln2->demux_count < DLN2_ADC_MAX_CHANNELS) {\n\t\tp = &dln2->demux[dln2->demux_count++];\n\t\tp->from = in_loc;\n\t\tp->to = out_loc;\n\t\tp->length = length;\n\t}\n}\n\nstatic void dln2_adc_update_demux(struct dln2_adc *dln2)\n{\n\tint in_ind = -1, out_ind;\n\tunsigned int in_loc = 0, out_loc = 0;\n\tstruct iio_dev *indio_dev = platform_get_drvdata(dln2->pdev);\n\n\t \n\tdln2->demux_count = 0;\n\n\t \n\tif (indio_dev->masklength &&\n\t    (*indio_dev->active_scan_mask & 0xff) == 0xff) {\n\t\tdln2_adc_add_demux(dln2, 0, 0, 16);\n\t\tdln2->ts_pad_offset = 0;\n\t\tdln2->ts_pad_length = 0;\n\t\treturn;\n\t}\n\n\t \n\tfor_each_set_bit(out_ind,\n\t\t\t indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\t \n\t\tif (out_ind == DLN2_ADC_MAX_CHANNELS)\n\t\t\tbreak;\n\t\tfor (++in_ind; in_ind != out_ind; ++in_ind)\n\t\t\tin_loc += 2;\n\t\tdln2_adc_add_demux(dln2, in_loc, out_loc, 2);\n\t\tout_loc += 2;\n\t\tin_loc += 2;\n\t}\n\n\tif (indio_dev->scan_timestamp) {\n\t\tsize_t ts_offset = indio_dev->scan_bytes / sizeof(int64_t) - 1;\n\n\t\tdln2->ts_pad_offset = out_loc;\n\t\tdln2->ts_pad_length = ts_offset * sizeof(int64_t) - out_loc;\n\t} else {\n\t\tdln2->ts_pad_offset = 0;\n\t\tdln2->ts_pad_length = 0;\n\t}\n}\n\nstatic int dln2_adc_get_chan_count(struct dln2_adc *dln2)\n{\n\tint ret;\n\tu8 port = dln2->port;\n\tu8 count;\n\tint olen = sizeof(count);\n\n\tret = dln2_transfer(dln2->pdev, DLN2_ADC_GET_CHANNEL_COUNT,\n\t\t\t    &port, sizeof(port), &count, &olen);\n\tif (ret < 0) {\n\t\tdev_dbg(&dln2->pdev->dev, \"Problem in %s\\n\", __func__);\n\t\treturn ret;\n\t}\n\tif (olen < sizeof(count))\n\t\treturn -EPROTO;\n\n\treturn count;\n}\n\nstatic int dln2_adc_set_port_resolution(struct dln2_adc *dln2)\n{\n\tint ret;\n\tstruct dln2_adc_port_chan port_chan = {\n\t\t.port = dln2->port,\n\t\t.chan = DLN2_ADC_DATA_BITS,\n\t};\n\n\tret = dln2_transfer_tx(dln2->pdev, DLN2_ADC_SET_RESOLUTION,\n\t\t\t       &port_chan, sizeof(port_chan));\n\tif (ret < 0)\n\t\tdev_dbg(&dln2->pdev->dev, \"Problem in %s\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic int dln2_adc_set_chan_enabled(struct dln2_adc *dln2,\n\t\t\t\t     int channel, bool enable)\n{\n\tint ret;\n\tstruct dln2_adc_port_chan port_chan = {\n\t\t.port = dln2->port,\n\t\t.chan = channel,\n\t};\n\tu16 cmd = enable ? DLN2_ADC_CHANNEL_ENABLE : DLN2_ADC_CHANNEL_DISABLE;\n\n\tret = dln2_transfer_tx(dln2->pdev, cmd, &port_chan, sizeof(port_chan));\n\tif (ret < 0)\n\t\tdev_dbg(&dln2->pdev->dev, \"Problem in %s\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic int dln2_adc_set_port_enabled(struct dln2_adc *dln2, bool enable,\n\t\t\t\t     u16 *conflict_out)\n{\n\tint ret;\n\tu8 port = dln2->port;\n\t__le16 conflict;\n\tint olen = sizeof(conflict);\n\tu16 cmd = enable ? DLN2_ADC_ENABLE : DLN2_ADC_DISABLE;\n\n\tif (conflict_out)\n\t\t*conflict_out = 0;\n\n\tret = dln2_transfer(dln2->pdev, cmd, &port, sizeof(port),\n\t\t\t    &conflict, &olen);\n\tif (ret < 0) {\n\t\tdev_dbg(&dln2->pdev->dev, \"Problem in %s(%d)\\n\",\n\t\t\t__func__, (int)enable);\n\t\tif (conflict_out && enable && olen >= sizeof(conflict))\n\t\t\t*conflict_out = le16_to_cpu(conflict);\n\t\treturn ret;\n\t}\n\tif (enable && olen < sizeof(conflict))\n\t\treturn -EPROTO;\n\n\treturn ret;\n}\n\nstatic int dln2_adc_set_chan_period(struct dln2_adc *dln2,\n\tunsigned int channel, unsigned int period)\n{\n\tint ret;\n\tstruct {\n\t\tstruct dln2_adc_port_chan port_chan;\n\t\t__u8 type;\n\t\t__le16 period;\n\t\t__le16 low;\n\t\t__le16 high;\n\t} __packed set_cfg = {\n\t\t.port_chan.port = dln2->port,\n\t\t.port_chan.chan = channel,\n\t\t.type = period ? DLN2_ADC_EVENT_ALWAYS : DLN2_ADC_EVENT_NONE,\n\t\t.period = cpu_to_le16(period)\n\t};\n\n\tret = dln2_transfer_tx(dln2->pdev, DLN2_ADC_CHANNEL_SET_CFG,\n\t\t\t       &set_cfg, sizeof(set_cfg));\n\tif (ret < 0)\n\t\tdev_dbg(&dln2->pdev->dev, \"Problem in %s\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic int dln2_adc_read(struct dln2_adc *dln2, unsigned int channel)\n{\n\tint ret, i;\n\tu16 conflict;\n\t__le16 value;\n\tint olen = sizeof(value);\n\tstruct dln2_adc_port_chan port_chan = {\n\t\t.port = dln2->port,\n\t\t.chan = channel,\n\t};\n\n\tret = dln2_adc_set_chan_enabled(dln2, channel, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dln2_adc_set_port_enabled(dln2, true, &conflict);\n\tif (ret < 0) {\n\t\tif (conflict) {\n\t\t\tdev_err(&dln2->pdev->dev,\n\t\t\t\t\"ADC pins conflict with mask %04X\\n\",\n\t\t\t\t(int)conflict);\n\t\t\tret = -EBUSY;\n\t\t}\n\t\tgoto disable_chan;\n\t}\n\n\t \n\tfor (i = 0; i < 2; ++i) {\n\t\tret = dln2_transfer(dln2->pdev, DLN2_ADC_CHANNEL_GET_VAL,\n\t\t\t\t    &port_chan, sizeof(port_chan),\n\t\t\t\t    &value, &olen);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(&dln2->pdev->dev, \"Problem in %s\\n\", __func__);\n\t\t\tgoto disable_port;\n\t\t}\n\t\tif (olen < sizeof(value)) {\n\t\t\tret = -EPROTO;\n\t\t\tgoto disable_port;\n\t\t}\n\t}\n\n\tret = le16_to_cpu(value);\n\ndisable_port:\n\tdln2_adc_set_port_enabled(dln2, false, NULL);\ndisable_chan:\n\tdln2_adc_set_chan_enabled(dln2, channel, false);\n\n\treturn ret;\n}\n\nstatic int dln2_adc_read_all(struct dln2_adc *dln2,\n\t\t\t     struct dln2_adc_get_all_vals *get_all_vals)\n{\n\tint ret;\n\t__u8 port = dln2->port;\n\tint olen = sizeof(*get_all_vals);\n\n\tret = dln2_transfer(dln2->pdev, DLN2_ADC_CHANNEL_GET_ALL_VAL,\n\t\t\t    &port, sizeof(port), get_all_vals, &olen);\n\tif (ret < 0) {\n\t\tdev_dbg(&dln2->pdev->dev, \"Problem in %s\\n\", __func__);\n\t\treturn ret;\n\t}\n\tif (olen < sizeof(*get_all_vals))\n\t\treturn -EPROTO;\n\n\treturn ret;\n}\n\nstatic int dln2_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val,\n\t\t\t     int *val2,\n\t\t\t     long mask)\n{\n\tint ret;\n\tunsigned int microhertz;\n\tstruct dln2_adc *dln2 = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&dln2->mutex);\n\t\tret = dln2_adc_read(dln2, chan->channel);\n\t\tmutex_unlock(&dln2->mutex);\n\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*val = 0;\n\t\t*val2 = 3222656;\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (dln2->sample_period) {\n\t\t\tmicrohertz = 1000000000 / dln2->sample_period;\n\t\t\t*val = microhertz / 1000000;\n\t\t\t*val2 = microhertz % 1000000;\n\t\t} else {\n\t\t\t*val = 0;\n\t\t\t*val2 = 0;\n\t\t}\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int dln2_adc_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val,\n\t\t\t      int val2,\n\t\t\t      long mask)\n{\n\tint ret;\n\tunsigned int microhertz;\n\tstruct dln2_adc *dln2 = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tmicrohertz = 1000000 * val + val2;\n\n\t\tmutex_lock(&dln2->mutex);\n\n\t\tdln2->sample_period =\n\t\t\tmicrohertz ? 1000000000 / microhertz : UINT_MAX;\n\t\tif (dln2->sample_period > 65535) {\n\t\t\tdln2->sample_period = 65535;\n\t\t\tdev_warn(&dln2->pdev->dev,\n\t\t\t\t \"clamping period to 65535ms\\n\");\n\t\t}\n\n\t\t \n\t\tif (dln2->trigger_chan != -1)\n\t\t\tret = dln2_adc_set_chan_period(dln2,\n\t\t\t\tdln2->trigger_chan, dln2->sample_period);\n\t\telse\n\t\t\tret = 0;\n\n\t\tmutex_unlock(&dln2->mutex);\n\n\t\treturn ret;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int dln2_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t const unsigned long *scan_mask)\n{\n\tstruct dln2_adc *dln2 = iio_priv(indio_dev);\n\tint chan_count = indio_dev->num_channels - 1;\n\tint ret, i, j;\n\n\tmutex_lock(&dln2->mutex);\n\n\tfor (i = 0; i < chan_count; ++i) {\n\t\tret = dln2_adc_set_chan_enabled(dln2, i,\n\t\t\t\t\t\ttest_bit(i, scan_mask));\n\t\tif (ret < 0) {\n\t\t\tfor (j = 0; j < i; ++j)\n\t\t\t\tdln2_adc_set_chan_enabled(dln2, j, false);\n\t\t\tmutex_unlock(&dln2->mutex);\n\t\t\tdev_err(&dln2->pdev->dev,\n\t\t\t\t\"Unable to enable ADC channel %d\\n\", i);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tdln2_adc_update_demux(dln2);\n\n\tmutex_unlock(&dln2->mutex);\n\n\treturn 0;\n}\n\n#define DLN2_ADC_CHAN(lval, idx) {\t\t\t\t\t\\\n\tlval.type = IIO_VOLTAGE;\t\t\t\t\t\\\n\tlval.channel = idx;\t\t\t\t\t\t\\\n\tlval.indexed = 1;\t\t\t\t\t\t\\\n\tlval.info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\t\t\\\n\tlval.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\t       BIT(IIO_CHAN_INFO_SAMP_FREQ);\t\\\n\tlval.scan_index = idx;\t\t\t\t\t\t\\\n\tlval.scan_type.sign = 'u';\t\t\t\t\t\\\n\tlval.scan_type.realbits = DLN2_ADC_DATA_BITS;\t\t\t\\\n\tlval.scan_type.storagebits = 16;\t\t\t\t\\\n\tlval.scan_type.endianness = IIO_LE;\t\t\t\t\\\n}\n\n \n#define IIO_CHAN_SOFT_TIMESTAMP_ASSIGN(lval, _si) {\t\\\n\tlval.type = IIO_TIMESTAMP;\t\t\t\\\n\tlval.channel = -1;\t\t\t\t\\\n\tlval.scan_index = _si;\t\t\t\t\\\n\tlval.scan_type.sign = 's';\t\t\t\\\n\tlval.scan_type.realbits = 64;\t\t\t\\\n\tlval.scan_type.storagebits = 64;\t\t\\\n}\n\nstatic const struct iio_info dln2_adc_info = {\n\t.read_raw = dln2_adc_read_raw,\n\t.write_raw = dln2_adc_write_raw,\n\t.update_scan_mode = dln2_update_scan_mode,\n};\n\nstatic irqreturn_t dln2_adc_trigger_h(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct {\n\t\t__le16 values[DLN2_ADC_MAX_CHANNELS];\n\t\tint64_t timestamp_space;\n\t} data;\n\tstruct dln2_adc_get_all_vals dev_data;\n\tstruct dln2_adc *dln2 = iio_priv(indio_dev);\n\tconst struct dln2_adc_demux_table *t;\n\tint ret, i;\n\n\tmutex_lock(&dln2->mutex);\n\tret = dln2_adc_read_all(dln2, &dev_data);\n\tmutex_unlock(&dln2->mutex);\n\tif (ret < 0)\n\t\tgoto done;\n\n\t \n\tfor (i = 0; i < dln2->demux_count; ++i) {\n\t\tt = &dln2->demux[i];\n\t\tmemcpy((void *)data.values + t->to,\n\t\t       (void *)dev_data.values + t->from, t->length);\n\t}\n\n\t \n\tif (dln2->ts_pad_length)\n\t\tmemset((void *)data.values + dln2->ts_pad_offset,\n\t\t       0, dln2->ts_pad_length);\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\nstatic int dln2_adc_triggered_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tstruct dln2_adc *dln2 = iio_priv(indio_dev);\n\tu16 conflict;\n\tunsigned int trigger_chan;\n\n\tmutex_lock(&dln2->mutex);\n\n\t \n\tret = dln2_adc_set_port_enabled(dln2, true, &conflict);\n\tif (ret < 0) {\n\t\tmutex_unlock(&dln2->mutex);\n\t\tdev_dbg(&dln2->pdev->dev, \"Problem in %s\\n\", __func__);\n\t\tif (conflict) {\n\t\t\tdev_err(&dln2->pdev->dev,\n\t\t\t\t\"ADC pins conflict with mask %04X\\n\",\n\t\t\t\t(int)conflict);\n\t\t\tret = -EBUSY;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t \n\ttrigger_chan = find_first_bit(indio_dev->active_scan_mask,\n\t\t\t\t      indio_dev->masklength);\n\tif (trigger_chan < DLN2_ADC_MAX_CHANNELS) {\n\t\tdln2->trigger_chan = trigger_chan;\n\t\tret = dln2_adc_set_chan_period(dln2, dln2->trigger_chan,\n\t\t\t\t\t       dln2->sample_period);\n\t\tmutex_unlock(&dln2->mutex);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(&dln2->pdev->dev, \"Problem in %s\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tdln2->trigger_chan = -1;\n\t\tmutex_unlock(&dln2->mutex);\n\t}\n\n\treturn 0;\n}\n\nstatic int dln2_adc_triggered_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tstruct dln2_adc *dln2 = iio_priv(indio_dev);\n\n\tmutex_lock(&dln2->mutex);\n\n\t \n\tif (dln2->trigger_chan != -1) {\n\t\tdln2_adc_set_chan_period(dln2, dln2->trigger_chan, 0);\n\t\tdln2->trigger_chan = -1;\n\t}\n\n\t \n\tret = dln2_adc_set_port_enabled(dln2, false, NULL);\n\n\tmutex_unlock(&dln2->mutex);\n\tif (ret < 0)\n\t\tdev_dbg(&dln2->pdev->dev, \"Problem in %s\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic const struct iio_buffer_setup_ops dln2_adc_buffer_setup_ops = {\n\t.postenable = dln2_adc_triggered_buffer_postenable,\n\t.predisable = dln2_adc_triggered_buffer_predisable,\n};\n\nstatic void dln2_adc_event(struct platform_device *pdev, u16 echo,\n\t\t\t   const void *data, int len)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct dln2_adc *dln2 = iio_priv(indio_dev);\n\n\t \n\tiio_trigger_poll(dln2->trig);\n}\n\nstatic int dln2_adc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dln2_adc *dln2;\n\tstruct dln2_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct iio_dev *indio_dev;\n\tint i, ret, chans;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*dln2));\n\tif (!indio_dev) {\n\t\tdev_err(dev, \"failed allocating iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdln2 = iio_priv(indio_dev);\n\tdln2->pdev = pdev;\n\tdln2->port = pdata->port;\n\tdln2->trigger_chan = -1;\n\tmutex_init(&dln2->mutex);\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tret = dln2_adc_set_port_resolution(dln2);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to set ADC resolution to 10 bits\\n\");\n\t\treturn ret;\n\t}\n\n\tchans = dln2_adc_get_chan_count(dln2);\n\tif (chans < 0) {\n\t\tdev_err(dev, \"failed to get channel count: %d\\n\", chans);\n\t\treturn chans;\n\t}\n\tif (chans > DLN2_ADC_MAX_CHANNELS) {\n\t\tchans = DLN2_ADC_MAX_CHANNELS;\n\t\tdev_warn(dev, \"clamping channels to %d\\n\",\n\t\t\t DLN2_ADC_MAX_CHANNELS);\n\t}\n\n\tfor (i = 0; i < chans; ++i)\n\t\tDLN2_ADC_CHAN(dln2->iio_channels[i], i)\n\tIIO_CHAN_SOFT_TIMESTAMP_ASSIGN(dln2->iio_channels[i], i);\n\n\tindio_dev->name = DLN2_ADC_MOD_NAME;\n\tindio_dev->info = &dln2_adc_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = dln2->iio_channels;\n\tindio_dev->num_channels = chans + 1;\n\tindio_dev->setup_ops = &dln2_adc_buffer_setup_ops;\n\n\tdln2->trig = devm_iio_trigger_alloc(dev, \"%s-dev%d\",\n\t\t\t\t\t    indio_dev->name,\n\t\t\t\t\t    iio_device_id(indio_dev));\n\tif (!dln2->trig) {\n\t\tdev_err(dev, \"failed to allocate trigger\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tiio_trigger_set_drvdata(dln2->trig, dln2);\n\tret = devm_iio_trigger_register(dev, dln2->trig);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register trigger: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tiio_trigger_set_immutable(indio_dev, dln2->trig);\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,\n\t\t\t\t\t      dln2_adc_trigger_h,\n\t\t\t\t\t      &dln2_adc_buffer_setup_ops);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to allocate triggered buffer: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = dln2_register_event_cb(pdev, DLN2_ADC_CONDITION_MET_EV,\n\t\t\t\t     dln2_adc_event);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to setup DLN2 periodic event: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register iio device: %d\\n\", ret);\n\t\tgoto unregister_event;\n\t}\n\n\treturn ret;\n\nunregister_event:\n\tdln2_unregister_event_cb(pdev, DLN2_ADC_CONDITION_MET_EV);\n\n\treturn ret;\n}\n\nstatic int dln2_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\n\tiio_device_unregister(indio_dev);\n\tdln2_unregister_event_cb(pdev, DLN2_ADC_CONDITION_MET_EV);\n\treturn 0;\n}\n\nstatic struct platform_driver dln2_adc_driver = {\n\t.driver.name\t= DLN2_ADC_MOD_NAME,\n\t.probe\t\t= dln2_adc_probe,\n\t.remove\t\t= dln2_adc_remove,\n};\n\nmodule_platform_driver(dln2_adc_driver);\n\nMODULE_AUTHOR(\"Jack Andersen <jackoalan@gmail.com\");\nMODULE_DESCRIPTION(\"Driver for the Diolan DLN2 ADC interface\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:dln2-adc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}