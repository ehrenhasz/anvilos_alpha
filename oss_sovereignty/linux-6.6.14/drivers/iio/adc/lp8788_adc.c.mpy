{
  "module_name": "lp8788_adc.c",
  "hash_id": "392f892747f17542e94b6b59eed085c4123275b582023062413f01109ec2bdf3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/lp8788_adc.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/driver.h>\n#include <linux/iio/machine.h>\n#include <linux/mfd/lp8788.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n \n#define LP8788_ADC_CONF\t\t\t0x60\n#define LP8788_ADC_RAW\t\t\t0x61\n#define LP8788_ADC_DONE\t\t\t0x63\n\n#define ADC_CONV_START\t\t\t1\n\nstruct lp8788_adc {\n\tstruct lp8788 *lp;\n\tstruct iio_map *map;\n\tstruct mutex lock;\n};\n\nstatic const int lp8788_scale[LPADC_MAX] = {\n\t[LPADC_VBATT_5P5] = 1343101,\n\t[LPADC_VIN_CHG]   = 3052503,\n\t[LPADC_IBATT]     = 610500,\n\t[LPADC_IC_TEMP]   = 61050,\n\t[LPADC_VBATT_6P0] = 1465201,\n\t[LPADC_VBATT_5P0] = 1221001,\n\t[LPADC_ADC1]      = 610500,\n\t[LPADC_ADC2]      = 610500,\n\t[LPADC_VDD]       = 1025641,\n\t[LPADC_VCOIN]     = 757020,\n\t[LPADC_ADC3]      = 610500,\n\t[LPADC_ADC4]      = 610500,\n};\n\nstatic int lp8788_get_adc_result(struct lp8788_adc *adc, enum lp8788_adc_id id,\n\t\t\t\tint *val)\n{\n\tunsigned int msb;\n\tunsigned int lsb;\n\tunsigned int result;\n\tu8 data;\n\tu8 rawdata[2];\n\tint size = ARRAY_SIZE(rawdata);\n\tint retry = 5;\n\tint ret;\n\n\tdata = (id << 1) | ADC_CONV_START;\n\tret = lp8788_write_byte(adc->lp, LP8788_ADC_CONF, data);\n\tif (ret)\n\t\tgoto err_io;\n\n\t \n\tdata = 0;\n\twhile (retry--) {\n\t\tusleep_range(100, 200);\n\n\t\tret = lp8788_read_byte(adc->lp, LP8788_ADC_DONE, &data);\n\t\tif (ret)\n\t\t\tgoto err_io;\n\n\t\t \n\t\tif (data)\n\t\t\tbreak;\n\t}\n\n\tret = lp8788_read_multi_bytes(adc->lp, LP8788_ADC_RAW, rawdata, size);\n\tif (ret)\n\t\tgoto err_io;\n\n\tmsb = (rawdata[0] << 4) & 0x00000ff0;\n\tlsb = (rawdata[1] >> 4) & 0x0000000f;\n\tresult = msb | lsb;\n\t*val = result;\n\n\treturn 0;\n\nerr_io:\n\treturn ret;\n}\n\nstatic int lp8788_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint *val, int *val2, long mask)\n{\n\tstruct lp8788_adc *adc = iio_priv(indio_dev);\n\tenum lp8788_adc_id id = chan->channel;\n\tint ret;\n\n\tmutex_lock(&adc->lock);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = lp8788_get_adc_result(adc, id, val) ? -EIO : IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = lp8788_scale[id] / 1000000;\n\t\t*val2 = lp8788_scale[id] % 1000000;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_info lp8788_adc_info = {\n\t.read_raw = &lp8788_adc_read_raw,\n};\n\n#define LP8788_CHAN(_id, _type) {\t\t\t\t\\\n\t\t.type = _type,\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\\\n\t\t.channel = LPADC_##_id,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t\t.datasheet_name = #_id,\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec lp8788_adc_channels[] = {\n\t[LPADC_VBATT_5P5] = LP8788_CHAN(VBATT_5P5, IIO_VOLTAGE),\n\t[LPADC_VIN_CHG]   = LP8788_CHAN(VIN_CHG, IIO_VOLTAGE),\n\t[LPADC_IBATT]     = LP8788_CHAN(IBATT, IIO_CURRENT),\n\t[LPADC_IC_TEMP]   = LP8788_CHAN(IC_TEMP, IIO_TEMP),\n\t[LPADC_VBATT_6P0] = LP8788_CHAN(VBATT_6P0, IIO_VOLTAGE),\n\t[LPADC_VBATT_5P0] = LP8788_CHAN(VBATT_5P0, IIO_VOLTAGE),\n\t[LPADC_ADC1]      = LP8788_CHAN(ADC1, IIO_VOLTAGE),\n\t[LPADC_ADC2]      = LP8788_CHAN(ADC2, IIO_VOLTAGE),\n\t[LPADC_VDD]       = LP8788_CHAN(VDD, IIO_VOLTAGE),\n\t[LPADC_VCOIN]     = LP8788_CHAN(VCOIN, IIO_VOLTAGE),\n\t[LPADC_ADC3]      = LP8788_CHAN(ADC3, IIO_VOLTAGE),\n\t[LPADC_ADC4]      = LP8788_CHAN(ADC4, IIO_VOLTAGE),\n};\n\n \nstatic struct iio_map lp8788_default_iio_maps[] = {\n\t{\n\t\t.consumer_dev_name = \"lp8788-charger\",\n\t\t.consumer_channel = \"lp8788_vbatt_5p0\",\n\t\t.adc_channel_label = \"VBATT_5P0\",\n\t},\n\t{\n\t\t.consumer_dev_name = \"lp8788-charger\",\n\t\t.consumer_channel = \"lp8788_adc1\",\n\t\t.adc_channel_label = \"ADC1\",\n\t},\n\t{ }\n};\n\nstatic int lp8788_iio_map_register(struct device *dev,\n\t\t\t\tstruct iio_dev *indio_dev,\n\t\t\t\tstruct lp8788_platform_data *pdata,\n\t\t\t\tstruct lp8788_adc *adc)\n{\n\tstruct iio_map *map;\n\tint ret;\n\n\tmap = (!pdata || !pdata->adc_pdata) ?\n\t\tlp8788_default_iio_maps : pdata->adc_pdata;\n\n\tret = devm_iio_map_array_register(dev, indio_dev, map);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"iio map err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tadc->map = map;\n\treturn 0;\n}\n\nstatic int lp8788_adc_probe(struct platform_device *pdev)\n{\n\tstruct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);\n\tstruct iio_dev *indio_dev;\n\tstruct lp8788_adc *adc;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\tadc->lp = lp;\n\n\tret = lp8788_iio_map_register(&pdev->dev, indio_dev, lp->pdata, adc);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&adc->lock);\n\n\tindio_dev->name = pdev->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &lp8788_adc_info;\n\tindio_dev->channels = lp8788_adc_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(lp8788_adc_channels);\n\n\treturn devm_iio_device_register(&pdev->dev, indio_dev);\n}\n\nstatic struct platform_driver lp8788_adc_driver = {\n\t.probe = lp8788_adc_probe,\n\t.driver = {\n\t\t.name = LP8788_DEV_ADC,\n\t},\n};\nmodule_platform_driver(lp8788_adc_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments LP8788 ADC Driver\");\nMODULE_AUTHOR(\"Milo Kim\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:lp8788-adc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}