{
  "module_name": "mt6370-adc.c",
  "hash_id": "5495c20dca9bf86ff928d4608d35973f01b32b395036c8c5e5efc87e074aee85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/mt6370-adc.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/iio/iio.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/sysfs.h>\n#include <linux/units.h>\n\n#include <dt-bindings/iio/adc/mediatek,mt6370_adc.h>\n\n#define MT6370_REG_DEV_INFO\t\t0x100\n#define MT6370_REG_CHG_CTRL3\t\t0x113\n#define MT6370_REG_CHG_CTRL7\t\t0x117\n#define MT6370_REG_CHG_ADC\t\t0x121\n#define MT6370_REG_ADC_DATA_H\t\t0x14C\n\n#define MT6370_ADC_START_MASK\t\tBIT(0)\n#define MT6370_ADC_IN_SEL_MASK\t\tGENMASK(7, 4)\n#define MT6370_AICR_ICHG_MASK\t\tGENMASK(7, 2)\n#define MT6370_VENID_MASK\t\tGENMASK(7, 4)\n\n#define MT6370_AICR_100_mA\t\t0x0\n#define MT6370_AICR_150_mA\t\t0x1\n#define MT6370_AICR_200_mA\t\t0x2\n#define MT6370_AICR_250_mA\t\t0x3\n#define MT6370_AICR_300_mA\t\t0x4\n#define MT6370_AICR_350_mA\t\t0x5\n\n#define MT6370_ICHG_100_mA\t\t0x0\n#define MT6370_ICHG_200_mA\t\t0x1\n#define MT6370_ICHG_300_mA\t\t0x2\n#define MT6370_ICHG_400_mA\t\t0x3\n#define MT6370_ICHG_500_mA\t\t0x4\n#define MT6370_ICHG_600_mA\t\t0x5\n#define MT6370_ICHG_700_mA\t\t0x6\n#define MT6370_ICHG_800_mA\t\t0x7\n\n#define ADC_CONV_TIME_MS\t\t35\n#define ADC_CONV_POLLING_TIME_US\t1000\n\n#define MT6370_VID_RT5081\t\t0x8\n#define MT6370_VID_RT5081A\t\t0xA\n#define MT6370_VID_MT6370\t\t0xE\n\nstruct mt6370_adc_data {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\t \n\tstruct mutex adc_lock;\n\tunsigned int vid;\n};\n\nstatic int mt6370_adc_read_channel(struct mt6370_adc_data *priv, int chan,\n\t\t\t\t   unsigned long addr, int *val)\n{\n\tunsigned int reg_val;\n\t__be16 be_val;\n\tint ret;\n\n\tmutex_lock(&priv->adc_lock);\n\n\treg_val = MT6370_ADC_START_MASK |\n\t\t  FIELD_PREP(MT6370_ADC_IN_SEL_MASK, addr);\n\tret = regmap_write(priv->regmap, MT6370_REG_CHG_ADC, reg_val);\n\tif (ret)\n\t\tgoto adc_unlock;\n\n\tmsleep(ADC_CONV_TIME_MS);\n\n\tret = regmap_read_poll_timeout(priv->regmap,\n\t\t\t\t       MT6370_REG_CHG_ADC, reg_val,\n\t\t\t\t       !(reg_val & MT6370_ADC_START_MASK),\n\t\t\t\t       ADC_CONV_POLLING_TIME_US,\n\t\t\t\t       ADC_CONV_TIME_MS * MILLI * 3);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to read ADC register (%d)\\n\", ret);\n\t\tgoto adc_unlock;\n\t}\n\n\tret = regmap_raw_read(priv->regmap, MT6370_REG_ADC_DATA_H,\n\t\t\t      &be_val, sizeof(be_val));\n\tif (ret)\n\t\tgoto adc_unlock;\n\n\t*val = be16_to_cpu(be_val);\n\tret = IIO_VAL_INT;\n\nadc_unlock:\n\tmutex_unlock(&priv->adc_lock);\n\n\treturn ret;\n}\n\nstatic int mt6370_adc_get_ibus_scale(struct mt6370_adc_data *priv)\n{\n\tswitch (priv->vid) {\n\tcase MT6370_VID_RT5081:\n\tcase MT6370_VID_RT5081A:\n\tcase MT6370_VID_MT6370:\n\t\treturn 3350;\n\tdefault:\n\t\treturn 3875;\n\t}\n}\n\nstatic int mt6370_adc_get_ibat_scale(struct mt6370_adc_data *priv)\n{\n\tswitch (priv->vid) {\n\tcase MT6370_VID_RT5081:\n\tcase MT6370_VID_RT5081A:\n\tcase MT6370_VID_MT6370:\n\t\treturn 2680;\n\tdefault:\n\t\treturn 3870;\n\t}\n}\n\nstatic int mt6370_adc_read_scale(struct mt6370_adc_data *priv,\n\t\t\t\t int chan, int *val1, int *val2)\n{\n\tunsigned int reg_val;\n\tint ret;\n\n\tswitch (chan) {\n\tcase MT6370_CHAN_VBAT:\n\tcase MT6370_CHAN_VSYS:\n\tcase MT6370_CHAN_CHG_VDDP:\n\t\t*val1 = 5;\n\t\treturn IIO_VAL_INT;\n\tcase MT6370_CHAN_IBUS:\n\t\tret = regmap_read(priv->regmap, MT6370_REG_CHG_CTRL3, &reg_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treg_val = FIELD_GET(MT6370_AICR_ICHG_MASK, reg_val);\n\t\tswitch (reg_val) {\n\t\tcase MT6370_AICR_100_mA:\n\t\tcase MT6370_AICR_150_mA:\n\t\tcase MT6370_AICR_200_mA:\n\t\tcase MT6370_AICR_250_mA:\n\t\tcase MT6370_AICR_300_mA:\n\t\tcase MT6370_AICR_350_mA:\n\t\t\t*val1 = mt6370_adc_get_ibus_scale(priv);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*val1 = 5000;\n\t\t\tbreak;\n\t\t}\n\n\t\t*val2 = 100;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase MT6370_CHAN_IBAT:\n\t\tret = regmap_read(priv->regmap, MT6370_REG_CHG_CTRL7, &reg_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treg_val = FIELD_GET(MT6370_AICR_ICHG_MASK, reg_val);\n\t\tswitch (reg_val) {\n\t\tcase MT6370_ICHG_100_mA:\n\t\tcase MT6370_ICHG_200_mA:\n\t\tcase MT6370_ICHG_300_mA:\n\t\tcase MT6370_ICHG_400_mA:\n\t\t\t*val1 = 2375;\n\t\t\tbreak;\n\t\tcase MT6370_ICHG_500_mA:\n\t\tcase MT6370_ICHG_600_mA:\n\t\tcase MT6370_ICHG_700_mA:\n\t\tcase MT6370_ICHG_800_mA:\n\t\t\t*val1 = mt6370_adc_get_ibat_scale(priv);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*val1 = 5000;\n\t\t\tbreak;\n\t\t}\n\n\t\t*val2 = 100;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase MT6370_CHAN_VBUSDIV5:\n\t\t*val1 = 25;\n\t\treturn IIO_VAL_INT;\n\tcase MT6370_CHAN_VBUSDIV2:\n\t\t*val1 = 10;\n\t\treturn IIO_VAL_INT;\n\tcase MT6370_CHAN_TS_BAT:\n\t\t*val1 = 25;\n\t\t*val2 = 10000;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase MT6370_CHAN_TEMP_JC:\n\t\t*val1 = 2000;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mt6370_adc_read_offset(struct mt6370_adc_data *priv,\n\t\t\t\t  int chan, int *val)\n{\n\t*val = -20;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int mt6370_adc_read_raw(struct iio_dev *iio_dev,\n\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t       int *val, int *val2, long mask)\n{\n\tstruct mt6370_adc_data *priv = iio_priv(iio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn mt6370_adc_read_channel(priv, chan->channel,\n\t\t\t\t\t       chan->address, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn mt6370_adc_read_scale(priv, chan->channel, val, val2);\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\treturn mt6370_adc_read_offset(priv, chan->channel, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const char * const mt6370_channel_labels[MT6370_CHAN_MAX] = {\n\t[MT6370_CHAN_VBUSDIV5] = \"vbusdiv5\",\n\t[MT6370_CHAN_VBUSDIV2] = \"vbusdiv2\",\n\t[MT6370_CHAN_VSYS] = \"vsys\",\n\t[MT6370_CHAN_VBAT] = \"vbat\",\n\t[MT6370_CHAN_TS_BAT] = \"ts_bat\",\n\t[MT6370_CHAN_IBUS] = \"ibus\",\n\t[MT6370_CHAN_IBAT] = \"ibat\",\n\t[MT6370_CHAN_CHG_VDDP] = \"chg_vddp\",\n\t[MT6370_CHAN_TEMP_JC] = \"temp_jc\",\n};\n\nstatic int mt6370_adc_read_label(struct iio_dev *iio_dev,\n\t\t\t\t struct iio_chan_spec const *chan, char *label)\n{\n\treturn sysfs_emit(label, \"%s\\n\", mt6370_channel_labels[chan->channel]);\n}\n\nstatic const struct iio_info mt6370_adc_iio_info = {\n\t.read_raw = mt6370_adc_read_raw,\n\t.read_label = mt6370_adc_read_label,\n};\n\n#define MT6370_ADC_CHAN(_idx, _type, _addr, _extra_info) {\t\\\n\t.type = _type,\t\t\t\t\t\t\\\n\t.channel = MT6370_CHAN_##_idx,\t\t\t\t\\\n\t.address = _addr,\t\t\t\t\t\\\n\t.scan_index = MT6370_CHAN_##_idx,\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t      _extra_info,\t\t\t\\\n}\n\nstatic const struct iio_chan_spec mt6370_adc_channels[] = {\n\tMT6370_ADC_CHAN(VBUSDIV5, IIO_VOLTAGE, 1, 0),\n\tMT6370_ADC_CHAN(VBUSDIV2, IIO_VOLTAGE, 2, 0),\n\tMT6370_ADC_CHAN(VSYS, IIO_VOLTAGE, 3, 0),\n\tMT6370_ADC_CHAN(VBAT, IIO_VOLTAGE, 4, 0),\n\tMT6370_ADC_CHAN(TS_BAT, IIO_VOLTAGE, 6, 0),\n\tMT6370_ADC_CHAN(IBUS, IIO_CURRENT, 8, 0),\n\tMT6370_ADC_CHAN(IBAT, IIO_CURRENT, 9, 0),\n\tMT6370_ADC_CHAN(CHG_VDDP, IIO_VOLTAGE, 11, 0),\n\tMT6370_ADC_CHAN(TEMP_JC, IIO_TEMP, 12, BIT(IIO_CHAN_INFO_OFFSET)),\n};\n\nstatic int mt6370_get_vendor_info(struct mt6370_adc_data *priv)\n{\n\tunsigned int dev_info;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, MT6370_REG_DEV_INFO, &dev_info);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->vid = FIELD_GET(MT6370_VENID_MASK, dev_info);\n\n\treturn 0;\n}\n\nstatic int mt6370_adc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mt6370_adc_data *priv;\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tregmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!regmap)\n\t\treturn dev_err_probe(dev, -ENODEV, \"Failed to get regmap\\n\");\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*priv));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tpriv = iio_priv(indio_dev);\n\tpriv->dev = dev;\n\tpriv->regmap = regmap;\n\tmutex_init(&priv->adc_lock);\n\n\tret = mt6370_get_vendor_info(priv);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to get vid\\n\");\n\n\tret = regmap_write(priv->regmap, MT6370_REG_CHG_ADC, 0);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to reset ADC\\n\");\n\n\tindio_dev->name = \"mt6370-adc\";\n\tindio_dev->info = &mt6370_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = mt6370_adc_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mt6370_adc_channels);\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id mt6370_adc_of_id[] = {\n\t{ .compatible = \"mediatek,mt6370-adc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mt6370_adc_of_id);\n\nstatic struct platform_driver mt6370_adc_driver = {\n\t.driver = {\n\t\t.name = \"mt6370-adc\",\n\t\t.of_match_table = mt6370_adc_of_id,\n\t},\n\t.probe = mt6370_adc_probe,\n};\nmodule_platform_driver(mt6370_adc_driver);\n\nMODULE_AUTHOR(\"ChiaEn Wu <chiaen_wu@richtek.com>\");\nMODULE_DESCRIPTION(\"MT6370 ADC Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}