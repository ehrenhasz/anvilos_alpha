{
  "module_name": "twl6030-gpadc.c",
  "hash_id": "de08e43b6988282c2aca24be7e2ba636d7a3aa8030f62ca3aa1aa0ed220cb8f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/twl6030-gpadc.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of_platform.h>\n#include <linux/mfd/twl.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define DRIVER_NAME\t\t\"twl6030_gpadc\"\n\n \n#define TWL6030_GPADC_USED_CHANNELS\t\t13\n#define TWL6030_GPADC_MAX_CHANNELS\t\t15\n#define TWL6032_GPADC_USED_CHANNELS\t\t15\n#define TWL6032_GPADC_MAX_CHANNELS\t\t19\n#define TWL6030_GPADC_NUM_TRIM_REGS\t\t16\n\n#define TWL6030_GPADC_CTRL_P1\t\t\t0x05\n\n#define TWL6032_GPADC_GPSELECT_ISB\t\t0x07\n#define TWL6032_GPADC_CTRL_P1\t\t\t0x08\n\n#define TWL6032_GPADC_GPCH0_LSB\t\t\t0x0d\n#define TWL6032_GPADC_GPCH0_MSB\t\t\t0x0e\n\n#define TWL6030_GPADC_CTRL_P1_SP1\t\tBIT(3)\n\n#define TWL6030_GPADC_GPCH0_LSB\t\t\t(0x29)\n\n#define TWL6030_GPADC_RT_SW1_EOC_MASK\t\tBIT(5)\n\n#define TWL6030_GPADC_TRIM1\t\t\t0xCD\n\n#define TWL6030_REG_TOGGLE1\t\t\t0x90\n#define TWL6030_GPADCS\t\t\t\tBIT(1)\n#define TWL6030_GPADCR\t\t\t\tBIT(0)\n\n#define USB_VBUS_CTRL_SET\t\t\t0x04\n#define USB_ID_CTRL_SET\t\t\t\t0x06\n\n#define TWL6030_MISC1\t\t\t\t0xE4\n#define VBUS_MEAS\t\t\t\t0x01\n#define ID_MEAS\t\t\t\t\t0x01\n\n#define VAC_MEAS                0x04\n#define VBAT_MEAS               0x02\n#define BB_MEAS                 0x01\n\n\n \nstruct twl6030_chnl_calib {\n\ts32 gain;\n\ts32 gain_error;\n\ts32 offset_error;\n};\n\n \nstruct twl6030_ideal_code {\n\tint channel;\n\tu16 code1;\n\tu16 code2;\n\tu16 volt1;\n\tu16 volt2;\n};\n\nstruct twl6030_gpadc_data;\n\n \nstruct twl6030_gpadc_platform_data {\n\tconst int nchannels;\n\tconst struct iio_chan_spec *iio_channels;\n\tconst struct twl6030_ideal_code *ideal;\n\tint (*start_conversion)(int channel);\n\tu8 (*channel_to_reg)(int channel);\n\tint (*calibrate)(struct twl6030_gpadc_data *gpadc);\n};\n\n \nstruct twl6030_gpadc_data {\n\tstruct device\t*dev;\n\tstruct mutex\tlock;\n\tstruct completion\tirq_complete;\n\tstruct twl6030_chnl_calib\t*twl6030_cal_tbl;\n\tconst struct twl6030_gpadc_platform_data *pdata;\n};\n\n \nstatic const struct twl6030_ideal_code\n\ttwl6030_ideal[TWL6030_GPADC_USED_CHANNELS] = {\n\t[0] = {  \n\t\t.channel = 0,\n\t\t.code1 = 116,\n\t\t.code2 = 745,\n\t\t.volt1 = 141,\n\t\t.volt2 = 910,\n\t},\n\t[1] = {  \n\t\t.channel = 1,\n\t\t.code1 = 82,\n\t\t.code2 = 900,\n\t\t.volt1 = 100,\n\t\t.volt2 = 1100,\n\t},\n\t[2] = {  \n\t\t.channel = 2,\n\t\t.code1 = 55,\n\t\t.code2 = 818,\n\t\t.volt1 = 101,\n\t\t.volt2 = 1499,\n\t},\n\t[3] = {  \n\t\t.channel = 3,\n\t\t.code1 = 82,\n\t\t.code2 = 900,\n\t\t.volt1 = 100,\n\t\t.volt2 = 1100,\n\t},\n\t[4] = {  \n\t\t.channel = 4,\n\t\t.code1 = 82,\n\t\t.code2 = 900,\n\t\t.volt1 = 100,\n\t\t.volt2 = 1100,\n\t},\n\t[5] = {  \n\t\t.channel = 5,\n\t\t.code1 = 82,\n\t\t.code2 = 900,\n\t\t.volt1 = 100,\n\t\t.volt2 = 1100,\n\t},\n\t[6] = {  \n\t\t.channel = 6,\n\t\t.code1 = 82,\n\t\t.code2 = 900,\n\t\t.volt1 = 100,\n\t\t.volt2 = 1100,\n\t},\n\t[7] = {  \n\t\t.channel = 7,\n\t\t.code1 = 614,\n\t\t.code2 = 941,\n\t\t.volt1 = 3001,\n\t\t.volt2 = 4599,\n\t},\n\t[8] = {  \n\t\t.channel = 8,\n\t\t.code1 = 82,\n\t\t.code2 = 688,\n\t\t.volt1 = 501,\n\t\t.volt2 = 4203,\n\t},\n\t[9] = {  \n\t\t.channel = 9,\n\t\t.code1 = 182,\n\t\t.code2 = 818,\n\t\t.volt1 = 2001,\n\t\t.volt2 = 8996,\n\t},\n\t[10] = {  \n\t\t.channel = 10,\n\t\t.code1 = 149,\n\t\t.code2 = 818,\n\t\t.volt1 = 1001,\n\t\t.volt2 = 5497,\n\t},\n\t[11] = {  \n\t\t.channel = 11,\n\t},\n\t\t \n\t\t \n\t[12] = {  \n\t\t.channel = 14,\n\t\t.code1 = 48,\n\t\t.code2 = 714,\n\t\t.volt1 = 323,\n\t\t.volt2 = 4800,\n\t},\n};\n\nstatic const struct twl6030_ideal_code\n\t\t\ttwl6032_ideal[TWL6032_GPADC_USED_CHANNELS] = {\n\t[0] = {  \n\t\t.channel = 0,\n\t\t.code1 = 1441,\n\t\t.code2 = 3276,\n\t\t.volt1 = 440,\n\t\t.volt2 = 1000,\n\t},\n\t[1] = {  \n\t\t.channel = 1,\n\t\t.code1 = 1441,\n\t\t.code2 = 3276,\n\t\t.volt1 = 440,\n\t\t.volt2 = 1000,\n\t},\n\t[2] = {  \n\t\t.channel = 2,\n\t\t.code1 = 1441,\n\t\t.code2 = 3276,\n\t\t.volt1 = 660,\n\t\t.volt2 = 1500,\n\t},\n\t[3] = {  \n\t\t.channel = 3,\n\t\t.code1 = 1441,\n\t\t.code2 = 3276,\n\t\t.volt1 = 440,\n\t\t.volt2 = 1000,\n\t},\n\t[4] = {  \n\t\t.channel = 4,\n\t\t.code1 = 1441,\n\t\t.code2 = 3276,\n\t\t.volt1 = 440,\n\t\t.volt2 = 1000,\n\t},\n\t[5] = {  \n\t\t.channel = 5,\n\t\t.code1 = 1441,\n\t\t.code2 = 3276,\n\t\t.volt1 = 440,\n\t\t.volt2 = 1000,\n\t},\n\t[6] = {  \n\t\t.channel = 6,\n\t\t.code1 = 1441,\n\t\t.code2 = 3276,\n\t\t.volt1 = 440,\n\t\t.volt2 = 1000,\n\t},\n\t[7] = {  \n\t\t.channel = 7,\n\t\t.code1 = 1441,\n\t\t.code2 = 3276,\n\t\t.volt1 = 2200,\n\t\t.volt2 = 5000,\n\t},\n\t[8] = {  \n\t\t.channel = 8,\n\t\t.code1 = 1441,\n\t\t.code2 = 3276,\n\t\t.volt1 = 2200,\n\t\t.volt2 = 5000,\n\t},\n\t[9] = {  \n\t\t.channel = 9,\n\t\t.code1 = 1441,\n\t\t.code2 = 3276,\n\t\t.volt1 = 3960,\n\t\t.volt2 = 9000,\n\t},\n\t[10] = {  \n\t\t.channel = 10,\n\t\t.code1 = 150,\n\t\t.code2 = 751,\n\t\t.volt1 = 1000,\n\t\t.volt2 = 5000,\n\t},\n\t[11] = {  \n\t\t.channel = 11,\n\t\t.code1 = 1441,\n\t\t.code2 = 3276,\n\t\t.volt1 = 660,\n\t\t.volt2 = 1500,\n\t},\n\t\t \n\t\t \n\t[12] = {  \n\t\t.channel = 14,\n\t\t.code1 = 1441,\n\t\t.code2 = 3276,\n\t\t.volt1 = 2420,\n\t\t.volt2 = 5500,\n\t},\n\t\t \n\t\t \n\t[13] = {  \n\t\t.channel = 17,\n\t},\n\t[14] = {  \n\t\t.channel = 18,\n\t\t.code1 = 1441,\n\t\t.code2 = 3276,\n\t\t.volt1 = 2200,\n\t\t.volt2 = 5000,\n\t},\n};\n\nstatic inline int twl6030_gpadc_write(u8 reg, u8 val)\n{\n\treturn twl_i2c_write_u8(TWL6030_MODULE_GPADC, val, reg);\n}\n\nstatic inline int twl6030_gpadc_read(u8 reg, u8 *val)\n{\n\n\treturn twl_i2c_read(TWL6030_MODULE_GPADC, val, reg, 2);\n}\n\nstatic int twl6030_gpadc_enable_irq(u8 mask)\n{\n\tint ret;\n\n\tret = twl6030_interrupt_unmask(mask, REG_INT_MSK_LINE_B);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = twl6030_interrupt_unmask(mask, REG_INT_MSK_STS_B);\n\n\treturn ret;\n}\n\nstatic void twl6030_gpadc_disable_irq(u8 mask)\n{\n\ttwl6030_interrupt_mask(mask, REG_INT_MSK_LINE_B);\n\ttwl6030_interrupt_mask(mask, REG_INT_MSK_STS_B);\n}\n\nstatic irqreturn_t twl6030_gpadc_irq_handler(int irq, void *indio_dev)\n{\n\tstruct twl6030_gpadc_data *gpadc = iio_priv(indio_dev);\n\n\tcomplete(&gpadc->irq_complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int twl6030_start_conversion(int channel)\n{\n\treturn twl6030_gpadc_write(TWL6030_GPADC_CTRL_P1,\n\t\t\t\t\tTWL6030_GPADC_CTRL_P1_SP1);\n}\n\nstatic int twl6032_start_conversion(int channel)\n{\n\tint ret;\n\n\tret = twl6030_gpadc_write(TWL6032_GPADC_GPSELECT_ISB, channel);\n\tif (ret)\n\t\treturn ret;\n\n\treturn twl6030_gpadc_write(TWL6032_GPADC_CTRL_P1,\n\t\t\t\t\t\tTWL6030_GPADC_CTRL_P1_SP1);\n}\n\nstatic u8 twl6030_channel_to_reg(int channel)\n{\n\treturn TWL6030_GPADC_GPCH0_LSB + 2 * channel;\n}\n\nstatic u8 twl6032_channel_to_reg(int channel)\n{\n\t \n\n\treturn TWL6032_GPADC_GPCH0_LSB;\n}\n\nstatic int twl6030_gpadc_lookup(const struct twl6030_ideal_code *ideal,\n\t\tint channel, int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tif (ideal[i].channel == channel)\n\t\t\tbreak;\n\n\treturn i;\n}\n\nstatic int twl6030_channel_calibrated(const struct twl6030_gpadc_platform_data\n\t\t*pdata, int channel)\n{\n\tconst struct twl6030_ideal_code *ideal = pdata->ideal;\n\tint i;\n\n\ti = twl6030_gpadc_lookup(ideal, channel, pdata->nchannels);\n\t \n\treturn pdata->ideal[i].code2;\n}\n\nstatic int twl6030_gpadc_make_correction(struct twl6030_gpadc_data *gpadc,\n\t\tint channel, int raw_code)\n{\n\tconst struct twl6030_ideal_code *ideal = gpadc->pdata->ideal;\n\tint corrected_code;\n\tint i;\n\n\ti = twl6030_gpadc_lookup(ideal, channel, gpadc->pdata->nchannels);\n\tcorrected_code = ((raw_code * 1000) -\n\t\tgpadc->twl6030_cal_tbl[i].offset_error) /\n\t\tgpadc->twl6030_cal_tbl[i].gain_error;\n\n\treturn corrected_code;\n}\n\nstatic int twl6030_gpadc_get_raw(struct twl6030_gpadc_data *gpadc,\n\t\tint channel, int *res)\n{\n\tu8 reg = gpadc->pdata->channel_to_reg(channel);\n\t__le16 val;\n\tint raw_code;\n\tint ret;\n\n\tret = twl6030_gpadc_read(reg, (u8 *)&val);\n\tif (ret) {\n\t\tdev_dbg(gpadc->dev, \"unable to read register 0x%X\\n\", reg);\n\t\treturn ret;\n\t}\n\n\traw_code = le16_to_cpu(val);\n\tdev_dbg(gpadc->dev, \"GPADC raw code: %d\", raw_code);\n\n\tif (twl6030_channel_calibrated(gpadc->pdata, channel))\n\t\t*res = twl6030_gpadc_make_correction(gpadc, channel, raw_code);\n\telse\n\t\t*res = raw_code;\n\n\treturn ret;\n}\n\nstatic int twl6030_gpadc_get_processed(struct twl6030_gpadc_data *gpadc,\n\t\tint channel, int *val)\n{\n\tconst struct twl6030_ideal_code *ideal = gpadc->pdata->ideal;\n\tint corrected_code;\n\tint channel_value;\n\tint i;\n\tint ret;\n\n\tret = twl6030_gpadc_get_raw(gpadc, channel, &corrected_code);\n\tif (ret)\n\t\treturn ret;\n\n\ti = twl6030_gpadc_lookup(ideal, channel, gpadc->pdata->nchannels);\n\tchannel_value = corrected_code *\n\t\t\tgpadc->twl6030_cal_tbl[i].gain;\n\n\t \n\tchannel_value /= 1000;\n\n\tdev_dbg(gpadc->dev, \"GPADC corrected code: %d\", corrected_code);\n\tdev_dbg(gpadc->dev, \"GPADC value: %d\", channel_value);\n\n\t*val = channel_value;\n\n\treturn ret;\n}\n\nstatic int twl6030_gpadc_read_raw(struct iio_dev *indio_dev,\n\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct twl6030_gpadc_data *gpadc = iio_priv(indio_dev);\n\tint ret;\n\tlong timeout;\n\n\tmutex_lock(&gpadc->lock);\n\n\tret = gpadc->pdata->start_conversion(chan->channel);\n\tif (ret) {\n\t\tdev_err(gpadc->dev, \"failed to start conversion\\n\");\n\t\tgoto err;\n\t}\n\t \n\ttimeout = wait_for_completion_interruptible_timeout(\n\t\t\t\t&gpadc->irq_complete, msecs_to_jiffies(5000));\n\tif (timeout == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err;\n\t} else if (timeout < 0) {\n\t\tret = -EINTR;\n\t\tgoto err;\n\t}\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = twl6030_gpadc_get_raw(gpadc, chan->channel, val);\n\t\tret = ret ? -EIO : IIO_VAL_INT;\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tret = twl6030_gpadc_get_processed(gpadc, chan->channel, val);\n\t\tret = ret ? -EIO : IIO_VAL_INT;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\nerr:\n\tmutex_unlock(&gpadc->lock);\n\n\treturn ret;\n}\n\n \nstatic void twl6030_calibrate_channel(struct twl6030_gpadc_data *gpadc,\n\t\tint channel, int d1, int d2)\n{\n\tint b, k, gain, x1, x2, i;\n\tconst struct twl6030_ideal_code *ideal = gpadc->pdata->ideal;\n\n\ti = twl6030_gpadc_lookup(ideal, channel, gpadc->pdata->nchannels);\n\n\t \n\tgain = ((ideal[i].volt2 - ideal[i].volt1) * 1000) /\n\t\t(ideal[i].code2 - ideal[i].code1);\n\n\tx1 = ideal[i].code1;\n\tx2 = ideal[i].code2;\n\n\t \n\tk = 1000 + (((d2 - d1) * 1000) / (x2 - x1));\n\n\t \n\tb = (d1 * 1000) - (k - 1000) * x1;\n\n\tgpadc->twl6030_cal_tbl[i].gain = gain;\n\tgpadc->twl6030_cal_tbl[i].gain_error = k;\n\tgpadc->twl6030_cal_tbl[i].offset_error = b;\n\n\tdev_dbg(gpadc->dev, \"GPADC d1   for Chn: %d = %d\\n\", channel, d1);\n\tdev_dbg(gpadc->dev, \"GPADC d2   for Chn: %d = %d\\n\", channel, d2);\n\tdev_dbg(gpadc->dev, \"GPADC x1   for Chn: %d = %d\\n\", channel, x1);\n\tdev_dbg(gpadc->dev, \"GPADC x2   for Chn: %d = %d\\n\", channel, x2);\n\tdev_dbg(gpadc->dev, \"GPADC Gain for Chn: %d = %d\\n\", channel, gain);\n\tdev_dbg(gpadc->dev, \"GPADC k    for Chn: %d = %d\\n\", channel, k);\n\tdev_dbg(gpadc->dev, \"GPADC b    for Chn: %d = %d\\n\", channel, b);\n}\n\nstatic inline int twl6030_gpadc_get_trim_offset(s8 d)\n{\n\t \n\t__u32 temp = ((d & 0x7f) >> 1) | ((d & 1) << 6);\n\n\treturn sign_extend32(temp, 6);\n}\n\nstatic int twl6030_calibration(struct twl6030_gpadc_data *gpadc)\n{\n\tint ret;\n\tint chn;\n\tu8 trim_regs[TWL6030_GPADC_NUM_TRIM_REGS];\n\ts8 d1, d2;\n\n\t \n\tret = twl_i2c_read(TWL6030_MODULE_ID2, trim_regs,\n\t\t\tTWL6030_GPADC_TRIM1, TWL6030_GPADC_NUM_TRIM_REGS);\n\tif (ret < 0) {\n\t\tdev_err(gpadc->dev, \"calibration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (chn = 0; chn < TWL6030_GPADC_MAX_CHANNELS; chn++) {\n\n\t\tswitch (chn) {\n\t\tcase 0:\n\t\t\td1 = trim_regs[0];\n\t\t\td2 = trim_regs[1];\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\t\td1 = trim_regs[4];\n\t\t\td2 = trim_regs[5];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\td1 = trim_regs[12];\n\t\t\td2 = trim_regs[13];\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\td1 = trim_regs[6];\n\t\t\td2 = trim_regs[7];\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\td1 = trim_regs[2];\n\t\t\td2 = trim_regs[3];\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\td1 = trim_regs[8];\n\t\t\td2 = trim_regs[9];\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\td1 = trim_regs[10];\n\t\t\td2 = trim_regs[11];\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\td1 = trim_regs[14];\n\t\t\td2 = trim_regs[15];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\td1 = twl6030_gpadc_get_trim_offset(d1);\n\t\td2 = twl6030_gpadc_get_trim_offset(d2);\n\n\t\ttwl6030_calibrate_channel(gpadc, chn, d1, d2);\n\t}\n\n\treturn 0;\n}\n\nstatic int twl6032_get_trim_value(u8 *trim_regs, unsigned int reg0,\n\t\tunsigned int reg1, unsigned int mask0, unsigned int mask1,\n\t\tunsigned int shift0)\n{\n\tint val;\n\n\tval = (trim_regs[reg0] & mask0) << shift0;\n\tval |= (trim_regs[reg1] & mask1) >> 1;\n\tif (trim_regs[reg1] & 0x01)\n\t\tval = -val;\n\n\treturn val;\n}\n\nstatic int twl6032_calibration(struct twl6030_gpadc_data *gpadc)\n{\n\tint chn, d1 = 0, d2 = 0, temp;\n\tu8 trim_regs[TWL6030_GPADC_NUM_TRIM_REGS];\n\tint ret;\n\n\tret = twl_i2c_read(TWL6030_MODULE_ID2, trim_regs,\n\t\t\tTWL6030_GPADC_TRIM1, TWL6030_GPADC_NUM_TRIM_REGS);\n\tif (ret < 0) {\n\t\tdev_err(gpadc->dev, \"calibration failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (chn = 0; chn < TWL6032_GPADC_MAX_CHANNELS; chn++) {\n\n\t\tswitch (chn) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 11:\n\t\tcase 14:\n\t\t\td1 = twl6032_get_trim_value(trim_regs, 2, 0, 0x1f,\n\t\t\t\t\t\t\t\t0x06, 2);\n\t\t\td2 = twl6032_get_trim_value(trim_regs, 3, 1, 0x3f,\n\t\t\t\t\t\t\t\t0x06, 2);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\ttemp = twl6032_get_trim_value(trim_regs, 2, 0, 0x1f,\n\t\t\t\t\t\t\t\t0x06, 2);\n\t\t\td1 = temp + twl6032_get_trim_value(trim_regs, 7, 6,\n\t\t\t\t\t\t\t\t0x18, 0x1E, 1);\n\n\t\t\ttemp = twl6032_get_trim_value(trim_regs, 3, 1, 0x3F,\n\t\t\t\t\t\t\t\t0x06, 2);\n\t\t\td2 = temp + twl6032_get_trim_value(trim_regs, 9, 7,\n\t\t\t\t\t\t\t\t0x1F, 0x06, 2);\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\ttemp = twl6032_get_trim_value(trim_regs, 2, 0, 0x1f,\n\t\t\t\t\t\t\t\t0x06, 2);\n\t\t\td1 = temp + twl6032_get_trim_value(trim_regs, 13, 11,\n\t\t\t\t\t\t\t\t0x18, 0x1E, 1);\n\n\t\t\ttemp = twl6032_get_trim_value(trim_regs, 3, 1, 0x3f,\n\t\t\t\t\t\t\t\t0x06, 2);\n\t\t\td2 = temp + twl6032_get_trim_value(trim_regs, 15, 13,\n\t\t\t\t\t\t\t\t0x1F, 0x06, 1);\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\td1 = twl6032_get_trim_value(trim_regs, 10, 8, 0x0f,\n\t\t\t\t\t\t\t\t0x0E, 3);\n\t\t\td2 = twl6032_get_trim_value(trim_regs, 14, 12, 0x0f,\n\t\t\t\t\t\t\t\t0x0E, 3);\n\t\t\tbreak;\n\t\tcase 7:\n\t\tcase 18:\n\t\t\ttemp = twl6032_get_trim_value(trim_regs, 2, 0, 0x1f,\n\t\t\t\t\t\t\t\t0x06, 2);\n\n\t\t\td1 = (trim_regs[4] & 0x7E) >> 1;\n\t\t\tif (trim_regs[4] & 0x01)\n\t\t\t\td1 = -d1;\n\t\t\td1 += temp;\n\n\t\t\ttemp = twl6032_get_trim_value(trim_regs, 3, 1, 0x3f,\n\t\t\t\t\t\t\t\t0x06, 2);\n\n\t\t\td2 = (trim_regs[5] & 0xFE) >> 1;\n\t\t\tif (trim_regs[5] & 0x01)\n\t\t\t\td2 = -d2;\n\n\t\t\td2 += temp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\ttwl6030_calibrate_channel(gpadc, chn, d1, d2);\n\t}\n\n\treturn 0;\n}\n\n#define TWL6030_GPADC_CHAN(chn, _type, chan_info) {\t\\\n\t.type = _type,\t\t\t\t\t\\\n\t.channel = chn,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(chan_info),\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec twl6030_gpadc_iio_channels[] = {\n\tTWL6030_GPADC_CHAN(0, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(1, IIO_TEMP, IIO_CHAN_INFO_RAW),\n\tTWL6030_GPADC_CHAN(2, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(3, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(4, IIO_TEMP, IIO_CHAN_INFO_RAW),\n\tTWL6030_GPADC_CHAN(5, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(6, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(7, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(8, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(9, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(10, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(11, IIO_VOLTAGE, IIO_CHAN_INFO_RAW),\n\tTWL6030_GPADC_CHAN(14, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n};\n\nstatic const struct iio_chan_spec twl6032_gpadc_iio_channels[] = {\n\tTWL6030_GPADC_CHAN(0, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(1, IIO_TEMP, IIO_CHAN_INFO_RAW),\n\tTWL6030_GPADC_CHAN(2, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(3, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(4, IIO_TEMP, IIO_CHAN_INFO_RAW),\n\tTWL6030_GPADC_CHAN(5, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(6, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(7, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(8, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(9, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(10, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(11, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(14, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n\tTWL6030_GPADC_CHAN(17, IIO_VOLTAGE, IIO_CHAN_INFO_RAW),\n\tTWL6030_GPADC_CHAN(18, IIO_VOLTAGE, IIO_CHAN_INFO_PROCESSED),\n};\n\nstatic const struct iio_info twl6030_gpadc_iio_info = {\n\t.read_raw = &twl6030_gpadc_read_raw,\n};\n\nstatic const struct twl6030_gpadc_platform_data twl6030_pdata = {\n\t.iio_channels = twl6030_gpadc_iio_channels,\n\t.nchannels = TWL6030_GPADC_USED_CHANNELS,\n\t.ideal = twl6030_ideal,\n\t.start_conversion = twl6030_start_conversion,\n\t.channel_to_reg = twl6030_channel_to_reg,\n\t.calibrate = twl6030_calibration,\n};\n\nstatic const struct twl6030_gpadc_platform_data twl6032_pdata = {\n\t.iio_channels = twl6032_gpadc_iio_channels,\n\t.nchannels = TWL6032_GPADC_USED_CHANNELS,\n\t.ideal = twl6032_ideal,\n\t.start_conversion = twl6032_start_conversion,\n\t.channel_to_reg = twl6032_channel_to_reg,\n\t.calibrate = twl6032_calibration,\n};\n\nstatic const struct of_device_id of_twl6030_match_tbl[] = {\n\t{\n\t\t.compatible = \"ti,twl6030-gpadc\",\n\t\t.data = &twl6030_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,twl6032-gpadc\",\n\t\t.data = &twl6032_pdata,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_twl6030_match_tbl);\n\nstatic int twl6030_gpadc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct twl6030_gpadc_data *gpadc;\n\tconst struct twl6030_gpadc_platform_data *pdata;\n\tconst struct of_device_id *match;\n\tstruct iio_dev *indio_dev;\n\tint irq;\n\tint ret;\n\n\tmatch = of_match_device(of_twl6030_match_tbl, dev);\n\tif (!match)\n\t\treturn -EINVAL;\n\n\tpdata = match->data;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*gpadc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tgpadc = iio_priv(indio_dev);\n\n\tgpadc->twl6030_cal_tbl = devm_kcalloc(dev,\n\t\t\t\t\tpdata->nchannels,\n\t\t\t\t\tsizeof(*gpadc->twl6030_cal_tbl),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!gpadc->twl6030_cal_tbl)\n\t\treturn -ENOMEM;\n\n\tgpadc->dev = dev;\n\tgpadc->pdata = pdata;\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\tmutex_init(&gpadc->lock);\n\tinit_completion(&gpadc->irq_complete);\n\n\tret = pdata->calibrate(gpadc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read calibration registers\\n\");\n\t\treturn ret;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\ttwl6030_gpadc_irq_handler,\n\t\t\t\tIRQF_ONESHOT, \"twl6030_gpadc\", indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = twl6030_gpadc_enable_irq(TWL6030_GPADC_RT_SW1_EOC_MASK);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable GPADC interrupt\\n\");\n\t\treturn ret;\n\t}\n\n\tret = twl_i2c_write_u8(TWL6030_MODULE_ID1, TWL6030_GPADCS,\n\t\t\t\t\tTWL6030_REG_TOGGLE1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable GPADC module\\n\");\n\t\treturn ret;\n\t}\n\n\tret = twl_i2c_write_u8(TWL_MODULE_USB, VBUS_MEAS, USB_VBUS_CTRL_SET);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to wire up inputs\\n\");\n\t\treturn ret;\n\t}\n\n\tret = twl_i2c_write_u8(TWL_MODULE_USB, ID_MEAS, USB_ID_CTRL_SET);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to wire up inputs\\n\");\n\t\treturn ret;\n\t}\n\n\tret = twl_i2c_write_u8(TWL6030_MODULE_ID0,\n\t\t\t\tVBAT_MEAS | BB_MEAS | VAC_MEAS,\n\t\t\t\tTWL6030_MISC1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to wire up inputs\\n\");\n\t\treturn ret;\n\t}\n\n\tindio_dev->name = DRIVER_NAME;\n\tindio_dev->info = &twl6030_gpadc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = pdata->iio_channels;\n\tindio_dev->num_channels = pdata->nchannels;\n\n\treturn iio_device_register(indio_dev);\n}\n\nstatic int twl6030_gpadc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\n\ttwl6030_gpadc_disable_irq(TWL6030_GPADC_RT_SW1_EOC_MASK);\n\tiio_device_unregister(indio_dev);\n\n\treturn 0;\n}\n\nstatic int twl6030_gpadc_suspend(struct device *pdev)\n{\n\tint ret;\n\n\tret = twl_i2c_write_u8(TWL6030_MODULE_ID1, TWL6030_GPADCR,\n\t\t\t\tTWL6030_REG_TOGGLE1);\n\tif (ret)\n\t\tdev_err(pdev, \"error resetting GPADC (%d)!\\n\", ret);\n\n\treturn 0;\n};\n\nstatic int twl6030_gpadc_resume(struct device *pdev)\n{\n\tint ret;\n\n\tret = twl_i2c_write_u8(TWL6030_MODULE_ID1, TWL6030_GPADCS,\n\t\t\t\tTWL6030_REG_TOGGLE1);\n\tif (ret)\n\t\tdev_err(pdev, \"error setting GPADC (%d)!\\n\", ret);\n\n\treturn 0;\n};\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(twl6030_gpadc_pm_ops, twl6030_gpadc_suspend,\n\t\t\t\ttwl6030_gpadc_resume);\n\nstatic struct platform_driver twl6030_gpadc_driver = {\n\t.probe\t\t= twl6030_gpadc_probe,\n\t.remove\t\t= twl6030_gpadc_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm\t= pm_sleep_ptr(&twl6030_gpadc_pm_ops),\n\t\t.of_match_table = of_twl6030_match_tbl,\n\t},\n};\n\nmodule_platform_driver(twl6030_gpadc_driver);\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_AUTHOR(\"Balaji T K <balajitk@ti.com>\");\nMODULE_AUTHOR(\"Graeme Gregory <gg@slimlogic.co.uk>\");\nMODULE_AUTHOR(\"Oleksandr Kozaruk <oleksandr.kozaruk@ti.com\");\nMODULE_DESCRIPTION(\"twl6030 ADC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}