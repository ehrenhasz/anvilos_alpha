{
  "module_name": "ltc2485.c",
  "hash_id": "c5325c65276ca5103be6a2f52bdb4f1406c9d806900481a2560dec1592b87614",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ltc2485.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n \n#define LTC2485_CONFIG_DEFAULT\t\t0\n\nstruct ltc2485_data {\n\tstruct i2c_client\t*client;\n\tktime_t\t\t\ttime_prev;\t \n};\n\nstatic void ltc2485_wait_conv(struct ltc2485_data *data)\n{\n\tconst unsigned int conv_time = 147;\t \n\tunsigned int time_elapsed;\n\n\t \n\ttime_elapsed = ktime_ms_delta(ktime_get(), data->time_prev);\n\n\tif (time_elapsed < conv_time)\n\t\tmsleep(conv_time - time_elapsed);\n}\n\nstatic int ltc2485_read(struct ltc2485_data *data, int *val)\n{\n\tstruct i2c_client *client = data->client;\n\t__be32 buf = 0;\n\tint ret;\n\n\tltc2485_wait_conv(data);\n\n\tret = i2c_master_recv(client, (char *)&buf, 4);\n\tif (ret < 0)  {\n\t\tdev_err(&client->dev, \"i2c_master_recv failed\\n\");\n\t\treturn ret;\n\t}\n\tdata->time_prev = ktime_get();\n\t*val = sign_extend32(be32_to_cpu(buf) >> 6, 24);\n\n\treturn ret;\n}\n\nstatic int ltc2485_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct ltc2485_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (mask == IIO_CHAN_INFO_RAW) {\n\t\tret = ltc2485_read(data, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\n\t} else if (mask == IIO_CHAN_INFO_SCALE) {\n\t\t*val = 5000;\t\t\t \n\t\t*val2 = 25;\t\t\t \n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\t} else {\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_chan_spec ltc2485_channel[] = {\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE)\n\t},\n};\n\nstatic const struct iio_info ltc2485_info = {\n\t.read_raw = ltc2485_read_raw,\n};\n\nstatic int ltc2485_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct iio_dev *indio_dev;\n\tstruct ltc2485_data *data;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_BYTE))\n\t\treturn -EOPNOTSUPP;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tindio_dev->name = id->name;\n\tindio_dev->info = &ltc2485_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = ltc2485_channel;\n\tindio_dev->num_channels = ARRAY_SIZE(ltc2485_channel);\n\n\tret = i2c_smbus_write_byte(data->client, LTC2485_CONFIG_DEFAULT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->time_prev = ktime_get();\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id ltc2485_id[] = {\n\t{ \"ltc2485\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ltc2485_id);\n\nstatic struct i2c_driver ltc2485_driver = {\n\t.driver = {\n\t\t.name = \"ltc2485\",\n\t},\n\t.probe = ltc2485_probe,\n\t.id_table = ltc2485_id,\n};\nmodule_i2c_driver(ltc2485_driver);\n\nMODULE_AUTHOR(\"Alison Schofield <amsfield22@gmail.com>\");\nMODULE_DESCRIPTION(\"Linear Technology LTC2485 ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}