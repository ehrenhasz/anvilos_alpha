{
  "module_name": "ad7476.c",
  "hash_id": "ae0b37be9af1cec42ced2d7ef50d79299659435d1c7ddd6f7bd4c8d49fd337ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7476.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\nstruct ad7476_state;\n\nstruct ad7476_chip_info {\n\tunsigned int\t\t\tint_vref_uv;\n\tstruct iio_chan_spec\t\tchannel[2];\n\t \n\tstruct iio_chan_spec\t\tconvst_channel[2];\n\tvoid (*reset)(struct ad7476_state *);\n\tbool\t\t\t\thas_vref;\n\tbool\t\t\t\thas_vdrive;\n};\n\nstruct ad7476_state {\n\tstruct spi_device\t\t*spi;\n\tconst struct ad7476_chip_info\t*chip_info;\n\tstruct regulator\t\t*ref_reg;\n\tstruct gpio_desc\t\t*convst_gpio;\n\tstruct spi_transfer\t\txfer;\n\tstruct spi_message\t\tmsg;\n\t \n\tunsigned char data[ALIGN(2, sizeof(s64)) + sizeof(s64)] __aligned(IIO_DMA_MINALIGN);\n};\n\nenum ad7476_supported_device_ids {\n\tID_AD7091,\n\tID_AD7091R,\n\tID_AD7273,\n\tID_AD7274,\n\tID_AD7276,\n\tID_AD7277,\n\tID_AD7278,\n\tID_AD7466,\n\tID_AD7467,\n\tID_AD7468,\n\tID_AD7475,\n\tID_AD7495,\n\tID_AD7940,\n\tID_ADC081S,\n\tID_ADC101S,\n\tID_ADC121S,\n\tID_ADS7866,\n\tID_ADS7867,\n\tID_ADS7868,\n\tID_LTC2314_14,\n};\n\nstatic void ad7091_convst(struct ad7476_state *st)\n{\n\tif (!st->convst_gpio)\n\t\treturn;\n\n\tgpiod_set_value(st->convst_gpio, 0);\n\tudelay(1);  \n\tgpiod_set_value(st->convst_gpio, 1);\n\tudelay(1);  \n}\n\nstatic irqreturn_t ad7476_trigger_handler(int irq, void  *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ad7476_state *st = iio_priv(indio_dev);\n\tint b_sent;\n\n\tad7091_convst(st);\n\n\tb_sent = spi_sync(st->spi, &st->msg);\n\tif (b_sent < 0)\n\t\tgoto done;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, st->data,\n\t\tiio_get_time_ns(indio_dev));\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ad7091_reset(struct ad7476_state *st)\n{\n\t \n\tspi_read(st->spi, st->data, 1);\n}\n\nstatic int ad7476_scan_direct(struct ad7476_state *st)\n{\n\tint ret;\n\n\tad7091_convst(st);\n\n\tret = spi_sync(st->spi, &st->msg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn be16_to_cpup((__be16 *)st->data);\n}\n\nstatic int ad7476_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tint ret;\n\tstruct ad7476_state *st = iio_priv(indio_dev);\n\tint scale_uv;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ad7476_scan_direct(st);\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = (ret >> st->chip_info->channel[0].scan_type.shift) &\n\t\t\tGENMASK(st->chip_info->channel[0].scan_type.realbits - 1, 0);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (st->ref_reg) {\n\t\t\tscale_uv = regulator_get_voltage(st->ref_reg);\n\t\t\tif (scale_uv < 0)\n\t\t\t\treturn scale_uv;\n\t\t} else {\n\t\t\tscale_uv = st->chip_info->int_vref_uv;\n\t\t}\n\t\t*val = scale_uv / 1000;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\treturn -EINVAL;\n}\n\n#define _AD7476_CHAN(bits, _shift, _info_mask_sep)\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.info_mask_separate = _info_mask_sep,\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = (bits),\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.shift = (_shift),\t\t\t\t\\\n\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\n#define ADC081S_CHAN(bits) _AD7476_CHAN((bits), 12 - (bits), \\\n\t\tBIT(IIO_CHAN_INFO_RAW))\n#define AD7476_CHAN(bits) _AD7476_CHAN((bits), 13 - (bits), \\\n\t\tBIT(IIO_CHAN_INFO_RAW))\n#define AD7940_CHAN(bits) _AD7476_CHAN((bits), 15 - (bits), \\\n\t\tBIT(IIO_CHAN_INFO_RAW))\n#define AD7091R_CHAN(bits) _AD7476_CHAN((bits), 16 - (bits), 0)\n#define AD7091R_CONVST_CHAN(bits) _AD7476_CHAN((bits), 16 - (bits), \\\n\t\tBIT(IIO_CHAN_INFO_RAW))\n#define ADS786X_CHAN(bits) _AD7476_CHAN((bits), 12 - (bits), \\\n\t\tBIT(IIO_CHAN_INFO_RAW))\n\nstatic const struct ad7476_chip_info ad7476_chip_info_tbl[] = {\n\t[ID_AD7091] = {\n\t\t.channel[0] = AD7091R_CHAN(12),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t\t.convst_channel[0] = AD7091R_CONVST_CHAN(12),\n\t\t.convst_channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t\t.reset = ad7091_reset,\n\t},\n\t[ID_AD7091R] = {\n\t\t.channel[0] = AD7091R_CHAN(12),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t\t.convst_channel[0] = AD7091R_CONVST_CHAN(12),\n\t\t.convst_channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t\t.int_vref_uv = 2500000,\n\t\t.has_vref = true,\n\t\t.reset = ad7091_reset,\n\t},\n\t[ID_AD7273] = {\n\t\t.channel[0] = AD7940_CHAN(10),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t\t.has_vref = true,\n\t},\n\t[ID_AD7274] = {\n\t\t.channel[0] = AD7940_CHAN(12),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t\t.has_vref = true,\n\t},\n\t[ID_AD7276] = {\n\t\t.channel[0] = AD7940_CHAN(12),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t},\n\t[ID_AD7277] = {\n\t\t.channel[0] = AD7940_CHAN(10),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t},\n\t[ID_AD7278] = {\n\t\t.channel[0] = AD7940_CHAN(8),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t},\n\t[ID_AD7466] = {\n\t\t.channel[0] = AD7476_CHAN(12),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t},\n\t[ID_AD7467] = {\n\t\t.channel[0] = AD7476_CHAN(10),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t},\n\t[ID_AD7468] = {\n\t\t.channel[0] = AD7476_CHAN(8),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t},\n\t[ID_AD7475] = {\n\t\t.channel[0] = AD7476_CHAN(12),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t\t.has_vref = true,\n\t\t.has_vdrive = true,\n\t},\n\t[ID_AD7495] = {\n\t\t.channel[0] = AD7476_CHAN(12),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t\t.int_vref_uv = 2500000,\n\t\t.has_vdrive = true,\n\t},\n\t[ID_AD7940] = {\n\t\t.channel[0] = AD7940_CHAN(14),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t},\n\t[ID_ADC081S] = {\n\t\t.channel[0] = ADC081S_CHAN(8),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t},\n\t[ID_ADC101S] = {\n\t\t.channel[0] = ADC081S_CHAN(10),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t},\n\t[ID_ADC121S] = {\n\t\t.channel[0] = ADC081S_CHAN(12),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t},\n\t[ID_ADS7866] = {\n\t\t.channel[0] = ADS786X_CHAN(12),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t},\n\t[ID_ADS7867] = {\n\t\t.channel[0] = ADS786X_CHAN(10),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t},\n\t[ID_ADS7868] = {\n\t\t.channel[0] = ADS786X_CHAN(8),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t},\n\t[ID_LTC2314_14] = {\n\t\t.channel[0] = AD7940_CHAN(14),\n\t\t.channel[1] = IIO_CHAN_SOFT_TIMESTAMP(1),\n\t\t.has_vref = true,\n\t},\n};\n\nstatic const struct iio_info ad7476_info = {\n\t.read_raw = &ad7476_read_raw,\n};\n\nstatic void ad7476_reg_disable(void *data)\n{\n\tstruct regulator *reg = data;\n\n\tregulator_disable(reg);\n}\n\nstatic int ad7476_probe(struct spi_device *spi)\n{\n\tstruct ad7476_state *st;\n\tstruct iio_dev *indio_dev;\n\tstruct regulator *reg;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tst->chip_info =\n\t\t&ad7476_chip_info_tbl[spi_get_device_id(spi)->driver_data];\n\n\treg = devm_regulator_get(&spi->dev, \"vcc\");\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tret = regulator_enable(reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, ad7476_reg_disable, reg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!st->chip_info->int_vref_uv)\n\t\tst->ref_reg = reg;\n\n\tif (st->chip_info->has_vref) {\n\n\t\t \n\t\tif (st->chip_info->int_vref_uv) {\n\t\t\treg = devm_regulator_get_optional(&spi->dev, \"vref\");\n\t\t\tif (IS_ERR(reg) && (PTR_ERR(reg) != -ENODEV))\n\t\t\t\treturn PTR_ERR(reg);\n\t\t} else {\n\t\t\treg = devm_regulator_get(&spi->dev, \"vref\");\n\t\t\tif (IS_ERR(reg))\n\t\t\t\treturn PTR_ERR(reg);\n\t\t}\n\n\t\tif (!IS_ERR(reg)) {\n\t\t\tret = regulator_enable(reg);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = devm_add_action_or_reset(&spi->dev,\n\t\t\t\t\t\t       ad7476_reg_disable,\n\t\t\t\t\t\t       reg);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tst->ref_reg = reg;\n\t\t} else {\n\t\t\t \n\t\t\tst->ref_reg = NULL;\n\t\t}\n\t}\n\n\tif (st->chip_info->has_vdrive) {\n\t\tret = devm_regulator_get_enable(&spi->dev, \"vdrive\");\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tst->convst_gpio = devm_gpiod_get_optional(&spi->dev,\n\t\t\t\t\t\t  \"adi,conversion-start\",\n\t\t\t\t\t\t  GPIOD_OUT_LOW);\n\tif (IS_ERR(st->convst_gpio))\n\t\treturn PTR_ERR(st->convst_gpio);\n\n\tst->spi = spi;\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = st->chip_info->channel;\n\tindio_dev->num_channels = 2;\n\tindio_dev->info = &ad7476_info;\n\n\tif (st->convst_gpio)\n\t\tindio_dev->channels = st->chip_info->convst_channel;\n\t \n\n\tst->xfer.rx_buf = &st->data;\n\tst->xfer.len = st->chip_info->channel[0].scan_type.storagebits / 8;\n\n\tspi_message_init(&st->msg);\n\tspi_message_add_tail(&st->xfer, &st->msg);\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev, NULL,\n\t\t\t\t\t      &ad7476_trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->chip_info->reset)\n\t\tst->chip_info->reset(st);\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad7476_id[] = {\n\t{\"ad7091\", ID_AD7091},\n\t{\"ad7091r\", ID_AD7091R},\n\t{\"ad7273\", ID_AD7273},\n\t{\"ad7274\", ID_AD7274},\n\t{\"ad7276\", ID_AD7276},\n\t{\"ad7277\", ID_AD7277},\n\t{\"ad7278\", ID_AD7278},\n\t{\"ad7466\", ID_AD7466},\n\t{\"ad7467\", ID_AD7467},\n\t{\"ad7468\", ID_AD7468},\n\t{\"ad7475\", ID_AD7475},\n\t{\"ad7476\", ID_AD7466},\n\t{\"ad7476a\", ID_AD7466},\n\t{\"ad7477\", ID_AD7467},\n\t{\"ad7477a\", ID_AD7467},\n\t{\"ad7478\", ID_AD7468},\n\t{\"ad7478a\", ID_AD7468},\n\t{\"ad7495\", ID_AD7495},\n\t{\"ad7910\", ID_AD7467},\n\t{\"ad7920\", ID_AD7466},\n\t{\"ad7940\", ID_AD7940},\n\t{\"adc081s\", ID_ADC081S},\n\t{\"adc101s\", ID_ADC101S},\n\t{\"adc121s\", ID_ADC121S},\n\t{\"ads7866\", ID_ADS7866},\n\t{\"ads7867\", ID_ADS7867},\n\t{\"ads7868\", ID_ADS7868},\n\t{\"ltc2314-14\", ID_LTC2314_14},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad7476_id);\n\nstatic struct spi_driver ad7476_driver = {\n\t.driver = {\n\t\t.name\t= \"ad7476\",\n\t},\n\t.probe\t\t= ad7476_probe,\n\t.id_table\t= ad7476_id,\n};\nmodule_spi_driver(ad7476_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7476 and similar 1-channel ADCs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}