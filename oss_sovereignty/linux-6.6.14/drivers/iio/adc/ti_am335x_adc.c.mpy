{
  "module_name": "ti_am335x_adc.c",
  "hash_id": "b21bd1491061a8de296c92b636e89d361e45c281ae2c93cb6281e63fc98abf0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti_am335x_adc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/iio/iio.h>\n#include <linux/of.h>\n#include <linux/iio/machine.h>\n#include <linux/iio/driver.h>\n#include <linux/iopoll.h>\n\n#include <linux/mfd/ti_am335x_tscadc.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/kfifo_buf.h>\n\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n\n#define DMA_BUFFER_SIZE\t\tSZ_2K\n\nstruct tiadc_dma {\n\tstruct dma_slave_config\tconf;\n\tstruct dma_chan\t\t*chan;\n\tdma_addr_t\t\taddr;\n\tdma_cookie_t\t\tcookie;\n\tu8\t\t\t*buf;\n\tint\t\t\tcurrent_period;\n\tint\t\t\tperiod_size;\n\tu8\t\t\tfifo_thresh;\n};\n\nstruct tiadc_device {\n\tstruct ti_tscadc_dev *mfd_tscadc;\n\tstruct tiadc_dma dma;\n\tstruct mutex fifo1_lock;  \n\tint channels;\n\tint total_ch_enabled;\n\tu8 channel_line[8];\n\tu8 channel_step[8];\n\tint buffer_en_ch_steps;\n\tu16 data[8];\n\tu32 open_delay[8], sample_delay[8], step_avg[8];\n};\n\nstatic unsigned int tiadc_readl(struct tiadc_device *adc, unsigned int reg)\n{\n\treturn readl(adc->mfd_tscadc->tscadc_base + reg);\n}\n\nstatic void tiadc_writel(struct tiadc_device *adc, unsigned int reg,\n\t\t\t unsigned int val)\n{\n\twritel(val, adc->mfd_tscadc->tscadc_base + reg);\n}\n\nstatic u32 get_adc_step_mask(struct tiadc_device *adc_dev)\n{\n\tu32 step_en;\n\n\tstep_en = ((1 << adc_dev->channels) - 1);\n\tstep_en <<= TOTAL_STEPS - adc_dev->channels + 1;\n\treturn step_en;\n}\n\nstatic u32 get_adc_chan_step_mask(struct tiadc_device *adc_dev,\n\t\t\t\t  struct iio_chan_spec const *chan)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(adc_dev->channel_step); i++) {\n\t\tif (chan->channel == adc_dev->channel_line[i]) {\n\t\t\tu32 step;\n\n\t\t\tstep = adc_dev->channel_step[i];\n\t\t\t \n\t\t\treturn 1 << (step + 1);\n\t\t}\n\t}\n\tWARN_ON(1);\n\treturn 0;\n}\n\nstatic u32 get_adc_step_bit(struct tiadc_device *adc_dev, int chan)\n{\n\treturn 1 << adc_dev->channel_step[chan];\n}\n\nstatic int tiadc_wait_idle(struct tiadc_device *adc_dev)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(adc_dev->mfd_tscadc->tscadc_base + REG_ADCFSM,\n\t\t\t\t  val, !(val & SEQ_STATUS), 10,\n\t\t\t\t  IDLE_TIMEOUT_MS * 1000 * adc_dev->channels);\n}\n\nstatic void tiadc_step_config(struct iio_dev *indio_dev)\n{\n\tstruct tiadc_device *adc_dev = iio_priv(indio_dev);\n\tunsigned int stepconfig;\n\tint i, steps = 0;\n\n\t \n\tfor (i = 0; i < adc_dev->channels; i++) {\n\t\tint chan;\n\n\t\tchan = adc_dev->channel_line[i];\n\n\t\tif (adc_dev->step_avg[i])\n\t\t\tstepconfig = STEPCONFIG_AVG(ffs(adc_dev->step_avg[i]) - 1) |\n\t\t\t\t     STEPCONFIG_FIFO1;\n\t\telse\n\t\t\tstepconfig = STEPCONFIG_FIFO1;\n\n\t\tif (iio_buffer_enabled(indio_dev))\n\t\t\tstepconfig |= STEPCONFIG_MODE_SWCNT;\n\n\t\ttiadc_writel(adc_dev, REG_STEPCONFIG(steps),\n\t\t\t     stepconfig | STEPCONFIG_INP(chan) |\n\t\t\t     STEPCONFIG_INM_ADCREFM | STEPCONFIG_RFP_VREFP |\n\t\t\t     STEPCONFIG_RFM_VREFN);\n\n\t\ttiadc_writel(adc_dev, REG_STEPDELAY(steps),\n\t\t\t     STEPDELAY_OPEN(adc_dev->open_delay[i]) |\n\t\t\t     STEPDELAY_SAMPLE(adc_dev->sample_delay[i]));\n\n\t\tadc_dev->channel_step[i] = steps;\n\t\tsteps++;\n\t}\n}\n\nstatic irqreturn_t tiadc_irq_h(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct tiadc_device *adc_dev = iio_priv(indio_dev);\n\tunsigned int status, config, adc_fsm;\n\tunsigned short count = 0;\n\n\tstatus = tiadc_readl(adc_dev, REG_IRQSTATUS);\n\n\t \n\tif (status & IRQENB_FIFO1OVRRUN) {\n\t\t \n\t\tconfig = tiadc_readl(adc_dev, REG_CTRL);\n\t\tconfig &= ~(CNTRLREG_SSENB);\n\t\ttiadc_writel(adc_dev, REG_CTRL, config);\n\t\ttiadc_writel(adc_dev, REG_IRQSTATUS,\n\t\t\t     IRQENB_FIFO1OVRRUN | IRQENB_FIFO1UNDRFLW |\n\t\t\t     IRQENB_FIFO1THRES);\n\n\t\t \n\t\tdo {\n\t\t\tadc_fsm = tiadc_readl(adc_dev, REG_ADCFSM);\n\t\t} while (adc_fsm != 0x10 && count++ < 100);\n\n\t\ttiadc_writel(adc_dev, REG_CTRL, (config | CNTRLREG_SSENB));\n\t\treturn IRQ_HANDLED;\n\t} else if (status & IRQENB_FIFO1THRES) {\n\t\t \n\t\ttiadc_writel(adc_dev, REG_IRQCLR, IRQENB_FIFO1THRES);\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t tiadc_worker_h(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct tiadc_device *adc_dev = iio_priv(indio_dev);\n\tint i, k, fifo1count, read;\n\tu16 *data = adc_dev->data;\n\n\tfifo1count = tiadc_readl(adc_dev, REG_FIFO1CNT);\n\tfor (k = 0; k < fifo1count; k = k + i) {\n\t\tfor (i = 0; i < indio_dev->scan_bytes / 2; i++) {\n\t\t\tread = tiadc_readl(adc_dev, REG_FIFO1);\n\t\t\tdata[i] = read & FIFOREAD_DATA_MASK;\n\t\t}\n\t\tiio_push_to_buffers(indio_dev, (u8 *)data);\n\t}\n\n\ttiadc_writel(adc_dev, REG_IRQSTATUS, IRQENB_FIFO1THRES);\n\ttiadc_writel(adc_dev, REG_IRQENABLE, IRQENB_FIFO1THRES);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void tiadc_dma_rx_complete(void *param)\n{\n\tstruct iio_dev *indio_dev = param;\n\tstruct tiadc_device *adc_dev = iio_priv(indio_dev);\n\tstruct tiadc_dma *dma = &adc_dev->dma;\n\tu8 *data;\n\tint i;\n\n\tdata = dma->buf + dma->current_period * dma->period_size;\n\tdma->current_period = 1 - dma->current_period;  \n\n\tfor (i = 0; i < dma->period_size; i += indio_dev->scan_bytes) {\n\t\tiio_push_to_buffers(indio_dev, data);\n\t\tdata += indio_dev->scan_bytes;\n\t}\n}\n\nstatic int tiadc_start_dma(struct iio_dev *indio_dev)\n{\n\tstruct tiadc_device *adc_dev = iio_priv(indio_dev);\n\tstruct tiadc_dma *dma = &adc_dev->dma;\n\tstruct dma_async_tx_descriptor *desc;\n\n\tdma->current_period = 0;  \n\n\t \n\tdma->fifo_thresh = rounddown(FIFO1_THRESHOLD + 1,\n\t\t\t\t     adc_dev->total_ch_enabled) - 1;\n\n\t \n\tdma->period_size = rounddown(DMA_BUFFER_SIZE / 2,\n\t\t\t\t     (dma->fifo_thresh + 1) * sizeof(u16));\n\n\tdma->conf.src_maxburst = dma->fifo_thresh + 1;\n\tdmaengine_slave_config(dma->chan, &dma->conf);\n\n\tdesc = dmaengine_prep_dma_cyclic(dma->chan, dma->addr,\n\t\t\t\t\t dma->period_size * 2,\n\t\t\t\t\t dma->period_size, DMA_DEV_TO_MEM,\n\t\t\t\t\t DMA_PREP_INTERRUPT);\n\tif (!desc)\n\t\treturn -EBUSY;\n\n\tdesc->callback = tiadc_dma_rx_complete;\n\tdesc->callback_param = indio_dev;\n\n\tdma->cookie = dmaengine_submit(desc);\n\n\tdma_async_issue_pending(dma->chan);\n\n\ttiadc_writel(adc_dev, REG_FIFO1THR, dma->fifo_thresh);\n\ttiadc_writel(adc_dev, REG_DMA1REQ, dma->fifo_thresh);\n\ttiadc_writel(adc_dev, REG_DMAENABLE_SET, DMA_FIFO1);\n\n\treturn 0;\n}\n\nstatic int tiadc_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct tiadc_device *adc_dev = iio_priv(indio_dev);\n\tint i, fifo1count;\n\tint ret;\n\n\tret = tiadc_wait_idle(adc_dev);\n\tif (ret)\n\t\treturn ret;\n\n\ttiadc_writel(adc_dev, REG_IRQCLR,\n\t\t     IRQENB_FIFO1THRES | IRQENB_FIFO1OVRRUN |\n\t\t     IRQENB_FIFO1UNDRFLW);\n\n\t \n\tfifo1count = tiadc_readl(adc_dev, REG_FIFO1CNT);\n\tfor (i = 0; i < fifo1count; i++)\n\t\ttiadc_readl(adc_dev, REG_FIFO1);\n\n\treturn 0;\n}\n\nstatic int tiadc_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct tiadc_device *adc_dev = iio_priv(indio_dev);\n\tstruct tiadc_dma *dma = &adc_dev->dma;\n\tunsigned int irq_enable;\n\tunsigned int enb = 0;\n\tu8 bit;\n\n\ttiadc_step_config(indio_dev);\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask, adc_dev->channels) {\n\t\tenb |= (get_adc_step_bit(adc_dev, bit) << 1);\n\t\tadc_dev->total_ch_enabled++;\n\t}\n\tadc_dev->buffer_en_ch_steps = enb;\n\n\tif (dma->chan)\n\t\ttiadc_start_dma(indio_dev);\n\n\tam335x_tsc_se_set_cache(adc_dev->mfd_tscadc, enb);\n\n\ttiadc_writel(adc_dev, REG_IRQSTATUS,\n\t\t     IRQENB_FIFO1THRES | IRQENB_FIFO1OVRRUN |\n\t\t     IRQENB_FIFO1UNDRFLW);\n\n\tirq_enable = IRQENB_FIFO1OVRRUN;\n\tif (!dma->chan)\n\t\tirq_enable |= IRQENB_FIFO1THRES;\n\ttiadc_writel(adc_dev,  REG_IRQENABLE, irq_enable);\n\n\treturn 0;\n}\n\nstatic int tiadc_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct tiadc_device *adc_dev = iio_priv(indio_dev);\n\tstruct tiadc_dma *dma = &adc_dev->dma;\n\tint fifo1count, i;\n\n\ttiadc_writel(adc_dev, REG_IRQCLR,\n\t\t     IRQENB_FIFO1THRES | IRQENB_FIFO1OVRRUN |\n\t\t     IRQENB_FIFO1UNDRFLW);\n\tam335x_tsc_se_clr(adc_dev->mfd_tscadc, adc_dev->buffer_en_ch_steps);\n\tadc_dev->buffer_en_ch_steps = 0;\n\tadc_dev->total_ch_enabled = 0;\n\tif (dma->chan) {\n\t\ttiadc_writel(adc_dev, REG_DMAENABLE_CLEAR, 0x2);\n\t\tdmaengine_terminate_async(dma->chan);\n\t}\n\n\t \n\tfifo1count = tiadc_readl(adc_dev, REG_FIFO1CNT);\n\tfor (i = 0; i < fifo1count; i++)\n\t\ttiadc_readl(adc_dev, REG_FIFO1);\n\n\treturn 0;\n}\n\nstatic int tiadc_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\ttiadc_step_config(indio_dev);\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops tiadc_buffer_setup_ops = {\n\t.preenable = &tiadc_buffer_preenable,\n\t.postenable = &tiadc_buffer_postenable,\n\t.predisable = &tiadc_buffer_predisable,\n\t.postdisable = &tiadc_buffer_postdisable,\n};\n\nstatic int tiadc_iio_buffered_hardware_setup(struct device *dev,\n\t\t\t\t\t     struct iio_dev *indio_dev,\n\t\t\t\t\t     irqreturn_t (*pollfunc_bh)(int irq, void *p),\n\t\t\t\t\t     irqreturn_t (*pollfunc_th)(int irq, void *p),\n\t\t\t\t\t     int irq, unsigned long flags,\n\t\t\t\t\t     const struct iio_buffer_setup_ops *setup_ops)\n{\n\tint ret;\n\n\tret = devm_iio_kfifo_buffer_setup(dev, indio_dev, setup_ops);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_request_threaded_irq(dev, irq, pollfunc_th, pollfunc_bh,\n\t\t\t\t\t flags, indio_dev->name, indio_dev);\n}\n\nstatic const char * const chan_name_ain[] = {\n\t\"AIN0\",\n\t\"AIN1\",\n\t\"AIN2\",\n\t\"AIN3\",\n\t\"AIN4\",\n\t\"AIN5\",\n\t\"AIN6\",\n\t\"AIN7\",\n};\n\nstatic int tiadc_channel_init(struct device *dev, struct iio_dev *indio_dev,\n\t\t\t      int channels)\n{\n\tstruct tiadc_device *adc_dev = iio_priv(indio_dev);\n\tstruct iio_chan_spec *chan_array;\n\tstruct iio_chan_spec *chan;\n\tint i;\n\n\tindio_dev->num_channels = channels;\n\tchan_array = devm_kcalloc(dev, channels, sizeof(*chan_array),\n\t\t\t\t  GFP_KERNEL);\n\tif (!chan_array)\n\t\treturn -ENOMEM;\n\n\tchan = chan_array;\n\tfor (i = 0; i < channels; i++, chan++) {\n\t\tchan->type = IIO_VOLTAGE;\n\t\tchan->indexed = 1;\n\t\tchan->channel = adc_dev->channel_line[i];\n\t\tchan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\n\t\tchan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);\n\t\tchan->datasheet_name = chan_name_ain[chan->channel];\n\t\tchan->scan_index = i;\n\t\tchan->scan_type.sign = 'u';\n\t\tchan->scan_type.realbits = 12;\n\t\tchan->scan_type.storagebits = 16;\n\t}\n\n\tindio_dev->channels = chan_array;\n\n\treturn 0;\n}\n\nstatic int tiadc_read_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan, int *val, int *val2,\n\t\t\t  long mask)\n{\n\tstruct tiadc_device *adc_dev = iio_priv(indio_dev);\n\tint i, map_val;\n\tunsigned int fifo1count, read, stepid;\n\tbool found = false;\n\tu32 step_en;\n\tunsigned long timeout;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\t*val = 1800;\n\t\t\t*val2 = chan->scan_type.realbits;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (iio_buffer_enabled(indio_dev))\n\t\treturn -EBUSY;\n\n\tstep_en = get_adc_chan_step_mask(adc_dev, chan);\n\tif (!step_en)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&adc_dev->fifo1_lock);\n\n\tret = tiadc_wait_idle(adc_dev);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tfifo1count = tiadc_readl(adc_dev, REG_FIFO1CNT);\n\twhile (fifo1count--)\n\t\ttiadc_readl(adc_dev, REG_FIFO1);\n\n\tam335x_tsc_se_set_once(adc_dev->mfd_tscadc, step_en);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(IDLE_TIMEOUT_MS * adc_dev->channels);\n\twhile (1) {\n\t\tfifo1count = tiadc_readl(adc_dev, REG_FIFO1CNT);\n\t\tif (fifo1count)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tam335x_tsc_se_adc_done(adc_dev->mfd_tscadc);\n\t\t\tret = -EAGAIN;\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\n\tmap_val = adc_dev->channel_step[chan->scan_index];\n\n\t \n\tfor (i = 0; i < fifo1count; i++) {\n\t\tread = tiadc_readl(adc_dev, REG_FIFO1);\n\t\tstepid = read & FIFOREAD_CHNLID_MASK;\n\t\tstepid = stepid >> 0x10;\n\n\t\tif (stepid == map_val) {\n\t\t\tread = read & FIFOREAD_DATA_MASK;\n\t\t\tfound = true;\n\t\t\t*val = (u16)read;\n\t\t}\n\t}\n\n\tam335x_tsc_se_adc_done(adc_dev->mfd_tscadc);\n\n\tif (!found)\n\t\tret = -EBUSY;\n\nerr_unlock:\n\tmutex_unlock(&adc_dev->fifo1_lock);\n\treturn ret ? ret : IIO_VAL_INT;\n}\n\nstatic const struct iio_info tiadc_info = {\n\t.read_raw = &tiadc_read_raw,\n};\n\nstatic int tiadc_request_dma(struct platform_device *pdev,\n\t\t\t     struct tiadc_device *adc_dev)\n{\n\tstruct tiadc_dma\t*dma = &adc_dev->dma;\n\tdma_cap_mask_t\t\tmask;\n\n\t \n\tdma->conf.direction = DMA_DEV_TO_MEM;\n\tdma->conf.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\tdma->conf.src_addr = adc_dev->mfd_tscadc->tscadc_phys_base + REG_FIFO1;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_CYCLIC, mask);\n\n\t \n\tdma->chan = dma_request_chan(adc_dev->mfd_tscadc->dev, \"fifo1\");\n\tif (IS_ERR(dma->chan)) {\n\t\tint ret = PTR_ERR(dma->chan);\n\n\t\tdma->chan = NULL;\n\t\treturn ret;\n\t}\n\n\t \n\tdma->buf = dma_alloc_coherent(dma->chan->device->dev, DMA_BUFFER_SIZE,\n\t\t\t\t      &dma->addr, GFP_KERNEL);\n\tif (!dma->buf)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdma_release_channel(dma->chan);\n\treturn -ENOMEM;\n}\n\nstatic int tiadc_parse_dt(struct platform_device *pdev,\n\t\t\t  struct tiadc_device *adc_dev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct property *prop;\n\tconst __be32 *cur;\n\tint channels = 0;\n\tu32 val;\n\tint i;\n\n\tof_property_for_each_u32(node, \"ti,adc-channels\", prop, cur, val) {\n\t\tadc_dev->channel_line[channels] = val;\n\n\t\t \n\t\tadc_dev->open_delay[channels] = STEPCONFIG_OPENDLY;\n\t\tadc_dev->sample_delay[channels] = STEPCONFIG_SAMPLEDLY;\n\t\tadc_dev->step_avg[channels] = 16;\n\n\t\tchannels++;\n\t}\n\n\tadc_dev->channels = channels;\n\n\tof_property_read_u32_array(node, \"ti,chan-step-avg\",\n\t\t\t\t   adc_dev->step_avg, channels);\n\tof_property_read_u32_array(node, \"ti,chan-step-opendelay\",\n\t\t\t\t   adc_dev->open_delay, channels);\n\tof_property_read_u32_array(node, \"ti,chan-step-sampledelay\",\n\t\t\t\t   adc_dev->sample_delay, channels);\n\n\tfor (i = 0; i < adc_dev->channels; i++) {\n\t\tint chan;\n\n\t\tchan = adc_dev->channel_line[i];\n\n\t\tif (adc_dev->step_avg[i] > STEPCONFIG_AVG_16) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"chan %d: wrong step avg, truncated to %ld\\n\",\n\t\t\t\t chan, STEPCONFIG_AVG_16);\n\t\t\tadc_dev->step_avg[i] = STEPCONFIG_AVG_16;\n\t\t}\n\n\t\tif (adc_dev->open_delay[i] > STEPCONFIG_MAX_OPENDLY) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"chan %d: wrong open delay, truncated to 0x%lX\\n\",\n\t\t\t\t chan, STEPCONFIG_MAX_OPENDLY);\n\t\t\tadc_dev->open_delay[i] = STEPCONFIG_MAX_OPENDLY;\n\t\t}\n\n\t\tif (adc_dev->sample_delay[i] > STEPCONFIG_MAX_SAMPLE) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"chan %d: wrong sample delay, truncated to 0x%lX\\n\",\n\t\t\t\t chan, STEPCONFIG_MAX_SAMPLE);\n\t\t\tadc_dev->sample_delay[i] = STEPCONFIG_MAX_SAMPLE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tiadc_probe(struct platform_device *pdev)\n{\n\tstruct iio_dev\t\t*indio_dev;\n\tstruct tiadc_device\t*adc_dev;\n\tstruct device_node\t*node = pdev->dev.of_node;\n\tint\t\t\terr;\n\n\tif (!node) {\n\t\tdev_err(&pdev->dev, \"Could not find valid DT data.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*adc_dev));\n\tif (!indio_dev) {\n\t\tdev_err(&pdev->dev, \"failed to allocate iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tadc_dev = iio_priv(indio_dev);\n\n\tadc_dev->mfd_tscadc = ti_tscadc_dev_get(pdev);\n\ttiadc_parse_dt(pdev, adc_dev);\n\n\tindio_dev->name = dev_name(&pdev->dev);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &tiadc_info;\n\n\ttiadc_step_config(indio_dev);\n\ttiadc_writel(adc_dev, REG_FIFO1THR, FIFO1_THRESHOLD);\n\tmutex_init(&adc_dev->fifo1_lock);\n\n\terr = tiadc_channel_init(&pdev->dev, indio_dev, adc_dev->channels);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = tiadc_iio_buffered_hardware_setup(&pdev->dev, indio_dev,\n\t\t\t\t\t\t&tiadc_worker_h,\n\t\t\t\t\t\t&tiadc_irq_h,\n\t\t\t\t\t\tadc_dev->mfd_tscadc->irq,\n\t\t\t\t\t\tIRQF_SHARED,\n\t\t\t\t\t\t&tiadc_buffer_setup_ops);\n\tif (err)\n\t\treturn err;\n\n\terr = iio_device_register(indio_dev);\n\tif (err)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\terr = tiadc_request_dma(pdev, adc_dev);\n\tif (err && err != -ENODEV) {\n\t\tdev_err_probe(&pdev->dev, err, \"DMA request failed\\n\");\n\t\tgoto err_dma;\n\t}\n\n\treturn 0;\n\nerr_dma:\n\tiio_device_unregister(indio_dev);\n\n\treturn err;\n}\n\nstatic int tiadc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct tiadc_device *adc_dev = iio_priv(indio_dev);\n\tstruct tiadc_dma *dma = &adc_dev->dma;\n\tu32 step_en;\n\n\tif (dma->chan) {\n\t\tdma_free_coherent(dma->chan->device->dev, DMA_BUFFER_SIZE,\n\t\t\t\t  dma->buf, dma->addr);\n\t\tdma_release_channel(dma->chan);\n\t}\n\tiio_device_unregister(indio_dev);\n\n\tstep_en = get_adc_step_mask(adc_dev);\n\tam335x_tsc_se_clr(adc_dev->mfd_tscadc, step_en);\n\n\treturn 0;\n}\n\nstatic int tiadc_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct tiadc_device *adc_dev = iio_priv(indio_dev);\n\tunsigned int idle;\n\n\tidle = tiadc_readl(adc_dev, REG_CTRL);\n\tidle &= ~(CNTRLREG_SSENB);\n\ttiadc_writel(adc_dev, REG_CTRL, idle | CNTRLREG_POWERDOWN);\n\n\treturn 0;\n}\n\nstatic int tiadc_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct tiadc_device *adc_dev = iio_priv(indio_dev);\n\tunsigned int restore;\n\n\t \n\trestore = tiadc_readl(adc_dev, REG_CTRL);\n\trestore &= ~CNTRLREG_POWERDOWN;\n\ttiadc_writel(adc_dev, REG_CTRL, restore);\n\n\ttiadc_step_config(indio_dev);\n\tam335x_tsc_se_set_cache(adc_dev->mfd_tscadc,\n\t\t\t\tadc_dev->buffer_en_ch_steps);\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tiadc_pm_ops, tiadc_suspend, tiadc_resume);\n\nstatic const struct of_device_id ti_adc_dt_ids[] = {\n\t{ .compatible = \"ti,am3359-adc\", },\n\t{ .compatible = \"ti,am4372-adc\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ti_adc_dt_ids);\n\nstatic struct platform_driver tiadc_driver = {\n\t.driver = {\n\t\t.name   = \"TI-am335x-adc\",\n\t\t.pm\t= pm_sleep_ptr(&tiadc_pm_ops),\n\t\t.of_match_table = ti_adc_dt_ids,\n\t},\n\t.probe\t= tiadc_probe,\n\t.remove\t= tiadc_remove,\n};\nmodule_platform_driver(tiadc_driver);\n\nMODULE_DESCRIPTION(\"TI ADC controller driver\");\nMODULE_AUTHOR(\"Rachna Patil <rachna@ti.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}