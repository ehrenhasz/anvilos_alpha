{
  "module_name": "meson_saradc.c",
  "hash_id": "cc400c1a2521f13d302584d38a6205bd9e50868c0c6861ebd13f22d65c1b518f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/meson_saradc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/mfd/syscon.h>\n\n#define MESON_SAR_ADC_REG0\t\t\t\t\t0x00\n\t#define MESON_SAR_ADC_REG0_PANEL_DETECT\t\t\tBIT(31)\n\t#define MESON_SAR_ADC_REG0_BUSY_MASK\t\t\tGENMASK(30, 28)\n\t#define MESON_SAR_ADC_REG0_DELTA_BUSY\t\t\tBIT(30)\n\t#define MESON_SAR_ADC_REG0_AVG_BUSY\t\t\tBIT(29)\n\t#define MESON_SAR_ADC_REG0_SAMPLE_BUSY\t\t\tBIT(28)\n\t#define MESON_SAR_ADC_REG0_FIFO_FULL\t\t\tBIT(27)\n\t#define MESON_SAR_ADC_REG0_FIFO_EMPTY\t\t\tBIT(26)\n\t#define MESON_SAR_ADC_REG0_FIFO_COUNT_MASK\t\tGENMASK(25, 21)\n\t#define MESON_SAR_ADC_REG0_ADC_BIAS_CTRL_MASK\t\tGENMASK(20, 19)\n\t#define MESON_SAR_ADC_REG0_CURR_CHAN_ID_MASK\t\tGENMASK(18, 16)\n\t#define MESON_SAR_ADC_REG0_ADC_TEMP_SEN_SEL\t\tBIT(15)\n\t#define MESON_SAR_ADC_REG0_SAMPLING_STOP\t\tBIT(14)\n\t#define MESON_SAR_ADC_REG0_CHAN_DELTA_EN_MASK\t\tGENMASK(13, 12)\n\t#define MESON_SAR_ADC_REG0_DETECT_IRQ_POL\t\tBIT(10)\n\t#define MESON_SAR_ADC_REG0_DETECT_IRQ_EN\t\tBIT(9)\n\t#define MESON_SAR_ADC_REG0_FIFO_CNT_IRQ_MASK\t\tGENMASK(8, 4)\n\t#define MESON_SAR_ADC_REG0_FIFO_IRQ_EN\t\t\tBIT(3)\n\t#define MESON_SAR_ADC_REG0_SAMPLING_START\t\tBIT(2)\n\t#define MESON_SAR_ADC_REG0_CONTINUOUS_EN\t\tBIT(1)\n\t#define MESON_SAR_ADC_REG0_SAMPLE_ENGINE_ENABLE\t\tBIT(0)\n\n#define MESON_SAR_ADC_CHAN_LIST\t\t\t\t\t0x04\n\t#define MESON_SAR_ADC_CHAN_LIST_MAX_INDEX_MASK\t\tGENMASK(26, 24)\n\t#define MESON_SAR_ADC_CHAN_LIST_ENTRY_MASK(_chan)\t\\\n\t\t\t\t\t(GENMASK(2, 0) << ((_chan) * 3))\n\n#define MESON_SAR_ADC_AVG_CNTL\t\t\t\t\t0x08\n\t#define MESON_SAR_ADC_AVG_CNTL_AVG_MODE_SHIFT(_chan)\t\\\n\t\t\t\t\t(16 + ((_chan) * 2))\n\t#define MESON_SAR_ADC_AVG_CNTL_AVG_MODE_MASK(_chan)\t\\\n\t\t\t\t\t(GENMASK(17, 16) << ((_chan) * 2))\n\t#define MESON_SAR_ADC_AVG_CNTL_NUM_SAMPLES_SHIFT(_chan)\t\\\n\t\t\t\t\t(0 + ((_chan) * 2))\n\t#define MESON_SAR_ADC_AVG_CNTL_NUM_SAMPLES_MASK(_chan)\t\\\n\t\t\t\t\t(GENMASK(1, 0) << ((_chan) * 2))\n\n#define MESON_SAR_ADC_REG3\t\t\t\t\t0x0c\n\t#define MESON_SAR_ADC_REG3_CNTL_USE_SC_DLY\t\tBIT(31)\n\t#define MESON_SAR_ADC_REG3_CLK_EN\t\t\tBIT(30)\n\t#define MESON_SAR_ADC_REG3_BL30_INITIALIZED\t\tBIT(28)\n\t#define MESON_SAR_ADC_REG3_CTRL_CONT_RING_COUNTER_EN\tBIT(27)\n\t#define MESON_SAR_ADC_REG3_CTRL_SAMPLING_CLOCK_PHASE\tBIT(26)\n\t#define MESON_SAR_ADC_REG3_CTRL_CHAN7_MUX_SEL_MASK\tGENMASK(25, 23)\n\t#define MESON_SAR_ADC_REG3_DETECT_EN\t\t\tBIT(22)\n\t#define MESON_SAR_ADC_REG3_ADC_EN\t\t\tBIT(21)\n\t#define MESON_SAR_ADC_REG3_PANEL_DETECT_COUNT_MASK\tGENMASK(20, 18)\n\t#define MESON_SAR_ADC_REG3_PANEL_DETECT_FILTER_TB_MASK\tGENMASK(17, 16)\n\t#define MESON_SAR_ADC_REG3_ADC_CLK_DIV_SHIFT\t\t10\n\t#define MESON_SAR_ADC_REG3_ADC_CLK_DIV_WIDTH\t\t6\n\t#define MESON_SAR_ADC_REG3_BLOCK_DLY_SEL_MASK\t\tGENMASK(9, 8)\n\t#define MESON_SAR_ADC_REG3_BLOCK_DLY_MASK\t\tGENMASK(7, 0)\n\n#define MESON_SAR_ADC_DELAY\t\t\t\t\t0x10\n\t#define MESON_SAR_ADC_DELAY_INPUT_DLY_SEL_MASK\t\tGENMASK(25, 24)\n\t#define MESON_SAR_ADC_DELAY_BL30_BUSY\t\t\tBIT(15)\n\t#define MESON_SAR_ADC_DELAY_KERNEL_BUSY\t\t\tBIT(14)\n\t#define MESON_SAR_ADC_DELAY_INPUT_DLY_CNT_MASK\t\tGENMASK(23, 16)\n\t#define MESON_SAR_ADC_DELAY_SAMPLE_DLY_SEL_MASK\t\tGENMASK(9, 8)\n\t#define MESON_SAR_ADC_DELAY_SAMPLE_DLY_CNT_MASK\t\tGENMASK(7, 0)\n\n#define MESON_SAR_ADC_LAST_RD\t\t\t\t\t0x14\n\t#define MESON_SAR_ADC_LAST_RD_LAST_CHANNEL1_MASK\tGENMASK(23, 16)\n\t#define MESON_SAR_ADC_LAST_RD_LAST_CHANNEL0_MASK\tGENMASK(9, 0)\n\n#define MESON_SAR_ADC_FIFO_RD\t\t\t\t\t0x18\n\t#define MESON_SAR_ADC_FIFO_RD_CHAN_ID_MASK\t\tGENMASK(14, 12)\n\t#define MESON_SAR_ADC_FIFO_RD_SAMPLE_VALUE_MASK\t\tGENMASK(11, 0)\n\n#define MESON_SAR_ADC_AUX_SW\t\t\t\t\t0x1c\n\t#define MESON_SAR_ADC_AUX_SW_MUX_SEL_CHAN_SHIFT(_chan)\t\\\n\t\t\t\t\t(8 + (((_chan) - 2) * 3))\n\t#define MESON_SAR_ADC_AUX_SW_VREF_P_MUX\t\t\tBIT(6)\n\t#define MESON_SAR_ADC_AUX_SW_VREF_N_MUX\t\t\tBIT(5)\n\t#define MESON_SAR_ADC_AUX_SW_MODE_SEL\t\t\tBIT(4)\n\t#define MESON_SAR_ADC_AUX_SW_YP_DRIVE_SW\t\tBIT(3)\n\t#define MESON_SAR_ADC_AUX_SW_XP_DRIVE_SW\t\tBIT(2)\n\t#define MESON_SAR_ADC_AUX_SW_YM_DRIVE_SW\t\tBIT(1)\n\t#define MESON_SAR_ADC_AUX_SW_XM_DRIVE_SW\t\tBIT(0)\n\n#define MESON_SAR_ADC_CHAN_10_SW\t\t\t\t0x20\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN1_MUX_SEL_MASK\tGENMASK(25, 23)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN1_VREF_P_MUX\tBIT(22)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN1_VREF_N_MUX\tBIT(21)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN1_MODE_SEL\t\tBIT(20)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN1_YP_DRIVE_SW\tBIT(19)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN1_XP_DRIVE_SW\tBIT(18)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN1_YM_DRIVE_SW\tBIT(17)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN1_XM_DRIVE_SW\tBIT(16)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN0_MUX_SEL_MASK\tGENMASK(9, 7)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN0_VREF_P_MUX\tBIT(6)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN0_VREF_N_MUX\tBIT(5)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN0_MODE_SEL\t\tBIT(4)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN0_YP_DRIVE_SW\tBIT(3)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN0_XP_DRIVE_SW\tBIT(2)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN0_YM_DRIVE_SW\tBIT(1)\n\t#define MESON_SAR_ADC_CHAN_10_SW_CHAN0_XM_DRIVE_SW\tBIT(0)\n\n#define MESON_SAR_ADC_DETECT_IDLE_SW\t\t\t\t0x24\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_DETECT_SW_EN\tBIT(26)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_DETECT_MUX_MASK\tGENMASK(25, 23)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_DETECT_VREF_P_MUX\tBIT(22)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_DETECT_VREF_N_MUX\tBIT(21)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_DETECT_MODE_SEL\tBIT(20)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_DETECT_YP_DRIVE_SW\tBIT(19)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_DETECT_XP_DRIVE_SW\tBIT(18)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_DETECT_YM_DRIVE_SW\tBIT(17)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_DETECT_XM_DRIVE_SW\tBIT(16)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_IDLE_MUX_SEL_MASK\tGENMASK(9, 7)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_IDLE_VREF_P_MUX\tBIT(6)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_IDLE_VREF_N_MUX\tBIT(5)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_IDLE_MODE_SEL\tBIT(4)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_IDLE_YP_DRIVE_SW\tBIT(3)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_IDLE_XP_DRIVE_SW\tBIT(2)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_IDLE_YM_DRIVE_SW\tBIT(1)\n\t#define MESON_SAR_ADC_DETECT_IDLE_SW_IDLE_XM_DRIVE_SW\tBIT(0)\n\n#define MESON_SAR_ADC_DELTA_10\t\t\t\t\t0x28\n\t#define MESON_SAR_ADC_DELTA_10_TEMP_SEL\t\t\tBIT(27)\n\t#define MESON_SAR_ADC_DELTA_10_TS_REVE1\t\t\tBIT(26)\n\t#define MESON_SAR_ADC_DELTA_10_CHAN1_DELTA_VALUE_MASK\tGENMASK(25, 16)\n\t#define MESON_SAR_ADC_DELTA_10_TS_REVE0\t\t\tBIT(15)\n\t#define MESON_SAR_ADC_DELTA_10_TS_C_MASK\t\tGENMASK(14, 11)\n\t#define MESON_SAR_ADC_DELTA_10_TS_VBG_EN\t\tBIT(10)\n\t#define MESON_SAR_ADC_DELTA_10_CHAN0_DELTA_VALUE_MASK\tGENMASK(9, 0)\n\n \n#define MESON_SAR_ADC_REG11\t\t\t\t\t0x2c\n\t#define MESON_SAR_ADC_REG11_BANDGAP_EN\t\t\tBIT(13)\n\t#define MESON_SAR_ADC_REG11_CMV_SEL                     BIT(6)\n\t#define MESON_SAR_ADC_REG11_VREF_VOLTAGE                BIT(5)\n\t#define MESON_SAR_ADC_REG11_EOC                         BIT(1)\n\t#define MESON_SAR_ADC_REG11_VREF_SEL                    BIT(0)\n\n#define MESON_SAR_ADC_REG13\t\t\t\t\t0x34\n\t#define MESON_SAR_ADC_REG13_12BIT_CALIBRATION_MASK\tGENMASK(13, 8)\n\n#define MESON_SAR_ADC_MAX_FIFO_SIZE\t\t\t\t32\n#define MESON_SAR_ADC_TIMEOUT\t\t\t\t\t100  \n#define MESON_SAR_ADC_VOLTAGE_AND_TEMP_CHANNEL\t\t\t6\n#define MESON_SAR_ADC_VOLTAGE_AND_MUX_CHANNEL\t\t\t7\n#define MESON_SAR_ADC_TEMP_OFFSET\t\t\t\t27\n\n \n#define MESON_SAR_ADC_EFUSE_BYTES\t\t\t\t4\n#define MESON_SAR_ADC_EFUSE_BYTE3_UPPER_ADC_VAL\t\t\tGENMASK(6, 0)\n#define MESON_SAR_ADC_EFUSE_BYTE3_IS_CALIBRATED\t\t\tBIT(7)\n\n#define MESON_HHI_DPLL_TOP_0\t\t\t\t\t0x318\n#define MESON_HHI_DPLL_TOP_0_TSC_BIT4\t\t\t\tBIT(9)\n\n \n#define MILLION\t\t\t\t\t\t\t1000000\n\n#define MESON_SAR_ADC_CHAN(_chan) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel = _chan,\t\t\t\t\t\t\\\n\t.address = _chan,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_AVERAGE_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_CALIBBIAS) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\t\t\\\n\t.datasheet_name = \"SAR_ADC_CH\"#_chan,\t\t\t\t\\\n}\n\n#define MESON_SAR_ADC_TEMP_CHAN(_chan) {\t\t\t\t\\\n\t.type = IIO_TEMP,\t\t\t\t\t\t\\\n\t.channel = _chan,\t\t\t\t\t\t\\\n\t.address = MESON_SAR_ADC_VOLTAGE_AND_TEMP_CHANNEL,\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_AVERAGE_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET) |\t\t\\\n\t\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_CALIBBIAS) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\t\t\\\n\t.datasheet_name = \"TEMP_SENSOR\",\t\t\t\t\\\n}\n\n#define MESON_SAR_ADC_MUX(_chan, _sel) {\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\t\\\n\t.channel = _chan,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.address = MESON_SAR_ADC_VOLTAGE_AND_MUX_CHANNEL,\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_AVERAGE_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_CALIBBIAS) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\t\t\\\n\t.datasheet_name = \"SAR_ADC_MUX_\"#_sel,\t\t\t\t\\\n}\n\nenum meson_sar_adc_vref_sel {\n\tVREF_CALIBATION_VOLTAGE = 0,\n\tVREF_VDDA = 1,\n};\n\nenum meson_sar_adc_avg_mode {\n\tNO_AVERAGING = 0x0,\n\tMEAN_AVERAGING = 0x1,\n\tMEDIAN_AVERAGING = 0x2,\n};\n\nenum meson_sar_adc_num_samples {\n\tONE_SAMPLE = 0x0,\n\tTWO_SAMPLES = 0x1,\n\tFOUR_SAMPLES = 0x2,\n\tEIGHT_SAMPLES = 0x3,\n};\n\nenum meson_sar_adc_chan7_mux_sel {\n\tCHAN7_MUX_VSS = 0x0,\n\tCHAN7_MUX_VDD_DIV4 = 0x1,\n\tCHAN7_MUX_VDD_DIV2 = 0x2,\n\tCHAN7_MUX_VDD_MUL3_DIV4 = 0x3,\n\tCHAN7_MUX_VDD = 0x4,\n\tCHAN7_MUX_CH7_INPUT = 0x7,\n};\n\nenum meson_sar_adc_channel_index {\n\tNUM_CHAN_0,\n\tNUM_CHAN_1,\n\tNUM_CHAN_2,\n\tNUM_CHAN_3,\n\tNUM_CHAN_4,\n\tNUM_CHAN_5,\n\tNUM_CHAN_6,\n\tNUM_CHAN_7,\n\tNUM_CHAN_TEMP,\n\tNUM_MUX_0_VSS,\n\tNUM_MUX_1_VDD_DIV4,\n\tNUM_MUX_2_VDD_DIV2,\n\tNUM_MUX_3_VDD_MUL3_DIV4,\n\tNUM_MUX_4_VDD,\n};\n\nstatic enum meson_sar_adc_chan7_mux_sel chan7_mux_values[] = {\n\tCHAN7_MUX_VSS,\n\tCHAN7_MUX_VDD_DIV4,\n\tCHAN7_MUX_VDD_DIV2,\n\tCHAN7_MUX_VDD_MUL3_DIV4,\n\tCHAN7_MUX_VDD,\n};\n\nstatic const char * const chan7_mux_names[] = {\n\t[CHAN7_MUX_VSS] = \"gnd\",\n\t[CHAN7_MUX_VDD_DIV4] = \"0.25vdd\",\n\t[CHAN7_MUX_VDD_DIV2] = \"0.5vdd\",\n\t[CHAN7_MUX_VDD_MUL3_DIV4] = \"0.75vdd\",\n\t[CHAN7_MUX_VDD] = \"vdd\",\n};\n\nstatic const struct iio_chan_spec meson_sar_adc_iio_channels[] = {\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_0),\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_1),\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_2),\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_3),\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_4),\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_5),\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_6),\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_7),\n\tMESON_SAR_ADC_MUX(NUM_MUX_0_VSS, 0),\n\tMESON_SAR_ADC_MUX(NUM_MUX_1_VDD_DIV4, 1),\n\tMESON_SAR_ADC_MUX(NUM_MUX_2_VDD_DIV2, 2),\n\tMESON_SAR_ADC_MUX(NUM_MUX_3_VDD_MUL3_DIV4, 3),\n\tMESON_SAR_ADC_MUX(NUM_MUX_4_VDD, 4),\n};\n\nstatic const struct iio_chan_spec meson_sar_adc_and_temp_iio_channels[] = {\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_0),\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_1),\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_2),\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_3),\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_4),\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_5),\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_6),\n\tMESON_SAR_ADC_CHAN(NUM_CHAN_7),\n\tMESON_SAR_ADC_TEMP_CHAN(NUM_CHAN_TEMP),\n\tMESON_SAR_ADC_MUX(NUM_MUX_0_VSS, 0),\n\tMESON_SAR_ADC_MUX(NUM_MUX_1_VDD_DIV4, 1),\n\tMESON_SAR_ADC_MUX(NUM_MUX_2_VDD_DIV2, 2),\n\tMESON_SAR_ADC_MUX(NUM_MUX_3_VDD_MUL3_DIV4, 3),\n\tMESON_SAR_ADC_MUX(NUM_MUX_4_VDD, 4),\n};\n\nstruct meson_sar_adc_param {\n\tbool\t\t\t\t\thas_bl30_integration;\n\tunsigned long\t\t\t\tclock_rate;\n\tu32\t\t\t\t\tbandgap_reg;\n\tunsigned int\t\t\t\tresolution;\n\tconst struct regmap_config\t\t*regmap_config;\n\tu8\t\t\t\t\ttemperature_trimming_bits;\n\tunsigned int\t\t\t\ttemperature_multiplier;\n\tunsigned int\t\t\t\ttemperature_divider;\n\tu8\t\t\t\t\tdisable_ring_counter;\n\tbool\t\t\t\t\thas_reg11;\n\tbool\t\t\t\t\thas_vref_select;\n\tu8\t\t\t\t\tvref_select;\n\tu8\t\t\t\t\tcmv_select;\n\tu8\t\t\t\t\tadc_eoc;\n\tenum meson_sar_adc_vref_sel\t\tvref_volatge;\n};\n\nstruct meson_sar_adc_data {\n\tconst struct meson_sar_adc_param\t*param;\n\tconst char\t\t\t\t*name;\n};\n\nstruct meson_sar_adc_priv {\n\tstruct regmap\t\t\t\t*regmap;\n\tstruct regulator\t\t\t*vref;\n\tconst struct meson_sar_adc_param\t*param;\n\tstruct clk\t\t\t\t*clkin;\n\tstruct clk\t\t\t\t*core_clk;\n\tstruct clk\t\t\t\t*adc_sel_clk;\n\tstruct clk\t\t\t\t*adc_clk;\n\tstruct clk_gate\t\t\t\tclk_gate;\n\tstruct clk\t\t\t\t*adc_div_clk;\n\tstruct clk_divider\t\t\tclk_div;\n\tstruct completion\t\t\tdone;\n\t \n\tstruct mutex\t\t\t\tlock;\n\tint\t\t\t\t\tcalibbias;\n\tint\t\t\t\t\tcalibscale;\n\tstruct regmap\t\t\t\t*tsc_regmap;\n\tbool\t\t\t\t\ttemperature_sensor_calibrated;\n\tu8\t\t\t\t\ttemperature_sensor_coefficient;\n\tu16\t\t\t\t\ttemperature_sensor_adc_val;\n\tenum meson_sar_adc_chan7_mux_sel\tchan7_mux_sel;\n};\n\nstatic const struct regmap_config meson_sar_adc_regmap_config_gxbb = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = MESON_SAR_ADC_REG13,\n};\n\nstatic const struct regmap_config meson_sar_adc_regmap_config_meson8 = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = MESON_SAR_ADC_DELTA_10,\n};\n\nstatic const struct iio_chan_spec *\nfind_channel_by_num(struct iio_dev *indio_dev, int num)\n{\n\tint i;\n\n\tfor (i = 0; i < indio_dev->num_channels; i++)\n\t\tif (indio_dev->channels[i].channel == num)\n\t\t\treturn &indio_dev->channels[i];\n\treturn NULL;\n}\n\nstatic unsigned int meson_sar_adc_get_fifo_count(struct iio_dev *indio_dev)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tu32 regval;\n\n\tregmap_read(priv->regmap, MESON_SAR_ADC_REG0, &regval);\n\n\treturn FIELD_GET(MESON_SAR_ADC_REG0_FIFO_COUNT_MASK, regval);\n}\n\nstatic int meson_sar_adc_calib_val(struct iio_dev *indio_dev, int val)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tint tmp;\n\n\t \n\ttmp = div_s64((s64)val * priv->calibscale, MILLION) + priv->calibbias;\n\n\treturn clamp(tmp, 0, (1 << priv->param->resolution) - 1);\n}\n\nstatic int meson_sar_adc_wait_busy_clear(struct iio_dev *indio_dev)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tint val;\n\n\t \n\tudelay(1);\n\treturn regmap_read_poll_timeout_atomic(priv->regmap, MESON_SAR_ADC_REG0, val,\n\t\t\t\t\t       !FIELD_GET(MESON_SAR_ADC_REG0_BUSY_MASK, val),\n\t\t\t\t\t       1, 10000);\n}\n\nstatic void meson_sar_adc_set_chan7_mux(struct iio_dev *indio_dev,\n\t\t\t\t\tenum meson_sar_adc_chan7_mux_sel sel)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tu32 regval;\n\n\tregval = FIELD_PREP(MESON_SAR_ADC_REG3_CTRL_CHAN7_MUX_SEL_MASK, sel);\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG3,\n\t\t\t   MESON_SAR_ADC_REG3_CTRL_CHAN7_MUX_SEL_MASK, regval);\n\n\tusleep_range(10, 20);\n\n\tpriv->chan7_mux_sel = sel;\n}\n\nstatic int meson_sar_adc_read_raw_sample(struct iio_dev *indio_dev,\n\t\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t\t int *val)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\tint regval, fifo_chan, fifo_val, count;\n\n\tif (!wait_for_completion_timeout(&priv->done,\n\t\t\t\tmsecs_to_jiffies(MESON_SAR_ADC_TIMEOUT)))\n\t\treturn -ETIMEDOUT;\n\n\tcount = meson_sar_adc_get_fifo_count(indio_dev);\n\tif (count != 1) {\n\t\tdev_err(dev, \"ADC FIFO has %d element(s) instead of one\\n\", count);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_read(priv->regmap, MESON_SAR_ADC_FIFO_RD, &regval);\n\tfifo_chan = FIELD_GET(MESON_SAR_ADC_FIFO_RD_CHAN_ID_MASK, regval);\n\tif (fifo_chan != chan->address) {\n\t\tdev_err(dev, \"ADC FIFO entry belongs to channel %d instead of %lu\\n\",\n\t\t\tfifo_chan, chan->address);\n\t\treturn -EINVAL;\n\t}\n\n\tfifo_val = FIELD_GET(MESON_SAR_ADC_FIFO_RD_SAMPLE_VALUE_MASK, regval);\n\tfifo_val &= GENMASK(priv->param->resolution - 1, 0);\n\t*val = meson_sar_adc_calib_val(indio_dev, fifo_val);\n\n\treturn 0;\n}\n\nstatic void meson_sar_adc_set_averaging(struct iio_dev *indio_dev,\n\t\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\t\tenum meson_sar_adc_avg_mode mode,\n\t\t\t\t\tenum meson_sar_adc_num_samples samples)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tint val, address = chan->address;\n\n\tval = samples << MESON_SAR_ADC_AVG_CNTL_NUM_SAMPLES_SHIFT(address);\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_AVG_CNTL,\n\t\t\t   MESON_SAR_ADC_AVG_CNTL_NUM_SAMPLES_MASK(address),\n\t\t\t   val);\n\n\tval = mode << MESON_SAR_ADC_AVG_CNTL_AVG_MODE_SHIFT(address);\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_AVG_CNTL,\n\t\t\t   MESON_SAR_ADC_AVG_CNTL_AVG_MODE_MASK(address), val);\n}\n\nstatic void meson_sar_adc_enable_channel(struct iio_dev *indio_dev,\n\t\t\t\t\tconst struct iio_chan_spec *chan)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tu32 regval;\n\n\t \n\tregval = FIELD_PREP(MESON_SAR_ADC_CHAN_LIST_MAX_INDEX_MASK, 0);\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_CHAN_LIST,\n\t\t\t   MESON_SAR_ADC_CHAN_LIST_MAX_INDEX_MASK, regval);\n\n\t \n\tregval = FIELD_PREP(MESON_SAR_ADC_CHAN_LIST_ENTRY_MASK(0),\n\t\t\t    chan->address);\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_CHAN_LIST,\n\t\t\t   MESON_SAR_ADC_CHAN_LIST_ENTRY_MASK(0), regval);\n\n\tregval = FIELD_PREP(MESON_SAR_ADC_DETECT_IDLE_SW_DETECT_MUX_MASK,\n\t\t\t    chan->address);\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_DETECT_IDLE_SW,\n\t\t\t   MESON_SAR_ADC_DETECT_IDLE_SW_DETECT_MUX_MASK,\n\t\t\t   regval);\n\n\tregval = FIELD_PREP(MESON_SAR_ADC_DETECT_IDLE_SW_IDLE_MUX_SEL_MASK,\n\t\t\t    chan->address);\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_DETECT_IDLE_SW,\n\t\t\t   MESON_SAR_ADC_DETECT_IDLE_SW_IDLE_MUX_SEL_MASK,\n\t\t\t   regval);\n\n\tif (chan->address == MESON_SAR_ADC_VOLTAGE_AND_TEMP_CHANNEL) {\n\t\tif (chan->type == IIO_TEMP)\n\t\t\tregval = MESON_SAR_ADC_DELTA_10_TEMP_SEL;\n\t\telse\n\t\t\tregval = 0;\n\n\t\tregmap_update_bits(priv->regmap,\n\t\t\t\t   MESON_SAR_ADC_DELTA_10,\n\t\t\t\t   MESON_SAR_ADC_DELTA_10_TEMP_SEL, regval);\n\t} else if (chan->address == MESON_SAR_ADC_VOLTAGE_AND_MUX_CHANNEL) {\n\t\tenum meson_sar_adc_chan7_mux_sel sel;\n\n\t\tif (chan->channel == NUM_CHAN_7)\n\t\t\tsel = CHAN7_MUX_CH7_INPUT;\n\t\telse\n\t\t\tsel = chan7_mux_values[chan->channel - NUM_MUX_0_VSS];\n\t\tif (sel != priv->chan7_mux_sel)\n\t\t\tmeson_sar_adc_set_chan7_mux(indio_dev, sel);\n\t}\n}\n\nstatic void meson_sar_adc_start_sample_engine(struct iio_dev *indio_dev)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\n\treinit_completion(&priv->done);\n\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG0,\n\t\t\t   MESON_SAR_ADC_REG0_FIFO_IRQ_EN,\n\t\t\t   MESON_SAR_ADC_REG0_FIFO_IRQ_EN);\n\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG0,\n\t\t\t   MESON_SAR_ADC_REG0_SAMPLE_ENGINE_ENABLE,\n\t\t\t   MESON_SAR_ADC_REG0_SAMPLE_ENGINE_ENABLE);\n\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG0,\n\t\t\t   MESON_SAR_ADC_REG0_SAMPLING_START,\n\t\t\t   MESON_SAR_ADC_REG0_SAMPLING_START);\n}\n\nstatic void meson_sar_adc_stop_sample_engine(struct iio_dev *indio_dev)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG0,\n\t\t\t   MESON_SAR_ADC_REG0_FIFO_IRQ_EN, 0);\n\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG0,\n\t\t\t   MESON_SAR_ADC_REG0_SAMPLING_STOP,\n\t\t\t   MESON_SAR_ADC_REG0_SAMPLING_STOP);\n\n\t \n\tmeson_sar_adc_wait_busy_clear(indio_dev);\n\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG0,\n\t\t\t   MESON_SAR_ADC_REG0_SAMPLE_ENGINE_ENABLE, 0);\n}\n\nstatic int meson_sar_adc_lock(struct iio_dev *indio_dev)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tint val, ret;\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->param->has_bl30_integration) {\n\t\t \n\t\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_DELAY,\n\t\t\t\t   MESON_SAR_ADC_DELAY_KERNEL_BUSY,\n\t\t\t\t   MESON_SAR_ADC_DELAY_KERNEL_BUSY);\n\n\t\tudelay(1);\n\n\t\t \n\t\tret = regmap_read_poll_timeout_atomic(priv->regmap, MESON_SAR_ADC_DELAY, val,\n\t\t\t\t\t\t      !(val & MESON_SAR_ADC_DELAY_BL30_BUSY),\n\t\t\t\t\t\t      1, 10000);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&priv->lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void meson_sar_adc_unlock(struct iio_dev *indio_dev)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\n\tif (priv->param->has_bl30_integration)\n\t\t \n\t\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_DELAY,\n\t\t\t\t   MESON_SAR_ADC_DELAY_KERNEL_BUSY, 0);\n\n\tmutex_unlock(&priv->lock);\n}\n\nstatic void meson_sar_adc_clear_fifo(struct iio_dev *indio_dev)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tunsigned int count, tmp;\n\n\tfor (count = 0; count < MESON_SAR_ADC_MAX_FIFO_SIZE; count++) {\n\t\tif (!meson_sar_adc_get_fifo_count(indio_dev))\n\t\t\tbreak;\n\n\t\tregmap_read(priv->regmap, MESON_SAR_ADC_FIFO_RD, &tmp);\n\t}\n}\n\nstatic int meson_sar_adc_get_sample(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum meson_sar_adc_avg_mode avg_mode,\n\t\t\t\t    enum meson_sar_adc_num_samples avg_samples,\n\t\t\t\t    int *val)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\tint ret;\n\n\tif (chan->type == IIO_TEMP && !priv->temperature_sensor_calibrated)\n\t\treturn -ENOTSUPP;\n\n\tret = meson_sar_adc_lock(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmeson_sar_adc_clear_fifo(indio_dev);\n\n\tmeson_sar_adc_set_averaging(indio_dev, chan, avg_mode, avg_samples);\n\n\tmeson_sar_adc_enable_channel(indio_dev, chan);\n\n\tmeson_sar_adc_start_sample_engine(indio_dev);\n\tret = meson_sar_adc_read_raw_sample(indio_dev, chan, val);\n\tmeson_sar_adc_stop_sample_engine(indio_dev);\n\n\tmeson_sar_adc_unlock(indio_dev);\n\n\tif (ret) {\n\t\tdev_warn(dev, \"failed to read sample for channel %lu: %d\\n\",\n\t\t\t chan->address, ret);\n\t\treturn ret;\n\t}\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int meson_sar_adc_iio_info_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn meson_sar_adc_get_sample(indio_dev, chan, NO_AVERAGING,\n\t\t\t\t\t\tONE_SAMPLE, val);\n\n\tcase IIO_CHAN_INFO_AVERAGE_RAW:\n\t\treturn meson_sar_adc_get_sample(indio_dev, chan,\n\t\t\t\t\t\tMEAN_AVERAGING, EIGHT_SAMPLES,\n\t\t\t\t\t\tval);\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type == IIO_VOLTAGE) {\n\t\t\tret = regulator_get_voltage(priv->vref);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"failed to get vref voltage: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t*val = ret / 1000;\n\t\t\t*val2 = priv->param->resolution;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\t} else if (chan->type == IIO_TEMP) {\n\t\t\t \n\t\t\t*val = priv->param->temperature_multiplier;\n\t\t\t*val2 = priv->param->temperature_divider;\n\n\t\t\t \n\t\t\t*val *= 1000;\n\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\t*val = priv->calibbias;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\t*val = priv->calibscale / MILLION;\n\t\t*val2 = priv->calibscale % MILLION;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = DIV_ROUND_CLOSEST(MESON_SAR_ADC_TEMP_OFFSET *\n\t\t\t\t\t priv->param->temperature_divider,\n\t\t\t\t\t priv->param->temperature_multiplier);\n\t\t*val -= priv->temperature_sensor_adc_val;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int meson_sar_adc_clk_init(struct iio_dev *indio_dev,\n\t\t\t\t  void __iomem *base)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\tstruct clk_init_data init;\n\tconst char *clk_parents[1];\n\n\tinit.name = devm_kasprintf(dev, GFP_KERNEL, \"%s#adc_div\", dev_name(dev));\n\tif (!init.name)\n\t\treturn -ENOMEM;\n\n\tinit.flags = 0;\n\tinit.ops = &clk_divider_ops;\n\tclk_parents[0] = __clk_get_name(priv->clkin);\n\tinit.parent_names = clk_parents;\n\tinit.num_parents = 1;\n\n\tpriv->clk_div.reg = base + MESON_SAR_ADC_REG3;\n\tpriv->clk_div.shift = MESON_SAR_ADC_REG3_ADC_CLK_DIV_SHIFT;\n\tpriv->clk_div.width = MESON_SAR_ADC_REG3_ADC_CLK_DIV_WIDTH;\n\tpriv->clk_div.hw.init = &init;\n\tpriv->clk_div.flags = 0;\n\n\tpriv->adc_div_clk = devm_clk_register(dev, &priv->clk_div.hw);\n\tif (WARN_ON(IS_ERR(priv->adc_div_clk)))\n\t\treturn PTR_ERR(priv->adc_div_clk);\n\n\tinit.name = devm_kasprintf(dev, GFP_KERNEL, \"%s#adc_en\", dev_name(dev));\n\tif (!init.name)\n\t\treturn -ENOMEM;\n\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.ops = &clk_gate_ops;\n\tclk_parents[0] = __clk_get_name(priv->adc_div_clk);\n\tinit.parent_names = clk_parents;\n\tinit.num_parents = 1;\n\n\tpriv->clk_gate.reg = base + MESON_SAR_ADC_REG3;\n\tpriv->clk_gate.bit_idx = __ffs(MESON_SAR_ADC_REG3_CLK_EN);\n\tpriv->clk_gate.hw.init = &init;\n\n\tpriv->adc_clk = devm_clk_register(dev, &priv->clk_gate.hw);\n\tif (WARN_ON(IS_ERR(priv->adc_clk)))\n\t\treturn PTR_ERR(priv->adc_clk);\n\n\treturn 0;\n}\n\nstatic int meson_sar_adc_temp_sensor_init(struct iio_dev *indio_dev)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tu8 *buf, trimming_bits, trimming_mask, upper_adc_val;\n\tstruct device *dev = indio_dev->dev.parent;\n\tstruct nvmem_cell *temperature_calib;\n\tsize_t read_len;\n\tint ret;\n\n\ttemperature_calib = devm_nvmem_cell_get(dev, \"temperature_calib\");\n\tif (IS_ERR(temperature_calib)) {\n\t\tret = PTR_ERR(temperature_calib);\n\n\t\t \n\t\tif (ret == -ENODEV)\n\t\t\treturn 0;\n\n\t\treturn dev_err_probe(dev, ret, \"failed to get temperature_calib cell\\n\");\n\t}\n\n\tpriv->tsc_regmap = syscon_regmap_lookup_by_phandle(dev->of_node, \"amlogic,hhi-sysctrl\");\n\tif (IS_ERR(priv->tsc_regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->tsc_regmap),\n\t\t\t\t     \"failed to get amlogic,hhi-sysctrl regmap\\n\");\n\n\tread_len = MESON_SAR_ADC_EFUSE_BYTES;\n\tbuf = nvmem_cell_read(temperature_calib, &read_len);\n\tif (IS_ERR(buf))\n\t\treturn dev_err_probe(dev, PTR_ERR(buf), \"failed to read temperature_calib cell\\n\");\n\tif (read_len != MESON_SAR_ADC_EFUSE_BYTES) {\n\t\tkfree(buf);\n\t\treturn dev_err_probe(dev, -EINVAL, \"invalid read size of temperature_calib cell\\n\");\n\t}\n\n\ttrimming_bits = priv->param->temperature_trimming_bits;\n\ttrimming_mask = BIT(trimming_bits) - 1;\n\n\tpriv->temperature_sensor_calibrated =\n\t\tbuf[3] & MESON_SAR_ADC_EFUSE_BYTE3_IS_CALIBRATED;\n\tpriv->temperature_sensor_coefficient = buf[2] & trimming_mask;\n\n\tupper_adc_val = FIELD_GET(MESON_SAR_ADC_EFUSE_BYTE3_UPPER_ADC_VAL,\n\t\t\t\t  buf[3]);\n\n\tpriv->temperature_sensor_adc_val = buf[2];\n\tpriv->temperature_sensor_adc_val |= upper_adc_val << BITS_PER_BYTE;\n\tpriv->temperature_sensor_adc_val >>= trimming_bits;\n\n\tkfree(buf);\n\n\treturn 0;\n}\n\nstatic int meson_sar_adc_init(struct iio_dev *indio_dev)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\tint regval, i, ret;\n\n\t \n\tmeson_sar_adc_set_chan7_mux(indio_dev, CHAN7_MUX_CH7_INPUT);\n\n\tif (priv->param->has_bl30_integration) {\n\t\t \n\t\tregmap_read(priv->regmap, MESON_SAR_ADC_REG3, &regval);\n\t\tif (regval & MESON_SAR_ADC_REG3_BL30_INITIALIZED)\n\t\t\treturn 0;\n\t}\n\n\tmeson_sar_adc_stop_sample_engine(indio_dev);\n\n\t \n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG0,\n\t\t\t   MESON_SAR_ADC_REG0_ADC_TEMP_SEN_SEL, 0);\n\n\t \n\tregmap_write(priv->regmap, MESON_SAR_ADC_CHAN_LIST, 0x0);\n\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG3,\n\t\t\t   MESON_SAR_ADC_REG3_CTRL_SAMPLING_CLOCK_PHASE, 0);\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG3,\n\t\t\t   MESON_SAR_ADC_REG3_CNTL_USE_SC_DLY,\n\t\t\t   MESON_SAR_ADC_REG3_CNTL_USE_SC_DLY);\n\n\t \n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_DELAY,\n\t\t\t   MESON_SAR_ADC_DELAY_INPUT_DLY_CNT_MASK,\n\t\t\t   FIELD_PREP(MESON_SAR_ADC_DELAY_SAMPLE_DLY_CNT_MASK,\n\t\t\t\t      10));\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_DELAY,\n\t\t\t   MESON_SAR_ADC_DELAY_SAMPLE_DLY_SEL_MASK,\n\t\t\t   FIELD_PREP(MESON_SAR_ADC_DELAY_SAMPLE_DLY_SEL_MASK,\n\t\t\t\t      0));\n\n\t \n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_DELAY,\n\t\t\t   MESON_SAR_ADC_DELAY_INPUT_DLY_CNT_MASK,\n\t\t\t   FIELD_PREP(MESON_SAR_ADC_DELAY_INPUT_DLY_CNT_MASK,\n\t\t\t\t      10));\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_DELAY,\n\t\t\t   MESON_SAR_ADC_DELAY_INPUT_DLY_SEL_MASK,\n\t\t\t   FIELD_PREP(MESON_SAR_ADC_DELAY_INPUT_DLY_SEL_MASK,\n\t\t\t\t      1));\n\n\t \n\tregval = FIELD_PREP(MESON_SAR_ADC_CHAN_10_SW_CHAN0_MUX_SEL_MASK, 0);\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_CHAN_10_SW,\n\t\t\t   MESON_SAR_ADC_CHAN_10_SW_CHAN0_MUX_SEL_MASK,\n\t\t\t   regval);\n\tregval = FIELD_PREP(MESON_SAR_ADC_CHAN_10_SW_CHAN1_MUX_SEL_MASK, 1);\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_CHAN_10_SW,\n\t\t\t   MESON_SAR_ADC_CHAN_10_SW_CHAN1_MUX_SEL_MASK,\n\t\t\t   regval);\n\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_CHAN_10_SW,\n\t\t\t   MESON_SAR_ADC_CHAN_10_SW_CHAN0_XP_DRIVE_SW,\n\t\t\t   MESON_SAR_ADC_CHAN_10_SW_CHAN0_XP_DRIVE_SW);\n\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_CHAN_10_SW,\n\t\t\t   MESON_SAR_ADC_CHAN_10_SW_CHAN0_YP_DRIVE_SW,\n\t\t\t   MESON_SAR_ADC_CHAN_10_SW_CHAN0_YP_DRIVE_SW);\n\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_CHAN_10_SW,\n\t\t\t   MESON_SAR_ADC_CHAN_10_SW_CHAN1_XP_DRIVE_SW,\n\t\t\t   MESON_SAR_ADC_CHAN_10_SW_CHAN1_XP_DRIVE_SW);\n\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_CHAN_10_SW,\n\t\t\t   MESON_SAR_ADC_CHAN_10_SW_CHAN1_YP_DRIVE_SW,\n\t\t\t   MESON_SAR_ADC_CHAN_10_SW_CHAN1_YP_DRIVE_SW);\n\n\t \n\tregval = 0;\n\tfor (i = 2; i <= 7; i++)\n\t\tregval |= i << MESON_SAR_ADC_AUX_SW_MUX_SEL_CHAN_SHIFT(i);\n\tregval |= MESON_SAR_ADC_AUX_SW_YP_DRIVE_SW;\n\tregval |= MESON_SAR_ADC_AUX_SW_XP_DRIVE_SW;\n\tregmap_write(priv->regmap, MESON_SAR_ADC_AUX_SW, regval);\n\n\tif (priv->temperature_sensor_calibrated) {\n\t\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_DELTA_10,\n\t\t\t\t   MESON_SAR_ADC_DELTA_10_TS_REVE1,\n\t\t\t\t   MESON_SAR_ADC_DELTA_10_TS_REVE1);\n\t\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_DELTA_10,\n\t\t\t\t   MESON_SAR_ADC_DELTA_10_TS_REVE0,\n\t\t\t\t   MESON_SAR_ADC_DELTA_10_TS_REVE0);\n\n\t\t \n\t\tregval = FIELD_PREP(MESON_SAR_ADC_DELTA_10_TS_C_MASK,\n\t\t\t\t    priv->temperature_sensor_coefficient);\n\t\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_DELTA_10,\n\t\t\t\t   MESON_SAR_ADC_DELTA_10_TS_C_MASK, regval);\n\n\t\tif (priv->param->temperature_trimming_bits == 5) {\n\t\t\tif (priv->temperature_sensor_coefficient & BIT(4))\n\t\t\t\tregval = MESON_HHI_DPLL_TOP_0_TSC_BIT4;\n\t\t\telse\n\t\t\t\tregval = 0;\n\n\t\t\t \n\t\t\tregmap_update_bits(priv->tsc_regmap,\n\t\t\t\t\t   MESON_HHI_DPLL_TOP_0,\n\t\t\t\t\t   MESON_HHI_DPLL_TOP_0_TSC_BIT4,\n\t\t\t\t\t   regval);\n\t\t}\n\t} else {\n\t\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_DELTA_10,\n\t\t\t\t   MESON_SAR_ADC_DELTA_10_TS_REVE1, 0);\n\t\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_DELTA_10,\n\t\t\t\t   MESON_SAR_ADC_DELTA_10_TS_REVE0, 0);\n\t}\n\n\tregval = FIELD_PREP(MESON_SAR_ADC_REG3_CTRL_CONT_RING_COUNTER_EN,\n\t\t\t    priv->param->disable_ring_counter);\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG3,\n\t\t\t   MESON_SAR_ADC_REG3_CTRL_CONT_RING_COUNTER_EN,\n\t\t\t   regval);\n\n\tif (priv->param->has_reg11) {\n\t\tregval = FIELD_PREP(MESON_SAR_ADC_REG11_EOC, priv->param->adc_eoc);\n\t\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG11,\n\t\t\t\t   MESON_SAR_ADC_REG11_EOC, regval);\n\n\t\tif (priv->param->has_vref_select) {\n\t\t\tregval = FIELD_PREP(MESON_SAR_ADC_REG11_VREF_SEL,\n\t\t\t\t\t    priv->param->vref_select);\n\t\t\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG11,\n\t\t\t\t\t   MESON_SAR_ADC_REG11_VREF_SEL, regval);\n\t\t}\n\n\t\tregval = FIELD_PREP(MESON_SAR_ADC_REG11_VREF_VOLTAGE,\n\t\t\t\t    priv->param->vref_volatge);\n\t\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG11,\n\t\t\t\t   MESON_SAR_ADC_REG11_VREF_VOLTAGE, regval);\n\n\t\tregval = FIELD_PREP(MESON_SAR_ADC_REG11_CMV_SEL,\n\t\t\t\t    priv->param->cmv_select);\n\t\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG11,\n\t\t\t\t   MESON_SAR_ADC_REG11_CMV_SEL, regval);\n\t}\n\n\tret = clk_set_parent(priv->adc_sel_clk, priv->clkin);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to set adc parent to clkin\\n\");\n\n\tret = clk_set_rate(priv->adc_clk, priv->param->clock_rate);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to set adc clock rate\\n\");\n\n\treturn 0;\n}\n\nstatic void meson_sar_adc_set_bandgap(struct iio_dev *indio_dev, bool on_off)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tconst struct meson_sar_adc_param *param = priv->param;\n\tu32 enable_mask;\n\n\tif (param->bandgap_reg == MESON_SAR_ADC_REG11)\n\t\tenable_mask = MESON_SAR_ADC_REG11_BANDGAP_EN;\n\telse\n\t\tenable_mask = MESON_SAR_ADC_DELTA_10_TS_VBG_EN;\n\n\tregmap_update_bits(priv->regmap, param->bandgap_reg, enable_mask,\n\t\t\t   on_off ? enable_mask : 0);\n}\n\nstatic int meson_sar_adc_hw_enable(struct iio_dev *indio_dev)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\tint ret;\n\tu32 regval;\n\n\tret = meson_sar_adc_lock(indio_dev);\n\tif (ret)\n\t\tgoto err_lock;\n\n\tret = regulator_enable(priv->vref);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable vref regulator\\n\");\n\t\tgoto err_vref;\n\t}\n\n\tregval = FIELD_PREP(MESON_SAR_ADC_REG0_FIFO_CNT_IRQ_MASK, 1);\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG0,\n\t\t\t   MESON_SAR_ADC_REG0_FIFO_CNT_IRQ_MASK, regval);\n\n\tmeson_sar_adc_set_bandgap(indio_dev, true);\n\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG3,\n\t\t\t   MESON_SAR_ADC_REG3_ADC_EN,\n\t\t\t   MESON_SAR_ADC_REG3_ADC_EN);\n\n\tudelay(5);\n\n\tret = clk_prepare_enable(priv->adc_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable adc clk\\n\");\n\t\tgoto err_adc_clk;\n\t}\n\n\tmeson_sar_adc_unlock(indio_dev);\n\n\treturn 0;\n\nerr_adc_clk:\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG3,\n\t\t\t   MESON_SAR_ADC_REG3_ADC_EN, 0);\n\tmeson_sar_adc_set_bandgap(indio_dev, false);\n\tregulator_disable(priv->vref);\nerr_vref:\n\tmeson_sar_adc_unlock(indio_dev);\nerr_lock:\n\treturn ret;\n}\n\nstatic void meson_sar_adc_hw_disable(struct iio_dev *indio_dev)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tint ret;\n\n\t \n\tret = meson_sar_adc_lock(indio_dev);\n\tif (ret)\n\t\tdev_err(indio_dev->dev.parent, \"Failed to lock ADC (%pE)\\n\", ERR_PTR(ret));\n\n\tclk_disable_unprepare(priv->adc_clk);\n\n\tregmap_update_bits(priv->regmap, MESON_SAR_ADC_REG3,\n\t\t\t   MESON_SAR_ADC_REG3_ADC_EN, 0);\n\n\tmeson_sar_adc_set_bandgap(indio_dev, false);\n\n\tregulator_disable(priv->vref);\n\n\tif (!ret)\n\t\tmeson_sar_adc_unlock(indio_dev);\n}\n\nstatic irqreturn_t meson_sar_adc_irq(int irq, void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tunsigned int cnt, threshold;\n\tu32 regval;\n\n\tregmap_read(priv->regmap, MESON_SAR_ADC_REG0, &regval);\n\tcnt = FIELD_GET(MESON_SAR_ADC_REG0_FIFO_COUNT_MASK, regval);\n\tthreshold = FIELD_GET(MESON_SAR_ADC_REG0_FIFO_CNT_IRQ_MASK, regval);\n\n\tif (cnt < threshold)\n\t\treturn IRQ_NONE;\n\n\tcomplete(&priv->done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int meson_sar_adc_calib(struct iio_dev *indio_dev)\n{\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tint ret, nominal0, nominal1, value0, value1;\n\n\t \n\tnominal0 = (1 << priv->param->resolution) / 4;\n\tnominal1 = (1 << priv->param->resolution) * 3 / 4;\n\n\tmeson_sar_adc_set_chan7_mux(indio_dev, CHAN7_MUX_VDD_DIV4);\n\tusleep_range(10, 20);\n\tret = meson_sar_adc_get_sample(indio_dev,\n\t\t\t\t       find_channel_by_num(indio_dev,\n\t\t\t\t\t\t\t   NUM_MUX_1_VDD_DIV4),\n\t\t\t\t       MEAN_AVERAGING, EIGHT_SAMPLES, &value0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmeson_sar_adc_set_chan7_mux(indio_dev, CHAN7_MUX_VDD_MUL3_DIV4);\n\tusleep_range(10, 20);\n\tret = meson_sar_adc_get_sample(indio_dev,\n\t\t\t\t       find_channel_by_num(indio_dev,\n\t\t\t\t\t\t\t   NUM_MUX_3_VDD_MUL3_DIV4),\n\t\t\t\t       MEAN_AVERAGING, EIGHT_SAMPLES, &value1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (value1 <= value0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->calibscale = div_s64((nominal1 - nominal0) * (s64)MILLION,\n\t\t\t\t   value1 - value0);\n\tpriv->calibbias = nominal0 - div_s64((s64)value0 * priv->calibscale,\n\t\t\t\t\t     MILLION);\n\tret = 0;\nout:\n\tmeson_sar_adc_set_chan7_mux(indio_dev, CHAN7_MUX_CH7_INPUT);\n\n\treturn ret;\n}\n\nstatic int read_label(struct iio_dev *indio_dev,\n\t\t      struct iio_chan_spec const *chan,\n\t\t      char *label)\n{\n\tif (chan->type == IIO_TEMP)\n\t\treturn sprintf(label, \"temp-sensor\\n\");\n\tif (chan->type == IIO_VOLTAGE && chan->channel >= NUM_MUX_0_VSS)\n\t\treturn sprintf(label, \"%s\\n\",\n\t\t\t       chan7_mux_names[chan->channel - NUM_MUX_0_VSS]);\n\tif (chan->type == IIO_VOLTAGE)\n\t\treturn sprintf(label, \"channel-%d\\n\", chan->channel);\n\treturn 0;\n}\n\nstatic const struct iio_info meson_sar_adc_iio_info = {\n\t.read_raw = meson_sar_adc_iio_info_read_raw,\n\t.read_label = read_label,\n};\n\nstatic const struct meson_sar_adc_param meson_sar_adc_meson8_param = {\n\t.has_bl30_integration = false,\n\t.clock_rate = 1150000,\n\t.bandgap_reg = MESON_SAR_ADC_DELTA_10,\n\t.regmap_config = &meson_sar_adc_regmap_config_meson8,\n\t.resolution = 10,\n\t.temperature_trimming_bits = 4,\n\t.temperature_multiplier = 18 * 10000,\n\t.temperature_divider = 1024 * 10 * 85,\n};\n\nstatic const struct meson_sar_adc_param meson_sar_adc_meson8b_param = {\n\t.has_bl30_integration = false,\n\t.clock_rate = 1150000,\n\t.bandgap_reg = MESON_SAR_ADC_DELTA_10,\n\t.regmap_config = &meson_sar_adc_regmap_config_meson8,\n\t.resolution = 10,\n\t.temperature_trimming_bits = 5,\n\t.temperature_multiplier = 10,\n\t.temperature_divider = 32,\n};\n\nstatic const struct meson_sar_adc_param meson_sar_adc_gxbb_param = {\n\t.has_bl30_integration = true,\n\t.clock_rate = 1200000,\n\t.bandgap_reg = MESON_SAR_ADC_REG11,\n\t.regmap_config = &meson_sar_adc_regmap_config_gxbb,\n\t.resolution = 10,\n\t.has_reg11 = true,\n\t.vref_volatge = 1,\n\t.cmv_select = 1,\n};\n\nstatic const struct meson_sar_adc_param meson_sar_adc_gxl_param = {\n\t.has_bl30_integration = true,\n\t.clock_rate = 1200000,\n\t.bandgap_reg = MESON_SAR_ADC_REG11,\n\t.regmap_config = &meson_sar_adc_regmap_config_gxbb,\n\t.resolution = 12,\n\t.disable_ring_counter = 1,\n\t.has_reg11 = true,\n\t.vref_volatge = 1,\n\t.cmv_select = 1,\n};\n\nstatic const struct meson_sar_adc_param meson_sar_adc_axg_param = {\n\t.has_bl30_integration = true,\n\t.clock_rate = 1200000,\n\t.bandgap_reg = MESON_SAR_ADC_REG11,\n\t.regmap_config = &meson_sar_adc_regmap_config_gxbb,\n\t.resolution = 12,\n\t.disable_ring_counter = 1,\n\t.has_reg11 = true,\n\t.vref_volatge = 1,\n\t.has_vref_select = true,\n\t.vref_select = VREF_VDDA,\n\t.cmv_select = 1,\n};\n\nstatic const struct meson_sar_adc_param meson_sar_adc_g12a_param = {\n\t.has_bl30_integration = false,\n\t.clock_rate = 1200000,\n\t.bandgap_reg = MESON_SAR_ADC_REG11,\n\t.regmap_config = &meson_sar_adc_regmap_config_gxbb,\n\t.resolution = 12,\n\t.disable_ring_counter = 1,\n\t.has_reg11 = true,\n\t.adc_eoc = 1,\n\t.has_vref_select = true,\n\t.vref_select = VREF_VDDA,\n};\n\nstatic const struct meson_sar_adc_data meson_sar_adc_meson8_data = {\n\t.param = &meson_sar_adc_meson8_param,\n\t.name = \"meson-meson8-saradc\",\n};\n\nstatic const struct meson_sar_adc_data meson_sar_adc_meson8b_data = {\n\t.param = &meson_sar_adc_meson8b_param,\n\t.name = \"meson-meson8b-saradc\",\n};\n\nstatic const struct meson_sar_adc_data meson_sar_adc_meson8m2_data = {\n\t.param = &meson_sar_adc_meson8b_param,\n\t.name = \"meson-meson8m2-saradc\",\n};\n\nstatic const struct meson_sar_adc_data meson_sar_adc_gxbb_data = {\n\t.param = &meson_sar_adc_gxbb_param,\n\t.name = \"meson-gxbb-saradc\",\n};\n\nstatic const struct meson_sar_adc_data meson_sar_adc_gxl_data = {\n\t.param = &meson_sar_adc_gxl_param,\n\t.name = \"meson-gxl-saradc\",\n};\n\nstatic const struct meson_sar_adc_data meson_sar_adc_gxm_data = {\n\t.param = &meson_sar_adc_gxl_param,\n\t.name = \"meson-gxm-saradc\",\n};\n\nstatic const struct meson_sar_adc_data meson_sar_adc_axg_data = {\n\t.param = &meson_sar_adc_axg_param,\n\t.name = \"meson-axg-saradc\",\n};\n\nstatic const struct meson_sar_adc_data meson_sar_adc_g12a_data = {\n\t.param = &meson_sar_adc_g12a_param,\n\t.name = \"meson-g12a-saradc\",\n};\n\nstatic const struct of_device_id meson_sar_adc_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,meson8-saradc\",\n\t\t.data = &meson_sar_adc_meson8_data,\n\t}, {\n\t\t.compatible = \"amlogic,meson8b-saradc\",\n\t\t.data = &meson_sar_adc_meson8b_data,\n\t}, {\n\t\t.compatible = \"amlogic,meson8m2-saradc\",\n\t\t.data = &meson_sar_adc_meson8m2_data,\n\t}, {\n\t\t.compatible = \"amlogic,meson-gxbb-saradc\",\n\t\t.data = &meson_sar_adc_gxbb_data,\n\t}, {\n\t\t.compatible = \"amlogic,meson-gxl-saradc\",\n\t\t.data = &meson_sar_adc_gxl_data,\n\t}, {\n\t\t.compatible = \"amlogic,meson-gxm-saradc\",\n\t\t.data = &meson_sar_adc_gxm_data,\n\t}, {\n\t\t.compatible = \"amlogic,meson-axg-saradc\",\n\t\t.data = &meson_sar_adc_axg_data,\n\t}, {\n\t\t.compatible = \"amlogic,meson-g12a-saradc\",\n\t\t.data = &meson_sar_adc_g12a_data,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, meson_sar_adc_of_match);\n\nstatic int meson_sar_adc_probe(struct platform_device *pdev)\n{\n\tconst struct meson_sar_adc_data *match_data;\n\tstruct meson_sar_adc_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tvoid __iomem *base;\n\tint irq, ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*priv));\n\tif (!indio_dev)\n\t\treturn dev_err_probe(dev, -ENOMEM, \"failed allocating iio device\\n\");\n\n\tpriv = iio_priv(indio_dev);\n\tinit_completion(&priv->done);\n\n\tmatch_data = of_device_get_match_data(dev);\n\tif (!match_data)\n\t\treturn dev_err_probe(dev, -ENODEV, \"failed to get match data\\n\");\n\n\tpriv->param = match_data->param;\n\n\tindio_dev->name = match_data->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &meson_sar_adc_iio_info;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->regmap = devm_regmap_init_mmio(dev, base, priv->param->regmap_config);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tirq = irq_of_parse_and_map(dev->of_node, 0);\n\tif (!irq)\n\t\treturn -EINVAL;\n\n\tret = devm_request_irq(dev, irq, meson_sar_adc_irq, IRQF_SHARED, dev_name(dev), indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->clkin = devm_clk_get(dev, \"clkin\");\n\tif (IS_ERR(priv->clkin))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clkin), \"failed to get clkin\\n\");\n\n\tpriv->core_clk = devm_clk_get_enabled(dev, \"core\");\n\tif (IS_ERR(priv->core_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->core_clk), \"failed to get core clk\\n\");\n\n\tpriv->adc_clk = devm_clk_get_optional(dev, \"adc_clk\");\n\tif (IS_ERR(priv->adc_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->adc_clk), \"failed to get adc clk\\n\");\n\n\tpriv->adc_sel_clk = devm_clk_get_optional(dev, \"adc_sel\");\n\tif (IS_ERR(priv->adc_sel_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->adc_sel_clk), \"failed to get adc_sel clk\\n\");\n\n\t \n\tif (!priv->adc_clk) {\n\t\tret = meson_sar_adc_clk_init(indio_dev, base);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpriv->vref = devm_regulator_get(dev, \"vref\");\n\tif (IS_ERR(priv->vref))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->vref), \"failed to get vref regulator\\n\");\n\n\tpriv->calibscale = MILLION;\n\n\tif (priv->param->temperature_trimming_bits) {\n\t\tret = meson_sar_adc_temp_sensor_init(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (priv->temperature_sensor_calibrated) {\n\t\tindio_dev->channels = meson_sar_adc_and_temp_iio_channels;\n\t\tindio_dev->num_channels =\n\t\t\tARRAY_SIZE(meson_sar_adc_and_temp_iio_channels);\n\t} else {\n\t\tindio_dev->channels = meson_sar_adc_iio_channels;\n\t\tindio_dev->num_channels =\n\t\t\tARRAY_SIZE(meson_sar_adc_iio_channels);\n\t}\n\n\tret = meson_sar_adc_init(indio_dev);\n\tif (ret)\n\t\tgoto err;\n\n\tmutex_init(&priv->lock);\n\n\tret = meson_sar_adc_hw_enable(indio_dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = meson_sar_adc_calib(indio_dev);\n\tif (ret)\n\t\tdev_warn(dev, \"calibration failed\\n\");\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto err_hw;\n\n\treturn 0;\n\nerr_hw:\n\tmeson_sar_adc_hw_disable(indio_dev);\nerr:\n\treturn ret;\n}\n\nstatic int meson_sar_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\n\tiio_device_unregister(indio_dev);\n\n\tmeson_sar_adc_hw_disable(indio_dev);\n\n\treturn 0;\n}\n\nstatic int meson_sar_adc_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\n\tmeson_sar_adc_hw_disable(indio_dev);\n\n\tclk_disable_unprepare(priv->core_clk);\n\n\treturn 0;\n}\n\nstatic int meson_sar_adc_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct meson_sar_adc_priv *priv = iio_priv(indio_dev);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->core_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable core clk\\n\");\n\t\treturn ret;\n\t}\n\n\treturn meson_sar_adc_hw_enable(indio_dev);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(meson_sar_adc_pm_ops,\n\t\t\t\tmeson_sar_adc_suspend, meson_sar_adc_resume);\n\nstatic struct platform_driver meson_sar_adc_driver = {\n\t.probe\t\t= meson_sar_adc_probe,\n\t.remove\t\t= meson_sar_adc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"meson-saradc\",\n\t\t.of_match_table = meson_sar_adc_of_match,\n\t\t.pm = pm_sleep_ptr(&meson_sar_adc_pm_ops),\n\t},\n};\n\nmodule_platform_driver(meson_sar_adc_driver);\n\nMODULE_AUTHOR(\"Martin Blumenstingl <martin.blumenstingl@googlemail.com>\");\nMODULE_DESCRIPTION(\"Amlogic Meson SAR ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}