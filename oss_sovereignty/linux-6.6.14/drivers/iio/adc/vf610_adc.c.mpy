{
  "module_name": "vf610_adc.c",
  "hash_id": "39499a0abe755ead9978aa18a8ef0479aef17ea6a24881b458df9aadb2a5736c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/vf610_adc.c",
  "human_readable_source": "\n \n\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n \n#define DRIVER_NAME \"vf610-adc\"\n\n \n#define VF610_REG_ADC_HC0\t\t0x00\n#define VF610_REG_ADC_HC1\t\t0x04\n#define VF610_REG_ADC_HS\t\t0x08\n#define VF610_REG_ADC_R0\t\t0x0c\n#define VF610_REG_ADC_R1\t\t0x10\n#define VF610_REG_ADC_CFG\t\t0x14\n#define VF610_REG_ADC_GC\t\t0x18\n#define VF610_REG_ADC_GS\t\t0x1c\n#define VF610_REG_ADC_CV\t\t0x20\n#define VF610_REG_ADC_OFS\t\t0x24\n#define VF610_REG_ADC_CAL\t\t0x28\n#define VF610_REG_ADC_PCTL\t\t0x30\n\n \n#define VF610_ADC_MODE_BIT8\t\t0x00\n#define VF610_ADC_MODE_BIT10\t\t0x04\n#define VF610_ADC_MODE_BIT12\t\t0x08\n#define VF610_ADC_MODE_MASK\t\t0x0c\n#define VF610_ADC_BUSCLK2_SEL\t\t0x01\n#define VF610_ADC_ALTCLK_SEL\t\t0x02\n#define VF610_ADC_ADACK_SEL\t\t0x03\n#define VF610_ADC_ADCCLK_MASK\t\t0x03\n#define VF610_ADC_CLK_DIV2\t\t0x20\n#define VF610_ADC_CLK_DIV4\t\t0x40\n#define VF610_ADC_CLK_DIV8\t\t0x60\n#define VF610_ADC_CLK_MASK\t\t0x60\n#define VF610_ADC_ADLSMP_LONG\t\t0x10\n#define VF610_ADC_ADSTS_SHORT   0x100\n#define VF610_ADC_ADSTS_NORMAL  0x200\n#define VF610_ADC_ADSTS_LONG    0x300\n#define VF610_ADC_ADSTS_MASK\t\t0x300\n#define VF610_ADC_ADLPC_EN\t\t0x80\n#define VF610_ADC_ADHSC_EN\t\t0x400\n#define VF610_ADC_REFSEL_VALT\t\t0x800\n#define VF610_ADC_REFSEL_VBG\t\t0x1000\n#define VF610_ADC_ADTRG_HARD\t\t0x2000\n#define VF610_ADC_AVGS_8\t\t0x4000\n#define VF610_ADC_AVGS_16\t\t0x8000\n#define VF610_ADC_AVGS_32\t\t0xC000\n#define VF610_ADC_AVGS_MASK\t\t0xC000\n#define VF610_ADC_OVWREN\t\t0x10000\n\n \n#define VF610_ADC_ADACKEN\t\t0x1\n#define VF610_ADC_DMAEN\t\t\t0x2\n#define VF610_ADC_ACREN\t\t\t0x4\n#define VF610_ADC_ACFGT\t\t\t0x8\n#define VF610_ADC_ACFE\t\t\t0x10\n#define VF610_ADC_AVGEN\t\t\t0x20\n#define VF610_ADC_ADCON\t\t\t0x40\n#define VF610_ADC_CAL\t\t\t0x80\n\n \n#define VF610_ADC_ADCHC(x)\t\t((x) & 0x1F)\n#define VF610_ADC_AIEN\t\t\t(0x1 << 7)\n#define VF610_ADC_CONV_DISABLE\t\t0x1F\n#define VF610_ADC_HS_COCO0\t\t0x1\n#define VF610_ADC_CALF\t\t\t0x2\n#define VF610_ADC_TIMEOUT\t\tmsecs_to_jiffies(100)\n\n#define DEFAULT_SAMPLE_TIME\t\t1000\n\n \n#define VF610_VTEMP25_3V0\t\t950\n \n#define VF610_VTEMP25_3V3\t\t867\n \n#define VF610_TEMP_SLOPE_COEFF\t\t1840\n\nenum clk_sel {\n\tVF610_ADCIOC_BUSCLK_SET,\n\tVF610_ADCIOC_ALTCLK_SET,\n\tVF610_ADCIOC_ADACK_SET,\n};\n\nenum vol_ref {\n\tVF610_ADCIOC_VR_VREF_SET,\n\tVF610_ADCIOC_VR_VALT_SET,\n\tVF610_ADCIOC_VR_VBG_SET,\n};\n\nenum average_sel {\n\tVF610_ADC_SAMPLE_1,\n\tVF610_ADC_SAMPLE_4,\n\tVF610_ADC_SAMPLE_8,\n\tVF610_ADC_SAMPLE_16,\n\tVF610_ADC_SAMPLE_32,\n};\n\nenum conversion_mode_sel {\n\tVF610_ADC_CONV_NORMAL,\n\tVF610_ADC_CONV_HIGH_SPEED,\n\tVF610_ADC_CONV_LOW_POWER,\n};\n\nenum lst_adder_sel {\n\tVF610_ADCK_CYCLES_3,\n\tVF610_ADCK_CYCLES_5,\n\tVF610_ADCK_CYCLES_7,\n\tVF610_ADCK_CYCLES_9,\n\tVF610_ADCK_CYCLES_13,\n\tVF610_ADCK_CYCLES_17,\n\tVF610_ADCK_CYCLES_21,\n\tVF610_ADCK_CYCLES_25,\n};\n\nstruct vf610_adc_feature {\n\tenum clk_sel\tclk_sel;\n\tenum vol_ref\tvol_ref;\n\tenum conversion_mode_sel conv_mode;\n\n\tint\tclk_div;\n\tint     sample_rate;\n\tint\tres_mode;\n\tu32 lst_adder_index;\n\tu32 default_sample_time;\n\n\tbool\tcalibration;\n\tbool\tovwren;\n};\n\nstruct vf610_adc {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\n\t \n\tstruct mutex lock;\n\n\tu32 vref_uv;\n\tu32 value;\n\tstruct regulator *vref;\n\n\tu32 max_adck_rate[3];\n\tstruct vf610_adc_feature adc_feature;\n\n\tu32 sample_freq_avail[5];\n\n\tstruct completion completion;\n\t \n\tstruct {\n\t\tu16 chan;\n\t\ts64 timestamp __aligned(8);\n\t} scan;\n};\n\nstatic const u32 vf610_hw_avgs[] = { 1, 4, 8, 16, 32 };\nstatic const u32 vf610_lst_adder[] = { 3, 5, 7, 9, 13, 17, 21, 25 };\n\nstatic inline void vf610_adc_calculate_rates(struct vf610_adc *info)\n{\n\tstruct vf610_adc_feature *adc_feature = &info->adc_feature;\n\tunsigned long adck_rate, ipg_rate = clk_get_rate(info->clk);\n\tu32 adck_period, lst_addr_min;\n\tint divisor, i;\n\n\tadck_rate = info->max_adck_rate[adc_feature->conv_mode];\n\n\tif (adck_rate) {\n\t\t \n\t\tdivisor = ipg_rate / adck_rate;\n\t\tadc_feature->clk_div = 1 << fls(divisor + 1);\n\t} else {\n\t\t \n\t\tadc_feature->clk_div = 8;\n\t}\n\n\tadck_rate = ipg_rate / adc_feature->clk_div;\n\n\t \n\tadck_period = NSEC_PER_SEC / adck_rate;\n\tlst_addr_min = adc_feature->default_sample_time / adck_period;\n\tfor (i = 0; i < ARRAY_SIZE(vf610_lst_adder); i++) {\n\t\tif (vf610_lst_adder[i] > lst_addr_min) {\n\t\t\tadc_feature->lst_adder_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(vf610_hw_avgs); i++)\n\t\tinfo->sample_freq_avail[i] =\n\t\t\tadck_rate / (6 + vf610_hw_avgs[i] *\n\t\t\t (25 + vf610_lst_adder[adc_feature->lst_adder_index]));\n}\n\nstatic inline void vf610_adc_cfg_init(struct vf610_adc *info)\n{\n\tstruct vf610_adc_feature *adc_feature = &info->adc_feature;\n\n\t \n\tadc_feature->clk_sel = VF610_ADCIOC_BUSCLK_SET;\n\tadc_feature->vol_ref = VF610_ADCIOC_VR_VREF_SET;\n\n\tadc_feature->calibration = true;\n\tadc_feature->ovwren = true;\n\n\tadc_feature->res_mode = 12;\n\tadc_feature->sample_rate = 1;\n\n\tadc_feature->conv_mode = VF610_ADC_CONV_LOW_POWER;\n\n\tvf610_adc_calculate_rates(info);\n}\n\nstatic void vf610_adc_cfg_post_set(struct vf610_adc *info)\n{\n\tstruct vf610_adc_feature *adc_feature = &info->adc_feature;\n\tint cfg_data = 0;\n\tint gc_data = 0;\n\n\tswitch (adc_feature->clk_sel) {\n\tcase VF610_ADCIOC_ALTCLK_SET:\n\t\tcfg_data |= VF610_ADC_ALTCLK_SEL;\n\t\tbreak;\n\tcase VF610_ADCIOC_ADACK_SET:\n\t\tcfg_data |= VF610_ADC_ADACK_SEL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tcfg_data |= VF610_ADC_ADLPC_EN;\n\n\t \n\tcfg_data |= VF610_ADC_ADHSC_EN;\n\n\t \n\tswitch (adc_feature->vol_ref) {\n\tcase VF610_ADCIOC_VR_VREF_SET:\n\t\tbreak;\n\tcase VF610_ADCIOC_VR_VALT_SET:\n\t\tcfg_data |= VF610_ADC_REFSEL_VALT;\n\t\tbreak;\n\tcase VF610_ADCIOC_VR_VBG_SET:\n\t\tcfg_data |= VF610_ADC_REFSEL_VBG;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(info->dev, \"error voltage reference\\n\");\n\t}\n\n\t \n\tif (adc_feature->ovwren)\n\t\tcfg_data |= VF610_ADC_OVWREN;\n\n\twritel(cfg_data, info->regs + VF610_REG_ADC_CFG);\n\twritel(gc_data, info->regs + VF610_REG_ADC_GC);\n}\n\nstatic void vf610_adc_calibration(struct vf610_adc *info)\n{\n\tint adc_gc, hc_cfg;\n\n\tif (!info->adc_feature.calibration)\n\t\treturn;\n\n\t \n\thc_cfg = VF610_ADC_AIEN | VF610_ADC_CONV_DISABLE;\n\twritel(hc_cfg, info->regs + VF610_REG_ADC_HC0);\n\n\tadc_gc = readl(info->regs + VF610_REG_ADC_GC);\n\twritel(adc_gc | VF610_ADC_CAL, info->regs + VF610_REG_ADC_GC);\n\n\tif (!wait_for_completion_timeout(&info->completion, VF610_ADC_TIMEOUT))\n\t\tdev_err(info->dev, \"Timeout for adc calibration\\n\");\n\n\tadc_gc = readl(info->regs + VF610_REG_ADC_GS);\n\tif (adc_gc & VF610_ADC_CALF)\n\t\tdev_err(info->dev, \"ADC calibration failed\\n\");\n\n\tinfo->adc_feature.calibration = false;\n}\n\nstatic void vf610_adc_cfg_set(struct vf610_adc *info)\n{\n\tstruct vf610_adc_feature *adc_feature = &(info->adc_feature);\n\tint cfg_data;\n\n\tcfg_data = readl(info->regs + VF610_REG_ADC_CFG);\n\n\tcfg_data &= ~VF610_ADC_ADLPC_EN;\n\tif (adc_feature->conv_mode == VF610_ADC_CONV_LOW_POWER)\n\t\tcfg_data |= VF610_ADC_ADLPC_EN;\n\n\tcfg_data &= ~VF610_ADC_ADHSC_EN;\n\tif (adc_feature->conv_mode == VF610_ADC_CONV_HIGH_SPEED)\n\t\tcfg_data |= VF610_ADC_ADHSC_EN;\n\n\twritel(cfg_data, info->regs + VF610_REG_ADC_CFG);\n}\n\nstatic void vf610_adc_sample_set(struct vf610_adc *info)\n{\n\tstruct vf610_adc_feature *adc_feature = &(info->adc_feature);\n\tint cfg_data, gc_data;\n\n\tcfg_data = readl(info->regs + VF610_REG_ADC_CFG);\n\tgc_data = readl(info->regs + VF610_REG_ADC_GC);\n\n\t \n\tcfg_data &= ~VF610_ADC_MODE_MASK;\n\tswitch (adc_feature->res_mode) {\n\tcase 8:\n\t\tcfg_data |= VF610_ADC_MODE_BIT8;\n\t\tbreak;\n\tcase 10:\n\t\tcfg_data |= VF610_ADC_MODE_BIT10;\n\t\tbreak;\n\tcase 12:\n\t\tcfg_data |= VF610_ADC_MODE_BIT12;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(info->dev, \"error resolution mode\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tcfg_data &= ~(VF610_ADC_CLK_MASK | VF610_ADC_ADCCLK_MASK);\n\tswitch (adc_feature->clk_div) {\n\tcase 1:\n\t\tbreak;\n\tcase 2:\n\t\tcfg_data |= VF610_ADC_CLK_DIV2;\n\t\tbreak;\n\tcase 4:\n\t\tcfg_data |= VF610_ADC_CLK_DIV4;\n\t\tbreak;\n\tcase 8:\n\t\tcfg_data |= VF610_ADC_CLK_DIV8;\n\t\tbreak;\n\tcase 16:\n\t\tswitch (adc_feature->clk_sel) {\n\t\tcase VF610_ADCIOC_BUSCLK_SET:\n\t\t\tcfg_data |= VF610_ADC_BUSCLK2_SEL | VF610_ADC_CLK_DIV8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(info->dev, \"error clk divider\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tswitch (adc_feature->lst_adder_index) {\n\tcase VF610_ADCK_CYCLES_3:\n\t\tbreak;\n\tcase VF610_ADCK_CYCLES_5:\n\t\tcfg_data |= VF610_ADC_ADSTS_SHORT;\n\t\tbreak;\n\tcase VF610_ADCK_CYCLES_7:\n\t\tcfg_data |= VF610_ADC_ADSTS_NORMAL;\n\t\tbreak;\n\tcase VF610_ADCK_CYCLES_9:\n\t\tcfg_data |= VF610_ADC_ADSTS_LONG;\n\t\tbreak;\n\tcase VF610_ADCK_CYCLES_13:\n\t\tcfg_data |= VF610_ADC_ADLSMP_LONG;\n\t\tbreak;\n\tcase VF610_ADCK_CYCLES_17:\n\t\tcfg_data |= VF610_ADC_ADLSMP_LONG;\n\t\tcfg_data |= VF610_ADC_ADSTS_SHORT;\n\t\tbreak;\n\tcase VF610_ADCK_CYCLES_21:\n\t\tcfg_data |= VF610_ADC_ADLSMP_LONG;\n\t\tcfg_data |= VF610_ADC_ADSTS_NORMAL;\n\t\tbreak;\n\tcase VF610_ADCK_CYCLES_25:\n\t\tcfg_data |= VF610_ADC_ADLSMP_LONG;\n\t\tcfg_data |= VF610_ADC_ADSTS_NORMAL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(info->dev, \"error in sample time select\\n\");\n\t}\n\n\t \n\tcfg_data &= ~VF610_ADC_AVGS_MASK;\n\tgc_data &= ~VF610_ADC_AVGEN;\n\tswitch (adc_feature->sample_rate) {\n\tcase VF610_ADC_SAMPLE_1:\n\t\tbreak;\n\tcase VF610_ADC_SAMPLE_4:\n\t\tgc_data |= VF610_ADC_AVGEN;\n\t\tbreak;\n\tcase VF610_ADC_SAMPLE_8:\n\t\tgc_data |= VF610_ADC_AVGEN;\n\t\tcfg_data |= VF610_ADC_AVGS_8;\n\t\tbreak;\n\tcase VF610_ADC_SAMPLE_16:\n\t\tgc_data |= VF610_ADC_AVGEN;\n\t\tcfg_data |= VF610_ADC_AVGS_16;\n\t\tbreak;\n\tcase VF610_ADC_SAMPLE_32:\n\t\tgc_data |= VF610_ADC_AVGEN;\n\t\tcfg_data |= VF610_ADC_AVGS_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(info->dev,\n\t\t\t\"error hardware sample average select\\n\");\n\t}\n\n\twritel(cfg_data, info->regs + VF610_REG_ADC_CFG);\n\twritel(gc_data, info->regs + VF610_REG_ADC_GC);\n}\n\nstatic void vf610_adc_hw_init(struct vf610_adc *info)\n{\n\t \n\tvf610_adc_cfg_post_set(info);\n\tvf610_adc_sample_set(info);\n\n\t \n\tvf610_adc_calibration(info);\n\n\t \n\tvf610_adc_cfg_set(info);\n}\n\nstatic int vf610_set_conversion_mode(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     unsigned int mode)\n{\n\tstruct vf610_adc *info = iio_priv(indio_dev);\n\n\tmutex_lock(&info->lock);\n\tinfo->adc_feature.conv_mode = mode;\n\tvf610_adc_calculate_rates(info);\n\tvf610_adc_hw_init(info);\n\tmutex_unlock(&info->lock);\n\n\treturn 0;\n}\n\nstatic int vf610_get_conversion_mode(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan)\n{\n\tstruct vf610_adc *info = iio_priv(indio_dev);\n\n\treturn info->adc_feature.conv_mode;\n}\n\nstatic const char * const vf610_conv_modes[] = { \"normal\", \"high-speed\",\n\t\t\t\t\t\t \"low-power\" };\n\nstatic const struct iio_enum vf610_conversion_mode = {\n\t.items = vf610_conv_modes,\n\t.num_items = ARRAY_SIZE(vf610_conv_modes),\n\t.get = vf610_get_conversion_mode,\n\t.set = vf610_set_conversion_mode,\n};\n\nstatic const struct iio_chan_spec_ext_info vf610_ext_info[] = {\n\tIIO_ENUM(\"conversion_mode\", IIO_SHARED_BY_DIR, &vf610_conversion_mode),\n\t{},\n};\n\n#define VF610_ADC_CHAN(_idx, _chan_type) {\t\t\t\\\n\t.type = (_chan_type),\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = (_idx),\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n\t.ext_info = vf610_ext_info,\t\t\t\t\\\n\t.scan_index = (_idx),\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\\\n\t\t.realbits = 12,\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\\\n\t},\t\t\t\t\t\t\\\n}\n\n#define VF610_ADC_TEMPERATURE_CHAN(_idx, _chan_type) {\t\\\n\t.type = (_chan_type),\t\\\n\t.channel = (_idx),\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\t\\\n\t.scan_index = (_idx),\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = 12,\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec vf610_adc_iio_channels[] = {\n\tVF610_ADC_CHAN(0, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(1, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(2, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(3, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(4, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(5, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(6, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(7, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(8, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(9, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(10, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(11, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(12, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(13, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(14, IIO_VOLTAGE),\n\tVF610_ADC_CHAN(15, IIO_VOLTAGE),\n\tVF610_ADC_TEMPERATURE_CHAN(26, IIO_TEMP),\n\tIIO_CHAN_SOFT_TIMESTAMP(32),\n\t \n};\n\nstatic int vf610_adc_read_data(struct vf610_adc *info)\n{\n\tint result;\n\n\tresult = readl(info->regs + VF610_REG_ADC_R0);\n\n\tswitch (info->adc_feature.res_mode) {\n\tcase 8:\n\t\tresult &= 0xFF;\n\t\tbreak;\n\tcase 10:\n\t\tresult &= 0x3FF;\n\t\tbreak;\n\tcase 12:\n\t\tresult &= 0xFFF;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic irqreturn_t vf610_adc_isr(int irq, void *dev_id)\n{\n\tstruct iio_dev *indio_dev = dev_id;\n\tstruct vf610_adc *info = iio_priv(indio_dev);\n\tint coco;\n\n\tcoco = readl(info->regs + VF610_REG_ADC_HS);\n\tif (coco & VF610_ADC_HS_COCO0) {\n\t\tinfo->value = vf610_adc_read_data(info);\n\t\tif (iio_buffer_enabled(indio_dev)) {\n\t\t\tinfo->scan.chan = info->value;\n\t\t\tiio_push_to_buffers_with_timestamp(indio_dev,\n\t\t\t\t\t&info->scan,\n\t\t\t\t\tiio_get_time_ns(indio_dev));\n\t\t\tiio_trigger_notify_done(indio_dev->trig);\n\t\t} else\n\t\t\tcomplete(&info->completion);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic ssize_t vf610_show_samp_freq_avail(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct vf610_adc *info = iio_priv(dev_to_iio_dev(dev));\n\tsize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(info->sample_freq_avail); i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"%u \", info->sample_freq_avail[i]);\n\n\t \n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic IIO_DEV_ATTR_SAMP_FREQ_AVAIL(vf610_show_samp_freq_avail);\n\nstatic struct attribute *vf610_attributes[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group vf610_attribute_group = {\n\t.attrs = vf610_attributes,\n};\n\nstatic int vf610_read_sample(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int *val)\n{\n\tstruct vf610_adc *info = iio_priv(indio_dev);\n\tunsigned int hc_cfg;\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&info->lock);\n\treinit_completion(&info->completion);\n\thc_cfg = VF610_ADC_ADCHC(chan->channel);\n\thc_cfg |= VF610_ADC_AIEN;\n\twritel(hc_cfg, info->regs + VF610_REG_ADC_HC0);\n\tret = wait_for_completion_interruptible_timeout(&info->completion,\n\t\t\t\t\t\t\tVF610_ADC_TIMEOUT);\n\tif (ret == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto out_unlock;\n\t}\n\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tswitch (chan->type) {\n\tcase IIO_VOLTAGE:\n\t\t*val = info->value;\n\t\tbreak;\n\tcase IIO_TEMP:\n\t\t \n\t\t*val = 25000 - ((int)info->value - VF610_VTEMP25_3V3) *\n\t\t\t\t1000000 / VF610_TEMP_SLOPE_COEFF;\n\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nout_unlock:\n\tmutex_unlock(&info->lock);\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret;\n}\n\nstatic int vf610_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint *val,\n\t\t\tint *val2,\n\t\t\tlong mask)\n{\n\tstruct vf610_adc *info = iio_priv(indio_dev);\n\tlong ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tret = vf610_read_sample(indio_dev, chan, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = info->vref_uv / 1000;\n\t\t*val2 = info->adc_feature.res_mode;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = info->sample_freq_avail[info->adc_feature.sample_rate];\n\t\t*val2 = 0;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int vf610_write_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint val,\n\t\t\tint val2,\n\t\t\tlong mask)\n{\n\tstruct vf610_adc *info = iio_priv(indio_dev);\n\tint i;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tfor (i = 0;\n\t\t\ti < ARRAY_SIZE(info->sample_freq_avail);\n\t\t\ti++)\n\t\t\tif (val == info->sample_freq_avail[i]) {\n\t\t\t\tinfo->adc_feature.sample_rate = i;\n\t\t\t\tvf610_adc_sample_set(info);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int vf610_adc_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct vf610_adc *info = iio_priv(indio_dev);\n\tunsigned int channel;\n\tint val;\n\n\tval = readl(info->regs + VF610_REG_ADC_GC);\n\tval |= VF610_ADC_ADCON;\n\twritel(val, info->regs + VF610_REG_ADC_GC);\n\n\tchannel = find_first_bit(indio_dev->active_scan_mask,\n\t\t\t\t\t\tindio_dev->masklength);\n\n\tval = VF610_ADC_ADCHC(channel);\n\tval |= VF610_ADC_AIEN;\n\n\twritel(val, info->regs + VF610_REG_ADC_HC0);\n\n\treturn 0;\n}\n\nstatic int vf610_adc_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct vf610_adc *info = iio_priv(indio_dev);\n\tunsigned int hc_cfg = 0;\n\tint val;\n\n\tval = readl(info->regs + VF610_REG_ADC_GC);\n\tval &= ~VF610_ADC_ADCON;\n\twritel(val, info->regs + VF610_REG_ADC_GC);\n\n\thc_cfg |= VF610_ADC_CONV_DISABLE;\n\thc_cfg &= ~VF610_ADC_AIEN;\n\n\twritel(hc_cfg, info->regs + VF610_REG_ADC_HC0);\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops iio_triggered_buffer_setup_ops = {\n\t.postenable = &vf610_adc_buffer_postenable,\n\t.predisable = &vf610_adc_buffer_predisable,\n\t.validate_scan_mask = &iio_validate_scan_mask_onehot,\n};\n\nstatic int vf610_adc_reg_access(struct iio_dev *indio_dev,\n\t\t\tunsigned reg, unsigned writeval,\n\t\t\tunsigned *readval)\n{\n\tstruct vf610_adc *info = iio_priv(indio_dev);\n\n\tif ((readval == NULL) ||\n\t\t((reg % 4) || (reg > VF610_REG_ADC_PCTL)))\n\t\treturn -EINVAL;\n\n\t*readval = readl(info->regs + reg);\n\n\treturn 0;\n}\n\nstatic const struct iio_info vf610_adc_iio_info = {\n\t.read_raw = &vf610_read_raw,\n\t.write_raw = &vf610_write_raw,\n\t.debugfs_reg_access = &vf610_adc_reg_access,\n\t.attrs = &vf610_attribute_group,\n};\n\nstatic const struct of_device_id vf610_adc_match[] = {\n\t{ .compatible = \"fsl,vf610-adc\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, vf610_adc_match);\n\nstatic int vf610_adc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct vf610_adc *info;\n\tstruct iio_dev *indio_dev;\n\tint irq;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(struct vf610_adc));\n\tif (!indio_dev) {\n\t\tdev_err(&pdev->dev, \"Failed allocating iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo = iio_priv(indio_dev);\n\tinfo->dev = &pdev->dev;\n\n\tinfo->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(info->regs))\n\t\treturn PTR_ERR(info->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(info->dev, irq,\n\t\t\t\tvf610_adc_isr, 0,\n\t\t\t\tdev_name(&pdev->dev), indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed requesting irq, irq = %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\tinfo->clk = devm_clk_get(&pdev->dev, \"adc\");\n\tif (IS_ERR(info->clk)) {\n\t\tdev_err(&pdev->dev, \"failed getting clock, err = %ld\\n\",\n\t\t\t\t\t\tPTR_ERR(info->clk));\n\t\treturn PTR_ERR(info->clk);\n\t}\n\n\tinfo->vref = devm_regulator_get(&pdev->dev, \"vref\");\n\tif (IS_ERR(info->vref))\n\t\treturn PTR_ERR(info->vref);\n\n\tret = regulator_enable(info->vref);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo->vref_uv = regulator_get_voltage(info->vref);\n\n\tdevice_property_read_u32_array(dev, \"fsl,adck-max-frequency\", info->max_adck_rate, 3);\n\n\tinfo->adc_feature.default_sample_time = DEFAULT_SAMPLE_TIME;\n\tdevice_property_read_u32(dev, \"min-sample-time\", &info->adc_feature.default_sample_time);\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tinit_completion(&info->completion);\n\n\tindio_dev->name = dev_name(&pdev->dev);\n\tindio_dev->info = &vf610_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = vf610_adc_iio_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(vf610_adc_iio_channels);\n\n\tret = clk_prepare_enable(info->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Could not prepare or enable the clock.\\n\");\n\t\tgoto error_adc_clk_enable;\n\t}\n\n\tvf610_adc_cfg_init(info);\n\tvf610_adc_hw_init(info);\n\n\tret = iio_triggered_buffer_setup(indio_dev, &iio_pollfunc_store_time,\n\t\t\t\t\tNULL, &iio_triggered_buffer_setup_ops);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Couldn't initialise the buffer\\n\");\n\t\tgoto error_iio_device_register;\n\t}\n\n\tmutex_init(&info->lock);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't register the device.\\n\");\n\t\tgoto error_adc_buffer_init;\n\t}\n\n\treturn 0;\n\nerror_adc_buffer_init:\n\tiio_triggered_buffer_cleanup(indio_dev);\nerror_iio_device_register:\n\tclk_disable_unprepare(info->clk);\nerror_adc_clk_enable:\n\tregulator_disable(info->vref);\n\n\treturn ret;\n}\n\nstatic int vf610_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct vf610_adc *info = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tregulator_disable(info->vref);\n\tclk_disable_unprepare(info->clk);\n\n\treturn 0;\n}\n\nstatic int vf610_adc_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct vf610_adc *info = iio_priv(indio_dev);\n\tint hc_cfg;\n\n\t \n\thc_cfg = readl(info->regs + VF610_REG_ADC_HC0);\n\thc_cfg |= VF610_ADC_CONV_DISABLE;\n\twritel(hc_cfg, info->regs + VF610_REG_ADC_HC0);\n\n\tclk_disable_unprepare(info->clk);\n\tregulator_disable(info->vref);\n\n\treturn 0;\n}\n\nstatic int vf610_adc_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct vf610_adc *info = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_enable(info->vref);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(info->clk);\n\tif (ret)\n\t\tgoto disable_reg;\n\n\tvf610_adc_hw_init(info);\n\n\treturn 0;\n\ndisable_reg:\n\tregulator_disable(info->vref);\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(vf610_adc_pm_ops, vf610_adc_suspend,\n\t\t\t\tvf610_adc_resume);\n\nstatic struct platform_driver vf610_adc_driver = {\n\t.probe          = vf610_adc_probe,\n\t.remove         = vf610_adc_remove,\n\t.driver         = {\n\t\t.name   = DRIVER_NAME,\n\t\t.of_match_table = vf610_adc_match,\n\t\t.pm     = pm_sleep_ptr(&vf610_adc_pm_ops),\n\t},\n};\n\nmodule_platform_driver(vf610_adc_driver);\n\nMODULE_AUTHOR(\"Fugang Duan <B38611@freescale.com>\");\nMODULE_DESCRIPTION(\"Freescale VF610 ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}