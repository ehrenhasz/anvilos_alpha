{
  "module_name": "fsl-imx25-gcq.c",
  "hash_id": "77cc2e7b32a100e7f89cbfe8bf70b957cf180451ab5b6c295ec8e158d5ce4448",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/fsl-imx25-gcq.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/iio/adc/fsl-imx25-gcq.h>\n#include <linux/clk.h>\n#include <linux/iio/iio.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/imx25-tsadc.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#define MX25_GCQ_TIMEOUT (msecs_to_jiffies(2000))\n\nstatic const char * const driver_name = \"mx25-gcq\";\n\nenum mx25_gcq_cfgs {\n\tMX25_CFG_XP = 0,\n\tMX25_CFG_YP,\n\tMX25_CFG_XN,\n\tMX25_CFG_YN,\n\tMX25_CFG_WIPER,\n\tMX25_CFG_INAUX0,\n\tMX25_CFG_INAUX1,\n\tMX25_CFG_INAUX2,\n\tMX25_NUM_CFGS,\n};\n\nstruct mx25_gcq_priv {\n\tstruct regmap *regs;\n\tstruct completion completed;\n\tstruct clk *clk;\n\tint irq;\n\tstruct regulator *vref[4];\n\tu32 channel_vref_mv[MX25_NUM_CFGS];\n\t \n\tstruct mutex lock;\n};\n\n#define MX25_CQG_CHAN(chan, id) {\\\n\t.type = IIO_VOLTAGE,\\\n\t.indexed = 1,\\\n\t.channel = chan,\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\\\n\t.datasheet_name = id,\\\n}\n\nstatic const struct iio_chan_spec mx25_gcq_channels[MX25_NUM_CFGS] = {\n\tMX25_CQG_CHAN(MX25_CFG_XP, \"xp\"),\n\tMX25_CQG_CHAN(MX25_CFG_YP, \"yp\"),\n\tMX25_CQG_CHAN(MX25_CFG_XN, \"xn\"),\n\tMX25_CQG_CHAN(MX25_CFG_YN, \"yn\"),\n\tMX25_CQG_CHAN(MX25_CFG_WIPER, \"wiper\"),\n\tMX25_CQG_CHAN(MX25_CFG_INAUX0, \"inaux0\"),\n\tMX25_CQG_CHAN(MX25_CFG_INAUX1, \"inaux1\"),\n\tMX25_CQG_CHAN(MX25_CFG_INAUX2, \"inaux2\"),\n};\n\nstatic const char * const mx25_gcq_refp_names[] = {\n\t[MX25_ADC_REFP_YP] = \"yp\",\n\t[MX25_ADC_REFP_XP] = \"xp\",\n\t[MX25_ADC_REFP_INT] = \"int\",\n\t[MX25_ADC_REFP_EXT] = \"ext\",\n};\n\nstatic irqreturn_t mx25_gcq_irq(int irq, void *data)\n{\n\tstruct mx25_gcq_priv *priv = data;\n\tu32 stats;\n\n\tregmap_read(priv->regs, MX25_ADCQ_SR, &stats);\n\n\tif (stats & MX25_ADCQ_SR_EOQ) {\n\t\tregmap_update_bits(priv->regs, MX25_ADCQ_MR,\n\t\t\t\t   MX25_ADCQ_MR_EOQ_IRQ, MX25_ADCQ_MR_EOQ_IRQ);\n\t\tcomplete(&priv->completed);\n\t}\n\n\t \n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_FQS, 0);\n\n\t \n\tregmap_write(priv->regs, MX25_ADCQ_SR, MX25_ADCQ_SR_FRR |\n\t\t     MX25_ADCQ_SR_FUR | MX25_ADCQ_SR_FOR |\n\t\t     MX25_ADCQ_SR_EOQ | MX25_ADCQ_SR_PD);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mx25_gcq_get_raw_value(struct device *dev,\n\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t  struct mx25_gcq_priv *priv,\n\t\t\t\t  int *val)\n{\n\tlong timeout;\n\tu32 data;\n\n\t \n\tregmap_write(priv->regs, MX25_ADCQ_ITEM_7_0,\n\t\t     MX25_ADCQ_ITEM(0, chan->channel));\n\n\tregmap_update_bits(priv->regs, MX25_ADCQ_MR, MX25_ADCQ_MR_EOQ_IRQ, 0);\n\n\t \n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_FQS,\n\t\t\t   MX25_ADCQ_CR_FQS);\n\n\ttimeout = wait_for_completion_interruptible_timeout(\n\t\t&priv->completed, MX25_GCQ_TIMEOUT);\n\tif (timeout < 0) {\n\t\tdev_err(dev, \"ADC wait for measurement failed\\n\");\n\t\treturn timeout;\n\t} else if (timeout == 0) {\n\t\tdev_err(dev, \"ADC timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tregmap_read(priv->regs, MX25_ADCQ_FIFO, &data);\n\n\t*val = MX25_ADCQ_FIFO_DATA(data);\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int mx25_gcq_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int *val,\n\t\t\t     int *val2, long mask)\n{\n\tstruct mx25_gcq_priv *priv = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&priv->lock);\n\t\tret = mx25_gcq_get_raw_value(&indio_dev->dev, chan, priv, val);\n\t\tmutex_unlock(&priv->lock);\n\t\treturn ret;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = priv->channel_vref_mv[chan->channel];\n\t\t*val2 = 12;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info mx25_gcq_iio_info = {\n\t.read_raw = mx25_gcq_read_raw,\n};\n\nstatic const struct regmap_config mx25_gcq_regconfig = {\n\t.max_register = 0x5c,\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic int mx25_gcq_ext_regulator_setup(struct device *dev,\n\t\t\t\t\tstruct mx25_gcq_priv *priv, u32 refp)\n{\n\tchar reg_name[12];\n\tint ret;\n\n\tif (priv->vref[refp])\n\t\treturn 0;\n\n\tret = snprintf(reg_name, sizeof(reg_name), \"vref-%s\",\n\t\t       mx25_gcq_refp_names[refp]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->vref[refp] = devm_regulator_get_optional(dev, reg_name);\n\tif (IS_ERR(priv->vref[refp]))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->vref[refp]),\n\t\t\t\t     \"Error, trying to use external voltage reference without a %s regulator.\",\n\t\t\t\t     reg_name);\n\n\treturn 0;\n}\n\nstatic int mx25_gcq_setup_cfgs(struct platform_device *pdev,\n\t\t\t       struct mx25_gcq_priv *priv)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *child;\n\tstruct device *dev = &pdev->dev;\n\tint ret, i;\n\n\t \n\tfor (i = 0; i < MX25_NUM_CFGS; ++i)\n\t\tregmap_write(priv->regs, MX25_ADCQ_CFG(i),\n\t\t\t     MX25_ADCQ_CFG_YPLL_OFF |\n\t\t\t     MX25_ADCQ_CFG_XNUR_OFF |\n\t\t\t     MX25_ADCQ_CFG_XPUL_OFF |\n\t\t\t     MX25_ADCQ_CFG_REFP_INT |\n\t\t\t     MX25_ADCQ_CFG_IN(i) |\n\t\t\t     MX25_ADCQ_CFG_REFN_NGND2);\n\n\tfor_each_child_of_node(np, child) {\n\t\tu32 reg;\n\t\tu32 refp = MX25_ADCQ_CFG_REFP_INT;\n\t\tu32 refn = MX25_ADCQ_CFG_REFN_NGND2;\n\n\t\tret = of_property_read_u32(child, \"reg\", &reg);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to get reg property\\n\");\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (reg >= MX25_NUM_CFGS) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"reg value is greater than the number of available configuration registers\\n\");\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tof_property_read_u32(child, \"fsl,adc-refp\", &refp);\n\t\tof_property_read_u32(child, \"fsl,adc-refn\", &refn);\n\n\t\tswitch (refp) {\n\t\tcase MX25_ADC_REFP_EXT:\n\t\tcase MX25_ADC_REFP_XP:\n\t\tcase MX25_ADC_REFP_YP:\n\t\t\tret = mx25_gcq_ext_regulator_setup(&pdev->dev, priv, refp);\n\t\t\tif (ret) {\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tpriv->channel_vref_mv[reg] =\n\t\t\t\tregulator_get_voltage(priv->vref[refp]);\n\t\t\t \n\t\t\tpriv->channel_vref_mv[reg] /= 1000;\n\t\t\tbreak;\n\t\tcase MX25_ADC_REFP_INT:\n\t\t\tpriv->channel_vref_mv[reg] = 2500;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Invalid positive reference %d\\n\", refp);\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\trefp = MX25_ADCQ_CFG_REFP(refp);\n\t\trefn = MX25_ADCQ_CFG_REFN(refn);\n\n\t\tif ((refp & MX25_ADCQ_CFG_REFP_MASK) != refp) {\n\t\t\tdev_err(dev, \"Invalid fsl,adc-refp property value\\n\");\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((refn & MX25_ADCQ_CFG_REFN_MASK) != refn) {\n\t\t\tdev_err(dev, \"Invalid fsl,adc-refn property value\\n\");\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tregmap_update_bits(priv->regs, MX25_ADCQ_CFG(reg),\n\t\t\t\t   MX25_ADCQ_CFG_REFP_MASK |\n\t\t\t\t   MX25_ADCQ_CFG_REFN_MASK,\n\t\t\t\t   refp | refn);\n\t}\n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR,\n\t\t\t   MX25_ADCQ_CR_FRST | MX25_ADCQ_CR_QRST,\n\t\t\t   MX25_ADCQ_CR_FRST | MX25_ADCQ_CR_QRST);\n\n\tregmap_write(priv->regs, MX25_ADCQ_CR,\n\t\t     MX25_ADCQ_CR_PDMSK | MX25_ADCQ_CR_QSM_FQS);\n\n\treturn 0;\n}\n\nstatic int mx25_gcq_probe(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct mx25_gcq_priv *priv;\n\tstruct mx25_tsadc *tsadc = dev_get_drvdata(pdev->dev.parent);\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *mem;\n\tint ret;\n\tint i;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*priv));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tpriv = iio_priv(indio_dev);\n\n\tmem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mem))\n\t\treturn PTR_ERR(mem);\n\n\tpriv->regs = devm_regmap_init_mmio(dev, mem, &mx25_gcq_regconfig);\n\tif (IS_ERR(priv->regs)) {\n\t\tdev_err(dev, \"Failed to initialize regmap\\n\");\n\t\treturn PTR_ERR(priv->regs);\n\t}\n\n\tmutex_init(&priv->lock);\n\n\tinit_completion(&priv->completed);\n\n\tret = mx25_gcq_setup_cfgs(pdev, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i != 4; ++i) {\n\t\tif (!priv->vref[i])\n\t\t\tcontinue;\n\n\t\tret = regulator_enable(priv->vref[i]);\n\t\tif (ret)\n\t\t\tgoto err_regulator_disable;\n\t}\n\n\tpriv->clk = tsadc->clk;\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable clock\\n\");\n\t\tgoto err_vref_disable;\n\t}\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_clk_unprepare;\n\n\tpriv->irq = ret;\n\tret = request_irq(priv->irq, mx25_gcq_irq, 0, pdev->name, priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed requesting IRQ\\n\");\n\t\tgoto err_clk_unprepare;\n\t}\n\n\tindio_dev->channels = mx25_gcq_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mx25_gcq_channels);\n\tindio_dev->info = &mx25_gcq_iio_info;\n\tindio_dev->name = driver_name;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register iio device\\n\");\n\t\tgoto err_irq_free;\n\t}\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\treturn 0;\n\nerr_irq_free:\n\tfree_irq(priv->irq, priv);\nerr_clk_unprepare:\n\tclk_disable_unprepare(priv->clk);\nerr_vref_disable:\n\ti = 4;\nerr_regulator_disable:\n\tfor (; i-- > 0;) {\n\t\tif (priv->vref[i])\n\t\t\tregulator_disable(priv->vref[i]);\n\t}\n\treturn ret;\n}\n\nstatic int mx25_gcq_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct mx25_gcq_priv *priv = iio_priv(indio_dev);\n\tint i;\n\n\tiio_device_unregister(indio_dev);\n\tfree_irq(priv->irq, priv);\n\tclk_disable_unprepare(priv->clk);\n\tfor (i = 4; i-- > 0;) {\n\t\tif (priv->vref[i])\n\t\t\tregulator_disable(priv->vref[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mx25_gcq_ids[] = {\n\t{ .compatible = \"fsl,imx25-gcq\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mx25_gcq_ids);\n\nstatic struct platform_driver mx25_gcq_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"mx25-gcq\",\n\t\t.of_match_table = mx25_gcq_ids,\n\t},\n\t.probe\t\t= mx25_gcq_probe,\n\t.remove\t\t= mx25_gcq_remove,\n};\nmodule_platform_driver(mx25_gcq_driver);\n\nMODULE_DESCRIPTION(\"ADC driver for Freescale mx25\");\nMODULE_AUTHOR(\"Markus Pargmann <mpa@pengutronix.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}