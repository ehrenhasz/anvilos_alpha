{
  "module_name": "qcom-spmi-iadc.c",
  "hash_id": "dac1c6b26d907eda1d7aa7e3f8d3530a5f16c3273647dd6ef2aa30ebab4bcf53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/qcom-spmi-iadc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/iio/iio.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n \n#define IADC_REVISION2\t\t\t\t0x1\n#define IADC_REVISION2_SUPPORTED_IADC\t\t1\n\n#define IADC_PERPH_TYPE\t\t\t\t0x4\n#define IADC_PERPH_TYPE_ADC\t\t\t8\n\n#define IADC_PERPH_SUBTYPE\t\t\t0x5\n#define IADC_PERPH_SUBTYPE_IADC\t\t\t3\n\n#define IADC_STATUS1\t\t\t\t0x8\n#define IADC_STATUS1_OP_MODE\t\t\t4\n#define IADC_STATUS1_REQ_STS\t\t\tBIT(1)\n#define IADC_STATUS1_EOC\t\t\tBIT(0)\n#define IADC_STATUS1_REQ_STS_EOC_MASK\t\t0x3\n\n#define IADC_MODE_CTL\t\t\t\t0x40\n#define IADC_OP_MODE_SHIFT\t\t\t3\n#define IADC_OP_MODE_NORMAL\t\t\t0\n#define IADC_TRIM_EN\t\t\t\tBIT(0)\n\n#define IADC_EN_CTL1\t\t\t\t0x46\n#define IADC_EN_CTL1_SET\t\t\tBIT(7)\n\n#define IADC_CH_SEL_CTL\t\t\t\t0x48\n\n#define IADC_DIG_PARAM\t\t\t\t0x50\n#define IADC_DIG_DEC_RATIO_SEL_SHIFT\t\t2\n\n#define IADC_HW_SETTLE_DELAY\t\t\t0x51\n\n#define IADC_CONV_REQ\t\t\t\t0x52\n#define IADC_CONV_REQ_SET\t\t\tBIT(7)\n\n#define IADC_FAST_AVG_CTL\t\t\t0x5a\n#define IADC_FAST_AVG_EN\t\t\t0x5b\n#define IADC_FAST_AVG_EN_SET\t\t\tBIT(7)\n\n#define IADC_PERH_RESET_CTL3\t\t\t0xda\n#define IADC_FOLLOW_WARM_RB\t\t\tBIT(2)\n\n#define IADC_DATA\t\t\t\t0x60\t \n\n#define IADC_SEC_ACCESS\t\t\t\t0xd0\n#define IADC_SEC_ACCESS_DATA\t\t\t0xa5\n\n#define IADC_NOMINAL_RSENSE\t\t\t0xf4\n#define IADC_NOMINAL_RSENSE_SIGN_MASK\t\tBIT(7)\n\n#define IADC_REF_GAIN_MICRO_VOLTS\t\t17857\n\n#define IADC_INT_RSENSE_DEVIATION\t\t15625\t \n\n#define IADC_INT_RSENSE_IDEAL_VALUE\t\t10000\t \n#define IADC_INT_RSENSE_DEFAULT_VALUE\t\t7800\t \n#define IADC_INT_RSENSE_DEFAULT_GF\t\t9000\t \n#define IADC_INT_RSENSE_DEFAULT_SMIC\t\t9700\t \n\n#define IADC_CONV_TIME_MIN_US\t\t\t2000\n#define IADC_CONV_TIME_MAX_US\t\t\t2100\n\n#define IADC_DEF_PRESCALING\t\t\t0  \n#define IADC_DEF_DECIMATION\t\t\t0  \n#define IADC_DEF_HW_SETTLE_TIME\t\t\t0  \n#define IADC_DEF_AVG_SAMPLES\t\t\t0  \n\n \n#define IADC_INT_RSENSE\t\t\t\t0\n#define IADC_EXT_RSENSE\t\t\t\t1\n#define IADC_GAIN_17P857MV\t\t\t3\n#define IADC_EXT_OFFSET_CSP_CSN\t\t\t5\n#define IADC_INT_OFFSET_CSP2_CSN2\t\t6\n\n \nstruct iadc_chip {\n\tstruct regmap\t*regmap;\n\tstruct device\t*dev;\n\tu16\t\tbase;\n\tbool\t\tpoll_eoc;\n\tu32\t\trsense[2];\n\tu16\t\toffset[2];\n\tu16\t\tgain;\n\tstruct mutex\tlock;\n\tstruct completion complete;\n};\n\nstatic int iadc_read(struct iadc_chip *iadc, u16 offset, u8 *data)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(iadc->regmap, iadc->base + offset, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*data = val;\n\treturn 0;\n}\n\nstatic int iadc_write(struct iadc_chip *iadc, u16 offset, u8 data)\n{\n\treturn regmap_write(iadc->regmap, iadc->base + offset, data);\n}\n\nstatic int iadc_reset(struct iadc_chip *iadc)\n{\n\tu8 data;\n\tint ret;\n\n\tret = iadc_write(iadc, IADC_SEC_ACCESS, IADC_SEC_ACCESS_DATA);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iadc_read(iadc, IADC_PERH_RESET_CTL3, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iadc_write(iadc, IADC_SEC_ACCESS, IADC_SEC_ACCESS_DATA);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata |= IADC_FOLLOW_WARM_RB;\n\n\treturn iadc_write(iadc, IADC_PERH_RESET_CTL3, data);\n}\n\nstatic int iadc_set_state(struct iadc_chip *iadc, bool state)\n{\n\treturn iadc_write(iadc, IADC_EN_CTL1, state ? IADC_EN_CTL1_SET : 0);\n}\n\nstatic void iadc_status_show(struct iadc_chip *iadc)\n{\n\tu8 mode, sta1, chan, dig, en, req;\n\tint ret;\n\n\tret = iadc_read(iadc, IADC_MODE_CTL, &mode);\n\tif (ret < 0)\n\t\treturn;\n\n\tret = iadc_read(iadc, IADC_DIG_PARAM, &dig);\n\tif (ret < 0)\n\t\treturn;\n\n\tret = iadc_read(iadc, IADC_CH_SEL_CTL, &chan);\n\tif (ret < 0)\n\t\treturn;\n\n\tret = iadc_read(iadc, IADC_CONV_REQ, &req);\n\tif (ret < 0)\n\t\treturn;\n\n\tret = iadc_read(iadc, IADC_STATUS1, &sta1);\n\tif (ret < 0)\n\t\treturn;\n\n\tret = iadc_read(iadc, IADC_EN_CTL1, &en);\n\tif (ret < 0)\n\t\treturn;\n\n\tdev_err(iadc->dev,\n\t\t\"mode:%02x en:%02x chan:%02x dig:%02x req:%02x sta1:%02x\\n\",\n\t\tmode, en, chan, dig, req, sta1);\n}\n\nstatic int iadc_configure(struct iadc_chip *iadc, int channel)\n{\n\tu8 decim, mode;\n\tint ret;\n\n\t \n\tmode = (IADC_OP_MODE_NORMAL << IADC_OP_MODE_SHIFT) | IADC_TRIM_EN;\n\tret = iadc_write(iadc, IADC_MODE_CTL, mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = iadc_write(iadc, IADC_CH_SEL_CTL, channel);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdecim = IADC_DEF_DECIMATION << IADC_DIG_DEC_RATIO_SEL_SHIFT;\n\tret = iadc_write(iadc, IADC_DIG_PARAM, decim);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = iadc_write(iadc, IADC_HW_SETTLE_DELAY, IADC_DEF_HW_SETTLE_TIME);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iadc_write(iadc, IADC_FAST_AVG_CTL, IADC_DEF_AVG_SAMPLES);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (IADC_DEF_AVG_SAMPLES)\n\t\tret = iadc_write(iadc, IADC_FAST_AVG_EN, IADC_FAST_AVG_EN_SET);\n\telse\n\t\tret = iadc_write(iadc, IADC_FAST_AVG_EN, 0);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!iadc->poll_eoc)\n\t\treinit_completion(&iadc->complete);\n\n\tret = iadc_set_state(iadc, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn iadc_write(iadc, IADC_CONV_REQ, IADC_CONV_REQ_SET);\n}\n\nstatic int iadc_poll_wait_eoc(struct iadc_chip *iadc, unsigned int interval_us)\n{\n\tunsigned int count, retry;\n\tint ret;\n\tu8 sta1;\n\n\tretry = interval_us / IADC_CONV_TIME_MIN_US;\n\n\tfor (count = 0; count < retry; count++) {\n\t\tret = iadc_read(iadc, IADC_STATUS1, &sta1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tsta1 &= IADC_STATUS1_REQ_STS_EOC_MASK;\n\t\tif (sta1 == IADC_STATUS1_EOC)\n\t\t\treturn 0;\n\n\t\tusleep_range(IADC_CONV_TIME_MIN_US, IADC_CONV_TIME_MAX_US);\n\t}\n\n\tiadc_status_show(iadc);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int iadc_read_result(struct iadc_chip *iadc, u16 *data)\n{\n\treturn regmap_bulk_read(iadc->regmap, iadc->base + IADC_DATA, data, 2);\n}\n\nstatic int iadc_do_conversion(struct iadc_chip *iadc, int chan, u16 *data)\n{\n\tunsigned int wait;\n\tint ret;\n\n\tret = iadc_configure(iadc, chan);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\twait = BIT(IADC_DEF_AVG_SAMPLES) * IADC_CONV_TIME_MIN_US * 2;\n\n\tif (iadc->poll_eoc) {\n\t\tret = iadc_poll_wait_eoc(iadc, wait);\n\t} else {\n\t\tret = wait_for_completion_timeout(&iadc->complete,\n\t\t\tusecs_to_jiffies(wait));\n\t\tif (!ret)\n\t\t\tret = -ETIMEDOUT;\n\t\telse\n\t\t\t \n\t\t\tret = iadc_poll_wait_eoc(iadc, IADC_CONV_TIME_MIN_US);\n\t}\n\n\tif (!ret)\n\t\tret = iadc_read_result(iadc, data);\nexit:\n\tiadc_set_state(iadc, false);\n\tif (ret < 0)\n\t\tdev_err(iadc->dev, \"conversion failed\\n\");\n\n\treturn ret;\n}\n\nstatic int iadc_read_raw(struct iio_dev *indio_dev,\n\t\t\t struct iio_chan_spec const *chan,\n\t\t\t int *val, int *val2, long mask)\n{\n\tstruct iadc_chip *iadc = iio_priv(indio_dev);\n\ts32 isense_ua, vsense_uv;\n\tu16 adc_raw, vsense_raw;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&iadc->lock);\n\t\tret = iadc_do_conversion(iadc, chan->channel, &adc_raw);\n\t\tmutex_unlock(&iadc->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tvsense_raw = adc_raw - iadc->offset[chan->channel];\n\n\t\tvsense_uv = vsense_raw * IADC_REF_GAIN_MICRO_VOLTS;\n\t\tvsense_uv /= (s32)iadc->gain - iadc->offset[chan->channel];\n\n\t\tisense_ua = vsense_uv / iadc->rsense[chan->channel];\n\n\t\tdev_dbg(iadc->dev, \"off %d gain %d adc %d %duV I %duA\\n\",\n\t\t\tiadc->offset[chan->channel], iadc->gain,\n\t\t\tadc_raw, vsense_uv, isense_ua);\n\n\t\t*val = isense_ua;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = 1000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info iadc_info = {\n\t.read_raw = iadc_read_raw,\n};\n\nstatic irqreturn_t iadc_isr(int irq, void *dev_id)\n{\n\tstruct iadc_chip *iadc = dev_id;\n\n\tcomplete(&iadc->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int iadc_update_offset(struct iadc_chip *iadc)\n{\n\tint ret;\n\n\tret = iadc_do_conversion(iadc, IADC_GAIN_17P857MV, &iadc->gain);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iadc_do_conversion(iadc, IADC_INT_OFFSET_CSP2_CSN2,\n\t\t\t\t &iadc->offset[IADC_INT_RSENSE]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (iadc->gain == iadc->offset[IADC_INT_RSENSE]) {\n\t\tdev_err(iadc->dev, \"error: internal offset == gain %d\\n\",\n\t\t\tiadc->gain);\n\t\treturn -EINVAL;\n\t}\n\n\tret = iadc_do_conversion(iadc, IADC_EXT_OFFSET_CSP_CSN,\n\t\t\t\t &iadc->offset[IADC_EXT_RSENSE]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (iadc->gain == iadc->offset[IADC_EXT_RSENSE]) {\n\t\tdev_err(iadc->dev, \"error: external offset == gain %d\\n\",\n\t\t\tiadc->gain);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int iadc_version_check(struct iadc_chip *iadc)\n{\n\tu8 val;\n\tint ret;\n\n\tret = iadc_read(iadc, IADC_PERPH_TYPE, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val < IADC_PERPH_TYPE_ADC) {\n\t\tdev_err(iadc->dev, \"%d is not ADC\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tret = iadc_read(iadc, IADC_PERPH_SUBTYPE, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val < IADC_PERPH_SUBTYPE_IADC) {\n\t\tdev_err(iadc->dev, \"%d is not IADC\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tret = iadc_read(iadc, IADC_REVISION2, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val < IADC_REVISION2_SUPPORTED_IADC) {\n\t\tdev_err(iadc->dev, \"revision %d not supported\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int iadc_rsense_read(struct iadc_chip *iadc, struct device_node *node)\n{\n\tint ret, sign, int_sense;\n\tu8 deviation;\n\n\tret = of_property_read_u32(node, \"qcom,external-resistor-micro-ohms\",\n\t\t\t\t   &iadc->rsense[IADC_EXT_RSENSE]);\n\tif (ret < 0)\n\t\tiadc->rsense[IADC_EXT_RSENSE] = IADC_INT_RSENSE_IDEAL_VALUE;\n\n\tif (!iadc->rsense[IADC_EXT_RSENSE]) {\n\t\tdev_err(iadc->dev, \"external resistor can't be zero Ohms\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = iadc_read(iadc, IADC_NOMINAL_RSENSE, &deviation);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tsign = (deviation & IADC_NOMINAL_RSENSE_SIGN_MASK) ? -1 : 1;\n\n\tdeviation &= ~IADC_NOMINAL_RSENSE_SIGN_MASK;\n\n\t \n\tint_sense = IADC_INT_RSENSE_IDEAL_VALUE * 1000;\n\tint_sense += sign * deviation * IADC_INT_RSENSE_DEVIATION;\n\tint_sense /= 1000;  \n\n\tiadc->rsense[IADC_INT_RSENSE] = int_sense;\n\treturn 0;\n}\n\nstatic const struct iio_chan_spec iadc_channels[] = {\n\t{\n\t\t.type = IIO_CURRENT,\n\t\t.datasheet_name\t= \"INTERNAL_RSENSE\",\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.indexed = 1,\n\t},\n\t{\n\t\t.type = IIO_CURRENT,\n\t\t.datasheet_name\t= \"EXTERNAL_RSENSE\",\n\t\t.channel = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.indexed = 1,\n\t},\n};\n\nstatic int iadc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct iadc_chip *iadc;\n\tint ret, irq_eoc;\n\tu32 res;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*iadc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tiadc = iio_priv(indio_dev);\n\tiadc->dev = dev;\n\n\tiadc->regmap = dev_get_regmap(dev->parent, NULL);\n\tif (!iadc->regmap)\n\t\treturn -ENODEV;\n\n\tinit_completion(&iadc->complete);\n\tmutex_init(&iadc->lock);\n\n\tret = of_property_read_u32(node, \"reg\", &res);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\tiadc->base = res;\n\n\tret = iadc_version_check(iadc);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\tret = iadc_rsense_read(iadc, node);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\tdev_dbg(iadc->dev, \"sense resistors %d and %d micro Ohm\\n\",\n\t\tiadc->rsense[IADC_INT_RSENSE],\n\t\tiadc->rsense[IADC_EXT_RSENSE]);\n\n\tirq_eoc = platform_get_irq(pdev, 0);\n\tif (irq_eoc == -EPROBE_DEFER)\n\t\treturn irq_eoc;\n\n\tif (irq_eoc < 0)\n\t\tiadc->poll_eoc = true;\n\n\tret = iadc_reset(iadc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"reset failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!iadc->poll_eoc) {\n\t\tret = devm_request_irq(dev, irq_eoc, iadc_isr, 0,\n\t\t\t\t\t\"spmi-iadc\", iadc);\n\t\tif (!ret)\n\t\t\tenable_irq_wake(irq_eoc);\n\t\telse\n\t\t\treturn ret;\n\t} else {\n\t\tdevice_init_wakeup(iadc->dev, 1);\n\t}\n\n\tret = iadc_update_offset(iadc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed offset calibration\\n\");\n\t\treturn ret;\n\t}\n\n\tindio_dev->name = pdev->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &iadc_info;\n\tindio_dev->channels = iadc_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(iadc_channels);\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id iadc_match_table[] = {\n\t{ .compatible = \"qcom,spmi-iadc\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, iadc_match_table);\n\nstatic struct platform_driver iadc_driver = {\n\t.driver = {\n\t\t   .name = \"qcom-spmi-iadc\",\n\t\t   .of_match_table = iadc_match_table,\n\t},\n\t.probe = iadc_probe,\n};\n\nmodule_platform_driver(iadc_driver);\n\nMODULE_ALIAS(\"platform:qcom-spmi-iadc\");\nMODULE_DESCRIPTION(\"Qualcomm SPMI PMIC current ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Ivan T. Ivanov <iivanov@mm-sol.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}