{
  "module_name": "ti-tsc2046.c",
  "hash_id": "144eb6985274f31698c86fabb182520e338a469c1f71ece92f72762f6b0c0ec9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-tsc2046.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/units.h>\n\n#include <asm/unaligned.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger.h>\n\n \n\n#define TI_TSC2046_NAME\t\t\t\t\"tsc2046\"\n\n \n#define\tTI_TSC2046_MAX_SAMPLE_RATE\t\t125000\n#define\tTI_TSC2046_SAMPLE_BITS \\\n\tBITS_PER_TYPE(struct tsc2046_adc_atom)\n#define\tTI_TSC2046_MAX_CLK_FREQ \\\n\t(TI_TSC2046_MAX_SAMPLE_RATE * TI_TSC2046_SAMPLE_BITS)\n\n#define TI_TSC2046_SAMPLE_INTERVAL_US\t\t10000\n\n#define TI_TSC2046_START\t\t\tBIT(7)\n#define TI_TSC2046_ADDR\t\t\t\tGENMASK(6, 4)\n#define TI_TSC2046_ADDR_TEMP1\t\t\t7\n#define TI_TSC2046_ADDR_AUX\t\t\t6\n#define TI_TSC2046_ADDR_X\t\t\t5\n#define TI_TSC2046_ADDR_Z2\t\t\t4\n#define TI_TSC2046_ADDR_Z1\t\t\t3\n#define TI_TSC2046_ADDR_VBAT\t\t\t2\n#define TI_TSC2046_ADDR_Y\t\t\t1\n#define TI_TSC2046_ADDR_TEMP0\t\t\t0\n\n \n#define TI_TSC2046_8BIT_MODE\t\t\tBIT(3)\n\n \n#define TI_TSC2046_SER\t\t\t\tBIT(2)\n\n \n#define TI_TSC2046_PD1_VREF_ON\t\t\tBIT(1)\n#define TI_TSC2046_PD0_ADC_ON\t\t\tBIT(0)\n\n \n#define TI_TSC2046_DATA_12BIT\t\t\tGENMASK(14, 3)\n\n#define TI_TSC2046_MAX_CHAN\t\t\t8\n#define TI_TSC2046_MIN_POLL_CNT\t\t\t3\n#define TI_TSC2046_EXT_POLL_CNT\t\t\t3\n#define TI_TSC2046_POLL_CNT \\\n\t(TI_TSC2046_MIN_POLL_CNT + TI_TSC2046_EXT_POLL_CNT)\n#define TI_TSC2046_INT_VREF\t\t\t2500\n\n \nstruct tsc2046_adc_atom {\n\t \n\tu8 cmd;\n\t \n\t__be16 data;\n} __packed;\n\n \nstruct tsc2046_adc_group_layout {\n\t \n\tunsigned int offset;\n\t \n\tunsigned int count;\n\t \n\tunsigned int skip;\n};\n\nstruct tsc2046_adc_dcfg {\n\tconst struct iio_chan_spec *channels;\n\tunsigned int num_channels;\n};\n\nstruct tsc2046_adc_ch_cfg {\n\tunsigned int settling_time_us;\n\tunsigned int oversampling_ratio;\n};\n\nenum tsc2046_state {\n\tTSC2046_STATE_SHUTDOWN,\n\tTSC2046_STATE_STANDBY,\n\tTSC2046_STATE_POLL,\n\tTSC2046_STATE_POLL_IRQ_DISABLE,\n\tTSC2046_STATE_ENABLE_IRQ,\n};\n\nstruct tsc2046_adc_priv {\n\tstruct spi_device *spi;\n\tconst struct tsc2046_adc_dcfg *dcfg;\n\tstruct regulator *vref_reg;\n\n\tstruct iio_trigger *trig;\n\tstruct hrtimer trig_timer;\n\tenum tsc2046_state state;\n\tint poll_cnt;\n\tspinlock_t state_lock;\n\n\tstruct spi_transfer xfer;\n\tstruct spi_message msg;\n\n\tstruct {\n\t\t \n\t\tu16 data[TI_TSC2046_MAX_CHAN];\n\t\t \n\t\ts64 ts __aligned(8);\n\t} scan_buf;\n\n\t \n\tstruct mutex slock;\n\tstruct tsc2046_adc_group_layout l[TI_TSC2046_MAX_CHAN];\n\tstruct tsc2046_adc_atom *rx;\n\tstruct tsc2046_adc_atom *tx;\n\n\tunsigned int count;\n\tunsigned int groups;\n\tu32 effective_speed_hz;\n\tu32 scan_interval_us;\n\tu32 time_per_scan_us;\n\tu32 time_per_bit_ns;\n\tunsigned int vref_mv;\n\n\tstruct tsc2046_adc_ch_cfg ch_cfg[TI_TSC2046_MAX_CHAN];\n};\n\n#define TI_TSC2046_V_CHAN(index, bits, name)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = index,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.datasheet_name = \"#name\",\t\t\t\t\\\n\t.scan_index = index,\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = bits,\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.endianness = IIO_CPU,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\n#define DECLARE_TI_TSC2046_8_CHANNELS(name, bits) \\\nconst struct iio_chan_spec name ## _channels[] = { \\\n\tTI_TSC2046_V_CHAN(0, bits, TEMP0), \\\n\tTI_TSC2046_V_CHAN(1, bits, Y), \\\n\tTI_TSC2046_V_CHAN(2, bits, VBAT), \\\n\tTI_TSC2046_V_CHAN(3, bits, Z1), \\\n\tTI_TSC2046_V_CHAN(4, bits, Z2), \\\n\tTI_TSC2046_V_CHAN(5, bits, X), \\\n\tTI_TSC2046_V_CHAN(6, bits, AUX), \\\n\tTI_TSC2046_V_CHAN(7, bits, TEMP1), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(8), \\\n}\n\nstatic DECLARE_TI_TSC2046_8_CHANNELS(tsc2046_adc, 12);\n\nstatic const struct tsc2046_adc_dcfg tsc2046_adc_dcfg_tsc2046e = {\n\t.channels = tsc2046_adc_channels,\n\t.num_channels = ARRAY_SIZE(tsc2046_adc_channels),\n};\n\n \nstatic unsigned int tsc2046_adc_time_to_count(struct tsc2046_adc_priv *priv,\n\t\t\t\t\t      unsigned long time)\n{\n\tunsigned int bit_count, sample_count;\n\n\tbit_count = DIV_ROUND_UP(time * NSEC_PER_USEC, priv->time_per_bit_ns);\n\tsample_count = DIV_ROUND_UP(bit_count, TI_TSC2046_SAMPLE_BITS);\n\n\tdev_dbg(&priv->spi->dev, \"Effective speed %u, time per bit: %u, count bits: %u, count samples: %u\\n\",\n\t\tpriv->effective_speed_hz, priv->time_per_bit_ns,\n\t\tbit_count, sample_count);\n\n\treturn sample_count;\n}\n\nstatic u8 tsc2046_adc_get_cmd(struct tsc2046_adc_priv *priv, int ch_idx,\n\t\t\t      bool keep_power)\n{\n\tu32 pd;\n\n\t \n\tif (keep_power)\n\t\tpd = TI_TSC2046_PD0_ADC_ON;\n\telse\n\t\tpd = 0;\n\n\tswitch (ch_idx) {\n\tcase TI_TSC2046_ADDR_TEMP1:\n\tcase TI_TSC2046_ADDR_AUX:\n\tcase TI_TSC2046_ADDR_VBAT:\n\tcase TI_TSC2046_ADDR_TEMP0:\n\t\tpd |= TI_TSC2046_SER;\n\t\tif (!priv->vref_reg)\n\t\t\tpd |= TI_TSC2046_PD1_VREF_ON;\n\t}\n\n\treturn TI_TSC2046_START | FIELD_PREP(TI_TSC2046_ADDR, ch_idx) | pd;\n}\n\nstatic u16 tsc2046_adc_get_value(struct tsc2046_adc_atom *buf)\n{\n\treturn FIELD_GET(TI_TSC2046_DATA_12BIT, get_unaligned_be16(&buf->data));\n}\n\nstatic int tsc2046_adc_read_one(struct tsc2046_adc_priv *priv, int ch_idx,\n\t\t\t\tu32 *effective_speed_hz)\n{\n\tstruct tsc2046_adc_ch_cfg *ch = &priv->ch_cfg[ch_idx];\n\tstruct tsc2046_adc_atom *rx_buf, *tx_buf;\n\tunsigned int val, val_normalized = 0;\n\tint ret, i, count_skip = 0, max_count;\n\tstruct spi_transfer xfer;\n\tstruct spi_message msg;\n\tu8 cmd;\n\n\tif (!effective_speed_hz) {\n\t\tcount_skip = tsc2046_adc_time_to_count(priv, ch->settling_time_us);\n\t\tmax_count = count_skip + ch->oversampling_ratio;\n\t} else {\n\t\tmax_count = 1;\n\t}\n\n\tif (sizeof(*tx_buf) * max_count > PAGE_SIZE)\n\t\treturn -ENOSPC;\n\n\ttx_buf = kcalloc(max_count, sizeof(*tx_buf), GFP_KERNEL);\n\tif (!tx_buf)\n\t\treturn -ENOMEM;\n\n\trx_buf = kcalloc(max_count, sizeof(*rx_buf), GFP_KERNEL);\n\tif (!rx_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto free_tx;\n\t}\n\n\t \n\tcmd = tsc2046_adc_get_cmd(priv, ch_idx, true);\n\n\tfor (i = 0; i < max_count - 1; i++)\n\t\ttx_buf[i].cmd = cmd;\n\n\t \n\ttx_buf[i].cmd = tsc2046_adc_get_cmd(priv, ch_idx, false);\n\n\tmemset(&xfer, 0, sizeof(xfer));\n\txfer.tx_buf = tx_buf;\n\txfer.rx_buf = rx_buf;\n\txfer.len = sizeof(*tx_buf) * max_count;\n\tspi_message_init_with_transfers(&msg, &xfer, 1);\n\n\t \n\tret = spi_sync(priv->spi, &msg);\n\tif (ret) {\n\t\tdev_err_ratelimited(&priv->spi->dev, \"SPI transfer failed %pe\\n\",\n\t\t\t\t    ERR_PTR(ret));\n\t\tgoto free_bufs;\n\t}\n\n\tif (effective_speed_hz)\n\t\t*effective_speed_hz = xfer.effective_speed_hz;\n\n\tfor (i = 0; i < max_count - count_skip; i++) {\n\t\tval = tsc2046_adc_get_value(&rx_buf[count_skip + i]);\n\t\tval_normalized += val;\n\t}\n\n\tret = DIV_ROUND_UP(val_normalized, max_count - count_skip);\n\nfree_bufs:\n\tkfree(rx_buf);\nfree_tx:\n\tkfree(tx_buf);\n\n\treturn ret;\n}\n\nstatic size_t tsc2046_adc_group_set_layout(struct tsc2046_adc_priv *priv,\n\t\t\t\t\t   unsigned int group,\n\t\t\t\t\t   unsigned int ch_idx)\n{\n\tstruct tsc2046_adc_ch_cfg *ch = &priv->ch_cfg[ch_idx];\n\tstruct tsc2046_adc_group_layout *cur;\n\tunsigned int max_count, count_skip;\n\tunsigned int offset = 0;\n\n\tif (group)\n\t\toffset = priv->l[group - 1].offset + priv->l[group - 1].count;\n\n\tcount_skip = tsc2046_adc_time_to_count(priv, ch->settling_time_us);\n\tmax_count = count_skip + ch->oversampling_ratio;\n\n\tcur = &priv->l[group];\n\tcur->offset = offset;\n\tcur->count = max_count;\n\tcur->skip = count_skip;\n\n\treturn sizeof(*priv->tx) * max_count;\n}\n\nstatic void tsc2046_adc_group_set_cmd(struct tsc2046_adc_priv *priv,\n\t\t\t\t      unsigned int group, int ch_idx)\n{\n\tstruct tsc2046_adc_group_layout *l = &priv->l[group];\n\tunsigned int i;\n\tu8 cmd;\n\n\t \n\tcmd = tsc2046_adc_get_cmd(priv, ch_idx, true);\n\n\tfor (i = 0; i < l->count - 1; i++)\n\t\tpriv->tx[l->offset + i].cmd = cmd;\n\n\t \n\tpriv->tx[l->offset + i].cmd = tsc2046_adc_get_cmd(priv, ch_idx, false);\n}\n\nstatic u16 tsc2046_adc_get_val(struct tsc2046_adc_priv *priv, int group)\n{\n\tstruct tsc2046_adc_group_layout *l;\n\tunsigned int val, val_normalized = 0;\n\tint valid_count, i;\n\n\tl = &priv->l[group];\n\tvalid_count = l->count - l->skip;\n\n\tfor (i = 0; i < valid_count; i++) {\n\t\tval = tsc2046_adc_get_value(&priv->rx[l->offset + l->skip + i]);\n\t\tval_normalized += val;\n\t}\n\n\treturn DIV_ROUND_UP(val_normalized, valid_count);\n}\n\nstatic int tsc2046_adc_scan(struct iio_dev *indio_dev)\n{\n\tstruct tsc2046_adc_priv *priv = iio_priv(indio_dev);\n\tstruct device *dev = &priv->spi->dev;\n\tint group;\n\tint ret;\n\n\tret = spi_sync(priv->spi, &priv->msg);\n\tif (ret < 0) {\n\t\tdev_err_ratelimited(dev, \"SPI transfer failed: %pe\\n\", ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tfor (group = 0; group < priv->groups; group++)\n\t\tpriv->scan_buf.data[group] = tsc2046_adc_get_val(priv, group);\n\n\tret = iio_push_to_buffers_with_timestamp(indio_dev, &priv->scan_buf,\n\t\t\t\t\t\t iio_get_time_ns(indio_dev));\n\t \n\tif (ret < 0 && ret != -EBUSY) {\n\t\tdev_err_ratelimited(dev, \"Failed to push scan buffer %pe\\n\",\n\t\t\t\t    ERR_PTR(ret));\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t tsc2046_adc_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct tsc2046_adc_priv *priv = iio_priv(indio_dev);\n\n\tmutex_lock(&priv->slock);\n\ttsc2046_adc_scan(indio_dev);\n\tmutex_unlock(&priv->slock);\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tsc2046_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long m)\n{\n\tstruct tsc2046_adc_priv *priv = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = tsc2046_adc_read_one(priv, chan->channel, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*val = priv->vref_mv;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int tsc2046_adc_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t\tconst unsigned long *active_scan_mask)\n{\n\tstruct tsc2046_adc_priv *priv = iio_priv(indio_dev);\n\tunsigned int ch_idx, group = 0;\n\tsize_t size;\n\n\tmutex_lock(&priv->slock);\n\n\tsize = 0;\n\tfor_each_set_bit(ch_idx, active_scan_mask, ARRAY_SIZE(priv->l)) {\n\t\tsize += tsc2046_adc_group_set_layout(priv, group, ch_idx);\n\t\ttsc2046_adc_group_set_cmd(priv, group, ch_idx);\n\t\tgroup++;\n\t}\n\n\tpriv->groups = group;\n\tpriv->xfer.len = size;\n\tpriv->time_per_scan_us = size * 8 * priv->time_per_bit_ns / NSEC_PER_USEC;\n\n\tif (priv->scan_interval_us < priv->time_per_scan_us)\n\t\tdev_warn(&priv->spi->dev, \"The scan interval (%d) is less then calculated scan time (%d)\\n\",\n\t\t\t priv->scan_interval_us, priv->time_per_scan_us);\n\n\tmutex_unlock(&priv->slock);\n\n\treturn 0;\n}\n\nstatic const struct iio_info tsc2046_adc_info = {\n\t.read_raw\t  = tsc2046_adc_read_raw,\n\t.update_scan_mode = tsc2046_adc_update_scan_mode,\n};\n\nstatic enum hrtimer_restart tsc2046_adc_timer(struct hrtimer *hrtimer)\n{\n\tstruct tsc2046_adc_priv *priv = container_of(hrtimer,\n\t\t\t\t\t\t     struct tsc2046_adc_priv,\n\t\t\t\t\t\t     trig_timer);\n\tunsigned long flags;\n\n\t \n\n\tspin_lock_irqsave(&priv->state_lock, flags);\n\tswitch (priv->state) {\n\tcase TSC2046_STATE_ENABLE_IRQ:\n\t\tif (priv->poll_cnt < TI_TSC2046_POLL_CNT) {\n\t\t\tpriv->poll_cnt++;\n\t\t\thrtimer_start(&priv->trig_timer,\n\t\t\t\t      ns_to_ktime(priv->scan_interval_us *\n\t\t\t\t\t\t  NSEC_PER_USEC),\n\t\t\t\t      HRTIMER_MODE_REL_SOFT);\n\n\t\t\tif (priv->poll_cnt >= TI_TSC2046_MIN_POLL_CNT) {\n\t\t\t\tpriv->state = TSC2046_STATE_POLL_IRQ_DISABLE;\n\t\t\t\tenable_irq(priv->spi->irq);\n\t\t\t} else {\n\t\t\t\tpriv->state = TSC2046_STATE_POLL;\n\t\t\t}\n\t\t} else {\n\t\t\tpriv->state = TSC2046_STATE_STANDBY;\n\t\t\tenable_irq(priv->spi->irq);\n\t\t}\n\t\tbreak;\n\tcase TSC2046_STATE_POLL_IRQ_DISABLE:\n\t\tdisable_irq_nosync(priv->spi->irq);\n\t\tfallthrough;\n\tcase TSC2046_STATE_POLL:\n\t\tpriv->state = TSC2046_STATE_ENABLE_IRQ;\n\t\t \n\t\tiio_trigger_poll(priv->trig);\n\t\tbreak;\n\tcase TSC2046_STATE_SHUTDOWN:\n\t\tbreak;\n\tcase TSC2046_STATE_STANDBY:\n\t\tfallthrough;\n\tdefault:\n\t\tdev_warn(&priv->spi->dev, \"Got unexpected state: %i\\n\",\n\t\t\t priv->state);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&priv->state_lock, flags);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic irqreturn_t tsc2046_adc_irq(int irq, void *dev_id)\n{\n\tstruct iio_dev *indio_dev = dev_id;\n\tstruct tsc2046_adc_priv *priv = iio_priv(indio_dev);\n\tunsigned long flags;\n\n\thrtimer_try_to_cancel(&priv->trig_timer);\n\n\tspin_lock_irqsave(&priv->state_lock, flags);\n\tif (priv->state != TSC2046_STATE_SHUTDOWN) {\n\t\tpriv->state = TSC2046_STATE_ENABLE_IRQ;\n\t\tpriv->poll_cnt = 0;\n\n\t\t \n\t\tdisable_irq_nosync(priv->spi->irq);\n\t\tiio_trigger_poll(priv->trig);\n\t}\n\tspin_unlock_irqrestore(&priv->state_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void tsc2046_adc_reenable_trigger(struct iio_trigger *trig)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct tsc2046_adc_priv *priv = iio_priv(indio_dev);\n\tktime_t tim;\n\n\t \n\ttim = ns_to_ktime((priv->scan_interval_us - priv->time_per_scan_us) *\n\t\t\t  NSEC_PER_USEC);\n\thrtimer_start(&priv->trig_timer, tim, HRTIMER_MODE_REL_SOFT);\n}\n\nstatic int tsc2046_adc_set_trigger_state(struct iio_trigger *trig, bool enable)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct tsc2046_adc_priv *priv = iio_priv(indio_dev);\n\tunsigned long flags;\n\n\tif (enable) {\n\t\tspin_lock_irqsave(&priv->state_lock, flags);\n\t\tif (priv->state == TSC2046_STATE_SHUTDOWN) {\n\t\t\tpriv->state = TSC2046_STATE_STANDBY;\n\t\t\tenable_irq(priv->spi->irq);\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->state_lock, flags);\n\t} else {\n\t\tspin_lock_irqsave(&priv->state_lock, flags);\n\n\t\tif (priv->state == TSC2046_STATE_STANDBY ||\n\t\t    priv->state == TSC2046_STATE_POLL_IRQ_DISABLE)\n\t\t\tdisable_irq_nosync(priv->spi->irq);\n\n\t\tpriv->state = TSC2046_STATE_SHUTDOWN;\n\t\tspin_unlock_irqrestore(&priv->state_lock, flags);\n\n\t\thrtimer_cancel(&priv->trig_timer);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iio_trigger_ops tsc2046_adc_trigger_ops = {\n\t.set_trigger_state = tsc2046_adc_set_trigger_state,\n\t.reenable = tsc2046_adc_reenable_trigger,\n};\n\nstatic int tsc2046_adc_setup_spi_msg(struct tsc2046_adc_priv *priv)\n{\n\tunsigned int ch_idx;\n\tsize_t size;\n\tint ret;\n\n\t \n\tret = tsc2046_adc_read_one(priv, TI_TSC2046_ADDR_TEMP0,\n\t\t\t\t   &priv->effective_speed_hz);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!priv->effective_speed_hz)\n\t\tpriv->effective_speed_hz = priv->spi->max_speed_hz;\n\n\n\tpriv->scan_interval_us = TI_TSC2046_SAMPLE_INTERVAL_US;\n\tpriv->time_per_bit_ns = DIV_ROUND_UP(NSEC_PER_SEC,\n\t\t\t\t\t     priv->effective_speed_hz);\n\n\t \n\tsize = 0;\n\tfor (ch_idx = 0; ch_idx < ARRAY_SIZE(priv->l); ch_idx++)\n\t\tsize += tsc2046_adc_group_set_layout(priv, ch_idx, ch_idx);\n\n\tif (size > PAGE_SIZE) {\n\t\tdev_err(&priv->spi->dev,\n\t\t\t\"Calculated scan buffer is too big. Try to reduce spi-max-frequency, settling-time-us or oversampling-ratio\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tpriv->tx = devm_kzalloc(&priv->spi->dev, size, GFP_KERNEL);\n\tif (!priv->tx)\n\t\treturn -ENOMEM;\n\n\tpriv->rx = devm_kzalloc(&priv->spi->dev, size, GFP_KERNEL);\n\tif (!priv->rx)\n\t\treturn -ENOMEM;\n\n\tpriv->xfer.tx_buf = priv->tx;\n\tpriv->xfer.rx_buf = priv->rx;\n\tpriv->xfer.len = size;\n\tspi_message_init_with_transfers(&priv->msg, &priv->xfer, 1);\n\n\treturn 0;\n}\n\nstatic void tsc2046_adc_parse_fwnode(struct tsc2046_adc_priv *priv)\n{\n\tstruct fwnode_handle *child;\n\tstruct device *dev = &priv->spi->dev;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->ch_cfg); i++) {\n\t\tpriv->ch_cfg[i].settling_time_us = 1;\n\t\tpriv->ch_cfg[i].oversampling_ratio = 1;\n\t}\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tu32 stl, overs, reg;\n\t\tint ret;\n\n\t\tret = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"invalid reg on %pfw, err: %pe\\n\", child,\n\t\t\t\tERR_PTR(ret));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (reg >= ARRAY_SIZE(priv->ch_cfg)) {\n\t\t\tdev_err(dev, \"%pfw: Unsupported reg value: %i, max supported is: %zu.\\n\",\n\t\t\t\tchild, reg, ARRAY_SIZE(priv->ch_cfg));\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = fwnode_property_read_u32(child, \"settling-time-us\", &stl);\n\t\tif (!ret)\n\t\t\tpriv->ch_cfg[reg].settling_time_us = stl;\n\n\t\tret = fwnode_property_read_u32(child, \"oversampling-ratio\",\n\t\t\t\t\t       &overs);\n\t\tif (!ret)\n\t\t\tpriv->ch_cfg[reg].oversampling_ratio = overs;\n\t}\n}\n\nstatic void tsc2046_adc_regulator_disable(void *data)\n{\n\tstruct tsc2046_adc_priv *priv = data;\n\n\tregulator_disable(priv->vref_reg);\n}\n\nstatic int tsc2046_adc_configure_regulator(struct tsc2046_adc_priv *priv)\n{\n\tstruct device *dev = &priv->spi->dev;\n\tint ret;\n\n\tpriv->vref_reg = devm_regulator_get_optional(dev, \"vref\");\n\tif (IS_ERR(priv->vref_reg)) {\n\t\t \n\t\tif (PTR_ERR(priv->vref_reg) != -ENODEV)\n\t\t\treturn PTR_ERR(priv->vref_reg);\n\t\tpriv->vref_reg = NULL;\n\t}\n\tif (!priv->vref_reg) {\n\t\t \n\t\tpriv->vref_mv = TI_TSC2046_INT_VREF;\n\t\treturn 0;\n\t}\n\n\tret = regulator_enable(priv->vref_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, tsc2046_adc_regulator_disable,\n\t\t\t\t       priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_get_voltage(priv->vref_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->vref_mv = ret / MILLI;\n\n\treturn 0;\n}\n\nstatic int tsc2046_adc_probe(struct spi_device *spi)\n{\n\tconst struct tsc2046_adc_dcfg *dcfg;\n\tstruct device *dev = &spi->dev;\n\tstruct tsc2046_adc_priv *priv;\n\tstruct iio_dev *indio_dev;\n\tstruct iio_trigger *trig;\n\tint ret;\n\n\tif (spi->max_speed_hz > TI_TSC2046_MAX_CLK_FREQ) {\n\t\tdev_err(dev, \"SPI max_speed_hz is too high: %d Hz. Max supported freq is %zu Hz\\n\",\n\t\t\tspi->max_speed_hz, TI_TSC2046_MAX_CLK_FREQ);\n\t\treturn -EINVAL;\n\t}\n\n\tdcfg = device_get_match_data(dev);\n\tif (!dcfg) {\n\t\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\n\t\tdcfg = (const struct tsc2046_adc_dcfg *)id->driver_data;\n\t}\n\tif (!dcfg)\n\t\treturn -EINVAL;\n\n\tspi->bits_per_word = 8;\n\tspi->mode &= ~SPI_MODE_X_MASK;\n\tspi->mode |= SPI_MODE_0;\n\tret = spi_setup(spi);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Error in SPI setup\\n\");\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*priv));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tpriv = iio_priv(indio_dev);\n\tpriv->dcfg = dcfg;\n\n\tpriv->spi = spi;\n\n\tindio_dev->name = TI_TSC2046_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = dcfg->channels;\n\tindio_dev->num_channels = dcfg->num_channels;\n\tindio_dev->info = &tsc2046_adc_info;\n\n\tret = tsc2046_adc_configure_regulator(priv);\n\tif (ret)\n\t\treturn ret;\n\n\ttsc2046_adc_parse_fwnode(priv);\n\n\tret = tsc2046_adc_setup_spi_msg(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&priv->slock);\n\n\tret = devm_request_irq(dev, spi->irq, &tsc2046_adc_irq,\n\t\t\t       IRQF_NO_AUTOEN, indio_dev->name, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\ttrig = devm_iio_trigger_alloc(dev, \"touchscreen-%s\", indio_dev->name);\n\tif (!trig)\n\t\treturn -ENOMEM;\n\n\tpriv->trig = trig;\n\tiio_trigger_set_drvdata(trig, indio_dev);\n\ttrig->ops = &tsc2046_adc_trigger_ops;\n\n\tspin_lock_init(&priv->state_lock);\n\tpriv->state = TSC2046_STATE_SHUTDOWN;\n\thrtimer_init(&priv->trig_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL_SOFT);\n\tpriv->trig_timer.function = tsc2046_adc_timer;\n\n\tret = devm_iio_trigger_register(dev, trig);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register trigger\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,\n\t\t\t\t\t      &tsc2046_adc_trigger_handler, NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to setup triggered buffer\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tindio_dev->trig = iio_trigger_get(priv->trig);\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id ads7950_of_table[] = {\n\t{ .compatible = \"ti,tsc2046e-adc\", .data = &tsc2046_adc_dcfg_tsc2046e },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ads7950_of_table);\n\nstatic const struct spi_device_id tsc2046_adc_spi_ids[] = {\n\t{ \"tsc2046e-adc\", (unsigned long)&tsc2046_adc_dcfg_tsc2046e },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, tsc2046_adc_spi_ids);\n\nstatic struct spi_driver tsc2046_adc_driver = {\n\t.driver = {\n\t\t.name = \"tsc2046\",\n\t\t.of_match_table = ads7950_of_table,\n\t},\n\t.id_table = tsc2046_adc_spi_ids,\n\t.probe = tsc2046_adc_probe,\n};\nmodule_spi_driver(tsc2046_adc_driver);\n\nMODULE_AUTHOR(\"Oleksij Rempel <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"TI TSC2046 ADC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}