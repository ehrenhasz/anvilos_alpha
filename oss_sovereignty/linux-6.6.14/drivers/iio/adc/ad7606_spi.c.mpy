{
  "module_name": "ad7606_spi.c",
  "hash_id": "a952d1f310708d2e532e399ceaa1e87986188a6de4ae20548b8783f66ee34942",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7606_spi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <linux/types.h>\n#include <linux/err.h>\n\n#include <linux/iio/iio.h>\n#include \"ad7606.h\"\n\n#define MAX_SPI_FREQ_HZ\t\t23500000\t \n\n#define AD7616_CONFIGURATION_REGISTER\t0x02\n#define AD7616_OS_MASK\t\t\tGENMASK(4, 2)\n#define AD7616_BURST_MODE\t\tBIT(6)\n#define AD7616_SEQEN_MODE\t\tBIT(5)\n#define AD7616_RANGE_CH_A_ADDR_OFF\t0x04\n#define AD7616_RANGE_CH_B_ADDR_OFF\t0x06\n \n#define AD7616_RANGE_CH_ADDR(ch)\t((ch) >> 2)\n \n#define AD7616_RANGE_CH_MSK(ch)\t\t(0b11 << (((ch) & 0b11) * 2))\n#define AD7616_RANGE_CH_MODE(ch, mode)\t((mode) << ((((ch) & 0b11)) * 2))\n\n#define AD7606_CONFIGURATION_REGISTER\t0x02\n#define AD7606_SINGLE_DOUT\t\t0x00\n\n \n#define AD7606_RANGE_CH_MSK(ch)\t\t(GENMASK(3, 0) << (4 * ((ch) & 0x1)))\n#define AD7606_RANGE_CH_MODE(ch, mode)\t\\\n\t((GENMASK(3, 0) & mode) << (4 * ((ch) & 0x1)))\n#define AD7606_RANGE_CH_ADDR(ch)\t(0x03 + ((ch) >> 1))\n#define AD7606_OS_MODE\t\t\t0x08\n\nstatic const struct iio_chan_spec ad7616_sw_channels[] = {\n\tIIO_CHAN_SOFT_TIMESTAMP(16),\n\tAD7616_CHANNEL(0),\n\tAD7616_CHANNEL(1),\n\tAD7616_CHANNEL(2),\n\tAD7616_CHANNEL(3),\n\tAD7616_CHANNEL(4),\n\tAD7616_CHANNEL(5),\n\tAD7616_CHANNEL(6),\n\tAD7616_CHANNEL(7),\n\tAD7616_CHANNEL(8),\n\tAD7616_CHANNEL(9),\n\tAD7616_CHANNEL(10),\n\tAD7616_CHANNEL(11),\n\tAD7616_CHANNEL(12),\n\tAD7616_CHANNEL(13),\n\tAD7616_CHANNEL(14),\n\tAD7616_CHANNEL(15),\n};\n\nstatic const struct iio_chan_spec ad7606b_sw_channels[] = {\n\tIIO_CHAN_SOFT_TIMESTAMP(8),\n\tAD7616_CHANNEL(0),\n\tAD7616_CHANNEL(1),\n\tAD7616_CHANNEL(2),\n\tAD7616_CHANNEL(3),\n\tAD7616_CHANNEL(4),\n\tAD7616_CHANNEL(5),\n\tAD7616_CHANNEL(6),\n\tAD7616_CHANNEL(7),\n};\n\nstatic const unsigned int ad7606B_oversampling_avail[9] = {\n\t1, 2, 4, 8, 16, 32, 64, 128, 256\n};\n\nstatic u16 ad7616_spi_rd_wr_cmd(int addr, char isWriteOp)\n{\n\t \n\treturn ((addr & 0x7F) << 1) | ((isWriteOp & 0x1) << 7);\n}\n\nstatic u16 ad7606B_spi_rd_wr_cmd(int addr, char is_write_op)\n{\n\t \n\treturn (addr & 0x3F) | (((~is_write_op) & 0x1) << 6);\n}\n\nstatic int ad7606_spi_read_block(struct device *dev,\n\t\t\t\t int count, void *buf)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tint i, ret;\n\tunsigned short *data = buf;\n\t__be16 *bdata = buf;\n\n\tret = spi_read(spi, buf, count * 2);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"SPI read error\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < count; i++)\n\t\tdata[i] = be16_to_cpu(bdata[i]);\n\n\treturn 0;\n}\n\nstatic int ad7606_spi_reg_read(struct ad7606_state *st, unsigned int addr)\n{\n\tstruct spi_device *spi = to_spi_device(st->dev);\n\tstruct spi_transfer t[] = {\n\t\t{\n\t\t\t.tx_buf = &st->d16[0],\n\t\t\t.len = 2,\n\t\t\t.cs_change = 0,\n\t\t}, {\n\t\t\t.rx_buf = &st->d16[1],\n\t\t\t.len = 2,\n\t\t},\n\t};\n\tint ret;\n\n\tst->d16[0] = cpu_to_be16(st->bops->rd_wr_cmd(addr, 0) << 8);\n\n\tret = spi_sync_transfer(spi, t, ARRAY_SIZE(t));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn be16_to_cpu(st->d16[1]);\n}\n\nstatic int ad7606_spi_reg_write(struct ad7606_state *st,\n\t\t\t\tunsigned int addr,\n\t\t\t\tunsigned int val)\n{\n\tstruct spi_device *spi = to_spi_device(st->dev);\n\n\tst->d16[0] = cpu_to_be16((st->bops->rd_wr_cmd(addr, 1) << 8) |\n\t\t\t\t  (val & 0x1FF));\n\n\treturn spi_write(spi, &st->d16[0], sizeof(st->d16[0]));\n}\n\nstatic int ad7606_spi_write_mask(struct ad7606_state *st,\n\t\t\t\t unsigned int addr,\n\t\t\t\t unsigned long mask,\n\t\t\t\t unsigned int val)\n{\n\tint readval;\n\n\treadval = st->bops->reg_read(st, addr);\n\tif (readval < 0)\n\t\treturn readval;\n\n\treadval &= ~mask;\n\treadval |= val;\n\n\treturn st->bops->reg_write(st, addr, readval);\n}\n\nstatic int ad7616_write_scale_sw(struct iio_dev *indio_dev, int ch, int val)\n{\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\tunsigned int ch_addr, mode, ch_index;\n\n\n\t \n\tch_index = ch >> 1;\n\n\tch_addr = AD7616_RANGE_CH_ADDR(ch_index);\n\n\tif ((ch & 0x1) == 0)  \n\t\tch_addr += AD7616_RANGE_CH_A_ADDR_OFF;\n\telse\t \n\t\tch_addr += AD7616_RANGE_CH_B_ADDR_OFF;\n\n\t \n\tmode = AD7616_RANGE_CH_MODE(ch_index, ((val + 1) & 0b11));\n\treturn st->bops->write_mask(st, ch_addr, AD7616_RANGE_CH_MSK(ch_index),\n\t\t\t\t     mode);\n}\n\nstatic int ad7616_write_os_sw(struct iio_dev *indio_dev, int val)\n{\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\n\treturn st->bops->write_mask(st, AD7616_CONFIGURATION_REGISTER,\n\t\t\t\t     AD7616_OS_MASK, val << 2);\n}\n\nstatic int ad7606_write_scale_sw(struct iio_dev *indio_dev, int ch, int val)\n{\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\n\treturn ad7606_spi_write_mask(st,\n\t\t\t\t     AD7606_RANGE_CH_ADDR(ch),\n\t\t\t\t     AD7606_RANGE_CH_MSK(ch),\n\t\t\t\t     AD7606_RANGE_CH_MODE(ch, val));\n}\n\nstatic int ad7606_write_os_sw(struct iio_dev *indio_dev, int val)\n{\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\n\treturn ad7606_spi_reg_write(st, AD7606_OS_MODE, val);\n}\n\nstatic int ad7616_sw_mode_config(struct iio_dev *indio_dev)\n{\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\n\t \n\tindio_dev->channels = ad7616_sw_channels;\n\n\tst->write_scale = ad7616_write_scale_sw;\n\tst->write_os = &ad7616_write_os_sw;\n\n\t \n\treturn st->bops->write_mask(st,\n\t\t\t      AD7616_CONFIGURATION_REGISTER,\n\t\t\t      AD7616_BURST_MODE | AD7616_SEQEN_MODE,\n\t\t\t      AD7616_BURST_MODE | AD7616_SEQEN_MODE);\n}\n\nstatic int ad7606B_sw_mode_config(struct iio_dev *indio_dev)\n{\n\tstruct ad7606_state *st = iio_priv(indio_dev);\n\tunsigned long os[3] = {1};\n\n\t \n\tif (st->gpio_os) {\n\t\tgpiod_set_array_value(ARRAY_SIZE(os),\n\t\t\t\t      st->gpio_os->desc, st->gpio_os->info, os);\n\t}\n\t \n\tst->oversampling_avail = ad7606B_oversampling_avail;\n\tst->num_os_ratios = ARRAY_SIZE(ad7606B_oversampling_avail);\n\n\tst->write_scale = ad7606_write_scale_sw;\n\tst->write_os = &ad7606_write_os_sw;\n\n\t \n\tst->bops->reg_write(st,\n\t\t\t    AD7606_CONFIGURATION_REGISTER,\n\t\t\t    AD7606_SINGLE_DOUT);\n\n\t \n\tindio_dev->channels = ad7606b_sw_channels;\n\n\treturn 0;\n}\n\nstatic const struct ad7606_bus_ops ad7606_spi_bops = {\n\t.read_block = ad7606_spi_read_block,\n};\n\nstatic const struct ad7606_bus_ops ad7616_spi_bops = {\n\t.read_block = ad7606_spi_read_block,\n\t.reg_read = ad7606_spi_reg_read,\n\t.reg_write = ad7606_spi_reg_write,\n\t.write_mask = ad7606_spi_write_mask,\n\t.rd_wr_cmd = ad7616_spi_rd_wr_cmd,\n\t.sw_mode_config = ad7616_sw_mode_config,\n};\n\nstatic const struct ad7606_bus_ops ad7606B_spi_bops = {\n\t.read_block = ad7606_spi_read_block,\n\t.reg_read = ad7606_spi_reg_read,\n\t.reg_write = ad7606_spi_reg_write,\n\t.write_mask = ad7606_spi_write_mask,\n\t.rd_wr_cmd = ad7606B_spi_rd_wr_cmd,\n\t.sw_mode_config = ad7606B_sw_mode_config,\n};\n\nstatic int ad7606_spi_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tconst struct ad7606_bus_ops *bops;\n\n\tswitch (id->driver_data) {\n\tcase ID_AD7616:\n\t\tbops = &ad7616_spi_bops;\n\t\tbreak;\n\tcase ID_AD7606B:\n\t\tbops = &ad7606B_spi_bops;\n\t\tbreak;\n\tdefault:\n\t\tbops = &ad7606_spi_bops;\n\t\tbreak;\n\t}\n\n\treturn ad7606_probe(&spi->dev, spi->irq, NULL,\n\t\t\t    id->name, id->driver_data,\n\t\t\t    bops);\n}\n\nstatic const struct spi_device_id ad7606_id_table[] = {\n\t{ \"ad7605-4\", ID_AD7605_4 },\n\t{ \"ad7606-4\", ID_AD7606_4 },\n\t{ \"ad7606-6\", ID_AD7606_6 },\n\t{ \"ad7606-8\", ID_AD7606_8 },\n\t{ \"ad7606b\",  ID_AD7606B },\n\t{ \"ad7616\",   ID_AD7616 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad7606_id_table);\n\nstatic const struct of_device_id ad7606_of_match[] = {\n\t{ .compatible = \"adi,ad7605-4\" },\n\t{ .compatible = \"adi,ad7606-4\" },\n\t{ .compatible = \"adi,ad7606-6\" },\n\t{ .compatible = \"adi,ad7606-8\" },\n\t{ .compatible = \"adi,ad7606b\" },\n\t{ .compatible = \"adi,ad7616\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ad7606_of_match);\n\nstatic struct spi_driver ad7606_driver = {\n\t.driver = {\n\t\t.name = \"ad7606\",\n\t\t.of_match_table = ad7606_of_match,\n\t\t.pm = AD7606_PM_OPS,\n\t},\n\t.probe = ad7606_spi_probe,\n\t.id_table = ad7606_id_table,\n};\nmodule_spi_driver(ad7606_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7606 ADC\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_AD7606);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}