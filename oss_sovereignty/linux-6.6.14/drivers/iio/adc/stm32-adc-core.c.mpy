{
  "module_name": "stm32-adc-core.c",
  "hash_id": "cc711d5576646fed82fca2f93a0287a23f1101af935e48fbda0ebcda4dbb3cf4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/stm32-adc-core.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdesc.h>\n#include <linux/irqdomain.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/units.h>\n\n#include \"stm32-adc-core.h\"\n\n#define STM32_ADC_CORE_SLEEP_DELAY_MS\t2000\n\n \n#define STM32MP1_SYSCFG_PMCSETR\t\t0x04\n#define STM32MP1_SYSCFG_PMCCLRR\t\t0x44\n\n \n#define STM32MP1_SYSCFG_ANASWVDD_MASK\tBIT(9)\n\n \n#define HAS_VBOOSTER\t\tBIT(0)\n#define HAS_ANASWVDD\t\tBIT(1)\n\n \nstruct stm32_adc_common_regs {\n\tu32 csr;\n\tu32 ccr;\n\tu32 eoc_msk[STM32_ADC_MAX_ADCS];\n\tu32 ovr_msk[STM32_ADC_MAX_ADCS];\n\tu32 ier;\n\tu32 eocie_msk;\n};\n\nstruct stm32_adc_priv;\n\n \nstruct stm32_adc_priv_cfg {\n\tconst struct stm32_adc_common_regs *regs;\n\tint (*clk_sel)(struct platform_device *, struct stm32_adc_priv *);\n\tu32 max_clk_rate_hz;\n\tu32 ipid;\n\tunsigned int has_syscfg;\n\tunsigned int num_irqs;\n\tunsigned int num_adcs;\n};\n\n \nstruct stm32_adc_priv {\n\tint\t\t\t\tirq[STM32_ADC_MAX_ADCS];\n\tunsigned int\t\t\tnb_adc_max;\n\tstruct irq_domain\t\t*domain;\n\tstruct clk\t\t\t*aclk;\n\tstruct clk\t\t\t*bclk;\n\tu32\t\t\t\tmax_clk_rate;\n\tstruct regulator\t\t*booster;\n\tstruct regulator\t\t*vdd;\n\tstruct regulator\t\t*vdda;\n\tstruct regulator\t\t*vref;\n\tint\t\t\t\tvdd_uv;\n\tint\t\t\t\tvdda_uv;\n\tconst struct stm32_adc_priv_cfg\t*cfg;\n\tstruct stm32_adc_common\t\tcommon;\n\tu32\t\t\t\tccr_bak;\n\tstruct regmap\t\t\t*syscfg;\n};\n\nstatic struct stm32_adc_priv *to_stm32_adc_priv(struct stm32_adc_common *com)\n{\n\treturn container_of(com, struct stm32_adc_priv, common);\n}\n\n \nstatic int stm32f4_pclk_div[] = {2, 4, 6, 8};\n\n \nstatic int stm32f4_adc_clk_sel(struct platform_device *pdev,\n\t\t\t       struct stm32_adc_priv *priv)\n{\n\tunsigned long rate;\n\tu32 val;\n\tint i;\n\n\t \n\tif (!priv->aclk) {\n\t\tdev_err(&pdev->dev, \"No 'adc' clock found\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\trate = clk_get_rate(priv->aclk);\n\tif (!rate) {\n\t\tdev_err(&pdev->dev, \"Invalid clock rate: 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(stm32f4_pclk_div); i++) {\n\t\tif ((rate / stm32f4_pclk_div[i]) <= priv->max_clk_rate)\n\t\t\tbreak;\n\t}\n\tif (i >= ARRAY_SIZE(stm32f4_pclk_div)) {\n\t\tdev_err(&pdev->dev, \"adc clk selection failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->common.rate = rate / stm32f4_pclk_div[i];\n\tval = readl_relaxed(priv->common.base + STM32F4_ADC_CCR);\n\tval &= ~STM32F4_ADC_ADCPRE_MASK;\n\tval |= i << STM32F4_ADC_ADCPRE_SHIFT;\n\twritel_relaxed(val, priv->common.base + STM32F4_ADC_CCR);\n\n\tdev_dbg(&pdev->dev, \"Using analog clock source at %ld kHz\\n\",\n\t\tpriv->common.rate / 1000);\n\n\treturn 0;\n}\n\n \nstruct stm32h7_adc_ck_spec {\n\tu32 ckmode;\n\tu32 presc;\n\tint div;\n};\n\nstatic const struct stm32h7_adc_ck_spec stm32h7_adc_ckmodes_spec[] = {\n\t \n\t{ 0, 0, 1 },\n\t{ 0, 1, 2 },\n\t{ 0, 2, 4 },\n\t{ 0, 3, 6 },\n\t{ 0, 4, 8 },\n\t{ 0, 5, 10 },\n\t{ 0, 6, 12 },\n\t{ 0, 7, 16 },\n\t{ 0, 8, 32 },\n\t{ 0, 9, 64 },\n\t{ 0, 10, 128 },\n\t{ 0, 11, 256 },\n\t \n\t{ 1, 0, 1 },\n\t{ 2, 0, 2 },\n\t{ 3, 0, 4 },\n};\n\nstatic int stm32h7_adc_clk_sel(struct platform_device *pdev,\n\t\t\t       struct stm32_adc_priv *priv)\n{\n\tu32 ckmode, presc, val;\n\tunsigned long rate;\n\tint i, div, duty;\n\n\t \n\tif (!priv->bclk) {\n\t\tdev_err(&pdev->dev, \"No 'bus' clock found\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (priv->aclk) {\n\t\t \n\t\trate = clk_get_rate(priv->aclk);\n\t\tif (!rate) {\n\t\t\tdev_err(&pdev->dev, \"Invalid adc clock rate: 0\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tduty = clk_get_scaled_duty_cycle(priv->aclk, 100);\n\t\tif (duty < 0)\n\t\t\tdev_warn(&pdev->dev, \"adc clock duty: %d\\n\", duty);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(stm32h7_adc_ckmodes_spec); i++) {\n\t\t\tckmode = stm32h7_adc_ckmodes_spec[i].ckmode;\n\t\t\tpresc = stm32h7_adc_ckmodes_spec[i].presc;\n\t\t\tdiv = stm32h7_adc_ckmodes_spec[i].div;\n\n\t\t\tif (ckmode)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (div == 1 && (duty < 49 || duty > 51))\n\t\t\t\tcontinue;\n\n\t\t\tif ((rate / div) <= priv->max_clk_rate)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\trate = clk_get_rate(priv->bclk);\n\tif (!rate) {\n\t\tdev_err(&pdev->dev, \"Invalid bus clock rate: 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tduty = clk_get_scaled_duty_cycle(priv->bclk, 100);\n\tif (duty < 0)\n\t\tdev_warn(&pdev->dev, \"bus clock duty: %d\\n\", duty);\n\n\tfor (i = 0; i < ARRAY_SIZE(stm32h7_adc_ckmodes_spec); i++) {\n\t\tckmode = stm32h7_adc_ckmodes_spec[i].ckmode;\n\t\tpresc = stm32h7_adc_ckmodes_spec[i].presc;\n\t\tdiv = stm32h7_adc_ckmodes_spec[i].div;\n\n\t\tif (!ckmode)\n\t\t\tcontinue;\n\n\t\tif (div == 1 && (duty < 49 || duty > 51))\n\t\t\tcontinue;\n\n\t\tif ((rate / div) <= priv->max_clk_rate)\n\t\t\tgoto out;\n\t}\n\n\tdev_err(&pdev->dev, \"adc clk selection failed\\n\");\n\treturn -EINVAL;\n\nout:\n\t \n\tpriv->common.rate = rate / div;\n\n\t \n\tval = readl_relaxed(priv->common.base + STM32H7_ADC_CCR);\n\tval &= ~(STM32H7_CKMODE_MASK | STM32H7_PRESC_MASK);\n\tval |= ckmode << STM32H7_CKMODE_SHIFT;\n\tval |= presc << STM32H7_PRESC_SHIFT;\n\twritel_relaxed(val, priv->common.base + STM32H7_ADC_CCR);\n\n\tdev_dbg(&pdev->dev, \"Using %s clock/%d source at %ld kHz\\n\",\n\t\tckmode ? \"bus\" : \"adc\", div, priv->common.rate / 1000);\n\n\treturn 0;\n}\n\n \nstatic const struct stm32_adc_common_regs stm32f4_adc_common_regs = {\n\t.csr = STM32F4_ADC_CSR,\n\t.ccr = STM32F4_ADC_CCR,\n\t.eoc_msk = { STM32F4_EOC1, STM32F4_EOC2, STM32F4_EOC3 },\n\t.ovr_msk = { STM32F4_OVR1, STM32F4_OVR2, STM32F4_OVR3 },\n\t.ier = STM32F4_ADC_CR1,\n\t.eocie_msk = STM32F4_EOCIE,\n};\n\n \nstatic const struct stm32_adc_common_regs stm32h7_adc_common_regs = {\n\t.csr = STM32H7_ADC_CSR,\n\t.ccr = STM32H7_ADC_CCR,\n\t.eoc_msk = { STM32H7_EOC_MST, STM32H7_EOC_SLV },\n\t.ovr_msk = { STM32H7_OVR_MST, STM32H7_OVR_SLV },\n\t.ier = STM32H7_ADC_IER,\n\t.eocie_msk = STM32H7_EOCIE,\n};\n\n \nstatic const struct stm32_adc_common_regs stm32mp13_adc_common_regs = {\n\t.csr = STM32H7_ADC_CSR,\n\t.ccr = STM32H7_ADC_CCR,\n\t.eoc_msk = { STM32H7_EOC_MST },\n\t.ovr_msk = { STM32H7_OVR_MST },\n\t.ier = STM32H7_ADC_IER,\n\t.eocie_msk = STM32H7_EOCIE,\n};\n\nstatic const unsigned int stm32_adc_offset[STM32_ADC_MAX_ADCS] = {\n\t0, STM32_ADC_OFFSET, STM32_ADC_OFFSET * 2,\n};\n\nstatic unsigned int stm32_adc_eoc_enabled(struct stm32_adc_priv *priv,\n\t\t\t\t\t  unsigned int adc)\n{\n\tu32 ier, offset = stm32_adc_offset[adc];\n\n\tier = readl_relaxed(priv->common.base + offset + priv->cfg->regs->ier);\n\n\treturn ier & priv->cfg->regs->eocie_msk;\n}\n\n \nstatic void stm32_adc_irq_handler(struct irq_desc *desc)\n{\n\tstruct stm32_adc_priv *priv = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tint i;\n\tu32 status;\n\n\tchained_irq_enter(chip, desc);\n\tstatus = readl_relaxed(priv->common.base + priv->cfg->regs->csr);\n\n\t \n\tfor (i = 0; i < priv->nb_adc_max; i++) {\n\t\tif ((status & priv->cfg->regs->eoc_msk[i] &&\n\t\t     stm32_adc_eoc_enabled(priv, i)) ||\n\t\t     (status & priv->cfg->regs->ovr_msk[i]))\n\t\t\tgeneric_handle_domain_irq(priv->domain, i);\n\t}\n\n\tchained_irq_exit(chip, desc);\n};\n\nstatic int stm32_adc_domain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tirq_set_chip_data(irq, d->host_data);\n\tirq_set_chip_and_handler(irq, &dummy_irq_chip, handle_level_irq);\n\n\treturn 0;\n}\n\nstatic void stm32_adc_domain_unmap(struct irq_domain *d, unsigned int irq)\n{\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\tirq_set_chip_data(irq, NULL);\n}\n\nstatic const struct irq_domain_ops stm32_adc_domain_ops = {\n\t.map = stm32_adc_domain_map,\n\t.unmap  = stm32_adc_domain_unmap,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic int stm32_adc_irq_probe(struct platform_device *pdev,\n\t\t\t       struct stm32_adc_priv *priv)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < priv->cfg->num_irqs; i++) {\n\t\tpriv->irq[i] = platform_get_irq(pdev, i);\n\t\tif (priv->irq[i] < 0)\n\t\t\treturn priv->irq[i];\n\t}\n\n\tpriv->domain = irq_domain_add_simple(np, STM32_ADC_MAX_ADCS, 0,\n\t\t\t\t\t     &stm32_adc_domain_ops,\n\t\t\t\t\t     priv);\n\tif (!priv->domain) {\n\t\tdev_err(&pdev->dev, \"Failed to add irq domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < priv->cfg->num_irqs; i++) {\n\t\tirq_set_chained_handler(priv->irq[i], stm32_adc_irq_handler);\n\t\tirq_set_handler_data(priv->irq[i], priv);\n\t}\n\n\treturn 0;\n}\n\nstatic void stm32_adc_irq_remove(struct platform_device *pdev,\n\t\t\t\t struct stm32_adc_priv *priv)\n{\n\tint hwirq;\n\tunsigned int i;\n\n\tfor (hwirq = 0; hwirq < priv->nb_adc_max; hwirq++)\n\t\tirq_dispose_mapping(irq_find_mapping(priv->domain, hwirq));\n\tirq_domain_remove(priv->domain);\n\n\tfor (i = 0; i < priv->cfg->num_irqs; i++)\n\t\tirq_set_chained_handler(priv->irq[i], NULL);\n}\n\nstatic int stm32_adc_core_switches_supply_en(struct stm32_adc_priv *priv,\n\t\t\t\t\t     struct device *dev)\n{\n\tint ret;\n\n\t \n\tif (priv->vdda_uv < 2700000) {\n\t\tif (priv->syscfg && priv->vdd_uv > 2700000) {\n\t\t\tret = regulator_enable(priv->vdd);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"vdd enable failed %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = regmap_write(priv->syscfg,\n\t\t\t\t\t   STM32MP1_SYSCFG_PMCSETR,\n\t\t\t\t\t   STM32MP1_SYSCFG_ANASWVDD_MASK);\n\t\t\tif (ret < 0) {\n\t\t\t\tregulator_disable(priv->vdd);\n\t\t\t\tdev_err(dev, \"vdd select failed, %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdev_dbg(dev, \"analog switches supplied by vdd\\n\");\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (priv->booster) {\n\t\t\t \n\t\t\tret = regulator_enable(priv->booster);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"booster enable failed %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdev_dbg(dev, \"analog switches supplied by booster\\n\");\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tdev_dbg(dev, \"analog switches supplied by vdda (%d uV)\\n\",\n\t\tpriv->vdda_uv);\n\n\treturn 0;\n}\n\nstatic void stm32_adc_core_switches_supply_dis(struct stm32_adc_priv *priv)\n{\n\tif (priv->vdda_uv < 2700000) {\n\t\tif (priv->syscfg && priv->vdd_uv > 2700000) {\n\t\t\tregmap_write(priv->syscfg, STM32MP1_SYSCFG_PMCCLRR,\n\t\t\t\t     STM32MP1_SYSCFG_ANASWVDD_MASK);\n\t\t\tregulator_disable(priv->vdd);\n\t\t\treturn;\n\t\t}\n\t\tif (priv->booster)\n\t\t\tregulator_disable(priv->booster);\n\t}\n}\n\nstatic int stm32_adc_core_hw_start(struct device *dev)\n{\n\tstruct stm32_adc_common *common = dev_get_drvdata(dev);\n\tstruct stm32_adc_priv *priv = to_stm32_adc_priv(common);\n\tint ret;\n\n\tret = regulator_enable(priv->vdda);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"vdda enable failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_get_voltage(priv->vdda);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"vdda get voltage failed, %d\\n\", ret);\n\t\tgoto err_vdda_disable;\n\t}\n\tpriv->vdda_uv = ret;\n\n\tret = stm32_adc_core_switches_supply_en(priv, dev);\n\tif (ret < 0)\n\t\tgoto err_vdda_disable;\n\n\tret = regulator_enable(priv->vref);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"vref enable failed\\n\");\n\t\tgoto err_switches_dis;\n\t}\n\n\tret = clk_prepare_enable(priv->bclk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"bus clk enable failed\\n\");\n\t\tgoto err_regulator_disable;\n\t}\n\n\tret = clk_prepare_enable(priv->aclk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"adc clk enable failed\\n\");\n\t\tgoto err_bclk_disable;\n\t}\n\n\twritel_relaxed(priv->ccr_bak, priv->common.base + priv->cfg->regs->ccr);\n\n\treturn 0;\n\nerr_bclk_disable:\n\tclk_disable_unprepare(priv->bclk);\nerr_regulator_disable:\n\tregulator_disable(priv->vref);\nerr_switches_dis:\n\tstm32_adc_core_switches_supply_dis(priv);\nerr_vdda_disable:\n\tregulator_disable(priv->vdda);\n\n\treturn ret;\n}\n\nstatic void stm32_adc_core_hw_stop(struct device *dev)\n{\n\tstruct stm32_adc_common *common = dev_get_drvdata(dev);\n\tstruct stm32_adc_priv *priv = to_stm32_adc_priv(common);\n\n\t \n\tpriv->ccr_bak = readl_relaxed(priv->common.base + priv->cfg->regs->ccr);\n\tclk_disable_unprepare(priv->aclk);\n\tclk_disable_unprepare(priv->bclk);\n\tregulator_disable(priv->vref);\n\tstm32_adc_core_switches_supply_dis(priv);\n\tregulator_disable(priv->vdda);\n}\n\nstatic int stm32_adc_core_switches_probe(struct device *dev,\n\t\t\t\t\t struct stm32_adc_priv *priv)\n{\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\t \n\tpriv->syscfg = syscon_regmap_lookup_by_phandle(np, \"st,syscfg\");\n\tif (IS_ERR(priv->syscfg)) {\n\t\tret = PTR_ERR(priv->syscfg);\n\t\tif (ret != -ENODEV)\n\t\t\treturn dev_err_probe(dev, ret, \"Can't probe syscfg\\n\");\n\n\t\tpriv->syscfg = NULL;\n\t}\n\n\t \n\tif (priv->cfg->has_syscfg & HAS_VBOOSTER &&\n\t    of_property_read_bool(np, \"booster-supply\")) {\n\t\tpriv->booster = devm_regulator_get_optional(dev, \"booster\");\n\t\tif (IS_ERR(priv->booster)) {\n\t\t\tret = PTR_ERR(priv->booster);\n\t\t\tif (ret != -ENODEV)\n\t\t\t\treturn dev_err_probe(dev, ret, \"can't get booster\\n\");\n\n\t\t\tpriv->booster = NULL;\n\t\t}\n\t}\n\n\t \n\tif (priv->cfg->has_syscfg & HAS_ANASWVDD &&\n\t    of_property_read_bool(np, \"vdd-supply\")) {\n\t\tpriv->vdd = devm_regulator_get_optional(dev, \"vdd\");\n\t\tif (IS_ERR(priv->vdd)) {\n\t\t\tret = PTR_ERR(priv->vdd);\n\t\t\tif (ret != -ENODEV)\n\t\t\t\treturn dev_err_probe(dev, ret, \"can't get vdd\\n\");\n\n\t\t\tpriv->vdd = NULL;\n\t\t}\n\t}\n\n\tif (priv->vdd) {\n\t\tret = regulator_enable(priv->vdd);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"vdd enable failed %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regulator_get_voltage(priv->vdd);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"vdd get voltage failed %d\\n\", ret);\n\t\t\tregulator_disable(priv->vdd);\n\t\t\treturn ret;\n\t\t}\n\t\tpriv->vdd_uv = ret;\n\n\t\tregulator_disable(priv->vdd);\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_adc_probe_identification(struct platform_device *pdev,\n\t\t\t\t\t  struct stm32_adc_priv *priv)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *child;\n\tconst char *compat;\n\tint ret, count = 0;\n\tu32 id, val;\n\n\tif (!priv->cfg->ipid)\n\t\treturn 0;\n\n\tid = FIELD_GET(STM32MP1_IPIDR_MASK,\n\t\t       readl_relaxed(priv->common.base + STM32MP1_ADC_IPDR));\n\tif (id != priv->cfg->ipid) {\n\t\tdev_err(&pdev->dev, \"Unexpected IP version: 0x%x\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_child_of_node(np, child) {\n\t\tret = of_property_read_string(child, \"compatible\", &compat);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\t \n\t\tif (strstr(compat, \"st,stm32\") && strstr(compat, \"adc\"))\n\t\t\tcount++;\n\t}\n\n\tval = readl_relaxed(priv->common.base + STM32MP1_ADC_HWCFGR0);\n\tpriv->nb_adc_max = FIELD_GET(STM32MP1_ADCNUM_MASK, val);\n\tif (count > priv->nb_adc_max) {\n\t\tdev_err(&pdev->dev, \"Unexpected child number: %d\", count);\n\t\treturn -EINVAL;\n\t}\n\n\tval = readl_relaxed(priv->common.base + STM32MP1_ADC_VERR);\n\tdev_dbg(&pdev->dev, \"ADC version: %lu.%lu\\n\",\n\t\tFIELD_GET(STM32MP1_MAJREV_MASK, val),\n\t\tFIELD_GET(STM32MP1_MINREV_MASK, val));\n\n\treturn 0;\n}\n\nstatic int stm32_adc_probe(struct platform_device *pdev)\n{\n\tstruct stm32_adc_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct of_device_id *of_id;\n\n\tstruct resource *res;\n\tu32 max_rate;\n\tint ret;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, &priv->common);\n\n\tof_id = of_match_device(dev->driver->of_match_table, dev);\n\tif (!of_id)\n\t\treturn -ENODEV;\n\n\tpriv->cfg = (const struct stm32_adc_priv_cfg *)of_id->data;\n\tpriv->nb_adc_max = priv->cfg->num_adcs;\n\tspin_lock_init(&priv->common.lock);\n\n\tpriv->common.base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(priv->common.base))\n\t\treturn PTR_ERR(priv->common.base);\n\tpriv->common.phys_base = res->start;\n\n\tpriv->vdda = devm_regulator_get(&pdev->dev, \"vdda\");\n\tif (IS_ERR(priv->vdda))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->vdda),\n\t\t\t\t     \"vdda get failed\\n\");\n\n\tpriv->vref = devm_regulator_get(&pdev->dev, \"vref\");\n\tif (IS_ERR(priv->vref))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->vref),\n\t\t\t\t     \"vref get failed\\n\");\n\n\tpriv->aclk = devm_clk_get_optional(&pdev->dev, \"adc\");\n\tif (IS_ERR(priv->aclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->aclk),\n\t\t\t\t     \"Can't get 'adc' clock\\n\");\n\n\tpriv->bclk = devm_clk_get_optional(&pdev->dev, \"bus\");\n\tif (IS_ERR(priv->bclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->bclk),\n\t\t\t\t     \"Can't get 'bus' clock\\n\");\n\n\tret = stm32_adc_core_switches_probe(dev, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_set_autosuspend_delay(dev, STM32_ADC_CORE_SLEEP_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n\n\tret = stm32_adc_core_hw_start(dev);\n\tif (ret)\n\t\tgoto err_pm_stop;\n\n\tret = stm32_adc_probe_identification(pdev, priv);\n\tif (ret < 0)\n\t\tgoto err_hw_stop;\n\n\tret = regulator_get_voltage(priv->vref);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"vref get voltage failed, %d\\n\", ret);\n\t\tgoto err_hw_stop;\n\t}\n\tpriv->common.vref_mv = ret / 1000;\n\tdev_dbg(&pdev->dev, \"vref+=%dmV\\n\", priv->common.vref_mv);\n\n\tret = of_property_read_u32(pdev->dev.of_node, \"st,max-clk-rate-hz\",\n\t\t\t\t   &max_rate);\n\tif (!ret)\n\t\tpriv->max_clk_rate = min(max_rate, priv->cfg->max_clk_rate_hz);\n\telse\n\t\tpriv->max_clk_rate = priv->cfg->max_clk_rate_hz;\n\n\tret = priv->cfg->clk_sel(pdev, priv);\n\tif (ret < 0)\n\t\tgoto err_hw_stop;\n\n\tret = stm32_adc_irq_probe(pdev, priv);\n\tif (ret < 0)\n\t\tgoto err_hw_stop;\n\n\tret = of_platform_populate(np, NULL, NULL, &pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to populate DT children\\n\");\n\t\tgoto err_irq_remove;\n\t}\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n\nerr_irq_remove:\n\tstm32_adc_irq_remove(pdev, priv);\nerr_hw_stop:\n\tstm32_adc_core_hw_stop(dev);\nerr_pm_stop:\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_put_noidle(dev);\n\n\treturn ret;\n}\n\nstatic int stm32_adc_remove(struct platform_device *pdev)\n{\n\tstruct stm32_adc_common *common = platform_get_drvdata(pdev);\n\tstruct stm32_adc_priv *priv = to_stm32_adc_priv(common);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tof_platform_depopulate(&pdev->dev);\n\tstm32_adc_irq_remove(pdev, priv);\n\tstm32_adc_core_hw_stop(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic int stm32_adc_core_runtime_suspend(struct device *dev)\n{\n\tstm32_adc_core_hw_stop(dev);\n\n\treturn 0;\n}\n\nstatic int stm32_adc_core_runtime_resume(struct device *dev)\n{\n\treturn stm32_adc_core_hw_start(dev);\n}\n\nstatic int stm32_adc_core_runtime_idle(struct device *dev)\n{\n\tpm_runtime_mark_last_busy(dev);\n\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(stm32_adc_core_pm_ops,\n\t\t\t\tstm32_adc_core_runtime_suspend,\n\t\t\t\tstm32_adc_core_runtime_resume,\n\t\t\t\tstm32_adc_core_runtime_idle);\n\nstatic const struct stm32_adc_priv_cfg stm32f4_adc_priv_cfg = {\n\t.regs = &stm32f4_adc_common_regs,\n\t.clk_sel = stm32f4_adc_clk_sel,\n\t.max_clk_rate_hz = 36000000,\n\t.num_irqs = 1,\n\t.num_adcs = 3,\n};\n\nstatic const struct stm32_adc_priv_cfg stm32h7_adc_priv_cfg = {\n\t.regs = &stm32h7_adc_common_regs,\n\t.clk_sel = stm32h7_adc_clk_sel,\n\t.max_clk_rate_hz = 36000000,\n\t.has_syscfg = HAS_VBOOSTER,\n\t.num_irqs = 1,\n\t.num_adcs = 2,\n};\n\nstatic const struct stm32_adc_priv_cfg stm32mp1_adc_priv_cfg = {\n\t.regs = &stm32h7_adc_common_regs,\n\t.clk_sel = stm32h7_adc_clk_sel,\n\t.max_clk_rate_hz = 36000000,\n\t.has_syscfg = HAS_VBOOSTER | HAS_ANASWVDD,\n\t.ipid = STM32MP15_IPIDR_NUMBER,\n\t.num_irqs = 2,\n};\n\nstatic const struct stm32_adc_priv_cfg stm32mp13_adc_priv_cfg = {\n\t.regs = &stm32mp13_adc_common_regs,\n\t.clk_sel = stm32h7_adc_clk_sel,\n\t.max_clk_rate_hz = 75 * HZ_PER_MHZ,\n\t.ipid = STM32MP13_IPIDR_NUMBER,\n\t.num_irqs = 1,\n};\n\nstatic const struct of_device_id stm32_adc_of_match[] = {\n\t{\n\t\t.compatible = \"st,stm32f4-adc-core\",\n\t\t.data = (void *)&stm32f4_adc_priv_cfg\n\t}, {\n\t\t.compatible = \"st,stm32h7-adc-core\",\n\t\t.data = (void *)&stm32h7_adc_priv_cfg\n\t}, {\n\t\t.compatible = \"st,stm32mp1-adc-core\",\n\t\t.data = (void *)&stm32mp1_adc_priv_cfg\n\t}, {\n\t\t.compatible = \"st,stm32mp13-adc-core\",\n\t\t.data = (void *)&stm32mp13_adc_priv_cfg\n\t}, {\n\t},\n};\nMODULE_DEVICE_TABLE(of, stm32_adc_of_match);\n\nstatic struct platform_driver stm32_adc_driver = {\n\t.probe = stm32_adc_probe,\n\t.remove = stm32_adc_remove,\n\t.driver = {\n\t\t.name = \"stm32-adc-core\",\n\t\t.of_match_table = stm32_adc_of_match,\n\t\t.pm = pm_ptr(&stm32_adc_core_pm_ops),\n\t},\n};\nmodule_platform_driver(stm32_adc_driver);\n\nMODULE_AUTHOR(\"Fabrice Gasnier <fabrice.gasnier@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 ADC core driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:stm32-adc-core\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}