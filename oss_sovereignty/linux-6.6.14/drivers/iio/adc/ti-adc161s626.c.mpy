{
  "module_name": "ti-adc161s626.c",
  "hash_id": "9058a2a69448322f26c7c292837d769c51c83c84ca2df797d4cb8dbe4fcfd364",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-adc161s626.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/spi/spi.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/regulator/consumer.h>\n\n#define TI_ADC_DRV_NAME\t\"ti-adc161s626\"\n\nenum {\n\tTI_ADC141S626,\n\tTI_ADC161S626,\n};\n\nstatic const struct iio_chan_spec ti_adc141s626_channels[] = {\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 14,\n\t\t\t.storagebits = 16,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n};\n\nstatic const struct iio_chan_spec ti_adc161s626_channels[] = {\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n};\n\nstruct ti_adc_data {\n\tstruct iio_dev *indio_dev;\n\tstruct spi_device *spi;\n\tstruct regulator *ref;\n\n\tu8 read_size;\n\tu8 shift;\n\n\tu8 buffer[16] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic int ti_adc_read_measurement(struct ti_adc_data *data,\n\t\t\t\t   struct iio_chan_spec const *chan, int *val)\n{\n\tint ret;\n\n\tswitch (data->read_size) {\n\tcase 2: {\n\t\t__be16 buf;\n\n\t\tret = spi_read(data->spi, (void *) &buf, 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = be16_to_cpu(buf);\n\t\tbreak;\n\t}\n\tcase 3: {\n\t\t__be32 buf;\n\n\t\tret = spi_read(data->spi, (void *) &buf, 3);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = be32_to_cpu(buf) >> 8;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*val = sign_extend32(*val >> data->shift, chan->scan_type.realbits - 1);\n\n\treturn 0;\n}\n\nstatic irqreturn_t ti_adc_trigger_handler(int irq, void *private)\n{\n\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ti_adc_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = ti_adc_read_measurement(data, &indio_dev->channels[0],\n\t\t\t\t     (int *) &data->buffer);\n\tif (!ret)\n\t\tiio_push_to_buffers_with_timestamp(indio_dev,\n\t\t\t\t\tdata->buffer,\n\t\t\t\t\tiio_get_time_ns(indio_dev));\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ti_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct ti_adc_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ti_adc_read_measurement(data, chan, val);\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = regulator_get_voltage(data->ref);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret / 1000;\n\t\t*val2 = chan->scan_type.realbits;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = 1 << (chan->scan_type.realbits - 1);\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iio_info ti_adc_info = {\n\t.read_raw = ti_adc_read_raw,\n};\n\nstatic void ti_adc_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int ti_adc_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct ti_adc_data *data;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tindio_dev->info = &ti_adc_info;\n\tindio_dev->name = TI_ADC_DRV_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tdata = iio_priv(indio_dev);\n\tdata->spi = spi;\n\n\tswitch (spi_get_device_id(spi)->driver_data) {\n\tcase TI_ADC141S626:\n\t\tindio_dev->channels = ti_adc141s626_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(ti_adc141s626_channels);\n\t\tdata->shift = 0;\n\t\tdata->read_size = 2;\n\t\tbreak;\n\tcase TI_ADC161S626:\n\t\tindio_dev->channels = ti_adc161s626_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(ti_adc161s626_channels);\n\t\tdata->shift = 6;\n\t\tdata->read_size = 3;\n\t\tbreak;\n\t}\n\n\tdata->ref = devm_regulator_get(&spi->dev, \"vdda\");\n\tif (IS_ERR(data->ref))\n\t\treturn PTR_ERR(data->ref);\n\n\tret = regulator_enable(data->ref);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, ti_adc_reg_disable,\n\t\t\t\t       data->ref);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev, NULL,\n\t\t\t\t\t      ti_adc_trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id ti_adc_dt_ids[] = {\n\t{ .compatible = \"ti,adc141s626\", },\n\t{ .compatible = \"ti,adc161s626\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ti_adc_dt_ids);\n\nstatic const struct spi_device_id ti_adc_id[] = {\n\t{\"adc141s626\", TI_ADC141S626},\n\t{\"adc161s626\", TI_ADC161S626},\n\t{},\n};\nMODULE_DEVICE_TABLE(spi, ti_adc_id);\n\nstatic struct spi_driver ti_adc_driver = {\n\t.driver = {\n\t\t.name\t= TI_ADC_DRV_NAME,\n\t\t.of_match_table = ti_adc_dt_ids,\n\t},\n\t.probe\t\t= ti_adc_probe,\n\t.id_table\t= ti_adc_id,\n};\nmodule_spi_driver(ti_adc_driver);\n\nMODULE_AUTHOR(\"Matt Ranostay <matt.ranostay@konsulko.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments ADC1x1S 1-channel differential ADC\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}