{
  "module_name": "ad7091r5.c",
  "hash_id": "ed99356c68e5bd19e8af2dbf96d5987a925282af28a2e8e57464ee209000cecf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7091r5.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n#include \"ad7091r-base.h\"\n\nstatic const struct iio_event_spec ad7091r5_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t BIT(IIO_EV_INFO_ENABLE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t BIT(IIO_EV_INFO_ENABLE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_HYSTERESIS),\n\t},\n};\n\n#define AD7091R_CHANNEL(idx, bits, ev, num_ev) { \\\n\t.type = IIO_VOLTAGE, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t.indexed = 1, \\\n\t.channel = idx, \\\n\t.event_spec = ev, \\\n\t.num_event_specs = num_ev, \\\n\t.scan_type.storagebits = 16, \\\n\t.scan_type.realbits = bits, \\\n}\nstatic const struct iio_chan_spec ad7091r5_channels_irq[] = {\n\tAD7091R_CHANNEL(0, 12, ad7091r5_events, ARRAY_SIZE(ad7091r5_events)),\n\tAD7091R_CHANNEL(1, 12, ad7091r5_events, ARRAY_SIZE(ad7091r5_events)),\n\tAD7091R_CHANNEL(2, 12, ad7091r5_events, ARRAY_SIZE(ad7091r5_events)),\n\tAD7091R_CHANNEL(3, 12, ad7091r5_events, ARRAY_SIZE(ad7091r5_events)),\n};\n\nstatic const struct iio_chan_spec ad7091r5_channels_noirq[] = {\n\tAD7091R_CHANNEL(0, 12, NULL, 0),\n\tAD7091R_CHANNEL(1, 12, NULL, 0),\n\tAD7091R_CHANNEL(2, 12, NULL, 0),\n\tAD7091R_CHANNEL(3, 12, NULL, 0),\n};\n\nstatic const struct ad7091r_chip_info ad7091r5_chip_info_irq = {\n\t.channels = ad7091r5_channels_irq,\n\t.num_channels = ARRAY_SIZE(ad7091r5_channels_irq),\n\t.vref_mV = 2500,\n};\n\nstatic const struct ad7091r_chip_info ad7091r5_chip_info_noirq = {\n\t.channels = ad7091r5_channels_noirq,\n\t.num_channels = ARRAY_SIZE(ad7091r5_channels_noirq),\n\t.vref_mV = 2500,\n};\n\nstatic int ad7091r5_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tconst struct ad7091r_chip_info *chip_info;\n\tstruct regmap *map = devm_regmap_init_i2c(i2c, &ad7091r_regmap_config);\n\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (i2c->irq)\n\t\tchip_info = &ad7091r5_chip_info_irq;\n\telse\n\t\tchip_info = &ad7091r5_chip_info_noirq;\n\n\treturn ad7091r_probe(&i2c->dev, id->name, chip_info, map, i2c->irq);\n}\n\nstatic const struct of_device_id ad7091r5_dt_ids[] = {\n\t{ .compatible = \"adi,ad7091r5\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ad7091r5_dt_ids);\n\nstatic const struct i2c_device_id ad7091r5_i2c_ids[] = {\n\t{\"ad7091r5\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ad7091r5_i2c_ids);\n\nstatic struct i2c_driver ad7091r5_driver = {\n\t.driver = {\n\t\t.name = \"ad7091r5\",\n\t\t.of_match_table = ad7091r5_dt_ids,\n\t},\n\t.probe = ad7091r5_i2c_probe,\n\t.id_table = ad7091r5_i2c_ids,\n};\nmodule_i2c_driver(ad7091r5_driver);\n\nMODULE_AUTHOR(\"Beniamin Bia <beniamin.bia@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7091R5 multi-channel ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_AD7091R);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}