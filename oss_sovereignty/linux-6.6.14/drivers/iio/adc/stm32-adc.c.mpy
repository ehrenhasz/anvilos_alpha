{
  "module_name": "stm32-adc.c",
  "hash_id": "bd4e4a128fafde317560301fc4ed1fa9b1013980bbce7a55550cc6186cf4ad5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/stm32-adc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/timer/stm32-lptim-trigger.h>\n#include <linux/iio/timer/stm32-timer-trigger.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n\n#include \"stm32-adc-core.h\"\n\n \n#define STM32H7_LINCALFACT_NUM\t\t6\n\n \n#define STM32H7_BOOST_CLKRATE\t\t20000000UL\n\n#define STM32_ADC_CH_MAX\t\t20\t \n#define STM32_ADC_CH_SZ\t\t\t16\t \n#define STM32_ADC_MAX_SQ\t\t16\t \n#define STM32_ADC_MAX_SMP\t\t7\t \n#define STM32_ADC_TIMEOUT_US\t\t100000\n#define STM32_ADC_TIMEOUT\t(msecs_to_jiffies(STM32_ADC_TIMEOUT_US / 1000))\n#define STM32_ADC_HW_STOP_DELAY_MS\t100\n#define STM32_ADC_VREFINT_VOLTAGE\t3300\n\n#define STM32_DMA_BUFFER_SIZE\t\tPAGE_SIZE\n\n \nenum stm32_adc_exten {\n\tSTM32_EXTEN_SWTRIG,\n\tSTM32_EXTEN_HWTRIG_RISING_EDGE,\n\tSTM32_EXTEN_HWTRIG_FALLING_EDGE,\n\tSTM32_EXTEN_HWTRIG_BOTH_EDGES,\n};\n\n \nenum stm32_adc_extsel {\n\tSTM32_EXT0,\n\tSTM32_EXT1,\n\tSTM32_EXT2,\n\tSTM32_EXT3,\n\tSTM32_EXT4,\n\tSTM32_EXT5,\n\tSTM32_EXT6,\n\tSTM32_EXT7,\n\tSTM32_EXT8,\n\tSTM32_EXT9,\n\tSTM32_EXT10,\n\tSTM32_EXT11,\n\tSTM32_EXT12,\n\tSTM32_EXT13,\n\tSTM32_EXT14,\n\tSTM32_EXT15,\n\tSTM32_EXT16,\n\tSTM32_EXT17,\n\tSTM32_EXT18,\n\tSTM32_EXT19,\n\tSTM32_EXT20,\n};\n\nenum stm32_adc_int_ch {\n\tSTM32_ADC_INT_CH_NONE = -1,\n\tSTM32_ADC_INT_CH_VDDCORE,\n\tSTM32_ADC_INT_CH_VDDCPU,\n\tSTM32_ADC_INT_CH_VDDQ_DDR,\n\tSTM32_ADC_INT_CH_VREFINT,\n\tSTM32_ADC_INT_CH_VBAT,\n\tSTM32_ADC_INT_CH_NB,\n};\n\n \nstruct stm32_adc_ic {\n\tconst char *name;\n\tu32 idx;\n};\n\nstatic const struct stm32_adc_ic stm32_adc_ic[STM32_ADC_INT_CH_NB] = {\n\t{ \"vddcore\", STM32_ADC_INT_CH_VDDCORE },\n\t{ \"vddcpu\", STM32_ADC_INT_CH_VDDCPU },\n\t{ \"vddq_ddr\", STM32_ADC_INT_CH_VDDQ_DDR },\n\t{ \"vrefint\", STM32_ADC_INT_CH_VREFINT },\n\t{ \"vbat\", STM32_ADC_INT_CH_VBAT },\n};\n\n \nstruct stm32_adc_trig_info {\n\tconst char *name;\n\tenum stm32_adc_extsel extsel;\n};\n\n \nstruct stm32_adc_calib {\n\tu32\t\t\tlincalfact[STM32H7_LINCALFACT_NUM];\n\tbool\t\t\tlincal_saved;\n};\n\n \nstruct stm32_adc_regs {\n\tint reg;\n\tint mask;\n\tint shift;\n};\n\n \nstruct stm32_adc_vrefint {\n\tu32 vrefint_cal;\n\tu32 vrefint_data;\n};\n\n \nstruct stm32_adc_regspec {\n\tconst u32 dr;\n\tconst struct stm32_adc_regs ier_eoc;\n\tconst struct stm32_adc_regs ier_ovr;\n\tconst struct stm32_adc_regs isr_eoc;\n\tconst struct stm32_adc_regs isr_ovr;\n\tconst struct stm32_adc_regs *sqr;\n\tconst struct stm32_adc_regs exten;\n\tconst struct stm32_adc_regs extsel;\n\tconst struct stm32_adc_regs res;\n\tconst struct stm32_adc_regs difsel;\n\tconst u32 smpr[2];\n\tconst struct stm32_adc_regs *smp_bits;\n\tconst struct stm32_adc_regs or_vddcore;\n\tconst struct stm32_adc_regs or_vddcpu;\n\tconst struct stm32_adc_regs or_vddq_ddr;\n\tconst struct stm32_adc_regs ccr_vbat;\n\tconst struct stm32_adc_regs ccr_vref;\n};\n\nstruct stm32_adc;\n\n \nstruct stm32_adc_cfg {\n\tconst struct stm32_adc_regspec\t*regs;\n\tconst struct stm32_adc_info\t*adc_info;\n\tstruct stm32_adc_trig_info\t*trigs;\n\tbool clk_required;\n\tbool has_vregready;\n\tbool has_boostmode;\n\tbool has_linearcal;\n\tbool has_presel;\n\tint (*prepare)(struct iio_dev *);\n\tvoid (*start_conv)(struct iio_dev *, bool dma);\n\tvoid (*stop_conv)(struct iio_dev *);\n\tvoid (*unprepare)(struct iio_dev *);\n\tvoid (*irq_clear)(struct iio_dev *indio_dev, u32 msk);\n\tconst unsigned int *smp_cycles;\n\tconst unsigned int *ts_int_ch;\n};\n\n \nstruct stm32_adc {\n\tstruct stm32_adc_common\t*common;\n\tu32\t\t\toffset;\n\tconst struct stm32_adc_cfg\t*cfg;\n\tstruct completion\tcompletion;\n\tu16\t\t\tbuffer[STM32_ADC_MAX_SQ + 4] __aligned(8);\n\tstruct clk\t\t*clk;\n\tint\t\t\tirq;\n\tspinlock_t\t\tlock;\t\t \n\tunsigned int\t\tbufi;\n\tunsigned int\t\tnum_conv;\n\tu32\t\t\tres;\n\tu32\t\t\ttrigger_polarity;\n\tstruct dma_chan\t\t*dma_chan;\n\tu8\t\t\t*rx_buf;\n\tdma_addr_t\t\trx_dma_buf;\n\tunsigned int\t\trx_buf_sz;\n\tu32\t\t\tdifsel;\n\tu32\t\t\tpcsel;\n\tu32\t\t\tsmpr_val[2];\n\tstruct stm32_adc_calib\tcal;\n\tstruct stm32_adc_vrefint vrefint;\n\tchar\t\t\tchan_name[STM32_ADC_CH_MAX][STM32_ADC_CH_SZ];\n\tu32\t\t\tnum_diff;\n\tint\t\t\tint_ch[STM32_ADC_INT_CH_NB];\n\tint\t\t\tnsmps;\n};\n\nstruct stm32_adc_diff_channel {\n\tu32 vinp;\n\tu32 vinn;\n};\n\n \nstruct stm32_adc_info {\n\tint max_channels;\n\tconst unsigned int *resolutions;\n\tconst unsigned int num_res;\n};\n\nstatic const unsigned int stm32f4_adc_resolutions[] = {\n\t \n\t12, 10, 8, 6,\n};\n\n \nstatic const struct stm32_adc_info stm32f4_adc_info = {\n\t.max_channels = 16,\n\t.resolutions = stm32f4_adc_resolutions,\n\t.num_res = ARRAY_SIZE(stm32f4_adc_resolutions),\n};\n\nstatic const unsigned int stm32h7_adc_resolutions[] = {\n\t \n\t16, 14, 12, 10, 8,\n};\n\n \nstatic const struct stm32_adc_info stm32h7_adc_info = {\n\t.max_channels = STM32_ADC_CH_MAX,\n\t.resolutions = stm32h7_adc_resolutions,\n\t.num_res = ARRAY_SIZE(stm32h7_adc_resolutions),\n};\n\n \nstatic const struct stm32_adc_info stm32mp13_adc_info = {\n\t.max_channels = 19,\n\t.resolutions = stm32f4_adc_resolutions,\n\t.num_res = ARRAY_SIZE(stm32f4_adc_resolutions),\n};\n\n \nstatic const struct stm32_adc_regs stm32f4_sq[STM32_ADC_MAX_SQ + 1] = {\n\t \n\t{ STM32F4_ADC_SQR1, GENMASK(23, 20), 20 },\n\t \n\t{ STM32F4_ADC_SQR3, GENMASK(4, 0), 0 },\n\t{ STM32F4_ADC_SQR3, GENMASK(9, 5), 5 },\n\t{ STM32F4_ADC_SQR3, GENMASK(14, 10), 10 },\n\t{ STM32F4_ADC_SQR3, GENMASK(19, 15), 15 },\n\t{ STM32F4_ADC_SQR3, GENMASK(24, 20), 20 },\n\t{ STM32F4_ADC_SQR3, GENMASK(29, 25), 25 },\n\t{ STM32F4_ADC_SQR2, GENMASK(4, 0), 0 },\n\t{ STM32F4_ADC_SQR2, GENMASK(9, 5), 5 },\n\t{ STM32F4_ADC_SQR2, GENMASK(14, 10), 10 },\n\t{ STM32F4_ADC_SQR2, GENMASK(19, 15), 15 },\n\t{ STM32F4_ADC_SQR2, GENMASK(24, 20), 20 },\n\t{ STM32F4_ADC_SQR2, GENMASK(29, 25), 25 },\n\t{ STM32F4_ADC_SQR1, GENMASK(4, 0), 0 },\n\t{ STM32F4_ADC_SQR1, GENMASK(9, 5), 5 },\n\t{ STM32F4_ADC_SQR1, GENMASK(14, 10), 10 },\n\t{ STM32F4_ADC_SQR1, GENMASK(19, 15), 15 },\n};\n\n \nstatic struct stm32_adc_trig_info stm32f4_adc_trigs[] = {\n\t{ TIM1_CH1, STM32_EXT0 },\n\t{ TIM1_CH2, STM32_EXT1 },\n\t{ TIM1_CH3, STM32_EXT2 },\n\t{ TIM2_CH2, STM32_EXT3 },\n\t{ TIM2_CH3, STM32_EXT4 },\n\t{ TIM2_CH4, STM32_EXT5 },\n\t{ TIM2_TRGO, STM32_EXT6 },\n\t{ TIM3_CH1, STM32_EXT7 },\n\t{ TIM3_TRGO, STM32_EXT8 },\n\t{ TIM4_CH4, STM32_EXT9 },\n\t{ TIM5_CH1, STM32_EXT10 },\n\t{ TIM5_CH2, STM32_EXT11 },\n\t{ TIM5_CH3, STM32_EXT12 },\n\t{ TIM8_CH1, STM32_EXT13 },\n\t{ TIM8_TRGO, STM32_EXT14 },\n\t{},  \n};\n\n \nstatic const struct stm32_adc_regs stm32f4_smp_bits[] = {\n\t \n\t{ 1, GENMASK(2, 0), 0 },\n\t{ 1, GENMASK(5, 3), 3 },\n\t{ 1, GENMASK(8, 6), 6 },\n\t{ 1, GENMASK(11, 9), 9 },\n\t{ 1, GENMASK(14, 12), 12 },\n\t{ 1, GENMASK(17, 15), 15 },\n\t{ 1, GENMASK(20, 18), 18 },\n\t{ 1, GENMASK(23, 21), 21 },\n\t{ 1, GENMASK(26, 24), 24 },\n\t{ 1, GENMASK(29, 27), 27 },\n\t \n\t{ 0, GENMASK(2, 0), 0 },\n\t{ 0, GENMASK(5, 3), 3 },\n\t{ 0, GENMASK(8, 6), 6 },\n\t{ 0, GENMASK(11, 9), 9 },\n\t{ 0, GENMASK(14, 12), 12 },\n\t{ 0, GENMASK(17, 15), 15 },\n\t{ 0, GENMASK(20, 18), 18 },\n\t{ 0, GENMASK(23, 21), 21 },\n\t{ 0, GENMASK(26, 24), 24 },\n};\n\n \nstatic const unsigned int stm32f4_adc_smp_cycles[STM32_ADC_MAX_SMP + 1] = {\n\t3, 15, 28, 56, 84, 112, 144, 480,\n};\n\nstatic const struct stm32_adc_regspec stm32f4_adc_regspec = {\n\t.dr = STM32F4_ADC_DR,\n\t.ier_eoc = { STM32F4_ADC_CR1, STM32F4_EOCIE },\n\t.ier_ovr = { STM32F4_ADC_CR1, STM32F4_OVRIE },\n\t.isr_eoc = { STM32F4_ADC_SR, STM32F4_EOC },\n\t.isr_ovr = { STM32F4_ADC_SR, STM32F4_OVR },\n\t.sqr = stm32f4_sq,\n\t.exten = { STM32F4_ADC_CR2, STM32F4_EXTEN_MASK, STM32F4_EXTEN_SHIFT },\n\t.extsel = { STM32F4_ADC_CR2, STM32F4_EXTSEL_MASK,\n\t\t    STM32F4_EXTSEL_SHIFT },\n\t.res = { STM32F4_ADC_CR1, STM32F4_RES_MASK, STM32F4_RES_SHIFT },\n\t.smpr = { STM32F4_ADC_SMPR1, STM32F4_ADC_SMPR2 },\n\t.smp_bits = stm32f4_smp_bits,\n};\n\nstatic const struct stm32_adc_regs stm32h7_sq[STM32_ADC_MAX_SQ + 1] = {\n\t \n\t{ STM32H7_ADC_SQR1, GENMASK(3, 0), 0 },\n\t \n\t{ STM32H7_ADC_SQR1, GENMASK(10, 6), 6 },\n\t{ STM32H7_ADC_SQR1, GENMASK(16, 12), 12 },\n\t{ STM32H7_ADC_SQR1, GENMASK(22, 18), 18 },\n\t{ STM32H7_ADC_SQR1, GENMASK(28, 24), 24 },\n\t{ STM32H7_ADC_SQR2, GENMASK(4, 0), 0 },\n\t{ STM32H7_ADC_SQR2, GENMASK(10, 6), 6 },\n\t{ STM32H7_ADC_SQR2, GENMASK(16, 12), 12 },\n\t{ STM32H7_ADC_SQR2, GENMASK(22, 18), 18 },\n\t{ STM32H7_ADC_SQR2, GENMASK(28, 24), 24 },\n\t{ STM32H7_ADC_SQR3, GENMASK(4, 0), 0 },\n\t{ STM32H7_ADC_SQR3, GENMASK(10, 6), 6 },\n\t{ STM32H7_ADC_SQR3, GENMASK(16, 12), 12 },\n\t{ STM32H7_ADC_SQR3, GENMASK(22, 18), 18 },\n\t{ STM32H7_ADC_SQR3, GENMASK(28, 24), 24 },\n\t{ STM32H7_ADC_SQR4, GENMASK(4, 0), 0 },\n\t{ STM32H7_ADC_SQR4, GENMASK(10, 6), 6 },\n};\n\n \nstatic struct stm32_adc_trig_info stm32h7_adc_trigs[] = {\n\t{ TIM1_CH1, STM32_EXT0 },\n\t{ TIM1_CH2, STM32_EXT1 },\n\t{ TIM1_CH3, STM32_EXT2 },\n\t{ TIM2_CH2, STM32_EXT3 },\n\t{ TIM3_TRGO, STM32_EXT4 },\n\t{ TIM4_CH4, STM32_EXT5 },\n\t{ TIM8_TRGO, STM32_EXT7 },\n\t{ TIM8_TRGO2, STM32_EXT8 },\n\t{ TIM1_TRGO, STM32_EXT9 },\n\t{ TIM1_TRGO2, STM32_EXT10 },\n\t{ TIM2_TRGO, STM32_EXT11 },\n\t{ TIM4_TRGO, STM32_EXT12 },\n\t{ TIM6_TRGO, STM32_EXT13 },\n\t{ TIM15_TRGO, STM32_EXT14 },\n\t{ TIM3_CH4, STM32_EXT15 },\n\t{ LPTIM1_OUT, STM32_EXT18 },\n\t{ LPTIM2_OUT, STM32_EXT19 },\n\t{ LPTIM3_OUT, STM32_EXT20 },\n\t{},\n};\n\n \nstatic const struct stm32_adc_regs stm32h7_smp_bits[] = {\n\t \n\t{ 0, GENMASK(2, 0), 0 },\n\t{ 0, GENMASK(5, 3), 3 },\n\t{ 0, GENMASK(8, 6), 6 },\n\t{ 0, GENMASK(11, 9), 9 },\n\t{ 0, GENMASK(14, 12), 12 },\n\t{ 0, GENMASK(17, 15), 15 },\n\t{ 0, GENMASK(20, 18), 18 },\n\t{ 0, GENMASK(23, 21), 21 },\n\t{ 0, GENMASK(26, 24), 24 },\n\t{ 0, GENMASK(29, 27), 27 },\n\t \n\t{ 1, GENMASK(2, 0), 0 },\n\t{ 1, GENMASK(5, 3), 3 },\n\t{ 1, GENMASK(8, 6), 6 },\n\t{ 1, GENMASK(11, 9), 9 },\n\t{ 1, GENMASK(14, 12), 12 },\n\t{ 1, GENMASK(17, 15), 15 },\n\t{ 1, GENMASK(20, 18), 18 },\n\t{ 1, GENMASK(23, 21), 21 },\n\t{ 1, GENMASK(26, 24), 24 },\n\t{ 1, GENMASK(29, 27), 27 },\n};\n\n \nstatic const unsigned int stm32h7_adc_smp_cycles[STM32_ADC_MAX_SMP + 1] = {\n\t1, 2, 8, 16, 32, 64, 387, 810,\n};\n\nstatic const struct stm32_adc_regspec stm32h7_adc_regspec = {\n\t.dr = STM32H7_ADC_DR,\n\t.ier_eoc = { STM32H7_ADC_IER, STM32H7_EOCIE },\n\t.ier_ovr = { STM32H7_ADC_IER, STM32H7_OVRIE },\n\t.isr_eoc = { STM32H7_ADC_ISR, STM32H7_EOC },\n\t.isr_ovr = { STM32H7_ADC_ISR, STM32H7_OVR },\n\t.sqr = stm32h7_sq,\n\t.exten = { STM32H7_ADC_CFGR, STM32H7_EXTEN_MASK, STM32H7_EXTEN_SHIFT },\n\t.extsel = { STM32H7_ADC_CFGR, STM32H7_EXTSEL_MASK,\n\t\t    STM32H7_EXTSEL_SHIFT },\n\t.res = { STM32H7_ADC_CFGR, STM32H7_RES_MASK, STM32H7_RES_SHIFT },\n\t.difsel = { STM32H7_ADC_DIFSEL, STM32H7_DIFSEL_MASK},\n\t.smpr = { STM32H7_ADC_SMPR1, STM32H7_ADC_SMPR2 },\n\t.smp_bits = stm32h7_smp_bits,\n};\n\n \nstatic const unsigned int stm32mp13_adc_smp_cycles[STM32_ADC_MAX_SMP + 1] = {\n\t2, 6, 12, 24, 47, 92, 247, 640,\n};\n\nstatic const struct stm32_adc_regspec stm32mp13_adc_regspec = {\n\t.dr = STM32H7_ADC_DR,\n\t.ier_eoc = { STM32H7_ADC_IER, STM32H7_EOCIE },\n\t.ier_ovr = { STM32H7_ADC_IER, STM32H7_OVRIE },\n\t.isr_eoc = { STM32H7_ADC_ISR, STM32H7_EOC },\n\t.isr_ovr = { STM32H7_ADC_ISR, STM32H7_OVR },\n\t.sqr = stm32h7_sq,\n\t.exten = { STM32H7_ADC_CFGR, STM32H7_EXTEN_MASK, STM32H7_EXTEN_SHIFT },\n\t.extsel = { STM32H7_ADC_CFGR, STM32H7_EXTSEL_MASK,\n\t\t    STM32H7_EXTSEL_SHIFT },\n\t.res = { STM32H7_ADC_CFGR, STM32MP13_RES_MASK, STM32MP13_RES_SHIFT },\n\t.difsel = { STM32MP13_ADC_DIFSEL, STM32MP13_DIFSEL_MASK},\n\t.smpr = { STM32H7_ADC_SMPR1, STM32H7_ADC_SMPR2 },\n\t.smp_bits = stm32h7_smp_bits,\n\t.or_vddcore = { STM32MP13_ADC2_OR, STM32MP13_OP0 },\n\t.or_vddcpu = { STM32MP13_ADC2_OR, STM32MP13_OP1 },\n\t.or_vddq_ddr = { STM32MP13_ADC2_OR, STM32MP13_OP2 },\n\t.ccr_vbat = { STM32H7_ADC_CCR, STM32H7_VBATEN },\n\t.ccr_vref = { STM32H7_ADC_CCR, STM32H7_VREFEN },\n};\n\nstatic const struct stm32_adc_regspec stm32mp1_adc_regspec = {\n\t.dr = STM32H7_ADC_DR,\n\t.ier_eoc = { STM32H7_ADC_IER, STM32H7_EOCIE },\n\t.ier_ovr = { STM32H7_ADC_IER, STM32H7_OVRIE },\n\t.isr_eoc = { STM32H7_ADC_ISR, STM32H7_EOC },\n\t.isr_ovr = { STM32H7_ADC_ISR, STM32H7_OVR },\n\t.sqr = stm32h7_sq,\n\t.exten = { STM32H7_ADC_CFGR, STM32H7_EXTEN_MASK, STM32H7_EXTEN_SHIFT },\n\t.extsel = { STM32H7_ADC_CFGR, STM32H7_EXTSEL_MASK,\n\t\t    STM32H7_EXTSEL_SHIFT },\n\t.res = { STM32H7_ADC_CFGR, STM32H7_RES_MASK, STM32H7_RES_SHIFT },\n\t.difsel = { STM32H7_ADC_DIFSEL, STM32H7_DIFSEL_MASK},\n\t.smpr = { STM32H7_ADC_SMPR1, STM32H7_ADC_SMPR2 },\n\t.smp_bits = stm32h7_smp_bits,\n\t.or_vddcore = { STM32MP1_ADC2_OR, STM32MP1_VDDCOREEN },\n\t.ccr_vbat = { STM32H7_ADC_CCR, STM32H7_VBATEN },\n\t.ccr_vref = { STM32H7_ADC_CCR, STM32H7_VREFEN },\n};\n\n \nstatic u32 stm32_adc_readl(struct stm32_adc *adc, u32 reg)\n{\n\treturn readl_relaxed(adc->common->base + adc->offset + reg);\n}\n\n#define stm32_adc_readl_addr(addr)\tstm32_adc_readl(adc, addr)\n\n#define stm32_adc_readl_poll_timeout(reg, val, cond, sleep_us, timeout_us) \\\n\treadx_poll_timeout(stm32_adc_readl_addr, reg, val, \\\n\t\t\t   cond, sleep_us, timeout_us)\n\nstatic u16 stm32_adc_readw(struct stm32_adc *adc, u32 reg)\n{\n\treturn readw_relaxed(adc->common->base + adc->offset + reg);\n}\n\nstatic void stm32_adc_writel(struct stm32_adc *adc, u32 reg, u32 val)\n{\n\twritel_relaxed(val, adc->common->base + adc->offset + reg);\n}\n\nstatic void stm32_adc_set_bits(struct stm32_adc *adc, u32 reg, u32 bits)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adc->lock, flags);\n\tstm32_adc_writel(adc, reg, stm32_adc_readl(adc, reg) | bits);\n\tspin_unlock_irqrestore(&adc->lock, flags);\n}\n\nstatic void stm32_adc_set_bits_common(struct stm32_adc *adc, u32 reg, u32 bits)\n{\n\tspin_lock(&adc->common->lock);\n\twritel_relaxed(readl_relaxed(adc->common->base + reg) | bits,\n\t\t       adc->common->base + reg);\n\tspin_unlock(&adc->common->lock);\n}\n\nstatic void stm32_adc_clr_bits(struct stm32_adc *adc, u32 reg, u32 bits)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adc->lock, flags);\n\tstm32_adc_writel(adc, reg, stm32_adc_readl(adc, reg) & ~bits);\n\tspin_unlock_irqrestore(&adc->lock, flags);\n}\n\nstatic void stm32_adc_clr_bits_common(struct stm32_adc *adc, u32 reg, u32 bits)\n{\n\tspin_lock(&adc->common->lock);\n\twritel_relaxed(readl_relaxed(adc->common->base + reg) & ~bits,\n\t\t       adc->common->base + reg);\n\tspin_unlock(&adc->common->lock);\n}\n\n \nstatic void stm32_adc_conv_irq_enable(struct stm32_adc *adc)\n{\n\tstm32_adc_set_bits(adc, adc->cfg->regs->ier_eoc.reg,\n\t\t\t   adc->cfg->regs->ier_eoc.mask);\n};\n\n \nstatic void stm32_adc_conv_irq_disable(struct stm32_adc *adc)\n{\n\tstm32_adc_clr_bits(adc, adc->cfg->regs->ier_eoc.reg,\n\t\t\t   adc->cfg->regs->ier_eoc.mask);\n}\n\nstatic void stm32_adc_ovr_irq_enable(struct stm32_adc *adc)\n{\n\tstm32_adc_set_bits(adc, adc->cfg->regs->ier_ovr.reg,\n\t\t\t   adc->cfg->regs->ier_ovr.mask);\n}\n\nstatic void stm32_adc_ovr_irq_disable(struct stm32_adc *adc)\n{\n\tstm32_adc_clr_bits(adc, adc->cfg->regs->ier_ovr.reg,\n\t\t\t   adc->cfg->regs->ier_ovr.mask);\n}\n\nstatic void stm32_adc_set_res(struct stm32_adc *adc)\n{\n\tconst struct stm32_adc_regs *res = &adc->cfg->regs->res;\n\tu32 val;\n\n\tval = stm32_adc_readl(adc, res->reg);\n\tval = (val & ~res->mask) | (adc->res << res->shift);\n\tstm32_adc_writel(adc, res->reg, val);\n}\n\nstatic int stm32_adc_hw_stop(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\n\tif (adc->cfg->unprepare)\n\t\tadc->cfg->unprepare(indio_dev);\n\n\tclk_disable_unprepare(adc->clk);\n\n\treturn 0;\n}\n\nstatic int stm32_adc_hw_start(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\n\tret = clk_prepare_enable(adc->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tstm32_adc_set_res(adc);\n\n\tif (adc->cfg->prepare) {\n\t\tret = adc->cfg->prepare(indio_dev);\n\t\tif (ret)\n\t\t\tgoto err_clk_dis;\n\t}\n\n\treturn 0;\n\nerr_clk_dis:\n\tclk_disable_unprepare(adc->clk);\n\n\treturn ret;\n}\n\nstatic void stm32_adc_int_ch_enable(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tu32 i;\n\n\tfor (i = 0; i < STM32_ADC_INT_CH_NB; i++) {\n\t\tif (adc->int_ch[i] == STM32_ADC_INT_CH_NONE)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase STM32_ADC_INT_CH_VDDCORE:\n\t\t\tdev_dbg(&indio_dev->dev, \"Enable VDDCore\\n\");\n\t\t\tstm32_adc_set_bits(adc, adc->cfg->regs->or_vddcore.reg,\n\t\t\t\t\t   adc->cfg->regs->or_vddcore.mask);\n\t\t\tbreak;\n\t\tcase STM32_ADC_INT_CH_VDDCPU:\n\t\t\tdev_dbg(&indio_dev->dev, \"Enable VDDCPU\\n\");\n\t\t\tstm32_adc_set_bits(adc, adc->cfg->regs->or_vddcpu.reg,\n\t\t\t\t\t   adc->cfg->regs->or_vddcpu.mask);\n\t\t\tbreak;\n\t\tcase STM32_ADC_INT_CH_VDDQ_DDR:\n\t\t\tdev_dbg(&indio_dev->dev, \"Enable VDDQ_DDR\\n\");\n\t\t\tstm32_adc_set_bits(adc, adc->cfg->regs->or_vddq_ddr.reg,\n\t\t\t\t\t   adc->cfg->regs->or_vddq_ddr.mask);\n\t\t\tbreak;\n\t\tcase STM32_ADC_INT_CH_VREFINT:\n\t\t\tdev_dbg(&indio_dev->dev, \"Enable VREFInt\\n\");\n\t\t\tstm32_adc_set_bits_common(adc, adc->cfg->regs->ccr_vref.reg,\n\t\t\t\t\t\t  adc->cfg->regs->ccr_vref.mask);\n\t\t\tbreak;\n\t\tcase STM32_ADC_INT_CH_VBAT:\n\t\t\tdev_dbg(&indio_dev->dev, \"Enable VBAT\\n\");\n\t\t\tstm32_adc_set_bits_common(adc, adc->cfg->regs->ccr_vbat.reg,\n\t\t\t\t\t\t  adc->cfg->regs->ccr_vbat.mask);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void stm32_adc_int_ch_disable(struct stm32_adc *adc)\n{\n\tu32 i;\n\n\tfor (i = 0; i < STM32_ADC_INT_CH_NB; i++) {\n\t\tif (adc->int_ch[i] == STM32_ADC_INT_CH_NONE)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase STM32_ADC_INT_CH_VDDCORE:\n\t\t\tstm32_adc_clr_bits(adc, adc->cfg->regs->or_vddcore.reg,\n\t\t\t\t\t   adc->cfg->regs->or_vddcore.mask);\n\t\t\tbreak;\n\t\tcase STM32_ADC_INT_CH_VDDCPU:\n\t\t\tstm32_adc_clr_bits(adc, adc->cfg->regs->or_vddcpu.reg,\n\t\t\t\t\t   adc->cfg->regs->or_vddcpu.mask);\n\t\t\tbreak;\n\t\tcase STM32_ADC_INT_CH_VDDQ_DDR:\n\t\t\tstm32_adc_clr_bits(adc, adc->cfg->regs->or_vddq_ddr.reg,\n\t\t\t\t\t   adc->cfg->regs->or_vddq_ddr.mask);\n\t\t\tbreak;\n\t\tcase STM32_ADC_INT_CH_VREFINT:\n\t\t\tstm32_adc_clr_bits_common(adc, adc->cfg->regs->ccr_vref.reg,\n\t\t\t\t\t\t  adc->cfg->regs->ccr_vref.mask);\n\t\t\tbreak;\n\t\tcase STM32_ADC_INT_CH_VBAT:\n\t\t\tstm32_adc_clr_bits_common(adc, adc->cfg->regs->ccr_vbat.reg,\n\t\t\t\t\t\t  adc->cfg->regs->ccr_vbat.mask);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void stm32f4_adc_start_conv(struct iio_dev *indio_dev, bool dma)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\n\tstm32_adc_set_bits(adc, STM32F4_ADC_CR1, STM32F4_SCAN);\n\n\tif (dma)\n\t\tstm32_adc_set_bits(adc, STM32F4_ADC_CR2,\n\t\t\t\t   STM32F4_DMA | STM32F4_DDS);\n\n\tstm32_adc_set_bits(adc, STM32F4_ADC_CR2, STM32F4_EOCS | STM32F4_ADON);\n\n\t \n\tusleep_range(2, 3);\n\n\t \n\tif (!(stm32_adc_readl(adc, STM32F4_ADC_CR2) & STM32F4_EXTEN_MASK))\n\t\tstm32_adc_set_bits(adc, STM32F4_ADC_CR2, STM32F4_SWSTART);\n}\n\nstatic void stm32f4_adc_stop_conv(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\n\tstm32_adc_clr_bits(adc, STM32F4_ADC_CR2, STM32F4_EXTEN_MASK);\n\tstm32_adc_clr_bits(adc, STM32F4_ADC_SR, STM32F4_STRT);\n\n\tstm32_adc_clr_bits(adc, STM32F4_ADC_CR1, STM32F4_SCAN);\n\tstm32_adc_clr_bits(adc, STM32F4_ADC_CR2,\n\t\t\t   STM32F4_ADON | STM32F4_DMA | STM32F4_DDS);\n}\n\nstatic void stm32f4_adc_irq_clear(struct iio_dev *indio_dev, u32 msk)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\n\tstm32_adc_clr_bits(adc, adc->cfg->regs->isr_eoc.reg, msk);\n}\n\nstatic void stm32h7_adc_start_conv(struct iio_dev *indio_dev, bool dma)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tenum stm32h7_adc_dmngt dmngt;\n\tunsigned long flags;\n\tu32 val;\n\n\tif (dma)\n\t\tdmngt = STM32H7_DMNGT_DMA_CIRC;\n\telse\n\t\tdmngt = STM32H7_DMNGT_DR_ONLY;\n\n\tspin_lock_irqsave(&adc->lock, flags);\n\tval = stm32_adc_readl(adc, STM32H7_ADC_CFGR);\n\tval = (val & ~STM32H7_DMNGT_MASK) | (dmngt << STM32H7_DMNGT_SHIFT);\n\tstm32_adc_writel(adc, STM32H7_ADC_CFGR, val);\n\tspin_unlock_irqrestore(&adc->lock, flags);\n\n\tstm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADSTART);\n}\n\nstatic void stm32h7_adc_stop_conv(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\tu32 val;\n\n\tstm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADSTP);\n\n\tret = stm32_adc_readl_poll_timeout(STM32H7_ADC_CR, val,\n\t\t\t\t\t   !(val & (STM32H7_ADSTART)),\n\t\t\t\t\t   100, STM32_ADC_TIMEOUT_US);\n\tif (ret)\n\t\tdev_warn(&indio_dev->dev, \"stop failed\\n\");\n\n\t \n\tstm32_adc_clr_bits(adc, STM32H7_ADC_CFGR, STM32H7_DMNGT_MASK);\n}\n\nstatic void stm32h7_adc_irq_clear(struct iio_dev *indio_dev, u32 msk)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\t \n\tstm32_adc_set_bits(adc, adc->cfg->regs->isr_eoc.reg, msk);\n}\n\nstatic void stm32mp13_adc_start_conv(struct iio_dev *indio_dev, bool dma)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\n\tif (dma)\n\t\tstm32_adc_set_bits(adc, STM32H7_ADC_CFGR,\n\t\t\t\t   STM32MP13_DMAEN | STM32MP13_DMACFG);\n\n\tstm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADSTART);\n}\n\nstatic int stm32h7_adc_exit_pwr_down(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\tu32 val;\n\n\t \n\tstm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_DEEPPWD);\n\tstm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADVREGEN);\n\n\tif (adc->cfg->has_boostmode &&\n\t    adc->common->rate > STM32H7_BOOST_CLKRATE)\n\t\tstm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_BOOST);\n\n\t \n\tif (!adc->cfg->has_vregready) {\n\t\tusleep_range(10, 20);\n\t\treturn 0;\n\t}\n\n\tret = stm32_adc_readl_poll_timeout(STM32H7_ADC_ISR, val,\n\t\t\t\t\t   val & STM32MP1_VREGREADY, 100,\n\t\t\t\t\t   STM32_ADC_TIMEOUT_US);\n\tif (ret) {\n\t\tstm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_DEEPPWD);\n\t\tdev_err(&indio_dev->dev, \"Failed to exit power down\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic void stm32h7_adc_enter_pwr_down(struct stm32_adc *adc)\n{\n\tif (adc->cfg->has_boostmode)\n\t\tstm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_BOOST);\n\n\t \n\tstm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_DEEPPWD);\n}\n\nstatic int stm32h7_adc_enable(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\tu32 val;\n\n\tstm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADEN);\n\n\t \n\tret = stm32_adc_readl_poll_timeout(STM32H7_ADC_ISR, val,\n\t\t\t\t\t   val & STM32H7_ADRDY,\n\t\t\t\t\t   100, STM32_ADC_TIMEOUT_US);\n\tif (ret) {\n\t\tstm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADDIS);\n\t\tdev_err(&indio_dev->dev, \"Failed to enable ADC\\n\");\n\t} else {\n\t\t \n\t\tstm32_adc_set_bits(adc, STM32H7_ADC_ISR, STM32H7_ADRDY);\n\t}\n\n\treturn ret;\n}\n\nstatic void stm32h7_adc_disable(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\tu32 val;\n\n\tif (!(stm32_adc_readl(adc, STM32H7_ADC_CR) & STM32H7_ADEN))\n\t\treturn;\n\n\t \n\tstm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADDIS);\n\tret = stm32_adc_readl_poll_timeout(STM32H7_ADC_CR, val,\n\t\t\t\t\t   !(val & STM32H7_ADEN), 100,\n\t\t\t\t\t   STM32_ADC_TIMEOUT_US);\n\tif (ret)\n\t\tdev_warn(&indio_dev->dev, \"Failed to disable\\n\");\n}\n\n \nstatic int stm32h7_adc_read_selfcalib(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tint i, ret;\n\tu32 lincalrdyw_mask, val;\n\n\t \n\tlincalrdyw_mask = STM32H7_LINCALRDYW6;\n\tfor (i = STM32H7_LINCALFACT_NUM - 1; i >= 0; i--) {\n\t\t \n\t\tstm32_adc_clr_bits(adc, STM32H7_ADC_CR, lincalrdyw_mask);\n\n\t\t \n\t\tret = stm32_adc_readl_poll_timeout(STM32H7_ADC_CR, val,\n\t\t\t\t\t\t   !(val & lincalrdyw_mask),\n\t\t\t\t\t\t   100, STM32_ADC_TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tdev_err(&indio_dev->dev, \"Failed to read calfact\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tval = stm32_adc_readl(adc, STM32H7_ADC_CALFACT2);\n\t\tadc->cal.lincalfact[i] = (val & STM32H7_LINCALFACT_MASK);\n\t\tadc->cal.lincalfact[i] >>= STM32H7_LINCALFACT_SHIFT;\n\n\t\tlincalrdyw_mask >>= 1;\n\t}\n\tadc->cal.lincal_saved = true;\n\n\treturn 0;\n}\n\n \nstatic int stm32h7_adc_restore_selfcalib(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tint i, ret;\n\tu32 lincalrdyw_mask, val;\n\n\tlincalrdyw_mask = STM32H7_LINCALRDYW6;\n\tfor (i = STM32H7_LINCALFACT_NUM - 1; i >= 0; i--) {\n\t\t \n\t\tval = adc->cal.lincalfact[i] << STM32H7_LINCALFACT_SHIFT;\n\t\tstm32_adc_writel(adc, STM32H7_ADC_CALFACT2, val);\n\t\tstm32_adc_set_bits(adc, STM32H7_ADC_CR, lincalrdyw_mask);\n\t\tret = stm32_adc_readl_poll_timeout(STM32H7_ADC_CR, val,\n\t\t\t\t\t\t   val & lincalrdyw_mask,\n\t\t\t\t\t\t   100, STM32_ADC_TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tdev_err(&indio_dev->dev, \"Failed to write calfact\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tstm32_adc_clr_bits(adc, STM32H7_ADC_CR, lincalrdyw_mask);\n\t\tret = stm32_adc_readl_poll_timeout(STM32H7_ADC_CR, val,\n\t\t\t\t\t\t   !(val & lincalrdyw_mask),\n\t\t\t\t\t\t   100, STM32_ADC_TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tdev_err(&indio_dev->dev, \"Failed to read calfact\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tval = stm32_adc_readl(adc, STM32H7_ADC_CALFACT2);\n\t\tif (val != adc->cal.lincalfact[i] << STM32H7_LINCALFACT_SHIFT) {\n\t\t\tdev_err(&indio_dev->dev, \"calfact not consistent\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tlincalrdyw_mask >>= 1;\n\t}\n\n\treturn 0;\n}\n\n \n#define STM32H7_ADC_CALIB_TIMEOUT_US\t\t100000\n\n \nstatic int stm32h7_adc_selfcalib(struct iio_dev *indio_dev, int do_lincal)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\tu32 msk = STM32H7_ADCALDIF;\n\tu32 val;\n\n\tif (adc->cfg->has_linearcal && do_lincal)\n\t\tmsk |= STM32H7_ADCALLIN;\n\t \n\tstm32h7_adc_disable(indio_dev);\n\n\t \n\tstm32_adc_clr_bits(adc, STM32H7_ADC_CR, msk);\n\n\t \n\tstm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADCAL);\n\tret = stm32_adc_readl_poll_timeout(STM32H7_ADC_CR, val,\n\t\t\t\t\t   !(val & STM32H7_ADCAL), 100,\n\t\t\t\t\t   STM32H7_ADC_CALIB_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"calibration (single-ended) error %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tstm32_adc_set_bits(adc, STM32H7_ADC_CR, msk);\n\tstm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADCAL);\n\tret = stm32_adc_readl_poll_timeout(STM32H7_ADC_CR, val,\n\t\t\t\t\t   !(val & STM32H7_ADCAL), 100,\n\t\t\t\t\t   STM32H7_ADC_CALIB_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"calibration (diff%s) error %d\\n\",\n\t\t\t(msk & STM32H7_ADCALLIN) ? \"+linear\" : \"\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tstm32_adc_clr_bits(adc, STM32H7_ADC_CR, msk);\n\n\treturn ret;\n}\n\n \nstatic int stm32h7_adc_check_selfcalib(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tu32 val;\n\n\tif (adc->cal.lincal_saved)\n\t\treturn true;\n\n\t \n\tval = stm32_adc_readl(adc, STM32H7_ADC_CR) & STM32H7_LINCALRDYW_MASK;\n\tif (val == STM32H7_LINCALRDYW_MASK)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int stm32h7_adc_prepare(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tint lincal_done = false;\n\tint ret;\n\n\tret = stm32h7_adc_exit_pwr_down(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adc->cfg->has_linearcal)\n\t\tlincal_done = stm32h7_adc_check_selfcalib(indio_dev);\n\n\t \n\tret = stm32h7_adc_selfcalib(indio_dev, !lincal_done);\n\tif (ret < 0)\n\t\tgoto pwr_dwn;\n\n\tstm32_adc_int_ch_enable(indio_dev);\n\n\tstm32_adc_writel(adc, adc->cfg->regs->difsel.reg, adc->difsel);\n\n\tret = stm32h7_adc_enable(indio_dev);\n\tif (ret)\n\t\tgoto ch_disable;\n\n\tif (adc->cfg->has_linearcal) {\n\t\tif (!adc->cal.lincal_saved)\n\t\t\tret = stm32h7_adc_read_selfcalib(indio_dev);\n\t\telse\n\t\t\tret = stm32h7_adc_restore_selfcalib(indio_dev);\n\n\t\tif (ret)\n\t\t\tgoto disable;\n\t}\n\n\tif (adc->cfg->has_presel)\n\t\tstm32_adc_writel(adc, STM32H7_ADC_PCSEL, adc->pcsel);\n\n\treturn 0;\n\ndisable:\n\tstm32h7_adc_disable(indio_dev);\nch_disable:\n\tstm32_adc_int_ch_disable(adc);\npwr_dwn:\n\tstm32h7_adc_enter_pwr_down(adc);\n\n\treturn ret;\n}\n\nstatic void stm32h7_adc_unprepare(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\n\tif (adc->cfg->has_presel)\n\t\tstm32_adc_writel(adc, STM32H7_ADC_PCSEL, 0);\n\tstm32h7_adc_disable(indio_dev);\n\tstm32_adc_int_ch_disable(adc);\n\tstm32h7_adc_enter_pwr_down(adc);\n}\n\n \nstatic int stm32_adc_conf_scan_seq(struct iio_dev *indio_dev,\n\t\t\t\t   const unsigned long *scan_mask)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tconst struct stm32_adc_regs *sqr = adc->cfg->regs->sqr;\n\tconst struct iio_chan_spec *chan;\n\tu32 val, bit;\n\tint i = 0;\n\n\t \n\tstm32_adc_writel(adc, adc->cfg->regs->smpr[0], adc->smpr_val[0]);\n\tstm32_adc_writel(adc, adc->cfg->regs->smpr[1], adc->smpr_val[1]);\n\n\tfor_each_set_bit(bit, scan_mask, indio_dev->masklength) {\n\t\tchan = indio_dev->channels + bit;\n\t\t \n\t\ti++;\n\t\tif (i > STM32_ADC_MAX_SQ)\n\t\t\treturn -EINVAL;\n\n\t\tdev_dbg(&indio_dev->dev, \"%s chan %d to SQ%d\\n\",\n\t\t\t__func__, chan->channel, i);\n\n\t\tval = stm32_adc_readl(adc, sqr[i].reg);\n\t\tval &= ~sqr[i].mask;\n\t\tval |= chan->channel << sqr[i].shift;\n\t\tstm32_adc_writel(adc, sqr[i].reg, val);\n\t}\n\n\tif (!i)\n\t\treturn -EINVAL;\n\n\t \n\tval = stm32_adc_readl(adc, sqr[0].reg);\n\tval &= ~sqr[0].mask;\n\tval |= ((i - 1) << sqr[0].shift);\n\tstm32_adc_writel(adc, sqr[0].reg, val);\n\n\treturn 0;\n}\n\n \nstatic int stm32_adc_get_trig_extsel(struct iio_dev *indio_dev,\n\t\t\t\t     struct iio_trigger *trig)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tint i;\n\n\t \n\tfor (i = 0; adc->cfg->trigs[i].name; i++) {\n\t\t \n\t\tif ((is_stm32_timer_trigger(trig) ||\n\t\t     is_stm32_lptim_trigger(trig)) &&\n\t\t    !strcmp(adc->cfg->trigs[i].name, trig->name)) {\n\t\t\treturn adc->cfg->trigs[i].extsel;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int stm32_adc_set_trig(struct iio_dev *indio_dev,\n\t\t\t      struct iio_trigger *trig)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tu32 val, extsel = 0, exten = STM32_EXTEN_SWTRIG;\n\tunsigned long flags;\n\tint ret;\n\n\tif (trig) {\n\t\tret = stm32_adc_get_trig_extsel(indio_dev, trig);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\textsel = ret;\n\t\texten = adc->trigger_polarity + STM32_EXTEN_HWTRIG_RISING_EDGE;\n\t}\n\n\tspin_lock_irqsave(&adc->lock, flags);\n\tval = stm32_adc_readl(adc, adc->cfg->regs->exten.reg);\n\tval &= ~(adc->cfg->regs->exten.mask | adc->cfg->regs->extsel.mask);\n\tval |= exten << adc->cfg->regs->exten.shift;\n\tval |= extsel << adc->cfg->regs->extsel.shift;\n\tstm32_adc_writel(adc,  adc->cfg->regs->exten.reg, val);\n\tspin_unlock_irqrestore(&adc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int stm32_adc_set_trig_pol(struct iio_dev *indio_dev,\n\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t  unsigned int type)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\n\tadc->trigger_polarity = type;\n\n\treturn 0;\n}\n\nstatic int stm32_adc_get_trig_pol(struct iio_dev *indio_dev,\n\t\t\t\t  const struct iio_chan_spec *chan)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\n\treturn adc->trigger_polarity;\n}\n\nstatic const char * const stm32_trig_pol_items[] = {\n\t\"rising-edge\", \"falling-edge\", \"both-edges\",\n};\n\nstatic const struct iio_enum stm32_adc_trig_pol = {\n\t.items = stm32_trig_pol_items,\n\t.num_items = ARRAY_SIZE(stm32_trig_pol_items),\n\t.get = stm32_adc_get_trig_pol,\n\t.set = stm32_adc_set_trig_pol,\n};\n\n \nstatic int stm32_adc_single_conv(struct iio_dev *indio_dev,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t int *res)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\tconst struct stm32_adc_regspec *regs = adc->cfg->regs;\n\tlong timeout;\n\tu32 val;\n\tint ret;\n\n\treinit_completion(&adc->completion);\n\n\tadc->bufi = 0;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tstm32_adc_writel(adc, regs->smpr[0], adc->smpr_val[0]);\n\tstm32_adc_writel(adc, regs->smpr[1], adc->smpr_val[1]);\n\n\t \n\tval = stm32_adc_readl(adc, regs->sqr[1].reg);\n\tval &= ~regs->sqr[1].mask;\n\tval |= chan->channel << regs->sqr[1].shift;\n\tstm32_adc_writel(adc, regs->sqr[1].reg, val);\n\n\t \n\tstm32_adc_clr_bits(adc, regs->sqr[0].reg, regs->sqr[0].mask);\n\n\t \n\tstm32_adc_clr_bits(adc, regs->exten.reg, regs->exten.mask);\n\n\tstm32_adc_conv_irq_enable(adc);\n\n\tadc->cfg->start_conv(indio_dev, false);\n\n\ttimeout = wait_for_completion_interruptible_timeout(\n\t\t\t\t\t&adc->completion, STM32_ADC_TIMEOUT);\n\tif (timeout == 0) {\n\t\tret = -ETIMEDOUT;\n\t} else if (timeout < 0) {\n\t\tret = timeout;\n\t} else {\n\t\t*res = adc->buffer[0];\n\t\tret = IIO_VAL_INT;\n\t}\n\n\tadc->cfg->stop_conv(indio_dev);\n\n\tstm32_adc_conv_irq_disable(adc);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nstatic int stm32_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int *val, int *val2, long mask)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (chan->type == IIO_VOLTAGE)\n\t\t\tret = stm32_adc_single_conv(indio_dev, chan, val);\n\t\telse\n\t\t\tret = -EINVAL;\n\n\t\tif (mask == IIO_CHAN_INFO_PROCESSED)\n\t\t\t*val = STM32_ADC_VREFINT_VOLTAGE * adc->vrefint.vrefint_cal / *val;\n\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->differential) {\n\t\t\t*val = adc->common->vref_mv * 2;\n\t\t\t*val2 = chan->scan_type.realbits;\n\t\t} else {\n\t\t\t*val = adc->common->vref_mv;\n\t\t\t*val2 = chan->scan_type.realbits;\n\t\t}\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (chan->differential)\n\t\t\t \n\t\t\t*val = -((1 << chan->scan_type.realbits) / 2);\n\t\telse\n\t\t\t*val = 0;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void stm32_adc_irq_clear(struct iio_dev *indio_dev, u32 msk)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\n\tadc->cfg->irq_clear(indio_dev, msk);\n}\n\nstatic irqreturn_t stm32_adc_threaded_isr(int irq, void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tconst struct stm32_adc_regspec *regs = adc->cfg->regs;\n\tu32 status = stm32_adc_readl(adc, regs->isr_eoc.reg);\n\n\t \n\tif (status & regs->isr_ovr.mask) {\n\t\t \n\t\tadc->cfg->stop_conv(indio_dev);\n\t\tstm32_adc_irq_clear(indio_dev, regs->isr_ovr.mask);\n\t\tdev_err(&indio_dev->dev, \"Overrun, stopping: restart needed\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t stm32_adc_isr(int irq, void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tconst struct stm32_adc_regspec *regs = adc->cfg->regs;\n\tu32 status = stm32_adc_readl(adc, regs->isr_eoc.reg);\n\n\tif (status & regs->isr_ovr.mask) {\n\t\t \n\t\tstm32_adc_ovr_irq_disable(adc);\n\t\tstm32_adc_conv_irq_disable(adc);\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\n\tif (status & regs->isr_eoc.mask) {\n\t\t \n\t\tadc->buffer[adc->bufi] = stm32_adc_readw(adc, regs->dr);\n\t\tif (iio_buffer_enabled(indio_dev)) {\n\t\t\tadc->bufi++;\n\t\t\tif (adc->bufi >= adc->num_conv) {\n\t\t\t\tstm32_adc_conv_irq_disable(adc);\n\t\t\t\tiio_trigger_poll(indio_dev->trig);\n\t\t\t}\n\t\t} else {\n\t\t\tcomplete(&adc->completion);\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\n \nstatic int stm32_adc_validate_trigger(struct iio_dev *indio_dev,\n\t\t\t\t      struct iio_trigger *trig)\n{\n\treturn stm32_adc_get_trig_extsel(indio_dev, trig) < 0 ? -EINVAL : 0;\n}\n\nstatic int stm32_adc_set_watermark(struct iio_dev *indio_dev, unsigned int val)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tunsigned int watermark = STM32_DMA_BUFFER_SIZE / 2;\n\tunsigned int rx_buf_sz = STM32_DMA_BUFFER_SIZE;\n\n\t \n\twatermark = min(watermark, val * (unsigned)(sizeof(u16)));\n\tadc->rx_buf_sz = min(rx_buf_sz, watermark * 2 * adc->num_conv);\n\n\treturn 0;\n}\n\nstatic int stm32_adc_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t      const unsigned long *scan_mask)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tadc->num_conv = bitmap_weight(scan_mask, indio_dev->masklength);\n\n\tret = stm32_adc_conf_scan_seq(indio_dev, scan_mask);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nstatic int stm32_adc_fwnode_xlate(struct iio_dev *indio_dev,\n\t\t\t\t  const struct fwnode_reference_args *iiospec)\n{\n\tint i;\n\n\tfor (i = 0; i < indio_dev->num_channels; i++)\n\t\tif (indio_dev->channels[i].channel == iiospec->args[0])\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\n \nstatic int stm32_adc_debugfs_reg_access(struct iio_dev *indio_dev,\n\t\t\t\t\tunsigned reg, unsigned writeval,\n\t\t\t\t\tunsigned *readval)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!readval)\n\t\tstm32_adc_writel(adc, reg, writeval);\n\telse\n\t\t*readval = stm32_adc_readl(adc, reg);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic const struct iio_info stm32_adc_iio_info = {\n\t.read_raw = stm32_adc_read_raw,\n\t.validate_trigger = stm32_adc_validate_trigger,\n\t.hwfifo_set_watermark = stm32_adc_set_watermark,\n\t.update_scan_mode = stm32_adc_update_scan_mode,\n\t.debugfs_reg_access = stm32_adc_debugfs_reg_access,\n\t.fwnode_xlate = stm32_adc_fwnode_xlate,\n};\n\nstatic unsigned int stm32_adc_dma_residue(struct stm32_adc *adc)\n{\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\n\tstatus = dmaengine_tx_status(adc->dma_chan,\n\t\t\t\t     adc->dma_chan->cookie,\n\t\t\t\t     &state);\n\tif (status == DMA_IN_PROGRESS) {\n\t\t \n\t\tunsigned int i = adc->rx_buf_sz - state.residue;\n\t\tunsigned int size;\n\n\t\t \n\t\tif (i >= adc->bufi)\n\t\t\tsize = i - adc->bufi;\n\t\telse\n\t\t\tsize = adc->rx_buf_sz + i - adc->bufi;\n\n\t\treturn size;\n\t}\n\n\treturn 0;\n}\n\nstatic void stm32_adc_dma_buffer_done(void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tint residue = stm32_adc_dma_residue(adc);\n\n\t \n\tdev_dbg(&indio_dev->dev, \"%s bufi=%d\\n\", __func__, adc->bufi);\n\n\twhile (residue >= indio_dev->scan_bytes) {\n\t\tu16 *buffer = (u16 *)&adc->rx_buf[adc->bufi];\n\n\t\tiio_push_to_buffers(indio_dev, buffer);\n\n\t\tresidue -= indio_dev->scan_bytes;\n\t\tadc->bufi += indio_dev->scan_bytes;\n\t\tif (adc->bufi >= adc->rx_buf_sz)\n\t\t\tadc->bufi = 0;\n\t}\n}\n\nstatic int stm32_adc_dma_start(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tstruct dma_async_tx_descriptor *desc;\n\tdma_cookie_t cookie;\n\tint ret;\n\n\tif (!adc->dma_chan)\n\t\treturn 0;\n\n\tdev_dbg(&indio_dev->dev, \"%s size=%d watermark=%d\\n\", __func__,\n\t\tadc->rx_buf_sz, adc->rx_buf_sz / 2);\n\n\t \n\tdesc = dmaengine_prep_dma_cyclic(adc->dma_chan,\n\t\t\t\t\t adc->rx_dma_buf,\n\t\t\t\t\t adc->rx_buf_sz, adc->rx_buf_sz / 2,\n\t\t\t\t\t DMA_DEV_TO_MEM,\n\t\t\t\t\t DMA_PREP_INTERRUPT);\n\tif (!desc)\n\t\treturn -EBUSY;\n\n\tdesc->callback = stm32_adc_dma_buffer_done;\n\tdesc->callback_param = indio_dev;\n\n\tcookie = dmaengine_submit(desc);\n\tret = dma_submit_error(cookie);\n\tif (ret) {\n\t\tdmaengine_terminate_sync(adc->dma_chan);\n\t\treturn ret;\n\t}\n\n\t \n\tdma_async_issue_pending(adc->dma_chan);\n\n\treturn 0;\n}\n\nstatic int stm32_adc_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = stm32_adc_set_trig(indio_dev, indio_dev->trig);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"Can't set trigger\\n\");\n\t\tgoto err_pm_put;\n\t}\n\n\tret = stm32_adc_dma_start(indio_dev);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"Can't start dma\\n\");\n\t\tgoto err_clr_trig;\n\t}\n\n\t \n\tadc->bufi = 0;\n\n\tstm32_adc_ovr_irq_enable(adc);\n\n\tif (!adc->dma_chan)\n\t\tstm32_adc_conv_irq_enable(adc);\n\n\tadc->cfg->start_conv(indio_dev, !!adc->dma_chan);\n\n\treturn 0;\n\nerr_clr_trig:\n\tstm32_adc_set_trig(indio_dev, NULL);\nerr_pm_put:\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nstatic int stm32_adc_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\n\tadc->cfg->stop_conv(indio_dev);\n\tif (!adc->dma_chan)\n\t\tstm32_adc_conv_irq_disable(adc);\n\n\tstm32_adc_ovr_irq_disable(adc);\n\n\tif (adc->dma_chan)\n\t\tdmaengine_terminate_sync(adc->dma_chan);\n\n\tif (stm32_adc_set_trig(indio_dev, NULL))\n\t\tdev_err(&indio_dev->dev, \"Can't clear trigger\\n\");\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops stm32_adc_buffer_setup_ops = {\n\t.postenable = &stm32_adc_buffer_postenable,\n\t.predisable = &stm32_adc_buffer_predisable,\n};\n\nstatic irqreturn_t stm32_adc_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\n\tdev_dbg(&indio_dev->dev, \"%s bufi=%d\\n\", __func__, adc->bufi);\n\n\t \n\tadc->bufi = 0;\n\tiio_push_to_buffers_with_timestamp(indio_dev, adc->buffer,\n\t\t\t\t\t   pf->timestamp);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\t \n\tstm32_adc_conv_irq_enable(adc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_chan_spec_ext_info stm32_adc_ext_info[] = {\n\tIIO_ENUM(\"trigger_polarity\", IIO_SHARED_BY_ALL, &stm32_adc_trig_pol),\n\t{\n\t\t.name = \"trigger_polarity_available\",\n\t\t.shared = IIO_SHARED_BY_ALL,\n\t\t.read = iio_enum_available_read,\n\t\t.private = (uintptr_t)&stm32_adc_trig_pol,\n\t},\n\t{},\n};\n\nstatic void stm32_adc_debugfs_init(struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tstruct dentry *d = iio_get_debugfs_dentry(indio_dev);\n\tstruct stm32_adc_calib *cal = &adc->cal;\n\tchar buf[16];\n\tunsigned int i;\n\n\tif (!adc->cfg->has_linearcal)\n\t\treturn;\n\n\tfor (i = 0; i < STM32H7_LINCALFACT_NUM; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"lincalfact%d\", i + 1);\n\t\tdebugfs_create_u32(buf, 0444, d, &cal->lincalfact[i]);\n\t}\n}\n\nstatic int stm32_adc_fw_get_resolution(struct iio_dev *indio_dev)\n{\n\tstruct device *dev = &indio_dev->dev;\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tunsigned int i;\n\tu32 res;\n\n\tif (device_property_read_u32(dev, \"assigned-resolution-bits\", &res))\n\t\tres = adc->cfg->adc_info->resolutions[0];\n\n\tfor (i = 0; i < adc->cfg->adc_info->num_res; i++)\n\t\tif (res == adc->cfg->adc_info->resolutions[i])\n\t\t\tbreak;\n\tif (i >= adc->cfg->adc_info->num_res) {\n\t\tdev_err(&indio_dev->dev, \"Bad resolution: %u bits\\n\", res);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&indio_dev->dev, \"Using %u bits resolution\\n\", res);\n\tadc->res = i;\n\n\treturn 0;\n}\n\nstatic void stm32_adc_smpr_init(struct stm32_adc *adc, int channel, u32 smp_ns)\n{\n\tconst struct stm32_adc_regs *smpr = &adc->cfg->regs->smp_bits[channel];\n\tu32 period_ns, shift = smpr->shift, mask = smpr->mask;\n\tunsigned int i, smp, r = smpr->reg;\n\n\t \n\tfor (i = 0; i < STM32_ADC_INT_CH_NB; i++)\n\t\tif (channel == adc->int_ch[i] && adc->int_ch[i] != STM32_ADC_INT_CH_NONE)\n\t\t\tsmp_ns = max(smp_ns, adc->cfg->ts_int_ch[i]);\n\n\t \n\tperiod_ns = NSEC_PER_SEC / adc->common->rate;\n\tfor (smp = 0; smp <= STM32_ADC_MAX_SMP; smp++)\n\t\tif ((period_ns * adc->cfg->smp_cycles[smp]) >= smp_ns)\n\t\t\tbreak;\n\tif (smp > STM32_ADC_MAX_SMP)\n\t\tsmp = STM32_ADC_MAX_SMP;\n\n\t \n\tadc->smpr_val[r] = (adc->smpr_val[r] & ~mask) | (smp << shift);\n}\n\nstatic void stm32_adc_chan_init_one(struct iio_dev *indio_dev,\n\t\t\t\t    struct iio_chan_spec *chan, u32 vinp,\n\t\t\t\t    u32 vinn, int scan_index, bool differential)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tchar *name = adc->chan_name[vinp];\n\n\tchan->type = IIO_VOLTAGE;\n\tchan->channel = vinp;\n\tif (differential) {\n\t\tchan->differential = 1;\n\t\tchan->channel2 = vinn;\n\t\tsnprintf(name, STM32_ADC_CH_SZ, \"in%d-in%d\", vinp, vinn);\n\t} else {\n\t\tsnprintf(name, STM32_ADC_CH_SZ, \"in%d\", vinp);\n\t}\n\tchan->datasheet_name = name;\n\tchan->scan_index = scan_index;\n\tchan->indexed = 1;\n\tif (chan->channel == adc->int_ch[STM32_ADC_INT_CH_VREFINT])\n\t\tchan->info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED);\n\telse\n\t\tchan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\n\tchan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t\t BIT(IIO_CHAN_INFO_OFFSET);\n\tchan->scan_type.sign = 'u';\n\tchan->scan_type.realbits = adc->cfg->adc_info->resolutions[adc->res];\n\tchan->scan_type.storagebits = 16;\n\tchan->ext_info = stm32_adc_ext_info;\n\n\t \n\tadc->pcsel |= BIT(chan->channel);\n\tif (differential) {\n\t\t \n\t\tadc->difsel |= BIT(chan->channel) & adc->cfg->regs->difsel.mask;\n\t\t \n\t\tadc->pcsel |= BIT(chan->channel2);\n\t}\n}\n\nstatic int stm32_adc_get_legacy_chan_count(struct iio_dev *indio_dev, struct stm32_adc *adc)\n{\n\tstruct device *dev = &indio_dev->dev;\n\tconst struct stm32_adc_info *adc_info = adc->cfg->adc_info;\n\tint num_channels = 0, ret;\n\n\tdev_dbg(&indio_dev->dev, \"using legacy channel config\\n\");\n\n\tret = device_property_count_u32(dev, \"st,adc-channels\");\n\tif (ret > adc_info->max_channels) {\n\t\tdev_err(&indio_dev->dev, \"Bad st,adc-channels?\\n\");\n\t\treturn -EINVAL;\n\t} else if (ret > 0) {\n\t\tnum_channels += ret;\n\t}\n\n\t \n\tret = device_property_count_u32(dev, \"st,adc-diff-channels\");\n\tif (ret > 0) {\n\t\tret /= (int)(sizeof(struct stm32_adc_diff_channel) / sizeof(u32));\n\t\tif (ret > adc_info->max_channels) {\n\t\t\tdev_err(&indio_dev->dev, \"Bad st,adc-diff-channels?\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else if (ret > 0) {\n\t\t\tadc->num_diff = ret;\n\t\t\tnum_channels += ret;\n\t\t}\n\t}\n\n\t \n\tadc->nsmps = device_property_count_u32(dev, \"st,min-sample-time-nsecs\");\n\tif (adc->nsmps > 1 && adc->nsmps != num_channels) {\n\t\tdev_err(&indio_dev->dev, \"Invalid st,min-sample-time-nsecs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn num_channels;\n}\n\nstatic int stm32_adc_legacy_chan_init(struct iio_dev *indio_dev,\n\t\t\t\t      struct stm32_adc *adc,\n\t\t\t\t      struct iio_chan_spec *channels,\n\t\t\t\t      int nchans)\n{\n\tconst struct stm32_adc_info *adc_info = adc->cfg->adc_info;\n\tstruct stm32_adc_diff_channel diff[STM32_ADC_CH_MAX];\n\tstruct device *dev = &indio_dev->dev;\n\tu32 num_diff = adc->num_diff;\n\tint num_se = nchans - num_diff;\n\tint size = num_diff * sizeof(*diff) / sizeof(u32);\n\tint scan_index = 0, ret, i, c;\n\tu32 smp = 0, smps[STM32_ADC_CH_MAX], chans[STM32_ADC_CH_MAX];\n\n\tif (num_diff) {\n\t\tret = device_property_read_u32_array(dev, \"st,adc-diff-channels\",\n\t\t\t\t\t\t     (u32 *)diff, size);\n\t\tif (ret) {\n\t\t\tdev_err(&indio_dev->dev, \"Failed to get diff channels %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < num_diff; i++) {\n\t\t\tif (diff[i].vinp >= adc_info->max_channels ||\n\t\t\t    diff[i].vinn >= adc_info->max_channels) {\n\t\t\t\tdev_err(&indio_dev->dev, \"Invalid channel in%d-in%d\\n\",\n\t\t\t\t\tdiff[i].vinp, diff[i].vinn);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tstm32_adc_chan_init_one(indio_dev, &channels[scan_index],\n\t\t\t\t\t\tdiff[i].vinp, diff[i].vinn,\n\t\t\t\t\t\tscan_index, true);\n\t\t\tscan_index++;\n\t\t}\n\t}\n\tif (num_se > 0) {\n\t\tret = device_property_read_u32_array(dev, \"st,adc-channels\", chans, num_se);\n\t\tif (ret) {\n\t\t\tdev_err(&indio_dev->dev, \"Failed to get st,adc-channels %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (c = 0; c < num_se; c++) {\n\t\t\tif (chans[c] >= adc_info->max_channels) {\n\t\t\t\tdev_err(&indio_dev->dev, \"Invalid channel %d\\n\",\n\t\t\t\t\tchans[c]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (i = 0; i < num_diff; i++) {\n\t\t\t\tif (chans[c] == diff[i].vinp) {\n\t\t\t\t\tdev_err(&indio_dev->dev, \"channel %d misconfigured\\n\",\n\t\t\t\t\t\tchans[c]);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstm32_adc_chan_init_one(indio_dev, &channels[scan_index],\n\t\t\t\t\t\tchans[c], 0, scan_index, false);\n\t\t\tscan_index++;\n\t\t}\n\t}\n\n\tif (adc->nsmps > 0) {\n\t\tret = device_property_read_u32_array(dev, \"st,min-sample-time-nsecs\",\n\t\t\t\t\t\t     smps, adc->nsmps);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < scan_index; i++) {\n\t\t \n\t\tif (i < adc->nsmps)\n\t\t\tsmp = smps[i];\n\n\t\t \n\t\tstm32_adc_smpr_init(adc, channels[i].channel, smp);\n\t}\n\n\treturn scan_index;\n}\n\nstatic int stm32_adc_populate_int_ch(struct iio_dev *indio_dev, const char *ch_name,\n\t\t\t\t     int chan)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tu16 vrefint;\n\tint i, ret;\n\n\tfor (i = 0; i < STM32_ADC_INT_CH_NB; i++) {\n\t\tif (!strncmp(stm32_adc_ic[i].name, ch_name, STM32_ADC_CH_SZ)) {\n\t\t\t \n\t\t\tswitch (i) {\n\t\t\tcase STM32_ADC_INT_CH_VDDCORE:\n\t\t\t\tif (!adc->cfg->regs->or_vddcore.reg)\n\t\t\t\t\tdev_warn(&indio_dev->dev,\n\t\t\t\t\t\t \"%s channel not available\\n\", ch_name);\n\t\t\t\tbreak;\n\t\t\tcase STM32_ADC_INT_CH_VDDCPU:\n\t\t\t\tif (!adc->cfg->regs->or_vddcpu.reg)\n\t\t\t\t\tdev_warn(&indio_dev->dev,\n\t\t\t\t\t\t \"%s channel not available\\n\", ch_name);\n\t\t\t\tbreak;\n\t\t\tcase STM32_ADC_INT_CH_VDDQ_DDR:\n\t\t\t\tif (!adc->cfg->regs->or_vddq_ddr.reg)\n\t\t\t\t\tdev_warn(&indio_dev->dev,\n\t\t\t\t\t\t \"%s channel not available\\n\", ch_name);\n\t\t\t\tbreak;\n\t\t\tcase STM32_ADC_INT_CH_VREFINT:\n\t\t\t\tif (!adc->cfg->regs->ccr_vref.reg)\n\t\t\t\t\tdev_warn(&indio_dev->dev,\n\t\t\t\t\t\t \"%s channel not available\\n\", ch_name);\n\t\t\t\tbreak;\n\t\t\tcase STM32_ADC_INT_CH_VBAT:\n\t\t\t\tif (!adc->cfg->regs->ccr_vbat.reg)\n\t\t\t\t\tdev_warn(&indio_dev->dev,\n\t\t\t\t\t\t \"%s channel not available\\n\", ch_name);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (stm32_adc_ic[i].idx != STM32_ADC_INT_CH_VREFINT) {\n\t\t\t\tadc->int_ch[i] = chan;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = nvmem_cell_read_u16(&indio_dev->dev, \"vrefint\", &vrefint);\n\t\t\tif (ret && ret != -ENOENT) {\n\t\t\t\treturn dev_err_probe(indio_dev->dev.parent, ret,\n\t\t\t\t\t\t     \"nvmem access error\\n\");\n\t\t\t}\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\tdev_dbg(&indio_dev->dev, \"vrefint calibration not found. Skip vrefint channel\\n\");\n\t\t\t\treturn ret;\n\t\t\t} else if (!vrefint) {\n\t\t\t\tdev_dbg(&indio_dev->dev, \"Null vrefint calibration value. Skip vrefint channel\\n\");\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t\tadc->int_ch[i] = chan;\n\t\t\tadc->vrefint.vrefint_cal = vrefint;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_adc_generic_chan_init(struct iio_dev *indio_dev,\n\t\t\t\t       struct stm32_adc *adc,\n\t\t\t\t       struct iio_chan_spec *channels)\n{\n\tconst struct stm32_adc_info *adc_info = adc->cfg->adc_info;\n\tstruct fwnode_handle *child;\n\tconst char *name;\n\tint val, scan_index = 0, ret;\n\tbool differential;\n\tu32 vin[2];\n\n\tdevice_for_each_child_node(&indio_dev->dev, child) {\n\t\tret = fwnode_property_read_u32(child, \"reg\", &val);\n\t\tif (ret) {\n\t\t\tdev_err(&indio_dev->dev, \"Missing channel index %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = fwnode_property_read_string(child, \"label\", &name);\n\t\t \n\t\tif (!ret) {\n\t\t\tif (strlen(name) >= STM32_ADC_CH_SZ) {\n\t\t\t\tdev_err(&indio_dev->dev, \"Label %s exceeds %d characters\\n\",\n\t\t\t\t\tname, STM32_ADC_CH_SZ);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tstrncpy(adc->chan_name[val], name, STM32_ADC_CH_SZ);\n\t\t\tret = stm32_adc_populate_int_ch(indio_dev, name, val);\n\t\t\tif (ret == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse if (ret)\n\t\t\t\tgoto err;\n\t\t} else if (ret != -EINVAL) {\n\t\t\tdev_err(&indio_dev->dev, \"Invalid label %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (val >= adc_info->max_channels) {\n\t\t\tdev_err(&indio_dev->dev, \"Invalid channel %d\\n\", val);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tdifferential = false;\n\t\tret = fwnode_property_read_u32_array(child, \"diff-channels\", vin, 2);\n\t\t \n\t\tif (!ret) {\n\t\t\tdifferential = true;\n\t\t\tif (vin[0] != val || vin[1] >= adc_info->max_channels) {\n\t\t\t\tdev_err(&indio_dev->dev, \"Invalid channel in%d-in%d\\n\",\n\t\t\t\t\tvin[0], vin[1]);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else if (ret != -EINVAL) {\n\t\t\tdev_err(&indio_dev->dev, \"Invalid diff-channels property %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tstm32_adc_chan_init_one(indio_dev, &channels[scan_index], val,\n\t\t\t\t\tvin[1], scan_index, differential);\n\n\t\tval = 0;\n\t\tret = fwnode_property_read_u32(child, \"st,min-sample-time-ns\", &val);\n\t\t \n\t\tif (ret && ret != -EINVAL) {\n\t\t\tdev_err(&indio_dev->dev, \"Invalid st,min-sample-time-ns property %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tstm32_adc_smpr_init(adc, channels[scan_index].channel, val);\n\t\tif (differential)\n\t\t\tstm32_adc_smpr_init(adc, vin[1], val);\n\n\t\tscan_index++;\n\t}\n\n\treturn scan_index;\n\nerr:\n\tfwnode_handle_put(child);\n\n\treturn ret;\n}\n\nstatic int stm32_adc_chan_fw_init(struct iio_dev *indio_dev, bool timestamping)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tconst struct stm32_adc_info *adc_info = adc->cfg->adc_info;\n\tstruct iio_chan_spec *channels;\n\tint scan_index = 0, num_channels = 0, ret, i;\n\tbool legacy = false;\n\n\tfor (i = 0; i < STM32_ADC_INT_CH_NB; i++)\n\t\tadc->int_ch[i] = STM32_ADC_INT_CH_NONE;\n\n\tnum_channels = device_get_child_node_count(&indio_dev->dev);\n\t \n\tif (!num_channels) {\n\t\tlegacy = true;\n\n\t\tret = stm32_adc_get_legacy_chan_count(indio_dev, adc);\n\t\tif (!ret) {\n\t\t\tdev_err(indio_dev->dev.parent, \"No channel found\\n\");\n\t\t\treturn -ENODATA;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tnum_channels = ret;\n\t}\n\n\tif (num_channels > adc_info->max_channels) {\n\t\tdev_err(&indio_dev->dev, \"Channel number [%d] exceeds %d\\n\",\n\t\t\tnum_channels, adc_info->max_channels);\n\t\treturn -EINVAL;\n\t}\n\n\tif (timestamping)\n\t\tnum_channels++;\n\n\tchannels = devm_kcalloc(&indio_dev->dev, num_channels,\n\t\t\t\tsizeof(struct iio_chan_spec), GFP_KERNEL);\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\tif (legacy)\n\t\tret = stm32_adc_legacy_chan_init(indio_dev, adc, channels,\n\t\t\t\t\t\t timestamping ? num_channels - 1 : num_channels);\n\telse\n\t\tret = stm32_adc_generic_chan_init(indio_dev, adc, channels);\n\tif (ret < 0)\n\t\treturn ret;\n\tscan_index = ret;\n\n\tif (timestamping) {\n\t\tstruct iio_chan_spec *timestamp = &channels[scan_index];\n\n\t\ttimestamp->type = IIO_TIMESTAMP;\n\t\ttimestamp->channel = -1;\n\t\ttimestamp->scan_index = scan_index;\n\t\ttimestamp->scan_type.sign = 's';\n\t\ttimestamp->scan_type.realbits = 64;\n\t\ttimestamp->scan_type.storagebits = 64;\n\n\t\tscan_index++;\n\t}\n\n\tindio_dev->num_channels = scan_index;\n\tindio_dev->channels = channels;\n\n\treturn 0;\n}\n\nstatic int stm32_adc_dma_request(struct device *dev, struct iio_dev *indio_dev)\n{\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\tstruct dma_slave_config config;\n\tint ret;\n\n\tadc->dma_chan = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(adc->dma_chan)) {\n\t\tret = PTR_ERR(adc->dma_chan);\n\t\tif (ret != -ENODEV)\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"DMA channel request failed with\\n\");\n\n\t\t \n\t\tadc->dma_chan = NULL;\n\t\treturn 0;\n\t}\n\n\tadc->rx_buf = dma_alloc_coherent(adc->dma_chan->device->dev,\n\t\t\t\t\t STM32_DMA_BUFFER_SIZE,\n\t\t\t\t\t &adc->rx_dma_buf, GFP_KERNEL);\n\tif (!adc->rx_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_release;\n\t}\n\n\t \n\tmemset(&config, 0, sizeof(config));\n\tconfig.src_addr = (dma_addr_t)adc->common->phys_base;\n\tconfig.src_addr += adc->offset + adc->cfg->regs->dr;\n\tconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\n\tret = dmaengine_slave_config(adc->dma_chan, &config);\n\tif (ret)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tdma_free_coherent(adc->dma_chan->device->dev, STM32_DMA_BUFFER_SIZE,\n\t\t\t  adc->rx_buf, adc->rx_dma_buf);\nerr_release:\n\tdma_release_channel(adc->dma_chan);\n\n\treturn ret;\n}\n\nstatic int stm32_adc_probe(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct device *dev = &pdev->dev;\n\tirqreturn_t (*handler)(int irq, void *p) = NULL;\n\tstruct stm32_adc *adc;\n\tbool timestamping = false;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\tadc->common = dev_get_drvdata(pdev->dev.parent);\n\tspin_lock_init(&adc->lock);\n\tinit_completion(&adc->completion);\n\tadc->cfg = device_get_match_data(dev);\n\n\tindio_dev->name = dev_name(&pdev->dev);\n\tdevice_set_node(&indio_dev->dev, dev_fwnode(&pdev->dev));\n\tindio_dev->info = &stm32_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE | INDIO_HARDWARE_TRIGGERED;\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tret = device_property_read_u32(dev, \"reg\", &adc->offset);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"missing reg property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tadc->irq = platform_get_irq(pdev, 0);\n\tif (adc->irq < 0)\n\t\treturn adc->irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, adc->irq, stm32_adc_isr,\n\t\t\t\t\tstm32_adc_threaded_isr,\n\t\t\t\t\t0, pdev->name, indio_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tadc->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(adc->clk)) {\n\t\tret = PTR_ERR(adc->clk);\n\t\tif (ret == -ENOENT && !adc->cfg->clk_required) {\n\t\t\tadc->clk = NULL;\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"Can't get clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = stm32_adc_fw_get_resolution(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = stm32_adc_dma_request(dev, indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!adc->dma_chan) {\n\t\t \n\t\thandler = &stm32_adc_trigger_handler;\n\t\ttimestamping = true;\n\t}\n\n\tret = stm32_adc_chan_fw_init(indio_dev, timestamping);\n\tif (ret < 0)\n\t\tgoto err_dma_disable;\n\n\tret = iio_triggered_buffer_setup(indio_dev,\n\t\t\t\t\t &iio_pollfunc_store_time, handler,\n\t\t\t\t\t &stm32_adc_buffer_setup_ops);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"buffer setup failed\\n\");\n\t\tgoto err_dma_disable;\n\t}\n\n\t \n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_set_autosuspend_delay(dev, STM32_ADC_HW_STOP_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n\n\tret = stm32_adc_hw_start(dev);\n\tif (ret)\n\t\tgoto err_buffer_cleanup;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"iio dev register failed\\n\");\n\t\tgoto err_hw_stop;\n\t}\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\tstm32_adc_debugfs_init(indio_dev);\n\n\treturn 0;\n\nerr_hw_stop:\n\tstm32_adc_hw_stop(dev);\n\nerr_buffer_cleanup:\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_put_noidle(dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\nerr_dma_disable:\n\tif (adc->dma_chan) {\n\t\tdma_free_coherent(adc->dma_chan->device->dev,\n\t\t\t\t  STM32_DMA_BUFFER_SIZE,\n\t\t\t\t  adc->rx_buf, adc->rx_dma_buf);\n\t\tdma_release_channel(adc->dma_chan);\n\t}\n\n\treturn ret;\n}\n\nstatic int stm32_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct stm32_adc *adc = iio_priv(indio_dev);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\t \n\tiio_device_unregister(indio_dev);\n\tstm32_adc_hw_stop(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tif (adc->dma_chan) {\n\t\tdma_free_coherent(adc->dma_chan->device->dev,\n\t\t\t\t  STM32_DMA_BUFFER_SIZE,\n\t\t\t\t  adc->rx_buf, adc->rx_dma_buf);\n\t\tdma_release_channel(adc->dma_chan);\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_adc_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\n\tif (iio_buffer_enabled(indio_dev))\n\t\tstm32_adc_buffer_predisable(indio_dev);\n\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int stm32_adc_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!iio_buffer_enabled(indio_dev))\n\t\treturn 0;\n\n\tret = stm32_adc_update_scan_mode(indio_dev,\n\t\t\t\t\t indio_dev->active_scan_mask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn stm32_adc_buffer_postenable(indio_dev);\n}\n\nstatic int stm32_adc_runtime_suspend(struct device *dev)\n{\n\treturn stm32_adc_hw_stop(dev);\n}\n\nstatic int stm32_adc_runtime_resume(struct device *dev)\n{\n\treturn stm32_adc_hw_start(dev);\n}\n\nstatic const struct dev_pm_ops stm32_adc_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(stm32_adc_suspend, stm32_adc_resume)\n\tRUNTIME_PM_OPS(stm32_adc_runtime_suspend, stm32_adc_runtime_resume,\n\t\t       NULL)\n};\n\nstatic const struct stm32_adc_cfg stm32f4_adc_cfg = {\n\t.regs = &stm32f4_adc_regspec,\n\t.adc_info = &stm32f4_adc_info,\n\t.trigs = stm32f4_adc_trigs,\n\t.clk_required = true,\n\t.start_conv = stm32f4_adc_start_conv,\n\t.stop_conv = stm32f4_adc_stop_conv,\n\t.smp_cycles = stm32f4_adc_smp_cycles,\n\t.irq_clear = stm32f4_adc_irq_clear,\n};\n\nstatic const unsigned int stm32_adc_min_ts_h7[] = { 0, 0, 0, 4300, 9000 };\nstatic_assert(ARRAY_SIZE(stm32_adc_min_ts_h7) == STM32_ADC_INT_CH_NB);\n\nstatic const struct stm32_adc_cfg stm32h7_adc_cfg = {\n\t.regs = &stm32h7_adc_regspec,\n\t.adc_info = &stm32h7_adc_info,\n\t.trigs = stm32h7_adc_trigs,\n\t.has_boostmode = true,\n\t.has_linearcal = true,\n\t.has_presel = true,\n\t.start_conv = stm32h7_adc_start_conv,\n\t.stop_conv = stm32h7_adc_stop_conv,\n\t.prepare = stm32h7_adc_prepare,\n\t.unprepare = stm32h7_adc_unprepare,\n\t.smp_cycles = stm32h7_adc_smp_cycles,\n\t.irq_clear = stm32h7_adc_irq_clear,\n\t.ts_int_ch = stm32_adc_min_ts_h7,\n};\n\nstatic const unsigned int stm32_adc_min_ts_mp1[] = { 100, 100, 100, 4300, 9800 };\nstatic_assert(ARRAY_SIZE(stm32_adc_min_ts_mp1) == STM32_ADC_INT_CH_NB);\n\nstatic const struct stm32_adc_cfg stm32mp1_adc_cfg = {\n\t.regs = &stm32mp1_adc_regspec,\n\t.adc_info = &stm32h7_adc_info,\n\t.trigs = stm32h7_adc_trigs,\n\t.has_vregready = true,\n\t.has_boostmode = true,\n\t.has_linearcal = true,\n\t.has_presel = true,\n\t.start_conv = stm32h7_adc_start_conv,\n\t.stop_conv = stm32h7_adc_stop_conv,\n\t.prepare = stm32h7_adc_prepare,\n\t.unprepare = stm32h7_adc_unprepare,\n\t.smp_cycles = stm32h7_adc_smp_cycles,\n\t.irq_clear = stm32h7_adc_irq_clear,\n\t.ts_int_ch = stm32_adc_min_ts_mp1,\n};\n\nstatic const unsigned int stm32_adc_min_ts_mp13[] = { 100, 0, 0, 4300, 9800 };\nstatic_assert(ARRAY_SIZE(stm32_adc_min_ts_mp13) == STM32_ADC_INT_CH_NB);\n\nstatic const struct stm32_adc_cfg stm32mp13_adc_cfg = {\n\t.regs = &stm32mp13_adc_regspec,\n\t.adc_info = &stm32mp13_adc_info,\n\t.trigs = stm32h7_adc_trigs,\n\t.start_conv = stm32mp13_adc_start_conv,\n\t.stop_conv = stm32h7_adc_stop_conv,\n\t.prepare = stm32h7_adc_prepare,\n\t.unprepare = stm32h7_adc_unprepare,\n\t.smp_cycles = stm32mp13_adc_smp_cycles,\n\t.irq_clear = stm32h7_adc_irq_clear,\n\t.ts_int_ch = stm32_adc_min_ts_mp13,\n};\n\nstatic const struct of_device_id stm32_adc_of_match[] = {\n\t{ .compatible = \"st,stm32f4-adc\", .data = (void *)&stm32f4_adc_cfg },\n\t{ .compatible = \"st,stm32h7-adc\", .data = (void *)&stm32h7_adc_cfg },\n\t{ .compatible = \"st,stm32mp1-adc\", .data = (void *)&stm32mp1_adc_cfg },\n\t{ .compatible = \"st,stm32mp13-adc\", .data = (void *)&stm32mp13_adc_cfg },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_adc_of_match);\n\nstatic struct platform_driver stm32_adc_driver = {\n\t.probe = stm32_adc_probe,\n\t.remove = stm32_adc_remove,\n\t.driver = {\n\t\t.name = \"stm32-adc\",\n\t\t.of_match_table = stm32_adc_of_match,\n\t\t.pm = pm_ptr(&stm32_adc_pm_ops),\n\t},\n};\nmodule_platform_driver(stm32_adc_driver);\n\nMODULE_AUTHOR(\"Fabrice Gasnier <fabrice.gasnier@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 ADC IIO driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:stm32-adc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}