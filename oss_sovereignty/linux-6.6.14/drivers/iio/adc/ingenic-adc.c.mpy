{
  "module_name": "ingenic-adc.c",
  "hash_id": "a7e5732a362f6fcc660ecda7ef70243ebf78be6086a189057a4d69cc34f4acee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ingenic-adc.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/iio/adc/ingenic,adc.h>\n#include <linux/clk.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#define JZ_ADC_REG_ENABLE\t\t0x00\n#define JZ_ADC_REG_CFG\t\t\t0x04\n#define JZ_ADC_REG_CTRL\t\t\t0x08\n#define JZ_ADC_REG_STATUS\t\t0x0c\n#define JZ_ADC_REG_ADSAME\t\t0x10\n#define JZ_ADC_REG_ADWAIT\t\t0x14\n#define JZ_ADC_REG_ADTCH\t\t0x18\n#define JZ_ADC_REG_ADBDAT\t\t0x1c\n#define JZ_ADC_REG_ADSDAT\t\t0x20\n#define JZ_ADC_REG_ADCMD\t\t0x24\n#define JZ_ADC_REG_ADCLK\t\t0x28\n\n#define JZ_ADC_REG_ENABLE_PD\t\tBIT(7)\n#define JZ_ADC_REG_CFG_AUX_MD\t\t(BIT(0) | BIT(1))\n#define JZ_ADC_REG_CFG_BAT_MD\t\tBIT(4)\n#define JZ_ADC_REG_CFG_SAMPLE_NUM(n)\t((n) << 10)\n#define JZ_ADC_REG_CFG_PULL_UP(n)\t((n) << 16)\n#define JZ_ADC_REG_CFG_CMD_SEL\t\tBIT(22)\n#define JZ_ADC_REG_CFG_VBAT_SEL\t\tBIT(30)\n#define JZ_ADC_REG_CFG_TOUCH_OPS_MASK\t(BIT(31) | GENMASK(23, 10))\n#define JZ_ADC_REG_ADCLK_CLKDIV_LSB\t0\n#define JZ4725B_ADC_REG_ADCLK_CLKDIV10US_LSB\t16\n#define JZ4770_ADC_REG_ADCLK_CLKDIV10US_LSB\t8\n#define JZ4770_ADC_REG_ADCLK_CLKDIVMS_LSB\t16\n\n#define JZ_ADC_REG_ADCMD_YNADC\t\tBIT(7)\n#define JZ_ADC_REG_ADCMD_YPADC\t\tBIT(8)\n#define JZ_ADC_REG_ADCMD_XNADC\t\tBIT(9)\n#define JZ_ADC_REG_ADCMD_XPADC\t\tBIT(10)\n#define JZ_ADC_REG_ADCMD_VREFPYP\tBIT(11)\n#define JZ_ADC_REG_ADCMD_VREFPXP\tBIT(12)\n#define JZ_ADC_REG_ADCMD_VREFPXN\tBIT(13)\n#define JZ_ADC_REG_ADCMD_VREFPAUX\tBIT(14)\n#define JZ_ADC_REG_ADCMD_VREFPVDD33\tBIT(15)\n#define JZ_ADC_REG_ADCMD_VREFNYN\tBIT(16)\n#define JZ_ADC_REG_ADCMD_VREFNXP\tBIT(17)\n#define JZ_ADC_REG_ADCMD_VREFNXN\tBIT(18)\n#define JZ_ADC_REG_ADCMD_VREFAUX\tBIT(19)\n#define JZ_ADC_REG_ADCMD_YNGRU\t\tBIT(20)\n#define JZ_ADC_REG_ADCMD_XNGRU\t\tBIT(21)\n#define JZ_ADC_REG_ADCMD_XPGRU\t\tBIT(22)\n#define JZ_ADC_REG_ADCMD_YPSUP\t\tBIT(23)\n#define JZ_ADC_REG_ADCMD_XNSUP\t\tBIT(24)\n#define JZ_ADC_REG_ADCMD_XPSUP\t\tBIT(25)\n\n#define JZ_ADC_AUX_VREF\t\t\t\t3300\n#define JZ_ADC_AUX_VREF_BITS\t\t\t12\n#define JZ_ADC_BATTERY_LOW_VREF\t\t\t2500\n#define JZ_ADC_BATTERY_LOW_VREF_BITS\t\t12\n#define JZ4725B_ADC_BATTERY_HIGH_VREF\t\t7500\n#define JZ4725B_ADC_BATTERY_HIGH_VREF_BITS\t10\n#define JZ4740_ADC_BATTERY_HIGH_VREF\t\t(7500 * 0.986)\n#define JZ4740_ADC_BATTERY_HIGH_VREF_BITS\t12\n#define JZ4760_ADC_BATTERY_VREF\t\t\t2500\n#define JZ4770_ADC_BATTERY_VREF\t\t\t1200\n#define JZ4770_ADC_BATTERY_VREF_BITS\t\t12\n\n#define JZ_ADC_IRQ_AUX\t\t\tBIT(0)\n#define JZ_ADC_IRQ_BATTERY\t\tBIT(1)\n#define JZ_ADC_IRQ_TOUCH\t\tBIT(2)\n#define JZ_ADC_IRQ_PEN_DOWN\t\tBIT(3)\n#define JZ_ADC_IRQ_PEN_UP\t\tBIT(4)\n#define JZ_ADC_IRQ_PEN_DOWN_SLEEP\tBIT(5)\n#define JZ_ADC_IRQ_SLEEP\t\tBIT(7)\n\nstruct ingenic_adc;\n\nstruct ingenic_adc_soc_data {\n\tunsigned int battery_high_vref;\n\tunsigned int battery_high_vref_bits;\n\tconst int *battery_raw_avail;\n\tsize_t battery_raw_avail_size;\n\tconst int *battery_scale_avail;\n\tsize_t battery_scale_avail_size;\n\tunsigned int battery_vref_mode: 1;\n\tunsigned int has_aux_md: 1;\n\tconst struct iio_chan_spec *channels;\n\tunsigned int num_channels;\n\tint (*init_clk_div)(struct device *dev, struct ingenic_adc *adc);\n};\n\nstruct ingenic_adc {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct mutex lock;\n\tstruct mutex aux_lock;\n\tconst struct ingenic_adc_soc_data *soc_data;\n\tbool low_vref_mode;\n};\n\nstatic void ingenic_adc_set_adcmd(struct iio_dev *iio_dev, unsigned long mask)\n{\n\tstruct ingenic_adc *adc = iio_priv(iio_dev);\n\n\tmutex_lock(&adc->lock);\n\n\t \n\treadl(adc->base + JZ_ADC_REG_ADCMD);\n\n\tif (mask & 0x3) {\n\t\t \n\t\twritel(JZ_ADC_REG_ADCMD_XNGRU\n\t\t       | JZ_ADC_REG_ADCMD_VREFNXN | JZ_ADC_REG_ADCMD_VREFPVDD33\n\t\t       | JZ_ADC_REG_ADCMD_YPADC,\n\t\t       adc->base + JZ_ADC_REG_ADCMD);\n\n\t\t \n\t\twritel(JZ_ADC_REG_ADCMD_YNGRU\n\t\t       | JZ_ADC_REG_ADCMD_VREFNYN | JZ_ADC_REG_ADCMD_VREFPVDD33\n\t\t       | JZ_ADC_REG_ADCMD_XPADC,\n\t\t       adc->base + JZ_ADC_REG_ADCMD);\n\t}\n\n\tif (mask & 0xc) {\n\t\t \n\t\twritel(JZ_ADC_REG_ADCMD_XNGRU\n\t\t       | JZ_ADC_REG_ADCMD_VREFNXN | JZ_ADC_REG_ADCMD_VREFPVDD33\n\t\t       | JZ_ADC_REG_ADCMD_YNADC,\n\t\t       adc->base + JZ_ADC_REG_ADCMD);\n\n\t\t \n\t\twritel(JZ_ADC_REG_ADCMD_YNGRU\n\t\t       | JZ_ADC_REG_ADCMD_VREFNYN | JZ_ADC_REG_ADCMD_VREFPVDD33\n\t\t       | JZ_ADC_REG_ADCMD_XNADC,\n\t\t       adc->base + JZ_ADC_REG_ADCMD);\n\t}\n\n\tif (mask & 0x30) {\n\t\t \n\t\twritel(JZ_ADC_REG_ADCMD_VREFNYN | JZ_ADC_REG_ADCMD_VREFPVDD33\n\t\t       | JZ_ADC_REG_ADCMD_YPADC,\n\t\t       adc->base + JZ_ADC_REG_ADCMD);\n\n\t\t \n\t\twritel(JZ_ADC_REG_ADCMD_VREFNXN | JZ_ADC_REG_ADCMD_VREFPVDD33\n\t\t       | JZ_ADC_REG_ADCMD_XPADC,\n\t\t       adc->base + JZ_ADC_REG_ADCMD);\n\t}\n\n\t \n\twritel(0, adc->base + JZ_ADC_REG_ADCMD);\n\n\tmutex_unlock(&adc->lock);\n}\n\nstatic void ingenic_adc_set_config(struct ingenic_adc *adc,\n\t\t\t\t   uint32_t mask,\n\t\t\t\t   uint32_t val)\n{\n\tuint32_t cfg;\n\n\tmutex_lock(&adc->lock);\n\n\tcfg = readl(adc->base + JZ_ADC_REG_CFG) & ~mask;\n\tcfg |= val;\n\twritel(cfg, adc->base + JZ_ADC_REG_CFG);\n\n\tmutex_unlock(&adc->lock);\n}\n\nstatic void ingenic_adc_enable_unlocked(struct ingenic_adc *adc,\n\t\t\t\t\tint engine,\n\t\t\t\t\tbool enabled)\n{\n\tu8 val;\n\n\tval = readb(adc->base + JZ_ADC_REG_ENABLE);\n\n\tif (enabled)\n\t\tval |= BIT(engine);\n\telse\n\t\tval &= ~BIT(engine);\n\n\twriteb(val, adc->base + JZ_ADC_REG_ENABLE);\n}\n\nstatic void ingenic_adc_enable(struct ingenic_adc *adc,\n\t\t\t       int engine,\n\t\t\t       bool enabled)\n{\n\tmutex_lock(&adc->lock);\n\tingenic_adc_enable_unlocked(adc, engine, enabled);\n\tmutex_unlock(&adc->lock);\n}\n\nstatic int ingenic_adc_capture(struct ingenic_adc *adc,\n\t\t\t       int engine)\n{\n\tu32 cfg;\n\tu8 val;\n\tint ret;\n\n\t \n\tmutex_lock(&adc->lock);\n\tcfg = readl(adc->base + JZ_ADC_REG_CFG);\n\twritel(cfg & ~JZ_ADC_REG_CFG_CMD_SEL, adc->base + JZ_ADC_REG_CFG);\n\n\tingenic_adc_enable_unlocked(adc, engine, true);\n\tret = readb_poll_timeout(adc->base + JZ_ADC_REG_ENABLE, val,\n\t\t\t\t !(val & BIT(engine)), 250, 1000);\n\tif (ret)\n\t\tingenic_adc_enable_unlocked(adc, engine, false);\n\n\twritel(cfg, adc->base + JZ_ADC_REG_CFG);\n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n\nstatic int ingenic_adc_write_raw(struct iio_dev *iio_dev,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int val,\n\t\t\t\t int val2,\n\t\t\t\t long m)\n{\n\tstruct ingenic_adc *adc = iio_priv(iio_dev);\n\tstruct device *dev = iio_dev->dev.parent;\n\tint ret;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->channel) {\n\t\tcase INGENIC_ADC_BATTERY:\n\t\t\tif (!adc->soc_data->battery_vref_mode)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tret = clk_enable(adc->clk);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Failed to enable clock: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (val > JZ_ADC_BATTERY_LOW_VREF) {\n\t\t\t\tingenic_adc_set_config(adc,\n\t\t\t\t\t\t       JZ_ADC_REG_CFG_BAT_MD,\n\t\t\t\t\t\t       0);\n\t\t\t\tadc->low_vref_mode = false;\n\t\t\t} else {\n\t\t\t\tingenic_adc_set_config(adc,\n\t\t\t\t\t\t       JZ_ADC_REG_CFG_BAT_MD,\n\t\t\t\t\t\t       JZ_ADC_REG_CFG_BAT_MD);\n\t\t\t\tadc->low_vref_mode = true;\n\t\t\t}\n\n\t\t\tclk_disable(adc->clk);\n\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const int jz4725b_adc_battery_raw_avail[] = {\n\t0, 1, (1 << JZ_ADC_BATTERY_LOW_VREF_BITS) - 1,\n};\n\nstatic const int jz4725b_adc_battery_scale_avail[] = {\n\tJZ4725B_ADC_BATTERY_HIGH_VREF, JZ4725B_ADC_BATTERY_HIGH_VREF_BITS,\n\tJZ_ADC_BATTERY_LOW_VREF, JZ_ADC_BATTERY_LOW_VREF_BITS,\n};\n\nstatic const int jz4740_adc_battery_raw_avail[] = {\n\t0, 1, (1 << JZ_ADC_BATTERY_LOW_VREF_BITS) - 1,\n};\n\nstatic const int jz4740_adc_battery_scale_avail[] = {\n\tJZ4740_ADC_BATTERY_HIGH_VREF, JZ4740_ADC_BATTERY_HIGH_VREF_BITS,\n\tJZ_ADC_BATTERY_LOW_VREF, JZ_ADC_BATTERY_LOW_VREF_BITS,\n};\n\nstatic const int jz4760_adc_battery_scale_avail[] = {\n\tJZ4760_ADC_BATTERY_VREF, JZ4770_ADC_BATTERY_VREF_BITS,\n};\n\nstatic const int jz4770_adc_battery_raw_avail[] = {\n\t0, 1, (1 << JZ4770_ADC_BATTERY_VREF_BITS) - 1,\n};\n\nstatic const int jz4770_adc_battery_scale_avail[] = {\n\tJZ4770_ADC_BATTERY_VREF, JZ4770_ADC_BATTERY_VREF_BITS,\n};\n\nstatic int jz4725b_adc_init_clk_div(struct device *dev, struct ingenic_adc *adc)\n{\n\tstruct clk *parent_clk;\n\tunsigned long parent_rate, rate;\n\tunsigned int div_main, div_10us;\n\n\tparent_clk = clk_get_parent(adc->clk);\n\tif (!parent_clk) {\n\t\tdev_err(dev, \"ADC clock has no parent\\n\");\n\t\treturn -ENODEV;\n\t}\n\tparent_rate = clk_get_rate(parent_clk);\n\n\t \n\tdiv_main = DIV_ROUND_UP(parent_rate, 8000000);\n\tdiv_main = clamp(div_main, 1u, 64u);\n\trate = parent_rate / div_main;\n\tif (rate < 500000 || rate > 8000000) {\n\t\tdev_err(dev, \"No valid divider for ADC main clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdiv_10us = DIV_ROUND_UP(rate, 100000);\n\n\twritel(((div_10us - 1) << JZ4725B_ADC_REG_ADCLK_CLKDIV10US_LSB) |\n\t       (div_main - 1) << JZ_ADC_REG_ADCLK_CLKDIV_LSB,\n\t       adc->base + JZ_ADC_REG_ADCLK);\n\n\treturn 0;\n}\n\nstatic int jz4770_adc_init_clk_div(struct device *dev, struct ingenic_adc *adc)\n{\n\tstruct clk *parent_clk;\n\tunsigned long parent_rate, rate;\n\tunsigned int div_main, div_ms, div_10us;\n\n\tparent_clk = clk_get_parent(adc->clk);\n\tif (!parent_clk) {\n\t\tdev_err(dev, \"ADC clock has no parent\\n\");\n\t\treturn -ENODEV;\n\t}\n\tparent_rate = clk_get_rate(parent_clk);\n\n\t \n\tdiv_main = DIV_ROUND_UP(parent_rate, 200000);\n\tdiv_main = clamp(div_main, 1u, 256u);\n\trate = parent_rate / div_main;\n\tif (rate < 20000 || rate > 200000) {\n\t\tdev_err(dev, \"No valid divider for ADC main clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdiv_10us = DIV_ROUND_UP(rate, 10000);\n\t \n\tdiv_ms = DIV_ROUND_UP(rate, 1000);\n\n\twritel(((div_ms - 1) << JZ4770_ADC_REG_ADCLK_CLKDIVMS_LSB) |\n\t       ((div_10us - 1) << JZ4770_ADC_REG_ADCLK_CLKDIV10US_LSB) |\n\t       (div_main - 1) << JZ_ADC_REG_ADCLK_CLKDIV_LSB,\n\t       adc->base + JZ_ADC_REG_ADCLK);\n\n\treturn 0;\n}\n\nstatic const struct iio_chan_spec jz4740_channels[] = {\n\t{\n\t\t.extend_name = \"aux\",\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_AUX,\n\t\t.scan_index = -1,\n\t},\n\t{\n\t\t.extend_name = \"battery\",\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_BATTERY,\n\t\t.scan_index = -1,\n\t},\n};\n\nstatic const struct iio_chan_spec jz4760_channels[] = {\n\t{\n\t\t.extend_name = \"aux\",\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_AUX0,\n\t\t.scan_index = -1,\n\t},\n\t{\n\t\t.extend_name = \"aux1\",\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_AUX,\n\t\t.scan_index = -1,\n\t},\n\t{\n\t\t.extend_name = \"aux2\",\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_AUX2,\n\t\t.scan_index = -1,\n\t},\n\t{\n\t\t.extend_name = \"battery\",\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_BATTERY,\n\t\t.scan_index = -1,\n\t},\n};\n\nstatic const struct iio_chan_spec jz4770_channels[] = {\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_TOUCH_XP,\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 12,\n\t\t\t.storagebits = 16,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_TOUCH_YP,\n\t\t.scan_index = 1,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 12,\n\t\t\t.storagebits = 16,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_TOUCH_XN,\n\t\t.scan_index = 2,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 12,\n\t\t\t.storagebits = 16,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_TOUCH_YN,\n\t\t.scan_index = 3,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 12,\n\t\t\t.storagebits = 16,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_TOUCH_XD,\n\t\t.scan_index = 4,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 12,\n\t\t\t.storagebits = 16,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_TOUCH_YD,\n\t\t.scan_index = 5,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 12,\n\t\t\t.storagebits = 16,\n\t\t},\n\t},\n\t{\n\t\t.extend_name = \"aux\",\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_AUX,\n\t\t.scan_index = -1,\n\t},\n\t{\n\t\t.extend_name = \"battery\",\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_BATTERY,\n\t\t.scan_index = -1,\n\t},\n\t{\n\t\t.extend_name = \"aux2\",\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.indexed = 1,\n\t\t.channel = INGENIC_ADC_AUX2,\n\t\t.scan_index = -1,\n\t},\n};\n\nstatic const struct ingenic_adc_soc_data jz4725b_adc_soc_data = {\n\t.battery_high_vref = JZ4725B_ADC_BATTERY_HIGH_VREF,\n\t.battery_high_vref_bits = JZ4725B_ADC_BATTERY_HIGH_VREF_BITS,\n\t.battery_raw_avail = jz4725b_adc_battery_raw_avail,\n\t.battery_raw_avail_size = ARRAY_SIZE(jz4725b_adc_battery_raw_avail),\n\t.battery_scale_avail = jz4725b_adc_battery_scale_avail,\n\t.battery_scale_avail_size = ARRAY_SIZE(jz4725b_adc_battery_scale_avail),\n\t.battery_vref_mode = true,\n\t.has_aux_md = false,\n\t.channels = jz4740_channels,\n\t.num_channels = ARRAY_SIZE(jz4740_channels),\n\t.init_clk_div = jz4725b_adc_init_clk_div,\n};\n\nstatic const struct ingenic_adc_soc_data jz4740_adc_soc_data = {\n\t.battery_high_vref = JZ4740_ADC_BATTERY_HIGH_VREF,\n\t.battery_high_vref_bits = JZ4740_ADC_BATTERY_HIGH_VREF_BITS,\n\t.battery_raw_avail = jz4740_adc_battery_raw_avail,\n\t.battery_raw_avail_size = ARRAY_SIZE(jz4740_adc_battery_raw_avail),\n\t.battery_scale_avail = jz4740_adc_battery_scale_avail,\n\t.battery_scale_avail_size = ARRAY_SIZE(jz4740_adc_battery_scale_avail),\n\t.battery_vref_mode = true,\n\t.has_aux_md = false,\n\t.channels = jz4740_channels,\n\t.num_channels = ARRAY_SIZE(jz4740_channels),\n\t.init_clk_div = NULL,  \n};\n\nstatic const struct ingenic_adc_soc_data jz4760_adc_soc_data = {\n\t.battery_high_vref = JZ4760_ADC_BATTERY_VREF,\n\t.battery_high_vref_bits = JZ4770_ADC_BATTERY_VREF_BITS,\n\t.battery_raw_avail = jz4770_adc_battery_raw_avail,\n\t.battery_raw_avail_size = ARRAY_SIZE(jz4770_adc_battery_raw_avail),\n\t.battery_scale_avail = jz4760_adc_battery_scale_avail,\n\t.battery_scale_avail_size = ARRAY_SIZE(jz4760_adc_battery_scale_avail),\n\t.battery_vref_mode = false,\n\t.has_aux_md = true,\n\t.channels = jz4760_channels,\n\t.num_channels = ARRAY_SIZE(jz4760_channels),\n\t.init_clk_div = jz4770_adc_init_clk_div,\n};\n\nstatic const struct ingenic_adc_soc_data jz4770_adc_soc_data = {\n\t.battery_high_vref = JZ4770_ADC_BATTERY_VREF,\n\t.battery_high_vref_bits = JZ4770_ADC_BATTERY_VREF_BITS,\n\t.battery_raw_avail = jz4770_adc_battery_raw_avail,\n\t.battery_raw_avail_size = ARRAY_SIZE(jz4770_adc_battery_raw_avail),\n\t.battery_scale_avail = jz4770_adc_battery_scale_avail,\n\t.battery_scale_avail_size = ARRAY_SIZE(jz4770_adc_battery_scale_avail),\n\t.battery_vref_mode = false,\n\t.has_aux_md = true,\n\t.channels = jz4770_channels,\n\t.num_channels = ARRAY_SIZE(jz4770_channels),\n\t.init_clk_div = jz4770_adc_init_clk_div,\n};\n\nstatic int ingenic_adc_read_avail(struct iio_dev *iio_dev,\n\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t  const int **vals,\n\t\t\t\t  int *type,\n\t\t\t\t  int *length,\n\t\t\t\t  long m)\n{\n\tstruct ingenic_adc *adc = iio_priv(iio_dev);\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*type = IIO_VAL_INT;\n\t\t*length = adc->soc_data->battery_raw_avail_size;\n\t\t*vals = adc->soc_data->battery_raw_avail;\n\t\treturn IIO_AVAIL_RANGE;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*type = IIO_VAL_FRACTIONAL_LOG2;\n\t\t*length = adc->soc_data->battery_scale_avail_size;\n\t\t*vals = adc->soc_data->battery_scale_avail;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ingenic_adc_read_chan_info_raw(struct iio_dev *iio_dev,\n\t\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t\t  int *val)\n{\n\tint cmd, ret, engine = (chan->channel == INGENIC_ADC_BATTERY);\n\tstruct ingenic_adc *adc = iio_priv(iio_dev);\n\n\tret = clk_enable(adc->clk);\n\tif (ret) {\n\t\tdev_err(iio_dev->dev.parent, \"Failed to enable clock: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tmutex_lock(&adc->aux_lock);\n\tif (adc->soc_data->has_aux_md && engine == 0) {\n\t\tswitch (chan->channel) {\n\t\tcase INGENIC_ADC_AUX0:\n\t\t\tcmd = 0;\n\t\t\tbreak;\n\t\tcase INGENIC_ADC_AUX:\n\t\t\tcmd = 1;\n\t\t\tbreak;\n\t\tcase INGENIC_ADC_AUX2:\n\t\t\tcmd = 2;\n\t\t\tbreak;\n\t\t}\n\n\t\tingenic_adc_set_config(adc, JZ_ADC_REG_CFG_AUX_MD, cmd);\n\t}\n\n\tret = ingenic_adc_capture(adc, engine);\n\tif (ret)\n\t\tgoto out;\n\n\tswitch (chan->channel) {\n\tcase INGENIC_ADC_AUX0:\n\tcase INGENIC_ADC_AUX:\n\tcase INGENIC_ADC_AUX2:\n\t\t*val = readw(adc->base + JZ_ADC_REG_ADSDAT);\n\t\tbreak;\n\tcase INGENIC_ADC_BATTERY:\n\t\t*val = readw(adc->base + JZ_ADC_REG_ADBDAT);\n\t\tbreak;\n\t}\n\n\tret = IIO_VAL_INT;\nout:\n\tmutex_unlock(&adc->aux_lock);\n\tclk_disable(adc->clk);\n\n\treturn ret;\n}\n\nstatic int ingenic_adc_read_raw(struct iio_dev *iio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val,\n\t\t\t\tint *val2,\n\t\t\t\tlong m)\n{\n\tstruct ingenic_adc *adc = iio_priv(iio_dev);\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn ingenic_adc_read_chan_info_raw(iio_dev, chan, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->channel) {\n\t\tcase INGENIC_ADC_AUX0:\n\t\tcase INGENIC_ADC_AUX:\n\t\tcase INGENIC_ADC_AUX2:\n\t\t\t*val = JZ_ADC_AUX_VREF;\n\t\t\t*val2 = JZ_ADC_AUX_VREF_BITS;\n\t\t\tbreak;\n\t\tcase INGENIC_ADC_BATTERY:\n\t\t\tif (adc->low_vref_mode) {\n\t\t\t\t*val = JZ_ADC_BATTERY_LOW_VREF;\n\t\t\t\t*val2 = JZ_ADC_BATTERY_LOW_VREF_BITS;\n\t\t\t} else {\n\t\t\t\t*val = adc->soc_data->battery_high_vref;\n\t\t\t\t*val2 = adc->soc_data->battery_high_vref_bits;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ingenic_adc_fwnode_xlate(struct iio_dev *iio_dev,\n\t\t\t\t    const struct fwnode_reference_args *iiospec)\n{\n\tint i;\n\n\tif (!iiospec->nargs)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < iio_dev->num_channels; ++i)\n\t\tif (iio_dev->channels[i].channel == iiospec->args[0])\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info ingenic_adc_info = {\n\t.write_raw = ingenic_adc_write_raw,\n\t.read_raw = ingenic_adc_read_raw,\n\t.read_avail = ingenic_adc_read_avail,\n\t.fwnode_xlate = ingenic_adc_fwnode_xlate,\n};\n\nstatic int ingenic_adc_buffer_enable(struct iio_dev *iio_dev)\n{\n\tstruct ingenic_adc *adc = iio_priv(iio_dev);\n\tint ret;\n\n\tret = clk_enable(adc->clk);\n\tif (ret) {\n\t\tdev_err(iio_dev->dev.parent, \"Failed to enable clock: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tmsleep(50);\n\tingenic_adc_set_config(adc, JZ_ADC_REG_CFG_TOUCH_OPS_MASK,\n\t\t\t       JZ_ADC_REG_CFG_SAMPLE_NUM(4) |\n\t\t\t       JZ_ADC_REG_CFG_PULL_UP(4));\n\n\twritew(80, adc->base + JZ_ADC_REG_ADWAIT);\n\twritew(2, adc->base + JZ_ADC_REG_ADSAME);\n\twriteb((u8)~JZ_ADC_IRQ_TOUCH, adc->base + JZ_ADC_REG_CTRL);\n\twritel(0, adc->base + JZ_ADC_REG_ADTCH);\n\n\tingenic_adc_set_config(adc, JZ_ADC_REG_CFG_CMD_SEL,\n\t\t\t       JZ_ADC_REG_CFG_CMD_SEL);\n\tingenic_adc_set_adcmd(iio_dev, iio_dev->active_scan_mask[0]);\n\n\tingenic_adc_enable(adc, 2, true);\n\n\treturn 0;\n}\n\nstatic int ingenic_adc_buffer_disable(struct iio_dev *iio_dev)\n{\n\tstruct ingenic_adc *adc = iio_priv(iio_dev);\n\n\tingenic_adc_enable(adc, 2, false);\n\n\tingenic_adc_set_config(adc, JZ_ADC_REG_CFG_CMD_SEL, 0);\n\n\twriteb(0xff, adc->base + JZ_ADC_REG_CTRL);\n\twriteb(0xff, adc->base + JZ_ADC_REG_STATUS);\n\tingenic_adc_set_config(adc, JZ_ADC_REG_CFG_TOUCH_OPS_MASK, 0);\n\twritew(0, adc->base + JZ_ADC_REG_ADSAME);\n\twritew(0, adc->base + JZ_ADC_REG_ADWAIT);\n\tclk_disable(adc->clk);\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops ingenic_buffer_setup_ops = {\n\t.postenable = &ingenic_adc_buffer_enable,\n\t.predisable = &ingenic_adc_buffer_disable\n};\n\nstatic irqreturn_t ingenic_adc_irq(int irq, void *data)\n{\n\tstruct iio_dev *iio_dev = data;\n\tstruct ingenic_adc *adc = iio_priv(iio_dev);\n\tunsigned long mask = iio_dev->active_scan_mask[0];\n\tunsigned int i;\n\tu32 tdat[3];\n\n\tfor (i = 0; i < ARRAY_SIZE(tdat); mask >>= 2, i++) {\n\t\tif (mask & 0x3)\n\t\t\ttdat[i] = readl(adc->base + JZ_ADC_REG_ADTCH);\n\t\telse\n\t\t\ttdat[i] = 0;\n\t}\n\n\tiio_push_to_buffers(iio_dev, tdat);\n\twriteb(JZ_ADC_IRQ_TOUCH, adc->base + JZ_ADC_REG_STATUS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ingenic_adc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *iio_dev;\n\tstruct ingenic_adc *adc;\n\tconst struct ingenic_adc_soc_data *soc_data;\n\tint irq, ret;\n\n\tsoc_data = device_get_match_data(dev);\n\tif (!soc_data)\n\t\treturn -EINVAL;\n\n\tiio_dev = devm_iio_device_alloc(dev, sizeof(*adc));\n\tif (!iio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(iio_dev);\n\tmutex_init(&adc->lock);\n\tmutex_init(&adc->aux_lock);\n\tadc->soc_data = soc_data;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, ingenic_adc_irq, 0,\n\t\t\t       dev_name(dev), iio_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to request irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tadc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(adc->base))\n\t\treturn PTR_ERR(adc->base);\n\n\tadc->clk = devm_clk_get_prepared(dev, \"adc\");\n\tif (IS_ERR(adc->clk)) {\n\t\tdev_err(dev, \"Unable to get clock\\n\");\n\t\treturn PTR_ERR(adc->clk);\n\t}\n\n\tret = clk_enable(adc->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (soc_data->init_clk_div) {\n\t\tret = soc_data->init_clk_div(dev, adc);\n\t\tif (ret) {\n\t\t\tclk_disable_unprepare(adc->clk);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\twriteb(0x00, adc->base + JZ_ADC_REG_ENABLE);\n\twriteb(0xff, adc->base + JZ_ADC_REG_CTRL);\n\n\t \n\tif (device_property_present(dev, \"ingenic,use-internal-divider\"))\n\t\tingenic_adc_set_config(adc, JZ_ADC_REG_CFG_VBAT_SEL,\n\t\t\t\t\t    JZ_ADC_REG_CFG_VBAT_SEL);\n\telse\n\t\tingenic_adc_set_config(adc, JZ_ADC_REG_CFG_VBAT_SEL, 0);\n\n\tusleep_range(2000, 3000);  \n\tclk_disable(adc->clk);\n\n\tiio_dev->name = \"jz-adc\";\n\tiio_dev->modes = INDIO_DIRECT_MODE | INDIO_BUFFER_SOFTWARE;\n\tiio_dev->setup_ops = &ingenic_buffer_setup_ops;\n\tiio_dev->channels = soc_data->channels;\n\tiio_dev->num_channels = soc_data->num_channels;\n\tiio_dev->info = &ingenic_adc_info;\n\n\tret = devm_iio_device_register(dev, iio_dev);\n\tif (ret)\n\t\tdev_err(dev, \"Unable to register IIO device\\n\");\n\n\treturn ret;\n}\n\nstatic const struct of_device_id ingenic_adc_of_match[] = {\n\t{ .compatible = \"ingenic,jz4725b-adc\", .data = &jz4725b_adc_soc_data, },\n\t{ .compatible = \"ingenic,jz4740-adc\", .data = &jz4740_adc_soc_data, },\n\t{ .compatible = \"ingenic,jz4760-adc\", .data = &jz4760_adc_soc_data, },\n\t{ .compatible = \"ingenic,jz4760b-adc\", .data = &jz4760_adc_soc_data, },\n\t{ .compatible = \"ingenic,jz4770-adc\", .data = &jz4770_adc_soc_data, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ingenic_adc_of_match);\n\nstatic struct platform_driver ingenic_adc_driver = {\n\t.driver = {\n\t\t.name = \"ingenic-adc\",\n\t\t.of_match_table = ingenic_adc_of_match,\n\t},\n\t.probe = ingenic_adc_probe,\n};\nmodule_platform_driver(ingenic_adc_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}