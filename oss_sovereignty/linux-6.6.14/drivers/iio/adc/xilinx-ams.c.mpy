{
  "module_name": "xilinx-ams.c",
  "hash_id": "39fb0a466f04d751814e8e4c35c377fbe0d5e4c490c25f9c4dfc80d69fde9608",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/xilinx-ams.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/devm-helpers.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/overflow.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n\n \n#define AMS_ISR_0\t\t\t0x010\n#define AMS_ISR_1\t\t\t0x014\n#define AMS_IER_0\t\t\t0x020\n#define AMS_IER_1\t\t\t0x024\n#define AMS_IDR_0\t\t\t0x028\n#define AMS_IDR_1\t\t\t0x02C\n#define AMS_PS_CSTS\t\t\t0x040\n#define AMS_PL_CSTS\t\t\t0x044\n\n#define AMS_VCC_PSPLL0\t\t\t0x060\n#define AMS_VCC_PSPLL3\t\t\t0x06C\n#define AMS_VCCINT\t\t\t0x078\n#define AMS_VCCBRAM\t\t\t0x07C\n#define AMS_VCCAUX\t\t\t0x080\n#define AMS_PSDDRPLL\t\t\t0x084\n#define AMS_PSINTFPDDR\t\t\t0x09C\n\n#define AMS_VCC_PSPLL0_CH\t\t48\n#define AMS_VCC_PSPLL3_CH\t\t51\n#define AMS_VCCINT_CH\t\t\t54\n#define AMS_VCCBRAM_CH\t\t\t55\n#define AMS_VCCAUX_CH\t\t\t56\n#define AMS_PSDDRPLL_CH\t\t\t57\n#define AMS_PSINTFPDDR_CH\t\t63\n\n#define AMS_REG_CONFIG0\t\t\t0x100\n#define AMS_REG_CONFIG1\t\t\t0x104\n#define AMS_REG_CONFIG3\t\t\t0x10C\n#define AMS_REG_CONFIG4\t\t\t0x110\n#define AMS_REG_SEQ_CH0\t\t\t0x120\n#define AMS_REG_SEQ_CH1\t\t\t0x124\n#define AMS_REG_SEQ_CH2\t\t\t0x118\n\n#define AMS_VUSER0_MASK\t\t\tBIT(0)\n#define AMS_VUSER1_MASK\t\t\tBIT(1)\n#define AMS_VUSER2_MASK\t\t\tBIT(2)\n#define AMS_VUSER3_MASK\t\t\tBIT(3)\n\n#define AMS_TEMP\t\t\t0x000\n#define AMS_SUPPLY1\t\t\t0x004\n#define AMS_SUPPLY2\t\t\t0x008\n#define AMS_VP_VN\t\t\t0x00C\n#define AMS_VREFP\t\t\t0x010\n#define AMS_VREFN\t\t\t0x014\n#define AMS_SUPPLY3\t\t\t0x018\n#define AMS_SUPPLY4\t\t\t0x034\n#define AMS_SUPPLY5\t\t\t0x038\n#define AMS_SUPPLY6\t\t\t0x03C\n#define AMS_SUPPLY7\t\t\t0x200\n#define AMS_SUPPLY8\t\t\t0x204\n#define AMS_SUPPLY9\t\t\t0x208\n#define AMS_SUPPLY10\t\t\t0x20C\n#define AMS_VCCAMS\t\t\t0x210\n#define AMS_TEMP_REMOTE\t\t\t0x214\n\n#define AMS_REG_VAUX(x)\t\t\t(0x40 + 4 * (x))\n\n#define AMS_PS_RESET_VALUE\t\t0xFFFF\n#define AMS_PL_RESET_VALUE\t\t0xFFFF\n\n#define AMS_CONF0_CHANNEL_NUM_MASK\tGENMASK(6, 0)\n\n#define AMS_CONF1_SEQ_MASK\t\tGENMASK(15, 12)\n#define AMS_CONF1_SEQ_DEFAULT\t\tFIELD_PREP(AMS_CONF1_SEQ_MASK, 0)\n#define AMS_CONF1_SEQ_CONTINUOUS\tFIELD_PREP(AMS_CONF1_SEQ_MASK, 2)\n#define AMS_CONF1_SEQ_SINGLE_CHANNEL\tFIELD_PREP(AMS_CONF1_SEQ_MASK, 3)\n\n#define AMS_REG_SEQ0_MASK\t\tGENMASK(15, 0)\n#define AMS_REG_SEQ2_MASK\t\tGENMASK(21, 16)\n#define AMS_REG_SEQ1_MASK\t\tGENMASK_ULL(37, 22)\n\n#define AMS_PS_SEQ_MASK\t\t\tGENMASK(21, 0)\n#define AMS_PL_SEQ_MASK\t\t\tGENMASK_ULL(59, 22)\n\n#define AMS_ALARM_TEMP\t\t\t0x140\n#define AMS_ALARM_SUPPLY1\t\t0x144\n#define AMS_ALARM_SUPPLY2\t\t0x148\n#define AMS_ALARM_SUPPLY3\t\t0x160\n#define AMS_ALARM_SUPPLY4\t\t0x164\n#define AMS_ALARM_SUPPLY5\t\t0x168\n#define AMS_ALARM_SUPPLY6\t\t0x16C\n#define AMS_ALARM_SUPPLY7\t\t0x180\n#define AMS_ALARM_SUPPLY8\t\t0x184\n#define AMS_ALARM_SUPPLY9\t\t0x188\n#define AMS_ALARM_SUPPLY10\t\t0x18C\n#define AMS_ALARM_VCCAMS\t\t0x190\n#define AMS_ALARM_TEMP_REMOTE\t\t0x194\n#define AMS_ALARM_THRESHOLD_OFF_10\t0x10\n#define AMS_ALARM_THRESHOLD_OFF_20\t0x20\n\n#define AMS_ALARM_THR_DIRECT_MASK\tBIT(1)\n#define AMS_ALARM_THR_MIN\t\t0x0000\n#define AMS_ALARM_THR_MAX\t\t(BIT(16) - 1)\n\n#define AMS_ALARM_MASK\t\t\tGENMASK_ULL(63, 0)\n#define AMS_NO_OF_ALARMS\t\t32\n#define AMS_PL_ALARM_START\t\t16\n#define AMS_PL_ALARM_MASK\t\tGENMASK(31, 16)\n#define AMS_ISR0_ALARM_MASK\t\tGENMASK(31, 0)\n#define AMS_ISR1_ALARM_MASK\t\t(GENMASK(31, 29) | GENMASK(4, 0))\n#define AMS_ISR1_EOC_MASK\t\tBIT(3)\n#define AMS_ISR1_INTR_MASK\t\tGENMASK_ULL(63, 32)\n#define AMS_ISR0_ALARM_2_TO_0_MASK\tGENMASK(2, 0)\n#define AMS_ISR0_ALARM_6_TO_3_MASK\tGENMASK(6, 3)\n#define AMS_ISR0_ALARM_12_TO_7_MASK\tGENMASK(13, 8)\n#define AMS_CONF1_ALARM_2_TO_0_MASK\tGENMASK(3, 1)\n#define AMS_CONF1_ALARM_6_TO_3_MASK\tGENMASK(11, 8)\n#define AMS_CONF1_ALARM_12_TO_7_MASK\tGENMASK(5, 0)\n#define AMS_REGCFG1_ALARM_MASK  \\\n\t(AMS_CONF1_ALARM_2_TO_0_MASK | AMS_CONF1_ALARM_6_TO_3_MASK | BIT(0))\n#define AMS_REGCFG3_ALARM_MASK\t\tAMS_CONF1_ALARM_12_TO_7_MASK\n\n#define AMS_PS_CSTS_PS_READY\t\t(BIT(27) | BIT(16))\n#define AMS_PL_CSTS_ACCESS_MASK\t\tBIT(1)\n\n#define AMS_PL_MAX_FIXED_CHANNEL\t10\n#define AMS_PL_MAX_EXT_CHANNEL\t\t20\n\n#define AMS_INIT_POLL_TIME_US\t\t200\n#define AMS_INIT_TIMEOUT_US\t\t10000\n#define AMS_UNMASK_TIMEOUT_MS\t\t500\n\n \n#define AMS_SUPPLY_SCALE_1VOLT_mV\t\t1000\n#define AMS_SUPPLY_SCALE_3VOLT_mV\t\t3000\n#define AMS_SUPPLY_SCALE_6VOLT_mV\t\t6000\n#define AMS_SUPPLY_SCALE_DIV_BIT\t16\n\n#define AMS_TEMP_SCALE\t\t\t509314\n#define AMS_TEMP_SCALE_DIV_BIT\t\t16\n#define AMS_TEMP_OFFSET\t\t\t-((280230LL << 16) / 509314)\n\nenum ams_alarm_bit {\n\tAMS_ALARM_BIT_TEMP = 0,\n\tAMS_ALARM_BIT_SUPPLY1 = 1,\n\tAMS_ALARM_BIT_SUPPLY2 = 2,\n\tAMS_ALARM_BIT_SUPPLY3 = 3,\n\tAMS_ALARM_BIT_SUPPLY4 = 4,\n\tAMS_ALARM_BIT_SUPPLY5 = 5,\n\tAMS_ALARM_BIT_SUPPLY6 = 6,\n\tAMS_ALARM_BIT_RESERVED = 7,\n\tAMS_ALARM_BIT_SUPPLY7 = 8,\n\tAMS_ALARM_BIT_SUPPLY8 = 9,\n\tAMS_ALARM_BIT_SUPPLY9 = 10,\n\tAMS_ALARM_BIT_SUPPLY10 = 11,\n\tAMS_ALARM_BIT_VCCAMS = 12,\n\tAMS_ALARM_BIT_TEMP_REMOTE = 13,\n};\n\nenum ams_seq {\n\tAMS_SEQ_VCC_PSPLL = 0,\n\tAMS_SEQ_VCC_PSBATT = 1,\n\tAMS_SEQ_VCCINT = 2,\n\tAMS_SEQ_VCCBRAM = 3,\n\tAMS_SEQ_VCCAUX = 4,\n\tAMS_SEQ_PSDDRPLL = 5,\n\tAMS_SEQ_INTDDR = 6,\n};\n\nenum ams_ps_pl_seq {\n\tAMS_SEQ_CALIB = 0,\n\tAMS_SEQ_RSVD_1 = 1,\n\tAMS_SEQ_RSVD_2 = 2,\n\tAMS_SEQ_TEST = 3,\n\tAMS_SEQ_RSVD_4 = 4,\n\tAMS_SEQ_SUPPLY4 = 5,\n\tAMS_SEQ_SUPPLY5 = 6,\n\tAMS_SEQ_SUPPLY6 = 7,\n\tAMS_SEQ_TEMP = 8,\n\tAMS_SEQ_SUPPLY2 = 9,\n\tAMS_SEQ_SUPPLY1 = 10,\n\tAMS_SEQ_VP_VN = 11,\n\tAMS_SEQ_VREFP = 12,\n\tAMS_SEQ_VREFN = 13,\n\tAMS_SEQ_SUPPLY3 = 14,\n\tAMS_SEQ_CURRENT_MON = 15,\n\tAMS_SEQ_SUPPLY7 = 16,\n\tAMS_SEQ_SUPPLY8 = 17,\n\tAMS_SEQ_SUPPLY9 = 18,\n\tAMS_SEQ_SUPPLY10 = 19,\n\tAMS_SEQ_VCCAMS = 20,\n\tAMS_SEQ_TEMP_REMOTE = 21,\n\tAMS_SEQ_MAX = 22\n};\n\n#define AMS_PS_SEQ_MAX\t\tAMS_SEQ_MAX\n#define AMS_SEQ(x)\t\t(AMS_SEQ_MAX + (x))\n#define PS_SEQ(x)\t\t(x)\n#define PL_SEQ(x)\t\t(AMS_PS_SEQ_MAX + (x))\n#define AMS_CTRL_SEQ_BASE\t(AMS_PS_SEQ_MAX * 3)\n\n#define AMS_CHAN_TEMP(_scan_index, _addr) { \\\n\t.type = IIO_TEMP, \\\n\t.indexed = 1, \\\n\t.address = (_addr), \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\tBIT(IIO_CHAN_INFO_SCALE) | \\\n\t\tBIT(IIO_CHAN_INFO_OFFSET), \\\n\t.event_spec = ams_temp_events, \\\n\t.scan_index = _scan_index, \\\n\t.num_event_specs = ARRAY_SIZE(ams_temp_events), \\\n}\n\n#define AMS_CHAN_VOLTAGE(_scan_index, _addr, _alarm) { \\\n\t.type = IIO_VOLTAGE, \\\n\t.indexed = 1, \\\n\t.address = (_addr), \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\tBIT(IIO_CHAN_INFO_SCALE), \\\n\t.event_spec = (_alarm) ? ams_voltage_events : NULL, \\\n\t.scan_index = _scan_index, \\\n\t.num_event_specs = (_alarm) ? ARRAY_SIZE(ams_voltage_events) : 0, \\\n}\n\n#define AMS_PS_CHAN_TEMP(_scan_index, _addr) \\\n\tAMS_CHAN_TEMP(PS_SEQ(_scan_index), _addr)\n#define AMS_PS_CHAN_VOLTAGE(_scan_index, _addr) \\\n\tAMS_CHAN_VOLTAGE(PS_SEQ(_scan_index), _addr, true)\n\n#define AMS_PL_CHAN_TEMP(_scan_index, _addr) \\\n\tAMS_CHAN_TEMP(PL_SEQ(_scan_index), _addr)\n#define AMS_PL_CHAN_VOLTAGE(_scan_index, _addr, _alarm) \\\n\tAMS_CHAN_VOLTAGE(PL_SEQ(_scan_index), _addr, _alarm)\n#define AMS_PL_AUX_CHAN_VOLTAGE(_auxno) \\\n\tAMS_CHAN_VOLTAGE(PL_SEQ(AMS_SEQ(_auxno)), AMS_REG_VAUX(_auxno), false)\n#define AMS_CTRL_CHAN_VOLTAGE(_scan_index, _addr) \\\n\tAMS_CHAN_VOLTAGE(PL_SEQ(AMS_SEQ(AMS_SEQ(_scan_index))), _addr, false)\n\n \nstruct ams {\n\tvoid __iomem *base;\n\tvoid __iomem *ps_base;\n\tvoid __iomem *pl_base;\n\tstruct clk *clk;\n\tstruct device *dev;\n\tstruct mutex lock;\n\tspinlock_t intr_lock;\n\tunsigned int alarm_mask;\n\tunsigned int current_masked_alarm;\n\tu64 intr_mask;\n\tstruct delayed_work ams_unmask_work;\n};\n\nstatic inline void ams_ps_update_reg(struct ams *ams, unsigned int offset,\n\t\t\t\t     u32 mask, u32 data)\n{\n\tu32 val, regval;\n\n\tval = readl(ams->ps_base + offset);\n\tregval = (val & ~mask) | (data & mask);\n\twritel(regval, ams->ps_base + offset);\n}\n\nstatic inline void ams_pl_update_reg(struct ams *ams, unsigned int offset,\n\t\t\t\t     u32 mask, u32 data)\n{\n\tu32 val, regval;\n\n\tval = readl(ams->pl_base + offset);\n\tregval = (val & ~mask) | (data & mask);\n\twritel(regval, ams->pl_base + offset);\n}\n\nstatic void ams_update_intrmask(struct ams *ams, u64 mask, u64 val)\n{\n\tu32 regval;\n\n\tams->intr_mask = (ams->intr_mask & ~mask) | (val & mask);\n\n\tregval = ~(ams->intr_mask | ams->current_masked_alarm);\n\twritel(regval, ams->base + AMS_IER_0);\n\n\tregval = ~(FIELD_GET(AMS_ISR1_INTR_MASK, ams->intr_mask));\n\twritel(regval, ams->base + AMS_IER_1);\n\n\tregval = ams->intr_mask | ams->current_masked_alarm;\n\twritel(regval, ams->base + AMS_IDR_0);\n\n\tregval = FIELD_GET(AMS_ISR1_INTR_MASK, ams->intr_mask);\n\twritel(regval, ams->base + AMS_IDR_1);\n}\n\nstatic void ams_disable_all_alarms(struct ams *ams)\n{\n\t \n\tif (ams->ps_base) {\n\t\tams_ps_update_reg(ams, AMS_REG_CONFIG1, AMS_REGCFG1_ALARM_MASK,\n\t\t\t\t  AMS_REGCFG1_ALARM_MASK);\n\t\tams_ps_update_reg(ams, AMS_REG_CONFIG3, AMS_REGCFG3_ALARM_MASK,\n\t\t\t\t  AMS_REGCFG3_ALARM_MASK);\n\t}\n\n\t \n\tif (ams->pl_base) {\n\t\tams_pl_update_reg(ams, AMS_REG_CONFIG1, AMS_REGCFG1_ALARM_MASK,\n\t\t\t\t  AMS_REGCFG1_ALARM_MASK);\n\t\tams_pl_update_reg(ams, AMS_REG_CONFIG3, AMS_REGCFG3_ALARM_MASK,\n\t\t\t\t  AMS_REGCFG3_ALARM_MASK);\n\t}\n}\n\nstatic void ams_update_ps_alarm(struct ams *ams, unsigned long alarm_mask)\n{\n\tu32 cfg;\n\tu32 val;\n\n\tval = FIELD_GET(AMS_ISR0_ALARM_2_TO_0_MASK, alarm_mask);\n\tcfg = ~(FIELD_PREP(AMS_CONF1_ALARM_2_TO_0_MASK, val));\n\n\tval = FIELD_GET(AMS_ISR0_ALARM_6_TO_3_MASK, alarm_mask);\n\tcfg &= ~(FIELD_PREP(AMS_CONF1_ALARM_6_TO_3_MASK, val));\n\n\tams_ps_update_reg(ams, AMS_REG_CONFIG1, AMS_REGCFG1_ALARM_MASK, cfg);\n\n\tval = FIELD_GET(AMS_ISR0_ALARM_12_TO_7_MASK, alarm_mask);\n\tcfg = ~(FIELD_PREP(AMS_CONF1_ALARM_12_TO_7_MASK, val));\n\tams_ps_update_reg(ams, AMS_REG_CONFIG3, AMS_REGCFG3_ALARM_MASK, cfg);\n}\n\nstatic void ams_update_pl_alarm(struct ams *ams, unsigned long alarm_mask)\n{\n\tunsigned long pl_alarm_mask;\n\tu32 cfg;\n\tu32 val;\n\n\tpl_alarm_mask = FIELD_GET(AMS_PL_ALARM_MASK, alarm_mask);\n\n\tval = FIELD_GET(AMS_ISR0_ALARM_2_TO_0_MASK, pl_alarm_mask);\n\tcfg = ~(FIELD_PREP(AMS_CONF1_ALARM_2_TO_0_MASK, val));\n\n\tval = FIELD_GET(AMS_ISR0_ALARM_6_TO_3_MASK, pl_alarm_mask);\n\tcfg &= ~(FIELD_PREP(AMS_CONF1_ALARM_6_TO_3_MASK, val));\n\n\tams_pl_update_reg(ams, AMS_REG_CONFIG1, AMS_REGCFG1_ALARM_MASK, cfg);\n\n\tval = FIELD_GET(AMS_ISR0_ALARM_12_TO_7_MASK, pl_alarm_mask);\n\tcfg = ~(FIELD_PREP(AMS_CONF1_ALARM_12_TO_7_MASK, val));\n\tams_pl_update_reg(ams, AMS_REG_CONFIG3, AMS_REGCFG3_ALARM_MASK, cfg);\n}\n\nstatic void ams_update_alarm(struct ams *ams, unsigned long alarm_mask)\n{\n\tunsigned long flags;\n\n\tif (ams->ps_base)\n\t\tams_update_ps_alarm(ams, alarm_mask);\n\n\tif (ams->pl_base)\n\t\tams_update_pl_alarm(ams, alarm_mask);\n\n\tspin_lock_irqsave(&ams->intr_lock, flags);\n\tams_update_intrmask(ams, AMS_ISR0_ALARM_MASK, ~alarm_mask);\n\tspin_unlock_irqrestore(&ams->intr_lock, flags);\n}\n\nstatic void ams_enable_channel_sequence(struct iio_dev *indio_dev)\n{\n\tstruct ams *ams = iio_priv(indio_dev);\n\tunsigned long long scan_mask;\n\tint i;\n\tu32 regval;\n\n\t \n\n\t \n\tscan_mask = BIT(0) | BIT(AMS_PS_SEQ_MAX);\n\tfor (i = 0; i < indio_dev->num_channels; i++)\n\t\tscan_mask |= BIT_ULL(indio_dev->channels[i].scan_index);\n\n\tif (ams->ps_base) {\n\t\t \n\t\tams_ps_update_reg(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,\n\t\t\t\t  AMS_CONF1_SEQ_DEFAULT);\n\n\t\t \n\t\tregval = FIELD_GET(AMS_REG_SEQ0_MASK, scan_mask);\n\t\twritel(regval, ams->ps_base + AMS_REG_SEQ_CH0);\n\n\t\tregval = FIELD_GET(AMS_REG_SEQ2_MASK, scan_mask);\n\t\twritel(regval, ams->ps_base + AMS_REG_SEQ_CH2);\n\n\t\t \n\t\tams_ps_update_reg(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,\n\t\t\t\t  AMS_CONF1_SEQ_CONTINUOUS);\n\t}\n\n\tif (ams->pl_base) {\n\t\t \n\t\tams_pl_update_reg(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,\n\t\t\t\t  AMS_CONF1_SEQ_DEFAULT);\n\n\t\t \n\t\tscan_mask = FIELD_GET(AMS_PL_SEQ_MASK, scan_mask);\n\n\t\tregval = FIELD_GET(AMS_REG_SEQ0_MASK, scan_mask);\n\t\twritel(regval, ams->pl_base + AMS_REG_SEQ_CH0);\n\n\t\tregval = FIELD_GET(AMS_REG_SEQ1_MASK, scan_mask);\n\t\twritel(regval, ams->pl_base + AMS_REG_SEQ_CH1);\n\n\t\tregval = FIELD_GET(AMS_REG_SEQ2_MASK, scan_mask);\n\t\twritel(regval, ams->pl_base + AMS_REG_SEQ_CH2);\n\n\t\t \n\t\tams_pl_update_reg(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,\n\t\t\t\t  AMS_CONF1_SEQ_CONTINUOUS);\n\t}\n}\n\nstatic int ams_init_device(struct ams *ams)\n{\n\tu32 expect = AMS_PS_CSTS_PS_READY;\n\tu32 reg, value;\n\tint ret;\n\n\t \n\tif (ams->ps_base) {\n\t\twritel(AMS_PS_RESET_VALUE, ams->ps_base + AMS_VP_VN);\n\n\t\tret = readl_poll_timeout(ams->base + AMS_PS_CSTS, reg, (reg & expect),\n\t\t\t\t\t AMS_INIT_POLL_TIME_US, AMS_INIT_TIMEOUT_US);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tams_ps_update_reg(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,\n\t\t\t\t  AMS_CONF1_SEQ_DEFAULT);\n\t}\n\n\tif (ams->pl_base) {\n\t\tvalue = readl(ams->base + AMS_PL_CSTS);\n\t\tif (value == 0)\n\t\t\treturn 0;\n\n\t\twritel(AMS_PL_RESET_VALUE, ams->pl_base + AMS_VP_VN);\n\n\t\t \n\t\tams_pl_update_reg(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,\n\t\t\t\t  AMS_CONF1_SEQ_DEFAULT);\n\t}\n\n\tams_disable_all_alarms(ams);\n\n\t \n\tams_update_intrmask(ams, AMS_ALARM_MASK, AMS_ALARM_MASK);\n\n\t \n\twritel(AMS_ISR0_ALARM_MASK, ams->base + AMS_ISR_0);\n\twritel(AMS_ISR1_ALARM_MASK, ams->base + AMS_ISR_1);\n\n\treturn 0;\n}\n\nstatic int ams_enable_single_channel(struct ams *ams, unsigned int offset)\n{\n\tu8 channel_num;\n\n\tswitch (offset) {\n\tcase AMS_VCC_PSPLL0:\n\t\tchannel_num = AMS_VCC_PSPLL0_CH;\n\t\tbreak;\n\tcase AMS_VCC_PSPLL3:\n\t\tchannel_num = AMS_VCC_PSPLL3_CH;\n\t\tbreak;\n\tcase AMS_VCCINT:\n\t\tchannel_num = AMS_VCCINT_CH;\n\t\tbreak;\n\tcase AMS_VCCBRAM:\n\t\tchannel_num = AMS_VCCBRAM_CH;\n\t\tbreak;\n\tcase AMS_VCCAUX:\n\t\tchannel_num = AMS_VCCAUX_CH;\n\t\tbreak;\n\tcase AMS_PSDDRPLL:\n\t\tchannel_num = AMS_PSDDRPLL_CH;\n\t\tbreak;\n\tcase AMS_PSINTFPDDR:\n\t\tchannel_num = AMS_PSINTFPDDR_CH;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tams_ps_update_reg(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,\n\t\t\t  AMS_CONF1_SEQ_DEFAULT);\n\n\t \n\tams_ps_update_reg(ams, AMS_REG_CONFIG0, AMS_CONF0_CHANNEL_NUM_MASK,\n\t\t\t  channel_num);\n\n\t \n\tams_ps_update_reg(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,\n\t\t\t  AMS_CONF1_SEQ_SINGLE_CHANNEL);\n\n\treturn 0;\n}\n\nstatic int ams_read_vcc_reg(struct ams *ams, unsigned int offset, u32 *data)\n{\n\tu32 expect = AMS_ISR1_EOC_MASK;\n\tu32 reg;\n\tint ret;\n\n\tret = ams_enable_single_channel(ams, offset);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(expect, ams->base + AMS_ISR_1);\n\tret = readl_poll_timeout(ams->base + AMS_ISR_1, reg, (reg & expect),\n\t\t\t\t AMS_INIT_POLL_TIME_US, AMS_INIT_TIMEOUT_US);\n\tif (ret)\n\t\treturn ret;\n\n\t*data = readl(ams->base + offset);\n\n\treturn 0;\n}\n\nstatic int ams_get_ps_scale(int address)\n{\n\tint val;\n\n\tswitch (address) {\n\tcase AMS_SUPPLY1:\n\tcase AMS_SUPPLY2:\n\tcase AMS_SUPPLY3:\n\tcase AMS_SUPPLY4:\n\tcase AMS_SUPPLY9:\n\tcase AMS_SUPPLY10:\n\tcase AMS_VCCAMS:\n\t\tval = AMS_SUPPLY_SCALE_3VOLT_mV;\n\t\tbreak;\n\tcase AMS_SUPPLY5:\n\tcase AMS_SUPPLY6:\n\tcase AMS_SUPPLY7:\n\tcase AMS_SUPPLY8:\n\t\tval = AMS_SUPPLY_SCALE_6VOLT_mV;\n\t\tbreak;\n\tdefault:\n\t\tval = AMS_SUPPLY_SCALE_1VOLT_mV;\n\t\tbreak;\n\t}\n\n\treturn val;\n}\n\nstatic int ams_get_pl_scale(struct ams *ams, int address)\n{\n\tint val, regval;\n\n\tswitch (address) {\n\tcase AMS_SUPPLY1:\n\tcase AMS_SUPPLY2:\n\tcase AMS_SUPPLY3:\n\tcase AMS_SUPPLY4:\n\tcase AMS_SUPPLY5:\n\tcase AMS_SUPPLY6:\n\tcase AMS_VCCAMS:\n\tcase AMS_VREFP:\n\tcase AMS_VREFN:\n\t\tval = AMS_SUPPLY_SCALE_3VOLT_mV;\n\t\tbreak;\n\tcase AMS_SUPPLY7:\n\t\tregval = readl(ams->pl_base + AMS_REG_CONFIG4);\n\t\tif (FIELD_GET(AMS_VUSER0_MASK, regval))\n\t\t\tval = AMS_SUPPLY_SCALE_6VOLT_mV;\n\t\telse\n\t\t\tval = AMS_SUPPLY_SCALE_3VOLT_mV;\n\t\tbreak;\n\tcase AMS_SUPPLY8:\n\t\tregval = readl(ams->pl_base + AMS_REG_CONFIG4);\n\t\tif (FIELD_GET(AMS_VUSER1_MASK, regval))\n\t\t\tval = AMS_SUPPLY_SCALE_6VOLT_mV;\n\t\telse\n\t\t\tval = AMS_SUPPLY_SCALE_3VOLT_mV;\n\t\tbreak;\n\tcase AMS_SUPPLY9:\n\t\tregval = readl(ams->pl_base + AMS_REG_CONFIG4);\n\t\tif (FIELD_GET(AMS_VUSER2_MASK, regval))\n\t\t\tval = AMS_SUPPLY_SCALE_6VOLT_mV;\n\t\telse\n\t\t\tval = AMS_SUPPLY_SCALE_3VOLT_mV;\n\t\tbreak;\n\tcase AMS_SUPPLY10:\n\t\tregval = readl(ams->pl_base + AMS_REG_CONFIG4);\n\t\tif (FIELD_GET(AMS_VUSER3_MASK, regval))\n\t\t\tval = AMS_SUPPLY_SCALE_6VOLT_mV;\n\t\telse\n\t\t\tval = AMS_SUPPLY_SCALE_3VOLT_mV;\n\t\tbreak;\n\tcase AMS_VP_VN:\n\tcase AMS_REG_VAUX(0) ... AMS_REG_VAUX(15):\n\t\tval = AMS_SUPPLY_SCALE_1VOLT_mV;\n\t\tbreak;\n\tdefault:\n\t\tval = AMS_SUPPLY_SCALE_1VOLT_mV;\n\t\tbreak;\n\t}\n\n\treturn val;\n}\n\nstatic int ams_get_ctrl_scale(int address)\n{\n\tint val;\n\n\tswitch (address) {\n\tcase AMS_VCC_PSPLL0:\n\tcase AMS_VCC_PSPLL3:\n\tcase AMS_VCCINT:\n\tcase AMS_VCCBRAM:\n\tcase AMS_VCCAUX:\n\tcase AMS_PSDDRPLL:\n\tcase AMS_PSINTFPDDR:\n\t\tval = AMS_SUPPLY_SCALE_3VOLT_mV;\n\t\tbreak;\n\tdefault:\n\t\tval = AMS_SUPPLY_SCALE_1VOLT_mV;\n\t\tbreak;\n\t}\n\n\treturn val;\n}\n\nstatic int ams_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint *val, int *val2, long mask)\n{\n\tstruct ams *ams = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&ams->lock);\n\t\tif (chan->scan_index >= AMS_CTRL_SEQ_BASE) {\n\t\t\tret = ams_read_vcc_reg(ams, chan->address, val);\n\t\t\tif (ret)\n\t\t\t\tgoto unlock_mutex;\n\t\t\tams_enable_channel_sequence(indio_dev);\n\t\t} else if (chan->scan_index >= AMS_PS_SEQ_MAX)\n\t\t\t*val = readl(ams->pl_base + chan->address);\n\t\telse\n\t\t\t*val = readl(ams->ps_base + chan->address);\n\n\t\tret = IIO_VAL_INT;\nunlock_mutex:\n\t\tmutex_unlock(&ams->lock);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tif (chan->scan_index < AMS_PS_SEQ_MAX)\n\t\t\t\t*val = ams_get_ps_scale(chan->address);\n\t\t\telse if (chan->scan_index >= AMS_PS_SEQ_MAX &&\n\t\t\t\t chan->scan_index < AMS_CTRL_SEQ_BASE)\n\t\t\t\t*val = ams_get_pl_scale(ams, chan->address);\n\t\t\telse\n\t\t\t\t*val = ams_get_ctrl_scale(chan->address);\n\n\t\t\t*val2 = AMS_SUPPLY_SCALE_DIV_BIT;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\tcase IIO_TEMP:\n\t\t\t*val = AMS_TEMP_SCALE;\n\t\t\t*val2 = AMS_TEMP_SCALE_DIV_BIT;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\t*val = AMS_TEMP_OFFSET;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ams_get_alarm_offset(int scan_index, enum iio_event_direction dir)\n{\n\tint offset;\n\n\tif (scan_index >= AMS_PS_SEQ_MAX)\n\t\tscan_index -= AMS_PS_SEQ_MAX;\n\n\tif (dir == IIO_EV_DIR_FALLING) {\n\t\tif (scan_index < AMS_SEQ_SUPPLY7)\n\t\t\toffset = AMS_ALARM_THRESHOLD_OFF_10;\n\t\telse\n\t\t\toffset = AMS_ALARM_THRESHOLD_OFF_20;\n\t} else {\n\t\toffset = 0;\n\t}\n\n\tswitch (scan_index) {\n\tcase AMS_SEQ_TEMP:\n\t\treturn AMS_ALARM_TEMP + offset;\n\tcase AMS_SEQ_SUPPLY1:\n\t\treturn AMS_ALARM_SUPPLY1 + offset;\n\tcase AMS_SEQ_SUPPLY2:\n\t\treturn AMS_ALARM_SUPPLY2 + offset;\n\tcase AMS_SEQ_SUPPLY3:\n\t\treturn AMS_ALARM_SUPPLY3 + offset;\n\tcase AMS_SEQ_SUPPLY4:\n\t\treturn AMS_ALARM_SUPPLY4 + offset;\n\tcase AMS_SEQ_SUPPLY5:\n\t\treturn AMS_ALARM_SUPPLY5 + offset;\n\tcase AMS_SEQ_SUPPLY6:\n\t\treturn AMS_ALARM_SUPPLY6 + offset;\n\tcase AMS_SEQ_SUPPLY7:\n\t\treturn AMS_ALARM_SUPPLY7 + offset;\n\tcase AMS_SEQ_SUPPLY8:\n\t\treturn AMS_ALARM_SUPPLY8 + offset;\n\tcase AMS_SEQ_SUPPLY9:\n\t\treturn AMS_ALARM_SUPPLY9 + offset;\n\tcase AMS_SEQ_SUPPLY10:\n\t\treturn AMS_ALARM_SUPPLY10 + offset;\n\tcase AMS_SEQ_VCCAMS:\n\t\treturn AMS_ALARM_VCCAMS + offset;\n\tcase AMS_SEQ_TEMP_REMOTE:\n\t\treturn AMS_ALARM_TEMP_REMOTE + offset;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct iio_chan_spec *ams_event_to_channel(struct iio_dev *dev,\n\t\t\t\t\t\t\tu32 event)\n{\n\tint scan_index = 0, i;\n\n\tif (event >= AMS_PL_ALARM_START) {\n\t\tevent -= AMS_PL_ALARM_START;\n\t\tscan_index = AMS_PS_SEQ_MAX;\n\t}\n\n\tswitch (event) {\n\tcase AMS_ALARM_BIT_TEMP:\n\t\tscan_index += AMS_SEQ_TEMP;\n\t\tbreak;\n\tcase AMS_ALARM_BIT_SUPPLY1:\n\t\tscan_index += AMS_SEQ_SUPPLY1;\n\t\tbreak;\n\tcase AMS_ALARM_BIT_SUPPLY2:\n\t\tscan_index += AMS_SEQ_SUPPLY2;\n\t\tbreak;\n\tcase AMS_ALARM_BIT_SUPPLY3:\n\t\tscan_index += AMS_SEQ_SUPPLY3;\n\t\tbreak;\n\tcase AMS_ALARM_BIT_SUPPLY4:\n\t\tscan_index += AMS_SEQ_SUPPLY4;\n\t\tbreak;\n\tcase AMS_ALARM_BIT_SUPPLY5:\n\t\tscan_index += AMS_SEQ_SUPPLY5;\n\t\tbreak;\n\tcase AMS_ALARM_BIT_SUPPLY6:\n\t\tscan_index += AMS_SEQ_SUPPLY6;\n\t\tbreak;\n\tcase AMS_ALARM_BIT_SUPPLY7:\n\t\tscan_index += AMS_SEQ_SUPPLY7;\n\t\tbreak;\n\tcase AMS_ALARM_BIT_SUPPLY8:\n\t\tscan_index += AMS_SEQ_SUPPLY8;\n\t\tbreak;\n\tcase AMS_ALARM_BIT_SUPPLY9:\n\t\tscan_index += AMS_SEQ_SUPPLY9;\n\t\tbreak;\n\tcase AMS_ALARM_BIT_SUPPLY10:\n\t\tscan_index += AMS_SEQ_SUPPLY10;\n\t\tbreak;\n\tcase AMS_ALARM_BIT_VCCAMS:\n\t\tscan_index += AMS_SEQ_VCCAMS;\n\t\tbreak;\n\tcase AMS_ALARM_BIT_TEMP_REMOTE:\n\t\tscan_index += AMS_SEQ_TEMP_REMOTE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < dev->num_channels; i++)\n\t\tif (dev->channels[i].scan_index == scan_index)\n\t\t\tbreak;\n\n\treturn &dev->channels[i];\n}\n\nstatic int ams_get_alarm_mask(int scan_index)\n{\n\tint bit = 0;\n\n\tif (scan_index >= AMS_PS_SEQ_MAX) {\n\t\tbit = AMS_PL_ALARM_START;\n\t\tscan_index -= AMS_PS_SEQ_MAX;\n\t}\n\n\tswitch (scan_index) {\n\tcase AMS_SEQ_TEMP:\n\t\treturn BIT(AMS_ALARM_BIT_TEMP + bit);\n\tcase AMS_SEQ_SUPPLY1:\n\t\treturn BIT(AMS_ALARM_BIT_SUPPLY1 + bit);\n\tcase AMS_SEQ_SUPPLY2:\n\t\treturn BIT(AMS_ALARM_BIT_SUPPLY2 + bit);\n\tcase AMS_SEQ_SUPPLY3:\n\t\treturn BIT(AMS_ALARM_BIT_SUPPLY3 + bit);\n\tcase AMS_SEQ_SUPPLY4:\n\t\treturn BIT(AMS_ALARM_BIT_SUPPLY4 + bit);\n\tcase AMS_SEQ_SUPPLY5:\n\t\treturn BIT(AMS_ALARM_BIT_SUPPLY5 + bit);\n\tcase AMS_SEQ_SUPPLY6:\n\t\treturn BIT(AMS_ALARM_BIT_SUPPLY6 + bit);\n\tcase AMS_SEQ_SUPPLY7:\n\t\treturn BIT(AMS_ALARM_BIT_SUPPLY7 + bit);\n\tcase AMS_SEQ_SUPPLY8:\n\t\treturn BIT(AMS_ALARM_BIT_SUPPLY8 + bit);\n\tcase AMS_SEQ_SUPPLY9:\n\t\treturn BIT(AMS_ALARM_BIT_SUPPLY9 + bit);\n\tcase AMS_SEQ_SUPPLY10:\n\t\treturn BIT(AMS_ALARM_BIT_SUPPLY10 + bit);\n\tcase AMS_SEQ_VCCAMS:\n\t\treturn BIT(AMS_ALARM_BIT_VCCAMS + bit);\n\tcase AMS_SEQ_TEMP_REMOTE:\n\t\treturn BIT(AMS_ALARM_BIT_TEMP_REMOTE + bit);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int ams_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t enum iio_event_type type,\n\t\t\t\t enum iio_event_direction dir)\n{\n\tstruct ams *ams = iio_priv(indio_dev);\n\n\treturn !!(ams->alarm_mask & ams_get_alarm_mask(chan->scan_index));\n}\n\nstatic int ams_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t  enum iio_event_type type,\n\t\t\t\t  enum iio_event_direction dir,\n\t\t\t\t  int state)\n{\n\tstruct ams *ams = iio_priv(indio_dev);\n\tunsigned int alarm;\n\n\talarm = ams_get_alarm_mask(chan->scan_index);\n\n\tmutex_lock(&ams->lock);\n\n\tif (state)\n\t\tams->alarm_mask |= alarm;\n\telse\n\t\tams->alarm_mask &= ~alarm;\n\n\tams_update_alarm(ams, ams->alarm_mask);\n\n\tmutex_unlock(&ams->lock);\n\n\treturn 0;\n}\n\nstatic int ams_read_event_value(struct iio_dev *indio_dev,\n\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\tenum iio_event_type type,\n\t\t\t\tenum iio_event_direction dir,\n\t\t\t\tenum iio_event_info info, int *val, int *val2)\n{\n\tstruct ams *ams = iio_priv(indio_dev);\n\tunsigned int offset = ams_get_alarm_offset(chan->scan_index, dir);\n\n\tmutex_lock(&ams->lock);\n\n\tif (chan->scan_index >= AMS_PS_SEQ_MAX)\n\t\t*val = readl(ams->pl_base + offset);\n\telse\n\t\t*val = readl(ams->ps_base + offset);\n\n\tmutex_unlock(&ams->lock);\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int ams_write_event_value(struct iio_dev *indio_dev,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t enum iio_event_type type,\n\t\t\t\t enum iio_event_direction dir,\n\t\t\t\t enum iio_event_info info, int val, int val2)\n{\n\tstruct ams *ams = iio_priv(indio_dev);\n\tunsigned int offset;\n\n\tmutex_lock(&ams->lock);\n\n\t \n\tif (chan->type == IIO_TEMP) {\n\t\toffset = ams_get_alarm_offset(chan->scan_index, IIO_EV_DIR_FALLING);\n\n\t\tif (chan->scan_index >= AMS_PS_SEQ_MAX)\n\t\t\tams_pl_update_reg(ams, offset,\n\t\t\t\t\t  AMS_ALARM_THR_DIRECT_MASK,\n\t\t\t\t\t  AMS_ALARM_THR_DIRECT_MASK);\n\t\telse\n\t\t\tams_ps_update_reg(ams, offset,\n\t\t\t\t\t  AMS_ALARM_THR_DIRECT_MASK,\n\t\t\t\t\t  AMS_ALARM_THR_DIRECT_MASK);\n\t}\n\n\toffset = ams_get_alarm_offset(chan->scan_index, dir);\n\tif (chan->scan_index >= AMS_PS_SEQ_MAX)\n\t\twritel(val, ams->pl_base + offset);\n\telse\n\t\twritel(val, ams->ps_base + offset);\n\n\tmutex_unlock(&ams->lock);\n\n\treturn 0;\n}\n\nstatic void ams_handle_event(struct iio_dev *indio_dev, u32 event)\n{\n\tconst struct iio_chan_spec *chan;\n\n\tchan = ams_event_to_channel(indio_dev, event);\n\n\tif (chan->type == IIO_TEMP) {\n\t\t \n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(chan->type, chan->channel,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_RISING),\n\t\t\t       iio_get_time_ns(indio_dev));\n\t} else {\n\t\t \n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(chan->type, chan->channel,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t    IIO_EV_DIR_EITHER),\n\t\t\t       iio_get_time_ns(indio_dev));\n\t}\n}\n\nstatic void ams_handle_events(struct iio_dev *indio_dev, unsigned long events)\n{\n\tunsigned int bit;\n\n\tfor_each_set_bit(bit, &events, AMS_NO_OF_ALARMS)\n\t\tams_handle_event(indio_dev, bit);\n}\n\n \nstatic void ams_unmask_worker(struct work_struct *work)\n{\n\tstruct ams *ams = container_of(work, struct ams, ams_unmask_work.work);\n\tunsigned int status, unmask;\n\n\tspin_lock_irq(&ams->intr_lock);\n\n\tstatus = readl(ams->base + AMS_ISR_0);\n\n\t \n\tunmask = (ams->current_masked_alarm ^ status) & ams->current_masked_alarm;\n\n\t \n\tunmask |= ams->intr_mask;\n\n\tams->current_masked_alarm &= status;\n\n\t \n\tams->current_masked_alarm &= ~ams->intr_mask;\n\n\t \n\twritel(unmask, ams->base + AMS_ISR_0);\n\n\tams_update_intrmask(ams, ~AMS_ALARM_MASK, ~AMS_ALARM_MASK);\n\n\tspin_unlock_irq(&ams->intr_lock);\n\n\t \n\tif (ams->current_masked_alarm)\n\t\tschedule_delayed_work(&ams->ams_unmask_work,\n\t\t\t\t      msecs_to_jiffies(AMS_UNMASK_TIMEOUT_MS));\n}\n\nstatic irqreturn_t ams_irq(int irq, void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct ams *ams = iio_priv(indio_dev);\n\tu32 isr0;\n\n\tspin_lock(&ams->intr_lock);\n\n\tisr0 = readl(ams->base + AMS_ISR_0);\n\n\t \n\tisr0 &= ~((ams->intr_mask & AMS_ISR0_ALARM_MASK) | ams->current_masked_alarm);\n\tif (!isr0) {\n\t\tspin_unlock(&ams->intr_lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\twritel(isr0, ams->base + AMS_ISR_0);\n\n\t \n\tams->current_masked_alarm |= isr0;\n\tams_update_intrmask(ams, ~AMS_ALARM_MASK, ~AMS_ALARM_MASK);\n\n\tams_handle_events(indio_dev, isr0);\n\n\tschedule_delayed_work(&ams->ams_unmask_work,\n\t\t\t      msecs_to_jiffies(AMS_UNMASK_TIMEOUT_MS));\n\n\tspin_unlock(&ams->intr_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_event_spec ams_temp_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE) | BIT(IIO_EV_INFO_VALUE),\n\t},\n};\n\nstatic const struct iio_event_spec ams_voltage_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec ams_ps_channels[] = {\n\tAMS_PS_CHAN_TEMP(AMS_SEQ_TEMP, AMS_TEMP),\n\tAMS_PS_CHAN_TEMP(AMS_SEQ_TEMP_REMOTE, AMS_TEMP_REMOTE),\n\tAMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY1, AMS_SUPPLY1),\n\tAMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY2, AMS_SUPPLY2),\n\tAMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY3, AMS_SUPPLY3),\n\tAMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY4, AMS_SUPPLY4),\n\tAMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY5, AMS_SUPPLY5),\n\tAMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY6, AMS_SUPPLY6),\n\tAMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY7, AMS_SUPPLY7),\n\tAMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY8, AMS_SUPPLY8),\n\tAMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY9, AMS_SUPPLY9),\n\tAMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY10, AMS_SUPPLY10),\n\tAMS_PS_CHAN_VOLTAGE(AMS_SEQ_VCCAMS, AMS_VCCAMS),\n};\n\nstatic const struct iio_chan_spec ams_pl_channels[] = {\n\tAMS_PL_CHAN_TEMP(AMS_SEQ_TEMP, AMS_TEMP),\n\tAMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY1, AMS_SUPPLY1, true),\n\tAMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY2, AMS_SUPPLY2, true),\n\tAMS_PL_CHAN_VOLTAGE(AMS_SEQ_VREFP, AMS_VREFP, false),\n\tAMS_PL_CHAN_VOLTAGE(AMS_SEQ_VREFN, AMS_VREFN, false),\n\tAMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY3, AMS_SUPPLY3, true),\n\tAMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY4, AMS_SUPPLY4, true),\n\tAMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY5, AMS_SUPPLY5, true),\n\tAMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY6, AMS_SUPPLY6, true),\n\tAMS_PL_CHAN_VOLTAGE(AMS_SEQ_VCCAMS, AMS_VCCAMS, true),\n\tAMS_PL_CHAN_VOLTAGE(AMS_SEQ_VP_VN, AMS_VP_VN, false),\n\tAMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY7, AMS_SUPPLY7, true),\n\tAMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY8, AMS_SUPPLY8, true),\n\tAMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY9, AMS_SUPPLY9, true),\n\tAMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY10, AMS_SUPPLY10, true),\n\tAMS_PL_AUX_CHAN_VOLTAGE(0),\n\tAMS_PL_AUX_CHAN_VOLTAGE(1),\n\tAMS_PL_AUX_CHAN_VOLTAGE(2),\n\tAMS_PL_AUX_CHAN_VOLTAGE(3),\n\tAMS_PL_AUX_CHAN_VOLTAGE(4),\n\tAMS_PL_AUX_CHAN_VOLTAGE(5),\n\tAMS_PL_AUX_CHAN_VOLTAGE(6),\n\tAMS_PL_AUX_CHAN_VOLTAGE(7),\n\tAMS_PL_AUX_CHAN_VOLTAGE(8),\n\tAMS_PL_AUX_CHAN_VOLTAGE(9),\n\tAMS_PL_AUX_CHAN_VOLTAGE(10),\n\tAMS_PL_AUX_CHAN_VOLTAGE(11),\n\tAMS_PL_AUX_CHAN_VOLTAGE(12),\n\tAMS_PL_AUX_CHAN_VOLTAGE(13),\n\tAMS_PL_AUX_CHAN_VOLTAGE(14),\n\tAMS_PL_AUX_CHAN_VOLTAGE(15),\n};\n\nstatic const struct iio_chan_spec ams_ctrl_channels[] = {\n\tAMS_CTRL_CHAN_VOLTAGE(AMS_SEQ_VCC_PSPLL, AMS_VCC_PSPLL0),\n\tAMS_CTRL_CHAN_VOLTAGE(AMS_SEQ_VCC_PSBATT, AMS_VCC_PSPLL3),\n\tAMS_CTRL_CHAN_VOLTAGE(AMS_SEQ_VCCINT, AMS_VCCINT),\n\tAMS_CTRL_CHAN_VOLTAGE(AMS_SEQ_VCCBRAM, AMS_VCCBRAM),\n\tAMS_CTRL_CHAN_VOLTAGE(AMS_SEQ_VCCAUX, AMS_VCCAUX),\n\tAMS_CTRL_CHAN_VOLTAGE(AMS_SEQ_PSDDRPLL, AMS_PSDDRPLL),\n\tAMS_CTRL_CHAN_VOLTAGE(AMS_SEQ_INTDDR, AMS_PSINTFPDDR),\n};\n\nstatic int ams_get_ext_chan(struct fwnode_handle *chan_node,\n\t\t\t    struct iio_chan_spec *channels, int num_channels)\n{\n\tstruct iio_chan_spec *chan;\n\tstruct fwnode_handle *child;\n\tunsigned int reg, ext_chan;\n\tint ret;\n\n\tfwnode_for_each_child_node(chan_node, child) {\n\t\tret = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\tif (ret || reg > AMS_PL_MAX_EXT_CHANNEL + 30)\n\t\t\tcontinue;\n\n\t\tchan = &channels[num_channels];\n\t\text_chan = reg + AMS_PL_MAX_FIXED_CHANNEL - 30;\n\t\tmemcpy(chan, &ams_pl_channels[ext_chan], sizeof(*channels));\n\n\t\tif (fwnode_property_read_bool(child, \"xlnx,bipolar\"))\n\t\t\tchan->scan_type.sign = 's';\n\n\t\tnum_channels++;\n\t}\n\n\treturn num_channels;\n}\n\nstatic void ams_iounmap_ps(void *data)\n{\n\tstruct ams *ams = data;\n\n\tiounmap(ams->ps_base);\n}\n\nstatic void ams_iounmap_pl(void *data)\n{\n\tstruct ams *ams = data;\n\n\tiounmap(ams->pl_base);\n}\n\nstatic int ams_init_module(struct iio_dev *indio_dev,\n\t\t\t   struct fwnode_handle *fwnode,\n\t\t\t   struct iio_chan_spec *channels)\n{\n\tstruct device *dev = indio_dev->dev.parent;\n\tstruct ams *ams = iio_priv(indio_dev);\n\tint num_channels = 0;\n\tint ret;\n\n\tif (fwnode_device_is_compatible(fwnode, \"xlnx,zynqmp-ams-ps\")) {\n\t\tams->ps_base = fwnode_iomap(fwnode, 0);\n\t\tif (!ams->ps_base)\n\t\t\treturn -ENXIO;\n\t\tret = devm_add_action_or_reset(dev, ams_iounmap_ps, ams);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tmemcpy(channels, ams_ps_channels, sizeof(ams_ps_channels));\n\t\tnum_channels = ARRAY_SIZE(ams_ps_channels);\n\t} else if (fwnode_device_is_compatible(fwnode, \"xlnx,zynqmp-ams-pl\")) {\n\t\tams->pl_base = fwnode_iomap(fwnode, 0);\n\t\tif (!ams->pl_base)\n\t\t\treturn -ENXIO;\n\n\t\tret = devm_add_action_or_reset(dev, ams_iounmap_pl, ams);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tmemcpy(channels, ams_pl_channels, AMS_PL_MAX_FIXED_CHANNEL * sizeof(*channels));\n\t\tnum_channels += AMS_PL_MAX_FIXED_CHANNEL;\n\t\tnum_channels = ams_get_ext_chan(fwnode, channels,\n\t\t\t\t\t\tnum_channels);\n\t} else if (fwnode_device_is_compatible(fwnode, \"xlnx,zynqmp-ams\")) {\n\t\t \n\t\tmemcpy(channels, ams_ctrl_channels, sizeof(ams_ctrl_channels));\n\t\tnum_channels += ARRAY_SIZE(ams_ctrl_channels);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn num_channels;\n}\n\nstatic int ams_parse_firmware(struct iio_dev *indio_dev)\n{\n\tstruct ams *ams = iio_priv(indio_dev);\n\tstruct iio_chan_spec *ams_channels, *dev_channels;\n\tstruct device *dev = indio_dev->dev.parent;\n\tstruct fwnode_handle *child = NULL;\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\tsize_t ams_size;\n\tint ret, ch_cnt = 0, i, rising_off, falling_off;\n\tunsigned int num_channels = 0;\n\n\tams_size = ARRAY_SIZE(ams_ps_channels) + ARRAY_SIZE(ams_pl_channels) +\n\t\tARRAY_SIZE(ams_ctrl_channels);\n\n\t \n\tams_channels = devm_kcalloc(dev, ams_size, sizeof(*ams_channels), GFP_KERNEL);\n\tif (!ams_channels)\n\t\treturn -ENOMEM;\n\n\tif (fwnode_device_is_available(fwnode)) {\n\t\tret = ams_init_module(indio_dev, fwnode, ams_channels);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tnum_channels += ret;\n\t}\n\n\tfwnode_for_each_child_node(fwnode, child) {\n\t\tif (fwnode_device_is_available(child)) {\n\t\t\tret = ams_init_module(indio_dev, child, ams_channels + num_channels);\n\t\t\tif (ret < 0) {\n\t\t\t\tfwnode_handle_put(child);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tnum_channels += ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_channels; i++) {\n\t\tams_channels[i].channel = ch_cnt++;\n\n\t\tif (ams_channels[i].scan_index < AMS_CTRL_SEQ_BASE) {\n\t\t\t \n\t\t\tfalling_off =\n\t\t\t\tams_get_alarm_offset(ams_channels[i].scan_index,\n\t\t\t\t\t\t     IIO_EV_DIR_FALLING);\n\t\t\trising_off =\n\t\t\t\tams_get_alarm_offset(ams_channels[i].scan_index,\n\t\t\t\t\t\t     IIO_EV_DIR_RISING);\n\t\t\tif (ams_channels[i].scan_index >= AMS_PS_SEQ_MAX) {\n\t\t\t\twritel(AMS_ALARM_THR_MIN,\n\t\t\t\t       ams->pl_base + falling_off);\n\t\t\t\twritel(AMS_ALARM_THR_MAX,\n\t\t\t\t       ams->pl_base + rising_off);\n\t\t\t} else {\n\t\t\t\twritel(AMS_ALARM_THR_MIN,\n\t\t\t\t       ams->ps_base + falling_off);\n\t\t\t\twritel(AMS_ALARM_THR_MAX,\n\t\t\t\t       ams->ps_base + rising_off);\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_channels = devm_krealloc_array(dev, ams_channels, num_channels,\n\t\t\t\t\t   sizeof(*dev_channels), GFP_KERNEL);\n\tif (!dev_channels)\n\t\treturn -ENOMEM;\n\n\tindio_dev->channels = dev_channels;\n\tindio_dev->num_channels = num_channels;\n\n\treturn 0;\n}\n\nstatic const struct iio_info iio_ams_info = {\n\t.read_raw = &ams_read_raw,\n\t.read_event_config = &ams_read_event_config,\n\t.write_event_config = &ams_write_event_config,\n\t.read_event_value = &ams_read_event_value,\n\t.write_event_value = &ams_write_event_value,\n};\n\nstatic const struct of_device_id ams_of_match_table[] = {\n\t{ .compatible = \"xlnx,zynqmp-ams\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ams_of_match_table);\n\nstatic int ams_probe(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct ams *ams;\n\tint ret;\n\tint irq;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*ams));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tams = iio_priv(indio_dev);\n\tmutex_init(&ams->lock);\n\tspin_lock_init(&ams->intr_lock);\n\n\tindio_dev->name = \"xilinx-ams\";\n\n\tindio_dev->info = &iio_ams_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tams->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ams->base))\n\t\treturn PTR_ERR(ams->base);\n\n\tams->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(ams->clk))\n\t\treturn PTR_ERR(ams->clk);\n\n\tret = devm_delayed_work_autocancel(&pdev->dev, &ams->ams_unmask_work,\n\t\t\t\t\t   ams_unmask_worker);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ams_parse_firmware(indio_dev);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"failure in parsing DT\\n\");\n\n\tret = ams_init_device(ams);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"failed to initialize AMS\\n\");\n\n\tams_enable_channel_sequence(indio_dev);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, &ams_irq, 0, \"ams-irq\",\n\t\t\t       indio_dev);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"failed to register interrupt\\n\");\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\treturn devm_iio_device_register(&pdev->dev, indio_dev);\n}\n\nstatic int ams_suspend(struct device *dev)\n{\n\tstruct ams *ams = iio_priv(dev_get_drvdata(dev));\n\n\tclk_disable_unprepare(ams->clk);\n\n\treturn 0;\n}\n\nstatic int ams_resume(struct device *dev)\n{\n\tstruct ams *ams = iio_priv(dev_get_drvdata(dev));\n\n\treturn clk_prepare_enable(ams->clk);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ams_pm_ops, ams_suspend, ams_resume);\n\nstatic struct platform_driver ams_driver = {\n\t.probe = ams_probe,\n\t.driver = {\n\t\t.name = \"xilinx-ams\",\n\t\t.pm = pm_sleep_ptr(&ams_pm_ops),\n\t\t.of_match_table = ams_of_match_table,\n\t},\n};\nmodule_platform_driver(ams_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Xilinx, Inc.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}