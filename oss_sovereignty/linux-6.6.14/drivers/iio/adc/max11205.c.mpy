{
  "module_name": "max11205.c",
  "hash_id": "642e82a1c7803c0e2cfa7e8afd8163d74bb19f494736167759127c95e1d93f81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/max11205.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/adc/ad_sigma_delta.h>\n\n#define MAX11205_BIT_SCALE\t15\n#define MAX11205A_OUT_DATA_RATE\t116\n#define MAX11205B_OUT_DATA_RATE\t13\n\nenum max11205_chip_type {\n\tTYPE_MAX11205A,\n\tTYPE_MAX11205B,\n};\n\nstruct max11205_chip_info {\n\tunsigned int\tout_data_rate;\n\tconst char\t*name;\n};\n\nstruct max11205_state {\n\tconst struct max11205_chip_info\t*chip_info;\n\tstruct regulator\t\t*vref;\n\tstruct ad_sigma_delta\t\tsd;\n};\n\nstatic const struct ad_sigma_delta_info max11205_sigma_delta_info = {\n\t.has_registers = false,\n};\n\nstatic int max11205_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct max11205_state *st = iio_priv(indio_dev);\n\tint reg_mv;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn ad_sigma_delta_single_conversion(indio_dev, chan, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treg_mv = regulator_get_voltage(st->vref);\n\t\tif (reg_mv < 0)\n\t\t\treturn reg_mv;\n\t\treg_mv /= 1000;\n\t\t*val = reg_mv;\n\t\t*val2 = MAX11205_BIT_SCALE;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = st->chip_info->out_data_rate;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info max11205_iio_info = {\n\t.read_raw = max11205_read_raw,\n\t.validate_trigger = ad_sd_validate_trigger,\n};\n\nstatic const struct iio_chan_spec max11205_channels[] = {\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.indexed = 1,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SAMP_FREQ) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t},\n};\n\nstatic const struct max11205_chip_info max11205_chip_info[] = {\n\t[TYPE_MAX11205A] = {\n\t\t.out_data_rate = MAX11205A_OUT_DATA_RATE,\n\t\t.name = \"max11205a\",\n\t},\n\t[TYPE_MAX11205B] = {\n\t\t.out_data_rate = MAX11205B_OUT_DATA_RATE,\n\t\t.name = \"max11205b\",\n\t},\n};\n\nstatic void max11205_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int max11205_probe(struct spi_device *spi)\n{\n\tstruct max11205_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tad_sd_init(&st->sd, indio_dev, spi, &max11205_sigma_delta_info);\n\n\tst->chip_info = device_get_match_data(&spi->dev);\n\tif (!st->chip_info)\n\t\tst->chip_info =\n\t\t\t(const struct max11205_chip_info *)spi_get_device_id(spi)->driver_data;\n\n\tindio_dev->name = st->chip_info->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = max11205_channels;\n\tindio_dev->num_channels = 1;\n\tindio_dev->info = &max11205_iio_info;\n\n\tst->vref = devm_regulator_get(&spi->dev, \"vref\");\n\tif (IS_ERR(st->vref))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(st->vref),\n\t\t\t\t     \"Failed to get vref regulator\\n\");\n\n\tret = regulator_enable(st->vref);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, max11205_reg_disable, st->vref);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_ad_sd_setup_buffer_and_trigger(&spi->dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id max11205_spi_ids[] = {\n\t{ \"max11205a\", (kernel_ulong_t)&max11205_chip_info[TYPE_MAX11205A] },\n\t{ \"max11205b\", (kernel_ulong_t)&max11205_chip_info[TYPE_MAX11205B] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, max11205_spi_ids);\n\nstatic const struct of_device_id max11205_dt_ids[] = {\n\t{\n\t\t.compatible = \"maxim,max11205a\",\n\t\t.data = &max11205_chip_info[TYPE_MAX11205A],\n\t},\n\t{\n\t\t.compatible = \"maxim,max11205b\",\n\t\t.data = &max11205_chip_info[TYPE_MAX11205B],\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max11205_dt_ids);\n\nstatic struct spi_driver max11205_spi_driver = {\n\t.driver = {\n\t\t.name = \"max11205\",\n\t\t.of_match_table = max11205_dt_ids,\n\t},\n\t.probe = max11205_probe,\n\t.id_table = max11205_spi_ids,\n};\nmodule_spi_driver(max11205_spi_driver);\n\nMODULE_AUTHOR(\"Ramona Bolboaca <ramona.bolboaca@analog.com>\");\nMODULE_DESCRIPTION(\"MAX11205 ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_AD_SIGMA_DELTA);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}