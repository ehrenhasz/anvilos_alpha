{
  "module_name": "max1118.c",
  "hash_id": "310bcae4c4bae227012642821b9b4e549d62d40573bff23203a9979c18c999fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/max1118.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/spi/spi.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/regulator/consumer.h>\n\nenum max1118_id {\n\tmax1117,\n\tmax1118,\n\tmax1119,\n};\n\nstruct max1118 {\n\tstruct spi_device *spi;\n\tstruct mutex lock;\n\tstruct regulator *reg;\n\t \n\tstruct {\n\t\tu8 channels[2];\n\t\ts64 ts __aligned(8);\n\t} scan;\n\n\tu8 data __aligned(IIO_DMA_MINALIGN);\n};\n\n#define MAX1118_CHANNEL(ch)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.channel = (ch),\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t\t.scan_index = ch,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t\t.realbits = 8,\t\t\t\t\t\\\n\t\t\t.storagebits = 8,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec max1118_channels[] = {\n\tMAX1118_CHANNEL(0),\n\tMAX1118_CHANNEL(1),\n\tIIO_CHAN_SOFT_TIMESTAMP(2),\n};\n\nstatic int max1118_read(struct iio_dev *indio_dev, int channel)\n{\n\tstruct max1118 *adc = iio_priv(indio_dev);\n\tstruct spi_transfer xfers[] = {\n\t\t \n\t\t{\n\t\t\t.len = 0,\n\t\t\t.delay = {\t \n\t\t\t\t.value = 1,\n\t\t\t\t.unit = SPI_DELAY_UNIT_USECS\n\t\t\t},\n\t\t\t.cs_change = 1,\n\t\t},\n\t\t \n\t\t{\n\t\t\t.len = 0,\n\t\t\t.delay = {\n\t\t\t\t.value = 8,\n\t\t\t\t.unit = SPI_DELAY_UNIT_USECS\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.rx_buf = &adc->data,\n\t\t\t.len = 1,\n\t\t},\n\t};\n\tint ret;\n\n\tif (channel == 0)\n\t\tret = spi_sync_transfer(adc->spi, xfers + 1, 2);\n\telse\n\t\tret = spi_sync_transfer(adc->spi, xfers, 3);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn adc->data;\n}\n\nstatic int max1118_get_vref_mV(struct iio_dev *indio_dev)\n{\n\tstruct max1118 *adc = iio_priv(indio_dev);\n\tconst struct spi_device_id *id = spi_get_device_id(adc->spi);\n\tint vref_uV;\n\n\tswitch (id->driver_data) {\n\tcase max1117:\n\t\treturn 2048;\n\tcase max1119:\n\t\treturn 4096;\n\tcase max1118:\n\t\tvref_uV = regulator_get_voltage(adc->reg);\n\t\tif (vref_uV < 0)\n\t\t\treturn vref_uV;\n\t\treturn vref_uV / 1000;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int max1118_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint *val, int *val2, long mask)\n{\n\tstruct max1118 *adc = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&adc->lock);\n\t\t*val = max1118_read(indio_dev, chan->channel);\n\t\tmutex_unlock(&adc->lock);\n\t\tif (*val < 0)\n\t\t\treturn *val;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = max1118_get_vref_mV(indio_dev);\n\t\tif (*val < 0)\n\t\t\treturn *val;\n\t\t*val2 = 8;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info max1118_info = {\n\t.read_raw = max1118_read_raw,\n};\n\nstatic irqreturn_t max1118_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct max1118 *adc = iio_priv(indio_dev);\n\tint scan_index;\n\tint i = 0;\n\n\tmutex_lock(&adc->lock);\n\n\tfor_each_set_bit(scan_index, indio_dev->active_scan_mask,\n\t\t\tindio_dev->masklength) {\n\t\tconst struct iio_chan_spec *scan_chan =\n\t\t\t\t&indio_dev->channels[scan_index];\n\t\tint ret = max1118_read(indio_dev, scan_chan->channel);\n\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&adc->spi->dev,\n\t\t\t\t\"failed to get conversion data\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tadc->scan.channels[i] = ret;\n\t\ti++;\n\t}\n\tiio_push_to_buffers_with_timestamp(indio_dev, &adc->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\nout:\n\tmutex_unlock(&adc->lock);\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void max1118_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int max1118_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct max1118 *adc;\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\tadc->spi = spi;\n\tmutex_init(&adc->lock);\n\n\tif (id->driver_data == max1118) {\n\t\tadc->reg = devm_regulator_get(&spi->dev, \"vref\");\n\t\tif (IS_ERR(adc->reg))\n\t\t\treturn dev_err_probe(&spi->dev, PTR_ERR(adc->reg),\n\t\t\t\t\t     \"failed to get vref regulator\\n\");\n\t\tret = regulator_enable(adc->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(&spi->dev, max1118_reg_disable,\n\t\t\t\t\t       adc->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t}\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->info = &max1118_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = max1118_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(max1118_channels);\n\n\t \n\tmax1118_read(indio_dev, 0);\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev, NULL,\n\t\t\t\t\t      max1118_trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id max1118_id[] = {\n\t{ \"max1117\", max1117 },\n\t{ \"max1118\", max1118 },\n\t{ \"max1119\", max1119 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, max1118_id);\n\nstatic const struct of_device_id max1118_dt_ids[] = {\n\t{ .compatible = \"maxim,max1117\" },\n\t{ .compatible = \"maxim,max1118\" },\n\t{ .compatible = \"maxim,max1119\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, max1118_dt_ids);\n\nstatic struct spi_driver max1118_spi_driver = {\n\t.driver = {\n\t\t.name = \"max1118\",\n\t\t.of_match_table = max1118_dt_ids,\n\t},\n\t.probe = max1118_probe,\n\t.id_table = max1118_id,\n};\nmodule_spi_driver(max1118_spi_driver);\n\nMODULE_AUTHOR(\"Akinobu Mita <akinobu.mita@gmail.com>\");\nMODULE_DESCRIPTION(\"MAXIM MAX1117/MAX1118/MAX1119 ADCs driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}