{
  "module_name": "ti-adc12138.c",
  "hash_id": "872cc714bdf6de836e691cc44f8c1708e073cacb2f34bd40b51ad164748cf358",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-adc12138.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/completion.h>\n#include <linux/clk.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/regulator/consumer.h>\n\n#define ADC12138_MODE_AUTO_CAL\t\t\t0x08\n#define ADC12138_MODE_READ_STATUS\t\t0x0c\n#define ADC12138_MODE_ACQUISITION_TIME_6\t0x0e\n#define ADC12138_MODE_ACQUISITION_TIME_10\t0x4e\n#define ADC12138_MODE_ACQUISITION_TIME_18\t0x8e\n#define ADC12138_MODE_ACQUISITION_TIME_34\t0xce\n\n#define ADC12138_STATUS_CAL\t\t\tBIT(6)\n\nenum {\n\tadc12130,\n\tadc12132,\n\tadc12138,\n};\n\nstruct adc12138 {\n\tstruct spi_device *spi;\n\tunsigned int id;\n\t \n\tstruct clk *cclk;\n\t \n\tstruct regulator *vref_p;\n\t \n\tstruct regulator *vref_n;\n\tstruct mutex lock;\n\tstruct completion complete;\n\t \n\tunsigned int acquisition_time;\n\t \n\t__be16 data[20] __aligned(8);\n\n\tu8 tx_buf[2] __aligned(IIO_DMA_MINALIGN);\n\tu8 rx_buf[2];\n};\n\n#define ADC12138_VOLTAGE_CHANNEL(chan)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.channel = chan,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE)\t\\\n\t\t\t\t\t| BIT(IIO_CHAN_INFO_OFFSET),\t\\\n\t\t.scan_index = chan,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\t\\\n\t\t\t.realbits = 13,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.shift = 3,\t\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\n#define ADC12138_VOLTAGE_CHANNEL_DIFF(chan1, chan2, si)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.channel = (chan1),\t\t\t\t\t\\\n\t\t.channel2 = (chan2),\t\t\t\t\t\\\n\t\t.differential = 1,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE)\t\\\n\t\t\t\t\t| BIT(IIO_CHAN_INFO_OFFSET),\t\\\n\t\t.scan_index = si,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\t\\\n\t\t\t.realbits = 13,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.shift = 3,\t\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec adc12132_channels[] = {\n\tADC12138_VOLTAGE_CHANNEL(0),\n\tADC12138_VOLTAGE_CHANNEL(1),\n\tADC12138_VOLTAGE_CHANNEL_DIFF(0, 1, 2),\n\tADC12138_VOLTAGE_CHANNEL_DIFF(1, 0, 3),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic const struct iio_chan_spec adc12138_channels[] = {\n\tADC12138_VOLTAGE_CHANNEL(0),\n\tADC12138_VOLTAGE_CHANNEL(1),\n\tADC12138_VOLTAGE_CHANNEL(2),\n\tADC12138_VOLTAGE_CHANNEL(3),\n\tADC12138_VOLTAGE_CHANNEL(4),\n\tADC12138_VOLTAGE_CHANNEL(5),\n\tADC12138_VOLTAGE_CHANNEL(6),\n\tADC12138_VOLTAGE_CHANNEL(7),\n\tADC12138_VOLTAGE_CHANNEL_DIFF(0, 1, 8),\n\tADC12138_VOLTAGE_CHANNEL_DIFF(1, 0, 9),\n\tADC12138_VOLTAGE_CHANNEL_DIFF(2, 3, 10),\n\tADC12138_VOLTAGE_CHANNEL_DIFF(3, 2, 11),\n\tADC12138_VOLTAGE_CHANNEL_DIFF(4, 5, 12),\n\tADC12138_VOLTAGE_CHANNEL_DIFF(5, 4, 13),\n\tADC12138_VOLTAGE_CHANNEL_DIFF(6, 7, 14),\n\tADC12138_VOLTAGE_CHANNEL_DIFF(7, 6, 15),\n\tIIO_CHAN_SOFT_TIMESTAMP(16),\n};\n\nstatic int adc12138_mode_programming(struct adc12138 *adc, u8 mode,\n\t\t\t\t     void *rx_buf, int len)\n{\n\tstruct spi_transfer xfer = {\n\t\t.tx_buf = adc->tx_buf,\n\t\t.rx_buf = adc->rx_buf,\n\t\t.len = len,\n\t};\n\tint ret;\n\n\t \n\tif (adc->id != adc12138)\n\t\tmode = (mode & 0xc0) | ((mode & 0x0f) << 2);\n\n\tadc->tx_buf[0] = mode;\n\n\tret = spi_sync_transfer(adc->spi, &xfer, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(rx_buf, adc->rx_buf, len);\n\n\treturn 0;\n}\n\nstatic int adc12138_read_status(struct adc12138 *adc)\n{\n\tu8 rx_buf[2];\n\tint ret;\n\n\tret = adc12138_mode_programming(adc, ADC12138_MODE_READ_STATUS,\n\t\t\t\t\trx_buf, 2);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (rx_buf[0] << 1) | (rx_buf[1] >> 7);\n}\n\nstatic int __adc12138_start_conv(struct adc12138 *adc,\n\t\t\t\t struct iio_chan_spec const *channel,\n\t\t\t\t void *data, int len)\n\n{\n\tstatic const u8 ch_to_mux[] = { 0, 4, 1, 5, 2, 6, 3, 7 };\n\tu8 mode = (ch_to_mux[channel->channel] << 4) |\n\t\t  (channel->differential ? 0 : 0x80);\n\n\treturn adc12138_mode_programming(adc, mode, data, len);\n}\n\nstatic int adc12138_start_conv(struct adc12138 *adc,\n\t\t\t       struct iio_chan_spec const *channel)\n{\n\tu8 trash;\n\n\treturn __adc12138_start_conv(adc, channel, &trash, 1);\n}\n\nstatic int adc12138_start_and_read_conv(struct adc12138 *adc,\n\t\t\t\t\tstruct iio_chan_spec const *channel,\n\t\t\t\t\t__be16 *data)\n{\n\treturn __adc12138_start_conv(adc, channel, data, 2);\n}\n\nstatic int adc12138_read_conv_data(struct adc12138 *adc, __be16 *value)\n{\n\t \n\treturn adc12138_mode_programming(adc, ADC12138_MODE_READ_STATUS,\n\t\t\t\t\t value, sizeof(*value));\n}\n\nstatic int adc12138_wait_eoc(struct adc12138 *adc, unsigned long timeout)\n{\n\tif (!wait_for_completion_timeout(&adc->complete, timeout))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int adc12138_adc_conversion(struct adc12138 *adc,\n\t\t\t\t   struct iio_chan_spec const *channel,\n\t\t\t\t   __be16 *value)\n{\n\tint ret;\n\n\treinit_completion(&adc->complete);\n\n\tret = adc12138_start_conv(adc, channel);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adc12138_wait_eoc(adc, msecs_to_jiffies(100));\n\tif (ret)\n\t\treturn ret;\n\n\treturn adc12138_read_conv_data(adc, value);\n}\n\nstatic int adc12138_read_raw(struct iio_dev *iio,\n\t\t\t     struct iio_chan_spec const *channel, int *value,\n\t\t\t     int *shift, long mask)\n{\n\tstruct adc12138 *adc = iio_priv(iio);\n\tint ret;\n\t__be16 data;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&adc->lock);\n\t\tret = adc12138_adc_conversion(adc, channel, &data);\n\t\tmutex_unlock(&adc->lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*value = sign_extend32(be16_to_cpu(data) >> channel->scan_type.shift,\n\t\t\t\t       channel->scan_type.realbits - 1);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = regulator_get_voltage(adc->vref_p);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*value = ret;\n\n\t\tif (!IS_ERR(adc->vref_n)) {\n\t\t\tret = regulator_get_voltage(adc->vref_n);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*value -= ret;\n\t\t}\n\n\t\t \n\t\t*value /= 1000;\n\t\t*shift = channel->scan_type.realbits - 1;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (!IS_ERR(adc->vref_n)) {\n\t\t\t*value = regulator_get_voltage(adc->vref_n);\n\t\t\tif (*value < 0)\n\t\t\t\treturn *value;\n\t\t} else {\n\t\t\t*value = 0;\n\t\t}\n\n\t\t \n\t\t*value /= 1000;\n\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info adc12138_info = {\n\t.read_raw = adc12138_read_raw,\n};\n\nstatic int adc12138_init(struct adc12138 *adc)\n{\n\tint ret;\n\tint status;\n\tu8 mode;\n\tu8 trash;\n\n\treinit_completion(&adc->complete);\n\n\tret = adc12138_mode_programming(adc, ADC12138_MODE_AUTO_CAL, &trash, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tstatus = adc12138_read_status(adc);\n\tif (status < 0)\n\t\treturn status;\n\n\tadc12138_wait_eoc(adc, msecs_to_jiffies(100));\n\n\tstatus = adc12138_read_status(adc);\n\tif (status & ADC12138_STATUS_CAL) {\n\t\tdev_warn(&adc->spi->dev,\n\t\t\t\"Auto Cal sequence is still in progress: %#x\\n\",\n\t\t\tstatus);\n\t\treturn -EIO;\n\t}\n\n\tswitch (adc->acquisition_time) {\n\tcase 6:\n\t\tmode = ADC12138_MODE_ACQUISITION_TIME_6;\n\t\tbreak;\n\tcase 10:\n\t\tmode = ADC12138_MODE_ACQUISITION_TIME_10;\n\t\tbreak;\n\tcase 18:\n\t\tmode = ADC12138_MODE_ACQUISITION_TIME_18;\n\t\tbreak;\n\tcase 34:\n\t\tmode = ADC12138_MODE_ACQUISITION_TIME_34;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn adc12138_mode_programming(adc, mode, &trash, 1);\n}\n\nstatic irqreturn_t adc12138_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct adc12138 *adc = iio_priv(indio_dev);\n\t__be16 trash;\n\tint ret;\n\tint scan_index;\n\tint i = 0;\n\n\tmutex_lock(&adc->lock);\n\n\tfor_each_set_bit(scan_index, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\tconst struct iio_chan_spec *scan_chan =\n\t\t\t\t&indio_dev->channels[scan_index];\n\n\t\treinit_completion(&adc->complete);\n\n\t\tret = adc12138_start_and_read_conv(adc, scan_chan,\n\t\t\t\t\ti ? &adc->data[i - 1] : &trash);\n\t\tif (ret) {\n\t\t\tdev_warn(&adc->spi->dev,\n\t\t\t\t \"failed to start conversion\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = adc12138_wait_eoc(adc, msecs_to_jiffies(100));\n\t\tif (ret) {\n\t\t\tdev_warn(&adc->spi->dev, \"wait eoc timeout\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\ti++;\n\t}\n\n\tif (i) {\n\t\tret = adc12138_read_conv_data(adc, &adc->data[i - 1]);\n\t\tif (ret) {\n\t\t\tdev_warn(&adc->spi->dev,\n\t\t\t\t \"failed to get conversion data\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, adc->data,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\nout:\n\tmutex_unlock(&adc->lock);\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t adc12138_eoc_handler(int irq, void *p)\n{\n\tstruct iio_dev *indio_dev = p;\n\tstruct adc12138 *adc = iio_priv(indio_dev);\n\n\tcomplete(&adc->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int adc12138_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct adc12138 *adc;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\tadc->spi = spi;\n\tadc->id = spi_get_device_id(spi)->driver_data;\n\tmutex_init(&adc->lock);\n\tinit_completion(&adc->complete);\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->info = &adc12138_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tswitch (adc->id) {\n\tcase adc12130:\n\tcase adc12132:\n\t\tindio_dev->channels = adc12132_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(adc12132_channels);\n\t\tbreak;\n\tcase adc12138:\n\t\tindio_dev->channels = adc12138_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(adc12138_channels);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = device_property_read_u32(&spi->dev, \"ti,acquisition-time\",\n\t\t\t\t       &adc->acquisition_time);\n\tif (ret)\n\t\tadc->acquisition_time = 10;\n\n\tadc->cclk = devm_clk_get(&spi->dev, NULL);\n\tif (IS_ERR(adc->cclk))\n\t\treturn PTR_ERR(adc->cclk);\n\n\tadc->vref_p = devm_regulator_get(&spi->dev, \"vref-p\");\n\tif (IS_ERR(adc->vref_p))\n\t\treturn PTR_ERR(adc->vref_p);\n\n\tadc->vref_n = devm_regulator_get_optional(&spi->dev, \"vref-n\");\n\tif (IS_ERR(adc->vref_n)) {\n\t\t \n\t\tret = PTR_ERR(adc->vref_n);\n\t\tif (ret != -ENODEV)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_request_irq(&spi->dev, spi->irq, adc12138_eoc_handler,\n\t\t\t       IRQF_TRIGGER_RISING, indio_dev->name, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(adc->cclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_enable(adc->vref_p);\n\tif (ret)\n\t\tgoto err_clk_disable;\n\n\tif (!IS_ERR(adc->vref_n)) {\n\t\tret = regulator_enable(adc->vref_n);\n\t\tif (ret)\n\t\t\tgoto err_vref_p_disable;\n\t}\n\n\tret = adc12138_init(adc);\n\tif (ret)\n\t\tgoto err_vref_n_disable;\n\n\tspi_set_drvdata(spi, indio_dev);\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL,\n\t\t\t\t\t adc12138_trigger_handler, NULL);\n\tif (ret)\n\t\tgoto err_vref_n_disable;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto err_buffer_cleanup;\n\n\treturn 0;\nerr_buffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\nerr_vref_n_disable:\n\tif (!IS_ERR(adc->vref_n))\n\t\tregulator_disable(adc->vref_n);\nerr_vref_p_disable:\n\tregulator_disable(adc->vref_p);\nerr_clk_disable:\n\tclk_disable_unprepare(adc->cclk);\n\n\treturn ret;\n}\n\nstatic void adc12138_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct adc12138 *adc = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tif (!IS_ERR(adc->vref_n))\n\t\tregulator_disable(adc->vref_n);\n\tregulator_disable(adc->vref_p);\n\tclk_disable_unprepare(adc->cclk);\n}\n\nstatic const struct of_device_id adc12138_dt_ids[] = {\n\t{ .compatible = \"ti,adc12130\", },\n\t{ .compatible = \"ti,adc12132\", },\n\t{ .compatible = \"ti,adc12138\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, adc12138_dt_ids);\n\nstatic const struct spi_device_id adc12138_id[] = {\n\t{ \"adc12130\", adc12130 },\n\t{ \"adc12132\", adc12132 },\n\t{ \"adc12138\", adc12138 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, adc12138_id);\n\nstatic struct spi_driver adc12138_driver = {\n\t.driver = {\n\t\t.name = \"adc12138\",\n\t\t.of_match_table = adc12138_dt_ids,\n\t},\n\t.probe = adc12138_probe,\n\t.remove = adc12138_remove,\n\t.id_table = adc12138_id,\n};\nmodule_spi_driver(adc12138_driver);\n\nMODULE_AUTHOR(\"Akinobu Mita <akinobu.mita@gmail.com>\");\nMODULE_DESCRIPTION(\"ADC12130/ADC12132/ADC12138 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}