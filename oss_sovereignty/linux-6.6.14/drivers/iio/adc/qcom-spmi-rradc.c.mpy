{
  "module_name": "qcom-spmi-rradc.c",
  "hash_id": "3d2dfe582b10a7ceb17748fc35aea5c8be5ca312110170dcfa010f24074f6505",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/qcom-spmi-rradc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/spmi.h>\n#include <linux/types.h>\n#include <linux/units.h>\n\n#include <asm/unaligned.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/types.h>\n\n#include <soc/qcom/qcom-spmi-pmic.h>\n\n#define DRIVER_NAME \"qcom-spmi-rradc\"\n\n#define RR_ADC_EN_CTL 0x46\n#define RR_ADC_SKIN_TEMP_LSB 0x50\n#define RR_ADC_SKIN_TEMP_MSB 0x51\n#define RR_ADC_CTL 0x52\n#define RR_ADC_CTL_CONTINUOUS_SEL BIT(3)\n#define RR_ADC_LOG 0x53\n#define RR_ADC_LOG_CLR_CTRL BIT(0)\n\n#define RR_ADC_FAKE_BATT_LOW_LSB 0x58\n#define RR_ADC_FAKE_BATT_LOW_MSB 0x59\n#define RR_ADC_FAKE_BATT_HIGH_LSB 0x5A\n#define RR_ADC_FAKE_BATT_HIGH_MSB 0x5B\n\n#define RR_ADC_BATT_ID_CTRL 0x60\n#define RR_ADC_BATT_ID_CTRL_CHANNEL_CONV BIT(0)\n#define RR_ADC_BATT_ID_TRIGGER 0x61\n#define RR_ADC_BATT_ID_STS 0x62\n#define RR_ADC_BATT_ID_CFG 0x63\n#define BATT_ID_SETTLE_MASK GENMASK(7, 5)\n#define RR_ADC_BATT_ID_5_LSB 0x66\n#define RR_ADC_BATT_ID_5_MSB 0x67\n#define RR_ADC_BATT_ID_15_LSB 0x68\n#define RR_ADC_BATT_ID_15_MSB 0x69\n#define RR_ADC_BATT_ID_150_LSB 0x6A\n#define RR_ADC_BATT_ID_150_MSB 0x6B\n\n#define RR_ADC_BATT_THERM_CTRL 0x70\n#define RR_ADC_BATT_THERM_TRIGGER 0x71\n#define RR_ADC_BATT_THERM_STS 0x72\n#define RR_ADC_BATT_THERM_CFG 0x73\n#define RR_ADC_BATT_THERM_LSB 0x74\n#define RR_ADC_BATT_THERM_MSB 0x75\n#define RR_ADC_BATT_THERM_FREQ 0x76\n\n#define RR_ADC_AUX_THERM_CTRL 0x80\n#define RR_ADC_AUX_THERM_TRIGGER 0x81\n#define RR_ADC_AUX_THERM_STS 0x82\n#define RR_ADC_AUX_THERM_CFG 0x83\n#define RR_ADC_AUX_THERM_LSB 0x84\n#define RR_ADC_AUX_THERM_MSB 0x85\n\n#define RR_ADC_SKIN_HOT 0x86\n#define RR_ADC_SKIN_TOO_HOT 0x87\n\n#define RR_ADC_AUX_THERM_C1 0x88\n#define RR_ADC_AUX_THERM_C2 0x89\n#define RR_ADC_AUX_THERM_C3 0x8A\n#define RR_ADC_AUX_THERM_HALF_RANGE 0x8B\n\n#define RR_ADC_USB_IN_V_CTRL 0x90\n#define RR_ADC_USB_IN_V_TRIGGER 0x91\n#define RR_ADC_USB_IN_V_STS 0x92\n#define RR_ADC_USB_IN_V_LSB 0x94\n#define RR_ADC_USB_IN_V_MSB 0x95\n#define RR_ADC_USB_IN_I_CTRL 0x98\n#define RR_ADC_USB_IN_I_TRIGGER 0x99\n#define RR_ADC_USB_IN_I_STS 0x9A\n#define RR_ADC_USB_IN_I_LSB 0x9C\n#define RR_ADC_USB_IN_I_MSB 0x9D\n\n#define RR_ADC_DC_IN_V_CTRL 0xA0\n#define RR_ADC_DC_IN_V_TRIGGER 0xA1\n#define RR_ADC_DC_IN_V_STS 0xA2\n#define RR_ADC_DC_IN_V_LSB 0xA4\n#define RR_ADC_DC_IN_V_MSB 0xA5\n#define RR_ADC_DC_IN_I_CTRL 0xA8\n#define RR_ADC_DC_IN_I_TRIGGER 0xA9\n#define RR_ADC_DC_IN_I_STS 0xAA\n#define RR_ADC_DC_IN_I_LSB 0xAC\n#define RR_ADC_DC_IN_I_MSB 0xAD\n\n#define RR_ADC_PMI_DIE_TEMP_CTRL 0xB0\n#define RR_ADC_PMI_DIE_TEMP_TRIGGER 0xB1\n#define RR_ADC_PMI_DIE_TEMP_STS 0xB2\n#define RR_ADC_PMI_DIE_TEMP_CFG 0xB3\n#define RR_ADC_PMI_DIE_TEMP_LSB 0xB4\n#define RR_ADC_PMI_DIE_TEMP_MSB 0xB5\n\n#define RR_ADC_CHARGER_TEMP_CTRL 0xB8\n#define RR_ADC_CHARGER_TEMP_TRIGGER 0xB9\n#define RR_ADC_CHARGER_TEMP_STS 0xBA\n#define RR_ADC_CHARGER_TEMP_CFG 0xBB\n#define RR_ADC_CHARGER_TEMP_LSB 0xBC\n#define RR_ADC_CHARGER_TEMP_MSB 0xBD\n#define RR_ADC_CHARGER_HOT 0xBE\n#define RR_ADC_CHARGER_TOO_HOT 0xBF\n\n#define RR_ADC_GPIO_CTRL 0xC0\n#define RR_ADC_GPIO_TRIGGER 0xC1\n#define RR_ADC_GPIO_STS 0xC2\n#define RR_ADC_GPIO_LSB 0xC4\n#define RR_ADC_GPIO_MSB 0xC5\n\n#define RR_ADC_ATEST_CTRL 0xC8\n#define RR_ADC_ATEST_TRIGGER 0xC9\n#define RR_ADC_ATEST_STS 0xCA\n#define RR_ADC_ATEST_LSB 0xCC\n#define RR_ADC_ATEST_MSB 0xCD\n#define RR_ADC_SEC_ACCESS 0xD0\n\n#define RR_ADC_PERPH_RESET_CTL2 0xD9\n#define RR_ADC_PERPH_RESET_CTL3 0xDA\n#define RR_ADC_PERPH_RESET_CTL4 0xDB\n#define RR_ADC_INT_TEST1 0xE0\n#define RR_ADC_INT_TEST_VAL 0xE1\n\n#define RR_ADC_TM_TRIGGER_CTRLS 0xE2\n#define RR_ADC_TM_ADC_CTRLS 0xE3\n#define RR_ADC_TM_CNL_CTRL 0xE4\n#define RR_ADC_TM_BATT_ID_CTRL 0xE5\n#define RR_ADC_TM_THERM_CTRL 0xE6\n#define RR_ADC_TM_CONV_STS 0xE7\n#define RR_ADC_TM_ADC_READ_LSB 0xE8\n#define RR_ADC_TM_ADC_READ_MSB 0xE9\n#define RR_ADC_TM_ATEST_MUX_1 0xEA\n#define RR_ADC_TM_ATEST_MUX_2 0xEB\n#define RR_ADC_TM_REFERENCES 0xED\n#define RR_ADC_TM_MISC_CTL 0xEE\n#define RR_ADC_TM_RR_CTRL 0xEF\n\n#define RR_ADC_TRIGGER_EVERY_CYCLE BIT(7)\n#define RR_ADC_TRIGGER_CTL BIT(0)\n\n#define RR_ADC_BATT_ID_RANGE 820\n\n#define RR_ADC_BITS 10\n#define RR_ADC_CHAN_MSB (1 << RR_ADC_BITS)\n#define RR_ADC_FS_VOLTAGE_MV 2500\n\n \n#define RR_ADC_BATT_THERM_LSB_K 4\n\n#define RR_ADC_TEMP_FS_VOLTAGE_NUM 5000000\n#define RR_ADC_TEMP_FS_VOLTAGE_DEN 3\n#define RR_ADC_DIE_TEMP_OFFSET 601400\n#define RR_ADC_DIE_TEMP_SLOPE 2\n#define RR_ADC_DIE_TEMP_OFFSET_MILLI_DEGC 25000\n\n#define RR_ADC_CHG_TEMP_GF_OFFSET_UV 1303168\n#define RR_ADC_CHG_TEMP_GF_SLOPE_UV_PER_C 3784\n#define RR_ADC_CHG_TEMP_SMIC_OFFSET_UV 1338433\n#define RR_ADC_CHG_TEMP_SMIC_SLOPE_UV_PER_C 3655\n#define RR_ADC_CHG_TEMP_660_GF_OFFSET_UV 1309001\n#define RR_ADC_CHG_TEMP_660_GF_SLOPE_UV_PER_C 3403\n#define RR_ADC_CHG_TEMP_660_SMIC_OFFSET_UV 1295898\n#define RR_ADC_CHG_TEMP_660_SMIC_SLOPE_UV_PER_C 3596\n#define RR_ADC_CHG_TEMP_660_MGNA_OFFSET_UV 1314779\n#define RR_ADC_CHG_TEMP_660_MGNA_SLOPE_UV_PER_C 3496\n#define RR_ADC_CHG_TEMP_OFFSET_MILLI_DEGC 25000\n#define RR_ADC_CHG_THRESHOLD_SCALE 4\n\n#define RR_ADC_VOLT_INPUT_FACTOR 8\n#define RR_ADC_CURR_INPUT_FACTOR 2000\n#define RR_ADC_CURR_USBIN_INPUT_FACTOR_MIL 1886\n#define RR_ADC_CURR_USBIN_660_FACTOR_MIL 9\n#define RR_ADC_CURR_USBIN_660_UV_VAL 579500\n\n#define RR_ADC_GPIO_FS_RANGE 5000\n#define RR_ADC_COHERENT_CHECK_RETRY 5\n#define RR_ADC_CHAN_MAX_CONTINUOUS_BUFFER_LEN 16\n\n#define RR_ADC_STS_CHANNEL_READING_MASK GENMASK(1, 0)\n#define RR_ADC_STS_CHANNEL_STS BIT(1)\n\n#define RR_ADC_TP_REV_VERSION1 21\n#define RR_ADC_TP_REV_VERSION2 29\n#define RR_ADC_TP_REV_VERSION3 32\n\n#define RRADC_BATT_ID_DELAY_MAX 8\n\nenum rradc_channel_id {\n\tRR_ADC_BATT_ID = 0,\n\tRR_ADC_BATT_THERM,\n\tRR_ADC_SKIN_TEMP,\n\tRR_ADC_USBIN_I,\n\tRR_ADC_USBIN_V,\n\tRR_ADC_DCIN_I,\n\tRR_ADC_DCIN_V,\n\tRR_ADC_DIE_TEMP,\n\tRR_ADC_CHG_TEMP,\n\tRR_ADC_GPIO,\n\tRR_ADC_CHAN_MAX\n};\n\nstruct rradc_chip;\n\n \nstruct rradc_channel {\n\tconst char *label;\n\tu8 lsb;\n\tu8 status;\n\tint size;\n\tint trigger_addr;\n\tint trigger_mask;\n\tint (*scale_fn)(struct rradc_chip *chip, u16 adc_code, int *result);\n};\n\nstruct rradc_chip {\n\tstruct device *dev;\n\tconst struct qcom_spmi_pmic *pmic;\n\t \n\tstruct mutex conversion_lock;\n\tstruct regmap *regmap;\n\tu32 base;\n\tint batt_id_delay;\n\tu16 batt_id_data;\n};\n\nstatic const int batt_id_delays[] = { 0, 1, 4, 12, 20, 40, 60, 80 };\nstatic const struct rradc_channel rradc_chans[RR_ADC_CHAN_MAX];\nstatic const struct iio_chan_spec rradc_iio_chans[RR_ADC_CHAN_MAX];\n\nstatic int rradc_read(struct rradc_chip *chip, u16 addr, __le16 *buf, int len)\n{\n\tint ret, retry_cnt = 0;\n\t__le16 data_check[RR_ADC_CHAN_MAX_CONTINUOUS_BUFFER_LEN / 2];\n\n\tif (len > RR_ADC_CHAN_MAX_CONTINUOUS_BUFFER_LEN) {\n\t\tdev_err(chip->dev,\n\t\t\t\"Can't read more than %d bytes, but asked to read %d bytes.\\n\",\n\t\t\tRR_ADC_CHAN_MAX_CONTINUOUS_BUFFER_LEN, len);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (retry_cnt < RR_ADC_COHERENT_CHECK_RETRY) {\n\t\tret = regmap_bulk_read(chip->regmap, chip->base + addr, buf,\n\t\t\t\t       len);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev, \"rr_adc reg 0x%x failed :%d\\n\", addr,\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_bulk_read(chip->regmap, chip->base + addr,\n\t\t\t\t       data_check, len);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev, \"rr_adc reg 0x%x failed :%d\\n\", addr,\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (memcmp(buf, data_check, len) != 0) {\n\t\t\tretry_cnt++;\n\t\t\tdev_dbg(chip->dev,\n\t\t\t\t\"coherent read error, retry_cnt:%d\\n\",\n\t\t\t\tretry_cnt);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (retry_cnt == RR_ADC_COHERENT_CHECK_RETRY)\n\t\tdev_err(chip->dev, \"Retry exceeded for coherency check\\n\");\n\n\treturn ret;\n}\n\nstatic int rradc_get_fab_coeff(struct rradc_chip *chip, int64_t *offset,\n\t\t\t       int64_t *slope)\n{\n\tif (chip->pmic->subtype == PM660_SUBTYPE) {\n\t\tswitch (chip->pmic->fab_id) {\n\t\tcase PM660_FAB_ID_GF:\n\t\t\t*offset = RR_ADC_CHG_TEMP_660_GF_OFFSET_UV;\n\t\t\t*slope = RR_ADC_CHG_TEMP_660_GF_SLOPE_UV_PER_C;\n\t\t\treturn 0;\n\t\tcase PM660_FAB_ID_TSMC:\n\t\t\t*offset = RR_ADC_CHG_TEMP_660_SMIC_OFFSET_UV;\n\t\t\t*slope = RR_ADC_CHG_TEMP_660_SMIC_SLOPE_UV_PER_C;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t*offset = RR_ADC_CHG_TEMP_660_MGNA_OFFSET_UV;\n\t\t\t*slope = RR_ADC_CHG_TEMP_660_MGNA_SLOPE_UV_PER_C;\n\t\t}\n\t} else if (chip->pmic->subtype == PMI8998_SUBTYPE) {\n\t\tswitch (chip->pmic->fab_id) {\n\t\tcase PMI8998_FAB_ID_GF:\n\t\t\t*offset = RR_ADC_CHG_TEMP_GF_OFFSET_UV;\n\t\t\t*slope = RR_ADC_CHG_TEMP_GF_SLOPE_UV_PER_C;\n\t\t\treturn 0;\n\t\tcase PMI8998_FAB_ID_SMIC:\n\t\t\t*offset = RR_ADC_CHG_TEMP_SMIC_OFFSET_UV;\n\t\t\t*slope = RR_ADC_CHG_TEMP_SMIC_SLOPE_UV_PER_C;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int rradc_post_process_batt_id(struct rradc_chip *chip, u16 adc_code,\n\t\t\t\t      int *result_ohms)\n{\n\tuint32_t current_value;\n\tint64_t r_id;\n\n\tcurrent_value = chip->batt_id_data;\n\tr_id = ((int64_t)adc_code * RR_ADC_FS_VOLTAGE_MV);\n\tr_id = div64_s64(r_id, (RR_ADC_CHAN_MSB * current_value));\n\t*result_ohms = (int)(r_id * MILLI);\n\n\treturn 0;\n}\n\nstatic int rradc_enable_continuous_mode(struct rradc_chip *chip)\n{\n\tint ret;\n\n\t \n\tret = regmap_update_bits(chip->regmap, chip->base + RR_ADC_LOG,\n\t\t\t\t RR_ADC_LOG_CLR_CTRL, RR_ADC_LOG_CLR_CTRL);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"log ctrl update to clear failed:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(chip->regmap, chip->base + RR_ADC_LOG,\n\t\t\t\t RR_ADC_LOG_CLR_CTRL, 0);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"log ctrl update to not clear failed:%d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(chip->regmap, chip->base + RR_ADC_CTL,\n\t\t\t\t RR_ADC_CTL_CONTINUOUS_SEL,\n\t\t\t\t RR_ADC_CTL_CONTINUOUS_SEL);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Update to continuous mode failed:%d\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic int rradc_disable_continuous_mode(struct rradc_chip *chip)\n{\n\tint ret;\n\n\t \n\tret = regmap_update_bits(chip->regmap, chip->base + RR_ADC_CTL,\n\t\t\t\t RR_ADC_CTL_CONTINUOUS_SEL, 0);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Update to non-continuous mode failed:%d\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic bool rradc_is_ready(struct rradc_chip *chip,\n\t\t\t   enum rradc_channel_id chan_address)\n{\n\tconst struct rradc_channel *chan = &rradc_chans[chan_address];\n\tint ret;\n\tunsigned int status, mask;\n\n\t \n\tswitch (chan_address) {\n\tcase RR_ADC_BATT_ID:\n\t\tmask = RR_ADC_STS_CHANNEL_STS;\n\t\tbreak;\n\tdefault:\n\t\tmask = RR_ADC_STS_CHANNEL_READING_MASK;\n\t\tbreak;\n\t}\n\n\tret = regmap_read(chip->regmap, chip->base + chan->status, &status);\n\tif (ret < 0 || !(status & mask))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int rradc_read_status_in_cont_mode(struct rradc_chip *chip,\n\t\t\t\t\t  enum rradc_channel_id chan_address)\n{\n\tconst struct rradc_channel *chan = &rradc_chans[chan_address];\n\tconst struct iio_chan_spec *iio_chan = &rradc_iio_chans[chan_address];\n\tint ret, i;\n\n\tif (chan->trigger_mask == 0) {\n\t\tdev_err(chip->dev, \"Channel doesn't have a trigger mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(chip->regmap, chip->base + chan->trigger_addr,\n\t\t\t\t chan->trigger_mask, chan->trigger_mask);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev,\n\t\t\t\"Failed to apply trigger for channel '%s' ret=%d\\n\",\n\t\t\tiio_chan->extend_name, ret);\n\t\treturn ret;\n\t}\n\n\tret = rradc_enable_continuous_mode(chip);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to switch to continuous mode\\n\");\n\t\tgoto disable_trigger;\n\t}\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tif (rradc_is_ready(chip, chan_address))\n\t\t\tbreak;\n\t\tusleep_range(50000, 50000 + 500);\n\t}\n\n\tif (i == 5) {\n\t\tdev_err(chip->dev, \"Channel '%s' is not ready\\n\",\n\t\t\tiio_chan->extend_name);\n\t\tret = -ETIMEDOUT;\n\t}\n\n\trradc_disable_continuous_mode(chip);\n\ndisable_trigger:\n\tregmap_update_bits(chip->regmap, chip->base + chan->trigger_addr,\n\t\t\t   chan->trigger_mask, 0);\n\n\treturn ret;\n}\n\nstatic int rradc_prepare_batt_id_conversion(struct rradc_chip *chip,\n\t\t\t\t\t    enum rradc_channel_id chan_address,\n\t\t\t\t\t    u16 *data)\n{\n\tint ret;\n\n\tret = regmap_update_bits(chip->regmap, chip->base + RR_ADC_BATT_ID_CTRL,\n\t\t\t\t RR_ADC_BATT_ID_CTRL_CHANNEL_CONV,\n\t\t\t\t RR_ADC_BATT_ID_CTRL_CHANNEL_CONV);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Enabling BATT ID channel failed:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(chip->regmap,\n\t\t\t\t chip->base + RR_ADC_BATT_ID_TRIGGER,\n\t\t\t\t RR_ADC_TRIGGER_CTL, RR_ADC_TRIGGER_CTL);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"BATT_ID trigger set failed:%d\\n\", ret);\n\t\tgoto out_disable_batt_id;\n\t}\n\n\tret = rradc_read_status_in_cont_mode(chip, chan_address);\n\n\t \n\tregmap_update_bits(chip->regmap, chip->base + RR_ADC_BATT_ID_TRIGGER,\n\t\t\t   RR_ADC_TRIGGER_CTL, 0);\n\nout_disable_batt_id:\n\tregmap_update_bits(chip->regmap, chip->base + RR_ADC_BATT_ID_CTRL,\n\t\t\t   RR_ADC_BATT_ID_CTRL_CHANNEL_CONV, 0);\n\n\treturn ret;\n}\n\nstatic int rradc_do_conversion(struct rradc_chip *chip,\n\t\t\t       enum rradc_channel_id chan_address, u16 *data)\n{\n\tconst struct rradc_channel *chan = &rradc_chans[chan_address];\n\tconst struct iio_chan_spec *iio_chan = &rradc_iio_chans[chan_address];\n\tint ret;\n\t__le16 buf[3];\n\n\tmutex_lock(&chip->conversion_lock);\n\n\tswitch (chan_address) {\n\tcase RR_ADC_BATT_ID:\n\t\tret = rradc_prepare_batt_id_conversion(chip, chan_address, data);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev, \"Battery ID conversion failed:%d\\n\",\n\t\t\t\tret);\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tbreak;\n\n\tcase RR_ADC_USBIN_V:\n\tcase RR_ADC_DIE_TEMP:\n\t\tret = rradc_read_status_in_cont_mode(chip, chan_address);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"Error reading in continuous mode:%d\\n\", ret);\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (!rradc_is_ready(chip, chan_address)) {\n\t\t\t \n\t\t\tdev_dbg(chip->dev, \"channel '%s' is not ready\\n\",\n\t\t\t\tiio_chan->extend_name);\n\t\t\tret = -ENODATA;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tbreak;\n\t}\n\n\tret = rradc_read(chip, chan->lsb, buf, chan->size);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"read data failed\\n\");\n\t\tgoto unlock_out;\n\t}\n\n\t \n\tif (chan_address == RR_ADC_BATT_ID) {\n\t\tu16 batt_id_150 = le16_to_cpu(buf[2]);\n\t\tu16 batt_id_15 = le16_to_cpu(buf[1]);\n\t\tu16 batt_id_5 = le16_to_cpu(buf[0]);\n\n\t\tif (!batt_id_150 && !batt_id_15 && !batt_id_5) {\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"Invalid batt_id values with all zeros\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock_out;\n\t\t}\n\n\t\tif (batt_id_150 <= RR_ADC_BATT_ID_RANGE) {\n\t\t\t*data = batt_id_150;\n\t\t\tchip->batt_id_data = 150;\n\t\t} else if (batt_id_15 <= RR_ADC_BATT_ID_RANGE) {\n\t\t\t*data = batt_id_15;\n\t\t\tchip->batt_id_data = 15;\n\t\t} else {\n\t\t\t*data = batt_id_5;\n\t\t\tchip->batt_id_data = 5;\n\t\t}\n\t} else {\n\t\t \n\t\t*data = le16_to_cpu(buf[0]);\n\t}\n\nunlock_out:\n\tmutex_unlock(&chip->conversion_lock);\n\n\treturn ret;\n}\n\nstatic int rradc_read_scale(struct rradc_chip *chip, int chan_address, int *val,\n\t\t\t    int *val2)\n{\n\tint64_t fab_offset, fab_slope;\n\tint ret;\n\n\tret = rradc_get_fab_coeff(chip, &fab_offset, &fab_slope);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Unable to get fab id coefficients\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (chan_address) {\n\tcase RR_ADC_SKIN_TEMP:\n\t\t*val = MILLI;\n\t\t*val2 = RR_ADC_BATT_THERM_LSB_K;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase RR_ADC_USBIN_I:\n\t\t*val = RR_ADC_CURR_USBIN_INPUT_FACTOR_MIL *\n\t\t       RR_ADC_FS_VOLTAGE_MV;\n\t\t*val2 = RR_ADC_CHAN_MSB;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase RR_ADC_DCIN_I:\n\t\t*val = RR_ADC_CURR_INPUT_FACTOR * RR_ADC_FS_VOLTAGE_MV;\n\t\t*val2 = RR_ADC_CHAN_MSB;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase RR_ADC_USBIN_V:\n\tcase RR_ADC_DCIN_V:\n\t\t*val = RR_ADC_VOLT_INPUT_FACTOR * RR_ADC_FS_VOLTAGE_MV * MILLI;\n\t\t*val2 = RR_ADC_CHAN_MSB;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase RR_ADC_GPIO:\n\t\t*val = RR_ADC_GPIO_FS_RANGE;\n\t\t*val2 = RR_ADC_CHAN_MSB;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase RR_ADC_CHG_TEMP:\n\t\t \n\t\t*val = -RR_ADC_TEMP_FS_VOLTAGE_NUM;\n\t\t*val2 = div64_s64(RR_ADC_TEMP_FS_VOLTAGE_DEN * RR_ADC_CHAN_MSB *\n\t\t\t\t\t  fab_slope,\n\t\t\t\t  MILLI);\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase RR_ADC_DIE_TEMP:\n\t\t*val = RR_ADC_TEMP_FS_VOLTAGE_NUM;\n\t\t*val2 = RR_ADC_TEMP_FS_VOLTAGE_DEN * RR_ADC_CHAN_MSB *\n\t\t\tRR_ADC_DIE_TEMP_SLOPE;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rradc_read_offset(struct rradc_chip *chip, int chan_address, int *val)\n{\n\tint64_t fab_offset, fab_slope;\n\tint64_t offset1, offset2;\n\tint ret;\n\n\tswitch (chan_address) {\n\tcase RR_ADC_SKIN_TEMP:\n\t\t \n\t\t*val = div64_s64(ABSOLUTE_ZERO_MILLICELSIUS,\n\t\t\t\t (MILLI / RR_ADC_BATT_THERM_LSB_K));\n\t\treturn IIO_VAL_INT;\n\tcase RR_ADC_CHG_TEMP:\n\t\tret = rradc_get_fab_coeff(chip, &fab_offset, &fab_slope);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"Unable to get fab id coefficients\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\toffset1 = -(fab_offset * RR_ADC_TEMP_FS_VOLTAGE_DEN *\n\t\t\t    RR_ADC_CHAN_MSB);\n\t\toffset1 += (int64_t)RR_ADC_TEMP_FS_VOLTAGE_NUM / 2ULL;\n\t\toffset1 = div64_s64(offset1,\n\t\t\t\t    (int64_t)(RR_ADC_TEMP_FS_VOLTAGE_NUM));\n\n\t\toffset2 = (int64_t)RR_ADC_CHG_TEMP_OFFSET_MILLI_DEGC *\n\t\t\t  RR_ADC_TEMP_FS_VOLTAGE_DEN * RR_ADC_CHAN_MSB *\n\t\t\t  (int64_t)fab_slope;\n\t\toffset2 += ((int64_t)MILLI * RR_ADC_TEMP_FS_VOLTAGE_NUM) / 2;\n\t\toffset2 = div64_s64(\n\t\t\toffset2, ((int64_t)MILLI * RR_ADC_TEMP_FS_VOLTAGE_NUM));\n\n\t\t \n\t\t*val = (int)(offset1 - offset2 - 1);\n\t\treturn IIO_VAL_INT;\n\tcase RR_ADC_DIE_TEMP:\n\t\toffset1 = -RR_ADC_DIE_TEMP_OFFSET *\n\t\t\t  (int64_t)RR_ADC_TEMP_FS_VOLTAGE_DEN *\n\t\t\t  (int64_t)RR_ADC_CHAN_MSB;\n\t\toffset1 = div64_s64(offset1, RR_ADC_TEMP_FS_VOLTAGE_NUM);\n\n\t\toffset2 = -(int64_t)RR_ADC_CHG_TEMP_OFFSET_MILLI_DEGC *\n\t\t\t  RR_ADC_TEMP_FS_VOLTAGE_DEN * RR_ADC_CHAN_MSB *\n\t\t\t  RR_ADC_DIE_TEMP_SLOPE;\n\t\toffset2 = div64_s64(offset2,\n\t\t\t\t    ((int64_t)RR_ADC_TEMP_FS_VOLTAGE_NUM));\n\n\t\t \n\t\t*val = (int)(offset1 - offset2);\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int rradc_read_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan_spec, int *val,\n\t\t\t  int *val2, long mask)\n{\n\tstruct rradc_chip *chip = iio_priv(indio_dev);\n\tconst struct rradc_channel *chan;\n\tint ret;\n\tu16 adc_code;\n\n\tif (chan_spec->address >= RR_ADC_CHAN_MAX) {\n\t\tdev_err(chip->dev, \"Invalid channel index:%lu\\n\",\n\t\t\tchan_spec->address);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn rradc_read_scale(chip, chan_spec->address, val, val2);\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\treturn rradc_read_offset(chip, chan_spec->address, val);\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = rradc_do_conversion(chip, chan_spec->address, &adc_code);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = adc_code;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tchan = &rradc_chans[chan_spec->address];\n\t\tif (!chan->scale_fn)\n\t\t\treturn -EINVAL;\n\t\tret = rradc_do_conversion(chip, chan_spec->address, &adc_code);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = chan->scale_fn(chip, adc_code, val);\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rradc_read_label(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, char *label)\n{\n\treturn snprintf(label, PAGE_SIZE, \"%s\\n\",\n\t\t\trradc_chans[chan->address].label);\n}\n\nstatic const struct iio_info rradc_info = {\n\t.read_raw = rradc_read_raw,\n\t.read_label = rradc_read_label,\n};\n\nstatic const struct rradc_channel rradc_chans[RR_ADC_CHAN_MAX] = {\n\t{\n\t\t.label = \"batt_id\",\n\t\t.scale_fn = rradc_post_process_batt_id,\n\t\t.lsb = RR_ADC_BATT_ID_5_LSB,\n\t\t.status = RR_ADC_BATT_ID_STS,\n\t\t.size = 6,\n\t\t.trigger_addr = RR_ADC_BATT_ID_TRIGGER,\n\t\t.trigger_mask = BIT(0),\n\t}, {\n\t\t.label = \"batt\",\n\t\t.lsb = RR_ADC_BATT_THERM_LSB,\n\t\t.status = RR_ADC_BATT_THERM_STS,\n\t\t.size = 2,\n\t\t.trigger_addr = RR_ADC_BATT_THERM_TRIGGER,\n\t}, {\n\t\t.label = \"pmi8998_skin\",\n\t\t.lsb = RR_ADC_SKIN_TEMP_LSB,\n\t\t.status = RR_ADC_AUX_THERM_STS,\n\t\t.size = 2,\n\t\t.trigger_addr = RR_ADC_AUX_THERM_TRIGGER,\n\t}, {\n\t\t.label = \"usbin_i\",\n\t\t.lsb = RR_ADC_USB_IN_I_LSB,\n\t\t.status = RR_ADC_USB_IN_I_STS,\n\t\t.size = 2,\n\t\t.trigger_addr = RR_ADC_USB_IN_I_TRIGGER,\n\t}, {\n\t\t.label = \"usbin_v\",\n\t\t.lsb = RR_ADC_USB_IN_V_LSB,\n\t\t.status = RR_ADC_USB_IN_V_STS,\n\t\t.size = 2,\n\t\t.trigger_addr = RR_ADC_USB_IN_V_TRIGGER,\n\t\t.trigger_mask = BIT(7),\n\t}, {\n\t\t.label = \"dcin_i\",\n\t\t.lsb = RR_ADC_DC_IN_I_LSB,\n\t\t.status = RR_ADC_DC_IN_I_STS,\n\t\t.size = 2,\n\t\t.trigger_addr = RR_ADC_DC_IN_I_TRIGGER,\n\t}, {\n\t\t.label = \"dcin_v\",\n\t\t.lsb = RR_ADC_DC_IN_V_LSB,\n\t\t.status = RR_ADC_DC_IN_V_STS,\n\t\t.size = 2,\n\t\t.trigger_addr = RR_ADC_DC_IN_V_TRIGGER,\n\t}, {\n\t\t.label = \"pmi8998_die\",\n\t\t.lsb = RR_ADC_PMI_DIE_TEMP_LSB,\n\t\t.status = RR_ADC_PMI_DIE_TEMP_STS,\n\t\t.size = 2,\n\t\t.trigger_addr = RR_ADC_PMI_DIE_TEMP_TRIGGER,\n\t\t.trigger_mask = RR_ADC_TRIGGER_EVERY_CYCLE,\n\t}, {\n\t\t.label = \"chg\",\n\t\t.lsb = RR_ADC_CHARGER_TEMP_LSB,\n\t\t.status = RR_ADC_CHARGER_TEMP_STS,\n\t\t.size = 2,\n\t\t.trigger_addr = RR_ADC_CHARGER_TEMP_TRIGGER,\n\t}, {\n\t\t.label = \"gpio\",\n\t\t.lsb = RR_ADC_GPIO_LSB,\n\t\t.status = RR_ADC_GPIO_STS,\n\t\t.size = 2,\n\t\t.trigger_addr = RR_ADC_GPIO_TRIGGER,\n\t},\n};\n\nstatic const struct iio_chan_spec rradc_iio_chans[RR_ADC_CHAN_MAX] = {\n\t{\n\t\t.type = IIO_RESISTANCE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.address = RR_ADC_BATT_ID,\n\t\t.channel = 0,\n\t\t.indexed = 1,\n\t}, {\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.address = RR_ADC_BATT_THERM,\n\t\t.channel = 0,\n\t\t.indexed = 1,\n\t}, {\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.address = RR_ADC_SKIN_TEMP,\n\t\t.channel = 1,\n\t\t.indexed = 1,\n\t}, {\n\t\t.type = IIO_CURRENT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = RR_ADC_USBIN_I,\n\t\t.channel = 0,\n\t\t.indexed = 1,\n\t}, {\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = RR_ADC_USBIN_V,\n\t\t.channel = 0,\n\t\t.indexed = 1,\n\t}, {\n\t\t.type = IIO_CURRENT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = RR_ADC_DCIN_I,\n\t\t.channel = 1,\n\t\t.indexed = 1,\n\t}, {\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = RR_ADC_DCIN_V,\n\t\t.channel = 1,\n\t\t.indexed = 1,\n\t}, {\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.address = RR_ADC_DIE_TEMP,\n\t\t.channel = 2,\n\t\t.indexed = 1,\n\t}, {\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = RR_ADC_CHG_TEMP,\n\t\t.channel = 3,\n\t\t.indexed = 1,\n\t}, {\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = RR_ADC_GPIO,\n\t\t.channel = 2,\n\t\t.indexed = 1,\n\t},\n};\n\nstatic int rradc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct rradc_chip *chip;\n\tint ret, i, batt_id_delay;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*chip));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tchip = iio_priv(indio_dev);\n\tchip->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!chip->regmap) {\n\t\tdev_err(dev, \"Couldn't get parent's regmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchip->dev = dev;\n\tmutex_init(&chip->conversion_lock);\n\n\tret = device_property_read_u32(dev, \"reg\", &chip->base);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Couldn't find reg address, ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tbatt_id_delay = -1;\n\tret = device_property_read_u32(dev, \"qcom,batt-id-delay-ms\",\n\t\t\t\t       &batt_id_delay);\n\tif (!ret) {\n\t\tfor (i = 0; i < RRADC_BATT_ID_DELAY_MAX; i++) {\n\t\t\tif (batt_id_delay == batt_id_delays[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == RRADC_BATT_ID_DELAY_MAX)\n\t\t\tbatt_id_delay = -1;\n\t}\n\n\tif (batt_id_delay >= 0) {\n\t\tbatt_id_delay = FIELD_PREP(BATT_ID_SETTLE_MASK, batt_id_delay);\n\t\tret = regmap_update_bits(chip->regmap,\n\t\t\t\t\t chip->base + RR_ADC_BATT_ID_CFG,\n\t\t\t\t\t batt_id_delay, batt_id_delay);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"BATT_ID settling time config failed:%d\\n\",\n\t\t\t\tret);\n\t\t}\n\t}\n\n\t \n\tchip->pmic = qcom_pmic_get(chip->dev);\n\tif (IS_ERR(chip->pmic)) {\n\t\tdev_err(chip->dev, \"Unable to get reference to PMIC device\\n\");\n\t\treturn PTR_ERR(chip->pmic);\n\t}\n\n\tswitch (chip->pmic->subtype) {\n\tcase PMI8998_SUBTYPE:\n\t\tindio_dev->name = \"pmi8998-rradc\";\n\t\tbreak;\n\tcase PM660_SUBTYPE:\n\t\tindio_dev->name = \"pm660-rradc\";\n\t\tbreak;\n\tdefault:\n\t\tindio_dev->name = DRIVER_NAME;\n\t\tbreak;\n\t}\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &rradc_info;\n\tindio_dev->channels = rradc_iio_chans;\n\tindio_dev->num_channels = ARRAY_SIZE(rradc_iio_chans);\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id rradc_match_table[] = {\n\t{ .compatible = \"qcom,pm660-rradc\" },\n\t{ .compatible = \"qcom,pmi8998-rradc\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rradc_match_table);\n\nstatic struct platform_driver rradc_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table\t= rradc_match_table,\n\t},\n\t.probe = rradc_probe,\n};\nmodule_platform_driver(rradc_driver);\n\nMODULE_DESCRIPTION(\"QCOM SPMI PMIC RR ADC driver\");\nMODULE_AUTHOR(\"Caleb Connolly <caleb.connolly@linaro.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}