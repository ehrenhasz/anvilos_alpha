{
  "module_name": "ad7768-1.c",
  "hash_id": "9c2e74a024683e3aae0af4d611709dbde2be8b41a36e12a8b94d0077a2ec65c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7768-1.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n \n#define AD7768_REG_CHIP_TYPE\t\t0x3\n#define AD7768_REG_PROD_ID_L\t\t0x4\n#define AD7768_REG_PROD_ID_H\t\t0x5\n#define AD7768_REG_CHIP_GRADE\t\t0x6\n#define AD7768_REG_SCRATCH_PAD\t\t0x0A\n#define AD7768_REG_VENDOR_L\t\t0x0C\n#define AD7768_REG_VENDOR_H\t\t0x0D\n#define AD7768_REG_INTERFACE_FORMAT\t0x14\n#define AD7768_REG_POWER_CLOCK\t\t0x15\n#define AD7768_REG_ANALOG\t\t0x16\n#define AD7768_REG_ANALOG2\t\t0x17\n#define AD7768_REG_CONVERSION\t\t0x18\n#define AD7768_REG_DIGITAL_FILTER\t0x19\n#define AD7768_REG_SINC3_DEC_RATE_MSB\t0x1A\n#define AD7768_REG_SINC3_DEC_RATE_LSB\t0x1B\n#define AD7768_REG_DUTY_CYCLE_RATIO\t0x1C\n#define AD7768_REG_SYNC_RESET\t\t0x1D\n#define AD7768_REG_GPIO_CONTROL\t\t0x1E\n#define AD7768_REG_GPIO_WRITE\t\t0x1F\n#define AD7768_REG_GPIO_READ\t\t0x20\n#define AD7768_REG_OFFSET_HI\t\t0x21\n#define AD7768_REG_OFFSET_MID\t\t0x22\n#define AD7768_REG_OFFSET_LO\t\t0x23\n#define AD7768_REG_GAIN_HI\t\t0x24\n#define AD7768_REG_GAIN_MID\t\t0x25\n#define AD7768_REG_GAIN_LO\t\t0x26\n#define AD7768_REG_SPI_DIAG_ENABLE\t0x28\n#define AD7768_REG_ADC_DIAG_ENABLE\t0x29\n#define AD7768_REG_DIG_DIAG_ENABLE\t0x2A\n#define AD7768_REG_ADC_DATA\t\t0x2C\n#define AD7768_REG_MASTER_STATUS\t0x2D\n#define AD7768_REG_SPI_DIAG_STATUS\t0x2E\n#define AD7768_REG_ADC_DIAG_STATUS\t0x2F\n#define AD7768_REG_DIG_DIAG_STATUS\t0x30\n#define AD7768_REG_MCLK_COUNTER\t\t0x31\n\n \n#define AD7768_PWR_MCLK_DIV_MSK\t\tGENMASK(5, 4)\n#define AD7768_PWR_MCLK_DIV(x)\t\tFIELD_PREP(AD7768_PWR_MCLK_DIV_MSK, x)\n#define AD7768_PWR_PWRMODE_MSK\t\tGENMASK(1, 0)\n#define AD7768_PWR_PWRMODE(x)\t\tFIELD_PREP(AD7768_PWR_PWRMODE_MSK, x)\n\n \n#define AD7768_DIG_FIL_FIL_MSK\t\tGENMASK(6, 4)\n#define AD7768_DIG_FIL_FIL(x)\t\tFIELD_PREP(AD7768_DIG_FIL_FIL_MSK, x)\n#define AD7768_DIG_FIL_DEC_MSK\t\tGENMASK(2, 0)\n#define AD7768_DIG_FIL_DEC_RATE(x)\tFIELD_PREP(AD7768_DIG_FIL_DEC_MSK, x)\n\n \n#define AD7768_CONV_MODE_MSK\t\tGENMASK(2, 0)\n#define AD7768_CONV_MODE(x)\t\tFIELD_PREP(AD7768_CONV_MODE_MSK, x)\n\n#define AD7768_RD_FLAG_MSK(x)\t\t(BIT(6) | ((x) & 0x3F))\n#define AD7768_WR_FLAG_MSK(x)\t\t((x) & 0x3F)\n\nenum ad7768_conv_mode {\n\tAD7768_CONTINUOUS,\n\tAD7768_ONE_SHOT,\n\tAD7768_SINGLE,\n\tAD7768_PERIODIC,\n\tAD7768_STANDBY\n};\n\nenum ad7768_pwrmode {\n\tAD7768_ECO_MODE = 0,\n\tAD7768_MED_MODE = 2,\n\tAD7768_FAST_MODE = 3\n};\n\nenum ad7768_mclk_div {\n\tAD7768_MCLK_DIV_16,\n\tAD7768_MCLK_DIV_8,\n\tAD7768_MCLK_DIV_4,\n\tAD7768_MCLK_DIV_2\n};\n\nenum ad7768_dec_rate {\n\tAD7768_DEC_RATE_32 = 0,\n\tAD7768_DEC_RATE_64 = 1,\n\tAD7768_DEC_RATE_128 = 2,\n\tAD7768_DEC_RATE_256 = 3,\n\tAD7768_DEC_RATE_512 = 4,\n\tAD7768_DEC_RATE_1024 = 5,\n\tAD7768_DEC_RATE_8 = 9,\n\tAD7768_DEC_RATE_16 = 10\n};\n\nstruct ad7768_clk_configuration {\n\tenum ad7768_mclk_div mclk_div;\n\tenum ad7768_dec_rate dec_rate;\n\tunsigned int clk_div;\n\tenum ad7768_pwrmode pwrmode;\n};\n\nstatic const struct ad7768_clk_configuration ad7768_clk_config[] = {\n\t{ AD7768_MCLK_DIV_2, AD7768_DEC_RATE_8, 16,  AD7768_FAST_MODE },\n\t{ AD7768_MCLK_DIV_2, AD7768_DEC_RATE_16, 32,  AD7768_FAST_MODE },\n\t{ AD7768_MCLK_DIV_2, AD7768_DEC_RATE_32, 64, AD7768_FAST_MODE },\n\t{ AD7768_MCLK_DIV_2, AD7768_DEC_RATE_64, 128, AD7768_FAST_MODE },\n\t{ AD7768_MCLK_DIV_2, AD7768_DEC_RATE_128, 256, AD7768_FAST_MODE },\n\t{ AD7768_MCLK_DIV_4, AD7768_DEC_RATE_128, 512, AD7768_MED_MODE },\n\t{ AD7768_MCLK_DIV_4, AD7768_DEC_RATE_256, 1024, AD7768_MED_MODE },\n\t{ AD7768_MCLK_DIV_4, AD7768_DEC_RATE_512, 2048, AD7768_MED_MODE },\n\t{ AD7768_MCLK_DIV_4, AD7768_DEC_RATE_1024, 4096, AD7768_MED_MODE },\n\t{ AD7768_MCLK_DIV_8, AD7768_DEC_RATE_1024, 8192, AD7768_MED_MODE },\n\t{ AD7768_MCLK_DIV_16, AD7768_DEC_RATE_1024, 16384, AD7768_ECO_MODE },\n};\n\nstatic const struct iio_chan_spec ad7768_channels[] = {\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 24,\n\t\t\t.storagebits = 32,\n\t\t\t.shift = 8,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n};\n\nstruct ad7768_state {\n\tstruct spi_device *spi;\n\tstruct regulator *vref;\n\tstruct mutex lock;\n\tstruct clk *mclk;\n\tunsigned int mclk_freq;\n\tunsigned int samp_freq;\n\tstruct completion completion;\n\tstruct iio_trigger *trig;\n\tstruct gpio_desc *gpio_sync_in;\n\tconst char *labels[ARRAY_SIZE(ad7768_channels)];\n\t \n\tunion {\n\t\tstruct {\n\t\t\t__be32 chan;\n\t\t\ts64 timestamp;\n\t\t} scan;\n\t\t__be32 d32;\n\t\tu8 d8[2];\n\t} data __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic int ad7768_spi_reg_read(struct ad7768_state *st, unsigned int addr,\n\t\t\t       unsigned int len)\n{\n\tunsigned int shift;\n\tint ret;\n\n\tshift = 32 - (8 * len);\n\tst->data.d8[0] = AD7768_RD_FLAG_MSK(addr);\n\n\tret = spi_write_then_read(st->spi, st->data.d8, 1,\n\t\t\t\t  &st->data.d32, len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (be32_to_cpu(st->data.d32) >> shift);\n}\n\nstatic int ad7768_spi_reg_write(struct ad7768_state *st,\n\t\t\t\tunsigned int addr,\n\t\t\t\tunsigned int val)\n{\n\tst->data.d8[0] = AD7768_WR_FLAG_MSK(addr);\n\tst->data.d8[1] = val & 0xFF;\n\n\treturn spi_write(st->spi, st->data.d8, 2);\n}\n\nstatic int ad7768_set_mode(struct ad7768_state *st,\n\t\t\t   enum ad7768_conv_mode mode)\n{\n\tint regval;\n\n\tregval = ad7768_spi_reg_read(st, AD7768_REG_CONVERSION, 1);\n\tif (regval < 0)\n\t\treturn regval;\n\n\tregval &= ~AD7768_CONV_MODE_MSK;\n\tregval |= AD7768_CONV_MODE(mode);\n\n\treturn ad7768_spi_reg_write(st, AD7768_REG_CONVERSION, regval);\n}\n\nstatic int ad7768_scan_direct(struct iio_dev *indio_dev)\n{\n\tstruct ad7768_state *st = iio_priv(indio_dev);\n\tint readval, ret;\n\n\treinit_completion(&st->completion);\n\n\tret = ad7768_set_mode(st, AD7768_ONE_SHOT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wait_for_completion_timeout(&st->completion,\n\t\t\t\t\t  msecs_to_jiffies(1000));\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\treadval = ad7768_spi_reg_read(st, AD7768_REG_ADC_DATA, 3);\n\tif (readval < 0)\n\t\treturn readval;\n\t \n\tret = ad7768_set_mode(st, AD7768_CONTINUOUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn readval;\n}\n\nstatic int ad7768_reg_access(struct iio_dev *indio_dev,\n\t\t\t     unsigned int reg,\n\t\t\t     unsigned int writeval,\n\t\t\t     unsigned int *readval)\n{\n\tstruct ad7768_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tif (readval) {\n\t\tret = ad7768_spi_reg_read(st, reg, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err_unlock;\n\t\t*readval = ret;\n\t\tret = 0;\n\t} else {\n\t\tret = ad7768_spi_reg_write(st, reg, writeval);\n\t}\nerr_unlock:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad7768_set_dig_fil(struct ad7768_state *st,\n\t\t\t      enum ad7768_dec_rate dec_rate)\n{\n\tunsigned int mode;\n\tint ret;\n\n\tif (dec_rate == AD7768_DEC_RATE_8 || dec_rate == AD7768_DEC_RATE_16)\n\t\tmode = AD7768_DIG_FIL_FIL(dec_rate);\n\telse\n\t\tmode = AD7768_DIG_FIL_DEC_RATE(dec_rate);\n\n\tret = ad7768_spi_reg_write(st, AD7768_REG_DIGITAL_FILTER, mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tgpiod_set_value(st->gpio_sync_in, 1);\n\tgpiod_set_value(st->gpio_sync_in, 0);\n\n\treturn 0;\n}\n\nstatic int ad7768_set_freq(struct ad7768_state *st,\n\t\t\t   unsigned int freq)\n{\n\tunsigned int diff_new, diff_old, pwr_mode, i, idx;\n\tint res, ret;\n\n\tdiff_old = U32_MAX;\n\tidx = 0;\n\n\tres = DIV_ROUND_CLOSEST(st->mclk_freq, freq);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ad7768_clk_config); i++) {\n\t\tdiff_new = abs(res - ad7768_clk_config[i].clk_div);\n\t\tif (diff_new < diff_old) {\n\t\t\tdiff_old = diff_new;\n\t\t\tidx = i;\n\t\t}\n\t}\n\n\t \n\tpwr_mode = AD7768_PWR_MCLK_DIV(ad7768_clk_config[idx].mclk_div) |\n\t\t   AD7768_PWR_PWRMODE(ad7768_clk_config[idx].pwrmode);\n\tret = ad7768_spi_reg_write(st, AD7768_REG_POWER_CLOCK, pwr_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret =  ad7768_set_dig_fil(st, ad7768_clk_config[idx].dec_rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->samp_freq = DIV_ROUND_CLOSEST(st->mclk_freq,\n\t\t\t\t\t  ad7768_clk_config[idx].clk_div);\n\n\treturn 0;\n}\n\nstatic ssize_t ad7768_sampling_freq_avail(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad7768_state *st = iio_priv(indio_dev);\n\tunsigned int freq;\n\tint i, len = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(ad7768_clk_config); i++) {\n\t\tfreq = DIV_ROUND_CLOSEST(st->mclk_freq,\n\t\t\t\t\t ad7768_clk_config[i].clk_div);\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d \", freq);\n\t}\n\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic IIO_DEV_ATTR_SAMP_FREQ_AVAIL(ad7768_sampling_freq_avail);\n\nstatic int ad7768_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long info)\n{\n\tstruct ad7768_state *st = iio_priv(indio_dev);\n\tint scale_uv, ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ad7768_scan_direct(indio_dev);\n\t\tif (ret >= 0)\n\t\t\t*val = ret;\n\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tscale_uv = regulator_get_voltage(st->vref);\n\t\tif (scale_uv < 0)\n\t\t\treturn scale_uv;\n\n\t\t*val = (scale_uv * 2) / 1000;\n\t\t*val2 = chan->scan_type.realbits;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = st->samp_freq;\n\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ad7768_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long info)\n{\n\tstruct ad7768_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn ad7768_set_freq(st, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad7768_read_label(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, char *label)\n{\n\tstruct ad7768_state *st = iio_priv(indio_dev);\n\n\treturn sprintf(label, \"%s\\n\", st->labels[chan->channel]);\n}\n\nstatic struct attribute *ad7768_attributes[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ad7768_group = {\n\t.attrs = ad7768_attributes,\n};\n\nstatic const struct iio_info ad7768_info = {\n\t.attrs = &ad7768_group,\n\t.read_raw = &ad7768_read_raw,\n\t.write_raw = &ad7768_write_raw,\n\t.read_label = ad7768_read_label,\n\t.debugfs_reg_access = &ad7768_reg_access,\n};\n\nstatic int ad7768_setup(struct ad7768_state *st)\n{\n\tint ret;\n\n\t \n\tret = ad7768_spi_reg_write(st, AD7768_REG_SYNC_RESET, 0x3);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad7768_spi_reg_write(st, AD7768_REG_SYNC_RESET, 0x2);\n\tif (ret)\n\t\treturn ret;\n\n\tst->gpio_sync_in = devm_gpiod_get(&st->spi->dev, \"adi,sync-in\",\n\t\t\t\t\t  GPIOD_OUT_LOW);\n\tif (IS_ERR(st->gpio_sync_in))\n\t\treturn PTR_ERR(st->gpio_sync_in);\n\n\t \n\treturn ad7768_set_freq(st, 32000);\n}\n\nstatic irqreturn_t ad7768_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ad7768_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = spi_read(st->spi, &st->data.scan.chan, 3);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &st->data.scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\nerr_unlock:\n\tiio_trigger_notify_done(indio_dev->trig);\n\tmutex_unlock(&st->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ad7768_interrupt(int irq, void *dev_id)\n{\n\tstruct iio_dev *indio_dev = dev_id;\n\tstruct ad7768_state *st = iio_priv(indio_dev);\n\n\tif (iio_buffer_enabled(indio_dev))\n\t\tiio_trigger_poll(st->trig);\n\telse\n\t\tcomplete(&st->completion);\n\n\treturn IRQ_HANDLED;\n};\n\nstatic int ad7768_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct ad7768_state *st = iio_priv(indio_dev);\n\n\t \n\treturn ad7768_spi_reg_write(st, AD7768_REG_INTERFACE_FORMAT, 0x01);\n}\n\nstatic int ad7768_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct ad7768_state *st = iio_priv(indio_dev);\n\n\t \n\treturn ad7768_spi_reg_read(st, AD7768_REG_ADC_DATA, 3);\n}\n\nstatic const struct iio_buffer_setup_ops ad7768_buffer_ops = {\n\t.postenable = &ad7768_buffer_postenable,\n\t.predisable = &ad7768_buffer_predisable,\n};\n\nstatic const struct iio_trigger_ops ad7768_trigger_ops = {\n\t.validate_device = iio_trigger_validate_own_device,\n};\n\nstatic void ad7768_regulator_disable(void *data)\n{\n\tstruct ad7768_state *st = data;\n\n\tregulator_disable(st->vref);\n}\n\nstatic int ad7768_set_channel_label(struct iio_dev *indio_dev,\n\t\t\t\t\t\tint num_channels)\n{\n\tstruct ad7768_state *st = iio_priv(indio_dev);\n\tstruct device *device = indio_dev->dev.parent;\n\tstruct fwnode_handle *fwnode;\n\tstruct fwnode_handle *child;\n\tconst char *label;\n\tint crt_ch = 0;\n\n\tfwnode = dev_fwnode(device);\n\tfwnode_for_each_child_node(fwnode, child) {\n\t\tif (fwnode_property_read_u32(child, \"reg\", &crt_ch))\n\t\t\tcontinue;\n\n\t\tif (crt_ch >= num_channels)\n\t\t\tcontinue;\n\n\t\tif (fwnode_property_read_string(child, \"label\", &label))\n\t\t\tcontinue;\n\n\t\tst->labels[crt_ch] = label;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad7768_probe(struct spi_device *spi)\n{\n\tstruct ad7768_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tst->spi = spi;\n\n\tst->vref = devm_regulator_get(&spi->dev, \"vref\");\n\tif (IS_ERR(st->vref))\n\t\treturn PTR_ERR(st->vref);\n\n\tret = regulator_enable(st->vref);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to enable specified vref supply\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&spi->dev, ad7768_regulator_disable, st);\n\tif (ret)\n\t\treturn ret;\n\n\tst->mclk = devm_clk_get_enabled(&spi->dev, \"mclk\");\n\tif (IS_ERR(st->mclk))\n\t\treturn PTR_ERR(st->mclk);\n\n\tst->mclk_freq = clk_get_rate(st->mclk);\n\n\tmutex_init(&st->lock);\n\n\tindio_dev->channels = ad7768_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ad7768_channels);\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->info = &ad7768_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = ad7768_setup(st);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"AD7768 setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tst->trig = devm_iio_trigger_alloc(&spi->dev, \"%s-dev%d\",\n\t\t\t\t\t  indio_dev->name,\n\t\t\t\t\t  iio_device_id(indio_dev));\n\tif (!st->trig)\n\t\treturn -ENOMEM;\n\n\tst->trig->ops = &ad7768_trigger_ops;\n\tiio_trigger_set_drvdata(st->trig, indio_dev);\n\tret = devm_iio_trigger_register(&spi->dev, st->trig);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->trig = iio_trigger_get(st->trig);\n\n\tinit_completion(&st->completion);\n\n\tret = ad7768_set_channel_label(indio_dev, ARRAY_SIZE(ad7768_channels));\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_irq(&spi->dev, spi->irq,\n\t\t\t       &ad7768_interrupt,\n\t\t\t       IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t       indio_dev->name, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev,\n\t\t\t\t\t      &iio_pollfunc_store_time,\n\t\t\t\t\t      &ad7768_trigger_handler,\n\t\t\t\t\t      &ad7768_buffer_ops);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad7768_id_table[] = {\n\t{ \"ad7768-1\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad7768_id_table);\n\nstatic const struct of_device_id ad7768_of_match[] = {\n\t{ .compatible = \"adi,ad7768-1\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ad7768_of_match);\n\nstatic struct spi_driver ad7768_driver = {\n\t.driver = {\n\t\t.name = \"ad7768-1\",\n\t\t.of_match_table = ad7768_of_match,\n\t},\n\t.probe = ad7768_probe,\n\t.id_table = ad7768_id_table,\n};\nmodule_spi_driver(ad7768_driver);\n\nMODULE_AUTHOR(\"Stefan Popa <stefan.popa@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7768-1 ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}