{
  "module_name": "ti-adc0832.c",
  "hash_id": "a1803c907badfb38f15d68e26cb44a4c8b36743846fad6d57d513d3165b423d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-adc0832.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/spi/spi.h>\n#include <linux/iio/iio.h>\n#include <linux/regulator/consumer.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\nenum {\n\tadc0831,\n\tadc0832,\n\tadc0834,\n\tadc0838,\n};\n\nstruct adc0832 {\n\tstruct spi_device *spi;\n\tstruct regulator *reg;\n\tstruct mutex lock;\n\tu8 mux_bits;\n\t \n\tu8 data[24] __aligned(8);\n\n\tu8 tx_buf[2] __aligned(IIO_DMA_MINALIGN);\n\tu8 rx_buf[2];\n};\n\n#define ADC0832_VOLTAGE_CHANNEL(chan)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.channel = chan,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t\t.scan_index = chan,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t\t.realbits = 8,\t\t\t\t\t\\\n\t\t\t.storagebits = 8,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\n#define ADC0832_VOLTAGE_CHANNEL_DIFF(chan1, chan2, si)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.channel = (chan1),\t\t\t\t\t\\\n\t\t.channel2 = (chan2),\t\t\t\t\t\\\n\t\t.differential = 1,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t\t.scan_index = si,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t\t.realbits = 8,\t\t\t\t\t\\\n\t\t\t.storagebits = 8,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec adc0831_channels[] = {\n\tADC0832_VOLTAGE_CHANNEL_DIFF(0, 1, 0),\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n};\n\nstatic const struct iio_chan_spec adc0832_channels[] = {\n\tADC0832_VOLTAGE_CHANNEL(0),\n\tADC0832_VOLTAGE_CHANNEL(1),\n\tADC0832_VOLTAGE_CHANNEL_DIFF(0, 1, 2),\n\tADC0832_VOLTAGE_CHANNEL_DIFF(1, 0, 3),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic const struct iio_chan_spec adc0834_channels[] = {\n\tADC0832_VOLTAGE_CHANNEL(0),\n\tADC0832_VOLTAGE_CHANNEL(1),\n\tADC0832_VOLTAGE_CHANNEL(2),\n\tADC0832_VOLTAGE_CHANNEL(3),\n\tADC0832_VOLTAGE_CHANNEL_DIFF(0, 1, 4),\n\tADC0832_VOLTAGE_CHANNEL_DIFF(1, 0, 5),\n\tADC0832_VOLTAGE_CHANNEL_DIFF(2, 3, 6),\n\tADC0832_VOLTAGE_CHANNEL_DIFF(3, 2, 7),\n\tIIO_CHAN_SOFT_TIMESTAMP(8),\n};\n\nstatic const struct iio_chan_spec adc0838_channels[] = {\n\tADC0832_VOLTAGE_CHANNEL(0),\n\tADC0832_VOLTAGE_CHANNEL(1),\n\tADC0832_VOLTAGE_CHANNEL(2),\n\tADC0832_VOLTAGE_CHANNEL(3),\n\tADC0832_VOLTAGE_CHANNEL(4),\n\tADC0832_VOLTAGE_CHANNEL(5),\n\tADC0832_VOLTAGE_CHANNEL(6),\n\tADC0832_VOLTAGE_CHANNEL(7),\n\tADC0832_VOLTAGE_CHANNEL_DIFF(0, 1, 8),\n\tADC0832_VOLTAGE_CHANNEL_DIFF(1, 0, 9),\n\tADC0832_VOLTAGE_CHANNEL_DIFF(2, 3, 10),\n\tADC0832_VOLTAGE_CHANNEL_DIFF(3, 2, 11),\n\tADC0832_VOLTAGE_CHANNEL_DIFF(4, 5, 12),\n\tADC0832_VOLTAGE_CHANNEL_DIFF(5, 4, 13),\n\tADC0832_VOLTAGE_CHANNEL_DIFF(6, 7, 14),\n\tADC0832_VOLTAGE_CHANNEL_DIFF(7, 6, 15),\n\tIIO_CHAN_SOFT_TIMESTAMP(16),\n};\n\nstatic int adc0831_adc_conversion(struct adc0832 *adc)\n{\n\tstruct spi_device *spi = adc->spi;\n\tint ret;\n\n\tret = spi_read(spi, &adc->rx_buf, 2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn (adc->rx_buf[0] << 2 & 0xff) | (adc->rx_buf[1] >> 6);\n}\n\nstatic int adc0832_adc_conversion(struct adc0832 *adc, int channel,\n\t\t\t\tbool differential)\n{\n\tstruct spi_device *spi = adc->spi;\n\tstruct spi_transfer xfer = {\n\t\t.tx_buf = adc->tx_buf,\n\t\t.rx_buf = adc->rx_buf,\n\t\t.len = 2,\n\t};\n\tint ret;\n\n\tif (!adc->mux_bits)\n\t\treturn adc0831_adc_conversion(adc);\n\n\t \n\tadc->tx_buf[0] = 1 << (adc->mux_bits + 1);\n\t \n\tadc->tx_buf[0] |= differential ? 0 : (1 << adc->mux_bits);\n\t \n\tadc->tx_buf[0] |= (channel % 2) << (adc->mux_bits - 1);\n\t \n\tif (adc->mux_bits > 1)\n\t\tadc->tx_buf[0] |= channel / 2;\n\n\t \n\tadc->tx_buf[0] <<= 1;\n\n\tret = spi_sync_transfer(spi, &xfer, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn adc->rx_buf[1];\n}\n\nstatic int adc0832_read_raw(struct iio_dev *iio,\n\t\t\tstruct iio_chan_spec const *channel, int *value,\n\t\t\tint *shift, long mask)\n{\n\tstruct adc0832 *adc = iio_priv(iio);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&adc->lock);\n\t\t*value = adc0832_adc_conversion(adc, channel->channel,\n\t\t\t\t\t\tchannel->differential);\n\t\tmutex_unlock(&adc->lock);\n\t\tif (*value < 0)\n\t\t\treturn *value;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*value = regulator_get_voltage(adc->reg);\n\t\tif (*value < 0)\n\t\t\treturn *value;\n\n\t\t \n\t\t*value /= 1000;\n\t\t*shift = 8;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info adc0832_info = {\n\t.read_raw = adc0832_read_raw,\n};\n\nstatic irqreturn_t adc0832_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct adc0832 *adc = iio_priv(indio_dev);\n\tint scan_index;\n\tint i = 0;\n\n\tmutex_lock(&adc->lock);\n\n\tfor_each_set_bit(scan_index, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\tconst struct iio_chan_spec *scan_chan =\n\t\t\t\t&indio_dev->channels[scan_index];\n\t\tint ret = adc0832_adc_conversion(adc, scan_chan->channel,\n\t\t\t\t\t\t scan_chan->differential);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&adc->spi->dev,\n\t\t\t\t \"failed to get conversion data\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tadc->data[i] = ret;\n\t\ti++;\n\t}\n\tiio_push_to_buffers_with_timestamp(indio_dev, adc->data,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\nout:\n\tmutex_unlock(&adc->lock);\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void adc0832_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int adc0832_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct adc0832 *adc;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\tadc->spi = spi;\n\tmutex_init(&adc->lock);\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->info = &adc0832_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tswitch (spi_get_device_id(spi)->driver_data) {\n\tcase adc0831:\n\t\tadc->mux_bits = 0;\n\t\tindio_dev->channels = adc0831_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(adc0831_channels);\n\t\tbreak;\n\tcase adc0832:\n\t\tadc->mux_bits = 1;\n\t\tindio_dev->channels = adc0832_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(adc0832_channels);\n\t\tbreak;\n\tcase adc0834:\n\t\tadc->mux_bits = 2;\n\t\tindio_dev->channels = adc0834_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(adc0834_channels);\n\t\tbreak;\n\tcase adc0838:\n\t\tadc->mux_bits = 3;\n\t\tindio_dev->channels = adc0838_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(adc0838_channels);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tadc->reg = devm_regulator_get(&spi->dev, \"vref\");\n\tif (IS_ERR(adc->reg))\n\t\treturn PTR_ERR(adc->reg);\n\n\tret = regulator_enable(adc->reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, adc0832_reg_disable,\n\t\t\t\t       adc->reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev, NULL,\n\t\t\t\t\t      adc0832_trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id adc0832_dt_ids[] = {\n\t{ .compatible = \"ti,adc0831\", },\n\t{ .compatible = \"ti,adc0832\", },\n\t{ .compatible = \"ti,adc0834\", },\n\t{ .compatible = \"ti,adc0838\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, adc0832_dt_ids);\n\nstatic const struct spi_device_id adc0832_id[] = {\n\t{ \"adc0831\", adc0831 },\n\t{ \"adc0832\", adc0832 },\n\t{ \"adc0834\", adc0834 },\n\t{ \"adc0838\", adc0838 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, adc0832_id);\n\nstatic struct spi_driver adc0832_driver = {\n\t.driver = {\n\t\t.name = \"adc0832\",\n\t\t.of_match_table = adc0832_dt_ids,\n\t},\n\t.probe = adc0832_probe,\n\t.id_table = adc0832_id,\n};\nmodule_spi_driver(adc0832_driver);\n\nMODULE_AUTHOR(\"Akinobu Mita <akinobu.mita@gmail.com>\");\nMODULE_DESCRIPTION(\"ADC0831/ADC0832/ADC0834/ADC0838 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}