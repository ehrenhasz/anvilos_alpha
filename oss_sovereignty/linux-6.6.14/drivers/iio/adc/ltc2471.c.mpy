{
  "module_name": "ltc2471.c",
  "hash_id": "973b833ccaf5dec92bffb2512429b7f3aabd7c234a0e1eb9edb7684ba9bf696c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ltc2471.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\nenum ltc2471_chips {\n\tltc2471,\n\tltc2473,\n};\n\nstruct ltc2471_data {\n\tstruct i2c_client *client;\n};\n\n \n#define LTC2471_VREF 1250\n\n \nstatic int ltc2471_get_value(struct i2c_client *client)\n{\n\tint ret;\n\t__be16 buf;\n\n\tret = i2c_master_recv(client, (char *)&buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(buf))\n\t\treturn -EIO;\n\n\t \n\treturn be16_to_cpu(buf);\n}\n\nstatic int ltc2471_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long info)\n{\n\tstruct ltc2471_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = ltc2471_get_value(data->client);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->differential)\n\t\t\t \n\t\t\t*val = 2 * LTC2471_VREF;\n\t\telse\n\t\t\t \n\t\t\t*val = LTC2471_VREF;\n\t\t*val2 = 16;\t \n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\t*val = -LTC2471_VREF;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_chan_spec ltc2471_channel[] = {\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t},\n};\n\nstatic const struct iio_chan_spec ltc2473_channel[] = {\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t\t    BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.differential = 1,\n\t},\n};\n\nstatic const struct iio_info ltc2471_info = {\n\t.read_raw = ltc2471_read_raw,\n};\n\nstatic int ltc2471_i2c_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct iio_dev *indio_dev;\n\tstruct ltc2471_data *data;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -EOPNOTSUPP;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\n\tindio_dev->name = id->name;\n\tindio_dev->info = &ltc2471_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tif (id->driver_data == ltc2473)\n\t\tindio_dev->channels = ltc2473_channel;\n\telse\n\t\tindio_dev->channels = ltc2471_channel;\n\tindio_dev->num_channels = 1;\n\n\t \n\tret = ltc2471_get_value(client);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Cannot read from device.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id ltc2471_i2c_id[] = {\n\t{ \"ltc2471\", ltc2471 },\n\t{ \"ltc2473\", ltc2473 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ltc2471_i2c_id);\n\nstatic struct i2c_driver ltc2471_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ltc2471\",\n\t},\n\t.probe = ltc2471_i2c_probe,\n\t.id_table = ltc2471_i2c_id,\n};\n\nmodule_i2c_driver(ltc2471_i2c_driver);\n\nMODULE_DESCRIPTION(\"LTC2471/LTC2473 ADC driver\");\nMODULE_AUTHOR(\"Topic Embedded Products\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}