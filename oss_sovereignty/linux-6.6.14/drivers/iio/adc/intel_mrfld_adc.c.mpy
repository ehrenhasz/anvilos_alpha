{
  "module_name": "intel_mrfld_adc.c",
  "hash_id": "46115a0c2df4c5220accc7de152118c0cd3a4a9cf265fd80168949cd047bfa25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/intel_mrfld_adc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/mfd/intel_soc_pmic_mrfld.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <linux/iio/driver.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/machine.h>\n\n#include <asm/unaligned.h>\n\n#define BCOVE_GPADCREQ\t\t\t0xDC\n#define BCOVE_GPADCREQ_BUSY\t\tBIT(0)\n#define BCOVE_GPADCREQ_IRQEN\t\tBIT(1)\n\n#define BCOVE_ADCIRQ_ALL (\t\t\\\n\tBCOVE_ADCIRQ_BATTEMP |\t\t\\\n\tBCOVE_ADCIRQ_SYSTEMP |\t\t\\\n\tBCOVE_ADCIRQ_BATTID |\t\t\\\n\tBCOVE_ADCIRQ_VIBATT |\t\t\\\n\tBCOVE_ADCIRQ_CCTICK)\n\n#define BCOVE_ADC_TIMEOUT\t\tmsecs_to_jiffies(1000)\n\nstatic const u8 mrfld_adc_requests[] = {\n\tBCOVE_ADCIRQ_VIBATT,\n\tBCOVE_ADCIRQ_BATTID,\n\tBCOVE_ADCIRQ_VIBATT,\n\tBCOVE_ADCIRQ_SYSTEMP,\n\tBCOVE_ADCIRQ_BATTEMP,\n\tBCOVE_ADCIRQ_BATTEMP,\n\tBCOVE_ADCIRQ_SYSTEMP,\n\tBCOVE_ADCIRQ_SYSTEMP,\n\tBCOVE_ADCIRQ_SYSTEMP,\n};\n\nstruct mrfld_adc {\n\tstruct regmap *regmap;\n\tstruct completion completion;\n\t \n\tstruct mutex lock;\n};\n\nstatic irqreturn_t mrfld_adc_thread_isr(int irq, void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct mrfld_adc *adc = iio_priv(indio_dev);\n\n\tcomplete(&adc->completion);\n\treturn IRQ_HANDLED;\n}\n\nstatic int mrfld_adc_single_conv(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int *result)\n{\n\tstruct mrfld_adc *adc = iio_priv(indio_dev);\n\tstruct regmap *regmap = adc->regmap;\n\tunsigned int req;\n\tlong timeout;\n\t__be16 value;\n\tint ret;\n\n\treinit_completion(&adc->completion);\n\n\tregmap_update_bits(regmap, BCOVE_MADCIRQ, BCOVE_ADCIRQ_ALL, 0);\n\tregmap_update_bits(regmap, BCOVE_MIRQLVL1, BCOVE_LVL1_ADC, 0);\n\n\tret = regmap_read_poll_timeout(regmap, BCOVE_GPADCREQ, req,\n\t\t\t\t       !(req & BCOVE_GPADCREQ_BUSY),\n\t\t\t\t       2000, 1000000);\n\tif (ret)\n\t\tgoto done;\n\n\treq = mrfld_adc_requests[chan->channel];\n\tret = regmap_write(regmap, BCOVE_GPADCREQ, BCOVE_GPADCREQ_IRQEN | req);\n\tif (ret)\n\t\tgoto done;\n\n\ttimeout = wait_for_completion_interruptible_timeout(&adc->completion,\n\t\t\t\t\t\t\t    BCOVE_ADC_TIMEOUT);\n\tif (timeout < 0) {\n\t\tret = timeout;\n\t\tgoto done;\n\t}\n\tif (timeout == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto done;\n\t}\n\n\tret = regmap_bulk_read(regmap, chan->address, &value, sizeof(value));\n\tif (ret)\n\t\tgoto done;\n\n\t*result = be16_to_cpu(value);\n\tret = IIO_VAL_INT;\n\ndone:\n\tregmap_update_bits(regmap, BCOVE_MIRQLVL1, BCOVE_LVL1_ADC, 0xff);\n\tregmap_update_bits(regmap, BCOVE_MADCIRQ, BCOVE_ADCIRQ_ALL, 0xff);\n\n\treturn ret;\n}\n\nstatic int mrfld_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int *val, int *val2, long mask)\n{\n\tstruct mrfld_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&adc->lock);\n\t\tret = mrfld_adc_single_conv(indio_dev, chan, val);\n\t\tmutex_unlock(&adc->lock);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info mrfld_adc_iio_info = {\n\t.read_raw = &mrfld_adc_read_raw,\n};\n\n#define BCOVE_ADC_CHANNEL(_type, _channel, _datasheet_name, _address)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.type = _type,\t\t\t\t\t\t\\\n\t\t.channel = _channel,\t\t\t\t\t\\\n\t\t.address = _address,\t\t\t\t\t\\\n\t\t.datasheet_name = _datasheet_name,\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t}\n\nstatic const struct iio_chan_spec mrfld_adc_channels[] = {\n\tBCOVE_ADC_CHANNEL(IIO_VOLTAGE,    0, \"CH0\", 0xE9),\n\tBCOVE_ADC_CHANNEL(IIO_RESISTANCE, 1, \"CH1\", 0xEB),\n\tBCOVE_ADC_CHANNEL(IIO_CURRENT,    2, \"CH2\", 0xED),\n\tBCOVE_ADC_CHANNEL(IIO_TEMP,       3, \"CH3\", 0xCC),\n\tBCOVE_ADC_CHANNEL(IIO_TEMP,       4, \"CH4\", 0xC8),\n\tBCOVE_ADC_CHANNEL(IIO_TEMP,       5, \"CH5\", 0xCA),\n\tBCOVE_ADC_CHANNEL(IIO_TEMP,       6, \"CH6\", 0xC2),\n\tBCOVE_ADC_CHANNEL(IIO_TEMP,       7, \"CH7\", 0xC4),\n\tBCOVE_ADC_CHANNEL(IIO_TEMP,       8, \"CH8\", 0xC6),\n};\n\nstatic struct iio_map iio_maps[] = {\n\tIIO_MAP(\"CH0\", \"bcove-battery\", \"VBATRSLT\"),\n\tIIO_MAP(\"CH1\", \"bcove-battery\", \"BATTID\"),\n\tIIO_MAP(\"CH2\", \"bcove-battery\", \"IBATRSLT\"),\n\tIIO_MAP(\"CH3\", \"bcove-temp\",    \"PMICTEMP\"),\n\tIIO_MAP(\"CH4\", \"bcove-temp\",    \"BATTEMP0\"),\n\tIIO_MAP(\"CH5\", \"bcove-temp\",    \"BATTEMP1\"),\n\tIIO_MAP(\"CH6\", \"bcove-temp\",    \"SYSTEMP0\"),\n\tIIO_MAP(\"CH7\", \"bcove-temp\",    \"SYSTEMP1\"),\n\tIIO_MAP(\"CH8\", \"bcove-temp\",    \"SYSTEMP2\"),\n\t{}\n};\n\nstatic int mrfld_adc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(dev->parent);\n\tstruct iio_dev *indio_dev;\n\tstruct mrfld_adc *adc;\n\tint irq;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(struct mrfld_adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\n\tmutex_init(&adc->lock);\n\tinit_completion(&adc->completion);\n\tadc->regmap = pmic->regmap;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(dev, irq, NULL, mrfld_adc_thread_isr,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED, pdev->name,\n\t\t\t\t\tindio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->name = pdev->name;\n\n\tindio_dev->channels = mrfld_adc_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mrfld_adc_channels);\n\tindio_dev->info = &mrfld_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = devm_iio_map_array_register(dev, indio_dev, iio_maps);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct platform_device_id mrfld_adc_id_table[] = {\n\t{ .name = \"mrfld_bcove_adc\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(platform, mrfld_adc_id_table);\n\nstatic struct platform_driver mrfld_adc_driver = {\n\t.driver = {\n\t\t.name = \"mrfld_bcove_adc\",\n\t},\n\t.probe = mrfld_adc_probe,\n\t.id_table = mrfld_adc_id_table,\n};\nmodule_platform_driver(mrfld_adc_driver);\n\nMODULE_AUTHOR(\"Bin Yang <bin.yang@intel.com>\");\nMODULE_AUTHOR(\"Vincent Pelletier <plr.vincent@gmail.com>\");\nMODULE_AUTHOR(\"Andy Shevchenko <andriy.shevchenko@linux.intel.com>\");\nMODULE_DESCRIPTION(\"ADC driver for Basin Cove PMIC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}