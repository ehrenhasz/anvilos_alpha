{
  "module_name": "ti-ads8688.c",
  "hash_id": "bf7e81c21fe942e70b7cd98d979ca0a5ad6cdc5b1d0cf38402aad5c4fe34e713",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-ads8688.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/sysfs.h>\n\n#define ADS8688_CMD_REG(x)\t\t(x << 8)\n#define ADS8688_CMD_REG_NOOP\t\t0x00\n#define ADS8688_CMD_REG_RST\t\t0x85\n#define ADS8688_CMD_REG_MAN_CH(chan)\t(0xC0 | (4 * chan))\n#define ADS8688_CMD_DONT_CARE_BITS\t16\n\n#define ADS8688_PROG_REG(x)\t\t(x << 9)\n#define ADS8688_PROG_REG_RANGE_CH(chan)\t(0x05 + chan)\n#define ADS8688_PROG_WR_BIT\t\tBIT(8)\n#define ADS8688_PROG_DONT_CARE_BITS\t8\n\n#define ADS8688_REG_PLUSMINUS25VREF\t0\n#define ADS8688_REG_PLUSMINUS125VREF\t1\n#define ADS8688_REG_PLUSMINUS0625VREF\t2\n#define ADS8688_REG_PLUS25VREF\t\t5\n#define ADS8688_REG_PLUS125VREF\t\t6\n\n#define ADS8688_VREF_MV\t\t\t4096\n#define ADS8688_REALBITS\t\t16\n#define ADS8688_MAX_CHANNELS\t\t8\n\n \nenum ads8688_range {\n\tADS8688_PLUSMINUS25VREF,\n\tADS8688_PLUSMINUS125VREF,\n\tADS8688_PLUSMINUS0625VREF,\n\tADS8688_PLUS25VREF,\n\tADS8688_PLUS125VREF,\n};\n\nstruct ads8688_chip_info {\n\tconst struct iio_chan_spec *channels;\n\tunsigned int num_channels;\n};\n\nstruct ads8688_state {\n\tstruct mutex\t\t\tlock;\n\tconst struct ads8688_chip_info\t*chip_info;\n\tstruct spi_device\t\t*spi;\n\tstruct regulator\t\t*reg;\n\tunsigned int\t\t\tvref_mv;\n\tenum ads8688_range\t\trange[8];\n\tunion {\n\t\t__be32 d32;\n\t\tu8 d8[4];\n\t} data[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nenum ads8688_id {\n\tID_ADS8684,\n\tID_ADS8688,\n};\n\nstruct ads8688_ranges {\n\tenum ads8688_range range;\n\tunsigned int scale;\n\tint offset;\n\tu8 reg;\n};\n\nstatic const struct ads8688_ranges ads8688_range_def[5] = {\n\t{\n\t\t.range = ADS8688_PLUSMINUS25VREF,\n\t\t.scale = 76295,\n\t\t.offset = -(1 << (ADS8688_REALBITS - 1)),\n\t\t.reg = ADS8688_REG_PLUSMINUS25VREF,\n\t}, {\n\t\t.range = ADS8688_PLUSMINUS125VREF,\n\t\t.scale = 38148,\n\t\t.offset = -(1 << (ADS8688_REALBITS - 1)),\n\t\t.reg = ADS8688_REG_PLUSMINUS125VREF,\n\t}, {\n\t\t.range = ADS8688_PLUSMINUS0625VREF,\n\t\t.scale = 19074,\n\t\t.offset = -(1 << (ADS8688_REALBITS - 1)),\n\t\t.reg = ADS8688_REG_PLUSMINUS0625VREF,\n\t}, {\n\t\t.range = ADS8688_PLUS25VREF,\n\t\t.scale = 38148,\n\t\t.offset = 0,\n\t\t.reg = ADS8688_REG_PLUS25VREF,\n\t}, {\n\t\t.range = ADS8688_PLUS125VREF,\n\t\t.scale = 19074,\n\t\t.offset = 0,\n\t\t.reg = ADS8688_REG_PLUS125VREF,\n\t}\n};\n\nstatic ssize_t ads8688_show_scales(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ads8688_state *st = iio_priv(dev_to_iio_dev(dev));\n\n\treturn sprintf(buf, \"0.%09u 0.%09u 0.%09u\\n\",\n\t\t       ads8688_range_def[0].scale * st->vref_mv,\n\t\t       ads8688_range_def[1].scale * st->vref_mv,\n\t\t       ads8688_range_def[2].scale * st->vref_mv);\n}\n\nstatic ssize_t ads8688_show_offsets(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d %d\\n\", ads8688_range_def[0].offset,\n\t\t       ads8688_range_def[3].offset);\n}\n\nstatic IIO_DEVICE_ATTR(in_voltage_scale_available, S_IRUGO,\n\t\t       ads8688_show_scales, NULL, 0);\nstatic IIO_DEVICE_ATTR(in_voltage_offset_available, S_IRUGO,\n\t\t       ads8688_show_offsets, NULL, 0);\n\nstatic struct attribute *ads8688_attributes[] = {\n\t&iio_dev_attr_in_voltage_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage_offset_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ads8688_attribute_group = {\n\t.attrs = ads8688_attributes,\n};\n\n#define ADS8688_CHAN(index)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = index,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)\t\t\\\n\t\t\t      | BIT(IIO_CHAN_INFO_SCALE)\t\\\n\t\t\t      | BIT(IIO_CHAN_INFO_OFFSET),\t\\\n\t.scan_index = index,\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec ads8684_channels[] = {\n\tADS8688_CHAN(0),\n\tADS8688_CHAN(1),\n\tADS8688_CHAN(2),\n\tADS8688_CHAN(3),\n};\n\nstatic const struct iio_chan_spec ads8688_channels[] = {\n\tADS8688_CHAN(0),\n\tADS8688_CHAN(1),\n\tADS8688_CHAN(2),\n\tADS8688_CHAN(3),\n\tADS8688_CHAN(4),\n\tADS8688_CHAN(5),\n\tADS8688_CHAN(6),\n\tADS8688_CHAN(7),\n};\n\nstatic int ads8688_prog_write(struct iio_dev *indio_dev, unsigned int addr,\n\t\t\t      unsigned int val)\n{\n\tstruct ads8688_state *st = iio_priv(indio_dev);\n\tu32 tmp;\n\n\ttmp = ADS8688_PROG_REG(addr) | ADS8688_PROG_WR_BIT | val;\n\ttmp <<= ADS8688_PROG_DONT_CARE_BITS;\n\tst->data[0].d32 = cpu_to_be32(tmp);\n\n\treturn spi_write(st->spi, &st->data[0].d8[1], 3);\n}\n\nstatic int ads8688_reset(struct iio_dev *indio_dev)\n{\n\tstruct ads8688_state *st = iio_priv(indio_dev);\n\tu32 tmp;\n\n\ttmp = ADS8688_CMD_REG(ADS8688_CMD_REG_RST);\n\ttmp <<= ADS8688_CMD_DONT_CARE_BITS;\n\tst->data[0].d32 = cpu_to_be32(tmp);\n\n\treturn spi_write(st->spi, &st->data[0].d8[0], 4);\n}\n\nstatic int ads8688_read(struct iio_dev *indio_dev, unsigned int chan)\n{\n\tstruct ads8688_state *st = iio_priv(indio_dev);\n\tint ret;\n\tu32 tmp;\n\tstruct spi_transfer t[] = {\n\t\t{\n\t\t\t.tx_buf = &st->data[0].d8[0],\n\t\t\t.len = 4,\n\t\t\t.cs_change = 1,\n\t\t}, {\n\t\t\t.tx_buf = &st->data[1].d8[0],\n\t\t\t.rx_buf = &st->data[1].d8[0],\n\t\t\t.len = 4,\n\t\t},\n\t};\n\n\ttmp = ADS8688_CMD_REG(ADS8688_CMD_REG_MAN_CH(chan));\n\ttmp <<= ADS8688_CMD_DONT_CARE_BITS;\n\tst->data[0].d32 = cpu_to_be32(tmp);\n\n\ttmp = ADS8688_CMD_REG(ADS8688_CMD_REG_NOOP);\n\ttmp <<= ADS8688_CMD_DONT_CARE_BITS;\n\tst->data[1].d32 = cpu_to_be32(tmp);\n\n\tret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn be32_to_cpu(st->data[1].d32) & 0xffff;\n}\n\nstatic int ads8688_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long m)\n{\n\tint ret, offset;\n\tunsigned long scale_mv;\n\n\tstruct ads8688_state *st = iio_priv(indio_dev);\n\n\tmutex_lock(&st->lock);\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = ads8688_read(indio_dev, chan->channel);\n\t\tmutex_unlock(&st->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tscale_mv = st->vref_mv;\n\t\tscale_mv *= ads8688_range_def[st->range[chan->channel]].scale;\n\t\t*val = 0;\n\t\t*val2 = scale_mv;\n\t\tmutex_unlock(&st->lock);\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\toffset = ads8688_range_def[st->range[chan->channel]].offset;\n\t\t*val = offset;\n\t\tmutex_unlock(&st->lock);\n\t\treturn IIO_VAL_INT;\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn -EINVAL;\n}\n\nstatic int ads8688_write_reg_range(struct iio_dev *indio_dev,\n\t\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t\t   enum ads8688_range range)\n{\n\tunsigned int tmp;\n\n\ttmp = ADS8688_PROG_REG_RANGE_CH(chan->channel);\n\n\treturn ads8688_prog_write(indio_dev, tmp, range);\n}\n\nstatic int ads8688_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct ads8688_state *st = iio_priv(indio_dev);\n\tunsigned int scale = 0;\n\tint ret = -EINVAL, i, offset = 0;\n\n\tmutex_lock(&st->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\toffset = ads8688_range_def[st->range[chan->channel]].offset;\n\t\tif (offset == 0 && val2 == ads8688_range_def[0].scale * st->vref_mv) {\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(ads8688_range_def); i++)\n\t\t\tif (val2 == ads8688_range_def[i].scale * st->vref_mv &&\n\t\t\t    offset == ads8688_range_def[i].offset) {\n\t\t\t\tret = ads8688_write_reg_range(indio_dev, chan,\n\t\t\t\t\tads8688_range_def[i].reg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\tif (!(ads8688_range_def[0].offset == val ||\n\t\t    ads8688_range_def[3].offset == val)) {\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (val == 0 &&\n\t\t    st->range[chan->channel] == ADS8688_PLUSMINUS25VREF) {\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tscale = ads8688_range_def[st->range[chan->channel]].scale;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(ads8688_range_def); i++)\n\t\t\tif (val == ads8688_range_def[i].offset &&\n\t\t\t    scale == ads8688_range_def[i].scale) {\n\t\t\t\tret = ads8688_write_reg_range(indio_dev, chan,\n\t\t\t\t\tads8688_range_def[i].reg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tst->range[chan->channel] = ads8688_range_def[i].range;\n\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ads8688_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t\t     long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info ads8688_info = {\n\t.read_raw = &ads8688_read_raw,\n\t.write_raw = &ads8688_write_raw,\n\t.write_raw_get_fmt = &ads8688_write_raw_get_fmt,\n\t.attrs = &ads8688_attribute_group,\n};\n\nstatic irqreturn_t ads8688_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\t \n\tu16 buffer[ADS8688_MAX_CHANNELS + sizeof(s64)/sizeof(u16)] __aligned(8);\n\tint i, j = 0;\n\n\tfor (i = 0; i < indio_dev->masklength; i++) {\n\t\tif (!test_bit(i, indio_dev->active_scan_mask))\n\t\t\tcontinue;\n\t\tbuffer[j] = ads8688_read(indio_dev, i);\n\t\tj++;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, buffer,\n\t\t\tiio_get_time_ns(indio_dev));\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct ads8688_chip_info ads8688_chip_info_tbl[] = {\n\t[ID_ADS8684] = {\n\t\t.channels = ads8684_channels,\n\t\t.num_channels = ARRAY_SIZE(ads8684_channels),\n\t},\n\t[ID_ADS8688] = {\n\t\t.channels = ads8688_channels,\n\t\t.num_channels = ARRAY_SIZE(ads8688_channels),\n\t},\n};\n\nstatic int ads8688_probe(struct spi_device *spi)\n{\n\tstruct ads8688_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->reg = devm_regulator_get_optional(&spi->dev, \"vref\");\n\tif (!IS_ERR(st->reg)) {\n\t\tret = regulator_enable(st->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regulator_get_voltage(st->reg);\n\t\tif (ret < 0)\n\t\t\tgoto err_regulator_disable;\n\n\t\tst->vref_mv = ret / 1000;\n\t} else {\n\t\t \n\t\tst->vref_mv = ADS8688_VREF_MV;\n\t}\n\n\tst->chip_info =\t&ads8688_chip_info_tbl[spi_get_device_id(spi)->driver_data];\n\n\tspi->mode = SPI_MODE_1;\n\n\tspi_set_drvdata(spi, indio_dev);\n\n\tst->spi = spi;\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = st->chip_info->channels;\n\tindio_dev->num_channels = st->chip_info->num_channels;\n\tindio_dev->info = &ads8688_info;\n\n\tads8688_reset(indio_dev);\n\n\tmutex_init(&st->lock);\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL, ads8688_trigger_handler, NULL);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"iio triggered buffer setup failed\\n\");\n\t\tgoto err_regulator_disable;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto err_buffer_cleanup;\n\n\treturn 0;\n\nerr_buffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\n\nerr_regulator_disable:\n\tif (!IS_ERR(st->reg))\n\t\tregulator_disable(st->reg);\n\n\treturn ret;\n}\n\nstatic void ads8688_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct ads8688_state *st = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\n\tif (!IS_ERR(st->reg))\n\t\tregulator_disable(st->reg);\n}\n\nstatic const struct spi_device_id ads8688_id[] = {\n\t{\"ads8684\", ID_ADS8684},\n\t{\"ads8688\", ID_ADS8688},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ads8688_id);\n\nstatic const struct of_device_id ads8688_of_match[] = {\n\t{ .compatible = \"ti,ads8684\" },\n\t{ .compatible = \"ti,ads8688\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ads8688_of_match);\n\nstatic struct spi_driver ads8688_driver = {\n\t.driver = {\n\t\t.name\t= \"ads8688\",\n\t\t.of_match_table = ads8688_of_match,\n\t},\n\t.probe\t\t= ads8688_probe,\n\t.remove\t\t= ads8688_remove,\n\t.id_table\t= ads8688_id,\n};\nmodule_spi_driver(ads8688_driver);\n\nMODULE_AUTHOR(\"Sean Nyekjaer <sean@geanix.dk>\");\nMODULE_DESCRIPTION(\"Texas Instruments ADS8688 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}