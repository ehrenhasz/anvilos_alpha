{
  "module_name": "berlin2-adc.c",
  "hash_id": "0ad6aa1783e94d2b22bb78ef0809c4640adc19b690c59df92798f43a2cd198ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/berlin2-adc.c",
  "human_readable_source": " \n\n#include <linux/iio/iio.h>\n#include <linux/iio/driver.h>\n#include <linux/iio/machine.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n\n#define BERLIN2_SM_CTRL\t\t\t\t0x14\n#define  BERLIN2_SM_CTRL_SM_SOC_INT\t\tBIT(1)\n#define  BERLIN2_SM_CTRL_SOC_SM_INT\t\tBIT(2)\n#define  BERLIN2_SM_CTRL_ADC_SEL(x)\t\t((x) << 5)\t \n#define  BERLIN2_SM_CTRL_ADC_SEL_MASK\t\tGENMASK(8, 5)\n#define  BERLIN2_SM_CTRL_ADC_POWER\t\tBIT(9)\n#define  BERLIN2_SM_CTRL_ADC_CLKSEL_DIV2\t(0x0 << 10)\n#define  BERLIN2_SM_CTRL_ADC_CLKSEL_DIV3\t(0x1 << 10)\n#define  BERLIN2_SM_CTRL_ADC_CLKSEL_DIV4\t(0x2 << 10)\n#define  BERLIN2_SM_CTRL_ADC_CLKSEL_DIV8\t(0x3 << 10)\n#define  BERLIN2_SM_CTRL_ADC_CLKSEL_MASK\tGENMASK(11, 10)\n#define  BERLIN2_SM_CTRL_ADC_START\t\tBIT(12)\n#define  BERLIN2_SM_CTRL_ADC_RESET\t\tBIT(13)\n#define  BERLIN2_SM_CTRL_ADC_BANDGAP_RDY\tBIT(14)\n#define  BERLIN2_SM_CTRL_ADC_CONT_SINGLE\t(0x0 << 15)\n#define  BERLIN2_SM_CTRL_ADC_CONT_CONTINUOUS\t(0x1 << 15)\n#define  BERLIN2_SM_CTRL_ADC_BUFFER_EN\t\tBIT(16)\n#define  BERLIN2_SM_CTRL_ADC_VREF_EXT\t\t(0x0 << 17)\n#define  BERLIN2_SM_CTRL_ADC_VREF_INT\t\t(0x1 << 17)\n#define  BERLIN2_SM_CTRL_ADC_ROTATE\t\tBIT(19)\n#define  BERLIN2_SM_CTRL_TSEN_EN\t\tBIT(20)\n#define  BERLIN2_SM_CTRL_TSEN_CLK_SEL_125\t(0x0 << 21)\t \n#define  BERLIN2_SM_CTRL_TSEN_CLK_SEL_250\t(0x1 << 21)\t \n#define  BERLIN2_SM_CTRL_TSEN_MODE_0_125\t(0x0 << 22)\t \n#define  BERLIN2_SM_CTRL_TSEN_MODE_10_50\t(0x1 << 22)\t \n#define  BERLIN2_SM_CTRL_TSEN_RESET\t\tBIT(29)\n#define BERLIN2_SM_ADC_DATA\t\t\t0x20\n#define  BERLIN2_SM_ADC_MASK\t\t\tGENMASK(9, 0)\n#define BERLIN2_SM_ADC_STATUS\t\t\t0x1c\n#define  BERLIN2_SM_ADC_STATUS_DATA_RDY(x)\tBIT(x)\t\t \n#define  BERLIN2_SM_ADC_STATUS_DATA_RDY_MASK\tGENMASK(15, 0)\n#define  BERLIN2_SM_ADC_STATUS_INT_EN(x)\t(BIT(x) << 16)\t \n#define  BERLIN2_SM_ADC_STATUS_INT_EN_MASK\tGENMASK(31, 16)\n#define BERLIN2_SM_TSEN_STATUS\t\t\t0x24\n#define  BERLIN2_SM_TSEN_STATUS_DATA_RDY\tBIT(0)\n#define  BERLIN2_SM_TSEN_STATUS_INT_EN\t\tBIT(1)\n#define BERLIN2_SM_TSEN_DATA\t\t\t0x28\n#define  BERLIN2_SM_TSEN_MASK\t\t\tGENMASK(9, 0)\n#define BERLIN2_SM_TSEN_CTRL\t\t\t0x74\n#define  BERLIN2_SM_TSEN_CTRL_START\t\tBIT(8)\n#define  BERLIN2_SM_TSEN_CTRL_SETTLING_4\t(0x0 << 21)\t \n#define  BERLIN2_SM_TSEN_CTRL_SETTLING_12\t(0x1 << 21)\t \n#define  BERLIN2_SM_TSEN_CTRL_SETTLING_MASK\tBIT(21)\n#define  BERLIN2_SM_TSEN_CTRL_TRIM(x)\t\t((x) << 22)\n#define  BERLIN2_SM_TSEN_CTRL_TRIM_MASK\t\tGENMASK(25, 22)\n\nstruct berlin2_adc_priv {\n\tstruct regmap\t\t*regmap;\n\tstruct mutex\t\tlock;\n\twait_queue_head_t\twq;\n\tbool\t\t\tdata_available;\n\tint\t\t\tdata;\n};\n\n#define BERLIN2_ADC_CHANNEL(n, t)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.channel\t\t= n,\t\t\t\t\\\n\t\t.datasheet_name\t\t= \"channel\"#n,\t\t\t\\\n\t\t.type\t\t\t= t,\t\t\t\t\\\n\t\t.indexed\t\t= 1,\t\t\t\t\\\n\t\t.info_mask_separate\t= BIT(IIO_CHAN_INFO_RAW),\t\\\n\t}\n\nstatic const struct iio_chan_spec berlin2_adc_channels[] = {\n\tBERLIN2_ADC_CHANNEL(0, IIO_VOLTAGE),\t \n\tBERLIN2_ADC_CHANNEL(1, IIO_VOLTAGE),\t \n\tBERLIN2_ADC_CHANNEL(2, IIO_VOLTAGE),\t \n\tBERLIN2_ADC_CHANNEL(3, IIO_VOLTAGE),\t \n\tBERLIN2_ADC_CHANNEL(4, IIO_VOLTAGE),\t \n\tBERLIN2_ADC_CHANNEL(5, IIO_VOLTAGE),\t \n\t{\t\t\t\t\t \n\t\t.channel\t\t= 6,\n\t\t.datasheet_name\t\t= \"channel6\",\n\t\t.type\t\t\t= IIO_TEMP,\n\t\t.indexed\t\t= 0,\n\t\t.info_mask_separate\t= BIT(IIO_CHAN_INFO_PROCESSED),\n\t},\n\tBERLIN2_ADC_CHANNEL(7, IIO_VOLTAGE),\t \n\tIIO_CHAN_SOFT_TIMESTAMP(8),\t\t \n};\n\nstatic int berlin2_adc_read(struct iio_dev *indio_dev, int channel)\n{\n\tstruct berlin2_adc_priv *priv = iio_priv(indio_dev);\n\tint data, ret;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tregmap_write(priv->regmap, BERLIN2_SM_ADC_STATUS,\n\t\t     BERLIN2_SM_ADC_STATUS_INT_EN(channel));\n\n\t \n\tregmap_update_bits(priv->regmap, BERLIN2_SM_CTRL,\n\t\t\t   BERLIN2_SM_CTRL_ADC_RESET |\n\t\t\t   BERLIN2_SM_CTRL_ADC_SEL_MASK |\n\t\t\t   BERLIN2_SM_CTRL_ADC_START,\n\t\t\t   BERLIN2_SM_CTRL_ADC_SEL(channel) |\n\t\t\t   BERLIN2_SM_CTRL_ADC_START);\n\n\tret = wait_event_interruptible_timeout(priv->wq, priv->data_available,\n\t\t\t\t\t       msecs_to_jiffies(1000));\n\n\t \n\tregmap_update_bits(priv->regmap, BERLIN2_SM_ADC_STATUS,\n\t\t\t   BERLIN2_SM_ADC_STATUS_INT_EN(channel), 0);\n\n\tif (ret == 0)\n\t\tret = -ETIMEDOUT;\n\tif (ret < 0) {\n\t\tmutex_unlock(&priv->lock);\n\t\treturn ret;\n\t}\n\n\tregmap_update_bits(priv->regmap, BERLIN2_SM_CTRL,\n\t\t\t   BERLIN2_SM_CTRL_ADC_START, 0);\n\n\tdata = priv->data;\n\tpriv->data_available = false;\n\n\tmutex_unlock(&priv->lock);\n\n\treturn data;\n}\n\nstatic int berlin2_adc_tsen_read(struct iio_dev *indio_dev)\n{\n\tstruct berlin2_adc_priv *priv = iio_priv(indio_dev);\n\tint data, ret;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tregmap_write(priv->regmap, BERLIN2_SM_TSEN_STATUS,\n\t\t     BERLIN2_SM_TSEN_STATUS_INT_EN);\n\n\t \n\tregmap_update_bits(priv->regmap, BERLIN2_SM_CTRL,\n\t\t\t   BERLIN2_SM_CTRL_TSEN_RESET |\n\t\t\t   BERLIN2_SM_CTRL_ADC_ROTATE,\n\t\t\t   BERLIN2_SM_CTRL_ADC_ROTATE);\n\n\t \n\tregmap_update_bits(priv->regmap, BERLIN2_SM_TSEN_CTRL,\n\t\t\t   BERLIN2_SM_TSEN_CTRL_TRIM_MASK |\n\t\t\t   BERLIN2_SM_TSEN_CTRL_SETTLING_MASK |\n\t\t\t   BERLIN2_SM_TSEN_CTRL_START,\n\t\t\t   BERLIN2_SM_TSEN_CTRL_TRIM(3) |\n\t\t\t   BERLIN2_SM_TSEN_CTRL_SETTLING_12 |\n\t\t\t   BERLIN2_SM_TSEN_CTRL_START);\n\n\tret = wait_event_interruptible_timeout(priv->wq, priv->data_available,\n\t\t\t\t\t       msecs_to_jiffies(1000));\n\n\t \n\tregmap_update_bits(priv->regmap, BERLIN2_SM_TSEN_STATUS,\n\t\t\t   BERLIN2_SM_TSEN_STATUS_INT_EN, 0);\n\n\tif (ret == 0)\n\t\tret = -ETIMEDOUT;\n\tif (ret < 0) {\n\t\tmutex_unlock(&priv->lock);\n\t\treturn ret;\n\t}\n\n\tregmap_update_bits(priv->regmap, BERLIN2_SM_TSEN_CTRL,\n\t\t\t   BERLIN2_SM_TSEN_CTRL_START, 0);\n\n\tdata = priv->data;\n\tpriv->data_available = false;\n\n\tmutex_unlock(&priv->lock);\n\n\treturn data;\n}\n\nstatic int berlin2_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan, int *val,\n\t\t\t\tint *val2, long mask)\n{\n\tint temp;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->type != IIO_VOLTAGE)\n\t\t\treturn -EINVAL;\n\n\t\t*val = berlin2_adc_read(indio_dev, chan->channel);\n\t\tif (*val < 0)\n\t\t\treturn *val;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tif (chan->type != IIO_TEMP)\n\t\t\treturn -EINVAL;\n\n\t\ttemp = berlin2_adc_tsen_read(indio_dev);\n\t\tif (temp < 0)\n\t\t\treturn temp;\n\n\t\tif (temp > 2047)\n\t\t\ttemp -= 4096;\n\n\t\t \n\t\t*val = ((temp * 100000) / 264 - 270000);\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic irqreturn_t berlin2_adc_irq(int irq, void *private)\n{\n\tstruct berlin2_adc_priv *priv = iio_priv(private);\n\tunsigned val;\n\n\tregmap_read(priv->regmap, BERLIN2_SM_ADC_STATUS, &val);\n\tif (val & BERLIN2_SM_ADC_STATUS_DATA_RDY_MASK) {\n\t\tregmap_read(priv->regmap, BERLIN2_SM_ADC_DATA, &priv->data);\n\t\tpriv->data &= BERLIN2_SM_ADC_MASK;\n\n\t\tval &= ~BERLIN2_SM_ADC_STATUS_DATA_RDY_MASK;\n\t\tregmap_write(priv->regmap, BERLIN2_SM_ADC_STATUS, val);\n\n\t\tpriv->data_available = true;\n\t\twake_up_interruptible(&priv->wq);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t berlin2_adc_tsen_irq(int irq, void *private)\n{\n\tstruct berlin2_adc_priv *priv = iio_priv(private);\n\tunsigned val;\n\n\tregmap_read(priv->regmap, BERLIN2_SM_TSEN_STATUS, &val);\n\tif (val & BERLIN2_SM_TSEN_STATUS_DATA_RDY) {\n\t\tregmap_read(priv->regmap, BERLIN2_SM_TSEN_DATA, &priv->data);\n\t\tpriv->data &= BERLIN2_SM_TSEN_MASK;\n\n\t\tval &= ~BERLIN2_SM_TSEN_STATUS_DATA_RDY;\n\t\tregmap_write(priv->regmap, BERLIN2_SM_TSEN_STATUS, val);\n\n\t\tpriv->data_available = true;\n\t\twake_up_interruptible(&priv->wq);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_info berlin2_adc_info = {\n\t.read_raw\t= berlin2_adc_read_raw,\n};\n\nstatic void berlin2_adc_powerdown(void *regmap)\n{\n\tregmap_update_bits(regmap, BERLIN2_SM_CTRL,\n\t\t\t   BERLIN2_SM_CTRL_ADC_POWER, 0);\n\n}\n\nstatic int berlin2_adc_probe(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct berlin2_adc_priv *priv;\n\tstruct device_node *parent_np = of_get_parent(pdev->dev.of_node);\n\tint irq, tsen_irq;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*priv));\n\tif (!indio_dev) {\n\t\tof_node_put(parent_np);\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = iio_priv(indio_dev);\n\n\tpriv->regmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tirq = platform_get_irq_byname(pdev, \"adc\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\ttsen_irq = platform_get_irq_byname(pdev, \"tsen\");\n\tif (tsen_irq < 0)\n\t\treturn tsen_irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, berlin2_adc_irq, 0,\n\t\t\t       pdev->dev.driver->name, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_irq(&pdev->dev, tsen_irq, berlin2_adc_tsen_irq,\n\t\t\t       0, pdev->dev.driver->name, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tinit_waitqueue_head(&priv->wq);\n\tmutex_init(&priv->lock);\n\n\tindio_dev->name = dev_name(&pdev->dev);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &berlin2_adc_info;\n\n\tindio_dev->channels = berlin2_adc_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(berlin2_adc_channels);\n\n\t \n\tregmap_update_bits(priv->regmap, BERLIN2_SM_CTRL,\n\t\t\t   BERLIN2_SM_CTRL_ADC_POWER,\n\t\t\t   BERLIN2_SM_CTRL_ADC_POWER);\n\n\tret = devm_add_action_or_reset(&pdev->dev, berlin2_adc_powerdown,\n\t\t\t\t       priv->regmap);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&pdev->dev, indio_dev);\n}\n\nstatic const struct of_device_id berlin2_adc_match[] = {\n\t{ .compatible = \"marvell,berlin2-adc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, berlin2_adc_match);\n\nstatic struct platform_driver berlin2_adc_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"berlin2-adc\",\n\t\t.of_match_table\t= berlin2_adc_match,\n\t},\n\t.probe\t= berlin2_adc_probe,\n};\nmodule_platform_driver(berlin2_adc_driver);\n\nMODULE_AUTHOR(\"Antoine Tenart <antoine.tenart@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Marvell Berlin2 ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}