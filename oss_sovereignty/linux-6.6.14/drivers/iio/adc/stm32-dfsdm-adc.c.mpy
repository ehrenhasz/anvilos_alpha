{
  "module_name": "stm32-dfsdm-adc.c",
  "hash_id": "7560e56527d2baf64a28561b82ffc129b03a647496da34e622e341a3b9bcb2b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/stm32-dfsdm-adc.c",
  "human_readable_source": "\n \n\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/iio/adc/stm32-dfsdm-adc.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/hw-consumer.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/timer/stm32-lptim-trigger.h>\n#include <linux/iio/timer/stm32-timer-trigger.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"stm32-dfsdm.h\"\n\n#define DFSDM_DMA_BUFFER_SIZE (4 * PAGE_SIZE)\n\n \n#define DFSDM_TIMEOUT_US 100000\n#define DFSDM_TIMEOUT (msecs_to_jiffies(DFSDM_TIMEOUT_US / 1000))\n\n \n#define DFSDM_DEFAULT_OVERSAMPLING  100\n\n \n#define DFSDM_MAX_INT_OVERSAMPLING 256\n#define DFSDM_MAX_FL_OVERSAMPLING 1024\n\n \n#define DFSDM_DATA_MAX BIT(30)\n \n#define DFSDM_DATA_RES 24\n\n \n#define DFSDM_CR1_CFG_MASK (DFSDM_CR1_RCH_MASK | DFSDM_CR1_RCONT_MASK | \\\n\t\t\t    DFSDM_CR1_RSYNC_MASK | DFSDM_CR1_JSYNC_MASK | \\\n\t\t\t    DFSDM_CR1_JSCAN_MASK)\n\nenum sd_converter_type {\n\tDFSDM_AUDIO,\n\tDFSDM_IIO,\n};\n\nstruct stm32_dfsdm_dev_data {\n\tint type;\n\tint (*init)(struct device *dev, struct iio_dev *indio_dev);\n\tunsigned int num_channels;\n\tconst struct regmap_config *regmap_cfg;\n};\n\nstruct stm32_dfsdm_adc {\n\tstruct stm32_dfsdm *dfsdm;\n\tconst struct stm32_dfsdm_dev_data *dev_data;\n\tunsigned int fl_id;\n\tunsigned int nconv;\n\tunsigned long smask;\n\n\t \n\tunsigned int oversamp;\n\tstruct iio_hw_consumer *hwc;\n\tstruct completion completion;\n\tu32 *buffer;\n\n\t \n\tunsigned int spi_freq;   \n\tunsigned int sample_freq;  \n\tint (*cb)(const void *data, size_t size, void *cb_priv);\n\tvoid *cb_priv;\n\n\t \n\tu8 *rx_buf;\n\tunsigned int bufi;  \n\tunsigned int buf_sz;  \n\tstruct dma_chan\t*dma_chan;\n\tdma_addr_t dma_buf;\n};\n\nstruct stm32_dfsdm_str2field {\n\tconst char\t*name;\n\tunsigned int\tval;\n};\n\n \nstatic const struct stm32_dfsdm_str2field stm32_dfsdm_chan_type[] = {\n\t{ \"SPI_R\", 0 },  \n\t{ \"SPI_F\", 1 },  \n\t{ \"MANCH_R\", 2 },  \n\t{ \"MANCH_F\", 3 },  \n\t{},\n};\n\n \nstatic const struct stm32_dfsdm_str2field stm32_dfsdm_chan_src[] = {\n\t \n\t{ \"CLKIN\", DFSDM_CHANNEL_SPI_CLOCK_EXTERNAL },\n\t \n\t{ \"CLKOUT\", DFSDM_CHANNEL_SPI_CLOCK_INTERNAL },\n\t \n\t{ \"CLKOUT_F\", DFSDM_CHANNEL_SPI_CLOCK_INTERNAL_DIV2_FALLING },\n\t \n\t{ \"CLKOUT_R\", DFSDM_CHANNEL_SPI_CLOCK_INTERNAL_DIV2_RISING },\n\t{},\n};\n\nstatic int stm32_dfsdm_str2val(const char *str,\n\t\t\t       const struct stm32_dfsdm_str2field *list)\n{\n\tconst struct stm32_dfsdm_str2field *p = list;\n\n\tfor (p = list; p && p->name; p++)\n\t\tif (!strcmp(p->name, str))\n\t\t\treturn p->val;\n\n\treturn -EINVAL;\n}\n\n \nstruct stm32_dfsdm_trig_info {\n\tconst char *name;\n\tunsigned int jextsel;\n};\n\n \nenum stm32_dfsdm_jexten {\n\tSTM32_DFSDM_JEXTEN_DISABLED,\n\tSTM32_DFSDM_JEXTEN_RISING_EDGE,\n\tSTM32_DFSDM_JEXTEN_FALLING_EDGE,\n\tSTM32_DFSDM_EXTEN_BOTH_EDGES,\n};\n\nstatic const struct stm32_dfsdm_trig_info stm32_dfsdm_trigs[] = {\n\t{ TIM1_TRGO, 0 },\n\t{ TIM1_TRGO2, 1 },\n\t{ TIM8_TRGO, 2 },\n\t{ TIM8_TRGO2, 3 },\n\t{ TIM3_TRGO, 4 },\n\t{ TIM4_TRGO, 5 },\n\t{ TIM16_OC1, 6 },\n\t{ TIM6_TRGO, 7 },\n\t{ TIM7_TRGO, 8 },\n\t{ LPTIM1_OUT, 26 },\n\t{ LPTIM2_OUT, 27 },\n\t{ LPTIM3_OUT, 28 },\n\t{},\n};\n\nstatic int stm32_dfsdm_get_jextsel(struct iio_dev *indio_dev,\n\t\t\t\t   struct iio_trigger *trig)\n{\n\tint i;\n\n\t \n\tfor (i = 0; stm32_dfsdm_trigs[i].name; i++) {\n\t\t \n\t\tif ((is_stm32_timer_trigger(trig) ||\n\t\t     is_stm32_lptim_trigger(trig)) &&\n\t\t    !strcmp(stm32_dfsdm_trigs[i].name, trig->name)) {\n\t\t\treturn stm32_dfsdm_trigs[i].jextsel;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_dfsdm_compute_osrs(struct stm32_dfsdm_filter *fl,\n\t\t\t\t    unsigned int fast, unsigned int oversamp)\n{\n\tunsigned int i, d, fosr, iosr;\n\tu64 res, max;\n\tint bits, shift;\n\tunsigned int m = 1;\t \n\tunsigned int p = fl->ford;\t \n\tstruct stm32_dfsdm_filter_osr *flo = &fl->flo[fast];\n\n\tpr_debug(\"Requested oversampling: %d\\n\", oversamp);\n\t \n\tif (fl->ford == DFSDM_FASTSINC_ORDER) {\n\t\tm = 2;\n\t\tp = 2;\n\t}\n\n\t \n\tfor (fosr = 1; fosr <= DFSDM_MAX_FL_OVERSAMPLING; fosr++) {\n\t\tfor (iosr = 1; iosr <= DFSDM_MAX_INT_OVERSAMPLING; iosr++) {\n\t\t\tif (fast)\n\t\t\t\td = fosr * iosr;\n\t\t\telse if (fl->ford == DFSDM_FASTSINC_ORDER)\n\t\t\t\td = fosr * (iosr + 3) + 2;\n\t\t\telse\n\t\t\t\td = fosr * (iosr - 1 + p) + p;\n\n\t\t\tif (d > oversamp)\n\t\t\t\tbreak;\n\t\t\telse if (d != oversamp)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tres = fosr;\n\t\t\tfor (i = p - 1; i > 0; i--) {\n\t\t\t\tres = res * (u64)fosr;\n\t\t\t\tif (res > DFSDM_DATA_MAX)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (res > DFSDM_DATA_MAX)\n\t\t\t\tcontinue;\n\n\t\t\tres = res * (u64)m * (u64)iosr;\n\t\t\tif (res > DFSDM_DATA_MAX)\n\t\t\t\tcontinue;\n\n\t\t\tif (res >= flo->res) {\n\t\t\t\tflo->res = res;\n\t\t\t\tflo->fosr = fosr;\n\t\t\t\tflo->iosr = iosr;\n\n\t\t\t\tbits = fls(flo->res);\n\t\t\t\t \n\t\t\t\tmax = flo->res << 8;\n\n\t\t\t\t \n\t\t\t\tif (flo->res > BIT(bits - 1))\n\t\t\t\t\tbits++;\n\t\t\t\telse\n\t\t\t\t\tmax--;\n\n\t\t\t\tshift = DFSDM_DATA_RES - bits;\n\t\t\t\t \n\t\t\t\tif (shift > 0) {\n\t\t\t\t\t \n\t\t\t\t\tflo->rshift = 0;\n\t\t\t\t\tflo->lshift = shift;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tflo->rshift = 1 - shift;\n\t\t\t\t\tflo->lshift = 1;\n\t\t\t\t\tmax >>= flo->rshift;\n\t\t\t\t}\n\t\t\t\tflo->max = (s32)max;\n\t\t\t\tflo->bits = bits;\n\n\t\t\t\tpr_debug(\"fast %d, fosr %d, iosr %d, res 0x%llx/%d bits, rshift %d, lshift %d\\n\",\n\t\t\t\t\t fast, flo->fosr, flo->iosr,\n\t\t\t\t\t flo->res, bits, flo->rshift,\n\t\t\t\t\t flo->lshift);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!flo->res)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int stm32_dfsdm_compute_all_osrs(struct iio_dev *indio_dev,\n\t\t\t\t\tunsigned int oversamp)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tstruct stm32_dfsdm_filter *fl = &adc->dfsdm->fl_list[adc->fl_id];\n\tint ret0, ret1;\n\n\tmemset(&fl->flo[0], 0, sizeof(fl->flo[0]));\n\tmemset(&fl->flo[1], 0, sizeof(fl->flo[1]));\n\n\tret0 = stm32_dfsdm_compute_osrs(fl, 0, oversamp);\n\tret1 = stm32_dfsdm_compute_osrs(fl, 1, oversamp);\n\tif (ret0 < 0 && ret1 < 0) {\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\"Filter parameters not found: errors %d/%d\\n\",\n\t\t\tret0, ret1);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_dfsdm_start_channel(struct iio_dev *indio_dev)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tstruct regmap *regmap = adc->dfsdm->regmap;\n\tconst struct iio_chan_spec *chan;\n\tunsigned int bit;\n\tint ret;\n\n\tfor_each_set_bit(bit, &adc->smask, sizeof(adc->smask) * BITS_PER_BYTE) {\n\t\tchan = indio_dev->channels + bit;\n\t\tret = regmap_update_bits(regmap, DFSDM_CHCFGR1(chan->channel),\n\t\t\t\t\t DFSDM_CHCFGR1_CHEN_MASK,\n\t\t\t\t\t DFSDM_CHCFGR1_CHEN(1));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void stm32_dfsdm_stop_channel(struct iio_dev *indio_dev)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tstruct regmap *regmap = adc->dfsdm->regmap;\n\tconst struct iio_chan_spec *chan;\n\tunsigned int bit;\n\n\tfor_each_set_bit(bit, &adc->smask, sizeof(adc->smask) * BITS_PER_BYTE) {\n\t\tchan = indio_dev->channels + bit;\n\t\tregmap_update_bits(regmap, DFSDM_CHCFGR1(chan->channel),\n\t\t\t\t   DFSDM_CHCFGR1_CHEN_MASK,\n\t\t\t\t   DFSDM_CHCFGR1_CHEN(0));\n\t}\n}\n\nstatic int stm32_dfsdm_chan_configure(struct stm32_dfsdm *dfsdm,\n\t\t\t\t      struct stm32_dfsdm_channel *ch)\n{\n\tunsigned int id = ch->id;\n\tstruct regmap *regmap = dfsdm->regmap;\n\tint ret;\n\n\tret = regmap_update_bits(regmap, DFSDM_CHCFGR1(id),\n\t\t\t\t DFSDM_CHCFGR1_SITP_MASK,\n\t\t\t\t DFSDM_CHCFGR1_SITP(ch->type));\n\tif (ret < 0)\n\t\treturn ret;\n\tret = regmap_update_bits(regmap, DFSDM_CHCFGR1(id),\n\t\t\t\t DFSDM_CHCFGR1_SPICKSEL_MASK,\n\t\t\t\t DFSDM_CHCFGR1_SPICKSEL(ch->src));\n\tif (ret < 0)\n\t\treturn ret;\n\treturn regmap_update_bits(regmap, DFSDM_CHCFGR1(id),\n\t\t\t\t  DFSDM_CHCFGR1_CHINSEL_MASK,\n\t\t\t\t  DFSDM_CHCFGR1_CHINSEL(ch->alt_si));\n}\n\nstatic int stm32_dfsdm_start_filter(struct stm32_dfsdm_adc *adc,\n\t\t\t\t    unsigned int fl_id,\n\t\t\t\t    struct iio_trigger *trig)\n{\n\tstruct stm32_dfsdm *dfsdm = adc->dfsdm;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(dfsdm->regmap, DFSDM_CR1(fl_id),\n\t\t\t\t DFSDM_CR1_DFEN_MASK, DFSDM_CR1_DFEN(1));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (adc->nconv > 1 || trig)\n\t\treturn 0;\n\n\t \n\treturn regmap_update_bits(dfsdm->regmap, DFSDM_CR1(fl_id),\n\t\t\t\t  DFSDM_CR1_RSWSTART_MASK,\n\t\t\t\t  DFSDM_CR1_RSWSTART(1));\n}\n\nstatic void stm32_dfsdm_stop_filter(struct stm32_dfsdm *dfsdm,\n\t\t\t\t    unsigned int fl_id)\n{\n\t \n\tregmap_update_bits(dfsdm->regmap, DFSDM_CR1(fl_id),\n\t\t\t   DFSDM_CR1_DFEN_MASK, DFSDM_CR1_DFEN(0));\n}\n\nstatic int stm32_dfsdm_filter_set_trig(struct iio_dev *indio_dev,\n\t\t\t\t       unsigned int fl_id,\n\t\t\t\t       struct iio_trigger *trig)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tstruct regmap *regmap = adc->dfsdm->regmap;\n\tu32 jextsel = 0, jexten = STM32_DFSDM_JEXTEN_DISABLED;\n\tint ret;\n\n\tif (trig) {\n\t\tret = stm32_dfsdm_get_jextsel(indio_dev, trig);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tjextsel = ret;\n\t\tjexten = STM32_DFSDM_JEXTEN_RISING_EDGE;\n\t}\n\n\tret = regmap_update_bits(regmap, DFSDM_CR1(fl_id),\n\t\t\t\t DFSDM_CR1_JEXTSEL_MASK | DFSDM_CR1_JEXTEN_MASK,\n\t\t\t\t DFSDM_CR1_JEXTSEL(jextsel) |\n\t\t\t\t DFSDM_CR1_JEXTEN(jexten));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int stm32_dfsdm_channels_configure(struct iio_dev *indio_dev,\n\t\t\t\t\t  unsigned int fl_id,\n\t\t\t\t\t  struct iio_trigger *trig)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tstruct regmap *regmap = adc->dfsdm->regmap;\n\tstruct stm32_dfsdm_filter *fl = &adc->dfsdm->fl_list[fl_id];\n\tstruct stm32_dfsdm_filter_osr *flo = &fl->flo[0];\n\tconst struct iio_chan_spec *chan;\n\tunsigned int bit;\n\tint ret;\n\n\tfl->fast = 0;\n\n\t \n\tif (adc->nconv == 1 && !trig && iio_buffer_enabled(indio_dev)) {\n\t\tif (fl->flo[1].res >= fl->flo[0].res) {\n\t\t\tfl->fast = 1;\n\t\t\tflo = &fl->flo[1];\n\t\t}\n\t}\n\n\tif (!flo->res)\n\t\treturn -EINVAL;\n\n\tdev_dbg(&indio_dev->dev, \"Samples actual resolution: %d bits\",\n\t\tmin(flo->bits, (u32)DFSDM_DATA_RES - 1));\n\n\tfor_each_set_bit(bit, &adc->smask,\n\t\t\t sizeof(adc->smask) * BITS_PER_BYTE) {\n\t\tchan = indio_dev->channels + bit;\n\n\t\tret = regmap_update_bits(regmap,\n\t\t\t\t\t DFSDM_CHCFGR2(chan->channel),\n\t\t\t\t\t DFSDM_CHCFGR2_DTRBS_MASK,\n\t\t\t\t\t DFSDM_CHCFGR2_DTRBS(flo->rshift));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_dfsdm_filter_configure(struct iio_dev *indio_dev,\n\t\t\t\t\tunsigned int fl_id,\n\t\t\t\t\tstruct iio_trigger *trig)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tstruct regmap *regmap = adc->dfsdm->regmap;\n\tstruct stm32_dfsdm_filter *fl = &adc->dfsdm->fl_list[fl_id];\n\tstruct stm32_dfsdm_filter_osr *flo = &fl->flo[fl->fast];\n\tu32 cr1;\n\tconst struct iio_chan_spec *chan;\n\tunsigned int bit, jchg = 0;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(regmap, DFSDM_FCR(fl_id), DFSDM_FCR_IOSR_MASK,\n\t\t\t\t DFSDM_FCR_IOSR(flo->iosr - 1));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(regmap, DFSDM_FCR(fl_id), DFSDM_FCR_FOSR_MASK,\n\t\t\t\t DFSDM_FCR_FOSR(flo->fosr - 1));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, DFSDM_FCR(fl_id), DFSDM_FCR_FORD_MASK,\n\t\t\t\t DFSDM_FCR_FORD(fl->ford));\n\tif (ret)\n\t\treturn ret;\n\n\tret = stm32_dfsdm_filter_set_trig(indio_dev, fl_id, trig);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, DFSDM_CR1(fl_id),\n\t\t\t\t DFSDM_CR1_FAST_MASK,\n\t\t\t\t DFSDM_CR1_FAST(fl->fast));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (adc->nconv == 1 && !trig) {\n\t\tbit = __ffs(adc->smask);\n\t\tchan = indio_dev->channels + bit;\n\n\t\t \n\t\tcr1 = DFSDM_CR1_RCH(chan->channel);\n\n\t\t \n\t\tif (iio_buffer_enabled(indio_dev))\n\t\t\tcr1 |= DFSDM_CR1_RCONT(1);\n\n\t\tcr1 |= DFSDM_CR1_RSYNC(fl->sync_mode);\n\t} else {\n\t\t \n\t\tfor_each_set_bit(bit, &adc->smask,\n\t\t\t\t sizeof(adc->smask) * BITS_PER_BYTE) {\n\t\t\tchan = indio_dev->channels + bit;\n\t\t\tjchg |= BIT(chan->channel);\n\t\t}\n\t\tret = regmap_write(regmap, DFSDM_JCHGR(fl_id), jchg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tcr1 = DFSDM_CR1_JSCAN((adc->nconv > 1) ? 1 : 0);\n\n\t\t \n\t\tif (!fl->sync_mode && !trig)\n\t\t\treturn -EINVAL;\n\t\tcr1 |= DFSDM_CR1_JSYNC(fl->sync_mode);\n\t}\n\n\treturn regmap_update_bits(regmap, DFSDM_CR1(fl_id), DFSDM_CR1_CFG_MASK,\n\t\t\t\t  cr1);\n}\n\nstatic int stm32_dfsdm_channel_parse_of(struct stm32_dfsdm *dfsdm,\n\t\t\t\t\tstruct iio_dev *indio_dev,\n\t\t\t\t\tstruct iio_chan_spec *ch)\n{\n\tstruct stm32_dfsdm_channel *df_ch;\n\tconst char *of_str;\n\tint chan_idx = ch->scan_index;\n\tint ret, val;\n\n\tret = of_property_read_u32_index(indio_dev->dev.of_node,\n\t\t\t\t\t \"st,adc-channels\", chan_idx,\n\t\t\t\t\t &ch->channel);\n\tif (ret < 0) {\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\" Error parsing 'st,adc-channels' for idx %d\\n\",\n\t\t\tchan_idx);\n\t\treturn ret;\n\t}\n\tif (ch->channel >= dfsdm->num_chs) {\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\" Error bad channel number %d (max = %d)\\n\",\n\t\t\tch->channel, dfsdm->num_chs);\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_string_index(indio_dev->dev.of_node,\n\t\t\t\t\t    \"st,adc-channel-names\", chan_idx,\n\t\t\t\t\t    &ch->datasheet_name);\n\tif (ret < 0) {\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\" Error parsing 'st,adc-channel-names' for idx %d\\n\",\n\t\t\tchan_idx);\n\t\treturn ret;\n\t}\n\n\tdf_ch =  &dfsdm->ch_list[ch->channel];\n\tdf_ch->id = ch->channel;\n\n\tret = of_property_read_string_index(indio_dev->dev.of_node,\n\t\t\t\t\t    \"st,adc-channel-types\", chan_idx,\n\t\t\t\t\t    &of_str);\n\tif (!ret) {\n\t\tval = stm32_dfsdm_str2val(of_str, stm32_dfsdm_chan_type);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t} else {\n\t\tval = 0;\n\t}\n\tdf_ch->type = val;\n\n\tret = of_property_read_string_index(indio_dev->dev.of_node,\n\t\t\t\t\t    \"st,adc-channel-clk-src\", chan_idx,\n\t\t\t\t\t    &of_str);\n\tif (!ret) {\n\t\tval = stm32_dfsdm_str2val(of_str, stm32_dfsdm_chan_src);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t} else {\n\t\tval = 0;\n\t}\n\tdf_ch->src = val;\n\n\tret = of_property_read_u32_index(indio_dev->dev.of_node,\n\t\t\t\t\t \"st,adc-alt-channel\", chan_idx,\n\t\t\t\t\t &df_ch->alt_si);\n\tif (ret < 0)\n\t\tdf_ch->alt_si = 0;\n\n\treturn 0;\n}\n\nstatic ssize_t dfsdm_adc_audio_get_spiclk(struct iio_dev *indio_dev,\n\t\t\t\t\t  uintptr_t priv,\n\t\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t\t  char *buf)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", adc->spi_freq);\n}\n\nstatic int dfsdm_adc_set_samp_freq(struct iio_dev *indio_dev,\n\t\t\t\t   unsigned int sample_freq,\n\t\t\t\t   unsigned int spi_freq)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tunsigned int oversamp;\n\tint ret;\n\n\toversamp = DIV_ROUND_CLOSEST(spi_freq, sample_freq);\n\tif (spi_freq % sample_freq)\n\t\tdev_dbg(&indio_dev->dev,\n\t\t\t\"Rate not accurate. requested (%u), actual (%u)\\n\",\n\t\t\tsample_freq, spi_freq / oversamp);\n\n\tret = stm32_dfsdm_compute_all_osrs(indio_dev, oversamp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tadc->sample_freq = spi_freq / oversamp;\n\tadc->oversamp = oversamp;\n\n\treturn 0;\n}\n\nstatic ssize_t dfsdm_adc_audio_set_spiclk(struct iio_dev *indio_dev,\n\t\t\t\t\t  uintptr_t priv,\n\t\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tstruct stm32_dfsdm_channel *ch = &adc->dfsdm->ch_list[chan->channel];\n\tunsigned int sample_freq = adc->sample_freq;\n\tunsigned int spi_freq;\n\tint ret;\n\n\tdev_err(&indio_dev->dev, \"enter %s\\n\", __func__);\n\t \n\tif (ch->src != DFSDM_CHANNEL_SPI_CLOCK_EXTERNAL)\n\t\treturn -EPERM;\n\n\tret = kstrtoint(buf, 0, &spi_freq);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!spi_freq)\n\t\treturn -EINVAL;\n\n\tif (sample_freq) {\n\t\tret = dfsdm_adc_set_samp_freq(indio_dev, sample_freq, spi_freq);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tadc->spi_freq = spi_freq;\n\n\treturn len;\n}\n\nstatic int stm32_dfsdm_start_conv(struct iio_dev *indio_dev,\n\t\t\t\t  struct iio_trigger *trig)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tstruct regmap *regmap = adc->dfsdm->regmap;\n\tint ret;\n\n\tret = stm32_dfsdm_channels_configure(indio_dev, adc->fl_id, trig);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = stm32_dfsdm_start_channel(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = stm32_dfsdm_filter_configure(indio_dev, adc->fl_id, trig);\n\tif (ret < 0)\n\t\tgoto stop_channels;\n\n\tret = stm32_dfsdm_start_filter(adc, adc->fl_id, trig);\n\tif (ret < 0)\n\t\tgoto filter_unconfigure;\n\n\treturn 0;\n\nfilter_unconfigure:\n\tregmap_update_bits(regmap, DFSDM_CR1(adc->fl_id),\n\t\t\t   DFSDM_CR1_CFG_MASK, 0);\nstop_channels:\n\tstm32_dfsdm_stop_channel(indio_dev);\n\n\treturn ret;\n}\n\nstatic void stm32_dfsdm_stop_conv(struct iio_dev *indio_dev)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tstruct regmap *regmap = adc->dfsdm->regmap;\n\n\tstm32_dfsdm_stop_filter(adc->dfsdm, adc->fl_id);\n\n\tregmap_update_bits(regmap, DFSDM_CR1(adc->fl_id),\n\t\t\t   DFSDM_CR1_CFG_MASK, 0);\n\n\tstm32_dfsdm_stop_channel(indio_dev);\n}\n\nstatic int stm32_dfsdm_set_watermark(struct iio_dev *indio_dev,\n\t\t\t\t     unsigned int val)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tunsigned int watermark = DFSDM_DMA_BUFFER_SIZE / 2;\n\tunsigned int rx_buf_sz = DFSDM_DMA_BUFFER_SIZE;\n\n\t \n\twatermark = min(watermark, val * (unsigned int)(sizeof(u32)));\n\tadc->buf_sz = min(rx_buf_sz, watermark * 2 * adc->nconv);\n\n\treturn 0;\n}\n\nstatic unsigned int stm32_dfsdm_adc_dma_residue(struct stm32_dfsdm_adc *adc)\n{\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\n\tstatus = dmaengine_tx_status(adc->dma_chan,\n\t\t\t\t     adc->dma_chan->cookie,\n\t\t\t\t     &state);\n\tif (status == DMA_IN_PROGRESS) {\n\t\t \n\t\tunsigned int i = adc->buf_sz - state.residue;\n\t\tunsigned int size;\n\n\t\t \n\t\tif (i >= adc->bufi)\n\t\t\tsize = i - adc->bufi;\n\t\telse\n\t\t\tsize = adc->buf_sz + i - adc->bufi;\n\n\t\treturn size;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void stm32_dfsdm_process_data(struct stm32_dfsdm_adc *adc,\n\t\t\t\t\t    s32 *buffer)\n{\n\tstruct stm32_dfsdm_filter *fl = &adc->dfsdm->fl_list[adc->fl_id];\n\tstruct stm32_dfsdm_filter_osr *flo = &fl->flo[fl->fast];\n\tunsigned int i = adc->nconv;\n\ts32 *ptr = buffer;\n\n\twhile (i--) {\n\t\t \n\t\t*ptr &= 0xFFFFFF00;\n\t\t \n\t\tif (*ptr > flo->max)\n\t\t\t*ptr -= 1;\n\t\t \n\t\t*ptr <<= flo->lshift;\n\n\t\tptr++;\n\t}\n}\n\nstatic void stm32_dfsdm_dma_buffer_done(void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tint available = stm32_dfsdm_adc_dma_residue(adc);\n\tsize_t old_pos;\n\n\t \n\n\tdev_dbg(&indio_dev->dev, \"pos = %d, available = %d\\n\",\n\t\tadc->bufi, available);\n\told_pos = adc->bufi;\n\n\twhile (available >= indio_dev->scan_bytes) {\n\t\ts32 *buffer = (s32 *)&adc->rx_buf[adc->bufi];\n\n\t\tstm32_dfsdm_process_data(adc, buffer);\n\n\t\tavailable -= indio_dev->scan_bytes;\n\t\tadc->bufi += indio_dev->scan_bytes;\n\t\tif (adc->bufi >= adc->buf_sz) {\n\t\t\tif (adc->cb)\n\t\t\t\tadc->cb(&adc->rx_buf[old_pos],\n\t\t\t\t\t adc->buf_sz - old_pos, adc->cb_priv);\n\t\t\tadc->bufi = 0;\n\t\t\told_pos = 0;\n\t\t}\n\t\t \n\t\tif (adc->dev_data->type == DFSDM_IIO)\n\t\t\tiio_push_to_buffers(indio_dev, buffer);\n\t}\n\tif (adc->cb)\n\t\tadc->cb(&adc->rx_buf[old_pos], adc->bufi - old_pos,\n\t\t\tadc->cb_priv);\n}\n\nstatic int stm32_dfsdm_adc_dma_start(struct iio_dev *indio_dev)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\t \n\tstruct dma_slave_config config = {\n\t\t.src_addr = (dma_addr_t)adc->dfsdm->phys_base,\n\t\t.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t};\n\tstruct dma_async_tx_descriptor *desc;\n\tdma_cookie_t cookie;\n\tint ret;\n\n\tif (!adc->dma_chan)\n\t\treturn -EINVAL;\n\n\tdev_dbg(&indio_dev->dev, \"size=%d watermark=%d\\n\",\n\t\tadc->buf_sz, adc->buf_sz / 2);\n\n\tif (adc->nconv == 1 && !indio_dev->trig)\n\t\tconfig.src_addr += DFSDM_RDATAR(adc->fl_id);\n\telse\n\t\tconfig.src_addr += DFSDM_JDATAR(adc->fl_id);\n\tret = dmaengine_slave_config(adc->dma_chan, &config);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdesc = dmaengine_prep_dma_cyclic(adc->dma_chan,\n\t\t\t\t\t adc->dma_buf,\n\t\t\t\t\t adc->buf_sz, adc->buf_sz / 2,\n\t\t\t\t\t DMA_DEV_TO_MEM,\n\t\t\t\t\t DMA_PREP_INTERRUPT);\n\tif (!desc)\n\t\treturn -EBUSY;\n\n\tdesc->callback = stm32_dfsdm_dma_buffer_done;\n\tdesc->callback_param = indio_dev;\n\n\tcookie = dmaengine_submit(desc);\n\tret = dma_submit_error(cookie);\n\tif (ret)\n\t\tgoto err_stop_dma;\n\n\t \n\tdma_async_issue_pending(adc->dma_chan);\n\n\tif (adc->nconv == 1 && !indio_dev->trig) {\n\t\t \n\t\tret = regmap_update_bits(adc->dfsdm->regmap,\n\t\t\t\t\t DFSDM_CR1(adc->fl_id),\n\t\t\t\t\t DFSDM_CR1_RDMAEN_MASK,\n\t\t\t\t\t DFSDM_CR1_RDMAEN_MASK);\n\t} else {\n\t\t \n\t\tret = regmap_update_bits(adc->dfsdm->regmap,\n\t\t\t\t\t DFSDM_CR1(adc->fl_id),\n\t\t\t\t\t DFSDM_CR1_JDMAEN_MASK,\n\t\t\t\t\t DFSDM_CR1_JDMAEN_MASK);\n\t}\n\n\tif (ret < 0)\n\t\tgoto err_stop_dma;\n\n\treturn 0;\n\nerr_stop_dma:\n\tdmaengine_terminate_all(adc->dma_chan);\n\n\treturn ret;\n}\n\nstatic void stm32_dfsdm_adc_dma_stop(struct iio_dev *indio_dev)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\n\tif (!adc->dma_chan)\n\t\treturn;\n\n\tregmap_update_bits(adc->dfsdm->regmap, DFSDM_CR1(adc->fl_id),\n\t\t\t   DFSDM_CR1_RDMAEN_MASK | DFSDM_CR1_JDMAEN_MASK, 0);\n\tdmaengine_terminate_all(adc->dma_chan);\n}\n\nstatic int stm32_dfsdm_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t\tconst unsigned long *scan_mask)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\n\tadc->nconv = bitmap_weight(scan_mask, indio_dev->masklength);\n\tadc->smask = *scan_mask;\n\n\tdev_dbg(&indio_dev->dev, \"nconv=%d mask=%lx\\n\", adc->nconv, *scan_mask);\n\n\treturn 0;\n}\n\nstatic int stm32_dfsdm_postenable(struct iio_dev *indio_dev)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\n\t \n\tadc->bufi = 0;\n\n\tif (adc->hwc) {\n\t\tret = iio_hw_consumer_enable(adc->hwc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = stm32_dfsdm_start_dfsdm(adc->dfsdm);\n\tif (ret < 0)\n\t\tgoto err_stop_hwc;\n\n\tret = stm32_dfsdm_adc_dma_start(indio_dev);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"Can't start DMA\\n\");\n\t\tgoto stop_dfsdm;\n\t}\n\n\tret = stm32_dfsdm_start_conv(indio_dev, indio_dev->trig);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"Can't start conversion\\n\");\n\t\tgoto err_stop_dma;\n\t}\n\n\treturn 0;\n\nerr_stop_dma:\n\tstm32_dfsdm_adc_dma_stop(indio_dev);\nstop_dfsdm:\n\tstm32_dfsdm_stop_dfsdm(adc->dfsdm);\nerr_stop_hwc:\n\tif (adc->hwc)\n\t\tiio_hw_consumer_disable(adc->hwc);\n\n\treturn ret;\n}\n\nstatic int stm32_dfsdm_predisable(struct iio_dev *indio_dev)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\n\tstm32_dfsdm_stop_conv(indio_dev);\n\n\tstm32_dfsdm_adc_dma_stop(indio_dev);\n\n\tstm32_dfsdm_stop_dfsdm(adc->dfsdm);\n\n\tif (adc->hwc)\n\t\tiio_hw_consumer_disable(adc->hwc);\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops stm32_dfsdm_buffer_setup_ops = {\n\t.postenable = &stm32_dfsdm_postenable,\n\t.predisable = &stm32_dfsdm_predisable,\n};\n\n \nint stm32_dfsdm_get_buff_cb(struct iio_dev *iio_dev,\n\t\t\t    int (*cb)(const void *data, size_t size,\n\t\t\t\t      void *private),\n\t\t\t    void *private)\n{\n\tstruct stm32_dfsdm_adc *adc;\n\n\tif (!iio_dev)\n\t\treturn -EINVAL;\n\tadc = iio_priv(iio_dev);\n\n\tadc->cb = cb;\n\tadc->cb_priv = private;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(stm32_dfsdm_get_buff_cb);\n\n \nint stm32_dfsdm_release_buff_cb(struct iio_dev *iio_dev)\n{\n\tstruct stm32_dfsdm_adc *adc;\n\n\tif (!iio_dev)\n\t\treturn -EINVAL;\n\tadc = iio_priv(iio_dev);\n\n\tadc->cb = NULL;\n\tadc->cb_priv = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(stm32_dfsdm_release_buff_cb);\n\nstatic int stm32_dfsdm_single_conv(struct iio_dev *indio_dev,\n\t\t\t\t   const struct iio_chan_spec *chan, int *res)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tlong timeout;\n\tint ret;\n\n\treinit_completion(&adc->completion);\n\n\tadc->buffer = res;\n\n\tret = stm32_dfsdm_start_dfsdm(adc->dfsdm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(adc->dfsdm->regmap, DFSDM_CR2(adc->fl_id),\n\t\t\t\t DFSDM_CR2_REOCIE_MASK, DFSDM_CR2_REOCIE(1));\n\tif (ret < 0)\n\t\tgoto stop_dfsdm;\n\n\tadc->nconv = 1;\n\tadc->smask = BIT(chan->scan_index);\n\tret = stm32_dfsdm_start_conv(indio_dev, NULL);\n\tif (ret < 0) {\n\t\tregmap_update_bits(adc->dfsdm->regmap, DFSDM_CR2(adc->fl_id),\n\t\t\t\t   DFSDM_CR2_REOCIE_MASK, DFSDM_CR2_REOCIE(0));\n\t\tgoto stop_dfsdm;\n\t}\n\n\ttimeout = wait_for_completion_interruptible_timeout(&adc->completion,\n\t\t\t\t\t\t\t    DFSDM_TIMEOUT);\n\n\t \n\tregmap_update_bits(adc->dfsdm->regmap, DFSDM_CR2(adc->fl_id),\n\t\t\t   DFSDM_CR2_REOCIE_MASK, DFSDM_CR2_REOCIE(0));\n\n\tif (timeout == 0)\n\t\tret = -ETIMEDOUT;\n\telse if (timeout < 0)\n\t\tret = timeout;\n\telse\n\t\tret = IIO_VAL_INT;\n\n\tstm32_dfsdm_stop_conv(indio_dev);\n\n\tstm32_dfsdm_process_data(adc, res);\n\nstop_dfsdm:\n\tstm32_dfsdm_stop_dfsdm(adc->dfsdm);\n\n\treturn ret;\n}\n\nstatic int stm32_dfsdm_write_raw(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int val, int val2, long mask)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tstruct stm32_dfsdm_channel *ch = &adc->dfsdm->ch_list[chan->channel];\n\tunsigned int spi_freq;\n\tint ret = -EINVAL;\n\n\tswitch (ch->src) {\n\tcase DFSDM_CHANNEL_SPI_CLOCK_INTERNAL:\n\t\tspi_freq = adc->dfsdm->spi_master_freq;\n\t\tbreak;\n\tcase DFSDM_CHANNEL_SPI_CLOCK_INTERNAL_DIV2_FALLING:\n\tcase DFSDM_CHANNEL_SPI_CLOCK_INTERNAL_DIV2_RISING:\n\t\tspi_freq = adc->dfsdm->spi_master_freq / 2;\n\t\tbreak;\n\tdefault:\n\t\tspi_freq = adc->spi_freq;\n\t}\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = stm32_dfsdm_compute_all_osrs(indio_dev, val);\n\t\tif (!ret) {\n\t\t\tdev_dbg(&indio_dev->dev,\n\t\t\t\t\"Sampling rate changed from (%u) to (%u)\\n\",\n\t\t\t\tadc->sample_freq, spi_freq / val);\n\t\t\tadc->oversamp = val;\n\t\t\tadc->sample_freq = spi_freq / val;\n\t\t}\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (!val)\n\t\t\treturn -EINVAL;\n\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = dfsdm_adc_set_samp_freq(indio_dev, val, spi_freq);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_dfsdm_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan, int *val,\n\t\t\t\tint *val2, long mask)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = iio_hw_consumer_enable(adc->hwc);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\"%s: IIO enable failed (channel %d)\\n\",\n\t\t\t\t__func__, chan->channel);\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\treturn ret;\n\t\t}\n\t\tret = stm32_dfsdm_single_conv(indio_dev, chan, val);\n\t\tiio_hw_consumer_disable(adc->hwc);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\"%s: Conversion failed (channel %d)\\n\",\n\t\t\t\t__func__, chan->channel);\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\treturn ret;\n\t\t}\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t*val = adc->oversamp;\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = adc->sample_freq;\n\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_dfsdm_validate_trigger(struct iio_dev *indio_dev,\n\t\t\t\t\tstruct iio_trigger *trig)\n{\n\treturn stm32_dfsdm_get_jextsel(indio_dev, trig) < 0 ? -EINVAL : 0;\n}\n\nstatic const struct iio_info stm32_dfsdm_info_audio = {\n\t.hwfifo_set_watermark = stm32_dfsdm_set_watermark,\n\t.read_raw = stm32_dfsdm_read_raw,\n\t.write_raw = stm32_dfsdm_write_raw,\n\t.update_scan_mode = stm32_dfsdm_update_scan_mode,\n};\n\nstatic const struct iio_info stm32_dfsdm_info_adc = {\n\t.hwfifo_set_watermark = stm32_dfsdm_set_watermark,\n\t.read_raw = stm32_dfsdm_read_raw,\n\t.write_raw = stm32_dfsdm_write_raw,\n\t.update_scan_mode = stm32_dfsdm_update_scan_mode,\n\t.validate_trigger = stm32_dfsdm_validate_trigger,\n};\n\nstatic irqreturn_t stm32_dfsdm_irq(int irq, void *arg)\n{\n\tstruct iio_dev *indio_dev = arg;\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tstruct regmap *regmap = adc->dfsdm->regmap;\n\tunsigned int status, int_en;\n\n\tregmap_read(regmap, DFSDM_ISR(adc->fl_id), &status);\n\tregmap_read(regmap, DFSDM_CR2(adc->fl_id), &int_en);\n\n\tif (status & DFSDM_ISR_REOCF_MASK) {\n\t\t \n\t\tregmap_read(regmap, DFSDM_RDATAR(adc->fl_id), adc->buffer);\n\t\tcomplete(&adc->completion);\n\t}\n\n\tif (status & DFSDM_ISR_ROVRF_MASK) {\n\t\tif (int_en & DFSDM_CR2_ROVRIE_MASK)\n\t\t\tdev_warn(&indio_dev->dev, \"Overrun detected\\n\");\n\t\tregmap_update_bits(regmap, DFSDM_ICR(adc->fl_id),\n\t\t\t\t   DFSDM_ICR_CLRROVRF_MASK,\n\t\t\t\t   DFSDM_ICR_CLRROVRF_MASK);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic const struct iio_chan_spec_ext_info dfsdm_adc_audio_ext_info[] = {\n\t \n\t{\n\t\t.name = \"spi_clk_freq\",\n\t\t.shared = IIO_SHARED_BY_TYPE,\n\t\t.read = dfsdm_adc_audio_get_spiclk,\n\t\t.write = dfsdm_adc_audio_set_spiclk,\n\t},\n\t{},\n};\n\nstatic void stm32_dfsdm_dma_release(struct iio_dev *indio_dev)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\n\tif (adc->dma_chan) {\n\t\tdma_free_coherent(adc->dma_chan->device->dev,\n\t\t\t\t  DFSDM_DMA_BUFFER_SIZE,\n\t\t\t\t  adc->rx_buf, adc->dma_buf);\n\t\tdma_release_channel(adc->dma_chan);\n\t}\n}\n\nstatic int stm32_dfsdm_dma_request(struct device *dev,\n\t\t\t\t   struct iio_dev *indio_dev)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\n\tadc->dma_chan = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(adc->dma_chan)) {\n\t\tint ret = PTR_ERR(adc->dma_chan);\n\n\t\tadc->dma_chan = NULL;\n\t\treturn ret;\n\t}\n\n\tadc->rx_buf = dma_alloc_coherent(adc->dma_chan->device->dev,\n\t\t\t\t\t DFSDM_DMA_BUFFER_SIZE,\n\t\t\t\t\t &adc->dma_buf, GFP_KERNEL);\n\tif (!adc->rx_buf) {\n\t\tdma_release_channel(adc->dma_chan);\n\t\treturn -ENOMEM;\n\t}\n\n\tindio_dev->modes |= INDIO_BUFFER_SOFTWARE;\n\tindio_dev->setup_ops = &stm32_dfsdm_buffer_setup_ops;\n\n\treturn 0;\n}\n\nstatic int stm32_dfsdm_adc_chan_init_one(struct iio_dev *indio_dev,\n\t\t\t\t\t struct iio_chan_spec *ch)\n{\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\n\tret = stm32_dfsdm_channel_parse_of(adc->dfsdm, indio_dev, ch);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tch->type = IIO_VOLTAGE;\n\tch->indexed = 1;\n\n\t \n\tch->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\n\tch->info_mask_shared_by_all = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO) |\n\t\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ);\n\n\tif (adc->dev_data->type == DFSDM_AUDIO) {\n\t\tch->ext_info = dfsdm_adc_audio_ext_info;\n\t} else {\n\t\tch->scan_type.shift = 8;\n\t}\n\tch->scan_type.sign = 's';\n\tch->scan_type.realbits = 24;\n\tch->scan_type.storagebits = 32;\n\n\treturn stm32_dfsdm_chan_configure(adc->dfsdm,\n\t\t\t\t\t  &adc->dfsdm->ch_list[ch->channel]);\n}\n\nstatic int stm32_dfsdm_audio_init(struct device *dev, struct iio_dev *indio_dev)\n{\n\tstruct iio_chan_spec *ch;\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tstruct stm32_dfsdm_channel *d_ch;\n\tint ret;\n\n\tch = devm_kzalloc(&indio_dev->dev, sizeof(*ch), GFP_KERNEL);\n\tif (!ch)\n\t\treturn -ENOMEM;\n\n\tch->scan_index = 0;\n\n\tret = stm32_dfsdm_adc_chan_init_one(indio_dev, ch);\n\tif (ret < 0) {\n\t\tdev_err(&indio_dev->dev, \"Channels init failed\\n\");\n\t\treturn ret;\n\t}\n\tch->info_mask_separate = BIT(IIO_CHAN_INFO_SAMP_FREQ);\n\n\td_ch = &adc->dfsdm->ch_list[ch->channel];\n\tif (d_ch->src != DFSDM_CHANNEL_SPI_CLOCK_EXTERNAL)\n\t\tadc->spi_freq = adc->dfsdm->spi_master_freq;\n\n\tindio_dev->num_channels = 1;\n\tindio_dev->channels = ch;\n\n\treturn stm32_dfsdm_dma_request(dev, indio_dev);\n}\n\nstatic int stm32_dfsdm_adc_init(struct device *dev, struct iio_dev *indio_dev)\n{\n\tstruct iio_chan_spec *ch;\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tint num_ch;\n\tint ret, chan_idx;\n\n\tadc->oversamp = DFSDM_DEFAULT_OVERSAMPLING;\n\tret = stm32_dfsdm_compute_all_osrs(indio_dev, adc->oversamp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnum_ch = of_property_count_u32_elems(indio_dev->dev.of_node,\n\t\t\t\t\t     \"st,adc-channels\");\n\tif (num_ch < 0 || num_ch > adc->dfsdm->num_chs) {\n\t\tdev_err(&indio_dev->dev, \"Bad st,adc-channels\\n\");\n\t\treturn num_ch < 0 ? num_ch : -EINVAL;\n\t}\n\n\t \n\tadc->hwc = devm_iio_hw_consumer_alloc(&indio_dev->dev);\n\tif (IS_ERR(adc->hwc))\n\t\treturn -EPROBE_DEFER;\n\n\tch = devm_kcalloc(&indio_dev->dev, num_ch, sizeof(*ch),\n\t\t\t  GFP_KERNEL);\n\tif (!ch)\n\t\treturn -ENOMEM;\n\n\tfor (chan_idx = 0; chan_idx < num_ch; chan_idx++) {\n\t\tch[chan_idx].scan_index = chan_idx;\n\t\tret = stm32_dfsdm_adc_chan_init_one(indio_dev, &ch[chan_idx]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&indio_dev->dev, \"Channels init failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tindio_dev->num_channels = num_ch;\n\tindio_dev->channels = ch;\n\n\tinit_completion(&adc->completion);\n\n\t \n\tret = stm32_dfsdm_dma_request(dev, indio_dev);\n\tif (ret) {\n\t\tif (ret != -ENODEV)\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"DMA channel request failed with\\n\");\n\n\t\tdev_dbg(dev, \"No DMA support\\n\");\n\t\treturn 0;\n\t}\n\n\tret = iio_triggered_buffer_setup(indio_dev,\n\t\t\t\t\t &iio_pollfunc_store_time, NULL,\n\t\t\t\t\t &stm32_dfsdm_buffer_setup_ops);\n\tif (ret) {\n\t\tstm32_dfsdm_dma_release(indio_dev);\n\t\tdev_err(&indio_dev->dev, \"buffer setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tindio_dev->modes |= INDIO_HARDWARE_TRIGGERED;\n\n\treturn 0;\n}\n\nstatic const struct stm32_dfsdm_dev_data stm32h7_dfsdm_adc_data = {\n\t.type = DFSDM_IIO,\n\t.init = stm32_dfsdm_adc_init,\n};\n\nstatic const struct stm32_dfsdm_dev_data stm32h7_dfsdm_audio_data = {\n\t.type = DFSDM_AUDIO,\n\t.init = stm32_dfsdm_audio_init,\n};\n\nstatic const struct of_device_id stm32_dfsdm_adc_match[] = {\n\t{\n\t\t.compatible = \"st,stm32-dfsdm-adc\",\n\t\t.data = &stm32h7_dfsdm_adc_data,\n\t},\n\t{\n\t\t.compatible = \"st,stm32-dfsdm-dmic\",\n\t\t.data = &stm32h7_dfsdm_audio_data,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, stm32_dfsdm_adc_match);\n\nstatic int stm32_dfsdm_adc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct stm32_dfsdm_adc *adc;\n\tstruct device_node *np = dev->of_node;\n\tconst struct stm32_dfsdm_dev_data *dev_data;\n\tstruct iio_dev *iio;\n\tchar *name;\n\tint ret, irq, val;\n\n\tdev_data = of_device_get_match_data(dev);\n\tiio = devm_iio_device_alloc(dev, sizeof(*adc));\n\tif (!iio) {\n\t\tdev_err(dev, \"%s: Failed to allocate IIO\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tadc = iio_priv(iio);\n\tadc->dfsdm = dev_get_drvdata(dev->parent);\n\n\tiio->dev.of_node = np;\n\tiio->modes = INDIO_DIRECT_MODE;\n\n\tplatform_set_drvdata(pdev, iio);\n\n\tret = of_property_read_u32(dev->of_node, \"reg\", &adc->fl_id);\n\tif (ret != 0 || adc->fl_id >= adc->dfsdm->num_fls) {\n\t\tdev_err(dev, \"Missing or bad reg property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tname = devm_kzalloc(dev, sizeof(\"dfsdm-adc0\"), GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\tif (dev_data->type == DFSDM_AUDIO) {\n\t\tiio->info = &stm32_dfsdm_info_audio;\n\t\tsnprintf(name, sizeof(\"dfsdm-pdm0\"), \"dfsdm-pdm%d\", adc->fl_id);\n\t} else {\n\t\tiio->info = &stm32_dfsdm_info_adc;\n\t\tsnprintf(name, sizeof(\"dfsdm-adc0\"), \"dfsdm-adc%d\", adc->fl_id);\n\t}\n\tiio->name = name;\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, stm32_dfsdm_irq,\n\t\t\t       0, pdev->name, iio);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(dev->of_node, \"st,filter-order\", &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set filter order\\n\");\n\t\treturn ret;\n\t}\n\n\tadc->dfsdm->fl_list[adc->fl_id].ford = val;\n\n\tret = of_property_read_u32(dev->of_node, \"st,filter0-sync\", &val);\n\tif (!ret)\n\t\tadc->dfsdm->fl_list[adc->fl_id].sync_mode = val;\n\n\tadc->dev_data = dev_data;\n\tret = dev_data->init(dev, iio);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iio_device_register(iio);\n\tif (ret < 0)\n\t\tgoto err_cleanup;\n\n\tif (dev_data->type == DFSDM_AUDIO) {\n\t\tret = of_platform_populate(np, NULL, NULL, dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to find an audio DAI\\n\");\n\t\t\tgoto err_unregister;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_unregister:\n\tiio_device_unregister(iio);\nerr_cleanup:\n\tstm32_dfsdm_dma_release(iio);\n\n\treturn ret;\n}\n\nstatic int stm32_dfsdm_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\n\tif (adc->dev_data->type == DFSDM_AUDIO)\n\t\tof_platform_depopulate(&pdev->dev);\n\tiio_device_unregister(indio_dev);\n\tstm32_dfsdm_dma_release(indio_dev);\n\n\treturn 0;\n}\n\nstatic int stm32_dfsdm_adc_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\n\tif (iio_buffer_enabled(indio_dev))\n\t\tstm32_dfsdm_predisable(indio_dev);\n\n\treturn 0;\n}\n\nstatic int stm32_dfsdm_adc_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct stm32_dfsdm_adc *adc = iio_priv(indio_dev);\n\tconst struct iio_chan_spec *chan;\n\tstruct stm32_dfsdm_channel *ch;\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < indio_dev->num_channels; i++) {\n\t\tchan = indio_dev->channels + i;\n\t\tch = &adc->dfsdm->ch_list[chan->channel];\n\t\tret = stm32_dfsdm_chan_configure(adc->dfsdm, ch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (iio_buffer_enabled(indio_dev))\n\t\tstm32_dfsdm_postenable(indio_dev);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(stm32_dfsdm_adc_pm_ops,\n\t\t\t\tstm32_dfsdm_adc_suspend,\n\t\t\t\tstm32_dfsdm_adc_resume);\n\nstatic struct platform_driver stm32_dfsdm_adc_driver = {\n\t.driver = {\n\t\t.name = \"stm32-dfsdm-adc\",\n\t\t.of_match_table = stm32_dfsdm_adc_match,\n\t\t.pm = pm_sleep_ptr(&stm32_dfsdm_adc_pm_ops),\n\t},\n\t.probe = stm32_dfsdm_adc_probe,\n\t.remove = stm32_dfsdm_adc_remove,\n};\nmodule_platform_driver(stm32_dfsdm_adc_driver);\n\nMODULE_DESCRIPTION(\"STM32 sigma delta ADC\");\nMODULE_AUTHOR(\"Arnaud Pouliquen <arnaud.pouliquen@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}