{
  "module_name": "ad7280a.c",
  "hash_id": "b8c014821407d210b8b8f4717fcda21e7c3998b06a25887a297fe39cc9206da2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7280a.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/crc8.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n\n \n\n#define AD7280A_CELL_VOLTAGE_1_REG\t\t0x0   \n#define AD7280A_CELL_VOLTAGE_2_REG\t\t0x1   \n#define AD7280A_CELL_VOLTAGE_3_REG\t\t0x2   \n#define AD7280A_CELL_VOLTAGE_4_REG\t\t0x3   \n#define AD7280A_CELL_VOLTAGE_5_REG\t\t0x4   \n#define AD7280A_CELL_VOLTAGE_6_REG\t\t0x5   \n#define AD7280A_AUX_ADC_1_REG\t\t\t0x6   \n#define AD7280A_AUX_ADC_2_REG\t\t\t0x7   \n#define AD7280A_AUX_ADC_3_REG\t\t\t0x8   \n#define AD7280A_AUX_ADC_4_REG\t\t\t0x9   \n#define AD7280A_AUX_ADC_5_REG\t\t\t0xA   \n#define AD7280A_AUX_ADC_6_REG\t\t\t0xB   \n#define AD7280A_SELF_TEST_REG\t\t\t0xC   \n\n#define AD7280A_CTRL_HB_REG\t\t\t0xD   \n#define   AD7280A_CTRL_HB_CONV_INPUT_MSK\t\tGENMASK(7, 6)\n#define     AD7280A_CTRL_HB_CONV_INPUT_ALL\t\t\t0\n#define     AD7280A_CTRL_HB_CONV_INPUT_6CELL_AUX1_3_5\t\t1\n#define     AD7280A_CTRL_HB_CONV_INPUT_6CELL\t\t\t2\n#define     AD7280A_CTRL_HB_CONV_INPUT_SELF_TEST\t\t3\n#define   AD7280A_CTRL_HB_CONV_RREAD_MSK\t\tGENMASK(5, 4)\n#define     AD7280A_CTRL_HB_CONV_RREAD_ALL\t\t\t0\n#define     AD7280A_CTRL_HB_CONV_RREAD_6CELL_AUX1_3_5\t\t1\n#define     AD7280A_CTRL_HB_CONV_RREAD_6CELL\t\t\t2\n#define     AD7280A_CTRL_HB_CONV_RREAD_NO\t\t        3\n#define   AD7280A_CTRL_HB_CONV_START_MSK\t\tBIT(3)\n#define     AD7280A_CTRL_HB_CONV_START_CNVST\t\t\t0\n#define     AD7280A_CTRL_HB_CONV_START_CS\t\t\t1\n#define   AD7280A_CTRL_HB_CONV_AVG_MSK\t\t\tGENMASK(2, 1)\n#define     AD7280A_CTRL_HB_CONV_AVG_DIS\t\t\t0\n#define     AD7280A_CTRL_HB_CONV_AVG_2\t\t\t\t1\n#define     AD7280A_CTRL_HB_CONV_AVG_4\t\t\t        2\n#define     AD7280A_CTRL_HB_CONV_AVG_8\t\t\t        3\n#define   AD7280A_CTRL_HB_PWRDN_SW\t\t\tBIT(0)\n\n#define AD7280A_CTRL_LB_REG\t\t\t0xE   \n#define   AD7280A_CTRL_LB_SWRST_MSK\t\t\tBIT(7)\n#define   AD7280A_CTRL_LB_ACQ_TIME_MSK\t\t\tGENMASK(6, 5)\n#define     AD7280A_CTRL_LB_ACQ_TIME_400ns\t\t\t0\n#define     AD7280A_CTRL_LB_ACQ_TIME_800ns\t\t\t1\n#define     AD7280A_CTRL_LB_ACQ_TIME_1200ns\t\t\t2\n#define     AD7280A_CTRL_LB_ACQ_TIME_1600ns\t\t\t3\n#define   AD7280A_CTRL_LB_MUST_SET\t\t\tBIT(4)\n#define   AD7280A_CTRL_LB_THERMISTOR_MSK\t\tBIT(3)\n#define   AD7280A_CTRL_LB_LOCK_DEV_ADDR_MSK\t\tBIT(2)\n#define   AD7280A_CTRL_LB_INC_DEV_ADDR_MSK\t\tBIT(1)\n#define   AD7280A_CTRL_LB_DAISY_CHAIN_RB_MSK\t\tBIT(0)\n\n#define AD7280A_CELL_OVERVOLTAGE_REG\t\t0xF   \n#define AD7280A_CELL_UNDERVOLTAGE_REG\t\t0x10  \n#define AD7280A_AUX_ADC_OVERVOLTAGE_REG\t\t0x11  \n#define AD7280A_AUX_ADC_UNDERVOLTAGE_REG\t0x12  \n\n#define AD7280A_ALERT_REG\t\t\t0x13  \n#define   AD7280A_ALERT_REMOVE_MSK\t\t\tGENMASK(3, 0)\n#define     AD7280A_ALERT_REMOVE_AUX5\t\t\tBIT(0)\n#define     AD7280A_ALERT_REMOVE_AUX3_AUX5\t\tBIT(1)\n#define     AD7280A_ALERT_REMOVE_VIN5\t\t\tBIT(2)\n#define     AD7280A_ALERT_REMOVE_VIN4_VIN5\t\tBIT(3)\n#define   AD7280A_ALERT_GEN_STATIC_HIGH\t\t\tBIT(6)\n#define   AD7280A_ALERT_RELAY_SIG_CHAIN_DOWN\t\t(BIT(7) | BIT(6))\n\n#define AD7280A_CELL_BALANCE_REG\t\t0x14  \n#define  AD7280A_CELL_BALANCE_CHAN_BITMAP_MSK\t\tGENMASK(7, 2)\n#define AD7280A_CB1_TIMER_REG\t\t\t0x15  \n#define  AD7280A_CB_TIMER_VAL_MSK\t\t\tGENMASK(7, 3)\n#define AD7280A_CB2_TIMER_REG\t\t\t0x16  \n#define AD7280A_CB3_TIMER_REG\t\t\t0x17  \n#define AD7280A_CB4_TIMER_REG\t\t\t0x18  \n#define AD7280A_CB5_TIMER_REG\t\t\t0x19  \n#define AD7280A_CB6_TIMER_REG\t\t\t0x1A  \n#define AD7280A_PD_TIMER_REG\t\t\t0x1B  \n#define AD7280A_READ_REG\t\t\t0x1C  \n#define   AD7280A_READ_ADDR_MSK\t\t\t\tGENMASK(7, 2)\n#define AD7280A_CNVST_CTRL_REG\t\t\t0x1D  \n\n \n#define AD7280A_TRANS_WRITE_DEVADDR_MSK\t\tGENMASK(31, 27)\n#define AD7280A_TRANS_WRITE_ADDR_MSK\t\tGENMASK(26, 21)\n#define AD7280A_TRANS_WRITE_VAL_MSK\t\tGENMASK(20, 13)\n#define AD7280A_TRANS_WRITE_ALL_MSK\t\tBIT(12)\n#define AD7280A_TRANS_WRITE_CRC_MSK\t\tGENMASK(10, 3)\n#define AD7280A_TRANS_WRITE_RES_PATTERN\t\t0x2\n\n \n#define AD7280A_TRANS_READ_DEVADDR_MSK\t\tGENMASK(31, 27)\n#define AD7280A_TRANS_READ_CONV_CHANADDR_MSK\tGENMASK(26, 23)\n#define AD7280A_TRANS_READ_CONV_DATA_MSK\tGENMASK(22, 11)\n#define AD7280A_TRANS_READ_REG_REGADDR_MSK\tGENMASK(26, 21)\n#define AD7280A_TRANS_READ_REG_DATA_MSK\t\tGENMASK(20, 13)\n#define AD7280A_TRANS_READ_WRITE_ACK_MSK\tBIT(10)\n#define AD7280A_TRANS_READ_CRC_MSK\t\tGENMASK(9, 2)\n\n \n#define AD7280A_ALL_CELLS\t\t\t\t(0xAD << 16)\n\n#define AD7280A_MAX_SPI_CLK_HZ\t\t700000  \n#define AD7280A_MAX_CHAIN\t\t8\n#define AD7280A_CELLS_PER_DEV\t\t6\n#define AD7280A_BITS\t\t\t12\n#define AD7280A_NUM_CH\t\t\t(AD7280A_AUX_ADC_6_REG - \\\n\t\t\t\t\tAD7280A_CELL_VOLTAGE_1_REG + 1)\n\n#define AD7280A_CALC_VOLTAGE_CHAN_NUM(d, c) (((d) * AD7280A_CELLS_PER_DEV) + \\\n\t\t\t\t\t     (c))\n#define AD7280A_CALC_TEMP_CHAN_NUM(d, c)    (((d) * AD7280A_CELLS_PER_DEV) + \\\n\t\t\t\t\t     (c) - AD7280A_CELLS_PER_DEV)\n\n#define AD7280A_DEVADDR_MASTER\t\t0\n#define AD7280A_DEVADDR_ALL\t\t0x1F\n\nstatic const unsigned short ad7280a_n_avg[4] = {1, 2, 4, 8};\nstatic const unsigned short ad7280a_t_acq_ns[4] = {470, 1030, 1510, 1945};\n\n \nstatic unsigned int ad7280a_devaddr(unsigned int addr)\n{\n\treturn ((addr & 0x1) << 4) |\n\t       ((addr & 0x2) << 2) |\n\t       (addr & 0x4) |\n\t       ((addr & 0x8) >> 2) |\n\t       ((addr & 0x10) >> 4);\n}\n\n \n#define AD7280A_READ_TXVAL\t0xF800030A\n\n \n#define POLYNOM\t\t0x2F\n\nstruct ad7280_state {\n\tstruct spi_device\t\t*spi;\n\tstruct iio_chan_spec\t\t*channels;\n\tunsigned int\t\t\tchain_last_alert_ignore;\n\tbool\t\t\t\tthermistor_term_en;\n\tint\t\t\t\tslave_num;\n\tint\t\t\t\tscan_cnt;\n\tint\t\t\t\treadback_delay_us;\n\tunsigned char\t\t\tcrc_tab[CRC8_TABLE_SIZE];\n\tu8\t\t\t\toversampling_ratio;\n\tu8\t\t\t\tacquisition_time;\n\tunsigned char\t\t\tctrl_lb;\n\tunsigned char\t\t\tcell_threshhigh;\n\tunsigned char\t\t\tcell_threshlow;\n\tunsigned char\t\t\taux_threshhigh;\n\tunsigned char\t\t\taux_threshlow;\n\tunsigned char\t\t\tcb_mask[AD7280A_MAX_CHAIN];\n\tstruct mutex\t\t\tlock;  \n\n\t__be32\t\t\t\ttx __aligned(IIO_DMA_MINALIGN);\n\t__be32\t\t\t\trx;\n};\n\nstatic unsigned char ad7280_calc_crc8(unsigned char *crc_tab, unsigned int val)\n{\n\tunsigned char crc;\n\n\tcrc = crc_tab[val >> 16 & 0xFF];\n\tcrc = crc_tab[crc ^ (val >> 8 & 0xFF)];\n\n\treturn crc ^ (val & 0xFF);\n}\n\nstatic int ad7280_check_crc(struct ad7280_state *st, unsigned int val)\n{\n\tunsigned char crc = ad7280_calc_crc8(st->crc_tab, val >> 10);\n\n\tif (crc != ((val >> 2) & 0xFF))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \n\nstatic void ad7280_delay(struct ad7280_state *st)\n{\n\tif (st->readback_delay_us < 50)\n\t\tudelay(st->readback_delay_us);\n\telse\n\t\tusleep_range(250, 500);\n}\n\nstatic int __ad7280_read32(struct ad7280_state *st, unsigned int *val)\n{\n\tint ret;\n\tstruct spi_transfer t = {\n\t\t.tx_buf\t= &st->tx,\n\t\t.rx_buf = &st->rx,\n\t\t.len = sizeof(st->tx),\n\t};\n\n\tst->tx = cpu_to_be32(AD7280A_READ_TXVAL);\n\n\tret = spi_sync_transfer(st->spi, &t, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = be32_to_cpu(st->rx);\n\n\treturn 0;\n}\n\nstatic int ad7280_write(struct ad7280_state *st, unsigned int devaddr,\n\t\t\tunsigned int addr, bool all, unsigned int val)\n{\n\tunsigned int reg = FIELD_PREP(AD7280A_TRANS_WRITE_DEVADDR_MSK, devaddr) |\n\t\tFIELD_PREP(AD7280A_TRANS_WRITE_ADDR_MSK, addr) |\n\t\tFIELD_PREP(AD7280A_TRANS_WRITE_VAL_MSK, val) |\n\t\tFIELD_PREP(AD7280A_TRANS_WRITE_ALL_MSK, all);\n\n\treg |= FIELD_PREP(AD7280A_TRANS_WRITE_CRC_MSK,\n\t\t\tad7280_calc_crc8(st->crc_tab, reg >> 11));\n\t \n\treg |= AD7280A_TRANS_WRITE_RES_PATTERN;\n\n\tst->tx = cpu_to_be32(reg);\n\n\treturn spi_write(st->spi, &st->tx, sizeof(st->tx));\n}\n\nstatic int ad7280_read_reg(struct ad7280_state *st, unsigned int devaddr,\n\t\t\t   unsigned int addr)\n{\n\tint ret;\n\tunsigned int tmp;\n\n\t \n\tret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CTRL_HB_REG, 1,\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_INPUT_MSK,\n\t\t\t\t      AD7280A_CTRL_HB_CONV_INPUT_ALL) |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_RREAD_MSK,\n\t\t\t\t      AD7280A_CTRL_HB_CONV_RREAD_NO) |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_AVG_MSK,\n\t\t\t\t      st->oversampling_ratio));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ad7280_write(st, devaddr, AD7280A_CTRL_HB_REG, 0,\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_INPUT_MSK,\n\t\t\t\t      AD7280A_CTRL_HB_CONV_INPUT_ALL) |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_RREAD_MSK,\n\t\t\t\t      AD7280A_CTRL_HB_CONV_RREAD_ALL) |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_AVG_MSK,\n\t\t\t\t      st->oversampling_ratio));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ad7280_write(st, devaddr, AD7280A_READ_REG, 0,\n\t\t\t   FIELD_PREP(AD7280A_READ_ADDR_MSK, addr));\n\tif (ret)\n\t\treturn ret;\n\n\tret = __ad7280_read32(st, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ad7280_check_crc(st, tmp))\n\t\treturn -EIO;\n\n\tif ((FIELD_GET(AD7280A_TRANS_READ_DEVADDR_MSK, tmp) != devaddr) ||\n\t    (FIELD_GET(AD7280A_TRANS_READ_REG_REGADDR_MSK, tmp) != addr))\n\t\treturn -EFAULT;\n\n\treturn FIELD_GET(AD7280A_TRANS_READ_REG_DATA_MSK, tmp);\n}\n\nstatic int ad7280_read_channel(struct ad7280_state *st, unsigned int devaddr,\n\t\t\t       unsigned int addr)\n{\n\tint ret;\n\tunsigned int tmp;\n\n\tret = ad7280_write(st, devaddr, AD7280A_READ_REG, 0,\n\t\t\t   FIELD_PREP(AD7280A_READ_ADDR_MSK, addr));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CTRL_HB_REG, 1,\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_INPUT_MSK,\n\t\t\t\t      AD7280A_CTRL_HB_CONV_INPUT_ALL) |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_RREAD_MSK,\n\t\t\t\t      AD7280A_CTRL_HB_CONV_RREAD_NO) |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_AVG_MSK,\n\t\t\t\t      st->oversampling_ratio));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad7280_write(st, devaddr, AD7280A_CTRL_HB_REG, 0,\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_INPUT_MSK,\n\t\t\t\t      AD7280A_CTRL_HB_CONV_INPUT_ALL) |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_RREAD_MSK,\n\t\t\t\t      AD7280A_CTRL_HB_CONV_RREAD_ALL) |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_START_MSK,\n\t\t\t\t      AD7280A_CTRL_HB_CONV_START_CS) |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_AVG_MSK,\n\t\t\t\t      st->oversampling_ratio));\n\tif (ret)\n\t\treturn ret;\n\n\tad7280_delay(st);\n\n\tret = __ad7280_read32(st, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ad7280_check_crc(st, tmp))\n\t\treturn -EIO;\n\n\tif ((FIELD_GET(AD7280A_TRANS_READ_DEVADDR_MSK, tmp) != devaddr) ||\n\t    (FIELD_GET(AD7280A_TRANS_READ_CONV_CHANADDR_MSK, tmp) != addr))\n\t\treturn -EFAULT;\n\n\treturn FIELD_GET(AD7280A_TRANS_READ_CONV_DATA_MSK, tmp);\n}\n\nstatic int ad7280_read_all_channels(struct ad7280_state *st, unsigned int cnt,\n\t\t\t\t    unsigned int *array)\n{\n\tint i, ret;\n\tunsigned int tmp, sum = 0;\n\n\tret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_READ_REG, 1,\n\t\t\t   AD7280A_CELL_VOLTAGE_1_REG << 2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CTRL_HB_REG, 1,\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_INPUT_MSK,\n\t\t\t\t      AD7280A_CTRL_HB_CONV_INPUT_ALL) |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_RREAD_MSK,\n\t\t\t\t      AD7280A_CTRL_HB_CONV_RREAD_ALL) |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_START_MSK,\n\t\t\t\t      AD7280A_CTRL_HB_CONV_START_CS) |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_HB_CONV_AVG_MSK,\n\t\t\t\t      st->oversampling_ratio));\n\tif (ret)\n\t\treturn ret;\n\n\tad7280_delay(st);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tret = __ad7280_read32(st, &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (ad7280_check_crc(st, tmp))\n\t\t\treturn -EIO;\n\n\t\tif (array)\n\t\t\tarray[i] = tmp;\n\t\t \n\t\tif (FIELD_GET(AD7280A_TRANS_READ_CONV_CHANADDR_MSK, tmp) <=\n\t\t    AD7280A_CELL_VOLTAGE_6_REG)\n\t\t\tsum += FIELD_GET(AD7280A_TRANS_READ_CONV_DATA_MSK, tmp);\n\t}\n\n\treturn sum;\n}\n\nstatic void ad7280_sw_power_down(void *data)\n{\n\tstruct ad7280_state *st = data;\n\n\tad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CTRL_HB_REG, 1,\n\t\t     AD7280A_CTRL_HB_PWRDN_SW |\n\t\t     FIELD_PREP(AD7280A_CTRL_HB_CONV_AVG_MSK, st->oversampling_ratio));\n}\n\nstatic int ad7280_chain_setup(struct ad7280_state *st)\n{\n\tunsigned int val, n;\n\tint ret;\n\n\tret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CTRL_LB_REG, 1,\n\t\t\t   FIELD_PREP(AD7280A_CTRL_LB_DAISY_CHAIN_RB_MSK, 1) |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_LB_LOCK_DEV_ADDR_MSK, 1) |\n\t\t\t   AD7280A_CTRL_LB_MUST_SET |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_LB_SWRST_MSK, 1) |\n\t\t\t   st->ctrl_lb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CTRL_LB_REG, 1,\n\t\t\t   FIELD_PREP(AD7280A_CTRL_LB_DAISY_CHAIN_RB_MSK, 1) |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_LB_LOCK_DEV_ADDR_MSK, 1) |\n\t\t\t   AD7280A_CTRL_LB_MUST_SET |\n\t\t\t   FIELD_PREP(AD7280A_CTRL_LB_SWRST_MSK, 0) |\n\t\t\t   st->ctrl_lb);\n\tif (ret)\n\t\tgoto error_power_down;\n\n\tret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_READ_REG, 1,\n\t\t\t   FIELD_PREP(AD7280A_READ_ADDR_MSK, AD7280A_CTRL_LB_REG));\n\tif (ret)\n\t\tgoto error_power_down;\n\n\tfor (n = 0; n <= AD7280A_MAX_CHAIN; n++) {\n\t\tret = __ad7280_read32(st, &val);\n\t\tif (ret)\n\t\t\tgoto error_power_down;\n\n\t\tif (val == 0)\n\t\t\treturn n - 1;\n\n\t\tif (ad7280_check_crc(st, val)) {\n\t\t\tret = -EIO;\n\t\t\tgoto error_power_down;\n\t\t}\n\n\t\tif (n != ad7280a_devaddr(FIELD_GET(AD7280A_TRANS_READ_DEVADDR_MSK, val))) {\n\t\t\tret = -EIO;\n\t\t\tgoto error_power_down;\n\t\t}\n\t}\n\tret = -EFAULT;\n\nerror_power_down:\n\tad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CTRL_HB_REG, 1,\n\t\t     AD7280A_CTRL_HB_PWRDN_SW |\n\t\t     FIELD_PREP(AD7280A_CTRL_HB_CONV_AVG_MSK, st->oversampling_ratio));\n\n\treturn ret;\n}\n\nstatic ssize_t ad7280_show_balance_sw(struct iio_dev *indio_dev,\n\t\t\t\t      uintptr_t private,\n\t\t\t\t      const struct iio_chan_spec *chan, char *buf)\n{\n\tstruct ad7280_state *st = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  !!(st->cb_mask[chan->address >> 8] &\n\t\t\t     BIT(chan->address & 0xFF)));\n}\n\nstatic ssize_t ad7280_store_balance_sw(struct iio_dev *indio_dev,\n\t\t\t\t       uintptr_t private,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       const char *buf, size_t len)\n{\n\tstruct ad7280_state *st = iio_priv(indio_dev);\n\tunsigned int devaddr, ch;\n\tbool readin;\n\tint ret;\n\n\tret = kstrtobool(buf, &readin);\n\tif (ret)\n\t\treturn ret;\n\n\tdevaddr = chan->address >> 8;\n\tch = chan->address & 0xFF;\n\n\tmutex_lock(&st->lock);\n\tif (readin)\n\t\tst->cb_mask[devaddr] |= BIT(ch);\n\telse\n\t\tst->cb_mask[devaddr] &= ~BIT(ch);\n\n\tret = ad7280_write(st, devaddr, AD7280A_CELL_BALANCE_REG, 0,\n\t\t\t   FIELD_PREP(AD7280A_CELL_BALANCE_CHAN_BITMAP_MSK,\n\t\t\t\t      st->cb_mask[devaddr]));\n\tmutex_unlock(&st->lock);\n\n\treturn ret ? ret : len;\n}\n\nstatic ssize_t ad7280_show_balance_timer(struct iio_dev *indio_dev,\n\t\t\t\t\t uintptr_t private,\n\t\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t\t char *buf)\n{\n\tstruct ad7280_state *st = iio_priv(indio_dev);\n\tunsigned int msecs;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = ad7280_read_reg(st, chan->address >> 8,\n\t\t\t      (chan->address & 0xFF) + AD7280A_CB1_TIMER_REG);\n\tmutex_unlock(&st->lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsecs = FIELD_GET(AD7280A_CB_TIMER_VAL_MSK, ret) * 71500;\n\n\treturn sysfs_emit(buf, \"%u.%u\\n\", msecs / 1000, msecs % 1000);\n}\n\nstatic ssize_t ad7280_store_balance_timer(struct iio_dev *indio_dev,\n\t\t\t\t\t  uintptr_t private,\n\t\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct ad7280_state *st = iio_priv(indio_dev);\n\tint val, val2;\n\tint ret;\n\n\tret = iio_str_to_fixpoint(buf, 1000, &val, &val2);\n\tif (ret)\n\t\treturn ret;\n\n\tval = val * 1000 + val2;\n\tval /= 71500;\n\n\tif (val > 31)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&st->lock);\n\tret = ad7280_write(st, chan->address >> 8,\n\t\t\t   (chan->address & 0xFF) + AD7280A_CB1_TIMER_REG, 0,\n\t\t\t   FIELD_PREP(AD7280A_CB_TIMER_VAL_MSK, val));\n\tmutex_unlock(&st->lock);\n\n\treturn ret ? ret : len;\n}\n\nstatic const struct iio_chan_spec_ext_info ad7280_cell_ext_info[] = {\n\t{\n\t\t.name = \"balance_switch_en\",\n\t\t.read = ad7280_show_balance_sw,\n\t\t.write = ad7280_store_balance_sw,\n\t\t.shared = IIO_SEPARATE,\n\t}, {\n\t\t.name = \"balance_switch_timer\",\n\t\t.read = ad7280_show_balance_timer,\n\t\t.write = ad7280_store_balance_timer,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\t{}\n};\n\nstatic const struct iio_event_spec ad7280_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_shared_by_type = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_shared_by_type = BIT(IIO_EV_INFO_VALUE),\n\t},\n};\n\nstatic void ad7280_voltage_channel_init(struct iio_chan_spec *chan, int i,\n\t\t\t\t\tbool irq_present)\n{\n\tchan->type = IIO_VOLTAGE;\n\tchan->differential = 1;\n\tchan->channel = i;\n\tchan->channel2 = chan->channel + 1;\n\tif (irq_present) {\n\t\tchan->event_spec = ad7280_events;\n\t\tchan->num_event_specs = ARRAY_SIZE(ad7280_events);\n\t}\n\tchan->ext_info = ad7280_cell_ext_info;\n}\n\nstatic void ad7280_temp_channel_init(struct iio_chan_spec *chan, int i,\n\t\t\t\t     bool irq_present)\n{\n\tchan->type = IIO_TEMP;\n\tchan->channel = i;\n\tif (irq_present) {\n\t\tchan->event_spec = ad7280_events;\n\t\tchan->num_event_specs = ARRAY_SIZE(ad7280_events);\n\t}\n}\n\nstatic void ad7280_common_fields_init(struct iio_chan_spec *chan, int addr,\n\t\t\t\t      int cnt)\n{\n\tchan->indexed = 1;\n\tchan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\n\tchan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);\n\tchan->info_mask_shared_by_all = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO);\n\tchan->address = addr;\n\tchan->scan_index = cnt;\n\tchan->scan_type.sign = 'u';\n\tchan->scan_type.realbits = 12;\n\tchan->scan_type.storagebits = 32;\n}\n\nstatic void ad7280_total_voltage_channel_init(struct iio_chan_spec *chan,\n\t\t\t\t\t      int cnt, int dev)\n{\n\tchan->type = IIO_VOLTAGE;\n\tchan->differential = 1;\n\tchan->channel = 0;\n\tchan->channel2 = dev * AD7280A_CELLS_PER_DEV;\n\tchan->address = AD7280A_ALL_CELLS;\n\tchan->indexed = 1;\n\tchan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\n\tchan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);\n\tchan->scan_index = cnt;\n\tchan->scan_type.sign = 'u';\n\tchan->scan_type.realbits = 32;\n\tchan->scan_type.storagebits = 32;\n}\n\nstatic void ad7280_init_dev_channels(struct ad7280_state *st, int dev, int *cnt,\n\t\t\t\t     bool irq_present)\n{\n\tint addr, ch, i;\n\tstruct iio_chan_spec *chan;\n\n\tfor (ch = AD7280A_CELL_VOLTAGE_1_REG; ch <= AD7280A_AUX_ADC_6_REG; ch++) {\n\t\tchan = &st->channels[*cnt];\n\n\t\tif (ch < AD7280A_AUX_ADC_1_REG) {\n\t\t\ti = AD7280A_CALC_VOLTAGE_CHAN_NUM(dev, ch);\n\t\t\tad7280_voltage_channel_init(chan, i, irq_present);\n\t\t} else {\n\t\t\ti = AD7280A_CALC_TEMP_CHAN_NUM(dev, ch);\n\t\t\tad7280_temp_channel_init(chan, i, irq_present);\n\t\t}\n\n\t\taddr = ad7280a_devaddr(dev) << 8 | ch;\n\t\tad7280_common_fields_init(chan, addr, *cnt);\n\n\t\t(*cnt)++;\n\t}\n}\n\nstatic int ad7280_channel_init(struct ad7280_state *st, bool irq_present)\n{\n\tint dev, cnt = 0;\n\n\tst->channels = devm_kcalloc(&st->spi->dev, (st->slave_num + 1) * 12 + 1,\n\t\t\t\t    sizeof(*st->channels), GFP_KERNEL);\n\tif (!st->channels)\n\t\treturn -ENOMEM;\n\n\tfor (dev = 0; dev <= st->slave_num; dev++)\n\t\tad7280_init_dev_channels(st, dev, &cnt, irq_present);\n\n\tad7280_total_voltage_channel_init(&st->channels[cnt], cnt, dev);\n\n\treturn cnt + 1;\n}\n\nstatic int ad7280a_read_thresh(struct iio_dev *indio_dev,\n\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t       enum iio_event_type type,\n\t\t\t       enum iio_event_direction dir,\n\t\t\t       enum iio_event_info info, int *val, int *val2)\n{\n\tstruct ad7280_state *st = iio_priv(indio_dev);\n\n\tswitch (chan->type) {\n\tcase IIO_VOLTAGE:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\t*val = 1000 + (st->cell_threshhigh * 1568L) / 100;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\t*val = 1000 + (st->cell_threshlow * 1568L) / 100;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_TEMP:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\t*val = ((st->aux_threshhigh) * 196L) / 10;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\t*val = (st->aux_threshlow * 196L) / 10;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad7280a_write_thresh(struct iio_dev *indio_dev,\n\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\tenum iio_event_type type,\n\t\t\t\tenum iio_event_direction dir,\n\t\t\t\tenum iio_event_info info,\n\t\t\t\tint val, int val2)\n{\n\tstruct ad7280_state *st = iio_priv(indio_dev);\n\tunsigned int addr;\n\tlong value;\n\tint ret;\n\n\tif (val2 != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&st->lock);\n\tswitch (chan->type) {\n\tcase IIO_VOLTAGE:\n\t\tvalue = ((val - 1000) * 100) / 1568;  \n\t\tvalue = clamp(value, 0L, 0xFFL);\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\taddr = AD7280A_CELL_OVERVOLTAGE_REG;\n\t\t\tret = ad7280_write(st, AD7280A_DEVADDR_MASTER, addr,\n\t\t\t\t\t   1, value);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tst->cell_threshhigh = value;\n\t\t\tbreak;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\taddr = AD7280A_CELL_UNDERVOLTAGE_REG;\n\t\t\tret = ad7280_write(st, AD7280A_DEVADDR_MASTER, addr,\n\t\t\t\t\t   1, value);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tst->cell_threshlow = value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tbreak;\n\tcase IIO_TEMP:\n\t\tvalue = (val * 10) / 196;  \n\t\tvalue = clamp(value, 0L, 0xFFL);\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\taddr = AD7280A_AUX_ADC_OVERVOLTAGE_REG;\n\t\t\tret = ad7280_write(st, AD7280A_DEVADDR_MASTER, addr,\n\t\t\t\t\t   1, value);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tst->aux_threshhigh = value;\n\t\t\tbreak;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\taddr = AD7280A_AUX_ADC_UNDERVOLTAGE_REG;\n\t\t\tret = ad7280_write(st, AD7280A_DEVADDR_MASTER, addr,\n\t\t\t\t\t   1, value);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tst->aux_threshlow = value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\nerr_unlock:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t ad7280_event_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct ad7280_state *st = iio_priv(indio_dev);\n\tunsigned int *channels;\n\tint i, ret;\n\n\tchannels = kcalloc(st->scan_cnt, sizeof(*channels), GFP_KERNEL);\n\tif (!channels)\n\t\treturn IRQ_HANDLED;\n\n\tret = ad7280_read_all_channels(st, st->scan_cnt, channels);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < st->scan_cnt; i++) {\n\t\tunsigned int val;\n\n\t\tval = FIELD_GET(AD7280A_TRANS_READ_CONV_DATA_MSK, channels[i]);\n\t\tif (FIELD_GET(AD7280A_TRANS_READ_CONV_CHANADDR_MSK, channels[i]) <=\n\t\t    AD7280A_CELL_VOLTAGE_6_REG) {\n\t\t\tif (val >= st->cell_threshhigh) {\n\t\t\t\tu64 tmp = IIO_EVENT_CODE(IIO_VOLTAGE, 1, 0,\n\t\t\t\t\t\t\t IIO_EV_DIR_RISING,\n\t\t\t\t\t\t\t IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t\t 0, 0, 0);\n\t\t\t\tiio_push_event(indio_dev, tmp,\n\t\t\t\t\t       iio_get_time_ns(indio_dev));\n\t\t\t} else if (val <= st->cell_threshlow) {\n\t\t\t\tu64 tmp = IIO_EVENT_CODE(IIO_VOLTAGE, 1, 0,\n\t\t\t\t\t\t\t IIO_EV_DIR_FALLING,\n\t\t\t\t\t\t\t IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t\t 0, 0, 0);\n\t\t\t\tiio_push_event(indio_dev, tmp,\n\t\t\t\t\t       iio_get_time_ns(indio_dev));\n\t\t\t}\n\t\t} else {\n\t\t\tif (val >= st->aux_threshhigh) {\n\t\t\t\tu64 tmp = IIO_UNMOD_EVENT_CODE(IIO_TEMP, 0,\n\t\t\t\t\t\t\tIIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t\tIIO_EV_DIR_RISING);\n\t\t\t\tiio_push_event(indio_dev, tmp,\n\t\t\t\t\t       iio_get_time_ns(indio_dev));\n\t\t\t} else if (val <= st->aux_threshlow) {\n\t\t\t\tu64 tmp = IIO_UNMOD_EVENT_CODE(IIO_TEMP, 0,\n\t\t\t\t\t\t\tIIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t\tIIO_EV_DIR_FALLING);\n\t\t\t\tiio_push_event(indio_dev, tmp,\n\t\t\t\t\t       iio_get_time_ns(indio_dev));\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tkfree(channels);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ad7280_update_delay(struct ad7280_state *st)\n{\n\t \n\n\tst->readback_delay_us =\n\t\t((ad7280a_t_acq_ns[st->acquisition_time & 0x3] + 720) *\n\t\t\t(AD7280A_NUM_CH * ad7280a_n_avg[st->oversampling_ratio & 0x3])) -\n\t\tad7280a_t_acq_ns[st->acquisition_time & 0x3] + st->slave_num * 250;\n\n\t \n\tst->readback_delay_us = DIV_ROUND_UP(st->readback_delay_us, 1000);\n\tst->readback_delay_us += 5;  \n}\n\nstatic int ad7280_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tstruct ad7280_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&st->lock);\n\t\tif (chan->address == AD7280A_ALL_CELLS)\n\t\t\tret = ad7280_read_all_channels(st, st->scan_cnt, NULL);\n\t\telse\n\t\t\tret = ad7280_read_channel(st, chan->address >> 8,\n\t\t\t\t\t\t  chan->address & 0xFF);\n\t\tmutex_unlock(&st->lock);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif ((chan->address & 0xFF) <= AD7280A_CELL_VOLTAGE_6_REG)\n\t\t\t*val = 4000;\n\t\telse\n\t\t\t*val = 5000;\n\n\t\t*val2 = AD7280A_BITS;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t*val = ad7280a_n_avg[st->oversampling_ratio];\n\t\treturn IIO_VAL_INT;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ad7280_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct ad7280_state *st = iio_priv(indio_dev);\n\tint i;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tif (val2 != 0)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < ARRAY_SIZE(ad7280a_n_avg); i++) {\n\t\t\tif (val == ad7280a_n_avg[i]) {\n\t\t\t\tst->oversampling_ratio = i;\n\t\t\t\tad7280_update_delay(st);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn -EINVAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info ad7280_info = {\n\t.read_raw = ad7280_read_raw,\n\t.write_raw = ad7280_write_raw,\n\t.read_event_value = &ad7280a_read_thresh,\n\t.write_event_value = &ad7280a_write_thresh,\n};\n\nstatic const struct iio_info ad7280_info_no_irq = {\n\t.read_raw = ad7280_read_raw,\n\t.write_raw = ad7280_write_raw,\n};\n\nstatic int ad7280_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct ad7280_state *st;\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tspi_set_drvdata(spi, indio_dev);\n\tst->spi = spi;\n\tmutex_init(&st->lock);\n\n\tst->thermistor_term_en =\n\t\tdevice_property_read_bool(dev, \"adi,thermistor-termination\");\n\n\tif (device_property_present(dev, \"adi,acquisition-time-ns\")) {\n\t\tu32 val;\n\n\t\tret = device_property_read_u32(dev, \"adi,acquisition-time-ns\", &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswitch (val) {\n\t\tcase 400:\n\t\t\tst->acquisition_time = AD7280A_CTRL_LB_ACQ_TIME_400ns;\n\t\t\tbreak;\n\t\tcase 800:\n\t\t\tst->acquisition_time = AD7280A_CTRL_LB_ACQ_TIME_800ns;\n\t\t\tbreak;\n\t\tcase 1200:\n\t\t\tst->acquisition_time = AD7280A_CTRL_LB_ACQ_TIME_1200ns;\n\t\t\tbreak;\n\t\tcase 1600:\n\t\t\tst->acquisition_time = AD7280A_CTRL_LB_ACQ_TIME_1600ns;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Firmware provided acquisition time is invalid\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tst->acquisition_time = AD7280A_CTRL_LB_ACQ_TIME_400ns;\n\t}\n\n\t \n\tif (device_property_present(dev, \"adi,voltage-alert-last-chan\")) {\n\t\tu32 val;\n\n\t\tret = device_property_read_u32(dev, \"adi,voltage-alert-last-chan\", &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswitch (val) {\n\t\tcase 3:\n\t\t\tst->chain_last_alert_ignore |= AD7280A_ALERT_REMOVE_VIN4_VIN5;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tst->chain_last_alert_ignore |= AD7280A_ALERT_REMOVE_VIN5;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev,\n\t\t\t\t\"Firmware provided last voltage alert channel invalid\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tcrc8_populate_msb(st->crc_tab, POLYNOM);\n\n\tst->spi->max_speed_hz = AD7280A_MAX_SPI_CLK_HZ;\n\tst->spi->mode = SPI_MODE_1;\n\tspi_setup(st->spi);\n\n\tst->ctrl_lb = FIELD_PREP(AD7280A_CTRL_LB_ACQ_TIME_MSK, st->acquisition_time) |\n\t\tFIELD_PREP(AD7280A_CTRL_LB_THERMISTOR_MSK, st->thermistor_term_en);\n\tst->oversampling_ratio = 0;  \n\n\tret = ad7280_chain_setup(st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->slave_num = ret;\n\tst->scan_cnt = (st->slave_num + 1) * AD7280A_NUM_CH;\n\tst->cell_threshhigh = 0xFF;\n\tst->aux_threshhigh = 0xFF;\n\n\tret = devm_add_action_or_reset(dev, ad7280_sw_power_down, st);\n\tif (ret)\n\t\treturn ret;\n\n\tad7280_update_delay(st);\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = ad7280_channel_init(st, spi->irq > 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tindio_dev->num_channels = ret;\n\tindio_dev->channels = st->channels;\n\tif (spi->irq > 0) {\n\t\tret = ad7280_write(st, AD7280A_DEVADDR_MASTER,\n\t\t\t\t   AD7280A_ALERT_REG, 1,\n\t\t\t\t   AD7280A_ALERT_RELAY_SIG_CHAIN_DOWN);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ad7280_write(st, ad7280a_devaddr(st->slave_num),\n\t\t\t\t   AD7280A_ALERT_REG, 0,\n\t\t\t\t   AD7280A_ALERT_GEN_STATIC_HIGH |\n\t\t\t\t   FIELD_PREP(AD7280A_ALERT_REMOVE_MSK,\n\t\t\t\t\t      st->chain_last_alert_ignore));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_request_threaded_irq(dev, spi->irq,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tad7280_event_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tindio_dev->name,\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tindio_dev->info = &ad7280_info;\n\t} else {\n\t\tindio_dev->info = &ad7280_info_no_irq;\n\t}\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad7280_id[] = {\n\t{\"ad7280a\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad7280_id);\n\nstatic struct spi_driver ad7280_driver = {\n\t.driver = {\n\t\t.name\t= \"ad7280\",\n\t},\n\t.probe\t\t= ad7280_probe,\n\t.id_table\t= ad7280_id,\n};\nmodule_spi_driver(ad7280_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7280A\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}