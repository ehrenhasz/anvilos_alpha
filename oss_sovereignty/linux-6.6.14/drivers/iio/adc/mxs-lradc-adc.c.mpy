{
  "module_name": "mxs-lradc-adc.c",
  "hash_id": "10b9b8363700403569d81ca119205be7560d0417c44949f53dae01f02ba00919",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/mxs-lradc-adc.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/mxs-lradc.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/sysfs.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/sysfs.h>\n\n \n#define LRADC_DELAY_TIMER_PER\t200\n#define LRADC_DELAY_TIMER_LOOP\t5\n\n#define VREF_MV_BASE 1850\n\nstatic const char *mx23_lradc_adc_irq_names[] = {\n\t\"mxs-lradc-channel0\",\n\t\"mxs-lradc-channel1\",\n\t\"mxs-lradc-channel2\",\n\t\"mxs-lradc-channel3\",\n\t\"mxs-lradc-channel4\",\n\t\"mxs-lradc-channel5\",\n};\n\nstatic const char *mx28_lradc_adc_irq_names[] = {\n\t\"mxs-lradc-thresh0\",\n\t\"mxs-lradc-thresh1\",\n\t\"mxs-lradc-channel0\",\n\t\"mxs-lradc-channel1\",\n\t\"mxs-lradc-channel2\",\n\t\"mxs-lradc-channel3\",\n\t\"mxs-lradc-channel4\",\n\t\"mxs-lradc-channel5\",\n\t\"mxs-lradc-button0\",\n\t\"mxs-lradc-button1\",\n};\n\nstatic const u32 mxs_lradc_adc_vref_mv[][LRADC_MAX_TOTAL_CHANS] = {\n\t[IMX23_LRADC] = {\n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE * 2,\t \n\t\tVREF_MV_BASE * 4,\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE * 4,\t \n\t},\n\t[IMX28_LRADC] = {\n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE * 4,\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE * 2,\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE * 2,\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE,\t\t \n\t\tVREF_MV_BASE * 4,\t \n\t},\n};\n\nenum mxs_lradc_divbytwo {\n\tMXS_LRADC_DIV_DISABLED = 0,\n\tMXS_LRADC_DIV_ENABLED,\n};\n\nstruct mxs_lradc_scale {\n\tunsigned int\t\tinteger;\n\tunsigned int\t\tnano;\n};\n\nstruct mxs_lradc_adc {\n\tstruct mxs_lradc\t*lradc;\n\tstruct device\t\t*dev;\n\n\tvoid __iomem\t\t*base;\n\t \n\tu32\t\t\tbuffer[10] __aligned(8);\n\tstruct iio_trigger\t*trig;\n\tstruct completion\tcompletion;\n\tspinlock_t\t\tlock;\n\n\tconst u32\t\t*vref_mv;\n\tstruct mxs_lradc_scale\tscale_avail[LRADC_MAX_TOTAL_CHANS][2];\n\tunsigned long\t\tis_divided;\n};\n\n\n \nstatic int mxs_lradc_adc_read_single(struct iio_dev *iio_dev, int chan,\n\t\t\t\t     int *val)\n{\n\tstruct mxs_lradc_adc *adc = iio_priv(iio_dev);\n\tstruct mxs_lradc *lradc = adc->lradc;\n\tint ret;\n\n\t \n\tret = iio_device_claim_direct_mode(iio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\treinit_completion(&adc->completion);\n\n\t \n\tif (lradc->soc == IMX28_LRADC)\n\t\twritel(LRADC_CTRL1_LRADC_IRQ_EN(0),\n\t\t       adc->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\twritel(0x1, adc->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);\n\n\t \n\tif (test_bit(chan, &adc->is_divided))\n\t\twritel(1 << LRADC_CTRL2_DIVIDE_BY_TWO_OFFSET,\n\t\t       adc->base + LRADC_CTRL2 + STMP_OFFSET_REG_SET);\n\telse\n\t\twritel(1 << LRADC_CTRL2_DIVIDE_BY_TWO_OFFSET,\n\t\t       adc->base + LRADC_CTRL2 + STMP_OFFSET_REG_CLR);\n\n\t \n\twritel(LRADC_CTRL4_LRADCSELECT_MASK(0),\n\t       adc->base + LRADC_CTRL4 + STMP_OFFSET_REG_CLR);\n\twritel(chan, adc->base + LRADC_CTRL4 + STMP_OFFSET_REG_SET);\n\n\twritel(0, adc->base + LRADC_CH(0));\n\n\t \n\twritel(LRADC_CTRL1_LRADC_IRQ_EN(0),\n\t       adc->base + LRADC_CTRL1 + STMP_OFFSET_REG_SET);\n\twritel(BIT(0), adc->base + LRADC_CTRL0 + STMP_OFFSET_REG_SET);\n\n\t \n\tret = wait_for_completion_killable_timeout(&adc->completion, HZ);\n\tif (!ret)\n\t\tret = -ETIMEDOUT;\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\t*val = readl(adc->base + LRADC_CH(0)) & LRADC_CH_VALUE_MASK;\n\tret = IIO_VAL_INT;\n\nerr:\n\twritel(LRADC_CTRL1_LRADC_IRQ_EN(0),\n\t       adc->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\n\tiio_device_release_direct_mode(iio_dev);\n\n\treturn ret;\n}\n\nstatic int mxs_lradc_adc_read_temp(struct iio_dev *iio_dev, int *val)\n{\n\tint ret, min, max;\n\n\tret = mxs_lradc_adc_read_single(iio_dev, 8, &min);\n\tif (ret != IIO_VAL_INT)\n\t\treturn ret;\n\n\tret = mxs_lradc_adc_read_single(iio_dev, 9, &max);\n\tif (ret != IIO_VAL_INT)\n\t\treturn ret;\n\n\t*val = max - min;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int mxs_lradc_adc_read_raw(struct iio_dev *iio_dev,\n\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t      int *val, int *val2, long m)\n{\n\tstruct mxs_lradc_adc *adc = iio_priv(iio_dev);\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->type == IIO_TEMP)\n\t\t\treturn mxs_lradc_adc_read_temp(iio_dev, val);\n\n\t\treturn mxs_lradc_adc_read_single(iio_dev, chan->channel, val);\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type == IIO_TEMP) {\n\t\t\t \n\t\t\t*val = 0;\n\t\t\t*val2 = 253000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\n\t\t*val = adc->vref_mv[chan->channel];\n\t\t*val2 = chan->scan_type.realbits -\n\t\t\ttest_bit(chan->channel, &adc->is_divided);\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (chan->type == IIO_TEMP) {\n\t\t\t \n\t\t\t*val = -1079;\n\t\t\t*val2 = 644268;\n\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\n\t\treturn -EINVAL;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mxs_lradc_adc_write_raw(struct iio_dev *iio_dev,\n\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t   int val, int val2, long m)\n{\n\tstruct mxs_lradc_adc *adc = iio_priv(iio_dev);\n\tstruct mxs_lradc_scale *scale_avail =\n\t\t\tadc->scale_avail[chan->channel];\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(iio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = -EINVAL;\n\t\tif (val == scale_avail[MXS_LRADC_DIV_DISABLED].integer &&\n\t\t    val2 == scale_avail[MXS_LRADC_DIV_DISABLED].nano) {\n\t\t\t \n\t\t\tclear_bit(chan->channel, &adc->is_divided);\n\t\t\tret = 0;\n\t\t} else if (val == scale_avail[MXS_LRADC_DIV_ENABLED].integer &&\n\t\t\t   val2 == scale_avail[MXS_LRADC_DIV_ENABLED].nano) {\n\t\t\t \n\t\t\tset_bit(chan->channel, &adc->is_divided);\n\t\t\tret = 0;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tiio_device_release_direct_mode(iio_dev);\n\n\treturn ret;\n}\n\nstatic int mxs_lradc_adc_write_raw_get_fmt(struct iio_dev *iio_dev,\n\t\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t\t   long m)\n{\n\treturn IIO_VAL_INT_PLUS_NANO;\n}\n\nstatic ssize_t mxs_lradc_adc_show_scale_avail(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\tstruct iio_dev *iio = dev_to_iio_dev(dev);\n\tstruct mxs_lradc_adc *adc = iio_priv(iio);\n\tstruct iio_dev_attr *iio_attr = to_iio_dev_attr(attr);\n\tint i, ch, len = 0;\n\n\tch = iio_attr->address;\n\tfor (i = 0; i < ARRAY_SIZE(adc->scale_avail[ch]); i++)\n\t\tlen += sprintf(buf + len, \"%u.%09u \",\n\t\t\t       adc->scale_avail[ch][i].integer,\n\t\t\t       adc->scale_avail[ch][i].nano);\n\n\tlen += sprintf(buf + len, \"\\n\");\n\n\treturn len;\n}\n\n#define SHOW_SCALE_AVAILABLE_ATTR(ch)\\\n\tIIO_DEVICE_ATTR(in_voltage##ch##_scale_available, 0444,\\\n\t\t\tmxs_lradc_adc_show_scale_avail, NULL, ch)\n\nstatic SHOW_SCALE_AVAILABLE_ATTR(0);\nstatic SHOW_SCALE_AVAILABLE_ATTR(1);\nstatic SHOW_SCALE_AVAILABLE_ATTR(2);\nstatic SHOW_SCALE_AVAILABLE_ATTR(3);\nstatic SHOW_SCALE_AVAILABLE_ATTR(4);\nstatic SHOW_SCALE_AVAILABLE_ATTR(5);\nstatic SHOW_SCALE_AVAILABLE_ATTR(6);\nstatic SHOW_SCALE_AVAILABLE_ATTR(7);\nstatic SHOW_SCALE_AVAILABLE_ATTR(10);\nstatic SHOW_SCALE_AVAILABLE_ATTR(11);\nstatic SHOW_SCALE_AVAILABLE_ATTR(12);\nstatic SHOW_SCALE_AVAILABLE_ATTR(13);\nstatic SHOW_SCALE_AVAILABLE_ATTR(14);\nstatic SHOW_SCALE_AVAILABLE_ATTR(15);\n\nstatic struct attribute *mxs_lradc_adc_attributes[] = {\n\t&iio_dev_attr_in_voltage0_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage1_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage2_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage3_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage4_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage5_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage6_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage7_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage10_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage11_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage12_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage13_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage14_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage15_scale_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group mxs_lradc_adc_attribute_group = {\n\t.attrs = mxs_lradc_adc_attributes,\n};\n\nstatic const struct iio_info mxs_lradc_adc_iio_info = {\n\t.read_raw\t\t= mxs_lradc_adc_read_raw,\n\t.write_raw\t\t= mxs_lradc_adc_write_raw,\n\t.write_raw_get_fmt\t= mxs_lradc_adc_write_raw_get_fmt,\n\t.attrs\t\t\t= &mxs_lradc_adc_attribute_group,\n};\n\n \nstatic irqreturn_t mxs_lradc_adc_handle_irq(int irq, void *data)\n{\n\tstruct iio_dev *iio = data;\n\tstruct mxs_lradc_adc *adc = iio_priv(iio);\n\tstruct mxs_lradc *lradc = adc->lradc;\n\tunsigned long reg = readl(adc->base + LRADC_CTRL1);\n\tunsigned long flags;\n\n\tif (!(reg & mxs_lradc_irq_mask(lradc)))\n\t\treturn IRQ_NONE;\n\n\tif (iio_buffer_enabled(iio)) {\n\t\tif (reg & lradc->buffer_vchans) {\n\t\t\tspin_lock_irqsave(&adc->lock, flags);\n\t\t\tiio_trigger_poll(iio->trig);\n\t\t\tspin_unlock_irqrestore(&adc->lock, flags);\n\t\t}\n\t} else if (reg & LRADC_CTRL1_LRADC_IRQ(0)) {\n\t\tcomplete(&adc->completion);\n\t}\n\n\twritel(reg & mxs_lradc_irq_mask(lradc),\n\t       adc->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\n\treturn IRQ_HANDLED;\n}\n\n\n \nstatic irqreturn_t mxs_lradc_adc_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *iio = pf->indio_dev;\n\tstruct mxs_lradc_adc *adc = iio_priv(iio);\n\tconst u32 chan_value = LRADC_CH_ACCUMULATE |\n\t\t((LRADC_DELAY_TIMER_LOOP - 1) << LRADC_CH_NUM_SAMPLES_OFFSET);\n\tunsigned int i, j = 0;\n\n\tfor_each_set_bit(i, iio->active_scan_mask, LRADC_MAX_TOTAL_CHANS) {\n\t\tadc->buffer[j] = readl(adc->base + LRADC_CH(j));\n\t\twritel(chan_value, adc->base + LRADC_CH(j));\n\t\tadc->buffer[j] &= LRADC_CH_VALUE_MASK;\n\t\tadc->buffer[j] /= LRADC_DELAY_TIMER_LOOP;\n\t\tj++;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(iio, adc->buffer, pf->timestamp);\n\n\tiio_trigger_notify_done(iio->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mxs_lradc_adc_configure_trigger(struct iio_trigger *trig, bool state)\n{\n\tstruct iio_dev *iio = iio_trigger_get_drvdata(trig);\n\tstruct mxs_lradc_adc *adc = iio_priv(iio);\n\tconst u32 st = state ? STMP_OFFSET_REG_SET : STMP_OFFSET_REG_CLR;\n\n\twritel(LRADC_DELAY_KICK, adc->base + (LRADC_DELAY(0) + st));\n\n\treturn 0;\n}\n\nstatic const struct iio_trigger_ops mxs_lradc_adc_trigger_ops = {\n\t.set_trigger_state = &mxs_lradc_adc_configure_trigger,\n};\n\nstatic int mxs_lradc_adc_trigger_init(struct iio_dev *iio)\n{\n\tint ret;\n\tstruct iio_trigger *trig;\n\tstruct mxs_lradc_adc *adc = iio_priv(iio);\n\n\ttrig = devm_iio_trigger_alloc(&iio->dev, \"%s-dev%i\", iio->name,\n\t\t\t\t      iio_device_id(iio));\n\tif (!trig)\n\t\treturn -ENOMEM;\n\n\ttrig->dev.parent = adc->dev;\n\tiio_trigger_set_drvdata(trig, iio);\n\ttrig->ops = &mxs_lradc_adc_trigger_ops;\n\n\tret = iio_trigger_register(trig);\n\tif (ret)\n\t\treturn ret;\n\n\tadc->trig = trig;\n\n\treturn 0;\n}\n\nstatic void mxs_lradc_adc_trigger_remove(struct iio_dev *iio)\n{\n\tstruct mxs_lradc_adc *adc = iio_priv(iio);\n\n\tiio_trigger_unregister(adc->trig);\n}\n\nstatic int mxs_lradc_adc_buffer_preenable(struct iio_dev *iio)\n{\n\tstruct mxs_lradc_adc *adc = iio_priv(iio);\n\tstruct mxs_lradc *lradc = adc->lradc;\n\tint chan, ofs = 0;\n\tunsigned long enable = 0;\n\tu32 ctrl4_set = 0;\n\tu32 ctrl4_clr = 0;\n\tu32 ctrl1_irq = 0;\n\tconst u32 chan_value = LRADC_CH_ACCUMULATE |\n\t\t((LRADC_DELAY_TIMER_LOOP - 1) << LRADC_CH_NUM_SAMPLES_OFFSET);\n\n\tif (lradc->soc == IMX28_LRADC)\n\t\twritel(lradc->buffer_vchans << LRADC_CTRL1_LRADC_IRQ_EN_OFFSET,\n\t\t       adc->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\twritel(lradc->buffer_vchans,\n\t       adc->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);\n\n\tfor_each_set_bit(chan, iio->active_scan_mask, LRADC_MAX_TOTAL_CHANS) {\n\t\tctrl4_set |= chan << LRADC_CTRL4_LRADCSELECT_OFFSET(ofs);\n\t\tctrl4_clr |= LRADC_CTRL4_LRADCSELECT_MASK(ofs);\n\t\tctrl1_irq |= LRADC_CTRL1_LRADC_IRQ_EN(ofs);\n\t\twritel(chan_value, adc->base + LRADC_CH(ofs));\n\t\tbitmap_set(&enable, ofs, 1);\n\t\tofs++;\n\t}\n\n\twritel(LRADC_DELAY_TRIGGER_LRADCS_MASK | LRADC_DELAY_KICK,\n\t       adc->base + LRADC_DELAY(0) + STMP_OFFSET_REG_CLR);\n\twritel(ctrl4_clr, adc->base + LRADC_CTRL4 + STMP_OFFSET_REG_CLR);\n\twritel(ctrl4_set, adc->base + LRADC_CTRL4 + STMP_OFFSET_REG_SET);\n\twritel(ctrl1_irq, adc->base + LRADC_CTRL1 + STMP_OFFSET_REG_SET);\n\twritel(enable << LRADC_DELAY_TRIGGER_LRADCS_OFFSET,\n\t       adc->base + LRADC_DELAY(0) + STMP_OFFSET_REG_SET);\n\n\treturn 0;\n}\n\nstatic int mxs_lradc_adc_buffer_postdisable(struct iio_dev *iio)\n{\n\tstruct mxs_lradc_adc *adc = iio_priv(iio);\n\tstruct mxs_lradc *lradc = adc->lradc;\n\n\twritel(LRADC_DELAY_TRIGGER_LRADCS_MASK | LRADC_DELAY_KICK,\n\t       adc->base + LRADC_DELAY(0) + STMP_OFFSET_REG_CLR);\n\n\twritel(lradc->buffer_vchans,\n\t       adc->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);\n\tif (lradc->soc == IMX28_LRADC)\n\t\twritel(lradc->buffer_vchans << LRADC_CTRL1_LRADC_IRQ_EN_OFFSET,\n\t\t       adc->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\n\treturn 0;\n}\n\nstatic bool mxs_lradc_adc_validate_scan_mask(struct iio_dev *iio,\n\t\t\t\t\t     const unsigned long *mask)\n{\n\tstruct mxs_lradc_adc *adc = iio_priv(iio);\n\tstruct mxs_lradc *lradc = adc->lradc;\n\tconst int map_chans = bitmap_weight(mask, LRADC_MAX_TOTAL_CHANS);\n\tint rsvd_chans = 0;\n\tunsigned long rsvd_mask = 0;\n\n\tif (lradc->use_touchbutton)\n\t\trsvd_mask |= CHAN_MASK_TOUCHBUTTON;\n\tif (lradc->touchscreen_wire == MXS_LRADC_TOUCHSCREEN_4WIRE)\n\t\trsvd_mask |= CHAN_MASK_TOUCHSCREEN_4WIRE;\n\tif (lradc->touchscreen_wire == MXS_LRADC_TOUCHSCREEN_5WIRE)\n\t\trsvd_mask |= CHAN_MASK_TOUCHSCREEN_5WIRE;\n\n\tif (lradc->use_touchbutton)\n\t\trsvd_chans++;\n\tif (lradc->touchscreen_wire)\n\t\trsvd_chans += 2;\n\n\t \n\tif (bitmap_intersects(mask, &rsvd_mask, LRADC_MAX_TOTAL_CHANS))\n\t\treturn false;\n\n\t \n\tif (map_chans + rsvd_chans > LRADC_MAX_MAPPED_CHANS)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic const struct iio_buffer_setup_ops mxs_lradc_adc_buffer_ops = {\n\t.preenable = &mxs_lradc_adc_buffer_preenable,\n\t.postdisable = &mxs_lradc_adc_buffer_postdisable,\n\t.validate_scan_mask = &mxs_lradc_adc_validate_scan_mask,\n};\n\n \n#define MXS_ADC_CHAN(idx, chan_type, name) {\t\t\t\\\n\t.type = (chan_type),\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.scan_index = (idx),\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t.channel = (idx),\t\t\t\t\t\\\n\t.address = (idx),\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = LRADC_RESOLUTION,\t\t\t\\\n\t\t.storagebits = 32,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.datasheet_name = (name),\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec mx23_lradc_chan_spec[] = {\n\tMXS_ADC_CHAN(0, IIO_VOLTAGE, \"LRADC0\"),\n\tMXS_ADC_CHAN(1, IIO_VOLTAGE, \"LRADC1\"),\n\tMXS_ADC_CHAN(2, IIO_VOLTAGE, \"LRADC2\"),\n\tMXS_ADC_CHAN(3, IIO_VOLTAGE, \"LRADC3\"),\n\tMXS_ADC_CHAN(4, IIO_VOLTAGE, \"LRADC4\"),\n\tMXS_ADC_CHAN(5, IIO_VOLTAGE, \"LRADC5\"),\n\tMXS_ADC_CHAN(6, IIO_VOLTAGE, \"VDDIO\"),\n\tMXS_ADC_CHAN(7, IIO_VOLTAGE, \"VBATT\"),\n\t \n\t{\n\t\t.type = IIO_TEMP,\n\t\t.indexed = 1,\n\t\t.scan_index = 8,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.channel = 8,\n\t\t.scan_type = {.sign = 'u', .realbits = 18, .storagebits = 32,},\n\t\t.datasheet_name = \"TEMP_DIE\",\n\t},\n\t \n\t{\n\t\t.type = IIO_TEMP,\n\t\t.indexed = 1,\n\t\t.scan_index = -1,\n\t\t.channel = 9,\n\t},\n\tMXS_ADC_CHAN(10, IIO_VOLTAGE, NULL),\n\tMXS_ADC_CHAN(11, IIO_VOLTAGE, NULL),\n\tMXS_ADC_CHAN(12, IIO_VOLTAGE, \"USB_DP\"),\n\tMXS_ADC_CHAN(13, IIO_VOLTAGE, \"USB_DN\"),\n\tMXS_ADC_CHAN(14, IIO_VOLTAGE, \"VBG\"),\n\tMXS_ADC_CHAN(15, IIO_VOLTAGE, \"VDD5V\"),\n};\n\nstatic const struct iio_chan_spec mx28_lradc_chan_spec[] = {\n\tMXS_ADC_CHAN(0, IIO_VOLTAGE, \"LRADC0\"),\n\tMXS_ADC_CHAN(1, IIO_VOLTAGE, \"LRADC1\"),\n\tMXS_ADC_CHAN(2, IIO_VOLTAGE, \"LRADC2\"),\n\tMXS_ADC_CHAN(3, IIO_VOLTAGE, \"LRADC3\"),\n\tMXS_ADC_CHAN(4, IIO_VOLTAGE, \"LRADC4\"),\n\tMXS_ADC_CHAN(5, IIO_VOLTAGE, \"LRADC5\"),\n\tMXS_ADC_CHAN(6, IIO_VOLTAGE, \"LRADC6\"),\n\tMXS_ADC_CHAN(7, IIO_VOLTAGE, \"VBATT\"),\n\t \n\t{\n\t\t.type = IIO_TEMP,\n\t\t.indexed = 1,\n\t\t.scan_index = 8,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.channel = 8,\n\t\t.scan_type = {.sign = 'u', .realbits = 18, .storagebits = 32,},\n\t\t.datasheet_name = \"TEMP_DIE\",\n\t},\n\t \n\t{\n\t\t.type = IIO_TEMP,\n\t\t.indexed = 1,\n\t\t.scan_index = -1,\n\t\t.channel = 9,\n\t},\n\tMXS_ADC_CHAN(10, IIO_VOLTAGE, \"VDDIO\"),\n\tMXS_ADC_CHAN(11, IIO_VOLTAGE, \"VTH\"),\n\tMXS_ADC_CHAN(12, IIO_VOLTAGE, \"VDDA\"),\n\tMXS_ADC_CHAN(13, IIO_VOLTAGE, \"VDDD\"),\n\tMXS_ADC_CHAN(14, IIO_VOLTAGE, \"VBG\"),\n\tMXS_ADC_CHAN(15, IIO_VOLTAGE, \"VDD5V\"),\n};\n\nstatic void mxs_lradc_adc_hw_init(struct mxs_lradc_adc *adc)\n{\n\t \n\tconst u32 adc_cfg =\n\t\t(1 << (LRADC_DELAY_TRIGGER_DELAYS_OFFSET + 0)) |\n\t\t(LRADC_DELAY_TIMER_PER << LRADC_DELAY_DELAY_OFFSET);\n\n\t \n\twritel(adc_cfg, adc->base + LRADC_DELAY(0));\n\n\t \n\twritel(0, adc->base + LRADC_CTRL2);\n}\n\nstatic void mxs_lradc_adc_hw_stop(struct mxs_lradc_adc *adc)\n{\n\twritel(0, adc->base + LRADC_DELAY(0));\n}\n\nstatic int mxs_lradc_adc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mxs_lradc *lradc = dev_get_drvdata(dev->parent);\n\tstruct mxs_lradc_adc *adc;\n\tstruct iio_dev *iio;\n\tstruct resource *iores;\n\tint ret, irq, virq, i, s, n;\n\tu64 scale_uv;\n\tconst char **irq_name;\n\n\t \n\tiio = devm_iio_device_alloc(dev, sizeof(*adc));\n\tif (!iio) {\n\t\tdev_err(dev, \"Failed to allocate IIO device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tadc = iio_priv(iio);\n\tadc->lradc = lradc;\n\tadc->dev = dev;\n\n\tiores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!iores)\n\t\treturn -EINVAL;\n\n\tadc->base = devm_ioremap(dev, iores->start, resource_size(iores));\n\tif (!adc->base)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&adc->completion);\n\tspin_lock_init(&adc->lock);\n\n\tplatform_set_drvdata(pdev, iio);\n\n\tiio->name = pdev->name;\n\tiio->dev.of_node = dev->parent->of_node;\n\tiio->info = &mxs_lradc_adc_iio_info;\n\tiio->modes = INDIO_DIRECT_MODE;\n\tiio->masklength = LRADC_MAX_TOTAL_CHANS;\n\n\tif (lradc->soc == IMX23_LRADC) {\n\t\tiio->channels = mx23_lradc_chan_spec;\n\t\tiio->num_channels = ARRAY_SIZE(mx23_lradc_chan_spec);\n\t\tirq_name = mx23_lradc_adc_irq_names;\n\t\tn = ARRAY_SIZE(mx23_lradc_adc_irq_names);\n\t} else {\n\t\tiio->channels = mx28_lradc_chan_spec;\n\t\tiio->num_channels = ARRAY_SIZE(mx28_lradc_chan_spec);\n\t\tirq_name = mx28_lradc_adc_irq_names;\n\t\tn = ARRAY_SIZE(mx28_lradc_adc_irq_names);\n\t}\n\n\tret = stmp_reset_block(adc->base);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < n; i++) {\n\t\tirq = platform_get_irq_byname(pdev, irq_name[i]);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tvirq = irq_of_parse_and_map(dev->parent->of_node, irq);\n\n\t\tret = devm_request_irq(dev, virq, mxs_lradc_adc_handle_irq,\n\t\t\t\t       0, irq_name[i], iio);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = mxs_lradc_adc_trigger_init(iio);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iio_triggered_buffer_setup(iio, &iio_pollfunc_store_time,\n\t\t\t\t\t &mxs_lradc_adc_trigger_handler,\n\t\t\t\t\t &mxs_lradc_adc_buffer_ops);\n\tif (ret)\n\t\tgoto err_trig;\n\n\tadc->vref_mv = mxs_lradc_adc_vref_mv[lradc->soc];\n\n\t \n\tfor (i = 0; i < LRADC_MAX_TOTAL_CHANS; i++) {\n\t\tfor (s = 0; s < ARRAY_SIZE(adc->scale_avail[i]); s++) {\n\t\t\t \n\t\t\tscale_uv = ((u64)adc->vref_mv[i] * 100000000) >>\n\t\t\t\t   (LRADC_RESOLUTION - s);\n\t\t\tadc->scale_avail[i][s].nano =\n\t\t\t\t\tdo_div(scale_uv, 100000000) * 10;\n\t\t\tadc->scale_avail[i][s].integer = scale_uv;\n\t\t}\n\t}\n\n\t \n\tmxs_lradc_adc_hw_init(adc);\n\n\t \n\tret = iio_device_register(iio);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register IIO device\\n\");\n\t\tgoto err_dev;\n\t}\n\n\treturn 0;\n\nerr_dev:\n\tmxs_lradc_adc_hw_stop(adc);\n\tiio_triggered_buffer_cleanup(iio);\nerr_trig:\n\tmxs_lradc_adc_trigger_remove(iio);\n\treturn ret;\n}\n\nstatic int mxs_lradc_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *iio = platform_get_drvdata(pdev);\n\tstruct mxs_lradc_adc *adc = iio_priv(iio);\n\n\tiio_device_unregister(iio);\n\tmxs_lradc_adc_hw_stop(adc);\n\tiio_triggered_buffer_cleanup(iio);\n\tmxs_lradc_adc_trigger_remove(iio);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mxs_lradc_adc_driver = {\n\t.driver = {\n\t\t.name\t= \"mxs-lradc-adc\",\n\t},\n\t.probe\t= mxs_lradc_adc_probe,\n\t.remove = mxs_lradc_adc_remove,\n};\nmodule_platform_driver(mxs_lradc_adc_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"Freescale MXS LRADC driver general purpose ADC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mxs-lradc-adc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}