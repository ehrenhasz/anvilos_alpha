{
  "module_name": "ad7793.c",
  "hash_id": "cd5d868a85b3207c2d428512fbd8b1c6569142fb2c6d610a768302c343f6b8ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7793.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/adc/ad_sigma_delta.h>\n#include <linux/platform_data/ad7793.h>\n\n \n#define AD7793_REG_COMM\t\t0  \n#define AD7793_REG_STAT\t\t0  \n#define AD7793_REG_MODE\t\t1  \n#define AD7793_REG_CONF\t\t2  \n#define AD7793_REG_DATA\t\t3  \n#define AD7793_REG_ID\t\t4  \n#define AD7793_REG_IO\t\t5  \n#define AD7793_REG_OFFSET\t6  \n#define AD7793_REG_FULLSALE\t7  \n\n \n#define AD7793_COMM_WEN\t\t(1 << 7)  \n#define AD7793_COMM_WRITE\t(0 << 6)  \n#define AD7793_COMM_READ\t(1 << 6)  \n#define AD7793_COMM_ADDR(x)\t(((x) & 0x7) << 3)  \n#define AD7793_COMM_CREAD\t(1 << 2)  \n\n \n#define AD7793_STAT_RDY\t\t(1 << 7)  \n#define AD7793_STAT_ERR\t\t(1 << 6)  \n#define AD7793_STAT_CH3\t\t(1 << 2)  \n#define AD7793_STAT_CH2\t\t(1 << 1)  \n#define AD7793_STAT_CH1\t\t(1 << 0)  \n\n \n#define AD7793_MODE_SEL(x)\t(((x) & 0x7) << 13)  \n#define AD7793_MODE_SEL_MASK\t(0x7 << 13)  \n#define AD7793_MODE_CLKSRC(x)\t(((x) & 0x3) << 6)  \n#define AD7793_MODE_RATE(x)\t((x) & 0xF)  \n\n#define AD7793_MODE_CONT\t\t0  \n#define AD7793_MODE_SINGLE\t\t1  \n#define AD7793_MODE_IDLE\t\t2  \n#define AD7793_MODE_PWRDN\t\t3  \n#define AD7793_MODE_CAL_INT_ZERO\t4  \n#define AD7793_MODE_CAL_INT_FULL\t5  \n#define AD7793_MODE_CAL_SYS_ZERO\t6  \n#define AD7793_MODE_CAL_SYS_FULL\t7  \n\n#define AD7793_CLK_INT\t\t0  \n#define AD7793_CLK_INT_CO\t1  \n#define AD7793_CLK_EXT\t\t2  \n#define AD7793_CLK_EXT_DIV2\t3  \n\n \n#define AD7793_CONF_VBIAS(x)\t(((x) & 0x3) << 14)  \n#define AD7793_CONF_BO_EN\t(1 << 13)  \n#define AD7793_CONF_UNIPOLAR\t(1 << 12)  \n#define AD7793_CONF_BOOST\t(1 << 11)  \n#define AD7793_CONF_GAIN(x)\t(((x) & 0x7) << 8)  \n#define AD7793_CONF_REFSEL(x)\t((x) << 6)  \n#define AD7793_CONF_BUF\t\t(1 << 4)  \n#define AD7793_CONF_CHAN(x)\t((x) & 0xf)  \n#define AD7793_CONF_CHAN_MASK\t0xf  \n\n#define AD7793_CH_AIN1P_AIN1M\t0  \n#define AD7793_CH_AIN2P_AIN2M\t1  \n#define AD7793_CH_AIN3P_AIN3M\t2  \n#define AD7793_CH_AIN1M_AIN1M\t3  \n#define AD7793_CH_TEMP\t\t6  \n#define AD7793_CH_AVDD_MONITOR\t7  \n\n#define AD7795_CH_AIN4P_AIN4M\t4  \n#define AD7795_CH_AIN5P_AIN5M\t5  \n#define AD7795_CH_AIN6P_AIN6M\t6  \n#define AD7795_CH_AIN1M_AIN1M\t8  \n\n \n#define AD7785_ID\t\t0x3\n#define AD7792_ID\t\t0xA\n#define AD7793_ID\t\t0xB\n#define AD7794_ID\t\t0xF\n#define AD7795_ID\t\t0xF\n#define AD7796_ID\t\t0xA\n#define AD7797_ID\t\t0xB\n#define AD7798_ID\t\t0x8\n#define AD7799_ID\t\t0x9\n#define AD7793_ID_MASK\t\t0xF\n\n \n#define AD7793_IO_IEXC1_IOUT1_IEXC2_IOUT2\t0  \n#define AD7793_IO_IEXC1_IOUT2_IEXC2_IOUT1\t1  \n#define AD7793_IO_IEXC1_IEXC2_IOUT1\t\t2  \n#define AD7793_IO_IEXC1_IEXC2_IOUT2\t\t3  \n\n#define AD7793_IO_IXCEN_10uA\t(1 << 0)  \n#define AD7793_IO_IXCEN_210uA\t(2 << 0)  \n#define AD7793_IO_IXCEN_1mA\t(3 << 0)  \n\n \n\n#define AD7793_FLAG_HAS_CLKSEL\t\tBIT(0)\n#define AD7793_FLAG_HAS_REFSEL\t\tBIT(1)\n#define AD7793_FLAG_HAS_VBIAS\t\tBIT(2)\n#define AD7793_HAS_EXITATION_CURRENT\tBIT(3)\n#define AD7793_FLAG_HAS_GAIN\t\tBIT(4)\n#define AD7793_FLAG_HAS_BUFFER\t\tBIT(5)\n\nstruct ad7793_chip_info {\n\tunsigned int id;\n\tconst struct iio_chan_spec *channels;\n\tunsigned int num_channels;\n\tunsigned int flags;\n\n\tconst struct iio_info *iio_info;\n\tconst u16 *sample_freq_avail;\n};\n\nstruct ad7793_state {\n\tconst struct ad7793_chip_info\t*chip_info;\n\tstruct regulator\t\t*reg;\n\tu16\t\t\t\tint_vref_mv;\n\tu16\t\t\t\tmode;\n\tu16\t\t\t\tconf;\n\tu32\t\t\t\tscale_avail[8][2];\n\n\tstruct ad_sigma_delta\t\tsd;\n\n};\n\nenum ad7793_supported_device_ids {\n\tID_AD7785,\n\tID_AD7792,\n\tID_AD7793,\n\tID_AD7794,\n\tID_AD7795,\n\tID_AD7796,\n\tID_AD7797,\n\tID_AD7798,\n\tID_AD7799,\n};\n\nstatic struct ad7793_state *ad_sigma_delta_to_ad7793(struct ad_sigma_delta *sd)\n{\n\treturn container_of(sd, struct ad7793_state, sd);\n}\n\nstatic int ad7793_set_channel(struct ad_sigma_delta *sd, unsigned int channel)\n{\n\tstruct ad7793_state *st = ad_sigma_delta_to_ad7793(sd);\n\n\tst->conf &= ~AD7793_CONF_CHAN_MASK;\n\tst->conf |= AD7793_CONF_CHAN(channel);\n\n\treturn ad_sd_write_reg(&st->sd, AD7793_REG_CONF, 2, st->conf);\n}\n\nstatic int ad7793_set_mode(struct ad_sigma_delta *sd,\n\t\t\t   enum ad_sigma_delta_mode mode)\n{\n\tstruct ad7793_state *st = ad_sigma_delta_to_ad7793(sd);\n\n\tst->mode &= ~AD7793_MODE_SEL_MASK;\n\tst->mode |= AD7793_MODE_SEL(mode);\n\n\treturn ad_sd_write_reg(&st->sd, AD7793_REG_MODE, 2, st->mode);\n}\n\nstatic const struct ad_sigma_delta_info ad7793_sigma_delta_info = {\n\t.set_channel = ad7793_set_channel,\n\t.set_mode = ad7793_set_mode,\n\t.has_registers = true,\n\t.addr_shift = 3,\n\t.read_mask = BIT(6),\n\t.irq_flags = IRQF_TRIGGER_FALLING,\n};\n\nstatic const struct ad_sd_calib_data ad7793_calib_arr[6] = {\n\t{AD7793_MODE_CAL_INT_ZERO, AD7793_CH_AIN1P_AIN1M},\n\t{AD7793_MODE_CAL_INT_FULL, AD7793_CH_AIN1P_AIN1M},\n\t{AD7793_MODE_CAL_INT_ZERO, AD7793_CH_AIN2P_AIN2M},\n\t{AD7793_MODE_CAL_INT_FULL, AD7793_CH_AIN2P_AIN2M},\n\t{AD7793_MODE_CAL_INT_ZERO, AD7793_CH_AIN3P_AIN3M},\n\t{AD7793_MODE_CAL_INT_FULL, AD7793_CH_AIN3P_AIN3M}\n};\n\nstatic int ad7793_calibrate_all(struct ad7793_state *st)\n{\n\treturn ad_sd_calibrate_all(&st->sd, ad7793_calib_arr,\n\t\t\t\t   ARRAY_SIZE(ad7793_calib_arr));\n}\n\nstatic int ad7793_check_platform_data(struct ad7793_state *st,\n\tconst struct ad7793_platform_data *pdata)\n{\n\tif ((pdata->current_source_direction == AD7793_IEXEC1_IEXEC2_IOUT1 ||\n\t\tpdata->current_source_direction == AD7793_IEXEC1_IEXEC2_IOUT2) &&\n\t\t((pdata->exitation_current != AD7793_IX_10uA) &&\n\t\t(pdata->exitation_current != AD7793_IX_210uA)))\n\t\treturn -EINVAL;\n\n\tif (!(st->chip_info->flags & AD7793_FLAG_HAS_CLKSEL) &&\n\t\tpdata->clock_src != AD7793_CLK_SRC_INT)\n\t\treturn -EINVAL;\n\n\tif (!(st->chip_info->flags & AD7793_FLAG_HAS_REFSEL) &&\n\t\tpdata->refsel != AD7793_REFSEL_REFIN1)\n\t\treturn -EINVAL;\n\n\tif (!(st->chip_info->flags & AD7793_FLAG_HAS_VBIAS) &&\n\t\tpdata->bias_voltage != AD7793_BIAS_VOLTAGE_DISABLED)\n\t\treturn -EINVAL;\n\n\tif (!(st->chip_info->flags & AD7793_HAS_EXITATION_CURRENT) &&\n\t\tpdata->exitation_current != AD7793_IX_DISABLED)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ad7793_setup(struct iio_dev *indio_dev,\n\tconst struct ad7793_platform_data *pdata,\n\tunsigned int vref_mv)\n{\n\tstruct ad7793_state *st = iio_priv(indio_dev);\n\tint i, ret;\n\tunsigned long long scale_uv;\n\tu32 id;\n\n\tret = ad7793_check_platform_data(st, pdata);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ad_sd_reset(&st->sd, 32);\n\tif (ret < 0)\n\t\tgoto out;\n\tusleep_range(500, 2000);  \n\n\t \n\tret = ad_sd_read_reg(&st->sd, AD7793_REG_ID, 1, &id);\n\tif (ret)\n\t\tgoto out;\n\n\tid &= AD7793_ID_MASK;\n\n\tif (id != st->chip_info->id) {\n\t\tret = -ENODEV;\n\t\tdev_err(&st->sd.spi->dev, \"device ID query failed\\n\");\n\t\tgoto out;\n\t}\n\n\tst->mode = AD7793_MODE_RATE(1);\n\tst->conf = 0;\n\n\tif (st->chip_info->flags & AD7793_FLAG_HAS_CLKSEL)\n\t\tst->mode |= AD7793_MODE_CLKSRC(pdata->clock_src);\n\tif (st->chip_info->flags & AD7793_FLAG_HAS_REFSEL)\n\t\tst->conf |= AD7793_CONF_REFSEL(pdata->refsel);\n\tif (st->chip_info->flags & AD7793_FLAG_HAS_VBIAS)\n\t\tst->conf |= AD7793_CONF_VBIAS(pdata->bias_voltage);\n\tif (pdata->buffered || !(st->chip_info->flags & AD7793_FLAG_HAS_BUFFER))\n\t\tst->conf |= AD7793_CONF_BUF;\n\tif (pdata->boost_enable &&\n\t\t(st->chip_info->flags & AD7793_FLAG_HAS_VBIAS))\n\t\tst->conf |= AD7793_CONF_BOOST;\n\tif (pdata->burnout_current)\n\t\tst->conf |= AD7793_CONF_BO_EN;\n\tif (pdata->unipolar)\n\t\tst->conf |= AD7793_CONF_UNIPOLAR;\n\n\tif (!(st->chip_info->flags & AD7793_FLAG_HAS_GAIN))\n\t\tst->conf |= AD7793_CONF_GAIN(7);\n\n\tret = ad7793_set_mode(&st->sd, AD_SD_MODE_IDLE);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ad7793_set_channel(&st->sd, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tif (st->chip_info->flags & AD7793_HAS_EXITATION_CURRENT) {\n\t\tret = ad_sd_write_reg(&st->sd, AD7793_REG_IO, 1,\n\t\t\t\tpdata->exitation_current |\n\t\t\t\t(pdata->current_source_direction << 2));\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = ad7793_calibrate_all(st);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(st->scale_avail); i++) {\n\t\tscale_uv = ((u64)vref_mv * 100000000)\n\t\t\t>> (st->chip_info->channels[0].scan_type.realbits -\n\t\t\t(!!(st->conf & AD7793_CONF_UNIPOLAR) ? 0 : 1));\n\t\tscale_uv >>= i;\n\n\t\tst->scale_avail[i][1] = do_div(scale_uv, 100000000) * 10;\n\t\tst->scale_avail[i][0] = scale_uv;\n\t}\n\n\treturn 0;\nout:\n\tdev_err(&st->sd.spi->dev, \"setup failed\\n\");\n\treturn ret;\n}\n\nstatic const u16 ad7793_sample_freq_avail[16] = {0, 470, 242, 123, 62, 50, 39,\n\t\t\t\t\t33, 19, 17, 16, 12, 10, 8, 6, 4};\n\nstatic const u16 ad7797_sample_freq_avail[16] = {0, 0, 0, 123, 62, 50, 0,\n\t\t\t\t\t33, 0, 17, 16, 12, 10, 8, 6, 4};\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\n\t\"470 242 123 62 50 39 33 19 17 16 12 10 8 6 4\");\n\nstatic IIO_CONST_ATTR_NAMED(sampling_frequency_available_ad7797,\n\tsampling_frequency_available, \"123 62 50 33 17 16 12 10 8 6 4\");\n\nstatic int ad7793_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type, int *length,\n\t\t\t     long mask)\n{\n\tstruct ad7793_state *st = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*vals = (int *)st->scale_avail;\n\t\t*type = IIO_VAL_INT_PLUS_NANO;\n\t\t \n\t\t*length = ARRAY_SIZE(st->scale_avail) * 2;\n\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic struct attribute *ad7793_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ad7793_attribute_group = {\n\t.attrs = ad7793_attributes,\n};\n\nstatic struct attribute *ad7797_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available_ad7797.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ad7797_attribute_group = {\n\t.attrs = ad7797_attributes,\n};\n\nstatic int ad7793_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tstruct ad7793_state *st = iio_priv(indio_dev);\n\tint ret;\n\tunsigned long long scale_uv;\n\tbool unipolar = !!(st->conf & AD7793_CONF_UNIPOLAR);\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = ad_sigma_delta_single_conversion(indio_dev, chan, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tif (chan->differential) {\n\t\t\t\t*val = st->\n\t\t\t\t\tscale_avail[(st->conf >> 8) & 0x7][0];\n\t\t\t\t*val2 = st->\n\t\t\t\t\tscale_avail[(st->conf >> 8) & 0x7][1];\n\t\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\t\t}\n\t\t\t \n\t\t\tscale_uv = (1170ULL * 1000000000ULL * 6ULL);\n\t\t\tbreak;\n\t\tcase IIO_TEMP:\n\t\t\t\t \n\t\t\t\tscale_uv = 1444444444444444ULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tscale_uv >>= (chan->scan_type.realbits - (unipolar ? 0 : 1));\n\t\t*val = 0;\n\t\t*val2 = scale_uv;\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (!unipolar)\n\t\t\t*val = -(1 << (chan->scan_type.realbits - 1));\n\t\telse\n\t\t\t*val = 0;\n\n\t\t \n\t\tif (chan->type == IIO_TEMP) {\n\t\t\tunsigned long long offset;\n\t\t\tunsigned int shift;\n\n\t\t\tshift = chan->scan_type.realbits - (unipolar ? 0 : 1);\n\t\t\toffset = 273ULL << shift;\n\t\t\tdo_div(offset, 1444);\n\t\t\t*val -= offset;\n\t\t}\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = st->chip_info\n\t\t\t       ->sample_freq_avail[AD7793_MODE_RATE(st->mode)];\n\t\treturn IIO_VAL_INT;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ad7793_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val,\n\t\t\t       int val2,\n\t\t\t       long mask)\n{\n\tstruct ad7793_state *st = iio_priv(indio_dev);\n\tint ret, i;\n\tunsigned int tmp;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = -EINVAL;\n\t\tfor (i = 0; i < ARRAY_SIZE(st->scale_avail); i++)\n\t\t\tif (val2 == st->scale_avail[i][1]) {\n\t\t\t\tret = 0;\n\t\t\t\ttmp = st->conf;\n\t\t\t\tst->conf &= ~AD7793_CONF_GAIN(-1);\n\t\t\t\tst->conf |= AD7793_CONF_GAIN(i);\n\n\t\t\t\tif (tmp == st->conf)\n\t\t\t\t\tbreak;\n\n\t\t\t\tad_sd_write_reg(&st->sd, AD7793_REG_CONF,\n\t\t\t\t\t\tsizeof(st->conf), st->conf);\n\t\t\t\tad7793_calibrate_all(st);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (!val) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tif (val == st->chip_info->sample_freq_avail[i])\n\t\t\t\tbreak;\n\n\t\tif (i == 16) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tst->mode &= ~AD7793_MODE_RATE(-1);\n\t\tst->mode |= AD7793_MODE_RATE(i);\n\t\tad_sd_write_reg(&st->sd, AD7793_REG_MODE, sizeof(st->mode),\n\t\t\t\tst->mode);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tiio_device_release_direct_mode(indio_dev);\n\treturn ret;\n}\n\nstatic int ad7793_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       long mask)\n{\n\treturn IIO_VAL_INT_PLUS_NANO;\n}\n\nstatic const struct iio_info ad7793_info = {\n\t.read_raw = &ad7793_read_raw,\n\t.write_raw = &ad7793_write_raw,\n\t.write_raw_get_fmt = &ad7793_write_raw_get_fmt,\n\t.read_avail = ad7793_read_avail,\n\t.attrs = &ad7793_attribute_group,\n\t.validate_trigger = ad_sd_validate_trigger,\n};\n\nstatic const struct iio_info ad7797_info = {\n\t.read_raw = &ad7793_read_raw,\n\t.write_raw = &ad7793_write_raw,\n\t.write_raw_get_fmt = &ad7793_write_raw_get_fmt,\n\t.attrs = &ad7797_attribute_group,\n\t.validate_trigger = ad_sd_validate_trigger,\n};\n\n#define __AD7793_CHANNEL(_si, _channel1, _channel2, _address, _bits, \\\n\t_storagebits, _shift, _extend_name, _type, _mask_type_av, _mask_all) \\\n\t{ \\\n\t\t.type = (_type), \\\n\t\t.differential = (_channel2 == -1 ? 0 : 1), \\\n\t\t.indexed = 1, \\\n\t\t.channel = (_channel1), \\\n\t\t.channel2 = (_channel2), \\\n\t\t.address = (_address), \\\n\t\t.extend_name = (_extend_name), \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET), \\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t\t.info_mask_shared_by_type_available = (_mask_type_av), \\\n\t\t.info_mask_shared_by_all = _mask_all, \\\n\t\t.scan_index = (_si), \\\n\t\t.scan_type = { \\\n\t\t\t.sign = 'u', \\\n\t\t\t.realbits = (_bits), \\\n\t\t\t.storagebits = (_storagebits), \\\n\t\t\t.shift = (_shift), \\\n\t\t\t.endianness = IIO_BE, \\\n\t\t}, \\\n\t}\n\n#define AD7793_DIFF_CHANNEL(_si, _channel1, _channel2, _address, _bits, \\\n\t_storagebits, _shift) \\\n\t__AD7793_CHANNEL(_si, _channel1, _channel2, _address, _bits, \\\n\t\t_storagebits, _shift, NULL, IIO_VOLTAGE, \\\n\t\tBIT(IIO_CHAN_INFO_SCALE), \\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ))\n\n#define AD7793_SHORTED_CHANNEL(_si, _channel, _address, _bits, \\\n\t_storagebits, _shift) \\\n\t__AD7793_CHANNEL(_si, _channel, _channel, _address, _bits, \\\n\t\t_storagebits, _shift, \"shorted\", IIO_VOLTAGE, \\\n\t\tBIT(IIO_CHAN_INFO_SCALE), \\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ))\n\n#define AD7793_TEMP_CHANNEL(_si, _address, _bits, _storagebits, _shift) \\\n\t__AD7793_CHANNEL(_si, 0, -1, _address, _bits, \\\n\t\t_storagebits, _shift, NULL, IIO_TEMP, \\\n\t\t0, \\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ))\n\n#define AD7793_SUPPLY_CHANNEL(_si, _channel, _address, _bits, _storagebits, \\\n\t_shift) \\\n\t__AD7793_CHANNEL(_si, _channel, -1, _address, _bits, \\\n\t\t_storagebits, _shift, \"supply\", IIO_VOLTAGE, \\\n\t\t0, \\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ))\n\n#define AD7797_DIFF_CHANNEL(_si, _channel1, _channel2, _address, _bits, \\\n\t_storagebits, _shift) \\\n\t__AD7793_CHANNEL(_si, _channel1, _channel2, _address, _bits, \\\n\t\t_storagebits, _shift, NULL, IIO_VOLTAGE, \\\n\t\t0, \\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ))\n\n#define AD7797_SHORTED_CHANNEL(_si, _channel, _address, _bits, \\\n\t_storagebits, _shift) \\\n\t__AD7793_CHANNEL(_si, _channel, _channel, _address, _bits, \\\n\t\t_storagebits, _shift, \"shorted\", IIO_VOLTAGE, \\\n\t\t0, \\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ))\n\n#define DECLARE_AD7793_CHANNELS(_name, _b, _sb, _s) \\\nconst struct iio_chan_spec _name##_channels[] = { \\\n\tAD7793_DIFF_CHANNEL(0, 0, 0, AD7793_CH_AIN1P_AIN1M, (_b), (_sb), (_s)), \\\n\tAD7793_DIFF_CHANNEL(1, 1, 1, AD7793_CH_AIN2P_AIN2M, (_b), (_sb), (_s)), \\\n\tAD7793_DIFF_CHANNEL(2, 2, 2, AD7793_CH_AIN3P_AIN3M, (_b), (_sb), (_s)), \\\n\tAD7793_SHORTED_CHANNEL(3, 0, AD7793_CH_AIN1M_AIN1M, (_b), (_sb), (_s)), \\\n\tAD7793_TEMP_CHANNEL(4, AD7793_CH_TEMP, (_b), (_sb), (_s)), \\\n\tAD7793_SUPPLY_CHANNEL(5, 3, AD7793_CH_AVDD_MONITOR, (_b), (_sb), (_s)), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(6), \\\n}\n\n#define DECLARE_AD7795_CHANNELS(_name, _b, _sb) \\\nconst struct iio_chan_spec _name##_channels[] = { \\\n\tAD7793_DIFF_CHANNEL(0, 0, 0, AD7793_CH_AIN1P_AIN1M, (_b), (_sb), 0), \\\n\tAD7793_DIFF_CHANNEL(1, 1, 1, AD7793_CH_AIN2P_AIN2M, (_b), (_sb), 0), \\\n\tAD7793_DIFF_CHANNEL(2, 2, 2, AD7793_CH_AIN3P_AIN3M, (_b), (_sb), 0), \\\n\tAD7793_DIFF_CHANNEL(3, 3, 3, AD7795_CH_AIN4P_AIN4M, (_b), (_sb), 0), \\\n\tAD7793_DIFF_CHANNEL(4, 4, 4, AD7795_CH_AIN5P_AIN5M, (_b), (_sb), 0), \\\n\tAD7793_DIFF_CHANNEL(5, 5, 5, AD7795_CH_AIN6P_AIN6M, (_b), (_sb), 0), \\\n\tAD7793_SHORTED_CHANNEL(6, 0, AD7795_CH_AIN1M_AIN1M, (_b), (_sb), 0), \\\n\tAD7793_TEMP_CHANNEL(7, AD7793_CH_TEMP, (_b), (_sb), 0), \\\n\tAD7793_SUPPLY_CHANNEL(8, 3, AD7793_CH_AVDD_MONITOR, (_b), (_sb), 0), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(9), \\\n}\n\n#define DECLARE_AD7797_CHANNELS(_name, _b, _sb) \\\nconst struct iio_chan_spec _name##_channels[] = { \\\n\tAD7797_DIFF_CHANNEL(0, 0, 0, AD7793_CH_AIN1P_AIN1M, (_b), (_sb), 0), \\\n\tAD7797_SHORTED_CHANNEL(1, 0, AD7793_CH_AIN1M_AIN1M, (_b), (_sb), 0), \\\n\tAD7793_TEMP_CHANNEL(2, AD7793_CH_TEMP, (_b), (_sb), 0), \\\n\tAD7793_SUPPLY_CHANNEL(3, 3, AD7793_CH_AVDD_MONITOR, (_b), (_sb), 0), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(4), \\\n}\n\n#define DECLARE_AD7799_CHANNELS(_name, _b, _sb) \\\nconst struct iio_chan_spec _name##_channels[] = { \\\n\tAD7793_DIFF_CHANNEL(0, 0, 0, AD7793_CH_AIN1P_AIN1M, (_b), (_sb), 0), \\\n\tAD7793_DIFF_CHANNEL(1, 1, 1, AD7793_CH_AIN2P_AIN2M, (_b), (_sb), 0), \\\n\tAD7793_DIFF_CHANNEL(2, 2, 2, AD7793_CH_AIN3P_AIN3M, (_b), (_sb), 0), \\\n\tAD7793_SHORTED_CHANNEL(3, 0, AD7793_CH_AIN1M_AIN1M, (_b), (_sb), 0), \\\n\tAD7793_SUPPLY_CHANNEL(4, 3, AD7793_CH_AVDD_MONITOR, (_b), (_sb), 0), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(5), \\\n}\n\nstatic DECLARE_AD7793_CHANNELS(ad7785, 20, 32, 4);\nstatic DECLARE_AD7793_CHANNELS(ad7792, 16, 32, 0);\nstatic DECLARE_AD7793_CHANNELS(ad7793, 24, 32, 0);\nstatic DECLARE_AD7795_CHANNELS(ad7794, 16, 32);\nstatic DECLARE_AD7795_CHANNELS(ad7795, 24, 32);\nstatic DECLARE_AD7797_CHANNELS(ad7796, 16, 16);\nstatic DECLARE_AD7797_CHANNELS(ad7797, 24, 32);\nstatic DECLARE_AD7799_CHANNELS(ad7798, 16, 16);\nstatic DECLARE_AD7799_CHANNELS(ad7799, 24, 32);\n\nstatic const struct ad7793_chip_info ad7793_chip_info_tbl[] = {\n\t[ID_AD7785] = {\n\t\t.id = AD7785_ID,\n\t\t.channels = ad7785_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7785_channels),\n\t\t.iio_info = &ad7793_info,\n\t\t.sample_freq_avail = ad7793_sample_freq_avail,\n\t\t.flags = AD7793_FLAG_HAS_CLKSEL |\n\t\t\tAD7793_FLAG_HAS_REFSEL |\n\t\t\tAD7793_FLAG_HAS_VBIAS |\n\t\t\tAD7793_HAS_EXITATION_CURRENT |\n\t\t\tAD7793_FLAG_HAS_GAIN |\n\t\t\tAD7793_FLAG_HAS_BUFFER,\n\t},\n\t[ID_AD7792] = {\n\t\t.id = AD7792_ID,\n\t\t.channels = ad7792_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7792_channels),\n\t\t.iio_info = &ad7793_info,\n\t\t.sample_freq_avail = ad7793_sample_freq_avail,\n\t\t.flags = AD7793_FLAG_HAS_CLKSEL |\n\t\t\tAD7793_FLAG_HAS_REFSEL |\n\t\t\tAD7793_FLAG_HAS_VBIAS |\n\t\t\tAD7793_HAS_EXITATION_CURRENT |\n\t\t\tAD7793_FLAG_HAS_GAIN |\n\t\t\tAD7793_FLAG_HAS_BUFFER,\n\t},\n\t[ID_AD7793] = {\n\t\t.id = AD7793_ID,\n\t\t.channels = ad7793_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7793_channels),\n\t\t.iio_info = &ad7793_info,\n\t\t.sample_freq_avail = ad7793_sample_freq_avail,\n\t\t.flags = AD7793_FLAG_HAS_CLKSEL |\n\t\t\tAD7793_FLAG_HAS_REFSEL |\n\t\t\tAD7793_FLAG_HAS_VBIAS |\n\t\t\tAD7793_HAS_EXITATION_CURRENT |\n\t\t\tAD7793_FLAG_HAS_GAIN |\n\t\t\tAD7793_FLAG_HAS_BUFFER,\n\t},\n\t[ID_AD7794] = {\n\t\t.id = AD7794_ID,\n\t\t.channels = ad7794_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7794_channels),\n\t\t.iio_info = &ad7793_info,\n\t\t.sample_freq_avail = ad7793_sample_freq_avail,\n\t\t.flags = AD7793_FLAG_HAS_CLKSEL |\n\t\t\tAD7793_FLAG_HAS_REFSEL |\n\t\t\tAD7793_FLAG_HAS_VBIAS |\n\t\t\tAD7793_HAS_EXITATION_CURRENT |\n\t\t\tAD7793_FLAG_HAS_GAIN |\n\t\t\tAD7793_FLAG_HAS_BUFFER,\n\t},\n\t[ID_AD7795] = {\n\t\t.id = AD7795_ID,\n\t\t.channels = ad7795_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7795_channels),\n\t\t.iio_info = &ad7793_info,\n\t\t.sample_freq_avail = ad7793_sample_freq_avail,\n\t\t.flags = AD7793_FLAG_HAS_CLKSEL |\n\t\t\tAD7793_FLAG_HAS_REFSEL |\n\t\t\tAD7793_FLAG_HAS_VBIAS |\n\t\t\tAD7793_HAS_EXITATION_CURRENT |\n\t\t\tAD7793_FLAG_HAS_GAIN |\n\t\t\tAD7793_FLAG_HAS_BUFFER,\n\t},\n\t[ID_AD7796] = {\n\t\t.id = AD7796_ID,\n\t\t.channels = ad7796_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7796_channels),\n\t\t.iio_info = &ad7797_info,\n\t\t.sample_freq_avail = ad7797_sample_freq_avail,\n\t\t.flags = AD7793_FLAG_HAS_CLKSEL,\n\t},\n\t[ID_AD7797] = {\n\t\t.id = AD7797_ID,\n\t\t.channels = ad7797_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7797_channels),\n\t\t.iio_info = &ad7797_info,\n\t\t.sample_freq_avail = ad7797_sample_freq_avail,\n\t\t.flags = AD7793_FLAG_HAS_CLKSEL,\n\t},\n\t[ID_AD7798] = {\n\t\t.id = AD7798_ID,\n\t\t.channels = ad7798_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7798_channels),\n\t\t.iio_info = &ad7793_info,\n\t\t.sample_freq_avail = ad7793_sample_freq_avail,\n\t\t.flags = AD7793_FLAG_HAS_GAIN |\n\t\t\tAD7793_FLAG_HAS_BUFFER,\n\t},\n\t[ID_AD7799] = {\n\t\t.id = AD7799_ID,\n\t\t.channels = ad7799_channels,\n\t\t.num_channels = ARRAY_SIZE(ad7799_channels),\n\t\t.iio_info = &ad7793_info,\n\t\t.sample_freq_avail = ad7793_sample_freq_avail,\n\t\t.flags = AD7793_FLAG_HAS_GAIN |\n\t\t\tAD7793_FLAG_HAS_BUFFER,\n\t},\n};\n\nstatic void ad7793_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int ad7793_probe(struct spi_device *spi)\n{\n\tconst struct ad7793_platform_data *pdata = spi->dev.platform_data;\n\tstruct ad7793_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret, vref_mv = 0;\n\n\tif (!pdata) {\n\t\tdev_err(&spi->dev, \"no platform data?\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!spi->irq) {\n\t\tdev_err(&spi->dev, \"no IRQ?\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tad_sd_init(&st->sd, indio_dev, spi, &ad7793_sigma_delta_info);\n\n\tif (pdata->refsel != AD7793_REFSEL_INTERNAL) {\n\t\tst->reg = devm_regulator_get(&spi->dev, \"refin\");\n\t\tif (IS_ERR(st->reg))\n\t\t\treturn PTR_ERR(st->reg);\n\n\t\tret = regulator_enable(st->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(&spi->dev, ad7793_reg_disable, st->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvref_mv = regulator_get_voltage(st->reg);\n\t\tif (vref_mv < 0)\n\t\t\treturn vref_mv;\n\n\t\tvref_mv /= 1000;\n\t} else {\n\t\tvref_mv = 1170;  \n\t}\n\n\tst->chip_info =\n\t\t&ad7793_chip_info_tbl[spi_get_device_id(spi)->driver_data];\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = st->chip_info->channels;\n\tindio_dev->num_channels = st->chip_info->num_channels;\n\tindio_dev->info = st->chip_info->iio_info;\n\n\tret = devm_ad_sd_setup_buffer_and_trigger(&spi->dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad7793_setup(indio_dev, pdata, vref_mv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad7793_id[] = {\n\t{\"ad7785\", ID_AD7785},\n\t{\"ad7792\", ID_AD7792},\n\t{\"ad7793\", ID_AD7793},\n\t{\"ad7794\", ID_AD7794},\n\t{\"ad7795\", ID_AD7795},\n\t{\"ad7796\", ID_AD7796},\n\t{\"ad7797\", ID_AD7797},\n\t{\"ad7798\", ID_AD7798},\n\t{\"ad7799\", ID_AD7799},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad7793_id);\n\nstatic struct spi_driver ad7793_driver = {\n\t.driver = {\n\t\t.name\t= \"ad7793\",\n\t},\n\t.probe\t\t= ad7793_probe,\n\t.id_table\t= ad7793_id,\n};\nmodule_spi_driver(ad7793_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7793 and similar ADCs\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_AD_SIGMA_DELTA);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}