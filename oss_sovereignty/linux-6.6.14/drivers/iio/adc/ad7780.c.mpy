{
  "module_name": "ad7780.c",
  "hash_id": "8a2927adadff8253f0ed0bd125f6384bbac3cb2425bd51e79844678524a37ea8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7780.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/bits.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/adc/ad_sigma_delta.h>\n\n#define AD7780_RDY\t\tBIT(7)\n#define AD7780_FILTER\t\tBIT(6)\n#define AD7780_ERR\t\tBIT(5)\n#define AD7780_ID1\t\tBIT(4)\n#define AD7780_ID0\t\tBIT(3)\n#define AD7780_GAIN\t\tBIT(2)\n\n#define AD7170_ID\t\t0\n#define AD7171_ID\t\t1\n#define AD7780_ID\t\t1\n#define AD7781_ID\t\t0\n\n#define AD7780_ID_MASK\t\t(AD7780_ID0 | AD7780_ID1)\n\n#define AD7780_PATTERN_GOOD\t1\n#define AD7780_PATTERN_MASK\tGENMASK(1, 0)\n\n#define AD7170_PATTERN_GOOD\t5\n#define AD7170_PATTERN_MASK\tGENMASK(2, 0)\n\n#define AD7780_GAIN_MIDPOINT\t64\n#define AD7780_FILTER_MIDPOINT\t13350\n\nstatic const unsigned int ad778x_gain[2]      = { 1, 128 };\nstatic const unsigned int ad778x_odr_avail[2] = { 10000, 16700 };\n\nstruct ad7780_chip_info {\n\tstruct iio_chan_spec\tchannel;\n\tunsigned int\t\tpattern_mask;\n\tunsigned int\t\tpattern;\n\tbool\t\t\tis_ad778x;\n};\n\nstruct ad7780_state {\n\tconst struct ad7780_chip_info\t*chip_info;\n\tstruct regulator\t\t*reg;\n\tstruct gpio_desc\t\t*powerdown_gpio;\n\tstruct gpio_desc\t\t*gain_gpio;\n\tstruct gpio_desc\t\t*filter_gpio;\n\tunsigned int\t\t\tgain;\n\tunsigned int\t\t\todr;\n\tunsigned int\t\t\tint_vref_mv;\n\n\tstruct ad_sigma_delta sd;\n};\n\nenum ad7780_supported_device_ids {\n\tID_AD7170,\n\tID_AD7171,\n\tID_AD7780,\n\tID_AD7781,\n};\n\nstatic struct ad7780_state *ad_sigma_delta_to_ad7780(struct ad_sigma_delta *sd)\n{\n\treturn container_of(sd, struct ad7780_state, sd);\n}\n\nstatic int ad7780_set_mode(struct ad_sigma_delta *sigma_delta,\n\t\t\t   enum ad_sigma_delta_mode mode)\n{\n\tstruct ad7780_state *st = ad_sigma_delta_to_ad7780(sigma_delta);\n\tunsigned int val;\n\n\tswitch (mode) {\n\tcase AD_SD_MODE_SINGLE:\n\tcase AD_SD_MODE_CONTINUOUS:\n\t\tval = 1;\n\t\tbreak;\n\tdefault:\n\t\tval = 0;\n\t\tbreak;\n\t}\n\n\tgpiod_set_value(st->powerdown_gpio, val);\n\n\treturn 0;\n}\n\nstatic int ad7780_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tstruct ad7780_state *st = iio_priv(indio_dev);\n\tint voltage_uv;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn ad_sigma_delta_single_conversion(indio_dev, chan, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tvoltage_uv = regulator_get_voltage(st->reg);\n\t\tif (voltage_uv < 0)\n\t\t\treturn voltage_uv;\n\t\tvoltage_uv /= 1000;\n\t\t*val = voltage_uv * st->gain;\n\t\t*val2 = chan->scan_type.realbits - 1;\n\t\tst->int_vref_mv = voltage_uv;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = -(1 << (chan->scan_type.realbits - 1));\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = st->odr;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ad7780_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val,\n\t\t\t    int val2,\n\t\t\t    long m)\n{\n\tstruct ad7780_state *st = iio_priv(indio_dev);\n\tconst struct ad7780_chip_info *chip_info = st->chip_info;\n\tunsigned long long vref;\n\tunsigned int full_scale, gain;\n\n\tif (!chip_info->is_ad778x)\n\t\treturn -EINVAL;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (val != 0)\n\t\t\treturn -EINVAL;\n\n\t\tvref = st->int_vref_mv * 1000000LL;\n\t\tfull_scale = 1 << (chip_info->channel.scan_type.realbits - 1);\n\t\tgain = DIV_ROUND_CLOSEST_ULL(vref, full_scale);\n\t\tgain = DIV_ROUND_CLOSEST(gain, val2);\n\t\tst->gain = gain;\n\t\tif (gain < AD7780_GAIN_MIDPOINT)\n\t\t\tgain = 0;\n\t\telse\n\t\t\tgain = 1;\n\t\tgpiod_set_value(st->gain_gpio, gain);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (1000*val + val2/1000 < AD7780_FILTER_MIDPOINT)\n\t\t\tval = 0;\n\t\telse\n\t\t\tval = 1;\n\t\tst->odr = ad778x_odr_avail[val];\n\t\tgpiod_set_value(st->filter_gpio, val);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad7780_postprocess_sample(struct ad_sigma_delta *sigma_delta,\n\t\t\t\t     unsigned int raw_sample)\n{\n\tstruct ad7780_state *st = ad_sigma_delta_to_ad7780(sigma_delta);\n\tconst struct ad7780_chip_info *chip_info = st->chip_info;\n\n\tif ((raw_sample & AD7780_ERR) ||\n\t    ((raw_sample & chip_info->pattern_mask) != chip_info->pattern))\n\t\treturn -EIO;\n\n\tif (chip_info->is_ad778x) {\n\t\tst->gain = ad778x_gain[raw_sample & AD7780_GAIN];\n\t\tst->odr = ad778x_odr_avail[raw_sample & AD7780_FILTER];\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ad_sigma_delta_info ad7780_sigma_delta_info = {\n\t.set_mode = ad7780_set_mode,\n\t.postprocess_sample = ad7780_postprocess_sample,\n\t.has_registers = false,\n\t.irq_flags = IRQF_TRIGGER_FALLING,\n};\n\n#define _AD7780_CHANNEL(_bits, _wordsize, _mask_all)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = 0,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_OFFSET),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.info_mask_shared_by_all = _mask_all,\t\t\t\\\n\t.scan_index = 1,\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = (_bits),\t\t\t\t\\\n\t\t.storagebits = 32,\t\t\t\t\\\n\t\t.shift = (_wordsize) - (_bits),\t\t\t\\\n\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\n#define AD7780_CHANNEL(_bits, _wordsize)\t\\\n\t_AD7780_CHANNEL(_bits, _wordsize, BIT(IIO_CHAN_INFO_SAMP_FREQ))\n#define AD7170_CHANNEL(_bits, _wordsize)\t\\\n\t_AD7780_CHANNEL(_bits, _wordsize, 0)\n\nstatic const struct ad7780_chip_info ad7780_chip_info_tbl[] = {\n\t[ID_AD7170] = {\n\t\t.channel = AD7170_CHANNEL(12, 24),\n\t\t.pattern = AD7170_PATTERN_GOOD,\n\t\t.pattern_mask = AD7170_PATTERN_MASK,\n\t\t.is_ad778x = false,\n\t},\n\t[ID_AD7171] = {\n\t\t.channel = AD7170_CHANNEL(16, 24),\n\t\t.pattern = AD7170_PATTERN_GOOD,\n\t\t.pattern_mask = AD7170_PATTERN_MASK,\n\t\t.is_ad778x = false,\n\t},\n\t[ID_AD7780] = {\n\t\t.channel = AD7780_CHANNEL(24, 32),\n\t\t.pattern = AD7780_PATTERN_GOOD,\n\t\t.pattern_mask = AD7780_PATTERN_MASK,\n\t\t.is_ad778x = true,\n\t},\n\t[ID_AD7781] = {\n\t\t.channel = AD7780_CHANNEL(20, 32),\n\t\t.pattern = AD7780_PATTERN_GOOD,\n\t\t.pattern_mask = AD7780_PATTERN_MASK,\n\t\t.is_ad778x = true,\n\t},\n};\n\nstatic const struct iio_info ad7780_info = {\n\t.read_raw = ad7780_read_raw,\n\t.write_raw = ad7780_write_raw,\n};\n\nstatic int ad7780_init_gpios(struct device *dev, struct ad7780_state *st)\n{\n\tint ret;\n\n\tst->powerdown_gpio = devm_gpiod_get_optional(dev,\n\t\t\t\t\t\t     \"powerdown\",\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(st->powerdown_gpio)) {\n\t\tret = PTR_ERR(st->powerdown_gpio);\n\t\tdev_err(dev, \"Failed to request powerdown GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!st->chip_info->is_ad778x)\n\t\treturn 0;\n\n\n\tst->gain_gpio = devm_gpiod_get_optional(dev,\n\t\t\t\t\t\t\"adi,gain\",\n\t\t\t\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(st->gain_gpio)) {\n\t\tret = PTR_ERR(st->gain_gpio);\n\t\tdev_err(dev, \"Failed to request gain GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tst->filter_gpio = devm_gpiod_get_optional(dev,\n\t\t\t\t\t\t  \"adi,filter\",\n\t\t\t\t\t\t  GPIOD_OUT_HIGH);\n\tif (IS_ERR(st->filter_gpio)) {\n\t\tret = PTR_ERR(st->filter_gpio);\n\t\tdev_err(dev, \"Failed to request filter GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ad7780_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int ad7780_probe(struct spi_device *spi)\n{\n\tstruct ad7780_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tst->gain = 1;\n\n\tad_sd_init(&st->sd, indio_dev, spi, &ad7780_sigma_delta_info);\n\n\tst->chip_info =\n\t\t&ad7780_chip_info_tbl[spi_get_device_id(spi)->driver_data];\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = &st->chip_info->channel;\n\tindio_dev->num_channels = 1;\n\tindio_dev->info = &ad7780_info;\n\n\tret = ad7780_init_gpios(&spi->dev, st);\n\tif (ret)\n\t\treturn ret;\n\n\tst->reg = devm_regulator_get(&spi->dev, \"avdd\");\n\tif (IS_ERR(st->reg))\n\t\treturn PTR_ERR(st->reg);\n\n\tret = regulator_enable(st->reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to enable specified AVdd supply\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&spi->dev, ad7780_reg_disable, st->reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_ad_sd_setup_buffer_and_trigger(&spi->dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad7780_id[] = {\n\t{\"ad7170\", ID_AD7170},\n\t{\"ad7171\", ID_AD7171},\n\t{\"ad7780\", ID_AD7780},\n\t{\"ad7781\", ID_AD7781},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad7780_id);\n\nstatic struct spi_driver ad7780_driver = {\n\t.driver = {\n\t\t.name\t= \"ad7780\",\n\t},\n\t.probe\t\t= ad7780_probe,\n\t.id_table\t= ad7780_id,\n};\nmodule_spi_driver(ad7780_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7780 and similar ADCs\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_AD_SIGMA_DELTA);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}