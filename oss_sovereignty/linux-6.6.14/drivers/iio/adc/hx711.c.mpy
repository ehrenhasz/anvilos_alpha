{
  "module_name": "hx711.c",
  "hash_id": "e8c6b8e808e4f049a0a21b356b9a21153f2bd94a251e08c9160c5d746c48c5fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/hx711.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n\n \n#define HX711_GAIN_MAX\t\t3\n#define HX711_RESET_GAIN\t128\n\nstruct hx711_gain_to_scale {\n\tint\t\t\tgain;\n\tint\t\t\tgain_pulse;\n\tint\t\t\tscale;\n\tint\t\t\tchannel;\n};\n\n \nstatic struct hx711_gain_to_scale hx711_gain_to_scale[HX711_GAIN_MAX] = {\n\t{ 128, 1, 0, 0 },\n\t{  32, 2, 0, 1 },\n\t{  64, 3, 0, 0 }\n};\n\nstatic int hx711_get_gain_to_pulse(int gain)\n{\n\tint i;\n\n\tfor (i = 0; i < HX711_GAIN_MAX; i++)\n\t\tif (hx711_gain_to_scale[i].gain == gain)\n\t\t\treturn hx711_gain_to_scale[i].gain_pulse;\n\treturn 1;\n}\n\nstatic int hx711_get_gain_to_scale(int gain)\n{\n\tint i;\n\n\tfor (i = 0; i < HX711_GAIN_MAX; i++)\n\t\tif (hx711_gain_to_scale[i].gain == gain)\n\t\t\treturn hx711_gain_to_scale[i].scale;\n\treturn 0;\n}\n\nstatic int hx711_get_scale_to_gain(int scale)\n{\n\tint i;\n\n\tfor (i = 0; i < HX711_GAIN_MAX; i++)\n\t\tif (hx711_gain_to_scale[i].scale == scale)\n\t\t\treturn hx711_gain_to_scale[i].gain;\n\treturn -EINVAL;\n}\n\nstruct hx711_data {\n\tstruct device\t\t*dev;\n\tstruct gpio_desc\t*gpiod_pd_sck;\n\tstruct gpio_desc\t*gpiod_dout;\n\tstruct regulator\t*reg_avdd;\n\tint\t\t\tgain_set;\t \n\tint\t\t\tgain_chan_a;\t \n\tstruct mutex\t\tlock;\n\t \n\tu32\t\t\tbuffer[4] __aligned(8);\n\t \n\tu32\t\t\tdata_ready_delay_ns;\n\tu32\t\t\tclock_frequency;\n};\n\nstatic int hx711_cycle(struct hx711_data *hx711_data)\n{\n\tunsigned long flags;\n\n\t \n\tlocal_irq_save(flags);\n\tgpiod_set_value(hx711_data->gpiod_pd_sck, 1);\n\n\t \n\tndelay(hx711_data->data_ready_delay_ns);\n\n\t \n\tgpiod_set_value(hx711_data->gpiod_pd_sck, 0);\n\tlocal_irq_restore(flags);\n\n\t \n\tndelay(hx711_data->data_ready_delay_ns);\n\n\t \n\treturn gpiod_get_value(hx711_data->gpiod_dout);\n}\n\nstatic int hx711_read(struct hx711_data *hx711_data)\n{\n\tint i, ret;\n\tint value = 0;\n\tint val = gpiod_get_value(hx711_data->gpiod_dout);\n\n\t \n\tif (val)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < 24; i++) {\n\t\tvalue <<= 1;\n\t\tret = hx711_cycle(hx711_data);\n\t\tif (ret)\n\t\t\tvalue++;\n\t}\n\n\tvalue ^= 0x800000;\n\n\tfor (i = 0; i < hx711_get_gain_to_pulse(hx711_data->gain_set); i++)\n\t\thx711_cycle(hx711_data);\n\n\treturn value;\n}\n\nstatic int hx711_wait_for_ready(struct hx711_data *hx711_data)\n{\n\tint i, val;\n\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\tval = gpiod_get_value(hx711_data->gpiod_dout);\n\t\tif (!val)\n\t\t\tbreak;\n\t\t \n\t\tmsleep(10);\n\t}\n\tif (val)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int hx711_reset(struct hx711_data *hx711_data)\n{\n\tint val = hx711_wait_for_ready(hx711_data);\n\n\tif (val) {\n\t\t \n\t\tgpiod_set_value(hx711_data->gpiod_pd_sck, 1);\n\t\tmsleep(10);\n\t\tgpiod_set_value(hx711_data->gpiod_pd_sck, 0);\n\n\t\tval = hx711_wait_for_ready(hx711_data);\n\n\t\t \n\t\thx711_data->gain_set = HX711_RESET_GAIN;\n\t}\n\n\treturn val;\n}\n\nstatic int hx711_set_gain_for_channel(struct hx711_data *hx711_data, int chan)\n{\n\tint ret;\n\n\tif (chan == 0) {\n\t\tif (hx711_data->gain_set == 32) {\n\t\t\thx711_data->gain_set = hx711_data->gain_chan_a;\n\n\t\t\tret = hx711_read(hx711_data);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tret = hx711_wait_for_ready(hx711_data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (hx711_data->gain_set != 32) {\n\t\t\thx711_data->gain_set = 32;\n\n\t\t\tret = hx711_read(hx711_data);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tret = hx711_wait_for_ready(hx711_data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hx711_reset_read(struct hx711_data *hx711_data, int chan)\n{\n\tint ret;\n\tint val;\n\n\t \n\tif (hx711_reset(hx711_data)) {\n\t\tdev_err(hx711_data->dev, \"reset failed!\");\n\t\treturn -EIO;\n\t}\n\n\tret = hx711_set_gain_for_channel(hx711_data, chan);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = hx711_read(hx711_data);\n\n\treturn val;\n}\n\nstatic int hx711_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tstruct hx711_data *hx711_data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&hx711_data->lock);\n\n\t\t*val = hx711_reset_read(hx711_data, chan->channel);\n\n\t\tmutex_unlock(&hx711_data->lock);\n\n\t\tif (*val < 0)\n\t\t\treturn *val;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\tmutex_lock(&hx711_data->lock);\n\n\t\t*val2 = hx711_get_gain_to_scale(hx711_data->gain_set);\n\n\t\tmutex_unlock(&hx711_data->lock);\n\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int hx711_write_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint val,\n\t\t\t\tint val2,\n\t\t\t\tlong mask)\n{\n\tstruct hx711_data *hx711_data = iio_priv(indio_dev);\n\tint ret;\n\tint gain;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\tif (val != 0)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&hx711_data->lock);\n\n\t\tgain = hx711_get_scale_to_gain(val2);\n\t\tif (gain < 0) {\n\t\t\tmutex_unlock(&hx711_data->lock);\n\t\t\treturn gain;\n\t\t}\n\n\t\tif (gain != hx711_data->gain_set) {\n\t\t\thx711_data->gain_set = gain;\n\t\t\tif (gain != 32)\n\t\t\t\thx711_data->gain_chan_a = gain;\n\n\t\t\tret = hx711_read(hx711_data);\n\t\t\tif (ret < 0) {\n\t\t\t\tmutex_unlock(&hx711_data->lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tmutex_unlock(&hx711_data->lock);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hx711_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\tstruct iio_chan_spec const *chan,\n\t\tlong mask)\n{\n\treturn IIO_VAL_INT_PLUS_NANO;\n}\n\nstatic irqreturn_t hx711_trigger(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct hx711_data *hx711_data = iio_priv(indio_dev);\n\tint i, j = 0;\n\n\tmutex_lock(&hx711_data->lock);\n\n\tmemset(hx711_data->buffer, 0, sizeof(hx711_data->buffer));\n\n\tfor (i = 0; i < indio_dev->masklength; i++) {\n\t\tif (!test_bit(i, indio_dev->active_scan_mask))\n\t\t\tcontinue;\n\n\t\thx711_data->buffer[j] = hx711_reset_read(hx711_data,\n\t\t\t\t\tindio_dev->channels[i].channel);\n\t\tj++;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, hx711_data->buffer,\n\t\t\t\t\t\t\tpf->timestamp);\n\n\tmutex_unlock(&hx711_data->lock);\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic ssize_t hx711_scale_available_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct iio_dev_attr *iio_attr = to_iio_dev_attr(attr);\n\tint channel = iio_attr->address;\n\tint i, len = 0;\n\n\tfor (i = 0; i < HX711_GAIN_MAX; i++)\n\t\tif (hx711_gain_to_scale[i].channel == channel)\n\t\t\tlen += sprintf(buf + len, \"0.%09d \",\n\t\t\t\t\thx711_gain_to_scale[i].scale);\n\n\tlen += sprintf(buf + len, \"\\n\");\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(in_voltage0_scale_available, S_IRUGO,\n\thx711_scale_available_show, NULL, 0);\n\nstatic IIO_DEVICE_ATTR(in_voltage1_scale_available, S_IRUGO,\n\thx711_scale_available_show, NULL, 1);\n\nstatic struct attribute *hx711_attributes[] = {\n\t&iio_dev_attr_in_voltage0_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage1_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group hx711_attribute_group = {\n\t.attrs = hx711_attributes,\n};\n\nstatic const struct iio_info hx711_iio_info = {\n\t.read_raw\t\t= hx711_read_raw,\n\t.write_raw\t\t= hx711_write_raw,\n\t.write_raw_get_fmt\t= hx711_write_raw_get_fmt,\n\t.attrs\t\t\t= &hx711_attribute_group,\n};\n\nstatic const struct iio_chan_spec hx711_chan_spec[] = {\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.channel = 0,\n\t\t.indexed = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 24,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.channel = 1,\n\t\t.indexed = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 1,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 24,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(2),\n};\n\nstatic int hx711_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct hx711_data *hx711_data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\tint i;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(struct hx711_data));\n\tif (!indio_dev) {\n\t\tdev_err(dev, \"failed to allocate IIO device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thx711_data = iio_priv(indio_dev);\n\thx711_data->dev = dev;\n\n\tmutex_init(&hx711_data->lock);\n\n\t \n\thx711_data->gpiod_pd_sck = devm_gpiod_get(dev, \"sck\", GPIOD_OUT_LOW);\n\tif (IS_ERR(hx711_data->gpiod_pd_sck)) {\n\t\tdev_err(dev, \"failed to get sck-gpiod: err=%ld\\n\",\n\t\t\t\t\tPTR_ERR(hx711_data->gpiod_pd_sck));\n\t\treturn PTR_ERR(hx711_data->gpiod_pd_sck);\n\t}\n\n\t \n\thx711_data->gpiod_dout = devm_gpiod_get(dev, \"dout\", GPIOD_IN);\n\tif (IS_ERR(hx711_data->gpiod_dout)) {\n\t\tdev_err(dev, \"failed to get dout-gpiod: err=%ld\\n\",\n\t\t\t\t\tPTR_ERR(hx711_data->gpiod_dout));\n\t\treturn PTR_ERR(hx711_data->gpiod_dout);\n\t}\n\n\thx711_data->reg_avdd = devm_regulator_get(dev, \"avdd\");\n\tif (IS_ERR(hx711_data->reg_avdd))\n\t\treturn PTR_ERR(hx711_data->reg_avdd);\n\n\tret = regulator_enable(hx711_data->reg_avdd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regulator_get_voltage(hx711_data->reg_avdd);\n\tif (ret < 0)\n\t\tgoto error_regulator;\n\n\t \n\tret *= 100;\n\n\tfor (i = 0; i < HX711_GAIN_MAX; i++)\n\t\thx711_gain_to_scale[i].scale =\n\t\t\tret / hx711_gain_to_scale[i].gain / 1678;\n\n\thx711_data->gain_set = 128;\n\thx711_data->gain_chan_a = 128;\n\n\thx711_data->clock_frequency = 400000;\n\tret = of_property_read_u32(np, \"clock-frequency\",\n\t\t\t\t\t&hx711_data->clock_frequency);\n\n\t \n\tif (hx711_data->clock_frequency < 20000) {\n\t\tdev_warn(dev, \"clock-frequency too low - assuming 400 kHz\\n\");\n\t\thx711_data->clock_frequency = 400000;\n\t}\n\n\thx711_data->data_ready_delay_ns =\n\t\t\t\t1000000000 / hx711_data->clock_frequency;\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tindio_dev->name = \"hx711\";\n\tindio_dev->info = &hx711_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = hx711_chan_spec;\n\tindio_dev->num_channels = ARRAY_SIZE(hx711_chan_spec);\n\n\tret = iio_triggered_buffer_setup(indio_dev, iio_pollfunc_store_time,\n\t\t\t\t\t\t\thx711_trigger, NULL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"setup of iio triggered buffer failed\\n\");\n\t\tgoto error_regulator;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Couldn't register the device\\n\");\n\t\tgoto error_buffer;\n\t}\n\n\treturn 0;\n\nerror_buffer:\n\tiio_triggered_buffer_cleanup(indio_dev);\n\nerror_regulator:\n\tregulator_disable(hx711_data->reg_avdd);\n\n\treturn ret;\n}\n\nstatic int hx711_remove(struct platform_device *pdev)\n{\n\tstruct hx711_data *hx711_data;\n\tstruct iio_dev *indio_dev;\n\n\tindio_dev = platform_get_drvdata(pdev);\n\thx711_data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tiio_triggered_buffer_cleanup(indio_dev);\n\n\tregulator_disable(hx711_data->reg_avdd);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_hx711_match[] = {\n\t{ .compatible = \"avia,hx711\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, of_hx711_match);\n\nstatic struct platform_driver hx711_driver = {\n\t.probe\t\t= hx711_probe,\n\t.remove\t\t= hx711_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"hx711-gpio\",\n\t\t.of_match_table\t= of_hx711_match,\n\t},\n};\n\nmodule_platform_driver(hx711_driver);\n\nMODULE_AUTHOR(\"Andreas Klinger <ak@it-klinger.de>\");\nMODULE_DESCRIPTION(\"HX711 bitbanging driver - ADC for weight cells\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:hx711-gpio\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}