{
  "module_name": "at91-sama5d2_adc.c",
  "hash_id": "8b229aaef480ea3720cca486a290825edea34ab431df2192f34ea21643433f04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/at91-sama5d2_adc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/sched.h>\n#include <linux/units.h>\n#include <linux/wait.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n\n#include <dt-bindings/iio/adc/at91-sama5d2_adc.h>\n\nstruct at91_adc_reg_layout {\n \n\tu16\t\t\t\tCR;\n \n#define\tAT91_SAMA5D2_CR_SWRST\t\tBIT(0)\n \n#define\tAT91_SAMA5D2_CR_START\t\tBIT(1)\n \n#define\tAT91_SAMA5D2_CR_TSCALIB\t\tBIT(2)\n \n#define\tAT91_SAMA5D2_CR_CMPRST\t\tBIT(4)\n\n \n\tu16\t\t\t\tMR;\n \n#define\tAT91_SAMA5D2_MR_TRGSEL(v)\t((v) << 1)\n \n#define\tAT91_SAMA5D2_MR_TRGSEL_TRIG0\t0\n \n#define\tAT91_SAMA5D2_MR_TRGSEL_TRIG1\t1\n \n#define\tAT91_SAMA5D2_MR_TRGSEL_TRIG2\t2\n \n#define\tAT91_SAMA5D2_MR_TRGSEL_TRIG3\t3\n \n#define\tAT91_SAMA5D2_MR_TRGSEL_TRIG4\t4\n \n#define\tAT91_SAMA5D2_MR_TRGSEL_TRIG5\t5\n \n#define\tAT91_SAMA5D2_MR_TRGSEL_TRIG6\t6\n \n#define\tAT91_SAMA5D2_MR_TRGSEL_TRIG7\t7\n \n#define\tAT91_SAMA5D2_MR_SLEEP\t\tBIT(5)\n \n#define\tAT91_SAMA5D2_MR_FWUP\t\tBIT(6)\n \n#define\tAT91_SAMA5D2_MR_PRESCAL(v)\t((v) << AT91_SAMA5D2_MR_PRESCAL_OFFSET)\n#define\tAT91_SAMA5D2_MR_PRESCAL_OFFSET\t8\n#define\tAT91_SAMA5D2_MR_PRESCAL_MAX\t0xff\n#define AT91_SAMA5D2_MR_PRESCAL_MASK\tGENMASK(15, 8)\n \n#define\tAT91_SAMA5D2_MR_STARTUP(v)\t((v) << 16)\n#define AT91_SAMA5D2_MR_STARTUP_MASK\tGENMASK(19, 16)\n \n#define AT91_SAMA5D2_MR_STARTUP_TS_MIN\t(50)\n \n#define\tAT91_SAMA5D2_MR_ANACH\t\tBIT(23)\n \n#define\tAT91_SAMA5D2_MR_TRACKTIM(v)\t((v) << 24)\n#define\tAT91_SAMA5D2_MR_TRACKTIM_TS\t6\n#define\tAT91_SAMA5D2_MR_TRACKTIM_MAX\t0xf\n \n#define\tAT91_SAMA5D2_MR_TRANSFER(v)\t((v) << 28)\n#define\tAT91_SAMA5D2_MR_TRANSFER_MAX\t0x3\n \n#define\tAT91_SAMA5D2_MR_USEQ\t\tBIT(31)\n\n \n\tu16\t\t\t\tSEQR1;\n \n\tu16\t\t\t\tSEQR2;\n \n\tu16\t\t\t\tCHER;\n \n\tu16\t\t\t\tCHDR;\n \n\tu16\t\t\t\tCHSR;\n \n\tu16\t\t\t\tLCDR;\n \n\tu16\t\t\t\tIER;\n \n#define AT91_SAMA5D2_IER_XRDY   BIT(20)\n \n#define AT91_SAMA5D2_IER_YRDY   BIT(21)\n \n#define AT91_SAMA5D2_IER_PRDY   BIT(22)\n \n#define AT91_SAMA5D2_IER_DRDY   BIT(24)\n \n#define AT91_SAMA5D2_IER_GOVRE BIT(25)\n \n#define AT91_SAMA5D2_IER_PEN    BIT(29)\n \n#define AT91_SAMA5D2_IER_NOPEN  BIT(30)\n\n \n\tu16\t\t\t\tIDR;\n \n\tu16\t\t\t\tIMR;\n \n\tu16\t\t\t\tISR;\n \n\tu16\t\t\t\tEOC_IER;\n \n\tu16\t\t\t\tEOC_IDR;\n \n\tu16\t\t\t\tEOC_IMR;\n \n\tu16\t\t\t\tEOC_ISR;\n \n#define AT91_SAMA5D2_ISR_PENS   BIT(31)\n \n\tu16\t\t\t\tLCTMR;\n \n\tu16\t\t\t\tLCCWR;\n \n\tu16\t\t\t\tOVER;\n \n\tu16\t\t\t\tEMR;\n \n#define AT91_SAMA5D2_EMR_OSR(V, M)\t\t(((V) << 16) & (M))\n#define AT91_SAMA5D2_EMR_OSR_1SAMPLES\t\t0\n#define AT91_SAMA5D2_EMR_OSR_4SAMPLES\t\t1\n#define AT91_SAMA5D2_EMR_OSR_16SAMPLES\t\t2\n#define AT91_SAMA5D2_EMR_OSR_64SAMPLES\t\t3\n#define AT91_SAMA5D2_EMR_OSR_256SAMPLES\t\t4\n\n \n#define AT91_SAMA5D2_TRACKX_MASK\t\tGENMASK(23, 22)\n#define AT91_SAMA5D2_TRACKX(x)\t\t\t(((x) << 22) & \\\n\t\t\t\t\t\t AT91_SAMA5D2_TRACKX_MASK)\n \n#define AT91_SAMA5D2_TRACKX_TS\t\t\t(1)\n\n \n#define AT91_SAMA5D2_EMR_ASTE(V)\t\t((V) << 20)\n\n \n\tu16\t\t\t\tCWR;\n \n\tu16\t\t\t\tCGR;\n \n\tu16\t\t\t\tCOR;\n \n\tu16\t\t\t\tCOR_diff_offset;\n \n\tu16\t\t\t\tACR;\n \n#define AT91_SAMA5D2_ACR_PENDETSENS_MASK        GENMASK(1, 0)\n \n#define AT91_SAMA5D2_ACR_SRCLCH\t\tBIT(16)\n\n \n\tu16\t\t\t\tTSMR;\n \n#define AT91_SAMA5D2_TSMR_TSMODE_NONE           0\n \n#define AT91_SAMA5D2_TSMR_TSMODE_4WIRE_NO_PRESS 1\n \n#define AT91_SAMA5D2_TSMR_TSMODE_4WIRE_PRESS    2\n \n#define AT91_SAMA5D2_TSMR_TSMODE_5WIRE          3\n \n#define AT91_SAMA5D2_TSMR_TSAV_MASK             GENMASK(5, 4)\n \n#define AT91_SAMA5D2_TSMR_TSAV(x)               ((x) << 4)\n \n#define AT91_SAMA5D2_TSMR_TSFREQ_MASK           GENMASK(11, 8)\n \n#define AT91_SAMA5D2_TSMR_TSFREQ(x)             ((x) << 8)\n \n#define AT91_SAMA5D2_TSMR_PENDBC_MASK           GENMASK(31, 28)\n \n#define AT91_SAMA5D2_TSMR_PENDBC(x)            ((x) << 28)\n \n#define AT91_SAMA5D2_TSMR_NOTSDMA               BIT(22)\n \n#define AT91_SAMA5D2_TSMR_PENDET_DIS            (0 << 24)\n \n#define AT91_SAMA5D2_TSMR_PENDET_ENA            BIT(24)\n\n \n\tu16\t\t\t\tXPOSR;\n \n\tu16\t\t\t\tYPOSR;\n \n\tu16\t\t\t\tPRESSR;\n \n\tu16\t\t\t\tTRGR;\n \n#define AT91_SAMA5D2_TRGR_TRGMOD_MASK GENMASK(2, 0)\n \n#define AT91_SAMA5D2_TRGR_TRGMOD_NO_TRIGGER 0\n \n#define AT91_SAMA5D2_TRGR_TRGMOD_EXT_TRIG_RISE 1\n \n#define AT91_SAMA5D2_TRGR_TRGMOD_EXT_TRIG_FALL 2\n \n#define AT91_SAMA5D2_TRGR_TRGMOD_EXT_TRIG_ANY 3\n \n#define AT91_SAMA5D2_TRGR_TRGMOD_PERIODIC 5\n \n#define AT91_SAMA5D2_TRGR_TRGPER_MASK           GENMASK(31, 16)\n \n#define AT91_SAMA5D2_TRGR_TRGPER(x)             ((x) << 16)\n\n \n\tu16\t\t\t\tCOSR;\n \n\tu16\t\t\t\tCVR;\n \n\tu16\t\t\t\tCECR;\n \n\tu16\t\t\t\tWPMR;\n \n\tu16\t\t\t\tWPSR;\n \n\tu16\t\t\t\tVERSION;\n \n\tu16\t\t\t\tTEMPMR;\n \n#define AT91_SAMA5D2_TEMPMR_TEMPON\tBIT(0)\n};\n\nstatic const struct at91_adc_reg_layout sama5d2_layout = {\n\t.CR =\t\t\t0x00,\n\t.MR =\t\t\t0x04,\n\t.SEQR1 =\t\t0x08,\n\t.SEQR2 =\t\t0x0c,\n\t.CHER =\t\t\t0x10,\n\t.CHDR =\t\t\t0x14,\n\t.CHSR =\t\t\t0x18,\n\t.LCDR =\t\t\t0x20,\n\t.IER =\t\t\t0x24,\n\t.IDR =\t\t\t0x28,\n\t.IMR =\t\t\t0x2c,\n\t.ISR =\t\t\t0x30,\n\t.LCTMR =\t\t0x34,\n\t.LCCWR =\t\t0x38,\n\t.OVER =\t\t\t0x3c,\n\t.EMR =\t\t\t0x40,\n\t.CWR =\t\t\t0x44,\n\t.CGR =\t\t\t0x48,\n\t.COR =\t\t\t0x4c,\n\t.COR_diff_offset =\t16,\n\t.ACR =\t\t\t0x94,\n\t.TSMR =\t\t\t0xb0,\n\t.XPOSR =\t\t0xb4,\n\t.YPOSR =\t\t0xb8,\n\t.PRESSR =\t\t0xbc,\n\t.TRGR =\t\t\t0xc0,\n\t.COSR =\t\t\t0xd0,\n\t.CVR =\t\t\t0xd4,\n\t.CECR =\t\t\t0xd8,\n\t.WPMR =\t\t\t0xe4,\n\t.WPSR =\t\t\t0xe8,\n\t.VERSION =\t\t0xfc,\n};\n\nstatic const struct at91_adc_reg_layout sama7g5_layout = {\n\t.CR =\t\t\t0x00,\n\t.MR =\t\t\t0x04,\n\t.SEQR1 =\t\t0x08,\n\t.SEQR2 =\t\t0x0c,\n\t.CHER =\t\t\t0x10,\n\t.CHDR =\t\t\t0x14,\n\t.CHSR =\t\t\t0x18,\n\t.LCDR =\t\t\t0x20,\n\t.IER =\t\t\t0x24,\n\t.IDR =\t\t\t0x28,\n\t.IMR =\t\t\t0x2c,\n\t.ISR =\t\t\t0x30,\n\t.EOC_IER =\t\t0x34,\n\t.EOC_IDR =\t\t0x38,\n\t.EOC_IMR =\t\t0x3c,\n\t.EOC_ISR =\t\t0x40,\n\t.TEMPMR =\t\t0x44,\n\t.OVER =\t\t\t0x4c,\n\t.EMR =\t\t\t0x50,\n\t.CWR =\t\t\t0x54,\n\t.COR =\t\t\t0x5c,\n\t.COR_diff_offset =\t0,\n\t.ACR =\t\t\t0xe0,\n\t.TRGR =\t\t\t0x100,\n\t.COSR =\t\t\t0x104,\n\t.CVR =\t\t\t0x108,\n\t.CECR =\t\t\t0x10c,\n\t.WPMR =\t\t\t0x118,\n\t.WPSR =\t\t\t0x11c,\n\t.VERSION =\t\t0x130,\n};\n\n#define AT91_SAMA5D2_TOUCH_SAMPLE_PERIOD_US          2000     \n#define AT91_SAMA5D2_TOUCH_PEN_DETECT_DEBOUNCE_US    200\n\n#define AT91_SAMA5D2_XYZ_MASK\t\tGENMASK(11, 0)\n\n#define AT91_SAMA5D2_MAX_POS_BITS\t\t\t12\n\n#define AT91_HWFIFO_MAX_SIZE_STR\t\"128\"\n#define AT91_HWFIFO_MAX_SIZE\t\t128\n\n#define AT91_SAMA5D2_CHAN_SINGLE(index, num, addr)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t\t.channel = num,\t\t\t\t\t\t\\\n\t\t.address = addr,\t\t\t\t\t\\\n\t\t.scan_index = index,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t\t.realbits = 14,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ)|\\\n\t\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\t\\\n\t\t.info_mask_shared_by_all_available =\t\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\t\\\n\t\t.datasheet_name = \"CH\"#num,\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t}\n\n#define AT91_SAMA5D2_CHAN_DIFF(index, num, num2, addr)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t\t.differential = 1,\t\t\t\t\t\\\n\t\t.channel = num,\t\t\t\t\t\t\\\n\t\t.channel2 = num2,\t\t\t\t\t\\\n\t\t.address = addr,\t\t\t\t\t\\\n\t\t.scan_index = index,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\t\\\n\t\t\t.realbits = 14,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ)|\\\n\t\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\t\\\n\t\t.info_mask_shared_by_all_available =\t\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\t\\\n\t\t.datasheet_name = \"CH\"#num\"-CH\"#num2,\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t}\n\n#define AT91_SAMA5D2_CHAN_TOUCH(num, name, mod)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_POSITIONRELATIVE,\t\t\t\t\\\n\t\t.modified = 1,\t\t\t\t\t\t\\\n\t\t.channel = num,\t\t\t\t\t\t\\\n\t\t.channel2 = mod,\t\t\t\t\t\\\n\t\t.scan_index = num,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t\t.realbits = 12,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ)|\\\n\t\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\t\\\n\t\t.info_mask_shared_by_all_available =\t\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\t\\\n\t\t.datasheet_name = name,\t\t\t\t\t\\\n\t}\n#define AT91_SAMA5D2_CHAN_PRESSURE(num, name)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_PRESSURE,\t\t\t\t\t\\\n\t\t.channel = num,\t\t\t\t\t\t\\\n\t\t.scan_index = num,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t\t.realbits = 12,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ)|\\\n\t\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\t\\\n\t\t.info_mask_shared_by_all_available =\t\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\t\\\n\t\t.datasheet_name = name,\t\t\t\t\t\\\n\t}\n\n#define AT91_SAMA5D2_CHAN_TEMP(num, name, addr)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_TEMP,\t\t\t\t\t\\\n\t\t.channel = num,\t\t\t\t\t\t\\\n\t\t.address =  addr,\t\t\t\t\t\\\n\t\t.scan_index = num,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\t\\\n\t\t.info_mask_shared_by_all =\t\t\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_PROCESSED) |\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\t\\\n\t\t.info_mask_shared_by_all_available =\t\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\t\\\n\t\t.datasheet_name = name,\t\t\t\t\t\\\n\t}\n\n#define at91_adc_readl(st, reg)\t\t\t\t\t\t\\\n\treadl_relaxed((st)->base + (st)->soc_info.platform->layout->reg)\n#define at91_adc_read_chan(st, reg)\t\t\t\t\t\\\n\treadl_relaxed((st)->base + reg)\n#define at91_adc_writel(st, reg, val)\t\t\t\t\t\\\n\twritel_relaxed(val, (st)->base + (st)->soc_info.platform->layout->reg)\n\n \nstruct at91_adc_platform {\n\tconst struct at91_adc_reg_layout\t*layout;\n\tconst struct iio_chan_spec\t\t(*adc_channels)[];\n\tunsigned int\t\t\t\tnr_channels;\n\tunsigned int\t\t\t\ttouch_chan_x;\n\tunsigned int\t\t\t\ttouch_chan_y;\n\tunsigned int\t\t\t\ttouch_chan_p;\n\tunsigned int\t\t\t\tmax_channels;\n\tunsigned int\t\t\t\tmax_index;\n\tunsigned int\t\t\t\thw_trig_cnt;\n\tunsigned int\t\t\t\tosr_mask;\n\tunsigned int\t\t\t\toversampling_avail[5];\n\tunsigned int\t\t\t\toversampling_avail_no;\n\tunsigned int\t\t\t\tchan_realbits;\n\tunsigned int\t\t\t\ttemp_chan;\n\tbool\t\t\t\t\ttemp_sensor;\n};\n\n \nstruct at91_adc_temp_sensor_clb {\n\tu32 p1;\n\tu32 p4;\n\tu32 p6;\n};\n\n \nenum at91_adc_ts_clb_idx {\n\tAT91_ADC_TS_CLB_IDX_P1 = 2,\n\tAT91_ADC_TS_CLB_IDX_P4 = 5,\n\tAT91_ADC_TS_CLB_IDX_P6 = 7,\n\tAT91_ADC_TS_CLB_IDX_MAX = 19,\n};\n\n \n#define AT91_ADC_TS_VTEMP_DT\t\t(2080U)\n\n \nstruct at91_adc_soc_info {\n\tunsigned\t\t\tstartup_time;\n\tunsigned\t\t\tmin_sample_rate;\n\tunsigned\t\t\tmax_sample_rate;\n\tconst struct at91_adc_platform\t*platform;\n\tstruct at91_adc_temp_sensor_clb\ttemp_sensor_clb;\n};\n\nstruct at91_adc_trigger {\n\tchar\t\t\t\t*name;\n\tunsigned int\t\t\ttrgmod_value;\n\tunsigned int\t\t\tedge_type;\n\tbool\t\t\t\thw_trig;\n};\n\n \nstruct at91_adc_dma {\n\tstruct dma_chan\t\t\t*dma_chan;\n\tu8\t\t\t\t*rx_buf;\n\tdma_addr_t\t\t\trx_dma_buf;\n\tphys_addr_t\t\t\tphys_addr;\n\tint\t\t\t\tbuf_idx;\n\tint\t\t\t\trx_buf_sz;\n\tint\t\t\t\twatermark;\n\ts64\t\t\t\tdma_ts;\n};\n\n \nstruct at91_adc_touch {\n\tu16\t\t\t\tsample_period_val;\n\tbool\t\t\t\ttouching;\n\tu16\t\t\t\tx_pos;\n\tunsigned long\t\t\tchannels_bitmask;\n\tstruct work_struct\t\tworkq;\n};\n\n \nstruct at91_adc_temp {\n\tu16\t\t\t\tsample_period_val;\n\tu16\t\t\t\tsaved_sample_rate;\n\tu16\t\t\t\tsaved_oversampling;\n};\n\n \n#define AT91_BUFFER_MAX_HWORDS ((32 * 2 + 8) / 2)\n\nstruct at91_adc_state {\n\tvoid __iomem\t\t\t*base;\n\tint\t\t\t\tirq;\n\tstruct clk\t\t\t*per_clk;\n\tstruct regulator\t\t*reg;\n\tstruct regulator\t\t*vref;\n\tint\t\t\t\tvref_uv;\n\tunsigned int\t\t\tcurrent_sample_rate;\n\tstruct iio_trigger\t\t*trig;\n\tconst struct at91_adc_trigger\t*selected_trig;\n\tconst struct iio_chan_spec\t*chan;\n\tbool\t\t\t\tconversion_done;\n\tu32\t\t\t\tconversion_value;\n\tunsigned int\t\t\toversampling_ratio;\n\tstruct at91_adc_soc_info\tsoc_info;\n\twait_queue_head_t\t\twq_data_available;\n\tstruct at91_adc_dma\t\tdma_st;\n\tstruct at91_adc_touch\t\ttouch_st;\n\tstruct at91_adc_temp\t\ttemp_st;\n\tstruct iio_dev\t\t\t*indio_dev;\n\tstruct device\t\t\t*dev;\n\t \n\tu16\t\t\t\tbuffer[AT91_BUFFER_MAX_HWORDS] __aligned(8);\n\t \n\tstruct mutex\t\t\tlock;\n};\n\nstatic const struct at91_adc_trigger at91_adc_trigger_list[] = {\n\t{\n\t\t.name = \"external_rising\",\n\t\t.trgmod_value = AT91_SAMA5D2_TRGR_TRGMOD_EXT_TRIG_RISE,\n\t\t.edge_type = IRQ_TYPE_EDGE_RISING,\n\t\t.hw_trig = true,\n\t},\n\t{\n\t\t.name = \"external_falling\",\n\t\t.trgmod_value = AT91_SAMA5D2_TRGR_TRGMOD_EXT_TRIG_FALL,\n\t\t.edge_type = IRQ_TYPE_EDGE_FALLING,\n\t\t.hw_trig = true,\n\t},\n\t{\n\t\t.name = \"external_any\",\n\t\t.trgmod_value = AT91_SAMA5D2_TRGR_TRGMOD_EXT_TRIG_ANY,\n\t\t.edge_type = IRQ_TYPE_EDGE_BOTH,\n\t\t.hw_trig = true,\n\t},\n\t{\n\t\t.name = \"software\",\n\t\t.trgmod_value = AT91_SAMA5D2_TRGR_TRGMOD_NO_TRIGGER,\n\t\t.edge_type = IRQ_TYPE_NONE,\n\t\t.hw_trig = false,\n\t},\n};\n\nstatic const struct iio_chan_spec at91_sama5d2_adc_channels[] = {\n\tAT91_SAMA5D2_CHAN_SINGLE(0, 0, 0x50),\n\tAT91_SAMA5D2_CHAN_SINGLE(1, 1, 0x54),\n\tAT91_SAMA5D2_CHAN_SINGLE(2, 2, 0x58),\n\tAT91_SAMA5D2_CHAN_SINGLE(3, 3, 0x5c),\n\tAT91_SAMA5D2_CHAN_SINGLE(4, 4, 0x60),\n\tAT91_SAMA5D2_CHAN_SINGLE(5, 5, 0x64),\n\tAT91_SAMA5D2_CHAN_SINGLE(6, 6, 0x68),\n\tAT91_SAMA5D2_CHAN_SINGLE(7, 7, 0x6c),\n\tAT91_SAMA5D2_CHAN_SINGLE(8, 8, 0x70),\n\tAT91_SAMA5D2_CHAN_SINGLE(9, 9, 0x74),\n\tAT91_SAMA5D2_CHAN_SINGLE(10, 10, 0x78),\n\tAT91_SAMA5D2_CHAN_SINGLE(11, 11, 0x7c),\n\t \n\tAT91_SAMA5D2_CHAN_DIFF(12, 0, 1, 0x50),\n\tAT91_SAMA5D2_CHAN_DIFF(14, 2, 3, 0x58),\n\tAT91_SAMA5D2_CHAN_DIFF(16, 4, 5, 0x60),\n\tAT91_SAMA5D2_CHAN_DIFF(18, 6, 7, 0x68),\n\tAT91_SAMA5D2_CHAN_DIFF(20, 8, 9, 0x70),\n\tAT91_SAMA5D2_CHAN_DIFF(22, 10, 11, 0x78),\n\tIIO_CHAN_SOFT_TIMESTAMP(23),\n\tAT91_SAMA5D2_CHAN_TOUCH(24, \"x\", IIO_MOD_X),\n\tAT91_SAMA5D2_CHAN_TOUCH(25, \"y\", IIO_MOD_Y),\n\tAT91_SAMA5D2_CHAN_PRESSURE(26, \"pressure\"),\n};\n\nstatic const struct iio_chan_spec at91_sama7g5_adc_channels[] = {\n\tAT91_SAMA5D2_CHAN_SINGLE(0, 0, 0x60),\n\tAT91_SAMA5D2_CHAN_SINGLE(1, 1, 0x64),\n\tAT91_SAMA5D2_CHAN_SINGLE(2, 2, 0x68),\n\tAT91_SAMA5D2_CHAN_SINGLE(3, 3, 0x6c),\n\tAT91_SAMA5D2_CHAN_SINGLE(4, 4, 0x70),\n\tAT91_SAMA5D2_CHAN_SINGLE(5, 5, 0x74),\n\tAT91_SAMA5D2_CHAN_SINGLE(6, 6, 0x78),\n\tAT91_SAMA5D2_CHAN_SINGLE(7, 7, 0x7c),\n\tAT91_SAMA5D2_CHAN_SINGLE(8, 8, 0x80),\n\tAT91_SAMA5D2_CHAN_SINGLE(9, 9, 0x84),\n\tAT91_SAMA5D2_CHAN_SINGLE(10, 10, 0x88),\n\tAT91_SAMA5D2_CHAN_SINGLE(11, 11, 0x8c),\n\tAT91_SAMA5D2_CHAN_SINGLE(12, 12, 0x90),\n\tAT91_SAMA5D2_CHAN_SINGLE(13, 13, 0x94),\n\tAT91_SAMA5D2_CHAN_SINGLE(14, 14, 0x98),\n\tAT91_SAMA5D2_CHAN_SINGLE(15, 15, 0x9c),\n\tAT91_SAMA5D2_CHAN_DIFF(16, 0, 1, 0x60),\n\tAT91_SAMA5D2_CHAN_DIFF(17, 2, 3, 0x68),\n\tAT91_SAMA5D2_CHAN_DIFF(18, 4, 5, 0x70),\n\tAT91_SAMA5D2_CHAN_DIFF(19, 6, 7, 0x78),\n\tAT91_SAMA5D2_CHAN_DIFF(20, 8, 9, 0x80),\n\tAT91_SAMA5D2_CHAN_DIFF(21, 10, 11, 0x88),\n\tAT91_SAMA5D2_CHAN_DIFF(22, 12, 13, 0x90),\n\tAT91_SAMA5D2_CHAN_DIFF(23, 14, 15, 0x98),\n\tIIO_CHAN_SOFT_TIMESTAMP(24),\n\tAT91_SAMA5D2_CHAN_TEMP(AT91_SAMA7G5_ADC_TEMP_CHANNEL, \"temp\", 0xdc),\n};\n\nstatic const struct at91_adc_platform sama5d2_platform = {\n\t.layout = &sama5d2_layout,\n\t.adc_channels = &at91_sama5d2_adc_channels,\n#define AT91_SAMA5D2_SINGLE_CHAN_CNT 12\n#define AT91_SAMA5D2_DIFF_CHAN_CNT 6\n\t.nr_channels = AT91_SAMA5D2_SINGLE_CHAN_CNT +\n\t\t       AT91_SAMA5D2_DIFF_CHAN_CNT,\n#define AT91_SAMA5D2_TOUCH_X_CHAN_IDX\t(AT91_SAMA5D2_SINGLE_CHAN_CNT + \\\n\t\t\t\t\tAT91_SAMA5D2_DIFF_CHAN_CNT * 2)\n\t.touch_chan_x = AT91_SAMA5D2_TOUCH_X_CHAN_IDX,\n#define AT91_SAMA5D2_TOUCH_Y_CHAN_IDX\t(AT91_SAMA5D2_TOUCH_X_CHAN_IDX + 1)\n\t.touch_chan_y = AT91_SAMA5D2_TOUCH_Y_CHAN_IDX,\n#define AT91_SAMA5D2_TOUCH_P_CHAN_IDX\t(AT91_SAMA5D2_TOUCH_Y_CHAN_IDX + 1)\n\t.touch_chan_p = AT91_SAMA5D2_TOUCH_P_CHAN_IDX,\n#define AT91_SAMA5D2_MAX_CHAN_IDX\tAT91_SAMA5D2_TOUCH_P_CHAN_IDX\n\t.max_channels = ARRAY_SIZE(at91_sama5d2_adc_channels),\n\t.max_index = AT91_SAMA5D2_MAX_CHAN_IDX,\n#define AT91_SAMA5D2_HW_TRIG_CNT\t3\n\t.hw_trig_cnt = AT91_SAMA5D2_HW_TRIG_CNT,\n\t.osr_mask = GENMASK(17, 16),\n\t.oversampling_avail = { 1, 4, 16, },\n\t.oversampling_avail_no = 3,\n\t.chan_realbits = 14,\n};\n\nstatic const struct at91_adc_platform sama7g5_platform = {\n\t.layout = &sama7g5_layout,\n\t.adc_channels = &at91_sama7g5_adc_channels,\n#define AT91_SAMA7G5_SINGLE_CHAN_CNT\t16\n#define AT91_SAMA7G5_DIFF_CHAN_CNT\t8\n#define AT91_SAMA7G5_TEMP_CHAN_CNT\t1\n\t.nr_channels = AT91_SAMA7G5_SINGLE_CHAN_CNT +\n\t\t       AT91_SAMA7G5_DIFF_CHAN_CNT +\n\t\t       AT91_SAMA7G5_TEMP_CHAN_CNT,\n#define AT91_SAMA7G5_MAX_CHAN_IDX\t(AT91_SAMA7G5_SINGLE_CHAN_CNT + \\\n\t\t\t\t\tAT91_SAMA7G5_DIFF_CHAN_CNT + \\\n\t\t\t\t\tAT91_SAMA7G5_TEMP_CHAN_CNT)\n\t.max_channels = ARRAY_SIZE(at91_sama7g5_adc_channels),\n\t.max_index = AT91_SAMA7G5_MAX_CHAN_IDX,\n#define AT91_SAMA7G5_HW_TRIG_CNT\t3\n\t.hw_trig_cnt = AT91_SAMA7G5_HW_TRIG_CNT,\n\t.osr_mask = GENMASK(18, 16),\n\t.oversampling_avail = { 1, 4, 16, 64, 256, },\n\t.oversampling_avail_no = 5,\n\t.chan_realbits = 16,\n\t.temp_sensor = true,\n\t.temp_chan = AT91_SAMA7G5_ADC_TEMP_CHANNEL,\n};\n\nstatic int at91_adc_chan_xlate(struct iio_dev *indio_dev, int chan)\n{\n\tint i;\n\n\tfor (i = 0; i < indio_dev->num_channels; i++) {\n\t\tif (indio_dev->channels[i].scan_index == chan)\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\n\nstatic inline struct iio_chan_spec const *\nat91_adc_chan_get(struct iio_dev *indio_dev, int chan)\n{\n\tint index = at91_adc_chan_xlate(indio_dev, chan);\n\n\tif (index < 0)\n\t\treturn NULL;\n\treturn indio_dev->channels + index;\n}\n\nstatic inline int at91_adc_fwnode_xlate(struct iio_dev *indio_dev,\n\t\t\t\t\tconst struct fwnode_reference_args *iiospec)\n{\n\treturn at91_adc_chan_xlate(indio_dev, iiospec->args[0]);\n}\n\nstatic unsigned int at91_adc_active_scan_mask_to_reg(struct iio_dev *indio_dev)\n{\n\tu32 mask = 0;\n\tu8 bit;\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->num_channels) {\n\t\tstruct iio_chan_spec const *chan =\n\t\t\t at91_adc_chan_get(indio_dev, bit);\n\t\tmask |= BIT(chan->channel);\n\t}\n\n\treturn mask & GENMASK(st->soc_info.platform->nr_channels, 0);\n}\n\nstatic void at91_adc_cor(struct at91_adc_state *st,\n\t\t\t struct iio_chan_spec const *chan)\n{\n\tu32 cor, cur_cor;\n\n\tcor = BIT(chan->channel) | BIT(chan->channel2);\n\n\tcur_cor = at91_adc_readl(st, COR);\n\tcor <<= st->soc_info.platform->layout->COR_diff_offset;\n\tif (chan->differential)\n\t\tat91_adc_writel(st, COR, cur_cor | cor);\n\telse\n\t\tat91_adc_writel(st, COR, cur_cor & ~cor);\n}\n\nstatic void at91_adc_irq_status(struct at91_adc_state *st, u32 *status,\n\t\t\t\tu32 *eoc)\n{\n\t*status = at91_adc_readl(st, ISR);\n\tif (st->soc_info.platform->layout->EOC_ISR)\n\t\t*eoc = at91_adc_readl(st, EOC_ISR);\n\telse\n\t\t*eoc = *status;\n}\n\nstatic void at91_adc_irq_mask(struct at91_adc_state *st, u32 *status, u32 *eoc)\n{\n\t*status = at91_adc_readl(st, IMR);\n\tif (st->soc_info.platform->layout->EOC_IMR)\n\t\t*eoc = at91_adc_readl(st, EOC_IMR);\n\telse\n\t\t*eoc = *status;\n}\n\nstatic void at91_adc_eoc_dis(struct at91_adc_state *st, unsigned int channel)\n{\n\t \n\tif (!st->soc_info.platform->layout->EOC_IDR)\n\t\tat91_adc_writel(st, IDR, BIT(channel));\n}\n\nstatic void at91_adc_eoc_ena(struct at91_adc_state *st, unsigned int channel)\n{\n\tif (!st->soc_info.platform->layout->EOC_IDR)\n\t\tat91_adc_writel(st, IER, BIT(channel));\n\telse\n\t\tat91_adc_writel(st, EOC_IER, BIT(channel));\n}\n\nstatic int at91_adc_config_emr(struct at91_adc_state *st,\n\t\t\t       u32 oversampling_ratio, u32 trackx)\n{\n\t \n\tunsigned int emr, osr;\n\tunsigned int osr_mask = st->soc_info.platform->osr_mask;\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < st->soc_info.platform->oversampling_avail_no; i++) {\n\t\tif (oversampling_ratio == st->soc_info.platform->oversampling_avail[i])\n\t\t\tbreak;\n\t}\n\tif (i == st->soc_info.platform->oversampling_avail_no)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (oversampling_ratio) {\n\tcase 1:\n\t\tosr = AT91_SAMA5D2_EMR_OSR(AT91_SAMA5D2_EMR_OSR_1SAMPLES,\n\t\t\t\t\t   osr_mask);\n\t\tbreak;\n\tcase 4:\n\t\tosr = AT91_SAMA5D2_EMR_OSR(AT91_SAMA5D2_EMR_OSR_4SAMPLES,\n\t\t\t\t\t   osr_mask);\n\t\tbreak;\n\tcase 16:\n\t\tosr = AT91_SAMA5D2_EMR_OSR(AT91_SAMA5D2_EMR_OSR_16SAMPLES,\n\t\t\t\t\t   osr_mask);\n\t\tbreak;\n\tcase 64:\n\t\tosr = AT91_SAMA5D2_EMR_OSR(AT91_SAMA5D2_EMR_OSR_64SAMPLES,\n\t\t\t\t\t   osr_mask);\n\t\tbreak;\n\tcase 256:\n\t\tosr = AT91_SAMA5D2_EMR_OSR(AT91_SAMA5D2_EMR_OSR_256SAMPLES,\n\t\t\t\t\t   osr_mask);\n\t\tbreak;\n\t}\n\n\tret = pm_runtime_resume_and_get(st->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\temr = at91_adc_readl(st, EMR);\n\t \n\temr |= AT91_SAMA5D2_EMR_ASTE(1);\n\t \n\temr &= ~(osr_mask | AT91_SAMA5D2_TRACKX_MASK);\n\t \n\temr |= osr | AT91_SAMA5D2_TRACKX(trackx);\n\tat91_adc_writel(st, EMR, emr);\n\n\tpm_runtime_mark_last_busy(st->dev);\n\tpm_runtime_put_autosuspend(st->dev);\n\n\tst->oversampling_ratio = oversampling_ratio;\n\n\treturn 0;\n}\n\nstatic int at91_adc_adjust_val_osr(struct at91_adc_state *st, int *val)\n{\n\tint nbits, diff;\n\n\tif (st->oversampling_ratio == 1)\n\t\tnbits = 12;\n\telse if (st->oversampling_ratio == 4)\n\t\tnbits = 13;\n\telse if (st->oversampling_ratio == 16)\n\t\tnbits = 14;\n\telse if (st->oversampling_ratio == 64)\n\t\tnbits = 15;\n\telse if (st->oversampling_ratio == 256)\n\t\tnbits = 16;\n\telse\n\t\t \n\t\treturn -EINVAL;\n\n\t \n\tdiff = st->soc_info.platform->chan_realbits - nbits;\n\t*val <<= diff;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic void at91_adc_adjust_val_osr_array(struct at91_adc_state *st, void *buf,\n\t\t\t\t\t  int len)\n{\n\tint i = 0, val;\n\tu16 *buf_u16 = (u16 *) buf;\n\n\t \n\twhile (i < len / 2) {\n\t\tval = buf_u16[i];\n\t\tat91_adc_adjust_val_osr(st, &val);\n\t\tbuf_u16[i] = val;\n\t\ti++;\n\t}\n}\n\nstatic int at91_adc_configure_touch(struct at91_adc_state *st, bool state)\n{\n\tu32 clk_khz = st->current_sample_rate / 1000;\n\tint i = 0, ret;\n\tu16 pendbc;\n\tu32 tsmr, acr;\n\n\tif (state) {\n\t\tret = pm_runtime_resume_and_get(st->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tat91_adc_writel(st, IDR,\n\t\t\t\tAT91_SAMA5D2_IER_PEN | AT91_SAMA5D2_IER_NOPEN);\n\t\tat91_adc_writel(st, TSMR, 0);\n\n\t\tpm_runtime_mark_last_busy(st->dev);\n\t\tpm_runtime_put_autosuspend(st->dev);\n\t\treturn 0;\n\t}\n\t \n\tpendbc = round_up(AT91_SAMA5D2_TOUCH_PEN_DETECT_DEBOUNCE_US *\n\t\t\t  clk_khz / 1000, 1);\n\n\t \n\twhile (pendbc >> i++)\n\t\t;\n\n\tpendbc = i;\n\n\ttsmr = AT91_SAMA5D2_TSMR_TSMODE_4WIRE_PRESS;\n\n\ttsmr |= AT91_SAMA5D2_TSMR_TSAV(2) & AT91_SAMA5D2_TSMR_TSAV_MASK;\n\ttsmr |= AT91_SAMA5D2_TSMR_PENDBC(pendbc) &\n\t\tAT91_SAMA5D2_TSMR_PENDBC_MASK;\n\ttsmr |= AT91_SAMA5D2_TSMR_NOTSDMA;\n\ttsmr |= AT91_SAMA5D2_TSMR_PENDET_ENA;\n\ttsmr |= AT91_SAMA5D2_TSMR_TSFREQ(2) & AT91_SAMA5D2_TSMR_TSFREQ_MASK;\n\n\tat91_adc_writel(st, TSMR, tsmr);\n\n\tacr =  at91_adc_readl(st, ACR);\n\tacr &= ~AT91_SAMA5D2_ACR_PENDETSENS_MASK;\n\tacr |= 0x02 & AT91_SAMA5D2_ACR_PENDETSENS_MASK;\n\tat91_adc_writel(st, ACR, acr);\n\n\t \n\tst->touch_st.sample_period_val =\n\t\t\t\t round_up((AT91_SAMA5D2_TOUCH_SAMPLE_PERIOD_US *\n\t\t\t\t clk_khz / 1000) - 1, 1);\n\t \n\tat91_adc_writel(st, IER, AT91_SAMA5D2_IER_PEN);\n\n\treturn 0;\n}\n\nstatic u16 at91_adc_touch_pos(struct at91_adc_state *st, int reg)\n{\n\tu32 val = 0;\n\tu32 scale, result, pos;\n\n\t \n\t \n\tif (reg == st->soc_info.platform->layout->XPOSR)\n\t\tval = at91_adc_readl(st, XPOSR);\n\telse if (reg == st->soc_info.platform->layout->YPOSR)\n\t\tval = at91_adc_readl(st, YPOSR);\n\n\tif (!val)\n\t\tdev_dbg(&st->indio_dev->dev, \"pos is 0\\n\");\n\n\tpos = val & AT91_SAMA5D2_XYZ_MASK;\n\tresult = (pos << AT91_SAMA5D2_MAX_POS_BITS) - pos;\n\tscale = (val >> 16) & AT91_SAMA5D2_XYZ_MASK;\n\tif (scale == 0) {\n\t\tdev_err(&st->indio_dev->dev, \"scale is 0\\n\");\n\t\treturn 0;\n\t}\n\tresult /= scale;\n\n\treturn result;\n}\n\nstatic u16 at91_adc_touch_x_pos(struct at91_adc_state *st)\n{\n\tst->touch_st.x_pos = at91_adc_touch_pos(st, st->soc_info.platform->layout->XPOSR);\n\treturn st->touch_st.x_pos;\n}\n\nstatic u16 at91_adc_touch_y_pos(struct at91_adc_state *st)\n{\n\treturn at91_adc_touch_pos(st, st->soc_info.platform->layout->YPOSR);\n}\n\nstatic u16 at91_adc_touch_pressure(struct at91_adc_state *st)\n{\n\tu32 val;\n\tu32 z1, z2;\n\tu32 pres;\n\tu32 rxp = 1;\n\tu32 factor = 1000;\n\n\t \n\tval = at91_adc_readl(st, PRESSR);\n\tz1 = val & AT91_SAMA5D2_XYZ_MASK;\n\tz2 = (val >> 16) & AT91_SAMA5D2_XYZ_MASK;\n\n\tif (z1 != 0)\n\t\tpres = rxp * (st->touch_st.x_pos * factor / 1024) *\n\t\t\t(z2 * factor / z1 - factor) /\n\t\t\tfactor;\n\telse\n\t\tpres = 0xFFFF;        \n\n\t \n\treturn 0xFFFF - pres;\n}\n\nstatic int at91_adc_read_position(struct at91_adc_state *st, int chan, u16 *val)\n{\n\t*val = 0;\n\tif (!st->touch_st.touching)\n\t\treturn -ENODATA;\n\tif (chan == st->soc_info.platform->touch_chan_x)\n\t\t*val = at91_adc_touch_x_pos(st);\n\telse if (chan == st->soc_info.platform->touch_chan_y)\n\t\t*val = at91_adc_touch_y_pos(st);\n\telse\n\t\treturn -ENODATA;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int at91_adc_read_pressure(struct at91_adc_state *st, int chan, u16 *val)\n{\n\t*val = 0;\n\tif (!st->touch_st.touching)\n\t\treturn -ENODATA;\n\tif (chan == st->soc_info.platform->touch_chan_p)\n\t\t*val = at91_adc_touch_pressure(st);\n\telse\n\t\treturn -ENODATA;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic void at91_adc_configure_trigger_registers(struct at91_adc_state *st,\n\t\t\t\t\t\t bool state)\n{\n\tu32 status = at91_adc_readl(st, TRGR);\n\n\t \n\tstatus &= ~AT91_SAMA5D2_TRGR_TRGMOD_MASK;\n\n\tif (state)\n\t\tstatus |= st->selected_trig->trgmod_value;\n\n\t \n\tat91_adc_writel(st, TRGR, status);\n}\n\nstatic int at91_adc_configure_trigger(struct iio_trigger *trig, bool state)\n{\n\tstruct iio_dev *indio = iio_trigger_get_drvdata(trig);\n\tstruct at91_adc_state *st = iio_priv(indio);\n\tint ret;\n\n\tif (state) {\n\t\tret = pm_runtime_resume_and_get(st->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tat91_adc_configure_trigger_registers(st, state);\n\n\tif (!state) {\n\t\tpm_runtime_mark_last_busy(st->dev);\n\t\tpm_runtime_put_autosuspend(st->dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void at91_adc_reenable_trigger(struct iio_trigger *trig)\n{\n\tstruct iio_dev *indio = iio_trigger_get_drvdata(trig);\n\tstruct at91_adc_state *st = iio_priv(indio);\n\n\t \n\tif (st->dma_st.dma_chan)\n\t\treturn;\n\n\tenable_irq(st->irq);\n\n\t \n\tat91_adc_readl(st, LCDR);\n}\n\nstatic const struct iio_trigger_ops at91_adc_trigger_ops = {\n\t.set_trigger_state = &at91_adc_configure_trigger,\n\t.reenable = &at91_adc_reenable_trigger,\n\t.validate_device = iio_trigger_validate_own_device,\n};\n\nstatic int at91_adc_dma_size_done(struct at91_adc_state *st)\n{\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\tint i, size;\n\n\tstatus = dmaengine_tx_status(st->dma_st.dma_chan,\n\t\t\t\t     st->dma_st.dma_chan->cookie,\n\t\t\t\t     &state);\n\tif (status != DMA_IN_PROGRESS)\n\t\treturn 0;\n\n\t \n\ti = st->dma_st.rx_buf_sz - state.residue;\n\n\t \n\tif (i >= st->dma_st.buf_idx)\n\t\tsize = i - st->dma_st.buf_idx;\n\telse\n\t\tsize = st->dma_st.rx_buf_sz + i - st->dma_st.buf_idx;\n\treturn size;\n}\n\nstatic void at91_dma_buffer_done(void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\n\tiio_trigger_poll_nested(indio_dev->trig);\n}\n\nstatic int at91_adc_dma_start(struct iio_dev *indio_dev)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\tstruct dma_async_tx_descriptor *desc;\n\tdma_cookie_t cookie;\n\tint ret;\n\tu8 bit;\n\n\tif (!st->dma_st.dma_chan)\n\t\treturn 0;\n\n\t \n\tst->dma_st.buf_idx = 0;\n\n\t \n\tst->dma_st.rx_buf_sz = 0;\n\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->num_channels) {\n\t\tstruct iio_chan_spec const *chan =\n\t\t\t\t\t at91_adc_chan_get(indio_dev, bit);\n\n\t\tif (!chan)\n\t\t\tcontinue;\n\n\t\tst->dma_st.rx_buf_sz += chan->scan_type.storagebits / 8;\n\t}\n\tst->dma_st.rx_buf_sz *= st->dma_st.watermark;\n\n\t \n\tdesc = dmaengine_prep_dma_cyclic(st->dma_st.dma_chan,\n\t\t\t\t\t st->dma_st.rx_dma_buf,\n\t\t\t\t\t st->dma_st.rx_buf_sz,\n\t\t\t\t\t st->dma_st.rx_buf_sz / 2,\n\t\t\t\t\t DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT);\n\n\tif (!desc) {\n\t\tdev_err(&indio_dev->dev, \"cannot prepare DMA cyclic\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tdesc->callback = at91_dma_buffer_done;\n\tdesc->callback_param = indio_dev;\n\n\tcookie = dmaengine_submit(desc);\n\tret = dma_submit_error(cookie);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"cannot submit DMA cyclic\\n\");\n\t\tdmaengine_terminate_async(st->dma_st.dma_chan);\n\t\treturn ret;\n\t}\n\n\t \n\tat91_adc_writel(st, IER, AT91_SAMA5D2_IER_GOVRE);\n\t \n\tdma_async_issue_pending(st->dma_st.dma_chan);\n\n\t \n\tst->dma_st.dma_ts = iio_get_time_ns(indio_dev);\n\n\tdev_dbg(&indio_dev->dev, \"DMA cyclic started\\n\");\n\n\treturn 0;\n}\n\nstatic bool at91_adc_buffer_check_use_irq(struct iio_dev *indio,\n\t\t\t\t\t  struct at91_adc_state *st)\n{\n\t \n\tif (st->dma_st.dma_chan)\n\t\treturn false;\n\t \n\tif (iio_trigger_validate_own_device(indio->trig, indio))\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool at91_adc_current_chan_is_touch(struct iio_dev *indio_dev)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\n\treturn !!bitmap_subset(indio_dev->active_scan_mask,\n\t\t\t       &st->touch_st.channels_bitmask,\n\t\t\t       st->soc_info.platform->max_index + 1);\n}\n\nstatic int at91_adc_buffer_prepare(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tu8 bit;\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\n\t \n\tif (at91_adc_current_chan_is_touch(indio_dev))\n\t\treturn at91_adc_configure_touch(st, true);\n\n\t \n\tif (!(iio_device_get_current_mode(indio_dev) & INDIO_ALL_TRIGGERED_MODES))\n\t\treturn -EINVAL;\n\n\tret = pm_runtime_resume_and_get(st->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = at91_adc_dma_start(indio_dev);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"buffer prepare failed\\n\");\n\t\tgoto pm_runtime_put;\n\t}\n\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->num_channels) {\n\t\tstruct iio_chan_spec const *chan =\n\t\t\t\t\tat91_adc_chan_get(indio_dev, bit);\n\t\tif (!chan)\n\t\t\tcontinue;\n\t\t \n\t\tif (chan->type == IIO_POSITIONRELATIVE ||\n\t\t    chan->type == IIO_PRESSURE ||\n\t\t    chan->type == IIO_TEMP)\n\t\t\tcontinue;\n\n\t\tat91_adc_cor(st, chan);\n\n\t\tat91_adc_writel(st, CHER, BIT(chan->channel));\n\t}\n\n\tif (at91_adc_buffer_check_use_irq(indio_dev, st))\n\t\tat91_adc_writel(st, IER, AT91_SAMA5D2_IER_DRDY);\n\npm_runtime_put:\n\tpm_runtime_mark_last_busy(st->dev);\n\tpm_runtime_put_autosuspend(st->dev);\n\treturn ret;\n}\n\nstatic int at91_adc_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\tint ret;\n\tu8 bit;\n\n\t \n\tif (at91_adc_current_chan_is_touch(indio_dev))\n\t\treturn at91_adc_configure_touch(st, false);\n\n\t \n\tif (!(iio_device_get_current_mode(indio_dev) & INDIO_ALL_TRIGGERED_MODES))\n\t\treturn -EINVAL;\n\n\tret = pm_runtime_resume_and_get(st->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->num_channels) {\n\t\tstruct iio_chan_spec const *chan =\n\t\t\t\t\tat91_adc_chan_get(indio_dev, bit);\n\n\t\tif (!chan)\n\t\t\tcontinue;\n\t\t \n\t\tif (chan->type == IIO_POSITIONRELATIVE ||\n\t\t    chan->type == IIO_PRESSURE ||\n\t\t    chan->type == IIO_TEMP)\n\t\t\tcontinue;\n\n\t\tat91_adc_writel(st, CHDR, BIT(chan->channel));\n\n\t\tif (st->dma_st.dma_chan)\n\t\t\tat91_adc_read_chan(st, chan->address);\n\t}\n\n\tif (at91_adc_buffer_check_use_irq(indio_dev, st))\n\t\tat91_adc_writel(st, IDR, AT91_SAMA5D2_IER_DRDY);\n\n\t \n\tat91_adc_readl(st, OVER);\n\n\t \n\tif (st->dma_st.dma_chan)\n\t\tdmaengine_terminate_sync(st->dma_st.dma_chan);\n\n\tpm_runtime_mark_last_busy(st->dev);\n\tpm_runtime_put_autosuspend(st->dev);\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops at91_buffer_setup_ops = {\n\t.postdisable = &at91_adc_buffer_postdisable,\n};\n\nstatic struct iio_trigger *at91_adc_allocate_trigger(struct iio_dev *indio,\n\t\t\t\t\t\t     char *trigger_name)\n{\n\tstruct iio_trigger *trig;\n\tint ret;\n\n\ttrig = devm_iio_trigger_alloc(&indio->dev, \"%s-dev%d-%s\", indio->name,\n\t\t\t\tiio_device_id(indio), trigger_name);\n\tif (!trig)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttrig->dev.parent = indio->dev.parent;\n\tiio_trigger_set_drvdata(trig, indio);\n\ttrig->ops = &at91_adc_trigger_ops;\n\n\tret = devm_iio_trigger_register(&indio->dev, trig);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn trig;\n}\n\nstatic void at91_adc_trigger_handler_nodma(struct iio_dev *indio_dev,\n\t\t\t\t\t   struct iio_poll_func *pf)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\tint i = 0;\n\tint val;\n\tu8 bit;\n\tu32 mask = at91_adc_active_scan_mask_to_reg(indio_dev);\n\tunsigned int timeout = 50;\n\tu32 status, imr, eoc = 0, eoc_imr;\n\n\t \n\twhile (((eoc & mask) != mask) && timeout) {\n\t\tat91_adc_irq_status(st, &status, &eoc);\n\t\tat91_adc_irq_mask(st, &imr, &eoc_imr);\n\t\tusleep_range(50, 100);\n\t\ttimeout--;\n\t}\n\n\t \n\tif (!timeout)\n\t\treturn;\n\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->num_channels) {\n\t\tstruct iio_chan_spec const *chan =\n\t\t\t\t\tat91_adc_chan_get(indio_dev, bit);\n\n\t\tif (!chan)\n\t\t\tcontinue;\n\t\t \n\t\tif (chan->type == IIO_VOLTAGE) {\n\t\t\tval = at91_adc_read_chan(st, chan->address);\n\t\t\tat91_adc_adjust_val_osr(st, &val);\n\t\t\tst->buffer[i] = val;\n\t\t} else {\n\t\t\tst->buffer[i] = 0;\n\t\t\tWARN(true, \"This trigger cannot handle this type of channel\");\n\t\t}\n\t\ti++;\n\t}\n\tiio_push_to_buffers_with_timestamp(indio_dev, st->buffer,\n\t\t\t\t\t   pf->timestamp);\n}\n\nstatic void at91_adc_trigger_handler_dma(struct iio_dev *indio_dev)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\tint transferred_len = at91_adc_dma_size_done(st);\n\ts64 ns = iio_get_time_ns(indio_dev);\n\ts64 interval;\n\tint sample_index = 0, sample_count, sample_size;\n\n\tu32 status = at91_adc_readl(st, ISR);\n\t \n\tif (status & AT91_SAMA5D2_IER_GOVRE)\n\t\tpr_info_ratelimited(\"%s: conversion overrun detected\\n\",\n\t\t\t\t    indio_dev->name);\n\n\tsample_size = div_s64(st->dma_st.rx_buf_sz, st->dma_st.watermark);\n\n\tsample_count = div_s64(transferred_len, sample_size);\n\n\t \n\tinterval = div_s64((ns - st->dma_st.dma_ts), sample_count);\n\n\twhile (transferred_len >= sample_size) {\n\t\t \n\t\tat91_adc_adjust_val_osr_array(st,\n\t\t\t\t\t&st->dma_st.rx_buf[st->dma_st.buf_idx],\n\t\t\t\t\tsample_size);\n\n\t\tiio_push_to_buffers_with_timestamp(indio_dev,\n\t\t\t\t(st->dma_st.rx_buf + st->dma_st.buf_idx),\n\t\t\t\t(st->dma_st.dma_ts + interval * sample_index));\n\t\t \n\t\ttransferred_len -= sample_size;\n\t\t \n\t\tst->dma_st.buf_idx += sample_size;\n\t\t \n\t\tif (st->dma_st.buf_idx >= st->dma_st.rx_buf_sz)\n\t\t\tst->dma_st.buf_idx = 0;\n\t\tsample_index++;\n\t}\n\t \n\tst->dma_st.dma_ts = iio_get_time_ns(indio_dev);\n}\n\nstatic irqreturn_t at91_adc_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\n\t \n\tif (iio_trigger_validate_own_device(indio_dev->trig, indio_dev))\n\t\tat91_adc_writel(st, CR, AT91_SAMA5D2_CR_START);\n\n\tif (st->dma_st.dma_chan)\n\t\tat91_adc_trigger_handler_dma(indio_dev);\n\telse\n\t\tat91_adc_trigger_handler_nodma(indio_dev, pf);\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned at91_adc_startup_time(unsigned startup_time_min,\n\t\t\t\t      unsigned adc_clk_khz)\n{\n\tstatic const unsigned int startup_lookup[] = {\n\t\t  0,   8,  16,  24,\n\t\t 64,  80,  96, 112,\n\t\t512, 576, 640, 704,\n\t\t768, 832, 896, 960\n\t\t};\n\tunsigned ticks_min, i;\n\n\t \n\n\tticks_min = startup_time_min * adc_clk_khz / 1000;\n\tfor (i = 0; i < ARRAY_SIZE(startup_lookup); i++)\n\t\tif (startup_lookup[i] > ticks_min)\n\t\t\tbreak;\n\n\treturn i;\n}\n\nstatic void at91_adc_setup_samp_freq(struct iio_dev *indio_dev, unsigned freq,\n\t\t\t\t     unsigned int startup_time,\n\t\t\t\t     unsigned int tracktim)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\tunsigned f_per, prescal, startup, mr;\n\tint ret;\n\n\tf_per = clk_get_rate(st->per_clk);\n\tprescal = (f_per / (2 * freq)) - 1;\n\n\tstartup = at91_adc_startup_time(startup_time, freq / 1000);\n\n\tret = pm_runtime_resume_and_get(st->dev);\n\tif (ret < 0)\n\t\treturn;\n\n\tmr = at91_adc_readl(st, MR);\n\tmr &= ~(AT91_SAMA5D2_MR_STARTUP_MASK | AT91_SAMA5D2_MR_PRESCAL_MASK);\n\tmr |= AT91_SAMA5D2_MR_STARTUP(startup);\n\tmr |= AT91_SAMA5D2_MR_PRESCAL(prescal);\n\tmr |= AT91_SAMA5D2_MR_TRACKTIM(tracktim);\n\tat91_adc_writel(st, MR, mr);\n\n\tpm_runtime_mark_last_busy(st->dev);\n\tpm_runtime_put_autosuspend(st->dev);\n\n\tdev_dbg(&indio_dev->dev, \"freq: %u, startup: %u, prescal: %u, tracktim=%u\\n\",\n\t\tfreq, startup, prescal, tracktim);\n\tst->current_sample_rate = freq;\n}\n\nstatic inline unsigned at91_adc_get_sample_freq(struct at91_adc_state *st)\n{\n\treturn st->current_sample_rate;\n}\n\nstatic void at91_adc_touch_data_handler(struct iio_dev *indio_dev)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\tu8 bit;\n\tu16 val;\n\tint i = 0;\n\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t st->soc_info.platform->max_index + 1) {\n\t\tstruct iio_chan_spec const *chan =\n\t\t\t\t\t at91_adc_chan_get(indio_dev, bit);\n\n\t\tif (chan->type == IIO_POSITIONRELATIVE)\n\t\t\tat91_adc_read_position(st, chan->channel, &val);\n\t\telse if (chan->type == IIO_PRESSURE)\n\t\t\tat91_adc_read_pressure(st, chan->channel, &val);\n\t\telse\n\t\t\tcontinue;\n\t\tst->buffer[i] = val;\n\t\ti++;\n\t}\n\t \n\tschedule_work(&st->touch_st.workq);\n}\n\nstatic void at91_adc_pen_detect_interrupt(struct at91_adc_state *st)\n{\n\tat91_adc_writel(st, IDR, AT91_SAMA5D2_IER_PEN);\n\tat91_adc_writel(st, IER, AT91_SAMA5D2_IER_NOPEN |\n\t\t\tAT91_SAMA5D2_IER_XRDY | AT91_SAMA5D2_IER_YRDY |\n\t\t\tAT91_SAMA5D2_IER_PRDY);\n\tat91_adc_writel(st, TRGR, AT91_SAMA5D2_TRGR_TRGMOD_PERIODIC |\n\t\t\tAT91_SAMA5D2_TRGR_TRGPER(st->touch_st.sample_period_val));\n\tst->touch_st.touching = true;\n}\n\nstatic void at91_adc_no_pen_detect_interrupt(struct iio_dev *indio_dev)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\n\tat91_adc_writel(st, TRGR, AT91_SAMA5D2_TRGR_TRGMOD_NO_TRIGGER);\n\tat91_adc_writel(st, IDR, AT91_SAMA5D2_IER_NOPEN |\n\t\t\tAT91_SAMA5D2_IER_XRDY | AT91_SAMA5D2_IER_YRDY |\n\t\t\tAT91_SAMA5D2_IER_PRDY);\n\tst->touch_st.touching = false;\n\n\tat91_adc_touch_data_handler(indio_dev);\n\n\tat91_adc_writel(st, IER, AT91_SAMA5D2_IER_PEN);\n}\n\nstatic void at91_adc_workq_handler(struct work_struct *workq)\n{\n\tstruct at91_adc_touch *touch_st = container_of(workq,\n\t\t\t\t\tstruct at91_adc_touch, workq);\n\tstruct at91_adc_state *st = container_of(touch_st,\n\t\t\t\t\tstruct at91_adc_state, touch_st);\n\tstruct iio_dev *indio_dev = st->indio_dev;\n\n\tiio_push_to_buffers(indio_dev, st->buffer);\n}\n\nstatic irqreturn_t at91_adc_interrupt(int irq, void *private)\n{\n\tstruct iio_dev *indio = private;\n\tstruct at91_adc_state *st = iio_priv(indio);\n\tu32 status, eoc, imr, eoc_imr;\n\tu32 rdy_mask = AT91_SAMA5D2_IER_XRDY | AT91_SAMA5D2_IER_YRDY |\n\t\t\tAT91_SAMA5D2_IER_PRDY;\n\n\tat91_adc_irq_status(st, &status, &eoc);\n\tat91_adc_irq_mask(st, &imr, &eoc_imr);\n\n\tif (!(status & imr) && !(eoc & eoc_imr))\n\t\treturn IRQ_NONE;\n\tif (status & AT91_SAMA5D2_IER_PEN) {\n\t\t \n\t\tat91_adc_pen_detect_interrupt(st);\n\t} else if ((status & AT91_SAMA5D2_IER_NOPEN)) {\n\t\t \n\t\tat91_adc_no_pen_detect_interrupt(indio);\n\t} else if ((status & AT91_SAMA5D2_ISR_PENS) &&\n\t\t   ((status & rdy_mask) == rdy_mask)) {\n\t\t \n\t\tat91_adc_touch_data_handler(indio);\n\t} else if (status & AT91_SAMA5D2_ISR_PENS) {\n\t\t \n\t\tstatus = at91_adc_readl(st, XPOSR);\n\t\tstatus = at91_adc_readl(st, YPOSR);\n\t\tstatus = at91_adc_readl(st, PRESSR);\n\t} else if (iio_buffer_enabled(indio) &&\n\t\t   (status & AT91_SAMA5D2_IER_DRDY)) {\n\t\t \n\t\tdisable_irq_nosync(irq);\n\t\tiio_trigger_poll(indio->trig);\n\t} else if (iio_buffer_enabled(indio) && st->dma_st.dma_chan) {\n\t\t \n\t\tdisable_irq_nosync(irq);\n\t\tWARN(true, \"Unexpected irq occurred\\n\");\n\t} else if (!iio_buffer_enabled(indio)) {\n\t\t \n\t\tst->conversion_value = at91_adc_read_chan(st, st->chan->address);\n\t\tst->conversion_done = true;\n\t\twake_up_interruptible(&st->wq_data_available);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int at91_adc_read_info_raw(struct iio_dev *indio_dev,\n\t\t\t\t  struct iio_chan_spec const *chan, int *val)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\tu16 tmp_val;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(st->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (chan->type == IIO_POSITIONRELATIVE) {\n\t\tret = at91_adc_read_position(st, chan->channel,\n\t\t\t\t\t     &tmp_val);\n\t\t*val = tmp_val;\n\t\tif (ret > 0)\n\t\t\tret = at91_adc_adjust_val_osr(st, val);\n\n\t\tgoto pm_runtime_put;\n\t}\n\tif (chan->type == IIO_PRESSURE) {\n\t\tret = at91_adc_read_pressure(st, chan->channel,\n\t\t\t\t\t     &tmp_val);\n\t\t*val = tmp_val;\n\t\tif (ret > 0)\n\t\t\tret = at91_adc_adjust_val_osr(st, val);\n\n\t\tgoto pm_runtime_put;\n\t}\n\n\t \n\n\tst->chan = chan;\n\n\tat91_adc_cor(st, chan);\n\tat91_adc_writel(st, CHER, BIT(chan->channel));\n\t \n\tif (chan->type == IIO_TEMP)\n\t\tat91_adc_writel(st, TEMPMR, AT91_SAMA5D2_TEMPMR_TEMPON);\n\tat91_adc_eoc_ena(st, chan->channel);\n\tat91_adc_writel(st, CR, AT91_SAMA5D2_CR_START);\n\n\tret = wait_event_interruptible_timeout(st->wq_data_available,\n\t\t\t\t\t       st->conversion_done,\n\t\t\t\t\t       msecs_to_jiffies(1000));\n\tif (ret == 0)\n\t\tret = -ETIMEDOUT;\n\n\tif (ret > 0) {\n\t\t*val = st->conversion_value;\n\t\tret = at91_adc_adjust_val_osr(st, val);\n\t\tif (chan->scan_type.sign == 's')\n\t\t\t*val = sign_extend32(*val,\n\t\t\t\t\t     chan->scan_type.realbits - 1);\n\t\tst->conversion_done = false;\n\t}\n\n\tat91_adc_eoc_dis(st, st->chan->channel);\n\tif (chan->type == IIO_TEMP)\n\t\tat91_adc_writel(st, TEMPMR, 0U);\n\tat91_adc_writel(st, CHDR, BIT(chan->channel));\n\n\t \n\tat91_adc_readl(st, LCDR);\n\npm_runtime_put:\n\tpm_runtime_mark_last_busy(st->dev);\n\tpm_runtime_put_autosuspend(st->dev);\n\treturn ret;\n}\n\nstatic int at91_adc_read_info_locked(struct iio_dev *indio_dev,\n\t\t\t\t     struct iio_chan_spec const *chan, int *val)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\tret = at91_adc_read_info_raw(indio_dev, chan, val);\n\tmutex_unlock(&st->lock);\n\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret;\n}\n\nstatic void at91_adc_temp_sensor_configure(struct at91_adc_state *st,\n\t\t\t\t\t   bool start)\n{\n\tu32 sample_rate, oversampling_ratio;\n\tu32 startup_time, tracktim, trackx;\n\n\tif (start) {\n\t\t \n\t\tsample_rate = 10 * MEGA;\n\t\toversampling_ratio = 256;\n\t\tstartup_time = AT91_SAMA5D2_MR_STARTUP_TS_MIN;\n\t\ttracktim = AT91_SAMA5D2_MR_TRACKTIM_TS;\n\t\ttrackx = AT91_SAMA5D2_TRACKX_TS;\n\n\t\tst->temp_st.saved_sample_rate = st->current_sample_rate;\n\t\tst->temp_st.saved_oversampling = st->oversampling_ratio;\n\t} else {\n\t\t \n\t\tsample_rate = st->temp_st.saved_sample_rate;\n\t\toversampling_ratio = st->temp_st.saved_oversampling;\n\t\tstartup_time = st->soc_info.startup_time;\n\t\ttracktim = 0;\n\t\ttrackx = 0;\n\t}\n\n\tat91_adc_setup_samp_freq(st->indio_dev, sample_rate, startup_time,\n\t\t\t\t tracktim);\n\tat91_adc_config_emr(st, oversampling_ratio, trackx);\n}\n\nstatic int at91_adc_read_temp(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan, int *val)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\tstruct at91_adc_temp_sensor_clb *clb = &st->soc_info.temp_sensor_clb;\n\tu64 div1, div2;\n\tu32 tmp;\n\tint ret, vbg, vtemp;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&st->lock);\n\n\tret = pm_runtime_resume_and_get(st->dev);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tat91_adc_temp_sensor_configure(st, true);\n\n\t \n\ttmp = at91_adc_readl(st, ACR);\n\ttmp |= AT91_SAMA5D2_ACR_SRCLCH;\n\tat91_adc_writel(st, ACR, tmp);\n\tret = at91_adc_read_info_raw(indio_dev, chan, &vbg);\n\tif (ret < 0)\n\t\tgoto restore_config;\n\n\t \n\ttmp &= ~AT91_SAMA5D2_ACR_SRCLCH;\n\tat91_adc_writel(st, ACR, tmp);\n\tret = at91_adc_read_info_raw(indio_dev, chan, &vtemp);\n\nrestore_config:\n\t \n\tat91_adc_temp_sensor_configure(st, false);\n\tpm_runtime_mark_last_busy(st->dev);\n\tpm_runtime_put_autosuspend(st->dev);\nunlock:\n\tmutex_unlock(&st->lock);\n\tiio_device_release_direct_mode(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdiv1 = DIV_ROUND_CLOSEST_ULL(((u64)vtemp * clb->p6), vbg);\n\tdiv1 = DIV_ROUND_CLOSEST_ULL((div1 * 1000), AT91_ADC_TS_VTEMP_DT);\n\tdiv2 = DIV_ROUND_CLOSEST_ULL((u64)clb->p4, AT91_ADC_TS_VTEMP_DT);\n\tdiv2 *= 1000;\n\t*val = clb->p1 + (int)div1 - (int)div2;\n\n\treturn ret;\n}\n\nstatic int at91_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn at91_adc_read_info_locked(indio_dev, chan, val);\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = st->vref_uv / 1000;\n\t\tif (chan->differential)\n\t\t\t*val *= 2;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tif (chan->type != IIO_TEMP)\n\t\t\treturn -EINVAL;\n\t\treturn at91_adc_read_temp(indio_dev, chan, val);\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = at91_adc_get_sample_freq(st);\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t*val = st->oversampling_ratio;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int at91_adc_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t \n\t\tif (val == st->oversampling_ratio)\n\t\t\treturn 0;\n\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmutex_lock(&st->lock);\n\t\t \n\t\tret = at91_adc_config_emr(st, val, 0);\n\t\tmutex_unlock(&st->lock);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (val < st->soc_info.min_sample_rate ||\n\t\t    val > st->soc_info.max_sample_rate)\n\t\t\treturn -EINVAL;\n\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmutex_lock(&st->lock);\n\t\tat91_adc_setup_samp_freq(indio_dev, val,\n\t\t\t\t\t st->soc_info.startup_time, 0);\n\t\tmutex_unlock(&st->lock);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int at91_adc_read_avail(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length,\n\t\t\t       long mask)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t*vals = (int *)st->soc_info.platform->oversampling_avail;\n\t\t*type = IIO_VAL_INT;\n\t\t*length = st->soc_info.platform->oversampling_avail_no;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void at91_adc_dma_init(struct at91_adc_state *st)\n{\n\tstruct device *dev = &st->indio_dev->dev;\n\tstruct dma_slave_config config = {0};\n\t \n\tunsigned int sample_size = st->soc_info.platform->nr_channels * 2;\n\t \n\tunsigned int pages = DIV_ROUND_UP(AT91_HWFIFO_MAX_SIZE *\n\t\t\t\t\t  sample_size * 2, PAGE_SIZE);\n\n\tif (st->dma_st.dma_chan)\n\t\treturn;\n\n\tst->dma_st.dma_chan = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(st->dma_st.dma_chan))  {\n\t\tdev_info(dev, \"can't get DMA channel\\n\");\n\t\tst->dma_st.dma_chan = NULL;\n\t\tgoto dma_exit;\n\t}\n\n\tst->dma_st.rx_buf = dma_alloc_coherent(st->dma_st.dma_chan->device->dev,\n\t\t\t\t\t       pages * PAGE_SIZE,\n\t\t\t\t\t       &st->dma_st.rx_dma_buf,\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!st->dma_st.rx_buf) {\n\t\tdev_info(dev, \"can't allocate coherent DMA area\\n\");\n\t\tgoto dma_chan_disable;\n\t}\n\n\t \n\tconfig.direction = DMA_DEV_TO_MEM;\n\tconfig.src_addr = (phys_addr_t)(st->dma_st.phys_addr\n\t\t\t  + st->soc_info.platform->layout->LCDR);\n\tconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\tconfig.src_maxburst = 1;\n\tconfig.dst_maxburst = 1;\n\n\tif (dmaengine_slave_config(st->dma_st.dma_chan, &config)) {\n\t\tdev_info(dev, \"can't configure DMA slave\\n\");\n\t\tgoto dma_free_area;\n\t}\n\n\tdev_info(dev, \"using %s for rx DMA transfers\\n\",\n\t\t dma_chan_name(st->dma_st.dma_chan));\n\n\treturn;\n\ndma_free_area:\n\tdma_free_coherent(st->dma_st.dma_chan->device->dev, pages * PAGE_SIZE,\n\t\t\t  st->dma_st.rx_buf, st->dma_st.rx_dma_buf);\ndma_chan_disable:\n\tdma_release_channel(st->dma_st.dma_chan);\n\tst->dma_st.dma_chan = NULL;\ndma_exit:\n\tdev_info(dev, \"continuing without DMA support\\n\");\n}\n\nstatic void at91_adc_dma_disable(struct at91_adc_state *st)\n{\n\tstruct device *dev = &st->indio_dev->dev;\n\t \n\tunsigned int sample_size = st->soc_info.platform->nr_channels * 2;\n\tunsigned int pages = DIV_ROUND_UP(AT91_HWFIFO_MAX_SIZE *\n\t\t\t\t\t  sample_size * 2, PAGE_SIZE);\n\n\t \n\tif (!st->dma_st.dma_chan)\n\t\treturn;\n\n\t \n\tdmaengine_terminate_sync(st->dma_st.dma_chan);\n\n\tdma_free_coherent(st->dma_st.dma_chan->device->dev, pages * PAGE_SIZE,\n\t\t\t  st->dma_st.rx_buf, st->dma_st.rx_dma_buf);\n\tdma_release_channel(st->dma_st.dma_chan);\n\tst->dma_st.dma_chan = NULL;\n\n\tdev_info(dev, \"continuing without DMA support\\n\");\n}\n\nstatic int at91_adc_set_watermark(struct iio_dev *indio_dev, unsigned int val)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tif (val > AT91_HWFIFO_MAX_SIZE)\n\t\tval = AT91_HWFIFO_MAX_SIZE;\n\n\tif (!st->selected_trig->hw_trig) {\n\t\tdev_dbg(&indio_dev->dev, \"we need hw trigger for DMA\\n\");\n\t\treturn 0;\n\t}\n\n\tdev_dbg(&indio_dev->dev, \"new watermark is %u\\n\", val);\n\tst->dma_st.watermark = val;\n\n\t \n\n\tif (val == 1)\n\t\tat91_adc_dma_disable(st);\n\telse if (val > 1)\n\t\tat91_adc_dma_init(st);\n\n\t \n\tret = at91_adc_buffer_prepare(indio_dev);\n\tif (ret)\n\t\tat91_adc_dma_disable(st);\n\n\treturn ret;\n}\n\nstatic int at91_adc_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t     const unsigned long *scan_mask)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\n\tif (bitmap_subset(scan_mask, &st->touch_st.channels_bitmask,\n\t\t\t  st->soc_info.platform->max_index + 1))\n\t\treturn 0;\n\t \n\tif (bitmap_intersects(&st->touch_st.channels_bitmask, scan_mask,\n\t\t\t      st->soc_info.platform->max_index + 1))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void at91_adc_hw_init(struct iio_dev *indio_dev)\n{\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\n\tat91_adc_writel(st, CR, AT91_SAMA5D2_CR_SWRST);\n\tif (st->soc_info.platform->layout->EOC_IDR)\n\t\tat91_adc_writel(st, EOC_IDR, 0xffffffff);\n\tat91_adc_writel(st, IDR, 0xffffffff);\n\t \n\tat91_adc_writel(st, MR,\n\t\t\tAT91_SAMA5D2_MR_TRANSFER(2) | AT91_SAMA5D2_MR_ANACH);\n\n\tat91_adc_setup_samp_freq(indio_dev, st->soc_info.min_sample_rate,\n\t\t\t\t st->soc_info.startup_time, 0);\n\n\t \n\tat91_adc_config_emr(st, st->oversampling_ratio, 0);\n}\n\nstatic ssize_t at91_adc_get_fifo_state(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!st->dma_st.dma_chan);\n}\n\nstatic ssize_t at91_adc_get_watermark(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", st->dma_st.watermark);\n}\n\nstatic IIO_DEVICE_ATTR(hwfifo_enabled, 0444,\n\t\t       at91_adc_get_fifo_state, NULL, 0);\nstatic IIO_DEVICE_ATTR(hwfifo_watermark, 0444,\n\t\t       at91_adc_get_watermark, NULL, 0);\n\nIIO_STATIC_CONST_DEVICE_ATTR(hwfifo_watermark_min, \"2\");\nIIO_STATIC_CONST_DEVICE_ATTR(hwfifo_watermark_max, AT91_HWFIFO_MAX_SIZE_STR);\n\nstatic const struct iio_dev_attr *at91_adc_fifo_attributes[] = {\n\t&iio_dev_attr_hwfifo_watermark_min,\n\t&iio_dev_attr_hwfifo_watermark_max,\n\t&iio_dev_attr_hwfifo_watermark,\n\t&iio_dev_attr_hwfifo_enabled,\n\tNULL,\n};\n\nstatic const struct iio_info at91_adc_info = {\n\t.read_avail = &at91_adc_read_avail,\n\t.read_raw = &at91_adc_read_raw,\n\t.write_raw = &at91_adc_write_raw,\n\t.update_scan_mode = &at91_adc_update_scan_mode,\n\t.fwnode_xlate = &at91_adc_fwnode_xlate,\n\t.hwfifo_set_watermark = &at91_adc_set_watermark,\n};\n\nstatic int at91_adc_buffer_and_trigger_init(struct device *dev,\n\t\t\t\t\t    struct iio_dev *indio)\n{\n\tstruct at91_adc_state *st = iio_priv(indio);\n\tconst struct iio_dev_attr **fifo_attrs;\n\tint ret;\n\n\tif (st->selected_trig->hw_trig)\n\t\tfifo_attrs = at91_adc_fifo_attributes;\n\telse\n\t\tfifo_attrs = NULL;\n\n\tret = devm_iio_triggered_buffer_setup_ext(&indio->dev, indio,\n\t\t&iio_pollfunc_store_time, &at91_adc_trigger_handler,\n\t\tIIO_BUFFER_DIRECTION_IN, &at91_buffer_setup_ops, fifo_attrs);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"couldn't initialize the buffer.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!st->selected_trig->hw_trig)\n\t\treturn 0;\n\n\tst->trig = at91_adc_allocate_trigger(indio, st->selected_trig->name);\n\tif (IS_ERR(st->trig)) {\n\t\tdev_err(dev, \"could not allocate trigger\\n\");\n\t\treturn PTR_ERR(st->trig);\n\t}\n\n\t \n\tst->dma_st.watermark = 1;\n\n\treturn 0;\n}\n\nstatic int at91_adc_temp_sensor_init(struct at91_adc_state *st,\n\t\t\t\t     struct device *dev)\n{\n\tstruct at91_adc_temp_sensor_clb *clb = &st->soc_info.temp_sensor_clb;\n\tstruct nvmem_cell *temp_calib;\n\tu32 *buf;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!st->soc_info.platform->temp_sensor)\n\t\treturn 0;\n\n\t \n\ttemp_calib = devm_nvmem_cell_get(dev, \"temperature_calib\");\n\tif (IS_ERR(temp_calib)) {\n\t\tret = PTR_ERR(temp_calib);\n\t\tif (ret != -ENOENT)\n\t\t\tdev_err(dev, \"Failed to get temperature_calib cell!\\n\");\n\t\treturn ret;\n\t}\n\n\tbuf = nvmem_cell_read(temp_calib, &len);\n\tif (IS_ERR(buf)) {\n\t\tdev_err(dev, \"Failed to read calibration data!\\n\");\n\t\treturn PTR_ERR(buf);\n\t}\n\tif (len < AT91_ADC_TS_CLB_IDX_MAX * 4) {\n\t\tdev_err(dev, \"Invalid calibration data!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_buf;\n\t}\n\n\t \n\tclb->p1 = buf[AT91_ADC_TS_CLB_IDX_P1];\n\tclb->p4 = buf[AT91_ADC_TS_CLB_IDX_P4];\n\tclb->p6 = buf[AT91_ADC_TS_CLB_IDX_P6];\n\n\t \n\tclb->p1 = clb->p1 * 1000;\n\nfree_buf:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int at91_adc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct at91_adc_state *st;\n\tstruct resource\t*res;\n\tint ret, i, num_channels;\n\tu32 edge_type = IRQ_TYPE_NONE;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tst->indio_dev = indio_dev;\n\n\tst->soc_info.platform = device_get_match_data(dev);\n\n\tret = at91_adc_temp_sensor_init(st, &pdev->dev);\n\t \n\tif (ret)\n\t\tnum_channels = st->soc_info.platform->max_channels - 1;\n\telse\n\t\tnum_channels = st->soc_info.platform->max_channels;\n\n\tindio_dev->name = dev_name(&pdev->dev);\n\tindio_dev->modes = INDIO_DIRECT_MODE | INDIO_BUFFER_SOFTWARE;\n\tindio_dev->info = &at91_adc_info;\n\tindio_dev->channels = *st->soc_info.platform->adc_channels;\n\tindio_dev->num_channels = num_channels;\n\n\tbitmap_set(&st->touch_st.channels_bitmask,\n\t\t   st->soc_info.platform->touch_chan_x, 1);\n\tbitmap_set(&st->touch_st.channels_bitmask,\n\t\t   st->soc_info.platform->touch_chan_y, 1);\n\tbitmap_set(&st->touch_st.channels_bitmask,\n\t\t   st->soc_info.platform->touch_chan_p, 1);\n\n\tst->oversampling_ratio = 1;\n\n\tret = device_property_read_u32(dev, \"atmel,min-sample-rate-hz\",\n\t\t\t\t       &st->soc_info.min_sample_rate);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"invalid or missing value for atmel,min-sample-rate-hz\\n\");\n\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(dev, \"atmel,max-sample-rate-hz\",\n\t\t\t\t       &st->soc_info.max_sample_rate);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"invalid or missing value for atmel,max-sample-rate-hz\\n\");\n\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(dev, \"atmel,startup-time-ms\",\n\t\t\t\t       &st->soc_info.startup_time);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"invalid or missing value for atmel,startup-time-ms\\n\");\n\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(dev, \"atmel,trigger-edge-type\",\n\t\t\t\t       &edge_type);\n\tif (ret) {\n\t\tdev_dbg(&pdev->dev,\n\t\t\t\"atmel,trigger-edge-type not specified, only software trigger available\\n\");\n\t}\n\n\tst->selected_trig = NULL;\n\n\t \n\tfor (i = 0; i < st->soc_info.platform->hw_trig_cnt + 1; i++)\n\t\tif (at91_adc_trigger_list[i].edge_type == edge_type) {\n\t\t\tst->selected_trig = &at91_adc_trigger_list[i];\n\t\t\tbreak;\n\t\t}\n\n\tif (!st->selected_trig) {\n\t\tdev_err(&pdev->dev, \"invalid external trigger edge value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinit_waitqueue_head(&st->wq_data_available);\n\tmutex_init(&st->lock);\n\tINIT_WORK(&st->touch_st.workq, at91_adc_workq_handler);\n\n\tst->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(st->base))\n\t\treturn PTR_ERR(st->base);\n\n\t \n\tst->dma_st.phys_addr = res->start;\n\n\tst->irq = platform_get_irq(pdev, 0);\n\tif (st->irq < 0)\n\t\treturn st->irq;\n\n\tst->per_clk = devm_clk_get(&pdev->dev, \"adc_clk\");\n\tif (IS_ERR(st->per_clk))\n\t\treturn PTR_ERR(st->per_clk);\n\n\tst->reg = devm_regulator_get(&pdev->dev, \"vddana\");\n\tif (IS_ERR(st->reg))\n\t\treturn PTR_ERR(st->reg);\n\n\tst->vref = devm_regulator_get(&pdev->dev, \"vref\");\n\tif (IS_ERR(st->vref))\n\t\treturn PTR_ERR(st->vref);\n\n\tret = devm_request_irq(&pdev->dev, st->irq, at91_adc_interrupt, 0,\n\t\t\t       pdev->dev.driver->name, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_enable(st->reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_enable(st->vref);\n\tif (ret)\n\t\tgoto reg_disable;\n\n\tst->vref_uv = regulator_get_voltage(st->vref);\n\tif (st->vref_uv <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto vref_disable;\n\t}\n\n\tret = clk_prepare_enable(st->per_clk);\n\tif (ret)\n\t\tgoto vref_disable;\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\tst->dev = &pdev->dev;\n\tpm_runtime_set_autosuspend_delay(st->dev, 500);\n\tpm_runtime_use_autosuspend(st->dev);\n\tpm_runtime_set_active(st->dev);\n\tpm_runtime_enable(st->dev);\n\tpm_runtime_get_noresume(st->dev);\n\n\tat91_adc_hw_init(indio_dev);\n\n\tret = at91_adc_buffer_and_trigger_init(&pdev->dev, indio_dev);\n\tif (ret < 0)\n\t\tgoto err_pm_disable;\n\n\tif (dma_coerce_mask_and_coherent(&indio_dev->dev, DMA_BIT_MASK(32)))\n\t\tdev_info(&pdev->dev, \"cannot set DMA mask to 32-bit\\n\");\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto dma_disable;\n\n\tif (st->selected_trig->hw_trig)\n\t\tdev_info(&pdev->dev, \"setting up trigger as %s\\n\",\n\t\t\t st->selected_trig->name);\n\n\tdev_info(&pdev->dev, \"version: %x\\n\",\n\t\t readl_relaxed(st->base + st->soc_info.platform->layout->VERSION));\n\n\tpm_runtime_mark_last_busy(st->dev);\n\tpm_runtime_put_autosuspend(st->dev);\n\n\treturn 0;\n\ndma_disable:\n\tat91_adc_dma_disable(st);\nerr_pm_disable:\n\tpm_runtime_put_noidle(st->dev);\n\tpm_runtime_disable(st->dev);\n\tpm_runtime_set_suspended(st->dev);\n\tpm_runtime_dont_use_autosuspend(st->dev);\n\tclk_disable_unprepare(st->per_clk);\nvref_disable:\n\tregulator_disable(st->vref);\nreg_disable:\n\tregulator_disable(st->reg);\n\treturn ret;\n}\n\nstatic int at91_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tat91_adc_dma_disable(st);\n\n\tpm_runtime_disable(st->dev);\n\tpm_runtime_set_suspended(st->dev);\n\tclk_disable_unprepare(st->per_clk);\n\n\tregulator_disable(st->vref);\n\tregulator_disable(st->reg);\n\n\treturn 0;\n}\n\nstatic int at91_adc_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(st->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (iio_buffer_enabled(indio_dev))\n\t\tat91_adc_buffer_postdisable(indio_dev);\n\n\t \n\tat91_adc_writel(st, CR, AT91_SAMA5D2_CR_SWRST);\n\n\tpm_runtime_mark_last_busy(st->dev);\n\tpm_runtime_put_noidle(st->dev);\n\tclk_disable_unprepare(st->per_clk);\n\tregulator_disable(st->vref);\n\tregulator_disable(st->reg);\n\n\treturn pinctrl_pm_select_sleep_state(dev);\n}\n\nstatic int at91_adc_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = pinctrl_pm_select_default_state(dev);\n\tif (ret)\n\t\tgoto resume_failed;\n\n\tret = regulator_enable(st->reg);\n\tif (ret)\n\t\tgoto resume_failed;\n\n\tret = regulator_enable(st->vref);\n\tif (ret)\n\t\tgoto reg_disable_resume;\n\n\tret = clk_prepare_enable(st->per_clk);\n\tif (ret)\n\t\tgoto vref_disable_resume;\n\n\tpm_runtime_get_noresume(st->dev);\n\n\tat91_adc_hw_init(indio_dev);\n\n\t \n\tif (iio_buffer_enabled(indio_dev)) {\n\t\tret = at91_adc_buffer_prepare(indio_dev);\n\t\tif (ret)\n\t\t\tgoto pm_runtime_put;\n\n\t\tat91_adc_configure_trigger_registers(st, true);\n\t}\n\n\tpm_runtime_mark_last_busy(st->dev);\n\tpm_runtime_put_autosuspend(st->dev);\n\n\treturn 0;\n\npm_runtime_put:\n\tpm_runtime_mark_last_busy(st->dev);\n\tpm_runtime_put_noidle(st->dev);\n\tclk_disable_unprepare(st->per_clk);\nvref_disable_resume:\n\tregulator_disable(st->vref);\nreg_disable_resume:\n\tregulator_disable(st->reg);\nresume_failed:\n\tdev_err(&indio_dev->dev, \"failed to resume\\n\");\n\treturn ret;\n}\n\nstatic int at91_adc_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\n\tclk_disable(st->per_clk);\n\n\treturn 0;\n}\n\nstatic int at91_adc_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct at91_adc_state *st = iio_priv(indio_dev);\n\n\treturn clk_enable(st->per_clk);\n}\n\nstatic const struct dev_pm_ops at91_adc_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(at91_adc_suspend, at91_adc_resume)\n\tRUNTIME_PM_OPS(at91_adc_runtime_suspend, at91_adc_runtime_resume,\n\t\t       NULL)\n};\n\nstatic const struct of_device_id at91_adc_dt_match[] = {\n\t{\n\t\t.compatible = \"atmel,sama5d2-adc\",\n\t\t.data = (const void *)&sama5d2_platform,\n\t}, {\n\t\t.compatible = \"microchip,sama7g5-adc\",\n\t\t.data = (const void *)&sama7g5_platform,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, at91_adc_dt_match);\n\nstatic struct platform_driver at91_adc_driver = {\n\t.probe = at91_adc_probe,\n\t.remove = at91_adc_remove,\n\t.driver = {\n\t\t.name = \"at91-sama5d2_adc\",\n\t\t.of_match_table = at91_adc_dt_match,\n\t\t.pm = pm_ptr(&at91_adc_pm_ops),\n\t},\n};\nmodule_platform_driver(at91_adc_driver)\n\nMODULE_AUTHOR(\"Ludovic Desroches <ludovic.desroches@microchip.com>\");\nMODULE_AUTHOR(\"Eugen Hristev <eugen.hristev@microchip.com\");\nMODULE_DESCRIPTION(\"Atmel AT91 SAMA5D2 ADC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}