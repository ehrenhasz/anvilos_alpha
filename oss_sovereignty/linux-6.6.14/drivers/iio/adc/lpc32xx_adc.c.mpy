{
  "module_name": "lpc32xx_adc.c",
  "hash_id": "d9e15d4a99fe40feb5167807d13200c4900dbbcb61212b44e841282e14efaf3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/lpc32xx_adc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/iio/iio.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n \n#define LPC32XXAD_SELECT(x)\t((x) + 0x04)\n#define LPC32XXAD_CTRL(x)\t((x) + 0x08)\n#define LPC32XXAD_VALUE(x)\t((x) + 0x48)\n\n \n \n#define LPC32XXAD_REFm         0x00000200\n \n#define LPC32XXAD_REFp\t\t0x00000080\n  \n#define LPC32XXAD_IN\t\t0x00000010\n \n#define LPC32XXAD_INTERNAL\t0x00000004\n\n \n#define LPC32XXAD_STROBE\t0x00000002\n#define LPC32XXAD_PDN_CTRL\t0x00000004\n\n \n#define LPC32XXAD_VALUE_MASK\t0x000003FF\n\n#define LPC32XXAD_NAME \"lpc32xx-adc\"\n\nstruct lpc32xx_adc_state {\n\tvoid __iomem *adc_base;\n\tstruct clk *clk;\n\tstruct completion completion;\n\tstruct regulator *vref;\n\t \n\tstruct mutex lock;\n\n\tu32 value;\n};\n\nstatic int lpc32xx_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val,\n\t\t\t    int *val2,\n\t\t\t    long mask)\n{\n\tstruct lpc32xx_adc_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&st->lock);\n\t\tret = clk_prepare_enable(st->clk);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\t__raw_writel(LPC32XXAD_INTERNAL | (chan->address) |\n\t\t\t     LPC32XXAD_REFp | LPC32XXAD_REFm,\n\t\t\t     LPC32XXAD_SELECT(st->adc_base));\n\t\t \n\t\t__raw_writel(LPC32XXAD_PDN_CTRL | LPC32XXAD_STROBE,\n\t\t\t     LPC32XXAD_CTRL(st->adc_base));\n\t\twait_for_completion(&st->completion);  \n\t\tclk_disable_unprepare(st->clk);\n\t\t*val = st->value;\n\t\tmutex_unlock(&st->lock);\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = regulator_get_voltage(st->vref) / 1000;\n\t\t*val2 =  10;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info lpc32xx_adc_iio_info = {\n\t.read_raw = &lpc32xx_read_raw,\n};\n\n#define LPC32XX_ADC_CHANNEL_BASE(_index)\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.channel = _index,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.address = LPC32XXAD_IN * _index,\t\t\\\n\t.scan_index = _index,\n\n#define LPC32XX_ADC_CHANNEL(_index) {\t\t\\\n\tLPC32XX_ADC_CHANNEL_BASE(_index)\t\\\n}\n\n#define LPC32XX_ADC_SCALE_CHANNEL(_index) {\t\t\t\\\n\tLPC32XX_ADC_CHANNEL_BASE(_index)\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE)\t\\\n}\n\nstatic const struct iio_chan_spec lpc32xx_adc_iio_channels[] = {\n\tLPC32XX_ADC_CHANNEL(0),\n\tLPC32XX_ADC_CHANNEL(1),\n\tLPC32XX_ADC_CHANNEL(2),\n};\n\nstatic const struct iio_chan_spec lpc32xx_adc_iio_scale_channels[] = {\n\tLPC32XX_ADC_SCALE_CHANNEL(0),\n\tLPC32XX_ADC_SCALE_CHANNEL(1),\n\tLPC32XX_ADC_SCALE_CHANNEL(2),\n};\n\nstatic irqreturn_t lpc32xx_adc_isr(int irq, void *dev_id)\n{\n\tstruct lpc32xx_adc_state *st = dev_id;\n\n\t \n\tst->value = __raw_readl(LPC32XXAD_VALUE(st->adc_base)) &\n\t\tLPC32XXAD_VALUE_MASK;\n\tcomplete(&st->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int lpc32xx_adc_probe(struct platform_device *pdev)\n{\n\tstruct lpc32xx_adc_state *st = NULL;\n\tstruct resource *res;\n\tint retval = -ENODEV;\n\tstruct iio_dev *iodev = NULL;\n\tint irq;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"failed to get platform I/O memory\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tiodev = devm_iio_device_alloc(&pdev->dev, sizeof(*st));\n\tif (!iodev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(iodev);\n\n\tst->adc_base = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t    resource_size(res));\n\tif (!st->adc_base) {\n\t\tdev_err(&pdev->dev, \"failed mapping memory\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tst->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(st->clk)) {\n\t\tdev_err(&pdev->dev, \"failed getting clock\\n\");\n\t\treturn PTR_ERR(st->clk);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tretval = devm_request_irq(&pdev->dev, irq, lpc32xx_adc_isr, 0,\n\t\t\t\t  LPC32XXAD_NAME, st);\n\tif (retval < 0) {\n\t\tdev_err(&pdev->dev, \"failed requesting interrupt\\n\");\n\t\treturn retval;\n\t}\n\n\tst->vref = devm_regulator_get(&pdev->dev, \"vref\");\n\tif (IS_ERR(st->vref)) {\n\t\tiodev->channels = lpc32xx_adc_iio_channels;\n\t\tdev_info(&pdev->dev,\n\t\t\t \"Missing vref regulator: No scaling available\\n\");\n\t} else {\n\t\tiodev->channels = lpc32xx_adc_iio_scale_channels;\n\t}\n\n\tplatform_set_drvdata(pdev, iodev);\n\n\tinit_completion(&st->completion);\n\n\tiodev->name = LPC32XXAD_NAME;\n\tiodev->info = &lpc32xx_adc_iio_info;\n\tiodev->modes = INDIO_DIRECT_MODE;\n\tiodev->num_channels = ARRAY_SIZE(lpc32xx_adc_iio_channels);\n\n\tmutex_init(&st->lock);\n\n\tretval = devm_iio_device_register(&pdev->dev, iodev);\n\tif (retval)\n\t\treturn retval;\n\n\tdev_info(&pdev->dev, \"LPC32XX ADC driver loaded, IRQ %d\\n\", irq);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id lpc32xx_adc_match[] = {\n\t{ .compatible = \"nxp,lpc3220-adc\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, lpc32xx_adc_match);\n\nstatic struct platform_driver lpc32xx_adc_driver = {\n\t.probe\t\t= lpc32xx_adc_probe,\n\t.driver\t\t= {\n\t\t.name\t= LPC32XXAD_NAME,\n\t\t.of_match_table = lpc32xx_adc_match,\n\t},\n};\n\nmodule_platform_driver(lpc32xx_adc_driver);\n\nMODULE_AUTHOR(\"Roland Stigge <stigge@antcom.de>\");\nMODULE_DESCRIPTION(\"LPC32XX ADC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}