{
  "module_name": "viperboard_adc.c",
  "hash_id": "8728f1c1da1bbf8d2b18ea00ace381d89d3abb93e3e1654c5846d47c6154c084",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/viperboard_adc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n\n#include <linux/usb.h>\n#include <linux/iio/iio.h>\n\n#include <linux/mfd/viperboard.h>\n\n#define VPRBRD_ADC_CMD_GET\t\t0x00\n\nstruct vprbrd_adc_msg {\n\tu8 cmd;\n\tu8 chan;\n\tu8 val;\n} __packed;\n\nstruct vprbrd_adc {\n\tstruct vprbrd *vb;\n};\n\n#define VPRBRD_ADC_CHANNEL(_index) {\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.channel = _index,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n}\n\nstatic struct iio_chan_spec const vprbrd_adc_iio_channels[] = {\n\tVPRBRD_ADC_CHANNEL(0),\n\tVPRBRD_ADC_CHANNEL(1),\n\tVPRBRD_ADC_CHANNEL(2),\n\tVPRBRD_ADC_CHANNEL(3),\n};\n\nstatic int vprbrd_iio_read_raw(struct iio_dev *iio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val,\n\t\t\t\tint *val2,\n\t\t\t\tlong info)\n{\n\tint ret, error = 0;\n\tstruct vprbrd_adc *adc = iio_priv(iio_dev);\n\tstruct vprbrd *vb = adc->vb;\n\tstruct vprbrd_adc_msg *admsg = (struct vprbrd_adc_msg *)vb->buf;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&vb->lock);\n\n\t\tadmsg->cmd = VPRBRD_ADC_CMD_GET;\n\t\tadmsg->chan = chan->channel;\n\t\tadmsg->val = 0x00;\n\n\t\tret = usb_control_msg(vb->usb_dev,\n\t\t\tusb_sndctrlpipe(vb->usb_dev, 0), VPRBRD_USB_REQUEST_ADC,\n\t\t\tVPRBRD_USB_TYPE_OUT, 0x0000, 0x0000, admsg,\n\t\t\tsizeof(struct vprbrd_adc_msg), VPRBRD_USB_TIMEOUT_MS);\n\t\tif (ret != sizeof(struct vprbrd_adc_msg)) {\n\t\t\tdev_err(&iio_dev->dev, \"usb send error on adc read\\n\");\n\t\t\terror = -EREMOTEIO;\n\t\t}\n\n\t\tret = usb_control_msg(vb->usb_dev,\n\t\t\tusb_rcvctrlpipe(vb->usb_dev, 0), VPRBRD_USB_REQUEST_ADC,\n\t\t\tVPRBRD_USB_TYPE_IN, 0x0000, 0x0000, admsg,\n\t\t\tsizeof(struct vprbrd_adc_msg), VPRBRD_USB_TIMEOUT_MS);\n\n\t\t*val = admsg->val;\n\n\t\tmutex_unlock(&vb->lock);\n\n\t\tif (ret != sizeof(struct vprbrd_adc_msg)) {\n\t\t\tdev_err(&iio_dev->dev, \"usb recv error on adc read\\n\");\n\t\t\terror = -EREMOTEIO;\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto error;\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\nerror:\n\treturn error;\n}\n\nstatic const struct iio_info vprbrd_adc_iio_info = {\n\t.read_raw = &vprbrd_iio_read_raw,\n};\n\nstatic int vprbrd_adc_probe(struct platform_device *pdev)\n{\n\tstruct vprbrd *vb = dev_get_drvdata(pdev->dev.parent);\n\tstruct vprbrd_adc *adc;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\t \n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*adc));\n\tif (!indio_dev) {\n\t\tdev_err(&pdev->dev, \"failed allocating iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tadc = iio_priv(indio_dev);\n\tadc->vb = vb;\n\tindio_dev->name = \"viperboard adc\";\n\tindio_dev->info = &vprbrd_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = vprbrd_adc_iio_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(vprbrd_adc_iio_channels);\n\n\tret = devm_iio_device_register(&pdev->dev, indio_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not register iio (adc)\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver vprbrd_adc_driver = {\n\t.driver = {\n\t\t.name\t= \"viperboard-adc\",\n\t},\n\t.probe\t\t= vprbrd_adc_probe,\n};\n\nmodule_platform_driver(vprbrd_adc_driver);\n\nMODULE_AUTHOR(\"Lars Poeschel <poeschel@lemonage.de>\");\nMODULE_DESCRIPTION(\"IIO ADC driver for Nano River Techs Viperboard\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:viperboard-adc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}