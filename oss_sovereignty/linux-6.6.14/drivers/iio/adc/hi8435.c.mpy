{
  "module_name": "hi8435.c",
  "hash_id": "4b97d07fe470e29d596abee673b8d7e8c58f49cf48081ff08a31695059f11fb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/hi8435.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_event.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/spi/spi.h>\n#include <linux/gpio/consumer.h>\n\n#define DRV_NAME \"hi8435\"\n\n \n#define HI8435_CTRL_REG\t\t0x02\n#define HI8435_PSEN_REG\t\t0x04\n#define HI8435_TMDATA_REG\t0x1E\n#define HI8435_GOCENHYS_REG\t0x3A\n#define HI8435_SOCENHYS_REG\t0x3C\n#define HI8435_SO7_0_REG\t0x10\n#define HI8435_SO15_8_REG\t0x12\n#define HI8435_SO23_16_REG\t0x14\n#define HI8435_SO31_24_REG\t0x16\n#define HI8435_SO31_0_REG\t0x78\n\n#define HI8435_WRITE_OPCODE\t0x00\n#define HI8435_READ_OPCODE\t0x80\n\n \n#define HI8435_CTRL_TEST\t0x01\n#define HI8435_CTRL_SRST\t0x02\n\nstruct hi8435_priv {\n\tstruct spi_device *spi;\n\tstruct mutex lock;\n\n\tunsigned long event_scan_mask;  \n\tunsigned int event_prev_val;\n\n\tunsigned threshold_lo[2];  \n\tunsigned threshold_hi[2];  \n\tu8 reg_buffer[3] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic int hi8435_readb(struct hi8435_priv *priv, u8 reg, u8 *val)\n{\n\treg |= HI8435_READ_OPCODE;\n\treturn spi_write_then_read(priv->spi, &reg, 1, val, 1);\n}\n\nstatic int hi8435_readw(struct hi8435_priv *priv, u8 reg, u16 *val)\n{\n\tint ret;\n\t__be16 be_val;\n\n\treg |= HI8435_READ_OPCODE;\n\tret = spi_write_then_read(priv->spi, &reg, 1, &be_val, 2);\n\t*val = be16_to_cpu(be_val);\n\n\treturn ret;\n}\n\nstatic int hi8435_readl(struct hi8435_priv *priv, u8 reg, u32 *val)\n{\n\tint ret;\n\t__be32 be_val;\n\n\treg |= HI8435_READ_OPCODE;\n\tret = spi_write_then_read(priv->spi, &reg, 1, &be_val, 4);\n\t*val = be32_to_cpu(be_val);\n\n\treturn ret;\n}\n\nstatic int hi8435_writeb(struct hi8435_priv *priv, u8 reg, u8 val)\n{\n\tpriv->reg_buffer[0] = reg | HI8435_WRITE_OPCODE;\n\tpriv->reg_buffer[1] = val;\n\n\treturn spi_write(priv->spi, priv->reg_buffer, 2);\n}\n\nstatic int hi8435_writew(struct hi8435_priv *priv, u8 reg, u16 val)\n{\n\tpriv->reg_buffer[0] = reg | HI8435_WRITE_OPCODE;\n\tpriv->reg_buffer[1] = (val >> 8) & 0xff;\n\tpriv->reg_buffer[2] = val & 0xff;\n\n\treturn spi_write(priv->spi, priv->reg_buffer, 3);\n}\n\nstatic int hi8435_read_raw(struct iio_dev *idev,\n\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct hi8435_priv *priv = iio_priv(idev);\n\tu32 tmp;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = hi8435_readl(priv, HI8435_SO31_0_REG, &tmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = !!(tmp & BIT(chan->channel));\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int hi8435_read_event_config(struct iio_dev *idev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir)\n{\n\tstruct hi8435_priv *priv = iio_priv(idev);\n\n\treturn !!(priv->event_scan_mask & BIT(chan->channel));\n}\n\nstatic int hi8435_write_event_config(struct iio_dev *idev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir, int state)\n{\n\tstruct hi8435_priv *priv = iio_priv(idev);\n\tint ret;\n\tu32 tmp;\n\n\tif (state) {\n\t\tret = hi8435_readl(priv, HI8435_SO31_0_REG, &tmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (tmp & BIT(chan->channel))\n\t\t\tpriv->event_prev_val |= BIT(chan->channel);\n\t\telse\n\t\t\tpriv->event_prev_val &= ~BIT(chan->channel);\n\n\t\tpriv->event_scan_mask |= BIT(chan->channel);\n\t} else\n\t\tpriv->event_scan_mask &= ~BIT(chan->channel);\n\n\treturn 0;\n}\n\nstatic int hi8435_read_event_value(struct iio_dev *idev,\n\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t   enum iio_event_type type,\n\t\t\t\t   enum iio_event_direction dir,\n\t\t\t\t   enum iio_event_info info,\n\t\t\t\t   int *val, int *val2)\n{\n\tstruct hi8435_priv *priv = iio_priv(idev);\n\tint ret;\n\tu8 mode, psen;\n\tu16 reg;\n\n\tret = hi8435_readb(priv, HI8435_PSEN_REG, &psen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmode = !!(psen & BIT(chan->channel / 8));\n\n\tret = hi8435_readw(priv, mode ? HI8435_SOCENHYS_REG :\n\t\t\t\t HI8435_GOCENHYS_REG, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dir == IIO_EV_DIR_FALLING)\n\t\t*val = ((reg & 0xff) - (reg >> 8)) / 2;\n\telse if (dir == IIO_EV_DIR_RISING)\n\t\t*val = ((reg & 0xff) + (reg >> 8)) / 2;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int hi8435_write_event_value(struct iio_dev *idev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir,\n\t\t\t\t    enum iio_event_info info,\n\t\t\t\t    int val, int val2)\n{\n\tstruct hi8435_priv *priv = iio_priv(idev);\n\tint ret;\n\tu8 mode, psen;\n\tu16 reg;\n\n\tret = hi8435_readb(priv, HI8435_PSEN_REG, &psen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmode = !!(psen & BIT(chan->channel / 8));\n\n\tret = hi8435_readw(priv, mode ? HI8435_SOCENHYS_REG :\n\t\t\t\t HI8435_GOCENHYS_REG, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dir == IIO_EV_DIR_FALLING) {\n\t\t \n\t\tif (val < 2 || val > 21 || (val + 2) > priv->threshold_hi[mode])\n\t\t\treturn -EINVAL;\n\n\t\tif (val == priv->threshold_lo[mode])\n\t\t\treturn 0;\n\n\t\tpriv->threshold_lo[mode] = val;\n\n\t\t \n\t\tif ((priv->threshold_hi[mode] - priv->threshold_lo[mode]) % 2)\n\t\t\tpriv->threshold_hi[mode]--;\n\t} else if (dir == IIO_EV_DIR_RISING) {\n\t\t \n\t\tif (val < 3 || val > 22 || val < (priv->threshold_lo[mode] + 2))\n\t\t\treturn -EINVAL;\n\n\t\tif (val == priv->threshold_hi[mode])\n\t\t\treturn 0;\n\n\t\tpriv->threshold_hi[mode] = val;\n\n\t\t \n\t\tif ((priv->threshold_hi[mode] - priv->threshold_lo[mode]) % 2)\n\t\t\tpriv->threshold_lo[mode]++;\n\t}\n\n\t \n\tmutex_lock(&priv->lock);\n\n\tret = hi8435_readw(priv, mode ? HI8435_SOCENHYS_REG :\n\t\t\t\t HI8435_GOCENHYS_REG, &reg);\n\tif (ret < 0) {\n\t\tmutex_unlock(&priv->lock);\n\t\treturn ret;\n\t}\n\n\t \n\treg = priv->threshold_hi[mode] - priv->threshold_lo[mode];\n\treg <<= 8;\n\t \n\treg |= (priv->threshold_hi[mode] + priv->threshold_lo[mode]);\n\n\tret = hi8435_writew(priv, mode ? HI8435_SOCENHYS_REG :\n\t\t\t\t  HI8435_GOCENHYS_REG, reg);\n\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int hi8435_debugfs_reg_access(struct iio_dev *idev,\n\t\t\t\t     unsigned reg, unsigned writeval,\n\t\t\t\t     unsigned *readval)\n{\n\tstruct hi8435_priv *priv = iio_priv(idev);\n\tint ret;\n\tu8 val;\n\n\tif (readval != NULL) {\n\t\tret = hi8435_readb(priv, reg, &val);\n\t\t*readval = val;\n\t} else {\n\t\tval = (u8)writeval;\n\t\tret = hi8435_writeb(priv, reg, val);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct iio_event_spec hi8435_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic int hi8435_get_sensing_mode(struct iio_dev *idev,\n\t\t\t\t   const struct iio_chan_spec *chan)\n{\n\tstruct hi8435_priv *priv = iio_priv(idev);\n\tint ret;\n\tu8 reg;\n\n\tret = hi8435_readb(priv, HI8435_PSEN_REG, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(reg & BIT(chan->channel / 8));\n}\n\nstatic int hi8435_set_sensing_mode(struct iio_dev *idev,\n\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t   unsigned int mode)\n{\n\tstruct hi8435_priv *priv = iio_priv(idev);\n\tint ret;\n\tu8 reg;\n\n\tmutex_lock(&priv->lock);\n\n\tret = hi8435_readb(priv, HI8435_PSEN_REG, &reg);\n\tif (ret < 0) {\n\t\tmutex_unlock(&priv->lock);\n\t\treturn ret;\n\t}\n\n\treg &= ~BIT(chan->channel / 8);\n\tif (mode)\n\t\treg |= BIT(chan->channel / 8);\n\n\tret = hi8435_writeb(priv, HI8435_PSEN_REG, reg);\n\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic const char * const hi8435_sensing_modes[] = { \"GND-Open\",\n\t\t\t\t\t\t     \"Supply-Open\" };\n\nstatic const struct iio_enum hi8435_sensing_mode = {\n\t.items = hi8435_sensing_modes,\n\t.num_items = ARRAY_SIZE(hi8435_sensing_modes),\n\t.get = hi8435_get_sensing_mode,\n\t.set = hi8435_set_sensing_mode,\n};\n\nstatic const struct iio_chan_spec_ext_info hi8435_ext_info[] = {\n\tIIO_ENUM(\"sensing_mode\", IIO_SEPARATE, &hi8435_sensing_mode),\n\tIIO_ENUM_AVAILABLE(\"sensing_mode\", IIO_SHARED_BY_TYPE, &hi8435_sensing_mode),\n\t{},\n};\n\n#define HI8435_VOLTAGE_CHANNEL(num)\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.channel = num,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.event_spec = hi8435_events,\t\t\t\\\n\t.num_event_specs = ARRAY_SIZE(hi8435_events),\t\\\n\t.ext_info = hi8435_ext_info,\t\t\t\\\n}\n\nstatic const struct iio_chan_spec hi8435_channels[] = {\n\tHI8435_VOLTAGE_CHANNEL(0),\n\tHI8435_VOLTAGE_CHANNEL(1),\n\tHI8435_VOLTAGE_CHANNEL(2),\n\tHI8435_VOLTAGE_CHANNEL(3),\n\tHI8435_VOLTAGE_CHANNEL(4),\n\tHI8435_VOLTAGE_CHANNEL(5),\n\tHI8435_VOLTAGE_CHANNEL(6),\n\tHI8435_VOLTAGE_CHANNEL(7),\n\tHI8435_VOLTAGE_CHANNEL(8),\n\tHI8435_VOLTAGE_CHANNEL(9),\n\tHI8435_VOLTAGE_CHANNEL(10),\n\tHI8435_VOLTAGE_CHANNEL(11),\n\tHI8435_VOLTAGE_CHANNEL(12),\n\tHI8435_VOLTAGE_CHANNEL(13),\n\tHI8435_VOLTAGE_CHANNEL(14),\n\tHI8435_VOLTAGE_CHANNEL(15),\n\tHI8435_VOLTAGE_CHANNEL(16),\n\tHI8435_VOLTAGE_CHANNEL(17),\n\tHI8435_VOLTAGE_CHANNEL(18),\n\tHI8435_VOLTAGE_CHANNEL(19),\n\tHI8435_VOLTAGE_CHANNEL(20),\n\tHI8435_VOLTAGE_CHANNEL(21),\n\tHI8435_VOLTAGE_CHANNEL(22),\n\tHI8435_VOLTAGE_CHANNEL(23),\n\tHI8435_VOLTAGE_CHANNEL(24),\n\tHI8435_VOLTAGE_CHANNEL(25),\n\tHI8435_VOLTAGE_CHANNEL(26),\n\tHI8435_VOLTAGE_CHANNEL(27),\n\tHI8435_VOLTAGE_CHANNEL(28),\n\tHI8435_VOLTAGE_CHANNEL(29),\n\tHI8435_VOLTAGE_CHANNEL(30),\n\tHI8435_VOLTAGE_CHANNEL(31),\n\tIIO_CHAN_SOFT_TIMESTAMP(32),\n};\n\nstatic const struct iio_info hi8435_info = {\n\t.read_raw = hi8435_read_raw,\n\t.read_event_config = hi8435_read_event_config,\n\t.write_event_config = hi8435_write_event_config,\n\t.read_event_value = hi8435_read_event_value,\n\t.write_event_value = hi8435_write_event_value,\n\t.debugfs_reg_access = hi8435_debugfs_reg_access,\n};\n\nstatic void hi8435_iio_push_event(struct iio_dev *idev, unsigned int val)\n{\n\tstruct hi8435_priv *priv = iio_priv(idev);\n\tenum iio_event_direction dir;\n\tunsigned int i;\n\tunsigned int status = priv->event_prev_val ^ val;\n\n\tif (!status)\n\t\treturn;\n\n\tfor_each_set_bit(i, &priv->event_scan_mask, 32) {\n\t\tif (status & BIT(i)) {\n\t\t\tdir = val & BIT(i) ? IIO_EV_DIR_RISING :\n\t\t\t\t\t     IIO_EV_DIR_FALLING;\n\t\t\tiio_push_event(idev,\n\t\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, i,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH, dir),\n\t\t\t\t       iio_get_time_ns(idev));\n\t\t}\n\t}\n\n\tpriv->event_prev_val = val;\n}\n\nstatic irqreturn_t hi8435_trigger_handler(int irq, void *private)\n{\n\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *idev = pf->indio_dev;\n\tstruct hi8435_priv *priv = iio_priv(idev);\n\tu32 val;\n\tint ret;\n\n\tret = hi8435_readl(priv, HI8435_SO31_0_REG, &val);\n\tif (ret < 0)\n\t\tgoto err_read;\n\n\thi8435_iio_push_event(idev, val);\n\nerr_read:\n\tiio_trigger_notify_done(idev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void hi8435_triggered_event_cleanup(void *data)\n{\n\tiio_triggered_event_cleanup(data);\n}\n\nstatic int hi8435_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *idev;\n\tstruct hi8435_priv *priv;\n\tstruct gpio_desc *reset_gpio;\n\tint ret;\n\n\tidev = devm_iio_device_alloc(&spi->dev, sizeof(*priv));\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tpriv = iio_priv(idev);\n\tpriv->spi = spi;\n\n\treset_gpio = devm_gpiod_get(&spi->dev, NULL, GPIOD_OUT_LOW);\n\tif (IS_ERR(reset_gpio)) {\n\t\t \n\t\thi8435_writeb(priv, HI8435_CTRL_REG, HI8435_CTRL_SRST);\n\t\thi8435_writeb(priv, HI8435_CTRL_REG, 0);\n\t} else {\n\t\tudelay(5);\n\t\tgpiod_set_value_cansleep(reset_gpio, 1);\n\t}\n\n\tmutex_init(&priv->lock);\n\n\tidev->name\t\t= spi_get_device_id(spi)->name;\n\tidev->modes\t\t= INDIO_DIRECT_MODE;\n\tidev->info\t\t= &hi8435_info;\n\tidev->channels\t\t= hi8435_channels;\n\tidev->num_channels\t= ARRAY_SIZE(hi8435_channels);\n\n\t \n\tpriv->event_scan_mask = ~(0);\n\t \n\tpriv->threshold_lo[0] = priv->threshold_lo[1] = 2;\n\tpriv->threshold_hi[0] = priv->threshold_hi[1] = 4;\n\thi8435_writew(priv, HI8435_GOCENHYS_REG, 0x206);\n\thi8435_writew(priv, HI8435_SOCENHYS_REG, 0x206);\n\n\tret = iio_triggered_event_setup(idev, NULL, hi8435_trigger_handler);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev,\n\t\t\t\t       hi8435_triggered_event_cleanup,\n\t\t\t\t       idev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, idev);\n}\n\nstatic const struct of_device_id hi8435_dt_ids[] = {\n\t{ .compatible = \"holt,hi8435\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hi8435_dt_ids);\n\nstatic const struct spi_device_id hi8435_id[] = {\n\t{ \"hi8435\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, hi8435_id);\n\nstatic struct spi_driver hi8435_driver = {\n\t.driver\t= {\n\t\t.name\t\t= DRV_NAME,\n\t\t.of_match_table\t= hi8435_dt_ids,\n\t},\n\t.probe\t\t= hi8435_probe,\n\t.id_table\t= hi8435_id,\n};\nmodule_spi_driver(hi8435_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Vladimir Barinov\");\nMODULE_DESCRIPTION(\"HI-8435 threshold detector\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}