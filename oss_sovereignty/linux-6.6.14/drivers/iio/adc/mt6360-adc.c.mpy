{
  "module_name": "mt6360-adc.c",
  "hash_id": "29672583583496b30a3974baa4c3d8a70a58c9a5a026e1e8be49d5faa341f65c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/mt6360-adc.c",
  "human_readable_source": "\n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#include <asm/unaligned.h>\n\n#define MT6360_REG_PMUCHGCTRL3\t0x313\n#define MT6360_REG_PMUADCCFG\t0x356\n#define MT6360_REG_PMUADCIDLET\t0x358\n#define MT6360_REG_PMUADCRPT1\t0x35A\n\n \n#define MT6360_AICR_MASK\tGENMASK(7, 2)\n#define MT6360_AICR_SHFT\t2\n#define MT6360_AICR_400MA\t0x6\n \n#define MT6360_ADCEN_MASK\tBIT(15)\n \n#define MT6360_PREFERCH_MASK\tGENMASK(7, 4)\n#define MT6360_PREFERCH_SHFT\t4\n#define MT6360_RPTCH_MASK\tGENMASK(3, 0)\n#define MT6360_NO_PREFER\t15\n\n \n#define ADC_WAIT_TIME_MS\t25\n#define ADC_CONV_TIMEOUT_MS\t100\n#define ADC_LOOP_TIME_US\t2000\n\nenum {\n\tMT6360_CHAN_USBID = 0,\n\tMT6360_CHAN_VBUSDIV5,\n\tMT6360_CHAN_VBUSDIV2,\n\tMT6360_CHAN_VSYS,\n\tMT6360_CHAN_VBAT,\n\tMT6360_CHAN_IBUS,\n\tMT6360_CHAN_IBAT,\n\tMT6360_CHAN_CHG_VDDP,\n\tMT6360_CHAN_TEMP_JC,\n\tMT6360_CHAN_VREF_TS,\n\tMT6360_CHAN_TS,\n\tMT6360_CHAN_MAX\n};\n\nstruct mt6360_adc_data {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\t \n\tstruct mutex adc_lock;\n\tktime_t last_off_timestamps[MT6360_CHAN_MAX];\n};\n\nstatic int mt6360_adc_read_channel(struct mt6360_adc_data *mad, int channel, int *val)\n{\n\t__be16 adc_enable;\n\tu8 rpt[3];\n\tktime_t predict_end_t, timeout;\n\tunsigned int pre_wait_time;\n\tint ret;\n\n\tmutex_lock(&mad->adc_lock);\n\n\t \n\tret = regmap_update_bits(mad->regmap, MT6360_REG_PMUADCRPT1, MT6360_PREFERCH_MASK,\n\t\t\t\t channel << MT6360_PREFERCH_SHFT);\n\tif (ret)\n\t\tgoto out_adc_lock;\n\n\tadc_enable = cpu_to_be16(MT6360_ADCEN_MASK | BIT(channel));\n\tret = regmap_raw_write(mad->regmap, MT6360_REG_PMUADCCFG, &adc_enable, sizeof(adc_enable));\n\tif (ret)\n\t\tgoto out_adc_lock;\n\n\tpredict_end_t = ktime_add_ms(mad->last_off_timestamps[channel], 2 * ADC_WAIT_TIME_MS);\n\n\tif (ktime_after(ktime_get(), predict_end_t))\n\t\tpre_wait_time = ADC_WAIT_TIME_MS;\n\telse\n\t\tpre_wait_time = 3 * ADC_WAIT_TIME_MS;\n\n\tif (msleep_interruptible(pre_wait_time)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_adc_conv;\n\t}\n\n\ttimeout = ktime_add_ms(ktime_get(), ADC_CONV_TIMEOUT_MS);\n\twhile (true) {\n\t\tret = regmap_raw_read(mad->regmap, MT6360_REG_PMUADCRPT1, rpt, sizeof(rpt));\n\t\tif (ret)\n\t\t\tgoto out_adc_conv;\n\n\t\t \n\t\tif ((rpt[0] & MT6360_RPTCH_MASK) == channel)\n\t\t\tbreak;\n\n\t\tif (ktime_compare(ktime_get(), timeout) > 0) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto out_adc_conv;\n\t\t}\n\n\t\tusleep_range(ADC_LOOP_TIME_US / 2, ADC_LOOP_TIME_US);\n\t}\n\n\t*val = rpt[1] << 8 | rpt[2];\n\tret = IIO_VAL_INT;\n\nout_adc_conv:\n\t \n\tadc_enable = cpu_to_be16(MT6360_ADCEN_MASK);\n\tregmap_raw_write(mad->regmap, MT6360_REG_PMUADCCFG, &adc_enable, sizeof(adc_enable));\n\tmad->last_off_timestamps[channel] = ktime_get();\n\t \n\tregmap_update_bits(mad->regmap, MT6360_REG_PMUADCRPT1, MT6360_PREFERCH_MASK,\n\t\t\t   MT6360_NO_PREFER << MT6360_PREFERCH_SHFT);\nout_adc_lock:\n\tmutex_unlock(&mad->adc_lock);\n\n\treturn ret;\n}\n\nstatic int mt6360_adc_read_scale(struct mt6360_adc_data *mad, int channel, int *val, int *val2)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tswitch (channel) {\n\tcase MT6360_CHAN_USBID:\n\tcase MT6360_CHAN_VSYS:\n\tcase MT6360_CHAN_VBAT:\n\tcase MT6360_CHAN_CHG_VDDP:\n\tcase MT6360_CHAN_VREF_TS:\n\tcase MT6360_CHAN_TS:\n\t\t*val = 1250;\n\t\treturn IIO_VAL_INT;\n\tcase MT6360_CHAN_VBUSDIV5:\n\t\t*val = 6250;\n\t\treturn IIO_VAL_INT;\n\tcase MT6360_CHAN_VBUSDIV2:\n\tcase MT6360_CHAN_IBUS:\n\tcase MT6360_CHAN_IBAT:\n\t\t*val = 2500;\n\n\t\tif (channel == MT6360_CHAN_IBUS) {\n\t\t\t \n\t\t\t \n\t\t\tret = regmap_read(mad->regmap, MT6360_REG_PMUCHGCTRL3, &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tregval = (regval & MT6360_AICR_MASK) >> MT6360_AICR_SHFT;\n\t\t\tif (regval < MT6360_AICR_400MA)\n\t\t\t\t*val = 1900;\n\t\t}\n\n\t\treturn IIO_VAL_INT;\n\tcase MT6360_CHAN_TEMP_JC:\n\t\t*val = 105;\n\t\t*val2 = 100;\n\t\treturn IIO_VAL_FRACTIONAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mt6360_adc_read_offset(struct mt6360_adc_data *mad, int channel, int *val)\n{\n\t*val = (channel == MT6360_CHAN_TEMP_JC) ? -80 : 0;\n\treturn IIO_VAL_INT;\n}\n\nstatic int mt6360_adc_read_raw(struct iio_dev *iio_dev, const struct iio_chan_spec *chan,\n\t\t\t       int *val, int *val2, long mask)\n{\n\tstruct mt6360_adc_data *mad = iio_priv(iio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn mt6360_adc_read_channel(mad, chan->channel, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn mt6360_adc_read_scale(mad, chan->channel, val, val2);\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\treturn mt6360_adc_read_offset(mad, chan->channel, val);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const char *mt6360_channel_labels[MT6360_CHAN_MAX] = {\n\t\"usbid\", \"vbusdiv5\", \"vbusdiv2\", \"vsys\", \"vbat\", \"ibus\", \"ibat\", \"chg_vddp\",\n\t\"temp_jc\", \"vref_ts\", \"ts\",\n};\n\nstatic int mt6360_adc_read_label(struct iio_dev *iio_dev, const struct iio_chan_spec *chan,\n\t\t\t\t char *label)\n{\n\treturn snprintf(label, PAGE_SIZE, \"%s\\n\", mt6360_channel_labels[chan->channel]);\n}\n\nstatic const struct iio_info mt6360_adc_iio_info = {\n\t.read_raw = mt6360_adc_read_raw,\n\t.read_label = mt6360_adc_read_label,\n};\n\n#define MT6360_ADC_CHAN(_idx, _type) {\t\t\t\t\\\n\t.type = _type,\t\t\t\t\t\t\\\n\t.channel = MT6360_CHAN_##_idx,\t\t\t\t\\\n\t.scan_index = MT6360_CHAN_##_idx,\t\t\t\\\n\t.datasheet_name = #_idx,\t\t\t\t\\\n\t.scan_type =  {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.endianness = IIO_CPU,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\t\\\n}\n\nstatic const struct iio_chan_spec mt6360_adc_channels[] = {\n\tMT6360_ADC_CHAN(USBID, IIO_VOLTAGE),\n\tMT6360_ADC_CHAN(VBUSDIV5, IIO_VOLTAGE),\n\tMT6360_ADC_CHAN(VBUSDIV2, IIO_VOLTAGE),\n\tMT6360_ADC_CHAN(VSYS, IIO_VOLTAGE),\n\tMT6360_ADC_CHAN(VBAT, IIO_VOLTAGE),\n\tMT6360_ADC_CHAN(IBUS, IIO_CURRENT),\n\tMT6360_ADC_CHAN(IBAT, IIO_CURRENT),\n\tMT6360_ADC_CHAN(CHG_VDDP, IIO_VOLTAGE),\n\tMT6360_ADC_CHAN(TEMP_JC, IIO_TEMP),\n\tMT6360_ADC_CHAN(VREF_TS, IIO_VOLTAGE),\n\tMT6360_ADC_CHAN(TS, IIO_VOLTAGE),\n\tIIO_CHAN_SOFT_TIMESTAMP(MT6360_CHAN_MAX),\n};\n\nstatic irqreturn_t mt6360_adc_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct mt6360_adc_data *mad = iio_priv(indio_dev);\n\tstruct {\n\t\tu16 values[MT6360_CHAN_MAX];\n\t\tint64_t timestamp;\n\t} data __aligned(8);\n\tint i = 0, bit, val, ret;\n\n\tmemset(&data, 0, sizeof(data));\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask, indio_dev->masklength) {\n\t\tret = mt6360_adc_read_channel(mad, bit, &val);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&indio_dev->dev, \"Failed to get channel %d conversion val\\n\", bit);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata.values[i++] = val;\n\t}\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data, iio_get_time_ns(indio_dev));\nout:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline int mt6360_adc_reset(struct mt6360_adc_data *info)\n{\n\t__be16 adc_enable;\n\tktime_t all_off_time;\n\tint i, ret;\n\n\t \n\tret = regmap_write(info->regmap, MT6360_REG_PMUADCIDLET, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tadc_enable = cpu_to_be16(MT6360_ADCEN_MASK);\n\tret = regmap_raw_write(info->regmap, MT6360_REG_PMUADCCFG, &adc_enable, sizeof(adc_enable));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tall_off_time = ktime_get();\n\tfor (i = 0; i < MT6360_CHAN_MAX; i++)\n\t\tinfo->last_off_timestamps[i] = all_off_time;\n\n\treturn 0;\n}\n\nstatic int mt6360_adc_probe(struct platform_device *pdev)\n{\n\tstruct mt6360_adc_data *mad;\n\tstruct regmap *regmap;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tregmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!regmap) {\n\t\tdev_err(&pdev->dev, \"Failed to get parent regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*mad));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tmad = iio_priv(indio_dev);\n\tmad->dev = &pdev->dev;\n\tmad->regmap = regmap;\n\tmutex_init(&mad->adc_lock);\n\n\tret = mt6360_adc_reset(mad);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to reset adc\\n\");\n\t\treturn ret;\n\t}\n\n\tindio_dev->name = dev_name(&pdev->dev);\n\tindio_dev->info = &mt6360_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = mt6360_adc_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mt6360_adc_channels);\n\n\tret = devm_iio_triggered_buffer_setup(&pdev->dev, indio_dev, NULL,\n\t\t\t\t\t      mt6360_adc_trigger_handler, NULL);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate iio trigger buffer\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&pdev->dev, indio_dev);\n}\n\nstatic const struct of_device_id mt6360_adc_of_id[] = {\n\t{ .compatible = \"mediatek,mt6360-adc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mt6360_adc_of_id);\n\nstatic struct platform_driver mt6360_adc_driver = {\n\t.driver = {\n\t\t.name = \"mt6360-adc\",\n\t\t.of_match_table = mt6360_adc_of_id,\n\t},\n\t.probe = mt6360_adc_probe,\n};\nmodule_platform_driver(mt6360_adc_driver);\n\nMODULE_AUTHOR(\"Gene Chen <gene_chen@richtek.com>\");\nMODULE_DESCRIPTION(\"MT6360 ADC Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}