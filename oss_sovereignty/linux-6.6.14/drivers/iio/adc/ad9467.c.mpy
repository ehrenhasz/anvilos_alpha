{
  "module_name": "ad9467.c",
  "hash_id": "283a1cd02c7a6be16968fae1c536a87d863cb4559ec354e47f6bf0568b8f28b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad9467.c",
  "human_readable_source": "\n \n#include <linux/cleanup.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#include <linux/clk.h>\n\n#include <linux/iio/adc/adi-axi-adc.h>\n\n \n\n#define AN877_ADC_REG_CHIP_PORT_CONF\t\t0x00\n#define AN877_ADC_REG_CHIP_ID\t\t\t0x01\n#define AN877_ADC_REG_CHIP_GRADE\t\t0x02\n#define AN877_ADC_REG_CHAN_INDEX\t\t0x05\n#define AN877_ADC_REG_TRANSFER\t\t\t0xFF\n#define AN877_ADC_REG_MODES\t\t\t0x08\n#define AN877_ADC_REG_TEST_IO\t\t\t0x0D\n#define AN877_ADC_REG_ADC_INPUT\t\t\t0x0F\n#define AN877_ADC_REG_OFFSET\t\t\t0x10\n#define AN877_ADC_REG_OUTPUT_MODE\t\t0x14\n#define AN877_ADC_REG_OUTPUT_ADJUST\t\t0x15\n#define AN877_ADC_REG_OUTPUT_PHASE\t\t0x16\n#define AN877_ADC_REG_OUTPUT_DELAY\t\t0x17\n#define AN877_ADC_REG_VREF\t\t\t0x18\n#define AN877_ADC_REG_ANALOG_INPUT\t\t0x2C\n\n \n#define AN877_ADC_TESTMODE_OFF\t\t\t0x0\n#define AN877_ADC_TESTMODE_MIDSCALE_SHORT\t0x1\n#define AN877_ADC_TESTMODE_POS_FULLSCALE\t0x2\n#define AN877_ADC_TESTMODE_NEG_FULLSCALE\t0x3\n#define AN877_ADC_TESTMODE_ALT_CHECKERBOARD\t0x4\n#define AN877_ADC_TESTMODE_PN23_SEQ\t\t0x5\n#define AN877_ADC_TESTMODE_PN9_SEQ\t\t0x6\n#define AN877_ADC_TESTMODE_ONE_ZERO_TOGGLE\t0x7\n#define AN877_ADC_TESTMODE_USER\t\t\t0x8\n#define AN877_ADC_TESTMODE_BIT_TOGGLE\t\t0x9\n#define AN877_ADC_TESTMODE_SYNC\t\t\t0xA\n#define AN877_ADC_TESTMODE_ONE_BIT_HIGH\t\t0xB\n#define AN877_ADC_TESTMODE_MIXED_BIT_FREQUENCY\t0xC\n#define AN877_ADC_TESTMODE_RAMP\t\t\t0xF\n\n \n#define AN877_ADC_TRANSFER_SYNC\t\t\t0x1\n\n \n#define AN877_ADC_OUTPUT_MODE_OFFSET_BINARY\t0x0\n#define AN877_ADC_OUTPUT_MODE_TWOS_COMPLEMENT\t0x1\n#define AN877_ADC_OUTPUT_MODE_GRAY_CODE\t\t0x2\n\n \n#define AN877_ADC_OUTPUT_EVEN_ODD_MODE_EN\t0x20\n#define AN877_ADC_INVERT_DCO_CLK\t\t0x80\n\n \n#define AN877_ADC_DCO_DELAY_ENABLE\t\t0x80\n\n \n\n#define CHIPID_AD9265\t\t\t0x64\n#define AD9265_DEF_OUTPUT_MODE\t\t0x40\n#define AD9265_REG_VREF_MASK\t\t0xC0\n\n \n\n#define CHIPID_AD9434\t\t\t0x6A\n#define AD9434_DEF_OUTPUT_MODE\t\t0x00\n#define AD9434_REG_VREF_MASK\t\t0xC0\n\n \n\n#define CHIPID_AD9467\t\t\t0x50\n#define AD9467_DEF_OUTPUT_MODE\t\t0x08\n#define AD9467_REG_VREF_MASK\t\t0x0F\n\nenum {\n\tID_AD9265,\n\tID_AD9434,\n\tID_AD9467,\n};\n\nstruct ad9467_chip_info {\n\tstruct adi_axi_adc_chip_info\taxi_adc_info;\n\tunsigned int\t\t\tdefault_output_mode;\n\tunsigned int\t\t\tvref_mask;\n};\n\n#define to_ad9467_chip_info(_info)\t\\\n\tcontainer_of(_info, struct ad9467_chip_info, axi_adc_info)\n\nstruct ad9467_state {\n\tstruct spi_device\t\t*spi;\n\tstruct clk\t\t\t*clk;\n\tunsigned int\t\t\toutput_mode;\n\tunsigned int                    (*scales)[2];\n\n\tstruct gpio_desc\t\t*pwrdown_gpio;\n\t \n\tstruct mutex\t\t\tlock;\n};\n\nstatic int ad9467_spi_read(struct spi_device *spi, unsigned int reg)\n{\n\tunsigned char tbuf[2], rbuf[1];\n\tint ret;\n\n\ttbuf[0] = 0x80 | (reg >> 8);\n\ttbuf[1] = reg & 0xFF;\n\n\tret = spi_write_then_read(spi,\n\t\t\t\t  tbuf, ARRAY_SIZE(tbuf),\n\t\t\t\t  rbuf, ARRAY_SIZE(rbuf));\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn rbuf[0];\n}\n\nstatic int ad9467_spi_write(struct spi_device *spi, unsigned int reg,\n\t\t\t    unsigned int val)\n{\n\tunsigned char buf[3];\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xFF;\n\tbuf[2] = val;\n\n\treturn spi_write(spi, buf, ARRAY_SIZE(buf));\n}\n\nstatic int ad9467_reg_access(struct adi_axi_adc_conv *conv, unsigned int reg,\n\t\t\t     unsigned int writeval, unsigned int *readval)\n{\n\tstruct ad9467_state *st = adi_axi_adc_conv_priv(conv);\n\tstruct spi_device *spi = st->spi;\n\tint ret;\n\n\tif (readval == NULL) {\n\t\tguard(mutex)(&st->lock);\n\t\tret = ad9467_spi_write(spi, reg, writeval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn ad9467_spi_write(spi, AN877_ADC_REG_TRANSFER,\n\t\t\t\t\tAN877_ADC_TRANSFER_SYNC);\n\t}\n\n\tret = ad9467_spi_read(spi, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\t*readval = ret;\n\n\treturn 0;\n}\n\nstatic const unsigned int ad9265_scale_table[][2] = {\n\t{1250, 0x00}, {1500, 0x40}, {1750, 0x80}, {2000, 0xC0},\n};\n\nstatic const unsigned int ad9434_scale_table[][2] = {\n\t{1600, 0x1C}, {1580, 0x1D}, {1550, 0x1E}, {1520, 0x1F}, {1500, 0x00},\n\t{1470, 0x01}, {1440, 0x02}, {1420, 0x03}, {1390, 0x04}, {1360, 0x05},\n\t{1340, 0x06}, {1310, 0x07}, {1280, 0x08}, {1260, 0x09}, {1230, 0x0A},\n\t{1200, 0x0B}, {1180, 0x0C},\n};\n\nstatic const unsigned int ad9467_scale_table[][2] = {\n\t{2000, 0}, {2100, 6}, {2200, 7},\n\t{2300, 8}, {2400, 9}, {2500, 10},\n};\n\nstatic void __ad9467_get_scale(struct adi_axi_adc_conv *conv, int index,\n\t\t\t       unsigned int *val, unsigned int *val2)\n{\n\tconst struct adi_axi_adc_chip_info *info = conv->chip_info;\n\tconst struct iio_chan_spec *chan = &info->channels[0];\n\tunsigned int tmp;\n\n\ttmp = (info->scale_table[index][0] * 1000000ULL) >>\n\t\t\tchan->scan_type.realbits;\n\t*val = tmp / 1000000;\n\t*val2 = tmp % 1000000;\n}\n\n#define AD9467_CHAN(_chan, _si, _bits, _sign)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel = _chan,\t\t\t\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t\t\\\n\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SCALE), \\\n\t.scan_index = _si,\t\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = _sign,\t\t\t\t\t\t\\\n\t\t.realbits = _bits,\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec ad9434_channels[] = {\n\tAD9467_CHAN(0, 0, 12, 'S'),\n};\n\nstatic const struct iio_chan_spec ad9467_channels[] = {\n\tAD9467_CHAN(0, 0, 16, 'S'),\n};\n\nstatic const struct ad9467_chip_info ad9467_chip_tbl[] = {\n\t[ID_AD9265] = {\n\t\t.axi_adc_info = {\n\t\t\t.id = CHIPID_AD9265,\n\t\t\t.max_rate = 125000000UL,\n\t\t\t.scale_table = ad9265_scale_table,\n\t\t\t.num_scales = ARRAY_SIZE(ad9265_scale_table),\n\t\t\t.channels = ad9467_channels,\n\t\t\t.num_channels = ARRAY_SIZE(ad9467_channels),\n\t\t},\n\t\t.default_output_mode = AD9265_DEF_OUTPUT_MODE,\n\t\t.vref_mask = AD9265_REG_VREF_MASK,\n\t},\n\t[ID_AD9434] = {\n\t\t.axi_adc_info = {\n\t\t\t.id = CHIPID_AD9434,\n\t\t\t.max_rate = 500000000UL,\n\t\t\t.scale_table = ad9434_scale_table,\n\t\t\t.num_scales = ARRAY_SIZE(ad9434_scale_table),\n\t\t\t.channels = ad9434_channels,\n\t\t\t.num_channels = ARRAY_SIZE(ad9434_channels),\n\t\t},\n\t\t.default_output_mode = AD9434_DEF_OUTPUT_MODE,\n\t\t.vref_mask = AD9434_REG_VREF_MASK,\n\t},\n\t[ID_AD9467] = {\n\t\t.axi_adc_info = {\n\t\t\t.id = CHIPID_AD9467,\n\t\t\t.max_rate = 250000000UL,\n\t\t\t.scale_table = ad9467_scale_table,\n\t\t\t.num_scales = ARRAY_SIZE(ad9467_scale_table),\n\t\t\t.channels = ad9467_channels,\n\t\t\t.num_channels = ARRAY_SIZE(ad9467_channels),\n\t\t},\n\t\t.default_output_mode = AD9467_DEF_OUTPUT_MODE,\n\t\t.vref_mask = AD9467_REG_VREF_MASK,\n\t},\n};\n\nstatic int ad9467_get_scale(struct adi_axi_adc_conv *conv, int *val, int *val2)\n{\n\tconst struct adi_axi_adc_chip_info *info = conv->chip_info;\n\tconst struct ad9467_chip_info *info1 = to_ad9467_chip_info(info);\n\tstruct ad9467_state *st = adi_axi_adc_conv_priv(conv);\n\tunsigned int i, vref_val;\n\tint ret;\n\n\tret = ad9467_spi_read(st->spi, AN877_ADC_REG_VREF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvref_val = ret & info1->vref_mask;\n\n\tfor (i = 0; i < info->num_scales; i++) {\n\t\tif (vref_val == info->scale_table[i][1])\n\t\t\tbreak;\n\t}\n\n\tif (i == info->num_scales)\n\t\treturn -ERANGE;\n\n\t__ad9467_get_scale(conv, i, val, val2);\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int ad9467_set_scale(struct adi_axi_adc_conv *conv, int val, int val2)\n{\n\tconst struct adi_axi_adc_chip_info *info = conv->chip_info;\n\tstruct ad9467_state *st = adi_axi_adc_conv_priv(conv);\n\tunsigned int scale_val[2];\n\tunsigned int i;\n\tint ret;\n\n\tif (val != 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < info->num_scales; i++) {\n\t\t__ad9467_get_scale(conv, i, &scale_val[0], &scale_val[1]);\n\t\tif (scale_val[0] != val || scale_val[1] != val2)\n\t\t\tcontinue;\n\n\t\tguard(mutex)(&st->lock);\n\t\tret = ad9467_spi_write(st->spi, AN877_ADC_REG_VREF,\n\t\t\t\t       info->scale_table[i][1]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn ad9467_spi_write(st->spi, AN877_ADC_REG_TRANSFER,\n\t\t\t\t\tAN877_ADC_TRANSFER_SYNC);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ad9467_read_raw(struct adi_axi_adc_conv *conv,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long m)\n{\n\tstruct ad9467_state *st = adi_axi_adc_conv_priv(conv);\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn ad9467_get_scale(conv, val, val2);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = clk_get_rate(st->clk);\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad9467_write_raw(struct adi_axi_adc_conv *conv,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tconst struct adi_axi_adc_chip_info *info = conv->chip_info;\n\tstruct ad9467_state *st = adi_axi_adc_conv_priv(conv);\n\tlong r_clk;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn ad9467_set_scale(conv, val, val2);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tr_clk = clk_round_rate(st->clk, val);\n\t\tif (r_clk < 0 || r_clk > info->max_rate) {\n\t\t\tdev_warn(&st->spi->dev,\n\t\t\t\t \"Error setting ADC sample rate %ld\", r_clk);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn clk_set_rate(st->clk, r_clk);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad9467_read_avail(struct adi_axi_adc_conv *conv,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type, int *length,\n\t\t\t     long mask)\n{\n\tconst struct adi_axi_adc_chip_info *info = conv->chip_info;\n\tstruct ad9467_state *st = adi_axi_adc_conv_priv(conv);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*vals = (const int *)st->scales;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t \n\t\t*length = info->num_scales * 2;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad9467_outputmode_set(struct spi_device *spi, unsigned int mode)\n{\n\tint ret;\n\n\tret = ad9467_spi_write(spi, AN877_ADC_REG_OUTPUT_MODE, mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ad9467_spi_write(spi, AN877_ADC_REG_TRANSFER,\n\t\t\t\tAN877_ADC_TRANSFER_SYNC);\n}\n\nstatic int ad9467_scale_fill(struct adi_axi_adc_conv *conv)\n{\n\tconst struct adi_axi_adc_chip_info *info = conv->chip_info;\n\tstruct ad9467_state *st = adi_axi_adc_conv_priv(conv);\n\tunsigned int i, val1, val2;\n\n\tst->scales = devm_kmalloc_array(&st->spi->dev, info->num_scales,\n\t\t\t\t\tsizeof(*st->scales), GFP_KERNEL);\n\tif (!st->scales)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < info->num_scales; i++) {\n\t\t__ad9467_get_scale(conv, i, &val1, &val2);\n\t\tst->scales[i][0] = val1;\n\t\tst->scales[i][1] = val2;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad9467_preenable_setup(struct adi_axi_adc_conv *conv)\n{\n\tstruct ad9467_state *st = adi_axi_adc_conv_priv(conv);\n\n\treturn ad9467_outputmode_set(st->spi, st->output_mode);\n}\n\nstatic int ad9467_reset(struct device *dev)\n{\n\tstruct gpio_desc *gpio;\n\n\tgpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR_OR_NULL(gpio))\n\t\treturn PTR_ERR_OR_ZERO(gpio);\n\n\tfsleep(1);\n\tgpiod_set_value_cansleep(gpio, 0);\n\tfsleep(10 * USEC_PER_MSEC);\n\n\treturn 0;\n}\n\nstatic int ad9467_probe(struct spi_device *spi)\n{\n\tconst struct ad9467_chip_info *info;\n\tstruct adi_axi_adc_conv *conv;\n\tstruct ad9467_state *st;\n\tunsigned int id;\n\tint ret;\n\n\tinfo = of_device_get_match_data(&spi->dev);\n\tif (!info)\n\t\tinfo = (void *)spi_get_device_id(spi)->driver_data;\n\tif (!info)\n\t\treturn -ENODEV;\n\n\tconv = devm_adi_axi_adc_conv_register(&spi->dev, sizeof(*st));\n\tif (IS_ERR(conv))\n\t\treturn PTR_ERR(conv);\n\n\tst = adi_axi_adc_conv_priv(conv);\n\tst->spi = spi;\n\n\tst->clk = devm_clk_get_enabled(&spi->dev, \"adc-clk\");\n\tif (IS_ERR(st->clk))\n\t\treturn PTR_ERR(st->clk);\n\n\tst->pwrdown_gpio = devm_gpiod_get_optional(&spi->dev, \"powerdown\",\n\t\t\t\t\t\t   GPIOD_OUT_LOW);\n\tif (IS_ERR(st->pwrdown_gpio))\n\t\treturn PTR_ERR(st->pwrdown_gpio);\n\n\tret = ad9467_reset(&spi->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tconv->chip_info = &info->axi_adc_info;\n\n\tret = ad9467_scale_fill(conv);\n\tif (ret)\n\t\treturn ret;\n\n\tid = ad9467_spi_read(spi, AN877_ADC_REG_CHIP_ID);\n\tif (id != conv->chip_info->id) {\n\t\tdev_err(&spi->dev, \"Mismatch CHIP_ID, got 0x%X, expected 0x%X\\n\",\n\t\t\tid, conv->chip_info->id);\n\t\treturn -ENODEV;\n\t}\n\n\tconv->reg_access = ad9467_reg_access;\n\tconv->write_raw = ad9467_write_raw;\n\tconv->read_raw = ad9467_read_raw;\n\tconv->read_avail = ad9467_read_avail;\n\tconv->preenable_setup = ad9467_preenable_setup;\n\n\tst->output_mode = info->default_output_mode |\n\t\t\t  AN877_ADC_OUTPUT_MODE_TWOS_COMPLEMENT;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ad9467_of_match[] = {\n\t{ .compatible = \"adi,ad9265\", .data = &ad9467_chip_tbl[ID_AD9265], },\n\t{ .compatible = \"adi,ad9434\", .data = &ad9467_chip_tbl[ID_AD9434], },\n\t{ .compatible = \"adi,ad9467\", .data = &ad9467_chip_tbl[ID_AD9467], },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ad9467_of_match);\n\nstatic const struct spi_device_id ad9467_ids[] = {\n\t{ \"ad9265\", (kernel_ulong_t)&ad9467_chip_tbl[ID_AD9265] },\n\t{ \"ad9434\", (kernel_ulong_t)&ad9467_chip_tbl[ID_AD9434] },\n\t{ \"ad9467\", (kernel_ulong_t)&ad9467_chip_tbl[ID_AD9467] },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad9467_ids);\n\nstatic struct spi_driver ad9467_driver = {\n\t.driver = {\n\t\t.name = \"ad9467\",\n\t\t.of_match_table = ad9467_of_match,\n\t},\n\t.probe = ad9467_probe,\n\t.id_table = ad9467_ids,\n};\nmodule_spi_driver(ad9467_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD9467 ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_ADI_AXI);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}