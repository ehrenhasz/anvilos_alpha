{
  "module_name": "imx93_adc.c",
  "hash_id": "0bf6af71356d0e7d71e57dfcb92e527c4f0ae0a2ef54160537e686d2f63c2b91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/imx93_adc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/iio/iio.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n\n#define IMX93_ADC_DRIVER_NAME\t\"imx93-adc\"\n\n \n#define IMX93_ADC_MCR\t\t0x00\n#define IMX93_ADC_MSR\t\t0x04\n#define IMX93_ADC_ISR\t\t0x10\n#define IMX93_ADC_IMR\t\t0x20\n#define IMX93_ADC_CIMR0\t\t0x24\n#define IMX93_ADC_CTR0\t\t0x94\n#define IMX93_ADC_NCMR0\t\t0xA4\n#define IMX93_ADC_PCDR0\t\t0x100\n#define IMX93_ADC_PCDR1\t\t0x104\n#define IMX93_ADC_PCDR2\t\t0x108\n#define IMX93_ADC_PCDR3\t\t0x10c\n#define IMX93_ADC_PCDR4\t\t0x110\n#define IMX93_ADC_PCDR5\t\t0x114\n#define IMX93_ADC_PCDR6\t\t0x118\n#define IMX93_ADC_PCDR7\t\t0x11c\n#define IMX93_ADC_CALSTAT\t0x39C\n\n \n#define IMX93_ADC_MCR_MODE_MASK\t\t\tBIT(29)\n#define IMX93_ADC_MCR_NSTART_MASK\t\tBIT(24)\n#define IMX93_ADC_MCR_CALSTART_MASK\t\tBIT(14)\n#define IMX93_ADC_MCR_ADCLKSE_MASK\t\tBIT(8)\n#define IMX93_ADC_MCR_PWDN_MASK\t\t\tBIT(0)\n#define IMX93_ADC_MSR_CALFAIL_MASK\t\tBIT(30)\n#define IMX93_ADC_MSR_CALBUSY_MASK\t\tBIT(29)\n#define IMX93_ADC_MSR_ADCSTATUS_MASK\t\tGENMASK(2, 0)\n#define IMX93_ADC_ISR_ECH_MASK\t\t\tBIT(0)\n#define IMX93_ADC_ISR_EOC_MASK\t\t\tBIT(1)\n#define IMX93_ADC_ISR_EOC_ECH_MASK\t\t(IMX93_ADC_ISR_EOC_MASK | \\\n\t\t\t\t\t\t IMX93_ADC_ISR_ECH_MASK)\n#define IMX93_ADC_IMR_JEOC_MASK\t\t\tBIT(3)\n#define IMX93_ADC_IMR_JECH_MASK\t\t\tBIT(2)\n#define IMX93_ADC_IMR_EOC_MASK\t\t\tBIT(1)\n#define IMX93_ADC_IMR_ECH_MASK\t\t\tBIT(0)\n#define IMX93_ADC_PCDR_CDATA_MASK\t\tGENMASK(11, 0)\n\n \n#define IMX93_ADC_MSR_ADCSTATUS_IDLE\t\t\t0\n#define IMX93_ADC_MSR_ADCSTATUS_POWER_DOWN\t\t1\n#define IMX93_ADC_MSR_ADCSTATUS_WAIT_STATE\t\t2\n#define IMX93_ADC_MSR_ADCSTATUS_BUSY_IN_CALIBRATION\t3\n#define IMX93_ADC_MSR_ADCSTATUS_SAMPLE\t\t\t4\n#define IMX93_ADC_MSR_ADCSTATUS_CONVERSION\t\t6\n\n#define IMX93_ADC_TIMEOUT\t\tmsecs_to_jiffies(100)\n\nstruct imx93_adc {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct clk *ipg_clk;\n\tint irq;\n\tstruct regulator *vref;\n\t \n\tstruct mutex lock;\n\tstruct completion completion;\n};\n\n#define IMX93_ADC_CHAN(_idx) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = (_idx),\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n}\n\nstatic const struct iio_chan_spec imx93_adc_iio_channels[] = {\n\tIMX93_ADC_CHAN(0),\n\tIMX93_ADC_CHAN(1),\n\tIMX93_ADC_CHAN(2),\n\tIMX93_ADC_CHAN(3),\n\tIMX93_ADC_CHAN(4),\n\tIMX93_ADC_CHAN(5),\n\tIMX93_ADC_CHAN(6),\n\tIMX93_ADC_CHAN(7),\n};\n\nstatic void imx93_adc_power_down(struct imx93_adc *adc)\n{\n\tu32 mcr, msr;\n\tint ret;\n\n\tmcr = readl(adc->regs + IMX93_ADC_MCR);\n\tmcr |= FIELD_PREP(IMX93_ADC_MCR_PWDN_MASK, 1);\n\twritel(mcr, adc->regs + IMX93_ADC_MCR);\n\n\tret = readl_poll_timeout(adc->regs + IMX93_ADC_MSR, msr,\n\t\t\t\t ((msr & IMX93_ADC_MSR_ADCSTATUS_MASK) ==\n\t\t\t\t  IMX93_ADC_MSR_ADCSTATUS_POWER_DOWN),\n\t\t\t\t 1, 50);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_warn(adc->dev,\n\t\t\t \"ADC do not in power down mode, current MSR is %x\\n\",\n\t\t\t msr);\n}\n\nstatic void imx93_adc_power_up(struct imx93_adc *adc)\n{\n\tu32 mcr;\n\n\t \n\tmcr = readl(adc->regs + IMX93_ADC_MCR);\n\tmcr &= ~FIELD_PREP(IMX93_ADC_MCR_PWDN_MASK, 1);\n\twritel(mcr, adc->regs + IMX93_ADC_MCR);\n}\n\nstatic void imx93_adc_config_ad_clk(struct imx93_adc *adc)\n{\n\tu32 mcr;\n\n\t \n\timx93_adc_power_down(adc);\n\n\t \n\tmcr = readl(adc->regs + IMX93_ADC_MCR);\n\tmcr |= FIELD_PREP(IMX93_ADC_MCR_ADCLKSE_MASK, 1);\n\twritel(mcr, adc->regs + IMX93_ADC_MCR);\n\n\timx93_adc_power_up(adc);\n}\n\nstatic int imx93_adc_calibration(struct imx93_adc *adc)\n{\n\tu32 mcr, msr;\n\tint ret;\n\n\t \n\timx93_adc_power_down(adc);\n\n\t \n\tmcr = readl(adc->regs + IMX93_ADC_MCR);\n\tmcr &= ~FIELD_PREP(IMX93_ADC_MCR_ADCLKSE_MASK, 1);\n\twritel(mcr, adc->regs + IMX93_ADC_MCR);\n\n\timx93_adc_power_up(adc);\n\n\t \n\n\t \n\tmcr = readl(adc->regs + IMX93_ADC_MCR);\n\tmcr |= FIELD_PREP(IMX93_ADC_MCR_CALSTART_MASK, 1);\n\twritel(mcr, adc->regs + IMX93_ADC_MCR);\n\n\t \n\tret = readl_poll_timeout(adc->regs + IMX93_ADC_MSR, msr,\n\t\t!(msr & IMX93_ADC_MSR_CALBUSY_MASK), 1000, 2000000);\n\tif (ret == -ETIMEDOUT) {\n\t\tdev_warn(adc->dev, \"ADC do not finish calibration in 2 min!\\n\");\n\t\timx93_adc_power_down(adc);\n\t\treturn ret;\n\t}\n\n\t \n\tmsr = readl(adc->regs + IMX93_ADC_MSR);\n\tif (msr & IMX93_ADC_MSR_CALFAIL_MASK) {\n\t\tdev_warn(adc->dev, \"ADC calibration failed!\\n\");\n\t\timx93_adc_power_down(adc);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx93_adc_read_channel_conversion(struct imx93_adc *adc,\n\t\t\t\t\t\tint channel_number,\n\t\t\t\t\t\tint *result)\n{\n\tu32 channel;\n\tu32 imr, mcr, pcda;\n\tlong ret;\n\n\treinit_completion(&adc->completion);\n\n\t \n\tchannel = 1 << channel_number;\n\twritel(channel, adc->regs + IMX93_ADC_NCMR0);\n\n\t \n\n\t \n\timr = FIELD_PREP(IMX93_ADC_IMR_EOC_MASK, 1);\n\twritel(imr, adc->regs + IMX93_ADC_IMR);\n\twritel(channel, adc->regs + IMX93_ADC_CIMR0);\n\n\t \n\tmcr = readl(adc->regs + IMX93_ADC_MCR);\n\tmcr &= ~FIELD_PREP(IMX93_ADC_MCR_MODE_MASK, 1);\n\twritel(mcr, adc->regs + IMX93_ADC_MCR);\n\n\t \n\tmcr = readl(adc->regs + IMX93_ADC_MCR);\n\tmcr |= FIELD_PREP(IMX93_ADC_MCR_NSTART_MASK, 1);\n\twritel(mcr, adc->regs + IMX93_ADC_MCR);\n\n\tret = wait_for_completion_interruptible_timeout(&adc->completion,\n\t\t\t\t\t\t\tIMX93_ADC_TIMEOUT);\n\tif (ret == 0)\n\t\treturn -ETIMEDOUT;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpcda = readl(adc->regs + IMX93_ADC_PCDR0 + channel_number * 4);\n\n\t*result = FIELD_GET(IMX93_ADC_PCDR_CDATA_MASK, pcda);\n\n\treturn ret;\n}\n\nstatic int imx93_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tstruct imx93_adc *adc = iio_priv(indio_dev);\n\tstruct device *dev = adc->dev;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tpm_runtime_get_sync(dev);\n\t\tmutex_lock(&adc->lock);\n\t\tret = imx93_adc_read_channel_conversion(adc, chan->channel, val);\n\t\tmutex_unlock(&adc->lock);\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tpm_runtime_put_sync_autosuspend(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = regulator_get_voltage(adc->vref);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret / 1000;\n\t\t*val2 = 12;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = clk_get_rate(adc->ipg_clk);\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic irqreturn_t imx93_adc_isr(int irq, void *dev_id)\n{\n\tstruct imx93_adc *adc = dev_id;\n\tu32 isr, eoc, unexpected;\n\n\tisr = readl(adc->regs + IMX93_ADC_ISR);\n\n\tif (FIELD_GET(IMX93_ADC_ISR_EOC_ECH_MASK, isr)) {\n\t\teoc = isr & IMX93_ADC_ISR_EOC_ECH_MASK;\n\t\twritel(eoc, adc->regs + IMX93_ADC_ISR);\n\t\tcomplete(&adc->completion);\n\t}\n\n\tunexpected = isr & ~IMX93_ADC_ISR_EOC_ECH_MASK;\n\tif (unexpected) {\n\t\twritel(unexpected, adc->regs + IMX93_ADC_ISR);\n\t\tdev_err(adc->dev, \"Unexpected interrupt 0x%08x.\\n\", unexpected);\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_info imx93_adc_iio_info = {\n\t.read_raw = &imx93_adc_read_raw,\n};\n\nstatic int imx93_adc_probe(struct platform_device *pdev)\n{\n\tstruct imx93_adc *adc;\n\tstruct iio_dev *indio_dev;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn dev_err_probe(dev, -ENOMEM,\n\t\t\t\t     \"Failed allocating iio device\\n\");\n\n\tadc = iio_priv(indio_dev);\n\tadc->dev = dev;\n\n\tmutex_init(&adc->lock);\n\tadc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(adc->regs))\n\t\treturn dev_err_probe(dev, PTR_ERR(adc->regs),\n\t\t\t\t     \"Failed getting ioremap resource\\n\");\n\n\t \n\tadc->irq = platform_get_irq(pdev, 2);\n\tif (adc->irq < 0)\n\t\treturn adc->irq;\n\n\tadc->ipg_clk = devm_clk_get(dev, \"ipg\");\n\tif (IS_ERR(adc->ipg_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(adc->ipg_clk),\n\t\t\t\t     \"Failed getting clock.\\n\");\n\n\tadc->vref = devm_regulator_get(dev, \"vref\");\n\tif (IS_ERR(adc->vref))\n\t\treturn dev_err_probe(dev, PTR_ERR(adc->vref),\n\t\t\t\t     \"Failed getting reference voltage.\\n\");\n\n\tret = regulator_enable(adc->vref);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to enable reference voltage.\\n\");\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tinit_completion(&adc->completion);\n\n\tindio_dev->name = \"imx93-adc\";\n\tindio_dev->info = &imx93_adc_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = imx93_adc_iio_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(imx93_adc_iio_channels);\n\n\tret = clk_prepare_enable(adc->ipg_clk);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret,\n\t\t\t      \"Failed to enable ipg clock.\\n\");\n\t\tgoto error_regulator_disable;\n\t}\n\n\tret = request_irq(adc->irq, imx93_adc_isr, 0, IMX93_ADC_DRIVER_NAME, adc);\n\tif (ret < 0) {\n\t\tdev_err_probe(dev, ret,\n\t\t\t      \"Failed requesting irq, irq = %d\\n\", adc->irq);\n\t\tgoto error_ipg_clk_disable;\n\t}\n\n\tret = imx93_adc_calibration(adc);\n\tif (ret < 0)\n\t\tgoto error_free_adc_irq;\n\n\timx93_adc_config_ad_clk(adc);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret,\n\t\t\t      \"Failed to register this iio device.\\n\");\n\t\tgoto error_adc_power_down;\n\t}\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 50);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\nerror_adc_power_down:\n\timx93_adc_power_down(adc);\nerror_free_adc_irq:\n\tfree_irq(adc->irq, adc);\nerror_ipg_clk_disable:\n\tclk_disable_unprepare(adc->ipg_clk);\nerror_regulator_disable:\n\tregulator_disable(adc->vref);\n\n\treturn ret;\n}\n\nstatic int imx93_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct imx93_adc *adc = iio_priv(indio_dev);\n\tstruct device *dev = adc->dev;\n\n\t \n\tpm_runtime_get_sync(dev);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_put_noidle(dev);\n\n\tiio_device_unregister(indio_dev);\n\timx93_adc_power_down(adc);\n\tfree_irq(adc->irq, adc);\n\tclk_disable_unprepare(adc->ipg_clk);\n\tregulator_disable(adc->vref);\n\n\treturn 0;\n}\n\nstatic int imx93_adc_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct imx93_adc *adc = iio_priv(indio_dev);\n\n\timx93_adc_power_down(adc);\n\tclk_disable_unprepare(adc->ipg_clk);\n\tregulator_disable(adc->vref);\n\n\treturn 0;\n}\n\nstatic int imx93_adc_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct imx93_adc *adc = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_enable(adc->vref);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Can't enable adc reference top voltage, err = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(adc->ipg_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not prepare or enable clock.\\n\");\n\t\tgoto err_disable_reg;\n\t}\n\n\timx93_adc_power_up(adc);\n\n\treturn 0;\n\nerr_disable_reg:\n\tregulator_disable(adc->vref);\n\n\treturn ret;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(imx93_adc_pm_ops,\n\t\t\t\t imx93_adc_runtime_suspend,\n\t\t\t\t imx93_adc_runtime_resume, NULL);\n\nstatic const struct of_device_id imx93_adc_match[] = {\n\t{ .compatible = \"nxp,imx93-adc\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx93_adc_match);\n\nstatic struct platform_driver imx93_adc_driver = {\n\t.probe\t\t= imx93_adc_probe,\n\t.remove\t\t= imx93_adc_remove,\n\t.driver\t\t= {\n\t\t.name\t= IMX93_ADC_DRIVER_NAME,\n\t\t.of_match_table = imx93_adc_match,\n\t\t.pm\t= pm_ptr(&imx93_adc_pm_ops),\n\t},\n};\n\nmodule_platform_driver(imx93_adc_driver);\n\nMODULE_DESCRIPTION(\"NXP i.MX93 ADC driver\");\nMODULE_AUTHOR(\"Haibo Chen <haibo.chen@nxp.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}