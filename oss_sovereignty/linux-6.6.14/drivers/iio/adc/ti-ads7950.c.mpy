{
  "module_name": "ti-ads7950.c",
  "hash_id": "7ff0335fd825485ec9951eef044609e0f51361b1fbc86f8f268336e70bdb941b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-ads7950.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n \n#define TI_ADS7950_VA_MV_ACPI_DEFAULT\t5000\n\n#define TI_ADS7950_CR_GPIO\tBIT(14)\n#define TI_ADS7950_CR_MANUAL\tBIT(12)\n#define TI_ADS7950_CR_WRITE\tBIT(11)\n#define TI_ADS7950_CR_CHAN(ch)\t((ch) << 7)\n#define TI_ADS7950_CR_RANGE_5V\tBIT(6)\n#define TI_ADS7950_CR_GPIO_DATA\tBIT(4)\n\n#define TI_ADS7950_MAX_CHAN\t16\n#define TI_ADS7950_NUM_GPIOS\t4\n\n#define TI_ADS7950_TIMESTAMP_SIZE (sizeof(int64_t) / sizeof(__be16))\n\n \n#define TI_ADS7950_EXTRACT(val, dec, bits) \\\n\t(((val) >> (dec)) & ((1 << (bits)) - 1))\n\n#define TI_ADS7950_MAN_CMD(cmd)         (TI_ADS7950_CR_MANUAL | (cmd))\n#define TI_ADS7950_GPIO_CMD(cmd)        (TI_ADS7950_CR_GPIO | (cmd))\n\n \n#define TI_ADS7950_MAN_CMD_SETTINGS(st) \\\n\t(TI_ADS7950_MAN_CMD(TI_ADS7950_CR_WRITE | st->cmd_settings_bitmask))\n \n#define TI_ADS7950_GPIO_CMD_SETTINGS(st) \\\n\t(TI_ADS7950_GPIO_CMD(st->gpio_cmd_settings_bitmask))\n\nstruct ti_ads7950_state {\n\tstruct spi_device\t*spi;\n\tstruct spi_transfer\tring_xfer;\n\tstruct spi_transfer\tscan_single_xfer[3];\n\tstruct spi_message\tring_msg;\n\tstruct spi_message\tscan_single_msg;\n\n\t \n\tstruct mutex\t\tslock;\n\tstruct gpio_chip\tchip;\n\n\tstruct regulator\t*reg;\n\tunsigned int\t\tvref_mv;\n\n\t \n\tunsigned int\t\tcmd_settings_bitmask;\n\n\t \n\tunsigned int\t\tgpio_cmd_settings_bitmask;\n\n\t \n\tu16 rx_buf[TI_ADS7950_MAX_CHAN + 2 + TI_ADS7950_TIMESTAMP_SIZE]\n\t\t__aligned(IIO_DMA_MINALIGN);\n\tu16 tx_buf[TI_ADS7950_MAX_CHAN + 2];\n\tu16 single_tx;\n\tu16 single_rx;\n\n};\n\nstruct ti_ads7950_chip_info {\n\tconst struct iio_chan_spec *channels;\n\tunsigned int num_channels;\n};\n\nenum ti_ads7950_id {\n\tTI_ADS7950,\n\tTI_ADS7951,\n\tTI_ADS7952,\n\tTI_ADS7953,\n\tTI_ADS7954,\n\tTI_ADS7955,\n\tTI_ADS7956,\n\tTI_ADS7957,\n\tTI_ADS7958,\n\tTI_ADS7959,\n\tTI_ADS7960,\n\tTI_ADS7961,\n};\n\n#define TI_ADS7950_V_CHAN(index, bits)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = index,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.address = index,\t\t\t\t\t\\\n\t.datasheet_name = \"CH##index\",\t\t\t\t\\\n\t.scan_index = index,\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = bits,\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.shift = 12 - (bits),\t\t\t\t\\\n\t\t.endianness = IIO_CPU,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\n#define DECLARE_TI_ADS7950_4_CHANNELS(name, bits) \\\nconst struct iio_chan_spec name ## _channels[] = { \\\n\tTI_ADS7950_V_CHAN(0, bits), \\\n\tTI_ADS7950_V_CHAN(1, bits), \\\n\tTI_ADS7950_V_CHAN(2, bits), \\\n\tTI_ADS7950_V_CHAN(3, bits), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(4), \\\n}\n\n#define DECLARE_TI_ADS7950_8_CHANNELS(name, bits) \\\nconst struct iio_chan_spec name ## _channels[] = { \\\n\tTI_ADS7950_V_CHAN(0, bits), \\\n\tTI_ADS7950_V_CHAN(1, bits), \\\n\tTI_ADS7950_V_CHAN(2, bits), \\\n\tTI_ADS7950_V_CHAN(3, bits), \\\n\tTI_ADS7950_V_CHAN(4, bits), \\\n\tTI_ADS7950_V_CHAN(5, bits), \\\n\tTI_ADS7950_V_CHAN(6, bits), \\\n\tTI_ADS7950_V_CHAN(7, bits), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(8), \\\n}\n\n#define DECLARE_TI_ADS7950_12_CHANNELS(name, bits) \\\nconst struct iio_chan_spec name ## _channels[] = { \\\n\tTI_ADS7950_V_CHAN(0, bits), \\\n\tTI_ADS7950_V_CHAN(1, bits), \\\n\tTI_ADS7950_V_CHAN(2, bits), \\\n\tTI_ADS7950_V_CHAN(3, bits), \\\n\tTI_ADS7950_V_CHAN(4, bits), \\\n\tTI_ADS7950_V_CHAN(5, bits), \\\n\tTI_ADS7950_V_CHAN(6, bits), \\\n\tTI_ADS7950_V_CHAN(7, bits), \\\n\tTI_ADS7950_V_CHAN(8, bits), \\\n\tTI_ADS7950_V_CHAN(9, bits), \\\n\tTI_ADS7950_V_CHAN(10, bits), \\\n\tTI_ADS7950_V_CHAN(11, bits), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(12), \\\n}\n\n#define DECLARE_TI_ADS7950_16_CHANNELS(name, bits) \\\nconst struct iio_chan_spec name ## _channels[] = { \\\n\tTI_ADS7950_V_CHAN(0, bits), \\\n\tTI_ADS7950_V_CHAN(1, bits), \\\n\tTI_ADS7950_V_CHAN(2, bits), \\\n\tTI_ADS7950_V_CHAN(3, bits), \\\n\tTI_ADS7950_V_CHAN(4, bits), \\\n\tTI_ADS7950_V_CHAN(5, bits), \\\n\tTI_ADS7950_V_CHAN(6, bits), \\\n\tTI_ADS7950_V_CHAN(7, bits), \\\n\tTI_ADS7950_V_CHAN(8, bits), \\\n\tTI_ADS7950_V_CHAN(9, bits), \\\n\tTI_ADS7950_V_CHAN(10, bits), \\\n\tTI_ADS7950_V_CHAN(11, bits), \\\n\tTI_ADS7950_V_CHAN(12, bits), \\\n\tTI_ADS7950_V_CHAN(13, bits), \\\n\tTI_ADS7950_V_CHAN(14, bits), \\\n\tTI_ADS7950_V_CHAN(15, bits), \\\n\tIIO_CHAN_SOFT_TIMESTAMP(16), \\\n}\n\nstatic DECLARE_TI_ADS7950_4_CHANNELS(ti_ads7950, 12);\nstatic DECLARE_TI_ADS7950_8_CHANNELS(ti_ads7951, 12);\nstatic DECLARE_TI_ADS7950_12_CHANNELS(ti_ads7952, 12);\nstatic DECLARE_TI_ADS7950_16_CHANNELS(ti_ads7953, 12);\nstatic DECLARE_TI_ADS7950_4_CHANNELS(ti_ads7954, 10);\nstatic DECLARE_TI_ADS7950_8_CHANNELS(ti_ads7955, 10);\nstatic DECLARE_TI_ADS7950_12_CHANNELS(ti_ads7956, 10);\nstatic DECLARE_TI_ADS7950_16_CHANNELS(ti_ads7957, 10);\nstatic DECLARE_TI_ADS7950_4_CHANNELS(ti_ads7958, 8);\nstatic DECLARE_TI_ADS7950_8_CHANNELS(ti_ads7959, 8);\nstatic DECLARE_TI_ADS7950_12_CHANNELS(ti_ads7960, 8);\nstatic DECLARE_TI_ADS7950_16_CHANNELS(ti_ads7961, 8);\n\nstatic const struct ti_ads7950_chip_info ti_ads7950_chip_info[] = {\n\t[TI_ADS7950] = {\n\t\t.channels\t= ti_ads7950_channels,\n\t\t.num_channels\t= ARRAY_SIZE(ti_ads7950_channels),\n\t},\n\t[TI_ADS7951] = {\n\t\t.channels\t= ti_ads7951_channels,\n\t\t.num_channels\t= ARRAY_SIZE(ti_ads7951_channels),\n\t},\n\t[TI_ADS7952] = {\n\t\t.channels\t= ti_ads7952_channels,\n\t\t.num_channels\t= ARRAY_SIZE(ti_ads7952_channels),\n\t},\n\t[TI_ADS7953] = {\n\t\t.channels\t= ti_ads7953_channels,\n\t\t.num_channels\t= ARRAY_SIZE(ti_ads7953_channels),\n\t},\n\t[TI_ADS7954] = {\n\t\t.channels\t= ti_ads7954_channels,\n\t\t.num_channels\t= ARRAY_SIZE(ti_ads7954_channels),\n\t},\n\t[TI_ADS7955] = {\n\t\t.channels\t= ti_ads7955_channels,\n\t\t.num_channels\t= ARRAY_SIZE(ti_ads7955_channels),\n\t},\n\t[TI_ADS7956] = {\n\t\t.channels\t= ti_ads7956_channels,\n\t\t.num_channels\t= ARRAY_SIZE(ti_ads7956_channels),\n\t},\n\t[TI_ADS7957] = {\n\t\t.channels\t= ti_ads7957_channels,\n\t\t.num_channels\t= ARRAY_SIZE(ti_ads7957_channels),\n\t},\n\t[TI_ADS7958] = {\n\t\t.channels\t= ti_ads7958_channels,\n\t\t.num_channels\t= ARRAY_SIZE(ti_ads7958_channels),\n\t},\n\t[TI_ADS7959] = {\n\t\t.channels\t= ti_ads7959_channels,\n\t\t.num_channels\t= ARRAY_SIZE(ti_ads7959_channels),\n\t},\n\t[TI_ADS7960] = {\n\t\t.channels\t= ti_ads7960_channels,\n\t\t.num_channels\t= ARRAY_SIZE(ti_ads7960_channels),\n\t},\n\t[TI_ADS7961] = {\n\t\t.channels\t= ti_ads7961_channels,\n\t\t.num_channels\t= ARRAY_SIZE(ti_ads7961_channels),\n\t},\n};\n\n \nstatic int ti_ads7950_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t       const unsigned long *active_scan_mask)\n{\n\tstruct ti_ads7950_state *st = iio_priv(indio_dev);\n\tint i, cmd, len;\n\n\tlen = 0;\n\tfor_each_set_bit(i, active_scan_mask, indio_dev->num_channels) {\n\t\tcmd = TI_ADS7950_MAN_CMD(TI_ADS7950_CR_CHAN(i));\n\t\tst->tx_buf[len++] = cmd;\n\t}\n\n\t \n\tst->tx_buf[len++] = 0;\n\tst->tx_buf[len++] = 0;\n\n\tst->ring_xfer.len = len * 2;\n\n\treturn 0;\n}\n\nstatic irqreturn_t ti_ads7950_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ti_ads7950_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->slock);\n\tret = spi_sync(st->spi, &st->ring_msg);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &st->rx_buf[2],\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\nout:\n\tmutex_unlock(&st->slock);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ti_ads7950_scan_direct(struct iio_dev *indio_dev, unsigned int ch)\n{\n\tstruct ti_ads7950_state *st = iio_priv(indio_dev);\n\tint ret, cmd;\n\n\tmutex_lock(&st->slock);\n\tcmd = TI_ADS7950_MAN_CMD(TI_ADS7950_CR_CHAN(ch));\n\tst->single_tx = cmd;\n\n\tret = spi_sync(st->spi, &st->scan_single_msg);\n\tif (ret)\n\t\tgoto out;\n\n\tret = st->single_rx;\n\nout:\n\tmutex_unlock(&st->slock);\n\n\treturn ret;\n}\n\nstatic int ti_ads7950_get_range(struct ti_ads7950_state *st)\n{\n\tint vref;\n\n\tif (st->vref_mv) {\n\t\tvref = st->vref_mv;\n\t} else {\n\t\tvref = regulator_get_voltage(st->reg);\n\t\tif (vref < 0)\n\t\t\treturn vref;\n\n\t\tvref /= 1000;\n\t}\n\n\tif (st->cmd_settings_bitmask & TI_ADS7950_CR_RANGE_5V)\n\t\tvref *= 2;\n\n\treturn vref;\n}\n\nstatic int ti_ads7950_read_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int *val, int *val2, long m)\n{\n\tstruct ti_ads7950_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = ti_ads7950_scan_direct(indio_dev, chan->address);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (chan->address != TI_ADS7950_EXTRACT(ret, 12, 4))\n\t\t\treturn -EIO;\n\n\t\t*val = TI_ADS7950_EXTRACT(ret, chan->scan_type.shift,\n\t\t\t\t\t  chan->scan_type.realbits);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = ti_ads7950_get_range(st);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret;\n\t\t*val2 = (1 << chan->scan_type.realbits) - 1;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info ti_ads7950_info = {\n\t.read_raw\t\t= &ti_ads7950_read_raw,\n\t.update_scan_mode\t= ti_ads7950_update_scan_mode,\n};\n\nstatic void ti_ads7950_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t   int value)\n{\n\tstruct ti_ads7950_state *st = gpiochip_get_data(chip);\n\n\tmutex_lock(&st->slock);\n\n\tif (value)\n\t\tst->cmd_settings_bitmask |= BIT(offset);\n\telse\n\t\tst->cmd_settings_bitmask &= ~BIT(offset);\n\n\tst->single_tx = TI_ADS7950_MAN_CMD_SETTINGS(st);\n\tspi_sync(st->spi, &st->scan_single_msg);\n\n\tmutex_unlock(&st->slock);\n}\n\nstatic int ti_ads7950_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct ti_ads7950_state *st = gpiochip_get_data(chip);\n\tint ret;\n\n\tmutex_lock(&st->slock);\n\n\t \n\tif (st->gpio_cmd_settings_bitmask & BIT(offset)) {\n\t\tret = st->cmd_settings_bitmask & BIT(offset);\n\t\tgoto out;\n\t}\n\n\t \n\tst->cmd_settings_bitmask |= TI_ADS7950_CR_GPIO_DATA;\n\tst->single_tx = TI_ADS7950_MAN_CMD_SETTINGS(st);\n\tret = spi_sync(st->spi, &st->scan_single_msg);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ((st->single_rx >> 12) & BIT(offset)) ? 1 : 0;\n\n\t \n\tst->cmd_settings_bitmask &= ~TI_ADS7950_CR_GPIO_DATA;\n\tst->single_tx = TI_ADS7950_MAN_CMD_SETTINGS(st);\n\tret = spi_sync(st->spi, &st->scan_single_msg);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tmutex_unlock(&st->slock);\n\n\treturn ret;\n}\n\nstatic int ti_ads7950_get_direction(struct gpio_chip *chip,\n\t\t\t\t    unsigned int offset)\n{\n\tstruct ti_ads7950_state *st = gpiochip_get_data(chip);\n\n\t \n\treturn !(st->gpio_cmd_settings_bitmask & BIT(offset));\n}\n\nstatic int _ti_ads7950_set_direction(struct gpio_chip *chip, int offset,\n\t\t\t\t     int input)\n{\n\tstruct ti_ads7950_state *st = gpiochip_get_data(chip);\n\tint ret = 0;\n\n\tmutex_lock(&st->slock);\n\n\t \n\tif (input && (st->gpio_cmd_settings_bitmask & BIT(offset)))\n\t\tst->gpio_cmd_settings_bitmask &= ~BIT(offset);\n\telse if (!input && !(st->gpio_cmd_settings_bitmask & BIT(offset)))\n\t\tst->gpio_cmd_settings_bitmask |= BIT(offset);\n\telse\n\t\tgoto out;\n\n\tst->single_tx = TI_ADS7950_GPIO_CMD_SETTINGS(st);\n\tret = spi_sync(st->spi, &st->scan_single_msg);\n\nout:\n\tmutex_unlock(&st->slock);\n\n\treturn ret;\n}\n\nstatic int ti_ads7950_direction_input(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset)\n{\n\treturn _ti_ads7950_set_direction(chip, offset, 1);\n}\n\nstatic int ti_ads7950_direction_output(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset, int value)\n{\n\tti_ads7950_set(chip, offset, value);\n\n\treturn _ti_ads7950_set_direction(chip, offset, 0);\n}\n\nstatic int ti_ads7950_init_hw(struct ti_ads7950_state *st)\n{\n\tint ret = 0;\n\n\tmutex_lock(&st->slock);\n\n\t \n\t \n\tst->cmd_settings_bitmask = TI_ADS7950_CR_RANGE_5V;\n\tst->single_tx = TI_ADS7950_MAN_CMD_SETTINGS(st);\n\tret = spi_sync(st->spi, &st->scan_single_msg);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tst->gpio_cmd_settings_bitmask = 0x0;\n\tst->single_tx = TI_ADS7950_GPIO_CMD_SETTINGS(st);\n\tret = spi_sync(st->spi, &st->scan_single_msg);\n\nout:\n\tmutex_unlock(&st->slock);\n\n\treturn ret;\n}\n\nstatic int ti_ads7950_probe(struct spi_device *spi)\n{\n\tstruct ti_ads7950_state *st;\n\tstruct iio_dev *indio_dev;\n\tconst struct ti_ads7950_chip_info *info;\n\tint ret;\n\n\tspi->bits_per_word = 16;\n\tspi->mode |= SPI_CS_WORD;\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"Error in spi setup\\n\");\n\t\treturn ret;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tspi_set_drvdata(spi, indio_dev);\n\n\tst->spi = spi;\n\n\tinfo = &ti_ads7950_chip_info[spi_get_device_id(spi)->driver_data];\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = info->channels;\n\tindio_dev->num_channels = info->num_channels;\n\tindio_dev->info = &ti_ads7950_info;\n\n\t \n\tspi_message_init(&st->ring_msg);\n\n\tst->ring_xfer.tx_buf = &st->tx_buf[0];\n\tst->ring_xfer.rx_buf = &st->rx_buf[0];\n\t \n\n\tspi_message_add_tail(&st->ring_xfer, &st->ring_msg);\n\n\t \n\n\tst->scan_single_xfer[0].tx_buf = &st->single_tx;\n\tst->scan_single_xfer[0].len = 2;\n\tst->scan_single_xfer[0].cs_change = 1;\n\tst->scan_single_xfer[1].tx_buf = &st->single_tx;\n\tst->scan_single_xfer[1].len = 2;\n\tst->scan_single_xfer[1].cs_change = 1;\n\tst->scan_single_xfer[2].rx_buf = &st->single_rx;\n\tst->scan_single_xfer[2].len = 2;\n\n\tspi_message_init_with_transfers(&st->scan_single_msg,\n\t\t\t\t\tst->scan_single_xfer, 3);\n\n\t \n\tif (ACPI_COMPANION(&spi->dev))\n\t\tst->vref_mv = TI_ADS7950_VA_MV_ACPI_DEFAULT;\n\n\tmutex_init(&st->slock);\n\n\tst->reg = devm_regulator_get(&spi->dev, \"vref\");\n\tif (IS_ERR(st->reg)) {\n\t\tret = dev_err_probe(&spi->dev, PTR_ERR(st->reg),\n\t\t\t\t     \"Failed to get regulator \\\"vref\\\"\\n\");\n\t\tgoto error_destroy_mutex;\n\t}\n\n\tret = regulator_enable(st->reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to enable regulator \\\"vref\\\"\\n\");\n\t\tgoto error_destroy_mutex;\n\t}\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL,\n\t\t\t\t\t &ti_ads7950_trigger_handler, NULL);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to setup triggered buffer\\n\");\n\t\tgoto error_disable_reg;\n\t}\n\n\tret = ti_ads7950_init_hw(st);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to init adc chip\\n\");\n\t\tgoto error_cleanup_ring;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to register iio device\\n\");\n\t\tgoto error_cleanup_ring;\n\t}\n\n\t \n\tst->chip.label = dev_name(&st->spi->dev);\n\tst->chip.parent = &st->spi->dev;\n\tst->chip.owner = THIS_MODULE;\n\tst->chip.can_sleep = true;\n\tst->chip.base = -1;\n\tst->chip.ngpio = TI_ADS7950_NUM_GPIOS;\n\tst->chip.get_direction = ti_ads7950_get_direction;\n\tst->chip.direction_input = ti_ads7950_direction_input;\n\tst->chip.direction_output = ti_ads7950_direction_output;\n\tst->chip.get = ti_ads7950_get;\n\tst->chip.set = ti_ads7950_set;\n\n\tret = gpiochip_add_data(&st->chip, st);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to init GPIOs\\n\");\n\t\tgoto error_iio_device;\n\t}\n\n\treturn 0;\n\nerror_iio_device:\n\tiio_device_unregister(indio_dev);\nerror_cleanup_ring:\n\tiio_triggered_buffer_cleanup(indio_dev);\nerror_disable_reg:\n\tregulator_disable(st->reg);\nerror_destroy_mutex:\n\tmutex_destroy(&st->slock);\n\n\treturn ret;\n}\n\nstatic void ti_ads7950_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct ti_ads7950_state *st = iio_priv(indio_dev);\n\n\tgpiochip_remove(&st->chip);\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tregulator_disable(st->reg);\n\tmutex_destroy(&st->slock);\n}\n\nstatic const struct spi_device_id ti_ads7950_id[] = {\n\t{ \"ads7950\", TI_ADS7950 },\n\t{ \"ads7951\", TI_ADS7951 },\n\t{ \"ads7952\", TI_ADS7952 },\n\t{ \"ads7953\", TI_ADS7953 },\n\t{ \"ads7954\", TI_ADS7954 },\n\t{ \"ads7955\", TI_ADS7955 },\n\t{ \"ads7956\", TI_ADS7956 },\n\t{ \"ads7957\", TI_ADS7957 },\n\t{ \"ads7958\", TI_ADS7958 },\n\t{ \"ads7959\", TI_ADS7959 },\n\t{ \"ads7960\", TI_ADS7960 },\n\t{ \"ads7961\", TI_ADS7961 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, ti_ads7950_id);\n\nstatic const struct of_device_id ads7950_of_table[] = {\n\t{ .compatible = \"ti,ads7950\", .data = &ti_ads7950_chip_info[TI_ADS7950] },\n\t{ .compatible = \"ti,ads7951\", .data = &ti_ads7950_chip_info[TI_ADS7951] },\n\t{ .compatible = \"ti,ads7952\", .data = &ti_ads7950_chip_info[TI_ADS7952] },\n\t{ .compatible = \"ti,ads7953\", .data = &ti_ads7950_chip_info[TI_ADS7953] },\n\t{ .compatible = \"ti,ads7954\", .data = &ti_ads7950_chip_info[TI_ADS7954] },\n\t{ .compatible = \"ti,ads7955\", .data = &ti_ads7950_chip_info[TI_ADS7955] },\n\t{ .compatible = \"ti,ads7956\", .data = &ti_ads7950_chip_info[TI_ADS7956] },\n\t{ .compatible = \"ti,ads7957\", .data = &ti_ads7950_chip_info[TI_ADS7957] },\n\t{ .compatible = \"ti,ads7958\", .data = &ti_ads7950_chip_info[TI_ADS7958] },\n\t{ .compatible = \"ti,ads7959\", .data = &ti_ads7950_chip_info[TI_ADS7959] },\n\t{ .compatible = \"ti,ads7960\", .data = &ti_ads7950_chip_info[TI_ADS7960] },\n\t{ .compatible = \"ti,ads7961\", .data = &ti_ads7950_chip_info[TI_ADS7961] },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ads7950_of_table);\n\nstatic struct spi_driver ti_ads7950_driver = {\n\t.driver = {\n\t\t.name\t= \"ads7950\",\n\t\t.of_match_table = ads7950_of_table,\n\t},\n\t.probe\t\t= ti_ads7950_probe,\n\t.remove\t\t= ti_ads7950_remove,\n\t.id_table\t= ti_ads7950_id,\n};\nmodule_spi_driver(ti_ads7950_driver);\n\nMODULE_AUTHOR(\"David Lechner <david@lechnology.com>\");\nMODULE_DESCRIPTION(\"TI TI_ADS7950 ADC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}