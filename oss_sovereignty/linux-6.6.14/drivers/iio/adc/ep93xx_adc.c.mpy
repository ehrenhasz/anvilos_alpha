{
  "module_name": "ep93xx_adc.c",
  "hash_id": "2189bc2b2fe915b80e48f6b5989f043e519cfc684ec1bdd2fa0472a72d985eb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ep93xx_adc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/iio/iio.h>\n#include <linux/io.h>\n#include <linux/irqflags.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n\n \n#ifdef CONFIG_HIGH_RES_TIMERS\n#define ep93xx_adc_delay(usmin, usmax) usleep_range(usmin, usmax)\n#else\n#define ep93xx_adc_delay(usmin, usmax) udelay(usmin)\n#endif\n\n#define EP93XX_ADC_RESULT\t0x08\n#define   EP93XX_ADC_SDR\tBIT(31)\n#define EP93XX_ADC_SWITCH\t0x18\n#define EP93XX_ADC_SW_LOCK\t0x20\n\nstruct ep93xx_adc_priv {\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tint lastch;\n\tstruct mutex lock;\n};\n\n#define EP93XX_ADC_CH(index, dname, swcfg) {\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = index,\t\t\t\t\t\\\n\t.address = swcfg,\t\t\t\t\t\\\n\t.datasheet_name = dname,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\t   BIT(IIO_CHAN_INFO_OFFSET),\t\\\n}\n\n \nstatic const struct iio_chan_spec ep93xx_adc_channels[8] = {\n\tEP93XX_ADC_CH(0, \"YM\",\t0x608),\n\tEP93XX_ADC_CH(1, \"SXP\",\t0x680),\n\tEP93XX_ADC_CH(2, \"SXM\",\t0x640),\n\tEP93XX_ADC_CH(3, \"SYP\",\t0x620),\n\tEP93XX_ADC_CH(4, \"SYM\",\t0x610),\n\tEP93XX_ADC_CH(5, \"XP\",\t0x601),\n\tEP93XX_ADC_CH(6, \"XM\",\t0x602),\n\tEP93XX_ADC_CH(7, \"YP\",\t0x604),\n};\n\nstatic int ep93xx_read_raw(struct iio_dev *iiodev,\n\t\t\t   struct iio_chan_spec const *channel, int *value,\n\t\t\t   int *shift, long mask)\n{\n\tstruct ep93xx_adc_priv *priv = iio_priv(iiodev);\n\tunsigned long timeout;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&priv->lock);\n\t\tif (priv->lastch != channel->channel) {\n\t\t\tpriv->lastch = channel->channel;\n\t\t\t \n\t\t\tlocal_irq_disable();\n\t\t\twritel_relaxed(0xAA, priv->base + EP93XX_ADC_SW_LOCK);\n\t\t\twritel_relaxed(channel->address,\n\t\t\t\t       priv->base + EP93XX_ADC_SWITCH);\n\t\t\tlocal_irq_enable();\n\t\t\t \n\t\t\tep93xx_adc_delay(2000, 2000);\n\t\t}\n\t\t \n\t\treadl_relaxed(priv->base + EP93XX_ADC_RESULT);\n\t\t \n\t\tep93xx_adc_delay(DIV_ROUND_UP(1000000, 925),\n\t\t\t\t DIV_ROUND_UP(1000000, 925));\n\t\t \n\t\tret = IIO_VAL_INT;\n\t\ttimeout = jiffies + msecs_to_jiffies(1) + 1;\n\t\twhile (1) {\n\t\t\tu32 t;\n\n\t\t\tt = readl_relaxed(priv->base + EP93XX_ADC_RESULT);\n\t\t\tif (t & EP93XX_ADC_SDR) {\n\t\t\t\t*value = sign_extend32(t, 15);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\tdev_err(&iiodev->dev, \"Conversion timeout\\n\");\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcpu_relax();\n\t\t}\n\t\tmutex_unlock(&priv->lock);\n\t\treturn ret;\n\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\t*value = 25000;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*value = (1ULL << 32) * 3300 / 50000;\n\t\t*shift = 32;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info ep93xx_adc_info = {\n\t.read_raw = ep93xx_read_raw,\n};\n\nstatic int ep93xx_adc_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct iio_dev *iiodev;\n\tstruct ep93xx_adc_priv *priv;\n\tstruct clk *pclk;\n\n\tiiodev = devm_iio_device_alloc(&pdev->dev, sizeof(*priv));\n\tif (!iiodev)\n\t\treturn -ENOMEM;\n\tpriv = iio_priv(iiodev);\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tiiodev->name = dev_name(&pdev->dev);\n\tiiodev->modes = INDIO_DIRECT_MODE;\n\tiiodev->info = &ep93xx_adc_info;\n\tiiodev->num_channels = ARRAY_SIZE(ep93xx_adc_channels);\n\tiiodev->channels = ep93xx_adc_channels;\n\n\tpriv->lastch = -1;\n\tmutex_init(&priv->lock);\n\n\tplatform_set_drvdata(pdev, iiodev);\n\n\tpriv->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(&pdev->dev, \"Cannot obtain clock\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tpclk = clk_get_parent(priv->clk);\n\tif (!pclk) {\n\t\tdev_warn(&pdev->dev, \"Cannot obtain parent clock\\n\");\n\t} else {\n\t\t \n\t\tret = clk_set_rate(priv->clk, clk_get_rate(pclk) / 16);\n\t\tif (ret)\n\t\t\tdev_warn(&pdev->dev, \"Cannot set clock rate\\n\");\n\t\t \n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = iio_device_register(iiodev);\n\tif (ret)\n\t\tclk_disable_unprepare(priv->clk);\n\n\treturn ret;\n}\n\nstatic int ep93xx_adc_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *iiodev = platform_get_drvdata(pdev);\n\tstruct ep93xx_adc_priv *priv = iio_priv(iiodev);\n\n\tiio_device_unregister(iiodev);\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ep93xx_adc_of_ids[] = {\n\t{ .compatible = \"cirrus,ep9301-adc\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ep93xx_adc_of_ids);\n\nstatic struct platform_driver ep93xx_adc_driver = {\n\t.driver = {\n\t\t.name = \"ep93xx-adc\",\n\t\t.of_match_table = ep93xx_adc_of_ids,\n\t},\n\t.probe = ep93xx_adc_probe,\n\t.remove = ep93xx_adc_remove,\n};\nmodule_platform_driver(ep93xx_adc_driver);\n\nMODULE_AUTHOR(\"Alexander Sverdlin <alexander.sverdlin@gmail.com>\");\nMODULE_DESCRIPTION(\"Cirrus Logic EP93XX ADC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:ep93xx-adc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}