{
  "module_name": "ad7298.c",
  "hash_id": "33334d39ce59716c44fd4b6b4f1745f1ed8e41a68c7748e4e2c1bdffe93199cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ad7298.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define AD7298_WRITE\tBIT(15)  \n#define AD7298_REPEAT\tBIT(14)  \n#define AD7298_CH(x)\tBIT(13 - (x))  \n#define AD7298_TSENSE\tBIT(5)  \n#define AD7298_EXTREF\tBIT(2)  \n#define AD7298_TAVG\tBIT(1)  \n#define AD7298_PDD\tBIT(0)  \n\n#define AD7298_MAX_CHAN\t\t8\n#define AD7298_INTREF_mV\t2500\n\n#define AD7298_CH_TEMP\t\t9\n\nstruct ad7298_state {\n\tstruct spi_device\t\t*spi;\n\tstruct regulator\t\t*reg;\n\tunsigned\t\t\text_ref;\n\tstruct spi_transfer\t\tring_xfer[10];\n\tstruct spi_transfer\t\tscan_single_xfer[3];\n\tstruct spi_message\t\tring_msg;\n\tstruct spi_message\t\tscan_single_msg;\n\t \n\t__be16\t\t\t\trx_buf[12] __aligned(IIO_DMA_MINALIGN);\n\t__be16\t\t\t\ttx_buf[2];\n};\n\n#define AD7298_V_CHAN(index)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.channel = index,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t\t.address = index,\t\t\t\t\t\\\n\t\t.scan_index = index,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t\t.realbits = 12,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec ad7298_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\n\t\t.address = AD7298_CH_TEMP,\n\t\t.scan_index = -1,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 32,\n\t\t\t.storagebits = 32,\n\t\t},\n\t},\n\tAD7298_V_CHAN(0),\n\tAD7298_V_CHAN(1),\n\tAD7298_V_CHAN(2),\n\tAD7298_V_CHAN(3),\n\tAD7298_V_CHAN(4),\n\tAD7298_V_CHAN(5),\n\tAD7298_V_CHAN(6),\n\tAD7298_V_CHAN(7),\n\tIIO_CHAN_SOFT_TIMESTAMP(8),\n};\n\n \nstatic int ad7298_update_scan_mode(struct iio_dev *indio_dev,\n\tconst unsigned long *active_scan_mask)\n{\n\tstruct ad7298_state *st = iio_priv(indio_dev);\n\tint i, m;\n\tunsigned short command;\n\tint scan_count;\n\n\t \n\tscan_count = bitmap_weight(active_scan_mask, indio_dev->masklength);\n\n\tcommand = AD7298_WRITE | st->ext_ref;\n\n\tfor (i = 0, m = AD7298_CH(0); i < AD7298_MAX_CHAN; i++, m >>= 1)\n\t\tif (test_bit(i, active_scan_mask))\n\t\t\tcommand |= m;\n\n\tst->tx_buf[0] = cpu_to_be16(command);\n\n\t \n\tst->ring_xfer[0].tx_buf = &st->tx_buf[0];\n\tst->ring_xfer[0].len = 2;\n\tst->ring_xfer[0].cs_change = 1;\n\tst->ring_xfer[1].tx_buf = &st->tx_buf[1];\n\tst->ring_xfer[1].len = 2;\n\tst->ring_xfer[1].cs_change = 1;\n\n\tspi_message_init(&st->ring_msg);\n\tspi_message_add_tail(&st->ring_xfer[0], &st->ring_msg);\n\tspi_message_add_tail(&st->ring_xfer[1], &st->ring_msg);\n\n\tfor (i = 0; i < scan_count; i++) {\n\t\tst->ring_xfer[i + 2].rx_buf = &st->rx_buf[i];\n\t\tst->ring_xfer[i + 2].len = 2;\n\t\tst->ring_xfer[i + 2].cs_change = 1;\n\t\tspi_message_add_tail(&st->ring_xfer[i + 2], &st->ring_msg);\n\t}\n\t \n\tst->ring_xfer[i + 1].cs_change = 0;\n\n\treturn 0;\n}\n\nstatic irqreturn_t ad7298_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ad7298_state *st = iio_priv(indio_dev);\n\tint b_sent;\n\n\tb_sent = spi_sync(st->spi, &st->ring_msg);\n\tif (b_sent)\n\t\tgoto done;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, st->rx_buf,\n\t\tiio_get_time_ns(indio_dev));\n\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ad7298_scan_direct(struct ad7298_state *st, unsigned ch)\n{\n\tint ret;\n\tst->tx_buf[0] = cpu_to_be16(AD7298_WRITE | st->ext_ref |\n\t\t\t\t   (AD7298_CH(0) >> ch));\n\n\tret = spi_sync(st->spi, &st->scan_single_msg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn be16_to_cpu(st->rx_buf[0]);\n}\n\nstatic int ad7298_scan_temp(struct ad7298_state *st, int *val)\n{\n\tint ret;\n\t__be16 buf;\n\n\tbuf = cpu_to_be16(AD7298_WRITE | AD7298_TSENSE |\n\t\t\t  AD7298_TAVG | st->ext_ref);\n\n\tret = spi_write(st->spi, (u8 *)&buf, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tbuf = cpu_to_be16(0);\n\n\tret = spi_write(st->spi, (u8 *)&buf, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(101, 1000);  \n\n\tret = spi_read(st->spi, (u8 *)&buf, 2);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = sign_extend32(be16_to_cpu(buf), 11);\n\n\treturn 0;\n}\n\nstatic int ad7298_get_ref_voltage(struct ad7298_state *st)\n{\n\tint vref;\n\n\tif (st->reg) {\n\t\tvref = regulator_get_voltage(st->reg);\n\t\tif (vref < 0)\n\t\t\treturn vref;\n\n\t\treturn vref / 1000;\n\t} else {\n\t\treturn AD7298_INTREF_mV;\n\t}\n}\n\nstatic int ad7298_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tint ret;\n\tstruct ad7298_state *st = iio_priv(indio_dev);\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (chan->address == AD7298_CH_TEMP)\n\t\t\tret = ad7298_scan_temp(st, val);\n\t\telse\n\t\t\tret = ad7298_scan_direct(st, chan->address);\n\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (chan->address != AD7298_CH_TEMP)\n\t\t\t*val = ret & GENMASK(chan->scan_type.realbits - 1, 0);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\t*val = ad7298_get_ref_voltage(st);\n\t\t\t*val2 = chan->scan_type.realbits;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\tcase IIO_TEMP:\n\t\t\t*val = ad7298_get_ref_voltage(st);\n\t\t\t*val2 = 10;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = 1093 - 2732500 / ad7298_get_ref_voltage(st);\n\t\treturn IIO_VAL_INT;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info ad7298_info = {\n\t.read_raw = &ad7298_read_raw,\n\t.update_scan_mode = ad7298_update_scan_mode,\n};\n\nstatic void ad7298_reg_disable(void *data)\n{\n\tstruct regulator *reg = data;\n\n\tregulator_disable(reg);\n}\n\nstatic int ad7298_probe(struct spi_device *spi)\n{\n\tstruct ad7298_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->reg = devm_regulator_get_optional(&spi->dev, \"vref\");\n\tif (!IS_ERR(st->reg)) {\n\t\tst->ext_ref = AD7298_EXTREF;\n\t} else {\n\t\tret = PTR_ERR(st->reg);\n\t\tif (ret != -ENODEV)\n\t\t\treturn ret;\n\n\t\tst->reg = NULL;\n\t}\n\n\tif (st->reg) {\n\t\tret = regulator_enable(st->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(&spi->dev, ad7298_reg_disable,\n\t\t\t\t\t       st->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tst->spi = spi;\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = ad7298_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ad7298_channels);\n\tindio_dev->info = &ad7298_info;\n\n\t \n\n\tst->scan_single_xfer[0].tx_buf = &st->tx_buf[0];\n\tst->scan_single_xfer[0].len = 2;\n\tst->scan_single_xfer[0].cs_change = 1;\n\tst->scan_single_xfer[1].tx_buf = &st->tx_buf[1];\n\tst->scan_single_xfer[1].len = 2;\n\tst->scan_single_xfer[1].cs_change = 1;\n\tst->scan_single_xfer[2].rx_buf = &st->rx_buf[0];\n\tst->scan_single_xfer[2].len = 2;\n\n\tspi_message_init(&st->scan_single_msg);\n\tspi_message_add_tail(&st->scan_single_xfer[0], &st->scan_single_msg);\n\tspi_message_add_tail(&st->scan_single_xfer[1], &st->scan_single_msg);\n\tspi_message_add_tail(&st->scan_single_xfer[2], &st->scan_single_msg);\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev, NULL,\n\t\t\t&ad7298_trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct acpi_device_id ad7298_acpi_ids[] = {\n\t{ \"INT3494\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, ad7298_acpi_ids);\n\nstatic const struct spi_device_id ad7298_id[] = {\n\t{\"ad7298\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad7298_id);\n\nstatic struct spi_driver ad7298_driver = {\n\t.driver = {\n\t\t.name\t= \"ad7298\",\n\t\t.acpi_match_table = ad7298_acpi_ids,\n\t},\n\t.probe\t\t= ad7298_probe,\n\t.id_table\t= ad7298_id,\n};\nmodule_spi_driver(ad7298_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7298 ADC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}