{
  "module_name": "rtq6056.c",
  "hash_id": "1a9408d0a6bbcf0a8f54de45f2fa78bc3452a56db568a16ef73ff981a31c11c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/rtq6056.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n#include <linux/util_macros.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define RTQ6056_REG_CONFIG\t0x00\n#define RTQ6056_REG_SHUNTVOLT\t0x01\n#define RTQ6056_REG_BUSVOLT\t0x02\n#define RTQ6056_REG_POWER\t0x03\n#define RTQ6056_REG_CURRENT\t0x04\n#define RTQ6056_REG_CALIBRATION\t0x05\n#define RTQ6056_REG_MASKENABLE\t0x06\n#define RTQ6056_REG_ALERTLIMIT\t0x07\n#define RTQ6056_REG_MANUFACTID\t0xFE\n#define RTQ6056_REG_DIEID\t0xFF\n\n#define RTQ6056_VENDOR_ID\t0x1214\n#define RTQ6056_DEFAULT_CONFIG\t0x4127\n#define RTQ6056_CONT_ALLON\t7\n\nenum {\n\tRTQ6056_CH_VSHUNT = 0,\n\tRTQ6056_CH_VBUS,\n\tRTQ6056_CH_POWER,\n\tRTQ6056_CH_CURRENT,\n\tRTQ6056_MAX_CHANNEL\n};\n\nenum {\n\tF_OPMODE = 0,\n\tF_VSHUNTCT,\n\tF_VBUSCT,\n\tF_AVG,\n\tF_RESET,\n\tF_MAX_FIELDS\n};\n\nstruct rtq6056_priv {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regmap_field *rm_fields[F_MAX_FIELDS];\n\tu32 shunt_resistor_uohm;\n\tint vshuntct_us;\n\tint vbusct_us;\n\tint avg_sample;\n};\n\nstatic const struct reg_field rtq6056_reg_fields[F_MAX_FIELDS] = {\n\t[F_OPMODE] = REG_FIELD(RTQ6056_REG_CONFIG, 0, 2),\n\t[F_VSHUNTCT] = REG_FIELD(RTQ6056_REG_CONFIG, 3, 5),\n\t[F_VBUSCT] = REG_FIELD(RTQ6056_REG_CONFIG, 6, 8),\n\t[F_AVG]\t= REG_FIELD(RTQ6056_REG_CONFIG, 9, 11),\n\t[F_RESET] = REG_FIELD(RTQ6056_REG_CONFIG, 15, 15),\n};\n\nstatic const struct iio_chan_spec rtq6056_channels[RTQ6056_MAX_CHANNEL + 1] = {\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.address = RTQ6056_REG_SHUNTVOLT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.indexed = 1,\n\t\t.channel = 1,\n\t\t.address = RTQ6056_REG_BUSVOLT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.scan_index = 1,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_POWER,\n\t\t.indexed = 1,\n\t\t.channel = 2,\n\t\t.address = RTQ6056_REG_POWER,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.scan_index = 2,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_CURRENT,\n\t\t.indexed = 1,\n\t\t.channel = 3,\n\t\t.address = RTQ6056_REG_CURRENT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.scan_index = 3,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(RTQ6056_MAX_CHANNEL),\n};\n\nstatic int rtq6056_adc_read_channel(struct rtq6056_priv *priv,\n\t\t\t\t    struct iio_chan_spec const *ch,\n\t\t\t\t    int *val)\n{\n\tstruct device *dev = priv->dev;\n\tunsigned int addr = ch->address;\n\tunsigned int regval;\n\tint ret;\n\n\tpm_runtime_get_sync(dev);\n\tret = regmap_read(priv->regmap, addr, &regval);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (addr == RTQ6056_REG_BUSVOLT || addr == RTQ6056_REG_POWER)\n\t\t*val = regval;\n\telse\n\t\t*val = sign_extend32(regval, 16);\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int rtq6056_adc_read_scale(struct iio_chan_spec const *ch, int *val,\n\t\t\t\t  int *val2)\n{\n\tswitch (ch->address) {\n\tcase RTQ6056_REG_SHUNTVOLT:\n\t\t \n\t\t*val = 2500;\n\t\t*val2 = 1000000;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase RTQ6056_REG_BUSVOLT:\n\t\t \n\t\t*val = 1250;\n\t\t*val2 = 1000;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase RTQ6056_REG_POWER:\n\t\t \n\t\t*val = 25;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic const int rtq6056_samp_freq_list[] = {\n\t7194, 4926, 3717, 1904, 964, 485, 243, 122,\n};\n\nstatic int rtq6056_adc_set_samp_freq(struct rtq6056_priv *priv,\n\t\t\t\t     struct iio_chan_spec const *ch, int val)\n{\n\tstruct regmap_field *rm_field;\n\tunsigned int selector;\n\tint *ct, ret;\n\n\tif (val > 7194 || val < 122)\n\t\treturn -EINVAL;\n\n\tif (ch->address == RTQ6056_REG_SHUNTVOLT) {\n\t\trm_field = priv->rm_fields[F_VSHUNTCT];\n\t\tct = &priv->vshuntct_us;\n\t} else if (ch->address == RTQ6056_REG_BUSVOLT) {\n\t\trm_field = priv->rm_fields[F_VBUSCT];\n\t\tct = &priv->vbusct_us;\n\t} else\n\t\treturn -EINVAL;\n\n\tselector = find_closest_descending(val, rtq6056_samp_freq_list,\n\t\t\t\t\t   ARRAY_SIZE(rtq6056_samp_freq_list));\n\n\tret = regmap_field_write(rm_field, selector);\n\tif (ret)\n\t\treturn ret;\n\n\t*ct = 1000000 / rtq6056_samp_freq_list[selector];\n\n\treturn 0;\n}\n\n \nstatic const int rtq6056_avg_sample_list[] = {\n\t1, 4, 16, 64, 128, 256, 512, 1024,\n};\n\nstatic int rtq6056_adc_set_average(struct rtq6056_priv *priv, int val)\n{\n\tunsigned int selector;\n\tint ret;\n\n\tif (val > 1024 || val < 1)\n\t\treturn -EINVAL;\n\n\tselector = find_closest(val, rtq6056_avg_sample_list,\n\t\t\t\tARRAY_SIZE(rtq6056_avg_sample_list));\n\n\tret = regmap_field_write(priv->rm_fields[F_AVG], selector);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->avg_sample = rtq6056_avg_sample_list[selector];\n\n\treturn 0;\n}\n\nstatic int rtq6056_adc_get_sample_freq(struct rtq6056_priv *priv,\n\t\t\t\t       struct iio_chan_spec const *ch, int *val)\n{\n\tint sample_time;\n\n\tif (ch->address == RTQ6056_REG_SHUNTVOLT)\n\t\tsample_time = priv->vshuntct_us;\n\telse if (ch->address == RTQ6056_REG_BUSVOLT)\n\t\tsample_time = priv->vbusct_us;\n\telse {\n\t\tsample_time = priv->vshuntct_us + priv->vbusct_us;\n\t\tsample_time *= priv->avg_sample;\n\t}\n\n\t*val = 1000000 / sample_time;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int rtq6056_adc_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan, int *val,\n\t\t\t\tint *val2, long mask)\n{\n\tstruct rtq6056_priv *priv = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn rtq6056_adc_read_channel(priv, chan, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn rtq6056_adc_read_scale(chan, val, val2);\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t*val = priv->avg_sample;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn rtq6056_adc_get_sample_freq(priv, chan, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rtq6056_adc_read_avail(struct iio_dev *indio_dev,\n\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t  const int **vals, int *type, int *length,\n\t\t\t\t  long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*vals = rtq6056_samp_freq_list;\n\t\t*type = IIO_VAL_INT;\n\t\t*length = ARRAY_SIZE(rtq6056_samp_freq_list);\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t*vals = rtq6056_avg_sample_list;\n\t\t*type = IIO_VAL_INT;\n\t\t*length = ARRAY_SIZE(rtq6056_avg_sample_list);\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rtq6056_adc_write_raw(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan, int val,\n\t\t\t\t int val2, long mask)\n{\n\tstruct rtq6056_priv *priv = iio_priv(indio_dev);\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = rtq6056_adc_set_samp_freq(priv, chan, val);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tret = rtq6056_adc_set_average(priv, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret;\n}\n\nstatic const char *rtq6056_channel_labels[RTQ6056_MAX_CHANNEL] = {\n\t[RTQ6056_CH_VSHUNT] = \"Vshunt\",\n\t[RTQ6056_CH_VBUS] = \"Vbus\",\n\t[RTQ6056_CH_POWER] = \"Power\",\n\t[RTQ6056_CH_CURRENT] = \"Current\",\n};\n\nstatic int rtq6056_adc_read_label(struct iio_dev *indio_dev,\n\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t  char *label)\n{\n\treturn sysfs_emit(label, \"%s\\n\", rtq6056_channel_labels[chan->channel]);\n}\n\nstatic int rtq6056_set_shunt_resistor(struct rtq6056_priv *priv,\n\t\t\t\t      int resistor_uohm)\n{\n\tunsigned int calib_val;\n\tint ret;\n\n\tif (resistor_uohm <= 0) {\n\t\tdev_err(priv->dev, \"Invalid resistor [%d]\\n\", resistor_uohm);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcalib_val = 5120000 / resistor_uohm;\n\tret = regmap_write(priv->regmap, RTQ6056_REG_CALIBRATION, calib_val);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->shunt_resistor_uohm = resistor_uohm;\n\n\treturn 0;\n}\n\nstatic ssize_t shunt_resistor_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct rtq6056_priv *priv = iio_priv(dev_to_iio_dev(dev));\n\tint vals[2] = { priv->shunt_resistor_uohm, 1000000 };\n\n\treturn iio_format_value(buf, IIO_VAL_FRACTIONAL, 1, vals);\n}\n\nstatic ssize_t shunt_resistor_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct rtq6056_priv *priv = iio_priv(indio_dev);\n\tint val, val_fract, ret;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iio_str_to_fixpoint(buf, 100000, &val, &val_fract);\n\tif (ret)\n\t\tgoto out_store;\n\n\tret = rtq6056_set_shunt_resistor(priv, val * 1000000 + val_fract);\n\nout_store:\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret ?: len;\n}\n\nstatic IIO_DEVICE_ATTR_RW(shunt_resistor, 0);\n\nstatic struct attribute *rtq6056_attributes[] = {\n\t&iio_dev_attr_shunt_resistor.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group rtq6056_attribute_group = {\n\t.attrs = rtq6056_attributes,\n};\n\nstatic const struct iio_info rtq6056_info = {\n\t.attrs = &rtq6056_attribute_group,\n\t.read_raw = rtq6056_adc_read_raw,\n\t.read_avail = rtq6056_adc_read_avail,\n\t.write_raw = rtq6056_adc_write_raw,\n\t.read_label = rtq6056_adc_read_label,\n};\n\nstatic irqreturn_t rtq6056_buffer_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct rtq6056_priv *priv = iio_priv(indio_dev);\n\tstruct device *dev = priv->dev;\n\tstruct {\n\t\tu16 vals[RTQ6056_MAX_CHANNEL];\n\t\ts64 timestamp __aligned(8);\n\t} data;\n\tunsigned int raw;\n\tint i = 0, bit, ret;\n\n\tmemset(&data, 0, sizeof(data));\n\n\tpm_runtime_get_sync(dev);\n\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask, indio_dev->masklength) {\n\t\tunsigned int addr = rtq6056_channels[bit].address;\n\n\t\tret = regmap_read(priv->regmap, addr, &raw);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tdata.vals[i++] = raw;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data, iio_get_time_ns(indio_dev));\n\nout:\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put(dev);\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rtq6056_enter_shutdown_state(void *dev)\n{\n\tstruct rtq6056_priv *priv = dev_get_drvdata(dev);\n\n\t \n\tregmap_field_write(priv->rm_fields[F_OPMODE], 0);\n}\n\nstatic bool rtq6056_is_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RTQ6056_REG_CONFIG ... RTQ6056_REG_ALERTLIMIT:\n\tcase RTQ6056_REG_MANUFACTID ... RTQ6056_REG_DIEID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rtq6056_is_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RTQ6056_REG_CONFIG:\n\tcase RTQ6056_REG_CALIBRATION ... RTQ6056_REG_ALERTLIMIT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config rtq6056_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n\t.max_register = RTQ6056_REG_DIEID,\n\t.readable_reg = rtq6056_is_readable_reg,\n\t.writeable_reg = rtq6056_is_writeable_reg,\n};\n\nstatic int rtq6056_probe(struct i2c_client *i2c)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct rtq6056_priv *priv;\n\tstruct device *dev = &i2c->dev;\n\tstruct regmap *regmap;\n\tunsigned int vendor_id, shunt_resistor_uohm;\n\tint ret;\n\n\tif (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*priv));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tpriv = iio_priv(indio_dev);\n\tpriv->dev = dev;\n\tpriv->vshuntct_us = priv->vbusct_us = 1037;\n\tpriv->avg_sample = 1;\n\ti2c_set_clientdata(i2c, priv);\n\n\tregmap = devm_regmap_init_i2c(i2c, &rtq6056_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap),\n\t\t\t\t     \"Failed to init regmap\\n\");\n\n\tpriv->regmap = regmap;\n\n\tret = regmap_read(regmap, RTQ6056_REG_MANUFACTID, &vendor_id);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to get manufacturer info\\n\");\n\n\tif (vendor_id != RTQ6056_VENDOR_ID)\n\t\treturn dev_err_probe(dev, -ENODEV,\n\t\t\t\t     \"Invalid vendor id 0x%04x\\n\", vendor_id);\n\n\tret = devm_regmap_field_bulk_alloc(dev, regmap, priv->rm_fields,\n\t\t\t\t\t   rtq6056_reg_fields, F_MAX_FIELDS);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init regmap field\\n\");\n\n\t \n\tret = regmap_write(regmap, RTQ6056_REG_CONFIG, RTQ6056_DEFAULT_CONFIG);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to enable continuous sensing\\n\");\n\n\tret = devm_add_action_or_reset(dev, rtq6056_enter_shutdown_state, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_set_autosuspend_delay(dev, MSEC_PER_SEC);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tret = devm_pm_runtime_enable(dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to enable pm_runtime\\n\");\n\n\t \n\tshunt_resistor_uohm = 2000;\n\tdevice_property_read_u32(dev, \"shunt-resistor-micro-ohms\",\n\t\t\t\t &shunt_resistor_uohm);\n\n\tret = rtq6056_set_shunt_resistor(priv, shunt_resistor_uohm);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to init shunt resistor\\n\");\n\n\tindio_dev->name = \"rtq6056\";\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = rtq6056_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(rtq6056_channels);\n\tindio_dev->info = &rtq6056_info;\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,\n\t\t\t\t\t      rtq6056_buffer_trigger_handler,\n\t\t\t\t\t      NULL);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to allocate iio trigger buffer\\n\");\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic int rtq6056_runtime_suspend(struct device *dev)\n{\n\tstruct rtq6056_priv *priv = dev_get_drvdata(dev);\n\n\t \n\treturn regmap_field_write(priv->rm_fields[F_OPMODE], 0);\n}\n\nstatic int rtq6056_runtime_resume(struct device *dev)\n{\n\tstruct rtq6056_priv *priv = dev_get_drvdata(dev);\n\tint sample_rdy_time_us, ret;\n\n\tret = regmap_field_write(priv->rm_fields[F_OPMODE], RTQ6056_CONT_ALLON);\n\tif (ret)\n\t\treturn ret;\n\n\tsample_rdy_time_us = priv->vbusct_us + priv->vshuntct_us;\n\tsample_rdy_time_us *= priv->avg_sample;\n\n\tusleep_range(sample_rdy_time_us, sample_rdy_time_us + 100);\n\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(rtq6056_pm_ops, rtq6056_runtime_suspend,\n\t\t\t\t rtq6056_runtime_resume, NULL);\n\nstatic const struct of_device_id rtq6056_device_match[] = {\n\t{ .compatible = \"richtek,rtq6056\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rtq6056_device_match);\n\nstatic struct i2c_driver rtq6056_driver = {\n\t.driver = {\n\t\t.name = \"rtq6056\",\n\t\t.of_match_table = rtq6056_device_match,\n\t\t.pm = pm_ptr(&rtq6056_pm_ops),\n\t},\n\t.probe = rtq6056_probe,\n};\nmodule_i2c_driver(rtq6056_driver);\n\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_DESCRIPTION(\"Richtek RTQ6056 Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}