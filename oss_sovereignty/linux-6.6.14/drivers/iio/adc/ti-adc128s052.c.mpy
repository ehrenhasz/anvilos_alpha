{
  "module_name": "ti-adc128s052.c",
  "hash_id": "edc10d287a5b02ea34e6c3c984e1d9732ff60fe7b5e1d965e185a86b498df681",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/ti-adc128s052.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/iio/iio.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\nstruct adc128_configuration {\n\tconst struct iio_chan_spec\t*channels;\n\tu8\t\t\t\tnum_channels;\n};\n\nstruct adc128 {\n\tstruct spi_device *spi;\n\n\tstruct regulator *reg;\n\tstruct mutex lock;\n\n\tu8 buffer[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic int adc128_adc_conversion(struct adc128 *adc, u8 channel)\n{\n\tint ret;\n\n\tmutex_lock(&adc->lock);\n\n\tadc->buffer[0] = channel << 3;\n\tadc->buffer[1] = 0;\n\n\tret = spi_write(adc->spi, &adc->buffer, 2);\n\tif (ret < 0) {\n\t\tmutex_unlock(&adc->lock);\n\t\treturn ret;\n\t}\n\n\tret = spi_read(adc->spi, &adc->buffer, 2);\n\n\tmutex_unlock(&adc->lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ((adc->buffer[0] << 8 | adc->buffer[1]) & 0xFFF);\n}\n\nstatic int adc128_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *channel, int *val,\n\t\t\t   int *val2, long mask)\n{\n\tstruct adc128 *adc = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\n\t\tret = adc128_adc_conversion(adc, channel->channel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\n\t\tret = regulator_get_voltage(adc->reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret / 1000;\n\t\t*val2 = 12;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n}\n\n#define ADC128_VOLTAGE_CHANNEL(num)\t\\\n\t{ \\\n\t\t.type = IIO_VOLTAGE, \\\n\t\t.indexed = 1, \\\n\t\t.channel = (num), \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) \\\n\t}\n\nstatic const struct iio_chan_spec adc128s052_channels[] = {\n\tADC128_VOLTAGE_CHANNEL(0),\n\tADC128_VOLTAGE_CHANNEL(1),\n\tADC128_VOLTAGE_CHANNEL(2),\n\tADC128_VOLTAGE_CHANNEL(3),\n\tADC128_VOLTAGE_CHANNEL(4),\n\tADC128_VOLTAGE_CHANNEL(5),\n\tADC128_VOLTAGE_CHANNEL(6),\n\tADC128_VOLTAGE_CHANNEL(7),\n};\n\nstatic const struct iio_chan_spec adc122s021_channels[] = {\n\tADC128_VOLTAGE_CHANNEL(0),\n\tADC128_VOLTAGE_CHANNEL(1),\n};\n\nstatic const struct iio_chan_spec adc124s021_channels[] = {\n\tADC128_VOLTAGE_CHANNEL(0),\n\tADC128_VOLTAGE_CHANNEL(1),\n\tADC128_VOLTAGE_CHANNEL(2),\n\tADC128_VOLTAGE_CHANNEL(3),\n};\n\nstatic const struct adc128_configuration adc128_config[] = {\n\t{ adc128s052_channels, ARRAY_SIZE(adc128s052_channels) },\n\t{ adc122s021_channels, ARRAY_SIZE(adc122s021_channels) },\n\t{ adc124s021_channels, ARRAY_SIZE(adc124s021_channels) },\n};\n\nstatic const struct iio_info adc128_info = {\n\t.read_raw = adc128_read_raw,\n};\n\nstatic void adc128_disable_regulator(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int adc128_probe(struct spi_device *spi)\n{\n\tconst struct adc128_configuration *config;\n\tstruct iio_dev *indio_dev;\n\tstruct adc128 *adc;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tadc = iio_priv(indio_dev);\n\tadc->spi = spi;\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &adc128_info;\n\n\tconfig = spi_get_device_match_data(spi);\n\n\tindio_dev->channels = config->channels;\n\tindio_dev->num_channels = config->num_channels;\n\n\tadc->reg = devm_regulator_get(&spi->dev, \"vref\");\n\tif (IS_ERR(adc->reg))\n\t\treturn PTR_ERR(adc->reg);\n\n\tret = regulator_enable(adc->reg);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = devm_add_action_or_reset(&spi->dev, adc128_disable_regulator,\n\t\t\t\t       adc->reg);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&adc->lock);\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id adc128_of_match[] = {\n\t{ .compatible = \"ti,adc128s052\", .data = &adc128_config[0] },\n\t{ .compatible = \"ti,adc122s021\", .data = &adc128_config[1] },\n\t{ .compatible = \"ti,adc122s051\", .data = &adc128_config[1] },\n\t{ .compatible = \"ti,adc122s101\", .data = &adc128_config[1] },\n\t{ .compatible = \"ti,adc124s021\", .data = &adc128_config[2] },\n\t{ .compatible = \"ti,adc124s051\", .data = &adc128_config[2] },\n\t{ .compatible = \"ti,adc124s101\", .data = &adc128_config[2] },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, adc128_of_match);\n\nstatic const struct spi_device_id adc128_id[] = {\n\t{ \"adc128s052\", (kernel_ulong_t)&adc128_config[0] },\n\t{ \"adc122s021\",\t(kernel_ulong_t)&adc128_config[1] },\n\t{ \"adc122s051\",\t(kernel_ulong_t)&adc128_config[1] },\n\t{ \"adc122s101\",\t(kernel_ulong_t)&adc128_config[1] },\n\t{ \"adc124s021\", (kernel_ulong_t)&adc128_config[2] },\n\t{ \"adc124s051\", (kernel_ulong_t)&adc128_config[2] },\n\t{ \"adc124s101\", (kernel_ulong_t)&adc128_config[2] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, adc128_id);\n\nstatic const struct acpi_device_id adc128_acpi_match[] = {\n\t{ \"AANT1280\", (kernel_ulong_t)&adc128_config[2] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, adc128_acpi_match);\n\nstatic struct spi_driver adc128_driver = {\n\t.driver = {\n\t\t.name = \"adc128s052\",\n\t\t.of_match_table = adc128_of_match,\n\t\t.acpi_match_table = adc128_acpi_match,\n\t},\n\t.probe = adc128_probe,\n\t.id_table = adc128_id,\n};\nmodule_spi_driver(adc128_driver);\n\nMODULE_AUTHOR(\"Angelo Compagnucci <angelo.compagnucci@gmail.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments ADC128S052\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}