{
  "module_name": "nau7802.c",
  "hash_id": "ceeae88c00e54d48b68186a51b364724cad40b1a8f982185ecda31c1d2bfafe3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/adc/nau7802.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/wait.h>\n#include <linux/log2.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define NAU7802_REG_PUCTRL\t0x00\n#define NAU7802_PUCTRL_RR(x)\t\t(x << 0)\n#define NAU7802_PUCTRL_RR_BIT\t\tNAU7802_PUCTRL_RR(1)\n#define NAU7802_PUCTRL_PUD(x)\t\t(x << 1)\n#define NAU7802_PUCTRL_PUD_BIT\t\tNAU7802_PUCTRL_PUD(1)\n#define NAU7802_PUCTRL_PUA(x)\t\t(x << 2)\n#define NAU7802_PUCTRL_PUA_BIT\t\tNAU7802_PUCTRL_PUA(1)\n#define NAU7802_PUCTRL_PUR(x)\t\t(x << 3)\n#define NAU7802_PUCTRL_PUR_BIT\t\tNAU7802_PUCTRL_PUR(1)\n#define NAU7802_PUCTRL_CS(x)\t\t(x << 4)\n#define NAU7802_PUCTRL_CS_BIT\t\tNAU7802_PUCTRL_CS(1)\n#define NAU7802_PUCTRL_CR(x)\t\t(x << 5)\n#define NAU7802_PUCTRL_CR_BIT\t\tNAU7802_PUCTRL_CR(1)\n#define NAU7802_PUCTRL_AVDDS(x)\t\t(x << 7)\n#define NAU7802_PUCTRL_AVDDS_BIT\tNAU7802_PUCTRL_AVDDS(1)\n#define NAU7802_REG_CTRL1\t0x01\n#define NAU7802_CTRL1_VLDO(x)\t\t(x << 3)\n#define NAU7802_CTRL1_GAINS(x)\t\t(x)\n#define NAU7802_CTRL1_GAINS_BITS\t0x07\n#define NAU7802_REG_CTRL2\t0x02\n#define NAU7802_CTRL2_CHS(x)\t\t(x << 7)\n#define NAU7802_CTRL2_CRS(x)\t\t(x << 4)\n#define NAU7802_SAMP_FREQ_320\t0x07\n#define NAU7802_CTRL2_CHS_BIT\t\tNAU7802_CTRL2_CHS(1)\n#define NAU7802_REG_ADC_B2\t0x12\n#define NAU7802_REG_ADC_B1\t0x13\n#define NAU7802_REG_ADC_B0\t0x14\n#define NAU7802_REG_ADC_CTRL\t0x15\n\n#define NAU7802_MIN_CONVERSIONS 6\n\nstruct nau7802_state {\n\tstruct i2c_client\t*client;\n\ts32\t\t\tlast_value;\n\tstruct mutex\t\tlock;\n\tstruct mutex\t\tdata_lock;\n\tu32\t\t\tvref_mv;\n\tu32\t\t\tconversion_count;\n\tu32\t\t\tmin_conversions;\n\tu8\t\t\tsample_rate;\n\tu32\t\t\tscale_avail[8];\n\tstruct completion\tvalue_ok;\n};\n\n#define NAU7802_CHANNEL(chan) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = (chan),\t\t\t\t\t\\\n\t.scan_index = (chan),\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ)\t\\\n}\n\nstatic const struct iio_chan_spec nau7802_chan_array[] = {\n\tNAU7802_CHANNEL(0),\n\tNAU7802_CHANNEL(1),\n};\n\nstatic const u16 nau7802_sample_freq_avail[] = {10, 20, 40, 80,\n\t\t\t\t\t\t10, 10, 10, 320};\n\nstatic ssize_t nau7802_show_scales(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct nau7802_state *st = iio_priv(dev_to_iio_dev(dev));\n\tint i, len = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(st->scale_avail); i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"0.%09d \",\n\t\t\t\t st->scale_avail[i]);\n\n\tbuf[len-1] = '\\n';\n\n\treturn len;\n}\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\"10 40 80 320\");\n\nstatic IIO_DEVICE_ATTR(in_voltage_scale_available, S_IRUGO, nau7802_show_scales,\n\t\t       NULL, 0);\n\nstatic struct attribute *nau7802_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_in_voltage_scale_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group nau7802_attribute_group = {\n\t.attrs = nau7802_attributes,\n};\n\nstatic int nau7802_set_gain(struct nau7802_state *st, int gain)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tst->conversion_count = 0;\n\n\tret = i2c_smbus_read_byte_data(st->client, NAU7802_REG_CTRL1);\n\tif (ret < 0)\n\t\tgoto nau7802_sysfs_set_gain_out;\n\tret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_CTRL1,\n\t\t\t\t\t(ret & (~NAU7802_CTRL1_GAINS_BITS)) |\n\t\t\t\t\tgain);\n\nnau7802_sysfs_set_gain_out:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int nau7802_read_conversion(struct nau7802_state *st)\n{\n\tint data;\n\n\tmutex_lock(&st->data_lock);\n\tdata = i2c_smbus_read_byte_data(st->client, NAU7802_REG_ADC_B2);\n\tif (data < 0)\n\t\tgoto nau7802_read_conversion_out;\n\tst->last_value = data << 16;\n\n\tdata = i2c_smbus_read_byte_data(st->client, NAU7802_REG_ADC_B1);\n\tif (data < 0)\n\t\tgoto nau7802_read_conversion_out;\n\tst->last_value |= data << 8;\n\n\tdata = i2c_smbus_read_byte_data(st->client, NAU7802_REG_ADC_B0);\n\tif (data < 0)\n\t\tgoto nau7802_read_conversion_out;\n\tst->last_value |= data;\n\n\tst->last_value = sign_extend32(st->last_value, 23);\n\nnau7802_read_conversion_out:\n\tmutex_unlock(&st->data_lock);\n\n\treturn data;\n}\n\n \nstatic int nau7802_sync(struct nau7802_state *st)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(st->client, NAU7802_REG_PUCTRL);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_PUCTRL,\n\t\t\t\tret | NAU7802_PUCTRL_CS_BIT);\n\n\treturn ret;\n}\n\nstatic irqreturn_t nau7802_eoc_trigger(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct nau7802_state *st = iio_priv(indio_dev);\n\tint status;\n\n\tstatus = i2c_smbus_read_byte_data(st->client, NAU7802_REG_PUCTRL);\n\tif (status < 0)\n\t\treturn IRQ_HANDLED;\n\n\tif (!(status & NAU7802_PUCTRL_CR_BIT))\n\t\treturn IRQ_NONE;\n\n\tif (nau7802_read_conversion(st) < 0)\n\t\treturn IRQ_HANDLED;\n\n\t \n\tif (st->conversion_count < NAU7802_MIN_CONVERSIONS)\n\t\tst->conversion_count++;\n\tif (st->conversion_count >= NAU7802_MIN_CONVERSIONS)\n\t\tcomplete(&st->value_ok);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int nau7802_read_irq(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint *val)\n{\n\tstruct nau7802_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\treinit_completion(&st->value_ok);\n\tenable_irq(st->client->irq);\n\n\tnau7802_sync(st);\n\n\t \n\tret = nau7802_read_conversion(st);\n\tif (ret < 0)\n\t\tgoto read_chan_info_failure;\n\n\t \n\tret = wait_for_completion_interruptible_timeout(&st->value_ok,\n\t\t\tmsecs_to_jiffies(1000));\n\tif (ret == 0)\n\t\tret = -ETIMEDOUT;\n\n\tif (ret < 0)\n\t\tgoto read_chan_info_failure;\n\n\tdisable_irq(st->client->irq);\n\n\t*val = st->last_value;\n\n\treturn IIO_VAL_INT;\n\nread_chan_info_failure:\n\tdisable_irq(st->client->irq);\n\n\treturn ret;\n}\n\nstatic int nau7802_read_poll(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint *val)\n{\n\tstruct nau7802_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tnau7802_sync(st);\n\n\t \n\tret = nau7802_read_conversion(st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdo {\n\t\tret = i2c_smbus_read_byte_data(st->client, NAU7802_REG_PUCTRL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\twhile (!(ret & NAU7802_PUCTRL_CR_BIT)) {\n\t\t\tif (st->sample_rate != NAU7802_SAMP_FREQ_320)\n\t\t\t\tmsleep(20);\n\t\t\telse\n\t\t\t\tmdelay(4);\n\t\t\tret = i2c_smbus_read_byte_data(st->client,\n\t\t\t\t\t\t\tNAU7802_REG_PUCTRL);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = nau7802_read_conversion(st);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (st->conversion_count < NAU7802_MIN_CONVERSIONS)\n\t\t\tst->conversion_count++;\n\t} while (st->conversion_count < NAU7802_MIN_CONVERSIONS);\n\n\t*val = st->last_value;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int nau7802_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct nau7802_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&st->lock);\n\t\t \n\t\tret = i2c_smbus_read_byte_data(st->client, NAU7802_REG_CTRL2);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (((ret & NAU7802_CTRL2_CHS_BIT) && !chan->channel) ||\n\t\t\t\t(!(ret & NAU7802_CTRL2_CHS_BIT) &&\n\t\t\t\t chan->channel)) {\n\t\t\tst->conversion_count = 0;\n\t\t\tret = i2c_smbus_write_byte_data(st->client,\n\t\t\t\t\tNAU7802_REG_CTRL2,\n\t\t\t\t\tNAU7802_CTRL2_CHS(chan->channel) |\n\t\t\t\t\tNAU7802_CTRL2_CRS(st->sample_rate));\n\n\t\t\tif (ret < 0) {\n\t\t\t\tmutex_unlock(&st->lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif (st->client->irq)\n\t\t\tret = nau7802_read_irq(indio_dev, chan, val);\n\t\telse\n\t\t\tret = nau7802_read_poll(indio_dev, chan, val);\n\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = i2c_smbus_read_byte_data(st->client, NAU7802_REG_CTRL1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\t*val = st->vref_mv;\n\t\t*val2 = 23 + (ret & NAU7802_CTRL1_GAINS_BITS);\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val =  nau7802_sample_freq_avail[st->sample_rate];\n\t\t*val2 = 0;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int nau7802_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct nau7802_state *st = iio_priv(indio_dev);\n\tint i, ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tfor (i = 0; i < ARRAY_SIZE(st->scale_avail); i++)\n\t\t\tif (val2 == st->scale_avail[i])\n\t\t\t\treturn nau7802_set_gain(st, i);\n\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tfor (i = 0; i < ARRAY_SIZE(nau7802_sample_freq_avail); i++)\n\t\t\tif (val == nau7802_sample_freq_avail[i]) {\n\t\t\t\tmutex_lock(&st->lock);\n\t\t\t\tst->sample_rate = i;\n\t\t\t\tst->conversion_count = 0;\n\t\t\t\tret = i2c_smbus_write_byte_data(st->client,\n\t\t\t\t\tNAU7802_REG_CTRL2,\n\t\t\t\t\tNAU7802_CTRL2_CRS(st->sample_rate));\n\t\t\t\tmutex_unlock(&st->lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int nau7802_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t\t     long mask)\n{\n\treturn IIO_VAL_INT_PLUS_NANO;\n}\n\nstatic const struct iio_info nau7802_info = {\n\t.read_raw = &nau7802_read_raw,\n\t.write_raw = &nau7802_write_raw,\n\t.write_raw_get_fmt = nau7802_write_raw_get_fmt,\n\t.attrs = &nau7802_attribute_group,\n};\n\nstatic int nau7802_probe(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct nau7802_state *st;\n\tint i, ret;\n\tu8 data;\n\tu32 tmp = 0;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*st));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tindio_dev->name = dev_name(&client->dev);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &nau7802_info;\n\n\tst->client = client;\n\n\t \n\tret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_PUCTRL,\n\t\t\t\t  NAU7802_PUCTRL_RR_BIT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_PUCTRL,\n\t\t\t\t  NAU7802_PUCTRL_PUD_BIT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tudelay(210);\n\tret = i2c_smbus_read_byte_data(st->client, NAU7802_REG_PUCTRL);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!(ret & NAU7802_PUCTRL_PUR_BIT))\n\t\treturn ret;\n\n\tdevice_property_read_u32(&client->dev, \"nuvoton,vldo\", &tmp);\n\tst->vref_mv = tmp;\n\n\tdata = NAU7802_PUCTRL_PUD_BIT | NAU7802_PUCTRL_PUA_BIT |\n\t\tNAU7802_PUCTRL_CS_BIT;\n\tif (tmp >= 2400)\n\t\tdata |= NAU7802_PUCTRL_AVDDS_BIT;\n\n\tret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_PUCTRL, data);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_ADC_CTRL, 0x30);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (tmp >= 2400) {\n\t\tdata = NAU7802_CTRL1_VLDO((4500 - tmp) / 300);\n\t\tret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_CTRL1,\n\t\t\t\t\t\tdata);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(st->scale_avail); i++)\n\t\tst->scale_avail[i] = (((u64)st->vref_mv) * 1000000000ULL)\n\t\t\t\t\t   >> (23 + i);\n\n\tinit_completion(&st->value_ok);\n\n\t \n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tnau7802_eoc_trigger,\n\t\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT |\n\t\t\t\t\t\tIRQF_NO_AUTOEN,\n\t\t\t\t\t\tclient->dev.driver->name,\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret) {\n\t\t\t \n\t\t\tdev_info(&client->dev,\n\t\t\t\t\"Failed to allocate IRQ, using polling mode\\n\");\n\t\t\tclient->irq = 0;\n\t\t}\n\t}\n\n\tif (!client->irq) {\n\t\t \n\t\tst->sample_rate = NAU7802_SAMP_FREQ_320;\n\t\tret = i2c_smbus_write_byte_data(st->client, NAU7802_REG_CTRL2,\n\t\t\t\t\t  NAU7802_CTRL2_CRS(st->sample_rate));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tindio_dev->num_channels = ARRAY_SIZE(nau7802_chan_array);\n\tindio_dev->channels = nau7802_chan_array;\n\n\tmutex_init(&st->lock);\n\tmutex_init(&st->data_lock);\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id nau7802_i2c_id[] = {\n\t{ \"nau7802\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, nau7802_i2c_id);\n\nstatic const struct of_device_id nau7802_dt_ids[] = {\n\t{ .compatible = \"nuvoton,nau7802\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, nau7802_dt_ids);\n\nstatic struct i2c_driver nau7802_driver = {\n\t.probe = nau7802_probe,\n\t.id_table = nau7802_i2c_id,\n\t.driver = {\n\t\t   .name = \"nau7802\",\n\t\t   .of_match_table = nau7802_dt_ids,\n\t},\n};\n\nmodule_i2c_driver(nau7802_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Nuvoton NAU7802 ADC Driver\");\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_AUTHOR(\"Alexandre Belloni <alexandre.belloni@free-electrons.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}