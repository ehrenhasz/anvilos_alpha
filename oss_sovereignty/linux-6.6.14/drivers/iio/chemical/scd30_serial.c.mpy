{
  "module_name": "scd30_serial.c",
  "hash_id": "1327f323904ce00f0a41ab3c9d451d7f41852996fbbb76fa78018b26b3f53efa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/scd30_serial.c",
  "human_readable_source": "\n \n#include <linux/crc16.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/iio/iio.h>\n#include <linux/jiffies.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/serdev.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <asm/unaligned.h>\n\n#include \"scd30.h\"\n\n#define SCD30_SERDEV_ADDR 0x61\n#define SCD30_SERDEV_WRITE 0x06\n#define SCD30_SERDEV_READ 0x03\n#define SCD30_SERDEV_MAX_BUF_SIZE 17\n#define SCD30_SERDEV_RX_HEADER_SIZE 3\n#define SCD30_SERDEV_CRC_SIZE 2\n#define SCD30_SERDEV_TIMEOUT msecs_to_jiffies(200)\n\nstruct scd30_serdev_priv {\n\tstruct completion meas_ready;\n\tchar *buf;\n\tint num_expected;\n\tint num;\n};\n\nstatic u16 scd30_serdev_cmd_lookup_tbl[] = {\n\t[CMD_START_MEAS] = 0x0036,\n\t[CMD_STOP_MEAS] = 0x0037,\n\t[CMD_MEAS_INTERVAL] = 0x0025,\n\t[CMD_MEAS_READY] = 0x0027,\n\t[CMD_READ_MEAS] = 0x0028,\n\t[CMD_ASC] = 0x003a,\n\t[CMD_FRC] = 0x0039,\n\t[CMD_TEMP_OFFSET] = 0x003b,\n\t[CMD_FW_VERSION] = 0x0020,\n\t[CMD_RESET] = 0x0034,\n};\n\nstatic u16 scd30_serdev_calc_crc(const char *buf, int size)\n{\n\treturn crc16(0xffff, buf, size);\n}\n\nstatic int scd30_serdev_xfer(struct scd30_state *state, char *txbuf, int txsize,\n\t\t\t     char *rxbuf, int rxsize)\n{\n\tstruct serdev_device *serdev = to_serdev_device(state->dev);\n\tstruct scd30_serdev_priv *priv = state->priv;\n\tint ret;\n\n\tpriv->buf = rxbuf;\n\tpriv->num_expected = rxsize;\n\tpriv->num = 0;\n\n\tret = serdev_device_write(serdev, txbuf, txsize, SCD30_SERDEV_TIMEOUT);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != txsize)\n\t\treturn -EIO;\n\n\tret = wait_for_completion_interruptible_timeout(&priv->meas_ready, SCD30_SERDEV_TIMEOUT);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int scd30_serdev_command(struct scd30_state *state, enum scd30_cmd cmd, u16 arg,\n\t\t\t\tvoid *response, int size)\n{\n\t \n\tchar txbuf[SCD30_SERDEV_MAX_BUF_SIZE] = { SCD30_SERDEV_ADDR },\n\t     rxbuf[SCD30_SERDEV_MAX_BUF_SIZE];\n\tint ret, rxsize, txsize = 2;\n\tchar *rsp = response;\n\tu16 crc;\n\n\tput_unaligned_be16(scd30_serdev_cmd_lookup_tbl[cmd], txbuf + txsize);\n\ttxsize += 2;\n\n\tif (rsp) {\n\t\ttxbuf[1] = SCD30_SERDEV_READ;\n\t\tif (cmd == CMD_READ_MEAS)\n\t\t\t \n\t\t\tput_unaligned_be16(size / 2, txbuf + txsize);\n\t\telse\n\t\t\tput_unaligned_be16(0x0001, txbuf + txsize);\n\t\ttxsize += 2;\n\t\tcrc = scd30_serdev_calc_crc(txbuf, txsize);\n\t\tput_unaligned_le16(crc, txbuf + txsize);\n\t\ttxsize += 2;\n\t\trxsize = SCD30_SERDEV_RX_HEADER_SIZE + size + SCD30_SERDEV_CRC_SIZE;\n\t} else {\n\t\tif ((cmd == CMD_STOP_MEAS) || (cmd == CMD_RESET))\n\t\t\targ = 0x0001;\n\n\t\ttxbuf[1] = SCD30_SERDEV_WRITE;\n\t\tput_unaligned_be16(arg, txbuf + txsize);\n\t\ttxsize += 2;\n\t\tcrc = scd30_serdev_calc_crc(txbuf, txsize);\n\t\tput_unaligned_le16(crc, txbuf + txsize);\n\t\ttxsize += 2;\n\t\trxsize = txsize;\n\t}\n\n\tret = scd30_serdev_xfer(state, txbuf, txsize, rxbuf, rxsize);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (txbuf[1]) {\n\tcase SCD30_SERDEV_WRITE:\n\t\tif (memcmp(txbuf, rxbuf, txsize)) {\n\t\t\tdev_err(state->dev, \"wrong message received\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\tcase SCD30_SERDEV_READ:\n\t\tif (rxbuf[2] != (rxsize - SCD30_SERDEV_RX_HEADER_SIZE - SCD30_SERDEV_CRC_SIZE)) {\n\t\t\tdev_err(state->dev, \"received data size does not match header\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\trxsize -= SCD30_SERDEV_CRC_SIZE;\n\t\tcrc = get_unaligned_le16(rxbuf + rxsize);\n\t\tif (crc != scd30_serdev_calc_crc(rxbuf, rxsize)) {\n\t\t\tdev_err(state->dev, \"data integrity check failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\trxsize -= SCD30_SERDEV_RX_HEADER_SIZE;\n\t\tmemcpy(rsp, rxbuf + SCD30_SERDEV_RX_HEADER_SIZE, rxsize);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(state->dev, \"received unknown op code\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int scd30_serdev_receive_buf(struct serdev_device *serdev,\n\t\t\t\t    const unsigned char *buf, size_t size)\n{\n\tstruct iio_dev *indio_dev = serdev_device_get_drvdata(serdev);\n\tstruct scd30_serdev_priv *priv;\n\tstruct scd30_state *state;\n\tint num;\n\n\tif (!indio_dev)\n\t\treturn 0;\n\n\tstate = iio_priv(indio_dev);\n\tpriv = state->priv;\n\n\t \n\tif (!priv->buf)\n\t\treturn 0;\n\n\tif (priv->num + size >= priv->num_expected)\n\t\tnum = priv->num_expected - priv->num;\n\telse\n\t\tnum = size;\n\n\tmemcpy(priv->buf + priv->num, buf, num);\n\tpriv->num += num;\n\n\tif (priv->num == priv->num_expected) {\n\t\tpriv->buf = NULL;\n\t\tcomplete(&priv->meas_ready);\n\t}\n\n\treturn num;\n}\n\nstatic const struct serdev_device_ops scd30_serdev_ops = {\n\t.receive_buf = scd30_serdev_receive_buf,\n\t.write_wakeup = serdev_device_write_wakeup,\n};\n\nstatic int scd30_serdev_probe(struct serdev_device *serdev)\n{\n\tstruct device *dev = &serdev->dev;\n\tstruct scd30_serdev_priv *priv;\n\tint irq, ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&priv->meas_ready);\n\tserdev_device_set_client_ops(serdev, &scd30_serdev_ops);\n\n\tret = devm_serdev_device_open(dev, serdev);\n\tif (ret)\n\t\treturn ret;\n\n\tserdev_device_set_baudrate(serdev, 19200);\n\tserdev_device_set_flow_control(serdev, false);\n\n\tret = serdev_device_set_parity(serdev, SERDEV_PARITY_NONE);\n\tif (ret)\n\t\treturn ret;\n\n\tirq = fwnode_irq_get(dev_fwnode(dev), 0);\n\n\treturn scd30_probe(dev, irq, KBUILD_MODNAME, priv, scd30_serdev_command);\n}\n\nstatic const struct of_device_id scd30_serdev_of_match[] = {\n\t{ .compatible = \"sensirion,scd30\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, scd30_serdev_of_match);\n\nstatic struct serdev_device_driver scd30_serdev_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = scd30_serdev_of_match,\n\t\t.pm = pm_sleep_ptr(&scd30_pm_ops),\n\t},\n\t.probe = scd30_serdev_probe,\n};\nmodule_serdev_device_driver(scd30_serdev_driver);\n\nMODULE_AUTHOR(\"Tomasz Duszynski <tomasz.duszynski@octakon.com>\");\nMODULE_DESCRIPTION(\"Sensirion SCD30 carbon dioxide sensor serial driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_SCD30);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}