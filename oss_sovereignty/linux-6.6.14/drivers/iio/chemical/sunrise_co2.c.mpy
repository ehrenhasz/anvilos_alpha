{
  "module_name": "sunrise_co2.c",
  "hash_id": "5eee3fdf30f4969cd71cc20dff1facaf0d5e80a5a463c97eb42a9cf90ef4c603",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/sunrise_co2.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/time64.h>\n\n#include <linux/iio/iio.h>\n\n#define DRIVER_NAME \"sunrise_co2\"\n\n#define SUNRISE_ERROR_STATUS_REG\t\t0x00\n#define SUNRISE_CO2_FILTERED_COMP_REG\t\t0x06\n#define SUNRISE_CHIP_TEMPERATURE_REG\t\t0x08\n#define SUNRISE_CALIBRATION_STATUS_REG\t\t0x81\n#define SUNRISE_CALIBRATION_COMMAND_REG\t\t0x82\n#define SUNRISE_CALIBRATION_FACTORY_CMD\t\t0x7c02\n#define SUNRISE_CALIBRATION_BACKGROUND_CMD\t0x7c06\n \n#define SUNRISE_CALIBRATION_TIMEOUT_US\t\t(30 * USEC_PER_SEC)\n\nstruct sunrise_dev {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\t \n\tstruct mutex lock;\n\tbool ignore_nak;\n};\n\n \n\nstatic int sunrise_regmap_read(void *context, const void *reg_buf,\n\t\t\t       size_t reg_size, void *val_buf, size_t val_size)\n{\n\tstruct i2c_client *client = context;\n\tstruct sunrise_dev *sunrise = i2c_get_clientdata(client);\n\tunion i2c_smbus_data data;\n\tint ret;\n\n\tif (reg_size != 1 || !val_size)\n\t\treturn -EINVAL;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.block[0] = val_size;\n\n\t \n\t__i2c_smbus_xfer(client->adapter, client->addr,\n\t\t\t sunrise->ignore_nak ? I2C_M_IGNORE_NAK : 0,\n\t\t\t I2C_SMBUS_WRITE, 0, I2C_SMBUS_BYTE_DATA, &data);\n\n\tusleep_range(500, 1500);\n\n\tret = __i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t       I2C_SMBUS_READ, ((u8 *)reg_buf)[0],\n\t\t\t       I2C_SMBUS_I2C_BLOCK_DATA, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemcpy(val_buf, &data.block[1], data.block[0]);\n\n\treturn 0;\n}\n\nstatic int sunrise_regmap_write(void *context, const void *val_buf, size_t count)\n{\n\tstruct i2c_client *client = context;\n\tstruct sunrise_dev *sunrise = i2c_get_clientdata(client);\n\tunion i2c_smbus_data data;\n\n\t \n\tif (!count)\n\t\treturn -EINVAL;\n\tcount--;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.block[0] = count;\n\tmemcpy(&data.block[1], (u8 *)val_buf + 1, count);\n\n\t__i2c_smbus_xfer(client->adapter, client->addr,\n\t\t\t sunrise->ignore_nak ? I2C_M_IGNORE_NAK : 0,\n\t\t\t I2C_SMBUS_WRITE, 0, I2C_SMBUS_BYTE_DATA, &data);\n\n\tusleep_range(500, 1500);\n\n\treturn __i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t\tI2C_SMBUS_WRITE, ((u8 *)val_buf)[0],\n\t\t\t\tI2C_SMBUS_I2C_BLOCK_DATA, &data);\n}\n\n \nstatic int sunrise_read_byte(struct sunrise_dev *sunrise, u8 reg)\n{\n\tconst struct i2c_client *client = sunrise->client;\n\tconst struct device *dev = &client->dev;\n\tunsigned int val;\n\tint ret;\n\n\ti2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tret = regmap_read(sunrise->regmap, reg, &val);\n\ti2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tif (ret) {\n\t\tdev_err(dev, \"Read byte failed: reg 0x%02x (%d)\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\treturn val;\n}\n\nstatic int sunrise_read_word(struct sunrise_dev *sunrise, u8 reg, u16 *val)\n{\n\tconst struct i2c_client *client = sunrise->client;\n\tconst struct device *dev = &client->dev;\n\t__be16 be_val;\n\tint ret;\n\n\ti2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tret = regmap_bulk_read(sunrise->regmap, reg, &be_val, sizeof(be_val));\n\ti2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tif (ret) {\n\t\tdev_err(dev, \"Read word failed: reg 0x%02x (%d)\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\t*val = be16_to_cpu(be_val);\n\n\treturn 0;\n}\n\nstatic int sunrise_write_byte(struct sunrise_dev *sunrise, u8 reg, u8 val)\n{\n\tconst struct i2c_client *client = sunrise->client;\n\tconst struct device *dev = &client->dev;\n\tint ret;\n\n\ti2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tret = regmap_write(sunrise->regmap, reg, val);\n\ti2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tif (ret)\n\t\tdev_err(dev, \"Write byte failed: reg 0x%02x (%d)\\n\", reg, ret);\n\n\treturn ret;\n}\n\nstatic int sunrise_write_word(struct sunrise_dev *sunrise, u8 reg, u16 data)\n{\n\tconst struct i2c_client *client = sunrise->client;\n\tconst struct device *dev = &client->dev;\n\t__be16 be_data = cpu_to_be16(data);\n\tint ret;\n\n\ti2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tret = regmap_bulk_write(sunrise->regmap, reg, &be_data, sizeof(be_data));\n\ti2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tif (ret)\n\t\tdev_err(dev, \"Write word failed: reg 0x%02x (%d)\\n\", reg, ret);\n\n\treturn ret;\n}\n\n \n\nenum {\n\tSUNRISE_CALIBRATION_FACTORY,\n\tSUNRISE_CALIBRATION_BACKGROUND,\n};\n\nstatic const struct sunrise_calib_data {\n\tu16 cmd;\n\tu8 bit;\n\tconst char * const name;\n} calib_data[] = {\n\t[SUNRISE_CALIBRATION_FACTORY] = {\n\t\tSUNRISE_CALIBRATION_FACTORY_CMD,\n\t\tBIT(2),\n\t\t\"factory_calibration\",\n\t},\n\t[SUNRISE_CALIBRATION_BACKGROUND] = {\n\t\tSUNRISE_CALIBRATION_BACKGROUND_CMD,\n\t\tBIT(5),\n\t\t\"background_calibration\",\n\t},\n};\n\nstatic int sunrise_calibrate(struct sunrise_dev *sunrise,\n\t\t\t     const struct sunrise_calib_data *data)\n{\n\tunsigned int status;\n\tint ret;\n\n\t \n\tret = sunrise_write_byte(sunrise, SUNRISE_CALIBRATION_STATUS_REG, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = sunrise_write_word(sunrise, SUNRISE_CALIBRATION_COMMAND_REG, data->cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(&sunrise->client->dev, \"%s in progress\\n\", data->name);\n\n\t \n\treturn read_poll_timeout(sunrise_read_byte, status, status & data->bit,\n\t\t\t\t 200000, SUNRISE_CALIBRATION_TIMEOUT_US, false,\n\t\t\t\t sunrise, SUNRISE_CALIBRATION_STATUS_REG);\n}\n\nstatic ssize_t sunrise_cal_factory_write(struct iio_dev *iiodev,\n\t\t\t\t\t uintptr_t private,\n\t\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t\t const char *buf, size_t len)\n{\n\tstruct sunrise_dev *sunrise = iio_priv(iiodev);\n\tbool enable;\n\tint ret;\n\n\tret = kstrtobool(buf, &enable);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!enable)\n\t\treturn len;\n\n\tmutex_lock(&sunrise->lock);\n\tret = sunrise_calibrate(sunrise, &calib_data[SUNRISE_CALIBRATION_FACTORY]);\n\tmutex_unlock(&sunrise->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t sunrise_cal_background_write(struct iio_dev *iiodev,\n\t\t\t\t\t    uintptr_t private,\n\t\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t\t    const char *buf, size_t len)\n{\n\tstruct sunrise_dev *sunrise = iio_priv(iiodev);\n\tbool enable;\n\tint ret;\n\n\tret = kstrtobool(buf, &enable);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!enable)\n\t\treturn len;\n\n\tmutex_lock(&sunrise->lock);\n\tret = sunrise_calibrate(sunrise, &calib_data[SUNRISE_CALIBRATION_BACKGROUND]);\n\tmutex_unlock(&sunrise->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\n  \nenum {\n\tSUNRISE_ERROR_FATAL,\n\tSUNRISE_ERROR_I2C,\n\tSUNRISE_ERROR_ALGORITHM,\n\tSUNRISE_ERROR_CALIBRATION,\n\tSUNRISE_ERROR_SELF_DIAGNOSTIC,\n\tSUNRISE_ERROR_OUT_OF_RANGE,\n\tSUNRISE_ERROR_MEMORY,\n\tSUNRISE_ERROR_NO_MEASUREMENT,\n\tSUNRISE_ERROR_LOW_VOLTAGE,\n\tSUNRISE_ERROR_MEASUREMENT_TIMEOUT,\n};\n\nstatic const char * const sunrise_error_statuses[] = {\n\t[SUNRISE_ERROR_FATAL] = \"error_fatal\",\n\t[SUNRISE_ERROR_I2C] = \"error_i2c\",\n\t[SUNRISE_ERROR_ALGORITHM] = \"error_algorithm\",\n\t[SUNRISE_ERROR_CALIBRATION] = \"error_calibration\",\n\t[SUNRISE_ERROR_SELF_DIAGNOSTIC] = \"error_self_diagnostic\",\n\t[SUNRISE_ERROR_OUT_OF_RANGE] = \"error_out_of_range\",\n\t[SUNRISE_ERROR_MEMORY] = \"error_memory\",\n\t[SUNRISE_ERROR_NO_MEASUREMENT] = \"error_no_measurement\",\n\t[SUNRISE_ERROR_LOW_VOLTAGE] = \"error_low_voltage\",\n\t[SUNRISE_ERROR_MEASUREMENT_TIMEOUT] = \"error_measurement_timeout\",\n};\n\nstatic const struct iio_enum sunrise_error_statuses_enum = {\n\t.items = sunrise_error_statuses,\n\t.num_items = ARRAY_SIZE(sunrise_error_statuses),\n};\n\nstatic ssize_t sunrise_error_status_read(struct iio_dev *iiodev,\n\t\t\t\t\t uintptr_t private,\n\t\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t\t char *buf)\n{\n\tstruct sunrise_dev *sunrise = iio_priv(iiodev);\n\tunsigned long errors;\n\tssize_t len = 0;\n\tu16 value;\n\tint ret;\n\tu8 i;\n\n\tmutex_lock(&sunrise->lock);\n\tret = sunrise_read_word(sunrise, SUNRISE_ERROR_STATUS_REG, &value);\n\tif (ret) {\n\t\tmutex_unlock(&sunrise->lock);\n\t\treturn ret;\n\t}\n\n\terrors = value;\n\tfor_each_set_bit(i, &errors, ARRAY_SIZE(sunrise_error_statuses))\n\t\tlen += sysfs_emit_at(buf, len, \"%s \", sunrise_error_statuses[i]);\n\n\tif (len)\n\t\tbuf[len - 1] = '\\n';\n\n\tmutex_unlock(&sunrise->lock);\n\n\treturn len;\n}\n\nstatic const struct iio_chan_spec_ext_info sunrise_concentration_ext_info[] = {\n\t \n\t{\n\t\t.name = \"calibration_factory\",\n\t\t.write = sunrise_cal_factory_write,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\t{\n\t\t.name = \"calibration_background\",\n\t\t.write = sunrise_cal_background_write,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\n\t \n\t{\n\t\t.name = \"error_status\",\n\t\t.read = sunrise_error_status_read,\n\t\t.shared = IIO_SHARED_BY_ALL,\n\t},\n\t{\n\t\t.name = \"error_status_available\",\n\t\t.shared = IIO_SHARED_BY_ALL,\n\t\t.read = iio_enum_available_read,\n\t\t.private = (uintptr_t)&sunrise_error_statuses_enum,\n\t},\n\t{}\n};\n\nstatic const struct iio_chan_spec sunrise_channels[] = {\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_CO2,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.ext_info = sunrise_concentration_ext_info,\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t},\n};\n\nstatic int sunrise_read_raw(struct iio_dev *iio_dev,\n\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct sunrise_dev *sunrise = iio_priv(iio_dev);\n\tu16 value;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_CONCENTRATION:\n\t\t\tmutex_lock(&sunrise->lock);\n\t\t\tret = sunrise_read_word(sunrise, SUNRISE_CO2_FILTERED_COMP_REG,\n\t\t\t\t\t\t&value);\n\t\t\tmutex_unlock(&sunrise->lock);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*val = value;\n\t\t\treturn IIO_VAL_INT;\n\n\t\tcase IIO_TEMP:\n\t\t\tmutex_lock(&sunrise->lock);\n\t\t\tret = sunrise_read_word(sunrise, SUNRISE_CHIP_TEMPERATURE_REG,\n\t\t\t\t\t\t&value);\n\t\t\tmutex_unlock(&sunrise->lock);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*val = value;\n\t\t\treturn IIO_VAL_INT;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_CONCENTRATION:\n\t\t\t \n\t\t\t*val = 1;\n\t\t\t*val2 = 10000;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = 10;\n\t\t\treturn IIO_VAL_INT;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info sunrise_info = {\n\t.read_raw = sunrise_read_raw,\n};\n\nstatic const struct regmap_bus sunrise_regmap_bus = {\n\t.read = sunrise_regmap_read,\n\t.write = sunrise_regmap_write,\n};\n\nstatic const struct regmap_config sunrise_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int sunrise_probe(struct i2c_client *client)\n{\n\tstruct sunrise_dev *sunrise;\n\tstruct iio_dev *iio_dev;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t\t\t      I2C_FUNC_SMBUS_BLOCK_DATA)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Adapter does not support required functionalities\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tiio_dev = devm_iio_device_alloc(&client->dev, sizeof(*sunrise));\n\tif (!iio_dev)\n\t\treturn -ENOMEM;\n\n\tsunrise = iio_priv(iio_dev);\n\tsunrise->client = client;\n\tmutex_init(&sunrise->lock);\n\n\ti2c_set_clientdata(client, sunrise);\n\n\tsunrise->regmap = devm_regmap_init(&client->dev, &sunrise_regmap_bus,\n\t\t\t\t\t   client, &sunrise_regmap_config);\n\tif (IS_ERR(sunrise->regmap)) {\n\t\tdev_err(&client->dev, \"Failed to initialize regmap\\n\");\n\t\treturn PTR_ERR(sunrise->regmap);\n\t}\n\n\t \n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_PROTOCOL_MANGLING))\n\t\tsunrise->ignore_nak = true;\n\n\tiio_dev->info = &sunrise_info;\n\tiio_dev->name = DRIVER_NAME;\n\tiio_dev->channels = sunrise_channels;\n\tiio_dev->num_channels = ARRAY_SIZE(sunrise_channels);\n\tiio_dev->modes = INDIO_DIRECT_MODE;\n\n\treturn devm_iio_device_register(&client->dev, iio_dev);\n}\n\nstatic const struct of_device_id sunrise_of_match[] = {\n\t{ .compatible = \"senseair,sunrise-006-0-0007\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sunrise_of_match);\n\nstatic struct i2c_driver sunrise_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = sunrise_of_match,\n\t},\n\t.probe = sunrise_probe,\n};\nmodule_i2c_driver(sunrise_driver);\n\nMODULE_AUTHOR(\"Jacopo Mondi <jacopo@jmondi.org>\");\nMODULE_DESCRIPTION(\"Senseair Sunrise 006-0-0007 CO2 sensor IIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}