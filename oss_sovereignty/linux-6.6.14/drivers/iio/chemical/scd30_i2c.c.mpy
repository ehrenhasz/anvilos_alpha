{
  "module_name": "scd30_i2c.c",
  "hash_id": "4956969036c4a5cf96239a550d559f1f1341443b19ca5bd9453456d7b2a29304",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/scd30_i2c.c",
  "human_readable_source": "\n \n#include <linux/crc8.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <asm/unaligned.h>\n\n#include \"scd30.h\"\n\n#define SCD30_I2C_MAX_BUF_SIZE 18\n#define SCD30_I2C_CRC8_POLYNOMIAL 0x31\n\nstatic u16 scd30_i2c_cmd_lookup_tbl[] = {\n\t[CMD_START_MEAS] = 0x0010,\n\t[CMD_STOP_MEAS] = 0x0104,\n\t[CMD_MEAS_INTERVAL] = 0x4600,\n\t[CMD_MEAS_READY] = 0x0202,\n\t[CMD_READ_MEAS] = 0x0300,\n\t[CMD_ASC] = 0x5306,\n\t[CMD_FRC] = 0x5204,\n\t[CMD_TEMP_OFFSET] = 0x5403,\n\t[CMD_FW_VERSION] = 0xd100,\n\t[CMD_RESET] = 0xd304,\n};\n\nDECLARE_CRC8_TABLE(scd30_i2c_crc8_tbl);\n\nstatic int scd30_i2c_xfer(struct scd30_state *state, char *txbuf, int txsize,\n\t\t\t  char *rxbuf, int rxsize)\n{\n\tstruct i2c_client *client = to_i2c_client(state->dev);\n\tint ret;\n\n\t \n\tret = i2c_master_send(client, txbuf, txsize);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != txsize)\n\t\treturn -EIO;\n\n\tif (!rxbuf)\n\t\treturn 0;\n\n\tret = i2c_master_recv(client, rxbuf, rxsize);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != rxsize)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int scd30_i2c_command(struct scd30_state *state, enum scd30_cmd cmd, u16 arg,\n\t\t\t     void *response, int size)\n{\n\tchar buf[SCD30_I2C_MAX_BUF_SIZE];\n\tchar *rsp = response;\n\tint i, ret;\n\tchar crc;\n\n\tput_unaligned_be16(scd30_i2c_cmd_lookup_tbl[cmd], buf);\n\ti = 2;\n\n\tif (rsp) {\n\t\t \n\t\tsize += size / 2;\n\t} else {\n\t\tput_unaligned_be16(arg, buf + i);\n\t\tcrc = crc8(scd30_i2c_crc8_tbl, buf + i, 2, CRC8_INIT_VALUE);\n\t\ti += 2;\n\t\tbuf[i] = crc;\n\t\ti += 1;\n\n\t\t \n\t\tif ((cmd == CMD_STOP_MEAS) || (cmd == CMD_RESET))\n\t\t\ti -= 3;\n\t}\n\n\tret = scd30_i2c_xfer(state, buf, i, buf, size);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < size; i += 3) {\n\t\tcrc = crc8(scd30_i2c_crc8_tbl, buf + i, 2, CRC8_INIT_VALUE);\n\t\tif (crc != buf[i + 2]) {\n\t\t\tdev_err(state->dev, \"data integrity check failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t*rsp++ = buf[i];\n\t\t*rsp++ = buf[i + 1];\n\t}\n\n\treturn 0;\n}\n\nstatic int scd30_i2c_probe(struct i2c_client *client)\n{\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -EOPNOTSUPP;\n\n\tcrc8_populate_msb(scd30_i2c_crc8_tbl, SCD30_I2C_CRC8_POLYNOMIAL);\n\n\treturn scd30_probe(&client->dev, client->irq, client->name, NULL, scd30_i2c_command);\n}\n\nstatic const struct of_device_id scd30_i2c_of_match[] = {\n\t{ .compatible = \"sensirion,scd30\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, scd30_i2c_of_match);\n\nstatic struct i2c_driver scd30_i2c_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = scd30_i2c_of_match,\n\t\t.pm = pm_sleep_ptr(&scd30_pm_ops),\n\t},\n\t.probe = scd30_i2c_probe,\n};\nmodule_i2c_driver(scd30_i2c_driver);\n\nMODULE_AUTHOR(\"Tomasz Duszynski <tomasz.duszynski@octakon.com>\");\nMODULE_DESCRIPTION(\"Sensirion SCD30 carbon dioxide sensor i2c driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_SCD30);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}