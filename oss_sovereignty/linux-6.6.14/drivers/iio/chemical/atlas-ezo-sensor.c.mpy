{
  "module_name": "atlas-ezo-sensor.c",
  "hash_id": "c7230b229050af841e4d990a22c87489e5acf1513a38ad9b842a57648347dafe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/atlas-ezo-sensor.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n\n#include <linux/iio/iio.h>\n\n#define ATLAS_EZO_DRV_NAME\t\t\"atlas-ezo-sensor\"\n#define ATLAS_INT_TIME_IN_MS\t\t950\n#define ATLAS_INT_HUM_TIME_IN_MS\t350\n\nenum {\n\tATLAS_CO2_EZO,\n\tATLAS_O2_EZO,\n\tATLAS_HUM_EZO,\n};\n\nstruct atlas_ezo_device {\n\tconst struct iio_chan_spec *channels;\n\tint num_channels;\n\tint delay;\n};\n\nstruct atlas_ezo_data {\n\tstruct i2c_client *client;\n\tconst struct atlas_ezo_device *chip;\n\n\t \n\tstruct mutex lock;\n\n\tu8 buffer[8];\n};\n\n#define ATLAS_CONCENTRATION_CHANNEL(_modifier) \\\n\t{ \\\n\t\t.type = IIO_CONCENTRATION, \\\n\t\t.modified = 1,\\\n\t\t.channel2 = _modifier, \\\n\t\t.info_mask_separate = \\\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE), \\\n\t\t.scan_index = 0, \\\n\t\t.scan_type =  { \\\n\t\t\t.sign = 'u', \\\n\t\t\t.realbits = 32, \\\n\t\t\t.storagebits = 32, \\\n\t\t\t.endianness = IIO_CPU, \\\n\t\t}, \\\n\t}\n\nstatic const struct iio_chan_spec atlas_co2_ezo_channels[] = {\n\tATLAS_CONCENTRATION_CHANNEL(IIO_MOD_CO2),\n};\n\nstatic const struct iio_chan_spec atlas_o2_ezo_channels[] = {\n\tATLAS_CONCENTRATION_CHANNEL(IIO_MOD_O2),\n};\n\nstatic const struct iio_chan_spec atlas_hum_ezo_channels[] = {\n\t{\n\t\t.type = IIO_HUMIDITYRELATIVE,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 0,\n\t\t.scan_type =  {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 32,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n};\n\nstatic struct atlas_ezo_device atlas_ezo_devices[] = {\n\t[ATLAS_CO2_EZO] = {\n\t\t.channels = atlas_co2_ezo_channels,\n\t\t.num_channels = 1,\n\t\t.delay = ATLAS_INT_TIME_IN_MS,\n\t},\n\t[ATLAS_O2_EZO] = {\n\t\t.channels = atlas_o2_ezo_channels,\n\t\t.num_channels = 1,\n\t\t.delay = ATLAS_INT_TIME_IN_MS,\n\t},\n\t[ATLAS_HUM_EZO] = {\n\t\t.channels = atlas_hum_ezo_channels,\n\t\t.num_channels = 1,\n\t\t.delay = ATLAS_INT_HUM_TIME_IN_MS,\n\t},\n};\n\nstatic void atlas_ezo_sanitize(char *buf)\n{\n\tchar *ptr = strchr(buf, '.');\n\n\tif (!ptr)\n\t\treturn;\n\n\tmemmove(ptr, ptr + 1, strlen(ptr));\n}\n\nstatic int atlas_ezo_read_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t  int *val, int *val2, long mask)\n{\n\tstruct atlas_ezo_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\n\tif (chan->type != IIO_CONCENTRATION)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW: {\n\t\tint ret;\n\t\tlong tmp;\n\n\t\tmutex_lock(&data->lock);\n\n\t\ttmp = i2c_smbus_write_byte(client, 'R');\n\n\t\tif (tmp < 0) {\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn tmp;\n\t\t}\n\n\t\tmsleep(data->chip->delay);\n\n\t\ttmp = i2c_master_recv(client, data->buffer, sizeof(data->buffer));\n\n\t\tif (tmp < 0 || data->buffer[0] != 1) {\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\t\tatlas_ezo_sanitize(data->buffer + 2);\n\n\t\tret = kstrtol(data->buffer + 1, 10, &tmp);\n\n\t\t*val = tmp;\n\n\t\tmutex_unlock(&data->lock);\n\n\t\treturn ret ? ret : IIO_VAL_INT;\n\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_HUMIDITYRELATIVE:\n\t\t\t*val = 10;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_CONCENTRATION:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tswitch (chan->channel2) {\n\t\tcase IIO_MOD_CO2:\n\t\t\t*val = 0;\n\t\t\t*val2 = 100;  \n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_MOD_O2:\n\t\t\t*val = 100;\n\t\t\treturn IIO_VAL_INT;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iio_info atlas_info = {\n\t.read_raw = atlas_ezo_read_raw,\n};\n\nstatic const struct i2c_device_id atlas_ezo_id[] = {\n\t{ \"atlas-co2-ezo\", (kernel_ulong_t)&atlas_ezo_devices[ATLAS_CO2_EZO] },\n\t{ \"atlas-o2-ezo\", (kernel_ulong_t)&atlas_ezo_devices[ATLAS_O2_EZO] },\n\t{ \"atlas-hum-ezo\", (kernel_ulong_t)&atlas_ezo_devices[ATLAS_HUM_EZO] },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, atlas_ezo_id);\n\nstatic const struct of_device_id atlas_ezo_dt_ids[] = {\n\t{ .compatible = \"atlas,co2-ezo\", .data = &atlas_ezo_devices[ATLAS_CO2_EZO], },\n\t{ .compatible = \"atlas,o2-ezo\", .data = &atlas_ezo_devices[ATLAS_O2_EZO], },\n\t{ .compatible = \"atlas,hum-ezo\", .data = &atlas_ezo_devices[ATLAS_HUM_EZO], },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, atlas_ezo_dt_ids);\n\nstatic int atlas_ezo_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tconst struct atlas_ezo_device *chip;\n\tstruct atlas_ezo_data *data;\n\tstruct iio_dev *indio_dev;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tif (dev_fwnode(&client->dev))\n\t\tchip = device_get_match_data(&client->dev);\n\telse\n\t\tchip = (const struct atlas_ezo_device *)id->driver_data;\n\tif (!chip)\n\t\treturn -EINVAL;\n\n\tindio_dev->info = &atlas_info;\n\tindio_dev->name = ATLAS_EZO_DRV_NAME;\n\tindio_dev->channels = chip->channels;\n\tindio_dev->num_channels = chip->num_channels;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\tdata->chip = chip;\n\tmutex_init(&data->lock);\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n};\n\nstatic struct i2c_driver atlas_ezo_driver = {\n\t.driver = {\n\t\t.name\t= ATLAS_EZO_DRV_NAME,\n\t\t.of_match_table\t= atlas_ezo_dt_ids,\n\t},\n\t.probe\t\t= atlas_ezo_probe,\n\t.id_table\t= atlas_ezo_id,\n};\nmodule_i2c_driver(atlas_ezo_driver);\n\nMODULE_AUTHOR(\"Matt Ranostay <matt.ranostay@konsulko.com>\");\nMODULE_DESCRIPTION(\"Atlas Scientific EZO sensors\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}