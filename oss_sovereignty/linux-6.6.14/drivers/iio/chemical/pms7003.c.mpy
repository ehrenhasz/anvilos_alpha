{
  "module_name": "pms7003.c",
  "hash_id": "ac30576095885efad888cdaf607d66af968341c3d7a0c774e06cbe7c7e8137ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/pms7003.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/serdev.h>\n\n#define PMS7003_DRIVER_NAME \"pms7003\"\n\n#define PMS7003_MAGIC 0x424d\n \n#define PMS7003_MAX_DATA_LENGTH 28\n#define PMS7003_CHECKSUM_LENGTH 2\n#define PMS7003_PM10_OFFSET 10\n#define PMS7003_PM2P5_OFFSET 8\n#define PMS7003_PM1_OFFSET 6\n\n#define PMS7003_TIMEOUT msecs_to_jiffies(6000)\n#define PMS7003_CMD_LENGTH 7\n#define PMS7003_PM_MAX 1000\n#define PMS7003_PM_MIN 0\n\nenum {\n\tPM1,\n\tPM2P5,\n\tPM10,\n};\n\nenum pms7003_cmd {\n\tCMD_WAKEUP,\n\tCMD_ENTER_PASSIVE_MODE,\n\tCMD_READ_PASSIVE,\n\tCMD_SLEEP,\n};\n\n \nstatic const u8 pms7003_cmd_tbl[][PMS7003_CMD_LENGTH] = {\n\t[CMD_WAKEUP] = { 0x42, 0x4d, 0xe4, 0x00, 0x01, 0x01, 0x74 },\n\t[CMD_ENTER_PASSIVE_MODE] = { 0x42, 0x4d, 0xe1, 0x00, 0x00, 0x01, 0x70 },\n\t[CMD_READ_PASSIVE] = { 0x42, 0x4d, 0xe2, 0x00, 0x00, 0x01, 0x71 },\n\t[CMD_SLEEP] = { 0x42, 0x4d, 0xe4, 0x00, 0x00, 0x01, 0x73 },\n};\n\nstruct pms7003_frame {\n\tu8 data[PMS7003_MAX_DATA_LENGTH];\n\tu16 expected_length;\n\tu16 length;\n};\n\nstruct pms7003_state {\n\tstruct serdev_device *serdev;\n\tstruct pms7003_frame frame;\n\tstruct completion frame_ready;\n\tstruct mutex lock;  \n\t \n\tstruct {\n\t\tu16 data[3];  \n\t\ts64 ts;\n\t} scan;\n};\n\nstatic int pms7003_do_cmd(struct pms7003_state *state, enum pms7003_cmd cmd)\n{\n\tint ret;\n\n\tret = serdev_device_write(state->serdev, pms7003_cmd_tbl[cmd],\n\t\t\t\t  PMS7003_CMD_LENGTH, PMS7003_TIMEOUT);\n\tif (ret < PMS7003_CMD_LENGTH)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\tret = wait_for_completion_interruptible_timeout(&state->frame_ready,\n\t\t\t\t\t\t\tPMS7003_TIMEOUT);\n\tif (!ret)\n\t\tret = -ETIMEDOUT;\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic u16 pms7003_get_pm(const u8 *data)\n{\n\treturn clamp_val(get_unaligned_be16(data),\n\t\t\t PMS7003_PM_MIN, PMS7003_PM_MAX);\n}\n\nstatic irqreturn_t pms7003_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct pms7003_state *state = iio_priv(indio_dev);\n\tstruct pms7003_frame *frame = &state->frame;\n\tint ret;\n\n\tmutex_lock(&state->lock);\n\tret = pms7003_do_cmd(state, CMD_READ_PASSIVE);\n\tif (ret) {\n\t\tmutex_unlock(&state->lock);\n\t\tgoto err;\n\t}\n\n\tstate->scan.data[PM1] =\n\t\tpms7003_get_pm(frame->data + PMS7003_PM1_OFFSET);\n\tstate->scan.data[PM2P5] =\n\t\tpms7003_get_pm(frame->data + PMS7003_PM2P5_OFFSET);\n\tstate->scan.data[PM10] =\n\t\tpms7003_get_pm(frame->data + PMS7003_PM10_OFFSET);\n\tmutex_unlock(&state->lock);\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &state->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pms7003_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct pms7003_state *state = iio_priv(indio_dev);\n\tstruct pms7003_frame *frame = &state->frame;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_MASSCONCENTRATION:\n\t\t\tmutex_lock(&state->lock);\n\t\t\tret = pms7003_do_cmd(state, CMD_READ_PASSIVE);\n\t\t\tif (ret) {\n\t\t\t\tmutex_unlock(&state->lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t*val = pms7003_get_pm(frame->data + chan->address);\n\t\t\tmutex_unlock(&state->lock);\n\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info pms7003_info = {\n\t.read_raw = pms7003_read_raw,\n};\n\n#define PMS7003_CHAN(_index, _mod, _addr) { \\\n\t.type = IIO_MASSCONCENTRATION, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_ ## _mod, \\\n\t.address = _addr, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), \\\n\t.scan_index = _index, \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 10, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_CPU, \\\n\t}, \\\n}\n\nstatic const struct iio_chan_spec pms7003_channels[] = {\n\tPMS7003_CHAN(0, PM1, PMS7003_PM1_OFFSET),\n\tPMS7003_CHAN(1, PM2P5, PMS7003_PM2P5_OFFSET),\n\tPMS7003_CHAN(2, PM10, PMS7003_PM10_OFFSET),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic u16 pms7003_calc_checksum(struct pms7003_frame *frame)\n{\n\tu16 checksum = (PMS7003_MAGIC >> 8) + (u8)(PMS7003_MAGIC & 0xff) +\n\t\t       (frame->length >> 8) + (u8)frame->length;\n\tint i;\n\n\tfor (i = 0; i < frame->length - PMS7003_CHECKSUM_LENGTH; i++)\n\t\tchecksum += frame->data[i];\n\n\treturn checksum;\n}\n\nstatic bool pms7003_frame_is_okay(struct pms7003_frame *frame)\n{\n\tint offset = frame->length - PMS7003_CHECKSUM_LENGTH;\n\tu16 checksum = get_unaligned_be16(frame->data + offset);\n\n\treturn checksum == pms7003_calc_checksum(frame);\n}\n\nstatic int pms7003_receive_buf(struct serdev_device *serdev,\n\t\t\t       const unsigned char *buf, size_t size)\n{\n\tstruct iio_dev *indio_dev = serdev_device_get_drvdata(serdev);\n\tstruct pms7003_state *state = iio_priv(indio_dev);\n\tstruct pms7003_frame *frame = &state->frame;\n\tint num;\n\n\tif (!frame->expected_length) {\n\t\tu16 magic;\n\n\t\t \n\t\tif (size < 4)\n\t\t\treturn 0;\n\n\t\tmagic = get_unaligned_be16(buf);\n\t\tif (magic != PMS7003_MAGIC)\n\t\t\treturn 2;\n\n\t\tnum = get_unaligned_be16(buf + 2);\n\t\tif (num <= PMS7003_MAX_DATA_LENGTH) {\n\t\t\tframe->expected_length = num;\n\t\t\tframe->length = 0;\n\t\t}\n\n\t\treturn 4;\n\t}\n\n\tnum = min(size, (size_t)(frame->expected_length - frame->length));\n\tmemcpy(frame->data + frame->length, buf, num);\n\tframe->length += num;\n\n\tif (frame->length == frame->expected_length) {\n\t\tif (pms7003_frame_is_okay(frame))\n\t\t\tcomplete(&state->frame_ready);\n\n\t\tframe->expected_length = 0;\n\t}\n\n\treturn num;\n}\n\nstatic const struct serdev_device_ops pms7003_serdev_ops = {\n\t.receive_buf = pms7003_receive_buf,\n\t.write_wakeup = serdev_device_write_wakeup,\n};\n\nstatic void pms7003_stop(void *data)\n{\n\tstruct pms7003_state *state = data;\n\n\tpms7003_do_cmd(state, CMD_SLEEP);\n}\n\nstatic const unsigned long pms7003_scan_masks[] = { 0x07, 0x00 };\n\nstatic int pms7003_probe(struct serdev_device *serdev)\n{\n\tstruct pms7003_state *state;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&serdev->dev, sizeof(*state));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tstate = iio_priv(indio_dev);\n\tserdev_device_set_drvdata(serdev, indio_dev);\n\tstate->serdev = serdev;\n\tindio_dev->info = &pms7003_info;\n\tindio_dev->name = PMS7003_DRIVER_NAME;\n\tindio_dev->channels = pms7003_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(pms7003_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->available_scan_masks = pms7003_scan_masks;\n\n\tmutex_init(&state->lock);\n\tinit_completion(&state->frame_ready);\n\n\tserdev_device_set_client_ops(serdev, &pms7003_serdev_ops);\n\tret = devm_serdev_device_open(&serdev->dev, serdev);\n\tif (ret)\n\t\treturn ret;\n\n\tserdev_device_set_baudrate(serdev, 9600);\n\tserdev_device_set_flow_control(serdev, false);\n\n\tret = serdev_device_set_parity(serdev, SERDEV_PARITY_NONE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pms7003_do_cmd(state, CMD_WAKEUP);\n\tif (ret) {\n\t\tdev_err(&serdev->dev, \"failed to wakeup sensor\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pms7003_do_cmd(state, CMD_ENTER_PASSIVE_MODE);\n\tif (ret) {\n\t\tdev_err(&serdev->dev, \"failed to enter passive mode\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&serdev->dev, pms7003_stop, state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup(&serdev->dev, indio_dev, NULL,\n\t\t\t\t\t      pms7003_trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&serdev->dev, indio_dev);\n}\n\nstatic const struct of_device_id pms7003_of_match[] = {\n\t{ .compatible = \"plantower,pms1003\" },\n\t{ .compatible = \"plantower,pms3003\" },\n\t{ .compatible = \"plantower,pms5003\" },\n\t{ .compatible = \"plantower,pms6003\" },\n\t{ .compatible = \"plantower,pms7003\" },\n\t{ .compatible = \"plantower,pmsa003\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pms7003_of_match);\n\nstatic struct serdev_device_driver pms7003_driver = {\n\t.driver = {\n\t\t.name = PMS7003_DRIVER_NAME,\n\t\t.of_match_table = pms7003_of_match,\n\t},\n\t.probe = pms7003_probe,\n};\nmodule_serdev_device_driver(pms7003_driver);\n\nMODULE_AUTHOR(\"Tomasz Duszynski <tduszyns@gmail.com>\");\nMODULE_DESCRIPTION(\"Plantower PMS7003 particulate matter sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}