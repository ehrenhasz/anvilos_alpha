{
  "module_name": "bme680_core.c",
  "hash_id": "daed6879737f2a3bea697266aba8afb0b8f69e1fc5ac714acec4be6dbf121940",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/bme680_core.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include <linux/regmap.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#include \"bme680.h\"\n\nstruct bme680_calib {\n\tu16 par_t1;\n\ts16 par_t2;\n\ts8  par_t3;\n\tu16 par_p1;\n\ts16 par_p2;\n\ts8  par_p3;\n\ts16 par_p4;\n\ts16 par_p5;\n\ts8  par_p6;\n\ts8  par_p7;\n\ts16 par_p8;\n\ts16 par_p9;\n\tu8  par_p10;\n\tu16 par_h1;\n\tu16 par_h2;\n\ts8  par_h3;\n\ts8  par_h4;\n\ts8  par_h5;\n\ts8  par_h6;\n\ts8  par_h7;\n\ts8  par_gh1;\n\ts16 par_gh2;\n\ts8  par_gh3;\n\tu8  res_heat_range;\n\ts8  res_heat_val;\n\ts8  range_sw_err;\n};\n\nstruct bme680_data {\n\tstruct regmap *regmap;\n\tstruct bme680_calib bme680;\n\tu8 oversampling_temp;\n\tu8 oversampling_press;\n\tu8 oversampling_humid;\n\tu16 heater_dur;\n\tu16 heater_temp;\n\t \n\ts32 t_fine;\n};\n\nstatic const struct regmap_range bme680_volatile_ranges[] = {\n\tregmap_reg_range(BME680_REG_MEAS_STAT_0, BME680_REG_GAS_R_LSB),\n\tregmap_reg_range(BME680_REG_STATUS, BME680_REG_STATUS),\n\tregmap_reg_range(BME680_T2_LSB_REG, BME680_GH3_REG),\n};\n\nstatic const struct regmap_access_table bme680_volatile_table = {\n\t.yes_ranges\t= bme680_volatile_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(bme680_volatile_ranges),\n};\n\nconst struct regmap_config bme680_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xef,\n\t.volatile_table = &bme680_volatile_table,\n\t.cache_type = REGCACHE_RBTREE,\n};\nEXPORT_SYMBOL_NS(bme680_regmap_config, IIO_BME680);\n\nstatic const struct iio_chan_spec bme680_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t},\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t},\n\t{\n\t\t.type = IIO_HUMIDITYRELATIVE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t},\n\t{\n\t\t.type = IIO_RESISTANCE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t},\n};\n\nstatic int bme680_read_calib(struct bme680_data *data,\n\t\t\t     struct bme680_calib *calib)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tunsigned int tmp, tmp_msb, tmp_lsb;\n\tint ret;\n\t__le16 buf;\n\n\t \n\tret = regmap_bulk_read(data->regmap, BME680_T1_LSB_REG,\n\t\t\t       &buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_T1_LSB_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_t1 = le16_to_cpu(buf);\n\n\tret = regmap_bulk_read(data->regmap, BME680_T2_LSB_REG,\n\t\t\t       &buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_T2_LSB_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_t2 = le16_to_cpu(buf);\n\n\tret = regmap_read(data->regmap, BME680_T3_REG, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_T3_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_t3 = tmp;\n\n\t \n\tret = regmap_bulk_read(data->regmap, BME680_P1_LSB_REG,\n\t\t\t       &buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_P1_LSB_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_p1 = le16_to_cpu(buf);\n\n\tret = regmap_bulk_read(data->regmap, BME680_P2_LSB_REG,\n\t\t\t       &buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_P2_LSB_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_p2 = le16_to_cpu(buf);\n\n\tret = regmap_read(data->regmap, BME680_P3_REG, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_P3_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_p3 = tmp;\n\n\tret = regmap_bulk_read(data->regmap, BME680_P4_LSB_REG,\n\t\t\t       &buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_P4_LSB_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_p4 = le16_to_cpu(buf);\n\n\tret = regmap_bulk_read(data->regmap, BME680_P5_LSB_REG,\n\t\t\t       &buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_P5_LSB_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_p5 = le16_to_cpu(buf);\n\n\tret = regmap_read(data->regmap, BME680_P6_REG, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_P6_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_p6 = tmp;\n\n\tret = regmap_read(data->regmap, BME680_P7_REG, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_P7_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_p7 = tmp;\n\n\tret = regmap_bulk_read(data->regmap, BME680_P8_LSB_REG,\n\t\t\t       &buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_P8_LSB_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_p8 = le16_to_cpu(buf);\n\n\tret = regmap_bulk_read(data->regmap, BME680_P9_LSB_REG,\n\t\t\t       &buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_P9_LSB_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_p9 = le16_to_cpu(buf);\n\n\tret = regmap_read(data->regmap, BME680_P10_REG, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_P10_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_p10 = tmp;\n\n\t \n\tret = regmap_read(data->regmap, BME680_H1_MSB_REG, &tmp_msb);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_H1_MSB_REG\\n\");\n\t\treturn ret;\n\t}\n\tret = regmap_read(data->regmap, BME680_H1_LSB_REG, &tmp_lsb);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_H1_LSB_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_h1 = (tmp_msb << BME680_HUM_REG_SHIFT_VAL) |\n\t\t\t(tmp_lsb & BME680_BIT_H1_DATA_MASK);\n\n\tret = regmap_read(data->regmap, BME680_H2_MSB_REG, &tmp_msb);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_H2_MSB_REG\\n\");\n\t\treturn ret;\n\t}\n\tret = regmap_read(data->regmap, BME680_H2_LSB_REG, &tmp_lsb);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_H2_LSB_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_h2 = (tmp_msb << BME680_HUM_REG_SHIFT_VAL) |\n\t\t\t(tmp_lsb >> BME680_HUM_REG_SHIFT_VAL);\n\n\tret = regmap_read(data->regmap, BME680_H3_REG, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_H3_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_h3 = tmp;\n\n\tret = regmap_read(data->regmap, BME680_H4_REG, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_H4_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_h4 = tmp;\n\n\tret = regmap_read(data->regmap, BME680_H5_REG, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_H5_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_h5 = tmp;\n\n\tret = regmap_read(data->regmap, BME680_H6_REG, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_H6_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_h6 = tmp;\n\n\tret = regmap_read(data->regmap, BME680_H7_REG, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_H7_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_h7 = tmp;\n\n\t \n\tret = regmap_read(data->regmap, BME680_GH1_REG, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_GH1_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_gh1 = tmp;\n\n\tret = regmap_bulk_read(data->regmap, BME680_GH2_LSB_REG,\n\t\t\t       &buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_GH2_LSB_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_gh2 = le16_to_cpu(buf);\n\n\tret = regmap_read(data->regmap, BME680_GH3_REG, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read BME680_GH3_REG\\n\");\n\t\treturn ret;\n\t}\n\tcalib->par_gh3 = tmp;\n\n\t \n\tret = regmap_read(data->regmap, BME680_REG_RES_HEAT_RANGE, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read resistance heat range\\n\");\n\t\treturn ret;\n\t}\n\tcalib->res_heat_range = FIELD_GET(BME680_RHRANGE_MASK, tmp);\n\n\tret = regmap_read(data->regmap, BME680_REG_RES_HEAT_VAL, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read resistance heat value\\n\");\n\t\treturn ret;\n\t}\n\tcalib->res_heat_val = tmp;\n\n\tret = regmap_read(data->regmap, BME680_REG_RANGE_SW_ERR, &tmp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read range software error\\n\");\n\t\treturn ret;\n\t}\n\tcalib->range_sw_err = FIELD_GET(BME680_RSERROR_MASK, tmp);\n\n\treturn 0;\n}\n\n \nstatic s16 bme680_compensate_temp(struct bme680_data *data,\n\t\t\t\t  s32 adc_temp)\n{\n\tstruct bme680_calib *calib = &data->bme680;\n\ts64 var1, var2, var3;\n\ts16 calc_temp;\n\n\t \n\tif (!calib->par_t2)\n\t\tbme680_read_calib(data, calib);\n\n\tvar1 = (adc_temp >> 3) - (calib->par_t1 << 1);\n\tvar2 = (var1 * calib->par_t2) >> 11;\n\tvar3 = ((var1 >> 1) * (var1 >> 1)) >> 12;\n\tvar3 = (var3 * (calib->par_t3 << 4)) >> 14;\n\tdata->t_fine = var2 + var3;\n\tcalc_temp = (data->t_fine * 5 + 128) >> 8;\n\n\treturn calc_temp;\n}\n\n \nstatic u32 bme680_compensate_press(struct bme680_data *data,\n\t\t\t\t   u32 adc_press)\n{\n\tstruct bme680_calib *calib = &data->bme680;\n\ts32 var1, var2, var3, press_comp;\n\n\tvar1 = (data->t_fine >> 1) - 64000;\n\tvar2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) * calib->par_p6) >> 2;\n\tvar2 = var2 + (var1 * calib->par_p5 << 1);\n\tvar2 = (var2 >> 2) + (calib->par_p4 << 16);\n\tvar1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) *\n\t\t\t(calib->par_p3 << 5)) >> 3) +\n\t\t\t((calib->par_p2 * var1) >> 1);\n\tvar1 = var1 >> 18;\n\tvar1 = ((32768 + var1) * calib->par_p1) >> 15;\n\tpress_comp = 1048576 - adc_press;\n\tpress_comp = ((press_comp - (var2 >> 12)) * 3125);\n\n\tif (press_comp >= BME680_MAX_OVERFLOW_VAL)\n\t\tpress_comp = ((press_comp / (u32)var1) << 1);\n\telse\n\t\tpress_comp = ((press_comp << 1) / (u32)var1);\n\n\tvar1 = (calib->par_p9 * (((press_comp >> 3) *\n\t\t\t(press_comp >> 3)) >> 13)) >> 12;\n\tvar2 = ((press_comp >> 2) * calib->par_p8) >> 13;\n\tvar3 = ((press_comp >> 8) * (press_comp >> 8) *\n\t\t\t(press_comp >> 8) * calib->par_p10) >> 17;\n\n\tpress_comp += (var1 + var2 + var3 + (calib->par_p7 << 7)) >> 4;\n\n\treturn press_comp;\n}\n\n \nstatic u32 bme680_compensate_humid(struct bme680_data *data,\n\t\t\t\t   u16 adc_humid)\n{\n\tstruct bme680_calib *calib = &data->bme680;\n\ts32 var1, var2, var3, var4, var5, var6, temp_scaled, calc_hum;\n\n\ttemp_scaled = (data->t_fine * 5 + 128) >> 8;\n\tvar1 = (adc_humid - ((s32) ((s32) calib->par_h1 * 16))) -\n\t\t(((temp_scaled * (s32) calib->par_h3) / 100) >> 1);\n\tvar2 = ((s32) calib->par_h2 *\n\t\t(((temp_scaled * calib->par_h4) / 100) +\n\t\t (((temp_scaled * ((temp_scaled * calib->par_h5) / 100))\n\t\t   >> 6) / 100) + (1 << 14))) >> 10;\n\tvar3 = var1 * var2;\n\tvar4 = calib->par_h6 << 7;\n\tvar4 = (var4 + ((temp_scaled * calib->par_h7) / 100)) >> 4;\n\tvar5 = ((var3 >> 14) * (var3 >> 14)) >> 10;\n\tvar6 = (var4 * var5) >> 1;\n\tcalc_hum = (((var3 + var6) >> 10) * 1000) >> 12;\n\n\tcalc_hum = clamp(calc_hum, 0, 100000);  \n\n\treturn calc_hum;\n}\n\n \nstatic u32 bme680_compensate_gas(struct bme680_data *data, u16 gas_res_adc,\n\t\t\t\t u8 gas_range)\n{\n\tstruct bme680_calib *calib = &data->bme680;\n\ts64 var1;\n\tu64 var2;\n\ts64 var3;\n\tu32 calc_gas_res;\n\n\t \n\tconst u32 lookupTable[16] = {2147483647u, 2147483647u,\n\t\t\t\t2147483647u, 2147483647u, 2147483647u,\n\t\t\t\t2126008810u, 2147483647u, 2130303777u,\n\t\t\t\t2147483647u, 2147483647u, 2143188679u,\n\t\t\t\t2136746228u, 2147483647u, 2126008810u,\n\t\t\t\t2147483647u, 2147483647u};\n\n\tvar1 = ((1340 + (5 * (s64) calib->range_sw_err)) *\n\t\t\t((s64) lookupTable[gas_range])) >> 16;\n\tvar2 = ((gas_res_adc << 15) - 16777216) + var1;\n\tvar3 = ((125000 << (15 - gas_range)) * var1) >> 9;\n\tvar3 += (var2 >> 1);\n\tcalc_gas_res = div64_s64(var3, (s64) var2);\n\n\treturn calc_gas_res;\n}\n\n \nstatic u8 bme680_calc_heater_res(struct bme680_data *data, u16 temp)\n{\n\tstruct bme680_calib *calib = &data->bme680;\n\ts32 var1, var2, var3, var4, var5, heatr_res_x100;\n\tu8 heatr_res;\n\n\tif (temp > 400)  \n\t\ttemp = 400;\n\n\tvar1 = (((s32) BME680_AMB_TEMP * calib->par_gh3) / 1000) * 256;\n\tvar2 = (calib->par_gh1 + 784) * (((((calib->par_gh2 + 154009) *\n\t\t\t\t\t\ttemp * 5) / 100)\n\t\t\t\t\t\t+ 3276800) / 10);\n\tvar3 = var1 + (var2 / 2);\n\tvar4 = (var3 / (calib->res_heat_range + 4));\n\tvar5 = 131 * calib->res_heat_val + 65536;\n\theatr_res_x100 = ((var4 / var5) - 250) * 34;\n\theatr_res = DIV_ROUND_CLOSEST(heatr_res_x100, 100);\n\n\treturn heatr_res;\n}\n\n \nstatic u8 bme680_calc_heater_dur(u16 dur)\n{\n\tu8 durval, factor = 0;\n\n\tif (dur >= 0xfc0) {\n\t\tdurval = 0xff;  \n\t} else {\n\t\twhile (dur > 0x3F) {\n\t\t\tdur = dur / 4;\n\t\t\tfactor += 1;\n\t\t}\n\t\tdurval = dur + (factor * 64);\n\t}\n\n\treturn durval;\n}\n\nstatic int bme680_set_mode(struct bme680_data *data, bool mode)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\n\tif (mode) {\n\t\tret = regmap_write_bits(data->regmap, BME680_REG_CTRL_MEAS,\n\t\t\t\t\tBME680_MODE_MASK, BME680_MODE_FORCED);\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"failed to set forced mode\\n\");\n\n\t} else {\n\t\tret = regmap_write_bits(data->regmap, BME680_REG_CTRL_MEAS,\n\t\t\t\t\tBME680_MODE_MASK, BME680_MODE_SLEEP);\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"failed to set sleep mode\\n\");\n\n\t}\n\n\treturn ret;\n}\n\nstatic u8 bme680_oversampling_to_reg(u8 val)\n{\n\treturn ilog2(val) + 1;\n}\n\nstatic int bme680_chip_config(struct bme680_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\tu8 osrs;\n\n\tosrs = FIELD_PREP(\n\t\tBME680_OSRS_HUMIDITY_MASK,\n\t\tbme680_oversampling_to_reg(data->oversampling_humid));\n\t \n\tret = regmap_update_bits(data->regmap, BME680_REG_CTRL_HUMIDITY,\n\t\t\t\t BME680_OSRS_HUMIDITY_MASK, osrs);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to write ctrl_hum register\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(data->regmap, BME680_REG_CONFIG,\n\t\t\t\t BME680_FILTER_MASK,\n\t\t\t\t BME680_FILTER_COEFF_VAL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to write config register\\n\");\n\t\treturn ret;\n\t}\n\n\tosrs = FIELD_PREP(BME680_OSRS_TEMP_MASK,\n\t\t\t  bme680_oversampling_to_reg(data->oversampling_temp)) |\n\t       FIELD_PREP(BME680_OSRS_PRESS_MASK,\n\t\t\t  bme680_oversampling_to_reg(data->oversampling_press));\n\tret = regmap_write_bits(data->regmap, BME680_REG_CTRL_MEAS,\n\t\t\t\tBME680_OSRS_TEMP_MASK | BME680_OSRS_PRESS_MASK,\n\t\t\t\tosrs);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to write ctrl_meas register\\n\");\n\n\treturn ret;\n}\n\nstatic int bme680_gas_config(struct bme680_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\tu8 heatr_res, heatr_dur;\n\n\theatr_res = bme680_calc_heater_res(data, data->heater_temp);\n\n\t \n\tret = regmap_write(data->regmap, BME680_REG_RES_HEAT_0, heatr_res);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to write res_heat_0 register\\n\");\n\t\treturn ret;\n\t}\n\n\theatr_dur = bme680_calc_heater_dur(data->heater_dur);\n\n\t \n\tret = regmap_write(data->regmap, BME680_REG_GAS_WAIT_0, heatr_dur);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to write gas_wait_0 register\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(data->regmap, BME680_REG_CTRL_GAS_1,\n\t\t\t\t BME680_RUN_GAS_MASK | BME680_NB_CONV_MASK,\n\t\t\t\t FIELD_PREP(BME680_RUN_GAS_MASK, 1) |\n\t\t\t\t FIELD_PREP(BME680_NB_CONV_MASK, 0));\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to write ctrl_gas_1 register\\n\");\n\n\treturn ret;\n}\n\nstatic int bme680_read_temp(struct bme680_data *data, int *val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\t__be32 tmp = 0;\n\ts32 adc_temp;\n\ts16 comp_temp;\n\n\t \n\tret = bme680_set_mode(data, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, BME680_REG_TEMP_MSB,\n\t\t\t       &tmp, 3);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read temperature\\n\");\n\t\treturn ret;\n\t}\n\n\tadc_temp = be32_to_cpu(tmp) >> 12;\n\tif (adc_temp == BME680_MEAS_SKIPPED) {\n\t\t \n\t\tdev_err(dev, \"reading temperature skipped\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcomp_temp = bme680_compensate_temp(data, adc_temp);\n\t \n\tif (val) {\n\t\t*val = comp_temp * 10;  \n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn ret;\n}\n\nstatic int bme680_read_press(struct bme680_data *data,\n\t\t\t     int *val, int *val2)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\t__be32 tmp = 0;\n\ts32 adc_press;\n\n\t \n\tret = bme680_read_temp(data, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, BME680_REG_PRESS_MSB,\n\t\t\t       &tmp, 3);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read pressure\\n\");\n\t\treturn ret;\n\t}\n\n\tadc_press = be32_to_cpu(tmp) >> 12;\n\tif (adc_press == BME680_MEAS_SKIPPED) {\n\t\t \n\t\tdev_err(dev, \"reading pressure skipped\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*val = bme680_compensate_press(data, adc_press);\n\t*val2 = 100;\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int bme680_read_humid(struct bme680_data *data,\n\t\t\t     int *val, int *val2)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\t__be16 tmp = 0;\n\ts32 adc_humidity;\n\tu32 comp_humidity;\n\n\t \n\tret = bme680_read_temp(data, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, BM6880_REG_HUMIDITY_MSB,\n\t\t\t       &tmp, sizeof(tmp));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read humidity\\n\");\n\t\treturn ret;\n\t}\n\n\tadc_humidity = be16_to_cpu(tmp);\n\tif (adc_humidity == BME680_MEAS_SKIPPED) {\n\t\t \n\t\tdev_err(dev, \"reading humidity skipped\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcomp_humidity = bme680_compensate_humid(data, adc_humidity);\n\n\t*val = comp_humidity;\n\t*val2 = 1000;\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int bme680_read_gas(struct bme680_data *data,\n\t\t\t   int *val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\t__be16 tmp = 0;\n\tunsigned int check;\n\tu16 adc_gas_res;\n\tu8 gas_range;\n\n\t \n\tret = bme680_gas_config(data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to set gas config\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = bme680_set_mode(data, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(data->regmap, BME680_REG_MEAS_STAT_0, &check);\n\tif (check & BME680_GAS_MEAS_BIT) {\n\t\tdev_err(dev, \"gas measurement incomplete\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = regmap_read(data->regmap, BME680_REG_GAS_R_LSB, &check);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read gas_r_lsb register\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif ((check & BME680_GAS_STAB_BIT) == 0) {\n\t\tdev_err(dev, \"heater failed to reach the target temperature\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_bulk_read(data->regmap, BME680_REG_GAS_MSB,\n\t\t\t       &tmp, sizeof(tmp));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read gas resistance\\n\");\n\t\treturn ret;\n\t}\n\n\tgas_range = check & BME680_GAS_RANGE_MASK;\n\tadc_gas_res = be16_to_cpu(tmp) >> BME680_ADC_GAS_RES_SHIFT;\n\n\t*val = bme680_compensate_gas(data, adc_gas_res, gas_range);\n\treturn IIO_VAL_INT;\n}\n\nstatic int bme680_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct bme680_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\treturn bme680_read_temp(data, val);\n\t\tcase IIO_PRESSURE:\n\t\t\treturn bme680_read_press(data, val, val2);\n\t\tcase IIO_HUMIDITYRELATIVE:\n\t\t\treturn bme680_read_humid(data, val, val2);\n\t\tcase IIO_RESISTANCE:\n\t\t\treturn bme680_read_gas(data, val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t*val = data->oversampling_temp;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_PRESSURE:\n\t\t\t*val = data->oversampling_press;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_HUMIDITYRELATIVE:\n\t\t\t*val = data->oversampling_humid;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic bool bme680_is_valid_oversampling(int rate)\n{\n\treturn (rate > 0 && rate <= 16 && is_power_of_2(rate));\n}\n\nstatic int bme680_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct bme680_data *data = iio_priv(indio_dev);\n\n\tif (val2 != 0)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t{\n\t\tif (!bme680_is_valid_oversampling(val))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\tdata->oversampling_temp = val;\n\t\t\tbreak;\n\t\tcase IIO_PRESSURE:\n\t\t\tdata->oversampling_press = val;\n\t\t\tbreak;\n\t\tcase IIO_HUMIDITYRELATIVE:\n\t\t\tdata->oversampling_humid = val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn bme680_chip_config(data);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const char bme680_oversampling_ratio_show[] = \"1 2 4 8 16\";\n\nstatic IIO_CONST_ATTR(oversampling_ratio_available,\n\t\t      bme680_oversampling_ratio_show);\n\nstatic struct attribute *bme680_attributes[] = {\n\t&iio_const_attr_oversampling_ratio_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group bme680_attribute_group = {\n\t.attrs = bme680_attributes,\n};\n\nstatic const struct iio_info bme680_info = {\n\t.read_raw = &bme680_read_raw,\n\t.write_raw = &bme680_write_raw,\n\t.attrs = &bme680_attribute_group,\n};\n\nstatic const char *bme680_match_acpi_device(struct device *dev)\n{\n\tconst struct acpi_device_id *id;\n\n\tid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\tif (!id)\n\t\treturn NULL;\n\n\treturn dev_name(dev);\n}\n\nint bme680_core_probe(struct device *dev, struct regmap *regmap,\n\t\t      const char *name)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct bme680_data *data;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_write(regmap, BME680_REG_SOFT_RESET,\n\t\t\t   BME680_CMD_SOFTRESET);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to reset chip\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(regmap, BME680_REG_CHIP_ID, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading chip ID\\n\");\n\t\treturn ret;\n\t}\n\n\tif (val != BME680_CHIP_ID_VAL) {\n\t\tdev_err(dev, \"Wrong chip ID, got %x expected %x\\n\",\n\t\t\t\tval, BME680_CHIP_ID_VAL);\n\t\treturn -ENODEV;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tif (!name && ACPI_HANDLE(dev))\n\t\tname = bme680_match_acpi_device(dev);\n\n\tdata = iio_priv(indio_dev);\n\tdev_set_drvdata(dev, indio_dev);\n\tdata->regmap = regmap;\n\tindio_dev->name = name;\n\tindio_dev->channels = bme680_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(bme680_channels);\n\tindio_dev->info = &bme680_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\t \n\tdata->oversampling_humid = 2;  \n\tdata->oversampling_press = 4;  \n\tdata->oversampling_temp = 8;   \n\tdata->heater_temp = 320;  \n\tdata->heater_dur = 150;   \n\n\tret = bme680_chip_config(data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to set chip_config data\\n\");\n\t\treturn ret;\n\t}\n\n\tret = bme680_gas_config(data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to set gas config data\\n\");\n\t\treturn ret;\n\t}\n\n\tret = bme680_read_calib(data, &data->bme680);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"failed to read calibration coefficients at probe\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(bme680_core_probe, IIO_BME680);\n\nMODULE_AUTHOR(\"Himanshu Jha <himanshujha199640@gmail.com>\");\nMODULE_DESCRIPTION(\"Bosch BME680 Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}