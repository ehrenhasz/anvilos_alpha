{
  "module_name": "sps30_i2c.c",
  "hash_id": "b57cc9f3a62d84dadb1252381239846c0b6fba0487637221d8d380bfeb3a7311",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/sps30_i2c.c",
  "human_readable_source": "\n \n#include <asm/unaligned.h>\n#include <linux/crc8.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/types.h>\n\n#include \"sps30.h\"\n\n#define SPS30_I2C_CRC8_POLYNOMIAL 0x31\n \n#define SPS30_I2C_MAX_BUF_SIZE 48\n\nDECLARE_CRC8_TABLE(sps30_i2c_crc8_table);\n\n#define SPS30_I2C_START_MEAS 0x0010\n#define SPS30_I2C_STOP_MEAS 0x0104\n#define SPS30_I2C_READ_MEAS 0x0300\n#define SPS30_I2C_MEAS_READY 0x0202\n#define SPS30_I2C_RESET 0xd304\n#define SPS30_I2C_CLEAN_FAN 0x5607\n#define SPS30_I2C_PERIOD 0x8004\n#define SPS30_I2C_READ_SERIAL 0xd033\n#define SPS30_I2C_READ_VERSION 0xd100\n\nstatic int sps30_i2c_xfer(struct sps30_state *state, unsigned char *txbuf, size_t txsize,\n\t\t\t  unsigned char *rxbuf, size_t rxsize)\n{\n\tstruct i2c_client *client = to_i2c_client(state->dev);\n\tint ret;\n\n\t \n\tret = i2c_master_send(client, txbuf, txsize);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != txsize)\n\t\treturn -EIO;\n\n\tif (!rxsize)\n\t\treturn 0;\n\n\tret = i2c_master_recv(client, rxbuf, rxsize);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != rxsize)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int sps30_i2c_command(struct sps30_state *state, u16 cmd, void *arg, size_t arg_size,\n\t\t\t     void *rsp, size_t rsp_size)\n{\n\t \n\tunsigned char buf[SPS30_I2C_MAX_BUF_SIZE];\n\tunsigned char *tmp;\n\tunsigned char crc;\n\tsize_t i;\n\tint ret;\n\n\tput_unaligned_be16(cmd, buf);\n\ti = 2;\n\n\tif (rsp) {\n\t\t \n\t\trsp_size += rsp_size / 2;\n\t} else {\n\t\ttmp = arg;\n\n\t\twhile (arg_size) {\n\t\t\tbuf[i] = *tmp++;\n\t\t\tbuf[i + 1] = *tmp++;\n\t\t\tbuf[i + 2] = crc8(sps30_i2c_crc8_table, buf + i, 2, CRC8_INIT_VALUE);\n\t\t\targ_size -= 2;\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\tret = sps30_i2c_xfer(state, buf, i, buf, rsp_size);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttmp = rsp;\n\tfor (i = 0; i < rsp_size; i += 3) {\n\t\tcrc = crc8(sps30_i2c_crc8_table, buf + i, 2, CRC8_INIT_VALUE);\n\t\tif (crc != buf[i + 2]) {\n\t\t\tdev_err(state->dev, \"data integrity check failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t*tmp++ = buf[i];\n\t\t*tmp++ = buf[i + 1];\n\t}\n\n\treturn 0;\n}\n\nstatic int sps30_i2c_start_meas(struct sps30_state *state)\n{\n\t \n\tunsigned char buf[] = { 0x03, 0x00 };\n\n\treturn sps30_i2c_command(state, SPS30_I2C_START_MEAS, buf, sizeof(buf), NULL, 0);\n}\n\nstatic int sps30_i2c_stop_meas(struct sps30_state *state)\n{\n\treturn sps30_i2c_command(state, SPS30_I2C_STOP_MEAS, NULL, 0, NULL, 0);\n}\n\nstatic int sps30_i2c_reset(struct sps30_state *state)\n{\n\tint ret;\n\n\tret = sps30_i2c_command(state, SPS30_I2C_RESET, NULL, 0, NULL, 0);\n\tmsleep(500);\n\t \n\tsps30_i2c_stop_meas(state);\n\n\treturn ret;\n}\n\nstatic bool sps30_i2c_meas_ready(struct sps30_state *state)\n{\n\tunsigned char buf[2];\n\tint ret;\n\n\tret = sps30_i2c_command(state, SPS30_I2C_MEAS_READY, NULL, 0, buf, sizeof(buf));\n\tif (ret)\n\t\treturn false;\n\n\treturn buf[1];\n}\n\nstatic int sps30_i2c_read_meas(struct sps30_state *state, __be32 *meas, size_t num)\n{\n\t \n\tif (msleep_interruptible(1000))\n\t\treturn -EINTR;\n\n\tif (!sps30_i2c_meas_ready(state))\n\t\treturn -ETIMEDOUT;\n\n\treturn sps30_i2c_command(state, SPS30_I2C_READ_MEAS, NULL, 0, meas, sizeof(num) * num);\n}\n\nstatic int sps30_i2c_clean_fan(struct sps30_state *state)\n{\n\treturn sps30_i2c_command(state, SPS30_I2C_CLEAN_FAN, NULL, 0, NULL, 0);\n}\n\nstatic int sps30_i2c_read_cleaning_period(struct sps30_state *state, __be32 *period)\n{\n\treturn sps30_i2c_command(state, SPS30_I2C_PERIOD, NULL, 0, period, sizeof(*period));\n}\n\nstatic int sps30_i2c_write_cleaning_period(struct sps30_state *state, __be32 period)\n{\n\treturn sps30_i2c_command(state, SPS30_I2C_PERIOD, &period, sizeof(period), NULL, 0);\n}\n\nstatic int sps30_i2c_show_info(struct sps30_state *state)\n{\n\t \n\tunsigned char buf[32 + 1] = { 0x00 };\n\tint ret;\n\n\tret = sps30_i2c_command(state, SPS30_I2C_READ_SERIAL, NULL, 0, buf, sizeof(buf) - 1);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(state->dev, \"serial number: %s\\n\", buf);\n\n\tret = sps30_i2c_command(state, SPS30_I2C_READ_VERSION, NULL, 0, buf, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(state->dev, \"fw version: %u.%u\\n\", buf[0], buf[1]);\n\n\treturn 0;\n}\n\nstatic const struct sps30_ops sps30_i2c_ops = {\n\t.start_meas = sps30_i2c_start_meas,\n\t.stop_meas = sps30_i2c_stop_meas,\n\t.read_meas = sps30_i2c_read_meas,\n\t.reset = sps30_i2c_reset,\n\t.clean_fan = sps30_i2c_clean_fan,\n\t.read_cleaning_period = sps30_i2c_read_cleaning_period,\n\t.write_cleaning_period = sps30_i2c_write_cleaning_period,\n\t.show_info = sps30_i2c_show_info,\n};\n\nstatic int sps30_i2c_probe(struct i2c_client *client)\n{\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -EOPNOTSUPP;\n\n\tcrc8_populate_msb(sps30_i2c_crc8_table, SPS30_I2C_CRC8_POLYNOMIAL);\n\n\treturn sps30_probe(&client->dev, client->name, NULL, &sps30_i2c_ops);\n}\n\nstatic const struct i2c_device_id sps30_i2c_id[] = {\n\t{ \"sps30\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sps30_i2c_id);\n\nstatic const struct of_device_id sps30_i2c_of_match[] = {\n\t{ .compatible = \"sensirion,sps30\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sps30_i2c_of_match);\n\nstatic struct i2c_driver sps30_i2c_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = sps30_i2c_of_match,\n\t},\n\t.id_table = sps30_i2c_id,\n\t.probe = sps30_i2c_probe,\n};\nmodule_i2c_driver(sps30_i2c_driver);\n\nMODULE_AUTHOR(\"Tomasz Duszynski <tomasz.duszynski@octakon.com>\");\nMODULE_DESCRIPTION(\"Sensirion SPS30 particulate matter sensor i2c driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_SPS30);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}