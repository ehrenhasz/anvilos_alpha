{
  "module_name": "sps30.c",
  "hash_id": "c7ea3f7043a4a0151c0e96938322c8734bd535bad22e9dd8e4437060d5c49479",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/sps30.c",
  "human_readable_source": "\n \n\n#include <linux/crc8.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"sps30.h\"\n\n \n#define SPS30_MAX_PM 3000\n \n#define SPS30_AUTO_CLEANING_PERIOD_MIN 0\n#define SPS30_AUTO_CLEANING_PERIOD_MAX 604800\n\nenum {\n\tPM1,\n\tPM2P5,\n\tPM4,\n\tPM10,\n};\n\nenum {\n\tRESET,\n\tMEASURING,\n};\n\nstatic s32 sps30_float_to_int_clamped(__be32 *fp)\n{\n\tint val = be32_to_cpup(fp);\n\tint mantissa = val & GENMASK(22, 0);\n\t \n\tint exp = val >> 23;\n\tint fraction, shift;\n\n\t \n\tif (!exp && !mantissa)\n\t\treturn 0;\n\n\texp -= 127;\n\tif (exp < 0) {\n\t\t \n\t\treturn ((((1 << 23) + mantissa) * 100) >> 23) >> (-exp);\n\t}\n\n\t \n\tshift = 23 - exp;\n\tval = (1 << exp) + (mantissa >> shift);\n\tif (val >= SPS30_MAX_PM)\n\t\treturn SPS30_MAX_PM * 100;\n\n\tfraction = mantissa & GENMASK(shift - 1, 0);\n\n\treturn val * 100 + ((fraction * 100) >> shift);\n}\n\nstatic int sps30_do_meas(struct sps30_state *state, s32 *data, int size)\n{\n\tint i, ret;\n\n\tif (state->state == RESET) {\n\t\tret = state->ops->start_meas(state);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstate->state = MEASURING;\n\t}\n\n\tret = state->ops->read_meas(state, (__be32 *)data, size);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < size; i++)\n\t\tdata[i] = sps30_float_to_int_clamped((__be32 *)&data[i]);\n\n\treturn 0;\n}\n\nstatic int sps30_do_reset(struct sps30_state *state)\n{\n\tint ret;\n\n\tret = state->ops->reset(state);\n\tif (ret)\n\t\treturn ret;\n\n\tstate->state = RESET;\n\n\treturn 0;\n}\n\nstatic irqreturn_t sps30_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct sps30_state *state = iio_priv(indio_dev);\n\tint ret;\n\tstruct {\n\t\ts32 data[4];  \n\t\ts64 ts;\n\t} scan;\n\n\tmutex_lock(&state->lock);\n\tret = sps30_do_meas(state, scan.data, ARRAY_SIZE(scan.data));\n\tmutex_unlock(&state->lock);\n\tif (ret)\n\t\tgoto err;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sps30_read_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t  int *val, int *val2, long mask)\n{\n\tstruct sps30_state *state = iio_priv(indio_dev);\n\tint data[4], ret = -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_MASSCONCENTRATION:\n\t\t\tmutex_lock(&state->lock);\n\t\t\t \n\t\t\tswitch (chan->channel2) {\n\t\t\tcase IIO_MOD_PM1:\n\t\t\t\tret = sps30_do_meas(state, data, 1);\n\t\t\t\tbreak;\n\t\t\tcase IIO_MOD_PM2P5:\n\t\t\t\tret = sps30_do_meas(state, data, 2);\n\t\t\t\tbreak;\n\t\t\tcase IIO_MOD_PM4:\n\t\t\t\tret = sps30_do_meas(state, data, 3);\n\t\t\t\tbreak;\n\t\t\tcase IIO_MOD_PM10:\n\t\t\t\tret = sps30_do_meas(state, data, 4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmutex_unlock(&state->lock);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*val = data[chan->address] / 100;\n\t\t\t*val2 = (data[chan->address] % 100) * 10000;\n\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_MASSCONCENTRATION:\n\t\t\tswitch (chan->channel2) {\n\t\t\tcase IIO_MOD_PM1:\n\t\t\tcase IIO_MOD_PM2P5:\n\t\t\tcase IIO_MOD_PM4:\n\t\t\tcase IIO_MOD_PM10:\n\t\t\t\t*val = 0;\n\t\t\t\t*val2 = 10000;\n\n\t\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t start_cleaning_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct sps30_state *state = iio_priv(indio_dev);\n\tint val, ret;\n\n\tif (kstrtoint(buf, 0, &val) || val != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->lock);\n\tret = state->ops->clean_fan(state);\n\tmutex_unlock(&state->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t cleaning_period_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct sps30_state *state = iio_priv(indio_dev);\n\t__be32 val;\n\tint ret;\n\n\tmutex_lock(&state->lock);\n\tret = state->ops->read_cleaning_period(state, &val);\n\tmutex_unlock(&state->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", be32_to_cpu(val));\n}\n\nstatic ssize_t cleaning_period_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct sps30_state *state = iio_priv(indio_dev);\n\tint val, ret;\n\n\tif (kstrtoint(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif ((val < SPS30_AUTO_CLEANING_PERIOD_MIN) ||\n\t    (val > SPS30_AUTO_CLEANING_PERIOD_MAX))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->lock);\n\tret = state->ops->write_cleaning_period(state, cpu_to_be32(val));\n\tif (ret) {\n\t\tmutex_unlock(&state->lock);\n\t\treturn ret;\n\t}\n\n\tmsleep(20);\n\n\t \n\tret = sps30_do_reset(state);\n\tif (ret)\n\t\tdev_warn(dev,\n\t\t\t \"period changed but reads will return the old value\\n\");\n\n\tmutex_unlock(&state->lock);\n\n\treturn len;\n}\n\nstatic ssize_t cleaning_period_available_show(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\treturn sysfs_emit(buf, \"[%d %d %d]\\n\",\n\t\t\t  SPS30_AUTO_CLEANING_PERIOD_MIN, 1,\n\t\t\t  SPS30_AUTO_CLEANING_PERIOD_MAX);\n}\n\nstatic IIO_DEVICE_ATTR_WO(start_cleaning, 0);\nstatic IIO_DEVICE_ATTR_RW(cleaning_period, 0);\nstatic IIO_DEVICE_ATTR_RO(cleaning_period_available, 0);\n\nstatic struct attribute *sps30_attrs[] = {\n\t&iio_dev_attr_start_cleaning.dev_attr.attr,\n\t&iio_dev_attr_cleaning_period.dev_attr.attr,\n\t&iio_dev_attr_cleaning_period_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group sps30_attr_group = {\n\t.attrs = sps30_attrs,\n};\n\nstatic const struct iio_info sps30_info = {\n\t.attrs = &sps30_attr_group,\n\t.read_raw = sps30_read_raw,\n};\n\n#define SPS30_CHAN(_index, _mod) { \\\n\t.type = IIO_MASSCONCENTRATION, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_ ## _mod, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t.address = _mod, \\\n\t.scan_index = _index, \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 19, \\\n\t\t.storagebits = 32, \\\n\t\t.endianness = IIO_CPU, \\\n\t}, \\\n}\n\nstatic const struct iio_chan_spec sps30_channels[] = {\n\tSPS30_CHAN(0, PM1),\n\tSPS30_CHAN(1, PM2P5),\n\tSPS30_CHAN(2, PM4),\n\tSPS30_CHAN(3, PM10),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic void sps30_devm_stop_meas(void *data)\n{\n\tstruct sps30_state *state = data;\n\n\tif (state->state == MEASURING)\n\t\tstate->ops->stop_meas(state);\n}\n\nstatic const unsigned long sps30_scan_masks[] = { 0x0f, 0x00 };\n\nint sps30_probe(struct device *dev, const char *name, void *priv, const struct sps30_ops *ops)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct sps30_state *state;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*state));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, indio_dev);\n\n\tstate = iio_priv(indio_dev);\n\tstate->dev = dev;\n\tstate->priv = priv;\n\tstate->ops = ops;\n\tmutex_init(&state->lock);\n\n\tindio_dev->info = &sps30_info;\n\tindio_dev->name = name;\n\tindio_dev->channels = sps30_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(sps30_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->available_scan_masks = sps30_scan_masks;\n\n\tret = sps30_do_reset(state);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to reset device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = state->ops->show_info(state);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read device info\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev, sps30_devm_stop_meas, state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,\n\t\t\t\t\t      sps30_trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(sps30_probe, IIO_SPS30);\n\nMODULE_AUTHOR(\"Tomasz Duszynski <tduszyns@gmail.com>\");\nMODULE_DESCRIPTION(\"Sensirion SPS30 particulate matter sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}