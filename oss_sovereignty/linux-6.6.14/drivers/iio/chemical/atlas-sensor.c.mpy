{
  "module_name": "atlas-sensor.c",
  "hash_id": "43ed8eefb374ee2a29a55906aeed981d1f985931c7de25e7279d82fe5bb2786e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/atlas-sensor.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/irq.h>\n#include <linux/irq_work.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/regmap.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/pm_runtime.h>\n\n#define ATLAS_REGMAP_NAME\t\"atlas_regmap\"\n#define ATLAS_DRV_NAME\t\t\"atlas\"\n\n#define ATLAS_REG_DEV_TYPE\t\t0x00\n#define ATLAS_REG_DEV_VERSION\t\t0x01\n\n#define ATLAS_REG_INT_CONTROL\t\t0x04\n#define ATLAS_REG_INT_CONTROL_EN\tBIT(3)\n\n#define ATLAS_REG_PWR_CONTROL\t\t0x06\n\n#define ATLAS_REG_PH_CALIB_STATUS\t0x0d\n#define ATLAS_REG_PH_CALIB_STATUS_MASK\t0x07\n#define ATLAS_REG_PH_CALIB_STATUS_LOW\tBIT(0)\n#define ATLAS_REG_PH_CALIB_STATUS_MID\tBIT(1)\n#define ATLAS_REG_PH_CALIB_STATUS_HIGH\tBIT(2)\n\n#define ATLAS_REG_EC_CALIB_STATUS\t\t0x0f\n#define ATLAS_REG_EC_CALIB_STATUS_MASK\t\t0x0f\n#define ATLAS_REG_EC_CALIB_STATUS_DRY\t\tBIT(0)\n#define ATLAS_REG_EC_CALIB_STATUS_SINGLE\tBIT(1)\n#define ATLAS_REG_EC_CALIB_STATUS_LOW\t\tBIT(2)\n#define ATLAS_REG_EC_CALIB_STATUS_HIGH\t\tBIT(3)\n\n#define ATLAS_REG_DO_CALIB_STATUS\t\t0x09\n#define ATLAS_REG_DO_CALIB_STATUS_MASK\t\t0x03\n#define ATLAS_REG_DO_CALIB_STATUS_PRESSURE\tBIT(0)\n#define ATLAS_REG_DO_CALIB_STATUS_DO\t\tBIT(1)\n\n#define ATLAS_REG_RTD_DATA\t\t0x0e\n\n#define ATLAS_REG_PH_TEMP_DATA\t\t0x0e\n#define ATLAS_REG_PH_DATA\t\t0x16\n\n#define ATLAS_REG_EC_PROBE\t\t0x08\n#define ATLAS_REG_EC_TEMP_DATA\t\t0x10\n#define ATLAS_REG_EC_DATA\t\t0x18\n#define ATLAS_REG_TDS_DATA\t\t0x1c\n#define ATLAS_REG_PSS_DATA\t\t0x20\n\n#define ATLAS_REG_ORP_CALIB_STATUS\t0x0d\n#define ATLAS_REG_ORP_DATA\t\t0x0e\n\n#define ATLAS_REG_DO_TEMP_DATA\t\t0x12\n#define ATLAS_REG_DO_DATA\t\t0x22\n\n#define ATLAS_PH_INT_TIME_IN_MS\t\t450\n#define ATLAS_EC_INT_TIME_IN_MS\t\t650\n#define ATLAS_ORP_INT_TIME_IN_MS\t450\n#define ATLAS_DO_INT_TIME_IN_MS\t\t450\n#define ATLAS_RTD_INT_TIME_IN_MS\t450\n\nenum {\n\tATLAS_PH_SM,\n\tATLAS_EC_SM,\n\tATLAS_ORP_SM,\n\tATLAS_DO_SM,\n\tATLAS_RTD_SM,\n};\n\nstruct atlas_data {\n\tstruct i2c_client *client;\n\tstruct iio_trigger *trig;\n\tstruct atlas_device *chip;\n\tstruct regmap *regmap;\n\tstruct irq_work work;\n\tunsigned int interrupt_enabled;\n\t \n\t__be32 buffer[6] __aligned(8);\n};\n\nstatic const struct regmap_config atlas_regmap_config = {\n\t.name = ATLAS_REGMAP_NAME,\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int atlas_buffer_num_channels(const struct iio_chan_spec *spec)\n{\n\tint idx = 0;\n\n\tfor (; spec->type != IIO_TIMESTAMP; spec++)\n\t\tidx++;\n\n\treturn idx;\n};\n\nstatic const struct iio_chan_spec atlas_ph_channels[] = {\n\t{\n\t\t.type = IIO_PH,\n\t\t.address = ATLAS_REG_PH_DATA,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 32,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = ATLAS_REG_PH_TEMP_DATA,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.output = 1,\n\t\t.scan_index = -1\n\t},\n};\n\n#define ATLAS_CONCENTRATION_CHANNEL(_idx, _addr) \\\n\t{\\\n\t\t.type = IIO_CONCENTRATION, \\\n\t\t.indexed = 1, \\\n\t\t.channel = _idx, \\\n\t\t.address = _addr, \\\n\t\t.info_mask_separate = \\\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE), \\\n\t\t.scan_index = _idx + 1, \\\n\t\t.scan_type = { \\\n\t\t\t.sign = 'u', \\\n\t\t\t.realbits = 32, \\\n\t\t\t.storagebits = 32, \\\n\t\t\t.endianness = IIO_BE, \\\n\t\t}, \\\n\t}\n\nstatic const struct iio_chan_spec atlas_ec_channels[] = {\n\t{\n\t\t.type = IIO_ELECTRICALCONDUCTIVITY,\n\t\t.address = ATLAS_REG_EC_DATA,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 32,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\tATLAS_CONCENTRATION_CHANNEL(0, ATLAS_REG_TDS_DATA),\n\tATLAS_CONCENTRATION_CHANNEL(1, ATLAS_REG_PSS_DATA),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = ATLAS_REG_EC_TEMP_DATA,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.output = 1,\n\t\t.scan_index = -1\n\t},\n};\n\nstatic const struct iio_chan_spec atlas_orp_channels[] = {\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.address = ATLAS_REG_ORP_DATA,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 32,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n};\n\nstatic const struct iio_chan_spec atlas_do_channels[] = {\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.address = ATLAS_REG_DO_DATA,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 32,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = ATLAS_REG_DO_TEMP_DATA,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.output = 1,\n\t\t.scan_index = -1\n\t},\n};\n\nstatic const struct iio_chan_spec atlas_rtd_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = ATLAS_REG_RTD_DATA,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 32,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n};\n\nstatic int atlas_check_ph_calibration(struct atlas_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(data->regmap, ATLAS_REG_PH_CALIB_STATUS, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(val & ATLAS_REG_PH_CALIB_STATUS_MASK)) {\n\t\tdev_warn(dev, \"device has not been calibrated\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!(val & ATLAS_REG_PH_CALIB_STATUS_LOW))\n\t\tdev_warn(dev, \"device missing low point calibration\\n\");\n\n\tif (!(val & ATLAS_REG_PH_CALIB_STATUS_MID))\n\t\tdev_warn(dev, \"device missing mid point calibration\\n\");\n\n\tif (!(val & ATLAS_REG_PH_CALIB_STATUS_HIGH))\n\t\tdev_warn(dev, \"device missing high point calibration\\n\");\n\n\treturn 0;\n}\n\nstatic int atlas_check_ec_calibration(struct atlas_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tint ret;\n\tunsigned int val;\n\t__be16\trval;\n\n\tret = regmap_bulk_read(data->regmap, ATLAS_REG_EC_PROBE, &rval, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tval = be16_to_cpu(rval);\n\tdev_info(dev, \"probe set to K = %d.%.2d\", val / 100, val % 100);\n\n\tret = regmap_read(data->regmap, ATLAS_REG_EC_CALIB_STATUS, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(val & ATLAS_REG_EC_CALIB_STATUS_MASK)) {\n\t\tdev_warn(dev, \"device has not been calibrated\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!(val & ATLAS_REG_EC_CALIB_STATUS_DRY))\n\t\tdev_warn(dev, \"device missing dry point calibration\\n\");\n\n\tif (val & ATLAS_REG_EC_CALIB_STATUS_SINGLE) {\n\t\tdev_warn(dev, \"device using single point calibration\\n\");\n\t} else {\n\t\tif (!(val & ATLAS_REG_EC_CALIB_STATUS_LOW))\n\t\t\tdev_warn(dev, \"device missing low point calibration\\n\");\n\n\t\tif (!(val & ATLAS_REG_EC_CALIB_STATUS_HIGH))\n\t\t\tdev_warn(dev, \"device missing high point calibration\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int atlas_check_orp_calibration(struct atlas_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(data->regmap, ATLAS_REG_ORP_CALIB_STATUS, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!val)\n\t\tdev_warn(dev, \"device has not been calibrated\\n\");\n\n\treturn 0;\n}\n\nstatic int atlas_check_do_calibration(struct atlas_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(data->regmap, ATLAS_REG_DO_CALIB_STATUS, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(val & ATLAS_REG_DO_CALIB_STATUS_MASK)) {\n\t\tdev_warn(dev, \"device has not been calibrated\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!(val & ATLAS_REG_DO_CALIB_STATUS_PRESSURE))\n\t\tdev_warn(dev, \"device missing atmospheric pressure calibration\\n\");\n\n\tif (!(val & ATLAS_REG_DO_CALIB_STATUS_DO))\n\t\tdev_warn(dev, \"device missing dissolved oxygen calibration\\n\");\n\n\treturn 0;\n}\n\nstruct atlas_device {\n\tconst struct iio_chan_spec *channels;\n\tint num_channels;\n\tint data_reg;\n\n\tint (*calibration)(struct atlas_data *data);\n\tint delay;\n};\n\nstatic struct atlas_device atlas_devices[] = {\n\t[ATLAS_PH_SM] = {\n\t\t\t\t.channels = atlas_ph_channels,\n\t\t\t\t.num_channels = 3,\n\t\t\t\t.data_reg = ATLAS_REG_PH_DATA,\n\t\t\t\t.calibration = &atlas_check_ph_calibration,\n\t\t\t\t.delay = ATLAS_PH_INT_TIME_IN_MS,\n\t},\n\t[ATLAS_EC_SM] = {\n\t\t\t\t.channels = atlas_ec_channels,\n\t\t\t\t.num_channels = 5,\n\t\t\t\t.data_reg = ATLAS_REG_EC_DATA,\n\t\t\t\t.calibration = &atlas_check_ec_calibration,\n\t\t\t\t.delay = ATLAS_EC_INT_TIME_IN_MS,\n\t},\n\t[ATLAS_ORP_SM] = {\n\t\t\t\t.channels = atlas_orp_channels,\n\t\t\t\t.num_channels = 2,\n\t\t\t\t.data_reg = ATLAS_REG_ORP_DATA,\n\t\t\t\t.calibration = &atlas_check_orp_calibration,\n\t\t\t\t.delay = ATLAS_ORP_INT_TIME_IN_MS,\n\t},\n\t[ATLAS_DO_SM] = {\n\t\t\t\t.channels = atlas_do_channels,\n\t\t\t\t.num_channels = 3,\n\t\t\t\t.data_reg = ATLAS_REG_DO_DATA,\n\t\t\t\t.calibration = &atlas_check_do_calibration,\n\t\t\t\t.delay = ATLAS_DO_INT_TIME_IN_MS,\n\t},\n\t[ATLAS_RTD_SM] = {\n\t\t\t\t.channels = atlas_rtd_channels,\n\t\t\t\t.num_channels = 2,\n\t\t\t\t.data_reg = ATLAS_REG_RTD_DATA,\n\t\t\t\t.delay = ATLAS_RTD_INT_TIME_IN_MS,\n\t},\n};\n\nstatic int atlas_set_powermode(struct atlas_data *data, int on)\n{\n\treturn regmap_write(data->regmap, ATLAS_REG_PWR_CONTROL, on);\n}\n\nstatic int atlas_set_interrupt(struct atlas_data *data, bool state)\n{\n\tif (!data->interrupt_enabled)\n\t\treturn 0;\n\n\treturn regmap_update_bits(data->regmap, ATLAS_REG_INT_CONTROL,\n\t\t\t\t  ATLAS_REG_INT_CONTROL_EN,\n\t\t\t\t  state ? ATLAS_REG_INT_CONTROL_EN : 0);\n}\n\nstatic int atlas_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct atlas_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(&data->client->dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn atlas_set_interrupt(data, true);\n}\n\nstatic int atlas_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct atlas_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = atlas_set_interrupt(data, false);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_mark_last_busy(&data->client->dev);\n\tret = pm_runtime_put_autosuspend(&data->client->dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops atlas_buffer_setup_ops = {\n\t.postenable = atlas_buffer_postenable,\n\t.predisable = atlas_buffer_predisable,\n};\n\nstatic void atlas_work_handler(struct irq_work *work)\n{\n\tstruct atlas_data *data = container_of(work, struct atlas_data, work);\n\n\tiio_trigger_poll(data->trig);\n}\n\nstatic irqreturn_t atlas_trigger_handler(int irq, void *private)\n{\n\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct atlas_data *data = iio_priv(indio_dev);\n\tint channels = atlas_buffer_num_channels(data->chip->channels);\n\tint ret;\n\n\tret = regmap_bulk_read(data->regmap, data->chip->data_reg,\n\t\t\t      &data->buffer, sizeof(__be32) * channels);\n\n\tif (!ret)\n\t\tiio_push_to_buffers_with_timestamp(indio_dev, data->buffer,\n\t\t\t\tiio_get_time_ns(indio_dev));\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t atlas_interrupt_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct atlas_data *data = iio_priv(indio_dev);\n\n\tirq_work_queue(&data->work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int atlas_read_measurement(struct atlas_data *data, int reg, __be32 *val)\n{\n\tstruct device *dev = &data->client->dev;\n\tint suspended = pm_runtime_suspended(dev);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (suspended)\n\t\tmsleep(data->chip->delay);\n\n\tret = regmap_bulk_read(data->regmap, reg, val, sizeof(*val));\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nstatic int atlas_read_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t  int *val, int *val2, long mask)\n{\n\tstruct atlas_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\tcase IIO_CHAN_INFO_RAW: {\n\t\tint ret;\n\t\t__be32 reg;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\tret = regmap_bulk_read(data->regmap, chan->address,\n\t\t\t\t\t       &reg, sizeof(reg));\n\t\t\tbreak;\n\t\tcase IIO_PH:\n\t\tcase IIO_CONCENTRATION:\n\t\tcase IIO_ELECTRICALCONDUCTIVITY:\n\t\tcase IIO_VOLTAGE:\n\t\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = atlas_read_measurement(data, chan->address, &reg);\n\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tif (!ret) {\n\t\t\t*val = be32_to_cpu(reg);\n\t\t\tret = IIO_VAL_INT;\n\t\t}\n\t\treturn ret;\n\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t*val = 10;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_PH:\n\t\t\t*val = 1;  \n\t\t\t*val2 = 1000;\n\t\t\tbreak;\n\t\tcase IIO_ELECTRICALCONDUCTIVITY:\n\t\t\t*val = 1;  \n\t\t\t*val2 = 100000;\n\t\t\tbreak;\n\t\tcase IIO_CONCENTRATION:\n\t\t\t*val = 0;  \n\t\t\t*val2 = 1000;\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tcase IIO_VOLTAGE:\n\t\t\t*val = 1;  \n\t\t\t*val2 = 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn IIO_VAL_FRACTIONAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int atlas_write_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int val, int val2, long mask)\n{\n\tstruct atlas_data *data = iio_priv(indio_dev);\n\t__be32 reg = cpu_to_be32(val / 10);\n\n\tif (val2 != 0 || val < 0 || val > 20000)\n\t\treturn -EINVAL;\n\n\tif (mask != IIO_CHAN_INFO_RAW || chan->type != IIO_TEMP)\n\t\treturn -EINVAL;\n\n\treturn regmap_bulk_write(data->regmap, chan->address,\n\t\t\t\t &reg, sizeof(reg));\n}\n\nstatic const struct iio_info atlas_info = {\n\t.read_raw = atlas_read_raw,\n\t.write_raw = atlas_write_raw,\n};\n\nstatic const struct i2c_device_id atlas_id[] = {\n\t{ \"atlas-ph-sm\", ATLAS_PH_SM },\n\t{ \"atlas-ec-sm\", ATLAS_EC_SM },\n\t{ \"atlas-orp-sm\", ATLAS_ORP_SM },\n\t{ \"atlas-do-sm\", ATLAS_DO_SM },\n\t{ \"atlas-rtd-sm\", ATLAS_RTD_SM },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, atlas_id);\n\nstatic const struct of_device_id atlas_dt_ids[] = {\n\t{ .compatible = \"atlas,ph-sm\", .data = (void *)ATLAS_PH_SM, },\n\t{ .compatible = \"atlas,ec-sm\", .data = (void *)ATLAS_EC_SM, },\n\t{ .compatible = \"atlas,orp-sm\", .data = (void *)ATLAS_ORP_SM, },\n\t{ .compatible = \"atlas,do-sm\", .data = (void *)ATLAS_DO_SM, },\n\t{ .compatible = \"atlas,rtd-sm\", .data = (void *)ATLAS_RTD_SM, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, atlas_dt_ids);\n\nstatic int atlas_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct atlas_data *data;\n\tstruct atlas_device *chip;\n\tstruct iio_trigger *trig;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tif (!dev_fwnode(&client->dev))\n\t\tchip = &atlas_devices[id->driver_data];\n\telse\n\t\tchip = &atlas_devices[(unsigned long)device_get_match_data(&client->dev)];\n\n\tindio_dev->info = &atlas_info;\n\tindio_dev->name = ATLAS_DRV_NAME;\n\tindio_dev->channels = chip->channels;\n\tindio_dev->num_channels = chip->num_channels;\n\tindio_dev->modes = INDIO_BUFFER_SOFTWARE | INDIO_DIRECT_MODE;\n\n\ttrig = devm_iio_trigger_alloc(&client->dev, \"%s-dev%d\",\n\t\t\t\t      indio_dev->name, iio_device_id(indio_dev));\n\n\tif (!trig)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\tdata->trig = trig;\n\tdata->chip = chip;\n\tiio_trigger_set_drvdata(trig, indio_dev);\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\tdata->regmap = devm_regmap_init_i2c(client, &atlas_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(&client->dev, \"regmap initialization failed\\n\");\n\t\treturn PTR_ERR(data->regmap);\n\t}\n\n\tret = pm_runtime_set_active(&client->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = chip->calibration(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iio_trigger_register(trig);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to register trigger\\n\");\n\t\treturn ret;\n\t}\n\n\tret = iio_triggered_buffer_setup(indio_dev, &iio_pollfunc_store_time,\n\t\t&atlas_trigger_handler, &atlas_buffer_setup_ops);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"cannot setup iio trigger\\n\");\n\t\tgoto unregister_trigger;\n\t}\n\n\tinit_irq_work(&data->work, atlas_work_handler);\n\n\tif (client->irq > 0) {\n\t\t \n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\tNULL, atlas_interrupt_handler,\n\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\"atlas_irq\",\n\t\t\t\tindio_dev);\n\n\t\tif (ret)\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t\"request irq (%d) failed\\n\", client->irq);\n\t\telse\n\t\t\tdata->interrupt_enabled = 1;\n\t}\n\n\tret = atlas_set_powermode(data, 1);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"cannot power device on\");\n\t\tgoto unregister_buffer;\n\t}\n\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev, 2500);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"unable to register device\\n\");\n\t\tgoto unregister_pm;\n\t}\n\n\treturn 0;\n\nunregister_pm:\n\tpm_runtime_disable(&client->dev);\n\tatlas_set_powermode(data, 0);\n\nunregister_buffer:\n\tiio_triggered_buffer_cleanup(indio_dev);\n\nunregister_trigger:\n\tiio_trigger_unregister(data->trig);\n\n\treturn ret;\n}\n\nstatic void atlas_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct atlas_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tiio_trigger_unregister(data->trig);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tret = atlas_set_powermode(data, 0);\n\tif (ret)\n\t\tdev_err(&client->dev, \"Failed to power down device (%pe)\\n\",\n\t\t\tERR_PTR(ret));\n}\n\nstatic int atlas_runtime_suspend(struct device *dev)\n{\n\tstruct atlas_data *data =\n\t\t     iio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\n\treturn atlas_set_powermode(data, 0);\n}\n\nstatic int atlas_runtime_resume(struct device *dev)\n{\n\tstruct atlas_data *data =\n\t\t     iio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\n\treturn atlas_set_powermode(data, 1);\n}\n\nstatic const struct dev_pm_ops atlas_pm_ops = {\n\tRUNTIME_PM_OPS(atlas_runtime_suspend, atlas_runtime_resume, NULL)\n};\n\nstatic struct i2c_driver atlas_driver = {\n\t.driver = {\n\t\t.name\t= ATLAS_DRV_NAME,\n\t\t.of_match_table\t= atlas_dt_ids,\n\t\t.pm\t= pm_ptr(&atlas_pm_ops),\n\t},\n\t.probe\t\t= atlas_probe,\n\t.remove\t\t= atlas_remove,\n\t.id_table\t= atlas_id,\n};\nmodule_i2c_driver(atlas_driver);\n\nMODULE_AUTHOR(\"Matt Ranostay <matt.ranostay@konsulko.com>\");\nMODULE_DESCRIPTION(\"Atlas Scientific SM sensors\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}