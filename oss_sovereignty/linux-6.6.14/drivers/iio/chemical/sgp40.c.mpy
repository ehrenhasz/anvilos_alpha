{
  "module_name": "sgp40.c",
  "hash_id": "37a310618d074933babb1ec8d807c74b3dffd20cdf0bda6d73b5aa6fdc050b59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/sgp40.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/crc8.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n\n \n#define SGP40_CALC_POWER\t14\n\n#define SGP40_CRC8_POLYNOMIAL\t0x31\n#define SGP40_CRC8_INIT\t\t0xff\n\nDECLARE_CRC8_TABLE(sgp40_crc8_table);\n\nstruct sgp40_data {\n\tstruct device\t\t*dev;\n\tstruct i2c_client\t*client;\n\tint\t\t\trht;\n\tint\t\t\ttemp;\n\tint\t\t\tres_calibbias;\n\t \n\tstruct mutex\t\tlock;\n};\n\nstruct sgp40_tg_measure {\n\tu8\tcommand[2];\n\t__be16\trht_ticks;\n\tu8\trht_crc;\n\t__be16\ttemp_ticks;\n\tu8\ttemp_crc;\n} __packed;\n\nstruct sgp40_tg_result {\n\t__be16\tres_ticks;\n\tu8\tres_crc;\n} __packed;\n\nstatic const struct iio_chan_spec sgp40_channels[] = {\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_VOC,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t},\n\t{\n\t\t.type = IIO_RESISTANCE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.output = 1,\n\t},\n\t{\n\t\t.type = IIO_HUMIDITYRELATIVE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.output = 1,\n\t},\n};\n\n \n\nstatic u32 sgp40_exp(int exp, u32 power, u32 rounds)\n{\n        u32 x, y, xp;\n        u32 factorial, divider, xmax;\n        int sign = 1;\n\tint i;\n\n        if (exp == 0)\n                return 1 << power;\n        else if (exp < 0) {\n                sign = -1;\n                exp *= -1;\n        }\n\n        xmax = 0x7FFFFFFF / exp;\n        x = exp;\n        xp = 1;\n        factorial = 1;\n        y = 1 << power;\n        divider = 0;\n\n        for (i = 1; i <= rounds; i++) {\n                xp *= x;\n                factorial *= i;\n                y += (xp >> divider) / factorial;\n                divider += power;\n                 \n                if (xp >= xmax) {\n                        xp >>= power;\n                        divider -= power;\n                }\n        }\n\n        if (sign == -1)\n                return (1 << (power * 2)) / y;\n        else\n                return y;\n}\n\nstatic int sgp40_calc_voc(struct sgp40_data *data, u16 resistance_raw, int *voc)\n{\n\tint x;\n\tu32 exp = 0;\n\n\t \n\tmutex_lock(&data->lock);\n\tx = ((int)resistance_raw - data->res_calibbias) * 106;\n\tmutex_unlock(&data->lock);\n\n\t \n\texp = sgp40_exp(x, SGP40_CALC_POWER, 18);\n\t*voc = 500 * ((1 << (SGP40_CALC_POWER * 2)) / ((1<<SGP40_CALC_POWER) + exp));\n\n\tdev_dbg(data->dev, \"raw: %d res_calibbias: %d x: %d exp: %d voc: %d\\n\",\n\t\t\t\tresistance_raw, data->res_calibbias, x, exp, *voc);\n\n\treturn 0;\n}\n\nstatic int sgp40_measure_resistance_raw(struct sgp40_data *data, u16 *resistance_raw)\n{\n\tint ret;\n\tstruct i2c_client *client = data->client;\n\tu32 ticks;\n\tu16 ticks16;\n\tu8 crc;\n\tstruct sgp40_tg_measure tg = {.command = {0x26, 0x0F}};\n\tstruct sgp40_tg_result tgres;\n\n\tmutex_lock(&data->lock);\n\n\tticks = (data->rht / 10) * 65535 / 10000;\n\tticks16 = (u16)clamp(ticks, 0u, 65535u);  \n\ttg.rht_ticks = cpu_to_be16(ticks16);\n\ttg.rht_crc = crc8(sgp40_crc8_table, (u8 *)&tg.rht_ticks, 2, SGP40_CRC8_INIT);\n\n\tticks = ((data->temp + 45000) / 10 ) * 65535 / 17500;\n\tticks16 = (u16)clamp(ticks, 0u, 65535u);  \n\ttg.temp_ticks = cpu_to_be16(ticks16);\n\ttg.temp_crc = crc8(sgp40_crc8_table, (u8 *)&tg.temp_ticks, 2, SGP40_CRC8_INIT);\n\n\tmutex_unlock(&data->lock);\n\n\tret = i2c_master_send(client, (const char *)&tg, sizeof(tg));\n\tif (ret != sizeof(tg)) {\n\t\tdev_warn(data->dev, \"i2c_master_send ret: %d sizeof: %zu\\n\", ret, sizeof(tg));\n\t\treturn -EIO;\n\t}\n\tmsleep(30);\n\n\tret = i2c_master_recv(client, (u8 *)&tgres, sizeof(tgres));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(tgres)) {\n\t\tdev_warn(data->dev, \"i2c_master_recv ret: %d sizeof: %zu\\n\", ret, sizeof(tgres));\n\t\treturn -EIO;\n\t}\n\n\tcrc = crc8(sgp40_crc8_table, (u8 *)&tgres.res_ticks, 2, SGP40_CRC8_INIT);\n\tif (crc != tgres.res_crc) {\n\t\tdev_err(data->dev, \"CRC error while measure-raw\\n\");\n\t\treturn -EIO;\n\t}\n\n\t*resistance_raw = be16_to_cpu(tgres.res_ticks);\n\n\treturn 0;\n}\n\nstatic int sgp40_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan, int *val,\n\t\t\tint *val2, long mask)\n{\n\tstruct sgp40_data *data = iio_priv(indio_dev);\n\tint ret, voc;\n\tu16 resistance_raw;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_RESISTANCE:\n\t\t\tret = sgp40_measure_resistance_raw(data, &resistance_raw);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*val = resistance_raw;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_TEMP:\n\t\t\tmutex_lock(&data->lock);\n\t\t\t*val = data->temp;\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_HUMIDITYRELATIVE:\n\t\t\tmutex_lock(&data->lock);\n\t\t\t*val = data->rht;\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tret = sgp40_measure_resistance_raw(data, &resistance_raw);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = sgp40_calc_voc(data, resistance_raw, &voc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = voc / (1 << SGP40_CALC_POWER);\n\t\t \n\t\t*val2 = ((voc % (1 << SGP40_CALC_POWER)) * 244) / (1 << (SGP40_CALC_POWER - 12));\n\t\tdev_dbg(data->dev, \"voc: %d val: %d.%06d\\n\", voc, *val, *val2);\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tmutex_lock(&data->lock);\n\t\t*val = data->res_calibbias;\n\t\tmutex_unlock(&data->lock);\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sgp40_write_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan, int val,\n\t\t\tint val2, long mask)\n{\n\tstruct sgp40_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\tif ((val < -45000) || (val > 130000))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmutex_lock(&data->lock);\n\t\t\tdata->temp = val;\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn 0;\n\t\tcase IIO_HUMIDITYRELATIVE:\n\t\t\tif ((val < 0) || (val > 100000))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmutex_lock(&data->lock);\n\t\t\tdata->rht = val;\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif ((val < 20000) || (val > 52768))\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&data->lock);\n\t\tdata->res_calibbias = val;\n\t\tmutex_unlock(&data->lock);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info sgp40_info = {\n\t.read_raw\t= sgp40_read_raw,\n\t.write_raw\t= sgp40_write_raw,\n};\n\nstatic int sgp40_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct sgp40_data *data;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\tdata->dev = dev;\n\n\tcrc8_populate_msb(sgp40_crc8_table, SGP40_CRC8_POLYNOMIAL);\n\n\tmutex_init(&data->lock);\n\n\t \n\tdata->rht = 50000;\t\t \n\tdata->temp = 25000;\t\t \n\tdata->res_calibbias = 30000;\t \n\n\tindio_dev->info = &sgp40_info;\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = sgp40_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(sgp40_channels);\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret)\n\t\tdev_err(dev, \"failed to register iio device\\n\");\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id sgp40_id[] = {\n\t{ \"sgp40\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, sgp40_id);\n\nstatic const struct of_device_id sgp40_dt_ids[] = {\n\t{ .compatible = \"sensirion,sgp40\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, sgp40_dt_ids);\n\nstatic struct i2c_driver sgp40_driver = {\n\t.driver = {\n\t\t.name = \"sgp40\",\n\t\t.of_match_table = sgp40_dt_ids,\n\t},\n\t.probe = sgp40_probe,\n\t.id_table = sgp40_id,\n};\nmodule_i2c_driver(sgp40_driver);\n\nMODULE_AUTHOR(\"Andreas Klinger <ak@it-klinger.de>\");\nMODULE_DESCRIPTION(\"Sensirion SGP40 gas sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}