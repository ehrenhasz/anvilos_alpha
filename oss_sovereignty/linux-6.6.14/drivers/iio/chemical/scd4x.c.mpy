{
  "module_name": "scd4x.c",
  "hash_id": "821fd7dfbb90af632de9e551b3748866d8817bc9e1fcf4a75d3ef68efb3b6f8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/scd4x.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/crc8.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/types.h>\n#include <linux/kernel.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n\n#define SCD4X_CRC8_POLYNOMIAL 0x31\n#define SCD4X_TIMEOUT_ERR 1000\n#define SCD4X_READ_BUF_SIZE 9\n#define SCD4X_COMMAND_BUF_SIZE 2\n#define SCD4X_WRITE_BUF_SIZE 5\n#define SCD4X_FRC_MIN_PPM 0\n#define SCD4X_FRC_MAX_PPM 2000\n#define SCD4X_PRESSURE_COMP_MIN_MBAR 700\n#define SCD4X_PRESSURE_COMP_MAX_MBAR 1200\n#define SCD4X_READY_MASK 0x01\n\n \nenum scd4x_cmd {\n\tCMD_START_MEAS          = 0x21b1,\n\tCMD_READ_MEAS           = 0xec05,\n\tCMD_STOP_MEAS           = 0x3f86,\n\tCMD_SET_TEMP_OFFSET     = 0x241d,\n\tCMD_GET_TEMP_OFFSET     = 0x2318,\n\tCMD_SET_AMB_PRESSURE\t= 0xe000,\n\tCMD_GET_AMB_PRESSURE\t= 0xe000,\n\tCMD_FRC                 = 0x362f,\n\tCMD_SET_ASC             = 0x2416,\n\tCMD_GET_ASC             = 0x2313,\n\tCMD_GET_DATA_READY      = 0xe4b8,\n};\n\nenum scd4x_channel_idx {\n\tSCD4X_CO2,\n\tSCD4X_TEMP,\n\tSCD4X_HR,\n};\n\nstruct scd4x_state {\n\tstruct i2c_client *client;\n\t \n\tstruct mutex lock;\n\tstruct regulator *vdd;\n};\n\nDECLARE_CRC8_TABLE(scd4x_crc8_table);\n\nstatic int scd4x_i2c_xfer(struct scd4x_state *state, char *txbuf, int txsize,\n\t\t\t\tchar *rxbuf, int rxsize)\n{\n\tstruct i2c_client *client = state->client;\n\tint ret;\n\n\tret = i2c_master_send(client, txbuf, txsize);\n\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != txsize)\n\t\treturn -EIO;\n\n\tif (rxsize == 0)\n\t\treturn 0;\n\n\tret = i2c_master_recv(client, rxbuf, rxsize);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != rxsize)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int scd4x_send_command(struct scd4x_state *state, enum scd4x_cmd cmd)\n{\n\tchar buf[SCD4X_COMMAND_BUF_SIZE];\n\tint ret;\n\n\t \n\tif ((cmd != CMD_STOP_MEAS) && (cmd != CMD_START_MEAS)) {\n\n\t\tret = scd4x_send_command(state, CMD_STOP_MEAS);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tmsleep_interruptible(500);\n\t}\n\n\tput_unaligned_be16(cmd, buf);\n\tret = scd4x_i2c_xfer(state, buf, 2, buf, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((cmd != CMD_STOP_MEAS) && (cmd != CMD_START_MEAS)) {\n\t\tret = scd4x_send_command(state, CMD_START_MEAS);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int scd4x_read(struct scd4x_state *state, enum scd4x_cmd cmd,\n\t\t\tvoid *response, int response_sz)\n{\n\tstruct i2c_client *client = state->client;\n\tchar buf[SCD4X_READ_BUF_SIZE];\n\tchar *rsp = response;\n\tint i, ret;\n\tchar crc;\n\n\t \n\tif ((cmd != CMD_GET_DATA_READY) && (cmd != CMD_READ_MEAS) &&\n\t    (cmd != CMD_GET_AMB_PRESSURE)) {\n\t\tret = scd4x_send_command(state, CMD_STOP_MEAS);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tmsleep_interruptible(500);\n\t}\n\n\t \n\tresponse_sz += response_sz / 2;\n\n\tput_unaligned_be16(cmd, buf);\n\tret = scd4x_i2c_xfer(state, buf, 2, buf, response_sz);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < response_sz; i += 3) {\n\t\tcrc = crc8(scd4x_crc8_table, buf + i, 2, CRC8_INIT_VALUE);\n\t\tif (crc != buf[i + 2]) {\n\t\t\tdev_err(&client->dev, \"CRC error\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t*rsp++ = buf[i];\n\t\t*rsp++ = buf[i + 1];\n\t}\n\n\t \n\tif ((cmd != CMD_GET_DATA_READY) && (cmd != CMD_READ_MEAS) &&\n\t    (cmd != CMD_GET_AMB_PRESSURE)) {\n\t\tret = scd4x_send_command(state, CMD_START_MEAS);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int scd4x_write(struct scd4x_state *state, enum scd4x_cmd cmd, uint16_t arg)\n{\n\tchar buf[SCD4X_WRITE_BUF_SIZE];\n\tint ret;\n\tchar crc;\n\n\tput_unaligned_be16(cmd, buf);\n\tput_unaligned_be16(arg, buf + 2);\n\n\tcrc = crc8(scd4x_crc8_table, buf + 2, 2, CRC8_INIT_VALUE);\n\tbuf[4] = crc;\n\n\t \n\tif (cmd != CMD_SET_AMB_PRESSURE) {\n\t\tret = scd4x_send_command(state, CMD_STOP_MEAS);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tmsleep_interruptible(500);\n\n\tret = scd4x_i2c_xfer(state, buf, SCD4X_WRITE_BUF_SIZE, buf, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif ((cmd != CMD_FRC) && (cmd != CMD_SET_AMB_PRESSURE)) {\n\t\tret = scd4x_send_command(state, CMD_START_MEAS);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int scd4x_write_and_fetch(struct scd4x_state *state, enum scd4x_cmd cmd,\n\t\t\t\tuint16_t arg, void *response, int response_sz)\n{\n\tstruct i2c_client *client = state->client;\n\tchar buf[SCD4X_READ_BUF_SIZE];\n\tchar *rsp = response;\n\tint i, ret;\n\tchar crc;\n\n\tret = scd4x_write(state, CMD_FRC, arg);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tmsleep_interruptible(400);\n\n\t \n\tresponse_sz += response_sz / 2;\n\n\tret = i2c_master_recv(client, buf, response_sz);\n\tif (ret < 0)\n\t\tgoto err;\n\tif (ret != response_sz) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < response_sz; i += 3) {\n\t\tcrc = crc8(scd4x_crc8_table, buf + i, 2, CRC8_INIT_VALUE);\n\t\tif (crc != buf[i + 2]) {\n\t\t\tdev_err(&client->dev, \"CRC error\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\t*rsp++ = buf[i];\n\t\t*rsp++ = buf[i + 1];\n\t}\n\n\treturn scd4x_send_command(state, CMD_START_MEAS);\n\nerr:\n\t \n\tscd4x_send_command(state, CMD_START_MEAS);\n\n\treturn ret;\n}\n\nstatic int scd4x_read_meas(struct scd4x_state *state, uint16_t *meas)\n{\n\tint i, ret;\n\t__be16 buf[3];\n\n\tret = scd4x_read(state, CMD_READ_MEAS, buf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(buf); i++)\n\t\tmeas[i] = be16_to_cpu(buf[i]);\n\n\treturn 0;\n}\n\nstatic int scd4x_wait_meas_poll(struct scd4x_state *state)\n{\n\tstruct i2c_client *client = state->client;\n\tint tries = 6;\n\tint ret;\n\n\tdo {\n\t\t__be16 bval;\n\t\tuint16_t val;\n\n\t\tret = scd4x_read(state, CMD_GET_DATA_READY, &bval, sizeof(bval));\n\t\tif (ret)\n\t\t\treturn -EIO;\n\t\tval = be16_to_cpu(bval);\n\n\t\t \n\t\tif (val & 0x7FF)\n\t\t\treturn 0;\n\n\t\tmsleep_interruptible(1000);\n\t} while (--tries);\n\n\t \n\tret = scd4x_send_command(state, CMD_START_MEAS);\n\tif (ret)\n\t\tdev_err(&client->dev, \"failed to start measurement: %d\\n\", ret);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int scd4x_read_poll(struct scd4x_state *state, uint16_t *buf)\n{\n\tint ret;\n\n\tret = scd4x_wait_meas_poll(state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn scd4x_read_meas(state, buf);\n}\n\nstatic int scd4x_read_channel(struct scd4x_state *state, int chan)\n{\n\tint ret;\n\tuint16_t buf[3];\n\n\tret = scd4x_read_poll(state, buf);\n\tif (ret)\n\t\treturn ret;\n\n\treturn buf[chan];\n}\n\nstatic int scd4x_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan, int *val,\n\t\t\tint *val2, long mask)\n{\n\tstruct scd4x_state *state = iio_priv(indio_dev);\n\tint ret;\n\t__be16 tmp;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->output) {\n\t\t\tmutex_lock(&state->lock);\n\t\t\tret = scd4x_read(state, CMD_GET_AMB_PRESSURE, &tmp, sizeof(tmp));\n\t\t\tmutex_unlock(&state->lock);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*val = be16_to_cpu(tmp);\n\t\t\treturn IIO_VAL_INT;\n\t\t}\n\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&state->lock);\n\t\tret = scd4x_read_channel(state, chan->address);\n\t\tmutex_unlock(&state->lock);\n\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type == IIO_CONCENTRATION) {\n\t\t\t*val = 0;\n\t\t\t*val2 = 100;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t} else if (chan->type == IIO_TEMP) {\n\t\t\t*val = 175000;\n\t\t\t*val2 = 65536;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\t} else if (chan->type == IIO_HUMIDITYRELATIVE) {\n\t\t\t*val = 100000;\n\t\t\t*val2 = 65536;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\t}\n\t\treturn -EINVAL;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = -16852;\n\t\t*val2 = 114286;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tmutex_lock(&state->lock);\n\t\tret = scd4x_read(state, CMD_GET_TEMP_OFFSET, &tmp, sizeof(tmp));\n\t\tmutex_unlock(&state->lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = be16_to_cpu(tmp);\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const int scd4x_pressure_calibbias_available[] = {\n\tSCD4X_PRESSURE_COMP_MIN_MBAR, 1, SCD4X_PRESSURE_COMP_MAX_MBAR,\n};\n\nstatic int scd4x_read_avail(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,\n\t\t\t    const int **vals, int *type, int *length, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*vals = scd4x_pressure_calibbias_available;\n\t\t*type = IIO_VAL_INT;\n\n\t\treturn IIO_AVAIL_RANGE;\n\t}\n\n\treturn -EINVAL;\n}\n\n\nstatic int scd4x_write_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,\n\t\t\t\tint val, int val2, long mask)\n{\n\tstruct scd4x_state *state = iio_priv(indio_dev);\n\tint ret = 0;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tmutex_lock(&state->lock);\n\t\tret = scd4x_write(state, CMD_SET_TEMP_OFFSET, val);\n\t\tmutex_unlock(&state->lock);\n\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PRESSURE:\n\t\t\tif (val < SCD4X_PRESSURE_COMP_MIN_MBAR ||\n\t\t\t    val > SCD4X_PRESSURE_COMP_MAX_MBAR)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmutex_lock(&state->lock);\n\t\t\tret = scd4x_write(state, CMD_SET_AMB_PRESSURE, val);\n\t\t\tmutex_unlock(&state->lock);\n\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t calibration_auto_enable_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct scd4x_state *state = iio_priv(indio_dev);\n\tint ret;\n\t__be16 bval;\n\tu16 val;\n\n\tmutex_lock(&state->lock);\n\tret = scd4x_read(state, CMD_GET_ASC, &bval, sizeof(bval));\n\tmutex_unlock(&state->lock);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read automatic calibration\");\n\t\treturn ret;\n\t}\n\n\tval = (be16_to_cpu(bval) & SCD4X_READY_MASK) ? 1 : 0;\n\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t calibration_auto_enable_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct scd4x_state *state = iio_priv(indio_dev);\n\tbool val;\n\tint ret;\n\tuint16_t value;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tvalue = val;\n\n\tmutex_lock(&state->lock);\n\tret = scd4x_write(state, CMD_SET_ASC, value);\n\tmutex_unlock(&state->lock);\n\tif (ret)\n\t\tdev_err(dev, \"failed to set automatic calibration\");\n\n\treturn ret ?: len;\n}\n\nstatic ssize_t calibration_forced_value_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct scd4x_state *state = iio_priv(indio_dev);\n\tuint16_t val, arg;\n\tint ret;\n\n\tret = kstrtou16(buf, 0, &arg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (arg < SCD4X_FRC_MIN_PPM || arg > SCD4X_FRC_MAX_PPM)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->lock);\n\tret = scd4x_write_and_fetch(state, CMD_FRC, arg, &val, sizeof(val));\n\tmutex_unlock(&state->lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (val == 0xff) {\n\t\tdev_err(dev, \"forced calibration has failed\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR_RW(calibration_auto_enable, 0);\nstatic IIO_DEVICE_ATTR_WO(calibration_forced_value, 0);\n\nstatic IIO_CONST_ATTR(calibration_forced_value_available,\n\t       __stringify([SCD4X_FRC_MIN_PPM 1 SCD4X_FRC_MAX_PPM]));\n\nstatic struct attribute *scd4x_attrs[] = {\n\t&iio_dev_attr_calibration_auto_enable.dev_attr.attr,\n\t&iio_dev_attr_calibration_forced_value.dev_attr.attr,\n\t&iio_const_attr_calibration_forced_value_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group scd4x_attr_group = {\n\t.attrs = scd4x_attrs,\n};\n\nstatic const struct iio_info scd4x_info = {\n\t.attrs = &scd4x_attr_group,\n\t.read_raw = scd4x_read_raw,\n\t.write_raw = scd4x_write_raw,\n\t.read_avail = scd4x_read_avail,\n};\n\nstatic const struct iio_chan_spec scd4x_channels[] = {\n\t{\n\t\t \n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_RAW),\n\t\t.output = 1,\n\t\t.scan_index = -1,\n\t},\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_CO2,\n\t\t.modified = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = SCD4X_CO2,\n\t\t.scan_index = SCD4X_CO2,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t\tBIT(IIO_CHAN_INFO_OFFSET) |\n\t\t\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\n\t\t.address = SCD4X_TEMP,\n\t\t.scan_index = SCD4X_TEMP,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_HUMIDITYRELATIVE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = SCD4X_HR,\n\t\t.scan_index = SCD4X_HR,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n};\n\nstatic int scd4x_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct scd4x_state *state  = iio_priv(indio_dev);\n\tint ret;\n\n\tret = scd4x_send_command(state, CMD_STOP_MEAS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regulator_disable(state->vdd);\n}\n\nstatic int scd4x_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct scd4x_state *state = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_enable(state->vdd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn scd4x_send_command(state, CMD_START_MEAS);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(scd4x_pm_ops, scd4x_suspend, scd4x_resume);\n\nstatic void scd4x_stop_meas(void *state)\n{\n\tscd4x_send_command(state, CMD_STOP_MEAS);\n}\n\nstatic void scd4x_disable_regulator(void *data)\n{\n\tstruct scd4x_state *state = data;\n\n\tregulator_disable(state->vdd);\n}\n\nstatic irqreturn_t scd4x_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct scd4x_state *state = iio_priv(indio_dev);\n\tstruct {\n\t\tuint16_t data[3];\n\t\tint64_t ts __aligned(8);\n\t} scan;\n\tint ret;\n\n\tmemset(&scan, 0, sizeof(scan));\n\tmutex_lock(&state->lock);\n\tret = scd4x_read_poll(state, scan.data);\n\tmutex_unlock(&state->lock);\n\tif (ret)\n\t\tgoto out;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &scan, iio_get_time_ns(indio_dev));\nout:\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\nstatic int scd4x_probe(struct i2c_client *client)\n{\n\tstatic const unsigned long scd4x_scan_masks[] = { 0x07, 0x00 };\n\tstruct device *dev = &client->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct scd4x_state *state;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*state));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tstate = iio_priv(indio_dev);\n\tmutex_init(&state->lock);\n\tstate->client = client;\n\tcrc8_populate_msb(scd4x_crc8_table, SCD4X_CRC8_POLYNOMIAL);\n\n\tindio_dev->info = &scd4x_info;\n\tindio_dev->name = client->name;\n\tindio_dev->channels = scd4x_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(scd4x_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->available_scan_masks = scd4x_scan_masks;\n\n\tstate->vdd = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(state->vdd))\n\t\treturn dev_err_probe(dev, PTR_ERR(state->vdd), \"failed to get regulator\\n\");\n\n\tret = regulator_enable(state->vdd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, scd4x_disable_regulator, state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = scd4x_send_command(state, CMD_STOP_MEAS);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to stop measurement: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmsleep_interruptible(500);\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL, scd4x_trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = scd4x_send_command(state, CMD_START_MEAS);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to start measurement: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev, scd4x_stop_meas, state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id scd4x_dt_ids[] = {\n\t{ .compatible = \"sensirion,scd40\" },\n\t{ .compatible = \"sensirion,scd41\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, scd4x_dt_ids);\n\nstatic struct i2c_driver scd4x_i2c_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = scd4x_dt_ids,\n\t\t.pm = pm_sleep_ptr(&scd4x_pm_ops),\n\t},\n\t.probe = scd4x_probe,\n};\nmodule_i2c_driver(scd4x_i2c_driver);\n\nMODULE_AUTHOR(\"Roan van Dijk <roan@protonic.nl>\");\nMODULE_DESCRIPTION(\"Sensirion SCD4X carbon dioxide sensor core driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}