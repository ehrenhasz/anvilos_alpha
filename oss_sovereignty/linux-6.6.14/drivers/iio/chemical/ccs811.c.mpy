{
  "module_name": "ccs811.c",
  "hash_id": "b4c2d5eeec094d178dea25cede295ccb0207e38c1462d48af4d7dc0919f82edd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/ccs811.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/module.h>\n\n#define CCS811_STATUS\t\t0x00\n#define CCS811_MEAS_MODE\t0x01\n#define CCS811_ALG_RESULT_DATA\t0x02\n#define CCS811_RAW_DATA\t\t0x03\n#define CCS811_HW_ID\t\t0x20\n#define CCS811_HW_ID_VALUE\t0x81\n#define CCS811_HW_VERSION\t0x21\n#define CCS811_HW_VERSION_VALUE\t0x10\n#define CCS811_HW_VERSION_MASK\t0xF0\n#define CCS811_ERR\t\t0xE0\n \n#define CCS811_APP_START\t0xF4\n#define CCS811_SW_RESET\t\t0xFF\n\n \n#define CCS811_STATUS_ERROR\t\tBIT(0)\n#define CCS811_STATUS_DATA_READY\tBIT(3)\n#define CCS811_STATUS_APP_VALID_MASK\tBIT(4)\n#define CCS811_STATUS_APP_VALID_LOADED\tBIT(4)\n \n#define CCS811_STATUS_FW_MODE_MASK\tBIT(7)\n#define CCS811_STATUS_FW_MODE_APPLICATION\tBIT(7)\n\n \n#define CCS811_MODE_IDLE\t0x00\n#define CCS811_MODE_IAQ_1SEC\t0x10\n#define CCS811_MODE_IAQ_10SEC\t0x20\n#define CCS811_MODE_IAQ_60SEC\t0x30\n#define CCS811_MODE_RAW_DATA\t0x40\n\n#define CCS811_MEAS_MODE_INTERRUPT\tBIT(3)\n\n#define CCS811_VOLTAGE_MASK\t0x3FF\n\nstruct ccs811_reading {\n\t__be16 co2;\n\t__be16 voc;\n\tu8 status;\n\tu8 error;\n\t__be16 raw_data;\n} __attribute__((__packed__));\n\nstruct ccs811_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;  \n\tstruct ccs811_reading buffer;\n\tstruct iio_trigger *drdy_trig;\n\tstruct gpio_desc *wakeup_gpio;\n\tbool drdy_trig_on;\n\t \n\tstruct {\n\t\ts16 channels[2];\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\nstatic const struct iio_chan_spec ccs811_channels[] = {\n\t{\n\t\t.type = IIO_CURRENT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = -1,\n\t}, {\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = -1,\n\t}, {\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_CO2,\n\t\t.modified = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t}, {\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_VOC,\n\t\t.modified = 1,\n\t\t.info_mask_separate =  BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t       BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 1,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(2),\n};\n\n \nstatic int ccs811_start_sensor_application(struct i2c_client *client)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, CCS811_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((ret & CCS811_STATUS_FW_MODE_APPLICATION))\n\t\treturn 0;\n\n\tif ((ret & CCS811_STATUS_APP_VALID_MASK) !=\n\t    CCS811_STATUS_APP_VALID_LOADED)\n\t\treturn -EIO;\n\n\tret = i2c_smbus_write_byte(client, CCS811_APP_START);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_byte_data(client, CCS811_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((ret & CCS811_STATUS_FW_MODE_MASK) !=\n\t    CCS811_STATUS_FW_MODE_APPLICATION) {\n\t\tdev_err(&client->dev, \"Application failed to start. Sensor is still in boot mode.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccs811_setup(struct i2c_client *client)\n{\n\tint ret;\n\n\tret = ccs811_start_sensor_application(client);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn i2c_smbus_write_byte_data(client, CCS811_MEAS_MODE,\n\t\t\t\t\t CCS811_MODE_IAQ_1SEC);\n}\n\nstatic void ccs811_set_wakeup(struct ccs811_data *data, bool enable)\n{\n\tif (!data->wakeup_gpio)\n\t\treturn;\n\n\tgpiod_set_value(data->wakeup_gpio, enable);\n\n\tif (enable)\n\t\tusleep_range(50, 60);\n\telse\n\t\tusleep_range(20, 30);\n}\n\nstatic int ccs811_get_measurement(struct ccs811_data *data)\n{\n\tint ret, tries = 11;\n\n\tccs811_set_wakeup(data, true);\n\n\t \n\twhile (tries-- > 0) {\n\t\tret = i2c_smbus_read_byte_data(data->client, CCS811_STATUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif ((ret & CCS811_STATUS_DATA_READY) || tries == 0)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\tif (!(ret & CCS811_STATUS_DATA_READY))\n\t\treturn -EIO;\n\n\tret = i2c_smbus_read_i2c_block_data(data->client,\n\t\t\t\t\t    CCS811_ALG_RESULT_DATA, 8,\n\t\t\t\t\t    (char *)&data->buffer);\n\tccs811_set_wakeup(data, false);\n\n\treturn ret;\n}\n\nstatic int ccs811_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct ccs811_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmutex_lock(&data->lock);\n\t\tret = ccs811_get_measurement(data);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&data->lock);\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\t*val = be16_to_cpu(data->buffer.raw_data) &\n\t\t\t\t\t   CCS811_VOLTAGE_MASK;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_CURRENT:\n\t\t\t*val = be16_to_cpu(data->buffer.raw_data) >> 10;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_CONCENTRATION:\n\t\t\tswitch (chan->channel2) {\n\t\t\tcase IIO_MOD_CO2:\n\t\t\t\t*val = be16_to_cpu(data->buffer.co2);\n\t\t\t\tret =  IIO_VAL_INT;\n\t\t\t\tbreak;\n\t\t\tcase IIO_MOD_VOC:\n\t\t\t\t*val = be16_to_cpu(data->buffer.voc);\n\t\t\t\tret = IIO_VAL_INT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tmutex_unlock(&data->lock);\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\treturn ret;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\t*val = 1;\n\t\t\t*val2 = 612903;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_CURRENT:\n\t\t\t*val = 0;\n\t\t\t*val2 = 1000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_CONCENTRATION:\n\t\t\tswitch (chan->channel2) {\n\t\t\tcase IIO_MOD_CO2:\n\t\t\t\t*val = 0;\n\t\t\t\t*val2 = 100;\n\t\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t\tcase IIO_MOD_VOC:\n\t\t\t\t*val = 0;\n\t\t\t\t*val2 = 100;\n\t\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info ccs811_info = {\n\t.read_raw = ccs811_read_raw,\n};\n\nstatic int ccs811_set_trigger_state(struct iio_trigger *trig,\n\t\t\t\t    bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct ccs811_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, CCS811_MEAS_MODE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (state)\n\t\tret |= CCS811_MEAS_MODE_INTERRUPT;\n\telse\n\t\tret &= ~CCS811_MEAS_MODE_INTERRUPT;\n\n\tdata->drdy_trig_on = state;\n\n\treturn i2c_smbus_write_byte_data(data->client, CCS811_MEAS_MODE, ret);\n}\n\nstatic const struct iio_trigger_ops ccs811_trigger_ops = {\n\t.set_trigger_state = ccs811_set_trigger_state,\n};\n\nstatic irqreturn_t ccs811_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ccs811_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tret = i2c_smbus_read_i2c_block_data(client, CCS811_ALG_RESULT_DATA,\n\t\t\t\t\t    sizeof(data->scan.channels),\n\t\t\t\t\t    (u8 *)data->scan.channels);\n\tif (ret != 4) {\n\t\tdev_err(&client->dev, \"cannot read sensor data\\n\");\n\t\tgoto err;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ccs811_data_rdy_trigger_poll(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct ccs811_data *data = iio_priv(indio_dev);\n\n\tif (data->drdy_trig_on)\n\t\tiio_trigger_poll(data->drdy_trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ccs811_reset(struct i2c_client *client)\n{\n\tstruct gpio_desc *reset_gpio;\n\tint ret;\n\n\treset_gpio = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(reset_gpio))\n\t\treturn PTR_ERR(reset_gpio);\n\n\t \n\tif (reset_gpio) {\n\t\tgpiod_set_value(reset_gpio, 1);\n\t\tusleep_range(20, 30);\n\t\tgpiod_set_value(reset_gpio, 0);\n\t} else {\n\t\t \n\t\tstatic const u8 reset_seq[] = {\n\t\t\t0x11, 0xE5, 0x72, 0x8A,\n\t\t};\n\n\t\tret = i2c_smbus_write_i2c_block_data(client, CCS811_SW_RESET,\n\t\t\t\t\t     sizeof(reset_seq), reset_seq);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"Failed to reset sensor\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tusleep_range(1000, 2000);\n\n\treturn 0;\n}\n\nstatic int ccs811_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct iio_dev *indio_dev;\n\tstruct ccs811_data *data;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WRITE_BYTE\n\t\t\t\t     | I2C_FUNC_SMBUS_BYTE_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_READ_I2C_BLOCK))\n\t\treturn -EOPNOTSUPP;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tdata->wakeup_gpio = devm_gpiod_get_optional(&client->dev, \"wakeup\",\n\t\t\t\t\t\t    GPIOD_OUT_HIGH);\n\tif (IS_ERR(data->wakeup_gpio))\n\t\treturn PTR_ERR(data->wakeup_gpio);\n\n\tccs811_set_wakeup(data, true);\n\n\tret = ccs811_reset(client);\n\tif (ret) {\n\t\tccs811_set_wakeup(data, false);\n\t\treturn ret;\n\t}\n\n\t \n\tret = i2c_smbus_read_byte_data(client, CCS811_HW_ID);\n\tif (ret < 0) {\n\t\tccs811_set_wakeup(data, false);\n\t\treturn ret;\n\t}\n\n\tif (ret != CCS811_HW_ID_VALUE) {\n\t\tdev_err(&client->dev, \"hardware id doesn't match CCS81x\\n\");\n\t\tccs811_set_wakeup(data, false);\n\t\treturn -ENODEV;\n\t}\n\n\tret = i2c_smbus_read_byte_data(client, CCS811_HW_VERSION);\n\tif (ret < 0) {\n\t\tccs811_set_wakeup(data, false);\n\t\treturn ret;\n\t}\n\n\tif ((ret & CCS811_HW_VERSION_MASK) != CCS811_HW_VERSION_VALUE) {\n\t\tdev_err(&client->dev, \"no CCS811 sensor\\n\");\n\t\tccs811_set_wakeup(data, false);\n\t\treturn -ENODEV;\n\t}\n\n\tret = ccs811_setup(client);\n\tif (ret < 0) {\n\t\tccs811_set_wakeup(data, false);\n\t\treturn ret;\n\t}\n\n\tccs811_set_wakeup(data, false);\n\n\tmutex_init(&data->lock);\n\n\tindio_dev->name = id->name;\n\tindio_dev->info = &ccs811_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tindio_dev->channels = ccs811_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ccs811_channels);\n\n\tif (client->irq > 0) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tccs811_data_rdy_trigger_poll,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"ccs811_irq\", indio_dev);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"irq request error %d\\n\", -ret);\n\t\t\tgoto err_poweroff;\n\t\t}\n\n\t\tdata->drdy_trig = devm_iio_trigger_alloc(&client->dev,\n\t\t\t\t\t\t\t \"%s-dev%d\",\n\t\t\t\t\t\t\t indio_dev->name,\n\t\t\t\t\t\t\t iio_device_id(indio_dev));\n\t\tif (!data->drdy_trig) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_poweroff;\n\t\t}\n\n\t\tdata->drdy_trig->ops = &ccs811_trigger_ops;\n\t\tiio_trigger_set_drvdata(data->drdy_trig, indio_dev);\n\t\tret = iio_trigger_register(data->drdy_trig);\n\t\tif (ret)\n\t\t\tgoto err_poweroff;\n\n\t\tindio_dev->trig = iio_trigger_get(data->drdy_trig);\n\t}\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL,\n\t\t\t\t\t ccs811_trigger_handler, NULL);\n\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"triggered buffer setup failed\\n\");\n\t\tgoto err_trigger_unregister;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"unable to register iio device\\n\");\n\t\tgoto err_buffer_cleanup;\n\t}\n\treturn 0;\n\nerr_buffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\nerr_trigger_unregister:\n\tif (data->drdy_trig)\n\t\tiio_trigger_unregister(data->drdy_trig);\nerr_poweroff:\n\ti2c_smbus_write_byte_data(client, CCS811_MEAS_MODE, CCS811_MODE_IDLE);\n\n\treturn ret;\n}\n\nstatic void ccs811_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct ccs811_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tif (data->drdy_trig)\n\t\tiio_trigger_unregister(data->drdy_trig);\n\n\tret = i2c_smbus_write_byte_data(client, CCS811_MEAS_MODE,\n\t\t\t\t\tCCS811_MODE_IDLE);\n\tif (ret)\n\t\tdev_warn(&client->dev, \"Failed to power down device (%pe)\\n\",\n\t\t\t ERR_PTR(ret));\n}\n\nstatic const struct i2c_device_id ccs811_id[] = {\n\t{\"ccs811\", 0},\n\t{\t}\n};\nMODULE_DEVICE_TABLE(i2c, ccs811_id);\n\nstatic const struct of_device_id ccs811_dt_ids[] = {\n\t{ .compatible = \"ams,ccs811\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ccs811_dt_ids);\n\nstatic struct i2c_driver ccs811_driver = {\n\t.driver = {\n\t\t.name = \"ccs811\",\n\t\t.of_match_table = ccs811_dt_ids,\n\t},\n\t.probe = ccs811_probe,\n\t.remove = ccs811_remove,\n\t.id_table = ccs811_id,\n};\nmodule_i2c_driver(ccs811_driver);\n\nMODULE_AUTHOR(\"Narcisa Vasile <narcisaanamaria12@gmail.com>\");\nMODULE_DESCRIPTION(\"CCS811 volatile organic compounds sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}