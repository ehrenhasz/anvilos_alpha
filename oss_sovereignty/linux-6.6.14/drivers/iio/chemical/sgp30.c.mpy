{
  "module_name": "sgp30.c",
  "hash_id": "4c4982de2524d19b4f8876c140717e080199729c79e9e17f5ee8fbd0892fd496",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/sgp30.c",
  "human_readable_source": "\n \n\n#include <linux/crc8.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define SGP_WORD_LEN\t\t\t\t2\n#define SGP_CRC8_POLYNOMIAL\t\t\t0x31\n#define SGP_CRC8_INIT\t\t\t\t0xff\n#define SGP_CRC8_LEN\t\t\t\t1\n#define SGP_CMD(cmd_word)\t\t\tcpu_to_be16(cmd_word)\n#define SGP_CMD_DURATION_US\t\t\t12000\n#define SGP_MEASUREMENT_DURATION_US\t\t50000\n#define SGP_CMD_LEN\t\t\t\tSGP_WORD_LEN\n#define SGP_CMD_MAX_BUF_SIZE\t\t\t(SGP_CMD_LEN + 2 * SGP_WORD_LEN)\n#define SGP_MEASUREMENT_LEN\t\t\t2\n#define SGP30_MEASURE_INTERVAL_HZ\t\t1\n#define SGPC3_MEASURE_INTERVAL_HZ\t\t2\n#define SGP_VERS_PRODUCT(data)\t((((data)->feature_set) & 0xf000) >> 12)\n#define SGP_VERS_RESERVED(data)\t((((data)->feature_set) & 0x0800) >> 11)\n#define SGP_VERS_GEN(data)\t((((data)->feature_set) & 0x0600) >> 9)\n#define SGP_VERS_ENG_BIT(data)\t((((data)->feature_set) & 0x0100) >> 8)\n#define SGP_VERS_MAJOR(data)\t((((data)->feature_set) & 0x00e0) >> 5)\n#define SGP_VERS_MINOR(data)\t(((data)->feature_set) & 0x001f)\n\nDECLARE_CRC8_TABLE(sgp_crc8_table);\n\nenum sgp_product_id {\n\tSGP30 = 0,\n\tSGPC3,\n};\n\nenum sgp30_channel_idx {\n\tSGP30_IAQ_TVOC_IDX = 0,\n\tSGP30_IAQ_CO2EQ_IDX,\n\tSGP30_SIG_ETOH_IDX,\n\tSGP30_SIG_H2_IDX,\n};\n\nenum sgpc3_channel_idx {\n\tSGPC3_IAQ_TVOC_IDX = 10,\n\tSGPC3_SIG_ETOH_IDX,\n};\n\nenum sgp_cmd {\n\tSGP_CMD_IAQ_INIT\t\t\t= SGP_CMD(0x2003),\n\tSGP_CMD_IAQ_MEASURE\t\t\t= SGP_CMD(0x2008),\n\tSGP_CMD_GET_FEATURE_SET\t\t\t= SGP_CMD(0x202f),\n\tSGP_CMD_GET_SERIAL_ID\t\t\t= SGP_CMD(0x3682),\n\n\tSGP30_CMD_MEASURE_SIGNAL\t\t= SGP_CMD(0x2050),\n\n\tSGPC3_CMD_MEASURE_RAW\t\t\t= SGP_CMD(0x2046),\n};\n\nstruct sgp_version {\n\tu8 major;\n\tu8 minor;\n};\n\nstruct sgp_crc_word {\n\t__be16 value;\n\tu8 crc8;\n} __attribute__((__packed__));\n\nunion sgp_reading {\n\tu8 start;\n\tstruct sgp_crc_word raw_words[4];\n};\n\nenum _iaq_buffer_state {\n\tIAQ_BUFFER_EMPTY = 0,\n\tIAQ_BUFFER_DEFAULT_VALS,\n\tIAQ_BUFFER_VALID,\n};\n\nstruct sgp_data {\n\tstruct i2c_client *client;\n\tstruct task_struct *iaq_thread;\n\tstruct mutex data_lock;\n\tunsigned long iaq_init_start_jiffies;\n\tunsigned long iaq_defval_skip_jiffies;\n\tu16 product_id;\n\tu16 feature_set;\n\tunsigned long measure_interval_jiffies;\n\tenum sgp_cmd iaq_init_cmd;\n\tenum sgp_cmd measure_iaq_cmd;\n\tenum sgp_cmd measure_gas_signals_cmd;\n\tunion sgp_reading buffer;\n\tunion sgp_reading iaq_buffer;\n\tenum _iaq_buffer_state iaq_buffer_state;\n};\n\nstruct sgp_device {\n\tconst struct iio_chan_spec *channels;\n\tint num_channels;\n};\n\nstatic const struct sgp_version supported_versions_sgp30[] = {\n\t{\n\t\t.major = 1,\n\t\t.minor = 0,\n\t},\n};\n\nstatic const struct sgp_version supported_versions_sgpc3[] = {\n\t{\n\t\t.major = 0,\n\t\t.minor = 4,\n\t},\n};\n\nstatic const struct iio_chan_spec sgp30_channels[] = {\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_VOC,\n\t\t.modified = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.address = SGP30_IAQ_TVOC_IDX,\n\t},\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_CO2,\n\t\t.modified = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.address = SGP30_IAQ_CO2EQ_IDX,\n\t},\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_ETHANOL,\n\t\t.modified = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.address = SGP30_SIG_ETOH_IDX,\n\t},\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_H2,\n\t\t.modified = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.address = SGP30_SIG_H2_IDX,\n\t},\n};\n\nstatic const struct iio_chan_spec sgpc3_channels[] = {\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_VOC,\n\t\t.modified = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.address = SGPC3_IAQ_TVOC_IDX,\n\t},\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_ETHANOL,\n\t\t.modified = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.address = SGPC3_SIG_ETOH_IDX,\n\t},\n};\n\nstatic const struct sgp_device sgp_devices[] = {\n\t[SGP30] = {\n\t\t.channels = sgp30_channels,\n\t\t.num_channels = ARRAY_SIZE(sgp30_channels),\n\t},\n\t[SGPC3] = {\n\t\t.channels = sgpc3_channels,\n\t\t.num_channels = ARRAY_SIZE(sgpc3_channels),\n\t},\n};\n\n \nstatic int sgp_verify_buffer(const struct sgp_data *data,\n\t\t\t     union sgp_reading *buf, size_t word_count)\n{\n\tsize_t size = word_count * (SGP_WORD_LEN + SGP_CRC8_LEN);\n\tint i;\n\tu8 crc;\n\tu8 *data_buf = &buf->start;\n\n\tfor (i = 0; i < size; i += SGP_WORD_LEN + SGP_CRC8_LEN) {\n\t\tcrc = crc8(sgp_crc8_table, &data_buf[i], SGP_WORD_LEN,\n\t\t\t   SGP_CRC8_INIT);\n\t\tif (crc != data_buf[i + SGP_WORD_LEN]) {\n\t\t\tdev_err(&data->client->dev, \"CRC error\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sgp_read_cmd(struct sgp_data *data, enum sgp_cmd cmd,\n\t\t\tunion sgp_reading *buf, size_t word_count,\n\t\t\tunsigned long duration_us)\n{\n\tint ret;\n\tstruct i2c_client *client = data->client;\n\tsize_t size = word_count * (SGP_WORD_LEN + SGP_CRC8_LEN);\n\tu8 *data_buf;\n\n\tret = i2c_master_send(client, (const char *)&cmd, SGP_CMD_LEN);\n\tif (ret != SGP_CMD_LEN)\n\t\treturn -EIO;\n\tusleep_range(duration_us, duration_us + 1000);\n\n\tif (word_count == 0)\n\t\treturn 0;\n\n\tdata_buf = &buf->start;\n\tret = i2c_master_recv(client, data_buf, size);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != size)\n\t\treturn -EIO;\n\n\treturn sgp_verify_buffer(data, buf, word_count);\n}\n\n \n\nstatic int sgp_measure_iaq(struct sgp_data *data)\n{\n\tint ret;\n\t \n\tbool default_vals = !time_after(jiffies, data->iaq_init_start_jiffies +\n\t\t\t\t\t\t data->iaq_defval_skip_jiffies);\n\n\tret = sgp_read_cmd(data, data->measure_iaq_cmd, &data->iaq_buffer,\n\t\t\t   SGP_MEASUREMENT_LEN, SGP_MEASUREMENT_DURATION_US);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->iaq_buffer_state = IAQ_BUFFER_DEFAULT_VALS;\n\n\tif (default_vals)\n\t\treturn -EBUSY;\n\n\tdata->iaq_buffer_state = IAQ_BUFFER_VALID;\n\n\treturn 0;\n}\n\nstatic void sgp_iaq_thread_sleep_until(const struct sgp_data *data,\n\t\t\t\t       unsigned long sleep_jiffies)\n{\n\tconst long IAQ_POLL = 50000;\n\n\twhile (!time_after(jiffies, sleep_jiffies)) {\n\t\tusleep_range(IAQ_POLL, IAQ_POLL + 10000);\n\t\tif (kthread_should_stop() || data->iaq_init_start_jiffies == 0)\n\t\t\treturn;\n\t}\n}\n\nstatic int sgp_iaq_threadfn(void *p)\n{\n\tstruct sgp_data *data = (struct sgp_data *)p;\n\tunsigned long next_update_jiffies;\n\tint ret;\n\n\twhile (!kthread_should_stop()) {\n\t\tmutex_lock(&data->data_lock);\n\t\tif (data->iaq_init_start_jiffies == 0) {\n\t\t\tret = sgp_read_cmd(data, data->iaq_init_cmd, NULL, 0,\n\t\t\t\t\t   SGP_CMD_DURATION_US);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto unlock_sleep_continue;\n\t\t\tdata->iaq_init_start_jiffies = jiffies;\n\t\t}\n\n\t\tret = sgp_measure_iaq(data);\n\t\tif (ret && ret != -EBUSY) {\n\t\t\tdev_warn(&data->client->dev,\n\t\t\t\t \"IAQ measurement error [%d]\\n\", ret);\n\t\t}\nunlock_sleep_continue:\n\t\tnext_update_jiffies = jiffies + data->measure_interval_jiffies;\n\t\tmutex_unlock(&data->data_lock);\n\t\tsgp_iaq_thread_sleep_until(data, next_update_jiffies);\n\t}\n\n\treturn 0;\n}\n\nstatic int sgp_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan, int *val,\n\t\t\tint *val2, long mask)\n{\n\tstruct sgp_data *data = iio_priv(indio_dev);\n\tstruct sgp_crc_word *words;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tmutex_lock(&data->data_lock);\n\t\tif (data->iaq_buffer_state != IAQ_BUFFER_VALID) {\n\t\t\tmutex_unlock(&data->data_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\twords = data->iaq_buffer.raw_words;\n\t\tswitch (chan->address) {\n\t\tcase SGP30_IAQ_TVOC_IDX:\n\t\tcase SGPC3_IAQ_TVOC_IDX:\n\t\t\t*val = 0;\n\t\t\t*val2 = be16_to_cpu(words[1].value);\n\t\t\tret = IIO_VAL_INT_PLUS_NANO;\n\t\t\tbreak;\n\t\tcase SGP30_IAQ_CO2EQ_IDX:\n\t\t\t*val = 0;\n\t\t\t*val2 = be16_to_cpu(words[0].value);\n\t\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&data->data_lock);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&data->data_lock);\n\t\tif (chan->address == SGPC3_SIG_ETOH_IDX) {\n\t\t\tif (data->iaq_buffer_state == IAQ_BUFFER_EMPTY)\n\t\t\t\tret = -EBUSY;\n\t\t\telse\n\t\t\t\tret = 0;\n\t\t\twords = data->iaq_buffer.raw_words;\n\t\t} else {\n\t\t\tret = sgp_read_cmd(data, data->measure_gas_signals_cmd,\n\t\t\t\t\t   &data->buffer, SGP_MEASUREMENT_LEN,\n\t\t\t\t\t   SGP_MEASUREMENT_DURATION_US);\n\t\t\twords = data->buffer.raw_words;\n\t\t}\n\t\tif (ret) {\n\t\t\tmutex_unlock(&data->data_lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch (chan->address) {\n\t\tcase SGP30_SIG_ETOH_IDX:\n\t\t\t*val = be16_to_cpu(words[1].value);\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase SGPC3_SIG_ETOH_IDX:\n\t\tcase SGP30_SIG_H2_IDX:\n\t\t\t*val = be16_to_cpu(words[0].value);\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&data->data_lock);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int sgp_check_compat(struct sgp_data *data,\n\t\t\t    unsigned int product_id)\n{\n\tstruct device *dev = &data->client->dev;\n\tconst struct sgp_version *supported_versions;\n\tu16 ix, num_fs;\n\tu16 product, generation, major, minor;\n\n\t \n\tgeneration = SGP_VERS_GEN(data);\n\tif (generation != 0) {\n\t\tdev_err(dev,\n\t\t\t\"incompatible product generation %d != 0\", generation);\n\t\treturn -ENODEV;\n\t}\n\n\tproduct = SGP_VERS_PRODUCT(data);\n\tif (product != product_id) {\n\t\tdev_err(dev, \"sensor reports a different product: 0x%04x\\n\",\n\t\t\tproduct);\n\t\treturn -ENODEV;\n\t}\n\n\tif (SGP_VERS_RESERVED(data))\n\t\tdev_warn(dev, \"reserved bit is set\\n\");\n\n\t \n\tif (SGP_VERS_ENG_BIT(data))\n\t\treturn -ENODEV;\n\n\tswitch (product) {\n\tcase SGP30:\n\t\tsupported_versions = supported_versions_sgp30;\n\t\tnum_fs = ARRAY_SIZE(supported_versions_sgp30);\n\t\tbreak;\n\tcase SGPC3:\n\t\tsupported_versions = supported_versions_sgpc3;\n\t\tnum_fs = ARRAY_SIZE(supported_versions_sgpc3);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tmajor = SGP_VERS_MAJOR(data);\n\tminor = SGP_VERS_MINOR(data);\n\tfor (ix = 0; ix < num_fs; ix++) {\n\t\tif (major == supported_versions[ix].major &&\n\t\t    minor >= supported_versions[ix].minor)\n\t\t\treturn 0;\n\t}\n\tdev_err(dev, \"unsupported sgp version: %d.%d\\n\", major, minor);\n\n\treturn -ENODEV;\n}\n\nstatic void sgp_init(struct sgp_data *data)\n{\n\tdata->iaq_init_cmd = SGP_CMD_IAQ_INIT;\n\tdata->iaq_init_start_jiffies = 0;\n\tdata->iaq_buffer_state = IAQ_BUFFER_EMPTY;\n\tswitch (SGP_VERS_PRODUCT(data)) {\n\tcase SGP30:\n\t\tdata->measure_interval_jiffies = SGP30_MEASURE_INTERVAL_HZ * HZ;\n\t\tdata->measure_iaq_cmd = SGP_CMD_IAQ_MEASURE;\n\t\tdata->measure_gas_signals_cmd = SGP30_CMD_MEASURE_SIGNAL;\n\t\tdata->product_id = SGP30;\n\t\tdata->iaq_defval_skip_jiffies = 15 * HZ;\n\t\tbreak;\n\tcase SGPC3:\n\t\tdata->measure_interval_jiffies = SGPC3_MEASURE_INTERVAL_HZ * HZ;\n\t\tdata->measure_iaq_cmd = SGPC3_CMD_MEASURE_RAW;\n\t\tdata->measure_gas_signals_cmd = SGPC3_CMD_MEASURE_RAW;\n\t\tdata->product_id = SGPC3;\n\t\tdata->iaq_defval_skip_jiffies =\n\t\t\t43 * data->measure_interval_jiffies;\n\t\tbreak;\n\t}\n}\n\nstatic const struct iio_info sgp_info = {\n\t.read_raw\t= sgp_read_raw,\n};\n\nstatic const struct of_device_id sgp_dt_ids[] = {\n\t{ .compatible = \"sensirion,sgp30\", .data = (void *)SGP30 },\n\t{ .compatible = \"sensirion,sgpc3\", .data = (void *)SGPC3 },\n\t{ }\n};\n\nstatic int sgp_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct sgp_data *data;\n\tunsigned long product_id;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tif (dev_fwnode(dev))\n\t\tproduct_id = (unsigned long)device_get_match_data(dev);\n\telse\n\t\tproduct_id = id->driver_data;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tcrc8_populate_msb(sgp_crc8_table, SGP_CRC8_POLYNOMIAL);\n\tmutex_init(&data->data_lock);\n\n\t \n\tret = sgp_read_cmd(data, SGP_CMD_GET_FEATURE_SET, &data->buffer, 1,\n\t\t\t   SGP_CMD_DURATION_US);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->feature_set = be16_to_cpu(data->buffer.raw_words[0].value);\n\n\tret = sgp_check_compat(data, product_id);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->info = &sgp_info;\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = sgp_devices[product_id].channels;\n\tindio_dev->num_channels = sgp_devices[product_id].num_channels;\n\n\tsgp_init(data);\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register iio device\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->iaq_thread = kthread_run(sgp_iaq_threadfn, data,\n\t\t\t\t       \"%s-iaq\", data->client->name);\n\n\treturn 0;\n}\n\nstatic void sgp_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct sgp_data *data = iio_priv(indio_dev);\n\n\tif (data->iaq_thread)\n\t\tkthread_stop(data->iaq_thread);\n}\n\nstatic const struct i2c_device_id sgp_id[] = {\n\t{ \"sgp30\", SGP30 },\n\t{ \"sgpc3\", SGPC3 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, sgp_id);\nMODULE_DEVICE_TABLE(of, sgp_dt_ids);\n\nstatic struct i2c_driver sgp_driver = {\n\t.driver = {\n\t\t.name = \"sgp30\",\n\t\t.of_match_table = sgp_dt_ids,\n\t},\n\t.probe = sgp_probe,\n\t.remove = sgp_remove,\n\t.id_table = sgp_id,\n};\nmodule_i2c_driver(sgp_driver);\n\nMODULE_AUTHOR(\"Andreas Brauchli <andreas.brauchli@sensirion.com>\");\nMODULE_AUTHOR(\"Pascal Sachs <pascal.sachs@sensirion.com>\");\nMODULE_DESCRIPTION(\"Sensirion SGP gas sensors\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}