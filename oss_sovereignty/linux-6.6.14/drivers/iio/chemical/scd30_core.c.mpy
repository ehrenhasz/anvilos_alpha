{
  "module_name": "scd30_core.c",
  "hash_id": "3bb0d64124cfd91c0bf8b6560782457f4b8c4c866afa6e0c5ede3911ea9c6d08",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/scd30_core.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/types.h>\n#include <linux/interrupt.h>\n#include <linux/irqreturn.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regulator/consumer.h>\n#include <linux/string.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n#include <asm/byteorder.h>\n\n#include \"scd30.h\"\n\n#define SCD30_PRESSURE_COMP_MIN_MBAR 700\n#define SCD30_PRESSURE_COMP_MAX_MBAR 1400\n#define SCD30_PRESSURE_COMP_DEFAULT 1013\n#define SCD30_MEAS_INTERVAL_MIN_S 2\n#define SCD30_MEAS_INTERVAL_MAX_S 1800\n#define SCD30_MEAS_INTERVAL_DEFAULT SCD30_MEAS_INTERVAL_MIN_S\n#define SCD30_FRC_MIN_PPM 400\n#define SCD30_FRC_MAX_PPM 2000\n#define SCD30_TEMP_OFFSET_MAX 655360\n#define SCD30_EXTRA_TIMEOUT_PER_S 250\n\nenum {\n\tSCD30_CONC,\n\tSCD30_TEMP,\n\tSCD30_HR,\n};\n\nstatic int scd30_command_write(struct scd30_state *state, enum scd30_cmd cmd, u16 arg)\n{\n\treturn state->command(state, cmd, arg, NULL, 0);\n}\n\nstatic int scd30_command_read(struct scd30_state *state, enum scd30_cmd cmd, u16 *val)\n{\n\t__be16 tmp;\n\tint ret;\n\n\tret = state->command(state, cmd, 0, &tmp, sizeof(tmp));\n\t*val = be16_to_cpup(&tmp);\n\n\treturn ret;\n}\n\nstatic int scd30_reset(struct scd30_state *state)\n{\n\tint ret;\n\tu16 val;\n\n\tret = scd30_command_write(state, CMD_RESET, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(2000);\n\t \n\tscd30_command_read(state, CMD_MEAS_READY, &val);\n\n\treturn 0;\n}\n\n \nstatic int scd30_float_to_fp(int float32)\n{\n\tint fraction, shift,\n\t    mantissa = float32 & GENMASK(22, 0),\n\t    sign = (float32 & BIT(31)) ? -1 : 1,\n\t    exp = (float32 & ~BIT(31)) >> 23;\n\n\t \n\tif (!exp && !mantissa)\n\t\treturn 0;\n\n\texp -= 127;\n\tif (exp < 0) {\n\t\texp = -exp;\n\t\t \n\t\treturn sign * ((((BIT(23) + mantissa) * 100) >> 23) >> exp);\n\t}\n\n\t \n\tshift = 23 - exp;\n\tfloat32 = BIT(exp) + (mantissa >> shift);\n\tfraction = mantissa & GENMASK(shift - 1, 0);\n\n\treturn sign * (float32 * 100 + ((fraction * 100) >> shift));\n}\n\nstatic int scd30_read_meas(struct scd30_state *state)\n{\n\tint i, ret;\n\n\tret = state->command(state, CMD_READ_MEAS, 0, state->meas, sizeof(state->meas));\n\tif (ret)\n\t\treturn ret;\n\n\tbe32_to_cpu_array(state->meas, (__be32 *)state->meas, ARRAY_SIZE(state->meas));\n\n\tfor (i = 0; i < ARRAY_SIZE(state->meas); i++)\n\t\tstate->meas[i] = scd30_float_to_fp(state->meas[i]);\n\n\t \n\tstate->meas[SCD30_TEMP] *= 10;\n\tstate->meas[SCD30_HR] *= 10;\n\n\treturn 0;\n}\n\nstatic int scd30_wait_meas_irq(struct scd30_state *state)\n{\n\tint ret, timeout;\n\n\treinit_completion(&state->meas_ready);\n\tenable_irq(state->irq);\n\ttimeout = msecs_to_jiffies(state->meas_interval * (1000 + SCD30_EXTRA_TIMEOUT_PER_S));\n\tret = wait_for_completion_interruptible_timeout(&state->meas_ready, timeout);\n\tif (ret > 0)\n\t\tret = 0;\n\telse if (!ret)\n\t\tret = -ETIMEDOUT;\n\n\tdisable_irq(state->irq);\n\n\treturn ret;\n}\n\nstatic int scd30_wait_meas_poll(struct scd30_state *state)\n{\n\tint timeout = state->meas_interval * SCD30_EXTRA_TIMEOUT_PER_S, tries = 5;\n\n\tdo {\n\t\tint ret;\n\t\tu16 val;\n\n\t\tret = scd30_command_read(state, CMD_MEAS_READY, &val);\n\t\tif (ret)\n\t\t\treturn -EIO;\n\n\t\t \n\t\tif (val)\n\t\t\tbreak;\n\n\t\tmsleep_interruptible(timeout);\n\t} while (--tries);\n\n\treturn tries ? 0 : -ETIMEDOUT;\n}\n\nstatic int scd30_read_poll(struct scd30_state *state)\n{\n\tint ret;\n\n\tret = scd30_wait_meas_poll(state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn scd30_read_meas(state);\n}\n\nstatic int scd30_read(struct scd30_state *state)\n{\n\tif (state->irq > 0)\n\t\treturn scd30_wait_meas_irq(state);\n\n\treturn scd30_read_poll(state);\n}\n\nstatic int scd30_read_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,\n\t\t\t  int *val, int *val2, long mask)\n{\n\tstruct scd30_state *state = iio_priv(indio_dev);\n\tint ret = -EINVAL;\n\tu16 tmp;\n\n\tmutex_lock(&state->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tif (chan->output) {\n\t\t\t*val = state->pressure_comp;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = scd30_read(state);\n\t\tif (ret) {\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\tbreak;\n\t\t}\n\n\t\t*val = state->meas[chan->address];\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = 1;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = scd30_command_read(state, CMD_MEAS_INTERVAL, &tmp);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*val = 0;\n\t\t*val2 = 1000000000 / tmp;\n\t\tret = IIO_VAL_INT_PLUS_NANO;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = scd30_command_read(state, CMD_TEMP_OFFSET, &tmp);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*val = tmp;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\t}\n\tmutex_unlock(&state->lock);\n\n\treturn ret;\n}\n\nstatic int scd30_write_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,\n\t\t\t   int val, int val2, long mask)\n{\n\tstruct scd30_state *state = iio_priv(indio_dev);\n\tint ret = -EINVAL;\n\n\tmutex_lock(&state->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (val)\n\t\t\tbreak;\n\n\t\tval = 1000000000 / val2;\n\t\tif (val < SCD30_MEAS_INTERVAL_MIN_S || val > SCD30_MEAS_INTERVAL_MAX_S)\n\t\t\tbreak;\n\n\t\tret = scd30_command_write(state, CMD_MEAS_INTERVAL, val);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstate->meas_interval = val;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_PRESSURE:\n\t\t\tif (val < SCD30_PRESSURE_COMP_MIN_MBAR ||\n\t\t\t    val > SCD30_PRESSURE_COMP_MAX_MBAR)\n\t\t\t\tbreak;\n\n\t\t\tret = scd30_command_write(state, CMD_START_MEAS, val);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tstate->pressure_comp = val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif (val < 0 || val > SCD30_TEMP_OFFSET_MAX)\n\t\t\tbreak;\n\t\t \n\t\tret = scd30_command_write(state, CMD_TEMP_OFFSET / 10, val);\n\t}\n\tmutex_unlock(&state->lock);\n\n\treturn ret;\n}\n\nstatic int scd30_write_raw_get_fmt(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,\n\t\t\t\t   long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const int scd30_pressure_raw_available[] = {\n\tSCD30_PRESSURE_COMP_MIN_MBAR, 1, SCD30_PRESSURE_COMP_MAX_MBAR,\n};\n\nstatic const int scd30_temp_calibbias_available[] = {\n\t0, 10, SCD30_TEMP_OFFSET_MAX,\n};\n\nstatic int scd30_read_avail(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,\n\t\t\t    const int **vals, int *type, int *length, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*vals = scd30_pressure_raw_available;\n\t\t*type = IIO_VAL_INT;\n\n\t\treturn IIO_AVAIL_RANGE;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\t*vals = scd30_temp_calibbias_available;\n\t\t*type = IIO_VAL_INT;\n\n\t\treturn IIO_AVAIL_RANGE;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t sampling_frequency_available_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\tint i = SCD30_MEAS_INTERVAL_MIN_S;\n\tssize_t len = 0;\n\n\tdo {\n\t\tlen += sysfs_emit_at(buf, len, \"0.%09u \", 1000000000 / i);\n\t\t \n\t\ti += 6;\n\t} while (i <= SCD30_MEAS_INTERVAL_MAX_S);\n\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t calibration_auto_enable_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct scd30_state *state = iio_priv(indio_dev);\n\tint ret;\n\tu16 val;\n\n\tmutex_lock(&state->lock);\n\tret = scd30_command_read(state, CMD_ASC, &val);\n\tmutex_unlock(&state->lock);\n\n\treturn ret ?: sysfs_emit(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t calibration_auto_enable_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct scd30_state *state = iio_priv(indio_dev);\n\tbool val;\n\tint ret;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&state->lock);\n\tret = scd30_command_write(state, CMD_ASC, val);\n\tmutex_unlock(&state->lock);\n\n\treturn ret ?: len;\n}\n\nstatic ssize_t calibration_forced_value_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct scd30_state *state = iio_priv(indio_dev);\n\tint ret;\n\tu16 val;\n\n\tmutex_lock(&state->lock);\n\tret = scd30_command_read(state, CMD_FRC, &val);\n\tmutex_unlock(&state->lock);\n\n\treturn ret ?: sysfs_emit(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t calibration_forced_value_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct scd30_state *state = iio_priv(indio_dev);\n\tint ret;\n\tu16 val;\n\n\tret = kstrtou16(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val < SCD30_FRC_MIN_PPM || val > SCD30_FRC_MAX_PPM)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->lock);\n\tret = scd30_command_write(state, CMD_FRC, val);\n\tmutex_unlock(&state->lock);\n\n\treturn ret ?: len;\n}\n\nstatic IIO_DEVICE_ATTR_RO(sampling_frequency_available, 0);\nstatic IIO_DEVICE_ATTR_RW(calibration_auto_enable, 0);\nstatic IIO_DEVICE_ATTR_RW(calibration_forced_value, 0);\n\nstatic struct attribute *scd30_attrs[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_calibration_auto_enable.dev_attr.attr,\n\t&iio_dev_attr_calibration_forced_value.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group scd30_attr_group = {\n\t.attrs = scd30_attrs,\n};\n\nstatic const struct iio_info scd30_info = {\n\t.attrs = &scd30_attr_group,\n\t.read_raw = scd30_read_raw,\n\t.write_raw = scd30_write_raw,\n\t.write_raw_get_fmt = scd30_write_raw_get_fmt,\n\t.read_avail = scd30_read_avail,\n};\n\n#define SCD30_CHAN_SCAN_TYPE(_sign, _realbits) .scan_type = { \\\n\t.sign = _sign, \\\n\t.realbits = _realbits, \\\n\t.storagebits = 32, \\\n\t.endianness = IIO_CPU, \\\n}\n\nstatic const struct iio_chan_spec scd30_channels[] = {\n\t{\n\t\t \n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_RAW),\n\t\t.output = 1,\n\t\t.scan_index = -1,\n\t},\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_CO2,\n\t\t.address = SCD30_CONC,\n\t\t.scan_index = SCD30_CONC,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.modified = 1,\n\n\t\tSCD30_CHAN_SCAN_TYPE('u', 20),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = SCD30_TEMP,\n\t\t.scan_index = SCD30_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_CALIBBIAS),\n\t\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_CALIBBIAS),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\n\t\tSCD30_CHAN_SCAN_TYPE('s', 18),\n\t},\n\t{\n\t\t.type = IIO_HUMIDITYRELATIVE,\n\t\t.address = SCD30_HR,\n\t\t.scan_index = SCD30_HR,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\n\t\tSCD30_CHAN_SCAN_TYPE('u', 17),\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic int scd30_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct scd30_state *state  = iio_priv(indio_dev);\n\tint ret;\n\n\tret = scd30_command_write(state, CMD_STOP_MEAS, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regulator_disable(state->vdd);\n}\n\nstatic int scd30_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct scd30_state *state = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_enable(state->vdd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn scd30_command_write(state, CMD_START_MEAS, state->pressure_comp);\n}\n\nEXPORT_NS_SIMPLE_DEV_PM_OPS(scd30_pm_ops, scd30_suspend, scd30_resume, IIO_SCD30);\n\nstatic void scd30_stop_meas(void *data)\n{\n\tstruct scd30_state *state = data;\n\n\tscd30_command_write(state, CMD_STOP_MEAS, 0);\n}\n\nstatic void scd30_disable_regulator(void *data)\n{\n\tstruct scd30_state *state = data;\n\n\tregulator_disable(state->vdd);\n}\n\nstatic irqreturn_t scd30_irq_handler(int irq, void *priv)\n{\n\tstruct iio_dev *indio_dev = priv;\n\n\tif (iio_buffer_enabled(indio_dev)) {\n\t\tiio_trigger_poll(indio_dev->trig);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t scd30_irq_thread_handler(int irq, void *priv)\n{\n\tstruct iio_dev *indio_dev = priv;\n\tstruct scd30_state *state = iio_priv(indio_dev);\n\tint ret;\n\n\tret = scd30_read_meas(state);\n\tif (ret)\n\t\tgoto out;\n\n\tcomplete_all(&state->meas_ready);\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t scd30_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct scd30_state *state = iio_priv(indio_dev);\n\tstruct {\n\t\tint data[SCD30_MEAS_COUNT];\n\t\ts64 ts __aligned(8);\n\t} scan;\n\tint ret;\n\n\tmutex_lock(&state->lock);\n\tif (!iio_trigger_using_own(indio_dev))\n\t\tret = scd30_read_poll(state);\n\telse\n\t\tret = scd30_read_meas(state);\n\tmemset(&scan, 0, sizeof(scan));\n\tmemcpy(scan.data, state->meas, sizeof(state->meas));\n\tmutex_unlock(&state->lock);\n\tif (ret)\n\t\tgoto out;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &scan, iio_get_time_ns(indio_dev));\nout:\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\nstatic int scd30_set_trigger_state(struct iio_trigger *trig, bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct scd30_state *st = iio_priv(indio_dev);\n\n\tif (state)\n\t\tenable_irq(st->irq);\n\telse\n\t\tdisable_irq(st->irq);\n\n\treturn 0;\n}\n\nstatic const struct iio_trigger_ops scd30_trigger_ops = {\n\t.set_trigger_state = scd30_set_trigger_state,\n\t.validate_device = iio_trigger_validate_own_device,\n};\n\nstatic int scd30_setup_trigger(struct iio_dev *indio_dev)\n{\n\tstruct scd30_state *state = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\tstruct iio_trigger *trig;\n\tint ret;\n\n\ttrig = devm_iio_trigger_alloc(dev, \"%s-dev%d\", indio_dev->name,\n\t\t\t\t      iio_device_id(indio_dev));\n\tif (!trig)\n\t\treturn dev_err_probe(dev, -ENOMEM, \"failed to allocate trigger\\n\");\n\n\ttrig->ops = &scd30_trigger_ops;\n\tiio_trigger_set_drvdata(trig, indio_dev);\n\n\tret = devm_iio_trigger_register(dev, trig);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->trig = iio_trigger_get(trig);\n\n\t \n\tret = devm_request_threaded_irq(dev, state->irq, scd30_irq_handler,\n\t\t\t\t\tscd30_irq_thread_handler,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT |\n\t\t\t\t\tIRQF_NO_AUTOEN,\n\t\t\t\t\tindio_dev->name, indio_dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to request irq\\n\");\n\n\treturn 0;\n}\n\nint scd30_probe(struct device *dev, int irq, const char *name, void *priv,\n\t\tscd30_command_t command)\n{\n\tstatic const unsigned long scd30_scan_masks[] = { 0x07, 0x00 };\n\tstruct scd30_state *state;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\tu16 val;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*state));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tstate = iio_priv(indio_dev);\n\tstate->dev = dev;\n\tstate->priv = priv;\n\tstate->irq = irq;\n\tstate->pressure_comp = SCD30_PRESSURE_COMP_DEFAULT;\n\tstate->meas_interval = SCD30_MEAS_INTERVAL_DEFAULT;\n\tstate->command = command;\n\tmutex_init(&state->lock);\n\tinit_completion(&state->meas_ready);\n\n\tdev_set_drvdata(dev, indio_dev);\n\n\tindio_dev->info = &scd30_info;\n\tindio_dev->name = name;\n\tindio_dev->channels = scd30_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(scd30_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->available_scan_masks = scd30_scan_masks;\n\n\tstate->vdd = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(state->vdd))\n\t\treturn dev_err_probe(dev, PTR_ERR(state->vdd), \"failed to get regulator\\n\");\n\n\tret = regulator_enable(state->vdd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, scd30_disable_regulator, state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = scd30_reset(state);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to reset device\\n\");\n\n\tif (state->irq > 0) {\n\t\tret = scd30_setup_trigger(indio_dev);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"failed to setup trigger\\n\");\n\t}\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL, scd30_trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = scd30_command_read(state, CMD_FW_VERSION, &val);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to read firmware version\\n\");\n\tdev_info(dev, \"firmware version: %d.%d\\n\", val >> 8, (char)val);\n\n\tret = scd30_command_write(state, CMD_MEAS_INTERVAL, state->meas_interval);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to set measurement interval\\n\");\n\n\tret = scd30_command_write(state, CMD_START_MEAS, state->pressure_comp);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to start measurement\\n\");\n\n\tret = devm_add_action_or_reset(dev, scd30_stop_meas, state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS(scd30_probe, IIO_SCD30);\n\nMODULE_AUTHOR(\"Tomasz Duszynski <tomasz.duszynski@octakon.com>\");\nMODULE_DESCRIPTION(\"Sensirion SCD30 carbon dioxide sensor core driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}