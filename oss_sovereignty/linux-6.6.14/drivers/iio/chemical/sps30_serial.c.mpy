{
  "module_name": "sps30_serial.c",
  "hash_id": "6a26f01c645725bca22812430b66a1fd5f8750e006b8920b0899b4429359a38e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/sps30_serial.c",
  "human_readable_source": "\n \n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/iio/iio.h>\n#include <linux/minmax.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/serdev.h>\n#include <linux/types.h>\n\n#include \"sps30.h\"\n\n#define SPS30_SERIAL_DEV_NAME \"sps30\"\n\n#define SPS30_SERIAL_SOF_EOF 0x7e\n#define SPS30_SERIAL_TIMEOUT msecs_to_jiffies(20)\n#define SPS30_SERIAL_MAX_BUF_SIZE 263\n#define SPS30_SERIAL_ESCAPE_CHAR 0x7d\n\n#define SPS30_SERIAL_FRAME_MIN_SIZE 7\n#define SPS30_SERIAL_FRAME_ADR_OFFSET 1\n#define SPS30_SERIAL_FRAME_CMD_OFFSET 2\n#define SPS30_SERIAL_FRAME_MOSI_LEN_OFFSET 3\n#define SPS30_SERIAL_FRAME_MISO_STATE_OFFSET 3\n#define SPS30_SERIAL_FRAME_MISO_LEN_OFFSET 4\n#define SPS30_SERIAL_FRAME_MISO_DATA_OFFSET 5\n\n#define SPS30_SERIAL_START_MEAS 0x00\n#define SPS30_SERIAL_STOP_MEAS 0x01\n#define SPS30_SERIAL_READ_MEAS 0x03\n#define SPS30_SERIAL_RESET 0xd3\n#define SPS30_SERIAL_CLEAN_FAN 0x56\n#define SPS30_SERIAL_PERIOD 0x80\n#define SPS30_SERIAL_DEV_INFO 0xd0\n#define SPS30_SERIAL_READ_VERSION 0xd1\n\nstruct sps30_serial_priv {\n\tstruct completion new_frame;\n\tunsigned char buf[SPS30_SERIAL_MAX_BUF_SIZE];\n\tsize_t num;\n\tbool escaped;\n\tbool done;\n};\n\nstatic int sps30_serial_xfer(struct sps30_state *state, const unsigned char *buf, size_t size)\n{\n\tstruct serdev_device *serdev = to_serdev_device(state->dev);\n\tstruct sps30_serial_priv *priv = state->priv;\n\tint ret;\n\n\tpriv->num = 0;\n\tpriv->escaped = false;\n\tpriv->done = false;\n\n\tret = serdev_device_write(serdev, buf, size, SPS30_SERIAL_TIMEOUT);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != size)\n\t\treturn -EIO;\n\n\tret = wait_for_completion_interruptible_timeout(&priv->new_frame, SPS30_SERIAL_TIMEOUT);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic const struct {\n\tunsigned char byte;\n\tunsigned char byte2;\n} sps30_serial_bytes[] = {\n\t{ 0x11, 0x31 },\n\t{ 0x13, 0x33 },\n\t{ 0x7e, 0x5e },\n\t{ 0x7d, 0x5d },\n};\n\nstatic int sps30_serial_put_byte(unsigned char *buf, unsigned char byte)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sps30_serial_bytes); i++) {\n\t\tif (sps30_serial_bytes[i].byte != byte)\n\t\t\tcontinue;\n\n\t\tbuf[0] = SPS30_SERIAL_ESCAPE_CHAR;\n\t\tbuf[1] = sps30_serial_bytes[i].byte2;\n\n\t\treturn 2;\n\t}\n\n\tbuf[0] = byte;\n\n\treturn 1;\n}\n\nstatic char sps30_serial_get_byte(bool escaped, unsigned char byte2)\n{\n\tint i;\n\n\tif (!escaped)\n\t\treturn byte2;\n\n\tfor (i = 0; i < ARRAY_SIZE(sps30_serial_bytes); i++) {\n\t\tif (sps30_serial_bytes[i].byte2 != byte2)\n\t\t\tcontinue;\n\n\t\treturn sps30_serial_bytes[i].byte;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned char sps30_serial_calc_chksum(const unsigned char *buf, size_t num)\n{\n\tunsigned int chksum = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < num; i++)\n\t\tchksum += buf[i];\n\n\treturn ~chksum;\n}\n\nstatic int sps30_serial_prep_frame(unsigned char *buf, unsigned char cmd,\n\t\t\t\t   const unsigned char *arg, size_t arg_size)\n{\n\tunsigned char chksum;\n\tint num = 0;\n\tsize_t i;\n\n\tbuf[num++] = SPS30_SERIAL_SOF_EOF;\n\tbuf[num++] = 0;\n\tnum += sps30_serial_put_byte(buf + num, cmd);\n\tnum += sps30_serial_put_byte(buf + num, arg_size);\n\n\tfor (i = 0; i < arg_size; i++)\n\t\tnum += sps30_serial_put_byte(buf + num, arg[i]);\n\n\t \n\tchksum = sps30_serial_calc_chksum(buf + 1, num - 1);\n\tnum += sps30_serial_put_byte(buf + num, chksum);\n\tbuf[num++] = SPS30_SERIAL_SOF_EOF;\n\n\treturn num;\n}\n\nstatic bool sps30_serial_frame_valid(struct sps30_state *state, const unsigned char *buf)\n{\n\tstruct sps30_serial_priv *priv = state->priv;\n\tunsigned char chksum;\n\n\tif ((priv->num < SPS30_SERIAL_FRAME_MIN_SIZE) ||\n\t    (priv->num != SPS30_SERIAL_FRAME_MIN_SIZE +\n\t     priv->buf[SPS30_SERIAL_FRAME_MISO_LEN_OFFSET])) {\n\t\tdev_err(state->dev, \"frame has invalid number of bytes\\n\");\n\t\treturn false;\n\t}\n\n\tif ((priv->buf[SPS30_SERIAL_FRAME_ADR_OFFSET] != buf[SPS30_SERIAL_FRAME_ADR_OFFSET]) ||\n\t    (priv->buf[SPS30_SERIAL_FRAME_CMD_OFFSET] != buf[SPS30_SERIAL_FRAME_CMD_OFFSET])) {\n\t\tdev_err(state->dev, \"frame has wrong ADR and CMD bytes\\n\");\n\t\treturn false;\n\t}\n\n\tif (priv->buf[SPS30_SERIAL_FRAME_MISO_STATE_OFFSET]) {\n\t\tdev_err(state->dev, \"frame with non-zero state received (0x%02x)\\n\",\n\t\t\tpriv->buf[SPS30_SERIAL_FRAME_MISO_STATE_OFFSET]);\n\t\treturn false;\n\t}\n\n\t \n\tchksum = sps30_serial_calc_chksum(priv->buf + 1, priv->num - 3);\n\tif (priv->buf[priv->num - 2] != chksum) {\n\t\tdev_err(state->dev, \"frame integrity check failed\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int sps30_serial_command(struct sps30_state *state, unsigned char cmd,\n\t\t\t\tconst void *arg, size_t arg_size, void *rsp, size_t rsp_size)\n{\n\tstruct sps30_serial_priv *priv = state->priv;\n\tunsigned char buf[SPS30_SERIAL_MAX_BUF_SIZE];\n\tint ret, size;\n\n\tsize = sps30_serial_prep_frame(buf, cmd, arg, arg_size);\n\tret = sps30_serial_xfer(state, buf, size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!sps30_serial_frame_valid(state, buf))\n\t\treturn -EIO;\n\n\tif (rsp) {\n\t\trsp_size = min_t(size_t, priv->buf[SPS30_SERIAL_FRAME_MISO_LEN_OFFSET], rsp_size);\n\t\tmemcpy(rsp, &priv->buf[SPS30_SERIAL_FRAME_MISO_DATA_OFFSET], rsp_size);\n\t}\n\n\treturn rsp_size;\n}\n\nstatic int sps30_serial_receive_buf(struct serdev_device *serdev,\n\t\t\t\t    const unsigned char *buf, size_t size)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(&serdev->dev);\n\tstruct sps30_serial_priv *priv;\n\tstruct sps30_state *state;\n\tunsigned char byte;\n\tsize_t i;\n\n\tif (!indio_dev)\n\t\treturn 0;\n\n\tstate = iio_priv(indio_dev);\n\tpriv = state->priv;\n\n\t \n\tif (priv->done)\n\t\treturn size;\n\n\t \n\tif (!priv->num && size && buf[0] != SPS30_SERIAL_SOF_EOF)\n\t\treturn 1;\n\n\tif (priv->num + size >= ARRAY_SIZE(priv->buf))\n\t\tsize = ARRAY_SIZE(priv->buf) - priv->num;\n\n\tfor (i = 0; i < size; i++) {\n\t\tbyte = buf[i];\n\t\t \n\t\tif (byte == SPS30_SERIAL_ESCAPE_CHAR) {\n\t\t\tpriv->escaped = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbyte = sps30_serial_get_byte(priv->escaped, byte);\n\t\tif (priv->escaped && !byte)\n\t\t\tdev_warn(state->dev, \"unrecognized escaped char (0x%02x)\\n\", byte);\n\n\t\tpriv->buf[priv->num++] = byte;\n\n\t\t \n\t\tif (!priv->escaped && byte == SPS30_SERIAL_SOF_EOF) {\n\t\t\tif (priv->num < SPS30_SERIAL_FRAME_MIN_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\tpriv->done = true;\n\t\t\tcomplete(&priv->new_frame);\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->escaped = false;\n\t}\n\n\treturn i;\n}\n\nstatic const struct serdev_device_ops sps30_serial_device_ops = {\n\t.receive_buf = sps30_serial_receive_buf,\n\t.write_wakeup = serdev_device_write_wakeup,\n};\n\nstatic int sps30_serial_start_meas(struct sps30_state *state)\n{\n\t \n\tunsigned char buf[] = { 0x01, 0x03 };\n\n\treturn sps30_serial_command(state, SPS30_SERIAL_START_MEAS, buf, sizeof(buf), NULL, 0);\n}\n\nstatic int sps30_serial_stop_meas(struct sps30_state *state)\n{\n\treturn sps30_serial_command(state, SPS30_SERIAL_STOP_MEAS, NULL, 0, NULL, 0);\n}\n\nstatic int sps30_serial_reset(struct sps30_state *state)\n{\n\tint ret;\n\n\tret = sps30_serial_command(state, SPS30_SERIAL_RESET, NULL, 0, NULL, 0);\n\tmsleep(500);\n\n\treturn ret;\n}\n\nstatic int sps30_serial_read_meas(struct sps30_state *state, __be32 *meas, size_t num)\n{\n\tint ret;\n\n\t \n\tif (msleep_interruptible(1000))\n\t\treturn -EINTR;\n\n\tret = sps30_serial_command(state, SPS30_SERIAL_READ_MEAS, NULL, 0, meas, num * sizeof(num));\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tif (ret == SPS30_SERIAL_FRAME_MIN_SIZE)\n\t\treturn -ETIMEDOUT;\n\tif (ret != num * sizeof(*meas))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int sps30_serial_clean_fan(struct sps30_state *state)\n{\n\treturn sps30_serial_command(state, SPS30_SERIAL_CLEAN_FAN, NULL, 0, NULL, 0);\n}\n\nstatic int sps30_serial_read_cleaning_period(struct sps30_state *state, __be32 *period)\n{\n\tunsigned char buf[] = { 0x00 };\n\tint ret;\n\n\tret = sps30_serial_command(state, SPS30_SERIAL_PERIOD, buf, sizeof(buf),\n\t\t\t\t   period, sizeof(*period));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(*period))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int sps30_serial_write_cleaning_period(struct sps30_state *state, __be32 period)\n{\n\tunsigned char buf[5] = { 0x00 };\n\n\tmemcpy(buf + 1, &period, sizeof(period));\n\n\treturn sps30_serial_command(state, SPS30_SERIAL_PERIOD, buf, sizeof(buf), NULL, 0);\n}\n\nstatic int sps30_serial_show_info(struct sps30_state *state)\n{\n\t \n\tunsigned char buf[32 + 1] = { 0x03 };\n\tstruct device *dev = state->dev;\n\tint ret;\n\n\tret = sps30_serial_command(state, SPS30_SERIAL_DEV_INFO, buf, 1, buf, sizeof(buf) - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(buf) - 1)\n\t\treturn -EIO;\n\n\tdev_info(dev, \"serial number: %s\\n\", buf);\n\n\tret = sps30_serial_command(state, SPS30_SERIAL_READ_VERSION, NULL, 0, buf, sizeof(buf) - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret < 2)\n\t\treturn -EIO;\n\n\tdev_info(dev, \"fw version: %u.%u\\n\", buf[0], buf[1]);\n\n\treturn 0;\n}\n\nstatic const struct sps30_ops sps30_serial_ops = {\n\t.start_meas = sps30_serial_start_meas,\n\t.stop_meas = sps30_serial_stop_meas,\n\t.read_meas = sps30_serial_read_meas,\n\t.reset = sps30_serial_reset,\n\t.clean_fan = sps30_serial_clean_fan,\n\t.read_cleaning_period = sps30_serial_read_cleaning_period,\n\t.write_cleaning_period = sps30_serial_write_cleaning_period,\n\t.show_info = sps30_serial_show_info,\n};\n\nstatic int sps30_serial_probe(struct serdev_device *serdev)\n{\n\tstruct device *dev = &serdev->dev;\n\tstruct sps30_serial_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&priv->new_frame);\n\tserdev_device_set_client_ops(serdev, &sps30_serial_device_ops);\n\n\tret = devm_serdev_device_open(dev, serdev);\n\tif (ret)\n\t\treturn ret;\n\n\tserdev_device_set_baudrate(serdev, 115200);\n\tserdev_device_set_flow_control(serdev, false);\n\n\tret = serdev_device_set_parity(serdev, SERDEV_PARITY_NONE);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sps30_probe(dev, SPS30_SERIAL_DEV_NAME, priv, &sps30_serial_ops);\n}\n\nstatic const struct of_device_id sps30_serial_of_match[] = {\n\t{ .compatible = \"sensirion,sps30\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sps30_serial_of_match);\n\nstatic struct serdev_device_driver sps30_serial_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = sps30_serial_of_match,\n\t},\n\t.probe = sps30_serial_probe,\n};\nmodule_serdev_device_driver(sps30_serial_driver);\n\nMODULE_AUTHOR(\"Tomasz Duszynski <tomasz.duszynski@octakon.com>\");\nMODULE_DESCRIPTION(\"Sensirion SPS30 particulate matter sensor serial driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_SPS30);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}