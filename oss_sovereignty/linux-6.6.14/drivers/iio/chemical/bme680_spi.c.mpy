{
  "module_name": "bme680_spi.c",
  "hash_id": "7053eaa6e7d86e56a1a5dde0ebba9e65c726ae2fdb2aad1a3ae3d3bacf449a4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/bme680_spi.c",
  "human_readable_source": "\n \n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n\n#include \"bme680.h\"\n\nstruct bme680_spi_bus_context {\n\tstruct spi_device *spi;\n\tu8 current_page;\n};\n\n \nstatic int bme680_regmap_spi_select_page(\n\tstruct bme680_spi_bus_context *ctx, u8 reg)\n{\n\tstruct spi_device *spi = ctx->spi;\n\tint ret;\n\tu8 buf[2];\n\tu8 page = (reg & 0x80) ? 0 : 1;  \n\n\tif (page == ctx->current_page)\n\t\treturn 0;\n\n\t \n\tbuf[0] = BME680_REG_STATUS;\n\tret = spi_write_then_read(spi, buf, 1, buf + 1, 1);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"failed to set page %u\\n\", page);\n\t\treturn ret;\n\t}\n\n\tbuf[0] = BME680_REG_STATUS;\n\tif (page)\n\t\tbuf[1] |= BME680_SPI_MEM_PAGE_BIT;\n\telse\n\t\tbuf[1] &= ~BME680_SPI_MEM_PAGE_BIT;\n\n\tret = spi_write(spi, buf, 2);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"failed to set page %u\\n\", page);\n\t\treturn ret;\n\t}\n\n\tctx->current_page = page;\n\n\treturn 0;\n}\n\nstatic int bme680_regmap_spi_write(void *context, const void *data,\n\t\t\t\t   size_t count)\n{\n\tstruct bme680_spi_bus_context *ctx = context;\n\tstruct spi_device *spi = ctx->spi;\n\tint ret;\n\tu8 buf[2];\n\n\tmemcpy(buf, data, 2);\n\n\tret = bme680_regmap_spi_select_page(ctx, buf[0]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbuf[0] &= ~0x80;\n\n\treturn spi_write(spi, buf, 2);\n}\n\nstatic int bme680_regmap_spi_read(void *context, const void *reg,\n\t\t\t\t  size_t reg_size, void *val, size_t val_size)\n{\n\tstruct bme680_spi_bus_context *ctx = context;\n\tstruct spi_device *spi = ctx->spi;\n\tint ret;\n\tu8 addr = *(const u8 *)reg;\n\n\tret = bme680_regmap_spi_select_page(ctx, addr);\n\tif (ret)\n\t\treturn ret;\n\n\taddr |= 0x80;  \n\n\treturn spi_write_then_read(spi, &addr, 1, val, val_size);\n}\n\nstatic struct regmap_bus bme680_regmap_bus = {\n\t.write = bme680_regmap_spi_write,\n\t.read = bme680_regmap_spi_read,\n\t.reg_format_endian_default = REGMAP_ENDIAN_BIG,\n\t.val_format_endian_default = REGMAP_ENDIAN_BIG,\n};\n\nstatic int bme680_spi_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tstruct bme680_spi_bus_context *bus_context;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tspi->bits_per_word = 8;\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"spi_setup failed!\\n\");\n\t\treturn ret;\n\t}\n\n\tbus_context = devm_kzalloc(&spi->dev, sizeof(*bus_context), GFP_KERNEL);\n\tif (!bus_context)\n\t\treturn -ENOMEM;\n\n\tbus_context->spi = spi;\n\tbus_context->current_page = 0xff;  \n\n\tregmap = devm_regmap_init(&spi->dev, &bme680_regmap_bus,\n\t\t\t\t  bus_context, &bme680_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&spi->dev, \"Failed to register spi regmap %ld\\n\", PTR_ERR(regmap));\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\treturn bme680_core_probe(&spi->dev, regmap, id->name);\n}\n\nstatic const struct spi_device_id bme680_spi_id[] = {\n\t{\"bme680\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(spi, bme680_spi_id);\n\nstatic const struct of_device_id bme680_of_spi_match[] = {\n\t{ .compatible = \"bosch,bme680\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bme680_of_spi_match);\n\nstatic struct spi_driver bme680_spi_driver = {\n\t.driver = {\n\t\t.name\t\t\t= \"bme680_spi\",\n\t\t.of_match_table\t\t= bme680_of_spi_match,\n\t},\n\t.probe = bme680_spi_probe,\n\t.id_table = bme680_spi_id,\n};\nmodule_spi_driver(bme680_spi_driver);\n\nMODULE_AUTHOR(\"Himanshu Jha <himanshujha199640@gmail.com>\");\nMODULE_DESCRIPTION(\"Bosch BME680 SPI driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_BME680);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}