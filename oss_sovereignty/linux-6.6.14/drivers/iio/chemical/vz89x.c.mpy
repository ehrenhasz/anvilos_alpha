{
  "module_name": "vz89x.c",
  "hash_id": "d193e215a5df23839b2da788d14a63e1531a3d6f9b8041244aa9fe94c5322c52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/chemical/vz89x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define VZ89X_REG_MEASUREMENT\t\t0x09\n#define VZ89X_REG_MEASUREMENT_RD_SIZE\t6\n#define VZ89X_REG_MEASUREMENT_WR_SIZE\t3\n\n#define VZ89X_VOC_CO2_IDX\t\t0\n#define VZ89X_VOC_SHORT_IDX\t\t1\n#define VZ89X_VOC_TVOC_IDX\t\t2\n#define VZ89X_VOC_RESISTANCE_IDX\t3\n\n#define VZ89TE_REG_MEASUREMENT\t\t0x0c\n#define VZ89TE_REG_MEASUREMENT_RD_SIZE\t7\n#define VZ89TE_REG_MEASUREMENT_WR_SIZE\t6\n\n#define VZ89TE_VOC_TVOC_IDX\t\t0\n#define VZ89TE_VOC_CO2_IDX\t\t1\n#define VZ89TE_VOC_RESISTANCE_IDX\t2\n\nenum {\n\tVZ89X,\n\tVZ89TE,\n};\n\nstruct vz89x_chip_data;\n\nstruct vz89x_data {\n\tstruct i2c_client *client;\n\tconst struct vz89x_chip_data *chip;\n\tstruct mutex lock;\n\tint (*xfer)(struct vz89x_data *data, u8 cmd);\n\n\tbool is_valid;\n\tunsigned long last_update;\n\tu8 buffer[VZ89TE_REG_MEASUREMENT_RD_SIZE];\n};\n\nstruct vz89x_chip_data {\n\tbool (*valid)(struct vz89x_data *data);\n\tconst struct iio_chan_spec *channels;\n\tu8 num_channels;\n\n\tu8 cmd;\n\tu8 read_size;\n\tu8 write_size;\n};\n\nstatic const struct iio_chan_spec vz89x_channels[] = {\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_CO2,\n\t\t.modified = 1,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET) | BIT(IIO_CHAN_INFO_RAW),\n\t\t.address = VZ89X_VOC_CO2_IDX,\n\t},\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_VOC,\n\t\t.modified = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.address = VZ89X_VOC_SHORT_IDX,\n\t\t.extend_name = \"short\",\n\t},\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_VOC,\n\t\t.modified = 1,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET) | BIT(IIO_CHAN_INFO_RAW),\n\t\t.address = VZ89X_VOC_TVOC_IDX,\n\t},\n\t{\n\t\t.type = IIO_RESISTANCE,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = VZ89X_VOC_RESISTANCE_IDX,\n\t\t.scan_index = -1,\n\t\t.scan_type = {\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t},\n};\n\nstatic const struct iio_chan_spec vz89te_channels[] = {\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_VOC,\n\t\t.modified = 1,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET) | BIT(IIO_CHAN_INFO_RAW),\n\t\t.address = VZ89TE_VOC_TVOC_IDX,\n\t},\n\n\t{\n\t\t.type = IIO_CONCENTRATION,\n\t\t.channel2 = IIO_MOD_CO2,\n\t\t.modified = 1,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET) | BIT(IIO_CHAN_INFO_RAW),\n\t\t.address = VZ89TE_VOC_CO2_IDX,\n\t},\n\t{\n\t\t.type = IIO_RESISTANCE,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = VZ89TE_VOC_RESISTANCE_IDX,\n\t\t.scan_index = -1,\n\t\t.scan_type = {\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n};\n\nstatic IIO_CONST_ATTR(in_concentration_co2_scale, \"0.00000698689\");\nstatic IIO_CONST_ATTR(in_concentration_voc_scale, \"0.00000000436681223\");\n\nstatic struct attribute *vz89x_attributes[] = {\n\t&iio_const_attr_in_concentration_co2_scale.dev_attr.attr,\n\t&iio_const_attr_in_concentration_voc_scale.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group vz89x_attrs_group = {\n\t.attrs = vz89x_attributes,\n};\n\n \n\nstatic bool vz89x_measurement_is_valid(struct vz89x_data *data)\n{\n\tif (data->buffer[VZ89X_VOC_SHORT_IDX] == 0)\n\t\treturn true;\n\n\treturn !!(data->buffer[data->chip->read_size - 1] > 0);\n}\n\n \nstatic bool vz89te_measurement_is_valid(struct vz89x_data *data)\n{\n\tu8 crc = 0;\n\tint i, sum = 0;\n\n\tfor (i = 0; i < (data->chip->read_size - 1); i++) {\n\t\tsum = crc + data->buffer[i];\n\t\tcrc = sum;\n\t\tcrc += sum / 256;\n\t}\n\n\treturn !((0xff - crc) == data->buffer[data->chip->read_size - 1]);\n}\n\nstatic int vz89x_i2c_xfer(struct vz89x_data *data, u8 cmd)\n{\n\tconst struct vz89x_chip_data *chip = data->chip;\n\tstruct i2c_client *client = data->client;\n\tstruct i2c_msg msg[2];\n\tint ret;\n\tu8 buf[6] = { cmd, 0, 0, 0, 0, 0xf3 };\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = client->flags;\n\tmsg[0].len = chip->write_size;\n\tmsg[0].buf  = (char *) &buf;\n\n\tmsg[1].addr = client->addr;\n\tmsg[1].flags = client->flags | I2C_M_RD;\n\tmsg[1].len = chip->read_size;\n\tmsg[1].buf = (char *) &data->buffer;\n\n\tret = i2c_transfer(client->adapter, msg, 2);\n\n\treturn (ret == 2) ? 0 : ret;\n}\n\nstatic int vz89x_smbus_xfer(struct vz89x_data *data, u8 cmd)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\tint i;\n\n\tret = i2c_smbus_write_word_data(client, cmd, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < data->chip->read_size; i++) {\n\t\tret = i2c_smbus_read_byte(client);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata->buffer[i] = ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int vz89x_get_measurement(struct vz89x_data *data)\n{\n\tconst struct vz89x_chip_data *chip = data->chip;\n\tint ret;\n\n\t \n\tif (!time_after(jiffies, data->last_update + HZ))\n\t\treturn data->is_valid ? 0 : -EAGAIN;\n\n\tdata->is_valid = false;\n\tdata->last_update = jiffies;\n\n\tret = data->xfer(data, chip->cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = chip->valid(data);\n\tif (ret)\n\t\treturn -EAGAIN;\n\n\tdata->is_valid = true;\n\n\treturn 0;\n}\n\nstatic int vz89x_get_resistance_reading(struct vz89x_data *data,\n\t\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\t\tint *val)\n{\n\tu8 *tmp = &data->buffer[chan->address];\n\n\tswitch (chan->scan_type.endianness) {\n\tcase IIO_LE:\n\t\t*val = le32_to_cpup((__le32 *) tmp) & GENMASK(23, 0);\n\t\tbreak;\n\tcase IIO_BE:\n\t\t*val = be32_to_cpup((__be32 *) tmp) >> 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vz89x_read_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan, int *val,\n\t\t\t  int *val2, long mask)\n{\n\tstruct vz89x_data *data = iio_priv(indio_dev);\n\tint ret = -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&data->lock);\n\t\tret = vz89x_get_measurement(data);\n\t\tmutex_unlock(&data->lock);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_CONCENTRATION:\n\t\t\t*val = data->buffer[chan->address];\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_RESISTANCE:\n\t\t\tret = vz89x_get_resistance_reading(data, chan, val);\n\t\t\tif (!ret)\n\t\t\t\treturn IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_RESISTANCE:\n\t\t\t*val = 10;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (chan->channel2) {\n\t\tcase IIO_MOD_CO2:\n\t\t\t*val = 44;\n\t\t\t*val2 = 250000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_MOD_VOC:\n\t\t\t*val = -13;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic const struct iio_info vz89x_info = {\n\t.attrs\t\t= &vz89x_attrs_group,\n\t.read_raw\t= vz89x_read_raw,\n};\n\nstatic const struct vz89x_chip_data vz89x_chips[] = {\n\t{\n\t\t.valid = vz89x_measurement_is_valid,\n\n\t\t.cmd = VZ89X_REG_MEASUREMENT,\n\t\t.read_size = VZ89X_REG_MEASUREMENT_RD_SIZE,\n\t\t.write_size = VZ89X_REG_MEASUREMENT_WR_SIZE,\n\n\t\t.channels = vz89x_channels,\n\t\t.num_channels = ARRAY_SIZE(vz89x_channels),\n\t},\n\t{\n\t\t.valid = vz89te_measurement_is_valid,\n\n\t\t.cmd = VZ89TE_REG_MEASUREMENT,\n\t\t.read_size = VZ89TE_REG_MEASUREMENT_RD_SIZE,\n\t\t.write_size = VZ89TE_REG_MEASUREMENT_WR_SIZE,\n\n\t\t.channels = vz89te_channels,\n\t\t.num_channels = ARRAY_SIZE(vz89te_channels),\n\t},\n};\n\nstatic const struct of_device_id vz89x_dt_ids[] = {\n\t{ .compatible = \"sgx,vz89x\", .data = (void *) VZ89X },\n\t{ .compatible = \"sgx,vz89te\", .data = (void *) VZ89TE },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, vz89x_dt_ids);\n\nstatic int vz89x_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct vz89x_data *data;\n\tint chip_id;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tdata = iio_priv(indio_dev);\n\n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\tdata->xfer = vz89x_i2c_xfer;\n\telse if (i2c_check_functionality(client->adapter,\n\t\t\t\tI2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_BYTE))\n\t\tdata->xfer = vz89x_smbus_xfer;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\tif (!dev_fwnode(dev))\n\t\tchip_id = id->driver_data;\n\telse\n\t\tchip_id = (unsigned long)device_get_match_data(dev);\n\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tdata->chip = &vz89x_chips[chip_id];\n\tdata->last_update = jiffies - HZ;\n\tmutex_init(&data->lock);\n\n\tindio_dev->info = &vz89x_info;\n\tindio_dev->name = dev_name(dev);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tindio_dev->channels = data->chip->channels;\n\tindio_dev->num_channels = data->chip->num_channels;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct i2c_device_id vz89x_id[] = {\n\t{ \"vz89x\", VZ89X },\n\t{ \"vz89te\", VZ89TE },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, vz89x_id);\n\nstatic struct i2c_driver vz89x_driver = {\n\t.driver = {\n\t\t.name\t= \"vz89x\",\n\t\t.of_match_table = vz89x_dt_ids,\n\t},\n\t.probe = vz89x_probe,\n\t.id_table = vz89x_id,\n};\nmodule_i2c_driver(vz89x_driver);\n\nMODULE_AUTHOR(\"Matt Ranostay <matt.ranostay@konsulko.com>\");\nMODULE_DESCRIPTION(\"SGX Sensortech MiCS VZ89X VOC sensors\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}