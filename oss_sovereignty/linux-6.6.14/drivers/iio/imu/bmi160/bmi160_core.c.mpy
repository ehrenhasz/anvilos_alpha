{
  "module_name": "bmi160_core.c",
  "hash_id": "e83d68d51c8e330f1a6112af64bab012fecd26f4431d1beda53ed8460eece03e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/bmi160/bmi160_core.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n\n#include \"bmi160.h\"\n\n#define BMI160_REG_CHIP_ID\t0x00\n#define BMI160_CHIP_ID_VAL\t0xD1\n\n#define BMI160_REG_PMU_STATUS\t0x03\n\n \n#define BMI160_REG_DATA_MAGN_XOUT_L\t0x04\n#define BMI160_REG_DATA_GYRO_XOUT_L\t0x0C\n#define BMI160_REG_DATA_ACCEL_XOUT_L\t0x12\n\n#define BMI160_REG_ACCEL_CONFIG\t\t0x40\n#define BMI160_ACCEL_CONFIG_ODR_MASK\tGENMASK(3, 0)\n#define BMI160_ACCEL_CONFIG_BWP_MASK\tGENMASK(6, 4)\n\n#define BMI160_REG_ACCEL_RANGE\t\t0x41\n#define BMI160_ACCEL_RANGE_2G\t\t0x03\n#define BMI160_ACCEL_RANGE_4G\t\t0x05\n#define BMI160_ACCEL_RANGE_8G\t\t0x08\n#define BMI160_ACCEL_RANGE_16G\t\t0x0C\n\n#define BMI160_REG_GYRO_CONFIG\t\t0x42\n#define BMI160_GYRO_CONFIG_ODR_MASK\tGENMASK(3, 0)\n#define BMI160_GYRO_CONFIG_BWP_MASK\tGENMASK(5, 4)\n\n#define BMI160_REG_GYRO_RANGE\t\t0x43\n#define BMI160_GYRO_RANGE_2000DPS\t0x00\n#define BMI160_GYRO_RANGE_1000DPS\t0x01\n#define BMI160_GYRO_RANGE_500DPS\t0x02\n#define BMI160_GYRO_RANGE_250DPS\t0x03\n#define BMI160_GYRO_RANGE_125DPS\t0x04\n\n#define BMI160_REG_CMD\t\t\t0x7E\n#define BMI160_CMD_ACCEL_PM_SUSPEND\t0x10\n#define BMI160_CMD_ACCEL_PM_NORMAL\t0x11\n#define BMI160_CMD_ACCEL_PM_LOW_POWER\t0x12\n#define BMI160_CMD_GYRO_PM_SUSPEND\t0x14\n#define BMI160_CMD_GYRO_PM_NORMAL\t0x15\n#define BMI160_CMD_GYRO_PM_FAST_STARTUP\t0x17\n#define BMI160_CMD_SOFTRESET\t\t0xB6\n\n#define BMI160_REG_INT_EN\t\t0x51\n#define BMI160_DRDY_INT_EN\t\tBIT(4)\n\n#define BMI160_REG_INT_OUT_CTRL\t\t0x53\n#define BMI160_INT_OUT_CTRL_MASK\t0x0f\n#define BMI160_INT1_OUT_CTRL_SHIFT\t0\n#define BMI160_INT2_OUT_CTRL_SHIFT\t4\n#define BMI160_EDGE_TRIGGERED\t\tBIT(0)\n#define BMI160_ACTIVE_HIGH\t\tBIT(1)\n#define BMI160_OPEN_DRAIN\t\tBIT(2)\n#define BMI160_OUTPUT_EN\t\tBIT(3)\n\n#define BMI160_REG_INT_LATCH\t\t0x54\n#define BMI160_INT1_LATCH_MASK\t\tBIT(4)\n#define BMI160_INT2_LATCH_MASK\t\tBIT(5)\n\n \n#define BMI160_REG_INT_MAP\t\t0x56\n#define BMI160_INT1_MAP_DRDY_EN\t\t0x80\n#define BMI160_INT2_MAP_DRDY_EN\t\t0x08\n\n#define BMI160_REG_DUMMY\t\t0x7F\n\n#define BMI160_NORMAL_WRITE_USLEEP\t2\n#define BMI160_SUSPENDED_WRITE_USLEEP\t450\n\n#define BMI160_ACCEL_PMU_MIN_USLEEP\t3800\n#define BMI160_GYRO_PMU_MIN_USLEEP\t80000\n#define BMI160_SOFTRESET_USLEEP\t\t1000\n\n#define BMI160_CHANNEL(_type, _axis, _index) {\t\t\t\\\n\t.type = _type,\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##_axis,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |  \\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t\\\n\t.scan_index = _index,\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\\\n\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.endianness = IIO_LE,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.ext_info = bmi160_ext_info,\t\t\t\t\\\n}\n\n \nenum bmi160_scan_axis {\n\tBMI160_SCAN_EXT_MAGN_X = 0,\n\tBMI160_SCAN_EXT_MAGN_Y,\n\tBMI160_SCAN_EXT_MAGN_Z,\n\tBMI160_SCAN_RHALL,\n\tBMI160_SCAN_GYRO_X,\n\tBMI160_SCAN_GYRO_Y,\n\tBMI160_SCAN_GYRO_Z,\n\tBMI160_SCAN_ACCEL_X,\n\tBMI160_SCAN_ACCEL_Y,\n\tBMI160_SCAN_ACCEL_Z,\n\tBMI160_SCAN_TIMESTAMP,\n};\n\nenum bmi160_sensor_type {\n\tBMI160_ACCEL\t= 0,\n\tBMI160_GYRO,\n\tBMI160_EXT_MAGN,\n\tBMI160_NUM_SENSORS  \n};\n\nenum bmi160_int_pin {\n\tBMI160_PIN_INT1,\n\tBMI160_PIN_INT2\n};\n\nconst struct regmap_config bmi160_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\nEXPORT_SYMBOL_NS(bmi160_regmap_config, IIO_BMI160);\n\nstruct bmi160_regs {\n\tu8 data;  \n\tu8 config;\n\tu8 config_odr_mask;\n\tu8 config_bwp_mask;\n\tu8 range;\n\tu8 pmu_cmd_normal;\n\tu8 pmu_cmd_suspend;\n};\n\nstatic struct bmi160_regs bmi160_regs[] = {\n\t[BMI160_ACCEL] = {\n\t\t.data\t= BMI160_REG_DATA_ACCEL_XOUT_L,\n\t\t.config\t= BMI160_REG_ACCEL_CONFIG,\n\t\t.config_odr_mask = BMI160_ACCEL_CONFIG_ODR_MASK,\n\t\t.config_bwp_mask = BMI160_ACCEL_CONFIG_BWP_MASK,\n\t\t.range\t= BMI160_REG_ACCEL_RANGE,\n\t\t.pmu_cmd_normal = BMI160_CMD_ACCEL_PM_NORMAL,\n\t\t.pmu_cmd_suspend = BMI160_CMD_ACCEL_PM_SUSPEND,\n\t},\n\t[BMI160_GYRO] = {\n\t\t.data\t= BMI160_REG_DATA_GYRO_XOUT_L,\n\t\t.config\t= BMI160_REG_GYRO_CONFIG,\n\t\t.config_odr_mask = BMI160_GYRO_CONFIG_ODR_MASK,\n\t\t.config_bwp_mask = BMI160_GYRO_CONFIG_BWP_MASK,\n\t\t.range\t= BMI160_REG_GYRO_RANGE,\n\t\t.pmu_cmd_normal = BMI160_CMD_GYRO_PM_NORMAL,\n\t\t.pmu_cmd_suspend = BMI160_CMD_GYRO_PM_SUSPEND,\n\t},\n};\n\nstatic unsigned long bmi160_pmu_time[] = {\n\t[BMI160_ACCEL] = BMI160_ACCEL_PMU_MIN_USLEEP,\n\t[BMI160_GYRO] = BMI160_GYRO_PMU_MIN_USLEEP,\n};\n\nstruct bmi160_scale {\n\tu8 bits;\n\tint uscale;\n};\n\nstruct bmi160_odr {\n\tu8 bits;\n\tint odr;\n\tint uodr;\n};\n\nstatic const struct bmi160_scale bmi160_accel_scale[] = {\n\t{ BMI160_ACCEL_RANGE_2G, 598},\n\t{ BMI160_ACCEL_RANGE_4G, 1197},\n\t{ BMI160_ACCEL_RANGE_8G, 2394},\n\t{ BMI160_ACCEL_RANGE_16G, 4788},\n};\n\nstatic const struct bmi160_scale bmi160_gyro_scale[] = {\n\t{ BMI160_GYRO_RANGE_2000DPS, 1065},\n\t{ BMI160_GYRO_RANGE_1000DPS, 532},\n\t{ BMI160_GYRO_RANGE_500DPS, 266},\n\t{ BMI160_GYRO_RANGE_250DPS, 133},\n\t{ BMI160_GYRO_RANGE_125DPS, 66},\n};\n\nstruct bmi160_scale_item {\n\tconst struct bmi160_scale *tbl;\n\tint num;\n};\n\nstatic const struct  bmi160_scale_item bmi160_scale_table[] = {\n\t[BMI160_ACCEL] = {\n\t\t.tbl\t= bmi160_accel_scale,\n\t\t.num\t= ARRAY_SIZE(bmi160_accel_scale),\n\t},\n\t[BMI160_GYRO] = {\n\t\t.tbl\t= bmi160_gyro_scale,\n\t\t.num\t= ARRAY_SIZE(bmi160_gyro_scale),\n\t},\n};\n\nstatic const struct bmi160_odr bmi160_accel_odr[] = {\n\t{0x01, 0, 781250},\n\t{0x02, 1, 562500},\n\t{0x03, 3, 125000},\n\t{0x04, 6, 250000},\n\t{0x05, 12, 500000},\n\t{0x06, 25, 0},\n\t{0x07, 50, 0},\n\t{0x08, 100, 0},\n\t{0x09, 200, 0},\n\t{0x0A, 400, 0},\n\t{0x0B, 800, 0},\n\t{0x0C, 1600, 0},\n};\n\nstatic const struct bmi160_odr bmi160_gyro_odr[] = {\n\t{0x06, 25, 0},\n\t{0x07, 50, 0},\n\t{0x08, 100, 0},\n\t{0x09, 200, 0},\n\t{0x0A, 400, 0},\n\t{0x0B, 800, 0},\n\t{0x0C, 1600, 0},\n\t{0x0D, 3200, 0},\n};\n\nstruct bmi160_odr_item {\n\tconst struct bmi160_odr *tbl;\n\tint num;\n};\n\nstatic const struct  bmi160_odr_item bmi160_odr_table[] = {\n\t[BMI160_ACCEL] = {\n\t\t.tbl\t= bmi160_accel_odr,\n\t\t.num\t= ARRAY_SIZE(bmi160_accel_odr),\n\t},\n\t[BMI160_GYRO] = {\n\t\t.tbl\t= bmi160_gyro_odr,\n\t\t.num\t= ARRAY_SIZE(bmi160_gyro_odr),\n\t},\n};\n\nstatic const struct iio_mount_matrix *\nbmi160_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\tconst struct iio_chan_spec *chan)\n{\n\tstruct bmi160_data *data = iio_priv(indio_dev);\n\n\treturn &data->orientation;\n}\n\nstatic const struct iio_chan_spec_ext_info bmi160_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_DIR, bmi160_get_mount_matrix),\n\t{ }\n};\n\nstatic const struct iio_chan_spec bmi160_channels[] = {\n\tBMI160_CHANNEL(IIO_ACCEL, X, BMI160_SCAN_ACCEL_X),\n\tBMI160_CHANNEL(IIO_ACCEL, Y, BMI160_SCAN_ACCEL_Y),\n\tBMI160_CHANNEL(IIO_ACCEL, Z, BMI160_SCAN_ACCEL_Z),\n\tBMI160_CHANNEL(IIO_ANGL_VEL, X, BMI160_SCAN_GYRO_X),\n\tBMI160_CHANNEL(IIO_ANGL_VEL, Y, BMI160_SCAN_GYRO_Y),\n\tBMI160_CHANNEL(IIO_ANGL_VEL, Z, BMI160_SCAN_GYRO_Z),\n\tIIO_CHAN_SOFT_TIMESTAMP(BMI160_SCAN_TIMESTAMP),\n};\n\nstatic enum bmi160_sensor_type bmi160_to_sensor(enum iio_chan_type iio_type)\n{\n\tswitch (iio_type) {\n\tcase IIO_ACCEL:\n\t\treturn BMI160_ACCEL;\n\tcase IIO_ANGL_VEL:\n\t\treturn BMI160_GYRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic\nint bmi160_set_mode(struct bmi160_data *data, enum bmi160_sensor_type t,\n\t\t    bool mode)\n{\n\tint ret;\n\tu8 cmd;\n\n\tif (mode)\n\t\tcmd = bmi160_regs[t].pmu_cmd_normal;\n\telse\n\t\tcmd = bmi160_regs[t].pmu_cmd_suspend;\n\n\tret = regmap_write(data->regmap, BMI160_REG_CMD, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(bmi160_pmu_time[t], bmi160_pmu_time[t] + 1000);\n\n\treturn 0;\n}\n\nstatic\nint bmi160_set_scale(struct bmi160_data *data, enum bmi160_sensor_type t,\n\t\t     int uscale)\n{\n\tint i;\n\n\tfor (i = 0; i < bmi160_scale_table[t].num; i++)\n\t\tif (bmi160_scale_table[t].tbl[i].uscale == uscale)\n\t\t\tbreak;\n\n\tif (i == bmi160_scale_table[t].num)\n\t\treturn -EINVAL;\n\n\treturn regmap_write(data->regmap, bmi160_regs[t].range,\n\t\t\t    bmi160_scale_table[t].tbl[i].bits);\n}\n\nstatic\nint bmi160_get_scale(struct bmi160_data *data, enum bmi160_sensor_type t,\n\t\t     int *uscale)\n{\n\tint i, ret, val;\n\n\tret = regmap_read(data->regmap, bmi160_regs[t].range, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < bmi160_scale_table[t].num; i++)\n\t\tif (bmi160_scale_table[t].tbl[i].bits == val) {\n\t\t\t*uscale = bmi160_scale_table[t].tbl[i].uscale;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -EINVAL;\n}\n\nstatic int bmi160_get_data(struct bmi160_data *data, int chan_type,\n\t\t\t   int axis, int *val)\n{\n\tu8 reg;\n\tint ret;\n\t__le16 sample;\n\tenum bmi160_sensor_type t = bmi160_to_sensor(chan_type);\n\n\treg = bmi160_regs[t].data + (axis - IIO_MOD_X) * sizeof(sample);\n\n\tret = regmap_bulk_read(data->regmap, reg, &sample, sizeof(sample));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = sign_extend32(le16_to_cpu(sample), 15);\n\n\treturn 0;\n}\n\nstatic\nint bmi160_set_odr(struct bmi160_data *data, enum bmi160_sensor_type t,\n\t\t   int odr, int uodr)\n{\n\tint i;\n\n\tfor (i = 0; i < bmi160_odr_table[t].num; i++)\n\t\tif (bmi160_odr_table[t].tbl[i].odr == odr &&\n\t\t    bmi160_odr_table[t].tbl[i].uodr == uodr)\n\t\t\tbreak;\n\n\tif (i >= bmi160_odr_table[t].num)\n\t\treturn -EINVAL;\n\n\treturn regmap_update_bits(data->regmap,\n\t\t\t\t  bmi160_regs[t].config,\n\t\t\t\t  bmi160_regs[t].config_odr_mask,\n\t\t\t\t  bmi160_odr_table[t].tbl[i].bits);\n}\n\nstatic int bmi160_get_odr(struct bmi160_data *data, enum bmi160_sensor_type t,\n\t\t\t  int *odr, int *uodr)\n{\n\tint i, val, ret;\n\n\tret = regmap_read(data->regmap, bmi160_regs[t].config, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= bmi160_regs[t].config_odr_mask;\n\n\tfor (i = 0; i < bmi160_odr_table[t].num; i++)\n\t\tif (val == bmi160_odr_table[t].tbl[i].bits)\n\t\t\tbreak;\n\n\tif (i >= bmi160_odr_table[t].num)\n\t\treturn -EINVAL;\n\n\t*odr = bmi160_odr_table[t].tbl[i].odr;\n\t*uodr = bmi160_odr_table[t].tbl[i].uodr;\n\n\treturn 0;\n}\n\nstatic irqreturn_t bmi160_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct bmi160_data *data = iio_priv(indio_dev);\n\tint i, ret, j = 0, base = BMI160_REG_DATA_MAGN_XOUT_L;\n\t__le16 sample;\n\n\tfor_each_set_bit(i, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\tret = regmap_bulk_read(data->regmap, base + i * sizeof(sample),\n\t\t\t\t       &sample, sizeof(sample));\n\t\tif (ret)\n\t\t\tgoto done;\n\t\tdata->buf[j++] = sample;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, data->buf, pf->timestamp);\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\nstatic int bmi160_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tint ret;\n\tstruct bmi160_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = bmi160_get_data(data, chan->type, chan->channel2, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\tret = bmi160_get_scale(data,\n\t\t\t\t       bmi160_to_sensor(chan->type), val2);\n\t\treturn ret ? ret : IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = bmi160_get_odr(data, bmi160_to_sensor(chan->type),\n\t\t\t\t     val, val2);\n\t\treturn ret ? ret : IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmi160_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct bmi160_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn bmi160_set_scale(data,\n\t\t\t\t\tbmi160_to_sensor(chan->type), val2);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn bmi160_set_odr(data, bmi160_to_sensor(chan->type),\n\t\t\t\t      val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic\nIIO_CONST_ATTR(in_accel_sampling_frequency_available,\n\t       \"0.78125 1.5625 3.125 6.25 12.5 25 50 100 200 400 800 1600\");\nstatic\nIIO_CONST_ATTR(in_anglvel_sampling_frequency_available,\n\t       \"25 50 100 200 400 800 1600 3200\");\nstatic\nIIO_CONST_ATTR(in_accel_scale_available,\n\t       \"0.000598 0.001197 0.002394 0.004788\");\nstatic\nIIO_CONST_ATTR(in_anglvel_scale_available,\n\t       \"0.001065 0.000532 0.000266 0.000133 0.000066\");\n\nstatic struct attribute *bmi160_attrs[] = {\n\t&iio_const_attr_in_accel_sampling_frequency_available.dev_attr.attr,\n\t&iio_const_attr_in_anglvel_sampling_frequency_available.dev_attr.attr,\n\t&iio_const_attr_in_accel_scale_available.dev_attr.attr,\n\t&iio_const_attr_in_anglvel_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group bmi160_attrs_group = {\n\t.attrs = bmi160_attrs,\n};\n\nstatic const struct iio_info bmi160_info = {\n\t.read_raw = bmi160_read_raw,\n\t.write_raw = bmi160_write_raw,\n\t.attrs = &bmi160_attrs_group,\n};\n\nstatic int bmi160_write_conf_reg(struct regmap *regmap, unsigned int reg,\n\t\t\t\t unsigned int mask, unsigned int bits,\n\t\t\t\t unsigned int write_usleep)\n{\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(regmap, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = (val & ~mask) | bits;\n\n\tret = regmap_write(regmap, reg, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(write_usleep, write_usleep + 1000);\n\n\treturn 0;\n}\n\nstatic int bmi160_config_pin(struct regmap *regmap, enum bmi160_int_pin pin,\n\t\t\t     bool open_drain, u8 irq_mask,\n\t\t\t     unsigned long write_usleep)\n{\n\tint ret;\n\tstruct device *dev = regmap_get_device(regmap);\n\tu8 int_out_ctrl_shift;\n\tu8 int_latch_mask;\n\tu8 int_map_mask;\n\tu8 int_out_ctrl_mask;\n\tu8 int_out_ctrl_bits;\n\tconst char *pin_name;\n\n\tswitch (pin) {\n\tcase BMI160_PIN_INT1:\n\t\tint_out_ctrl_shift = BMI160_INT1_OUT_CTRL_SHIFT;\n\t\tint_latch_mask = BMI160_INT1_LATCH_MASK;\n\t\tint_map_mask = BMI160_INT1_MAP_DRDY_EN;\n\t\tbreak;\n\tcase BMI160_PIN_INT2:\n\t\tint_out_ctrl_shift = BMI160_INT2_OUT_CTRL_SHIFT;\n\t\tint_latch_mask = BMI160_INT2_LATCH_MASK;\n\t\tint_map_mask = BMI160_INT2_MAP_DRDY_EN;\n\t\tbreak;\n\t}\n\tint_out_ctrl_mask = BMI160_INT_OUT_CTRL_MASK << int_out_ctrl_shift;\n\n\t \n\tint_out_ctrl_bits = BMI160_OUTPUT_EN;\n\tif (open_drain)\n\t\t \n\t\tint_out_ctrl_bits |= BMI160_OPEN_DRAIN;\n\tint_out_ctrl_bits |= irq_mask;\n\tint_out_ctrl_bits <<= int_out_ctrl_shift;\n\n\tret = bmi160_write_conf_reg(regmap, BMI160_REG_INT_OUT_CTRL,\n\t\t\t\t    int_out_ctrl_mask, int_out_ctrl_bits,\n\t\t\t\t    write_usleep);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = bmi160_write_conf_reg(regmap, BMI160_REG_INT_LATCH,\n\t\t\t\t    int_latch_mask, int_latch_mask,\n\t\t\t\t    write_usleep);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = bmi160_write_conf_reg(regmap, BMI160_REG_INT_MAP,\n\t\t\t\t    int_map_mask, int_map_mask,\n\t\t\t\t    write_usleep);\n\tif (ret) {\n\t\tswitch (pin) {\n\t\tcase BMI160_PIN_INT1:\n\t\t\tpin_name = \"INT1\";\n\t\t\tbreak;\n\t\tcase BMI160_PIN_INT2:\n\t\t\tpin_name = \"INT2\";\n\t\t\tbreak;\n\t\t}\n\t\tdev_err(dev, \"Failed to configure %s IRQ pin\", pin_name);\n\t}\n\n\treturn ret;\n}\n\nint bmi160_enable_irq(struct regmap *regmap, bool enable)\n{\n\tunsigned int enable_bit = 0;\n\n\tif (enable)\n\t\tenable_bit = BMI160_DRDY_INT_EN;\n\n\treturn bmi160_write_conf_reg(regmap, BMI160_REG_INT_EN,\n\t\t\t\t     BMI160_DRDY_INT_EN, enable_bit,\n\t\t\t\t     BMI160_NORMAL_WRITE_USLEEP);\n}\nEXPORT_SYMBOL_NS(bmi160_enable_irq, IIO_BMI160);\n\nstatic int bmi160_get_irq(struct fwnode_handle *fwnode, enum bmi160_int_pin *pin)\n{\n\tint irq;\n\n\t \n\tirq = fwnode_irq_get_byname(fwnode, \"INT1\");\n\tif (irq > 0) {\n\t\t*pin = BMI160_PIN_INT1;\n\t\treturn irq;\n\t}\n\n\tirq = fwnode_irq_get_byname(fwnode, \"INT2\");\n\tif (irq > 0)\n\t\t*pin = BMI160_PIN_INT2;\n\n\treturn irq;\n}\n\nstatic int bmi160_config_device_irq(struct iio_dev *indio_dev, int irq_type,\n\t\t\t\t    enum bmi160_int_pin pin)\n{\n\tbool open_drain;\n\tu8 irq_mask;\n\tstruct bmi160_data *data = iio_priv(indio_dev);\n\tstruct device *dev = regmap_get_device(data->regmap);\n\n\t \n\tif (irq_type == IRQF_TRIGGER_RISING)\n\t\tirq_mask = BMI160_ACTIVE_HIGH | BMI160_EDGE_TRIGGERED;\n\telse if (irq_type == IRQF_TRIGGER_FALLING)\n\t\tirq_mask = BMI160_EDGE_TRIGGERED;\n\telse if (irq_type == IRQF_TRIGGER_HIGH)\n\t\tirq_mask = BMI160_ACTIVE_HIGH;\n\telse if (irq_type == IRQF_TRIGGER_LOW)\n\t\tirq_mask = 0;\n\telse {\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\"Invalid interrupt type 0x%x specified\\n\", irq_type);\n\t\treturn -EINVAL;\n\t}\n\n\topen_drain = device_property_read_bool(dev, \"drive-open-drain\");\n\n\treturn bmi160_config_pin(data->regmap, pin, open_drain, irq_mask,\n\t\t\t\t BMI160_NORMAL_WRITE_USLEEP);\n}\n\nstatic int bmi160_setup_irq(struct iio_dev *indio_dev, int irq,\n\t\t\t    enum bmi160_int_pin pin)\n{\n\tstruct irq_data *desc;\n\tu32 irq_type;\n\tint ret;\n\n\tdesc = irq_get_irq_data(irq);\n\tif (!desc) {\n\t\tdev_err(&indio_dev->dev, \"Could not find IRQ %d\\n\", irq);\n\t\treturn -EINVAL;\n\t}\n\n\tirq_type = irqd_get_trigger_type(desc);\n\n\tret = bmi160_config_device_irq(indio_dev, irq_type, pin);\n\tif (ret)\n\t\treturn ret;\n\n\treturn bmi160_probe_trigger(indio_dev, irq, irq_type);\n}\n\nstatic int bmi160_chip_init(struct bmi160_data *data, bool use_spi)\n{\n\tint ret;\n\tunsigned int val;\n\tstruct device *dev = regmap_get_device(data->regmap);\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(data->supplies), data->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(data->regmap, BMI160_REG_CMD, BMI160_CMD_SOFTRESET);\n\tif (ret)\n\t\tgoto disable_regulator;\n\n\tusleep_range(BMI160_SOFTRESET_USLEEP, BMI160_SOFTRESET_USLEEP + 1);\n\n\t \n\tif (use_spi) {\n\t\tret = regmap_read(data->regmap, BMI160_REG_DUMMY, &val);\n\t\tif (ret)\n\t\t\tgoto disable_regulator;\n\t}\n\n\tret = regmap_read(data->regmap, BMI160_REG_CHIP_ID, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"Error reading chip id\\n\");\n\t\tgoto disable_regulator;\n\t}\n\tif (val != BMI160_CHIP_ID_VAL) {\n\t\tdev_err(dev, \"Wrong chip id, got %x expected %x\\n\",\n\t\t\tval, BMI160_CHIP_ID_VAL);\n\t\tret = -ENODEV;\n\t\tgoto disable_regulator;\n\t}\n\n\tret = bmi160_set_mode(data, BMI160_ACCEL, true);\n\tif (ret)\n\t\tgoto disable_regulator;\n\n\tret = bmi160_set_mode(data, BMI160_GYRO, true);\n\tif (ret)\n\t\tgoto disable_accel;\n\n\treturn 0;\n\ndisable_accel:\n\tbmi160_set_mode(data, BMI160_ACCEL, false);\n\ndisable_regulator:\n\tregulator_bulk_disable(ARRAY_SIZE(data->supplies), data->supplies);\n\treturn ret;\n}\n\nstatic int bmi160_data_rdy_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t     bool enable)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct bmi160_data *data = iio_priv(indio_dev);\n\n\treturn bmi160_enable_irq(data->regmap, enable);\n}\n\nstatic const struct iio_trigger_ops bmi160_trigger_ops = {\n\t.set_trigger_state = &bmi160_data_rdy_trigger_set_state,\n};\n\nint bmi160_probe_trigger(struct iio_dev *indio_dev, int irq, u32 irq_type)\n{\n\tstruct bmi160_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tdata->trig = devm_iio_trigger_alloc(&indio_dev->dev, \"%s-dev%d\",\n\t\t\t\t\t    indio_dev->name,\n\t\t\t\t\t    iio_device_id(indio_dev));\n\n\tif (data->trig == NULL)\n\t\treturn -ENOMEM;\n\n\tret = devm_request_irq(&indio_dev->dev, irq,\n\t\t\t       &iio_trigger_generic_data_rdy_poll,\n\t\t\t       irq_type, \"bmi160\", data->trig);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->trig->dev.parent = regmap_get_device(data->regmap);\n\tdata->trig->ops = &bmi160_trigger_ops;\n\tiio_trigger_set_drvdata(data->trig, indio_dev);\n\n\tret = devm_iio_trigger_register(&indio_dev->dev, data->trig);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->trig = iio_trigger_get(data->trig);\n\n\treturn 0;\n}\n\nstatic void bmi160_chip_uninit(void *data)\n{\n\tstruct bmi160_data *bmi_data = data;\n\tstruct device *dev = regmap_get_device(bmi_data->regmap);\n\tint ret;\n\n\tbmi160_set_mode(bmi_data, BMI160_GYRO, false);\n\tbmi160_set_mode(bmi_data, BMI160_ACCEL, false);\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(bmi_data->supplies),\n\t\t\t\t     bmi_data->supplies);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to disable regulators: %d\\n\", ret);\n}\n\nint bmi160_core_probe(struct device *dev, struct regmap *regmap,\n\t\t      const char *name, bool use_spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct bmi160_data *data;\n\tint irq;\n\tenum bmi160_int_pin int_pin;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdev_set_drvdata(dev, indio_dev);\n\tdata->regmap = regmap;\n\n\tdata->supplies[0].supply = \"vdd\";\n\tdata->supplies[1].supply = \"vddio\";\n\tret = devm_regulator_bulk_get(dev,\n\t\t\t\t      ARRAY_SIZE(data->supplies),\n\t\t\t\t      data->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = iio_read_mount_matrix(dev, &data->orientation);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bmi160_chip_init(data, use_spi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, bmi160_chip_uninit, data);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->channels = bmi160_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(bmi160_channels);\n\tindio_dev->name = name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &bmi160_info;\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev,\n\t\t\t\t\t      iio_pollfunc_store_time,\n\t\t\t\t\t      bmi160_trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tirq = bmi160_get_irq(dev_fwnode(dev), &int_pin);\n\tif (irq > 0) {\n\t\tret = bmi160_setup_irq(indio_dev, irq, int_pin);\n\t\tif (ret)\n\t\t\tdev_err(&indio_dev->dev, \"Failed to setup IRQ %d\\n\",\n\t\t\t\tirq);\n\t} else {\n\t\tdev_info(&indio_dev->dev, \"Not setting up IRQ trigger\\n\");\n\t}\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(bmi160_core_probe, IIO_BMI160);\n\nMODULE_AUTHOR(\"Daniel Baluta <daniel.baluta@intel.com>\");\nMODULE_DESCRIPTION(\"Bosch BMI160 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}