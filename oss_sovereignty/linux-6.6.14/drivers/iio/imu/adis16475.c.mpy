{
  "module_name": "adis16475.c",
  "hash_id": "44b49e8459fc0c2257b0f684c8b61e22cd00ea7e18f24c2a32a68b8818195272",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/adis16475.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/imu/adis.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/irq.h>\n#include <linux/lcm.h>\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n\n#define ADIS16475_REG_DIAG_STAT\t\t0x02\n#define ADIS16475_REG_X_GYRO_L\t\t0x04\n#define ADIS16475_REG_Y_GYRO_L\t\t0x08\n#define ADIS16475_REG_Z_GYRO_L\t\t0x0C\n#define ADIS16475_REG_X_ACCEL_L\t\t0x10\n#define ADIS16475_REG_Y_ACCEL_L\t\t0x14\n#define ADIS16475_REG_Z_ACCEL_L\t\t0x18\n#define ADIS16475_REG_TEMP_OUT\t\t0x1c\n#define ADIS16475_REG_X_GYRO_BIAS_L\t0x40\n#define ADIS16475_REG_Y_GYRO_BIAS_L\t0x44\n#define ADIS16475_REG_Z_GYRO_BIAS_L\t0x48\n#define ADIS16475_REG_X_ACCEL_BIAS_L\t0x4c\n#define ADIS16475_REG_Y_ACCEL_BIAS_L\t0x50\n#define ADIS16475_REG_Z_ACCEL_BIAS_L\t0x54\n#define ADIS16475_REG_FILT_CTRL\t\t0x5c\n#define ADIS16475_FILT_CTRL_MASK\tGENMASK(2, 0)\n#define ADIS16475_FILT_CTRL(x)\t\tFIELD_PREP(ADIS16475_FILT_CTRL_MASK, x)\n#define ADIS16475_REG_MSG_CTRL\t\t0x60\n#define ADIS16475_MSG_CTRL_DR_POL_MASK\tBIT(0)\n#define ADIS16475_MSG_CTRL_DR_POL(x) \\\n\t\t\t\tFIELD_PREP(ADIS16475_MSG_CTRL_DR_POL_MASK, x)\n#define ADIS16475_SYNC_MODE_MASK\tGENMASK(4, 2)\n#define ADIS16475_SYNC_MODE(x)\t\tFIELD_PREP(ADIS16475_SYNC_MODE_MASK, x)\n#define ADIS16475_REG_UP_SCALE\t\t0x62\n#define ADIS16475_REG_DEC_RATE\t\t0x64\n#define ADIS16475_REG_GLOB_CMD\t\t0x68\n#define ADIS16475_REG_FIRM_REV\t\t0x6c\n#define ADIS16475_REG_FIRM_DM\t\t0x6e\n#define ADIS16475_REG_FIRM_Y\t\t0x70\n#define ADIS16475_REG_PROD_ID\t\t0x72\n#define ADIS16475_REG_SERIAL_NUM\t0x74\n#define ADIS16475_REG_FLASH_CNT\t\t0x7c\n#define ADIS16500_BURST32_MASK\t\tBIT(9)\n#define ADIS16500_BURST32(x)\t\tFIELD_PREP(ADIS16500_BURST32_MASK, x)\n \n#define ADIS16475_BURST32_MAX_DATA\t32\n#define ADIS16475_BURST_MAX_DATA\t20\n#define ADIS16475_MAX_SCAN_DATA\t\t20\n \n#define ADIS16475_BURST_MAX_SPEED\t1000000\n#define ADIS16475_LSB_DEC_MASK\t\t0\n#define ADIS16475_LSB_FIR_MASK\t\t1\n\nenum {\n\tADIS16475_SYNC_DIRECT = 1,\n\tADIS16475_SYNC_SCALED,\n\tADIS16475_SYNC_OUTPUT,\n\tADIS16475_SYNC_PULSE = 5,\n};\n\nstruct adis16475_sync {\n\tu16 sync_mode;\n\tu16 min_rate;\n\tu16 max_rate;\n};\n\nstruct adis16475_chip_info {\n\tconst struct iio_chan_spec *channels;\n\tconst struct adis16475_sync *sync;\n\tconst struct adis_data adis_data;\n\tconst char *name;\n\tu32 num_channels;\n\tu32 gyro_max_val;\n\tu32 gyro_max_scale;\n\tu32 accel_max_val;\n\tu32 accel_max_scale;\n\tu32 temp_scale;\n\tu32 int_clk;\n\tu16 max_dec;\n\tu8 num_sync;\n\tbool has_burst32;\n};\n\nstruct adis16475 {\n\tconst struct adis16475_chip_info *info;\n\tstruct adis adis;\n\tu32 clk_freq;\n\tbool burst32;\n\tunsigned long lsb_flag;\n\tu16 sync_mode;\n\t \n\t__be16 data[ADIS16475_MAX_SCAN_DATA] __aligned(8);\n};\n\nenum {\n\tADIS16475_SCAN_GYRO_X,\n\tADIS16475_SCAN_GYRO_Y,\n\tADIS16475_SCAN_GYRO_Z,\n\tADIS16475_SCAN_ACCEL_X,\n\tADIS16475_SCAN_ACCEL_Y,\n\tADIS16475_SCAN_ACCEL_Z,\n\tADIS16475_SCAN_TEMP,\n};\n\nstatic bool low_rate_allow;\nmodule_param(low_rate_allow, bool, 0444);\nMODULE_PARM_DESC(low_rate_allow,\n\t\t \"Allow IMU rates below the minimum advisable when external clk is used in SCALED mode (default: N)\");\n\n#ifdef CONFIG_DEBUG_FS\nstatic ssize_t adis16475_show_firmware_revision(struct file *file,\n\t\t\t\t\t\tchar __user *userbuf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct adis16475 *st = file->private_data;\n\tchar buf[7];\n\tsize_t len;\n\tu16 rev;\n\tint ret;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16475_REG_FIRM_REV, &rev);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = scnprintf(buf, sizeof(buf), \"%x.%x\\n\", rev >> 8, rev & 0xff);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations adis16475_firmware_revision_fops = {\n\t.open = simple_open,\n\t.read = adis16475_show_firmware_revision,\n\t.llseek = default_llseek,\n\t.owner = THIS_MODULE,\n};\n\nstatic ssize_t adis16475_show_firmware_date(struct file *file,\n\t\t\t\t\t    char __user *userbuf,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct adis16475 *st = file->private_data;\n\tu16 md, year;\n\tchar buf[12];\n\tsize_t len;\n\tint ret;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16475_REG_FIRM_Y, &year);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16475_REG_FIRM_DM, &md);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = snprintf(buf, sizeof(buf), \"%.2x-%.2x-%.4x\\n\", md >> 8, md & 0xff,\n\t\t       year);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations adis16475_firmware_date_fops = {\n\t.open = simple_open,\n\t.read = adis16475_show_firmware_date,\n\t.llseek = default_llseek,\n\t.owner = THIS_MODULE,\n};\n\nstatic int adis16475_show_serial_number(void *arg, u64 *val)\n{\n\tstruct adis16475 *st = arg;\n\tu16 serial;\n\tint ret;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16475_REG_SERIAL_NUM, &serial);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = serial;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(adis16475_serial_number_fops,\n\t\t\t adis16475_show_serial_number, NULL, \"0x%.4llx\\n\");\n\nstatic int adis16475_show_product_id(void *arg, u64 *val)\n{\n\tstruct adis16475 *st = arg;\n\tu16 prod_id;\n\tint ret;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16475_REG_PROD_ID, &prod_id);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = prod_id;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(adis16475_product_id_fops,\n\t\t\t adis16475_show_product_id, NULL, \"%llu\\n\");\n\nstatic int adis16475_show_flash_count(void *arg, u64 *val)\n{\n\tstruct adis16475 *st = arg;\n\tu32 flash_count;\n\tint ret;\n\n\tret = adis_read_reg_32(&st->adis, ADIS16475_REG_FLASH_CNT,\n\t\t\t       &flash_count);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = flash_count;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(adis16475_flash_count_fops,\n\t\t\t adis16475_show_flash_count, NULL, \"%lld\\n\");\n\nstatic void adis16475_debugfs_init(struct iio_dev *indio_dev)\n{\n\tstruct adis16475 *st = iio_priv(indio_dev);\n\tstruct dentry *d = iio_get_debugfs_dentry(indio_dev);\n\n\tdebugfs_create_file_unsafe(\"serial_number\", 0400,\n\t\t\t\t   d, st, &adis16475_serial_number_fops);\n\tdebugfs_create_file_unsafe(\"product_id\", 0400,\n\t\t\t\t   d, st, &adis16475_product_id_fops);\n\tdebugfs_create_file_unsafe(\"flash_count\", 0400,\n\t\t\t\t   d, st, &adis16475_flash_count_fops);\n\tdebugfs_create_file(\"firmware_revision\", 0400,\n\t\t\t    d, st, &adis16475_firmware_revision_fops);\n\tdebugfs_create_file(\"firmware_date\", 0400, d,\n\t\t\t    st, &adis16475_firmware_date_fops);\n}\n#else\nstatic void adis16475_debugfs_init(struct iio_dev *indio_dev)\n{\n}\n#endif\n\nstatic int adis16475_get_freq(struct adis16475 *st, u32 *freq)\n{\n\tint ret;\n\tu16 dec;\n\tu32 sample_rate = st->clk_freq;\n\n\tadis_dev_lock(&st->adis);\n\n\tif (st->sync_mode == ADIS16475_SYNC_SCALED) {\n\t\tu16 sync_scale;\n\n\t\tret = __adis_read_reg_16(&st->adis, ADIS16475_REG_UP_SCALE, &sync_scale);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tsample_rate = st->clk_freq * sync_scale;\n\t}\n\n\tret = __adis_read_reg_16(&st->adis, ADIS16475_REG_DEC_RATE, &dec);\n\tif (ret)\n\t\tgoto error;\n\n\tadis_dev_unlock(&st->adis);\n\n\t*freq = DIV_ROUND_CLOSEST(sample_rate, dec + 1);\n\n\treturn 0;\nerror:\n\tadis_dev_unlock(&st->adis);\n\treturn ret;\n}\n\nstatic int adis16475_set_freq(struct adis16475 *st, const u32 freq)\n{\n\tu16 dec;\n\tint ret;\n\tu32 sample_rate = st->clk_freq;\n\n\tif (!freq)\n\t\treturn -EINVAL;\n\n\tadis_dev_lock(&st->adis);\n\t \n\tif (st->sync_mode == ADIS16475_SYNC_SCALED) {\n\t\tunsigned long scaled_rate = lcm(st->clk_freq, freq);\n\t\tint sync_scale;\n\n\t\t \n\t\tif (scaled_rate > 2100000)\n\t\t\tscaled_rate = 2100000 / st->clk_freq * st->clk_freq;\n\t\telse\n\t\t\tscaled_rate = 2100000 / scaled_rate * scaled_rate;\n\n\t\t \n\t\tif (scaled_rate < 1900000 && !low_rate_allow)\n\t\t\tscaled_rate = roundup(1900000, st->clk_freq);\n\n\t\tsync_scale = scaled_rate / st->clk_freq;\n\t\tret = __adis_write_reg_16(&st->adis, ADIS16475_REG_UP_SCALE, sync_scale);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tsample_rate = scaled_rate;\n\t}\n\n\tdec = DIV_ROUND_CLOSEST(sample_rate, freq);\n\n\tif (dec)\n\t\tdec--;\n\n\tif (dec > st->info->max_dec)\n\t\tdec = st->info->max_dec;\n\n\tret = __adis_write_reg_16(&st->adis, ADIS16475_REG_DEC_RATE, dec);\n\tif (ret)\n\t\tgoto error;\n\n\tadis_dev_unlock(&st->adis);\n\t \n\tassign_bit(ADIS16475_LSB_DEC_MASK, &st->lsb_flag, dec);\n\n\treturn 0;\nerror:\n\tadis_dev_unlock(&st->adis);\n\treturn ret;\n}\n\n \nstatic const u32 adis16475_3db_freqs[] = {\n\t[0] = 720,  \n\t[1] = 360,\n\t[2] = 164,\n\t[3] = 80,\n\t[4] = 40,\n\t[5] = 20,\n\t[6] = 10,\n};\n\nstatic int adis16475_get_filter(struct adis16475 *st, u32 *filter)\n{\n\tu16 filter_sz;\n\tint ret;\n\tconst int mask = ADIS16475_FILT_CTRL_MASK;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16475_REG_FILT_CTRL, &filter_sz);\n\tif (ret)\n\t\treturn ret;\n\n\t*filter = adis16475_3db_freqs[filter_sz & mask];\n\n\treturn 0;\n}\n\nstatic int adis16475_set_filter(struct adis16475 *st, const u32 filter)\n{\n\tint i = ARRAY_SIZE(adis16475_3db_freqs);\n\tint ret;\n\n\twhile (--i) {\n\t\tif (adis16475_3db_freqs[i] >= filter)\n\t\t\tbreak;\n\t}\n\n\tret = adis_write_reg_16(&st->adis, ADIS16475_REG_FILT_CTRL,\n\t\t\t\tADIS16475_FILT_CTRL(i));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tassign_bit(ADIS16475_LSB_FIR_MASK, &st->lsb_flag, i);\n\n\treturn 0;\n}\n\nstatic const u32 adis16475_calib_regs[] = {\n\t[ADIS16475_SCAN_GYRO_X] = ADIS16475_REG_X_GYRO_BIAS_L,\n\t[ADIS16475_SCAN_GYRO_Y] = ADIS16475_REG_Y_GYRO_BIAS_L,\n\t[ADIS16475_SCAN_GYRO_Z] = ADIS16475_REG_Z_GYRO_BIAS_L,\n\t[ADIS16475_SCAN_ACCEL_X] = ADIS16475_REG_X_ACCEL_BIAS_L,\n\t[ADIS16475_SCAN_ACCEL_Y] = ADIS16475_REG_Y_ACCEL_BIAS_L,\n\t[ADIS16475_SCAN_ACCEL_Z] = ADIS16475_REG_Z_ACCEL_BIAS_L,\n};\n\nstatic int adis16475_read_raw(struct iio_dev *indio_dev,\n\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t      int *val, int *val2, long info)\n{\n\tstruct adis16475 *st = iio_priv(indio_dev);\n\tint ret;\n\tu32 tmp;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn adis_single_conversion(indio_dev, chan, 0, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\t*val = st->info->gyro_max_val;\n\t\t\t*val2 = st->info->gyro_max_scale;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_ACCEL:\n\t\t\t*val = st->info->accel_max_val;\n\t\t\t*val2 = st->info->accel_max_scale;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_TEMP:\n\t\t\t*val = st->info->temp_scale;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = adis_read_reg_32(&st->adis,\n\t\t\t\t       adis16475_calib_regs[chan->scan_index],\n\t\t\t\t       val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tret = adis16475_get_filter(st, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = adis16475_get_freq(st, &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = tmp / 1000;\n\t\t*val2 = (tmp % 1000) * 1000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adis16475_write_raw(struct iio_dev *indio_dev,\n\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t       int val, int val2, long info)\n{\n\tstruct adis16475 *st = iio_priv(indio_dev);\n\tu32 tmp;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\ttmp = val * 1000 + val2 / 1000;\n\t\treturn adis16475_set_freq(st, tmp);\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn adis16475_set_filter(st, val);\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treturn adis_write_reg_32(&st->adis,\n\t\t\t\t\t adis16475_calib_regs[chan->scan_index],\n\t\t\t\t\t val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#define ADIS16475_MOD_CHAN(_type, _mod, _address, _si, _r_bits, _s_bits) \\\n\t{ \\\n\t\t.type = (_type), \\\n\t\t.modified = 1, \\\n\t\t.channel2 = (_mod), \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS), \\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY), \\\n\t\t.address = (_address), \\\n\t\t.scan_index = (_si), \\\n\t\t.scan_type = { \\\n\t\t\t.sign = 's', \\\n\t\t\t.realbits = (_r_bits), \\\n\t\t\t.storagebits = (_s_bits), \\\n\t\t\t.endianness = IIO_BE, \\\n\t\t}, \\\n\t}\n\n#define ADIS16475_GYRO_CHANNEL(_mod) \\\n\tADIS16475_MOD_CHAN(IIO_ANGL_VEL, IIO_MOD_ ## _mod, \\\n\t\t\t   ADIS16475_REG_ ## _mod ## _GYRO_L, \\\n\t\t\t   ADIS16475_SCAN_GYRO_ ## _mod, 32, 32)\n\n#define ADIS16475_ACCEL_CHANNEL(_mod) \\\n\tADIS16475_MOD_CHAN(IIO_ACCEL, IIO_MOD_ ## _mod, \\\n\t\t\t   ADIS16475_REG_ ## _mod ## _ACCEL_L, \\\n\t\t\t   ADIS16475_SCAN_ACCEL_ ## _mod, 32, 32)\n\n#define ADIS16475_TEMP_CHANNEL() { \\\n\t\t.type = IIO_TEMP, \\\n\t\t.indexed = 1, \\\n\t\t.channel = 0, \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE), \\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY), \\\n\t\t.address = ADIS16475_REG_TEMP_OUT, \\\n\t\t.scan_index = ADIS16475_SCAN_TEMP, \\\n\t\t.scan_type = { \\\n\t\t\t.sign = 's', \\\n\t\t\t.realbits = 16, \\\n\t\t\t.storagebits = 16, \\\n\t\t\t.endianness = IIO_BE, \\\n\t\t}, \\\n\t}\n\nstatic const struct iio_chan_spec adis16475_channels[] = {\n\tADIS16475_GYRO_CHANNEL(X),\n\tADIS16475_GYRO_CHANNEL(Y),\n\tADIS16475_GYRO_CHANNEL(Z),\n\tADIS16475_ACCEL_CHANNEL(X),\n\tADIS16475_ACCEL_CHANNEL(Y),\n\tADIS16475_ACCEL_CHANNEL(Z),\n\tADIS16475_TEMP_CHANNEL(),\n\tIIO_CHAN_SOFT_TIMESTAMP(7)\n};\n\nenum adis16475_variant {\n\tADIS16470,\n\tADIS16475_1,\n\tADIS16475_2,\n\tADIS16475_3,\n\tADIS16477_1,\n\tADIS16477_2,\n\tADIS16477_3,\n\tADIS16465_1,\n\tADIS16465_2,\n\tADIS16465_3,\n\tADIS16467_1,\n\tADIS16467_2,\n\tADIS16467_3,\n\tADIS16500,\n\tADIS16505_1,\n\tADIS16505_2,\n\tADIS16505_3,\n\tADIS16507_1,\n\tADIS16507_2,\n\tADIS16507_3,\n};\n\nenum {\n\tADIS16475_DIAG_STAT_DATA_PATH = 1,\n\tADIS16475_DIAG_STAT_FLASH_MEM,\n\tADIS16475_DIAG_STAT_SPI,\n\tADIS16475_DIAG_STAT_STANDBY,\n\tADIS16475_DIAG_STAT_SENSOR,\n\tADIS16475_DIAG_STAT_MEMORY,\n\tADIS16475_DIAG_STAT_CLK,\n};\n\nstatic const char * const adis16475_status_error_msgs[] = {\n\t[ADIS16475_DIAG_STAT_DATA_PATH] = \"Data Path Overrun\",\n\t[ADIS16475_DIAG_STAT_FLASH_MEM] = \"Flash memory update failure\",\n\t[ADIS16475_DIAG_STAT_SPI] = \"SPI communication error\",\n\t[ADIS16475_DIAG_STAT_STANDBY] = \"Standby mode\",\n\t[ADIS16475_DIAG_STAT_SENSOR] = \"Sensor failure\",\n\t[ADIS16475_DIAG_STAT_MEMORY] = \"Memory failure\",\n\t[ADIS16475_DIAG_STAT_CLK] = \"Clock error\",\n};\n\n#define ADIS16475_DATA(_prod_id, _timeouts)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.msc_ctrl_reg = ADIS16475_REG_MSG_CTRL,\t\t\t\t\\\n\t.glob_cmd_reg = ADIS16475_REG_GLOB_CMD,\t\t\t\t\\\n\t.diag_stat_reg = ADIS16475_REG_DIAG_STAT,\t\t\t\\\n\t.prod_id_reg = ADIS16475_REG_PROD_ID,\t\t\t\t\\\n\t.prod_id = (_prod_id),\t\t\t\t\t\t\\\n\t.self_test_mask = BIT(2),\t\t\t\t\t\\\n\t.self_test_reg = ADIS16475_REG_GLOB_CMD,\t\t\t\\\n\t.cs_change_delay = 16,\t\t\t\t\t\t\\\n\t.read_delay = 5,\t\t\t\t\t\t\\\n\t.write_delay = 5,\t\t\t\t\t\t\\\n\t.status_error_msgs = adis16475_status_error_msgs,\t\t\\\n\t.status_error_mask = BIT(ADIS16475_DIAG_STAT_DATA_PATH) |\t\\\n\t\tBIT(ADIS16475_DIAG_STAT_FLASH_MEM) |\t\t\t\\\n\t\tBIT(ADIS16475_DIAG_STAT_SPI) |\t\t\t\t\\\n\t\tBIT(ADIS16475_DIAG_STAT_STANDBY) |\t\t\t\\\n\t\tBIT(ADIS16475_DIAG_STAT_SENSOR) |\t\t\t\\\n\t\tBIT(ADIS16475_DIAG_STAT_MEMORY) |\t\t\t\\\n\t\tBIT(ADIS16475_DIAG_STAT_CLK),\t\t\t\t\\\n\t.unmasked_drdy = true,\t\t\t\t\t\t\\\n\t.timeouts = (_timeouts),\t\t\t\t\t\\\n\t.burst_reg_cmd = ADIS16475_REG_GLOB_CMD,\t\t\t\\\n\t.burst_len = ADIS16475_BURST_MAX_DATA,\t\t\t\t\\\n\t.burst_max_len = ADIS16475_BURST32_MAX_DATA,\t\t\t\\\n\t.burst_max_speed_hz = ADIS16475_BURST_MAX_SPEED\t\t\t\\\n}\n\nstatic const struct adis16475_sync adis16475_sync_mode[] = {\n\t{ ADIS16475_SYNC_OUTPUT },\n\t{ ADIS16475_SYNC_DIRECT, 1900, 2100 },\n\t{ ADIS16475_SYNC_SCALED, 1, 128 },\n\t{ ADIS16475_SYNC_PULSE, 1000, 2100 },\n};\n\nstatic const struct adis_timeout adis16475_timeouts = {\n\t.reset_ms = 200,\n\t.sw_reset_ms = 200,\n\t.self_test_ms = 20,\n};\n\nstatic const struct adis_timeout adis1650x_timeouts = {\n\t.reset_ms = 260,\n\t.sw_reset_ms = 260,\n\t.self_test_ms = 30,\n};\n\nstatic const struct adis16475_chip_info adis16475_chip_info[] = {\n\t[ADIS16470] = {\n\t\t.name = \"adis16470\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(10 << 16),\n\t\t.accel_max_val = 1,\n\t\t.accel_max_scale = IIO_M_S_2_TO_G(800 << 16),\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode),\n\t\t.adis_data = ADIS16475_DATA(16470, &adis16475_timeouts),\n\t},\n\t[ADIS16475_1] = {\n\t\t.name = \"adis16475-1\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(160 << 16),\n\t\t.accel_max_val = 1,\n\t\t.accel_max_scale = IIO_M_S_2_TO_G(4000 << 16),\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode),\n\t\t.adis_data = ADIS16475_DATA(16475, &adis16475_timeouts),\n\t},\n\t[ADIS16475_2] = {\n\t\t.name = \"adis16475-2\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(40 << 16),\n\t\t.accel_max_val = 1,\n\t\t.accel_max_scale = IIO_M_S_2_TO_G(4000 << 16),\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode),\n\t\t.adis_data = ADIS16475_DATA(16475, &adis16475_timeouts),\n\t},\n\t[ADIS16475_3] = {\n\t\t.name = \"adis16475-3\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(10 << 16),\n\t\t.accel_max_val = 1,\n\t\t.accel_max_scale = IIO_M_S_2_TO_G(4000 << 16),\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode),\n\t\t.adis_data = ADIS16475_DATA(16475, &adis16475_timeouts),\n\t},\n\t[ADIS16477_1] = {\n\t\t.name = \"adis16477-1\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(160 << 16),\n\t\t.accel_max_val = 1,\n\t\t.accel_max_scale = IIO_M_S_2_TO_G(800 << 16),\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode),\n\t\t.has_burst32 = true,\n\t\t.adis_data = ADIS16475_DATA(16477, &adis16475_timeouts),\n\t},\n\t[ADIS16477_2] = {\n\t\t.name = \"adis16477-2\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(40 << 16),\n\t\t.accel_max_val = 1,\n\t\t.accel_max_scale = IIO_M_S_2_TO_G(800 << 16),\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode),\n\t\t.has_burst32 = true,\n\t\t.adis_data = ADIS16475_DATA(16477, &adis16475_timeouts),\n\t},\n\t[ADIS16477_3] = {\n\t\t.name = \"adis16477-3\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(10 << 16),\n\t\t.accel_max_val = 1,\n\t\t.accel_max_scale = IIO_M_S_2_TO_G(800 << 16),\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode),\n\t\t.has_burst32 = true,\n\t\t.adis_data = ADIS16475_DATA(16477, &adis16475_timeouts),\n\t},\n\t[ADIS16465_1] = {\n\t\t.name = \"adis16465-1\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(160 << 16),\n\t\t.accel_max_val = 1,\n\t\t.accel_max_scale = IIO_M_S_2_TO_G(4000 << 16),\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode),\n\t\t.adis_data = ADIS16475_DATA(16465, &adis16475_timeouts),\n\t},\n\t[ADIS16465_2] = {\n\t\t.name = \"adis16465-2\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(40 << 16),\n\t\t.accel_max_val = 1,\n\t\t.accel_max_scale = IIO_M_S_2_TO_G(4000 << 16),\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode),\n\t\t.adis_data = ADIS16475_DATA(16465, &adis16475_timeouts),\n\t},\n\t[ADIS16465_3] = {\n\t\t.name = \"adis16465-3\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(10 << 16),\n\t\t.accel_max_val = 1,\n\t\t.accel_max_scale = IIO_M_S_2_TO_G(4000 << 16),\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode),\n\t\t.adis_data = ADIS16475_DATA(16465, &adis16475_timeouts),\n\t},\n\t[ADIS16467_1] = {\n\t\t.name = \"adis16467-1\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(160 << 16),\n\t\t.accel_max_val = 1,\n\t\t.accel_max_scale = IIO_M_S_2_TO_G(800 << 16),\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode),\n\t\t.adis_data = ADIS16475_DATA(16467, &adis16475_timeouts),\n\t},\n\t[ADIS16467_2] = {\n\t\t.name = \"adis16467-2\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(40 << 16),\n\t\t.accel_max_val = 1,\n\t\t.accel_max_scale = IIO_M_S_2_TO_G(800 << 16),\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode),\n\t\t.adis_data = ADIS16475_DATA(16467, &adis16475_timeouts),\n\t},\n\t[ADIS16467_3] = {\n\t\t.name = \"adis16467-3\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(10 << 16),\n\t\t.accel_max_val = 1,\n\t\t.accel_max_scale = IIO_M_S_2_TO_G(800 << 16),\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode),\n\t\t.adis_data = ADIS16475_DATA(16467, &adis16475_timeouts),\n\t},\n\t[ADIS16500] = {\n\t\t.name = \"adis16500\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(10 << 16),\n\t\t.accel_max_val = 392,\n\t\t.accel_max_scale = 32000 << 16,\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t \n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode) - 1,\n\t\t.has_burst32 = true,\n\t\t.adis_data = ADIS16475_DATA(16500, &adis1650x_timeouts),\n\t},\n\t[ADIS16505_1] = {\n\t\t.name = \"adis16505-1\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(160 << 16),\n\t\t.accel_max_val = 78,\n\t\t.accel_max_scale = 32000 << 16,\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t \n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode) - 1,\n\t\t.has_burst32 = true,\n\t\t.adis_data = ADIS16475_DATA(16505, &adis1650x_timeouts),\n\t},\n\t[ADIS16505_2] = {\n\t\t.name = \"adis16505-2\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(40 << 16),\n\t\t.accel_max_val = 78,\n\t\t.accel_max_scale = 32000 << 16,\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t \n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode) - 1,\n\t\t.has_burst32 = true,\n\t\t.adis_data = ADIS16475_DATA(16505, &adis1650x_timeouts),\n\t},\n\t[ADIS16505_3] = {\n\t\t.name = \"adis16505-3\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(10 << 16),\n\t\t.accel_max_val = 78,\n\t\t.accel_max_scale = 32000 << 16,\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t \n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode) - 1,\n\t\t.has_burst32 = true,\n\t\t.adis_data = ADIS16475_DATA(16505, &adis1650x_timeouts),\n\t},\n\t[ADIS16507_1] = {\n\t\t.name = \"adis16507-1\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(160 << 16),\n\t\t.accel_max_val = 392,\n\t\t.accel_max_scale = 32000 << 16,\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t \n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode) - 1,\n\t\t.has_burst32 = true,\n\t\t.adis_data = ADIS16475_DATA(16507, &adis1650x_timeouts),\n\t},\n\t[ADIS16507_2] = {\n\t\t.name = \"adis16507-2\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(40 << 16),\n\t\t.accel_max_val = 392,\n\t\t.accel_max_scale = 32000 << 16,\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t \n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode) - 1,\n\t\t.has_burst32 = true,\n\t\t.adis_data = ADIS16475_DATA(16507, &adis1650x_timeouts),\n\t},\n\t[ADIS16507_3] = {\n\t\t.name = \"adis16507-3\",\n\t\t.num_channels = ARRAY_SIZE(adis16475_channels),\n\t\t.channels = adis16475_channels,\n\t\t.gyro_max_val = 1,\n\t\t.gyro_max_scale = IIO_RAD_TO_DEGREE(10 << 16),\n\t\t.accel_max_val = 392,\n\t\t.accel_max_scale = 32000 << 16,\n\t\t.temp_scale = 100,\n\t\t.int_clk = 2000,\n\t\t.max_dec = 1999,\n\t\t.sync = adis16475_sync_mode,\n\t\t \n\t\t.num_sync = ARRAY_SIZE(adis16475_sync_mode) - 1,\n\t\t.has_burst32 = true,\n\t\t.adis_data = ADIS16475_DATA(16507, &adis1650x_timeouts),\n\t},\n};\n\nstatic const struct iio_info adis16475_info = {\n\t.read_raw = &adis16475_read_raw,\n\t.write_raw = &adis16475_write_raw,\n\t.update_scan_mode = adis_update_scan_mode,\n\t.debugfs_reg_access = adis_debugfs_reg_access,\n};\n\nstatic bool adis16475_validate_crc(const u8 *buffer, u16 crc,\n\t\t\t\t   const bool burst32)\n{\n\tint i;\n\t \n\tconst u16 sz = burst32 ? ADIS16475_BURST32_MAX_DATA :\n\t\tADIS16475_BURST_MAX_DATA;\n\n\tfor (i = 0; i < sz - 2; i++)\n\t\tcrc -= buffer[i];\n\n\treturn crc == 0;\n}\n\nstatic void adis16475_burst32_check(struct adis16475 *st)\n{\n\tint ret;\n\tstruct adis *adis = &st->adis;\n\n\tif (!st->info->has_burst32)\n\t\treturn;\n\n\tif (st->lsb_flag && !st->burst32) {\n\t\tconst u16 en = ADIS16500_BURST32(1);\n\n\t\tret = __adis_update_bits(&st->adis, ADIS16475_REG_MSG_CTRL,\n\t\t\t\t\t ADIS16500_BURST32_MASK, en);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tst->burst32 = true;\n\n\t\t \n\t\tadis->burst_extra_len = 6 * sizeof(u16);\n\t\tadis->xfer[1].len += 6 * sizeof(u16);\n\t\tdev_dbg(&adis->spi->dev, \"Enable burst32 mode, xfer:%d\",\n\t\t\tadis->xfer[1].len);\n\n\t} else if (!st->lsb_flag && st->burst32) {\n\t\tconst u16 en = ADIS16500_BURST32(0);\n\n\t\tret = __adis_update_bits(&st->adis, ADIS16475_REG_MSG_CTRL,\n\t\t\t\t\t ADIS16500_BURST32_MASK, en);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tst->burst32 = false;\n\n\t\t \n\t\tadis->burst_extra_len = 0;\n\t\tadis->xfer[1].len -= 6 * sizeof(u16);\n\t\tdev_dbg(&adis->spi->dev, \"Disable burst32 mode, xfer:%d\\n\",\n\t\t\tadis->xfer[1].len);\n\t}\n}\n\nstatic irqreturn_t adis16475_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct adis16475 *st = iio_priv(indio_dev);\n\tstruct adis *adis = &st->adis;\n\tint ret, bit, i = 0;\n\t__be16 *buffer;\n\tu16 crc;\n\tbool valid;\n\t \n\tconst u8 offset = st->burst32 ? 13 : 7;\n\n\tret = spi_sync(adis->spi, &adis->msg);\n\tif (ret)\n\t\tgoto check_burst32;\n\n\tbuffer = adis->buffer;\n\n\tcrc = be16_to_cpu(buffer[offset + 2]);\n\tvalid = adis16475_validate_crc(adis->buffer, crc, st->burst32);\n\tif (!valid) {\n\t\tdev_err(&adis->spi->dev, \"Invalid crc\\n\");\n\t\tgoto check_burst32;\n\t}\n\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\t \n\t\tswitch (bit) {\n\t\tcase ADIS16475_SCAN_TEMP:\n\t\t\tst->data[i++] = buffer[offset];\n\t\t\tbreak;\n\t\tcase ADIS16475_SCAN_GYRO_X ... ADIS16475_SCAN_ACCEL_Z:\n\t\t\t \n\t\t\tif (st->burst32) {\n\t\t\t\t \n\t\t\t\tst->data[i++] = buffer[bit * 2 + 2];\n\t\t\t\t \n\t\t\t\tst->data[i++] = buffer[bit * 2 + 1];\n\t\t\t} else {\n\t\t\t\tst->data[i++] = buffer[bit + 1];\n\t\t\t\t \n\t\t\t\tif (st->lsb_flag && !st->info->has_burst32) {\n\t\t\t\t\tu16 val = 0;\n\t\t\t\t\tconst u32 reg = ADIS16475_REG_X_GYRO_L +\n\t\t\t\t\t\tbit * 4;\n\n\t\t\t\t\tadis_read_reg_16(adis, reg, &val);\n\t\t\t\t\tst->data[i++] = cpu_to_be16(val);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tst->data[i++] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, st->data, pf->timestamp);\ncheck_burst32:\n\t \n\tadis16475_burst32_check(st);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int adis16475_config_sync_mode(struct adis16475 *st)\n{\n\tint ret;\n\tstruct device *dev = &st->adis.spi->dev;\n\tconst struct adis16475_sync *sync;\n\tu32 sync_mode;\n\n\t \n\tst->clk_freq = st->info->int_clk * 1000;\n\n\tret = device_property_read_u32(dev, \"adi,sync-mode\", &sync_mode);\n\tif (ret)\n\t\treturn 0;\n\n\tif (sync_mode >= st->info->num_sync) {\n\t\tdev_err(dev, \"Invalid sync mode: %u for %s\\n\", sync_mode,\n\t\t\tst->info->name);\n\t\treturn -EINVAL;\n\t}\n\n\tsync = &st->info->sync[sync_mode];\n\tst->sync_mode = sync->sync_mode;\n\n\t \n\tif (sync->sync_mode != ADIS16475_SYNC_OUTPUT) {\n\t\tstruct clk *clk = devm_clk_get_enabled(dev, NULL);\n\n\t\tif (IS_ERR(clk))\n\t\t\treturn PTR_ERR(clk);\n\n\t\tst->clk_freq = clk_get_rate(clk);\n\t\tif (st->clk_freq < sync->min_rate ||\n\t\t    st->clk_freq > sync->max_rate) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Clk rate:%u not in a valid range:[%u %u]\\n\",\n\t\t\t\tst->clk_freq, sync->min_rate, sync->max_rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sync->sync_mode == ADIS16475_SYNC_SCALED) {\n\t\t\tu16 up_scale;\n\n\t\t\t \n\t\t\tup_scale = 2100 / st->clk_freq;\n\n\t\t\tret = __adis_write_reg_16(&st->adis,\n\t\t\t\t\t\t  ADIS16475_REG_UP_SCALE,\n\t\t\t\t\t\t  up_scale);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tst->clk_freq *= 1000;\n\t}\n\t \n\tret = __adis_update_bits(&st->adis, ADIS16475_REG_MSG_CTRL,\n\t\t\t\t ADIS16475_SYNC_MODE_MASK, sync->sync_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(250, 260);\n\n\treturn 0;\n}\n\nstatic int adis16475_config_irq_pin(struct adis16475 *st)\n{\n\tint ret;\n\tstruct irq_data *desc;\n\tu32 irq_type;\n\tu16 val = 0;\n\tu8 polarity;\n\tstruct spi_device *spi = st->adis.spi;\n\n\tdesc = irq_get_irq_data(spi->irq);\n\tif (!desc) {\n\t\tdev_err(&spi->dev, \"Could not find IRQ %d\\n\", spi->irq);\n\t\treturn -EINVAL;\n\t}\n\t \n\tirq_type = irqd_get_trigger_type(desc);\n\tif (irq_type == IRQ_TYPE_EDGE_RISING) {\n\t\tpolarity = 1;\n\t\tst->adis.irq_flag = IRQF_TRIGGER_RISING;\n\t} else if (irq_type == IRQ_TYPE_EDGE_FALLING) {\n\t\tpolarity = 0;\n\t\tst->adis.irq_flag = IRQF_TRIGGER_FALLING;\n\t} else {\n\t\tdev_err(&spi->dev, \"Invalid interrupt type 0x%x specified\\n\",\n\t\t\tirq_type);\n\t\treturn -EINVAL;\n\t}\n\n\tval = ADIS16475_MSG_CTRL_DR_POL(polarity);\n\tret = __adis_update_bits(&st->adis, ADIS16475_REG_MSG_CTRL,\n\t\t\t\t ADIS16475_MSG_CTRL_DR_POL_MASK, val);\n\tif (ret)\n\t\treturn ret;\n\t \n\tusleep_range(250, 260);\n\n\treturn 0;\n}\n\n\nstatic int adis16475_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct adis16475 *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->info = spi_get_device_match_data(spi);\n\tif (!st->info)\n\t\treturn -EINVAL;\n\n\tret = adis_init(&st->adis, indio_dev, spi, &st->info->adis_data);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->name = st->info->name;\n\tindio_dev->channels = st->info->channels;\n\tindio_dev->num_channels = st->info->num_channels;\n\tindio_dev->info = &adis16475_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = __adis_initial_startup(&st->adis);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adis16475_config_irq_pin(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adis16475_config_sync_mode(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_adis_setup_buffer_and_trigger(&st->adis, indio_dev,\n\t\t\t\t\t\t adis16475_trigger_handler);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_device_register(&spi->dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tadis16475_debugfs_init(indio_dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id adis16475_of_match[] = {\n\t{ .compatible = \"adi,adis16470\",\n\t\t.data = &adis16475_chip_info[ADIS16470] },\n\t{ .compatible = \"adi,adis16475-1\",\n\t\t.data = &adis16475_chip_info[ADIS16475_1] },\n\t{ .compatible = \"adi,adis16475-2\",\n\t\t.data = &adis16475_chip_info[ADIS16475_2] },\n\t{ .compatible = \"adi,adis16475-3\",\n\t\t.data = &adis16475_chip_info[ADIS16475_3] },\n\t{ .compatible = \"adi,adis16477-1\",\n\t\t.data = &adis16475_chip_info[ADIS16477_1] },\n\t{ .compatible = \"adi,adis16477-2\",\n\t\t.data = &adis16475_chip_info[ADIS16477_2] },\n\t{ .compatible = \"adi,adis16477-3\",\n\t\t.data = &adis16475_chip_info[ADIS16477_3] },\n\t{ .compatible = \"adi,adis16465-1\",\n\t\t.data = &adis16475_chip_info[ADIS16465_1] },\n\t{ .compatible = \"adi,adis16465-2\",\n\t\t.data = &adis16475_chip_info[ADIS16465_2] },\n\t{ .compatible = \"adi,adis16465-3\",\n\t\t.data = &adis16475_chip_info[ADIS16465_3] },\n\t{ .compatible = \"adi,adis16467-1\",\n\t\t.data = &adis16475_chip_info[ADIS16467_1] },\n\t{ .compatible = \"adi,adis16467-2\",\n\t\t.data = &adis16475_chip_info[ADIS16467_2] },\n\t{ .compatible = \"adi,adis16467-3\",\n\t\t.data = &adis16475_chip_info[ADIS16467_3] },\n\t{ .compatible = \"adi,adis16500\",\n\t\t.data = &adis16475_chip_info[ADIS16500] },\n\t{ .compatible = \"adi,adis16505-1\",\n\t\t.data = &adis16475_chip_info[ADIS16505_1] },\n\t{ .compatible = \"adi,adis16505-2\",\n\t\t.data = &adis16475_chip_info[ADIS16505_2] },\n\t{ .compatible = \"adi,adis16505-3\",\n\t\t.data = &adis16475_chip_info[ADIS16505_3] },\n\t{ .compatible = \"adi,adis16507-1\",\n\t\t.data = &adis16475_chip_info[ADIS16507_1] },\n\t{ .compatible = \"adi,adis16507-2\",\n\t\t.data = &adis16475_chip_info[ADIS16507_2] },\n\t{ .compatible = \"adi,adis16507-3\",\n\t\t.data = &adis16475_chip_info[ADIS16507_3] },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, adis16475_of_match);\n\nstatic const struct spi_device_id adis16475_ids[] = {\n\t{ \"adis16470\", (kernel_ulong_t)&adis16475_chip_info[ADIS16470] },\n\t{ \"adis16475-1\", (kernel_ulong_t)&adis16475_chip_info[ADIS16475_1] },\n\t{ \"adis16475-2\", (kernel_ulong_t)&adis16475_chip_info[ADIS16475_2] },\n\t{ \"adis16475-3\", (kernel_ulong_t)&adis16475_chip_info[ADIS16475_3] },\n\t{ \"adis16477-1\", (kernel_ulong_t)&adis16475_chip_info[ADIS16477_1] },\n\t{ \"adis16477-2\", (kernel_ulong_t)&adis16475_chip_info[ADIS16477_2] },\n\t{ \"adis16477-3\", (kernel_ulong_t)&adis16475_chip_info[ADIS16477_3] },\n\t{ \"adis16465-1\", (kernel_ulong_t)&adis16475_chip_info[ADIS16465_1] },\n\t{ \"adis16465-2\", (kernel_ulong_t)&adis16475_chip_info[ADIS16465_2] },\n\t{ \"adis16465-3\", (kernel_ulong_t)&adis16475_chip_info[ADIS16465_3] },\n\t{ \"adis16467-1\", (kernel_ulong_t)&adis16475_chip_info[ADIS16467_1] },\n\t{ \"adis16467-2\", (kernel_ulong_t)&adis16475_chip_info[ADIS16467_2] },\n\t{ \"adis16467-3\", (kernel_ulong_t)&adis16475_chip_info[ADIS16467_3] },\n\t{ \"adis16500\", (kernel_ulong_t)&adis16475_chip_info[ADIS16500] },\n\t{ \"adis16505-1\", (kernel_ulong_t)&adis16475_chip_info[ADIS16505_1] },\n\t{ \"adis16505-2\", (kernel_ulong_t)&adis16475_chip_info[ADIS16505_2] },\n\t{ \"adis16505-3\", (kernel_ulong_t)&adis16475_chip_info[ADIS16505_3] },\n\t{ \"adis16507-1\", (kernel_ulong_t)&adis16475_chip_info[ADIS16507_1] },\n\t{ \"adis16507-2\", (kernel_ulong_t)&adis16475_chip_info[ADIS16507_2] },\n\t{ \"adis16507-3\", (kernel_ulong_t)&adis16475_chip_info[ADIS16507_3] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, adis16475_ids);\n\nstatic struct spi_driver adis16475_driver = {\n\t.driver = {\n\t\t.name = \"adis16475\",\n\t\t.of_match_table = adis16475_of_match,\n\t},\n\t.probe = adis16475_probe,\n\t.id_table = adis16475_ids,\n};\nmodule_spi_driver(adis16475_driver);\n\nMODULE_AUTHOR(\"Nuno Sa <nuno.sa@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADIS16475 IMU driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IIO_ADISLIB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}