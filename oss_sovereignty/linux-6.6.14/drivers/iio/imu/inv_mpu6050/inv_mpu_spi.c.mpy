{
  "module_name": "inv_mpu_spi.c",
  "hash_id": "5389dfd909c85b352b18083012326915c8171e432902ac949d89196907ba9f5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/inv_mpu6050/inv_mpu_spi.c",
  "human_readable_source": "\n \n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n#include <linux/regmap.h>\n#include <linux/iio/iio.h>\n#include \"inv_mpu_iio.h\"\n\nstatic const struct regmap_config inv_mpu_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int inv_mpu_i2c_disable(struct iio_dev *indio_dev)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\tint ret = 0;\n\n\tif (st->reg->i2c_if) {\n\t\tret = regmap_write(st->map, st->reg->i2c_if,\n\t\t\t\t   INV_ICM20602_BIT_I2C_IF_DIS);\n\t} else {\n\t\tst->chip_config.user_ctrl |= INV_MPU6050_BIT_I2C_IF_DIS;\n\t\tret = regmap_write(st->map, st->reg->user_ctrl,\n\t\t\t\t   st->chip_config.user_ctrl);\n\t}\n\n\treturn ret;\n}\n\nstatic int inv_mpu_probe(struct spi_device *spi)\n{\n\tconst void *match;\n\tstruct regmap *regmap;\n\tconst struct spi_device_id *spi_id;\n\tconst char *name = NULL;\n\tenum inv_devices chip_type;\n\n\tif ((spi_id = spi_get_device_id(spi))) {\n\t\tchip_type = (enum inv_devices)spi_id->driver_data;\n\t\tname = spi_id->name;\n\t} else if ((match = device_get_match_data(&spi->dev))) {\n\t\tchip_type = (uintptr_t)match;\n\t\tname = dev_name(&spi->dev);\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\tregmap = devm_regmap_init_spi(spi, &inv_mpu_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&spi->dev, \"Failed to register spi regmap: %pe\\n\",\n\t\t\tregmap);\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\treturn inv_mpu_core_probe(regmap, spi->irq, name,\n\t\t\t\t  inv_mpu_i2c_disable, chip_type);\n}\n\n \nstatic const struct spi_device_id inv_mpu_id[] = {\n\t{\"mpu6000\", INV_MPU6000},\n\t{\"mpu6500\", INV_MPU6500},\n\t{\"mpu6515\", INV_MPU6515},\n\t{\"mpu6880\", INV_MPU6880},\n\t{\"mpu9250\", INV_MPU9250},\n\t{\"mpu9255\", INV_MPU9255},\n\t{\"icm20608\", INV_ICM20608},\n\t{\"icm20608d\", INV_ICM20608D},\n\t{\"icm20609\", INV_ICM20609},\n\t{\"icm20689\", INV_ICM20689},\n\t{\"icm20600\", INV_ICM20600},\n\t{\"icm20602\", INV_ICM20602},\n\t{\"icm20690\", INV_ICM20690},\n\t{\"iam20680\", INV_IAM20680},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(spi, inv_mpu_id);\n\nstatic const struct of_device_id inv_of_match[] = {\n\t{\n\t\t.compatible = \"invensense,mpu6000\",\n\t\t.data = (void *)INV_MPU6000\n\t},\n\t{\n\t\t.compatible = \"invensense,mpu6500\",\n\t\t.data = (void *)INV_MPU6500\n\t},\n\t{\n\t\t.compatible = \"invensense,mpu6515\",\n\t\t.data = (void *)INV_MPU6515\n\t},\n\t{\n\t\t.compatible = \"invensense,mpu6880\",\n\t\t.data = (void *)INV_MPU6880\n\t},\n\t{\n\t\t.compatible = \"invensense,mpu9250\",\n\t\t.data = (void *)INV_MPU9250\n\t},\n\t{\n\t\t.compatible = \"invensense,mpu9255\",\n\t\t.data = (void *)INV_MPU9255\n\t},\n\t{\n\t\t.compatible = \"invensense,icm20608\",\n\t\t.data = (void *)INV_ICM20608\n\t},\n\t{\n\t\t.compatible = \"invensense,icm20608d\",\n\t\t.data = (void *)INV_ICM20608D\n\t},\n\t{\n\t\t.compatible = \"invensense,icm20609\",\n\t\t.data = (void *)INV_ICM20609\n\t},\n\t{\n\t\t.compatible = \"invensense,icm20689\",\n\t\t.data = (void *)INV_ICM20689\n\t},\n\t{\n\t\t.compatible = \"invensense,icm20600\",\n\t\t.data = (void *)INV_ICM20600\n\t},\n\t{\n\t\t.compatible = \"invensense,icm20602\",\n\t\t.data = (void *)INV_ICM20602\n\t},\n\t{\n\t\t.compatible = \"invensense,icm20690\",\n\t\t.data = (void *)INV_ICM20690\n\t},\n\t{\n\t\t.compatible = \"invensense,iam20680\",\n\t\t.data = (void *)INV_IAM20680\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, inv_of_match);\n\nstatic const struct acpi_device_id inv_acpi_match[] = {\n\t{\"INVN6000\", INV_MPU6000},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, inv_acpi_match);\n\nstatic struct spi_driver inv_mpu_driver = {\n\t.probe\t\t=\tinv_mpu_probe,\n\t.id_table\t=\tinv_mpu_id,\n\t.driver = {\n\t\t.of_match_table = inv_of_match,\n\t\t.acpi_match_table = inv_acpi_match,\n\t\t.name\t=\t\"inv-mpu6000-spi\",\n\t\t.pm     =       pm_ptr(&inv_mpu_pmops),\n\t},\n};\n\nmodule_spi_driver(inv_mpu_driver);\n\nMODULE_AUTHOR(\"Adriana Reus <adriana.reus@intel.com>\");\nMODULE_DESCRIPTION(\"Invensense device MPU6000 driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IIO_MPU6050);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}