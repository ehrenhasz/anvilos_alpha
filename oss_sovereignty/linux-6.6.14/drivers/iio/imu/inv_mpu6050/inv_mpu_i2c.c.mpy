{
  "module_name": "inv_mpu_i2c.c",
  "hash_id": "c95a4bce2ad4ab80ad3ab4f47964ca9cca63a66c11ec8d8d2819621bb891cc92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n\n#include \"inv_mpu_iio.h\"\n\nstatic const struct regmap_config inv_mpu_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int inv_mpu6050_select_bypass(struct i2c_mux_core *muxc, u32 chan_id)\n{\n\treturn 0;\n}\n\nstatic bool inv_mpu_i2c_aux_bus(struct device *dev)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(dev_get_drvdata(dev));\n\n\tswitch (st->chip_type) {\n\tcase INV_ICM20608:\n\tcase INV_ICM20608D:\n\tcase INV_ICM20609:\n\tcase INV_ICM20689:\n\tcase INV_ICM20600:\n\tcase INV_ICM20602:\n\tcase INV_IAM20680:\n\t\t \n\t\treturn false;\n\tcase INV_MPU9150:\n\tcase INV_MPU9250:\n\tcase INV_MPU9255:\n\t\tif (st->magn_disabled)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic int inv_mpu_i2c_aux_setup(struct iio_dev *indio_dev)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\tstruct fwnode_handle *mux_node;\n\tint ret;\n\n\t \n\tswitch (st->chip_type) {\n\tcase INV_MPU9150:\n\tcase INV_MPU9250:\n\tcase INV_MPU9255:\n\t\tmux_node = device_get_named_child_node(dev, \"i2c-gate\");\n\t\tif (mux_node != NULL) {\n\t\t\tst->magn_disabled = true;\n\t\t\tdev_warn(dev, \"disable internal use of magnetometer\\n\");\n\t\t}\n\t\tfwnode_handle_put(mux_node);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (inv_mpu_i2c_aux_bus(dev)) {\n\t\tret = regmap_write(st->map, st->reg->int_pin_cfg,\n\t\t\t\t   st->irq_mask | INV_MPU6050_BIT_BYPASS_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int inv_mpu_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tconst void *match;\n\tstruct inv_mpu6050_state *st;\n\tint result;\n\tenum inv_devices chip_type;\n\tstruct regmap *regmap;\n\tconst char *name;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_I2C_BLOCK))\n\t\treturn -EOPNOTSUPP;\n\n\tmatch = device_get_match_data(&client->dev);\n\tif (match) {\n\t\tchip_type = (uintptr_t)match;\n\t\tname = client->name;\n\t} else if (id) {\n\t\tchip_type = (enum inv_devices)\n\t\t\tid->driver_data;\n\t\tname = id->name;\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n\n\tregmap = devm_regmap_init_i2c(client, &inv_mpu_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"Failed to register i2c regmap: %pe\\n\",\n\t\t\tregmap);\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tresult = inv_mpu_core_probe(regmap, client->irq, name,\n\t\t\t\t    inv_mpu_i2c_aux_setup, chip_type);\n\tif (result < 0)\n\t\treturn result;\n\n\tst = iio_priv(dev_get_drvdata(&client->dev));\n\tif (inv_mpu_i2c_aux_bus(&client->dev)) {\n\t\t \n\t\tst->muxc = i2c_mux_alloc(client->adapter, &client->dev,\n\t\t\t\t\t 1, 0, I2C_MUX_LOCKED | I2C_MUX_GATE,\n\t\t\t\t\t inv_mpu6050_select_bypass, NULL);\n\t\tif (!st->muxc)\n\t\t\treturn -ENOMEM;\n\t\tst->muxc->priv = dev_get_drvdata(&client->dev);\n\t\tresult = i2c_mux_add_adapter(st->muxc, 0, 0, 0);\n\t\tif (result)\n\t\t\treturn result;\n\t\tresult = inv_mpu_acpi_create_mux_client(client);\n\t\tif (result)\n\t\t\tgoto out_del_mux;\n\t}\n\n\treturn 0;\n\nout_del_mux:\n\ti2c_mux_del_adapters(st->muxc);\n\treturn result;\n}\n\nstatic void inv_mpu_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\n\tif (st->muxc) {\n\t\tinv_mpu_acpi_delete_mux_client(client);\n\t\ti2c_mux_del_adapters(st->muxc);\n\t}\n}\n\n \nstatic const struct i2c_device_id inv_mpu_id[] = {\n\t{\"mpu6050\", INV_MPU6050},\n\t{\"mpu6500\", INV_MPU6500},\n\t{\"mpu6515\", INV_MPU6515},\n\t{\"mpu6880\", INV_MPU6880},\n\t{\"mpu9150\", INV_MPU9150},\n\t{\"mpu9250\", INV_MPU9250},\n\t{\"mpu9255\", INV_MPU9255},\n\t{\"icm20608\", INV_ICM20608},\n\t{\"icm20608d\", INV_ICM20608D},\n\t{\"icm20609\", INV_ICM20609},\n\t{\"icm20689\", INV_ICM20689},\n\t{\"icm20600\", INV_ICM20600},\n\t{\"icm20602\", INV_ICM20602},\n\t{\"icm20690\", INV_ICM20690},\n\t{\"iam20680\", INV_IAM20680},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, inv_mpu_id);\n\nstatic const struct of_device_id inv_of_match[] = {\n\t{\n\t\t.compatible = \"invensense,mpu6050\",\n\t\t.data = (void *)INV_MPU6050\n\t},\n\t{\n\t\t.compatible = \"invensense,mpu6500\",\n\t\t.data = (void *)INV_MPU6500\n\t},\n\t{\n\t\t.compatible = \"invensense,mpu6515\",\n\t\t.data = (void *)INV_MPU6515\n\t},\n\t{\n\t\t.compatible = \"invensense,mpu6880\",\n\t\t.data = (void *)INV_MPU6880\n\t},\n\t{\n\t\t.compatible = \"invensense,mpu9150\",\n\t\t.data = (void *)INV_MPU9150\n\t},\n\t{\n\t\t.compatible = \"invensense,mpu9250\",\n\t\t.data = (void *)INV_MPU9250\n\t},\n\t{\n\t\t.compatible = \"invensense,mpu9255\",\n\t\t.data = (void *)INV_MPU9255\n\t},\n\t{\n\t\t.compatible = \"invensense,icm20608\",\n\t\t.data = (void *)INV_ICM20608\n\t},\n\t{\n\t\t.compatible = \"invensense,icm20608d\",\n\t\t.data = (void *)INV_ICM20608D\n\t},\n\t{\n\t\t.compatible = \"invensense,icm20609\",\n\t\t.data = (void *)INV_ICM20609\n\t},\n\t{\n\t\t.compatible = \"invensense,icm20689\",\n\t\t.data = (void *)INV_ICM20689\n\t},\n\t{\n\t\t.compatible = \"invensense,icm20600\",\n\t\t.data = (void *)INV_ICM20600\n\t},\n\t{\n\t\t.compatible = \"invensense,icm20602\",\n\t\t.data = (void *)INV_ICM20602\n\t},\n\t{\n\t\t.compatible = \"invensense,icm20690\",\n\t\t.data = (void *)INV_ICM20690\n\t},\n\t{\n\t\t.compatible = \"invensense,iam20680\",\n\t\t.data = (void *)INV_IAM20680\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, inv_of_match);\n\nstatic const struct acpi_device_id inv_acpi_match[] = {\n\t{\"INVN6500\", INV_MPU6500},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, inv_acpi_match);\n\nstatic struct i2c_driver inv_mpu_driver = {\n\t.probe\t\t=\tinv_mpu_probe,\n\t.remove\t\t=\tinv_mpu_remove,\n\t.id_table\t=\tinv_mpu_id,\n\t.driver = {\n\t\t.of_match_table = inv_of_match,\n\t\t.acpi_match_table = inv_acpi_match,\n\t\t.name\t=\t\"inv-mpu6050-i2c\",\n\t\t.pm     =       pm_ptr(&inv_mpu_pmops),\n\t},\n};\n\nmodule_i2c_driver(inv_mpu_driver);\n\nMODULE_AUTHOR(\"Invensense Corporation\");\nMODULE_DESCRIPTION(\"Invensense device MPU6050 driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IIO_MPU6050);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}