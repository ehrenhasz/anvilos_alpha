{
  "module_name": "inv_mpu_acpi.c",
  "hash_id": "8e806333411b0c75a95dd19bcf01fd94fb67fab973049431dc02fa7c5b98786d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/inv_mpu6050/inv_mpu_acpi.c",
  "human_readable_source": "\n \n\n#ifdef CONFIG_ACPI\n\n#include <linux/kernel.h>\n#include <linux/i2c.h>\n#include <linux/dmi.h>\n#include <linux/acpi.h>\n#include \"inv_mpu_iio.h\"\n\nenum inv_mpu_product_name {\n\tINV_MPU_NOT_MATCHED,\n\tINV_MPU_ASUS_T100TA,\n};\n\nstatic enum inv_mpu_product_name matched_product_name;\n\nstatic int __init asus_t100_matched(const struct dmi_system_id *d)\n{\n\tmatched_product_name = INV_MPU_ASUS_T100TA;\n\n\treturn 0;\n}\n\nstatic const struct dmi_system_id inv_mpu_dev_list[] = {\n\t{\n\t.callback = asus_t100_matched,\n\t.ident = \"Asus Transformer Book T100\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"T100TA\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"1.0\"),\n\t\t},\n\t},\n\t \n\t{}\n};\n\nstatic int asus_acpi_get_sensor_info(struct acpi_device *adev,\n\t\t\t\t     struct i2c_client *client,\n\t\t\t\t     struct i2c_board_info *info)\n{\n\tstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\n\tint i;\n\tacpi_status status;\n\tunion acpi_object *cpm;\n\tint ret;\n\n\tstatus = acpi_evaluate_object(adev->handle, \"CNF0\", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tcpm = buffer.pointer;\n\tfor (i = 0; i < cpm->package.count; ++i) {\n\t\tunion acpi_object *elem;\n\t\tint j;\n\n\t\telem = &cpm->package.elements[i];\n\t\tfor (j = 0; j < elem->package.count; ++j) {\n\t\t\tunion acpi_object *sub_elem;\n\n\t\t\tsub_elem = &elem->package.elements[j];\n\t\t\tif (sub_elem->type == ACPI_TYPE_STRING)\n\t\t\t\tstrscpy(info->type, sub_elem->string.pointer,\n\t\t\t\t\tsizeof(info->type));\n\t\t\telse if (sub_elem->type == ACPI_TYPE_INTEGER) {\n\t\t\t\tif (sub_elem->integer.value != client->addr) {\n\t\t\t\t\tinfo->addr = sub_elem->integer.value;\n\t\t\t\t\tbreak;  \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tret = cpm->package.count;\n\tkfree(buffer.pointer);\n\n\treturn ret;\n}\n\nstatic int acpi_i2c_check_resource(struct acpi_resource *ares, void *data)\n{\n\tstruct acpi_resource_i2c_serialbus *sb;\n\tu32 *addr = data;\n\n\tif (i2c_acpi_get_i2c_resource(ares, &sb)) {\n\t\tif (*addr)\n\t\t\t*addr |= (sb->slave_address << 16);\n\t\telse\n\t\t\t*addr = sb->slave_address;\n\t}\n\n\t \n\treturn 1;\n}\n\nstatic int inv_mpu_process_acpi_config(struct i2c_client *client,\n\t\t\t\t       unsigned short *primary_addr,\n\t\t\t\t       unsigned short *secondary_addr)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&client->dev);\n\tconst struct acpi_device_id *id;\n\tu32 i2c_addr = 0;\n\tLIST_HEAD(resources);\n\tint ret;\n\n\tid = acpi_match_device(client->dev.driver->acpi_match_table,\n\t\t\t       &client->dev);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tret = acpi_dev_get_resources(adev, &resources,\n\t\t\t\t     acpi_i2c_check_resource, &i2c_addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tacpi_dev_free_resource_list(&resources);\n\t*primary_addr = i2c_addr & 0x0000ffff;\n\t*secondary_addr = (i2c_addr & 0xffff0000) >> 16;\n\n\treturn 0;\n}\n\nint inv_mpu_acpi_create_mux_client(struct i2c_client *client)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(dev_get_drvdata(&client->dev));\n\tstruct acpi_device *adev = ACPI_COMPANION(&client->dev);\n\n\tst->mux_client = NULL;\n\tif (adev) {\n\t\tstruct i2c_board_info info;\n\t\tstruct i2c_client *mux_client;\n\t\tint ret = -1;\n\n\t\tmemset(&info, 0, sizeof(info));\n\n\t\tdmi_check_system(inv_mpu_dev_list);\n\t\tswitch (matched_product_name) {\n\t\tcase INV_MPU_ASUS_T100TA:\n\t\t\tret = asus_acpi_get_sensor_info(adev, client,\n\t\t\t\t\t\t\t&info);\n\t\t\tbreak;\n\t\t \n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tunsigned short primary, secondary;\n\n\t\t\tret = inv_mpu_process_acpi_config(client, &primary,\n\t\t\t\t\t\t\t  &secondary);\n\t\t\tif (!ret && secondary) {\n\t\t\t\tchar *name;\n\n\t\t\t\tinfo.addr = secondary;\n\t\t\t\tstrscpy(info.type, dev_name(&adev->dev),\n\t\t\t\t\tsizeof(info.type));\n\t\t\t\tname = strchr(info.type, ':');\n\t\t\t\tif (name)\n\t\t\t\t\t*name = '\\0';\n\t\t\t\tstrlcat(info.type, \"-client\",\n\t\t\t\t\tsizeof(info.type));\n\t\t\t} else\n\t\t\t\treturn 0;  \n\t\t}\n\t\tmux_client = i2c_new_client_device(st->muxc->adapter[0], &info);\n\t\tif (IS_ERR(mux_client))\n\t\t\treturn PTR_ERR(mux_client);\n\t\tst->mux_client = mux_client;\n\t}\n\n\treturn 0;\n}\n\nvoid inv_mpu_acpi_delete_mux_client(struct i2c_client *client)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(dev_get_drvdata(&client->dev));\n\n\ti2c_unregister_device(st->mux_client);\n}\n#else\n\n#include \"inv_mpu_iio.h\"\n\nint inv_mpu_acpi_create_mux_client(struct i2c_client *client)\n{\n\treturn 0;\n}\n\nvoid inv_mpu_acpi_delete_mux_client(struct i2c_client *client)\n{\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}