{
  "module_name": "inv_mpu_core.c",
  "hash_id": "6845f82ddeeaede608c1ce25154c91c82d50eb64cfa8ca900e1763a454f57163",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/acpi.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n\n#include <linux/iio/common/inv_sensors_timestamp.h>\n#include <linux/iio/iio.h>\n\n#include \"inv_mpu_iio.h\"\n#include \"inv_mpu_magn.h\"\n\n \nstatic const int gyro_scale_6050[] = {133090, 266181, 532362, 1064724};\n\n \nstatic const int accel_scale[] = {598, 1196, 2392, 4785};\n\nstatic const struct inv_mpu6050_reg_map reg_set_icm20602 = {\n\t.sample_rate_div\t= INV_MPU6050_REG_SAMPLE_RATE_DIV,\n\t.lpf                    = INV_MPU6050_REG_CONFIG,\n\t.accel_lpf              = INV_MPU6500_REG_ACCEL_CONFIG_2,\n\t.user_ctrl              = INV_MPU6050_REG_USER_CTRL,\n\t.fifo_en                = INV_MPU6050_REG_FIFO_EN,\n\t.gyro_config            = INV_MPU6050_REG_GYRO_CONFIG,\n\t.accl_config            = INV_MPU6050_REG_ACCEL_CONFIG,\n\t.fifo_count_h           = INV_MPU6050_REG_FIFO_COUNT_H,\n\t.fifo_r_w               = INV_MPU6050_REG_FIFO_R_W,\n\t.raw_gyro               = INV_MPU6050_REG_RAW_GYRO,\n\t.raw_accl               = INV_MPU6050_REG_RAW_ACCEL,\n\t.temperature            = INV_MPU6050_REG_TEMPERATURE,\n\t.int_enable             = INV_MPU6050_REG_INT_ENABLE,\n\t.int_status             = INV_MPU6050_REG_INT_STATUS,\n\t.pwr_mgmt_1             = INV_MPU6050_REG_PWR_MGMT_1,\n\t.pwr_mgmt_2             = INV_MPU6050_REG_PWR_MGMT_2,\n\t.int_pin_cfg            = INV_MPU6050_REG_INT_PIN_CFG,\n\t.accl_offset            = INV_MPU6500_REG_ACCEL_OFFSET,\n\t.gyro_offset            = INV_MPU6050_REG_GYRO_OFFSET,\n\t.i2c_if                 = INV_ICM20602_REG_I2C_IF,\n};\n\nstatic const struct inv_mpu6050_reg_map reg_set_6500 = {\n\t.sample_rate_div\t= INV_MPU6050_REG_SAMPLE_RATE_DIV,\n\t.lpf                    = INV_MPU6050_REG_CONFIG,\n\t.accel_lpf              = INV_MPU6500_REG_ACCEL_CONFIG_2,\n\t.user_ctrl              = INV_MPU6050_REG_USER_CTRL,\n\t.fifo_en                = INV_MPU6050_REG_FIFO_EN,\n\t.gyro_config            = INV_MPU6050_REG_GYRO_CONFIG,\n\t.accl_config            = INV_MPU6050_REG_ACCEL_CONFIG,\n\t.fifo_count_h           = INV_MPU6050_REG_FIFO_COUNT_H,\n\t.fifo_r_w               = INV_MPU6050_REG_FIFO_R_W,\n\t.raw_gyro               = INV_MPU6050_REG_RAW_GYRO,\n\t.raw_accl               = INV_MPU6050_REG_RAW_ACCEL,\n\t.temperature            = INV_MPU6050_REG_TEMPERATURE,\n\t.int_enable             = INV_MPU6050_REG_INT_ENABLE,\n\t.int_status             = INV_MPU6050_REG_INT_STATUS,\n\t.pwr_mgmt_1             = INV_MPU6050_REG_PWR_MGMT_1,\n\t.pwr_mgmt_2             = INV_MPU6050_REG_PWR_MGMT_2,\n\t.int_pin_cfg\t\t= INV_MPU6050_REG_INT_PIN_CFG,\n\t.accl_offset\t\t= INV_MPU6500_REG_ACCEL_OFFSET,\n\t.gyro_offset\t\t= INV_MPU6050_REG_GYRO_OFFSET,\n\t.i2c_if                 = 0,\n};\n\nstatic const struct inv_mpu6050_reg_map reg_set_6050 = {\n\t.sample_rate_div\t= INV_MPU6050_REG_SAMPLE_RATE_DIV,\n\t.lpf                    = INV_MPU6050_REG_CONFIG,\n\t.user_ctrl              = INV_MPU6050_REG_USER_CTRL,\n\t.fifo_en                = INV_MPU6050_REG_FIFO_EN,\n\t.gyro_config            = INV_MPU6050_REG_GYRO_CONFIG,\n\t.accl_config            = INV_MPU6050_REG_ACCEL_CONFIG,\n\t.fifo_count_h           = INV_MPU6050_REG_FIFO_COUNT_H,\n\t.fifo_r_w               = INV_MPU6050_REG_FIFO_R_W,\n\t.raw_gyro               = INV_MPU6050_REG_RAW_GYRO,\n\t.raw_accl               = INV_MPU6050_REG_RAW_ACCEL,\n\t.temperature            = INV_MPU6050_REG_TEMPERATURE,\n\t.int_enable             = INV_MPU6050_REG_INT_ENABLE,\n\t.pwr_mgmt_1             = INV_MPU6050_REG_PWR_MGMT_1,\n\t.pwr_mgmt_2             = INV_MPU6050_REG_PWR_MGMT_2,\n\t.int_pin_cfg\t\t= INV_MPU6050_REG_INT_PIN_CFG,\n\t.accl_offset\t\t= INV_MPU6050_REG_ACCEL_OFFSET,\n\t.gyro_offset\t\t= INV_MPU6050_REG_GYRO_OFFSET,\n\t.i2c_if                 = 0,\n};\n\nstatic const struct inv_mpu6050_chip_config chip_config_6050 = {\n\t.clk = INV_CLK_INTERNAL,\n\t.fsr = INV_MPU6050_FSR_2000DPS,\n\t.lpf = INV_MPU6050_FILTER_20HZ,\n\t.divider = INV_MPU6050_FIFO_RATE_TO_DIVIDER(50),\n\t.gyro_en = true,\n\t.accl_en = true,\n\t.temp_en = true,\n\t.magn_en = false,\n\t.gyro_fifo_enable = false,\n\t.accl_fifo_enable = false,\n\t.temp_fifo_enable = false,\n\t.magn_fifo_enable = false,\n\t.accl_fs = INV_MPU6050_FS_02G,\n\t.user_ctrl = 0,\n};\n\nstatic const struct inv_mpu6050_chip_config chip_config_6500 = {\n\t.clk = INV_CLK_PLL,\n\t.fsr = INV_MPU6050_FSR_2000DPS,\n\t.lpf = INV_MPU6050_FILTER_20HZ,\n\t.divider = INV_MPU6050_FIFO_RATE_TO_DIVIDER(50),\n\t.gyro_en = true,\n\t.accl_en = true,\n\t.temp_en = true,\n\t.magn_en = false,\n\t.gyro_fifo_enable = false,\n\t.accl_fifo_enable = false,\n\t.temp_fifo_enable = false,\n\t.magn_fifo_enable = false,\n\t.accl_fs = INV_MPU6050_FS_02G,\n\t.user_ctrl = 0,\n};\n\n \nstatic const struct inv_mpu6050_hw hw_info[] = {\n\t{\n\t\t.whoami = INV_MPU6050_WHOAMI_VALUE,\n\t\t.name = \"MPU6050\",\n\t\t.reg = &reg_set_6050,\n\t\t.config = &chip_config_6050,\n\t\t.fifo_size = 1024,\n\t\t.temp = {INV_MPU6050_TEMP_OFFSET, INV_MPU6050_TEMP_SCALE},\n\t\t.startup_time = {INV_MPU6050_GYRO_STARTUP_TIME, INV_MPU6050_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_MPU6500_WHOAMI_VALUE,\n\t\t.name = \"MPU6500\",\n\t\t.reg = &reg_set_6500,\n\t\t.config = &chip_config_6500,\n\t\t.fifo_size = 512,\n\t\t.temp = {INV_MPU6500_TEMP_OFFSET, INV_MPU6500_TEMP_SCALE},\n\t\t.startup_time = {INV_MPU6500_GYRO_STARTUP_TIME, INV_MPU6500_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_MPU6515_WHOAMI_VALUE,\n\t\t.name = \"MPU6515\",\n\t\t.reg = &reg_set_6500,\n\t\t.config = &chip_config_6500,\n\t\t.fifo_size = 512,\n\t\t.temp = {INV_MPU6500_TEMP_OFFSET, INV_MPU6500_TEMP_SCALE},\n\t\t.startup_time = {INV_MPU6500_GYRO_STARTUP_TIME, INV_MPU6500_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_MPU6880_WHOAMI_VALUE,\n\t\t.name = \"MPU6880\",\n\t\t.reg = &reg_set_6500,\n\t\t.config = &chip_config_6500,\n\t\t.fifo_size = 4096,\n\t\t.temp = {INV_MPU6500_TEMP_OFFSET, INV_MPU6500_TEMP_SCALE},\n\t\t.startup_time = {INV_MPU6500_GYRO_STARTUP_TIME, INV_MPU6500_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_MPU6000_WHOAMI_VALUE,\n\t\t.name = \"MPU6000\",\n\t\t.reg = &reg_set_6050,\n\t\t.config = &chip_config_6050,\n\t\t.fifo_size = 1024,\n\t\t.temp = {INV_MPU6050_TEMP_OFFSET, INV_MPU6050_TEMP_SCALE},\n\t\t.startup_time = {INV_MPU6050_GYRO_STARTUP_TIME, INV_MPU6050_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_MPU9150_WHOAMI_VALUE,\n\t\t.name = \"MPU9150\",\n\t\t.reg = &reg_set_6050,\n\t\t.config = &chip_config_6050,\n\t\t.fifo_size = 1024,\n\t\t.temp = {INV_MPU6050_TEMP_OFFSET, INV_MPU6050_TEMP_SCALE},\n\t\t.startup_time = {INV_MPU6050_GYRO_STARTUP_TIME, INV_MPU6050_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_MPU9250_WHOAMI_VALUE,\n\t\t.name = \"MPU9250\",\n\t\t.reg = &reg_set_6500,\n\t\t.config = &chip_config_6500,\n\t\t.fifo_size = 512,\n\t\t.temp = {INV_MPU6500_TEMP_OFFSET, INV_MPU6500_TEMP_SCALE},\n\t\t.startup_time = {INV_MPU6500_GYRO_STARTUP_TIME, INV_MPU6500_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_MPU9255_WHOAMI_VALUE,\n\t\t.name = \"MPU9255\",\n\t\t.reg = &reg_set_6500,\n\t\t.config = &chip_config_6500,\n\t\t.fifo_size = 512,\n\t\t.temp = {INV_MPU6500_TEMP_OFFSET, INV_MPU6500_TEMP_SCALE},\n\t\t.startup_time = {INV_MPU6500_GYRO_STARTUP_TIME, INV_MPU6500_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_ICM20608_WHOAMI_VALUE,\n\t\t.name = \"ICM20608\",\n\t\t.reg = &reg_set_6500,\n\t\t.config = &chip_config_6500,\n\t\t.fifo_size = 512,\n\t\t.temp = {INV_ICM20608_TEMP_OFFSET, INV_ICM20608_TEMP_SCALE},\n\t\t.startup_time = {INV_MPU6500_GYRO_STARTUP_TIME, INV_MPU6500_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_ICM20608D_WHOAMI_VALUE,\n\t\t.name = \"ICM20608D\",\n\t\t.reg = &reg_set_6500,\n\t\t.config = &chip_config_6500,\n\t\t.fifo_size = 512,\n\t\t.temp = {INV_ICM20608_TEMP_OFFSET, INV_ICM20608_TEMP_SCALE},\n\t\t.startup_time = {INV_MPU6500_GYRO_STARTUP_TIME, INV_MPU6500_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_ICM20609_WHOAMI_VALUE,\n\t\t.name = \"ICM20609\",\n\t\t.reg = &reg_set_6500,\n\t\t.config = &chip_config_6500,\n\t\t.fifo_size = 4 * 1024,\n\t\t.temp = {INV_ICM20608_TEMP_OFFSET, INV_ICM20608_TEMP_SCALE},\n\t\t.startup_time = {INV_MPU6500_GYRO_STARTUP_TIME, INV_MPU6500_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_ICM20689_WHOAMI_VALUE,\n\t\t.name = \"ICM20689\",\n\t\t.reg = &reg_set_6500,\n\t\t.config = &chip_config_6500,\n\t\t.fifo_size = 4 * 1024,\n\t\t.temp = {INV_ICM20608_TEMP_OFFSET, INV_ICM20608_TEMP_SCALE},\n\t\t.startup_time = {INV_MPU6500_GYRO_STARTUP_TIME, INV_MPU6500_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_ICM20600_WHOAMI_VALUE,\n\t\t.name = \"ICM20600\",\n\t\t.reg = &reg_set_icm20602,\n\t\t.config = &chip_config_6500,\n\t\t.fifo_size = 1008,\n\t\t.temp = {INV_ICM20608_TEMP_OFFSET, INV_ICM20608_TEMP_SCALE},\n\t\t.startup_time = {INV_ICM20602_GYRO_STARTUP_TIME, INV_ICM20602_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_ICM20602_WHOAMI_VALUE,\n\t\t.name = \"ICM20602\",\n\t\t.reg = &reg_set_icm20602,\n\t\t.config = &chip_config_6500,\n\t\t.fifo_size = 1008,\n\t\t.temp = {INV_ICM20608_TEMP_OFFSET, INV_ICM20608_TEMP_SCALE},\n\t\t.startup_time = {INV_ICM20602_GYRO_STARTUP_TIME, INV_ICM20602_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_ICM20690_WHOAMI_VALUE,\n\t\t.name = \"ICM20690\",\n\t\t.reg = &reg_set_6500,\n\t\t.config = &chip_config_6500,\n\t\t.fifo_size = 1024,\n\t\t.temp = {INV_ICM20608_TEMP_OFFSET, INV_ICM20608_TEMP_SCALE},\n\t\t.startup_time = {INV_ICM20690_GYRO_STARTUP_TIME, INV_ICM20690_ACCEL_STARTUP_TIME},\n\t},\n\t{\n\t\t.whoami = INV_IAM20680_WHOAMI_VALUE,\n\t\t.name = \"IAM20680\",\n\t\t.reg = &reg_set_6500,\n\t\t.config = &chip_config_6500,\n\t\t.fifo_size = 512,\n\t\t.temp = {INV_ICM20608_TEMP_OFFSET, INV_ICM20608_TEMP_SCALE},\n\t\t.startup_time = {INV_MPU6500_GYRO_STARTUP_TIME, INV_MPU6500_ACCEL_STARTUP_TIME},\n\t},\n};\n\nstatic int inv_mpu6050_pwr_mgmt_1_write(struct inv_mpu6050_state *st, bool sleep,\n\t\t\t\t\tint clock, int temp_dis)\n{\n\tu8 val;\n\n\tif (clock < 0)\n\t\tclock = st->chip_config.clk;\n\tif (temp_dis < 0)\n\t\ttemp_dis = !st->chip_config.temp_en;\n\n\tval = clock & INV_MPU6050_BIT_CLK_MASK;\n\tif (temp_dis)\n\t\tval |= INV_MPU6050_BIT_TEMP_DIS;\n\tif (sleep)\n\t\tval |= INV_MPU6050_BIT_SLEEP;\n\n\tdev_dbg(regmap_get_device(st->map), \"pwr_mgmt_1: 0x%x\\n\", val);\n\treturn regmap_write(st->map, st->reg->pwr_mgmt_1, val);\n}\n\nstatic int inv_mpu6050_clock_switch(struct inv_mpu6050_state *st,\n\t\t\t\t    unsigned int clock)\n{\n\tint ret;\n\n\tswitch (st->chip_type) {\n\tcase INV_MPU6050:\n\tcase INV_MPU6000:\n\tcase INV_MPU9150:\n\t\t \n\t\tret = inv_mpu6050_pwr_mgmt_1_write(st, false, clock, -1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tst->chip_config.clk = clock;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint inv_mpu6050_switch_engine(struct inv_mpu6050_state *st, bool en,\n\t\t\t      unsigned int mask)\n{\n\tunsigned int sleep;\n\tu8 pwr_mgmt2, user_ctrl;\n\tint ret;\n\n\t \n\tif (mask & INV_MPU6050_SENSOR_ACCL && en == st->chip_config.accl_en)\n\t\tmask &= ~INV_MPU6050_SENSOR_ACCL;\n\tif (mask & INV_MPU6050_SENSOR_GYRO && en == st->chip_config.gyro_en)\n\t\tmask &= ~INV_MPU6050_SENSOR_GYRO;\n\tif (mask & INV_MPU6050_SENSOR_TEMP && en == st->chip_config.temp_en)\n\t\tmask &= ~INV_MPU6050_SENSOR_TEMP;\n\tif (mask & INV_MPU6050_SENSOR_MAGN && en == st->chip_config.magn_en)\n\t\tmask &= ~INV_MPU6050_SENSOR_MAGN;\n\tif (mask == 0)\n\t\treturn 0;\n\n\t \n\tif (mask & INV_MPU6050_SENSOR_TEMP) {\n\t\tret = inv_mpu6050_pwr_mgmt_1_write(st, false, -1, !en);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tst->chip_config.temp_en = en;\n\t}\n\n\t \n\tif (mask & INV_MPU6050_SENSOR_MAGN) {\n\t\tuser_ctrl = st->chip_config.user_ctrl;\n\t\tif (en)\n\t\t\tuser_ctrl |= INV_MPU6050_BIT_I2C_MST_EN;\n\t\telse\n\t\t\tuser_ctrl &= ~INV_MPU6050_BIT_I2C_MST_EN;\n\t\tret = regmap_write(st->map, st->reg->user_ctrl, user_ctrl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tst->chip_config.user_ctrl = user_ctrl;\n\t\tst->chip_config.magn_en = en;\n\t}\n\n\t \n\tif (mask & (INV_MPU6050_SENSOR_ACCL | INV_MPU6050_SENSOR_GYRO)) {\n\t\t \n\t\tpwr_mgmt2 = 0;\n\t\tif (!st->chip_config.accl_en)\n\t\t\tpwr_mgmt2 |= INV_MPU6050_BIT_PWR_ACCL_STBY;\n\t\tif (!st->chip_config.gyro_en)\n\t\t\tpwr_mgmt2 |= INV_MPU6050_BIT_PWR_GYRO_STBY;\n\n\t\t \n\t\tif (mask & INV_MPU6050_SENSOR_ACCL) {\n\t\t\tif (en)\n\t\t\t\tpwr_mgmt2 &= ~INV_MPU6050_BIT_PWR_ACCL_STBY;\n\t\t\telse\n\t\t\t\tpwr_mgmt2 |= INV_MPU6050_BIT_PWR_ACCL_STBY;\n\t\t}\n\t\tif (mask & INV_MPU6050_SENSOR_GYRO) {\n\t\t\tif (en)\n\t\t\t\tpwr_mgmt2 &= ~INV_MPU6050_BIT_PWR_GYRO_STBY;\n\t\t\telse\n\t\t\t\tpwr_mgmt2 |= INV_MPU6050_BIT_PWR_GYRO_STBY;\n\t\t}\n\n\t\t \n\t\tif (mask & INV_MPU6050_SENSOR_GYRO && !en) {\n\t\t\tret = inv_mpu6050_clock_switch(st, INV_CLK_INTERNAL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tdev_dbg(regmap_get_device(st->map), \"pwr_mgmt_2: 0x%x\\n\",\n\t\t\tpwr_mgmt2);\n\t\tret = regmap_write(st->map, st->reg->pwr_mgmt_2, pwr_mgmt2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (mask & INV_MPU6050_SENSOR_ACCL)\n\t\t\tst->chip_config.accl_en = en;\n\t\tif (mask & INV_MPU6050_SENSOR_GYRO)\n\t\t\tst->chip_config.gyro_en = en;\n\n\t\t \n\t\tsleep = 0;\n\t\tif (en) {\n\t\t\tif (mask & INV_MPU6050_SENSOR_ACCL) {\n\t\t\t\tif (sleep < st->hw->startup_time.accel)\n\t\t\t\t\tsleep = st->hw->startup_time.accel;\n\t\t\t}\n\t\t\tif (mask & INV_MPU6050_SENSOR_GYRO) {\n\t\t\t\tif (sleep < st->hw->startup_time.gyro)\n\t\t\t\t\tsleep = st->hw->startup_time.gyro;\n\t\t\t}\n\t\t} else {\n\t\t\tif (mask & INV_MPU6050_SENSOR_GYRO) {\n\t\t\t\tif (sleep < INV_MPU6050_GYRO_DOWN_TIME)\n\t\t\t\t\tsleep = INV_MPU6050_GYRO_DOWN_TIME;\n\t\t\t}\n\t\t}\n\t\tif (sleep)\n\t\t\tmsleep(sleep);\n\n\t\t \n\t\tif (mask & INV_MPU6050_SENSOR_GYRO && en) {\n\t\t\tret = inv_mpu6050_clock_switch(st, INV_CLK_PLL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int inv_mpu6050_set_power_itg(struct inv_mpu6050_state *st,\n\t\t\t\t     bool power_on)\n{\n\tint result;\n\n\tresult = inv_mpu6050_pwr_mgmt_1_write(st, !power_on, -1, -1);\n\tif (result)\n\t\treturn result;\n\n\tif (power_on)\n\t\tusleep_range(INV_MPU6050_REG_UP_TIME_MIN,\n\t\t\t     INV_MPU6050_REG_UP_TIME_MAX);\n\n\treturn 0;\n}\n\nstatic int inv_mpu6050_set_gyro_fsr(struct inv_mpu6050_state *st,\n\t\t\t\t    enum inv_mpu6050_fsr_e val)\n{\n\tunsigned int gyro_shift;\n\tu8 data;\n\n\tswitch (st->chip_type) {\n\tcase INV_ICM20690:\n\t\tgyro_shift = INV_ICM20690_GYRO_CONFIG_FSR_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tgyro_shift = INV_MPU6050_GYRO_CONFIG_FSR_SHIFT;\n\t\tbreak;\n\t}\n\n\tdata = val << gyro_shift;\n\treturn regmap_write(st->map, st->reg->gyro_config, data);\n}\n\n \nstatic int inv_mpu6050_set_lpf_regs(struct inv_mpu6050_state *st,\n\t\t\t\t    enum inv_mpu6050_filter_e val)\n{\n\tint result;\n\n\tresult = regmap_write(st->map, st->reg->lpf, val);\n\tif (result)\n\t\treturn result;\n\n\t \n\tswitch (st->chip_type) {\n\tcase INV_MPU6050:\n\tcase INV_MPU6000:\n\tcase INV_MPU9150:\n\t\t \n\t\treturn 0;\n\tcase INV_ICM20689:\n\tcase INV_ICM20690:\n\t\t \n\t\tval |= INV_ICM20689_BITS_FIFO_SIZE_MAX;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn regmap_write(st->map, st->reg->accel_lpf, val);\n}\n\n \nstatic int inv_mpu6050_init_config(struct iio_dev *indio_dev)\n{\n\tint result;\n\tu8 d;\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\tstruct inv_sensors_timestamp_chip timestamp;\n\n\tresult = inv_mpu6050_set_gyro_fsr(st, st->chip_config.fsr);\n\tif (result)\n\t\treturn result;\n\n\tresult = inv_mpu6050_set_lpf_regs(st, st->chip_config.lpf);\n\tif (result)\n\t\treturn result;\n\n\td = st->chip_config.divider;\n\tresult = regmap_write(st->map, st->reg->sample_rate_div, d);\n\tif (result)\n\t\treturn result;\n\n\td = (st->chip_config.accl_fs << INV_MPU6050_ACCL_CONFIG_FSR_SHIFT);\n\tresult = regmap_write(st->map, st->reg->accl_config, d);\n\tif (result)\n\t\treturn result;\n\n\tresult = regmap_write(st->map, st->reg->int_pin_cfg, st->irq_mask);\n\tif (result)\n\t\treturn result;\n\n\t \n\ttimestamp.clock_period = NSEC_PER_SEC / INV_MPU6050_INTERNAL_FREQ_HZ;\n\ttimestamp.jitter = 20;\n\ttimestamp.init_period =\n\t\t\tNSEC_PER_SEC / INV_MPU6050_DIVIDER_TO_FIFO_RATE(st->chip_config.divider);\n\tinv_sensors_timestamp_init(&st->timestamp, &timestamp);\n\n\t \n\tresult = inv_mpu_magn_probe(st);\n\tif (result)\n\t\treturn result;\n\n\treturn 0;\n}\n\nstatic int inv_mpu6050_sensor_set(struct inv_mpu6050_state  *st, int reg,\n\t\t\t\tint axis, int val)\n{\n\tint ind, result;\n\t__be16 d = cpu_to_be16(val);\n\n\tind = (axis - IIO_MOD_X) * 2;\n\tresult = regmap_bulk_write(st->map, reg + ind, &d, sizeof(d));\n\tif (result)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int inv_mpu6050_sensor_show(struct inv_mpu6050_state  *st, int reg,\n\t\t\t\t   int axis, int *val)\n{\n\tint ind, result;\n\t__be16 d;\n\n\tind = (axis - IIO_MOD_X) * 2;\n\tresult = regmap_bulk_read(st->map, reg + ind, &d, sizeof(d));\n\tif (result)\n\t\treturn -EINVAL;\n\t*val = (short)be16_to_cpup(&d);\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int inv_mpu6050_read_channel_data(struct iio_dev *indio_dev,\n\t\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t\t int *val)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\tstruct device *pdev = regmap_get_device(st->map);\n\tunsigned int freq_hz, period_us, min_sleep_us, max_sleep_us;\n\tint result;\n\tint ret;\n\n\t \n\tfreq_hz = INV_MPU6050_DIVIDER_TO_FIFO_RATE(st->chip_config.divider);\n\tperiod_us = 1000000 / freq_hz;\n\n\tresult = pm_runtime_resume_and_get(pdev);\n\tif (result)\n\t\treturn result;\n\n\tswitch (chan->type) {\n\tcase IIO_ANGL_VEL:\n\t\tif (!st->chip_config.gyro_en) {\n\t\t\tresult = inv_mpu6050_switch_engine(st, true,\n\t\t\t\t\tINV_MPU6050_SENSOR_GYRO);\n\t\t\tif (result)\n\t\t\t\tgoto error_power_off;\n\t\t\t \n\t\t\tmin_sleep_us = 2 * period_us;\n\t\t\tmax_sleep_us = 2 * (period_us + period_us / 2);\n\t\t\tusleep_range(min_sleep_us, max_sleep_us);\n\t\t}\n\t\tret = inv_mpu6050_sensor_show(st, st->reg->raw_gyro,\n\t\t\t\t\t      chan->channel2, val);\n\t\tbreak;\n\tcase IIO_ACCEL:\n\t\tif (!st->chip_config.accl_en) {\n\t\t\tresult = inv_mpu6050_switch_engine(st, true,\n\t\t\t\t\tINV_MPU6050_SENSOR_ACCL);\n\t\t\tif (result)\n\t\t\t\tgoto error_power_off;\n\t\t\t \n\t\t\tmin_sleep_us = period_us;\n\t\t\tmax_sleep_us = period_us + period_us / 2;\n\t\t\tusleep_range(min_sleep_us, max_sleep_us);\n\t\t}\n\t\tret = inv_mpu6050_sensor_show(st, st->reg->raw_accl,\n\t\t\t\t\t      chan->channel2, val);\n\t\tbreak;\n\tcase IIO_TEMP:\n\t\t \n\t\tif (!st->chip_config.accl_en && !st->chip_config.gyro_en) {\n\t\t\tresult = -EBUSY;\n\t\t\tgoto error_power_off;\n\t\t}\n\t\tif (!st->chip_config.temp_en) {\n\t\t\tresult = inv_mpu6050_switch_engine(st, true,\n\t\t\t\t\tINV_MPU6050_SENSOR_TEMP);\n\t\t\tif (result)\n\t\t\t\tgoto error_power_off;\n\t\t\t \n\t\t\tmin_sleep_us = period_us;\n\t\t\tmax_sleep_us = period_us + period_us / 2;\n\t\t\tusleep_range(min_sleep_us, max_sleep_us);\n\t\t}\n\t\tret = inv_mpu6050_sensor_show(st, st->reg->temperature,\n\t\t\t\t\t      IIO_MOD_X, val);\n\t\tbreak;\n\tcase IIO_MAGN:\n\t\tif (!st->chip_config.magn_en) {\n\t\t\tresult = inv_mpu6050_switch_engine(st, true,\n\t\t\t\t\tINV_MPU6050_SENSOR_MAGN);\n\t\t\tif (result)\n\t\t\t\tgoto error_power_off;\n\t\t\t \n\t\t\tif (freq_hz > INV_MPU_MAGN_FREQ_HZ_MAX) {\n\t\t\t\tfreq_hz = INV_MPU_MAGN_FREQ_HZ_MAX;\n\t\t\t\tperiod_us = 1000000 / freq_hz;\n\t\t\t}\n\t\t\t \n\t\t\tmin_sleep_us = 2 * period_us;\n\t\t\tmax_sleep_us = 2 * (period_us + period_us / 2);\n\t\t\tusleep_range(min_sleep_us, max_sleep_us);\n\t\t}\n\t\tret = inv_mpu_magn_read(st, chan->channel2, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_mark_last_busy(pdev);\n\tpm_runtime_put_autosuspend(pdev);\n\n\treturn ret;\n\nerror_power_off:\n\tpm_runtime_put_autosuspend(pdev);\n\treturn result;\n}\n\nstatic int\ninv_mpu6050_read_raw(struct iio_dev *indio_dev,\n\t\t     struct iio_chan_spec const *chan,\n\t\t     int *val, int *val2, long mask)\n{\n\tstruct inv_mpu6050_state  *st = iio_priv(indio_dev);\n\tint ret = 0;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmutex_lock(&st->lock);\n\t\tret = inv_mpu6050_read_channel_data(indio_dev, chan, val);\n\t\tmutex_unlock(&st->lock);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\tmutex_lock(&st->lock);\n\t\t\t*val  = 0;\n\t\t\t*val2 = gyro_scale_6050[st->chip_config.fsr];\n\t\t\tmutex_unlock(&st->lock);\n\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tcase IIO_ACCEL:\n\t\t\tmutex_lock(&st->lock);\n\t\t\t*val = 0;\n\t\t\t*val2 = accel_scale[st->chip_config.accl_fs];\n\t\t\tmutex_unlock(&st->lock);\n\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_TEMP:\n\t\t\t*val = st->hw->temp.scale / 1000000;\n\t\t\t*val2 = st->hw->temp.scale % 1000000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_MAGN:\n\t\t\treturn inv_mpu_magn_get_scale(st, chan, val, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t*val = st->hw->temp.offset;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\tmutex_lock(&st->lock);\n\t\t\tret = inv_mpu6050_sensor_show(st, st->reg->gyro_offset,\n\t\t\t\t\t\tchan->channel2, val);\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn ret;\n\t\tcase IIO_ACCEL:\n\t\t\tmutex_lock(&st->lock);\n\t\t\tret = inv_mpu6050_sensor_show(st, st->reg->accl_offset,\n\t\t\t\t\t\tchan->channel2, val);\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn ret;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int inv_mpu6050_write_gyro_scale(struct inv_mpu6050_state *st, int val,\n\t\t\t\t\tint val2)\n{\n\tint result, i;\n\n\tif (val != 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(gyro_scale_6050); ++i) {\n\t\tif (gyro_scale_6050[i] == val2) {\n\t\t\tresult = inv_mpu6050_set_gyro_fsr(st, i);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\n\t\t\tst->chip_config.fsr = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int inv_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tdefault:\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\tdefault:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int inv_mpu6050_write_accel_scale(struct inv_mpu6050_state *st, int val,\n\t\t\t\t\t int val2)\n{\n\tint result, i;\n\tu8 d;\n\n\tif (val != 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(accel_scale); ++i) {\n\t\tif (accel_scale[i] == val2) {\n\t\t\td = (i << INV_MPU6050_ACCL_CONFIG_FSR_SHIFT);\n\t\t\tresult = regmap_write(st->map, st->reg->accl_config, d);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\n\t\t\tst->chip_config.accl_fs = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int inv_mpu6050_write_raw(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int val, int val2, long mask)\n{\n\tstruct inv_mpu6050_state  *st = iio_priv(indio_dev);\n\tstruct device *pdev = regmap_get_device(st->map);\n\tint result;\n\n\t \n\tresult = iio_device_claim_direct_mode(indio_dev);\n\tif (result)\n\t\treturn result;\n\n\tmutex_lock(&st->lock);\n\tresult = pm_runtime_resume_and_get(pdev);\n\tif (result)\n\t\tgoto error_write_raw_unlock;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\tresult = inv_mpu6050_write_gyro_scale(st, val, val2);\n\t\t\tbreak;\n\t\tcase IIO_ACCEL:\n\t\t\tresult = inv_mpu6050_write_accel_scale(st, val, val2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\tresult = inv_mpu6050_sensor_set(st,\n\t\t\t\t\t\t\tst->reg->gyro_offset,\n\t\t\t\t\t\t\tchan->channel2, val);\n\t\t\tbreak;\n\t\tcase IIO_ACCEL:\n\t\t\tresult = inv_mpu6050_sensor_set(st,\n\t\t\t\t\t\t\tst->reg->accl_offset,\n\t\t\t\t\t\t\tchan->channel2, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_mark_last_busy(pdev);\n\tpm_runtime_put_autosuspend(pdev);\nerror_write_raw_unlock:\n\tmutex_unlock(&st->lock);\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn result;\n}\n\n \nstatic int inv_mpu6050_set_lpf(struct inv_mpu6050_state *st, int rate)\n{\n\tstatic const int hz[] = {400, 200, 90, 40, 20, 10};\n\tstatic const int d[] = {\n\t\tINV_MPU6050_FILTER_200HZ, INV_MPU6050_FILTER_100HZ,\n\t\tINV_MPU6050_FILTER_45HZ, INV_MPU6050_FILTER_20HZ,\n\t\tINV_MPU6050_FILTER_10HZ, INV_MPU6050_FILTER_5HZ\n\t};\n\tint i, result;\n\tu8 data;\n\n\tdata = INV_MPU6050_FILTER_5HZ;\n\tfor (i = 0; i < ARRAY_SIZE(hz); ++i) {\n\t\tif (rate >= hz[i]) {\n\t\t\tdata = d[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tresult = inv_mpu6050_set_lpf_regs(st, data);\n\tif (result)\n\t\treturn result;\n\tst->chip_config.lpf = data;\n\n\treturn 0;\n}\n\n \nstatic ssize_t\ninv_mpu6050_fifo_rate_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint fifo_rate;\n\tu32 fifo_period;\n\tbool fifo_on;\n\tu8 d;\n\tint result;\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\tstruct device *pdev = regmap_get_device(st->map);\n\n\tif (kstrtoint(buf, 10, &fifo_rate))\n\t\treturn -EINVAL;\n\tif (fifo_rate < INV_MPU6050_MIN_FIFO_RATE ||\n\t    fifo_rate > INV_MPU6050_MAX_FIFO_RATE)\n\t\treturn -EINVAL;\n\n\t \n\td = INV_MPU6050_FIFO_RATE_TO_DIVIDER(fifo_rate);\n\t \n\tfifo_rate = INV_MPU6050_DIVIDER_TO_FIFO_RATE(d);\n\tfifo_period = NSEC_PER_SEC / fifo_rate;\n\n\tmutex_lock(&st->lock);\n\tif (d == st->chip_config.divider) {\n\t\tresult = 0;\n\t\tgoto fifo_rate_fail_unlock;\n\t}\n\n\tfifo_on = st->chip_config.accl_fifo_enable ||\n\t\t  st->chip_config.gyro_fifo_enable ||\n\t\t  st->chip_config.magn_fifo_enable;\n\tresult = inv_sensors_timestamp_update_odr(&st->timestamp, fifo_period, fifo_on);\n\tif (result)\n\t\tgoto fifo_rate_fail_unlock;\n\n\tresult = pm_runtime_resume_and_get(pdev);\n\tif (result)\n\t\tgoto fifo_rate_fail_unlock;\n\n\tresult = regmap_write(st->map, st->reg->sample_rate_div, d);\n\tif (result)\n\t\tgoto fifo_rate_fail_power_off;\n\tst->chip_config.divider = d;\n\n\tresult = inv_mpu6050_set_lpf(st, fifo_rate);\n\tif (result)\n\t\tgoto fifo_rate_fail_power_off;\n\n\t \n\tresult = inv_mpu_magn_set_rate(st, fifo_rate);\n\tif (result)\n\t\tgoto fifo_rate_fail_power_off;\n\n\tpm_runtime_mark_last_busy(pdev);\nfifo_rate_fail_power_off:\n\tpm_runtime_put_autosuspend(pdev);\nfifo_rate_fail_unlock:\n\tmutex_unlock(&st->lock);\n\tif (result)\n\t\treturn result;\n\n\treturn count;\n}\n\n \nstatic ssize_t\ninv_fifo_rate_show(struct device *dev, struct device_attribute *attr,\n\t\t   char *buf)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(dev_to_iio_dev(dev));\n\tunsigned fifo_rate;\n\n\tmutex_lock(&st->lock);\n\tfifo_rate = INV_MPU6050_DIVIDER_TO_FIFO_RATE(st->chip_config.divider);\n\tmutex_unlock(&st->lock);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", fifo_rate);\n}\n\n \nstatic ssize_t inv_attr_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(dev_to_iio_dev(dev));\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\ts8 *m;\n\n\tswitch (this_attr->address) {\n\t \n\tcase ATTR_GYRO_MATRIX:\n\tcase ATTR_ACCL_MATRIX:\n\t\tm = st->plat_data.orientation;\n\n\t\treturn scnprintf(buf, PAGE_SIZE,\n\t\t\t\"%d, %d, %d; %d, %d, %d; %d, %d, %d\\n\",\n\t\t\tm[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int inv_mpu6050_validate_trigger(struct iio_dev *indio_dev,\n\t\t\t\t\tstruct iio_trigger *trig)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\n\tif (st->trig != trig)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct iio_mount_matrix *\ninv_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t     const struct iio_chan_spec *chan)\n{\n\tstruct inv_mpu6050_state *data = iio_priv(indio_dev);\n\tconst struct iio_mount_matrix *matrix;\n\n\tif (chan->type == IIO_MAGN)\n\t\tmatrix = &data->magn_orient;\n\telse\n\t\tmatrix = &data->orientation;\n\n\treturn matrix;\n}\n\nstatic const struct iio_chan_spec_ext_info inv_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_TYPE, inv_get_mount_matrix),\n\t{ }\n};\n\n#define INV_MPU6050_CHAN(_type, _channel2, _index)                    \\\n\t{                                                             \\\n\t\t.type = _type,                                        \\\n\t\t.modified = 1,                                        \\\n\t\t.channel2 = _channel2,                                \\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t      \\\n\t\t\t\t      BIT(IIO_CHAN_INFO_CALIBBIAS),   \\\n\t\t.scan_index = _index,                                 \\\n\t\t.scan_type = {                                        \\\n\t\t\t\t.sign = 's',                          \\\n\t\t\t\t.realbits = 16,                       \\\n\t\t\t\t.storagebits = 16,                    \\\n\t\t\t\t.shift = 0,                           \\\n\t\t\t\t.endianness = IIO_BE,                 \\\n\t\t\t     },                                       \\\n\t\t.ext_info = inv_ext_info,                             \\\n\t}\n\n#define INV_MPU6050_TEMP_CHAN(_index)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.type = IIO_TEMP,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)\t\\\n\t\t\t\t| BIT(IIO_CHAN_INFO_OFFSET)\t\\\n\t\t\t\t| BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t\t.scan_index = _index,\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\\\n\t\t\t.realbits = 16,\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\\\n\t\t\t.shift = 0,\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec inv_mpu_channels[] = {\n\tIIO_CHAN_SOFT_TIMESTAMP(INV_MPU6050_SCAN_TIMESTAMP),\n\n\tINV_MPU6050_TEMP_CHAN(INV_MPU6050_SCAN_TEMP),\n\n\tINV_MPU6050_CHAN(IIO_ANGL_VEL, IIO_MOD_X, INV_MPU6050_SCAN_GYRO_X),\n\tINV_MPU6050_CHAN(IIO_ANGL_VEL, IIO_MOD_Y, INV_MPU6050_SCAN_GYRO_Y),\n\tINV_MPU6050_CHAN(IIO_ANGL_VEL, IIO_MOD_Z, INV_MPU6050_SCAN_GYRO_Z),\n\n\tINV_MPU6050_CHAN(IIO_ACCEL, IIO_MOD_X, INV_MPU6050_SCAN_ACCL_X),\n\tINV_MPU6050_CHAN(IIO_ACCEL, IIO_MOD_Y, INV_MPU6050_SCAN_ACCL_Y),\n\tINV_MPU6050_CHAN(IIO_ACCEL, IIO_MOD_Z, INV_MPU6050_SCAN_ACCL_Z),\n};\n\n#define INV_MPU6050_SCAN_MASK_3AXIS_ACCEL\t\\\n\t(BIT(INV_MPU6050_SCAN_ACCL_X)\t\t\\\n\t| BIT(INV_MPU6050_SCAN_ACCL_Y)\t\t\\\n\t| BIT(INV_MPU6050_SCAN_ACCL_Z))\n\n#define INV_MPU6050_SCAN_MASK_3AXIS_GYRO\t\\\n\t(BIT(INV_MPU6050_SCAN_GYRO_X)\t\t\\\n\t| BIT(INV_MPU6050_SCAN_GYRO_Y)\t\t\\\n\t| BIT(INV_MPU6050_SCAN_GYRO_Z))\n\n#define INV_MPU6050_SCAN_MASK_TEMP\t\t(BIT(INV_MPU6050_SCAN_TEMP))\n\nstatic const unsigned long inv_mpu_scan_masks[] = {\n\t \n\tINV_MPU6050_SCAN_MASK_3AXIS_ACCEL,\n\tINV_MPU6050_SCAN_MASK_3AXIS_ACCEL | INV_MPU6050_SCAN_MASK_TEMP,\n\t \n\tINV_MPU6050_SCAN_MASK_3AXIS_GYRO,\n\tINV_MPU6050_SCAN_MASK_3AXIS_GYRO | INV_MPU6050_SCAN_MASK_TEMP,\n\t \n\tINV_MPU6050_SCAN_MASK_3AXIS_ACCEL | INV_MPU6050_SCAN_MASK_3AXIS_GYRO,\n\tINV_MPU6050_SCAN_MASK_3AXIS_ACCEL | INV_MPU6050_SCAN_MASK_3AXIS_GYRO\n\t\t| INV_MPU6050_SCAN_MASK_TEMP,\n\t0,\n};\n\n#define INV_MPU9X50_MAGN_CHAN(_chan2, _bits, _index)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_MAGN,\t\t\t\t\t\\\n\t\t.modified = 1,\t\t\t\t\t\t\\\n\t\t.channel2 = _chan2,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\t      BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.scan_index = _index,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\t\\\n\t\t\t.realbits = _bits,\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.shift = 0,\t\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.ext_info = inv_ext_info,\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec inv_mpu9150_channels[] = {\n\tIIO_CHAN_SOFT_TIMESTAMP(INV_MPU9X50_SCAN_TIMESTAMP),\n\n\tINV_MPU6050_TEMP_CHAN(INV_MPU6050_SCAN_TEMP),\n\n\tINV_MPU6050_CHAN(IIO_ANGL_VEL, IIO_MOD_X, INV_MPU6050_SCAN_GYRO_X),\n\tINV_MPU6050_CHAN(IIO_ANGL_VEL, IIO_MOD_Y, INV_MPU6050_SCAN_GYRO_Y),\n\tINV_MPU6050_CHAN(IIO_ANGL_VEL, IIO_MOD_Z, INV_MPU6050_SCAN_GYRO_Z),\n\n\tINV_MPU6050_CHAN(IIO_ACCEL, IIO_MOD_X, INV_MPU6050_SCAN_ACCL_X),\n\tINV_MPU6050_CHAN(IIO_ACCEL, IIO_MOD_Y, INV_MPU6050_SCAN_ACCL_Y),\n\tINV_MPU6050_CHAN(IIO_ACCEL, IIO_MOD_Z, INV_MPU6050_SCAN_ACCL_Z),\n\n\t \n\tINV_MPU9X50_MAGN_CHAN(IIO_MOD_X, 13, INV_MPU9X50_SCAN_MAGN_X),\n\tINV_MPU9X50_MAGN_CHAN(IIO_MOD_Y, 13, INV_MPU9X50_SCAN_MAGN_Y),\n\tINV_MPU9X50_MAGN_CHAN(IIO_MOD_Z, 13, INV_MPU9X50_SCAN_MAGN_Z),\n};\n\nstatic const struct iio_chan_spec inv_mpu9250_channels[] = {\n\tIIO_CHAN_SOFT_TIMESTAMP(INV_MPU9X50_SCAN_TIMESTAMP),\n\n\tINV_MPU6050_TEMP_CHAN(INV_MPU6050_SCAN_TEMP),\n\n\tINV_MPU6050_CHAN(IIO_ANGL_VEL, IIO_MOD_X, INV_MPU6050_SCAN_GYRO_X),\n\tINV_MPU6050_CHAN(IIO_ANGL_VEL, IIO_MOD_Y, INV_MPU6050_SCAN_GYRO_Y),\n\tINV_MPU6050_CHAN(IIO_ANGL_VEL, IIO_MOD_Z, INV_MPU6050_SCAN_GYRO_Z),\n\n\tINV_MPU6050_CHAN(IIO_ACCEL, IIO_MOD_X, INV_MPU6050_SCAN_ACCL_X),\n\tINV_MPU6050_CHAN(IIO_ACCEL, IIO_MOD_Y, INV_MPU6050_SCAN_ACCL_Y),\n\tINV_MPU6050_CHAN(IIO_ACCEL, IIO_MOD_Z, INV_MPU6050_SCAN_ACCL_Z),\n\n\t \n\tINV_MPU9X50_MAGN_CHAN(IIO_MOD_X, 16, INV_MPU9X50_SCAN_MAGN_X),\n\tINV_MPU9X50_MAGN_CHAN(IIO_MOD_Y, 16, INV_MPU9X50_SCAN_MAGN_Y),\n\tINV_MPU9X50_MAGN_CHAN(IIO_MOD_Z, 16, INV_MPU9X50_SCAN_MAGN_Z),\n};\n\n#define INV_MPU9X50_SCAN_MASK_3AXIS_MAGN\t\\\n\t(BIT(INV_MPU9X50_SCAN_MAGN_X)\t\t\\\n\t| BIT(INV_MPU9X50_SCAN_MAGN_Y)\t\t\\\n\t| BIT(INV_MPU9X50_SCAN_MAGN_Z))\n\nstatic const unsigned long inv_mpu9x50_scan_masks[] = {\n\t \n\tINV_MPU6050_SCAN_MASK_3AXIS_ACCEL,\n\tINV_MPU6050_SCAN_MASK_3AXIS_ACCEL | INV_MPU6050_SCAN_MASK_TEMP,\n\t \n\tINV_MPU6050_SCAN_MASK_3AXIS_GYRO,\n\tINV_MPU6050_SCAN_MASK_3AXIS_GYRO | INV_MPU6050_SCAN_MASK_TEMP,\n\t \n\tINV_MPU9X50_SCAN_MASK_3AXIS_MAGN,\n\tINV_MPU9X50_SCAN_MASK_3AXIS_MAGN | INV_MPU6050_SCAN_MASK_TEMP,\n\t \n\tINV_MPU6050_SCAN_MASK_3AXIS_ACCEL | INV_MPU6050_SCAN_MASK_3AXIS_GYRO,\n\tINV_MPU6050_SCAN_MASK_3AXIS_ACCEL | INV_MPU6050_SCAN_MASK_3AXIS_GYRO\n\t\t| INV_MPU6050_SCAN_MASK_TEMP,\n\t \n\tINV_MPU6050_SCAN_MASK_3AXIS_ACCEL | INV_MPU9X50_SCAN_MASK_3AXIS_MAGN,\n\tINV_MPU6050_SCAN_MASK_3AXIS_ACCEL | INV_MPU9X50_SCAN_MASK_3AXIS_MAGN\n\t\t| INV_MPU6050_SCAN_MASK_TEMP,\n\t \n\tINV_MPU6050_SCAN_MASK_3AXIS_GYRO | INV_MPU9X50_SCAN_MASK_3AXIS_MAGN,\n\tINV_MPU6050_SCAN_MASK_3AXIS_GYRO | INV_MPU9X50_SCAN_MASK_3AXIS_MAGN\n\t\t| INV_MPU6050_SCAN_MASK_TEMP,\n\t \n\tINV_MPU6050_SCAN_MASK_3AXIS_ACCEL | INV_MPU6050_SCAN_MASK_3AXIS_GYRO\n\t\t| INV_MPU9X50_SCAN_MASK_3AXIS_MAGN,\n\tINV_MPU6050_SCAN_MASK_3AXIS_ACCEL | INV_MPU6050_SCAN_MASK_3AXIS_GYRO\n\t\t| INV_MPU9X50_SCAN_MASK_3AXIS_MAGN\n\t\t| INV_MPU6050_SCAN_MASK_TEMP,\n\t0,\n};\n\nstatic const unsigned long inv_icm20602_scan_masks[] = {\n\t \n\tINV_MPU6050_SCAN_MASK_3AXIS_ACCEL | INV_MPU6050_SCAN_MASK_TEMP,\n\t \n\tINV_MPU6050_SCAN_MASK_3AXIS_GYRO | INV_MPU6050_SCAN_MASK_TEMP,\n\t \n\tINV_MPU6050_SCAN_MASK_3AXIS_ACCEL | INV_MPU6050_SCAN_MASK_3AXIS_GYRO\n\t\t| INV_MPU6050_SCAN_MASK_TEMP,\n\t0,\n};\n\n \nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\"10 20 50 100 200 500\");\nstatic IIO_CONST_ATTR(in_anglvel_scale_available,\n\t\t\t\t\t  \"0.000133090 0.000266181 0.000532362 0.001064724\");\nstatic IIO_CONST_ATTR(in_accel_scale_available,\n\t\t\t\t\t  \"0.000598 0.001196 0.002392 0.004785\");\nstatic IIO_DEV_ATTR_SAMP_FREQ(S_IRUGO | S_IWUSR, inv_fifo_rate_show,\n\tinv_mpu6050_fifo_rate_store);\n\n \nstatic IIO_DEVICE_ATTR(in_gyro_matrix, S_IRUGO, inv_attr_show, NULL,\n\tATTR_GYRO_MATRIX);\nstatic IIO_DEVICE_ATTR(in_accel_matrix, S_IRUGO, inv_attr_show, NULL,\n\tATTR_ACCL_MATRIX);\n\nstatic struct attribute *inv_attributes[] = {\n\t&iio_dev_attr_in_gyro_matrix.dev_attr.attr,   \n\t&iio_dev_attr_in_accel_matrix.dev_attr.attr,  \n\t&iio_dev_attr_sampling_frequency.dev_attr.attr,\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_const_attr_in_accel_scale_available.dev_attr.attr,\n\t&iio_const_attr_in_anglvel_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group inv_attribute_group = {\n\t.attrs = inv_attributes\n};\n\nstatic int inv_mpu6050_reg_access(struct iio_dev *indio_dev,\n\t\t\t\t  unsigned int reg,\n\t\t\t\t  unsigned int writeval,\n\t\t\t\t  unsigned int *readval)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tif (readval)\n\t\tret = regmap_read(st->map, reg, readval);\n\telse\n\t\tret = regmap_write(st->map, reg, writeval);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_info mpu_info = {\n\t.read_raw = &inv_mpu6050_read_raw,\n\t.write_raw = &inv_mpu6050_write_raw,\n\t.write_raw_get_fmt = &inv_write_raw_get_fmt,\n\t.attrs = &inv_attribute_group,\n\t.validate_trigger = inv_mpu6050_validate_trigger,\n\t.debugfs_reg_access = &inv_mpu6050_reg_access,\n};\n\n \nstatic int inv_check_and_setup_chip(struct inv_mpu6050_state *st)\n{\n\tint result;\n\tunsigned int regval, mask;\n\tint i;\n\n\tst->hw  = &hw_info[st->chip_type];\n\tst->reg = hw_info[st->chip_type].reg;\n\tmemcpy(&st->chip_config, hw_info[st->chip_type].config,\n\t       sizeof(st->chip_config));\n\tst->data = devm_kzalloc(regmap_get_device(st->map), st->hw->fifo_size, GFP_KERNEL);\n\tif (st->data == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tresult = regmap_read(st->map, INV_MPU6050_REG_WHOAMI, &regval);\n\tif (result)\n\t\treturn result;\n\tif (regval != st->hw->whoami) {\n\t\t \n\t\tfor (i = 0; i < INV_NUM_PARTS; ++i) {\n\t\t\tif (regval == hw_info[i].whoami) {\n\t\t\t\tdev_warn(regmap_get_device(st->map),\n\t\t\t\t\t\"whoami mismatch got 0x%02x (%s) expected 0x%02x (%s)\\n\",\n\t\t\t\t\tregval, hw_info[i].name,\n\t\t\t\t\tst->hw->whoami, st->hw->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i >= INV_NUM_PARTS) {\n\t\t\tdev_err(regmap_get_device(st->map),\n\t\t\t\t\"invalid whoami 0x%02x expected 0x%02x (%s)\\n\",\n\t\t\t\tregval, st->hw->whoami, st->hw->name);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tresult = regmap_write(st->map, st->reg->pwr_mgmt_1,\n\t\t\t      INV_MPU6050_BIT_H_RESET);\n\tif (result)\n\t\treturn result;\n\tmsleep(INV_MPU6050_POWER_UP_TIME);\n\tswitch (st->chip_type) {\n\tcase INV_MPU6000:\n\tcase INV_MPU6500:\n\tcase INV_MPU6515:\n\tcase INV_MPU6880:\n\tcase INV_MPU9250:\n\tcase INV_MPU9255:\n\t\t \n\t\tregval = INV_MPU6050_BIT_TEMP_RST | INV_MPU6050_BIT_ACCEL_RST |\n\t\t\t INV_MPU6050_BIT_GYRO_RST;\n\t\tresult = regmap_write(st->map, INV_MPU6050_REG_SIGNAL_PATH_RESET,\n\t\t\t\t      regval);\n\t\tif (result)\n\t\t\treturn result;\n\t\tmsleep(INV_MPU6050_POWER_UP_TIME);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tresult = inv_mpu6050_set_power_itg(st, true);\n\tif (result)\n\t\treturn result;\n\tmask = INV_MPU6050_SENSOR_ACCL | INV_MPU6050_SENSOR_GYRO |\n\t\t\tINV_MPU6050_SENSOR_TEMP | INV_MPU6050_SENSOR_MAGN;\n\tresult = inv_mpu6050_switch_engine(st, false, mask);\n\tif (result)\n\t\tgoto error_power_off;\n\n\treturn 0;\n\nerror_power_off:\n\tinv_mpu6050_set_power_itg(st, false);\n\treturn result;\n}\n\nstatic int inv_mpu_core_enable_regulator_vddio(struct inv_mpu6050_state *st)\n{\n\tint result;\n\n\tresult = regulator_enable(st->vddio_supply);\n\tif (result) {\n\t\tdev_err(regmap_get_device(st->map),\n\t\t\t\"Failed to enable vddio regulator: %d\\n\", result);\n\t} else {\n\t\t \n\t\tusleep_range(3000, 5000);\n\t}\n\n\treturn result;\n}\n\nstatic int inv_mpu_core_disable_regulator_vddio(struct inv_mpu6050_state *st)\n{\n\tint result;\n\n\tresult = regulator_disable(st->vddio_supply);\n\tif (result)\n\t\tdev_err(regmap_get_device(st->map),\n\t\t\t\"Failed to disable vddio regulator: %d\\n\", result);\n\n\treturn result;\n}\n\nstatic void inv_mpu_core_disable_regulator_action(void *_data)\n{\n\tstruct inv_mpu6050_state *st = _data;\n\tint result;\n\n\tresult = regulator_disable(st->vdd_supply);\n\tif (result)\n\t\tdev_err(regmap_get_device(st->map),\n\t\t\t\"Failed to disable vdd regulator: %d\\n\", result);\n\n\tinv_mpu_core_disable_regulator_vddio(st);\n}\n\nstatic void inv_mpu_pm_disable(void *data)\n{\n\tstruct device *dev = data;\n\n\tpm_runtime_disable(dev);\n}\n\nint inv_mpu_core_probe(struct regmap *regmap, int irq, const char *name,\n\t\tint (*inv_mpu_bus_setup)(struct iio_dev *), int chip_type)\n{\n\tstruct inv_mpu6050_state *st;\n\tstruct iio_dev *indio_dev;\n\tstruct inv_mpu6050_platform_data *pdata;\n\tstruct device *dev = regmap_get_device(regmap);\n\tint result;\n\tstruct irq_data *desc;\n\tint irq_type;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(hw_info) != INV_NUM_PARTS);\n\tif (chip_type < 0 || chip_type >= INV_NUM_PARTS) {\n\t\tdev_err(dev, \"Bad invensense chip_type=%d name=%s\\n\",\n\t\t\t\tchip_type, name);\n\t\treturn -ENODEV;\n\t}\n\tst = iio_priv(indio_dev);\n\tmutex_init(&st->lock);\n\tst->chip_type = chip_type;\n\tst->irq = irq;\n\tst->map = regmap;\n\n\tpdata = dev_get_platdata(dev);\n\tif (!pdata) {\n\t\tresult = iio_read_mount_matrix(dev, &st->orientation);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"Failed to retrieve mounting matrix %d\\n\",\n\t\t\t\tresult);\n\t\t\treturn result;\n\t\t}\n\t} else {\n\t\tst->plat_data = *pdata;\n\t}\n\n\tif (irq > 0) {\n\t\tdesc = irq_get_irq_data(irq);\n\t\tif (!desc) {\n\t\t\tdev_err(dev, \"Could not find IRQ %d\\n\", irq);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tirq_type = irqd_get_trigger_type(desc);\n\t\tif (!irq_type)\n\t\t\tirq_type = IRQF_TRIGGER_RISING;\n\t} else {\n\t\t \n\t\tirq_type = IRQF_TRIGGER_RISING;\n\t}\n\n\tif (irq_type & IRQF_TRIGGER_RISING)\t\n\t\tst->irq_mask = INV_MPU6050_ACTIVE_HIGH;\n\telse if (irq_type == IRQF_TRIGGER_FALLING)\n\t\tst->irq_mask = INV_MPU6050_ACTIVE_LOW;\n\telse if (irq_type == IRQF_TRIGGER_HIGH)\n\t\tst->irq_mask = INV_MPU6050_ACTIVE_HIGH |\n\t\t\tINV_MPU6050_LATCH_INT_EN;\n\telse if (irq_type == IRQF_TRIGGER_LOW)\n\t\tst->irq_mask = INV_MPU6050_ACTIVE_LOW |\n\t\t\tINV_MPU6050_LATCH_INT_EN;\n\telse {\n\t\tdev_err(dev, \"Invalid interrupt type 0x%x specified\\n\",\n\t\t\tirq_type);\n\t\treturn -EINVAL;\n\t}\n\n\tst->vdd_supply = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(st->vdd_supply))\n\t\treturn dev_err_probe(dev, PTR_ERR(st->vdd_supply),\n\t\t\t\t     \"Failed to get vdd regulator\\n\");\n\n\tst->vddio_supply = devm_regulator_get(dev, \"vddio\");\n\tif (IS_ERR(st->vddio_supply))\n\t\treturn dev_err_probe(dev, PTR_ERR(st->vddio_supply),\n\t\t\t\t     \"Failed to get vddio regulator\\n\");\n\n\tresult = regulator_enable(st->vdd_supply);\n\tif (result) {\n\t\tdev_err(dev, \"Failed to enable vdd regulator: %d\\n\", result);\n\t\treturn result;\n\t}\n\tmsleep(INV_MPU6050_POWER_UP_TIME);\n\n\tresult = inv_mpu_core_enable_regulator_vddio(st);\n\tif (result) {\n\t\tregulator_disable(st->vdd_supply);\n\t\treturn result;\n\t}\n\n\tresult = devm_add_action_or_reset(dev, inv_mpu_core_disable_regulator_action,\n\t\t\t\t st);\n\tif (result) {\n\t\tdev_err(dev, \"Failed to setup regulator cleanup action %d\\n\",\n\t\t\tresult);\n\t\treturn result;\n\t}\n\n\t \n\tresult = inv_mpu_magn_set_orient(st);\n\tif (result)\n\t\treturn result;\n\n\t \n\tresult = inv_check_and_setup_chip(st);\n\tif (result)\n\t\treturn result;\n\n\tresult = inv_mpu6050_init_config(indio_dev);\n\tif (result) {\n\t\tdev_err(dev, \"Could not initialize device.\\n\");\n\t\tgoto error_power_off;\n\t}\n\n\tdev_set_drvdata(dev, indio_dev);\n\t \n\tif (name)\n\t\tindio_dev->name = name;\n\telse\n\t\tindio_dev->name = dev_name(dev);\n\n\t \n\tif (inv_mpu_bus_setup) {\n\t\tresult = inv_mpu_bus_setup(indio_dev);\n\t\tif (result)\n\t\t\tgoto error_power_off;\n\t}\n\n\t \n\tresult = pm_runtime_set_active(dev);\n\tif (result)\n\t\tgoto error_power_off;\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev, INV_MPU6050_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_put(dev);\n\tresult = devm_add_action_or_reset(dev, inv_mpu_pm_disable, dev);\n\tif (result)\n\t\treturn result;\n\n\tswitch (chip_type) {\n\tcase INV_MPU9150:\n\t\tindio_dev->channels = inv_mpu9150_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(inv_mpu9150_channels);\n\t\tindio_dev->available_scan_masks = inv_mpu9x50_scan_masks;\n\t\tbreak;\n\tcase INV_MPU9250:\n\tcase INV_MPU9255:\n\t\tindio_dev->channels = inv_mpu9250_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(inv_mpu9250_channels);\n\t\tindio_dev->available_scan_masks = inv_mpu9x50_scan_masks;\n\t\tbreak;\n\tcase INV_ICM20600:\n\tcase INV_ICM20602:\n\t\tindio_dev->channels = inv_mpu_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);\n\t\tindio_dev->available_scan_masks = inv_icm20602_scan_masks;\n\t\tbreak;\n\tdefault:\n\t\tindio_dev->channels = inv_mpu_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);\n\t\tindio_dev->available_scan_masks = inv_mpu_scan_masks;\n\t\tbreak;\n\t}\n\t \n\tif (st->magn_disabled) {\n\t\tindio_dev->channels = inv_mpu_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);\n\t\tindio_dev->available_scan_masks = inv_mpu_scan_masks;\n\t}\n\n\tindio_dev->info = &mpu_info;\n\n\tif (irq > 0) {\n\t\t \n\t\tresult = devm_iio_triggered_buffer_setup(dev, indio_dev,\n\t\t\t\t\t\t\t iio_pollfunc_store_time,\n\t\t\t\t\t\t\t inv_mpu6050_read_fifo,\n\t\t\t\t\t\t\t NULL);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"configure buffer fail %d\\n\", result);\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = inv_mpu6050_probe_trigger(indio_dev, irq_type);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"trigger probe fail %d\\n\", result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tresult = devm_iio_device_register(dev, indio_dev);\n\tif (result) {\n\t\tdev_err(dev, \"IIO register fail %d\\n\", result);\n\t\treturn result;\n\t}\n\n\treturn 0;\n\nerror_power_off:\n\tinv_mpu6050_set_power_itg(st, false);\n\treturn result;\n}\nEXPORT_SYMBOL_NS_GPL(inv_mpu_core_probe, IIO_MPU6050);\n\nstatic int inv_mpu_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\tint result;\n\n\tmutex_lock(&st->lock);\n\tresult = inv_mpu_core_enable_regulator_vddio(st);\n\tif (result)\n\t\tgoto out_unlock;\n\n\tresult = inv_mpu6050_set_power_itg(st, true);\n\tif (result)\n\t\tgoto out_unlock;\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\tresult = inv_mpu6050_switch_engine(st, true, st->suspended_sensors);\n\tif (result)\n\t\tgoto out_unlock;\n\n\tif (iio_buffer_enabled(indio_dev))\n\t\tresult = inv_mpu6050_prepare_fifo(st, true);\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\n\treturn result;\n}\n\nstatic int inv_mpu_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\tint result;\n\n\tmutex_lock(&st->lock);\n\n\tst->suspended_sensors = 0;\n\tif (pm_runtime_suspended(dev)) {\n\t\tresult = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (iio_buffer_enabled(indio_dev)) {\n\t\tresult = inv_mpu6050_prepare_fifo(st, false);\n\t\tif (result)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (st->chip_config.accl_en)\n\t\tst->suspended_sensors |= INV_MPU6050_SENSOR_ACCL;\n\tif (st->chip_config.gyro_en)\n\t\tst->suspended_sensors |= INV_MPU6050_SENSOR_GYRO;\n\tif (st->chip_config.temp_en)\n\t\tst->suspended_sensors |= INV_MPU6050_SENSOR_TEMP;\n\tif (st->chip_config.magn_en)\n\t\tst->suspended_sensors |= INV_MPU6050_SENSOR_MAGN;\n\tresult = inv_mpu6050_switch_engine(st, false, st->suspended_sensors);\n\tif (result)\n\t\tgoto out_unlock;\n\n\tresult = inv_mpu6050_set_power_itg(st, false);\n\tif (result)\n\t\tgoto out_unlock;\n\n\tinv_mpu_core_disable_regulator_vddio(st);\nout_unlock:\n\tmutex_unlock(&st->lock);\n\n\treturn result;\n}\n\nstatic int inv_mpu_runtime_suspend(struct device *dev)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(dev_get_drvdata(dev));\n\tunsigned int sensors;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tsensors = INV_MPU6050_SENSOR_ACCL | INV_MPU6050_SENSOR_GYRO |\n\t\t\tINV_MPU6050_SENSOR_TEMP | INV_MPU6050_SENSOR_MAGN;\n\tret = inv_mpu6050_switch_engine(st, false, sensors);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = inv_mpu6050_set_power_itg(st, false);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tinv_mpu_core_disable_regulator_vddio(st);\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic int inv_mpu_runtime_resume(struct device *dev)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(dev_get_drvdata(dev));\n\tint ret;\n\n\tret = inv_mpu_core_enable_regulator_vddio(st);\n\tif (ret)\n\t\treturn ret;\n\n\treturn inv_mpu6050_set_power_itg(st, true);\n}\n\nEXPORT_NS_GPL_DEV_PM_OPS(inv_mpu_pmops, IIO_MPU6050) = {\n\tSYSTEM_SLEEP_PM_OPS(inv_mpu_suspend, inv_mpu_resume)\n\tRUNTIME_PM_OPS(inv_mpu_runtime_suspend, inv_mpu_runtime_resume, NULL)\n};\n\nMODULE_AUTHOR(\"Invensense Corporation\");\nMODULE_DESCRIPTION(\"Invensense device MPU6050 driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IIO_INV_SENSORS_TIMESTAMP);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}