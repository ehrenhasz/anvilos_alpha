{
  "module_name": "inv_mpu_trigger.c",
  "hash_id": "5a84f8f056a6733a79f4f5e8690d233b4ecc5e2dc462ad58e23be32b6d829a82",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/inv_mpu6050/inv_mpu_trigger.c",
  "human_readable_source": "\n \n\n#include <linux/pm_runtime.h>\n\n#include <linux/iio/common/inv_sensors_timestamp.h>\n\n#include \"inv_mpu_iio.h\"\n\nstatic unsigned int inv_scan_query_mpu6050(struct iio_dev *indio_dev)\n{\n\tstruct inv_mpu6050_state  *st = iio_priv(indio_dev);\n\tunsigned int mask;\n\n\t \n\tif (!indio_dev->active_scan_mask) {\n\t\tst->chip_config.temp_fifo_enable = true;\n\t\treturn INV_MPU6050_SENSOR_TEMP;\n\t}\n\n\tst->chip_config.gyro_fifo_enable =\n\t\ttest_bit(INV_MPU6050_SCAN_GYRO_X,\n\t\t\t indio_dev->active_scan_mask) ||\n\t\ttest_bit(INV_MPU6050_SCAN_GYRO_Y,\n\t\t\t indio_dev->active_scan_mask) ||\n\t\ttest_bit(INV_MPU6050_SCAN_GYRO_Z,\n\t\t\t indio_dev->active_scan_mask);\n\n\tst->chip_config.accl_fifo_enable =\n\t\ttest_bit(INV_MPU6050_SCAN_ACCL_X,\n\t\t\t indio_dev->active_scan_mask) ||\n\t\ttest_bit(INV_MPU6050_SCAN_ACCL_Y,\n\t\t\t indio_dev->active_scan_mask) ||\n\t\ttest_bit(INV_MPU6050_SCAN_ACCL_Z,\n\t\t\t indio_dev->active_scan_mask);\n\n\tst->chip_config.temp_fifo_enable =\n\t\ttest_bit(INV_MPU6050_SCAN_TEMP, indio_dev->active_scan_mask);\n\n\tmask = 0;\n\tif (st->chip_config.gyro_fifo_enable)\n\t\tmask |= INV_MPU6050_SENSOR_GYRO;\n\tif (st->chip_config.accl_fifo_enable)\n\t\tmask |= INV_MPU6050_SENSOR_ACCL;\n\tif (st->chip_config.temp_fifo_enable)\n\t\tmask |= INV_MPU6050_SENSOR_TEMP;\n\n\treturn mask;\n}\n\nstatic unsigned int inv_scan_query_mpu9x50(struct iio_dev *indio_dev)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\tunsigned int mask;\n\n\tmask = inv_scan_query_mpu6050(indio_dev);\n\n\t \n\tif (st->magn_disabled)\n\t\treturn mask;\n\n\tst->chip_config.magn_fifo_enable =\n\t\ttest_bit(INV_MPU9X50_SCAN_MAGN_X,\n\t\t\t indio_dev->active_scan_mask) ||\n\t\ttest_bit(INV_MPU9X50_SCAN_MAGN_Y,\n\t\t\t indio_dev->active_scan_mask) ||\n\t\ttest_bit(INV_MPU9X50_SCAN_MAGN_Z,\n\t\t\t indio_dev->active_scan_mask);\n\tif (st->chip_config.magn_fifo_enable)\n\t\tmask |= INV_MPU6050_SENSOR_MAGN;\n\n\treturn mask;\n}\n\nstatic unsigned int inv_scan_query(struct iio_dev *indio_dev)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\n\tswitch (st->chip_type) {\n\tcase INV_MPU9150:\n\tcase INV_MPU9250:\n\tcase INV_MPU9255:\n\t\treturn inv_scan_query_mpu9x50(indio_dev);\n\tdefault:\n\t\treturn inv_scan_query_mpu6050(indio_dev);\n\t}\n}\n\nstatic unsigned int inv_compute_skip_samples(const struct inv_mpu6050_state *st)\n{\n\tunsigned int skip_samples = 0;\n\n\t \n\tif (st->chip_config.magn_fifo_enable)\n\t\tskip_samples = 1;\n\n\treturn skip_samples;\n}\n\nint inv_mpu6050_prepare_fifo(struct inv_mpu6050_state *st, bool enable)\n{\n\tuint8_t d;\n\tint ret;\n\n\tif (enable) {\n\t\t \n\t\tinv_sensors_timestamp_reset(&st->timestamp);\n\t\t \n\t\td = st->chip_config.user_ctrl | INV_MPU6050_BIT_FIFO_RST;\n\t\tret = regmap_write(st->map, st->reg->user_ctrl, d);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\td = 0;\n\t\tif (st->chip_config.gyro_fifo_enable)\n\t\t\td |= INV_MPU6050_BITS_GYRO_OUT;\n\t\tif (st->chip_config.accl_fifo_enable)\n\t\t\td |= INV_MPU6050_BIT_ACCEL_OUT;\n\t\tif (st->chip_config.temp_fifo_enable)\n\t\t\td |= INV_MPU6050_BIT_TEMP_OUT;\n\t\tif (st->chip_config.magn_fifo_enable)\n\t\t\td |= INV_MPU6050_BIT_SLAVE_0;\n\t\tret = regmap_write(st->map, st->reg->fifo_en, d);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\td = st->chip_config.user_ctrl | INV_MPU6050_BIT_FIFO_EN;\n\t\tret = regmap_write(st->map, st->reg->user_ctrl, d);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tret = regmap_write(st->map, st->reg->int_enable,\n\t\t\t\t   INV_MPU6050_BIT_DATA_RDY_EN);\n\t} else {\n\t\tret = regmap_write(st->map, st->reg->int_enable, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = regmap_write(st->map, st->reg->fifo_en, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tret = regmap_write(st->map, st->reg->user_ctrl,\n\t\t\t\t   st->chip_config.user_ctrl);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int inv_mpu6050_set_enable(struct iio_dev *indio_dev, bool enable)\n{\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\tstruct device *pdev = regmap_get_device(st->map);\n\tunsigned int scan;\n\tint result;\n\n\tif (enable) {\n\t\tscan = inv_scan_query(indio_dev);\n\t\tresult = pm_runtime_resume_and_get(pdev);\n\t\tif (result)\n\t\t\treturn result;\n\t\t \n\t\tresult = inv_mpu6050_switch_engine(st, false, ~scan);\n\t\tif (result)\n\t\t\tgoto error_power_off;\n\t\tresult = inv_mpu6050_switch_engine(st, true, scan);\n\t\tif (result)\n\t\t\tgoto error_power_off;\n\t\tst->skip_samples = inv_compute_skip_samples(st);\n\t\tresult = inv_mpu6050_prepare_fifo(st, true);\n\t\tif (result)\n\t\t\tgoto error_power_off;\n\t} else {\n\t\tresult = inv_mpu6050_prepare_fifo(st, false);\n\t\tif (result)\n\t\t\tgoto error_power_off;\n\t\tpm_runtime_mark_last_busy(pdev);\n\t\tpm_runtime_put_autosuspend(pdev);\n\t}\n\n\treturn 0;\n\nerror_power_off:\n\tpm_runtime_put_autosuspend(pdev);\n\treturn result;\n}\n\n \nstatic int inv_mpu_data_rdy_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t      bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\tint result;\n\n\tmutex_lock(&st->lock);\n\tresult = inv_mpu6050_set_enable(indio_dev, state);\n\tmutex_unlock(&st->lock);\n\n\treturn result;\n}\n\nstatic const struct iio_trigger_ops inv_mpu_trigger_ops = {\n\t.set_trigger_state = &inv_mpu_data_rdy_trigger_set_state,\n};\n\nint inv_mpu6050_probe_trigger(struct iio_dev *indio_dev, int irq_type)\n{\n\tint ret;\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\n\tst->trig = devm_iio_trigger_alloc(&indio_dev->dev,\n\t\t\t\t\t  \"%s-dev%d\",\n\t\t\t\t\t  indio_dev->name,\n\t\t\t\t\t  iio_device_id(indio_dev));\n\tif (!st->trig)\n\t\treturn -ENOMEM;\n\n\tret = devm_request_irq(&indio_dev->dev, st->irq,\n\t\t\t       &iio_trigger_generic_data_rdy_poll,\n\t\t\t       irq_type,\n\t\t\t       \"inv_mpu\",\n\t\t\t       st->trig);\n\tif (ret)\n\t\treturn ret;\n\n\tst->trig->dev.parent = regmap_get_device(st->map);\n\tst->trig->ops = &inv_mpu_trigger_ops;\n\tiio_trigger_set_drvdata(st->trig, indio_dev);\n\n\tret = devm_iio_trigger_register(&indio_dev->dev, st->trig);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->trig = iio_trigger_get(st->trig);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}