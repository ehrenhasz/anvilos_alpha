{
  "module_name": "inv_mpu_ring.c",
  "hash_id": "23f85969781c97fad76cbc6702198c5203c14422b43fefde9a02acdf2f9997c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/inv_mpu6050/inv_mpu_ring.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/poll.h>\n#include <linux/math64.h>\n\n#include <linux/iio/common/inv_sensors_timestamp.h>\n\n#include \"inv_mpu_iio.h\"\n\nstatic int inv_reset_fifo(struct iio_dev *indio_dev)\n{\n\tint result;\n\tstruct inv_mpu6050_state  *st = iio_priv(indio_dev);\n\n\t \n\tinv_mpu6050_prepare_fifo(st, false);\n\tresult = inv_mpu6050_prepare_fifo(st, true);\n\tif (result)\n\t\tgoto reset_fifo_fail;\n\n\treturn 0;\n\nreset_fifo_fail:\n\tdev_err(regmap_get_device(st->map), \"reset fifo failed %d\\n\", result);\n\tresult = regmap_write(st->map, st->reg->int_enable,\n\t\t\t      INV_MPU6050_BIT_DATA_RDY_EN);\n\n\treturn result;\n}\n\n \nirqreturn_t inv_mpu6050_read_fifo(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct inv_mpu6050_state *st = iio_priv(indio_dev);\n\tsize_t bytes_per_datum;\n\tint result;\n\tu16 fifo_count;\n\tu32 fifo_period;\n\ts64 timestamp;\n\tu8 data[INV_MPU6050_OUTPUT_DATA_SIZE];\n\tint int_status;\n\tsize_t i, nb;\n\n\tmutex_lock(&st->lock);\n\n\t \n\tresult = regmap_read(st->map, st->reg->int_status, &int_status);\n\tif (result) {\n\t\tdev_err(regmap_get_device(st->map),\n\t\t\t\"failed to ack interrupt\\n\");\n\t\tgoto flush_fifo;\n\t}\n\tif (!(int_status & INV_MPU6050_BIT_RAW_DATA_RDY_INT))\n\t\tgoto end_session;\n\n\tif (!(st->chip_config.accl_fifo_enable |\n\t\tst->chip_config.gyro_fifo_enable |\n\t\tst->chip_config.magn_fifo_enable))\n\t\tgoto end_session;\n\tbytes_per_datum = 0;\n\tif (st->chip_config.accl_fifo_enable)\n\t\tbytes_per_datum += INV_MPU6050_BYTES_PER_3AXIS_SENSOR;\n\n\tif (st->chip_config.gyro_fifo_enable)\n\t\tbytes_per_datum += INV_MPU6050_BYTES_PER_3AXIS_SENSOR;\n\n\tif (st->chip_config.temp_fifo_enable)\n\t\tbytes_per_datum += INV_MPU6050_BYTES_PER_TEMP_SENSOR;\n\n\tif (st->chip_config.magn_fifo_enable)\n\t\tbytes_per_datum += INV_MPU9X50_BYTES_MAGN;\n\n\t \n\tresult = regmap_bulk_read(st->map, st->reg->fifo_count_h,\n\t\t\t\t  st->data, INV_MPU6050_FIFO_COUNT_BYTE);\n\tif (result)\n\t\tgoto end_session;\n\tfifo_count = be16_to_cpup((__be16 *)&st->data[0]);\n\n\t \n\tnb = 3 * bytes_per_datum;\n\tif (fifo_count >= st->hw->fifo_size - nb) {\n\t\tdev_warn(regmap_get_device(st->map), \"fifo overflow reset\\n\");\n\t\tgoto flush_fifo;\n\t}\n\n\t \n\tnb = fifo_count / bytes_per_datum;\n\tfifo_count = nb * bytes_per_datum;\n\t \n\tfifo_period = NSEC_PER_SEC / INV_MPU6050_DIVIDER_TO_FIFO_RATE(st->chip_config.divider);\n\tinv_sensors_timestamp_interrupt(&st->timestamp, fifo_period, nb, nb, pf->timestamp);\n\tinv_sensors_timestamp_apply_odr(&st->timestamp, fifo_period, nb, 0);\n\n\t \n\tmemset(data, 0, sizeof(data));\n\n\t \n\tresult = regmap_noinc_read(st->map, st->reg->fifo_r_w, st->data, fifo_count);\n\tif (result)\n\t\tgoto flush_fifo;\n\tfor (i = 0; i < nb; ++i) {\n\t\t \n\t\tif (st->skip_samples) {\n\t\t\tst->skip_samples--;\n\t\t\tcontinue;\n\t\t}\n\t\tmemcpy(data, &st->data[i * bytes_per_datum], bytes_per_datum);\n\t\ttimestamp = inv_sensors_timestamp_pop(&st->timestamp);\n\t\tiio_push_to_buffers_with_timestamp(indio_dev, data, timestamp);\n\t}\n\nend_session:\n\tmutex_unlock(&st->lock);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n\nflush_fifo:\n\t \n\tinv_reset_fifo(indio_dev);\n\tmutex_unlock(&st->lock);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}