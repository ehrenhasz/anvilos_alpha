{
  "module_name": "inv_mpu_magn.c",
  "hash_id": "b8c9201ace24cfc082fd256dc38f3541d9c1b24567a572944293c36406c6f3a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/inv_mpu6050/inv_mpu_magn.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/string.h>\n\n#include \"inv_mpu_aux.h\"\n#include \"inv_mpu_iio.h\"\n#include \"inv_mpu_magn.h\"\n\n \n#define INV_MPU_MAGN_I2C_ADDR\t\t0x0C\n\n#define INV_MPU_MAGN_REG_WIA\t\t0x00\n#define INV_MPU_MAGN_BITS_WIA\t\t0x48\n\n#define INV_MPU_MAGN_REG_ST1\t\t0x02\n#define INV_MPU_MAGN_BIT_DRDY\t\t0x01\n#define INV_MPU_MAGN_BIT_DOR\t\t0x02\n\n#define INV_MPU_MAGN_REG_DATA\t\t0x03\n\n#define INV_MPU_MAGN_REG_ST2\t\t0x09\n#define INV_MPU_MAGN_BIT_HOFL\t\t0x08\n#define INV_MPU_MAGN_BIT_BITM\t\t0x10\n\n#define INV_MPU_MAGN_REG_CNTL1\t\t0x0A\n#define INV_MPU_MAGN_BITS_MODE_PWDN\t0x00\n#define INV_MPU_MAGN_BITS_MODE_SINGLE\t0x01\n#define INV_MPU_MAGN_BITS_MODE_FUSE\t0x0F\n#define INV_MPU9250_MAGN_BIT_OUTPUT_BIT\t0x10\n\n#define INV_MPU9250_MAGN_REG_CNTL2\t0x0B\n#define INV_MPU9250_MAGN_BIT_SRST\t0x01\n\n#define INV_MPU_MAGN_REG_ASAX\t\t0x10\n#define INV_MPU_MAGN_REG_ASAY\t\t0x11\n#define INV_MPU_MAGN_REG_ASAZ\t\t0x12\n\nstatic bool inv_magn_supported(const struct inv_mpu6050_state *st)\n{\n\tswitch (st->chip_type) {\n\tcase INV_MPU9150:\n\tcase INV_MPU9250:\n\tcase INV_MPU9255:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic int inv_magn_init(struct inv_mpu6050_state *st)\n{\n\tuint8_t val;\n\tuint8_t asa[3];\n\tint32_t sensitivity;\n\tint ret;\n\n\t \n\tret = inv_mpu_aux_read(st, INV_MPU_MAGN_I2C_ADDR, INV_MPU_MAGN_REG_WIA,\n\t\t\t       &val, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\tif (val != INV_MPU_MAGN_BITS_WIA)\n\t\treturn -ENODEV;\n\n\t \n\tswitch (st->chip_type) {\n\tcase INV_MPU9250:\n\tcase INV_MPU9255:\n\t\tret = inv_mpu_aux_write(st, INV_MPU_MAGN_I2C_ADDR,\n\t\t\t\t\tINV_MPU9250_MAGN_REG_CNTL2,\n\t\t\t\t\tINV_MPU9250_MAGN_BIT_SRST);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tret = inv_mpu_aux_write(st, INV_MPU_MAGN_I2C_ADDR,\n\t\t\t\tINV_MPU_MAGN_REG_CNTL1,\n\t\t\t\tINV_MPU_MAGN_BITS_MODE_FUSE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = inv_mpu_aux_read(st, INV_MPU_MAGN_I2C_ADDR, INV_MPU_MAGN_REG_ASAX,\n\t\t\t       asa, sizeof(asa));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = inv_mpu_aux_write(st, INV_MPU_MAGN_I2C_ADDR,\n\t\t\t\tINV_MPU_MAGN_REG_CNTL1,\n\t\t\t\tINV_MPU_MAGN_BITS_MODE_PWDN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (st->chip_type) {\n\tcase INV_MPU9150:\n\t\t \n\t\tsensitivity = 3000;\n\t\tbreak;\n\tcase INV_MPU9250:\n\tcase INV_MPU9255:\n\t\t \n\t\tsensitivity = 1500;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tst->magn_raw_to_gauss[0] = (((int32_t)asa[0] + 128) * sensitivity) / 256;\n\tst->magn_raw_to_gauss[1] = (((int32_t)asa[1] + 128) * sensitivity) / 256;\n\tst->magn_raw_to_gauss[2] = (((int32_t)asa[2] + 128) * sensitivity) / 256;\n\n\treturn 0;\n}\n\n \nint inv_mpu_magn_probe(struct inv_mpu6050_state *st)\n{\n\tuint8_t val;\n\tint ret;\n\n\t \n\tif (!inv_magn_supported(st))\n\t\treturn 0;\n\n\t \n\tret = inv_mpu_aux_init(st);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = inv_magn_init(st);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(st->map, INV_MPU6050_REG_I2C_SLV_ADDR(0),\n\t\t\t   INV_MPU6050_BIT_I2C_SLV_RNW | INV_MPU_MAGN_I2C_ADDR);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(st->map, INV_MPU6050_REG_I2C_SLV_REG(0),\n\t\t\t   INV_MPU_MAGN_REG_DATA);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(st->map, INV_MPU6050_REG_I2C_SLV_CTRL(0),\n\t\t\t   INV_MPU6050_BIT_SLV_EN |\n\t\t\t   INV_MPU6050_BIT_SLV_BYTE_SW |\n\t\t\t   INV_MPU6050_BIT_SLV_GRP |\n\t\t\t   INV_MPU9X50_BYTES_MAGN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(st->map, INV_MPU6050_REG_I2C_SLV_ADDR(1),\n\t\t\t   INV_MPU_MAGN_I2C_ADDR);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(st->map, INV_MPU6050_REG_I2C_SLV_REG(1),\n\t\t\t   INV_MPU_MAGN_REG_CNTL1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = INV_MPU_MAGN_BITS_MODE_SINGLE;\n\tswitch (st->chip_type) {\n\tcase INV_MPU9250:\n\tcase INV_MPU9255:\n\t\tval |= INV_MPU9250_MAGN_BIT_OUTPUT_BIT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tret = regmap_write(st->map, INV_MPU6050_REG_I2C_SLV_DO(1), val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(st->map, INV_MPU6050_REG_I2C_SLV_CTRL(1),\n\t\t\t    INV_MPU6050_BIT_SLV_EN | 1);\n}\n\n \nint inv_mpu_magn_set_rate(const struct inv_mpu6050_state *st, int fifo_rate)\n{\n\tuint8_t d;\n\n\t \n\tif (!inv_magn_supported(st))\n\t\treturn 0;\n\n\t \n\tif (fifo_rate > INV_MPU_MAGN_FREQ_HZ_MAX)\n\t\td = fifo_rate / INV_MPU_MAGN_FREQ_HZ_MAX - 1;\n\telse\n\t\td = 0;\n\n\treturn regmap_write(st->map, INV_MPU6050_REG_I2C_SLV4_CTRL, d);\n}\n\n \nint inv_mpu_magn_set_orient(struct inv_mpu6050_state *st)\n{\n\tstruct device *dev = regmap_get_device(st->map);\n\tconst char *orient;\n\tchar *str;\n\tint i;\n\n\t \n\tswitch (st->chip_type) {\n\tcase INV_MPU9150:\n\tcase INV_MPU9250:\n\tcase INV_MPU9255:\n\t\t \n\t\tst->magn_orient.rotation[0] = st->orientation.rotation[3];\n\t\tst->magn_orient.rotation[1] = st->orientation.rotation[4];\n\t\tst->magn_orient.rotation[2] = st->orientation.rotation[5];\n\t\t \n\t\tst->magn_orient.rotation[3] = st->orientation.rotation[0];\n\t\tst->magn_orient.rotation[4] = st->orientation.rotation[1];\n\t\tst->magn_orient.rotation[5] = st->orientation.rotation[2];\n\t\t \n\t\tfor (i = 6; i < 9; ++i) {\n\t\t\torient = st->orientation.rotation[i];\n\n\t\t\t \n\t\t\tif (orient[0] == '-')\n\t\t\t\tstr = devm_kstrdup(dev, orient + 1, GFP_KERNEL);\n\t\t\telse if (!strcmp(orient, \"0\"))\n\t\t\t\tstr = devm_kstrdup(dev, orient, GFP_KERNEL);\n\t\t\telse\n\t\t\t\tstr = devm_kasprintf(dev, GFP_KERNEL, \"-%s\", orient);\n\t\t\tif (!str)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tst->magn_orient.rotation[i] = str;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tst->magn_orient = st->orientation;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nint inv_mpu_magn_read(struct inv_mpu6050_state *st, int axis, int *val)\n{\n\tunsigned int status;\n\t__be16 data;\n\tuint8_t addr;\n\tint ret;\n\n\t \n\tif (!inv_magn_supported(st))\n\t\treturn -ENODEV;\n\n\t \n\tswitch (axis) {\n\tcase IIO_MOD_X:\n\t\taddr = 0;\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\taddr = 2;\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\taddr = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\taddr += INV_MPU6050_REG_EXT_SENS_DATA;\n\n\t \n\tret = regmap_read(st->map, INV_MPU6050_REG_I2C_MST_STATUS, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status & INV_MPU6050_BIT_I2C_SLV0_NACK ||\n\t\t\tstatus & INV_MPU6050_BIT_I2C_SLV1_NACK)\n\t\treturn -EIO;\n\n\tret = regmap_bulk_read(st->map, addr, &data, sizeof(data));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = (int16_t)be16_to_cpu(data);\n\n\treturn IIO_VAL_INT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}