{
  "module_name": "adis16480.c",
  "hash_id": "d57fdfb493189b466924d6f49213bec302733f7839b7e59c75f706524cd2489d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/adis16480.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/bitfield.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/math.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/lcm.h>\n#include <linux/property.h>\n#include <linux/swab.h>\n#include <linux/crc32.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/imu/adis.h>\n#include <linux/iio/trigger_consumer.h>\n\n#include <linux/debugfs.h>\n\n#define ADIS16480_PAGE_SIZE 0x80\n\n#define ADIS16480_REG(page, reg) ((page) * ADIS16480_PAGE_SIZE + (reg))\n\n#define ADIS16480_REG_PAGE_ID 0x00  \n#define ADIS16480_REG_SEQ_CNT\t\t\tADIS16480_REG(0x00, 0x06)\n#define ADIS16480_REG_SYS_E_FLA\t\t\tADIS16480_REG(0x00, 0x08)\n#define ADIS16480_REG_DIAG_STS\t\t\tADIS16480_REG(0x00, 0x0A)\n#define ADIS16480_REG_ALM_STS\t\t\tADIS16480_REG(0x00, 0x0C)\n#define ADIS16480_REG_TEMP_OUT\t\t\tADIS16480_REG(0x00, 0x0E)\n#define ADIS16480_REG_X_GYRO_OUT\t\tADIS16480_REG(0x00, 0x10)\n#define ADIS16480_REG_Y_GYRO_OUT\t\tADIS16480_REG(0x00, 0x14)\n#define ADIS16480_REG_Z_GYRO_OUT\t\tADIS16480_REG(0x00, 0x18)\n#define ADIS16480_REG_X_ACCEL_OUT\t\tADIS16480_REG(0x00, 0x1C)\n#define ADIS16480_REG_Y_ACCEL_OUT\t\tADIS16480_REG(0x00, 0x20)\n#define ADIS16480_REG_Z_ACCEL_OUT\t\tADIS16480_REG(0x00, 0x24)\n#define ADIS16480_REG_X_MAGN_OUT\t\tADIS16480_REG(0x00, 0x28)\n#define ADIS16480_REG_Y_MAGN_OUT\t\tADIS16480_REG(0x00, 0x2A)\n#define ADIS16480_REG_Z_MAGN_OUT\t\tADIS16480_REG(0x00, 0x2C)\n#define ADIS16480_REG_BAROM_OUT\t\t\tADIS16480_REG(0x00, 0x2E)\n#define ADIS16480_REG_X_DELTAANG_OUT\t\tADIS16480_REG(0x00, 0x40)\n#define ADIS16480_REG_Y_DELTAANG_OUT\t\tADIS16480_REG(0x00, 0x44)\n#define ADIS16480_REG_Z_DELTAANG_OUT\t\tADIS16480_REG(0x00, 0x48)\n#define ADIS16480_REG_X_DELTAVEL_OUT\t\tADIS16480_REG(0x00, 0x4C)\n#define ADIS16480_REG_Y_DELTAVEL_OUT\t\tADIS16480_REG(0x00, 0x50)\n#define ADIS16480_REG_Z_DELTAVEL_OUT\t\tADIS16480_REG(0x00, 0x54)\n#define ADIS16480_REG_PROD_ID\t\t\tADIS16480_REG(0x00, 0x7E)\n\n#define ADIS16480_REG_X_GYRO_SCALE\t\tADIS16480_REG(0x02, 0x04)\n#define ADIS16480_REG_Y_GYRO_SCALE\t\tADIS16480_REG(0x02, 0x06)\n#define ADIS16480_REG_Z_GYRO_SCALE\t\tADIS16480_REG(0x02, 0x08)\n#define ADIS16480_REG_X_ACCEL_SCALE\t\tADIS16480_REG(0x02, 0x0A)\n#define ADIS16480_REG_Y_ACCEL_SCALE\t\tADIS16480_REG(0x02, 0x0C)\n#define ADIS16480_REG_Z_ACCEL_SCALE\t\tADIS16480_REG(0x02, 0x0E)\n#define ADIS16480_REG_X_GYRO_BIAS\t\tADIS16480_REG(0x02, 0x10)\n#define ADIS16480_REG_Y_GYRO_BIAS\t\tADIS16480_REG(0x02, 0x14)\n#define ADIS16480_REG_Z_GYRO_BIAS\t\tADIS16480_REG(0x02, 0x18)\n#define ADIS16480_REG_X_ACCEL_BIAS\t\tADIS16480_REG(0x02, 0x1C)\n#define ADIS16480_REG_Y_ACCEL_BIAS\t\tADIS16480_REG(0x02, 0x20)\n#define ADIS16480_REG_Z_ACCEL_BIAS\t\tADIS16480_REG(0x02, 0x24)\n#define ADIS16480_REG_X_HARD_IRON\t\tADIS16480_REG(0x02, 0x28)\n#define ADIS16480_REG_Y_HARD_IRON\t\tADIS16480_REG(0x02, 0x2A)\n#define ADIS16480_REG_Z_HARD_IRON\t\tADIS16480_REG(0x02, 0x2C)\n#define ADIS16480_REG_BAROM_BIAS\t\tADIS16480_REG(0x02, 0x40)\n#define ADIS16480_REG_FLASH_CNT\t\t\tADIS16480_REG(0x02, 0x7C)\n\n#define ADIS16480_REG_GLOB_CMD\t\t\tADIS16480_REG(0x03, 0x02)\n#define ADIS16480_REG_FNCTIO_CTRL\t\tADIS16480_REG(0x03, 0x06)\n#define ADIS16480_REG_GPIO_CTRL\t\t\tADIS16480_REG(0x03, 0x08)\n#define ADIS16480_REG_CONFIG\t\t\tADIS16480_REG(0x03, 0x0A)\n#define ADIS16480_REG_DEC_RATE\t\t\tADIS16480_REG(0x03, 0x0C)\n#define ADIS16480_REG_SLP_CNT\t\t\tADIS16480_REG(0x03, 0x10)\n#define ADIS16480_REG_FILTER_BNK0\t\tADIS16480_REG(0x03, 0x16)\n#define ADIS16480_REG_FILTER_BNK1\t\tADIS16480_REG(0x03, 0x18)\n#define ADIS16480_REG_ALM_CNFG0\t\t\tADIS16480_REG(0x03, 0x20)\n#define ADIS16480_REG_ALM_CNFG1\t\t\tADIS16480_REG(0x03, 0x22)\n#define ADIS16480_REG_ALM_CNFG2\t\t\tADIS16480_REG(0x03, 0x24)\n#define ADIS16480_REG_XG_ALM_MAGN\t\tADIS16480_REG(0x03, 0x28)\n#define ADIS16480_REG_YG_ALM_MAGN\t\tADIS16480_REG(0x03, 0x2A)\n#define ADIS16480_REG_ZG_ALM_MAGN\t\tADIS16480_REG(0x03, 0x2C)\n#define ADIS16480_REG_XA_ALM_MAGN\t\tADIS16480_REG(0x03, 0x2E)\n#define ADIS16480_REG_YA_ALM_MAGN\t\tADIS16480_REG(0x03, 0x30)\n#define ADIS16480_REG_ZA_ALM_MAGN\t\tADIS16480_REG(0x03, 0x32)\n#define ADIS16480_REG_XM_ALM_MAGN\t\tADIS16480_REG(0x03, 0x34)\n#define ADIS16480_REG_YM_ALM_MAGN\t\tADIS16480_REG(0x03, 0x36)\n#define ADIS16480_REG_ZM_ALM_MAGN\t\tADIS16480_REG(0x03, 0x38)\n#define ADIS16480_REG_BR_ALM_MAGN\t\tADIS16480_REG(0x03, 0x3A)\n#define ADIS16480_REG_FIRM_REV\t\t\tADIS16480_REG(0x03, 0x78)\n#define ADIS16480_REG_FIRM_DM\t\t\tADIS16480_REG(0x03, 0x7A)\n#define ADIS16480_REG_FIRM_Y\t\t\tADIS16480_REG(0x03, 0x7C)\n\n \n#define ADIS16495_REG_SYNC_SCALE\t\tADIS16480_REG(0x03, 0x10)\n#define ADIS16495_REG_BURST_CMD\t\t\tADIS16480_REG(0x00, 0x7C)\n#define ADIS16495_BURST_ID\t\t\t0xA5A5\n \n#define ADIS16495_BURST_MAX_DATA\t\t20\n \n#define ADIS16495_BURST_MAX_SPEED              6000000\n\n#define ADIS16480_REG_SERIAL_NUM\t\tADIS16480_REG(0x04, 0x20)\n\n \n#define ADIS16480_FIR_COEF(page) (x < 60 ? ADIS16480_REG(page, (x) + 8) : \\\n\t\tADIS16480_REG((page) + 1, (x) - 60 + 8))\n#define ADIS16480_FIR_COEF_A(x)\t\t\tADIS16480_FIR_COEF(0x05, (x))\n#define ADIS16480_FIR_COEF_B(x)\t\t\tADIS16480_FIR_COEF(0x07, (x))\n#define ADIS16480_FIR_COEF_C(x)\t\t\tADIS16480_FIR_COEF(0x09, (x))\n#define ADIS16480_FIR_COEF_D(x)\t\t\tADIS16480_FIR_COEF(0x0B, (x))\n\n \n#define ADIS16480_DRDY_SEL_MSK\t\tGENMASK(1, 0)\n#define ADIS16480_DRDY_SEL(x)\t\tFIELD_PREP(ADIS16480_DRDY_SEL_MSK, x)\n#define ADIS16480_DRDY_POL_MSK\t\tBIT(2)\n#define ADIS16480_DRDY_POL(x)\t\tFIELD_PREP(ADIS16480_DRDY_POL_MSK, x)\n#define ADIS16480_DRDY_EN_MSK\t\tBIT(3)\n#define ADIS16480_DRDY_EN(x)\t\tFIELD_PREP(ADIS16480_DRDY_EN_MSK, x)\n#define ADIS16480_SYNC_SEL_MSK\t\tGENMASK(5, 4)\n#define ADIS16480_SYNC_SEL(x)\t\tFIELD_PREP(ADIS16480_SYNC_SEL_MSK, x)\n#define ADIS16480_SYNC_EN_MSK\t\tBIT(7)\n#define ADIS16480_SYNC_EN(x)\t\tFIELD_PREP(ADIS16480_SYNC_EN_MSK, x)\n#define ADIS16480_SYNC_MODE_MSK\t\tBIT(8)\n#define ADIS16480_SYNC_MODE(x)\t\tFIELD_PREP(ADIS16480_SYNC_MODE_MSK, x)\n\nstruct adis16480_chip_info {\n\tunsigned int num_channels;\n\tconst struct iio_chan_spec *channels;\n\tunsigned int gyro_max_val;\n\tunsigned int gyro_max_scale;\n\tunsigned int accel_max_val;\n\tunsigned int accel_max_scale;\n\tunsigned int temp_scale;\n\tunsigned int int_clk;\n\tunsigned int max_dec_rate;\n\tconst unsigned int *filter_freqs;\n\tbool has_pps_clk_mode;\n\tbool has_sleep_cnt;\n\tconst struct adis_data adis_data;\n};\n\nenum adis16480_int_pin {\n\tADIS16480_PIN_DIO1,\n\tADIS16480_PIN_DIO2,\n\tADIS16480_PIN_DIO3,\n\tADIS16480_PIN_DIO4\n};\n\nenum adis16480_clock_mode {\n\tADIS16480_CLK_SYNC,\n\tADIS16480_CLK_PPS,\n\tADIS16480_CLK_INT\n};\n\nstruct adis16480 {\n\tconst struct adis16480_chip_info *chip_info;\n\n\tstruct adis adis;\n\tstruct clk *ext_clk;\n\tenum adis16480_clock_mode clk_mode;\n\tunsigned int clk_freq;\n\t \n\t__be16 data[ADIS16495_BURST_MAX_DATA] __aligned(8);\n};\n\nstatic const char * const adis16480_int_pin_names[4] = {\n\t[ADIS16480_PIN_DIO1] = \"DIO1\",\n\t[ADIS16480_PIN_DIO2] = \"DIO2\",\n\t[ADIS16480_PIN_DIO3] = \"DIO3\",\n\t[ADIS16480_PIN_DIO4] = \"DIO4\",\n};\n\nstatic bool low_rate_allow;\nmodule_param(low_rate_allow, bool, 0444);\nMODULE_PARM_DESC(low_rate_allow,\n\t\t \"Allow IMU rates below the minimum advisable when external clk is used in PPS mode (default: N)\");\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic ssize_t adis16480_show_firmware_revision(struct file *file,\n\t\tchar __user *userbuf, size_t count, loff_t *ppos)\n{\n\tstruct adis16480 *adis16480 = file->private_data;\n\tchar buf[7];\n\tsize_t len;\n\tu16 rev;\n\tint ret;\n\n\tret = adis_read_reg_16(&adis16480->adis, ADIS16480_REG_FIRM_REV, &rev);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = scnprintf(buf, sizeof(buf), \"%x.%x\\n\", rev >> 8, rev & 0xff);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations adis16480_firmware_revision_fops = {\n\t.open = simple_open,\n\t.read = adis16480_show_firmware_revision,\n\t.llseek = default_llseek,\n\t.owner = THIS_MODULE,\n};\n\nstatic ssize_t adis16480_show_firmware_date(struct file *file,\n\t\tchar __user *userbuf, size_t count, loff_t *ppos)\n{\n\tstruct adis16480 *adis16480 = file->private_data;\n\tu16 md, year;\n\tchar buf[12];\n\tsize_t len;\n\tint ret;\n\n\tret = adis_read_reg_16(&adis16480->adis, ADIS16480_REG_FIRM_Y, &year);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adis_read_reg_16(&adis16480->adis, ADIS16480_REG_FIRM_DM, &md);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = snprintf(buf, sizeof(buf), \"%.2x-%.2x-%.4x\\n\",\n\t\t\tmd >> 8, md & 0xff, year);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations adis16480_firmware_date_fops = {\n\t.open = simple_open,\n\t.read = adis16480_show_firmware_date,\n\t.llseek = default_llseek,\n\t.owner = THIS_MODULE,\n};\n\nstatic int adis16480_show_serial_number(void *arg, u64 *val)\n{\n\tstruct adis16480 *adis16480 = arg;\n\tu16 serial;\n\tint ret;\n\n\tret = adis_read_reg_16(&adis16480->adis, ADIS16480_REG_SERIAL_NUM,\n\t\t&serial);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = serial;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(adis16480_serial_number_fops,\n\tadis16480_show_serial_number, NULL, \"0x%.4llx\\n\");\n\nstatic int adis16480_show_product_id(void *arg, u64 *val)\n{\n\tstruct adis16480 *adis16480 = arg;\n\tu16 prod_id;\n\tint ret;\n\n\tret = adis_read_reg_16(&adis16480->adis, ADIS16480_REG_PROD_ID,\n\t\t&prod_id);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = prod_id;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(adis16480_product_id_fops,\n\tadis16480_show_product_id, NULL, \"%llu\\n\");\n\nstatic int adis16480_show_flash_count(void *arg, u64 *val)\n{\n\tstruct adis16480 *adis16480 = arg;\n\tu32 flash_count;\n\tint ret;\n\n\tret = adis_read_reg_32(&adis16480->adis, ADIS16480_REG_FLASH_CNT,\n\t\t&flash_count);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = flash_count;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(adis16480_flash_count_fops,\n\tadis16480_show_flash_count, NULL, \"%lld\\n\");\n\nstatic int adis16480_debugfs_init(struct iio_dev *indio_dev)\n{\n\tstruct adis16480 *adis16480 = iio_priv(indio_dev);\n\tstruct dentry *d = iio_get_debugfs_dentry(indio_dev);\n\n\tdebugfs_create_file_unsafe(\"firmware_revision\", 0400,\n\t\td, adis16480, &adis16480_firmware_revision_fops);\n\tdebugfs_create_file_unsafe(\"firmware_date\", 0400,\n\t\td, adis16480, &adis16480_firmware_date_fops);\n\tdebugfs_create_file_unsafe(\"serial_number\", 0400,\n\t\td, adis16480, &adis16480_serial_number_fops);\n\tdebugfs_create_file_unsafe(\"product_id\", 0400,\n\t\td, adis16480, &adis16480_product_id_fops);\n\tdebugfs_create_file_unsafe(\"flash_count\", 0400,\n\t\td, adis16480, &adis16480_flash_count_fops);\n\n\treturn 0;\n}\n\n#else\n\nstatic int adis16480_debugfs_init(struct iio_dev *indio_dev)\n{\n\treturn 0;\n}\n\n#endif\n\nstatic int adis16480_set_freq(struct iio_dev *indio_dev, int val, int val2)\n{\n\tstruct adis16480 *st = iio_priv(indio_dev);\n\tunsigned int t, sample_rate = st->clk_freq;\n\tint ret;\n\n\tif (val < 0 || val2 < 0)\n\t\treturn -EINVAL;\n\n\tt =  val * 1000 + val2 / 1000;\n\tif (t == 0)\n\t\treturn -EINVAL;\n\n\tadis_dev_lock(&st->adis);\n\t \n\tif (st->clk_mode == ADIS16480_CLK_PPS) {\n\t\tunsigned long scaled_rate = lcm(st->clk_freq, t);\n\t\tint sync_scale;\n\n\t\t \n\t\tif (scaled_rate > st->chip_info->int_clk)\n\t\t\tscaled_rate = st->chip_info->int_clk / st->clk_freq * st->clk_freq;\n\t\telse\n\t\t\tscaled_rate = st->chip_info->int_clk / scaled_rate * scaled_rate;\n\n\t\t \n\t\tif (scaled_rate < 4000000 && !low_rate_allow)\n\t\t\tscaled_rate = roundup(4000000, st->clk_freq);\n\n\t\tsync_scale = scaled_rate / st->clk_freq;\n\t\tret = __adis_write_reg_16(&st->adis, ADIS16495_REG_SYNC_SCALE, sync_scale);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tsample_rate = scaled_rate;\n\t}\n\n\tt = DIV_ROUND_CLOSEST(sample_rate, t);\n\tif (t)\n\t\tt--;\n\n\tif (t > st->chip_info->max_dec_rate)\n\t\tt = st->chip_info->max_dec_rate;\n\n\tret = __adis_write_reg_16(&st->adis, ADIS16480_REG_DEC_RATE, t);\nerror:\n\tadis_dev_unlock(&st->adis);\n\treturn ret;\n}\n\nstatic int adis16480_get_freq(struct iio_dev *indio_dev, int *val, int *val2)\n{\n\tstruct adis16480 *st = iio_priv(indio_dev);\n\tuint16_t t;\n\tint ret;\n\tunsigned int freq, sample_rate = st->clk_freq;\n\n\tadis_dev_lock(&st->adis);\n\n\tif (st->clk_mode == ADIS16480_CLK_PPS) {\n\t\tu16 sync_scale;\n\n\t\tret = __adis_read_reg_16(&st->adis, ADIS16495_REG_SYNC_SCALE, &sync_scale);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tsample_rate = st->clk_freq * sync_scale;\n\t}\n\n\tret = __adis_read_reg_16(&st->adis, ADIS16480_REG_DEC_RATE, &t);\n\tif (ret)\n\t\tgoto error;\n\n\tadis_dev_unlock(&st->adis);\n\n\tfreq = DIV_ROUND_CLOSEST(sample_rate, (t + 1));\n\n\t*val = freq / 1000;\n\t*val2 = (freq % 1000) * 1000;\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\nerror:\n\tadis_dev_unlock(&st->adis);\n\treturn ret;\n}\n\nenum {\n\tADIS16480_SCAN_GYRO_X,\n\tADIS16480_SCAN_GYRO_Y,\n\tADIS16480_SCAN_GYRO_Z,\n\tADIS16480_SCAN_ACCEL_X,\n\tADIS16480_SCAN_ACCEL_Y,\n\tADIS16480_SCAN_ACCEL_Z,\n\tADIS16480_SCAN_MAGN_X,\n\tADIS16480_SCAN_MAGN_Y,\n\tADIS16480_SCAN_MAGN_Z,\n\tADIS16480_SCAN_BARO,\n\tADIS16480_SCAN_TEMP,\n};\n\nstatic const unsigned int adis16480_calibbias_regs[] = {\n\t[ADIS16480_SCAN_GYRO_X] = ADIS16480_REG_X_GYRO_BIAS,\n\t[ADIS16480_SCAN_GYRO_Y] = ADIS16480_REG_Y_GYRO_BIAS,\n\t[ADIS16480_SCAN_GYRO_Z] = ADIS16480_REG_Z_GYRO_BIAS,\n\t[ADIS16480_SCAN_ACCEL_X] = ADIS16480_REG_X_ACCEL_BIAS,\n\t[ADIS16480_SCAN_ACCEL_Y] = ADIS16480_REG_Y_ACCEL_BIAS,\n\t[ADIS16480_SCAN_ACCEL_Z] = ADIS16480_REG_Z_ACCEL_BIAS,\n\t[ADIS16480_SCAN_MAGN_X] = ADIS16480_REG_X_HARD_IRON,\n\t[ADIS16480_SCAN_MAGN_Y] = ADIS16480_REG_Y_HARD_IRON,\n\t[ADIS16480_SCAN_MAGN_Z] = ADIS16480_REG_Z_HARD_IRON,\n\t[ADIS16480_SCAN_BARO] = ADIS16480_REG_BAROM_BIAS,\n};\n\nstatic const unsigned int adis16480_calibscale_regs[] = {\n\t[ADIS16480_SCAN_GYRO_X] = ADIS16480_REG_X_GYRO_SCALE,\n\t[ADIS16480_SCAN_GYRO_Y] = ADIS16480_REG_Y_GYRO_SCALE,\n\t[ADIS16480_SCAN_GYRO_Z] = ADIS16480_REG_Z_GYRO_SCALE,\n\t[ADIS16480_SCAN_ACCEL_X] = ADIS16480_REG_X_ACCEL_SCALE,\n\t[ADIS16480_SCAN_ACCEL_Y] = ADIS16480_REG_Y_ACCEL_SCALE,\n\t[ADIS16480_SCAN_ACCEL_Z] = ADIS16480_REG_Z_ACCEL_SCALE,\n};\n\nstatic int adis16480_set_calibbias(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int bias)\n{\n\tunsigned int reg = adis16480_calibbias_regs[chan->scan_index];\n\tstruct adis16480 *st = iio_priv(indio_dev);\n\n\tswitch (chan->type) {\n\tcase IIO_MAGN:\n\tcase IIO_PRESSURE:\n\t\tif (bias < -0x8000 || bias >= 0x8000)\n\t\t\treturn -EINVAL;\n\t\treturn adis_write_reg_16(&st->adis, reg, bias);\n\tcase IIO_ANGL_VEL:\n\tcase IIO_ACCEL:\n\t\treturn adis_write_reg_32(&st->adis, reg, bias);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int adis16480_get_calibbias(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int *bias)\n{\n\tunsigned int reg = adis16480_calibbias_regs[chan->scan_index];\n\tstruct adis16480 *st = iio_priv(indio_dev);\n\tuint16_t val16;\n\tuint32_t val32;\n\tint ret;\n\n\tswitch (chan->type) {\n\tcase IIO_MAGN:\n\tcase IIO_PRESSURE:\n\t\tret = adis_read_reg_16(&st->adis, reg, &val16);\n\t\tif (ret == 0)\n\t\t\t*bias = sign_extend32(val16, 15);\n\t\tbreak;\n\tcase IIO_ANGL_VEL:\n\tcase IIO_ACCEL:\n\t\tret = adis_read_reg_32(&st->adis, reg, &val32);\n\t\tif (ret == 0)\n\t\t\t*bias = sign_extend32(val32, 31);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int adis16480_set_calibscale(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int scale)\n{\n\tunsigned int reg = adis16480_calibscale_regs[chan->scan_index];\n\tstruct adis16480 *st = iio_priv(indio_dev);\n\n\tif (scale < -0x8000 || scale >= 0x8000)\n\t\treturn -EINVAL;\n\n\treturn adis_write_reg_16(&st->adis, reg, scale);\n}\n\nstatic int adis16480_get_calibscale(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int *scale)\n{\n\tunsigned int reg = adis16480_calibscale_regs[chan->scan_index];\n\tstruct adis16480 *st = iio_priv(indio_dev);\n\tuint16_t val16;\n\tint ret;\n\n\tret = adis_read_reg_16(&st->adis, reg, &val16);\n\tif (ret)\n\t\treturn ret;\n\n\t*scale = sign_extend32(val16, 15);\n\treturn IIO_VAL_INT;\n}\n\nstatic const unsigned int adis16480_def_filter_freqs[] = {\n\t310,\n\t55,\n\t275,\n\t63,\n};\n\nstatic const unsigned int adis16495_def_filter_freqs[] = {\n\t300,\n\t100,\n\t300,\n\t100,\n};\n\nstatic const unsigned int ad16480_filter_data[][2] = {\n\t[ADIS16480_SCAN_GYRO_X]\t\t= { ADIS16480_REG_FILTER_BNK0, 0 },\n\t[ADIS16480_SCAN_GYRO_Y]\t\t= { ADIS16480_REG_FILTER_BNK0, 3 },\n\t[ADIS16480_SCAN_GYRO_Z]\t\t= { ADIS16480_REG_FILTER_BNK0, 6 },\n\t[ADIS16480_SCAN_ACCEL_X]\t= { ADIS16480_REG_FILTER_BNK0, 9 },\n\t[ADIS16480_SCAN_ACCEL_Y]\t= { ADIS16480_REG_FILTER_BNK0, 12 },\n\t[ADIS16480_SCAN_ACCEL_Z]\t= { ADIS16480_REG_FILTER_BNK1, 0 },\n\t[ADIS16480_SCAN_MAGN_X]\t\t= { ADIS16480_REG_FILTER_BNK1, 3 },\n\t[ADIS16480_SCAN_MAGN_Y]\t\t= { ADIS16480_REG_FILTER_BNK1, 6 },\n\t[ADIS16480_SCAN_MAGN_Z]\t\t= { ADIS16480_REG_FILTER_BNK1, 9 },\n};\n\nstatic int adis16480_get_filter_freq(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int *freq)\n{\n\tstruct adis16480 *st = iio_priv(indio_dev);\n\tunsigned int enable_mask, offset, reg;\n\tuint16_t val;\n\tint ret;\n\n\treg = ad16480_filter_data[chan->scan_index][0];\n\toffset = ad16480_filter_data[chan->scan_index][1];\n\tenable_mask = BIT(offset + 2);\n\n\tret = adis_read_reg_16(&st->adis, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(val & enable_mask))\n\t\t*freq = 0;\n\telse\n\t\t*freq = st->chip_info->filter_freqs[(val >> offset) & 0x3];\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int adis16480_set_filter_freq(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, unsigned int freq)\n{\n\tstruct adis16480 *st = iio_priv(indio_dev);\n\tunsigned int enable_mask, offset, reg;\n\tunsigned int diff, best_diff;\n\tunsigned int i, best_freq;\n\tuint16_t val;\n\tint ret;\n\n\treg = ad16480_filter_data[chan->scan_index][0];\n\toffset = ad16480_filter_data[chan->scan_index][1];\n\tenable_mask = BIT(offset + 2);\n\n\tadis_dev_lock(&st->adis);\n\n\tret = __adis_read_reg_16(&st->adis, reg, &val);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (freq == 0) {\n\t\tval &= ~enable_mask;\n\t} else {\n\t\tbest_freq = 0;\n\t\tbest_diff = st->chip_info->filter_freqs[0];\n\t\tfor (i = 0; i < ARRAY_SIZE(adis16480_def_filter_freqs); i++) {\n\t\t\tif (st->chip_info->filter_freqs[i] >= freq) {\n\t\t\t\tdiff = st->chip_info->filter_freqs[i] - freq;\n\t\t\t\tif (diff < best_diff) {\n\t\t\t\t\tbest_diff = diff;\n\t\t\t\t\tbest_freq = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tval &= ~(0x3 << offset);\n\t\tval |= best_freq << offset;\n\t\tval |= enable_mask;\n\t}\n\n\tret = __adis_write_reg_16(&st->adis, reg, val);\nout_unlock:\n\tadis_dev_unlock(&st->adis);\n\n\treturn ret;\n}\n\nstatic int adis16480_read_raw(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int *val, int *val2, long info)\n{\n\tstruct adis16480 *st = iio_priv(indio_dev);\n\tunsigned int temp;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn adis_single_conversion(indio_dev, chan, 0, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\t*val = st->chip_info->gyro_max_scale;\n\t\t\t*val2 = st->chip_info->gyro_max_val;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_ACCEL:\n\t\t\t*val = st->chip_info->accel_max_scale;\n\t\t\t*val2 = st->chip_info->accel_max_val;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_MAGN:\n\t\t\t*val = 0;\n\t\t\t*val2 = 100;  \n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = st->chip_info->temp_scale / 1000;\n\t\t\t*val2 = (st->chip_info->temp_scale % 1000) * 1000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_PRESSURE:\n\t\t\t \n\t\t\t*val = 131;  \n\t\t\t*val2 = 32767 << 16;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\ttemp = 25 * 1000000LL;  \n\t\t*val = DIV_ROUND_CLOSEST_ULL(temp, st->chip_info->temp_scale);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treturn adis16480_get_calibbias(indio_dev, chan, val);\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\treturn adis16480_get_calibscale(indio_dev, chan, val);\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn adis16480_get_filter_freq(indio_dev, chan, val);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn adis16480_get_freq(indio_dev, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adis16480_write_raw(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int val, int val2, long info)\n{\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treturn adis16480_set_calibbias(indio_dev, chan, val);\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\treturn adis16480_set_calibscale(indio_dev, chan, val);\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn adis16480_set_filter_freq(indio_dev, chan, val);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn adis16480_set_freq(indio_dev, val, val2);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#define ADIS16480_MOD_CHANNEL(_type, _mod, _address, _si, _info_sep, _bits) \\\n\t{ \\\n\t\t.type = (_type), \\\n\t\t.modified = 1, \\\n\t\t.channel2 = (_mod), \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS) | \\\n\t\t\t_info_sep, \\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t\t.address = (_address), \\\n\t\t.scan_index = (_si), \\\n\t\t.scan_type = { \\\n\t\t\t.sign = 's', \\\n\t\t\t.realbits = (_bits), \\\n\t\t\t.storagebits = (_bits), \\\n\t\t\t.endianness = IIO_BE, \\\n\t\t}, \\\n\t}\n\n#define ADIS16480_GYRO_CHANNEL(_mod) \\\n\tADIS16480_MOD_CHANNEL(IIO_ANGL_VEL, IIO_MOD_ ## _mod, \\\n\tADIS16480_REG_ ## _mod ## _GYRO_OUT, ADIS16480_SCAN_GYRO_ ## _mod, \\\n\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY) | \\\n\tBIT(IIO_CHAN_INFO_CALIBSCALE), \\\n\t32)\n\n#define ADIS16480_ACCEL_CHANNEL(_mod) \\\n\tADIS16480_MOD_CHANNEL(IIO_ACCEL, IIO_MOD_ ## _mod, \\\n\tADIS16480_REG_ ## _mod ## _ACCEL_OUT, ADIS16480_SCAN_ACCEL_ ## _mod, \\\n\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY) | \\\n\tBIT(IIO_CHAN_INFO_CALIBSCALE), \\\n\t32)\n\n#define ADIS16480_MAGN_CHANNEL(_mod) \\\n\tADIS16480_MOD_CHANNEL(IIO_MAGN, IIO_MOD_ ## _mod, \\\n\tADIS16480_REG_ ## _mod ## _MAGN_OUT, ADIS16480_SCAN_MAGN_ ## _mod, \\\n\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY), \\\n\t16)\n\n#define ADIS16480_PRESSURE_CHANNEL() \\\n\t{ \\\n\t\t.type = IIO_PRESSURE, \\\n\t\t.indexed = 1, \\\n\t\t.channel = 0, \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS) | \\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE), \\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t\t.address = ADIS16480_REG_BAROM_OUT, \\\n\t\t.scan_index = ADIS16480_SCAN_BARO, \\\n\t\t.scan_type = { \\\n\t\t\t.sign = 's', \\\n\t\t\t.realbits = 32, \\\n\t\t\t.storagebits = 32, \\\n\t\t\t.endianness = IIO_BE, \\\n\t\t}, \\\n\t}\n\n#define ADIS16480_TEMP_CHANNEL() { \\\n\t\t.type = IIO_TEMP, \\\n\t\t.indexed = 1, \\\n\t\t.channel = 0, \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) | \\\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET), \\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t\t.address = ADIS16480_REG_TEMP_OUT, \\\n\t\t.scan_index = ADIS16480_SCAN_TEMP, \\\n\t\t.scan_type = { \\\n\t\t\t.sign = 's', \\\n\t\t\t.realbits = 16, \\\n\t\t\t.storagebits = 16, \\\n\t\t\t.endianness = IIO_BE, \\\n\t\t}, \\\n\t}\n\nstatic const struct iio_chan_spec adis16480_channels[] = {\n\tADIS16480_GYRO_CHANNEL(X),\n\tADIS16480_GYRO_CHANNEL(Y),\n\tADIS16480_GYRO_CHANNEL(Z),\n\tADIS16480_ACCEL_CHANNEL(X),\n\tADIS16480_ACCEL_CHANNEL(Y),\n\tADIS16480_ACCEL_CHANNEL(Z),\n\tADIS16480_MAGN_CHANNEL(X),\n\tADIS16480_MAGN_CHANNEL(Y),\n\tADIS16480_MAGN_CHANNEL(Z),\n\tADIS16480_PRESSURE_CHANNEL(),\n\tADIS16480_TEMP_CHANNEL(),\n\tIIO_CHAN_SOFT_TIMESTAMP(11)\n};\n\nstatic const struct iio_chan_spec adis16485_channels[] = {\n\tADIS16480_GYRO_CHANNEL(X),\n\tADIS16480_GYRO_CHANNEL(Y),\n\tADIS16480_GYRO_CHANNEL(Z),\n\tADIS16480_ACCEL_CHANNEL(X),\n\tADIS16480_ACCEL_CHANNEL(Y),\n\tADIS16480_ACCEL_CHANNEL(Z),\n\tADIS16480_TEMP_CHANNEL(),\n\tIIO_CHAN_SOFT_TIMESTAMP(7)\n};\n\nenum adis16480_variant {\n\tADIS16375,\n\tADIS16480,\n\tADIS16485,\n\tADIS16488,\n\tADIS16490,\n\tADIS16495_1,\n\tADIS16495_2,\n\tADIS16495_3,\n\tADIS16497_1,\n\tADIS16497_2,\n\tADIS16497_3,\n};\n\n#define ADIS16480_DIAG_STAT_XGYRO_FAIL 0\n#define ADIS16480_DIAG_STAT_YGYRO_FAIL 1\n#define ADIS16480_DIAG_STAT_ZGYRO_FAIL 2\n#define ADIS16480_DIAG_STAT_XACCL_FAIL 3\n#define ADIS16480_DIAG_STAT_YACCL_FAIL 4\n#define ADIS16480_DIAG_STAT_ZACCL_FAIL 5\n#define ADIS16480_DIAG_STAT_XMAGN_FAIL 8\n#define ADIS16480_DIAG_STAT_YMAGN_FAIL 9\n#define ADIS16480_DIAG_STAT_ZMAGN_FAIL 10\n#define ADIS16480_DIAG_STAT_BARO_FAIL 11\n\nstatic const char * const adis16480_status_error_msgs[] = {\n\t[ADIS16480_DIAG_STAT_XGYRO_FAIL] = \"X-axis gyroscope self-test failure\",\n\t[ADIS16480_DIAG_STAT_YGYRO_FAIL] = \"Y-axis gyroscope self-test failure\",\n\t[ADIS16480_DIAG_STAT_ZGYRO_FAIL] = \"Z-axis gyroscope self-test failure\",\n\t[ADIS16480_DIAG_STAT_XACCL_FAIL] = \"X-axis accelerometer self-test failure\",\n\t[ADIS16480_DIAG_STAT_YACCL_FAIL] = \"Y-axis accelerometer self-test failure\",\n\t[ADIS16480_DIAG_STAT_ZACCL_FAIL] = \"Z-axis accelerometer self-test failure\",\n\t[ADIS16480_DIAG_STAT_XMAGN_FAIL] = \"X-axis magnetometer self-test failure\",\n\t[ADIS16480_DIAG_STAT_YMAGN_FAIL] = \"Y-axis magnetometer self-test failure\",\n\t[ADIS16480_DIAG_STAT_ZMAGN_FAIL] = \"Z-axis magnetometer self-test failure\",\n\t[ADIS16480_DIAG_STAT_BARO_FAIL] = \"Barometer self-test failure\",\n};\n\nstatic int adis16480_enable_irq(struct adis *adis, bool enable);\n\n#define ADIS16480_DATA(_prod_id, _timeouts, _burst_len)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.diag_stat_reg = ADIS16480_REG_DIAG_STS,\t\t\t\\\n\t.glob_cmd_reg = ADIS16480_REG_GLOB_CMD,\t\t\t\t\\\n\t.prod_id_reg = ADIS16480_REG_PROD_ID,\t\t\t\t\\\n\t.prod_id = (_prod_id),\t\t\t\t\t\t\\\n\t.has_paging = true,\t\t\t\t\t\t\\\n\t.read_delay = 5,\t\t\t\t\t\t\\\n\t.write_delay = 5,\t\t\t\t\t\t\\\n\t.self_test_mask = BIT(1),\t\t\t\t\t\\\n\t.self_test_reg = ADIS16480_REG_GLOB_CMD,\t\t\t\\\n\t.status_error_msgs = adis16480_status_error_msgs,\t\t\\\n\t.status_error_mask = BIT(ADIS16480_DIAG_STAT_XGYRO_FAIL) |\t\\\n\t\tBIT(ADIS16480_DIAG_STAT_YGYRO_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16480_DIAG_STAT_ZGYRO_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16480_DIAG_STAT_XACCL_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16480_DIAG_STAT_YACCL_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16480_DIAG_STAT_ZACCL_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16480_DIAG_STAT_XMAGN_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16480_DIAG_STAT_YMAGN_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16480_DIAG_STAT_ZMAGN_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16480_DIAG_STAT_BARO_FAIL),\t\t\t\\\n\t.enable_irq = adis16480_enable_irq,\t\t\t\t\\\n\t.timeouts = (_timeouts),\t\t\t\t\t\\\n\t.burst_reg_cmd = ADIS16495_REG_BURST_CMD,\t\t\t\\\n\t.burst_len = (_burst_len),\t\t\t\t\t\\\n\t.burst_max_speed_hz = ADIS16495_BURST_MAX_SPEED\t\t\t\\\n}\n\nstatic const struct adis_timeout adis16485_timeouts = {\n\t.reset_ms = 560,\n\t.sw_reset_ms = 120,\n\t.self_test_ms = 12,\n};\n\nstatic const struct adis_timeout adis16480_timeouts = {\n\t.reset_ms = 560,\n\t.sw_reset_ms = 560,\n\t.self_test_ms = 12,\n};\n\nstatic const struct adis_timeout adis16495_timeouts = {\n\t.reset_ms = 170,\n\t.sw_reset_ms = 130,\n\t.self_test_ms = 40,\n};\n\nstatic const struct adis_timeout adis16495_1_timeouts = {\n\t.reset_ms = 250,\n\t.sw_reset_ms = 210,\n\t.self_test_ms = 20,\n};\n\nstatic const struct adis16480_chip_info adis16480_chip_info[] = {\n\t[ADIS16375] = {\n\t\t.channels = adis16485_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16485_channels),\n\t\t \n\t\t.gyro_max_val = 22887 << 16,\n\t\t.gyro_max_scale = IIO_DEGREE_TO_RAD(300),\n\t\t.accel_max_val = IIO_M_S_2_TO_G(21973 << 16),\n\t\t.accel_max_scale = 18,\n\t\t.temp_scale = 5650,  \n\t\t.int_clk = 2460000,\n\t\t.max_dec_rate = 2048,\n\t\t.has_sleep_cnt = true,\n\t\t.filter_freqs = adis16480_def_filter_freqs,\n\t\t.adis_data = ADIS16480_DATA(16375, &adis16485_timeouts, 0),\n\t},\n\t[ADIS16480] = {\n\t\t.channels = adis16480_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16480_channels),\n\t\t.gyro_max_val = 22500 << 16,\n\t\t.gyro_max_scale = IIO_DEGREE_TO_RAD(450),\n\t\t.accel_max_val = IIO_M_S_2_TO_G(12500 << 16),\n\t\t.accel_max_scale = 10,\n\t\t.temp_scale = 5650,  \n\t\t.int_clk = 2460000,\n\t\t.max_dec_rate = 2048,\n\t\t.has_sleep_cnt = true,\n\t\t.filter_freqs = adis16480_def_filter_freqs,\n\t\t.adis_data = ADIS16480_DATA(16480, &adis16480_timeouts, 0),\n\t},\n\t[ADIS16485] = {\n\t\t.channels = adis16485_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16485_channels),\n\t\t.gyro_max_val = 22500 << 16,\n\t\t.gyro_max_scale = IIO_DEGREE_TO_RAD(450),\n\t\t.accel_max_val = IIO_M_S_2_TO_G(20000 << 16),\n\t\t.accel_max_scale = 5,\n\t\t.temp_scale = 5650,  \n\t\t.int_clk = 2460000,\n\t\t.max_dec_rate = 2048,\n\t\t.has_sleep_cnt = true,\n\t\t.filter_freqs = adis16480_def_filter_freqs,\n\t\t.adis_data = ADIS16480_DATA(16485, &adis16485_timeouts, 0),\n\t},\n\t[ADIS16488] = {\n\t\t.channels = adis16480_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16480_channels),\n\t\t.gyro_max_val = 22500 << 16,\n\t\t.gyro_max_scale = IIO_DEGREE_TO_RAD(450),\n\t\t.accel_max_val = IIO_M_S_2_TO_G(22500 << 16),\n\t\t.accel_max_scale = 18,\n\t\t.temp_scale = 5650,  \n\t\t.int_clk = 2460000,\n\t\t.max_dec_rate = 2048,\n\t\t.has_sleep_cnt = true,\n\t\t.filter_freqs = adis16480_def_filter_freqs,\n\t\t.adis_data = ADIS16480_DATA(16488, &adis16485_timeouts, 0),\n\t},\n\t[ADIS16490] = {\n\t\t.channels = adis16485_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16485_channels),\n\t\t.gyro_max_val = 20000 << 16,\n\t\t.gyro_max_scale = IIO_DEGREE_TO_RAD(100),\n\t\t.accel_max_val = IIO_M_S_2_TO_G(16000 << 16),\n\t\t.accel_max_scale = 8,\n\t\t.temp_scale = 14285,  \n\t\t.int_clk = 4250000,\n\t\t.max_dec_rate = 4250,\n\t\t.filter_freqs = adis16495_def_filter_freqs,\n\t\t.has_pps_clk_mode = true,\n\t\t.adis_data = ADIS16480_DATA(16490, &adis16495_timeouts, 0),\n\t},\n\t[ADIS16495_1] = {\n\t\t.channels = adis16485_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16485_channels),\n\t\t.gyro_max_val = 20000 << 16,\n\t\t.gyro_max_scale = IIO_DEGREE_TO_RAD(125),\n\t\t.accel_max_val = IIO_M_S_2_TO_G(32000 << 16),\n\t\t.accel_max_scale = 8,\n\t\t.temp_scale = 12500,  \n\t\t.int_clk = 4250000,\n\t\t.max_dec_rate = 4250,\n\t\t.filter_freqs = adis16495_def_filter_freqs,\n\t\t.has_pps_clk_mode = true,\n\t\t \n\t\t.adis_data = ADIS16480_DATA(16495, &adis16495_1_timeouts,\n\t\t\t\t\t    ADIS16495_BURST_MAX_DATA * 2),\n\t},\n\t[ADIS16495_2] = {\n\t\t.channels = adis16485_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16485_channels),\n\t\t.gyro_max_val = 18000 << 16,\n\t\t.gyro_max_scale = IIO_DEGREE_TO_RAD(450),\n\t\t.accel_max_val = IIO_M_S_2_TO_G(32000 << 16),\n\t\t.accel_max_scale = 8,\n\t\t.temp_scale = 12500,  \n\t\t.int_clk = 4250000,\n\t\t.max_dec_rate = 4250,\n\t\t.filter_freqs = adis16495_def_filter_freqs,\n\t\t.has_pps_clk_mode = true,\n\t\t \n\t\t.adis_data = ADIS16480_DATA(16495, &adis16495_1_timeouts,\n\t\t\t\t\t    ADIS16495_BURST_MAX_DATA * 2),\n\t},\n\t[ADIS16495_3] = {\n\t\t.channels = adis16485_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16485_channels),\n\t\t.gyro_max_val = 20000 << 16,\n\t\t.gyro_max_scale = IIO_DEGREE_TO_RAD(2000),\n\t\t.accel_max_val = IIO_M_S_2_TO_G(32000 << 16),\n\t\t.accel_max_scale = 8,\n\t\t.temp_scale = 12500,  \n\t\t.int_clk = 4250000,\n\t\t.max_dec_rate = 4250,\n\t\t.filter_freqs = adis16495_def_filter_freqs,\n\t\t.has_pps_clk_mode = true,\n\t\t \n\t\t.adis_data = ADIS16480_DATA(16495, &adis16495_1_timeouts,\n\t\t\t\t\t    ADIS16495_BURST_MAX_DATA * 2),\n\t},\n\t[ADIS16497_1] = {\n\t\t.channels = adis16485_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16485_channels),\n\t\t.gyro_max_val = 20000 << 16,\n\t\t.gyro_max_scale = IIO_DEGREE_TO_RAD(125),\n\t\t.accel_max_val = IIO_M_S_2_TO_G(32000 << 16),\n\t\t.accel_max_scale = 40,\n\t\t.temp_scale = 12500,  \n\t\t.int_clk = 4250000,\n\t\t.max_dec_rate = 4250,\n\t\t.filter_freqs = adis16495_def_filter_freqs,\n\t\t.has_pps_clk_mode = true,\n\t\t \n\t\t.adis_data = ADIS16480_DATA(16497, &adis16495_1_timeouts,\n\t\t\t\t\t    ADIS16495_BURST_MAX_DATA * 2),\n\t},\n\t[ADIS16497_2] = {\n\t\t.channels = adis16485_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16485_channels),\n\t\t.gyro_max_val = 18000 << 16,\n\t\t.gyro_max_scale = IIO_DEGREE_TO_RAD(450),\n\t\t.accel_max_val = IIO_M_S_2_TO_G(32000 << 16),\n\t\t.accel_max_scale = 40,\n\t\t.temp_scale = 12500,  \n\t\t.int_clk = 4250000,\n\t\t.max_dec_rate = 4250,\n\t\t.filter_freqs = adis16495_def_filter_freqs,\n\t\t.has_pps_clk_mode = true,\n\t\t \n\t\t.adis_data = ADIS16480_DATA(16497, &adis16495_1_timeouts,\n\t\t\t\t\t    ADIS16495_BURST_MAX_DATA * 2),\n\t},\n\t[ADIS16497_3] = {\n\t\t.channels = adis16485_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16485_channels),\n\t\t.gyro_max_val = 20000 << 16,\n\t\t.gyro_max_scale = IIO_DEGREE_TO_RAD(2000),\n\t\t.accel_max_val = IIO_M_S_2_TO_G(32000 << 16),\n\t\t.accel_max_scale = 40,\n\t\t.temp_scale = 12500,  \n\t\t.int_clk = 4250000,\n\t\t.max_dec_rate = 4250,\n\t\t.filter_freqs = adis16495_def_filter_freqs,\n\t\t.has_pps_clk_mode = true,\n\t\t \n\t\t.adis_data = ADIS16480_DATA(16497, &adis16495_1_timeouts,\n\t\t\t\t\t    ADIS16495_BURST_MAX_DATA * 2),\n\t},\n};\n\nstatic bool adis16480_validate_crc(const u16 *buf, const u8 n_elem, const u32 crc)\n{\n\tu32 crc_calc;\n\tu16 crc_buf[15];\n\tint j;\n\n\tfor (j = 0; j < n_elem; j++)\n\t\tcrc_buf[j] = swab16(buf[j]);\n\n\tcrc_calc = crc32(~0, crc_buf, n_elem * 2);\n\tcrc_calc ^= ~0;\n\n\treturn (crc == crc_calc);\n}\n\nstatic irqreturn_t adis16480_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct adis16480 *st = iio_priv(indio_dev);\n\tstruct adis *adis = &st->adis;\n\tstruct device *dev = &adis->spi->dev;\n\tint ret, bit, offset, i = 0;\n\t__be16 *buffer;\n\tu32 crc;\n\tbool valid;\n\n\tadis_dev_lock(adis);\n\tif (adis->current_page != 0) {\n\t\tadis->tx[0] = ADIS_WRITE_REG(ADIS_REG_PAGE_ID);\n\t\tadis->tx[1] = 0;\n\t\tret = spi_write(adis->spi, adis->tx, 2);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to change device page: %d\\n\", ret);\n\t\t\tadis_dev_unlock(adis);\n\t\t\tgoto irq_done;\n\t\t}\n\n\t\tadis->current_page = 0;\n\t}\n\n\tret = spi_sync(adis->spi, &adis->msg);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read data: %d\\n\", ret);\n\t\tadis_dev_unlock(adis);\n\t\tgoto irq_done;\n\t}\n\n\tadis_dev_unlock(adis);\n\n\t \n\tbuffer = adis->buffer;\n\tfor (offset = 0; offset < 4; offset++) {\n\t\tu16 curr = be16_to_cpu(buffer[offset]);\n\t\tu16 next = be16_to_cpu(buffer[offset + 1]);\n\n\t\tif (curr == ADIS16495_BURST_ID && next != ADIS16495_BURST_ID) {\n\t\t\toffset++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offset == 4) {\n\t\tdev_err(dev, \"Invalid burst data\\n\");\n\t\tgoto irq_done;\n\t}\n\n\tcrc = be16_to_cpu(buffer[offset + 16]) << 16 | be16_to_cpu(buffer[offset + 15]);\n\tvalid = adis16480_validate_crc((u16 *)&buffer[offset], 15, crc);\n\tif (!valid) {\n\t\tdev_err(dev, \"Invalid crc\\n\");\n\t\tgoto irq_done;\n\t}\n\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask, indio_dev->masklength) {\n\t\t \n\t\tswitch (bit) {\n\t\tcase ADIS16480_SCAN_TEMP:\n\t\t\tst->data[i++] = buffer[offset + 1];\n\t\t\tbreak;\n\t\tcase ADIS16480_SCAN_GYRO_X ... ADIS16480_SCAN_ACCEL_Z:\n\t\t\t \n\t\t\tst->data[i++] = buffer[2 * bit + offset + 3];\n\t\t\tst->data[i++] = buffer[2 * bit + offset + 2];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, st->data, pf->timestamp);\nirq_done:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_info adis16480_info = {\n\t.read_raw = &adis16480_read_raw,\n\t.write_raw = &adis16480_write_raw,\n\t.update_scan_mode = adis_update_scan_mode,\n\t.debugfs_reg_access = adis_debugfs_reg_access,\n};\n\nstatic int adis16480_stop_device(struct iio_dev *indio_dev)\n{\n\tstruct adis16480 *st = iio_priv(indio_dev);\n\tstruct device *dev = &st->adis.spi->dev;\n\tint ret;\n\n\tret = adis_write_reg_16(&st->adis, ADIS16480_REG_SLP_CNT, BIT(9));\n\tif (ret)\n\t\tdev_err(dev, \"Could not power down device: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int adis16480_enable_irq(struct adis *adis, bool enable)\n{\n\tuint16_t val;\n\tint ret;\n\n\tret = __adis_read_reg_16(adis, ADIS16480_REG_FNCTIO_CTRL, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~ADIS16480_DRDY_EN_MSK;\n\tval |= ADIS16480_DRDY_EN(enable);\n\n\treturn __adis_write_reg_16(adis, ADIS16480_REG_FNCTIO_CTRL, val);\n}\n\nstatic int adis16480_config_irq_pin(struct adis16480 *st)\n{\n\tstruct device *dev = &st->adis.spi->dev;\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\tstruct irq_data *desc;\n\tenum adis16480_int_pin pin;\n\tunsigned int irq_type;\n\tuint16_t val;\n\tint i, irq = 0;\n\n\tdesc = irq_get_irq_data(st->adis.spi->irq);\n\tif (!desc) {\n\t\tdev_err(dev, \"Could not find IRQ %d\\n\", irq);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval = ADIS16480_DRDY_EN(0);\n\n\t \n\tpin = ADIS16480_PIN_DIO1;\n\tfor (i = 0; i < ARRAY_SIZE(adis16480_int_pin_names); i++) {\n\t\tirq = fwnode_irq_get_byname(fwnode, adis16480_int_pin_names[i]);\n\t\tif (irq > 0) {\n\t\t\tpin = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tval |= ADIS16480_DRDY_SEL(pin);\n\n\t \n\tirq_type = irqd_get_trigger_type(desc);\n\tif (irq_type == IRQ_TYPE_EDGE_RISING) {  \n\t\tval |= ADIS16480_DRDY_POL(1);\n\t} else if (irq_type == IRQ_TYPE_EDGE_FALLING) {\n\t\tval |= ADIS16480_DRDY_POL(0);\n\t} else {\n\t\tdev_err(dev, \"Invalid interrupt type 0x%x specified\\n\", irq_type);\n\t\treturn -EINVAL;\n\t}\n\t \n\treturn adis_write_reg_16(&st->adis, ADIS16480_REG_FNCTIO_CTRL, val);\n}\n\nstatic int adis16480_fw_get_ext_clk_pin(struct adis16480 *st)\n{\n\tstruct device *dev = &st->adis.spi->dev;\n\tconst char *ext_clk_pin;\n\tenum adis16480_int_pin pin;\n\tint i;\n\n\tpin = ADIS16480_PIN_DIO2;\n\tif (device_property_read_string(dev, \"adi,ext-clk-pin\", &ext_clk_pin))\n\t\tgoto clk_input_not_found;\n\n\tfor (i = 0; i < ARRAY_SIZE(adis16480_int_pin_names); i++) {\n\t\tif (strcasecmp(ext_clk_pin, adis16480_int_pin_names[i]) == 0)\n\t\t\treturn i;\n\t}\n\nclk_input_not_found:\n\tdev_info(dev, \"clk input line not specified, using DIO2\\n\");\n\treturn pin;\n}\n\nstatic int adis16480_ext_clk_config(struct adis16480 *st, bool enable)\n{\n\tstruct device *dev = &st->adis.spi->dev;\n\tunsigned int mode, mask;\n\tenum adis16480_int_pin pin;\n\tuint16_t val;\n\tint ret;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16480_REG_FNCTIO_CTRL, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tpin = adis16480_fw_get_ext_clk_pin(st);\n\t \n\tif (pin == ADIS16480_DRDY_SEL(val))\n\t\tdev_warn(dev, \"DIO%x pin supports only one function at a time\\n\", pin + 1);\n\n\tmode = ADIS16480_SYNC_EN(enable) | ADIS16480_SYNC_SEL(pin);\n\tmask = ADIS16480_SYNC_EN_MSK | ADIS16480_SYNC_SEL_MSK;\n\t \n\tif (st->chip_info->has_pps_clk_mode) {\n\t\tmode |= ADIS16480_SYNC_MODE(st->clk_mode);\n\t\tmask |= ADIS16480_SYNC_MODE_MSK;\n\t}\n\n\tval &= ~mask;\n\tval |= mode;\n\n\tret = adis_write_reg_16(&st->adis, ADIS16480_REG_FNCTIO_CTRL, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn clk_prepare_enable(st->ext_clk);\n}\n\nstatic int adis16480_get_ext_clocks(struct adis16480 *st)\n{\n\tstruct device *dev = &st->adis.spi->dev;\n\n\tst->ext_clk = devm_clk_get_optional(dev, \"sync\");\n\tif (IS_ERR(st->ext_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(st->ext_clk), \"failed to get ext clk\\n\");\n\tif (st->ext_clk) {\n\t\tst->clk_mode = ADIS16480_CLK_SYNC;\n\t\treturn 0;\n\t}\n\n\tif (st->chip_info->has_pps_clk_mode) {\n\t\tst->ext_clk = devm_clk_get_optional(dev, \"pps\");\n\t\tif (IS_ERR(st->ext_clk))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(st->ext_clk), \"failed to get ext clk\\n\");\n\t\tif (st->ext_clk) {\n\t\t\tst->clk_mode = ADIS16480_CLK_PPS;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tst->clk_mode = ADIS16480_CLK_INT;\n\treturn 0;\n}\n\nstatic void adis16480_stop(void *data)\n{\n\tadis16480_stop_device(data);\n}\n\nstatic void adis16480_clk_disable(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic int adis16480_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tconst struct adis_data *adis16480_data;\n\tirq_handler_t trigger_handler = NULL;\n\tstruct device *dev = &spi->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct adis16480 *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->chip_info = &adis16480_chip_info[id->driver_data];\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->channels = st->chip_info->channels;\n\tindio_dev->num_channels = st->chip_info->num_channels;\n\tindio_dev->info = &adis16480_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tadis16480_data = &st->chip_info->adis_data;\n\n\tret = adis_init(&st->adis, indio_dev, spi, adis16480_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __adis_initial_startup(&st->adis);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->chip_info->has_sleep_cnt) {\n\t\tret = devm_add_action_or_reset(dev, adis16480_stop, indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = adis16480_config_irq_pin(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adis16480_get_ext_clocks(st);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->ext_clk) {\n\t\tret = adis16480_ext_clk_config(st, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(dev, adis16480_clk_disable, st->ext_clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tst->clk_freq = clk_get_rate(st->ext_clk);\n\t\tst->clk_freq *= 1000;  \n\t\tif (st->clk_mode == ADIS16480_CLK_PPS) {\n\t\t\tu16 sync_scale;\n\n\t\t\t \n\t\t\tsync_scale = st->chip_info->int_clk / st->clk_freq;\n\t\t\tret = __adis_write_reg_16(&st->adis, ADIS16495_REG_SYNC_SCALE, sync_scale);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tst->clk_freq = st->chip_info->int_clk;\n\t}\n\n\t \n\tif (adis16480_data->burst_len)\n\t\ttrigger_handler = adis16480_trigger_handler;\n\n\tret = devm_adis_setup_buffer_and_trigger(&st->adis, indio_dev,\n\t\t\t\t\t\t trigger_handler);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tadis16480_debugfs_init(indio_dev);\n\n\treturn 0;\n}\n\nstatic const struct spi_device_id adis16480_ids[] = {\n\t{ \"adis16375\", ADIS16375 },\n\t{ \"adis16480\", ADIS16480 },\n\t{ \"adis16485\", ADIS16485 },\n\t{ \"adis16488\", ADIS16488 },\n\t{ \"adis16490\", ADIS16490 },\n\t{ \"adis16495-1\", ADIS16495_1 },\n\t{ \"adis16495-2\", ADIS16495_2 },\n\t{ \"adis16495-3\", ADIS16495_3 },\n\t{ \"adis16497-1\", ADIS16497_1 },\n\t{ \"adis16497-2\", ADIS16497_2 },\n\t{ \"adis16497-3\", ADIS16497_3 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, adis16480_ids);\n\nstatic const struct of_device_id adis16480_of_match[] = {\n\t{ .compatible = \"adi,adis16375\" },\n\t{ .compatible = \"adi,adis16480\" },\n\t{ .compatible = \"adi,adis16485\" },\n\t{ .compatible = \"adi,adis16488\" },\n\t{ .compatible = \"adi,adis16490\" },\n\t{ .compatible = \"adi,adis16495-1\" },\n\t{ .compatible = \"adi,adis16495-2\" },\n\t{ .compatible = \"adi,adis16495-3\" },\n\t{ .compatible = \"adi,adis16497-1\" },\n\t{ .compatible = \"adi,adis16497-2\" },\n\t{ .compatible = \"adi,adis16497-3\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, adis16480_of_match);\n\nstatic struct spi_driver adis16480_driver = {\n\t.driver = {\n\t\t.name = \"adis16480\",\n\t\t.of_match_table = adis16480_of_match,\n\t},\n\t.id_table = adis16480_ids,\n\t.probe = adis16480_probe,\n};\nmodule_spi_driver(adis16480_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Analog Devices ADIS16480 IMU driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_ADISLIB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}