{
  "module_name": "adis16460.c",
  "hash_id": "4cf79610bd06b11bc3b51f13193ee1f4b7e6a1ffd0243ecae1a2513390c11b62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/adis16460.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/imu/adis.h>\n\n#include <linux/debugfs.h>\n\n#define ADIS16460_REG_FLASH_CNT\t\t0x00\n#define ADIS16460_REG_DIAG_STAT\t\t0x02\n#define ADIS16460_REG_X_GYRO_LOW\t0x04\n#define ADIS16460_REG_X_GYRO_OUT\t0x06\n#define ADIS16460_REG_Y_GYRO_LOW\t0x08\n#define ADIS16460_REG_Y_GYRO_OUT\t0x0A\n#define ADIS16460_REG_Z_GYRO_LOW\t0x0C\n#define ADIS16460_REG_Z_GYRO_OUT\t0x0E\n#define ADIS16460_REG_X_ACCL_LOW\t0x10\n#define ADIS16460_REG_X_ACCL_OUT\t0x12\n#define ADIS16460_REG_Y_ACCL_LOW\t0x14\n#define ADIS16460_REG_Y_ACCL_OUT\t0x16\n#define ADIS16460_REG_Z_ACCL_LOW\t0x18\n#define ADIS16460_REG_Z_ACCL_OUT\t0x1A\n#define ADIS16460_REG_SMPL_CNTR\t\t0x1C\n#define ADIS16460_REG_TEMP_OUT\t\t0x1E\n#define ADIS16460_REG_X_DELT_ANG\t0x24\n#define ADIS16460_REG_Y_DELT_ANG\t0x26\n#define ADIS16460_REG_Z_DELT_ANG\t0x28\n#define ADIS16460_REG_X_DELT_VEL\t0x2A\n#define ADIS16460_REG_Y_DELT_VEL\t0x2C\n#define ADIS16460_REG_Z_DELT_VEL\t0x2E\n#define ADIS16460_REG_MSC_CTRL\t\t0x32\n#define ADIS16460_REG_SYNC_SCAL\t\t0x34\n#define ADIS16460_REG_DEC_RATE\t\t0x36\n#define ADIS16460_REG_FLTR_CTRL\t\t0x38\n#define ADIS16460_REG_GLOB_CMD\t\t0x3E\n#define ADIS16460_REG_X_GYRO_OFF\t0x40\n#define ADIS16460_REG_Y_GYRO_OFF\t0x42\n#define ADIS16460_REG_Z_GYRO_OFF\t0x44\n#define ADIS16460_REG_X_ACCL_OFF\t0x46\n#define ADIS16460_REG_Y_ACCL_OFF\t0x48\n#define ADIS16460_REG_Z_ACCL_OFF\t0x4A\n#define ADIS16460_REG_LOT_ID1\t\t0x52\n#define ADIS16460_REG_LOT_ID2\t\t0x54\n#define ADIS16460_REG_PROD_ID\t\t0x56\n#define ADIS16460_REG_SERIAL_NUM\t0x58\n#define ADIS16460_REG_CAL_SGNTR\t\t0x60\n#define ADIS16460_REG_CAL_CRC\t\t0x62\n#define ADIS16460_REG_CODE_SGNTR\t0x64\n#define ADIS16460_REG_CODE_CRC\t\t0x66\n\nstruct adis16460_chip_info {\n\tunsigned int num_channels;\n\tconst struct iio_chan_spec *channels;\n\tunsigned int gyro_max_val;\n\tunsigned int gyro_max_scale;\n\tunsigned int accel_max_val;\n\tunsigned int accel_max_scale;\n};\n\nstruct adis16460 {\n\tconst struct adis16460_chip_info *chip_info;\n\tstruct adis adis;\n};\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic int adis16460_show_serial_number(void *arg, u64 *val)\n{\n\tstruct adis16460 *adis16460 = arg;\n\tu16 serial;\n\tint ret;\n\n\tret = adis_read_reg_16(&adis16460->adis, ADIS16460_REG_SERIAL_NUM,\n\t\t&serial);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = serial;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(adis16460_serial_number_fops,\n\t\tadis16460_show_serial_number, NULL, \"0x%.4llx\\n\");\n\nstatic int adis16460_show_product_id(void *arg, u64 *val)\n{\n\tstruct adis16460 *adis16460 = arg;\n\tu16 prod_id;\n\tint ret;\n\n\tret = adis_read_reg_16(&adis16460->adis, ADIS16460_REG_PROD_ID,\n\t\t&prod_id);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = prod_id;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(adis16460_product_id_fops,\n\t\tadis16460_show_product_id, NULL, \"%llu\\n\");\n\nstatic int adis16460_show_flash_count(void *arg, u64 *val)\n{\n\tstruct adis16460 *adis16460 = arg;\n\tu32 flash_count;\n\tint ret;\n\n\tret = adis_read_reg_32(&adis16460->adis, ADIS16460_REG_FLASH_CNT,\n\t\t&flash_count);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = flash_count;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(adis16460_flash_count_fops,\n\t\tadis16460_show_flash_count, NULL, \"%lld\\n\");\n\nstatic int adis16460_debugfs_init(struct iio_dev *indio_dev)\n{\n\tstruct adis16460 *adis16460 = iio_priv(indio_dev);\n\tstruct dentry *d = iio_get_debugfs_dentry(indio_dev);\n\n\tdebugfs_create_file_unsafe(\"serial_number\", 0400,\n\t\t\td, adis16460, &adis16460_serial_number_fops);\n\tdebugfs_create_file_unsafe(\"product_id\", 0400,\n\t\t\td, adis16460, &adis16460_product_id_fops);\n\tdebugfs_create_file_unsafe(\"flash_count\", 0400,\n\t\t\td, adis16460, &adis16460_flash_count_fops);\n\n\treturn 0;\n}\n\n#else\n\nstatic int adis16460_debugfs_init(struct iio_dev *indio_dev)\n{\n\treturn 0;\n}\n\n#endif\n\nstatic int adis16460_set_freq(struct iio_dev *indio_dev, int val, int val2)\n{\n\tstruct adis16460 *st = iio_priv(indio_dev);\n\tint t;\n\n\tt =  val * 1000 + val2 / 1000;\n\tif (t <= 0)\n\t\treturn -EINVAL;\n\n\tt = 2048000 / t;\n\tif (t > 2048)\n\t\tt = 2048;\n\n\tif (t != 0)\n\t\tt--;\n\n\treturn adis_write_reg_16(&st->adis, ADIS16460_REG_DEC_RATE, t);\n}\n\nstatic int adis16460_get_freq(struct iio_dev *indio_dev, int *val, int *val2)\n{\n\tstruct adis16460 *st = iio_priv(indio_dev);\n\tuint16_t t;\n\tint ret;\n\tunsigned int freq;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16460_REG_DEC_RATE, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tfreq = 2048000 / (t + 1);\n\t*val = freq / 1000;\n\t*val2 = (freq % 1000) * 1000;\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int adis16460_read_raw(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int *val, int *val2, long info)\n{\n\tstruct adis16460 *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn adis_single_conversion(indio_dev, chan, 0, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\t*val = st->chip_info->gyro_max_scale;\n\t\t\t*val2 = st->chip_info->gyro_max_val;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_ACCEL:\n\t\t\t*val = st->chip_info->accel_max_scale;\n\t\t\t*val2 = st->chip_info->accel_max_val;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_TEMP:\n\t\t\t*val = 50;  \n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = 500;  \n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn adis16460_get_freq(indio_dev, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adis16460_write_raw(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int val, int val2, long info)\n{\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn adis16460_set_freq(indio_dev, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nenum {\n\tADIS16460_SCAN_GYRO_X,\n\tADIS16460_SCAN_GYRO_Y,\n\tADIS16460_SCAN_GYRO_Z,\n\tADIS16460_SCAN_ACCEL_X,\n\tADIS16460_SCAN_ACCEL_Y,\n\tADIS16460_SCAN_ACCEL_Z,\n\tADIS16460_SCAN_TEMP,\n};\n\n#define ADIS16460_MOD_CHANNEL(_type, _mod, _address, _si, _bits) \\\n\t{ \\\n\t\t.type = (_type), \\\n\t\t.modified = 1, \\\n\t\t.channel2 = (_mod), \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t\t.address = (_address), \\\n\t\t.scan_index = (_si), \\\n\t\t.scan_type = { \\\n\t\t\t.sign = 's', \\\n\t\t\t.realbits = (_bits), \\\n\t\t\t.storagebits = (_bits), \\\n\t\t\t.endianness = IIO_BE, \\\n\t\t}, \\\n\t}\n\n#define ADIS16460_GYRO_CHANNEL(_mod) \\\n\tADIS16460_MOD_CHANNEL(IIO_ANGL_VEL, IIO_MOD_ ## _mod, \\\n\tADIS16460_REG_ ## _mod ## _GYRO_LOW, ADIS16460_SCAN_GYRO_ ## _mod, \\\n\t32)\n\n#define ADIS16460_ACCEL_CHANNEL(_mod) \\\n\tADIS16460_MOD_CHANNEL(IIO_ACCEL, IIO_MOD_ ## _mod, \\\n\tADIS16460_REG_ ## _mod ## _ACCL_LOW, ADIS16460_SCAN_ACCEL_ ## _mod, \\\n\t32)\n\n#define ADIS16460_TEMP_CHANNEL() { \\\n\t\t.type = IIO_TEMP, \\\n\t\t.indexed = 1, \\\n\t\t.channel = 0, \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) | \\\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET), \\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t\t.address = ADIS16460_REG_TEMP_OUT, \\\n\t\t.scan_index = ADIS16460_SCAN_TEMP, \\\n\t\t.scan_type = { \\\n\t\t\t.sign = 's', \\\n\t\t\t.realbits = 16, \\\n\t\t\t.storagebits = 16, \\\n\t\t\t.endianness = IIO_BE, \\\n\t\t}, \\\n\t}\n\nstatic const struct iio_chan_spec adis16460_channels[] = {\n\tADIS16460_GYRO_CHANNEL(X),\n\tADIS16460_GYRO_CHANNEL(Y),\n\tADIS16460_GYRO_CHANNEL(Z),\n\tADIS16460_ACCEL_CHANNEL(X),\n\tADIS16460_ACCEL_CHANNEL(Y),\n\tADIS16460_ACCEL_CHANNEL(Z),\n\tADIS16460_TEMP_CHANNEL(),\n\tIIO_CHAN_SOFT_TIMESTAMP(7)\n};\n\nstatic const struct adis16460_chip_info adis16460_chip_info = {\n\t.channels = adis16460_channels,\n\t.num_channels = ARRAY_SIZE(adis16460_channels),\n\t \n\t.gyro_max_val = IIO_RAD_TO_DEGREE(200 << 16),\n\t.gyro_max_scale = 1,\n\t.accel_max_val = IIO_M_S_2_TO_G(20000 << 16),\n\t.accel_max_scale = 5,\n};\n\nstatic const struct iio_info adis16460_info = {\n\t.read_raw = &adis16460_read_raw,\n\t.write_raw = &adis16460_write_raw,\n\t.update_scan_mode = adis_update_scan_mode,\n\t.debugfs_reg_access = adis_debugfs_reg_access,\n};\n\n#define ADIS16460_DIAG_STAT_IN_CLK_OOS\t7\n#define ADIS16460_DIAG_STAT_FLASH_MEM\t6\n#define ADIS16460_DIAG_STAT_SELF_TEST\t5\n#define ADIS16460_DIAG_STAT_OVERRANGE\t4\n#define ADIS16460_DIAG_STAT_SPI_COMM\t3\n#define ADIS16460_DIAG_STAT_FLASH_UPT\t2\n\nstatic const char * const adis16460_status_error_msgs[] = {\n\t[ADIS16460_DIAG_STAT_IN_CLK_OOS] = \"Input clock out of sync\",\n\t[ADIS16460_DIAG_STAT_FLASH_MEM] = \"Flash memory failure\",\n\t[ADIS16460_DIAG_STAT_SELF_TEST] = \"Self test diagnostic failure\",\n\t[ADIS16460_DIAG_STAT_OVERRANGE] = \"Sensor overrange\",\n\t[ADIS16460_DIAG_STAT_SPI_COMM] = \"SPI communication failure\",\n\t[ADIS16460_DIAG_STAT_FLASH_UPT] = \"Flash update failure\",\n};\n\nstatic const struct adis_timeout adis16460_timeouts = {\n\t.reset_ms = 225,\n\t.sw_reset_ms = 225,\n\t.self_test_ms = 10,\n};\n\nstatic const struct adis_data adis16460_data = {\n\t.diag_stat_reg = ADIS16460_REG_DIAG_STAT,\n\t.glob_cmd_reg = ADIS16460_REG_GLOB_CMD,\n\t.prod_id_reg = ADIS16460_REG_PROD_ID,\n\t.prod_id = 16460,\n\t.self_test_mask = BIT(2),\n\t.self_test_reg = ADIS16460_REG_GLOB_CMD,\n\t.has_paging = false,\n\t.read_delay = 5,\n\t.write_delay = 5,\n\t.cs_change_delay = 16,\n\t.status_error_msgs = adis16460_status_error_msgs,\n\t.status_error_mask = BIT(ADIS16460_DIAG_STAT_IN_CLK_OOS) |\n\t\tBIT(ADIS16460_DIAG_STAT_FLASH_MEM) |\n\t\tBIT(ADIS16460_DIAG_STAT_SELF_TEST) |\n\t\tBIT(ADIS16460_DIAG_STAT_OVERRANGE) |\n\t\tBIT(ADIS16460_DIAG_STAT_SPI_COMM) |\n\t\tBIT(ADIS16460_DIAG_STAT_FLASH_UPT),\n\t.unmasked_drdy = true,\n\t.timeouts = &adis16460_timeouts,\n};\n\nstatic int adis16460_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct adis16460 *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->chip_info = &adis16460_chip_info;\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->channels = st->chip_info->channels;\n\tindio_dev->num_channels = st->chip_info->num_channels;\n\tindio_dev->info = &adis16460_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = adis_init(&st->adis, indio_dev, spi, &adis16460_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_adis_setup_buffer_and_trigger(&st->adis, indio_dev, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __adis_initial_startup(&st->adis);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_device_register(&spi->dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tadis16460_debugfs_init(indio_dev);\n\n\treturn 0;\n}\n\nstatic const struct spi_device_id adis16460_ids[] = {\n\t{ \"adis16460\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, adis16460_ids);\n\nstatic const struct of_device_id adis16460_of_match[] = {\n\t{ .compatible = \"adi,adis16460\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, adis16460_of_match);\n\nstatic struct spi_driver adis16460_driver = {\n\t.driver = {\n\t\t.name = \"adis16460\",\n\t\t.of_match_table = adis16460_of_match,\n\t},\n\t.id_table = adis16460_ids,\n\t.probe = adis16460_probe,\n};\nmodule_spi_driver(adis16460_driver);\n\nMODULE_AUTHOR(\"Dragos Bogdan <dragos.bogdan@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADIS16460 IMU driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IIO_ADISLIB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}