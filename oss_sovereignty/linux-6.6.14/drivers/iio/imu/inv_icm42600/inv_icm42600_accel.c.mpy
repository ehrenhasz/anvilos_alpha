{
  "module_name": "inv_icm42600_accel.c",
  "hash_id": "3d81bdc7a960bc3735f1dc9a39ce65ed0e9a99b31a7ccabfe1d7b4acc505d5a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/inv_icm42600/inv_icm42600_accel.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n#include <linux/math64.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/common/inv_sensors_timestamp.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/kfifo_buf.h>\n\n#include \"inv_icm42600.h\"\n#include \"inv_icm42600_temp.h\"\n#include \"inv_icm42600_buffer.h\"\n\n#define INV_ICM42600_ACCEL_CHAN(_modifier, _index, _ext_info)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_ACCEL,\t\t\t\t\t\\\n\t\t.modified = 1,\t\t\t\t\t\t\\\n\t\t.channel2 = _modifier,\t\t\t\t\t\\\n\t\t.info_mask_separate =\t\t\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\t\t\t\\\n\t\t.info_mask_shared_by_type =\t\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\t\t\t\\\n\t\t.info_mask_shared_by_type_available =\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\t\t\t\\\n\t\t.info_mask_shared_by_all =\t\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t\\\n\t\t.info_mask_shared_by_all_available =\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t\\\n\t\t.scan_index = _index,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\t\\\n\t\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.ext_info = _ext_info,\t\t\t\t\t\\\n\t}\n\nenum inv_icm42600_accel_scan {\n\tINV_ICM42600_ACCEL_SCAN_X,\n\tINV_ICM42600_ACCEL_SCAN_Y,\n\tINV_ICM42600_ACCEL_SCAN_Z,\n\tINV_ICM42600_ACCEL_SCAN_TEMP,\n\tINV_ICM42600_ACCEL_SCAN_TIMESTAMP,\n};\n\nstatic const struct iio_chan_spec_ext_info inv_icm42600_accel_ext_infos[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_ALL, inv_icm42600_get_mount_matrix),\n\t{},\n};\n\nstatic const struct iio_chan_spec inv_icm42600_accel_channels[] = {\n\tINV_ICM42600_ACCEL_CHAN(IIO_MOD_X, INV_ICM42600_ACCEL_SCAN_X,\n\t\t\t\tinv_icm42600_accel_ext_infos),\n\tINV_ICM42600_ACCEL_CHAN(IIO_MOD_Y, INV_ICM42600_ACCEL_SCAN_Y,\n\t\t\t\tinv_icm42600_accel_ext_infos),\n\tINV_ICM42600_ACCEL_CHAN(IIO_MOD_Z, INV_ICM42600_ACCEL_SCAN_Z,\n\t\t\t\tinv_icm42600_accel_ext_infos),\n\tINV_ICM42600_TEMP_CHAN(INV_ICM42600_ACCEL_SCAN_TEMP),\n\tIIO_CHAN_SOFT_TIMESTAMP(INV_ICM42600_ACCEL_SCAN_TIMESTAMP),\n};\n\n \nstruct inv_icm42600_accel_buffer {\n\tstruct inv_icm42600_fifo_sensor_data accel;\n\tint16_t temp;\n\tint64_t timestamp __aligned(8);\n};\n\n#define INV_ICM42600_SCAN_MASK_ACCEL_3AXIS\t\t\t\t\\\n\t(BIT(INV_ICM42600_ACCEL_SCAN_X) |\t\t\t\t\\\n\tBIT(INV_ICM42600_ACCEL_SCAN_Y) |\t\t\t\t\\\n\tBIT(INV_ICM42600_ACCEL_SCAN_Z))\n\n#define INV_ICM42600_SCAN_MASK_TEMP\tBIT(INV_ICM42600_ACCEL_SCAN_TEMP)\n\nstatic const unsigned long inv_icm42600_accel_scan_masks[] = {\n\t \n\tINV_ICM42600_SCAN_MASK_ACCEL_3AXIS | INV_ICM42600_SCAN_MASK_TEMP,\n\t0,\n};\n\n \nstatic int inv_icm42600_accel_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t\t       const unsigned long *scan_mask)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tstruct inv_sensors_timestamp *ts = iio_priv(indio_dev);\n\tstruct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;\n\tunsigned int fifo_en = 0;\n\tunsigned int sleep_temp = 0;\n\tunsigned int sleep_accel = 0;\n\tunsigned int sleep;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tif (*scan_mask & INV_ICM42600_SCAN_MASK_TEMP) {\n\t\t \n\t\tret = inv_icm42600_set_temp_conf(st, true, &sleep_temp);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tfifo_en |= INV_ICM42600_SENSOR_TEMP;\n\t}\n\n\tif (*scan_mask & INV_ICM42600_SCAN_MASK_ACCEL_3AXIS) {\n\t\t \n\t\tconf.mode = INV_ICM42600_SENSOR_MODE_LOW_NOISE;\n\t\tret = inv_icm42600_set_accel_conf(st, &conf, &sleep_accel);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tfifo_en |= INV_ICM42600_SENSOR_ACCEL;\n\t}\n\n\t \n\tinv_sensors_timestamp_apply_odr(ts, 0, 0, 0);\n\tret = inv_icm42600_buffer_set_fifo_en(st, fifo_en | st->fifo.en);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = inv_icm42600_buffer_update_watermark(st);\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\t \n\tif (sleep_accel > sleep_temp)\n\t\tsleep = sleep_accel;\n\telse\n\t\tsleep = sleep_temp;\n\tif (sleep)\n\t\tmsleep(sleep);\n\treturn ret;\n}\n\nstatic int inv_icm42600_accel_read_sensor(struct inv_icm42600_state *st,\n\t\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t\t  int16_t *val)\n{\n\tstruct device *dev = regmap_get_device(st->map);\n\tstruct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;\n\tunsigned int reg;\n\t__be16 *data;\n\tint ret;\n\n\tif (chan->type != IIO_ACCEL)\n\t\treturn -EINVAL;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\treg = INV_ICM42600_REG_ACCEL_DATA_X;\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\treg = INV_ICM42600_REG_ACCEL_DATA_Y;\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\treg = INV_ICM42600_REG_ACCEL_DATA_Z;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_get_sync(dev);\n\tmutex_lock(&st->lock);\n\n\t \n\tconf.mode = INV_ICM42600_SENSOR_MODE_LOW_NOISE;\n\tret = inv_icm42600_set_accel_conf(st, &conf, NULL);\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tdata = (__be16 *)&st->buffer[0];\n\tret = regmap_bulk_read(st->map, reg, data, sizeof(*data));\n\tif (ret)\n\t\tgoto exit;\n\n\t*val = (int16_t)be16_to_cpup(data);\n\tif (*val == INV_ICM42600_DATA_INVALID)\n\t\tret = -EINVAL;\nexit:\n\tmutex_unlock(&st->lock);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\treturn ret;\n}\n\n \nstatic const int inv_icm42600_accel_scale[] = {\n\t \n\t[2 * INV_ICM42600_ACCEL_FS_16G] = 0,\n\t[2 * INV_ICM42600_ACCEL_FS_16G + 1] = 4788403,\n\t \n\t[2 * INV_ICM42600_ACCEL_FS_8G] = 0,\n\t[2 * INV_ICM42600_ACCEL_FS_8G + 1] = 2394202,\n\t \n\t[2 * INV_ICM42600_ACCEL_FS_4G] = 0,\n\t[2 * INV_ICM42600_ACCEL_FS_4G + 1] = 1197101,\n\t \n\t[2 * INV_ICM42600_ACCEL_FS_2G] = 0,\n\t[2 * INV_ICM42600_ACCEL_FS_2G + 1] = 598550,\n};\n\nstatic int inv_icm42600_accel_read_scale(struct inv_icm42600_state *st,\n\t\t\t\t\t int *val, int *val2)\n{\n\tunsigned int idx;\n\n\tidx = st->conf.accel.fs;\n\n\t*val = inv_icm42600_accel_scale[2 * idx];\n\t*val2 = inv_icm42600_accel_scale[2 * idx + 1];\n\treturn IIO_VAL_INT_PLUS_NANO;\n}\n\nstatic int inv_icm42600_accel_write_scale(struct inv_icm42600_state *st,\n\t\t\t\t\t  int val, int val2)\n{\n\tstruct device *dev = regmap_get_device(st->map);\n\tunsigned int idx;\n\tstruct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;\n\tint ret;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(inv_icm42600_accel_scale); idx += 2) {\n\t\tif (val == inv_icm42600_accel_scale[idx] &&\n\t\t    val2 == inv_icm42600_accel_scale[idx + 1])\n\t\t\tbreak;\n\t}\n\tif (idx >= ARRAY_SIZE(inv_icm42600_accel_scale))\n\t\treturn -EINVAL;\n\n\tconf.fs = idx / 2;\n\n\tpm_runtime_get_sync(dev);\n\tmutex_lock(&st->lock);\n\n\tret = inv_icm42600_set_accel_conf(st, &conf, NULL);\n\n\tmutex_unlock(&st->lock);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\n \nstatic const int inv_icm42600_accel_odr[] = {\n\t \n\t12, 500000,\n\t \n\t25, 0,\n\t \n\t50, 0,\n\t \n\t100, 0,\n\t \n\t200, 0,\n\t \n\t1000, 0,\n\t \n\t2000, 0,\n\t \n\t4000, 0,\n};\n\nstatic const int inv_icm42600_accel_odr_conv[] = {\n\tINV_ICM42600_ODR_12_5HZ,\n\tINV_ICM42600_ODR_25HZ,\n\tINV_ICM42600_ODR_50HZ,\n\tINV_ICM42600_ODR_100HZ,\n\tINV_ICM42600_ODR_200HZ,\n\tINV_ICM42600_ODR_1KHZ_LN,\n\tINV_ICM42600_ODR_2KHZ_LN,\n\tINV_ICM42600_ODR_4KHZ_LN,\n};\n\nstatic int inv_icm42600_accel_read_odr(struct inv_icm42600_state *st,\n\t\t\t\t       int *val, int *val2)\n{\n\tunsigned int odr;\n\tunsigned int i;\n\n\todr = st->conf.accel.odr;\n\n\tfor (i = 0; i < ARRAY_SIZE(inv_icm42600_accel_odr_conv); ++i) {\n\t\tif (inv_icm42600_accel_odr_conv[i] == odr)\n\t\t\tbreak;\n\t}\n\tif (i >= ARRAY_SIZE(inv_icm42600_accel_odr_conv))\n\t\treturn -EINVAL;\n\n\t*val = inv_icm42600_accel_odr[2 * i];\n\t*val2 = inv_icm42600_accel_odr[2 * i + 1];\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int inv_icm42600_accel_write_odr(struct iio_dev *indio_dev,\n\t\t\t\t\tint val, int val2)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tstruct inv_sensors_timestamp *ts = iio_priv(indio_dev);\n\tstruct device *dev = regmap_get_device(st->map);\n\tunsigned int idx;\n\tstruct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;\n\tint ret;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(inv_icm42600_accel_odr); idx += 2) {\n\t\tif (val == inv_icm42600_accel_odr[idx] &&\n\t\t    val2 == inv_icm42600_accel_odr[idx + 1])\n\t\t\tbreak;\n\t}\n\tif (idx >= ARRAY_SIZE(inv_icm42600_accel_odr))\n\t\treturn -EINVAL;\n\n\tconf.odr = inv_icm42600_accel_odr_conv[idx / 2];\n\n\tpm_runtime_get_sync(dev);\n\tmutex_lock(&st->lock);\n\n\tret = inv_sensors_timestamp_update_odr(ts, inv_icm42600_odr_to_period(conf.odr),\n\t\t\t\t\t       iio_buffer_enabled(indio_dev));\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = inv_icm42600_set_accel_conf(st, &conf, NULL);\n\tif (ret)\n\t\tgoto out_unlock;\n\tinv_icm42600_buffer_update_fifo_period(st);\n\tinv_icm42600_buffer_update_watermark(st);\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\n \nstatic int inv_icm42600_accel_calibbias[] = {\n\t-10, 42010,\t\t \n\t0, 4903,\t\t \n\t10, 37106,\t\t \n};\n\nstatic int inv_icm42600_accel_read_offset(struct inv_icm42600_state *st,\n\t\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t\t  int *val, int *val2)\n{\n\tstruct device *dev = regmap_get_device(st->map);\n\tint64_t val64;\n\tint32_t bias;\n\tunsigned int reg;\n\tint16_t offset;\n\tuint8_t data[2];\n\tint ret;\n\n\tif (chan->type != IIO_ACCEL)\n\t\treturn -EINVAL;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\treg = INV_ICM42600_REG_OFFSET_USER4;\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\treg = INV_ICM42600_REG_OFFSET_USER6;\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\treg = INV_ICM42600_REG_OFFSET_USER7;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_get_sync(dev);\n\tmutex_lock(&st->lock);\n\n\tret = regmap_bulk_read(st->map, reg, st->buffer, sizeof(data));\n\tmemcpy(data, st->buffer, sizeof(data));\n\n\tmutex_unlock(&st->lock);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\toffset = sign_extend32(((data[0] & 0xF0) << 4) | data[1], 11);\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\toffset = sign_extend32(((data[1] & 0x0F) << 8) | data[0], 11);\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\toffset = sign_extend32(((data[0] & 0xF0) << 4) | data[1], 11);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval64 = (int64_t)offset * 5LL * 9806650LL;\n\t \n\tif (val64 >= 0)\n\t\tval64 += 10000LL / 2LL;\n\telse\n\t\tval64 -= 10000LL / 2LL;\n\tbias = div_s64(val64, 10000L);\n\t*val = bias / 1000000L;\n\t*val2 = bias % 1000000L;\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int inv_icm42600_accel_write_offset(struct inv_icm42600_state *st,\n\t\t\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t\t\t   int val, int val2)\n{\n\tstruct device *dev = regmap_get_device(st->map);\n\tint64_t val64;\n\tint32_t min, max;\n\tunsigned int reg, regval;\n\tint16_t offset;\n\tint ret;\n\n\tif (chan->type != IIO_ACCEL)\n\t\treturn -EINVAL;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\treg = INV_ICM42600_REG_OFFSET_USER4;\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\treg = INV_ICM42600_REG_OFFSET_USER6;\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\treg = INV_ICM42600_REG_OFFSET_USER7;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmin = inv_icm42600_accel_calibbias[0] * 1000000L +\n\t      inv_icm42600_accel_calibbias[1];\n\tmax = inv_icm42600_accel_calibbias[4] * 1000000L +\n\t      inv_icm42600_accel_calibbias[5];\n\tval64 = (int64_t)val * 1000000LL + (int64_t)val2;\n\tif (val64 < min || val64 > max)\n\t\treturn -EINVAL;\n\n\t \n\tval64 = val64 * 10000LL;\n\t \n\tif (val64 >= 0)\n\t\tval64 += 9806650 * 5 / 2;\n\telse\n\t\tval64 -= 9806650 * 5 / 2;\n\toffset = div_s64(val64, 9806650 * 5);\n\n\t \n\tif (offset < -2048)\n\t\toffset = -2048;\n\telse if (offset > 2047)\n\t\toffset = 2047;\n\n\tpm_runtime_get_sync(dev);\n\tmutex_lock(&st->lock);\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\t \n\t\tret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER4,\n\t\t\t\t  &regval);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tst->buffer[0] = ((offset & 0xF00) >> 4) | (regval & 0x0F);\n\t\tst->buffer[1] = offset & 0xFF;\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\t \n\t\tret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER7,\n\t\t\t\t  &regval);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tst->buffer[0] = offset & 0xFF;\n\t\tst->buffer[1] = ((offset & 0xF00) >> 8) | (regval & 0xF0);\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\t \n\t\tret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER7,\n\t\t\t\t  &regval);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tst->buffer[0] = ((offset & 0xF00) >> 4) | (regval & 0x0F);\n\t\tst->buffer[1] = offset & 0xFF;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = regmap_bulk_write(st->map, reg, st->buffer, 2);\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\treturn ret;\n}\n\nstatic int inv_icm42600_accel_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t\t       int *val, int *val2, long mask)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tint16_t data;\n\tint ret;\n\n\tswitch (chan->type) {\n\tcase IIO_ACCEL:\n\t\tbreak;\n\tcase IIO_TEMP:\n\t\treturn inv_icm42600_temp_read_raw(indio_dev, chan, val, val2, mask);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = inv_icm42600_accel_read_sensor(st, chan, &data);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*val = data;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn inv_icm42600_accel_read_scale(st, val, val2);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn inv_icm42600_accel_read_odr(st, val, val2);\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treturn inv_icm42600_accel_read_offset(st, chan, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int inv_icm42600_accel_read_avail(struct iio_dev *indio_dev,\n\t\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t\t const int **vals,\n\t\t\t\t\t int *type, int *length, long mask)\n{\n\tif (chan->type != IIO_ACCEL)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*vals = inv_icm42600_accel_scale;\n\t\t*type = IIO_VAL_INT_PLUS_NANO;\n\t\t*length = ARRAY_SIZE(inv_icm42600_accel_scale);\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*vals = inv_icm42600_accel_odr;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t*length = ARRAY_SIZE(inv_icm42600_accel_odr);\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\t*vals = inv_icm42600_accel_calibbias;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\treturn IIO_AVAIL_RANGE;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int inv_icm42600_accel_write_raw(struct iio_dev *indio_dev,\n\t\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\t\tint val, int val2, long mask)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tint ret;\n\n\tif (chan->type != IIO_ACCEL)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = inv_icm42600_accel_write_scale(st, val, val2);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn inv_icm42600_accel_write_odr(indio_dev, val, val2);\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = inv_icm42600_accel_write_offset(st, chan, val, val2);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int inv_icm42600_accel_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\t\t\tlong mask)\n{\n\tif (chan->type != IIO_ACCEL)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int inv_icm42600_accel_hwfifo_set_watermark(struct iio_dev *indio_dev,\n\t\t\t\t\t\t   unsigned int val)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tst->fifo.watermark.accel = val;\n\tret = inv_icm42600_buffer_update_watermark(st);\n\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int inv_icm42600_accel_hwfifo_flush(struct iio_dev *indio_dev,\n\t\t\t\t\t   unsigned int count)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tint ret;\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tmutex_lock(&st->lock);\n\n\tret = inv_icm42600_buffer_hwfifo_flush(st, count);\n\tif (!ret)\n\t\tret = st->fifo.nb.accel;\n\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_info inv_icm42600_accel_info = {\n\t.read_raw = inv_icm42600_accel_read_raw,\n\t.read_avail = inv_icm42600_accel_read_avail,\n\t.write_raw = inv_icm42600_accel_write_raw,\n\t.write_raw_get_fmt = inv_icm42600_accel_write_raw_get_fmt,\n\t.debugfs_reg_access = inv_icm42600_debugfs_reg,\n\t.update_scan_mode = inv_icm42600_accel_update_scan_mode,\n\t.hwfifo_set_watermark = inv_icm42600_accel_hwfifo_set_watermark,\n\t.hwfifo_flush_to_buffer = inv_icm42600_accel_hwfifo_flush,\n};\n\nstruct iio_dev *inv_icm42600_accel_init(struct inv_icm42600_state *st)\n{\n\tstruct device *dev = regmap_get_device(st->map);\n\tconst char *name;\n\tstruct inv_sensors_timestamp_chip ts_chip;\n\tstruct inv_sensors_timestamp *ts;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tname = devm_kasprintf(dev, GFP_KERNEL, \"%s-accel\", st->name);\n\tif (!name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*ts));\n\tif (!indio_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tts_chip.clock_period = 31250;\n\tts_chip.jitter = 20;\n\tts_chip.init_period = inv_icm42600_odr_to_period(st->conf.accel.odr);\n\tts = iio_priv(indio_dev);\n\tinv_sensors_timestamp_init(ts, &ts_chip);\n\n\tiio_device_set_drvdata(indio_dev, st);\n\tindio_dev->name = name;\n\tindio_dev->info = &inv_icm42600_accel_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = inv_icm42600_accel_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(inv_icm42600_accel_channels);\n\tindio_dev->available_scan_masks = inv_icm42600_accel_scan_masks;\n\n\tret = devm_iio_kfifo_buffer_setup(dev, indio_dev,\n\t\t\t\t\t  &inv_icm42600_buffer_ops);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn indio_dev;\n}\n\nint inv_icm42600_accel_parse_fifo(struct iio_dev *indio_dev)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tstruct inv_sensors_timestamp *ts = iio_priv(indio_dev);\n\tssize_t i, size;\n\tunsigned int no;\n\tconst void *accel, *gyro, *timestamp;\n\tconst int8_t *temp;\n\tunsigned int odr;\n\tint64_t ts_val;\n\tstruct inv_icm42600_accel_buffer buffer;\n\n\t \n\tfor (i = 0, no = 0; i < st->fifo.count; i += size, ++no) {\n\t\tsize = inv_icm42600_fifo_decode_packet(&st->fifo.data[i],\n\t\t\t\t&accel, &gyro, &temp, &timestamp, &odr);\n\t\t \n\t\tif (size <= 0)\n\t\t\treturn size;\n\n\t\t \n\t\tif (accel == NULL || !inv_icm42600_fifo_is_data_valid(accel))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (odr & INV_ICM42600_SENSOR_ACCEL)\n\t\t\tinv_sensors_timestamp_apply_odr(ts, st->fifo.period,\n\t\t\t\t\t\t\tst->fifo.nb.total, no);\n\n\t\t \n\t\tmemset(&buffer, 0, sizeof(buffer));\n\t\tmemcpy(&buffer.accel, accel, sizeof(buffer.accel));\n\t\t \n\t\tbuffer.temp = temp ? (*temp * 64) : 0;\n\t\tts_val = inv_sensors_timestamp_pop(ts);\n\t\tiio_push_to_buffers_with_timestamp(indio_dev, &buffer, ts_val);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}