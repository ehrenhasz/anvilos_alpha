{
  "module_name": "inv_icm42600_core.c",
  "hash_id": "4767acf492096b64621af018d13353b537b1b444f31a51fd4e7adae6dd4ca01d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/inv_icm42600/inv_icm42600_core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\n#include <linux/iio/iio.h>\n\n#include \"inv_icm42600.h\"\n#include \"inv_icm42600_buffer.h\"\n\nstatic const struct regmap_range_cfg inv_icm42600_regmap_ranges[] = {\n\t{\n\t\t.name = \"user banks\",\n\t\t.range_min = 0x0000,\n\t\t.range_max = 0x4FFF,\n\t\t.selector_reg = INV_ICM42600_REG_BANK_SEL,\n\t\t.selector_mask = INV_ICM42600_BANK_SEL_MASK,\n\t\t.selector_shift = 0,\n\t\t.window_start = 0,\n\t\t.window_len = 0x1000,\n\t},\n};\n\nconst struct regmap_config inv_icm42600_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x4FFF,\n\t.ranges = inv_icm42600_regmap_ranges,\n\t.num_ranges = ARRAY_SIZE(inv_icm42600_regmap_ranges),\n};\nEXPORT_SYMBOL_NS_GPL(inv_icm42600_regmap_config, IIO_ICM42600);\n\nstruct inv_icm42600_hw {\n\tuint8_t whoami;\n\tconst char *name;\n\tconst struct inv_icm42600_conf *conf;\n};\n\n \nstatic const struct inv_icm42600_conf inv_icm42600_default_conf = {\n\t.gyro = {\n\t\t.mode = INV_ICM42600_SENSOR_MODE_OFF,\n\t\t.fs = INV_ICM42600_GYRO_FS_2000DPS,\n\t\t.odr = INV_ICM42600_ODR_50HZ,\n\t\t.filter = INV_ICM42600_FILTER_BW_ODR_DIV_2,\n\t},\n\t.accel = {\n\t\t.mode = INV_ICM42600_SENSOR_MODE_OFF,\n\t\t.fs = INV_ICM42600_ACCEL_FS_16G,\n\t\t.odr = INV_ICM42600_ODR_50HZ,\n\t\t.filter = INV_ICM42600_FILTER_BW_ODR_DIV_2,\n\t},\n\t.temp_en = false,\n};\n\nstatic const struct inv_icm42600_hw inv_icm42600_hw[INV_CHIP_NB] = {\n\t[INV_CHIP_ICM42600] = {\n\t\t.whoami = INV_ICM42600_WHOAMI_ICM42600,\n\t\t.name = \"icm42600\",\n\t\t.conf = &inv_icm42600_default_conf,\n\t},\n\t[INV_CHIP_ICM42602] = {\n\t\t.whoami = INV_ICM42600_WHOAMI_ICM42602,\n\t\t.name = \"icm42602\",\n\t\t.conf = &inv_icm42600_default_conf,\n\t},\n\t[INV_CHIP_ICM42605] = {\n\t\t.whoami = INV_ICM42600_WHOAMI_ICM42605,\n\t\t.name = \"icm42605\",\n\t\t.conf = &inv_icm42600_default_conf,\n\t},\n\t[INV_CHIP_ICM42622] = {\n\t\t.whoami = INV_ICM42600_WHOAMI_ICM42622,\n\t\t.name = \"icm42622\",\n\t\t.conf = &inv_icm42600_default_conf,\n\t},\n\t[INV_CHIP_ICM42631] = {\n\t\t.whoami = INV_ICM42600_WHOAMI_ICM42631,\n\t\t.name = \"icm42631\",\n\t\t.conf = &inv_icm42600_default_conf,\n\t},\n};\n\nconst struct iio_mount_matrix *\ninv_icm42600_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\t      const struct iio_chan_spec *chan)\n{\n\tconst struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\n\treturn &st->orientation;\n}\n\nuint32_t inv_icm42600_odr_to_period(enum inv_icm42600_odr odr)\n{\n\tstatic uint32_t odr_periods[INV_ICM42600_ODR_NB] = {\n\t\t \n\t\t0, 0, 0,\n\t\t \n\t\t125000,\n\t\t \n\t\t250000,\n\t\t \n\t\t500000,\n\t\t \n\t\t1000000,\n\t\t \n\t\t5000000,\n\t\t \n\t\t10000000,\n\t\t \n\t\t20000000,\n\t\t \n\t\t40000000,\n\t\t \n\t\t80000000,\n\t\t \n\t\t160000000,\n\t\t \n\t\t320000000,\n\t\t \n\t\t640000000,\n\t\t \n\t\t2000000,\n\t};\n\n\treturn odr_periods[odr];\n}\n\nstatic int inv_icm42600_set_pwr_mgmt0(struct inv_icm42600_state *st,\n\t\t\t\t      enum inv_icm42600_sensor_mode gyro,\n\t\t\t\t      enum inv_icm42600_sensor_mode accel,\n\t\t\t\t      bool temp, unsigned int *sleep_ms)\n{\n\tenum inv_icm42600_sensor_mode oldgyro = st->conf.gyro.mode;\n\tenum inv_icm42600_sensor_mode oldaccel = st->conf.accel.mode;\n\tbool oldtemp = st->conf.temp_en;\n\tunsigned int sleepval;\n\tunsigned int val;\n\tint ret;\n\n\t \n\tif (gyro == oldgyro && accel == oldaccel && temp == oldtemp)\n\t\treturn 0;\n\n\tval = INV_ICM42600_PWR_MGMT0_GYRO(gyro) |\n\t      INV_ICM42600_PWR_MGMT0_ACCEL(accel);\n\tif (!temp)\n\t\tval |= INV_ICM42600_PWR_MGMT0_TEMP_DIS;\n\tret = regmap_write(st->map, INV_ICM42600_REG_PWR_MGMT0, val);\n\tif (ret)\n\t\treturn ret;\n\n\tst->conf.gyro.mode = gyro;\n\tst->conf.accel.mode = accel;\n\tst->conf.temp_en = temp;\n\n\t \n\tsleepval = 0;\n\t \n\tif (temp && !oldtemp) {\n\t\tif (sleepval < INV_ICM42600_TEMP_STARTUP_TIME_MS)\n\t\t\tsleepval = INV_ICM42600_TEMP_STARTUP_TIME_MS;\n\t}\n\t \n\tif (accel != oldaccel && oldaccel == INV_ICM42600_SENSOR_MODE_OFF) {\n\t\t \n\t\tusleep_range(200, 300);\n\t\tif (sleepval < INV_ICM42600_ACCEL_STARTUP_TIME_MS)\n\t\t\tsleepval = INV_ICM42600_ACCEL_STARTUP_TIME_MS;\n\t}\n\tif (gyro != oldgyro) {\n\t\t \n\t\tif (oldgyro == INV_ICM42600_SENSOR_MODE_OFF) {\n\t\t\t \n\t\t\tusleep_range(200, 300);\n\t\t\tif (sleepval < INV_ICM42600_GYRO_STARTUP_TIME_MS)\n\t\t\t\tsleepval = INV_ICM42600_GYRO_STARTUP_TIME_MS;\n\t\t \n\t\t} else if (gyro == INV_ICM42600_SENSOR_MODE_OFF) {\n\t\t\tif (sleepval < INV_ICM42600_GYRO_STOP_TIME_MS)\n\t\t\t\tsleepval =  INV_ICM42600_GYRO_STOP_TIME_MS;\n\t\t}\n\t}\n\n\t \n\tif (sleep_ms)\n\t\t*sleep_ms = sleepval;\n\telse if (sleepval)\n\t\tmsleep(sleepval);\n\n\treturn 0;\n}\n\nint inv_icm42600_set_accel_conf(struct inv_icm42600_state *st,\n\t\t\t\tstruct inv_icm42600_sensor_conf *conf,\n\t\t\t\tunsigned int *sleep_ms)\n{\n\tstruct inv_icm42600_sensor_conf *oldconf = &st->conf.accel;\n\tunsigned int val;\n\tint ret;\n\n\t \n\tif (conf->mode < 0)\n\t\tconf->mode = oldconf->mode;\n\tif (conf->fs < 0)\n\t\tconf->fs = oldconf->fs;\n\tif (conf->odr < 0)\n\t\tconf->odr = oldconf->odr;\n\tif (conf->filter < 0)\n\t\tconf->filter = oldconf->filter;\n\n\t \n\tif (conf->fs != oldconf->fs || conf->odr != oldconf->odr) {\n\t\tval = INV_ICM42600_ACCEL_CONFIG0_FS(conf->fs) |\n\t\t      INV_ICM42600_ACCEL_CONFIG0_ODR(conf->odr);\n\t\tret = regmap_write(st->map, INV_ICM42600_REG_ACCEL_CONFIG0, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\toldconf->fs = conf->fs;\n\t\toldconf->odr = conf->odr;\n\t}\n\n\t \n\tif (conf->filter != oldconf->filter) {\n\t\tval = INV_ICM42600_GYRO_ACCEL_CONFIG0_ACCEL_FILT(conf->filter) |\n\t\t      INV_ICM42600_GYRO_ACCEL_CONFIG0_GYRO_FILT(st->conf.gyro.filter);\n\t\tret = regmap_write(st->map, INV_ICM42600_REG_GYRO_ACCEL_CONFIG0, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\toldconf->filter = conf->filter;\n\t}\n\n\t \n\treturn inv_icm42600_set_pwr_mgmt0(st, st->conf.gyro.mode, conf->mode,\n\t\t\t\t\t  st->conf.temp_en, sleep_ms);\n}\n\nint inv_icm42600_set_gyro_conf(struct inv_icm42600_state *st,\n\t\t\t       struct inv_icm42600_sensor_conf *conf,\n\t\t\t       unsigned int *sleep_ms)\n{\n\tstruct inv_icm42600_sensor_conf *oldconf = &st->conf.gyro;\n\tunsigned int val;\n\tint ret;\n\n\t \n\tif (conf->mode < 0)\n\t\tconf->mode = oldconf->mode;\n\tif (conf->fs < 0)\n\t\tconf->fs = oldconf->fs;\n\tif (conf->odr < 0)\n\t\tconf->odr = oldconf->odr;\n\tif (conf->filter < 0)\n\t\tconf->filter = oldconf->filter;\n\n\t \n\tif (conf->fs != oldconf->fs || conf->odr != oldconf->odr) {\n\t\tval = INV_ICM42600_GYRO_CONFIG0_FS(conf->fs) |\n\t\t      INV_ICM42600_GYRO_CONFIG0_ODR(conf->odr);\n\t\tret = regmap_write(st->map, INV_ICM42600_REG_GYRO_CONFIG0, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\toldconf->fs = conf->fs;\n\t\toldconf->odr = conf->odr;\n\t}\n\n\t \n\tif (conf->filter != oldconf->filter) {\n\t\tval = INV_ICM42600_GYRO_ACCEL_CONFIG0_ACCEL_FILT(st->conf.accel.filter) |\n\t\t      INV_ICM42600_GYRO_ACCEL_CONFIG0_GYRO_FILT(conf->filter);\n\t\tret = regmap_write(st->map, INV_ICM42600_REG_GYRO_ACCEL_CONFIG0, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\toldconf->filter = conf->filter;\n\t}\n\n\t \n\treturn inv_icm42600_set_pwr_mgmt0(st, conf->mode, st->conf.accel.mode,\n\t\t\t\t\t  st->conf.temp_en, sleep_ms);\n\n\treturn 0;\n}\n\nint inv_icm42600_set_temp_conf(struct inv_icm42600_state *st, bool enable,\n\t\t\t       unsigned int *sleep_ms)\n{\n\treturn inv_icm42600_set_pwr_mgmt0(st, st->conf.gyro.mode,\n\t\t\t\t\t  st->conf.accel.mode, enable,\n\t\t\t\t\t  sleep_ms);\n}\n\nint inv_icm42600_debugfs_reg(struct iio_dev *indio_dev, unsigned int reg,\n\t\t\t     unsigned int writeval, unsigned int *readval)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tif (readval)\n\t\tret = regmap_read(st->map, reg, readval);\n\telse\n\t\tret = regmap_write(st->map, reg, writeval);\n\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int inv_icm42600_set_conf(struct inv_icm42600_state *st,\n\t\t\t\t const struct inv_icm42600_conf *conf)\n{\n\tunsigned int val;\n\tint ret;\n\n\t \n\tval = INV_ICM42600_PWR_MGMT0_GYRO(conf->gyro.mode) |\n\t      INV_ICM42600_PWR_MGMT0_ACCEL(conf->accel.mode);\n\tif (!conf->temp_en)\n\t\tval |= INV_ICM42600_PWR_MGMT0_TEMP_DIS;\n\tret = regmap_write(st->map, INV_ICM42600_REG_PWR_MGMT0, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = INV_ICM42600_GYRO_CONFIG0_FS(conf->gyro.fs) |\n\t      INV_ICM42600_GYRO_CONFIG0_ODR(conf->gyro.odr);\n\tret = regmap_write(st->map, INV_ICM42600_REG_GYRO_CONFIG0, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = INV_ICM42600_ACCEL_CONFIG0_FS(conf->accel.fs) |\n\t      INV_ICM42600_ACCEL_CONFIG0_ODR(conf->accel.odr);\n\tret = regmap_write(st->map, INV_ICM42600_REG_ACCEL_CONFIG0, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = INV_ICM42600_GYRO_ACCEL_CONFIG0_ACCEL_FILT(conf->accel.filter) |\n\t      INV_ICM42600_GYRO_ACCEL_CONFIG0_GYRO_FILT(conf->gyro.filter);\n\tret = regmap_write(st->map, INV_ICM42600_REG_GYRO_ACCEL_CONFIG0, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tst->conf = *conf;\n\n\treturn 0;\n}\n\n \nstatic int inv_icm42600_setup(struct inv_icm42600_state *st,\n\t\t\t      inv_icm42600_bus_setup bus_setup)\n{\n\tconst struct inv_icm42600_hw *hw = &inv_icm42600_hw[st->chip];\n\tconst struct device *dev = regmap_get_device(st->map);\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_read(st->map, INV_ICM42600_REG_WHOAMI, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val != hw->whoami) {\n\t\tdev_err(dev, \"invalid whoami %#02x expected %#02x (%s)\\n\",\n\t\t\tval, hw->whoami, hw->name);\n\t\treturn -ENODEV;\n\t}\n\tst->name = hw->name;\n\n\t \n\tret = regmap_write(st->map, INV_ICM42600_REG_DEVICE_CONFIG,\n\t\t\t   INV_ICM42600_DEVICE_CONFIG_SOFT_RESET);\n\tif (ret)\n\t\treturn ret;\n\tmsleep(INV_ICM42600_RESET_TIME_MS);\n\n\tret = regmap_read(st->map, INV_ICM42600_REG_INT_STATUS, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (!(val & INV_ICM42600_INT_STATUS_RESET_DONE)) {\n\t\tdev_err(dev, \"reset error, reset done bit not set\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = bus_setup(st);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(st->map, INV_ICM42600_REG_INTF_CONFIG0,\n\t\t\t\t INV_ICM42600_INTF_CONFIG0_SENSOR_DATA_ENDIAN,\n\t\t\t\t INV_ICM42600_INTF_CONFIG0_SENSOR_DATA_ENDIAN);\n\tif (ret)\n\t\treturn ret;\n\n\treturn inv_icm42600_set_conf(st, hw->conf);\n}\n\nstatic irqreturn_t inv_icm42600_irq_timestamp(int irq, void *_data)\n{\n\tstruct inv_icm42600_state *st = _data;\n\n\tst->timestamp.gyro = iio_get_time_ns(st->indio_gyro);\n\tst->timestamp.accel = iio_get_time_ns(st->indio_accel);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t inv_icm42600_irq_handler(int irq, void *_data)\n{\n\tstruct inv_icm42600_state *st = _data;\n\tstruct device *dev = regmap_get_device(st->map);\n\tunsigned int status;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = regmap_read(st->map, INV_ICM42600_REG_INT_STATUS, &status);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tif (status & INV_ICM42600_INT_STATUS_FIFO_FULL)\n\t\tdev_warn(dev, \"FIFO full data lost!\\n\");\n\n\t \n\tif (status & INV_ICM42600_INT_STATUS_FIFO_THS) {\n\t\tret = inv_icm42600_buffer_fifo_read(st, 0);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"FIFO read error %d\\n\", ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tret = inv_icm42600_buffer_fifo_parse(st);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"FIFO parsing error %d\\n\", ret);\n\t}\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int inv_icm42600_irq_init(struct inv_icm42600_state *st, int irq,\n\t\t\t\t int irq_type, bool open_drain)\n{\n\tstruct device *dev = regmap_get_device(st->map);\n\tunsigned int val;\n\tint ret;\n\n\t \n\tswitch (irq_type) {\n\tcase IRQF_TRIGGER_RISING:\n\tcase IRQF_TRIGGER_HIGH:\n\t\tval = INV_ICM42600_INT_CONFIG_INT1_ACTIVE_HIGH;\n\t\tbreak;\n\tdefault:\n\t\tval = INV_ICM42600_INT_CONFIG_INT1_ACTIVE_LOW;\n\t\tbreak;\n\t}\n\n\tswitch (irq_type) {\n\tcase IRQF_TRIGGER_LOW:\n\tcase IRQF_TRIGGER_HIGH:\n\t\tval |= INV_ICM42600_INT_CONFIG_INT1_LATCHED;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!open_drain)\n\t\tval |= INV_ICM42600_INT_CONFIG_INT1_PUSH_PULL;\n\n\tret = regmap_write(st->map, INV_ICM42600_REG_INT_CONFIG, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(st->map, INV_ICM42600_REG_INT_CONFIG1,\n\t\t\t\t INV_ICM42600_INT_CONFIG1_ASYNC_RESET, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_request_threaded_irq(dev, irq, inv_icm42600_irq_timestamp,\n\t\t\t\t\t inv_icm42600_irq_handler, irq_type,\n\t\t\t\t\t \"inv_icm42600\", st);\n}\n\nstatic int inv_icm42600_timestamp_setup(struct inv_icm42600_state *st)\n{\n\tunsigned int val;\n\n\t \n\tval = INV_ICM42600_TMST_CONFIG_TMST_TO_REGS_EN |\n\t      INV_ICM42600_TMST_CONFIG_TMST_EN;\n\treturn regmap_update_bits(st->map, INV_ICM42600_REG_TMST_CONFIG,\n\t\t\t\t  INV_ICM42600_TMST_CONFIG_MASK, val);\n}\n\nstatic int inv_icm42600_enable_regulator_vddio(struct inv_icm42600_state *st)\n{\n\tint ret;\n\n\tret = regulator_enable(st->vddio_supply);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(3000, 4000);\n\n\treturn 0;\n}\n\nstatic void inv_icm42600_disable_vdd_reg(void *_data)\n{\n\tstruct inv_icm42600_state *st = _data;\n\tconst struct device *dev = regmap_get_device(st->map);\n\tint ret;\n\n\tret = regulator_disable(st->vdd_supply);\n\tif (ret)\n\t\tdev_err(dev, \"failed to disable vdd error %d\\n\", ret);\n}\n\nstatic void inv_icm42600_disable_vddio_reg(void *_data)\n{\n\tstruct inv_icm42600_state *st = _data;\n\tconst struct device *dev = regmap_get_device(st->map);\n\tint ret;\n\n\tret = regulator_disable(st->vddio_supply);\n\tif (ret)\n\t\tdev_err(dev, \"failed to disable vddio error %d\\n\", ret);\n}\n\nstatic void inv_icm42600_disable_pm(void *_data)\n{\n\tstruct device *dev = _data;\n\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n}\n\nint inv_icm42600_core_probe(struct regmap *regmap, int chip, int irq,\n\t\t\t    inv_icm42600_bus_setup bus_setup)\n{\n\tstruct device *dev = regmap_get_device(regmap);\n\tstruct inv_icm42600_state *st;\n\tstruct irq_data *irq_desc;\n\tint irq_type;\n\tbool open_drain;\n\tint ret;\n\n\tif (chip <= INV_CHIP_INVALID || chip >= INV_CHIP_NB) {\n\t\tdev_err(dev, \"invalid chip = %d\\n\", chip);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tirq_desc = irq_get_irq_data(irq);\n\tif (!irq_desc) {\n\t\tdev_err(dev, \"could not find IRQ %d\\n\", irq);\n\t\treturn -EINVAL;\n\t}\n\n\tirq_type = irqd_get_trigger_type(irq_desc);\n\tif (!irq_type)\n\t\tirq_type = IRQF_TRIGGER_FALLING;\n\n\topen_drain = device_property_read_bool(dev, \"drive-open-drain\");\n\n\tst = devm_kzalloc(dev, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, st);\n\tmutex_init(&st->lock);\n\tst->chip = chip;\n\tst->map = regmap;\n\n\tret = iio_read_mount_matrix(dev, &st->orientation);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to retrieve mounting matrix %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tst->vdd_supply = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(st->vdd_supply))\n\t\treturn PTR_ERR(st->vdd_supply);\n\n\tst->vddio_supply = devm_regulator_get(dev, \"vddio\");\n\tif (IS_ERR(st->vddio_supply))\n\t\treturn PTR_ERR(st->vddio_supply);\n\n\tret = regulator_enable(st->vdd_supply);\n\tif (ret)\n\t\treturn ret;\n\tmsleep(INV_ICM42600_POWER_UP_TIME_MS);\n\n\tret = devm_add_action_or_reset(dev, inv_icm42600_disable_vdd_reg, st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = inv_icm42600_enable_regulator_vddio(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, inv_icm42600_disable_vddio_reg, st);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = inv_icm42600_setup(st, bus_setup);\n\tif (ret)\n\t\treturn ret;\n\n\tret = inv_icm42600_timestamp_setup(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = inv_icm42600_buffer_init(st);\n\tif (ret)\n\t\treturn ret;\n\n\tst->indio_gyro = inv_icm42600_gyro_init(st);\n\tif (IS_ERR(st->indio_gyro))\n\t\treturn PTR_ERR(st->indio_gyro);\n\n\tst->indio_accel = inv_icm42600_accel_init(st);\n\tif (IS_ERR(st->indio_accel))\n\t\treturn PTR_ERR(st->indio_accel);\n\n\tret = inv_icm42600_irq_init(st, irq, irq_type, open_drain);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = pm_runtime_set_active(dev);\n\tif (ret)\n\t\treturn ret;\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev, INV_ICM42600_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_put(dev);\n\n\treturn devm_add_action_or_reset(dev, inv_icm42600_disable_pm, dev);\n}\nEXPORT_SYMBOL_NS_GPL(inv_icm42600_core_probe, IIO_ICM42600);\n\n \nstatic int inv_icm42600_suspend(struct device *dev)\n{\n\tstruct inv_icm42600_state *st = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tst->suspended.gyro = st->conf.gyro.mode;\n\tst->suspended.accel = st->conf.accel.mode;\n\tst->suspended.temp = st->conf.temp_en;\n\tif (pm_runtime_suspended(dev)) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (st->fifo.on) {\n\t\tret = regmap_write(st->map, INV_ICM42600_REG_FIFO_CONFIG,\n\t\t\t\t   INV_ICM42600_FIFO_CONFIG_BYPASS);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tret = inv_icm42600_set_pwr_mgmt0(st, INV_ICM42600_SENSOR_MODE_OFF,\n\t\t\t\t\t INV_ICM42600_SENSOR_MODE_OFF, false,\n\t\t\t\t\t NULL);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tregulator_disable(st->vddio_supply);\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\n \nstatic int inv_icm42600_resume(struct device *dev)\n{\n\tstruct inv_icm42600_state *st = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = inv_icm42600_enable_regulator_vddio(st);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\t \n\tret = inv_icm42600_set_pwr_mgmt0(st, st->suspended.gyro,\n\t\t\t\t\t st->suspended.accel,\n\t\t\t\t\t st->suspended.temp, NULL);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tif (st->fifo.on)\n\t\tret = regmap_write(st->map, INV_ICM42600_REG_FIFO_CONFIG,\n\t\t\t\t   INV_ICM42600_FIFO_CONFIG_STREAM);\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\n \nstatic int inv_icm42600_runtime_suspend(struct device *dev)\n{\n\tstruct inv_icm42600_state *st = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\t \n\tret = inv_icm42600_set_pwr_mgmt0(st, INV_ICM42600_SENSOR_MODE_OFF,\n\t\t\t\t\t INV_ICM42600_SENSOR_MODE_OFF, false,\n\t\t\t\t\t NULL);\n\tif (ret)\n\t\tgoto error_unlock;\n\n\tregulator_disable(st->vddio_supply);\n\nerror_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\n \nstatic int inv_icm42600_runtime_resume(struct device *dev)\n{\n\tstruct inv_icm42600_state *st = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = inv_icm42600_enable_regulator_vddio(st);\n\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nEXPORT_NS_GPL_DEV_PM_OPS(inv_icm42600_pm_ops, IIO_ICM42600) = {\n\tSYSTEM_SLEEP_PM_OPS(inv_icm42600_suspend, inv_icm42600_resume)\n\tRUNTIME_PM_OPS(inv_icm42600_runtime_suspend,\n\t\t       inv_icm42600_runtime_resume, NULL)\n};\n\nMODULE_AUTHOR(\"InvenSense, Inc.\");\nMODULE_DESCRIPTION(\"InvenSense ICM-426xx device driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IIO_INV_SENSORS_TIMESTAMP);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}