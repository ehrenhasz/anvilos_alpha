{
  "module_name": "inv_icm42600_gyro.c",
  "hash_id": "645f600969ef72a81fbce160bf38c0888bed7e9a3a37384510ab3da35242156a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/inv_icm42600/inv_icm42600_gyro.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n#include <linux/math64.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/common/inv_sensors_timestamp.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/kfifo_buf.h>\n\n#include \"inv_icm42600.h\"\n#include \"inv_icm42600_temp.h\"\n#include \"inv_icm42600_buffer.h\"\n\n#define INV_ICM42600_GYRO_CHAN(_modifier, _index, _ext_info)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_ANGL_VEL,\t\t\t\t\t\\\n\t\t.modified = 1,\t\t\t\t\t\t\\\n\t\t.channel2 = _modifier,\t\t\t\t\t\\\n\t\t.info_mask_separate =\t\t\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\t\t\t\\\n\t\t.info_mask_shared_by_type =\t\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\t\t\t\\\n\t\t.info_mask_shared_by_type_available =\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\t\t\t\\\n\t\t.info_mask_shared_by_all =\t\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t\\\n\t\t.info_mask_shared_by_all_available =\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t\\\n\t\t.scan_index = _index,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\t\\\n\t\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.ext_info = _ext_info,\t\t\t\t\t\\\n\t}\n\nenum inv_icm42600_gyro_scan {\n\tINV_ICM42600_GYRO_SCAN_X,\n\tINV_ICM42600_GYRO_SCAN_Y,\n\tINV_ICM42600_GYRO_SCAN_Z,\n\tINV_ICM42600_GYRO_SCAN_TEMP,\n\tINV_ICM42600_GYRO_SCAN_TIMESTAMP,\n};\n\nstatic const struct iio_chan_spec_ext_info inv_icm42600_gyro_ext_infos[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_ALL, inv_icm42600_get_mount_matrix),\n\t{},\n};\n\nstatic const struct iio_chan_spec inv_icm42600_gyro_channels[] = {\n\tINV_ICM42600_GYRO_CHAN(IIO_MOD_X, INV_ICM42600_GYRO_SCAN_X,\n\t\t\t       inv_icm42600_gyro_ext_infos),\n\tINV_ICM42600_GYRO_CHAN(IIO_MOD_Y, INV_ICM42600_GYRO_SCAN_Y,\n\t\t\t       inv_icm42600_gyro_ext_infos),\n\tINV_ICM42600_GYRO_CHAN(IIO_MOD_Z, INV_ICM42600_GYRO_SCAN_Z,\n\t\t\t       inv_icm42600_gyro_ext_infos),\n\tINV_ICM42600_TEMP_CHAN(INV_ICM42600_GYRO_SCAN_TEMP),\n\tIIO_CHAN_SOFT_TIMESTAMP(INV_ICM42600_GYRO_SCAN_TIMESTAMP),\n};\n\n \nstruct inv_icm42600_gyro_buffer {\n\tstruct inv_icm42600_fifo_sensor_data gyro;\n\tint16_t temp;\n\tint64_t timestamp __aligned(8);\n};\n\n#define INV_ICM42600_SCAN_MASK_GYRO_3AXIS\t\t\t\t\\\n\t(BIT(INV_ICM42600_GYRO_SCAN_X) |\t\t\t\t\\\n\tBIT(INV_ICM42600_GYRO_SCAN_Y) |\t\t\t\t\t\\\n\tBIT(INV_ICM42600_GYRO_SCAN_Z))\n\n#define INV_ICM42600_SCAN_MASK_TEMP\tBIT(INV_ICM42600_GYRO_SCAN_TEMP)\n\nstatic const unsigned long inv_icm42600_gyro_scan_masks[] = {\n\t \n\tINV_ICM42600_SCAN_MASK_GYRO_3AXIS | INV_ICM42600_SCAN_MASK_TEMP,\n\t0,\n};\n\n \nstatic int inv_icm42600_gyro_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t\t      const unsigned long *scan_mask)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tstruct inv_sensors_timestamp *ts = iio_priv(indio_dev);\n\tstruct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;\n\tunsigned int fifo_en = 0;\n\tunsigned int sleep_gyro = 0;\n\tunsigned int sleep_temp = 0;\n\tunsigned int sleep;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tif (*scan_mask & INV_ICM42600_SCAN_MASK_TEMP) {\n\t\t \n\t\tret = inv_icm42600_set_temp_conf(st, true, &sleep_temp);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tfifo_en |= INV_ICM42600_SENSOR_TEMP;\n\t}\n\n\tif (*scan_mask & INV_ICM42600_SCAN_MASK_GYRO_3AXIS) {\n\t\t \n\t\tconf.mode = INV_ICM42600_SENSOR_MODE_LOW_NOISE;\n\t\tret = inv_icm42600_set_gyro_conf(st, &conf, &sleep_gyro);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tfifo_en |= INV_ICM42600_SENSOR_GYRO;\n\t}\n\n\t \n\tinv_sensors_timestamp_apply_odr(ts, 0, 0, 0);\n\tret = inv_icm42600_buffer_set_fifo_en(st, fifo_en | st->fifo.en);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = inv_icm42600_buffer_update_watermark(st);\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\t \n\tif (sleep_gyro > sleep_temp)\n\t\tsleep = sleep_gyro;\n\telse\n\t\tsleep = sleep_temp;\n\tif (sleep)\n\t\tmsleep(sleep);\n\treturn ret;\n}\n\nstatic int inv_icm42600_gyro_read_sensor(struct inv_icm42600_state *st,\n\t\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t\t int16_t *val)\n{\n\tstruct device *dev = regmap_get_device(st->map);\n\tstruct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;\n\tunsigned int reg;\n\t__be16 *data;\n\tint ret;\n\n\tif (chan->type != IIO_ANGL_VEL)\n\t\treturn -EINVAL;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\treg = INV_ICM42600_REG_GYRO_DATA_X;\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\treg = INV_ICM42600_REG_GYRO_DATA_Y;\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\treg = INV_ICM42600_REG_GYRO_DATA_Z;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_get_sync(dev);\n\tmutex_lock(&st->lock);\n\n\t \n\tconf.mode = INV_ICM42600_SENSOR_MODE_LOW_NOISE;\n\tret = inv_icm42600_set_gyro_conf(st, &conf, NULL);\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tdata = (__be16 *)&st->buffer[0];\n\tret = regmap_bulk_read(st->map, reg, data, sizeof(*data));\n\tif (ret)\n\t\tgoto exit;\n\n\t*val = (int16_t)be16_to_cpup(data);\n\tif (*val == INV_ICM42600_DATA_INVALID)\n\t\tret = -EINVAL;\nexit:\n\tmutex_unlock(&st->lock);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\treturn ret;\n}\n\n \nstatic const int inv_icm42600_gyro_scale[] = {\n\t \n\t[2 * INV_ICM42600_GYRO_FS_2000DPS] = 0,\n\t[2 * INV_ICM42600_GYRO_FS_2000DPS + 1] = 1065264,\n\t \n\t[2 * INV_ICM42600_GYRO_FS_1000DPS] = 0,\n\t[2 * INV_ICM42600_GYRO_FS_1000DPS + 1] = 532632,\n\t \n\t[2 * INV_ICM42600_GYRO_FS_500DPS] = 0,\n\t[2 * INV_ICM42600_GYRO_FS_500DPS + 1] = 266316,\n\t \n\t[2 * INV_ICM42600_GYRO_FS_250DPS] = 0,\n\t[2 * INV_ICM42600_GYRO_FS_250DPS + 1] = 133158,\n\t \n\t[2 * INV_ICM42600_GYRO_FS_125DPS] = 0,\n\t[2 * INV_ICM42600_GYRO_FS_125DPS + 1] = 66579,\n\t \n\t[2 * INV_ICM42600_GYRO_FS_62_5DPS] = 0,\n\t[2 * INV_ICM42600_GYRO_FS_62_5DPS + 1] = 33290,\n\t \n\t[2 * INV_ICM42600_GYRO_FS_31_25DPS] = 0,\n\t[2 * INV_ICM42600_GYRO_FS_31_25DPS + 1] = 16645,\n\t \n\t[2 * INV_ICM42600_GYRO_FS_15_625DPS] = 0,\n\t[2 * INV_ICM42600_GYRO_FS_15_625DPS + 1] = 8322,\n};\n\nstatic int inv_icm42600_gyro_read_scale(struct inv_icm42600_state *st,\n\t\t\t\t\tint *val, int *val2)\n{\n\tunsigned int idx;\n\n\tidx = st->conf.gyro.fs;\n\n\t*val = inv_icm42600_gyro_scale[2 * idx];\n\t*val2 = inv_icm42600_gyro_scale[2 * idx + 1];\n\treturn IIO_VAL_INT_PLUS_NANO;\n}\n\nstatic int inv_icm42600_gyro_write_scale(struct inv_icm42600_state *st,\n\t\t\t\t\t int val, int val2)\n{\n\tstruct device *dev = regmap_get_device(st->map);\n\tunsigned int idx;\n\tstruct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;\n\tint ret;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(inv_icm42600_gyro_scale); idx += 2) {\n\t\tif (val == inv_icm42600_gyro_scale[idx] &&\n\t\t    val2 == inv_icm42600_gyro_scale[idx + 1])\n\t\t\tbreak;\n\t}\n\tif (idx >= ARRAY_SIZE(inv_icm42600_gyro_scale))\n\t\treturn -EINVAL;\n\n\tconf.fs = idx / 2;\n\n\tpm_runtime_get_sync(dev);\n\tmutex_lock(&st->lock);\n\n\tret = inv_icm42600_set_gyro_conf(st, &conf, NULL);\n\n\tmutex_unlock(&st->lock);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\n \nstatic const int inv_icm42600_gyro_odr[] = {\n\t \n\t12, 500000,\n\t \n\t25, 0,\n\t \n\t50, 0,\n\t \n\t100, 0,\n\t \n\t200, 0,\n\t \n\t1000, 0,\n\t \n\t2000, 0,\n\t \n\t4000, 0,\n};\n\nstatic const int inv_icm42600_gyro_odr_conv[] = {\n\tINV_ICM42600_ODR_12_5HZ,\n\tINV_ICM42600_ODR_25HZ,\n\tINV_ICM42600_ODR_50HZ,\n\tINV_ICM42600_ODR_100HZ,\n\tINV_ICM42600_ODR_200HZ,\n\tINV_ICM42600_ODR_1KHZ_LN,\n\tINV_ICM42600_ODR_2KHZ_LN,\n\tINV_ICM42600_ODR_4KHZ_LN,\n};\n\nstatic int inv_icm42600_gyro_read_odr(struct inv_icm42600_state *st,\n\t\t\t\t      int *val, int *val2)\n{\n\tunsigned int odr;\n\tunsigned int i;\n\n\todr = st->conf.gyro.odr;\n\n\tfor (i = 0; i < ARRAY_SIZE(inv_icm42600_gyro_odr_conv); ++i) {\n\t\tif (inv_icm42600_gyro_odr_conv[i] == odr)\n\t\t\tbreak;\n\t}\n\tif (i >= ARRAY_SIZE(inv_icm42600_gyro_odr_conv))\n\t\treturn -EINVAL;\n\n\t*val = inv_icm42600_gyro_odr[2 * i];\n\t*val2 = inv_icm42600_gyro_odr[2 * i + 1];\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int inv_icm42600_gyro_write_odr(struct iio_dev *indio_dev,\n\t\t\t\t       int val, int val2)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tstruct inv_sensors_timestamp *ts = iio_priv(indio_dev);\n\tstruct device *dev = regmap_get_device(st->map);\n\tunsigned int idx;\n\tstruct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;\n\tint ret;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(inv_icm42600_gyro_odr); idx += 2) {\n\t\tif (val == inv_icm42600_gyro_odr[idx] &&\n\t\t    val2 == inv_icm42600_gyro_odr[idx + 1])\n\t\t\tbreak;\n\t}\n\tif (idx >= ARRAY_SIZE(inv_icm42600_gyro_odr))\n\t\treturn -EINVAL;\n\n\tconf.odr = inv_icm42600_gyro_odr_conv[idx / 2];\n\n\tpm_runtime_get_sync(dev);\n\tmutex_lock(&st->lock);\n\n\tret = inv_sensors_timestamp_update_odr(ts, inv_icm42600_odr_to_period(conf.odr),\n\t\t\t\t\t       iio_buffer_enabled(indio_dev));\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = inv_icm42600_set_gyro_conf(st, &conf, NULL);\n\tif (ret)\n\t\tgoto out_unlock;\n\tinv_icm42600_buffer_update_fifo_period(st);\n\tinv_icm42600_buffer_update_watermark(st);\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\n \nstatic int inv_icm42600_gyro_calibbias[] = {\n\t-1, 117010721,\t\t \n\t0, 545415,\t\t \n\t1, 116465306,\t\t \n};\n\nstatic int inv_icm42600_gyro_read_offset(struct inv_icm42600_state *st,\n\t\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t\t int *val, int *val2)\n{\n\tstruct device *dev = regmap_get_device(st->map);\n\tint64_t val64;\n\tint32_t bias;\n\tunsigned int reg;\n\tint16_t offset;\n\tuint8_t data[2];\n\tint ret;\n\n\tif (chan->type != IIO_ANGL_VEL)\n\t\treturn -EINVAL;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\treg = INV_ICM42600_REG_OFFSET_USER0;\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\treg = INV_ICM42600_REG_OFFSET_USER1;\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\treg = INV_ICM42600_REG_OFFSET_USER3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_get_sync(dev);\n\tmutex_lock(&st->lock);\n\n\tret = regmap_bulk_read(st->map, reg, st->buffer, sizeof(data));\n\tmemcpy(data, st->buffer, sizeof(data));\n\n\tmutex_unlock(&st->lock);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\toffset = sign_extend32(((data[1] & 0x0F) << 8) | data[0], 11);\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\toffset = sign_extend32(((data[0] & 0xF0) << 4) | data[1], 11);\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\toffset = sign_extend32(((data[1] & 0x0F) << 8) | data[0], 11);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval64 = (int64_t)offset * 64LL * 3141592653LL;\n\t \n\tif (val64 >= 0)\n\t\tval64 += 2048 * 180 / 2;\n\telse\n\t\tval64 -= 2048 * 180 / 2;\n\tbias = div_s64(val64, 2048 * 180);\n\t*val = bias / 1000000000L;\n\t*val2 = bias % 1000000000L;\n\n\treturn IIO_VAL_INT_PLUS_NANO;\n}\n\nstatic int inv_icm42600_gyro_write_offset(struct inv_icm42600_state *st,\n\t\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t\t  int val, int val2)\n{\n\tstruct device *dev = regmap_get_device(st->map);\n\tint64_t val64, min, max;\n\tunsigned int reg, regval;\n\tint16_t offset;\n\tint ret;\n\n\tif (chan->type != IIO_ANGL_VEL)\n\t\treturn -EINVAL;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\treg = INV_ICM42600_REG_OFFSET_USER0;\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\treg = INV_ICM42600_REG_OFFSET_USER1;\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\treg = INV_ICM42600_REG_OFFSET_USER3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmin = (int64_t)inv_icm42600_gyro_calibbias[0] * 1000000000LL +\n\t      (int64_t)inv_icm42600_gyro_calibbias[1];\n\tmax = (int64_t)inv_icm42600_gyro_calibbias[4] * 1000000000LL +\n\t      (int64_t)inv_icm42600_gyro_calibbias[5];\n\tval64 = (int64_t)val * 1000000000LL + (int64_t)val2;\n\tif (val64 < min || val64 > max)\n\t\treturn -EINVAL;\n\n\t \n\tval64 = val64 * 180LL * 2048LL;\n\t \n\tif (val64 >= 0)\n\t\tval64 += 3141592653LL * 64LL / 2LL;\n\telse\n\t\tval64 -= 3141592653LL * 64LL / 2LL;\n\toffset = div64_s64(val64, 3141592653LL * 64LL);\n\n\t \n\tif (offset < -2048)\n\t\toffset = -2048;\n\telse if (offset > 2047)\n\t\toffset = 2047;\n\n\tpm_runtime_get_sync(dev);\n\tmutex_lock(&st->lock);\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\t \n\t\tret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER1,\n\t\t\t\t  &regval);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tst->buffer[0] = offset & 0xFF;\n\t\tst->buffer[1] = (regval & 0xF0) | ((offset & 0xF00) >> 8);\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\t \n\t\tret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER1,\n\t\t\t\t  &regval);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tst->buffer[0] = ((offset & 0xF00) >> 4) | (regval & 0x0F);\n\t\tst->buffer[1] = offset & 0xFF;\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\t \n\t\tret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER4,\n\t\t\t\t  &regval);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tst->buffer[0] = offset & 0xFF;\n\t\tst->buffer[1] = (regval & 0xF0) | ((offset & 0xF00) >> 8);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = regmap_bulk_write(st->map, reg, st->buffer, 2);\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\treturn ret;\n}\n\nstatic int inv_icm42600_gyro_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t\t      int *val, int *val2, long mask)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tint16_t data;\n\tint ret;\n\n\tswitch (chan->type) {\n\tcase IIO_ANGL_VEL:\n\t\tbreak;\n\tcase IIO_TEMP:\n\t\treturn inv_icm42600_temp_read_raw(indio_dev, chan, val, val2, mask);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = inv_icm42600_gyro_read_sensor(st, chan, &data);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*val = data;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn inv_icm42600_gyro_read_scale(st, val, val2);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn inv_icm42600_gyro_read_odr(st, val, val2);\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treturn inv_icm42600_gyro_read_offset(st, chan, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int inv_icm42600_gyro_read_avail(struct iio_dev *indio_dev,\n\t\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\t\tconst int **vals,\n\t\t\t\t\tint *type, int *length, long mask)\n{\n\tif (chan->type != IIO_ANGL_VEL)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*vals = inv_icm42600_gyro_scale;\n\t\t*type = IIO_VAL_INT_PLUS_NANO;\n\t\t*length = ARRAY_SIZE(inv_icm42600_gyro_scale);\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*vals = inv_icm42600_gyro_odr;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t*length = ARRAY_SIZE(inv_icm42600_gyro_odr);\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\t*vals = inv_icm42600_gyro_calibbias;\n\t\t*type = IIO_VAL_INT_PLUS_NANO;\n\t\treturn IIO_AVAIL_RANGE;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int inv_icm42600_gyro_write_raw(struct iio_dev *indio_dev,\n\t\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t\t       int val, int val2, long mask)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tint ret;\n\n\tif (chan->type != IIO_ANGL_VEL)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = inv_icm42600_gyro_write_scale(st, val, val2);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn inv_icm42600_gyro_write_odr(indio_dev, val, val2);\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = inv_icm42600_gyro_write_offset(st, chan, val, val2);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int inv_icm42600_gyro_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t\t\t       long mask)\n{\n\tif (chan->type != IIO_ANGL_VEL)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int inv_icm42600_gyro_hwfifo_set_watermark(struct iio_dev *indio_dev,\n\t\t\t\t\t\t  unsigned int val)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tst->fifo.watermark.gyro = val;\n\tret = inv_icm42600_buffer_update_watermark(st);\n\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int inv_icm42600_gyro_hwfifo_flush(struct iio_dev *indio_dev,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tint ret;\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tmutex_lock(&st->lock);\n\n\tret = inv_icm42600_buffer_hwfifo_flush(st, count);\n\tif (!ret)\n\t\tret = st->fifo.nb.gyro;\n\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_info inv_icm42600_gyro_info = {\n\t.read_raw = inv_icm42600_gyro_read_raw,\n\t.read_avail = inv_icm42600_gyro_read_avail,\n\t.write_raw = inv_icm42600_gyro_write_raw,\n\t.write_raw_get_fmt = inv_icm42600_gyro_write_raw_get_fmt,\n\t.debugfs_reg_access = inv_icm42600_debugfs_reg,\n\t.update_scan_mode = inv_icm42600_gyro_update_scan_mode,\n\t.hwfifo_set_watermark = inv_icm42600_gyro_hwfifo_set_watermark,\n\t.hwfifo_flush_to_buffer = inv_icm42600_gyro_hwfifo_flush,\n};\n\nstruct iio_dev *inv_icm42600_gyro_init(struct inv_icm42600_state *st)\n{\n\tstruct device *dev = regmap_get_device(st->map);\n\tconst char *name;\n\tstruct inv_sensors_timestamp_chip ts_chip;\n\tstruct inv_sensors_timestamp *ts;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tname = devm_kasprintf(dev, GFP_KERNEL, \"%s-gyro\", st->name);\n\tif (!name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*ts));\n\tif (!indio_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tts_chip.clock_period = 31250;\n\tts_chip.jitter = 20;\n\tts_chip.init_period = inv_icm42600_odr_to_period(st->conf.accel.odr);\n\tts = iio_priv(indio_dev);\n\tinv_sensors_timestamp_init(ts, &ts_chip);\n\n\tiio_device_set_drvdata(indio_dev, st);\n\tindio_dev->name = name;\n\tindio_dev->info = &inv_icm42600_gyro_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = inv_icm42600_gyro_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(inv_icm42600_gyro_channels);\n\tindio_dev->available_scan_masks = inv_icm42600_gyro_scan_masks;\n\tindio_dev->setup_ops = &inv_icm42600_buffer_ops;\n\n\tret = devm_iio_kfifo_buffer_setup(dev, indio_dev,\n\t\t\t\t\t  &inv_icm42600_buffer_ops);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn indio_dev;\n}\n\nint inv_icm42600_gyro_parse_fifo(struct iio_dev *indio_dev)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tstruct inv_sensors_timestamp *ts = iio_priv(indio_dev);\n\tssize_t i, size;\n\tunsigned int no;\n\tconst void *accel, *gyro, *timestamp;\n\tconst int8_t *temp;\n\tunsigned int odr;\n\tint64_t ts_val;\n\tstruct inv_icm42600_gyro_buffer buffer;\n\n\t \n\tfor (i = 0, no = 0; i < st->fifo.count; i += size, ++no) {\n\t\tsize = inv_icm42600_fifo_decode_packet(&st->fifo.data[i],\n\t\t\t\t&accel, &gyro, &temp, &timestamp, &odr);\n\t\t \n\t\tif (size <= 0)\n\t\t\treturn size;\n\n\t\t \n\t\tif (gyro == NULL || !inv_icm42600_fifo_is_data_valid(gyro))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (odr & INV_ICM42600_SENSOR_GYRO)\n\t\t\tinv_sensors_timestamp_apply_odr(ts, st->fifo.period,\n\t\t\t\t\t\t\tst->fifo.nb.total, no);\n\n\t\t \n\t\tmemset(&buffer, 0, sizeof(buffer));\n\t\tmemcpy(&buffer.gyro, gyro, sizeof(buffer.gyro));\n\t\t \n\t\tbuffer.temp = temp ? (*temp * 64) : 0;\n\t\tts_val = inv_sensors_timestamp_pop(ts);\n\t\tiio_push_to_buffers_with_timestamp(indio_dev, &buffer, ts_val);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}