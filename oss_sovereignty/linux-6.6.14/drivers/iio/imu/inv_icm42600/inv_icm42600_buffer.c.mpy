{
  "module_name": "inv_icm42600_buffer.c",
  "hash_id": "2233b0a3b7aacb6e6dff9419593aa5ba2e798e806c79633ce08866eea9388198",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/inv_icm42600/inv_icm42600_buffer.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/common/inv_sensors_timestamp.h>\n#include <linux/iio/iio.h>\n\n#include \"inv_icm42600.h\"\n#include \"inv_icm42600_buffer.h\"\n\n \n#define INV_ICM42600_FIFO_HEADER_MSG\t\tBIT(7)\n#define INV_ICM42600_FIFO_HEADER_ACCEL\t\tBIT(6)\n#define INV_ICM42600_FIFO_HEADER_GYRO\t\tBIT(5)\n#define INV_ICM42600_FIFO_HEADER_TMST_FSYNC\tGENMASK(3, 2)\n#define INV_ICM42600_FIFO_HEADER_ODR_ACCEL\tBIT(1)\n#define INV_ICM42600_FIFO_HEADER_ODR_GYRO\tBIT(0)\n\nstruct inv_icm42600_fifo_1sensor_packet {\n\tuint8_t header;\n\tstruct inv_icm42600_fifo_sensor_data data;\n\tint8_t temp;\n} __packed;\n#define INV_ICM42600_FIFO_1SENSOR_PACKET_SIZE\t\t8\n\nstruct inv_icm42600_fifo_2sensors_packet {\n\tuint8_t header;\n\tstruct inv_icm42600_fifo_sensor_data accel;\n\tstruct inv_icm42600_fifo_sensor_data gyro;\n\tint8_t temp;\n\t__be16 timestamp;\n} __packed;\n#define INV_ICM42600_FIFO_2SENSORS_PACKET_SIZE\t\t16\n\nssize_t inv_icm42600_fifo_decode_packet(const void *packet, const void **accel,\n\t\t\t\t\tconst void **gyro, const int8_t **temp,\n\t\t\t\t\tconst void **timestamp, unsigned int *odr)\n{\n\tconst struct inv_icm42600_fifo_1sensor_packet *pack1 = packet;\n\tconst struct inv_icm42600_fifo_2sensors_packet *pack2 = packet;\n\tuint8_t header = *((const uint8_t *)packet);\n\n\t \n\tif (header & INV_ICM42600_FIFO_HEADER_MSG) {\n\t\t*accel = NULL;\n\t\t*gyro = NULL;\n\t\t*temp = NULL;\n\t\t*timestamp = NULL;\n\t\t*odr = 0;\n\t\treturn 0;\n\t}\n\n\t \n\t*odr = 0;\n\tif (header & INV_ICM42600_FIFO_HEADER_ODR_GYRO)\n\t\t*odr |= INV_ICM42600_SENSOR_GYRO;\n\tif (header & INV_ICM42600_FIFO_HEADER_ODR_ACCEL)\n\t\t*odr |= INV_ICM42600_SENSOR_ACCEL;\n\n\t \n\tif ((header & INV_ICM42600_FIFO_HEADER_ACCEL) &&\n\t    (header & INV_ICM42600_FIFO_HEADER_GYRO)) {\n\t\t*accel = &pack2->accel;\n\t\t*gyro = &pack2->gyro;\n\t\t*temp = &pack2->temp;\n\t\t*timestamp = &pack2->timestamp;\n\t\treturn INV_ICM42600_FIFO_2SENSORS_PACKET_SIZE;\n\t}\n\n\t \n\tif (header & INV_ICM42600_FIFO_HEADER_ACCEL) {\n\t\t*accel = &pack1->data;\n\t\t*gyro = NULL;\n\t\t*temp = &pack1->temp;\n\t\t*timestamp = NULL;\n\t\treturn INV_ICM42600_FIFO_1SENSOR_PACKET_SIZE;\n\t}\n\n\t \n\tif (header & INV_ICM42600_FIFO_HEADER_GYRO) {\n\t\t*accel = NULL;\n\t\t*gyro = &pack1->data;\n\t\t*temp = &pack1->temp;\n\t\t*timestamp = NULL;\n\t\treturn INV_ICM42600_FIFO_1SENSOR_PACKET_SIZE;\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\nvoid inv_icm42600_buffer_update_fifo_period(struct inv_icm42600_state *st)\n{\n\tuint32_t period_gyro, period_accel, period;\n\n\tif (st->fifo.en & INV_ICM42600_SENSOR_GYRO)\n\t\tperiod_gyro = inv_icm42600_odr_to_period(st->conf.gyro.odr);\n\telse\n\t\tperiod_gyro = U32_MAX;\n\n\tif (st->fifo.en & INV_ICM42600_SENSOR_ACCEL)\n\t\tperiod_accel = inv_icm42600_odr_to_period(st->conf.accel.odr);\n\telse\n\t\tperiod_accel = U32_MAX;\n\n\tif (period_gyro <= period_accel)\n\t\tperiod = period_gyro;\n\telse\n\t\tperiod = period_accel;\n\n\tst->fifo.period = period;\n}\n\nint inv_icm42600_buffer_set_fifo_en(struct inv_icm42600_state *st,\n\t\t\t\t    unsigned int fifo_en)\n{\n\tunsigned int mask, val;\n\tint ret;\n\n\t \n\tmask = INV_ICM42600_FIFO_CONFIG1_TMST_FSYNC_EN |\n\t\tINV_ICM42600_FIFO_CONFIG1_TEMP_EN |\n\t\tINV_ICM42600_FIFO_CONFIG1_GYRO_EN |\n\t\tINV_ICM42600_FIFO_CONFIG1_ACCEL_EN;\n\n\tval = 0;\n\tif (fifo_en & INV_ICM42600_SENSOR_GYRO)\n\t\tval |= INV_ICM42600_FIFO_CONFIG1_GYRO_EN;\n\tif (fifo_en & INV_ICM42600_SENSOR_ACCEL)\n\t\tval |= INV_ICM42600_FIFO_CONFIG1_ACCEL_EN;\n\tif (fifo_en & INV_ICM42600_SENSOR_TEMP)\n\t\tval |= INV_ICM42600_FIFO_CONFIG1_TEMP_EN;\n\n\tret = regmap_update_bits(st->map, INV_ICM42600_REG_FIFO_CONFIG1, mask, val);\n\tif (ret)\n\t\treturn ret;\n\n\tst->fifo.en = fifo_en;\n\tinv_icm42600_buffer_update_fifo_period(st);\n\n\treturn 0;\n}\n\nstatic size_t inv_icm42600_get_packet_size(unsigned int fifo_en)\n{\n\tsize_t packet_size;\n\n\tif ((fifo_en & INV_ICM42600_SENSOR_GYRO) &&\n\t    (fifo_en & INV_ICM42600_SENSOR_ACCEL))\n\t\tpacket_size = INV_ICM42600_FIFO_2SENSORS_PACKET_SIZE;\n\telse\n\t\tpacket_size = INV_ICM42600_FIFO_1SENSOR_PACKET_SIZE;\n\n\treturn packet_size;\n}\n\nstatic unsigned int inv_icm42600_wm_truncate(unsigned int watermark,\n\t\t\t\t\t     size_t packet_size)\n{\n\tsize_t wm_size;\n\tunsigned int wm;\n\n\twm_size = watermark * packet_size;\n\tif (wm_size > INV_ICM42600_FIFO_WATERMARK_MAX)\n\t\twm_size = INV_ICM42600_FIFO_WATERMARK_MAX;\n\n\twm = wm_size / packet_size;\n\n\treturn wm;\n}\n\n \nint inv_icm42600_buffer_update_watermark(struct inv_icm42600_state *st)\n{\n\tsize_t packet_size, wm_size;\n\tunsigned int wm_gyro, wm_accel, watermark;\n\tuint32_t period_gyro, period_accel, period;\n\tuint32_t latency_gyro, latency_accel, latency;\n\tbool restore;\n\t__le16 raw_wm;\n\tint ret;\n\n\tpacket_size = inv_icm42600_get_packet_size(st->fifo.en);\n\n\t \n\twm_gyro = inv_icm42600_wm_truncate(st->fifo.watermark.gyro, packet_size);\n\twm_accel = inv_icm42600_wm_truncate(st->fifo.watermark.accel, packet_size);\n\t \n\tperiod_gyro = inv_icm42600_odr_to_period(st->conf.gyro.odr) / 1000UL;\n\tperiod_accel = inv_icm42600_odr_to_period(st->conf.accel.odr) / 1000UL;\n\tlatency_gyro = period_gyro * wm_gyro;\n\tlatency_accel = period_accel * wm_accel;\n\n\t \n\tif (latency_gyro == 0) {\n\t\twatermark = wm_accel;\n\t} else if (latency_accel == 0) {\n\t\twatermark = wm_gyro;\n\t} else {\n\t\t \n\t\tif (latency_gyro <= latency_accel)\n\t\t\tlatency = latency_gyro - (latency_accel % latency_gyro);\n\t\telse\n\t\t\tlatency = latency_accel - (latency_gyro % latency_accel);\n\t\t \n\t\tif (period_gyro <= period_accel)\n\t\t\tperiod = period_gyro;\n\t\telse\n\t\t\tperiod = period_accel;\n\t\t \n\t\twatermark = latency / period;\n\t\tif (watermark < 1)\n\t\t\twatermark = 1;\n\t}\n\n\t \n\twm_size = watermark * packet_size;\n\n\t \n\tret = regmap_update_bits_check(st->map, INV_ICM42600_REG_INT_SOURCE0,\n\t\t\t\t       INV_ICM42600_INT_SOURCE0_FIFO_THS_INT1_EN,\n\t\t\t\t       0, &restore);\n\tif (ret)\n\t\treturn ret;\n\n\traw_wm = INV_ICM42600_FIFO_WATERMARK_VAL(wm_size);\n\tmemcpy(st->buffer, &raw_wm, sizeof(raw_wm));\n\tret = regmap_bulk_write(st->map, INV_ICM42600_REG_FIFO_WATERMARK,\n\t\t\t\tst->buffer, sizeof(raw_wm));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (restore) {\n\t\tret = regmap_update_bits(st->map, INV_ICM42600_REG_INT_SOURCE0,\n\t\t\t\t\t INV_ICM42600_INT_SOURCE0_FIFO_THS_INT1_EN,\n\t\t\t\t\t INV_ICM42600_INT_SOURCE0_FIFO_THS_INT1_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int inv_icm42600_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tstruct device *dev = regmap_get_device(st->map);\n\tstruct inv_sensors_timestamp *ts = iio_priv(indio_dev);\n\n\tpm_runtime_get_sync(dev);\n\n\tmutex_lock(&st->lock);\n\tinv_sensors_timestamp_reset(ts);\n\tmutex_unlock(&st->lock);\n\n\treturn 0;\n}\n\n \nstatic int inv_icm42600_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\t \n\tif (st->fifo.on) {\n\t\tret = 0;\n\t\tgoto out_on;\n\t}\n\n\t \n\tret = regmap_update_bits(st->map, INV_ICM42600_REG_INT_SOURCE0,\n\t\t\t\t INV_ICM42600_INT_SOURCE0_FIFO_THS_INT1_EN,\n\t\t\t\t INV_ICM42600_INT_SOURCE0_FIFO_THS_INT1_EN);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tret = regmap_write(st->map, INV_ICM42600_REG_SIGNAL_PATH_RESET,\n\t\t\t   INV_ICM42600_SIGNAL_PATH_RESET_FIFO_FLUSH);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tret = regmap_write(st->map, INV_ICM42600_REG_FIFO_CONFIG,\n\t\t\t   INV_ICM42600_FIFO_CONFIG_STREAM);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tret = regmap_bulk_read(st->map, INV_ICM42600_REG_FIFO_COUNT, st->buffer, 2);\n\tif (ret)\n\t\tgoto out_unlock;\n\nout_on:\n\t \n\tst->fifo.on++;\nout_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic int inv_icm42600_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\t \n\tif (st->fifo.on > 1) {\n\t\tret = 0;\n\t\tgoto out_off;\n\t}\n\n\t \n\tret = regmap_write(st->map, INV_ICM42600_REG_FIFO_CONFIG,\n\t\t\t   INV_ICM42600_FIFO_CONFIG_BYPASS);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tret = regmap_write(st->map, INV_ICM42600_REG_SIGNAL_PATH_RESET,\n\t\t\t   INV_ICM42600_SIGNAL_PATH_RESET_FIFO_FLUSH);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tret = regmap_update_bits(st->map, INV_ICM42600_REG_INT_SOURCE0,\n\t\t\t\t INV_ICM42600_INT_SOURCE0_FIFO_THS_INT1_EN, 0);\n\tif (ret)\n\t\tgoto out_unlock;\n\nout_off:\n\t \n\tst->fifo.on--;\nout_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic int inv_icm42600_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);\n\tstruct device *dev = regmap_get_device(st->map);\n\tunsigned int sensor;\n\tunsigned int *watermark;\n\tstruct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;\n\tunsigned int sleep_temp = 0;\n\tunsigned int sleep_sensor = 0;\n\tunsigned int sleep;\n\tint ret;\n\n\tif (indio_dev == st->indio_gyro) {\n\t\tsensor = INV_ICM42600_SENSOR_GYRO;\n\t\twatermark = &st->fifo.watermark.gyro;\n\t} else if (indio_dev == st->indio_accel) {\n\t\tsensor = INV_ICM42600_SENSOR_ACCEL;\n\t\twatermark = &st->fifo.watermark.accel;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&st->lock);\n\n\tret = inv_icm42600_buffer_set_fifo_en(st, st->fifo.en & ~sensor);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t*watermark = 0;\n\tret = inv_icm42600_buffer_update_watermark(st);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tconf.mode = INV_ICM42600_SENSOR_MODE_OFF;\n\tif (sensor == INV_ICM42600_SENSOR_GYRO)\n\t\tret = inv_icm42600_set_gyro_conf(st, &conf, &sleep_sensor);\n\telse\n\t\tret = inv_icm42600_set_accel_conf(st, &conf, &sleep_sensor);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tif (!st->fifo.on)\n\t\tret = inv_icm42600_set_temp_conf(st, false, &sleep_temp);\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\n\t \n\tif (sleep_sensor > sleep_temp)\n\t\tsleep = sleep_sensor;\n\telse\n\t\tsleep = sleep_temp;\n\tif (sleep)\n\t\tmsleep(sleep);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nconst struct iio_buffer_setup_ops inv_icm42600_buffer_ops = {\n\t.preenable = inv_icm42600_buffer_preenable,\n\t.postenable = inv_icm42600_buffer_postenable,\n\t.predisable = inv_icm42600_buffer_predisable,\n\t.postdisable = inv_icm42600_buffer_postdisable,\n};\n\nint inv_icm42600_buffer_fifo_read(struct inv_icm42600_state *st,\n\t\t\t\t  unsigned int max)\n{\n\tsize_t max_count;\n\t__be16 *raw_fifo_count;\n\tssize_t i, size;\n\tconst void *accel, *gyro, *timestamp;\n\tconst int8_t *temp;\n\tunsigned int odr;\n\tint ret;\n\n\t \n\tst->fifo.count = 0;\n\tst->fifo.nb.gyro = 0;\n\tst->fifo.nb.accel = 0;\n\tst->fifo.nb.total = 0;\n\n\t \n\tif (max == 0)\n\t\tmax_count = sizeof(st->fifo.data);\n\telse\n\t\tmax_count = max * inv_icm42600_get_packet_size(st->fifo.en);\n\n\t \n\traw_fifo_count = (__be16 *)st->buffer;\n\tret = regmap_bulk_read(st->map, INV_ICM42600_REG_FIFO_COUNT,\n\t\t\t       raw_fifo_count, sizeof(*raw_fifo_count));\n\tif (ret)\n\t\treturn ret;\n\tst->fifo.count = be16_to_cpup(raw_fifo_count);\n\n\t \n\tif (st->fifo.count == 0)\n\t\treturn 0;\n\tif (st->fifo.count > max_count)\n\t\tst->fifo.count = max_count;\n\n\t \n\tret = regmap_noinc_read(st->map, INV_ICM42600_REG_FIFO_DATA,\n\t\t\t\tst->fifo.data, st->fifo.count);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < st->fifo.count; i += size) {\n\t\tsize = inv_icm42600_fifo_decode_packet(&st->fifo.data[i],\n\t\t\t\t&accel, &gyro, &temp, &timestamp, &odr);\n\t\tif (size <= 0)\n\t\t\tbreak;\n\t\tif (gyro != NULL && inv_icm42600_fifo_is_data_valid(gyro))\n\t\t\tst->fifo.nb.gyro++;\n\t\tif (accel != NULL && inv_icm42600_fifo_is_data_valid(accel))\n\t\t\tst->fifo.nb.accel++;\n\t\tst->fifo.nb.total++;\n\t}\n\n\treturn 0;\n}\n\nint inv_icm42600_buffer_fifo_parse(struct inv_icm42600_state *st)\n{\n\tstruct inv_sensors_timestamp *ts;\n\tint ret;\n\n\tif (st->fifo.nb.total == 0)\n\t\treturn 0;\n\n\t \n\tts = iio_priv(st->indio_gyro);\n\tinv_sensors_timestamp_interrupt(ts, st->fifo.period, st->fifo.nb.total,\n\t\t\t\t\tst->fifo.nb.gyro, st->timestamp.gyro);\n\tif (st->fifo.nb.gyro > 0) {\n\t\tret = inv_icm42600_gyro_parse_fifo(st->indio_gyro);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tts = iio_priv(st->indio_accel);\n\tinv_sensors_timestamp_interrupt(ts, st->fifo.period, st->fifo.nb.total,\n\t\t\t\t\tst->fifo.nb.accel, st->timestamp.accel);\n\tif (st->fifo.nb.accel > 0) {\n\t\tret = inv_icm42600_accel_parse_fifo(st->indio_accel);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint inv_icm42600_buffer_hwfifo_flush(struct inv_icm42600_state *st,\n\t\t\t\t     unsigned int count)\n{\n\tstruct inv_sensors_timestamp *ts;\n\tint64_t gyro_ts, accel_ts;\n\tint ret;\n\n\tgyro_ts = iio_get_time_ns(st->indio_gyro);\n\taccel_ts = iio_get_time_ns(st->indio_accel);\n\n\tret = inv_icm42600_buffer_fifo_read(st, count);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->fifo.nb.total == 0)\n\t\treturn 0;\n\n\tif (st->fifo.nb.gyro > 0) {\n\t\tts = iio_priv(st->indio_gyro);\n\t\tinv_sensors_timestamp_interrupt(ts, st->fifo.period,\n\t\t\t\t\t\tst->fifo.nb.total, st->fifo.nb.gyro,\n\t\t\t\t\t\tgyro_ts);\n\t\tret = inv_icm42600_gyro_parse_fifo(st->indio_gyro);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (st->fifo.nb.accel > 0) {\n\t\tts = iio_priv(st->indio_accel);\n\t\tinv_sensors_timestamp_interrupt(ts, st->fifo.period,\n\t\t\t\t\t\tst->fifo.nb.total, st->fifo.nb.accel,\n\t\t\t\t\t\taccel_ts);\n\t\tret = inv_icm42600_accel_parse_fifo(st->indio_accel);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint inv_icm42600_buffer_init(struct inv_icm42600_state *st)\n{\n\tunsigned int val;\n\tint ret;\n\n\t \n\tval = INV_ICM42600_INTF_CONFIG0_FIFO_COUNT_ENDIAN;\n\tret = regmap_update_bits(st->map, INV_ICM42600_REG_INTF_CONFIG0,\n\t\t\t\t GENMASK(7, 5), val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = INV_ICM42600_FIFO_CONFIG1_RESUME_PARTIAL_RD |\n\t      INV_ICM42600_FIFO_CONFIG1_WM_GT_TH;\n\treturn regmap_update_bits(st->map, INV_ICM42600_REG_FIFO_CONFIG1,\n\t\t\t\t  GENMASK(6, 5) | GENMASK(3, 0), val);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}