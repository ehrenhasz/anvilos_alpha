{
  "module_name": "kmx61.c",
  "hash_id": "bdb94aa457886c30eaf83ce81c179a9d6f36f742f92bcf0054de94797ec6b893",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/kmx61.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include <linux/interrupt.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#define KMX61_DRV_NAME \"kmx61\"\n#define KMX61_IRQ_NAME \"kmx61_event\"\n\n#define KMX61_REG_WHO_AM_I\t0x00\n#define KMX61_REG_INS1\t\t0x01\n#define KMX61_REG_INS2\t\t0x02\n\n \n#define KMX61_ACC_XOUT_L\t0x0A\n#define KMX61_ACC_XOUT_H\t0x0B\n#define KMX61_ACC_YOUT_L\t0x0C\n#define KMX61_ACC_YOUT_H\t0x0D\n#define KMX61_ACC_ZOUT_L\t0x0E\n#define KMX61_ACC_ZOUT_H\t0x0F\n\n \n#define KMX61_TEMP_L\t\t0x10\n#define KMX61_TEMP_H\t\t0x11\n\n \n#define KMX61_MAG_XOUT_L\t0x12\n#define KMX61_MAG_XOUT_H\t0x13\n#define KMX61_MAG_YOUT_L\t0x14\n#define KMX61_MAG_YOUT_H\t0x15\n#define KMX61_MAG_ZOUT_L\t0x16\n#define KMX61_MAG_ZOUT_H\t0x17\n\n#define KMX61_REG_INL\t\t0x28\n#define KMX61_REG_STBY\t\t0x29\n#define KMX61_REG_CTRL1\t\t0x2A\n#define KMX61_REG_CTRL2\t\t0x2B\n#define KMX61_REG_ODCNTL\t0x2C\n#define KMX61_REG_INC1\t\t0x2D\n\n#define KMX61_REG_WUF_THRESH\t0x3D\n#define KMX61_REG_WUF_TIMER\t0x3E\n\n#define KMX61_ACC_STBY_BIT\tBIT(0)\n#define KMX61_MAG_STBY_BIT\tBIT(1)\n#define KMX61_ACT_STBY_BIT\tBIT(7)\n\n#define KMX61_ALL_STBY\t\t(KMX61_ACC_STBY_BIT | KMX61_MAG_STBY_BIT)\n\n#define KMX61_REG_INS1_BIT_WUFS\t\tBIT(1)\n\n#define KMX61_REG_INS2_BIT_ZP\t\tBIT(0)\n#define KMX61_REG_INS2_BIT_ZN\t\tBIT(1)\n#define KMX61_REG_INS2_BIT_YP\t\tBIT(2)\n#define KMX61_REG_INS2_BIT_YN\t\tBIT(3)\n#define KMX61_REG_INS2_BIT_XP\t\tBIT(4)\n#define KMX61_REG_INS2_BIT_XN\t\tBIT(5)\n\n#define KMX61_REG_CTRL1_GSEL_MASK\t0x03\n\n#define KMX61_REG_CTRL1_BIT_RES\t\tBIT(4)\n#define KMX61_REG_CTRL1_BIT_DRDYE\tBIT(5)\n#define KMX61_REG_CTRL1_BIT_WUFE\tBIT(6)\n#define KMX61_REG_CTRL1_BIT_BTSE\tBIT(7)\n\n#define KMX61_REG_INC1_BIT_WUFS\t\tBIT(0)\n#define KMX61_REG_INC1_BIT_DRDYM\tBIT(1)\n#define KMX61_REG_INC1_BIT_DRDYA\tBIT(2)\n#define KMX61_REG_INC1_BIT_IEN\t\tBIT(5)\n\n#define KMX61_ACC_ODR_SHIFT\t0\n#define KMX61_MAG_ODR_SHIFT\t4\n#define KMX61_ACC_ODR_MASK\t0x0F\n#define KMX61_MAG_ODR_MASK\t0xF0\n\n#define KMX61_OWUF_MASK\t\t0x7\n\n#define KMX61_DEFAULT_WAKE_THRESH\t1\n#define KMX61_DEFAULT_WAKE_DURATION\t1\n\n#define KMX61_SLEEP_DELAY_MS\t2000\n\n#define KMX61_CHIP_ID\t\t0x12\n\n \n#define KMX61_ACC\t0x01\n#define KMX61_MAG\t0x02\n\nstruct kmx61_data {\n\tstruct i2c_client *client;\n\n\t \n\tstruct mutex lock;\n\n\t \n\tbool acc_stby;\n\tbool mag_stby;\n\n\t \n\tbool acc_ps;\n\tbool mag_ps;\n\n\t \n\tu8 range;\n\tu8 odr_bits;\n\tu8 wake_thresh;\n\tu8 wake_duration;\n\n\t \n\tstruct iio_dev *acc_indio_dev;\n\tstruct iio_trigger *acc_dready_trig;\n\tstruct iio_trigger *motion_trig;\n\tbool acc_dready_trig_on;\n\tbool motion_trig_on;\n\tbool ev_enable_state;\n\n\t \n\tstruct iio_dev *mag_indio_dev;\n\tstruct iio_trigger *mag_dready_trig;\n\tbool mag_dready_trig_on;\n};\n\nenum kmx61_range {\n\tKMX61_RANGE_2G,\n\tKMX61_RANGE_4G,\n\tKMX61_RANGE_8G,\n};\n\nenum kmx61_axis {\n\tKMX61_AXIS_X,\n\tKMX61_AXIS_Y,\n\tKMX61_AXIS_Z,\n};\n\nstatic const u16 kmx61_uscale_table[] = {9582, 19163, 38326};\n\nstatic const struct {\n\tint val;\n\tint val2;\n} kmx61_samp_freq_table[] = { {12, 500000},\n\t\t\t{25, 0},\n\t\t\t{50, 0},\n\t\t\t{100, 0},\n\t\t\t{200, 0},\n\t\t\t{400, 0},\n\t\t\t{800, 0},\n\t\t\t{1600, 0},\n\t\t\t{0, 781000},\n\t\t\t{1, 563000},\n\t\t\t{3, 125000},\n\t\t\t{6, 250000} };\n\nstatic const struct {\n\tint val;\n\tint val2;\n\tint odr_bits;\n} kmx61_wake_up_odr_table[] = { {0, 781000, 0x00},\n\t\t\t\t {1, 563000, 0x01},\n\t\t\t\t {3, 125000, 0x02},\n\t\t\t\t {6, 250000, 0x03},\n\t\t\t\t {12, 500000, 0x04},\n\t\t\t\t {25, 0, 0x05},\n\t\t\t\t {50, 0, 0x06},\n\t\t\t\t {100, 0, 0x06},\n\t\t\t\t {200, 0, 0x06},\n\t\t\t\t {400, 0, 0x06},\n\t\t\t\t {800, 0, 0x06},\n\t\t\t\t {1600, 0, 0x06} };\n\nstatic IIO_CONST_ATTR(accel_scale_available, \"0.009582 0.019163 0.038326\");\nstatic IIO_CONST_ATTR(magn_scale_available, \"0.001465\");\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\n\t\"0.781000 1.563000 3.125000 6.250000 12.500000 25 50 100 200 400 800\");\n\nstatic struct attribute *kmx61_acc_attributes[] = {\n\t&iio_const_attr_accel_scale_available.dev_attr.attr,\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic struct attribute *kmx61_mag_attributes[] = {\n\t&iio_const_attr_magn_scale_available.dev_attr.attr,\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group kmx61_acc_attribute_group = {\n\t.attrs = kmx61_acc_attributes,\n};\n\nstatic const struct attribute_group kmx61_mag_attribute_group = {\n\t.attrs = kmx61_mag_attributes,\n};\n\nstatic const struct iio_event_spec kmx61_event = {\n\t.type = IIO_EV_TYPE_THRESH,\n\t.dir = IIO_EV_DIR_EITHER,\n\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t BIT(IIO_EV_INFO_PERIOD),\n};\n\n#define KMX61_ACC_CHAN(_axis) { \\\n\t.type = IIO_ACCEL, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_ ## _axis, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.address = KMX61_ACC, \\\n\t.scan_index = KMX61_AXIS_ ## _axis, \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = 12, \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 4, \\\n\t\t.endianness = IIO_LE, \\\n\t}, \\\n\t.event_spec = &kmx61_event, \\\n\t.num_event_specs = 1 \\\n}\n\n#define KMX61_MAG_CHAN(_axis) { \\\n\t.type = IIO_MAGN, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_ ## _axis, \\\n\t.address = KMX61_MAG, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.scan_index = KMX61_AXIS_ ## _axis, \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = 14, \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 2, \\\n\t\t.endianness = IIO_LE, \\\n\t}, \\\n}\n\nstatic const struct iio_chan_spec kmx61_acc_channels[] = {\n\tKMX61_ACC_CHAN(X),\n\tKMX61_ACC_CHAN(Y),\n\tKMX61_ACC_CHAN(Z),\n};\n\nstatic const struct iio_chan_spec kmx61_mag_channels[] = {\n\tKMX61_MAG_CHAN(X),\n\tKMX61_MAG_CHAN(Y),\n\tKMX61_MAG_CHAN(Z),\n};\n\nstatic void kmx61_set_data(struct iio_dev *indio_dev, struct kmx61_data *data)\n{\n\tstruct kmx61_data **priv = iio_priv(indio_dev);\n\n\t*priv = data;\n}\n\nstatic struct kmx61_data *kmx61_get_data(struct iio_dev *indio_dev)\n{\n\treturn *(struct kmx61_data **)iio_priv(indio_dev);\n}\n\nstatic int kmx61_convert_freq_to_bit(int val, int val2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(kmx61_samp_freq_table); i++)\n\t\tif (val == kmx61_samp_freq_table[i].val &&\n\t\t    val2 == kmx61_samp_freq_table[i].val2)\n\t\t\treturn i;\n\treturn -EINVAL;\n}\n\nstatic int kmx61_convert_wake_up_odr_to_bit(int val, int val2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(kmx61_wake_up_odr_table); ++i)\n\t\tif (kmx61_wake_up_odr_table[i].val == val &&\n\t\t\tkmx61_wake_up_odr_table[i].val2 == val2)\n\t\t\t\treturn kmx61_wake_up_odr_table[i].odr_bits;\n\treturn -EINVAL;\n}\n\n \nstatic int kmx61_set_mode(struct kmx61_data *data, u8 mode, u8 device,\n\t\t\t  bool update)\n{\n\tint ret;\n\tint acc_stby = -1, mag_stby = -1;\n\n\tret = i2c_smbus_read_byte_data(data->client, KMX61_REG_STBY);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error reading reg_stby\\n\");\n\t\treturn ret;\n\t}\n\tif (device & KMX61_ACC) {\n\t\tif (mode & KMX61_ACC_STBY_BIT) {\n\t\t\tret |= KMX61_ACC_STBY_BIT;\n\t\t\tacc_stby = 1;\n\t\t} else {\n\t\t\tret &= ~KMX61_ACC_STBY_BIT;\n\t\t\tacc_stby = 0;\n\t\t}\n\t}\n\n\tif (device & KMX61_MAG) {\n\t\tif (mode & KMX61_MAG_STBY_BIT) {\n\t\t\tret |= KMX61_MAG_STBY_BIT;\n\t\t\tmag_stby = 1;\n\t\t} else {\n\t\t\tret &= ~KMX61_MAG_STBY_BIT;\n\t\t\tmag_stby = 0;\n\t\t}\n\t}\n\n\tif (mode & KMX61_ACT_STBY_BIT)\n\t\tret |= KMX61_ACT_STBY_BIT;\n\n\tret = i2c_smbus_write_byte_data(data->client, KMX61_REG_STBY, ret);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error writing reg_stby\\n\");\n\t\treturn ret;\n\t}\n\n\tif (acc_stby != -1 && update)\n\t\tdata->acc_stby = acc_stby;\n\tif (mag_stby != -1 && update)\n\t\tdata->mag_stby = mag_stby;\n\n\treturn 0;\n}\n\nstatic int kmx61_get_mode(struct kmx61_data *data, u8 *mode, u8 device)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, KMX61_REG_STBY);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error reading reg_stby\\n\");\n\t\treturn ret;\n\t}\n\t*mode = 0;\n\n\tif (device & KMX61_ACC) {\n\t\tif (ret & KMX61_ACC_STBY_BIT)\n\t\t\t*mode |= KMX61_ACC_STBY_BIT;\n\t\telse\n\t\t\t*mode &= ~KMX61_ACC_STBY_BIT;\n\t}\n\n\tif (device & KMX61_MAG) {\n\t\tif (ret & KMX61_MAG_STBY_BIT)\n\t\t\t*mode |= KMX61_MAG_STBY_BIT;\n\t\telse\n\t\t\t*mode &= ~KMX61_MAG_STBY_BIT;\n\t}\n\n\treturn 0;\n}\n\nstatic int kmx61_set_wake_up_odr(struct kmx61_data *data, int val, int val2)\n{\n\tint ret, odr_bits;\n\n\todr_bits = kmx61_convert_wake_up_odr_to_bit(val, val2);\n\tif (odr_bits < 0)\n\t\treturn odr_bits;\n\n\tret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL2,\n\t\t\t\t\todr_bits);\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev, \"Error writing reg_ctrl2\\n\");\n\treturn ret;\n}\n\nstatic int kmx61_set_odr(struct kmx61_data *data, int val, int val2, u8 device)\n{\n\tint ret;\n\tu8 mode;\n\tint lodr_bits, odr_bits;\n\n\tret = kmx61_get_mode(data, &mode, KMX61_ACC | KMX61_MAG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlodr_bits = kmx61_convert_freq_to_bit(val, val2);\n\tif (lodr_bits < 0)\n\t\treturn lodr_bits;\n\n\t \n\tret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG,\n\t\t\t     true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\todr_bits = 0;\n\tif (device & KMX61_ACC)\n\t\todr_bits |= lodr_bits << KMX61_ACC_ODR_SHIFT;\n\tif (device & KMX61_MAG)\n\t\todr_bits |= lodr_bits << KMX61_MAG_ODR_SHIFT;\n\n\tret = i2c_smbus_write_byte_data(data->client, KMX61_REG_ODCNTL,\n\t\t\t\t\todr_bits);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->odr_bits = odr_bits;\n\n\tif (device & KMX61_ACC) {\n\t\tret = kmx61_set_wake_up_odr(data, val, val2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);\n}\n\nstatic int kmx61_get_odr(struct kmx61_data *data, int *val, int *val2,\n\t\t\t u8 device)\n{\n\tu8 lodr_bits;\n\n\tif (device & KMX61_ACC)\n\t\tlodr_bits = (data->odr_bits >> KMX61_ACC_ODR_SHIFT) &\n\t\t\t     KMX61_ACC_ODR_MASK;\n\telse if (device & KMX61_MAG)\n\t\tlodr_bits = (data->odr_bits >> KMX61_MAG_ODR_SHIFT) &\n\t\t\t     KMX61_MAG_ODR_MASK;\n\telse\n\t\treturn -EINVAL;\n\n\tif (lodr_bits >= ARRAY_SIZE(kmx61_samp_freq_table))\n\t\treturn -EINVAL;\n\n\t*val = kmx61_samp_freq_table[lodr_bits].val;\n\t*val2 = kmx61_samp_freq_table[lodr_bits].val2;\n\n\treturn 0;\n}\n\nstatic int kmx61_set_range(struct kmx61_data *data, u8 range)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, KMX61_REG_CTRL1);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error reading reg_ctrl1\\n\");\n\t\treturn ret;\n\t}\n\n\tret &= ~KMX61_REG_CTRL1_GSEL_MASK;\n\tret |= range & KMX61_REG_CTRL1_GSEL_MASK;\n\n\tret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error writing reg_ctrl1\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->range = range;\n\n\treturn 0;\n}\n\nstatic int kmx61_set_scale(struct kmx61_data *data, u16 uscale)\n{\n\tint ret, i;\n\tu8  mode;\n\n\tfor (i = 0; i < ARRAY_SIZE(kmx61_uscale_table); i++) {\n\t\tif (kmx61_uscale_table[i] == uscale) {\n\t\t\tret = kmx61_get_mode(data, &mode,\n\t\t\t\t\t     KMX61_ACC | KMX61_MAG);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tret = kmx61_set_mode(data, KMX61_ALL_STBY,\n\t\t\t\t\t     KMX61_ACC | KMX61_MAG, true);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tret = kmx61_set_range(data, i);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\treturn  kmx61_set_mode(data, mode,\n\t\t\t\t\t       KMX61_ACC | KMX61_MAG, true);\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int kmx61_chip_init(struct kmx61_data *data)\n{\n\tint ret, val, val2;\n\n\tret = i2c_smbus_read_byte_data(data->client, KMX61_REG_WHO_AM_I);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error reading who_am_i\\n\");\n\t\treturn ret;\n\t}\n\n\tif (ret != KMX61_CHIP_ID) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"Wrong chip id, got %x expected %x\\n\",\n\t\t\t ret, KMX61_CHIP_ID);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = kmx61_set_range(data, KMX61_RANGE_4G);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, KMX61_REG_ODCNTL);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error reading reg_odcntl\\n\");\n\t\treturn ret;\n\t}\n\tdata->odr_bits = ret;\n\n\t \n\tret = kmx61_get_odr(data, &val, &val2, KMX61_ACC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = kmx61_set_wake_up_odr(data, val, val2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = kmx61_set_mode(data, 0, KMX61_ACC | KMX61_MAG, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->wake_thresh = KMX61_DEFAULT_WAKE_THRESH;\n\tdata->wake_duration = KMX61_DEFAULT_WAKE_DURATION;\n\n\treturn 0;\n}\n\nstatic int kmx61_setup_new_data_interrupt(struct kmx61_data *data,\n\t\t\t\t\t  bool status, u8 device)\n{\n\tu8 mode;\n\tint ret;\n\n\tret = kmx61_get_mode(data, &mode, KMX61_ACC | KMX61_MAG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INC1);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error reading reg_ctrl1\\n\");\n\t\treturn ret;\n\t}\n\n\tif (status) {\n\t\tret |= KMX61_REG_INC1_BIT_IEN;\n\t\tif (device & KMX61_ACC)\n\t\t\tret |= KMX61_REG_INC1_BIT_DRDYA;\n\t\tif (device & KMX61_MAG)\n\t\t\tret |=  KMX61_REG_INC1_BIT_DRDYM;\n\t} else {\n\t\tret &= ~KMX61_REG_INC1_BIT_IEN;\n\t\tif (device & KMX61_ACC)\n\t\t\tret &= ~KMX61_REG_INC1_BIT_DRDYA;\n\t\tif (device & KMX61_MAG)\n\t\t\tret &= ~KMX61_REG_INC1_BIT_DRDYM;\n\t}\n\tret = i2c_smbus_write_byte_data(data->client, KMX61_REG_INC1, ret);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error writing reg_int_ctrl1\\n\");\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_read_byte_data(data->client, KMX61_REG_CTRL1);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error reading reg_ctrl1\\n\");\n\t\treturn ret;\n\t}\n\n\tif (status)\n\t\tret |= KMX61_REG_CTRL1_BIT_DRDYE;\n\telse\n\t\tret &= ~KMX61_REG_CTRL1_BIT_DRDYE;\n\n\tret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error writing reg_ctrl1\\n\");\n\t\treturn ret;\n\t}\n\n\treturn kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);\n}\n\nstatic int kmx61_chip_update_thresholds(struct kmx61_data *data)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tKMX61_REG_WUF_TIMER,\n\t\t\t\t\tdata->wake_duration);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error writing reg_wuf_timer\\n\");\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tKMX61_REG_WUF_THRESH,\n\t\t\t\t\tdata->wake_thresh);\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev, \"Error writing reg_wuf_thresh\\n\");\n\n\treturn ret;\n}\n\nstatic int kmx61_setup_any_motion_interrupt(struct kmx61_data *data,\n\t\t\t\t\t    bool status)\n{\n\tu8 mode;\n\tint ret;\n\n\tret = kmx61_get_mode(data, &mode, KMX61_ACC | KMX61_MAG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = kmx61_chip_update_thresholds(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INC1);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error reading reg_inc1\\n\");\n\t\treturn ret;\n\t}\n\tif (status)\n\t\tret |= (KMX61_REG_INC1_BIT_IEN | KMX61_REG_INC1_BIT_WUFS);\n\telse\n\t\tret &= ~(KMX61_REG_INC1_BIT_IEN | KMX61_REG_INC1_BIT_WUFS);\n\n\tret = i2c_smbus_write_byte_data(data->client, KMX61_REG_INC1, ret);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error writing reg_inc1\\n\");\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_read_byte_data(data->client, KMX61_REG_CTRL1);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error reading reg_ctrl1\\n\");\n\t\treturn ret;\n\t}\n\n\tif (status)\n\t\tret |= KMX61_REG_CTRL1_BIT_WUFE | KMX61_REG_CTRL1_BIT_BTSE;\n\telse\n\t\tret &= ~(KMX61_REG_CTRL1_BIT_WUFE | KMX61_REG_CTRL1_BIT_BTSE);\n\n\tret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error writing reg_ctrl1\\n\");\n\t\treturn ret;\n\t}\n\tmode |= KMX61_ACT_STBY_BIT;\n\treturn kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);\n}\n\n \nstatic int kmx61_set_power_state(struct kmx61_data *data, bool on, u8 device)\n{\n#ifdef CONFIG_PM\n\tint ret;\n\n\tif (device & KMX61_ACC) {\n\t\tif (on && !data->acc_ps && !data->mag_stby) {\n\t\t\tret = kmx61_set_mode(data, 0, KMX61_ACC, true);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tdata->acc_ps = on;\n\t}\n\tif (device & KMX61_MAG) {\n\t\tif (on && !data->mag_ps && !data->acc_stby) {\n\t\t\tret = kmx61_set_mode(data, 0, KMX61_MAG, true);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tdata->mag_ps = on;\n\t}\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(&data->client->dev);\n\t} else {\n\t\tpm_runtime_mark_last_busy(&data->client->dev);\n\t\tret = pm_runtime_put_autosuspend(&data->client->dev);\n\t}\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"Failed: kmx61_set_power_state for %d, ret %d\\n\",\n\t\t\ton, ret);\n\n\t\treturn ret;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int kmx61_read_measurement(struct kmx61_data *data, u8 base, u8 offset)\n{\n\tint ret;\n\tu8 reg = base + offset * 2;\n\n\tret = i2c_smbus_read_word_data(data->client, reg);\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev, \"failed to read reg at %x\\n\", reg);\n\n\treturn ret;\n}\n\nstatic int kmx61_read_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan, int *val,\n\t\t\t  int *val2, long mask)\n{\n\tint ret;\n\tu8 base_reg;\n\tstruct kmx61_data *data = kmx61_get_data(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ACCEL:\n\t\t\tbase_reg = KMX61_ACC_XOUT_L;\n\t\t\tbreak;\n\t\tcase IIO_MAGN:\n\t\t\tbase_reg = KMX61_MAG_XOUT_L;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmutex_lock(&data->lock);\n\n\t\tret = kmx61_set_power_state(data, true, chan->address);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = kmx61_read_measurement(data, base_reg, chan->scan_index);\n\t\tif (ret < 0) {\n\t\t\tkmx61_set_power_state(data, false, chan->address);\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn ret;\n\t\t}\n\t\t*val = sign_extend32(ret >> chan->scan_type.shift,\n\t\t\t\t     chan->scan_type.realbits - 1);\n\t\tret = kmx61_set_power_state(data, false, chan->address);\n\n\t\tmutex_unlock(&data->lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ACCEL:\n\t\t\t*val = 0;\n\t\t\t*val2 = kmx61_uscale_table[data->range];\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_MAGN:\n\t\t\t \n\t\t\t*val = 0;\n\t\t\t*val2 = 1465;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (chan->type != IIO_ACCEL && chan->type != IIO_MAGN)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&data->lock);\n\t\tret = kmx61_get_odr(data, val, val2, chan->address);\n\t\tmutex_unlock(&data->lock);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int kmx61_write_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan, int val,\n\t\t\t   int val2, long mask)\n{\n\tint ret;\n\tstruct kmx61_data *data = kmx61_get_data(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (chan->type != IIO_ACCEL && chan->type != IIO_MAGN)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&data->lock);\n\t\tret = kmx61_set_odr(data, val, val2, chan->address);\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ACCEL:\n\t\t\tif (val != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tmutex_lock(&data->lock);\n\t\t\tret = kmx61_set_scale(data, val2);\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int kmx61_read_event(struct iio_dev *indio_dev,\n\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t    enum iio_event_type type,\n\t\t\t    enum iio_event_direction dir,\n\t\t\t    enum iio_event_info info,\n\t\t\t    int *val, int *val2)\n{\n\tstruct kmx61_data *data = kmx61_get_data(indio_dev);\n\n\t*val2 = 0;\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\t*val = data->wake_thresh;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_EV_INFO_PERIOD:\n\t\t*val = data->wake_duration;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int kmx61_write_event(struct iio_dev *indio_dev,\n\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t     enum iio_event_type type,\n\t\t\t     enum iio_event_direction dir,\n\t\t\t     enum iio_event_info info,\n\t\t\t     int val, int val2)\n{\n\tstruct kmx61_data *data = kmx61_get_data(indio_dev);\n\n\tif (data->ev_enable_state)\n\t\treturn -EBUSY;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tdata->wake_thresh = val;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_EV_INFO_PERIOD:\n\t\tdata->wake_duration = val;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int kmx61_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t   enum iio_event_type type,\n\t\t\t\t   enum iio_event_direction dir)\n{\n\tstruct kmx61_data *data = kmx61_get_data(indio_dev);\n\n\treturn data->ev_enable_state;\n}\n\nstatic int kmx61_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir,\n\t\t\t\t    int state)\n{\n\tstruct kmx61_data *data = kmx61_get_data(indio_dev);\n\tint ret = 0;\n\n\tif (state && data->ev_enable_state)\n\t\treturn 0;\n\n\tmutex_lock(&data->lock);\n\n\tif (!state && data->motion_trig_on) {\n\t\tdata->ev_enable_state = false;\n\t\tgoto err_unlock;\n\t}\n\n\tret = kmx61_set_power_state(data, state, KMX61_ACC);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\tret = kmx61_setup_any_motion_interrupt(data, state);\n\tif (ret < 0) {\n\t\tkmx61_set_power_state(data, false, KMX61_ACC);\n\t\tgoto err_unlock;\n\t}\n\n\tdata->ev_enable_state = state;\n\nerr_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int kmx61_acc_validate_trigger(struct iio_dev *indio_dev,\n\t\t\t\t      struct iio_trigger *trig)\n{\n\tstruct kmx61_data *data = kmx61_get_data(indio_dev);\n\n\tif (data->acc_dready_trig != trig && data->motion_trig != trig)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int kmx61_mag_validate_trigger(struct iio_dev *indio_dev,\n\t\t\t\t      struct iio_trigger *trig)\n{\n\tstruct kmx61_data *data = kmx61_get_data(indio_dev);\n\n\tif (data->mag_dready_trig != trig)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct iio_info kmx61_acc_info = {\n\t.read_raw\t\t= kmx61_read_raw,\n\t.write_raw\t\t= kmx61_write_raw,\n\t.attrs\t\t\t= &kmx61_acc_attribute_group,\n\t.read_event_value\t= kmx61_read_event,\n\t.write_event_value\t= kmx61_write_event,\n\t.read_event_config\t= kmx61_read_event_config,\n\t.write_event_config\t= kmx61_write_event_config,\n\t.validate_trigger\t= kmx61_acc_validate_trigger,\n};\n\nstatic const struct iio_info kmx61_mag_info = {\n\t.read_raw\t\t= kmx61_read_raw,\n\t.write_raw\t\t= kmx61_write_raw,\n\t.attrs\t\t\t= &kmx61_mag_attribute_group,\n\t.validate_trigger\t= kmx61_mag_validate_trigger,\n};\n\n\nstatic int kmx61_data_rdy_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t    bool state)\n{\n\tint ret = 0;\n\tu8 device;\n\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct kmx61_data *data = kmx61_get_data(indio_dev);\n\n\tmutex_lock(&data->lock);\n\n\tif (!state && data->ev_enable_state && data->motion_trig_on) {\n\t\tdata->motion_trig_on = false;\n\t\tgoto err_unlock;\n\t}\n\n\tif (data->acc_dready_trig == trig || data->motion_trig == trig)\n\t\tdevice = KMX61_ACC;\n\telse\n\t\tdevice = KMX61_MAG;\n\n\tret = kmx61_set_power_state(data, state, device);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\tif (data->acc_dready_trig == trig || data->mag_dready_trig == trig)\n\t\tret = kmx61_setup_new_data_interrupt(data, state, device);\n\telse\n\t\tret = kmx61_setup_any_motion_interrupt(data, state);\n\tif (ret < 0) {\n\t\tkmx61_set_power_state(data, false, device);\n\t\tgoto err_unlock;\n\t}\n\n\tif (data->acc_dready_trig == trig)\n\t\tdata->acc_dready_trig_on = state;\n\telse if (data->mag_dready_trig == trig)\n\t\tdata->mag_dready_trig_on = state;\n\telse\n\t\tdata->motion_trig_on = state;\nerr_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic void kmx61_trig_reenable(struct iio_trigger *trig)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct kmx61_data *data = kmx61_get_data(indio_dev);\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INL);\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev, \"Error reading reg_inl\\n\");\n}\n\nstatic const struct iio_trigger_ops kmx61_trigger_ops = {\n\t.set_trigger_state = kmx61_data_rdy_trigger_set_state,\n\t.reenable = kmx61_trig_reenable,\n};\n\nstatic irqreturn_t kmx61_event_handler(int irq, void *private)\n{\n\tstruct kmx61_data *data = private;\n\tstruct iio_dev *indio_dev = data->acc_indio_dev;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INS1);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error reading reg_ins1\\n\");\n\t\tgoto ack_intr;\n\t}\n\n\tif (ret & KMX61_REG_INS1_BIT_WUFS) {\n\t\tret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INS2);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&data->client->dev, \"Error reading reg_ins2\\n\");\n\t\t\tgoto ack_intr;\n\t\t}\n\n\t\tif (ret & KMX61_REG_INS2_BIT_XN)\n\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t       0,\n\t\t\t\t       IIO_MOD_X,\n\t\t\t\t       IIO_EV_TYPE_THRESH,\n\t\t\t\t       IIO_EV_DIR_FALLING),\n\t\t\t\t       0);\n\n\t\tif (ret & KMX61_REG_INS2_BIT_XP)\n\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t       0,\n\t\t\t\t       IIO_MOD_X,\n\t\t\t\t       IIO_EV_TYPE_THRESH,\n\t\t\t\t       IIO_EV_DIR_RISING),\n\t\t\t\t       0);\n\n\t\tif (ret & KMX61_REG_INS2_BIT_YN)\n\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t       0,\n\t\t\t\t       IIO_MOD_Y,\n\t\t\t\t       IIO_EV_TYPE_THRESH,\n\t\t\t\t       IIO_EV_DIR_FALLING),\n\t\t\t\t       0);\n\n\t\tif (ret & KMX61_REG_INS2_BIT_YP)\n\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t       0,\n\t\t\t\t       IIO_MOD_Y,\n\t\t\t\t       IIO_EV_TYPE_THRESH,\n\t\t\t\t       IIO_EV_DIR_RISING),\n\t\t\t\t       0);\n\n\t\tif (ret & KMX61_REG_INS2_BIT_ZN)\n\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t       0,\n\t\t\t\t       IIO_MOD_Z,\n\t\t\t\t       IIO_EV_TYPE_THRESH,\n\t\t\t\t       IIO_EV_DIR_FALLING),\n\t\t\t\t       0);\n\n\t\tif (ret & KMX61_REG_INS2_BIT_ZP)\n\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t       0,\n\t\t\t\t       IIO_MOD_Z,\n\t\t\t\t       IIO_EV_TYPE_THRESH,\n\t\t\t\t       IIO_EV_DIR_RISING),\n\t\t\t\t       0);\n\t}\n\nack_intr:\n\tret = i2c_smbus_read_byte_data(data->client, KMX61_REG_CTRL1);\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev, \"Error reading reg_ctrl1\\n\");\n\n\tret |= KMX61_REG_CTRL1_BIT_RES;\n\tret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev, \"Error writing reg_ctrl1\\n\");\n\n\tret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INL);\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev, \"Error reading reg_inl\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t kmx61_data_rdy_trig_poll(int irq, void *private)\n{\n\tstruct kmx61_data *data = private;\n\n\tif (data->acc_dready_trig_on)\n\t\tiio_trigger_poll(data->acc_dready_trig);\n\tif (data->mag_dready_trig_on)\n\t\tiio_trigger_poll(data->mag_dready_trig);\n\n\tif (data->motion_trig_on)\n\t\tiio_trigger_poll(data->motion_trig);\n\n\tif (data->ev_enable_state)\n\t\treturn IRQ_WAKE_THREAD;\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t kmx61_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct kmx61_data *data = kmx61_get_data(indio_dev);\n\tint bit, ret, i = 0;\n\tu8 base;\n\ts16 buffer[8];\n\n\tif (indio_dev == data->acc_indio_dev)\n\t\tbase = KMX61_ACC_XOUT_L;\n\telse\n\t\tbase = KMX61_MAG_XOUT_L;\n\n\tmutex_lock(&data->lock);\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\tret = kmx61_read_measurement(data, base, bit);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&data->lock);\n\t\t\tgoto err;\n\t\t}\n\t\tbuffer[i++] = ret;\n\t}\n\tmutex_unlock(&data->lock);\n\n\tiio_push_to_buffers(indio_dev, buffer);\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const char *kmx61_match_acpi_device(struct device *dev)\n{\n\tconst struct acpi_device_id *id;\n\n\tid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\tif (!id)\n\t\treturn NULL;\n\treturn dev_name(dev);\n}\n\nstatic struct iio_dev *kmx61_indiodev_setup(struct kmx61_data *data,\n\t\t\t\t\t    const struct iio_info *info,\n\t\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t\t    int num_channels,\n\t\t\t\t\t    const char *name)\n{\n\tstruct iio_dev *indio_dev;\n\n\tindio_dev = devm_iio_device_alloc(&data->client->dev, sizeof(data));\n\tif (!indio_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkmx61_set_data(indio_dev, data);\n\n\tindio_dev->channels = chan;\n\tindio_dev->num_channels = num_channels;\n\tindio_dev->name = name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = info;\n\n\treturn indio_dev;\n}\n\nstatic struct iio_trigger *kmx61_trigger_setup(struct kmx61_data *data,\n\t\t\t\t\t       struct iio_dev *indio_dev,\n\t\t\t\t\t       const char *tag)\n{\n\tstruct iio_trigger *trig;\n\tint ret;\n\n\ttrig = devm_iio_trigger_alloc(&data->client->dev,\n\t\t\t\t      \"%s-%s-dev%d\",\n\t\t\t\t      indio_dev->name,\n\t\t\t\t      tag,\n\t\t\t\t      iio_device_id(indio_dev));\n\tif (!trig)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttrig->ops = &kmx61_trigger_ops;\n\tiio_trigger_set_drvdata(trig, indio_dev);\n\n\tret = iio_trigger_register(trig);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn trig;\n}\n\nstatic int kmx61_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tint ret;\n\tstruct kmx61_data *data;\n\tconst char *name = NULL;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tdata->client = client;\n\n\tmutex_init(&data->lock);\n\n\tif (id)\n\t\tname = id->name;\n\telse if (ACPI_HANDLE(&client->dev))\n\t\tname = kmx61_match_acpi_device(&client->dev);\n\telse\n\t\treturn -ENODEV;\n\n\tdata->acc_indio_dev =\n\t\tkmx61_indiodev_setup(data, &kmx61_acc_info,\n\t\t\t\t     kmx61_acc_channels,\n\t\t\t\t     ARRAY_SIZE(kmx61_acc_channels),\n\t\t\t\t     name);\n\tif (IS_ERR(data->acc_indio_dev))\n\t\treturn PTR_ERR(data->acc_indio_dev);\n\n\tdata->mag_indio_dev =\n\t\tkmx61_indiodev_setup(data, &kmx61_mag_info,\n\t\t\t\t     kmx61_mag_channels,\n\t\t\t\t     ARRAY_SIZE(kmx61_mag_channels),\n\t\t\t\t     name);\n\tif (IS_ERR(data->mag_indio_dev))\n\t\treturn PTR_ERR(data->mag_indio_dev);\n\n\tret = kmx61_chip_init(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (client->irq > 0) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tkmx61_data_rdy_trig_poll,\n\t\t\t\t\t\tkmx61_event_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING,\n\t\t\t\t\t\tKMX61_IRQ_NAME,\n\t\t\t\t\t\tdata);\n\t\tif (ret)\n\t\t\tgoto err_chip_uninit;\n\n\t\tdata->acc_dready_trig =\n\t\t\tkmx61_trigger_setup(data, data->acc_indio_dev,\n\t\t\t\t\t    \"dready\");\n\t\tif (IS_ERR(data->acc_dready_trig)) {\n\t\t\tret = PTR_ERR(data->acc_dready_trig);\n\t\t\tgoto err_chip_uninit;\n\t\t}\n\n\t\tdata->mag_dready_trig =\n\t\t\tkmx61_trigger_setup(data, data->mag_indio_dev,\n\t\t\t\t\t    \"dready\");\n\t\tif (IS_ERR(data->mag_dready_trig)) {\n\t\t\tret = PTR_ERR(data->mag_dready_trig);\n\t\t\tgoto err_trigger_unregister_acc_dready;\n\t\t}\n\n\t\tdata->motion_trig =\n\t\t\tkmx61_trigger_setup(data, data->acc_indio_dev,\n\t\t\t\t\t    \"any-motion\");\n\t\tif (IS_ERR(data->motion_trig)) {\n\t\t\tret = PTR_ERR(data->motion_trig);\n\t\t\tgoto err_trigger_unregister_mag_dready;\n\t\t}\n\n\t\tret = iio_triggered_buffer_setup(data->acc_indio_dev,\n\t\t\t\t\t\t &iio_pollfunc_store_time,\n\t\t\t\t\t\t kmx61_trigger_handler,\n\t\t\t\t\t\t NULL);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\"Failed to setup acc triggered buffer\\n\");\n\t\t\tgoto err_trigger_unregister_motion;\n\t\t}\n\n\t\tret = iio_triggered_buffer_setup(data->mag_indio_dev,\n\t\t\t\t\t\t &iio_pollfunc_store_time,\n\t\t\t\t\t\t kmx61_trigger_handler,\n\t\t\t\t\t\t NULL);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\"Failed to setup mag triggered buffer\\n\");\n\t\t\tgoto err_buffer_cleanup_acc;\n\t\t}\n\t}\n\n\tret = pm_runtime_set_active(&client->dev);\n\tif (ret < 0)\n\t\tgoto err_buffer_cleanup_mag;\n\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev, KMX61_SLEEP_DELAY_MS);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\tret = iio_device_register(data->acc_indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to register acc iio device\\n\");\n\t\tgoto err_pm_cleanup;\n\t}\n\n\tret = iio_device_register(data->mag_indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to register mag iio device\\n\");\n\t\tgoto err_iio_unregister_acc;\n\t}\n\n\treturn 0;\n\nerr_iio_unregister_acc:\n\tiio_device_unregister(data->acc_indio_dev);\nerr_pm_cleanup:\n\tpm_runtime_dont_use_autosuspend(&client->dev);\n\tpm_runtime_disable(&client->dev);\nerr_buffer_cleanup_mag:\n\tif (client->irq > 0)\n\t\tiio_triggered_buffer_cleanup(data->mag_indio_dev);\nerr_buffer_cleanup_acc:\n\tif (client->irq > 0)\n\t\tiio_triggered_buffer_cleanup(data->acc_indio_dev);\nerr_trigger_unregister_motion:\n\tiio_trigger_unregister(data->motion_trig);\nerr_trigger_unregister_mag_dready:\n\tiio_trigger_unregister(data->mag_dready_trig);\nerr_trigger_unregister_acc_dready:\n\tiio_trigger_unregister(data->acc_dready_trig);\nerr_chip_uninit:\n\tkmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);\n\treturn ret;\n}\n\nstatic void kmx61_remove(struct i2c_client *client)\n{\n\tstruct kmx61_data *data = i2c_get_clientdata(client);\n\n\tiio_device_unregister(data->acc_indio_dev);\n\tiio_device_unregister(data->mag_indio_dev);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tif (client->irq > 0) {\n\t\tiio_triggered_buffer_cleanup(data->acc_indio_dev);\n\t\tiio_triggered_buffer_cleanup(data->mag_indio_dev);\n\t\tiio_trigger_unregister(data->acc_dready_trig);\n\t\tiio_trigger_unregister(data->mag_dready_trig);\n\t\tiio_trigger_unregister(data->motion_trig);\n\t}\n\n\tmutex_lock(&data->lock);\n\tkmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);\n\tmutex_unlock(&data->lock);\n}\n\nstatic int kmx61_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct kmx61_data *data = i2c_get_clientdata(to_i2c_client(dev));\n\n\tmutex_lock(&data->lock);\n\tret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG,\n\t\t\t     false);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int kmx61_resume(struct device *dev)\n{\n\tu8 stby = 0;\n\tstruct kmx61_data *data = i2c_get_clientdata(to_i2c_client(dev));\n\n\tif (data->acc_stby)\n\t\tstby |= KMX61_ACC_STBY_BIT;\n\tif (data->mag_stby)\n\t\tstby |= KMX61_MAG_STBY_BIT;\n\n\treturn kmx61_set_mode(data, stby, KMX61_ACC | KMX61_MAG, true);\n}\n\nstatic int kmx61_runtime_suspend(struct device *dev)\n{\n\tstruct kmx61_data *data = i2c_get_clientdata(to_i2c_client(dev));\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int kmx61_runtime_resume(struct device *dev)\n{\n\tstruct kmx61_data *data = i2c_get_clientdata(to_i2c_client(dev));\n\tu8 stby = 0;\n\n\tif (!data->acc_ps)\n\t\tstby |= KMX61_ACC_STBY_BIT;\n\tif (!data->mag_ps)\n\t\tstby |= KMX61_MAG_STBY_BIT;\n\n\treturn kmx61_set_mode(data, stby, KMX61_ACC | KMX61_MAG, true);\n}\n\nstatic const struct dev_pm_ops kmx61_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(kmx61_suspend, kmx61_resume)\n\tRUNTIME_PM_OPS(kmx61_runtime_suspend, kmx61_runtime_resume, NULL)\n};\n\nstatic const struct acpi_device_id kmx61_acpi_match[] = {\n\t{\"KMX61021\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(acpi, kmx61_acpi_match);\n\nstatic const struct i2c_device_id kmx61_id[] = {\n\t{\"kmx611021\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, kmx61_id);\n\nstatic struct i2c_driver kmx61_driver = {\n\t.driver = {\n\t\t.name = KMX61_DRV_NAME,\n\t\t.acpi_match_table = ACPI_PTR(kmx61_acpi_match),\n\t\t.pm = pm_ptr(&kmx61_pm_ops),\n\t},\n\t.probe\t\t= kmx61_probe,\n\t.remove\t\t= kmx61_remove,\n\t.id_table\t= kmx61_id,\n};\n\nmodule_i2c_driver(kmx61_driver);\n\nMODULE_AUTHOR(\"Daniel Baluta <daniel.baluta@intel.com>\");\nMODULE_DESCRIPTION(\"KMX61 accelerometer/magnetometer driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}