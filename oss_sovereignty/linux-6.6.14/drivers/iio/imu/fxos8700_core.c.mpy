{
  "module_name": "fxos8700_core.c",
  "hash_id": "7e65b94d1bd332c4ae099c95ecc229cab8bd57ee8e49d5a2b9c81ff2ea6bbe04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/fxos8700_core.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#include \"fxos8700.h\"\n\n \n#define FXOS8700_STATUS             0x00\n#define FXOS8700_OUT_X_MSB          0x01\n#define FXOS8700_OUT_X_LSB          0x02\n#define FXOS8700_OUT_Y_MSB          0x03\n#define FXOS8700_OUT_Y_LSB          0x04\n#define FXOS8700_OUT_Z_MSB          0x05\n#define FXOS8700_OUT_Z_LSB          0x06\n#define FXOS8700_F_SETUP            0x09\n#define FXOS8700_TRIG_CFG           0x0a\n#define FXOS8700_SYSMOD             0x0b\n#define FXOS8700_INT_SOURCE         0x0c\n#define FXOS8700_WHO_AM_I           0x0d\n#define FXOS8700_XYZ_DATA_CFG       0x0e\n#define FXOS8700_HP_FILTER_CUTOFF   0x0f\n#define FXOS8700_PL_STATUS          0x10\n#define FXOS8700_PL_CFG             0x11\n#define FXOS8700_PL_COUNT           0x12\n#define FXOS8700_PL_BF_ZCOMP        0x13\n#define FXOS8700_PL_THS_REG         0x14\n#define FXOS8700_A_FFMT_CFG         0x15\n#define FXOS8700_A_FFMT_SRC         0x16\n#define FXOS8700_A_FFMT_THS         0x17\n#define FXOS8700_A_FFMT_COUNT       0x18\n#define FXOS8700_TRANSIENT_CFG      0x1d\n#define FXOS8700_TRANSIENT_SRC      0x1e\n#define FXOS8700_TRANSIENT_THS      0x1f\n#define FXOS8700_TRANSIENT_COUNT    0x20\n#define FXOS8700_PULSE_CFG          0x21\n#define FXOS8700_PULSE_SRC          0x22\n#define FXOS8700_PULSE_THSX         0x23\n#define FXOS8700_PULSE_THSY         0x24\n#define FXOS8700_PULSE_THSZ         0x25\n#define FXOS8700_PULSE_TMLT         0x26\n#define FXOS8700_PULSE_LTCY         0x27\n#define FXOS8700_PULSE_WIND         0x28\n#define FXOS8700_ASLP_COUNT         0x29\n#define FXOS8700_CTRL_REG1          0x2a\n#define FXOS8700_CTRL_REG2          0x2b\n#define FXOS8700_CTRL_REG3          0x2c\n#define FXOS8700_CTRL_REG4          0x2d\n#define FXOS8700_CTRL_REG5          0x2e\n#define FXOS8700_OFF_X              0x2f\n#define FXOS8700_OFF_Y              0x30\n#define FXOS8700_OFF_Z              0x31\n#define FXOS8700_M_DR_STATUS        0x32\n#define FXOS8700_M_OUT_X_MSB        0x33\n#define FXOS8700_M_OUT_X_LSB        0x34\n#define FXOS8700_M_OUT_Y_MSB        0x35\n#define FXOS8700_M_OUT_Y_LSB        0x36\n#define FXOS8700_M_OUT_Z_MSB        0x37\n#define FXOS8700_M_OUT_Z_LSB        0x38\n#define FXOS8700_CMP_X_MSB          0x39\n#define FXOS8700_CMP_X_LSB          0x3a\n#define FXOS8700_CMP_Y_MSB          0x3b\n#define FXOS8700_CMP_Y_LSB          0x3c\n#define FXOS8700_CMP_Z_MSB          0x3d\n#define FXOS8700_CMP_Z_LSB          0x3e\n#define FXOS8700_M_OFF_X_MSB        0x3f\n#define FXOS8700_M_OFF_X_LSB        0x40\n#define FXOS8700_M_OFF_Y_MSB        0x41\n#define FXOS8700_M_OFF_Y_LSB        0x42\n#define FXOS8700_M_OFF_Z_MSB        0x43\n#define FXOS8700_M_OFF_Z_LSB        0x44\n#define FXOS8700_MAX_X_MSB          0x45\n#define FXOS8700_MAX_X_LSB          0x46\n#define FXOS8700_MAX_Y_MSB          0x47\n#define FXOS8700_MAX_Y_LSB          0x48\n#define FXOS8700_MAX_Z_MSB          0x49\n#define FXOS8700_MAX_Z_LSB          0x4a\n#define FXOS8700_MIN_X_MSB          0x4b\n#define FXOS8700_MIN_X_LSB          0x4c\n#define FXOS8700_MIN_Y_MSB          0x4d\n#define FXOS8700_MIN_Y_LSB          0x4e\n#define FXOS8700_MIN_Z_MSB          0x4f\n#define FXOS8700_MIN_Z_LSB          0x50\n#define FXOS8700_TEMP               0x51\n#define FXOS8700_M_THS_CFG          0x52\n#define FXOS8700_M_THS_SRC          0x53\n#define FXOS8700_M_THS_X_MSB        0x54\n#define FXOS8700_M_THS_X_LSB        0x55\n#define FXOS8700_M_THS_Y_MSB        0x56\n#define FXOS8700_M_THS_Y_LSB        0x57\n#define FXOS8700_M_THS_Z_MSB        0x58\n#define FXOS8700_M_THS_Z_LSB        0x59\n#define FXOS8700_M_THS_COUNT        0x5a\n#define FXOS8700_M_CTRL_REG1        0x5b\n#define FXOS8700_M_CTRL_REG2        0x5c\n#define FXOS8700_M_CTRL_REG3        0x5d\n#define FXOS8700_M_INT_SRC          0x5e\n#define FXOS8700_A_VECM_CFG         0x5f\n#define FXOS8700_A_VECM_THS_MSB     0x60\n#define FXOS8700_A_VECM_THS_LSB     0x61\n#define FXOS8700_A_VECM_CNT         0x62\n#define FXOS8700_A_VECM_INITX_MSB   0x63\n#define FXOS8700_A_VECM_INITX_LSB   0x64\n#define FXOS8700_A_VECM_INITY_MSB   0x65\n#define FXOS8700_A_VECM_INITY_LSB   0x66\n#define FXOS8700_A_VECM_INITZ_MSB   0x67\n#define FXOS8700_A_VECM_INITZ_LSB   0x68\n#define FXOS8700_M_VECM_CFG         0x69\n#define FXOS8700_M_VECM_THS_MSB     0x6a\n#define FXOS8700_M_VECM_THS_LSB     0x6b\n#define FXOS8700_M_VECM_CNT         0x6c\n#define FXOS8700_M_VECM_INITX_MSB   0x6d\n#define FXOS8700_M_VECM_INITX_LSB   0x6e\n#define FXOS8700_M_VECM_INITY_MSB   0x6f\n#define FXOS8700_M_VECM_INITY_LSB   0x70\n#define FXOS8700_M_VECM_INITZ_MSB   0x71\n#define FXOS8700_M_VECM_INITZ_LSB   0x72\n#define FXOS8700_A_FFMT_THS_X_MSB   0x73\n#define FXOS8700_A_FFMT_THS_X_LSB   0x74\n#define FXOS8700_A_FFMT_THS_Y_MSB   0x75\n#define FXOS8700_A_FFMT_THS_Y_LSB   0x76\n#define FXOS8700_A_FFMT_THS_Z_MSB   0x77\n#define FXOS8700_A_FFMT_THS_Z_LSB   0x78\n#define FXOS8700_A_TRAN_INIT_MSB    0x79\n#define FXOS8700_A_TRAN_INIT_LSB_X  0x7a\n#define FXOS8700_A_TRAN_INIT_LSB_Y  0x7b\n#define FXOS8700_A_TRAN_INIT_LSB_Z  0x7d\n#define FXOS8700_TM_NVM_LOCK        0x7e\n#define FXOS8700_NVM_DATA0_35       0x80\n#define FXOS8700_NVM_DATA_BNK3      0xa4\n#define FXOS8700_NVM_DATA_BNK2      0xa5\n#define FXOS8700_NVM_DATA_BNK1      0xa6\n#define FXOS8700_NVM_DATA_BNK0      0xa7\n\n \n#define FXOS8700_CTRL_ODR_MAX       0x00\n#define FXOS8700_CTRL_ODR_MSK       GENMASK(5, 3)\n\n \n#define FXOS8700_HMS_MASK           GENMASK(1, 0)\n#define FXOS8700_OS_MASK            GENMASK(4, 2)\n\n \n#define FXOS8700_MAXMIN_RST         BIT(2)\n#define FXOS8700_MAXMIN_DIS_THS     BIT(3)\n#define FXOS8700_MAXMIN_DIS         BIT(4)\n\n#define FXOS8700_ACTIVE             0x01\n#define FXOS8700_ACTIVE_MIN_USLEEP  4000  \n\n#define FXOS8700_DEVICE_ID          0xC7\n#define FXOS8700_PRE_DEVICE_ID      0xC4\n#define FXOS8700_DATA_BUF_SIZE      3\n\nstruct fxos8700_data {\n\tstruct regmap *regmap;\n\tstruct iio_trigger *trig;\n\t__be16 buf[FXOS8700_DATA_BUF_SIZE] __aligned(IIO_DMA_MINALIGN);\n};\n\n \nstatic const struct regmap_range read_range[] = {\n\t{\n\t\t.range_min = FXOS8700_STATUS,\n\t\t.range_max = FXOS8700_A_FFMT_COUNT,\n\t}, {\n\t\t.range_min = FXOS8700_TRANSIENT_CFG,\n\t\t.range_max = FXOS8700_A_FFMT_THS_Z_LSB,\n\t},\n};\n\nstatic const struct regmap_range write_range[] = {\n\t{\n\t\t.range_min = FXOS8700_F_SETUP,\n\t\t.range_max = FXOS8700_TRIG_CFG,\n\t}, {\n\t\t.range_min = FXOS8700_XYZ_DATA_CFG,\n\t\t.range_max = FXOS8700_HP_FILTER_CUTOFF,\n\t}, {\n\t\t.range_min = FXOS8700_PL_CFG,\n\t\t.range_max = FXOS8700_A_FFMT_CFG,\n\t}, {\n\t\t.range_min = FXOS8700_A_FFMT_THS,\n\t\t.range_max = FXOS8700_TRANSIENT_CFG,\n\t}, {\n\t\t.range_min = FXOS8700_TRANSIENT_THS,\n\t\t.range_max = FXOS8700_PULSE_CFG,\n\t}, {\n\t\t.range_min = FXOS8700_PULSE_THSX,\n\t\t.range_max = FXOS8700_OFF_Z,\n\t}, {\n\t\t.range_min = FXOS8700_M_OFF_X_MSB,\n\t\t.range_max = FXOS8700_M_OFF_Z_LSB,\n\t}, {\n\t\t.range_min = FXOS8700_M_THS_CFG,\n\t\t.range_max = FXOS8700_M_THS_CFG,\n\t}, {\n\t\t.range_min = FXOS8700_M_THS_X_MSB,\n\t\t.range_max = FXOS8700_M_CTRL_REG3,\n\t}, {\n\t\t.range_min = FXOS8700_A_VECM_CFG,\n\t\t.range_max = FXOS8700_A_FFMT_THS_Z_LSB,\n\t},\n};\n\nstatic const struct regmap_access_table driver_read_table = {\n\t.yes_ranges =   read_range,\n\t.n_yes_ranges = ARRAY_SIZE(read_range),\n};\n\nstatic const struct regmap_access_table driver_write_table = {\n\t.yes_ranges =   write_range,\n\t.n_yes_ranges = ARRAY_SIZE(write_range),\n};\n\nconst struct regmap_config fxos8700_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = FXOS8700_NVM_DATA_BNK0,\n\t.rd_table = &driver_read_table,\n\t.wr_table = &driver_write_table,\n};\nEXPORT_SYMBOL(fxos8700_regmap_config);\n\n#define FXOS8700_CHANNEL(_type, _axis) {\t\t\t\\\n\t.type = _type,\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##_axis,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |  \\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t\\\n}\n\nenum fxos8700_accel_scale_bits {\n\tMODE_2G = 0,\n\tMODE_4G,\n\tMODE_8G,\n};\n\n \nenum fxos8700_scan_axis {\n\tFXOS8700_SCAN_ACCEL_X = 0,\n\tFXOS8700_SCAN_ACCEL_Y,\n\tFXOS8700_SCAN_ACCEL_Z,\n\tFXOS8700_SCAN_MAGN_X,\n\tFXOS8700_SCAN_MAGN_Y,\n\tFXOS8700_SCAN_MAGN_Z,\n\tFXOS8700_SCAN_RHALL,\n\tFXOS8700_SCAN_TIMESTAMP,\n};\n\nenum fxos8700_sensor {\n\tFXOS8700_ACCEL\t= 0,\n\tFXOS8700_MAGN,\n\tFXOS8700_NUM_SENSORS  \n};\n\nenum fxos8700_int_pin {\n\tFXOS8700_PIN_INT1,\n\tFXOS8700_PIN_INT2\n};\n\nstruct fxos8700_scale {\n\tu8 bits;\n\tint uscale;\n};\n\nstruct fxos8700_odr {\n\tu8 bits;\n\tint odr;\n\tint uodr;\n};\n\nstatic const struct fxos8700_scale fxos8700_accel_scale[] = {\n\t{ MODE_2G, 244},\n\t{ MODE_4G, 488},\n\t{ MODE_8G, 976},\n};\n\n \nstatic const struct fxos8700_odr fxos8700_odr[] = {\n\t{0x00, 800, 0},\n\t{0x01, 400, 0},\n\t{0x02, 200, 0},\n\t{0x03, 100, 0},\n\t{0x04, 50, 0},\n\t{0x05, 12, 500000},\n\t{0x06, 6, 250000},\n\t{0x07, 1, 562500},\n};\n\nstatic const struct iio_chan_spec fxos8700_channels[] = {\n\tFXOS8700_CHANNEL(IIO_ACCEL, X),\n\tFXOS8700_CHANNEL(IIO_ACCEL, Y),\n\tFXOS8700_CHANNEL(IIO_ACCEL, Z),\n\tFXOS8700_CHANNEL(IIO_MAGN, X),\n\tFXOS8700_CHANNEL(IIO_MAGN, Y),\n\tFXOS8700_CHANNEL(IIO_MAGN, Z),\n\tIIO_CHAN_SOFT_TIMESTAMP(FXOS8700_SCAN_TIMESTAMP),\n};\n\nstatic enum fxos8700_sensor fxos8700_to_sensor(enum iio_chan_type iio_type)\n{\n\tswitch (iio_type) {\n\tcase IIO_ACCEL:\n\t\treturn FXOS8700_ACCEL;\n\tcase IIO_MAGN:\n\t\treturn FXOS8700_MAGN;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int fxos8700_set_active_mode(struct fxos8700_data *data,\n\t\t\t\t    enum fxos8700_sensor t, bool mode)\n{\n\tint ret;\n\n\tret = regmap_write(data->regmap, FXOS8700_CTRL_REG1, mode);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(FXOS8700_ACTIVE_MIN_USLEEP,\n\t\t     FXOS8700_ACTIVE_MIN_USLEEP + 1000);\n\n\treturn 0;\n}\n\nstatic int fxos8700_set_scale(struct fxos8700_data *data,\n\t\t\t      enum fxos8700_sensor t, int uscale)\n{\n\tint i, ret, val;\n\tbool active_mode;\n\tstatic const int scale_num = ARRAY_SIZE(fxos8700_accel_scale);\n\tstruct device *dev = regmap_get_device(data->regmap);\n\n\tif (t == FXOS8700_MAGN) {\n\t\tdev_err(dev, \"Magnetometer scale is locked at 0.001Gs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_read(data->regmap, FXOS8700_CTRL_REG1, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tactive_mode = val & FXOS8700_ACTIVE;\n\tif (active_mode) {\n\t\tret = regmap_write(data->regmap, FXOS8700_CTRL_REG1,\n\t\t\t\t   val & ~FXOS8700_ACTIVE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < scale_num; i++)\n\t\tif (fxos8700_accel_scale[i].uscale == uscale)\n\t\t\tbreak;\n\n\tif (i == scale_num)\n\t\treturn -EINVAL;\n\n\tret = regmap_write(data->regmap, FXOS8700_XYZ_DATA_CFG,\n\t\t\t    fxos8700_accel_scale[i].bits);\n\tif (ret)\n\t\treturn ret;\n\treturn regmap_write(data->regmap, FXOS8700_CTRL_REG1,\n\t\t\t\t  active_mode);\n}\n\nstatic int fxos8700_get_scale(struct fxos8700_data *data,\n\t\t\t      enum fxos8700_sensor t, int *uscale)\n{\n\tint i, ret, val;\n\tstatic const int scale_num = ARRAY_SIZE(fxos8700_accel_scale);\n\n\tif (t == FXOS8700_MAGN) {\n\t\t*uscale = 1000;  \n\t\treturn 0;\n\t}\n\n\tret = regmap_read(data->regmap, FXOS8700_XYZ_DATA_CFG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < scale_num; i++) {\n\t\tif (fxos8700_accel_scale[i].bits == (val & 0x3)) {\n\t\t\t*uscale = fxos8700_accel_scale[i].uscale;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int fxos8700_get_data(struct fxos8700_data *data, int chan_type,\n\t\t\t     int axis, int *val)\n{\n\tu8 base, reg;\n\ts16 tmp;\n\tint ret;\n\n\t \n\tswitch (chan_type) {\n\tcase IIO_ACCEL:\n\t\tbase = FXOS8700_OUT_X_MSB;\n\t\tbreak;\n\tcase IIO_MAGN:\n\t\tbase = FXOS8700_M_OUT_X_MSB;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_bulk_read(data->regmap, base, data->buf,\n\t\t\t       sizeof(data->buf));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treg = axis - IIO_MOD_X;\n\n\t \n\ttmp = be16_to_cpu(data->buf[reg]);\n\n\t \n\tswitch (chan_type) {\n\tcase IIO_ACCEL:\n\t\ttmp = tmp >> 2;\n\t\tbreak;\n\tcase IIO_MAGN:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t*val = sign_extend32(tmp, 15);\n\n\treturn 0;\n}\n\nstatic int fxos8700_set_odr(struct fxos8700_data *data, enum fxos8700_sensor t,\n\t\t\t    int odr, int uodr)\n{\n\tint i, ret, val;\n\tbool active_mode;\n\tstatic const int odr_num = ARRAY_SIZE(fxos8700_odr);\n\n\tret = regmap_read(data->regmap, FXOS8700_CTRL_REG1, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tactive_mode = val & FXOS8700_ACTIVE;\n\n\tif (active_mode) {\n\t\t \n\t\tret = regmap_write(data->regmap, FXOS8700_CTRL_REG1,\n\t\t\t\t   val & ~FXOS8700_ACTIVE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < odr_num; i++)\n\t\tif (fxos8700_odr[i].odr == odr && fxos8700_odr[i].uodr == uodr)\n\t\t\tbreak;\n\n\tif (i >= odr_num)\n\t\treturn -EINVAL;\n\n\tval &= ~FXOS8700_CTRL_ODR_MSK;\n\tval |= FIELD_PREP(FXOS8700_CTRL_ODR_MSK, fxos8700_odr[i].bits) | FXOS8700_ACTIVE;\n\treturn regmap_write(data->regmap, FXOS8700_CTRL_REG1, val);\n}\n\nstatic int fxos8700_get_odr(struct fxos8700_data *data, enum fxos8700_sensor t,\n\t\t\t    int *odr, int *uodr)\n{\n\tint i, val, ret;\n\tstatic const int odr_num = ARRAY_SIZE(fxos8700_odr);\n\n\tret = regmap_read(data->regmap, FXOS8700_CTRL_REG1, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = FIELD_GET(FXOS8700_CTRL_ODR_MSK, val);\n\n\tfor (i = 0; i < odr_num; i++)\n\t\tif (val == fxos8700_odr[i].bits)\n\t\t\tbreak;\n\n\tif (i >= odr_num)\n\t\treturn -EINVAL;\n\n\t*odr = fxos8700_odr[i].odr;\n\t*uodr = fxos8700_odr[i].uodr;\n\n\treturn 0;\n}\n\nstatic int fxos8700_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tint ret;\n\tstruct fxos8700_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = fxos8700_get_data(data, chan->type, chan->channel2, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\tret = fxos8700_get_scale(data, fxos8700_to_sensor(chan->type),\n\t\t\t\t\t val2);\n\t\treturn ret ? ret : IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = fxos8700_get_odr(data, fxos8700_to_sensor(chan->type),\n\t\t\t\t       val, val2);\n\t\treturn ret ? ret : IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int fxos8700_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tstruct fxos8700_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn fxos8700_set_scale(data, fxos8700_to_sensor(chan->type),\n\t\t\t\t\t  val2);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn fxos8700_set_odr(data, fxos8700_to_sensor(chan->type),\n\t\t\t\t\tval, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic IIO_CONST_ATTR(in_accel_sampling_frequency_available,\n\t\t      \"1.5625 6.25 12.5 50 100 200 400 800\");\nstatic IIO_CONST_ATTR(in_magn_sampling_frequency_available,\n\t\t      \"1.5625 6.25 12.5 50 100 200 400 800\");\nstatic IIO_CONST_ATTR(in_accel_scale_available, \"0.000244 0.000488 0.000976\");\nstatic IIO_CONST_ATTR(in_magn_scale_available, \"0.001000\");\n\nstatic struct attribute *fxos8700_attrs[] = {\n\t&iio_const_attr_in_accel_sampling_frequency_available.dev_attr.attr,\n\t&iio_const_attr_in_magn_sampling_frequency_available.dev_attr.attr,\n\t&iio_const_attr_in_accel_scale_available.dev_attr.attr,\n\t&iio_const_attr_in_magn_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group fxos8700_attrs_group = {\n\t.attrs = fxos8700_attrs,\n};\n\nstatic const struct iio_info fxos8700_info = {\n\t.read_raw = fxos8700_read_raw,\n\t.write_raw = fxos8700_write_raw,\n\t.attrs = &fxos8700_attrs_group,\n};\n\nstatic int fxos8700_chip_init(struct fxos8700_data *data, bool use_spi)\n{\n\tint ret;\n\tunsigned int val;\n\tstruct device *dev = regmap_get_device(data->regmap);\n\n\tret = regmap_read(data->regmap, FXOS8700_WHO_AM_I, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"Error reading chip id\\n\");\n\t\treturn ret;\n\t}\n\tif (val != FXOS8700_DEVICE_ID && val != FXOS8700_PRE_DEVICE_ID) {\n\t\tdev_err(dev, \"Wrong chip id, got %x expected %x or %x\\n\",\n\t\t\tval, FXOS8700_DEVICE_ID, FXOS8700_PRE_DEVICE_ID);\n\t\treturn -ENODEV;\n\t}\n\n\tret = fxos8700_set_active_mode(data, FXOS8700_ACCEL, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fxos8700_set_active_mode(data, FXOS8700_MAGN, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, FXOS8700_CTRL_REG1, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, FXOS8700_M_CTRL_REG1,\n\t\t\t   FXOS8700_HMS_MASK | FXOS8700_OS_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, FXOS8700_M_CTRL_REG2,\n\t\t\t   FXOS8700_MAXMIN_RST | FXOS8700_MAXMIN_DIS_THS |\n\t\t\t   FXOS8700_MAXMIN_DIS);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, FXOS8700_XYZ_DATA_CFG, MODE_8G);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(data->regmap, FXOS8700_CTRL_REG1,\n\t\t\t\tFXOS8700_CTRL_ODR_MSK | FXOS8700_ACTIVE,\n\t\t\t\tFIELD_PREP(FXOS8700_CTRL_ODR_MSK, FXOS8700_CTRL_ODR_MAX) |\n\t\t\t\tFXOS8700_ACTIVE);\n}\n\nstatic void fxos8700_chip_uninit(void *data)\n{\n\tstruct fxos8700_data *fxos8700_data = data;\n\n\tfxos8700_set_active_mode(fxos8700_data, FXOS8700_ACCEL, false);\n\tfxos8700_set_active_mode(fxos8700_data, FXOS8700_MAGN, false);\n}\n\nint fxos8700_core_probe(struct device *dev, struct regmap *regmap,\n\t\t\tconst char *name, bool use_spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct fxos8700_data *data;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdev_set_drvdata(dev, indio_dev);\n\tdata->regmap = regmap;\n\n\tret = fxos8700_chip_init(data, use_spi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, fxos8700_chip_uninit, data);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->channels = fxos8700_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(fxos8700_channels);\n\tindio_dev->name = name ? name : \"fxos8700\";\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &fxos8700_info;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_GPL(fxos8700_core_probe);\n\nMODULE_AUTHOR(\"Robert Jones <rjones@gateworks.com>\");\nMODULE_DESCRIPTION(\"FXOS8700 6-Axis Acc and Mag Combo Sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}