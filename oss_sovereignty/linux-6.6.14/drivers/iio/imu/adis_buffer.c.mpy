{
  "module_name": "adis_buffer.c",
  "hash_id": "d6adf88054c9aead6e08eb2eecef31f0861a52f7f5d8389ef6d675beca2037f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/adis_buffer.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/imu/adis.h>\n\nstatic int adis_update_scan_mode_burst(struct iio_dev *indio_dev,\n\t\t\t\t       const unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tunsigned int burst_length, burst_max_length;\n\tu8 *tx;\n\n\tburst_length = adis->data->burst_len + adis->burst_extra_len;\n\n\tif (adis->data->burst_max_len)\n\t\tburst_max_length = adis->data->burst_max_len;\n\telse\n\t\tburst_max_length = burst_length;\n\n\tadis->xfer = kcalloc(2, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\n\tadis->buffer = kzalloc(burst_max_length + sizeof(u16), GFP_KERNEL);\n\tif (!adis->buffer) {\n\t\tkfree(adis->xfer);\n\t\tadis->xfer = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\ttx = adis->buffer + burst_max_length;\n\ttx[0] = ADIS_READ_REG(adis->data->burst_reg_cmd);\n\ttx[1] = 0;\n\n\tadis->xfer[0].tx_buf = tx;\n\tadis->xfer[0].bits_per_word = 8;\n\tadis->xfer[0].len = 2;\n\tif (adis->data->burst_max_speed_hz)\n\t\tadis->xfer[0].speed_hz = adis->data->burst_max_speed_hz;\n\tadis->xfer[1].rx_buf = adis->buffer;\n\tadis->xfer[1].bits_per_word = 8;\n\tadis->xfer[1].len = burst_length;\n\tif (adis->data->burst_max_speed_hz)\n\t\tadis->xfer[1].speed_hz = adis->data->burst_max_speed_hz;\n\n\tspi_message_init(&adis->msg);\n\tspi_message_add_tail(&adis->xfer[0], &adis->msg);\n\tspi_message_add_tail(&adis->xfer[1], &adis->msg);\n\n\treturn 0;\n}\n\nint adis_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t  const unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tconst struct iio_chan_spec *chan;\n\tunsigned int scan_count;\n\tunsigned int i, j;\n\t__be16 *tx, *rx;\n\n\tkfree(adis->xfer);\n\tkfree(adis->buffer);\n\n\tif (adis->data->burst_len)\n\t\treturn adis_update_scan_mode_burst(indio_dev, scan_mask);\n\n\tscan_count = indio_dev->scan_bytes / 2;\n\n\tadis->xfer = kcalloc(scan_count + 1, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\n\tadis->buffer = kcalloc(indio_dev->scan_bytes, 2, GFP_KERNEL);\n\tif (!adis->buffer) {\n\t\tkfree(adis->xfer);\n\t\tadis->xfer = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\trx = adis->buffer;\n\ttx = rx + scan_count;\n\n\tspi_message_init(&adis->msg);\n\n\tfor (j = 0; j <= scan_count; j++) {\n\t\tadis->xfer[j].bits_per_word = 8;\n\t\tif (j != scan_count)\n\t\t\tadis->xfer[j].cs_change = 1;\n\t\tadis->xfer[j].len = 2;\n\t\tadis->xfer[j].delay.value = adis->data->read_delay;\n\t\tadis->xfer[j].delay.unit = SPI_DELAY_UNIT_USECS;\n\t\tif (j < scan_count)\n\t\t\tadis->xfer[j].tx_buf = &tx[j];\n\t\tif (j >= 1)\n\t\t\tadis->xfer[j].rx_buf = &rx[j - 1];\n\t\tspi_message_add_tail(&adis->xfer[j], &adis->msg);\n\t}\n\n\tchan = indio_dev->channels;\n\tfor (i = 0; i < indio_dev->num_channels; i++, chan++) {\n\t\tif (!test_bit(chan->scan_index, scan_mask))\n\t\t\tcontinue;\n\t\tif (chan->scan_type.storagebits == 32)\n\t\t\t*tx++ = cpu_to_be16((chan->address + 2) << 8);\n\t\t*tx++ = cpu_to_be16(chan->address << 8);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(adis_update_scan_mode, IIO_ADISLIB);\n\nstatic irqreturn_t adis_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tint ret;\n\n\tif (adis->data->has_paging) {\n\t\tmutex_lock(&adis->state_lock);\n\t\tif (adis->current_page != 0) {\n\t\t\tadis->tx[0] = ADIS_WRITE_REG(ADIS_REG_PAGE_ID);\n\t\t\tadis->tx[1] = 0;\n\t\t\tret = spi_write(adis->spi, adis->tx, 2);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&adis->spi->dev, \"Failed to change device page: %d\\n\", ret);\n\t\t\t\tmutex_unlock(&adis->state_lock);\n\t\t\t\tgoto irq_done;\n\t\t\t}\n\n\t\t\tadis->current_page = 0;\n\t\t}\n\t}\n\n\tret = spi_sync(adis->spi, &adis->msg);\n\tif (adis->data->has_paging)\n\t\tmutex_unlock(&adis->state_lock);\n\tif (ret) {\n\t\tdev_err(&adis->spi->dev, \"Failed to read data: %d\", ret);\n\t\tgoto irq_done;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, adis->buffer,\n\t\t\t\t\t   pf->timestamp);\n\nirq_done:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void adis_buffer_cleanup(void *arg)\n{\n\tstruct adis *adis = arg;\n\n\tkfree(adis->buffer);\n\tkfree(adis->xfer);\n}\n\n \nint\ndevm_adis_setup_buffer_and_trigger(struct adis *adis, struct iio_dev *indio_dev,\n\t\t\t\t   irq_handler_t trigger_handler)\n{\n\tint ret;\n\n\tif (!trigger_handler)\n\t\ttrigger_handler = adis_trigger_handler;\n\n\tret = devm_iio_triggered_buffer_setup(&adis->spi->dev, indio_dev,\n\t\t\t\t\t      &iio_pollfunc_store_time,\n\t\t\t\t\t      trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adis->spi->irq) {\n\t\tret = devm_adis_probe_trigger(adis, indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_add_action_or_reset(&adis->spi->dev, adis_buffer_cleanup,\n\t\t\t\t\tadis);\n}\nEXPORT_SYMBOL_NS_GPL(devm_adis_setup_buffer_and_trigger, IIO_ADISLIB);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}