{
  "module_name": "adis.c",
  "hash_id": "01e9593b40e6ec2e5d1c5ff213e5ff74e483137348af900e8b456acacf1e146c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/adis.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/module.h>\n#include <asm/unaligned.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/imu/adis.h>\n\n#define ADIS_MSC_CTRL_DATA_RDY_EN\tBIT(2)\n#define ADIS_MSC_CTRL_DATA_RDY_POL_HIGH\tBIT(1)\n#define ADIS_MSC_CTRL_DATA_RDY_DIO2\tBIT(0)\n#define ADIS_GLOB_CMD_SW_RESET\t\tBIT(7)\n\n \nint __adis_write_reg(struct adis *adis, unsigned int reg, unsigned int value,\n\t\t     unsigned int size)\n{\n\tunsigned int page = reg / ADIS_PAGE_SIZE;\n\tint ret, i;\n\tstruct spi_message msg;\n\tstruct spi_transfer xfers[] = {\n\t\t{\n\t\t\t.tx_buf = adis->tx,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = 2,\n\t\t\t.cs_change = 1,\n\t\t\t.delay.value = adis->data->write_delay,\n\t\t\t.delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t\t.cs_change_delay.value = adis->data->cs_change_delay,\n\t\t\t.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t}, {\n\t\t\t.tx_buf = adis->tx + 2,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = 2,\n\t\t\t.cs_change = 1,\n\t\t\t.delay.value = adis->data->write_delay,\n\t\t\t.delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t\t.cs_change_delay.value = adis->data->cs_change_delay,\n\t\t\t.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t}, {\n\t\t\t.tx_buf = adis->tx + 4,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = 2,\n\t\t\t.cs_change = 1,\n\t\t\t.delay.value = adis->data->write_delay,\n\t\t\t.delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t\t.cs_change_delay.value = adis->data->cs_change_delay,\n\t\t\t.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t}, {\n\t\t\t.tx_buf = adis->tx + 6,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = 2,\n\t\t\t.delay.value = adis->data->write_delay,\n\t\t\t.delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t}, {\n\t\t\t.tx_buf = adis->tx + 8,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = 2,\n\t\t\t.delay.value = adis->data->write_delay,\n\t\t\t.delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t},\n\t};\n\n\tspi_message_init(&msg);\n\n\tif (adis->current_page != page) {\n\t\tadis->tx[0] = ADIS_WRITE_REG(ADIS_REG_PAGE_ID);\n\t\tadis->tx[1] = page;\n\t\tspi_message_add_tail(&xfers[0], &msg);\n\t}\n\n\tswitch (size) {\n\tcase 4:\n\t\tadis->tx[8] = ADIS_WRITE_REG(reg + 3);\n\t\tadis->tx[9] = (value >> 24) & 0xff;\n\t\tadis->tx[6] = ADIS_WRITE_REG(reg + 2);\n\t\tadis->tx[7] = (value >> 16) & 0xff;\n\t\tfallthrough;\n\tcase 2:\n\t\tadis->tx[4] = ADIS_WRITE_REG(reg + 1);\n\t\tadis->tx[5] = (value >> 8) & 0xff;\n\t\tfallthrough;\n\tcase 1:\n\t\tadis->tx[2] = ADIS_WRITE_REG(reg);\n\t\tadis->tx[3] = value & 0xff;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\txfers[size].cs_change = 0;\n\n\tfor (i = 1; i <= size; i++)\n\t\tspi_message_add_tail(&xfers[i], &msg);\n\n\tret = spi_sync(adis->spi, &msg);\n\tif (ret) {\n\t\tdev_err(&adis->spi->dev, \"Failed to write register 0x%02X: %d\\n\",\n\t\t\treg, ret);\n\t} else {\n\t\tadis->current_page = page;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(__adis_write_reg, IIO_ADISLIB);\n\n \nint __adis_read_reg(struct adis *adis, unsigned int reg, unsigned int *val,\n\t\t    unsigned int size)\n{\n\tunsigned int page = reg / ADIS_PAGE_SIZE;\n\tstruct spi_message msg;\n\tint ret;\n\tstruct spi_transfer xfers[] = {\n\t\t{\n\t\t\t.tx_buf = adis->tx,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = 2,\n\t\t\t.cs_change = 1,\n\t\t\t.delay.value = adis->data->write_delay,\n\t\t\t.delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t\t.cs_change_delay.value = adis->data->cs_change_delay,\n\t\t\t.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t}, {\n\t\t\t.tx_buf = adis->tx + 2,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = 2,\n\t\t\t.cs_change = 1,\n\t\t\t.delay.value = adis->data->read_delay,\n\t\t\t.delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t\t.cs_change_delay.value = adis->data->cs_change_delay,\n\t\t\t.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t}, {\n\t\t\t.tx_buf = adis->tx + 4,\n\t\t\t.rx_buf = adis->rx,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = 2,\n\t\t\t.cs_change = 1,\n\t\t\t.delay.value = adis->data->read_delay,\n\t\t\t.delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t\t.cs_change_delay.value = adis->data->cs_change_delay,\n\t\t\t.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t}, {\n\t\t\t.rx_buf = adis->rx + 2,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = 2,\n\t\t\t.delay.value = adis->data->read_delay,\n\t\t\t.delay.unit = SPI_DELAY_UNIT_USECS,\n\t\t},\n\t};\n\n\tspi_message_init(&msg);\n\n\tif (adis->current_page != page) {\n\t\tadis->tx[0] = ADIS_WRITE_REG(ADIS_REG_PAGE_ID);\n\t\tadis->tx[1] = page;\n\t\tspi_message_add_tail(&xfers[0], &msg);\n\t}\n\n\tswitch (size) {\n\tcase 4:\n\t\tadis->tx[2] = ADIS_READ_REG(reg + 2);\n\t\tadis->tx[3] = 0;\n\t\tspi_message_add_tail(&xfers[1], &msg);\n\t\tfallthrough;\n\tcase 2:\n\t\tadis->tx[4] = ADIS_READ_REG(reg);\n\t\tadis->tx[5] = 0;\n\t\tspi_message_add_tail(&xfers[2], &msg);\n\t\tspi_message_add_tail(&xfers[3], &msg);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = spi_sync(adis->spi, &msg);\n\tif (ret) {\n\t\tdev_err(&adis->spi->dev, \"Failed to read register 0x%02X: %d\\n\",\n\t\t\treg, ret);\n\t\treturn ret;\n\t}\n\n\tadis->current_page = page;\n\n\tswitch (size) {\n\tcase 4:\n\t\t*val = get_unaligned_be32(adis->rx);\n\t\tbreak;\n\tcase 2:\n\t\t*val = get_unaligned_be16(adis->rx + 2);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(__adis_read_reg, IIO_ADISLIB);\n \nint __adis_update_bits_base(struct adis *adis, unsigned int reg, const u32 mask,\n\t\t\t    const u32 val, u8 size)\n{\n\tint ret;\n\tu32 __val;\n\n\tret = __adis_read_reg(adis, reg, &__val, size);\n\tif (ret)\n\t\treturn ret;\n\n\t__val = (__val & ~mask) | (val & mask);\n\n\treturn __adis_write_reg(adis, reg, __val, size);\n}\nEXPORT_SYMBOL_NS_GPL(__adis_update_bits_base, IIO_ADISLIB);\n\n#ifdef CONFIG_DEBUG_FS\n\nint adis_debugfs_reg_access(struct iio_dev *indio_dev, unsigned int reg,\n\t\t\t    unsigned int writeval, unsigned int *readval)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\n\tif (readval) {\n\t\tu16 val16;\n\t\tint ret;\n\n\t\tret = adis_read_reg_16(adis, reg, &val16);\n\t\tif (ret == 0)\n\t\t\t*readval = val16;\n\n\t\treturn ret;\n\t}\n\n\treturn adis_write_reg_16(adis, reg, writeval);\n}\nEXPORT_SYMBOL_NS(adis_debugfs_reg_access, IIO_ADISLIB);\n\n#endif\n\n \nint __adis_enable_irq(struct adis *adis, bool enable)\n{\n\tint ret;\n\tu16 msc;\n\n\tif (adis->data->enable_irq)\n\t\treturn adis->data->enable_irq(adis, enable);\n\n\tif (adis->data->unmasked_drdy) {\n\t\tif (enable)\n\t\t\tenable_irq(adis->spi->irq);\n\t\telse\n\t\t\tdisable_irq(adis->spi->irq);\n\n\t\treturn 0;\n\t}\n\n\tret = __adis_read_reg_16(adis, adis->data->msc_ctrl_reg, &msc);\n\tif (ret)\n\t\treturn ret;\n\n\tmsc |= ADIS_MSC_CTRL_DATA_RDY_POL_HIGH;\n\tmsc &= ~ADIS_MSC_CTRL_DATA_RDY_DIO2;\n\tif (enable)\n\t\tmsc |= ADIS_MSC_CTRL_DATA_RDY_EN;\n\telse\n\t\tmsc &= ~ADIS_MSC_CTRL_DATA_RDY_EN;\n\n\treturn __adis_write_reg_16(adis, adis->data->msc_ctrl_reg, msc);\n}\nEXPORT_SYMBOL_NS(__adis_enable_irq, IIO_ADISLIB);\n\n \nint __adis_check_status(struct adis *adis)\n{\n\tu16 status;\n\tint ret;\n\tint i;\n\n\tret = __adis_read_reg_16(adis, adis->data->diag_stat_reg, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tstatus &= adis->data->status_error_mask;\n\n\tif (status == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < 16; ++i) {\n\t\tif (status & BIT(i)) {\n\t\t\tdev_err(&adis->spi->dev, \"%s.\\n\",\n\t\t\t\tadis->data->status_error_msgs[i]);\n\t\t}\n\t}\n\n\treturn -EIO;\n}\nEXPORT_SYMBOL_NS_GPL(__adis_check_status, IIO_ADISLIB);\n\n \nint __adis_reset(struct adis *adis)\n{\n\tint ret;\n\tconst struct adis_timeout *timeouts = adis->data->timeouts;\n\n\tret = __adis_write_reg_8(adis, adis->data->glob_cmd_reg,\n\t\t\t\t ADIS_GLOB_CMD_SW_RESET);\n\tif (ret) {\n\t\tdev_err(&adis->spi->dev, \"Failed to reset device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmsleep(timeouts->sw_reset_ms);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(__adis_reset, IIO_ADIS_LIB);\n\nstatic int adis_self_test(struct adis *adis)\n{\n\tint ret;\n\tconst struct adis_timeout *timeouts = adis->data->timeouts;\n\n\tret = __adis_write_reg_16(adis, adis->data->self_test_reg,\n\t\t\t\t  adis->data->self_test_mask);\n\tif (ret) {\n\t\tdev_err(&adis->spi->dev, \"Failed to initiate self test: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tmsleep(timeouts->self_test_ms);\n\n\tret = __adis_check_status(adis);\n\n\tif (adis->data->self_test_no_autoclear)\n\t\t__adis_write_reg_16(adis, adis->data->self_test_reg, 0x00);\n\n\treturn ret;\n}\n\n \nint __adis_initial_startup(struct adis *adis)\n{\n\tconst struct adis_timeout *timeouts = adis->data->timeouts;\n\tstruct gpio_desc *gpio;\n\tu16 prod_id;\n\tint ret;\n\n\t \n\tgpio = devm_gpiod_get_optional(&adis->spi->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(gpio))\n\t\treturn PTR_ERR(gpio);\n\n\tif (gpio) {\n\t\tusleep_range(10, 12);\n\t\t \n\t\tgpiod_set_value_cansleep(gpio, 0);\n\t\tmsleep(timeouts->reset_ms);\n\t} else {\n\t\tret = __adis_reset(adis);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = adis_self_test(adis);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!adis->data->unmasked_drdy)\n\t\t__adis_enable_irq(adis, false);\n\n\tif (!adis->data->prod_id_reg)\n\t\treturn 0;\n\n\tret = adis_read_reg_16(adis, adis->data->prod_id_reg, &prod_id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (prod_id != adis->data->prod_id)\n\t\tdev_warn(&adis->spi->dev,\n\t\t\t \"Device ID(%u) and product ID(%u) do not match.\\n\",\n\t\t\t adis->data->prod_id, prod_id);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(__adis_initial_startup, IIO_ADISLIB);\n\n \nint adis_single_conversion(struct iio_dev *indio_dev,\n\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t   unsigned int error_mask, int *val)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tunsigned int uval;\n\tint ret;\n\n\tmutex_lock(&adis->state_lock);\n\n\tret = __adis_read_reg(adis, chan->address, &uval,\n\t\t\t      chan->scan_type.storagebits / 8);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tif (uval & error_mask) {\n\t\tret = __adis_check_status(adis);\n\t\tif (ret)\n\t\t\tgoto err_unlock;\n\t}\n\n\tif (chan->scan_type.sign == 's')\n\t\t*val = sign_extend32(uval, chan->scan_type.realbits - 1);\n\telse\n\t\t*val = uval & ((1 << chan->scan_type.realbits) - 1);\n\n\tret = IIO_VAL_INT;\nerr_unlock:\n\tmutex_unlock(&adis->state_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(adis_single_conversion, IIO_ADISLIB);\n\n \nint adis_init(struct adis *adis, struct iio_dev *indio_dev,\n\t      struct spi_device *spi, const struct adis_data *data)\n{\n\tif (!data || !data->timeouts) {\n\t\tdev_err(&spi->dev, \"No config data or timeouts not defined!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&adis->state_lock);\n\tadis->spi = spi;\n\tadis->data = data;\n\tiio_device_set_drvdata(indio_dev, adis);\n\n\tif (data->has_paging) {\n\t\t \n\t\tadis->current_page = -1;\n\t} else {\n\t\t \n\t\tadis->current_page = 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(adis_init, IIO_ADISLIB);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Common library code for ADIS16XXX devices\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}