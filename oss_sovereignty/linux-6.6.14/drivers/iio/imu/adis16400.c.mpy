{
  "module_name": "adis16400.c",
  "hash_id": "c0acb47d30c39ea074850d554d9da4513bd7123e1f5894a9c77c5c31f67f198d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/adis16400.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/imu/adis.h>\n\n#define ADIS16400_STARTUP_DELAY\t290  \n#define ADIS16400_MTEST_DELAY 90  \n\n#define ADIS16400_FLASH_CNT  0x00  \n#define ADIS16400_SUPPLY_OUT 0x02  \n#define ADIS16400_XGYRO_OUT 0x04  \n#define ADIS16400_YGYRO_OUT 0x06  \n#define ADIS16400_ZGYRO_OUT 0x08  \n#define ADIS16400_XACCL_OUT 0x0A  \n#define ADIS16400_YACCL_OUT 0x0C  \n#define ADIS16400_ZACCL_OUT 0x0E  \n#define ADIS16400_XMAGN_OUT 0x10  \n#define ADIS16400_YMAGN_OUT 0x12  \n#define ADIS16400_ZMAGN_OUT 0x14  \n#define ADIS16400_TEMP_OUT  0x16  \n#define ADIS16400_AUX_ADC   0x18  \n\n#define ADIS16350_XTEMP_OUT 0x10  \n#define ADIS16350_YTEMP_OUT 0x12  \n#define ADIS16350_ZTEMP_OUT 0x14  \n\n#define ADIS16300_PITCH_OUT 0x12  \n#define ADIS16300_ROLL_OUT  0x14  \n#define ADIS16300_AUX_ADC   0x16  \n\n#define ADIS16448_BARO_OUT\t0x16  \n#define ADIS16448_TEMP_OUT  0x18  \n\n \n#define ADIS16400_XGYRO_OFF 0x1A  \n#define ADIS16400_YGYRO_OFF 0x1C  \n#define ADIS16400_ZGYRO_OFF 0x1E  \n#define ADIS16400_XACCL_OFF 0x20  \n#define ADIS16400_YACCL_OFF 0x22  \n#define ADIS16400_ZACCL_OFF 0x24  \n#define ADIS16400_XMAGN_HIF 0x26  \n#define ADIS16400_YMAGN_HIF 0x28  \n#define ADIS16400_ZMAGN_HIF 0x2A  \n#define ADIS16400_XMAGN_SIF 0x2C  \n#define ADIS16400_YMAGN_SIF 0x2E  \n#define ADIS16400_ZMAGN_SIF 0x30  \n\n#define ADIS16400_GPIO_CTRL 0x32  \n#define ADIS16400_MSC_CTRL  0x34  \n#define ADIS16400_SMPL_PRD  0x36  \n#define ADIS16400_SENS_AVG  0x38  \n#define ADIS16400_SLP_CNT   0x3A  \n#define ADIS16400_DIAG_STAT 0x3C  \n\n \n#define ADIS16400_GLOB_CMD  0x3E  \n#define ADIS16400_ALM_MAG1  0x40  \n#define ADIS16400_ALM_MAG2  0x42  \n#define ADIS16400_ALM_SMPL1 0x44  \n#define ADIS16400_ALM_SMPL2 0x46  \n#define ADIS16400_ALM_CTRL  0x48  \n#define ADIS16400_AUX_DAC   0x4A  \n\n#define ADIS16334_LOT_ID1   0x52  \n#define ADIS16334_LOT_ID2   0x54  \n#define ADIS16400_PRODUCT_ID 0x56  \n#define ADIS16334_SERIAL_NUMBER 0x58  \n\n#define ADIS16400_ERROR_ACTIVE\t\t\t(1<<14)\n#define ADIS16400_NEW_DATA\t\t\t(1<<14)\n\n \n#define ADIS16400_MSC_CTRL_MEM_TEST\t\t(1<<11)\n#define ADIS16400_MSC_CTRL_INT_SELF_TEST\t(1<<10)\n#define ADIS16400_MSC_CTRL_NEG_SELF_TEST\t(1<<9)\n#define ADIS16400_MSC_CTRL_POS_SELF_TEST\t(1<<8)\n#define ADIS16400_MSC_CTRL_GYRO_BIAS\t\t(1<<7)\n#define ADIS16400_MSC_CTRL_ACCL_ALIGN\t\t(1<<6)\n#define ADIS16400_MSC_CTRL_DATA_RDY_EN\t\t(1<<2)\n#define ADIS16400_MSC_CTRL_DATA_RDY_POL_HIGH\t(1<<1)\n#define ADIS16400_MSC_CTRL_DATA_RDY_DIO2\t(1<<0)\n\n \n#define ADIS16400_SMPL_PRD_TIME_BASE\t(1<<7)\n#define ADIS16400_SMPL_PRD_DIV_MASK\t0x7F\n\n \n#define ADIS16400_DIAG_STAT_ZACCL_FAIL\t15\n#define ADIS16400_DIAG_STAT_YACCL_FAIL\t14\n#define ADIS16400_DIAG_STAT_XACCL_FAIL\t13\n#define ADIS16400_DIAG_STAT_XGYRO_FAIL\t12\n#define ADIS16400_DIAG_STAT_YGYRO_FAIL\t11\n#define ADIS16400_DIAG_STAT_ZGYRO_FAIL\t10\n#define ADIS16400_DIAG_STAT_ALARM2\t9\n#define ADIS16400_DIAG_STAT_ALARM1\t8\n#define ADIS16400_DIAG_STAT_FLASH_CHK\t6\n#define ADIS16400_DIAG_STAT_SELF_TEST\t5\n#define ADIS16400_DIAG_STAT_OVERFLOW\t4\n#define ADIS16400_DIAG_STAT_SPI_FAIL\t3\n#define ADIS16400_DIAG_STAT_FLASH_UPT\t2\n#define ADIS16400_DIAG_STAT_POWER_HIGH\t1\n#define ADIS16400_DIAG_STAT_POWER_LOW\t0\n\n \n#define ADIS16400_GLOB_CMD_SW_RESET\t(1<<7)\n#define ADIS16400_GLOB_CMD_P_AUTO_NULL\t(1<<4)\n#define ADIS16400_GLOB_CMD_FLASH_UPD\t(1<<3)\n#define ADIS16400_GLOB_CMD_DAC_LATCH\t(1<<2)\n#define ADIS16400_GLOB_CMD_FAC_CALIB\t(1<<1)\n#define ADIS16400_GLOB_CMD_AUTO_NULL\t(1<<0)\n\n \n#define ADIS16400_SLP_CNT_POWER_OFF\t(1<<8)\n\n#define ADIS16334_RATE_DIV_SHIFT 8\n#define ADIS16334_RATE_INT_CLK BIT(0)\n\n#define ADIS16400_SPI_SLOW\t(u32)(300 * 1000)\n#define ADIS16400_SPI_BURST\t(u32)(1000 * 1000)\n#define ADIS16400_SPI_FAST\t(u32)(2000 * 1000)\n\n#define ADIS16400_HAS_PROD_ID\t\tBIT(0)\n#define ADIS16400_NO_BURST\t\tBIT(1)\n#define ADIS16400_HAS_SLOW_MODE\t\tBIT(2)\n#define ADIS16400_HAS_SERIAL_NUMBER\tBIT(3)\n#define ADIS16400_BURST_DIAG_STAT\tBIT(4)\n\nstruct adis16400_state;\n\nstruct adis16400_chip_info {\n\tconst struct iio_chan_spec *channels;\n\tconst struct adis_data adis_data;\n\tconst int num_channels;\n\tconst long flags;\n\tunsigned int gyro_scale_micro;\n\tunsigned int accel_scale_micro;\n\tint temp_scale_nano;\n\tint temp_offset;\n\t \n\tint (*set_freq)(struct adis16400_state *st, unsigned int freq);\n\tint (*get_freq)(struct adis16400_state *st);\n};\n\n \nstruct adis16400_state {\n\tstruct adis16400_chip_info\t*variant;\n\tint\t\t\t\tfilt_int;\n\n\tstruct adis adis;\n\tunsigned long avail_scan_mask[2];\n};\n\n \n\nenum {\n\tADIS16400_SCAN_SUPPLY,\n\tADIS16400_SCAN_GYRO_X,\n\tADIS16400_SCAN_GYRO_Y,\n\tADIS16400_SCAN_GYRO_Z,\n\tADIS16400_SCAN_ACC_X,\n\tADIS16400_SCAN_ACC_Y,\n\tADIS16400_SCAN_ACC_Z,\n\tADIS16400_SCAN_MAGN_X,\n\tADIS16400_SCAN_MAGN_Y,\n\tADIS16400_SCAN_MAGN_Z,\n\tADIS16400_SCAN_BARO,\n\tADIS16350_SCAN_TEMP_X,\n\tADIS16350_SCAN_TEMP_Y,\n\tADIS16350_SCAN_TEMP_Z,\n\tADIS16300_SCAN_INCLI_X,\n\tADIS16300_SCAN_INCLI_Y,\n\tADIS16400_SCAN_ADC,\n\tADIS16400_SCAN_TIMESTAMP,\n};\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic ssize_t adis16400_show_serial_number(struct file *file,\n\t\tchar __user *userbuf, size_t count, loff_t *ppos)\n{\n\tstruct adis16400_state *st = file->private_data;\n\tu16 lot1, lot2, serial_number;\n\tchar buf[16];\n\tsize_t len;\n\tint ret;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16334_LOT_ID1, &lot1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16334_LOT_ID2, &lot2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16334_SERIAL_NUMBER,\n\t\t\t&serial_number);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = snprintf(buf, sizeof(buf), \"%.4x-%.4x-%.4x\\n\", lot1, lot2,\n\t\t\tserial_number);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations adis16400_serial_number_fops = {\n\t.open = simple_open,\n\t.read = adis16400_show_serial_number,\n\t.llseek = default_llseek,\n\t.owner = THIS_MODULE,\n};\n\nstatic int adis16400_show_product_id(void *arg, u64 *val)\n{\n\tstruct adis16400_state *st = arg;\n\tuint16_t prod_id;\n\tint ret;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16400_PRODUCT_ID, &prod_id);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = prod_id;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(adis16400_product_id_fops,\n\tadis16400_show_product_id, NULL, \"%lld\\n\");\n\nstatic int adis16400_show_flash_count(void *arg, u64 *val)\n{\n\tstruct adis16400_state *st = arg;\n\tuint16_t flash_count;\n\tint ret;\n\n\tret = adis_read_reg_16(&st->adis, ADIS16400_FLASH_CNT, &flash_count);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = flash_count;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(adis16400_flash_count_fops,\n\tadis16400_show_flash_count, NULL, \"%lld\\n\");\n\nstatic int adis16400_debugfs_init(struct iio_dev *indio_dev)\n{\n\tstruct adis16400_state *st = iio_priv(indio_dev);\n\tstruct dentry *d = iio_get_debugfs_dentry(indio_dev);\n\n\tif (st->variant->flags & ADIS16400_HAS_SERIAL_NUMBER)\n\t\tdebugfs_create_file_unsafe(\"serial_number\", 0400,\n\t\t\t\td, st, &adis16400_serial_number_fops);\n\tif (st->variant->flags & ADIS16400_HAS_PROD_ID)\n\t\tdebugfs_create_file_unsafe(\"product_id\", 0400,\n\t\t\t\td, st, &adis16400_product_id_fops);\n\tdebugfs_create_file_unsafe(\"flash_count\", 0400,\n\t\t\td, st, &adis16400_flash_count_fops);\n\n\treturn 0;\n}\n\n#else\n\nstatic int adis16400_debugfs_init(struct iio_dev *indio_dev)\n{\n\treturn 0;\n}\n\n#endif\n\nenum adis16400_chip_variant {\n\tADIS16300,\n\tADIS16334,\n\tADIS16350,\n\tADIS16360,\n\tADIS16362,\n\tADIS16364,\n\tADIS16367,\n\tADIS16400,\n\tADIS16445,\n\tADIS16448,\n};\n\nstatic int adis16334_get_freq(struct adis16400_state *st)\n{\n\tint ret;\n\tuint16_t t;\n\n\tret = __adis_read_reg_16(&st->adis, ADIS16400_SMPL_PRD, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tt >>= ADIS16334_RATE_DIV_SHIFT;\n\n\treturn 819200 >> t;\n}\n\nstatic int adis16334_set_freq(struct adis16400_state *st, unsigned int freq)\n{\n\tunsigned int t;\n\n\tif (freq < 819200)\n\t\tt = ilog2(819200 / freq);\n\telse\n\t\tt = 0;\n\n\tif (t > 0x31)\n\t\tt = 0x31;\n\n\tt <<= ADIS16334_RATE_DIV_SHIFT;\n\tt |= ADIS16334_RATE_INT_CLK;\n\n\treturn __adis_write_reg_16(&st->adis, ADIS16400_SMPL_PRD, t);\n}\n\nstatic int adis16400_get_freq(struct adis16400_state *st)\n{\n\tint sps, ret;\n\tuint16_t t;\n\n\tret = __adis_read_reg_16(&st->adis, ADIS16400_SMPL_PRD, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tsps = (t & ADIS16400_SMPL_PRD_TIME_BASE) ? 52851 : 1638404;\n\tsps /= (t & ADIS16400_SMPL_PRD_DIV_MASK) + 1;\n\n\treturn sps;\n}\n\nstatic int adis16400_set_freq(struct adis16400_state *st, unsigned int freq)\n{\n\tunsigned int t;\n\tuint8_t val = 0;\n\n\tt = 1638404 / freq;\n\tif (t >= 128) {\n\t\tval |= ADIS16400_SMPL_PRD_TIME_BASE;\n\t\tt = 52851 / freq;\n\t\tif (t >= 128)\n\t\t\tt = 127;\n\t} else if (t != 0) {\n\t\tt--;\n\t}\n\n\tval |= t;\n\n\tif (t >= 0x0A || (val & ADIS16400_SMPL_PRD_TIME_BASE))\n\t\tst->adis.spi->max_speed_hz = ADIS16400_SPI_SLOW;\n\telse\n\t\tst->adis.spi->max_speed_hz = ADIS16400_SPI_FAST;\n\n\treturn __adis_write_reg_8(&st->adis, ADIS16400_SMPL_PRD, val);\n}\n\nstatic const unsigned int adis16400_3db_divisors[] = {\n\t[0] = 2,  \n\t[1] = 6,\n\t[2] = 12,\n\t[3] = 25,\n\t[4] = 50,\n\t[5] = 100,\n\t[6] = 200,\n\t[7] = 200,  \n};\n\nstatic int __adis16400_set_filter(struct iio_dev *indio_dev, int sps, int val)\n{\n\tstruct adis16400_state *st = iio_priv(indio_dev);\n\tuint16_t val16;\n\tint i, ret;\n\n\tfor (i = ARRAY_SIZE(adis16400_3db_divisors) - 1; i >= 1; i--) {\n\t\tif (sps / adis16400_3db_divisors[i] >= val)\n\t\t\tbreak;\n\t}\n\n\tret = __adis_read_reg_16(&st->adis, ADIS16400_SENS_AVG, &val16);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __adis_write_reg_16(&st->adis, ADIS16400_SENS_AVG,\n\t\t\t\t\t (val16 & ~0x07) | i);\n\treturn ret;\n}\n\n \nstatic int adis16400_stop_device(struct iio_dev *indio_dev)\n{\n\tstruct adis16400_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = adis_write_reg_16(&st->adis, ADIS16400_SLP_CNT,\n\t\t\tADIS16400_SLP_CNT_POWER_OFF);\n\tif (ret)\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\"problem with turning device off: SLP_CNT\");\n\n\treturn ret;\n}\n\nstatic int adis16400_initial_setup(struct iio_dev *indio_dev)\n{\n\tstruct adis16400_state *st = iio_priv(indio_dev);\n\tuint16_t prod_id, smp_prd;\n\tunsigned int device_id;\n\tint ret;\n\n\t \n\tif (st->variant->flags & ADIS16400_HAS_SLOW_MODE)\n\t\tst->adis.spi->max_speed_hz = ADIS16400_SPI_SLOW;\n\telse\n\t\tst->adis.spi->max_speed_hz = ADIS16400_SPI_FAST;\n\tst->adis.spi->mode = SPI_MODE_3;\n\tspi_setup(st->adis.spi);\n\n\tret = __adis_initial_startup(&st->adis);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->variant->flags & ADIS16400_HAS_PROD_ID) {\n\t\tret = adis_read_reg_16(&st->adis,\n\t\t\t\t\t\tADIS16400_PRODUCT_ID, &prod_id);\n\t\tif (ret)\n\t\t\tgoto err_ret;\n\n\t\tif (sscanf(indio_dev->name, \"adis%u\\n\", &device_id) != 1) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_ret;\n\t\t}\n\n\t\tif (prod_id != device_id)\n\t\t\tdev_warn(&indio_dev->dev, \"Device ID(%u) and product ID(%u) do not match.\",\n\t\t\t\t\tdevice_id, prod_id);\n\n\t\tdev_info(&indio_dev->dev, \"%s: prod_id 0x%04x at CS%d (irq %d)\\n\",\n\t\t\tindio_dev->name, prod_id,\n\t\t\tspi_get_chipselect(st->adis.spi, 0), st->adis.spi->irq);\n\t}\n\t \n\tif (st->variant->flags & ADIS16400_HAS_SLOW_MODE) {\n\t\tret = adis_read_reg_16(&st->adis, ADIS16400_SMPL_PRD, &smp_prd);\n\t\tif (ret)\n\t\t\tgoto err_ret;\n\n\t\tif ((smp_prd & ADIS16400_SMPL_PRD_DIV_MASK) < 0x0A) {\n\t\t\tst->adis.spi->max_speed_hz = ADIS16400_SPI_FAST;\n\t\t\tspi_setup(st->adis.spi);\n\t\t}\n\t}\n\nerr_ret:\n\treturn ret;\n}\n\nstatic const uint8_t adis16400_addresses[] = {\n\t[ADIS16400_SCAN_GYRO_X] = ADIS16400_XGYRO_OFF,\n\t[ADIS16400_SCAN_GYRO_Y] = ADIS16400_YGYRO_OFF,\n\t[ADIS16400_SCAN_GYRO_Z] = ADIS16400_ZGYRO_OFF,\n\t[ADIS16400_SCAN_ACC_X] = ADIS16400_XACCL_OFF,\n\t[ADIS16400_SCAN_ACC_Y] = ADIS16400_YACCL_OFF,\n\t[ADIS16400_SCAN_ACC_Z] = ADIS16400_ZACCL_OFF,\n};\n\nstatic int adis16400_write_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int val, int val2, long info)\n{\n\tstruct adis16400_state *st = iio_priv(indio_dev);\n\tint ret, sps;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = adis_write_reg_16(&st->adis,\n\t\t\t\tadis16400_addresses[chan->scan_index], val);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\t \n\t\tadis_dev_lock(&st->adis);\n\t\tst->filt_int = val;\n\t\t \n\t\tsps = st->variant->get_freq(st);\n\t\tif (sps < 0) {\n\t\t\tadis_dev_unlock(&st->adis);\n\t\t\treturn sps;\n\t\t}\n\n\t\tret = __adis16400_set_filter(indio_dev, sps,\n\t\t\tval * 1000 + val2 / 1000);\n\t\tadis_dev_unlock(&st->adis);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tsps = val * 1000 + val2 / 1000;\n\n\t\tif (sps <= 0)\n\t\t\treturn -EINVAL;\n\n\t\tadis_dev_lock(&st->adis);\n\t\tret = st->variant->set_freq(st, sps);\n\t\tadis_dev_unlock(&st->adis);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adis16400_read_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int *val, int *val2, long info)\n{\n\tstruct adis16400_state *st = iio_priv(indio_dev);\n\tint16_t val16;\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn adis_single_conversion(indio_dev, chan, 0, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\t*val = 0;\n\t\t\t*val2 = st->variant->gyro_scale_micro;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_VOLTAGE:\n\t\t\t*val = 0;\n\t\t\tif (chan->channel == 0) {\n\t\t\t\t*val = 2;\n\t\t\t\t*val2 = 418000;  \n\t\t\t} else {\n\t\t\t\t*val = 0;\n\t\t\t\t*val2 = 805800;  \n\t\t\t}\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_ACCEL:\n\t\t\t*val = 0;\n\t\t\t*val2 = st->variant->accel_scale_micro;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_MAGN:\n\t\t\t*val = 0;\n\t\t\t*val2 = 500;  \n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_TEMP:\n\t\t\t*val = st->variant->temp_scale_nano / 1000000;\n\t\t\t*val2 = (st->variant->temp_scale_nano % 1000000);\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_PRESSURE:\n\t\t\t \n\t\t\t*val = 0;\n\t\t\t*val2 = 2000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = adis_read_reg_16(&st->adis,\n\t\t\t\tadis16400_addresses[chan->scan_index], &val16);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval16 = sign_extend32(val16, 11);\n\t\t*val = val16;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\t*val = st->variant->temp_offset;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tadis_dev_lock(&st->adis);\n\t\t \n\t\tret = __adis_read_reg_16(&st->adis,\n\t\t\t\t\t\tADIS16400_SENS_AVG,\n\t\t\t\t\t\t&val16);\n\t\tif (ret) {\n\t\t\tadis_dev_unlock(&st->adis);\n\t\t\treturn ret;\n\t\t}\n\t\tret = st->variant->get_freq(st);\n\t\tadis_dev_unlock(&st->adis);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret /= adis16400_3db_divisors[val16 & 0x07];\n\t\t*val = ret / 1000;\n\t\t*val2 = (ret % 1000) * 1000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tadis_dev_lock(&st->adis);\n\t\tret = st->variant->get_freq(st);\n\t\tadis_dev_unlock(&st->adis);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*val = ret / 1000;\n\t\t*val2 = (ret % 1000) * 1000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#if IS_ENABLED(CONFIG_IIO_BUFFER)\nstatic irqreturn_t adis16400_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct adis16400_state *st = iio_priv(indio_dev);\n\tstruct adis *adis = &st->adis;\n\tvoid *buffer;\n\tint ret;\n\n\tret = spi_sync(adis->spi, &adis->msg);\n\tif (ret)\n\t\tdev_err(&adis->spi->dev, \"Failed to read data: %d\\n\", ret);\n\n\tif (st->variant->flags & ADIS16400_BURST_DIAG_STAT) {\n\t\tbuffer = adis->buffer + sizeof(u16);\n\t\t \n\t\tiio_push_to_buffers_with_ts_unaligned(indio_dev, buffer,\n\t\t\t\t\t\t      indio_dev->scan_bytes - sizeof(pf->timestamp),\n\t\t\t\t\t\t      pf->timestamp);\n\t} else {\n\t\tiio_push_to_buffers_with_timestamp(indio_dev,\n\t\t\t\t\t\t   adis->buffer,\n\t\t\t\t\t\t   pf->timestamp);\n\t}\n\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n#else\n#define adis16400_trigger_handler\tNULL\n#endif  \n\n#define ADIS16400_VOLTAGE_CHAN(addr, bits, name, si, chn) { \\\n\t.type = IIO_VOLTAGE, \\\n\t.indexed = 1, \\\n\t.channel = chn, \\\n\t.extend_name = name, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\tBIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.address = (addr), \\\n\t.scan_index = (si), \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = (bits), \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 0, \\\n\t\t.endianness = IIO_BE, \\\n\t}, \\\n}\n\n#define ADIS16400_SUPPLY_CHAN(addr, bits) \\\n\tADIS16400_VOLTAGE_CHAN(addr, bits, \"supply\", ADIS16400_SCAN_SUPPLY, 0)\n\n#define ADIS16400_AUX_ADC_CHAN(addr, bits) \\\n\tADIS16400_VOLTAGE_CHAN(addr, bits, NULL, ADIS16400_SCAN_ADC, 1)\n\n#define ADIS16400_GYRO_CHAN(mod, addr, bits) { \\\n\t.type = IIO_ANGL_VEL, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_ ## mod, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\t\t  \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.address = addr, \\\n\t.scan_index = ADIS16400_SCAN_GYRO_ ## mod, \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = (bits), \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 0, \\\n\t\t.endianness = IIO_BE, \\\n\t}, \\\n}\n\n#define ADIS16400_ACCEL_CHAN(mod, addr, bits) { \\\n\t.type = IIO_ACCEL, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_ ## mod, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\tBIT(IIO_CHAN_INFO_CALIBBIAS), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.address = (addr), \\\n\t.scan_index = ADIS16400_SCAN_ACC_ ## mod, \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = (bits), \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 0, \\\n\t\t.endianness = IIO_BE, \\\n\t}, \\\n}\n\n#define ADIS16400_MAGN_CHAN(mod, addr, bits) { \\\n\t.type = IIO_MAGN, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_ ## mod, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.address = (addr), \\\n\t.scan_index = ADIS16400_SCAN_MAGN_ ## mod, \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = (bits), \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 0, \\\n\t\t.endianness = IIO_BE, \\\n\t}, \\\n}\n\n#define ADIS16400_MOD_TEMP_NAME_X \"x\"\n#define ADIS16400_MOD_TEMP_NAME_Y \"y\"\n#define ADIS16400_MOD_TEMP_NAME_Z \"z\"\n\n#define ADIS16400_MOD_TEMP_CHAN(mod, addr, bits) { \\\n\t.type = IIO_TEMP, \\\n\t.indexed = 1, \\\n\t.channel = 0, \\\n\t.extend_name = ADIS16400_MOD_TEMP_NAME_ ## mod, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\tBIT(IIO_CHAN_INFO_OFFSET) | \\\n\t\tBIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_type = \\\n\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.address = (addr), \\\n\t.scan_index = ADIS16350_SCAN_TEMP_ ## mod, \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = (bits), \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 0, \\\n\t\t.endianness = IIO_BE, \\\n\t}, \\\n}\n\n#define ADIS16400_TEMP_CHAN(addr, bits) { \\\n\t.type = IIO_TEMP, \\\n\t.indexed = 1, \\\n\t.channel = 0, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\tBIT(IIO_CHAN_INFO_OFFSET) | \\\n\t\tBIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.address = (addr), \\\n\t.scan_index = ADIS16350_SCAN_TEMP_X, \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = (bits), \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 0, \\\n\t\t.endianness = IIO_BE, \\\n\t}, \\\n}\n\n#define ADIS16400_INCLI_CHAN(mod, addr, bits) { \\\n\t.type = IIO_INCLI, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_ ## mod, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.address = (addr), \\\n\t.scan_index = ADIS16300_SCAN_INCLI_ ## mod, \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = (bits), \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 0, \\\n\t\t.endianness = IIO_BE, \\\n\t}, \\\n}\n\nstatic const struct iio_chan_spec adis16400_channels[] = {\n\tADIS16400_SUPPLY_CHAN(ADIS16400_SUPPLY_OUT, 14),\n\tADIS16400_GYRO_CHAN(X, ADIS16400_XGYRO_OUT, 14),\n\tADIS16400_GYRO_CHAN(Y, ADIS16400_YGYRO_OUT, 14),\n\tADIS16400_GYRO_CHAN(Z, ADIS16400_ZGYRO_OUT, 14),\n\tADIS16400_ACCEL_CHAN(X, ADIS16400_XACCL_OUT, 14),\n\tADIS16400_ACCEL_CHAN(Y, ADIS16400_YACCL_OUT, 14),\n\tADIS16400_ACCEL_CHAN(Z, ADIS16400_ZACCL_OUT, 14),\n\tADIS16400_MAGN_CHAN(X, ADIS16400_XMAGN_OUT, 14),\n\tADIS16400_MAGN_CHAN(Y, ADIS16400_YMAGN_OUT, 14),\n\tADIS16400_MAGN_CHAN(Z, ADIS16400_ZMAGN_OUT, 14),\n\tADIS16400_TEMP_CHAN(ADIS16400_TEMP_OUT, 12),\n\tADIS16400_AUX_ADC_CHAN(ADIS16400_AUX_ADC, 12),\n\tIIO_CHAN_SOFT_TIMESTAMP(ADIS16400_SCAN_TIMESTAMP),\n};\n\nstatic const struct iio_chan_spec adis16445_channels[] = {\n\tADIS16400_GYRO_CHAN(X, ADIS16400_XGYRO_OUT, 16),\n\tADIS16400_GYRO_CHAN(Y, ADIS16400_YGYRO_OUT, 16),\n\tADIS16400_GYRO_CHAN(Z, ADIS16400_ZGYRO_OUT, 16),\n\tADIS16400_ACCEL_CHAN(X, ADIS16400_XACCL_OUT, 16),\n\tADIS16400_ACCEL_CHAN(Y, ADIS16400_YACCL_OUT, 16),\n\tADIS16400_ACCEL_CHAN(Z, ADIS16400_ZACCL_OUT, 16),\n\tADIS16400_TEMP_CHAN(ADIS16448_TEMP_OUT, 12),\n\tIIO_CHAN_SOFT_TIMESTAMP(ADIS16400_SCAN_TIMESTAMP),\n};\n\nstatic const struct iio_chan_spec adis16448_channels[] = {\n\tADIS16400_GYRO_CHAN(X, ADIS16400_XGYRO_OUT, 16),\n\tADIS16400_GYRO_CHAN(Y, ADIS16400_YGYRO_OUT, 16),\n\tADIS16400_GYRO_CHAN(Z, ADIS16400_ZGYRO_OUT, 16),\n\tADIS16400_ACCEL_CHAN(X, ADIS16400_XACCL_OUT, 16),\n\tADIS16400_ACCEL_CHAN(Y, ADIS16400_YACCL_OUT, 16),\n\tADIS16400_ACCEL_CHAN(Z, ADIS16400_ZACCL_OUT, 16),\n\tADIS16400_MAGN_CHAN(X, ADIS16400_XMAGN_OUT, 16),\n\tADIS16400_MAGN_CHAN(Y, ADIS16400_YMAGN_OUT, 16),\n\tADIS16400_MAGN_CHAN(Z, ADIS16400_ZMAGN_OUT, 16),\n\t{\n\t\t.type = IIO_PRESSURE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.address = ADIS16448_BARO_OUT,\n\t\t.scan_index = ADIS16400_SCAN_BARO,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\tADIS16400_TEMP_CHAN(ADIS16448_TEMP_OUT, 12),\n\tIIO_CHAN_SOFT_TIMESTAMP(ADIS16400_SCAN_TIMESTAMP),\n};\n\nstatic const struct iio_chan_spec adis16350_channels[] = {\n\tADIS16400_SUPPLY_CHAN(ADIS16400_SUPPLY_OUT, 12),\n\tADIS16400_GYRO_CHAN(X, ADIS16400_XGYRO_OUT, 14),\n\tADIS16400_GYRO_CHAN(Y, ADIS16400_YGYRO_OUT, 14),\n\tADIS16400_GYRO_CHAN(Z, ADIS16400_ZGYRO_OUT, 14),\n\tADIS16400_ACCEL_CHAN(X, ADIS16400_XACCL_OUT, 14),\n\tADIS16400_ACCEL_CHAN(Y, ADIS16400_YACCL_OUT, 14),\n\tADIS16400_ACCEL_CHAN(Z, ADIS16400_ZACCL_OUT, 14),\n\tADIS16400_MAGN_CHAN(X, ADIS16400_XMAGN_OUT, 14),\n\tADIS16400_MAGN_CHAN(Y, ADIS16400_YMAGN_OUT, 14),\n\tADIS16400_MAGN_CHAN(Z, ADIS16400_ZMAGN_OUT, 14),\n\tADIS16400_AUX_ADC_CHAN(ADIS16300_AUX_ADC, 12),\n\tADIS16400_MOD_TEMP_CHAN(X, ADIS16350_XTEMP_OUT, 12),\n\tADIS16400_MOD_TEMP_CHAN(Y, ADIS16350_YTEMP_OUT, 12),\n\tADIS16400_MOD_TEMP_CHAN(Z, ADIS16350_ZTEMP_OUT, 12),\n\tIIO_CHAN_SOFT_TIMESTAMP(ADIS16400_SCAN_TIMESTAMP),\n};\n\nstatic const struct iio_chan_spec adis16300_channels[] = {\n\tADIS16400_SUPPLY_CHAN(ADIS16400_SUPPLY_OUT, 12),\n\tADIS16400_GYRO_CHAN(X, ADIS16400_XGYRO_OUT, 14),\n\tADIS16400_ACCEL_CHAN(X, ADIS16400_XACCL_OUT, 14),\n\tADIS16400_ACCEL_CHAN(Y, ADIS16400_YACCL_OUT, 14),\n\tADIS16400_ACCEL_CHAN(Z, ADIS16400_ZACCL_OUT, 14),\n\tADIS16400_TEMP_CHAN(ADIS16350_XTEMP_OUT, 12),\n\tADIS16400_AUX_ADC_CHAN(ADIS16300_AUX_ADC, 12),\n\tADIS16400_INCLI_CHAN(X, ADIS16300_PITCH_OUT, 13),\n\tADIS16400_INCLI_CHAN(Y, ADIS16300_ROLL_OUT, 13),\n\tIIO_CHAN_SOFT_TIMESTAMP(ADIS16400_SCAN_TIMESTAMP),\n};\n\nstatic const struct iio_chan_spec adis16334_channels[] = {\n\tADIS16400_GYRO_CHAN(X, ADIS16400_XGYRO_OUT, 14),\n\tADIS16400_GYRO_CHAN(Y, ADIS16400_YGYRO_OUT, 14),\n\tADIS16400_GYRO_CHAN(Z, ADIS16400_ZGYRO_OUT, 14),\n\tADIS16400_ACCEL_CHAN(X, ADIS16400_XACCL_OUT, 14),\n\tADIS16400_ACCEL_CHAN(Y, ADIS16400_YACCL_OUT, 14),\n\tADIS16400_ACCEL_CHAN(Z, ADIS16400_ZACCL_OUT, 14),\n\tADIS16400_TEMP_CHAN(ADIS16350_XTEMP_OUT, 12),\n\tIIO_CHAN_SOFT_TIMESTAMP(ADIS16400_SCAN_TIMESTAMP),\n};\n\nstatic const char * const adis16400_status_error_msgs[] = {\n\t[ADIS16400_DIAG_STAT_ZACCL_FAIL] = \"Z-axis accelerometer self-test failure\",\n\t[ADIS16400_DIAG_STAT_YACCL_FAIL] = \"Y-axis accelerometer self-test failure\",\n\t[ADIS16400_DIAG_STAT_XACCL_FAIL] = \"X-axis accelerometer self-test failure\",\n\t[ADIS16400_DIAG_STAT_XGYRO_FAIL] = \"X-axis gyroscope self-test failure\",\n\t[ADIS16400_DIAG_STAT_YGYRO_FAIL] = \"Y-axis gyroscope self-test failure\",\n\t[ADIS16400_DIAG_STAT_ZGYRO_FAIL] = \"Z-axis gyroscope self-test failure\",\n\t[ADIS16400_DIAG_STAT_ALARM2] = \"Alarm 2 active\",\n\t[ADIS16400_DIAG_STAT_ALARM1] = \"Alarm 1 active\",\n\t[ADIS16400_DIAG_STAT_FLASH_CHK] = \"Flash checksum error\",\n\t[ADIS16400_DIAG_STAT_SELF_TEST] = \"Self test error\",\n\t[ADIS16400_DIAG_STAT_OVERFLOW] = \"Sensor overrange\",\n\t[ADIS16400_DIAG_STAT_SPI_FAIL] = \"SPI failure\",\n\t[ADIS16400_DIAG_STAT_FLASH_UPT] = \"Flash update failed\",\n\t[ADIS16400_DIAG_STAT_POWER_HIGH] = \"Power supply above 5.25V\",\n\t[ADIS16400_DIAG_STAT_POWER_LOW] = \"Power supply below 4.75V\",\n};\n\n#define ADIS16400_DATA(_timeouts, _burst_len)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.msc_ctrl_reg = ADIS16400_MSC_CTRL,\t\t\t\t\\\n\t.glob_cmd_reg = ADIS16400_GLOB_CMD,\t\t\t\t\\\n\t.diag_stat_reg = ADIS16400_DIAG_STAT,\t\t\t\t\\\n\t.read_delay = 50,\t\t\t\t\t\t\\\n\t.write_delay = 50,\t\t\t\t\t\t\\\n\t.self_test_mask = ADIS16400_MSC_CTRL_MEM_TEST,\t\t\t\\\n\t.self_test_reg = ADIS16400_MSC_CTRL,\t\t\t\t\\\n\t.status_error_msgs = adis16400_status_error_msgs,\t\t\\\n\t.status_error_mask = BIT(ADIS16400_DIAG_STAT_ZACCL_FAIL) |\t\\\n\t\tBIT(ADIS16400_DIAG_STAT_YACCL_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16400_DIAG_STAT_XACCL_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16400_DIAG_STAT_XGYRO_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16400_DIAG_STAT_YGYRO_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16400_DIAG_STAT_ZGYRO_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16400_DIAG_STAT_ALARM2) |\t\t\t\\\n\t\tBIT(ADIS16400_DIAG_STAT_ALARM1) |\t\t\t\\\n\t\tBIT(ADIS16400_DIAG_STAT_FLASH_CHK) |\t\t\t\\\n\t\tBIT(ADIS16400_DIAG_STAT_SELF_TEST) |\t\t\t\\\n\t\tBIT(ADIS16400_DIAG_STAT_OVERFLOW) |\t\t\t\\\n\t\tBIT(ADIS16400_DIAG_STAT_SPI_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16400_DIAG_STAT_FLASH_UPT) |\t\t\t\\\n\t\tBIT(ADIS16400_DIAG_STAT_POWER_HIGH) |\t\t\t\\\n\t\tBIT(ADIS16400_DIAG_STAT_POWER_LOW),\t\t\t\\\n\t.timeouts = (_timeouts),\t\t\t\t\t\\\n\t.burst_reg_cmd = ADIS16400_GLOB_CMD,\t\t\t\t\\\n\t.burst_len = (_burst_len),\t\t\t\t\t\\\n\t.burst_max_speed_hz = ADIS16400_SPI_BURST\t\t\t\\\n}\n\nstatic const struct adis_timeout adis16300_timeouts = {\n\t.reset_ms = ADIS16400_STARTUP_DELAY,\n\t.sw_reset_ms = ADIS16400_STARTUP_DELAY,\n\t.self_test_ms = ADIS16400_STARTUP_DELAY,\n};\n\nstatic const struct adis_timeout adis16334_timeouts = {\n\t.reset_ms = 60,\n\t.sw_reset_ms = 60,\n\t.self_test_ms = 14,\n};\n\nstatic const struct adis_timeout adis16362_timeouts = {\n\t.reset_ms = 130,\n\t.sw_reset_ms = 130,\n\t.self_test_ms = 12,\n};\n\nstatic const struct adis_timeout adis16400_timeouts = {\n\t.reset_ms = 170,\n\t.sw_reset_ms = 170,\n\t.self_test_ms = 12,\n};\n\nstatic const struct adis_timeout adis16445_timeouts = {\n\t.reset_ms = 55,\n\t.sw_reset_ms = 55,\n\t.self_test_ms = 16,\n};\n\nstatic const struct adis_timeout adis16448_timeouts = {\n\t.reset_ms = 90,\n\t.sw_reset_ms = 90,\n\t.self_test_ms = 45,\n};\n\nstatic struct adis16400_chip_info adis16400_chips[] = {\n\t[ADIS16300] = {\n\t\t.channels = adis16300_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16300_channels),\n\t\t.flags = ADIS16400_HAS_PROD_ID | ADIS16400_HAS_SLOW_MODE |\n\t\t\t\tADIS16400_HAS_SERIAL_NUMBER,\n\t\t.gyro_scale_micro = IIO_DEGREE_TO_RAD(50000),  \n\t\t.accel_scale_micro = 5884,\n\t\t.temp_scale_nano = 140000000,  \n\t\t.temp_offset = 25000000 / 140000,  \n\t\t.set_freq = adis16400_set_freq,\n\t\t.get_freq = adis16400_get_freq,\n\t\t.adis_data = ADIS16400_DATA(&adis16300_timeouts, 18),\n\t},\n\t[ADIS16334] = {\n\t\t.channels = adis16334_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16334_channels),\n\t\t.flags = ADIS16400_HAS_PROD_ID | ADIS16400_NO_BURST |\n\t\t\t\tADIS16400_HAS_SERIAL_NUMBER,\n\t\t.gyro_scale_micro = IIO_DEGREE_TO_RAD(50000),  \n\t\t.accel_scale_micro = IIO_G_TO_M_S_2(1000),  \n\t\t.temp_scale_nano = 67850000,  \n\t\t.temp_offset = 25000000 / 67850,  \n\t\t.set_freq = adis16334_set_freq,\n\t\t.get_freq = adis16334_get_freq,\n\t\t.adis_data = ADIS16400_DATA(&adis16334_timeouts, 0),\n\t},\n\t[ADIS16350] = {\n\t\t.channels = adis16350_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16350_channels),\n\t\t.gyro_scale_micro = IIO_DEGREE_TO_RAD(73260),  \n\t\t.accel_scale_micro = IIO_G_TO_M_S_2(2522),  \n\t\t.temp_scale_nano = 145300000,  \n\t\t.temp_offset = 25000000 / 145300,  \n\t\t.flags = ADIS16400_NO_BURST | ADIS16400_HAS_SLOW_MODE,\n\t\t.set_freq = adis16400_set_freq,\n\t\t.get_freq = adis16400_get_freq,\n\t\t.adis_data = ADIS16400_DATA(&adis16300_timeouts, 0),\n\t},\n\t[ADIS16360] = {\n\t\t.channels = adis16350_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16350_channels),\n\t\t.flags = ADIS16400_HAS_PROD_ID | ADIS16400_HAS_SLOW_MODE |\n\t\t\t\tADIS16400_HAS_SERIAL_NUMBER,\n\t\t.gyro_scale_micro = IIO_DEGREE_TO_RAD(50000),  \n\t\t.accel_scale_micro = IIO_G_TO_M_S_2(3333),  \n\t\t.temp_scale_nano = 136000000,  \n\t\t.temp_offset = 25000000 / 136000,  \n\t\t.set_freq = adis16400_set_freq,\n\t\t.get_freq = adis16400_get_freq,\n\t\t.adis_data = ADIS16400_DATA(&adis16300_timeouts, 28),\n\t},\n\t[ADIS16362] = {\n\t\t.channels = adis16350_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16350_channels),\n\t\t.flags = ADIS16400_HAS_PROD_ID | ADIS16400_HAS_SLOW_MODE |\n\t\t\t\tADIS16400_HAS_SERIAL_NUMBER,\n\t\t.gyro_scale_micro = IIO_DEGREE_TO_RAD(50000),  \n\t\t.accel_scale_micro = IIO_G_TO_M_S_2(333),  \n\t\t.temp_scale_nano = 136000000,  \n\t\t.temp_offset = 25000000 / 136000,  \n\t\t.set_freq = adis16400_set_freq,\n\t\t.get_freq = adis16400_get_freq,\n\t\t.adis_data = ADIS16400_DATA(&adis16362_timeouts, 28),\n\t},\n\t[ADIS16364] = {\n\t\t.channels = adis16350_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16350_channels),\n\t\t.flags = ADIS16400_HAS_PROD_ID | ADIS16400_HAS_SLOW_MODE |\n\t\t\t\tADIS16400_HAS_SERIAL_NUMBER,\n\t\t.gyro_scale_micro = IIO_DEGREE_TO_RAD(50000),  \n\t\t.accel_scale_micro = IIO_G_TO_M_S_2(1000),  \n\t\t.temp_scale_nano = 136000000,  \n\t\t.temp_offset = 25000000 / 136000,  \n\t\t.set_freq = adis16400_set_freq,\n\t\t.get_freq = adis16400_get_freq,\n\t\t.adis_data = ADIS16400_DATA(&adis16362_timeouts, 28),\n\t},\n\t[ADIS16367] = {\n\t\t.channels = adis16350_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16350_channels),\n\t\t.flags = ADIS16400_HAS_PROD_ID | ADIS16400_HAS_SLOW_MODE |\n\t\t\t\tADIS16400_HAS_SERIAL_NUMBER,\n\t\t.gyro_scale_micro = IIO_DEGREE_TO_RAD(2000),  \n\t\t.accel_scale_micro = IIO_G_TO_M_S_2(3333),  \n\t\t.temp_scale_nano = 136000000,  \n\t\t.temp_offset = 25000000 / 136000,  \n\t\t.set_freq = adis16400_set_freq,\n\t\t.get_freq = adis16400_get_freq,\n\t\t.adis_data = ADIS16400_DATA(&adis16300_timeouts, 28),\n\t},\n\t[ADIS16400] = {\n\t\t.channels = adis16400_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16400_channels),\n\t\t.flags = ADIS16400_HAS_PROD_ID | ADIS16400_HAS_SLOW_MODE,\n\t\t.gyro_scale_micro = IIO_DEGREE_TO_RAD(50000),  \n\t\t.accel_scale_micro = IIO_G_TO_M_S_2(3333),  \n\t\t.temp_scale_nano = 140000000,  \n\t\t.temp_offset = 25000000 / 140000,  \n\t\t.set_freq = adis16400_set_freq,\n\t\t.get_freq = adis16400_get_freq,\n\t\t.adis_data = ADIS16400_DATA(&adis16400_timeouts, 24),\n\t},\n\t[ADIS16445] = {\n\t\t.channels = adis16445_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16445_channels),\n\t\t.flags = ADIS16400_HAS_PROD_ID |\n\t\t\t\tADIS16400_HAS_SERIAL_NUMBER |\n\t\t\t\tADIS16400_BURST_DIAG_STAT,\n\t\t.gyro_scale_micro = IIO_DEGREE_TO_RAD(10000),  \n\t\t.accel_scale_micro = IIO_G_TO_M_S_2(250),  \n\t\t.temp_scale_nano = 73860000,  \n\t\t.temp_offset = 31000000 / 73860,  \n\t\t.set_freq = adis16334_set_freq,\n\t\t.get_freq = adis16334_get_freq,\n\t\t.adis_data = ADIS16400_DATA(&adis16445_timeouts, 16),\n\t},\n\t[ADIS16448] = {\n\t\t.channels = adis16448_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16448_channels),\n\t\t.flags = ADIS16400_HAS_PROD_ID |\n\t\t\t\tADIS16400_HAS_SERIAL_NUMBER |\n\t\t\t\tADIS16400_BURST_DIAG_STAT,\n\t\t.gyro_scale_micro = IIO_DEGREE_TO_RAD(40000),  \n\t\t.accel_scale_micro = IIO_G_TO_M_S_2(833),  \n\t\t.temp_scale_nano = 73860000,  \n\t\t.temp_offset = 31000000 / 73860,  \n\t\t.set_freq = adis16334_set_freq,\n\t\t.get_freq = adis16334_get_freq,\n\t\t.adis_data = ADIS16400_DATA(&adis16448_timeouts, 24),\n\t}\n};\n\nstatic const struct iio_info adis16400_info = {\n\t.read_raw = &adis16400_read_raw,\n\t.write_raw = &adis16400_write_raw,\n\t.update_scan_mode = adis_update_scan_mode,\n\t.debugfs_reg_access = adis_debugfs_reg_access,\n};\n\nstatic void adis16400_setup_chan_mask(struct adis16400_state *st)\n{\n\tconst struct adis16400_chip_info *chip_info = st->variant;\n\tunsigned int i;\n\n\tfor (i = 0; i < chip_info->num_channels; i++) {\n\t\tconst struct iio_chan_spec *ch = &chip_info->channels[i];\n\n\t\tif (ch->scan_index >= 0 &&\n\t\t    ch->scan_index != ADIS16400_SCAN_TIMESTAMP)\n\t\t\tst->avail_scan_mask[0] |= BIT(ch->scan_index);\n\t}\n}\n\nstatic void adis16400_stop(void *data)\n{\n\tadis16400_stop_device(data);\n}\n\nstatic int adis16400_probe(struct spi_device *spi)\n{\n\tstruct adis16400_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\tconst struct adis_data *adis16400_data;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\t \n\tst->variant = &adis16400_chips[spi_get_device_id(spi)->driver_data];\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->channels = st->variant->channels;\n\tindio_dev->num_channels = st->variant->num_channels;\n\tindio_dev->info = &adis16400_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tif (!(st->variant->flags & ADIS16400_NO_BURST)) {\n\t\tadis16400_setup_chan_mask(st);\n\t\tindio_dev->available_scan_masks = st->avail_scan_mask;\n\t}\n\n\tadis16400_data = &st->variant->adis_data;\n\n\tret = adis_init(&st->adis, indio_dev, spi, adis16400_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_adis_setup_buffer_and_trigger(&st->adis, indio_dev, adis16400_trigger_handler);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = adis16400_initial_setup(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, adis16400_stop, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_device_register(&spi->dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tadis16400_debugfs_init(indio_dev);\n\treturn 0;\n}\n\nstatic const struct spi_device_id adis16400_id[] = {\n\t{\"adis16300\", ADIS16300},\n\t{\"adis16305\", ADIS16300},\n\t{\"adis16334\", ADIS16334},\n\t{\"adis16350\", ADIS16350},\n\t{\"adis16354\", ADIS16350},\n\t{\"adis16355\", ADIS16350},\n\t{\"adis16360\", ADIS16360},\n\t{\"adis16362\", ADIS16362},\n\t{\"adis16364\", ADIS16364},\n\t{\"adis16365\", ADIS16360},\n\t{\"adis16367\", ADIS16367},\n\t{\"adis16400\", ADIS16400},\n\t{\"adis16405\", ADIS16400},\n\t{\"adis16445\", ADIS16445},\n\t{\"adis16448\", ADIS16448},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, adis16400_id);\n\nstatic struct spi_driver adis16400_driver = {\n\t.driver = {\n\t\t.name = \"adis16400\",\n\t},\n\t.id_table = adis16400_id,\n\t.probe = adis16400_probe,\n};\nmodule_spi_driver(adis16400_driver);\n\nMODULE_AUTHOR(\"Manuel Stahl <manuel.stahl@iis.fraunhofer.de>\");\nMODULE_DESCRIPTION(\"Analog Devices ADIS16400/5 IMU SPI driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_ADISLIB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}