{
  "module_name": "st_lsm6dsx_buffer.c",
  "hash_id": "b23e01a7a488c8c4ed08fa680fa2dbb3880e459616e23cdc44b13a3d2d9b818b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/st_lsm6dsx/st_lsm6dsx_buffer.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/iio/kfifo_buf.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/regmap.h>\n#include <linux/bitfield.h>\n\n#include <linux/platform_data/st_sensors_pdata.h>\n\n#include \"st_lsm6dsx.h\"\n\n#define ST_LSM6DSX_REG_FIFO_MODE_ADDR\t\t0x0a\n#define ST_LSM6DSX_FIFO_MODE_MASK\t\tGENMASK(2, 0)\n#define ST_LSM6DSX_FIFO_ODR_MASK\t\tGENMASK(6, 3)\n#define ST_LSM6DSX_FIFO_EMPTY_MASK\t\tBIT(12)\n#define ST_LSM6DSX_REG_FIFO_OUTL_ADDR\t\t0x3e\n#define ST_LSM6DSX_REG_FIFO_OUT_TAG_ADDR\t0x78\n#define ST_LSM6DSX_REG_TS_RESET_ADDR\t\t0x42\n\n#define ST_LSM6DSX_MAX_FIFO_ODR_VAL\t\t0x08\n\n#define ST_LSM6DSX_TS_RESET_VAL\t\t\t0xaa\n\nstruct st_lsm6dsx_decimator_entry {\n\tu8 decimator;\n\tu8 val;\n};\n\nenum st_lsm6dsx_fifo_tag {\n\tST_LSM6DSX_GYRO_TAG = 0x01,\n\tST_LSM6DSX_ACC_TAG = 0x02,\n\tST_LSM6DSX_TS_TAG = 0x04,\n\tST_LSM6DSX_EXT0_TAG = 0x0f,\n\tST_LSM6DSX_EXT1_TAG = 0x10,\n\tST_LSM6DSX_EXT2_TAG = 0x11,\n};\n\nstatic const\nstruct st_lsm6dsx_decimator_entry st_lsm6dsx_decimator_table[] = {\n\t{  0, 0x0 },\n\t{  1, 0x1 },\n\t{  2, 0x2 },\n\t{  3, 0x3 },\n\t{  4, 0x4 },\n\t{  8, 0x5 },\n\t{ 16, 0x6 },\n\t{ 32, 0x7 },\n};\n\nstatic int\nst_lsm6dsx_get_decimator_val(struct st_lsm6dsx_sensor *sensor, u32 max_odr)\n{\n\tconst int max_size = ARRAY_SIZE(st_lsm6dsx_decimator_table);\n\tu32 decimator =  max_odr / sensor->odr;\n\tint i;\n\n\tif (decimator > 1)\n\t\tdecimator = round_down(decimator, 2);\n\n\tfor (i = 0; i < max_size; i++) {\n\t\tif (st_lsm6dsx_decimator_table[i].decimator == decimator)\n\t\t\tbreak;\n\t}\n\n\tsensor->decimator = decimator;\n\treturn i == max_size ? 0 : st_lsm6dsx_decimator_table[i].val;\n}\n\nstatic void st_lsm6dsx_get_max_min_odr(struct st_lsm6dsx_hw *hw,\n\t\t\t\t       u32 *max_odr, u32 *min_odr)\n{\n\tstruct st_lsm6dsx_sensor *sensor;\n\tint i;\n\n\t*max_odr = 0, *min_odr = ~0;\n\tfor (i = 0; i < ST_LSM6DSX_ID_MAX; i++) {\n\t\tif (!hw->iio_devs[i])\n\t\t\tcontinue;\n\n\t\tsensor = iio_priv(hw->iio_devs[i]);\n\n\t\tif (!(hw->enable_mask & BIT(sensor->id)))\n\t\t\tcontinue;\n\n\t\t*max_odr = max_t(u32, *max_odr, sensor->odr);\n\t\t*min_odr = min_t(u32, *min_odr, sensor->odr);\n\t}\n}\n\nstatic u8 st_lsm6dsx_get_sip(struct st_lsm6dsx_sensor *sensor, u32 min_odr)\n{\n\tu8 sip = sensor->odr / min_odr;\n\n\treturn sip > 1 ? round_down(sip, 2) : sip;\n}\n\nstatic int st_lsm6dsx_update_decimators(struct st_lsm6dsx_hw *hw)\n{\n\tconst struct st_lsm6dsx_reg *ts_dec_reg;\n\tstruct st_lsm6dsx_sensor *sensor;\n\tu16 sip = 0, ts_sip = 0;\n\tu32 max_odr, min_odr;\n\tint err = 0, i;\n\tu8 data;\n\n\tst_lsm6dsx_get_max_min_odr(hw, &max_odr, &min_odr);\n\n\tfor (i = 0; i < ST_LSM6DSX_ID_MAX; i++) {\n\t\tconst struct st_lsm6dsx_reg *dec_reg;\n\n\t\tif (!hw->iio_devs[i])\n\t\t\tcontinue;\n\n\t\tsensor = iio_priv(hw->iio_devs[i]);\n\t\t \n\t\tif (hw->enable_mask & BIT(sensor->id)) {\n\t\t\tsensor->sip = st_lsm6dsx_get_sip(sensor, min_odr);\n\t\t\tdata = st_lsm6dsx_get_decimator_val(sensor, max_odr);\n\t\t} else {\n\t\t\tsensor->sip = 0;\n\t\t\tdata = 0;\n\t\t}\n\t\tts_sip = max_t(u16, ts_sip, sensor->sip);\n\n\t\tdec_reg = &hw->settings->decimator[sensor->id];\n\t\tif (dec_reg->addr) {\n\t\t\tint val = ST_LSM6DSX_SHIFT_VAL(data, dec_reg->mask);\n\n\t\t\terr = st_lsm6dsx_update_bits_locked(hw, dec_reg->addr,\n\t\t\t\t\t\t\t    dec_reg->mask,\n\t\t\t\t\t\t\t    val);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tsip += sensor->sip;\n\t}\n\thw->sip = sip + ts_sip;\n\thw->ts_sip = ts_sip;\n\n\t \n\tts_dec_reg = &hw->settings->ts_settings.decimator;\n\tif (ts_dec_reg->addr) {\n\t\tint val, ts_dec = !!hw->ts_sip;\n\n\t\tval = ST_LSM6DSX_SHIFT_VAL(ts_dec, ts_dec_reg->mask);\n\t\terr = st_lsm6dsx_update_bits_locked(hw, ts_dec_reg->addr,\n\t\t\t\t\t\t    ts_dec_reg->mask, val);\n\t}\n\treturn err;\n}\n\nstatic int st_lsm6dsx_set_fifo_mode(struct st_lsm6dsx_hw *hw,\n\t\t\t\t    enum st_lsm6dsx_fifo_mode fifo_mode)\n{\n\tunsigned int data;\n\n\tdata = FIELD_PREP(ST_LSM6DSX_FIFO_MODE_MASK, fifo_mode);\n\treturn st_lsm6dsx_update_bits_locked(hw, ST_LSM6DSX_REG_FIFO_MODE_ADDR,\n\t\t\t\t\t     ST_LSM6DSX_FIFO_MODE_MASK, data);\n}\n\nstatic int st_lsm6dsx_set_fifo_odr(struct st_lsm6dsx_sensor *sensor,\n\t\t\t\t   bool enable)\n{\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tconst struct st_lsm6dsx_reg *batch_reg;\n\tu8 data;\n\n\tbatch_reg = &hw->settings->batch[sensor->id];\n\tif (batch_reg->addr) {\n\t\tint val;\n\n\t\tif (enable) {\n\t\t\tint err;\n\n\t\t\terr = st_lsm6dsx_check_odr(sensor, sensor->odr,\n\t\t\t\t\t\t   &data);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tdata = 0;\n\t\t}\n\t\tval = ST_LSM6DSX_SHIFT_VAL(data, batch_reg->mask);\n\t\treturn st_lsm6dsx_update_bits_locked(hw, batch_reg->addr,\n\t\t\t\t\t\t     batch_reg->mask, val);\n\t} else {\n\t\tdata = hw->enable_mask ? ST_LSM6DSX_MAX_FIFO_ODR_VAL : 0;\n\t\treturn st_lsm6dsx_update_bits_locked(hw,\n\t\t\t\t\tST_LSM6DSX_REG_FIFO_MODE_ADDR,\n\t\t\t\t\tST_LSM6DSX_FIFO_ODR_MASK,\n\t\t\t\t\tFIELD_PREP(ST_LSM6DSX_FIFO_ODR_MASK,\n\t\t\t\t\t\t   data));\n\t}\n}\n\nint st_lsm6dsx_update_watermark(struct st_lsm6dsx_sensor *sensor, u16 watermark)\n{\n\tu16 fifo_watermark = ~0, cur_watermark, fifo_th_mask;\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tstruct st_lsm6dsx_sensor *cur_sensor;\n\tint i, err, data;\n\t__le16 wdata;\n\n\tif (!hw->sip)\n\t\treturn 0;\n\n\tfor (i = 0; i < ST_LSM6DSX_ID_MAX; i++) {\n\t\tif (!hw->iio_devs[i])\n\t\t\tcontinue;\n\n\t\tcur_sensor = iio_priv(hw->iio_devs[i]);\n\n\t\tif (!(hw->enable_mask & BIT(cur_sensor->id)))\n\t\t\tcontinue;\n\n\t\tcur_watermark = (cur_sensor == sensor) ? watermark\n\t\t\t\t\t\t       : cur_sensor->watermark;\n\n\t\tfifo_watermark = min_t(u16, fifo_watermark, cur_watermark);\n\t}\n\n\tfifo_watermark = max_t(u16, fifo_watermark, hw->sip);\n\tfifo_watermark = (fifo_watermark / hw->sip) * hw->sip;\n\tfifo_watermark = fifo_watermark * hw->settings->fifo_ops.th_wl;\n\n\tmutex_lock(&hw->page_lock);\n\terr = regmap_read(hw->regmap, hw->settings->fifo_ops.fifo_th.addr + 1,\n\t\t\t  &data);\n\tif (err < 0)\n\t\tgoto out;\n\n\tfifo_th_mask = hw->settings->fifo_ops.fifo_th.mask;\n\tfifo_watermark = ((data << 8) & ~fifo_th_mask) |\n\t\t\t (fifo_watermark & fifo_th_mask);\n\n\twdata = cpu_to_le16(fifo_watermark);\n\terr = regmap_bulk_write(hw->regmap,\n\t\t\t\thw->settings->fifo_ops.fifo_th.addr,\n\t\t\t\t&wdata, sizeof(wdata));\nout:\n\tmutex_unlock(&hw->page_lock);\n\treturn err;\n}\n\nstatic int st_lsm6dsx_reset_hw_ts(struct st_lsm6dsx_hw *hw)\n{\n\tstruct st_lsm6dsx_sensor *sensor;\n\tint i, err;\n\n\t \n\terr = st_lsm6dsx_write_locked(hw, ST_LSM6DSX_REG_TS_RESET_ADDR,\n\t\t\t\t      ST_LSM6DSX_TS_RESET_VAL);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < ST_LSM6DSX_ID_MAX; i++) {\n\t\tif (!hw->iio_devs[i])\n\t\t\tcontinue;\n\n\t\tsensor = iio_priv(hw->iio_devs[i]);\n\t\t \n\t\tsensor->ts_ref = iio_get_time_ns(hw->iio_devs[i]);\n\t}\n\treturn 0;\n}\n\nint st_lsm6dsx_resume_fifo(struct st_lsm6dsx_hw *hw)\n{\n\tint err;\n\n\t \n\terr = st_lsm6dsx_reset_hw_ts(hw);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn st_lsm6dsx_set_fifo_mode(hw, ST_LSM6DSX_FIFO_CONT);\n}\n\n \nstatic inline int st_lsm6dsx_read_block(struct st_lsm6dsx_hw *hw, u8 addr,\n\t\t\t\t\tu8 *data, unsigned int data_len,\n\t\t\t\t\tunsigned int max_word_len)\n{\n\tunsigned int word_len, read_len = 0;\n\tint err;\n\n\twhile (read_len < data_len) {\n\t\tword_len = min_t(unsigned int, data_len - read_len,\n\t\t\t\t max_word_len);\n\t\terr = st_lsm6dsx_read_locked(hw, addr, data + read_len,\n\t\t\t\t\t     word_len);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tread_len += word_len;\n\t}\n\treturn 0;\n}\n\n#define ST_LSM6DSX_IIO_BUFF_SIZE\t(ALIGN(ST_LSM6DSX_SAMPLE_SIZE, \\\n\t\t\t\t\t       sizeof(s64)) + sizeof(s64))\n \nint st_lsm6dsx_read_fifo(struct st_lsm6dsx_hw *hw)\n{\n\tstruct st_lsm6dsx_sensor *acc_sensor, *gyro_sensor, *ext_sensor = NULL;\n\tint err, sip, acc_sip, gyro_sip, ts_sip, ext_sip, read_len, offset;\n\tu16 fifo_len, pattern_len = hw->sip * ST_LSM6DSX_SAMPLE_SIZE;\n\tu16 fifo_diff_mask = hw->settings->fifo_ops.fifo_diff.mask;\n\tbool reset_ts = false;\n\t__le16 fifo_status;\n\ts64 ts = 0;\n\n\terr = st_lsm6dsx_read_locked(hw,\n\t\t\t\t     hw->settings->fifo_ops.fifo_diff.addr,\n\t\t\t\t     &fifo_status, sizeof(fifo_status));\n\tif (err < 0) {\n\t\tdev_err(hw->dev, \"failed to read fifo status (err=%d)\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tif (fifo_status & cpu_to_le16(ST_LSM6DSX_FIFO_EMPTY_MASK))\n\t\treturn 0;\n\n\tfifo_len = (le16_to_cpu(fifo_status) & fifo_diff_mask) *\n\t\t   ST_LSM6DSX_CHAN_SIZE;\n\tfifo_len = (fifo_len / pattern_len) * pattern_len;\n\n\tacc_sensor = iio_priv(hw->iio_devs[ST_LSM6DSX_ID_ACC]);\n\tgyro_sensor = iio_priv(hw->iio_devs[ST_LSM6DSX_ID_GYRO]);\n\tif (hw->iio_devs[ST_LSM6DSX_ID_EXT0])\n\t\text_sensor = iio_priv(hw->iio_devs[ST_LSM6DSX_ID_EXT0]);\n\n\tfor (read_len = 0; read_len < fifo_len; read_len += pattern_len) {\n\t\terr = st_lsm6dsx_read_block(hw, ST_LSM6DSX_REG_FIFO_OUTL_ADDR,\n\t\t\t\t\t    hw->buff, pattern_len,\n\t\t\t\t\t    ST_LSM6DSX_MAX_WORD_LEN);\n\t\tif (err < 0) {\n\t\t\tdev_err(hw->dev,\n\t\t\t\t\"failed to read pattern from fifo (err=%d)\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\text_sip = ext_sensor ? ext_sensor->sip : 0;\n\t\tgyro_sip = gyro_sensor->sip;\n\t\tacc_sip = acc_sensor->sip;\n\t\tts_sip = hw->ts_sip;\n\t\toffset = 0;\n\t\tsip = 0;\n\n\t\twhile (acc_sip > 0 || gyro_sip > 0 || ext_sip > 0) {\n\t\t\tif (gyro_sip > 0 && !(sip % gyro_sensor->decimator)) {\n\t\t\t\tmemcpy(hw->scan[ST_LSM6DSX_ID_GYRO].channels,\n\t\t\t\t       &hw->buff[offset],\n\t\t\t\t       sizeof(hw->scan[ST_LSM6DSX_ID_GYRO].channels));\n\t\t\t\toffset += sizeof(hw->scan[ST_LSM6DSX_ID_GYRO].channels);\n\t\t\t}\n\t\t\tif (acc_sip > 0 && !(sip % acc_sensor->decimator)) {\n\t\t\t\tmemcpy(hw->scan[ST_LSM6DSX_ID_ACC].channels,\n\t\t\t\t       &hw->buff[offset],\n\t\t\t\t       sizeof(hw->scan[ST_LSM6DSX_ID_ACC].channels));\n\t\t\t\toffset += sizeof(hw->scan[ST_LSM6DSX_ID_ACC].channels);\n\t\t\t}\n\t\t\tif (ext_sip > 0 && !(sip % ext_sensor->decimator)) {\n\t\t\t\tmemcpy(hw->scan[ST_LSM6DSX_ID_EXT0].channels,\n\t\t\t\t       &hw->buff[offset],\n\t\t\t\t       sizeof(hw->scan[ST_LSM6DSX_ID_EXT0].channels));\n\t\t\t\toffset += sizeof(hw->scan[ST_LSM6DSX_ID_EXT0].channels);\n\t\t\t}\n\n\t\t\tif (ts_sip-- > 0) {\n\t\t\t\tu8 data[ST_LSM6DSX_SAMPLE_SIZE];\n\n\t\t\t\tmemcpy(data, &hw->buff[offset], sizeof(data));\n\t\t\t\t \n\t\t\t\tts = data[1] << 16 | data[0] << 8 | data[3];\n\t\t\t\t \n\t\t\t\tif (!reset_ts && ts >= 0xff0000)\n\t\t\t\t\treset_ts = true;\n\t\t\t\tts *= hw->ts_gain;\n\n\t\t\t\toffset += ST_LSM6DSX_SAMPLE_SIZE;\n\t\t\t}\n\n\t\t\tif (gyro_sip > 0 && !(sip % gyro_sensor->decimator)) {\n\t\t\t\t \n\t\t\t\tif (gyro_sensor->samples_to_discard > 0)\n\t\t\t\t\tgyro_sensor->samples_to_discard--;\n\t\t\t\telse\n\t\t\t\t\tiio_push_to_buffers_with_timestamp(\n\t\t\t\t\t\thw->iio_devs[ST_LSM6DSX_ID_GYRO],\n\t\t\t\t\t\t&hw->scan[ST_LSM6DSX_ID_GYRO],\n\t\t\t\t\t\tgyro_sensor->ts_ref + ts);\n\t\t\t\tgyro_sip--;\n\t\t\t}\n\t\t\tif (acc_sip > 0 && !(sip % acc_sensor->decimator)) {\n\t\t\t\t \n\t\t\t\tif (acc_sensor->samples_to_discard > 0)\n\t\t\t\t\tacc_sensor->samples_to_discard--;\n\t\t\t\telse\n\t\t\t\t\tiio_push_to_buffers_with_timestamp(\n\t\t\t\t\t\thw->iio_devs[ST_LSM6DSX_ID_ACC],\n\t\t\t\t\t\t&hw->scan[ST_LSM6DSX_ID_ACC],\n\t\t\t\t\t\tacc_sensor->ts_ref + ts);\n\t\t\t\tacc_sip--;\n\t\t\t}\n\t\t\tif (ext_sip > 0 && !(sip % ext_sensor->decimator)) {\n\t\t\t\tiio_push_to_buffers_with_timestamp(\n\t\t\t\t\thw->iio_devs[ST_LSM6DSX_ID_EXT0],\n\t\t\t\t\t&hw->scan[ST_LSM6DSX_ID_EXT0],\n\t\t\t\t\text_sensor->ts_ref + ts);\n\t\t\t\text_sip--;\n\t\t\t}\n\t\t\tsip++;\n\t\t}\n\t}\n\n\tif (unlikely(reset_ts)) {\n\t\terr = st_lsm6dsx_reset_hw_ts(hw);\n\t\tif (err < 0) {\n\t\t\tdev_err(hw->dev, \"failed to reset hw ts (err=%d)\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn read_len;\n}\n\n#define ST_LSM6DSX_INVALID_SAMPLE\t0x7ffd\nstatic int\nst_lsm6dsx_push_tagged_data(struct st_lsm6dsx_hw *hw, u8 tag,\n\t\t\t    u8 *data, s64 ts)\n{\n\ts16 val = le16_to_cpu(*(__le16 *)data);\n\tstruct st_lsm6dsx_sensor *sensor;\n\tstruct iio_dev *iio_dev;\n\n\t \n\tif (val >= ST_LSM6DSX_INVALID_SAMPLE)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (tag) {\n\tcase ST_LSM6DSX_GYRO_TAG:\n\t\tiio_dev = hw->iio_devs[ST_LSM6DSX_ID_GYRO];\n\t\tbreak;\n\tcase ST_LSM6DSX_ACC_TAG:\n\t\tiio_dev = hw->iio_devs[ST_LSM6DSX_ID_ACC];\n\t\tbreak;\n\tcase ST_LSM6DSX_EXT0_TAG:\n\t\tif (hw->enable_mask & BIT(ST_LSM6DSX_ID_EXT0))\n\t\t\tiio_dev = hw->iio_devs[ST_LSM6DSX_ID_EXT0];\n\t\telse if (hw->enable_mask & BIT(ST_LSM6DSX_ID_EXT1))\n\t\t\tiio_dev = hw->iio_devs[ST_LSM6DSX_ID_EXT1];\n\t\telse\n\t\t\tiio_dev = hw->iio_devs[ST_LSM6DSX_ID_EXT2];\n\t\tbreak;\n\tcase ST_LSM6DSX_EXT1_TAG:\n\t\tif ((hw->enable_mask & BIT(ST_LSM6DSX_ID_EXT0)) &&\n\t\t    (hw->enable_mask & BIT(ST_LSM6DSX_ID_EXT1)))\n\t\t\tiio_dev = hw->iio_devs[ST_LSM6DSX_ID_EXT1];\n\t\telse\n\t\t\tiio_dev = hw->iio_devs[ST_LSM6DSX_ID_EXT2];\n\t\tbreak;\n\tcase ST_LSM6DSX_EXT2_TAG:\n\t\tiio_dev = hw->iio_devs[ST_LSM6DSX_ID_EXT2];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsensor = iio_priv(iio_dev);\n\tiio_push_to_buffers_with_timestamp(iio_dev, data,\n\t\t\t\t\t   ts + sensor->ts_ref);\n\n\treturn 0;\n}\n\n \nint st_lsm6dsx_read_tagged_fifo(struct st_lsm6dsx_hw *hw)\n{\n\tu16 pattern_len = hw->sip * ST_LSM6DSX_TAGGED_SAMPLE_SIZE;\n\tu16 fifo_len, fifo_diff_mask;\n\t \n\tu8 iio_buff[ST_LSM6DSX_IIO_BUFF_SIZE] __aligned(8);\n\tu8 tag;\n\tbool reset_ts = false;\n\tint i, err, read_len;\n\t__le16 fifo_status;\n\ts64 ts = 0;\n\n\terr = st_lsm6dsx_read_locked(hw,\n\t\t\t\t     hw->settings->fifo_ops.fifo_diff.addr,\n\t\t\t\t     &fifo_status, sizeof(fifo_status));\n\tif (err < 0) {\n\t\tdev_err(hw->dev, \"failed to read fifo status (err=%d)\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tfifo_diff_mask = hw->settings->fifo_ops.fifo_diff.mask;\n\tfifo_len = (le16_to_cpu(fifo_status) & fifo_diff_mask) *\n\t\t   ST_LSM6DSX_TAGGED_SAMPLE_SIZE;\n\tif (!fifo_len)\n\t\treturn 0;\n\n\tfor (read_len = 0; read_len < fifo_len; read_len += pattern_len) {\n\t\terr = st_lsm6dsx_read_block(hw,\n\t\t\t\t\t    ST_LSM6DSX_REG_FIFO_OUT_TAG_ADDR,\n\t\t\t\t\t    hw->buff, pattern_len,\n\t\t\t\t\t    ST_LSM6DSX_MAX_TAGGED_WORD_LEN);\n\t\tif (err < 0) {\n\t\t\tdev_err(hw->dev,\n\t\t\t\t\"failed to read pattern from fifo (err=%d)\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\n\t\tfor (i = 0; i < pattern_len;\n\t\t     i += ST_LSM6DSX_TAGGED_SAMPLE_SIZE) {\n\t\t\tmemcpy(iio_buff, &hw->buff[i + ST_LSM6DSX_TAG_SIZE],\n\t\t\t       ST_LSM6DSX_SAMPLE_SIZE);\n\n\t\t\ttag = hw->buff[i] >> 3;\n\t\t\tif (tag == ST_LSM6DSX_TS_TAG) {\n\t\t\t\t \n\t\t\t\tts = le32_to_cpu(*((__le32 *)iio_buff));\n\t\t\t\t \n\t\t\t\tif (!reset_ts && ts >= 0xffff0000)\n\t\t\t\t\treset_ts = true;\n\t\t\t\tts *= hw->ts_gain;\n\t\t\t} else {\n\t\t\t\tst_lsm6dsx_push_tagged_data(hw, tag, iio_buff,\n\t\t\t\t\t\t\t    ts);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(reset_ts)) {\n\t\terr = st_lsm6dsx_reset_hw_ts(hw);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn read_len;\n}\n\nint st_lsm6dsx_flush_fifo(struct st_lsm6dsx_hw *hw)\n{\n\tint err;\n\n\tif (!hw->settings->fifo_ops.read_fifo)\n\t\treturn -ENOTSUPP;\n\n\tmutex_lock(&hw->fifo_lock);\n\n\thw->settings->fifo_ops.read_fifo(hw);\n\terr = st_lsm6dsx_set_fifo_mode(hw, ST_LSM6DSX_FIFO_BYPASS);\n\n\tmutex_unlock(&hw->fifo_lock);\n\n\treturn err;\n}\n\nstatic void\nst_lsm6dsx_update_samples_to_discard(struct st_lsm6dsx_sensor *sensor)\n{\n\tconst struct st_lsm6dsx_samples_to_discard *data;\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tint i;\n\n\tif (sensor->id != ST_LSM6DSX_ID_GYRO &&\n\t    sensor->id != ST_LSM6DSX_ID_ACC)\n\t\treturn;\n\n\t \n\tif (hw->settings->drdy_mask.addr)\n\t\treturn;\n\n\tdata = &hw->settings->samples_to_discard[sensor->id];\n\tfor (i = 0; i < ST_LSM6DSX_ODR_LIST_SIZE; i++) {\n\t\tif (data->val[i].milli_hz == sensor->odr) {\n\t\t\tsensor->samples_to_discard = data->val[i].samples;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint st_lsm6dsx_update_fifo(struct st_lsm6dsx_sensor *sensor, bool enable)\n{\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tu8 fifo_mask;\n\tint err;\n\n\tmutex_lock(&hw->conf_lock);\n\n\tif (enable)\n\t\tfifo_mask = hw->fifo_mask | BIT(sensor->id);\n\telse\n\t\tfifo_mask = hw->fifo_mask & ~BIT(sensor->id);\n\n\tif (hw->fifo_mask) {\n\t\terr = st_lsm6dsx_flush_fifo(hw);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (enable)\n\t\tst_lsm6dsx_update_samples_to_discard(sensor);\n\n\terr = st_lsm6dsx_device_set_enable(sensor, enable);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = st_lsm6dsx_set_fifo_odr(sensor, enable);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = st_lsm6dsx_update_decimators(hw);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = st_lsm6dsx_update_watermark(sensor, sensor->watermark);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (fifo_mask) {\n\t\terr = st_lsm6dsx_resume_fifo(hw);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\thw->fifo_mask = fifo_mask;\n\nout:\n\tmutex_unlock(&hw->conf_lock);\n\n\treturn err;\n}\n\nstatic int st_lsm6dsx_buffer_preenable(struct iio_dev *iio_dev)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\n\tif (!hw->settings->fifo_ops.update_fifo)\n\t\treturn -ENOTSUPP;\n\n\treturn hw->settings->fifo_ops.update_fifo(sensor, true);\n}\n\nstatic int st_lsm6dsx_buffer_postdisable(struct iio_dev *iio_dev)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\n\tif (!hw->settings->fifo_ops.update_fifo)\n\t\treturn -ENOTSUPP;\n\n\treturn hw->settings->fifo_ops.update_fifo(sensor, false);\n}\n\nstatic const struct iio_buffer_setup_ops st_lsm6dsx_buffer_ops = {\n\t.preenable = st_lsm6dsx_buffer_preenable,\n\t.postdisable = st_lsm6dsx_buffer_postdisable,\n};\n\nint st_lsm6dsx_fifo_setup(struct st_lsm6dsx_hw *hw)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ST_LSM6DSX_ID_MAX; i++) {\n\t\tif (!hw->iio_devs[i])\n\t\t\tcontinue;\n\n\t\tret = devm_iio_kfifo_buffer_setup(hw->dev, hw->iio_devs[i],\n\t\t\t\t\t\t  &st_lsm6dsx_buffer_ops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}