{
  "module_name": "st_lsm6dsx_core.c",
  "hash_id": "756e3ef1caa1ed1cf96257420b40d00a9d27a528209c98ce3a11ea420c7fe6bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/st_lsm6dsx/st_lsm6dsx_core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/minmax.h>\n#include <linux/pm.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/bitfield.h>\n\n#include <linux/platform_data/st_sensors_pdata.h>\n\n#include \"st_lsm6dsx.h\"\n\n#define ST_LSM6DSX_REG_WHOAMI_ADDR\t\t0x0f\n\n#define ST_LSM6DSX_TS_SENSITIVITY\t\t25000UL  \n\nstatic const struct iio_chan_spec st_lsm6dsx_acc_channels[] = {\n\tST_LSM6DSX_CHANNEL_ACC(IIO_ACCEL, 0x28, IIO_MOD_X, 0),\n\tST_LSM6DSX_CHANNEL_ACC(IIO_ACCEL, 0x2a, IIO_MOD_Y, 1),\n\tST_LSM6DSX_CHANNEL_ACC(IIO_ACCEL, 0x2c, IIO_MOD_Z, 2),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic const struct iio_chan_spec st_lsm6dsx_gyro_channels[] = {\n\tST_LSM6DSX_CHANNEL(IIO_ANGL_VEL, 0x22, IIO_MOD_X, 0),\n\tST_LSM6DSX_CHANNEL(IIO_ANGL_VEL, 0x24, IIO_MOD_Y, 1),\n\tST_LSM6DSX_CHANNEL(IIO_ANGL_VEL, 0x26, IIO_MOD_Z, 2),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic const struct iio_chan_spec st_lsm6ds0_gyro_channels[] = {\n\tST_LSM6DSX_CHANNEL(IIO_ANGL_VEL, 0x18, IIO_MOD_X, 0),\n\tST_LSM6DSX_CHANNEL(IIO_ANGL_VEL, 0x1a, IIO_MOD_Y, 1),\n\tST_LSM6DSX_CHANNEL(IIO_ANGL_VEL, 0x1c, IIO_MOD_Z, 2),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic const struct st_lsm6dsx_settings st_lsm6dsx_sensor_settings[] = {\n\t{\n\t\t.reset = {\n\t\t\t.addr = 0x22,\n\t\t\t.mask = BIT(0),\n\t\t},\n\t\t.boot = {\n\t\t\t.addr = 0x22,\n\t\t\t.mask = BIT(7),\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x22,\n\t\t\t.mask = BIT(6),\n\t\t},\n\t\t.id = {\n\t\t\t{\n\t\t\t\t.hw_id = ST_LSM9DS1_ID,\n\t\t\t\t.name = ST_LSM9DS1_DEV_NAME,\n\t\t\t\t.wai = 0x68,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_LSM6DS0_ID,\n\t\t\t\t.name = ST_LSM6DS0_DEV_NAME,\n\t\t\t\t.wai = 0x68,\n\t\t\t},\n\t\t},\n\t\t.channels = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.chan = st_lsm6dsx_acc_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_acc_channels),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.chan = st_lsm6ds0_gyro_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6ds0_gyro_channels),\n\t\t\t},\n\t\t},\n\t\t.odr_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x20,\n\t\t\t\t\t.mask = GENMASK(7, 5),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {  10000, 0x01 },\n\t\t\t\t.odr_avl[1] = {  50000, 0x02 },\n\t\t\t\t.odr_avl[2] = { 119000, 0x03 },\n\t\t\t\t.odr_avl[3] = { 238000, 0x04 },\n\t\t\t\t.odr_avl[4] = { 476000, 0x05 },\n\t\t\t\t.odr_avl[5] = { 952000, 0x06 },\n\t\t\t\t.odr_len = 6,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(7, 5),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {  14900, 0x01 },\n\t\t\t\t.odr_avl[1] = {  59500, 0x02 },\n\t\t\t\t.odr_avl[2] = { 119000, 0x03 },\n\t\t\t\t.odr_avl[3] = { 238000, 0x04 },\n\t\t\t\t.odr_avl[4] = { 476000, 0x05 },\n\t\t\t\t.odr_avl[5] = { 952000, 0x06 },\n\t\t\t\t.odr_len = 6,\n\t\t\t},\n\t\t},\n\t\t.fs_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x20,\n\t\t\t\t\t.mask = GENMASK(4, 3),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_G_TO_M_S_2(61000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_G_TO_M_S_2(122000), 0x2 },\n\t\t\t\t.fs_avl[2] = { IIO_G_TO_M_S_2(244000), 0x3 },\n\t\t\t\t.fs_avl[3] = { IIO_G_TO_M_S_2(732000), 0x1 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(4, 3),\n\t\t\t\t},\n\n\t\t\t\t.fs_avl[0] = {  IIO_DEGREE_TO_RAD(8750000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_DEGREE_TO_RAD(17500000), 0x1 },\n\t\t\t\t.fs_avl[2] = { IIO_DEGREE_TO_RAD(70000000), 0x3 },\n\t\t\t\t.fs_len = 3,\n\t\t\t},\n\t\t},\n\t\t.irq_config = {\n\t\t\t.irq1 = {\n\t\t\t\t.addr = 0x0c,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.irq2 = {\n\t\t\t\t.addr = 0x0d,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.hla = {\n\t\t\t\t.addr = 0x22,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.od = {\n\t\t\t\t.addr = 0x22,\n\t\t\t\t.mask = BIT(4),\n\t\t\t},\n\t\t},\n\t\t.fifo_ops = {\n\t\t\t.max_size = 32,\n\t\t},\n\t},\n\t{\n\t\t.reset = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(0),\n\t\t},\n\t\t.boot = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(7),\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(6),\n\t\t},\n\t\t.id = {\n\t\t\t{\n\t\t\t\t.hw_id = ST_LSM6DS3_ID,\n\t\t\t\t.name = ST_LSM6DS3_DEV_NAME,\n\t\t\t\t.wai = 0x69,\n\t\t\t},\n\t\t},\n\t\t.channels = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.chan = st_lsm6dsx_acc_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_acc_channels),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.chan = st_lsm6dsx_gyro_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_gyro_channels),\n\t\t\t},\n\t\t},\n\t\t.odr_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {  12500, 0x01 },\n\t\t\t\t.odr_avl[1] = {  26000, 0x02 },\n\t\t\t\t.odr_avl[2] = {  52000, 0x03 },\n\t\t\t\t.odr_avl[3] = { 104000, 0x04 },\n\t\t\t\t.odr_avl[4] = { 208000, 0x05 },\n\t\t\t\t.odr_avl[5] = { 416000, 0x06 },\n\t\t\t\t.odr_len = 6,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x11,\n\t\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {  12500, 0x01 },\n\t\t\t\t.odr_avl[1] = {  26000, 0x02 },\n\t\t\t\t.odr_avl[2] = {  52000, 0x03 },\n\t\t\t\t.odr_avl[3] = { 104000, 0x04 },\n\t\t\t\t.odr_avl[4] = { 208000, 0x05 },\n\t\t\t\t.odr_avl[5] = { 416000, 0x06 },\n\t\t\t\t.odr_len = 6,\n\t\t\t},\n\t\t},\n\t\t.fs_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(3, 2),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_G_TO_M_S_2(61000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_G_TO_M_S_2(122000), 0x2 },\n\t\t\t\t.fs_avl[2] = { IIO_G_TO_M_S_2(244000), 0x3 },\n\t\t\t\t.fs_avl[3] = { IIO_G_TO_M_S_2(488000), 0x1 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x11,\n\t\t\t\t\t.mask = GENMASK(3, 2),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_DEGREE_TO_RAD(8750000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_DEGREE_TO_RAD(17500000), 0x1 },\n\t\t\t\t.fs_avl[2] = { IIO_DEGREE_TO_RAD(35000000), 0x2 },\n\t\t\t\t.fs_avl[3] = { IIO_DEGREE_TO_RAD(70000000), 0x3 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t},\n\t\t.irq_config = {\n\t\t\t.irq1 = {\n\t\t\t\t.addr = 0x0d,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.irq2 = {\n\t\t\t\t.addr = 0x0e,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.lir = {\n\t\t\t\t.addr = 0x58,\n\t\t\t\t.mask = BIT(0),\n\t\t\t},\n\t\t\t.irq1_func = {\n\t\t\t\t.addr = 0x5e,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.irq2_func = {\n\t\t\t\t.addr = 0x5f,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.hla = {\n\t\t\t\t.addr = 0x12,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.od = {\n\t\t\t\t.addr = 0x12,\n\t\t\t\t.mask = BIT(4),\n\t\t\t},\n\t\t},\n\t\t.decimator = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.addr = 0x08,\n\t\t\t\t.mask = GENMASK(2, 0),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.addr = 0x08,\n\t\t\t\t.mask = GENMASK(5, 3),\n\t\t\t},\n\t\t},\n\t\t.fifo_ops = {\n\t\t\t.update_fifo = st_lsm6dsx_update_fifo,\n\t\t\t.read_fifo = st_lsm6dsx_read_fifo,\n\t\t\t.fifo_th = {\n\t\t\t\t.addr = 0x06,\n\t\t\t\t.mask = GENMASK(11, 0),\n\t\t\t},\n\t\t\t.fifo_diff = {\n\t\t\t\t.addr = 0x3a,\n\t\t\t\t.mask = GENMASK(11, 0),\n\t\t\t},\n\t\t\t.max_size = 1365,\n\t\t\t.th_wl = 3,  \n\t\t},\n\t\t.ts_settings = {\n\t\t\t.timer_en = {\n\t\t\t\t.addr = 0x58,\n\t\t\t\t.mask = BIT(7),\n\t\t\t},\n\t\t\t.hr_timer = {\n\t\t\t\t.addr = 0x5c,\n\t\t\t\t.mask = BIT(4),\n\t\t\t},\n\t\t\t.fifo_en = {\n\t\t\t\t.addr = 0x07,\n\t\t\t\t.mask = BIT(7),\n\t\t\t},\n\t\t\t.decimator = {\n\t\t\t\t.addr = 0x09,\n\t\t\t\t.mask = GENMASK(5, 3),\n\t\t\t},\n\t\t},\n\t\t.event_settings = {\n\t\t\t.wakeup_reg = {\n\t\t\t\t.addr = 0x5B,\n\t\t\t\t.mask = GENMASK(5, 0),\n\t\t\t},\n\t\t\t.wakeup_src_reg = 0x1b,\n\t\t\t.wakeup_src_status_mask = BIT(3),\n\t\t\t.wakeup_src_z_mask = BIT(0),\n\t\t\t.wakeup_src_y_mask = BIT(1),\n\t\t\t.wakeup_src_x_mask = BIT(2),\n\t\t},\n\t},\n\t{\n\t\t.reset = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(0),\n\t\t},\n\t\t.boot = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(7),\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(6),\n\t\t},\n\t\t.id = {\n\t\t\t{\n\t\t\t\t.hw_id = ST_LSM6DS3H_ID,\n\t\t\t\t.name = ST_LSM6DS3H_DEV_NAME,\n\t\t\t\t.wai = 0x69,\n\t\t\t},\n\t\t},\n\t\t.channels = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.chan = st_lsm6dsx_acc_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_acc_channels),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.chan = st_lsm6dsx_gyro_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_gyro_channels),\n\t\t\t},\n\t\t},\n\t\t.odr_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {  12500, 0x01 },\n\t\t\t\t.odr_avl[1] = {  26000, 0x02 },\n\t\t\t\t.odr_avl[2] = {  52000, 0x03 },\n\t\t\t\t.odr_avl[3] = { 104000, 0x04 },\n\t\t\t\t.odr_avl[4] = { 208000, 0x05 },\n\t\t\t\t.odr_avl[5] = { 416000, 0x06 },\n\t\t\t\t.odr_len = 6,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x11,\n\t\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {  12500, 0x01 },\n\t\t\t\t.odr_avl[1] = {  26000, 0x02 },\n\t\t\t\t.odr_avl[2] = {  52000, 0x03 },\n\t\t\t\t.odr_avl[3] = { 104000, 0x04 },\n\t\t\t\t.odr_avl[4] = { 208000, 0x05 },\n\t\t\t\t.odr_avl[5] = { 416000, 0x06 },\n\t\t\t\t.odr_len = 6,\n\t\t\t},\n\t\t},\n\t\t.fs_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(3, 2),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_G_TO_M_S_2(61000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_G_TO_M_S_2(122000), 0x2 },\n\t\t\t\t.fs_avl[2] = { IIO_G_TO_M_S_2(244000), 0x3 },\n\t\t\t\t.fs_avl[3] = { IIO_G_TO_M_S_2(488000), 0x1 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x11,\n\t\t\t\t\t.mask = GENMASK(3, 2),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_DEGREE_TO_RAD(8750000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_DEGREE_TO_RAD(17500000), 0x1 },\n\t\t\t\t.fs_avl[2] = { IIO_DEGREE_TO_RAD(35000000), 0x2 },\n\t\t\t\t.fs_avl[3] = { IIO_DEGREE_TO_RAD(70000000), 0x3 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t},\n\t\t.irq_config = {\n\t\t\t.irq1 = {\n\t\t\t\t.addr = 0x0d,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.irq2 = {\n\t\t\t\t.addr = 0x0e,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.lir = {\n\t\t\t\t.addr = 0x58,\n\t\t\t\t.mask = BIT(0),\n\t\t\t},\n\t\t\t.irq1_func = {\n\t\t\t\t.addr = 0x5e,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.irq2_func = {\n\t\t\t\t.addr = 0x5f,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.hla = {\n\t\t\t\t.addr = 0x12,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.od = {\n\t\t\t\t.addr = 0x12,\n\t\t\t\t.mask = BIT(4),\n\t\t\t},\n\t\t},\n\t\t.decimator = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.addr = 0x08,\n\t\t\t\t.mask = GENMASK(2, 0),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.addr = 0x08,\n\t\t\t\t.mask = GENMASK(5, 3),\n\t\t\t},\n\t\t},\n\t\t.fifo_ops = {\n\t\t\t.update_fifo = st_lsm6dsx_update_fifo,\n\t\t\t.read_fifo = st_lsm6dsx_read_fifo,\n\t\t\t.fifo_th = {\n\t\t\t\t.addr = 0x06,\n\t\t\t\t.mask = GENMASK(11, 0),\n\t\t\t},\n\t\t\t.fifo_diff = {\n\t\t\t\t.addr = 0x3a,\n\t\t\t\t.mask = GENMASK(11, 0),\n\t\t\t},\n\t\t\t.max_size = 682,\n\t\t\t.th_wl = 3,  \n\t\t},\n\t\t.ts_settings = {\n\t\t\t.timer_en = {\n\t\t\t\t.addr = 0x58,\n\t\t\t\t.mask = BIT(7),\n\t\t\t},\n\t\t\t.hr_timer = {\n\t\t\t\t.addr = 0x5c,\n\t\t\t\t.mask = BIT(4),\n\t\t\t},\n\t\t\t.fifo_en = {\n\t\t\t\t.addr = 0x07,\n\t\t\t\t.mask = BIT(7),\n\t\t\t},\n\t\t\t.decimator = {\n\t\t\t\t.addr = 0x09,\n\t\t\t\t.mask = GENMASK(5, 3),\n\t\t\t},\n\t\t},\n\t\t.event_settings = {\n\t\t\t.wakeup_reg = {\n\t\t\t\t.addr = 0x5B,\n\t\t\t\t.mask = GENMASK(5, 0),\n\t\t\t},\n\t\t\t.wakeup_src_reg = 0x1b,\n\t\t\t.wakeup_src_status_mask = BIT(3),\n\t\t\t.wakeup_src_z_mask = BIT(0),\n\t\t\t.wakeup_src_y_mask = BIT(1),\n\t\t\t.wakeup_src_x_mask = BIT(2),\n\t\t},\n\t},\n\t{\n\t\t.reset = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(0),\n\t\t},\n\t\t.boot = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(7),\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(6),\n\t\t},\n\t\t.id = {\n\t\t\t{\n\t\t\t\t.hw_id = ST_LSM6DSL_ID,\n\t\t\t\t.name = ST_LSM6DSL_DEV_NAME,\n\t\t\t\t.wai = 0x6a,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_LSM6DSM_ID,\n\t\t\t\t.name = ST_LSM6DSM_DEV_NAME,\n\t\t\t\t.wai = 0x6a,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_ISM330DLC_ID,\n\t\t\t\t.name = ST_ISM330DLC_DEV_NAME,\n\t\t\t\t.wai = 0x6a,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_LSM6DS3TRC_ID,\n\t\t\t\t.name = ST_LSM6DS3TRC_DEV_NAME,\n\t\t\t\t.wai = 0x6a,\n\t\t\t},\n\t\t},\n\t\t.channels = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.chan = st_lsm6dsx_acc_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_acc_channels),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.chan = st_lsm6dsx_gyro_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_gyro_channels),\n\t\t\t},\n\t\t},\n\t\t.odr_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {  12500, 0x01 },\n\t\t\t\t.odr_avl[1] = {  26000, 0x02 },\n\t\t\t\t.odr_avl[2] = {  52000, 0x03 },\n\t\t\t\t.odr_avl[3] = { 104000, 0x04 },\n\t\t\t\t.odr_avl[4] = { 208000, 0x05 },\n\t\t\t\t.odr_avl[5] = { 416000, 0x06 },\n\t\t\t\t.odr_len = 6,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x11,\n\t\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {  12500, 0x01 },\n\t\t\t\t.odr_avl[1] = {  26000, 0x02 },\n\t\t\t\t.odr_avl[2] = {  52000, 0x03 },\n\t\t\t\t.odr_avl[3] = { 104000, 0x04 },\n\t\t\t\t.odr_avl[4] = { 208000, 0x05 },\n\t\t\t\t.odr_avl[5] = { 416000, 0x06 },\n\t\t\t\t.odr_len = 6,\n\t\t\t},\n\t\t},\n\t\t.fs_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(3, 2),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_G_TO_M_S_2(61000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_G_TO_M_S_2(122000), 0x2 },\n\t\t\t\t.fs_avl[2] = { IIO_G_TO_M_S_2(244000), 0x3 },\n\t\t\t\t.fs_avl[3] = { IIO_G_TO_M_S_2(488000), 0x1 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x11,\n\t\t\t\t\t.mask = GENMASK(3, 2),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_DEGREE_TO_RAD(8750000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_DEGREE_TO_RAD(17500000), 0x1 },\n\t\t\t\t.fs_avl[2] = { IIO_DEGREE_TO_RAD(35000000), 0x2 },\n\t\t\t\t.fs_avl[3] = { IIO_DEGREE_TO_RAD(70000000), 0x3 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t},\n\t\t.samples_to_discard = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.val[0] = {  12500, 1 },\n\t\t\t\t.val[1] = {  26000, 1 },\n\t\t\t\t.val[2] = {  52000, 1 },\n\t\t\t\t.val[3] = { 104000, 2 },\n\t\t\t\t.val[4] = { 208000, 2 },\n\t\t\t\t.val[5] = { 416000, 2 },\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.val[0] = {  12500,  2 },\n\t\t\t\t.val[1] = {  26000,  5 },\n\t\t\t\t.val[2] = {  52000,  7 },\n\t\t\t\t.val[3] = { 104000, 12 },\n\t\t\t\t.val[4] = { 208000, 20 },\n\t\t\t\t.val[5] = { 416000, 36 },\n\t\t\t},\n\t\t},\n\t\t.irq_config = {\n\t\t\t.irq1 = {\n\t\t\t\t.addr = 0x0d,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.irq2 = {\n\t\t\t\t.addr = 0x0e,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.lir = {\n\t\t\t\t.addr = 0x58,\n\t\t\t\t.mask = BIT(0),\n\t\t\t},\n\t\t\t.irq1_func = {\n\t\t\t\t.addr = 0x5e,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.irq2_func = {\n\t\t\t\t.addr = 0x5f,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.hla = {\n\t\t\t\t.addr = 0x12,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.od = {\n\t\t\t\t.addr = 0x12,\n\t\t\t\t.mask = BIT(4),\n\t\t\t},\n\t\t},\n\t\t.decimator = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.addr = 0x08,\n\t\t\t\t.mask = GENMASK(2, 0),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.addr = 0x08,\n\t\t\t\t.mask = GENMASK(5, 3),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_EXT0] = {\n\t\t\t\t.addr = 0x09,\n\t\t\t\t.mask = GENMASK(2, 0),\n\t\t\t},\n\t\t},\n\t\t.fifo_ops = {\n\t\t\t.update_fifo = st_lsm6dsx_update_fifo,\n\t\t\t.read_fifo = st_lsm6dsx_read_fifo,\n\t\t\t.fifo_th = {\n\t\t\t\t.addr = 0x06,\n\t\t\t\t.mask = GENMASK(10, 0),\n\t\t\t},\n\t\t\t.fifo_diff = {\n\t\t\t\t.addr = 0x3a,\n\t\t\t\t.mask = GENMASK(10, 0),\n\t\t\t},\n\t\t\t.max_size = 682,\n\t\t\t.th_wl = 3,  \n\t\t},\n\t\t.ts_settings = {\n\t\t\t.timer_en = {\n\t\t\t\t.addr = 0x19,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.hr_timer = {\n\t\t\t\t.addr = 0x5c,\n\t\t\t\t.mask = BIT(4),\n\t\t\t},\n\t\t\t.fifo_en = {\n\t\t\t\t.addr = 0x07,\n\t\t\t\t.mask = BIT(7),\n\t\t\t},\n\t\t\t.decimator = {\n\t\t\t\t.addr = 0x09,\n\t\t\t\t.mask = GENMASK(5, 3),\n\t\t\t},\n\t\t},\n\t\t.shub_settings = {\n\t\t\t.page_mux = {\n\t\t\t\t.addr = 0x01,\n\t\t\t\t.mask = BIT(7),\n\t\t\t},\n\t\t\t.master_en = {\n\t\t\t\t.addr = 0x1a,\n\t\t\t\t.mask = BIT(0),\n\t\t\t},\n\t\t\t.pullup_en = {\n\t\t\t\t.addr = 0x1a,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.aux_sens = {\n\t\t\t\t.addr = 0x04,\n\t\t\t\t.mask = GENMASK(5, 4),\n\t\t\t},\n\t\t\t.wr_once = {\n\t\t\t\t.addr = 0x07,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.emb_func = {\n\t\t\t\t.addr = 0x19,\n\t\t\t\t.mask = BIT(2),\n\t\t\t},\n\t\t\t.num_ext_dev = 1,\n\t\t\t.shub_out = {\n\t\t\t\t.addr = 0x2e,\n\t\t\t},\n\t\t\t.slv0_addr = 0x02,\n\t\t\t.dw_slv0_addr = 0x0e,\n\t\t\t.pause = 0x7,\n\t\t},\n\t\t.event_settings = {\n\t\t\t.enable_reg = {\n\t\t\t\t.addr = 0x58,\n\t\t\t\t.mask = BIT(7),\n\t\t\t},\n\t\t\t.wakeup_reg = {\n\t\t\t\t.addr = 0x5B,\n\t\t\t\t.mask = GENMASK(5, 0),\n\t\t\t},\n\t\t\t.wakeup_src_reg = 0x1b,\n\t\t\t.wakeup_src_status_mask = BIT(3),\n\t\t\t.wakeup_src_z_mask = BIT(0),\n\t\t\t.wakeup_src_y_mask = BIT(1),\n\t\t\t.wakeup_src_x_mask = BIT(2),\n\t\t},\n\t},\n\t{\n\t\t.reset = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(0),\n\t\t},\n\t\t.boot = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(7),\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(6),\n\t\t},\n\t\t.id = {\n\t\t\t{\n\t\t\t\t.hw_id = ST_LSM6DSR_ID,\n\t\t\t\t.name = ST_LSM6DSR_DEV_NAME,\n\t\t\t\t.wai = 0x6b,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_ISM330DHCX_ID,\n\t\t\t\t.name = ST_ISM330DHCX_DEV_NAME,\n\t\t\t\t.wai = 0x6b,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_LSM6DSRX_ID,\n\t\t\t\t.name = ST_LSM6DSRX_DEV_NAME,\n\t\t\t\t.wai = 0x6b,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_LSM6DSO_ID,\n\t\t\t\t.name = ST_LSM6DSO_DEV_NAME,\n\t\t\t\t.wai = 0x6c,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_LSM6DSOX_ID,\n\t\t\t\t.name = ST_LSM6DSOX_DEV_NAME,\n\t\t\t\t.wai = 0x6c,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_LSM6DST_ID,\n\t\t\t\t.name = ST_LSM6DST_DEV_NAME,\n\t\t\t\t.wai = 0x6d,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_ASM330LHHX_ID,\n\t\t\t\t.name = ST_ASM330LHHX_DEV_NAME,\n\t\t\t\t.wai = 0x6b,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_LSM6DSTX_ID,\n\t\t\t\t.name = ST_LSM6DSTX_DEV_NAME,\n\t\t\t\t.wai = 0x6d,\n\t\t\t},\n\t\t},\n\t\t.channels = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.chan = st_lsm6dsx_acc_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_acc_channels),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.chan = st_lsm6dsx_gyro_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_gyro_channels),\n\t\t\t},\n\t\t},\n\t\t.drdy_mask = {\n\t\t\t.addr = 0x13,\n\t\t\t.mask = BIT(3),\n\t\t},\n\t\t.odr_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {  12500, 0x01 },\n\t\t\t\t.odr_avl[1] = {  26000, 0x02 },\n\t\t\t\t.odr_avl[2] = {  52000, 0x03 },\n\t\t\t\t.odr_avl[3] = { 104000, 0x04 },\n\t\t\t\t.odr_avl[4] = { 208000, 0x05 },\n\t\t\t\t.odr_avl[5] = { 416000, 0x06 },\n\t\t\t\t.odr_avl[6] = { 833000, 0x07 },\n\t\t\t\t.odr_len = 7,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x11,\n\t\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {  12500, 0x01 },\n\t\t\t\t.odr_avl[1] = {  26000, 0x02 },\n\t\t\t\t.odr_avl[2] = {  52000, 0x03 },\n\t\t\t\t.odr_avl[3] = { 104000, 0x04 },\n\t\t\t\t.odr_avl[4] = { 208000, 0x05 },\n\t\t\t\t.odr_avl[5] = { 416000, 0x06 },\n\t\t\t\t.odr_avl[6] = { 833000, 0x07 },\n\t\t\t\t.odr_len = 7,\n\t\t\t},\n\t\t},\n\t\t.fs_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(3, 2),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_G_TO_M_S_2(61000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_G_TO_M_S_2(122000), 0x2 },\n\t\t\t\t.fs_avl[2] = { IIO_G_TO_M_S_2(244000), 0x3 },\n\t\t\t\t.fs_avl[3] = { IIO_G_TO_M_S_2(488000), 0x1 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x11,\n\t\t\t\t\t.mask = GENMASK(3, 2),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_DEGREE_TO_RAD(8750000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_DEGREE_TO_RAD(17500000), 0x1 },\n\t\t\t\t.fs_avl[2] = { IIO_DEGREE_TO_RAD(35000000), 0x2 },\n\t\t\t\t.fs_avl[3] = { IIO_DEGREE_TO_RAD(70000000), 0x3 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t},\n\t\t.irq_config = {\n\t\t\t.irq1 = {\n\t\t\t\t.addr = 0x0d,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.irq2 = {\n\t\t\t\t.addr = 0x0e,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.lir = {\n\t\t\t\t.addr = 0x56,\n\t\t\t\t.mask = BIT(0),\n\t\t\t},\n\t\t\t.clear_on_read = {\n\t\t\t\t.addr = 0x56,\n\t\t\t\t.mask = BIT(6),\n\t\t\t},\n\t\t\t.irq1_func = {\n\t\t\t\t.addr = 0x5e,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.irq2_func = {\n\t\t\t\t.addr = 0x5f,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.hla = {\n\t\t\t\t.addr = 0x12,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.od = {\n\t\t\t\t.addr = 0x12,\n\t\t\t\t.mask = BIT(4),\n\t\t\t},\n\t\t},\n\t\t.batch = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.addr = 0x09,\n\t\t\t\t.mask = GENMASK(3, 0),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.addr = 0x09,\n\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t},\n\t\t},\n\t\t.fifo_ops = {\n\t\t\t.update_fifo = st_lsm6dsx_update_fifo,\n\t\t\t.read_fifo = st_lsm6dsx_read_tagged_fifo,\n\t\t\t.fifo_th = {\n\t\t\t\t.addr = 0x07,\n\t\t\t\t.mask = GENMASK(8, 0),\n\t\t\t},\n\t\t\t.fifo_diff = {\n\t\t\t\t.addr = 0x3a,\n\t\t\t\t.mask = GENMASK(9, 0),\n\t\t\t},\n\t\t\t.max_size = 512,\n\t\t\t.th_wl = 1,\n\t\t},\n\t\t.ts_settings = {\n\t\t\t.timer_en = {\n\t\t\t\t.addr = 0x19,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.decimator = {\n\t\t\t\t.addr = 0x0a,\n\t\t\t\t.mask = GENMASK(7, 6),\n\t\t\t},\n\t\t\t.freq_fine = 0x63,\n\t\t},\n\t\t.shub_settings = {\n\t\t\t.page_mux = {\n\t\t\t\t.addr = 0x01,\n\t\t\t\t.mask = BIT(6),\n\t\t\t},\n\t\t\t.master_en = {\n\t\t\t\t.sec_page = true,\n\t\t\t\t.addr = 0x14,\n\t\t\t\t.mask = BIT(2),\n\t\t\t},\n\t\t\t.pullup_en = {\n\t\t\t\t.sec_page = true,\n\t\t\t\t.addr = 0x14,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.aux_sens = {\n\t\t\t\t.addr = 0x14,\n\t\t\t\t.mask = GENMASK(1, 0),\n\t\t\t},\n\t\t\t.wr_once = {\n\t\t\t\t.addr = 0x14,\n\t\t\t\t.mask = BIT(6),\n\t\t\t},\n\t\t\t.num_ext_dev = 3,\n\t\t\t.shub_out = {\n\t\t\t\t.sec_page = true,\n\t\t\t\t.addr = 0x02,\n\t\t\t},\n\t\t\t.slv0_addr = 0x15,\n\t\t\t.dw_slv0_addr = 0x21,\n\t\t\t.batch_en = BIT(3),\n\t\t},\n\t\t.event_settings = {\n\t\t\t.enable_reg = {\n\t\t\t\t.addr = 0x58,\n\t\t\t\t.mask = BIT(7),\n\t\t\t},\n\t\t\t.wakeup_reg = {\n\t\t\t\t.addr = 0x5b,\n\t\t\t\t.mask = GENMASK(5, 0),\n\t\t\t},\n\t\t\t.wakeup_src_reg = 0x1b,\n\t\t\t.wakeup_src_status_mask = BIT(3),\n\t\t\t.wakeup_src_z_mask = BIT(0),\n\t\t\t.wakeup_src_y_mask = BIT(1),\n\t\t\t.wakeup_src_x_mask = BIT(2),\n\t\t},\n\t},\n\t{\n\t\t.reset = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(0),\n\t\t},\n\t\t.boot = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(7),\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(6),\n\t\t},\n\t\t.id = {\n\t\t\t{\n\t\t\t\t.hw_id = ST_ASM330LHH_ID,\n\t\t\t\t.name = ST_ASM330LHH_DEV_NAME,\n\t\t\t\t.wai = 0x6b,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_LSM6DSOP_ID,\n\t\t\t\t.name = ST_LSM6DSOP_DEV_NAME,\n\t\t\t\t.wai = 0x6c,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_ASM330LHB_ID,\n\t\t\t\t.name = ST_ASM330LHB_DEV_NAME,\n\t\t\t\t.wai = 0x6b,\n\t\t\t},\n\t\t},\n\t\t.channels = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.chan = st_lsm6dsx_acc_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_acc_channels),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.chan = st_lsm6dsx_gyro_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_gyro_channels),\n\t\t\t},\n\t\t},\n\t\t.drdy_mask = {\n\t\t\t.addr = 0x13,\n\t\t\t.mask = BIT(3),\n\t\t},\n\t\t.odr_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {  12500, 0x01 },\n\t\t\t\t.odr_avl[1] = {  26000, 0x02 },\n\t\t\t\t.odr_avl[2] = {  52000, 0x03 },\n\t\t\t\t.odr_avl[3] = { 104000, 0x04 },\n\t\t\t\t.odr_avl[4] = { 208000, 0x05 },\n\t\t\t\t.odr_avl[5] = { 416000, 0x06 },\n\t\t\t\t.odr_avl[6] = { 833000, 0x07 },\n\t\t\t\t.odr_len = 7,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x11,\n\t\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {  12500, 0x01 },\n\t\t\t\t.odr_avl[1] = {  26000, 0x02 },\n\t\t\t\t.odr_avl[2] = {  52000, 0x03 },\n\t\t\t\t.odr_avl[3] = { 104000, 0x04 },\n\t\t\t\t.odr_avl[4] = { 208000, 0x05 },\n\t\t\t\t.odr_avl[5] = { 416000, 0x06 },\n\t\t\t\t.odr_avl[6] = { 833000, 0x07 },\n\t\t\t\t.odr_len = 7,\n\t\t\t},\n\t\t},\n\t\t.fs_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(3, 2),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_G_TO_M_S_2(61000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_G_TO_M_S_2(122000), 0x2 },\n\t\t\t\t.fs_avl[2] = { IIO_G_TO_M_S_2(244000), 0x3 },\n\t\t\t\t.fs_avl[3] = { IIO_G_TO_M_S_2(488000), 0x1 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x11,\n\t\t\t\t\t.mask = GENMASK(3, 2),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_DEGREE_TO_RAD(8750000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_DEGREE_TO_RAD(17500000), 0x1 },\n\t\t\t\t.fs_avl[2] = { IIO_DEGREE_TO_RAD(35000000), 0x2 },\n\t\t\t\t.fs_avl[3] = { IIO_DEGREE_TO_RAD(70000000), 0x3 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t},\n\t\t.irq_config = {\n\t\t\t.irq1 = {\n\t\t\t\t.addr = 0x0d,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.irq2 = {\n\t\t\t\t.addr = 0x0e,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.lir = {\n\t\t\t\t.addr = 0x56,\n\t\t\t\t.mask = BIT(0),\n\t\t\t},\n\t\t\t.clear_on_read = {\n\t\t\t\t.addr = 0x56,\n\t\t\t\t.mask = BIT(6),\n\t\t\t},\n\t\t\t.irq1_func = {\n\t\t\t\t.addr = 0x5e,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.irq2_func = {\n\t\t\t\t.addr = 0x5f,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.hla = {\n\t\t\t\t.addr = 0x12,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.od = {\n\t\t\t\t.addr = 0x12,\n\t\t\t\t.mask = BIT(4),\n\t\t\t},\n\t\t},\n\t\t.batch = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.addr = 0x09,\n\t\t\t\t.mask = GENMASK(3, 0),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.addr = 0x09,\n\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t},\n\t\t},\n\t\t.fifo_ops = {\n\t\t\t.update_fifo = st_lsm6dsx_update_fifo,\n\t\t\t.read_fifo = st_lsm6dsx_read_tagged_fifo,\n\t\t\t.fifo_th = {\n\t\t\t\t.addr = 0x07,\n\t\t\t\t.mask = GENMASK(8, 0),\n\t\t\t},\n\t\t\t.fifo_diff = {\n\t\t\t\t.addr = 0x3a,\n\t\t\t\t.mask = GENMASK(9, 0),\n\t\t\t},\n\t\t\t.max_size = 512,\n\t\t\t.th_wl = 1,\n\t\t},\n\t\t.ts_settings = {\n\t\t\t.timer_en = {\n\t\t\t\t.addr = 0x19,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.decimator = {\n\t\t\t\t.addr = 0x0a,\n\t\t\t\t.mask = GENMASK(7, 6),\n\t\t\t},\n\t\t\t.freq_fine = 0x63,\n\t\t},\n\t\t.event_settings = {\n\t\t\t.enable_reg = {\n\t\t\t\t.addr = 0x58,\n\t\t\t\t.mask = BIT(7),\n\t\t\t},\n\t\t\t.wakeup_reg = {\n\t\t\t\t.addr = 0x5B,\n\t\t\t\t.mask = GENMASK(5, 0),\n\t\t\t},\n\t\t\t.wakeup_src_reg = 0x1b,\n\t\t\t.wakeup_src_status_mask = BIT(3),\n\t\t\t.wakeup_src_z_mask = BIT(0),\n\t\t\t.wakeup_src_y_mask = BIT(1),\n\t\t\t.wakeup_src_x_mask = BIT(2),\n\t\t},\n\t},\n\t{\n\t\t.reset = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(0),\n\t\t},\n\t\t.boot = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(7),\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(6),\n\t\t},\n\t\t.id = {\n\t\t\t{\n\t\t\t\t.hw_id = ST_LSM6DSV_ID,\n\t\t\t\t.name = ST_LSM6DSV_DEV_NAME,\n\t\t\t\t.wai = 0x70,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_LSM6DSV16X_ID,\n\t\t\t\t.name = ST_LSM6DSV16X_DEV_NAME,\n\t\t\t\t.wai = 0x70,\n\t\t\t},\n\t\t},\n\t\t.channels = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.chan = st_lsm6dsx_acc_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_acc_channels),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.chan = st_lsm6dsx_gyro_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_gyro_channels),\n\t\t\t},\n\t\t},\n\t\t.drdy_mask = {\n\t\t\t.addr = 0x13,\n\t\t\t.mask = BIT(3),\n\t\t},\n\t\t.odr_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(3, 0),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {   7500, 0x02 },\n\t\t\t\t.odr_avl[1] = {  15000, 0x03 },\n\t\t\t\t.odr_avl[2] = {  30000, 0x04 },\n\t\t\t\t.odr_avl[3] = {  60000, 0x05 },\n\t\t\t\t.odr_avl[4] = { 120000, 0x06 },\n\t\t\t\t.odr_avl[5] = { 240000, 0x07 },\n\t\t\t\t.odr_avl[6] = { 480000, 0x08 },\n\t\t\t\t.odr_avl[7] = { 960000, 0x09 },\n\t\t\t\t.odr_len = 8,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x11,\n\t\t\t\t\t.mask = GENMASK(3, 0),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {   7500, 0x02 },\n\t\t\t\t.odr_avl[1] = {  15000, 0x03 },\n\t\t\t\t.odr_avl[2] = {  30000, 0x04 },\n\t\t\t\t.odr_avl[3] = {  60000, 0x05 },\n\t\t\t\t.odr_avl[4] = { 120000, 0x06 },\n\t\t\t\t.odr_avl[5] = { 240000, 0x07 },\n\t\t\t\t.odr_avl[6] = { 480000, 0x08 },\n\t\t\t\t.odr_avl[7] = { 960000, 0x09 },\n\t\t\t\t.odr_len = 8,\n\t\t\t},\n\t\t},\n\t\t.fs_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x17,\n\t\t\t\t\t.mask = GENMASK(1, 0),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_G_TO_M_S_2(61000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_G_TO_M_S_2(122000), 0x1 },\n\t\t\t\t.fs_avl[2] = { IIO_G_TO_M_S_2(244000), 0x2 },\n\t\t\t\t.fs_avl[3] = { IIO_G_TO_M_S_2(488000), 0x3 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x15,\n\t\t\t\t\t.mask = GENMASK(3, 0),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_DEGREE_TO_RAD(8750000), 0x1 },\n\t\t\t\t.fs_avl[1] = { IIO_DEGREE_TO_RAD(17500000), 0x2 },\n\t\t\t\t.fs_avl[2] = { IIO_DEGREE_TO_RAD(35000000), 0x3 },\n\t\t\t\t.fs_avl[3] = { IIO_DEGREE_TO_RAD(70000000), 0x4 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t},\n\t\t.irq_config = {\n\t\t\t.irq1 = {\n\t\t\t\t.addr = 0x0d,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.irq2 = {\n\t\t\t\t.addr = 0x0e,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.lir = {\n\t\t\t\t.addr = 0x56,\n\t\t\t\t.mask = BIT(0),\n\t\t\t},\n\t\t\t.irq1_func = {\n\t\t\t\t.addr = 0x5e,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.irq2_func = {\n\t\t\t\t.addr = 0x5f,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.hla = {\n\t\t\t\t.addr = 0x03,\n\t\t\t\t.mask = BIT(4),\n\t\t\t},\n\t\t\t.od = {\n\t\t\t\t.addr = 0x03,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t},\n\t\t.batch = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.addr = 0x09,\n\t\t\t\t.mask = GENMASK(3, 0),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.addr = 0x09,\n\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t},\n\t\t},\n\t\t.fifo_ops = {\n\t\t\t.update_fifo = st_lsm6dsx_update_fifo,\n\t\t\t.read_fifo = st_lsm6dsx_read_tagged_fifo,\n\t\t\t.fifo_th = {\n\t\t\t\t.addr = 0x07,\n\t\t\t\t.mask = GENMASK(7, 0),\n\t\t\t},\n\t\t\t.fifo_diff = {\n\t\t\t\t.addr = 0x1b,\n\t\t\t\t.mask = GENMASK(8, 0),\n\t\t\t},\n\t\t\t.max_size = 512,\n\t\t\t.th_wl = 1,\n\t\t},\n\t\t.ts_settings = {\n\t\t\t.timer_en = {\n\t\t\t\t.addr = 0x50,\n\t\t\t\t.mask = BIT(6),\n\t\t\t},\n\t\t\t.decimator = {\n\t\t\t\t.addr = 0x0a,\n\t\t\t\t.mask = GENMASK(7, 6),\n\t\t\t},\n\t\t\t.freq_fine = 0x4f,\n\t\t},\n\t\t.shub_settings = {\n\t\t\t.page_mux = {\n\t\t\t\t.addr = 0x01,\n\t\t\t\t.mask = BIT(6),\n\t\t\t},\n\t\t\t.master_en = {\n\t\t\t\t.sec_page = true,\n\t\t\t\t.addr = 0x14,\n\t\t\t\t.mask = BIT(2),\n\t\t\t},\n\t\t\t.pullup_en = {\n\t\t\t\t.addr = 0x03,\n\t\t\t\t.mask = BIT(6),\n\t\t\t},\n\t\t\t.aux_sens = {\n\t\t\t\t.addr = 0x14,\n\t\t\t\t.mask = GENMASK(1, 0),\n\t\t\t},\n\t\t\t.wr_once = {\n\t\t\t\t.addr = 0x14,\n\t\t\t\t.mask = BIT(6),\n\t\t\t},\n\t\t\t.num_ext_dev = 3,\n\t\t\t.shub_out = {\n\t\t\t\t.sec_page = true,\n\t\t\t\t.addr = 0x02,\n\t\t\t},\n\t\t\t.slv0_addr = 0x15,\n\t\t\t.dw_slv0_addr = 0x21,\n\t\t\t.batch_en = BIT(3),\n\t\t},\n\t\t.event_settings = {\n\t\t\t.enable_reg = {\n\t\t\t\t.addr = 0x50,\n\t\t\t\t.mask = BIT(7),\n\t\t\t},\n\t\t\t.wakeup_reg = {\n\t\t\t\t.addr = 0x5b,\n\t\t\t\t.mask = GENMASK(5, 0),\n\t\t\t},\n\t\t\t.wakeup_src_reg = 0x45,\n\t\t\t.wakeup_src_status_mask = BIT(3),\n\t\t\t.wakeup_src_z_mask = BIT(0),\n\t\t\t.wakeup_src_y_mask = BIT(1),\n\t\t\t.wakeup_src_x_mask = BIT(2),\n\t\t},\n\t},\n\t{\n\t\t.reset = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(0),\n\t\t},\n\t\t.boot = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(7),\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x12,\n\t\t\t.mask = BIT(6),\n\t\t},\n\t\t.id = {\n\t\t\t{\n\t\t\t\t.hw_id = ST_LSM6DSO16IS_ID,\n\t\t\t\t.name = ST_LSM6DSO16IS_DEV_NAME,\n\t\t\t\t.wai = 0x22,\n\t\t\t}, {\n\t\t\t\t.hw_id = ST_ISM330IS_ID,\n\t\t\t\t.name = ST_ISM330IS_DEV_NAME,\n\t\t\t\t.wai = 0x22,\n\t\t\t}\n\t\t},\n\t\t.channels = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.chan = st_lsm6dsx_acc_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_acc_channels),\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.chan = st_lsm6dsx_gyro_channels,\n\t\t\t\t.len = ARRAY_SIZE(st_lsm6dsx_gyro_channels),\n\t\t\t},\n\t\t},\n\t\t.odr_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {  12500, 0x01 },\n\t\t\t\t.odr_avl[1] = {  26000, 0x02 },\n\t\t\t\t.odr_avl[2] = {  52000, 0x03 },\n\t\t\t\t.odr_avl[3] = { 104000, 0x04 },\n\t\t\t\t.odr_avl[4] = { 208000, 0x05 },\n\t\t\t\t.odr_avl[5] = { 416000, 0x06 },\n\t\t\t\t.odr_avl[6] = { 833000, 0x07 },\n\t\t\t\t.odr_len = 7,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x11,\n\t\t\t\t\t.mask = GENMASK(7, 4),\n\t\t\t\t},\n\t\t\t\t.odr_avl[0] = {  12500, 0x01 },\n\t\t\t\t.odr_avl[1] = {  26000, 0x02 },\n\t\t\t\t.odr_avl[2] = {  52000, 0x03 },\n\t\t\t\t.odr_avl[3] = { 104000, 0x04 },\n\t\t\t\t.odr_avl[4] = { 208000, 0x05 },\n\t\t\t\t.odr_avl[5] = { 416000, 0x06 },\n\t\t\t\t.odr_avl[6] = { 833000, 0x07 },\n\t\t\t\t.odr_len = 7,\n\t\t\t},\n\t\t},\n\t\t.fs_table = {\n\t\t\t[ST_LSM6DSX_ID_ACC] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x10,\n\t\t\t\t\t.mask = GENMASK(3, 2),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_G_TO_M_S_2(61000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_G_TO_M_S_2(122000), 0x2 },\n\t\t\t\t.fs_avl[2] = { IIO_G_TO_M_S_2(244000), 0x3 },\n\t\t\t\t.fs_avl[3] = { IIO_G_TO_M_S_2(488000), 0x1 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t\t[ST_LSM6DSX_ID_GYRO] = {\n\t\t\t\t.reg = {\n\t\t\t\t\t.addr = 0x11,\n\t\t\t\t\t.mask = GENMASK(3, 2),\n\t\t\t\t},\n\t\t\t\t.fs_avl[0] = {  IIO_DEGREE_TO_RAD(8750000), 0x0 },\n\t\t\t\t.fs_avl[1] = { IIO_DEGREE_TO_RAD(17500000), 0x1 },\n\t\t\t\t.fs_avl[2] = { IIO_DEGREE_TO_RAD(35000000), 0x2 },\n\t\t\t\t.fs_avl[3] = { IIO_DEGREE_TO_RAD(70000000), 0x3 },\n\t\t\t\t.fs_len = 4,\n\t\t\t},\n\t\t},\n\t\t.irq_config = {\n\t\t\t.hla = {\n\t\t\t\t.addr = 0x12,\n\t\t\t\t.mask = BIT(5),\n\t\t\t},\n\t\t\t.od = {\n\t\t\t\t.addr = 0x12,\n\t\t\t\t.mask = BIT(4),\n\t\t\t},\n\t\t},\n\t\t.shub_settings = {\n\t\t\t.page_mux = {\n\t\t\t\t.addr = 0x01,\n\t\t\t\t.mask = BIT(6),\n\t\t\t},\n\t\t\t.master_en = {\n\t\t\t\t.sec_page = true,\n\t\t\t\t.addr = 0x14,\n\t\t\t\t.mask = BIT(2),\n\t\t\t},\n\t\t\t.pullup_en = {\n\t\t\t\t.sec_page = true,\n\t\t\t\t.addr = 0x14,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t.aux_sens = {\n\t\t\t\t.addr = 0x14,\n\t\t\t\t.mask = GENMASK(1, 0),\n\t\t\t},\n\t\t\t.wr_once = {\n\t\t\t\t.addr = 0x14,\n\t\t\t\t.mask = BIT(6),\n\t\t\t},\n\t\t\t.num_ext_dev = 3,\n\t\t\t.shub_out = {\n\t\t\t\t.sec_page = true,\n\t\t\t\t.addr = 0x02,\n\t\t\t},\n\t\t\t.slv0_addr = 0x15,\n\t\t\t.dw_slv0_addr = 0x21,\n\t\t},\n\t},\n};\n\nint st_lsm6dsx_set_page(struct st_lsm6dsx_hw *hw, bool enable)\n{\n\tconst struct st_lsm6dsx_shub_settings *hub_settings;\n\tunsigned int data;\n\tint err;\n\n\thub_settings = &hw->settings->shub_settings;\n\tdata = ST_LSM6DSX_SHIFT_VAL(enable, hub_settings->page_mux.mask);\n\terr = regmap_update_bits(hw->regmap, hub_settings->page_mux.addr,\n\t\t\t\t hub_settings->page_mux.mask, data);\n\tusleep_range(100, 150);\n\n\treturn err;\n}\n\nstatic int st_lsm6dsx_check_whoami(struct st_lsm6dsx_hw *hw, int id,\n\t\t\t\t   const char **name)\n{\n\tint err, i, j, data;\n\n\tfor (i = 0; i < ARRAY_SIZE(st_lsm6dsx_sensor_settings); i++) {\n\t\tfor (j = 0; j < ST_LSM6DSX_MAX_ID; j++) {\n\t\t\tif (st_lsm6dsx_sensor_settings[i].id[j].name &&\n\t\t\t    id == st_lsm6dsx_sensor_settings[i].id[j].hw_id)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j < ST_LSM6DSX_MAX_ID)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(st_lsm6dsx_sensor_settings)) {\n\t\tdev_err(hw->dev, \"unsupported hw id [%02x]\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\terr = regmap_read(hw->regmap, ST_LSM6DSX_REG_WHOAMI_ADDR, &data);\n\tif (err < 0) {\n\t\tdev_err(hw->dev, \"failed to read whoami register\\n\");\n\t\treturn err;\n\t}\n\n\tif (data != st_lsm6dsx_sensor_settings[i].id[j].wai) {\n\t\tdev_err(hw->dev, \"unsupported whoami [%02x]\\n\", data);\n\t\treturn -ENODEV;\n\t}\n\n\t*name = st_lsm6dsx_sensor_settings[i].id[j].name;\n\thw->settings = &st_lsm6dsx_sensor_settings[i];\n\n\treturn 0;\n}\n\nstatic int st_lsm6dsx_set_full_scale(struct st_lsm6dsx_sensor *sensor,\n\t\t\t\t     u32 gain)\n{\n\tconst struct st_lsm6dsx_fs_table_entry *fs_table;\n\tunsigned int data;\n\tint i, err;\n\n\tfs_table = &sensor->hw->settings->fs_table[sensor->id];\n\tfor (i = 0; i < fs_table->fs_len; i++) {\n\t\tif (fs_table->fs_avl[i].gain == gain)\n\t\t\tbreak;\n\t}\n\n\tif (i == fs_table->fs_len)\n\t\treturn -EINVAL;\n\n\tdata = ST_LSM6DSX_SHIFT_VAL(fs_table->fs_avl[i].val,\n\t\t\t\t    fs_table->reg.mask);\n\terr = st_lsm6dsx_update_bits_locked(sensor->hw, fs_table->reg.addr,\n\t\t\t\t\t    fs_table->reg.mask, data);\n\tif (err < 0)\n\t\treturn err;\n\n\tsensor->gain = gain;\n\n\treturn 0;\n}\n\nint st_lsm6dsx_check_odr(struct st_lsm6dsx_sensor *sensor, u32 odr, u8 *val)\n{\n\tconst struct st_lsm6dsx_odr_table_entry *odr_table;\n\tint i;\n\n\todr_table = &sensor->hw->settings->odr_table[sensor->id];\n\tfor (i = 0; i < odr_table->odr_len; i++) {\n\t\t \n\t\tif (odr_table->odr_avl[i].milli_hz >= odr)\n\t\t\tbreak;\n\t}\n\n\tif (i == odr_table->odr_len)\n\t\treturn -EINVAL;\n\n\t*val = odr_table->odr_avl[i].val;\n\treturn odr_table->odr_avl[i].milli_hz;\n}\n\nstatic int\nst_lsm6dsx_check_odr_dependency(struct st_lsm6dsx_hw *hw, u32 odr,\n\t\t\t\tenum st_lsm6dsx_sensor_id id)\n{\n\tstruct st_lsm6dsx_sensor *ref = iio_priv(hw->iio_devs[id]);\n\n\tif (odr > 0) {\n\t\tif (hw->enable_mask & BIT(id))\n\t\t\treturn max_t(u32, ref->odr, odr);\n\t\telse\n\t\t\treturn odr;\n\t} else {\n\t\treturn (hw->enable_mask & BIT(id)) ? ref->odr : 0;\n\t}\n}\n\nstatic int\nst_lsm6dsx_set_odr(struct st_lsm6dsx_sensor *sensor, u32 req_odr)\n{\n\tstruct st_lsm6dsx_sensor *ref_sensor = sensor;\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tconst struct st_lsm6dsx_reg *reg;\n\tunsigned int data;\n\tu8 val = 0;\n\tint err;\n\n\tswitch (sensor->id) {\n\tcase ST_LSM6DSX_ID_GYRO:\n\t\tbreak;\n\tcase ST_LSM6DSX_ID_EXT0:\n\tcase ST_LSM6DSX_ID_EXT1:\n\tcase ST_LSM6DSX_ID_EXT2:\n\tcase ST_LSM6DSX_ID_ACC: {\n\t\tu32 odr;\n\t\tint i;\n\n\t\t \n\t\tref_sensor = iio_priv(hw->iio_devs[ST_LSM6DSX_ID_ACC]);\n\t\tfor (i = ST_LSM6DSX_ID_ACC; i < ST_LSM6DSX_ID_MAX; i++) {\n\t\t\tif (!hw->iio_devs[i] || i == sensor->id)\n\t\t\t\tcontinue;\n\n\t\t\todr = st_lsm6dsx_check_odr_dependency(hw, req_odr, i);\n\t\t\tif (odr != req_odr)\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:  \n\t\treturn -EINVAL;\n\t}\n\n\tif (req_odr > 0) {\n\t\terr = st_lsm6dsx_check_odr(ref_sensor, req_odr, &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treg = &hw->settings->odr_table[ref_sensor->id].reg;\n\tdata = ST_LSM6DSX_SHIFT_VAL(val, reg->mask);\n\treturn st_lsm6dsx_update_bits_locked(hw, reg->addr, reg->mask, data);\n}\n\nstatic int\n__st_lsm6dsx_sensor_set_enable(struct st_lsm6dsx_sensor *sensor,\n\t\t\t       bool enable)\n{\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tu32 odr = enable ? sensor->odr : 0;\n\tint err;\n\n\terr = st_lsm6dsx_set_odr(sensor, odr);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (enable)\n\t\thw->enable_mask |= BIT(sensor->id);\n\telse\n\t\thw->enable_mask &= ~BIT(sensor->id);\n\n\treturn 0;\n}\n\nstatic int\nst_lsm6dsx_check_events(struct st_lsm6dsx_sensor *sensor, bool enable)\n{\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\n\tif (sensor->id == ST_LSM6DSX_ID_GYRO || enable)\n\t\treturn 0;\n\n\treturn hw->enable_event;\n}\n\nint st_lsm6dsx_sensor_set_enable(struct st_lsm6dsx_sensor *sensor,\n\t\t\t\t bool enable)\n{\n\tif (st_lsm6dsx_check_events(sensor, enable))\n\t\treturn 0;\n\n\treturn __st_lsm6dsx_sensor_set_enable(sensor, enable);\n}\n\nstatic int st_lsm6dsx_read_oneshot(struct st_lsm6dsx_sensor *sensor,\n\t\t\t\t   u8 addr, int *val)\n{\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tint err, delay;\n\t__le16 data;\n\n\terr = st_lsm6dsx_sensor_set_enable(sensor, true);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tdelay = 1000000000 / sensor->odr;\n\tusleep_range(3 * delay, 4 * delay);\n\n\terr = st_lsm6dsx_read_locked(hw, addr, &data, sizeof(data));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!hw->enable_event) {\n\t\terr = st_lsm6dsx_sensor_set_enable(sensor, false);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t*val = (s16)le16_to_cpu(data);\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int st_lsm6dsx_read_raw(struct iio_dev *iio_dev,\n\t\t\t       struct iio_chan_spec const *ch,\n\t\t\t       int *val, int *val2, long mask)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(iio_dev);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = st_lsm6dsx_read_oneshot(sensor, ch->address, val);\n\t\tiio_device_release_direct_mode(iio_dev);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = sensor->odr / 1000;\n\t\t*val2 = (sensor->odr % 1000) * 1000;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = sensor->gain;\n\t\tret = IIO_VAL_INT_PLUS_NANO;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int st_lsm6dsx_write_raw(struct iio_dev *iio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint val, int val2, long mask)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\n\tint err;\n\n\terr = iio_device_claim_direct_mode(iio_dev);\n\tif (err)\n\t\treturn err;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\terr = st_lsm6dsx_set_full_scale(sensor, val2);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ: {\n\t\tu8 data;\n\n\t\tval = val * 1000 + val2 / 1000;\n\t\tval = st_lsm6dsx_check_odr(sensor, val, &data);\n\t\tif (val < 0)\n\t\t\terr = val;\n\t\telse\n\t\t\tsensor->odr = val;\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tiio_device_release_direct_mode(iio_dev);\n\n\treturn err;\n}\n\nstatic int st_lsm6dsx_event_setup(struct st_lsm6dsx_hw *hw, int state)\n{\n\tconst struct st_lsm6dsx_reg *reg;\n\tunsigned int data;\n\tint err;\n\n\tif (!hw->settings->irq_config.irq1_func.addr)\n\t\treturn -ENOTSUPP;\n\n\treg = &hw->settings->event_settings.enable_reg;\n\tif (reg->addr) {\n\t\tdata = ST_LSM6DSX_SHIFT_VAL(state, reg->mask);\n\t\terr = st_lsm6dsx_update_bits_locked(hw, reg->addr,\n\t\t\t\t\t\t    reg->mask, data);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tdata = ST_LSM6DSX_SHIFT_VAL(state, hw->irq_routing->mask);\n\treturn st_lsm6dsx_update_bits_locked(hw, hw->irq_routing->addr,\n\t\t\t\t\t     hw->irq_routing->mask, data);\n}\n\nstatic int st_lsm6dsx_read_event(struct iio_dev *iio_dev,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t enum iio_event_type type,\n\t\t\t\t enum iio_event_direction dir,\n\t\t\t\t enum iio_event_info info,\n\t\t\t\t int *val, int *val2)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\n\tif (type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\t*val2 = 0;\n\t*val = hw->event_threshold;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int\nst_lsm6dsx_write_event(struct iio_dev *iio_dev,\n\t\t       const struct iio_chan_spec *chan,\n\t\t       enum iio_event_type type,\n\t\t       enum iio_event_direction dir,\n\t\t       enum iio_event_info info,\n\t\t       int val, int val2)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tconst struct st_lsm6dsx_reg *reg;\n\tunsigned int data;\n\tint err;\n\n\tif (type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\tif (val < 0 || val > 31)\n\t\treturn -EINVAL;\n\n\treg = &hw->settings->event_settings.wakeup_reg;\n\tdata = ST_LSM6DSX_SHIFT_VAL(val, reg->mask);\n\terr = st_lsm6dsx_update_bits_locked(hw, reg->addr,\n\t\t\t\t\t    reg->mask, data);\n\tif (err < 0)\n\t\treturn -EINVAL;\n\n\thw->event_threshold = val;\n\n\treturn 0;\n}\n\nstatic int\nst_lsm6dsx_read_event_config(struct iio_dev *iio_dev,\n\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t     enum iio_event_type type,\n\t\t\t     enum iio_event_direction dir)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\n\tif (type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\treturn !!(hw->enable_event & BIT(chan->channel2));\n}\n\nstatic int\nst_lsm6dsx_write_event_config(struct iio_dev *iio_dev,\n\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t      enum iio_event_type type,\n\t\t\t      enum iio_event_direction dir, int state)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tu8 enable_event;\n\tint err;\n\n\tif (type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\tif (state) {\n\t\tenable_event = hw->enable_event | BIT(chan->channel2);\n\n\t\t \n\t\tif (hw->enable_event)\n\t\t\tgoto out;\n\t} else {\n\t\tenable_event = hw->enable_event & ~BIT(chan->channel2);\n\n\t\t \n\t\tif (enable_event)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (hw->enable_event == enable_event)\n\t\treturn 0;\n\n\terr = st_lsm6dsx_event_setup(hw, state);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&hw->conf_lock);\n\tif (enable_event || !(hw->fifo_mask & BIT(sensor->id)))\n\t\terr = __st_lsm6dsx_sensor_set_enable(sensor, state);\n\tmutex_unlock(&hw->conf_lock);\n\tif (err < 0)\n\t\treturn err;\n\nout:\n\thw->enable_event = enable_event;\n\n\treturn 0;\n}\n\nint st_lsm6dsx_set_watermark(struct iio_dev *iio_dev, unsigned int val)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tint err;\n\n\tval = clamp_val(val, 1, hw->settings->fifo_ops.max_size);\n\n\tmutex_lock(&hw->conf_lock);\n\n\terr = st_lsm6dsx_update_watermark(sensor, val);\n\n\tmutex_unlock(&hw->conf_lock);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tsensor->watermark = val;\n\n\treturn 0;\n}\n\nstatic ssize_t\nst_lsm6dsx_sysfs_sampling_frequency_avail(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(dev_to_iio_dev(dev));\n\tconst struct st_lsm6dsx_odr_table_entry *odr_table;\n\tint i, len = 0;\n\n\todr_table = &sensor->hw->settings->odr_table[sensor->id];\n\tfor (i = 0; i < odr_table->odr_len; i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d.%03d \",\n\t\t\t\t odr_table->odr_avl[i].milli_hz / 1000,\n\t\t\t\t odr_table->odr_avl[i].milli_hz % 1000);\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t st_lsm6dsx_sysfs_scale_avail(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(dev_to_iio_dev(dev));\n\tconst struct st_lsm6dsx_fs_table_entry *fs_table;\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tint i, len = 0;\n\n\tfs_table = &hw->settings->fs_table[sensor->id];\n\tfor (i = 0; i < fs_table->fs_len; i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"0.%09u \",\n\t\t\t\t fs_table->fs_avl[i].gain);\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic int st_lsm6dsx_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\t\tlong mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\tcase IIO_ACCEL:\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tdefault:\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\tdefault:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n}\n\nstatic IIO_DEV_ATTR_SAMP_FREQ_AVAIL(st_lsm6dsx_sysfs_sampling_frequency_avail);\nstatic IIO_DEVICE_ATTR(in_accel_scale_available, 0444,\n\t\t       st_lsm6dsx_sysfs_scale_avail, NULL, 0);\nstatic IIO_DEVICE_ATTR(in_anglvel_scale_available, 0444,\n\t\t       st_lsm6dsx_sysfs_scale_avail, NULL, 0);\n\nstatic struct attribute *st_lsm6dsx_acc_attributes[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_in_accel_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group st_lsm6dsx_acc_attribute_group = {\n\t.attrs = st_lsm6dsx_acc_attributes,\n};\n\nstatic const struct iio_info st_lsm6dsx_acc_info = {\n\t.attrs = &st_lsm6dsx_acc_attribute_group,\n\t.read_raw = st_lsm6dsx_read_raw,\n\t.write_raw = st_lsm6dsx_write_raw,\n\t.read_event_value = st_lsm6dsx_read_event,\n\t.write_event_value = st_lsm6dsx_write_event,\n\t.read_event_config = st_lsm6dsx_read_event_config,\n\t.write_event_config = st_lsm6dsx_write_event_config,\n\t.hwfifo_set_watermark = st_lsm6dsx_set_watermark,\n\t.write_raw_get_fmt = st_lsm6dsx_write_raw_get_fmt,\n};\n\nstatic struct attribute *st_lsm6dsx_gyro_attributes[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_in_anglvel_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group st_lsm6dsx_gyro_attribute_group = {\n\t.attrs = st_lsm6dsx_gyro_attributes,\n};\n\nstatic const struct iio_info st_lsm6dsx_gyro_info = {\n\t.attrs = &st_lsm6dsx_gyro_attribute_group,\n\t.read_raw = st_lsm6dsx_read_raw,\n\t.write_raw = st_lsm6dsx_write_raw,\n\t.hwfifo_set_watermark = st_lsm6dsx_set_watermark,\n\t.write_raw_get_fmt = st_lsm6dsx_write_raw_get_fmt,\n};\n\nstatic int st_lsm6dsx_get_drdy_pin(struct st_lsm6dsx_hw *hw, int *drdy_pin)\n{\n\tstruct device *dev = hw->dev;\n\n\tif (!dev_fwnode(dev))\n\t\treturn -EINVAL;\n\n\treturn device_property_read_u32(dev, \"st,drdy-int-pin\", drdy_pin);\n}\n\nstatic int\nst_lsm6dsx_get_drdy_reg(struct st_lsm6dsx_hw *hw,\n\t\t\tconst struct st_lsm6dsx_reg **drdy_reg)\n{\n\tint err = 0, drdy_pin;\n\n\tif (st_lsm6dsx_get_drdy_pin(hw, &drdy_pin) < 0) {\n\t\tstruct st_sensors_platform_data *pdata;\n\t\tstruct device *dev = hw->dev;\n\n\t\tpdata = (struct st_sensors_platform_data *)dev->platform_data;\n\t\tdrdy_pin = pdata ? pdata->drdy_int_pin : 1;\n\t}\n\n\tswitch (drdy_pin) {\n\tcase 1:\n\t\thw->irq_routing = &hw->settings->irq_config.irq1_func;\n\t\t*drdy_reg = &hw->settings->irq_config.irq1;\n\t\tbreak;\n\tcase 2:\n\t\thw->irq_routing = &hw->settings->irq_config.irq2_func;\n\t\t*drdy_reg = &hw->settings->irq_config.irq2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hw->dev, \"unsupported data ready pin\\n\");\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int st_lsm6dsx_init_shub(struct st_lsm6dsx_hw *hw)\n{\n\tconst struct st_lsm6dsx_shub_settings *hub_settings;\n\tstruct st_sensors_platform_data *pdata;\n\tstruct device *dev = hw->dev;\n\tunsigned int data;\n\tint err = 0;\n\n\thub_settings = &hw->settings->shub_settings;\n\n\tpdata = (struct st_sensors_platform_data *)dev->platform_data;\n\tif ((dev_fwnode(dev) && device_property_read_bool(dev, \"st,pullups\")) ||\n\t    (pdata && pdata->pullups)) {\n\t\tif (hub_settings->pullup_en.sec_page) {\n\t\t\terr = st_lsm6dsx_set_page(hw, true);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tdata = ST_LSM6DSX_SHIFT_VAL(1, hub_settings->pullup_en.mask);\n\t\terr = regmap_update_bits(hw->regmap,\n\t\t\t\t\t hub_settings->pullup_en.addr,\n\t\t\t\t\t hub_settings->pullup_en.mask, data);\n\n\t\tif (hub_settings->pullup_en.sec_page)\n\t\t\tst_lsm6dsx_set_page(hw, false);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (hub_settings->aux_sens.addr) {\n\t\t \n\t\terr = st_lsm6dsx_set_page(hw, true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tdata = ST_LSM6DSX_SHIFT_VAL(3, hub_settings->aux_sens.mask);\n\t\terr = regmap_update_bits(hw->regmap,\n\t\t\t\t\t hub_settings->aux_sens.addr,\n\t\t\t\t\t hub_settings->aux_sens.mask, data);\n\n\t\tst_lsm6dsx_set_page(hw, false);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (hub_settings->emb_func.addr) {\n\t\tdata = ST_LSM6DSX_SHIFT_VAL(1, hub_settings->emb_func.mask);\n\t\terr = regmap_update_bits(hw->regmap,\n\t\t\t\t\t hub_settings->emb_func.addr,\n\t\t\t\t\t hub_settings->emb_func.mask, data);\n\t}\n\n\treturn err;\n}\n\nstatic int st_lsm6dsx_init_hw_timer(struct st_lsm6dsx_hw *hw)\n{\n\tconst struct st_lsm6dsx_hw_ts_settings *ts_settings;\n\tint err, val;\n\n\tts_settings = &hw->settings->ts_settings;\n\t \n\tif (ts_settings->timer_en.addr) {\n\t\tval = ST_LSM6DSX_SHIFT_VAL(1, ts_settings->timer_en.mask);\n\t\terr = regmap_update_bits(hw->regmap,\n\t\t\t\t\t ts_settings->timer_en.addr,\n\t\t\t\t\t ts_settings->timer_en.mask, val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (ts_settings->hr_timer.addr) {\n\t\tval = ST_LSM6DSX_SHIFT_VAL(1, ts_settings->hr_timer.mask);\n\t\terr = regmap_update_bits(hw->regmap,\n\t\t\t\t\t ts_settings->hr_timer.addr,\n\t\t\t\t\t ts_settings->hr_timer.mask, val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (ts_settings->fifo_en.addr) {\n\t\tval = ST_LSM6DSX_SHIFT_VAL(1, ts_settings->fifo_en.mask);\n\t\terr = regmap_update_bits(hw->regmap,\n\t\t\t\t\t ts_settings->fifo_en.addr,\n\t\t\t\t\t ts_settings->fifo_en.mask, val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\thw->ts_gain = ST_LSM6DSX_TS_SENSITIVITY;\n\tif (ts_settings->freq_fine) {\n\t\terr = regmap_read(hw->regmap, ts_settings->freq_fine, &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\thw->ts_gain -= ((s8)val * 37500) / 1000;\n\t}\n\n\treturn 0;\n}\n\nstatic int st_lsm6dsx_reset_device(struct st_lsm6dsx_hw *hw)\n{\n\tconst struct st_lsm6dsx_reg *reg;\n\tint err;\n\n\t \n\terr = st_lsm6dsx_flush_fifo(hw);\n\tif (err < 0 && err != -ENOTSUPP)\n\t\treturn err;\n\n\t \n\treg = &hw->settings->reset;\n\terr = regmap_update_bits(hw->regmap, reg->addr, reg->mask,\n\t\t\t\t ST_LSM6DSX_SHIFT_VAL(1, reg->mask));\n\tif (err < 0)\n\t\treturn err;\n\n\tmsleep(50);\n\n\t \n\treg = &hw->settings->boot;\n\terr = regmap_update_bits(hw->regmap, reg->addr, reg->mask,\n\t\t\t\t ST_LSM6DSX_SHIFT_VAL(1, reg->mask));\n\tif (err < 0)\n\t\treturn err;\n\n\tmsleep(50);\n\n\treturn 0;\n}\n\nstatic int st_lsm6dsx_init_device(struct st_lsm6dsx_hw *hw)\n{\n\tconst struct st_lsm6dsx_reg *reg;\n\tint err;\n\n\terr = st_lsm6dsx_reset_device(hw);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treg = &hw->settings->bdu;\n\terr = regmap_update_bits(hw->regmap, reg->addr, reg->mask,\n\t\t\t\t ST_LSM6DSX_SHIFT_VAL(1, reg->mask));\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = st_lsm6dsx_get_drdy_reg(hw, &reg);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = regmap_update_bits(hw->regmap, reg->addr, reg->mask,\n\t\t\t\t ST_LSM6DSX_SHIFT_VAL(1, reg->mask));\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (hw->settings->irq_config.lir.addr) {\n\t\treg = &hw->settings->irq_config.lir;\n\t\terr = regmap_update_bits(hw->regmap, reg->addr, reg->mask,\n\t\t\t\t\t ST_LSM6DSX_SHIFT_VAL(1, reg->mask));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tif (hw->settings->irq_config.clear_on_read.addr) {\n\t\t\treg = &hw->settings->irq_config.clear_on_read;\n\t\t\terr = regmap_update_bits(hw->regmap,\n\t\t\t\t\treg->addr, reg->mask,\n\t\t\t\t\tST_LSM6DSX_SHIFT_VAL(1, reg->mask));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (hw->settings->drdy_mask.addr) {\n\t\treg = &hw->settings->drdy_mask;\n\t\terr = regmap_update_bits(hw->regmap, reg->addr, reg->mask,\n\t\t\t\t\t ST_LSM6DSX_SHIFT_VAL(1, reg->mask));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = st_lsm6dsx_init_shub(hw);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn st_lsm6dsx_init_hw_timer(hw);\n}\n\nstatic struct iio_dev *st_lsm6dsx_alloc_iiodev(struct st_lsm6dsx_hw *hw,\n\t\t\t\t\t       enum st_lsm6dsx_sensor_id id,\n\t\t\t\t\t       const char *name)\n{\n\tstruct st_lsm6dsx_sensor *sensor;\n\tstruct iio_dev *iio_dev;\n\n\tiio_dev = devm_iio_device_alloc(hw->dev, sizeof(*sensor));\n\tif (!iio_dev)\n\t\treturn NULL;\n\n\tiio_dev->modes = INDIO_DIRECT_MODE;\n\tiio_dev->available_scan_masks = st_lsm6dsx_available_scan_masks;\n\tiio_dev->channels = hw->settings->channels[id].chan;\n\tiio_dev->num_channels = hw->settings->channels[id].len;\n\n\tsensor = iio_priv(iio_dev);\n\tsensor->id = id;\n\tsensor->hw = hw;\n\tsensor->odr = hw->settings->odr_table[id].odr_avl[0].milli_hz;\n\tsensor->gain = hw->settings->fs_table[id].fs_avl[0].gain;\n\tsensor->watermark = 1;\n\n\tswitch (id) {\n\tcase ST_LSM6DSX_ID_ACC:\n\t\tiio_dev->info = &st_lsm6dsx_acc_info;\n\t\tscnprintf(sensor->name, sizeof(sensor->name), \"%s_accel\",\n\t\t\t  name);\n\t\tbreak;\n\tcase ST_LSM6DSX_ID_GYRO:\n\t\tiio_dev->info = &st_lsm6dsx_gyro_info;\n\t\tscnprintf(sensor->name, sizeof(sensor->name), \"%s_gyro\",\n\t\t\t  name);\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\tiio_dev->name = sensor->name;\n\n\treturn iio_dev;\n}\n\nstatic bool\nst_lsm6dsx_report_motion_event(struct st_lsm6dsx_hw *hw)\n{\n\tconst struct st_lsm6dsx_event_settings *event_settings;\n\tint err, data;\n\ts64 timestamp;\n\n\tif (!hw->enable_event)\n\t\treturn false;\n\n\tevent_settings = &hw->settings->event_settings;\n\terr = st_lsm6dsx_read_locked(hw, event_settings->wakeup_src_reg,\n\t\t\t\t     &data, sizeof(data));\n\tif (err < 0)\n\t\treturn false;\n\n\ttimestamp = iio_get_time_ns(hw->iio_devs[ST_LSM6DSX_ID_ACC]);\n\tif ((data & hw->settings->event_settings.wakeup_src_z_mask) &&\n\t    (hw->enable_event & BIT(IIO_MOD_Z)))\n\t\tiio_push_event(hw->iio_devs[ST_LSM6DSX_ID_ACC],\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  IIO_MOD_Z,\n\t\t\t\t\t\t  IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t  IIO_EV_DIR_EITHER),\n\t\t\t\t\t\t  timestamp);\n\n\tif ((data & hw->settings->event_settings.wakeup_src_y_mask) &&\n\t    (hw->enable_event & BIT(IIO_MOD_Y)))\n\t\tiio_push_event(hw->iio_devs[ST_LSM6DSX_ID_ACC],\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  IIO_MOD_Y,\n\t\t\t\t\t\t  IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t  IIO_EV_DIR_EITHER),\n\t\t\t\t\t\t  timestamp);\n\n\tif ((data & hw->settings->event_settings.wakeup_src_x_mask) &&\n\t    (hw->enable_event & BIT(IIO_MOD_X)))\n\t\tiio_push_event(hw->iio_devs[ST_LSM6DSX_ID_ACC],\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  IIO_MOD_X,\n\t\t\t\t\t\t  IIO_EV_TYPE_THRESH,\n\t\t\t\t\t\t  IIO_EV_DIR_EITHER),\n\t\t\t\t\t\t  timestamp);\n\n\treturn data & event_settings->wakeup_src_status_mask;\n}\n\nstatic irqreturn_t st_lsm6dsx_handler_thread(int irq, void *private)\n{\n\tstruct st_lsm6dsx_hw *hw = private;\n\tint fifo_len = 0, len;\n\tbool event;\n\n\tevent = st_lsm6dsx_report_motion_event(hw);\n\n\tif (!hw->settings->fifo_ops.read_fifo)\n\t\treturn event ? IRQ_HANDLED : IRQ_NONE;\n\n\t \n\tdo {\n\t\tmutex_lock(&hw->fifo_lock);\n\t\tlen = hw->settings->fifo_ops.read_fifo(hw);\n\t\tmutex_unlock(&hw->fifo_lock);\n\n\t\tif (len > 0)\n\t\t\tfifo_len += len;\n\t} while (len > 0);\n\n\treturn fifo_len || event ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic irqreturn_t st_lsm6dsx_sw_trigger_handler_thread(int irq,\n\t\t\t\t\t\t\tvoid *private)\n{\n\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *iio_dev = pf->indio_dev;\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\n\tif (sensor->id == ST_LSM6DSX_ID_EXT0 ||\n\t    sensor->id == ST_LSM6DSX_ID_EXT1 ||\n\t    sensor->id == ST_LSM6DSX_ID_EXT2)\n\t\tst_lsm6dsx_shub_read_output(hw,\n\t\t\t\t\t    (u8 *)hw->scan[sensor->id].channels,\n\t\t\t\t\t    sizeof(hw->scan[sensor->id].channels));\n\telse\n\t\tst_lsm6dsx_read_locked(hw, iio_dev->channels[0].address,\n\t\t\t\t       hw->scan[sensor->id].channels,\n\t\t\t\t       sizeof(hw->scan[sensor->id].channels));\n\n\tiio_push_to_buffers_with_timestamp(iio_dev, &hw->scan[sensor->id],\n\t\t\t\t\t   iio_get_time_ns(iio_dev));\n\tiio_trigger_notify_done(iio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int st_lsm6dsx_irq_setup(struct st_lsm6dsx_hw *hw)\n{\n\tstruct st_sensors_platform_data *pdata;\n\tconst struct st_lsm6dsx_reg *reg;\n\tstruct device *dev = hw->dev;\n\tunsigned long irq_type;\n\tbool irq_active_low;\n\tint err;\n\n\tirq_type = irqd_get_trigger_type(irq_get_irq_data(hw->irq));\n\n\tswitch (irq_type) {\n\tcase IRQF_TRIGGER_HIGH:\n\tcase IRQF_TRIGGER_RISING:\n\t\tirq_active_low = false;\n\t\tbreak;\n\tcase IRQF_TRIGGER_LOW:\n\tcase IRQF_TRIGGER_FALLING:\n\t\tirq_active_low = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_info(hw->dev, \"mode %lx unsupported\\n\", irq_type);\n\t\treturn -EINVAL;\n\t}\n\n\treg = &hw->settings->irq_config.hla;\n\terr = regmap_update_bits(hw->regmap, reg->addr, reg->mask,\n\t\t\t\t ST_LSM6DSX_SHIFT_VAL(irq_active_low,\n\t\t\t\t\t\t      reg->mask));\n\tif (err < 0)\n\t\treturn err;\n\n\tpdata = (struct st_sensors_platform_data *)dev->platform_data;\n\tif ((dev_fwnode(dev) && device_property_read_bool(dev, \"drive-open-drain\")) ||\n\t    (pdata && pdata->open_drain)) {\n\t\treg = &hw->settings->irq_config.od;\n\t\terr = regmap_update_bits(hw->regmap, reg->addr, reg->mask,\n\t\t\t\t\t ST_LSM6DSX_SHIFT_VAL(1, reg->mask));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tirq_type |= IRQF_SHARED;\n\t}\n\n\terr = devm_request_threaded_irq(hw->dev, hw->irq,\n\t\t\t\t\tNULL,\n\t\t\t\t\tst_lsm6dsx_handler_thread,\n\t\t\t\t\tirq_type | IRQF_ONESHOT,\n\t\t\t\t\t\"lsm6dsx\", hw);\n\tif (err) {\n\t\tdev_err(hw->dev, \"failed to request trigger irq %d\\n\",\n\t\t\thw->irq);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int st_lsm6dsx_sw_buffer_preenable(struct iio_dev *iio_dev)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\n\n\treturn st_lsm6dsx_device_set_enable(sensor, true);\n}\n\nstatic int st_lsm6dsx_sw_buffer_postdisable(struct iio_dev *iio_dev)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\n\n\treturn st_lsm6dsx_device_set_enable(sensor, false);\n}\n\nstatic const struct iio_buffer_setup_ops st_lsm6dsx_sw_buffer_ops = {\n\t.preenable = st_lsm6dsx_sw_buffer_preenable,\n\t.postdisable = st_lsm6dsx_sw_buffer_postdisable,\n};\n\nstatic int st_lsm6dsx_sw_buffers_setup(struct st_lsm6dsx_hw *hw)\n{\n\tint i;\n\n\tfor (i = 0; i < ST_LSM6DSX_ID_MAX; i++) {\n\t\tint err;\n\n\t\tif (!hw->iio_devs[i])\n\t\t\tcontinue;\n\n\t\terr = devm_iio_triggered_buffer_setup(hw->dev,\n\t\t\t\t\thw->iio_devs[i], NULL,\n\t\t\t\t\tst_lsm6dsx_sw_trigger_handler_thread,\n\t\t\t\t\t&st_lsm6dsx_sw_buffer_ops);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int st_lsm6dsx_init_regulators(struct device *dev)\n{\n\t \n\tstatic const char * const regulators[] = { \"vdd\", \"vddio\" };\n\tint err;\n\n\terr = devm_regulator_bulk_get_enable(dev, ARRAY_SIZE(regulators),\n\t\t\t\t\t     regulators);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"failed to enable regulators\\n\");\n\n\tmsleep(50);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\n\nstatic int lsm6dsx_get_acpi_mount_matrix(struct device *dev,\n\t\t\t\t\t struct iio_mount_matrix *orientation)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tunion acpi_object *obj, *elements;\n\tacpi_status status;\n\tint i, j, val[3];\n\tchar *str;\n\n\tif (!has_acpi_companion(dev))\n\t\treturn -EINVAL;\n\n\tif (!acpi_has_method(adev->handle, \"ROTM\"))\n\t\treturn -EINVAL;\n\n\tstatus = acpi_evaluate_object(adev->handle, \"ROTM\", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_warn(dev, \"Failed to get ACPI mount matrix: %d\\n\", status);\n\t\treturn -EINVAL;\n\t}\n\n\tobj = buffer.pointer;\n\tif (obj->type != ACPI_TYPE_PACKAGE || obj->package.count != 3)\n\t\tgoto unknown_format;\n\n\telements = obj->package.elements;\n\tfor (i = 0; i < 3; i++) {\n\t\tif (elements[i].type != ACPI_TYPE_STRING)\n\t\t\tgoto unknown_format;\n\n\t\tstr = elements[i].string.pointer;\n\t\tif (sscanf(str, \"%d %d %d\", &val[0], &val[1], &val[2]) != 3)\n\t\t\tgoto unknown_format;\n\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tswitch (val[j]) {\n\t\t\tcase -1: str = \"-1\"; break;\n\t\t\tcase 0:  str = \"0\";  break;\n\t\t\tcase 1:  str = \"1\";  break;\n\t\t\tdefault: goto unknown_format;\n\t\t\t}\n\t\t\torientation->rotation[i * 3 + j] = str;\n\t\t}\n\t}\n\n\tkfree(buffer.pointer);\n\treturn 0;\n\nunknown_format:\n\tdev_warn(dev, \"Unknown ACPI mount matrix format, ignoring\\n\");\n\tkfree(buffer.pointer);\n\treturn -EINVAL;\n}\n\n#else\n\nstatic int lsm6dsx_get_acpi_mount_matrix(struct device *dev,\n\t\t\t\t\t  struct iio_mount_matrix *orientation)\n{\n\treturn -EOPNOTSUPP;\n}\n\n#endif\n\nint st_lsm6dsx_probe(struct device *dev, int irq, int hw_id,\n\t\t     struct regmap *regmap)\n{\n\tstruct st_sensors_platform_data *pdata = dev->platform_data;\n\tconst struct st_lsm6dsx_shub_settings *hub_settings;\n\tstruct st_lsm6dsx_hw *hw;\n\tconst char *name = NULL;\n\tint i, err;\n\n\thw = devm_kzalloc(dev, sizeof(*hw), GFP_KERNEL);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, (void *)hw);\n\n\tmutex_init(&hw->fifo_lock);\n\tmutex_init(&hw->conf_lock);\n\tmutex_init(&hw->page_lock);\n\n\terr = st_lsm6dsx_init_regulators(dev);\n\tif (err)\n\t\treturn err;\n\n\thw->buff = devm_kzalloc(dev, ST_LSM6DSX_BUFF_SIZE, GFP_KERNEL);\n\tif (!hw->buff)\n\t\treturn -ENOMEM;\n\n\thw->dev = dev;\n\thw->irq = irq;\n\thw->regmap = regmap;\n\n\terr = st_lsm6dsx_check_whoami(hw, hw_id, &name);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < ST_LSM6DSX_ID_EXT0; i++) {\n\t\thw->iio_devs[i] = st_lsm6dsx_alloc_iiodev(hw, i, name);\n\t\tif (!hw->iio_devs[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\terr = st_lsm6dsx_init_device(hw);\n\tif (err < 0)\n\t\treturn err;\n\n\thub_settings = &hw->settings->shub_settings;\n\tif (hub_settings->master_en.addr &&\n\t    (!dev_fwnode(dev) ||\n\t     !device_property_read_bool(dev, \"st,disable-sensor-hub\"))) {\n\t\terr = st_lsm6dsx_shub_probe(hw, name);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (hw->irq > 0) {\n\t\terr = st_lsm6dsx_irq_setup(hw);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = st_lsm6dsx_fifo_setup(hw);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!hw->irq || !hw->settings->fifo_ops.read_fifo) {\n\t\t \n\t\terr = st_lsm6dsx_sw_buffers_setup(hw);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = lsm6dsx_get_acpi_mount_matrix(hw->dev, &hw->orientation);\n\tif (err) {\n\t\terr = iio_read_mount_matrix(hw->dev, &hw->orientation);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < ST_LSM6DSX_ID_MAX; i++) {\n\t\tif (!hw->iio_devs[i])\n\t\t\tcontinue;\n\n\t\terr = devm_iio_device_register(hw->dev, hw->iio_devs[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif ((dev_fwnode(dev) && device_property_read_bool(dev, \"wakeup-source\")) ||\n\t    (pdata && pdata->wakeup_source))\n\t\tdevice_init_wakeup(dev, true);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(st_lsm6dsx_probe, IIO_LSM6DSX);\n\nstatic int st_lsm6dsx_suspend(struct device *dev)\n{\n\tstruct st_lsm6dsx_hw *hw = dev_get_drvdata(dev);\n\tstruct st_lsm6dsx_sensor *sensor;\n\tint i, err = 0;\n\n\tfor (i = 0; i < ST_LSM6DSX_ID_MAX; i++) {\n\t\tif (!hw->iio_devs[i])\n\t\t\tcontinue;\n\n\t\tsensor = iio_priv(hw->iio_devs[i]);\n\t\tif (!(hw->enable_mask & BIT(sensor->id)))\n\t\t\tcontinue;\n\n\t\tif (device_may_wakeup(dev) &&\n\t\t    sensor->id == ST_LSM6DSX_ID_ACC && hw->enable_event) {\n\t\t\t \n\t\t\tenable_irq_wake(hw->irq);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = st_lsm6dsx_device_set_enable(sensor, false);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\thw->suspend_mask |= BIT(sensor->id);\n\t}\n\n\tif (hw->fifo_mask)\n\t\terr = st_lsm6dsx_flush_fifo(hw);\n\n\treturn err;\n}\n\nstatic int st_lsm6dsx_resume(struct device *dev)\n{\n\tstruct st_lsm6dsx_hw *hw = dev_get_drvdata(dev);\n\tstruct st_lsm6dsx_sensor *sensor;\n\tint i, err = 0;\n\n\tfor (i = 0; i < ST_LSM6DSX_ID_MAX; i++) {\n\t\tif (!hw->iio_devs[i])\n\t\t\tcontinue;\n\n\t\tsensor = iio_priv(hw->iio_devs[i]);\n\t\tif (device_may_wakeup(dev) &&\n\t\t    sensor->id == ST_LSM6DSX_ID_ACC && hw->enable_event)\n\t\t\tdisable_irq_wake(hw->irq);\n\n\t\tif (!(hw->suspend_mask & BIT(sensor->id)))\n\t\t\tcontinue;\n\n\t\terr = st_lsm6dsx_device_set_enable(sensor, true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\thw->suspend_mask &= ~BIT(sensor->id);\n\t}\n\n\tif (hw->fifo_mask)\n\t\terr = st_lsm6dsx_resume_fifo(hw);\n\n\treturn err;\n}\n\nEXPORT_NS_SIMPLE_DEV_PM_OPS(st_lsm6dsx_pm_ops, st_lsm6dsx_suspend,\n\t\t\t    st_lsm6dsx_resume, IIO_LSM6DSX);\n\nMODULE_AUTHOR(\"Lorenzo Bianconi <lorenzo.bianconi@st.com>\");\nMODULE_AUTHOR(\"Denis Ciocca <denis.ciocca@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics st_lsm6dsx driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}