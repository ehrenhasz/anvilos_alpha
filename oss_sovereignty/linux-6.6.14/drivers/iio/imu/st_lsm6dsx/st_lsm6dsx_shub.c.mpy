{
  "module_name": "st_lsm6dsx_shub.c",
  "hash_id": "37220a5ca861e4db3f6ed1ecf07cbb0b92345a9a81d51f9d262c14470fa8f022",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/st_lsm6dsx/st_lsm6dsx_shub.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/bitfield.h>\n\n#include \"st_lsm6dsx.h\"\n\n#define ST_LSM6DSX_SLV_ADDR(n, base)\t\t((base) + (n) * 3)\n#define ST_LSM6DSX_SLV_SUB_ADDR(n, base)\t((base) + 1 + (n) * 3)\n#define ST_LSM6DSX_SLV_CONFIG(n, base)\t\t((base) + 2 + (n) * 3)\n\n#define ST_LS6DSX_READ_OP_MASK\t\t\tGENMASK(2, 0)\n\nstatic const struct st_lsm6dsx_ext_dev_settings st_lsm6dsx_ext_dev_table[] = {\n\t \n\t{\n\t\t.i2c_addr = { 0x1e },\n\t\t.wai = {\n\t\t\t.addr = 0x4f,\n\t\t\t.val = 0x40,\n\t\t},\n\t\t.id = ST_LSM6DSX_ID_MAGN,\n\t\t.odr_table = {\n\t\t\t.reg = {\n\t\t\t\t.addr = 0x60,\n\t\t\t\t.mask = GENMASK(3, 2),\n\t\t\t},\n\t\t\t.odr_avl[0] = {  10000, 0x0 },\n\t\t\t.odr_avl[1] = {  20000, 0x1 },\n\t\t\t.odr_avl[2] = {  50000, 0x2 },\n\t\t\t.odr_avl[3] = { 100000, 0x3 },\n\t\t\t.odr_len = 4,\n\t\t},\n\t\t.fs_table = {\n\t\t\t.fs_avl[0] = {\n\t\t\t\t.gain = 1500,\n\t\t\t\t.val = 0x0,\n\t\t\t},  \n\t\t\t.fs_len = 1,\n\t\t},\n\t\t.temp_comp = {\n\t\t\t.addr = 0x60,\n\t\t\t.mask = BIT(7),\n\t\t},\n\t\t.pwr_table = {\n\t\t\t.reg = {\n\t\t\t\t.addr = 0x60,\n\t\t\t\t.mask = GENMASK(1, 0),\n\t\t\t},\n\t\t\t.off_val = 0x2,\n\t\t\t.on_val = 0x0,\n\t\t},\n\t\t.off_canc = {\n\t\t\t.addr = 0x61,\n\t\t\t.mask = BIT(1),\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x62,\n\t\t\t.mask = BIT(4),\n\t\t},\n\t\t.out = {\n\t\t\t.addr = 0x68,\n\t\t\t.len = 6,\n\t\t},\n\t},\n\t \n\t{\n\t\t.i2c_addr = { 0x1e },\n\t\t.wai = {\n\t\t\t.addr = 0x0f,\n\t\t\t.val = 0x3d,\n\t\t},\n\t\t.id = ST_LSM6DSX_ID_MAGN,\n\t\t.odr_table = {\n\t\t\t.reg = {\n\t\t\t\t.addr = 0x20,\n\t\t\t\t.mask = GENMASK(4, 2),\n\t\t\t},\n\t\t\t.odr_avl[0] = {  1000, 0x0 },\n\t\t\t.odr_avl[1] = {  2000, 0x1 },\n\t\t\t.odr_avl[2] = {  3000, 0x2 },\n\t\t\t.odr_avl[3] = {  5000, 0x3 },\n\t\t\t.odr_avl[4] = { 10000, 0x4 },\n\t\t\t.odr_avl[5] = { 20000, 0x5 },\n\t\t\t.odr_avl[6] = { 40000, 0x6 },\n\t\t\t.odr_avl[7] = { 80000, 0x7 },\n\t\t\t.odr_len = 8,\n\t\t},\n\t\t.fs_table = {\n\t\t\t.reg = {\n\t\t\t\t.addr = 0x21,\n\t\t\t\t.mask = GENMASK(6, 5),\n\t\t\t},\n\t\t\t.fs_avl[0] = {\n\t\t\t\t.gain = 146,\n\t\t\t\t.val = 0x00,\n\t\t\t},  \n\t\t\t.fs_avl[1] = {\n\t\t\t\t.gain = 292,\n\t\t\t\t.val = 0x01,\n\t\t\t},  \n\t\t\t.fs_avl[2] = {\n\t\t\t\t.gain = 438,\n\t\t\t\t.val = 0x02,\n\t\t\t},  \n\t\t\t.fs_avl[3] = {\n\t\t\t\t.gain = 584,\n\t\t\t\t.val = 0x03,\n\t\t\t},  \n\t\t\t.fs_len = 4,\n\t\t},\n\t\t.pwr_table = {\n\t\t\t.reg = {\n\t\t\t\t.addr = 0x22,\n\t\t\t\t.mask = GENMASK(1, 0),\n\t\t\t},\n\t\t\t.off_val = 0x2,\n\t\t\t.on_val = 0x0,\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x24,\n\t\t\t.mask = BIT(6),\n\t\t},\n\t\t.out = {\n\t\t\t.addr = 0x28,\n\t\t\t.len = 6,\n\t\t},\n\t},\n};\n\nstatic void st_lsm6dsx_shub_wait_complete(struct st_lsm6dsx_hw *hw)\n{\n\tstruct st_lsm6dsx_sensor *sensor;\n\tu32 odr, timeout;\n\n\tsensor = iio_priv(hw->iio_devs[ST_LSM6DSX_ID_ACC]);\n\todr = (hw->enable_mask & BIT(ST_LSM6DSX_ID_ACC)) ? sensor->odr : 12500;\n\t \n\ttimeout = max_t(u32, 2000000U / odr + 1, 10);\n\tmsleep(timeout);\n}\n\n \nint st_lsm6dsx_shub_read_output(struct st_lsm6dsx_hw *hw, u8 *data, int len)\n{\n\tconst struct st_lsm6dsx_shub_settings *hub_settings;\n\tint err;\n\n\tmutex_lock(&hw->page_lock);\n\n\thub_settings = &hw->settings->shub_settings;\n\tif (hub_settings->shub_out.sec_page) {\n\t\terr = st_lsm6dsx_set_page(hw, true);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\terr = regmap_bulk_read(hw->regmap, hub_settings->shub_out.addr,\n\t\t\t       data, len);\n\n\tif (hub_settings->shub_out.sec_page)\n\t\tst_lsm6dsx_set_page(hw, false);\nout:\n\tmutex_unlock(&hw->page_lock);\n\n\treturn err;\n}\n\n \nstatic int st_lsm6dsx_shub_write_reg(struct st_lsm6dsx_hw *hw, u8 addr,\n\t\t\t\t     u8 *data, int len)\n{\n\tint err;\n\n\tmutex_lock(&hw->page_lock);\n\terr = st_lsm6dsx_set_page(hw, true);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = regmap_bulk_write(hw->regmap, addr, data, len);\n\n\tst_lsm6dsx_set_page(hw, false);\nout:\n\tmutex_unlock(&hw->page_lock);\n\n\treturn err;\n}\n\nstatic int\nst_lsm6dsx_shub_write_reg_with_mask(struct st_lsm6dsx_hw *hw, u8 addr,\n\t\t\t\t    u8 mask, u8 val)\n{\n\tint err;\n\n\tmutex_lock(&hw->page_lock);\n\terr = st_lsm6dsx_set_page(hw, true);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = regmap_update_bits(hw->regmap, addr, mask, val);\n\n\tst_lsm6dsx_set_page(hw, false);\nout:\n\tmutex_unlock(&hw->page_lock);\n\n\treturn err;\n}\n\nstatic int st_lsm6dsx_shub_master_enable(struct st_lsm6dsx_sensor *sensor,\n\t\t\t\t\t bool enable)\n{\n\tconst struct st_lsm6dsx_shub_settings *hub_settings;\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tunsigned int data;\n\tint err;\n\n\t \n\terr = st_lsm6dsx_sensor_set_enable(sensor, enable);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&hw->page_lock);\n\n\thub_settings = &hw->settings->shub_settings;\n\tif (hub_settings->master_en.sec_page) {\n\t\terr = st_lsm6dsx_set_page(hw, true);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tdata = ST_LSM6DSX_SHIFT_VAL(enable, hub_settings->master_en.mask);\n\terr = regmap_update_bits(hw->regmap, hub_settings->master_en.addr,\n\t\t\t\t hub_settings->master_en.mask, data);\n\n\tif (hub_settings->master_en.sec_page)\n\t\tst_lsm6dsx_set_page(hw, false);\nout:\n\tmutex_unlock(&hw->page_lock);\n\n\treturn err;\n}\n\n \nstatic int\nst_lsm6dsx_shub_read(struct st_lsm6dsx_sensor *sensor, u8 addr,\n\t\t     u8 *data, int len)\n{\n\tconst struct st_lsm6dsx_shub_settings *hub_settings;\n\tu8 config[3], slv_addr, slv_config = 0;\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tconst struct st_lsm6dsx_reg *aux_sens;\n\tint err;\n\n\thub_settings = &hw->settings->shub_settings;\n\tslv_addr = ST_LSM6DSX_SLV_ADDR(0, hub_settings->slv0_addr);\n\taux_sens = &hw->settings->shub_settings.aux_sens;\n\t \n\tif (slv_addr + 2 == aux_sens->addr)\n\t\tslv_config = ST_LSM6DSX_SHIFT_VAL(3, aux_sens->mask);\n\n\tconfig[0] = (sensor->ext_info.addr << 1) | 1;\n\tconfig[1] = addr;\n\tconfig[2] = (len & ST_LS6DSX_READ_OP_MASK) | slv_config;\n\n\terr = st_lsm6dsx_shub_write_reg(hw, slv_addr, config,\n\t\t\t\t\tsizeof(config));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = st_lsm6dsx_shub_master_enable(sensor, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tst_lsm6dsx_shub_wait_complete(hw);\n\n\terr = st_lsm6dsx_shub_read_output(hw, data,\n\t\t\t\t\t  len & ST_LS6DSX_READ_OP_MASK);\n\tif (err < 0)\n\t\treturn err;\n\n\tst_lsm6dsx_shub_master_enable(sensor, false);\n\n\tconfig[0] = hub_settings->pause;\n\tconfig[1] = 0;\n\tconfig[2] = slv_config;\n\treturn st_lsm6dsx_shub_write_reg(hw, slv_addr, config,\n\t\t\t\t\t sizeof(config));\n}\n\n \nstatic int\nst_lsm6dsx_shub_write(struct st_lsm6dsx_sensor *sensor, u8 addr,\n\t\t      u8 *data, int len)\n{\n\tconst struct st_lsm6dsx_shub_settings *hub_settings;\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tu8 config[2], slv_addr;\n\tint err, i;\n\n\thub_settings = &hw->settings->shub_settings;\n\tif (hub_settings->wr_once.addr) {\n\t\tunsigned int data;\n\n\t\tdata = ST_LSM6DSX_SHIFT_VAL(1, hub_settings->wr_once.mask);\n\t\terr = st_lsm6dsx_shub_write_reg_with_mask(hw,\n\t\t\thub_settings->wr_once.addr,\n\t\t\thub_settings->wr_once.mask,\n\t\t\tdata);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tslv_addr = ST_LSM6DSX_SLV_ADDR(0, hub_settings->slv0_addr);\n\tconfig[0] = sensor->ext_info.addr << 1;\n\tfor (i = 0 ; i < len; i++) {\n\t\tconfig[1] = addr + i;\n\n\t\terr = st_lsm6dsx_shub_write_reg(hw, slv_addr, config,\n\t\t\t\t\t\tsizeof(config));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = st_lsm6dsx_shub_write_reg(hw, hub_settings->dw_slv0_addr,\n\t\t\t\t\t\t&data[i], 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = st_lsm6dsx_shub_master_enable(sensor, true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tst_lsm6dsx_shub_wait_complete(hw);\n\n\t\tst_lsm6dsx_shub_master_enable(sensor, false);\n\t}\n\n\tconfig[0] = hub_settings->pause;\n\tconfig[1] = 0;\n\treturn st_lsm6dsx_shub_write_reg(hw, slv_addr, config, sizeof(config));\n}\n\nstatic int\nst_lsm6dsx_shub_write_with_mask(struct st_lsm6dsx_sensor *sensor,\n\t\t\t\tu8 addr, u8 mask, u8 val)\n{\n\tint err;\n\tu8 data;\n\n\terr = st_lsm6dsx_shub_read(sensor, addr, &data, sizeof(data));\n\tif (err < 0)\n\t\treturn err;\n\n\tdata = ((data & ~mask) | (val << __ffs(mask) & mask));\n\n\treturn st_lsm6dsx_shub_write(sensor, addr, &data, sizeof(data));\n}\n\nstatic int\nst_lsm6dsx_shub_get_odr_val(struct st_lsm6dsx_sensor *sensor,\n\t\t\t    u32 odr, u16 *val)\n{\n\tconst struct st_lsm6dsx_ext_dev_settings *settings;\n\tint i;\n\n\tsettings = sensor->ext_info.settings;\n\tfor (i = 0; i < settings->odr_table.odr_len; i++) {\n\t\tif (settings->odr_table.odr_avl[i].milli_hz == odr)\n\t\t\tbreak;\n\t}\n\n\tif (i == settings->odr_table.odr_len)\n\t\treturn -EINVAL;\n\n\t*val = settings->odr_table.odr_avl[i].val;\n\treturn 0;\n}\n\nstatic int\nst_lsm6dsx_shub_set_odr(struct st_lsm6dsx_sensor *sensor, u32 odr)\n{\n\tconst struct st_lsm6dsx_ext_dev_settings *settings;\n\tu16 val;\n\tint err;\n\n\terr = st_lsm6dsx_shub_get_odr_val(sensor, odr, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tsettings = sensor->ext_info.settings;\n\treturn st_lsm6dsx_shub_write_with_mask(sensor,\n\t\t\t\t\t       settings->odr_table.reg.addr,\n\t\t\t\t\t       settings->odr_table.reg.mask,\n\t\t\t\t\t       val);\n}\n\n \nstatic int\nst_lsm6dsx_shub_config_channels(struct st_lsm6dsx_sensor *sensor,\n\t\t\t\tbool enable)\n{\n\tconst struct st_lsm6dsx_shub_settings *hub_settings;\n\tconst struct st_lsm6dsx_ext_dev_settings *settings;\n\tu8 config[9] = {}, enable_mask, slv_addr;\n\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\tstruct st_lsm6dsx_sensor *cur_sensor;\n\tint i, j = 0;\n\n\thub_settings = &hw->settings->shub_settings;\n\tif (enable)\n\t\tenable_mask = hw->enable_mask | BIT(sensor->id);\n\telse\n\t\tenable_mask = hw->enable_mask & ~BIT(sensor->id);\n\n\tfor (i = ST_LSM6DSX_ID_EXT0; i <= ST_LSM6DSX_ID_EXT2; i++) {\n\t\tif (!hw->iio_devs[i])\n\t\t\tcontinue;\n\n\t\tcur_sensor = iio_priv(hw->iio_devs[i]);\n\t\tif (!(enable_mask & BIT(cur_sensor->id)))\n\t\t\tcontinue;\n\n\t\tsettings = cur_sensor->ext_info.settings;\n\t\tconfig[j] = (sensor->ext_info.addr << 1) | 1;\n\t\tconfig[j + 1] = settings->out.addr;\n\t\tconfig[j + 2] = (settings->out.len & ST_LS6DSX_READ_OP_MASK) |\n\t\t\t\thub_settings->batch_en;\n\t\tj += 3;\n\t}\n\n\tslv_addr = ST_LSM6DSX_SLV_ADDR(1, hub_settings->slv0_addr);\n\treturn st_lsm6dsx_shub_write_reg(hw, slv_addr, config,\n\t\t\t\t\t sizeof(config));\n}\n\nint st_lsm6dsx_shub_set_enable(struct st_lsm6dsx_sensor *sensor, bool enable)\n{\n\tconst struct st_lsm6dsx_ext_dev_settings *settings;\n\tint err;\n\n\terr = st_lsm6dsx_shub_config_channels(sensor, enable);\n\tif (err < 0)\n\t\treturn err;\n\n\tsettings = sensor->ext_info.settings;\n\tif (enable) {\n\t\terr = st_lsm6dsx_shub_set_odr(sensor,\n\t\t\t\t\t      sensor->ext_info.slv_odr);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\terr = st_lsm6dsx_shub_write_with_mask(sensor,\n\t\t\t\t\tsettings->odr_table.reg.addr,\n\t\t\t\t\tsettings->odr_table.reg.mask, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (settings->pwr_table.reg.addr) {\n\t\tu8 val;\n\n\t\tval = enable ? settings->pwr_table.on_val\n\t\t\t     : settings->pwr_table.off_val;\n\t\terr = st_lsm6dsx_shub_write_with_mask(sensor,\n\t\t\t\t\tsettings->pwr_table.reg.addr,\n\t\t\t\t\tsettings->pwr_table.reg.mask, val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn st_lsm6dsx_shub_master_enable(sensor, enable);\n}\n\nstatic int\nst_lsm6dsx_shub_read_oneshot(struct st_lsm6dsx_sensor *sensor,\n\t\t\t     struct iio_chan_spec const *ch,\n\t\t\t     int *val)\n{\n\tint err, delay, len;\n\tu8 data[4];\n\n\terr = st_lsm6dsx_shub_set_enable(sensor, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tdelay = 1000000000 / sensor->ext_info.slv_odr;\n\tusleep_range(delay, 2 * delay);\n\n\tlen = min_t(int, sizeof(data), ch->scan_type.realbits >> 3);\n\terr = st_lsm6dsx_shub_read(sensor, ch->address, data, len);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = st_lsm6dsx_shub_set_enable(sensor, false);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (len) {\n\tcase 2:\n\t\t*val = (s16)le16_to_cpu(*((__le16 *)data));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int\nst_lsm6dsx_shub_read_raw(struct iio_dev *iio_dev,\n\t\t\t struct iio_chan_spec const *ch,\n\t\t\t int *val, int *val2, long mask)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(iio_dev);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = st_lsm6dsx_shub_read_oneshot(sensor, ch, val);\n\t\tiio_device_release_direct_mode(iio_dev);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = sensor->ext_info.slv_odr / 1000;\n\t\t*val2 = (sensor->ext_info.slv_odr % 1000) * 1000;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = sensor->gain;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nst_lsm6dsx_shub_set_full_scale(struct st_lsm6dsx_sensor *sensor,\n\t\t\t       u32 gain)\n{\n\tconst struct st_lsm6dsx_fs_table_entry *fs_table;\n\tint i, err;\n\n\tfs_table = &sensor->ext_info.settings->fs_table;\n\tif (!fs_table->reg.addr)\n\t\treturn -ENOTSUPP;\n\n\tfor (i = 0; i < fs_table->fs_len; i++) {\n\t\tif (fs_table->fs_avl[i].gain == gain)\n\t\t\tbreak;\n\t}\n\n\tif (i == fs_table->fs_len)\n\t\treturn -EINVAL;\n\n\terr = st_lsm6dsx_shub_write_with_mask(sensor, fs_table->reg.addr,\n\t\t\t\t\t      fs_table->reg.mask,\n\t\t\t\t\t      fs_table->fs_avl[i].val);\n\tif (err < 0)\n\t\treturn err;\n\n\tsensor->gain = gain;\n\n\treturn 0;\n}\n\nstatic int\nst_lsm6dsx_shub_write_raw(struct iio_dev *iio_dev,\n\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t  int val, int val2, long mask)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\n\tint err;\n\n\terr = iio_device_claim_direct_mode(iio_dev);\n\tif (err)\n\t\treturn err;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ: {\n\t\tu16 data;\n\n\t\tval = val * 1000 + val2 / 1000;\n\t\terr = st_lsm6dsx_shub_get_odr_val(sensor, val, &data);\n\t\tif (!err) {\n\t\t\tstruct st_lsm6dsx_hw *hw = sensor->hw;\n\t\t\tstruct st_lsm6dsx_sensor *ref_sensor;\n\t\t\tu8 odr_val;\n\t\t\tint odr;\n\n\t\t\tref_sensor = iio_priv(hw->iio_devs[ST_LSM6DSX_ID_ACC]);\n\t\t\todr = st_lsm6dsx_check_odr(ref_sensor, val, &odr_val);\n\t\t\tif (odr < 0) {\n\t\t\t\terr = odr;\n\t\t\t\tgoto release;\n\t\t\t}\n\n\t\t\tsensor->ext_info.slv_odr = val;\n\t\t\tsensor->odr = odr;\n\t\t}\n\t\tbreak;\n\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\terr = st_lsm6dsx_shub_set_full_scale(sensor, val2);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\nrelease:\n\tiio_device_release_direct_mode(iio_dev);\n\n\treturn err;\n}\n\nstatic ssize_t\nst_lsm6dsx_shub_sampling_freq_avail(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(dev_get_drvdata(dev));\n\tconst struct st_lsm6dsx_ext_dev_settings *settings;\n\tint i, len = 0;\n\n\tsettings = sensor->ext_info.settings;\n\tfor (i = 0; i < settings->odr_table.odr_len; i++) {\n\t\tu32 val = settings->odr_table.odr_avl[i].milli_hz;\n\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d.%03d \",\n\t\t\t\t val / 1000, val % 1000);\n\t}\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t st_lsm6dsx_shub_scale_avail(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct st_lsm6dsx_sensor *sensor = iio_priv(dev_get_drvdata(dev));\n\tconst struct st_lsm6dsx_ext_dev_settings *settings;\n\tint i, len = 0;\n\n\tsettings = sensor->ext_info.settings;\n\tfor (i = 0; i < settings->fs_table.fs_len; i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"0.%06u \",\n\t\t\t\t settings->fs_table.fs_avl[i].gain);\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic IIO_DEV_ATTR_SAMP_FREQ_AVAIL(st_lsm6dsx_shub_sampling_freq_avail);\nstatic IIO_DEVICE_ATTR(in_scale_available, 0444,\n\t\t       st_lsm6dsx_shub_scale_avail, NULL, 0);\nstatic struct attribute *st_lsm6dsx_shub_attributes[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_in_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group st_lsm6dsx_shub_attribute_group = {\n\t.attrs = st_lsm6dsx_shub_attributes,\n};\n\nstatic const struct iio_info st_lsm6dsx_shub_info = {\n\t.attrs = &st_lsm6dsx_shub_attribute_group,\n\t.read_raw = st_lsm6dsx_shub_read_raw,\n\t.write_raw = st_lsm6dsx_shub_write_raw,\n\t.hwfifo_set_watermark = st_lsm6dsx_set_watermark,\n};\n\nstatic struct iio_dev *\nst_lsm6dsx_shub_alloc_iiodev(struct st_lsm6dsx_hw *hw,\n\t\t\t     enum st_lsm6dsx_sensor_id id,\n\t\t\t     const struct st_lsm6dsx_ext_dev_settings *info,\n\t\t\t     u8 i2c_addr, const char *name)\n{\n\tenum st_lsm6dsx_sensor_id ref_id = ST_LSM6DSX_ID_ACC;\n\tstruct iio_chan_spec *ext_channels;\n\tstruct st_lsm6dsx_sensor *sensor;\n\tstruct iio_dev *iio_dev;\n\n\tiio_dev = devm_iio_device_alloc(hw->dev, sizeof(*sensor));\n\tif (!iio_dev)\n\t\treturn NULL;\n\n\tiio_dev->modes = INDIO_DIRECT_MODE;\n\tiio_dev->info = &st_lsm6dsx_shub_info;\n\n\tsensor = iio_priv(iio_dev);\n\tsensor->id = id;\n\tsensor->hw = hw;\n\tsensor->odr = hw->settings->odr_table[ref_id].odr_avl[0].milli_hz;\n\tsensor->ext_info.slv_odr = info->odr_table.odr_avl[0].milli_hz;\n\tsensor->gain = info->fs_table.fs_avl[0].gain;\n\tsensor->ext_info.settings = info;\n\tsensor->ext_info.addr = i2c_addr;\n\tsensor->watermark = 1;\n\n\tswitch (info->id) {\n\tcase ST_LSM6DSX_ID_MAGN: {\n\t\tconst struct iio_chan_spec magn_channels[] = {\n\t\t\tST_LSM6DSX_CHANNEL(IIO_MAGN, info->out.addr,\n\t\t\t\t\t   IIO_MOD_X, 0),\n\t\t\tST_LSM6DSX_CHANNEL(IIO_MAGN, info->out.addr + 2,\n\t\t\t\t\t   IIO_MOD_Y, 1),\n\t\t\tST_LSM6DSX_CHANNEL(IIO_MAGN, info->out.addr + 4,\n\t\t\t\t\t   IIO_MOD_Z, 2),\n\t\t\tIIO_CHAN_SOFT_TIMESTAMP(3),\n\t\t};\n\n\t\text_channels = devm_kzalloc(hw->dev, sizeof(magn_channels),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!ext_channels)\n\t\t\treturn NULL;\n\n\t\tmemcpy(ext_channels, magn_channels, sizeof(magn_channels));\n\t\tiio_dev->available_scan_masks = st_lsm6dsx_available_scan_masks;\n\t\tiio_dev->channels = ext_channels;\n\t\tiio_dev->num_channels = ARRAY_SIZE(magn_channels);\n\n\t\tscnprintf(sensor->name, sizeof(sensor->name), \"%s_magn\",\n\t\t\t  name);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn NULL;\n\t}\n\tiio_dev->name = sensor->name;\n\n\treturn iio_dev;\n}\n\nstatic int st_lsm6dsx_shub_init_device(struct st_lsm6dsx_sensor *sensor)\n{\n\tconst struct st_lsm6dsx_ext_dev_settings *settings;\n\tint err;\n\n\tsettings = sensor->ext_info.settings;\n\tif (settings->bdu.addr) {\n\t\terr = st_lsm6dsx_shub_write_with_mask(sensor,\n\t\t\t\t\t\t      settings->bdu.addr,\n\t\t\t\t\t\t      settings->bdu.mask, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (settings->temp_comp.addr) {\n\t\terr = st_lsm6dsx_shub_write_with_mask(sensor,\n\t\t\t\t\tsettings->temp_comp.addr,\n\t\t\t\t\tsettings->temp_comp.mask, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (settings->off_canc.addr) {\n\t\terr = st_lsm6dsx_shub_write_with_mask(sensor,\n\t\t\t\t\tsettings->off_canc.addr,\n\t\t\t\t\tsettings->off_canc.mask, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nst_lsm6dsx_shub_check_wai(struct st_lsm6dsx_hw *hw, u8 *i2c_addr,\n\t\t\t  const struct st_lsm6dsx_ext_dev_settings *settings)\n{\n\tconst struct st_lsm6dsx_shub_settings *hub_settings;\n\tu8 config[3], data, slv_addr, slv_config = 0;\n\tconst struct st_lsm6dsx_reg *aux_sens;\n\tstruct st_lsm6dsx_sensor *sensor;\n\tbool found = false;\n\tint i, err;\n\n\tsensor = iio_priv(hw->iio_devs[ST_LSM6DSX_ID_ACC]);\n\thub_settings = &hw->settings->shub_settings;\n\taux_sens = &hw->settings->shub_settings.aux_sens;\n\tslv_addr = ST_LSM6DSX_SLV_ADDR(0, hub_settings->slv0_addr);\n\t \n\tif (slv_addr + 2 == aux_sens->addr)\n\t\tslv_config = ST_LSM6DSX_SHIFT_VAL(3, aux_sens->mask);\n\n\tfor (i = 0; i < ARRAY_SIZE(settings->i2c_addr); i++) {\n\t\tif (!settings->i2c_addr[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tconfig[0] = (settings->i2c_addr[i] << 1) | 0x1;\n\t\tconfig[1] = settings->wai.addr;\n\t\tconfig[2] = 0x1 | slv_config;\n\n\t\terr = st_lsm6dsx_shub_write_reg(hw, slv_addr, config,\n\t\t\t\t\t\tsizeof(config));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = st_lsm6dsx_shub_master_enable(sensor, true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tst_lsm6dsx_shub_wait_complete(hw);\n\n\t\terr = st_lsm6dsx_shub_read_output(hw, &data, sizeof(data));\n\n\t\tst_lsm6dsx_shub_master_enable(sensor, false);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (data != settings->wai.val)\n\t\t\tcontinue;\n\n\t\t*i2c_addr = settings->i2c_addr[i];\n\t\tfound = true;\n\t\tbreak;\n\t}\n\n\t \n\tconfig[0] = hub_settings->pause;\n\tconfig[1] = 0;\n\tconfig[2] = slv_config;\n\terr = st_lsm6dsx_shub_write_reg(hw, slv_addr, config,\n\t\t\t\t\tsizeof(config));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn found ? 0 : -ENODEV;\n}\n\nint st_lsm6dsx_shub_probe(struct st_lsm6dsx_hw *hw, const char *name)\n{\n\tenum st_lsm6dsx_sensor_id id = ST_LSM6DSX_ID_EXT0;\n\tstruct st_lsm6dsx_sensor *sensor;\n\tint err, i, num_ext_dev = 0;\n\tu8 i2c_addr = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(st_lsm6dsx_ext_dev_table); i++) {\n\t\terr = st_lsm6dsx_shub_check_wai(hw, &i2c_addr,\n\t\t\t\t\t&st_lsm6dsx_ext_dev_table[i]);\n\t\tif (err == -ENODEV)\n\t\t\tcontinue;\n\t\telse if (err < 0)\n\t\t\treturn err;\n\n\t\thw->iio_devs[id] = st_lsm6dsx_shub_alloc_iiodev(hw, id,\n\t\t\t\t\t\t&st_lsm6dsx_ext_dev_table[i],\n\t\t\t\t\t\ti2c_addr, name);\n\t\tif (!hw->iio_devs[id])\n\t\t\treturn -ENOMEM;\n\n\t\tsensor = iio_priv(hw->iio_devs[id]);\n\t\terr = st_lsm6dsx_shub_init_device(sensor);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (++num_ext_dev >= hw->settings->shub_settings.num_ext_dev)\n\t\t\tbreak;\n\t\tid++;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}