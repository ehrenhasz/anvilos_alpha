{
  "module_name": "bno055_ser_core.c",
  "hash_id": "fda03a2178d84c54fc91e5c7171bd856bab36cabf689cac323781b28e9e29f55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/bno055/bno055_ser_core.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/serdev.h>\n\n#include \"bno055_ser_trace.h\"\n#include \"bno055.h\"\n\n \n\n \n#define BNO055_SER_XFER_BURST_BREAK_THRESHOLD 22\n\nstruct bno055_ser_priv {\n\tenum {\n\t\tCMD_NONE,\n\t\tCMD_READ,\n\t\tCMD_WRITE,\n\t} expect_response;\n\tint expected_data_len;\n\tu8 *response_buf;\n\n\t \n\tenum {\n\t\tSTATUS_CRIT = -1,\n\t\tSTATUS_OK = 0,\n\t\tSTATUS_FAIL = 1,\n\t} cmd_status;\n\n\t \n\tstruct mutex lock;\n\n\t \n\tstruct {\n\t\tenum {\n\t\t\tRX_IDLE,\n\t\t\tRX_START,\n\t\t\tRX_DATA,\n\t\t} state;\n\t\tint databuf_count;\n\t\tint expected_len;\n\t\tint type;\n\t} rx;\n\n\t \n\tbool cmd_stale;\n\n\tstruct completion cmd_complete;\n\tstruct serdev_device *serdev;\n};\n\nstatic int bno055_ser_send_chunk(struct bno055_ser_priv *priv, const u8 *data, int len)\n{\n\tint ret;\n\n\ttrace_send_chunk(len, data);\n\tret = serdev_device_write(priv->serdev, data, len, msecs_to_jiffies(25));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret < len)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int bno055_ser_do_send_cmd(struct bno055_ser_priv *priv,\n\t\t\t\t  bool read, int addr, int len, const u8 *data)\n{\n\tu8 hdr[] = {0xAA, read, addr, len};\n\tint chunk_len;\n\tint ret;\n\n\tret = bno055_ser_send_chunk(priv, hdr, 2);\n\tif (ret)\n\t\tgoto fail;\n\tusleep_range(2000, 3000);\n\tret = bno055_ser_send_chunk(priv, hdr + 2, 2);\n\tif (ret)\n\t\tgoto fail;\n\n\tif (read)\n\t\treturn 0;\n\n\twhile (len) {\n\t\tchunk_len = min(len, 2);\n\t\tusleep_range(2000, 3000);\n\t\tret = bno055_ser_send_chunk(priv, data, chunk_len);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\tdata += chunk_len;\n\t\tlen -= chunk_len;\n\t}\n\n\treturn 0;\nfail:\n\t \n\tusleep_range(40000, 50000);\n\treturn ret;\n}\n\nstatic int bno055_ser_send_cmd(struct bno055_ser_priv *priv,\n\t\t\t       bool read, int addr, int len, const u8 *data)\n{\n\tconst int retry_max = 5;\n\tint retry = retry_max;\n\tint ret = 0;\n\n\t \n\tif (priv->cmd_stale) {\n\t\tret = wait_for_completion_interruptible_timeout(&priv->cmd_complete,\n\t\t\t\t\t\t\t\tmsecs_to_jiffies(100));\n\t\tif (ret == -ERESTARTSYS)\n\t\t\treturn -ERESTARTSYS;\n\n\t\tpriv->cmd_stale = false;\n\t\t \n\t\tif (priv->cmd_status == STATUS_CRIT)\n\t\t\treturn -EIO;\n\t}\n\n\t \n\tdo {\n\t\tmutex_lock(&priv->lock);\n\t\tpriv->expect_response = read ? CMD_READ : CMD_WRITE;\n\t\treinit_completion(&priv->cmd_complete);\n\t\tmutex_unlock(&priv->lock);\n\n\t\tif (retry != retry_max)\n\t\t\ttrace_cmd_retry(read, addr, retry_max - retry);\n\t\tret = bno055_ser_do_send_cmd(priv, read, addr, len, data);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tret = wait_for_completion_interruptible_timeout(&priv->cmd_complete,\n\t\t\t\t\t\t\t\tmsecs_to_jiffies(100));\n\t\tif (ret == -ERESTARTSYS) {\n\t\t\tpriv->cmd_stale = true;\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\n\t\tif (!ret)\n\t\t\treturn -ETIMEDOUT;\n\n\t\tif (priv->cmd_status == STATUS_OK)\n\t\t\treturn 0;\n\t\tif (priv->cmd_status == STATUS_CRIT)\n\t\t\treturn -EIO;\n\n\t\t \n\t} while (--retry);\n\n\tif (ret < 0)\n\t\treturn ret;\n\tif (priv->cmd_status == STATUS_FAIL)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int bno055_ser_write_reg(void *context, const void *_data, size_t count)\n{\n\tconst u8 *data = _data;\n\tstruct bno055_ser_priv *priv = context;\n\n\tif (count < 2) {\n\t\tdev_err(&priv->serdev->dev, \"Invalid write count %zu\", count);\n\t\treturn -EINVAL;\n\t}\n\n\ttrace_write_reg(data[0], data[1]);\n\treturn bno055_ser_send_cmd(priv, 0, data[0], count - 1, data + 1);\n}\n\nstatic int bno055_ser_read_reg(void *context,\n\t\t\t       const void *_reg, size_t reg_size,\n\t\t\t       void *val, size_t val_size)\n{\n\tint ret;\n\tint reg_addr;\n\tconst u8 *reg = _reg;\n\tstruct bno055_ser_priv *priv = context;\n\n\tif (val_size > 128) {\n\t\tdev_err(&priv->serdev->dev, \"Invalid read valsize %zu\", val_size);\n\t\treturn -EINVAL;\n\t}\n\n\treg_addr = *reg;\n\ttrace_read_reg(reg_addr, val_size);\n\tmutex_lock(&priv->lock);\n\tpriv->expected_data_len = val_size;\n\tpriv->response_buf = val;\n\tmutex_unlock(&priv->lock);\n\n\tret = bno055_ser_send_cmd(priv, 1, reg_addr, val_size, NULL);\n\n\tmutex_lock(&priv->lock);\n\tpriv->response_buf = NULL;\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\n \nstatic void bno055_ser_handle_rx(struct bno055_ser_priv *priv, int status)\n{\n\tmutex_lock(&priv->lock);\n\tswitch (priv->expect_response) {\n\tcase CMD_NONE:\n\t\tdev_warn(&priv->serdev->dev, \"received unexpected, yet valid, data from sensor\");\n\t\tmutex_unlock(&priv->lock);\n\t\treturn;\n\n\tcase CMD_READ:\n\t\tpriv->cmd_status = status;\n\t\tif (status == STATUS_OK &&\n\t\t    priv->rx.databuf_count != priv->expected_data_len) {\n\t\t\t \n\t\t\tpriv->cmd_status = STATUS_FAIL;\n\t\t\tdev_warn(&priv->serdev->dev,\n\t\t\t\t \"received an unexpected amount of, yet valid, data from sensor\");\n\t\t}\n\t\tbreak;\n\n\tcase CMD_WRITE:\n\t\tpriv->cmd_status = status;\n\t\tbreak;\n\t}\n\n\tpriv->expect_response = CMD_NONE;\n\tmutex_unlock(&priv->lock);\n\tcomplete(&priv->cmd_complete);\n}\n\n \nstatic int bno055_ser_receive_buf(struct serdev_device *serdev,\n\t\t\t\t  const unsigned char *buf, size_t size)\n{\n\tint status;\n\tstruct bno055_ser_priv *priv = serdev_device_get_drvdata(serdev);\n\tint remaining = size;\n\n\tif (size == 0)\n\t\treturn 0;\n\n\ttrace_recv(size, buf);\n\tswitch (priv->rx.state) {\n\tcase RX_IDLE:\n\t\t \n\t\tif (buf[0] != 0xEE && buf[0] != 0xBB) {\n\t\t\tdev_err(&priv->serdev->dev,\n\t\t\t\t\"Invalid packet start %x\", buf[0]);\n\t\t\tbno055_ser_handle_rx(priv, STATUS_CRIT);\n\t\t\tbreak;\n\t\t}\n\t\tpriv->rx.type = buf[0];\n\t\tpriv->rx.state = RX_START;\n\t\tremaining--;\n\t\tbuf++;\n\t\tpriv->rx.databuf_count = 0;\n\t\tfallthrough;\n\n\tcase RX_START:\n\t\t \n\t\tif (remaining == 0)\n\t\t\tbreak;\n\n\t\tif (priv->rx.type == 0xEE) {\n\t\t\tif (remaining > 1) {\n\t\t\t\tdev_err(&priv->serdev->dev, \"EE pkt. Extra data received\");\n\t\t\t\tstatus = STATUS_CRIT;\n\t\t\t} else {\n\t\t\t\tstatus = (buf[0] == 1) ? STATUS_OK : STATUS_FAIL;\n\t\t\t}\n\t\t\tbno055_ser_handle_rx(priv, status);\n\t\t\tpriv->rx.state = RX_IDLE;\n\t\t\tbreak;\n\n\t\t} else {\n\t\t\t \n\t\t\tpriv->rx.state = RX_DATA;\n\t\t\tpriv->rx.expected_len = buf[0];\n\t\t\tremaining--;\n\t\t\tbuf++;\n\t\t}\n\t\tfallthrough;\n\n\tcase RX_DATA:\n\t\t \n\t\tif (remaining == 0)\n\t\t\tbreak;\n\n\t\tif (priv->rx.databuf_count + remaining > priv->rx.expected_len) {\n\t\t\t \n\t\t\tdev_err(&priv->serdev->dev, \"BB pkt. Extra data received\");\n\t\t\tbno055_ser_handle_rx(priv, STATUS_CRIT);\n\t\t\tpriv->rx.state = RX_IDLE;\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&priv->lock);\n\t\t \n\t\tif (priv->response_buf &&\n\t\t     \n\t\t    (priv->rx.databuf_count + remaining <= priv->expected_data_len))\n\t\t\tmemcpy(priv->response_buf + priv->rx.databuf_count,\n\t\t\t       buf, remaining);\n\t\tmutex_unlock(&priv->lock);\n\n\t\tpriv->rx.databuf_count += remaining;\n\n\t\t \n\t\tif (priv->rx.databuf_count == priv->rx.expected_len) {\n\t\t\tbno055_ser_handle_rx(priv, STATUS_OK);\n\t\t\tpriv->rx.state = RX_IDLE;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn size;\n}\n\nstatic const struct serdev_device_ops bno055_ser_serdev_ops = {\n\t.receive_buf = bno055_ser_receive_buf,\n\t.write_wakeup = serdev_device_write_wakeup,\n};\n\nstatic struct regmap_bus bno055_ser_regmap_bus = {\n\t.write = bno055_ser_write_reg,\n\t.read = bno055_ser_read_reg,\n};\n\nstatic int bno055_ser_probe(struct serdev_device *serdev)\n{\n\tstruct bno055_ser_priv *priv;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tpriv = devm_kzalloc(&serdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tserdev_device_set_drvdata(serdev, priv);\n\tpriv->serdev = serdev;\n\tmutex_init(&priv->lock);\n\tinit_completion(&priv->cmd_complete);\n\n\tserdev_device_set_client_ops(serdev, &bno055_ser_serdev_ops);\n\tret = devm_serdev_device_open(&serdev->dev, serdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (serdev_device_set_baudrate(serdev, 115200) != 115200) {\n\t\tdev_err(&serdev->dev, \"Cannot set required baud rate\");\n\t\treturn -EIO;\n\t}\n\n\tret = serdev_device_set_parity(serdev, SERDEV_PARITY_NONE);\n\tif (ret) {\n\t\tdev_err(&serdev->dev, \"Cannot set required parity setting\");\n\t\treturn ret;\n\t}\n\tserdev_device_set_flow_control(serdev, false);\n\n\tregmap = devm_regmap_init(&serdev->dev, &bno055_ser_regmap_bus,\n\t\t\t\t  priv, &bno055_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(&serdev->dev, PTR_ERR(regmap),\n\t\t\t\t     \"Unable to init register map\");\n\n\treturn bno055_probe(&serdev->dev, regmap,\n\t\t\t    BNO055_SER_XFER_BURST_BREAK_THRESHOLD, false);\n}\n\nstatic const struct of_device_id bno055_ser_of_match[] = {\n\t{ .compatible = \"bosch,bno055\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, bno055_ser_of_match);\n\nstatic struct serdev_device_driver bno055_ser_driver = {\n\t.driver = {\n\t\t.name = \"bno055-ser\",\n\t\t.of_match_table = bno055_ser_of_match,\n\t},\n\t.probe = bno055_ser_probe,\n};\nmodule_serdev_device_driver(bno055_ser_driver);\n\nMODULE_AUTHOR(\"Andrea Merello <andrea.merello@iit.it>\");\nMODULE_DESCRIPTION(\"Bosch BNO055 serdev interface\");\nMODULE_IMPORT_NS(IIO_BNO055);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}