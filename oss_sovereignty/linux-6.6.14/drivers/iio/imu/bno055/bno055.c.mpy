{
  "module_name": "bno055.c",
  "hash_id": "ed9d3834530e132fa419042390f3c349f8480839e5179c483c26369208c86eb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/imu/bno055/bno055.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitmap.h>\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/util_macros.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#include \"bno055.h\"\n\n#define BNO055_FW_UID_FMT \"bno055-caldata-%*phN.dat\"\n#define BNO055_FW_GENERIC_NAME \"bno055-caldata.dat\"\n\n \n#define BNO055_PAGESEL_REG\t\t0x7\n\n \n#define BNO055_CHIP_ID_REG\t\t0x0\n#define BNO055_CHIP_ID_MAGIC 0xA0\n#define BNO055_SW_REV_LSB_REG\t\t0x4\n#define BNO055_SW_REV_MSB_REG\t\t0x5\n#define BNO055_ACC_DATA_X_LSB_REG\t0x8\n#define BNO055_ACC_DATA_Y_LSB_REG\t0xA\n#define BNO055_ACC_DATA_Z_LSB_REG\t0xC\n#define BNO055_MAG_DATA_X_LSB_REG\t0xE\n#define BNO055_MAG_DATA_Y_LSB_REG\t0x10\n#define BNO055_MAG_DATA_Z_LSB_REG\t0x12\n#define BNO055_GYR_DATA_X_LSB_REG\t0x14\n#define BNO055_GYR_DATA_Y_LSB_REG\t0x16\n#define BNO055_GYR_DATA_Z_LSB_REG\t0x18\n#define BNO055_EUL_DATA_X_LSB_REG\t0x1A\n#define BNO055_EUL_DATA_Y_LSB_REG\t0x1C\n#define BNO055_EUL_DATA_Z_LSB_REG\t0x1E\n#define BNO055_QUAT_DATA_W_LSB_REG\t0x20\n#define BNO055_LIA_DATA_X_LSB_REG\t0x28\n#define BNO055_LIA_DATA_Y_LSB_REG\t0x2A\n#define BNO055_LIA_DATA_Z_LSB_REG\t0x2C\n#define BNO055_GRAVITY_DATA_X_LSB_REG\t0x2E\n#define BNO055_GRAVITY_DATA_Y_LSB_REG\t0x30\n#define BNO055_GRAVITY_DATA_Z_LSB_REG\t0x32\n#define BNO055_SCAN_CH_COUNT ((BNO055_GRAVITY_DATA_Z_LSB_REG - BNO055_ACC_DATA_X_LSB_REG) / 2)\n#define BNO055_TEMP_REG\t\t\t0x34\n#define BNO055_CALIB_STAT_REG\t\t0x35\n#define BNO055_CALIB_STAT_MAGN_SHIFT 0\n#define BNO055_CALIB_STAT_ACCEL_SHIFT 2\n#define BNO055_CALIB_STAT_GYRO_SHIFT 4\n#define BNO055_CALIB_STAT_SYS_SHIFT 6\n#define BNO055_SYS_ERR_REG\t\t0x3A\n#define BNO055_POWER_MODE_REG\t\t0x3E\n#define BNO055_POWER_MODE_NORMAL 0\n#define BNO055_SYS_TRIGGER_REG\t\t0x3F\n#define BNO055_SYS_TRIGGER_RST_SYS BIT(5)\n#define BNO055_SYS_TRIGGER_CLK_SEL BIT(7)\n#define BNO055_OPR_MODE_REG\t\t0x3D\n#define BNO055_OPR_MODE_CONFIG 0x0\n#define BNO055_OPR_MODE_AMG 0x7\n#define BNO055_OPR_MODE_FUSION_FMC_OFF 0xB\n#define BNO055_OPR_MODE_FUSION 0xC\n#define BNO055_UNIT_SEL_REG\t\t0x3B\n \n#define BNO055_UNIT_SEL_ANDROID BIT(7)\n#define BNO055_UNIT_SEL_GYR_RPS BIT(1)\n#define BNO055_CALDATA_START\t\t0x55\n#define BNO055_CALDATA_END\t\t0x6A\n#define BNO055_CALDATA_LEN 22\n\n \n#define BNO055_REG_OFFSET_ADDR\t\t0x4D\n\n \n#define BNO055_PG1(x) ((x) | 0x80)\n#define BNO055_ACC_CONFIG_REG\t\tBNO055_PG1(0x8)\n#define BNO055_ACC_CONFIG_LPF_MASK GENMASK(4, 2)\n#define BNO055_ACC_CONFIG_RANGE_MASK GENMASK(1, 0)\n#define BNO055_MAG_CONFIG_REG\t\tBNO055_PG1(0x9)\n#define BNO055_MAG_CONFIG_HIGHACCURACY 0x18\n#define BNO055_MAG_CONFIG_ODR_MASK GENMASK(2, 0)\n#define BNO055_GYR_CONFIG_REG\t\tBNO055_PG1(0xA)\n#define BNO055_GYR_CONFIG_RANGE_MASK GENMASK(2, 0)\n#define BNO055_GYR_CONFIG_LPF_MASK GENMASK(5, 3)\n#define BNO055_GYR_AM_SET_REG\t\tBNO055_PG1(0x1F)\n#define BNO055_UID_LOWER_REG\t\tBNO055_PG1(0x50)\n#define BNO055_UID_HIGHER_REG\t\tBNO055_PG1(0x5F)\n#define BNO055_UID_LEN 16\n\nstruct bno055_sysfs_attr {\n\tint *vals;\n\tint len;\n\tint *fusion_vals;\n\tint *hw_xlate;\n\tint type;\n};\n\nstatic int bno055_acc_lpf_vals[] = {\n\t7, 810000, 15, 630000, 31, 250000, 62, 500000,\n\t125, 0, 250, 0, 500, 0, 1000, 0,\n};\n\nstatic struct bno055_sysfs_attr bno055_acc_lpf = {\n\t.vals = bno055_acc_lpf_vals,\n\t.len = ARRAY_SIZE(bno055_acc_lpf_vals),\n\t.fusion_vals = (int[]){62, 500000},\n\t.type = IIO_VAL_INT_PLUS_MICRO,\n};\n\nstatic int bno055_acc_range_vals[] = {\n   \n\t1962, 3924, 7848, 15696\n};\n\nstatic struct bno055_sysfs_attr bno055_acc_range = {\n\t.vals = bno055_acc_range_vals,\n\t.len = ARRAY_SIZE(bno055_acc_range_vals),\n\t.fusion_vals = (int[]){3924},  \n\t.type = IIO_VAL_INT,\n};\n\n \n\n \nstatic int bno055_gyr_scale_vals[] = {\n\t125, 1877467, 250, 1877467, 500, 1877467,\n\t1000, 1877467, 2000, 1877467,\n};\n\nstatic struct bno055_sysfs_attr bno055_gyr_scale = {\n\t.vals = bno055_gyr_scale_vals,\n\t.len = ARRAY_SIZE(bno055_gyr_scale_vals),\n\t.fusion_vals = (int[]){1, 900},\n\t.hw_xlate = (int[]){4, 3, 2, 1, 0},\n\t.type = IIO_VAL_FRACTIONAL,\n};\n\nstatic int bno055_gyr_lpf_vals[] = {12, 23, 32, 47, 64, 116, 230, 523};\nstatic struct bno055_sysfs_attr bno055_gyr_lpf = {\n\t.vals = bno055_gyr_lpf_vals,\n\t.len = ARRAY_SIZE(bno055_gyr_lpf_vals),\n\t.fusion_vals = (int[]){32},\n\t.hw_xlate = (int[]){5, 4, 7, 3, 6, 2, 1, 0},\n\t.type = IIO_VAL_INT,\n};\n\nstatic int bno055_mag_odr_vals[] = {2, 6, 8, 10, 15, 20, 25, 30};\nstatic struct bno055_sysfs_attr bno055_mag_odr = {\n\t.vals = bno055_mag_odr_vals,\n\t.len =  ARRAY_SIZE(bno055_mag_odr_vals),\n\t.fusion_vals = (int[]){20},\n\t.type = IIO_VAL_INT,\n};\n\nstruct bno055_priv {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tstruct clk *clk;\n\tint operation_mode;\n\tint xfer_burst_break_thr;\n\tstruct mutex lock;\n\tu8 uid[BNO055_UID_LEN];\n\tstruct gpio_desc *reset_gpio;\n\tbool sw_reset;\n\tstruct {\n\t\t__le16 chans[BNO055_SCAN_CH_COUNT];\n\t\ts64 timestamp __aligned(8);\n\t} buf;\n\tstruct dentry *debugfs;\n};\n\nstatic bool bno055_regmap_volatile(struct device *dev, unsigned int reg)\n{\n\t \n\tif (reg >= BNO055_ACC_DATA_X_LSB_REG && reg <= BNO055_SYS_ERR_REG)\n\t\treturn true;\n\n\t \n\tif (reg == BNO055_MAG_CONFIG_REG ||\n\t    reg == BNO055_ACC_CONFIG_REG ||\n\t    reg == BNO055_GYR_CONFIG_REG)\n\t\treturn true;\n\n\t \n\tif (reg >= BNO055_CALDATA_START && reg <= BNO055_CALDATA_END)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool bno055_regmap_readable(struct device *dev, unsigned int reg)\n{\n\t \n\tif ((reg < BNO055_PG1(0) && reg > BNO055_CALDATA_END) ||\n\t    reg == 0x3C)\n\t\treturn false;\n\n\t \n\tif (reg > BNO055_PG1(BNO055_UID_HIGHER_REG) ||\n\t    (reg < BNO055_PG1(BNO055_UID_LOWER_REG) && reg > BNO055_PG1(BNO055_GYR_AM_SET_REG)) ||\n\t    reg == BNO055_PG1(0xE) ||\n\t    (reg < BNO055_PG1(BNO055_PAGESEL_REG) && reg >= BNO055_PG1(0x0)))\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool bno055_regmap_writeable(struct device *dev, unsigned int reg)\n{\n\t \n\tif (!bno055_regmap_readable(dev, reg))\n\t\treturn false;\n\n\t \n\tif (reg >= BNO055_ACC_DATA_X_LSB_REG && reg <= BNO055_SYS_ERR_REG)\n\t\treturn false;\n\n\t \n\tif (reg < BNO055_PAGESEL_REG ||\n\t    (reg <= BNO055_UID_HIGHER_REG && reg >= BNO055_UID_LOWER_REG))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic const struct regmap_range_cfg bno055_regmap_ranges[] = {\n\t{\n\t\t.range_min = 0,\n\t\t.range_max = 0x7f * 2,\n\t\t.selector_reg = BNO055_PAGESEL_REG,\n\t\t.selector_mask = GENMASK(7, 0),\n\t\t.selector_shift = 0,\n\t\t.window_start = 0,\n\t\t.window_len = 0x80,\n\t},\n};\n\nconst struct regmap_config bno055_regmap_config = {\n\t.name = \"bno055\",\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.ranges = bno055_regmap_ranges,\n\t.num_ranges = 1,\n\t.volatile_reg = bno055_regmap_volatile,\n\t.max_register = 0x80 * 2,\n\t.writeable_reg = bno055_regmap_writeable,\n\t.readable_reg = bno055_regmap_readable,\n\t.cache_type = REGCACHE_RBTREE,\n};\nEXPORT_SYMBOL_NS_GPL(bno055_regmap_config, IIO_BNO055);\n\n \nstatic int bno055_calibration_load(struct bno055_priv *priv, const u8 *data, int len)\n{\n\tif (len != BNO055_CALDATA_LEN) {\n\t\tdev_dbg(priv->dev, \"Invalid calibration file size %d (expected %d)\",\n\t\t\tlen, BNO055_CALDATA_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(priv->dev, \"loading cal data: %*ph\", BNO055_CALDATA_LEN, data);\n\treturn regmap_bulk_write(priv->regmap, BNO055_CALDATA_START,\n\t\t\t\t data, BNO055_CALDATA_LEN);\n}\n\nstatic int bno055_operation_mode_do_set(struct bno055_priv *priv,\n\t\t\t\t\tint operation_mode)\n{\n\tint ret;\n\n\tret = regmap_write(priv->regmap, BNO055_OPR_MODE_REG,\n\t\t\t   operation_mode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(20);\n\n\treturn 0;\n}\n\nstatic int bno055_system_reset(struct bno055_priv *priv)\n{\n\tint ret;\n\n\tif (priv->reset_gpio) {\n\t\tgpiod_set_value_cansleep(priv->reset_gpio, 0);\n\t\tusleep_range(5000, 10000);\n\t\tgpiod_set_value_cansleep(priv->reset_gpio, 1);\n\t} else if (priv->sw_reset) {\n\t\tret = regmap_write(priv->regmap, BNO055_SYS_TRIGGER_REG,\n\t\t\t\t   BNO055_SYS_TRIGGER_RST_SYS);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\treturn 0;\n\t}\n\n\tregcache_drop_region(priv->regmap, 0x0, 0xff);\n\tusleep_range(650000, 700000);\n\n\treturn 0;\n}\n\nstatic int bno055_init(struct bno055_priv *priv, const u8 *caldata, int len)\n{\n\tint ret;\n\n\tret = bno055_operation_mode_do_set(priv, BNO055_OPR_MODE_CONFIG);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(priv->regmap, BNO055_POWER_MODE_REG,\n\t\t\t   BNO055_POWER_MODE_NORMAL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(priv->regmap, BNO055_SYS_TRIGGER_REG,\n\t\t\t   priv->clk ? BNO055_SYS_TRIGGER_CLK_SEL : 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(priv->regmap, BNO055_UNIT_SEL_REG,\n\t\t\t   BNO055_UNIT_SEL_ANDROID | BNO055_UNIT_SEL_GYR_RPS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (caldata) {\n\t\tret = bno055_calibration_load(priv, caldata, len);\n\t\tif (ret)\n\t\t\tdev_warn(priv->dev, \"failed to load calibration data with error %d\\n\",\n\t\t\t\t ret);\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t bno055_operation_mode_set(struct bno055_priv *priv,\n\t\t\t\t\t int operation_mode)\n{\n\tu8 caldata[BNO055_CALDATA_LEN];\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\tret = bno055_operation_mode_do_set(priv, BNO055_OPR_MODE_CONFIG);\n\tif (ret)\n\t\tgoto exit_unlock;\n\n\tif (operation_mode == BNO055_OPR_MODE_FUSION ||\n\t    operation_mode == BNO055_OPR_MODE_FUSION_FMC_OFF) {\n\t\t \n\t\tret = regmap_bulk_read(priv->regmap, BNO055_CALDATA_START, caldata,\n\t\t\t\t       BNO055_CALDATA_LEN);\n\t\tif (ret)\n\t\t\tgoto exit_unlock;\n\n\t\tret = bno055_system_reset(priv);\n\t\tif (ret)\n\t\t\tgoto exit_unlock;\n\n\t\tret = bno055_init(priv, caldata, BNO055_CALDATA_LEN);\n\t\tif (ret)\n\t\t\tgoto exit_unlock;\n\t}\n\n\tret = bno055_operation_mode_do_set(priv, operation_mode);\n\tif (ret)\n\t\tgoto exit_unlock;\n\n\tpriv->operation_mode = operation_mode;\n\nexit_unlock:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic void bno055_uninit(void *arg)\n{\n\tstruct bno055_priv *priv = arg;\n\n\t \n\tbno055_operation_mode_do_set(priv, BNO055_OPR_MODE_CONFIG);\n}\n\n#define BNO055_CHANNEL(_type, _axis, _index, _address, _sep, _sh, _avail) {\t\\\n\t.address = _address,\t\t\t\t\t\t\t\\\n\t.type = _type,\t\t\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##_axis,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | (_sep),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | (_sh),\t\t\\\n\t.info_mask_shared_by_type_available = _avail,\t\t\t\t\\\n\t.scan_index = _index,\t\t\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\t\t\\\n\t\t.realbits = 16,\t\t\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\t\t\\\n\t\t.endianness = IIO_LE,\t\t\t\t\t\t\\\n\t\t.repeat = IIO_MOD_##_axis == IIO_MOD_QUATERNION ? 4 : 0,        \\\n\t},\t\t\t\t\t\t\t\t\t\\\n}\n\n \nenum bno055_scan_axis {\n\tBNO055_SCAN_ACCEL_X,\n\tBNO055_SCAN_ACCEL_Y,\n\tBNO055_SCAN_ACCEL_Z,\n\tBNO055_SCAN_MAGN_X,\n\tBNO055_SCAN_MAGN_Y,\n\tBNO055_SCAN_MAGN_Z,\n\tBNO055_SCAN_GYRO_X,\n\tBNO055_SCAN_GYRO_Y,\n\tBNO055_SCAN_GYRO_Z,\n\tBNO055_SCAN_YAW,\n\tBNO055_SCAN_ROLL,\n\tBNO055_SCAN_PITCH,\n\tBNO055_SCAN_QUATERNION,\n\tBNO055_SCAN_LIA_X,\n\tBNO055_SCAN_LIA_Y,\n\tBNO055_SCAN_LIA_Z,\n\tBNO055_SCAN_GRAVITY_X,\n\tBNO055_SCAN_GRAVITY_Y,\n\tBNO055_SCAN_GRAVITY_Z,\n\tBNO055_SCAN_TIMESTAMP,\n\t_BNO055_SCAN_MAX\n};\n\nstatic const struct iio_chan_spec bno055_channels[] = {\n\t \n\tBNO055_CHANNEL(IIO_ACCEL, X, BNO055_SCAN_ACCEL_X,\n\t\t       BNO055_ACC_DATA_X_LSB_REG, BIT(IIO_CHAN_INFO_OFFSET),\n\t\t       BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t\t       BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY)),\n\tBNO055_CHANNEL(IIO_ACCEL, Y, BNO055_SCAN_ACCEL_Y,\n\t\t       BNO055_ACC_DATA_Y_LSB_REG, BIT(IIO_CHAN_INFO_OFFSET),\n\t\t       BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t\t       BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY)),\n\tBNO055_CHANNEL(IIO_ACCEL, Z, BNO055_SCAN_ACCEL_Z,\n\t\t       BNO055_ACC_DATA_Z_LSB_REG, BIT(IIO_CHAN_INFO_OFFSET),\n\t\t       BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t\t       BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY)),\n\t \n\tBNO055_CHANNEL(IIO_ANGL_VEL, X, BNO055_SCAN_GYRO_X,\n\t\t       BNO055_GYR_DATA_X_LSB_REG, BIT(IIO_CHAN_INFO_OFFSET),\n\t\t       BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t\t       BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY) |\n\t\t       BIT(IIO_CHAN_INFO_SCALE)),\n\tBNO055_CHANNEL(IIO_ANGL_VEL, Y, BNO055_SCAN_GYRO_Y,\n\t\t       BNO055_GYR_DATA_Y_LSB_REG, BIT(IIO_CHAN_INFO_OFFSET),\n\t\t       BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t\t       BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY) |\n\t\t       BIT(IIO_CHAN_INFO_SCALE)),\n\tBNO055_CHANNEL(IIO_ANGL_VEL, Z, BNO055_SCAN_GYRO_Z,\n\t\t       BNO055_GYR_DATA_Z_LSB_REG, BIT(IIO_CHAN_INFO_OFFSET),\n\t\t       BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t\t       BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY) |\n\t\t       BIT(IIO_CHAN_INFO_SCALE)),\n\t \n\tBNO055_CHANNEL(IIO_MAGN, X, BNO055_SCAN_MAGN_X,\n\t\t       BNO055_MAG_DATA_X_LSB_REG, BIT(IIO_CHAN_INFO_OFFSET),\n\t\t       BIT(IIO_CHAN_INFO_SAMP_FREQ), BIT(IIO_CHAN_INFO_SAMP_FREQ)),\n\tBNO055_CHANNEL(IIO_MAGN, Y, BNO055_SCAN_MAGN_Y,\n\t\t       BNO055_MAG_DATA_Y_LSB_REG, BIT(IIO_CHAN_INFO_OFFSET),\n\t\t       BIT(IIO_CHAN_INFO_SAMP_FREQ), BIT(IIO_CHAN_INFO_SAMP_FREQ)),\n\tBNO055_CHANNEL(IIO_MAGN, Z, BNO055_SCAN_MAGN_Z,\n\t\t       BNO055_MAG_DATA_Z_LSB_REG, BIT(IIO_CHAN_INFO_OFFSET),\n\t\t       BIT(IIO_CHAN_INFO_SAMP_FREQ), BIT(IIO_CHAN_INFO_SAMP_FREQ)),\n\t \n\tBNO055_CHANNEL(IIO_ROT, YAW, BNO055_SCAN_YAW,\n\t\t       BNO055_EUL_DATA_X_LSB_REG, 0, 0, 0),\n\tBNO055_CHANNEL(IIO_ROT, ROLL, BNO055_SCAN_ROLL,\n\t\t       BNO055_EUL_DATA_Y_LSB_REG, 0, 0, 0),\n\tBNO055_CHANNEL(IIO_ROT, PITCH, BNO055_SCAN_PITCH,\n\t\t       BNO055_EUL_DATA_Z_LSB_REG, 0, 0, 0),\n\t \n\tBNO055_CHANNEL(IIO_ROT, QUATERNION, BNO055_SCAN_QUATERNION,\n\t\t       BNO055_QUAT_DATA_W_LSB_REG, 0, 0, 0),\n\n\t \n\tBNO055_CHANNEL(IIO_ACCEL, LINEAR_X, BNO055_SCAN_LIA_X,\n\t\t       BNO055_LIA_DATA_X_LSB_REG, 0, 0, 0),\n\tBNO055_CHANNEL(IIO_ACCEL, LINEAR_Y, BNO055_SCAN_LIA_Y,\n\t\t       BNO055_LIA_DATA_Y_LSB_REG, 0, 0, 0),\n\tBNO055_CHANNEL(IIO_ACCEL, LINEAR_Z, BNO055_SCAN_LIA_Z,\n\t\t       BNO055_LIA_DATA_Z_LSB_REG, 0, 0, 0),\n\n\t \n\tBNO055_CHANNEL(IIO_GRAVITY, X, BNO055_SCAN_GRAVITY_X,\n\t\t       BNO055_GRAVITY_DATA_X_LSB_REG, 0, 0, 0),\n\tBNO055_CHANNEL(IIO_GRAVITY, Y, BNO055_SCAN_GRAVITY_Y,\n\t\t       BNO055_GRAVITY_DATA_Y_LSB_REG, 0, 0, 0),\n\tBNO055_CHANNEL(IIO_GRAVITY, Z, BNO055_SCAN_GRAVITY_Z,\n\t\t       BNO055_GRAVITY_DATA_Z_LSB_REG, 0, 0, 0),\n\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.scan_index = -1,\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(BNO055_SCAN_TIMESTAMP),\n};\n\nstatic int bno055_get_regmask(struct bno055_priv *priv, int *val, int *val2,\n\t\t\t      int reg, int mask, struct bno055_sysfs_attr *attr)\n{\n\tconst int shift = __ffs(mask);\n\tint hwval, idx;\n\tint ret;\n\tint i;\n\n\tret = regmap_read(priv->regmap, reg, &hwval);\n\tif (ret)\n\t\treturn ret;\n\n\tidx = (hwval & mask) >> shift;\n\tif (attr->hw_xlate)\n\t\tfor (i = 0; i < attr->len; i++)\n\t\t\tif (attr->hw_xlate[i] == idx) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\tif (attr->type == IIO_VAL_INT) {\n\t\t*val = attr->vals[idx];\n\t} else {  \n\t\t*val = attr->vals[idx * 2];\n\t\t*val2 = attr->vals[idx * 2 + 1];\n\t}\n\n\treturn attr->type;\n}\n\nstatic int bno055_set_regmask(struct bno055_priv *priv, int val, int val2,\n\t\t\t      int reg, int mask, struct bno055_sysfs_attr *attr)\n{\n\tconst int shift = __ffs(mask);\n\tint best_delta;\n\tint req_val;\n\tint tbl_val;\n\tbool first;\n\tint delta;\n\tint hwval;\n\tint ret;\n\tint len;\n\tint i;\n\n\t \n\tif (priv->operation_mode != BNO055_OPR_MODE_AMG)\n\t\treturn 0;\n\n\tlen = attr->len;\n\n\t \n\treq_val = val;\n\tif (attr->type != IIO_VAL_INT) {\n\t\tlen /= 2;\n\t\treq_val = min(val, 2147) * 1000000 + val2;\n\t}\n\n\tfirst = true;\n\tfor (i = 0; i < len; i++) {\n\t\tswitch (attr->type) {\n\t\tcase IIO_VAL_INT:\n\t\t\ttbl_val = attr->vals[i];\n\t\t\tbreak;\n\t\tcase IIO_VAL_INT_PLUS_MICRO:\n\t\t\tWARN_ON(attr->vals[i * 2] > 2147);\n\t\t\ttbl_val = attr->vals[i * 2] * 1000000 +\n\t\t\t\tattr->vals[i * 2 + 1];\n\t\t\tbreak;\n\t\tcase IIO_VAL_FRACTIONAL:\n\t\t\tWARN_ON(attr->vals[i * 2] > 4294);\n\t\t\ttbl_val = attr->vals[i * 2] * 1000000 /\n\t\t\t\tattr->vals[i * 2 + 1];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdelta = abs(tbl_val - req_val);\n\t\tif (first || delta < best_delta) {\n\t\t\tbest_delta = delta;\n\t\t\thwval = i;\n\t\t\tfirst = false;\n\t\t}\n\t}\n\n\tif (attr->hw_xlate)\n\t\thwval = attr->hw_xlate[hwval];\n\n\tret = bno055_operation_mode_do_set(priv, BNO055_OPR_MODE_CONFIG);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(priv->regmap, reg, mask, hwval << shift);\n\tif (ret)\n\t\treturn ret;\n\n\treturn bno055_operation_mode_do_set(priv, BNO055_OPR_MODE_AMG);\n}\n\nstatic int bno055_read_simple_chan(struct iio_dev *indio_dev,\n\t\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct bno055_priv *priv = iio_priv(indio_dev);\n\t__le16 raw_val;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = regmap_bulk_read(priv->regmap, chan->address,\n\t\t\t\t       &raw_val, sizeof(raw_val));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = sign_extend32(le16_to_cpu(raw_val), 15);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (priv->operation_mode != BNO055_OPR_MODE_AMG) {\n\t\t\t*val = 0;\n\t\t} else {\n\t\t\tret = regmap_bulk_read(priv->regmap,\n\t\t\t\t\t       chan->address +\n\t\t\t\t\t       BNO055_REG_OFFSET_ADDR,\n\t\t\t\t\t       &raw_val, sizeof(raw_val));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t \n\t\t\t*val = -sign_extend32(le16_to_cpu(raw_val), 15);\n\t\t}\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 1;\n\t\tswitch (chan->type) {\n\t\tcase IIO_GRAVITY:\n\t\t\t \n\t\tcase IIO_ACCEL:\n\t\t\t \n\t\t\t*val2 = 100;\n\t\t\tbreak;\n\t\tcase IIO_MAGN:\n\t\t\t \n\t\t\t*val2 = 160;\n\t\t\tbreak;\n\t\tcase IIO_ANGL_VEL:\n\t\t\t \n\t\t\tif (priv->operation_mode != BNO055_OPR_MODE_AMG) {\n\t\t\t\t*val = bno055_gyr_scale.fusion_vals[0];\n\t\t\t\t*val2 = bno055_gyr_scale.fusion_vals[1];\n\t\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\t\t}\n\n\t\t\treturn bno055_get_regmask(priv, val, val2,\n\t\t\t\t\t\t  BNO055_GYR_CONFIG_REG,\n\t\t\t\t\t\t  BNO055_GYR_CONFIG_RANGE_MASK,\n\t\t\t\t\t\t  &bno055_gyr_scale);\n\t\t\tbreak;\n\t\tcase IIO_ROT:\n\t\t\t \n\t\t\t*val2 = 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn IIO_VAL_FRACTIONAL;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (chan->type != IIO_MAGN)\n\t\t\treturn -EINVAL;\n\n\t\treturn bno055_get_regmask(priv, val, val2,\n\t\t\t\t\t  BNO055_MAG_CONFIG_REG,\n\t\t\t\t\t  BNO055_MAG_CONFIG_ODR_MASK,\n\t\t\t\t\t  &bno055_mag_odr);\n\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\treturn bno055_get_regmask(priv, val, val2,\n\t\t\t\t\t\t  BNO055_GYR_CONFIG_REG,\n\t\t\t\t\t\t  BNO055_GYR_CONFIG_LPF_MASK,\n\t\t\t\t\t\t  &bno055_gyr_lpf);\n\t\tcase IIO_ACCEL:\n\t\t\treturn bno055_get_regmask(priv, val, val2,\n\t\t\t\t\t\t  BNO055_ACC_CONFIG_REG,\n\t\t\t\t\t\t  BNO055_ACC_CONFIG_LPF_MASK,\n\t\t\t\t\t\t  &bno055_acc_lpf);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bno055_sysfs_attr_avail(struct bno055_priv *priv, struct bno055_sysfs_attr *attr,\n\t\t\t\t   const int **vals, int *length)\n{\n\tif (priv->operation_mode != BNO055_OPR_MODE_AMG) {\n\t\t \n\t\t*vals = attr->fusion_vals;\n\t\tif (attr->type == IIO_VAL_INT)\n\t\t\t*length = 1;\n\t\telse\n\t\t\t*length = 2;  \n\t} else {\n\t\t*vals = attr->vals;\n\t\t*length = attr->len;\n\t}\n\n\treturn attr->type;\n}\n\nstatic int bno055_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type, int *length,\n\t\t\t     long mask)\n{\n\tstruct bno055_priv *priv = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\t*type = bno055_sysfs_attr_avail(priv, &bno055_gyr_scale,\n\t\t\t\t\t\t\tvals, length);\n\t\t\treturn IIO_AVAIL_LIST;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\t*type = bno055_sysfs_attr_avail(priv, &bno055_gyr_lpf,\n\t\t\t\t\t\t\tvals, length);\n\t\t\treturn IIO_AVAIL_LIST;\n\t\tcase IIO_ACCEL:\n\t\t\t*type = bno055_sysfs_attr_avail(priv, &bno055_acc_lpf,\n\t\t\t\t\t\t\tvals, length);\n\t\t\treturn IIO_AVAIL_LIST;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tswitch (chan->type) {\n\t\tcase IIO_MAGN:\n\t\t\t*type = bno055_sysfs_attr_avail(priv, &bno055_mag_odr,\n\t\t\t\t\t\t\tvals, length);\n\t\t\treturn IIO_AVAIL_LIST;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bno055_read_temp_chan(struct iio_dev *indio_dev, int *val)\n{\n\tstruct bno055_priv *priv = iio_priv(indio_dev);\n\tunsigned int raw_val;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, BNO055_TEMP_REG, &raw_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t*val = raw_val * 1000;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int bno055_read_quaternion(struct iio_dev *indio_dev,\n\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t  int size, int *vals, int *val_len,\n\t\t\t\t  long mask)\n{\n\tstruct bno055_priv *priv = iio_priv(indio_dev);\n\t__le16 raw_vals[4];\n\tint i, ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (size < 4)\n\t\t\treturn -EINVAL;\n\t\tret = regmap_bulk_read(priv->regmap,\n\t\t\t\t       BNO055_QUAT_DATA_W_LSB_REG,\n\t\t\t\t       raw_vals, sizeof(raw_vals));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tvals[i] = sign_extend32(le16_to_cpu(raw_vals[i]), 15);\n\t\t*val_len = 4;\n\t\treturn IIO_VAL_INT_MULTIPLE;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\tif (size < 2)\n\t\t\treturn -EINVAL;\n\t\tvals[0] = 1;\n\t\tvals[1] = 14;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic bool bno055_is_chan_readable(struct iio_dev *indio_dev,\n\t\t\t\t    struct iio_chan_spec const *chan)\n{\n\tstruct bno055_priv *priv = iio_priv(indio_dev);\n\n\tif (priv->operation_mode != BNO055_OPR_MODE_AMG)\n\t\treturn true;\n\n\tswitch (chan->type) {\n\tcase IIO_GRAVITY:\n\tcase IIO_ROT:\n\t\treturn false;\n\tcase IIO_ACCEL:\n\t\tif (chan->channel2 == IIO_MOD_LINEAR_X ||\n\t\t    chan->channel2 == IIO_MOD_LINEAR_Y ||\n\t\t    chan->channel2 == IIO_MOD_LINEAR_Z)\n\t\t\treturn false;\n\t\treturn true;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic int _bno055_read_raw_multi(struct iio_dev *indio_dev,\n\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t  int size, int *vals, int *val_len,\n\t\t\t\t  long mask)\n{\n\tif (!bno055_is_chan_readable(indio_dev, chan))\n\t\treturn -EBUSY;\n\n\tswitch (chan->type) {\n\tcase IIO_MAGN:\n\tcase IIO_ACCEL:\n\tcase IIO_ANGL_VEL:\n\tcase IIO_GRAVITY:\n\t\tif (size < 2)\n\t\t\treturn -EINVAL;\n\t\t*val_len = 2;\n\t\treturn bno055_read_simple_chan(indio_dev, chan,\n\t\t\t\t\t       &vals[0], &vals[1],\n\t\t\t\t\t       mask);\n\tcase IIO_TEMP:\n\t\t*val_len = 1;\n\t\treturn bno055_read_temp_chan(indio_dev, &vals[0]);\n\tcase IIO_ROT:\n\t\t \n\t\tif (chan->channel2 == IIO_MOD_QUATERNION)\n\t\t\treturn bno055_read_quaternion(indio_dev, chan,\n\t\t\t\t\t\t      size, vals,\n\t\t\t\t\t\t      val_len, mask);\n\t\tif (size < 2)\n\t\t\treturn -EINVAL;\n\t\t*val_len = 2;\n\t\treturn bno055_read_simple_chan(indio_dev, chan,\n\t\t\t\t\t       &vals[0], &vals[1],\n\t\t\t\t\t       mask);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bno055_read_raw_multi(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int size, int *vals, int *val_len,\n\t\t\t\t long mask)\n{\n\tstruct bno055_priv *priv = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tret = _bno055_read_raw_multi(indio_dev, chan, size,\n\t\t\t\t     vals, val_len, mask);\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic int _bno055_write_raw(struct iio_dev *iio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct bno055_priv *priv = iio_priv(iio_dev);\n\n\tswitch (chan->type) {\n\tcase IIO_MAGN:\n\t\tswitch (mask) {\n\t\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t\treturn bno055_set_regmask(priv, val, val2,\n\t\t\t\t\t\t  BNO055_MAG_CONFIG_REG,\n\t\t\t\t\t\t  BNO055_MAG_CONFIG_ODR_MASK,\n\t\t\t\t\t\t  &bno055_mag_odr);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_ACCEL:\n\t\tswitch (mask) {\n\t\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\t\treturn bno055_set_regmask(priv, val, val2,\n\t\t\t\t\t\t  BNO055_ACC_CONFIG_REG,\n\t\t\t\t\t\t  BNO055_ACC_CONFIG_LPF_MASK,\n\t\t\t\t\t\t  &bno055_acc_lpf);\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_ANGL_VEL:\n\t\tswitch (mask) {\n\t\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\t\treturn bno055_set_regmask(priv, val, val2,\n\t\t\t\t\t\t  BNO055_GYR_CONFIG_REG,\n\t\t\t\t\t\t  BNO055_GYR_CONFIG_LPF_MASK,\n\t\t\t\t\t\t  &bno055_gyr_lpf);\n\t\tcase IIO_CHAN_INFO_SCALE:\n\t\t\treturn bno055_set_regmask(priv, val, val2,\n\t\t\t\t\t\t  BNO055_GYR_CONFIG_REG,\n\t\t\t\t\t\t  BNO055_GYR_CONFIG_RANGE_MASK,\n\t\t\t\t\t\t  &bno055_gyr_scale);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bno055_write_raw(struct iio_dev *iio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct bno055_priv *priv = iio_priv(iio_dev);\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tret = _bno055_write_raw(iio_dev, chan, val, val2, mask);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic ssize_t in_accel_range_raw_available_show(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\tstruct bno055_priv *priv = iio_priv(dev_to_iio_dev(dev));\n\tint len = 0;\n\tint i;\n\n\tif (priv->operation_mode != BNO055_OPR_MODE_AMG)\n\t\treturn sysfs_emit(buf, \"%d\\n\", bno055_acc_range.fusion_vals[0]);\n\n\tfor (i = 0; i < bno055_acc_range.len; i++)\n\t\tlen += sysfs_emit_at(buf, len, \"%d \", bno055_acc_range.vals[i]);\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t fusion_enable_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct bno055_priv *priv = iio_priv(dev_to_iio_dev(dev));\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  priv->operation_mode != BNO055_OPR_MODE_AMG);\n}\n\nstatic ssize_t fusion_enable_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct bno055_priv *priv = iio_priv(indio_dev);\n\tbool en;\n\tint ret;\n\n\tif (indio_dev->active_scan_mask &&\n\t    !bitmap_empty(indio_dev->active_scan_mask, _BNO055_SCAN_MAX))\n\t\treturn -EBUSY;\n\n\tret = kstrtobool(buf, &en);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (!en)\n\t\treturn bno055_operation_mode_set(priv, BNO055_OPR_MODE_AMG) ?: len;\n\n\t \n\tif (priv->operation_mode == BNO055_OPR_MODE_AMG)\n\t\treturn  bno055_operation_mode_set(priv, BNO055_OPR_MODE_FUSION_FMC_OFF) ?: len;\n\n\treturn len;\n}\n\nstatic ssize_t in_magn_calibration_fast_enable_show(struct device *dev,\n\t\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t\t    char *buf)\n{\n\tstruct bno055_priv *priv = iio_priv(dev_to_iio_dev(dev));\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  priv->operation_mode == BNO055_OPR_MODE_FUSION);\n}\n\nstatic ssize_t in_magn_calibration_fast_enable_store(struct device *dev,\n\t\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct bno055_priv *priv = iio_priv(indio_dev);\n\tint ret;\n\n\tif (indio_dev->active_scan_mask &&\n\t    !bitmap_empty(indio_dev->active_scan_mask, _BNO055_SCAN_MAX))\n\t\treturn -EBUSY;\n\n\tif (sysfs_streq(buf, \"0\")) {\n\t\tif (priv->operation_mode == BNO055_OPR_MODE_FUSION) {\n\t\t\tret = bno055_operation_mode_set(priv, BNO055_OPR_MODE_FUSION_FMC_OFF);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (priv->operation_mode == BNO055_OPR_MODE_AMG)\n\t\t\treturn -EINVAL;\n\n\t\tif (priv->operation_mode != BNO055_OPR_MODE_FUSION) {\n\t\t\tret = bno055_operation_mode_set(priv, BNO055_OPR_MODE_FUSION);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t in_accel_range_raw_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct bno055_priv *priv = iio_priv(dev_to_iio_dev(dev));\n\tint val;\n\tint ret;\n\n\tret = bno055_get_regmask(priv, &val, NULL,\n\t\t\t\t BNO055_ACC_CONFIG_REG,\n\t\t\t\t BNO055_ACC_CONFIG_RANGE_MASK,\n\t\t\t\t &bno055_acc_range);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t in_accel_range_raw_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct bno055_priv *priv = iio_priv(dev_to_iio_dev(dev));\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&priv->lock);\n\tret = bno055_set_regmask(priv, val, 0,\n\t\t\t\t BNO055_ACC_CONFIG_REG,\n\t\t\t\t BNO055_ACC_CONFIG_RANGE_MASK,\n\t\t\t\t &bno055_acc_range);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret ?: len;\n}\n\nstatic ssize_t bno055_get_calib_status(struct device *dev, char *buf, int which)\n{\n\tstruct bno055_priv *priv = iio_priv(dev_to_iio_dev(dev));\n\tint calib;\n\tint ret;\n\tint val;\n\n\tif (priv->operation_mode == BNO055_OPR_MODE_AMG ||\n\t    (priv->operation_mode == BNO055_OPR_MODE_FUSION_FMC_OFF &&\n\t     which == BNO055_CALIB_STAT_MAGN_SHIFT)) {\n\t\tcalib = 0;\n\t} else {\n\t\tmutex_lock(&priv->lock);\n\t\tret = regmap_read(priv->regmap, BNO055_CALIB_STAT_REG, &val);\n\t\tmutex_unlock(&priv->lock);\n\n\t\tif (ret)\n\t\t\treturn -EIO;\n\n\t\tcalib = ((val >> which) & GENMASK(1, 0)) + 1;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\", calib);\n}\n\nstatic ssize_t serialnumber_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct bno055_priv *priv = iio_priv(dev_to_iio_dev(dev));\n\n\treturn sysfs_emit(buf, \"%*ph\\n\", BNO055_UID_LEN, priv->uid);\n}\n\nstatic ssize_t calibration_data_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t     struct bin_attribute *bin_attr, char *buf,\n\t\t\t\t     loff_t pos, size_t count)\n{\n\tstruct bno055_priv *priv = iio_priv(dev_to_iio_dev(kobj_to_dev(kobj)));\n\tu8 data[BNO055_CALDATA_LEN];\n\tint ret;\n\n\t \n\tif (count < BNO055_CALDATA_LEN || pos)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\tret = bno055_operation_mode_do_set(priv, BNO055_OPR_MODE_CONFIG);\n\tif (ret)\n\t\tgoto exit_unlock;\n\n\tret = regmap_bulk_read(priv->regmap, BNO055_CALDATA_START, data,\n\t\t\t       BNO055_CALDATA_LEN);\n\tif (ret)\n\t\tgoto exit_unlock;\n\n\tret = bno055_operation_mode_do_set(priv, priv->operation_mode);\n\tif (ret)\n\t\tgoto exit_unlock;\n\n\tmemcpy(buf, data, BNO055_CALDATA_LEN);\n\n\tret = BNO055_CALDATA_LEN;\nexit_unlock:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nstatic ssize_t sys_calibration_auto_status_show(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *a,\n\t\t\t\t\t\tchar *buf)\n{\n\treturn bno055_get_calib_status(dev, buf, BNO055_CALIB_STAT_SYS_SHIFT);\n}\n\nstatic ssize_t in_accel_calibration_auto_status_show(struct device *dev,\n\t\t\t\t\t\t     struct device_attribute *a,\n\t\t\t\t\t\t     char *buf)\n{\n\treturn bno055_get_calib_status(dev, buf, BNO055_CALIB_STAT_ACCEL_SHIFT);\n}\n\nstatic ssize_t in_gyro_calibration_auto_status_show(struct device *dev,\n\t\t\t\t\t\t    struct device_attribute *a,\n\t\t\t\t\t\t    char *buf)\n{\n\treturn bno055_get_calib_status(dev, buf, BNO055_CALIB_STAT_GYRO_SHIFT);\n}\n\nstatic ssize_t in_magn_calibration_auto_status_show(struct device *dev,\n\t\t\t\t\t\t    struct device_attribute *a,\n\t\t\t\t\t\t    char *buf)\n{\n\treturn bno055_get_calib_status(dev, buf, BNO055_CALIB_STAT_MAGN_SHIFT);\n}\n\nstatic int bno055_debugfs_reg_access(struct iio_dev *iio_dev, unsigned int reg,\n\t\t\t\t     unsigned int writeval, unsigned int *readval)\n{\n\tstruct bno055_priv *priv = iio_priv(iio_dev);\n\n\tif (readval)\n\t\treturn regmap_read(priv->regmap, reg, readval);\n\telse\n\t\treturn regmap_write(priv->regmap, reg, writeval);\n}\n\nstatic ssize_t bno055_show_fw_version(struct file *file, char __user *userbuf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct bno055_priv *priv = file->private_data;\n\tint rev, ver;\n\tchar *buf;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, BNO055_SW_REV_LSB_REG, &rev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(priv->regmap, BNO055_SW_REV_MSB_REG, &ver);\n\tif (ret)\n\t\treturn ret;\n\n\tbuf = kasprintf(GFP_KERNEL, \"ver: 0x%x, rev: 0x%x\\n\", ver, rev);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = simple_read_from_buffer(userbuf, count, ppos, buf, strlen(buf));\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic const struct file_operations bno055_fw_version_ops = {\n\t.open = simple_open,\n\t.read = bno055_show_fw_version,\n\t.llseek = default_llseek,\n\t.owner = THIS_MODULE,\n};\n\nstatic void bno055_debugfs_remove(void *_priv)\n{\n\tstruct bno055_priv *priv = _priv;\n\n\tdebugfs_remove(priv->debugfs);\n\tpriv->debugfs = NULL;\n}\n\nstatic void bno055_debugfs_init(struct iio_dev *iio_dev)\n{\n\tstruct bno055_priv *priv = iio_priv(iio_dev);\n\n\tpriv->debugfs = debugfs_create_file(\"firmware_version\", 0400,\n\t\t\t\t\t    iio_get_debugfs_dentry(iio_dev),\n\t\t\t\t\t    priv, &bno055_fw_version_ops);\n\tif (!IS_ERR(priv->debugfs))\n\t\tdevm_add_action_or_reset(priv->dev, bno055_debugfs_remove,\n\t\t\t\t\t priv);\n\tif (IS_ERR_OR_NULL(priv->debugfs))\n\t\tdev_warn(priv->dev, \"failed to setup debugfs\");\n}\n\nstatic IIO_DEVICE_ATTR_RW(fusion_enable, 0);\nstatic IIO_DEVICE_ATTR_RW(in_magn_calibration_fast_enable, 0);\nstatic IIO_DEVICE_ATTR_RW(in_accel_range_raw, 0);\n\nstatic IIO_DEVICE_ATTR_RO(in_accel_range_raw_available, 0);\nstatic IIO_DEVICE_ATTR_RO(sys_calibration_auto_status, 0);\nstatic IIO_DEVICE_ATTR_RO(in_accel_calibration_auto_status, 0);\nstatic IIO_DEVICE_ATTR_RO(in_gyro_calibration_auto_status, 0);\nstatic IIO_DEVICE_ATTR_RO(in_magn_calibration_auto_status, 0);\nstatic IIO_DEVICE_ATTR_RO(serialnumber, 0);\n\nstatic struct attribute *bno055_attrs[] = {\n\t&iio_dev_attr_in_accel_range_raw_available.dev_attr.attr,\n\t&iio_dev_attr_in_accel_range_raw.dev_attr.attr,\n\t&iio_dev_attr_fusion_enable.dev_attr.attr,\n\t&iio_dev_attr_in_magn_calibration_fast_enable.dev_attr.attr,\n\t&iio_dev_attr_sys_calibration_auto_status.dev_attr.attr,\n\t&iio_dev_attr_in_accel_calibration_auto_status.dev_attr.attr,\n\t&iio_dev_attr_in_gyro_calibration_auto_status.dev_attr.attr,\n\t&iio_dev_attr_in_magn_calibration_auto_status.dev_attr.attr,\n\t&iio_dev_attr_serialnumber.dev_attr.attr,\n\tNULL\n};\n\nstatic BIN_ATTR_RO(calibration_data, BNO055_CALDATA_LEN);\n\nstatic struct bin_attribute *bno055_bin_attrs[] = {\n\t&bin_attr_calibration_data,\n\tNULL\n};\n\nstatic const struct attribute_group bno055_attrs_group = {\n\t.attrs = bno055_attrs,\n\t.bin_attrs = bno055_bin_attrs,\n};\n\nstatic const struct iio_info bno055_info = {\n\t.read_raw_multi = bno055_read_raw_multi,\n\t.read_avail = bno055_read_avail,\n\t.write_raw = bno055_write_raw,\n\t.attrs = &bno055_attrs_group,\n\t.debugfs_reg_access = bno055_debugfs_reg_access,\n};\n\n \nstatic int bno055_scan_xfer(struct bno055_priv *priv,\n\t\t\t    int start_ch, int len, unsigned long mask,\n\t\t\t    __le16 *buf, int *buf_idx)\n{\n\tconst int base = BNO055_ACC_DATA_X_LSB_REG;\n\tbool quat_in_read = false;\n\tint buf_base = *buf_idx;\n\t__le16 *dst, *src;\n\tint offs_fixup = 0;\n\tint xfer_len = len;\n\tint ret;\n\tint i, n;\n\n\tif (!mask)\n\t\treturn 0;\n\n\t \n\tif (start_ch > BNO055_SCAN_QUATERNION) {\n\t\tstart_ch += 3;\n\t} else if ((start_ch <= BNO055_SCAN_QUATERNION) &&\n\t\t ((start_ch + len) > BNO055_SCAN_QUATERNION)) {\n\t\tquat_in_read = true;\n\t\txfer_len += 3;\n\t}\n\n\tret = regmap_bulk_read(priv->regmap,\n\t\t\t       base + start_ch * sizeof(__le16),\n\t\t\t       buf + buf_base,\n\t\t\t       xfer_len * sizeof(__le16));\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_set_bit(i, &mask, len) {\n\t\tif (quat_in_read && ((start_ch + i) > BNO055_SCAN_QUATERNION))\n\t\t\toffs_fixup = 3;\n\n\t\tdst = buf + *buf_idx;\n\t\tsrc = buf + buf_base + offs_fixup + i;\n\n\t\tn = (start_ch + i == BNO055_SCAN_QUATERNION) ? 4 : 1;\n\n\t\tif (dst != src)\n\t\t\tmemcpy(dst, src, n * sizeof(__le16));\n\n\t\t*buf_idx += n;\n\t}\n\treturn 0;\n}\n\nstatic irqreturn_t bno055_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *iio_dev = pf->indio_dev;\n\tstruct bno055_priv *priv = iio_priv(iio_dev);\n\tint xfer_start, start, end, prev_end;\n\tunsigned long mask;\n\tint quat_extra_len;\n\tbool first = true;\n\tint buf_idx = 0;\n\tbool thr_hit;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tfor_each_set_bitrange(start, end, iio_dev->active_scan_mask,\n\t\t\t      iio_dev->masklength) {\n\t\t \n\t\tif (first) {\n\t\t\txfer_start = start;\n\t\t} else {\n\t\t\t \n\n\t\t\t \n\t\t\tquat_extra_len = ((start > BNO055_SCAN_QUATERNION) &&\n\t\t\t\t\t  (prev_end <= BNO055_SCAN_QUATERNION)) ? 3 : 0;\n\n\t\t\t \n\t\t\tthr_hit = (start - prev_end + quat_extra_len) >\n\t\t\t\tpriv->xfer_burst_break_thr;\n\n\t\t\t \n\t\t\tif (thr_hit) {\n\t\t\t\tmask = *iio_dev->active_scan_mask >> xfer_start;\n\t\t\t\tret = bno055_scan_xfer(priv, xfer_start,\n\t\t\t\t\t\t       prev_end - xfer_start,\n\t\t\t\t\t\t       mask, priv->buf.chans, &buf_idx);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto done;\n\t\t\t\txfer_start = start;\n\t\t\t}\n\t\t}\n\t\tfirst = false;\n\t\tprev_end = end;\n\t}\n\n\t \n\tmask = *iio_dev->active_scan_mask >> xfer_start;\n\tret = bno055_scan_xfer(priv, xfer_start,\n\t\t\t       prev_end - xfer_start,\n\t\t\t       mask, priv->buf.chans, &buf_idx);\n\n\tif (!ret)\n\t\tiio_push_to_buffers_with_timestamp(iio_dev,\n\t\t\t\t\t\t   &priv->buf, pf->timestamp);\ndone:\n\tmutex_unlock(&priv->lock);\n\tiio_trigger_notify_done(iio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\nstatic int bno055_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct bno055_priv *priv = iio_priv(indio_dev);\n\tconst unsigned long fusion_mask =\n\t\tBIT(BNO055_SCAN_YAW) |\n\t\tBIT(BNO055_SCAN_ROLL) |\n\t\tBIT(BNO055_SCAN_PITCH) |\n\t\tBIT(BNO055_SCAN_QUATERNION) |\n\t\tBIT(BNO055_SCAN_LIA_X) |\n\t\tBIT(BNO055_SCAN_LIA_Y) |\n\t\tBIT(BNO055_SCAN_LIA_Z) |\n\t\tBIT(BNO055_SCAN_GRAVITY_X) |\n\t\tBIT(BNO055_SCAN_GRAVITY_Y) |\n\t\tBIT(BNO055_SCAN_GRAVITY_Z);\n\n\tif (priv->operation_mode == BNO055_OPR_MODE_AMG &&\n\t    bitmap_intersects(indio_dev->active_scan_mask, &fusion_mask,\n\t\t\t      _BNO055_SCAN_MAX))\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops bno055_buffer_setup_ops = {\n\t.preenable = bno055_buffer_preenable,\n};\n\nint bno055_probe(struct device *dev, struct regmap *regmap,\n\t\t int xfer_burst_break_thr, bool sw_reset)\n{\n\tconst struct firmware *caldata = NULL;\n\tstruct bno055_priv *priv;\n\tstruct iio_dev *iio_dev;\n\tchar *fw_name_buf;\n\tunsigned int val;\n\tint rev, ver;\n\tint ret;\n\n\tiio_dev = devm_iio_device_alloc(dev, sizeof(*priv));\n\tif (!iio_dev)\n\t\treturn -ENOMEM;\n\n\tiio_dev->name = \"bno055\";\n\tpriv = iio_priv(iio_dev);\n\tmutex_init(&priv->lock);\n\tpriv->regmap = regmap;\n\tpriv->dev = dev;\n\tpriv->xfer_burst_break_thr = xfer_burst_break_thr;\n\tpriv->sw_reset = sw_reset;\n\n\tpriv->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->reset_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->reset_gpio), \"Failed to get reset GPIO\\n\");\n\n\tpriv->clk = devm_clk_get_optional_enabled(dev, \"clk\");\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk), \"Failed to get CLK\\n\");\n\n\tif (priv->reset_gpio) {\n\t\tusleep_range(5000, 10000);\n\t\tgpiod_set_value_cansleep(priv->reset_gpio, 1);\n\t\tusleep_range(650000, 750000);\n\t} else if (!sw_reset) {\n\t\tdev_warn(dev, \"No usable reset method; IMU may be unreliable\\n\");\n\t}\n\n\tret = regmap_read(priv->regmap, BNO055_CHIP_ID_REG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != BNO055_CHIP_ID_MAGIC)\n\t\tdev_warn(dev, \"Unrecognized chip ID 0x%x\\n\", val);\n\n\t \n\tif (!priv->reset_gpio) {\n\t\tret = bno055_system_reset(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = regmap_read(priv->regmap, BNO055_SW_REV_LSB_REG, &rev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(priv->regmap, BNO055_SW_REV_MSB_REG, &ver);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ver != 0x3 || rev != 0x11)\n\t\tdev_warn(dev, \"Untested firmware version. Anglvel scale may not work as expected\\n\");\n\n\tret = regmap_bulk_read(priv->regmap, BNO055_UID_LOWER_REG,\n\t\t\t       priv->uid, BNO055_UID_LEN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfw_name_buf = kasprintf(GFP_KERNEL, BNO055_FW_UID_FMT,\n\t\t\t\tBNO055_UID_LEN, priv->uid);\n\tif (!fw_name_buf)\n\t\treturn -ENOMEM;\n\n\tret = request_firmware(&caldata, fw_name_buf, dev);\n\tkfree(fw_name_buf);\n\tif (ret)\n\t\tret = request_firmware(&caldata, BNO055_FW_GENERIC_NAME, dev);\n\tif (ret) {\n\t\tdev_notice(dev, \"Calibration file load failed. See instruction in kernel Documentation/iio/bno055.rst\\n\");\n\t\tret = bno055_init(priv, NULL, 0);\n\t} else {\n\t\tret = bno055_init(priv, caldata->data, caldata->size);\n\t\trelease_firmware(caldata);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->operation_mode = BNO055_OPR_MODE_FUSION;\n\tret = bno055_operation_mode_do_set(priv, priv->operation_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, bno055_uninit, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tiio_dev->channels = bno055_channels;\n\tiio_dev->num_channels = ARRAY_SIZE(bno055_channels);\n\tiio_dev->info = &bno055_info;\n\tiio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = devm_iio_triggered_buffer_setup(dev, iio_dev,\n\t\t\t\t\t      iio_pollfunc_store_time,\n\t\t\t\t\t      bno055_trigger_handler,\n\t\t\t\t\t      &bno055_buffer_setup_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_device_register(dev, iio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tbno055_debugfs_init(iio_dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(bno055_probe, IIO_BNO055);\n\nMODULE_AUTHOR(\"Andrea Merello <andrea.merello@iit.it>\");\nMODULE_DESCRIPTION(\"Bosch BNO055 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}