{
  "module_name": "adrf6780.c",
  "hash_id": "a14ce1acb6dc177250c8415850f9d669bfade5c37bd0a44d723adb175722dbd4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/frequency/adrf6780.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/spi/spi.h>\n\n#include <asm/unaligned.h>\n\n \n#define ADRF6780_REG_CONTROL\t\t\t0x00\n#define ADRF6780_REG_ALARM_READBACK\t\t0x01\n#define ADRF6780_REG_ALARM_MASKS\t\t0x02\n#define ADRF6780_REG_ENABLE\t\t\t0x03\n#define ADRF6780_REG_LINEARIZE\t\t\t0x04\n#define ADRF6780_REG_LO_PATH\t\t\t0x05\n#define ADRF6780_REG_ADC_CONTROL\t\t0x06\n#define ADRF6780_REG_ADC_OUTPUT\t\t\t0x0C\n\n \n#define ADRF6780_PARITY_EN_MSK\t\t\tBIT(15)\n#define ADRF6780_SOFT_RESET_MSK\t\t\tBIT(14)\n#define ADRF6780_CHIP_ID_MSK\t\t\tGENMASK(11, 4)\n#define ADRF6780_CHIP_ID\t\t\t0xA\n#define ADRF6780_CHIP_REVISION_MSK\t\tGENMASK(3, 0)\n\n \n#define ADRF6780_PARITY_ERROR_MSK\t\tBIT(15)\n#define ADRF6780_TOO_FEW_ERRORS_MSK\t\tBIT(14)\n#define ADRF6780_TOO_MANY_ERRORS_MSK\t\tBIT(13)\n#define ADRF6780_ADDRESS_RANGE_ERROR_MSK\tBIT(12)\n\n \n#define ADRF6780_VGA_BUFFER_EN_MSK\t\tBIT(8)\n#define ADRF6780_DETECTOR_EN_MSK\t\tBIT(7)\n#define ADRF6780_LO_BUFFER_EN_MSK\t\tBIT(6)\n#define ADRF6780_IF_MODE_EN_MSK\t\t\tBIT(5)\n#define ADRF6780_IQ_MODE_EN_MSK\t\t\tBIT(4)\n#define ADRF6780_LO_X2_EN_MSK\t\t\tBIT(3)\n#define ADRF6780_LO_PPF_EN_MSK\t\t\tBIT(2)\n#define ADRF6780_LO_EN_MSK\t\t\tBIT(1)\n#define ADRF6780_UC_BIAS_EN_MSK\t\t\tBIT(0)\n\n \n#define ADRF6780_RDAC_LINEARIZE_MSK\t\tGENMASK(7, 0)\n\n \n#define ADRF6780_LO_SIDEBAND_MSK\t\tBIT(10)\n#define ADRF6780_Q_PATH_PHASE_ACCURACY_MSK\tGENMASK(7, 4)\n#define ADRF6780_I_PATH_PHASE_ACCURACY_MSK\tGENMASK(3, 0)\n\n \n#define ADRF6780_VDET_OUTPUT_SELECT_MSK\t\tBIT(3)\n#define ADRF6780_ADC_START_MSK\t\t\tBIT(2)\n#define ADRF6780_ADC_EN_MSK\t\t\tBIT(1)\n#define ADRF6780_ADC_CLOCK_EN_MSK\t\tBIT(0)\n\n \n#define ADRF6780_ADC_STATUS_MSK\t\t\tBIT(8)\n#define ADRF6780_ADC_VALUE_MSK\t\t\tGENMASK(7, 0)\n\nstruct adrf6780_state {\n\tstruct spi_device\t*spi;\n\tstruct clk\t\t*clkin;\n\t \n\tstruct mutex\t\tlock;\n\tbool\t\t\tvga_buff_en;\n\tbool\t\t\tlo_buff_en;\n\tbool\t\t\tif_mode_en;\n\tbool\t\t\tiq_mode_en;\n\tbool\t\t\tlo_x2_en;\n\tbool\t\t\tlo_ppf_en;\n\tbool\t\t\tlo_en;\n\tbool\t\t\tuc_bias_en;\n\tbool\t\t\tlo_sideband;\n\tbool\t\t\tvdet_out_en;\n\tu8\t\t\tdata[3] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic int __adrf6780_spi_read(struct adrf6780_state *st, unsigned int reg,\n\t\t\t       unsigned int *val)\n{\n\tint ret;\n\tstruct spi_transfer t = {0};\n\n\tst->data[0] = 0x80 | (reg << 1);\n\tst->data[1] = 0x0;\n\tst->data[2] = 0x0;\n\n\tt.rx_buf = &st->data[0];\n\tt.tx_buf = &st->data[0];\n\tt.len = 3;\n\n\tret = spi_sync_transfer(st->spi, &t, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = (get_unaligned_be24(&st->data[0]) >> 1) & GENMASK(15, 0);\n\n\treturn ret;\n}\n\nstatic int adrf6780_spi_read(struct adrf6780_state *st, unsigned int reg,\n\t\t\t     unsigned int *val)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __adrf6780_spi_read(st, reg, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int __adrf6780_spi_write(struct adrf6780_state *st,\n\t\t\t\tunsigned int reg,\n\t\t\t\tunsigned int val)\n{\n\tput_unaligned_be24((val << 1) | (reg << 17), &st->data[0]);\n\n\treturn spi_write(st->spi, &st->data[0], 3);\n}\n\nstatic int adrf6780_spi_write(struct adrf6780_state *st, unsigned int reg,\n\t\t\t      unsigned int val)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __adrf6780_spi_write(st, reg, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int __adrf6780_spi_update_bits(struct adrf6780_state *st,\n\t\t\t\t      unsigned int reg, unsigned int mask,\n\t\t\t\t      unsigned int val)\n{\n\tint ret;\n\tunsigned int data, temp;\n\n\tret = __adrf6780_spi_read(st, reg, &data);\n\tif (ret)\n\t\treturn ret;\n\n\ttemp = (data & ~mask) | (val & mask);\n\n\treturn __adrf6780_spi_write(st, reg, temp);\n}\n\nstatic int adrf6780_spi_update_bits(struct adrf6780_state *st, unsigned int reg,\n\t\t\t\t    unsigned int mask, unsigned int val)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __adrf6780_spi_update_bits(st, reg, mask, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int adrf6780_read_adc_raw(struct adrf6780_state *st, unsigned int *read_val)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = __adrf6780_spi_update_bits(st, ADRF6780_REG_ADC_CONTROL,\n\t\t\t\t\t ADRF6780_ADC_EN_MSK |\n\t\t\t\t\t ADRF6780_ADC_CLOCK_EN_MSK |\n\t\t\t\t\t ADRF6780_ADC_START_MSK,\n\t\t\t\t\t FIELD_PREP(ADRF6780_ADC_EN_MSK, 1) |\n\t\t\t\t\t FIELD_PREP(ADRF6780_ADC_CLOCK_EN_MSK, 1) |\n\t\t\t\t\t FIELD_PREP(ADRF6780_ADC_START_MSK, 1));\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tusleep_range(200, 250);\n\n\tret = __adrf6780_spi_read(st, ADRF6780_REG_ADC_OUTPUT, read_val);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (!(*read_val & ADRF6780_ADC_STATUS_MSK)) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tret = __adrf6780_spi_update_bits(st, ADRF6780_REG_ADC_CONTROL,\n\t\t\t\t\t ADRF6780_ADC_START_MSK,\n\t\t\t\t\t FIELD_PREP(ADRF6780_ADC_START_MSK, 0));\n\tif (ret)\n\t\tgoto exit;\n\n\tret = __adrf6780_spi_read(st, ADRF6780_REG_ADC_OUTPUT, read_val);\n\nexit:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic int adrf6780_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long info)\n{\n\tstruct adrf6780_state *dev = iio_priv(indio_dev);\n\tunsigned int data;\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = adrf6780_read_adc_raw(dev, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = data & ADRF6780_ADC_VALUE_MSK;\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = adrf6780_spi_read(dev, ADRF6780_REG_LINEARIZE, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = data & ADRF6780_RDAC_LINEARIZE_MSK;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_PHASE:\n\t\tret = adrf6780_spi_read(dev, ADRF6780_REG_LO_PATH, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswitch (chan->channel2) {\n\t\tcase IIO_MOD_I:\n\t\t\t*val = data & ADRF6780_I_PATH_PHASE_ACCURACY_MSK;\n\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_MOD_Q:\n\t\t\t*val = FIELD_GET(ADRF6780_Q_PATH_PHASE_ACCURACY_MSK,\n\t\t\t\t\t data);\n\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adrf6780_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long info)\n{\n\tstruct adrf6780_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn adrf6780_spi_write(st, ADRF6780_REG_LINEARIZE, val);\n\tcase IIO_CHAN_INFO_PHASE:\n\t\tswitch (chan->channel2) {\n\t\tcase IIO_MOD_I:\n\t\t\treturn adrf6780_spi_update_bits(st,\n\t\t\t\tADRF6780_REG_LO_PATH,\n\t\t\t\tADRF6780_I_PATH_PHASE_ACCURACY_MSK,\n\t\t\t\tFIELD_PREP(ADRF6780_I_PATH_PHASE_ACCURACY_MSK, val));\n\t\tcase IIO_MOD_Q:\n\t\t\treturn adrf6780_spi_update_bits(st,\n\t\t\t\tADRF6780_REG_LO_PATH,\n\t\t\t\tADRF6780_Q_PATH_PHASE_ACCURACY_MSK,\n\t\t\t\tFIELD_PREP(ADRF6780_Q_PATH_PHASE_ACCURACY_MSK, val));\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adrf6780_reg_access(struct iio_dev *indio_dev,\n\t\t\t       unsigned int reg,\n\t\t\t       unsigned int write_val,\n\t\t\t       unsigned int *read_val)\n{\n\tstruct adrf6780_state *st = iio_priv(indio_dev);\n\n\tif (read_val)\n\t\treturn adrf6780_spi_read(st, reg, read_val);\n\telse\n\t\treturn adrf6780_spi_write(st, reg, write_val);\n}\n\nstatic const struct iio_info adrf6780_info = {\n\t.read_raw = adrf6780_read_raw,\n\t.write_raw = adrf6780_write_raw,\n\t.debugfs_reg_access = &adrf6780_reg_access,\n};\n\n#define ADRF6780_CHAN_ADC(_channel) {\t\t\t\\\n\t.type = IIO_ALTVOLTAGE,\t\t\t\t\\\n\t.output = 0,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)\t\\\n}\n\n#define ADRF6780_CHAN_RDAC(_channel) {\t\t\t\\\n\t.type = IIO_ALTVOLTAGE,\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_SCALE)\t\\\n}\n\n#define ADRF6780_CHAN_IQ_PHASE(_channel, rf_comp) {\t\t\\\n\t.type = IIO_ALTVOLTAGE,\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##rf_comp,\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_PHASE)\t\t\\\n}\n\nstatic const struct iio_chan_spec adrf6780_channels[] = {\n\tADRF6780_CHAN_ADC(0),\n\tADRF6780_CHAN_RDAC(0),\n\tADRF6780_CHAN_IQ_PHASE(0, I),\n\tADRF6780_CHAN_IQ_PHASE(0, Q),\n};\n\nstatic int adrf6780_reset(struct adrf6780_state *st)\n{\n\tint ret;\n\tstruct spi_device *spi = st->spi;\n\n\tret = __adrf6780_spi_update_bits(st, ADRF6780_REG_CONTROL,\n\t\t\t\t\t ADRF6780_SOFT_RESET_MSK,\n\t\t\t\t\t FIELD_PREP(ADRF6780_SOFT_RESET_MSK, 1));\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"ADRF6780 SPI software reset failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = __adrf6780_spi_update_bits(st, ADRF6780_REG_CONTROL,\n\t\t\t\t\t ADRF6780_SOFT_RESET_MSK,\n\t\t\t\t\t FIELD_PREP(ADRF6780_SOFT_RESET_MSK, 0));\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"ADRF6780 SPI software reset disable failed.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int adrf6780_init(struct adrf6780_state *st)\n{\n\tint ret;\n\tunsigned int chip_id, enable_reg, enable_reg_msk;\n\tstruct spi_device *spi = st->spi;\n\n\t \n\tret = adrf6780_reset(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __adrf6780_spi_read(st, ADRF6780_REG_CONTROL, &chip_id);\n\tif (ret)\n\t\treturn ret;\n\n\tchip_id = FIELD_GET(ADRF6780_CHIP_ID_MSK, chip_id);\n\tif (chip_id != ADRF6780_CHIP_ID) {\n\t\tdev_err(&spi->dev, \"ADRF6780 Invalid Chip ID.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tenable_reg_msk = ADRF6780_VGA_BUFFER_EN_MSK |\n\t\t\tADRF6780_DETECTOR_EN_MSK |\n\t\t\tADRF6780_LO_BUFFER_EN_MSK |\n\t\t\tADRF6780_IF_MODE_EN_MSK |\n\t\t\tADRF6780_IQ_MODE_EN_MSK |\n\t\t\tADRF6780_LO_X2_EN_MSK |\n\t\t\tADRF6780_LO_PPF_EN_MSK |\n\t\t\tADRF6780_LO_EN_MSK |\n\t\t\tADRF6780_UC_BIAS_EN_MSK;\n\n\tenable_reg = FIELD_PREP(ADRF6780_VGA_BUFFER_EN_MSK, st->vga_buff_en) |\n\t\t\tFIELD_PREP(ADRF6780_DETECTOR_EN_MSK, 1) |\n\t\t\tFIELD_PREP(ADRF6780_LO_BUFFER_EN_MSK, st->lo_buff_en) |\n\t\t\tFIELD_PREP(ADRF6780_IF_MODE_EN_MSK, st->if_mode_en) |\n\t\t\tFIELD_PREP(ADRF6780_IQ_MODE_EN_MSK, st->iq_mode_en) |\n\t\t\tFIELD_PREP(ADRF6780_LO_X2_EN_MSK, st->lo_x2_en) |\n\t\t\tFIELD_PREP(ADRF6780_LO_PPF_EN_MSK, st->lo_ppf_en) |\n\t\t\tFIELD_PREP(ADRF6780_LO_EN_MSK, st->lo_en) |\n\t\t\tFIELD_PREP(ADRF6780_UC_BIAS_EN_MSK, st->uc_bias_en);\n\n\tret = __adrf6780_spi_update_bits(st, ADRF6780_REG_ENABLE,\n\t\t\t\t\t enable_reg_msk, enable_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __adrf6780_spi_update_bits(st, ADRF6780_REG_LO_PATH,\n\t\t\t\t\t ADRF6780_LO_SIDEBAND_MSK,\n\t\t\t\t\t FIELD_PREP(ADRF6780_LO_SIDEBAND_MSK, st->lo_sideband));\n\tif (ret)\n\t\treturn ret;\n\n\treturn __adrf6780_spi_update_bits(st, ADRF6780_REG_ADC_CONTROL,\n\t\tADRF6780_VDET_OUTPUT_SELECT_MSK,\n\t\tFIELD_PREP(ADRF6780_VDET_OUTPUT_SELECT_MSK, st->vdet_out_en));\n}\n\nstatic void adrf6780_properties_parse(struct adrf6780_state *st)\n{\n\tstruct spi_device *spi = st->spi;\n\n\tst->vga_buff_en = device_property_read_bool(&spi->dev, \"adi,vga-buff-en\");\n\tst->lo_buff_en = device_property_read_bool(&spi->dev, \"adi,lo-buff-en\");\n\tst->if_mode_en = device_property_read_bool(&spi->dev, \"adi,if-mode-en\");\n\tst->iq_mode_en = device_property_read_bool(&spi->dev, \"adi,iq-mode-en\");\n\tst->lo_x2_en = device_property_read_bool(&spi->dev, \"adi,lo-x2-en\");\n\tst->lo_ppf_en = device_property_read_bool(&spi->dev, \"adi,lo-ppf-en\");\n\tst->lo_en = device_property_read_bool(&spi->dev, \"adi,lo-en\");\n\tst->uc_bias_en = device_property_read_bool(&spi->dev, \"adi,uc-bias-en\");\n\tst->lo_sideband = device_property_read_bool(&spi->dev, \"adi,lo-sideband\");\n\tst->vdet_out_en = device_property_read_bool(&spi->dev, \"adi,vdet-out-en\");\n}\n\nstatic void adrf6780_powerdown(void *data)\n{\n\t \n\tadrf6780_spi_write(data, ADRF6780_REG_ENABLE, 0x0);\n}\n\nstatic int adrf6780_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct adrf6780_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tindio_dev->info = &adrf6780_info;\n\tindio_dev->name = \"adrf6780\";\n\tindio_dev->channels = adrf6780_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adrf6780_channels);\n\n\tst->spi = spi;\n\n\tadrf6780_properties_parse(st);\n\n\tst->clkin = devm_clk_get_enabled(&spi->dev, \"lo_in\");\n\tif (IS_ERR(st->clkin))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(st->clkin),\n\t\t\t\t     \"failed to get the LO input clock\\n\");\n\n\tmutex_init(&st->lock);\n\n\tret = adrf6780_init(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, adrf6780_powerdown, st);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id adrf6780_id[] = {\n\t{ \"adrf6780\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, adrf6780_id);\n\nstatic const struct of_device_id adrf6780_of_match[] = {\n\t{ .compatible = \"adi,adrf6780\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, adrf6780_of_match);\n\nstatic struct spi_driver adrf6780_driver = {\n\t.driver = {\n\t\t.name = \"adrf6780\",\n\t\t.of_match_table = adrf6780_of_match,\n\t},\n\t.probe = adrf6780_probe,\n\t.id_table = adrf6780_id,\n};\nmodule_spi_driver(adrf6780_driver);\n\nMODULE_AUTHOR(\"Antoniu Miclaus <antoniu.miclaus@analog.com\");\nMODULE_DESCRIPTION(\"Analog Devices ADRF6780\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}