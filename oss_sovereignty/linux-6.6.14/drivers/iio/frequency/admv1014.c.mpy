{
  "module_name": "admv1014.c",
  "hash_id": "bb2acdb77a91d29f69c43c85435d8bcad529553dafec3b3c1d6e57a3bf2d966a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/frequency/admv1014.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/device.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/notifier.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/units.h>\n\n#include <asm/unaligned.h>\n\n \n#define ADMV1014_REG_SPI_CONTROL\t\t0x00\n#define ADMV1014_REG_ALARM\t\t\t0x01\n#define ADMV1014_REG_ALARM_MASKS\t\t0x02\n#define ADMV1014_REG_ENABLE\t\t\t0x03\n#define ADMV1014_REG_QUAD\t\t\t0x04\n#define ADMV1014_REG_LO_AMP_PHASE_ADJUST1\t0x05\n#define ADMV1014_REG_MIXER\t\t\t0x07\n#define ADMV1014_REG_IF_AMP\t\t\t0x08\n#define ADMV1014_REG_IF_AMP_BB_AMP\t\t0x09\n#define ADMV1014_REG_BB_AMP_AGC\t\t\t0x0A\n#define ADMV1014_REG_VVA_TEMP_COMP\t\t0x0B\n\n \n#define ADMV1014_PARITY_EN_MSK\t\t\tBIT(15)\n#define ADMV1014_SPI_SOFT_RESET_MSK\t\tBIT(14)\n#define ADMV1014_CHIP_ID_MSK\t\t\tGENMASK(11, 4)\n#define ADMV1014_CHIP_ID\t\t\t0x9\n#define ADMV1014_REVISION_ID_MSK\t\tGENMASK(3, 0)\n\n \n#define ADMV1014_PARITY_ERROR_MSK\t\tBIT(15)\n#define ADMV1014_TOO_FEW_ERRORS_MSK\t\tBIT(14)\n#define ADMV1014_TOO_MANY_ERRORS_MSK\t\tBIT(13)\n#define ADMV1014_ADDRESS_RANGE_ERROR_MSK\tBIT(12)\n\n \n#define ADMV1014_IBIAS_PD_MSK\t\t\tBIT(14)\n#define ADMV1014_P1DB_COMPENSATION_MSK\t\tGENMASK(13, 12)\n#define ADMV1014_IF_AMP_PD_MSK\t\t\tBIT(11)\n#define ADMV1014_QUAD_BG_PD_MSK\t\t\tBIT(9)\n#define ADMV1014_BB_AMP_PD_MSK\t\t\tBIT(8)\n#define ADMV1014_QUAD_IBIAS_PD_MSK\t\tBIT(7)\n#define ADMV1014_DET_EN_MSK\t\t\tBIT(6)\n#define ADMV1014_BG_PD_MSK\t\t\tBIT(5)\n\n \n#define ADMV1014_QUAD_SE_MODE_MSK\t\tGENMASK(9, 6)\n#define ADMV1014_QUAD_FILTERS_MSK\t\tGENMASK(3, 0)\n\n \n#define ADMV1014_LOAMP_PH_ADJ_I_FINE_MSK\tGENMASK(15, 9)\n#define ADMV1014_LOAMP_PH_ADJ_Q_FINE_MSK\tGENMASK(8, 2)\n\n \n#define ADMV1014_MIXER_VGATE_MSK\t\tGENMASK(15, 9)\n#define ADMV1014_DET_PROG_MSK\t\t\tGENMASK(6, 0)\n\n \n#define ADMV1014_IF_AMP_COARSE_GAIN_I_MSK\tGENMASK(11, 8)\n#define ADMV1014_IF_AMP_FINE_GAIN_Q_MSK\t\tGENMASK(7, 4)\n#define ADMV1014_IF_AMP_FINE_GAIN_I_MSK\t\tGENMASK(3, 0)\n\n \n#define ADMV1014_IF_AMP_COARSE_GAIN_Q_MSK\tGENMASK(15, 12)\n#define ADMV1014_BB_AMP_OFFSET_Q_MSK\t\tGENMASK(9, 5)\n#define ADMV1014_BB_AMP_OFFSET_I_MSK\t\tGENMASK(4, 0)\n\n \n#define ADMV1014_BB_AMP_REF_GEN_MSK\t\tGENMASK(6, 3)\n#define ADMV1014_BB_AMP_GAIN_CTRL_MSK\t\tGENMASK(2, 1)\n#define ADMV1014_BB_SWITCH_HIGH_LOW_CM_MSK\tBIT(0)\n\n \n#define ADMV1014_VVA_TEMP_COMP_MSK\t\tGENMASK(15, 0)\n\n \n#define ADMV1014_READ\t\t\t\tBIT(7)\n#define ADMV1014_REG_ADDR_READ_MSK\t\tGENMASK(6, 1)\n#define ADMV1014_REG_ADDR_WRITE_MSK\t\tGENMASK(22, 17)\n#define ADMV1014_REG_DATA_MSK\t\t\tGENMASK(16, 1)\n#define ADMV1014_NUM_REGULATORS\t\t\t9\n\nenum {\n\tADMV1014_IQ_MODE,\n\tADMV1014_IF_MODE,\n};\n\nenum {\n\tADMV1014_SE_MODE_POS = 6,\n\tADMV1014_SE_MODE_NEG = 9,\n\tADMV1014_SE_MODE_DIFF = 12,\n};\n\nenum {\n\tADMV1014_CALIBSCALE_COARSE,\n\tADMV1014_CALIBSCALE_FINE,\n};\n\nstatic const int detector_table[] = {0, 1, 2, 4, 8, 16, 32, 64};\n\nstatic const char * const input_mode_names[] = { \"iq\", \"if\" };\n\nstatic const char * const quad_se_mode_names[] = { \"se-pos\", \"se-neg\", \"diff\" };\n\nstruct admv1014_state {\n\tstruct spi_device\t\t*spi;\n\tstruct clk\t\t\t*clkin;\n\tstruct notifier_block\t\tnb;\n\t \n\tstruct mutex\t\t\tlock;\n\tstruct regulator_bulk_data\tregulators[ADMV1014_NUM_REGULATORS];\n\tunsigned int\t\t\tinput_mode;\n\tunsigned int\t\t\tquad_se_mode;\n\tunsigned int\t\t\tp1db_comp;\n\tbool\t\t\t\tdet_en;\n\tu8\t\t\t\tdata[3] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic const int mixer_vgate_table[] = {106, 107, 108, 110, 111, 112, 113, 114,\n\t\t\t\t\t117, 118, 119, 120, 122, 123, 44, 45};\n\nstatic int __admv1014_spi_read(struct admv1014_state *st, unsigned int reg,\n\t\t\t       unsigned int *val)\n{\n\tstruct spi_transfer t = {};\n\tint ret;\n\n\tst->data[0] = ADMV1014_READ | FIELD_PREP(ADMV1014_REG_ADDR_READ_MSK, reg);\n\tst->data[1] = 0;\n\tst->data[2] = 0;\n\n\tt.rx_buf = &st->data[0];\n\tt.tx_buf = &st->data[0];\n\tt.len = sizeof(st->data);\n\n\tret = spi_sync_transfer(st->spi, &t, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = FIELD_GET(ADMV1014_REG_DATA_MSK, get_unaligned_be24(&st->data[0]));\n\n\treturn ret;\n}\n\nstatic int admv1014_spi_read(struct admv1014_state *st, unsigned int reg,\n\t\t\t     unsigned int *val)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __admv1014_spi_read(st, reg, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int __admv1014_spi_write(struct admv1014_state *st,\n\t\t\t\tunsigned int reg,\n\t\t\t\tunsigned int val)\n{\n\tput_unaligned_be24(FIELD_PREP(ADMV1014_REG_DATA_MSK, val) |\n\t\t\t   FIELD_PREP(ADMV1014_REG_ADDR_WRITE_MSK, reg), &st->data[0]);\n\n\treturn spi_write(st->spi, &st->data[0], 3);\n}\n\nstatic int admv1014_spi_write(struct admv1014_state *st, unsigned int reg,\n\t\t\t      unsigned int val)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __admv1014_spi_write(st, reg, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int __admv1014_spi_update_bits(struct admv1014_state *st, unsigned int reg,\n\t\t\t\t      unsigned int mask, unsigned int val)\n{\n\tunsigned int data, temp;\n\tint ret;\n\n\tret = __admv1014_spi_read(st, reg, &data);\n\tif (ret)\n\t\treturn ret;\n\n\ttemp = (data & ~mask) | (val & mask);\n\n\treturn __admv1014_spi_write(st, reg, temp);\n}\n\nstatic int admv1014_spi_update_bits(struct admv1014_state *st, unsigned int reg,\n\t\t\t\t    unsigned int mask, unsigned int val)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __admv1014_spi_update_bits(st, reg, mask, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int admv1014_update_quad_filters(struct admv1014_state *st)\n{\n\tunsigned int filt_raw;\n\tu64 rate = clk_get_rate(st->clkin);\n\n\tif (rate >= (5400 * HZ_PER_MHZ) && rate <= (7000 * HZ_PER_MHZ))\n\t\tfilt_raw = 15;\n\telse if (rate > (7000 * HZ_PER_MHZ) && rate <= (8000 * HZ_PER_MHZ))\n\t\tfilt_raw = 10;\n\telse if (rate > (8000 * HZ_PER_MHZ) && rate <= (9200 * HZ_PER_MHZ))\n\t\tfilt_raw = 5;\n\telse\n\t\tfilt_raw = 0;\n\n\treturn __admv1014_spi_update_bits(st, ADMV1014_REG_QUAD,\n\t\t\t\t\tADMV1014_QUAD_FILTERS_MSK,\n\t\t\t\t\tFIELD_PREP(ADMV1014_QUAD_FILTERS_MSK, filt_raw));\n}\n\nstatic int admv1014_update_vcm_settings(struct admv1014_state *st)\n{\n\tunsigned int i, vcm_mv, vcm_comp, bb_sw_hl_cm;\n\tint ret;\n\n\tvcm_mv = regulator_get_voltage(st->regulators[0].consumer) / 1000;\n\tfor (i = 0; i < ARRAY_SIZE(mixer_vgate_table); i++) {\n\t\tvcm_comp = 1050 + mult_frac(i, 450, 8);\n\t\tif (vcm_mv != vcm_comp)\n\t\t\tcontinue;\n\n\t\tret = __admv1014_spi_update_bits(st, ADMV1014_REG_MIXER,\n\t\t\t\t\t\t ADMV1014_MIXER_VGATE_MSK,\n\t\t\t\t\t\t FIELD_PREP(ADMV1014_MIXER_VGATE_MSK,\n\t\t\t\t\t\t\t    mixer_vgate_table[i]));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbb_sw_hl_cm = ~(i / 8);\n\t\tbb_sw_hl_cm = FIELD_PREP(ADMV1014_BB_SWITCH_HIGH_LOW_CM_MSK, bb_sw_hl_cm);\n\n\t\treturn __admv1014_spi_update_bits(st, ADMV1014_REG_BB_AMP_AGC,\n\t\t\t\t\t\t  ADMV1014_BB_AMP_REF_GEN_MSK |\n\t\t\t\t\t\t  ADMV1014_BB_SWITCH_HIGH_LOW_CM_MSK,\n\t\t\t\t\t\t  FIELD_PREP(ADMV1014_BB_AMP_REF_GEN_MSK, i) |\n\t\t\t\t\t\t  bb_sw_hl_cm);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int admv1014_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long info)\n{\n\tstruct admv1014_state *st = iio_priv(indio_dev);\n\tunsigned int data;\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tret = admv1014_spi_read(st, ADMV1014_REG_IF_AMP_BB_AMP, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (chan->channel2 == IIO_MOD_I)\n\t\t\t*val = FIELD_GET(ADMV1014_BB_AMP_OFFSET_I_MSK, data);\n\t\telse\n\t\t\t*val = FIELD_GET(ADMV1014_BB_AMP_OFFSET_Q_MSK, data);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_PHASE:\n\t\tret = admv1014_spi_read(st, ADMV1014_REG_LO_AMP_PHASE_ADJUST1, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (chan->channel2 == IIO_MOD_I)\n\t\t\t*val = FIELD_GET(ADMV1014_LOAMP_PH_ADJ_I_FINE_MSK, data);\n\t\telse\n\t\t\t*val = FIELD_GET(ADMV1014_LOAMP_PH_ADJ_Q_FINE_MSK, data);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = admv1014_spi_read(st, ADMV1014_REG_MIXER, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = FIELD_GET(ADMV1014_DET_PROG_MSK, data);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tret = admv1014_spi_read(st, ADMV1014_REG_BB_AMP_AGC, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = FIELD_GET(ADMV1014_BB_AMP_GAIN_CTRL_MSK, data);\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int admv1014_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long info)\n{\n\tint data;\n\tunsigned int msk;\n\tstruct admv1014_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (chan->channel2 == IIO_MOD_I) {\n\t\t\tmsk = ADMV1014_BB_AMP_OFFSET_I_MSK;\n\t\t\tdata = FIELD_PREP(ADMV1014_BB_AMP_OFFSET_I_MSK, val);\n\t\t} else {\n\t\t\tmsk = ADMV1014_BB_AMP_OFFSET_Q_MSK;\n\t\t\tdata = FIELD_PREP(ADMV1014_BB_AMP_OFFSET_Q_MSK, val);\n\t\t}\n\n\t\treturn admv1014_spi_update_bits(st, ADMV1014_REG_IF_AMP_BB_AMP, msk, data);\n\tcase IIO_CHAN_INFO_PHASE:\n\t\tif (chan->channel2 == IIO_MOD_I) {\n\t\t\tmsk = ADMV1014_LOAMP_PH_ADJ_I_FINE_MSK;\n\t\t\tdata = FIELD_PREP(ADMV1014_LOAMP_PH_ADJ_I_FINE_MSK, val);\n\t\t} else {\n\t\t\tmsk = ADMV1014_LOAMP_PH_ADJ_Q_FINE_MSK;\n\t\t\tdata = FIELD_PREP(ADMV1014_LOAMP_PH_ADJ_Q_FINE_MSK, val);\n\t\t}\n\n\t\treturn admv1014_spi_update_bits(st, ADMV1014_REG_LO_AMP_PHASE_ADJUST1, msk, data);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn admv1014_spi_update_bits(st, ADMV1014_REG_MIXER,\n\t\t\t\t\t\tADMV1014_DET_PROG_MSK,\n\t\t\t\t\t\tFIELD_PREP(ADMV1014_DET_PROG_MSK, val));\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\treturn admv1014_spi_update_bits(st, ADMV1014_REG_BB_AMP_AGC,\n\t\t\t\t\t\tADMV1014_BB_AMP_GAIN_CTRL_MSK,\n\t\t\t\t\t\tFIELD_PREP(ADMV1014_BB_AMP_GAIN_CTRL_MSK, val));\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t admv1014_read(struct iio_dev *indio_dev,\n\t\t\t     uintptr_t private,\n\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t     char *buf)\n{\n\tstruct admv1014_state *st = iio_priv(indio_dev);\n\tunsigned int data;\n\tint ret;\n\n\tswitch (private) {\n\tcase ADMV1014_CALIBSCALE_COARSE:\n\t\tif (chan->channel2 == IIO_MOD_I) {\n\t\t\tret = admv1014_spi_read(st, ADMV1014_REG_IF_AMP, &data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tdata = FIELD_GET(ADMV1014_IF_AMP_COARSE_GAIN_I_MSK, data);\n\t\t} else {\n\t\t\tret = admv1014_spi_read(st, ADMV1014_REG_IF_AMP_BB_AMP, &data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tdata = FIELD_GET(ADMV1014_IF_AMP_COARSE_GAIN_Q_MSK, data);\n\t\t}\n\t\tbreak;\n\tcase ADMV1014_CALIBSCALE_FINE:\n\t\tret = admv1014_spi_read(st, ADMV1014_REG_IF_AMP, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (chan->channel2 == IIO_MOD_I)\n\t\t\tdata = FIELD_GET(ADMV1014_IF_AMP_FINE_GAIN_I_MSK, data);\n\t\telse\n\t\t\tdata = FIELD_GET(ADMV1014_IF_AMP_FINE_GAIN_Q_MSK, data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sysfs_emit(buf, \"%u\\n\", data);\n}\n\nstatic ssize_t admv1014_write(struct iio_dev *indio_dev,\n\t\t\t      uintptr_t private,\n\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t      const char *buf, size_t len)\n{\n\tstruct admv1014_state *st = iio_priv(indio_dev);\n\tunsigned int data, addr, msk;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (private) {\n\tcase ADMV1014_CALIBSCALE_COARSE:\n\t\tif (chan->channel2 == IIO_MOD_I) {\n\t\t\taddr = ADMV1014_REG_IF_AMP;\n\t\t\tmsk = ADMV1014_IF_AMP_COARSE_GAIN_I_MSK;\n\t\t\tdata = FIELD_PREP(ADMV1014_IF_AMP_COARSE_GAIN_I_MSK, data);\n\t\t} else {\n\t\t\taddr = ADMV1014_REG_IF_AMP_BB_AMP;\n\t\t\tmsk = ADMV1014_IF_AMP_COARSE_GAIN_Q_MSK;\n\t\t\tdata = FIELD_PREP(ADMV1014_IF_AMP_COARSE_GAIN_Q_MSK, data);\n\t\t}\n\t\tbreak;\n\tcase ADMV1014_CALIBSCALE_FINE:\n\t\taddr = ADMV1014_REG_IF_AMP;\n\n\t\tif (chan->channel2 == IIO_MOD_I) {\n\t\t\tmsk = ADMV1014_IF_AMP_FINE_GAIN_I_MSK;\n\t\t\tdata = FIELD_PREP(ADMV1014_IF_AMP_FINE_GAIN_I_MSK, data);\n\t\t} else {\n\t\t\tmsk = ADMV1014_IF_AMP_FINE_GAIN_Q_MSK;\n\t\t\tdata = FIELD_PREP(ADMV1014_IF_AMP_FINE_GAIN_Q_MSK, data);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = admv1014_spi_update_bits(st, addr, msk, data);\n\n\treturn ret ? ret : len;\n}\n\nstatic int admv1014_read_avail(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length,\n\t\t\t       long info)\n{\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*vals = detector_table;\n\t\t*type = IIO_VAL_INT;\n\t\t*length = ARRAY_SIZE(detector_table);\n\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int admv1014_reg_access(struct iio_dev *indio_dev,\n\t\t\t       unsigned int reg,\n\t\t\t       unsigned int write_val,\n\t\t\t       unsigned int *read_val)\n{\n\tstruct admv1014_state *st = iio_priv(indio_dev);\n\n\tif (read_val)\n\t\treturn admv1014_spi_read(st, reg, read_val);\n\telse\n\t\treturn admv1014_spi_write(st, reg, write_val);\n}\n\nstatic const struct iio_info admv1014_info = {\n\t.read_raw = admv1014_read_raw,\n\t.write_raw = admv1014_write_raw,\n\t.read_avail = &admv1014_read_avail,\n\t.debugfs_reg_access = &admv1014_reg_access,\n};\n\nstatic const char * const admv1014_reg_name[] = {\n\t \"vcm\", \"vcc-if-bb\", \"vcc-vga\", \"vcc-vva\", \"vcc-lna-3p3\",\n\t \"vcc-lna-1p5\", \"vcc-bg\", \"vcc-quad\", \"vcc-mixer\"\n};\n\nstatic int admv1014_freq_change(struct notifier_block *nb, unsigned long action, void *data)\n{\n\tstruct admv1014_state *st = container_of(nb, struct admv1014_state, nb);\n\tint ret;\n\n\tif (action == POST_RATE_CHANGE) {\n\t\tmutex_lock(&st->lock);\n\t\tret = notifier_from_errno(admv1014_update_quad_filters(st));\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\n#define _ADMV1014_EXT_INFO(_name, _shared, _ident) { \\\n\t\t.name = _name, \\\n\t\t.read = admv1014_read, \\\n\t\t.write = admv1014_write, \\\n\t\t.private = _ident, \\\n\t\t.shared = _shared, \\\n}\n\nstatic const struct iio_chan_spec_ext_info admv1014_ext_info[] = {\n\t_ADMV1014_EXT_INFO(\"calibscale_coarse\", IIO_SEPARATE, ADMV1014_CALIBSCALE_COARSE),\n\t_ADMV1014_EXT_INFO(\"calibscale_fine\", IIO_SEPARATE, ADMV1014_CALIBSCALE_FINE),\n\t{ }\n};\n\n#define ADMV1014_CHAN_IQ(_channel, rf_comp) {\t\t\t\t\\\n\t.type = IIO_ALTVOLTAGE,\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.output = 0,\t\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##rf_comp,\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_PHASE) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_OFFSET),\t\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_CALIBSCALE),\t\\\n\t}\n\n#define ADMV1014_CHAN_IF(_channel, rf_comp) {\t\t\t\t\\\n\t.type = IIO_ALTVOLTAGE,\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.output = 0,\t\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##rf_comp,\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_PHASE) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_OFFSET),\t\t\t\t\\\n\t}\n\n#define ADMV1014_CHAN_POWER(_channel) {\t\t\t\t\t\\\n\t.type = IIO_POWER,\t\t\t\t\t\t\\\n\t.output = 0,\t\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_SCALE),\t\t\t\\\n\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t}\n\n#define ADMV1014_CHAN_CALIBSCALE(_channel, rf_comp, _admv1014_ext_info) {\t\\\n\t.type = IIO_ALTVOLTAGE,\t\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\t\\\n\t.output = 0,\t\t\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##rf_comp,\t\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\t\t\\\n\t.ext_info = _admv1014_ext_info,\t\t\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec admv1014_channels_iq[] = {\n\tADMV1014_CHAN_IQ(0, I),\n\tADMV1014_CHAN_IQ(0, Q),\n\tADMV1014_CHAN_POWER(0),\n};\n\nstatic const struct iio_chan_spec admv1014_channels_if[] = {\n\tADMV1014_CHAN_IF(0, I),\n\tADMV1014_CHAN_IF(0, Q),\n\tADMV1014_CHAN_CALIBSCALE(0, I, admv1014_ext_info),\n\tADMV1014_CHAN_CALIBSCALE(0, Q, admv1014_ext_info),\n\tADMV1014_CHAN_POWER(0),\n};\n\nstatic void admv1014_clk_disable(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic void admv1014_reg_disable(void *data)\n{\n\tregulator_bulk_disable(ADMV1014_NUM_REGULATORS, data);\n}\n\nstatic void admv1014_powerdown(void *data)\n{\n\tunsigned int enable_reg, enable_reg_msk;\n\n\t \n\tenable_reg_msk = ADMV1014_IBIAS_PD_MSK |\n\t\t\tADMV1014_IF_AMP_PD_MSK |\n\t\t\tADMV1014_QUAD_BG_PD_MSK |\n\t\t\tADMV1014_BB_AMP_PD_MSK |\n\t\t\tADMV1014_QUAD_IBIAS_PD_MSK |\n\t\t\tADMV1014_BG_PD_MSK;\n\n\tenable_reg = FIELD_PREP(ADMV1014_IBIAS_PD_MSK, 1) |\n\t\t\tFIELD_PREP(ADMV1014_IF_AMP_PD_MSK, 1) |\n\t\t\tFIELD_PREP(ADMV1014_QUAD_BG_PD_MSK, 1) |\n\t\t\tFIELD_PREP(ADMV1014_BB_AMP_PD_MSK, 1) |\n\t\t\tFIELD_PREP(ADMV1014_QUAD_IBIAS_PD_MSK, 1) |\n\t\t\tFIELD_PREP(ADMV1014_BG_PD_MSK, 1);\n\n\tadmv1014_spi_update_bits(data, ADMV1014_REG_ENABLE,\n\t\t\t\t enable_reg_msk, enable_reg);\n}\n\nstatic int admv1014_init(struct admv1014_state *st)\n{\n\tunsigned int chip_id, enable_reg, enable_reg_msk;\n\tstruct spi_device *spi = st->spi;\n\tint ret;\n\n\tret = regulator_bulk_enable(ADMV1014_NUM_REGULATORS, st->regulators);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to enable regulators\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&spi->dev, admv1014_reg_disable, st->regulators);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(st->clkin);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, admv1014_clk_disable, st->clkin);\n\tif (ret)\n\t\treturn ret;\n\n\tst->nb.notifier_call = admv1014_freq_change;\n\tret = devm_clk_notifier_register(&spi->dev, st->clkin, &st->nb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, admv1014_powerdown, st);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = __admv1014_spi_update_bits(st, ADMV1014_REG_SPI_CONTROL,\n\t\t\t\t\t ADMV1014_SPI_SOFT_RESET_MSK,\n\t\t\t\t\t FIELD_PREP(ADMV1014_SPI_SOFT_RESET_MSK, 1));\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"ADMV1014 SPI software reset failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = __admv1014_spi_update_bits(st, ADMV1014_REG_SPI_CONTROL,\n\t\t\t\t\t ADMV1014_SPI_SOFT_RESET_MSK,\n\t\t\t\t\t FIELD_PREP(ADMV1014_SPI_SOFT_RESET_MSK, 0));\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"ADMV1014 SPI software reset disable failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = __admv1014_spi_write(st, ADMV1014_REG_VVA_TEMP_COMP, 0x727C);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Writing default Temperature Compensation value failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = __admv1014_spi_read(st, ADMV1014_REG_SPI_CONTROL, &chip_id);\n\tif (ret)\n\t\treturn ret;\n\n\tchip_id = FIELD_GET(ADMV1014_CHIP_ID_MSK, chip_id);\n\tif (chip_id != ADMV1014_CHIP_ID) {\n\t\tdev_err(&spi->dev, \"Invalid Chip ID.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = __admv1014_spi_update_bits(st, ADMV1014_REG_QUAD,\n\t\t\t\t\t ADMV1014_QUAD_SE_MODE_MSK,\n\t\t\t\t\t FIELD_PREP(ADMV1014_QUAD_SE_MODE_MSK,\n\t\t\t\t\t\t    st->quad_se_mode));\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Writing Quad SE Mode failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = admv1014_update_quad_filters(st);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Update Quad Filters failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = admv1014_update_vcm_settings(st);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Update VCM Settings failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tenable_reg_msk = ADMV1014_P1DB_COMPENSATION_MSK |\n\t\t\t ADMV1014_IF_AMP_PD_MSK |\n\t\t\t ADMV1014_BB_AMP_PD_MSK |\n\t\t\t ADMV1014_DET_EN_MSK;\n\n\tenable_reg = FIELD_PREP(ADMV1014_P1DB_COMPENSATION_MSK, st->p1db_comp ? 3 : 0) |\n\t\t     FIELD_PREP(ADMV1014_IF_AMP_PD_MSK,\n\t\t\t\t(st->input_mode == ADMV1014_IF_MODE) ? 0 : 1) |\n\t\t     FIELD_PREP(ADMV1014_BB_AMP_PD_MSK,\n\t\t\t\t(st->input_mode == ADMV1014_IF_MODE) ? 1 : 0) |\n\t\t     FIELD_PREP(ADMV1014_DET_EN_MSK, st->det_en);\n\n\treturn __admv1014_spi_update_bits(st, ADMV1014_REG_ENABLE, enable_reg_msk, enable_reg);\n}\n\nstatic int admv1014_properties_parse(struct admv1014_state *st)\n{\n\tconst char *str;\n\tunsigned int i;\n\tstruct spi_device *spi = st->spi;\n\tint ret;\n\n\tst->det_en = device_property_read_bool(&spi->dev, \"adi,detector-enable\");\n\n\tst->p1db_comp = device_property_read_bool(&spi->dev, \"adi,p1db-compensation-enable\");\n\n\tret = device_property_read_string(&spi->dev, \"adi,input-mode\", &str);\n\tif (ret) {\n\t\tst->input_mode = ADMV1014_IQ_MODE;\n\t} else {\n\t\tret = match_string(input_mode_names, ARRAY_SIZE(input_mode_names), str);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tst->input_mode = ret;\n\t}\n\n\tret = device_property_read_string(&spi->dev, \"adi,quad-se-mode\", &str);\n\tif (ret) {\n\t\tst->quad_se_mode = ADMV1014_SE_MODE_POS;\n\t} else {\n\t\tret = match_string(quad_se_mode_names, ARRAY_SIZE(quad_se_mode_names), str);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tst->quad_se_mode = ADMV1014_SE_MODE_POS + (ret * 3);\n\t}\n\n\tfor (i = 0; i < ADMV1014_NUM_REGULATORS; ++i)\n\t\tst->regulators[i].supply = admv1014_reg_name[i];\n\n\tret = devm_regulator_bulk_get(&st->spi->dev, ADMV1014_NUM_REGULATORS,\n\t\t\t\t      st->regulators);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to request regulators\");\n\t\treturn ret;\n\t}\n\n\tst->clkin = devm_clk_get(&spi->dev, \"lo_in\");\n\tif (IS_ERR(st->clkin))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(st->clkin),\n\t\t\t\t     \"failed to get the LO input clock\\n\");\n\n\treturn 0;\n}\n\nstatic int admv1014_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct admv1014_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tret = admv1014_properties_parse(st);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->info = &admv1014_info;\n\tindio_dev->name = \"admv1014\";\n\n\tif (st->input_mode == ADMV1014_IQ_MODE) {\n\t\tindio_dev->channels = admv1014_channels_iq;\n\t\tindio_dev->num_channels = ARRAY_SIZE(admv1014_channels_iq);\n\t} else {\n\t\tindio_dev->channels = admv1014_channels_if;\n\t\tindio_dev->num_channels = ARRAY_SIZE(admv1014_channels_if);\n\t}\n\n\tst->spi = spi;\n\n\tmutex_init(&st->lock);\n\n\tret = admv1014_init(st);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id admv1014_id[] = {\n\t{ \"admv1014\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, admv1014_id);\n\nstatic const struct of_device_id admv1014_of_match[] = {\n\t{ .compatible = \"adi,admv1014\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, admv1014_of_match);\n\nstatic struct spi_driver admv1014_driver = {\n\t.driver = {\n\t\t.name = \"admv1014\",\n\t\t.of_match_table = admv1014_of_match,\n\t},\n\t.probe = admv1014_probe,\n\t.id_table = admv1014_id,\n};\nmodule_spi_driver(admv1014_driver);\n\nMODULE_AUTHOR(\"Antoniu Miclaus <antoniu.miclaus@analog.com\");\nMODULE_DESCRIPTION(\"Analog Devices ADMV1014\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}