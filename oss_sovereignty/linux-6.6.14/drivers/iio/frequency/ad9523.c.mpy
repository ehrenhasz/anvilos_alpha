{
  "module_name": "ad9523.c",
  "hash_id": "64fe5239b4ab43ac6c77df717df98dc732ab6d2b7039b063d9849a6e57533d6c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/frequency/ad9523.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/frequency/ad9523.h>\n\n#define AD9523_READ\t(1 << 15)\n#define AD9523_WRITE\t(0 << 15)\n#define AD9523_CNT(x)\t(((x) - 1) << 13)\n#define AD9523_ADDR(x)\t((x) & 0xFFF)\n\n#define AD9523_R1B\t(1 << 16)\n#define AD9523_R2B\t(2 << 16)\n#define AD9523_R3B\t(3 << 16)\n#define AD9523_TRANSF_LEN(x)\t\t\t((x) >> 16)\n\n#define AD9523_SERIAL_PORT_CONFIG\t\t(AD9523_R1B | 0x0)\n#define AD9523_VERSION_REGISTER\t\t\t(AD9523_R1B | 0x2)\n#define AD9523_PART_REGISTER\t\t\t(AD9523_R1B | 0x3)\n#define AD9523_READBACK_CTRL\t\t\t(AD9523_R1B | 0x4)\n\n#define AD9523_EEPROM_CUSTOMER_VERSION_ID\t(AD9523_R2B | 0x6)\n\n#define AD9523_PLL1_REF_A_DIVIDER\t\t(AD9523_R2B | 0x11)\n#define AD9523_PLL1_REF_B_DIVIDER\t\t(AD9523_R2B | 0x13)\n#define AD9523_PLL1_REF_TEST_DIVIDER\t\t(AD9523_R1B | 0x14)\n#define AD9523_PLL1_FEEDBACK_DIVIDER\t\t(AD9523_R2B | 0x17)\n#define AD9523_PLL1_CHARGE_PUMP_CTRL\t\t(AD9523_R2B | 0x19)\n#define AD9523_PLL1_INPUT_RECEIVERS_CTRL\t(AD9523_R1B | 0x1A)\n#define AD9523_PLL1_REF_CTRL\t\t\t(AD9523_R1B | 0x1B)\n#define AD9523_PLL1_MISC_CTRL\t\t\t(AD9523_R1B | 0x1C)\n#define AD9523_PLL1_LOOP_FILTER_CTRL\t\t(AD9523_R1B | 0x1D)\n\n#define AD9523_PLL2_CHARGE_PUMP\t\t\t(AD9523_R1B | 0xF0)\n#define AD9523_PLL2_FEEDBACK_DIVIDER_AB\t\t(AD9523_R1B | 0xF1)\n#define AD9523_PLL2_CTRL\t\t\t(AD9523_R1B | 0xF2)\n#define AD9523_PLL2_VCO_CTRL\t\t\t(AD9523_R1B | 0xF3)\n#define AD9523_PLL2_VCO_DIVIDER\t\t\t(AD9523_R1B | 0xF4)\n#define AD9523_PLL2_LOOP_FILTER_CTRL\t\t(AD9523_R2B | 0xF6)\n#define AD9523_PLL2_R2_DIVIDER\t\t\t(AD9523_R1B | 0xF7)\n\n#define AD9523_CHANNEL_CLOCK_DIST(ch)\t\t(AD9523_R3B | (0x192 + 3 * ch))\n\n#define AD9523_PLL1_OUTPUT_CTRL\t\t\t(AD9523_R1B | 0x1BA)\n#define AD9523_PLL1_OUTPUT_CHANNEL_CTRL\t\t(AD9523_R1B | 0x1BB)\n\n#define AD9523_READBACK_0\t\t\t(AD9523_R1B | 0x22C)\n#define AD9523_READBACK_1\t\t\t(AD9523_R1B | 0x22D)\n\n#define AD9523_STATUS_SIGNALS\t\t\t(AD9523_R3B | 0x232)\n#define AD9523_POWER_DOWN_CTRL\t\t\t(AD9523_R1B | 0x233)\n#define AD9523_IO_UPDATE\t\t\t(AD9523_R1B | 0x234)\n\n#define AD9523_EEPROM_DATA_XFER_STATUS\t\t(AD9523_R1B | 0xB00)\n#define AD9523_EEPROM_ERROR_READBACK\t\t(AD9523_R1B | 0xB01)\n#define AD9523_EEPROM_CTRL1\t\t\t(AD9523_R1B | 0xB02)\n#define AD9523_EEPROM_CTRL2\t\t\t(AD9523_R1B | 0xB03)\n\n \n\n#define AD9523_SER_CONF_SDO_ACTIVE\t\t(1 << 7)\n#define AD9523_SER_CONF_SOFT_RESET\t\t(1 << 5)\n\n \n#define AD9523_READBACK_CTRL_READ_BUFFERED\t(1 << 0)\n\n \n#define AD9523_PLL1_CHARGE_PUMP_CURRENT_nA(x)\t(((x) / 500) & 0x7F)\n#define AD9523_PLL1_CHARGE_PUMP_TRISTATE\t(1 << 7)\n#define AD9523_PLL1_CHARGE_PUMP_MODE_NORMAL\t(3 << 8)\n#define AD9523_PLL1_CHARGE_PUMP_MODE_PUMP_DOWN\t(2 << 8)\n#define AD9523_PLL1_CHARGE_PUMP_MODE_PUMP_UP\t(1 << 8)\n#define AD9523_PLL1_CHARGE_PUMP_MODE_TRISTATE\t(0 << 8)\n#define AD9523_PLL1_BACKLASH_PW_MIN\t\t(0 << 10)\n#define AD9523_PLL1_BACKLASH_PW_LOW\t\t(1 << 10)\n#define AD9523_PLL1_BACKLASH_PW_HIGH\t\t(2 << 10)\n#define AD9523_PLL1_BACKLASH_PW_MAX\t\t(3 << 10)\n\n \n#define AD9523_PLL1_REF_TEST_RCV_EN\t\t(1 << 7)\n#define AD9523_PLL1_REFB_DIFF_RCV_EN\t\t(1 << 6)\n#define AD9523_PLL1_REFA_DIFF_RCV_EN\t\t(1 << 5)\n#define AD9523_PLL1_REFB_RCV_EN\t\t\t(1 << 4)\n#define AD9523_PLL1_REFA_RCV_EN\t\t\t(1 << 3)\n#define AD9523_PLL1_REFA_REFB_PWR_CTRL_EN\t(1 << 2)\n#define AD9523_PLL1_OSC_IN_CMOS_NEG_INP_EN\t(1 << 1)\n#define AD9523_PLL1_OSC_IN_DIFF_EN\t\t(1 << 0)\n\n \n#define AD9523_PLL1_BYPASS_REF_TEST_DIV_EN\t(1 << 7)\n#define AD9523_PLL1_BYPASS_FEEDBACK_DIV_EN\t(1 << 6)\n#define AD9523_PLL1_ZERO_DELAY_MODE_INT\t\t(1 << 5)\n#define AD9523_PLL1_ZERO_DELAY_MODE_EXT\t\t(0 << 5)\n#define AD9523_PLL1_OSC_IN_PLL_FEEDBACK_EN\t(1 << 4)\n#define AD9523_PLL1_ZD_IN_CMOS_NEG_INP_EN\t(1 << 3)\n#define AD9523_PLL1_ZD_IN_DIFF_EN\t\t(1 << 2)\n#define AD9523_PLL1_REFB_CMOS_NEG_INP_EN\t(1 << 1)\n#define AD9523_PLL1_REFA_CMOS_NEG_INP_EN\t(1 << 0)\n\n \n#define AD9523_PLL1_REFB_INDEP_DIV_CTRL_EN\t(1 << 7)\n#define AD9523_PLL1_OSC_CTRL_FAIL_VCC_BY2_EN\t(1 << 6)\n#define AD9523_PLL1_REF_MODE(x)\t\t\t((x) << 2)\n#define AD9523_PLL1_BYPASS_REFB_DIV\t\t(1 << 1)\n#define AD9523_PLL1_BYPASS_REFA_DIV\t\t(1 << 0)\n\n \n#define AD9523_PLL1_LOOP_FILTER_RZERO(x)\t((x) & 0xF)\n\n \n#define AD9523_PLL2_CHARGE_PUMP_CURRENT_nA(x)\t((x) / 3500)\n\n \n#define AD9523_PLL2_FB_NDIV_A_CNT(x)\t\t(((x) & 0x3) << 6)\n#define AD9523_PLL2_FB_NDIV_B_CNT(x)\t\t(((x) & 0x3F) << 0)\n#define AD9523_PLL2_FB_NDIV(a, b)\t\t(4 * (b) + (a))\n\n \n#define AD9523_PLL2_CHARGE_PUMP_MODE_NORMAL\t(3 << 0)\n#define AD9523_PLL2_CHARGE_PUMP_MODE_PUMP_DOWN\t(2 << 0)\n#define AD9523_PLL2_CHARGE_PUMP_MODE_PUMP_UP\t(1 << 0)\n#define AD9523_PLL2_CHARGE_PUMP_MODE_TRISTATE\t(0 << 0)\n#define AD9523_PLL2_BACKLASH_PW_MIN\t\t(0 << 2)\n#define AD9523_PLL2_BACKLASH_PW_LOW\t\t(1 << 2)\n#define AD9523_PLL2_BACKLASH_PW_HIGH\t\t(2 << 2)\n#define AD9523_PLL2_BACKLASH_PW_MAX\t\t(3 << 1)\n#define AD9523_PLL2_BACKLASH_CTRL_EN\t\t(1 << 4)\n#define AD9523_PLL2_FREQ_DOUBLER_EN\t\t(1 << 5)\n#define AD9523_PLL2_LOCK_DETECT_PWR_DOWN_EN\t(1 << 7)\n\n \n#define AD9523_PLL2_VCO_CALIBRATE\t\t(1 << 1)\n#define AD9523_PLL2_FORCE_VCO_MIDSCALE\t\t(1 << 2)\n#define AD9523_PLL2_FORCE_REFERENCE_VALID\t(1 << 3)\n#define AD9523_PLL2_FORCE_RELEASE_SYNC\t\t(1 << 4)\n\n \n#define AD9523_PLL2_VCO_DIV_M1(x)\t\t((((x) - 3) & 0x3) << 0)\n#define AD9523_PLL2_VCO_DIV_M2(x)\t\t((((x) - 3) & 0x3) << 4)\n#define AD9523_PLL2_VCO_DIV_M1_PWR_DOWN_EN\t(1 << 2)\n#define AD9523_PLL2_VCO_DIV_M2_PWR_DOWN_EN\t(1 << 6)\n\n \n#define AD9523_PLL2_LOOP_FILTER_CPOLE1(x)\t(((x) & 0x7) << 0)\n#define AD9523_PLL2_LOOP_FILTER_RZERO(x)\t(((x) & 0x7) << 3)\n#define AD9523_PLL2_LOOP_FILTER_RPOLE2(x)\t(((x) & 0x7) << 6)\n#define AD9523_PLL2_LOOP_FILTER_RZERO_BYPASS_EN\t(1 << 8)\n\n \n#define AD9523_PLL2_R2_DIVIDER_VAL(x)\t\t(((x) & 0x1F) << 0)\n\n \n#define AD9523_CLK_DIST_DIV_PHASE(x)\t\t(((x) & 0x3F) << 18)\n#define AD9523_CLK_DIST_DIV_PHASE_REV(x)\t((ret >> 18) & 0x3F)\n#define AD9523_CLK_DIST_DIV(x)\t\t\t((((x) - 1) & 0x3FF) << 8)\n#define AD9523_CLK_DIST_DIV_REV(x)\t\t(((ret >> 8) & 0x3FF) + 1)\n#define AD9523_CLK_DIST_INV_DIV_OUTPUT_EN\t(1 << 7)\n#define AD9523_CLK_DIST_IGNORE_SYNC_EN\t\t(1 << 6)\n#define AD9523_CLK_DIST_PWR_DOWN_EN\t\t(1 << 5)\n#define AD9523_CLK_DIST_LOW_PWR_MODE_EN\t\t(1 << 4)\n#define AD9523_CLK_DIST_DRIVER_MODE(x)\t\t(((x) & 0xF) << 0)\n\n \n#define AD9523_PLL1_OUTP_CTRL_VCO_DIV_SEL_CH6_M2\t(1 << 7)\n#define AD9523_PLL1_OUTP_CTRL_VCO_DIV_SEL_CH5_M2\t(1 << 6)\n#define AD9523_PLL1_OUTP_CTRL_VCO_DIV_SEL_CH4_M2\t(1 << 5)\n#define AD9523_PLL1_OUTP_CTRL_CMOS_DRV_WEAK\t\t(1 << 4)\n#define AD9523_PLL1_OUTP_CTRL_OUTPUT_DIV_1\t\t(0 << 0)\n#define AD9523_PLL1_OUTP_CTRL_OUTPUT_DIV_2\t\t(1 << 0)\n#define AD9523_PLL1_OUTP_CTRL_OUTPUT_DIV_4\t\t(2 << 0)\n#define AD9523_PLL1_OUTP_CTRL_OUTPUT_DIV_8\t\t(4 << 0)\n#define AD9523_PLL1_OUTP_CTRL_OUTPUT_DIV_16\t\t(8 << 0)\n\n \n#define AD9523_PLL1_OUTP_CH_CTRL_OUTPUT_PWR_DOWN_EN\t(1 << 7)\n#define AD9523_PLL1_OUTP_CH_CTRL_VCO_DIV_SEL_CH9_M2\t(1 << 6)\n#define AD9523_PLL1_OUTP_CH_CTRL_VCO_DIV_SEL_CH8_M2\t(1 << 5)\n#define AD9523_PLL1_OUTP_CH_CTRL_VCO_DIV_SEL_CH7_M2\t(1 << 4)\n#define AD9523_PLL1_OUTP_CH_CTRL_VCXO_SRC_SEL_CH3\t(1 << 3)\n#define AD9523_PLL1_OUTP_CH_CTRL_VCXO_SRC_SEL_CH2\t(1 << 2)\n#define AD9523_PLL1_OUTP_CH_CTRL_VCXO_SRC_SEL_CH1\t(1 << 1)\n#define AD9523_PLL1_OUTP_CH_CTRL_VCXO_SRC_SEL_CH0\t(1 << 0)\n\n \n#define AD9523_READBACK_0_STAT_PLL2_REF_CLK\t\t(1 << 7)\n#define AD9523_READBACK_0_STAT_PLL2_FB_CLK\t\t(1 << 6)\n#define AD9523_READBACK_0_STAT_VCXO\t\t\t(1 << 5)\n#define AD9523_READBACK_0_STAT_REF_TEST\t\t\t(1 << 4)\n#define AD9523_READBACK_0_STAT_REFB\t\t\t(1 << 3)\n#define AD9523_READBACK_0_STAT_REFA\t\t\t(1 << 2)\n#define AD9523_READBACK_0_STAT_PLL2_LD\t\t\t(1 << 1)\n#define AD9523_READBACK_0_STAT_PLL1_LD\t\t\t(1 << 0)\n\n \n#define AD9523_READBACK_1_HOLDOVER_ACTIVE\t\t(1 << 3)\n#define AD9523_READBACK_1_AUTOMODE_SEL_REFB\t\t(1 << 2)\n#define AD9523_READBACK_1_VCO_CALIB_IN_PROGRESS\t\t(1 << 0)\n\n \n#define AD9523_STATUS_SIGNALS_SYNC_MAN_CTRL\t\t(1 << 16)\n#define AD9523_STATUS_MONITOR_01_PLL12_LOCKED\t\t(0x302)\n \n#define AD9523_POWER_DOWN_CTRL_PLL1_PWR_DOWN\t\t(1 << 2)\n#define AD9523_POWER_DOWN_CTRL_PLL2_PWR_DOWN\t\t(1 << 1)\n#define AD9523_POWER_DOWN_CTRL_DIST_PWR_DOWN\t\t(1 << 0)\n\n \n#define AD9523_IO_UPDATE_EN\t\t\t\t(1 << 0)\n\n \n#define AD9523_EEPROM_DATA_XFER_IN_PROGRESS\t\t(1 << 0)\n\n \n#define AD9523_EEPROM_ERROR_READBACK_FAIL\t\t(1 << 0)\n\n \n#define AD9523_EEPROM_CTRL1_SOFT_EEPROM\t\t\t(1 << 1)\n#define AD9523_EEPROM_CTRL1_EEPROM_WRITE_PROT_DIS\t(1 << 0)\n\n \n#define AD9523_EEPROM_CTRL2_REG2EEPROM\t\t\t(1 << 0)\n\n#define AD9523_NUM_CHAN\t\t\t\t\t14\n#define AD9523_NUM_CHAN_ALT_CLK_SRC\t\t\t10\n\n \n#define AD_IFE(_pde, _a, _b) ((pdata->_pde) ? _a : _b)\n#define AD_IF(_pde, _a) AD_IFE(_pde, _a, 0)\n\nenum {\n\tAD9523_STAT_PLL1_LD,\n\tAD9523_STAT_PLL2_LD,\n\tAD9523_STAT_REFA,\n\tAD9523_STAT_REFB,\n\tAD9523_STAT_REF_TEST,\n\tAD9523_STAT_VCXO,\n\tAD9523_STAT_PLL2_FB_CLK,\n\tAD9523_STAT_PLL2_REF_CLK,\n\tAD9523_SYNC,\n\tAD9523_EEPROM,\n};\n\nenum {\n\tAD9523_VCO1,\n\tAD9523_VCO2,\n\tAD9523_VCXO,\n\tAD9523_NUM_CLK_SRC,\n};\n\nstruct ad9523_state {\n\tstruct spi_device\t\t*spi;\n\tstruct ad9523_platform_data\t*pdata;\n\tstruct iio_chan_spec\t\tad9523_channels[AD9523_NUM_CHAN];\n\tstruct gpio_desc\t\t*pwrdown_gpio;\n\tstruct gpio_desc\t\t*reset_gpio;\n\tstruct gpio_desc\t\t*sync_gpio;\n\n\tunsigned long\t\tvcxo_freq;\n\tunsigned long\t\tvco_freq;\n\tunsigned long\t\tvco_out_freq[AD9523_NUM_CLK_SRC];\n\tunsigned char\t\tvco_out_map[AD9523_NUM_CHAN_ALT_CLK_SRC];\n\n\t \n\tstruct mutex\t\tlock;\n\n\t \n\tunion {\n\t\t__be32 d32;\n\t\tu8 d8[4];\n\t} data[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic int ad9523_read(struct iio_dev *indio_dev, unsigned int addr)\n{\n\tstruct ad9523_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\t \n\n\tstruct spi_transfer t[] = {\n\t\t{\n\t\t\t.tx_buf = &st->data[0].d8[2],\n\t\t\t.len = 2,\n\t\t}, {\n\t\t\t.rx_buf = &st->data[1].d8[4 - AD9523_TRANSF_LEN(addr)],\n\t\t\t.len = AD9523_TRANSF_LEN(addr),\n\t\t},\n\t};\n\n\tst->data[0].d32 = cpu_to_be32(AD9523_READ |\n\t\t\t\t      AD9523_CNT(AD9523_TRANSF_LEN(addr)) |\n\t\t\t\t      AD9523_ADDR(addr));\n\n\tret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\n\tif (ret < 0)\n\t\tdev_err(&indio_dev->dev, \"read failed (%d)\", ret);\n\telse\n\t\tret = be32_to_cpu(st->data[1].d32) & (0xFFFFFF >>\n\t\t\t\t  (8 * (3 - AD9523_TRANSF_LEN(addr))));\n\n\treturn ret;\n};\n\nstatic int ad9523_write(struct iio_dev *indio_dev,\n\t\tunsigned int addr, unsigned int val)\n{\n\tstruct ad9523_state *st = iio_priv(indio_dev);\n\tint ret;\n\tstruct spi_transfer t[] = {\n\t\t{\n\t\t\t.tx_buf = &st->data[0].d8[2],\n\t\t\t.len = 2,\n\t\t}, {\n\t\t\t.tx_buf = &st->data[1].d8[4 - AD9523_TRANSF_LEN(addr)],\n\t\t\t.len = AD9523_TRANSF_LEN(addr),\n\t\t},\n\t};\n\n\tst->data[0].d32 = cpu_to_be32(AD9523_WRITE |\n\t\t\t\t      AD9523_CNT(AD9523_TRANSF_LEN(addr)) |\n\t\t\t\t      AD9523_ADDR(addr));\n\tst->data[1].d32 = cpu_to_be32(val);\n\n\tret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\n\n\tif (ret < 0)\n\t\tdev_err(&indio_dev->dev, \"write failed (%d)\", ret);\n\n\treturn ret;\n}\n\nstatic int ad9523_io_update(struct iio_dev *indio_dev)\n{\n\treturn ad9523_write(indio_dev, AD9523_IO_UPDATE, AD9523_IO_UPDATE_EN);\n}\n\nstatic int ad9523_vco_out_map(struct iio_dev *indio_dev,\n\t\t\t      unsigned int ch, unsigned int out)\n{\n\tstruct ad9523_state *st = iio_priv(indio_dev);\n\tint ret;\n\tunsigned int mask;\n\n\tswitch (ch) {\n\tcase 0 ... 3:\n\t\tret = ad9523_read(indio_dev, AD9523_PLL1_OUTPUT_CHANNEL_CTRL);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tmask = AD9523_PLL1_OUTP_CH_CTRL_VCXO_SRC_SEL_CH0 << ch;\n\t\tif (out) {\n\t\t\tret |= mask;\n\t\t\tout = 2;\n\t\t} else {\n\t\t\tret &= ~mask;\n\t\t}\n\t\tret = ad9523_write(indio_dev,\n\t\t\t\t   AD9523_PLL1_OUTPUT_CHANNEL_CTRL, ret);\n\t\tbreak;\n\tcase 4 ... 6:\n\t\tret = ad9523_read(indio_dev, AD9523_PLL1_OUTPUT_CTRL);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tmask = AD9523_PLL1_OUTP_CTRL_VCO_DIV_SEL_CH4_M2 << (ch - 4);\n\t\tif (out)\n\t\t\tret |= mask;\n\t\telse\n\t\t\tret &= ~mask;\n\t\tret = ad9523_write(indio_dev, AD9523_PLL1_OUTPUT_CTRL, ret);\n\t\tbreak;\n\tcase 7 ... 9:\n\t\tret = ad9523_read(indio_dev, AD9523_PLL1_OUTPUT_CHANNEL_CTRL);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tmask = AD9523_PLL1_OUTP_CH_CTRL_VCO_DIV_SEL_CH7_M2 << (ch - 7);\n\t\tif (out)\n\t\t\tret |= mask;\n\t\telse\n\t\t\tret &= ~mask;\n\t\tret = ad9523_write(indio_dev,\n\t\t\t\t   AD9523_PLL1_OUTPUT_CHANNEL_CTRL, ret);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tst->vco_out_map[ch] = out;\n\n\treturn ret;\n}\n\nstatic int ad9523_set_clock_provider(struct iio_dev *indio_dev,\n\t\t\t      unsigned int ch, unsigned long freq)\n{\n\tstruct ad9523_state *st = iio_priv(indio_dev);\n\tlong tmp1, tmp2;\n\tbool use_alt_clk_src;\n\n\tswitch (ch) {\n\tcase 0 ... 3:\n\t\tuse_alt_clk_src = (freq == st->vco_out_freq[AD9523_VCXO]);\n\t\tbreak;\n\tcase 4 ... 9:\n\t\ttmp1 = st->vco_out_freq[AD9523_VCO1] / freq;\n\t\ttmp2 = st->vco_out_freq[AD9523_VCO2] / freq;\n\t\ttmp1 *= freq;\n\t\ttmp2 *= freq;\n\t\tuse_alt_clk_src = (abs(tmp1 - freq) > abs(tmp2 - freq));\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n\n\treturn ad9523_vco_out_map(indio_dev, ch, use_alt_clk_src);\n}\n\nstatic int ad9523_store_eeprom(struct iio_dev *indio_dev)\n{\n\tint ret, tmp;\n\n\tret = ad9523_write(indio_dev, AD9523_EEPROM_CTRL1,\n\t\t\t   AD9523_EEPROM_CTRL1_EEPROM_WRITE_PROT_DIS);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ad9523_write(indio_dev, AD9523_EEPROM_CTRL2,\n\t\t\t   AD9523_EEPROM_CTRL2_REG2EEPROM);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttmp = 4;\n\tdo {\n\t\tmsleep(20);\n\t\tret = ad9523_read(indio_dev,\n\t\t\t\t  AD9523_EEPROM_DATA_XFER_STATUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} while ((ret & AD9523_EEPROM_DATA_XFER_IN_PROGRESS) && tmp--);\n\n\tret = ad9523_write(indio_dev, AD9523_EEPROM_CTRL1, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_read(indio_dev, AD9523_EEPROM_ERROR_READBACK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & AD9523_EEPROM_ERROR_READBACK_FAIL) {\n\t\tdev_err(&indio_dev->dev, \"Verify EEPROM failed\");\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int ad9523_sync(struct iio_dev *indio_dev)\n{\n\tint ret, tmp;\n\n\tret = ad9523_read(indio_dev, AD9523_STATUS_SIGNALS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttmp = ret;\n\ttmp |= AD9523_STATUS_SIGNALS_SYNC_MAN_CTRL;\n\n\tret = ad9523_write(indio_dev, AD9523_STATUS_SIGNALS, tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tad9523_io_update(indio_dev);\n\ttmp &= ~AD9523_STATUS_SIGNALS_SYNC_MAN_CTRL;\n\n\tret = ad9523_write(indio_dev, AD9523_STATUS_SIGNALS, tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ad9523_io_update(indio_dev);\n}\n\nstatic ssize_t ad9523_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tstruct ad9523_state *st = iio_priv(indio_dev);\n\tbool state;\n\tint ret;\n\n\tret = kstrtobool(buf, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!state)\n\t\treturn len;\n\n\tmutex_lock(&st->lock);\n\tswitch ((u32)this_attr->address) {\n\tcase AD9523_SYNC:\n\t\tret = ad9523_sync(indio_dev);\n\t\tbreak;\n\tcase AD9523_EEPROM:\n\t\tret = ad9523_store_eeprom(indio_dev);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn ret ? ret : len;\n}\n\nstatic ssize_t ad9523_show(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tstruct ad9523_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = ad9523_read(indio_dev, AD9523_READBACK_0);\n\tif (ret >= 0) {\n\t\tret = sysfs_emit(buf, \"%d\\n\", !!(ret & (1 <<\n\t\t\t(u32)this_attr->address)));\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic IIO_DEVICE_ATTR(pll1_locked, S_IRUGO,\n\t\t\tad9523_show,\n\t\t\tNULL,\n\t\t\tAD9523_STAT_PLL1_LD);\n\nstatic IIO_DEVICE_ATTR(pll2_locked, S_IRUGO,\n\t\t\tad9523_show,\n\t\t\tNULL,\n\t\t\tAD9523_STAT_PLL2_LD);\n\nstatic IIO_DEVICE_ATTR(pll1_reference_clk_a_present, S_IRUGO,\n\t\t\tad9523_show,\n\t\t\tNULL,\n\t\t\tAD9523_STAT_REFA);\n\nstatic IIO_DEVICE_ATTR(pll1_reference_clk_b_present, S_IRUGO,\n\t\t\tad9523_show,\n\t\t\tNULL,\n\t\t\tAD9523_STAT_REFB);\n\nstatic IIO_DEVICE_ATTR(pll1_reference_clk_test_present, S_IRUGO,\n\t\t\tad9523_show,\n\t\t\tNULL,\n\t\t\tAD9523_STAT_REF_TEST);\n\nstatic IIO_DEVICE_ATTR(vcxo_clk_present, S_IRUGO,\n\t\t\tad9523_show,\n\t\t\tNULL,\n\t\t\tAD9523_STAT_VCXO);\n\nstatic IIO_DEVICE_ATTR(pll2_feedback_clk_present, S_IRUGO,\n\t\t\tad9523_show,\n\t\t\tNULL,\n\t\t\tAD9523_STAT_PLL2_FB_CLK);\n\nstatic IIO_DEVICE_ATTR(pll2_reference_clk_present, S_IRUGO,\n\t\t\tad9523_show,\n\t\t\tNULL,\n\t\t\tAD9523_STAT_PLL2_REF_CLK);\n\nstatic IIO_DEVICE_ATTR(sync_dividers, S_IWUSR,\n\t\t\tNULL,\n\t\t\tad9523_store,\n\t\t\tAD9523_SYNC);\n\nstatic IIO_DEVICE_ATTR(store_eeprom, S_IWUSR,\n\t\t\tNULL,\n\t\t\tad9523_store,\n\t\t\tAD9523_EEPROM);\n\nstatic struct attribute *ad9523_attributes[] = {\n\t&iio_dev_attr_sync_dividers.dev_attr.attr,\n\t&iio_dev_attr_store_eeprom.dev_attr.attr,\n\t&iio_dev_attr_pll2_feedback_clk_present.dev_attr.attr,\n\t&iio_dev_attr_pll2_reference_clk_present.dev_attr.attr,\n\t&iio_dev_attr_pll1_reference_clk_a_present.dev_attr.attr,\n\t&iio_dev_attr_pll1_reference_clk_b_present.dev_attr.attr,\n\t&iio_dev_attr_pll1_reference_clk_test_present.dev_attr.attr,\n\t&iio_dev_attr_vcxo_clk_present.dev_attr.attr,\n\t&iio_dev_attr_pll1_locked.dev_attr.attr,\n\t&iio_dev_attr_pll2_locked.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ad9523_attribute_group = {\n\t.attrs = ad9523_attributes,\n};\n\nstatic int ad9523_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tstruct ad9523_state *st = iio_priv(indio_dev);\n\tunsigned int code;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = ad9523_read(indio_dev, AD9523_CHANNEL_CLOCK_DIST(chan->channel));\n\tmutex_unlock(&st->lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*val = !(ret & AD9523_CLK_DIST_PWR_DOWN_EN);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_FREQUENCY:\n\t\t*val = st->vco_out_freq[st->vco_out_map[chan->channel]] /\n\t\t\tAD9523_CLK_DIST_DIV_REV(ret);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_PHASE:\n\t\tcode = (AD9523_CLK_DIST_DIV_PHASE_REV(ret) * 3141592) /\n\t\t\tAD9523_CLK_DIST_DIV_REV(ret);\n\t\t*val = code / 1000000;\n\t\t*val2 = code % 1000000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n};\n\nstatic int ad9523_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val,\n\t\t\t    int val2,\n\t\t\t    long mask)\n{\n\tstruct ad9523_state *st = iio_priv(indio_dev);\n\tunsigned int reg;\n\tint ret, tmp, code;\n\n\tmutex_lock(&st->lock);\n\tret = ad9523_read(indio_dev, AD9523_CHANNEL_CLOCK_DIST(chan->channel));\n\tif (ret < 0)\n\t\tgoto out;\n\n\treg = ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val)\n\t\t\treg &= ~AD9523_CLK_DIST_PWR_DOWN_EN;\n\t\telse\n\t\t\treg |= AD9523_CLK_DIST_PWR_DOWN_EN;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_FREQUENCY:\n\t\tif (val <= 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = ad9523_set_clock_provider(indio_dev, chan->channel, val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\ttmp = st->vco_out_freq[st->vco_out_map[chan->channel]] / val;\n\t\ttmp = clamp(tmp, 1, 1024);\n\t\treg &= ~(0x3FF << 8);\n\t\treg |= AD9523_CLK_DIST_DIV(tmp);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_PHASE:\n\t\tcode = val * 1000000 + val2 % 1000000;\n\t\ttmp = (code * AD9523_CLK_DIST_DIV_REV(ret)) / 3141592;\n\t\ttmp = clamp(tmp, 0, 63);\n\t\treg &= ~AD9523_CLK_DIST_DIV_PHASE(~0);\n\t\treg |= AD9523_CLK_DIST_DIV_PHASE(tmp);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ad9523_write(indio_dev, AD9523_CHANNEL_CLOCK_DIST(chan->channel),\n\t\t\t   reg);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tad9523_io_update(indio_dev);\nout:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic int ad9523_reg_access(struct iio_dev *indio_dev,\n\t\t\t      unsigned int reg, unsigned int writeval,\n\t\t\t      unsigned int *readval)\n{\n\tstruct ad9523_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tif (readval == NULL) {\n\t\tret = ad9523_write(indio_dev, reg | AD9523_R1B, writeval);\n\t\tad9523_io_update(indio_dev);\n\t} else {\n\t\tret = ad9523_read(indio_dev, reg | AD9523_R1B);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\t\t*readval = ret;\n\t\tret = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_info ad9523_info = {\n\t.read_raw = &ad9523_read_raw,\n\t.write_raw = &ad9523_write_raw,\n\t.debugfs_reg_access = &ad9523_reg_access,\n\t.attrs = &ad9523_attribute_group,\n};\n\nstatic int ad9523_setup(struct iio_dev *indio_dev)\n{\n\tstruct ad9523_state *st = iio_priv(indio_dev);\n\tstruct ad9523_platform_data *pdata = st->pdata;\n\tstruct ad9523_channel_spec *chan;\n\tunsigned long active_mask = 0;\n\tint ret, i;\n\n\tret = ad9523_write(indio_dev, AD9523_SERIAL_PORT_CONFIG,\n\t\t\t   AD9523_SER_CONF_SOFT_RESET |\n\t\t\t  (st->spi->mode & SPI_3WIRE ? 0 :\n\t\t\t  AD9523_SER_CONF_SDO_ACTIVE));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_write(indio_dev, AD9523_READBACK_CTRL,\n\t\t\t  AD9523_READBACK_CTRL_READ_BUFFERED);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_io_update(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ad9523_write(indio_dev, AD9523_PLL1_REF_A_DIVIDER,\n\t\tpdata->refa_r_div);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_write(indio_dev, AD9523_PLL1_REF_B_DIVIDER,\n\t\tpdata->refb_r_div);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_write(indio_dev, AD9523_PLL1_FEEDBACK_DIVIDER,\n\t\tpdata->pll1_feedback_div);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_write(indio_dev, AD9523_PLL1_CHARGE_PUMP_CTRL,\n\t\tAD9523_PLL1_CHARGE_PUMP_CURRENT_nA(pdata->\n\t\t\tpll1_charge_pump_current_nA) |\n\t\tAD9523_PLL1_CHARGE_PUMP_MODE_NORMAL |\n\t\tAD9523_PLL1_BACKLASH_PW_MIN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_write(indio_dev, AD9523_PLL1_INPUT_RECEIVERS_CTRL,\n\t\tAD_IF(refa_diff_rcv_en, AD9523_PLL1_REFA_RCV_EN) |\n\t\tAD_IF(refb_diff_rcv_en, AD9523_PLL1_REFB_RCV_EN) |\n\t\tAD_IF(osc_in_diff_en, AD9523_PLL1_OSC_IN_DIFF_EN) |\n\t\tAD_IF(osc_in_cmos_neg_inp_en,\n\t\t      AD9523_PLL1_OSC_IN_CMOS_NEG_INP_EN) |\n\t\tAD_IF(refa_diff_rcv_en, AD9523_PLL1_REFA_DIFF_RCV_EN) |\n\t\tAD_IF(refb_diff_rcv_en, AD9523_PLL1_REFB_DIFF_RCV_EN));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_write(indio_dev, AD9523_PLL1_REF_CTRL,\n\t\tAD_IF(zd_in_diff_en, AD9523_PLL1_ZD_IN_DIFF_EN) |\n\t\tAD_IF(zd_in_cmos_neg_inp_en,\n\t\t      AD9523_PLL1_ZD_IN_CMOS_NEG_INP_EN) |\n\t\tAD_IF(zero_delay_mode_internal_en,\n\t\t      AD9523_PLL1_ZERO_DELAY_MODE_INT) |\n\t\tAD_IF(osc_in_feedback_en, AD9523_PLL1_OSC_IN_PLL_FEEDBACK_EN) |\n\t\tAD_IF(refa_cmos_neg_inp_en, AD9523_PLL1_REFA_CMOS_NEG_INP_EN) |\n\t\tAD_IF(refb_cmos_neg_inp_en, AD9523_PLL1_REFB_CMOS_NEG_INP_EN));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_write(indio_dev, AD9523_PLL1_MISC_CTRL,\n\t\tAD9523_PLL1_REFB_INDEP_DIV_CTRL_EN |\n\t\tAD9523_PLL1_REF_MODE(pdata->ref_mode));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_write(indio_dev, AD9523_PLL1_LOOP_FILTER_CTRL,\n\t\tAD9523_PLL1_LOOP_FILTER_RZERO(pdata->pll1_loop_filter_rzero));\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\n\tret = ad9523_write(indio_dev, AD9523_PLL2_CHARGE_PUMP,\n\t\tAD9523_PLL2_CHARGE_PUMP_CURRENT_nA(pdata->\n\t\t\tpll2_charge_pump_current_nA));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_write(indio_dev, AD9523_PLL2_FEEDBACK_DIVIDER_AB,\n\t\tAD9523_PLL2_FB_NDIV_A_CNT(pdata->pll2_ndiv_a_cnt) |\n\t\tAD9523_PLL2_FB_NDIV_B_CNT(pdata->pll2_ndiv_b_cnt));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_write(indio_dev, AD9523_PLL2_CTRL,\n\t\tAD9523_PLL2_CHARGE_PUMP_MODE_NORMAL |\n\t\tAD9523_PLL2_BACKLASH_CTRL_EN |\n\t\tAD_IF(pll2_freq_doubler_en, AD9523_PLL2_FREQ_DOUBLER_EN));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->vco_freq = div_u64((unsigned long long)pdata->vcxo_freq *\n\t\t\t       (pdata->pll2_freq_doubler_en ? 2 : 1) *\n\t\t\t       AD9523_PLL2_FB_NDIV(pdata->pll2_ndiv_a_cnt,\n\t\t\t\t\t\t   pdata->pll2_ndiv_b_cnt),\n\t\t\t       pdata->pll2_r2_div);\n\n\tret = ad9523_write(indio_dev, AD9523_PLL2_VCO_CTRL,\n\t\tAD9523_PLL2_VCO_CALIBRATE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_write(indio_dev, AD9523_PLL2_VCO_DIVIDER,\n\t\tAD9523_PLL2_VCO_DIV_M1(pdata->pll2_vco_div_m1) |\n\t\tAD9523_PLL2_VCO_DIV_M2(pdata->pll2_vco_div_m2) |\n\t\tAD_IFE(pll2_vco_div_m1, 0,\n\t\t       AD9523_PLL2_VCO_DIV_M1_PWR_DOWN_EN) |\n\t\tAD_IFE(pll2_vco_div_m2, 0,\n\t\t       AD9523_PLL2_VCO_DIV_M2_PWR_DOWN_EN));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pdata->pll2_vco_div_m1)\n\t\tst->vco_out_freq[AD9523_VCO1] =\n\t\t\tst->vco_freq / pdata->pll2_vco_div_m1;\n\n\tif (pdata->pll2_vco_div_m2)\n\t\tst->vco_out_freq[AD9523_VCO2] =\n\t\t\tst->vco_freq / pdata->pll2_vco_div_m2;\n\n\tst->vco_out_freq[AD9523_VCXO] = pdata->vcxo_freq;\n\n\tret = ad9523_write(indio_dev, AD9523_PLL2_R2_DIVIDER,\n\t\tAD9523_PLL2_R2_DIVIDER_VAL(pdata->pll2_r2_div));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_write(indio_dev, AD9523_PLL2_LOOP_FILTER_CTRL,\n\t\tAD9523_PLL2_LOOP_FILTER_CPOLE1(pdata->cpole1) |\n\t\tAD9523_PLL2_LOOP_FILTER_RZERO(pdata->rzero) |\n\t\tAD9523_PLL2_LOOP_FILTER_RPOLE2(pdata->rpole2) |\n\t\tAD_IF(rzero_bypass_en,\n\t\t      AD9523_PLL2_LOOP_FILTER_RZERO_BYPASS_EN));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < pdata->num_channels; i++) {\n\t\tchan = &pdata->channels[i];\n\t\tif (chan->channel_num < AD9523_NUM_CHAN) {\n\t\t\t__set_bit(chan->channel_num, &active_mask);\n\t\t\tret = ad9523_write(indio_dev,\n\t\t\t\tAD9523_CHANNEL_CLOCK_DIST(chan->channel_num),\n\t\t\t\tAD9523_CLK_DIST_DRIVER_MODE(chan->driver_mode) |\n\t\t\t\tAD9523_CLK_DIST_DIV(chan->channel_divider) |\n\t\t\t\tAD9523_CLK_DIST_DIV_PHASE(chan->divider_phase) |\n\t\t\t\t(chan->sync_ignore_en ?\n\t\t\t\t\tAD9523_CLK_DIST_IGNORE_SYNC_EN : 0) |\n\t\t\t\t(chan->divider_output_invert_en ?\n\t\t\t\t\tAD9523_CLK_DIST_INV_DIV_OUTPUT_EN : 0) |\n\t\t\t\t(chan->low_power_mode_en ?\n\t\t\t\t\tAD9523_CLK_DIST_LOW_PWR_MODE_EN : 0) |\n\t\t\t\t(chan->output_dis ?\n\t\t\t\t\tAD9523_CLK_DIST_PWR_DOWN_EN : 0));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tret = ad9523_vco_out_map(indio_dev, chan->channel_num,\n\t\t\t\t\t   chan->use_alt_clock_src);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tst->ad9523_channels[i].type = IIO_ALTVOLTAGE;\n\t\t\tst->ad9523_channels[i].output = 1;\n\t\t\tst->ad9523_channels[i].indexed = 1;\n\t\t\tst->ad9523_channels[i].channel = chan->channel_num;\n\t\t\tst->ad9523_channels[i].extend_name =\n\t\t\t\tchan->extended_name;\n\t\t\tst->ad9523_channels[i].info_mask_separate =\n\t\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_PHASE) |\n\t\t\t\tBIT(IIO_CHAN_INFO_FREQUENCY);\n\t\t}\n\t}\n\n\tfor_each_clear_bit(i, &active_mask, AD9523_NUM_CHAN) {\n\t\tret = ad9523_write(indio_dev,\n\t\t\t     AD9523_CHANNEL_CLOCK_DIST(i),\n\t\t\t     AD9523_CLK_DIST_DRIVER_MODE(TRISTATE) |\n\t\t\t     AD9523_CLK_DIST_PWR_DOWN_EN);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = ad9523_write(indio_dev, AD9523_POWER_DOWN_CTRL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_write(indio_dev, AD9523_STATUS_SIGNALS,\n\t\t\t   AD9523_STATUS_MONITOR_01_PLL12_LOCKED);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad9523_io_update(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ad9523_probe(struct spi_device *spi)\n{\n\tstruct ad9523_platform_data *pdata = spi->dev.platform_data;\n\tstruct iio_dev *indio_dev;\n\tstruct ad9523_state *st;\n\tint ret;\n\n\tif (!pdata) {\n\t\tdev_err(&spi->dev, \"no platform data?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tmutex_init(&st->lock);\n\n\tret = devm_regulator_get_enable(&spi->dev, \"vcc\");\n\tif (ret)\n\t\treturn ret;\n\n\tst->pwrdown_gpio = devm_gpiod_get_optional(&spi->dev, \"powerdown\",\n\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(st->pwrdown_gpio))\n\t\treturn PTR_ERR(st->pwrdown_gpio);\n\n\tst->reset_gpio = devm_gpiod_get_optional(&spi->dev, \"reset\",\n\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(st->reset_gpio))\n\t\treturn PTR_ERR(st->reset_gpio);\n\n\tif (st->reset_gpio) {\n\t\tudelay(1);\n\t\tgpiod_direction_output(st->reset_gpio, 1);\n\t}\n\n\tst->sync_gpio = devm_gpiod_get_optional(&spi->dev, \"sync\",\n\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(st->sync_gpio))\n\t\treturn PTR_ERR(st->sync_gpio);\n\n\tspi_set_drvdata(spi, indio_dev);\n\tst->spi = spi;\n\tst->pdata = pdata;\n\n\tindio_dev->name = (pdata->name[0] != 0) ? pdata->name :\n\t\t\t  spi_get_device_id(spi)->name;\n\tindio_dev->info = &ad9523_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = st->ad9523_channels;\n\tindio_dev->num_channels = pdata->num_channels;\n\n\tret = ad9523_setup(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad9523_id[] = {\n\t{\"ad9523-1\", 9523},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad9523_id);\n\nstatic struct spi_driver ad9523_driver = {\n\t.driver = {\n\t\t.name\t= \"ad9523\",\n\t},\n\t.probe\t\t= ad9523_probe,\n\t.id_table\t= ad9523_id,\n};\nmodule_spi_driver(ad9523_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD9523 CLOCKDIST/PLL\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}