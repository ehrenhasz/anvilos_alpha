{
  "module_name": "adf4350.c",
  "hash_id": "db27b0da1068801d549c90374bcca147e301b829e6f3ed9be64fc73f1fb026a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/frequency/adf4350.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/gcd.h>\n#include <linux/gpio/consumer.h>\n#include <asm/div64.h>\n#include <linux/clk.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/frequency/adf4350.h>\n\nenum {\n\tADF4350_FREQ,\n\tADF4350_FREQ_REFIN,\n\tADF4350_FREQ_RESOLUTION,\n\tADF4350_PWRDOWN,\n};\n\nstruct adf4350_state {\n\tstruct spi_device\t\t*spi;\n\tstruct gpio_desc\t\t*lock_detect_gpiod;\n\tstruct adf4350_platform_data\t*pdata;\n\tstruct clk\t\t\t*clk;\n\tunsigned long\t\t\tclkin;\n\tunsigned long\t\t\tchspc;  \n\tunsigned long\t\t\tfpfd;  \n\tunsigned long\t\t\tmin_out_freq;\n\tunsigned\t\t\tr0_fract;\n\tunsigned\t\t\tr0_int;\n\tunsigned\t\t\tr1_mod;\n\tunsigned\t\t\tr4_rf_div_sel;\n\tunsigned long\t\t\tregs[6];\n\tunsigned long\t\t\tregs_hw[6];\n\tunsigned long long\t\tfreq_req;\n\t \n\tstruct mutex\t\t\tlock;\n\t \n\t__be32\t\t\t\tval __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic struct adf4350_platform_data default_pdata = {\n\t.channel_spacing = 10000,\n\t.r2_user_settings = ADF4350_REG2_PD_POLARITY_POS |\n\t\t\t    ADF4350_REG2_CHARGE_PUMP_CURR_uA(2500),\n\t.r3_user_settings = ADF4350_REG3_12BIT_CLKDIV_MODE(0),\n\t.r4_user_settings = ADF4350_REG4_OUTPUT_PWR(3) |\n\t\t\t    ADF4350_REG4_MUTE_TILL_LOCK_EN,\n};\n\nstatic int adf4350_sync_config(struct adf4350_state *st)\n{\n\tint ret, i, doublebuf = 0;\n\n\tfor (i = ADF4350_REG5; i >= ADF4350_REG0; i--) {\n\t\tif ((st->regs_hw[i] != st->regs[i]) ||\n\t\t\t((i == ADF4350_REG0) && doublebuf)) {\n\t\t\tswitch (i) {\n\t\t\tcase ADF4350_REG1:\n\t\t\tcase ADF4350_REG4:\n\t\t\t\tdoublebuf = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tst->val  = cpu_to_be32(st->regs[i] | i);\n\t\t\tret = spi_write(st->spi, &st->val, 4);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tst->regs_hw[i] = st->regs[i];\n\t\t\tdev_dbg(&st->spi->dev, \"[%d] 0x%X\\n\",\n\t\t\t\ti, (u32)st->regs[i] | i);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int adf4350_reg_access(struct iio_dev *indio_dev,\n\t\t\t      unsigned reg, unsigned writeval,\n\t\t\t      unsigned *readval)\n{\n\tstruct adf4350_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tif (reg > ADF4350_REG5)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&st->lock);\n\tif (readval == NULL) {\n\t\tst->regs[reg] = writeval & ~(BIT(0) | BIT(1) | BIT(2));\n\t\tret = adf4350_sync_config(st);\n\t} else {\n\t\t*readval =  st->regs_hw[reg];\n\t\tret = 0;\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int adf4350_tune_r_cnt(struct adf4350_state *st, unsigned short r_cnt)\n{\n\tstruct adf4350_platform_data *pdata = st->pdata;\n\n\tdo {\n\t\tr_cnt++;\n\t\tst->fpfd = (st->clkin * (pdata->ref_doubler_en ? 2 : 1)) /\n\t\t\t   (r_cnt * (pdata->ref_div2_en ? 2 : 1));\n\t} while (st->fpfd > ADF4350_MAX_FREQ_PFD);\n\n\treturn r_cnt;\n}\n\nstatic int adf4350_set_freq(struct adf4350_state *st, unsigned long long freq)\n{\n\tstruct adf4350_platform_data *pdata = st->pdata;\n\tu64 tmp;\n\tu32 div_gcd, prescaler, chspc;\n\tu16 mdiv, r_cnt = 0;\n\tu8 band_sel_div;\n\n\tif (freq > ADF4350_MAX_OUT_FREQ || freq < st->min_out_freq)\n\t\treturn -EINVAL;\n\n\tif (freq > ADF4350_MAX_FREQ_45_PRESC) {\n\t\tprescaler = ADF4350_REG1_PRESCALER;\n\t\tmdiv = 75;\n\t} else {\n\t\tprescaler = 0;\n\t\tmdiv = 23;\n\t}\n\n\tst->r4_rf_div_sel = 0;\n\n\twhile (freq < ADF4350_MIN_VCO_FREQ) {\n\t\tfreq <<= 1;\n\t\tst->r4_rf_div_sel++;\n\t}\n\n\t \n\tif (pdata->ref_div_factor)\n\t\tr_cnt = pdata->ref_div_factor - 1;\n\n\tchspc = st->chspc;\n\n\tdo  {\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tr_cnt = adf4350_tune_r_cnt(st, r_cnt);\n\t\t\t\tst->r1_mod = st->fpfd / chspc;\n\t\t\t\tif (r_cnt > ADF4350_MAX_R_CNT) {\n\t\t\t\t\t \n\t\t\t\t\tchspc++;\n\t\t\t\t\tr_cnt = 0;\n\t\t\t\t}\n\t\t\t} while ((st->r1_mod > ADF4350_MAX_MODULUS) && r_cnt);\n\t\t} while (r_cnt == 0);\n\n\t\ttmp = freq * (u64)st->r1_mod + (st->fpfd >> 1);\n\t\tdo_div(tmp, st->fpfd);  \n\t\tst->r0_fract = do_div(tmp, st->r1_mod);\n\t\tst->r0_int = tmp;\n\t} while (mdiv > st->r0_int);\n\n\tband_sel_div = DIV_ROUND_UP(st->fpfd, ADF4350_MAX_BANDSEL_CLK);\n\n\tif (st->r0_fract && st->r1_mod) {\n\t\tdiv_gcd = gcd(st->r1_mod, st->r0_fract);\n\t\tst->r1_mod /= div_gcd;\n\t\tst->r0_fract /= div_gcd;\n\t} else {\n\t\tst->r0_fract = 0;\n\t\tst->r1_mod = 1;\n\t}\n\n\tdev_dbg(&st->spi->dev, \"VCO: %llu Hz, PFD %lu Hz\\n\"\n\t\t\"REF_DIV %d, R0_INT %d, R0_FRACT %d\\n\"\n\t\t\"R1_MOD %d, RF_DIV %d\\nPRESCALER %s, BAND_SEL_DIV %d\\n\",\n\t\tfreq, st->fpfd, r_cnt, st->r0_int, st->r0_fract, st->r1_mod,\n\t\t1 << st->r4_rf_div_sel, prescaler ? \"8/9\" : \"4/5\",\n\t\tband_sel_div);\n\n\tst->regs[ADF4350_REG0] = ADF4350_REG0_INT(st->r0_int) |\n\t\t\t\t ADF4350_REG0_FRACT(st->r0_fract);\n\n\tst->regs[ADF4350_REG1] = ADF4350_REG1_PHASE(1) |\n\t\t\t\t ADF4350_REG1_MOD(st->r1_mod) |\n\t\t\t\t prescaler;\n\n\tst->regs[ADF4350_REG2] =\n\t\tADF4350_REG2_10BIT_R_CNT(r_cnt) |\n\t\tADF4350_REG2_DOUBLE_BUFF_EN |\n\t\t(pdata->ref_doubler_en ? ADF4350_REG2_RMULT2_EN : 0) |\n\t\t(pdata->ref_div2_en ? ADF4350_REG2_RDIV2_EN : 0) |\n\t\t(pdata->r2_user_settings & (ADF4350_REG2_PD_POLARITY_POS |\n\t\tADF4350_REG2_LDP_6ns | ADF4350_REG2_LDF_INT_N |\n\t\tADF4350_REG2_CHARGE_PUMP_CURR_uA(5000) |\n\t\tADF4350_REG2_MUXOUT(0x7) | ADF4350_REG2_NOISE_MODE(0x3)));\n\n\tst->regs[ADF4350_REG3] = pdata->r3_user_settings &\n\t\t\t\t (ADF4350_REG3_12BIT_CLKDIV(0xFFF) |\n\t\t\t\t ADF4350_REG3_12BIT_CLKDIV_MODE(0x3) |\n\t\t\t\t ADF4350_REG3_12BIT_CSR_EN |\n\t\t\t\t ADF4351_REG3_CHARGE_CANCELLATION_EN |\n\t\t\t\t ADF4351_REG3_ANTI_BACKLASH_3ns_EN |\n\t\t\t\t ADF4351_REG3_BAND_SEL_CLOCK_MODE_HIGH);\n\n\tst->regs[ADF4350_REG4] =\n\t\tADF4350_REG4_FEEDBACK_FUND |\n\t\tADF4350_REG4_RF_DIV_SEL(st->r4_rf_div_sel) |\n\t\tADF4350_REG4_8BIT_BAND_SEL_CLKDIV(band_sel_div) |\n\t\tADF4350_REG4_RF_OUT_EN |\n\t\t(pdata->r4_user_settings &\n\t\t(ADF4350_REG4_OUTPUT_PWR(0x3) |\n\t\tADF4350_REG4_AUX_OUTPUT_PWR(0x3) |\n\t\tADF4350_REG4_AUX_OUTPUT_EN |\n\t\tADF4350_REG4_AUX_OUTPUT_FUND |\n\t\tADF4350_REG4_MUTE_TILL_LOCK_EN));\n\n\tst->regs[ADF4350_REG5] = ADF4350_REG5_LD_PIN_MODE_DIGITAL;\n\tst->freq_req = freq;\n\n\treturn adf4350_sync_config(st);\n}\n\nstatic ssize_t adf4350_write(struct iio_dev *indio_dev,\n\t\t\t\t    uintptr_t private,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    const char *buf, size_t len)\n{\n\tstruct adf4350_state *st = iio_priv(indio_dev);\n\tunsigned long long readin;\n\tunsigned long tmp;\n\tint ret;\n\n\tret = kstrtoull(buf, 10, &readin);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\tswitch ((u32)private) {\n\tcase ADF4350_FREQ:\n\t\tret = adf4350_set_freq(st, readin);\n\t\tbreak;\n\tcase ADF4350_FREQ_REFIN:\n\t\tif (readin > ADF4350_MAX_FREQ_REFIN) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (st->clk) {\n\t\t\ttmp = clk_round_rate(st->clk, readin);\n\t\t\tif (tmp != readin) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = clk_set_rate(st->clk, tmp);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tst->clkin = readin;\n\t\tret = adf4350_set_freq(st, st->freq_req);\n\t\tbreak;\n\tcase ADF4350_FREQ_RESOLUTION:\n\t\tif (readin == 0)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tst->chspc = readin;\n\t\tbreak;\n\tcase ADF4350_PWRDOWN:\n\t\tif (readin)\n\t\t\tst->regs[ADF4350_REG2] |= ADF4350_REG2_POWER_DOWN_EN;\n\t\telse\n\t\t\tst->regs[ADF4350_REG2] &= ~ADF4350_REG2_POWER_DOWN_EN;\n\n\t\tadf4350_sync_config(st);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn ret ? ret : len;\n}\n\nstatic ssize_t adf4350_read(struct iio_dev *indio_dev,\n\t\t\t\t   uintptr_t private,\n\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t   char *buf)\n{\n\tstruct adf4350_state *st = iio_priv(indio_dev);\n\tunsigned long long val;\n\tint ret = 0;\n\n\tmutex_lock(&st->lock);\n\tswitch ((u32)private) {\n\tcase ADF4350_FREQ:\n\t\tval = (u64)((st->r0_int * st->r1_mod) + st->r0_fract) *\n\t\t\t(u64)st->fpfd;\n\t\tdo_div(val, st->r1_mod * (1 << st->r4_rf_div_sel));\n\t\t \n\t\tif (st->lock_detect_gpiod)\n\t\t\tif (!gpiod_get_value(st->lock_detect_gpiod)) {\n\t\t\t\tdev_dbg(&st->spi->dev, \"PLL un-locked\\n\");\n\t\t\t\tret = -EBUSY;\n\t\t\t}\n\t\tbreak;\n\tcase ADF4350_FREQ_REFIN:\n\t\tif (st->clk)\n\t\t\tst->clkin = clk_get_rate(st->clk);\n\n\t\tval = st->clkin;\n\t\tbreak;\n\tcase ADF4350_FREQ_RESOLUTION:\n\t\tval = st->chspc;\n\t\tbreak;\n\tcase ADF4350_PWRDOWN:\n\t\tval = !!(st->regs[ADF4350_REG2] & ADF4350_REG2_POWER_DOWN_EN);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tval = 0;\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn ret < 0 ? ret : sprintf(buf, \"%llu\\n\", val);\n}\n\n#define _ADF4350_EXT_INFO(_name, _ident) { \\\n\t.name = _name, \\\n\t.read = adf4350_read, \\\n\t.write = adf4350_write, \\\n\t.private = _ident, \\\n\t.shared = IIO_SEPARATE, \\\n}\n\nstatic const struct iio_chan_spec_ext_info adf4350_ext_info[] = {\n\t \n\t_ADF4350_EXT_INFO(\"frequency\", ADF4350_FREQ),\n\t_ADF4350_EXT_INFO(\"frequency_resolution\", ADF4350_FREQ_RESOLUTION),\n\t_ADF4350_EXT_INFO(\"refin_frequency\", ADF4350_FREQ_REFIN),\n\t_ADF4350_EXT_INFO(\"powerdown\", ADF4350_PWRDOWN),\n\t{ },\n};\n\nstatic const struct iio_chan_spec adf4350_chan = {\n\t.type = IIO_ALTVOLTAGE,\n\t.indexed = 1,\n\t.output = 1,\n\t.ext_info = adf4350_ext_info,\n};\n\nstatic const struct iio_info adf4350_info = {\n\t.debugfs_reg_access = &adf4350_reg_access,\n};\n\nstatic struct adf4350_platform_data *adf4350_parse_dt(struct device *dev)\n{\n\tstruct adf4350_platform_data *pdata;\n\tunsigned int tmp;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tsnprintf(pdata->name, sizeof(pdata->name), \"%pfw\", dev_fwnode(dev));\n\n\ttmp = 10000;\n\tdevice_property_read_u32(dev, \"adi,channel-spacing\", &tmp);\n\tpdata->channel_spacing = tmp;\n\n\ttmp = 0;\n\tdevice_property_read_u32(dev, \"adi,power-up-frequency\", &tmp);\n\tpdata->power_up_frequency = tmp;\n\n\ttmp = 0;\n\tdevice_property_read_u32(dev, \"adi,reference-div-factor\", &tmp);\n\tpdata->ref_div_factor = tmp;\n\n\tpdata->ref_doubler_en = device_property_read_bool(dev, \"adi,reference-doubler-enable\");\n\tpdata->ref_div2_en = device_property_read_bool(dev, \"adi,reference-div2-enable\");\n\n\t \n\tpdata->r2_user_settings = 0;\n\tif (device_property_read_bool(dev, \"adi,phase-detector-polarity-positive-enable\"))\n\t\tpdata->r2_user_settings |= ADF4350_REG2_PD_POLARITY_POS;\n\tif (device_property_read_bool(dev, \"adi,lock-detect-precision-6ns-enable\"))\n\t\tpdata->r2_user_settings |= ADF4350_REG2_LDP_6ns;\n\tif (device_property_read_bool(dev, \"adi,lock-detect-function-integer-n-enable\"))\n\t\tpdata->r2_user_settings |= ADF4350_REG2_LDF_INT_N;\n\n\ttmp = 2500;\n\tdevice_property_read_u32(dev, \"adi,charge-pump-current\", &tmp);\n\tpdata->r2_user_settings |= ADF4350_REG2_CHARGE_PUMP_CURR_uA(tmp);\n\n\ttmp = 0;\n\tdevice_property_read_u32(dev, \"adi,muxout-select\", &tmp);\n\tpdata->r2_user_settings |= ADF4350_REG2_MUXOUT(tmp);\n\n\tif (device_property_read_bool(dev, \"adi,low-spur-mode-enable\"))\n\t\tpdata->r2_user_settings |= ADF4350_REG2_NOISE_MODE(0x3);\n\n\t \n\n\tpdata->r3_user_settings = 0;\n\tif (device_property_read_bool(dev, \"adi,cycle-slip-reduction-enable\"))\n\t\tpdata->r3_user_settings |= ADF4350_REG3_12BIT_CSR_EN;\n\tif (device_property_read_bool(dev, \"adi,charge-cancellation-enable\"))\n\t\tpdata->r3_user_settings |= ADF4351_REG3_CHARGE_CANCELLATION_EN;\n\tif (device_property_read_bool(dev, \"adi,anti-backlash-3ns-enable\"))\n\t\tpdata->r3_user_settings |= ADF4351_REG3_ANTI_BACKLASH_3ns_EN;\n\tif (device_property_read_bool(dev, \"adi,band-select-clock-mode-high-enable\"))\n\t\tpdata->r3_user_settings |= ADF4351_REG3_BAND_SEL_CLOCK_MODE_HIGH;\n\n\ttmp = 0;\n\tdevice_property_read_u32(dev, \"adi,12bit-clk-divider\", &tmp);\n\tpdata->r3_user_settings |= ADF4350_REG3_12BIT_CLKDIV(tmp);\n\n\ttmp = 0;\n\tdevice_property_read_u32(dev, \"adi,clk-divider-mode\", &tmp);\n\tpdata->r3_user_settings |= ADF4350_REG3_12BIT_CLKDIV_MODE(tmp);\n\n\t \n\n\tpdata->r4_user_settings = 0;\n\tif (device_property_read_bool(dev, \"adi,aux-output-enable\"))\n\t\tpdata->r4_user_settings |= ADF4350_REG4_AUX_OUTPUT_EN;\n\tif (device_property_read_bool(dev, \"adi,aux-output-fundamental-enable\"))\n\t\tpdata->r4_user_settings |= ADF4350_REG4_AUX_OUTPUT_FUND;\n\tif (device_property_read_bool(dev, \"adi,mute-till-lock-enable\"))\n\t\tpdata->r4_user_settings |= ADF4350_REG4_MUTE_TILL_LOCK_EN;\n\n\ttmp = 0;\n\tdevice_property_read_u32(dev, \"adi,output-power\", &tmp);\n\tpdata->r4_user_settings |= ADF4350_REG4_OUTPUT_PWR(tmp);\n\n\ttmp = 0;\n\tdevice_property_read_u32(dev, \"adi,aux-output-power\", &tmp);\n\tpdata->r4_user_settings |= ADF4350_REG4_AUX_OUTPUT_PWR(tmp);\n\n\treturn pdata;\n}\n\nstatic void adf4350_power_down(void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct adf4350_state *st = iio_priv(indio_dev);\n\n\tst->regs[ADF4350_REG2] |= ADF4350_REG2_POWER_DOWN_EN;\n\tadf4350_sync_config(st);\n}\n\nstatic int adf4350_probe(struct spi_device *spi)\n{\n\tstruct adf4350_platform_data *pdata;\n\tstruct iio_dev *indio_dev;\n\tstruct adf4350_state *st;\n\tstruct clk *clk = NULL;\n\tint ret;\n\n\tif (dev_fwnode(&spi->dev)) {\n\t\tpdata = adf4350_parse_dt(&spi->dev);\n\t\tif (pdata == NULL)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tpdata = spi->dev.platform_data;\n\t}\n\n\tif (!pdata) {\n\t\tdev_warn(&spi->dev, \"no platform data? using default\\n\");\n\t\tpdata = &default_pdata;\n\t}\n\n\tif (!pdata->clkin) {\n\t\tclk = devm_clk_get_enabled(&spi->dev, \"clkin\");\n\t\tif (IS_ERR(clk))\n\t\t\treturn PTR_ERR(clk);\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tret = devm_regulator_get_enable(&spi->dev, \"vcc\");\n\tif (ret)\n\t\treturn ret;\n\n\tst->spi = spi;\n\tst->pdata = pdata;\n\n\tindio_dev->name = (pdata->name[0] != 0) ? pdata->name :\n\t\tspi_get_device_id(spi)->name;\n\n\tindio_dev->info = &adf4350_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = &adf4350_chan;\n\tindio_dev->num_channels = 1;\n\n\tmutex_init(&st->lock);\n\n\tst->chspc = pdata->channel_spacing;\n\tif (clk) {\n\t\tst->clk = clk;\n\t\tst->clkin = clk_get_rate(clk);\n\t} else {\n\t\tst->clkin = pdata->clkin;\n\t}\n\n\tst->min_out_freq = spi_get_device_id(spi)->driver_data == 4351 ?\n\t\tADF4351_MIN_OUT_FREQ : ADF4350_MIN_OUT_FREQ;\n\n\tmemset(st->regs_hw, 0xFF, sizeof(st->regs_hw));\n\n\tst->lock_detect_gpiod = devm_gpiod_get_optional(&spi->dev, NULL,\n\t\t\t\t\t\t\tGPIOD_IN);\n\tif (IS_ERR(st->lock_detect_gpiod))\n\t\treturn PTR_ERR(st->lock_detect_gpiod);\n\n\tif (pdata->power_up_frequency) {\n\t\tret = adf4350_set_freq(st, pdata->power_up_frequency);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&spi->dev, adf4350_power_down, indio_dev);\n\tif (ret)\n\t\treturn dev_err_probe(&spi->dev, ret,\n\t\t\t\t     \"Failed to add action to managed power down\\n\");\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id adf4350_of_match[] = {\n\t{ .compatible = \"adi,adf4350\", },\n\t{ .compatible = \"adi,adf4351\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, adf4350_of_match);\n\nstatic const struct spi_device_id adf4350_id[] = {\n\t{\"adf4350\", 4350},\n\t{\"adf4351\", 4351},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, adf4350_id);\n\nstatic struct spi_driver adf4350_driver = {\n\t.driver = {\n\t\t.name\t= \"adf4350\",\n\t\t.of_match_table = adf4350_of_match,\n\t},\n\t.probe\t\t= adf4350_probe,\n\t.id_table\t= adf4350_id,\n};\nmodule_spi_driver(adf4350_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADF4350/ADF4351 PLL\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}