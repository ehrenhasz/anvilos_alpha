{
  "module_name": "admv1013.c",
  "hash_id": "391cc116fbac4198e1f010136edb1c73ee57bd6d3050716b094690ad4d5907d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/frequency/admv1013.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/notifier.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/units.h>\n\n#include <asm/unaligned.h>\n\n \n#define ADMV1013_REG_SPI_CONTROL\t\t0x00\n#define ADMV1013_REG_ALARM\t\t\t0x01\n#define ADMV1013_REG_ALARM_MASKS\t\t0x02\n#define ADMV1013_REG_ENABLE\t\t\t0x03\n#define ADMV1013_REG_LO_AMP_I\t\t\t0x05\n#define ADMV1013_REG_LO_AMP_Q\t\t\t0x06\n#define ADMV1013_REG_OFFSET_ADJUST_I\t\t0x07\n#define ADMV1013_REG_OFFSET_ADJUST_Q\t\t0x08\n#define ADMV1013_REG_QUAD\t\t\t0x09\n#define ADMV1013_REG_VVA_TEMP_COMP\t\t0x0A\n\n \n#define ADMV1013_PARITY_EN_MSK\t\t\tBIT(15)\n#define ADMV1013_SPI_SOFT_RESET_MSK\t\tBIT(14)\n#define ADMV1013_CHIP_ID_MSK\t\t\tGENMASK(11, 4)\n#define ADMV1013_CHIP_ID\t\t\t0xA\n#define ADMV1013_REVISION_ID_MSK\t\tGENMASK(3, 0)\n\n \n#define ADMV1013_PARITY_ERROR_MSK\t\tBIT(15)\n#define ADMV1013_TOO_FEW_ERRORS_MSK\t\tBIT(14)\n#define ADMV1013_TOO_MANY_ERRORS_MSK\t\tBIT(13)\n#define ADMV1013_ADDRESS_RANGE_ERROR_MSK\tBIT(12)\n\n \n#define ADMV1013_VGA_PD_MSK\t\t\tBIT(15)\n#define ADMV1013_MIXER_PD_MSK\t\t\tBIT(14)\n#define ADMV1013_QUAD_PD_MSK\t\t\tGENMASK(13, 11)\n#define ADMV1013_BG_PD_MSK\t\t\tBIT(10)\n#define ADMV1013_MIXER_IF_EN_MSK\t\tBIT(7)\n#define ADMV1013_DET_EN_MSK\t\t\tBIT(5)\n\n \n#define ADMV1013_LOAMP_PH_ADJ_FINE_MSK\t\tGENMASK(13, 7)\n#define ADMV1013_MIXER_VGATE_MSK\t\tGENMASK(6, 0)\n\n \n#define ADMV1013_MIXER_OFF_ADJ_P_MSK\t\tGENMASK(15, 9)\n#define ADMV1013_MIXER_OFF_ADJ_N_MSK\t\tGENMASK(8, 2)\n\n \n#define ADMV1013_QUAD_SE_MODE_MSK\t\tGENMASK(9, 6)\n#define ADMV1013_QUAD_FILTERS_MSK\t\tGENMASK(3, 0)\n\n \n#define ADMV1013_VVA_TEMP_COMP_MSK\t\tGENMASK(15, 0)\n\n \n#define ADMV1013_READ\t\t\t\tBIT(7)\n#define ADMV1013_REG_ADDR_READ_MSK\t\tGENMASK(6, 1)\n#define ADMV1013_REG_ADDR_WRITE_MSK\t\tGENMASK(22, 17)\n#define ADMV1013_REG_DATA_MSK\t\t\tGENMASK(16, 1)\n\nenum {\n\tADMV1013_IQ_MODE,\n\tADMV1013_IF_MODE\n};\n\nenum {\n\tADMV1013_RFMOD_I_CALIBPHASE,\n\tADMV1013_RFMOD_Q_CALIBPHASE,\n};\n\nenum {\n\tADMV1013_SE_MODE_POS = 6,\n\tADMV1013_SE_MODE_NEG = 9,\n\tADMV1013_SE_MODE_DIFF = 12\n};\n\nstruct admv1013_state {\n\tstruct spi_device\t*spi;\n\tstruct clk\t\t*clkin;\n\t \n\tstruct mutex\t\tlock;\n\tstruct regulator\t*reg;\n\tstruct notifier_block\tnb;\n\tunsigned int\t\tinput_mode;\n\tunsigned int\t\tquad_se_mode;\n\tbool\t\t\tdet_en;\n\tu8\t\t\tdata[3] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic int __admv1013_spi_read(struct admv1013_state *st, unsigned int reg,\n\t\t\t       unsigned int *val)\n{\n\tint ret;\n\tstruct spi_transfer t = {0};\n\n\tst->data[0] = ADMV1013_READ | FIELD_PREP(ADMV1013_REG_ADDR_READ_MSK, reg);\n\tst->data[1] = 0x0;\n\tst->data[2] = 0x0;\n\n\tt.rx_buf = &st->data[0];\n\tt.tx_buf = &st->data[0];\n\tt.len = 3;\n\n\tret = spi_sync_transfer(st->spi, &t, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = FIELD_GET(ADMV1013_REG_DATA_MSK, get_unaligned_be24(&st->data[0]));\n\n\treturn ret;\n}\n\nstatic int admv1013_spi_read(struct admv1013_state *st, unsigned int reg,\n\t\t\t     unsigned int *val)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __admv1013_spi_read(st, reg, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int __admv1013_spi_write(struct admv1013_state *st,\n\t\t\t\tunsigned int reg,\n\t\t\t\tunsigned int val)\n{\n\tput_unaligned_be24(FIELD_PREP(ADMV1013_REG_DATA_MSK, val) |\n\t\t\t   FIELD_PREP(ADMV1013_REG_ADDR_WRITE_MSK, reg), &st->data[0]);\n\n\treturn spi_write(st->spi, &st->data[0], 3);\n}\n\nstatic int admv1013_spi_write(struct admv1013_state *st, unsigned int reg,\n\t\t\t      unsigned int val)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __admv1013_spi_write(st, reg, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int __admv1013_spi_update_bits(struct admv1013_state *st, unsigned int reg,\n\t\t\t\t      unsigned int mask, unsigned int val)\n{\n\tint ret;\n\tunsigned int data, temp;\n\n\tret = __admv1013_spi_read(st, reg, &data);\n\tif (ret)\n\t\treturn ret;\n\n\ttemp = (data & ~mask) | (val & mask);\n\n\treturn __admv1013_spi_write(st, reg, temp);\n}\n\nstatic int admv1013_spi_update_bits(struct admv1013_state *st, unsigned int reg,\n\t\t\t\t    unsigned int mask, unsigned int val)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __admv1013_spi_update_bits(st, reg, mask, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int admv1013_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long info)\n{\n\tstruct admv1013_state *st = iio_priv(indio_dev);\n\tunsigned int data, addr;\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tswitch (chan->channel) {\n\t\tcase IIO_MOD_I:\n\t\t\taddr = ADMV1013_REG_OFFSET_ADJUST_I;\n\t\t\tbreak;\n\t\tcase IIO_MOD_Q:\n\t\t\taddr = ADMV1013_REG_OFFSET_ADJUST_Q;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = admv1013_spi_read(st, addr, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!chan->channel)\n\t\t\t*val = FIELD_GET(ADMV1013_MIXER_OFF_ADJ_P_MSK, data);\n\t\telse\n\t\t\t*val = FIELD_GET(ADMV1013_MIXER_OFF_ADJ_N_MSK, data);\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int admv1013_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long info)\n{\n\tstruct admv1013_state *st = iio_priv(indio_dev);\n\tunsigned int addr, data, msk;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tswitch (chan->channel2) {\n\t\tcase IIO_MOD_I:\n\t\t\taddr = ADMV1013_REG_OFFSET_ADJUST_I;\n\t\t\tbreak;\n\t\tcase IIO_MOD_Q:\n\t\t\taddr = ADMV1013_REG_OFFSET_ADJUST_Q;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!chan->channel) {\n\t\t\tmsk = ADMV1013_MIXER_OFF_ADJ_P_MSK;\n\t\t\tdata = FIELD_PREP(ADMV1013_MIXER_OFF_ADJ_P_MSK, val);\n\t\t} else {\n\t\t\tmsk = ADMV1013_MIXER_OFF_ADJ_N_MSK;\n\t\t\tdata = FIELD_PREP(ADMV1013_MIXER_OFF_ADJ_N_MSK, val);\n\t\t}\n\n\t\treturn admv1013_spi_update_bits(st, addr, msk, data);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t admv1013_read(struct iio_dev *indio_dev,\n\t\t\t     uintptr_t private,\n\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t     char *buf)\n{\n\tstruct admv1013_state *st = iio_priv(indio_dev);\n\tunsigned int data, addr;\n\tint ret;\n\n\tswitch ((u32)private) {\n\tcase ADMV1013_RFMOD_I_CALIBPHASE:\n\t\taddr = ADMV1013_REG_LO_AMP_I;\n\t\tbreak;\n\tcase ADMV1013_RFMOD_Q_CALIBPHASE:\n\t\taddr = ADMV1013_REG_LO_AMP_Q;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = admv1013_spi_read(st, addr, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = FIELD_GET(ADMV1013_LOAMP_PH_ADJ_FINE_MSK, data);\n\n\treturn sysfs_emit(buf, \"%u\\n\", data);\n}\n\nstatic ssize_t admv1013_write(struct iio_dev *indio_dev,\n\t\t\t      uintptr_t private,\n\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t      const char *buf, size_t len)\n{\n\tstruct admv1013_state *st = iio_priv(indio_dev);\n\tunsigned int data;\n\tint ret;\n\n\tret = kstrtou32(buf, 10, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = FIELD_PREP(ADMV1013_LOAMP_PH_ADJ_FINE_MSK, data);\n\n\tswitch ((u32)private) {\n\tcase ADMV1013_RFMOD_I_CALIBPHASE:\n\t\tret = admv1013_spi_update_bits(st, ADMV1013_REG_LO_AMP_I,\n\t\t\t\t\t       ADMV1013_LOAMP_PH_ADJ_FINE_MSK,\n\t\t\t\t\t       data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase ADMV1013_RFMOD_Q_CALIBPHASE:\n\t\tret = admv1013_spi_update_bits(st, ADMV1013_REG_LO_AMP_Q,\n\t\t\t\t\t       ADMV1013_LOAMP_PH_ADJ_FINE_MSK,\n\t\t\t\t\t       data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret ? ret : len;\n}\n\nstatic int admv1013_update_quad_filters(struct admv1013_state *st)\n{\n\tunsigned int filt_raw;\n\tu64 rate = clk_get_rate(st->clkin);\n\n\tif (rate >= (5400 * HZ_PER_MHZ) && rate <= (7000 * HZ_PER_MHZ))\n\t\tfilt_raw = 15;\n\telse if (rate >= (5400 * HZ_PER_MHZ) && rate <= (8000 * HZ_PER_MHZ))\n\t\tfilt_raw = 10;\n\telse if (rate >= (6600 * HZ_PER_MHZ) && rate <= (9200 * HZ_PER_MHZ))\n\t\tfilt_raw = 5;\n\telse\n\t\tfilt_raw = 0;\n\n\treturn __admv1013_spi_update_bits(st, ADMV1013_REG_QUAD,\n\t\t\t\t\tADMV1013_QUAD_FILTERS_MSK,\n\t\t\t\t\tFIELD_PREP(ADMV1013_QUAD_FILTERS_MSK, filt_raw));\n}\n\nstatic int admv1013_update_mixer_vgate(struct admv1013_state *st)\n{\n\tunsigned int mixer_vgate;\n\tint vcm;\n\n\tvcm = regulator_get_voltage(st->reg);\n\tif (vcm < 0)\n\t\treturn vcm;\n\n\tif (vcm <= 1800000)\n\t\tmixer_vgate = (2389 * vcm / 1000000 + 8100) / 100;\n\telse if (vcm > 1800000 && vcm <= 2600000)\n\t\tmixer_vgate = (2375 * vcm / 1000000 + 125) / 100;\n\telse\n\t\treturn -EINVAL;\n\n\treturn __admv1013_spi_update_bits(st, ADMV1013_REG_LO_AMP_I,\n\t\t\t\t ADMV1013_MIXER_VGATE_MSK,\n\t\t\t\t FIELD_PREP(ADMV1013_MIXER_VGATE_MSK, mixer_vgate));\n}\n\nstatic int admv1013_reg_access(struct iio_dev *indio_dev,\n\t\t\t       unsigned int reg,\n\t\t\t       unsigned int write_val,\n\t\t\t       unsigned int *read_val)\n{\n\tstruct admv1013_state *st = iio_priv(indio_dev);\n\n\tif (read_val)\n\t\treturn admv1013_spi_read(st, reg, read_val);\n\telse\n\t\treturn admv1013_spi_write(st, reg, write_val);\n}\n\nstatic const struct iio_info admv1013_info = {\n\t.read_raw = admv1013_read_raw,\n\t.write_raw = admv1013_write_raw,\n\t.debugfs_reg_access = &admv1013_reg_access,\n};\n\nstatic const char * const admv1013_vcc_regs[] = {\n\t \"vcc-drv\", \"vcc2-drv\", \"vcc-vva\", \"vcc-amp1\", \"vcc-amp2\",\n\t \"vcc-env\", \"vcc-bg\", \"vcc-bg2\", \"vcc-mixer\", \"vcc-quad\"\n};\n\nstatic int admv1013_freq_change(struct notifier_block *nb, unsigned long action, void *data)\n{\n\tstruct admv1013_state *st = container_of(nb, struct admv1013_state, nb);\n\tint ret;\n\n\tif (action == POST_RATE_CHANGE) {\n\t\tmutex_lock(&st->lock);\n\t\tret = notifier_from_errno(admv1013_update_quad_filters(st));\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\n#define _ADMV1013_EXT_INFO(_name, _shared, _ident) { \\\n\t\t.name = _name, \\\n\t\t.read = admv1013_read, \\\n\t\t.write = admv1013_write, \\\n\t\t.private = _ident, \\\n\t\t.shared = _shared, \\\n}\n\nstatic const struct iio_chan_spec_ext_info admv1013_ext_info[] = {\n\t_ADMV1013_EXT_INFO(\"i_calibphase\", IIO_SEPARATE, ADMV1013_RFMOD_I_CALIBPHASE),\n\t_ADMV1013_EXT_INFO(\"q_calibphase\", IIO_SEPARATE, ADMV1013_RFMOD_Q_CALIBPHASE),\n\t{ },\n};\n\n#define ADMV1013_CHAN_PHASE(_channel, _channel2, _admv1013_ext_info) {\t\t\\\n\t.type = IIO_ALTVOLTAGE,\t\t\t\t\t\\\n\t.output = 0,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel2 = _channel2,\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\\\n\t.differential = 1,\t\t\t\t\t\\\n\t.ext_info = _admv1013_ext_info,\t\t\t\t\\\n\t}\n\n#define ADMV1013_CHAN_CALIB(_channel, rf_comp) {\t\\\n\t.type = IIO_ALTVOLTAGE,\t\t\t\t\t\\\n\t.output = 0,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##rf_comp,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_CALIBBIAS),\t\\\n\t}\n\nstatic const struct iio_chan_spec admv1013_channels[] = {\n\tADMV1013_CHAN_PHASE(0, 1, admv1013_ext_info),\n\tADMV1013_CHAN_CALIB(0, I),\n\tADMV1013_CHAN_CALIB(0, Q),\n\tADMV1013_CHAN_CALIB(1, I),\n\tADMV1013_CHAN_CALIB(1, Q),\n};\n\nstatic int admv1013_init(struct admv1013_state *st)\n{\n\tint ret;\n\tunsigned int data;\n\tstruct spi_device *spi = st->spi;\n\n\t \n\tret = __admv1013_spi_update_bits(st, ADMV1013_REG_SPI_CONTROL,\n\t\t\t\t\t ADMV1013_SPI_SOFT_RESET_MSK,\n\t\t\t\t\t FIELD_PREP(ADMV1013_SPI_SOFT_RESET_MSK, 1));\n\tif (ret)\n\t\treturn ret;\n\n\tret = __admv1013_spi_update_bits(st, ADMV1013_REG_SPI_CONTROL,\n\t\t\t\t\t ADMV1013_SPI_SOFT_RESET_MSK,\n\t\t\t\t\t FIELD_PREP(ADMV1013_SPI_SOFT_RESET_MSK, 0));\n\tif (ret)\n\t\treturn ret;\n\n\tret = __admv1013_spi_read(st, ADMV1013_REG_SPI_CONTROL, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = FIELD_GET(ADMV1013_CHIP_ID_MSK, data);\n\tif (data != ADMV1013_CHIP_ID) {\n\t\tdev_err(&spi->dev, \"Invalid Chip ID.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = __admv1013_spi_write(st, ADMV1013_REG_VVA_TEMP_COMP, 0xE700);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = FIELD_PREP(ADMV1013_QUAD_SE_MODE_MSK, st->quad_se_mode);\n\n\tret = __admv1013_spi_update_bits(st, ADMV1013_REG_QUAD,\n\t\t\t\t\t ADMV1013_QUAD_SE_MODE_MSK, data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = admv1013_update_mixer_vgate(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = admv1013_update_quad_filters(st);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __admv1013_spi_update_bits(st, ADMV1013_REG_ENABLE,\n\t\t\t\t\t  ADMV1013_DET_EN_MSK |\n\t\t\t\t\t  ADMV1013_MIXER_IF_EN_MSK,\n\t\t\t\t\t  st->det_en |\n\t\t\t\t\t  st->input_mode);\n}\n\nstatic void admv1013_reg_disable(void *data)\n{\n\tregulator_disable(data);\n}\n\nstatic void admv1013_powerdown(void *data)\n{\n\tunsigned int enable_reg, enable_reg_msk;\n\n\t \n\tenable_reg_msk = ADMV1013_VGA_PD_MSK |\n\t\t\tADMV1013_MIXER_PD_MSK |\n\t\t\tADMV1013_QUAD_PD_MSK |\n\t\t\tADMV1013_BG_PD_MSK |\n\t\t\tADMV1013_MIXER_IF_EN_MSK |\n\t\t\tADMV1013_DET_EN_MSK;\n\n\tenable_reg = FIELD_PREP(ADMV1013_VGA_PD_MSK, 1) |\n\t\t\tFIELD_PREP(ADMV1013_MIXER_PD_MSK, 1) |\n\t\t\tFIELD_PREP(ADMV1013_QUAD_PD_MSK, 7) |\n\t\t\tFIELD_PREP(ADMV1013_BG_PD_MSK, 1) |\n\t\t\tFIELD_PREP(ADMV1013_MIXER_IF_EN_MSK, 0) |\n\t\t\tFIELD_PREP(ADMV1013_DET_EN_MSK, 0);\n\n\tadmv1013_spi_update_bits(data, ADMV1013_REG_ENABLE, enable_reg_msk, enable_reg);\n}\n\nstatic int admv1013_properties_parse(struct admv1013_state *st)\n{\n\tint ret;\n\tconst char *str;\n\tstruct spi_device *spi = st->spi;\n\n\tst->det_en = device_property_read_bool(&spi->dev, \"adi,detector-enable\");\n\n\tret = device_property_read_string(&spi->dev, \"adi,input-mode\", &str);\n\tif (ret)\n\t\tst->input_mode = ADMV1013_IQ_MODE;\n\n\tif (!strcmp(str, \"iq\"))\n\t\tst->input_mode = ADMV1013_IQ_MODE;\n\telse if (!strcmp(str, \"if\"))\n\t\tst->input_mode = ADMV1013_IF_MODE;\n\telse\n\t\treturn -EINVAL;\n\n\tret = device_property_read_string(&spi->dev, \"adi,quad-se-mode\", &str);\n\tif (ret)\n\t\tst->quad_se_mode = ADMV1013_SE_MODE_DIFF;\n\n\tif (!strcmp(str, \"diff\"))\n\t\tst->quad_se_mode = ADMV1013_SE_MODE_DIFF;\n\telse if (!strcmp(str, \"se-pos\"))\n\t\tst->quad_se_mode = ADMV1013_SE_MODE_POS;\n\telse if (!strcmp(str, \"se-neg\"))\n\t\tst->quad_se_mode = ADMV1013_SE_MODE_NEG;\n\telse\n\t\treturn -EINVAL;\n\n\tst->reg = devm_regulator_get(&spi->dev, \"vcm\");\n\tif (IS_ERR(st->reg))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(st->reg),\n\t\t\t\t     \"failed to get the common-mode voltage\\n\");\n\n\tret = devm_regulator_bulk_get_enable(&st->spi->dev,\n\t\t\t\t\t     ARRAY_SIZE(admv1013_vcc_regs),\n\t\t\t\t\t     admv1013_vcc_regs);\n\tif (ret) {\n\t\tdev_err_probe(&spi->dev, ret,\n\t\t\t      \"Failed to request VCC regulators\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int admv1013_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct admv1013_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tindio_dev->info = &admv1013_info;\n\tindio_dev->name = \"admv1013\";\n\tindio_dev->channels = admv1013_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(admv1013_channels);\n\n\tst->spi = spi;\n\n\tret = admv1013_properties_parse(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_enable(st->reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to enable specified Common-Mode Voltage!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&spi->dev, admv1013_reg_disable,\n\t\t\t\t       st->reg);\n\tif (ret)\n\t\treturn ret;\n\n\tst->clkin = devm_clk_get_enabled(&spi->dev, \"lo_in\");\n\tif (IS_ERR(st->clkin))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(st->clkin),\n\t\t\t\t     \"failed to get the LO input clock\\n\");\n\n\tst->nb.notifier_call = admv1013_freq_change;\n\tret = devm_clk_notifier_register(&spi->dev, st->clkin, &st->nb);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&st->lock);\n\n\tret = admv1013_init(st);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"admv1013 init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&spi->dev, admv1013_powerdown, st);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id admv1013_id[] = {\n\t{ \"admv1013\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, admv1013_id);\n\nstatic const struct of_device_id admv1013_of_match[] = {\n\t{ .compatible = \"adi,admv1013\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, admv1013_of_match);\n\nstatic struct spi_driver admv1013_driver = {\n\t.driver = {\n\t\t.name = \"admv1013\",\n\t\t.of_match_table = admv1013_of_match,\n\t},\n\t.probe = admv1013_probe,\n\t.id_table = admv1013_id,\n};\nmodule_spi_driver(admv1013_driver);\n\nMODULE_AUTHOR(\"Antoniu Miclaus <antoniu.miclaus@analog.com\");\nMODULE_DESCRIPTION(\"Analog Devices ADMV1013\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}