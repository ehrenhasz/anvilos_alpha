{
  "module_name": "adf4371.c",
  "hash_id": "4357720f6edf8c34d5754103a53c57b071634a2c8723dd0d7ab88a334aa380dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/frequency/adf4371.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gcd.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/iio.h>\n\n \n#define ADF4371_REG(x)\t\t\t(x)\n\n \n#define ADF4371_ADDR_ASC_MSK\t\tBIT(2)\n#define ADF4371_ADDR_ASC(x)\t\tFIELD_PREP(ADF4371_ADDR_ASC_MSK, x)\n#define ADF4371_ADDR_ASC_R_MSK\t\tBIT(5)\n#define ADF4371_ADDR_ASC_R(x)\t\tFIELD_PREP(ADF4371_ADDR_ASC_R_MSK, x)\n#define ADF4371_RESET_CMD\t\t0x81\n\n \n#define ADF4371_FRAC2WORD_L_MSK\t\tGENMASK(7, 1)\n#define ADF4371_FRAC2WORD_L(x)\t\tFIELD_PREP(ADF4371_FRAC2WORD_L_MSK, x)\n#define ADF4371_FRAC1WORD_MSK\t\tBIT(0)\n#define ADF4371_FRAC1WORD(x)\t\tFIELD_PREP(ADF4371_FRAC1WORD_MSK, x)\n\n \n#define ADF4371_FRAC2WORD_H_MSK\t\tGENMASK(6, 0)\n#define ADF4371_FRAC2WORD_H(x)\t\tFIELD_PREP(ADF4371_FRAC2WORD_H_MSK, x)\n\n \n#define ADF4371_MOD2WORD_MSK\t\tGENMASK(5, 0)\n#define ADF4371_MOD2WORD(x)\t\tFIELD_PREP(ADF4371_MOD2WORD_MSK, x)\n\n \n#define ADF4371_RF_DIV_SEL_MSK\t\tGENMASK(6, 4)\n#define ADF4371_RF_DIV_SEL(x)\t\tFIELD_PREP(ADF4371_RF_DIV_SEL_MSK, x)\n\n \n#define ADF4371_MUTE_LD_MSK\t\tBIT(7)\n#define ADF4371_MUTE_LD(x)\t\tFIELD_PREP(ADF4371_MUTE_LD_MSK, x)\n\n \n#define ADF4371_TIMEOUT_MSK\t\tGENMASK(1, 0)\n#define ADF4371_TIMEOUT(x)\t\tFIELD_PREP(ADF4371_TIMEOUT_MSK, x)\n\n \n#define ADF4371_VCO_ALC_TOUT_MSK\tGENMASK(4, 0)\n#define ADF4371_VCO_ALC_TOUT(x)\t\tFIELD_PREP(ADF4371_VCO_ALC_TOUT_MSK, x)\n\n \n#define ADF4371_MIN_VCO_FREQ\t\t4000000000ULL  \n#define ADF4371_MAX_VCO_FREQ\t\t8000000000ULL  \n#define ADF4371_MAX_OUT_RF8_FREQ\tADF4371_MAX_VCO_FREQ  \n#define ADF4371_MIN_OUT_RF8_FREQ\t(ADF4371_MIN_VCO_FREQ / 64)  \n#define ADF4371_MAX_OUT_RF16_FREQ\t(ADF4371_MAX_VCO_FREQ * 2)  \n#define ADF4371_MIN_OUT_RF16_FREQ\t(ADF4371_MIN_VCO_FREQ * 2)  \n#define ADF4371_MAX_OUT_RF32_FREQ\t(ADF4371_MAX_VCO_FREQ * 4)  \n#define ADF4371_MIN_OUT_RF32_FREQ\t(ADF4371_MIN_VCO_FREQ * 4)  \n\n#define ADF4371_MAX_FREQ_PFD\t\t250000000UL  \n#define ADF4371_MAX_FREQ_REFIN\t\t600000000UL  \n\n \n#define ADF4371_MODULUS1\t\t33554432ULL\n \n#define ADF4371_MAX_MODULUS2\t\tBIT(14)\n\n#define ADF4371_CHECK_RANGE(freq, range) \\\n\t((freq > ADF4371_MAX_ ## range) || (freq < ADF4371_MIN_ ## range))\n\nenum {\n\tADF4371_FREQ,\n\tADF4371_POWER_DOWN,\n\tADF4371_CHANNEL_NAME\n};\n\nenum {\n\tADF4371_CH_RF8,\n\tADF4371_CH_RFAUX8,\n\tADF4371_CH_RF16,\n\tADF4371_CH_RF32\n};\n\nenum adf4371_variant {\n\tADF4371,\n\tADF4372\n};\n\nstruct adf4371_pwrdown {\n\tunsigned int reg;\n\tunsigned int bit;\n};\n\nstatic const char * const adf4371_ch_names[] = {\n\t\"RF8x\", \"RFAUX8x\", \"RF16x\", \"RF32x\"\n};\n\nstatic const struct adf4371_pwrdown adf4371_pwrdown_ch[4] = {\n\t[ADF4371_CH_RF8] = { ADF4371_REG(0x25), 2 },\n\t[ADF4371_CH_RFAUX8] = { ADF4371_REG(0x72), 3 },\n\t[ADF4371_CH_RF16] = { ADF4371_REG(0x25), 3 },\n\t[ADF4371_CH_RF32] = { ADF4371_REG(0x25), 4 },\n};\n\nstatic const struct reg_sequence adf4371_reg_defaults[] = {\n\t{ ADF4371_REG(0x0),  0x18 },\n\t{ ADF4371_REG(0x12), 0x40 },\n\t{ ADF4371_REG(0x1E), 0x48 },\n\t{ ADF4371_REG(0x20), 0x14 },\n\t{ ADF4371_REG(0x22), 0x00 },\n\t{ ADF4371_REG(0x23), 0x00 },\n\t{ ADF4371_REG(0x24), 0x80 },\n\t{ ADF4371_REG(0x25), 0x07 },\n\t{ ADF4371_REG(0x27), 0xC5 },\n\t{ ADF4371_REG(0x28), 0x83 },\n\t{ ADF4371_REG(0x2C), 0x44 },\n\t{ ADF4371_REG(0x2D), 0x11 },\n\t{ ADF4371_REG(0x2E), 0x12 },\n\t{ ADF4371_REG(0x2F), 0x94 },\n\t{ ADF4371_REG(0x32), 0x04 },\n\t{ ADF4371_REG(0x35), 0xFA },\n\t{ ADF4371_REG(0x36), 0x30 },\n\t{ ADF4371_REG(0x39), 0x07 },\n\t{ ADF4371_REG(0x3A), 0x55 },\n\t{ ADF4371_REG(0x3E), 0x0C },\n\t{ ADF4371_REG(0x3F), 0x80 },\n\t{ ADF4371_REG(0x40), 0x50 },\n\t{ ADF4371_REG(0x41), 0x28 },\n\t{ ADF4371_REG(0x47), 0xC0 },\n\t{ ADF4371_REG(0x52), 0xF4 },\n\t{ ADF4371_REG(0x70), 0x03 },\n\t{ ADF4371_REG(0x71), 0x60 },\n\t{ ADF4371_REG(0x72), 0x32 },\n};\n\nstatic const struct regmap_config adf4371_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.read_flag_mask = BIT(7),\n};\n\nstruct adf4371_chip_info {\n\tunsigned int num_channels;\n\tconst struct iio_chan_spec *channels;\n};\n\nstruct adf4371_state {\n\tstruct spi_device *spi;\n\tstruct regmap *regmap;\n\tstruct clk *clkin;\n\t \n\tstruct mutex lock;\n\tconst struct adf4371_chip_info *chip_info;\n\tunsigned long clkin_freq;\n\tunsigned long fpfd;\n\tunsigned int integer;\n\tunsigned int fract1;\n\tunsigned int fract2;\n\tunsigned int mod2;\n\tunsigned int rf_div_sel;\n\tunsigned int ref_div_factor;\n\tu8 buf[10] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic unsigned long long adf4371_pll_fract_n_get_rate(struct adf4371_state *st,\n\t\t\t\t\t\t       u32 channel)\n{\n\tunsigned long long val, tmp;\n\tunsigned int ref_div_sel;\n\n\tval = (((u64)st->integer * ADF4371_MODULUS1) + st->fract1) * st->fpfd;\n\ttmp = (u64)st->fract2 * st->fpfd;\n\tdo_div(tmp, st->mod2);\n\tval += tmp + ADF4371_MODULUS1 / 2;\n\n\tif (channel == ADF4371_CH_RF8 || channel == ADF4371_CH_RFAUX8)\n\t\tref_div_sel = st->rf_div_sel;\n\telse\n\t\tref_div_sel = 0;\n\n\tdo_div(val, ADF4371_MODULUS1 * (1 << ref_div_sel));\n\n\tif (channel == ADF4371_CH_RF16)\n\t\tval <<= 1;\n\telse if (channel == ADF4371_CH_RF32)\n\t\tval <<= 2;\n\n\treturn val;\n}\n\nstatic void adf4371_pll_fract_n_compute(unsigned long long vco,\n\t\t\t\t       unsigned long long pfd,\n\t\t\t\t       unsigned int *integer,\n\t\t\t\t       unsigned int *fract1,\n\t\t\t\t       unsigned int *fract2,\n\t\t\t\t       unsigned int *mod2)\n{\n\tunsigned long long tmp;\n\tu32 gcd_div;\n\n\ttmp = do_div(vco, pfd);\n\ttmp = tmp * ADF4371_MODULUS1;\n\t*fract2 = do_div(tmp, pfd);\n\n\t*integer = vco;\n\t*fract1 = tmp;\n\n\t*mod2 = pfd;\n\n\twhile (*mod2 > ADF4371_MAX_MODULUS2) {\n\t\t*mod2 >>= 1;\n\t\t*fract2 >>= 1;\n\t}\n\n\tgcd_div = gcd(*fract2, *mod2);\n\t*mod2 /= gcd_div;\n\t*fract2 /= gcd_div;\n}\n\nstatic int adf4371_set_freq(struct adf4371_state *st, unsigned long long freq,\n\t\t\t    unsigned int channel)\n{\n\tu32 cp_bleed;\n\tu8 int_mode = 0;\n\tint ret;\n\n\tswitch (channel) {\n\tcase ADF4371_CH_RF8:\n\tcase ADF4371_CH_RFAUX8:\n\t\tif (ADF4371_CHECK_RANGE(freq, OUT_RF8_FREQ))\n\t\t\treturn -EINVAL;\n\n\t\tst->rf_div_sel = 0;\n\n\t\twhile (freq < ADF4371_MIN_VCO_FREQ) {\n\t\t\tfreq <<= 1;\n\t\t\tst->rf_div_sel++;\n\t\t}\n\t\tbreak;\n\tcase ADF4371_CH_RF16:\n\t\t \n\t\tif (ADF4371_CHECK_RANGE(freq, OUT_RF16_FREQ))\n\t\t\treturn -EINVAL;\n\n\t\tfreq >>= 1;\n\t\tbreak;\n\tcase ADF4371_CH_RF32:\n\t\t \n\t\tif (ADF4371_CHECK_RANGE(freq, OUT_RF32_FREQ))\n\t\t\treturn -EINVAL;\n\n\t\tfreq >>= 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tadf4371_pll_fract_n_compute(freq, st->fpfd, &st->integer, &st->fract1,\n\t\t\t\t    &st->fract2, &st->mod2);\n\tst->buf[0] = st->integer >> 8;\n\tst->buf[1] = 0x40;  \n\tst->buf[2] = 0x00;\n\tst->buf[3] = st->fract1 & 0xFF;\n\tst->buf[4] = st->fract1 >> 8;\n\tst->buf[5] = st->fract1 >> 16;\n\tst->buf[6] = ADF4371_FRAC2WORD_L(st->fract2 & 0x7F) |\n\t\t     ADF4371_FRAC1WORD(st->fract1 >> 24);\n\tst->buf[7] = ADF4371_FRAC2WORD_H(st->fract2 >> 7);\n\tst->buf[8] = st->mod2 & 0xFF;\n\tst->buf[9] = ADF4371_MOD2WORD(st->mod2 >> 8);\n\n\tret = regmap_bulk_write(st->regmap, ADF4371_REG(0x11), st->buf, 10);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tret = regmap_write(st->regmap, ADF4371_REG(0x1F), st->ref_div_factor);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(st->regmap, ADF4371_REG(0x24),\n\t\t\t\t ADF4371_RF_DIV_SEL_MSK,\n\t\t\t\t ADF4371_RF_DIV_SEL(st->rf_div_sel));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcp_bleed = DIV_ROUND_UP(400 * 1750, st->integer * 375);\n\tcp_bleed = clamp(cp_bleed, 1U, 255U);\n\tret = regmap_write(st->regmap, ADF4371_REG(0x26), cp_bleed);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tif (st->fract1 == 0 && st->fract2 == 0)\n\t\tint_mode = 0x01;\n\n\tret = regmap_write(st->regmap, ADF4371_REG(0x2B), int_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_write(st->regmap, ADF4371_REG(0x10), st->integer & 0xFF);\n}\n\nstatic ssize_t adf4371_read(struct iio_dev *indio_dev,\n\t\t\t    uintptr_t private,\n\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t    char *buf)\n{\n\tstruct adf4371_state *st = iio_priv(indio_dev);\n\tunsigned long long val = 0;\n\tunsigned int readval, reg, bit;\n\tint ret;\n\n\tswitch ((u32)private) {\n\tcase ADF4371_FREQ:\n\t\tval = adf4371_pll_fract_n_get_rate(st, chan->channel);\n\t\tret = regmap_read(st->regmap, ADF4371_REG(0x7C), &readval);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (readval == 0x00) {\n\t\t\tdev_dbg(&st->spi->dev, \"PLL un-locked\\n\");\n\t\t\tret = -EBUSY;\n\t\t}\n\t\tbreak;\n\tcase ADF4371_POWER_DOWN:\n\t\treg = adf4371_pwrdown_ch[chan->channel].reg;\n\t\tbit = adf4371_pwrdown_ch[chan->channel].bit;\n\n\t\tret = regmap_read(st->regmap, reg, &readval);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tval = !(readval & BIT(bit));\n\t\tbreak;\n\tcase ADF4371_CHANNEL_NAME:\n\t\treturn sprintf(buf, \"%s\\n\", adf4371_ch_names[chan->channel]);\n\tdefault:\n\t\tret = -EINVAL;\n\t\tval = 0;\n\t\tbreak;\n\t}\n\n\treturn ret < 0 ? ret : sprintf(buf, \"%llu\\n\", val);\n}\n\nstatic ssize_t adf4371_write(struct iio_dev *indio_dev,\n\t\t\t     uintptr_t private,\n\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t     const char *buf, size_t len)\n{\n\tstruct adf4371_state *st = iio_priv(indio_dev);\n\tunsigned long long freq;\n\tbool power_down;\n\tunsigned int bit, readval, reg;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tswitch ((u32)private) {\n\tcase ADF4371_FREQ:\n\t\tret = kstrtoull(buf, 10, &freq);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = adf4371_set_freq(st, freq, chan->channel);\n\t\tbreak;\n\tcase ADF4371_POWER_DOWN:\n\t\tret = kstrtobool(buf, &power_down);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\treg = adf4371_pwrdown_ch[chan->channel].reg;\n\t\tbit = adf4371_pwrdown_ch[chan->channel].bit;\n\t\tret = regmap_read(st->regmap, reg, &readval);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\treadval &= ~BIT(bit);\n\t\treadval |= (!power_down << bit);\n\n\t\tret = regmap_write(st->regmap, reg, readval);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn ret ? ret : len;\n}\n\n#define _ADF4371_EXT_INFO(_name, _ident) { \\\n\t\t.name = _name, \\\n\t\t.read = adf4371_read, \\\n\t\t.write = adf4371_write, \\\n\t\t.private = _ident, \\\n\t\t.shared = IIO_SEPARATE, \\\n}\n\nstatic const struct iio_chan_spec_ext_info adf4371_ext_info[] = {\n\t \n\t_ADF4371_EXT_INFO(\"frequency\", ADF4371_FREQ),\n\t_ADF4371_EXT_INFO(\"powerdown\", ADF4371_POWER_DOWN),\n\t_ADF4371_EXT_INFO(\"name\", ADF4371_CHANNEL_NAME),\n\t{ },\n};\n\n#define ADF4371_CHANNEL(index) { \\\n\t\t.type = IIO_ALTVOLTAGE, \\\n\t\t.output = 1, \\\n\t\t.channel = index, \\\n\t\t.ext_info = adf4371_ext_info, \\\n\t\t.indexed = 1, \\\n\t}\n\nstatic const struct iio_chan_spec adf4371_chan[] = {\n\tADF4371_CHANNEL(ADF4371_CH_RF8),\n\tADF4371_CHANNEL(ADF4371_CH_RFAUX8),\n\tADF4371_CHANNEL(ADF4371_CH_RF16),\n\tADF4371_CHANNEL(ADF4371_CH_RF32),\n};\n\nstatic const struct adf4371_chip_info adf4371_chip_info[] = {\n\t[ADF4371] = {\n\t\t.channels = adf4371_chan,\n\t\t.num_channels = 4,\n\t},\n\t[ADF4372] = {\n\t\t.channels = adf4371_chan,\n\t\t.num_channels = 3,\n\t}\n};\n\nstatic int adf4371_reg_access(struct iio_dev *indio_dev,\n\t\t\t      unsigned int reg,\n\t\t\t      unsigned int writeval,\n\t\t\t      unsigned int *readval)\n{\n\tstruct adf4371_state *st = iio_priv(indio_dev);\n\n\tif (readval)\n\t\treturn regmap_read(st->regmap, reg, readval);\n\telse\n\t\treturn regmap_write(st->regmap, reg, writeval);\n}\n\nstatic const struct iio_info adf4371_info = {\n\t.debugfs_reg_access = &adf4371_reg_access,\n};\n\nstatic int adf4371_setup(struct adf4371_state *st)\n{\n\tunsigned int synth_timeout = 2, timeout = 1, vco_alc_timeout = 1;\n\tunsigned int vco_band_div, tmp;\n\tint ret;\n\n\t \n\tret = regmap_write(st->regmap, ADF4371_REG(0x0), ADF4371_RESET_CMD);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_multi_reg_write(st->regmap, adf4371_reg_defaults,\n\t\t\t\t     ARRAY_SIZE(adf4371_reg_defaults));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (device_property_read_bool(&st->spi->dev, \"adi,mute-till-lock-en\")) {\n\t\tret = regmap_update_bits(st->regmap, ADF4371_REG(0x25),\n\t\t\t\t\t ADF4371_MUTE_LD_MSK,\n\t\t\t\t\t ADF4371_MUTE_LD(1));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(st->regmap, ADF4371_REG(0x0),\n\t\t\t\t ADF4371_ADDR_ASC_MSK | ADF4371_ADDR_ASC_R_MSK,\n\t\t\t\t ADF4371_ADDR_ASC(1) | ADF4371_ADDR_ASC_R(1));\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tdo {\n\t\tst->ref_div_factor++;\n\t\tst->fpfd = st->clkin_freq / st->ref_div_factor;\n\t} while (st->fpfd > ADF4371_MAX_FREQ_PFD);\n\n\t \n\tvco_band_div = DIV_ROUND_UP(st->fpfd, 2400000U);\n\n\ttmp = DIV_ROUND_CLOSEST(st->fpfd, 1000000U);\n\tdo {\n\t\ttimeout++;\n\t\tif (timeout > 1023) {\n\t\t\ttimeout = 2;\n\t\t\tsynth_timeout++;\n\t\t}\n\t} while (synth_timeout * 1024 + timeout <= 20 * tmp);\n\n\tdo {\n\t\tvco_alc_timeout++;\n\t} while (vco_alc_timeout * 1024 - timeout <= 50 * tmp);\n\n\tst->buf[0] = vco_band_div;\n\tst->buf[1] = timeout & 0xFF;\n\tst->buf[2] = ADF4371_TIMEOUT(timeout >> 8) | 0x04;\n\tst->buf[3] = synth_timeout;\n\tst->buf[4] = ADF4371_VCO_ALC_TOUT(vco_alc_timeout);\n\n\treturn regmap_bulk_write(st->regmap, ADF4371_REG(0x30), st->buf, 5);\n}\n\nstatic int adf4371_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tstruct iio_dev *indio_dev;\n\tstruct adf4371_state *st;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_spi(spi, &adf4371_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&spi->dev, \"Error initializing spi regmap: %ld\\n\",\n\t\t\tPTR_ERR(regmap));\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tst = iio_priv(indio_dev);\n\tspi_set_drvdata(spi, indio_dev);\n\tst->spi = spi;\n\tst->regmap = regmap;\n\tmutex_init(&st->lock);\n\n\tst->chip_info = &adf4371_chip_info[id->driver_data];\n\tindio_dev->name = id->name;\n\tindio_dev->info = &adf4371_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = st->chip_info->channels;\n\tindio_dev->num_channels = st->chip_info->num_channels;\n\n\tst->clkin = devm_clk_get_enabled(&spi->dev, \"clkin\");\n\tif (IS_ERR(st->clkin))\n\t\treturn PTR_ERR(st->clkin);\n\n\tst->clkin_freq = clk_get_rate(st->clkin);\n\n\tret = adf4371_setup(st);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"ADF4371 setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id adf4371_id_table[] = {\n\t{ \"adf4371\", ADF4371 },\n\t{ \"adf4372\", ADF4372 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, adf4371_id_table);\n\nstatic const struct of_device_id adf4371_of_match[] = {\n\t{ .compatible = \"adi,adf4371\" },\n\t{ .compatible = \"adi,adf4372\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, adf4371_of_match);\n\nstatic struct spi_driver adf4371_driver = {\n\t.driver = {\n\t\t.name = \"adf4371\",\n\t\t.of_match_table = adf4371_of_match,\n\t},\n\t.probe = adf4371_probe,\n\t.id_table = adf4371_id_table,\n};\nmodule_spi_driver(adf4371_driver);\n\nMODULE_AUTHOR(\"Stefan Popa <stefan.popa@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADF4371 SPI PLL\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}