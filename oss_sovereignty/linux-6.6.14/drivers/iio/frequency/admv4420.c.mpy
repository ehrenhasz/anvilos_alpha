{
  "module_name": "admv4420.c",
  "hash_id": "5247d533bac08d393dd9c0f01e89b0bcf062752940e2518324c4c2f2c92ebd9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/frequency/admv4420.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/units.h>\n\n#include <asm/unaligned.h>\n\n \n#define ADMV4420_SPI_CONFIG_1\t\t\t0x00\n#define ADMV4420_SPI_CONFIG_2\t\t\t0x01\n#define ADMV4420_CHIPTYPE\t\t\t0x03\n#define ADMV4420_PRODUCT_ID_L\t\t\t0x04\n#define ADMV4420_PRODUCT_ID_H\t\t\t0x05\n#define ADMV4420_SCRATCHPAD\t\t\t0x0A\n#define ADMV4420_SPI_REV\t\t\t0x0B\n#define ADMV4420_ENABLES\t\t\t0x103\n#define ADMV4420_SDO_LEVEL\t\t\t0x108\n#define ADMV4420_INT_L\t\t\t\t0x200\n#define ADMV4420_INT_H\t\t\t\t0x201\n#define ADMV4420_FRAC_L\t\t\t\t0x202\n#define ADMV4420_FRAC_M\t\t\t\t0x203\n#define ADMV4420_FRAC_H\t\t\t\t0x204\n#define ADMV4420_MOD_L\t\t\t\t0x208\n#define ADMV4420_MOD_M\t\t\t\t0x209\n#define ADMV4420_MOD_H\t\t\t\t0x20A\n#define ADMV4420_R_DIV_L\t\t\t0x20C\n#define ADMV4420_R_DIV_H\t\t\t0x20D\n#define ADMV4420_REFERENCE\t\t\t0x20E\n#define ADMV4420_VCO_DATA_READBACK1\t\t0x211\n#define ADMV4420_VCO_DATA_READBACK2\t\t0x212\n#define ADMV4420_PLL_MUX_SEL\t\t\t0x213\n#define ADMV4420_LOCK_DETECT\t\t\t0x214\n#define ADMV4420_BAND_SELECT\t\t\t0x215\n#define ADMV4420_VCO_ALC_TIMEOUT\t\t0x216\n#define ADMV4420_VCO_MANUAL\t\t\t0x217\n#define ADMV4420_ALC\t\t\t\t0x219\n#define ADMV4420_VCO_TIMEOUT1\t\t\t0x21C\n#define ADMV4420_VCO_TIMEOUT2\t\t\t0x21D\n#define ADMV4420_VCO_BAND_DIV\t\t\t0x21E\n#define ADMV4420_VCO_READBACK_SEL\t\t0x21F\n#define ADMV4420_AUTOCAL\t\t\t0x226\n#define ADMV4420_CP_STATE\t\t\t0x22C\n#define ADMV4420_CP_BLEED_EN\t\t\t0x22D\n#define ADMV4420_CP_CURRENT\t\t\t0x22E\n#define ADMV4420_CP_BLEED\t\t\t0x22F\n\n#define ADMV4420_SPI_CONFIG_1_SDOACTIVE\t\t(BIT(4) | BIT(3))\n#define ADMV4420_SPI_CONFIG_1_ENDIAN\t\t(BIT(5) | BIT(2))\n#define ADMV4420_SPI_CONFIG_1_SOFTRESET\t\t(BIT(7) | BIT(1))\n\n#define ADMV4420_REFERENCE_DIVIDE_BY_2_MASK\tBIT(0)\n#define ADMV4420_REFERENCE_MODE_MASK\t\tBIT(1)\n#define ADMV4420_REFERENCE_DOUBLER_MASK\t\tBIT(2)\n\n#define ADMV4420_REF_DIVIDER_MAX_VAL\t\tGENMASK(9, 0)\n#define ADMV4420_N_COUNTER_INT_MAX\t\tGENMASK(15, 0)\n#define ADMV4420_N_COUNTER_FRAC_MAX\t\tGENMASK(23, 0)\n#define ADMV4420_N_COUNTER_MOD_MAX\t\tGENMASK(23, 0)\n\n#define ENABLE_PLL\t\t\t\tBIT(6)\n#define ENABLE_LO\t\t\t\tBIT(5)\n#define ENABLE_VCO\t\t\t\tBIT(3)\n#define ENABLE_IFAMP\t\t\t\tBIT(2)\n#define ENABLE_MIXER\t\t\t\tBIT(1)\n#define ENABLE_LNA\t\t\t\tBIT(0)\n\n#define ADMV4420_SCRATCH_PAD_VAL_1              0xAD\n#define ADMV4420_SCRATCH_PAD_VAL_2              0xEA\n\n#define ADMV4420_REF_FREQ_HZ                    50000000\n#define MAX_N_COUNTER                           655360UL\n#define MAX_R_DIVIDER                           1024\n#define ADMV4420_DEFAULT_LO_FREQ_HZ\t\t16750000000ULL\n\nenum admv4420_mux_sel {\n\tADMV4420_LOW = 0,\n\tADMV4420_LOCK_DTCT = 1,\n\tADMV4420_R_COUNTER_PER_2 = 4,\n\tADMV4420_N_CONUTER_PER_2 = 5,\n\tADMV4420_HIGH = 8,\n};\n\nstruct admv4420_reference_block {\n\tbool doubler_en;\n\tbool divide_by_2_en;\n\tbool ref_single_ended;\n\tu32 divider;\n};\n\nstruct admv4420_n_counter {\n\tu32 int_val;\n\tu32 frac_val;\n\tu32 mod_val;\n\tu32 n_counter;\n};\n\nstruct admv4420_state {\n\tstruct spi_device\t\t*spi;\n\tstruct regmap\t\t\t*regmap;\n\tu64\t\t\t\tvco_freq_hz;\n\tu64\t\t\t\tlo_freq_hz;\n\tstruct admv4420_reference_block ref_block;\n\tstruct admv4420_n_counter\tn_counter;\n\tenum admv4420_mux_sel\t\tmux_sel;\n\tstruct mutex\t\t\tlock;\n\tu8\t\t\t\ttransf_buf[4] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic const struct regmap_config admv4420_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.read_flag_mask = BIT(7),\n};\n\nstatic int admv4420_reg_access(struct iio_dev *indio_dev,\n\t\t\t       u32 reg, u32 writeval,\n\t\t\t       u32 *readval)\n{\n\tstruct admv4420_state *st = iio_priv(indio_dev);\n\n\tif (readval)\n\t\treturn regmap_read(st->regmap, reg, readval);\n\telse\n\t\treturn regmap_write(st->regmap, reg, writeval);\n}\n\nstatic int admv4420_set_n_counter(struct admv4420_state *st, u32 int_val,\n\t\t\t\t  u32 frac_val, u32 mod_val)\n{\n\tint ret;\n\n\tput_unaligned_le32(frac_val, st->transf_buf);\n\tret = regmap_bulk_write(st->regmap, ADMV4420_FRAC_L, st->transf_buf, 3);\n\tif (ret)\n\t\treturn ret;\n\n\tput_unaligned_le32(mod_val, st->transf_buf);\n\tret = regmap_bulk_write(st->regmap, ADMV4420_MOD_L, st->transf_buf, 3);\n\tif (ret)\n\t\treturn ret;\n\n\tput_unaligned_le32(int_val, st->transf_buf);\n\treturn regmap_bulk_write(st->regmap, ADMV4420_INT_L, st->transf_buf, 2);\n}\n\nstatic int admv4420_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long info)\n{\n\tstruct admv4420_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_FREQUENCY:\n\n\t\t*val = div_u64_rem(st->lo_freq_hz, MICRO, val2);\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info admv4420_info = {\n\t.read_raw = admv4420_read_raw,\n\t.debugfs_reg_access = &admv4420_reg_access,\n};\n\nstatic const struct iio_chan_spec admv4420_channels[] = {\n\t{\n\t\t.type = IIO_ALTVOLTAGE,\n\t\t.output = 0,\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_FREQUENCY),\n\t},\n};\n\nstatic void admv4420_fw_parse(struct admv4420_state *st)\n{\n\tstruct device *dev = &st->spi->dev;\n\tu32 tmp;\n\tint ret;\n\n\tret = device_property_read_u32(dev, \"adi,lo-freq-khz\", &tmp);\n\tif (!ret)\n\t\tst->lo_freq_hz = (u64)tmp * KILO;\n\n\tst->ref_block.ref_single_ended = device_property_read_bool(dev,\n\t\t\t\t\t\t\t\t   \"adi,ref-ext-single-ended-en\");\n}\n\nstatic inline uint64_t admv4420_calc_pfd_vco(struct admv4420_state *st)\n{\n\treturn div_u64(st->vco_freq_hz * 10, st->n_counter.n_counter);\n}\n\nstatic inline uint32_t admv4420_calc_pfd_ref(struct admv4420_state *st)\n{\n\tuint32_t tmp;\n\tu8 doubler, divide_by_2;\n\n\tdoubler = st->ref_block.doubler_en ? 2 : 1;\n\tdivide_by_2 = st->ref_block.divide_by_2_en ? 2 : 1;\n\ttmp = ADMV4420_REF_FREQ_HZ * doubler;\n\n\treturn (tmp / (st->ref_block.divider * divide_by_2));\n}\n\nstatic int admv4420_calc_parameters(struct admv4420_state *st)\n{\n\tu64 pfd_ref, pfd_vco;\n\tbool sol_found = false;\n\n\tst->ref_block.doubler_en = false;\n\tst->ref_block.divide_by_2_en = false;\n\tst->vco_freq_hz = div_u64(st->lo_freq_hz, 2);\n\n\tfor (st->ref_block.divider = 1; st->ref_block.divider < MAX_R_DIVIDER;\n\t    st->ref_block.divider++) {\n\t\tpfd_ref = admv4420_calc_pfd_ref(st);\n\t\tfor (st->n_counter.n_counter = 1; st->n_counter.n_counter < MAX_N_COUNTER;\n\t\t    st->n_counter.n_counter++) {\n\t\t\tpfd_vco = admv4420_calc_pfd_vco(st);\n\t\t\tif (pfd_ref == pfd_vco) {\n\t\t\t\tsol_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sol_found)\n\t\t\tbreak;\n\n\t\tst->n_counter.n_counter = 1;\n\t}\n\tif (!sol_found)\n\t\treturn -1;\n\n\tst->n_counter.int_val = div_u64_rem(st->n_counter.n_counter, 10, &st->n_counter.frac_val);\n\tst->n_counter.mod_val = 10;\n\n\treturn 0;\n}\n\nstatic int admv4420_setup(struct iio_dev *indio_dev)\n{\n\tstruct admv4420_state *st = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\tu32 val;\n\tint ret;\n\n\tret = regmap_write(st->regmap, ADMV4420_SPI_CONFIG_1,\n\t\t\t   ADMV4420_SPI_CONFIG_1_SOFTRESET);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(st->regmap, ADMV4420_SPI_CONFIG_1,\n\t\t\t   ADMV4420_SPI_CONFIG_1_SDOACTIVE |\n\t\t\t   ADMV4420_SPI_CONFIG_1_ENDIAN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(st->regmap,\n\t\t\t   ADMV4420_SCRATCHPAD,\n\t\t\t   ADMV4420_SCRATCH_PAD_VAL_1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(st->regmap, ADMV4420_SCRATCHPAD, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != ADMV4420_SCRATCH_PAD_VAL_1) {\n\t\tdev_err(dev, \"Failed ADMV4420 to read/write scratchpad %x \", val);\n\t\treturn -EIO;\n\t}\n\n\tret = regmap_write(st->regmap,\n\t\t\t   ADMV4420_SCRATCHPAD,\n\t\t\t   ADMV4420_SCRATCH_PAD_VAL_2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(st->regmap, ADMV4420_SCRATCHPAD, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != ADMV4420_SCRATCH_PAD_VAL_2) {\n\t\tdev_err(dev, \"Failed to read/write scratchpad %x \", val);\n\t\treturn -EIO;\n\t}\n\n\tst->mux_sel = ADMV4420_LOCK_DTCT;\n\tst->lo_freq_hz = ADMV4420_DEFAULT_LO_FREQ_HZ;\n\n\tadmv4420_fw_parse(st);\n\n\tret = admv4420_calc_parameters(st);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed calc parameters for %lld \", st->vco_freq_hz);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(st->regmap, ADMV4420_R_DIV_L,\n\t\t\t   FIELD_GET(0xFF, st->ref_block.divider));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(st->regmap, ADMV4420_R_DIV_H,\n\t\t\t   FIELD_GET(0xFF00, st->ref_block.divider));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(st->regmap, ADMV4420_REFERENCE,\n\t\t\t   st->ref_block.divide_by_2_en |\n\t\t\t   FIELD_PREP(ADMV4420_REFERENCE_MODE_MASK, st->ref_block.ref_single_ended) |\n\t\t\t   FIELD_PREP(ADMV4420_REFERENCE_DOUBLER_MASK, st->ref_block.doubler_en));\n\tif (ret)\n\t\treturn ret;\n\n\tret = admv4420_set_n_counter(st, st->n_counter.int_val,\n\t\t\t\t     st->n_counter.frac_val,\n\t\t\t\t     st->n_counter.mod_val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(st->regmap, ADMV4420_PLL_MUX_SEL, st->mux_sel);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(st->regmap, ADMV4420_ENABLES,\n\t\t\t    ENABLE_PLL | ENABLE_LO | ENABLE_VCO |\n\t\t\t    ENABLE_IFAMP | ENABLE_MIXER | ENABLE_LNA);\n}\n\nstatic int admv4420_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct admv4420_state *st;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_spi(spi, &admv4420_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(regmap),\n\t\t\t\t     \"Failed to initializing spi regmap\\n\");\n\n\tst = iio_priv(indio_dev);\n\tst->spi = spi;\n\tst->regmap = regmap;\n\n\tindio_dev->name = \"admv4420\";\n\tindio_dev->info = &admv4420_info;\n\tindio_dev->channels = admv4420_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(admv4420_channels);\n\n\tret = admv4420_setup(indio_dev);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Setup ADMV4420 failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id admv4420_of_match[] = {\n\t{ .compatible = \"adi,admv4420\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, admv4420_of_match);\n\nstatic struct spi_driver admv4420_driver = {\n\t.driver = {\n\t\t.name = \"admv4420\",\n\t\t.of_match_table = admv4420_of_match,\n\t},\n\t.probe = admv4420_probe,\n};\n\nmodule_spi_driver(admv4420_driver);\n\nMODULE_AUTHOR(\"Cristian Pop <cristian.pop@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADMV44200 K Band Downconverter\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}