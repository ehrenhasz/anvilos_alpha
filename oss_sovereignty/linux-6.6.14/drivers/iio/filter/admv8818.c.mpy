{
  "module_name": "admv8818.c",
  "hash_id": "ec8244bde5614fdaabb89896d56caffde3bf4b90d6c901ef794484fe8b4fddc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/filter/admv8818.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/notifier.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/units.h>\n\n \n#define ADMV8818_REG_SPI_CONFIG_A\t\t0x0\n#define ADMV8818_REG_SPI_CONFIG_B\t\t0x1\n#define ADMV8818_REG_CHIPTYPE\t\t\t0x3\n#define ADMV8818_REG_PRODUCT_ID_L\t\t0x4\n#define ADMV8818_REG_PRODUCT_ID_H\t\t0x5\n#define ADMV8818_REG_FAST_LATCH_POINTER\t\t0x10\n#define ADMV8818_REG_FAST_LATCH_STOP\t\t0x11\n#define ADMV8818_REG_FAST_LATCH_START\t\t0x12\n#define ADMV8818_REG_FAST_LATCH_DIRECTION\t0x13\n#define ADMV8818_REG_FAST_LATCH_STATE\t\t0x14\n#define ADMV8818_REG_WR0_SW\t\t\t0x20\n#define ADMV8818_REG_WR0_FILTER\t\t\t0x21\n#define ADMV8818_REG_WR1_SW\t\t\t0x22\n#define ADMV8818_REG_WR1_FILTER\t\t\t0x23\n#define ADMV8818_REG_WR2_SW\t\t\t0x24\n#define ADMV8818_REG_WR2_FILTER\t\t\t0x25\n#define ADMV8818_REG_WR3_SW\t\t\t0x26\n#define ADMV8818_REG_WR3_FILTER\t\t\t0x27\n#define ADMV8818_REG_WR4_SW\t\t\t0x28\n#define ADMV8818_REG_WR4_FILTER\t\t\t0x29\n#define ADMV8818_REG_LUT0_SW\t\t\t0x100\n#define ADMV8818_REG_LUT0_FILTER\t\t0x101\n#define ADMV8818_REG_LUT127_SW\t\t\t0x1FE\n#define ADMV8818_REG_LUT127_FILTER\t\t0x1FF\n\n \n#define ADMV8818_SOFTRESET_N_MSK\t\tBIT(7)\n#define ADMV8818_LSB_FIRST_N_MSK\t\tBIT(6)\n#define ADMV8818_ENDIAN_N_MSK\t\t\tBIT(5)\n#define ADMV8818_SDOACTIVE_N_MSK\t\tBIT(4)\n#define ADMV8818_SDOACTIVE_MSK\t\t\tBIT(3)\n#define ADMV8818_ENDIAN_MSK\t\t\tBIT(2)\n#define ADMV8818_LSBFIRST_MSK\t\t\tBIT(1)\n#define ADMV8818_SOFTRESET_MSK\t\t\tBIT(0)\n\n \n#define ADMV8818_SINGLE_INSTRUCTION_MSK\t\tBIT(7)\n#define ADMV8818_CSB_STALL_MSK\t\t\tBIT(6)\n#define ADMV8818_MASTER_SLAVE_RB_MSK\t\tBIT(5)\n#define ADMV8818_MASTER_SLAVE_TRANSFER_MSK\tBIT(0)\n\n \n#define ADMV8818_SW_IN_SET_WR0_MSK\t\tBIT(7)\n#define ADMV8818_SW_OUT_SET_WR0_MSK\t\tBIT(6)\n#define ADMV8818_SW_IN_WR0_MSK\t\t\tGENMASK(5, 3)\n#define ADMV8818_SW_OUT_WR0_MSK\t\t\tGENMASK(2, 0)\n\n \n#define ADMV8818_HPF_WR0_MSK\t\t\tGENMASK(7, 4)\n#define ADMV8818_LPF_WR0_MSK\t\t\tGENMASK(3, 0)\n\nenum {\n\tADMV8818_BW_FREQ,\n\tADMV8818_CENTER_FREQ\n};\n\nenum {\n\tADMV8818_AUTO_MODE,\n\tADMV8818_MANUAL_MODE,\n\tADMV8818_BYPASS_MODE,\n};\n\nstruct admv8818_state {\n\tstruct spi_device\t*spi;\n\tstruct regmap\t\t*regmap;\n\tstruct clk\t\t*clkin;\n\tstruct notifier_block\tnb;\n\t \n\tstruct mutex\t\tlock;\n\tunsigned int\t\tfilter_mode;\n\tu64\t\t\tcf_hz;\n};\n\nstatic const unsigned long long freq_range_hpf[4][2] = {\n\t{1750000000ULL, 3550000000ULL},\n\t{3400000000ULL, 7250000000ULL},\n\t{6600000000, 12000000000},\n\t{12500000000, 19900000000}\n};\n\nstatic const unsigned long long freq_range_lpf[4][2] = {\n\t{2050000000ULL, 3850000000ULL},\n\t{3350000000ULL, 7250000000ULL},\n\t{7000000000, 13000000000},\n\t{12550000000, 18500000000}\n};\n\nstatic const struct regmap_config admv8818_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.read_flag_mask = 0x80,\n\t.max_register = 0x1FF,\n};\n\nstatic const char * const admv8818_modes[] = {\n\t[0] = \"auto\",\n\t[1] = \"manual\",\n\t[2] = \"bypass\"\n};\n\nstatic int __admv8818_hpf_select(struct admv8818_state *st, u64 freq)\n{\n\tunsigned int hpf_step = 0, hpf_band = 0, i, j;\n\tu64 freq_step;\n\tint ret;\n\n\tif (freq < freq_range_hpf[0][0])\n\t\tgoto hpf_write;\n\n\tif (freq > freq_range_hpf[3][1]) {\n\t\thpf_step = 15;\n\t\thpf_band = 4;\n\n\t\tgoto hpf_write;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tfreq_step = div_u64((freq_range_hpf[i][1] -\n\t\t\tfreq_range_hpf[i][0]), 15);\n\n\t\tif (freq > freq_range_hpf[i][0] &&\n\t\t    (freq < freq_range_hpf[i][1] + freq_step)) {\n\t\t\thpf_band = i + 1;\n\n\t\t\tfor (j = 1; j <= 16; j++) {\n\t\t\t\tif (freq < (freq_range_hpf[i][0] + (freq_step * j))) {\n\t\t\t\t\thpf_step = j - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (freq >= 12000 * HZ_PER_MHZ && freq <= 12500 * HZ_PER_MHZ) {\n\t\thpf_band = 3;\n\t\thpf_step = 15;\n\t}\n\nhpf_write:\n\tret = regmap_update_bits(st->regmap, ADMV8818_REG_WR0_SW,\n\t\t\t\t ADMV8818_SW_IN_SET_WR0_MSK |\n\t\t\t\t ADMV8818_SW_IN_WR0_MSK,\n\t\t\t\t FIELD_PREP(ADMV8818_SW_IN_SET_WR0_MSK, 1) |\n\t\t\t\t FIELD_PREP(ADMV8818_SW_IN_WR0_MSK, hpf_band));\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(st->regmap, ADMV8818_REG_WR0_FILTER,\n\t\t\t\t  ADMV8818_HPF_WR0_MSK,\n\t\t\t\t  FIELD_PREP(ADMV8818_HPF_WR0_MSK, hpf_step));\n}\n\nstatic int admv8818_hpf_select(struct admv8818_state *st, u64 freq)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __admv8818_hpf_select(st, freq);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int __admv8818_lpf_select(struct admv8818_state *st, u64 freq)\n{\n\tunsigned int lpf_step = 0, lpf_band = 0, i, j;\n\tu64 freq_step;\n\tint ret;\n\n\tif (freq > freq_range_lpf[3][1])\n\t\tgoto lpf_write;\n\n\tif (freq < freq_range_lpf[0][0]) {\n\t\tlpf_band = 1;\n\n\t\tgoto lpf_write;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (freq > freq_range_lpf[i][0] && freq < freq_range_lpf[i][1]) {\n\t\t\tlpf_band = i + 1;\n\t\t\tfreq_step = div_u64((freq_range_lpf[i][1] - freq_range_lpf[i][0]), 15);\n\n\t\t\tfor (j = 0; j <= 15; j++) {\n\t\t\t\tif (freq < (freq_range_lpf[i][0] + (freq_step * j))) {\n\t\t\t\t\tlpf_step = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\nlpf_write:\n\tret = regmap_update_bits(st->regmap, ADMV8818_REG_WR0_SW,\n\t\t\t\t ADMV8818_SW_OUT_SET_WR0_MSK |\n\t\t\t\t ADMV8818_SW_OUT_WR0_MSK,\n\t\t\t\t FIELD_PREP(ADMV8818_SW_OUT_SET_WR0_MSK, 1) |\n\t\t\t\t FIELD_PREP(ADMV8818_SW_OUT_WR0_MSK, lpf_band));\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(st->regmap, ADMV8818_REG_WR0_FILTER,\n\t\t\t\t  ADMV8818_LPF_WR0_MSK,\n\t\t\t\t  FIELD_PREP(ADMV8818_LPF_WR0_MSK, lpf_step));\n}\n\nstatic int admv8818_lpf_select(struct admv8818_state *st, u64 freq)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __admv8818_lpf_select(st, freq);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int admv8818_rfin_band_select(struct admv8818_state *st)\n{\n\tint ret;\n\n\tst->cf_hz = clk_get_rate(st->clkin);\n\n\tmutex_lock(&st->lock);\n\n\tret = __admv8818_hpf_select(st, st->cf_hz);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = __admv8818_lpf_select(st, st->cf_hz);\nexit:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic int __admv8818_read_hpf_freq(struct admv8818_state *st, u64 *hpf_freq)\n{\n\tunsigned int data, hpf_band, hpf_state;\n\tint ret;\n\n\tret = regmap_read(st->regmap, ADMV8818_REG_WR0_SW, &data);\n\tif (ret)\n\t\treturn ret;\n\n\thpf_band = FIELD_GET(ADMV8818_SW_IN_WR0_MSK, data);\n\tif (!hpf_band || hpf_band > 4) {\n\t\t*hpf_freq = 0;\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(st->regmap, ADMV8818_REG_WR0_FILTER, &data);\n\tif (ret)\n\t\treturn ret;\n\n\thpf_state = FIELD_GET(ADMV8818_HPF_WR0_MSK, data);\n\n\t*hpf_freq = div_u64(freq_range_hpf[hpf_band - 1][1] - freq_range_hpf[hpf_band - 1][0], 15);\n\t*hpf_freq = freq_range_hpf[hpf_band - 1][0] + (*hpf_freq * hpf_state);\n\n\treturn ret;\n}\n\nstatic int admv8818_read_hpf_freq(struct admv8818_state *st, u64 *hpf_freq)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __admv8818_read_hpf_freq(st, hpf_freq);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int __admv8818_read_lpf_freq(struct admv8818_state *st, u64 *lpf_freq)\n{\n\tunsigned int data, lpf_band, lpf_state;\n\tint ret;\n\n\tret = regmap_read(st->regmap, ADMV8818_REG_WR0_SW, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tlpf_band = FIELD_GET(ADMV8818_SW_OUT_WR0_MSK, data);\n\tif (!lpf_band || lpf_band > 4) {\n\t\t*lpf_freq = 0;\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(st->regmap, ADMV8818_REG_WR0_FILTER, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tlpf_state = FIELD_GET(ADMV8818_LPF_WR0_MSK, data);\n\n\t*lpf_freq = div_u64(freq_range_lpf[lpf_band - 1][1] - freq_range_lpf[lpf_band - 1][0], 15);\n\t*lpf_freq = freq_range_lpf[lpf_band - 1][0] + (*lpf_freq * lpf_state);\n\n\treturn ret;\n}\n\nstatic int admv8818_read_lpf_freq(struct admv8818_state *st, u64 *lpf_freq)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __admv8818_read_lpf_freq(st, lpf_freq);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int admv8818_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long info)\n{\n\tstruct admv8818_state *st = iio_priv(indio_dev);\n\n\tu64 freq = ((u64)val2 << 32 | (u32)val);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn admv8818_lpf_select(st, freq);\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn admv8818_hpf_select(st, freq);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int admv8818_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long info)\n{\n\tstruct admv8818_state *st = iio_priv(indio_dev);\n\tint ret;\n\tu64 freq;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tret = admv8818_read_lpf_freq(st, &freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = (u32)freq;\n\t\t*val2 = (u32)(freq >> 32);\n\n\t\treturn IIO_VAL_INT_64;\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\tret = admv8818_read_hpf_freq(st, &freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = (u32)freq;\n\t\t*val2 = (u32)(freq >> 32);\n\n\t\treturn IIO_VAL_INT_64;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int admv8818_reg_access(struct iio_dev *indio_dev,\n\t\t\t       unsigned int reg,\n\t\t\t       unsigned int write_val,\n\t\t\t       unsigned int *read_val)\n{\n\tstruct admv8818_state *st = iio_priv(indio_dev);\n\n\tif (read_val)\n\t\treturn regmap_read(st->regmap, reg, read_val);\n\telse\n\t\treturn regmap_write(st->regmap, reg, write_val);\n}\n\nstatic int admv8818_filter_bypass(struct admv8818_state *st)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = regmap_update_bits(st->regmap, ADMV8818_REG_WR0_SW,\n\t\t\t\t ADMV8818_SW_IN_SET_WR0_MSK |\n\t\t\t\t ADMV8818_SW_IN_WR0_MSK |\n\t\t\t\t ADMV8818_SW_OUT_SET_WR0_MSK |\n\t\t\t\t ADMV8818_SW_OUT_WR0_MSK,\n\t\t\t\t FIELD_PREP(ADMV8818_SW_IN_SET_WR0_MSK, 1) |\n\t\t\t\t FIELD_PREP(ADMV8818_SW_IN_WR0_MSK, 0) |\n\t\t\t\t FIELD_PREP(ADMV8818_SW_OUT_SET_WR0_MSK, 1) |\n\t\t\t\t FIELD_PREP(ADMV8818_SW_OUT_WR0_MSK, 0));\n\tif (ret)\n\t\tgoto exit;\n\n\tret = regmap_update_bits(st->regmap, ADMV8818_REG_WR0_FILTER,\n\t\t\t\t ADMV8818_HPF_WR0_MSK |\n\t\t\t\t ADMV8818_LPF_WR0_MSK,\n\t\t\t\t FIELD_PREP(ADMV8818_HPF_WR0_MSK, 0) |\n\t\t\t\t FIELD_PREP(ADMV8818_LPF_WR0_MSK, 0));\n\nexit:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int admv8818_get_mode(struct iio_dev *indio_dev,\n\t\t\t     const struct iio_chan_spec *chan)\n{\n\tstruct admv8818_state *st = iio_priv(indio_dev);\n\n\treturn st->filter_mode;\n}\n\nstatic int admv8818_set_mode(struct iio_dev *indio_dev,\n\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t     unsigned int mode)\n{\n\tstruct admv8818_state *st = iio_priv(indio_dev);\n\tint ret = 0;\n\n\tif (!st->clkin) {\n\t\tif (mode == ADMV8818_MANUAL_MODE)\n\t\t\tgoto set_mode;\n\n\t\tif (mode == ADMV8818_BYPASS_MODE) {\n\t\t\tret = admv8818_filter_bypass(st);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tgoto set_mode;\n\t\t}\n\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (mode) {\n\tcase ADMV8818_AUTO_MODE:\n\t\tif (st->filter_mode == ADMV8818_AUTO_MODE)\n\t\t\treturn 0;\n\n\t\tret = clk_prepare_enable(st->clkin);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = clk_notifier_register(st->clkin, &st->nb);\n\t\tif (ret) {\n\t\t\tclk_disable_unprepare(st->clkin);\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tbreak;\n\tcase ADMV8818_MANUAL_MODE:\n\tcase ADMV8818_BYPASS_MODE:\n\t\tif (st->filter_mode == ADMV8818_AUTO_MODE) {\n\t\t\tclk_disable_unprepare(st->clkin);\n\n\t\t\tret = clk_notifier_unregister(st->clkin, &st->nb);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (mode == ADMV8818_BYPASS_MODE) {\n\t\t\tret = admv8818_filter_bypass(st);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\nset_mode:\n\tst->filter_mode = mode;\n\n\treturn ret;\n}\n\nstatic const struct iio_info admv8818_info = {\n\t.write_raw = admv8818_write_raw,\n\t.read_raw = admv8818_read_raw,\n\t.debugfs_reg_access = &admv8818_reg_access,\n};\n\nstatic const struct iio_enum admv8818_mode_enum = {\n\t.items = admv8818_modes,\n\t.num_items = ARRAY_SIZE(admv8818_modes),\n\t.get = admv8818_get_mode,\n\t.set = admv8818_set_mode,\n};\n\nstatic const struct iio_chan_spec_ext_info admv8818_ext_info[] = {\n\tIIO_ENUM(\"filter_mode\", IIO_SHARED_BY_ALL, &admv8818_mode_enum),\n\tIIO_ENUM_AVAILABLE(\"filter_mode\", IIO_SHARED_BY_ALL, &admv8818_mode_enum),\n\t{ },\n};\n\n#define ADMV8818_CHAN(_channel) {\t\t\t\t\\\n\t.type = IIO_ALTVOLTAGE,\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\\\n\t.info_mask_separate =\t\t\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY) | \\\n\t\tBIT(IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY) \\\n}\n\n#define ADMV8818_CHAN_BW_CF(_channel, _admv8818_ext_info) {\t\\\n\t.type = IIO_ALTVOLTAGE,\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\\\n\t.ext_info = _admv8818_ext_info,\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec admv8818_channels[] = {\n\tADMV8818_CHAN(0),\n\tADMV8818_CHAN_BW_CF(0, admv8818_ext_info),\n};\n\nstatic int admv8818_freq_change(struct notifier_block *nb, unsigned long action, void *data)\n{\n\tstruct admv8818_state *st = container_of(nb, struct admv8818_state, nb);\n\n\tif (action == POST_RATE_CHANGE)\n\t\treturn notifier_from_errno(admv8818_rfin_band_select(st));\n\n\treturn NOTIFY_OK;\n}\n\nstatic void admv8818_clk_notifier_unreg(void *data)\n{\n\tstruct admv8818_state *st = data;\n\n\tif (st->filter_mode == 0)\n\t\tclk_notifier_unregister(st->clkin, &st->nb);\n}\n\nstatic void admv8818_clk_disable(void *data)\n{\n\tstruct admv8818_state *st = data;\n\n\tif (st->filter_mode == 0)\n\t\tclk_disable_unprepare(st->clkin);\n}\n\nstatic int admv8818_init(struct admv8818_state *st)\n{\n\tint ret;\n\tstruct spi_device *spi = st->spi;\n\tunsigned int chip_id;\n\n\tret = regmap_update_bits(st->regmap, ADMV8818_REG_SPI_CONFIG_A,\n\t\t\t\t ADMV8818_SOFTRESET_N_MSK |\n\t\t\t\t ADMV8818_SOFTRESET_MSK,\n\t\t\t\t FIELD_PREP(ADMV8818_SOFTRESET_N_MSK, 1) |\n\t\t\t\t FIELD_PREP(ADMV8818_SOFTRESET_MSK, 1));\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"ADMV8818 Soft Reset failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(st->regmap, ADMV8818_REG_SPI_CONFIG_A,\n\t\t\t\t ADMV8818_SDOACTIVE_N_MSK |\n\t\t\t\t ADMV8818_SDOACTIVE_MSK,\n\t\t\t\t FIELD_PREP(ADMV8818_SDOACTIVE_N_MSK, 1) |\n\t\t\t\t FIELD_PREP(ADMV8818_SDOACTIVE_MSK, 1));\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"ADMV8818 SDO Enable failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(st->regmap, ADMV8818_REG_CHIPTYPE, &chip_id);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"ADMV8818 Chip ID read failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (chip_id != 0x1) {\n\t\tdev_err(&spi->dev, \"ADMV8818 Invalid Chip ID.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(st->regmap, ADMV8818_REG_SPI_CONFIG_B,\n\t\t\t\t ADMV8818_SINGLE_INSTRUCTION_MSK,\n\t\t\t\t FIELD_PREP(ADMV8818_SINGLE_INSTRUCTION_MSK, 1));\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"ADMV8818 Single Instruction failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (st->clkin)\n\t\treturn admv8818_rfin_band_select(st);\n\telse\n\t\treturn 0;\n}\n\nstatic int admv8818_clk_setup(struct admv8818_state *st)\n{\n\tstruct spi_device *spi = st->spi;\n\tint ret;\n\n\tst->clkin = devm_clk_get_optional(&spi->dev, \"rf_in\");\n\tif (IS_ERR(st->clkin))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(st->clkin),\n\t\t\t\t     \"failed to get the input clock\\n\");\n\telse if (!st->clkin)\n\t\treturn 0;\n\n\tret = clk_prepare_enable(st->clkin);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, admv8818_clk_disable, st);\n\tif (ret)\n\t\treturn ret;\n\n\tst->nb.notifier_call = admv8818_freq_change;\n\tret = clk_notifier_register(st->clkin, &st->nb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(&spi->dev, admv8818_clk_notifier_unreg, st);\n}\n\nstatic int admv8818_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *regmap;\n\tstruct admv8818_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_spi(spi, &admv8818_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tst = iio_priv(indio_dev);\n\tst->regmap = regmap;\n\n\tindio_dev->info = &admv8818_info;\n\tindio_dev->name = \"admv8818\";\n\tindio_dev->channels = admv8818_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(admv8818_channels);\n\n\tst->spi = spi;\n\n\tret = admv8818_clk_setup(st);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&st->lock);\n\n\tret = admv8818_init(st);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id admv8818_id[] = {\n\t{ \"admv8818\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, admv8818_id);\n\nstatic const struct of_device_id admv8818_of_match[] = {\n\t{ .compatible = \"adi,admv8818\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, admv8818_of_match);\n\nstatic struct spi_driver admv8818_driver = {\n\t.driver = {\n\t\t.name = \"admv8818\",\n\t\t.of_match_table = admv8818_of_match,\n\t},\n\t.probe = admv8818_probe,\n\t.id_table = admv8818_id,\n};\nmodule_spi_driver(admv8818_driver);\n\nMODULE_AUTHOR(\"Antoniu Miclaus <antoniu.miclaus@analog.com\");\nMODULE_DESCRIPTION(\"Analog Devices ADMV8818\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}