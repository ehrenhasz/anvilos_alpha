{
  "module_name": "ad5766.c",
  "hash_id": "531e293884d4ef0949b90c0a4a6470eb7d6bda7225a9783f0e144264906793b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad5766.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <asm/unaligned.h>\n\n#define AD5766_UPPER_WORD_SPI_MASK\t\tGENMASK(31, 16)\n#define AD5766_LOWER_WORD_SPI_MASK\t\tGENMASK(15, 0)\n#define AD5766_DITHER_SOURCE_MASK(ch)\t\tGENMASK(((2 * ch) + 1), (2 * ch))\n#define AD5766_DITHER_SOURCE(ch, source)\tBIT((ch * 2) + source)\n#define AD5766_DITHER_SCALE_MASK(x)\t\tAD5766_DITHER_SOURCE_MASK(x)\n#define AD5766_DITHER_SCALE(ch, scale)\t\t(scale << (ch * 2))\n#define AD5766_DITHER_ENABLE_MASK(ch)\t\tBIT(ch)\n#define AD5766_DITHER_ENABLE(ch, state)\t\t((!state) << ch)\n#define AD5766_DITHER_INVERT_MASK(ch)\t\tBIT(ch)\n#define AD5766_DITHER_INVERT(ch, state)\t\t(state << ch)\n\n#define AD5766_CMD_NOP_MUX_OUT\t\t\t0x00\n#define AD5766_CMD_SDO_CNTRL\t\t\t0x01\n#define AD5766_CMD_WR_IN_REG(x)\t\t\t(0x10 | ((x) & GENMASK(3, 0)))\n#define AD5766_CMD_WR_DAC_REG(x)\t\t(0x20 | ((x) & GENMASK(3, 0)))\n#define AD5766_CMD_SW_LDAC\t\t\t0x30\n#define AD5766_CMD_SPAN_REG\t\t\t0x40\n#define AD5766_CMD_WR_PWR_DITHER\t\t0x51\n#define AD5766_CMD_WR_DAC_REG_ALL\t\t0x60\n#define AD5766_CMD_SW_FULL_RESET\t\t0x70\n#define AD5766_CMD_READBACK_REG(x)\t\t(0x80 | ((x) & GENMASK(3, 0)))\n#define AD5766_CMD_DITHER_SIG_1\t\t\t0x90\n#define AD5766_CMD_DITHER_SIG_2\t\t\t0xA0\n#define AD5766_CMD_INV_DITHER\t\t\t0xB0\n#define AD5766_CMD_DITHER_SCALE_1\t\t0xC0\n#define AD5766_CMD_DITHER_SCALE_2\t\t0xD0\n\n#define AD5766_FULL_RESET_CODE\t\t\t0x1234\n\nenum ad5766_type {\n\tID_AD5766,\n\tID_AD5767,\n};\n\nenum ad5766_voltage_range {\n\tAD5766_VOLTAGE_RANGE_M20V_0V,\n\tAD5766_VOLTAGE_RANGE_M16V_to_0V,\n\tAD5766_VOLTAGE_RANGE_M10V_to_0V,\n\tAD5766_VOLTAGE_RANGE_M12V_to_14V,\n\tAD5766_VOLTAGE_RANGE_M16V_to_10V,\n\tAD5766_VOLTAGE_RANGE_M10V_to_6V,\n\tAD5766_VOLTAGE_RANGE_M5V_to_5V,\n\tAD5766_VOLTAGE_RANGE_M10V_to_10V,\n};\n\n \nstruct ad5766_chip_info {\n\tunsigned int\t\t\tnum_channels;\n\tconst struct iio_chan_spec\t*channels;\n};\n\nenum {\n\tAD5766_DITHER_ENABLE,\n\tAD5766_DITHER_INVERT,\n\tAD5766_DITHER_SOURCE,\n};\n\n \nstatic const char * const ad5766_dither_scales[] = {\n\t\"1\",\n\t\"0.75\",\n\t\"0.5\",\n\t\"0.25\",\n};\n\n \nstruct ad5766_state {\n\tstruct spi_device\t\t*spi;\n\tstruct mutex\t\t\tlock;\n\tconst struct ad5766_chip_info\t*chip_info;\n\tstruct gpio_desc\t\t*gpio_reset;\n\tenum ad5766_voltage_range\tcrt_range;\n\tu16\t\tdither_enable;\n\tu16\t\tdither_invert;\n\tu32\t\tdither_source;\n\tu32\t\tdither_scale;\n\tunion {\n\t\tu32\td32;\n\t\tu16\tw16[2];\n\t\tu8\tb8[4];\n\t} data[3] __aligned(IIO_DMA_MINALIGN);\n};\n\nstruct ad5766_span_tbl {\n\tint\t\tmin;\n\tint\t\tmax;\n};\n\nstatic const struct ad5766_span_tbl ad5766_span_tbl[] = {\n\t[AD5766_VOLTAGE_RANGE_M20V_0V] =\t{-20, 0},\n\t[AD5766_VOLTAGE_RANGE_M16V_to_0V] =\t{-16, 0},\n\t[AD5766_VOLTAGE_RANGE_M10V_to_0V] =\t{-10, 0},\n\t[AD5766_VOLTAGE_RANGE_M12V_to_14V] =\t{-12, 14},\n\t[AD5766_VOLTAGE_RANGE_M16V_to_10V] =\t{-16, 10},\n\t[AD5766_VOLTAGE_RANGE_M10V_to_6V] =\t{-10, 6},\n\t[AD5766_VOLTAGE_RANGE_M5V_to_5V] =\t{-5, 5},\n\t[AD5766_VOLTAGE_RANGE_M10V_to_10V] =\t{-10, 10},\n};\n\nstatic int __ad5766_spi_read(struct ad5766_state *st, u8 dac, int *val)\n{\n\tint ret;\n\tstruct spi_transfer xfers[] = {\n\t\t{\n\t\t\t.tx_buf = &st->data[0].d32,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = 3,\n\t\t\t.cs_change = 1,\n\t\t}, {\n\t\t\t.tx_buf = &st->data[1].d32,\n\t\t\t.rx_buf = &st->data[2].d32,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = 3,\n\t\t},\n\t};\n\n\tst->data[0].d32 = AD5766_CMD_READBACK_REG(dac);\n\tst->data[1].d32 = AD5766_CMD_NOP_MUX_OUT;\n\n\tret = spi_sync_transfer(st->spi, xfers, ARRAY_SIZE(xfers));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = st->data[2].w16[1];\n\n\treturn ret;\n}\n\nstatic int __ad5766_spi_write(struct ad5766_state *st, u8 command, u16 data)\n{\n\tst->data[0].b8[0] = command;\n\tput_unaligned_be16(data, &st->data[0].b8[1]);\n\n\treturn spi_write(st->spi, &st->data[0].b8[0], 3);\n}\n\nstatic int ad5766_read(struct iio_dev *indio_dev, u8 dac, int *val)\n{\n\tstruct ad5766_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __ad5766_spi_read(st, dac, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad5766_write(struct iio_dev *indio_dev, u8 dac, u16 data)\n{\n\tstruct ad5766_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __ad5766_spi_write(st, AD5766_CMD_WR_DAC_REG(dac), data);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad5766_reset(struct ad5766_state *st)\n{\n\tint ret;\n\n\tif (st->gpio_reset) {\n\t\tgpiod_set_value_cansleep(st->gpio_reset, 1);\n\t\tndelay(100);  \n\t\tgpiod_set_value_cansleep(st->gpio_reset, 0);\n\t} else {\n\t\tret = __ad5766_spi_write(st, AD5766_CMD_SW_FULL_RESET,\n\t\t\t\t\tAD5766_FULL_RESET_CODE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tndelay(25);\n\n\treturn 0;\n}\n\nstatic int ad5766_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tstruct ad5766_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = ad5766_read(indio_dev, chan->address, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = ad5766_span_tbl[st->crt_range].min;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = ad5766_span_tbl[st->crt_range].max -\n\t\t       ad5766_span_tbl[st->crt_range].min;\n\t\t*val2 = st->chip_info->channels[0].scan_type.realbits;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad5766_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val,\n\t\t\t    int val2,\n\t\t\t    long info)\n{\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t{\n\t\tconst int max_val = GENMASK(chan->scan_type.realbits - 1, 0);\n\n\t\tif (val > max_val || val < 0)\n\t\t\treturn -EINVAL;\n\t\tval <<= chan->scan_type.shift;\n\t\treturn ad5766_write(indio_dev, chan->address, val);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info ad5766_info = {\n\t.read_raw = ad5766_read_raw,\n\t.write_raw = ad5766_write_raw,\n};\n\nstatic int ad5766_get_dither_source(struct iio_dev *dev,\n\t\t\t\t    const struct iio_chan_spec *chan)\n{\n\tstruct ad5766_state *st = iio_priv(dev);\n\tu32 source;\n\n\tsource = st->dither_source & AD5766_DITHER_SOURCE_MASK(chan->channel);\n\tsource = source >> (chan->channel * 2);\n\tsource -= 1;\n\n\treturn source;\n}\n\nstatic int ad5766_set_dither_source(struct iio_dev *dev,\n\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t  unsigned int source)\n{\n\tstruct ad5766_state *st = iio_priv(dev);\n\tuint16_t val;\n\tint ret;\n\n\tst->dither_source &= ~AD5766_DITHER_SOURCE_MASK(chan->channel);\n\tst->dither_source |= AD5766_DITHER_SOURCE(chan->channel, source);\n\n\tval = FIELD_GET(AD5766_LOWER_WORD_SPI_MASK, st->dither_source);\n\tret = ad5766_write(dev, AD5766_CMD_DITHER_SIG_1, val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = FIELD_GET(AD5766_UPPER_WORD_SPI_MASK, st->dither_source);\n\n\treturn ad5766_write(dev, AD5766_CMD_DITHER_SIG_2, val);\n}\n\nstatic int ad5766_get_dither_scale(struct iio_dev *dev,\n\t\t\t\t   const struct iio_chan_spec *chan)\n{\n\tstruct ad5766_state *st = iio_priv(dev);\n\tu32 scale;\n\n\tscale = st->dither_scale & AD5766_DITHER_SCALE_MASK(chan->channel);\n\n\treturn (scale >> (chan->channel * 2));\n}\n\nstatic int ad5766_set_dither_scale(struct iio_dev *dev,\n\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t  unsigned int scale)\n{\n\tint ret;\n\tstruct ad5766_state *st = iio_priv(dev);\n\tuint16_t val;\n\n\tst->dither_scale &= ~AD5766_DITHER_SCALE_MASK(chan->channel);\n\tst->dither_scale |= AD5766_DITHER_SCALE(chan->channel, scale);\n\n\tval = FIELD_GET(AD5766_LOWER_WORD_SPI_MASK, st->dither_scale);\n\tret = ad5766_write(dev, AD5766_CMD_DITHER_SCALE_1, val);\n\tif (ret)\n\t\treturn ret;\n\tval = FIELD_GET(AD5766_UPPER_WORD_SPI_MASK, st->dither_scale);\n\n\treturn ad5766_write(dev, AD5766_CMD_DITHER_SCALE_2, val);\n}\n\nstatic const struct iio_enum ad5766_dither_scale_enum = {\n\t.items = ad5766_dither_scales,\n\t.num_items = ARRAY_SIZE(ad5766_dither_scales),\n\t.set = ad5766_set_dither_scale,\n\t.get = ad5766_get_dither_scale,\n};\n\nstatic ssize_t ad5766_read_ext(struct iio_dev *indio_dev,\n\t\t\t       uintptr_t private,\n\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t       char *buf)\n{\n\tstruct ad5766_state *st = iio_priv(indio_dev);\n\n\tswitch (private) {\n\tcase AD5766_DITHER_ENABLE:\n\t\treturn sprintf(buf, \"%u\\n\",\n\t\t\t       !(st->dither_enable & BIT(chan->channel)));\n\t\tbreak;\n\tcase AD5766_DITHER_INVERT:\n\t\treturn sprintf(buf, \"%u\\n\",\n\t\t\t       !!(st->dither_invert & BIT(chan->channel)));\n\t\tbreak;\n\tcase AD5766_DITHER_SOURCE:\n\t\treturn sprintf(buf, \"%d\\n\",\n\t\t\t       ad5766_get_dither_source(indio_dev, chan));\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t ad5766_write_ext(struct iio_dev *indio_dev,\n\t\t\t\t uintptr_t private,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t const char *buf, size_t len)\n{\n\tstruct ad5766_state *st = iio_priv(indio_dev);\n\tbool readin;\n\tint ret;\n\n\tret = kstrtobool(buf, &readin);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (private) {\n\tcase AD5766_DITHER_ENABLE:\n\t\tst->dither_enable &= ~AD5766_DITHER_ENABLE_MASK(chan->channel);\n\t\tst->dither_enable |= AD5766_DITHER_ENABLE(chan->channel,\n\t\t\t\t\t\t\t  readin);\n\t\tret = ad5766_write(indio_dev, AD5766_CMD_WR_PWR_DITHER,\n\t\t\t\t   st->dither_enable);\n\t\tbreak;\n\tcase AD5766_DITHER_INVERT:\n\t\tst->dither_invert &= ~AD5766_DITHER_INVERT_MASK(chan->channel);\n\t\tst->dither_invert |= AD5766_DITHER_INVERT(chan->channel,\n\t\t\t\t\t\t\t  readin);\n\t\tret = ad5766_write(indio_dev, AD5766_CMD_INV_DITHER,\n\t\t\t\t   st->dither_invert);\n\t\tbreak;\n\tcase AD5766_DITHER_SOURCE:\n\t\tret = ad5766_set_dither_source(indio_dev, chan, readin);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret ? ret : len;\n}\n\n#define _AD5766_CHAN_EXT_INFO(_name, _what, _shared) { \\\n\t.name = _name, \\\n\t.read = ad5766_read_ext, \\\n\t.write = ad5766_write_ext, \\\n\t.private = _what, \\\n\t.shared = _shared, \\\n}\n\nstatic const struct iio_chan_spec_ext_info ad5766_ext_info[] = {\n\n\t_AD5766_CHAN_EXT_INFO(\"dither_enable\", AD5766_DITHER_ENABLE,\n\t\t\t      IIO_SEPARATE),\n\t_AD5766_CHAN_EXT_INFO(\"dither_invert\", AD5766_DITHER_INVERT,\n\t\t\t      IIO_SEPARATE),\n\t_AD5766_CHAN_EXT_INFO(\"dither_source\", AD5766_DITHER_SOURCE,\n\t\t\t      IIO_SEPARATE),\n\tIIO_ENUM(\"dither_scale\", IIO_SEPARATE, &ad5766_dither_scale_enum),\n\tIIO_ENUM_AVAILABLE(\"dither_scale\", IIO_SEPARATE,\n\t\t\t   &ad5766_dither_scale_enum),\n\t{}\n};\n\n#define AD576x_CHANNEL(_chan, _bits) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\t\\\n\t.channel = (_chan),\t\t\t\t\t\t\\\n\t.address = (_chan),\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_SCALE),\t\t\t\t\\\n\t.scan_index = (_chan),\t\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\t\\\n\t\t.realbits = (_bits),\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\t\\\n\t\t.shift = 16 - (_bits),\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.ext_info = ad5766_ext_info,\t\t\t\t\t\\\n}\n\n#define DECLARE_AD576x_CHANNELS(_name, _bits)\t\t\t\\\nconst struct iio_chan_spec _name[] = {\t\t\t\t\\\n\tAD576x_CHANNEL(0, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(1, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(2, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(3, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(4, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(5, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(6, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(7, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(8, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(9, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(10, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(11, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(12, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(13, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(14, (_bits)),\t\t\t\t\\\n\tAD576x_CHANNEL(15, (_bits)),\t\t\t\t\\\n}\n\nstatic DECLARE_AD576x_CHANNELS(ad5766_channels, 16);\nstatic DECLARE_AD576x_CHANNELS(ad5767_channels, 12);\n\nstatic const struct ad5766_chip_info ad5766_chip_infos[] = {\n\t[ID_AD5766] = {\n\t\t.num_channels = ARRAY_SIZE(ad5766_channels),\n\t\t.channels = ad5766_channels,\n\t},\n\t[ID_AD5767] = {\n\t\t.num_channels = ARRAY_SIZE(ad5767_channels),\n\t\t.channels = ad5767_channels,\n\t},\n};\n\nstatic int ad5766_get_output_range(struct ad5766_state *st)\n{\n\tint i, ret, min, max, tmp[2];\n\n\tret = device_property_read_u32_array(&st->spi->dev,\n\t\t\t\t\t     \"output-range-microvolts\",\n\t\t\t\t\t     tmp, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tmin = tmp[0] / 1000000;\n\tmax = tmp[1] / 1000000;\n\tfor (i = 0; i < ARRAY_SIZE(ad5766_span_tbl); i++) {\n\t\tif (ad5766_span_tbl[i].min != min ||\n\t\t    ad5766_span_tbl[i].max != max)\n\t\t\tcontinue;\n\n\t\tst->crt_range = i;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ad5766_default_setup(struct ad5766_state *st)\n{\n\tuint16_t val;\n\tint ret, i;\n\n\t \n\tret = ad5766_reset(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad5766_get_output_range(st);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tst->dither_enable = GENMASK(15, 0);\n\tret = __ad5766_spi_write(st, AD5766_CMD_WR_PWR_DITHER,\n\t\t\t     st->dither_enable);\n\tif (ret)\n\t\treturn ret;\n\n\tst->dither_source = 0;\n\tfor (i = 0; i < ARRAY_SIZE(ad5766_channels); i++)\n\t\tst->dither_source |= AD5766_DITHER_SOURCE(i, 0);\n\tval = FIELD_GET(AD5766_LOWER_WORD_SPI_MASK, st->dither_source);\n\tret = __ad5766_spi_write(st, AD5766_CMD_DITHER_SIG_1, val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = FIELD_GET(AD5766_UPPER_WORD_SPI_MASK, st->dither_source);\n\tret = __ad5766_spi_write(st, AD5766_CMD_DITHER_SIG_2, val);\n\tif (ret)\n\t\treturn ret;\n\n\tst->dither_scale = 0;\n\tval = FIELD_GET(AD5766_LOWER_WORD_SPI_MASK, st->dither_scale);\n\tret = __ad5766_spi_write(st, AD5766_CMD_DITHER_SCALE_1, val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = FIELD_GET(AD5766_UPPER_WORD_SPI_MASK, st->dither_scale);\n\tret = __ad5766_spi_write(st, AD5766_CMD_DITHER_SCALE_2, val);\n\tif (ret)\n\t\treturn ret;\n\n\tst->dither_invert = 0;\n\tret = __ad5766_spi_write(st, AD5766_CMD_INV_DITHER, st->dither_invert);\n\tif (ret)\n\t\treturn ret;\n\n\treturn  __ad5766_spi_write(st, AD5766_CMD_SPAN_REG, st->crt_range);\n}\n\nstatic irqreturn_t ad5766_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct iio_buffer *buffer = indio_dev->buffer;\n\tstruct ad5766_state *st = iio_priv(indio_dev);\n\tint ret, ch, i;\n\tu16 data[ARRAY_SIZE(ad5766_channels)];\n\n\tret = iio_pop_from_buffer(buffer, data);\n\tif (ret)\n\t\tgoto done;\n\n\ti = 0;\n\tmutex_lock(&st->lock);\n\tfor_each_set_bit(ch, indio_dev->active_scan_mask,\n\t\t\t st->chip_info->num_channels - 1)\n\t\t__ad5766_spi_write(st, AD5766_CMD_WR_IN_REG(ch), data[i++]);\n\n\t__ad5766_spi_write(st, AD5766_CMD_SW_LDAC,\n\t\t\t   *indio_dev->active_scan_mask);\n\tmutex_unlock(&st->lock);\n\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ad5766_probe(struct spi_device *spi)\n{\n\tenum ad5766_type type;\n\tstruct iio_dev *indio_dev;\n\tstruct ad5766_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tmutex_init(&st->lock);\n\n\tst->spi = spi;\n\ttype = spi_get_device_id(spi)->driver_data;\n\tst->chip_info = &ad5766_chip_infos[type];\n\n\tindio_dev->channels = st->chip_info->channels;\n\tindio_dev->num_channels = st->chip_info->num_channels;\n\tindio_dev->info = &ad5766_info;\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tst->gpio_reset = devm_gpiod_get_optional(&st->spi->dev, \"reset\",\n\t\t\t\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(st->gpio_reset))\n\t\treturn PTR_ERR(st->gpio_reset);\n\n\tret = ad5766_default_setup(st);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = devm_iio_triggered_buffer_setup_ext(&spi->dev, indio_dev, NULL,\n\t\t\t\t\t\t  ad5766_trigger_handler,\n\t\t\t\t\t\t  IIO_BUFFER_DIRECTION_OUT,\n\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t  NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id ad5766_dt_match[] = {\n\t{ .compatible = \"adi,ad5766\" },\n\t{ .compatible = \"adi,ad5767\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ad5766_dt_match);\n\nstatic const struct spi_device_id ad5766_spi_ids[] = {\n\t{ \"ad5766\", ID_AD5766 },\n\t{ \"ad5767\", ID_AD5767 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad5766_spi_ids);\n\nstatic struct spi_driver ad5766_driver = {\n\t.driver = {\n\t\t.name = \"ad5766\",\n\t\t.of_match_table = ad5766_dt_match,\n\t},\n\t.probe = ad5766_probe,\n\t.id_table = ad5766_spi_ids,\n};\nmodule_spi_driver(ad5766_driver);\n\nMODULE_AUTHOR(\"Denis-Gabriel Gheorghescu <denis.gheorghescu@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5766/AD5767 DACs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}