{
  "module_name": "ltc2688.c",
  "hash_id": "9663faf86441df37df47abd16e85cce4f02e4303c00037e7fec153a493ed3a27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ltc2688.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iio/iio.h>\n#include <linux/limits.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#define LTC2688_DAC_CHANNELS\t\t\t16\n\n#define LTC2688_CMD_CH_CODE(x)\t\t\t(0x00 + (x))\n#define LTC2688_CMD_CH_SETTING(x)\t\t(0x10 + (x))\n#define LTC2688_CMD_CH_OFFSET(x)\t\t(0X20 + (x))\n#define LTC2688_CMD_CH_GAIN(x)\t\t\t(0x30 + (x))\n#define LTC2688_CMD_CH_CODE_UPDATE(x)\t\t(0x40 + (x))\n\n#define LTC2688_CMD_CONFIG\t\t\t0x70\n#define LTC2688_CMD_POWERDOWN\t\t\t0x71\n#define LTC2688_CMD_A_B_SELECT\t\t\t0x72\n#define LTC2688_CMD_SW_TOGGLE\t\t\t0x73\n#define LTC2688_CMD_TOGGLE_DITHER_EN\t\t0x74\n#define LTC2688_CMD_THERMAL_STAT\t\t0x77\n#define LTC2688_CMD_UPDATE_ALL\t\t\t0x7C\n#define LTC2688_CMD_NOOP\t\t\t0xFF\n\n#define LTC2688_READ_OPERATION\t\t\t0x80\n\n \n#define LTC2688_CH_SPAN_MSK\t\t\tGENMASK(2, 0)\n#define LTC2688_CH_OVERRANGE_MSK\t\tBIT(3)\n#define LTC2688_CH_TD_SEL_MSK\t\t\tGENMASK(5, 4)\n#define LTC2688_CH_TGP_MAX\t\t\t3\n#define LTC2688_CH_DIT_PER_MSK\t\t\tGENMASK(8, 6)\n#define LTC2688_CH_DIT_PH_MSK\t\t\tGENMASK(10, 9)\n#define LTC2688_CH_MODE_MSK\t\t\tBIT(11)\n\n#define LTC2688_DITHER_RAW_MASK\t\t\tGENMASK(15, 2)\n#define LTC2688_CH_CALIBBIAS_MASK\t\tGENMASK(15, 2)\n#define LTC2688_DITHER_RAW_MAX_VAL\t\t(BIT(14) - 1)\n#define LTC2688_CH_CALIBBIAS_MAX_VAL\t\t(BIT(14) - 1)\n\n \n#define LTC2688_CONFIG_RST\t\t\tBIT(15)\n#define LTC2688_CONFIG_EXT_REF\t\t\tBIT(1)\n\n#define LTC2688_DITHER_FREQ_AVAIL_N\t\t5\n\nenum {\n\tLTC2688_SPAN_RANGE_0V_5V,\n\tLTC2688_SPAN_RANGE_0V_10V,\n\tLTC2688_SPAN_RANGE_M5V_5V,\n\tLTC2688_SPAN_RANGE_M10V_10V,\n\tLTC2688_SPAN_RANGE_M15V_15V,\n\tLTC2688_SPAN_RANGE_MAX\n};\n\nenum {\n\tLTC2688_MODE_DEFAULT,\n\tLTC2688_MODE_DITHER_TOGGLE,\n};\n\nstruct ltc2688_chan {\n\tlong dither_frequency[LTC2688_DITHER_FREQ_AVAIL_N];\n\tbool overrange;\n\tbool toggle_chan;\n\tu8 mode;\n};\n\nstruct ltc2688_state {\n\tstruct spi_device *spi;\n\tstruct regmap *regmap;\n\tstruct ltc2688_chan channels[LTC2688_DAC_CHANNELS];\n\tstruct iio_chan_spec *iio_chan;\n\t \n\tstruct mutex lock;\n\tint vref;\n\t \n\tu8 tx_data[6] __aligned(IIO_DMA_MINALIGN);\n\tu8 rx_data[3];\n};\n\nstatic int ltc2688_spi_read(void *context, const void *reg, size_t reg_size,\n\t\t\t    void *val, size_t val_size)\n{\n\tstruct ltc2688_state *st = context;\n\tstruct spi_transfer xfers[] = {\n\t\t{\n\t\t\t.tx_buf = st->tx_data,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = reg_size + val_size,\n\t\t\t.cs_change = 1,\n\t\t}, {\n\t\t\t.tx_buf = st->tx_data + 3,\n\t\t\t.rx_buf = st->rx_data,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = reg_size + val_size,\n\t\t},\n\t};\n\tint ret;\n\n\tmemcpy(st->tx_data, reg, reg_size);\n\n\tret = spi_sync_transfer(st->spi, xfers, ARRAY_SIZE(xfers));\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(val, &st->rx_data[1], val_size);\n\n\treturn 0;\n}\n\nstatic int ltc2688_spi_write(void *context, const void *data, size_t count)\n{\n\tstruct ltc2688_state *st = context;\n\n\treturn spi_write(st->spi, data, count);\n}\n\nstatic int ltc2688_span_get(const struct ltc2688_state *st, int c)\n{\n\tint ret, reg, span;\n\n\tret = regmap_read(st->regmap, LTC2688_CMD_CH_SETTING(c), &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tspan = FIELD_GET(LTC2688_CH_SPAN_MSK, reg);\n\t \n\tif (span >= LTC2688_SPAN_RANGE_MAX)\n\t\treturn -EIO;\n\n\treturn span;\n}\n\nstatic const int ltc2688_span_helper[LTC2688_SPAN_RANGE_MAX][2] = {\n\t{0, 5000}, {0, 10000}, {-5000, 5000}, {-10000, 10000}, {-15000, 15000},\n};\n\nstatic int ltc2688_scale_get(const struct ltc2688_state *st, int c, int *val)\n{\n\tconst struct ltc2688_chan *chan = &st->channels[c];\n\tint span, fs;\n\n\tspan = ltc2688_span_get(st, c);\n\tif (span < 0)\n\t\treturn span;\n\n\tfs = ltc2688_span_helper[span][1] - ltc2688_span_helper[span][0];\n\tif (chan->overrange)\n\t\tfs = mult_frac(fs, 105, 100);\n\n\t*val = DIV_ROUND_CLOSEST(fs * st->vref, 4096);\n\n\treturn 0;\n}\n\nstatic int ltc2688_offset_get(const struct ltc2688_state *st, int c, int *val)\n{\n\tint span;\n\n\tspan = ltc2688_span_get(st, c);\n\tif (span < 0)\n\t\treturn span;\n\n\tif (ltc2688_span_helper[span][0] < 0)\n\t\t*val = -32768;\n\telse\n\t\t*val = 0;\n\n\treturn 0;\n}\n\nenum {\n\tLTC2688_INPUT_A,\n\tLTC2688_INPUT_B,\n\tLTC2688_INPUT_B_AVAIL,\n\tLTC2688_DITHER_OFF,\n\tLTC2688_DITHER_FREQ_AVAIL,\n};\n\nstatic int ltc2688_dac_code_write(struct ltc2688_state *st, u32 chan, u32 input,\n\t\t\t\t  u16 code)\n{\n\tstruct ltc2688_chan *c = &st->channels[chan];\n\tint ret, reg;\n\n\t \n\tif (!c->toggle_chan && input == LTC2688_INPUT_B) {\n\t\tif (code > LTC2688_DITHER_RAW_MAX_VAL)\n\t\t\treturn -EINVAL;\n\n\t\tcode = FIELD_PREP(LTC2688_DITHER_RAW_MASK, code);\n\t}\n\n\tmutex_lock(&st->lock);\n\t \n\tret = regmap_update_bits(st->regmap, LTC2688_CMD_A_B_SELECT, BIT(chan),\n\t\t\t\t input << chan);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tif (c->mode == LTC2688_MODE_DEFAULT)\n\t\treg = LTC2688_CMD_CH_CODE_UPDATE(chan);\n\telse\n\t\treg = LTC2688_CMD_CH_CODE(chan);\n\n\tret = regmap_write(st->regmap, reg, code);\nout_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic int ltc2688_dac_code_read(struct ltc2688_state *st, u32 chan, u32 input,\n\t\t\t\t u32 *code)\n{\n\tstruct ltc2688_chan *c = &st->channels[chan];\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = regmap_update_bits(st->regmap, LTC2688_CMD_A_B_SELECT, BIT(chan),\n\t\t\t\t input << chan);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_read(st->regmap, LTC2688_CMD_CH_CODE(chan), code);\nout_unlock:\n\tmutex_unlock(&st->lock);\n\n\tif (!c->toggle_chan && input == LTC2688_INPUT_B)\n\t\t*code = FIELD_GET(LTC2688_DITHER_RAW_MASK, *code);\n\n\treturn ret;\n}\n\nstatic const int ltc2688_raw_range[] = {0, 1, U16_MAX};\n\nstatic int ltc2688_read_avail(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      const int **vals, int *type, int *length,\n\t\t\t      long info)\n{\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*vals = ltc2688_raw_range;\n\t\t*type = IIO_VAL_INT;\n\t\treturn IIO_AVAIL_RANGE;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ltc2688_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2, long info)\n{\n\tstruct ltc2688_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = ltc2688_dac_code_read(st, chan->channel, LTC2688_INPUT_A,\n\t\t\t\t\t    val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tret = ltc2688_offset_get(st, chan->channel, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = ltc2688_scale_get(st, chan->channel, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val2 = 16;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = regmap_read(st->regmap,\n\t\t\t\t  LTC2688_CMD_CH_OFFSET(chan->channel), val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = FIELD_GET(LTC2688_CH_CALIBBIAS_MASK, *val);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tret = regmap_read(st->regmap,\n\t\t\t\t  LTC2688_CMD_CH_GAIN(chan->channel), val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ltc2688_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int val,\n\t\t\t     int val2, long info)\n{\n\tstruct ltc2688_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val > U16_MAX || val < 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn ltc2688_dac_code_write(st, chan->channel,\n\t\t\t\t\t      LTC2688_INPUT_A, val);\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif (val > LTC2688_CH_CALIBBIAS_MAX_VAL)\n\t\t\treturn -EINVAL;\n\n\t\treturn regmap_write(st->regmap,\n\t\t\t\t    LTC2688_CMD_CH_OFFSET(chan->channel),\n\t\t\t\t    FIELD_PREP(LTC2688_CH_CALIBBIAS_MASK, val));\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\treturn regmap_write(st->regmap,\n\t\t\t\t    LTC2688_CMD_CH_GAIN(chan->channel), val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t ltc2688_dither_toggle_set(struct iio_dev *indio_dev,\n\t\t\t\t\t uintptr_t private,\n\t\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t\t const char *buf, size_t len)\n{\n\tstruct ltc2688_state *st = iio_priv(indio_dev);\n\tstruct ltc2688_chan *c = &st->channels[chan->channel];\n\tint ret;\n\tbool en;\n\n\tret = kstrtobool(buf, &en);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\tret = regmap_update_bits(st->regmap, LTC2688_CMD_TOGGLE_DITHER_EN,\n\t\t\t\t BIT(chan->channel), en << chan->channel);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tc->mode = en ? LTC2688_MODE_DITHER_TOGGLE : LTC2688_MODE_DEFAULT;\nout_unlock:\n\tmutex_unlock(&st->lock);\n\n\treturn ret ?: len;\n}\n\nstatic ssize_t ltc2688_reg_bool_get(struct iio_dev *indio_dev,\n\t\t\t\t    uintptr_t private,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    char *buf)\n{\n\tconst struct ltc2688_state *st = iio_priv(indio_dev);\n\tint ret;\n\tu32 val;\n\n\tret = regmap_read(st->regmap, private, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%u\\n\", !!(val & BIT(chan->channel)));\n}\n\nstatic ssize_t ltc2688_reg_bool_set(struct iio_dev *indio_dev,\n\t\t\t\t    uintptr_t private,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    const char *buf, size_t len)\n{\n\tconst struct ltc2688_state *st = iio_priv(indio_dev);\n\tint ret;\n\tbool en;\n\n\tret = kstrtobool(buf, &en);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(st->regmap, private, BIT(chan->channel),\n\t\t\t\t en << chan->channel);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t ltc2688_dither_freq_avail(const struct ltc2688_state *st,\n\t\t\t\t\t const struct ltc2688_chan *chan,\n\t\t\t\t\t char *buf)\n{\n\tint sz = 0;\n\tu32 f;\n\n\tfor (f = 0; f < ARRAY_SIZE(chan->dither_frequency); f++)\n\t\tsz += sysfs_emit_at(buf, sz, \"%ld \", chan->dither_frequency[f]);\n\n\tbuf[sz - 1] = '\\n';\n\n\treturn sz;\n}\n\nstatic ssize_t ltc2688_dither_freq_get(struct iio_dev *indio_dev,\n\t\t\t\t       uintptr_t private,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       char *buf)\n{\n\tconst struct ltc2688_state *st = iio_priv(indio_dev);\n\tconst struct ltc2688_chan *c = &st->channels[chan->channel];\n\tu32 reg, freq;\n\tint ret;\n\n\tif (private == LTC2688_DITHER_FREQ_AVAIL)\n\t\treturn ltc2688_dither_freq_avail(st, c, buf);\n\n\tret = regmap_read(st->regmap, LTC2688_CMD_CH_SETTING(chan->channel),\n\t\t\t  &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tfreq = FIELD_GET(LTC2688_CH_DIT_PER_MSK, reg);\n\tif (freq >= ARRAY_SIZE(c->dither_frequency))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buf, \"%ld\\n\", c->dither_frequency[freq]);\n}\n\nstatic ssize_t ltc2688_dither_freq_set(struct iio_dev *indio_dev,\n\t\t\t\t       uintptr_t private,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       const char *buf, size_t len)\n{\n\tconst struct ltc2688_state *st = iio_priv(indio_dev);\n\tconst struct ltc2688_chan *c = &st->channels[chan->channel];\n\tlong val;\n\tu32 freq;\n\tint ret;\n\n\tif (private == LTC2688_DITHER_FREQ_AVAIL)\n\t\treturn -EINVAL;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (freq = 0; freq < ARRAY_SIZE(c->dither_frequency); freq++) {\n\t\tif (val == c->dither_frequency[freq])\n\t\t\tbreak;\n\t}\n\n\tif (freq == ARRAY_SIZE(c->dither_frequency))\n\t\treturn -EINVAL;\n\n\tret = regmap_update_bits(st->regmap,\n\t\t\t\t LTC2688_CMD_CH_SETTING(chan->channel),\n\t\t\t\t LTC2688_CH_DIT_PER_MSK,\n\t\t\t\t FIELD_PREP(LTC2688_CH_DIT_PER_MSK, freq));\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t ltc2688_dac_input_read(struct iio_dev *indio_dev,\n\t\t\t\t      uintptr_t private,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      char *buf)\n{\n\tstruct ltc2688_state *st = iio_priv(indio_dev);\n\tint ret;\n\tu32 val;\n\n\tif (private == LTC2688_INPUT_B_AVAIL)\n\t\treturn sysfs_emit(buf, \"[%u %u %u]\\n\", ltc2688_raw_range[0],\n\t\t\t\t  ltc2688_raw_range[1],\n\t\t\t\t  ltc2688_raw_range[2] / 4);\n\n\tif (private == LTC2688_DITHER_OFF)\n\t\treturn sysfs_emit(buf, \"0\\n\");\n\n\tret = ltc2688_dac_code_read(st, chan->channel, private, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t ltc2688_dac_input_write(struct iio_dev *indio_dev,\n\t\t\t\t       uintptr_t private,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       const char *buf, size_t len)\n{\n\tstruct ltc2688_state *st = iio_priv(indio_dev);\n\tint ret;\n\tu16 val;\n\n\tif (private == LTC2688_INPUT_B_AVAIL || private == LTC2688_DITHER_OFF)\n\t\treturn -EINVAL;\n\n\tret = kstrtou16(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ltc2688_dac_code_write(st, chan->channel, private, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic int ltc2688_get_dither_phase(struct iio_dev *dev,\n\t\t\t\t    const struct iio_chan_spec *chan)\n{\n\tstruct ltc2688_state *st = iio_priv(dev);\n\tint ret, regval;\n\n\tret = regmap_read(st->regmap, LTC2688_CMD_CH_SETTING(chan->channel),\n\t\t\t  &regval);\n\tif (ret)\n\t\treturn ret;\n\n\treturn FIELD_GET(LTC2688_CH_DIT_PH_MSK, regval);\n}\n\nstatic int ltc2688_set_dither_phase(struct iio_dev *dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    unsigned int phase)\n{\n\tstruct ltc2688_state *st = iio_priv(dev);\n\n\treturn regmap_update_bits(st->regmap,\n\t\t\t\t  LTC2688_CMD_CH_SETTING(chan->channel),\n\t\t\t\t  LTC2688_CH_DIT_PH_MSK,\n\t\t\t\t  FIELD_PREP(LTC2688_CH_DIT_PH_MSK, phase));\n}\n\nstatic int ltc2688_reg_access(struct iio_dev *indio_dev,\n\t\t\t      unsigned int reg,\n\t\t\t      unsigned int writeval,\n\t\t\t      unsigned int *readval)\n{\n\tstruct ltc2688_state *st = iio_priv(indio_dev);\n\n\tif (readval)\n\t\treturn regmap_read(st->regmap, reg, readval);\n\n\treturn regmap_write(st->regmap, reg, writeval);\n}\n\nstatic const char * const ltc2688_dither_phase[] = {\n\t\"0\", \"1.5708\", \"3.14159\", \"4.71239\",\n};\n\nstatic const struct iio_enum ltc2688_dither_phase_enum = {\n\t.items = ltc2688_dither_phase,\n\t.num_items = ARRAY_SIZE(ltc2688_dither_phase),\n\t.set = ltc2688_set_dither_phase,\n\t.get = ltc2688_get_dither_phase,\n};\n\n#define LTC2688_CHAN_EXT_INFO(_name, _what, _shared, _read, _write) {\t\\\n\t.name = _name,\t\t\t\t\t\t\t\\\n\t.read = (_read),\t\t\t\t\t\t\\\n\t.write = (_write),\t\t\t\t\t\t\\\n\t.private = (_what),\t\t\t\t\t\t\\\n\t.shared = (_shared),\t\t\t\t\t\t\\\n}\n\n \nstatic const struct iio_chan_spec_ext_info ltc2688_toggle_sym_ext_info[] = {\n\tLTC2688_CHAN_EXT_INFO(\"raw0\", LTC2688_INPUT_A, IIO_SEPARATE,\n\t\t\t      ltc2688_dac_input_read, ltc2688_dac_input_write),\n\tLTC2688_CHAN_EXT_INFO(\"raw1\", LTC2688_INPUT_B, IIO_SEPARATE,\n\t\t\t      ltc2688_dac_input_read, ltc2688_dac_input_write),\n\tLTC2688_CHAN_EXT_INFO(\"toggle_en\", LTC2688_CMD_TOGGLE_DITHER_EN,\n\t\t\t      IIO_SEPARATE, ltc2688_reg_bool_get,\n\t\t\t      ltc2688_dither_toggle_set),\n\tLTC2688_CHAN_EXT_INFO(\"powerdown\", LTC2688_CMD_POWERDOWN, IIO_SEPARATE,\n\t\t\t      ltc2688_reg_bool_get, ltc2688_reg_bool_set),\n\tLTC2688_CHAN_EXT_INFO(\"symbol\", LTC2688_CMD_SW_TOGGLE, IIO_SEPARATE,\n\t\t\t      ltc2688_reg_bool_get, ltc2688_reg_bool_set),\n\t{}\n};\n\nstatic const struct iio_chan_spec_ext_info ltc2688_toggle_ext_info[] = {\n\tLTC2688_CHAN_EXT_INFO(\"raw0\", LTC2688_INPUT_A, IIO_SEPARATE,\n\t\t\t      ltc2688_dac_input_read, ltc2688_dac_input_write),\n\tLTC2688_CHAN_EXT_INFO(\"raw1\", LTC2688_INPUT_B, IIO_SEPARATE,\n\t\t\t      ltc2688_dac_input_read, ltc2688_dac_input_write),\n\tLTC2688_CHAN_EXT_INFO(\"toggle_en\", LTC2688_CMD_TOGGLE_DITHER_EN,\n\t\t\t      IIO_SEPARATE, ltc2688_reg_bool_get,\n\t\t\t      ltc2688_dither_toggle_set),\n\tLTC2688_CHAN_EXT_INFO(\"powerdown\", LTC2688_CMD_POWERDOWN, IIO_SEPARATE,\n\t\t\t      ltc2688_reg_bool_get, ltc2688_reg_bool_set),\n\t{}\n};\n\nstatic struct iio_chan_spec_ext_info ltc2688_dither_ext_info[] = {\n\tLTC2688_CHAN_EXT_INFO(\"dither_raw\", LTC2688_INPUT_B, IIO_SEPARATE,\n\t\t\t      ltc2688_dac_input_read, ltc2688_dac_input_write),\n\tLTC2688_CHAN_EXT_INFO(\"dither_raw_available\", LTC2688_INPUT_B_AVAIL,\n\t\t\t      IIO_SEPARATE, ltc2688_dac_input_read,\n\t\t\t      ltc2688_dac_input_write),\n\tLTC2688_CHAN_EXT_INFO(\"dither_offset\", LTC2688_DITHER_OFF, IIO_SEPARATE,\n\t\t\t      ltc2688_dac_input_read, ltc2688_dac_input_write),\n\t \n\tLTC2688_CHAN_EXT_INFO(\"dither_frequency\", 0, IIO_SEPARATE,\n\t\t\t      ltc2688_dither_freq_get, ltc2688_dither_freq_set),\n\tLTC2688_CHAN_EXT_INFO(\"dither_frequency_available\",\n\t\t\t      LTC2688_DITHER_FREQ_AVAIL, IIO_SEPARATE,\n\t\t\t      ltc2688_dither_freq_get, ltc2688_dither_freq_set),\n\tIIO_ENUM(\"dither_phase\", IIO_SEPARATE, &ltc2688_dither_phase_enum),\n\tIIO_ENUM_AVAILABLE(\"dither_phase\", IIO_SEPARATE,\n\t\t\t   &ltc2688_dither_phase_enum),\n\tLTC2688_CHAN_EXT_INFO(\"dither_en\", LTC2688_CMD_TOGGLE_DITHER_EN,\n\t\t\t      IIO_SEPARATE, ltc2688_reg_bool_get,\n\t\t\t      ltc2688_dither_toggle_set),\n\tLTC2688_CHAN_EXT_INFO(\"powerdown\", LTC2688_CMD_POWERDOWN, IIO_SEPARATE,\n\t\t\t      ltc2688_reg_bool_get, ltc2688_reg_bool_set),\n\t{}\n};\n\nstatic const struct iio_chan_spec_ext_info ltc2688_ext_info[] = {\n\tLTC2688_CHAN_EXT_INFO(\"powerdown\", LTC2688_CMD_POWERDOWN, IIO_SEPARATE,\n\t\t\t      ltc2688_reg_bool_get, ltc2688_reg_bool_set),\n\t{}\n};\n\n#define LTC2688_CHANNEL(_chan) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\t\\\n\t.channel = (_chan),\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_CALIBSCALE) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_OFFSET) |\t\\\n\t\tBIT(IIO_CHAN_INFO_CALIBBIAS) | BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.ext_info = ltc2688_ext_info,\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec ltc2688_channels[] = {\n\tLTC2688_CHANNEL(0),\n\tLTC2688_CHANNEL(1),\n\tLTC2688_CHANNEL(2),\n\tLTC2688_CHANNEL(3),\n\tLTC2688_CHANNEL(4),\n\tLTC2688_CHANNEL(5),\n\tLTC2688_CHANNEL(6),\n\tLTC2688_CHANNEL(7),\n\tLTC2688_CHANNEL(8),\n\tLTC2688_CHANNEL(9),\n\tLTC2688_CHANNEL(10),\n\tLTC2688_CHANNEL(11),\n\tLTC2688_CHANNEL(12),\n\tLTC2688_CHANNEL(13),\n\tLTC2688_CHANNEL(14),\n\tLTC2688_CHANNEL(15),\n};\n\nstatic void ltc2688_clk_disable(void *clk)\n{\n\tclk_disable_unprepare(clk);\n}\n\nstatic const int ltc2688_period[LTC2688_DITHER_FREQ_AVAIL_N] = {\n\t4, 8, 16, 32, 64,\n};\n\nstatic int ltc2688_tgp_clk_setup(struct ltc2688_state *st,\n\t\t\t\t struct ltc2688_chan *chan,\n\t\t\t\t struct fwnode_handle *node, int tgp)\n{\n\tstruct device *dev = &st->spi->dev;\n\tunsigned long rate;\n\tstruct clk *clk;\n\tint ret, f;\n\n\tclk = devm_get_clk_from_child(dev, to_of_node(node), NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(clk), \"failed to get tgp clk.\\n\");\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to enable tgp clk.\\n\");\n\n\tret = devm_add_action_or_reset(dev, ltc2688_clk_disable, clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chan->toggle_chan)\n\t\treturn 0;\n\n\t \n\trate = clk_get_rate(clk);\n\tfor (f = 0; f < ARRAY_SIZE(chan->dither_frequency); f++)\n\t\tchan->dither_frequency[f] = DIV_ROUND_CLOSEST(rate, ltc2688_period[f]);\n\n\treturn 0;\n}\n\nstatic int ltc2688_span_lookup(const struct ltc2688_state *st, int min, int max)\n{\n\tu32 span;\n\n\tfor (span = 0; span < ARRAY_SIZE(ltc2688_span_helper); span++) {\n\t\tif (min == ltc2688_span_helper[span][0] &&\n\t\t    max == ltc2688_span_helper[span][1])\n\t\t\treturn span;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ltc2688_channel_config(struct ltc2688_state *st)\n{\n\tstruct device *dev = &st->spi->dev;\n\tstruct fwnode_handle *child;\n\tu32 reg, clk_input, val, tmp[2];\n\tint ret, span;\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tstruct ltc2688_chan *chan;\n\n\t\tret = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"Failed to get reg property\\n\");\n\t\t}\n\n\t\tif (reg >= LTC2688_DAC_CHANNELS) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t\t     \"reg bigger than: %d\\n\",\n\t\t\t\t\t     LTC2688_DAC_CHANNELS);\n\t\t}\n\n\t\tval = 0;\n\t\tchan = &st->channels[reg];\n\t\tif (fwnode_property_read_bool(child, \"adi,toggle-mode\")) {\n\t\t\tchan->toggle_chan = true;\n\t\t\t \n\t\t\tst->iio_chan[reg].ext_info = ltc2688_toggle_sym_ext_info;\n\t\t\t \n\t\t\t__clear_bit(IIO_CHAN_INFO_RAW,\n\t\t\t\t    &st->iio_chan[reg].info_mask_separate);\n\t\t}\n\n\t\tret = fwnode_property_read_u32_array(child, \"adi,output-range-microvolt\",\n\t\t\t\t\t\t     tmp, ARRAY_SIZE(tmp));\n\t\tif (!ret) {\n\t\t\tspan = ltc2688_span_lookup(st, (int)tmp[0] / 1000,\n\t\t\t\t\t\t   tmp[1] / 1000);\n\t\t\tif (span < 0) {\n\t\t\t\tfwnode_handle_put(child);\n\t\t\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t\t\t     \"output range not valid:[%d %d]\\n\",\n\t\t\t\t\t\t     tmp[0], tmp[1]);\n\t\t\t}\n\n\t\t\tval |= FIELD_PREP(LTC2688_CH_SPAN_MSK, span);\n\t\t}\n\n\t\tret = fwnode_property_read_u32(child, \"adi,toggle-dither-input\",\n\t\t\t\t\t       &clk_input);\n\t\tif (!ret) {\n\t\t\tif (clk_input >= LTC2688_CH_TGP_MAX) {\n\t\t\t\tfwnode_handle_put(child);\n\t\t\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t\t\t     \"toggle-dither-input inv value(%d)\\n\",\n\t\t\t\t\t\t     clk_input);\n\t\t\t}\n\n\t\t\tret = ltc2688_tgp_clk_setup(st, chan, child, clk_input);\n\t\t\tif (ret) {\n\t\t\t\tfwnode_handle_put(child);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\t\t\tval |= FIELD_PREP(LTC2688_CH_TD_SEL_MSK, clk_input + 1);\n\n\t\t\t \n\t\t\tif (!chan->toggle_chan) {\n\t\t\t\tval |= FIELD_PREP(LTC2688_CH_MODE_MSK, 1);\n\t\t\t\tst->iio_chan[reg].ext_info = ltc2688_dither_ext_info;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tst->iio_chan[reg].ext_info = ltc2688_toggle_ext_info;\n\t\t\t}\n\t\t}\n\n\t\tif (fwnode_property_read_bool(child, \"adi,overrange\")) {\n\t\t\tchan->overrange = true;\n\t\t\tval |= LTC2688_CH_OVERRANGE_MSK;\n\t\t}\n\n\t\tif (!val)\n\t\t\tcontinue;\n\n\t\tret = regmap_write(st->regmap, LTC2688_CMD_CH_SETTING(reg),\n\t\t\t\t   val);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t\t     \"failed to set chan settings\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ltc2688_setup(struct ltc2688_state *st, struct regulator *vref)\n{\n\tstruct device *dev = &st->spi->dev;\n\tstruct gpio_desc *gpio;\n\tint ret;\n\n\t \n\tgpio = devm_gpiod_get_optional(dev, \"clr\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(gpio), \"Failed to get reset gpio\");\n\tif (gpio) {\n\t\tusleep_range(1000, 1200);\n\t\t \n\t\tgpiod_set_value_cansleep(gpio, 0);\n\t} else {\n\t\tret = regmap_update_bits(st->regmap, LTC2688_CMD_CONFIG,\n\t\t\t\t\t LTC2688_CONFIG_RST,\n\t\t\t\t\t LTC2688_CONFIG_RST);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tusleep_range(10000, 12000);\n\n\t \n\tst->iio_chan = devm_kmemdup(dev, ltc2688_channels,\n\t\t\t\t    sizeof(ltc2688_channels), GFP_KERNEL);\n\tif (!st->iio_chan)\n\t\treturn -ENOMEM;\n\n\tret = ltc2688_channel_config(st);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!vref)\n\t\treturn 0;\n\n\treturn regmap_set_bits(st->regmap, LTC2688_CMD_CONFIG,\n\t\t\t       LTC2688_CONFIG_EXT_REF);\n}\n\nstatic void ltc2688_disable_regulator(void *regulator)\n{\n\tregulator_disable(regulator);\n}\n\nstatic bool ltc2688_reg_readable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LTC2688_CMD_CH_CODE(0) ... LTC2688_CMD_CH_GAIN(15):\n\t\treturn true;\n\tcase LTC2688_CMD_CONFIG ... LTC2688_CMD_THERMAL_STAT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool ltc2688_reg_writable(struct device *dev, unsigned int reg)\n{\n\t \n\tif (reg <= LTC2688_CMD_UPDATE_ALL && reg != LTC2688_CMD_THERMAL_STAT)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct regmap_bus ltc2688_regmap_bus = {\n\t.read = ltc2688_spi_read,\n\t.write = ltc2688_spi_write,\n\t.read_flag_mask = LTC2688_READ_OPERATION,\n\t.reg_format_endian_default = REGMAP_ENDIAN_BIG,\n\t.val_format_endian_default = REGMAP_ENDIAN_BIG,\n};\n\nstatic const struct regmap_config ltc2688_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.readable_reg = ltc2688_reg_readable,\n\t.writeable_reg = ltc2688_reg_writable,\n\t \n\t.max_register = LTC2688_CMD_UPDATE_ALL,\n};\n\nstatic const struct iio_info ltc2688_info = {\n\t.write_raw = ltc2688_write_raw,\n\t.read_raw = ltc2688_read_raw,\n\t.read_avail = ltc2688_read_avail,\n\t.debugfs_reg_access = ltc2688_reg_access,\n};\n\nstatic int ltc2688_probe(struct spi_device *spi)\n{\n\tstatic const char * const regulators[] = { \"vcc\", \"iovcc\" };\n\tstruct ltc2688_state *st;\n\tstruct iio_dev *indio_dev;\n\tstruct regulator *vref_reg;\n\tstruct device *dev = &spi->dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tst->spi = spi;\n\n\t \n\tst->tx_data[3] = LTC2688_CMD_NOOP;\n\tmutex_init(&st->lock);\n\n\tst->regmap = devm_regmap_init(dev, &ltc2688_regmap_bus, st,\n\t\t\t\t      &ltc2688_regmap_config);\n\tif (IS_ERR(st->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(st->regmap),\n\t\t\t\t     \"Failed to init regmap\");\n\n\tret = devm_regulator_bulk_get_enable(dev, ARRAY_SIZE(regulators),\n\t\t\t\t\t     regulators);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to enable regulators\\n\");\n\n\tvref_reg = devm_regulator_get_optional(dev, \"vref\");\n\tif (IS_ERR(vref_reg)) {\n\t\tif (PTR_ERR(vref_reg) != -ENODEV)\n\t\t\treturn dev_err_probe(dev, PTR_ERR(vref_reg),\n\t\t\t\t\t     \"Failed to get vref regulator\");\n\n\t\tvref_reg = NULL;\n\t\t \n\t\tst->vref = 4096;\n\t} else {\n\t\tret = regulator_enable(vref_reg);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"Failed to enable vref regulators\\n\");\n\n\t\tret = devm_add_action_or_reset(dev, ltc2688_disable_regulator,\n\t\t\t\t\t       vref_reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regulator_get_voltage(vref_reg);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(dev, ret, \"Failed to get vref\\n\");\n\n\t\tst->vref = ret / 1000;\n\t}\n\n\tret = ltc2688_setup(st, vref_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->name = \"ltc2688\";\n\tindio_dev->info = &ltc2688_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = st->iio_chan;\n\tindio_dev->num_channels = ARRAY_SIZE(ltc2688_channels);\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id ltc2688_of_id[] = {\n\t{ .compatible = \"adi,ltc2688\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ltc2688_of_id);\n\nstatic const struct spi_device_id ltc2688_id[] = {\n\t{ \"ltc2688\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ltc2688_id);\n\nstatic struct spi_driver ltc2688_driver = {\n\t.driver = {\n\t\t.name = \"ltc2688\",\n\t\t.of_match_table = ltc2688_of_id,\n\t},\n\t.probe = ltc2688_probe,\n\t.id_table = ltc2688_id,\n};\nmodule_spi_driver(ltc2688_driver);\n\nMODULE_AUTHOR(\"Nuno S\u00e1 <nuno.sa@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices LTC2688 DAC\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}