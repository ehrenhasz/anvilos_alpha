{
  "module_name": "mcp4922.c",
  "hash_id": "faa7d22e2f6351a5a7979ac74bf1a55e0d2c5a7bf7c023b80eae2582999fa4b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/mcp4922.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/spi/spi.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/regulator/consumer.h>\n#include <linux/bitops.h>\n\n#define MCP4922_NUM_CHANNELS\t2\n#define MCP4921_NUM_CHANNELS\t1\n\nenum mcp4922_supported_device_ids {\n\tID_MCP4902,\n\tID_MCP4912,\n\tID_MCP4921,\n\tID_MCP4922,\n};\n\nstruct mcp4922_state {\n\tstruct spi_device *spi;\n\tunsigned int value[MCP4922_NUM_CHANNELS];\n\tunsigned int vref_mv;\n\tstruct regulator *vref_reg;\n\tu8 mosi[2] __aligned(IIO_DMA_MINALIGN);\n};\n\n#define MCP4922_CHAN(chan, bits) {\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.channel = chan,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.scan_type = {\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\\\n\t\t.realbits = (bits),\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\\\n\t\t.shift = 12 - (bits),\t\t\t\\\n\t},\t\t\t\t\t\t\\\n}\n\nstatic int mcp4922_spi_write(struct mcp4922_state *state, u8 addr, u32 val)\n{\n\tstate->mosi[1] = val & 0xff;\n\tstate->mosi[0] = (addr == 0) ? 0x00 : 0x80;\n\tstate->mosi[0] |= 0x30 | ((val >> 8) & 0x0f);\n\n\treturn spi_write(state->spi, state->mosi, 2);\n}\n\nstatic int mcp4922_read_raw(struct iio_dev *indio_dev,\n\t\tstruct iio_chan_spec const *chan,\n\t\tint *val,\n\t\tint *val2,\n\t\tlong mask)\n{\n\tstruct mcp4922_state *state = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*val = state->value[chan->channel];\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = state->vref_mv;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mcp4922_write_raw(struct iio_dev *indio_dev,\n\t\tstruct iio_chan_spec const *chan,\n\t\tint val,\n\t\tint val2,\n\t\tlong mask)\n{\n\tstruct mcp4922_state *state = iio_priv(indio_dev);\n\tint ret;\n\n\tif (val2 != 0)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val < 0 || val > GENMASK(chan->scan_type.realbits - 1, 0))\n\t\t\treturn -EINVAL;\n\t\tval <<= chan->scan_type.shift;\n\n\t\tret = mcp4922_spi_write(state, chan->channel, val);\n\t\tif (!ret)\n\t\t\tstate->value[chan->channel] = val;\n\t\treturn ret;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_chan_spec mcp4922_channels[4][MCP4922_NUM_CHANNELS] = {\n\t[ID_MCP4902] = { MCP4922_CHAN(0, 8),\tMCP4922_CHAN(1, 8) },\n\t[ID_MCP4912] = { MCP4922_CHAN(0, 10),\tMCP4922_CHAN(1, 10) },\n\t[ID_MCP4921] = { MCP4922_CHAN(0, 12),\t{} },\n\t[ID_MCP4922] = { MCP4922_CHAN(0, 12),\tMCP4922_CHAN(1, 12) },\n};\n\nstatic const struct iio_info mcp4922_info = {\n\t.read_raw = &mcp4922_read_raw,\n\t.write_raw = &mcp4922_write_raw,\n};\n\nstatic int mcp4922_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct mcp4922_state *state;\n\tconst struct spi_device_id *id;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*state));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tstate = iio_priv(indio_dev);\n\tstate->spi = spi;\n\tstate->vref_reg = devm_regulator_get(&spi->dev, \"vref\");\n\tif (IS_ERR(state->vref_reg))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(state->vref_reg),\n\t\t\t\t     \"Vref regulator not specified\\n\");\n\n\tret = regulator_enable(state->vref_reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to enable vref regulator: %d\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_get_voltage(state->vref_reg);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"Failed to read vref regulator: %d\\n\",\n\t\t\t\tret);\n\t\tgoto error_disable_reg;\n\t}\n\tstate->vref_mv = ret / 1000;\n\n\tspi_set_drvdata(spi, indio_dev);\n\tid = spi_get_device_id(spi);\n\tindio_dev->info = &mcp4922_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = mcp4922_channels[id->driver_data];\n\tif (id->driver_data == ID_MCP4921)\n\t\tindio_dev->num_channels = MCP4921_NUM_CHANNELS;\n\telse\n\t\tindio_dev->num_channels = MCP4922_NUM_CHANNELS;\n\tindio_dev->name = id->name;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to register iio device: %d\\n\",\n\t\t\t\tret);\n\t\tgoto error_disable_reg;\n\t}\n\n\treturn 0;\n\nerror_disable_reg:\n\tregulator_disable(state->vref_reg);\n\n\treturn ret;\n}\n\nstatic void mcp4922_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct mcp4922_state *state;\n\n\tiio_device_unregister(indio_dev);\n\tstate = iio_priv(indio_dev);\n\tregulator_disable(state->vref_reg);\n}\n\nstatic const struct spi_device_id mcp4922_id[] = {\n\t{\"mcp4902\", ID_MCP4902},\n\t{\"mcp4912\", ID_MCP4912},\n\t{\"mcp4921\", ID_MCP4921},\n\t{\"mcp4922\", ID_MCP4922},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, mcp4922_id);\n\nstatic struct spi_driver mcp4922_driver = {\n\t.driver = {\n\t\t   .name = \"mcp4922\",\n\t\t   },\n\t.probe = mcp4922_probe,\n\t.remove = mcp4922_remove,\n\t.id_table = mcp4922_id,\n};\nmodule_spi_driver(mcp4922_driver);\n\nMODULE_AUTHOR(\"Michael Welling <mwelling@ieee.org>\");\nMODULE_DESCRIPTION(\"Microchip MCP4902, MCP4912, MCP4922 DAC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}