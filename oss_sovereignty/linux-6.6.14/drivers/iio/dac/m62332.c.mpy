{
  "module_name": "m62332.c",
  "hash_id": "769709f680bfadc72ae446a1b25ed3112f8de78ba0ee36ec18ab227545d5b11e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/m62332.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/driver.h>\n\n#include <linux/regulator/consumer.h>\n\n#define M62332_CHANNELS 2\n\nstruct m62332_data {\n\tstruct i2c_client\t*client;\n\tstruct regulator\t*vcc;\n\tstruct mutex\t\tmutex;\n\tu8\t\t\traw[M62332_CHANNELS];\n\tu8\t\t\tsave[M62332_CHANNELS];\n};\n\nstatic int m62332_set_value(struct iio_dev *indio_dev, u8 val, int channel)\n{\n\tstruct m62332_data *data = iio_priv(indio_dev);\n\tstruct i2c_client *client = data->client;\n\tu8 outbuf[2];\n\tint res;\n\n\tif (val == data->raw[channel])\n\t\treturn 0;\n\n\toutbuf[0] = channel;\n\toutbuf[1] = val;\n\n\tmutex_lock(&data->mutex);\n\n\tif (val) {\n\t\tres = regulator_enable(data->vcc);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\tres = i2c_master_send(client, outbuf, ARRAY_SIZE(outbuf));\n\tif (res >= 0 && res != ARRAY_SIZE(outbuf))\n\t\tres = -EIO;\n\tif (res < 0)\n\t\tgoto out;\n\n\tdata->raw[channel] = val;\n\n\tif (!val)\n\t\tregulator_disable(data->vcc);\n\n\tmutex_unlock(&data->mutex);\n\n\treturn 0;\n\nout:\n\tmutex_unlock(&data->mutex);\n\n\treturn res;\n}\n\nstatic int m62332_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long mask)\n{\n\tstruct m62332_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\tret = regulator_get_voltage(data->vcc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret / 1000;  \n\t\t*val2 = 8;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*val = data->raw[chan->channel];\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = 1;\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int m62332_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int val, int val2,\n\t\t\t    long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val < 0 || val > 255)\n\t\t\treturn -EINVAL;\n\n\t\treturn m62332_set_value(indio_dev, val, chan->channel);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int m62332_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct m62332_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tdata->save[0] = data->raw[0];\n\tdata->save[1] = data->raw[1];\n\n\tret = m62332_set_value(indio_dev, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn m62332_set_value(indio_dev, 0, 1);\n}\n\nstatic int m62332_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct m62332_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = m62332_set_value(indio_dev, data->save[0], 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn m62332_set_value(indio_dev, data->save[1], 1);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(m62332_pm_ops, m62332_suspend, m62332_resume);\n\nstatic const struct iio_info m62332_info = {\n\t.read_raw = m62332_read_raw,\n\t.write_raw = m62332_write_raw,\n};\n\n#define M62332_CHANNEL(chan) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\\\n\t.channel = (chan),\t\t\t\t\t\\\n\t.datasheet_name = \"CH\" #chan,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\t    BIT(IIO_CHAN_INFO_OFFSET),\t\\\n}\n\nstatic const struct iio_chan_spec m62332_channels[M62332_CHANNELS] = {\n\tM62332_CHANNEL(0),\n\tM62332_CHANNEL(1)\n};\n\nstatic int m62332_probe(struct i2c_client *client)\n{\n\tstruct m62332_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tmutex_init(&data->mutex);\n\n\tdata->vcc = devm_regulator_get(&client->dev, \"VCC\");\n\tif (IS_ERR(data->vcc))\n\t\treturn PTR_ERR(data->vcc);\n\n\tindio_dev->num_channels = ARRAY_SIZE(m62332_channels);\n\tindio_dev->channels = m62332_channels;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &m62332_info;\n\n\tret = iio_map_array_register(indio_dev, client->dev.platform_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tiio_map_array_unregister(indio_dev);\n\n\treturn ret;\n}\n\nstatic void m62332_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\n\tiio_device_unregister(indio_dev);\n\tiio_map_array_unregister(indio_dev);\n\tm62332_set_value(indio_dev, 0, 0);\n\tm62332_set_value(indio_dev, 0, 1);\n}\n\nstatic const struct i2c_device_id m62332_id[] = {\n\t{ \"m62332\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, m62332_id);\n\nstatic struct i2c_driver m62332_driver = {\n\t.driver = {\n\t\t.name\t= \"m62332\",\n\t\t.pm\t= pm_sleep_ptr(&m62332_pm_ops),\n\t},\n\t.probe\t\t= m62332_probe,\n\t.remove\t\t= m62332_remove,\n\t.id_table\t= m62332_id,\n};\nmodule_i2c_driver(m62332_driver);\n\nMODULE_AUTHOR(\"Dmitry Eremin-Solenikov\");\nMODULE_DESCRIPTION(\"M62332 8-bit DAC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}