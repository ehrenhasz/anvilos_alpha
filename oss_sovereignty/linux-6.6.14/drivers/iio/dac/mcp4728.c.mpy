{
  "module_name": "mcp4728.c",
  "hash_id": "1589804b3d4d556fa9bb14cb908e067a5d657b2fefda734995aa69bebfa1ff2d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/mcp4728.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n\n#define MCP4728_RESOLUTION\t  12\n#define MCP4728_N_CHANNELS\t  4\n\n#define MCP4728_CMD_MASK\t  GENMASK(7, 3)\n#define MCP4728_CHSEL_MASK\t  GENMASK(2, 1)\n#define MCP4728_UDAC_MASK\t  BIT(0)\n\n#define MCP4728_VREF_MASK\t  BIT(7)\n#define MCP4728_PDMODE_MASK\t  GENMASK(6, 5)\n#define MCP4728_GAIN_MASK\t  BIT(4)\n\n#define MCP4728_DAC_H_MASK\t  GENMASK(3, 0)\n#define MCP4728_DAC_L_MASK\t  GENMASK(7, 0)\n\n#define MCP4728_RDY_MASK\t  BIT(7)\n\n#define MCP4728_MW_CMD\t\t  0x08  \n#define MCP4728_SW_CMD\t\t  0x0A  \n\n#define MCP4728_READ_RESPONSE_LEN (MCP4728_N_CHANNELS * 3 * 2)\n#define MCP4728_WRITE_EEPROM_LEN  (1 + MCP4728_N_CHANNELS * 2)\n\nenum vref_mode {\n\tMCP4728_VREF_EXTERNAL_VDD    = 0,\n\tMCP4728_VREF_INTERNAL_2048mV = 1,\n};\n\nenum gain_mode {\n\tMCP4728_GAIN_X1 = 0,\n\tMCP4728_GAIN_X2 = 1,\n};\n\nenum iio_powerdown_mode {\n\tMCP4728_IIO_1K,\n\tMCP4728_IIO_100K,\n\tMCP4728_IIO_500K,\n};\n\nstruct mcp4728_channel_data {\n\tenum vref_mode ref_mode;\n\tenum iio_powerdown_mode pd_mode;\n\tenum gain_mode g_mode;\n\tu16 dac_value;\n};\n\n \nenum mcp4728_scale {\n\tMCP4728_SCALE_VDD,\n\tMCP4728_SCALE_VINT_NO_GAIN,\n\tMCP4728_SCALE_VINT_GAIN_X2,\n\tMCP4728_N_SCALES\n};\n\nstruct mcp4728_data {\n\tstruct i2c_client *client;\n\tstruct regulator *vdd_reg;\n\tbool powerdown;\n\tint scales_avail[MCP4728_N_SCALES * 2];\n\tstruct mcp4728_channel_data chdata[MCP4728_N_CHANNELS];\n};\n\n#define MCP4728_CHAN(chan) {\t\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel = chan,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)\t|\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\t\t\t\\\n\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.ext_info = mcp4728_ext_info,\t\t\t\t\t\\\n}\n\nstatic int mcp4728_suspend(struct device *dev);\nstatic int mcp4728_resume(struct device *dev);\n\nstatic ssize_t mcp4728_store_eeprom(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct mcp4728_data *data = iio_priv(indio_dev);\n\tu8 outbuf[MCP4728_WRITE_EEPROM_LEN];\n\tint tries = 20;\n\tu8 inbuf[3];\n\tbool state;\n\tint ret;\n\tunsigned int i;\n\n\tret = kstrtobool(buf, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!state)\n\t\treturn 0;\n\n\toutbuf[0] = FIELD_PREP(MCP4728_CMD_MASK, MCP4728_SW_CMD);\n\n\tfor (i = 0; i < MCP4728_N_CHANNELS; i++) {\n\t\tstruct mcp4728_channel_data *ch = &data->chdata[i];\n\t\tint offset\t\t\t= 1 + i * 2;\n\n\t\toutbuf[offset] = FIELD_PREP(MCP4728_VREF_MASK, ch->ref_mode);\n\n\t\tif (data->powerdown) {\n\t\t\tu8 mcp4728_pd_mode = ch->pd_mode + 1;\n\n\t\t\toutbuf[offset] |= FIELD_PREP(MCP4728_PDMODE_MASK,\n\t\t\t\t\t\t     mcp4728_pd_mode);\n\t\t}\n\n\t\toutbuf[offset] |= FIELD_PREP(MCP4728_GAIN_MASK, ch->g_mode);\n\t\toutbuf[offset] |=\n\t\t\tFIELD_PREP(MCP4728_DAC_H_MASK, ch->dac_value >> 8);\n\t\toutbuf[offset + 1] =\n\t\t\tFIELD_PREP(MCP4728_DAC_L_MASK, ch->dac_value);\n\t}\n\n\tret = i2c_master_send(data->client, outbuf, MCP4728_WRITE_EEPROM_LEN);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != MCP4728_WRITE_EEPROM_LEN)\n\t\treturn -EIO;\n\n\t \n\twhile (tries--) {\n\t\tmsleep(20);\n\t\tret = i2c_master_recv(data->client, inbuf, 3);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret != 3)\n\t\t\treturn -EIO;\n\n\t\tif (FIELD_GET(MCP4728_RDY_MASK, inbuf[0]))\n\t\t\tbreak;\n\t}\n\n\tif (tries < 0) {\n\t\tdev_err(&data->client->dev, \"%s failed, incomplete\\n\",\n\t\t\t__func__);\n\t\treturn -EIO;\n\t}\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(store_eeprom, 0200, NULL, mcp4728_store_eeprom, 0);\n\nstatic struct attribute *mcp4728_attributes[] = {\n\t&iio_dev_attr_store_eeprom.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mcp4728_attribute_group = {\n\t.attrs = mcp4728_attributes,\n};\n\nstatic int mcp4728_program_channel_cfg(int channel, struct iio_dev *indio_dev)\n{\n\tstruct mcp4728_data *data\t= iio_priv(indio_dev);\n\tstruct mcp4728_channel_data *ch = &data->chdata[channel];\n\tu8 outbuf[3];\n\tint ret;\n\n\toutbuf[0] = FIELD_PREP(MCP4728_CMD_MASK, MCP4728_MW_CMD);\n\toutbuf[0] |= FIELD_PREP(MCP4728_CHSEL_MASK, channel);\n\toutbuf[0] |= FIELD_PREP(MCP4728_UDAC_MASK, 0);\n\n\toutbuf[1] = FIELD_PREP(MCP4728_VREF_MASK, ch->ref_mode);\n\n\tif (data->powerdown)\n\t\toutbuf[1] |= FIELD_PREP(MCP4728_PDMODE_MASK, ch->pd_mode + 1);\n\n\toutbuf[1] |= FIELD_PREP(MCP4728_GAIN_MASK, ch->g_mode);\n\toutbuf[1] |= FIELD_PREP(MCP4728_DAC_H_MASK, ch->dac_value >> 8);\n\toutbuf[2] = FIELD_PREP(MCP4728_DAC_L_MASK, ch->dac_value);\n\n\tret = i2c_master_send(data->client, outbuf, 3);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != 3)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic const char *const mcp4728_powerdown_modes[] = { \"1kohm_to_gnd\",\n\t\t\t\t\t\t       \"100kohm_to_gnd\",\n\t\t\t\t\t\t       \"500kohm_to_gnd\" };\n\nstatic int mcp4728_get_powerdown_mode(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan)\n{\n\tstruct mcp4728_data *data = iio_priv(indio_dev);\n\n\treturn data->chdata[chan->channel].pd_mode;\n}\n\nstatic int mcp4728_set_powerdown_mode(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      unsigned int mode)\n{\n\tstruct mcp4728_data *data = iio_priv(indio_dev);\n\n\tdata->chdata[chan->channel].pd_mode = mode;\n\n\treturn 0;\n}\n\nstatic ssize_t mcp4728_read_powerdown(struct iio_dev *indio_dev,\n\t\t\t\t      uintptr_t private,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      char *buf)\n{\n\tstruct mcp4728_data *data = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", data->powerdown);\n}\n\nstatic ssize_t mcp4728_write_powerdown(struct iio_dev *indio_dev,\n\t\t\t\t       uintptr_t private,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       const char *buf, size_t len)\n{\n\tstruct mcp4728_data *data = iio_priv(indio_dev);\n\tbool state;\n\tint ret;\n\n\tret = kstrtobool(buf, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (state)\n\t\tret = mcp4728_suspend(&data->client->dev);\n\telse\n\t\tret = mcp4728_resume(&data->client->dev);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic const struct iio_enum mcp4728_powerdown_mode_enum = {\n\t.items\t   = mcp4728_powerdown_modes,\n\t.num_items = ARRAY_SIZE(mcp4728_powerdown_modes),\n\t.get\t   = mcp4728_get_powerdown_mode,\n\t.set\t   = mcp4728_set_powerdown_mode,\n};\n\nstatic const struct iio_chan_spec_ext_info mcp4728_ext_info[] = {\n\t{\n\t\t.name\t= \"powerdown\",\n\t\t.read\t= mcp4728_read_powerdown,\n\t\t.write\t= mcp4728_write_powerdown,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\tIIO_ENUM(\"powerdown_mode\", IIO_SEPARATE, &mcp4728_powerdown_mode_enum),\n\tIIO_ENUM_AVAILABLE(\"powerdown_mode\", IIO_SHARED_BY_TYPE,\n\t\t\t   &mcp4728_powerdown_mode_enum),\n\t{},\n};\n\nstatic const struct iio_chan_spec mcp4728_channels[MCP4728_N_CHANNELS] = {\n\tMCP4728_CHAN(0),\n\tMCP4728_CHAN(1),\n\tMCP4728_CHAN(2),\n\tMCP4728_CHAN(3),\n};\n\nstatic void mcp4728_get_scale_avail(enum mcp4728_scale scale,\n\t\t\t\t    struct mcp4728_data *data, int *val,\n\t\t\t\t    int *val2)\n{\n\t*val  = data->scales_avail[scale * 2];\n\t*val2 = data->scales_avail[scale * 2 + 1];\n}\n\nstatic void mcp4728_get_scale(int channel, struct mcp4728_data *data, int *val,\n\t\t\t      int *val2)\n{\n\tint ref_mode = data->chdata[channel].ref_mode;\n\tint g_mode   = data->chdata[channel].g_mode;\n\n\tif (ref_mode == MCP4728_VREF_EXTERNAL_VDD) {\n\t\tmcp4728_get_scale_avail(MCP4728_SCALE_VDD, data, val, val2);\n\t} else {\n\t\tif (g_mode == MCP4728_GAIN_X1) {\n\t\t\tmcp4728_get_scale_avail(MCP4728_SCALE_VINT_NO_GAIN,\n\t\t\t\t\t\tdata, val, val2);\n\t\t} else {\n\t\t\tmcp4728_get_scale_avail(MCP4728_SCALE_VINT_GAIN_X2,\n\t\t\t\t\t\tdata, val, val2);\n\t\t}\n\t}\n}\n\nstatic int mcp4728_find_matching_scale(struct mcp4728_data *data, int val,\n\t\t\t\t       int val2)\n{\n\tfor (int i = 0; i < MCP4728_N_SCALES; i++) {\n\t\tif (data->scales_avail[i * 2] == val &&\n\t\t    data->scales_avail[i * 2 + 1] == val2)\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int mcp4728_set_scale(int channel, struct mcp4728_data *data, int val,\n\t\t\t     int val2)\n{\n\tint scale = mcp4728_find_matching_scale(data, val, val2);\n\n\tif (scale < 0)\n\t\treturn scale;\n\n\tswitch (scale) {\n\tcase MCP4728_SCALE_VDD:\n\t\tdata->chdata[channel].ref_mode = MCP4728_VREF_EXTERNAL_VDD;\n\t\treturn 0;\n\tcase MCP4728_SCALE_VINT_NO_GAIN:\n\t\tdata->chdata[channel].ref_mode = MCP4728_VREF_INTERNAL_2048mV;\n\t\tdata->chdata[channel].g_mode   = MCP4728_GAIN_X1;\n\t\treturn 0;\n\tcase MCP4728_SCALE_VINT_GAIN_X2:\n\t\tdata->chdata[channel].ref_mode = MCP4728_VREF_INTERNAL_2048mV;\n\t\tdata->chdata[channel].g_mode   = MCP4728_GAIN_X2;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mcp4728_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct mcp4728_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*val = data->chdata[chan->channel].dac_value;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tmcp4728_get_scale(chan->channel, data, val, val2);\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int mcp4728_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int val,\n\t\t\t     int val2, long mask)\n{\n\tstruct mcp4728_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val < 0 || val > GENMASK(MCP4728_RESOLUTION - 1, 0))\n\t\t\treturn -EINVAL;\n\t\tdata->chdata[chan->channel].dac_value = val;\n\t\treturn mcp4728_program_channel_cfg(chan->channel, indio_dev);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = mcp4728_set_scale(chan->channel, data, val, val2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn mcp4728_program_channel_cfg(chan->channel, indio_dev);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void mcp4728_init_scale_avail(enum mcp4728_scale scale, int vref_mv,\n\t\t\t\t     struct mcp4728_data *data)\n{\n\ts64 tmp;\n\tint value_micro;\n\tint value_int;\n\n\ttmp\t  = (s64)vref_mv * 1000000LL >> MCP4728_RESOLUTION;\n\tvalue_int = div_s64_rem(tmp, 1000000LL, &value_micro);\n\n\tdata->scales_avail[scale * 2]\t  = value_int;\n\tdata->scales_avail[scale * 2 + 1] = value_micro;\n}\n\nstatic int mcp4728_init_scales_avail(struct mcp4728_data *data)\n{\n\tint ret;\n\n\tret = regulator_get_voltage(data->vdd_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmcp4728_init_scale_avail(MCP4728_SCALE_VDD, ret / 1000, data);\n\tmcp4728_init_scale_avail(MCP4728_SCALE_VINT_NO_GAIN, 2048, data);\n\tmcp4728_init_scale_avail(MCP4728_SCALE_VINT_GAIN_X2, 4096, data);\n\n\treturn 0;\n}\n\nstatic int mcp4728_read_avail(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      const int **vals, int *type, int *length,\n\t\t\t      long info)\n{\n\tstruct mcp4728_data *data = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\t*vals\t= data->scales_avail;\n\t\t\t*length = MCP4728_N_SCALES * 2;\n\t\t\treturn IIO_AVAIL_LIST;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info mcp4728_info = {\n\t.read_raw   = mcp4728_read_raw,\n\t.write_raw  = mcp4728_write_raw,\n\t.read_avail = &mcp4728_read_avail,\n\t.attrs\t    = &mcp4728_attribute_group,\n};\n\nstatic int mcp4728_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct mcp4728_data *data = iio_priv(indio_dev);\n\tunsigned int i;\n\n\tdata->powerdown = true;\n\n\tfor (i = 0; i < MCP4728_N_CHANNELS; i++) {\n\t\tint err = mcp4728_program_channel_cfg(i, indio_dev);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int mcp4728_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct mcp4728_data *data = iio_priv(indio_dev);\n\tint err\t\t\t  = 0;\n\tunsigned int i;\n\n\tdata->powerdown = false;\n\n\tfor (i = 0; i < MCP4728_N_CHANNELS; i++) {\n\t\tint ret = mcp4728_program_channel_cfg(i, indio_dev);\n\n\t\tif (ret)\n\t\t\terr = ret;\n\t}\n\treturn err;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mcp4728_pm_ops, mcp4728_suspend,\n\t\t\t\tmcp4728_resume);\n\nstatic int mcp4728_init_channels_data(struct mcp4728_data *data)\n{\n\tu8 inbuf[MCP4728_READ_RESPONSE_LEN];\n\tint ret;\n\tunsigned int i;\n\n\tret = i2c_master_recv(data->client, inbuf, MCP4728_READ_RESPONSE_LEN);\n\tif (ret < 0) {\n\t\treturn dev_err_probe(&data->client->dev, ret,\n\t\t\t\t     \"failed to read mcp4728 conf.\\n\");\n\t} else if (ret != MCP4728_READ_RESPONSE_LEN) {\n\t\treturn dev_err_probe(&data->client->dev, -EIO,\n\t\t\t\"failed to read mcp4728 conf. Wrong Response Len ret=%d\\n\",\n\t\t\tret);\n\t}\n\n\tfor (i = 0; i < MCP4728_N_CHANNELS; i++) {\n\t\tstruct mcp4728_channel_data *ch = &data->chdata[i];\n\t\tu8 r2\t\t\t\t= inbuf[i * 6 + 1];\n\t\tu8 r3\t\t\t\t= inbuf[i * 6 + 2];\n\n\t\tch->dac_value = FIELD_GET(MCP4728_DAC_H_MASK, r2) << 8 |\n\t\t\t\tFIELD_GET(MCP4728_DAC_L_MASK, r3);\n\t\tch->ref_mode = FIELD_GET(MCP4728_VREF_MASK, r2);\n\t\tch->pd_mode  = FIELD_GET(MCP4728_PDMODE_MASK, r2);\n\t\tch->g_mode   = FIELD_GET(MCP4728_GAIN_MASK, r2);\n\t}\n\n\treturn 0;\n}\n\nstatic void mcp4728_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int mcp4728_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct mcp4728_data *data;\n\tstruct iio_dev *indio_dev;\n\tint err;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tdata->vdd_reg = devm_regulator_get(&client->dev, \"vdd\");\n\tif (IS_ERR(data->vdd_reg))\n\t\treturn PTR_ERR(data->vdd_reg);\n\n\terr = regulator_enable(data->vdd_reg);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_add_action_or_reset(&client->dev, mcp4728_reg_disable,\n\t\t\t\t       data->vdd_reg);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mcp4728_init_channels_data(data);\n\tif (err) {\n\t\treturn dev_err_probe(&client->dev, err,\n\t\t\t\"failed to read mcp4728 current configuration\\n\");\n\t}\n\n\terr = mcp4728_init_scales_avail(data);\n\tif (err) {\n\t\treturn dev_err_probe(&client->dev, err,\n\t\t\t\t     \"failed to init scales\\n\");\n\t}\n\n\tindio_dev->name\t\t= id->name;\n\tindio_dev->info\t\t= &mcp4728_info;\n\tindio_dev->channels\t= mcp4728_channels;\n\tindio_dev->num_channels = MCP4728_N_CHANNELS;\n\tindio_dev->modes\t= INDIO_DIRECT_MODE;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id mcp4728_id[] = {\n\t{ \"mcp4728\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, mcp4728_id);\n\nstatic const struct of_device_id mcp4728_of_match[] = {\n\t{ .compatible = \"microchip,mcp4728\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mcp4728_of_match);\n\nstatic struct i2c_driver mcp4728_driver = {\n\t.driver = {\n\t\t.name = \"mcp4728\",\n\t\t.of_match_table = mcp4728_of_match,\n\t\t.pm = pm_sleep_ptr(&mcp4728_pm_ops),\n\t},\n\t.probe = mcp4728_probe,\n\t.id_table = mcp4728_id,\n};\nmodule_i2c_driver(mcp4728_driver);\n\nMODULE_AUTHOR(\"Andrea Collamati <andrea.collamati@gmail.com>\");\nMODULE_DESCRIPTION(\"MCP4728 12-bit DAC\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}