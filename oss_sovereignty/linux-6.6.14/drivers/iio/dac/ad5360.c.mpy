{
  "module_name": "ad5360.c",
  "hash_id": "d13d38b126b23e4e59521e525dd1f0298ee15100ce9cbb5095429c9cd1c52ed6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad5360.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define AD5360_CMD(x)\t\t\t\t((x) << 22)\n#define AD5360_ADDR(x)\t\t\t\t((x) << 16)\n\n#define AD5360_READBACK_TYPE(x)\t\t\t((x) << 13)\n#define AD5360_READBACK_ADDR(x)\t\t\t((x) << 7)\n\n#define AD5360_CHAN_ADDR(chan)\t\t\t((chan) + 0x8)\n\n#define AD5360_CMD_WRITE_DATA\t\t\t0x3\n#define AD5360_CMD_WRITE_OFFSET\t\t\t0x2\n#define AD5360_CMD_WRITE_GAIN\t\t\t0x1\n#define AD5360_CMD_SPECIAL_FUNCTION\t\t0x0\n\n \n#define AD5360_REG_SF_NOP\t\t\t0x0\n#define AD5360_REG_SF_CTRL\t\t\t0x1\n#define AD5360_REG_SF_OFS(x)\t\t\t(0x2 + (x))\n#define AD5360_REG_SF_READBACK\t\t\t0x5\n\n#define AD5360_SF_CTRL_PWR_DOWN\t\t\tBIT(0)\n\n#define AD5360_READBACK_X1A\t\t\t0x0\n#define AD5360_READBACK_X1B\t\t\t0x1\n#define AD5360_READBACK_OFFSET\t\t\t0x2\n#define AD5360_READBACK_GAIN\t\t\t0x3\n#define AD5360_READBACK_SF\t\t\t0x4\n\n\n \n\nstruct ad5360_chip_info {\n\tstruct iio_chan_spec\tchannel_template;\n\tunsigned int\t\tnum_channels;\n\tunsigned int\t\tchannels_per_group;\n\tunsigned int\t\tnum_vrefs;\n};\n\n \n\nstruct ad5360_state {\n\tstruct spi_device\t\t*spi;\n\tconst struct ad5360_chip_info\t*chip_info;\n\tstruct regulator_bulk_data\tvref_reg[3];\n\tunsigned int\t\t\tctrl;\n\tstruct mutex\t\t\tlock;\n\n\t \n\tunion {\n\t\t__be32 d32;\n\t\tu8 d8[4];\n\t} data[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nenum ad5360_type {\n\tID_AD5360,\n\tID_AD5361,\n\tID_AD5362,\n\tID_AD5363,\n\tID_AD5370,\n\tID_AD5371,\n\tID_AD5372,\n\tID_AD5373,\n};\n\n#define AD5360_CHANNEL(bits) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_SCALE) |\t\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_OFFSET) |\t\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) |\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = (bits),\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.shift = 16 - (bits),\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\nstatic const struct ad5360_chip_info ad5360_chip_info_tbl[] = {\n\t[ID_AD5360] = {\n\t\t.channel_template = AD5360_CHANNEL(16),\n\t\t.num_channels = 16,\n\t\t.channels_per_group = 8,\n\t\t.num_vrefs = 2,\n\t},\n\t[ID_AD5361] = {\n\t\t.channel_template = AD5360_CHANNEL(14),\n\t\t.num_channels = 16,\n\t\t.channels_per_group = 8,\n\t\t.num_vrefs = 2,\n\t},\n\t[ID_AD5362] = {\n\t\t.channel_template = AD5360_CHANNEL(16),\n\t\t.num_channels = 8,\n\t\t.channels_per_group = 4,\n\t\t.num_vrefs = 2,\n\t},\n\t[ID_AD5363] = {\n\t\t.channel_template = AD5360_CHANNEL(14),\n\t\t.num_channels = 8,\n\t\t.channels_per_group = 4,\n\t\t.num_vrefs = 2,\n\t},\n\t[ID_AD5370] = {\n\t\t.channel_template = AD5360_CHANNEL(16),\n\t\t.num_channels = 40,\n\t\t.channels_per_group = 8,\n\t\t.num_vrefs = 2,\n\t},\n\t[ID_AD5371] = {\n\t\t.channel_template = AD5360_CHANNEL(14),\n\t\t.num_channels = 40,\n\t\t.channels_per_group = 8,\n\t\t.num_vrefs = 3,\n\t},\n\t[ID_AD5372] = {\n\t\t.channel_template = AD5360_CHANNEL(16),\n\t\t.num_channels = 32,\n\t\t.channels_per_group = 8,\n\t\t.num_vrefs = 2,\n\t},\n\t[ID_AD5373] = {\n\t\t.channel_template = AD5360_CHANNEL(14),\n\t\t.num_channels = 32,\n\t\t.channels_per_group = 8,\n\t\t.num_vrefs = 2,\n\t},\n};\n\nstatic unsigned int ad5360_get_channel_vref_index(struct ad5360_state *st,\n\tunsigned int channel)\n{\n\tunsigned int i;\n\n\t \n\ti = channel / st->chip_info->channels_per_group;\n\tif (i >= st->chip_info->num_vrefs)\n\t\ti = st->chip_info->num_vrefs - 1;\n\n\treturn i;\n}\n\nstatic int ad5360_get_channel_vref(struct ad5360_state *st,\n\tunsigned int channel)\n{\n\tunsigned int i = ad5360_get_channel_vref_index(st, channel);\n\n\treturn regulator_get_voltage(st->vref_reg[i].consumer);\n}\n\n\nstatic int ad5360_write_unlocked(struct iio_dev *indio_dev,\n\tunsigned int cmd, unsigned int addr, unsigned int val,\n\tunsigned int shift)\n{\n\tstruct ad5360_state *st = iio_priv(indio_dev);\n\n\tval <<= shift;\n\tval |= AD5360_CMD(cmd) | AD5360_ADDR(addr);\n\tst->data[0].d32 = cpu_to_be32(val);\n\n\treturn spi_write(st->spi, &st->data[0].d8[1], 3);\n}\n\nstatic int ad5360_write(struct iio_dev *indio_dev, unsigned int cmd,\n\tunsigned int addr, unsigned int val, unsigned int shift)\n{\n\tint ret;\n\tstruct ad5360_state *st = iio_priv(indio_dev);\n\n\tmutex_lock(&st->lock);\n\tret = ad5360_write_unlocked(indio_dev, cmd, addr, val, shift);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad5360_read(struct iio_dev *indio_dev, unsigned int type,\n\tunsigned int addr)\n{\n\tstruct ad5360_state *st = iio_priv(indio_dev);\n\tint ret;\n\tstruct spi_transfer t[] = {\n\t\t{\n\t\t\t.tx_buf = &st->data[0].d8[1],\n\t\t\t.len = 3,\n\t\t\t.cs_change = 1,\n\t\t}, {\n\t\t\t.rx_buf = &st->data[1].d8[1],\n\t\t\t.len = 3,\n\t\t},\n\t};\n\n\tmutex_lock(&st->lock);\n\n\tst->data[0].d32 = cpu_to_be32(AD5360_CMD(AD5360_CMD_SPECIAL_FUNCTION) |\n\t\tAD5360_ADDR(AD5360_REG_SF_READBACK) |\n\t\tAD5360_READBACK_TYPE(type) |\n\t\tAD5360_READBACK_ADDR(addr));\n\n\tret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\n\tif (ret >= 0)\n\t\tret = be32_to_cpu(st->data[1].d32) & 0xffff;\n\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic ssize_t ad5360_read_dac_powerdown(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad5360_state *st = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", (bool)(st->ctrl & AD5360_SF_CTRL_PWR_DOWN));\n}\n\nstatic int ad5360_update_ctrl(struct iio_dev *indio_dev, unsigned int set,\n\tunsigned int clr)\n{\n\tstruct ad5360_state *st = iio_priv(indio_dev);\n\tunsigned int ret;\n\n\tmutex_lock(&st->lock);\n\n\tst->ctrl |= set;\n\tst->ctrl &= ~clr;\n\n\tret = ad5360_write_unlocked(indio_dev, AD5360_CMD_SPECIAL_FUNCTION,\n\t\t\tAD5360_REG_SF_CTRL, st->ctrl, 0);\n\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic ssize_t ad5360_write_dac_powerdown(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tbool pwr_down;\n\tint ret;\n\n\tret = kstrtobool(buf, &pwr_down);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pwr_down)\n\t\tret = ad5360_update_ctrl(indio_dev, AD5360_SF_CTRL_PWR_DOWN, 0);\n\telse\n\t\tret = ad5360_update_ctrl(indio_dev, 0, AD5360_SF_CTRL_PWR_DOWN);\n\n\treturn ret ? ret : len;\n}\n\nstatic IIO_DEVICE_ATTR(out_voltage_powerdown,\n\t\t\tS_IRUGO | S_IWUSR,\n\t\t\tad5360_read_dac_powerdown,\n\t\t\tad5360_write_dac_powerdown, 0);\n\nstatic struct attribute *ad5360_attributes[] = {\n\t&iio_dev_attr_out_voltage_powerdown.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ad5360_attribute_group = {\n\t.attrs = ad5360_attributes,\n};\n\nstatic int ad5360_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val,\n\t\t\t       int val2,\n\t\t\t       long mask)\n{\n\tstruct ad5360_state *st = iio_priv(indio_dev);\n\tint max_val = (1 << chan->scan_type.realbits);\n\tunsigned int ofs_index;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val >= max_val || val < 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn ad5360_write(indio_dev, AD5360_CMD_WRITE_DATA,\n\t\t\t\t chan->address, val, chan->scan_type.shift);\n\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif (val >= max_val || val < 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn ad5360_write(indio_dev, AD5360_CMD_WRITE_OFFSET,\n\t\t\t\t chan->address, val, chan->scan_type.shift);\n\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (val >= max_val || val < 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn ad5360_write(indio_dev, AD5360_CMD_WRITE_GAIN,\n\t\t\t\t chan->address, val, chan->scan_type.shift);\n\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (val <= -max_val || val > 0)\n\t\t\treturn -EINVAL;\n\n\t\tval = -val;\n\n\t\t \n\t\tval >>= (chan->scan_type.realbits - 14);\n\n\t\t \n\t\tofs_index = ad5360_get_channel_vref_index(st, chan->channel);\n\t\treturn ad5360_write(indio_dev, AD5360_CMD_SPECIAL_FUNCTION,\n\t\t\t\t AD5360_REG_SF_OFS(ofs_index), val, 0);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ad5360_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tstruct ad5360_state *st = iio_priv(indio_dev);\n\tunsigned int ofs_index;\n\tint scale_uv;\n\tint ret;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = ad5360_read(indio_dev, AD5360_READBACK_X1A,\n\t\t\tchan->address);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret >> chan->scan_type.shift;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tscale_uv = ad5360_get_channel_vref(st, chan->channel);\n\t\tif (scale_uv < 0)\n\t\t\treturn scale_uv;\n\n\t\t \n\t\t*val = scale_uv * 4 / 1000;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = ad5360_read(indio_dev, AD5360_READBACK_OFFSET,\n\t\t\tchan->address);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tret = ad5360_read(indio_dev, AD5360_READBACK_GAIN,\n\t\t\tchan->address);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tofs_index = ad5360_get_channel_vref_index(st, chan->channel);\n\t\tret = ad5360_read(indio_dev, AD5360_READBACK_SF,\n\t\t\tAD5360_REG_SF_OFS(ofs_index));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret <<= (chan->scan_type.realbits - 14);\n\t\t*val = -ret;\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info ad5360_info = {\n\t.read_raw = ad5360_read_raw,\n\t.write_raw = ad5360_write_raw,\n\t.attrs = &ad5360_attribute_group,\n};\n\nstatic const char * const ad5360_vref_name[] = {\n\t \"vref0\", \"vref1\", \"vref2\"\n};\n\nstatic int ad5360_alloc_channels(struct iio_dev *indio_dev)\n{\n\tstruct ad5360_state *st = iio_priv(indio_dev);\n\tstruct iio_chan_spec *channels;\n\tunsigned int i;\n\n\tchannels = kcalloc(st->chip_info->num_channels,\n\t\t\t   sizeof(struct iio_chan_spec), GFP_KERNEL);\n\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < st->chip_info->num_channels; ++i) {\n\t\tchannels[i] = st->chip_info->channel_template;\n\t\tchannels[i].channel = i;\n\t\tchannels[i].address = AD5360_CHAN_ADDR(i);\n\t}\n\n\tindio_dev->channels = channels;\n\n\treturn 0;\n}\n\nstatic int ad5360_probe(struct spi_device *spi)\n{\n\tenum ad5360_type type = spi_get_device_id(spi)->driver_data;\n\tstruct iio_dev *indio_dev;\n\tstruct ad5360_state *st;\n\tunsigned int i;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL) {\n\t\tdev_err(&spi->dev, \"Failed to allocate iio device\\n\");\n\t\treturn  -ENOMEM;\n\t}\n\n\tst = iio_priv(indio_dev);\n\tspi_set_drvdata(spi, indio_dev);\n\n\tst->chip_info = &ad5360_chip_info_tbl[type];\n\tst->spi = spi;\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->info = &ad5360_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->num_channels = st->chip_info->num_channels;\n\n\tmutex_init(&st->lock);\n\n\tret = ad5360_alloc_channels(indio_dev);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to allocate channel spec: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < st->chip_info->num_vrefs; ++i)\n\t\tst->vref_reg[i].supply = ad5360_vref_name[i];\n\n\tret = devm_regulator_bulk_get(&st->spi->dev, st->chip_info->num_vrefs,\n\t\tst->vref_reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to request vref regulators: %d\\n\", ret);\n\t\tgoto error_free_channels;\n\t}\n\n\tret = regulator_bulk_enable(st->chip_info->num_vrefs, st->vref_reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to enable vref regulators: %d\\n\", ret);\n\t\tgoto error_free_channels;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to register iio device: %d\\n\", ret);\n\t\tgoto error_disable_reg;\n\t}\n\n\treturn 0;\n\nerror_disable_reg:\n\tregulator_bulk_disable(st->chip_info->num_vrefs, st->vref_reg);\nerror_free_channels:\n\tkfree(indio_dev->channels);\n\n\treturn ret;\n}\n\nstatic void ad5360_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct ad5360_state *st = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tkfree(indio_dev->channels);\n\n\tregulator_bulk_disable(st->chip_info->num_vrefs, st->vref_reg);\n}\n\nstatic const struct spi_device_id ad5360_ids[] = {\n\t{ \"ad5360\", ID_AD5360 },\n\t{ \"ad5361\", ID_AD5361 },\n\t{ \"ad5362\", ID_AD5362 },\n\t{ \"ad5363\", ID_AD5363 },\n\t{ \"ad5370\", ID_AD5370 },\n\t{ \"ad5371\", ID_AD5371 },\n\t{ \"ad5372\", ID_AD5372 },\n\t{ \"ad5373\", ID_AD5373 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad5360_ids);\n\nstatic struct spi_driver ad5360_driver = {\n\t.driver = {\n\t\t   .name = \"ad5360\",\n\t},\n\t.probe = ad5360_probe,\n\t.remove = ad5360_remove,\n\t.id_table = ad5360_ids,\n};\nmodule_spi_driver(ad5360_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5360/61/62/63/70/71/72/73 DAC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}