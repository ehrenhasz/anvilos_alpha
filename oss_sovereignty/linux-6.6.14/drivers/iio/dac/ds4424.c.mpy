{
  "module_name": "ds4424.c",
  "hash_id": "e838b215bdfa845704db0d6d4d7cec27c3586f0504cb0976cb5c11c9a360a0d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ds4424.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/driver.h>\n#include <linux/iio/machine.h>\n#include <linux/iio/consumer.h>\n\n#define DS4422_MAX_DAC_CHANNELS\t\t2\n#define DS4424_MAX_DAC_CHANNELS\t\t4\n\n#define DS4424_DAC_ADDR(chan)   ((chan) + 0xf8)\n#define DS4424_SOURCE_I\t\t1\n#define DS4424_SINK_I\t\t0\n\n#define DS4424_CHANNEL(chan) { \\\n\t.type = IIO_CURRENT, \\\n\t.indexed = 1, \\\n\t.output = 1, \\\n\t.channel = chan, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n}\n\n \nunion ds4424_raw_data {\n\tstruct {\n\t\tu8 dx:7;\n\t\tu8 source_bit:1;\n\t};\n\tu8 bits;\n};\n\nenum ds4424_device_ids {\n\tID_DS4422,\n\tID_DS4424,\n};\n\nstruct ds4424_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tuint8_t save[DS4424_MAX_DAC_CHANNELS];\n\tstruct regulator *vcc_reg;\n\tuint8_t raw[DS4424_MAX_DAC_CHANNELS];\n};\n\nstatic const struct iio_chan_spec ds4424_channels[] = {\n\tDS4424_CHANNEL(0),\n\tDS4424_CHANNEL(1),\n\tDS4424_CHANNEL(2),\n\tDS4424_CHANNEL(3),\n};\n\nstatic int ds4424_get_value(struct iio_dev *indio_dev,\n\t\t\t     int *val, int channel)\n{\n\tstruct ds4424_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = i2c_smbus_read_byte_data(data->client, DS4424_DAC_ADDR(channel));\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t*val = ret;\n\nfail:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int ds4424_set_value(struct iio_dev *indio_dev,\n\t\t\t     int val, struct iio_chan_spec const *chan)\n{\n\tstruct ds4424_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\tDS4424_DAC_ADDR(chan->channel), val);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tdata->raw[chan->channel] = val;\n\nfail:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int ds4424_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tunion ds4424_raw_data raw;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = ds4424_get_value(indio_dev, val, chan->channel);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s : ds4424_get_value returned %d\\n\",\n\t\t\t\t\t\t\t__func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t\traw.bits = *val;\n\t\t*val = raw.dx;\n\t\tif (raw.source_bit == DS4424_SINK_I)\n\t\t\t*val = -*val;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ds4424_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tunion ds4424_raw_data raw;\n\n\tif (val2 != 0)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val < S8_MIN || val > S8_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tif (val > 0) {\n\t\t\traw.source_bit = DS4424_SOURCE_I;\n\t\t\traw.dx = val;\n\t\t} else {\n\t\t\traw.source_bit = DS4424_SINK_I;\n\t\t\traw.dx = -val;\n\t\t}\n\n\t\treturn ds4424_set_value(indio_dev, raw.bits, chan);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ds4424_verify_chip(struct iio_dev *indio_dev)\n{\n\tint ret, val;\n\n\tret = ds4424_get_value(indio_dev, &val, 0);\n\tif (ret < 0)\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\"%s failed. ret: %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic int ds4424_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct ds4424_data *data = iio_priv(indio_dev);\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < indio_dev->num_channels; i++) {\n\t\tdata->save[i] = data->raw[i];\n\t\tret = ds4424_set_value(indio_dev, 0,\n\t\t\t\t&indio_dev->channels[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic int ds4424_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct ds4424_data *data = iio_priv(indio_dev);\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < indio_dev->num_channels; i++) {\n\t\tret = ds4424_set_value(indio_dev, data->save[i],\n\t\t\t\t&indio_dev->channels[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ds4424_pm_ops, ds4424_suspend, ds4424_resume);\n\nstatic const struct iio_info ds4424_info = {\n\t.read_raw = ds4424_read_raw,\n\t.write_raw = ds4424_write_raw,\n};\n\nstatic int ds4424_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct ds4424_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev) {\n\t\tdev_err(&client->dev, \"iio dev alloc failed.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tindio_dev->name = id->name;\n\n\tdata->vcc_reg = devm_regulator_get(&client->dev, \"vcc\");\n\tif (IS_ERR(data->vcc_reg))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(data->vcc_reg),\n\t\t\t\t     \"Failed to get vcc-supply regulator.\\n\");\n\n\tmutex_init(&data->lock);\n\tret = regulator_enable(data->vcc_reg);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\t\"Unable to enable the regulator.\\n\");\n\t\treturn ret;\n\t}\n\n\tusleep_range(1000, 1200);\n\tret = ds4424_verify_chip(indio_dev);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tswitch (id->driver_data) {\n\tcase ID_DS4422:\n\t\tindio_dev->num_channels = DS4422_MAX_DAC_CHANNELS;\n\t\tbreak;\n\tcase ID_DS4424:\n\t\tindio_dev->num_channels = DS4424_MAX_DAC_CHANNELS;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev,\n\t\t\t\t\"ds4424: Invalid chip id.\\n\");\n\t\tret = -ENXIO;\n\t\tgoto fail;\n\t}\n\n\tindio_dev->channels = ds4424_channels;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &ds4424_info;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\t\"iio_device_register failed. ret: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\treturn ret;\n\nfail:\n\tregulator_disable(data->vcc_reg);\n\treturn ret;\n}\n\nstatic void ds4424_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct ds4424_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tregulator_disable(data->vcc_reg);\n}\n\nstatic const struct i2c_device_id ds4424_id[] = {\n\t{ \"ds4422\", ID_DS4422 },\n\t{ \"ds4424\", ID_DS4424 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, ds4424_id);\n\nstatic const struct of_device_id ds4424_of_match[] = {\n\t{ .compatible = \"maxim,ds4422\" },\n\t{ .compatible = \"maxim,ds4424\" },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, ds4424_of_match);\n\nstatic struct i2c_driver ds4424_driver = {\n\t.driver = {\n\t\t.name\t= \"ds4424\",\n\t\t.of_match_table = ds4424_of_match,\n\t\t.pm     = pm_sleep_ptr(&ds4424_pm_ops),\n\t},\n\t.probe\t\t= ds4424_probe,\n\t.remove\t\t= ds4424_remove,\n\t.id_table\t= ds4424_id,\n};\nmodule_i2c_driver(ds4424_driver);\n\nMODULE_DESCRIPTION(\"Maxim DS4424 DAC Driver\");\nMODULE_AUTHOR(\"Ismail H. Kose <ismail.kose@maximintegrated.com>\");\nMODULE_AUTHOR(\"Vishal Sood <vishal.sood@maximintegrated.com>\");\nMODULE_AUTHOR(\"David Jung <david.jung@maximintegrated.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}