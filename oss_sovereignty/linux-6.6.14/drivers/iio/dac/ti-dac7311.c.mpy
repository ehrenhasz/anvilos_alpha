{
  "module_name": "ti-dac7311.c",
  "hash_id": "0aa08c446d3b683c68ff5fce766e7ffe478f8ffebeea384c7efd278fd0abc509",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ti-dac7311.c",
  "human_readable_source": "\n \n\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\nenum {\n\tID_DAC5311 = 0,\n\tID_DAC6311,\n\tID_DAC7311,\n};\n\nenum {\n\tPOWER_1KOHM_TO_GND = 0,\n\tPOWER_100KOHM_TO_GND,\n\tPOWER_TRI_STATE,\n};\n\nstruct ti_dac_spec {\n\tu8 resolution;\n};\n\nstatic const struct ti_dac_spec ti_dac_spec[] = {\n\t[ID_DAC5311] = { .resolution = 8 },\n\t[ID_DAC6311] = { .resolution = 10 },\n\t[ID_DAC7311] = { .resolution = 12 },\n};\n\n \nstruct ti_dac_chip {\n\tstruct mutex lock;\n\tstruct regulator *vref;\n\tstruct spi_device *spi;\n\tu16 val;\n\tbool powerdown;\n\tu8 powerdown_mode;\n\tu8 resolution;\n\tu8 buf[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic u8 ti_dac_get_power(struct ti_dac_chip *ti_dac, bool powerdown)\n{\n\tif (powerdown)\n\t\treturn ti_dac->powerdown_mode + 1;\n\n\treturn 0;\n}\n\nstatic int ti_dac_cmd(struct ti_dac_chip *ti_dac, u8 power, u16 val)\n{\n\tu8 shift = 14 - ti_dac->resolution;\n\n\tti_dac->buf[0] = (val << shift) & 0xFF;\n\tti_dac->buf[1] = (power << 6) | (val >> (8 - shift));\n\treturn spi_write(ti_dac->spi, ti_dac->buf, 2);\n}\n\nstatic const char * const ti_dac_powerdown_modes[] = {\n\t\"1kohm_to_gnd\",\n\t\"100kohm_to_gnd\",\n\t\"three_state\",\n};\n\nstatic int ti_dac_get_powerdown_mode(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan)\n{\n\tstruct ti_dac_chip *ti_dac = iio_priv(indio_dev);\n\n\treturn ti_dac->powerdown_mode;\n}\n\nstatic int ti_dac_set_powerdown_mode(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     unsigned int mode)\n{\n\tstruct ti_dac_chip *ti_dac = iio_priv(indio_dev);\n\n\tti_dac->powerdown_mode = mode;\n\treturn 0;\n}\n\nstatic const struct iio_enum ti_dac_powerdown_mode = {\n\t.items = ti_dac_powerdown_modes,\n\t.num_items = ARRAY_SIZE(ti_dac_powerdown_modes),\n\t.get = ti_dac_get_powerdown_mode,\n\t.set = ti_dac_set_powerdown_mode,\n};\n\nstatic ssize_t ti_dac_read_powerdown(struct iio_dev *indio_dev,\n\t\t\t\t     uintptr_t private,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     char *buf)\n{\n\tstruct ti_dac_chip *ti_dac = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ti_dac->powerdown);\n}\n\nstatic ssize_t ti_dac_write_powerdown(struct iio_dev *indio_dev,\n\t\t\t\t      uintptr_t private,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct ti_dac_chip *ti_dac = iio_priv(indio_dev);\n\tbool powerdown;\n\tu8 power;\n\tint ret;\n\n\tret = kstrtobool(buf, &powerdown);\n\tif (ret)\n\t\treturn ret;\n\n\tpower = ti_dac_get_power(ti_dac, powerdown);\n\n\tmutex_lock(&ti_dac->lock);\n\tret = ti_dac_cmd(ti_dac, power, 0);\n\tif (!ret)\n\t\tti_dac->powerdown = powerdown;\n\tmutex_unlock(&ti_dac->lock);\n\n\treturn ret ? ret : len;\n}\n\nstatic const struct iio_chan_spec_ext_info ti_dac_ext_info[] = {\n\t{\n\t\t.name\t   = \"powerdown\",\n\t\t.read\t   = ti_dac_read_powerdown,\n\t\t.write\t   = ti_dac_write_powerdown,\n\t\t.shared\t   = IIO_SHARED_BY_TYPE,\n\t},\n\tIIO_ENUM(\"powerdown_mode\", IIO_SHARED_BY_TYPE, &ti_dac_powerdown_mode),\n\tIIO_ENUM_AVAILABLE(\"powerdown_mode\", IIO_SHARED_BY_TYPE, &ti_dac_powerdown_mode),\n\t{ },\n};\n\n#define TI_DAC_CHANNEL(chan) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.channel = (chan),\t\t\t\t\t\\\n\t.output = true,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.ext_info = ti_dac_ext_info,\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec ti_dac_channels[] = {\n\tTI_DAC_CHANNEL(0),\n};\n\nstatic int ti_dac_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct ti_dac_chip *ti_dac = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*val = ti_dac->val;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = regulator_get_voltage(ti_dac->vref);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret / 1000;\n\t\t*val2 = ti_dac->resolution;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ti_dac_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct ti_dac_chip *ti_dac = iio_priv(indio_dev);\n\tu8 power = ti_dac_get_power(ti_dac, ti_dac->powerdown);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (ti_dac->val == val)\n\t\t\treturn 0;\n\n\t\tif (val >= (1 << ti_dac->resolution) || val < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (ti_dac->powerdown)\n\t\t\treturn -EBUSY;\n\n\t\tmutex_lock(&ti_dac->lock);\n\t\tret = ti_dac_cmd(ti_dac, power, val);\n\t\tif (!ret)\n\t\t\tti_dac->val = val;\n\t\tmutex_unlock(&ti_dac->lock);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int ti_dac_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t    struct iio_chan_spec const *chan, long mask)\n{\n\treturn IIO_VAL_INT;\n}\n\nstatic const struct iio_info ti_dac_info = {\n\t.read_raw\t   = ti_dac_read_raw,\n\t.write_raw\t   = ti_dac_write_raw,\n\t.write_raw_get_fmt = ti_dac_write_raw_get_fmt,\n};\n\nstatic int ti_dac_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tconst struct ti_dac_spec *spec;\n\tstruct ti_dac_chip *ti_dac;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*ti_dac));\n\tif (!indio_dev) {\n\t\tdev_err(dev, \"can not allocate iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspi->mode = SPI_MODE_1;\n\tspi->bits_per_word = 16;\n\tspi_setup(spi);\n\n\tindio_dev->info = &ti_dac_info;\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = ti_dac_channels;\n\tspi_set_drvdata(spi, indio_dev);\n\n\tti_dac = iio_priv(indio_dev);\n\tti_dac->powerdown = false;\n\tti_dac->spi = spi;\n\n\tspec = &ti_dac_spec[spi_get_device_id(spi)->driver_data];\n\tindio_dev->num_channels = 1;\n\tti_dac->resolution = spec->resolution;\n\n\tti_dac->vref = devm_regulator_get(dev, \"vref\");\n\tif (IS_ERR(ti_dac->vref))\n\t\treturn dev_err_probe(dev, PTR_ERR(ti_dac->vref),\n\t\t\t\t     \"error to get regulator\\n\");\n\n\tret = regulator_enable(ti_dac->vref);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can not enable regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_init(&ti_dac->lock);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"fail to register iio device: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tmutex_destroy(&ti_dac->lock);\n\tregulator_disable(ti_dac->vref);\n\treturn ret;\n}\n\nstatic void ti_dac_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct ti_dac_chip *ti_dac = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tmutex_destroy(&ti_dac->lock);\n\tregulator_disable(ti_dac->vref);\n}\n\nstatic const struct of_device_id ti_dac_of_id[] = {\n\t{ .compatible = \"ti,dac5311\" },\n\t{ .compatible = \"ti,dac6311\" },\n\t{ .compatible = \"ti,dac7311\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ti_dac_of_id);\n\nstatic const struct spi_device_id ti_dac_spi_id[] = {\n\t{ \"dac5311\", ID_DAC5311  },\n\t{ \"dac6311\", ID_DAC6311 },\n\t{ \"dac7311\", ID_DAC7311 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, ti_dac_spi_id);\n\nstatic struct spi_driver ti_dac_driver = {\n\t.driver = {\n\t\t.name\t\t= \"ti-dac7311\",\n\t\t.of_match_table\t= ti_dac_of_id,\n\t},\n\t.probe\t  = ti_dac_probe,\n\t.remove   = ti_dac_remove,\n\t.id_table = ti_dac_spi_id,\n};\nmodule_spi_driver(ti_dac_driver);\n\nMODULE_AUTHOR(\"Charles-Antoine Couret <charles-antoine.couret@essensium.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments 8/10/12-bit 1-channel DAC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}