{
  "module_name": "ad7293.c",
  "hash_id": "24996106c2560804bef2c7e2eca459f8a8ea7909abb064945d6b7b761461f7ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad7293.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iio/iio.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <asm/unaligned.h>\n\n#define AD7293_R1B\t\t\t\tBIT(16)\n#define AD7293_R2B\t\t\t\tBIT(17)\n#define AD7293_PAGE_ADDR_MSK\t\t\tGENMASK(15, 8)\n#define AD7293_PAGE(x)\t\t\t\tFIELD_PREP(AD7293_PAGE_ADDR_MSK, x)\n\n \n#define AD7293_REG_NO_OP\t\t\t(AD7293_R1B | AD7293_PAGE(0x0) | 0x0)\n#define AD7293_REG_PAGE_SELECT\t\t\t(AD7293_R1B | AD7293_PAGE(0x0) | 0x1)\n#define AD7293_REG_CONV_CMD\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x2)\n#define AD7293_REG_RESULT\t\t\t(AD7293_R1B | AD7293_PAGE(0x0) | 0x3)\n#define AD7293_REG_DAC_EN\t\t\t(AD7293_R1B | AD7293_PAGE(0x0) | 0x4)\n#define AD7293_REG_DEVICE_ID\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0xC)\n#define AD7293_REG_SOFT_RESET\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0xF)\n\n \n#define AD7293_REG_VIN0\t\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x10)\n#define AD7293_REG_VIN1\t\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x11)\n#define AD7293_REG_VIN2\t\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x12)\n#define AD7293_REG_VIN3\t\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x13)\n#define AD7293_REG_TSENSE_INT\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x20)\n#define AD7293_REG_TSENSE_D0\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x21)\n#define AD7293_REG_TSENSE_D1\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x22)\n#define AD7293_REG_ISENSE_0\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x28)\n#define AD7293_REG_ISENSE_1\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x29)\n#define AD7293_REG_ISENSE_2\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x2A)\n#define AD7293_REG_ISENSE_3\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x2B)\n#define AD7293_REG_UNI_VOUT0\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x30)\n#define AD7293_REG_UNI_VOUT1\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x31)\n#define AD7293_REG_UNI_VOUT2\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x32)\n#define AD7293_REG_UNI_VOUT3\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x33)\n#define AD7293_REG_BI_VOUT0\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x34)\n#define AD7293_REG_BI_VOUT1\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x35)\n#define AD7293_REG_BI_VOUT2\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x36)\n#define AD7293_REG_BI_VOUT3\t\t\t(AD7293_R2B | AD7293_PAGE(0x0) | 0x37)\n\n \n#define AD7293_REG_DIGITAL_OUT_EN\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x11)\n#define AD7293_REG_DIGITAL_INOUT_FUNC\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x12)\n#define AD7293_REG_DIGITAL_FUNC_POL\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x13)\n#define AD7293_REG_GENERAL\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x14)\n#define AD7293_REG_VINX_RANGE0\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x15)\n#define AD7293_REG_VINX_RANGE1\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x16)\n#define AD7293_REG_VINX_DIFF_SE\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x17)\n#define AD7293_REG_VINX_FILTER\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x18)\n#define AD7293_REG_BG_EN\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x19)\n#define AD7293_REG_CONV_DELAY\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x1A)\n#define AD7293_REG_TSENSE_BG_EN\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x1B)\n#define AD7293_REG_ISENSE_BG_EN\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x1C)\n#define AD7293_REG_ISENSE_GAIN\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x1D)\n#define AD7293_REG_DAC_SNOOZE_O\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x1F)\n#define AD7293_REG_DAC_SNOOZE_1\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x20)\n#define AD7293_REG_RSX_MON_BG_EN\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x23)\n#define AD7293_REG_INTEGR_CL\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x28)\n#define AD7293_REG_PA_ON_CTRL\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x29)\n#define AD7293_REG_RAMP_TIME_0\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x2A)\n#define AD7293_REG_RAMP_TIME_1\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x2B)\n#define AD7293_REG_RAMP_TIME_2\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x2C)\n#define AD7293_REG_RAMP_TIME_3\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x2D)\n#define AD7293_REG_CL_FR_IT\t\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x2E)\n#define AD7293_REG_INTX_AVSS_AVDD\t\t(AD7293_R2B | AD7293_PAGE(0x2) | 0x2F)\n\n \n#define AD7293_REG_VINX_SEQ\t\t\t(AD7293_R2B | AD7293_PAGE(0x3) | 0x10)\n#define AD7293_REG_ISENSEX_TSENSEX_SEQ\t\t(AD7293_R2B | AD7293_PAGE(0x3) | 0x11)\n#define AD7293_REG_RSX_MON_BI_VOUTX_SEQ\t\t(AD7293_R2B | AD7293_PAGE(0x3) | 0x12)\n\n \n#define AD7293_REG_VIN0_OFFSET\t\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x10)\n#define AD7293_REG_VIN1_OFFSET\t\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x11)\n#define AD7293_REG_VIN2_OFFSET\t\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x12)\n#define AD7293_REG_VIN3_OFFSET\t\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x13)\n#define AD7293_REG_TSENSE_INT_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x20)\n#define AD7293_REG_TSENSE_D0_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x21)\n#define AD7293_REG_TSENSE_D1_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x22)\n#define AD7293_REG_ISENSE0_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x28)\n#define AD7293_REG_ISENSE1_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x29)\n#define AD7293_REG_ISENSE2_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x2A)\n#define AD7293_REG_ISENSE3_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x2B)\n#define AD7293_REG_UNI_VOUT0_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x30)\n#define AD7293_REG_UNI_VOUT1_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x31)\n#define AD7293_REG_UNI_VOUT2_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x32)\n#define AD7293_REG_UNI_VOUT3_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x33)\n#define AD7293_REG_BI_VOUT0_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x34)\n#define AD7293_REG_BI_VOUT1_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x35)\n#define AD7293_REG_BI_VOUT2_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x36)\n#define AD7293_REG_BI_VOUT3_OFFSET\t\t(AD7293_R1B | AD7293_PAGE(0xE) | 0x37)\n\n \n#define AD7293_READ\t\t\t\tBIT(7)\n#define AD7293_TRANSF_LEN_MSK\t\t\tGENMASK(17, 16)\n\n#define AD7293_REG_ADDR_MSK\t\t\tGENMASK(7, 0)\n#define AD7293_REG_VOUT_OFFSET_MSK\t\tGENMASK(5, 4)\n#define AD7293_REG_DATA_RAW_MSK\t\t\tGENMASK(15, 4)\n#define AD7293_REG_VINX_RANGE_GET_CH_MSK(x, ch)\t(((x) >> (ch)) & 0x1)\n#define AD7293_REG_VINX_RANGE_SET_CH_MSK(x, ch)\t(((x) & 0x1) << (ch))\n#define AD7293_CHIP_ID\t\t\t\t0x18\n\nenum ad7293_ch_type {\n\tAD7293_ADC_VINX,\n\tAD7293_ADC_TSENSE,\n\tAD7293_ADC_ISENSE,\n\tAD7293_DAC,\n};\n\nenum ad7293_max_offset {\n\tAD7293_TSENSE_MIN_OFFSET_CH = 4,\n\tAD7293_ISENSE_MIN_OFFSET_CH = 7,\n\tAD7293_VOUT_MIN_OFFSET_CH = 11,\n\tAD7293_VOUT_MAX_OFFSET_CH = 18,\n};\n\nstatic const int dac_offset_table[] = {0, 1, 2};\n\nstatic const int isense_gain_table[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\nstatic const int adc_range_table[] = {0, 1, 2, 3};\n\nstruct ad7293_state {\n\tstruct spi_device *spi;\n\t \n\tstruct mutex lock;\n\tstruct gpio_desc *gpio_reset;\n\tstruct regulator *reg_avdd;\n\tstruct regulator *reg_vdrive;\n\tu8 page_select;\n\tu8 data[3] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic int ad7293_page_select(struct ad7293_state *st, unsigned int reg)\n{\n\tint ret;\n\n\tif (st->page_select != FIELD_GET(AD7293_PAGE_ADDR_MSK, reg)) {\n\t\tst->data[0] = FIELD_GET(AD7293_REG_ADDR_MSK, AD7293_REG_PAGE_SELECT);\n\t\tst->data[1] = FIELD_GET(AD7293_PAGE_ADDR_MSK, reg);\n\n\t\tret = spi_write(st->spi, &st->data[0], 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tst->page_select = FIELD_GET(AD7293_PAGE_ADDR_MSK, reg);\n\t}\n\n\treturn 0;\n}\n\nstatic int __ad7293_spi_read(struct ad7293_state *st, unsigned int reg,\n\t\t\t     u16 *val)\n{\n\tint ret;\n\tunsigned int length;\n\tstruct spi_transfer t = {0};\n\n\tlength = FIELD_GET(AD7293_TRANSF_LEN_MSK, reg);\n\n\tret = ad7293_page_select(st, reg);\n\tif (ret)\n\t\treturn ret;\n\n\tst->data[0] = AD7293_READ | FIELD_GET(AD7293_REG_ADDR_MSK, reg);\n\tst->data[1] = 0x0;\n\tst->data[2] = 0x0;\n\n\tt.tx_buf = &st->data[0];\n\tt.rx_buf = &st->data[0];\n\tt.len = length + 1;\n\n\tret = spi_sync_transfer(st->spi, &t, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (length == 1)\n\t\t*val = st->data[1];\n\telse\n\t\t*val = get_unaligned_be16(&st->data[1]);\n\n\treturn 0;\n}\n\nstatic int ad7293_spi_read(struct ad7293_state *st, unsigned int reg,\n\t\t\t   u16 *val)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __ad7293_spi_read(st, reg, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int __ad7293_spi_write(struct ad7293_state *st, unsigned int reg,\n\t\t\t      u16 val)\n{\n\tint ret;\n\tunsigned int length;\n\n\tlength = FIELD_GET(AD7293_TRANSF_LEN_MSK, reg);\n\n\tret = ad7293_page_select(st, reg);\n\tif (ret)\n\t\treturn ret;\n\n\tst->data[0] = FIELD_GET(AD7293_REG_ADDR_MSK, reg);\n\n\tif (length == 1)\n\t\tst->data[1] = val;\n\telse\n\t\tput_unaligned_be16(val, &st->data[1]);\n\n\treturn spi_write(st->spi, &st->data[0], length + 1);\n}\n\nstatic int ad7293_spi_write(struct ad7293_state *st, unsigned int reg,\n\t\t\t    u16 val)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __ad7293_spi_write(st, reg, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int __ad7293_spi_update_bits(struct ad7293_state *st, unsigned int reg,\n\t\t\t\t    u16 mask, u16 val)\n{\n\tint ret;\n\tu16 data, temp;\n\n\tret = __ad7293_spi_read(st, reg, &data);\n\tif (ret)\n\t\treturn ret;\n\n\ttemp = (data & ~mask) | (val & mask);\n\n\treturn __ad7293_spi_write(st, reg, temp);\n}\n\nstatic int ad7293_spi_update_bits(struct ad7293_state *st, unsigned int reg,\n\t\t\t\t  u16 mask, u16 val)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = __ad7293_spi_update_bits(st, reg, mask, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad7293_adc_get_scale(struct ad7293_state *st, unsigned int ch,\n\t\t\t\tu16 *range)\n{\n\tint ret;\n\tu16 data;\n\n\tmutex_lock(&st->lock);\n\n\tret = __ad7293_spi_read(st, AD7293_REG_VINX_RANGE1, &data);\n\tif (ret)\n\t\tgoto exit;\n\n\t*range = AD7293_REG_VINX_RANGE_GET_CH_MSK(data, ch);\n\n\tret = __ad7293_spi_read(st, AD7293_REG_VINX_RANGE0, &data);\n\tif (ret)\n\t\tgoto exit;\n\n\t*range |= AD7293_REG_VINX_RANGE_GET_CH_MSK(data, ch) << 1;\n\nexit:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad7293_adc_set_scale(struct ad7293_state *st, unsigned int ch,\n\t\t\t\tu16 range)\n{\n\tint ret;\n\tunsigned int ch_msk = BIT(ch);\n\n\tmutex_lock(&st->lock);\n\tret = __ad7293_spi_update_bits(st, AD7293_REG_VINX_RANGE1, ch_msk,\n\t\t\t\t       AD7293_REG_VINX_RANGE_SET_CH_MSK(range, ch));\n\tif (ret)\n\t\tgoto exit;\n\n\tret = __ad7293_spi_update_bits(st, AD7293_REG_VINX_RANGE0, ch_msk,\n\t\t\t\t       AD7293_REG_VINX_RANGE_SET_CH_MSK((range >> 1), ch));\n\nexit:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad7293_get_offset(struct ad7293_state *st, unsigned int ch,\n\t\t\t     u16 *offset)\n{\n\tif (ch < AD7293_TSENSE_MIN_OFFSET_CH)\n\t\treturn ad7293_spi_read(st, AD7293_REG_VIN0_OFFSET + ch, offset);\n\telse if (ch < AD7293_ISENSE_MIN_OFFSET_CH)\n\t\treturn ad7293_spi_read(st, AD7293_REG_TSENSE_INT_OFFSET + (ch - 4), offset);\n\telse if (ch < AD7293_VOUT_MIN_OFFSET_CH)\n\t\treturn ad7293_spi_read(st, AD7293_REG_ISENSE0_OFFSET + (ch - 7), offset);\n\telse if (ch <= AD7293_VOUT_MAX_OFFSET_CH)\n\t\treturn ad7293_spi_read(st, AD7293_REG_UNI_VOUT0_OFFSET + (ch - 11), offset);\n\n\treturn -EINVAL;\n}\n\nstatic int ad7293_set_offset(struct ad7293_state *st, unsigned int ch,\n\t\t\t     u16 offset)\n{\n\tif (ch < AD7293_TSENSE_MIN_OFFSET_CH)\n\t\treturn ad7293_spi_write(st, AD7293_REG_VIN0_OFFSET + ch,\n\t\t\t\t\toffset);\n\telse if (ch < AD7293_ISENSE_MIN_OFFSET_CH)\n\t\treturn ad7293_spi_write(st,\n\t\t\t\t\tAD7293_REG_TSENSE_INT_OFFSET +\n\t\t\t\t\t(ch - AD7293_TSENSE_MIN_OFFSET_CH),\n\t\t\t\t\toffset);\n\telse if (ch < AD7293_VOUT_MIN_OFFSET_CH)\n\t\treturn ad7293_spi_write(st,\n\t\t\t\t\tAD7293_REG_ISENSE0_OFFSET +\n\t\t\t\t\t(ch - AD7293_ISENSE_MIN_OFFSET_CH),\n\t\t\t\t\toffset);\n\telse if (ch <= AD7293_VOUT_MAX_OFFSET_CH)\n\t\treturn ad7293_spi_update_bits(st,\n\t\t\t\t\t      AD7293_REG_UNI_VOUT0_OFFSET +\n\t\t\t\t\t      (ch - AD7293_VOUT_MIN_OFFSET_CH),\n\t\t\t\t\t      AD7293_REG_VOUT_OFFSET_MSK,\n\t\t\t\t\t      FIELD_PREP(AD7293_REG_VOUT_OFFSET_MSK, offset));\n\n\treturn -EINVAL;\n}\n\nstatic int ad7293_isense_set_scale(struct ad7293_state *st, unsigned int ch,\n\t\t\t\t   u16 gain)\n{\n\tunsigned int ch_msk = (0xf << (4 * ch));\n\n\treturn ad7293_spi_update_bits(st, AD7293_REG_ISENSE_GAIN, ch_msk,\n\t\t\t\t      gain << (4 * ch));\n}\n\nstatic int ad7293_isense_get_scale(struct ad7293_state *st, unsigned int ch,\n\t\t\t\t   u16 *gain)\n{\n\tint ret;\n\n\tret = ad7293_spi_read(st, AD7293_REG_ISENSE_GAIN, gain);\n\tif (ret)\n\t\treturn ret;\n\n\t*gain = (*gain >> (4 * ch)) & 0xf;\n\n\treturn ret;\n}\n\nstatic int ad7293_dac_write_raw(struct ad7293_state *st, unsigned int ch,\n\t\t\t\tu16 raw)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = __ad7293_spi_update_bits(st, AD7293_REG_DAC_EN, BIT(ch), BIT(ch));\n\tif (ret)\n\t\tgoto exit;\n\n\tret =  __ad7293_spi_write(st, AD7293_REG_UNI_VOUT0 + ch,\n\t\t\t\t  FIELD_PREP(AD7293_REG_DATA_RAW_MSK, raw));\n\nexit:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad7293_ch_read_raw(struct ad7293_state *st, enum ad7293_ch_type type,\n\t\t\t      unsigned int ch, u16 *raw)\n{\n\tint ret;\n\tunsigned int reg_wr, reg_rd, data_wr;\n\n\tswitch (type) {\n\tcase AD7293_ADC_VINX:\n\t\treg_wr = AD7293_REG_VINX_SEQ;\n\t\treg_rd = AD7293_REG_VIN0 + ch;\n\t\tdata_wr = BIT(ch);\n\n\t\tbreak;\n\tcase AD7293_ADC_TSENSE:\n\t\treg_wr = AD7293_REG_ISENSEX_TSENSEX_SEQ;\n\t\treg_rd = AD7293_REG_TSENSE_INT + ch;\n\t\tdata_wr = BIT(ch);\n\n\t\tbreak;\n\tcase AD7293_ADC_ISENSE:\n\t\treg_wr = AD7293_REG_ISENSEX_TSENSEX_SEQ;\n\t\treg_rd = AD7293_REG_ISENSE_0 + ch;\n\t\tdata_wr = BIT(ch) << 8;\n\n\t\tbreak;\n\tcase AD7293_DAC:\n\t\treg_rd = AD7293_REG_UNI_VOUT0 + ch;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&st->lock);\n\n\tif (type != AD7293_DAC) {\n\t\tif (type == AD7293_ADC_TSENSE) {\n\t\t\tret = __ad7293_spi_write(st, AD7293_REG_TSENSE_BG_EN,\n\t\t\t\t\t\t BIT(ch));\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\n\t\t\tusleep_range(9000, 9900);\n\t\t} else if (type == AD7293_ADC_ISENSE) {\n\t\t\tret = __ad7293_spi_write(st, AD7293_REG_ISENSE_BG_EN,\n\t\t\t\t\t\t BIT(ch));\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\n\t\t\tusleep_range(2000, 7000);\n\t\t}\n\n\t\tret = __ad7293_spi_write(st, reg_wr, data_wr);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\tret = __ad7293_spi_write(st, AD7293_REG_CONV_CMD, 0x82);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tret = __ad7293_spi_read(st, reg_rd, raw);\n\n\t*raw = FIELD_GET(AD7293_REG_DATA_RAW_MSK, *raw);\n\nexit:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad7293_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long info)\n{\n\tstruct ad7293_state *st = iio_priv(indio_dev);\n\tint ret;\n\tu16 data;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tif (chan->output)\n\t\t\t\tret =  ad7293_ch_read_raw(st, AD7293_DAC,\n\t\t\t\t\t\t\t  chan->channel, &data);\n\t\t\telse\n\t\t\t\tret =  ad7293_ch_read_raw(st, AD7293_ADC_VINX,\n\t\t\t\t\t\t\t  chan->channel, &data);\n\n\t\t\tbreak;\n\t\tcase IIO_CURRENT:\n\t\t\tret =  ad7293_ch_read_raw(st, AD7293_ADC_ISENSE,\n\t\t\t\t\t\t  chan->channel, &data);\n\n\t\t\tbreak;\n\t\tcase IIO_TEMP:\n\t\t\tret =  ad7293_ch_read_raw(st, AD7293_ADC_TSENSE,\n\t\t\t\t\t\t  chan->channel, &data);\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = data;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tif (chan->output) {\n\t\t\t\tret = ad7293_get_offset(st,\n\t\t\t\t\t\t\tchan->channel + AD7293_VOUT_MIN_OFFSET_CH,\n\t\t\t\t\t\t\t&data);\n\n\t\t\t\tdata = FIELD_GET(AD7293_REG_VOUT_OFFSET_MSK, data);\n\t\t\t} else {\n\t\t\t\tret = ad7293_get_offset(st, chan->channel, &data);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase IIO_CURRENT:\n\t\t\tret = ad7293_get_offset(st,\n\t\t\t\t\t\tchan->channel + AD7293_ISENSE_MIN_OFFSET_CH,\n\t\t\t\t\t\t&data);\n\n\t\t\tbreak;\n\t\tcase IIO_TEMP:\n\t\t\tret = ad7293_get_offset(st,\n\t\t\t\t\t\tchan->channel + AD7293_TSENSE_MIN_OFFSET_CH,\n\t\t\t\t\t\t&data);\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = data;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tret = ad7293_adc_get_scale(st, chan->channel, &data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*val = data;\n\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_CURRENT:\n\t\t\tret = ad7293_isense_get_scale(st, chan->channel, &data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*val = data;\n\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_TEMP:\n\t\t\t*val = 1;\n\t\t\t*val2 = 8;\n\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad7293_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long info)\n{\n\tstruct ad7293_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tif (!chan->output)\n\t\t\t\treturn -EINVAL;\n\n\t\t\treturn ad7293_dac_write_raw(st, chan->channel, val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tif (chan->output)\n\t\t\t\treturn ad7293_set_offset(st,\n\t\t\t\t\t\t\t chan->channel +\n\t\t\t\t\t\t\t AD7293_VOUT_MIN_OFFSET_CH,\n\t\t\t\t\t\t\t val);\n\t\t\telse\n\t\t\t\treturn ad7293_set_offset(st, chan->channel, val);\n\t\tcase IIO_CURRENT:\n\t\t\treturn ad7293_set_offset(st,\n\t\t\t\t\t\t chan->channel +\n\t\t\t\t\t\t AD7293_ISENSE_MIN_OFFSET_CH,\n\t\t\t\t\t\t val);\n\t\tcase IIO_TEMP:\n\t\t\treturn ad7293_set_offset(st,\n\t\t\t\t\t\t chan->channel +\n\t\t\t\t\t\t AD7293_TSENSE_MIN_OFFSET_CH,\n\t\t\t\t\t\t val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\treturn ad7293_adc_set_scale(st, chan->channel, val);\n\t\tcase IIO_CURRENT:\n\t\t\treturn ad7293_isense_set_scale(st, chan->channel, val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad7293_reg_access(struct iio_dev *indio_dev,\n\t\t\t     unsigned int reg,\n\t\t\t     unsigned int write_val,\n\t\t\t     unsigned int *read_val)\n{\n\tstruct ad7293_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tif (read_val) {\n\t\tu16 temp;\n\t\tret = ad7293_spi_read(st, reg, &temp);\n\t\t*read_val = temp;\n\t} else {\n\t\tret = ad7293_spi_write(st, reg, (u16)write_val);\n\t}\n\n\treturn ret;\n}\n\nstatic int ad7293_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type, int *length,\n\t\t\t     long info)\n{\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*vals = dac_offset_table;\n\t\t*type = IIO_VAL_INT;\n\t\t*length = ARRAY_SIZE(dac_offset_table);\n\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*type = IIO_VAL_INT;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\t*vals = adc_range_table;\n\t\t\t*length = ARRAY_SIZE(adc_range_table);\n\t\t\treturn IIO_AVAIL_LIST;\n\t\tcase IIO_CURRENT:\n\t\t\t*vals = isense_gain_table;\n\t\t\t*length = ARRAY_SIZE(isense_gain_table);\n\t\t\treturn IIO_AVAIL_LIST;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#define AD7293_CHAN_ADC(_channel) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\t\\\n\t.output = 0,\t\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\t\t\\\n\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SCALE)\t\\\n}\n\n#define AD7293_CHAN_DAC(_channel) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\t\t\\\n\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_OFFSET)\t\\\n}\n\n#define AD7293_CHAN_ISENSE(_channel) {\t\t\t\t\t\\\n\t.type = IIO_CURRENT,\t\t\t\t\t\t\\\n\t.output = 0,\t\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_OFFSET) |\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\t\t\t\\\n\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SCALE)\t\\\n}\n\n#define AD7293_CHAN_TEMP(_channel) {\t\t\t\t\t\\\n\t.type = IIO_TEMP,\t\t\t\t\t\t\\\n\t.output = 0,\t\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel = _channel,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE)\t\t\\\n}\n\nstatic const struct iio_chan_spec ad7293_channels[] = {\n\tAD7293_CHAN_ADC(0),\n\tAD7293_CHAN_ADC(1),\n\tAD7293_CHAN_ADC(2),\n\tAD7293_CHAN_ADC(3),\n\tAD7293_CHAN_ISENSE(0),\n\tAD7293_CHAN_ISENSE(1),\n\tAD7293_CHAN_ISENSE(2),\n\tAD7293_CHAN_ISENSE(3),\n\tAD7293_CHAN_TEMP(0),\n\tAD7293_CHAN_TEMP(1),\n\tAD7293_CHAN_TEMP(2),\n\tAD7293_CHAN_DAC(0),\n\tAD7293_CHAN_DAC(1),\n\tAD7293_CHAN_DAC(2),\n\tAD7293_CHAN_DAC(3),\n\tAD7293_CHAN_DAC(4),\n\tAD7293_CHAN_DAC(5),\n\tAD7293_CHAN_DAC(6),\n\tAD7293_CHAN_DAC(7)\n};\n\nstatic int ad7293_soft_reset(struct ad7293_state *st)\n{\n\tint ret;\n\n\tret = __ad7293_spi_write(st, AD7293_REG_SOFT_RESET, 0x7293);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __ad7293_spi_write(st, AD7293_REG_SOFT_RESET, 0x0000);\n}\n\nstatic int ad7293_reset(struct ad7293_state *st)\n{\n\tif (st->gpio_reset) {\n\t\tgpiod_set_value(st->gpio_reset, 0);\n\t\tusleep_range(100, 1000);\n\t\tgpiod_set_value(st->gpio_reset, 1);\n\t\tusleep_range(100, 1000);\n\n\t\treturn 0;\n\t}\n\n\t \n\treturn ad7293_soft_reset(st);\n}\n\nstatic int ad7293_properties_parse(struct ad7293_state *st)\n{\n\tstruct spi_device *spi = st->spi;\n\n\tst->gpio_reset = devm_gpiod_get_optional(&st->spi->dev, \"reset\",\n\t\t\t\t\t\t GPIOD_OUT_HIGH);\n\tif (IS_ERR(st->gpio_reset))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(st->gpio_reset),\n\t\t\t\t     \"failed to get the reset GPIO\\n\");\n\n\tst->reg_avdd = devm_regulator_get(&spi->dev, \"avdd\");\n\tif (IS_ERR(st->reg_avdd))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(st->reg_avdd),\n\t\t\t\t     \"failed to get the AVDD voltage\\n\");\n\n\tst->reg_vdrive = devm_regulator_get(&spi->dev, \"vdrive\");\n\tif (IS_ERR(st->reg_vdrive))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(st->reg_vdrive),\n\t\t\t\t     \"failed to get the VDRIVE voltage\\n\");\n\n\treturn 0;\n}\n\nstatic void ad7293_reg_disable(void *data)\n{\n\tregulator_disable(data);\n}\n\nstatic int ad7293_init(struct ad7293_state *st)\n{\n\tint ret;\n\tu16 chip_id;\n\tstruct spi_device *spi = st->spi;\n\n\tret = ad7293_properties_parse(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad7293_reset(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_enable(st->reg_avdd);\n\tif (ret) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"Failed to enable specified AVDD Voltage!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&spi->dev, ad7293_reg_disable,\n\t\t\t\t       st->reg_avdd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_enable(st->reg_vdrive);\n\tif (ret) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"Failed to enable specified VDRIVE Voltage!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&spi->dev, ad7293_reg_disable,\n\t\t\t\t       st->reg_vdrive);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_get_voltage(st->reg_avdd);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"Failed to read avdd regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ret > 5500000 || ret < 4500000)\n\t\treturn -EINVAL;\n\n\tret = regulator_get_voltage(st->reg_vdrive);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"Failed to read vdrive regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (ret > 5500000 || ret < 1700000)\n\t\treturn -EINVAL;\n\n\t \n\tret = __ad7293_spi_read(st, AD7293_REG_DEVICE_ID, &chip_id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chip_id != AD7293_CHIP_ID) {\n\t\tdev_err(&spi->dev, \"Invalid Chip ID.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iio_info ad7293_info = {\n\t.read_raw = ad7293_read_raw,\n\t.write_raw = ad7293_write_raw,\n\t.read_avail = &ad7293_read_avail,\n\t.debugfs_reg_access = &ad7293_reg_access,\n};\n\nstatic int ad7293_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct ad7293_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tindio_dev->info = &ad7293_info;\n\tindio_dev->name = \"ad7293\";\n\tindio_dev->channels = ad7293_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ad7293_channels);\n\n\tst->spi = spi;\n\tst->page_select = 0;\n\n\tmutex_init(&st->lock);\n\n\tret = ad7293_init(st);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad7293_id[] = {\n\t{ \"ad7293\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad7293_id);\n\nstatic const struct of_device_id ad7293_of_match[] = {\n\t{ .compatible = \"adi,ad7293\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ad7293_of_match);\n\nstatic struct spi_driver ad7293_driver = {\n\t.driver = {\n\t\t.name = \"ad7293\",\n\t\t.of_match_table = ad7293_of_match,\n\t},\n\t.probe = ad7293_probe,\n\t.id_table = ad7293_id,\n};\nmodule_spi_driver(ad7293_driver);\n\nMODULE_AUTHOR(\"Antoniu Miclaus <antoniu.miclaus@analog.com\");\nMODULE_DESCRIPTION(\"Analog Devices AD7293\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}