{
  "module_name": "ad5758.c",
  "hash_id": "b8f6beed1de4806f0d5c2e1bd6fff26747ded0a1b55973b2a587d3309a410488",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad5758.c",
  "human_readable_source": "\n \n#include <linux/bsearch.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n#include <linux/gpio/consumer.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n \n#define AD5758_NOP\t\t\t\t0x00\n#define AD5758_DAC_INPUT\t\t\t0x01\n#define AD5758_DAC_OUTPUT\t\t\t0x02\n#define AD5758_CLEAR_CODE\t\t\t0x03\n#define AD5758_USER_GAIN\t\t\t0x04\n#define AD5758_USER_OFFSET\t\t\t0x05\n#define AD5758_DAC_CONFIG\t\t\t0x06\n#define AD5758_SW_LDAC\t\t\t\t0x07\n#define AD5758_KEY\t\t\t\t0x08\n#define AD5758_GP_CONFIG1\t\t\t0x09\n#define AD5758_GP_CONFIG2\t\t\t0x0A\n#define AD5758_DCDC_CONFIG1\t\t\t0x0B\n#define AD5758_DCDC_CONFIG2\t\t\t0x0C\n#define AD5758_WDT_CONFIG\t\t\t0x0F\n#define AD5758_DIGITAL_DIAG_CONFIG\t\t0x10\n#define AD5758_ADC_CONFIG\t\t\t0x11\n#define AD5758_FAULT_PIN_CONFIG\t\t\t0x12\n#define AD5758_TWO_STAGE_READBACK_SELECT\t0x13\n#define AD5758_DIGITAL_DIAG_RESULTS\t\t0x14\n#define AD5758_ANALOG_DIAG_RESULTS\t\t0x15\n#define AD5758_STATUS\t\t\t\t0x16\n#define AD5758_CHIP_ID\t\t\t\t0x17\n#define AD5758_FREQ_MONITOR\t\t\t0x18\n#define AD5758_DEVICE_ID_0\t\t\t0x19\n#define AD5758_DEVICE_ID_1\t\t\t0x1A\n#define AD5758_DEVICE_ID_2\t\t\t0x1B\n#define AD5758_DEVICE_ID_3\t\t\t0x1C\n\n \n#define AD5758_DAC_CONFIG_RANGE_MSK\t\tGENMASK(3, 0)\n#define AD5758_DAC_CONFIG_RANGE_MODE(x)\t\t(((x) & 0xF) << 0)\n#define AD5758_DAC_CONFIG_INT_EN_MSK\t\tBIT(5)\n#define AD5758_DAC_CONFIG_INT_EN_MODE(x)\t(((x) & 0x1) << 5)\n#define AD5758_DAC_CONFIG_OUT_EN_MSK\t\tBIT(6)\n#define AD5758_DAC_CONFIG_OUT_EN_MODE(x)\t(((x) & 0x1) << 6)\n#define AD5758_DAC_CONFIG_SR_EN_MSK\t\tBIT(8)\n#define AD5758_DAC_CONFIG_SR_EN_MODE(x)\t\t(((x) & 0x1) << 8)\n#define AD5758_DAC_CONFIG_SR_CLOCK_MSK\t\tGENMASK(12, 9)\n#define AD5758_DAC_CONFIG_SR_CLOCK_MODE(x)\t(((x) & 0xF) << 9)\n#define AD5758_DAC_CONFIG_SR_STEP_MSK\t\tGENMASK(15, 13)\n#define AD5758_DAC_CONFIG_SR_STEP_MODE(x)\t(((x) & 0x7) << 13)\n\n \n#define AD5758_KEY_CODE_RESET_1\t\t\t0x15FA\n#define AD5758_KEY_CODE_RESET_2\t\t\t0xAF51\n#define AD5758_KEY_CODE_SINGLE_ADC_CONV\t\t0x1ADC\n#define AD5758_KEY_CODE_RESET_WDT\t\t0x0D06\n#define AD5758_KEY_CODE_CALIB_MEM_REFRESH\t0xFCBA\n\n \n#define AD5758_DCDC_CONFIG1_DCDC_VPROG_MSK\tGENMASK(4, 0)\n#define AD5758_DCDC_CONFIG1_DCDC_VPROG_MODE(x)\t(((x) & 0x1F) << 0)\n#define AD5758_DCDC_CONFIG1_DCDC_MODE_MSK\tGENMASK(6, 5)\n#define AD5758_DCDC_CONFIG1_DCDC_MODE_MODE(x)\t(((x) & 0x3) << 5)\n\n \n#define AD5758_DCDC_CONFIG2_ILIMIT_MSK\t\tGENMASK(3, 1)\n#define AD5758_DCDC_CONFIG2_ILIMIT_MODE(x)\t(((x) & 0x7) << 1)\n#define AD5758_DCDC_CONFIG2_INTR_SAT_3WI_MSK\tBIT(11)\n#define AD5758_DCDC_CONFIG2_BUSY_3WI_MSK\tBIT(12)\n\n \n#define AD5758_CAL_MEM_UNREFRESHED_MSK\t\tBIT(15)\n\n \n#define AD5758_ADC_CONFIG_PPC_BUF_EN(x)\t\t(((x) & 0x1) << 11)\n#define AD5758_ADC_CONFIG_PPC_BUF_MSK\t\tBIT(11)\n\n#define AD5758_WR_FLAG_MSK(x)\t\t(0x80 | ((x) & 0x1F))\n\n#define AD5758_FULL_SCALE_MICRO\t65535000000ULL\n\nstruct ad5758_range {\n\tint reg;\n\tint min;\n\tint max;\n};\n\n \nstruct ad5758_state {\n\tstruct spi_device *spi;\n\tstruct mutex lock;\n\tstruct gpio_desc *gpio_reset;\n\tstruct ad5758_range out_range;\n\tunsigned int dc_dc_mode;\n\tunsigned int dc_dc_ilim;\n\tunsigned int slew_time;\n\tbool pwr_down;\n\t__be32 d32[3];\n};\n\n \nenum ad5758_output_range {\n\tAD5758_RANGE_0V_5V,\n\tAD5758_RANGE_0V_10V,\n\tAD5758_RANGE_PLUSMINUS_5V,\n\tAD5758_RANGE_PLUSMINUS_10V,\n\tAD5758_RANGE_0mA_20mA = 8,\n\tAD5758_RANGE_0mA_24mA,\n\tAD5758_RANGE_4mA_24mA,\n\tAD5758_RANGE_PLUSMINUS_20mA,\n\tAD5758_RANGE_PLUSMINUS_24mA,\n\tAD5758_RANGE_MINUS_1mA_PLUS_22mA,\n};\n\nenum ad5758_dc_dc_mode {\n\tAD5758_DCDC_MODE_POWER_OFF,\n\tAD5758_DCDC_MODE_DPC_CURRENT,\n\tAD5758_DCDC_MODE_DPC_VOLTAGE,\n\tAD5758_DCDC_MODE_PPC_CURRENT,\n};\n\nstatic const struct ad5758_range ad5758_voltage_range[] = {\n\t{ AD5758_RANGE_0V_5V, 0, 5000000 },\n\t{ AD5758_RANGE_0V_10V, 0, 10000000 },\n\t{ AD5758_RANGE_PLUSMINUS_5V, -5000000, 5000000 },\n\t{ AD5758_RANGE_PLUSMINUS_10V, -10000000, 10000000 }\n};\n\nstatic const struct ad5758_range ad5758_current_range[] = {\n\t{ AD5758_RANGE_0mA_20mA, 0, 20000},\n\t{ AD5758_RANGE_0mA_24mA, 0, 24000 },\n\t{ AD5758_RANGE_4mA_24mA, 4, 24000 },\n\t{ AD5758_RANGE_PLUSMINUS_20mA, -20000, 20000 },\n\t{ AD5758_RANGE_PLUSMINUS_24mA, -24000, 24000 },\n\t{ AD5758_RANGE_MINUS_1mA_PLUS_22mA, -1000, 22000 },\n};\n\nstatic const int ad5758_sr_clk[16] = {\n\t240000, 200000, 150000, 128000, 64000, 32000, 16000, 8000, 4000, 2000,\n\t1000, 512, 256, 128, 64, 16\n};\n\nstatic const int ad5758_sr_step[8] = {\n\t4, 12, 64, 120, 256, 500, 1820, 2048\n};\n\nstatic const int ad5758_dc_dc_ilim[6] = {\n\t150000, 200000, 250000, 300000, 350000, 400000\n};\n\nstatic int ad5758_spi_reg_read(struct ad5758_state *st, unsigned int addr)\n{\n\tstruct spi_transfer t[] = {\n\t\t{\n\t\t\t.tx_buf = &st->d32[0],\n\t\t\t.len = 4,\n\t\t\t.cs_change = 1,\n\t\t}, {\n\t\t\t.tx_buf = &st->d32[1],\n\t\t\t.rx_buf = &st->d32[2],\n\t\t\t.len = 4,\n\t\t},\n\t};\n\tint ret;\n\n\tst->d32[0] = cpu_to_be32(\n\t\t(AD5758_WR_FLAG_MSK(AD5758_TWO_STAGE_READBACK_SELECT) << 24) |\n\t\t(addr << 8));\n\tst->d32[1] = cpu_to_be32(AD5758_WR_FLAG_MSK(AD5758_NOP) << 24);\n\n\tret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (be32_to_cpu(st->d32[2]) >> 8) & 0xFFFF;\n}\n\nstatic int ad5758_spi_reg_write(struct ad5758_state *st,\n\t\t\t\tunsigned int addr,\n\t\t\t\tunsigned int val)\n{\n\tst->d32[0] = cpu_to_be32((AD5758_WR_FLAG_MSK(addr) << 24) |\n\t\t\t\t ((val & 0xFFFF) << 8));\n\n\treturn spi_write(st->spi, &st->d32[0], sizeof(st->d32[0]));\n}\n\nstatic int ad5758_spi_write_mask(struct ad5758_state *st,\n\t\t\t\t unsigned int addr,\n\t\t\t\t unsigned long int mask,\n\t\t\t\t unsigned int val)\n{\n\tint regval;\n\n\tregval = ad5758_spi_reg_read(st, addr);\n\tif (regval < 0)\n\t\treturn regval;\n\n\tregval &= ~mask;\n\tregval |= val;\n\n\treturn ad5758_spi_reg_write(st, addr, regval);\n}\n\nstatic int cmpfunc(const void *a, const void *b)\n{\n\treturn *(int *)a - *(int *)b;\n}\n\nstatic int ad5758_find_closest_match(const int *array,\n\t\t\t\t     unsigned int size, int val)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (val <= array[i])\n\t\t\treturn i;\n\t}\n\n\treturn size - 1;\n}\n\nstatic int ad5758_wait_for_task_complete(struct ad5758_state *st,\n\t\t\t\t\t unsigned int reg,\n\t\t\t\t\t unsigned int mask)\n{\n\tunsigned int timeout;\n\tint ret;\n\n\ttimeout = 10;\n\tdo {\n\t\tret = ad5758_spi_reg_read(st, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(ret & mask))\n\t\t\treturn 0;\n\n\t\tusleep_range(100, 1000);\n\t} while (--timeout);\n\n\tdev_err(&st->spi->dev,\n\t\t\"Error reading bit 0x%x in 0x%x register\\n\", mask, reg);\n\n\treturn -EIO;\n}\n\nstatic int ad5758_calib_mem_refresh(struct ad5758_state *st)\n{\n\tint ret;\n\n\tret = ad5758_spi_reg_write(st, AD5758_KEY,\n\t\t\t\t   AD5758_KEY_CODE_CALIB_MEM_REFRESH);\n\tif (ret < 0) {\n\t\tdev_err(&st->spi->dev,\n\t\t\t\"Failed to initiate a calibration memory refresh\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\treturn ad5758_wait_for_task_complete(st, AD5758_DIGITAL_DIAG_RESULTS,\n\t\t\t\t\t     AD5758_CAL_MEM_UNREFRESHED_MSK);\n}\n\nstatic int ad5758_soft_reset(struct ad5758_state *st)\n{\n\tint ret;\n\n\tret = ad5758_spi_reg_write(st, AD5758_KEY, AD5758_KEY_CODE_RESET_1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ad5758_spi_reg_write(st, AD5758_KEY, AD5758_KEY_CODE_RESET_2);\n\n\t \n\tusleep_range(100, 1000);\n\n\treturn ret;\n}\n\nstatic int ad5758_set_dc_dc_conv_mode(struct ad5758_state *st,\n\t\t\t\t      enum ad5758_dc_dc_mode mode)\n{\n\tint ret;\n\n\t \n\tif (mode == AD5758_DCDC_MODE_PPC_CURRENT) {\n\t\tret  = ad5758_spi_write_mask(st, AD5758_ADC_CONFIG,\n\t\t\t\t    AD5758_ADC_CONFIG_PPC_BUF_MSK,\n\t\t\t\t    AD5758_ADC_CONFIG_PPC_BUF_EN(1));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = ad5758_spi_write_mask(st, AD5758_DCDC_CONFIG1,\n\t\t\t\t    AD5758_DCDC_CONFIG1_DCDC_MODE_MSK,\n\t\t\t\t    AD5758_DCDC_CONFIG1_DCDC_MODE_MODE(mode));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ad5758_wait_for_task_complete(st, AD5758_DCDC_CONFIG2,\n\t\t\t\t\t    AD5758_DCDC_CONFIG2_BUSY_3WI_MSK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->dc_dc_mode = mode;\n\n\treturn ret;\n}\n\nstatic int ad5758_set_dc_dc_ilim(struct ad5758_state *st, unsigned int ilim)\n{\n\tint ret;\n\n\tret = ad5758_spi_write_mask(st, AD5758_DCDC_CONFIG2,\n\t\t\t\t    AD5758_DCDC_CONFIG2_ILIMIT_MSK,\n\t\t\t\t    AD5758_DCDC_CONFIG2_ILIMIT_MODE(ilim));\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\treturn ad5758_wait_for_task_complete(st, AD5758_DCDC_CONFIG2,\n\t\t\t\t\t     AD5758_DCDC_CONFIG2_BUSY_3WI_MSK);\n}\n\nstatic int ad5758_slew_rate_set(struct ad5758_state *st,\n\t\t\t\tunsigned int sr_clk_idx,\n\t\t\t\tunsigned int sr_step_idx)\n{\n\tunsigned int mode;\n\tunsigned long int mask;\n\tint ret;\n\n\tmask = AD5758_DAC_CONFIG_SR_EN_MSK |\n\t       AD5758_DAC_CONFIG_SR_CLOCK_MSK |\n\t       AD5758_DAC_CONFIG_SR_STEP_MSK;\n\tmode = AD5758_DAC_CONFIG_SR_EN_MODE(1) |\n\t       AD5758_DAC_CONFIG_SR_STEP_MODE(sr_step_idx) |\n\t       AD5758_DAC_CONFIG_SR_CLOCK_MODE(sr_clk_idx);\n\n\tret = ad5758_spi_write_mask(st, AD5758_DAC_CONFIG, mask, mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn ad5758_wait_for_task_complete(st, AD5758_DIGITAL_DIAG_RESULTS,\n\t\t\t\t\t     AD5758_CAL_MEM_UNREFRESHED_MSK);\n}\n\nstatic int ad5758_slew_rate_config(struct ad5758_state *st)\n{\n\tunsigned int sr_clk_idx, sr_step_idx;\n\tint i, res;\n\ts64 diff_new, diff_old;\n\tu64 sr_step, calc_slew_time;\n\n\tsr_clk_idx = 0;\n\tsr_step_idx = 0;\n\tdiff_old = S64_MAX;\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ad5758_sr_clk); i++) {\n\t\t \n\t\tsr_step = AD5758_FULL_SCALE_MICRO;\n\t\tdo_div(sr_step, ad5758_sr_clk[i]);\n\t\tdo_div(sr_step, st->slew_time);\n\t\t \n\t\tres = ad5758_find_closest_match(ad5758_sr_step,\n\t\t\t\t\t\tARRAY_SIZE(ad5758_sr_step),\n\t\t\t\t\t\tsr_step);\n\t\t \n\t\tcalc_slew_time = AD5758_FULL_SCALE_MICRO;\n\t\tdo_div(calc_slew_time, ad5758_sr_step[res]);\n\t\tdo_div(calc_slew_time, ad5758_sr_clk[i]);\n\t\t \n\t\tdiff_new = abs(st->slew_time - calc_slew_time);\n\t\tif (diff_new < diff_old) {\n\t\t\tdiff_old = diff_new;\n\t\t\tsr_clk_idx = i;\n\t\t\tsr_step_idx = res;\n\t\t}\n\t}\n\n\treturn ad5758_slew_rate_set(st, sr_clk_idx, sr_step_idx);\n}\n\nstatic int ad5758_set_out_range(struct ad5758_state *st, int range)\n{\n\tint ret;\n\n\tret = ad5758_spi_write_mask(st, AD5758_DAC_CONFIG,\n\t\t\t\t    AD5758_DAC_CONFIG_RANGE_MSK,\n\t\t\t\t    AD5758_DAC_CONFIG_RANGE_MODE(range));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn ad5758_wait_for_task_complete(st, AD5758_DIGITAL_DIAG_RESULTS,\n\t\t\t\t\t     AD5758_CAL_MEM_UNREFRESHED_MSK);\n}\n\nstatic int ad5758_internal_buffers_en(struct ad5758_state *st, bool enable)\n{\n\tint ret;\n\n\tret = ad5758_spi_write_mask(st, AD5758_DAC_CONFIG,\n\t\t\t\t    AD5758_DAC_CONFIG_INT_EN_MSK,\n\t\t\t\t    AD5758_DAC_CONFIG_INT_EN_MODE(enable));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn ad5758_wait_for_task_complete(st, AD5758_DIGITAL_DIAG_RESULTS,\n\t\t\t\t\t     AD5758_CAL_MEM_UNREFRESHED_MSK);\n}\n\nstatic int ad5758_reset(struct ad5758_state *st)\n{\n\tif (st->gpio_reset) {\n\t\tgpiod_set_value(st->gpio_reset, 0);\n\t\tusleep_range(100, 1000);\n\t\tgpiod_set_value(st->gpio_reset, 1);\n\t\tusleep_range(100, 1000);\n\n\t\treturn 0;\n\t} else {\n\t\t \n\t\treturn ad5758_soft_reset(st);\n\t}\n}\n\nstatic int ad5758_reg_access(struct iio_dev *indio_dev,\n\t\t\t     unsigned int reg,\n\t\t\t     unsigned int writeval,\n\t\t\t     unsigned int *readval)\n{\n\tstruct ad5758_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tif (readval) {\n\t\tret = ad5758_spi_reg_read(st, reg);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\t*readval = ret;\n\t\tret = 0;\n\t} else {\n\t\tret = ad5758_spi_reg_write(st, reg, writeval);\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad5758_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long info)\n{\n\tstruct ad5758_state *st = iio_priv(indio_dev);\n\tint max, min, ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&st->lock);\n\t\tret = ad5758_spi_reg_read(st, AD5758_DAC_INPUT);\n\t\tmutex_unlock(&st->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tmin = st->out_range.min;\n\t\tmax = st->out_range.max;\n\t\t*val = (max - min) / 1000;\n\t\t*val2 = 16;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tmin = st->out_range.min;\n\t\tmax = st->out_range.max;\n\t\t*val = ((min * (1 << 16)) / (max - min)) / 1000;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad5758_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long info)\n{\n\tstruct ad5758_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&st->lock);\n\t\tret = ad5758_spi_reg_write(st, AD5758_DAC_INPUT, val);\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t ad5758_read_powerdown(struct iio_dev *indio_dev,\n\t\t\t\t     uintptr_t priv,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     char *buf)\n{\n\tstruct ad5758_state *st = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", st->pwr_down);\n}\n\nstatic ssize_t ad5758_write_powerdown(struct iio_dev *indio_dev,\n\t\t\t\t      uintptr_t priv,\n\t\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct ad5758_state *st = iio_priv(indio_dev);\n\tbool pwr_down;\n\tunsigned int dac_config_mode, val;\n\tunsigned long int dac_config_msk;\n\tint ret;\n\n\tret = kstrtobool(buf, &pwr_down);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\tif (pwr_down)\n\t\tval = 0;\n\telse\n\t\tval = 1;\n\n\tdac_config_mode = AD5758_DAC_CONFIG_OUT_EN_MODE(val) |\n\t\t\t  AD5758_DAC_CONFIG_INT_EN_MODE(val);\n\tdac_config_msk = AD5758_DAC_CONFIG_OUT_EN_MSK |\n\t\t\t AD5758_DAC_CONFIG_INT_EN_MSK;\n\n\tret = ad5758_spi_write_mask(st, AD5758_DAC_CONFIG,\n\t\t\t\t    dac_config_msk,\n\t\t\t\t    dac_config_mode);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\tst->pwr_down = pwr_down;\n\nerr_unlock:\n\tmutex_unlock(&st->lock);\n\n\treturn ret ? ret : len;\n}\n\nstatic const struct iio_info ad5758_info = {\n\t.read_raw = ad5758_read_raw,\n\t.write_raw = ad5758_write_raw,\n\t.debugfs_reg_access = &ad5758_reg_access,\n};\n\nstatic const struct iio_chan_spec_ext_info ad5758_ext_info[] = {\n\t{\n\t\t.name = \"powerdown\",\n\t\t.read = ad5758_read_powerdown,\n\t\t.write = ad5758_write_powerdown,\n\t\t.shared = IIO_SHARED_BY_TYPE,\n\t},\n\t{ }\n};\n\n#define AD5758_DAC_CHAN(_chan_type) {\t\t\t\t\\\n\t.type = (_chan_type),\t\t\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_RAW) |\t\\\n\t\tBIT(IIO_CHAN_INFO_SCALE) |\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_OFFSET),\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\\\n\t.ext_info = ad5758_ext_info,\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec ad5758_voltage_ch[] = {\n\tAD5758_DAC_CHAN(IIO_VOLTAGE)\n};\n\nstatic const struct iio_chan_spec ad5758_current_ch[] = {\n\tAD5758_DAC_CHAN(IIO_CURRENT)\n};\n\nstatic bool ad5758_is_valid_mode(enum ad5758_dc_dc_mode mode)\n{\n\tswitch (mode) {\n\tcase AD5758_DCDC_MODE_DPC_CURRENT:\n\tcase AD5758_DCDC_MODE_DPC_VOLTAGE:\n\tcase AD5758_DCDC_MODE_PPC_CURRENT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int ad5758_crc_disable(struct ad5758_state *st)\n{\n\tunsigned int mask;\n\n\tmask = (AD5758_WR_FLAG_MSK(AD5758_DIGITAL_DIAG_CONFIG) << 24) | 0x5C3A;\n\tst->d32[0] = cpu_to_be32(mask);\n\n\treturn spi_write(st->spi, &st->d32[0], 4);\n}\n\nstatic int ad5758_find_out_range(struct ad5758_state *st,\n\t\t\t\t const struct ad5758_range *range,\n\t\t\t\t unsigned int size,\n\t\t\t\t int min, int max)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif ((min == range[i].min) && (max == range[i].max)) {\n\t\t\tst->out_range.reg = range[i].reg;\n\t\t\tst->out_range.min = range[i].min;\n\t\t\tst->out_range.max = range[i].max;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ad5758_parse_dt(struct ad5758_state *st)\n{\n\tunsigned int tmp, tmparray[2], size;\n\tconst struct ad5758_range *range;\n\tint *index, ret;\n\n\tst->dc_dc_ilim = 0;\n\tret = device_property_read_u32(&st->spi->dev,\n\t\t\t\t       \"adi,dc-dc-ilim-microamp\", &tmp);\n\tif (ret) {\n\t\tdev_dbg(&st->spi->dev,\n\t\t\t\"Missing \\\"dc-dc-ilim-microamp\\\" property\\n\");\n\t} else {\n\t\tindex = bsearch(&tmp, ad5758_dc_dc_ilim,\n\t\t\t\tARRAY_SIZE(ad5758_dc_dc_ilim),\n\t\t\t\tsizeof(int), cmpfunc);\n\t\tif (!index)\n\t\t\tdev_dbg(&st->spi->dev, \"dc-dc-ilim out of range\\n\");\n\t\telse\n\t\t\tst->dc_dc_ilim = index - ad5758_dc_dc_ilim;\n\t}\n\n\tret = device_property_read_u32(&st->spi->dev, \"adi,dc-dc-mode\",\n\t\t\t\t       &st->dc_dc_mode);\n\tif (ret) {\n\t\tdev_err(&st->spi->dev, \"Missing \\\"dc-dc-mode\\\" property\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!ad5758_is_valid_mode(st->dc_dc_mode))\n\t\treturn -EINVAL;\n\n\tif (st->dc_dc_mode == AD5758_DCDC_MODE_DPC_VOLTAGE) {\n\t\tret = device_property_read_u32_array(&st->spi->dev,\n\t\t\t\t\t\t     \"adi,range-microvolt\",\n\t\t\t\t\t\t     tmparray, 2);\n\t\tif (ret) {\n\t\t\tdev_err(&st->spi->dev,\n\t\t\t\t\"Missing \\\"range-microvolt\\\" property\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\trange = ad5758_voltage_range;\n\t\tsize = ARRAY_SIZE(ad5758_voltage_range);\n\t} else {\n\t\tret = device_property_read_u32_array(&st->spi->dev,\n\t\t\t\t\t\t     \"adi,range-microamp\",\n\t\t\t\t\t\t     tmparray, 2);\n\t\tif (ret) {\n\t\t\tdev_err(&st->spi->dev,\n\t\t\t\t\"Missing \\\"range-microamp\\\" property\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\trange = ad5758_current_range;\n\t\tsize = ARRAY_SIZE(ad5758_current_range);\n\t}\n\n\tret = ad5758_find_out_range(st, range, size, tmparray[0], tmparray[1]);\n\tif (ret) {\n\t\tdev_err(&st->spi->dev, \"range invalid\\n\");\n\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(&st->spi->dev, \"adi,slew-time-us\", &tmp);\n\tif (ret) {\n\t\tdev_dbg(&st->spi->dev, \"Missing \\\"slew-time-us\\\" property\\n\");\n\t\tst->slew_time = 0;\n\t} else {\n\t\tst->slew_time = tmp;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad5758_init(struct ad5758_state *st)\n{\n\tint regval, ret;\n\n\tst->gpio_reset = devm_gpiod_get_optional(&st->spi->dev, \"reset\",\n\t\t\t\t\t\t GPIOD_OUT_HIGH);\n\tif (IS_ERR(st->gpio_reset))\n\t\treturn PTR_ERR(st->gpio_reset);\n\n\t \n\tret = ad5758_crc_disable(st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ad5758_reset(st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ad5758_crc_disable(st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ad5758_calib_mem_refresh(st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregval = ad5758_spi_reg_read(st, AD5758_DIGITAL_DIAG_RESULTS);\n\tif (regval < 0)\n\t\treturn regval;\n\n\t \n\tret = ad5758_spi_reg_write(st, AD5758_DIGITAL_DIAG_RESULTS, regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ad5758_set_dc_dc_ilim(st, st->dc_dc_ilim);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ad5758_set_dc_dc_conv_mode(st, st->dc_dc_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ad5758_set_out_range(st, st->out_range.reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (st->slew_time) {\n\t\tret = ad5758_slew_rate_config(st);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = ad5758_internal_buffers_en(st, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn ad5758_spi_write_mask(st, AD5758_DAC_CONFIG,\n\t\t\t\t     AD5758_DAC_CONFIG_OUT_EN_MSK,\n\t\t\t\t     AD5758_DAC_CONFIG_OUT_EN_MODE(1));\n}\n\nstatic int ad5758_probe(struct spi_device *spi)\n{\n\tstruct ad5758_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tspi_set_drvdata(spi, indio_dev);\n\n\tst->spi = spi;\n\n\tmutex_init(&st->lock);\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->info = &ad5758_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->num_channels = 1;\n\n\tret = ad5758_parse_dt(st);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (st->dc_dc_mode == AD5758_DCDC_MODE_DPC_VOLTAGE)\n\t\tindio_dev->channels = ad5758_voltage_ch;\n\telse\n\t\tindio_dev->channels = ad5758_current_ch;\n\n\tret = ad5758_init(st);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"AD5758 init failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&st->spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad5758_id[] = {\n\t{ \"ad5758\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad5758_id);\n\nstatic const struct of_device_id ad5758_of_match[] = {\n        { .compatible = \"adi,ad5758\" },\n        { },\n};\nMODULE_DEVICE_TABLE(of, ad5758_of_match);\n\nstatic struct spi_driver ad5758_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = ad5758_of_match,\n\t},\n\t.probe = ad5758_probe,\n\t.id_table = ad5758_id,\n};\n\nmodule_spi_driver(ad5758_driver);\n\nMODULE_AUTHOR(\"Stefan Popa <stefan.popa@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5758 DAC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}