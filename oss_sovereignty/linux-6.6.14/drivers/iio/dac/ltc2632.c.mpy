{
  "module_name": "ltc2632.c",
  "hash_id": "ddaf584c77f017e3fb83e503bc7ae4e303b37bca40b6e2a1cb9cf8f90ab3f85e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ltc2632.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/spi/spi.h>\n#include <linux/module.h>\n#include <linux/iio/iio.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n\n#include <asm/unaligned.h>\n\n#define LTC2632_CMD_WRITE_INPUT_N               0x0\n#define LTC2632_CMD_UPDATE_DAC_N                0x1\n#define LTC2632_CMD_WRITE_INPUT_N_UPDATE_ALL    0x2\n#define LTC2632_CMD_WRITE_INPUT_N_UPDATE_N      0x3\n#define LTC2632_CMD_POWERDOWN_DAC_N             0x4\n#define LTC2632_CMD_POWERDOWN_CHIP              0x5\n#define LTC2632_CMD_INTERNAL_REFER              0x6\n#define LTC2632_CMD_EXTERNAL_REFER              0x7\n\n \nstruct ltc2632_chip_info {\n\tconst struct iio_chan_spec *channels;\n\tconst size_t num_channels;\n\tconst int vref_mv;\n};\n\n \nstruct ltc2632_state {\n\tstruct spi_device *spi_dev;\n\tunsigned int powerdown_cache_mask;\n\tint vref_mv;\n\tstruct regulator *vref_reg;\n};\n\nenum ltc2632_supported_device_ids {\n\tID_LTC2632L12,\n\tID_LTC2632L10,\n\tID_LTC2632L8,\n\tID_LTC2632H12,\n\tID_LTC2632H10,\n\tID_LTC2632H8,\n\tID_LTC2634L12,\n\tID_LTC2634L10,\n\tID_LTC2634L8,\n\tID_LTC2634H12,\n\tID_LTC2634H10,\n\tID_LTC2634H8,\n\tID_LTC2636L12,\n\tID_LTC2636L10,\n\tID_LTC2636L8,\n\tID_LTC2636H12,\n\tID_LTC2636H10,\n\tID_LTC2636H8,\n};\n\nstatic int ltc2632_spi_write(struct spi_device *spi,\n\t\t\t     u8 cmd, u8 addr, u16 val, u8 shift)\n{\n\tu32 data;\n\tu8 msg[3];\n\n\t \n\tdata = (cmd << 20) | (addr << 16) | (val << shift);\n\tput_unaligned_be24(data, &msg[0]);\n\n\treturn spi_write(spi, msg, sizeof(msg));\n}\n\nstatic int ltc2632_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val,\n\t\t\t    int *val2,\n\t\t\t    long m)\n{\n\tconst struct ltc2632_state *st = iio_priv(indio_dev);\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = st->vref_mv;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ltc2632_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val,\n\t\t\t     int val2,\n\t\t\t     long mask)\n{\n\tstruct ltc2632_state *st = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val >= (1 << chan->scan_type.realbits) || val < 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn ltc2632_spi_write(st->spi_dev,\n\t\t\t\t\t LTC2632_CMD_WRITE_INPUT_N_UPDATE_N,\n\t\t\t\t\t chan->address, val,\n\t\t\t\t\t chan->scan_type.shift);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t ltc2632_read_dac_powerdown(struct iio_dev *indio_dev,\n\t\t\t\t\t  uintptr_t private,\n\t\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t\t  char *buf)\n{\n\tstruct ltc2632_state *st = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  !!(st->powerdown_cache_mask & (1 << chan->channel)));\n}\n\nstatic ssize_t ltc2632_write_dac_powerdown(struct iio_dev *indio_dev,\n\t\t\t\t\t   uintptr_t private,\n\t\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t\t   const char *buf,\n\t\t\t\t\t   size_t len)\n{\n\tbool pwr_down;\n\tint ret;\n\tstruct ltc2632_state *st = iio_priv(indio_dev);\n\n\tret = kstrtobool(buf, &pwr_down);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pwr_down)\n\t\tst->powerdown_cache_mask |= (1 << chan->channel);\n\telse\n\t\tst->powerdown_cache_mask &= ~(1 << chan->channel);\n\n\tret = ltc2632_spi_write(st->spi_dev,\n\t\t\t\tLTC2632_CMD_POWERDOWN_DAC_N,\n\t\t\t\tchan->channel, 0, 0);\n\n\treturn ret ? ret : len;\n}\n\nstatic const struct iio_info ltc2632_info = {\n\t.write_raw\t= ltc2632_write_raw,\n\t.read_raw\t= ltc2632_read_raw,\n};\n\nstatic const struct iio_chan_spec_ext_info ltc2632_ext_info[] = {\n\t{\n\t\t.name = \"powerdown\",\n\t\t.read = ltc2632_read_dac_powerdown,\n\t\t.write = ltc2632_write_dac_powerdown,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\t{ },\n};\n\n#define LTC2632_CHANNEL(_chan, _bits) { \\\n\t\t.type = IIO_VOLTAGE, \\\n\t\t.indexed = 1, \\\n\t\t.output = 1, \\\n\t\t.channel = (_chan), \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t\t.address = (_chan), \\\n\t\t.scan_type = { \\\n\t\t\t.realbits\t= (_bits), \\\n\t\t\t.shift\t\t= 16 - (_bits), \\\n\t\t}, \\\n\t\t.ext_info = ltc2632_ext_info, \\\n}\n\n#define DECLARE_LTC2632_CHANNELS(_name, _bits) \\\n\tconst struct iio_chan_spec _name ## _channels[] = { \\\n\t\tLTC2632_CHANNEL(0, _bits), \\\n\t\tLTC2632_CHANNEL(1, _bits), \\\n\t\tLTC2632_CHANNEL(2, _bits), \\\n\t\tLTC2632_CHANNEL(3, _bits), \\\n\t\tLTC2632_CHANNEL(4, _bits), \\\n\t\tLTC2632_CHANNEL(5, _bits), \\\n\t\tLTC2632_CHANNEL(6, _bits), \\\n\t\tLTC2632_CHANNEL(7, _bits), \\\n\t}\n\nstatic DECLARE_LTC2632_CHANNELS(ltc2632x12, 12);\nstatic DECLARE_LTC2632_CHANNELS(ltc2632x10, 10);\nstatic DECLARE_LTC2632_CHANNELS(ltc2632x8, 8);\n\nstatic const struct ltc2632_chip_info ltc2632_chip_info_tbl[] = {\n\t[ID_LTC2632L12] = {\n\t\t.channels\t= ltc2632x12_channels,\n\t\t.num_channels\t= 2,\n\t\t.vref_mv\t= 2500,\n\t},\n\t[ID_LTC2632L10] = {\n\t\t.channels\t= ltc2632x10_channels,\n\t\t.num_channels\t= 2,\n\t\t.vref_mv\t= 2500,\n\t},\n\t[ID_LTC2632L8] =  {\n\t\t.channels\t= ltc2632x8_channels,\n\t\t.num_channels\t= 2,\n\t\t.vref_mv\t= 2500,\n\t},\n\t[ID_LTC2632H12] = {\n\t\t.channels\t= ltc2632x12_channels,\n\t\t.num_channels\t= 2,\n\t\t.vref_mv\t= 4096,\n\t},\n\t[ID_LTC2632H10] = {\n\t\t.channels\t= ltc2632x10_channels,\n\t\t.num_channels\t= 2,\n\t\t.vref_mv\t= 4096,\n\t},\n\t[ID_LTC2632H8] =  {\n\t\t.channels\t= ltc2632x8_channels,\n\t\t.num_channels\t= 2,\n\t\t.vref_mv\t= 4096,\n\t},\n\t[ID_LTC2634L12] = {\n\t\t.channels\t= ltc2632x12_channels,\n\t\t.num_channels\t= 4,\n\t\t.vref_mv\t= 2500,\n\t},\n\t[ID_LTC2634L10] = {\n\t\t.channels\t= ltc2632x10_channels,\n\t\t.num_channels\t= 4,\n\t\t.vref_mv\t= 2500,\n\t},\n\t[ID_LTC2634L8] =  {\n\t\t.channels\t= ltc2632x8_channels,\n\t\t.num_channels\t= 4,\n\t\t.vref_mv\t= 2500,\n\t},\n\t[ID_LTC2634H12] = {\n\t\t.channels\t= ltc2632x12_channels,\n\t\t.num_channels\t= 4,\n\t\t.vref_mv\t= 4096,\n\t},\n\t[ID_LTC2634H10] = {\n\t\t.channels\t= ltc2632x10_channels,\n\t\t.num_channels\t= 4,\n\t\t.vref_mv\t= 4096,\n\t},\n\t[ID_LTC2634H8] =  {\n\t\t.channels\t= ltc2632x8_channels,\n\t\t.num_channels\t= 4,\n\t\t.vref_mv\t= 4096,\n\t},\n\t[ID_LTC2636L12] = {\n\t\t.channels\t= ltc2632x12_channels,\n\t\t.num_channels\t= 8,\n\t\t.vref_mv\t= 2500,\n\t},\n\t[ID_LTC2636L10] = {\n\t\t.channels\t= ltc2632x10_channels,\n\t\t.num_channels\t= 8,\n\t\t.vref_mv\t= 2500,\n\t},\n\t[ID_LTC2636L8] =  {\n\t\t.channels\t= ltc2632x8_channels,\n\t\t.num_channels\t= 8,\n\t\t.vref_mv\t= 2500,\n\t},\n\t[ID_LTC2636H12] = {\n\t\t.channels\t= ltc2632x12_channels,\n\t\t.num_channels\t= 8,\n\t\t.vref_mv\t= 4096,\n\t},\n\t[ID_LTC2636H10] = {\n\t\t.channels\t= ltc2632x10_channels,\n\t\t.num_channels\t= 8,\n\t\t.vref_mv\t= 4096,\n\t},\n\t[ID_LTC2636H8] =  {\n\t\t.channels\t= ltc2632x8_channels,\n\t\t.num_channels\t= 8,\n\t\t.vref_mv\t= 4096,\n\t},\n};\n\nstatic int ltc2632_probe(struct spi_device *spi)\n{\n\tstruct ltc2632_state *st;\n\tstruct iio_dev *indio_dev;\n\tstruct ltc2632_chip_info *chip_info;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tspi_set_drvdata(spi, indio_dev);\n\tst->spi_dev = spi;\n\n\tchip_info = (struct ltc2632_chip_info *)\n\t\t\tspi_get_device_id(spi)->driver_data;\n\n\tst->vref_reg = devm_regulator_get_optional(&spi->dev, \"vref\");\n\tif (PTR_ERR(st->vref_reg) == -ENODEV) {\n\t\t \n\t\tst->vref_reg = NULL;\n\t\tst->vref_mv = chip_info->vref_mv;\n\n\t\tret = ltc2632_spi_write(spi, LTC2632_CMD_INTERNAL_REFER,\n\t\t\t\t0, 0, 0);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"Set internal reference command failed, %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t} else if (IS_ERR(st->vref_reg)) {\n\t\tdev_err(&spi->dev,\n\t\t\t\t\"Error getting voltage reference regulator\\n\");\n\t\treturn PTR_ERR(st->vref_reg);\n\t} else {\n\t\t \n\t\tret = regulator_enable(st->vref_reg);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"enable reference regulator failed, %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tst->vref_mv = regulator_get_voltage(st->vref_reg) / 1000;\n\n\t\tret = ltc2632_spi_write(spi, LTC2632_CMD_EXTERNAL_REFER,\n\t\t\t\t0, 0, 0);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"Set external reference command failed, %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tindio_dev->name = fwnode_get_name(dev_fwnode(&spi->dev)) ?: spi_get_device_id(spi)->name;\n\tindio_dev->info = &ltc2632_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = chip_info->channels;\n\tindio_dev->num_channels = chip_info->num_channels;\n\n\treturn iio_device_register(indio_dev);\n}\n\nstatic void ltc2632_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct ltc2632_state *st = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tif (st->vref_reg)\n\t\tregulator_disable(st->vref_reg);\n}\n\nstatic const struct spi_device_id ltc2632_id[] = {\n\t{ \"ltc2632-l12\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2632L12] },\n\t{ \"ltc2632-l10\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2632L10] },\n\t{ \"ltc2632-l8\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2632L8] },\n\t{ \"ltc2632-h12\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2632H12] },\n\t{ \"ltc2632-h10\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2632H10] },\n\t{ \"ltc2632-h8\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2632H8] },\n\t{ \"ltc2634-l12\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2634L12] },\n\t{ \"ltc2634-l10\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2634L10] },\n\t{ \"ltc2634-l8\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2634L8] },\n\t{ \"ltc2634-h12\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2634H12] },\n\t{ \"ltc2634-h10\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2634H10] },\n\t{ \"ltc2634-h8\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2634H8] },\n\t{ \"ltc2636-l12\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2636L12] },\n\t{ \"ltc2636-l10\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2636L10] },\n\t{ \"ltc2636-l8\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2636L8] },\n\t{ \"ltc2636-h12\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2636H12] },\n\t{ \"ltc2636-h10\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2636H10] },\n\t{ \"ltc2636-h8\", (kernel_ulong_t)&ltc2632_chip_info_tbl[ID_LTC2636H8] },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ltc2632_id);\n\nstatic const struct of_device_id ltc2632_of_match[] = {\n\t{\n\t\t.compatible = \"lltc,ltc2632-l12\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2632L12]\n\t}, {\n\t\t.compatible = \"lltc,ltc2632-l10\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2632L10]\n\t}, {\n\t\t.compatible = \"lltc,ltc2632-l8\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2632L8]\n\t}, {\n\t\t.compatible = \"lltc,ltc2632-h12\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2632H12]\n\t}, {\n\t\t.compatible = \"lltc,ltc2632-h10\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2632H10]\n\t}, {\n\t\t.compatible = \"lltc,ltc2632-h8\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2632H8]\n\t}, {\n\t\t.compatible = \"lltc,ltc2634-l12\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2634L12]\n\t}, {\n\t\t.compatible = \"lltc,ltc2634-l10\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2634L10]\n\t}, {\n\t\t.compatible = \"lltc,ltc2634-l8\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2634L8]\n\t}, {\n\t\t.compatible = \"lltc,ltc2634-h12\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2634H12]\n\t}, {\n\t\t.compatible = \"lltc,ltc2634-h10\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2634H10]\n\t}, {\n\t\t.compatible = \"lltc,ltc2634-h8\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2634H8]\n\t}, {\n\t\t.compatible = \"lltc,ltc2636-l12\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2636L12]\n\t}, {\n\t\t.compatible = \"lltc,ltc2636-l10\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2636L10]\n\t}, {\n\t\t.compatible = \"lltc,ltc2636-l8\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2636L8]\n\t}, {\n\t\t.compatible = \"lltc,ltc2636-h12\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2636H12]\n\t}, {\n\t\t.compatible = \"lltc,ltc2636-h10\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2636H10]\n\t}, {\n\t\t.compatible = \"lltc,ltc2636-h8\",\n\t\t.data = &ltc2632_chip_info_tbl[ID_LTC2636H8]\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ltc2632_of_match);\n\nstatic struct spi_driver ltc2632_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"ltc2632\",\n\t\t.of_match_table = ltc2632_of_match,\n\t},\n\t.probe\t\t= ltc2632_probe,\n\t.remove\t\t= ltc2632_remove,\n\t.id_table\t= ltc2632_id,\n};\nmodule_spi_driver(ltc2632_driver);\n\nMODULE_AUTHOR(\"Maxime Roussin-Belanger <maxime.roussinbelanger@gmail.com>\");\nMODULE_DESCRIPTION(\"LTC2632 DAC SPI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}