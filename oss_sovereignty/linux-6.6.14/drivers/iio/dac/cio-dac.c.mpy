{
  "module_name": "cio-dac.c",
  "hash_id": "14c5a38f9d2422a24b6ec39f18eb62bac39988572f517625f77dd53389f168c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/cio-dac.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/types.h>\n#include <linux/isa.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\n#define CIO_DAC_NUM_CHAN 16\n\n#define CIO_DAC_CHAN(chan) {\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t.channel = chan,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.output = 1\t\t\t\t\t\\\n}\n\n#define CIO_DAC_EXTENT 32\n\nstatic unsigned int base[max_num_isa_dev(CIO_DAC_EXTENT)];\nstatic unsigned int num_cio_dac;\nmodule_param_hw_array(base, uint, ioport, &num_cio_dac, 0);\nMODULE_PARM_DESC(base, \"Measurement Computing CIO-DAC base addresses\");\n\n#define CIO_DAC_BASE 0x00\n#define CIO_DAC_CHANNEL_STRIDE 2\n\nstatic bool cio_dac_precious_reg(struct device *dev, unsigned int reg)\n{\n\t \n\treturn true;\n}\n\nstatic const struct regmap_config cio_dac_regmap_config = {\n\t.reg_bits = 16,\n\t.reg_stride = 2,\n\t.val_bits = 16,\n\t.io_port = true,\n\t.max_register = 0x1F,\n\t.precious_reg = cio_dac_precious_reg,\n};\n\n \nstruct cio_dac_iio {\n\tstruct regmap *map;\n};\n\nstatic int cio_dac_read_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int *val, int *val2, long mask)\n{\n\tstruct cio_dac_iio *const priv = iio_priv(indio_dev);\n\tconst unsigned int offset = chan->channel * CIO_DAC_CHANNEL_STRIDE;\n\tint err;\n\tunsigned int dac_val;\n\n\tif (mask != IIO_CHAN_INFO_RAW)\n\t\treturn -EINVAL;\n\n\terr = regmap_read(priv->map, CIO_DAC_BASE + offset, &dac_val);\n\tif (err)\n\t\treturn err;\n\n\t*val = dac_val;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int cio_dac_write_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int val, int val2, long mask)\n{\n\tstruct cio_dac_iio *const priv = iio_priv(indio_dev);\n\tconst unsigned int offset = chan->channel * CIO_DAC_CHANNEL_STRIDE;\n\n\tif (mask != IIO_CHAN_INFO_RAW)\n\t\treturn -EINVAL;\n\n\t \n\tif ((unsigned int)val > 4095)\n\t\treturn -EINVAL;\n\n\treturn regmap_write(priv->map, CIO_DAC_BASE + offset, val);\n}\n\nstatic const struct iio_info cio_dac_info = {\n\t.read_raw = cio_dac_read_raw,\n\t.write_raw = cio_dac_write_raw\n};\n\nstatic const struct iio_chan_spec cio_dac_channels[CIO_DAC_NUM_CHAN] = {\n\tCIO_DAC_CHAN(0), CIO_DAC_CHAN(1), CIO_DAC_CHAN(2), CIO_DAC_CHAN(3),\n\tCIO_DAC_CHAN(4), CIO_DAC_CHAN(5), CIO_DAC_CHAN(6), CIO_DAC_CHAN(7),\n\tCIO_DAC_CHAN(8), CIO_DAC_CHAN(9), CIO_DAC_CHAN(10), CIO_DAC_CHAN(11),\n\tCIO_DAC_CHAN(12), CIO_DAC_CHAN(13), CIO_DAC_CHAN(14), CIO_DAC_CHAN(15)\n};\n\nstatic int cio_dac_probe(struct device *dev, unsigned int id)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct cio_dac_iio *priv;\n\tvoid __iomem *regs;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*priv));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tif (!devm_request_region(dev, base[id], CIO_DAC_EXTENT,\n\t\tdev_name(dev))) {\n\t\tdev_err(dev, \"Unable to request port addresses (0x%X-0x%X)\\n\",\n\t\t\tbase[id], base[id] + CIO_DAC_EXTENT);\n\t\treturn -EBUSY;\n\t}\n\n\tregs = devm_ioport_map(dev, base[id], CIO_DAC_EXTENT);\n\tif (!regs)\n\t\treturn -ENOMEM;\n\n\tpriv = iio_priv(indio_dev);\n\tpriv->map = devm_regmap_init_mmio(dev, regs, &cio_dac_regmap_config);\n\tif (IS_ERR(priv->map))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->map),\n\t\t\t\t     \"Unable to initialize register map\\n\");\n\n\tindio_dev->info = &cio_dac_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = cio_dac_channels;\n\tindio_dev->num_channels = CIO_DAC_NUM_CHAN;\n\tindio_dev->name = dev_name(dev);\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic struct isa_driver cio_dac_driver = {\n\t.probe = cio_dac_probe,\n\t.driver = {\n\t\t.name = \"cio-dac\"\n\t}\n};\n\nmodule_isa_driver(cio_dac_driver, num_cio_dac);\n\nMODULE_AUTHOR(\"William Breathitt Gray <vilhelm.gray@gmail.com>\");\nMODULE_DESCRIPTION(\"Measurement Computing CIO-DAC IIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}