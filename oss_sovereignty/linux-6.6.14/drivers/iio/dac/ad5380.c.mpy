{
  "module_name": "ad5380.c",
  "hash_id": "685172809ca8cad6ceafef7ea0b56defe5c1b77374cb474130502052145553ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad5380.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define AD5380_REG_DATA(x)\t(((x) << 2) | 3)\n#define AD5380_REG_OFFSET(x)\t(((x) << 2) | 2)\n#define AD5380_REG_GAIN(x)\t(((x) << 2) | 1)\n#define AD5380_REG_SF_PWR_DOWN\t(8 << 2)\n#define AD5380_REG_SF_PWR_UP\t(9 << 2)\n#define AD5380_REG_SF_CTRL\t(12 << 2)\n\n#define AD5380_CTRL_PWR_DOWN_MODE_OFFSET\t13\n#define AD5380_CTRL_INT_VREF_2V5\t\tBIT(12)\n#define AD5380_CTRL_INT_VREF_EN\t\t\tBIT(10)\n\n \nstruct ad5380_chip_info {\n\tstruct iio_chan_spec\tchannel_template;\n\tunsigned int\t\tnum_channels;\n\tunsigned int\t\tint_vref;\n};\n\n \nstruct ad5380_state {\n\tstruct regmap\t\t\t*regmap;\n\tconst struct ad5380_chip_info\t*chip_info;\n\tstruct regulator\t\t*vref_reg;\n\tint\t\t\t\tvref;\n\tbool\t\t\t\tpwr_down;\n\tstruct mutex\t\t\tlock;\n};\n\nenum ad5380_type {\n\tID_AD5380_3,\n\tID_AD5380_5,\n\tID_AD5381_3,\n\tID_AD5381_5,\n\tID_AD5382_3,\n\tID_AD5382_5,\n\tID_AD5383_3,\n\tID_AD5383_5,\n\tID_AD5390_3,\n\tID_AD5390_5,\n\tID_AD5391_3,\n\tID_AD5391_5,\n\tID_AD5392_3,\n\tID_AD5392_5,\n};\n\nstatic ssize_t ad5380_read_dac_powerdown(struct iio_dev *indio_dev,\n\tuintptr_t private, const struct iio_chan_spec *chan, char *buf)\n{\n\tstruct ad5380_state *st = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", st->pwr_down);\n}\n\nstatic ssize_t ad5380_write_dac_powerdown(struct iio_dev *indio_dev,\n\t uintptr_t private, const struct iio_chan_spec *chan, const char *buf,\n\t size_t len)\n{\n\tstruct ad5380_state *st = iio_priv(indio_dev);\n\tbool pwr_down;\n\tint ret;\n\n\tret = kstrtobool(buf, &pwr_down);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\n\tif (pwr_down)\n\t\tret = regmap_write(st->regmap, AD5380_REG_SF_PWR_DOWN, 0);\n\telse\n\t\tret = regmap_write(st->regmap, AD5380_REG_SF_PWR_UP, 0);\n\n\tst->pwr_down = pwr_down;\n\n\tmutex_unlock(&st->lock);\n\n\treturn ret ? ret : len;\n}\n\nstatic const char * const ad5380_powerdown_modes[] = {\n\t\"100kohm_to_gnd\",\n\t\"three_state\",\n};\n\nstatic int ad5380_get_powerdown_mode(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan)\n{\n\tstruct ad5380_state *st = iio_priv(indio_dev);\n\tunsigned int mode;\n\tint ret;\n\n\tret = regmap_read(st->regmap, AD5380_REG_SF_CTRL, &mode);\n\tif (ret)\n\t\treturn ret;\n\n\tmode = (mode >> AD5380_CTRL_PWR_DOWN_MODE_OFFSET) & 1;\n\n\treturn mode;\n}\n\nstatic int ad5380_set_powerdown_mode(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, unsigned int mode)\n{\n\tstruct ad5380_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regmap_update_bits(st->regmap, AD5380_REG_SF_CTRL,\n\t\t1 << AD5380_CTRL_PWR_DOWN_MODE_OFFSET,\n\t\tmode << AD5380_CTRL_PWR_DOWN_MODE_OFFSET);\n\n\treturn ret;\n}\n\nstatic const struct iio_enum ad5380_powerdown_mode_enum = {\n\t.items = ad5380_powerdown_modes,\n\t.num_items = ARRAY_SIZE(ad5380_powerdown_modes),\n\t.get = ad5380_get_powerdown_mode,\n\t.set = ad5380_set_powerdown_mode,\n};\n\nstatic unsigned int ad5380_info_to_reg(struct iio_chan_spec const *chan,\n\tlong info)\n{\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn AD5380_REG_DATA(chan->address);\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treturn AD5380_REG_OFFSET(chan->address);\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\treturn AD5380_REG_GAIN(chan->address);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad5380_write_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int val, int val2, long info)\n{\n\tconst unsigned int max_val = (1 << chan->scan_type.realbits);\n\tstruct ad5380_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (val >= max_val || val < 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn regmap_write(st->regmap,\n\t\t\tad5380_info_to_reg(chan, info),\n\t\t\tval << chan->scan_type.shift);\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tval += (1 << chan->scan_type.realbits) / 2;\n\t\tif (val >= max_val || val < 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn regmap_write(st->regmap,\n\t\t\tAD5380_REG_OFFSET(chan->address),\n\t\t\tval << chan->scan_type.shift);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ad5380_read_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int *val, int *val2, long info)\n{\n\tstruct ad5380_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tret = regmap_read(st->regmap, ad5380_info_to_reg(chan, info),\n\t\t\t\t\tval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*val >>= chan->scan_type.shift;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = regmap_read(st->regmap, AD5380_REG_OFFSET(chan->address),\n\t\t\t\t\tval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*val >>= chan->scan_type.shift;\n\t\t*val -= (1 << chan->scan_type.realbits) / 2;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 2 * st->vref;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info ad5380_info = {\n\t.read_raw = ad5380_read_raw,\n\t.write_raw = ad5380_write_raw,\n};\n\nstatic const struct iio_chan_spec_ext_info ad5380_ext_info[] = {\n\t{\n\t\t.name = \"powerdown\",\n\t\t.read = ad5380_read_dac_powerdown,\n\t\t.write = ad5380_write_dac_powerdown,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\tIIO_ENUM(\"powerdown_mode\", IIO_SHARED_BY_TYPE,\n\t\t &ad5380_powerdown_mode_enum),\n\tIIO_ENUM_AVAILABLE(\"powerdown_mode\", IIO_SHARED_BY_TYPE, &ad5380_powerdown_mode_enum),\n\t{ },\n};\n\n#define AD5380_CHANNEL(_bits) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) |\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = (_bits),\t\t\t\t\\\n\t\t.storagebits =  16,\t\t\t\t\\\n\t\t.shift = 14 - (_bits),\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.ext_info = ad5380_ext_info,\t\t\t\t\\\n}\n\nstatic const struct ad5380_chip_info ad5380_chip_info_tbl[] = {\n\t[ID_AD5380_3] = {\n\t\t.channel_template = AD5380_CHANNEL(14),\n\t\t.num_channels = 40,\n\t\t.int_vref = 1250,\n\t},\n\t[ID_AD5380_5] = {\n\t\t.channel_template = AD5380_CHANNEL(14),\n\t\t.num_channels = 40,\n\t\t.int_vref = 2500,\n\t},\n\t[ID_AD5381_3] = {\n\t\t.channel_template = AD5380_CHANNEL(12),\n\t\t.num_channels = 16,\n\t\t.int_vref = 1250,\n\t},\n\t[ID_AD5381_5] = {\n\t\t.channel_template = AD5380_CHANNEL(12),\n\t\t.num_channels = 16,\n\t\t.int_vref = 2500,\n\t},\n\t[ID_AD5382_3] = {\n\t\t.channel_template = AD5380_CHANNEL(14),\n\t\t.num_channels = 32,\n\t\t.int_vref = 1250,\n\t},\n\t[ID_AD5382_5] = {\n\t\t.channel_template = AD5380_CHANNEL(14),\n\t\t.num_channels = 32,\n\t\t.int_vref = 2500,\n\t},\n\t[ID_AD5383_3] = {\n\t\t.channel_template = AD5380_CHANNEL(12),\n\t\t.num_channels = 32,\n\t\t.int_vref = 1250,\n\t},\n\t[ID_AD5383_5] = {\n\t\t.channel_template = AD5380_CHANNEL(12),\n\t\t.num_channels = 32,\n\t\t.int_vref = 2500,\n\t},\n\t[ID_AD5390_3] = {\n\t\t.channel_template = AD5380_CHANNEL(14),\n\t\t.num_channels = 16,\n\t\t.int_vref = 1250,\n\t},\n\t[ID_AD5390_5] = {\n\t\t.channel_template = AD5380_CHANNEL(14),\n\t\t.num_channels = 16,\n\t\t.int_vref = 2500,\n\t},\n\t[ID_AD5391_3] = {\n\t\t.channel_template = AD5380_CHANNEL(12),\n\t\t.num_channels = 16,\n\t\t.int_vref = 1250,\n\t},\n\t[ID_AD5391_5] = {\n\t\t.channel_template = AD5380_CHANNEL(12),\n\t\t.num_channels = 16,\n\t\t.int_vref = 2500,\n\t},\n\t[ID_AD5392_3] = {\n\t\t.channel_template = AD5380_CHANNEL(14),\n\t\t.num_channels = 8,\n\t\t.int_vref = 1250,\n\t},\n\t[ID_AD5392_5] = {\n\t\t.channel_template = AD5380_CHANNEL(14),\n\t\t.num_channels = 8,\n\t\t.int_vref = 2500,\n\t},\n};\n\nstatic int ad5380_alloc_channels(struct iio_dev *indio_dev)\n{\n\tstruct ad5380_state *st = iio_priv(indio_dev);\n\tstruct iio_chan_spec *channels;\n\tunsigned int i;\n\n\tchannels = kcalloc(st->chip_info->num_channels,\n\t\t\t   sizeof(struct iio_chan_spec), GFP_KERNEL);\n\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < st->chip_info->num_channels; ++i) {\n\t\tchannels[i] = st->chip_info->channel_template;\n\t\tchannels[i].channel = i;\n\t\tchannels[i].address = i;\n\t}\n\n\tindio_dev->channels = channels;\n\n\treturn 0;\n}\n\nstatic int ad5380_probe(struct device *dev, struct regmap *regmap,\n\t\t\tenum ad5380_type type, const char *name)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct ad5380_state *st;\n\tunsigned int ctrl = 0;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (indio_dev == NULL) {\n\t\tdev_err(dev, \"Failed to allocate iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tst = iio_priv(indio_dev);\n\tdev_set_drvdata(dev, indio_dev);\n\n\tst->chip_info = &ad5380_chip_info_tbl[type];\n\tst->regmap = regmap;\n\n\tindio_dev->name = name;\n\tindio_dev->info = &ad5380_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->num_channels = st->chip_info->num_channels;\n\n\tmutex_init(&st->lock);\n\n\tret = ad5380_alloc_channels(indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to allocate channel spec: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (st->chip_info->int_vref == 2500)\n\t\tctrl |= AD5380_CTRL_INT_VREF_2V5;\n\n\tst->vref_reg = devm_regulator_get(dev, \"vref\");\n\tif (!IS_ERR(st->vref_reg)) {\n\t\tret = regulator_enable(st->vref_reg);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable vref regulators: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto error_free_reg;\n\t\t}\n\n\t\tret = regulator_get_voltage(st->vref_reg);\n\t\tif (ret < 0)\n\t\t\tgoto error_disable_reg;\n\n\t\tst->vref = ret / 1000;\n\t} else {\n\t\tst->vref = st->chip_info->int_vref;\n\t\tctrl |= AD5380_CTRL_INT_VREF_EN;\n\t}\n\n\tret = regmap_write(st->regmap, AD5380_REG_SF_CTRL, ctrl);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to write to device: %d\\n\", ret);\n\t\tgoto error_disable_reg;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register iio device: %d\\n\", ret);\n\t\tgoto error_disable_reg;\n\t}\n\n\treturn 0;\n\nerror_disable_reg:\n\tif (!IS_ERR(st->vref_reg))\n\t\tregulator_disable(st->vref_reg);\nerror_free_reg:\n\tkfree(indio_dev->channels);\n\n\treturn ret;\n}\n\nstatic void ad5380_remove(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct ad5380_state *st = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tkfree(indio_dev->channels);\n\n\tif (!IS_ERR(st->vref_reg))\n\t\tregulator_disable(st->vref_reg);\n}\n\nstatic bool ad5380_reg_false(struct device *dev, unsigned int reg)\n{\n\treturn false;\n}\n\nstatic const struct regmap_config ad5380_regmap_config = {\n\t.reg_bits = 10,\n\t.val_bits = 14,\n\n\t.max_register = AD5380_REG_DATA(40),\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.volatile_reg = ad5380_reg_false,\n\t.readable_reg = ad5380_reg_false,\n};\n\n#if IS_ENABLED(CONFIG_SPI_MASTER)\n\nstatic int ad5380_spi_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tstruct regmap *regmap;\n\n\tregmap = devm_regmap_init_spi(spi, &ad5380_regmap_config);\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn ad5380_probe(&spi->dev, regmap, id->driver_data, id->name);\n}\n\nstatic void ad5380_spi_remove(struct spi_device *spi)\n{\n\tad5380_remove(&spi->dev);\n}\n\nstatic const struct spi_device_id ad5380_spi_ids[] = {\n\t{ \"ad5380-3\", ID_AD5380_3 },\n\t{ \"ad5380-5\", ID_AD5380_5 },\n\t{ \"ad5381-3\", ID_AD5381_3 },\n\t{ \"ad5381-5\", ID_AD5381_5 },\n\t{ \"ad5382-3\", ID_AD5382_3 },\n\t{ \"ad5382-5\", ID_AD5382_5 },\n\t{ \"ad5383-3\", ID_AD5383_3 },\n\t{ \"ad5383-5\", ID_AD5383_5 },\n\t{ \"ad5384-3\", ID_AD5380_3 },\n\t{ \"ad5384-5\", ID_AD5380_5 },\n\t{ \"ad5390-3\", ID_AD5390_3 },\n\t{ \"ad5390-5\", ID_AD5390_5 },\n\t{ \"ad5391-3\", ID_AD5391_3 },\n\t{ \"ad5391-5\", ID_AD5391_5 },\n\t{ \"ad5392-3\", ID_AD5392_3 },\n\t{ \"ad5392-5\", ID_AD5392_5 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, ad5380_spi_ids);\n\nstatic struct spi_driver ad5380_spi_driver = {\n\t.driver = {\n\t\t   .name = \"ad5380\",\n\t},\n\t.probe = ad5380_spi_probe,\n\t.remove = ad5380_spi_remove,\n\t.id_table = ad5380_spi_ids,\n};\n\nstatic inline int ad5380_spi_register_driver(void)\n{\n\treturn spi_register_driver(&ad5380_spi_driver);\n}\n\nstatic inline void ad5380_spi_unregister_driver(void)\n{\n\tspi_unregister_driver(&ad5380_spi_driver);\n}\n\n#else\n\nstatic inline int ad5380_spi_register_driver(void)\n{\n\treturn 0;\n}\n\nstatic inline void ad5380_spi_unregister_driver(void)\n{\n}\n\n#endif\n\n#if IS_ENABLED(CONFIG_I2C)\n\nstatic int ad5380_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tstruct regmap *regmap;\n\n\tregmap = devm_regmap_init_i2c(i2c, &ad5380_regmap_config);\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn ad5380_probe(&i2c->dev, regmap, id->driver_data, id->name);\n}\n\nstatic void ad5380_i2c_remove(struct i2c_client *i2c)\n{\n\tad5380_remove(&i2c->dev);\n}\n\nstatic const struct i2c_device_id ad5380_i2c_ids[] = {\n\t{ \"ad5380-3\", ID_AD5380_3 },\n\t{ \"ad5380-5\", ID_AD5380_5 },\n\t{ \"ad5381-3\", ID_AD5381_3 },\n\t{ \"ad5381-5\", ID_AD5381_5 },\n\t{ \"ad5382-3\", ID_AD5382_3 },\n\t{ \"ad5382-5\", ID_AD5382_5 },\n\t{ \"ad5383-3\", ID_AD5383_3 },\n\t{ \"ad5383-5\", ID_AD5383_5 },\n\t{ \"ad5384-3\", ID_AD5380_3 },\n\t{ \"ad5384-5\", ID_AD5380_5 },\n\t{ \"ad5390-3\", ID_AD5390_3 },\n\t{ \"ad5390-5\", ID_AD5390_5 },\n\t{ \"ad5391-3\", ID_AD5391_3 },\n\t{ \"ad5391-5\", ID_AD5391_5 },\n\t{ \"ad5392-3\", ID_AD5392_3 },\n\t{ \"ad5392-5\", ID_AD5392_5 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ad5380_i2c_ids);\n\nstatic struct i2c_driver ad5380_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"ad5380\",\n\t},\n\t.probe = ad5380_i2c_probe,\n\t.remove = ad5380_i2c_remove,\n\t.id_table = ad5380_i2c_ids,\n};\n\nstatic inline int ad5380_i2c_register_driver(void)\n{\n\treturn i2c_add_driver(&ad5380_i2c_driver);\n}\n\nstatic inline void ad5380_i2c_unregister_driver(void)\n{\n\ti2c_del_driver(&ad5380_i2c_driver);\n}\n\n#else\n\nstatic inline int ad5380_i2c_register_driver(void)\n{\n\treturn 0;\n}\n\nstatic inline void ad5380_i2c_unregister_driver(void)\n{\n}\n\n#endif\n\nstatic int __init ad5380_spi_init(void)\n{\n\tint ret;\n\n\tret = ad5380_spi_register_driver();\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad5380_i2c_register_driver();\n\tif (ret) {\n\t\tad5380_spi_unregister_driver();\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(ad5380_spi_init);\n\nstatic void __exit ad5380_spi_exit(void)\n{\n\tad5380_i2c_unregister_driver();\n\tad5380_spi_unregister_driver();\n\n}\nmodule_exit(ad5380_spi_exit);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5380/81/82/83/84/90/91/92 DAC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}