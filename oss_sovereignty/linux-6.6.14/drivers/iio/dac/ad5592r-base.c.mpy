{
  "module_name": "ad5592r-base.c",
  "hash_id": "9f9b3ea7abe8bd8da4ca92b422c138d3e6f27119702a2a1cd49c199fc4a26329",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad5592r-base.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/property.h>\n\n#include <dt-bindings/iio/adi,ad5592r.h>\n\n#include \"ad5592r-base.h\"\n\nstatic int ad5592r_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct ad5592r_state *st = gpiochip_get_data(chip);\n\tint ret = 0;\n\tu8 val;\n\n\tmutex_lock(&st->gpio_lock);\n\n\tif (st->gpio_out & BIT(offset))\n\t\tval = st->gpio_val;\n\telse\n\t\tret = st->ops->gpio_read(st, &val);\n\n\tmutex_unlock(&st->gpio_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(val & BIT(offset));\n}\n\nstatic void ad5592r_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct ad5592r_state *st = gpiochip_get_data(chip);\n\n\tmutex_lock(&st->gpio_lock);\n\n\tif (value)\n\t\tst->gpio_val |= BIT(offset);\n\telse\n\t\tst->gpio_val &= ~BIT(offset);\n\n\tst->ops->reg_write(st, AD5592R_REG_GPIO_SET, st->gpio_val);\n\n\tmutex_unlock(&st->gpio_lock);\n}\n\nstatic int ad5592r_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct ad5592r_state *st = gpiochip_get_data(chip);\n\tint ret;\n\n\tmutex_lock(&st->gpio_lock);\n\n\tst->gpio_out &= ~BIT(offset);\n\tst->gpio_in |= BIT(offset);\n\n\tret = st->ops->reg_write(st, AD5592R_REG_GPIO_OUT_EN, st->gpio_out);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\tret = st->ops->reg_write(st, AD5592R_REG_GPIO_IN_EN, st->gpio_in);\n\nerr_unlock:\n\tmutex_unlock(&st->gpio_lock);\n\n\treturn ret;\n}\n\nstatic int ad5592r_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t unsigned offset, int value)\n{\n\tstruct ad5592r_state *st = gpiochip_get_data(chip);\n\tint ret;\n\n\tmutex_lock(&st->gpio_lock);\n\n\tif (value)\n\t\tst->gpio_val |= BIT(offset);\n\telse\n\t\tst->gpio_val &= ~BIT(offset);\n\n\tst->gpio_in &= ~BIT(offset);\n\tst->gpio_out |= BIT(offset);\n\n\tret = st->ops->reg_write(st, AD5592R_REG_GPIO_SET, st->gpio_val);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\tret = st->ops->reg_write(st, AD5592R_REG_GPIO_OUT_EN, st->gpio_out);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\tret = st->ops->reg_write(st, AD5592R_REG_GPIO_IN_EN, st->gpio_in);\n\nerr_unlock:\n\tmutex_unlock(&st->gpio_lock);\n\n\treturn ret;\n}\n\nstatic int ad5592r_gpio_request(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct ad5592r_state *st = gpiochip_get_data(chip);\n\n\tif (!(st->gpio_map & BIT(offset))) {\n\t\tdev_err(st->dev, \"GPIO %d is reserved by alternate function\\n\",\n\t\t\toffset);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic const char * const ad5592r_gpio_names[] = {\n\t\"GPIO0\", \"GPIO1\", \"GPIO2\", \"GPIO3\", \"GPIO4\", \"GPIO5\", \"GPIO6\", \"GPIO7\",\n};\n\nstatic int ad5592r_gpio_init(struct ad5592r_state *st)\n{\n\tif (!st->gpio_map)\n\t\treturn 0;\n\n\tst->gpiochip.label = dev_name(st->dev);\n\tst->gpiochip.base = -1;\n\tst->gpiochip.ngpio = 8;\n\tst->gpiochip.parent = st->dev;\n\tst->gpiochip.can_sleep = true;\n\tst->gpiochip.direction_input = ad5592r_gpio_direction_input;\n\tst->gpiochip.direction_output = ad5592r_gpio_direction_output;\n\tst->gpiochip.get = ad5592r_gpio_get;\n\tst->gpiochip.set = ad5592r_gpio_set;\n\tst->gpiochip.request = ad5592r_gpio_request;\n\tst->gpiochip.owner = THIS_MODULE;\n\tst->gpiochip.names = ad5592r_gpio_names;\n\n\tmutex_init(&st->gpio_lock);\n\n\treturn gpiochip_add_data(&st->gpiochip, st);\n}\n\nstatic void ad5592r_gpio_cleanup(struct ad5592r_state *st)\n{\n\tif (st->gpio_map)\n\t\tgpiochip_remove(&st->gpiochip);\n}\n\nstatic int ad5592r_reset(struct ad5592r_state *st)\n{\n\tstruct gpio_desc *gpio;\n\n\tgpio = devm_gpiod_get_optional(st->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpio))\n\t\treturn PTR_ERR(gpio);\n\n\tif (gpio) {\n\t\tudelay(1);\n\t\tgpiod_set_value(gpio, 1);\n\t} else {\n\t\tmutex_lock(&st->lock);\n\t\t \n\t\tst->ops->reg_write(st, AD5592R_REG_RESET, 0xdac);\n\t\tmutex_unlock(&st->lock);\n\t}\n\n\tudelay(250);\n\n\treturn 0;\n}\n\nstatic int ad5592r_get_vref(struct ad5592r_state *st)\n{\n\tint ret;\n\n\tif (st->reg) {\n\t\tret = regulator_get_voltage(st->reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn ret / 1000;\n\t} else {\n\t\treturn 2500;\n\t}\n}\n\nstatic int ad5592r_set_channel_modes(struct ad5592r_state *st)\n{\n\tconst struct ad5592r_rw_ops *ops = st->ops;\n\tint ret;\n\tunsigned i;\n\tu8 pulldown = 0, tristate = 0, dac = 0, adc = 0;\n\tu16 read_back;\n\n\tfor (i = 0; i < st->num_channels; i++) {\n\t\tswitch (st->channel_modes[i]) {\n\t\tcase CH_MODE_DAC:\n\t\t\tdac |= BIT(i);\n\t\t\tbreak;\n\n\t\tcase CH_MODE_ADC:\n\t\t\tadc |= BIT(i);\n\t\t\tbreak;\n\n\t\tcase CH_MODE_DAC_AND_ADC:\n\t\t\tdac |= BIT(i);\n\t\t\tadc |= BIT(i);\n\t\t\tbreak;\n\n\t\tcase CH_MODE_GPIO:\n\t\t\tst->gpio_map |= BIT(i);\n\t\t\tst->gpio_in |= BIT(i);  \n\t\t\tbreak;\n\n\t\tcase CH_MODE_UNUSED:\n\t\tdefault:\n\t\t\tswitch (st->channel_offstate[i]) {\n\t\t\tcase CH_OFFSTATE_OUT_TRISTATE:\n\t\t\t\ttristate |= BIT(i);\n\t\t\t\tbreak;\n\n\t\t\tcase CH_OFFSTATE_OUT_LOW:\n\t\t\t\tst->gpio_out |= BIT(i);\n\t\t\t\tbreak;\n\n\t\t\tcase CH_OFFSTATE_OUT_HIGH:\n\t\t\t\tst->gpio_out |= BIT(i);\n\t\t\t\tst->gpio_val |= BIT(i);\n\t\t\t\tbreak;\n\n\t\t\tcase CH_OFFSTATE_PULLDOWN:\n\t\t\tdefault:\n\t\t\t\tpulldown |= BIT(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_lock(&st->lock);\n\n\t \n\tret = ops->reg_write(st, AD5592R_REG_PULLDOWN, pulldown);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tret = ops->reg_write(st, AD5592R_REG_TRISTATE, tristate);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\t \n\tret = ops->reg_write(st, AD5592R_REG_DAC_EN, dac);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tret = ops->reg_write(st, AD5592R_REG_ADC_EN, adc);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tret = ops->reg_write(st, AD5592R_REG_GPIO_SET, st->gpio_val);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tret = ops->reg_write(st, AD5592R_REG_GPIO_OUT_EN, st->gpio_out);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tret = ops->reg_write(st, AD5592R_REG_GPIO_IN_EN, st->gpio_in);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\t \n\tret = ops->reg_read(st, AD5592R_REG_ADC_EN, &read_back);\n\tif (!ret && (read_back & 0xff) != adc)\n\t\tret = -EIO;\n\nerr_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic int ad5592r_reset_channel_modes(struct ad5592r_state *st)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(st->channel_modes); i++)\n\t\tst->channel_modes[i] = CH_MODE_UNUSED;\n\n\treturn ad5592r_set_channel_modes(st);\n}\n\nstatic int ad5592r_write_raw(struct iio_dev *iio_dev,\n\tstruct iio_chan_spec const *chan, int val, int val2, long mask)\n{\n\tstruct ad5592r_state *st = iio_priv(iio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\n\t\tif (val >= (1 << chan->scan_type.realbits) || val < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (!chan->output)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&st->lock);\n\t\tret = st->ops->write_dac(st, chan->channel, val);\n\t\tif (!ret)\n\t\t\tst->cached_dac[chan->channel] = val;\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type == IIO_VOLTAGE) {\n\t\t\tbool gain;\n\n\t\t\tif (val == st->scale_avail[0][0] &&\n\t\t\t\tval2 == st->scale_avail[0][1])\n\t\t\t\tgain = false;\n\t\t\telse if (val == st->scale_avail[1][0] &&\n\t\t\t\t val2 == st->scale_avail[1][1])\n\t\t\t\tgain = true;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmutex_lock(&st->lock);\n\n\t\t\tret = st->ops->reg_read(st, AD5592R_REG_CTRL,\n\t\t\t\t\t\t&st->cached_gp_ctrl);\n\t\t\tif (ret < 0) {\n\t\t\t\tmutex_unlock(&st->lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (chan->output) {\n\t\t\t\tif (gain)\n\t\t\t\t\tst->cached_gp_ctrl |=\n\t\t\t\t\t\tAD5592R_REG_CTRL_DAC_RANGE;\n\t\t\t\telse\n\t\t\t\t\tst->cached_gp_ctrl &=\n\t\t\t\t\t\t~AD5592R_REG_CTRL_DAC_RANGE;\n\t\t\t} else {\n\t\t\t\tif (gain)\n\t\t\t\t\tst->cached_gp_ctrl |=\n\t\t\t\t\t\tAD5592R_REG_CTRL_ADC_RANGE;\n\t\t\t\telse\n\t\t\t\t\tst->cached_gp_ctrl &=\n\t\t\t\t\t\t~AD5592R_REG_CTRL_ADC_RANGE;\n\t\t\t}\n\n\t\t\tret = st->ops->reg_write(st, AD5592R_REG_CTRL,\n\t\t\t\t\t\t st->cached_gp_ctrl);\n\t\t\tmutex_unlock(&st->lock);\n\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad5592r_read_raw(struct iio_dev *iio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long m)\n{\n\tstruct ad5592r_state *st = iio_priv(iio_dev);\n\tu16 read_val;\n\tint ret, mult;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (!chan->output) {\n\t\t\tmutex_lock(&st->lock);\n\t\t\tret = st->ops->read_adc(st, chan->channel, &read_val);\n\t\t\tmutex_unlock(&st->lock);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif ((read_val >> 12 & 0x7) != (chan->channel & 0x7)) {\n\t\t\t\tdev_err(st->dev, \"Error while reading channel %u\\n\",\n\t\t\t\t\t\tchan->channel);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tread_val &= GENMASK(11, 0);\n\n\t\t} else {\n\t\t\tmutex_lock(&st->lock);\n\t\t\tread_val = st->cached_dac[chan->channel];\n\t\t\tmutex_unlock(&st->lock);\n\t\t}\n\n\t\tdev_dbg(st->dev, \"Channel %u read: 0x%04hX\\n\",\n\t\t\t\tchan->channel, read_val);\n\n\t\t*val = (int) read_val;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = ad5592r_get_vref(st);\n\n\t\tif (chan->type == IIO_TEMP) {\n\t\t\ts64 tmp = *val * (3767897513LL / 25LL);\n\t\t\t*val = div_s64_rem(tmp, 1000000000LL, val2);\n\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\n\t\tmutex_lock(&st->lock);\n\n\t\tif (chan->output)\n\t\t\tmult = !!(st->cached_gp_ctrl &\n\t\t\t\tAD5592R_REG_CTRL_DAC_RANGE);\n\t\telse\n\t\t\tmult = !!(st->cached_gp_ctrl &\n\t\t\t\tAD5592R_REG_CTRL_ADC_RANGE);\n\n\t\tmutex_unlock(&st->lock);\n\n\t\t*val *= ++mult;\n\n\t\t*val2 = chan->scan_type.realbits;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tret = ad5592r_get_vref(st);\n\n\t\tmutex_lock(&st->lock);\n\n\t\tif (st->cached_gp_ctrl & AD5592R_REG_CTRL_ADC_RANGE)\n\t\t\t*val = (-34365 * 25) / ret;\n\t\telse\n\t\t\t*val = (-75365 * 25) / ret;\n\n\t\tmutex_unlock(&st->lock);\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad5592r_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\n\tdefault:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info ad5592r_info = {\n\t.read_raw = ad5592r_read_raw,\n\t.write_raw = ad5592r_write_raw,\n\t.write_raw_get_fmt = ad5592r_write_raw_get_fmt,\n};\n\nstatic ssize_t ad5592r_show_scale_available(struct iio_dev *iio_dev,\n\t\t\t\t\t   uintptr_t private,\n\t\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t\t   char *buf)\n{\n\tstruct ad5592r_state *st = iio_priv(iio_dev);\n\n\treturn sprintf(buf, \"%d.%09u %d.%09u\\n\",\n\t\tst->scale_avail[0][0], st->scale_avail[0][1],\n\t\tst->scale_avail[1][0], st->scale_avail[1][1]);\n}\n\nstatic const struct iio_chan_spec_ext_info ad5592r_ext_info[] = {\n\t{\n\t .name = \"scale_available\",\n\t .read = ad5592r_show_scale_available,\n\t .shared = IIO_SHARED_BY_TYPE,\n\t },\n\t{},\n};\n\nstatic void ad5592r_setup_channel(struct iio_dev *iio_dev,\n\t\tstruct iio_chan_spec *chan, bool output, unsigned id)\n{\n\tchan->type = IIO_VOLTAGE;\n\tchan->indexed = 1;\n\tchan->output = output;\n\tchan->channel = id;\n\tchan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\n\tchan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);\n\tchan->scan_type.sign = 'u';\n\tchan->scan_type.realbits = 12;\n\tchan->scan_type.storagebits = 16;\n\tchan->ext_info = ad5592r_ext_info;\n}\n\nstatic int ad5592r_alloc_channels(struct iio_dev *iio_dev)\n{\n\tstruct ad5592r_state *st = iio_priv(iio_dev);\n\tunsigned i, curr_channel = 0,\n\t\t num_channels = st->num_channels;\n\tstruct iio_chan_spec *channels;\n\tstruct fwnode_handle *child;\n\tu32 reg, tmp;\n\tint ret;\n\n\tdevice_for_each_child_node(st->dev, child) {\n\t\tret = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\tif (ret || reg >= ARRAY_SIZE(st->channel_modes))\n\t\t\tcontinue;\n\n\t\tret = fwnode_property_read_u32(child, \"adi,mode\", &tmp);\n\t\tif (!ret)\n\t\t\tst->channel_modes[reg] = tmp;\n\n\t\tret = fwnode_property_read_u32(child, \"adi,off-state\", &tmp);\n\t\tif (!ret)\n\t\t\tst->channel_offstate[reg] = tmp;\n\t}\n\n\tchannels = devm_kcalloc(st->dev,\n\t\t\t1 + 2 * num_channels, sizeof(*channels),\n\t\t\tGFP_KERNEL);\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_channels; i++) {\n\t\tswitch (st->channel_modes[i]) {\n\t\tcase CH_MODE_DAC:\n\t\t\tad5592r_setup_channel(iio_dev, &channels[curr_channel],\n\t\t\t\t\ttrue, i);\n\t\t\tcurr_channel++;\n\t\t\tbreak;\n\n\t\tcase CH_MODE_ADC:\n\t\t\tad5592r_setup_channel(iio_dev, &channels[curr_channel],\n\t\t\t\t\tfalse, i);\n\t\t\tcurr_channel++;\n\t\t\tbreak;\n\n\t\tcase CH_MODE_DAC_AND_ADC:\n\t\t\tad5592r_setup_channel(iio_dev, &channels[curr_channel],\n\t\t\t\t\ttrue, i);\n\t\t\tcurr_channel++;\n\t\t\tad5592r_setup_channel(iio_dev, &channels[curr_channel],\n\t\t\t\t\tfalse, i);\n\t\t\tcurr_channel++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tchannels[curr_channel].type = IIO_TEMP;\n\tchannels[curr_channel].channel = 8;\n\tchannels[curr_channel].info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t   BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t   BIT(IIO_CHAN_INFO_OFFSET);\n\tcurr_channel++;\n\n\tiio_dev->num_channels = curr_channel;\n\tiio_dev->channels = channels;\n\n\treturn 0;\n}\n\nstatic void ad5592r_init_scales(struct ad5592r_state *st, int vref_mV)\n{\n\ts64 tmp = (s64)vref_mV * 1000000000LL >> 12;\n\n\tst->scale_avail[0][0] =\n\t\tdiv_s64_rem(tmp, 1000000000LL, &st->scale_avail[0][1]);\n\tst->scale_avail[1][0] =\n\t\tdiv_s64_rem(tmp * 2, 1000000000LL, &st->scale_avail[1][1]);\n}\n\nint ad5592r_probe(struct device *dev, const char *name,\n\t\tconst struct ad5592r_rw_ops *ops)\n{\n\tstruct iio_dev *iio_dev;\n\tstruct ad5592r_state *st;\n\tint ret;\n\n\tiio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (!iio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(iio_dev);\n\tst->dev = dev;\n\tst->ops = ops;\n\tst->num_channels = 8;\n\tdev_set_drvdata(dev, iio_dev);\n\n\tst->reg = devm_regulator_get_optional(dev, \"vref\");\n\tif (IS_ERR(st->reg)) {\n\t\tif ((PTR_ERR(st->reg) != -ENODEV) && dev_fwnode(dev))\n\t\t\treturn PTR_ERR(st->reg);\n\n\t\tst->reg = NULL;\n\t} else {\n\t\tret = regulator_enable(st->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tiio_dev->name = name;\n\tiio_dev->info = &ad5592r_info;\n\tiio_dev->modes = INDIO_DIRECT_MODE;\n\n\tmutex_init(&st->lock);\n\n\tad5592r_init_scales(st, ad5592r_get_vref(st));\n\n\tret = ad5592r_reset(st);\n\tif (ret)\n\t\tgoto error_disable_reg;\n\n\tret = ops->reg_write(st, AD5592R_REG_PD,\n\t\t     (st->reg == NULL) ? AD5592R_REG_PD_EN_REF : 0);\n\tif (ret)\n\t\tgoto error_disable_reg;\n\n\tret = ad5592r_alloc_channels(iio_dev);\n\tif (ret)\n\t\tgoto error_disable_reg;\n\n\tret = ad5592r_set_channel_modes(st);\n\tif (ret)\n\t\tgoto error_reset_ch_modes;\n\n\tret = iio_device_register(iio_dev);\n\tif (ret)\n\t\tgoto error_reset_ch_modes;\n\n\tret = ad5592r_gpio_init(st);\n\tif (ret)\n\t\tgoto error_dev_unregister;\n\n\treturn 0;\n\nerror_dev_unregister:\n\tiio_device_unregister(iio_dev);\n\nerror_reset_ch_modes:\n\tad5592r_reset_channel_modes(st);\n\nerror_disable_reg:\n\tif (st->reg)\n\t\tregulator_disable(st->reg);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(ad5592r_probe, IIO_AD5592R);\n\nvoid ad5592r_remove(struct device *dev)\n{\n\tstruct iio_dev *iio_dev = dev_get_drvdata(dev);\n\tstruct ad5592r_state *st = iio_priv(iio_dev);\n\n\tiio_device_unregister(iio_dev);\n\tad5592r_reset_channel_modes(st);\n\tad5592r_gpio_cleanup(st);\n\n\tif (st->reg)\n\t\tregulator_disable(st->reg);\n}\nEXPORT_SYMBOL_NS_GPL(ad5592r_remove, IIO_AD5592R);\n\nMODULE_AUTHOR(\"Paul Cercueil <paul.cercueil@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5592R multi-channel converters\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}