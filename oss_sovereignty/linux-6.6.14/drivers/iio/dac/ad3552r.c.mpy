{
  "module_name": "ad3552r.c",
  "hash_id": "a12cb47e05e9bd79035b338a95db631e2bfc29418b249261f583640ed9b1d5d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad3552r.c",
  "human_readable_source": "\n \n#include <asm/unaligned.h>\n#include <linux/device.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n \n \n#define AD3552R_REG_ADDR_INTERFACE_CONFIG_A\t\t0x00\n#define   AD3552R_MASK_SOFTWARE_RESET\t\t\t(BIT(7) | BIT(0))\n#define   AD3552R_MASK_ADDR_ASCENSION\t\t\tBIT(5)\n#define   AD3552R_MASK_SDO_ACTIVE\t\t\tBIT(4)\n#define AD3552R_REG_ADDR_INTERFACE_CONFIG_B\t\t0x01\n#define   AD3552R_MASK_SINGLE_INST\t\t\tBIT(7)\n#define   AD3552R_MASK_SHORT_INSTRUCTION\t\tBIT(3)\n#define AD3552R_REG_ADDR_DEVICE_CONFIG\t\t\t0x02\n#define   AD3552R_MASK_DEVICE_STATUS(n)\t\t\tBIT(4 + (n))\n#define   AD3552R_MASK_CUSTOM_MODES\t\t\tGENMASK(3, 2)\n#define   AD3552R_MASK_OPERATING_MODES\t\t\tGENMASK(1, 0)\n#define AD3552R_REG_ADDR_CHIP_TYPE\t\t\t0x03\n#define   AD3552R_MASK_CLASS\t\t\t\tGENMASK(7, 0)\n#define AD3552R_REG_ADDR_PRODUCT_ID_L\t\t\t0x04\n#define AD3552R_REG_ADDR_PRODUCT_ID_H\t\t\t0x05\n#define AD3552R_REG_ADDR_CHIP_GRADE\t\t\t0x06\n#define   AD3552R_MASK_GRADE\t\t\t\tGENMASK(7, 4)\n#define   AD3552R_MASK_DEVICE_REVISION\t\t\tGENMASK(3, 0)\n#define AD3552R_REG_ADDR_SCRATCH_PAD\t\t\t0x0A\n#define AD3552R_REG_ADDR_SPI_REVISION\t\t\t0x0B\n#define AD3552R_REG_ADDR_VENDOR_L\t\t\t0x0C\n#define AD3552R_REG_ADDR_VENDOR_H\t\t\t0x0D\n#define AD3552R_REG_ADDR_STREAM_MODE\t\t\t0x0E\n#define   AD3552R_MASK_LENGTH\t\t\t\tGENMASK(7, 0)\n#define AD3552R_REG_ADDR_TRANSFER_REGISTER\t\t0x0F\n#define   AD3552R_MASK_MULTI_IO_MODE\t\t\tGENMASK(7, 6)\n#define   AD3552R_MASK_STREAM_LENGTH_KEEP_VALUE\t\tBIT(2)\n#define AD3552R_REG_ADDR_INTERFACE_CONFIG_C\t\t0x10\n#define   AD3552R_MASK_CRC_ENABLE\t\t\t(GENMASK(7, 6) |\\\n\t\t\t\t\t\t\t GENMASK(1, 0))\n#define   AD3552R_MASK_STRICT_REGISTER_ACCESS\t\tBIT(5)\n#define AD3552R_REG_ADDR_INTERFACE_STATUS_A\t\t0x11\n#define   AD3552R_MASK_INTERFACE_NOT_READY\t\tBIT(7)\n#define   AD3552R_MASK_CLOCK_COUNTING_ERROR\t\tBIT(5)\n#define   AD3552R_MASK_INVALID_OR_NO_CRC\t\tBIT(3)\n#define   AD3552R_MASK_WRITE_TO_READ_ONLY_REGISTER\tBIT(2)\n#define   AD3552R_MASK_PARTIAL_REGISTER_ACCESS\t\tBIT(1)\n#define   AD3552R_MASK_REGISTER_ADDRESS_INVALID\t\tBIT(0)\n#define AD3552R_REG_ADDR_INTERFACE_CONFIG_D\t\t0x14\n#define   AD3552R_MASK_ALERT_ENABLE_PULLUP\t\tBIT(6)\n#define   AD3552R_MASK_MEM_CRC_EN\t\t\tBIT(4)\n#define   AD3552R_MASK_SDO_DRIVE_STRENGTH\t\tGENMASK(3, 2)\n#define   AD3552R_MASK_DUAL_SPI_SYNCHROUNOUS_EN\t\tBIT(1)\n#define   AD3552R_MASK_SPI_CONFIG_DDR\t\t\tBIT(0)\n#define AD3552R_REG_ADDR_SH_REFERENCE_CONFIG\t\t0x15\n#define   AD3552R_MASK_IDUMP_FAST_MODE\t\t\tBIT(6)\n#define   AD3552R_MASK_SAMPLE_HOLD_DIFFERENTIAL_USER_EN\tBIT(5)\n#define   AD3552R_MASK_SAMPLE_HOLD_USER_TRIM\t\tGENMASK(4, 3)\n#define   AD3552R_MASK_SAMPLE_HOLD_USER_ENABLE\t\tBIT(2)\n#define   AD3552R_MASK_REFERENCE_VOLTAGE_SEL\t\tGENMASK(1, 0)\n#define AD3552R_REG_ADDR_ERR_ALARM_MASK\t\t\t0x16\n#define   AD3552R_MASK_REF_RANGE_ALARM\t\t\tBIT(6)\n#define   AD3552R_MASK_CLOCK_COUNT_ERR_ALARM\t\tBIT(5)\n#define   AD3552R_MASK_MEM_CRC_ERR_ALARM\t\tBIT(4)\n#define   AD3552R_MASK_SPI_CRC_ERR_ALARM\t\tBIT(3)\n#define   AD3552R_MASK_WRITE_TO_READ_ONLY_ALARM\t\tBIT(2)\n#define   AD3552R_MASK_PARTIAL_REGISTER_ACCESS_ALARM\tBIT(1)\n#define   AD3552R_MASK_REGISTER_ADDRESS_INVALID_ALARM\tBIT(0)\n#define AD3552R_REG_ADDR_ERR_STATUS\t\t\t0x17\n#define   AD3552R_MASK_REF_RANGE_ERR_STATUS\t\t\tBIT(6)\n#define   AD3552R_MASK_DUAL_SPI_STREAM_EXCEEDS_DAC_ERR_STATUS\tBIT(5)\n#define   AD3552R_MASK_MEM_CRC_ERR_STATUS\t\t\tBIT(4)\n#define   AD3552R_MASK_RESET_STATUS\t\t\t\tBIT(0)\n#define AD3552R_REG_ADDR_POWERDOWN_CONFIG\t\t0x18\n#define   AD3552R_MASK_CH_DAC_POWERDOWN(ch)\t\tBIT(4 + (ch))\n#define   AD3552R_MASK_CH_AMPLIFIER_POWERDOWN(ch)\tBIT(ch)\n#define AD3552R_REG_ADDR_CH0_CH1_OUTPUT_RANGE\t\t0x19\n#define   AD3552R_MASK_CH_OUTPUT_RANGE_SEL(ch)\t\t((ch) ? GENMASK(7, 4) :\\\n\t\t\t\t\t\t\t GENMASK(3, 0))\n#define AD3552R_REG_ADDR_CH_OFFSET(ch)\t\t\t(0x1B + (ch) * 2)\n#define   AD3552R_MASK_CH_OFFSET_BITS_0_7\t\tGENMASK(7, 0)\n#define AD3552R_REG_ADDR_CH_GAIN(ch)\t\t\t(0x1C + (ch) * 2)\n#define   AD3552R_MASK_CH_RANGE_OVERRIDE\t\tBIT(7)\n#define   AD3552R_MASK_CH_GAIN_SCALING_N\t\tGENMASK(6, 5)\n#define   AD3552R_MASK_CH_GAIN_SCALING_P\t\tGENMASK(4, 3)\n#define   AD3552R_MASK_CH_OFFSET_POLARITY\t\tBIT(2)\n#define   AD3552R_MASK_CH_OFFSET_BIT_8\t\t\tBIT(0)\n \n#define AD3552R_SECONDARY_REGION_START\t\t\t0x28\n#define AD3552R_REG_ADDR_HW_LDAC_16B\t\t\t0x28\n#define AD3552R_REG_ADDR_CH_DAC_16B(ch)\t\t\t(0x2C - (1 - ch) * 2)\n#define AD3552R_REG_ADDR_DAC_PAGE_MASK_16B\t\t0x2E\n#define AD3552R_REG_ADDR_CH_SELECT_16B\t\t\t0x2F\n#define AD3552R_REG_ADDR_INPUT_PAGE_MASK_16B\t\t0x31\n#define AD3552R_REG_ADDR_SW_LDAC_16B\t\t\t0x32\n#define AD3552R_REG_ADDR_CH_INPUT_16B(ch)\t\t(0x36 - (1 - ch) * 2)\n \n#define AD3552R_REG_START_24B\t\t\t\t0x37\n#define AD3552R_REG_ADDR_HW_LDAC_24B\t\t\t0x37\n#define AD3552R_REG_ADDR_CH_DAC_24B(ch)\t\t\t(0x3D - (1 - ch) * 3)\n#define AD3552R_REG_ADDR_DAC_PAGE_MASK_24B\t\t0x40\n#define AD3552R_REG_ADDR_CH_SELECT_24B\t\t\t0x41\n#define AD3552R_REG_ADDR_INPUT_PAGE_MASK_24B\t\t0x44\n#define AD3552R_REG_ADDR_SW_LDAC_24B\t\t\t0x45\n#define AD3552R_REG_ADDR_CH_INPUT_24B(ch)\t\t(0x4B - (1 - ch) * 3)\n\n \n#define AD3552R_NUM_CH\t\t\t\t\t2\n#define AD3552R_MASK_CH(ch)\t\t\t\tBIT(ch)\n#define AD3552R_MASK_ALL_CH\t\t\t\tGENMASK(1, 0)\n#define AD3552R_MAX_REG_SIZE\t\t\t\t3\n#define AD3552R_READ_BIT\t\t\t\tBIT(7)\n#define AD3552R_ADDR_MASK\t\t\t\tGENMASK(6, 0)\n#define AD3552R_MASK_DAC_12B\t\t\t\t0xFFF0\n#define AD3552R_DEFAULT_CONFIG_B_VALUE\t\t\t0x8\n#define AD3552R_SCRATCH_PAD_TEST_VAL1\t\t\t0x34\n#define AD3552R_SCRATCH_PAD_TEST_VAL2\t\t\t0xB2\n#define AD3552R_GAIN_SCALE\t\t\t\t1000\n#define AD3552R_LDAC_PULSE_US\t\t\t\t100\n\nenum ad3552r_ch_vref_select {\n\t \n\tAD3552R_INTERNAL_VREF_PIN_FLOATING,\n\t \n\tAD3552R_INTERNAL_VREF_PIN_2P5V,\n\t \n\tAD3552R_EXTERNAL_VREF_PIN_INPUT\n};\n\nenum ad3542r_id {\n\tAD3542R_ID = 0x4009,\n\tAD3552R_ID = 0x4008,\n};\n\nenum ad3552r_ch_output_range {\n\t \n\tAD3552R_CH_OUTPUT_RANGE_0__2P5V,\n\t \n\tAD3552R_CH_OUTPUT_RANGE_0__5V,\n\t \n\tAD3552R_CH_OUTPUT_RANGE_0__10V,\n\t \n\tAD3552R_CH_OUTPUT_RANGE_NEG_5__5V,\n\t \n\tAD3552R_CH_OUTPUT_RANGE_NEG_10__10V,\n};\n\nstatic const s32 ad3552r_ch_ranges[][2] = {\n\t[AD3552R_CH_OUTPUT_RANGE_0__2P5V]\t= {0, 2500},\n\t[AD3552R_CH_OUTPUT_RANGE_0__5V]\t\t= {0, 5000},\n\t[AD3552R_CH_OUTPUT_RANGE_0__10V]\t= {0, 10000},\n\t[AD3552R_CH_OUTPUT_RANGE_NEG_5__5V]\t= {-5000, 5000},\n\t[AD3552R_CH_OUTPUT_RANGE_NEG_10__10V]\t= {-10000, 10000}\n};\n\nenum ad3542r_ch_output_range {\n\t \n\tAD3542R_CH_OUTPUT_RANGE_0__2P5V,\n\t \n\tAD3542R_CH_OUTPUT_RANGE_0__3V,\n\t \n\tAD3542R_CH_OUTPUT_RANGE_0__5V,\n\t \n\tAD3542R_CH_OUTPUT_RANGE_0__10V,\n\t \n\tAD3542R_CH_OUTPUT_RANGE_NEG_2P5__7P5V,\n\t \n\tAD3542R_CH_OUTPUT_RANGE_NEG_5__5V,\n};\n\nstatic const s32 ad3542r_ch_ranges[][2] = {\n\t[AD3542R_CH_OUTPUT_RANGE_0__2P5V]\t= {0, 2500},\n\t[AD3542R_CH_OUTPUT_RANGE_0__3V]\t\t= {0, 3000},\n\t[AD3542R_CH_OUTPUT_RANGE_0__5V]\t\t= {0, 5000},\n\t[AD3542R_CH_OUTPUT_RANGE_0__10V]\t= {0, 10000},\n\t[AD3542R_CH_OUTPUT_RANGE_NEG_2P5__7P5V]\t= {-2500, 7500},\n\t[AD3542R_CH_OUTPUT_RANGE_NEG_5__5V]\t= {-5000, 5000}\n};\n\nenum ad3552r_ch_gain_scaling {\n\t \n\tAD3552R_CH_GAIN_SCALING_1,\n\t \n\tAD3552R_CH_GAIN_SCALING_0_5,\n\t \n\tAD3552R_CH_GAIN_SCALING_0_25,\n\t \n\tAD3552R_CH_GAIN_SCALING_0_125,\n};\n\n \nstatic const s32 gains_scaling_table[] = {\n\t[AD3552R_CH_GAIN_SCALING_1]\t\t= 1000,\n\t[AD3552R_CH_GAIN_SCALING_0_5]\t\t= 500,\n\t[AD3552R_CH_GAIN_SCALING_0_25]\t\t= 250,\n\t[AD3552R_CH_GAIN_SCALING_0_125]\t\t= 125\n};\n\nenum ad3552r_dev_attributes {\n\t \n\t \n\tAD3552R_SDO_DRIVE_STRENGTH,\n\t \n\tAD3552R_VREF_SELECT,\n\t \n\tAD3552R_ADDR_ASCENSION,\n};\n\nenum ad3552r_ch_attributes {\n\t \n\tAD3552R_CH_DAC_POWERDOWN,\n\t \n\tAD3552R_CH_AMPLIFIER_POWERDOWN,\n\t \n\tAD3552R_CH_OUTPUT_RANGE_SEL,\n\t \n\tAD3552R_CH_RANGE_OVERRIDE,\n\t \n\tAD3552R_CH_GAIN_OFFSET,\n\t \n\tAD3552R_CH_GAIN_OFFSET_POLARITY,\n\t \n\tAD3552R_CH_GAIN_SCALING_P,\n\t \n\tAD3552R_CH_GAIN_SCALING_N,\n\t \n\tAD3552R_CH_RFB,\n\t \n\tAD3552R_CH_SELECT,\n};\n\nstruct ad3552r_ch_data {\n\ts32\tscale_int;\n\ts32\tscale_dec;\n\ts32\toffset_int;\n\ts32\toffset_dec;\n\ts16\tgain_offset;\n\tu16\trfb;\n\tu8\tn;\n\tu8\tp;\n\tu8\trange;\n\tbool\trange_override;\n};\n\nstruct ad3552r_desc {\n\t \n\tstruct mutex\t\tlock;\n\tstruct gpio_desc\t*gpio_reset;\n\tstruct gpio_desc\t*gpio_ldac;\n\tstruct spi_device\t*spi;\n\tstruct ad3552r_ch_data\tch_data[AD3552R_NUM_CH];\n\tstruct iio_chan_spec\tchannels[AD3552R_NUM_CH + 1];\n\tunsigned long\t\tenabled_ch;\n\tunsigned int\t\tnum_ch;\n\tenum ad3542r_id\t\tchip_id;\n};\n\nstatic const u16 addr_mask_map[][2] = {\n\t[AD3552R_ADDR_ASCENSION] = {\n\t\t\tAD3552R_REG_ADDR_INTERFACE_CONFIG_A,\n\t\t\tAD3552R_MASK_ADDR_ASCENSION\n\t},\n\t[AD3552R_SDO_DRIVE_STRENGTH] = {\n\t\t\tAD3552R_REG_ADDR_INTERFACE_CONFIG_D,\n\t\t\tAD3552R_MASK_SDO_DRIVE_STRENGTH\n\t},\n\t[AD3552R_VREF_SELECT] = {\n\t\t\tAD3552R_REG_ADDR_SH_REFERENCE_CONFIG,\n\t\t\tAD3552R_MASK_REFERENCE_VOLTAGE_SEL\n\t},\n};\n\n \nstatic const u16 addr_mask_map_ch[][3] = {\n\t[AD3552R_CH_DAC_POWERDOWN] = {\n\t\t\tAD3552R_REG_ADDR_POWERDOWN_CONFIG,\n\t\t\tAD3552R_MASK_CH_DAC_POWERDOWN(0),\n\t\t\tAD3552R_MASK_CH_DAC_POWERDOWN(1)\n\t},\n\t[AD3552R_CH_AMPLIFIER_POWERDOWN] = {\n\t\t\tAD3552R_REG_ADDR_POWERDOWN_CONFIG,\n\t\t\tAD3552R_MASK_CH_AMPLIFIER_POWERDOWN(0),\n\t\t\tAD3552R_MASK_CH_AMPLIFIER_POWERDOWN(1)\n\t},\n\t[AD3552R_CH_OUTPUT_RANGE_SEL] = {\n\t\t\tAD3552R_REG_ADDR_CH0_CH1_OUTPUT_RANGE,\n\t\t\tAD3552R_MASK_CH_OUTPUT_RANGE_SEL(0),\n\t\t\tAD3552R_MASK_CH_OUTPUT_RANGE_SEL(1)\n\t},\n\t[AD3552R_CH_SELECT] = {\n\t\t\tAD3552R_REG_ADDR_CH_SELECT_16B,\n\t\t\tAD3552R_MASK_CH(0),\n\t\t\tAD3552R_MASK_CH(1)\n\t}\n};\n\nstatic u8 _ad3552r_reg_len(u8 addr)\n{\n\tswitch (addr) {\n\tcase AD3552R_REG_ADDR_HW_LDAC_16B:\n\tcase AD3552R_REG_ADDR_CH_SELECT_16B:\n\tcase AD3552R_REG_ADDR_SW_LDAC_16B:\n\tcase AD3552R_REG_ADDR_HW_LDAC_24B:\n\tcase AD3552R_REG_ADDR_CH_SELECT_24B:\n\tcase AD3552R_REG_ADDR_SW_LDAC_24B:\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (addr > AD3552R_REG_ADDR_HW_LDAC_24B)\n\t\treturn 3;\n\tif (addr > AD3552R_REG_ADDR_HW_LDAC_16B)\n\t\treturn 2;\n\n\treturn 1;\n}\n\n \nstatic int ad3552r_transfer(struct ad3552r_desc *dac, u8 addr, u32 len,\n\t\t\t    u8 *data, bool is_read)\n{\n\t \n\tu8 buf[8];\n\n\tbuf[0] = addr & AD3552R_ADDR_MASK;\n\tbuf[0] |= is_read ? AD3552R_READ_BIT : 0;\n\tif (is_read)\n\t\treturn spi_write_then_read(dac->spi, buf, 1, data, len);\n\n\tmemcpy(buf + 1, data, len);\n\treturn spi_write_then_read(dac->spi, buf, len + 1, NULL, 0);\n}\n\nstatic int ad3552r_write_reg(struct ad3552r_desc *dac, u8 addr, u16 val)\n{\n\tu8 reg_len;\n\tu8 buf[AD3552R_MAX_REG_SIZE] = { 0 };\n\n\treg_len = _ad3552r_reg_len(addr);\n\tif (reg_len == 2)\n\t\t \n\t\tval &= AD3552R_MASK_DAC_12B;\n\tif (reg_len == 1)\n\t\tbuf[0] = val & 0xFF;\n\telse\n\t\t \n\t\tput_unaligned_be16(val, buf);\n\n\treturn ad3552r_transfer(dac, addr, reg_len, buf, false);\n}\n\nstatic int ad3552r_read_reg(struct ad3552r_desc *dac, u8 addr, u16 *val)\n{\n\tint err;\n\tu8  reg_len, buf[AD3552R_MAX_REG_SIZE] = { 0 };\n\n\treg_len = _ad3552r_reg_len(addr);\n\terr = ad3552r_transfer(dac, addr, reg_len, buf, true);\n\tif (err)\n\t\treturn err;\n\n\tif (reg_len == 1)\n\t\t*val = buf[0];\n\telse\n\t\t \n\t\t*val = get_unaligned_be16(buf);\n\n\treturn 0;\n}\n\nstatic u16 ad3552r_field_prep(u16 val, u16 mask)\n{\n\treturn (val << __ffs(mask)) & mask;\n}\n\n \nstatic int ad3552r_update_reg_field(struct ad3552r_desc *dac, u8 addr, u16 mask,\n\t\t\t\t    u16 val)\n{\n\tint ret;\n\tu16 reg;\n\n\tret = ad3552r_read_reg(dac, addr, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treg &= ~mask;\n\treg |= ad3552r_field_prep(val, mask);\n\n\treturn ad3552r_write_reg(dac, addr, reg);\n}\n\nstatic int ad3552r_set_ch_value(struct ad3552r_desc *dac,\n\t\t\t\tenum ad3552r_ch_attributes attr,\n\t\t\t\tu8 ch,\n\t\t\t\tu16 val)\n{\n\t \n\treturn ad3552r_update_reg_field(dac, addr_mask_map_ch[attr][0],\n\t\t\t\t       addr_mask_map_ch[attr][ch + 1], val);\n}\n\n#define AD3552R_CH_DAC(_idx) ((struct iio_chan_spec) {\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.output = true,\t\t\t\t\t\t\\\n\t.indexed = true,\t\t\t\t\t\\\n\t.channel = _idx,\t\t\t\t\t\\\n\t.scan_index = _idx,\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_ENABLE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\t\\\n})\n\nstatic int ad3552r_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val,\n\t\t\t    int *val2,\n\t\t\t    long mask)\n{\n\tstruct ad3552r_desc *dac = iio_priv(indio_dev);\n\tu16 tmp_val;\n\tint err;\n\tu8 ch = chan->channel;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&dac->lock);\n\t\terr = ad3552r_read_reg(dac, AD3552R_REG_ADDR_CH_DAC_24B(ch),\n\t\t\t\t       &tmp_val);\n\t\tmutex_unlock(&dac->lock);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = tmp_val;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\tmutex_lock(&dac->lock);\n\t\terr = ad3552r_read_reg(dac, AD3552R_REG_ADDR_POWERDOWN_CONFIG,\n\t\t\t\t       &tmp_val);\n\t\tmutex_unlock(&dac->lock);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*val = !((tmp_val & AD3552R_MASK_CH_DAC_POWERDOWN(ch)) >>\n\t\t\t  __ffs(AD3552R_MASK_CH_DAC_POWERDOWN(ch)));\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = dac->ch_data[ch].scale_int;\n\t\t*val2 = dac->ch_data[ch].scale_dec;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = dac->ch_data[ch].offset_int;\n\t\t*val2 = dac->ch_data[ch].offset_dec;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad3552r_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val,\n\t\t\t     int val2,\n\t\t\t     long mask)\n{\n\tstruct ad3552r_desc *dac = iio_priv(indio_dev);\n\tint err;\n\n\tmutex_lock(&dac->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\terr = ad3552r_write_reg(dac,\n\t\t\t\t\tAD3552R_REG_ADDR_CH_DAC_24B(chan->channel),\n\t\t\t\t\tval);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\terr = ad3552r_set_ch_value(dac, AD3552R_CH_DAC_POWERDOWN,\n\t\t\t\t\t   chan->channel, !val);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&dac->lock);\n\n\treturn err;\n}\n\nstatic const struct iio_info ad3552r_iio_info = {\n\t.read_raw = ad3552r_read_raw,\n\t.write_raw = ad3552r_write_raw\n};\n\nstatic int32_t ad3552r_trigger_hw_ldac(struct gpio_desc *ldac)\n{\n\tgpiod_set_value_cansleep(ldac, 0);\n\tusleep_range(AD3552R_LDAC_PULSE_US, AD3552R_LDAC_PULSE_US + 10);\n\tgpiod_set_value_cansleep(ldac, 1);\n\n\treturn 0;\n}\n\nstatic int ad3552r_write_all_channels(struct ad3552r_desc *dac, u8 *data)\n{\n\tint err, len;\n\tu8 addr, buff[AD3552R_NUM_CH * AD3552R_MAX_REG_SIZE + 1];\n\n\taddr = AD3552R_REG_ADDR_CH_INPUT_24B(1);\n\t \n\tmemcpy(buff, data + 2, 2);\n\tbuff[2] = 0;\n\t \n\tmemcpy(buff + 3, data, 2);\n\tbuff[5] = 0;\n\tlen = 6;\n\tif (!dac->gpio_ldac) {\n\t\t \n\t\tbuff[6] = AD3552R_MASK_ALL_CH;\n\t\t++len;\n\t}\n\terr = ad3552r_transfer(dac, addr, len, buff, false);\n\tif (err)\n\t\treturn err;\n\n\tif (dac->gpio_ldac)\n\t\treturn ad3552r_trigger_hw_ldac(dac->gpio_ldac);\n\n\treturn 0;\n}\n\nstatic int ad3552r_write_codes(struct ad3552r_desc *dac, u32 mask, u8 *data)\n{\n\tint err;\n\tu8 addr, buff[AD3552R_MAX_REG_SIZE];\n\n\tif (mask == AD3552R_MASK_ALL_CH) {\n\t\tif (memcmp(data, data + 2, 2) != 0)\n\t\t\treturn ad3552r_write_all_channels(dac, data);\n\n\t\taddr = AD3552R_REG_ADDR_INPUT_PAGE_MASK_24B;\n\t} else {\n\t\taddr = AD3552R_REG_ADDR_CH_INPUT_24B(__ffs(mask));\n\t}\n\n\tmemcpy(buff, data, 2);\n\tbuff[2] = 0;\n\terr = ad3552r_transfer(dac, addr, 3, data, false);\n\tif (err)\n\t\treturn err;\n\n\tif (dac->gpio_ldac)\n\t\treturn ad3552r_trigger_hw_ldac(dac->gpio_ldac);\n\n\treturn ad3552r_write_reg(dac, AD3552R_REG_ADDR_SW_LDAC_24B, mask);\n}\n\nstatic irqreturn_t ad3552r_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct iio_buffer *buf = indio_dev->buffer;\n\tstruct ad3552r_desc *dac = iio_priv(indio_dev);\n\t \n\tu8 buff[AD3552R_NUM_CH * AD3552R_MAX_REG_SIZE];\n\tint err;\n\n\tmemset(buff, 0, sizeof(buff));\n\terr = iio_pop_from_buffer(buf, buff);\n\tif (err)\n\t\tgoto end;\n\n\tmutex_lock(&dac->lock);\n\tad3552r_write_codes(dac, *indio_dev->active_scan_mask, buff);\n\tmutex_unlock(&dac->lock);\nend:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ad3552r_check_scratch_pad(struct ad3552r_desc *dac)\n{\n\tconst u16 val1 = AD3552R_SCRATCH_PAD_TEST_VAL1;\n\tconst u16 val2 = AD3552R_SCRATCH_PAD_TEST_VAL2;\n\tu16 val;\n\tint err;\n\n\terr = ad3552r_write_reg(dac, AD3552R_REG_ADDR_SCRATCH_PAD, val1);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ad3552r_read_reg(dac, AD3552R_REG_ADDR_SCRATCH_PAD, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (val1 != val)\n\t\treturn -ENODEV;\n\n\terr = ad3552r_write_reg(dac, AD3552R_REG_ADDR_SCRATCH_PAD, val2);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ad3552r_read_reg(dac, AD3552R_REG_ADDR_SCRATCH_PAD, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (val2 != val)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstruct reg_addr_pool {\n\tstruct ad3552r_desc *dac;\n\tu8\t\t    addr;\n};\n\nstatic int ad3552r_read_reg_wrapper(struct reg_addr_pool *addr)\n{\n\tint err;\n\tu16 val;\n\n\terr = ad3552r_read_reg(addr->dac, addr->addr, &val);\n\tif (err)\n\t\treturn err;\n\n\treturn val;\n}\n\nstatic int ad3552r_reset(struct ad3552r_desc *dac)\n{\n\tstruct reg_addr_pool addr;\n\tint ret;\n\tint val;\n\n\tdac->gpio_reset = devm_gpiod_get_optional(&dac->spi->dev, \"reset\",\n\t\t\t\t\t\t  GPIOD_OUT_LOW);\n\tif (IS_ERR(dac->gpio_reset))\n\t\treturn dev_err_probe(&dac->spi->dev, PTR_ERR(dac->gpio_reset),\n\t\t\t\t     \"Error while getting gpio reset\");\n\n\tif (dac->gpio_reset) {\n\t\t \n\t\tusleep_range(10, 20);\n\t\tgpiod_set_value_cansleep(dac->gpio_reset, 1);\n\t} else {\n\t\t \n\t\tret = ad3552r_update_reg_field(dac,\n\t\t\t\t\t       AD3552R_REG_ADDR_INTERFACE_CONFIG_A,\n\t\t\t\t\t       AD3552R_MASK_SOFTWARE_RESET,\n\t\t\t\t\t       AD3552R_MASK_SOFTWARE_RESET);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t}\n\n\taddr.dac = dac;\n\taddr.addr = AD3552R_REG_ADDR_INTERFACE_CONFIG_B;\n\tret = readx_poll_timeout(ad3552r_read_reg_wrapper, &addr, val,\n\t\t\t\t val == AD3552R_DEFAULT_CONFIG_B_VALUE ||\n\t\t\t\t val < 0,\n\t\t\t\t 5000, 50000);\n\tif (val < 0)\n\t\tret = val;\n\tif (ret) {\n\t\tdev_err(&dac->spi->dev, \"Error while resetting\");\n\t\treturn ret;\n\t}\n\n\tret = readx_poll_timeout(ad3552r_read_reg_wrapper, &addr, val,\n\t\t\t\t !(val & AD3552R_MASK_INTERFACE_NOT_READY) ||\n\t\t\t\t val < 0,\n\t\t\t\t 5000, 50000);\n\tif (val < 0)\n\t\tret = val;\n\tif (ret) {\n\t\tdev_err(&dac->spi->dev, \"Error while resetting\");\n\t\treturn ret;\n\t}\n\n\treturn ad3552r_update_reg_field(dac,\n\t\t\t\t\taddr_mask_map[AD3552R_ADDR_ASCENSION][0],\n\t\t\t\t\taddr_mask_map[AD3552R_ADDR_ASCENSION][1],\n\t\t\t\t\tval);\n}\n\nstatic void ad3552r_get_custom_range(struct ad3552r_desc *dac, s32 i, s32 *v_min,\n\t\t\t\t     s32 *v_max)\n{\n\ts64 vref, tmp, common, offset, gn, gp;\n\t \n\tvref = 2500;\n\t \n\tcommon = 2575 * dac->ch_data[i].rfb;\n\toffset = dac->ch_data[i].gain_offset;\n\n\tgn = gains_scaling_table[dac->ch_data[i].n];\n\ttmp = (1024 * gn + AD3552R_GAIN_SCALE * offset) * common;\n\ttmp = div_s64(tmp, 1024  * AD3552R_GAIN_SCALE);\n\t*v_max = vref + tmp;\n\n\tgp = gains_scaling_table[dac->ch_data[i].p];\n\ttmp = (1024 * gp - AD3552R_GAIN_SCALE * offset) * common;\n\ttmp = div_s64(tmp, 1024 * AD3552R_GAIN_SCALE);\n\t*v_min = vref - tmp;\n}\n\nstatic void ad3552r_calc_gain_and_offset(struct ad3552r_desc *dac, s32 ch)\n{\n\ts32 idx, v_max, v_min, span, rem;\n\ts64 tmp;\n\n\tif (dac->ch_data[ch].range_override) {\n\t\tad3552r_get_custom_range(dac, ch, &v_min, &v_max);\n\t} else {\n\t\t \n\t\tidx = dac->ch_data[ch].range;\n\t\tif (dac->chip_id == AD3542R_ID) {\n\t\t\tv_min = ad3542r_ch_ranges[idx][0];\n\t\t\tv_max = ad3542r_ch_ranges[idx][1];\n\t\t} else {\n\t\t\tv_min = ad3552r_ch_ranges[idx][0];\n\t\t\tv_max = ad3552r_ch_ranges[idx][1];\n\t\t}\n\t}\n\n\t \n\tspan = v_max - v_min;\n\tdac->ch_data[ch].scale_int = div_s64_rem(span, 65536, &rem);\n\t \n\tdac->ch_data[ch].scale_dec = DIV_ROUND_CLOSEST((s64)rem * 1000000,\n\t\t\t\t\t\t\t65536);\n\n\tdac->ch_data[ch].offset_int = div_s64_rem(v_min * 65536, span, &rem);\n\ttmp = (s64)rem * 1000000;\n\tdac->ch_data[ch].offset_dec = div_s64(tmp, span);\n}\n\nstatic int ad3552r_find_range(u16 id, s32 *vals)\n{\n\tint i, len;\n\tconst s32 (*ranges)[2];\n\n\tif (id == AD3542R_ID) {\n\t\tlen = ARRAY_SIZE(ad3542r_ch_ranges);\n\t\tranges = ad3542r_ch_ranges;\n\t} else {\n\t\tlen = ARRAY_SIZE(ad3552r_ch_ranges);\n\t\tranges = ad3552r_ch_ranges;\n\t}\n\n\tfor (i = 0; i < len; i++)\n\t\tif (vals[0] == ranges[i][0] * 1000 &&\n\t\t    vals[1] == ranges[i][1] * 1000)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int ad3552r_configure_custom_gain(struct ad3552r_desc *dac,\n\t\t\t\t\t struct fwnode_handle *child,\n\t\t\t\t\t u32 ch)\n{\n\tstruct device *dev = &dac->spi->dev;\n\tstruct fwnode_handle *gain_child;\n\tu32 val;\n\tint err;\n\tu8 addr;\n\tu16 reg = 0, offset;\n\n\tgain_child = fwnode_get_named_child_node(child,\n\t\t\t\t\t\t \"custom-output-range-config\");\n\tif (!gain_child) {\n\t\tdev_err(dev,\n\t\t\t\"mandatory custom-output-range-config property missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdac->ch_data[ch].range_override = 1;\n\treg |= ad3552r_field_prep(1, AD3552R_MASK_CH_RANGE_OVERRIDE);\n\n\terr = fwnode_property_read_u32(gain_child, \"adi,gain-scaling-p\", &val);\n\tif (err) {\n\t\tdev_err(dev, \"mandatory adi,gain-scaling-p property missing\\n\");\n\t\tgoto put_child;\n\t}\n\treg |= ad3552r_field_prep(val, AD3552R_MASK_CH_GAIN_SCALING_P);\n\tdac->ch_data[ch].p = val;\n\n\terr = fwnode_property_read_u32(gain_child, \"adi,gain-scaling-n\", &val);\n\tif (err) {\n\t\tdev_err(dev, \"mandatory adi,gain-scaling-n property missing\\n\");\n\t\tgoto put_child;\n\t}\n\treg |= ad3552r_field_prep(val, AD3552R_MASK_CH_GAIN_SCALING_N);\n\tdac->ch_data[ch].n = val;\n\n\terr = fwnode_property_read_u32(gain_child, \"adi,rfb-ohms\", &val);\n\tif (err) {\n\t\tdev_err(dev, \"mandatory adi,rfb-ohms property missing\\n\");\n\t\tgoto put_child;\n\t}\n\tdac->ch_data[ch].rfb = val;\n\n\terr = fwnode_property_read_u32(gain_child, \"adi,gain-offset\", &val);\n\tif (err) {\n\t\tdev_err(dev, \"mandatory adi,gain-offset property missing\\n\");\n\t\tgoto put_child;\n\t}\n\tdac->ch_data[ch].gain_offset = val;\n\n\toffset = abs((s32)val);\n\treg |= ad3552r_field_prep((offset >> 8), AD3552R_MASK_CH_OFFSET_BIT_8);\n\n\treg |= ad3552r_field_prep((s32)val < 0, AD3552R_MASK_CH_OFFSET_POLARITY);\n\taddr = AD3552R_REG_ADDR_CH_GAIN(ch);\n\terr = ad3552r_write_reg(dac, addr,\n\t\t\t\toffset & AD3552R_MASK_CH_OFFSET_BITS_0_7);\n\tif (err) {\n\t\tdev_err(dev, \"Error writing register\\n\");\n\t\tgoto put_child;\n\t}\n\n\terr = ad3552r_write_reg(dac, addr, reg);\n\tif (err) {\n\t\tdev_err(dev, \"Error writing register\\n\");\n\t\tgoto put_child;\n\t}\n\nput_child:\n\tfwnode_handle_put(gain_child);\n\n\treturn err;\n}\n\nstatic void ad3552r_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int ad3552r_configure_device(struct ad3552r_desc *dac)\n{\n\tstruct device *dev = &dac->spi->dev;\n\tstruct fwnode_handle *child;\n\tstruct regulator *vref;\n\tint err, cnt = 0, voltage, delta = 100000;\n\tu32 vals[2], val, ch;\n\n\tdac->gpio_ldac = devm_gpiod_get_optional(dev, \"ldac\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(dac->gpio_ldac))\n\t\treturn dev_err_probe(dev, PTR_ERR(dac->gpio_ldac),\n\t\t\t\t     \"Error getting gpio ldac\");\n\n\tvref = devm_regulator_get_optional(dev, \"vref\");\n\tif (IS_ERR(vref)) {\n\t\tif (PTR_ERR(vref) != -ENODEV)\n\t\t\treturn dev_err_probe(dev, PTR_ERR(vref),\n\t\t\t\t\t     \"Error getting vref\");\n\n\t\tif (device_property_read_bool(dev, \"adi,vref-out-en\"))\n\t\t\tval = AD3552R_INTERNAL_VREF_PIN_2P5V;\n\t\telse\n\t\t\tval = AD3552R_INTERNAL_VREF_PIN_FLOATING;\n\t} else {\n\t\terr = regulator_enable(vref);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to enable external vref supply\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\terr = devm_add_action_or_reset(dev, ad3552r_reg_disable, vref);\n\t\tif (err) {\n\t\t\tregulator_disable(vref);\n\t\t\treturn err;\n\t\t}\n\n\t\tvoltage = regulator_get_voltage(vref);\n\t\tif (voltage > 2500000 + delta || voltage < 2500000 - delta) {\n\t\t\tdev_warn(dev, \"vref-supply must be 2.5V\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = AD3552R_EXTERNAL_VREF_PIN_INPUT;\n\t}\n\n\terr = ad3552r_update_reg_field(dac,\n\t\t\t\t       addr_mask_map[AD3552R_VREF_SELECT][0],\n\t\t\t\t       addr_mask_map[AD3552R_VREF_SELECT][1],\n\t\t\t\t       val);\n\tif (err)\n\t\treturn err;\n\n\terr = device_property_read_u32(dev, \"adi,sdo-drive-strength\", &val);\n\tif (!err) {\n\t\tif (val > 3) {\n\t\t\tdev_err(dev, \"adi,sdo-drive-strength must be less than 4\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = ad3552r_update_reg_field(dac,\n\t\t\t\t\t       addr_mask_map[AD3552R_SDO_DRIVE_STRENGTH][0],\n\t\t\t\t\t       addr_mask_map[AD3552R_SDO_DRIVE_STRENGTH][1],\n\t\t\t\t\t       val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tdac->num_ch = device_get_child_node_count(dev);\n\tif (!dac->num_ch) {\n\t\tdev_err(dev, \"No channels defined\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdevice_for_each_child_node(dev, child) {\n\t\terr = fwnode_property_read_u32(child, \"reg\", &ch);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"mandatory reg property missing\\n\");\n\t\t\tgoto put_child;\n\t\t}\n\t\tif (ch >= AD3552R_NUM_CH) {\n\t\t\tdev_err(dev, \"reg must be less than %d\\n\",\n\t\t\t\tAD3552R_NUM_CH);\n\t\t\terr = -EINVAL;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tif (fwnode_property_present(child, \"adi,output-range-microvolt\")) {\n\t\t\terr = fwnode_property_read_u32_array(child,\n\t\t\t\t\t\t\t     \"adi,output-range-microvolt\",\n\t\t\t\t\t\t\t     vals,\n\t\t\t\t\t\t\t     2);\n\t\t\tif (err) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"adi,output-range-microvolt property could not be parsed\\n\");\n\t\t\t\tgoto put_child;\n\t\t\t}\n\n\t\t\terr = ad3552r_find_range(dac->chip_id, vals);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Invalid adi,output-range-microvolt value\\n\");\n\t\t\t\tgoto put_child;\n\t\t\t}\n\t\t\tval = err;\n\t\t\terr = ad3552r_set_ch_value(dac,\n\t\t\t\t\t\t   AD3552R_CH_OUTPUT_RANGE_SEL,\n\t\t\t\t\t\t   ch, val);\n\t\t\tif (err)\n\t\t\t\tgoto put_child;\n\n\t\t\tdac->ch_data[ch].range = val;\n\t\t} else if (dac->chip_id == AD3542R_ID) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"adi,output-range-microvolt is required for ad3542r\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto put_child;\n\t\t} else {\n\t\t\terr = ad3552r_configure_custom_gain(dac, child, ch);\n\t\t\tif (err)\n\t\t\t\tgoto put_child;\n\t\t}\n\n\t\tad3552r_calc_gain_and_offset(dac, ch);\n\t\tdac->enabled_ch |= BIT(ch);\n\n\t\terr = ad3552r_set_ch_value(dac, AD3552R_CH_SELECT, ch, 1);\n\t\tif (err < 0)\n\t\t\tgoto put_child;\n\n\t\tdac->channels[cnt] = AD3552R_CH_DAC(ch);\n\t\t++cnt;\n\n\t}\n\n\t \n\tfor_each_clear_bit(ch, &dac->enabled_ch, AD3552R_NUM_CH) {\n\t\terr = ad3552r_set_ch_value(dac, AD3552R_CH_AMPLIFIER_POWERDOWN,\n\t\t\t\t\t   ch, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tdac->num_ch = cnt;\n\n\treturn 0;\nput_child:\n\tfwnode_handle_put(child);\n\n\treturn err;\n}\n\nstatic int ad3552r_init(struct ad3552r_desc *dac)\n{\n\tint err;\n\tu16 val, id;\n\n\terr = ad3552r_reset(dac);\n\tif (err) {\n\t\tdev_err(&dac->spi->dev, \"Reset failed\\n\");\n\t\treturn err;\n\t}\n\n\terr = ad3552r_check_scratch_pad(dac);\n\tif (err) {\n\t\tdev_err(&dac->spi->dev, \"Scratch pad test failed\\n\");\n\t\treturn err;\n\t}\n\n\terr = ad3552r_read_reg(dac, AD3552R_REG_ADDR_PRODUCT_ID_L, &val);\n\tif (err) {\n\t\tdev_err(&dac->spi->dev, \"Fail read PRODUCT_ID_L\\n\");\n\t\treturn err;\n\t}\n\n\tid = val;\n\terr = ad3552r_read_reg(dac, AD3552R_REG_ADDR_PRODUCT_ID_H, &val);\n\tif (err) {\n\t\tdev_err(&dac->spi->dev, \"Fail read PRODUCT_ID_H\\n\");\n\t\treturn err;\n\t}\n\n\tid |= val << 8;\n\tif (id != dac->chip_id) {\n\t\tdev_err(&dac->spi->dev, \"Product id not matching\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn ad3552r_configure_device(dac);\n}\n\nstatic int ad3552r_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tstruct ad3552r_desc *dac;\n\tstruct iio_dev *indio_dev;\n\tint err;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*dac));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdac = iio_priv(indio_dev);\n\tdac->spi = spi;\n\tdac->chip_id = id->driver_data;\n\n\tmutex_init(&dac->lock);\n\n\terr = ad3552r_init(dac);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (dac->chip_id == AD3552R_ID)\n\t\tindio_dev->name = \"ad3552r\";\n\telse\n\t\tindio_dev->name = \"ad3542r\";\n\tindio_dev->dev.parent = &spi->dev;\n\tindio_dev->info = &ad3552r_iio_info;\n\tindio_dev->num_channels = dac->num_ch;\n\tindio_dev->channels = dac->channels;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\terr = devm_iio_triggered_buffer_setup_ext(&indio_dev->dev, indio_dev, NULL,\n\t\t\t\t\t\t  &ad3552r_trigger_handler,\n\t\t\t\t\t\t  IIO_BUFFER_DIRECTION_OUT,\n\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t  NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad3552r_id[] = {\n\t{ \"ad3542r\", AD3542R_ID },\n\t{ \"ad3552r\", AD3552R_ID },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, ad3552r_id);\n\nstatic const struct of_device_id ad3552r_of_match[] = {\n\t{ .compatible = \"adi,ad3542r\"},\n\t{ .compatible = \"adi,ad3552r\"},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ad3552r_of_match);\n\nstatic struct spi_driver ad3552r_driver = {\n\t.driver = {\n\t\t.name = \"ad3552r\",\n\t\t.of_match_table = ad3552r_of_match,\n\t},\n\t.probe = ad3552r_probe,\n\t.id_table = ad3552r_id\n};\nmodule_spi_driver(ad3552r_driver);\n\nMODULE_AUTHOR(\"Mihail Chindris <mihail.chindris@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Device AD3552R DAC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}