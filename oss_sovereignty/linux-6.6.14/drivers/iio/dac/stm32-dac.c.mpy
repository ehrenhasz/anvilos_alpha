{
  "module_name": "stm32-dac.c",
  "hash_id": "4a84263572fb3a782975ee09f669f43f3b75ad4c194656d2332a1dd1bd416115",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/stm32-dac.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/iio/iio.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/string_helpers.h>\n\n#include \"stm32-dac-core.h\"\n\n#define STM32_DAC_CHANNEL_1\t\t1\n#define STM32_DAC_CHANNEL_2\t\t2\n#define STM32_DAC_IS_CHAN_1(ch)\t\t((ch) & STM32_DAC_CHANNEL_1)\n\n#define STM32_DAC_AUTO_SUSPEND_DELAY_MS\t2000\n\n \nstruct stm32_dac {\n\tstruct stm32_dac_common *common;\n\tstruct mutex\t\tlock;\n};\n\nstatic int stm32_dac_is_enabled(struct iio_dev *indio_dev, int channel)\n{\n\tstruct stm32_dac *dac = iio_priv(indio_dev);\n\tu32 en, val;\n\tint ret;\n\n\tret = regmap_read(dac->common->regmap, STM32_DAC_CR, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (STM32_DAC_IS_CHAN_1(channel))\n\t\ten = FIELD_GET(STM32_DAC_CR_EN1, val);\n\telse\n\t\ten = FIELD_GET(STM32_DAC_CR_EN2, val);\n\n\treturn !!en;\n}\n\nstatic int stm32_dac_set_enable_state(struct iio_dev *indio_dev, int ch,\n\t\t\t\t      bool enable)\n{\n\tstruct stm32_dac *dac = iio_priv(indio_dev);\n\tstruct device *dev = indio_dev->dev.parent;\n\tu32 msk = STM32_DAC_IS_CHAN_1(ch) ? STM32_DAC_CR_EN1 : STM32_DAC_CR_EN2;\n\tu32 en = enable ? msk : 0;\n\tint ret;\n\n\t \n\tmutex_lock(&dac->lock);\n\tret = stm32_dac_is_enabled(indio_dev, ch);\n\tif (ret < 0 || enable == !!ret) {\n\t\tmutex_unlock(&dac->lock);\n\t\treturn ret < 0 ? ret : 0;\n\t}\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&dac->lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = regmap_update_bits(dac->common->regmap, STM32_DAC_CR, msk, en);\n\tmutex_unlock(&dac->lock);\n\tif (ret < 0) {\n\t\tdev_err(&indio_dev->dev, \"%s failed\\n\", str_enable_disable(en));\n\t\tgoto err_put_pm;\n\t}\n\n\t \n\tif (en && dac->common->hfsel)\n\t\tudelay(1);\n\n\tif (!enable) {\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tpm_runtime_put_autosuspend(dev);\n\t}\n\n\treturn 0;\n\nerr_put_pm:\n\tif (enable) {\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tpm_runtime_put_autosuspend(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int stm32_dac_get_value(struct stm32_dac *dac, int channel, int *val)\n{\n\tint ret;\n\n\tif (STM32_DAC_IS_CHAN_1(channel))\n\t\tret = regmap_read(dac->common->regmap, STM32_DAC_DOR1, val);\n\telse\n\t\tret = regmap_read(dac->common->regmap, STM32_DAC_DOR2, val);\n\n\treturn ret ? ret : IIO_VAL_INT;\n}\n\nstatic int stm32_dac_set_value(struct stm32_dac *dac, int channel, int val)\n{\n\tint ret;\n\n\tif (STM32_DAC_IS_CHAN_1(channel))\n\t\tret = regmap_write(dac->common->regmap, STM32_DAC_DHR12R1, val);\n\telse\n\t\tret = regmap_write(dac->common->regmap, STM32_DAC_DHR12R2, val);\n\n\treturn ret;\n}\n\nstatic int stm32_dac_read_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int *val, int *val2, long mask)\n{\n\tstruct stm32_dac *dac = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn stm32_dac_get_value(dac, chan->channel, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = dac->common->vref_mv;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int stm32_dac_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val, int val2, long mask)\n{\n\tstruct stm32_dac *dac = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn stm32_dac_set_value(dac, chan->channel, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int stm32_dac_debugfs_reg_access(struct iio_dev *indio_dev,\n\t\t\t\t\tunsigned reg, unsigned writeval,\n\t\t\t\t\tunsigned *readval)\n{\n\tstruct stm32_dac *dac = iio_priv(indio_dev);\n\n\tif (!readval)\n\t\treturn regmap_write(dac->common->regmap, reg, writeval);\n\telse\n\t\treturn regmap_read(dac->common->regmap, reg, readval);\n}\n\nstatic const struct iio_info stm32_dac_iio_info = {\n\t.read_raw = stm32_dac_read_raw,\n\t.write_raw = stm32_dac_write_raw,\n\t.debugfs_reg_access = stm32_dac_debugfs_reg_access,\n};\n\nstatic const char * const stm32_dac_powerdown_modes[] = {\n\t\"three_state\",\n};\n\nstatic int stm32_dac_get_powerdown_mode(struct iio_dev *indio_dev,\n\t\t\t\t\tconst struct iio_chan_spec *chan)\n{\n\treturn 0;\n}\n\nstatic int stm32_dac_set_powerdown_mode(struct iio_dev *indio_dev,\n\t\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\t\tunsigned int type)\n{\n\treturn 0;\n}\n\nstatic ssize_t stm32_dac_read_powerdown(struct iio_dev *indio_dev,\n\t\t\t\t\tuintptr_t private,\n\t\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\t\tchar *buf)\n{\n\tint ret = stm32_dac_is_enabled(indio_dev, chan->channel);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", ret ? 0 : 1);\n}\n\nstatic ssize_t stm32_dac_write_powerdown(struct iio_dev *indio_dev,\n\t\t\t\t\t uintptr_t private,\n\t\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t\t const char *buf, size_t len)\n{\n\tbool powerdown;\n\tint ret;\n\n\tret = kstrtobool(buf, &powerdown);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stm32_dac_set_enable_state(indio_dev, chan->channel, !powerdown);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic const struct iio_enum stm32_dac_powerdown_mode_en = {\n\t.items = stm32_dac_powerdown_modes,\n\t.num_items = ARRAY_SIZE(stm32_dac_powerdown_modes),\n\t.get = stm32_dac_get_powerdown_mode,\n\t.set = stm32_dac_set_powerdown_mode,\n};\n\nstatic const struct iio_chan_spec_ext_info stm32_dac_ext_info[] = {\n\t{\n\t\t.name = \"powerdown\",\n\t\t.read = stm32_dac_read_powerdown,\n\t\t.write = stm32_dac_write_powerdown,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\tIIO_ENUM(\"powerdown_mode\", IIO_SEPARATE, &stm32_dac_powerdown_mode_en),\n\tIIO_ENUM_AVAILABLE(\"powerdown_mode\", IIO_SHARED_BY_TYPE, &stm32_dac_powerdown_mode_en),\n\t{},\n};\n\n#define STM32_DAC_CHANNEL(chan, name) {\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\\\n\t.channel = chan,\t\t\t\t\\\n\t.info_mask_separate =\t\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t  \\\n\t.scan_type = {\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\\\n\t\t.realbits = 12,\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\\\n\t},\t\t\t\t\t\t\\\n\t.datasheet_name = name,\t\t\t\t\\\n\t.ext_info = stm32_dac_ext_info\t\t\t\\\n}\n\nstatic const struct iio_chan_spec stm32_dac_channels[] = {\n\tSTM32_DAC_CHANNEL(STM32_DAC_CHANNEL_1, \"out1\"),\n\tSTM32_DAC_CHANNEL(STM32_DAC_CHANNEL_2, \"out2\"),\n};\n\nstatic int stm32_dac_chan_of_init(struct iio_dev *indio_dev)\n{\n\tstruct device_node *np = indio_dev->dev.of_node;\n\tunsigned int i;\n\tu32 channel;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"reg\", &channel);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"Failed to read reg property\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(stm32_dac_channels); i++) {\n\t\tif (stm32_dac_channels[i].channel == channel)\n\t\t\tbreak;\n\t}\n\tif (i >= ARRAY_SIZE(stm32_dac_channels)) {\n\t\tdev_err(&indio_dev->dev, \"Invalid reg property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tindio_dev->channels = &stm32_dac_channels[i];\n\t \n\tindio_dev->num_channels = 1;\n\n\treturn 0;\n};\n\nstatic int stm32_dac_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct stm32_dac *dac;\n\tint ret;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*dac));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tdac = iio_priv(indio_dev);\n\tdac->common = dev_get_drvdata(pdev->dev.parent);\n\tindio_dev->name = dev_name(&pdev->dev);\n\tindio_dev->dev.of_node = pdev->dev.of_node;\n\tindio_dev->info = &stm32_dac_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tmutex_init(&dac->lock);\n\n\tret = stm32_dac_chan_of_init(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_set_autosuspend_delay(dev, STM32_DAC_AUTO_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto err_pm_put;\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n\nerr_pm_put:\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_put_noidle(dev);\n\n\treturn ret;\n}\n\nstatic int stm32_dac_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tiio_device_unregister(indio_dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic int stm32_dac_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tint channel = indio_dev->channels[0].channel;\n\tint ret;\n\n\t \n\tret = stm32_dac_is_enabled(indio_dev, channel);\n\tif (ret)\n\t\treturn ret < 0 ? ret : -EBUSY;\n\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(stm32_dac_pm_ops, stm32_dac_suspend,\n\t\t\t\tpm_runtime_force_resume);\n\nstatic const struct of_device_id stm32_dac_of_match[] = {\n\t{ .compatible = \"st,stm32-dac\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_dac_of_match);\n\nstatic struct platform_driver stm32_dac_driver = {\n\t.probe = stm32_dac_probe,\n\t.remove = stm32_dac_remove,\n\t.driver = {\n\t\t.name = \"stm32-dac\",\n\t\t.of_match_table = stm32_dac_of_match,\n\t\t.pm = pm_sleep_ptr(&stm32_dac_pm_ops),\n\t},\n};\nmodule_platform_driver(stm32_dac_driver);\n\nMODULE_ALIAS(\"platform:stm32-dac\");\nMODULE_AUTHOR(\"Amelie Delaunay <amelie.delaunay@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 DAC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}