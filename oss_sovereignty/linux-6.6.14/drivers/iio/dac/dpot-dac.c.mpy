{
  "module_name": "dpot-dac.c",
  "hash_id": "77e44433eb9708a8ef5eda383a2c026d4fb7d0c7a4c9dadabf159e5498c71939",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/dpot-dac.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/err.h>\n#include <linux/iio/consumer.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\nstruct dpot_dac {\n\tstruct regulator *vref;\n\tstruct iio_channel *dpot;\n\tu32 max_ohms;\n};\n\nstatic const struct iio_chan_spec dpot_dac_iio_channel = {\n\t.type = IIO_VOLTAGE,\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)\n\t\t\t    | BIT(IIO_CHAN_INFO_SCALE),\n\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_RAW),\n\t.output = 1,\n\t.indexed = 1,\n};\n\nstatic int dpot_dac_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct dpot_dac *dac = iio_priv(indio_dev);\n\tint ret;\n\tunsigned long long tmp;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn iio_read_channel_raw(dac->dpot, val);\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = iio_read_channel_scale(dac->dpot, val, val2);\n\t\tswitch (ret) {\n\t\tcase IIO_VAL_FRACTIONAL_LOG2:\n\t\t\ttmp = *val * 1000000000LL;\n\t\t\tdo_div(tmp, dac->max_ohms);\n\t\t\ttmp *= regulator_get_voltage(dac->vref) / 1000;\n\t\t\tdo_div(tmp, 1000000000LL);\n\t\t\t*val = tmp;\n\t\t\treturn ret;\n\t\tcase IIO_VAL_INT:\n\t\t\t \n\t\t\t*val2 = 1;\n\t\t\tret = IIO_VAL_FRACTIONAL;\n\t\t\t \n\t\t\tfallthrough;\n\t\tcase IIO_VAL_FRACTIONAL:\n\t\t\t*val *= regulator_get_voltage(dac->vref) / 1000;\n\t\t\t*val2 *= dac->max_ohms;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int dpot_dac_read_avail(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length,\n\t\t\t       long mask)\n{\n\tstruct dpot_dac *dac = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*type = IIO_VAL_INT;\n\t\treturn iio_read_avail_channel_raw(dac->dpot, vals, length);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int dpot_dac_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tstruct dpot_dac *dac = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn iio_write_channel_raw(dac->dpot, val);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info dpot_dac_info = {\n\t.read_raw = dpot_dac_read_raw,\n\t.read_avail = dpot_dac_read_avail,\n\t.write_raw = dpot_dac_write_raw,\n};\n\nstatic int dpot_dac_channel_max_ohms(struct iio_dev *indio_dev)\n{\n\tstruct device *dev = &indio_dev->dev;\n\tstruct dpot_dac *dac = iio_priv(indio_dev);\n\tunsigned long long tmp;\n\tint ret;\n\tint val;\n\tint val2;\n\tint max;\n\n\tret = iio_read_max_channel_raw(dac->dpot, &max);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"dpot does not indicate its raw maximum value\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (iio_read_channel_scale(dac->dpot, &val, &val2)) {\n\tcase IIO_VAL_INT:\n\t\treturn max * val;\n\tcase IIO_VAL_FRACTIONAL:\n\t\ttmp = (unsigned long long)max * val;\n\t\tdo_div(tmp, val2);\n\t\treturn tmp;\n\tcase IIO_VAL_FRACTIONAL_LOG2:\n\t\ttmp = val * 1000000000LL * max >> val2;\n\t\tdo_div(tmp, 1000000000LL);\n\t\treturn tmp;\n\tdefault:\n\t\tdev_err(dev, \"dpot has a scale that is too weird\\n\");\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int dpot_dac_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct dpot_dac *dac;\n\tenum iio_chan_type type;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*dac));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\tdac = iio_priv(indio_dev);\n\n\tindio_dev->name = dev_name(dev);\n\tindio_dev->info = &dpot_dac_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = &dpot_dac_iio_channel;\n\tindio_dev->num_channels = 1;\n\n\tdac->vref = devm_regulator_get(dev, \"vref\");\n\tif (IS_ERR(dac->vref))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(dac->vref),\n\t\t\t\t     \"failed to get vref regulator\\n\");\n\n\tdac->dpot = devm_iio_channel_get(dev, \"dpot\");\n\tif (IS_ERR(dac->dpot))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(dac->dpot),\n\t\t\t\t     \"failed to get dpot input channel\\n\");\n\n\tret = iio_get_channel_type(dac->dpot, &type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (type != IIO_RESISTANCE) {\n\t\tdev_err(dev, \"dpot is of the wrong type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = dpot_dac_channel_max_ohms(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tdac->max_ohms = ret;\n\n\tret = regulator_enable(dac->vref);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable the vref regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register iio device\\n\");\n\t\tgoto disable_reg;\n\t}\n\n\treturn 0;\n\ndisable_reg:\n\tregulator_disable(dac->vref);\n\treturn ret;\n}\n\nstatic int dpot_dac_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct dpot_dac *dac = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tregulator_disable(dac->vref);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id dpot_dac_match[] = {\n\t{ .compatible = \"dpot-dac\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, dpot_dac_match);\n\nstatic struct platform_driver dpot_dac_driver = {\n\t.probe = dpot_dac_probe,\n\t.remove = dpot_dac_remove,\n\t.driver = {\n\t\t.name = \"iio-dpot-dac\",\n\t\t.of_match_table = dpot_dac_match,\n\t},\n};\nmodule_platform_driver(dpot_dac_driver);\n\nMODULE_DESCRIPTION(\"DAC emulation driver using a digital potentiometer\");\nMODULE_AUTHOR(\"Peter Rosin <peda@axentia.se>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}