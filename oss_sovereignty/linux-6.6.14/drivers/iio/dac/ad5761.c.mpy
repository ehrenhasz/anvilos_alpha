{
  "module_name": "ad5761.c",
  "hash_id": "95fc7c038e90edd368620fae05162d095bf849cb6ddb7f33ed3037e3c462d36b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad5761.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <linux/bitops.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/regulator/consumer.h>\n#include <linux/platform_data/ad5761.h>\n\n#define AD5761_ADDR(addr)\t\t((addr & 0xf) << 16)\n#define AD5761_ADDR_NOOP\t\t0x0\n#define AD5761_ADDR_DAC_WRITE\t\t0x3\n#define AD5761_ADDR_CTRL_WRITE_REG\t0x4\n#define AD5761_ADDR_SW_DATA_RESET\t0x7\n#define AD5761_ADDR_DAC_READ\t\t0xb\n#define AD5761_ADDR_CTRL_READ_REG\t0xc\n#define AD5761_ADDR_SW_FULL_RESET\t0xf\n\n#define AD5761_CTRL_USE_INTVREF\t\tBIT(5)\n#define AD5761_CTRL_ETS\t\t\tBIT(6)\n\n \n\nstruct ad5761_chip_info {\n\tunsigned long int_vref;\n\tconst struct iio_chan_spec channel;\n};\n\nstruct ad5761_range_params {\n\tint m;\n\tint c;\n};\n\nenum ad5761_supported_device_ids {\n\tID_AD5721,\n\tID_AD5721R,\n\tID_AD5761,\n\tID_AD5761R,\n};\n\n \nstruct ad5761_state {\n\tstruct spi_device\t\t*spi;\n\tstruct regulator\t\t*vref_reg;\n\tstruct mutex\t\t\tlock;\n\n\tbool use_intref;\n\tint vref;\n\tenum ad5761_voltage_range range;\n\n\t \n\tunion {\n\t\t__be32 d32;\n\t\tu8 d8[4];\n\t} data[3] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic const struct ad5761_range_params ad5761_range_params[] = {\n\t[AD5761_VOLTAGE_RANGE_M10V_10V] = {\n\t\t.m = 80,\n\t\t.c = 40,\n\t},\n\t[AD5761_VOLTAGE_RANGE_0V_10V] = {\n\t\t.m = 40,\n\t\t.c = 0,\n\t},\n\t[AD5761_VOLTAGE_RANGE_M5V_5V] = {\n\t\t.m = 40,\n\t\t.c = 20,\n\t},\n\t[AD5761_VOLTAGE_RANGE_0V_5V] = {\n\t\t.m = 20,\n\t\t.c = 0,\n\t},\n\t[AD5761_VOLTAGE_RANGE_M2V5_7V5] = {\n\t\t.m = 40,\n\t\t.c = 10,\n\t},\n\t[AD5761_VOLTAGE_RANGE_M3V_3V] = {\n\t\t.m = 24,\n\t\t.c = 12,\n\t},\n\t[AD5761_VOLTAGE_RANGE_0V_16V] = {\n\t\t.m = 64,\n\t\t.c = 0,\n\t},\n\t[AD5761_VOLTAGE_RANGE_0V_20V] = {\n\t\t.m = 80,\n\t\t.c = 0,\n\t},\n};\n\nstatic int _ad5761_spi_write(struct ad5761_state *st, u8 addr, u16 val)\n{\n\tst->data[0].d32 = cpu_to_be32(AD5761_ADDR(addr) | val);\n\n\treturn spi_write(st->spi, &st->data[0].d8[1], 3);\n}\n\nstatic int ad5761_spi_write(struct iio_dev *indio_dev, u8 addr, u16 val)\n{\n\tstruct ad5761_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = _ad5761_spi_write(st, addr, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int _ad5761_spi_read(struct ad5761_state *st, u8 addr, u16 *val)\n{\n\tint ret;\n\tstruct spi_transfer xfers[] = {\n\t\t{\n\t\t\t.tx_buf = &st->data[0].d8[1],\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = 3,\n\t\t\t.cs_change = true,\n\t\t}, {\n\t\t\t.tx_buf = &st->data[1].d8[1],\n\t\t\t.rx_buf = &st->data[2].d8[1],\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = 3,\n\t\t},\n\t};\n\n\tst->data[0].d32 = cpu_to_be32(AD5761_ADDR(addr));\n\tst->data[1].d32 = cpu_to_be32(AD5761_ADDR(AD5761_ADDR_NOOP));\n\n\tret = spi_sync_transfer(st->spi, xfers, ARRAY_SIZE(xfers));\n\n\t*val = be32_to_cpu(st->data[2].d32);\n\n\treturn ret;\n}\n\nstatic int ad5761_spi_read(struct iio_dev *indio_dev, u8 addr, u16 *val)\n{\n\tstruct ad5761_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = _ad5761_spi_read(st, addr, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad5761_spi_set_range(struct ad5761_state *st,\n\t\t\t\tenum ad5761_voltage_range range)\n{\n\tu16 aux;\n\tint ret;\n\n\taux = (range & 0x7) | AD5761_CTRL_ETS;\n\n\tif (st->use_intref)\n\t\taux |= AD5761_CTRL_USE_INTVREF;\n\n\tret = _ad5761_spi_write(st, AD5761_ADDR_SW_FULL_RESET, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = _ad5761_spi_write(st, AD5761_ADDR_CTRL_WRITE_REG, aux);\n\tif (ret)\n\t\treturn ret;\n\n\tst->range = range;\n\n\treturn 0;\n}\n\nstatic int ad5761_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long mask)\n{\n\tstruct ad5761_state *st;\n\tint ret;\n\tu16 aux;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = ad5761_spi_read(indio_dev, AD5761_ADDR_DAC_READ, &aux);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*val = aux >> chan->scan_type.shift;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tst = iio_priv(indio_dev);\n\t\t*val = st->vref * ad5761_range_params[st->range].m;\n\t\t*val /= 10;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tst = iio_priv(indio_dev);\n\t\t*val = -(1 << chan->scan_type.realbits);\n\t\t*val *=\tad5761_range_params[st->range].c;\n\t\t*val /=\tad5761_range_params[st->range].m;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad5761_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val,\n\t\t\t    int val2,\n\t\t\t    long mask)\n{\n\tu16 aux;\n\n\tif (mask != IIO_CHAN_INFO_RAW)\n\t\treturn -EINVAL;\n\n\tif (val2 || (val << chan->scan_type.shift) > 0xffff || val < 0)\n\t\treturn -EINVAL;\n\n\taux = val << chan->scan_type.shift;\n\n\treturn ad5761_spi_write(indio_dev, AD5761_ADDR_DAC_WRITE, aux);\n}\n\nstatic const struct iio_info ad5761_info = {\n\t.read_raw = &ad5761_read_raw,\n\t.write_raw = &ad5761_write_raw,\n};\n\n#define AD5761_CHAN(_bits) {\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\tBIT(IIO_CHAN_INFO_OFFSET),\t\t\\\n\t.scan_type = {\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\\\n\t\t.realbits = (_bits),\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\\\n\t\t.shift = 16 - (_bits),\t\t\t\\\n\t},\t\t\t\t\t\t\\\n}\n\nstatic const struct ad5761_chip_info ad5761_chip_infos[] = {\n\t[ID_AD5721] = {\n\t\t.int_vref = 0,\n\t\t.channel = AD5761_CHAN(12),\n\t},\n\t[ID_AD5721R] = {\n\t\t.int_vref = 2500,\n\t\t.channel = AD5761_CHAN(12),\n\t},\n\t[ID_AD5761] = {\n\t\t.int_vref = 0,\n\t\t.channel = AD5761_CHAN(16),\n\t},\n\t[ID_AD5761R] = {\n\t\t.int_vref = 2500,\n\t\t.channel = AD5761_CHAN(16),\n\t},\n};\n\nstatic int ad5761_get_vref(struct ad5761_state *st,\n\t\t\t   const struct ad5761_chip_info *chip_info)\n{\n\tint ret;\n\n\tst->vref_reg = devm_regulator_get_optional(&st->spi->dev, \"vref\");\n\tif (PTR_ERR(st->vref_reg) == -ENODEV) {\n\t\t \n\t\tif (!chip_info->int_vref) {\n\t\t\tdev_err(&st->spi->dev,\n\t\t\t\t\"Voltage reference not found\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tst->use_intref = true;\n\t\tst->vref = chip_info->int_vref;\n\t\treturn 0;\n\t}\n\n\tif (IS_ERR(st->vref_reg)) {\n\t\tdev_err(&st->spi->dev,\n\t\t\t\"Error getting voltage reference regulator\\n\");\n\t\treturn PTR_ERR(st->vref_reg);\n\t}\n\n\tret = regulator_enable(st->vref_reg);\n\tif (ret) {\n\t\tdev_err(&st->spi->dev,\n\t\t\t \"Failed to enable voltage reference\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_get_voltage(st->vref_reg);\n\tif (ret < 0) {\n\t\tdev_err(&st->spi->dev,\n\t\t\t \"Failed to get voltage reference value\\n\");\n\t\tgoto disable_regulator_vref;\n\t}\n\n\tif (ret < 2000000 || ret > 3000000) {\n\t\tdev_warn(&st->spi->dev,\n\t\t\t \"Invalid external voltage ref. value %d uV\\n\", ret);\n\t\tret = -EIO;\n\t\tgoto disable_regulator_vref;\n\t}\n\n\tst->vref = ret / 1000;\n\tst->use_intref = false;\n\n\treturn 0;\n\ndisable_regulator_vref:\n\tregulator_disable(st->vref_reg);\n\tst->vref_reg = NULL;\n\treturn ret;\n}\n\nstatic int ad5761_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *iio_dev;\n\tstruct ad5761_state *st;\n\tint ret;\n\tconst struct ad5761_chip_info *chip_info =\n\t\t&ad5761_chip_infos[spi_get_device_id(spi)->driver_data];\n\tenum ad5761_voltage_range voltage_range = AD5761_VOLTAGE_RANGE_0V_5V;\n\tstruct ad5761_platform_data *pdata = dev_get_platdata(&spi->dev);\n\n\tiio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!iio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(iio_dev);\n\n\tst->spi = spi;\n\tspi_set_drvdata(spi, iio_dev);\n\n\tret = ad5761_get_vref(st, chip_info);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pdata)\n\t\tvoltage_range = pdata->voltage_range;\n\n\tmutex_init(&st->lock);\n\n\tret = ad5761_spi_set_range(st, voltage_range);\n\tif (ret)\n\t\tgoto disable_regulator_err;\n\n\tiio_dev->info = &ad5761_info;\n\tiio_dev->modes = INDIO_DIRECT_MODE;\n\tiio_dev->channels = &chip_info->channel;\n\tiio_dev->num_channels = 1;\n\tiio_dev->name = spi_get_device_id(st->spi)->name;\n\tret = iio_device_register(iio_dev);\n\tif (ret)\n\t\tgoto disable_regulator_err;\n\n\treturn 0;\n\ndisable_regulator_err:\n\tif (!IS_ERR_OR_NULL(st->vref_reg))\n\t\tregulator_disable(st->vref_reg);\n\n\treturn ret;\n}\n\nstatic void ad5761_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *iio_dev = spi_get_drvdata(spi);\n\tstruct ad5761_state *st = iio_priv(iio_dev);\n\n\tiio_device_unregister(iio_dev);\n\n\tif (!IS_ERR_OR_NULL(st->vref_reg))\n\t\tregulator_disable(st->vref_reg);\n}\n\nstatic const struct spi_device_id ad5761_id[] = {\n\t{\"ad5721\", ID_AD5721},\n\t{\"ad5721r\", ID_AD5721R},\n\t{\"ad5761\", ID_AD5761},\n\t{\"ad5761r\", ID_AD5761R},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad5761_id);\n\nstatic struct spi_driver ad5761_driver = {\n\t.driver = {\n\t\t   .name = \"ad5761\",\n\t\t   },\n\t.probe = ad5761_probe,\n\t.remove = ad5761_remove,\n\t.id_table = ad5761_id,\n};\nmodule_spi_driver(ad5761_driver);\n\nMODULE_AUTHOR(\"Ricardo Ribalda <ribalda@kernel.org>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5721, AD5721R, AD5761, AD5761R driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}