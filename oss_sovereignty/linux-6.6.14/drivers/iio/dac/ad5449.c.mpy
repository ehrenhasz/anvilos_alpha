{
  "module_name": "ad5449.c",
  "hash_id": "0591049d9f59ed1ddb8a85d24f7fe6534b091ae373cf071ad6b89e76fc358086",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad5449.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/regulator/consumer.h>\n#include <asm/unaligned.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#include <linux/platform_data/ad5449.h>\n\n#define AD5449_MAX_CHANNELS\t\t2\n#define AD5449_MAX_VREFS\t\t2\n\n#define AD5449_CMD_NOOP\t\t\t0x0\n#define AD5449_CMD_LOAD_AND_UPDATE(x)\t(0x1 + (x) * 3)\n#define AD5449_CMD_READ(x)\t\t(0x2 + (x) * 3)\n#define AD5449_CMD_LOAD(x)\t\t(0x3 + (x) * 3)\n#define AD5449_CMD_CTRL\t\t\t13\n\n#define AD5449_CTRL_SDO_OFFSET\t\t10\n#define AD5449_CTRL_DAISY_CHAIN\t\tBIT(9)\n#define AD5449_CTRL_HCLR_TO_MIDSCALE\tBIT(8)\n#define AD5449_CTRL_SAMPLE_RISING\tBIT(7)\n\n \nstruct ad5449_chip_info {\n\tconst struct iio_chan_spec *channels;\n\tunsigned int num_channels;\n\tbool has_ctrl;\n};\n\n \nstruct ad5449 {\n\tstruct spi_device\t\t*spi;\n\tconst struct ad5449_chip_info\t*chip_info;\n\tstruct regulator_bulk_data\tvref_reg[AD5449_MAX_VREFS];\n\tstruct mutex\t\t\tlock;\n\n\tbool has_sdo;\n\tuint16_t dac_cache[AD5449_MAX_CHANNELS];\n\n\t \n\t__be16 data[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nenum ad5449_type {\n\tID_AD5426,\n\tID_AD5429,\n\tID_AD5432,\n\tID_AD5439,\n\tID_AD5443,\n\tID_AD5449,\n};\n\nstatic int ad5449_write(struct iio_dev *indio_dev, unsigned int addr,\n\tunsigned int val)\n{\n\tstruct ad5449 *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tst->data[0] = cpu_to_be16((addr << 12) | val);\n\tret = spi_write(st->spi, st->data, 2);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad5449_read(struct iio_dev *indio_dev, unsigned int addr,\n\tunsigned int *val)\n{\n\tstruct ad5449 *st = iio_priv(indio_dev);\n\tint ret;\n\tstruct spi_transfer t[] = {\n\t\t{\n\t\t\t.tx_buf = &st->data[0],\n\t\t\t.len = 2,\n\t\t\t.cs_change = 1,\n\t\t}, {\n\t\t\t.tx_buf = &st->data[1],\n\t\t\t.rx_buf = &st->data[1],\n\t\t\t.len = 2,\n\t\t},\n\t};\n\n\tmutex_lock(&st->lock);\n\tst->data[0] = cpu_to_be16(addr << 12);\n\tst->data[1] = cpu_to_be16(AD5449_CMD_NOOP);\n\n\tret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\t*val = be16_to_cpu(st->data[1]);\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic int ad5449_read_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int *val, int *val2, long info)\n{\n\tstruct ad5449 *st = iio_priv(indio_dev);\n\tstruct regulator_bulk_data *reg;\n\tint scale_uv;\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (st->has_sdo) {\n\t\t\tret = ad5449_read(indio_dev,\n\t\t\t\tAD5449_CMD_READ(chan->address), val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\t*val &= 0xfff;\n\t\t} else {\n\t\t\t*val = st->dac_cache[chan->address];\n\t\t}\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treg = &st->vref_reg[chan->channel];\n\t\tscale_uv = regulator_get_voltage(reg->consumer);\n\t\tif (scale_uv < 0)\n\t\t\treturn scale_uv;\n\n\t\t*val = scale_uv / 1000;\n\t\t*val2 = chan->scan_type.realbits;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ad5449_write_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int val, int val2, long info)\n{\n\tstruct ad5449 *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val < 0 || val >= (1 << chan->scan_type.realbits))\n\t\t\treturn -EINVAL;\n\n\t\tret = ad5449_write(indio_dev,\n\t\t\tAD5449_CMD_LOAD_AND_UPDATE(chan->address),\n\t\t\tval << chan->scan_type.shift);\n\t\tif (ret == 0)\n\t\t\tst->dac_cache[chan->address] = val;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct iio_info ad5449_info = {\n\t.read_raw = ad5449_read_raw,\n\t.write_raw = ad5449_write_raw,\n};\n\n#define AD5449_CHANNEL(chan, bits) {\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\\\n\t.channel = (chan),\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_SCALE),\t\t\t\\\n\t.address = (chan),\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = (bits),\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.shift = 12 - (bits),\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\n#define DECLARE_AD5449_CHANNELS(name, bits) \\\nconst struct iio_chan_spec name[] = { \\\n\tAD5449_CHANNEL(0, bits), \\\n\tAD5449_CHANNEL(1, bits), \\\n}\n\nstatic DECLARE_AD5449_CHANNELS(ad5429_channels, 8);\nstatic DECLARE_AD5449_CHANNELS(ad5439_channels, 10);\nstatic DECLARE_AD5449_CHANNELS(ad5449_channels, 12);\n\nstatic const struct ad5449_chip_info ad5449_chip_info[] = {\n\t[ID_AD5426] = {\n\t\t.channels = ad5429_channels,\n\t\t.num_channels = 1,\n\t\t.has_ctrl = false,\n\t},\n\t[ID_AD5429] = {\n\t\t.channels = ad5429_channels,\n\t\t.num_channels = 2,\n\t\t.has_ctrl = true,\n\t},\n\t[ID_AD5432] = {\n\t\t.channels = ad5439_channels,\n\t\t.num_channels = 1,\n\t\t.has_ctrl = false,\n\t},\n\t[ID_AD5439] = {\n\t\t.channels = ad5439_channels,\n\t\t.num_channels = 2,\n\t\t.has_ctrl = true,\n\t},\n\t[ID_AD5443] = {\n\t\t.channels = ad5449_channels,\n\t\t.num_channels = 1,\n\t\t.has_ctrl = false,\n\t},\n\t[ID_AD5449] = {\n\t\t.channels = ad5449_channels,\n\t\t.num_channels = 2,\n\t\t.has_ctrl = true,\n\t},\n};\n\nstatic const char *ad5449_vref_name(struct ad5449 *st, int n)\n{\n\tif (st->chip_info->num_channels == 1)\n\t\treturn \"VREF\";\n\n\tif (n == 0)\n\t\treturn \"VREFA\";\n\telse\n\t\treturn \"VREFB\";\n}\n\nstatic int ad5449_spi_probe(struct spi_device *spi)\n{\n\tstruct ad5449_platform_data *pdata = spi->dev.platform_data;\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tstruct iio_dev *indio_dev;\n\tstruct ad5449 *st;\n\tunsigned int i;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tspi_set_drvdata(spi, indio_dev);\n\n\tst->chip_info = &ad5449_chip_info[id->driver_data];\n\tst->spi = spi;\n\n\tfor (i = 0; i < st->chip_info->num_channels; ++i)\n\t\tst->vref_reg[i].supply = ad5449_vref_name(st, i);\n\n\tret = devm_regulator_bulk_get(&spi->dev, st->chip_info->num_channels,\n\t\t\t\tst->vref_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_bulk_enable(st->chip_info->num_channels, st->vref_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->name = id->name;\n\tindio_dev->info = &ad5449_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = st->chip_info->channels;\n\tindio_dev->num_channels = st->chip_info->num_channels;\n\n\tmutex_init(&st->lock);\n\n\tif (st->chip_info->has_ctrl) {\n\t\tunsigned int ctrl = 0x00;\n\t\tif (pdata) {\n\t\t\tif (pdata->hardware_clear_to_midscale)\n\t\t\t\tctrl |= AD5449_CTRL_HCLR_TO_MIDSCALE;\n\t\t\tctrl |= pdata->sdo_mode << AD5449_CTRL_SDO_OFFSET;\n\t\t\tst->has_sdo = pdata->sdo_mode != AD5449_SDO_DISABLED;\n\t\t} else {\n\t\t\tst->has_sdo = true;\n\t\t}\n\t\tad5449_write(indio_dev, AD5449_CMD_CTRL, ctrl);\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto error_disable_reg;\n\n\treturn 0;\n\nerror_disable_reg:\n\tregulator_bulk_disable(st->chip_info->num_channels, st->vref_reg);\n\n\treturn ret;\n}\n\nstatic void ad5449_spi_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct ad5449 *st = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tregulator_bulk_disable(st->chip_info->num_channels, st->vref_reg);\n}\n\nstatic const struct spi_device_id ad5449_spi_ids[] = {\n\t{ \"ad5415\", ID_AD5449 },\n\t{ \"ad5426\", ID_AD5426 },\n\t{ \"ad5429\", ID_AD5429 },\n\t{ \"ad5432\", ID_AD5432 },\n\t{ \"ad5439\", ID_AD5439 },\n\t{ \"ad5443\", ID_AD5443 },\n\t{ \"ad5449\", ID_AD5449 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad5449_spi_ids);\n\nstatic struct spi_driver ad5449_spi_driver = {\n\t.driver = {\n\t\t.name = \"ad5449\",\n\t},\n\t.probe = ad5449_spi_probe,\n\t.remove = ad5449_spi_remove,\n\t.id_table = ad5449_spi_ids,\n};\nmodule_spi_driver(ad5449_spi_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5449 and similar DACs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}