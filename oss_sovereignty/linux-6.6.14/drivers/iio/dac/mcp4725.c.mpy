{
  "module_name": "mcp4725.c",
  "hash_id": "d8cfc8b21d0e9edefc0a5f15fb8028b927ca7b2df44fcbf47f8a88b707dc323f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/mcp4725.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/regulator/consumer.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#include <linux/iio/dac/mcp4725.h>\n\n#define MCP4725_DRV_NAME \"mcp4725\"\n\n#define MCP472X_REF_VDD\t\t\t0x00\n#define MCP472X_REF_VREF_UNBUFFERED\t0x02\n#define MCP472X_REF_VREF_BUFFERED\t0x03\n\nstruct mcp4725_data {\n\tstruct i2c_client *client;\n\tint id;\n\tunsigned ref_mode;\n\tbool vref_buffered;\n\tu16 dac_value;\n\tbool powerdown;\n\tunsigned powerdown_mode;\n\tstruct regulator *vdd_reg;\n\tstruct regulator *vref_reg;\n};\n\nstatic int mcp4725_suspend(struct device *dev)\n{\n\tstruct mcp4725_data *data = iio_priv(i2c_get_clientdata(\n\t\tto_i2c_client(dev)));\n\tu8 outbuf[2];\n\tint ret;\n\n\toutbuf[0] = (data->powerdown_mode + 1) << 4;\n\toutbuf[1] = 0;\n\tdata->powerdown = true;\n\n\tret = i2c_master_send(data->client, outbuf, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != 2)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int mcp4725_resume(struct device *dev)\n{\n\tstruct mcp4725_data *data = iio_priv(i2c_get_clientdata(\n\t\tto_i2c_client(dev)));\n\tu8 outbuf[2];\n\tint ret;\n\n\t \n\toutbuf[0] = (data->dac_value >> 8) & 0xf;\n\toutbuf[1] = data->dac_value & 0xff;\n\tdata->powerdown = false;\n\n\tret = i2c_master_send(data->client, outbuf, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != 2)\n\t\treturn -EIO;\n\treturn 0;\n}\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mcp4725_pm_ops, mcp4725_suspend,\n\t\t\t\tmcp4725_resume);\n\nstatic ssize_t mcp4725_store_eeprom(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct mcp4725_data *data = iio_priv(indio_dev);\n\tint tries = 20;\n\tu8 inoutbuf[3];\n\tbool state;\n\tint ret;\n\n\tret = kstrtobool(buf, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!state)\n\t\treturn 0;\n\n\tinoutbuf[0] = 0x60;  \n\tinoutbuf[0] |= data->ref_mode << 3;\n\tinoutbuf[0] |= data->powerdown ? ((data->powerdown_mode + 1) << 1) : 0;\n\tinoutbuf[1] = data->dac_value >> 4;\n\tinoutbuf[2] = (data->dac_value & 0xf) << 4;\n\n\tret = i2c_master_send(data->client, inoutbuf, 3);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != 3)\n\t\treturn -EIO;\n\n\t \n\twhile (tries--) {\n\t\tmsleep(20);\n\t\tret = i2c_master_recv(data->client, inoutbuf, 3);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret != 3)\n\t\t\treturn -EIO;\n\n\t\tif (inoutbuf[0] & 0x80)\n\t\t\tbreak;\n\t}\n\n\tif (tries < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"mcp4725_store_eeprom() failed, incomplete\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(store_eeprom, S_IWUSR, NULL, mcp4725_store_eeprom, 0);\n\nstatic struct attribute *mcp4725_attributes[] = {\n\t&iio_dev_attr_store_eeprom.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mcp4725_attribute_group = {\n\t.attrs = mcp4725_attributes,\n};\n\nstatic const char * const mcp4725_powerdown_modes[] = {\n\t\"1kohm_to_gnd\",\n\t\"100kohm_to_gnd\",\n\t\"500kohm_to_gnd\"\n};\n\nstatic const char * const mcp4726_powerdown_modes[] = {\n\t\"1kohm_to_gnd\",\n\t\"125kohm_to_gnd\",\n\t\"640kohm_to_gnd\"\n};\n\nstatic int mcp4725_get_powerdown_mode(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan)\n{\n\tstruct mcp4725_data *data = iio_priv(indio_dev);\n\n\treturn data->powerdown_mode;\n}\n\nstatic int mcp4725_set_powerdown_mode(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, unsigned mode)\n{\n\tstruct mcp4725_data *data = iio_priv(indio_dev);\n\n\tdata->powerdown_mode = mode;\n\n\treturn 0;\n}\n\nstatic ssize_t mcp4725_read_powerdown(struct iio_dev *indio_dev,\n\tuintptr_t private, const struct iio_chan_spec *chan, char *buf)\n{\n\tstruct mcp4725_data *data = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", data->powerdown);\n}\n\nstatic ssize_t mcp4725_write_powerdown(struct iio_dev *indio_dev,\n\t uintptr_t private, const struct iio_chan_spec *chan,\n\t const char *buf, size_t len)\n{\n\tstruct mcp4725_data *data = iio_priv(indio_dev);\n\tbool state;\n\tint ret;\n\n\tret = kstrtobool(buf, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (state)\n\t\tret = mcp4725_suspend(&data->client->dev);\n\telse\n\t\tret = mcp4725_resume(&data->client->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn len;\n}\n\nenum chip_id {\n\tMCP4725,\n\tMCP4726,\n};\n\nstatic const struct iio_enum mcp472x_powerdown_mode_enum[] = {\n\t[MCP4725] = {\n\t\t.items = mcp4725_powerdown_modes,\n\t\t.num_items = ARRAY_SIZE(mcp4725_powerdown_modes),\n\t\t.get = mcp4725_get_powerdown_mode,\n\t\t.set = mcp4725_set_powerdown_mode,\n\t},\n\t[MCP4726] = {\n\t\t.items = mcp4726_powerdown_modes,\n\t\t.num_items = ARRAY_SIZE(mcp4726_powerdown_modes),\n\t\t.get = mcp4725_get_powerdown_mode,\n\t\t.set = mcp4725_set_powerdown_mode,\n\t},\n};\n\nstatic const struct iio_chan_spec_ext_info mcp4725_ext_info[] = {\n\t{\n\t\t.name = \"powerdown\",\n\t\t.read = mcp4725_read_powerdown,\n\t\t.write = mcp4725_write_powerdown,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\tIIO_ENUM(\"powerdown_mode\", IIO_SEPARATE,\n\t\t\t&mcp472x_powerdown_mode_enum[MCP4725]),\n\tIIO_ENUM_AVAILABLE(\"powerdown_mode\", IIO_SHARED_BY_TYPE,\n\t\t\t   &mcp472x_powerdown_mode_enum[MCP4725]),\n\t{ },\n};\n\nstatic const struct iio_chan_spec_ext_info mcp4726_ext_info[] = {\n\t{\n\t\t.name = \"powerdown\",\n\t\t.read = mcp4725_read_powerdown,\n\t\t.write = mcp4725_write_powerdown,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\tIIO_ENUM(\"powerdown_mode\", IIO_SEPARATE,\n\t\t\t&mcp472x_powerdown_mode_enum[MCP4726]),\n\tIIO_ENUM_AVAILABLE(\"powerdown_mode\", IIO_SHARED_BY_TYPE,\n\t\t\t   &mcp472x_powerdown_mode_enum[MCP4726]),\n\t{ },\n};\n\nstatic const struct iio_chan_spec mcp472x_channel[] = {\n\t[MCP4725] = {\n\t\t.type\t\t= IIO_VOLTAGE,\n\t\t.indexed\t= 1,\n\t\t.output\t\t= 1,\n\t\t.channel\t= 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t\t.ext_info\t= mcp4725_ext_info,\n\t},\n\t[MCP4726] = {\n\t\t.type\t\t= IIO_VOLTAGE,\n\t\t.indexed\t= 1,\n\t\t.output\t\t= 1,\n\t\t.channel\t= 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t\t.ext_info\t= mcp4726_ext_info,\n\t},\n};\n\nstatic int mcp4725_set_value(struct iio_dev *indio_dev, int val)\n{\n\tstruct mcp4725_data *data = iio_priv(indio_dev);\n\tu8 outbuf[2];\n\tint ret;\n\n\tif (val >= (1 << 12) || val < 0)\n\t\treturn -EINVAL;\n\n\toutbuf[0] = (val >> 8) & 0xf;\n\toutbuf[1] = val & 0xff;\n\n\tret = i2c_master_send(data->client, outbuf, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != 2)\n\t\treturn -EIO;\n\telse\n\t\treturn 0;\n}\n\nstatic int mcp4726_set_cfg(struct iio_dev *indio_dev)\n{\n\tstruct mcp4725_data *data = iio_priv(indio_dev);\n\tu8 outbuf[3];\n\tint ret;\n\n\toutbuf[0] = 0x40;\n\toutbuf[0] |= data->ref_mode << 3;\n\tif (data->powerdown)\n\t\toutbuf[0] |= data->powerdown << 1;\n\toutbuf[1] = data->dac_value >> 4;\n\toutbuf[2] = (data->dac_value & 0xf) << 4;\n\n\tret = i2c_master_send(data->client, outbuf, 3);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != 3)\n\t\treturn -EIO;\n\telse\n\t\treturn 0;\n}\n\nstatic int mcp4725_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct mcp4725_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*val = data->dac_value;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (data->ref_mode == MCP472X_REF_VDD)\n\t\t\tret = regulator_get_voltage(data->vdd_reg);\n\t\telse\n\t\t\tret = regulator_get_voltage(data->vref_reg);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret / 1000;\n\t\t*val2 = 12;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int mcp4725_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val, int val2, long mask)\n{\n\tstruct mcp4725_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = mcp4725_set_value(indio_dev, val);\n\t\tdata->dac_value = val;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct iio_info mcp4725_info = {\n\t.read_raw = mcp4725_read_raw,\n\t.write_raw = mcp4725_write_raw,\n\t.attrs = &mcp4725_attribute_group,\n};\n\nstatic int mcp4725_probe_dt(struct device *dev,\n\t\t\t    struct mcp4725_platform_data *pdata)\n{\n\t \n\tpdata->use_vref = device_property_read_bool(dev, \"vref-supply\");\n\tpdata->vref_buffered =\n\t\tdevice_property_read_bool(dev, \"microchip,vref-buffered\");\n\n\treturn 0;\n}\n\nstatic int mcp4725_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct mcp4725_data *data;\n\tstruct iio_dev *indio_dev;\n\tstruct mcp4725_platform_data *pdata, pdata_dt;\n\tu8 inbuf[4];\n\tu8 pd;\n\tu8 ref;\n\tint err;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tif (dev_fwnode(&client->dev))\n\t\tdata->id = (uintptr_t)device_get_match_data(&client->dev);\n\telse\n\t\tdata->id = id->driver_data;\n\tpdata = dev_get_platdata(&client->dev);\n\n\tif (!pdata) {\n\t\terr = mcp4725_probe_dt(&client->dev, &pdata_dt);\n\t\tif (err) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"invalid platform or devicetree data\");\n\t\t\treturn err;\n\t\t}\n\t\tpdata = &pdata_dt;\n\t}\n\n\tif (data->id == MCP4725 && pdata->use_vref) {\n\t\tdev_err(&client->dev,\n\t\t\t\"external reference is unavailable on MCP4725\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pdata->use_vref && pdata->vref_buffered) {\n\t\tdev_err(&client->dev,\n\t\t\t\"buffering is unavailable on the internal reference\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pdata->use_vref)\n\t\tdata->ref_mode = MCP472X_REF_VDD;\n\telse\n\t\tdata->ref_mode = pdata->vref_buffered ?\n\t\t\tMCP472X_REF_VREF_BUFFERED :\n\t\t\tMCP472X_REF_VREF_UNBUFFERED;\n\n\tdata->vdd_reg = devm_regulator_get(&client->dev, \"vdd\");\n\tif (IS_ERR(data->vdd_reg))\n\t\treturn PTR_ERR(data->vdd_reg);\n\n\terr = regulator_enable(data->vdd_reg);\n\tif (err)\n\t\treturn err;\n\n\tif (pdata->use_vref) {\n\t\tdata->vref_reg = devm_regulator_get(&client->dev, \"vref\");\n\t\tif (IS_ERR(data->vref_reg)) {\n\t\t\terr = PTR_ERR(data->vref_reg);\n\t\t\tgoto err_disable_vdd_reg;\n\t\t}\n\n\t\terr = regulator_enable(data->vref_reg);\n\t\tif (err)\n\t\t\tgoto err_disable_vdd_reg;\n\t}\n\n\tindio_dev->name = id->name;\n\tindio_dev->info = &mcp4725_info;\n\tindio_dev->channels = &mcp472x_channel[id->driver_data];\n\tindio_dev->num_channels = 1;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\t \n\terr = i2c_master_recv(client, inbuf, data->id == MCP4725 ? 3 : 4);\n\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"failed to read DAC value\");\n\t\tgoto err_disable_vref_reg;\n\t}\n\tpd = (inbuf[0] >> 1) & 0x3;\n\tdata->powerdown = pd > 0;\n\tdata->powerdown_mode = pd ? pd - 1 : 2;  \n\tdata->dac_value = (inbuf[1] << 4) | (inbuf[2] >> 4);\n\tif (data->id == MCP4726)\n\t\tref = (inbuf[3] >> 3) & 0x3;\n\n\tif (data->id == MCP4726 && ref != data->ref_mode) {\n\t\tdev_info(&client->dev,\n\t\t\t\"voltage reference mode differs (conf: %u, eeprom: %u), setting %u\",\n\t\t\tdata->ref_mode, ref, data->ref_mode);\n\t\terr = mcp4726_set_cfg(indio_dev);\n\t\tif (err < 0)\n\t\t\tgoto err_disable_vref_reg;\n\t}\n \n\terr = iio_device_register(indio_dev);\n\tif (err)\n\t\tgoto err_disable_vref_reg;\n\n\treturn 0;\n\nerr_disable_vref_reg:\n\tif (data->vref_reg)\n\t\tregulator_disable(data->vref_reg);\n\nerr_disable_vdd_reg:\n\tregulator_disable(data->vdd_reg);\n\n\treturn err;\n}\n\nstatic void mcp4725_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct mcp4725_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tif (data->vref_reg)\n\t\tregulator_disable(data->vref_reg);\n\tregulator_disable(data->vdd_reg);\n}\n\nstatic const struct i2c_device_id mcp4725_id[] = {\n\t{ \"mcp4725\", MCP4725 },\n\t{ \"mcp4726\", MCP4726 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mcp4725_id);\n\nstatic const struct of_device_id mcp4725_of_match[] = {\n\t{\n\t\t.compatible = \"microchip,mcp4725\",\n\t\t.data = (void *)MCP4725\n\t},\n\t{\n\t\t.compatible = \"microchip,mcp4726\",\n\t\t.data = (void *)MCP4726\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mcp4725_of_match);\n\nstatic struct i2c_driver mcp4725_driver = {\n\t.driver = {\n\t\t.name\t= MCP4725_DRV_NAME,\n\t\t.of_match_table = mcp4725_of_match,\n\t\t.pm\t= pm_sleep_ptr(&mcp4725_pm_ops),\n\t},\n\t.probe\t\t= mcp4725_probe,\n\t.remove\t\t= mcp4725_remove,\n\t.id_table\t= mcp4725_id,\n};\nmodule_i2c_driver(mcp4725_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"MCP4725/6 12-bit DAC\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}