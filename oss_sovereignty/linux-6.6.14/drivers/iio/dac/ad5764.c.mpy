{
  "module_name": "ad5764.c",
  "hash_id": "457aead644111f2386bb999b8bf703de03b3d3f6037dfb1050aa79345744881e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad5764.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define AD5764_REG_SF_NOP\t\t\t0x0\n#define AD5764_REG_SF_CONFIG\t\t\t0x1\n#define AD5764_REG_SF_CLEAR\t\t\t0x4\n#define AD5764_REG_SF_LOAD\t\t\t0x5\n#define AD5764_REG_DATA(x)\t\t\t((2 << 3) | (x))\n#define AD5764_REG_COARSE_GAIN(x)\t\t((3 << 3) | (x))\n#define AD5764_REG_FINE_GAIN(x)\t\t\t((4 << 3) | (x))\n#define AD5764_REG_OFFSET(x)\t\t\t((5 << 3) | (x))\n\n#define AD5764_NUM_CHANNELS 4\n\n \nstruct ad5764_chip_info {\n\tunsigned long int_vref;\n\tconst struct iio_chan_spec *channels;\n};\n\n \n\nstruct ad5764_state {\n\tstruct spi_device\t\t*spi;\n\tconst struct ad5764_chip_info\t*chip_info;\n\tstruct regulator_bulk_data\tvref_reg[2];\n\tstruct mutex\t\t\tlock;\n\n\t \n\tunion {\n\t\t__be32 d32;\n\t\tu8 d8[4];\n\t} data[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nenum ad5764_type {\n\tID_AD5744,\n\tID_AD5744R,\n\tID_AD5764,\n\tID_AD5764R,\n};\n\n#define AD5764_CHANNEL(_chan, _bits) {\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\\\n\t.channel = (_chan),\t\t\t\t\t\\\n\t.address = (_chan),\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_SCALE) |\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) |\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET),\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = (_bits),\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.shift = 16 - (_bits),\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\n#define DECLARE_AD5764_CHANNELS(_name, _bits) \\\nconst struct iio_chan_spec _name##_channels[] = { \\\n\tAD5764_CHANNEL(0, (_bits)), \\\n\tAD5764_CHANNEL(1, (_bits)), \\\n\tAD5764_CHANNEL(2, (_bits)), \\\n\tAD5764_CHANNEL(3, (_bits)), \\\n};\n\nstatic DECLARE_AD5764_CHANNELS(ad5764, 16);\nstatic DECLARE_AD5764_CHANNELS(ad5744, 14);\n\nstatic const struct ad5764_chip_info ad5764_chip_infos[] = {\n\t[ID_AD5744] = {\n\t\t.int_vref = 0,\n\t\t.channels = ad5744_channels,\n\t},\n\t[ID_AD5744R] = {\n\t\t.int_vref = 5000000,\n\t\t.channels = ad5744_channels,\n\t},\n\t[ID_AD5764] = {\n\t\t.int_vref = 0,\n\t\t.channels = ad5764_channels,\n\t},\n\t[ID_AD5764R] = {\n\t\t.int_vref = 5000000,\n\t\t.channels = ad5764_channels,\n\t},\n};\n\nstatic int ad5764_write(struct iio_dev *indio_dev, unsigned int reg,\n\tunsigned int val)\n{\n\tstruct ad5764_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tst->data[0].d32 = cpu_to_be32((reg << 16) | val);\n\n\tret = spi_write(st->spi, &st->data[0].d8[1], 3);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad5764_read(struct iio_dev *indio_dev, unsigned int reg,\n\tunsigned int *val)\n{\n\tstruct ad5764_state *st = iio_priv(indio_dev);\n\tint ret;\n\tstruct spi_transfer t[] = {\n\t\t{\n\t\t\t.tx_buf = &st->data[0].d8[1],\n\t\t\t.len = 3,\n\t\t\t.cs_change = 1,\n\t\t}, {\n\t\t\t.rx_buf = &st->data[1].d8[1],\n\t\t\t.len = 3,\n\t\t},\n\t};\n\n\tmutex_lock(&st->lock);\n\n\tst->data[0].d32 = cpu_to_be32((1 << 23) | (reg << 16));\n\n\tret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\n\tif (ret >= 0)\n\t\t*val = be32_to_cpu(st->data[1].d32) & 0xffff;\n\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad5764_chan_info_to_reg(struct iio_chan_spec const *chan, long info)\n{\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn AD5764_REG_DATA(chan->address);\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treturn AD5764_REG_OFFSET(chan->address);\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\treturn AD5764_REG_FINE_GAIN(chan->address);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad5764_write_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int val, int val2, long info)\n{\n\tconst int max_val = (1 << chan->scan_type.realbits);\n\tunsigned int reg;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val >= max_val || val < 0)\n\t\t\treturn -EINVAL;\n\t\tval <<= chan->scan_type.shift;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif (val >= 128 || val < -128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (val >= 32 || val < -32)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treg = ad5764_chan_info_to_reg(chan, info);\n\treturn ad5764_write(indio_dev, reg, (u16)val);\n}\n\nstatic int ad5764_get_channel_vref(struct ad5764_state *st,\n\tunsigned int channel)\n{\n\tif (st->chip_info->int_vref)\n\t\treturn st->chip_info->int_vref;\n\telse\n\t\treturn regulator_get_voltage(st->vref_reg[channel / 2].consumer);\n}\n\nstatic int ad5764_read_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int *val, int *val2, long info)\n{\n\tstruct ad5764_state *st = iio_priv(indio_dev);\n\tunsigned int reg;\n\tint vref;\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treg = AD5764_REG_DATA(chan->address);\n\t\tret = ad5764_read(indio_dev, reg, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val >>= chan->scan_type.shift;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treg = AD5764_REG_OFFSET(chan->address);\n\t\tret = ad5764_read(indio_dev, reg, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = sign_extend32(*val, 7);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\treg = AD5764_REG_FINE_GAIN(chan->address);\n\t\tret = ad5764_read(indio_dev, reg, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = sign_extend32(*val, 5);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\tvref = ad5764_get_channel_vref(st, chan->channel);\n\t\tif (vref < 0)\n\t\t\treturn vref;\n\n\t\t*val = vref * 4 / 1000;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = -(1 << chan->scan_type.realbits) / 2;\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info ad5764_info = {\n\t.read_raw = ad5764_read_raw,\n\t.write_raw = ad5764_write_raw,\n};\n\nstatic int ad5764_probe(struct spi_device *spi)\n{\n\tenum ad5764_type type = spi_get_device_id(spi)->driver_data;\n\tstruct iio_dev *indio_dev;\n\tstruct ad5764_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL) {\n\t\tdev_err(&spi->dev, \"Failed to allocate iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tst = iio_priv(indio_dev);\n\tspi_set_drvdata(spi, indio_dev);\n\n\tst->spi = spi;\n\tst->chip_info = &ad5764_chip_infos[type];\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->info = &ad5764_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->num_channels = AD5764_NUM_CHANNELS;\n\tindio_dev->channels = st->chip_info->channels;\n\n\tmutex_init(&st->lock);\n\n\tif (st->chip_info->int_vref == 0) {\n\t\tst->vref_reg[0].supply = \"vrefAB\";\n\t\tst->vref_reg[1].supply = \"vrefCD\";\n\n\t\tret = devm_regulator_bulk_get(&st->spi->dev,\n\t\t\tARRAY_SIZE(st->vref_reg), st->vref_reg);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev, \"Failed to request vref regulators: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regulator_bulk_enable(ARRAY_SIZE(st->vref_reg),\n\t\t\tst->vref_reg);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev, \"Failed to enable vref regulators: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to register iio device: %d\\n\", ret);\n\t\tgoto error_disable_reg;\n\t}\n\n\treturn 0;\n\nerror_disable_reg:\n\tif (st->chip_info->int_vref == 0)\n\t\tregulator_bulk_disable(ARRAY_SIZE(st->vref_reg), st->vref_reg);\n\treturn ret;\n}\n\nstatic void ad5764_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct ad5764_state *st = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tif (st->chip_info->int_vref == 0)\n\t\tregulator_bulk_disable(ARRAY_SIZE(st->vref_reg), st->vref_reg);\n}\n\nstatic const struct spi_device_id ad5764_ids[] = {\n\t{ \"ad5744\", ID_AD5744 },\n\t{ \"ad5744r\", ID_AD5744R },\n\t{ \"ad5764\", ID_AD5764 },\n\t{ \"ad5764r\", ID_AD5764R },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, ad5764_ids);\n\nstatic struct spi_driver ad5764_driver = {\n\t.driver = {\n\t\t.name = \"ad5764\",\n\t},\n\t.probe = ad5764_probe,\n\t.remove = ad5764_remove,\n\t.id_table = ad5764_ids,\n};\nmodule_spi_driver(ad5764_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5744/AD5744R/AD5764/AD5764R DAC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}