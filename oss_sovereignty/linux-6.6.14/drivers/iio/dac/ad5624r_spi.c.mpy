{
  "module_name": "ad5624r_spi.c",
  "hash_id": "dc779a446d7fe65e87cf899a665d77a649ae00b3df31628fa09539fb3932e298",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad5624r_spi.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/regulator/consumer.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#include <asm/unaligned.h>\n\n#include \"ad5624r.h\"\n\nstatic int ad5624r_spi_write(struct spi_device *spi,\n\t\t\t     u8 cmd, u8 addr, u16 val, u8 shift)\n{\n\tu32 data;\n\tu8 msg[3];\n\n\t \n\tdata = (0 << 22) | (cmd << 19) | (addr << 16) | (val << shift);\n\tput_unaligned_be24(data, &msg[0]);\n\n\treturn spi_write(spi, msg, sizeof(msg));\n}\n\nstatic int ad5624r_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tstruct ad5624r_state *st = iio_priv(indio_dev);\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = st->vref_mv;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ad5624r_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val,\n\t\t\t       int val2,\n\t\t\t       long mask)\n{\n\tstruct ad5624r_state *st = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val >= (1 << chan->scan_type.realbits) || val < 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn ad5624r_spi_write(st->us,\n\t\t\t\tAD5624R_CMD_WRITE_INPUT_N_UPDATE_N,\n\t\t\t\tchan->address, val,\n\t\t\t\tchan->scan_type.shift);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const char * const ad5624r_powerdown_modes[] = {\n\t\"1kohm_to_gnd\",\n\t\"100kohm_to_gnd\",\n\t\"three_state\"\n};\n\nstatic int ad5624r_get_powerdown_mode(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan)\n{\n\tstruct ad5624r_state *st = iio_priv(indio_dev);\n\n\treturn st->pwr_down_mode;\n}\n\nstatic int ad5624r_set_powerdown_mode(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, unsigned int mode)\n{\n\tstruct ad5624r_state *st = iio_priv(indio_dev);\n\n\tst->pwr_down_mode = mode;\n\n\treturn 0;\n}\n\nstatic const struct iio_enum ad5624r_powerdown_mode_enum = {\n\t.items = ad5624r_powerdown_modes,\n\t.num_items = ARRAY_SIZE(ad5624r_powerdown_modes),\n\t.get = ad5624r_get_powerdown_mode,\n\t.set = ad5624r_set_powerdown_mode,\n};\n\nstatic ssize_t ad5624r_read_dac_powerdown(struct iio_dev *indio_dev,\n\tuintptr_t private, const struct iio_chan_spec *chan, char *buf)\n{\n\tstruct ad5624r_state *st = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  !!(st->pwr_down_mask & (1 << chan->channel)));\n}\n\nstatic ssize_t ad5624r_write_dac_powerdown(struct iio_dev *indio_dev,\n\tuintptr_t private, const struct iio_chan_spec *chan, const char *buf,\n\tsize_t len)\n{\n\tbool pwr_down;\n\tint ret;\n\tstruct ad5624r_state *st = iio_priv(indio_dev);\n\n\tret = kstrtobool(buf, &pwr_down);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pwr_down)\n\t\tst->pwr_down_mask |= (1 << chan->channel);\n\telse\n\t\tst->pwr_down_mask &= ~(1 << chan->channel);\n\n\tret = ad5624r_spi_write(st->us, AD5624R_CMD_POWERDOWN_DAC, 0,\n\t\t\t\t(st->pwr_down_mode << 4) |\n\t\t\t\tst->pwr_down_mask, 16);\n\n\treturn ret ? ret : len;\n}\n\nstatic const struct iio_info ad5624r_info = {\n\t.write_raw = ad5624r_write_raw,\n\t.read_raw = ad5624r_read_raw,\n};\n\nstatic const struct iio_chan_spec_ext_info ad5624r_ext_info[] = {\n\t{\n\t\t.name = \"powerdown\",\n\t\t.read = ad5624r_read_dac_powerdown,\n\t\t.write = ad5624r_write_dac_powerdown,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\tIIO_ENUM(\"powerdown_mode\", IIO_SHARED_BY_TYPE,\n\t\t &ad5624r_powerdown_mode_enum),\n\tIIO_ENUM_AVAILABLE(\"powerdown_mode\", IIO_SHARED_BY_TYPE, &ad5624r_powerdown_mode_enum),\n\t{ },\n};\n\n#define AD5624R_CHANNEL(_chan, _bits) { \\\n\t.type = IIO_VOLTAGE, \\\n\t.indexed = 1, \\\n\t.output = 1, \\\n\t.channel = (_chan), \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t.address = (_chan), \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = (_bits), \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 16 - (_bits), \\\n\t}, \\\n\t.ext_info = ad5624r_ext_info, \\\n}\n\n#define DECLARE_AD5624R_CHANNELS(_name, _bits) \\\n\tconst struct iio_chan_spec _name##_channels[] = { \\\n\t\tAD5624R_CHANNEL(0, _bits), \\\n\t\tAD5624R_CHANNEL(1, _bits), \\\n\t\tAD5624R_CHANNEL(2, _bits), \\\n\t\tAD5624R_CHANNEL(3, _bits), \\\n}\n\nstatic DECLARE_AD5624R_CHANNELS(ad5624r, 12);\nstatic DECLARE_AD5624R_CHANNELS(ad5644r, 14);\nstatic DECLARE_AD5624R_CHANNELS(ad5664r, 16);\n\nstatic const struct ad5624r_chip_info ad5624r_chip_info_tbl[] = {\n\t[ID_AD5624R3] = {\n\t\t.channels = ad5624r_channels,\n\t\t.int_vref_mv = 1250,\n\t},\n\t[ID_AD5624R5] = {\n\t\t.channels = ad5624r_channels,\n\t\t.int_vref_mv = 2500,\n\t},\n\t[ID_AD5644R3] = {\n\t\t.channels = ad5644r_channels,\n\t\t.int_vref_mv = 1250,\n\t},\n\t[ID_AD5644R5] = {\n\t\t.channels = ad5644r_channels,\n\t\t.int_vref_mv = 2500,\n\t},\n\t[ID_AD5664R3] = {\n\t\t.channels = ad5664r_channels,\n\t\t.int_vref_mv = 1250,\n\t},\n\t[ID_AD5664R5] = {\n\t\t.channels = ad5664r_channels,\n\t\t.int_vref_mv = 2500,\n\t},\n};\n\nstatic int ad5624r_probe(struct spi_device *spi)\n{\n\tstruct ad5624r_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret, voltage_uv = 0;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tst = iio_priv(indio_dev);\n\tst->reg = devm_regulator_get_optional(&spi->dev, \"vref\");\n\tif (!IS_ERR(st->reg)) {\n\t\tret = regulator_enable(st->reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regulator_get_voltage(st->reg);\n\t\tif (ret < 0)\n\t\t\tgoto error_disable_reg;\n\n\t\tvoltage_uv = ret;\n\t} else {\n\t\tif (PTR_ERR(st->reg) != -ENODEV)\n\t\t\treturn PTR_ERR(st->reg);\n\t\t \n\t\tst->reg = devm_regulator_get_optional(&spi->dev, \"vcc\");\n\t\tif (!IS_ERR(st->reg)) {\n\t\t\tret = regulator_enable(st->reg);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = regulator_get_voltage(st->reg);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_disable_reg;\n\n\t\t\tvoltage_uv = ret;\n\t\t}\n\t}\n\n\tspi_set_drvdata(spi, indio_dev);\n\tst->chip_info =\n\t\t&ad5624r_chip_info_tbl[spi_get_device_id(spi)->driver_data];\n\n\tif (voltage_uv)\n\t\tst->vref_mv = voltage_uv / 1000;\n\telse\n\t\tst->vref_mv = st->chip_info->int_vref_mv;\n\n\tst->us = spi;\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->info = &ad5624r_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = st->chip_info->channels;\n\tindio_dev->num_channels = AD5624R_DAC_CHANNELS;\n\n\tret = ad5624r_spi_write(spi, AD5624R_CMD_INTERNAL_REFER_SETUP, 0,\n\t\t\t\t!!voltage_uv, 16);\n\tif (ret)\n\t\tgoto error_disable_reg;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto error_disable_reg;\n\n\treturn 0;\n\nerror_disable_reg:\n\tif (!IS_ERR(st->reg))\n\t\tregulator_disable(st->reg);\n\n\treturn ret;\n}\n\nstatic void ad5624r_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct ad5624r_state *st = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tif (!IS_ERR(st->reg))\n\t\tregulator_disable(st->reg);\n}\n\nstatic const struct spi_device_id ad5624r_id[] = {\n\t{\"ad5624r3\", ID_AD5624R3},\n\t{\"ad5644r3\", ID_AD5644R3},\n\t{\"ad5664r3\", ID_AD5664R3},\n\t{\"ad5624r5\", ID_AD5624R5},\n\t{\"ad5644r5\", ID_AD5644R5},\n\t{\"ad5664r5\", ID_AD5664R5},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad5624r_id);\n\nstatic struct spi_driver ad5624r_driver = {\n\t.driver = {\n\t\t   .name = \"ad5624r\",\n\t\t   },\n\t.probe = ad5624r_probe,\n\t.remove = ad5624r_remove,\n\t.id_table = ad5624r_id,\n};\nmodule_spi_driver(ad5624r_driver);\n\nMODULE_AUTHOR(\"Barry Song <21cnbao@gmail.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5624/44/64R DAC spi driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}