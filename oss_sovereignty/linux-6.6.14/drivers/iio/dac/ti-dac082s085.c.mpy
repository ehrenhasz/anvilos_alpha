{
  "module_name": "ti-dac082s085.c",
  "hash_id": "3b949c7981addd27401c23d5283ef893b3d4e409640e9ad557bb7c112dee268c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ti-dac082s085.c",
  "human_readable_source": "\n \n\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\nenum { dual_8bit, dual_10bit, dual_12bit, quad_8bit, quad_10bit, quad_12bit };\n\nstruct ti_dac_spec {\n\tu8 num_channels;\n\tu8 resolution;\n};\n\nstatic const struct ti_dac_spec ti_dac_spec[] = {\n\t[dual_8bit]  = { .num_channels = 2, .resolution = 8  },\n\t[dual_10bit] = { .num_channels = 2, .resolution = 10 },\n\t[dual_12bit] = { .num_channels = 2, .resolution = 12 },\n\t[quad_8bit]  = { .num_channels = 4, .resolution = 8  },\n\t[quad_10bit] = { .num_channels = 4, .resolution = 10 },\n\t[quad_12bit] = { .num_channels = 4, .resolution = 12 },\n};\n\n \nstruct ti_dac_chip {\n\tstruct mutex lock;\n\tstruct regulator *vref;\n\tstruct spi_message mesg;\n\tstruct spi_transfer xfer;\n\tu16 val[4];\n\tbool powerdown;\n\tu8 powerdown_mode;\n\tu8 resolution;\n\tu8 buf[2] __aligned(IIO_DMA_MINALIGN);\n};\n\n#define WRITE_NOT_UPDATE(chan)\t(0x00 | (chan) << 6)\n#define WRITE_AND_UPDATE(chan)\t(0x10 | (chan) << 6)\n#define WRITE_ALL_UPDATE\t 0x20\n#define POWERDOWN(mode) \t(0x30 | ((mode) + 1) << 6)\n\nstatic int ti_dac_cmd(struct ti_dac_chip *ti_dac, u8 cmd, u16 val)\n{\n\tu8 shift = 12 - ti_dac->resolution;\n\n\tti_dac->buf[0] = cmd | (val >> (8 - shift));\n\tti_dac->buf[1] = (val << shift) & 0xff;\n\treturn spi_sync(ti_dac->mesg.spi, &ti_dac->mesg);\n}\n\nstatic const char * const ti_dac_powerdown_modes[] = {\n\t\"2.5kohm_to_gnd\", \"100kohm_to_gnd\", \"three_state\",\n};\n\nstatic int ti_dac_get_powerdown_mode(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan)\n{\n\tstruct ti_dac_chip *ti_dac = iio_priv(indio_dev);\n\n\treturn ti_dac->powerdown_mode;\n}\n\nstatic int ti_dac_set_powerdown_mode(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     unsigned int mode)\n{\n\tstruct ti_dac_chip *ti_dac = iio_priv(indio_dev);\n\tint ret = 0;\n\n\tif (ti_dac->powerdown_mode == mode)\n\t\treturn 0;\n\n\tmutex_lock(&ti_dac->lock);\n\tif (ti_dac->powerdown) {\n\t\tret = ti_dac_cmd(ti_dac, POWERDOWN(mode), 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tti_dac->powerdown_mode = mode;\n\nout:\n\tmutex_unlock(&ti_dac->lock);\n\treturn ret;\n}\n\nstatic const struct iio_enum ti_dac_powerdown_mode = {\n\t.items = ti_dac_powerdown_modes,\n\t.num_items = ARRAY_SIZE(ti_dac_powerdown_modes),\n\t.get = ti_dac_get_powerdown_mode,\n\t.set = ti_dac_set_powerdown_mode,\n};\n\nstatic ssize_t ti_dac_read_powerdown(struct iio_dev *indio_dev,\n\t\t\t\t     uintptr_t private,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     char *buf)\n{\n\tstruct ti_dac_chip *ti_dac = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ti_dac->powerdown);\n}\n\nstatic ssize_t ti_dac_write_powerdown(struct iio_dev *indio_dev,\n\t\t\t\t      uintptr_t private,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct ti_dac_chip *ti_dac = iio_priv(indio_dev);\n\tbool powerdown;\n\tint ret;\n\n\tret = kstrtobool(buf, &powerdown);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ti_dac->powerdown == powerdown)\n\t\treturn len;\n\n\tmutex_lock(&ti_dac->lock);\n\tif (powerdown)\n\t\tret = ti_dac_cmd(ti_dac, POWERDOWN(ti_dac->powerdown_mode), 0);\n\telse\n\t\tret = ti_dac_cmd(ti_dac, WRITE_AND_UPDATE(0), ti_dac->val[0]);\n\tif (!ret)\n\t\tti_dac->powerdown = powerdown;\n\tmutex_unlock(&ti_dac->lock);\n\n\treturn ret ? ret : len;\n}\n\nstatic const struct iio_chan_spec_ext_info ti_dac_ext_info[] = {\n\t{\n\t\t.name\t   = \"powerdown\",\n\t\t.read\t   = ti_dac_read_powerdown,\n\t\t.write\t   = ti_dac_write_powerdown,\n\t\t.shared\t   = IIO_SHARED_BY_TYPE,\n\t},\n\tIIO_ENUM(\"powerdown_mode\", IIO_SHARED_BY_TYPE, &ti_dac_powerdown_mode),\n\tIIO_ENUM_AVAILABLE(\"powerdown_mode\", IIO_SHARED_BY_TYPE, &ti_dac_powerdown_mode),\n\t{ },\n};\n\n#define TI_DAC_CHANNEL(chan) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.channel = (chan),\t\t\t\t\t\\\n\t.address = (chan),\t\t\t\t\t\\\n\t.indexed = true,\t\t\t\t\t\\\n\t.output = true,\t\t\t\t\t\t\\\n\t.datasheet_name = (const char[]){ 'A' + (chan), 0 },\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.ext_info = ti_dac_ext_info,\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec ti_dac_channels[] = {\n\tTI_DAC_CHANNEL(0),\n\tTI_DAC_CHANNEL(1),\n\tTI_DAC_CHANNEL(2),\n\tTI_DAC_CHANNEL(3),\n};\n\nstatic int ti_dac_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct ti_dac_chip *ti_dac = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*val = ti_dac->val[chan->channel];\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = regulator_get_voltage(ti_dac->vref);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret / 1000;\n\t\t*val2 = ti_dac->resolution;\n\t\tret = IIO_VAL_FRACTIONAL_LOG2;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int ti_dac_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct ti_dac_chip *ti_dac = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (ti_dac->val[chan->channel] == val)\n\t\t\treturn 0;\n\n\t\tif (val >= (1 << ti_dac->resolution) || val < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (ti_dac->powerdown)\n\t\t\treturn -EBUSY;\n\n\t\tmutex_lock(&ti_dac->lock);\n\t\tret = ti_dac_cmd(ti_dac, WRITE_AND_UPDATE(chan->channel), val);\n\t\tif (!ret)\n\t\t\tti_dac->val[chan->channel] = val;\n\t\tmutex_unlock(&ti_dac->lock);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int ti_dac_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t    struct iio_chan_spec const *chan, long mask)\n{\n\treturn IIO_VAL_INT;\n}\n\nstatic const struct iio_info ti_dac_info = {\n\t.read_raw\t   = ti_dac_read_raw,\n\t.write_raw\t   = ti_dac_write_raw,\n\t.write_raw_get_fmt = ti_dac_write_raw_get_fmt,\n};\n\nstatic int ti_dac_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tconst struct ti_dac_spec *spec;\n\tstruct ti_dac_chip *ti_dac;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*ti_dac));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tindio_dev->info = &ti_dac_info;\n\tindio_dev->name = spi->modalias;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = ti_dac_channels;\n\tspi_set_drvdata(spi, indio_dev);\n\n\tti_dac = iio_priv(indio_dev);\n\tti_dac->xfer.tx_buf = &ti_dac->buf;\n\tti_dac->xfer.len = sizeof(ti_dac->buf);\n\tspi_message_init_with_transfers(&ti_dac->mesg, &ti_dac->xfer, 1);\n\tti_dac->mesg.spi = spi;\n\n\tspec = &ti_dac_spec[spi_get_device_id(spi)->driver_data];\n\tindio_dev->num_channels = spec->num_channels;\n\tti_dac->resolution = spec->resolution;\n\n\tti_dac->vref = devm_regulator_get(dev, \"vref\");\n\tif (IS_ERR(ti_dac->vref))\n\t\treturn PTR_ERR(ti_dac->vref);\n\n\tret = regulator_enable(ti_dac->vref);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_init(&ti_dac->lock);\n\n\tret = ti_dac_cmd(ti_dac, WRITE_ALL_UPDATE, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize outputs to 0\\n\");\n\t\tgoto err;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tmutex_destroy(&ti_dac->lock);\n\tregulator_disable(ti_dac->vref);\n\treturn ret;\n}\n\nstatic void ti_dac_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct ti_dac_chip *ti_dac = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tmutex_destroy(&ti_dac->lock);\n\tregulator_disable(ti_dac->vref);\n}\n\nstatic const struct of_device_id ti_dac_of_id[] = {\n\t{ .compatible = \"ti,dac082s085\" },\n\t{ .compatible = \"ti,dac102s085\" },\n\t{ .compatible = \"ti,dac122s085\" },\n\t{ .compatible = \"ti,dac084s085\" },\n\t{ .compatible = \"ti,dac104s085\" },\n\t{ .compatible = \"ti,dac124s085\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ti_dac_of_id);\n\nstatic const struct spi_device_id ti_dac_spi_id[] = {\n\t{ \"dac082s085\", dual_8bit  },\n\t{ \"dac102s085\", dual_10bit },\n\t{ \"dac122s085\", dual_12bit },\n\t{ \"dac084s085\", quad_8bit  },\n\t{ \"dac104s085\", quad_10bit },\n\t{ \"dac124s085\", quad_12bit },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, ti_dac_spi_id);\n\nstatic struct spi_driver ti_dac_driver = {\n\t.driver = {\n\t\t.name\t\t= \"ti-dac082s085\",\n\t\t.of_match_table\t= ti_dac_of_id,\n\t},\n\t.probe\t  = ti_dac_probe,\n\t.remove   = ti_dac_remove,\n\t.id_table = ti_dac_spi_id,\n};\nmodule_spi_driver(ti_dac_driver);\n\nMODULE_AUTHOR(\"Lukas Wunner <lukas@wunner.de>\");\nMODULE_DESCRIPTION(\"Texas Instruments 8/10/12-bit 2/4-channel DAC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}