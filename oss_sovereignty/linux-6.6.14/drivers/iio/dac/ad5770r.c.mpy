{
  "module_name": "ad5770r.c",
  "hash_id": "677cb314d2f2eac10ad346b4b07a33a09c1723af7cf3db365328d276ec6d0346",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad5770r.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#define ADI_SPI_IF_CONFIG_A\t\t0x00\n#define ADI_SPI_IF_CONFIG_B\t\t0x01\n#define ADI_SPI_IF_DEVICE_CONFIG\t0x02\n#define ADI_SPI_IF_CHIP_TYPE\t\t0x03\n#define ADI_SPI_IF_PRODUCT_ID_L\t\t0x04\n#define ADI_SPI_IF_PRODUCT_ID_H\t\t0x05\n#define ADI_SPI_IF_CHIP_GRADE\t\t0x06\n#define ADI_SPI_IF_SCRACTH_PAD\t\t0x0A\n#define ADI_SPI_IF_SPI_REVISION\t\t0x0B\n#define ADI_SPI_IF_SPI_VENDOR_L\t\t0x0C\n#define ADI_SPI_IF_SPI_VENDOR_H\t\t0x0D\n#define ADI_SPI_IF_SPI_STREAM_MODE\t0x0E\n#define ADI_SPI_IF_CONFIG_C\t\t0x10\n#define ADI_SPI_IF_STATUS_A\t\t0x11\n\n \n#define ADI_SPI_IF_SW_RESET_MSK\t\t(BIT(0) | BIT(7))\n#define ADI_SPI_IF_SW_RESET_SEL(x)\t((x) & ADI_SPI_IF_SW_RESET_MSK)\n#define ADI_SPI_IF_ADDR_ASC_MSK\t\t(BIT(2) | BIT(5))\n#define ADI_SPI_IF_ADDR_ASC_SEL(x)\t(((x) << 2) & ADI_SPI_IF_ADDR_ASC_MSK)\n\n \n#define ADI_SPI_IF_SINGLE_INS_MSK\tBIT(7)\n#define ADI_SPI_IF_SINGLE_INS_SEL(x)\tFIELD_PREP(ADI_SPI_IF_SINGLE_INS_MSK, x)\n#define ADI_SPI_IF_SHORT_INS_MSK\tBIT(7)\n#define ADI_SPI_IF_SHORT_INS_SEL(x)\tFIELD_PREP(ADI_SPI_IF_SINGLE_INS_MSK, x)\n\n \n#define ADI_SPI_IF_STRICT_REG_MSK\tBIT(5)\n#define ADI_SPI_IF_STRICT_REG_GET(x)\tFIELD_GET(ADI_SPI_IF_STRICT_REG_MSK, x)\n\n \n#define AD5770R_CHANNEL_CONFIG\t\t0x14\n#define AD5770R_OUTPUT_RANGE(ch)\t(0x15 + (ch))\n#define AD5770R_FILTER_RESISTOR(ch)\t(0x1D + (ch))\n#define AD5770R_REFERENCE\t\t0x1B\n#define AD5770R_DAC_LSB(ch)\t\t(0x26 + 2 * (ch))\n#define AD5770R_DAC_MSB(ch)\t\t(0x27 + 2 * (ch))\n#define AD5770R_CH_SELECT\t\t0x34\n#define AD5770R_CH_ENABLE\t\t0x44\n\n \n#define AD5770R_CFG_CH0_SINK_EN(x)\t\t(((x) & 0x1) << 7)\n#define AD5770R_CFG_SHUTDOWN_B(x, ch)\t\t(((x) & 0x1) << (ch))\n\n \n#define AD5770R_RANGE_OUTPUT_SCALING(x)\t\t(((x) & GENMASK(5, 0)) << 2)\n#define AD5770R_RANGE_MODE(x)\t\t\t((x) & GENMASK(1, 0))\n\n \n#define AD5770R_REF_RESISTOR_SEL(x)\t\t(((x) & 0x1) << 2)\n#define AD5770R_REF_SEL(x)\t\t\t((x) & GENMASK(1, 0))\n\n \n#define AD5770R_CH_SET(x, ch)\t\t(((x) & 0x1) << (ch))\n\n#define AD5770R_MAX_CHANNELS\t6\n#define AD5770R_MAX_CH_MODES\t14\n#define AD5770R_LOW_VREF_mV\t1250\n#define AD5770R_HIGH_VREF_mV\t2500\n\nenum ad5770r_ch0_modes {\n\tAD5770R_CH0_0_300 = 0,\n\tAD5770R_CH0_NEG_60_0,\n\tAD5770R_CH0_NEG_60_300\n};\n\nenum ad5770r_ch1_modes {\n\tAD5770R_CH1_0_140_LOW_HEAD = 1,\n\tAD5770R_CH1_0_140_LOW_NOISE,\n\tAD5770R_CH1_0_250\n};\n\nenum ad5770r_ch2_5_modes {\n\tAD5770R_CH_LOW_RANGE = 0,\n\tAD5770R_CH_HIGH_RANGE\n};\n\nenum ad5770r_ref_v {\n\tAD5770R_EXT_2_5_V = 0,\n\tAD5770R_INT_1_25_V_OUT_ON,\n\tAD5770R_EXT_1_25_V,\n\tAD5770R_INT_1_25_V_OUT_OFF\n};\n\nenum ad5770r_output_filter_resistor {\n\tAD5770R_FILTER_60_OHM = 0x0,\n\tAD5770R_FILTER_5_6_KOHM = 0x5,\n\tAD5770R_FILTER_11_2_KOHM,\n\tAD5770R_FILTER_22_2_KOHM,\n\tAD5770R_FILTER_44_4_KOHM,\n\tAD5770R_FILTER_104_KOHM,\n};\n\nstruct ad5770r_out_range {\n\tu8\tout_scale;\n\tu8\tout_range_mode;\n};\n\n \nstruct ad5770r_state {\n\tstruct spi_device\t\t*spi;\n\tstruct regmap\t\t\t*regmap;\n\tstruct regulator\t\t*vref_reg;\n\tstruct gpio_desc\t\t*gpio_reset;\n\tstruct ad5770r_out_range\toutput_mode[AD5770R_MAX_CHANNELS];\n\tint\t\t\t\tvref;\n\tbool\t\t\t\tch_pwr_down[AD5770R_MAX_CHANNELS];\n\tbool\t\t\t\tinternal_ref;\n\tbool\t\t\t\texternal_res;\n\tu8\t\t\t\ttransf_buf[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic const struct regmap_config ad5770r_spi_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.read_flag_mask = BIT(7),\n};\n\nstruct ad5770r_output_modes {\n\tunsigned int ch;\n\tu8 mode;\n\tint min;\n\tint max;\n};\n\nstatic struct ad5770r_output_modes ad5770r_rng_tbl[] = {\n\t{ 0, AD5770R_CH0_0_300, 0, 300 },\n\t{ 0, AD5770R_CH0_NEG_60_0, -60, 0 },\n\t{ 0, AD5770R_CH0_NEG_60_300, -60, 300 },\n\t{ 1, AD5770R_CH1_0_140_LOW_HEAD, 0, 140 },\n\t{ 1, AD5770R_CH1_0_140_LOW_NOISE, 0, 140 },\n\t{ 1, AD5770R_CH1_0_250, 0, 250 },\n\t{ 2, AD5770R_CH_LOW_RANGE, 0, 55 },\n\t{ 2, AD5770R_CH_HIGH_RANGE, 0, 150 },\n\t{ 3, AD5770R_CH_LOW_RANGE, 0, 45 },\n\t{ 3, AD5770R_CH_HIGH_RANGE, 0, 100 },\n\t{ 4, AD5770R_CH_LOW_RANGE, 0, 45 },\n\t{ 4, AD5770R_CH_HIGH_RANGE, 0, 100 },\n\t{ 5, AD5770R_CH_LOW_RANGE, 0, 45 },\n\t{ 5, AD5770R_CH_HIGH_RANGE, 0, 100 },\n};\n\nstatic const unsigned int ad5770r_filter_freqs[] = {\n\t153, 357, 715, 1400, 2800, 262000,\n};\n\nstatic const unsigned int ad5770r_filter_reg_vals[] = {\n\tAD5770R_FILTER_104_KOHM,\n\tAD5770R_FILTER_44_4_KOHM,\n\tAD5770R_FILTER_22_2_KOHM,\n\tAD5770R_FILTER_11_2_KOHM,\n\tAD5770R_FILTER_5_6_KOHM,\n\tAD5770R_FILTER_60_OHM\n};\n\nstatic int ad5770r_set_output_mode(struct ad5770r_state *st,\n\t\t\t\t   const struct ad5770r_out_range *out_mode,\n\t\t\t\t   int channel)\n{\n\tunsigned int regval;\n\n\tregval = AD5770R_RANGE_OUTPUT_SCALING(out_mode->out_scale) |\n\t\t AD5770R_RANGE_MODE(out_mode->out_range_mode);\n\n\treturn regmap_write(st->regmap,\n\t\t\t    AD5770R_OUTPUT_RANGE(channel), regval);\n}\n\nstatic int ad5770r_set_reference(struct ad5770r_state *st)\n{\n\tunsigned int regval;\n\n\tregval = AD5770R_REF_RESISTOR_SEL(st->external_res);\n\n\tif (st->internal_ref) {\n\t\tregval |= AD5770R_REF_SEL(AD5770R_INT_1_25_V_OUT_OFF);\n\t} else {\n\t\tswitch (st->vref) {\n\t\tcase AD5770R_LOW_VREF_mV:\n\t\t\tregval |= AD5770R_REF_SEL(AD5770R_EXT_1_25_V);\n\t\t\tbreak;\n\t\tcase AD5770R_HIGH_VREF_mV:\n\t\t\tregval |= AD5770R_REF_SEL(AD5770R_EXT_2_5_V);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tregval = AD5770R_REF_SEL(AD5770R_INT_1_25_V_OUT_OFF);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn regmap_write(st->regmap, AD5770R_REFERENCE, regval);\n}\n\nstatic int ad5770r_soft_reset(struct ad5770r_state *st)\n{\n\treturn regmap_write(st->regmap, ADI_SPI_IF_CONFIG_A,\n\t\t\t    ADI_SPI_IF_SW_RESET_SEL(1));\n}\n\nstatic int ad5770r_reset(struct ad5770r_state *st)\n{\n\t \n\tif (!st->gpio_reset)\n\t\treturn ad5770r_soft_reset(st);\n\n\tgpiod_set_value_cansleep(st->gpio_reset, 0);\n\tusleep_range(10, 20);\n\tgpiod_set_value_cansleep(st->gpio_reset, 1);\n\n\t \n\tusleep_range(100, 200);\n\n\treturn 0;\n}\n\nstatic int ad5770r_get_range(struct ad5770r_state *st,\n\t\t\t     int ch, int *min, int *max)\n{\n\tint i;\n\tu8 tbl_ch, tbl_mode, out_range;\n\n\tout_range = st->output_mode[ch].out_range_mode;\n\n\tfor (i = 0; i < AD5770R_MAX_CH_MODES; i++) {\n\t\ttbl_ch = ad5770r_rng_tbl[i].ch;\n\t\ttbl_mode = ad5770r_rng_tbl[i].mode;\n\t\tif (tbl_ch == ch && tbl_mode == out_range) {\n\t\t\t*min = ad5770r_rng_tbl[i].min;\n\t\t\t*max = ad5770r_rng_tbl[i].max;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ad5770r_get_filter_freq(struct iio_dev *indio_dev,\n\t\t\t\t   const struct iio_chan_spec *chan, int *freq)\n{\n\tstruct ad5770r_state *st = iio_priv(indio_dev);\n\tint ret;\n\tunsigned int regval, i;\n\n\tret = regmap_read(st->regmap,\n\t\t\t  AD5770R_FILTER_RESISTOR(chan->channel), &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(ad5770r_filter_reg_vals); i++)\n\t\tif (regval == ad5770r_filter_reg_vals[i])\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(ad5770r_filter_reg_vals))\n\t\treturn -EINVAL;\n\n\t*freq = ad5770r_filter_freqs[i];\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int ad5770r_set_filter_freq(struct iio_dev *indio_dev,\n\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t   unsigned int freq)\n{\n\tstruct ad5770r_state *st = iio_priv(indio_dev);\n\tunsigned int regval, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ad5770r_filter_freqs); i++)\n\t\tif (ad5770r_filter_freqs[i] >= freq)\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(ad5770r_filter_freqs))\n\t\treturn -EINVAL;\n\n\tregval = ad5770r_filter_reg_vals[i];\n\n\treturn regmap_write(st->regmap, AD5770R_FILTER_RESISTOR(chan->channel),\n\t\t\t    regval);\n}\n\nstatic int ad5770r_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long info)\n{\n\tstruct ad5770r_state *st = iio_priv(indio_dev);\n\tint max, min, ret;\n\tu16 buf16;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = regmap_bulk_read(st->regmap,\n\t\t\t\t       chan->address,\n\t\t\t\t       st->transf_buf, 2);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\tbuf16 = st->transf_buf[0] + (st->transf_buf[1] << 8);\n\t\t*val = buf16 >> 2;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = ad5770r_get_range(st, chan->channel, &min, &max);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = max - min;\n\t\t \n\t\t*val2 = 14;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn ad5770r_get_filter_freq(indio_dev, chan, val);\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tret = ad5770r_get_range(st, chan->channel, &min, &max);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = min;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad5770r_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long info)\n{\n\tstruct ad5770r_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tst->transf_buf[0] = ((u16)val >> 6);\n\t\tst->transf_buf[1] = (val & GENMASK(5, 0)) << 2;\n\t\treturn regmap_bulk_write(st->regmap, chan->address,\n\t\t\t\t\t st->transf_buf, 2);\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn ad5770r_set_filter_freq(indio_dev, chan, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad5770r_read_freq_avail(struct iio_dev *indio_dev,\n\t\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t\t   const int **vals, int *type, int *length,\n\t\t\t\t   long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\t*type = IIO_VAL_INT;\n\t\t*vals = ad5770r_filter_freqs;\n\t\t*length = ARRAY_SIZE(ad5770r_filter_freqs);\n\t\treturn IIO_AVAIL_LIST;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ad5770r_reg_access(struct iio_dev *indio_dev,\n\t\t\t      unsigned int reg,\n\t\t\t      unsigned int writeval,\n\t\t\t      unsigned int *readval)\n{\n\tstruct ad5770r_state *st = iio_priv(indio_dev);\n\n\tif (readval)\n\t\treturn regmap_read(st->regmap, reg, readval);\n\telse\n\t\treturn regmap_write(st->regmap, reg, writeval);\n}\n\nstatic const struct iio_info ad5770r_info = {\n\t.read_raw = ad5770r_read_raw,\n\t.write_raw = ad5770r_write_raw,\n\t.read_avail = ad5770r_read_freq_avail,\n\t.debugfs_reg_access = &ad5770r_reg_access,\n};\n\nstatic int ad5770r_store_output_range(struct ad5770r_state *st,\n\t\t\t\t      int min, int max, int index)\n{\n\tint i;\n\n\tfor (i = 0; i < AD5770R_MAX_CH_MODES; i++) {\n\t\tif (ad5770r_rng_tbl[i].ch != index)\n\t\t\tcontinue;\n\t\tif (ad5770r_rng_tbl[i].min != min ||\n\t\t    ad5770r_rng_tbl[i].max != max)\n\t\t\tcontinue;\n\t\tst->output_mode[index].out_range_mode = ad5770r_rng_tbl[i].mode;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t ad5770r_read_dac_powerdown(struct iio_dev *indio_dev,\n\t\t\t\t\t  uintptr_t private,\n\t\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t\t  char *buf)\n{\n\tstruct ad5770r_state *st = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", st->ch_pwr_down[chan->channel]);\n}\n\nstatic ssize_t ad5770r_write_dac_powerdown(struct iio_dev *indio_dev,\n\t\t\t\t\t   uintptr_t private,\n\t\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t\t   const char *buf, size_t len)\n{\n\tstruct ad5770r_state *st = iio_priv(indio_dev);\n\tunsigned int regval;\n\tunsigned int mask;\n\tbool readin;\n\tint ret;\n\n\tret = kstrtobool(buf, &readin);\n\tif (ret)\n\t\treturn ret;\n\n\treadin = !readin;\n\n\tregval = AD5770R_CFG_SHUTDOWN_B(readin, chan->channel);\n\tif (chan->channel == 0 &&\n\t    st->output_mode[0].out_range_mode > AD5770R_CH0_0_300) {\n\t\tregval |= AD5770R_CFG_CH0_SINK_EN(readin);\n\t\tmask = BIT(chan->channel) + BIT(7);\n\t} else {\n\t\tmask = BIT(chan->channel);\n\t}\n\tret = regmap_update_bits(st->regmap, AD5770R_CHANNEL_CONFIG, mask,\n\t\t\t\t regval);\n\tif (ret)\n\t\treturn ret;\n\n\tregval = AD5770R_CH_SET(readin, chan->channel);\n\tret = regmap_update_bits(st->regmap, AD5770R_CH_ENABLE,\n\t\t\t\t BIT(chan->channel), regval);\n\tif (ret)\n\t\treturn ret;\n\n\tst->ch_pwr_down[chan->channel] = !readin;\n\n\treturn len;\n}\n\nstatic const struct iio_chan_spec_ext_info ad5770r_ext_info[] = {\n\t{\n\t\t.name = \"powerdown\",\n\t\t.read = ad5770r_read_dac_powerdown,\n\t\t.write = ad5770r_write_dac_powerdown,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\t{ }\n};\n\n#define AD5770R_IDAC_CHANNEL(index, reg) {\t\t\t\t\\\n\t.type = IIO_CURRENT,\t\t\t\t\t\t\\\n\t.address = reg,\t\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.channel = index,\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_SCALE) |\t\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_OFFSET) |\t\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\t\\\n\t.info_mask_shared_by_type_available =\t\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\t\\\n\t.ext_info = ad5770r_ext_info,\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec ad5770r_channels[] = {\n\tAD5770R_IDAC_CHANNEL(0, AD5770R_DAC_MSB(0)),\n\tAD5770R_IDAC_CHANNEL(1, AD5770R_DAC_MSB(1)),\n\tAD5770R_IDAC_CHANNEL(2, AD5770R_DAC_MSB(2)),\n\tAD5770R_IDAC_CHANNEL(3, AD5770R_DAC_MSB(3)),\n\tAD5770R_IDAC_CHANNEL(4, AD5770R_DAC_MSB(4)),\n\tAD5770R_IDAC_CHANNEL(5, AD5770R_DAC_MSB(5)),\n};\n\nstatic int ad5770r_channel_config(struct ad5770r_state *st)\n{\n\tint ret, tmp[2], min, max;\n\tunsigned int num;\n\tstruct fwnode_handle *child;\n\n\tnum = device_get_child_node_count(&st->spi->dev);\n\tif (num != AD5770R_MAX_CHANNELS)\n\t\treturn -EINVAL;\n\n\tdevice_for_each_child_node(&st->spi->dev, child) {\n\t\tret = fwnode_property_read_u32(child, \"reg\", &num);\n\t\tif (ret)\n\t\t\tgoto err_child_out;\n\t\tif (num >= AD5770R_MAX_CHANNELS) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_child_out;\n\t\t}\n\n\t\tret = fwnode_property_read_u32_array(child,\n\t\t\t\t\t\t     \"adi,range-microamp\",\n\t\t\t\t\t\t     tmp, 2);\n\t\tif (ret)\n\t\t\tgoto err_child_out;\n\n\t\tmin = tmp[0] / 1000;\n\t\tmax = tmp[1] / 1000;\n\t\tret = ad5770r_store_output_range(st, min, max, num);\n\t\tif (ret)\n\t\t\tgoto err_child_out;\n\t}\n\n\treturn 0;\n\nerr_child_out:\n\tfwnode_handle_put(child);\n\treturn ret;\n}\n\nstatic int ad5770r_init(struct ad5770r_state *st)\n{\n\tint ret, i;\n\n\tst->gpio_reset = devm_gpiod_get_optional(&st->spi->dev, \"reset\",\n\t\t\t\t\t\t GPIOD_OUT_HIGH);\n\tif (IS_ERR(st->gpio_reset))\n\t\treturn PTR_ERR(st->gpio_reset);\n\n\t \n\tret = ad5770r_reset(st);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ad5770r_channel_config(st);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < AD5770R_MAX_CHANNELS; i++) {\n\t\tret = ad5770r_set_output_mode(st,  &st->output_mode[i], i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tst->external_res = fwnode_property_read_bool(st->spi->dev.fwnode,\n\t\t\t\t\t\t     \"adi,external-resistor\");\n\n\tret = ad5770r_set_reference(st);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(st->regmap, AD5770R_CHANNEL_CONFIG, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(st->regmap, AD5770R_CH_ENABLE, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < AD5770R_MAX_CHANNELS; i++)\n\t\tst->ch_pwr_down[i] = true;\n\n\treturn ret;\n}\n\nstatic void ad5770r_disable_regulator(void *data)\n{\n\tstruct ad5770r_state *st = data;\n\n\tregulator_disable(st->vref_reg);\n}\n\nstatic int ad5770r_probe(struct spi_device *spi)\n{\n\tstruct ad5770r_state *st;\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tspi_set_drvdata(spi, indio_dev);\n\n\tst->spi = spi;\n\n\tregmap = devm_regmap_init_spi(spi, &ad5770r_spi_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&spi->dev, \"Error initializing spi regmap: %ld\\n\",\n\t\t\tPTR_ERR(regmap));\n\t\treturn PTR_ERR(regmap);\n\t}\n\tst->regmap = regmap;\n\n\tst->vref_reg = devm_regulator_get_optional(&spi->dev, \"vref\");\n\tif (!IS_ERR(st->vref_reg)) {\n\t\tret = regulator_enable(st->vref_reg);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"Failed to enable vref regulators: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_add_action_or_reset(&spi->dev,\n\t\t\t\t\t       ad5770r_disable_regulator,\n\t\t\t\t\t       st);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regulator_get_voltage(st->vref_reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tst->vref = ret / 1000;\n\t} else {\n\t\tif (PTR_ERR(st->vref_reg) == -ENODEV) {\n\t\t\tst->vref = AD5770R_LOW_VREF_mV;\n\t\t\tst->internal_ref = true;\n\t\t} else {\n\t\t\treturn PTR_ERR(st->vref_reg);\n\t\t}\n\t}\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->info = &ad5770r_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = ad5770r_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ad5770r_channels);\n\n\tret = ad5770r_init(st);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"AD5770R init failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&st->spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id ad5770r_of_id[] = {\n\t{ .compatible = \"adi,ad5770r\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ad5770r_of_id);\n\nstatic const struct spi_device_id ad5770r_id[] = {\n\t{ \"ad5770r\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(spi, ad5770r_id);\n\nstatic struct spi_driver ad5770r_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = ad5770r_of_id,\n\t},\n\t.probe = ad5770r_probe,\n\t.id_table = ad5770r_id,\n};\n\nmodule_spi_driver(ad5770r_driver);\n\nMODULE_AUTHOR(\"Mircea Caprioru <mircea.caprioru@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5770R IDAC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}