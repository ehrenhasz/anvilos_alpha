{
  "module_name": "ad5504.c",
  "hash_id": "46ad435e746d9501ff62af5bbc523f3905c7bf75a72b58b3d2b20c9cac77c6fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad5504.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/regulator/consumer.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n#include <linux/iio/dac/ad5504.h>\n\n#define AD5504_RES_MASK\t\t\tGENMASK(11, 0)\n#define AD5504_CMD_READ\t\t\tBIT(15)\n#define AD5504_CMD_WRITE\t\t0\n#define AD5504_ADDR(addr)\t\t((addr) << 12)\n\n \n#define AD5504_ADDR_NOOP\t\t0\n#define AD5504_ADDR_DAC(x)\t\t((x) + 1)\n#define AD5504_ADDR_ALL_DAC\t\t5\n#define AD5504_ADDR_CTRL\t\t7\n\n \n#define AD5504_DAC_PWR(ch)\t\t((ch) << 2)\n#define AD5504_DAC_PWRDWN_MODE(mode)\t((mode) << 6)\n#define AD5504_DAC_PWRDN_20K\t\t0\n#define AD5504_DAC_PWRDN_3STATE\t\t1\n\n \nstruct ad5504_state {\n\tstruct spi_device\t\t*spi;\n\tstruct regulator\t\t*reg;\n\tunsigned short\t\t\tvref_mv;\n\tunsigned\t\t\tpwr_down_mask;\n\tunsigned\t\t\tpwr_down_mode;\n\n\t__be16\t\t\t\tdata[2] __aligned(IIO_DMA_MINALIGN);\n};\n\n \nenum ad5504_supported_device_ids {\n\tID_AD5504,\n\tID_AD5501,\n};\n\nstatic int ad5504_spi_write(struct ad5504_state *st, u8 addr, u16 val)\n{\n\tst->data[0] = cpu_to_be16(AD5504_CMD_WRITE | AD5504_ADDR(addr) |\n\t\t\t      (val & AD5504_RES_MASK));\n\n\treturn spi_write(st->spi, &st->data[0], 2);\n}\n\nstatic int ad5504_spi_read(struct ad5504_state *st, u8 addr)\n{\n\tint ret;\n\tstruct spi_transfer t = {\n\t    .tx_buf = &st->data[0],\n\t    .rx_buf = &st->data[1],\n\t    .len = 2,\n\t};\n\n\tst->data[0] = cpu_to_be16(AD5504_CMD_READ | AD5504_ADDR(addr));\n\tret = spi_sync_transfer(st->spi, &t, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn be16_to_cpu(st->data[1]) & AD5504_RES_MASK;\n}\n\nstatic int ad5504_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tstruct ad5504_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = ad5504_spi_read(st, chan->address);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = st->vref_mv;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ad5504_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val,\n\t\t\t       int val2,\n\t\t\t       long mask)\n{\n\tstruct ad5504_state *st = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val >= (1 << chan->scan_type.realbits) || val < 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn ad5504_spi_write(st, chan->address, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const char * const ad5504_powerdown_modes[] = {\n\t\"20kohm_to_gnd\",\n\t\"three_state\",\n};\n\nstatic int ad5504_get_powerdown_mode(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan)\n{\n\tstruct ad5504_state *st = iio_priv(indio_dev);\n\n\treturn st->pwr_down_mode;\n}\n\nstatic int ad5504_set_powerdown_mode(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, unsigned int mode)\n{\n\tstruct ad5504_state *st = iio_priv(indio_dev);\n\n\tst->pwr_down_mode = mode;\n\n\treturn 0;\n}\n\nstatic const struct iio_enum ad5504_powerdown_mode_enum = {\n\t.items = ad5504_powerdown_modes,\n\t.num_items = ARRAY_SIZE(ad5504_powerdown_modes),\n\t.get = ad5504_get_powerdown_mode,\n\t.set = ad5504_set_powerdown_mode,\n};\n\nstatic ssize_t ad5504_read_dac_powerdown(struct iio_dev *indio_dev,\n\tuintptr_t private, const struct iio_chan_spec *chan, char *buf)\n{\n\tstruct ad5504_state *st = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  !(st->pwr_down_mask & (1 << chan->channel)));\n}\n\nstatic ssize_t ad5504_write_dac_powerdown(struct iio_dev *indio_dev,\n\tuintptr_t private, const struct iio_chan_spec *chan, const char *buf,\n\tsize_t len)\n{\n\tbool pwr_down;\n\tint ret;\n\tstruct ad5504_state *st = iio_priv(indio_dev);\n\n\tret = kstrtobool(buf, &pwr_down);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pwr_down)\n\t\tst->pwr_down_mask &= ~(1 << chan->channel);\n\telse\n\t\tst->pwr_down_mask |= (1 << chan->channel);\n\n\tret = ad5504_spi_write(st, AD5504_ADDR_CTRL,\n\t\t\t\tAD5504_DAC_PWRDWN_MODE(st->pwr_down_mode) |\n\t\t\t\tAD5504_DAC_PWR(st->pwr_down_mask));\n\n\t \n\tad5504_spi_write(st, AD5504_ADDR_NOOP, 0);\n\n\treturn ret ? ret : len;\n}\n\nstatic IIO_CONST_ATTR(temp0_thresh_rising_value, \"110000\");\nstatic IIO_CONST_ATTR(temp0_thresh_rising_en, \"1\");\n\nstatic struct attribute *ad5504_ev_attributes[] = {\n\t&iio_const_attr_temp0_thresh_rising_value.dev_attr.attr,\n\t&iio_const_attr_temp0_thresh_rising_en.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ad5504_ev_attribute_group = {\n\t.attrs = ad5504_ev_attributes,\n};\n\nstatic irqreturn_t ad5504_event_handler(int irq, void *private)\n{\n\tiio_push_event(private,\n\t\t       IIO_UNMOD_EVENT_CODE(IIO_TEMP,\n\t\t\t\t\t    0,\n\t\t\t\t\t    IIO_EV_TYPE_THRESH,\n\t\t\t\t\t    IIO_EV_DIR_RISING),\n\t\t       iio_get_time_ns(private));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_info ad5504_info = {\n\t.write_raw = ad5504_write_raw,\n\t.read_raw = ad5504_read_raw,\n\t.event_attrs = &ad5504_ev_attribute_group,\n};\n\nstatic const struct iio_chan_spec_ext_info ad5504_ext_info[] = {\n\t{\n\t\t.name = \"powerdown\",\n\t\t.read = ad5504_read_dac_powerdown,\n\t\t.write = ad5504_write_dac_powerdown,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\tIIO_ENUM(\"powerdown_mode\", IIO_SHARED_BY_TYPE,\n\t\t &ad5504_powerdown_mode_enum),\n\tIIO_ENUM_AVAILABLE(\"powerdown_mode\", IIO_SHARED_BY_TYPE, &ad5504_powerdown_mode_enum),\n\t{ },\n};\n\n#define AD5504_CHANNEL(_chan) { \\\n\t.type = IIO_VOLTAGE, \\\n\t.indexed = 1, \\\n\t.output = 1, \\\n\t.channel = (_chan), \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t.address = AD5504_ADDR_DAC(_chan), \\\n\t.scan_type = { \\\n\t\t.sign = 'u', \\\n\t\t.realbits = 12, \\\n\t\t.storagebits = 16, \\\n\t}, \\\n\t.ext_info = ad5504_ext_info, \\\n}\n\nstatic const struct iio_chan_spec ad5504_channels[] = {\n\tAD5504_CHANNEL(0),\n\tAD5504_CHANNEL(1),\n\tAD5504_CHANNEL(2),\n\tAD5504_CHANNEL(3),\n};\n\nstatic int ad5504_probe(struct spi_device *spi)\n{\n\tstruct ad5504_platform_data *pdata = spi->dev.platform_data;\n\tstruct iio_dev *indio_dev;\n\tstruct ad5504_state *st;\n\tstruct regulator *reg;\n\tint ret, voltage_uv = 0;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\treg = devm_regulator_get(&spi->dev, \"vcc\");\n\tif (!IS_ERR(reg)) {\n\t\tret = regulator_enable(reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regulator_get_voltage(reg);\n\t\tif (ret < 0)\n\t\t\tgoto error_disable_reg;\n\n\t\tvoltage_uv = ret;\n\t}\n\n\tspi_set_drvdata(spi, indio_dev);\n\tst = iio_priv(indio_dev);\n\tif (voltage_uv)\n\t\tst->vref_mv = voltage_uv / 1000;\n\telse if (pdata)\n\t\tst->vref_mv = pdata->vref_mv;\n\telse\n\t\tdev_warn(&spi->dev, \"reference voltage unspecified\\n\");\n\n\tst->reg = reg;\n\tst->spi = spi;\n\tindio_dev->name = spi_get_device_id(st->spi)->name;\n\tindio_dev->info = &ad5504_info;\n\tif (spi_get_device_id(st->spi)->driver_data == ID_AD5501)\n\t\tindio_dev->num_channels = 1;\n\telse\n\t\tindio_dev->num_channels = 4;\n\tindio_dev->channels = ad5504_channels;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tif (spi->irq) {\n\t\tret = devm_request_threaded_irq(&spi->dev, spi->irq,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   &ad5504_event_handler,\n\t\t\t\t\t   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t   spi_get_device_id(st->spi)->name,\n\t\t\t\t\t   indio_dev);\n\t\tif (ret)\n\t\t\tgoto error_disable_reg;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto error_disable_reg;\n\n\treturn 0;\n\nerror_disable_reg:\n\tif (!IS_ERR(reg))\n\t\tregulator_disable(reg);\n\n\treturn ret;\n}\n\nstatic void ad5504_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct ad5504_state *st = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tif (!IS_ERR(st->reg))\n\t\tregulator_disable(st->reg);\n}\n\nstatic const struct spi_device_id ad5504_id[] = {\n\t{\"ad5504\", ID_AD5504},\n\t{\"ad5501\", ID_AD5501},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad5504_id);\n\nstatic struct spi_driver ad5504_driver = {\n\t.driver = {\n\t\t   .name = \"ad5504\",\n\t\t   },\n\t.probe = ad5504_probe,\n\t.remove = ad5504_remove,\n\t.id_table = ad5504_id,\n};\nmodule_spi_driver(ad5504_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5501/AD5501 DAC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}