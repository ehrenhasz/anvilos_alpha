{
  "module_name": "ad5755.c",
  "hash_id": "0dc67abca787c9a3b95ac99b1641526ecbb3d348fd635519c662da871bc6a3ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad5755.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/delay.h>\n#include <linux/property.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define AD5755_NUM_CHANNELS 4\n\n#define AD5755_ADDR(x)\t\t\t((x) << 16)\n\n#define AD5755_WRITE_REG_DATA(chan)\t(chan)\n#define AD5755_WRITE_REG_GAIN(chan)\t(0x08 | (chan))\n#define AD5755_WRITE_REG_OFFSET(chan)\t(0x10 | (chan))\n#define AD5755_WRITE_REG_CTRL(chan)\t(0x1c | (chan))\n\n#define AD5755_READ_REG_DATA(chan)\t(chan)\n#define AD5755_READ_REG_CTRL(chan)\t(0x4 | (chan))\n#define AD5755_READ_REG_GAIN(chan)\t(0x8 | (chan))\n#define AD5755_READ_REG_OFFSET(chan)\t(0xc | (chan))\n#define AD5755_READ_REG_CLEAR(chan)\t(0x10 | (chan))\n#define AD5755_READ_REG_SLEW(chan)\t(0x14 | (chan))\n#define AD5755_READ_REG_STATUS\t\t0x18\n#define AD5755_READ_REG_MAIN\t\t0x19\n#define AD5755_READ_REG_DC_DC\t\t0x1a\n\n#define AD5755_CTRL_REG_SLEW\t0x0\n#define AD5755_CTRL_REG_MAIN\t0x1\n#define AD5755_CTRL_REG_DAC\t0x2\n#define AD5755_CTRL_REG_DC_DC\t0x3\n#define AD5755_CTRL_REG_SW\t0x4\n\n#define AD5755_READ_FLAG 0x800000\n\n#define AD5755_NOOP 0x1CE000\n\n#define AD5755_DAC_INT_EN\t\t\tBIT(8)\n#define AD5755_DAC_CLR_EN\t\t\tBIT(7)\n#define AD5755_DAC_OUT_EN\t\t\tBIT(6)\n#define AD5755_DAC_INT_CURRENT_SENSE_RESISTOR\tBIT(5)\n#define AD5755_DAC_DC_DC_EN\t\t\tBIT(4)\n#define AD5755_DAC_VOLTAGE_OVERRANGE_EN\t\tBIT(3)\n\n#define AD5755_DC_DC_MAXV\t\t\t0\n#define AD5755_DC_DC_FREQ_SHIFT\t\t\t2\n#define AD5755_DC_DC_PHASE_SHIFT\t\t4\n#define AD5755_EXT_DC_DC_COMP_RES\t\tBIT(6)\n\n#define AD5755_SLEW_STEP_SIZE_SHIFT\t\t0\n#define AD5755_SLEW_RATE_SHIFT\t\t\t3\n#define AD5755_SLEW_ENABLE\t\t\tBIT(12)\n\nenum ad5755_mode {\n\tAD5755_MODE_VOLTAGE_0V_5V\t\t= 0,\n\tAD5755_MODE_VOLTAGE_0V_10V\t\t= 1,\n\tAD5755_MODE_VOLTAGE_PLUSMINUS_5V\t= 2,\n\tAD5755_MODE_VOLTAGE_PLUSMINUS_10V\t= 3,\n\tAD5755_MODE_CURRENT_4mA_20mA\t\t= 4,\n\tAD5755_MODE_CURRENT_0mA_20mA\t\t= 5,\n\tAD5755_MODE_CURRENT_0mA_24mA\t\t= 6,\n};\n\nenum ad5755_dc_dc_phase {\n\tAD5755_DC_DC_PHASE_ALL_SAME_EDGE\t\t= 0,\n\tAD5755_DC_DC_PHASE_A_B_SAME_EDGE_C_D_OPP_EDGE\t= 1,\n\tAD5755_DC_DC_PHASE_A_C_SAME_EDGE_B_D_OPP_EDGE\t= 2,\n\tAD5755_DC_DC_PHASE_90_DEGREE\t\t\t= 3,\n};\n\nenum ad5755_dc_dc_freq {\n\tAD5755_DC_DC_FREQ_250kHZ = 0,\n\tAD5755_DC_DC_FREQ_410kHZ = 1,\n\tAD5755_DC_DC_FREQ_650kHZ = 2,\n};\n\nenum ad5755_dc_dc_maxv {\n\tAD5755_DC_DC_MAXV_23V\t= 0,\n\tAD5755_DC_DC_MAXV_24V5\t= 1,\n\tAD5755_DC_DC_MAXV_27V\t= 2,\n\tAD5755_DC_DC_MAXV_29V5\t= 3,\n};\n\nenum ad5755_slew_rate {\n\tAD5755_SLEW_RATE_64k\t= 0,\n\tAD5755_SLEW_RATE_32k\t= 1,\n\tAD5755_SLEW_RATE_16k\t= 2,\n\tAD5755_SLEW_RATE_8k\t= 3,\n\tAD5755_SLEW_RATE_4k\t= 4,\n\tAD5755_SLEW_RATE_2k\t= 5,\n\tAD5755_SLEW_RATE_1k\t= 6,\n\tAD5755_SLEW_RATE_500\t= 7,\n\tAD5755_SLEW_RATE_250\t= 8,\n\tAD5755_SLEW_RATE_125\t= 9,\n\tAD5755_SLEW_RATE_64\t= 10,\n\tAD5755_SLEW_RATE_32\t= 11,\n\tAD5755_SLEW_RATE_16\t= 12,\n\tAD5755_SLEW_RATE_8\t= 13,\n\tAD5755_SLEW_RATE_4\t= 14,\n\tAD5755_SLEW_RATE_0_5\t= 15,\n};\n\nenum ad5755_slew_step_size {\n\tAD5755_SLEW_STEP_SIZE_1 = 0,\n\tAD5755_SLEW_STEP_SIZE_2 = 1,\n\tAD5755_SLEW_STEP_SIZE_4 = 2,\n\tAD5755_SLEW_STEP_SIZE_8 = 3,\n\tAD5755_SLEW_STEP_SIZE_16 = 4,\n\tAD5755_SLEW_STEP_SIZE_32 = 5,\n\tAD5755_SLEW_STEP_SIZE_64 = 6,\n\tAD5755_SLEW_STEP_SIZE_128 = 7,\n\tAD5755_SLEW_STEP_SIZE_256 = 8,\n};\n\n \nstruct ad5755_platform_data {\n\tbool ext_dc_dc_compenstation_resistor;\n\tenum ad5755_dc_dc_phase dc_dc_phase;\n\tenum ad5755_dc_dc_freq dc_dc_freq;\n\tenum ad5755_dc_dc_maxv dc_dc_maxv;\n\n\tstruct {\n\t\tenum ad5755_mode mode;\n\t\tbool ext_current_sense_resistor;\n\t\tbool enable_voltage_overrange;\n\t\tstruct {\n\t\t\tbool enable;\n\t\t\tenum ad5755_slew_rate rate;\n\t\t\tenum ad5755_slew_step_size step_size;\n\t\t} slew;\n\t} dac[4];\n};\n\n \nstruct ad5755_chip_info {\n\tconst struct iio_chan_spec channel_template;\n\tunsigned int calib_shift;\n\tbool has_voltage_out;\n};\n\n \nstruct ad5755_state {\n\tstruct spi_device\t\t*spi;\n\tconst struct ad5755_chip_info\t*chip_info;\n\tunsigned int\t\t\tpwr_down;\n\tunsigned int\t\t\tctrl[AD5755_NUM_CHANNELS];\n\tstruct iio_chan_spec\t\tchannels[AD5755_NUM_CHANNELS];\n\tstruct mutex\t\t\tlock;\n\n\t \n\n\tunion {\n\t\t__be32 d32;\n\t\tu8 d8[4];\n\t} data[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nenum ad5755_type {\n\tID_AD5755,\n\tID_AD5757,\n\tID_AD5735,\n\tID_AD5737,\n};\n\nstatic const int ad5755_dcdc_freq_table[][2] = {\n\t{ 250000, AD5755_DC_DC_FREQ_250kHZ },\n\t{ 410000, AD5755_DC_DC_FREQ_410kHZ },\n\t{ 650000, AD5755_DC_DC_FREQ_650kHZ }\n};\n\nstatic const int ad5755_dcdc_maxv_table[][2] = {\n\t{ 23000000, AD5755_DC_DC_MAXV_23V },\n\t{ 24500000, AD5755_DC_DC_MAXV_24V5 },\n\t{ 27000000, AD5755_DC_DC_MAXV_27V },\n\t{ 29500000, AD5755_DC_DC_MAXV_29V5 },\n};\n\nstatic const int ad5755_slew_rate_table[][2] = {\n\t{ 64000, AD5755_SLEW_RATE_64k },\n\t{ 32000, AD5755_SLEW_RATE_32k },\n\t{ 16000, AD5755_SLEW_RATE_16k },\n\t{ 8000, AD5755_SLEW_RATE_8k },\n\t{ 4000, AD5755_SLEW_RATE_4k },\n\t{ 2000, AD5755_SLEW_RATE_2k },\n\t{ 1000, AD5755_SLEW_RATE_1k },\n\t{ 500, AD5755_SLEW_RATE_500 },\n\t{ 250, AD5755_SLEW_RATE_250 },\n\t{ 125, AD5755_SLEW_RATE_125 },\n\t{ 64, AD5755_SLEW_RATE_64 },\n\t{ 32, AD5755_SLEW_RATE_32 },\n\t{ 16, AD5755_SLEW_RATE_16 },\n\t{ 8, AD5755_SLEW_RATE_8 },\n\t{ 4, AD5755_SLEW_RATE_4 },\n\t{ 0, AD5755_SLEW_RATE_0_5 },\n};\n\nstatic const int ad5755_slew_step_table[][2] = {\n\t{ 256, AD5755_SLEW_STEP_SIZE_256 },\n\t{ 128, AD5755_SLEW_STEP_SIZE_128 },\n\t{ 64, AD5755_SLEW_STEP_SIZE_64 },\n\t{ 32, AD5755_SLEW_STEP_SIZE_32 },\n\t{ 16, AD5755_SLEW_STEP_SIZE_16 },\n\t{ 4, AD5755_SLEW_STEP_SIZE_4 },\n\t{ 2, AD5755_SLEW_STEP_SIZE_2 },\n\t{ 1, AD5755_SLEW_STEP_SIZE_1 },\n};\n\nstatic int ad5755_write_unlocked(struct iio_dev *indio_dev,\n\tunsigned int reg, unsigned int val)\n{\n\tstruct ad5755_state *st = iio_priv(indio_dev);\n\n\tst->data[0].d32 = cpu_to_be32((reg << 16) | val);\n\n\treturn spi_write(st->spi, &st->data[0].d8[1], 3);\n}\n\nstatic int ad5755_write_ctrl_unlocked(struct iio_dev *indio_dev,\n\tunsigned int channel, unsigned int reg, unsigned int val)\n{\n\treturn ad5755_write_unlocked(indio_dev,\n\t\tAD5755_WRITE_REG_CTRL(channel), (reg << 13) | val);\n}\n\nstatic int ad5755_write(struct iio_dev *indio_dev, unsigned int reg,\n\tunsigned int val)\n{\n\tstruct ad5755_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = ad5755_write_unlocked(indio_dev, reg, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad5755_write_ctrl(struct iio_dev *indio_dev, unsigned int channel,\n\tunsigned int reg, unsigned int val)\n{\n\tstruct ad5755_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = ad5755_write_ctrl_unlocked(indio_dev, channel, reg, val);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad5755_read(struct iio_dev *indio_dev, unsigned int addr)\n{\n\tstruct ad5755_state *st = iio_priv(indio_dev);\n\tint ret;\n\tstruct spi_transfer t[] = {\n\t\t{\n\t\t\t.tx_buf = &st->data[0].d8[1],\n\t\t\t.len = 3,\n\t\t\t.cs_change = 1,\n\t\t}, {\n\t\t\t.tx_buf = &st->data[1].d8[1],\n\t\t\t.rx_buf = &st->data[1].d8[1],\n\t\t\t.len = 3,\n\t\t},\n\t};\n\n\tmutex_lock(&st->lock);\n\n\tst->data[0].d32 = cpu_to_be32(AD5755_READ_FLAG | (addr << 16));\n\tst->data[1].d32 = cpu_to_be32(AD5755_NOOP);\n\n\tret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\n\tif (ret >= 0)\n\t\tret = be32_to_cpu(st->data[1].d32) & 0xffff;\n\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad5755_update_dac_ctrl(struct iio_dev *indio_dev,\n\tunsigned int channel, unsigned int set, unsigned int clr)\n{\n\tstruct ad5755_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tst->ctrl[channel] |= set;\n\tst->ctrl[channel] &= ~clr;\n\n\tret = ad5755_write_ctrl_unlocked(indio_dev, channel,\n\t\tAD5755_CTRL_REG_DAC, st->ctrl[channel]);\n\n\treturn ret;\n}\n\nstatic int ad5755_set_channel_pwr_down(struct iio_dev *indio_dev,\n\tunsigned int channel, bool pwr_down)\n{\n\tstruct ad5755_state *st = iio_priv(indio_dev);\n\tunsigned int mask = BIT(channel);\n\n\tmutex_lock(&st->lock);\n\n\tif ((bool)(st->pwr_down & mask) == pwr_down)\n\t\tgoto out_unlock;\n\n\tif (!pwr_down) {\n\t\tst->pwr_down &= ~mask;\n\t\tad5755_update_dac_ctrl(indio_dev, channel,\n\t\t\tAD5755_DAC_INT_EN | AD5755_DAC_DC_DC_EN, 0);\n\t\tudelay(200);\n\t\tad5755_update_dac_ctrl(indio_dev, channel,\n\t\t\tAD5755_DAC_OUT_EN, 0);\n\t} else {\n\t\tst->pwr_down |= mask;\n\t\tad5755_update_dac_ctrl(indio_dev, channel,\n\t\t\t0, AD5755_DAC_INT_EN | AD5755_DAC_OUT_EN |\n\t\t\t\tAD5755_DAC_DC_DC_EN);\n\t}\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\n\treturn 0;\n}\n\nstatic const int ad5755_min_max_table[][2] = {\n\t[AD5755_MODE_VOLTAGE_0V_5V] = { 0, 5000 },\n\t[AD5755_MODE_VOLTAGE_0V_10V] = { 0, 10000 },\n\t[AD5755_MODE_VOLTAGE_PLUSMINUS_5V] = { -5000, 5000 },\n\t[AD5755_MODE_VOLTAGE_PLUSMINUS_10V] = { -10000, 10000 },\n\t[AD5755_MODE_CURRENT_4mA_20mA] = { 4, 20 },\n\t[AD5755_MODE_CURRENT_0mA_20mA] = { 0, 20 },\n\t[AD5755_MODE_CURRENT_0mA_24mA] = { 0, 24 },\n};\n\nstatic void ad5755_get_min_max(struct ad5755_state *st,\n\tstruct iio_chan_spec const *chan, int *min, int *max)\n{\n\tenum ad5755_mode mode = st->ctrl[chan->channel] & 7;\n\t*min = ad5755_min_max_table[mode][0];\n\t*max = ad5755_min_max_table[mode][1];\n}\n\nstatic inline int ad5755_get_offset(struct ad5755_state *st,\n\tstruct iio_chan_spec const *chan)\n{\n\tint min, max;\n\n\tad5755_get_min_max(st, chan, &min, &max);\n\treturn (min * (1 << chan->scan_type.realbits)) / (max - min);\n}\n\nstatic int ad5755_chan_reg_info(struct ad5755_state *st,\n\tstruct iio_chan_spec const *chan, long info, bool write,\n\tunsigned int *reg, unsigned int *shift, unsigned int *offset)\n{\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (write)\n\t\t\t*reg = AD5755_WRITE_REG_DATA(chan->address);\n\t\telse\n\t\t\t*reg = AD5755_READ_REG_DATA(chan->address);\n\t\t*shift = chan->scan_type.shift;\n\t\t*offset = 0;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif (write)\n\t\t\t*reg = AD5755_WRITE_REG_OFFSET(chan->address);\n\t\telse\n\t\t\t*reg = AD5755_READ_REG_OFFSET(chan->address);\n\t\t*shift = st->chip_info->calib_shift;\n\t\t*offset = 32768;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (write)\n\t\t\t*reg =  AD5755_WRITE_REG_GAIN(chan->address);\n\t\telse\n\t\t\t*reg =  AD5755_READ_REG_GAIN(chan->address);\n\t\t*shift = st->chip_info->calib_shift;\n\t\t*offset = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad5755_read_raw(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int *val, int *val2, long info)\n{\n\tstruct ad5755_state *st = iio_priv(indio_dev);\n\tunsigned int reg, shift, offset;\n\tint min, max;\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tad5755_get_min_max(st, chan, &min, &max);\n\t\t*val = max - min;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = ad5755_get_offset(st, chan);\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\tret = ad5755_chan_reg_info(st, chan, info, false,\n\t\t\t\t\t\t&reg, &shift, &offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ad5755_read(indio_dev, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = (ret - offset) >> shift;\n\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ad5755_write_raw(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int val, int val2, long info)\n{\n\tstruct ad5755_state *st = iio_priv(indio_dev);\n\tunsigned int shift, reg, offset;\n\tint ret;\n\n\tret = ad5755_chan_reg_info(st, chan, info, true,\n\t\t\t\t\t&reg, &shift, &offset);\n\tif (ret)\n\t\treturn ret;\n\n\tval <<= shift;\n\tval += offset;\n\n\tif (val < 0 || val > 0xffff)\n\t\treturn -EINVAL;\n\n\treturn ad5755_write(indio_dev, reg, val);\n}\n\nstatic ssize_t ad5755_read_powerdown(struct iio_dev *indio_dev, uintptr_t priv,\n\tconst struct iio_chan_spec *chan, char *buf)\n{\n\tstruct ad5755_state *st = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  (bool)(st->pwr_down & (1 << chan->channel)));\n}\n\nstatic ssize_t ad5755_write_powerdown(struct iio_dev *indio_dev, uintptr_t priv,\n\tstruct iio_chan_spec const *chan, const char *buf, size_t len)\n{\n\tbool pwr_down;\n\tint ret;\n\n\tret = kstrtobool(buf, &pwr_down);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad5755_set_channel_pwr_down(indio_dev, chan->channel, pwr_down);\n\treturn ret ? ret : len;\n}\n\nstatic const struct iio_info ad5755_info = {\n\t.read_raw = ad5755_read_raw,\n\t.write_raw = ad5755_write_raw,\n};\n\nstatic const struct iio_chan_spec_ext_info ad5755_ext_info[] = {\n\t{\n\t\t.name = \"powerdown\",\n\t\t.read = ad5755_read_powerdown,\n\t\t.write = ad5755_write_powerdown,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\t{ },\n};\n\n#define AD5755_CHANNEL(_bits) {\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_SCALE) |\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_OFFSET) |\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) |\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = (_bits),\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.shift = 16 - (_bits),\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.ext_info = ad5755_ext_info,\t\t\t\t\\\n}\n\nstatic const struct ad5755_chip_info ad5755_chip_info_tbl[] = {\n\t[ID_AD5735] = {\n\t\t.channel_template = AD5755_CHANNEL(14),\n\t\t.has_voltage_out = true,\n\t\t.calib_shift = 4,\n\t},\n\t[ID_AD5737] = {\n\t\t.channel_template = AD5755_CHANNEL(14),\n\t\t.has_voltage_out = false,\n\t\t.calib_shift = 4,\n\t},\n\t[ID_AD5755] = {\n\t\t.channel_template = AD5755_CHANNEL(16),\n\t\t.has_voltage_out = true,\n\t\t.calib_shift = 0,\n\t},\n\t[ID_AD5757] = {\n\t\t.channel_template = AD5755_CHANNEL(16),\n\t\t.has_voltage_out = false,\n\t\t.calib_shift = 0,\n\t},\n};\n\nstatic bool ad5755_is_valid_mode(struct ad5755_state *st, enum ad5755_mode mode)\n{\n\tswitch (mode) {\n\tcase AD5755_MODE_VOLTAGE_0V_5V:\n\tcase AD5755_MODE_VOLTAGE_0V_10V:\n\tcase AD5755_MODE_VOLTAGE_PLUSMINUS_5V:\n\tcase AD5755_MODE_VOLTAGE_PLUSMINUS_10V:\n\t\treturn st->chip_info->has_voltage_out;\n\tcase AD5755_MODE_CURRENT_4mA_20mA:\n\tcase AD5755_MODE_CURRENT_0mA_20mA:\n\tcase AD5755_MODE_CURRENT_0mA_24mA:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int ad5755_setup_pdata(struct iio_dev *indio_dev,\n\t\t\t      const struct ad5755_platform_data *pdata)\n{\n\tstruct ad5755_state *st = iio_priv(indio_dev);\n\tunsigned int val;\n\tunsigned int i;\n\tint ret;\n\n\tif (pdata->dc_dc_phase > AD5755_DC_DC_PHASE_90_DEGREE ||\n\t\tpdata->dc_dc_freq > AD5755_DC_DC_FREQ_650kHZ ||\n\t\tpdata->dc_dc_maxv > AD5755_DC_DC_MAXV_29V5)\n\t\treturn -EINVAL;\n\n\tval = pdata->dc_dc_maxv << AD5755_DC_DC_MAXV;\n\tval |= pdata->dc_dc_freq << AD5755_DC_DC_FREQ_SHIFT;\n\tval |= pdata->dc_dc_phase << AD5755_DC_DC_PHASE_SHIFT;\n\tif (pdata->ext_dc_dc_compenstation_resistor)\n\t\tval |= AD5755_EXT_DC_DC_COMP_RES;\n\n\tret = ad5755_write_ctrl(indio_dev, 0, AD5755_CTRL_REG_DC_DC, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(pdata->dac); ++i) {\n\t\tval = pdata->dac[i].slew.step_size <<\n\t\t\tAD5755_SLEW_STEP_SIZE_SHIFT;\n\t\tval |= pdata->dac[i].slew.rate <<\n\t\t\tAD5755_SLEW_RATE_SHIFT;\n\t\tif (pdata->dac[i].slew.enable)\n\t\t\tval |= AD5755_SLEW_ENABLE;\n\n\t\tret = ad5755_write_ctrl(indio_dev, i,\n\t\t\t\t\tAD5755_CTRL_REG_SLEW, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pdata->dac); ++i) {\n\t\tif (!ad5755_is_valid_mode(st, pdata->dac[i].mode))\n\t\t\treturn -EINVAL;\n\n\t\tval = 0;\n\t\tif (!pdata->dac[i].ext_current_sense_resistor)\n\t\t\tval |= AD5755_DAC_INT_CURRENT_SENSE_RESISTOR;\n\t\tif (pdata->dac[i].enable_voltage_overrange)\n\t\t\tval |= AD5755_DAC_VOLTAGE_OVERRANGE_EN;\n\t\tval |= pdata->dac[i].mode;\n\n\t\tret = ad5755_update_dac_ctrl(indio_dev, i, val, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool ad5755_is_voltage_mode(enum ad5755_mode mode)\n{\n\tswitch (mode) {\n\tcase AD5755_MODE_VOLTAGE_0V_5V:\n\tcase AD5755_MODE_VOLTAGE_0V_10V:\n\tcase AD5755_MODE_VOLTAGE_PLUSMINUS_5V:\n\tcase AD5755_MODE_VOLTAGE_PLUSMINUS_10V:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int ad5755_init_channels(struct iio_dev *indio_dev,\n\t\t\t\tconst struct ad5755_platform_data *pdata)\n{\n\tstruct ad5755_state *st = iio_priv(indio_dev);\n\tstruct iio_chan_spec *channels = st->channels;\n\tunsigned int i;\n\n\tfor (i = 0; i < AD5755_NUM_CHANNELS; ++i) {\n\t\tchannels[i] = st->chip_info->channel_template;\n\t\tchannels[i].channel = i;\n\t\tchannels[i].address = i;\n\t\tif (pdata && ad5755_is_voltage_mode(pdata->dac[i].mode))\n\t\t\tchannels[i].type = IIO_VOLTAGE;\n\t\telse\n\t\t\tchannels[i].type = IIO_CURRENT;\n\t}\n\n\tindio_dev->channels = channels;\n\n\treturn 0;\n}\n\n#define AD5755_DEFAULT_DAC_PDATA { \\\n\t\t.mode = AD5755_MODE_CURRENT_4mA_20mA, \\\n\t\t.ext_current_sense_resistor = true, \\\n\t\t.enable_voltage_overrange = false, \\\n\t\t.slew = { \\\n\t\t\t.enable = false, \\\n\t\t\t.rate = AD5755_SLEW_RATE_64k, \\\n\t\t\t.step_size = AD5755_SLEW_STEP_SIZE_1, \\\n\t\t}, \\\n\t}\n\nstatic const struct ad5755_platform_data ad5755_default_pdata = {\n\t.ext_dc_dc_compenstation_resistor = false,\n\t.dc_dc_phase = AD5755_DC_DC_PHASE_ALL_SAME_EDGE,\n\t.dc_dc_freq = AD5755_DC_DC_FREQ_410kHZ,\n\t.dc_dc_maxv = AD5755_DC_DC_MAXV_23V,\n\t.dac = {\n\t\t[0] = AD5755_DEFAULT_DAC_PDATA,\n\t\t[1] = AD5755_DEFAULT_DAC_PDATA,\n\t\t[2] = AD5755_DEFAULT_DAC_PDATA,\n\t\t[3] = AD5755_DEFAULT_DAC_PDATA,\n\t},\n};\n\nstatic struct ad5755_platform_data *ad5755_parse_fw(struct device *dev)\n{\n\tstruct fwnode_handle *pp;\n\tstruct ad5755_platform_data *pdata;\n\tunsigned int tmp;\n\tunsigned int tmparray[3];\n\tint devnr, i;\n\n\tif (!dev_fwnode(dev))\n\t\treturn NULL;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tpdata->ext_dc_dc_compenstation_resistor =\n\t    device_property_read_bool(dev, \"adi,ext-dc-dc-compenstation-resistor\");\n\n\tpdata->dc_dc_phase = AD5755_DC_DC_PHASE_ALL_SAME_EDGE;\n\tdevice_property_read_u32(dev, \"adi,dc-dc-phase\", &pdata->dc_dc_phase);\n\n\tpdata->dc_dc_freq = AD5755_DC_DC_FREQ_410kHZ;\n\tif (!device_property_read_u32(dev, \"adi,dc-dc-freq-hz\", &tmp)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(ad5755_dcdc_freq_table); i++) {\n\t\t\tif (tmp == ad5755_dcdc_freq_table[i][0]) {\n\t\t\t\tpdata->dc_dc_freq = ad5755_dcdc_freq_table[i][1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == ARRAY_SIZE(ad5755_dcdc_freq_table))\n\t\t\tdev_err(dev,\n\t\t\t\t\"adi,dc-dc-freq out of range selecting 410kHz\\n\");\n\t}\n\n\tpdata->dc_dc_maxv = AD5755_DC_DC_MAXV_23V;\n\tif (!device_property_read_u32(dev, \"adi,dc-dc-max-microvolt\", &tmp)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(ad5755_dcdc_maxv_table); i++) {\n\t\t\tif (tmp == ad5755_dcdc_maxv_table[i][0]) {\n\t\t\t\tpdata->dc_dc_maxv = ad5755_dcdc_maxv_table[i][1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ARRAY_SIZE(ad5755_dcdc_maxv_table))\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"adi,dc-dc-maxv out of range selecting 23V\\n\");\n\t}\n\n\tdevnr = 0;\n\tdevice_for_each_child_node(dev, pp) {\n\t\tif (devnr >= AD5755_NUM_CHANNELS) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"There are too many channels defined in DT\\n\");\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tpdata->dac[devnr].mode = AD5755_MODE_CURRENT_4mA_20mA;\n\t\tfwnode_property_read_u32(pp, \"adi,mode\", &pdata->dac[devnr].mode);\n\n\t\tpdata->dac[devnr].ext_current_sense_resistor =\n\t\t    fwnode_property_read_bool(pp, \"adi,ext-current-sense-resistor\");\n\n\t\tpdata->dac[devnr].enable_voltage_overrange =\n\t\t    fwnode_property_read_bool(pp, \"adi,enable-voltage-overrange\");\n\n\t\tif (!fwnode_property_read_u32_array(pp, \"adi,slew\", tmparray, 3)) {\n\t\t\tpdata->dac[devnr].slew.enable = tmparray[0];\n\n\t\t\tpdata->dac[devnr].slew.rate = AD5755_SLEW_RATE_64k;\n\t\t\tfor (i = 0; i < ARRAY_SIZE(ad5755_slew_rate_table); i++) {\n\t\t\t\tif (tmparray[1] == ad5755_slew_rate_table[i][0]) {\n\t\t\t\t\tpdata->dac[devnr].slew.rate =\n\t\t\t\t\t\tad5755_slew_rate_table[i][1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == ARRAY_SIZE(ad5755_slew_rate_table))\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"channel %d slew rate out of range selecting 64kHz\\n\",\n\t\t\t\t\tdevnr);\n\n\t\t\tpdata->dac[devnr].slew.step_size = AD5755_SLEW_STEP_SIZE_1;\n\t\t\tfor (i = 0; i < ARRAY_SIZE(ad5755_slew_step_table); i++) {\n\t\t\t\tif (tmparray[2] == ad5755_slew_step_table[i][0]) {\n\t\t\t\t\tpdata->dac[devnr].slew.step_size =\n\t\t\t\t\t\tad5755_slew_step_table[i][1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == ARRAY_SIZE(ad5755_slew_step_table))\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"channel %d slew step size out of range selecting 1 LSB\\n\",\n\t\t\t\t\tdevnr);\n\t\t} else {\n\t\t\tpdata->dac[devnr].slew.enable = false;\n\t\t\tpdata->dac[devnr].slew.rate = AD5755_SLEW_RATE_64k;\n\t\t\tpdata->dac[devnr].slew.step_size =\n\t\t\t    AD5755_SLEW_STEP_SIZE_1;\n\t\t}\n\t\tdevnr++;\n\t}\n\n\treturn pdata;\n\n error_out:\n\tfwnode_handle_put(pp);\n\tdevm_kfree(dev, pdata);\n\treturn NULL;\n}\n\nstatic int ad5755_probe(struct spi_device *spi)\n{\n\tenum ad5755_type type = spi_get_device_id(spi)->driver_data;\n\tconst struct ad5755_platform_data *pdata;\n\tstruct iio_dev *indio_dev;\n\tstruct ad5755_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL) {\n\t\tdev_err(&spi->dev, \"Failed to allocate iio device\\n\");\n\t\treturn  -ENOMEM;\n\t}\n\n\tst = iio_priv(indio_dev);\n\tspi_set_drvdata(spi, indio_dev);\n\n\tst->chip_info = &ad5755_chip_info_tbl[type];\n\tst->spi = spi;\n\tst->pwr_down = 0xf;\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->info = &ad5755_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->num_channels = AD5755_NUM_CHANNELS;\n\n\tmutex_init(&st->lock);\n\n\n\tpdata = ad5755_parse_fw(&spi->dev);\n\tif (!pdata) {\n\t\tdev_warn(&spi->dev, \"no firmware provided parameters? using default\\n\");\n\t\tpdata = &ad5755_default_pdata;\n\t}\n\n\tret = ad5755_init_channels(indio_dev, pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad5755_setup_pdata(indio_dev, pdata);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id ad5755_id[] = {\n\t{ \"ad5755\", ID_AD5755 },\n\t{ \"ad5755-1\", ID_AD5755 },\n\t{ \"ad5757\", ID_AD5757 },\n\t{ \"ad5735\", ID_AD5735 },\n\t{ \"ad5737\", ID_AD5737 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad5755_id);\n\nstatic const struct of_device_id ad5755_of_match[] = {\n\t{ .compatible = \"adi,ad5755\" },\n\t{ .compatible = \"adi,ad5755-1\" },\n\t{ .compatible = \"adi,ad5757\" },\n\t{ .compatible = \"adi,ad5735\" },\n\t{ .compatible = \"adi,ad5737\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ad5755_of_match);\n\nstatic struct spi_driver ad5755_driver = {\n\t.driver = {\n\t\t.name = \"ad5755\",\n\t},\n\t.probe = ad5755_probe,\n\t.id_table = ad5755_id,\n};\nmodule_spi_driver(ad5755_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5755/55-1/57/35/37 DAC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}