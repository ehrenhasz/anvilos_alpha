{
  "module_name": "ltc1660.c",
  "hash_id": "5d9bafd0617d40a1942a4d686e1a658df01aa652af3b1b5b9b2f7e59c3be8b51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ltc1660.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n\n#define LTC1660_REG_WAKE\t0x0\n#define LTC1660_REG_DAC_A\t0x1\n#define LTC1660_REG_DAC_B\t0x2\n#define LTC1660_REG_DAC_C\t0x3\n#define LTC1660_REG_DAC_D\t0x4\n#define LTC1660_REG_DAC_E\t0x5\n#define LTC1660_REG_DAC_F\t0x6\n#define LTC1660_REG_DAC_G\t0x7\n#define LTC1660_REG_DAC_H\t0x8\n#define LTC1660_REG_SLEEP\t0xe\n\n#define LTC1660_NUM_CHANNELS\t8\n\nstatic const struct regmap_config ltc1660_regmap_config = {\n\t.reg_bits = 4,\n\t.val_bits = 12,\n};\n\nenum ltc1660_supported_device_ids {\n\tID_LTC1660,\n\tID_LTC1665,\n};\n\nstruct ltc1660_priv {\n\tstruct spi_device *spi;\n\tstruct regmap *regmap;\n\tstruct regulator *vref_reg;\n\tunsigned int value[LTC1660_NUM_CHANNELS];\n\tunsigned int vref_mv;\n};\n\nstatic int ltc1660_read_raw(struct iio_dev *indio_dev,\n\t\tstruct iio_chan_spec const *chan,\n\t\tint *val,\n\t\tint *val2,\n\t\tlong mask)\n{\n\tstruct ltc1660_priv *priv = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*val = priv->value[chan->channel];\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = regulator_get_voltage(priv->vref_reg);\n\t\tif (*val < 0) {\n\t\t\tdev_err(&priv->spi->dev, \"failed to read vref regulator: %d\\n\",\n\t\t\t\t\t*val);\n\t\t\treturn *val;\n\t\t}\n\n\t\t \n\t\t*val /= 1000;\n\t\t*val2 = chan->scan_type.realbits;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ltc1660_write_raw(struct iio_dev *indio_dev,\n\t\tstruct iio_chan_spec const *chan,\n\t\tint val,\n\t\tint val2,\n\t\tlong mask)\n{\n\tstruct ltc1660_priv *priv = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val2 != 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (val < 0 || val > GENMASK(chan->scan_type.realbits - 1, 0))\n\t\t\treturn -EINVAL;\n\n\t\tret = regmap_write(priv->regmap, chan->channel,\n\t\t\t\t\t(val << chan->scan_type.shift));\n\t\tif (!ret)\n\t\t\tpriv->value[chan->channel] = val;\n\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#define LTC1660_CHAN(chan, bits) {\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\\\n\t.channel = chan,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.scan_type = {\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\\\n\t\t.realbits = (bits),\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\\\n\t\t.shift = 12 - (bits),\t\t\t\\\n\t},\t\t\t\t\t\t\\\n}\n\n#define  LTC1660_OCTAL_CHANNELS(bits) {\t\t\t\\\n\t\tLTC1660_CHAN(LTC1660_REG_DAC_A, bits),\t\\\n\t\tLTC1660_CHAN(LTC1660_REG_DAC_B, bits),\t\\\n\t\tLTC1660_CHAN(LTC1660_REG_DAC_C, bits),\t\\\n\t\tLTC1660_CHAN(LTC1660_REG_DAC_D, bits),\t\\\n\t\tLTC1660_CHAN(LTC1660_REG_DAC_E, bits),\t\\\n\t\tLTC1660_CHAN(LTC1660_REG_DAC_F, bits),\t\\\n\t\tLTC1660_CHAN(LTC1660_REG_DAC_G, bits),\t\\\n\t\tLTC1660_CHAN(LTC1660_REG_DAC_H, bits),\t\\\n}\n\nstatic const struct iio_chan_spec ltc1660_channels[][LTC1660_NUM_CHANNELS] = {\n\t[ID_LTC1660] = LTC1660_OCTAL_CHANNELS(10),\n\t[ID_LTC1665] = LTC1660_OCTAL_CHANNELS(8),\n};\n\nstatic const struct iio_info ltc1660_info = {\n\t.read_raw = &ltc1660_read_raw,\n\t.write_raw = &ltc1660_write_raw,\n};\n\nstatic int ltc1660_suspend(struct device *dev)\n{\n\tstruct ltc1660_priv *priv = iio_priv(spi_get_drvdata(\n\t\t\t\t\t\tto_spi_device(dev)));\n\treturn regmap_write(priv->regmap, LTC1660_REG_SLEEP, 0x00);\n}\n\nstatic int ltc1660_resume(struct device *dev)\n{\n\tstruct ltc1660_priv *priv = iio_priv(spi_get_drvdata(\n\t\t\t\t\t\tto_spi_device(dev)));\n\treturn regmap_write(priv->regmap, LTC1660_REG_WAKE, 0x00);\n}\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ltc1660_pm_ops, ltc1660_suspend,\n\t\t\t\tltc1660_resume);\n\nstatic int ltc1660_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct ltc1660_priv *priv;\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*priv));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tpriv = iio_priv(indio_dev);\n\tpriv->regmap = devm_regmap_init_spi(spi, &ltc1660_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(&spi->dev, \"failed to register spi regmap %ld\\n\",\n\t\t\tPTR_ERR(priv->regmap));\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\n\tpriv->vref_reg = devm_regulator_get(&spi->dev, \"vref\");\n\tif (IS_ERR(priv->vref_reg))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(priv->vref_reg),\n\t\t\t\t     \"vref regulator not specified\\n\");\n\n\tret = regulator_enable(priv->vref_reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to enable vref regulator: %d\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tpriv->spi = spi;\n\tspi_set_drvdata(spi, indio_dev);\n\tindio_dev->info = &ltc1660_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = ltc1660_channels[id->driver_data];\n\tindio_dev->num_channels = LTC1660_NUM_CHANNELS;\n\tindio_dev->name = id->name;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to register iio device: %d\\n\",\n\t\t\t\tret);\n\t\tgoto error_disable_reg;\n\t}\n\n\treturn 0;\n\nerror_disable_reg:\n\tregulator_disable(priv->vref_reg);\n\n\treturn ret;\n}\n\nstatic void ltc1660_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct ltc1660_priv *priv = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tregulator_disable(priv->vref_reg);\n}\n\nstatic const struct of_device_id ltc1660_dt_ids[] = {\n\t{ .compatible = \"lltc,ltc1660\", .data = (void *)ID_LTC1660 },\n\t{ .compatible = \"lltc,ltc1665\", .data = (void *)ID_LTC1665 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ltc1660_dt_ids);\n\nstatic const struct spi_device_id ltc1660_id[] = {\n\t{\"ltc1660\", ID_LTC1660},\n\t{\"ltc1665\", ID_LTC1665},\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, ltc1660_id);\n\nstatic struct spi_driver ltc1660_driver = {\n\t.driver = {\n\t\t.name = \"ltc1660\",\n\t\t.of_match_table = ltc1660_dt_ids,\n\t\t.pm = pm_sleep_ptr(&ltc1660_pm_ops),\n\t},\n\t.probe\t= ltc1660_probe,\n\t.remove = ltc1660_remove,\n\t.id_table = ltc1660_id,\n};\nmodule_spi_driver(ltc1660_driver);\n\nMODULE_AUTHOR(\"Marcus Folkesson <marcus.folkesson@gmail.com>\");\nMODULE_DESCRIPTION(\"Linear Technology LTC1660/LTC1665 DAC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}