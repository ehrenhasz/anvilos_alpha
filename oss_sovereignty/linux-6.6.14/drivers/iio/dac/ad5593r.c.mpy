{
  "module_name": "ad5593r.c",
  "hash_id": "df3be60b176eaa099cc141d524795c6dd70c0eb16b1cb96db0f4b9a30d113a19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad5593r.c",
  "human_readable_source": "\n \n\n#include \"ad5592r-base.h\"\n\n#include <linux/bitops.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n\n#include <asm/unaligned.h>\n\n#define AD5593R_MODE_CONF\t\t(0 << 4)\n#define AD5593R_MODE_DAC_WRITE\t\t(1 << 4)\n#define AD5593R_MODE_ADC_READBACK\t(4 << 4)\n#define AD5593R_MODE_DAC_READBACK\t(5 << 4)\n#define AD5593R_MODE_GPIO_READBACK\t(6 << 4)\n#define AD5593R_MODE_REG_READBACK\t(7 << 4)\n\nstatic int ad5593r_read_word(struct i2c_client *i2c, u8 reg, u16 *value)\n{\n\tint ret;\n\tu8 buf[2];\n\n\tret = i2c_smbus_write_byte(i2c, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_master_recv(i2c, buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*value = get_unaligned_be16(buf);\n\n\treturn 0;\n}\n\nstatic int ad5593r_write_dac(struct ad5592r_state *st, unsigned chan, u16 value)\n{\n\tstruct i2c_client *i2c = to_i2c_client(st->dev);\n\n\treturn i2c_smbus_write_word_swapped(i2c,\n\t\t\tAD5593R_MODE_DAC_WRITE | chan, value);\n}\n\nstatic int ad5593r_read_adc(struct ad5592r_state *st, unsigned chan, u16 *value)\n{\n\tstruct i2c_client *i2c = to_i2c_client(st->dev);\n\ts32 val;\n\n\tval = i2c_smbus_write_word_swapped(i2c,\n\t\t\tAD5593R_MODE_CONF | AD5592R_REG_ADC_SEQ, BIT(chan));\n\tif (val < 0)\n\t\treturn (int) val;\n\n\treturn ad5593r_read_word(i2c, AD5593R_MODE_ADC_READBACK, value);\n}\n\nstatic int ad5593r_reg_write(struct ad5592r_state *st, u8 reg, u16 value)\n{\n\tstruct i2c_client *i2c = to_i2c_client(st->dev);\n\n\treturn i2c_smbus_write_word_swapped(i2c,\n\t\t\tAD5593R_MODE_CONF | reg, value);\n}\n\nstatic int ad5593r_reg_read(struct ad5592r_state *st, u8 reg, u16 *value)\n{\n\tstruct i2c_client *i2c = to_i2c_client(st->dev);\n\n\treturn ad5593r_read_word(i2c, AD5593R_MODE_REG_READBACK | reg, value);\n}\n\nstatic int ad5593r_gpio_read(struct ad5592r_state *st, u8 *value)\n{\n\tstruct i2c_client *i2c = to_i2c_client(st->dev);\n\tu16 val;\n\tint ret;\n\n\tret = ad5593r_read_word(i2c, AD5593R_MODE_GPIO_READBACK, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t*value = (u8) val;\n\n\treturn 0;\n}\n\nstatic const struct ad5592r_rw_ops ad5593r_rw_ops = {\n\t.write_dac = ad5593r_write_dac,\n\t.read_adc = ad5593r_read_adc,\n\t.reg_write = ad5593r_reg_write,\n\t.reg_read = ad5593r_reg_read,\n\t.gpio_read = ad5593r_gpio_read,\n};\n\nstatic int ad5593r_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tif (!i2c_check_functionality(i2c->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE | I2C_FUNC_I2C))\n\t\treturn -EOPNOTSUPP;\n\n\treturn ad5592r_probe(&i2c->dev, id->name, &ad5593r_rw_ops);\n}\n\nstatic void ad5593r_i2c_remove(struct i2c_client *i2c)\n{\n\tad5592r_remove(&i2c->dev);\n}\n\nstatic const struct i2c_device_id ad5593r_i2c_ids[] = {\n\t{ .name = \"ad5593r\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, ad5593r_i2c_ids);\n\nstatic const struct of_device_id ad5593r_of_match[] = {\n\t{ .compatible = \"adi,ad5593r\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ad5593r_of_match);\n\nstatic const struct acpi_device_id ad5593r_acpi_match[] = {\n\t{\"ADS5593\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, ad5593r_acpi_match);\n\nstatic struct i2c_driver ad5593r_driver = {\n\t.driver = {\n\t\t.name = \"ad5593r\",\n\t\t.of_match_table = ad5593r_of_match,\n\t\t.acpi_match_table = ad5593r_acpi_match,\n\t},\n\t.probe = ad5593r_i2c_probe,\n\t.remove = ad5593r_i2c_remove,\n\t.id_table = ad5593r_i2c_ids,\n};\nmodule_i2c_driver(ad5593r_driver);\n\nMODULE_AUTHOR(\"Paul Cercueil <paul.cercueil@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5593R multi-channel converters\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_AD5592R);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}