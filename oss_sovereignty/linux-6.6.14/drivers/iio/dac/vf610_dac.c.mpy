{
  "module_name": "vf610_dac.c",
  "hash_id": "6bb67853d62414cddd21d687fb10c358a16dab9202314c18f2fd7786df4e51c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/vf610_dac.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define VF610_DACx_STATCTRL\t\t0x20\n\n#define VF610_DAC_DACEN\t\t\tBIT(15)\n#define VF610_DAC_DACRFS\t\tBIT(14)\n#define VF610_DAC_LPEN\t\t\tBIT(11)\n\n#define VF610_DAC_DAT0(x)\t\t((x) & 0xFFF)\n\nenum vf610_conversion_mode_sel {\n\tVF610_DAC_CONV_HIGH_POWER,\n\tVF610_DAC_CONV_LOW_POWER,\n};\n\nstruct vf610_dac {\n\tstruct clk *clk;\n\tstruct device *dev;\n\tenum vf610_conversion_mode_sel conv_mode;\n\tvoid __iomem *regs;\n\tstruct mutex lock;\n};\n\nstatic void vf610_dac_init(struct vf610_dac *info)\n{\n\tint val;\n\n\tinfo->conv_mode = VF610_DAC_CONV_LOW_POWER;\n\tval = VF610_DAC_DACEN | VF610_DAC_DACRFS |\n\t\tVF610_DAC_LPEN;\n\twritel(val, info->regs + VF610_DACx_STATCTRL);\n}\n\nstatic void vf610_dac_exit(struct vf610_dac *info)\n{\n\tint val;\n\n\tval = readl(info->regs + VF610_DACx_STATCTRL);\n\tval &= ~VF610_DAC_DACEN;\n\twritel(val, info->regs + VF610_DACx_STATCTRL);\n}\n\nstatic int vf610_set_conversion_mode(struct iio_dev *indio_dev,\n\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\tunsigned int mode)\n{\n\tstruct vf610_dac *info = iio_priv(indio_dev);\n\tint val;\n\n\tmutex_lock(&info->lock);\n\tinfo->conv_mode = mode;\n\tval = readl(info->regs + VF610_DACx_STATCTRL);\n\tif (mode)\n\t\tval |= VF610_DAC_LPEN;\n\telse\n\t\tval &= ~VF610_DAC_LPEN;\n\twritel(val, info->regs + VF610_DACx_STATCTRL);\n\tmutex_unlock(&info->lock);\n\n\treturn 0;\n}\n\nstatic int vf610_get_conversion_mode(struct iio_dev *indio_dev,\n\t\t\t\tconst struct iio_chan_spec *chan)\n{\n\tstruct vf610_dac *info = iio_priv(indio_dev);\n\n\treturn info->conv_mode;\n}\n\nstatic const char * const vf610_conv_modes[] = { \"high-power\", \"low-power\" };\n\nstatic const struct iio_enum vf610_conversion_mode = {\n\t.items = vf610_conv_modes,\n\t.num_items = ARRAY_SIZE(vf610_conv_modes),\n\t.get = vf610_get_conversion_mode,\n\t.set = vf610_set_conversion_mode,\n};\n\nstatic const struct iio_chan_spec_ext_info vf610_ext_info[] = {\n\tIIO_ENUM(\"conversion_mode\", IIO_SHARED_BY_DIR,\n\t\t&vf610_conversion_mode),\n\t{},\n};\n\n#define VF610_DAC_CHAN(_chan_type) { \\\n\t.type = (_chan_type), \\\n\t.output = 1, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t.ext_info = vf610_ext_info, \\\n}\n\nstatic const struct iio_chan_spec vf610_dac_iio_channels[] = {\n\tVF610_DAC_CHAN(IIO_VOLTAGE),\n};\n\nstatic int vf610_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint *val, int *val2,\n\t\t\tlong mask)\n{\n\tstruct vf610_dac *info = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*val = VF610_DAC_DAT0(readl(info->regs));\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*val = 3300  ;\n\t\t*val2 = 12;\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vf610_write_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *chan,\n\t\t\tint val, int val2,\n\t\t\tlong mask)\n{\n\tstruct vf610_dac *info = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&info->lock);\n\t\twritel(VF610_DAC_DAT0(val), info->regs);\n\t\tmutex_unlock(&info->lock);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info vf610_dac_iio_info = {\n\t.read_raw = &vf610_read_raw,\n\t.write_raw = &vf610_write_raw,\n};\n\nstatic const struct of_device_id vf610_dac_match[] = {\n\t{ .compatible = \"fsl,vf610-dac\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, vf610_dac_match);\n\nstatic int vf610_dac_probe(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct vf610_dac *info;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev,\n\t\t\t\t\tsizeof(struct vf610_dac));\n\tif (!indio_dev) {\n\t\tdev_err(&pdev->dev, \"Failed allocating iio device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo = iio_priv(indio_dev);\n\tinfo->dev = &pdev->dev;\n\n\tinfo->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(info->regs))\n\t\treturn PTR_ERR(info->regs);\n\n\tinfo->clk = devm_clk_get(&pdev->dev, \"dac\");\n\tif (IS_ERR(info->clk)) {\n\t\tdev_err(&pdev->dev, \"Failed getting clock, err = %ld\\n\",\n\t\t\tPTR_ERR(info->clk));\n\t\treturn PTR_ERR(info->clk);\n\t}\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tindio_dev->name = dev_name(&pdev->dev);\n\tindio_dev->info = &vf610_dac_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = vf610_dac_iio_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(vf610_dac_iio_channels);\n\n\tmutex_init(&info->lock);\n\n\tret = clk_prepare_enable(info->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Could not prepare or enable the clock\\n\");\n\t\treturn ret;\n\t}\n\n\tvf610_dac_init(info);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't register the device\\n\");\n\t\tgoto error_iio_device_register;\n\t}\n\n\treturn 0;\n\nerror_iio_device_register:\n\tvf610_dac_exit(info);\n\tclk_disable_unprepare(info->clk);\n\n\treturn ret;\n}\n\nstatic int vf610_dac_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct vf610_dac *info = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tvf610_dac_exit(info);\n\tclk_disable_unprepare(info->clk);\n\n\treturn 0;\n}\n\nstatic int vf610_dac_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct vf610_dac *info = iio_priv(indio_dev);\n\n\tvf610_dac_exit(info);\n\tclk_disable_unprepare(info->clk);\n\n\treturn 0;\n}\n\nstatic int vf610_dac_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct vf610_dac *info = iio_priv(indio_dev);\n\tint ret;\n\n\tret = clk_prepare_enable(info->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tvf610_dac_init(info);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(vf610_dac_pm_ops, vf610_dac_suspend,\n\t\t\t\tvf610_dac_resume);\n\nstatic struct platform_driver vf610_dac_driver = {\n\t.probe          = vf610_dac_probe,\n\t.remove         = vf610_dac_remove,\n\t.driver         = {\n\t\t.name   = \"vf610-dac\",\n\t\t.of_match_table = vf610_dac_match,\n\t\t.pm     = pm_sleep_ptr(&vf610_dac_pm_ops),\n\t},\n};\nmodule_platform_driver(vf610_dac_driver);\n\nMODULE_AUTHOR(\"Sanchayan Maity <sanchayan.maity@toradex.com>\");\nMODULE_DESCRIPTION(\"Freescale VF610 DAC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}