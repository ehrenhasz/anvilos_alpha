{
  "module_name": "ad7303.c",
  "hash_id": "5fd12e23ad12502f60153447cc8949c01b834b758bcda0a07cf8d359a532b450",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad7303.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define AD7303_CFG_EXTERNAL_VREF BIT(15)\n#define AD7303_CFG_POWER_DOWN(ch) BIT(11 + (ch))\n#define AD7303_CFG_ADDR_OFFSET\t10\n\n#define AD7303_CMD_UPDATE_DAC\t(0x3 << 8)\n\n \n\nstruct ad7303_state {\n\tstruct spi_device *spi;\n\tuint16_t config;\n\tuint8_t dac_cache[2];\n\n\tstruct regulator *vdd_reg;\n\tstruct regulator *vref_reg;\n\n\tstruct mutex lock;\n\t \n\t__be16 data __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic int ad7303_write(struct ad7303_state *st, unsigned int chan,\n\tuint8_t val)\n{\n\tst->data = cpu_to_be16(AD7303_CMD_UPDATE_DAC |\n\t\t(chan << AD7303_CFG_ADDR_OFFSET) |\n\t\tst->config | val);\n\n\treturn spi_write(st->spi, &st->data, sizeof(st->data));\n}\n\nstatic ssize_t ad7303_read_dac_powerdown(struct iio_dev *indio_dev,\n\tuintptr_t private, const struct iio_chan_spec *chan, char *buf)\n{\n\tstruct ad7303_state *st = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", (bool)(st->config &\n\t\tAD7303_CFG_POWER_DOWN(chan->channel)));\n}\n\nstatic ssize_t ad7303_write_dac_powerdown(struct iio_dev *indio_dev,\n\t uintptr_t private, const struct iio_chan_spec *chan, const char *buf,\n\t size_t len)\n{\n\tstruct ad7303_state *st = iio_priv(indio_dev);\n\tbool pwr_down;\n\tint ret;\n\n\tret = kstrtobool(buf, &pwr_down);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\n\tif (pwr_down)\n\t\tst->config |= AD7303_CFG_POWER_DOWN(chan->channel);\n\telse\n\t\tst->config &= ~AD7303_CFG_POWER_DOWN(chan->channel);\n\n\t \n\tad7303_write(st, chan->channel, st->dac_cache[chan->channel]);\n\n\tmutex_unlock(&st->lock);\n\treturn len;\n}\n\nstatic int ad7303_get_vref(struct ad7303_state *st,\n\tstruct iio_chan_spec const *chan)\n{\n\tint ret;\n\n\tif (st->config & AD7303_CFG_EXTERNAL_VREF)\n\t\treturn regulator_get_voltage(st->vref_reg);\n\n\tret = regulator_get_voltage(st->vdd_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn ret / 2;\n}\n\nstatic int ad7303_read_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int *val, int *val2, long info)\n{\n\tstruct ad7303_state *st = iio_priv(indio_dev);\n\tint vref_uv;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&st->lock);\n\t\t*val = st->dac_cache[chan->channel];\n\t\tmutex_unlock(&st->lock);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tvref_uv = ad7303_get_vref(st, chan);\n\t\tif (vref_uv < 0)\n\t\t\treturn vref_uv;\n\n\t\t*val = 2 * vref_uv / 1000;\n\t\t*val2 = chan->scan_type.realbits;\n\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ad7303_write_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int val, int val2, long mask)\n{\n\tstruct ad7303_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val >= (1 << chan->scan_type.realbits) || val < 0)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&st->lock);\n\t\tret = ad7303_write(st, chan->address, val);\n\t\tif (ret == 0)\n\t\t\tst->dac_cache[chan->channel] = val;\n\t\tmutex_unlock(&st->lock);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct iio_info ad7303_info = {\n\t.read_raw = ad7303_read_raw,\n\t.write_raw = ad7303_write_raw,\n};\n\nstatic const struct iio_chan_spec_ext_info ad7303_ext_info[] = {\n\t{\n\t\t.name = \"powerdown\",\n\t\t.read = ad7303_read_dac_powerdown,\n\t\t.write = ad7303_write_dac_powerdown,\n\t\t.shared = IIO_SEPARATE,\n\t},\n\t{ },\n};\n\n#define AD7303_CHANNEL(chan) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\\\n\t.channel = (chan),\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.address = (chan),\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t.realbits = 8,\t\t\t\t\t\\\n\t\t.storagebits = 8,\t\t\t\t\\\n\t\t.shift = 0,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.ext_info = ad7303_ext_info,\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec ad7303_channels[] = {\n\tAD7303_CHANNEL(0),\n\tAD7303_CHANNEL(1),\n};\n\nstatic void ad7303_reg_disable(void *reg)\n{\n\tregulator_disable(reg);\n}\n\nstatic int ad7303_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tstruct iio_dev *indio_dev;\n\tstruct ad7303_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->spi = spi;\n\n\tmutex_init(&st->lock);\n\n\tst->vdd_reg = devm_regulator_get(&spi->dev, \"Vdd\");\n\tif (IS_ERR(st->vdd_reg))\n\t\treturn PTR_ERR(st->vdd_reg);\n\n\tret = regulator_enable(st->vdd_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, ad7303_reg_disable, st->vdd_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tst->vref_reg = devm_regulator_get_optional(&spi->dev, \"REF\");\n\tif (IS_ERR(st->vref_reg)) {\n\t\tret = PTR_ERR(st->vref_reg);\n\t\tif (ret != -ENODEV)\n\t\t\treturn ret;\n\t\tst->vref_reg = NULL;\n\t}\n\n\tif (st->vref_reg) {\n\t\tret = regulator_enable(st->vref_reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(&spi->dev, ad7303_reg_disable,\n\t\t\t\t\t       st->vref_reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tst->config |= AD7303_CFG_EXTERNAL_VREF;\n\t}\n\n\tindio_dev->name = id->name;\n\tindio_dev->info = &ad7303_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = ad7303_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ad7303_channels);\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id ad7303_spi_of_match[] = {\n\t{ .compatible = \"adi,ad7303\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ad7303_spi_of_match);\n\nstatic const struct spi_device_id ad7303_spi_ids[] = {\n\t{ \"ad7303\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad7303_spi_ids);\n\nstatic struct spi_driver ad7303_driver = {\n\t.driver = {\n\t\t.name = \"ad7303\",\n\t\t.of_match_table = ad7303_spi_of_match,\n\t},\n\t.probe = ad7303_probe,\n\t.id_table = ad7303_spi_ids,\n};\nmodule_spi_driver(ad7303_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Analog Devices AD7303 DAC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}