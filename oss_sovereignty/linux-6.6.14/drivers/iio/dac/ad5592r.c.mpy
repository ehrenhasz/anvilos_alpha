{
  "module_name": "ad5592r.c",
  "hash_id": "477ad13a07579afb0e8e192e51f86d03d3d95b75b84ef585780fd1fec504bba1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dac/ad5592r.c",
  "human_readable_source": "\n \n\n#include \"ad5592r-base.h\"\n\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/spi/spi.h>\n\n#define AD5592R_GPIO_READBACK_EN\tBIT(10)\n#define AD5592R_LDAC_READBACK_EN\tBIT(6)\n\nstatic int ad5592r_spi_wnop_r16(struct ad5592r_state *st, __be16 *buf)\n{\n\tstruct spi_device *spi = container_of(st->dev, struct spi_device, dev);\n\tstruct spi_transfer t = {\n\t\t\t.tx_buf\t= &st->spi_msg_nop,\n\t\t\t.rx_buf\t= buf,\n\t\t\t.len = 2\n\t\t};\n\n\tst->spi_msg_nop = 0;  \n\n\treturn spi_sync_transfer(spi, &t, 1);\n}\n\nstatic int ad5592r_write_dac(struct ad5592r_state *st, unsigned chan, u16 value)\n{\n\tstruct spi_device *spi = container_of(st->dev, struct spi_device, dev);\n\n\tst->spi_msg = cpu_to_be16(BIT(15) | (chan << 12) | value);\n\n\treturn spi_write(spi, &st->spi_msg, sizeof(st->spi_msg));\n}\n\nstatic int ad5592r_read_adc(struct ad5592r_state *st, unsigned chan, u16 *value)\n{\n\tstruct spi_device *spi = container_of(st->dev, struct spi_device, dev);\n\tint ret;\n\n\tst->spi_msg = cpu_to_be16((AD5592R_REG_ADC_SEQ << 11) | BIT(chan));\n\n\tret = spi_write(spi, &st->spi_msg, sizeof(st->spi_msg));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ad5592r_spi_wnop_r16(st, &st->spi_msg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad5592r_spi_wnop_r16(st, &st->spi_msg);\n\tif (ret)\n\t\treturn ret;\n\n\t*value = be16_to_cpu(st->spi_msg);\n\n\treturn 0;\n}\n\nstatic int ad5592r_reg_write(struct ad5592r_state *st, u8 reg, u16 value)\n{\n\tstruct spi_device *spi = container_of(st->dev, struct spi_device, dev);\n\n\tst->spi_msg = cpu_to_be16((reg << 11) | value);\n\n\treturn spi_write(spi, &st->spi_msg, sizeof(st->spi_msg));\n}\n\nstatic int ad5592r_reg_read(struct ad5592r_state *st, u8 reg, u16 *value)\n{\n\tstruct spi_device *spi = container_of(st->dev, struct spi_device, dev);\n\tint ret;\n\n\tst->spi_msg = cpu_to_be16((AD5592R_REG_LDAC << 11) |\n\t\t\t\t   AD5592R_LDAC_READBACK_EN | (reg << 2));\n\n\tret = spi_write(spi, &st->spi_msg, sizeof(st->spi_msg));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad5592r_spi_wnop_r16(st, &st->spi_msg);\n\tif (ret)\n\t\treturn ret;\n\n\t*value = be16_to_cpu(st->spi_msg);\n\n\treturn 0;\n}\n\nstatic int ad5592r_gpio_read(struct ad5592r_state *st, u8 *value)\n{\n\tint ret;\n\n\tret = ad5592r_reg_write(st, AD5592R_REG_GPIO_IN_EN,\n\t\t\t\tAD5592R_GPIO_READBACK_EN | st->gpio_in);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad5592r_spi_wnop_r16(st, &st->spi_msg);\n\tif (ret)\n\t\treturn ret;\n\n\t*value = (u8) be16_to_cpu(st->spi_msg);\n\n\treturn 0;\n}\n\nstatic const struct ad5592r_rw_ops ad5592r_rw_ops = {\n\t.write_dac = ad5592r_write_dac,\n\t.read_adc = ad5592r_read_adc,\n\t.reg_write = ad5592r_reg_write,\n\t.reg_read = ad5592r_reg_read,\n\t.gpio_read = ad5592r_gpio_read,\n};\n\nstatic int ad5592r_spi_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\n\treturn ad5592r_probe(&spi->dev, id->name, &ad5592r_rw_ops);\n}\n\nstatic void ad5592r_spi_remove(struct spi_device *spi)\n{\n\tad5592r_remove(&spi->dev);\n}\n\nstatic const struct spi_device_id ad5592r_spi_ids[] = {\n\t{ .name = \"ad5592r\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad5592r_spi_ids);\n\nstatic const struct of_device_id ad5592r_of_match[] = {\n\t{ .compatible = \"adi,ad5592r\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ad5592r_of_match);\n\nstatic const struct acpi_device_id ad5592r_acpi_match[] = {\n\t{\"ADS5592\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, ad5592r_acpi_match);\n\nstatic struct spi_driver ad5592r_spi_driver = {\n\t.driver = {\n\t\t.name = \"ad5592r\",\n\t\t.of_match_table = ad5592r_of_match,\n\t\t.acpi_match_table = ad5592r_acpi_match,\n\t},\n\t.probe = ad5592r_spi_probe,\n\t.remove = ad5592r_spi_remove,\n\t.id_table = ad5592r_spi_ids,\n};\nmodule_spi_driver(ad5592r_spi_driver);\n\nMODULE_AUTHOR(\"Paul Cercueil <paul.cercueil@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD5592R multi-channel converters\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_AD5592R);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}