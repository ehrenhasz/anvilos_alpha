{
  "module_name": "afe4403.c",
  "hash_id": "2d4f2627922ffd1e431efbc7e2acbcb5af49946136cfe54b4d309985bbc5b65e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/health/afe4403.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/sysfs.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#include <asm/unaligned.h>\n\n#include \"afe440x.h\"\n\n#define AFE4403_DRIVER_NAME\t\t\"afe4403\"\n\n \n#define AFE4403_TIAGAIN\t\t\t0x20\n#define AFE4403_TIA_AMB_GAIN\t\t0x21\n\nenum afe4403_fields {\n\t \n\tF_RF_LED1, F_CF_LED1,\n\tF_RF_LED, F_CF_LED,\n\n\t \n\tF_ILED1, F_ILED2,\n\n\t \n\tF_MAX_FIELDS\n};\n\nstatic const struct reg_field afe4403_reg_fields[] = {\n\t \n\t[F_RF_LED1]\t= REG_FIELD(AFE4403_TIAGAIN, 0, 2),\n\t[F_CF_LED1]\t= REG_FIELD(AFE4403_TIAGAIN, 3, 7),\n\t[F_RF_LED]\t= REG_FIELD(AFE4403_TIA_AMB_GAIN, 0, 2),\n\t[F_CF_LED]\t= REG_FIELD(AFE4403_TIA_AMB_GAIN, 3, 7),\n\t \n\t[F_ILED1]\t= REG_FIELD(AFE440X_LEDCNTRL, 0, 7),\n\t[F_ILED2]\t= REG_FIELD(AFE440X_LEDCNTRL, 8, 15),\n};\n\n \nstruct afe4403_data {\n\tstruct device *dev;\n\tstruct spi_device *spi;\n\tstruct regmap *regmap;\n\tstruct regmap_field *fields[F_MAX_FIELDS];\n\tstruct regulator *regulator;\n\tstruct iio_trigger *trig;\n\tint irq;\n\t \n\ts32 buffer[8] __aligned(8);\n};\n\nenum afe4403_chan_id {\n\tLED2 = 1,\n\tALED2,\n\tLED1,\n\tALED1,\n\tLED2_ALED2,\n\tLED1_ALED1,\n};\n\nstatic const unsigned int afe4403_channel_values[] = {\n\t[LED2] = AFE440X_LED2VAL,\n\t[ALED2] = AFE440X_ALED2VAL,\n\t[LED1] = AFE440X_LED1VAL,\n\t[ALED1] = AFE440X_ALED1VAL,\n\t[LED2_ALED2] = AFE440X_LED2_ALED2VAL,\n\t[LED1_ALED1] = AFE440X_LED1_ALED1VAL,\n};\n\nstatic const unsigned int afe4403_channel_leds[] = {\n\t[LED2] = F_ILED2,\n\t[LED1] = F_ILED1,\n};\n\nstatic const struct iio_chan_spec afe4403_channels[] = {\n\t \n\tAFE440X_INTENSITY_CHAN(LED2, 0),\n\tAFE440X_INTENSITY_CHAN(ALED2, 0),\n\tAFE440X_INTENSITY_CHAN(LED1, 0),\n\tAFE440X_INTENSITY_CHAN(ALED1, 0),\n\tAFE440X_INTENSITY_CHAN(LED2_ALED2, 0),\n\tAFE440X_INTENSITY_CHAN(LED1_ALED1, 0),\n\t \n\tAFE440X_CURRENT_CHAN(LED2),\n\tAFE440X_CURRENT_CHAN(LED1),\n};\n\nstatic const struct afe440x_val_table afe4403_res_table[] = {\n\t{ 500000 }, { 250000 }, { 100000 }, { 50000 },\n\t{ 25000 }, { 10000 }, { 1000000 }, { 0 },\n};\nAFE440X_TABLE_ATTR(in_intensity_resistance_available, afe4403_res_table);\n\nstatic const struct afe440x_val_table afe4403_cap_table[] = {\n\t{ 0, 5000 }, { 0, 10000 }, { 0, 20000 }, { 0, 25000 },\n\t{ 0, 30000 }, { 0, 35000 }, { 0, 45000 }, { 0, 50000 },\n\t{ 0, 55000 }, { 0, 60000 }, { 0, 70000 }, { 0, 75000 },\n\t{ 0, 80000 }, { 0, 85000 }, { 0, 95000 }, { 0, 100000 },\n\t{ 0, 155000 }, { 0, 160000 }, { 0, 170000 }, { 0, 175000 },\n\t{ 0, 180000 }, { 0, 185000 }, { 0, 195000 }, { 0, 200000 },\n\t{ 0, 205000 }, { 0, 210000 }, { 0, 220000 }, { 0, 225000 },\n\t{ 0, 230000 }, { 0, 235000 }, { 0, 245000 }, { 0, 250000 },\n};\nAFE440X_TABLE_ATTR(in_intensity_capacitance_available, afe4403_cap_table);\n\nstatic ssize_t afe440x_show_register(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct afe4403_data *afe = iio_priv(indio_dev);\n\tstruct afe440x_attr *afe440x_attr = to_afe440x_attr(attr);\n\tunsigned int reg_val;\n\tint vals[2];\n\tint ret;\n\n\tret = regmap_field_read(afe->fields[afe440x_attr->field], &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reg_val >= afe440x_attr->table_size)\n\t\treturn -EINVAL;\n\n\tvals[0] = afe440x_attr->val_table[reg_val].integer;\n\tvals[1] = afe440x_attr->val_table[reg_val].fract;\n\n\treturn iio_format_value(buf, IIO_VAL_INT_PLUS_MICRO, 2, vals);\n}\n\nstatic ssize_t afe440x_store_register(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct afe4403_data *afe = iio_priv(indio_dev);\n\tstruct afe440x_attr *afe440x_attr = to_afe440x_attr(attr);\n\tint val, integer, fract, ret;\n\n\tret = iio_str_to_fixpoint(buf, 100000, &integer, &fract);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (val = 0; val < afe440x_attr->table_size; val++)\n\t\tif (afe440x_attr->val_table[val].integer == integer &&\n\t\t    afe440x_attr->val_table[val].fract == fract)\n\t\t\tbreak;\n\tif (val == afe440x_attr->table_size)\n\t\treturn -EINVAL;\n\n\tret = regmap_field_write(afe->fields[afe440x_attr->field], val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic AFE440X_ATTR(in_intensity1_resistance, F_RF_LED, afe4403_res_table);\nstatic AFE440X_ATTR(in_intensity1_capacitance, F_CF_LED, afe4403_cap_table);\n\nstatic AFE440X_ATTR(in_intensity2_resistance, F_RF_LED, afe4403_res_table);\nstatic AFE440X_ATTR(in_intensity2_capacitance, F_CF_LED, afe4403_cap_table);\n\nstatic AFE440X_ATTR(in_intensity3_resistance, F_RF_LED1, afe4403_res_table);\nstatic AFE440X_ATTR(in_intensity3_capacitance, F_CF_LED1, afe4403_cap_table);\n\nstatic AFE440X_ATTR(in_intensity4_resistance, F_RF_LED1, afe4403_res_table);\nstatic AFE440X_ATTR(in_intensity4_capacitance, F_CF_LED1, afe4403_cap_table);\n\nstatic struct attribute *afe440x_attributes[] = {\n\t&dev_attr_in_intensity_resistance_available.attr,\n\t&dev_attr_in_intensity_capacitance_available.attr,\n\t&afe440x_attr_in_intensity1_resistance.dev_attr.attr,\n\t&afe440x_attr_in_intensity1_capacitance.dev_attr.attr,\n\t&afe440x_attr_in_intensity2_resistance.dev_attr.attr,\n\t&afe440x_attr_in_intensity2_capacitance.dev_attr.attr,\n\t&afe440x_attr_in_intensity3_resistance.dev_attr.attr,\n\t&afe440x_attr_in_intensity3_capacitance.dev_attr.attr,\n\t&afe440x_attr_in_intensity4_resistance.dev_attr.attr,\n\t&afe440x_attr_in_intensity4_capacitance.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group afe440x_attribute_group = {\n\t.attrs = afe440x_attributes\n};\n\nstatic int afe4403_read(struct afe4403_data *afe, unsigned int reg, u32 *val)\n{\n\tu8 tx[4] = {AFE440X_CONTROL0, 0x0, 0x0, AFE440X_CONTROL0_READ};\n\tu8 rx[3];\n\tint ret;\n\n\t \n\tret = spi_write_then_read(afe->spi, tx, 4, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = spi_write_then_read(afe->spi, &reg, 1, rx, sizeof(rx));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = get_unaligned_be24(&rx[0]);\n\n\t \n\ttx[3] = AFE440X_CONTROL0_WRITE;\n\tret = spi_write_then_read(afe->spi, tx, 4, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int afe4403_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct afe4403_data *afe = iio_priv(indio_dev);\n\tunsigned int reg, field;\n\tint ret;\n\n\tswitch (chan->type) {\n\tcase IIO_INTENSITY:\n\t\tswitch (mask) {\n\t\tcase IIO_CHAN_INFO_RAW:\n\t\t\treg = afe4403_channel_values[chan->address];\n\t\t\tret = afe4403_read(afe, reg, val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT;\n\t\t}\n\t\tbreak;\n\tcase IIO_CURRENT:\n\t\tswitch (mask) {\n\t\tcase IIO_CHAN_INFO_RAW:\n\t\t\tfield = afe4403_channel_leds[chan->address];\n\t\t\tret = regmap_field_read(afe->fields[field], val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_CHAN_INFO_SCALE:\n\t\t\t*val = 0;\n\t\t\t*val2 = 800000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int afe4403_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct afe4403_data *afe = iio_priv(indio_dev);\n\tunsigned int field = afe4403_channel_leds[chan->address];\n\n\tswitch (chan->type) {\n\tcase IIO_CURRENT:\n\t\tswitch (mask) {\n\t\tcase IIO_CHAN_INFO_RAW:\n\t\t\treturn regmap_field_write(afe->fields[field], val);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info afe4403_iio_info = {\n\t.attrs = &afe440x_attribute_group,\n\t.read_raw = afe4403_read_raw,\n\t.write_raw = afe4403_write_raw,\n};\n\nstatic irqreturn_t afe4403_trigger_handler(int irq, void *private)\n{\n\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct afe4403_data *afe = iio_priv(indio_dev);\n\tint ret, bit, i = 0;\n\tu8 tx[4] = {AFE440X_CONTROL0, 0x0, 0x0, AFE440X_CONTROL0_READ};\n\tu8 rx[3];\n\n\t \n\tret = spi_write_then_read(afe->spi, tx, 4, NULL, 0);\n\tif (ret)\n\t\tgoto err;\n\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\tret = spi_write_then_read(afe->spi,\n\t\t\t\t\t  &afe4403_channel_values[bit], 1,\n\t\t\t\t\t  rx, sizeof(rx));\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tafe->buffer[i++] = get_unaligned_be24(&rx[0]);\n\t}\n\n\t \n\ttx[3] = AFE440X_CONTROL0_WRITE;\n\tret = spi_write_then_read(afe->spi, tx, 4, NULL, 0);\n\tif (ret)\n\t\tgoto err;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, afe->buffer,\n\t\t\t\t\t   pf->timestamp);\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\n#define AFE4403_TIMING_PAIRS\t\t\t\\\n\t{ AFE440X_LED2STC,\t0x000050 },\t\\\n\t{ AFE440X_LED2ENDC,\t0x0003e7 },\t\\\n\t{ AFE440X_LED1LEDSTC,\t0x0007d0 },\t\\\n\t{ AFE440X_LED1LEDENDC,\t0x000bb7 },\t\\\n\t{ AFE440X_ALED2STC,\t0x000438 },\t\\\n\t{ AFE440X_ALED2ENDC,\t0x0007cf },\t\\\n\t{ AFE440X_LED1STC,\t0x000820 },\t\\\n\t{ AFE440X_LED1ENDC,\t0x000bb7 },\t\\\n\t{ AFE440X_LED2LEDSTC,\t0x000000 },\t\\\n\t{ AFE440X_LED2LEDENDC,\t0x0003e7 },\t\\\n\t{ AFE440X_ALED1STC,\t0x000c08 },\t\\\n\t{ AFE440X_ALED1ENDC,\t0x000f9f },\t\\\n\t{ AFE440X_LED2CONVST,\t0x0003ef },\t\\\n\t{ AFE440X_LED2CONVEND,\t0x0007cf },\t\\\n\t{ AFE440X_ALED2CONVST,\t0x0007d7 },\t\\\n\t{ AFE440X_ALED2CONVEND,\t0x000bb7 },\t\\\n\t{ AFE440X_LED1CONVST,\t0x000bbf },\t\\\n\t{ AFE440X_LED1CONVEND,\t0x009c3f },\t\\\n\t{ AFE440X_ALED1CONVST,\t0x000fa7 },\t\\\n\t{ AFE440X_ALED1CONVEND,\t0x001387 },\t\\\n\t{ AFE440X_ADCRSTSTCT0,\t0x0003e8 },\t\\\n\t{ AFE440X_ADCRSTENDCT0,\t0x0003eb },\t\\\n\t{ AFE440X_ADCRSTSTCT1,\t0x0007d0 },\t\\\n\t{ AFE440X_ADCRSTENDCT1,\t0x0007d3 },\t\\\n\t{ AFE440X_ADCRSTSTCT2,\t0x000bb8 },\t\\\n\t{ AFE440X_ADCRSTENDCT2,\t0x000bbb },\t\\\n\t{ AFE440X_ADCRSTSTCT3,\t0x000fa0 },\t\\\n\t{ AFE440X_ADCRSTENDCT3,\t0x000fa3 },\t\\\n\t{ AFE440X_PRPCOUNT,\t0x009c3f },\t\\\n\t{ AFE440X_PDNCYCLESTC,\t0x001518 },\t\\\n\t{ AFE440X_PDNCYCLEENDC,\t0x00991f }\n\nstatic const struct reg_sequence afe4403_reg_sequences[] = {\n\tAFE4403_TIMING_PAIRS,\n\t{ AFE440X_CONTROL1, AFE440X_CONTROL1_TIMEREN },\n\t{ AFE4403_TIAGAIN, AFE440X_TIAGAIN_ENSEPGAIN },\n};\n\nstatic const struct regmap_range afe4403_yes_ranges[] = {\n\tregmap_reg_range(AFE440X_LED2VAL, AFE440X_LED1_ALED1VAL),\n};\n\nstatic const struct regmap_access_table afe4403_volatile_table = {\n\t.yes_ranges = afe4403_yes_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(afe4403_yes_ranges),\n};\n\nstatic const struct regmap_config afe4403_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 24,\n\n\t.max_register = AFE440X_PDNCYCLEENDC,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_table = &afe4403_volatile_table,\n};\n\nstatic const struct of_device_id afe4403_of_match[] = {\n\t{ .compatible = \"ti,afe4403\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, afe4403_of_match);\n\nstatic int afe4403_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(to_spi_device(dev));\n\tstruct afe4403_data *afe = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regmap_update_bits(afe->regmap, AFE440X_CONTROL2,\n\t\t\t\t AFE440X_CONTROL2_PDN_AFE,\n\t\t\t\t AFE440X_CONTROL2_PDN_AFE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_disable(afe->regulator);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to disable regulator\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int afe4403_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(to_spi_device(dev));\n\tstruct afe4403_data *afe = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_enable(afe->regulator);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to enable regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(afe->regmap, AFE440X_CONTROL2,\n\t\t\t\t AFE440X_CONTROL2_PDN_AFE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(afe4403_pm_ops, afe4403_suspend,\n\t\t\t\tafe4403_resume);\n\nstatic int afe4403_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct afe4403_data *afe;\n\tint i, ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*afe));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tafe = iio_priv(indio_dev);\n\tspi_set_drvdata(spi, indio_dev);\n\n\tafe->dev = &spi->dev;\n\tafe->spi = spi;\n\tafe->irq = spi->irq;\n\n\tafe->regmap = devm_regmap_init_spi(spi, &afe4403_regmap_config);\n\tif (IS_ERR(afe->regmap)) {\n\t\tdev_err(afe->dev, \"Unable to allocate register map\\n\");\n\t\treturn PTR_ERR(afe->regmap);\n\t}\n\n\tfor (i = 0; i < F_MAX_FIELDS; i++) {\n\t\tafe->fields[i] = devm_regmap_field_alloc(afe->dev, afe->regmap,\n\t\t\t\t\t\t\t afe4403_reg_fields[i]);\n\t\tif (IS_ERR(afe->fields[i])) {\n\t\t\tdev_err(afe->dev, \"Unable to allocate regmap fields\\n\");\n\t\t\treturn PTR_ERR(afe->fields[i]);\n\t\t}\n\t}\n\n\tafe->regulator = devm_regulator_get(afe->dev, \"tx_sup\");\n\tif (IS_ERR(afe->regulator))\n\t\treturn dev_err_probe(afe->dev, PTR_ERR(afe->regulator),\n\t\t\t\t     \"Unable to get regulator\\n\");\n\n\tret = regulator_enable(afe->regulator);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"Unable to enable regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(afe->regmap, AFE440X_CONTROL0,\n\t\t\t   AFE440X_CONTROL0_SW_RESET);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"Unable to reset device\\n\");\n\t\tgoto err_disable_reg;\n\t}\n\n\tret = regmap_multi_reg_write(afe->regmap, afe4403_reg_sequences,\n\t\t\t\t     ARRAY_SIZE(afe4403_reg_sequences));\n\tif (ret) {\n\t\tdev_err(afe->dev, \"Unable to set register defaults\\n\");\n\t\tgoto err_disable_reg;\n\t}\n\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = afe4403_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(afe4403_channels);\n\tindio_dev->name = AFE4403_DRIVER_NAME;\n\tindio_dev->info = &afe4403_iio_info;\n\n\tif (afe->irq > 0) {\n\t\tafe->trig = devm_iio_trigger_alloc(afe->dev,\n\t\t\t\t\t\t   \"%s-dev%d\",\n\t\t\t\t\t\t   indio_dev->name,\n\t\t\t\t\t\t   iio_device_id(indio_dev));\n\t\tif (!afe->trig) {\n\t\t\tdev_err(afe->dev, \"Unable to allocate IIO trigger\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_disable_reg;\n\t\t}\n\n\t\tiio_trigger_set_drvdata(afe->trig, indio_dev);\n\n\t\tret = iio_trigger_register(afe->trig);\n\t\tif (ret) {\n\t\t\tdev_err(afe->dev, \"Unable to register IIO trigger\\n\");\n\t\t\tgoto err_disable_reg;\n\t\t}\n\n\t\tret = devm_request_threaded_irq(afe->dev, afe->irq,\n\t\t\t\t\t\tiio_trigger_generic_data_rdy_poll,\n\t\t\t\t\t\tNULL, IRQF_ONESHOT,\n\t\t\t\t\t\tAFE4403_DRIVER_NAME,\n\t\t\t\t\t\tafe->trig);\n\t\tif (ret) {\n\t\t\tdev_err(afe->dev, \"Unable to request IRQ\\n\");\n\t\t\tgoto err_trig;\n\t\t}\n\t}\n\n\tret = iio_triggered_buffer_setup(indio_dev, &iio_pollfunc_store_time,\n\t\t\t\t\t afe4403_trigger_handler, NULL);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"Unable to setup buffer\\n\");\n\t\tgoto err_trig;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"Unable to register IIO device\\n\");\n\t\tgoto err_buff;\n\t}\n\n\treturn 0;\n\nerr_buff:\n\tiio_triggered_buffer_cleanup(indio_dev);\nerr_trig:\n\tif (afe->irq > 0)\n\t\tiio_trigger_unregister(afe->trig);\nerr_disable_reg:\n\tregulator_disable(afe->regulator);\n\n\treturn ret;\n}\n\nstatic void afe4403_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct afe4403_data *afe = iio_priv(indio_dev);\n\tint ret;\n\n\tiio_device_unregister(indio_dev);\n\n\tiio_triggered_buffer_cleanup(indio_dev);\n\n\tif (afe->irq > 0)\n\t\tiio_trigger_unregister(afe->trig);\n\n\tret = regulator_disable(afe->regulator);\n\tif (ret)\n\t\tdev_warn(afe->dev, \"Unable to disable regulator\\n\");\n}\n\nstatic const struct spi_device_id afe4403_ids[] = {\n\t{ \"afe4403\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, afe4403_ids);\n\nstatic struct spi_driver afe4403_spi_driver = {\n\t.driver = {\n\t\t.name = AFE4403_DRIVER_NAME,\n\t\t.of_match_table = afe4403_of_match,\n\t\t.pm = pm_sleep_ptr(&afe4403_pm_ops),\n\t},\n\t.probe = afe4403_probe,\n\t.remove = afe4403_remove,\n\t.id_table = afe4403_ids,\n};\nmodule_spi_driver(afe4403_spi_driver);\n\nMODULE_AUTHOR(\"Andrew F. Davis <afd@ti.com>\");\nMODULE_DESCRIPTION(\"TI AFE4403 Heart Rate Monitor and Pulse Oximeter AFE\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}