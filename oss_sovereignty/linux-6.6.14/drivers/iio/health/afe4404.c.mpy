{
  "module_name": "afe4404.c",
  "hash_id": "f1b888c7669de6f54081fb5ce06e7865f06de450b880899e9834ffc1092108db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/health/afe4404.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/sysfs.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#include \"afe440x.h\"\n\n#define AFE4404_DRIVER_NAME\t\t\"afe4404\"\n\n \n#define AFE4404_TIA_GAIN_SEP\t\t0x20\n#define AFE4404_TIA_GAIN\t\t0x21\n#define AFE4404_PROG_TG_STC\t\t0x34\n#define AFE4404_PROG_TG_ENDC\t\t0x35\n#define AFE4404_LED3LEDSTC\t\t0x36\n#define AFE4404_LED3LEDENDC\t\t0x37\n#define AFE4404_CLKDIV_PRF\t\t0x39\n#define AFE4404_OFFDAC\t\t\t0x3a\n#define AFE4404_DEC\t\t\t0x3d\n#define AFE4404_AVG_LED2_ALED2VAL\t0x3f\n#define AFE4404_AVG_LED1_ALED1VAL\t0x40\n\n \n#define AFE440X_CONTROL2_OSC_ENABLE\tBIT(9)\n\nenum afe4404_fields {\n\t \n\tF_TIA_GAIN_SEP, F_TIA_CF_SEP,\n\tF_TIA_GAIN, TIA_CF,\n\n\t \n\tF_ILED1, F_ILED2, F_ILED3,\n\n\t \n\tF_OFFDAC_AMB2, F_OFFDAC_LED1, F_OFFDAC_AMB1, F_OFFDAC_LED2,\n\n\t \n\tF_MAX_FIELDS\n};\n\nstatic const struct reg_field afe4404_reg_fields[] = {\n\t \n\t[F_TIA_GAIN_SEP]\t= REG_FIELD(AFE4404_TIA_GAIN_SEP, 0, 2),\n\t[F_TIA_CF_SEP]\t\t= REG_FIELD(AFE4404_TIA_GAIN_SEP, 3, 5),\n\t[F_TIA_GAIN]\t\t= REG_FIELD(AFE4404_TIA_GAIN, 0, 2),\n\t[TIA_CF]\t\t= REG_FIELD(AFE4404_TIA_GAIN, 3, 5),\n\t \n\t[F_ILED1]\t\t= REG_FIELD(AFE440X_LEDCNTRL, 0, 5),\n\t[F_ILED2]\t\t= REG_FIELD(AFE440X_LEDCNTRL, 6, 11),\n\t[F_ILED3]\t\t= REG_FIELD(AFE440X_LEDCNTRL, 12, 17),\n\t \n\t[F_OFFDAC_AMB2]\t\t= REG_FIELD(AFE4404_OFFDAC, 0, 4),\n\t[F_OFFDAC_LED1]\t\t= REG_FIELD(AFE4404_OFFDAC, 5, 9),\n\t[F_OFFDAC_AMB1]\t\t= REG_FIELD(AFE4404_OFFDAC, 10, 14),\n\t[F_OFFDAC_LED2]\t\t= REG_FIELD(AFE4404_OFFDAC, 15, 19),\n};\n\n \nstruct afe4404_data {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regmap_field *fields[F_MAX_FIELDS];\n\tstruct regulator *regulator;\n\tstruct iio_trigger *trig;\n\tint irq;\n\ts32 buffer[10] __aligned(8);\n};\n\nenum afe4404_chan_id {\n\tLED2 = 1,\n\tALED2,\n\tLED1,\n\tALED1,\n\tLED2_ALED2,\n\tLED1_ALED1,\n};\n\nstatic const unsigned int afe4404_channel_values[] = {\n\t[LED2] = AFE440X_LED2VAL,\n\t[ALED2] = AFE440X_ALED2VAL,\n\t[LED1] = AFE440X_LED1VAL,\n\t[ALED1] = AFE440X_ALED1VAL,\n\t[LED2_ALED2] = AFE440X_LED2_ALED2VAL,\n\t[LED1_ALED1] = AFE440X_LED1_ALED1VAL,\n};\n\nstatic const unsigned int afe4404_channel_leds[] = {\n\t[LED2] = F_ILED2,\n\t[ALED2] = F_ILED3,\n\t[LED1] = F_ILED1,\n};\n\nstatic const unsigned int afe4404_channel_offdacs[] = {\n\t[LED2] = F_OFFDAC_LED2,\n\t[ALED2] = F_OFFDAC_AMB2,\n\t[LED1] = F_OFFDAC_LED1,\n\t[ALED1] = F_OFFDAC_AMB1,\n};\n\nstatic const struct iio_chan_spec afe4404_channels[] = {\n\t \n\tAFE440X_INTENSITY_CHAN(LED2, BIT(IIO_CHAN_INFO_OFFSET)),\n\tAFE440X_INTENSITY_CHAN(ALED2, BIT(IIO_CHAN_INFO_OFFSET)),\n\tAFE440X_INTENSITY_CHAN(LED1, BIT(IIO_CHAN_INFO_OFFSET)),\n\tAFE440X_INTENSITY_CHAN(ALED1, BIT(IIO_CHAN_INFO_OFFSET)),\n\tAFE440X_INTENSITY_CHAN(LED2_ALED2, 0),\n\tAFE440X_INTENSITY_CHAN(LED1_ALED1, 0),\n\t \n\tAFE440X_CURRENT_CHAN(LED2),\n\tAFE440X_CURRENT_CHAN(ALED2),\n\tAFE440X_CURRENT_CHAN(LED1),\n};\n\nstatic const struct afe440x_val_table afe4404_res_table[] = {\n\t{ .integer = 500000, .fract = 0 },\n\t{ .integer = 250000, .fract = 0 },\n\t{ .integer = 100000, .fract = 0 },\n\t{ .integer = 50000, .fract = 0 },\n\t{ .integer = 25000, .fract = 0 },\n\t{ .integer = 10000, .fract = 0 },\n\t{ .integer = 1000000, .fract = 0 },\n\t{ .integer = 2000000, .fract = 0 },\n};\nAFE440X_TABLE_ATTR(in_intensity_resistance_available, afe4404_res_table);\n\nstatic const struct afe440x_val_table afe4404_cap_table[] = {\n\t{ .integer = 0, .fract = 5000 },\n\t{ .integer = 0, .fract = 2500 },\n\t{ .integer = 0, .fract = 10000 },\n\t{ .integer = 0, .fract = 7500 },\n\t{ .integer = 0, .fract = 20000 },\n\t{ .integer = 0, .fract = 17500 },\n\t{ .integer = 0, .fract = 25000 },\n\t{ .integer = 0, .fract = 22500 },\n};\nAFE440X_TABLE_ATTR(in_intensity_capacitance_available, afe4404_cap_table);\n\nstatic ssize_t afe440x_show_register(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct afe4404_data *afe = iio_priv(indio_dev);\n\tstruct afe440x_attr *afe440x_attr = to_afe440x_attr(attr);\n\tunsigned int reg_val;\n\tint vals[2];\n\tint ret;\n\n\tret = regmap_field_read(afe->fields[afe440x_attr->field], &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reg_val >= afe440x_attr->table_size)\n\t\treturn -EINVAL;\n\n\tvals[0] = afe440x_attr->val_table[reg_val].integer;\n\tvals[1] = afe440x_attr->val_table[reg_val].fract;\n\n\treturn iio_format_value(buf, IIO_VAL_INT_PLUS_MICRO, 2, vals);\n}\n\nstatic ssize_t afe440x_store_register(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct afe4404_data *afe = iio_priv(indio_dev);\n\tstruct afe440x_attr *afe440x_attr = to_afe440x_attr(attr);\n\tint val, integer, fract, ret;\n\n\tret = iio_str_to_fixpoint(buf, 100000, &integer, &fract);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (val = 0; val < afe440x_attr->table_size; val++)\n\t\tif (afe440x_attr->val_table[val].integer == integer &&\n\t\t    afe440x_attr->val_table[val].fract == fract)\n\t\t\tbreak;\n\tif (val == afe440x_attr->table_size)\n\t\treturn -EINVAL;\n\n\tret = regmap_field_write(afe->fields[afe440x_attr->field], val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic AFE440X_ATTR(in_intensity1_resistance, F_TIA_GAIN_SEP, afe4404_res_table);\nstatic AFE440X_ATTR(in_intensity1_capacitance, F_TIA_CF_SEP, afe4404_cap_table);\n\nstatic AFE440X_ATTR(in_intensity2_resistance, F_TIA_GAIN_SEP, afe4404_res_table);\nstatic AFE440X_ATTR(in_intensity2_capacitance, F_TIA_CF_SEP, afe4404_cap_table);\n\nstatic AFE440X_ATTR(in_intensity3_resistance, F_TIA_GAIN, afe4404_res_table);\nstatic AFE440X_ATTR(in_intensity3_capacitance, TIA_CF, afe4404_cap_table);\n\nstatic AFE440X_ATTR(in_intensity4_resistance, F_TIA_GAIN, afe4404_res_table);\nstatic AFE440X_ATTR(in_intensity4_capacitance, TIA_CF, afe4404_cap_table);\n\nstatic struct attribute *afe440x_attributes[] = {\n\t&dev_attr_in_intensity_resistance_available.attr,\n\t&dev_attr_in_intensity_capacitance_available.attr,\n\t&afe440x_attr_in_intensity1_resistance.dev_attr.attr,\n\t&afe440x_attr_in_intensity1_capacitance.dev_attr.attr,\n\t&afe440x_attr_in_intensity2_resistance.dev_attr.attr,\n\t&afe440x_attr_in_intensity2_capacitance.dev_attr.attr,\n\t&afe440x_attr_in_intensity3_resistance.dev_attr.attr,\n\t&afe440x_attr_in_intensity3_capacitance.dev_attr.attr,\n\t&afe440x_attr_in_intensity4_resistance.dev_attr.attr,\n\t&afe440x_attr_in_intensity4_capacitance.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group afe440x_attribute_group = {\n\t.attrs = afe440x_attributes\n};\n\nstatic int afe4404_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct afe4404_data *afe = iio_priv(indio_dev);\n\tunsigned int value_reg, led_field, offdac_field;\n\tint ret;\n\n\tswitch (chan->type) {\n\tcase IIO_INTENSITY:\n\t\tswitch (mask) {\n\t\tcase IIO_CHAN_INFO_RAW:\n\t\t\tvalue_reg = afe4404_channel_values[chan->address];\n\t\t\tret = regmap_read(afe->regmap, value_reg, val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_CHAN_INFO_OFFSET:\n\t\t\toffdac_field = afe4404_channel_offdacs[chan->address];\n\t\t\tret = regmap_field_read(afe->fields[offdac_field], val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT;\n\t\t}\n\t\tbreak;\n\tcase IIO_CURRENT:\n\t\tswitch (mask) {\n\t\tcase IIO_CHAN_INFO_RAW:\n\t\t\tled_field = afe4404_channel_leds[chan->address];\n\t\t\tret = regmap_field_read(afe->fields[led_field], val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_CHAN_INFO_SCALE:\n\t\t\t*val = 0;\n\t\t\t*val2 = 800000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int afe4404_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct afe4404_data *afe = iio_priv(indio_dev);\n\tunsigned int led_field, offdac_field;\n\n\tswitch (chan->type) {\n\tcase IIO_INTENSITY:\n\t\tswitch (mask) {\n\t\tcase IIO_CHAN_INFO_OFFSET:\n\t\t\toffdac_field = afe4404_channel_offdacs[chan->address];\n\t\t\treturn regmap_field_write(afe->fields[offdac_field], val);\n\t\t}\n\t\tbreak;\n\tcase IIO_CURRENT:\n\t\tswitch (mask) {\n\t\tcase IIO_CHAN_INFO_RAW:\n\t\t\tled_field = afe4404_channel_leds[chan->address];\n\t\t\treturn regmap_field_write(afe->fields[led_field], val);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info afe4404_iio_info = {\n\t.attrs = &afe440x_attribute_group,\n\t.read_raw = afe4404_read_raw,\n\t.write_raw = afe4404_write_raw,\n};\n\nstatic irqreturn_t afe4404_trigger_handler(int irq, void *private)\n{\n\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct afe4404_data *afe = iio_priv(indio_dev);\n\tint ret, bit, i = 0;\n\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\tret = regmap_read(afe->regmap, afe4404_channel_values[bit],\n\t\t\t\t  &afe->buffer[i++]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, afe->buffer,\n\t\t\t\t\t   pf->timestamp);\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\n \n#define AFE4404_TIMING_PAIRS\t\t\t\\\n\t{ AFE440X_PRPCOUNT,\t39999\t},\t\\\n\t{ AFE440X_LED2LEDSTC,\t0\t},\t\\\n\t{ AFE440X_LED2LEDENDC,\t398\t},\t\\\n\t{ AFE440X_LED2STC,\t80\t},\t\\\n\t{ AFE440X_LED2ENDC,\t398\t},\t\\\n\t{ AFE440X_ADCRSTSTCT0,\t5600\t},\t\\\n\t{ AFE440X_ADCRSTENDCT0,\t5606\t},\t\\\n\t{ AFE440X_LED2CONVST,\t5607\t},\t\\\n\t{ AFE440X_LED2CONVEND,\t6066\t},\t\\\n\t{ AFE4404_LED3LEDSTC,\t400\t},\t\\\n\t{ AFE4404_LED3LEDENDC,\t798\t},\t\\\n\t{ AFE440X_ALED2STC,\t480\t},\t\\\n\t{ AFE440X_ALED2ENDC,\t798\t},\t\\\n\t{ AFE440X_ADCRSTSTCT1,\t6068\t},\t\\\n\t{ AFE440X_ADCRSTENDCT1,\t6074\t},\t\\\n\t{ AFE440X_ALED2CONVST,\t6075\t},\t\\\n\t{ AFE440X_ALED2CONVEND,\t6534\t},\t\\\n\t{ AFE440X_LED1LEDSTC,\t800\t},\t\\\n\t{ AFE440X_LED1LEDENDC,\t1198\t},\t\\\n\t{ AFE440X_LED1STC,\t880\t},\t\\\n\t{ AFE440X_LED1ENDC,\t1198\t},\t\\\n\t{ AFE440X_ADCRSTSTCT2,\t6536\t},\t\\\n\t{ AFE440X_ADCRSTENDCT2,\t6542\t},\t\\\n\t{ AFE440X_LED1CONVST,\t6543\t},\t\\\n\t{ AFE440X_LED1CONVEND,\t7003\t},\t\\\n\t{ AFE440X_ALED1STC,\t1280\t},\t\\\n\t{ AFE440X_ALED1ENDC,\t1598\t},\t\\\n\t{ AFE440X_ADCRSTSTCT3,\t7005\t},\t\\\n\t{ AFE440X_ADCRSTENDCT3,\t7011\t},\t\\\n\t{ AFE440X_ALED1CONVST,\t7012\t},\t\\\n\t{ AFE440X_ALED1CONVEND,\t7471\t},\t\\\n\t{ AFE440X_PDNCYCLESTC,\t7671\t},\t\\\n\t{ AFE440X_PDNCYCLEENDC,\t39199\t}\n\nstatic const struct reg_sequence afe4404_reg_sequences[] = {\n\tAFE4404_TIMING_PAIRS,\n\t{ AFE440X_CONTROL1, AFE440X_CONTROL1_TIMEREN },\n\t{ AFE4404_TIA_GAIN_SEP, AFE440X_TIAGAIN_ENSEPGAIN },\n\t{ AFE440X_CONTROL2, AFE440X_CONTROL2_OSC_ENABLE\t},\n};\n\nstatic const struct regmap_range afe4404_yes_ranges[] = {\n\tregmap_reg_range(AFE440X_LED2VAL, AFE440X_LED1_ALED1VAL),\n\tregmap_reg_range(AFE4404_AVG_LED2_ALED2VAL, AFE4404_AVG_LED1_ALED1VAL),\n};\n\nstatic const struct regmap_access_table afe4404_volatile_table = {\n\t.yes_ranges = afe4404_yes_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(afe4404_yes_ranges),\n};\n\nstatic const struct regmap_config afe4404_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 24,\n\n\t.max_register = AFE4404_AVG_LED1_ALED1VAL,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_table = &afe4404_volatile_table,\n};\n\nstatic const struct of_device_id afe4404_of_match[] = {\n\t{ .compatible = \"ti,afe4404\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, afe4404_of_match);\n\nstatic int afe4404_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct afe4404_data *afe = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regmap_update_bits(afe->regmap, AFE440X_CONTROL2,\n\t\t\t\t AFE440X_CONTROL2_PDN_AFE,\n\t\t\t\t AFE440X_CONTROL2_PDN_AFE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_disable(afe->regulator);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to disable regulator\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int afe4404_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct afe4404_data *afe = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regulator_enable(afe->regulator);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to enable regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(afe->regmap, AFE440X_CONTROL2,\n\t\t\t\t AFE440X_CONTROL2_PDN_AFE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(afe4404_pm_ops, afe4404_suspend,\n\t\t\t\tafe4404_resume);\n\nstatic int afe4404_probe(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct afe4404_data *afe;\n\tint i, ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*afe));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tafe = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\n\tafe->dev = &client->dev;\n\tafe->irq = client->irq;\n\n\tafe->regmap = devm_regmap_init_i2c(client, &afe4404_regmap_config);\n\tif (IS_ERR(afe->regmap)) {\n\t\tdev_err(afe->dev, \"Unable to allocate register map\\n\");\n\t\treturn PTR_ERR(afe->regmap);\n\t}\n\n\tfor (i = 0; i < F_MAX_FIELDS; i++) {\n\t\tafe->fields[i] = devm_regmap_field_alloc(afe->dev, afe->regmap,\n\t\t\t\t\t\t\t afe4404_reg_fields[i]);\n\t\tif (IS_ERR(afe->fields[i])) {\n\t\t\tdev_err(afe->dev, \"Unable to allocate regmap fields\\n\");\n\t\t\treturn PTR_ERR(afe->fields[i]);\n\t\t}\n\t}\n\n\tafe->regulator = devm_regulator_get(afe->dev, \"tx_sup\");\n\tif (IS_ERR(afe->regulator))\n\t\treturn dev_err_probe(afe->dev, PTR_ERR(afe->regulator),\n\t\t\t\t     \"Unable to get regulator\\n\");\n\n\tret = regulator_enable(afe->regulator);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"Unable to enable regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(afe->regmap, AFE440X_CONTROL0,\n\t\t\t   AFE440X_CONTROL0_SW_RESET);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"Unable to reset device\\n\");\n\t\tgoto disable_reg;\n\t}\n\n\tret = regmap_multi_reg_write(afe->regmap, afe4404_reg_sequences,\n\t\t\t\t     ARRAY_SIZE(afe4404_reg_sequences));\n\tif (ret) {\n\t\tdev_err(afe->dev, \"Unable to set register defaults\\n\");\n\t\tgoto disable_reg;\n\t}\n\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = afe4404_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(afe4404_channels);\n\tindio_dev->name = AFE4404_DRIVER_NAME;\n\tindio_dev->info = &afe4404_iio_info;\n\n\tif (afe->irq > 0) {\n\t\tafe->trig = devm_iio_trigger_alloc(afe->dev,\n\t\t\t\t\t\t   \"%s-dev%d\",\n\t\t\t\t\t\t   indio_dev->name,\n\t\t\t\t\t\t   iio_device_id(indio_dev));\n\t\tif (!afe->trig) {\n\t\t\tdev_err(afe->dev, \"Unable to allocate IIO trigger\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto disable_reg;\n\t\t}\n\n\t\tiio_trigger_set_drvdata(afe->trig, indio_dev);\n\n\t\tret = iio_trigger_register(afe->trig);\n\t\tif (ret) {\n\t\t\tdev_err(afe->dev, \"Unable to register IIO trigger\\n\");\n\t\t\tgoto disable_reg;\n\t\t}\n\n\t\tret = devm_request_threaded_irq(afe->dev, afe->irq,\n\t\t\t\t\t\tiio_trigger_generic_data_rdy_poll,\n\t\t\t\t\t\tNULL, IRQF_ONESHOT,\n\t\t\t\t\t\tAFE4404_DRIVER_NAME,\n\t\t\t\t\t\tafe->trig);\n\t\tif (ret) {\n\t\t\tdev_err(afe->dev, \"Unable to request IRQ\\n\");\n\t\t\tgoto disable_reg;\n\t\t}\n\t}\n\n\tret = iio_triggered_buffer_setup(indio_dev, &iio_pollfunc_store_time,\n\t\t\t\t\t afe4404_trigger_handler, NULL);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"Unable to setup buffer\\n\");\n\t\tgoto unregister_trigger;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"Unable to register IIO device\\n\");\n\t\tgoto unregister_triggered_buffer;\n\t}\n\n\treturn 0;\n\nunregister_triggered_buffer:\n\tiio_triggered_buffer_cleanup(indio_dev);\nunregister_trigger:\n\tif (afe->irq > 0)\n\t\tiio_trigger_unregister(afe->trig);\ndisable_reg:\n\tregulator_disable(afe->regulator);\n\n\treturn ret;\n}\n\nstatic void afe4404_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct afe4404_data *afe = iio_priv(indio_dev);\n\tint ret;\n\n\tiio_device_unregister(indio_dev);\n\n\tiio_triggered_buffer_cleanup(indio_dev);\n\n\tif (afe->irq > 0)\n\t\tiio_trigger_unregister(afe->trig);\n\n\tret = regulator_disable(afe->regulator);\n\tif (ret)\n\t\tdev_err(afe->dev, \"Unable to disable regulator\\n\");\n}\n\nstatic const struct i2c_device_id afe4404_ids[] = {\n\t{ \"afe4404\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, afe4404_ids);\n\nstatic struct i2c_driver afe4404_i2c_driver = {\n\t.driver = {\n\t\t.name = AFE4404_DRIVER_NAME,\n\t\t.of_match_table = afe4404_of_match,\n\t\t.pm = pm_sleep_ptr(&afe4404_pm_ops),\n\t},\n\t.probe = afe4404_probe,\n\t.remove = afe4404_remove,\n\t.id_table = afe4404_ids,\n};\nmodule_i2c_driver(afe4404_i2c_driver);\n\nMODULE_AUTHOR(\"Andrew F. Davis <afd@ti.com>\");\nMODULE_DESCRIPTION(\"TI AFE4404 Heart Rate Monitor and Pulse Oximeter AFE\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}