{
  "module_name": "industrialio-gts-helper.c",
  "hash_id": "9d0f008affc68af9bf30d4a26417d7bfca8b4ffad19f2579d6f1451c7d513e04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/industrialio-gts-helper.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/overflow.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/types.h>\n#include <linux/units.h>\n\n#include <linux/iio/iio-gts-helper.h>\n#include <linux/iio/types.h>\n\n \nstatic int iio_gts_get_gain(const u64 max, const u64 scale)\n{\n\tu64 full = max;\n\tint tmp = 1;\n\n\tif (scale > full || !scale)\n\t\treturn -EINVAL;\n\n\tif (U64_MAX - full < scale) {\n\t\t \n\t\tif (full - scale < scale)\n\t\t\treturn 1;\n\n\t\tfull -= scale;\n\t\ttmp++;\n\t}\n\n\twhile (full > scale * (u64)tmp)\n\t\ttmp++;\n\n\treturn tmp;\n}\n\n \nstatic int gain_get_scale_fraction(const u64 max, u64 scale, int known,\n\t\t\t\t   int *unknown)\n{\n\tint tot_gain;\n\n\ttot_gain = iio_gts_get_gain(max, scale);\n\tif (tot_gain < 0)\n\t\treturn tot_gain;\n\n\t*unknown = tot_gain / known;\n\n\t \n\tif (!*unknown || *unknown * known != tot_gain)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int iio_gts_delinearize(u64 lin_scale, unsigned long scaler,\n\t\t\t       int *scale_whole, int *scale_nano)\n{\n\tint frac;\n\n\tif (scaler > NANO)\n\t\treturn -EOVERFLOW;\n\n\tif (!scaler)\n\t\treturn -EINVAL;\n\n\tfrac = do_div(lin_scale, scaler);\n\n\t*scale_whole = lin_scale;\n\t*scale_nano = frac * (NANO / scaler);\n\n\treturn 0;\n}\n\nstatic int iio_gts_linearize(int scale_whole, int scale_nano,\n\t\t\t     unsigned long scaler, u64 *lin_scale)\n{\n\t \n\tif (scaler > NANO || !scaler)\n\t\treturn -EINVAL;\n\n\t*lin_scale = (u64)scale_whole * (u64)scaler +\n\t\t     (u64)(scale_nano / (NANO / scaler));\n\n\treturn 0;\n}\n\n \nint iio_gts_total_gain_to_scale(struct iio_gts *gts, int total_gain,\n\t\t\t\tint *scale_int, int *scale_nano)\n{\n\tu64 tmp;\n\n\ttmp = gts->max_scale;\n\n\tdo_div(tmp, total_gain);\n\n\treturn iio_gts_delinearize(tmp, NANO, scale_int, scale_nano);\n}\nEXPORT_SYMBOL_NS_GPL(iio_gts_total_gain_to_scale, IIO_GTS_HELPER);\n\n \nstatic void iio_gts_purge_avail_scale_table(struct iio_gts *gts)\n{\n\tint i;\n\n\tif (gts->per_time_avail_scale_tables) {\n\t\tfor (i = 0; i < gts->num_itime; i++)\n\t\t\tkfree(gts->per_time_avail_scale_tables[i]);\n\n\t\tkfree(gts->per_time_avail_scale_tables);\n\t\tgts->per_time_avail_scale_tables = NULL;\n\t}\n\n\tkfree(gts->avail_all_scales_table);\n\tgts->avail_all_scales_table = NULL;\n\n\tgts->num_avail_all_scales = 0;\n}\n\nstatic int iio_gts_gain_cmp(const void *a, const void *b)\n{\n\treturn *(int *)a - *(int *)b;\n}\n\nstatic int gain_to_scaletables(struct iio_gts *gts, int **gains, int **scales)\n{\n\tint ret, i, j, new_idx, time_idx;\n\tint *all_gains;\n\tsize_t gain_bytes;\n\n\tfor (i = 0; i < gts->num_itime; i++) {\n\t\t \n\t\tsort(gains[i], gts->num_hwgain, sizeof(int), iio_gts_gain_cmp,\n\t\t     NULL);\n\n\t\t \n\t\tfor (j = 0; j < gts->num_hwgain; j++) {\n\t\t\tret = iio_gts_total_gain_to_scale(gts, gains[i][j],\n\t\t\t\t\t\t\t  &scales[i][2 * j],\n\t\t\t\t\t\t\t  &scales[i][2 * j + 1]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tgain_bytes = array_size(gts->num_hwgain, sizeof(int));\n\tall_gains = kcalloc(gts->num_itime, gain_bytes, GFP_KERNEL);\n\tif (!all_gains)\n\t\treturn -ENOMEM;\n\n\t \n\ttime_idx = gts->num_itime - 1;\n\tmemcpy(all_gains, gains[time_idx], gain_bytes);\n\tnew_idx = gts->num_hwgain;\n\n\twhile (time_idx--) {\n\t\tfor (j = 0; j < gts->num_hwgain; j++) {\n\t\t\tint candidate = gains[time_idx][j];\n\t\t\tint chk;\n\n\t\t\tif (candidate > all_gains[new_idx - 1]) {\n\t\t\t\tall_gains[new_idx] = candidate;\n\t\t\t\tnew_idx++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (chk = 0; chk < new_idx; chk++)\n\t\t\t\tif (candidate <= all_gains[chk])\n\t\t\t\t\tbreak;\n\n\t\t\tif (candidate == all_gains[chk])\n\t\t\t\tcontinue;\n\n\t\t\tmemmove(&all_gains[chk + 1], &all_gains[chk],\n\t\t\t\t(new_idx - chk) * sizeof(int));\n\t\t\tall_gains[chk] = candidate;\n\t\t\tnew_idx++;\n\t\t}\n\t}\n\n\tgts->avail_all_scales_table = kcalloc(new_idx, 2 * sizeof(int),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!gts->avail_all_scales_table) {\n\t\tret = -ENOMEM;\n\t\tgoto free_out;\n\t}\n\tgts->num_avail_all_scales = new_idx;\n\n\tfor (i = 0; i < gts->num_avail_all_scales; i++) {\n\t\tret = iio_gts_total_gain_to_scale(gts, all_gains[i],\n\t\t\t\t\t&gts->avail_all_scales_table[i * 2],\n\t\t\t\t\t&gts->avail_all_scales_table[i * 2 + 1]);\n\n\t\tif (ret) {\n\t\t\tkfree(gts->avail_all_scales_table);\n\t\t\tgts->num_avail_all_scales = 0;\n\t\t\tgoto free_out;\n\t\t}\n\t}\n\nfree_out:\n\tkfree(all_gains);\n\n\treturn ret;\n}\n\n \nstatic int iio_gts_build_avail_scale_table(struct iio_gts *gts)\n{\n\tint **per_time_gains, **per_time_scales, i, j, ret = -ENOMEM;\n\n\tper_time_gains = kcalloc(gts->num_itime, sizeof(*per_time_gains), GFP_KERNEL);\n\tif (!per_time_gains)\n\t\treturn ret;\n\n\tper_time_scales = kcalloc(gts->num_itime, sizeof(*per_time_scales), GFP_KERNEL);\n\tif (!per_time_scales)\n\t\tgoto free_gains;\n\n\tfor (i = 0; i < gts->num_itime; i++) {\n\t\tper_time_scales[i] = kcalloc(gts->num_hwgain, 2 * sizeof(int),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!per_time_scales[i])\n\t\t\tgoto err_free_out;\n\n\t\tper_time_gains[i] = kcalloc(gts->num_hwgain, sizeof(int),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!per_time_gains[i]) {\n\t\t\tkfree(per_time_scales[i]);\n\t\t\tgoto err_free_out;\n\t\t}\n\n\t\tfor (j = 0; j < gts->num_hwgain; j++)\n\t\t\tper_time_gains[i][j] = gts->hwgain_table[j].gain *\n\t\t\t\t\t       gts->itime_table[i].mul;\n\t}\n\n\tret = gain_to_scaletables(gts, per_time_gains, per_time_scales);\n\tif (ret)\n\t\tgoto err_free_out;\n\n\tkfree(per_time_gains);\n\tgts->per_time_avail_scale_tables = per_time_scales;\n\n\treturn 0;\n\nerr_free_out:\n\tfor (i--; i; i--) {\n\t\tkfree(per_time_scales[i]);\n\t\tkfree(per_time_gains[i]);\n\t}\n\tkfree(per_time_scales);\nfree_gains:\n\tkfree(per_time_gains);\n\n\treturn ret;\n}\n\nstatic void iio_gts_us_to_int_micro(int *time_us, int *int_micro_times,\n\t\t\t\t    int num_times)\n{\n\tint i;\n\n\tfor (i = 0; i < num_times; i++) {\n\t\tint_micro_times[i * 2] = time_us[i] / 1000000;\n\t\tint_micro_times[i * 2 + 1] = time_us[i] % 1000000;\n\t}\n}\n\n \nstatic int iio_gts_build_avail_time_table(struct iio_gts *gts)\n{\n\tint *times, i, j, idx = 0, *int_micro_times;\n\n\tif (!gts->num_itime)\n\t\treturn 0;\n\n\ttimes = kcalloc(gts->num_itime, sizeof(int), GFP_KERNEL);\n\tif (!times)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = gts->num_itime - 1; i >= 0; i--) {\n\t\tint new = gts->itime_table[i].time_us;\n\n\t\tif (times[idx] < new) {\n\t\t\ttimes[idx++] = new;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j <= idx; j++) {\n\t\t\tif (times[j] > new) {\n\t\t\t\tmemmove(&times[j + 1], &times[j],\n\t\t\t\t\t(idx - j) * sizeof(int));\n\t\t\t\ttimes[j] = new;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tint_micro_times = kcalloc(idx, sizeof(int) * 2, GFP_KERNEL);\n\tif (int_micro_times) {\n\t\t \n\t\tgts->num_avail_time_tables = idx;\n\t\tiio_gts_us_to_int_micro(times, int_micro_times, idx);\n\t}\n\n\tgts->avail_time_tables = int_micro_times;\n\tkfree(times);\n\n\tif (!int_micro_times)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic void iio_gts_purge_avail_time_table(struct iio_gts *gts)\n{\n\tif (gts->num_avail_time_tables) {\n\t\tkfree(gts->avail_time_tables);\n\t\tgts->avail_time_tables = NULL;\n\t\tgts->num_avail_time_tables = 0;\n\t}\n}\n\n \nstatic int iio_gts_build_avail_tables(struct iio_gts *gts)\n{\n\tint ret;\n\n\tret = iio_gts_build_avail_scale_table(gts);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iio_gts_build_avail_time_table(gts);\n\tif (ret)\n\t\tiio_gts_purge_avail_scale_table(gts);\n\n\treturn ret;\n}\n\n \nstatic void iio_gts_purge_avail_tables(struct iio_gts *gts)\n{\n\tiio_gts_purge_avail_time_table(gts);\n\tiio_gts_purge_avail_scale_table(gts);\n}\n\nstatic void devm_iio_gts_avail_all_drop(void *res)\n{\n\tiio_gts_purge_avail_tables(res);\n}\n\n \nstatic int devm_iio_gts_build_avail_tables(struct device *dev,\n\t\t\t\t\t   struct iio_gts *gts)\n{\n\tint ret;\n\n\tret = iio_gts_build_avail_tables(gts);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, devm_iio_gts_avail_all_drop, gts);\n}\n\nstatic int sanity_check_time(const struct iio_itime_sel_mul *t)\n{\n\tif (t->sel < 0 || t->time_us < 0 || t->mul <= 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sanity_check_gain(const struct iio_gain_sel_pair *g)\n{\n\tif (g->sel < 0 || g->gain <= 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int iio_gts_sanity_check(struct iio_gts *gts)\n{\n\tint g, t, ret;\n\n\tif (!gts->num_hwgain && !gts->num_itime)\n\t\treturn -EINVAL;\n\n\tfor (t = 0; t < gts->num_itime; t++) {\n\t\tret = sanity_check_time(&gts->itime_table[t]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (g = 0; g < gts->num_hwgain; g++) {\n\t\tret = sanity_check_gain(&gts->hwgain_table[g]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (g = 0; g < gts->num_hwgain; g++) {\n\t\tfor (t = 0; t < gts->num_itime; t++) {\n\t\t\tint gain, mul, res;\n\n\t\t\tgain = gts->hwgain_table[g].gain;\n\t\t\tmul = gts->itime_table[t].mul;\n\n\t\t\tif (check_mul_overflow(gain, mul, &res))\n\t\t\t\treturn -EOVERFLOW;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int iio_init_iio_gts(int max_scale_int, int max_scale_nano,\n\t\t\tconst struct iio_gain_sel_pair *gain_tbl, int num_gain,\n\t\t\tconst struct iio_itime_sel_mul *tim_tbl, int num_times,\n\t\t\tstruct iio_gts *gts)\n{\n\tint ret;\n\n\tmemset(gts, 0, sizeof(*gts));\n\n\tret = iio_gts_linearize(max_scale_int, max_scale_nano, NANO,\n\t\t\t\t   &gts->max_scale);\n\tif (ret)\n\t\treturn ret;\n\n\tgts->hwgain_table = gain_tbl;\n\tgts->num_hwgain = num_gain;\n\tgts->itime_table = tim_tbl;\n\tgts->num_itime = num_times;\n\n\treturn iio_gts_sanity_check(gts);\n}\n\n \nint devm_iio_init_iio_gts(struct device *dev, int max_scale_int, int max_scale_nano,\n\t\t\t  const struct iio_gain_sel_pair *gain_tbl, int num_gain,\n\t\t\t  const struct iio_itime_sel_mul *tim_tbl, int num_times,\n\t\t\t  struct iio_gts *gts)\n{\n\tint ret;\n\n\tret = iio_init_iio_gts(max_scale_int, max_scale_nano, gain_tbl,\n\t\t\t       num_gain, tim_tbl, num_times, gts);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_gts_build_avail_tables(dev, gts);\n}\nEXPORT_SYMBOL_NS_GPL(devm_iio_init_iio_gts, IIO_GTS_HELPER);\n\n \nint iio_gts_all_avail_scales(struct iio_gts *gts, const int **vals, int *type,\n\t\t\t     int *length)\n{\n\tif (!gts->num_avail_all_scales)\n\t\treturn -EINVAL;\n\n\t*vals = gts->avail_all_scales_table;\n\t*type = IIO_VAL_INT_PLUS_NANO;\n\t*length = gts->num_avail_all_scales * 2;\n\n\treturn IIO_AVAIL_LIST;\n}\nEXPORT_SYMBOL_NS_GPL(iio_gts_all_avail_scales, IIO_GTS_HELPER);\n\n \nint iio_gts_avail_scales_for_time(struct iio_gts *gts, int time,\n\t\t\t\t  const int **vals, int *type, int *length)\n{\n\tint i;\n\n\tfor (i = 0; i < gts->num_itime; i++)\n\t\tif (gts->itime_table[i].time_us == time)\n\t\t\tbreak;\n\n\tif (i == gts->num_itime)\n\t\treturn -EINVAL;\n\n\t*vals = gts->per_time_avail_scale_tables[i];\n\t*type = IIO_VAL_INT_PLUS_NANO;\n\t*length = gts->num_hwgain * 2;\n\n\treturn IIO_AVAIL_LIST;\n}\nEXPORT_SYMBOL_NS_GPL(iio_gts_avail_scales_for_time, IIO_GTS_HELPER);\n\n \nint iio_gts_avail_times(struct iio_gts *gts,  const int **vals, int *type,\n\t\t\tint *length)\n{\n\tif (!gts->num_avail_time_tables)\n\t\treturn -EINVAL;\n\n\t*vals = gts->avail_time_tables;\n\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t*length = gts->num_avail_time_tables * 2;\n\n\treturn IIO_AVAIL_LIST;\n}\nEXPORT_SYMBOL_NS_GPL(iio_gts_avail_times, IIO_GTS_HELPER);\n\n \nint iio_gts_find_sel_by_gain(struct iio_gts *gts, int gain)\n{\n\tint i;\n\n\tfor (i = 0; i < gts->num_hwgain; i++)\n\t\tif (gts->hwgain_table[i].gain == gain)\n\t\t\treturn gts->hwgain_table[i].sel;\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_NS_GPL(iio_gts_find_sel_by_gain, IIO_GTS_HELPER);\n\n \nint iio_gts_find_gain_by_sel(struct iio_gts *gts, int sel)\n{\n\tint i;\n\n\tfor (i = 0; i < gts->num_hwgain; i++)\n\t\tif (gts->hwgain_table[i].sel == sel)\n\t\t\treturn gts->hwgain_table[i].gain;\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_NS_GPL(iio_gts_find_gain_by_sel, IIO_GTS_HELPER);\n\n \nint iio_gts_get_min_gain(struct iio_gts *gts)\n{\n\tint i, min = -EINVAL;\n\n\tfor (i = 0; i < gts->num_hwgain; i++) {\n\t\tint gain = gts->hwgain_table[i].gain;\n\n\t\tif (min == -EINVAL)\n\t\t\tmin = gain;\n\t\telse\n\t\t\tmin = min(min, gain);\n\t}\n\n\treturn min;\n}\nEXPORT_SYMBOL_NS_GPL(iio_gts_get_min_gain, IIO_GTS_HELPER);\n\n \nint iio_find_closest_gain_low(struct iio_gts *gts, int gain, bool *in_range)\n{\n\tint i, diff = 0;\n\tint best = -1;\n\n\t*in_range = false;\n\n\tfor (i = 0; i < gts->num_hwgain; i++) {\n\t\tif (gain == gts->hwgain_table[i].gain) {\n\t\t\t*in_range = true;\n\t\t\treturn gain;\n\t\t}\n\n\t\tif (gain > gts->hwgain_table[i].gain) {\n\t\t\tif (!diff) {\n\t\t\t\tdiff = gain - gts->hwgain_table[i].gain;\n\t\t\t\tbest = i;\n\t\t\t} else {\n\t\t\t\tint tmp = gain - gts->hwgain_table[i].gain;\n\n\t\t\t\tif (tmp < diff) {\n\t\t\t\t\tdiff = tmp;\n\t\t\t\t\tbest = i;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\t*in_range = true;\n\t\t}\n\t}\n\t \n\tif (!diff) {\n\t\t*in_range = false;\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn gts->hwgain_table[best].gain;\n}\nEXPORT_SYMBOL_NS_GPL(iio_find_closest_gain_low, IIO_GTS_HELPER);\n\nstatic int iio_gts_get_int_time_gain_multiplier_by_sel(struct iio_gts *gts,\n\t\t\t\t\t\t       int sel)\n{\n\tconst struct iio_itime_sel_mul *time;\n\n\ttime = iio_gts_find_itime_by_sel(gts, sel);\n\tif (!time)\n\t\treturn -EINVAL;\n\n\treturn time->mul;\n}\n\n \nstatic int iio_gts_find_gain_for_scale_using_time(struct iio_gts *gts, int time_sel,\n\t\t\t\t\t\t  int scale_int, int scale_nano,\n\t\t\t\t\t\t  int *gain)\n{\n\tu64 scale_linear;\n\tint ret, mul;\n\n\tret = iio_gts_linearize(scale_int, scale_nano, NANO, &scale_linear);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iio_gts_get_int_time_gain_multiplier_by_sel(gts, time_sel);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmul = ret;\n\n\tret = gain_get_scale_fraction(gts->max_scale, scale_linear, mul, gain);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!iio_gts_valid_gain(gts, *gain))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint iio_gts_find_gain_sel_for_scale_using_time(struct iio_gts *gts, int time_sel,\n\t\t\t\t\t       int scale_int, int scale_nano,\n\t\t\t\t\t       int *gain_sel)\n{\n\tint gain, ret;\n\n\tret = iio_gts_find_gain_for_scale_using_time(gts, time_sel, scale_int,\n\t\t\t\t\t\t     scale_nano, &gain);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iio_gts_find_sel_by_gain(gts, gain);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*gain_sel = ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(iio_gts_find_gain_sel_for_scale_using_time, IIO_GTS_HELPER);\n\nstatic int iio_gts_get_total_gain(struct iio_gts *gts, int gain, int time)\n{\n\tconst struct iio_itime_sel_mul *itime;\n\n\tif (!iio_gts_valid_gain(gts, gain))\n\t\treturn -EINVAL;\n\n\tif (!gts->num_itime)\n\t\treturn gain;\n\n\titime = iio_gts_find_itime_by_time(gts, time);\n\tif (!itime)\n\t\treturn -EINVAL;\n\n\treturn gain * itime->mul;\n}\n\nstatic int iio_gts_get_scale_linear(struct iio_gts *gts, int gain, int time,\n\t\t\t\t    u64 *scale)\n{\n\tint total_gain;\n\tu64 tmp;\n\n\ttotal_gain = iio_gts_get_total_gain(gts, gain, time);\n\tif (total_gain < 0)\n\t\treturn total_gain;\n\n\ttmp = gts->max_scale;\n\n\tdo_div(tmp, total_gain);\n\n\t*scale = tmp;\n\n\treturn 0;\n}\n\n \nint iio_gts_get_scale(struct iio_gts *gts, int gain, int time, int *scale_int,\n\t\t      int *scale_nano)\n{\n\tu64 lin_scale;\n\tint ret;\n\n\tret = iio_gts_get_scale_linear(gts, gain, time, &lin_scale);\n\tif (ret)\n\t\treturn ret;\n\n\treturn iio_gts_delinearize(lin_scale, NANO, scale_int, scale_nano);\n}\nEXPORT_SYMBOL_NS_GPL(iio_gts_get_scale, IIO_GTS_HELPER);\n\n \nint iio_gts_find_new_gain_sel_by_old_gain_time(struct iio_gts *gts,\n\t\t\t\t\t       int old_gain, int old_time_sel,\n\t\t\t\t\t       int new_time_sel, int *new_gain)\n{\n\tconst struct iio_itime_sel_mul *itime_old, *itime_new;\n\tu64 scale;\n\tint ret;\n\n\t*new_gain = -1;\n\n\titime_old = iio_gts_find_itime_by_sel(gts, old_time_sel);\n\tif (!itime_old)\n\t\treturn -EINVAL;\n\n\titime_new = iio_gts_find_itime_by_sel(gts, new_time_sel);\n\tif (!itime_new)\n\t\treturn -EINVAL;\n\n\tret = iio_gts_get_scale_linear(gts, old_gain, itime_old->time_us,\n\t\t\t\t       &scale);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gain_get_scale_fraction(gts->max_scale, scale, itime_new->mul,\n\t\t\t\t      new_gain);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!iio_gts_valid_gain(gts, *new_gain))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(iio_gts_find_new_gain_sel_by_old_gain_time, IIO_GTS_HELPER);\n\n \nint iio_gts_find_new_gain_by_old_gain_time(struct iio_gts *gts, int old_gain,\n\t\t\t\t\t   int old_time, int new_time,\n\t\t\t\t\t   int *new_gain)\n{\n\tconst struct iio_itime_sel_mul *itime_new;\n\tu64 scale;\n\tint ret;\n\n\t*new_gain = -1;\n\n\titime_new = iio_gts_find_itime_by_time(gts, new_time);\n\tif (!itime_new)\n\t\treturn -EINVAL;\n\n\tret = iio_gts_get_scale_linear(gts, old_gain, old_time, &scale);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gain_get_scale_fraction(gts->max_scale, scale, itime_new->mul,\n\t\t\t\t      new_gain);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!iio_gts_valid_gain(gts, *new_gain))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(iio_gts_find_new_gain_by_old_gain_time, IIO_GTS_HELPER);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Matti Vaittinen <mazziesaccount@gmail.com>\");\nMODULE_DESCRIPTION(\"IIO light sensor gain-time-scale helpers\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}