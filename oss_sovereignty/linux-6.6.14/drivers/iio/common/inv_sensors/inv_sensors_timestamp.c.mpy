{
  "module_name": "inv_sensors_timestamp.c",
  "hash_id": "a4b953ec17bbe14c01780b7655bfe598725d0d0941b2031a4517051517c7a62d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/common/inv_sensors/inv_sensors_timestamp.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n\n#include <linux/iio/common/inv_sensors_timestamp.h>\n\n \n#define INV_SENSORS_TIMESTAMP_JITTER(_val, _jitter)\t\t\\\n\t(div_s64((_val) * (_jitter), 1000))\n#define INV_SENSORS_TIMESTAMP_MIN(_val, _jitter)\t\t\\\n\t(((_val) * (1000 - (_jitter))) / 1000)\n#define INV_SENSORS_TIMESTAMP_MAX(_val, _jitter)\t\t\\\n\t(((_val) * (1000 + (_jitter))) / 1000)\n\n \nstatic void inv_update_acc(struct inv_sensors_timestamp_acc *acc, uint32_t val)\n{\n\tuint64_t sum = 0;\n\tsize_t i;\n\n\tacc->values[acc->idx++] = val;\n\tif (acc->idx >= ARRAY_SIZE(acc->values))\n\t\tacc->idx = 0;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(acc->values); ++i) {\n\t\tif (acc->values[i] == 0)\n\t\t\tbreak;\n\t\tsum += acc->values[i];\n\t}\n\n\tacc->val = div_u64(sum, i);\n}\n\nvoid inv_sensors_timestamp_init(struct inv_sensors_timestamp *ts,\n\t\t\t\tconst struct inv_sensors_timestamp_chip *chip)\n{\n\tmemset(ts, 0, sizeof(*ts));\n\n\t \n\tts->chip = *chip;\n\tts->min_period = INV_SENSORS_TIMESTAMP_MIN(chip->clock_period, chip->jitter);\n\tts->max_period = INV_SENSORS_TIMESTAMP_MAX(chip->clock_period, chip->jitter);\n\n\t \n\tts->mult = chip->init_period / chip->clock_period;\n\tts->period = chip->init_period;\n\n\t \n\tinv_update_acc(&ts->chip_period, chip->clock_period);\n}\nEXPORT_SYMBOL_NS_GPL(inv_sensors_timestamp_init, IIO_INV_SENSORS_TIMESTAMP);\n\nint inv_sensors_timestamp_update_odr(struct inv_sensors_timestamp *ts,\n\t\t\t\t     uint32_t period, bool fifo)\n{\n\t \n\tif (fifo && ts->new_mult != 0)\n\t\treturn -EAGAIN;\n\n\tts->new_mult = period / ts->chip.clock_period;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(inv_sensors_timestamp_update_odr, IIO_INV_SENSORS_TIMESTAMP);\n\nstatic bool inv_validate_period(struct inv_sensors_timestamp *ts, uint32_t period, uint32_t mult)\n{\n\tuint32_t period_min, period_max;\n\n\t \n\tperiod_min = ts->min_period * mult;\n\tperiod_max = ts->max_period * mult;\n\tif (period > period_min && period < period_max)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool inv_update_chip_period(struct inv_sensors_timestamp *ts,\n\t\t\t\t    uint32_t mult, uint32_t period)\n{\n\tuint32_t new_chip_period;\n\n\tif (!inv_validate_period(ts, period, mult))\n\t\treturn false;\n\n\t \n\tnew_chip_period = period / mult;\n\tinv_update_acc(&ts->chip_period, new_chip_period);\n\tts->period = ts->mult * ts->chip_period.val;\n\n\treturn true;\n}\n\nstatic void inv_align_timestamp_it(struct inv_sensors_timestamp *ts)\n{\n\tint64_t delta, jitter;\n\tint64_t adjust;\n\n\t \n\tdelta = ts->it.lo - ts->timestamp;\n\n\t \n\tjitter = INV_SENSORS_TIMESTAMP_JITTER((int64_t)ts->period, ts->chip.jitter);\n\tif (delta > jitter)\n\t\tadjust = jitter;\n\telse if (delta < -jitter)\n\t\tadjust = -jitter;\n\telse\n\t\tadjust = 0;\n\n\tts->timestamp += adjust;\n}\n\nvoid inv_sensors_timestamp_interrupt(struct inv_sensors_timestamp *ts,\n\t\t\t\t      uint32_t fifo_period, size_t fifo_nb,\n\t\t\t\t      size_t sensor_nb, int64_t timestamp)\n{\n\tstruct inv_sensors_timestamp_interval *it;\n\tint64_t delta, interval;\n\tconst uint32_t fifo_mult = fifo_period / ts->chip.clock_period;\n\tuint32_t period = ts->period;\n\tbool valid = false;\n\n\tif (fifo_nb == 0)\n\t\treturn;\n\n\t \n\tit = &ts->it;\n\tit->lo = it->up;\n\tit->up = timestamp;\n\tdelta = it->up - it->lo;\n\tif (it->lo != 0) {\n\t\t \n\t\tperiod = div_s64(delta, fifo_nb);\n\t\tvalid = inv_update_chip_period(ts, fifo_mult, period);\n\t}\n\n\t \n\tif (ts->timestamp == 0) {\n\t\t \n\t\tinterval = (int64_t)ts->period * (int64_t)sensor_nb;\n\t\tts->timestamp = it->up - interval;\n\t\treturn;\n\t}\n\n\t \n\tif (valid)\n\t\tinv_align_timestamp_it(ts);\n}\nEXPORT_SYMBOL_NS_GPL(inv_sensors_timestamp_interrupt, IIO_INV_SENSORS_TIMESTAMP);\n\nvoid inv_sensors_timestamp_apply_odr(struct inv_sensors_timestamp *ts,\n\t\t\t\t     uint32_t fifo_period, size_t fifo_nb,\n\t\t\t\t     unsigned int fifo_no)\n{\n\tint64_t interval;\n\tuint32_t fifo_mult;\n\n\tif (ts->new_mult == 0)\n\t\treturn;\n\n\t \n\tts->mult = ts->new_mult;\n\tts->new_mult = 0;\n\tts->period = ts->mult * ts->chip_period.val;\n\n\t \n\tif (ts->timestamp != 0) {\n\t\t \n\t\tfifo_mult = fifo_period / ts->chip.clock_period;\n\t\tfifo_period = fifo_mult * ts->chip_period.val;\n\t\t \n\t\tinterval = (int64_t)(fifo_nb - fifo_no) * (int64_t)fifo_period;\n\t\tts->timestamp = ts->it.up - interval;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(inv_sensors_timestamp_apply_odr, IIO_INV_SENSORS_TIMESTAMP);\n\nMODULE_AUTHOR(\"InvenSense, Inc.\");\nMODULE_DESCRIPTION(\"InvenSense sensors timestamp module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}