{
  "module_name": "ms_sensors_i2c.c",
  "hash_id": "d53aa22215787aa92198e5306b4b5147fdcd2d5840bbb6218b28220bb9feacd5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/common/ms_sensors/ms_sensors_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/iio/iio.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n\n#include \"ms_sensors_i2c.h\"\n\n \nstatic const u16 ms_sensors_ht_t_conversion_time[] = { 50000, 25000,\n\t\t\t\t\t\t       13000, 7000 };\nstatic const u16 ms_sensors_ht_h_conversion_time[] = { 16000, 5000,\n\t\t\t\t\t\t       3000, 8000 };\nstatic const u16 ms_sensors_tp_conversion_time[] = { 500, 1100, 2100,\n\t\t\t\t\t\t     4100, 8220, 16440 };\n\n#define MS_SENSORS_SERIAL_READ_MSB\t\t0xFA0F\n#define MS_SENSORS_SERIAL_READ_LSB\t\t0xFCC9\n#define MS_SENSORS_CONFIG_REG_WRITE\t\t0xE6\n#define MS_SENSORS_CONFIG_REG_READ\t\t0xE7\n#define MS_SENSORS_HT_T_CONVERSION_START\t0xF3\n#define MS_SENSORS_HT_H_CONVERSION_START\t0xF5\n\n#define MS_SENSORS_TP_PROM_READ\t\t\t0xA0\n#define MS_SENSORS_TP_T_CONVERSION_START\t0x50\n#define MS_SENSORS_TP_P_CONVERSION_START\t0x40\n#define MS_SENSORS_TP_ADC_READ\t\t\t0x00\n\n#define MS_SENSORS_NO_READ_CMD\t\t\t0xFF\n\n \nint ms_sensors_reset(void *cli, u8 cmd, unsigned int delay)\n{\n\tint ret;\n\tstruct i2c_client *client = cli;\n\n\tret = i2c_smbus_write_byte(client, cmd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to reset device\\n\");\n\t\treturn ret;\n\t}\n\tusleep_range(delay, delay + 1000);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(ms_sensors_reset, IIO_MEAS_SPEC_SENSORS);\n\n \nint ms_sensors_read_prom_word(void *cli, int cmd, u16 *word)\n{\n\tint ret;\n\tstruct i2c_client *client = cli;\n\n\tret = i2c_smbus_read_word_swapped(client, cmd);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to read prom word\\n\");\n\t\treturn ret;\n\t}\n\t*word = ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(ms_sensors_read_prom_word, IIO_MEAS_SPEC_SENSORS);\n\n \nint ms_sensors_convert_and_read(void *cli, u8 conv, u8 rd,\n\t\t\t\tunsigned int delay, u32 *adc)\n{\n\tint ret;\n\t__be32 buf = 0;\n\tstruct i2c_client *client = cli;\n\n\t \n\tret = i2c_smbus_write_byte(client, conv);\n\tif (ret)\n\t\tgoto err;\n\tusleep_range(delay, delay + 1000);\n\n\t \n\tif (rd != MS_SENSORS_NO_READ_CMD)\n\t\tret = i2c_smbus_read_i2c_block_data(client, rd, 3, (u8 *)&buf);\n\telse\n\t\tret = i2c_master_recv(client, (u8 *)&buf, 3);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdev_dbg(&client->dev, \"ADC raw value : %x\\n\", be32_to_cpu(buf) >> 8);\n\t*adc = be32_to_cpu(buf) >> 8;\n\n\treturn 0;\nerr:\n\tdev_err(&client->dev, \"Unable to make sensor adc conversion\\n\");\n\treturn ret;\n}\nEXPORT_SYMBOL_NS(ms_sensors_convert_and_read, IIO_MEAS_SPEC_SENSORS);\n\n \nstatic bool ms_sensors_crc_valid(u32 value)\n{\n\tu32 polynom = 0x988000;\t \n\tu32 msb = 0x800000;\n\tu32 mask = 0xFF8000;\n\tu32 result = value & 0xFFFF00;\n\tu8 crc = value & 0xFF;\n\n\twhile (msb != 0x80) {\n\t\tif (result & msb)\n\t\t\tresult = ((result ^ polynom) & mask)\n\t\t\t\t| (result & ~mask);\n\t\tmsb >>= 1;\n\t\tmask >>= 1;\n\t\tpolynom >>= 1;\n\t}\n\n\treturn result == crc;\n}\n\n \nint ms_sensors_read_serial(struct i2c_client *client, u64 *sn)\n{\n\tu8 i;\n\t__be64 rcv_buf = 0;\n\tu64 rcv_val;\n\t__be16 send_buf;\n\tint ret;\n\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t .addr = client->addr,\n\t\t .flags = client->flags,\n\t\t .len = 2,\n\t\t .buf = (__u8 *)&send_buf,\n\t\t },\n\t\t{\n\t\t .addr = client->addr,\n\t\t .flags = client->flags | I2C_M_RD,\n\t\t .buf = (__u8 *)&rcv_buf,\n\t\t },\n\t};\n\n\t \n\tsend_buf = cpu_to_be16(MS_SENSORS_SERIAL_READ_MSB);\n\tmsg[1].len = 8;\n\tret = i2c_transfer(client->adapter, msg, 2);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Unable to read device serial number\");\n\t\treturn ret;\n\t}\n\n\trcv_val = be64_to_cpu(rcv_buf);\n\tdev_dbg(&client->dev, \"Serial MSB raw : %llx\\n\", rcv_val);\n\n\tfor (i = 0; i < 64; i += 16) {\n\t\tif (!ms_sensors_crc_valid((rcv_val >> i) & 0xFFFF))\n\t\t\treturn -ENODEV;\n\t}\n\n\t*sn = (((rcv_val >> 32) & 0xFF000000) |\n\t       ((rcv_val >> 24) & 0x00FF0000) |\n\t       ((rcv_val >> 16) & 0x0000FF00) |\n\t       ((rcv_val >> 8) & 0x000000FF)) << 16;\n\n\t \n\tsend_buf = cpu_to_be16(MS_SENSORS_SERIAL_READ_LSB);\n\tmsg[1].len = 6;\n\trcv_buf = 0;\n\tret = i2c_transfer(client->adapter, msg, 2);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Unable to read device serial number\");\n\t\treturn ret;\n\t}\n\n\trcv_val = be64_to_cpu(rcv_buf) >> 16;\n\tdev_dbg(&client->dev, \"Serial MSB raw : %llx\\n\", rcv_val);\n\n\tfor (i = 0; i < 48; i += 24) {\n\t\tif (!ms_sensors_crc_valid((rcv_val >> i) & 0xFFFFFF))\n\t\t\treturn -ENODEV;\n\t}\n\n\t*sn |= (rcv_val & 0xFFFF00) << 40 | (rcv_val >> 32);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(ms_sensors_read_serial, IIO_MEAS_SPEC_SENSORS);\n\nstatic int ms_sensors_read_config_reg(struct i2c_client *client,\n\t\t\t\t      u8 *config_reg)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte(client, MS_SENSORS_CONFIG_REG_READ);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Unable to read config register\");\n\t\treturn ret;\n\t}\n\n\tret = i2c_master_recv(client, config_reg, 1);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Unable to read config register\");\n\t\treturn ret;\n\t}\n\tdev_dbg(&client->dev, \"Config register :%x\\n\", *config_reg);\n\n\treturn 0;\n}\n\n \nssize_t ms_sensors_write_resolution(struct ms_ht_dev *dev_data,\n\t\t\t\t    u8 i)\n{\n\tu8 config_reg;\n\tint ret;\n\n\tret = ms_sensors_read_config_reg(dev_data->client, &config_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tconfig_reg &= 0x7E;\n\tconfig_reg |= ((i & 1) << 7) + ((i & 2) >> 1);\n\n\treturn i2c_smbus_write_byte_data(dev_data->client,\n\t\t\t\t\t MS_SENSORS_CONFIG_REG_WRITE,\n\t\t\t\t\t config_reg);\n}\nEXPORT_SYMBOL_NS(ms_sensors_write_resolution, IIO_MEAS_SPEC_SENSORS);\n\n \nssize_t ms_sensors_show_battery_low(struct ms_ht_dev *dev_data,\n\t\t\t\t    char *buf)\n{\n\tint ret;\n\tu8 config_reg;\n\n\tmutex_lock(&dev_data->lock);\n\tret = ms_sensors_read_config_reg(dev_data->client, &config_reg);\n\tmutex_unlock(&dev_data->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", (config_reg & 0x40) >> 6);\n}\nEXPORT_SYMBOL_NS(ms_sensors_show_battery_low, IIO_MEAS_SPEC_SENSORS);\n\n \nssize_t ms_sensors_show_heater(struct ms_ht_dev *dev_data,\n\t\t\t       char *buf)\n{\n\tu8 config_reg;\n\tint ret;\n\n\tmutex_lock(&dev_data->lock);\n\tret = ms_sensors_read_config_reg(dev_data->client, &config_reg);\n\tmutex_unlock(&dev_data->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", (config_reg & 0x4) >> 2);\n}\nEXPORT_SYMBOL_NS(ms_sensors_show_heater, IIO_MEAS_SPEC_SENSORS);\n\n \nssize_t ms_sensors_write_heater(struct ms_ht_dev *dev_data,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tu8 val, config_reg;\n\tint ret;\n\n\tret = kstrtou8(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev_data->lock);\n\tret = ms_sensors_read_config_reg(dev_data->client, &config_reg);\n\tif (ret) {\n\t\tmutex_unlock(&dev_data->lock);\n\t\treturn ret;\n\t}\n\n\tconfig_reg &= 0xFB;\n\tconfig_reg |= val << 2;\n\n\tret = i2c_smbus_write_byte_data(dev_data->client,\n\t\t\t\t\tMS_SENSORS_CONFIG_REG_WRITE,\n\t\t\t\t\tconfig_reg);\n\tmutex_unlock(&dev_data->lock);\n\tif (ret) {\n\t\tdev_err(&dev_data->client->dev, \"Unable to write config register\\n\");\n\t\treturn ret;\n\t}\n\n\treturn len;\n}\nEXPORT_SYMBOL_NS(ms_sensors_write_heater, IIO_MEAS_SPEC_SENSORS);\n\n \nint ms_sensors_ht_read_temperature(struct ms_ht_dev *dev_data,\n\t\t\t\t   s32 *temperature)\n{\n\tint ret;\n\tu32 adc;\n\tu16 delay;\n\n\tmutex_lock(&dev_data->lock);\n\tdelay = ms_sensors_ht_t_conversion_time[dev_data->res_index];\n\tret = ms_sensors_convert_and_read(dev_data->client,\n\t\t\t\t\t  MS_SENSORS_HT_T_CONVERSION_START,\n\t\t\t\t\t  MS_SENSORS_NO_READ_CMD,\n\t\t\t\t\t  delay, &adc);\n\tmutex_unlock(&dev_data->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ms_sensors_crc_valid(adc)) {\n\t\tdev_err(&dev_data->client->dev,\n\t\t\t\"Temperature read crc check error\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\t*temperature = (((s64)(adc >> 8) * 175720) >> 16) - 46850;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(ms_sensors_ht_read_temperature, IIO_MEAS_SPEC_SENSORS);\n\n \nint ms_sensors_ht_read_humidity(struct ms_ht_dev *dev_data,\n\t\t\t\tu32 *humidity)\n{\n\tint ret;\n\tu32 adc;\n\tu16 delay;\n\n\tmutex_lock(&dev_data->lock);\n\tdelay = ms_sensors_ht_h_conversion_time[dev_data->res_index];\n\tret = ms_sensors_convert_and_read(dev_data->client,\n\t\t\t\t\t  MS_SENSORS_HT_H_CONVERSION_START,\n\t\t\t\t\t  MS_SENSORS_NO_READ_CMD,\n\t\t\t\t\t  delay, &adc);\n\tmutex_unlock(&dev_data->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ms_sensors_crc_valid(adc)) {\n\t\tdev_err(&dev_data->client->dev,\n\t\t\t\"Humidity read crc check error\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\t*humidity = (((s32)(adc >> 8) * 12500) >> 16) * 10 - 6000;\n\tif (*humidity >= 100000)\n\t\t*humidity = 100000;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(ms_sensors_ht_read_humidity, IIO_MEAS_SPEC_SENSORS);\n\n \nstatic u8 ms_sensors_tp_crc4(u16 *prom)\n{\n\tunsigned int cnt, n_bit;\n\tu16 n_rem = 0x0000;\n\n\tfor (cnt = 0; cnt < MS_SENSORS_TP_PROM_WORDS_NB * 2; cnt++) {\n\t\tif (cnt % 2 == 1)\n\t\t\tn_rem ^= prom[cnt >> 1] & 0x00FF;\n\t\telse\n\t\t\tn_rem ^= prom[cnt >> 1] >> 8;\n\n\t\tfor (n_bit = 8; n_bit > 0; n_bit--) {\n\t\t\tif (n_rem & 0x8000)\n\t\t\t\tn_rem = (n_rem << 1) ^ 0x3000;\n\t\t\telse\n\t\t\t\tn_rem <<= 1;\n\t\t}\n\t}\n\n\treturn n_rem >> 12;\n}\n\n \nstatic bool ms_sensors_tp_crc_valid_112(u16 *prom)\n{\n\tu16 w0 = prom[0], crc_read = (w0 & 0xF000) >> 12;\n\tu8 crc;\n\n\tprom[0] &= 0x0FFF;       \n\tprom[MS_SENSORS_TP_PROM_WORDS_NB - 1] = 0;\n\n\tcrc = ms_sensors_tp_crc4(prom);\n\n\tprom[0] = w0;\n\n\treturn crc == crc_read;\n}\n\n \nstatic bool ms_sensors_tp_crc_valid_128(u16 *prom)\n{\n\tu16 w7 = prom[7], crc_read = w7 & 0x000F;\n\tu8 crc;\n\n\tprom[7] &= 0xFF00;       \n\n\tcrc = ms_sensors_tp_crc4(prom);\n\n\tprom[7] = w7;\n\n\treturn crc == crc_read;\n}\n\n \nint ms_sensors_tp_read_prom(struct ms_tp_dev *dev_data)\n{\n\tint i, ret;\n\tbool valid;\n\n\tfor (i = 0; i < dev_data->hw->prom_len; i++) {\n\t\tret = ms_sensors_read_prom_word(\n\t\t\tdev_data->client,\n\t\t\tMS_SENSORS_TP_PROM_READ + (i << 1),\n\t\t\t&dev_data->prom[i]);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dev_data->hw->prom_len == 8)\n\t\tvalid = ms_sensors_tp_crc_valid_128(dev_data->prom);\n\telse\n\t\tvalid = ms_sensors_tp_crc_valid_112(dev_data->prom);\n\n\tif (!valid) {\n\t\tdev_err(&dev_data->client->dev,\n\t\t\t\"Calibration coefficients crc check error\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(ms_sensors_tp_read_prom, IIO_MEAS_SPEC_SENSORS);\n\n \nint ms_sensors_read_temp_and_pressure(struct ms_tp_dev *dev_data,\n\t\t\t\t      int *temperature,\n\t\t\t\t      unsigned int *pressure)\n{\n\tint ret;\n\tu32 t_adc, p_adc;\n\ts32 dt, temp;\n\ts64 off, sens, t2, off2, sens2;\n\tu16 *prom = dev_data->prom, delay;\n\n\tmutex_lock(&dev_data->lock);\n\tdelay = ms_sensors_tp_conversion_time[dev_data->res_index];\n\n\tret = ms_sensors_convert_and_read(\n\t\t\t\t\tdev_data->client,\n\t\t\t\t\tMS_SENSORS_TP_T_CONVERSION_START +\n\t\t\t\t\t\tdev_data->res_index * 2,\n\t\t\t\t\tMS_SENSORS_TP_ADC_READ,\n\t\t\t\t\tdelay, &t_adc);\n\tif (ret) {\n\t\tmutex_unlock(&dev_data->lock);\n\t\treturn ret;\n\t}\n\n\tret = ms_sensors_convert_and_read(\n\t\t\t\t\tdev_data->client,\n\t\t\t\t\tMS_SENSORS_TP_P_CONVERSION_START +\n\t\t\t\t\t\tdev_data->res_index * 2,\n\t\t\t\t\tMS_SENSORS_TP_ADC_READ,\n\t\t\t\t\tdelay, &p_adc);\n\tmutex_unlock(&dev_data->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tdt = (s32)t_adc - (prom[5] << 8);\n\n\t \n\ttemp = 2000 + (((s64)dt * prom[6]) >> 23);\n\n\t \n\tif (temp < 2000) {\n\t\ts64 tmp = (s64)temp - 2000;\n\n\t\tt2 = (3 * ((s64)dt * (s64)dt)) >> 33;\n\t\toff2 = (61 * tmp * tmp) >> 4;\n\t\tsens2 = (29 * tmp * tmp) >> 4;\n\n\t\tif (temp < -1500) {\n\t\t\ts64 tmp = (s64)temp + 1500;\n\n\t\t\toff2 += 17 * tmp * tmp;\n\t\t\tsens2 += 9 * tmp * tmp;\n\t\t}\n\t} else {\n\t\tt2 = (5 * ((s64)dt * (s64)dt)) >> 38;\n\t\toff2 = 0;\n\t\tsens2 = 0;\n\t}\n\n\t \n\toff = (((s64)prom[2]) << 17) + ((((s64)prom[4]) * (s64)dt) >> 6);\n\toff -= off2;\n\n\t \n\tsens = (((s64)prom[1]) << 16) + (((s64)prom[3] * dt) >> 7);\n\tsens -= sens2;\n\n\t \n\t*temperature = (temp - t2) * 10;\n\t*pressure = (u32)(((((s64)p_adc * sens) >> 21) - off) >> 15);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(ms_sensors_read_temp_and_pressure, IIO_MEAS_SPEC_SENSORS);\n\nMODULE_DESCRIPTION(\"Measurement-Specialties common i2c driver\");\nMODULE_AUTHOR(\"William Markezana <william.markezana@meas-spec.com>\");\nMODULE_AUTHOR(\"Ludovic Tancerel <ludovic.tancerel@maplehightech.com>\");\nMODULE_LICENSE(\"GPL v2\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}