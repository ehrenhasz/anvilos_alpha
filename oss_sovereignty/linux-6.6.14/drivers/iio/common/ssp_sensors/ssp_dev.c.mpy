{
  "module_name": "ssp_dev.c",
  "hash_id": "891e6ff3da36d1b5fdf1acb840b0714464a22da4862818572e373b61fb227e18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/common/ssp_sensors/ssp_dev.c",
  "human_readable_source": "\n \n\n#include <linux/iio/iio.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mfd/core.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n\n#include \"ssp.h\"\n\n#define SSP_WDT_TIME\t\t\t10000\n#define SSP_LIMIT_RESET_CNT\t\t20\n#define SSP_LIMIT_TIMEOUT_CNT\t\t3\n\n \n#define SSP_BOOT_SPI_HZ\t400000\n\n \nstruct ssp_instruction {\n\t__le32 a;\n\t__le32 b;\n\tu8 c;\n} __attribute__((__packed__));\n\nstatic const u8 ssp_magnitude_table[] = {110, 85, 171, 71, 203, 195, 0, 67,\n\t208, 56, 175, 244, 206, 213, 0, 92, 250, 0, 55, 48, 189, 252, 171,\n\t243, 13, 45, 250};\n\nstatic const struct ssp_sensorhub_info ssp_rinato_info = {\n\t.fw_name = \"ssp_B2.fw\",\n\t.fw_crashed_name = \"ssp_crashed.fw\",\n\t.fw_rev = 14052300,\n\t.mag_table = ssp_magnitude_table,\n\t.mag_length = ARRAY_SIZE(ssp_magnitude_table),\n};\n\nstatic const struct ssp_sensorhub_info ssp_thermostat_info = {\n\t.fw_name = \"thermostat_B2.fw\",\n\t.fw_crashed_name = \"ssp_crashed.fw\",\n\t.fw_rev = 14080600,\n\t.mag_table = ssp_magnitude_table,\n\t.mag_length = ARRAY_SIZE(ssp_magnitude_table),\n};\n\nstatic const struct mfd_cell sensorhub_sensor_devs[] = {\n\t{\n\t\t.name = \"ssp-accelerometer\",\n\t},\n\t{\n\t\t.name = \"ssp-gyroscope\",\n\t},\n};\n\nstatic void ssp_toggle_mcu_reset_gpio(struct ssp_data *data)\n{\n\tgpiod_set_value(data->mcu_reset_gpiod, 0);\n\tusleep_range(1000, 1200);\n\tgpiod_set_value(data->mcu_reset_gpiod, 1);\n\tmsleep(50);\n}\n\nstatic void ssp_sync_available_sensors(struct ssp_data *data)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < SSP_SENSOR_MAX; ++i) {\n\t\tif (data->available_sensors & BIT(i)) {\n\t\t\tret = ssp_enable_sensor(data, i, data->delay_buf[i]);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&data->spi->dev,\n\t\t\t\t\t\"Sync sensor nr: %d fail\\n\", i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = ssp_command(data, SSP_MSG2SSP_AP_MCU_SET_DUMPMODE,\n\t\t\t  data->mcu_dump_mode);\n\tif (ret < 0)\n\t\tdev_err(&data->spi->dev,\n\t\t\t\"SSP_MSG2SSP_AP_MCU_SET_DUMPMODE failed\\n\");\n}\n\nstatic void ssp_enable_mcu(struct ssp_data *data, bool enable)\n{\n\tdev_info(&data->spi->dev, \"current shutdown = %d, old = %d\\n\", enable,\n\t\t data->shut_down);\n\n\tif (enable && data->shut_down) {\n\t\tdata->shut_down = false;\n\t\tenable_irq(data->spi->irq);\n\t\tenable_irq_wake(data->spi->irq);\n\t} else if (!enable && !data->shut_down) {\n\t\tdata->shut_down = true;\n\t\tdisable_irq(data->spi->irq);\n\t\tdisable_irq_wake(data->spi->irq);\n\t} else {\n\t\tdev_warn(&data->spi->dev, \"current shutdown = %d, old = %d\\n\",\n\t\t\t enable, data->shut_down);\n\t}\n}\n\n \nstatic int ssp_check_fwbl(struct ssp_data *data)\n{\n\tint retries = 0;\n\n\twhile (retries++ < 5) {\n\t\tdata->cur_firm_rev = ssp_get_firmware_rev(data);\n\t\tif (data->cur_firm_rev == SSP_INVALID_REVISION ||\n\t\t    data->cur_firm_rev == SSP_INVALID_REVISION2) {\n\t\t\tdev_warn(&data->spi->dev,\n\t\t\t\t \"Invalid revision, trying %d time\\n\", retries);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (data->cur_firm_rev == SSP_INVALID_REVISION ||\n\t    data->cur_firm_rev == SSP_INVALID_REVISION2) {\n\t\tdev_err(&data->spi->dev, \"SSP_INVALID_REVISION\\n\");\n\t\treturn SSP_FW_DL_STATE_NEED_TO_SCHEDULE;\n\t}\n\n\tdev_info(&data->spi->dev,\n\t\t \"MCU Firm Rev : Old = %8u, New = %8u\\n\",\n\t\t data->cur_firm_rev,\n\t\t data->sensorhub_info->fw_rev);\n\n\tif (data->cur_firm_rev != data->sensorhub_info->fw_rev)\n\t\treturn SSP_FW_DL_STATE_NEED_TO_SCHEDULE;\n\n\treturn SSP_FW_DL_STATE_NONE;\n}\n\nstatic void ssp_reset_mcu(struct ssp_data *data)\n{\n\tssp_enable_mcu(data, false);\n\tssp_clean_pending_list(data);\n\tssp_toggle_mcu_reset_gpio(data);\n\tssp_enable_mcu(data, true);\n}\n\nstatic void ssp_wdt_work_func(struct work_struct *work)\n{\n\tstruct ssp_data *data = container_of(work, struct ssp_data, work_wdt);\n\n\tdev_err(&data->spi->dev, \"%s - Sensor state: 0x%x, RC: %u, CC: %u\\n\",\n\t\t__func__, data->available_sensors, data->reset_cnt,\n\t\tdata->com_fail_cnt);\n\n\tssp_reset_mcu(data);\n\tdata->com_fail_cnt = 0;\n\tdata->timeout_cnt = 0;\n}\n\nstatic void ssp_wdt_timer_func(struct timer_list *t)\n{\n\tstruct ssp_data *data = from_timer(data, t, wdt_timer);\n\n\tswitch (data->fw_dl_state) {\n\tcase SSP_FW_DL_STATE_FAIL:\n\tcase SSP_FW_DL_STATE_DOWNLOADING:\n\tcase SSP_FW_DL_STATE_SYNC:\n\t\tgoto _mod;\n\t}\n\n\tif (data->timeout_cnt > SSP_LIMIT_TIMEOUT_CNT ||\n\t    data->com_fail_cnt > SSP_LIMIT_RESET_CNT)\n\t\tqueue_work(system_power_efficient_wq, &data->work_wdt);\n_mod:\n\tmod_timer(&data->wdt_timer, jiffies + msecs_to_jiffies(SSP_WDT_TIME));\n}\n\nstatic void ssp_enable_wdt_timer(struct ssp_data *data)\n{\n\tmod_timer(&data->wdt_timer, jiffies + msecs_to_jiffies(SSP_WDT_TIME));\n}\n\nstatic void ssp_disable_wdt_timer(struct ssp_data *data)\n{\n\tdel_timer_sync(&data->wdt_timer);\n\tcancel_work_sync(&data->work_wdt);\n}\n\n \nu32 ssp_get_sensor_delay(struct ssp_data *data, enum ssp_sensor_type type)\n{\n\treturn data->delay_buf[type];\n}\nEXPORT_SYMBOL_NS(ssp_get_sensor_delay, IIO_SSP_SENSORS);\n\n \nint ssp_enable_sensor(struct ssp_data *data, enum ssp_sensor_type type,\n\t\t      u32 delay)\n{\n\tint ret;\n\tstruct ssp_instruction to_send;\n\n\tto_send.a = cpu_to_le32(delay);\n\tto_send.b = cpu_to_le32(data->batch_latency_buf[type]);\n\tto_send.c = data->batch_opt_buf[type];\n\n\tswitch (data->check_status[type]) {\n\tcase SSP_INITIALIZATION_STATE:\n\t\t \n\tcase SSP_ADD_SENSOR_STATE:\n\t\tret = ssp_send_instruction(data,\n\t\t\t\t\t   SSP_MSG2SSP_INST_BYPASS_SENSOR_ADD,\n\t\t\t\t\t   type,\n\t\t\t\t\t   (u8 *)&to_send, sizeof(to_send));\n\t\tif (ret < 0) {\n\t\t\tdev_err(&data->spi->dev, \"Enabling sensor failed\\n\");\n\t\t\tdata->check_status[type] = SSP_NO_SENSOR_STATE;\n\t\t\tgoto derror;\n\t\t}\n\n\t\tdata->sensor_enable |= BIT(type);\n\t\tdata->check_status[type] = SSP_RUNNING_SENSOR_STATE;\n\t\tbreak;\n\tcase SSP_RUNNING_SENSOR_STATE:\n\t\tret = ssp_send_instruction(data,\n\t\t\t\t\t   SSP_MSG2SSP_INST_CHANGE_DELAY, type,\n\t\t\t\t\t   (u8 *)&to_send, sizeof(to_send));\n\t\tif (ret < 0) {\n\t\t\tdev_err(&data->spi->dev,\n\t\t\t\t\"Changing sensor delay failed\\n\");\n\t\t\tgoto derror;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdata->check_status[type] = SSP_ADD_SENSOR_STATE;\n\t\tbreak;\n\t}\n\n\tdata->delay_buf[type] = delay;\n\n\tif (atomic_inc_return(&data->enable_refcount) == 1)\n\t\tssp_enable_wdt_timer(data);\n\n\treturn 0;\n\nderror:\n\treturn ret;\n}\nEXPORT_SYMBOL_NS(ssp_enable_sensor, IIO_SSP_SENSORS);\n\n \nint ssp_change_delay(struct ssp_data *data, enum ssp_sensor_type type,\n\t\t     u32 delay)\n{\n\tint ret;\n\tstruct ssp_instruction to_send;\n\n\tto_send.a = cpu_to_le32(delay);\n\tto_send.b = cpu_to_le32(data->batch_latency_buf[type]);\n\tto_send.c = data->batch_opt_buf[type];\n\n\tret = ssp_send_instruction(data, SSP_MSG2SSP_INST_CHANGE_DELAY, type,\n\t\t\t\t   (u8 *)&to_send, sizeof(to_send));\n\tif (ret < 0) {\n\t\tdev_err(&data->spi->dev, \"Changing sensor delay failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->delay_buf[type] = delay;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(ssp_change_delay, IIO_SSP_SENSORS);\n\n \nint ssp_disable_sensor(struct ssp_data *data, enum ssp_sensor_type type)\n{\n\tint ret;\n\t__le32 command;\n\n\tif (data->sensor_enable & BIT(type)) {\n\t\tcommand = cpu_to_le32(data->delay_buf[type]);\n\n\t\tret = ssp_send_instruction(data,\n\t\t\t\t\t   SSP_MSG2SSP_INST_BYPASS_SENSOR_RM,\n\t\t\t\t\t   type, (u8 *)&command,\n\t\t\t\t\t   sizeof(command));\n\t\tif (ret < 0) {\n\t\t\tdev_err(&data->spi->dev, \"Remove sensor fail\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->sensor_enable &= ~BIT(type);\n\t}\n\n\tdata->check_status[type] = SSP_ADD_SENSOR_STATE;\n\n\tif (atomic_dec_and_test(&data->enable_refcount))\n\t\tssp_disable_wdt_timer(data);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(ssp_disable_sensor, IIO_SSP_SENSORS);\n\nstatic irqreturn_t ssp_irq_thread_fn(int irq, void *dev_id)\n{\n\tstruct ssp_data *data = dev_id;\n\n\t \n\tssp_irq_msg(data);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ssp_initialize_mcu(struct ssp_data *data)\n{\n\tint ret;\n\n\tssp_clean_pending_list(data);\n\n\tret = ssp_get_chipid(data);\n\tif (ret != SSP_DEVICE_ID) {\n\t\tdev_err(&data->spi->dev, \"%s - MCU %s ret = %d\\n\", __func__,\n\t\t\tret < 0 ? \"is not working\" : \"identification failed\",\n\t\t\tret);\n\t\treturn ret < 0 ? ret : -ENODEV;\n\t}\n\n\tdev_info(&data->spi->dev, \"MCU device ID = %d\\n\", ret);\n\n\t \n\tret = ssp_set_magnetic_matrix(data);\n\tif (ret < 0) {\n\t\tdev_err(&data->spi->dev,\n\t\t\t\"%s - ssp_set_magnetic_matrix failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tdata->available_sensors = ssp_get_sensor_scanning_info(data);\n\tif (data->available_sensors == 0) {\n\t\tdev_err(&data->spi->dev,\n\t\t\t\"%s - ssp_get_sensor_scanning_info failed\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tdata->cur_firm_rev = ssp_get_firmware_rev(data);\n\tdev_info(&data->spi->dev, \"MCU Firm Rev : New = %8u\\n\",\n\t\t data->cur_firm_rev);\n\n\treturn ssp_command(data, SSP_MSG2SSP_AP_MCU_DUMP_CHECK, 0);\n}\n\n \nstatic void ssp_refresh_task(struct work_struct *work)\n{\n\tstruct ssp_data *data = container_of((struct delayed_work *)work,\n\t\t\t\t\t     struct ssp_data, work_refresh);\n\n\tdev_info(&data->spi->dev, \"refreshing\\n\");\n\n\tdata->reset_cnt++;\n\n\tif (ssp_initialize_mcu(data) >= 0) {\n\t\tssp_sync_available_sensors(data);\n\t\tif (data->last_ap_state != 0)\n\t\t\tssp_command(data, data->last_ap_state, 0);\n\n\t\tif (data->last_resume_state != 0)\n\t\t\tssp_command(data, data->last_resume_state, 0);\n\n\t\tdata->timeout_cnt = 0;\n\t\tdata->com_fail_cnt = 0;\n\t}\n}\n\nint ssp_queue_ssp_refresh_task(struct ssp_data *data, unsigned int delay)\n{\n\tcancel_delayed_work_sync(&data->work_refresh);\n\n\treturn queue_delayed_work(system_power_efficient_wq,\n\t\t\t\t  &data->work_refresh,\n\t\t\t\t  msecs_to_jiffies(delay));\n}\n\nstatic const struct of_device_id ssp_of_match[] = {\n\t{\n\t\t.compatible\t= \"samsung,sensorhub-rinato\",\n\t\t.data\t\t= &ssp_rinato_info,\n\t}, {\n\t\t.compatible\t= \"samsung,sensorhub-thermostat\",\n\t\t.data\t\t= &ssp_thermostat_info,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ssp_of_match);\n\nstatic struct ssp_data *ssp_parse_dt(struct device *dev)\n{\n\tstruct ssp_data *data;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn NULL;\n\n\tdata->mcu_ap_gpiod = devm_gpiod_get(dev, \"mcu-ap\", GPIOD_IN);\n\tif (IS_ERR(data->mcu_ap_gpiod))\n\t\treturn NULL;\n\n\tdata->ap_mcu_gpiod = devm_gpiod_get(dev, \"ap-mcu\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(data->ap_mcu_gpiod))\n\t\treturn NULL;\n\n\tdata->mcu_reset_gpiod = devm_gpiod_get(dev, \"mcu-reset\",\n\t\t\t\t\t       GPIOD_OUT_HIGH);\n\tif (IS_ERR(data->mcu_reset_gpiod))\n\t\treturn NULL;\n\n\tdata->sensorhub_info = device_get_match_data(dev);\n\n\tdev_set_drvdata(dev, data);\n\n\treturn data;\n}\n\n \nvoid ssp_register_consumer(struct iio_dev *indio_dev, enum ssp_sensor_type type)\n{\n\tstruct ssp_data *data = dev_get_drvdata(indio_dev->dev.parent->parent);\n\n\tdata->sensor_devs[type] = indio_dev;\n}\nEXPORT_SYMBOL_NS(ssp_register_consumer, IIO_SSP_SENSORS);\n\nstatic int ssp_probe(struct spi_device *spi)\n{\n\tint ret, i;\n\tstruct ssp_data *data;\n\n\tdata = ssp_parse_dt(&spi->dev);\n\tif (!data) {\n\t\tdev_err(&spi->dev, \"Failed to find platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = mfd_add_devices(&spi->dev, PLATFORM_DEVID_NONE,\n\t\t\t      sensorhub_sensor_devs,\n\t\t\t      ARRAY_SIZE(sensorhub_sensor_devs), NULL, 0, NULL);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"mfd add devices fail\\n\");\n\t\treturn ret;\n\t}\n\n\tspi->mode = SPI_MODE_1;\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"Failed to setup spi\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->fw_dl_state = SSP_FW_DL_STATE_NONE;\n\tdata->spi = spi;\n\tspi_set_drvdata(spi, data);\n\n\tmutex_init(&data->comm_lock);\n\n\tfor (i = 0; i < SSP_SENSOR_MAX; ++i) {\n\t\tdata->delay_buf[i] = SSP_DEFAULT_POLLING_DELAY;\n\t\tdata->batch_latency_buf[i] = 0;\n\t\tdata->batch_opt_buf[i] = 0;\n\t\tdata->check_status[i] = SSP_INITIALIZATION_STATE;\n\t}\n\n\tdata->delay_buf[SSP_BIO_HRM_LIB] = 100;\n\n\tdata->time_syncing = true;\n\n\tmutex_init(&data->pending_lock);\n\tINIT_LIST_HEAD(&data->pending_list);\n\n\tatomic_set(&data->enable_refcount, 0);\n\n\tINIT_WORK(&data->work_wdt, ssp_wdt_work_func);\n\tINIT_DELAYED_WORK(&data->work_refresh, ssp_refresh_task);\n\n\ttimer_setup(&data->wdt_timer, ssp_wdt_timer_func, 0);\n\n\tret = request_threaded_irq(data->spi->irq, NULL,\n\t\t\t\t   ssp_irq_thread_fn,\n\t\t\t\t   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t   \"SSP_Int\", data);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"Irq request fail\\n\");\n\t\tgoto err_setup_irq;\n\t}\n\n\t \n\tdata->shut_down = false;\n\n\t \n\tenable_irq_wake(data->spi->irq);\n\n\tdata->fw_dl_state = ssp_check_fwbl(data);\n\tif (data->fw_dl_state == SSP_FW_DL_STATE_NONE) {\n\t\tret = ssp_initialize_mcu(data);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&spi->dev, \"Initialize_mcu failed\\n\");\n\t\t\tgoto err_read_reg;\n\t\t}\n\t} else {\n\t\tdev_err(&spi->dev, \"Firmware version not supported\\n\");\n\t\tret = -EPERM;\n\t\tgoto err_read_reg;\n\t}\n\n\treturn 0;\n\nerr_read_reg:\n\tfree_irq(data->spi->irq, data);\nerr_setup_irq:\n\tmutex_destroy(&data->pending_lock);\n\tmutex_destroy(&data->comm_lock);\n\n\tdev_err(&spi->dev, \"Probe failed!\\n\");\n\n\treturn ret;\n}\n\nstatic void ssp_remove(struct spi_device *spi)\n{\n\tstruct ssp_data *data = spi_get_drvdata(spi);\n\n\tif (ssp_command(data, SSP_MSG2SSP_AP_STATUS_SHUTDOWN, 0) < 0)\n\t\tdev_err(&data->spi->dev,\n\t\t\t\"SSP_MSG2SSP_AP_STATUS_SHUTDOWN failed\\n\");\n\n\tssp_enable_mcu(data, false);\n\tssp_disable_wdt_timer(data);\n\n\tssp_clean_pending_list(data);\n\n\tfree_irq(data->spi->irq, data);\n\n\tdel_timer_sync(&data->wdt_timer);\n\tcancel_work_sync(&data->work_wdt);\n\n\tmutex_destroy(&data->comm_lock);\n\tmutex_destroy(&data->pending_lock);\n\n\tmfd_remove_devices(&spi->dev);\n}\n\nstatic int ssp_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct ssp_data *data = spi_get_drvdata(to_spi_device(dev));\n\n\tdata->last_resume_state = SSP_MSG2SSP_AP_STATUS_SUSPEND;\n\n\tif (atomic_read(&data->enable_refcount) > 0)\n\t\tssp_disable_wdt_timer(data);\n\n\tret = ssp_command(data, SSP_MSG2SSP_AP_STATUS_SUSPEND, 0);\n\tif (ret < 0) {\n\t\tdev_err(&data->spi->dev,\n\t\t\t\"%s SSP_MSG2SSP_AP_STATUS_SUSPEND failed\\n\", __func__);\n\n\t\tssp_enable_wdt_timer(data);\n\t\treturn ret;\n\t}\n\n\tdata->time_syncing = false;\n\tdisable_irq(data->spi->irq);\n\n\treturn 0;\n}\n\nstatic int ssp_resume(struct device *dev)\n{\n\tint ret;\n\tstruct ssp_data *data = spi_get_drvdata(to_spi_device(dev));\n\n\tenable_irq(data->spi->irq);\n\n\tif (atomic_read(&data->enable_refcount) > 0)\n\t\tssp_enable_wdt_timer(data);\n\n\tret = ssp_command(data, SSP_MSG2SSP_AP_STATUS_RESUME, 0);\n\tif (ret < 0) {\n\t\tdev_err(&data->spi->dev,\n\t\t\t\"%s SSP_MSG2SSP_AP_STATUS_RESUME failed\\n\", __func__);\n\t\tssp_disable_wdt_timer(data);\n\t\treturn ret;\n\t}\n\n\t \n\tdata->last_resume_state = SSP_MSG2SSP_AP_STATUS_RESUME;\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ssp_pm_ops, ssp_suspend, ssp_resume);\n\nstatic struct spi_driver ssp_driver = {\n\t.probe = ssp_probe,\n\t.remove = ssp_remove,\n\t.driver = {\n\t\t.pm = pm_sleep_ptr(&ssp_pm_ops),\n\t\t.of_match_table = ssp_of_match,\n\t\t.name = \"sensorhub\"\n\t},\n};\n\nmodule_spi_driver(ssp_driver);\n\nMODULE_DESCRIPTION(\"ssp sensorhub driver\");\nMODULE_AUTHOR(\"Samsung Electronics\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}