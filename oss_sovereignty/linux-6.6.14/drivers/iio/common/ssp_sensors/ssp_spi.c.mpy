{
  "module_name": "ssp_spi.c",
  "hash_id": "fdd06f5f934e48e6169c6409cecd24911ad21d447cfb731e50087ada1d900de4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/common/ssp_sensors/ssp_spi.c",
  "human_readable_source": "\n \n\n#include \"ssp.h\"\n\n#define SSP_DEV (&data->spi->dev)\n#define SSP_GET_MESSAGE_TYPE(data) (data & (3 << SSP_RW))\n\n \n#define SSP_MSG2AP_INST_BYPASS_DATA\t\t0x37\n#define SSP_MSG2AP_INST_LIBRARY_DATA\t\t0x01\n#define SSP_MSG2AP_INST_DEBUG_DATA\t\t0x03\n#define SSP_MSG2AP_INST_BIG_DATA\t\t0x04\n#define SSP_MSG2AP_INST_META_DATA\t\t0x05\n#define SSP_MSG2AP_INST_TIME_SYNC\t\t0x06\n#define SSP_MSG2AP_INST_RESET\t\t\t0x07\n\n#define SSP_UNIMPLEMENTED -1\n\nstruct ssp_msg_header {\n\tu8 cmd;\n\t__le16 length;\n\t__le16 options;\n\t__le32 data;\n} __attribute__((__packed__));\n\nstruct ssp_msg {\n\tu16 length;\n\tu16 options;\n\tstruct list_head list;\n\tstruct completion *done;\n\tstruct ssp_msg_header *h;\n\tchar *buffer;\n};\n\nstatic const int ssp_offset_map[SSP_SENSOR_MAX] = {\n\t[SSP_ACCELEROMETER_SENSOR] =\t\tSSP_ACCELEROMETER_SIZE +\n\t\t\t\t\t\tSSP_TIME_SIZE,\n\t[SSP_GYROSCOPE_SENSOR] =\t\tSSP_GYROSCOPE_SIZE +\n\t\t\t\t\t\tSSP_TIME_SIZE,\n\t[SSP_GEOMAGNETIC_UNCALIB_SENSOR] =\tSSP_UNIMPLEMENTED,\n\t[SSP_GEOMAGNETIC_RAW] =\t\t\tSSP_UNIMPLEMENTED,\n\t[SSP_GEOMAGNETIC_SENSOR] =\t\tSSP_UNIMPLEMENTED,\n\t[SSP_PRESSURE_SENSOR] =\t\t\tSSP_UNIMPLEMENTED,\n\t[SSP_GESTURE_SENSOR] =\t\t\tSSP_UNIMPLEMENTED,\n\t[SSP_PROXIMITY_SENSOR] =\t\tSSP_UNIMPLEMENTED,\n\t[SSP_TEMPERATURE_HUMIDITY_SENSOR] =\tSSP_UNIMPLEMENTED,\n\t[SSP_LIGHT_SENSOR] =\t\t\tSSP_UNIMPLEMENTED,\n\t[SSP_PROXIMITY_RAW] =\t\t\tSSP_UNIMPLEMENTED,\n\t[SSP_ORIENTATION_SENSOR] =\t\tSSP_UNIMPLEMENTED,\n\t[SSP_STEP_DETECTOR] =\t\t\tSSP_UNIMPLEMENTED,\n\t[SSP_SIG_MOTION_SENSOR] =\t\tSSP_UNIMPLEMENTED,\n\t[SSP_GYRO_UNCALIB_SENSOR] =\t\tSSP_UNIMPLEMENTED,\n\t[SSP_GAME_ROTATION_VECTOR] =\t\tSSP_UNIMPLEMENTED,\n\t[SSP_ROTATION_VECTOR] =\t\t\tSSP_UNIMPLEMENTED,\n\t[SSP_STEP_COUNTER] =\t\t\tSSP_UNIMPLEMENTED,\n\t[SSP_BIO_HRM_RAW] =\t\t\tSSP_BIO_HRM_RAW_SIZE +\n\t\t\t\t\t\tSSP_TIME_SIZE,\n\t[SSP_BIO_HRM_RAW_FAC] =\t\t\tSSP_BIO_HRM_RAW_FAC_SIZE +\n\t\t\t\t\t\tSSP_TIME_SIZE,\n\t[SSP_BIO_HRM_LIB] =\t\t\tSSP_BIO_HRM_LIB_SIZE +\n\t\t\t\t\t\tSSP_TIME_SIZE,\n};\n\n#define SSP_HEADER_SIZE\t\t(sizeof(struct ssp_msg_header))\n#define SSP_HEADER_SIZE_ALIGNED\t(ALIGN(SSP_HEADER_SIZE, 4))\n\nstatic struct ssp_msg *ssp_create_msg(u8 cmd, u16 len, u16 opt, u32 data)\n{\n\tstruct ssp_msg_header h;\n\tstruct ssp_msg *msg;\n\n\tmsg = kzalloc(sizeof(*msg), GFP_KERNEL);\n\tif (!msg)\n\t\treturn NULL;\n\n\th.cmd = cmd;\n\th.length = cpu_to_le16(len);\n\th.options = cpu_to_le16(opt);\n\th.data = cpu_to_le32(data);\n\n\tmsg->buffer = kzalloc(SSP_HEADER_SIZE_ALIGNED + len,\n\t\t\t      GFP_KERNEL | GFP_DMA);\n\tif (!msg->buffer) {\n\t\tkfree(msg);\n\t\treturn NULL;\n\t}\n\n\tmsg->length = len;\n\tmsg->options = opt;\n\n\tmemcpy(msg->buffer, &h, SSP_HEADER_SIZE);\n\n\treturn msg;\n}\n\n \nstatic inline void ssp_fill_buffer(struct ssp_msg *m, unsigned int offset,\n\t\t\t\t   const void *src, unsigned int len)\n{\n\tmemcpy(&m->buffer[SSP_HEADER_SIZE_ALIGNED + offset], src, len);\n}\n\nstatic inline void ssp_get_buffer(struct ssp_msg *m, unsigned int offset,\n\t\t\t\t  void *dest, unsigned int len)\n{\n\tmemcpy(dest, &m->buffer[SSP_HEADER_SIZE_ALIGNED + offset],  len);\n}\n\n#define SSP_GET_BUFFER_AT_INDEX(m, index) \\\n\t(m->buffer[SSP_HEADER_SIZE_ALIGNED + index])\n#define SSP_SET_BUFFER_AT_INDEX(m, index, val) \\\n\t(m->buffer[SSP_HEADER_SIZE_ALIGNED + index] = val)\n\nstatic void ssp_clean_msg(struct ssp_msg *m)\n{\n\tkfree(m->buffer);\n\tkfree(m);\n}\n\nstatic int ssp_print_mcu_debug(char *data_frame, int *data_index,\n\t\t\t       int received_len)\n{\n\tint length = data_frame[(*data_index)++];\n\n\tif (length > received_len - *data_index || length <= 0) {\n\t\tssp_dbg(\"[SSP]: MSG From MCU-invalid debug length(%d/%d)\\n\",\n\t\t\tlength, received_len);\n\t\treturn -EPROTO;\n\t}\n\n\tssp_dbg(\"[SSP]: MSG From MCU - %s\\n\", &data_frame[*data_index]);\n\n\t*data_index += length;\n\n\treturn 0;\n}\n\n \nstatic int ssp_check_lines(struct ssp_data *data, bool state)\n{\n\tint delay_cnt = 0;\n\n\tgpiod_set_value_cansleep(data->ap_mcu_gpiod, state);\n\n\twhile (gpiod_get_value_cansleep(data->mcu_ap_gpiod) != state) {\n\t\tusleep_range(3000, 3500);\n\n\t\tif (data->shut_down || delay_cnt++ > 500) {\n\t\t\tdev_err(SSP_DEV, \"%s:timeout, hw ack wait fail %d\\n\",\n\t\t\t\t__func__, state);\n\n\t\t\tif (!state)\n\t\t\t\tgpiod_set_value_cansleep(data->ap_mcu_gpiod, 1);\n\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ssp_do_transfer(struct ssp_data *data, struct ssp_msg *msg,\n\t\t\t   struct completion *done, int timeout)\n{\n\tint status;\n\t \n\tconst bool use_no_irq = msg->length == 0;\n\n\tif (data->shut_down)\n\t\treturn -EPERM;\n\n\tmsg->done = done;\n\n\tmutex_lock(&data->comm_lock);\n\n\tstatus = ssp_check_lines(data, false);\n\tif (status < 0)\n\t\tgoto _error_locked;\n\n\tstatus = spi_write(data->spi, msg->buffer, SSP_HEADER_SIZE);\n\tif (status < 0) {\n\t\tgpiod_set_value_cansleep(data->ap_mcu_gpiod, 1);\n\t\tdev_err(SSP_DEV, \"%s spi_write fail\\n\", __func__);\n\t\tgoto _error_locked;\n\t}\n\n\tif (!use_no_irq) {\n\t\tmutex_lock(&data->pending_lock);\n\t\tlist_add_tail(&msg->list, &data->pending_list);\n\t\tmutex_unlock(&data->pending_lock);\n\t}\n\n\tstatus = ssp_check_lines(data, true);\n\tif (status < 0) {\n\t\tif (!use_no_irq) {\n\t\t\tmutex_lock(&data->pending_lock);\n\t\t\tlist_del(&msg->list);\n\t\t\tmutex_unlock(&data->pending_lock);\n\t\t}\n\t\tgoto _error_locked;\n\t}\n\n\tmutex_unlock(&data->comm_lock);\n\n\tif (!use_no_irq && done)\n\t\tif (wait_for_completion_timeout(done,\n\t\t\t\t\t\tmsecs_to_jiffies(timeout)) ==\n\t\t    0) {\n\t\t\tmutex_lock(&data->pending_lock);\n\t\t\tlist_del(&msg->list);\n\t\t\tmutex_unlock(&data->pending_lock);\n\n\t\t\tdata->timeout_cnt++;\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\treturn 0;\n\n_error_locked:\n\tmutex_unlock(&data->comm_lock);\n\tdata->timeout_cnt++;\n\treturn status;\n}\n\nstatic inline int ssp_spi_sync_command(struct ssp_data *data,\n\t\t\t\t       struct ssp_msg *msg)\n{\n\treturn ssp_do_transfer(data, msg, NULL, 0);\n}\n\nstatic int ssp_spi_sync(struct ssp_data *data, struct ssp_msg *msg,\n\t\t\tint timeout)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\tif (WARN_ON(!msg->length))\n\t\treturn -EPERM;\n\n\treturn ssp_do_transfer(data, msg, &done, timeout);\n}\n\nstatic int ssp_handle_big_data(struct ssp_data *data, char *dataframe, int *idx)\n{\n\t \n\t*idx += 8;\n\treturn 0;\n}\n\nstatic int ssp_parse_dataframe(struct ssp_data *data, char *dataframe, int len)\n{\n\tint idx, sd;\n\tstruct ssp_sensor_data *spd;\n\tstruct iio_dev **indio_devs = data->sensor_devs;\n\n\tfor (idx = 0; idx < len;) {\n\t\tswitch (dataframe[idx++]) {\n\t\tcase SSP_MSG2AP_INST_BYPASS_DATA:\n\t\t\tif (idx >= len)\n\t\t\t\treturn -EPROTO;\n\t\t\tsd = dataframe[idx++];\n\t\t\tif (sd < 0 || sd >= SSP_SENSOR_MAX) {\n\t\t\t\tdev_err(SSP_DEV,\n\t\t\t\t\t\"Mcu data frame1 error %d\\n\", sd);\n\t\t\t\treturn -EPROTO;\n\t\t\t}\n\n\t\t\tif (indio_devs[sd]) {\n\t\t\t\tspd = iio_priv(indio_devs[sd]);\n\t\t\t\tif (spd->process_data) {\n\t\t\t\t\tif (idx >= len)\n\t\t\t\t\t\treturn -EPROTO;\n\t\t\t\t\tspd->process_data(indio_devs[sd],\n\t\t\t\t\t\t\t  &dataframe[idx],\n\t\t\t\t\t\t\t  data->timestamp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdev_err(SSP_DEV, \"no client for frame\\n\");\n\t\t\t}\n\n\t\t\tidx += ssp_offset_map[sd];\n\t\t\tbreak;\n\t\tcase SSP_MSG2AP_INST_DEBUG_DATA:\n\t\t\tif (idx >= len)\n\t\t\t\treturn -EPROTO;\n\t\t\tsd = ssp_print_mcu_debug(dataframe, &idx, len);\n\t\t\tif (sd) {\n\t\t\t\tdev_err(SSP_DEV,\n\t\t\t\t\t\"Mcu data frame3 error %d\\n\", sd);\n\t\t\t\treturn sd;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SSP_MSG2AP_INST_LIBRARY_DATA:\n\t\t\tidx += len;\n\t\t\tbreak;\n\t\tcase SSP_MSG2AP_INST_BIG_DATA:\n\t\t\tssp_handle_big_data(data, dataframe, &idx);\n\t\t\tbreak;\n\t\tcase SSP_MSG2AP_INST_TIME_SYNC:\n\t\t\tdata->time_syncing = true;\n\t\t\tbreak;\n\t\tcase SSP_MSG2AP_INST_RESET:\n\t\t\tssp_queue_ssp_refresh_task(data, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (data->time_syncing)\n\t\tdata->timestamp = ktime_get_real_ns();\n\n\treturn 0;\n}\n\n \nint ssp_irq_msg(struct ssp_data *data)\n{\n\tchar *buffer;\n\tu8 msg_type;\n\tint ret;\n\tu16 length, msg_options;\n\tstruct ssp_msg *msg = NULL, *iter, *n;\n\n\tret = spi_read(data->spi, data->header_buffer, SSP_HEADER_BUFFER_SIZE);\n\tif (ret < 0) {\n\t\tdev_err(SSP_DEV, \"header read fail\\n\");\n\t\treturn ret;\n\t}\n\n\tlength = le16_to_cpu(data->header_buffer[1]);\n\tmsg_options = le16_to_cpu(data->header_buffer[0]);\n\n\tif (length == 0) {\n\t\tdev_err(SSP_DEV, \"length received from mcu is 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmsg_type = SSP_GET_MESSAGE_TYPE(msg_options);\n\n\tswitch (msg_type) {\n\tcase SSP_AP2HUB_READ:\n\tcase SSP_AP2HUB_WRITE:\n\t\t \n\t\tmutex_lock(&data->pending_lock);\n\t\tlist_for_each_entry_safe(iter, n, &data->pending_list, list) {\n\t\t\tif (iter->options == msg_options) {\n\t\t\t\tlist_del(&iter->list);\n\t\t\t\tmsg = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!msg) {\n\t\t\t \n\t\t\tbuffer = kmalloc(length, GFP_KERNEL | GFP_DMA);\n\t\t\tif (!buffer) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto _unlock;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = spi_read(data->spi, buffer, length);\n\t\t\tif (ret >= 0)\n\t\t\t\tret = -EPROTO;\n\n\t\t\tkfree(buffer);\n\n\t\t\tdev_err(SSP_DEV, \"No match error %x\\n\",\n\t\t\t\tmsg_options);\n\n\t\t\tgoto _unlock;\n\t\t}\n\n\t\tif (msg_type == SSP_AP2HUB_READ)\n\t\t\tret = spi_read(data->spi,\n\t\t\t\t       &msg->buffer[SSP_HEADER_SIZE_ALIGNED],\n\t\t\t\t       msg->length);\n\n\t\tif (msg_type == SSP_AP2HUB_WRITE) {\n\t\t\tret = spi_write(data->spi,\n\t\t\t\t\t&msg->buffer[SSP_HEADER_SIZE_ALIGNED],\n\t\t\t\t\tmsg->length);\n\t\t\tif (msg_options & SSP_AP2HUB_RETURN) {\n\t\t\t\tmsg->options =\n\t\t\t\t\tSSP_AP2HUB_READ | SSP_AP2HUB_RETURN;\n\t\t\t\tmsg->length = 1;\n\n\t\t\t\tlist_add_tail(&msg->list, &data->pending_list);\n\t\t\t\tgoto _unlock;\n\t\t\t}\n\t\t}\n\n\t\tif (msg->done)\n\t\t\tif (!completion_done(msg->done))\n\t\t\t\tcomplete(msg->done);\n_unlock:\n\t\tmutex_unlock(&data->pending_lock);\n\t\tbreak;\n\tcase SSP_HUB2AP_WRITE:\n\t\tbuffer = kzalloc(length, GFP_KERNEL | GFP_DMA);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\tret = spi_read(data->spi, buffer, length);\n\t\tif (ret < 0) {\n\t\t\tdev_err(SSP_DEV, \"spi read fail\\n\");\n\t\t\tkfree(buffer);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ssp_parse_dataframe(data, buffer, length);\n\n\t\tkfree(buffer);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(SSP_DEV, \"unknown msg type\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\treturn ret;\n}\n\nvoid ssp_clean_pending_list(struct ssp_data *data)\n{\n\tstruct ssp_msg *msg, *n;\n\n\tmutex_lock(&data->pending_lock);\n\tlist_for_each_entry_safe(msg, n, &data->pending_list, list) {\n\t\tlist_del(&msg->list);\n\n\t\tif (msg->done)\n\t\t\tif (!completion_done(msg->done))\n\t\t\t\tcomplete(msg->done);\n\t}\n\tmutex_unlock(&data->pending_lock);\n}\n\nint ssp_command(struct ssp_data *data, char command, int arg)\n{\n\tint ret;\n\tstruct ssp_msg *msg;\n\n\tmsg = ssp_create_msg(command, 0, SSP_AP2HUB_WRITE, arg);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tssp_dbg(\"%s - command 0x%x %d\\n\", __func__, command, arg);\n\n\tret = ssp_spi_sync_command(data, msg);\n\tssp_clean_msg(msg);\n\n\treturn ret;\n}\n\nint ssp_send_instruction(struct ssp_data *data, u8 inst, u8 sensor_type,\n\t\t\t u8 *send_buf, u8 length)\n{\n\tint ret;\n\tstruct ssp_msg *msg;\n\n\tif (data->fw_dl_state == SSP_FW_DL_STATE_DOWNLOADING) {\n\t\tdev_err(SSP_DEV, \"%s - Skip Inst! DL state = %d\\n\",\n\t\t\t__func__, data->fw_dl_state);\n\t\treturn -EBUSY;\n\t} else if (!(data->available_sensors & BIT(sensor_type)) &&\n\t\t   (inst <= SSP_MSG2SSP_INST_CHANGE_DELAY)) {\n\t\tdev_err(SSP_DEV, \"%s - Bypass Inst Skip! - %u\\n\",\n\t\t\t__func__, sensor_type);\n\t\treturn -EIO;  \n\t}\n\n\tmsg = ssp_create_msg(inst, length + 2, SSP_AP2HUB_WRITE, 0);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tssp_fill_buffer(msg, 0, &sensor_type, 1);\n\tssp_fill_buffer(msg, 1, send_buf, length);\n\n\tssp_dbg(\"%s - Inst = 0x%x, Sensor Type = 0x%x, data = %u\\n\",\n\t\t__func__, inst, sensor_type, send_buf[1]);\n\n\tret = ssp_spi_sync(data, msg, 1000);\n\tssp_clean_msg(msg);\n\n\treturn ret;\n}\n\nint ssp_get_chipid(struct ssp_data *data)\n{\n\tint ret;\n\tchar buffer;\n\tstruct ssp_msg *msg;\n\n\tmsg = ssp_create_msg(SSP_MSG2SSP_AP_WHOAMI, 1, SSP_AP2HUB_READ, 0);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tret = ssp_spi_sync(data, msg, 1000);\n\n\tbuffer = SSP_GET_BUFFER_AT_INDEX(msg, 0);\n\n\tssp_clean_msg(msg);\n\n\treturn ret < 0 ? ret : buffer;\n}\n\nint ssp_set_magnetic_matrix(struct ssp_data *data)\n{\n\tint ret;\n\tstruct ssp_msg *msg;\n\n\tmsg = ssp_create_msg(SSP_MSG2SSP_AP_SET_MAGNETIC_STATIC_MATRIX,\n\t\t\t     data->sensorhub_info->mag_length, SSP_AP2HUB_WRITE,\n\t\t\t     0);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tssp_fill_buffer(msg, 0, data->sensorhub_info->mag_table,\n\t\t\tdata->sensorhub_info->mag_length);\n\n\tret = ssp_spi_sync(data, msg, 1000);\n\tssp_clean_msg(msg);\n\n\treturn ret;\n}\n\nunsigned int ssp_get_sensor_scanning_info(struct ssp_data *data)\n{\n\tint ret;\n\t__le32 result;\n\tu32 cpu_result = 0;\n\n\tstruct ssp_msg *msg = ssp_create_msg(SSP_MSG2SSP_AP_SENSOR_SCANNING, 4,\n\t\t\t\t\t     SSP_AP2HUB_READ, 0);\n\tif (!msg)\n\t\treturn 0;\n\n\tret = ssp_spi_sync(data, msg, 1000);\n\tif (ret < 0) {\n\t\tdev_err(SSP_DEV, \"%s - spi read fail %d\\n\", __func__, ret);\n\t\tgoto _exit;\n\t}\n\n\tssp_get_buffer(msg, 0, &result, 4);\n\tcpu_result = le32_to_cpu(result);\n\n\tdev_info(SSP_DEV, \"%s state: 0x%08x\\n\", __func__, cpu_result);\n\n_exit:\n\tssp_clean_msg(msg);\n\treturn cpu_result;\n}\n\nunsigned int ssp_get_firmware_rev(struct ssp_data *data)\n{\n\tint ret;\n\t__le32 result;\n\n\tstruct ssp_msg *msg = ssp_create_msg(SSP_MSG2SSP_AP_FIRMWARE_REV, 4,\n\t\t\t\t\t     SSP_AP2HUB_READ, 0);\n\tif (!msg)\n\t\treturn SSP_INVALID_REVISION;\n\n\tret = ssp_spi_sync(data, msg, 1000);\n\tif (ret < 0) {\n\t\tdev_err(SSP_DEV, \"%s - transfer fail %d\\n\", __func__, ret);\n\t\tret = SSP_INVALID_REVISION;\n\t\tgoto _exit;\n\t}\n\n\tssp_get_buffer(msg, 0, &result, 4);\n\tret = le32_to_cpu(result);\n\n_exit:\n\tssp_clean_msg(msg);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}