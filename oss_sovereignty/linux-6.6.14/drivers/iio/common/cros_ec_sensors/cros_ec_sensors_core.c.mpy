{
  "module_name": "cros_ec_sensors_core.c",
  "hash_id": "ca5f399f045b2fbd3ca1e9d7220713798edc221f165aa8f1126ed44dd745b433",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/common/cros_ec_sensors/cros_ec_sensors_core.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/common/cros_ec_sensors_core.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/kfifo_buf.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_data/cros_ec_sensorhub.h>\n#include <linux/platform_device.h>\n\n \n#define CROS_EC_FIFO_SIZE (2048 * 2 / 3)\n\nstatic int cros_ec_get_host_cmd_version_mask(struct cros_ec_device *ec_dev,\n\t\t\t\t\t     u16 cmd_offset, u16 cmd, u32 *mask)\n{\n\tint ret;\n\tstruct {\n\t\tstruct cros_ec_command msg;\n\t\tunion {\n\t\t\tstruct ec_params_get_cmd_versions params;\n\t\t\tstruct ec_response_get_cmd_versions resp;\n\t\t};\n\t} __packed buf = {\n\t\t.msg = {\n\t\t\t.command = EC_CMD_GET_CMD_VERSIONS + cmd_offset,\n\t\t\t.insize = sizeof(struct ec_response_get_cmd_versions),\n\t\t\t.outsize = sizeof(struct ec_params_get_cmd_versions)\n\t\t\t},\n\t\t.params = {.cmd = cmd}\n\t};\n\n\tret = cros_ec_cmd_xfer_status(ec_dev, &buf.msg);\n\tif (ret >= 0)\n\t\t*mask = buf.resp.version_mask;\n\treturn ret;\n}\n\nstatic void get_default_min_max_freq(enum motionsensor_type type,\n\t\t\t\t     u32 *min_freq,\n\t\t\t\t     u32 *max_freq,\n\t\t\t\t     u32 *max_fifo_events)\n{\n\t \n\t*max_fifo_events = CROS_EC_FIFO_SIZE;\n\n\tswitch (type) {\n\tcase MOTIONSENSE_TYPE_ACCEL:\n\t\t*min_freq = 12500;\n\t\t*max_freq = 100000;\n\t\tbreak;\n\tcase MOTIONSENSE_TYPE_GYRO:\n\t\t*min_freq = 25000;\n\t\t*max_freq = 100000;\n\t\tbreak;\n\tcase MOTIONSENSE_TYPE_MAG:\n\t\t*min_freq = 5000;\n\t\t*max_freq = 25000;\n\t\tbreak;\n\tcase MOTIONSENSE_TYPE_PROX:\n\tcase MOTIONSENSE_TYPE_LIGHT:\n\t\t*min_freq = 100;\n\t\t*max_freq = 50000;\n\t\tbreak;\n\tcase MOTIONSENSE_TYPE_BARO:\n\t\t*min_freq = 250;\n\t\t*max_freq = 20000;\n\t\tbreak;\n\tcase MOTIONSENSE_TYPE_ACTIVITY:\n\tdefault:\n\t\t*min_freq = 0;\n\t\t*max_freq = 0;\n\t\tbreak;\n\t}\n}\n\nstatic int cros_ec_sensor_set_ec_rate(struct cros_ec_sensors_core_state *st,\n\t\t\t\t      int rate)\n{\n\tint ret;\n\n\tif (rate > U16_MAX)\n\t\trate = U16_MAX;\n\n\tmutex_lock(&st->cmd_lock);\n\tst->param.cmd = MOTIONSENSE_CMD_EC_RATE;\n\tst->param.ec_rate.data = rate;\n\tret = cros_ec_motion_send_host_cmd(st, 0);\n\tmutex_unlock(&st->cmd_lock);\n\treturn ret;\n}\n\nstatic ssize_t cros_ec_sensor_set_report_latency(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\n\tint integer, fract, ret;\n\tint latency;\n\n\tret = iio_str_to_fixpoint(buf, 100000, &integer, &fract);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlatency = integer * 1000 + fract / 1000;\n\tret = cros_ec_sensor_set_ec_rate(st, latency);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic ssize_t cros_ec_sensor_get_report_latency(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\n\tint latency, ret;\n\n\tmutex_lock(&st->cmd_lock);\n\tst->param.cmd = MOTIONSENSE_CMD_EC_RATE;\n\tst->param.ec_rate.data = EC_MOTION_SENSE_NO_VALUE;\n\n\tret = cros_ec_motion_send_host_cmd(st, 0);\n\tlatency = st->resp->ec_rate.ret;\n\tmutex_unlock(&st->cmd_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d.%06u\\n\",\n\t\t       latency / 1000,\n\t\t       (latency % 1000) * 1000);\n}\n\nstatic IIO_DEVICE_ATTR(hwfifo_timeout, 0644,\n\t\t       cros_ec_sensor_get_report_latency,\n\t\t       cros_ec_sensor_set_report_latency, 0);\n\nstatic ssize_t hwfifo_watermark_max_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\n\n\treturn sprintf(buf, \"%d\\n\", st->fifo_max_event_count);\n}\n\nstatic IIO_DEVICE_ATTR_RO(hwfifo_watermark_max, 0);\n\nstatic const struct iio_dev_attr *cros_ec_sensor_fifo_attributes[] = {\n\t&iio_dev_attr_hwfifo_timeout,\n\t&iio_dev_attr_hwfifo_watermark_max,\n\tNULL,\n};\n\nint cros_ec_sensors_push_data(struct iio_dev *indio_dev,\n\t\t\t      s16 *data,\n\t\t\t      s64 timestamp)\n{\n\tstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\n\ts16 *out;\n\ts64 delta;\n\tunsigned int i;\n\n\t \n\tif (iio_device_claim_buffer_mode(indio_dev) < 0)\n\t\treturn 0;\n\n\tout = (s16 *)st->samples;\n\tfor_each_set_bit(i,\n\t\t\t indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\t*out = data[i];\n\t\tout++;\n\t}\n\n\tif (iio_device_get_clock(indio_dev) != CLOCK_BOOTTIME)\n\t\tdelta = iio_get_time_ns(indio_dev) - cros_ec_get_time_ns();\n\telse\n\t\tdelta = 0;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, st->samples,\n\t\t\t\t\t   timestamp + delta);\n\n\tiio_device_release_buffer_mode(indio_dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cros_ec_sensors_push_data);\n\nstatic void cros_ec_sensors_core_clean(void *arg)\n{\n\tstruct platform_device *pdev = (struct platform_device *)arg;\n\tstruct cros_ec_sensorhub *sensor_hub =\n\t\tdev_get_drvdata(pdev->dev.parent);\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\n\tu8 sensor_num = st->param.info.sensor_num;\n\n\tcros_ec_sensorhub_unregister_push_data(sensor_hub, sensor_num);\n}\n\n \nint cros_ec_sensors_core_init(struct platform_device *pdev,\n\t\t\t      struct iio_dev *indio_dev,\n\t\t\t      bool physical_device,\n\t\t\t      cros_ec_sensors_capture_t trigger_capture)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cros_ec_sensors_core_state *state = iio_priv(indio_dev);\n\tstruct cros_ec_sensorhub *sensor_hub = dev_get_drvdata(dev->parent);\n\tstruct cros_ec_dev *ec = sensor_hub->ec;\n\tstruct cros_ec_sensor_platform *sensor_platform = dev_get_platdata(dev);\n\tu32 ver_mask, temp;\n\tint frequencies[ARRAY_SIZE(state->frequencies) / 2] = { 0 };\n\tint ret, i;\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tstate->ec = ec->ec_dev;\n\tstate->msg = devm_kzalloc(&pdev->dev, sizeof(*state->msg) +\n\t\t\t\tmax((u16)sizeof(struct ec_params_motion_sense),\n\t\t\t\tstate->ec->max_response), GFP_KERNEL);\n\tif (!state->msg)\n\t\treturn -ENOMEM;\n\n\tstate->resp = (struct ec_response_motion_sense *)state->msg->data;\n\n\tmutex_init(&state->cmd_lock);\n\n\tret = cros_ec_get_host_cmd_version_mask(state->ec,\n\t\t\t\t\t\tec->cmd_offset,\n\t\t\t\t\t\tEC_CMD_MOTION_SENSE_CMD,\n\t\t\t\t\t\t&ver_mask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tstate->msg->version = fls(ver_mask) - 1;\n\tstate->msg->command = EC_CMD_MOTION_SENSE_CMD + ec->cmd_offset;\n\tstate->msg->outsize = sizeof(struct ec_params_motion_sense);\n\n\tindio_dev->name = pdev->name;\n\n\tif (physical_device) {\n\t\tenum motionsensor_location loc;\n\n\t\tstate->param.cmd = MOTIONSENSE_CMD_INFO;\n\t\tstate->param.info.sensor_num = sensor_platform->sensor_num;\n\t\tret = cros_ec_motion_send_host_cmd(state, 0);\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"Can not access sensor info\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tstate->type = state->resp->info.type;\n\t\tloc = state->resp->info.location;\n\t\tif (loc == MOTIONSENSE_LOC_BASE)\n\t\t\tindio_dev->label = \"accel-base\";\n\t\telse if (loc == MOTIONSENSE_LOC_LID)\n\t\t\tindio_dev->label = \"accel-display\";\n\t\telse if (loc == MOTIONSENSE_LOC_CAMERA)\n\t\t\tindio_dev->label = \"accel-camera\";\n\n\t\t \n\t\tmemset(state->sign, 1, CROS_EC_SENSOR_MAX_AXIS);\n\n\t\tfor (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)\n\t\t\tstate->calib[i].scale = MOTION_SENSE_DEFAULT_SCALE;\n\n\t\t \n\t\tif (state->msg->version < 3) {\n\t\t\tget_default_min_max_freq(state->resp->info.type,\n\t\t\t\t\t\t &frequencies[1],\n\t\t\t\t\t\t &frequencies[2],\n\t\t\t\t\t\t &state->fifo_max_event_count);\n\t\t} else {\n\t\t\tif (state->resp->info_3.max_frequency == 0) {\n\t\t\t\tget_default_min_max_freq(state->resp->info.type,\n\t\t\t\t\t\t\t &frequencies[1],\n\t\t\t\t\t\t\t &frequencies[2],\n\t\t\t\t\t\t\t &temp);\n\t\t\t} else {\n\t\t\t\tfrequencies[1] = state->resp->info_3.min_frequency;\n\t\t\t\tfrequencies[2] = state->resp->info_3.max_frequency;\n\t\t\t}\n\t\t\tstate->fifo_max_event_count = state->resp->info_3.fifo_max_event_count;\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(frequencies); i++) {\n\t\t\tstate->frequencies[2 * i] = frequencies[i] / 1000;\n\t\t\tstate->frequencies[2 * i + 1] =\n\t\t\t\t(frequencies[i] % 1000) * 1000;\n\t\t}\n\n\t\tif (cros_ec_check_features(ec, EC_FEATURE_MOTION_SENSE_FIFO)) {\n\t\t\t \n\t\t\tret = devm_iio_kfifo_buffer_setup_ext(dev, indio_dev, NULL,\n\t\t\t\t\t\t\t      cros_ec_sensor_fifo_attributes);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tret = iio_device_set_clock(indio_dev, CLOCK_BOOTTIME);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t} else {\n\t\t\t \n\t\t\tret = devm_iio_triggered_buffer_setup(dev, indio_dev,\n\t\t\t\t\tNULL, trigger_capture, NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cros_ec_sensors_core_init);\n\n \nint cros_ec_sensors_core_register(struct device *dev,\n\t\t\t\t  struct iio_dev *indio_dev,\n\t\t\t\t  cros_ec_sensorhub_push_data_cb_t push_data)\n{\n\tstruct cros_ec_sensor_platform *sensor_platform = dev_get_platdata(dev);\n\tstruct cros_ec_sensorhub *sensor_hub = dev_get_drvdata(dev->parent);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct cros_ec_dev *ec = sensor_hub->ec;\n\tint ret;\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!push_data ||\n\t    !cros_ec_check_features(ec, EC_FEATURE_MOTION_SENSE_FIFO))\n\t\treturn 0;\n\n\tret = cros_ec_sensorhub_register_push_data(\n\t\t\tsensor_hub, sensor_platform->sensor_num,\n\t\t\tindio_dev, push_data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(\n\t\t\tdev, cros_ec_sensors_core_clean, pdev);\n}\nEXPORT_SYMBOL_GPL(cros_ec_sensors_core_register);\n\n \nint cros_ec_motion_send_host_cmd(struct cros_ec_sensors_core_state *state,\n\t\t\t\t u16 opt_length)\n{\n\tint ret;\n\n\tif (opt_length)\n\t\tstate->msg->insize = min(opt_length, state->ec->max_response);\n\telse\n\t\tstate->msg->insize = state->ec->max_response;\n\n\tmemcpy(state->msg->data, &state->param, sizeof(state->param));\n\n\tret = cros_ec_cmd_xfer_status(state->ec, state->msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret &&\n\t    state->resp != (struct ec_response_motion_sense *)state->msg->data)\n\t\tmemcpy(state->resp, state->msg->data, ret);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cros_ec_motion_send_host_cmd);\n\nstatic ssize_t cros_ec_sensors_calibrate(struct iio_dev *indio_dev,\n\t\tuintptr_t private, const struct iio_chan_spec *chan,\n\t\tconst char *buf, size_t len)\n{\n\tstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\n\tint ret, i;\n\tbool calibrate;\n\n\tret = kstrtobool(buf, &calibrate);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!calibrate)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&st->cmd_lock);\n\tst->param.cmd = MOTIONSENSE_CMD_PERFORM_CALIB;\n\tret = cros_ec_motion_send_host_cmd(st, 0);\n\tif (ret != 0) {\n\t\tdev_warn(&indio_dev->dev, \"Unable to calibrate sensor\\n\");\n\t} else {\n\t\t \n\t\tfor (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)\n\t\t\tst->calib[i].offset = st->resp->perform_calib.offset[i];\n\t}\n\tmutex_unlock(&st->cmd_lock);\n\n\treturn ret ? ret : len;\n}\n\nstatic ssize_t cros_ec_sensors_id(struct iio_dev *indio_dev,\n\t\t\t\t  uintptr_t private,\n\t\t\t\t  const struct iio_chan_spec *chan, char *buf)\n{\n\tstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", st->param.info.sensor_num);\n}\n\nconst struct iio_chan_spec_ext_info cros_ec_sensors_ext_info[] = {\n\t{\n\t\t.name = \"calibrate\",\n\t\t.shared = IIO_SHARED_BY_ALL,\n\t\t.write = cros_ec_sensors_calibrate\n\t},\n\t{\n\t\t.name = \"id\",\n\t\t.shared = IIO_SHARED_BY_ALL,\n\t\t.read = cros_ec_sensors_id\n\t},\n\t{ },\n};\nEXPORT_SYMBOL_GPL(cros_ec_sensors_ext_info);\n\n \nstatic unsigned int cros_ec_sensors_idx_to_reg(\n\t\t\t\t\tstruct cros_ec_sensors_core_state *st,\n\t\t\t\t\tunsigned int idx)\n{\n\t \n\tif (st->type == MOTIONSENSE_TYPE_ACCEL)\n\t\treturn EC_MEMMAP_ACC_DATA + sizeof(u16) *\n\t\t\t(1 + idx + st->param.info.sensor_num *\n\t\t\t CROS_EC_SENSOR_MAX_AXIS);\n\n\treturn EC_MEMMAP_GYRO_DATA + sizeof(u16) * idx;\n}\n\nstatic int cros_ec_sensors_cmd_read_u8(struct cros_ec_device *ec,\n\t\t\t\t       unsigned int offset, u8 *dest)\n{\n\treturn ec->cmd_readmem(ec, offset, 1, dest);\n}\n\nstatic int cros_ec_sensors_cmd_read_u16(struct cros_ec_device *ec,\n\t\t\t\t\t unsigned int offset, u16 *dest)\n{\n\t__le16 tmp;\n\tint ret = ec->cmd_readmem(ec, offset, 2, &tmp);\n\n\tif (ret >= 0)\n\t\t*dest = le16_to_cpu(tmp);\n\n\treturn ret;\n}\n\n \nstatic int cros_ec_sensors_read_until_not_busy(\n\t\t\t\t\tstruct cros_ec_sensors_core_state *st)\n{\n\tstruct cros_ec_device *ec = st->ec;\n\tu8 status;\n\tint ret, attempts = 0;\n\n\tret = cros_ec_sensors_cmd_read_u8(ec, EC_MEMMAP_ACC_STATUS, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (status & EC_MEMMAP_ACC_STATUS_BUSY_BIT) {\n\t\t \n\t\tif (attempts++ >= 50)\n\t\t\treturn -EIO;\n\n\t\t \n\t\tif (attempts % 5 == 0)\n\t\t\tmsleep(25);\n\n\t\tret = cros_ec_sensors_cmd_read_u8(ec, EC_MEMMAP_ACC_STATUS,\n\t\t\t\t\t\t  &status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn status;\n}\n\n \nstatic int cros_ec_sensors_read_data_unsafe(struct iio_dev *indio_dev,\n\t\t\t unsigned long scan_mask, s16 *data)\n{\n\tstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\n\tstruct cros_ec_device *ec = st->ec;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tfor_each_set_bit(i, &scan_mask, indio_dev->masklength) {\n\t\tret = cros_ec_sensors_cmd_read_u16(ec,\n\t\t\t\t\t     cros_ec_sensors_idx_to_reg(st, i),\n\t\t\t\t\t     data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*data *= st->sign[i];\n\t\tdata++;\n\t}\n\n\treturn 0;\n}\n\n \nint cros_ec_sensors_read_lpc(struct iio_dev *indio_dev,\n\t\t\t     unsigned long scan_mask, s16 *data)\n{\n\tstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\n\tstruct cros_ec_device *ec = st->ec;\n\tu8 samp_id = 0xff, status = 0;\n\tint ret, attempts = 0;\n\n\t \n\twhile ((status & (EC_MEMMAP_ACC_STATUS_BUSY_BIT |\n\t\t\t  EC_MEMMAP_ACC_STATUS_SAMPLE_ID_MASK)) != samp_id) {\n\t\t \n\t\tif (attempts++ >= 5)\n\t\t\treturn -EIO;\n\n\t\t \n\t\tret = cros_ec_sensors_read_until_not_busy(st);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tsamp_id = ret & EC_MEMMAP_ACC_STATUS_SAMPLE_ID_MASK;\n\n\t\t \n\t\tret = cros_ec_sensors_read_data_unsafe(indio_dev, scan_mask,\n\t\t\t\t\t\t       data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = cros_ec_sensors_cmd_read_u8(ec, EC_MEMMAP_ACC_STATUS,\n\t\t\t\t\t\t  &status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cros_ec_sensors_read_lpc);\n\n \nint cros_ec_sensors_read_cmd(struct iio_dev *indio_dev,\n\t\t\t     unsigned long scan_mask, s16 *data)\n{\n\tstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\n\tint ret;\n\tunsigned int i;\n\n\t \n\tst->param.cmd = MOTIONSENSE_CMD_DATA;\n\tret = cros_ec_motion_send_host_cmd(st, sizeof(st->resp->data));\n\tif (ret != 0) {\n\t\tdev_warn(&indio_dev->dev, \"Unable to read sensor data\\n\");\n\t\treturn ret;\n\t}\n\n\tfor_each_set_bit(i, &scan_mask, indio_dev->masklength) {\n\t\t*data = st->resp->data.data[i];\n\t\tdata++;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cros_ec_sensors_read_cmd);\n\n \nirqreturn_t cros_ec_sensors_capture(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->cmd_lock);\n\n\t \n\tmemset(st->samples, 0, indio_dev->scan_bytes);\n\n\t \n\tret = st->read_ec_sensors_data(indio_dev,\n\t\t\t\t       *(indio_dev->active_scan_mask),\n\t\t\t\t       (s16 *)st->samples);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, st->samples,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\ndone:\n\t \n\tiio_trigger_notify_done(indio_dev->trig);\n\n\tmutex_unlock(&st->cmd_lock);\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_GPL(cros_ec_sensors_capture);\n\n \nint cros_ec_sensors_core_read(struct cros_ec_sensors_core_state *st,\n\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t  int *val, int *val2, long mask)\n{\n\tint ret, frequency;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tst->param.cmd = MOTIONSENSE_CMD_SENSOR_ODR;\n\t\tst->param.sensor_odr.data =\n\t\t\tEC_MOTION_SENSE_NO_VALUE;\n\n\t\tret = cros_ec_motion_send_host_cmd(st, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tfrequency = st->resp->sensor_odr.ret;\n\t\t*val = frequency / 1000;\n\t\t*val2 = (frequency % 1000) * 1000;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cros_ec_sensors_core_read);\n\n \nint cros_ec_sensors_core_read_avail(struct iio_dev *indio_dev,\n\t\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t\t    const int **vals,\n\t\t\t\t    int *type,\n\t\t\t\t    int *length,\n\t\t\t\t    long mask)\n{\n\tstruct cros_ec_sensors_core_state *state = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*length = ARRAY_SIZE(state->frequencies);\n\t\t*vals = (const int *)&state->frequencies;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\treturn IIO_AVAIL_LIST;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(cros_ec_sensors_core_read_avail);\n\n \nint cros_ec_sensors_core_write(struct cros_ec_sensors_core_state *st,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val, int val2, long mask)\n{\n\tint ret, frequency;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tfrequency = val * 1000 + val2 / 1000;\n\t\tst->param.cmd = MOTIONSENSE_CMD_SENSOR_ODR;\n\t\tst->param.sensor_odr.data = frequency;\n\n\t\t \n\t\tst->param.sensor_odr.roundup = 1;\n\n\t\tret = cros_ec_motion_send_host_cmd(st, 0);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cros_ec_sensors_core_write);\n\nstatic int __maybe_unused cros_ec_sensors_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\n\tint ret = 0;\n\n\tif (st->range_updated) {\n\t\tmutex_lock(&st->cmd_lock);\n\t\tst->param.cmd = MOTIONSENSE_CMD_SENSOR_RANGE;\n\t\tst->param.sensor_range.data = st->curr_range;\n\t\tst->param.sensor_range.roundup = 1;\n\t\tret = cros_ec_motion_send_host_cmd(st, 0);\n\t\tmutex_unlock(&st->cmd_lock);\n\t}\n\treturn ret;\n}\n\nSIMPLE_DEV_PM_OPS(cros_ec_sensors_pm_ops, NULL, cros_ec_sensors_resume);\nEXPORT_SYMBOL_GPL(cros_ec_sensors_pm_ops);\n\nMODULE_DESCRIPTION(\"ChromeOS EC sensor hub core functions\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}