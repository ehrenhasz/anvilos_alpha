{
  "module_name": "cros_ec_lid_angle.c",
  "hash_id": "8edf84e05bdc4c7dfc83c7b4ded0d85c61764813f6cf3ec0f5e66835ca44f05b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/common/cros_ec_sensors/cros_ec_lid_angle.c",
  "human_readable_source": "\n\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/common/cros_ec_sensors_core.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/kfifo_buf.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define DRV_NAME \"cros-ec-lid-angle\"\n\n \nstatic const struct iio_chan_spec cros_ec_lid_angle_channels[] = {\n\t{\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.scan_type.realbits = CROS_EC_SENSOR_BITS,\n\t\t.scan_type.storagebits = CROS_EC_SENSOR_BITS,\n\t\t.scan_type.sign = 'u',\n\t\t.type = IIO_ANGL\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1)\n};\n\n \nstruct cros_ec_lid_angle_state {\n\t \n\tstruct cros_ec_sensors_core_state core;\n};\n\nstatic int cros_ec_sensors_read_lid_angle(struct iio_dev *indio_dev,\n\t\t\t\t\t  unsigned long scan_mask, s16 *data)\n{\n\tstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tst->param.cmd = MOTIONSENSE_CMD_LID_ANGLE;\n\tret = cros_ec_motion_send_host_cmd(st, sizeof(st->resp->lid_angle));\n\tif (ret) {\n\t\tdev_warn(&indio_dev->dev, \"Unable to read lid angle\\n\");\n\t\treturn ret;\n\t}\n\n\t*data = st->resp->lid_angle.value;\n\treturn 0;\n}\n\nstatic int cros_ec_lid_angle_read(struct iio_dev *indio_dev,\n\t\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct cros_ec_lid_angle_state *st = iio_priv(indio_dev);\n\ts16 data;\n\tint ret;\n\n\tmutex_lock(&st->core.cmd_lock);\n\tret = cros_ec_sensors_read_lid_angle(indio_dev, 1, &data);\n\tif (ret == 0) {\n\t\t*val = data;\n\t\tret = IIO_VAL_INT;\n\t}\n\tmutex_unlock(&st->core.cmd_lock);\n\treturn ret;\n}\n\nstatic const struct iio_info cros_ec_lid_angle_info = {\n\t.read_raw = &cros_ec_lid_angle_read,\n};\n\nstatic int cros_ec_lid_angle_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct cros_ec_lid_angle_state *state;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*state));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tret = cros_ec_sensors_core_init(pdev, indio_dev, false, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->info = &cros_ec_lid_angle_info;\n\tstate = iio_priv(indio_dev);\n\tindio_dev->channels = cros_ec_lid_angle_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(cros_ec_lid_angle_channels);\n\n\tstate->core.read_ec_sensors_data = cros_ec_sensors_read_lid_angle;\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,\n\t\t\tcros_ec_sensors_capture, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn cros_ec_sensors_core_register(dev, indio_dev, NULL);\n}\n\nstatic const struct platform_device_id cros_ec_lid_angle_ids[] = {\n\t{\n\t\t.name = DRV_NAME,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(platform, cros_ec_lid_angle_ids);\n\nstatic struct platform_driver cros_ec_lid_angle_platform_driver = {\n\t.driver = {\n\t\t.name\t= DRV_NAME,\n\t},\n\t.probe\t\t= cros_ec_lid_angle_probe,\n\t.id_table\t= cros_ec_lid_angle_ids,\n};\nmodule_platform_driver(cros_ec_lid_angle_platform_driver);\n\nMODULE_DESCRIPTION(\"ChromeOS EC driver for reporting convertible lid angle.\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}