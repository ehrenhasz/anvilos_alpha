{
  "module_name": "cros_ec_sensors.c",
  "hash_id": "8a5bdf29dcc1877483df770858ca945e12fc01cfaec49939bb218cb78de17f6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/common/cros_ec_sensors_core.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/kfifo_buf.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define CROS_EC_SENSORS_MAX_CHANNELS 4\n\n \nstruct cros_ec_sensors_state {\n\t \n\tstruct cros_ec_sensors_core_state core;\n\n\tstruct iio_chan_spec channels[CROS_EC_SENSORS_MAX_CHANNELS];\n};\n\nstatic int cros_ec_sensors_read(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t  int *val, int *val2, long mask)\n{\n\tstruct cros_ec_sensors_state *st = iio_priv(indio_dev);\n\ts16 data = 0;\n\ts64 val64;\n\tint i;\n\tint ret;\n\tint idx = chan->scan_index;\n\n\tmutex_lock(&st->core.cmd_lock);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = st->core.read_ec_sensors_data(indio_dev, 1 << idx, &data);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = IIO_VAL_INT;\n\t\t*val = data;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tst->core.param.cmd = MOTIONSENSE_CMD_SENSOR_OFFSET;\n\t\tst->core.param.sensor_offset.flags = 0;\n\n\t\tret = cros_ec_motion_send_host_cmd(&st->core, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tfor (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)\n\t\t\tst->core.calib[i].offset =\n\t\t\t\tst->core.resp->sensor_offset.offset[i];\n\t\tret = IIO_VAL_INT;\n\t\t*val = st->core.calib[idx].offset;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tst->core.param.cmd = MOTIONSENSE_CMD_SENSOR_SCALE;\n\t\tst->core.param.sensor_offset.flags = 0;\n\n\t\tret = cros_ec_motion_send_host_cmd(&st->core, 0);\n\t\tif (ret == -EPROTO || ret == -EOPNOTSUPP) {\n\t\t\t \n\t\t\t*val = 1;\n\t\t\t*val2 = 0;\n\t\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\t\tbreak;\n\t\t} else if (ret) {\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfor (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)\n\t\t\tst->core.calib[i].scale =\n\t\t\t\tst->core.resp->sensor_scale.scale[i];\n\n\t\t*val = st->core.calib[idx].scale >> 15;\n\t\t*val2 = ((st->core.calib[idx].scale & 0x7FFF) * 1000000LL) /\n\t\t\tMOTION_SENSE_DEFAULT_SCALE;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tst->core.param.cmd = MOTIONSENSE_CMD_SENSOR_RANGE;\n\t\tst->core.param.sensor_range.data = EC_MOTION_SENSE_NO_VALUE;\n\n\t\tret = cros_ec_motion_send_host_cmd(&st->core, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tval64 = st->core.resp->sensor_range.ret;\n\t\tswitch (st->core.type) {\n\t\tcase MOTIONSENSE_TYPE_ACCEL:\n\t\t\t \n\t\t\t*val = div_s64(val64 * 980665, 10);\n\t\t\t*val2 = 10000 << (CROS_EC_SENSOR_BITS - 1);\n\t\t\tret = IIO_VAL_FRACTIONAL;\n\t\t\tbreak;\n\t\tcase MOTIONSENSE_TYPE_GYRO:\n\t\t\t \n\t\t\t*val = 0;\n\t\t\t*val2 = div_s64(val64 * 3141592653ULL,\n\t\t\t\t\t180 << (CROS_EC_SENSOR_BITS - 1));\n\t\t\tret = IIO_VAL_INT_PLUS_NANO;\n\t\t\tbreak;\n\t\tcase MOTIONSENSE_TYPE_MAG:\n\t\t\t \n\t\t\t*val = val64;\n\t\t\t*val2 = 100 << (CROS_EC_SENSOR_BITS - 1);\n\t\t\tret = IIO_VAL_FRACTIONAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = cros_ec_sensors_core_read(&st->core, chan, val, val2,\n\t\t\t\t\t\tmask);\n\t\tbreak;\n\t}\n\tmutex_unlock(&st->core.cmd_lock);\n\n\treturn ret;\n}\n\nstatic int cros_ec_sensors_write(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val, int val2, long mask)\n{\n\tstruct cros_ec_sensors_state *st = iio_priv(indio_dev);\n\tint i;\n\tint ret;\n\tint idx = chan->scan_index;\n\n\tmutex_lock(&st->core.cmd_lock);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tst->core.calib[idx].offset = val;\n\n\t\t \n\t\tst->core.param.cmd = MOTIONSENSE_CMD_SENSOR_OFFSET;\n\t\tst->core.param.sensor_offset.flags =\n\t\t\tMOTION_SENSE_SET_OFFSET;\n\t\tfor (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)\n\t\t\tst->core.param.sensor_offset.offset[i] =\n\t\t\t\tst->core.calib[i].offset;\n\t\tst->core.param.sensor_offset.temp =\n\t\t\tEC_MOTION_SENSE_INVALID_CALIB_TEMP;\n\n\t\tret = cros_ec_motion_send_host_cmd(&st->core, 0);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tst->core.calib[idx].scale = val;\n\t\t \n\n\t\tst->core.param.cmd = MOTIONSENSE_CMD_SENSOR_SCALE;\n\t\tst->core.param.sensor_offset.flags =\n\t\t\tMOTION_SENSE_SET_OFFSET;\n\t\tfor (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)\n\t\t\tst->core.param.sensor_scale.scale[i] =\n\t\t\t\tst->core.calib[i].scale;\n\t\tst->core.param.sensor_scale.temp =\n\t\t\tEC_MOTION_SENSE_INVALID_CALIB_TEMP;\n\n\t\tret = cros_ec_motion_send_host_cmd(&st->core, 0);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (st->core.type == MOTIONSENSE_TYPE_MAG) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tst->core.param.cmd = MOTIONSENSE_CMD_SENSOR_RANGE;\n\t\tst->core.param.sensor_range.data = val;\n\n\t\t \n\t\tst->core.param.sensor_range.roundup = 1;\n\n\t\tret = cros_ec_motion_send_host_cmd(&st->core, 0);\n\t\tif (ret == 0) {\n\t\t\tst->core.range_updated = true;\n\t\t\tst->core.curr_range = val;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = cros_ec_sensors_core_write(\n\t\t\t\t&st->core, chan, val, val2, mask);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&st->core.cmd_lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_info ec_sensors_info = {\n\t.read_raw = &cros_ec_sensors_read,\n\t.write_raw = &cros_ec_sensors_write,\n\t.read_avail = &cros_ec_sensors_core_read_avail,\n};\n\nstatic int cros_ec_sensors_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct cros_ec_sensors_state *state;\n\tstruct iio_chan_spec *channel;\n\tint ret, i;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*state));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tret = cros_ec_sensors_core_init(pdev, indio_dev, true,\n\t\t\t\t\tcros_ec_sensors_capture);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->info = &ec_sensors_info;\n\tstate = iio_priv(indio_dev);\n\tfor (channel = state->channels, i = CROS_EC_SENSOR_X;\n\t     i < CROS_EC_SENSOR_MAX_AXIS; i++, channel++) {\n\t\t \n\t\tchannel->info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS) |\n\t\t\tBIT(IIO_CHAN_INFO_CALIBSCALE);\n\t\tchannel->info_mask_shared_by_all =\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ);\n\t\tchannel->info_mask_shared_by_all_available =\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ);\n\t\tchannel->scan_type.realbits = CROS_EC_SENSOR_BITS;\n\t\tchannel->scan_type.storagebits = CROS_EC_SENSOR_BITS;\n\t\tchannel->scan_index = i;\n\t\tchannel->ext_info = cros_ec_sensors_ext_info;\n\t\tchannel->modified = 1;\n\t\tchannel->channel2 = IIO_MOD_X + i;\n\t\tchannel->scan_type.sign = 's';\n\n\t\t \n\t\tswitch (state->core.type) {\n\t\tcase MOTIONSENSE_TYPE_ACCEL:\n\t\t\tchannel->type = IIO_ACCEL;\n\t\t\tbreak;\n\t\tcase MOTIONSENSE_TYPE_GYRO:\n\t\t\tchannel->type = IIO_ANGL_VEL;\n\t\t\tbreak;\n\t\tcase MOTIONSENSE_TYPE_MAG:\n\t\t\tchannel->type = IIO_MAGN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&pdev->dev, \"Unknown motion sensor\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tchannel->type = IIO_TIMESTAMP;\n\tchannel->channel = -1;\n\tchannel->scan_index = CROS_EC_SENSOR_MAX_AXIS;\n\tchannel->scan_type.sign = 's';\n\tchannel->scan_type.realbits = 64;\n\tchannel->scan_type.storagebits = 64;\n\n\tindio_dev->channels = state->channels;\n\tindio_dev->num_channels = CROS_EC_SENSORS_MAX_CHANNELS;\n\n\t \n\tif ((state->core.ec->cmd_readmem != NULL) &&\n\t    (state->core.type != MOTIONSENSE_TYPE_MAG))\n\t\tstate->core.read_ec_sensors_data = cros_ec_sensors_read_lpc;\n\telse\n\t\tstate->core.read_ec_sensors_data = cros_ec_sensors_read_cmd;\n\n\treturn cros_ec_sensors_core_register(dev, indio_dev,\n\t\t\tcros_ec_sensors_push_data);\n}\n\nstatic const struct platform_device_id cros_ec_sensors_ids[] = {\n\t{\n\t\t.name = \"cros-ec-accel\",\n\t},\n\t{\n\t\t.name = \"cros-ec-gyro\",\n\t},\n\t{\n\t\t.name = \"cros-ec-mag\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(platform, cros_ec_sensors_ids);\n\nstatic struct platform_driver cros_ec_sensors_platform_driver = {\n\t.driver = {\n\t\t.name\t= \"cros-ec-sensors\",\n\t\t.pm\t= &cros_ec_sensors_pm_ops,\n\t},\n\t.probe\t\t= cros_ec_sensors_probe,\n\t.id_table\t= cros_ec_sensors_ids,\n};\nmodule_platform_driver(cros_ec_sensors_platform_driver);\n\nMODULE_DESCRIPTION(\"ChromeOS EC 3-axis sensors driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}