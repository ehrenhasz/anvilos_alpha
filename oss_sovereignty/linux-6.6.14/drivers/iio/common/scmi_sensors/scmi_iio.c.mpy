{
  "module_name": "scmi_iio.c",
  "hash_id": "3f0386d044fd616eeb58814fa1866e87ed34227aeace621ad5452aabe8b3258c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/common/scmi_sensors/scmi_iio.c",
  "human_readable_source": "\n\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/kfifo_buf.h>\n#include <linux/iio/sysfs.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/scmi_protocol.h>\n#include <linux/time.h>\n#include <linux/types.h>\n#include <linux/units.h>\n\n#define SCMI_IIO_NUM_OF_AXIS 3\n\nstruct scmi_iio_priv {\n\tconst struct scmi_sensor_proto_ops *sensor_ops;\n\tstruct scmi_protocol_handle *ph;\n\tconst struct scmi_sensor_info *sensor_info;\n\tstruct iio_dev *indio_dev;\n\t \n\tstruct mutex lock;\n\t \n\ts64 iio_buf[SCMI_IIO_NUM_OF_AXIS + 1];\n\tstruct notifier_block sensor_update_nb;\n\tu32 *freq_avail;\n};\n\nstatic int scmi_iio_sensor_update_cb(struct notifier_block *nb,\n\t\t\t\t     unsigned long event, void *data)\n{\n\tstruct scmi_sensor_update_report *sensor_update = data;\n\tstruct iio_dev *scmi_iio_dev;\n\tstruct scmi_iio_priv *sensor;\n\ts8 tstamp_scale;\n\tu64 time, time_ns;\n\tint i;\n\n\tif (sensor_update->readings_count == 0)\n\t\treturn NOTIFY_DONE;\n\n\tsensor = container_of(nb, struct scmi_iio_priv, sensor_update_nb);\n\n\tfor (i = 0; i < sensor_update->readings_count; i++)\n\t\tsensor->iio_buf[i] = sensor_update->readings[i].value;\n\n\tif (!sensor->sensor_info->timestamped) {\n\t\ttime_ns = ktime_to_ns(sensor_update->timestamp);\n\t} else {\n\t\t \n\t\ttime = sensor_update->readings[0].timestamp;\n\n\t\t \n\t\ttstamp_scale = sensor->sensor_info->tstamp_scale +\n\t\t\t       const_ilog2(NSEC_PER_SEC) / const_ilog2(10);\n\t\tif (tstamp_scale < 0) {\n\t\t\tdo_div(time, int_pow(10, abs(tstamp_scale)));\n\t\t\ttime_ns = time;\n\t\t} else {\n\t\t\ttime_ns = time * int_pow(10, tstamp_scale);\n\t\t}\n\t}\n\n\tscmi_iio_dev = sensor->indio_dev;\n\tiio_push_to_buffers_with_timestamp(scmi_iio_dev, sensor->iio_buf,\n\t\t\t\t\t   time_ns);\n\treturn NOTIFY_OK;\n}\n\nstatic int scmi_iio_buffer_preenable(struct iio_dev *iio_dev)\n{\n\tstruct scmi_iio_priv *sensor = iio_priv(iio_dev);\n\tu32 sensor_config = 0;\n\tint err;\n\n\tif (sensor->sensor_info->timestamped)\n\t\tsensor_config |= FIELD_PREP(SCMI_SENS_CFG_TSTAMP_ENABLED_MASK,\n\t\t\t\t\t    SCMI_SENS_CFG_TSTAMP_ENABLE);\n\n\tsensor_config |= FIELD_PREP(SCMI_SENS_CFG_SENSOR_ENABLED_MASK,\n\t\t\t\t    SCMI_SENS_CFG_SENSOR_ENABLE);\n\terr = sensor->sensor_ops->config_set(sensor->ph,\n\t\t\t\t\t     sensor->sensor_info->id,\n\t\t\t\t\t     sensor_config);\n\tif (err)\n\t\tdev_err(&iio_dev->dev, \"Error in enabling sensor %s err %d\",\n\t\t\tsensor->sensor_info->name, err);\n\n\treturn err;\n}\n\nstatic int scmi_iio_buffer_postdisable(struct iio_dev *iio_dev)\n{\n\tstruct scmi_iio_priv *sensor = iio_priv(iio_dev);\n\tu32 sensor_config = 0;\n\tint err;\n\n\tsensor_config |= FIELD_PREP(SCMI_SENS_CFG_SENSOR_ENABLED_MASK,\n\t\t\t\t    SCMI_SENS_CFG_SENSOR_DISABLE);\n\terr = sensor->sensor_ops->config_set(sensor->ph,\n\t\t\t\t\t     sensor->sensor_info->id,\n\t\t\t\t\t     sensor_config);\n\tif (err) {\n\t\tdev_err(&iio_dev->dev,\n\t\t\t\"Error in disabling sensor %s with err %d\",\n\t\t\tsensor->sensor_info->name, err);\n\t}\n\n\treturn err;\n}\n\nstatic const struct iio_buffer_setup_ops scmi_iio_buffer_ops = {\n\t.preenable = scmi_iio_buffer_preenable,\n\t.postdisable = scmi_iio_buffer_postdisable,\n};\n\nstatic int scmi_iio_set_odr_val(struct iio_dev *iio_dev, int val, int val2)\n{\n\tstruct scmi_iio_priv *sensor = iio_priv(iio_dev);\n\tu64 sec, mult, uHz, sf;\n\tu32 sensor_config;\n\tchar buf[32];\n\n\tint err = sensor->sensor_ops->config_get(sensor->ph,\n\t\t\t\t\t\t sensor->sensor_info->id,\n\t\t\t\t\t\t &sensor_config);\n\tif (err) {\n\t\tdev_err(&iio_dev->dev,\n\t\t\t\"Error in getting sensor config for sensor %s err %d\",\n\t\t\tsensor->sensor_info->name, err);\n\t\treturn err;\n\t}\n\n\tuHz = val * MICROHZ_PER_HZ + val2;\n\n\t \n\tsf = (u64)uHz * 0xFFFF;\n\tdo_div(sf,  MICROHZ_PER_HZ);\n\tmult = scnprintf(buf, sizeof(buf), \"%llu\", sf) - 1;\n\n\tsec = int_pow(10, mult) * MICROHZ_PER_HZ;\n\tdo_div(sec, uHz);\n\tif (sec == 0) {\n\t\tdev_err(&iio_dev->dev,\n\t\t\t\"Trying to set invalid sensor update value for sensor %s\",\n\t\t\tsensor->sensor_info->name);\n\t\treturn -EINVAL;\n\t}\n\n\tsensor_config &= ~SCMI_SENS_CFG_UPDATE_SECS_MASK;\n\tsensor_config |= FIELD_PREP(SCMI_SENS_CFG_UPDATE_SECS_MASK, sec);\n\tsensor_config &= ~SCMI_SENS_CFG_UPDATE_EXP_MASK;\n\tsensor_config |= FIELD_PREP(SCMI_SENS_CFG_UPDATE_EXP_MASK, -mult);\n\n\tif (sensor->sensor_info->timestamped) {\n\t\tsensor_config &= ~SCMI_SENS_CFG_TSTAMP_ENABLED_MASK;\n\t\tsensor_config |= FIELD_PREP(SCMI_SENS_CFG_TSTAMP_ENABLED_MASK,\n\t\t\t\t\t    SCMI_SENS_CFG_TSTAMP_ENABLE);\n\t}\n\n\tsensor_config &= ~SCMI_SENS_CFG_ROUND_MASK;\n\tsensor_config |=\n\t\tFIELD_PREP(SCMI_SENS_CFG_ROUND_MASK, SCMI_SENS_CFG_ROUND_AUTO);\n\n\terr = sensor->sensor_ops->config_set(sensor->ph,\n\t\t\t\t\t     sensor->sensor_info->id,\n\t\t\t\t\t     sensor_config);\n\tif (err)\n\t\tdev_err(&iio_dev->dev,\n\t\t\t\"Error in setting sensor update interval for sensor %s value %u err %d\",\n\t\t\tsensor->sensor_info->name, sensor_config, err);\n\n\treturn err;\n}\n\nstatic int scmi_iio_write_raw(struct iio_dev *iio_dev,\n\t\t\t      struct iio_chan_spec const *chan, int val,\n\t\t\t      int val2, long mask)\n{\n\tstruct scmi_iio_priv *sensor = iio_priv(iio_dev);\n\tint err;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tmutex_lock(&sensor->lock);\n\t\terr = scmi_iio_set_odr_val(iio_dev, val, val2);\n\t\tmutex_unlock(&sensor->lock);\n\t\treturn err;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int scmi_iio_read_avail(struct iio_dev *iio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length,\n\t\t\t       long mask)\n{\n\tstruct scmi_iio_priv *sensor = iio_priv(iio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*vals = sensor->freq_avail;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t*length = sensor->sensor_info->intervals.count * 2;\n\t\tif (sensor->sensor_info->intervals.segmented)\n\t\t\treturn IIO_AVAIL_RANGE;\n\t\telse\n\t\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void convert_ns_to_freq(u64 interval_ns, u64 *hz, u64 *uhz)\n{\n\tu64 rem, freq;\n\n\tfreq = NSEC_PER_SEC;\n\trem = do_div(freq, interval_ns);\n\t*hz = freq;\n\t*uhz = rem * 1000000UL;\n\tdo_div(*uhz, interval_ns);\n}\n\nstatic int scmi_iio_get_odr_val(struct iio_dev *iio_dev, int *val, int *val2)\n{\n\tu64 sensor_update_interval, sensor_interval_mult, hz, uhz;\n\tstruct scmi_iio_priv *sensor = iio_priv(iio_dev);\n\tu32 sensor_config;\n\tint mult;\n\n\tint err = sensor->sensor_ops->config_get(sensor->ph,\n\t\t\t\t\t\t sensor->sensor_info->id,\n\t\t\t\t\t\t &sensor_config);\n\tif (err) {\n\t\tdev_err(&iio_dev->dev,\n\t\t\t\"Error in getting sensor config for sensor %s err %d\",\n\t\t\tsensor->sensor_info->name, err);\n\t\treturn err;\n\t}\n\n\tsensor_update_interval =\n\t\tSCMI_SENS_CFG_GET_UPDATE_SECS(sensor_config) * NSEC_PER_SEC;\n\n\tmult = SCMI_SENS_CFG_GET_UPDATE_EXP(sensor_config);\n\tif (mult < 0) {\n\t\tsensor_interval_mult = int_pow(10, abs(mult));\n\t\tdo_div(sensor_update_interval, sensor_interval_mult);\n\t} else {\n\t\tsensor_interval_mult = int_pow(10, mult);\n\t\tsensor_update_interval =\n\t\t\tsensor_update_interval * sensor_interval_mult;\n\t}\n\n\tconvert_ns_to_freq(sensor_update_interval, &hz, &uhz);\n\t*val = hz;\n\t*val2 = uhz;\n\treturn 0;\n}\n\nstatic int scmi_iio_read_channel_data(struct iio_dev *iio_dev,\n\t\t\t     struct iio_chan_spec const *ch, int *val, int *val2)\n{\n\tstruct scmi_iio_priv *sensor = iio_priv(iio_dev);\n\tu32 sensor_config;\n\tstruct scmi_sensor_reading readings[SCMI_IIO_NUM_OF_AXIS];\n\tint err;\n\n\tsensor_config = FIELD_PREP(SCMI_SENS_CFG_SENSOR_ENABLED_MASK,\n\t\t\t\t\tSCMI_SENS_CFG_SENSOR_ENABLE);\n\terr = sensor->sensor_ops->config_set(\n\t\tsensor->ph, sensor->sensor_info->id, sensor_config);\n\tif (err) {\n\t\tdev_err(&iio_dev->dev,\n\t\t\t\"Error in enabling sensor %s err %d\",\n\t\t\tsensor->sensor_info->name, err);\n\t\treturn err;\n\t}\n\n\terr = sensor->sensor_ops->reading_get_timestamped(\n\t\tsensor->ph, sensor->sensor_info->id,\n\t\tsensor->sensor_info->num_axis, readings);\n\tif (err) {\n\t\tdev_err(&iio_dev->dev,\n\t\t\t\"Error in reading raw attribute for sensor %s err %d\",\n\t\t\tsensor->sensor_info->name, err);\n\t\treturn err;\n\t}\n\n\tsensor_config = FIELD_PREP(SCMI_SENS_CFG_SENSOR_ENABLED_MASK,\n\t\t\t\t\tSCMI_SENS_CFG_SENSOR_DISABLE);\n\terr = sensor->sensor_ops->config_set(\n\t\tsensor->ph, sensor->sensor_info->id, sensor_config);\n\tif (err) {\n\t\tdev_err(&iio_dev->dev,\n\t\t\t\"Error in disabling sensor %s err %d\",\n\t\t\tsensor->sensor_info->name, err);\n\t\treturn err;\n\t}\n\n\t*val = lower_32_bits(readings[ch->scan_index].value);\n\t*val2 = upper_32_bits(readings[ch->scan_index].value);\n\n\treturn IIO_VAL_INT_64;\n}\n\nstatic int scmi_iio_read_raw(struct iio_dev *iio_dev,\n\t\t\t     struct iio_chan_spec const *ch, int *val,\n\t\t\t     int *val2, long mask)\n{\n\tstruct scmi_iio_priv *sensor = iio_priv(iio_dev);\n\ts8 scale;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tscale = sensor->sensor_info->axis[ch->scan_index].scale;\n\t\tif (scale < 0) {\n\t\t\t*val = 1;\n\t\t\t*val2 = int_pow(10, abs(scale));\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\t}\n\t\t*val = int_pow(10, scale);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = scmi_iio_get_odr_val(iio_dev, val, val2);\n\t\treturn ret ? ret : IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(iio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = scmi_iio_read_channel_data(iio_dev, ch, val, val2);\n\t\tiio_device_release_direct_mode(iio_dev);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info scmi_iio_info = {\n\t.read_raw = scmi_iio_read_raw,\n\t.read_avail = scmi_iio_read_avail,\n\t.write_raw = scmi_iio_write_raw,\n};\n\nstatic ssize_t scmi_iio_get_raw_available(struct iio_dev *iio_dev,\n\t\t\t\t\t  uintptr_t private,\n\t\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t\t  char *buf)\n{\n\tstruct scmi_iio_priv *sensor = iio_priv(iio_dev);\n\tu64 resolution, rem;\n\ts64 min_range, max_range;\n\ts8 exponent, scale;\n\tint len = 0;\n\n\t \n\tif (sensor->sensor_info->axis[0].extended_attrs) {\n\t\tmin_range = sensor->sensor_info->axis[0].attrs.min_range;\n\t\tmax_range = sensor->sensor_info->axis[0].attrs.max_range;\n\t\tresolution = sensor->sensor_info->axis[0].resolution;\n\t\texponent = sensor->sensor_info->axis[0].exponent;\n\t\tscale = sensor->sensor_info->axis[0].scale;\n\n\t\t \n\t\texponent = exponent - scale;\n\t\tif (exponent < 0) {\n\t\t\trem = do_div(resolution,\n\t\t\t\t     int_pow(10, abs(exponent))\n\t\t\t\t     );\n\t\t\tlen = sysfs_emit(buf,\n\t\t\t\t\t\"[%lld %llu.%llu %lld]\\n\", min_range,\n\t\t\t\t\tresolution, rem, max_range);\n\t\t} else {\n\t\t\tresolution = resolution * int_pow(10, exponent);\n\t\t\tlen = sysfs_emit(buf, \"[%lld %llu %lld]\\n\",\n\t\t\t\t\tmin_range, resolution, max_range);\n\t\t}\n\t}\n\treturn len;\n}\n\nstatic const struct iio_chan_spec_ext_info scmi_iio_ext_info[] = {\n\t{\n\t\t.name = \"raw_available\",\n\t\t.read = scmi_iio_get_raw_available,\n\t\t.shared = IIO_SHARED_BY_TYPE,\n\t},\n\t{},\n};\n\nstatic void scmi_iio_set_timestamp_channel(struct iio_chan_spec *iio_chan,\n\t\t\t\t\t   int scan_index)\n{\n\tiio_chan->type = IIO_TIMESTAMP;\n\tiio_chan->channel = -1;\n\tiio_chan->scan_index = scan_index;\n\tiio_chan->scan_type.sign = 'u';\n\tiio_chan->scan_type.realbits = 64;\n\tiio_chan->scan_type.storagebits = 64;\n}\n\nstatic void scmi_iio_set_data_channel(struct iio_chan_spec *iio_chan,\n\t\t\t\t      enum iio_chan_type type,\n\t\t\t\t      enum iio_modifier mod, int scan_index)\n{\n\tiio_chan->type = type;\n\tiio_chan->modified = 1;\n\tiio_chan->channel2 = mod;\n\tiio_chan->info_mask_separate =\n\t\tBIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_RAW);\n\tiio_chan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ);\n\tiio_chan->info_mask_shared_by_type_available =\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ);\n\tiio_chan->scan_index = scan_index;\n\tiio_chan->scan_type.sign = 's';\n\tiio_chan->scan_type.realbits = 64;\n\tiio_chan->scan_type.storagebits = 64;\n\tiio_chan->scan_type.endianness = IIO_LE;\n\tiio_chan->ext_info = scmi_iio_ext_info;\n}\n\nstatic int scmi_iio_get_chan_modifier(const char *name,\n\t\t\t\t      enum iio_modifier *modifier)\n{\n\tchar *pch, mod;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tpch = strrchr(name, '_');\n\tif (!pch)\n\t\treturn -EINVAL;\n\n\tmod = *(pch + 1);\n\tswitch (mod) {\n\tcase 'X':\n\t\t*modifier = IIO_MOD_X;\n\t\treturn 0;\n\tcase 'Y':\n\t\t*modifier = IIO_MOD_Y;\n\t\treturn 0;\n\tcase 'Z':\n\t\t*modifier = IIO_MOD_Z;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int scmi_iio_get_chan_type(u8 scmi_type, enum iio_chan_type *iio_type)\n{\n\tswitch (scmi_type) {\n\tcase METERS_SEC_SQUARED:\n\t\t*iio_type = IIO_ACCEL;\n\t\treturn 0;\n\tcase RADIANS_SEC:\n\t\t*iio_type = IIO_ANGL_VEL;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic u64 scmi_iio_convert_interval_to_ns(u32 val)\n{\n\tu64 sensor_update_interval =\n\t\tSCMI_SENS_INTVL_GET_SECS(val) * NSEC_PER_SEC;\n\tu64 sensor_interval_mult;\n\tint mult;\n\n\tmult = SCMI_SENS_INTVL_GET_EXP(val);\n\tif (mult < 0) {\n\t\tsensor_interval_mult = int_pow(10, abs(mult));\n\t\tdo_div(sensor_update_interval, sensor_interval_mult);\n\t} else {\n\t\tsensor_interval_mult = int_pow(10, mult);\n\t\tsensor_update_interval =\n\t\t\tsensor_update_interval * sensor_interval_mult;\n\t}\n\treturn sensor_update_interval;\n}\n\nstatic int scmi_iio_set_sampling_freq_avail(struct iio_dev *iio_dev)\n{\n\tu64 cur_interval_ns, low_interval_ns, high_interval_ns, step_size_ns,\n\t\thz, uhz;\n\tunsigned int cur_interval, low_interval, high_interval, step_size;\n\tstruct scmi_iio_priv *sensor = iio_priv(iio_dev);\n\tint i;\n\n\tsensor->freq_avail =\n\t\tdevm_kzalloc(&iio_dev->dev,\n\t\t\t     sizeof(*sensor->freq_avail) *\n\t\t\t\t     (sensor->sensor_info->intervals.count * 2),\n\t\t\t     GFP_KERNEL);\n\tif (!sensor->freq_avail)\n\t\treturn -ENOMEM;\n\n\tif (sensor->sensor_info->intervals.segmented) {\n\t\tlow_interval = sensor->sensor_info->intervals\n\t\t\t\t       .desc[SCMI_SENS_INTVL_SEGMENT_LOW];\n\t\tlow_interval_ns = scmi_iio_convert_interval_to_ns(low_interval);\n\t\tconvert_ns_to_freq(low_interval_ns, &hz, &uhz);\n\t\tsensor->freq_avail[0] = hz;\n\t\tsensor->freq_avail[1] = uhz;\n\n\t\tstep_size = sensor->sensor_info->intervals\n\t\t\t\t    .desc[SCMI_SENS_INTVL_SEGMENT_STEP];\n\t\tstep_size_ns = scmi_iio_convert_interval_to_ns(step_size);\n\t\tconvert_ns_to_freq(step_size_ns, &hz, &uhz);\n\t\tsensor->freq_avail[2] = hz;\n\t\tsensor->freq_avail[3] = uhz;\n\n\t\thigh_interval = sensor->sensor_info->intervals\n\t\t\t\t\t.desc[SCMI_SENS_INTVL_SEGMENT_HIGH];\n\t\thigh_interval_ns =\n\t\t\tscmi_iio_convert_interval_to_ns(high_interval);\n\t\tconvert_ns_to_freq(high_interval_ns, &hz, &uhz);\n\t\tsensor->freq_avail[4] = hz;\n\t\tsensor->freq_avail[5] = uhz;\n\t} else {\n\t\tfor (i = 0; i < sensor->sensor_info->intervals.count; i++) {\n\t\t\tcur_interval = sensor->sensor_info->intervals.desc[i];\n\t\t\tcur_interval_ns =\n\t\t\t\tscmi_iio_convert_interval_to_ns(cur_interval);\n\t\t\tconvert_ns_to_freq(cur_interval_ns, &hz, &uhz);\n\t\t\tsensor->freq_avail[i * 2] = hz;\n\t\t\tsensor->freq_avail[i * 2 + 1] = uhz;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct iio_dev *\nscmi_alloc_iiodev(struct scmi_device *sdev,\n\t\t  const struct scmi_sensor_proto_ops *ops,\n\t\t  struct scmi_protocol_handle *ph,\n\t\t  const struct scmi_sensor_info *sensor_info)\n{\n\tstruct iio_chan_spec *iio_channels;\n\tstruct scmi_iio_priv *sensor;\n\tenum iio_modifier modifier;\n\tenum iio_chan_type type;\n\tstruct iio_dev *iiodev;\n\tstruct device *dev = &sdev->dev;\n\tconst struct scmi_handle *handle = sdev->handle;\n\tint i, ret;\n\n\tiiodev = devm_iio_device_alloc(dev, sizeof(*sensor));\n\tif (!iiodev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiiodev->modes = INDIO_DIRECT_MODE;\n\tsensor = iio_priv(iiodev);\n\tsensor->sensor_ops = ops;\n\tsensor->ph = ph;\n\tsensor->sensor_info = sensor_info;\n\tsensor->sensor_update_nb.notifier_call = scmi_iio_sensor_update_cb;\n\tsensor->indio_dev = iiodev;\n\tmutex_init(&sensor->lock);\n\n\t \n\tiiodev->num_channels = sensor_info->num_axis + 1;\n\tiiodev->name = sensor_info->name;\n\tiiodev->info = &scmi_iio_info;\n\n\tiio_channels =\n\t\tdevm_kzalloc(dev,\n\t\t\t     sizeof(*iio_channels) * (iiodev->num_channels),\n\t\t\t     GFP_KERNEL);\n\tif (!iio_channels)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = scmi_iio_set_sampling_freq_avail(iiodev);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tfor (i = 0; i < sensor_info->num_axis; i++) {\n\t\tret = scmi_iio_get_chan_type(sensor_info->axis[i].type, &type);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\n\t\tret = scmi_iio_get_chan_modifier(sensor_info->axis[i].name,\n\t\t\t\t\t\t &modifier);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\n\t\tscmi_iio_set_data_channel(&iio_channels[i], type, modifier,\n\t\t\t\t\t  sensor_info->axis[i].id);\n\t}\n\n\tret = handle->notify_ops->devm_event_notifier_register(sdev,\n\t\t\t\tSCMI_PROTOCOL_SENSOR, SCMI_EVENT_SENSOR_UPDATE,\n\t\t\t\t&sensor->sensor_info->id,\n\t\t\t\t&sensor->sensor_update_nb);\n\tif (ret) {\n\t\tdev_err(&iiodev->dev,\n\t\t\t\"Error in registering sensor update notifier for sensor %s err %d\",\n\t\t\tsensor->sensor_info->name, ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tscmi_iio_set_timestamp_channel(&iio_channels[i], i);\n\tiiodev->channels = iio_channels;\n\treturn iiodev;\n}\n\nstatic int scmi_iio_dev_probe(struct scmi_device *sdev)\n{\n\tconst struct scmi_sensor_info *sensor_info;\n\tstruct scmi_handle *handle = sdev->handle;\n\tconst struct scmi_sensor_proto_ops *sensor_ops;\n\tstruct scmi_protocol_handle *ph;\n\tstruct device *dev = &sdev->dev;\n\tstruct iio_dev *scmi_iio_dev;\n\tu16 nr_sensors;\n\tint err = -ENODEV, i;\n\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tsensor_ops = handle->devm_protocol_get(sdev, SCMI_PROTOCOL_SENSOR, &ph);\n\tif (IS_ERR(sensor_ops)) {\n\t\tdev_err(dev, \"SCMI device has no sensor interface\\n\");\n\t\treturn PTR_ERR(sensor_ops);\n\t}\n\n\tnr_sensors = sensor_ops->count_get(ph);\n\tif (!nr_sensors) {\n\t\tdev_dbg(dev, \"0 sensors found via SCMI bus\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < nr_sensors; i++) {\n\t\tsensor_info = sensor_ops->info_get(ph, i);\n\t\tif (!sensor_info) {\n\t\t\tdev_err(dev, \"SCMI sensor %d has missing info\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (sensor_info->num_axis != SCMI_IIO_NUM_OF_AXIS)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (sensor_info->axis[0].type != METERS_SEC_SQUARED &&\n\t\t    sensor_info->axis[0].type != RADIANS_SEC)\n\t\t\tcontinue;\n\n\t\tscmi_iio_dev = scmi_alloc_iiodev(sdev, sensor_ops, ph,\n\t\t\t\t\t\t sensor_info);\n\t\tif (IS_ERR(scmi_iio_dev)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"failed to allocate IIO device for sensor %s: %ld\\n\",\n\t\t\t\tsensor_info->name, PTR_ERR(scmi_iio_dev));\n\t\t\treturn PTR_ERR(scmi_iio_dev);\n\t\t}\n\n\t\terr = devm_iio_kfifo_buffer_setup(&scmi_iio_dev->dev,\n\t\t\t\t\t\t  scmi_iio_dev,\n\t\t\t\t\t\t  &scmi_iio_buffer_ops);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"IIO buffer setup error at sensor %s: %d\\n\",\n\t\t\t\tsensor_info->name, err);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = devm_iio_device_register(dev, scmi_iio_dev);\n\t\tif (err) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"IIO device registration failed at sensor %s: %d\\n\",\n\t\t\t\tsensor_info->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic const struct scmi_device_id scmi_id_table[] = {\n\t{ SCMI_PROTOCOL_SENSOR, \"iiodev\" },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(scmi, scmi_id_table);\n\nstatic struct scmi_driver scmi_iiodev_driver = {\n\t.name = \"scmi-sensor-iiodev\",\n\t.probe = scmi_iio_dev_probe,\n\t.id_table = scmi_id_table,\n};\n\nmodule_scmi_driver(scmi_iiodev_driver);\n\nMODULE_AUTHOR(\"Jyoti Bhayana <jbhayana@google.com>\");\nMODULE_DESCRIPTION(\"SCMI IIO Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}