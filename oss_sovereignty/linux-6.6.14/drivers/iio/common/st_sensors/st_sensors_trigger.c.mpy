{
  "module_name": "st_sensors_trigger.c",
  "hash_id": "6e847f7a7f2a279cf160528abbef18480bc35dabd91dabe2766cbb10ddd9e253",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/common/st_sensors/st_sensors_trigger.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger.h>\n#include <linux/interrupt.h>\n#include <linux/regmap.h>\n#include <linux/iio/common/st_sensors.h>\n#include \"st_sensors_core.h\"\n\n \nstatic bool st_sensors_new_samples_available(struct iio_dev *indio_dev,\n\t\t\t\t\t     struct st_sensor_data *sdata)\n{\n\tint ret, status;\n\n\t \n\tif (!sdata->sensor_settings->drdy_irq.stat_drdy.addr)\n\t\treturn true;\n\n\t \n\tif (!indio_dev->active_scan_mask)\n\t\treturn false;\n\n\tret = regmap_read(sdata->regmap,\n\t\t\t  sdata->sensor_settings->drdy_irq.stat_drdy.addr,\n\t\t\t  &status);\n\tif (ret < 0) {\n\t\tdev_err(indio_dev->dev.parent,\n\t\t\t\"error checking samples available\\n\");\n\t\treturn false;\n\t}\n\n\treturn !!(status & sdata->sensor_settings->drdy_irq.stat_drdy.mask);\n}\n\n \nstatic irqreturn_t st_sensors_irq_handler(int irq, void *p)\n{\n\tstruct iio_trigger *trig = p;\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\n\t \n\tsdata->hw_timestamp = iio_get_time_ns(indio_dev);\n\treturn IRQ_WAKE_THREAD;\n}\n\n \nstatic irqreturn_t st_sensors_irq_thread(int irq, void *p)\n{\n\tstruct iio_trigger *trig = p;\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\n\t \n\tif (sdata->hw_irq_trigger &&\n\t    st_sensors_new_samples_available(indio_dev, sdata)) {\n\t\tiio_trigger_poll_nested(p);\n\t} else {\n\t\tdev_dbg(indio_dev->dev.parent, \"spurious IRQ\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (!sdata->edge_irq)\n\t\treturn IRQ_HANDLED;\n\n\t \n\twhile (sdata->hw_irq_trigger &&\n\t       st_sensors_new_samples_available(indio_dev, sdata)) {\n\t\tdev_dbg(indio_dev->dev.parent,\n\t\t\t\"more samples came in during polling\\n\");\n\t\tsdata->hw_timestamp = iio_get_time_ns(indio_dev);\n\t\tiio_trigger_poll_nested(p);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nint st_sensors_allocate_trigger(struct iio_dev *indio_dev,\n\t\t\t\tconst struct iio_trigger_ops *trigger_ops)\n{\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\tstruct device *parent = indio_dev->dev.parent;\n\tunsigned long irq_trig;\n\tint err;\n\n\tsdata->trig = devm_iio_trigger_alloc(parent, \"%s-trigger\",\n\t\t\t\t\t     indio_dev->name);\n\tif (sdata->trig == NULL) {\n\t\tdev_err(&indio_dev->dev, \"failed to allocate iio trigger.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tiio_trigger_set_drvdata(sdata->trig, indio_dev);\n\tsdata->trig->ops = trigger_ops;\n\n\tirq_trig = irqd_get_trigger_type(irq_get_irq_data(sdata->irq));\n\t \n\tswitch(irq_trig) {\n\tcase IRQF_TRIGGER_FALLING:\n\tcase IRQF_TRIGGER_LOW:\n\t\tif (!sdata->sensor_settings->drdy_irq.addr_ihl) {\n\t\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\"falling/low specified for IRQ but hardware supports only rising/high: will request rising/high\\n\");\n\t\t\tif (irq_trig == IRQF_TRIGGER_FALLING)\n\t\t\t\tirq_trig = IRQF_TRIGGER_RISING;\n\t\t\tif (irq_trig == IRQF_TRIGGER_LOW)\n\t\t\t\tirq_trig = IRQF_TRIGGER_HIGH;\n\t\t} else {\n\t\t\t \n\t\t\terr = st_sensors_write_data_with_mask(indio_dev,\n\t\t\t\tsdata->sensor_settings->drdy_irq.addr_ihl,\n\t\t\t\tsdata->sensor_settings->drdy_irq.mask_ihl, 1);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tdev_info(&indio_dev->dev,\n\t\t\t\t \"interrupts on the falling edge or active low level\\n\");\n\t\t}\n\t\tbreak;\n\tcase IRQF_TRIGGER_RISING:\n\t\tdev_info(&indio_dev->dev,\n\t\t\t \"interrupts on the rising edge\\n\");\n\t\tbreak;\n\tcase IRQF_TRIGGER_HIGH:\n\t\tdev_info(&indio_dev->dev,\n\t\t\t \"interrupts active high level\\n\");\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_err(&indio_dev->dev,\n\t\t\t\"unsupported IRQ trigger specified (%lx), enforce rising edge\\n\", irq_trig);\n\t\tirq_trig = IRQF_TRIGGER_RISING;\n\t}\n\n\t \n\tif (irq_trig == IRQF_TRIGGER_FALLING ||\n\t    irq_trig == IRQF_TRIGGER_RISING) {\n\t\tif (!sdata->sensor_settings->drdy_irq.stat_drdy.addr) {\n\t\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\"edge IRQ not supported w/o stat register.\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tsdata->edge_irq = true;\n\t} else {\n\t\t \n\t\tirq_trig |= IRQF_ONESHOT;\n\t}\n\n\t \n\tif (sdata->int_pin_open_drain &&\n\t    sdata->sensor_settings->drdy_irq.stat_drdy.addr)\n\t\tirq_trig |= IRQF_SHARED;\n\n\terr = devm_request_threaded_irq(parent,\n\t\t\t\t\tsdata->irq,\n\t\t\t\t\tst_sensors_irq_handler,\n\t\t\t\t\tst_sensors_irq_thread,\n\t\t\t\t\tirq_trig,\n\t\t\t\t\tsdata->trig->name,\n\t\t\t\t\tsdata->trig);\n\tif (err) {\n\t\tdev_err(&indio_dev->dev, \"failed to request trigger IRQ.\\n\");\n\t\treturn err;\n\t}\n\n\terr = devm_iio_trigger_register(parent, sdata->trig);\n\tif (err < 0) {\n\t\tdev_err(&indio_dev->dev, \"failed to register iio trigger.\\n\");\n\t\treturn err;\n\t}\n\tindio_dev->trig = iio_trigger_get(sdata->trig);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(st_sensors_allocate_trigger, IIO_ST_SENSORS);\n\nint st_sensors_validate_device(struct iio_trigger *trig,\n\t\t\t       struct iio_dev *indio_dev)\n{\n\tstruct iio_dev *indio = iio_trigger_get_drvdata(trig);\n\n\tif (indio != indio_dev)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(st_sensors_validate_device, IIO_ST_SENSORS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}