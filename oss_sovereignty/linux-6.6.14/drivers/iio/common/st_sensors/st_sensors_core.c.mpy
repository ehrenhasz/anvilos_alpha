{
  "module_name": "st_sensors_core.c",
  "hash_id": "1f9183c0a0516e6285ba73a3e9157d1e70fcbec73b75f51c6fbcba279d54184b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/common/st_sensors/st_sensors_core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/iio/iio.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regmap.h>\n#include <asm/unaligned.h>\n#include <linux/iio/common/st_sensors.h>\n\n#include \"st_sensors_core.h\"\n\nint st_sensors_write_data_with_mask(struct iio_dev *indio_dev,\n\t\t\t\t    u8 reg_addr, u8 mask, u8 data)\n{\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\n\treturn regmap_update_bits(sdata->regmap,\n\t\t\t\t  reg_addr, mask, data << __ffs(mask));\n}\n\nint st_sensors_debugfs_reg_access(struct iio_dev *indio_dev,\n\t\t\t\t  unsigned reg, unsigned writeval,\n\t\t\t\t  unsigned *readval)\n{\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\tint err;\n\n\tif (!readval)\n\t\treturn regmap_write(sdata->regmap, reg, writeval);\n\n\terr = regmap_read(sdata->regmap, reg, readval);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(st_sensors_debugfs_reg_access, IIO_ST_SENSORS);\n\nstatic int st_sensors_match_odr(struct st_sensor_settings *sensor_settings,\n\t\t\tunsigned int odr, struct st_sensor_odr_avl *odr_out)\n{\n\tint i, ret = -EINVAL;\n\n\tfor (i = 0; i < ST_SENSORS_ODR_LIST_MAX; i++) {\n\t\tif (sensor_settings->odr.odr_avl[i].hz == 0)\n\t\t\tgoto st_sensors_match_odr_error;\n\n\t\tif (sensor_settings->odr.odr_avl[i].hz == odr) {\n\t\t\todr_out->hz = sensor_settings->odr.odr_avl[i].hz;\n\t\t\todr_out->value = sensor_settings->odr.odr_avl[i].value;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\nst_sensors_match_odr_error:\n\treturn ret;\n}\n\nint st_sensors_set_odr(struct iio_dev *indio_dev, unsigned int odr)\n{\n\tint err = 0;\n\tstruct st_sensor_odr_avl odr_out = {0, 0};\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\n\tmutex_lock(&sdata->odr_lock);\n\n\tif (!sdata->sensor_settings->odr.mask)\n\t\tgoto unlock_mutex;\n\n\terr = st_sensors_match_odr(sdata->sensor_settings, odr, &odr_out);\n\tif (err < 0)\n\t\tgoto unlock_mutex;\n\n\tif ((sdata->sensor_settings->odr.addr ==\n\t\t\t\t\tsdata->sensor_settings->pw.addr) &&\n\t\t\t\t(sdata->sensor_settings->odr.mask ==\n\t\t\t\t\tsdata->sensor_settings->pw.mask)) {\n\t\tif (sdata->enabled == true) {\n\t\t\terr = st_sensors_write_data_with_mask(indio_dev,\n\t\t\t\tsdata->sensor_settings->odr.addr,\n\t\t\t\tsdata->sensor_settings->odr.mask,\n\t\t\t\todr_out.value);\n\t\t} else {\n\t\t\terr = 0;\n\t\t}\n\t} else {\n\t\terr = st_sensors_write_data_with_mask(indio_dev,\n\t\t\tsdata->sensor_settings->odr.addr,\n\t\t\tsdata->sensor_settings->odr.mask,\n\t\t\todr_out.value);\n\t}\n\tif (err >= 0)\n\t\tsdata->odr = odr_out.hz;\n\nunlock_mutex:\n\tmutex_unlock(&sdata->odr_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_NS(st_sensors_set_odr, IIO_ST_SENSORS);\n\nstatic int st_sensors_match_fs(struct st_sensor_settings *sensor_settings,\n\t\t\t\t\tunsigned int fs, int *index_fs_avl)\n{\n\tint i, ret = -EINVAL;\n\n\tfor (i = 0; i < ST_SENSORS_FULLSCALE_AVL_MAX; i++) {\n\t\tif (sensor_settings->fs.fs_avl[i].num == 0)\n\t\t\treturn ret;\n\n\t\tif (sensor_settings->fs.fs_avl[i].num == fs) {\n\t\t\t*index_fs_avl = i;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int st_sensors_set_fullscale(struct iio_dev *indio_dev, unsigned int fs)\n{\n\tint err, i = 0;\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\n\tif (sdata->sensor_settings->fs.addr == 0)\n\t\treturn 0;\n\n\terr = st_sensors_match_fs(sdata->sensor_settings, fs, &i);\n\tif (err < 0)\n\t\tgoto st_accel_set_fullscale_error;\n\n\terr = st_sensors_write_data_with_mask(indio_dev,\n\t\t\t\tsdata->sensor_settings->fs.addr,\n\t\t\t\tsdata->sensor_settings->fs.mask,\n\t\t\t\tsdata->sensor_settings->fs.fs_avl[i].value);\n\tif (err < 0)\n\t\tgoto st_accel_set_fullscale_error;\n\n\tsdata->current_fullscale = &sdata->sensor_settings->fs.fs_avl[i];\n\treturn err;\n\nst_accel_set_fullscale_error:\n\tdev_err(&indio_dev->dev, \"failed to set new fullscale.\\n\");\n\treturn err;\n}\n\nint st_sensors_set_enable(struct iio_dev *indio_dev, bool enable)\n{\n\tu8 tmp_value;\n\tint err = -EINVAL;\n\tbool found = false;\n\tstruct st_sensor_odr_avl odr_out = {0, 0};\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\n\tif (enable) {\n\t\ttmp_value = sdata->sensor_settings->pw.value_on;\n\t\tif ((sdata->sensor_settings->odr.addr ==\n\t\t\t\t\tsdata->sensor_settings->pw.addr) &&\n\t\t\t\t(sdata->sensor_settings->odr.mask ==\n\t\t\t\t\tsdata->sensor_settings->pw.mask)) {\n\t\t\terr = st_sensors_match_odr(sdata->sensor_settings,\n\t\t\t\t\t\t\tsdata->odr, &odr_out);\n\t\t\tif (err < 0)\n\t\t\t\tgoto set_enable_error;\n\t\t\ttmp_value = odr_out.value;\n\t\t\tfound = true;\n\t\t}\n\t\terr = st_sensors_write_data_with_mask(indio_dev,\n\t\t\t\tsdata->sensor_settings->pw.addr,\n\t\t\t\tsdata->sensor_settings->pw.mask, tmp_value);\n\t\tif (err < 0)\n\t\t\tgoto set_enable_error;\n\n\t\tsdata->enabled = true;\n\n\t\tif (found)\n\t\t\tsdata->odr = odr_out.hz;\n\t} else {\n\t\terr = st_sensors_write_data_with_mask(indio_dev,\n\t\t\t\tsdata->sensor_settings->pw.addr,\n\t\t\t\tsdata->sensor_settings->pw.mask,\n\t\t\t\tsdata->sensor_settings->pw.value_off);\n\t\tif (err < 0)\n\t\t\tgoto set_enable_error;\n\n\t\tsdata->enabled = false;\n\t}\n\nset_enable_error:\n\treturn err;\n}\nEXPORT_SYMBOL_NS(st_sensors_set_enable, IIO_ST_SENSORS);\n\nint st_sensors_set_axis_enable(struct iio_dev *indio_dev, u8 axis_enable)\n{\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\tint err = 0;\n\n\tif (sdata->sensor_settings->enable_axis.addr)\n\t\terr = st_sensors_write_data_with_mask(indio_dev,\n\t\t\t\tsdata->sensor_settings->enable_axis.addr,\n\t\t\t\tsdata->sensor_settings->enable_axis.mask,\n\t\t\t\taxis_enable);\n\treturn err;\n}\nEXPORT_SYMBOL_NS(st_sensors_set_axis_enable, IIO_ST_SENSORS);\n\n\nint st_sensors_power_enable(struct iio_dev *indio_dev)\n{\n\tstatic const char * const regulator_names[] = { \"vdd\", \"vddio\" };\n\tstruct device *parent = indio_dev->dev.parent;\n\tint err;\n\n\t \n\terr = devm_regulator_bulk_get_enable(parent,\n\t\t\t\t\t     ARRAY_SIZE(regulator_names),\n\t\t\t\t\t     regulator_names);\n\tif (err)\n\t\treturn dev_err_probe(&indio_dev->dev, err,\n\t\t\t\t     \"unable to enable supplies\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(st_sensors_power_enable, IIO_ST_SENSORS);\n\nstatic int st_sensors_set_drdy_int_pin(struct iio_dev *indio_dev,\n\t\t\t\t\tstruct st_sensors_platform_data *pdata)\n{\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\n\t \n\tif (!sdata->sensor_settings->drdy_irq.int1.addr &&\n\t    !sdata->sensor_settings->drdy_irq.int2.addr) {\n\t\tif (pdata->drdy_int_pin)\n\t\t\tdev_info(&indio_dev->dev,\n\t\t\t\t \"DRDY on pin INT%d specified, but sensor does not support interrupts\\n\",\n\t\t\t\t pdata->drdy_int_pin);\n\t\treturn 0;\n\t}\n\n\tswitch (pdata->drdy_int_pin) {\n\tcase 1:\n\t\tif (!sdata->sensor_settings->drdy_irq.int1.mask) {\n\t\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\t\"DRDY on INT1 not available.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsdata->drdy_int_pin = 1;\n\t\tbreak;\n\tcase 2:\n\t\tif (!sdata->sensor_settings->drdy_irq.int2.mask) {\n\t\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\t\"DRDY on INT2 not available.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsdata->drdy_int_pin = 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&indio_dev->dev, \"DRDY on pdata not valid.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdata->open_drain) {\n\t\tif (!sdata->sensor_settings->drdy_irq.int1.addr_od &&\n\t\t    !sdata->sensor_settings->drdy_irq.int2.addr_od)\n\t\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\"open drain requested but unsupported.\\n\");\n\t\telse\n\t\t\tsdata->int_pin_open_drain = true;\n\t}\n\n\treturn 0;\n}\n\nstatic struct st_sensors_platform_data *st_sensors_dev_probe(struct device *dev,\n\t\tstruct st_sensors_platform_data *defdata)\n{\n\tstruct st_sensors_platform_data *pdata;\n\tu32 val;\n\n\tif (!dev_fwnode(dev))\n\t\treturn NULL;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!device_property_read_u32(dev, \"st,drdy-int-pin\", &val) && (val <= 2))\n\t\tpdata->drdy_int_pin = (u8) val;\n\telse\n\t\tpdata->drdy_int_pin = defdata ? defdata->drdy_int_pin : 0;\n\n\tpdata->open_drain = device_property_read_bool(dev, \"drive-open-drain\");\n\n\treturn pdata;\n}\n\n \nvoid st_sensors_dev_name_probe(struct device *dev, char *name, int len)\n{\n\tconst void *match;\n\n\tmatch = device_get_match_data(dev);\n\tif (!match)\n\t\treturn;\n\n\t \n\tstrscpy(name, match, len);\n}\nEXPORT_SYMBOL_NS(st_sensors_dev_name_probe, IIO_ST_SENSORS);\n\nint st_sensors_init_sensor(struct iio_dev *indio_dev,\n\t\t\t\t\tstruct st_sensors_platform_data *pdata)\n{\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\tstruct st_sensors_platform_data *of_pdata;\n\tint err = 0;\n\n\tmutex_init(&sdata->odr_lock);\n\n\t \n\tof_pdata = st_sensors_dev_probe(indio_dev->dev.parent, pdata);\n\tif (IS_ERR(of_pdata))\n\t\treturn PTR_ERR(of_pdata);\n\tif (of_pdata)\n\t\tpdata = of_pdata;\n\n\tif (pdata) {\n\t\terr = st_sensors_set_drdy_int_pin(indio_dev, pdata);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = st_sensors_set_enable(indio_dev, false);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = st_sensors_set_dataready_irq(indio_dev, false);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (sdata->current_fullscale) {\n\t\terr = st_sensors_set_fullscale(indio_dev,\n\t\t\t\t\t\tsdata->current_fullscale->num);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else\n\t\tdev_info(&indio_dev->dev, \"Full-scale not possible\\n\");\n\n\terr = st_sensors_set_odr(indio_dev, sdata->odr);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (sdata->sensor_settings->bdu.addr) {\n\t\terr = st_sensors_write_data_with_mask(indio_dev,\n\t\t\t\t\tsdata->sensor_settings->bdu.addr,\n\t\t\t\t\tsdata->sensor_settings->bdu.mask, true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (sdata->sensor_settings->das.addr) {\n\t\terr = st_sensors_write_data_with_mask(indio_dev,\n\t\t\t\t\tsdata->sensor_settings->das.addr,\n\t\t\t\t\tsdata->sensor_settings->das.mask, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (sdata->int_pin_open_drain) {\n\t\tu8 addr, mask;\n\n\t\tif (sdata->drdy_int_pin == 1) {\n\t\t\taddr = sdata->sensor_settings->drdy_irq.int1.addr_od;\n\t\t\tmask = sdata->sensor_settings->drdy_irq.int1.mask_od;\n\t\t} else {\n\t\t\taddr = sdata->sensor_settings->drdy_irq.int2.addr_od;\n\t\t\tmask = sdata->sensor_settings->drdy_irq.int2.mask_od;\n\t\t}\n\n\t\tdev_info(&indio_dev->dev,\n\t\t\t \"set interrupt line to open drain mode on pin %d\\n\",\n\t\t\t sdata->drdy_int_pin);\n\t\terr = st_sensors_write_data_with_mask(indio_dev, addr,\n\t\t\t\t\t\t      mask, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = st_sensors_set_axis_enable(indio_dev, ST_SENSORS_ENABLE_ALL_AXIS);\n\n\treturn err;\n}\nEXPORT_SYMBOL_NS(st_sensors_init_sensor, IIO_ST_SENSORS);\n\nint st_sensors_set_dataready_irq(struct iio_dev *indio_dev, bool enable)\n{\n\tint err;\n\tu8 drdy_addr, drdy_mask;\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\n\tif (!sdata->sensor_settings->drdy_irq.int1.addr &&\n\t    !sdata->sensor_settings->drdy_irq.int2.addr) {\n\t\t \n\t\tif (sdata->sensor_settings->drdy_irq.stat_drdy.addr)\n\t\t\tsdata->hw_irq_trigger = enable;\n\t\treturn 0;\n\t}\n\n\t \n\tif (sdata->sensor_settings->drdy_irq.ig1.en_addr > 0) {\n\t\terr = st_sensors_write_data_with_mask(indio_dev,\n\t\t\t\tsdata->sensor_settings->drdy_irq.ig1.en_addr,\n\t\t\t\tsdata->sensor_settings->drdy_irq.ig1.en_mask,\n\t\t\t\t(int)enable);\n\t\tif (err < 0)\n\t\t\tgoto st_accel_set_dataready_irq_error;\n\t}\n\n\tif (sdata->drdy_int_pin == 1) {\n\t\tdrdy_addr = sdata->sensor_settings->drdy_irq.int1.addr;\n\t\tdrdy_mask = sdata->sensor_settings->drdy_irq.int1.mask;\n\t} else {\n\t\tdrdy_addr = sdata->sensor_settings->drdy_irq.int2.addr;\n\t\tdrdy_mask = sdata->sensor_settings->drdy_irq.int2.mask;\n\t}\n\n\t \n\tsdata->hw_irq_trigger = enable;\n\n\t \n\terr = st_sensors_write_data_with_mask(indio_dev, drdy_addr,\n\t\t\t\t\t      drdy_mask, (int)enable);\n\nst_accel_set_dataready_irq_error:\n\treturn err;\n}\nEXPORT_SYMBOL_NS(st_sensors_set_dataready_irq, IIO_ST_SENSORS);\n\nint st_sensors_set_fullscale_by_gain(struct iio_dev *indio_dev, int scale)\n{\n\tint err = -EINVAL, i;\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\n\tfor (i = 0; i < ST_SENSORS_FULLSCALE_AVL_MAX; i++) {\n\t\tif ((sdata->sensor_settings->fs.fs_avl[i].gain == scale) &&\n\t\t\t\t(sdata->sensor_settings->fs.fs_avl[i].gain != 0)) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (err < 0)\n\t\tgoto st_sensors_match_scale_error;\n\n\terr = st_sensors_set_fullscale(indio_dev,\n\t\t\t\tsdata->sensor_settings->fs.fs_avl[i].num);\n\nst_sensors_match_scale_error:\n\treturn err;\n}\nEXPORT_SYMBOL_NS(st_sensors_set_fullscale_by_gain, IIO_ST_SENSORS);\n\nstatic int st_sensors_read_axis_data(struct iio_dev *indio_dev,\n\t\t\t\t     struct iio_chan_spec const *ch, int *data)\n{\n\tint err;\n\tu8 *outdata;\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\tunsigned int byte_for_channel;\n\n\tbyte_for_channel = DIV_ROUND_UP(ch->scan_type.realbits +\n\t\t\t\t\tch->scan_type.shift, 8);\n\toutdata = kmalloc(byte_for_channel, GFP_DMA | GFP_KERNEL);\n\tif (!outdata)\n\t\treturn -ENOMEM;\n\n\terr = regmap_bulk_read(sdata->regmap, ch->address,\n\t\t\t       outdata, byte_for_channel);\n\tif (err < 0)\n\t\tgoto st_sensors_free_memory;\n\n\tif (byte_for_channel == 1)\n\t\t*data = (s8)*outdata;\n\telse if (byte_for_channel == 2)\n\t\t*data = (s16)get_unaligned_le16(outdata);\n\telse if (byte_for_channel == 3)\n\t\t*data = (s32)sign_extend32(get_unaligned_le24(outdata), 23);\n\nst_sensors_free_memory:\n\tkfree(outdata);\n\n\treturn err;\n}\n\nint st_sensors_read_info_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *ch, int *val)\n{\n\tint err;\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\n\terr = iio_device_claim_direct_mode(indio_dev);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&sdata->odr_lock);\n\n\terr = st_sensors_set_enable(indio_dev, true);\n\tif (err < 0)\n\t\tgoto out;\n\n\tmsleep((sdata->sensor_settings->bootime * 1000) / sdata->odr);\n\terr = st_sensors_read_axis_data(indio_dev, ch, val);\n\tif (err < 0)\n\t\tgoto out;\n\n\t*val = *val >> ch->scan_type.shift;\n\n\terr = st_sensors_set_enable(indio_dev, false);\n\nout:\n\tmutex_unlock(&sdata->odr_lock);\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn err;\n}\nEXPORT_SYMBOL_NS(st_sensors_read_info_raw, IIO_ST_SENSORS);\n\n \nint st_sensors_get_settings_index(const char *name,\n\t\t\t\t  const struct st_sensor_settings *list,\n\t\t\t\t  const int list_length)\n{\n\tint i, n;\n\n\tfor (i = 0; i < list_length; i++) {\n\t\tfor (n = 0; n < ST_SENSORS_MAX_4WAI; n++) {\n\t\t\tif (strcmp(name, list[i].sensors_supported[n]) == 0)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_NS(st_sensors_get_settings_index, IIO_ST_SENSORS);\n\n \nint st_sensors_verify_id(struct iio_dev *indio_dev)\n{\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\tint wai, err;\n\n\tif (sdata->sensor_settings->wai_addr) {\n\t\terr = regmap_read(sdata->regmap,\n\t\t\t\t  sdata->sensor_settings->wai_addr, &wai);\n\t\tif (err < 0) {\n\t\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\"failed to read Who-Am-I register.\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tif (sdata->sensor_settings->wai != wai) {\n\t\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\"%s: WhoAmI mismatch (0x%x).\\n\",\n\t\t\t\tindio_dev->name, wai);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(st_sensors_verify_id, IIO_ST_SENSORS);\n\nssize_t st_sensors_sysfs_sampling_frequency_avail(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint i, len = 0;\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\n\tfor (i = 0; i < ST_SENSORS_ODR_LIST_MAX; i++) {\n\t\tif (sdata->sensor_settings->odr.odr_avl[i].hz == 0)\n\t\t\tbreak;\n\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d \",\n\t\t\t\tsdata->sensor_settings->odr.odr_avl[i].hz);\n\t}\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\nEXPORT_SYMBOL_NS(st_sensors_sysfs_sampling_frequency_avail, IIO_ST_SENSORS);\n\nssize_t st_sensors_sysfs_scale_avail(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint i, len = 0, q, r;\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct st_sensor_data *sdata = iio_priv(indio_dev);\n\n\tfor (i = 0; i < ST_SENSORS_FULLSCALE_AVL_MAX; i++) {\n\t\tif (sdata->sensor_settings->fs.fs_avl[i].num == 0)\n\t\t\tbreak;\n\n\t\tq = sdata->sensor_settings->fs.fs_avl[i].gain / 1000000;\n\t\tr = sdata->sensor_settings->fs.fs_avl[i].gain % 1000000;\n\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%u.%06u \", q, r);\n\t}\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\nEXPORT_SYMBOL_NS(st_sensors_sysfs_scale_avail, IIO_ST_SENSORS);\n\nMODULE_AUTHOR(\"Denis Ciocca <denis.ciocca@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics ST-sensors core\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}