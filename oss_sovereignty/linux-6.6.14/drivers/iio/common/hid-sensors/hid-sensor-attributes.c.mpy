{
  "module_name": "hid-sensor-attributes.c",
  "hash_id": "a0055fcec8a74397973a421e4608b3f3afd4b7acfc981a372c77c0b9d3c0b442",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/common/hid-sensors/hid-sensor-attributes.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/units.h>\n\n#include <linux/hid-sensor-hub.h>\n#include <linux/iio/iio.h>\n\nstatic struct {\n\tu32 usage_id;\n\tint unit;  \n\tint scale_val0;  \n\tint scale_val1;  \n} unit_conversion[] = {\n\t{HID_USAGE_SENSOR_ACCEL_3D, 0, 9, 806650000},\n\t{HID_USAGE_SENSOR_ACCEL_3D,\n\t\tHID_USAGE_SENSOR_UNITS_METERS_PER_SEC_SQRD, 1, 0},\n\t{HID_USAGE_SENSOR_ACCEL_3D,\n\t\tHID_USAGE_SENSOR_UNITS_G, 9, 806650000},\n\n\t{HID_USAGE_SENSOR_GRAVITY_VECTOR, 0, 9, 806650000},\n\t{HID_USAGE_SENSOR_GRAVITY_VECTOR,\n\t\tHID_USAGE_SENSOR_UNITS_METERS_PER_SEC_SQRD, 1, 0},\n\t{HID_USAGE_SENSOR_GRAVITY_VECTOR,\n\t\tHID_USAGE_SENSOR_UNITS_G, 9, 806650000},\n\n\t{HID_USAGE_SENSOR_GYRO_3D, 0, 0, 17453293},\n\t{HID_USAGE_SENSOR_GYRO_3D,\n\t\tHID_USAGE_SENSOR_UNITS_RADIANS_PER_SECOND, 1, 0},\n\t{HID_USAGE_SENSOR_GYRO_3D,\n\t\tHID_USAGE_SENSOR_UNITS_DEGREES_PER_SECOND, 0, 17453293},\n\n\t{HID_USAGE_SENSOR_COMPASS_3D, 0, 0, 1000000},\n\t{HID_USAGE_SENSOR_COMPASS_3D, HID_USAGE_SENSOR_UNITS_GAUSS, 1, 0},\n\n\t{HID_USAGE_SENSOR_INCLINOMETER_3D, 0, 0, 17453293},\n\t{HID_USAGE_SENSOR_INCLINOMETER_3D,\n\t\tHID_USAGE_SENSOR_UNITS_DEGREES, 0, 17453293},\n\t{HID_USAGE_SENSOR_INCLINOMETER_3D,\n\t\tHID_USAGE_SENSOR_UNITS_RADIANS, 1, 0},\n\n\t{HID_USAGE_SENSOR_ALS, 0, 1, 0},\n\t{HID_USAGE_SENSOR_ALS, HID_USAGE_SENSOR_UNITS_LUX, 1, 0},\n\n\t{HID_USAGE_SENSOR_PRESSURE, 0, 100, 0},\n\t{HID_USAGE_SENSOR_PRESSURE, HID_USAGE_SENSOR_UNITS_PASCAL, 0, 1000000},\n\n\t{HID_USAGE_SENSOR_TIME_TIMESTAMP, 0, 1000000000, 0},\n\t{HID_USAGE_SENSOR_TIME_TIMESTAMP, HID_USAGE_SENSOR_UNITS_MILLISECOND,\n\t\t1000000, 0},\n\n\t{HID_USAGE_SENSOR_DEVICE_ORIENTATION, 0, 1, 0},\n\n\t{HID_USAGE_SENSOR_RELATIVE_ORIENTATION, 0, 1, 0},\n\n\t{HID_USAGE_SENSOR_GEOMAGNETIC_ORIENTATION, 0, 1, 0},\n\n\t{HID_USAGE_SENSOR_TEMPERATURE, 0, 1000, 0},\n\t{HID_USAGE_SENSOR_TEMPERATURE, HID_USAGE_SENSOR_UNITS_DEGREES, 1000, 0},\n\n\t{HID_USAGE_SENSOR_HUMIDITY, 0, 1000, 0},\n\t{HID_USAGE_SENSOR_HINGE, 0, 0, 17453293},\n\t{HID_USAGE_SENSOR_HINGE, HID_USAGE_SENSOR_UNITS_DEGREES, 0, 17453293},\n};\n\nstatic void simple_div(int dividend, int divisor, int *whole,\n\t\t\t\tint *micro_frac)\n{\n\tint rem;\n\tint exp = 0;\n\n\t*micro_frac = 0;\n\tif (divisor == 0) {\n\t\t*whole = 0;\n\t\treturn;\n\t}\n\t*whole = dividend/divisor;\n\trem = dividend % divisor;\n\tif (rem) {\n\t\twhile (rem <= divisor) {\n\t\t\trem *= 10;\n\t\t\texp++;\n\t\t}\n\t\t*micro_frac = (rem / divisor) * int_pow(10, 6 - exp);\n\t}\n}\n\nstatic void split_micro_fraction(unsigned int no, int exp, int *val1, int *val2)\n{\n\tint divisor = int_pow(10, exp);\n\n\t*val1 = no / divisor;\n\t*val2 = no % divisor * int_pow(10, 6 - exp);\n}\n\n \nstatic void convert_from_vtf_format(u32 value, int size, int exp,\n\t\t\t\t\tint *val1, int *val2)\n{\n\tint sign = 1;\n\n\tif (value & BIT(size*8 - 1)) {\n\t\tvalue =  ((1LL << (size * 8)) - value);\n\t\tsign = -1;\n\t}\n\texp = hid_sensor_convert_exponent(exp);\n\tif (exp >= 0) {\n\t\t*val1 = sign * value * int_pow(10, exp);\n\t\t*val2 = 0;\n\t} else {\n\t\tsplit_micro_fraction(value, -exp, val1, val2);\n\t\tif (*val1)\n\t\t\t*val1 = sign * (*val1);\n\t\telse\n\t\t\t*val2 = sign * (*val2);\n\t}\n}\n\nstatic u32 convert_to_vtf_format(int size, int exp, int val1, int val2)\n{\n\tint divisor;\n\tu32 value;\n\tint sign = 1;\n\n\tif (val1 < 0 || val2 < 0)\n\t\tsign = -1;\n\texp = hid_sensor_convert_exponent(exp);\n\tif (exp < 0) {\n\t\tdivisor = int_pow(10, 6 + exp);\n\t\tvalue = abs(val1) * int_pow(10, -exp);\n\t\tvalue += abs(val2) / divisor;\n\t} else {\n\t\tdivisor = int_pow(10, exp);\n\t\tvalue = abs(val1) / divisor;\n\t}\n\tif (sign < 0)\n\t\tvalue =  ((1LL << (size * 8)) - value);\n\n\treturn value;\n}\n\ns32 hid_sensor_read_poll_value(struct hid_sensor_common *st)\n{\n\ts32 value = 0;\n\tint ret;\n\n\tret = sensor_hub_get_feature(st->hsdev,\n\t\t\t\t     st->poll.report_id,\n\t\t\t\t     st->poll.index, sizeof(value), &value);\n\n\tif (ret < 0 || value < 0) {\n\t\treturn -EINVAL;\n\t} else {\n\t\tif (st->poll.units == HID_USAGE_SENSOR_UNITS_SECOND)\n\t\t\tvalue = value * 1000;\n\t}\n\n\treturn value;\n}\nEXPORT_SYMBOL_NS(hid_sensor_read_poll_value, IIO_HID_ATTRIBUTES);\n\nint hid_sensor_read_samp_freq_value(struct hid_sensor_common *st,\n\t\t\t\tint *val1, int *val2)\n{\n\ts32 value;\n\tint ret;\n\n\tret = sensor_hub_get_feature(st->hsdev,\n\t\t\t\t     st->poll.report_id,\n\t\t\t\t     st->poll.index, sizeof(value), &value);\n\tif (ret < 0 || value < 0) {\n\t\t*val1 = *val2 = 0;\n\t\treturn -EINVAL;\n\t} else {\n\t\tif (st->poll.units == HID_USAGE_SENSOR_UNITS_MILLISECOND)\n\t\t\tsimple_div(1000, value, val1, val2);\n\t\telse if (st->poll.units == HID_USAGE_SENSOR_UNITS_SECOND)\n\t\t\tsimple_div(1, value, val1, val2);\n\t\telse {\n\t\t\t*val1 = *val2 = 0;\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\nEXPORT_SYMBOL_NS(hid_sensor_read_samp_freq_value, IIO_HID);\n\nint hid_sensor_write_samp_freq_value(struct hid_sensor_common *st,\n\t\t\t\tint val1, int val2)\n{\n\ts32 value;\n\tint ret;\n\n\tif (val1 < 0 || val2 < 0)\n\t\treturn -EINVAL;\n\n\tvalue = val1 * HZ_PER_MHZ + val2;\n\tif (value) {\n\t\tif (st->poll.units == HID_USAGE_SENSOR_UNITS_MILLISECOND)\n\t\t\tvalue = NSEC_PER_SEC / value;\n\t\telse if (st->poll.units == HID_USAGE_SENSOR_UNITS_SECOND)\n\t\t\tvalue = USEC_PER_SEC / value;\n\t\telse\n\t\t\tvalue = 0;\n\t}\n\tret = sensor_hub_set_feature(st->hsdev, st->poll.report_id,\n\t\t\t\t     st->poll.index, sizeof(value), &value);\n\tif (ret < 0 || value < 0)\n\t\treturn -EINVAL;\n\n\tret = sensor_hub_get_feature(st->hsdev,\n\t\t\t\t     st->poll.report_id,\n\t\t\t\t     st->poll.index, sizeof(value), &value);\n\tif (ret < 0 || value < 0)\n\t\treturn -EINVAL;\n\n\tst->poll_interval = value;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(hid_sensor_write_samp_freq_value, IIO_HID);\n\nint hid_sensor_read_raw_hyst_value(struct hid_sensor_common *st,\n\t\t\t\tint *val1, int *val2)\n{\n\ts32 value;\n\tint ret;\n\n\tret = sensor_hub_get_feature(st->hsdev,\n\t\t\t\t     st->sensitivity.report_id,\n\t\t\t\t     st->sensitivity.index, sizeof(value),\n\t\t\t\t     &value);\n\tif (ret < 0 || value < 0) {\n\t\t*val1 = *val2 = 0;\n\t\treturn -EINVAL;\n\t} else {\n\t\tconvert_from_vtf_format(value, st->sensitivity.size,\n\t\t\t\t\tst->sensitivity.unit_expo,\n\t\t\t\t\tval1, val2);\n\t}\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\nEXPORT_SYMBOL_NS(hid_sensor_read_raw_hyst_value, IIO_HID);\n\nint hid_sensor_read_raw_hyst_rel_value(struct hid_sensor_common *st, int *val1,\n\t\t\t\t       int *val2)\n{\n\ts32 value;\n\tint ret;\n\n\tret = sensor_hub_get_feature(st->hsdev,\n\t\t\t\t     st->sensitivity_rel.report_id,\n\t\t\t\t     st->sensitivity_rel.index, sizeof(value),\n\t\t\t\t     &value);\n\tif (ret < 0 || value < 0) {\n\t\t*val1 = *val2 = 0;\n\t\treturn -EINVAL;\n\t}\n\n\tconvert_from_vtf_format(value, st->sensitivity_rel.size,\n\t\t\t\tst->sensitivity_rel.unit_expo, val1, val2);\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\nEXPORT_SYMBOL_NS(hid_sensor_read_raw_hyst_rel_value, IIO_HID);\n\n\nint hid_sensor_write_raw_hyst_value(struct hid_sensor_common *st,\n\t\t\t\t\tint val1, int val2)\n{\n\ts32 value;\n\tint ret;\n\n\tif (val1 < 0 || val2 < 0)\n\t\treturn -EINVAL;\n\n\tvalue = convert_to_vtf_format(st->sensitivity.size,\n\t\t\t\tst->sensitivity.unit_expo,\n\t\t\t\tval1, val2);\n\tret = sensor_hub_set_feature(st->hsdev, st->sensitivity.report_id,\n\t\t\t\t     st->sensitivity.index, sizeof(value),\n\t\t\t\t     &value);\n\tif (ret < 0 || value < 0)\n\t\treturn -EINVAL;\n\n\tret = sensor_hub_get_feature(st->hsdev,\n\t\t\t\t     st->sensitivity.report_id,\n\t\t\t\t     st->sensitivity.index, sizeof(value),\n\t\t\t\t     &value);\n\tif (ret < 0 || value < 0)\n\t\treturn -EINVAL;\n\n\tst->raw_hystersis = value;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(hid_sensor_write_raw_hyst_value, IIO_HID);\n\nint hid_sensor_write_raw_hyst_rel_value(struct hid_sensor_common *st,\n\t\t\t\t\tint val1, int val2)\n{\n\ts32 value;\n\tint ret;\n\n\tif (val1 < 0 || val2 < 0)\n\t\treturn -EINVAL;\n\n\tvalue = convert_to_vtf_format(st->sensitivity_rel.size,\n\t\t\t\tst->sensitivity_rel.unit_expo,\n\t\t\t\tval1, val2);\n\tret = sensor_hub_set_feature(st->hsdev, st->sensitivity_rel.report_id,\n\t\t\t\t     st->sensitivity_rel.index, sizeof(value),\n\t\t\t\t     &value);\n\tif (ret < 0 || value < 0)\n\t\treturn -EINVAL;\n\n\tret = sensor_hub_get_feature(st->hsdev,\n\t\t\t\t     st->sensitivity_rel.report_id,\n\t\t\t\t     st->sensitivity_rel.index, sizeof(value),\n\t\t\t\t     &value);\n\tif (ret < 0 || value < 0)\n\t\treturn -EINVAL;\n\n\tst->raw_hystersis = value;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(hid_sensor_write_raw_hyst_rel_value, IIO_HID);\n\n \nstatic void adjust_exponent_nano(int *val0, int *val1, int scale0,\n\t\t\t\t  int scale1, int exp)\n{\n\tint divisor;\n\tint i;\n\tint x;\n\tint res;\n\tint rem;\n\n\tif (exp > 0) {\n\t\t*val0 = scale0 * int_pow(10, exp);\n\t\tres = 0;\n\t\tif (exp > 9) {\n\t\t\t*val1 = 0;\n\t\t\treturn;\n\t\t}\n\t\tfor (i = 0; i < exp; ++i) {\n\t\t\tdivisor = int_pow(10, 8 - i);\n\t\t\tx = scale1 / divisor;\n\t\t\tres += int_pow(10, exp - 1 - i) * x;\n\t\t\tscale1 = scale1 % divisor;\n\t\t}\n\t\t*val0 += res;\n\t\t*val1 = scale1 * int_pow(10, exp);\n\t} else if (exp < 0) {\n\t\texp = abs(exp);\n\t\tif (exp > 9) {\n\t\t\t*val0 = *val1 = 0;\n\t\t\treturn;\n\t\t}\n\t\tdivisor = int_pow(10, exp);\n\t\t*val0 = scale0 / divisor;\n\t\trem = scale0 % divisor;\n\t\tres = 0;\n\t\tfor (i = 0; i < (9 - exp); ++i) {\n\t\t\tdivisor = int_pow(10, 8 - i);\n\t\t\tx = scale1 / divisor;\n\t\t\tres += int_pow(10, 8 - exp - i) * x;\n\t\t\tscale1 = scale1 % divisor;\n\t\t}\n\t\t*val1 = rem * int_pow(10, 9 - exp) + res;\n\t} else {\n\t\t*val0 = scale0;\n\t\t*val1 = scale1;\n\t}\n}\n\nint hid_sensor_format_scale(u32 usage_id,\n\t\t\tstruct hid_sensor_hub_attribute_info *attr_info,\n\t\t\tint *val0, int *val1)\n{\n\tint i;\n\tint exp;\n\n\t*val0 = 1;\n\t*val1 = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(unit_conversion); ++i) {\n\t\tif (unit_conversion[i].usage_id == usage_id &&\n\t\t\tunit_conversion[i].unit == attr_info->units) {\n\t\t\texp  = hid_sensor_convert_exponent(\n\t\t\t\t\t\tattr_info->unit_expo);\n\t\t\tadjust_exponent_nano(val0, val1,\n\t\t\t\t\tunit_conversion[i].scale_val0,\n\t\t\t\t\tunit_conversion[i].scale_val1, exp);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn IIO_VAL_INT_PLUS_NANO;\n}\nEXPORT_SYMBOL_NS(hid_sensor_format_scale, IIO_HID);\n\nint64_t hid_sensor_convert_timestamp(struct hid_sensor_common *st,\n\t\t\t\t     int64_t raw_value)\n{\n\treturn st->timestamp_ns_scale * raw_value;\n}\nEXPORT_SYMBOL_NS(hid_sensor_convert_timestamp, IIO_HID);\n\nstatic\nint hid_sensor_get_reporting_interval(struct hid_sensor_hub_device *hsdev,\n\t\t\t\t\tu32 usage_id,\n\t\t\t\t\tstruct hid_sensor_common *st)\n{\n\tsensor_hub_input_get_attribute_info(hsdev,\n\t\t\t\t\tHID_FEATURE_REPORT, usage_id,\n\t\t\t\t\tHID_USAGE_SENSOR_PROP_REPORT_INTERVAL,\n\t\t\t\t\t&st->poll);\n\t \n\tif (st->poll.units == 0)\n\t\tst->poll.units = HID_USAGE_SENSOR_UNITS_MILLISECOND;\n\n\tst->poll_interval = -1;\n\n\treturn 0;\n\n}\n\nstatic void hid_sensor_get_report_latency_info(struct hid_sensor_hub_device *hsdev,\n\t\t\t\t\t       u32 usage_id,\n\t\t\t\t\t       struct hid_sensor_common *st)\n{\n\tsensor_hub_input_get_attribute_info(hsdev, HID_FEATURE_REPORT,\n\t\t\t\t\t    usage_id,\n\t\t\t\t\t    HID_USAGE_SENSOR_PROP_REPORT_LATENCY,\n\t\t\t\t\t    &st->report_latency);\n\n\thid_dbg(hsdev->hdev, \"Report latency attributes: %x:%x\\n\",\n\t\tst->report_latency.index, st->report_latency.report_id);\n}\n\nint hid_sensor_get_report_latency(struct hid_sensor_common *st)\n{\n\tint ret;\n\tint value;\n\n\tret = sensor_hub_get_feature(st->hsdev, st->report_latency.report_id,\n\t\t\t\t     st->report_latency.index, sizeof(value),\n\t\t\t\t     &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn value;\n}\nEXPORT_SYMBOL_NS(hid_sensor_get_report_latency, IIO_HID_ATTRIBUTES);\n\nint hid_sensor_set_report_latency(struct hid_sensor_common *st, int latency_ms)\n{\n\treturn sensor_hub_set_feature(st->hsdev, st->report_latency.report_id,\n\t\t\t\t      st->report_latency.index,\n\t\t\t\t      sizeof(latency_ms), &latency_ms);\n}\nEXPORT_SYMBOL_NS(hid_sensor_set_report_latency, IIO_HID_ATTRIBUTES);\n\nbool hid_sensor_batch_mode_supported(struct hid_sensor_common *st)\n{\n\treturn st->report_latency.index > 0 && st->report_latency.report_id > 0;\n}\nEXPORT_SYMBOL_NS(hid_sensor_batch_mode_supported, IIO_HID_ATTRIBUTES);\n\nint hid_sensor_parse_common_attributes(struct hid_sensor_hub_device *hsdev,\n\t\t\t\t\tu32 usage_id,\n\t\t\t\t\tstruct hid_sensor_common *st,\n\t\t\t\t\tconst u32 *sensitivity_addresses,\n\t\t\t\t\tu32 sensitivity_addresses_len)\n{\n\n\tstruct hid_sensor_hub_attribute_info timestamp;\n\ts32 value;\n\tint ret;\n\tint i;\n\n\thid_sensor_get_reporting_interval(hsdev, usage_id, st);\n\n\tsensor_hub_input_get_attribute_info(hsdev,\n\t\t\t\t\tHID_FEATURE_REPORT, usage_id,\n\t\t\t\t\tHID_USAGE_SENSOR_PROP_REPORT_STATE,\n\t\t\t\t\t&st->report_state);\n\n\tsensor_hub_input_get_attribute_info(hsdev,\n\t\t\t\t\tHID_FEATURE_REPORT, usage_id,\n\t\t\t\t\tHID_USAGE_SENSOR_PROY_POWER_STATE,\n\t\t\t\t\t&st->power_state);\n\n\tst->power_state.logical_minimum = 1;\n\tst->report_state.logical_minimum = 1;\n\n\tsensor_hub_input_get_attribute_info(hsdev,\n\t\t\tHID_FEATURE_REPORT, usage_id,\n\t\t\tHID_USAGE_SENSOR_PROP_SENSITIVITY_ABS,\n\t\t\t &st->sensitivity);\n\n\tsensor_hub_input_get_attribute_info(hsdev,\n\t\t\tHID_FEATURE_REPORT, usage_id,\n\t\t\tHID_USAGE_SENSOR_PROP_SENSITIVITY_REL_PCT,\n\t\t\t&st->sensitivity_rel);\n\t \n\tfor (i = 0; i < sensitivity_addresses_len; i++) {\n\t\tif (st->sensitivity.index < 0)\n\t\t\tsensor_hub_input_get_attribute_info(\n\t\t\t\thsdev, HID_FEATURE_REPORT, usage_id,\n\t\t\t\tHID_USAGE_SENSOR_DATA_MOD_CHANGE_SENSITIVITY_ABS |\n\t\t\t\t\tsensitivity_addresses[i],\n\t\t\t\t&st->sensitivity);\n\n\t\tif (st->sensitivity_rel.index < 0)\n\t\t\tsensor_hub_input_get_attribute_info(\n\t\t\t\thsdev, HID_FEATURE_REPORT, usage_id,\n\t\t\t\tHID_USAGE_SENSOR_DATA_MOD_CHANGE_SENSITIVITY_REL_PCT |\n\t\t\t\t\tsensitivity_addresses[i],\n\t\t\t\t&st->sensitivity_rel);\n\t}\n\n\tst->raw_hystersis = -1;\n\n\tsensor_hub_input_get_attribute_info(hsdev,\n\t\t\t\t\t    HID_INPUT_REPORT, usage_id,\n\t\t\t\t\t    HID_USAGE_SENSOR_TIME_TIMESTAMP,\n\t\t\t\t\t    &timestamp);\n\tif (timestamp.index >= 0 && timestamp.report_id) {\n\t\tint val0, val1;\n\n\t\thid_sensor_format_scale(HID_USAGE_SENSOR_TIME_TIMESTAMP,\n\t\t\t\t\t&timestamp, &val0, &val1);\n\t\tst->timestamp_ns_scale = val0;\n\t} else\n\t\tst->timestamp_ns_scale = 1000000000;\n\n\thid_sensor_get_report_latency_info(hsdev, usage_id, st);\n\n\thid_dbg(hsdev->hdev, \"common attributes: %x:%x, %x:%x, %x:%x %x:%x %x:%x\\n\",\n\t\tst->poll.index, st->poll.report_id,\n\t\tst->report_state.index, st->report_state.report_id,\n\t\tst->power_state.index, st->power_state.report_id,\n\t\tst->sensitivity.index, st->sensitivity.report_id,\n\t\ttimestamp.index, timestamp.report_id);\n\n\tret = sensor_hub_get_feature(hsdev,\n\t\t\t\tst->power_state.report_id,\n\t\t\t\tst->power_state.index, sizeof(value), &value);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (value < 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(hid_sensor_parse_common_attributes, IIO_HID);\n\nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@intel.com>\");\nMODULE_DESCRIPTION(\"HID Sensor common attribute processing\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}