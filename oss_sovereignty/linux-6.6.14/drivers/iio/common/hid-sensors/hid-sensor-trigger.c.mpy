{
  "module_name": "hid-sensor-trigger.c",
  "hash_id": "872f7021db38d84c9f8578eddedfe82e5493026df9d0b916a5032b9c64916320",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/common/hid-sensors/hid-sensor-trigger.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/hid-sensor-hub.h>\n#include <linux/workqueue.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/sysfs.h>\n#include \"hid-sensor-trigger.h\"\n\nstatic ssize_t _hid_sensor_set_report_latency(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);\n\tint integer, fract, ret;\n\tint latency;\n\n\tret = iio_str_to_fixpoint(buf, 100000, &integer, &fract);\n\tif (ret)\n\t\treturn ret;\n\n\tlatency = integer * 1000 + fract / 1000;\n\tret = hid_sensor_set_report_latency(attrb, latency);\n\tif (ret < 0)\n\t\treturn len;\n\n\tattrb->latency_ms = hid_sensor_get_report_latency(attrb);\n\n\treturn len;\n}\n\nstatic ssize_t _hid_sensor_get_report_latency(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);\n\tint latency;\n\n\tlatency = hid_sensor_get_report_latency(attrb);\n\tif (latency < 0)\n\t\treturn latency;\n\n\treturn sprintf(buf, \"%d.%06u\\n\", latency / 1000, (latency % 1000) * 1000);\n}\n\nstatic ssize_t _hid_sensor_get_fifo_state(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);\n\tint latency;\n\n\tlatency = hid_sensor_get_report_latency(attrb);\n\tif (latency < 0)\n\t\treturn latency;\n\n\treturn sprintf(buf, \"%d\\n\", !!latency);\n}\n\nstatic IIO_DEVICE_ATTR(hwfifo_timeout, 0644,\n\t\t       _hid_sensor_get_report_latency,\n\t\t       _hid_sensor_set_report_latency, 0);\nstatic IIO_DEVICE_ATTR(hwfifo_enabled, 0444,\n\t\t       _hid_sensor_get_fifo_state, NULL, 0);\n\nstatic const struct iio_dev_attr *hid_sensor_fifo_attributes[] = {\n\t&iio_dev_attr_hwfifo_timeout,\n\t&iio_dev_attr_hwfifo_enabled,\n\tNULL,\n};\n\nstatic int _hid_sensor_power_state(struct hid_sensor_common *st, bool state)\n{\n\tint state_val;\n\tint report_val;\n\ts32 poll_value = 0;\n\n\tif (state) {\n\t\tif (sensor_hub_device_open(st->hsdev))\n\t\t\treturn -EIO;\n\n\t\tatomic_inc(&st->data_ready);\n\n\t\tstate_val = hid_sensor_get_usage_index(st->hsdev,\n\t\t\tst->power_state.report_id,\n\t\t\tst->power_state.index,\n\t\t\tHID_USAGE_SENSOR_PROP_POWER_STATE_D0_FULL_POWER_ENUM);\n\t\treport_val = hid_sensor_get_usage_index(st->hsdev,\n\t\t\tst->report_state.report_id,\n\t\t\tst->report_state.index,\n\t\t\tHID_USAGE_SENSOR_PROP_REPORTING_STATE_ALL_EVENTS_ENUM);\n\n\t\tpoll_value = hid_sensor_read_poll_value(st);\n\t} else {\n\t\tint val;\n\n\t\tval = atomic_dec_if_positive(&st->data_ready);\n\t\tif (val < 0)\n\t\t\treturn 0;\n\n\t\tsensor_hub_device_close(st->hsdev);\n\t\tstate_val = hid_sensor_get_usage_index(st->hsdev,\n\t\t\tst->power_state.report_id,\n\t\t\tst->power_state.index,\n\t\t\tHID_USAGE_SENSOR_PROP_POWER_STATE_D4_POWER_OFF_ENUM);\n\t\treport_val = hid_sensor_get_usage_index(st->hsdev,\n\t\t\tst->report_state.report_id,\n\t\t\tst->report_state.index,\n\t\t\tHID_USAGE_SENSOR_PROP_REPORTING_STATE_NO_EVENTS_ENUM);\n\t}\n\n\tif (state_val >= 0) {\n\t\tstate_val += st->power_state.logical_minimum;\n\t\tsensor_hub_set_feature(st->hsdev, st->power_state.report_id,\n\t\t\t\t       st->power_state.index, sizeof(state_val),\n\t\t\t\t       &state_val);\n\t}\n\n\tif (report_val >= 0) {\n\t\treport_val += st->report_state.logical_minimum;\n\t\tsensor_hub_set_feature(st->hsdev, st->report_state.report_id,\n\t\t\t\t       st->report_state.index,\n\t\t\t\t       sizeof(report_val),\n\t\t\t\t       &report_val);\n\t}\n\n\tpr_debug(\"HID_SENSOR %s set power_state %d report_state %d\\n\",\n\t\t st->pdev->name, state_val, report_val);\n\n\tsensor_hub_get_feature(st->hsdev, st->power_state.report_id,\n\t\t\t       st->power_state.index,\n\t\t\t       sizeof(state_val), &state_val);\n\tif (state && poll_value)\n\t\tmsleep_interruptible(poll_value * 2);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(hid_sensor_power_state, IIO_HID);\n\nint hid_sensor_power_state(struct hid_sensor_common *st, bool state)\n{\n\n#ifdef CONFIG_PM\n\tint ret;\n\n\tif (atomic_add_unless(&st->runtime_pm_enable, 1, 1))\n\t\tpm_runtime_enable(&st->pdev->dev);\n\n\tif (state) {\n\t\tatomic_inc(&st->user_requested_state);\n\t\tret = pm_runtime_resume_and_get(&st->pdev->dev);\n\t} else {\n\t\tatomic_dec(&st->user_requested_state);\n\t\tpm_runtime_mark_last_busy(&st->pdev->dev);\n\t\tpm_runtime_use_autosuspend(&st->pdev->dev);\n\t\tret = pm_runtime_put_autosuspend(&st->pdev->dev);\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n#else\n\tatomic_set(&st->user_requested_state, state);\n\treturn _hid_sensor_power_state(st, state);\n#endif\n}\n\nstatic void hid_sensor_set_power_work(struct work_struct *work)\n{\n\tstruct hid_sensor_common *attrb = container_of(work,\n\t\t\t\t\t\t       struct hid_sensor_common,\n\t\t\t\t\t\t       work);\n\n\tif (attrb->poll_interval >= 0)\n\t\tsensor_hub_set_feature(attrb->hsdev, attrb->poll.report_id,\n\t\t\t\t       attrb->poll.index,\n\t\t\t\t       sizeof(attrb->poll_interval),\n\t\t\t\t       &attrb->poll_interval);\n\n\tif (attrb->raw_hystersis >= 0)\n\t\tsensor_hub_set_feature(attrb->hsdev,\n\t\t\t\t       attrb->sensitivity.report_id,\n\t\t\t\t       attrb->sensitivity.index,\n\t\t\t\t       sizeof(attrb->raw_hystersis),\n\t\t\t\t       &attrb->raw_hystersis);\n\n\tif (attrb->latency_ms > 0)\n\t\thid_sensor_set_report_latency(attrb, attrb->latency_ms);\n\n\tif (atomic_read(&attrb->user_requested_state))\n\t\t_hid_sensor_power_state(attrb, true);\n}\n\nstatic int hid_sensor_data_rdy_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t\tbool state)\n{\n\treturn hid_sensor_power_state(iio_trigger_get_drvdata(trig), state);\n}\n\nvoid hid_sensor_remove_trigger(struct iio_dev *indio_dev,\n\t\t\t       struct hid_sensor_common *attrb)\n{\n\tif (atomic_read(&attrb->runtime_pm_enable))\n\t\tpm_runtime_disable(&attrb->pdev->dev);\n\n\tpm_runtime_set_suspended(&attrb->pdev->dev);\n\n\tcancel_work_sync(&attrb->work);\n\tiio_trigger_unregister(attrb->trigger);\n\tiio_trigger_free(attrb->trigger);\n\tiio_triggered_buffer_cleanup(indio_dev);\n}\nEXPORT_SYMBOL_NS(hid_sensor_remove_trigger, IIO_HID);\n\nstatic const struct iio_trigger_ops hid_sensor_trigger_ops = {\n\t.set_trigger_state = &hid_sensor_data_rdy_trigger_set_state,\n};\n\nint hid_sensor_setup_trigger(struct iio_dev *indio_dev, const char *name,\n\t\t\t\tstruct hid_sensor_common *attrb)\n{\n\tconst struct iio_dev_attr **fifo_attrs;\n\tint ret;\n\tstruct iio_trigger *trig;\n\n\tif (hid_sensor_batch_mode_supported(attrb))\n\t\tfifo_attrs = hid_sensor_fifo_attributes;\n\telse\n\t\tfifo_attrs = NULL;\n\n\tret = iio_triggered_buffer_setup_ext(indio_dev,\n\t\t\t\t\t     &iio_pollfunc_store_time, NULL,\n\t\t\t\t\t     IIO_BUFFER_DIRECTION_IN,\n\t\t\t\t\t     NULL, fifo_attrs);\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"Triggered Buffer Setup Failed\\n\");\n\t\treturn ret;\n\t}\n\n\ttrig = iio_trigger_alloc(indio_dev->dev.parent,\n\t\t\t\t \"%s-dev%d\", name, iio_device_id(indio_dev));\n\tif (trig == NULL) {\n\t\tdev_err(&indio_dev->dev, \"Trigger Allocate Failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error_triggered_buffer_cleanup;\n\t}\n\n\tiio_trigger_set_drvdata(trig, attrb);\n\ttrig->ops = &hid_sensor_trigger_ops;\n\tret = iio_trigger_register(trig);\n\n\tif (ret) {\n\t\tdev_err(&indio_dev->dev, \"Trigger Register Failed\\n\");\n\t\tgoto error_free_trig;\n\t}\n\tattrb->trigger = trig;\n\tindio_dev->trig = iio_trigger_get(trig);\n\n\tret = pm_runtime_set_active(&indio_dev->dev);\n\tif (ret)\n\t\tgoto error_unreg_trigger;\n\n\tiio_device_set_drvdata(indio_dev, attrb);\n\n\tINIT_WORK(&attrb->work, hid_sensor_set_power_work);\n\n\tpm_suspend_ignore_children(&attrb->pdev->dev, true);\n\t \n\tpm_runtime_set_autosuspend_delay(&attrb->pdev->dev,\n\t\t\t\t\t 3000);\n\treturn ret;\nerror_unreg_trigger:\n\tiio_trigger_unregister(trig);\nerror_free_trig:\n\tiio_trigger_free(trig);\nerror_triggered_buffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS(hid_sensor_setup_trigger, IIO_HID);\n\nstatic int __maybe_unused hid_sensor_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);\n\n\treturn _hid_sensor_power_state(attrb, false);\n}\n\nstatic int __maybe_unused hid_sensor_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);\n\tschedule_work(&attrb->work);\n\treturn 0;\n}\n\nstatic int __maybe_unused hid_sensor_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);\n\treturn _hid_sensor_power_state(attrb, true);\n}\n\nconst struct dev_pm_ops hid_sensor_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(hid_sensor_suspend, hid_sensor_resume)\n\tSET_RUNTIME_PM_OPS(hid_sensor_suspend,\n\t\t\t   hid_sensor_runtime_resume, NULL)\n};\nEXPORT_SYMBOL_NS(hid_sensor_pm_ops, IIO_HID);\n\nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@intel.com>\");\nMODULE_DESCRIPTION(\"HID Sensor trigger processing\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IIO_HID_ATTRIBUTES);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}