{
  "module_name": "bma220_spi.c",
  "hash_id": "f360b545df72bfa53a5bc3a6db9ff2a0de60bd72890a61e2e205e7e7918f4cf3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/bma220_spi.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define BMA220_REG_ID\t\t\t\t0x00\n#define BMA220_REG_ACCEL_X\t\t\t0x02\n#define BMA220_REG_ACCEL_Y\t\t\t0x03\n#define BMA220_REG_ACCEL_Z\t\t\t0x04\n#define BMA220_REG_RANGE\t\t\t0x11\n#define BMA220_REG_SUSPEND\t\t\t0x18\n\n#define BMA220_CHIP_ID\t\t\t\t0xDD\n#define BMA220_READ_MASK\t\t\tBIT(7)\n#define BMA220_RANGE_MASK\t\t\tGENMASK(1, 0)\n#define BMA220_SUSPEND_SLEEP\t\t\t0xFF\n#define BMA220_SUSPEND_WAKE\t\t\t0x00\n\n#define BMA220_DEVICE_NAME\t\t\t\"bma220\"\n\n#define BMA220_ACCEL_CHANNEL(index, reg, axis) {\t\t\t\\\n\t.type = IIO_ACCEL,\t\t\t\t\t\t\\\n\t.address = reg,\t\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##axis,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t.scan_index = index,\t\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\t\\\n\t\t.realbits = 6,\t\t\t\t\t\t\\\n\t\t.storagebits = 8,\t\t\t\t\t\\\n\t\t.shift = 2,\t\t\t\t\t\t\\\n\t\t.endianness = IIO_CPU,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nenum bma220_axis {\n\tAXIS_X,\n\tAXIS_Y,\n\tAXIS_Z,\n};\n\nstatic const int bma220_scale_table[][2] = {\n\t{0, 623000}, {1, 248000}, {2, 491000}, {4, 983000},\n};\n\nstruct bma220_data {\n\tstruct spi_device *spi_device;\n\tstruct mutex lock;\n\tstruct {\n\t\ts8 chans[3];\n\t\t \n\t\ts64 timestamp __aligned(8);\n\t} scan;\n\tu8 tx_buf[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic const struct iio_chan_spec bma220_channels[] = {\n\tBMA220_ACCEL_CHANNEL(0, BMA220_REG_ACCEL_X, X),\n\tBMA220_ACCEL_CHANNEL(1, BMA220_REG_ACCEL_Y, Y),\n\tBMA220_ACCEL_CHANNEL(2, BMA220_REG_ACCEL_Z, Z),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic inline int bma220_read_reg(struct spi_device *spi, u8 reg)\n{\n\treturn spi_w8r8(spi, reg | BMA220_READ_MASK);\n}\n\nstatic const unsigned long bma220_accel_scan_masks[] = {\n\tBIT(AXIS_X) | BIT(AXIS_Y) | BIT(AXIS_Z),\n\t0\n};\n\nstatic irqreturn_t bma220_trigger_handler(int irq, void *p)\n{\n\tint ret;\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct bma220_data *data = iio_priv(indio_dev);\n\tstruct spi_device *spi = data->spi_device;\n\n\tmutex_lock(&data->lock);\n\tdata->tx_buf[0] = BMA220_REG_ACCEL_X | BMA220_READ_MASK;\n\tret = spi_write_then_read(spi, data->tx_buf, 1, &data->scan.chans,\n\t\t\t\t  ARRAY_SIZE(bma220_channels) - 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t   pf->timestamp);\nerr:\n\tmutex_unlock(&data->lock);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bma220_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tint ret;\n\tu8 range_idx;\n\tstruct bma220_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = bma220_read_reg(data->spi_device, chan->address);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\t*val = sign_extend32(ret >> chan->scan_type.shift,\n\t\t\t\t     chan->scan_type.realbits - 1);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = bma220_read_reg(data->spi_device, BMA220_REG_RANGE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\trange_idx = ret & BMA220_RANGE_MASK;\n\t\t*val = bma220_scale_table[range_idx][0];\n\t\t*val2 = bma220_scale_table[range_idx][1];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int bma220_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tint i;\n\tint ret;\n\tint index = -1;\n\tstruct bma220_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tfor (i = 0; i < ARRAY_SIZE(bma220_scale_table); i++)\n\t\t\tif (val == bma220_scale_table[i][0] &&\n\t\t\t    val2 == bma220_scale_table[i][1]) {\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (index < 0)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&data->lock);\n\t\tdata->tx_buf[0] = BMA220_REG_RANGE;\n\t\tdata->tx_buf[1] = index;\n\t\tret = spi_write(data->spi_device, data->tx_buf,\n\t\t\t\tsizeof(data->tx_buf));\n\t\tif (ret < 0)\n\t\t\tdev_err(&data->spi_device->dev,\n\t\t\t\t\"failed to set measurement range\\n\");\n\t\tmutex_unlock(&data->lock);\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int bma220_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type, int *length,\n\t\t\t     long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*vals = (int *)bma220_scale_table;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t*length = ARRAY_SIZE(bma220_scale_table) * 2;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info bma220_info = {\n\t.read_raw\t\t= bma220_read_raw,\n\t.write_raw\t\t= bma220_write_raw,\n\t.read_avail\t\t= bma220_read_avail,\n};\n\nstatic int bma220_init(struct spi_device *spi)\n{\n\tint ret;\n\n\tret = bma220_read_reg(spi, BMA220_REG_ID);\n\tif (ret != BMA220_CHIP_ID)\n\t\treturn -ENODEV;\n\n\t \n\tret = bma220_read_reg(spi, BMA220_REG_SUSPEND);\n\tif (ret == BMA220_SUSPEND_WAKE)\n\t\tret = bma220_read_reg(spi, BMA220_REG_SUSPEND);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == BMA220_SUSPEND_WAKE)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int bma220_power(struct spi_device *spi, bool up)\n{\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tret = bma220_read_reg(spi, BMA220_REG_SUSPEND);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (up && ret == BMA220_SUSPEND_SLEEP)\n\t\t\treturn 0;\n\n\t\tif (!up && ret == BMA220_SUSPEND_WAKE)\n\t\t\treturn 0;\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic void bma220_deinit(void *spi)\n{\n\tbma220_power(spi, false);\n}\n\nstatic int bma220_probe(struct spi_device *spi)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\tstruct bma220_data *data;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*data));\n\tif (!indio_dev) {\n\t\tdev_err(&spi->dev, \"iio allocation failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = iio_priv(indio_dev);\n\tdata->spi_device = spi;\n\tmutex_init(&data->lock);\n\n\tindio_dev->info = &bma220_info;\n\tindio_dev->name = BMA220_DEVICE_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = bma220_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(bma220_channels);\n\tindio_dev->available_scan_masks = bma220_accel_scan_masks;\n\n\tret = bma220_init(data->spi_device);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, bma220_deinit, spi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev,\n\t\t\t\t\t      iio_pollfunc_store_time,\n\t\t\t\t\t      bma220_trigger_handler, NULL);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"iio triggered buffer setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic int bma220_suspend(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\n\treturn bma220_power(spi, false);\n}\n\nstatic int bma220_resume(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\n\treturn bma220_power(spi, true);\n}\nstatic DEFINE_SIMPLE_DEV_PM_OPS(bma220_pm_ops, bma220_suspend, bma220_resume);\n\nstatic const struct spi_device_id bma220_spi_id[] = {\n\t{\"bma220\", 0},\n\t{}\n};\n\nstatic const struct acpi_device_id bma220_acpi_id[] = {\n\t{\"BMA0220\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, bma220_spi_id);\n\nstatic struct spi_driver bma220_driver = {\n\t.driver = {\n\t\t.name = \"bma220_spi\",\n\t\t.pm = pm_sleep_ptr(&bma220_pm_ops),\n\t\t.acpi_match_table = bma220_acpi_id,\n\t},\n\t.probe =            bma220_probe,\n\t.id_table =         bma220_spi_id,\n};\nmodule_spi_driver(bma220_driver);\n\nMODULE_AUTHOR(\"Tiberiu Breana <tiberiu.a.breana@intel.com>\");\nMODULE_DESCRIPTION(\"BMA220 acceleration sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}