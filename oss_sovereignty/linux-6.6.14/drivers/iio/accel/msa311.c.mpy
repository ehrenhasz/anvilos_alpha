{
  "module_name": "msa311.c",
  "hash_id": "1c5440a042d8949d9671c12700d9b435ba5b8c59598c88fe0960af417f017ca3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/msa311.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/string_helpers.h>\n#include <linux/units.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define MSA311_SOFT_RESET_REG     0x00\n#define MSA311_PARTID_REG         0x01\n#define MSA311_ACC_X_REG          0x02\n#define MSA311_ACC_Y_REG          0x04\n#define MSA311_ACC_Z_REG          0x06\n#define MSA311_MOTION_INT_REG     0x09\n#define MSA311_DATA_INT_REG       0x0A\n#define MSA311_TAP_ACTIVE_STS_REG 0x0B\n#define MSA311_ORIENT_STS_REG     0x0C\n#define MSA311_RANGE_REG          0x0F\n#define MSA311_ODR_REG            0x10\n#define MSA311_PWR_MODE_REG       0x11\n#define MSA311_SWAP_POLARITY_REG  0x12\n#define MSA311_INT_SET_0_REG      0x16\n#define MSA311_INT_SET_1_REG      0x17\n#define MSA311_INT_MAP_0_REG      0x19\n#define MSA311_INT_MAP_1_REG      0x1A\n#define MSA311_INT_CONFIG_REG     0x20\n#define MSA311_INT_LATCH_REG      0x21\n#define MSA311_FREEFALL_DUR_REG   0x22\n#define MSA311_FREEFALL_TH_REG    0x23\n#define MSA311_FREEFALL_HY_REG    0x24\n#define MSA311_ACTIVE_DUR_REG     0x27\n#define MSA311_ACTIVE_TH_REG      0x28\n#define MSA311_TAP_DUR_REG        0x2A\n#define MSA311_TAP_TH_REG         0x2B\n#define MSA311_ORIENT_HY_REG      0x2C\n#define MSA311_Z_BLOCK_REG        0x2D\n#define MSA311_OFFSET_X_REG       0x38\n#define MSA311_OFFSET_Y_REG       0x39\n#define MSA311_OFFSET_Z_REG       0x3A\n\nenum msa311_fields {\n\t \n\tF_SOFT_RESET_I2C, F_SOFT_RESET_SPI,\n\t \n\tF_ORIENT_INT, F_S_TAP_INT, F_D_TAP_INT, F_ACTIVE_INT, F_FREEFALL_INT,\n\t \n\tF_NEW_DATA_INT,\n\t \n\tF_TAP_SIGN, F_TAP_FIRST_X, F_TAP_FIRST_Y, F_TAP_FIRST_Z, F_ACTV_SIGN,\n\tF_ACTV_FIRST_X, F_ACTV_FIRST_Y, F_ACTV_FIRST_Z,\n\t \n\tF_ORIENT_Z, F_ORIENT_X_Y,\n\t \n\tF_FS,\n\t \n\tF_X_AXIS_DIS, F_Y_AXIS_DIS, F_Z_AXIS_DIS, F_ODR,\n\t \n\tF_PWR_MODE, F_LOW_POWER_BW,\n\t \n\tF_X_POLARITY, F_Y_POLARITY, F_Z_POLARITY, F_X_Y_SWAP,\n\t \n\tF_ORIENT_INT_EN, F_S_TAP_INT_EN, F_D_TAP_INT_EN, F_ACTIVE_INT_EN_Z,\n\tF_ACTIVE_INT_EN_Y, F_ACTIVE_INT_EN_X,\n\t \n\tF_NEW_DATA_INT_EN, F_FREEFALL_INT_EN,\n\t \n\tF_INT1_ORIENT, F_INT1_S_TAP, F_INT1_D_TAP, F_INT1_ACTIVE,\n\tF_INT1_FREEFALL,\n\t \n\tF_INT1_NEW_DATA,\n\t \n\tF_INT1_OD, F_INT1_LVL,\n\t \n\tF_RESET_INT, F_LATCH_INT,\n\t \n\tF_FREEFALL_MODE, F_FREEFALL_HY,\n\t \n\tF_ACTIVE_DUR,\n\t \n\tF_TAP_QUIET, F_TAP_SHOCK, F_TAP_DUR,\n\t \n\tF_TAP_TH,\n\t \n\tF_ORIENT_HYST, F_ORIENT_BLOCKING, F_ORIENT_MODE,\n\t \n\tF_Z_BLOCKING,\n\t \n\tF_MAX_FIELDS,\n};\n\nstatic const struct reg_field msa311_reg_fields[] = {\n\t \n\t[F_SOFT_RESET_I2C] = REG_FIELD(MSA311_SOFT_RESET_REG, 2, 2),\n\t[F_SOFT_RESET_SPI] = REG_FIELD(MSA311_SOFT_RESET_REG, 5, 5),\n\t \n\t[F_ORIENT_INT] = REG_FIELD(MSA311_MOTION_INT_REG, 6, 6),\n\t[F_S_TAP_INT] = REG_FIELD(MSA311_MOTION_INT_REG, 5, 5),\n\t[F_D_TAP_INT] = REG_FIELD(MSA311_MOTION_INT_REG, 4, 4),\n\t[F_ACTIVE_INT] = REG_FIELD(MSA311_MOTION_INT_REG, 2, 2),\n\t[F_FREEFALL_INT] = REG_FIELD(MSA311_MOTION_INT_REG, 0, 0),\n\t \n\t[F_NEW_DATA_INT] = REG_FIELD(MSA311_DATA_INT_REG, 0, 0),\n\t \n\t[F_TAP_SIGN] = REG_FIELD(MSA311_TAP_ACTIVE_STS_REG, 7, 7),\n\t[F_TAP_FIRST_X] = REG_FIELD(MSA311_TAP_ACTIVE_STS_REG, 6, 6),\n\t[F_TAP_FIRST_Y] = REG_FIELD(MSA311_TAP_ACTIVE_STS_REG, 5, 5),\n\t[F_TAP_FIRST_Z] = REG_FIELD(MSA311_TAP_ACTIVE_STS_REG, 4, 4),\n\t[F_ACTV_SIGN] = REG_FIELD(MSA311_TAP_ACTIVE_STS_REG, 3, 3),\n\t[F_ACTV_FIRST_X] = REG_FIELD(MSA311_TAP_ACTIVE_STS_REG, 2, 2),\n\t[F_ACTV_FIRST_Y] = REG_FIELD(MSA311_TAP_ACTIVE_STS_REG, 1, 1),\n\t[F_ACTV_FIRST_Z] = REG_FIELD(MSA311_TAP_ACTIVE_STS_REG, 0, 0),\n\t \n\t[F_ORIENT_Z] = REG_FIELD(MSA311_ORIENT_STS_REG, 6, 6),\n\t[F_ORIENT_X_Y] = REG_FIELD(MSA311_ORIENT_STS_REG, 4, 5),\n\t \n\t[F_FS] = REG_FIELD(MSA311_RANGE_REG, 0, 1),\n\t \n\t[F_X_AXIS_DIS] = REG_FIELD(MSA311_ODR_REG, 7, 7),\n\t[F_Y_AXIS_DIS] = REG_FIELD(MSA311_ODR_REG, 6, 6),\n\t[F_Z_AXIS_DIS] = REG_FIELD(MSA311_ODR_REG, 5, 5),\n\t[F_ODR] = REG_FIELD(MSA311_ODR_REG, 0, 3),\n\t \n\t[F_PWR_MODE] = REG_FIELD(MSA311_PWR_MODE_REG, 6, 7),\n\t[F_LOW_POWER_BW] = REG_FIELD(MSA311_PWR_MODE_REG, 1, 4),\n\t \n\t[F_X_POLARITY] = REG_FIELD(MSA311_SWAP_POLARITY_REG, 3, 3),\n\t[F_Y_POLARITY] = REG_FIELD(MSA311_SWAP_POLARITY_REG, 2, 2),\n\t[F_Z_POLARITY] = REG_FIELD(MSA311_SWAP_POLARITY_REG, 1, 1),\n\t[F_X_Y_SWAP] = REG_FIELD(MSA311_SWAP_POLARITY_REG, 0, 0),\n\t \n\t[F_ORIENT_INT_EN] = REG_FIELD(MSA311_INT_SET_0_REG, 6, 6),\n\t[F_S_TAP_INT_EN] = REG_FIELD(MSA311_INT_SET_0_REG, 5, 5),\n\t[F_D_TAP_INT_EN] = REG_FIELD(MSA311_INT_SET_0_REG, 4, 4),\n\t[F_ACTIVE_INT_EN_Z] = REG_FIELD(MSA311_INT_SET_0_REG, 2, 2),\n\t[F_ACTIVE_INT_EN_Y] = REG_FIELD(MSA311_INT_SET_0_REG, 1, 1),\n\t[F_ACTIVE_INT_EN_X] = REG_FIELD(MSA311_INT_SET_0_REG, 0, 0),\n\t \n\t[F_NEW_DATA_INT_EN] = REG_FIELD(MSA311_INT_SET_1_REG, 4, 4),\n\t[F_FREEFALL_INT_EN] = REG_FIELD(MSA311_INT_SET_1_REG, 3, 3),\n\t \n\t[F_INT1_ORIENT] = REG_FIELD(MSA311_INT_MAP_0_REG, 6, 6),\n\t[F_INT1_S_TAP] = REG_FIELD(MSA311_INT_MAP_0_REG, 5, 5),\n\t[F_INT1_D_TAP] = REG_FIELD(MSA311_INT_MAP_0_REG, 4, 4),\n\t[F_INT1_ACTIVE] = REG_FIELD(MSA311_INT_MAP_0_REG, 2, 2),\n\t[F_INT1_FREEFALL] = REG_FIELD(MSA311_INT_MAP_0_REG, 0, 0),\n\t \n\t[F_INT1_NEW_DATA] = REG_FIELD(MSA311_INT_MAP_1_REG, 0, 0),\n\t \n\t[F_INT1_OD] = REG_FIELD(MSA311_INT_CONFIG_REG, 1, 1),\n\t[F_INT1_LVL] = REG_FIELD(MSA311_INT_CONFIG_REG, 0, 0),\n\t \n\t[F_RESET_INT] = REG_FIELD(MSA311_INT_LATCH_REG, 7, 7),\n\t[F_LATCH_INT] = REG_FIELD(MSA311_INT_LATCH_REG, 0, 3),\n\t \n\t[F_FREEFALL_MODE] = REG_FIELD(MSA311_FREEFALL_HY_REG, 2, 2),\n\t[F_FREEFALL_HY] = REG_FIELD(MSA311_FREEFALL_HY_REG, 0, 1),\n\t \n\t[F_ACTIVE_DUR] = REG_FIELD(MSA311_ACTIVE_DUR_REG, 0, 1),\n\t \n\t[F_TAP_QUIET] = REG_FIELD(MSA311_TAP_DUR_REG, 7, 7),\n\t[F_TAP_SHOCK] = REG_FIELD(MSA311_TAP_DUR_REG, 6, 6),\n\t[F_TAP_DUR] = REG_FIELD(MSA311_TAP_DUR_REG, 0, 2),\n\t \n\t[F_TAP_TH] = REG_FIELD(MSA311_TAP_TH_REG, 0, 4),\n\t \n\t[F_ORIENT_HYST] = REG_FIELD(MSA311_ORIENT_HY_REG, 4, 6),\n\t[F_ORIENT_BLOCKING] = REG_FIELD(MSA311_ORIENT_HY_REG, 2, 3),\n\t[F_ORIENT_MODE] = REG_FIELD(MSA311_ORIENT_HY_REG, 0, 1),\n\t \n\t[F_Z_BLOCKING] = REG_FIELD(MSA311_Z_BLOCK_REG, 0, 3),\n};\n\n#define MSA311_WHO_AM_I 0x13\n\n \nenum {\n\tMSA311_FS_2G,\n\tMSA311_FS_4G,\n\tMSA311_FS_8G,\n\tMSA311_FS_16G,\n};\n\nstruct iio_decimal_fract {\n\tint integral;\n\tint microfract;\n};\n\nstatic const struct iio_decimal_fract msa311_fs_table[] = {\n\t{0, 9580}, {0, 19160}, {0, 38320}, {0, 76641},\n};\n\n \nenum {\n\tMSA311_ODR_1_HZ,\n\tMSA311_ODR_1_95_HZ,\n\tMSA311_ODR_3_9_HZ,\n\tMSA311_ODR_7_81_HZ,\n\tMSA311_ODR_15_63_HZ,\n\tMSA311_ODR_31_25_HZ,\n\tMSA311_ODR_62_5_HZ,\n\tMSA311_ODR_125_HZ,\n\tMSA311_ODR_250_HZ,\n\tMSA311_ODR_500_HZ,\n\tMSA311_ODR_1000_HZ,\n};\n\nstatic const struct iio_decimal_fract msa311_odr_table[] = {\n\t{1, 0}, {1, 950000}, {3, 900000}, {7, 810000}, {15, 630000},\n\t{31, 250000}, {62, 500000}, {125, 0}, {250, 0}, {500, 0}, {1000, 0},\n};\n\n \n#define MSA311_PWR_MODE_NORMAL  0b00\n#define MSA311_PWR_MODE_LOW     0b01\n#define MSA311_PWR_MODE_UNKNOWN 0b10\n#define MSA311_PWR_MODE_SUSPEND 0b11\nstatic const char * const msa311_pwr_modes[] = {\n\t[MSA311_PWR_MODE_NORMAL] = \"normal\",\n\t[MSA311_PWR_MODE_LOW] = \"low\",\n\t[MSA311_PWR_MODE_UNKNOWN] = \"unknown\",\n\t[MSA311_PWR_MODE_SUSPEND] = \"suspend\",\n};\n\n \n#define MSA311_PWR_SLEEP_DELAY_MS 2000\n\n \nenum {\n\tMSA311_INT1_OD_PUSH_PULL,\n\tMSA311_INT1_OD_OPEN_DRAIN,\n};\n\nenum {\n\tMSA311_INT1_LVL_LOW,\n\tMSA311_INT1_LVL_HIGH,\n};\n\n \n#define MSA311_LATCH_INT_NOT_LATCHED 0b0000\n#define MSA311_LATCH_INT_250MS       0b0001\n#define MSA311_LATCH_INT_500MS       0b0010\n#define MSA311_LATCH_INT_1S          0b0011\n#define MSA311_LATCH_INT_2S          0b0100\n#define MSA311_LATCH_INT_4S          0b0101\n#define MSA311_LATCH_INT_8S          0b0110\n#define MSA311_LATCH_INT_1MS         0b1010\n#define MSA311_LATCH_INT_2MS         0b1011\n#define MSA311_LATCH_INT_25MS        0b1100\n#define MSA311_LATCH_INT_50MS        0b1101\n#define MSA311_LATCH_INT_100MS       0b1110\n#define MSA311_LATCH_INT_LATCHED     0b0111\n\nstatic const struct regmap_range msa311_readonly_registers[] = {\n\tregmap_reg_range(MSA311_PARTID_REG, MSA311_ORIENT_STS_REG),\n};\n\nstatic const struct regmap_access_table msa311_writeable_table = {\n\t.no_ranges = msa311_readonly_registers,\n\t.n_no_ranges = ARRAY_SIZE(msa311_readonly_registers),\n};\n\nstatic const struct regmap_range msa311_writeonly_registers[] = {\n\tregmap_reg_range(MSA311_SOFT_RESET_REG, MSA311_SOFT_RESET_REG),\n};\n\nstatic const struct regmap_access_table msa311_readable_table = {\n\t.no_ranges = msa311_writeonly_registers,\n\t.n_no_ranges = ARRAY_SIZE(msa311_writeonly_registers),\n};\n\nstatic const struct regmap_range msa311_volatile_registers[] = {\n\tregmap_reg_range(MSA311_ACC_X_REG, MSA311_ORIENT_STS_REG),\n};\n\nstatic const struct regmap_access_table msa311_volatile_table = {\n\t.yes_ranges = msa311_volatile_registers,\n\t.n_yes_ranges = ARRAY_SIZE(msa311_volatile_registers),\n};\n\nstatic const struct regmap_config msa311_regmap_config = {\n\t.name = \"msa311\",\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = MSA311_OFFSET_Z_REG,\n\t.wr_table = &msa311_writeable_table,\n\t.rd_table = &msa311_readable_table,\n\t.volatile_table = &msa311_volatile_table,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\n#define MSA311_GENMASK(field) ({                \\\n\ttypeof(&(msa311_reg_fields)[0]) _field; \\\n\t_field = &msa311_reg_fields[(field)];   \\\n\tGENMASK(_field->msb, _field->lsb);      \\\n})\n\n \nstruct msa311_priv {\n\tstruct regmap *regs;\n\tstruct regmap_field *fields[F_MAX_FIELDS];\n\n\tstruct device *dev;\n\tstruct mutex lock;\n\tchar *chip_name;\n\n\tstruct iio_trigger *new_data_trig;\n};\n\nenum msa311_si {\n\tMSA311_SI_X,\n\tMSA311_SI_Y,\n\tMSA311_SI_Z,\n\tMSA311_SI_TIMESTAMP,\n};\n\n#define MSA311_ACCEL_CHANNEL(axis) {                                        \\\n\t.type = IIO_ACCEL,                                                  \\\n\t.modified = 1,                                                      \\\n\t.channel2 = IIO_MOD_##axis,                                         \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),                       \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |              \\\n\t\t\t\t    BIT(IIO_CHAN_INFO_SAMP_FREQ),           \\\n\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SCALE) |    \\\n\t\t\t\t\t      BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.scan_index = MSA311_SI_##axis,                                     \\\n\t.scan_type = {                                                      \\\n\t\t.sign = 's',                                                \\\n\t\t.realbits = 12,                                             \\\n\t\t.storagebits = 16,                                          \\\n\t\t.shift = 4,                                                 \\\n\t\t.endianness = IIO_LE,                                       \\\n\t},                                                                  \\\n\t.datasheet_name = \"ACC_\"#axis,                                      \\\n}\n\nstatic const struct iio_chan_spec msa311_channels[] = {\n\tMSA311_ACCEL_CHANNEL(X),\n\tMSA311_ACCEL_CHANNEL(Y),\n\tMSA311_ACCEL_CHANNEL(Z),\n\tIIO_CHAN_SOFT_TIMESTAMP(MSA311_SI_TIMESTAMP),\n};\n\n \nstatic int msa311_get_odr(struct msa311_priv *msa311, unsigned int *odr)\n{\n\tint err;\n\n\terr = regmap_field_read(msa311->fields[F_ODR], odr);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (*odr > MSA311_ODR_1000_HZ)\n\t\t*odr = MSA311_ODR_1000_HZ;\n\n\treturn 0;\n}\n\n \nstatic int msa311_set_odr(struct msa311_priv *msa311, unsigned int odr)\n{\n\tstruct device *dev = msa311->dev;\n\tunsigned int pwr_mode;\n\tbool good_odr;\n\tint err;\n\n\terr = regmap_field_read(msa311->fields[F_PWR_MODE], &pwr_mode);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (pwr_mode == MSA311_PWR_MODE_NORMAL)\n\t\tgood_odr = (odr > MSA311_ODR_1_95_HZ);\n\telse\n\t\tgood_odr = false;\n\n\tif (!good_odr) {\n\t\tdev_err(dev,\n\t\t\t\"can't set odr %u.%06uHz, not available in %s mode\\n\",\n\t\t\tmsa311_odr_table[odr].integral,\n\t\t\tmsa311_odr_table[odr].microfract,\n\t\t\tmsa311_pwr_modes[pwr_mode]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_field_write(msa311->fields[F_ODR], odr);\n}\n\n \nstatic int msa311_wait_for_next_data(struct msa311_priv *msa311)\n{\n\tstatic const unsigned int unintr_thresh_ms = 20;\n\tstruct device *dev = msa311->dev;\n\tunsigned long freq_uhz;\n\tunsigned long wait_ms;\n\tunsigned int odr;\n\tint err;\n\n\terr = msa311_get_odr(msa311, &odr);\n\tif (err) {\n\t\tdev_err(dev, \"can't get actual frequency (%pe)\\n\",\n\t\t\tERR_PTR(err));\n\t\treturn err;\n\t}\n\n\t \n\tfreq_uhz = msa311_odr_table[odr].integral * MICROHZ_PER_HZ +\n\t\t   msa311_odr_table[odr].microfract;\n\twait_ms = (MICROHZ_PER_HZ / freq_uhz) * MSEC_PER_SEC;\n\n\tif (wait_ms < unintr_thresh_ms)\n\t\tusleep_range(wait_ms * USEC_PER_MSEC,\n\t\t\t     unintr_thresh_ms * USEC_PER_MSEC);\n\telse if (msleep_interruptible(wait_ms))\n\t\treturn -EINTR;\n\n\treturn 0;\n}\n\n \nstatic int msa311_set_pwr_mode(struct msa311_priv *msa311, unsigned int mode)\n{\n\tstruct device *dev = msa311->dev;\n\tunsigned int prev_mode;\n\tint err;\n\n\tif (mode >= ARRAY_SIZE(msa311_pwr_modes))\n\t\treturn -EINVAL;\n\n\tdev_dbg(dev, \"transition to %s mode\\n\", msa311_pwr_modes[mode]);\n\n\terr = regmap_field_read(msa311->fields[F_PWR_MODE], &prev_mode);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_field_write(msa311->fields[F_PWR_MODE], mode);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (prev_mode == MSA311_PWR_MODE_SUSPEND &&\n\t    mode == MSA311_PWR_MODE_NORMAL)\n\t\treturn msa311_wait_for_next_data(msa311);\n\n\treturn 0;\n}\n\n \nstatic int msa311_get_axis(struct msa311_priv *msa311,\n\t\t\t   const struct iio_chan_spec * const chan,\n\t\t\t   __le16 *axis)\n{\n\tstruct device *dev = msa311->dev;\n\tunsigned int axis_reg;\n\n\tif (chan->scan_index < MSA311_SI_X || chan->scan_index > MSA311_SI_Z) {\n\t\tdev_err(dev, \"invalid scan_index value [%d]\\n\",\n\t\t\tchan->scan_index);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\taxis_reg = MSA311_ACC_X_REG + (chan->scan_index << 1);\n\n\treturn regmap_bulk_read(msa311->regs, axis_reg, axis, sizeof(*axis));\n}\n\nstatic int msa311_read_raw_data(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2)\n{\n\tstruct msa311_priv *msa311 = iio_priv(indio_dev);\n\tstruct device *dev = msa311->dev;\n\t__le16 axis;\n\tint err;\n\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = iio_device_claim_direct_mode(indio_dev);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&msa311->lock);\n\terr = msa311_get_axis(msa311, chan, &axis);\n\tmutex_unlock(&msa311->lock);\n\n\tiio_device_release_direct_mode(indio_dev);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\tif (err) {\n\t\tdev_err(dev, \"can't get axis %s (%pe)\\n\",\n\t\t\tchan->datasheet_name, ERR_PTR(err));\n\t\treturn err;\n\t}\n\n\t \n\t*val = sign_extend32(le16_to_cpu(axis) >> chan->scan_type.shift,\n\t\t\t     chan->scan_type.realbits - 1);\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int msa311_read_scale(struct iio_dev *indio_dev, int *val, int *val2)\n{\n\tstruct msa311_priv *msa311 = iio_priv(indio_dev);\n\tstruct device *dev = msa311->dev;\n\tunsigned int fs;\n\tint err;\n\n\tmutex_lock(&msa311->lock);\n\terr = regmap_field_read(msa311->fields[F_FS], &fs);\n\tmutex_unlock(&msa311->lock);\n\tif (err) {\n\t\tdev_err(dev, \"can't get actual scale (%pe)\\n\", ERR_PTR(err));\n\t\treturn err;\n\t}\n\n\t*val = msa311_fs_table[fs].integral;\n\t*val2 = msa311_fs_table[fs].microfract;\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int msa311_read_samp_freq(struct iio_dev *indio_dev,\n\t\t\t\t int *val, int *val2)\n{\n\tstruct msa311_priv *msa311 = iio_priv(indio_dev);\n\tstruct device *dev = msa311->dev;\n\tunsigned int odr;\n\tint err;\n\n\tmutex_lock(&msa311->lock);\n\terr = msa311_get_odr(msa311, &odr);\n\tmutex_unlock(&msa311->lock);\n\tif (err) {\n\t\tdev_err(dev, \"can't get actual frequency (%pe)\\n\",\n\t\t\tERR_PTR(err));\n\t\treturn err;\n\t}\n\n\t*val = msa311_odr_table[odr].integral;\n\t*val2 = msa311_odr_table[odr].microfract;\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int msa311_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn msa311_read_raw_data(indio_dev, chan, val, val2);\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn msa311_read_scale(indio_dev, val, val2);\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn msa311_read_samp_freq(indio_dev, val, val2);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int msa311_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type,\n\t\t\t     int *length, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*vals = (int *)msa311_odr_table;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t \n\t\t*length = ARRAY_SIZE(msa311_odr_table) * 2;\n\t\treturn IIO_AVAIL_LIST;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*vals = (int *)msa311_fs_table;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t \n\t\t*length = ARRAY_SIZE(msa311_fs_table) * 2;\n\t\treturn IIO_AVAIL_LIST;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int msa311_write_scale(struct iio_dev *indio_dev, int val, int val2)\n{\n\tstruct msa311_priv *msa311 = iio_priv(indio_dev);\n\tstruct device *dev = msa311->dev;\n\tunsigned int fs;\n\tint err;\n\n\t \n\tif (val)\n\t\treturn 0;\n\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tfor (fs = 0; fs < ARRAY_SIZE(msa311_fs_table); fs++)\n\t\t \n\t\tif (val2 == msa311_fs_table[fs].microfract) {\n\t\t\tmutex_lock(&msa311->lock);\n\t\t\terr = regmap_field_write(msa311->fields[F_FS], fs);\n\t\t\tmutex_unlock(&msa311->lock);\n\t\t\tbreak;\n\t\t}\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\tif (err)\n\t\tdev_err(dev, \"can't update scale (%pe)\\n\", ERR_PTR(err));\n\n\treturn err;\n}\n\nstatic int msa311_write_samp_freq(struct iio_dev *indio_dev, int val, int val2)\n{\n\tstruct msa311_priv *msa311 = iio_priv(indio_dev);\n\tstruct device *dev = msa311->dev;\n\tunsigned int odr;\n\tint err;\n\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = iio_device_claim_direct_mode(indio_dev);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tfor (odr = 0; odr < ARRAY_SIZE(msa311_odr_table); odr++)\n\t\tif (val == msa311_odr_table[odr].integral &&\n\t\t    val2 == msa311_odr_table[odr].microfract) {\n\t\t\tmutex_lock(&msa311->lock);\n\t\t\terr = msa311_set_odr(msa311, odr);\n\t\t\tmutex_unlock(&msa311->lock);\n\t\t\tbreak;\n\t\t}\n\n\tiio_device_release_direct_mode(indio_dev);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\tif (err)\n\t\tdev_err(dev, \"can't update frequency (%pe)\\n\", ERR_PTR(err));\n\n\treturn err;\n}\n\nstatic int msa311_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn msa311_write_scale(indio_dev, val, val2);\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn msa311_write_samp_freq(indio_dev, val, val2);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int msa311_debugfs_reg_access(struct iio_dev *indio_dev,\n\t\t\t\t     unsigned int reg, unsigned int writeval,\n\t\t\t\t     unsigned int *readval)\n{\n\tstruct msa311_priv *msa311 = iio_priv(indio_dev);\n\tstruct device *dev = msa311->dev;\n\tint err;\n\n\tif (reg > regmap_get_max_register(msa311->regs))\n\t\treturn -EINVAL;\n\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&msa311->lock);\n\n\tif (readval)\n\t\terr = regmap_read(msa311->regs, reg, readval);\n\telse\n\t\terr = regmap_write(msa311->regs, reg, writeval);\n\n\tmutex_unlock(&msa311->lock);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\tif (err)\n\t\tdev_err(dev, \"can't %s register %u from debugfs (%pe)\\n\",\n\t\t\tstr_read_write(readval), reg, ERR_PTR(err));\n\n\treturn err;\n}\n\nstatic int msa311_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct msa311_priv *msa311 = iio_priv(indio_dev);\n\tstruct device *dev = msa311->dev;\n\n\treturn pm_runtime_resume_and_get(dev);\n}\n\nstatic int msa311_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct msa311_priv *msa311 = iio_priv(indio_dev);\n\tstruct device *dev = msa311->dev;\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic int msa311_set_new_data_trig_state(struct iio_trigger *trig, bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct msa311_priv *msa311 = iio_priv(indio_dev);\n\tstruct device *dev = msa311->dev;\n\tint err;\n\n\tmutex_lock(&msa311->lock);\n\terr = regmap_field_write(msa311->fields[F_NEW_DATA_INT_EN], state);\n\tmutex_unlock(&msa311->lock);\n\tif (err)\n\t\tdev_err(dev,\n\t\t\t\"can't %s buffer due to new_data_int failure (%pe)\\n\",\n\t\t\tstr_enable_disable(state), ERR_PTR(err));\n\n\treturn err;\n}\n\nstatic int msa311_validate_device(struct iio_trigger *trig,\n\t\t\t\t  struct iio_dev *indio_dev)\n{\n\treturn iio_trigger_get_drvdata(trig) == indio_dev ? 0 : -EINVAL;\n}\n\nstatic irqreturn_t msa311_buffer_thread(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct msa311_priv *msa311 = iio_priv(pf->indio_dev);\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tconst struct iio_chan_spec *chan;\n\tstruct device *dev = msa311->dev;\n\tint bit, err, i = 0;\n\t__le16 axis;\n\tstruct {\n\t\t__le16 channels[MSA311_SI_Z + 1];\n\t\ts64 ts __aligned(8);\n\t} buf;\n\n\tmemset(&buf, 0, sizeof(buf));\n\n\tmutex_lock(&msa311->lock);\n\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\tchan = &msa311_channels[bit];\n\n\t\terr = msa311_get_axis(msa311, chan, &axis);\n\t\tif (err) {\n\t\t\tmutex_unlock(&msa311->lock);\n\t\t\tdev_err(dev, \"can't get axis %s (%pe)\\n\",\n\t\t\t\tchan->datasheet_name, ERR_PTR(err));\n\t\t\tgoto notify_done;\n\t\t}\n\n\t\tbuf.channels[i++] = axis;\n\t}\n\n\tmutex_unlock(&msa311->lock);\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &buf,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\nnotify_done:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t msa311_irq_thread(int irq, void *p)\n{\n\tstruct msa311_priv *msa311 = iio_priv(p);\n\tunsigned int new_data_int_enabled;\n\tstruct device *dev = msa311->dev;\n\tint err;\n\n\tmutex_lock(&msa311->lock);\n\n\t \n\terr = regmap_field_read(msa311->fields[F_NEW_DATA_INT_EN],\n\t\t\t\t&new_data_int_enabled);\n\n\tmutex_unlock(&msa311->lock);\n\tif (err) {\n\t\tdev_err(dev, \"can't read new_data interrupt state (%pe)\\n\",\n\t\t\tERR_PTR(err));\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (new_data_int_enabled)\n\t\tiio_trigger_poll_nested(msa311->new_data_trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_info msa311_info = {\n\t.read_raw = msa311_read_raw,\n\t.read_avail = msa311_read_avail,\n\t.write_raw = msa311_write_raw,\n\t.debugfs_reg_access = msa311_debugfs_reg_access,\n};\n\nstatic const struct iio_buffer_setup_ops msa311_buffer_setup_ops = {\n\t.preenable = msa311_buffer_preenable,\n\t.postdisable = msa311_buffer_postdisable,\n};\n\nstatic const struct iio_trigger_ops msa311_new_data_trig_ops = {\n\t.set_trigger_state = msa311_set_new_data_trig_state,\n\t.validate_device = msa311_validate_device,\n};\n\nstatic int msa311_check_partid(struct msa311_priv *msa311)\n{\n\tstruct device *dev = msa311->dev;\n\tunsigned int partid;\n\tint err;\n\n\terr = regmap_read(msa311->regs, MSA311_PARTID_REG, &partid);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"failed to read partid\\n\");\n\n\tif (partid != MSA311_WHO_AM_I)\n\t\tdev_warn(dev, \"invalid partid (%#x), expected (%#x)\\n\",\n\t\t\t partid, MSA311_WHO_AM_I);\n\n\tmsa311->chip_name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t   \"msa311-%02x\", partid);\n\tif (!msa311->chip_name)\n\t\treturn dev_err_probe(dev, -ENOMEM, \"can't alloc chip name\\n\");\n\n\treturn 0;\n}\n\nstatic int msa311_soft_reset(struct msa311_priv *msa311)\n{\n\tstruct device *dev = msa311->dev;\n\tint err;\n\n\terr = regmap_write(msa311->regs, MSA311_SOFT_RESET_REG,\n\t\t\t   MSA311_GENMASK(F_SOFT_RESET_I2C) |\n\t\t\t   MSA311_GENMASK(F_SOFT_RESET_SPI));\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"can't soft reset all logic\\n\");\n\n\treturn 0;\n}\n\nstatic int msa311_chip_init(struct msa311_priv *msa311)\n{\n\tstruct device *dev = msa311->dev;\n\tconst char zero_bulk[2] = { };\n\tint err;\n\n\terr = regmap_write(msa311->regs, MSA311_RANGE_REG, MSA311_FS_16G);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"failed to setup accel range\\n\");\n\n\t \n\terr = regmap_bulk_write(msa311->regs, MSA311_INT_SET_0_REG,\n\t\t\t\tzero_bulk, sizeof(zero_bulk));\n\tif (err)\n\t\treturn dev_err_probe(dev, err,\n\t\t\t\t     \"can't disable set0/set1 interrupts\\n\");\n\n\t \n\terr = regmap_bulk_write(msa311->regs, MSA311_INT_MAP_0_REG,\n\t\t\t\tzero_bulk, sizeof(zero_bulk));\n\tif (err)\n\t\treturn dev_err_probe(dev, err,\n\t\t\t\t     \"failed to unmap map0/map1 interrupts\\n\");\n\n\t \n\terr = regmap_update_bits(msa311->regs, MSA311_ODR_REG,\n\t\t\t\t MSA311_GENMASK(F_X_AXIS_DIS) |\n\t\t\t\t MSA311_GENMASK(F_Y_AXIS_DIS) |\n\t\t\t\t MSA311_GENMASK(F_Z_AXIS_DIS), 0);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"can't enable all axes\\n\");\n\n\terr = msa311_set_odr(msa311, MSA311_ODR_125_HZ);\n\tif (err)\n\t\treturn dev_err_probe(dev, err,\n\t\t\t\t     \"failed to set accel frequency\\n\");\n\n\treturn 0;\n}\n\nstatic int msa311_setup_interrupts(struct msa311_priv *msa311)\n{\n\tstruct device *dev = msa311->dev;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(i2c);\n\tstruct iio_trigger *trig;\n\tint err;\n\n\t \n\tif (i2c->irq <= 0)\n\t\treturn 0;\n\n\terr = devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL,\n\t\t\t\t\tmsa311_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\tmsa311->chip_name, indio_dev);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"failed to request IRQ\\n\");\n\n\ttrig = devm_iio_trigger_alloc(dev, \"%s-new-data\", msa311->chip_name);\n\tif (!trig)\n\t\treturn dev_err_probe(dev, -ENOMEM,\n\t\t\t\t     \"can't allocate newdata trigger\\n\");\n\n\tmsa311->new_data_trig = trig;\n\tmsa311->new_data_trig->ops = &msa311_new_data_trig_ops;\n\tiio_trigger_set_drvdata(msa311->new_data_trig, indio_dev);\n\n\terr = devm_iio_trigger_register(dev, msa311->new_data_trig);\n\tif (err)\n\t\treturn dev_err_probe(dev, err,\n\t\t\t\t     \"can't register newdata trigger\\n\");\n\n\terr = regmap_field_write(msa311->fields[F_INT1_OD],\n\t\t\t\t MSA311_INT1_OD_PUSH_PULL);\n\tif (err)\n\t\treturn dev_err_probe(dev, err,\n\t\t\t\t     \"can't enable push-pull interrupt\\n\");\n\n\terr = regmap_field_write(msa311->fields[F_INT1_LVL],\n\t\t\t\t MSA311_INT1_LVL_HIGH);\n\tif (err)\n\t\treturn dev_err_probe(dev, err,\n\t\t\t\t     \"can't set active interrupt level\\n\");\n\n\terr = regmap_field_write(msa311->fields[F_LATCH_INT],\n\t\t\t\t MSA311_LATCH_INT_LATCHED);\n\tif (err)\n\t\treturn dev_err_probe(dev, err,\n\t\t\t\t     \"can't latch interrupt\\n\");\n\n\terr = regmap_field_write(msa311->fields[F_RESET_INT], 1);\n\tif (err)\n\t\treturn dev_err_probe(dev, err,\n\t\t\t\t     \"can't reset interrupt\\n\");\n\n\terr = regmap_field_write(msa311->fields[F_INT1_NEW_DATA], 1);\n\tif (err)\n\t\treturn dev_err_probe(dev, err,\n\t\t\t\t     \"can't map new data interrupt\\n\");\n\n\treturn 0;\n}\n\nstatic int msa311_regmap_init(struct msa311_priv *msa311)\n{\n\tstruct regmap_field **fields = msa311->fields;\n\tstruct device *dev = msa311->dev;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct regmap *regmap;\n\tint i;\n\n\tregmap = devm_regmap_init_i2c(i2c, &msa311_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap),\n\t\t\t\t     \"failed to register i2c regmap\\n\");\n\n\tmsa311->regs = regmap;\n\n\tfor (i = 0; i < F_MAX_FIELDS; i++) {\n\t\tfields[i] = devm_regmap_field_alloc(dev,\n\t\t\t\t\t\t    msa311->regs,\n\t\t\t\t\t\t    msa311_reg_fields[i]);\n\t\tif (IS_ERR(msa311->fields[i]))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(msa311->fields[i]),\n\t\t\t\t\t     \"can't alloc field[%d]\\n\", i);\n\t}\n\n\treturn 0;\n}\n\nstatic void msa311_powerdown(void *msa311)\n{\n\tmsa311_set_pwr_mode(msa311, MSA311_PWR_MODE_SUSPEND);\n}\n\nstatic int msa311_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct msa311_priv *msa311;\n\tstruct iio_dev *indio_dev;\n\tint err;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*msa311));\n\tif (!indio_dev)\n\t\treturn dev_err_probe(dev, -ENOMEM,\n\t\t\t\t     \"IIO device allocation failed\\n\");\n\n\tmsa311 = iio_priv(indio_dev);\n\tmsa311->dev = dev;\n\ti2c_set_clientdata(i2c, indio_dev);\n\n\terr = msa311_regmap_init(msa311);\n\tif (err)\n\t\treturn err;\n\n\tmutex_init(&msa311->lock);\n\n\terr = devm_regulator_get_enable(dev, \"vdd\");\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"can't get vdd supply\\n\");\n\n\terr = msa311_check_partid(msa311);\n\tif (err)\n\t\treturn err;\n\n\terr = msa311_soft_reset(msa311);\n\tif (err)\n\t\treturn err;\n\n\terr = msa311_set_pwr_mode(msa311, MSA311_PWR_MODE_NORMAL);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"failed to power on device\\n\");\n\n\t \n\terr = devm_add_action_or_reset(dev, msa311_powerdown, msa311);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"can't add powerdown action\\n\");\n\n\terr = pm_runtime_set_active(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_pm_runtime_enable(dev);\n\tif (err)\n\t\treturn err;\n\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_autosuspend_delay(dev, MSA311_PWR_SLEEP_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\n\terr = msa311_chip_init(msa311);\n\tif (err)\n\t\treturn err;\n\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = msa311_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(msa311_channels);\n\tindio_dev->name = msa311->chip_name;\n\tindio_dev->info = &msa311_info;\n\n\terr = devm_iio_triggered_buffer_setup(dev, indio_dev,\n\t\t\t\t\t      iio_pollfunc_store_time,\n\t\t\t\t\t      msa311_buffer_thread,\n\t\t\t\t\t      &msa311_buffer_setup_ops);\n\tif (err)\n\t\treturn dev_err_probe(dev, err,\n\t\t\t\t     \"can't setup IIO trigger buffer\\n\");\n\n\terr = msa311_setup_interrupts(msa311);\n\tif (err)\n\t\treturn err;\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\terr = devm_iio_device_register(dev, indio_dev);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"IIO device register failed\\n\");\n\n\treturn 0;\n}\n\nstatic int msa311_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct msa311_priv *msa311 = iio_priv(indio_dev);\n\tint err;\n\n\tmutex_lock(&msa311->lock);\n\terr = msa311_set_pwr_mode(msa311, MSA311_PWR_MODE_SUSPEND);\n\tmutex_unlock(&msa311->lock);\n\tif (err)\n\t\tdev_err(dev, \"failed to power off device (%pe)\\n\",\n\t\t\tERR_PTR(err));\n\n\treturn err;\n}\n\nstatic int msa311_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct msa311_priv *msa311 = iio_priv(indio_dev);\n\tint err;\n\n\tmutex_lock(&msa311->lock);\n\terr = msa311_set_pwr_mode(msa311, MSA311_PWR_MODE_NORMAL);\n\tmutex_unlock(&msa311->lock);\n\tif (err)\n\t\tdev_err(dev, \"failed to power on device (%pe)\\n\",\n\t\t\tERR_PTR(err));\n\n\treturn err;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(msa311_pm_ops, msa311_runtime_suspend,\n\t\t\t\t msa311_runtime_resume, NULL);\n\nstatic const struct i2c_device_id msa311_i2c_id[] = {\n\t{ .name = \"msa311\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, msa311_i2c_id);\n\nstatic const struct of_device_id msa311_of_match[] = {\n\t{ .compatible = \"memsensing,msa311\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, msa311_of_match);\n\nstatic struct i2c_driver msa311_driver = {\n\t.driver = {\n\t\t.name = \"msa311\",\n\t\t.of_match_table = msa311_of_match,\n\t\t.pm = pm_ptr(&msa311_pm_ops),\n\t},\n\t.probe\t\t= msa311_probe,\n\t.id_table\t= msa311_i2c_id,\n};\nmodule_i2c_driver(msa311_driver);\n\nMODULE_AUTHOR(\"Dmitry Rokosov <ddrokosov@sberdevices.ru>\");\nMODULE_DESCRIPTION(\"MEMSensing MSA311 3-axis accelerometer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}