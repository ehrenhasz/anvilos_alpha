{
  "module_name": "da280.c",
  "hash_id": "59707c293a13eaaabaa7e27d702f5fd215e08e3640f328125ac8a57ee735f626",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/da280.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/byteorder/generic.h>\n\n#define DA280_REG_CHIP_ID\t\t0x01\n#define DA280_REG_ACC_X_LSB\t\t0x02\n#define DA280_REG_ACC_Y_LSB\t\t0x04\n#define DA280_REG_ACC_Z_LSB\t\t0x06\n#define DA280_REG_MODE_BW\t\t0x11\n\n#define DA280_CHIP_ID\t\t\t0x13\n#define DA280_MODE_ENABLE\t\t0x1e\n#define DA280_MODE_DISABLE\t\t0x9e\n\nenum da280_chipset { da217, da226, da280 };\n\n \n\nstatic const int da280_nscale = 2395019;\n\n#define DA280_CHANNEL(reg, axis) {\t\\\n\t.type = IIO_ACCEL,\t\\\n\t.address = reg,\t\\\n\t.modified = 1,\t\\\n\t.channel2 = IIO_MOD_##axis,\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n}\n\nstatic const struct iio_chan_spec da280_channels[] = {\n\tDA280_CHANNEL(DA280_REG_ACC_X_LSB, X),\n\tDA280_CHANNEL(DA280_REG_ACC_Y_LSB, Y),\n\tDA280_CHANNEL(DA280_REG_ACC_Z_LSB, Z),\n};\n\nstruct da280_data {\n\tstruct i2c_client *client;\n};\n\nstatic int da280_enable(struct i2c_client *client, bool enable)\n{\n\tu8 data = enable ? DA280_MODE_ENABLE : DA280_MODE_DISABLE;\n\n\treturn i2c_smbus_write_byte_data(client, DA280_REG_MODE_BW, data);\n}\n\nstatic int da280_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tstruct da280_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = i2c_smbus_read_word_data(data->client, chan->address);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\t*val = (short)ret >> 2;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = da280_nscale;\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info da280_info = {\n\t.read_raw\t= da280_read_raw,\n};\n\nstatic enum da280_chipset da280_match_acpi_device(struct device *dev)\n{\n\tconst struct acpi_device_id *id;\n\n\tid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\tif (!id)\n\t\treturn -EINVAL;\n\n\treturn (enum da280_chipset) id->driver_data;\n}\n\nstatic void da280_disable(void *client)\n{\n\tda280_enable(client, false);\n}\n\nstatic int da280_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\tstruct da280_data *data;\n\tenum da280_chipset chip;\n\n\tret = i2c_smbus_read_byte_data(client, DA280_REG_CHIP_ID);\n\tif (ret != DA280_CHIP_ID)\n\t\treturn (ret < 0) ? ret : -ENODEV;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\n\tindio_dev->info = &da280_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = da280_channels;\n\n\tif (ACPI_HANDLE(&client->dev)) {\n\t\tchip = da280_match_acpi_device(&client->dev);\n\t} else {\n\t\tchip = id->driver_data;\n\t}\n\n\tif (chip == da217) {\n\t\tindio_dev->name = \"da217\";\n\t\tindio_dev->num_channels = 3;\n\t} else if (chip == da226) {\n\t\tindio_dev->name = \"da226\";\n\t\tindio_dev->num_channels = 2;\n\t} else {\n\t\tindio_dev->name = \"da280\";\n\t\tindio_dev->num_channels = 3;\n\t}\n\n\tret = da280_enable(client, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&client->dev, da280_disable, client);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic int da280_suspend(struct device *dev)\n{\n\treturn da280_enable(to_i2c_client(dev), false);\n}\n\nstatic int da280_resume(struct device *dev)\n{\n\treturn da280_enable(to_i2c_client(dev), true);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(da280_pm_ops, da280_suspend, da280_resume);\n\nstatic const struct acpi_device_id da280_acpi_match[] = {\n\t{\"NSA2513\", da217},\n\t{\"MIRAACC\", da280},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, da280_acpi_match);\n\nstatic const struct i2c_device_id da280_i2c_id[] = {\n\t{ \"da217\", da217 },\n\t{ \"da226\", da226 },\n\t{ \"da280\", da280 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, da280_i2c_id);\n\nstatic struct i2c_driver da280_driver = {\n\t.driver = {\n\t\t.name = \"da280\",\n\t\t.acpi_match_table = ACPI_PTR(da280_acpi_match),\n\t\t.pm = pm_sleep_ptr(&da280_pm_ops),\n\t},\n\t.probe\t\t= da280_probe,\n\t.id_table\t= da280_i2c_id,\n};\n\nmodule_i2c_driver(da280_driver);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"MiraMEMS DA280 3-Axis Accelerometer driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}