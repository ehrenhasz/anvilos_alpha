{
  "module_name": "dmard10.c",
  "hash_id": "ec8daa1c2031a577c7f700a9d41348283effa8e1266aa91b7e643ff549b23c33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/dmard10.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/byteorder/generic.h>\n\n#define DMARD10_REG_ACTR\t\t\t0x00\n#define DMARD10_REG_AFEM\t\t\t0x0c\n#define DMARD10_REG_STADR\t\t\t0x12\n#define DMARD10_REG_STAINT\t\t\t0x1c\n#define DMARD10_REG_MISC2\t\t\t0x1f\n#define DMARD10_REG_PD\t\t\t\t0x21\n\n#define DMARD10_MODE_OFF\t\t\t0x00\n#define DMARD10_MODE_STANDBY\t\t\t0x02\n#define DMARD10_MODE_ACTIVE\t\t\t0x06\n#define DMARD10_MODE_READ_OTP\t\t\t0x12\n#define DMARD10_MODE_RESET_DATA_PATH\t\t0x82\n\n \n#define DMARD10_VALUE_AFEM_AFEN_NORMAL\t\t0x8f\n \n#define DMARD10_VALUE_CKSEL_ODR_100_204\t\t0x74\n \n#define DMARD10_VALUE_INTC\t\t\t0x00\n \n#define DMARD10_VALUE_TAPNS_AVE_2\t\t0x11\n\n#define DMARD10_VALUE_STADR\t\t\t0x55\n#define DMARD10_VALUE_STAINT\t\t\t0xaa\n#define DMARD10_VALUE_MISC2_OSCA_EN\t\t0x08\n#define DMARD10_VALUE_PD_RST\t\t\t0x52\n\n \n#define DMARD10_X_OFFSET\t\t\t1\n#define DMARD10_Y_OFFSET\t\t\t2\n#define DMARD10_Z_OFFSET\t\t\t3\n\n \n\nstatic const int dmard10_nscale = 76640625;\n\n#define DMARD10_CHANNEL(reg, axis) {\t\\\n\t.type = IIO_ACCEL,\t\\\n\t.address = reg,\t\\\n\t.modified = 1,\t\\\n\t.channel2 = IIO_MOD_##axis,\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n}\n\nstatic const struct iio_chan_spec dmard10_channels[] = {\n\tDMARD10_CHANNEL(DMARD10_X_OFFSET, X),\n\tDMARD10_CHANNEL(DMARD10_Y_OFFSET, Y),\n\tDMARD10_CHANNEL(DMARD10_Z_OFFSET, Z),\n};\n\nstruct dmard10_data {\n\tstruct i2c_client *client;\n};\n\n \nstatic int dmard10_reset(struct i2c_client *client)\n{\n\tunsigned char buffer[7];\n\tint ret;\n\n\t \n\tret = i2c_smbus_write_byte_data(client, DMARD10_REG_PD,\n\t\t\t\t\t\tDMARD10_VALUE_PD_RST);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbuffer[0] = DMARD10_REG_ACTR;\n\tbuffer[1] = DMARD10_MODE_STANDBY;\n\tbuffer[2] = DMARD10_MODE_READ_OTP;\n\tbuffer[3] = DMARD10_MODE_STANDBY;\n\tbuffer[4] = DMARD10_MODE_RESET_DATA_PATH;\n\tbuffer[5] = DMARD10_MODE_STANDBY;\n\tret = i2c_master_send(client, buffer, 6);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = i2c_smbus_write_byte_data(client, DMARD10_REG_MISC2,\n\t\t\t\t\t\tDMARD10_VALUE_MISC2_OSCA_EN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbuffer[0] = DMARD10_REG_AFEM;\n\tbuffer[1] = DMARD10_VALUE_AFEM_AFEN_NORMAL;\n\tbuffer[2] = DMARD10_VALUE_CKSEL_ODR_100_204;\n\tbuffer[3] = DMARD10_VALUE_INTC;\n\tbuffer[4] = DMARD10_VALUE_TAPNS_AVE_2;\n\tbuffer[5] = 0x00;  \n\tbuffer[6] = 0x07;  \n\tret = i2c_master_send(client, buffer, 7);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = i2c_smbus_write_byte_data(client, DMARD10_REG_ACTR,\n\t\t\t\t\t\tDMARD10_MODE_ACTIVE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int dmard10_shutdown(struct i2c_client *client)\n{\n\tunsigned char buffer[3];\n\n\tbuffer[0] = DMARD10_REG_ACTR;\n\tbuffer[1] = DMARD10_MODE_STANDBY;\n\tbuffer[2] = DMARD10_MODE_OFF;\n\n\treturn i2c_master_send(client, buffer, 3);\n}\n\nstatic int dmard10_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tstruct dmard10_data *data = iio_priv(indio_dev);\n\t__le16 buf[4];\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t \n\t\tret = i2c_smbus_read_i2c_block_data(data->client,\n\t\t\t\t\t\t    DMARD10_REG_STADR,\n\t\t\t\t\t\t    sizeof(buf), (u8 *)buf);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = le16_to_cpu(buf[chan->address]);\n\t\t*val = sign_extend32(ret, 12);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = dmard10_nscale;\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info dmard10_info = {\n\t.read_raw\t= dmard10_read_raw,\n};\n\nstatic void dmard10_shutdown_cleanup(void *client)\n{\n\tdmard10_shutdown(client);\n}\n\nstatic int dmard10_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\tstruct dmard10_data *data;\n\n\t \n\tret = i2c_smbus_read_byte_data(client, DMARD10_REG_STADR);\n\tif (ret != DMARD10_VALUE_STADR)\n\t\treturn (ret < 0) ? ret : -ENODEV;\n\n\tret = i2c_smbus_read_byte_data(client, DMARD10_REG_STAINT);\n\tif (ret != DMARD10_VALUE_STAINT)\n\t\treturn (ret < 0) ? ret : -ENODEV;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev) {\n\t\tdev_err(&client->dev, \"iio allocation failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\n\tindio_dev->info = &dmard10_info;\n\tindio_dev->name = \"dmard10\";\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = dmard10_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(dmard10_channels);\n\n\tret = dmard10_reset(client);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&client->dev, dmard10_shutdown_cleanup,\n\t\t\t\t       client);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic int dmard10_suspend(struct device *dev)\n{\n\treturn dmard10_shutdown(to_i2c_client(dev));\n}\n\nstatic int dmard10_resume(struct device *dev)\n{\n\treturn dmard10_reset(to_i2c_client(dev));\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(dmard10_pm_ops, dmard10_suspend,\n\t\t\t\tdmard10_resume);\n\nstatic const struct i2c_device_id dmard10_i2c_id[] = {\n\t{\"dmard10\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, dmard10_i2c_id);\n\nstatic struct i2c_driver dmard10_driver = {\n\t.driver = {\n\t\t.name = \"dmard10\",\n\t\t.pm = pm_sleep_ptr(&dmard10_pm_ops),\n\t},\n\t.probe\t\t= dmard10_probe,\n\t.id_table\t= dmard10_i2c_id,\n};\n\nmodule_i2c_driver(dmard10_driver);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"Domintech ARD10 3-Axis Accelerometer driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}