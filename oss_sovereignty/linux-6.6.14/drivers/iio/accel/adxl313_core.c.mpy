{
  "module_name": "adxl313_core.c",
  "hash_id": "347949dcd5ac2cca52262fa657866c6ca827e854234aa5a7fd6fa7473394acff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/adxl313_core.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n#include \"adxl313.h\"\n\nstatic const struct regmap_range adxl312_readable_reg_range[] = {\n\tregmap_reg_range(ADXL313_REG_DEVID0, ADXL313_REG_DEVID0),\n\tregmap_reg_range(ADXL313_REG_OFS_AXIS(0), ADXL313_REG_OFS_AXIS(2)),\n\tregmap_reg_range(ADXL313_REG_THRESH_ACT, ADXL313_REG_ACT_INACT_CTL),\n\tregmap_reg_range(ADXL313_REG_BW_RATE, ADXL313_REG_FIFO_STATUS),\n};\n\nstatic const struct regmap_range adxl313_readable_reg_range[] = {\n\tregmap_reg_range(ADXL313_REG_DEVID0, ADXL313_REG_XID),\n\tregmap_reg_range(ADXL313_REG_SOFT_RESET, ADXL313_REG_SOFT_RESET),\n\tregmap_reg_range(ADXL313_REG_OFS_AXIS(0), ADXL313_REG_OFS_AXIS(2)),\n\tregmap_reg_range(ADXL313_REG_THRESH_ACT, ADXL313_REG_ACT_INACT_CTL),\n\tregmap_reg_range(ADXL313_REG_BW_RATE, ADXL313_REG_FIFO_STATUS),\n};\n\nconst struct regmap_access_table adxl312_readable_regs_table = {\n\t.yes_ranges = adxl312_readable_reg_range,\n\t.n_yes_ranges = ARRAY_SIZE(adxl312_readable_reg_range),\n};\nEXPORT_SYMBOL_NS_GPL(adxl312_readable_regs_table, IIO_ADXL313);\n\nconst struct regmap_access_table adxl313_readable_regs_table = {\n\t.yes_ranges = adxl313_readable_reg_range,\n\t.n_yes_ranges = ARRAY_SIZE(adxl313_readable_reg_range),\n};\nEXPORT_SYMBOL_NS_GPL(adxl313_readable_regs_table, IIO_ADXL313);\n\nconst struct regmap_access_table adxl314_readable_regs_table = {\n\t.yes_ranges = adxl312_readable_reg_range,\n\t.n_yes_ranges = ARRAY_SIZE(adxl312_readable_reg_range),\n};\nEXPORT_SYMBOL_NS_GPL(adxl314_readable_regs_table, IIO_ADXL313);\n\nstatic int adxl312_check_id(struct device *dev,\n\t\t\t    struct adxl313_data *data)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(data->regmap, ADXL313_REG_DEVID0, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tif (regval != ADXL313_DEVID0_ADXL312_314)\n\t\tdev_warn(dev, \"Invalid manufacturer ID: %#02x\\n\", regval);\n\n\treturn 0;\n}\n\nstatic int adxl313_check_id(struct device *dev,\n\t\t\t    struct adxl313_data *data)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(data->regmap, ADXL313_REG_DEVID0, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tif (regval != ADXL313_DEVID0)\n\t\tdev_warn(dev, \"Invalid manufacturer ID: 0x%02x\\n\", regval);\n\n\t \n\tif (regval == ADXL313_DEVID0) {\n\t\tret = regmap_read(data->regmap, ADXL313_REG_DEVID1, &regval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (regval != ADXL313_DEVID1)\n\t\t\tdev_warn(dev, \"Invalid mems ID: 0x%02x\\n\", regval);\n\n\t\tret = regmap_read(data->regmap, ADXL313_REG_PARTID, &regval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (regval != ADXL313_PARTID)\n\t\t\tdev_warn(dev, \"Invalid device ID: 0x%02x\\n\", regval);\n\t}\n\n\treturn 0;\n}\n\nconst struct adxl313_chip_info adxl31x_chip_info[] = {\n\t[ADXL312] = {\n\t\t.name = \"adxl312\",\n\t\t.type = ADXL312,\n\t\t.scale_factor = 28425072,\n\t\t.variable_range = true,\n\t\t.soft_reset = false,\n\t\t.check_id = &adxl312_check_id,\n\t},\n\t[ADXL313] = {\n\t\t.name = \"adxl313\",\n\t\t.type = ADXL313,\n\t\t.scale_factor = 9576806,\n\t\t.variable_range = true,\n\t\t.soft_reset = true,\n\t\t.check_id = &adxl313_check_id,\n\t},\n\t[ADXL314] = {\n\t\t.name = \"adxl314\",\n\t\t.type = ADXL314,\n\t\t.scale_factor = 478858719,\n\t\t.variable_range = false,\n\t\t.soft_reset = false,\n\t\t.check_id = &adxl312_check_id,\n\t},\n};\nEXPORT_SYMBOL_NS_GPL(adxl31x_chip_info, IIO_ADXL313);\n\nstatic const struct regmap_range adxl312_writable_reg_range[] = {\n\tregmap_reg_range(ADXL313_REG_OFS_AXIS(0), ADXL313_REG_OFS_AXIS(2)),\n\tregmap_reg_range(ADXL313_REG_THRESH_ACT, ADXL313_REG_ACT_INACT_CTL),\n\tregmap_reg_range(ADXL313_REG_BW_RATE, ADXL313_REG_INT_MAP),\n\tregmap_reg_range(ADXL313_REG_DATA_FORMAT, ADXL313_REG_DATA_FORMAT),\n\tregmap_reg_range(ADXL313_REG_FIFO_CTL, ADXL313_REG_FIFO_CTL),\n};\n\nstatic const struct regmap_range adxl313_writable_reg_range[] = {\n\tregmap_reg_range(ADXL313_REG_SOFT_RESET, ADXL313_REG_SOFT_RESET),\n\tregmap_reg_range(ADXL313_REG_OFS_AXIS(0), ADXL313_REG_OFS_AXIS(2)),\n\tregmap_reg_range(ADXL313_REG_THRESH_ACT, ADXL313_REG_ACT_INACT_CTL),\n\tregmap_reg_range(ADXL313_REG_BW_RATE, ADXL313_REG_INT_MAP),\n\tregmap_reg_range(ADXL313_REG_DATA_FORMAT, ADXL313_REG_DATA_FORMAT),\n\tregmap_reg_range(ADXL313_REG_FIFO_CTL, ADXL313_REG_FIFO_CTL),\n};\n\nconst struct regmap_access_table adxl312_writable_regs_table = {\n\t.yes_ranges = adxl312_writable_reg_range,\n\t.n_yes_ranges = ARRAY_SIZE(adxl312_writable_reg_range),\n};\nEXPORT_SYMBOL_NS_GPL(adxl312_writable_regs_table, IIO_ADXL313);\n\nconst struct regmap_access_table adxl313_writable_regs_table = {\n\t.yes_ranges = adxl313_writable_reg_range,\n\t.n_yes_ranges = ARRAY_SIZE(adxl313_writable_reg_range),\n};\nEXPORT_SYMBOL_NS_GPL(adxl313_writable_regs_table, IIO_ADXL313);\n\nconst struct regmap_access_table adxl314_writable_regs_table = {\n\t.yes_ranges = adxl312_writable_reg_range,\n\t.n_yes_ranges = ARRAY_SIZE(adxl312_writable_reg_range),\n};\nEXPORT_SYMBOL_NS_GPL(adxl314_writable_regs_table, IIO_ADXL313);\n\nstatic const int adxl313_odr_freqs[][2] = {\n\t[0] = { 6, 250000 },\n\t[1] = { 12, 500000 },\n\t[2] = { 25, 0 },\n\t[3] = { 50, 0 },\n\t[4] = { 100, 0 },\n\t[5] = { 200, 0 },\n\t[6] = { 400, 0 },\n\t[7] = { 800, 0 },\n\t[8] = { 1600, 0 },\n\t[9] = { 3200, 0 },\n};\n\n#define ADXL313_ACCEL_CHANNEL(index, axis) {\t\t\t\t\\\n\t.type = IIO_ACCEL,\t\t\t\t\t\t\\\n\t.address = index,\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##axis,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_CALIBBIAS),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\t\\\n\t\t\t\t    BIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n\t.info_mask_shared_by_type_available =\t\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.realbits = 13,\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec adxl313_channels[] = {\n\tADXL313_ACCEL_CHANNEL(0, X),\n\tADXL313_ACCEL_CHANNEL(1, Y),\n\tADXL313_ACCEL_CHANNEL(2, Z),\n};\n\nstatic int adxl313_set_odr(struct adxl313_data *data,\n\t\t\t   unsigned int freq1, unsigned int freq2)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(adxl313_odr_freqs); i++) {\n\t\tif (adxl313_odr_freqs[i][0] == freq1 &&\n\t\t    adxl313_odr_freqs[i][1] == freq2)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(adxl313_odr_freqs))\n\t\treturn -EINVAL;\n\n\treturn regmap_update_bits(data->regmap, ADXL313_REG_BW_RATE,\n\t\t\t\t  ADXL313_RATE_MSK,\n\t\t\t\t  FIELD_PREP(ADXL313_RATE_MSK, ADXL313_RATE_BASE + i));\n}\n\nstatic int adxl313_read_axis(struct adxl313_data *data,\n\t\t\t     struct iio_chan_spec const *chan)\n{\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\n\tret = regmap_bulk_read(data->regmap,\n\t\t\t       ADXL313_REG_DATA_AXIS(chan->address),\n\t\t\t       &data->transf_buf, sizeof(data->transf_buf));\n\tif (ret)\n\t\tgoto unlock_ret;\n\n\tret = le16_to_cpu(data->transf_buf);\n\nunlock_ret:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int adxl313_read_freq_avail(struct iio_dev *indio_dev,\n\t\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t\t   const int **vals, int *type, int *length,\n\t\t\t\t   long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*vals = (const int *)adxl313_odr_freqs;\n\t\t*length = ARRAY_SIZE(adxl313_odr_freqs) * 2;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxl313_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct adxl313_data *data = iio_priv(indio_dev);\n\tunsigned int regval;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = adxl313_read_axis(data, chan);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = sign_extend32(ret, chan->scan_type.realbits - 1);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\n\t\t*val2 = data->chip_info->scale_factor;\n\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = regmap_read(data->regmap,\n\t\t\t\t  ADXL313_REG_OFS_AXIS(chan->address), &regval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\t*val = sign_extend32(regval, 7) * 4;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = regmap_read(data->regmap, ADXL313_REG_BW_RATE, &regval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = FIELD_GET(ADXL313_RATE_MSK, regval) - ADXL313_RATE_BASE;\n\t\t*val = adxl313_odr_freqs[ret][0];\n\t\t*val2 = adxl313_odr_freqs[ret][1];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxl313_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct adxl313_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\t \n\t\tif (clamp_val(val, -128 * 4, 127 * 4) != val)\n\t\t\treturn -EINVAL;\n\n\t\treturn regmap_write(data->regmap,\n\t\t\t\t    ADXL313_REG_OFS_AXIS(chan->address),\n\t\t\t\t    val / 4);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn adxl313_set_odr(data, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info adxl313_info = {\n\t.read_raw\t= adxl313_read_raw,\n\t.write_raw\t= adxl313_write_raw,\n\t.read_avail\t= adxl313_read_freq_avail,\n};\n\nstatic int adxl313_setup(struct device *dev, struct adxl313_data *data,\n\t\t\t int (*setup)(struct device *, struct regmap *))\n{\n\tint ret;\n\n\t \n\tif (data->chip_info->soft_reset) {\n\t\tret = regmap_write(data->regmap, ADXL313_REG_SOFT_RESET,\n\t\t\t\t   ADXL313_SOFT_RESET);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (setup) {\n\t\tret = setup(dev, data->regmap);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = data->chip_info->check_id(dev, data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (data->chip_info->variable_range) {\n\t\tret = regmap_update_bits(data->regmap, ADXL313_REG_DATA_FORMAT,\n\t\t\t\t\t ADXL313_RANGE_MSK,\n\t\t\t\t\t FIELD_PREP(ADXL313_RANGE_MSK, ADXL313_RANGE_MAX));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_update_bits(data->regmap, ADXL313_REG_DATA_FORMAT,\n\t\t\t\t\t ADXL313_FULL_RES, ADXL313_FULL_RES);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\treturn regmap_update_bits(data->regmap, ADXL313_REG_POWER_CTL,\n\t\t\t\t  ADXL313_POWER_CTL_MSK,\n\t\t\t\t  ADXL313_MEASUREMENT_MODE);\n}\n\n \nint adxl313_core_probe(struct device *dev,\n\t\t       struct regmap *regmap,\n\t\t       const struct adxl313_chip_info *chip_info,\n\t\t       int (*setup)(struct device *, struct regmap *))\n{\n\tstruct adxl313_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->regmap = regmap;\n\tdata->chip_info = chip_info;\n\n\tmutex_init(&data->lock);\n\n\tindio_dev->name = chip_info->name;\n\tindio_dev->info = &adxl313_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = adxl313_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adxl313_channels);\n\n\tret = adxl313_setup(dev, data, setup);\n\tif (ret) {\n\t\tdev_err(dev, \"ADXL313 setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(adxl313_core_probe, IIO_ADXL313);\n\nMODULE_AUTHOR(\"Lucas Stankus <lucas.p.stankus@gmail.com>\");\nMODULE_DESCRIPTION(\"ADXL313 3-Axis Digital Accelerometer core driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}