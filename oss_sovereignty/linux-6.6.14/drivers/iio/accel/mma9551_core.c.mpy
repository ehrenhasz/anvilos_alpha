{
  "module_name": "mma9551_core.c",
  "hash_id": "f57e150f24c1a22511a18bd522f89653cfb9b1435452c7644dbc96bbff92a96f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/mma9551_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/iio/iio.h>\n#include <linux/pm_runtime.h>\n#include \"mma9551_core.h\"\n\n \n#define MMA9551_CMD_READ_VERSION_INFO\t0x00\n#define MMA9551_CMD_READ_CONFIG\t\t0x10\n#define MMA9551_CMD_WRITE_CONFIG\t0x20\n#define MMA9551_CMD_READ_STATUS\t\t0x30\n\n \n#define MMA9551_RESPONSE_COCO\t\tBIT(7)\n\n \n#define MMA9551_MCI_ERROR_NONE\t\t\t0x00\n#define MMA9551_MCI_ERROR_PARAM\t\t\t0x04\n#define MMA9551_MCI_INVALID_COUNT\t\t0x19\n#define MMA9551_MCI_ERROR_COMMAND\t\t0x1C\n#define MMA9551_MCI_ERROR_INVALID_LENGTH\t0x21\n#define MMA9551_MCI_ERROR_FIFO_BUSY\t\t0x22\n#define MMA9551_MCI_ERROR_FIFO_ALLOCATED\t0x23\n#define MMA9551_MCI_ERROR_FIFO_OVERSIZE\t\t0x24\n\n \n#define MMA9551_GPIO_POL_MSB\t\t0x08\n#define MMA9551_GPIO_POL_LSB\t\t0x09\n\n \n#define MMA9551_SLEEP_CFG\t\t0x06\n#define MMA9551_SLEEP_CFG_SNCEN\t\tBIT(0)\n#define MMA9551_SLEEP_CFG_FLEEN\t\tBIT(1)\n#define MMA9551_SLEEP_CFG_SCHEN\t\tBIT(2)\n\n \n#define MMA9551_AFE_X_ACCEL_REG\t\t0x00\n#define MMA9551_AFE_Y_ACCEL_REG\t\t0x02\n#define MMA9551_AFE_Z_ACCEL_REG\t\t0x04\n\n \n#define MMA9551_RSC_RESET\t\t0x00\n#define MMA9551_RSC_OFFSET(mask)\t(3 - (ffs(mask) - 1) / 8)\n#define MMA9551_RSC_VAL(mask)\t\t(mask >> (((ffs(mask) - 1) / 8) * 8))\n\n \n#define MMA9551_MAILBOX_CTRL_REGS\t4\n#define MMA9551_MAX_MAILBOX_DATA_REGS\t28\n#define MMA9551_MAILBOX_REGS\t\t32\n\n#define MMA9551_I2C_READ_RETRIES\t5\n#define MMA9551_I2C_READ_DELAY\t50\t \n\nstruct mma9551_mbox_request {\n\tu8 start_mbox;\t\t \n\tu8 app_id;\n\t \n\tu8 cmd_off;\n\tu8 lower_off;\n\tu8 nbytes;\n\tu8 buf[MMA9551_MAX_MAILBOX_DATA_REGS - 1];\n} __packed;\n\nstruct mma9551_mbox_response {\n\tu8 app_id;\n\t \n\tu8 coco_err;\n\tu8 nbytes;\n\tu8 req_bytes;\n\tu8 buf[MMA9551_MAX_MAILBOX_DATA_REGS];\n} __packed;\n\nstruct mma9551_version_info {\n\t__be32 device_id;\n\tu8 rom_version[2];\n\tu8 fw_version[2];\n\tu8 hw_version[2];\n\tu8 fw_build[2];\n};\n\nstatic int mma9551_transfer(struct i2c_client *client,\n\t\t\t    u8 app_id, u8 command, u16 offset,\n\t\t\t    u8 *inbytes, int num_inbytes,\n\t\t\t    u8 *outbytes, int num_outbytes)\n{\n\tstruct mma9551_mbox_request req;\n\tstruct mma9551_mbox_response rsp;\n\tstruct i2c_msg in, out;\n\tu8 req_len, err_code;\n\tint ret, retries;\n\n\tif (offset >= 1 << 12) {\n\t\tdev_err(&client->dev, \"register offset too large\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treq_len = 1 + MMA9551_MAILBOX_CTRL_REGS + num_inbytes;\n\treq.start_mbox = 0;\n\treq.app_id = app_id;\n\treq.cmd_off = command | (offset >> 8);\n\treq.lower_off = offset;\n\n\tif (command == MMA9551_CMD_WRITE_CONFIG)\n\t\treq.nbytes = num_inbytes;\n\telse\n\t\treq.nbytes = num_outbytes;\n\tif (num_inbytes)\n\t\tmemcpy(req.buf, inbytes, num_inbytes);\n\n\tout.addr = client->addr;\n\tout.flags = 0;\n\tout.len = req_len;\n\tout.buf = (u8 *)&req;\n\n\tret = i2c_transfer(client->adapter, &out, 1);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"i2c write failed\\n\");\n\t\treturn ret;\n\t}\n\n\tretries = MMA9551_I2C_READ_RETRIES;\n\tdo {\n\t\tudelay(MMA9551_I2C_READ_DELAY);\n\n\t\tin.addr = client->addr;\n\t\tin.flags = I2C_M_RD;\n\t\tin.len = sizeof(rsp);\n\t\tin.buf = (u8 *)&rsp;\n\n\t\tret = i2c_transfer(client->adapter, &in, 1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"i2c read failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (rsp.coco_err & MMA9551_RESPONSE_COCO)\n\t\t\tbreak;\n\t} while (--retries > 0);\n\n\tif (retries == 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"timed out while waiting for command response\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (rsp.app_id != app_id) {\n\t\tdev_err(&client->dev,\n\t\t\t\"app_id mismatch in response got %02x expected %02x\\n\",\n\t\t\trsp.app_id, app_id);\n\t\treturn -EINVAL;\n\t}\n\n\terr_code = rsp.coco_err & ~MMA9551_RESPONSE_COCO;\n\tif (err_code != MMA9551_MCI_ERROR_NONE) {\n\t\tdev_err(&client->dev, \"read returned error %x\\n\", err_code);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rsp.nbytes != rsp.req_bytes) {\n\t\tdev_err(&client->dev,\n\t\t\t\"output length mismatch got %d expected %d\\n\",\n\t\t\trsp.nbytes, rsp.req_bytes);\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_outbytes)\n\t\tmemcpy(outbytes, rsp.buf, num_outbytes);\n\n\treturn 0;\n}\n\n \nint mma9551_read_config_byte(struct i2c_client *client, u8 app_id,\n\t\t\t     u16 reg, u8 *val)\n{\n\treturn mma9551_transfer(client, app_id, MMA9551_CMD_READ_CONFIG,\n\t\t\t\treg, NULL, 0, val, 1);\n}\nEXPORT_SYMBOL_NS(mma9551_read_config_byte, IIO_MMA9551);\n\n \nint mma9551_write_config_byte(struct i2c_client *client, u8 app_id,\n\t\t\t      u16 reg, u8 val)\n{\n\treturn mma9551_transfer(client, app_id, MMA9551_CMD_WRITE_CONFIG, reg,\n\t\t\t\t&val, 1, NULL, 0);\n}\nEXPORT_SYMBOL_NS(mma9551_write_config_byte, IIO_MMA9551);\n\n \nint mma9551_read_status_byte(struct i2c_client *client, u8 app_id,\n\t\t\t     u16 reg, u8 *val)\n{\n\treturn mma9551_transfer(client, app_id, MMA9551_CMD_READ_STATUS,\n\t\t\t\treg, NULL, 0, val, 1);\n}\nEXPORT_SYMBOL_NS(mma9551_read_status_byte, IIO_MMA9551);\n\n \nint mma9551_read_config_word(struct i2c_client *client, u8 app_id,\n\t\t\t     u16 reg, u16 *val)\n{\n\tint ret;\n\t__be16 v;\n\n\tret = mma9551_transfer(client, app_id, MMA9551_CMD_READ_CONFIG,\n\t\t\t       reg, NULL, 0, (u8 *)&v, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = be16_to_cpu(v);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(mma9551_read_config_word, IIO_MMA9551);\n\n \nint mma9551_write_config_word(struct i2c_client *client, u8 app_id,\n\t\t\t      u16 reg, u16 val)\n{\n\t__be16 v = cpu_to_be16(val);\n\n\treturn mma9551_transfer(client, app_id, MMA9551_CMD_WRITE_CONFIG, reg,\n\t\t\t\t(u8 *)&v, 2, NULL, 0);\n}\nEXPORT_SYMBOL_NS(mma9551_write_config_word, IIO_MMA9551);\n\n \nint mma9551_read_status_word(struct i2c_client *client, u8 app_id,\n\t\t\t     u16 reg, u16 *val)\n{\n\tint ret;\n\t__be16 v;\n\n\tret = mma9551_transfer(client, app_id, MMA9551_CMD_READ_STATUS,\n\t\t\t       reg, NULL, 0, (u8 *)&v, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = be16_to_cpu(v);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(mma9551_read_status_word, IIO_MMA9551);\n\n \nint mma9551_read_config_words(struct i2c_client *client, u8 app_id,\n\t\t\t      u16 reg, u8 len, u16 *buf)\n{\n\tint ret, i;\n\t__be16 be_buf[MMA9551_MAX_MAILBOX_DATA_REGS / 2];\n\n\tif (len > ARRAY_SIZE(be_buf)) {\n\t\tdev_err(&client->dev, \"Invalid buffer size %d\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\tret = mma9551_transfer(client, app_id, MMA9551_CMD_READ_CONFIG,\n\t\t\t       reg, NULL, 0, (u8 *)be_buf, len * sizeof(u16));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i] = be16_to_cpu(be_buf[i]);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(mma9551_read_config_words, IIO_MMA9551);\n\n \nint mma9551_read_status_words(struct i2c_client *client, u8 app_id,\n\t\t\t      u16 reg, u8 len, u16 *buf)\n{\n\tint ret, i;\n\t__be16 be_buf[MMA9551_MAX_MAILBOX_DATA_REGS / 2];\n\n\tif (len > ARRAY_SIZE(be_buf)) {\n\t\tdev_err(&client->dev, \"Invalid buffer size %d\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\tret = mma9551_transfer(client, app_id, MMA9551_CMD_READ_STATUS,\n\t\t\t       reg, NULL, 0, (u8 *)be_buf, len * sizeof(u16));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i] = be16_to_cpu(be_buf[i]);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(mma9551_read_status_words, IIO_MMA9551);\n\n \nint mma9551_write_config_words(struct i2c_client *client, u8 app_id,\n\t\t\t       u16 reg, u8 len, u16 *buf)\n{\n\tint i;\n\t__be16 be_buf[(MMA9551_MAX_MAILBOX_DATA_REGS - 1) / 2];\n\n\tif (len > ARRAY_SIZE(be_buf)) {\n\t\tdev_err(&client->dev, \"Invalid buffer size %d\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < len; i++)\n\t\tbe_buf[i] = cpu_to_be16(buf[i]);\n\n\treturn mma9551_transfer(client, app_id, MMA9551_CMD_WRITE_CONFIG,\n\t\t\t\treg, (u8 *)be_buf, len * sizeof(u16), NULL, 0);\n}\nEXPORT_SYMBOL_NS(mma9551_write_config_words, IIO_MMA9551);\n\n \nint mma9551_update_config_bits(struct i2c_client *client, u8 app_id,\n\t\t\t       u16 reg, u8 mask, u8 val)\n{\n\tint ret;\n\tu8 tmp, orig;\n\n\tret = mma9551_read_config_byte(client, app_id, reg, &orig);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttmp = orig & ~mask;\n\ttmp |= val & mask;\n\n\tif (tmp == orig)\n\t\treturn 0;\n\n\treturn mma9551_write_config_byte(client, app_id, reg, tmp);\n}\nEXPORT_SYMBOL_NS(mma9551_update_config_bits, IIO_MMA9551);\n\n \nint mma9551_gpio_config(struct i2c_client *client, enum mma9551_gpio_pin pin,\n\t\t\tu8 app_id, u8 bitnum, int polarity)\n{\n\tu8 reg, pol_mask, pol_val;\n\tint ret;\n\n\tif (pin > mma9551_gpio_max) {\n\t\tdev_err(&client->dev, \"bad GPIO pin\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treg = pin * 2;\n\n\tret = mma9551_write_config_byte(client, MMA9551_APPID_GPIO,\n\t\t\t\t\treg, app_id);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"error setting GPIO app_id\\n\");\n\t\treturn ret;\n\t}\n\n\tret = mma9551_write_config_byte(client, MMA9551_APPID_GPIO,\n\t\t\t\t\treg + 1, bitnum);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"error setting GPIO bit number\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (pin) {\n\tcase mma9551_gpio6:\n\t\treg = MMA9551_GPIO_POL_LSB;\n\t\tpol_mask = 1 << 6;\n\t\tbreak;\n\tcase mma9551_gpio7:\n\t\treg = MMA9551_GPIO_POL_LSB;\n\t\tpol_mask = 1 << 7;\n\t\tbreak;\n\tcase mma9551_gpio8:\n\t\treg = MMA9551_GPIO_POL_MSB;\n\t\tpol_mask = 1 << 0;\n\t\tbreak;\n\tcase mma9551_gpio9:\n\t\treg = MMA9551_GPIO_POL_MSB;\n\t\tpol_mask = 1 << 1;\n\t\tbreak;\n\t}\n\tpol_val = polarity ? pol_mask : 0;\n\n\tret = mma9551_update_config_bits(client, MMA9551_APPID_GPIO, reg,\n\t\t\t\t\t pol_mask, pol_val);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"error setting GPIO polarity\\n\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS(mma9551_gpio_config, IIO_MMA9551);\n\n \nint mma9551_read_version(struct i2c_client *client)\n{\n\tstruct mma9551_version_info info;\n\tint ret;\n\n\tret = mma9551_transfer(client, MMA9551_APPID_VERSION, 0x00, 0x00,\n\t\t\t       NULL, 0, (u8 *)&info, sizeof(info));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(&client->dev, \"device ID 0x%x, firmware version %02x.%02x\\n\",\n\t\t be32_to_cpu(info.device_id), info.fw_version[0],\n\t\t info.fw_version[1]);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(mma9551_read_version, IIO_MMA9551);\n\n \nint mma9551_set_device_state(struct i2c_client *client, bool enable)\n{\n\treturn mma9551_update_config_bits(client, MMA9551_APPID_SLEEP_WAKE,\n\t\t\t\t\t  MMA9551_SLEEP_CFG,\n\t\t\t\t\t  MMA9551_SLEEP_CFG_SNCEN |\n\t\t\t\t\t  MMA9551_SLEEP_CFG_FLEEN |\n\t\t\t\t\t  MMA9551_SLEEP_CFG_SCHEN,\n\t\t\t\t\t  enable ? MMA9551_SLEEP_CFG_SCHEN |\n\t\t\t\t\t  MMA9551_SLEEP_CFG_FLEEN :\n\t\t\t\t\t  MMA9551_SLEEP_CFG_SNCEN);\n}\nEXPORT_SYMBOL_NS(mma9551_set_device_state, IIO_MMA9551);\n\n \nint mma9551_set_power_state(struct i2c_client *client, bool on)\n{\n#ifdef CONFIG_PM\n\tint ret;\n\n\tif (on)\n\t\tret = pm_runtime_resume_and_get(&client->dev);\n\telse {\n\t\tpm_runtime_mark_last_busy(&client->dev);\n\t\tret = pm_runtime_put_autosuspend(&client->dev);\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to change power state to %d\\n\", on);\n\n\t\treturn ret;\n\t}\n#endif\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(mma9551_set_power_state, IIO_MMA9551);\n\n \nvoid mma9551_sleep(int freq)\n{\n\tint sleep_val = 1000 / freq;\n\n\tif (sleep_val < 20)\n\t\tusleep_range(sleep_val * 1000, 20000);\n\telse\n\t\tmsleep_interruptible(sleep_val);\n}\nEXPORT_SYMBOL_NS(mma9551_sleep, IIO_MMA9551);\n\n \nint mma9551_read_accel_chan(struct i2c_client *client,\n\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t    int *val, int *val2)\n{\n\tu16 reg_addr;\n\ts16 raw_accel;\n\tint ret;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\treg_addr = MMA9551_AFE_X_ACCEL_REG;\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\treg_addr = MMA9551_AFE_Y_ACCEL_REG;\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\treg_addr = MMA9551_AFE_Z_ACCEL_REG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = mma9551_set_power_state(client, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mma9551_read_status_word(client, MMA9551_APPID_AFE,\n\t\t\t\t       reg_addr, &raw_accel);\n\tif (ret < 0)\n\t\tgoto out_poweroff;\n\n\t*val = raw_accel;\n\n\tret = IIO_VAL_INT;\n\nout_poweroff:\n\tmma9551_set_power_state(client, false);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS(mma9551_read_accel_chan, IIO_MMA9551);\n\n \nint mma9551_read_accel_scale(int *val, int *val2)\n{\n\t*val = 0;\n\t*val2 = 2440;\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\nEXPORT_SYMBOL_NS(mma9551_read_accel_scale, IIO_MMA9551);\n\n \nint mma9551_app_reset(struct i2c_client *client, u32 app_mask)\n{\n\treturn mma9551_write_config_byte(client, MMA9551_APPID_RSC,\n\t\t\t\t\t MMA9551_RSC_RESET +\n\t\t\t\t\t MMA9551_RSC_OFFSET(app_mask),\n\t\t\t\t\t MMA9551_RSC_VAL(app_mask));\n}\nEXPORT_SYMBOL_NS(mma9551_app_reset, IIO_MMA9551);\n\nMODULE_AUTHOR(\"Irina Tirdea <irina.tirdea@intel.com>\");\nMODULE_AUTHOR(\"Vlad Dogaru <vlad.dogaru@intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MMA955xL sensors core\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}