{
  "module_name": "mma8452.c",
  "hash_id": "1b7ae6ecb982cd55628481aa5fa575cc2267592a1b615b569c84bbe7f70c7779",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/mma8452.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/events.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n\n#define MMA8452_STATUS\t\t\t\t0x00\n#define  MMA8452_STATUS_DRDY\t\t\t(BIT(2) | BIT(1) | BIT(0))\n#define MMA8452_OUT_X\t\t\t\t0x01  \n#define MMA8452_OUT_Y\t\t\t\t0x03\n#define MMA8452_OUT_Z\t\t\t\t0x05\n#define MMA8452_INT_SRC\t\t\t\t0x0c\n#define MMA8452_WHO_AM_I\t\t\t0x0d\n#define MMA8452_DATA_CFG\t\t\t0x0e\n#define  MMA8452_DATA_CFG_FS_MASK\t\tGENMASK(1, 0)\n#define  MMA8452_DATA_CFG_FS_2G\t\t\t0\n#define  MMA8452_DATA_CFG_FS_4G\t\t\t1\n#define  MMA8452_DATA_CFG_FS_8G\t\t\t2\n#define  MMA8452_DATA_CFG_HPF_MASK\t\tBIT(4)\n#define MMA8452_HP_FILTER_CUTOFF\t\t0x0f\n#define  MMA8452_HP_FILTER_CUTOFF_SEL_MASK\tGENMASK(1, 0)\n#define MMA8452_FF_MT_CFG\t\t\t0x15\n#define  MMA8452_FF_MT_CFG_OAE\t\t\tBIT(6)\n#define  MMA8452_FF_MT_CFG_ELE\t\t\tBIT(7)\n#define MMA8452_FF_MT_SRC\t\t\t0x16\n#define  MMA8452_FF_MT_SRC_XHE\t\t\tBIT(1)\n#define  MMA8452_FF_MT_SRC_YHE\t\t\tBIT(3)\n#define  MMA8452_FF_MT_SRC_ZHE\t\t\tBIT(5)\n#define MMA8452_FF_MT_THS\t\t\t0x17\n#define  MMA8452_FF_MT_THS_MASK\t\t\t0x7f\n#define MMA8452_FF_MT_COUNT\t\t\t0x18\n#define MMA8452_FF_MT_CHAN_SHIFT\t\t3\n#define MMA8452_TRANSIENT_CFG\t\t\t0x1d\n#define  MMA8452_TRANSIENT_CFG_CHAN(chan)\tBIT(chan + 1)\n#define  MMA8452_TRANSIENT_CFG_HPF_BYP\t\tBIT(0)\n#define  MMA8452_TRANSIENT_CFG_ELE\t\tBIT(4)\n#define MMA8452_TRANSIENT_SRC\t\t\t0x1e\n#define  MMA8452_TRANSIENT_SRC_XTRANSE\t\tBIT(1)\n#define  MMA8452_TRANSIENT_SRC_YTRANSE\t\tBIT(3)\n#define  MMA8452_TRANSIENT_SRC_ZTRANSE\t\tBIT(5)\n#define MMA8452_TRANSIENT_THS\t\t\t0x1f\n#define  MMA8452_TRANSIENT_THS_MASK\t\tGENMASK(6, 0)\n#define MMA8452_TRANSIENT_COUNT\t\t\t0x20\n#define MMA8452_TRANSIENT_CHAN_SHIFT\t\t1\n#define MMA8452_CTRL_REG1\t\t\t0x2a\n#define  MMA8452_CTRL_ACTIVE\t\t\tBIT(0)\n#define  MMA8452_CTRL_DR_MASK\t\t\tGENMASK(5, 3)\n#define  MMA8452_CTRL_DR_SHIFT\t\t\t3\n#define  MMA8452_CTRL_DR_DEFAULT\t\t0x4  \n#define MMA8452_CTRL_REG2\t\t\t0x2b\n#define  MMA8452_CTRL_REG2_RST\t\t\tBIT(6)\n#define  MMA8452_CTRL_REG2_MODS_SHIFT\t\t3\n#define  MMA8452_CTRL_REG2_MODS_MASK\t\t0x1b\n#define MMA8452_CTRL_REG4\t\t\t0x2d\n#define MMA8452_CTRL_REG5\t\t\t0x2e\n#define MMA8452_OFF_X\t\t\t\t0x2f\n#define MMA8452_OFF_Y\t\t\t\t0x30\n#define MMA8452_OFF_Z\t\t\t\t0x31\n\n#define MMA8452_MAX_REG\t\t\t\t0x31\n\n#define  MMA8452_INT_DRDY\t\t\tBIT(0)\n#define  MMA8452_INT_FF_MT\t\t\tBIT(2)\n#define  MMA8452_INT_TRANS\t\t\tBIT(5)\n\n#define MMA8451_DEVICE_ID\t\t\t0x1a\n#define MMA8452_DEVICE_ID\t\t\t0x2a\n#define MMA8453_DEVICE_ID\t\t\t0x3a\n#define MMA8652_DEVICE_ID\t\t\t0x4a\n#define MMA8653_DEVICE_ID\t\t\t0x5a\n#define FXLS8471_DEVICE_ID\t\t\t0x6a\n\n#define MMA8452_AUTO_SUSPEND_DELAY_MS\t\t2000\n\nstruct mma8452_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tstruct iio_mount_matrix orientation;\n\tu8 ctrl_reg1;\n\tu8 data_cfg;\n\tconst struct mma_chip_info *chip_info;\n\tint sleep_val;\n\tstruct regulator *vdd_reg;\n\tstruct regulator *vddio_reg;\n\n\t \n\tstruct {\n\t\t__be16 channels[3];\n\t\ts64 ts __aligned(8);\n\t} buffer;\n};\n\n  \nstruct mma8452_event_regs {\n\tu8 ev_cfg;\n\tu8 ev_cfg_ele;\n\tu8 ev_cfg_chan_shift;\n\tu8 ev_src;\n\tu8 ev_ths;\n\tu8 ev_ths_mask;\n\tu8 ev_count;\n};\n\nstatic const struct mma8452_event_regs ff_mt_ev_regs = {\n\t.ev_cfg = MMA8452_FF_MT_CFG,\n\t.ev_cfg_ele = MMA8452_FF_MT_CFG_ELE,\n\t.ev_cfg_chan_shift = MMA8452_FF_MT_CHAN_SHIFT,\n\t.ev_src = MMA8452_FF_MT_SRC,\n\t.ev_ths = MMA8452_FF_MT_THS,\n\t.ev_ths_mask = MMA8452_FF_MT_THS_MASK,\n\t.ev_count = MMA8452_FF_MT_COUNT\n};\n\nstatic const struct mma8452_event_regs trans_ev_regs = {\n\t.ev_cfg = MMA8452_TRANSIENT_CFG,\n\t.ev_cfg_ele = MMA8452_TRANSIENT_CFG_ELE,\n\t.ev_cfg_chan_shift = MMA8452_TRANSIENT_CHAN_SHIFT,\n\t.ev_src = MMA8452_TRANSIENT_SRC,\n\t.ev_ths = MMA8452_TRANSIENT_THS,\n\t.ev_ths_mask = MMA8452_TRANSIENT_THS_MASK,\n\t.ev_count = MMA8452_TRANSIENT_COUNT,\n};\n\n \nstruct mma_chip_info {\n\tconst char *name;\n\tu8 chip_id;\n\tconst struct iio_chan_spec *channels;\n\tint num_channels;\n\tconst int mma_scales[3][2];\n\tint all_events;\n\tint enabled_events;\n};\n\nenum {\n\tidx_x,\n\tidx_y,\n\tidx_z,\n\tidx_ts,\n};\n\nstatic int mma8452_drdy(struct mma8452_data *data)\n{\n\tint tries = 150;\n\n\twhile (tries-- > 0) {\n\t\tint ret = i2c_smbus_read_byte_data(data->client,\n\t\t\tMMA8452_STATUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif ((ret & MMA8452_STATUS_DRDY) == MMA8452_STATUS_DRDY)\n\t\t\treturn 0;\n\n\t\tif (data->sleep_val <= 20)\n\t\t\tusleep_range(data->sleep_val * 250,\n\t\t\t\t     data->sleep_val * 500);\n\t\telse\n\t\t\tmsleep(20);\n\t}\n\n\tdev_err(&data->client->dev, \"data not ready\\n\");\n\n\treturn -EIO;\n}\n\nstatic int mma8452_set_runtime_pm_state(struct i2c_client *client, bool on)\n{\n#ifdef CONFIG_PM\n\tint ret;\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(&client->dev);\n\t} else {\n\t\tpm_runtime_mark_last_busy(&client->dev);\n\t\tret = pm_runtime_put_autosuspend(&client->dev);\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to change power state to %d\\n\", on);\n\n\t\treturn ret;\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic int mma8452_read(struct mma8452_data *data, __be16 buf[3])\n{\n\tint ret = mma8452_drdy(data);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mma8452_set_runtime_pm_state(data->client, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_i2c_block_data(data->client, MMA8452_OUT_X,\n\t\t\t\t\t    3 * sizeof(__be16), (u8 *)buf);\n\n\tret = mma8452_set_runtime_pm_state(data->client, false);\n\n\treturn ret;\n}\n\nstatic ssize_t mma8452_show_int_plus_micros(char *buf, const int (*vals)[2],\n\t\t\t\t\t    int n)\n{\n\tsize_t len = 0;\n\n\twhile (n-- > 0)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d.%06d \",\n\t\t\t\t vals[n][0], vals[n][1]);\n\n\t \n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic int mma8452_get_int_plus_micros_index(const int (*vals)[2], int n,\n\t\t\t\t\t     int val, int val2)\n{\n\twhile (n-- > 0)\n\t\tif (val == vals[n][0] && val2 == vals[n][1])\n\t\t\treturn n;\n\n\treturn -EINVAL;\n}\n\nstatic unsigned int mma8452_get_odr_index(struct mma8452_data *data)\n{\n\treturn (data->ctrl_reg1 & MMA8452_CTRL_DR_MASK) >>\n\t\t\tMMA8452_CTRL_DR_SHIFT;\n}\n\nstatic const int mma8452_samp_freq[8][2] = {\n\t{800, 0}, {400, 0}, {200, 0}, {100, 0}, {50, 0}, {12, 500000},\n\t{6, 250000}, {1, 560000}\n};\n\n \nstatic const unsigned int mma8452_time_step_us[4][8] = {\n\t{ 1250, 2500, 5000, 10000, 20000, 20000, 20000, 20000 },   \n\t{ 1250, 2500, 5000, 10000, 20000, 80000, 80000, 80000 },   \n\t{ 1250, 2500, 2500, 2500, 2500, 2500, 2500, 2500 },\t   \n\t{ 1250, 2500, 5000, 10000, 20000, 80000, 160000, 160000 }  \n};\n\n \nstatic const int mma8452_hp_filter_cutoff[4][8][4][2] = {\n\t{  \n\t{ {16, 0}, {8, 0}, {4, 0}, {2, 0} },\t\t \n\t{ {16, 0}, {8, 0}, {4, 0}, {2, 0} },\t\t \n\t{ {8, 0}, {4, 0}, {2, 0}, {1, 0} },\t\t \n\t{ {4, 0}, {2, 0}, {1, 0}, {0, 500000} },\t \n\t{ {2, 0}, {1, 0}, {0, 500000}, {0, 250000} },\t \n\t{ {2, 0}, {1, 0}, {0, 500000}, {0, 250000} },\t \n\t{ {2, 0}, {1, 0}, {0, 500000}, {0, 250000} },\t \n\t{ {2, 0}, {1, 0}, {0, 500000}, {0, 250000} }\t \n\t},\n\t{  \n\t{ {16, 0}, {8, 0}, {4, 0}, {2, 0} },\n\t{ {16, 0}, {8, 0}, {4, 0}, {2, 0} },\n\t{ {8, 0}, {4, 0}, {2, 0}, {1, 0} },\n\t{ {4, 0}, {2, 0}, {1, 0}, {0, 500000} },\n\t{ {2, 0}, {1, 0}, {0, 500000}, {0, 250000} },\n\t{ {0, 500000}, {0, 250000}, {0, 125000}, {0, 063000} },\n\t{ {0, 500000}, {0, 250000}, {0, 125000}, {0, 063000} },\n\t{ {0, 500000}, {0, 250000}, {0, 125000}, {0, 063000} }\n\t},\n\t{  \n\t{ {16, 0}, {8, 0}, {4, 0}, {2, 0} },\n\t{ {16, 0}, {8, 0}, {4, 0}, {2, 0} },\n\t{ {16, 0}, {8, 0}, {4, 0}, {2, 0} },\n\t{ {16, 0}, {8, 0}, {4, 0}, {2, 0} },\n\t{ {16, 0}, {8, 0}, {4, 0}, {2, 0} },\n\t{ {16, 0}, {8, 0}, {4, 0}, {2, 0} },\n\t{ {16, 0}, {8, 0}, {4, 0}, {2, 0} },\n\t{ {16, 0}, {8, 0}, {4, 0}, {2, 0} }\n\t},\n\t{  \n\t{ {16, 0}, {8, 0}, {4, 0}, {2, 0} },\n\t{ {8, 0}, {4, 0}, {2, 0}, {1, 0} },\n\t{ {4, 0}, {2, 0}, {1, 0}, {0, 500000} },\n\t{ {2, 0}, {1, 0}, {0, 500000}, {0, 250000} },\n\t{ {1, 0}, {0, 500000}, {0, 250000}, {0, 125000} },\n\t{ {0, 250000}, {0, 125000}, {0, 063000}, {0, 031000} },\n\t{ {0, 250000}, {0, 125000}, {0, 063000}, {0, 031000} },\n\t{ {0, 250000}, {0, 125000}, {0, 063000}, {0, 031000} }\n\t}\n};\n\n \nstatic const u16 mma8452_os_ratio[4][8] = {\n\t \n\t{ 2, 4, 4, 4, 4, 16, 32, 128 },\t\t \n\t{ 2, 4, 4, 4, 4, 4, 8, 32 },\t\t \n\t{ 2, 4, 8, 16, 32, 128, 256, 1024 },\t \n\t{ 2, 2, 2, 2, 2, 2, 4, 16 }\t\t \n};\n\nstatic int mma8452_get_power_mode(struct mma8452_data *data)\n{\n\tint reg;\n\n\treg = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t       MMA8452_CTRL_REG2);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treturn ((reg & MMA8452_CTRL_REG2_MODS_MASK) >>\n\t\tMMA8452_CTRL_REG2_MODS_SHIFT);\n}\n\nstatic ssize_t mma8452_show_samp_freq_avail(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\treturn mma8452_show_int_plus_micros(buf, mma8452_samp_freq,\n\t\t\t\t\t    ARRAY_SIZE(mma8452_samp_freq));\n}\n\nstatic ssize_t mma8452_show_scale_avail(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\n\treturn mma8452_show_int_plus_micros(buf, data->chip_info->mma_scales,\n\t\tARRAY_SIZE(data->chip_info->mma_scales));\n}\n\nstatic ssize_t mma8452_show_hp_cutoff_avail(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\tint i, j;\n\n\ti = mma8452_get_odr_index(data);\n\tj = mma8452_get_power_mode(data);\n\tif (j < 0)\n\t\treturn j;\n\n\treturn mma8452_show_int_plus_micros(buf, mma8452_hp_filter_cutoff[j][i],\n\t\tARRAY_SIZE(mma8452_hp_filter_cutoff[0][0]));\n}\n\nstatic ssize_t mma8452_show_os_ratio_avail(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\tint i = mma8452_get_odr_index(data);\n\tint j;\n\tu16 val = 0;\n\tsize_t len = 0;\n\n\tfor (j = 0; j < ARRAY_SIZE(mma8452_os_ratio); j++) {\n\t\tif (val == mma8452_os_ratio[j][i])\n\t\t\tcontinue;\n\n\t\tval = mma8452_os_ratio[j][i];\n\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d \", val);\n\t}\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic IIO_DEV_ATTR_SAMP_FREQ_AVAIL(mma8452_show_samp_freq_avail);\nstatic IIO_DEVICE_ATTR(in_accel_scale_available, 0444,\n\t\t       mma8452_show_scale_avail, NULL, 0);\nstatic IIO_DEVICE_ATTR(in_accel_filter_high_pass_3db_frequency_available,\n\t\t       0444, mma8452_show_hp_cutoff_avail, NULL, 0);\nstatic IIO_DEVICE_ATTR(in_accel_oversampling_ratio_available, 0444,\n\t\t       mma8452_show_os_ratio_avail, NULL, 0);\n\nstatic int mma8452_get_samp_freq_index(struct mma8452_data *data,\n\t\t\t\t       int val, int val2)\n{\n\treturn mma8452_get_int_plus_micros_index(mma8452_samp_freq,\n\t\t\t\t\t\t ARRAY_SIZE(mma8452_samp_freq),\n\t\t\t\t\t\t val, val2);\n}\n\nstatic int mma8452_get_scale_index(struct mma8452_data *data, int val, int val2)\n{\n\treturn mma8452_get_int_plus_micros_index(data->chip_info->mma_scales,\n\t\t\tARRAY_SIZE(data->chip_info->mma_scales), val, val2);\n}\n\nstatic int mma8452_get_hp_filter_index(struct mma8452_data *data,\n\t\t\t\t       int val, int val2)\n{\n\tint i, j;\n\n\ti = mma8452_get_odr_index(data);\n\tj = mma8452_get_power_mode(data);\n\tif (j < 0)\n\t\treturn j;\n\n\treturn mma8452_get_int_plus_micros_index(mma8452_hp_filter_cutoff[j][i],\n\t\tARRAY_SIZE(mma8452_hp_filter_cutoff[0][0]), val, val2);\n}\n\nstatic int mma8452_read_hp_filter(struct mma8452_data *data, int *hz, int *uHz)\n{\n\tint j, i, ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, MMA8452_HP_FILTER_CUTOFF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ti = mma8452_get_odr_index(data);\n\tj = mma8452_get_power_mode(data);\n\tif (j < 0)\n\t\treturn j;\n\n\tret &= MMA8452_HP_FILTER_CUTOFF_SEL_MASK;\n\t*hz = mma8452_hp_filter_cutoff[j][i][ret][0];\n\t*uHz = mma8452_hp_filter_cutoff[j][i][ret][1];\n\n\treturn 0;\n}\n\nstatic int mma8452_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\t__be16 buffer[3];\n\tint i, ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&data->lock);\n\t\tret = mma8452_read(data, buffer);\n\t\tmutex_unlock(&data->lock);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = sign_extend32(be16_to_cpu(\n\t\t\tbuffer[chan->scan_index]) >> chan->scan_type.shift,\n\t\t\tchan->scan_type.realbits - 1);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\ti = data->data_cfg & MMA8452_DATA_CFG_FS_MASK;\n\t\t*val = data->chip_info->mma_scales[i][0];\n\t\t*val2 = data->chip_info->mma_scales[i][1];\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\ti = mma8452_get_odr_index(data);\n\t\t*val = mma8452_samp_freq[i][0];\n\t\t*val2 = mma8452_samp_freq[i][1];\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t       MMA8452_OFF_X +\n\t\t\t\t\t       chan->scan_index);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = sign_extend32(ret, 7);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\tif (data->data_cfg & MMA8452_DATA_CFG_HPF_MASK) {\n\t\t\tret = mma8452_read_hp_filter(data, val, val2);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\t*val = 0;\n\t\t\t*val2 = 0;\n\t\t}\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tret = mma8452_get_power_mode(data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ti = mma8452_get_odr_index(data);\n\n\t\t*val = mma8452_os_ratio[ret][i];\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mma8452_calculate_sleep(struct mma8452_data *data)\n{\n\tint ret, i = mma8452_get_odr_index(data);\n\n\tif (mma8452_samp_freq[i][0] > 0)\n\t\tret = 1000 / mma8452_samp_freq[i][0];\n\telse\n\t\tret = 1000;\n\n\treturn ret == 0 ? 1 : ret;\n}\n\nstatic int mma8452_standby(struct mma8452_data *data)\n{\n\treturn i2c_smbus_write_byte_data(data->client, MMA8452_CTRL_REG1,\n\t\t\t\t\tdata->ctrl_reg1 & ~MMA8452_CTRL_ACTIVE);\n}\n\nstatic int mma8452_active(struct mma8452_data *data)\n{\n\treturn i2c_smbus_write_byte_data(data->client, MMA8452_CTRL_REG1,\n\t\t\t\t\t data->ctrl_reg1);\n}\n\n \nstatic int mma8452_is_active(struct mma8452_data *data)\n{\n\tint reg;\n\n\treg = i2c_smbus_read_byte_data(data->client, MMA8452_CTRL_REG1);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treturn reg & MMA8452_CTRL_ACTIVE;\n}\n\nstatic int mma8452_change_config(struct mma8452_data *data, u8 reg, u8 val)\n{\n\tint ret;\n\tint is_active;\n\n\tmutex_lock(&data->lock);\n\n\tis_active = mma8452_is_active(data);\n\tif (is_active < 0) {\n\t\tret = is_active;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (is_active > 0) {\n\t\tret = mma8452_standby(data);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\n\tret = i2c_smbus_write_byte_data(data->client, reg, val);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (is_active > 0) {\n\t\tret = mma8452_active(data);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\n\tret = 0;\nfail:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int mma8452_set_power_mode(struct mma8452_data *data, u8 mode)\n{\n\tint reg;\n\n\treg = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t       MMA8452_CTRL_REG2);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treg &= ~MMA8452_CTRL_REG2_MODS_MASK;\n\treg |= mode << MMA8452_CTRL_REG2_MODS_SHIFT;\n\n\treturn mma8452_change_config(data, MMA8452_CTRL_REG2, reg);\n}\n\n \nstatic int mma8452_freefall_mode_enabled(struct mma8452_data *data)\n{\n\tint val;\n\n\tval = i2c_smbus_read_byte_data(data->client, MMA8452_FF_MT_CFG);\n\tif (val < 0)\n\t\treturn val;\n\n\treturn !(val & MMA8452_FF_MT_CFG_OAE);\n}\n\nstatic int mma8452_set_freefall_mode(struct mma8452_data *data, bool state)\n{\n\tint val;\n\n\tif ((state && mma8452_freefall_mode_enabled(data)) ||\n\t    (!state && !(mma8452_freefall_mode_enabled(data))))\n\t\treturn 0;\n\n\tval = i2c_smbus_read_byte_data(data->client, MMA8452_FF_MT_CFG);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (state) {\n\t\tval |= BIT(idx_x + MMA8452_FF_MT_CHAN_SHIFT);\n\t\tval |= BIT(idx_y + MMA8452_FF_MT_CHAN_SHIFT);\n\t\tval |= BIT(idx_z + MMA8452_FF_MT_CHAN_SHIFT);\n\t\tval &= ~MMA8452_FF_MT_CFG_OAE;\n\t} else {\n\t\tval &= ~BIT(idx_x + MMA8452_FF_MT_CHAN_SHIFT);\n\t\tval &= ~BIT(idx_y + MMA8452_FF_MT_CHAN_SHIFT);\n\t\tval &= ~BIT(idx_z + MMA8452_FF_MT_CHAN_SHIFT);\n\t\tval |= MMA8452_FF_MT_CFG_OAE;\n\t}\n\n\treturn mma8452_change_config(data, MMA8452_FF_MT_CFG, val);\n}\n\nstatic int mma8452_set_hp_filter_frequency(struct mma8452_data *data,\n\t\t\t\t\t   int val, int val2)\n{\n\tint i, reg;\n\n\ti = mma8452_get_hp_filter_index(data, val, val2);\n\tif (i < 0)\n\t\treturn i;\n\n\treg = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t       MMA8452_HP_FILTER_CUTOFF);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treg &= ~MMA8452_HP_FILTER_CUTOFF_SEL_MASK;\n\treg |= i;\n\n\treturn mma8452_change_config(data, MMA8452_HP_FILTER_CUTOFF, reg);\n}\n\nstatic int mma8452_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\tint i, ret;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\ti = mma8452_get_samp_freq_index(data, val, val2);\n\t\tif (i < 0) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t\tdata->ctrl_reg1 &= ~MMA8452_CTRL_DR_MASK;\n\t\tdata->ctrl_reg1 |= i << MMA8452_CTRL_DR_SHIFT;\n\n\t\tdata->sleep_val = mma8452_calculate_sleep(data);\n\n\t\tret = mma8452_change_config(data, MMA8452_CTRL_REG1,\n\t\t\t\t\t    data->ctrl_reg1);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\ti = mma8452_get_scale_index(data, val, val2);\n\t\tif (i < 0) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->data_cfg &= ~MMA8452_DATA_CFG_FS_MASK;\n\t\tdata->data_cfg |= i;\n\n\t\tret = mma8452_change_config(data, MMA8452_DATA_CFG,\n\t\t\t\t\t    data->data_cfg);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif (val < -128 || val > 127) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = mma8452_change_config(data,\n\t\t\t\t\t    MMA8452_OFF_X + chan->scan_index,\n\t\t\t\t\t    val);\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\tif (val == 0 && val2 == 0) {\n\t\t\tdata->data_cfg &= ~MMA8452_DATA_CFG_HPF_MASK;\n\t\t} else {\n\t\t\tdata->data_cfg |= MMA8452_DATA_CFG_HPF_MASK;\n\t\t\tret = mma8452_set_hp_filter_frequency(data, val, val2);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tret = mma8452_change_config(data, MMA8452_DATA_CFG,\n\t\t\t\t\t     data->data_cfg);\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tret = mma8452_get_odr_index(data);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mma8452_os_ratio); i++) {\n\t\t\tif (mma8452_os_ratio[i][ret] == val) {\n\t\t\t\tret = mma8452_set_power_mode(data, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tiio_device_release_direct_mode(indio_dev);\n\treturn ret;\n}\n\nstatic int mma8452_get_event_regs(struct mma8452_data *data,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_direction dir,\n\t\tconst struct mma8452_event_regs **ev_reg)\n{\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tswitch (chan->type) {\n\tcase IIO_ACCEL:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\tif ((data->chip_info->all_events\n\t\t\t\t\t& MMA8452_INT_TRANS) &&\n\t\t\t\t(data->chip_info->enabled_events\n\t\t\t\t\t& MMA8452_INT_TRANS))\n\t\t\t\t*ev_reg = &trans_ev_regs;\n\t\t\telse\n\t\t\t\t*ev_reg = &ff_mt_ev_regs;\n\t\t\treturn 0;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\t*ev_reg = &ff_mt_ev_regs;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mma8452_read_event_value(struct iio_dev *indio_dev,\n\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t       enum iio_event_type type,\n\t\t\t       enum iio_event_direction dir,\n\t\t\t       enum iio_event_info info,\n\t\t\t       int *val, int *val2)\n{\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\tint ret, us, power_mode;\n\tconst struct mma8452_event_regs *ev_regs;\n\n\tret = mma8452_get_event_regs(data, chan, dir, &ev_regs);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tret = i2c_smbus_read_byte_data(data->client, ev_regs->ev_ths);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = ret & ev_regs->ev_ths_mask;\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_EV_INFO_PERIOD:\n\t\tret = i2c_smbus_read_byte_data(data->client, ev_regs->ev_count);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tpower_mode = mma8452_get_power_mode(data);\n\t\tif (power_mode < 0)\n\t\t\treturn power_mode;\n\n\t\tus = ret * mma8452_time_step_us[power_mode][\n\t\t\t\tmma8452_get_odr_index(data)];\n\t\t*val = us / USEC_PER_SEC;\n\t\t*val2 = us % USEC_PER_SEC;\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase IIO_EV_INFO_HIGH_PASS_FILTER_3DB:\n\t\tret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t       MMA8452_TRANSIENT_CFG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret & MMA8452_TRANSIENT_CFG_HPF_BYP) {\n\t\t\t*val = 0;\n\t\t\t*val2 = 0;\n\t\t} else {\n\t\t\tret = mma8452_read_hp_filter(data, val, val2);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mma8452_write_event_value(struct iio_dev *indio_dev,\n\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\tenum iio_event_type type,\n\t\t\t\tenum iio_event_direction dir,\n\t\t\t\tenum iio_event_info info,\n\t\t\t\tint val, int val2)\n{\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\tint ret, reg, steps;\n\tconst struct mma8452_event_regs *ev_regs;\n\n\tret = mma8452_get_event_regs(data, chan, dir, &ev_regs);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tif (val < 0 || val > ev_regs->ev_ths_mask)\n\t\t\treturn -EINVAL;\n\n\t\treturn mma8452_change_config(data, ev_regs->ev_ths, val);\n\n\tcase IIO_EV_INFO_PERIOD:\n\t\tret = mma8452_get_power_mode(data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tsteps = (val * USEC_PER_SEC + val2) /\n\t\t\t\tmma8452_time_step_us[ret][\n\t\t\t\t\tmma8452_get_odr_index(data)];\n\n\t\tif (steps < 0 || steps > 0xff)\n\t\t\treturn -EINVAL;\n\n\t\treturn mma8452_change_config(data, ev_regs->ev_count, steps);\n\n\tcase IIO_EV_INFO_HIGH_PASS_FILTER_3DB:\n\t\treg = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t       MMA8452_TRANSIENT_CFG);\n\t\tif (reg < 0)\n\t\t\treturn reg;\n\n\t\tif (val == 0 && val2 == 0) {\n\t\t\treg |= MMA8452_TRANSIENT_CFG_HPF_BYP;\n\t\t} else {\n\t\t\treg &= ~MMA8452_TRANSIENT_CFG_HPF_BYP;\n\t\t\tret = mma8452_set_hp_filter_frequency(data, val, val2);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\treturn mma8452_change_config(data, MMA8452_TRANSIENT_CFG, reg);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mma8452_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir)\n{\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\tint ret;\n\tconst struct mma8452_event_regs *ev_regs;\n\n\tret = mma8452_get_event_regs(data, chan, dir, &ev_regs);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_FALLING:\n\t\treturn mma8452_freefall_mode_enabled(data);\n\tcase IIO_EV_DIR_RISING:\n\t\tret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\tev_regs->ev_cfg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn !!(ret & BIT(chan->scan_index +\n\t\t\t\tev_regs->ev_cfg_chan_shift));\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mma8452_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir,\n\t\t\t\t      int state)\n{\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\tint val, ret;\n\tconst struct mma8452_event_regs *ev_regs;\n\n\tret = mma8452_get_event_regs(data, chan, dir, &ev_regs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mma8452_set_runtime_pm_state(data->client, state);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_FALLING:\n\t\treturn mma8452_set_freefall_mode(data, state);\n\tcase IIO_EV_DIR_RISING:\n\t\tval = i2c_smbus_read_byte_data(data->client, ev_regs->ev_cfg);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tif (state) {\n\t\t\tif (mma8452_freefall_mode_enabled(data)) {\n\t\t\t\tval &= ~BIT(idx_x + ev_regs->ev_cfg_chan_shift);\n\t\t\t\tval &= ~BIT(idx_y + ev_regs->ev_cfg_chan_shift);\n\t\t\t\tval &= ~BIT(idx_z + ev_regs->ev_cfg_chan_shift);\n\t\t\t\tval |= MMA8452_FF_MT_CFG_OAE;\n\t\t\t}\n\t\t\tval |= BIT(chan->scan_index +\n\t\t\t\t\tev_regs->ev_cfg_chan_shift);\n\t\t} else {\n\t\t\tif (mma8452_freefall_mode_enabled(data))\n\t\t\t\treturn 0;\n\n\t\t\tval &= ~BIT(chan->scan_index +\n\t\t\t\t\tev_regs->ev_cfg_chan_shift);\n\t\t}\n\n\t\tval |= ev_regs->ev_cfg_ele;\n\n\t\treturn mma8452_change_config(data, ev_regs->ev_cfg, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void mma8452_transient_interrupt(struct iio_dev *indio_dev)\n{\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\ts64 ts = iio_get_time_ns(indio_dev);\n\tint src;\n\n\tsrc = i2c_smbus_read_byte_data(data->client, MMA8452_TRANSIENT_SRC);\n\tif (src < 0)\n\t\treturn;\n\n\tif (src & MMA8452_TRANSIENT_SRC_XTRANSE)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL, 0, IIO_MOD_X,\n\t\t\t\t\t\t  IIO_EV_TYPE_MAG,\n\t\t\t\t\t\t  IIO_EV_DIR_RISING),\n\t\t\t       ts);\n\n\tif (src & MMA8452_TRANSIENT_SRC_YTRANSE)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL, 0, IIO_MOD_Y,\n\t\t\t\t\t\t  IIO_EV_TYPE_MAG,\n\t\t\t\t\t\t  IIO_EV_DIR_RISING),\n\t\t\t       ts);\n\n\tif (src & MMA8452_TRANSIENT_SRC_ZTRANSE)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL, 0, IIO_MOD_Z,\n\t\t\t\t\t\t  IIO_EV_TYPE_MAG,\n\t\t\t\t\t\t  IIO_EV_DIR_RISING),\n\t\t\t       ts);\n}\n\nstatic irqreturn_t mma8452_interrupt(int irq, void *p)\n{\n\tstruct iio_dev *indio_dev = p;\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\tirqreturn_t ret = IRQ_NONE;\n\tint src;\n\n\tsrc = i2c_smbus_read_byte_data(data->client, MMA8452_INT_SRC);\n\tif (src < 0)\n\t\treturn IRQ_NONE;\n\n\tif (!(src & (data->chip_info->enabled_events | MMA8452_INT_DRDY)))\n\t\treturn IRQ_NONE;\n\n\tif (src & MMA8452_INT_DRDY) {\n\t\tiio_trigger_poll_nested(indio_dev->trig);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (src & MMA8452_INT_FF_MT) {\n\t\tif (mma8452_freefall_mode_enabled(data)) {\n\t\t\ts64 ts = iio_get_time_ns(indio_dev);\n\n\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL, 0,\n\t\t\t\t\t\t\t  IIO_MOD_X_AND_Y_AND_Z,\n\t\t\t\t\t\t\t  IIO_EV_TYPE_MAG,\n\t\t\t\t\t\t\t  IIO_EV_DIR_FALLING),\n\t\t\t\t\tts);\n\t\t}\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (src & MMA8452_INT_TRANS) {\n\t\tmma8452_transient_interrupt(indio_dev);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t mma8452_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = mma8452_read(data, data->buffer.channels);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->buffer,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mma8452_reg_access_dbg(struct iio_dev *indio_dev,\n\t\t\t\t  unsigned int reg, unsigned int writeval,\n\t\t\t\t  unsigned int *readval)\n{\n\tint ret;\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\n\tif (reg > MMA8452_MAX_REG)\n\t\treturn -EINVAL;\n\n\tif (!readval)\n\t\treturn mma8452_change_config(data, reg, writeval);\n\n\tret = i2c_smbus_read_byte_data(data->client, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*readval = ret;\n\n\treturn 0;\n}\n\nstatic const struct iio_event_spec mma8452_freefall_event[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_MAG,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t\t.mask_shared_by_type = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t\tBIT(IIO_EV_INFO_PERIOD) |\n\t\t\t\t\tBIT(IIO_EV_INFO_HIGH_PASS_FILTER_3DB)\n\t},\n};\n\nstatic const struct iio_event_spec mma8652_freefall_event[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_MAG,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t\t.mask_shared_by_type = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t\tBIT(IIO_EV_INFO_PERIOD)\n\t},\n};\n\nstatic const struct iio_event_spec mma8452_transient_event[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_MAG,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t\t.mask_shared_by_type = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t\tBIT(IIO_EV_INFO_PERIOD) |\n\t\t\t\t\tBIT(IIO_EV_INFO_HIGH_PASS_FILTER_3DB)\n\t},\n};\n\nstatic const struct iio_event_spec mma8452_motion_event[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_MAG,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t\t.mask_shared_by_type = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t\tBIT(IIO_EV_INFO_PERIOD)\n\t},\n};\n\n \nstatic IIO_CONST_ATTR_NAMED(accel_transient_scale, in_accel_scale, \"0.617742\");\n\nstatic struct attribute *mma8452_event_attributes[] = {\n\t&iio_const_attr_accel_transient_scale.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mma8452_event_attribute_group = {\n\t.attrs = mma8452_event_attributes,\n};\n\nstatic const struct iio_mount_matrix *\nmma8452_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\t   const struct iio_chan_spec *chan)\n{\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\n\treturn &data->orientation;\n}\n\nstatic const struct iio_chan_spec_ext_info mma8452_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_TYPE, mma8452_get_mount_matrix),\n\t{ }\n};\n\n#define MMA8452_FREEFALL_CHANNEL(modifier) { \\\n\t.type = IIO_ACCEL, \\\n\t.modified = 1, \\\n\t.channel2 = modifier, \\\n\t.scan_index = -1, \\\n\t.event_spec = mma8452_freefall_event, \\\n\t.num_event_specs = ARRAY_SIZE(mma8452_freefall_event), \\\n}\n\n#define MMA8652_FREEFALL_CHANNEL(modifier) { \\\n\t.type = IIO_ACCEL, \\\n\t.modified = 1, \\\n\t.channel2 = modifier, \\\n\t.scan_index = -1, \\\n\t.event_spec = mma8652_freefall_event, \\\n\t.num_event_specs = ARRAY_SIZE(mma8652_freefall_event), \\\n}\n\n#define MMA8452_CHANNEL(axis, idx, bits) { \\\n\t.type = IIO_ACCEL, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_##axis, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_CALIBBIAS), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) | \\\n\t\t\tBIT(IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY) | \\\n\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \\\n\t.scan_index = idx, \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = (bits), \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 16 - (bits), \\\n\t\t.endianness = IIO_BE, \\\n\t}, \\\n\t.event_spec = mma8452_transient_event, \\\n\t.num_event_specs = ARRAY_SIZE(mma8452_transient_event), \\\n\t.ext_info = mma8452_ext_info, \\\n}\n\n#define MMA8652_CHANNEL(axis, idx, bits) { \\\n\t.type = IIO_ACCEL, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_##axis, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\tBIT(IIO_CHAN_INFO_CALIBBIAS), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\tBIT(IIO_CHAN_INFO_SCALE) | \\\n\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \\\n\t.scan_index = idx, \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = (bits), \\\n\t\t.storagebits = 16, \\\n\t\t.shift = 16 - (bits), \\\n\t\t.endianness = IIO_BE, \\\n\t}, \\\n\t.event_spec = mma8452_motion_event, \\\n\t.num_event_specs = ARRAY_SIZE(mma8452_motion_event), \\\n\t.ext_info = mma8452_ext_info, \\\n}\n\nstatic const struct iio_chan_spec mma8451_channels[] = {\n\tMMA8452_CHANNEL(X, idx_x, 14),\n\tMMA8452_CHANNEL(Y, idx_y, 14),\n\tMMA8452_CHANNEL(Z, idx_z, 14),\n\tIIO_CHAN_SOFT_TIMESTAMP(idx_ts),\n\tMMA8452_FREEFALL_CHANNEL(IIO_MOD_X_AND_Y_AND_Z),\n};\n\nstatic const struct iio_chan_spec mma8452_channels[] = {\n\tMMA8452_CHANNEL(X, idx_x, 12),\n\tMMA8452_CHANNEL(Y, idx_y, 12),\n\tMMA8452_CHANNEL(Z, idx_z, 12),\n\tIIO_CHAN_SOFT_TIMESTAMP(idx_ts),\n\tMMA8452_FREEFALL_CHANNEL(IIO_MOD_X_AND_Y_AND_Z),\n};\n\nstatic const struct iio_chan_spec mma8453_channels[] = {\n\tMMA8452_CHANNEL(X, idx_x, 10),\n\tMMA8452_CHANNEL(Y, idx_y, 10),\n\tMMA8452_CHANNEL(Z, idx_z, 10),\n\tIIO_CHAN_SOFT_TIMESTAMP(idx_ts),\n\tMMA8452_FREEFALL_CHANNEL(IIO_MOD_X_AND_Y_AND_Z),\n};\n\nstatic const struct iio_chan_spec mma8652_channels[] = {\n\tMMA8652_CHANNEL(X, idx_x, 12),\n\tMMA8652_CHANNEL(Y, idx_y, 12),\n\tMMA8652_CHANNEL(Z, idx_z, 12),\n\tIIO_CHAN_SOFT_TIMESTAMP(idx_ts),\n\tMMA8652_FREEFALL_CHANNEL(IIO_MOD_X_AND_Y_AND_Z),\n};\n\nstatic const struct iio_chan_spec mma8653_channels[] = {\n\tMMA8652_CHANNEL(X, idx_x, 10),\n\tMMA8652_CHANNEL(Y, idx_y, 10),\n\tMMA8652_CHANNEL(Z, idx_z, 10),\n\tIIO_CHAN_SOFT_TIMESTAMP(idx_ts),\n\tMMA8652_FREEFALL_CHANNEL(IIO_MOD_X_AND_Y_AND_Z),\n};\n\nenum {\n\tmma8451,\n\tmma8452,\n\tmma8453,\n\tmma8652,\n\tmma8653,\n\tfxls8471,\n};\n\nstatic const struct mma_chip_info mma_chip_info_table[] = {\n\t[mma8451] = {\n\t\t.name = \"mma8451\",\n\t\t.chip_id = MMA8451_DEVICE_ID,\n\t\t.channels = mma8451_channels,\n\t\t.num_channels = ARRAY_SIZE(mma8451_channels),\n\t\t \n\t\t.mma_scales = { {0, 2394}, {0, 4788}, {0, 9577} },\n\t\t \n\t\t.all_events = MMA8452_INT_DRDY |\n\t\t\t\t\tMMA8452_INT_TRANS |\n\t\t\t\t\tMMA8452_INT_FF_MT,\n\t\t.enabled_events = MMA8452_INT_TRANS |\n\t\t\t\t\tMMA8452_INT_FF_MT,\n\t},\n\t[mma8452] = {\n\t\t.name = \"mma8452\",\n\t\t.chip_id = MMA8452_DEVICE_ID,\n\t\t.channels = mma8452_channels,\n\t\t.num_channels = ARRAY_SIZE(mma8452_channels),\n\t\t.mma_scales = { {0, 9577}, {0, 19154}, {0, 38307} },\n\t\t \n\t\t.all_events = MMA8452_INT_DRDY |\n\t\t\t\t\tMMA8452_INT_TRANS |\n\t\t\t\t\tMMA8452_INT_FF_MT,\n\t\t.enabled_events = MMA8452_INT_TRANS |\n\t\t\t\t\tMMA8452_INT_FF_MT,\n\t},\n\t[mma8453] = {\n\t\t.name = \"mma8453\",\n\t\t.chip_id = MMA8453_DEVICE_ID,\n\t\t.channels = mma8453_channels,\n\t\t.num_channels = ARRAY_SIZE(mma8453_channels),\n\t\t.mma_scales = { {0, 38307}, {0, 76614}, {0, 153228} },\n\t\t \n\t\t.all_events = MMA8452_INT_DRDY |\n\t\t\t\t\tMMA8452_INT_TRANS |\n\t\t\t\t\tMMA8452_INT_FF_MT,\n\t\t.enabled_events = MMA8452_INT_TRANS |\n\t\t\t\t\tMMA8452_INT_FF_MT,\n\t},\n\t[mma8652] = {\n\t\t.name = \"mma8652\",\n\t\t.chip_id = MMA8652_DEVICE_ID,\n\t\t.channels = mma8652_channels,\n\t\t.num_channels = ARRAY_SIZE(mma8652_channels),\n\t\t.mma_scales = { {0, 9577}, {0, 19154}, {0, 38307} },\n\t\t.all_events = MMA8452_INT_DRDY |\n\t\t\t\t\tMMA8452_INT_FF_MT,\n\t\t.enabled_events = MMA8452_INT_FF_MT,\n\t},\n\t[mma8653] = {\n\t\t.name = \"mma8653\",\n\t\t.chip_id = MMA8653_DEVICE_ID,\n\t\t.channels = mma8653_channels,\n\t\t.num_channels = ARRAY_SIZE(mma8653_channels),\n\t\t.mma_scales = { {0, 38307}, {0, 76614}, {0, 153228} },\n\t\t \n\t\t.all_events = MMA8452_INT_DRDY |\n\t\t\t\t\tMMA8452_INT_FF_MT,\n\t\t.enabled_events = MMA8452_INT_FF_MT,\n\t},\n\t[fxls8471] = {\n\t\t.name = \"fxls8471\",\n\t\t.chip_id = FXLS8471_DEVICE_ID,\n\t\t.channels = mma8451_channels,\n\t\t.num_channels = ARRAY_SIZE(mma8451_channels),\n\t\t.mma_scales = { {0, 2394}, {0, 4788}, {0, 9577} },\n\t\t \n\t\t.all_events = MMA8452_INT_DRDY |\n\t\t\t\t\tMMA8452_INT_TRANS |\n\t\t\t\t\tMMA8452_INT_FF_MT,\n\t\t.enabled_events = MMA8452_INT_TRANS |\n\t\t\t\t\tMMA8452_INT_FF_MT,\n\t},\n};\n\nstatic struct attribute *mma8452_attributes[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_in_accel_scale_available.dev_attr.attr,\n\t&iio_dev_attr_in_accel_filter_high_pass_3db_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_in_accel_oversampling_ratio_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group mma8452_group = {\n\t.attrs = mma8452_attributes,\n};\n\nstatic const struct iio_info mma8452_info = {\n\t.attrs = &mma8452_group,\n\t.read_raw = &mma8452_read_raw,\n\t.write_raw = &mma8452_write_raw,\n\t.event_attrs = &mma8452_event_attribute_group,\n\t.read_event_value = &mma8452_read_event_value,\n\t.write_event_value = &mma8452_write_event_value,\n\t.read_event_config = &mma8452_read_event_config,\n\t.write_event_config = &mma8452_write_event_config,\n\t.debugfs_reg_access = &mma8452_reg_access_dbg,\n};\n\nstatic const unsigned long mma8452_scan_masks[] = {0x7, 0};\n\nstatic int mma8452_data_rdy_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t      bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\tint reg, ret;\n\n\tret = mma8452_set_runtime_pm_state(data->client, state);\n\tif (ret)\n\t\treturn ret;\n\n\treg = i2c_smbus_read_byte_data(data->client, MMA8452_CTRL_REG4);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tif (state)\n\t\treg |= MMA8452_INT_DRDY;\n\telse\n\t\treg &= ~MMA8452_INT_DRDY;\n\n\treturn mma8452_change_config(data, MMA8452_CTRL_REG4, reg);\n}\n\nstatic const struct iio_trigger_ops mma8452_trigger_ops = {\n\t.set_trigger_state = mma8452_data_rdy_trigger_set_state,\n\t.validate_device = iio_trigger_validate_own_device,\n};\n\nstatic int mma8452_trigger_setup(struct iio_dev *indio_dev)\n{\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\tstruct iio_trigger *trig;\n\tint ret;\n\n\ttrig = devm_iio_trigger_alloc(&data->client->dev, \"%s-dev%d\",\n\t\t\t\t      indio_dev->name,\n\t\t\t\t      iio_device_id(indio_dev));\n\tif (!trig)\n\t\treturn -ENOMEM;\n\n\ttrig->ops = &mma8452_trigger_ops;\n\tiio_trigger_set_drvdata(trig, indio_dev);\n\n\tret = iio_trigger_register(trig);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->trig = iio_trigger_get(trig);\n\n\treturn 0;\n}\n\nstatic void mma8452_trigger_cleanup(struct iio_dev *indio_dev)\n{\n\tif (indio_dev->trig)\n\t\tiio_trigger_unregister(indio_dev->trig);\n}\n\nstatic int mma8452_reset(struct i2c_client *client)\n{\n\tint i;\n\tint ret;\n\n\t \n\ti2c_smbus_write_byte_data(client, MMA8452_CTRL_REG2,\n\t\t\t\t\tMMA8452_CTRL_REG2_RST);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tusleep_range(100, 200);\n\t\tret = i2c_smbus_read_byte_data(client, MMA8452_CTRL_REG2);\n\t\tif (ret == -EIO)\n\t\t\tcontinue;  \n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!(ret & MMA8452_CTRL_REG2_RST))\n\t\t\treturn 0;\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic const struct of_device_id mma8452_dt_ids[] = {\n\t{ .compatible = \"fsl,mma8451\", .data = &mma_chip_info_table[mma8451] },\n\t{ .compatible = \"fsl,mma8452\", .data = &mma_chip_info_table[mma8452] },\n\t{ .compatible = \"fsl,mma8453\", .data = &mma_chip_info_table[mma8453] },\n\t{ .compatible = \"fsl,mma8652\", .data = &mma_chip_info_table[mma8652] },\n\t{ .compatible = \"fsl,mma8653\", .data = &mma_chip_info_table[mma8653] },\n\t{ .compatible = \"fsl,fxls8471\", .data = &mma_chip_info_table[fxls8471] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mma8452_dt_ids);\n\nstatic int mma8452_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct mma8452_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\tdata->chip_info = device_get_match_data(&client->dev);\n\tif (!data->chip_info) {\n\t\tif (id) {\n\t\t\tdata->chip_info = &mma_chip_info_table[id->driver_data];\n\t\t} else {\n\t\t\tdev_err(&client->dev, \"unknown device model\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tret = iio_read_mount_matrix(&client->dev, &data->orientation);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->vdd_reg = devm_regulator_get(&client->dev, \"vdd\");\n\tif (IS_ERR(data->vdd_reg))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(data->vdd_reg),\n\t\t\t\t     \"failed to get VDD regulator!\\n\");\n\n\tdata->vddio_reg = devm_regulator_get(&client->dev, \"vddio\");\n\tif (IS_ERR(data->vddio_reg))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(data->vddio_reg),\n\t\t\t\t     \"failed to get VDDIO regulator!\\n\");\n\n\tret = regulator_enable(data->vdd_reg);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to enable VDD regulator!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_enable(data->vddio_reg);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to enable VDDIO regulator!\\n\");\n\t\tgoto disable_regulator_vdd;\n\t}\n\n\tret = i2c_smbus_read_byte_data(client, MMA8452_WHO_AM_I);\n\tif (ret < 0)\n\t\tgoto disable_regulators;\n\n\tswitch (ret) {\n\tcase MMA8451_DEVICE_ID:\n\tcase MMA8452_DEVICE_ID:\n\tcase MMA8453_DEVICE_ID:\n\tcase MMA8652_DEVICE_ID:\n\tcase MMA8653_DEVICE_ID:\n\tcase FXLS8471_DEVICE_ID:\n\t\tif (ret == data->chip_info->chip_id)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tret = -ENODEV;\n\t\tgoto disable_regulators;\n\t}\n\n\tdev_info(&client->dev, \"registering %s accelerometer; ID 0x%x\\n\",\n\t\t data->chip_info->name, data->chip_info->chip_id);\n\n\ti2c_set_clientdata(client, indio_dev);\n\tindio_dev->info = &mma8452_info;\n\tindio_dev->name = data->chip_info->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = data->chip_info->channels;\n\tindio_dev->num_channels = data->chip_info->num_channels;\n\tindio_dev->available_scan_masks = mma8452_scan_masks;\n\n\tret = mma8452_reset(client);\n\tif (ret < 0)\n\t\tgoto disable_regulators;\n\n\tdata->data_cfg = MMA8452_DATA_CFG_FS_2G;\n\tret = i2c_smbus_write_byte_data(client, MMA8452_DATA_CFG,\n\t\t\t\t\tdata->data_cfg);\n\tif (ret < 0)\n\t\tgoto disable_regulators;\n\n\t \n\tret = i2c_smbus_write_byte_data(client, MMA8452_TRANSIENT_THS,\n\t\t\t\t\tMMA8452_TRANSIENT_THS_MASK);\n\tif (ret < 0)\n\t\tgoto disable_regulators;\n\n\tif (client->irq) {\n\t\tint irq2;\n\n\t\tirq2 = of_irq_get_byname(client->dev.of_node, \"INT2\");\n\n\t\tif (irq2 == client->irq) {\n\t\t\tdev_dbg(&client->dev, \"using interrupt line INT2\\n\");\n\t\t} else {\n\t\t\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\tMMA8452_CTRL_REG5,\n\t\t\t\t\t\tdata->chip_info->all_events);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto disable_regulators;\n\n\t\t\tdev_dbg(&client->dev, \"using interrupt line INT1\\n\");\n\t\t}\n\n\t\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\tMMA8452_CTRL_REG4,\n\t\t\t\t\tdata->chip_info->enabled_events);\n\t\tif (ret < 0)\n\t\t\tgoto disable_regulators;\n\n\t\tret = mma8452_trigger_setup(indio_dev);\n\t\tif (ret < 0)\n\t\t\tgoto disable_regulators;\n\t}\n\n\tdata->ctrl_reg1 = MMA8452_CTRL_ACTIVE |\n\t\t\t  (MMA8452_CTRL_DR_DEFAULT << MMA8452_CTRL_DR_SHIFT);\n\n\tdata->sleep_val = mma8452_calculate_sleep(data);\n\n\tret = i2c_smbus_write_byte_data(client, MMA8452_CTRL_REG1,\n\t\t\t\t\tdata->ctrl_reg1);\n\tif (ret < 0)\n\t\tgoto trigger_cleanup;\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL,\n\t\t\t\t\t mma8452_trigger_handler, NULL);\n\tif (ret < 0)\n\t\tgoto trigger_cleanup;\n\n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(&client->dev,\n\t\t\t\t\t\tclient->irq,\n\t\t\t\t\t\tNULL, mma8452_interrupt,\n\t\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t\tclient->name, indio_dev);\n\t\tif (ret)\n\t\t\tgoto buffer_cleanup;\n\t}\n\n\tret = pm_runtime_set_active(&client->dev);\n\tif (ret < 0)\n\t\tgoto buffer_cleanup;\n\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev,\n\t\t\t\t\t MMA8452_AUTO_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto buffer_cleanup;\n\n\tret = mma8452_set_freefall_mode(data, false);\n\tif (ret < 0)\n\t\tgoto unregister_device;\n\n\treturn 0;\n\nunregister_device:\n\tiio_device_unregister(indio_dev);\n\nbuffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\n\ntrigger_cleanup:\n\tmma8452_trigger_cleanup(indio_dev);\n\ndisable_regulators:\n\tregulator_disable(data->vddio_reg);\n\ndisable_regulator_vdd:\n\tregulator_disable(data->vdd_reg);\n\n\treturn ret;\n}\n\nstatic void mma8452_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tmma8452_trigger_cleanup(indio_dev);\n\tmma8452_standby(iio_priv(indio_dev));\n\n\tregulator_disable(data->vddio_reg);\n\tregulator_disable(data->vdd_reg);\n}\n\n#ifdef CONFIG_PM\nstatic int mma8452_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = mma8452_standby(data);\n\tmutex_unlock(&data->lock);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"powering off device failed\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tret = regulator_disable(data->vddio_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to disable VDDIO regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_disable(data->vdd_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to disable VDD regulator\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mma8452_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mma8452_data *data = iio_priv(indio_dev);\n\tint ret, sleep_val;\n\n\tret = regulator_enable(data->vdd_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable VDD regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_enable(data->vddio_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable VDDIO regulator\\n\");\n\t\tregulator_disable(data->vdd_reg);\n\t\treturn ret;\n\t}\n\n\tret = mma8452_active(data);\n\tif (ret < 0)\n\t\tgoto runtime_resume_failed;\n\n\tret = mma8452_get_odr_index(data);\n\tsleep_val = 1000 / mma8452_samp_freq[ret][0];\n\tif (sleep_val < 20)\n\t\tusleep_range(sleep_val * 1000, 20000);\n\telse\n\t\tmsleep_interruptible(sleep_val);\n\n\treturn 0;\n\nruntime_resume_failed:\n\tregulator_disable(data->vddio_reg);\n\tregulator_disable(data->vdd_reg);\n\n\treturn ret;\n}\n#endif\n\nstatic const struct dev_pm_ops mma8452_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(mma8452_runtime_suspend,\n\t\t\t   mma8452_runtime_resume, NULL)\n};\n\nstatic const struct i2c_device_id mma8452_id[] = {\n\t{ \"mma8451\", mma8451 },\n\t{ \"mma8452\", mma8452 },\n\t{ \"mma8453\", mma8453 },\n\t{ \"mma8652\", mma8652 },\n\t{ \"mma8653\", mma8653 },\n\t{ \"fxls8471\", fxls8471 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mma8452_id);\n\nstatic struct i2c_driver mma8452_driver = {\n\t.driver = {\n\t\t.name\t= \"mma8452\",\n\t\t.of_match_table = mma8452_dt_ids,\n\t\t.pm\t= &mma8452_pm_ops,\n\t},\n\t.probe = mma8452_probe,\n\t.remove = mma8452_remove,\n\t.id_table = mma8452_id,\n};\nmodule_i2c_driver(mma8452_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"Freescale / NXP MMA8452 accelerometer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}