{
  "module_name": "bmi088-accel-core.c",
  "hash_id": "b4dbd5541a729ff7073af194ac2f1d86e16a1e348709da00a36046e2f7befdd4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/bmi088-accel-core.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#include \"bmi088-accel.h\"\n\n#define BMI088_ACCEL_REG_CHIP_ID\t\t\t0x00\n#define BMI088_ACCEL_REG_ERROR\t\t\t\t0x02\n\n#define BMI088_ACCEL_REG_INT_STATUS\t\t\t0x1D\n#define BMI088_ACCEL_INT_STATUS_BIT_DRDY\t\tBIT(7)\n\n#define BMI088_ACCEL_REG_RESET\t\t\t\t0x7E\n#define BMI088_ACCEL_RESET_VAL\t\t\t\t0xB6\n\n#define BMI088_ACCEL_REG_PWR_CTRL\t\t\t0x7D\n#define BMI088_ACCEL_REG_PWR_CONF\t\t\t0x7C\n\n#define BMI088_ACCEL_REG_INT_MAP_DATA\t\t\t0x58\n#define BMI088_ACCEL_INT_MAP_DATA_BIT_INT1_DRDY\t\tBIT(2)\n#define BMI088_ACCEL_INT_MAP_DATA_BIT_INT2_FWM\t\tBIT(5)\n\n#define BMI088_ACCEL_REG_INT1_IO_CONF\t\t\t0x53\n#define BMI088_ACCEL_INT1_IO_CONF_BIT_ENABLE_OUT\tBIT(3)\n#define BMI088_ACCEL_INT1_IO_CONF_BIT_LVL\t\tBIT(1)\n\n#define BMI088_ACCEL_REG_INT2_IO_CONF\t\t\t0x54\n#define BMI088_ACCEL_INT2_IO_CONF_BIT_ENABLE_OUT\tBIT(3)\n#define BMI088_ACCEL_INT2_IO_CONF_BIT_LVL\t\tBIT(1)\n\n#define BMI088_ACCEL_REG_ACC_CONF\t\t\t0x40\n#define BMI088_ACCEL_MODE_ODR_MASK\t\t\t0x0f\n\n#define BMI088_ACCEL_REG_ACC_RANGE\t\t\t0x41\n#define BMI088_ACCEL_RANGE_3G\t\t\t\t0x00\n#define BMI088_ACCEL_RANGE_6G\t\t\t\t0x01\n#define BMI088_ACCEL_RANGE_12G\t\t\t\t0x02\n#define BMI088_ACCEL_RANGE_24G\t\t\t\t0x03\n\n#define BMI088_ACCEL_REG_TEMP\t\t\t\t0x22\n#define BMI088_ACCEL_REG_TEMP_SHIFT\t\t\t5\n#define BMI088_ACCEL_TEMP_UNIT\t\t\t\t125\n#define BMI088_ACCEL_TEMP_OFFSET\t\t\t23000\n\n#define BMI088_ACCEL_REG_XOUT_L\t\t\t\t0x12\n#define BMI088_ACCEL_AXIS_TO_REG(axis) \\\n\t(BMI088_ACCEL_REG_XOUT_L + (axis * 2))\n\n#define BMI088_ACCEL_MAX_STARTUP_TIME_US\t\t1000\n#define BMI088_AUTO_SUSPEND_DELAY_MS\t\t\t2000\n\n#define BMI088_ACCEL_REG_FIFO_STATUS\t\t\t0x0E\n#define BMI088_ACCEL_REG_FIFO_CONFIG0\t\t\t0x48\n#define BMI088_ACCEL_REG_FIFO_CONFIG1\t\t\t0x49\n#define BMI088_ACCEL_REG_FIFO_DATA\t\t\t0x3F\n#define BMI088_ACCEL_FIFO_LENGTH\t\t\t100\n\n#define BMI088_ACCEL_FIFO_MODE_FIFO\t\t\t0x40\n#define BMI088_ACCEL_FIFO_MODE_STREAM\t\t\t0x80\n\n#define BMIO088_ACCEL_ACC_RANGE_MSK\t\t\tGENMASK(1, 0)\n\nenum bmi088_accel_axis {\n\tAXIS_X,\n\tAXIS_Y,\n\tAXIS_Z,\n};\n\nstatic const int bmi088_sample_freqs[] = {\n\t12, 500000,\n\t25, 0,\n\t50, 0,\n\t100, 0,\n\t200, 0,\n\t400, 0,\n\t800, 0,\n\t1600, 0,\n};\n\n \nenum bmi088_osr_modes {\n\tBMI088_ACCEL_MODE_OSR_NORMAL = 0xA,\n\tBMI088_ACCEL_MODE_OSR_2 = 0x9,\n\tBMI088_ACCEL_MODE_OSR_4 = 0x8,\n};\n\n \nenum bmi088_odr_modes {\n\tBMI088_ACCEL_MODE_ODR_12_5 = 0x5,\n\tBMI088_ACCEL_MODE_ODR_25 = 0x6,\n\tBMI088_ACCEL_MODE_ODR_50 = 0x7,\n\tBMI088_ACCEL_MODE_ODR_100 = 0x8,\n\tBMI088_ACCEL_MODE_ODR_200 = 0x9,\n\tBMI088_ACCEL_MODE_ODR_400 = 0xa,\n\tBMI088_ACCEL_MODE_ODR_800 = 0xb,\n\tBMI088_ACCEL_MODE_ODR_1600 = 0xc,\n};\n\nstruct bmi088_scale_info {\n\tint scale;\n\tu8 reg_range;\n};\n\nstruct bmi088_accel_chip_info {\n\tconst char *name;\n\tu8 chip_id;\n\tconst struct iio_chan_spec *channels;\n\tint num_channels;\n\tconst int scale_table[4][2];\n};\n\nstruct bmi088_accel_data {\n\tstruct regmap *regmap;\n\tconst struct bmi088_accel_chip_info *chip_info;\n\tu8 buffer[2] __aligned(IIO_DMA_MINALIGN);  \n};\n\nstatic const struct regmap_range bmi088_volatile_ranges[] = {\n\t \n\tregmap_reg_range(BMI088_ACCEL_REG_ERROR, 0x3f),\n\t \n\tregmap_reg_range(BMI088_ACCEL_REG_RESET, BMI088_ACCEL_REG_RESET),\n};\n\nstatic const struct regmap_access_table bmi088_volatile_table = {\n\t.yes_ranges\t= bmi088_volatile_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(bmi088_volatile_ranges),\n};\n\nconst struct regmap_config bmi088_regmap_conf = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x7E,\n\t.volatile_table = &bmi088_volatile_table,\n\t.cache_type = REGCACHE_RBTREE,\n};\nEXPORT_SYMBOL_NS_GPL(bmi088_regmap_conf, IIO_BMI088);\n\nstatic int bmi088_accel_power_up(struct bmi088_accel_data *data)\n{\n\tint ret;\n\n\t \n\tret = regmap_write(data->regmap, BMI088_ACCEL_REG_PWR_CTRL, 0x4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(5000, 6000);\n\n\t \n\tret = regmap_write(data->regmap, BMI088_ACCEL_REG_PWR_CONF, 0x0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(1000, 1200);\n\n\treturn 0;\n}\n\nstatic int bmi088_accel_power_down(struct bmi088_accel_data *data)\n{\n\tint ret;\n\n\t \n\tret = regmap_write(data->regmap, BMI088_ACCEL_REG_PWR_CONF, 0x3);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(1000, 1200);\n\n\t \n\tret = regmap_write(data->regmap, BMI088_ACCEL_REG_PWR_CTRL, 0x0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(5000, 6000);\n\n\treturn 0;\n}\n\nstatic int bmi088_accel_get_sample_freq(struct bmi088_accel_data *data,\n\t\t\t\t\tint *val, int *val2)\n{\n\tunsigned int value;\n\tint ret;\n\n\tret = regmap_read(data->regmap, BMI088_ACCEL_REG_ACC_CONF,\n\t\t\t  &value);\n\tif (ret)\n\t\treturn ret;\n\n\tvalue &= BMI088_ACCEL_MODE_ODR_MASK;\n\tvalue -= BMI088_ACCEL_MODE_ODR_12_5;\n\tvalue <<= 1;\n\n\tif (value >= ARRAY_SIZE(bmi088_sample_freqs) - 1)\n\t\treturn -EINVAL;\n\n\t*val = bmi088_sample_freqs[value];\n\t*val2 = bmi088_sample_freqs[value + 1];\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int bmi088_accel_set_sample_freq(struct bmi088_accel_data *data, int val)\n{\n\tunsigned int regval;\n\tint index = 0;\n\n\twhile (index < ARRAY_SIZE(bmi088_sample_freqs) &&\n\t       bmi088_sample_freqs[index] != val)\n\t\tindex += 2;\n\n\tif (index >= ARRAY_SIZE(bmi088_sample_freqs))\n\t\treturn -EINVAL;\n\n\tregval = (index >> 1) + BMI088_ACCEL_MODE_ODR_12_5;\n\n\treturn regmap_update_bits(data->regmap, BMI088_ACCEL_REG_ACC_CONF,\n\t\t\t\t  BMI088_ACCEL_MODE_ODR_MASK, regval);\n}\n\nstatic int bmi088_accel_set_scale(struct bmi088_accel_data *data, int val, int val2)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (val  == data->chip_info->scale_table[i][0] &&\n\t\t    val2 == data->chip_info->scale_table[i][1])\n\t\t\tbreak;\n\n\tif (i == 4)\n\t\treturn -EINVAL;\n\n\treturn regmap_write(data->regmap, BMI088_ACCEL_REG_ACC_RANGE, i);\n}\n\nstatic int bmi088_accel_get_temp(struct bmi088_accel_data *data, int *val)\n{\n\tint ret;\n\ts16 temp;\n\n\tret = regmap_bulk_read(data->regmap, BMI088_ACCEL_REG_TEMP,\n\t\t\t       &data->buffer, sizeof(__be16));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttemp = be16_to_cpu(*(__be16 *)data->buffer);\n\n\t*val = temp >> BMI088_ACCEL_REG_TEMP_SHIFT;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int bmi088_accel_get_axis(struct bmi088_accel_data *data,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int *val)\n{\n\tint ret;\n\ts16 raw_val;\n\n\tret = regmap_bulk_read(data->regmap,\n\t\t\t       BMI088_ACCEL_AXIS_TO_REG(chan->scan_index),\n\t\t\t       data->buffer, sizeof(__le16));\n\tif (ret)\n\t\treturn ret;\n\n\traw_val = le16_to_cpu(*(__le16 *)data->buffer);\n\t*val = raw_val;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int bmi088_accel_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int *val, int *val2, long mask)\n{\n\tstruct bmi088_accel_data *data = iio_priv(indio_dev);\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\tint reg;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\tret = pm_runtime_resume_and_get(dev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = bmi088_accel_get_temp(data, val);\n\t\t\tgoto out_read_raw_pm_put;\n\t\tcase IIO_ACCEL:\n\t\t\tret = pm_runtime_resume_and_get(dev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\t\tif (ret)\n\t\t\t\tgoto out_read_raw_pm_put;\n\n\t\t\tret = bmi088_accel_get_axis(data, chan, val);\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\tif (!ret)\n\t\t\t\tret = IIO_VAL_INT;\n\n\t\t\tgoto out_read_raw_pm_put;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = BMI088_ACCEL_TEMP_OFFSET/BMI088_ACCEL_TEMP_UNIT;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = BMI088_ACCEL_TEMP_UNIT;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_ACCEL:\n\t\t\tret = pm_runtime_resume_and_get(dev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = regmap_read(data->regmap,\n\t\t\t\t\t  BMI088_ACCEL_REG_ACC_RANGE, &reg);\n\t\t\tif (ret)\n\t\t\t\tgoto out_read_raw_pm_put;\n\n\t\t\treg = FIELD_GET(BMIO088_ACCEL_ACC_RANGE_MSK, reg);\n\t\t\t*val  = data->chip_info->scale_table[reg][0];\n\t\t\t*val2 = data->chip_info->scale_table[reg][1];\n\t\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\n\t\t\tgoto out_read_raw_pm_put;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = bmi088_accel_get_sample_freq(data, val, val2);\n\t\tgoto out_read_raw_pm_put;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n\nout_read_raw_pm_put:\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nstatic int bmi088_accel_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type, int *length,\n\t\t\t     long mask)\n{\n\tstruct bmi088_accel_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*vals = (const int *)data->chip_info->scale_table;\n\t\t*length = 8;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t*vals = bmi088_sample_freqs;\n\t\t*length = ARRAY_SIZE(bmi088_sample_freqs);\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bmi088_accel_write_raw(struct iio_dev *indio_dev,\n\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t  int val, int val2, long mask)\n{\n\tstruct bmi088_accel_data *data = iio_priv(indio_dev);\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = bmi088_accel_set_scale(data, val, val2);\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tpm_runtime_put_autosuspend(dev);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = bmi088_accel_set_sample_freq(data, val);\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tpm_runtime_put_autosuspend(dev);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#define BMI088_ACCEL_CHANNEL(_axis) { \\\n\t.type = IIO_ACCEL, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_##_axis, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE), \\\n\t.scan_index = AXIS_##_axis, \\\n}\n\nstatic const struct iio_chan_spec bmi088_accel_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.scan_index = -1,\n\t},\n\tBMI088_ACCEL_CHANNEL(X),\n\tBMI088_ACCEL_CHANNEL(Y),\n\tBMI088_ACCEL_CHANNEL(Z),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic const struct bmi088_accel_chip_info bmi088_accel_chip_info_tbl[] = {\n\t[BOSCH_BMI085] = {\n\t\t.name = \"bmi085-accel\",\n\t\t.chip_id = 0x1F,\n\t\t.channels = bmi088_accel_channels,\n\t\t.num_channels = ARRAY_SIZE(bmi088_accel_channels),\n\t\t.scale_table = {{0, 598}, {0, 1196}, {0, 2393}, {0, 4785}},\n\t},\n\t[BOSCH_BMI088] = {\n\t\t.name = \"bmi088-accel\",\n\t\t.chip_id = 0x1E,\n\t\t.channels = bmi088_accel_channels,\n\t\t.num_channels = ARRAY_SIZE(bmi088_accel_channels),\n\t\t.scale_table = {{0, 897}, {0, 1794}, {0, 3589}, {0, 7178}},\n\t},\n\t[BOSCH_BMI090L] = {\n\t\t.name = \"bmi090l-accel\",\n\t\t.chip_id = 0x1A,\n\t\t.channels = bmi088_accel_channels,\n\t\t.num_channels = ARRAY_SIZE(bmi088_accel_channels),\n\t\t.scale_table = {{0, 897}, {0, 1794}, {0, 3589}, {0, 7178}},\n\t},\n};\n\nstatic const struct iio_info bmi088_accel_info = {\n\t.read_raw\t= bmi088_accel_read_raw,\n\t.write_raw\t= bmi088_accel_write_raw,\n\t.read_avail\t= bmi088_accel_read_avail,\n};\n\nstatic const unsigned long bmi088_accel_scan_masks[] = {\n\tBIT(AXIS_X) | BIT(AXIS_Y) | BIT(AXIS_Z),\n\t0\n};\n\nstatic int bmi088_accel_chip_init(struct bmi088_accel_data *data, enum bmi_device_type type)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret, i;\n\tunsigned int val;\n\n\tif (type >= BOSCH_UNKNOWN)\n\t\treturn -ENODEV;\n\n\t \n\tregmap_read(data->regmap, BMI088_ACCEL_REG_INT_STATUS, &val);\n\n\t \n\tret = regmap_write(data->regmap, BMI088_ACCEL_REG_RESET,\n\t\t\t   BMI088_ACCEL_RESET_VAL);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(1000, 2000);\n\n\t \n\tregmap_read(data->regmap, BMI088_ACCEL_REG_INT_STATUS, &val);\n\n\t \n\tret = regmap_read(data->regmap, BMI088_ACCEL_REG_CHIP_ID, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"Error: Reading chip id\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(bmi088_accel_chip_info_tbl); i++)\n\t\tif (bmi088_accel_chip_info_tbl[i].chip_id == val)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(bmi088_accel_chip_info_tbl))\n\t\tdata->chip_info = &bmi088_accel_chip_info_tbl[type];\n\telse\n\t\tdata->chip_info = &bmi088_accel_chip_info_tbl[i];\n\n\tif (i != type)\n\t\tdev_warn(dev, \"unexpected chip id 0x%X\\n\", val);\n\n\treturn 0;\n}\n\nint bmi088_accel_core_probe(struct device *dev, struct regmap *regmap,\n\tint irq, enum bmi_device_type type)\n{\n\tstruct bmi088_accel_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdev_set_drvdata(dev, indio_dev);\n\n\tdata->regmap = regmap;\n\n\tret = bmi088_accel_chip_init(data, type);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->channels = data->chip_info->channels;\n\tindio_dev->num_channels = data->chip_info->num_channels;\n\tindio_dev->name = data->chip_info->name;\n\tindio_dev->available_scan_masks = bmi088_accel_scan_masks;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &bmi088_accel_info;\n\n\t \n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_enable(dev);\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 6000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_put(dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tdev_err(dev, \"Unable to register iio device\\n\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(bmi088_accel_core_probe, IIO_BMI088);\n\n\nvoid bmi088_accel_core_remove(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmi088_accel_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tbmi088_accel_power_down(data);\n}\nEXPORT_SYMBOL_NS_GPL(bmi088_accel_core_remove, IIO_BMI088);\n\nstatic int bmi088_accel_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmi088_accel_data *data = iio_priv(indio_dev);\n\n\treturn bmi088_accel_power_down(data);\n}\n\nstatic int bmi088_accel_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmi088_accel_data *data = iio_priv(indio_dev);\n\n\treturn bmi088_accel_power_up(data);\n}\n\nEXPORT_NS_GPL_RUNTIME_DEV_PM_OPS(bmi088_accel_pm_ops,\n\t\t\t\t bmi088_accel_runtime_suspend,\n\t\t\t\t bmi088_accel_runtime_resume, NULL,\n\t\t\t\t IIO_BMI088);\n\nMODULE_AUTHOR(\"Niek van Agt <niek.van.agt@topicproducts.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"BMI088 accelerometer driver (core)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}