{
  "module_name": "ssp_accel_sensor.c",
  "hash_id": "a209799c9683341c67e31040eab9739529c57cc3457ff08774a55709d1940fed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/ssp_accel_sensor.c",
  "human_readable_source": "\n \n\n#include <linux/iio/common/ssp_sensors.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/kfifo_buf.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include \"../common/ssp_sensors/ssp_iio_sensor.h\"\n\n#define SSP_CHANNEL_COUNT 3\n\n#define SSP_ACCEL_NAME \"ssp-accelerometer\"\nstatic const char ssp_accel_device_name[] = SSP_ACCEL_NAME;\n\nenum ssp_accel_3d_channel {\n\tSSP_CHANNEL_SCAN_INDEX_X,\n\tSSP_CHANNEL_SCAN_INDEX_Y,\n\tSSP_CHANNEL_SCAN_INDEX_Z,\n\tSSP_CHANNEL_SCAN_INDEX_TIME,\n};\n\nstatic int ssp_accel_read_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,  int *val,\n\t\t\t      int *val2, long mask)\n{\n\tu32 t;\n\tstruct ssp_data *data = dev_get_drvdata(indio_dev->dev.parent->parent);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tt = ssp_get_sensor_delay(data, SSP_ACCELEROMETER_SENSOR);\n\t\tssp_convert_to_freq(t, val, val2);\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ssp_accel_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan, int val,\n\t\t\t       int val2, long mask)\n{\n\tint ret;\n\tstruct ssp_data *data = dev_get_drvdata(indio_dev->dev.parent->parent);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = ssp_convert_to_time(val, val2);\n\t\tret = ssp_change_delay(data, SSP_ACCELEROMETER_SENSOR, ret);\n\t\tif (ret < 0)\n\t\t\tdev_err(&indio_dev->dev, \"accel sensor enable fail\\n\");\n\n\t\treturn ret;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info ssp_accel_iio_info = {\n\t.read_raw = &ssp_accel_read_raw,\n\t.write_raw = &ssp_accel_write_raw,\n};\n\nstatic const unsigned long ssp_accel_scan_mask[] = { 0x7, 0, };\n\nstatic const struct iio_chan_spec ssp_acc_channels[] = {\n\tSSP_CHANNEL_AG(IIO_ACCEL, IIO_MOD_X, SSP_CHANNEL_SCAN_INDEX_X),\n\tSSP_CHANNEL_AG(IIO_ACCEL, IIO_MOD_Y, SSP_CHANNEL_SCAN_INDEX_Y),\n\tSSP_CHANNEL_AG(IIO_ACCEL, IIO_MOD_Z, SSP_CHANNEL_SCAN_INDEX_Z),\n\tSSP_CHAN_TIMESTAMP(SSP_CHANNEL_SCAN_INDEX_TIME),\n};\n\nstatic int ssp_process_accel_data(struct iio_dev *indio_dev, void *buf,\n\t\t\t\t  int64_t timestamp)\n{\n\treturn ssp_common_process_data(indio_dev, buf, SSP_ACCELEROMETER_SIZE,\n\t\t\t\t       timestamp);\n}\n\nstatic const struct iio_buffer_setup_ops ssp_accel_buffer_ops = {\n\t.postenable = &ssp_common_buffer_postenable,\n\t.postdisable = &ssp_common_buffer_postdisable,\n};\n\nstatic int ssp_accel_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\tstruct ssp_sensor_data *spd;\n\n\tindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*spd));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tspd = iio_priv(indio_dev);\n\n\tspd->process_data = ssp_process_accel_data;\n\tspd->type = SSP_ACCELEROMETER_SENSOR;\n\n\tindio_dev->name = ssp_accel_device_name;\n\tindio_dev->info = &ssp_accel_iio_info;\n\tindio_dev->channels = ssp_acc_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ssp_acc_channels);\n\tindio_dev->available_scan_masks = ssp_accel_scan_mask;\n\n\tret = devm_iio_kfifo_buffer_setup(&pdev->dev, indio_dev,\n\t\t\t\t\t  &ssp_accel_buffer_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tret = devm_iio_device_register(&pdev->dev, indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tssp_register_consumer(indio_dev, SSP_ACCELEROMETER_SENSOR);\n\n\treturn 0;\n}\n\nstatic struct platform_driver ssp_accel_driver = {\n\t.driver = {\n\t\t.name = SSP_ACCEL_NAME,\n\t},\n\t.probe = ssp_accel_probe,\n};\n\nmodule_platform_driver(ssp_accel_driver);\n\nMODULE_AUTHOR(\"Karol Wrona <k.wrona@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung sensorhub accelerometers driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IIO_SSP_SENSORS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}