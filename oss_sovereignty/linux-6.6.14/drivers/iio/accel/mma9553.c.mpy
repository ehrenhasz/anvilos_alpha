{
  "module_name": "mma9553.c",
  "hash_id": "c4bc68d0933918dcd8906dcb1b5d06d19badef5046fed70513b927037cf35637",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/mma9553.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n#include <linux/pm_runtime.h>\n#include \"mma9551_core.h\"\n\n#define MMA9553_DRV_NAME\t\t\t\"mma9553\"\n#define MMA9553_IRQ_NAME\t\t\t\"mma9553_event\"\n\n \n#define MMA9553_REG_CONF_SLEEPMIN\t\t0x00\n#define MMA9553_REG_CONF_SLEEPMAX\t\t0x02\n#define MMA9553_REG_CONF_SLEEPTHD\t\t0x04\n#define MMA9553_MASK_CONF_WORD\t\t\tGENMASK(15, 0)\n\n#define MMA9553_REG_CONF_CONF_STEPLEN\t\t0x06\n#define MMA9553_MASK_CONF_CONFIG\t\tBIT(15)\n#define MMA9553_MASK_CONF_ACT_DBCNTM\t\tBIT(14)\n#define MMA9553_MASK_CONF_SLP_DBCNTM\t\tBIT(13)\n#define MMA9553_MASK_CONF_STEPLEN\t\tGENMASK(7, 0)\n\n#define MMA9553_REG_CONF_HEIGHT_WEIGHT\t\t0x08\n#define MMA9553_MASK_CONF_HEIGHT\t\tGENMASK(15, 8)\n#define MMA9553_MASK_CONF_WEIGHT\t\tGENMASK(7, 0)\n\n#define MMA9553_REG_CONF_FILTER\t\t\t0x0A\n#define MMA9553_MASK_CONF_FILTSTEP\t\tGENMASK(15, 8)\n#define MMA9553_MASK_CONF_MALE\t\t\tBIT(7)\n#define MMA9553_MASK_CONF_FILTTIME\t\tGENMASK(6, 0)\n\n#define MMA9553_REG_CONF_SPEED_STEP\t\t0x0C\n#define MMA9553_MASK_CONF_SPDPRD\t\tGENMASK(15, 8)\n#define MMA9553_MASK_CONF_STEPCOALESCE\t\tGENMASK(7, 0)\n\n#define MMA9553_REG_CONF_ACTTHD\t\t\t0x0E\n#define MMA9553_MAX_ACTTHD\t\t\tGENMASK(15, 0)\n\n \n#define MMA9553_REG_STATUS\t\t\t0x00\n#define MMA9553_MASK_STATUS_MRGFL\t\tBIT(15)\n#define MMA9553_MASK_STATUS_SUSPCHG\t\tBIT(14)\n#define MMA9553_MASK_STATUS_STEPCHG\t\tBIT(13)\n#define MMA9553_MASK_STATUS_ACTCHG\t\tBIT(12)\n#define MMA9553_MASK_STATUS_SUSP\t\tBIT(11)\n#define MMA9553_MASK_STATUS_ACTIVITY\t\tGENMASK(10, 8)\n#define MMA9553_MASK_STATUS_VERSION\t\tGENMASK(7, 0)\n\n#define MMA9553_REG_STEPCNT\t\t\t0x02\n#define MMA9553_REG_DISTANCE\t\t\t0x04\n#define MMA9553_REG_SPEED\t\t\t0x06\n#define MMA9553_REG_CALORIES\t\t\t0x08\n#define MMA9553_REG_SLEEPCNT\t\t\t0x0A\n\n \n#define MMA9553_DEFAULT_GPIO_PIN\tmma9551_gpio6\n#define MMA9553_DEFAULT_GPIO_POLARITY\t0\n\n \n#define MMA9553_STATUS_TO_BITNUM(bit)\t(ffs(bit) - 9)\n#define MMA9553_MAX_BITNUM\t\tMMA9553_STATUS_TO_BITNUM(BIT(16))\n\n#define MMA9553_DEFAULT_SAMPLE_RATE\t30\t \n\n \n#define MMA9553_ACTIVITY_THD_TO_SEC(thd) ((thd) / MMA9553_DEFAULT_SAMPLE_RATE)\n#define MMA9553_ACTIVITY_SEC_TO_THD(sec) ((sec) * MMA9553_DEFAULT_SAMPLE_RATE)\n\n \n#define MMA9553_DEFAULT_SLEEPMIN\t3688\t \n#define MMA9553_DEFAULT_SLEEPMAX\t4508\t \n#define MMA9553_DEFAULT_SLEEPTHD\t(MMA9553_DEFAULT_SAMPLE_RATE * 30)\n\n#define MMA9553_CONFIG_RETRIES\t\t2\n\n \nenum activity_level {\n\tACTIVITY_UNKNOWN,\n\tACTIVITY_REST,\n\tACTIVITY_WALKING,\n\tACTIVITY_JOGGING,\n\tACTIVITY_RUNNING,\n};\n\nstatic struct mma9553_event_info {\n\tenum iio_chan_type type;\n\tenum iio_modifier mod;\n\tenum iio_event_direction dir;\n} mma9553_events_info[] = {\n\t{\n\t\t.type = IIO_STEPS,\n\t\t.mod = IIO_NO_MOD,\n\t\t.dir = IIO_EV_DIR_NONE,\n\t},\n\t{\n\t\t.type = IIO_ACTIVITY,\n\t\t.mod = IIO_MOD_STILL,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t},\n\t{\n\t\t.type = IIO_ACTIVITY,\n\t\t.mod = IIO_MOD_STILL,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t},\n\t{\n\t\t.type = IIO_ACTIVITY,\n\t\t.mod = IIO_MOD_WALKING,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t},\n\t{\n\t\t.type = IIO_ACTIVITY,\n\t\t.mod = IIO_MOD_WALKING,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t},\n\t{\n\t\t.type = IIO_ACTIVITY,\n\t\t.mod = IIO_MOD_JOGGING,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t},\n\t{\n\t\t.type = IIO_ACTIVITY,\n\t\t.mod = IIO_MOD_JOGGING,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t},\n\t{\n\t\t.type = IIO_ACTIVITY,\n\t\t.mod = IIO_MOD_RUNNING,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t},\n\t{\n\t\t.type = IIO_ACTIVITY,\n\t\t.mod = IIO_MOD_RUNNING,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t},\n};\n\n#define MMA9553_EVENTS_INFO_SIZE ARRAY_SIZE(mma9553_events_info)\n\nstruct mma9553_event {\n\tstruct mma9553_event_info *info;\n\tbool enabled;\n};\n\nstruct mma9553_conf_regs {\n\tu16 sleepmin;\n\tu16 sleepmax;\n\tu16 sleepthd;\n\tu16 config;\n\tu16 height_weight;\n\tu16 filter;\n\tu16 speed_step;\n\tu16 actthd;\n} __packed;\n\nstruct mma9553_data {\n\tstruct i2c_client *client;\n\t \n\tstruct mutex mutex;\n\tstruct mma9553_conf_regs conf;\n\tstruct mma9553_event events[MMA9553_EVENTS_INFO_SIZE];\n\tint num_events;\n\tu8 gpio_bitnum;\n\t \n\tbool stepcnt_enabled;\n\tu16 stepcnt;\n\tu8 activity;\n\ts64 timestamp;\n};\n\nstatic u8 mma9553_get_bits(u16 val, u16 mask)\n{\n\treturn (val & mask) >> (ffs(mask) - 1);\n}\n\nstatic u16 mma9553_set_bits(u16 current_val, u16 val, u16 mask)\n{\n\treturn (current_val & ~mask) | (val << (ffs(mask) - 1));\n}\n\nstatic enum iio_modifier mma9553_activity_to_mod(enum activity_level activity)\n{\n\tswitch (activity) {\n\tcase ACTIVITY_RUNNING:\n\t\treturn IIO_MOD_RUNNING;\n\tcase ACTIVITY_JOGGING:\n\t\treturn IIO_MOD_JOGGING;\n\tcase ACTIVITY_WALKING:\n\t\treturn IIO_MOD_WALKING;\n\tcase ACTIVITY_REST:\n\t\treturn IIO_MOD_STILL;\n\tcase ACTIVITY_UNKNOWN:\n\tdefault:\n\t\treturn IIO_NO_MOD;\n\t}\n}\n\nstatic void mma9553_init_events(struct mma9553_data *data)\n{\n\tint i;\n\n\tdata->num_events = MMA9553_EVENTS_INFO_SIZE;\n\tfor (i = 0; i < data->num_events; i++) {\n\t\tdata->events[i].info = &mma9553_events_info[i];\n\t\tdata->events[i].enabled = false;\n\t}\n}\n\nstatic struct mma9553_event *mma9553_get_event(struct mma9553_data *data,\n\t\t\t\t\t       enum iio_chan_type type,\n\t\t\t\t\t       enum iio_modifier mod,\n\t\t\t\t\t       enum iio_event_direction dir)\n{\n\tint i;\n\n\tfor (i = 0; i < data->num_events; i++)\n\t\tif (data->events[i].info->type == type &&\n\t\t    data->events[i].info->mod == mod &&\n\t\t    data->events[i].info->dir == dir)\n\t\t\treturn &data->events[i];\n\n\treturn NULL;\n}\n\nstatic bool mma9553_is_any_event_enabled(struct mma9553_data *data,\n\t\t\t\t\t bool check_type,\n\t\t\t\t\t enum iio_chan_type type)\n{\n\tint i;\n\n\tfor (i = 0; i < data->num_events; i++)\n\t\tif ((check_type && data->events[i].info->type == type &&\n\t\t     data->events[i].enabled) ||\n\t\t     (!check_type && data->events[i].enabled))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int mma9553_set_config(struct mma9553_data *data, u16 reg,\n\t\t\t      u16 *p_reg_val, u16 val, u16 mask)\n{\n\tint ret, retries;\n\tu16 reg_val, config;\n\n\treg_val = *p_reg_val;\n\tif (val == mma9553_get_bits(reg_val, mask))\n\t\treturn 0;\n\n\treg_val = mma9553_set_bits(reg_val, val, mask);\n\tret = mma9551_write_config_word(data->client, MMA9551_APPID_PEDOMETER,\n\t\t\t\t\treg, reg_val);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"error writing config register 0x%x\\n\", reg);\n\t\treturn ret;\n\t}\n\n\t*p_reg_val = reg_val;\n\n\t \n\tconfig = mma9553_set_bits(data->conf.config, 1,\n\t\t\t\t  MMA9553_MASK_CONF_CONFIG);\n\n\tret = mma9551_write_config_word(data->client, MMA9551_APPID_PEDOMETER,\n\t\t\t\t\tMMA9553_REG_CONF_CONF_STEPLEN, config);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"error writing config register 0x%x\\n\",\n\t\t\tMMA9553_REG_CONF_CONF_STEPLEN);\n\t\treturn ret;\n\t}\n\n\tretries = MMA9553_CONFIG_RETRIES;\n\tdo {\n\t\tmma9551_sleep(MMA9553_DEFAULT_SAMPLE_RATE);\n\t\tret = mma9551_read_config_word(data->client,\n\t\t\t\t\t       MMA9551_APPID_PEDOMETER,\n\t\t\t\t\t       MMA9553_REG_CONF_CONF_STEPLEN,\n\t\t\t\t\t       &config);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} while (mma9553_get_bits(config, MMA9553_MASK_CONF_CONFIG) &&\n\t\t --retries > 0);\n\n\treturn 0;\n}\n\nstatic int mma9553_read_activity_stepcnt(struct mma9553_data *data,\n\t\t\t\t\t u8 *activity, u16 *stepcnt)\n{\n\tu16 buf[2];\n\tint ret;\n\n\tret = mma9551_read_status_words(data->client, MMA9551_APPID_PEDOMETER,\n\t\t\t\t\tMMA9553_REG_STATUS, ARRAY_SIZE(buf),\n\t\t\t\t\tbuf);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"error reading status and stepcnt\\n\");\n\t\treturn ret;\n\t}\n\n\t*activity = mma9553_get_bits(buf[0], MMA9553_MASK_STATUS_ACTIVITY);\n\t*stepcnt = buf[1];\n\n\treturn 0;\n}\n\nstatic int mma9553_conf_gpio(struct mma9553_data *data)\n{\n\tu8 bitnum = 0, appid = MMA9551_APPID_PEDOMETER;\n\tint ret;\n\tstruct mma9553_event *ev_step_detect;\n\tbool activity_enabled;\n\n\tactivity_enabled = mma9553_is_any_event_enabled(data, true,\n\t\t\t\t\t\t\tIIO_ACTIVITY);\n\tev_step_detect = mma9553_get_event(data, IIO_STEPS, IIO_NO_MOD,\n\t\t\t\t\t   IIO_EV_DIR_NONE);\n\n\t \n\tif (activity_enabled && ev_step_detect->enabled)\n\t\tbitnum = MMA9553_STATUS_TO_BITNUM(MMA9553_MASK_STATUS_MRGFL);\n\telse if (ev_step_detect->enabled)\n\t\tbitnum = MMA9553_STATUS_TO_BITNUM(MMA9553_MASK_STATUS_STEPCHG);\n\telse if (activity_enabled)\n\t\tbitnum = MMA9553_STATUS_TO_BITNUM(MMA9553_MASK_STATUS_ACTCHG);\n\telse\t\t\t \n\t\tappid = MMA9551_APPID_NONE;\n\n\tif (data->gpio_bitnum == bitnum)\n\t\treturn 0;\n\n\t \n\tif (activity_enabled || ev_step_detect->enabled) {\n\t\tret = mma9553_read_activity_stepcnt(data, &data->activity,\n\t\t\t\t\t\t    &data->stepcnt);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = mma9551_gpio_config(data->client, MMA9553_DEFAULT_GPIO_PIN, appid,\n\t\t\t\t  bitnum, MMA9553_DEFAULT_GPIO_POLARITY);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->gpio_bitnum = bitnum;\n\n\treturn 0;\n}\n\nstatic int mma9553_init(struct mma9553_data *data)\n{\n\tint ret;\n\n\tret = mma9551_read_version(data->client);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mma9551_read_config_words(data->client, MMA9551_APPID_PEDOMETER,\n\t\t\t\t\tMMA9553_REG_CONF_SLEEPMIN,\n\t\t\t\t\tsizeof(data->conf) / sizeof(u16),\n\t\t\t\t\t(u16 *)&data->conf);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"failed to read configuration registers\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tdata->gpio_bitnum = MMA9553_MAX_BITNUM;\n\tret = mma9553_conf_gpio(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mma9551_app_reset(data->client, MMA9551_RSC_PED);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdata->conf.sleepmin = MMA9553_DEFAULT_SLEEPMIN;\n\tdata->conf.sleepmax = MMA9553_DEFAULT_SLEEPMAX;\n\tdata->conf.sleepthd = MMA9553_DEFAULT_SLEEPTHD;\n\tdata->conf.config = mma9553_set_bits(data->conf.config, 1,\n\t\t\t\t\t     MMA9553_MASK_CONF_CONFIG);\n\t \n\tdata->conf.config = mma9553_set_bits(data->conf.config, 1,\n\t\t\t\t\t     MMA9553_MASK_CONF_ACT_DBCNTM);\n\tret = mma9551_write_config_words(data->client, MMA9551_APPID_PEDOMETER,\n\t\t\t\t\t MMA9553_REG_CONF_SLEEPMIN,\n\t\t\t\t\t sizeof(data->conf) / sizeof(u16),\n\t\t\t\t\t (u16 *)&data->conf);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"failed to write configuration registers\\n\");\n\t\treturn ret;\n\t}\n\n\treturn mma9551_set_device_state(data->client, true);\n}\n\nstatic int mma9553_read_status_word(struct mma9553_data *data, u16 reg,\n\t\t\t\t    u16 *tmp)\n{\n\tbool powered_on;\n\tint ret;\n\n\t \n\tpowered_on = mma9553_is_any_event_enabled(data, false, 0) ||\n\t\t     data->stepcnt_enabled;\n\tif (!powered_on) {\n\t\tdev_err(&data->client->dev, \"No channels enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&data->mutex);\n\tret = mma9551_read_status_word(data->client, MMA9551_APPID_PEDOMETER,\n\t\t\t\t       reg, tmp);\n\tmutex_unlock(&data->mutex);\n\treturn ret;\n}\n\nstatic int mma9553_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\tint ret;\n\tu16 tmp;\n\tu8 activity;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_STEPS:\n\t\t\tret = mma9553_read_status_word(data,\n\t\t\t\t\t\t       MMA9553_REG_STEPCNT,\n\t\t\t\t\t\t       &tmp);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = tmp;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_DISTANCE:\n\t\t\tret = mma9553_read_status_word(data,\n\t\t\t\t\t\t       MMA9553_REG_DISTANCE,\n\t\t\t\t\t\t       &tmp);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = tmp;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_ACTIVITY:\n\t\t\tret = mma9553_read_status_word(data,\n\t\t\t\t\t\t       MMA9553_REG_STATUS,\n\t\t\t\t\t\t       &tmp);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tactivity =\n\t\t\t    mma9553_get_bits(tmp, MMA9553_MASK_STATUS_ACTIVITY);\n\n\t\t\t \n\t\t\tif (chan->channel2 == mma9553_activity_to_mod(activity))\n\t\t\t\t*val = 100;\n\t\t\telse\n\t\t\t\t*val = 0;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VELOCITY:\t \n\t\t\tif (chan->channel2 != IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z)\n\t\t\t\treturn -EINVAL;\n\t\t\tret = mma9553_read_status_word(data,\n\t\t\t\t\t\t       MMA9553_REG_SPEED,\n\t\t\t\t\t\t       &tmp);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = tmp;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_ENERGY:\t \n\t\t\tret = mma9553_read_status_word(data,\n\t\t\t\t\t\t       MMA9553_REG_CALORIES,\n\t\t\t\t\t\t       &tmp);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = tmp;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_ACCEL:\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tret = mma9551_read_accel_chan(data->client,\n\t\t\t\t\t\t      chan, val, val2);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VELOCITY:\t \n\t\t\tif (chan->channel2 != IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z)\n\t\t\t\treturn -EINVAL;\n\t\t\t*val = 0;\n\t\t\t*val2 = 277;\t \n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_ENERGY:\t \n\t\t\t*val = 4184;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_ACCEL:\n\t\t\treturn mma9551_read_accel_scale(val, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\t*val = data->stepcnt_enabled;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBHEIGHT:\n\t\ttmp = mma9553_get_bits(data->conf.height_weight,\n\t\t\t\t       MMA9553_MASK_CONF_HEIGHT);\n\t\t*val = tmp / 100;\t \n\t\t*val2 = (tmp % 100) * 10000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_CALIBWEIGHT:\n\t\t*val = mma9553_get_bits(data->conf.height_weight,\n\t\t\t\t\tMMA9553_MASK_CONF_WEIGHT);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_DEBOUNCE_COUNT:\n\t\tswitch (chan->type) {\n\t\tcase IIO_STEPS:\n\t\t\t*val = mma9553_get_bits(data->conf.filter,\n\t\t\t\t\t\tMMA9553_MASK_CONF_FILTSTEP);\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_DEBOUNCE_TIME:\n\t\tswitch (chan->type) {\n\t\tcase IIO_STEPS:\n\t\t\t*val = mma9553_get_bits(data->conf.filter,\n\t\t\t\t\t\tMMA9553_MASK_CONF_FILTTIME);\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VELOCITY:\n\t\t\tif (chan->channel2 != IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z)\n\t\t\t\treturn -EINVAL;\n\t\t\t*val = mma9553_get_bits(data->conf.speed_step,\n\t\t\t\t\t\tMMA9553_MASK_CONF_SPDPRD);\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mma9553_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\tint ret, tmp;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\tif (data->stepcnt_enabled == !!val)\n\t\t\treturn 0;\n\t\tmutex_lock(&data->mutex);\n\t\tret = mma9551_set_power_state(data->client, val);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tdata->stepcnt_enabled = val;\n\t\tmutex_unlock(&data->mutex);\n\t\treturn 0;\n\tcase IIO_CHAN_INFO_CALIBHEIGHT:\n\t\t \n\t\ttmp = val * 100 + val2 / 10000;\n\t\tif (tmp < 0 || tmp > 255)\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&data->mutex);\n\t\tret = mma9553_set_config(data,\n\t\t\t\t\t MMA9553_REG_CONF_HEIGHT_WEIGHT,\n\t\t\t\t\t &data->conf.height_weight,\n\t\t\t\t\t tmp, MMA9553_MASK_CONF_HEIGHT);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_CALIBWEIGHT:\n\t\tif (val < 0 || val > 255)\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&data->mutex);\n\t\tret = mma9553_set_config(data,\n\t\t\t\t\t MMA9553_REG_CONF_HEIGHT_WEIGHT,\n\t\t\t\t\t &data->conf.height_weight,\n\t\t\t\t\t val, MMA9553_MASK_CONF_WEIGHT);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_DEBOUNCE_COUNT:\n\t\tswitch (chan->type) {\n\t\tcase IIO_STEPS:\n\t\t\t \n\t\t\tif (val < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (val > 6)\n\t\t\t\tval = 6;\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tret = mma9553_set_config(data, MMA9553_REG_CONF_FILTER,\n\t\t\t\t\t\t &data->conf.filter, val,\n\t\t\t\t\t\t MMA9553_MASK_CONF_FILTSTEP);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_DEBOUNCE_TIME:\n\t\tswitch (chan->type) {\n\t\tcase IIO_STEPS:\n\t\t\tif (val < 0 || val > 127)\n\t\t\t\treturn -EINVAL;\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tret = mma9553_set_config(data, MMA9553_REG_CONF_FILTER,\n\t\t\t\t\t\t &data->conf.filter, val,\n\t\t\t\t\t\t MMA9553_MASK_CONF_FILTTIME);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VELOCITY:\n\t\t\tif (chan->channel2 != IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z)\n\t\t\t\treturn -EINVAL;\n\t\t\t \n\t\t\tif (val < 2)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (val > 5)\n\t\t\t\tval = 5;\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tret = mma9553_set_config(data,\n\t\t\t\t\t\t MMA9553_REG_CONF_SPEED_STEP,\n\t\t\t\t\t\t &data->conf.speed_step, val,\n\t\t\t\t\t\t MMA9553_MASK_CONF_SPDPRD);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mma9553_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir)\n{\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\tstruct mma9553_event *event;\n\n\tevent = mma9553_get_event(data, chan->type, chan->channel2, dir);\n\tif (!event)\n\t\treturn -EINVAL;\n\n\treturn event->enabled;\n}\n\nstatic int mma9553_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir, int state)\n{\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\tstruct mma9553_event *event;\n\tint ret;\n\n\tevent = mma9553_get_event(data, chan->type, chan->channel2, dir);\n\tif (!event)\n\t\treturn -EINVAL;\n\n\tif (event->enabled == state)\n\t\treturn 0;\n\n\tmutex_lock(&data->mutex);\n\n\tret = mma9551_set_power_state(data->client, state);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tevent->enabled = state;\n\n\tret = mma9553_conf_gpio(data);\n\tif (ret < 0)\n\t\tgoto err_conf_gpio;\n\n\tmutex_unlock(&data->mutex);\n\n\treturn 0;\n\nerr_conf_gpio:\n\tif (state) {\n\t\tevent->enabled = false;\n\t\tmma9551_set_power_state(data->client, false);\n\t}\nerr_out:\n\tmutex_unlock(&data->mutex);\n\treturn ret;\n}\n\nstatic int mma9553_read_event_value(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir,\n\t\t\t\t    enum iio_event_info info,\n\t\t\t\t    int *val, int *val2)\n{\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\n\t*val2 = 0;\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_STEPS:\n\t\t\t*val = mma9553_get_bits(data->conf.speed_step,\n\t\t\t\t\t\tMMA9553_MASK_CONF_STEPCOALESCE);\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_ACTIVITY:\n\t\t\t \n\t\t\t*val = 50;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_EV_INFO_PERIOD:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ACTIVITY:\n\t\t\t*val = MMA9553_ACTIVITY_THD_TO_SEC(data->conf.actthd);\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mma9553_write_event_value(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir,\n\t\t\t\t     enum iio_event_info info,\n\t\t\t\t     int val, int val2)\n{\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_STEPS:\n\t\t\tif (val < 0 || val > 255)\n\t\t\t\treturn -EINVAL;\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tret = mma9553_set_config(data,\n\t\t\t\t\t\tMMA9553_REG_CONF_SPEED_STEP,\n\t\t\t\t\t\t&data->conf.speed_step, val,\n\t\t\t\t\t\tMMA9553_MASK_CONF_STEPCOALESCE);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_EV_INFO_PERIOD:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ACTIVITY:\n\t\t\tif (val < 0 || val > MMA9553_ACTIVITY_THD_TO_SEC(\n\t\t\t    MMA9553_MAX_ACTTHD))\n\t\t\t\treturn -EINVAL;\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tret = mma9553_set_config(data, MMA9553_REG_CONF_ACTTHD,\n\t\t\t\t\t\t &data->conf.actthd,\n\t\t\t\t\t\t MMA9553_ACTIVITY_SEC_TO_THD\n\t\t\t\t\t\t (val), MMA9553_MASK_CONF_WORD);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mma9553_get_calibgender_mode(struct iio_dev *indio_dev,\n\t\t\t\t\tconst struct iio_chan_spec *chan)\n{\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\tu8 gender;\n\n\tgender = mma9553_get_bits(data->conf.filter, MMA9553_MASK_CONF_MALE);\n\t \n\treturn !gender;\n}\n\nstatic int mma9553_set_calibgender_mode(struct iio_dev *indio_dev,\n\t\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\t\tunsigned int mode)\n{\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\tu8 gender = !mode;\n\tint ret;\n\n\tif ((mode != 0) && (mode != 1))\n\t\treturn -EINVAL;\n\tmutex_lock(&data->mutex);\n\tret = mma9553_set_config(data, MMA9553_REG_CONF_FILTER,\n\t\t\t\t &data->conf.filter, gender,\n\t\t\t\t MMA9553_MASK_CONF_MALE);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic const struct iio_event_spec mma9553_step_event = {\n\t.type = IIO_EV_TYPE_CHANGE,\n\t.dir = IIO_EV_DIR_NONE,\n\t.mask_separate = BIT(IIO_EV_INFO_ENABLE) | BIT(IIO_EV_INFO_VALUE),\n};\n\nstatic const struct iio_event_spec mma9553_activity_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t\t BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t BIT(IIO_EV_INFO_PERIOD),\n\t },\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t\t BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t BIT(IIO_EV_INFO_PERIOD),\n\t},\n};\n\nstatic const char * const mma9553_calibgender_modes[] = { \"male\", \"female\" };\n\nstatic const struct iio_enum mma9553_calibgender_enum = {\n\t.items = mma9553_calibgender_modes,\n\t.num_items = ARRAY_SIZE(mma9553_calibgender_modes),\n\t.get = mma9553_get_calibgender_mode,\n\t.set = mma9553_set_calibgender_mode,\n};\n\nstatic const struct iio_chan_spec_ext_info mma9553_ext_info[] = {\n\tIIO_ENUM(\"calibgender\", IIO_SHARED_BY_TYPE, &mma9553_calibgender_enum),\n\tIIO_ENUM_AVAILABLE(\"calibgender\", IIO_SHARED_BY_TYPE, &mma9553_calibgender_enum),\n\t{},\n};\n\n#define MMA9553_PEDOMETER_CHANNEL(_type, _mask) {\t\t\\\n\t.type = _type,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_ENABLE)      |\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_CALIBHEIGHT) |\t\\\n\t\t\t      _mask,\t\t\t\t\\\n\t.ext_info = mma9553_ext_info,\t\t\t\t\\\n}\n\n#define MMA9553_ACTIVITY_CHANNEL(_chan2) {\t\t\t\t\\\n\t.type = IIO_ACTIVITY,\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = _chan2,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_CALIBHEIGHT) |\t\\\n\t\t\t\t    BIT(IIO_CHAN_INFO_ENABLE),\t\t\\\n\t.event_spec = mma9553_activity_events,\t\t\t\t\\\n\t.num_event_specs = ARRAY_SIZE(mma9553_activity_events),\t\t\\\n\t.ext_info = mma9553_ext_info,\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec mma9553_channels[] = {\n\tMMA9551_ACCEL_CHANNEL(IIO_MOD_X),\n\tMMA9551_ACCEL_CHANNEL(IIO_MOD_Y),\n\tMMA9551_ACCEL_CHANNEL(IIO_MOD_Z),\n\n\t{\n\t\t.type = IIO_STEPS,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t     BIT(IIO_CHAN_INFO_ENABLE) |\n\t\t\t\t     BIT(IIO_CHAN_INFO_DEBOUNCE_COUNT) |\n\t\t\t\t     BIT(IIO_CHAN_INFO_DEBOUNCE_TIME),\n\t\t.event_spec = &mma9553_step_event,\n\t\t.num_event_specs = 1,\n\t},\n\n\tMMA9553_PEDOMETER_CHANNEL(IIO_DISTANCE, BIT(IIO_CHAN_INFO_PROCESSED)),\n\t{\n\t\t.type = IIO_VELOCITY,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_ENABLE),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_CALIBHEIGHT),\n\t\t.ext_info = mma9553_ext_info,\n\t},\n\tMMA9553_PEDOMETER_CHANNEL(IIO_ENERGY, BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t  BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t  BIT(IIO_CHAN_INFO_CALIBWEIGHT)),\n\n\tMMA9553_ACTIVITY_CHANNEL(IIO_MOD_RUNNING),\n\tMMA9553_ACTIVITY_CHANNEL(IIO_MOD_JOGGING),\n\tMMA9553_ACTIVITY_CHANNEL(IIO_MOD_WALKING),\n\tMMA9553_ACTIVITY_CHANNEL(IIO_MOD_STILL),\n};\n\nstatic const struct iio_info mma9553_info = {\n\t.read_raw = mma9553_read_raw,\n\t.write_raw = mma9553_write_raw,\n\t.read_event_config = mma9553_read_event_config,\n\t.write_event_config = mma9553_write_event_config,\n\t.read_event_value = mma9553_read_event_value,\n\t.write_event_value = mma9553_write_event_value,\n};\n\nstatic irqreturn_t mma9553_irq_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\n\tdata->timestamp = iio_get_time_ns(indio_dev);\n\t \n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t mma9553_event_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\tu16 stepcnt;\n\tu8 activity;\n\tstruct mma9553_event *ev_activity, *ev_prev_activity, *ev_step_detect;\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = mma9553_read_activity_stepcnt(data, &activity, &stepcnt);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->mutex);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tev_prev_activity = mma9553_get_event(data, IIO_ACTIVITY,\n\t\t\t\t\t     mma9553_activity_to_mod(\n\t\t\t\t\t     data->activity),\n\t\t\t\t\t     IIO_EV_DIR_FALLING);\n\tev_activity = mma9553_get_event(data, IIO_ACTIVITY,\n\t\t\t\t\tmma9553_activity_to_mod(activity),\n\t\t\t\t\tIIO_EV_DIR_RISING);\n\tev_step_detect = mma9553_get_event(data, IIO_STEPS, IIO_NO_MOD,\n\t\t\t\t\t   IIO_EV_DIR_NONE);\n\n\tif (ev_step_detect->enabled && (stepcnt != data->stepcnt)) {\n\t\tdata->stepcnt = stepcnt;\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_EVENT_CODE(IIO_STEPS, 0, IIO_NO_MOD,\n\t\t\t\t\t      IIO_EV_DIR_NONE,\n\t\t\t\t\t      IIO_EV_TYPE_CHANGE, 0, 0, 0),\n\t\t\t       data->timestamp);\n\t}\n\n\tif (activity != data->activity) {\n\t\tdata->activity = activity;\n\t\t \n\t\tif (ev_prev_activity && ev_prev_activity->enabled)\n\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_EVENT_CODE(IIO_ACTIVITY, 0,\n\t\t\t\t\t\t    ev_prev_activity->info->mod,\n\t\t\t\t\t\t    IIO_EV_DIR_FALLING,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH, 0, 0,\n\t\t\t\t\t\t    0),\n\t\t\t\t       data->timestamp);\n\n\t\tif (ev_activity && ev_activity->enabled)\n\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_EVENT_CODE(IIO_ACTIVITY, 0,\n\t\t\t\t\t\t      ev_activity->info->mod,\n\t\t\t\t\t\t      IIO_EV_DIR_RISING,\n\t\t\t\t\t\t      IIO_EV_TYPE_THRESH, 0, 0,\n\t\t\t\t\t\t      0),\n\t\t\t\t       data->timestamp);\n\t}\n\tmutex_unlock(&data->mutex);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const char *mma9553_match_acpi_device(struct device *dev)\n{\n\tconst struct acpi_device_id *id;\n\n\tid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\tif (!id)\n\t\treturn NULL;\n\n\treturn dev_name(dev);\n}\n\nstatic int mma9553_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct mma9553_data *data;\n\tstruct iio_dev *indio_dev;\n\tconst char *name = NULL;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tif (id)\n\t\tname = id->name;\n\telse if (ACPI_HANDLE(&client->dev))\n\t\tname = mma9553_match_acpi_device(&client->dev);\n\telse\n\t\treturn -ENOSYS;\n\n\tmutex_init(&data->mutex);\n\tmma9553_init_events(data);\n\n\tret = mma9553_init(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tindio_dev->channels = mma9553_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mma9553_channels);\n\tindio_dev->name = name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &mma9553_info;\n\n\tif (client->irq > 0) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tmma9553_irq_handler,\n\t\t\t\t\t\tmma9553_event_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING,\n\t\t\t\t\t\tMMA9553_IRQ_NAME, indio_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"request irq %d failed\\n\",\n\t\t\t\tclient->irq);\n\t\t\tgoto out_poweroff;\n\t\t}\n\t}\n\n\tret = pm_runtime_set_active(&client->dev);\n\tif (ret < 0)\n\t\tgoto out_poweroff;\n\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev,\n\t\t\t\t\t MMA9551_AUTO_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"unable to register iio device\\n\");\n\t\tgoto err_pm_cleanup;\n\t}\n\n\tdev_dbg(&indio_dev->dev, \"Registered device %s\\n\", name);\n\treturn 0;\n\nerr_pm_cleanup:\n\tpm_runtime_dont_use_autosuspend(&client->dev);\n\tpm_runtime_disable(&client->dev);\nout_poweroff:\n\tmma9551_set_device_state(client, false);\n\treturn ret;\n}\n\nstatic void mma9553_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tmutex_lock(&data->mutex);\n\tmma9551_set_device_state(data->client, false);\n\tmutex_unlock(&data->mutex);\n}\n\nstatic int mma9553_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = mma9551_set_device_state(data->client, false);\n\tmutex_unlock(&data->mutex);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"powering off device failed\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic int mma9553_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = mma9551_set_device_state(data->client, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmma9551_sleep(MMA9553_DEFAULT_SAMPLE_RATE);\n\n\treturn 0;\n}\n\nstatic int mma9553_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = mma9551_set_device_state(data->client, false);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int mma9553_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mma9553_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = mma9551_set_device_state(data->client, true);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops mma9553_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(mma9553_suspend, mma9553_resume)\n\tRUNTIME_PM_OPS(mma9553_runtime_suspend, mma9553_runtime_resume, NULL)\n};\n\nstatic const struct acpi_device_id mma9553_acpi_match[] = {\n\t{\"MMA9553\", 0},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(acpi, mma9553_acpi_match);\n\nstatic const struct i2c_device_id mma9553_id[] = {\n\t{\"mma9553\", 0},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, mma9553_id);\n\nstatic struct i2c_driver mma9553_driver = {\n\t.driver = {\n\t\t   .name = MMA9553_DRV_NAME,\n\t\t   .acpi_match_table = ACPI_PTR(mma9553_acpi_match),\n\t\t   .pm = pm_ptr(&mma9553_pm_ops),\n\t\t   },\n\t.probe = mma9553_probe,\n\t.remove = mma9553_remove,\n\t.id_table = mma9553_id,\n};\n\nmodule_i2c_driver(mma9553_driver);\n\nMODULE_AUTHOR(\"Irina Tirdea <irina.tirdea@intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MMA9553L pedometer platform driver\");\nMODULE_IMPORT_NS(IIO_MMA9551);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}