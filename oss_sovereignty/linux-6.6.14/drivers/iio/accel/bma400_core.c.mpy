{
  "module_name": "bma400_core.c",
  "hash_id": "2f0b6d8e135b8fc32bfdc425addfbb5143888bd9a87feb49847d3c3dfefefab4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/bma400_core.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#include <asm/unaligned.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/events.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#include \"bma400.h\"\n\n \nstatic int bma400_scales[8];\n\n \nstatic int bma400_sample_freqs[14];\n\nstatic const int bma400_osr_range[] = { 0, 1, 3 };\n\nstatic int tap_reset_timeout[BMA400_TAP_TIM_LIST_LEN] = {\n\t300000,\n\t400000,\n\t500000,\n\t600000\n};\n\nstatic int tap_max2min_time[BMA400_TAP_TIM_LIST_LEN] = {\n\t30000,\n\t45000,\n\t60000,\n\t90000\n};\n\nstatic int double_tap2_min_delay[BMA400_TAP_TIM_LIST_LEN] = {\n\t20000,\n\t40000,\n\t60000,\n\t80000\n};\n\n \nenum bma400_power_mode {\n\tPOWER_MODE_SLEEP   = 0x00,\n\tPOWER_MODE_LOW     = 0x01,\n\tPOWER_MODE_NORMAL  = 0x02,\n\tPOWER_MODE_INVALID = 0x03,\n};\n\nenum bma400_scan {\n\tBMA400_ACCL_X,\n\tBMA400_ACCL_Y,\n\tBMA400_ACCL_Z,\n\tBMA400_TEMP,\n};\n\nstruct bma400_sample_freq {\n\tint hz;\n\tint uhz;\n};\n\nenum bma400_activity {\n\tBMA400_STILL,\n\tBMA400_WALKING,\n\tBMA400_RUNNING,\n};\n\nstruct bma400_data {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct mutex mutex;  \n\tstruct iio_mount_matrix orientation;\n\tenum bma400_power_mode power_mode;\n\tstruct bma400_sample_freq sample_freq;\n\tint oversampling_ratio;\n\tint scale;\n\tstruct iio_trigger *trig;\n\tint steps_enabled;\n\tbool step_event_en;\n\tbool activity_event_en;\n\tunsigned int generic_event_en;\n\tunsigned int tap_event_en_bitmask;\n\t \n\tstruct {\n\t\t__le16 buff[3];\n\t\tu8 temperature;\n\t\ts64 ts __aligned(8);\n\t} buffer __aligned(IIO_DMA_MINALIGN);\n\t__le16 status;\n\t__be16 duration;\n};\n\nstatic bool bma400_is_writable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase BMA400_CHIP_ID_REG:\n\tcase BMA400_ERR_REG:\n\tcase BMA400_STATUS_REG:\n\tcase BMA400_X_AXIS_LSB_REG:\n\tcase BMA400_X_AXIS_MSB_REG:\n\tcase BMA400_Y_AXIS_LSB_REG:\n\tcase BMA400_Y_AXIS_MSB_REG:\n\tcase BMA400_Z_AXIS_LSB_REG:\n\tcase BMA400_Z_AXIS_MSB_REG:\n\tcase BMA400_SENSOR_TIME0:\n\tcase BMA400_SENSOR_TIME1:\n\tcase BMA400_SENSOR_TIME2:\n\tcase BMA400_EVENT_REG:\n\tcase BMA400_INT_STAT0_REG:\n\tcase BMA400_INT_STAT1_REG:\n\tcase BMA400_INT_STAT2_REG:\n\tcase BMA400_TEMP_DATA_REG:\n\tcase BMA400_FIFO_LENGTH0_REG:\n\tcase BMA400_FIFO_LENGTH1_REG:\n\tcase BMA400_FIFO_DATA_REG:\n\tcase BMA400_STEP_CNT0_REG:\n\tcase BMA400_STEP_CNT1_REG:\n\tcase BMA400_STEP_CNT3_REG:\n\tcase BMA400_STEP_STAT_REG:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool bma400_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase BMA400_ERR_REG:\n\tcase BMA400_STATUS_REG:\n\tcase BMA400_X_AXIS_LSB_REG:\n\tcase BMA400_X_AXIS_MSB_REG:\n\tcase BMA400_Y_AXIS_LSB_REG:\n\tcase BMA400_Y_AXIS_MSB_REG:\n\tcase BMA400_Z_AXIS_LSB_REG:\n\tcase BMA400_Z_AXIS_MSB_REG:\n\tcase BMA400_SENSOR_TIME0:\n\tcase BMA400_SENSOR_TIME1:\n\tcase BMA400_SENSOR_TIME2:\n\tcase BMA400_EVENT_REG:\n\tcase BMA400_INT_STAT0_REG:\n\tcase BMA400_INT_STAT1_REG:\n\tcase BMA400_INT_STAT2_REG:\n\tcase BMA400_TEMP_DATA_REG:\n\tcase BMA400_FIFO_LENGTH0_REG:\n\tcase BMA400_FIFO_LENGTH1_REG:\n\tcase BMA400_FIFO_DATA_REG:\n\tcase BMA400_STEP_CNT0_REG:\n\tcase BMA400_STEP_CNT1_REG:\n\tcase BMA400_STEP_CNT3_REG:\n\tcase BMA400_STEP_STAT_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nconst struct regmap_config bma400_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = BMA400_CMD_REG,\n\t.cache_type = REGCACHE_RBTREE,\n\t.writeable_reg = bma400_is_writable_reg,\n\t.volatile_reg = bma400_is_volatile_reg,\n};\nEXPORT_SYMBOL_NS(bma400_regmap_config, IIO_BMA400);\n\nstatic const struct iio_mount_matrix *\nbma400_accel_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\t      const struct iio_chan_spec *chan)\n{\n\tstruct bma400_data *data = iio_priv(indio_dev);\n\n\treturn &data->orientation;\n}\n\nstatic const struct iio_chan_spec_ext_info bma400_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_DIR, bma400_accel_get_mount_matrix),\n\t{ }\n};\n\nstatic const struct iio_event_spec bma400_step_detect_event = {\n\t.type = IIO_EV_TYPE_CHANGE,\n\t.dir = IIO_EV_DIR_NONE,\n\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n};\n\nstatic const struct iio_event_spec bma400_activity_event = {\n\t.type = IIO_EV_TYPE_CHANGE,\n\t.dir = IIO_EV_DIR_NONE,\n\t.mask_shared_by_type = BIT(IIO_EV_INFO_ENABLE),\n};\n\nstatic const struct iio_event_spec bma400_accel_event[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_MAG,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_shared_by_type = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t       BIT(IIO_EV_INFO_PERIOD) |\n\t\t\t\t       BIT(IIO_EV_INFO_HYSTERESIS) |\n\t\t\t\t       BIT(IIO_EV_INFO_ENABLE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_MAG,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_shared_by_type = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t       BIT(IIO_EV_INFO_PERIOD) |\n\t\t\t\t       BIT(IIO_EV_INFO_HYSTERESIS) |\n\t\t\t\t       BIT(IIO_EV_INFO_ENABLE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_GESTURE,\n\t\t.dir = IIO_EV_DIR_SINGLETAP,\n\t\t.mask_shared_by_type = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t       BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t\t       BIT(IIO_EV_INFO_RESET_TIMEOUT),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_GESTURE,\n\t\t.dir = IIO_EV_DIR_DOUBLETAP,\n\t\t.mask_shared_by_type = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t       BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t\t       BIT(IIO_EV_INFO_RESET_TIMEOUT) |\n\t\t\t\t       BIT(IIO_EV_INFO_TAP2_MIN_DELAY),\n\t},\n};\n\nstatic int usec_to_tapreg_raw(int usec, const int *time_list)\n{\n\tint index;\n\n\tfor (index = 0; index < BMA400_TAP_TIM_LIST_LEN; index++) {\n\t\tif (usec == time_list[index])\n\t\t\treturn index;\n\t}\n\treturn -EINVAL;\n}\n\nstatic ssize_t in_accel_gesture_tap_maxtomin_time_show(struct device *dev,\n\t\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t\t       char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct bma400_data *data = iio_priv(indio_dev);\n\tint ret, reg_val, raw, vals[2];\n\n\tret = regmap_read(data->regmap, BMA400_TAP_CONFIG1, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\traw = FIELD_GET(BMA400_TAP_TICSTH_MSK, reg_val);\n\tvals[0] = 0;\n\tvals[1] = tap_max2min_time[raw];\n\n\treturn iio_format_value(buf, IIO_VAL_INT_PLUS_MICRO, 2, vals);\n}\n\nstatic ssize_t in_accel_gesture_tap_maxtomin_time_store(struct device *dev,\n\t\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct bma400_data *data = iio_priv(indio_dev);\n\tint ret, val_int, val_fract, raw;\n\n\tret = iio_str_to_fixpoint(buf, 100000, &val_int, &val_fract);\n\tif (ret)\n\t\treturn ret;\n\n\traw = usec_to_tapreg_raw(val_fract, tap_max2min_time);\n\tif (raw < 0)\n\t\treturn -EINVAL;\n\n\tret = regmap_update_bits(data->regmap, BMA400_TAP_CONFIG1,\n\t\t\t\t BMA400_TAP_TICSTH_MSK,\n\t\t\t\t FIELD_PREP(BMA400_TAP_TICSTH_MSK, raw));\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR_RW(in_accel_gesture_tap_maxtomin_time, 0);\n\n \n\n \nstatic IIO_CONST_ATTR(in_accel_gesture_tap_reset_timeout_available,\n\t\t      \"0.3 0.4 0.5 0.6\");\n\n \nstatic IIO_CONST_ATTR(in_accel_gesture_tap_maxtomin_time_available,\n\t\t      \"0.03 0.045 0.06 0.09\");\n\n \nstatic IIO_CONST_ATTR(in_accel_gesture_doubletap_tap2_min_delay_available,\n\t\t      \"0.02 0.04 0.06 0.08\");\n\n \nstatic IIO_CONST_ATTR(in_accel_gesture_tap_value_available, \"0 1 2 3 4 5 6 7\");\n\nstatic struct attribute *bma400_event_attributes[] = {\n\t&iio_const_attr_in_accel_gesture_tap_value_available.dev_attr.attr,\n\t&iio_const_attr_in_accel_gesture_tap_reset_timeout_available.dev_attr.attr,\n\t&iio_const_attr_in_accel_gesture_tap_maxtomin_time_available.dev_attr.attr,\n\t&iio_const_attr_in_accel_gesture_doubletap_tap2_min_delay_available.dev_attr.attr,\n\t&iio_dev_attr_in_accel_gesture_tap_maxtomin_time.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group bma400_event_attribute_group = {\n\t.attrs = bma400_event_attributes,\n};\n\n#define BMA400_ACC_CHANNEL(_index, _axis) { \\\n\t.type = IIO_ACCEL, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_##_axis, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\tBIT(IIO_CHAN_INFO_SCALE) | \\\n\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \\\n\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\tBIT(IIO_CHAN_INFO_SCALE) | \\\n\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \\\n\t.ext_info = bma400_ext_info, \\\n\t.scan_index = _index,\t\\\n\t.scan_type = {\t\t\\\n\t\t.sign = 's',\t\\\n\t\t.realbits = 12,\t\t\\\n\t\t.storagebits = 16,\t\\\n\t\t.endianness = IIO_LE,\t\\\n\t},\t\t\t\t\\\n\t.event_spec = bma400_accel_event,\t\t\t\\\n\t.num_event_specs = ARRAY_SIZE(bma400_accel_event)\t\\\n}\n\n#define BMA400_ACTIVITY_CHANNEL(_chan2) {\t\\\n\t.type = IIO_ACTIVITY,\t\t\t\\\n\t.modified = 1,\t\t\t\t\\\n\t.channel2 = _chan2,\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\t\\\n\t.scan_index = -1,  \t\t\\\n\t.event_spec = &bma400_activity_event,\t\t\t\\\n\t.num_event_specs = 1,\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec bma400_channels[] = {\n\tBMA400_ACC_CHANNEL(0, X),\n\tBMA400_ACC_CHANNEL(1, Y),\n\tBMA400_ACC_CHANNEL(2, Z),\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.scan_index = 3,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 8,\n\t\t\t.storagebits = 8,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_STEPS,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_ENABLE),\n\t\t.scan_index = -1,  \n\t\t.event_spec = &bma400_step_detect_event,\n\t\t.num_event_specs = 1,\n\t},\n\tBMA400_ACTIVITY_CHANNEL(IIO_MOD_STILL),\n\tBMA400_ACTIVITY_CHANNEL(IIO_MOD_WALKING),\n\tBMA400_ACTIVITY_CHANNEL(IIO_MOD_RUNNING),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic int bma400_get_temp_reg(struct bma400_data *data, int *val, int *val2)\n{\n\tunsigned int raw_temp;\n\tint host_temp;\n\tint ret;\n\n\tif (data->power_mode == POWER_MODE_SLEEP)\n\t\treturn -EBUSY;\n\n\tret = regmap_read(data->regmap, BMA400_TEMP_DATA_REG, &raw_temp);\n\tif (ret)\n\t\treturn ret;\n\n\thost_temp = sign_extend32(raw_temp, 7);\n\t \n\t*val = (host_temp >> 1) + 23;\n\t*val2 = (host_temp & 0x1) * 500000;\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int bma400_get_accel_reg(struct bma400_data *data,\n\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\tint *val)\n{\n\t__le16 raw_accel;\n\tint lsb_reg;\n\tint ret;\n\n\tif (data->power_mode == POWER_MODE_SLEEP)\n\t\treturn -EBUSY;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\tlsb_reg = BMA400_X_AXIS_LSB_REG;\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\tlsb_reg = BMA400_Y_AXIS_LSB_REG;\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\tlsb_reg = BMA400_Z_AXIS_LSB_REG;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(data->dev, \"invalid axis channel modifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_bulk_read(data->regmap, lsb_reg, &raw_accel,\n\t\t\t       sizeof(raw_accel));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = sign_extend32(le16_to_cpu(raw_accel), 11);\n\treturn IIO_VAL_INT;\n}\n\nstatic void bma400_output_data_rate_from_raw(int raw, unsigned int *val,\n\t\t\t\t\t     unsigned int *val2)\n{\n\t*val = BMA400_ACC_ODR_MAX_HZ >> (BMA400_ACC_ODR_MAX_RAW - raw);\n\tif (raw > BMA400_ACC_ODR_MIN_RAW)\n\t\t*val2 = 0;\n\telse\n\t\t*val2 = 500000;\n}\n\nstatic int bma400_get_accel_output_data_rate(struct bma400_data *data)\n{\n\tunsigned int val;\n\tunsigned int odr;\n\tint ret;\n\n\tswitch (data->power_mode) {\n\tcase POWER_MODE_LOW:\n\t\t \n\t\tbma400_output_data_rate_from_raw(BMA400_ACC_ODR_LP_RAW,\n\t\t\t\t\t\t &data->sample_freq.hz,\n\t\t\t\t\t\t &data->sample_freq.uhz);\n\t\treturn 0;\n\tcase POWER_MODE_NORMAL:\n\t\t \n\t\tret = regmap_read(data->regmap, BMA400_ACC_CONFIG1_REG, &val);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\todr = val & BMA400_ACC_ODR_MASK;\n\t\tif (odr < BMA400_ACC_ODR_MIN_RAW ||\n\t\t    odr > BMA400_ACC_ODR_MAX_RAW) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbma400_output_data_rate_from_raw(odr, &data->sample_freq.hz,\n\t\t\t\t\t\t &data->sample_freq.uhz);\n\t\treturn 0;\n\tcase POWER_MODE_SLEEP:\n\t\tdata->sample_freq.hz = 0;\n\t\tdata->sample_freq.uhz = 0;\n\t\treturn 0;\n\tdefault:\n\t\tret = 0;\n\t\tgoto error;\n\t}\nerror:\n\tdata->sample_freq.hz = -1;\n\tdata->sample_freq.uhz = -1;\n\treturn ret;\n}\n\nstatic int bma400_set_accel_output_data_rate(struct bma400_data *data,\n\t\t\t\t\t     int hz, int uhz)\n{\n\tunsigned int idx;\n\tunsigned int odr;\n\tunsigned int val;\n\tint ret;\n\n\tif (hz >= BMA400_ACC_ODR_MIN_WHOLE_HZ) {\n\t\tif (uhz || hz > BMA400_ACC_ODR_MAX_HZ)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tidx = __ffs(hz);\n\n\t\tif (hz >> idx != BMA400_ACC_ODR_MIN_WHOLE_HZ)\n\t\t\treturn -EINVAL;\n\n\t\tidx += BMA400_ACC_ODR_MIN_RAW + 1;\n\t} else if (hz == BMA400_ACC_ODR_MIN_HZ && uhz == 500000) {\n\t\tidx = BMA400_ACC_ODR_MIN_RAW;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_read(data->regmap, BMA400_ACC_CONFIG1_REG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\todr = (~BMA400_ACC_ODR_MASK & val) | idx;\n\n\tret = regmap_write(data->regmap, BMA400_ACC_CONFIG1_REG, odr);\n\tif (ret)\n\t\treturn ret;\n\n\tbma400_output_data_rate_from_raw(idx, &data->sample_freq.hz,\n\t\t\t\t\t &data->sample_freq.uhz);\n\treturn 0;\n}\n\nstatic int bma400_get_accel_oversampling_ratio(struct bma400_data *data)\n{\n\tunsigned int val;\n\tunsigned int osr;\n\tint ret;\n\n\t \n\tswitch (data->power_mode) {\n\tcase POWER_MODE_LOW:\n\t\tret = regmap_read(data->regmap, BMA400_ACC_CONFIG0_REG, &val);\n\t\tif (ret) {\n\t\t\tdata->oversampling_ratio = -1;\n\t\t\treturn ret;\n\t\t}\n\n\t\tosr = (val & BMA400_LP_OSR_MASK) >> BMA400_LP_OSR_SHIFT;\n\n\t\tdata->oversampling_ratio = osr;\n\t\treturn 0;\n\tcase POWER_MODE_NORMAL:\n\t\tret = regmap_read(data->regmap, BMA400_ACC_CONFIG1_REG, &val);\n\t\tif (ret) {\n\t\t\tdata->oversampling_ratio = -1;\n\t\t\treturn ret;\n\t\t}\n\n\t\tosr = (val & BMA400_NP_OSR_MASK) >> BMA400_NP_OSR_SHIFT;\n\n\t\tdata->oversampling_ratio = osr;\n\t\treturn 0;\n\tcase POWER_MODE_SLEEP:\n\t\tdata->oversampling_ratio = 0;\n\t\treturn 0;\n\tdefault:\n\t\tdata->oversampling_ratio = -1;\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bma400_set_accel_oversampling_ratio(struct bma400_data *data,\n\t\t\t\t\t       int val)\n{\n\tunsigned int acc_config;\n\tint ret;\n\n\tif (val & ~BMA400_TWO_BITS_MASK)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (data->power_mode) {\n\tcase POWER_MODE_LOW:\n\t\tret = regmap_read(data->regmap, BMA400_ACC_CONFIG0_REG,\n\t\t\t\t  &acc_config);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(data->regmap, BMA400_ACC_CONFIG0_REG,\n\t\t\t\t   (acc_config & ~BMA400_LP_OSR_MASK) |\n\t\t\t\t   (val << BMA400_LP_OSR_SHIFT));\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"Failed to write out OSR\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->oversampling_ratio = val;\n\t\treturn 0;\n\tcase POWER_MODE_NORMAL:\n\t\tret = regmap_read(data->regmap, BMA400_ACC_CONFIG1_REG,\n\t\t\t\t  &acc_config);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(data->regmap, BMA400_ACC_CONFIG1_REG,\n\t\t\t\t   (acc_config & ~BMA400_NP_OSR_MASK) |\n\t\t\t\t   (val << BMA400_NP_OSR_SHIFT));\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"Failed to write out OSR\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->oversampling_ratio = val;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int bma400_accel_scale_to_raw(struct bma400_data *data,\n\t\t\t\t     unsigned int val)\n{\n\tint raw;\n\n\tif (val == 0)\n\t\treturn -EINVAL;\n\n\t \n\traw = __ffs(val);\n\n\tif (val >> raw != BMA400_SCALE_MIN)\n\t\treturn -EINVAL;\n\n\treturn raw;\n}\n\nstatic int bma400_get_accel_scale(struct bma400_data *data)\n{\n\tunsigned int raw_scale;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(data->regmap, BMA400_ACC_CONFIG1_REG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\traw_scale = (val & BMA400_ACC_SCALE_MASK) >> BMA400_SCALE_SHIFT;\n\tif (raw_scale > BMA400_TWO_BITS_MASK)\n\t\treturn -EINVAL;\n\n\tdata->scale = BMA400_SCALE_MIN << raw_scale;\n\n\treturn 0;\n}\n\nstatic int bma400_set_accel_scale(struct bma400_data *data, unsigned int val)\n{\n\tunsigned int acc_config;\n\tint raw;\n\tint ret;\n\n\tret = regmap_read(data->regmap, BMA400_ACC_CONFIG1_REG, &acc_config);\n\tif (ret)\n\t\treturn ret;\n\n\traw = bma400_accel_scale_to_raw(data, val);\n\tif (raw < 0)\n\t\treturn raw;\n\n\tret = regmap_write(data->regmap, BMA400_ACC_CONFIG1_REG,\n\t\t\t   (acc_config & ~BMA400_ACC_SCALE_MASK) |\n\t\t\t   (raw << BMA400_SCALE_SHIFT));\n\tif (ret)\n\t\treturn ret;\n\n\tdata->scale = val;\n\treturn 0;\n}\n\nstatic int bma400_get_power_mode(struct bma400_data *data)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(data->regmap, BMA400_STATUS_REG, &val);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to read status register\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->power_mode = (val >> 1) & BMA400_TWO_BITS_MASK;\n\treturn 0;\n}\n\nstatic int bma400_set_power_mode(struct bma400_data *data,\n\t\t\t\t enum bma400_power_mode mode)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(data->regmap, BMA400_ACC_CONFIG0_REG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data->power_mode == mode)\n\t\treturn 0;\n\n\tif (mode == POWER_MODE_INVALID)\n\t\treturn -EINVAL;\n\n\t \n\tret = regmap_write(data->regmap, BMA400_ACC_CONFIG0_REG,\n\t\t\t   mode | (val & ~BMA400_TWO_BITS_MASK));\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to write to power-mode\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->power_mode = mode;\n\n\t \n\tbma400_get_accel_output_data_rate(data);\n\tbma400_get_accel_oversampling_ratio(data);\n\treturn 0;\n}\n\nstatic int bma400_enable_steps(struct bma400_data *data, int val)\n{\n\tint ret;\n\n\tif (data->steps_enabled == val)\n\t\treturn 0;\n\n\tret = regmap_update_bits(data->regmap, BMA400_INT_CONFIG1_REG,\n\t\t\t\t BMA400_STEP_INT_MSK,\n\t\t\t\t FIELD_PREP(BMA400_STEP_INT_MSK, val ? 1 : 0));\n\tif (ret)\n\t\treturn ret;\n\tdata->steps_enabled = val;\n\treturn ret;\n}\n\nstatic int bma400_get_steps_reg(struct bma400_data *data, int *val)\n{\n\tu8 *steps_raw;\n\tint ret;\n\n\tsteps_raw = kmalloc(BMA400_STEP_RAW_LEN, GFP_KERNEL);\n\tif (!steps_raw)\n\t\treturn -ENOMEM;\n\n\tret = regmap_bulk_read(data->regmap, BMA400_STEP_CNT0_REG,\n\t\t\t       steps_raw, BMA400_STEP_RAW_LEN);\n\tif (ret) {\n\t\tkfree(steps_raw);\n\t\treturn ret;\n\t}\n\t*val = get_unaligned_le24(steps_raw);\n\tkfree(steps_raw);\n\treturn IIO_VAL_INT;\n}\n\nstatic void bma400_init_tables(void)\n{\n\tint raw;\n\tint i;\n\n\tfor (i = 0; i + 1 < ARRAY_SIZE(bma400_sample_freqs); i += 2) {\n\t\traw = (i / 2) + 5;\n\t\tbma400_output_data_rate_from_raw(raw, &bma400_sample_freqs[i],\n\t\t\t\t\t\t &bma400_sample_freqs[i + 1]);\n\t}\n\n\tfor (i = 0; i + 1 < ARRAY_SIZE(bma400_scales); i += 2) {\n\t\traw = i / 2;\n\t\tbma400_scales[i] = 0;\n\t\tbma400_scales[i + 1] = BMA400_SCALE_MIN << raw;\n\t}\n}\n\nstatic void bma400_power_disable(void *data_ptr)\n{\n\tstruct bma400_data *data = data_ptr;\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = bma400_set_power_mode(data, POWER_MODE_SLEEP);\n\tmutex_unlock(&data->mutex);\n\tif (ret)\n\t\tdev_warn(data->dev, \"Failed to put device into sleep mode (%pe)\\n\",\n\t\t\t ERR_PTR(ret));\n}\n\nstatic enum iio_modifier bma400_act_to_mod(enum bma400_activity activity)\n{\n\tswitch (activity) {\n\tcase BMA400_STILL:\n\t\treturn IIO_MOD_STILL;\n\tcase BMA400_WALKING:\n\t\treturn IIO_MOD_WALKING;\n\tcase BMA400_RUNNING:\n\t\treturn IIO_MOD_RUNNING;\n\tdefault:\n\t\treturn IIO_NO_MOD;\n\t}\n}\n\nstatic int bma400_init(struct bma400_data *data)\n{\n\tstatic const char * const regulator_names[] = { \"vdd\", \"vddio\" };\n\tunsigned int val;\n\tint ret;\n\n\tret = devm_regulator_bulk_get_enable(data->dev,\n\t\t\t\t\t     ARRAY_SIZE(regulator_names),\n\t\t\t\t\t     regulator_names);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret, \"Failed to get regulators\\n\");\n\n\t \n\tret = regmap_read(data->regmap, BMA400_CHIP_ID_REG, &val);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to read chip id register\\n\");\n\t\treturn ret;\n\t}\n\n\tif (val != BMA400_ID_REG_VAL) {\n\t\tdev_err(data->dev, \"Chip ID mismatch\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = bma400_get_power_mode(data);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to get the initial power-mode\\n\");\n\t\treturn ret;\n\t}\n\n\tif (data->power_mode != POWER_MODE_NORMAL) {\n\t\tret = bma400_set_power_mode(data, POWER_MODE_NORMAL);\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"Failed to wake up the device\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tusleep_range(1500, 2000);\n\t}\n\n\tret = devm_add_action_or_reset(data->dev, bma400_power_disable, data);\n\tif (ret)\n\t\treturn ret;\n\n\tbma400_init_tables();\n\n\tret = bma400_get_accel_output_data_rate(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bma400_get_accel_oversampling_ratio(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bma400_get_accel_scale(data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, BMA400_INT_IO_CTRL_REG, 0x06);\n\tif (ret)\n\t\treturn ret;\n\t \n\treturn regmap_write(data->regmap, BMA400_ACC_CONFIG2_REG, 0x00);\n}\n\nstatic int bma400_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan, int *val,\n\t\t\t   int *val2, long mask)\n{\n\tstruct bma400_data *data = iio_priv(indio_dev);\n\tunsigned int activity;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tret = bma400_get_temp_reg(data, val, val2);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\tcase IIO_STEPS:\n\t\t\treturn bma400_get_steps_reg(data, val);\n\t\tcase IIO_ACTIVITY:\n\t\t\tret = regmap_read(data->regmap, BMA400_STEP_STAT_REG,\n\t\t\t\t\t  &activity);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\t \n\t\t\tif (chan->channel2 == bma400_act_to_mod(activity))\n\t\t\t\t*val = 100;\n\t\t\telse\n\t\t\t\t*val = 0;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&data->mutex);\n\t\tret = bma400_get_accel_reg(data, chan, val);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ACCEL:\n\t\t\tif (data->sample_freq.hz < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t*val = data->sample_freq.hz;\n\t\t\t*val2 = data->sample_freq.uhz;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = 6;\n\t\t\t*val2 = 250000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = data->scale;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t \n\t\tif (data->oversampling_ratio < 0)\n\t\t\treturn -EINVAL;\n\n\t\t*val = data->oversampling_ratio;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\t*val = data->steps_enabled;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bma400_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type, int *length,\n\t\t\t     long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t*vals = bma400_scales;\n\t\t*length = ARRAY_SIZE(bma400_scales);\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t*type = IIO_VAL_INT;\n\t\t*vals = bma400_osr_range;\n\t\t*length = ARRAY_SIZE(bma400_osr_range);\n\t\treturn IIO_AVAIL_RANGE;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t*vals = bma400_sample_freqs;\n\t\t*length = ARRAY_SIZE(bma400_sample_freqs);\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bma400_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int val, int val2,\n\t\t\t    long mask)\n{\n\tstruct bma400_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t \n\t\tif (chan->type != IIO_ACCEL)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&data->mutex);\n\t\tret = bma400_set_accel_output_data_rate(data, val, val2);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (val != 0 ||\n\t\t    val2 < BMA400_SCALE_MIN || val2 > BMA400_SCALE_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&data->mutex);\n\t\tret = bma400_set_accel_scale(data, val2);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tmutex_lock(&data->mutex);\n\t\tret = bma400_set_accel_oversampling_ratio(data, val);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\tmutex_lock(&data->mutex);\n\t\tret = bma400_enable_steps(data, val);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bma400_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t\t    long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bma400_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir)\n{\n\tstruct bma400_data *data = iio_priv(indio_dev);\n\n\tswitch (chan->type) {\n\tcase IIO_ACCEL:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\treturn FIELD_GET(BMA400_INT_GEN1_MSK,\n\t\t\t\t\t data->generic_event_en);\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\treturn FIELD_GET(BMA400_INT_GEN2_MSK,\n\t\t\t\t\t data->generic_event_en);\n\t\tcase IIO_EV_DIR_SINGLETAP:\n\t\t\treturn FIELD_GET(BMA400_S_TAP_MSK,\n\t\t\t\t\t data->tap_event_en_bitmask);\n\t\tcase IIO_EV_DIR_DOUBLETAP:\n\t\t\treturn FIELD_GET(BMA400_D_TAP_MSK,\n\t\t\t\t\t data->tap_event_en_bitmask);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_STEPS:\n\t\treturn data->step_event_en;\n\tcase IIO_ACTIVITY:\n\t\treturn data->activity_event_en;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bma400_steps_event_enable(struct bma400_data *data, int state)\n{\n\tint ret;\n\n\tret = bma400_enable_steps(data, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(data->regmap, BMA400_INT12_MAP_REG,\n\t\t\t\t BMA400_STEP_INT_MSK,\n\t\t\t\t FIELD_PREP(BMA400_STEP_INT_MSK,\n\t\t\t\t\t    state));\n\tif (ret)\n\t\treturn ret;\n\tdata->step_event_en = state;\n\treturn 0;\n}\n\nstatic int bma400_activity_event_en(struct bma400_data *data,\n\t\t\t\t    enum iio_event_direction dir,\n\t\t\t\t    int state)\n{\n\tint ret, reg, msk, value;\n\tint field_value = 0;\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\treg = BMA400_GEN1INT_CONFIG0;\n\t\tmsk = BMA400_INT_GEN1_MSK;\n\t\tvalue = 2;\n\t\tset_mask_bits(&field_value, BMA400_INT_GEN1_MSK,\n\t\t\t      FIELD_PREP(BMA400_INT_GEN1_MSK, state));\n\t\tbreak;\n\tcase IIO_EV_DIR_FALLING:\n\t\treg = BMA400_GEN2INT_CONFIG0;\n\t\tmsk = BMA400_INT_GEN2_MSK;\n\t\tvalue = 0;\n\t\tset_mask_bits(&field_value, BMA400_INT_GEN2_MSK,\n\t\t\t      FIELD_PREP(BMA400_INT_GEN2_MSK, state));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_write(data->regmap, reg, 0xF8);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, reg + BMA400_GEN_CONFIG1_OFF, value);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, reg + BMA400_GEN_CONFIG2_OFF, 0x0A);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, reg + BMA400_GEN_CONFIG31_OFF, 0x0F);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(data->regmap, BMA400_INT1_MAP_REG, msk,\n\t\t\t\t field_value);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(data->regmap, BMA400_INT_CONFIG0_REG, msk,\n\t\t\t\t field_value);\n\tif (ret)\n\t\treturn ret;\n\n\tset_mask_bits(&data->generic_event_en, msk, field_value);\n\treturn 0;\n}\n\nstatic int bma400_tap_event_en(struct bma400_data *data,\n\t\t\t       enum iio_event_direction dir, int state)\n{\n\tunsigned int mask, field_value;\n\tint ret;\n\n\t \n\tif (data->power_mode != POWER_MODE_NORMAL)\n\t\treturn -EINVAL;\n\n\t \n\tif (data->sample_freq.hz != 200 && state) {\n\t\tdev_err(data->dev, \"Invalid data rate for tap interrupts.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(data->regmap, BMA400_INT12_MAP_REG,\n\t\t\t\t BMA400_S_TAP_MSK,\n\t\t\t\t FIELD_PREP(BMA400_S_TAP_MSK, state));\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_SINGLETAP:\n\t\tmask = BMA400_S_TAP_MSK;\n\t\tset_mask_bits(&field_value, BMA400_S_TAP_MSK,\n\t\t\t      FIELD_PREP(BMA400_S_TAP_MSK, state));\n\t\tbreak;\n\tcase IIO_EV_DIR_DOUBLETAP:\n\t\tmask = BMA400_D_TAP_MSK;\n\t\tset_mask_bits(&field_value, BMA400_D_TAP_MSK,\n\t\t\t      FIELD_PREP(BMA400_D_TAP_MSK, state));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(data->regmap, BMA400_INT_CONFIG1_REG, mask,\n\t\t\t\t field_value);\n\tif (ret)\n\t\treturn ret;\n\n\tset_mask_bits(&data->tap_event_en_bitmask, mask, field_value);\n\n\treturn 0;\n}\n\nstatic int bma400_disable_adv_interrupt(struct bma400_data *data)\n{\n\tint ret;\n\n\tret = regmap_write(data->regmap, BMA400_INT_CONFIG0_REG, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(data->regmap, BMA400_INT_CONFIG1_REG, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->tap_event_en_bitmask = 0;\n\tdata->generic_event_en = 0;\n\tdata->step_event_en = false;\n\tdata->activity_event_en = false;\n\n\treturn 0;\n}\n\nstatic int bma400_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir, int state)\n{\n\tstruct bma400_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (chan->type) {\n\tcase IIO_ACCEL:\n\t\tswitch (type) {\n\t\tcase IIO_EV_TYPE_MAG:\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tret = bma400_activity_event_en(data, dir, state);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\tcase IIO_EV_TYPE_GESTURE:\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tret = bma400_tap_event_en(data, dir, state);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_STEPS:\n\t\tmutex_lock(&data->mutex);\n\t\tret = bma400_steps_event_enable(data, state);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tcase IIO_ACTIVITY:\n\t\tmutex_lock(&data->mutex);\n\t\tif (!data->step_event_en) {\n\t\t\tret = bma400_steps_event_enable(data, true);\n\t\t\tif (ret) {\n\t\t\t\tmutex_unlock(&data->mutex);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tdata->activity_event_en = state;\n\t\tmutex_unlock(&data->mutex);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int get_gen_config_reg(enum iio_event_direction dir)\n{\n\tswitch (dir) {\n\tcase IIO_EV_DIR_FALLING:\n\t\treturn BMA400_GEN2INT_CONFIG0;\n\tcase IIO_EV_DIR_RISING:\n\t\treturn BMA400_GEN1INT_CONFIG0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bma400_read_event_value(struct iio_dev *indio_dev,\n\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t   enum iio_event_type type,\n\t\t\t\t   enum iio_event_direction dir,\n\t\t\t\t   enum iio_event_info info,\n\t\t\t\t   int *val, int *val2)\n{\n\tstruct bma400_data *data = iio_priv(indio_dev);\n\tint ret, reg, reg_val, raw;\n\n\tif (chan->type != IIO_ACCEL)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase IIO_EV_TYPE_MAG:\n\t\treg = get_gen_config_reg(dir);\n\t\tif (reg < 0)\n\t\t\treturn -EINVAL;\n\n\t\t*val2 = 0;\n\t\tswitch (info) {\n\t\tcase IIO_EV_INFO_VALUE:\n\t\t\tret = regmap_read(data->regmap,\n\t\t\t\t\t  reg + BMA400_GEN_CONFIG2_OFF,\n\t\t\t\t\t  val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_EV_INFO_PERIOD:\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tret = regmap_bulk_read(data->regmap,\n\t\t\t\t\t       reg + BMA400_GEN_CONFIG3_OFF,\n\t\t\t\t\t       &data->duration,\n\t\t\t\t\t       sizeof(data->duration));\n\t\t\tif (ret) {\n\t\t\t\tmutex_unlock(&data->mutex);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t*val = be16_to_cpu(data->duration);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_EV_INFO_HYSTERESIS:\n\t\t\tret = regmap_read(data->regmap, reg, val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\t*val = FIELD_GET(BMA400_GEN_HYST_MSK, *val);\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_EV_TYPE_GESTURE:\n\t\tswitch (info) {\n\t\tcase IIO_EV_INFO_VALUE:\n\t\t\tret = regmap_read(data->regmap, BMA400_TAP_CONFIG,\n\t\t\t\t\t  &reg_val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*val = FIELD_GET(BMA400_TAP_SEN_MSK, reg_val);\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_EV_INFO_RESET_TIMEOUT:\n\t\t\tret = regmap_read(data->regmap, BMA400_TAP_CONFIG1,\n\t\t\t\t\t  &reg_val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\traw = FIELD_GET(BMA400_TAP_QUIET_MSK, reg_val);\n\t\t\t*val = 0;\n\t\t\t*val2 = tap_reset_timeout[raw];\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_EV_INFO_TAP2_MIN_DELAY:\n\t\t\tret = regmap_read(data->regmap, BMA400_TAP_CONFIG1,\n\t\t\t\t\t  &reg_val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\traw = FIELD_GET(BMA400_TAP_QUIETDT_MSK, reg_val);\n\t\t\t*val = 0;\n\t\t\t*val2 = double_tap2_min_delay[raw];\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bma400_write_event_value(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir,\n\t\t\t\t    enum iio_event_info info,\n\t\t\t\t    int val, int val2)\n{\n\tstruct bma400_data *data = iio_priv(indio_dev);\n\tint reg, ret, raw;\n\n\tif (chan->type != IIO_ACCEL)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase IIO_EV_TYPE_MAG:\n\t\treg = get_gen_config_reg(dir);\n\t\tif (reg < 0)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info) {\n\t\tcase IIO_EV_INFO_VALUE:\n\t\t\tif (val < 1 || val > 255)\n\t\t\t\treturn -EINVAL;\n\n\t\t\treturn regmap_write(data->regmap,\n\t\t\t\t\t    reg + BMA400_GEN_CONFIG2_OFF,\n\t\t\t\t\t    val);\n\t\tcase IIO_EV_INFO_PERIOD:\n\t\t\tif (val < 1 || val > 65535)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tput_unaligned_be16(val, &data->duration);\n\t\t\tret = regmap_bulk_write(data->regmap,\n\t\t\t\t\t\treg + BMA400_GEN_CONFIG3_OFF,\n\t\t\t\t\t\t&data->duration,\n\t\t\t\t\t\tsizeof(data->duration));\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\tcase IIO_EV_INFO_HYSTERESIS:\n\t\t\tif (val < 0 || val > 3)\n\t\t\t\treturn -EINVAL;\n\n\t\t\treturn regmap_update_bits(data->regmap, reg,\n\t\t\t\t\t\t  BMA400_GEN_HYST_MSK,\n\t\t\t\t\t\t  FIELD_PREP(BMA400_GEN_HYST_MSK,\n\t\t\t\t\t\t\t     val));\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_EV_TYPE_GESTURE:\n\t\tswitch (info) {\n\t\tcase IIO_EV_INFO_VALUE:\n\t\t\tif (val < 0 || val > 7)\n\t\t\t\treturn -EINVAL;\n\n\t\t\treturn regmap_update_bits(data->regmap,\n\t\t\t\t\t\t  BMA400_TAP_CONFIG,\n\t\t\t\t\t\t  BMA400_TAP_SEN_MSK,\n\t\t\t\t\t\t  FIELD_PREP(BMA400_TAP_SEN_MSK,\n\t\t\t\t\t\t\t     val));\n\t\tcase IIO_EV_INFO_RESET_TIMEOUT:\n\t\t\traw = usec_to_tapreg_raw(val2, tap_reset_timeout);\n\t\t\tif (raw < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\treturn regmap_update_bits(data->regmap,\n\t\t\t\t\t\t  BMA400_TAP_CONFIG1,\n\t\t\t\t\t\t  BMA400_TAP_QUIET_MSK,\n\t\t\t\t\t\t  FIELD_PREP(BMA400_TAP_QUIET_MSK,\n\t\t\t\t\t\t\t     raw));\n\t\tcase IIO_EV_INFO_TAP2_MIN_DELAY:\n\t\t\traw = usec_to_tapreg_raw(val2, double_tap2_min_delay);\n\t\t\tif (raw < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\treturn regmap_update_bits(data->regmap,\n\t\t\t\t\t\t  BMA400_TAP_CONFIG1,\n\t\t\t\t\t\t  BMA400_TAP_QUIETDT_MSK,\n\t\t\t\t\t\t  FIELD_PREP(BMA400_TAP_QUIETDT_MSK,\n\t\t\t\t\t\t\t     raw));\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bma400_data_rdy_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t     bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct bma400_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap, BMA400_INT_CONFIG0_REG,\n\t\t\t\t BMA400_INT_DRDY_MSK,\n\t\t\t\t FIELD_PREP(BMA400_INT_DRDY_MSK, state));\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(data->regmap, BMA400_INT1_MAP_REG,\n\t\t\t\t  BMA400_INT_DRDY_MSK,\n\t\t\t\t  FIELD_PREP(BMA400_INT_DRDY_MSK, state));\n}\n\nstatic const unsigned long bma400_avail_scan_masks[] = {\n\tBIT(BMA400_ACCL_X) | BIT(BMA400_ACCL_Y) | BIT(BMA400_ACCL_Z),\n\tBIT(BMA400_ACCL_X) | BIT(BMA400_ACCL_Y) | BIT(BMA400_ACCL_Z)\n\t| BIT(BMA400_TEMP),\n\t0\n};\n\nstatic const struct iio_info bma400_info = {\n\t.read_raw          = bma400_read_raw,\n\t.read_avail        = bma400_read_avail,\n\t.write_raw         = bma400_write_raw,\n\t.write_raw_get_fmt = bma400_write_raw_get_fmt,\n\t.read_event_config = bma400_read_event_config,\n\t.write_event_config = bma400_write_event_config,\n\t.write_event_value = bma400_write_event_value,\n\t.read_event_value = bma400_read_event_value,\n\t.event_attrs = &bma400_event_attribute_group,\n};\n\nstatic const struct iio_trigger_ops bma400_trigger_ops = {\n\t.set_trigger_state = &bma400_data_rdy_trigger_set_state,\n\t.validate_device = &iio_trigger_validate_own_device,\n};\n\nstatic irqreturn_t bma400_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct bma400_data *data = iio_priv(indio_dev);\n\tint ret, temp;\n\n\t \n\tmutex_lock(&data->mutex);\n\n\t \n\tret = regmap_bulk_read(data->regmap, BMA400_X_AXIS_LSB_REG,\n\t\t\t       &data->buffer.buff, sizeof(data->buffer.buff));\n\tif (ret)\n\t\tgoto unlock_err;\n\n\tif (test_bit(BMA400_TEMP, indio_dev->active_scan_mask)) {\n\t\tret = regmap_read(data->regmap, BMA400_TEMP_DATA_REG, &temp);\n\t\tif (ret)\n\t\t\tgoto unlock_err;\n\n\t\tdata->buffer.temperature = temp;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->buffer,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\n\tmutex_unlock(&data->mutex);\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n\nunlock_err:\n\tmutex_unlock(&data->mutex);\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t bma400_interrupt(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct bma400_data *data = iio_priv(indio_dev);\n\ts64 timestamp = iio_get_time_ns(indio_dev);\n\tunsigned int act, ev_dir = IIO_EV_DIR_NONE;\n\tint ret;\n\n\t \n\tmutex_lock(&data->mutex);\n\tret = regmap_bulk_read(data->regmap, BMA400_INT_STAT0_REG,\n\t\t\t       &data->status,\n\t\t\t       sizeof(data->status));\n\t \n\tif (ret || !data->status)\n\t\tgoto unlock_err;\n\n\t \n\tif (FIELD_GET(BMA400_INT_ENG_OVRUN_MSK, le16_to_cpu(data->status))) {\n\t\tbma400_disable_adv_interrupt(data);\n\t\tdev_err(data->dev, \"Interrupt engine overrun\\n\");\n\t\tgoto unlock_err;\n\t}\n\n\tif (FIELD_GET(BMA400_INT_S_TAP_MSK, le16_to_cpu(data->status)))\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL, 0,\n\t\t\t\t\t\t  IIO_MOD_X_OR_Y_OR_Z,\n\t\t\t\t\t\t  IIO_EV_TYPE_GESTURE,\n\t\t\t\t\t\t  IIO_EV_DIR_SINGLETAP),\n\t\t\t       timestamp);\n\n\tif (FIELD_GET(BMA400_INT_D_TAP_MSK, le16_to_cpu(data->status)))\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL, 0,\n\t\t\t\t\t\t  IIO_MOD_X_OR_Y_OR_Z,\n\t\t\t\t\t\t  IIO_EV_TYPE_GESTURE,\n\t\t\t\t\t\t  IIO_EV_DIR_DOUBLETAP),\n\t\t\t       timestamp);\n\n\tif (FIELD_GET(BMA400_INT_GEN1_MSK, le16_to_cpu(data->status)))\n\t\tev_dir = IIO_EV_DIR_RISING;\n\n\tif (FIELD_GET(BMA400_INT_GEN2_MSK, le16_to_cpu(data->status)))\n\t\tev_dir = IIO_EV_DIR_FALLING;\n\n\tif (ev_dir != IIO_EV_DIR_NONE) {\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL, 0,\n\t\t\t\t\t\t  IIO_MOD_X_OR_Y_OR_Z,\n\t\t\t\t\t\t  IIO_EV_TYPE_MAG, ev_dir),\n\t\t\t       timestamp);\n\t}\n\n\tif (FIELD_GET(BMA400_STEP_STAT_MASK, le16_to_cpu(data->status))) {\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_STEPS, 0, IIO_NO_MOD,\n\t\t\t\t\t\t  IIO_EV_TYPE_CHANGE,\n\t\t\t\t\t\t  IIO_EV_DIR_NONE),\n\t\t\t       timestamp);\n\n\t\tif (data->activity_event_en) {\n\t\t\tret = regmap_read(data->regmap, BMA400_STEP_STAT_REG,\n\t\t\t\t\t  &act);\n\t\t\tif (ret)\n\t\t\t\tgoto unlock_err;\n\n\t\t\tiio_push_event(indio_dev,\n\t\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACTIVITY, 0,\n\t\t\t\t\t\t\t  bma400_act_to_mod(act),\n\t\t\t\t\t\t\t  IIO_EV_TYPE_CHANGE,\n\t\t\t\t\t\t\t  IIO_EV_DIR_NONE),\n\t\t\t\t       timestamp);\n\t\t}\n\t}\n\n\tif (FIELD_GET(BMA400_INT_DRDY_MSK, le16_to_cpu(data->status))) {\n\t\tmutex_unlock(&data->mutex);\n\t\tiio_trigger_poll_nested(data->trig);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tmutex_unlock(&data->mutex);\n\treturn IRQ_HANDLED;\n\nunlock_err:\n\tmutex_unlock(&data->mutex);\n\treturn IRQ_NONE;\n}\n\nint bma400_probe(struct device *dev, struct regmap *regmap, int irq,\n\t\t const char *name)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct bma400_data *data;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->regmap = regmap;\n\tdata->dev = dev;\n\n\tret = bma400_init(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iio_read_mount_matrix(dev, &data->orientation);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&data->mutex);\n\tindio_dev->name = name;\n\tindio_dev->info = &bma400_info;\n\tindio_dev->channels = bma400_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(bma400_channels);\n\tindio_dev->available_scan_masks = bma400_avail_scan_masks;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tif (irq > 0) {\n\t\tdata->trig = devm_iio_trigger_alloc(dev, \"%s-dev%d\",\n\t\t\t\t\t\t    indio_dev->name,\n\t\t\t\t\t\t    iio_device_id(indio_dev));\n\t\tif (!data->trig)\n\t\t\treturn -ENOMEM;\n\n\t\tdata->trig->ops = &bma400_trigger_ops;\n\t\tiio_trigger_set_drvdata(data->trig, indio_dev);\n\n\t\tret = devm_iio_trigger_register(data->dev, data->trig);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(data->dev, ret,\n\t\t\t\t\t     \"iio trigger register fail\\n\");\n\n\t\tindio_dev->trig = iio_trigger_get(data->trig);\n\t\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t\t\t&bma400_interrupt,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t\tindio_dev->name, indio_dev);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(data->dev, ret,\n\t\t\t\t\t     \"request irq %d failed\\n\", irq);\n\t}\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,\n\t\t\t\t\t      &bma400_trigger_handler, NULL);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret,\n\t\t\t\t     \"iio triggered buffer setup failed\\n\");\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS(bma400_probe, IIO_BMA400);\n\nMODULE_AUTHOR(\"Dan Robertson <dan@dlrobertson.com>\");\nMODULE_AUTHOR(\"Jagath Jog J <jagathjog1996@gmail.com>\");\nMODULE_DESCRIPTION(\"Bosch BMA400 triaxial acceleration sensor core\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}