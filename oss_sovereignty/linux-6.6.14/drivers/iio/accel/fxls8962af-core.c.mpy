{
  "module_name": "fxls8962af-core.c",
  "hash_id": "4c30ec5ac882bccc811bf7dae0192b88c4689b2e5432879a83008807704d6025",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/fxls8962af-core.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regmap.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/kfifo_buf.h>\n#include <linux/iio/sysfs.h>\n\n#include \"fxls8962af.h\"\n\n#define FXLS8962AF_INT_STATUS\t\t\t0x00\n#define FXLS8962AF_INT_STATUS_SRC_BOOT\t\tBIT(0)\n#define FXLS8962AF_INT_STATUS_SRC_SDCD_OT\tBIT(4)\n#define FXLS8962AF_INT_STATUS_SRC_BUF\t\tBIT(5)\n#define FXLS8962AF_INT_STATUS_SRC_DRDY\t\tBIT(7)\n#define FXLS8962AF_TEMP_OUT\t\t\t0x01\n#define FXLS8962AF_VECM_LSB\t\t\t0x02\n#define FXLS8962AF_OUT_X_LSB\t\t\t0x04\n#define FXLS8962AF_OUT_Y_LSB\t\t\t0x06\n#define FXLS8962AF_OUT_Z_LSB\t\t\t0x08\n#define FXLS8962AF_BUF_STATUS\t\t\t0x0b\n#define FXLS8962AF_BUF_STATUS_BUF_CNT\t\tGENMASK(5, 0)\n#define FXLS8962AF_BUF_STATUS_BUF_OVF\t\tBIT(6)\n#define FXLS8962AF_BUF_STATUS_BUF_WMRK\t\tBIT(7)\n#define FXLS8962AF_BUF_X_LSB\t\t\t0x0c\n#define FXLS8962AF_BUF_Y_LSB\t\t\t0x0e\n#define FXLS8962AF_BUF_Z_LSB\t\t\t0x10\n\n#define FXLS8962AF_PROD_REV\t\t\t0x12\n#define FXLS8962AF_WHO_AM_I\t\t\t0x13\n\n#define FXLS8962AF_SYS_MODE\t\t\t0x14\n#define FXLS8962AF_SENS_CONFIG1\t\t\t0x15\n#define FXLS8962AF_SENS_CONFIG1_ACTIVE\t\tBIT(0)\n#define FXLS8962AF_SENS_CONFIG1_RST\t\tBIT(7)\n#define FXLS8962AF_SC1_FSR_MASK\t\t\tGENMASK(2, 1)\n#define FXLS8962AF_SC1_FSR_PREP(x)\t\tFIELD_PREP(FXLS8962AF_SC1_FSR_MASK, (x))\n#define FXLS8962AF_SC1_FSR_GET(x)\t\tFIELD_GET(FXLS8962AF_SC1_FSR_MASK, (x))\n\n#define FXLS8962AF_SENS_CONFIG2\t\t\t0x16\n#define FXLS8962AF_SENS_CONFIG3\t\t\t0x17\n#define FXLS8962AF_SC3_WAKE_ODR_MASK\t\tGENMASK(7, 4)\n#define FXLS8962AF_SC3_WAKE_ODR_PREP(x)\t\tFIELD_PREP(FXLS8962AF_SC3_WAKE_ODR_MASK, (x))\n#define FXLS8962AF_SC3_WAKE_ODR_GET(x)\t\tFIELD_GET(FXLS8962AF_SC3_WAKE_ODR_MASK, (x))\n#define FXLS8962AF_SENS_CONFIG4\t\t\t0x18\n#define FXLS8962AF_SC4_INT_PP_OD_MASK\t\tBIT(1)\n#define FXLS8962AF_SC4_INT_PP_OD_PREP(x)\tFIELD_PREP(FXLS8962AF_SC4_INT_PP_OD_MASK, (x))\n#define FXLS8962AF_SC4_INT_POL_MASK\t\tBIT(0)\n#define FXLS8962AF_SC4_INT_POL_PREP(x)\t\tFIELD_PREP(FXLS8962AF_SC4_INT_POL_MASK, (x))\n#define FXLS8962AF_SENS_CONFIG5\t\t\t0x19\n\n#define FXLS8962AF_WAKE_IDLE_LSB\t\t0x1b\n#define FXLS8962AF_SLEEP_IDLE_LSB\t\t0x1c\n#define FXLS8962AF_ASLP_COUNT_LSB\t\t0x1e\n\n#define FXLS8962AF_INT_EN\t\t\t0x20\n#define FXLS8962AF_INT_EN_SDCD_OT_EN\t\tBIT(5)\n#define FXLS8962AF_INT_EN_BUF_EN\t\tBIT(6)\n#define FXLS8962AF_INT_PIN_SEL\t\t\t0x21\n#define FXLS8962AF_INT_PIN_SEL_MASK\t\tGENMASK(7, 0)\n#define FXLS8962AF_INT_PIN_SEL_INT1\t\t0x00\n#define FXLS8962AF_INT_PIN_SEL_INT2\t\tGENMASK(7, 0)\n\n#define FXLS8962AF_OFF_X\t\t\t0x22\n#define FXLS8962AF_OFF_Y\t\t\t0x23\n#define FXLS8962AF_OFF_Z\t\t\t0x24\n\n#define FXLS8962AF_BUF_CONFIG1\t\t\t0x26\n#define FXLS8962AF_BC1_BUF_MODE_MASK\t\tGENMASK(6, 5)\n#define FXLS8962AF_BC1_BUF_MODE_PREP(x)\t\tFIELD_PREP(FXLS8962AF_BC1_BUF_MODE_MASK, (x))\n#define FXLS8962AF_BUF_CONFIG2\t\t\t0x27\n#define FXLS8962AF_BUF_CONFIG2_BUF_WMRK\t\tGENMASK(5, 0)\n\n#define FXLS8962AF_ORIENT_STATUS\t\t0x28\n#define FXLS8962AF_ORIENT_CONFIG\t\t0x29\n#define FXLS8962AF_ORIENT_DBCOUNT\t\t0x2a\n#define FXLS8962AF_ORIENT_BF_ZCOMP\t\t0x2b\n#define FXLS8962AF_ORIENT_THS_REG\t\t0x2c\n\n#define FXLS8962AF_SDCD_INT_SRC1\t\t0x2d\n#define FXLS8962AF_SDCD_INT_SRC1_X_OT\t\tBIT(5)\n#define FXLS8962AF_SDCD_INT_SRC1_X_POL\t\tBIT(4)\n#define FXLS8962AF_SDCD_INT_SRC1_Y_OT\t\tBIT(3)\n#define FXLS8962AF_SDCD_INT_SRC1_Y_POL\t\tBIT(2)\n#define FXLS8962AF_SDCD_INT_SRC1_Z_OT\t\tBIT(1)\n#define FXLS8962AF_SDCD_INT_SRC1_Z_POL\t\tBIT(0)\n#define FXLS8962AF_SDCD_INT_SRC2\t\t0x2e\n#define FXLS8962AF_SDCD_CONFIG1\t\t\t0x2f\n#define FXLS8962AF_SDCD_CONFIG1_Z_OT_EN\t\tBIT(3)\n#define FXLS8962AF_SDCD_CONFIG1_Y_OT_EN\t\tBIT(4)\n#define FXLS8962AF_SDCD_CONFIG1_X_OT_EN\t\tBIT(5)\n#define FXLS8962AF_SDCD_CONFIG1_OT_ELE\t\tBIT(7)\n#define FXLS8962AF_SDCD_CONFIG2\t\t\t0x30\n#define FXLS8962AF_SDCD_CONFIG2_SDCD_EN\t\tBIT(7)\n#define FXLS8962AF_SC2_REF_UPDM_AC\t\tGENMASK(6, 5)\n#define FXLS8962AF_SDCD_OT_DBCNT\t\t0x31\n#define FXLS8962AF_SDCD_WT_DBCNT\t\t0x32\n#define FXLS8962AF_SDCD_LTHS_LSB\t\t0x33\n#define FXLS8962AF_SDCD_UTHS_LSB\t\t0x35\n\n#define FXLS8962AF_SELF_TEST_CONFIG1\t\t0x37\n#define FXLS8962AF_SELF_TEST_CONFIG2\t\t0x38\n\n#define FXLS8962AF_MAX_REG\t\t\t0x38\n\n#define FXLS8962AF_DEVICE_ID\t\t\t0x62\n#define FXLS8964AF_DEVICE_ID\t\t\t0x84\n\n \n#define FXLS8962AF_TEMP_CENTER_VAL\t\t25\n\n#define FXLS8962AF_AUTO_SUSPEND_DELAY_MS\t2000\n\n#define FXLS8962AF_FIFO_LENGTH\t\t\t32\n#define FXLS8962AF_SCALE_TABLE_LEN\t\t4\n#define FXLS8962AF_SAMP_FREQ_TABLE_LEN\t\t13\n\nstatic const int fxls8962af_scale_table[FXLS8962AF_SCALE_TABLE_LEN][2] = {\n\t{0, IIO_G_TO_M_S_2(980000)},\n\t{0, IIO_G_TO_M_S_2(1950000)},\n\t{0, IIO_G_TO_M_S_2(3910000)},\n\t{0, IIO_G_TO_M_S_2(7810000)},\n};\n\nstatic const int fxls8962af_samp_freq_table[FXLS8962AF_SAMP_FREQ_TABLE_LEN][2] = {\n\t{3200, 0}, {1600, 0}, {800, 0}, {400, 0}, {200, 0}, {100, 0},\n\t{50, 0}, {25, 0}, {12, 500000}, {6, 250000}, {3, 125000},\n\t{1, 563000}, {0, 781000},\n};\n\nstruct fxls8962af_chip_info {\n\tconst char *name;\n\tconst struct iio_chan_spec *channels;\n\tint num_channels;\n\tu8 chip_id;\n};\n\nstruct fxls8962af_data {\n\tstruct regmap *regmap;\n\tconst struct fxls8962af_chip_info *chip_info;\n\tstruct {\n\t\t__le16 channels[3];\n\t\ts64 ts __aligned(8);\n\t} scan;\n\tint64_t timestamp, old_timestamp;\t \n\tstruct iio_mount_matrix orientation;\n\tint irq;\n\tu8 watermark;\n\tu8 enable_event;\n\tu16 lower_thres;\n\tu16 upper_thres;\n};\n\nconst struct regmap_config fxls8962af_i2c_regmap_conf = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = FXLS8962AF_MAX_REG,\n};\nEXPORT_SYMBOL_NS_GPL(fxls8962af_i2c_regmap_conf, IIO_FXLS8962AF);\n\nconst struct regmap_config fxls8962af_spi_regmap_conf = {\n\t.reg_bits = 8,\n\t.pad_bits = 8,\n\t.val_bits = 8,\n\t.max_register = FXLS8962AF_MAX_REG,\n};\nEXPORT_SYMBOL_NS_GPL(fxls8962af_spi_regmap_conf, IIO_FXLS8962AF);\n\nenum {\n\tfxls8962af_idx_x,\n\tfxls8962af_idx_y,\n\tfxls8962af_idx_z,\n\tfxls8962af_idx_ts,\n};\n\nenum fxls8962af_int_pin {\n\tFXLS8962AF_PIN_INT1,\n\tFXLS8962AF_PIN_INT2,\n};\n\nstatic int fxls8962af_power_on(struct fxls8962af_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret)\n\t\tdev_err(dev, \"failed to power on\\n\");\n\n\treturn ret;\n}\n\nstatic int fxls8962af_power_off(struct fxls8962af_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\n\tpm_runtime_mark_last_busy(dev);\n\tret = pm_runtime_put_autosuspend(dev);\n\tif (ret)\n\t\tdev_err(dev, \"failed to power off\\n\");\n\n\treturn ret;\n}\n\nstatic int fxls8962af_standby(struct fxls8962af_data *data)\n{\n\treturn regmap_update_bits(data->regmap, FXLS8962AF_SENS_CONFIG1,\n\t\t\t\t  FXLS8962AF_SENS_CONFIG1_ACTIVE, 0);\n}\n\nstatic int fxls8962af_active(struct fxls8962af_data *data)\n{\n\treturn regmap_update_bits(data->regmap, FXLS8962AF_SENS_CONFIG1,\n\t\t\t\t  FXLS8962AF_SENS_CONFIG1_ACTIVE, 1);\n}\n\nstatic int fxls8962af_is_active(struct fxls8962af_data *data)\n{\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(data->regmap, FXLS8962AF_SENS_CONFIG1, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn reg & FXLS8962AF_SENS_CONFIG1_ACTIVE;\n}\n\nstatic int fxls8962af_get_out(struct fxls8962af_data *data,\n\t\t\t      struct iio_chan_spec const *chan, int *val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\t__le16 raw_val;\n\tint is_active;\n\tint ret;\n\n\tis_active = fxls8962af_is_active(data);\n\tif (!is_active) {\n\t\tret = fxls8962af_power_on(data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = regmap_bulk_read(data->regmap, chan->address,\n\t\t\t       &raw_val, sizeof(data->lower_thres));\n\n\tif (!is_active)\n\t\tfxls8962af_power_off(data);\n\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get out reg 0x%lx\\n\", chan->address);\n\t\treturn ret;\n\t}\n\n\t*val = sign_extend32(le16_to_cpu(raw_val),\n\t\t\t     chan->scan_type.realbits - 1);\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int fxls8962af_read_avail(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t const int **vals, int *type, int *length,\n\t\t\t\t long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*type = IIO_VAL_INT_PLUS_NANO;\n\t\t*vals = (int *)fxls8962af_scale_table;\n\t\t*length = ARRAY_SIZE(fxls8962af_scale_table) * 2;\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t*vals = (int *)fxls8962af_samp_freq_table;\n\t\t*length = ARRAY_SIZE(fxls8962af_samp_freq_table) * 2;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int fxls8962af_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\t\tlong mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t}\n}\n\nstatic int fxls8962af_update_config(struct fxls8962af_data *data, u8 reg,\n\t\t\t\t    u8 mask, u8 val)\n{\n\tint ret;\n\tint is_active;\n\n\tis_active = fxls8962af_is_active(data);\n\tif (is_active) {\n\t\tret = fxls8962af_standby(data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(data->regmap, reg, mask, val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (is_active) {\n\t\tret = fxls8962af_active(data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fxls8962af_set_full_scale(struct fxls8962af_data *data, u32 scale)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fxls8962af_scale_table); i++)\n\t\tif (scale == fxls8962af_scale_table[i][1])\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(fxls8962af_scale_table))\n\t\treturn -EINVAL;\n\n\treturn fxls8962af_update_config(data, FXLS8962AF_SENS_CONFIG1,\n\t\t\t\t\tFXLS8962AF_SC1_FSR_MASK,\n\t\t\t\t\tFXLS8962AF_SC1_FSR_PREP(i));\n}\n\nstatic unsigned int fxls8962af_read_full_scale(struct fxls8962af_data *data,\n\t\t\t\t\t       int *val)\n{\n\tint ret;\n\tunsigned int reg;\n\tu8 range_idx;\n\n\tret = regmap_read(data->regmap, FXLS8962AF_SENS_CONFIG1, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\trange_idx = FXLS8962AF_SC1_FSR_GET(reg);\n\n\t*val = fxls8962af_scale_table[range_idx][1];\n\n\treturn IIO_VAL_INT_PLUS_NANO;\n}\n\nstatic int fxls8962af_set_samp_freq(struct fxls8962af_data *data, u32 val,\n\t\t\t\t    u32 val2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fxls8962af_samp_freq_table); i++)\n\t\tif (val == fxls8962af_samp_freq_table[i][0] &&\n\t\t    val2 == fxls8962af_samp_freq_table[i][1])\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(fxls8962af_samp_freq_table))\n\t\treturn -EINVAL;\n\n\treturn fxls8962af_update_config(data, FXLS8962AF_SENS_CONFIG3,\n\t\t\t\t\tFXLS8962AF_SC3_WAKE_ODR_MASK,\n\t\t\t\t\tFXLS8962AF_SC3_WAKE_ODR_PREP(i));\n}\n\nstatic unsigned int fxls8962af_read_samp_freq(struct fxls8962af_data *data,\n\t\t\t\t\t      int *val, int *val2)\n{\n\tint ret;\n\tunsigned int reg;\n\tu8 range_idx;\n\n\tret = regmap_read(data->regmap, FXLS8962AF_SENS_CONFIG3, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\trange_idx = FXLS8962AF_SC3_WAKE_ODR_GET(reg);\n\n\t*val = fxls8962af_samp_freq_table[range_idx][0];\n\t*val2 = fxls8962af_samp_freq_table[range_idx][1];\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int fxls8962af_read_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int *val, int *val2, long mask)\n{\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\tcase IIO_ACCEL:\n\t\t\treturn fxls8962af_get_out(data, chan, val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (chan->type != IIO_TEMP)\n\t\t\treturn -EINVAL;\n\n\t\t*val = FXLS8962AF_TEMP_CENTER_VAL;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\treturn fxls8962af_read_full_scale(data, val2);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn fxls8962af_read_samp_freq(data, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int fxls8962af_write_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint val, int val2, long mask)\n{\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (val != 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = fxls8962af_set_full_scale(data, val2);\n\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = fxls8962af_set_samp_freq(data, val, val2);\n\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int fxls8962af_event_setup(struct fxls8962af_data *data, int state)\n{\n\t \n\tint mask = FXLS8962AF_INT_EN_SDCD_OT_EN;\n\tint value = state ? mask : 0;\n\n\treturn regmap_update_bits(data->regmap, FXLS8962AF_INT_EN, mask, value);\n}\n\nstatic int fxls8962af_set_watermark(struct iio_dev *indio_dev, unsigned val)\n{\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\n\tif (val > FXLS8962AF_FIFO_LENGTH)\n\t\tval = FXLS8962AF_FIFO_LENGTH;\n\n\tdata->watermark = val;\n\n\treturn 0;\n}\n\nstatic int __fxls8962af_set_thresholds(struct fxls8962af_data *data,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       enum iio_event_direction dir,\n\t\t\t\t       int val)\n{\n\tswitch (dir) {\n\tcase IIO_EV_DIR_FALLING:\n\t\tdata->lower_thres = val;\n\t\treturn regmap_bulk_write(data->regmap, FXLS8962AF_SDCD_LTHS_LSB,\n\t\t\t\t&data->lower_thres, sizeof(data->lower_thres));\n\tcase IIO_EV_DIR_RISING:\n\t\tdata->upper_thres = val;\n\t\treturn regmap_bulk_write(data->regmap, FXLS8962AF_SDCD_UTHS_LSB,\n\t\t\t\t&data->upper_thres, sizeof(data->upper_thres));\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int fxls8962af_read_event(struct iio_dev *indio_dev,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t enum iio_event_type type,\n\t\t\t\t enum iio_event_direction dir,\n\t\t\t\t enum iio_event_info info,\n\t\t\t\t int *val, int *val2)\n{\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_FALLING:\n\t\tret = regmap_bulk_read(data->regmap, FXLS8962AF_SDCD_LTHS_LSB,\n\t\t\t\t       &data->lower_thres, sizeof(data->lower_thres));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = sign_extend32(data->lower_thres, chan->scan_type.realbits - 1);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_EV_DIR_RISING:\n\t\tret = regmap_bulk_read(data->regmap, FXLS8962AF_SDCD_UTHS_LSB,\n\t\t\t\t       &data->upper_thres, sizeof(data->upper_thres));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = sign_extend32(data->upper_thres, chan->scan_type.realbits - 1);\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int fxls8962af_write_event(struct iio_dev *indio_dev,\n\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t  enum iio_event_type type,\n\t\t\t\t  enum iio_event_direction dir,\n\t\t\t\t  enum iio_event_info info,\n\t\t\t\t  int val, int val2)\n{\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\tint ret, val_masked;\n\n\tif (type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\tif (val < -2048 || val > 2047)\n\t\treturn -EINVAL;\n\n\tif (data->enable_event)\n\t\treturn -EBUSY;\n\n\tval_masked = val & GENMASK(11, 0);\n\tif (fxls8962af_is_active(data)) {\n\t\tret = fxls8962af_standby(data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = __fxls8962af_set_thresholds(data, chan, dir, val_masked);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn fxls8962af_active(data);\n\t} else {\n\t\treturn __fxls8962af_set_thresholds(data, chan, dir, val_masked);\n\t}\n}\n\nstatic int\nfxls8962af_read_event_config(struct iio_dev *indio_dev,\n\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t     enum iio_event_type type,\n\t\t\t     enum iio_event_direction dir)\n{\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\n\tif (type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\treturn !!(FXLS8962AF_SDCD_CONFIG1_X_OT_EN & data->enable_event);\n\tcase IIO_MOD_Y:\n\t\treturn !!(FXLS8962AF_SDCD_CONFIG1_Y_OT_EN & data->enable_event);\n\tcase IIO_MOD_Z:\n\t\treturn !!(FXLS8962AF_SDCD_CONFIG1_Z_OT_EN & data->enable_event);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int\nfxls8962af_write_event_config(struct iio_dev *indio_dev,\n\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t      enum iio_event_type type,\n\t\t\t      enum iio_event_direction dir, int state)\n{\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\tu8 enable_event, enable_bits;\n\tint ret, value;\n\n\tif (type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\tenable_bits = FXLS8962AF_SDCD_CONFIG1_X_OT_EN;\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\tenable_bits = FXLS8962AF_SDCD_CONFIG1_Y_OT_EN;\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\tenable_bits = FXLS8962AF_SDCD_CONFIG1_Z_OT_EN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (state)\n\t\tenable_event = data->enable_event | enable_bits;\n\telse\n\t\tenable_event = data->enable_event & ~enable_bits;\n\n\tif (data->enable_event == enable_event)\n\t\treturn 0;\n\n\tret = fxls8962af_standby(data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tvalue = enable_event | FXLS8962AF_SDCD_CONFIG1_OT_ELE;\n\tret = regmap_write(data->regmap, FXLS8962AF_SDCD_CONFIG1, value);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tvalue = enable_event ?\n\t\tFXLS8962AF_SDCD_CONFIG2_SDCD_EN | FXLS8962AF_SC2_REF_UPDM_AC :\n\t\t0x00;\n\tret = regmap_write(data->regmap, FXLS8962AF_SDCD_CONFIG2, value);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fxls8962af_event_setup(data, state);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->enable_event = enable_event;\n\n\tif (data->enable_event) {\n\t\tfxls8962af_active(data);\n\t\tret = fxls8962af_power_on(data);\n\t} else {\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = fxls8962af_power_off(data);\n\n\t\tiio_device_release_direct_mode(indio_dev);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct iio_event_spec fxls8962af_event[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t},\n};\n\n#define FXLS8962AF_CHANNEL(axis, reg, idx) { \\\n\t.type = IIO_ACCEL, \\\n\t.address = reg, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_##axis, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\t\t\t    BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SCALE) | \\\n\t\t\t\t\t      BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.scan_index = idx, \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = 12, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_LE, \\\n\t}, \\\n\t.event_spec = fxls8962af_event, \\\n\t.num_event_specs = ARRAY_SIZE(fxls8962af_event), \\\n}\n\n#define FXLS8962AF_TEMP_CHANNEL { \\\n\t.type = IIO_TEMP, \\\n\t.address = FXLS8962AF_TEMP_OUT, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\\\n\t.scan_index = -1, \\\n\t.scan_type = { \\\n\t\t.realbits = 8, \\\n\t\t.storagebits = 8, \\\n\t}, \\\n}\n\nstatic const struct iio_chan_spec fxls8962af_channels[] = {\n\tFXLS8962AF_CHANNEL(X, FXLS8962AF_OUT_X_LSB, fxls8962af_idx_x),\n\tFXLS8962AF_CHANNEL(Y, FXLS8962AF_OUT_Y_LSB, fxls8962af_idx_y),\n\tFXLS8962AF_CHANNEL(Z, FXLS8962AF_OUT_Z_LSB, fxls8962af_idx_z),\n\tIIO_CHAN_SOFT_TIMESTAMP(fxls8962af_idx_ts),\n\tFXLS8962AF_TEMP_CHANNEL,\n};\n\nstatic const struct fxls8962af_chip_info fxls_chip_info_table[] = {\n\t[fxls8962af] = {\n\t\t.chip_id = FXLS8962AF_DEVICE_ID,\n\t\t.name = \"fxls8962af\",\n\t\t.channels = fxls8962af_channels,\n\t\t.num_channels = ARRAY_SIZE(fxls8962af_channels),\n\t},\n\t[fxls8964af] = {\n\t\t.chip_id = FXLS8964AF_DEVICE_ID,\n\t\t.name = \"fxls8964af\",\n\t\t.channels = fxls8962af_channels,\n\t\t.num_channels = ARRAY_SIZE(fxls8962af_channels),\n\t},\n};\n\nstatic const struct iio_info fxls8962af_info = {\n\t.read_raw = &fxls8962af_read_raw,\n\t.write_raw = &fxls8962af_write_raw,\n\t.write_raw_get_fmt = fxls8962af_write_raw_get_fmt,\n\t.read_event_value = fxls8962af_read_event,\n\t.write_event_value = fxls8962af_write_event,\n\t.read_event_config = fxls8962af_read_event_config,\n\t.write_event_config = fxls8962af_write_event_config,\n\t.read_avail = fxls8962af_read_avail,\n\t.hwfifo_set_watermark = fxls8962af_set_watermark,\n};\n\nstatic int fxls8962af_reset(struct fxls8962af_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap, FXLS8962AF_SENS_CONFIG1,\n\t\t\t\t FXLS8962AF_SENS_CONFIG1_RST,\n\t\t\t\t FXLS8962AF_SENS_CONFIG1_RST);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read_poll_timeout(data->regmap, FXLS8962AF_INT_STATUS, reg,\n\t\t\t\t       (reg & FXLS8962AF_INT_STATUS_SRC_BOOT),\n\t\t\t\t       1000, 18000);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_err(dev, \"reset timeout, int_status = 0x%x\\n\", reg);\n\n\treturn ret;\n}\n\nstatic int __fxls8962af_fifo_set_mode(struct fxls8962af_data *data, bool onoff)\n{\n\tint ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, FXLS8962AF_BUF_CONFIG2,\n\t\t\t\t FXLS8962AF_BUF_CONFIG2_BUF_WMRK,\n\t\t\t\t data->watermark);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(data->regmap, FXLS8962AF_BUF_CONFIG1,\n\t\t\t\t  FXLS8962AF_BC1_BUF_MODE_MASK,\n\t\t\t\t  FXLS8962AF_BC1_BUF_MODE_PREP(onoff));\n}\n\nstatic int fxls8962af_buffer_preenable(struct iio_dev *indio_dev)\n{\n\treturn fxls8962af_power_on(iio_priv(indio_dev));\n}\n\nstatic int fxls8962af_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tfxls8962af_standby(data);\n\n\t \n\tret = regmap_update_bits(data->regmap, FXLS8962AF_INT_EN,\n\t\t\t\t FXLS8962AF_INT_EN_BUF_EN,\n\t\t\t\t FXLS8962AF_INT_EN_BUF_EN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __fxls8962af_fifo_set_mode(data, true);\n\n\tfxls8962af_active(data);\n\n\treturn ret;\n}\n\nstatic int fxls8962af_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tfxls8962af_standby(data);\n\n\t \n\tret = regmap_update_bits(data->regmap, FXLS8962AF_INT_EN,\n\t\t\t\t FXLS8962AF_INT_EN_BUF_EN, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __fxls8962af_fifo_set_mode(data, false);\n\n\tif (data->enable_event)\n\t\tfxls8962af_active(data);\n\n\treturn ret;\n}\n\nstatic int fxls8962af_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\n\tif (!data->enable_event)\n\t\tfxls8962af_power_off(data);\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops fxls8962af_buffer_ops = {\n\t.preenable = fxls8962af_buffer_preenable,\n\t.postenable = fxls8962af_buffer_postenable,\n\t.predisable = fxls8962af_buffer_predisable,\n\t.postdisable = fxls8962af_buffer_postdisable,\n};\n\nstatic int fxls8962af_i2c_raw_read_errata3(struct fxls8962af_data *data,\n\t\t\t\t\t   u16 *buffer, int samples,\n\t\t\t\t\t   int sample_length)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < samples; i++) {\n\t\tret = regmap_raw_read(data->regmap, FXLS8962AF_BUF_X_LSB,\n\t\t\t\t      &buffer[i * 3], sample_length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fxls8962af_fifo_transfer(struct fxls8962af_data *data,\n\t\t\t\t    u16 *buffer, int samples)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint sample_length = 3 * sizeof(*buffer);\n\tint total_length = samples * sample_length;\n\tint ret;\n\n\tif (i2c_verify_client(dev) &&\n\t    data->chip_info->chip_id == FXLS8962AF_DEVICE_ID)\n\t\t \n\t\tret = fxls8962af_i2c_raw_read_errata3(data, buffer, samples,\n\t\t\t\t\t\t      sample_length);\n\telse\n\t\tret = regmap_raw_read(data->regmap, FXLS8962AF_BUF_X_LSB, buffer,\n\t\t\t\t      total_length);\n\n\tif (ret)\n\t\tdev_err(dev, \"Error transferring data from fifo: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int fxls8962af_fifo_flush(struct iio_dev *indio_dev)\n{\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tu16 buffer[FXLS8962AF_FIFO_LENGTH * 3];\n\tuint64_t sample_period;\n\tunsigned int reg;\n\tint64_t tstamp;\n\tint ret, i;\n\tu8 count;\n\n\tret = regmap_read(data->regmap, FXLS8962AF_BUF_STATUS, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reg & FXLS8962AF_BUF_STATUS_BUF_OVF) {\n\t\tdev_err(dev, \"Buffer overflow\");\n\t\treturn -EOVERFLOW;\n\t}\n\n\tcount = reg & FXLS8962AF_BUF_STATUS_BUF_CNT;\n\tif (!count)\n\t\treturn 0;\n\n\tdata->old_timestamp = data->timestamp;\n\tdata->timestamp = iio_get_time_ns(indio_dev);\n\n\t \n\tsample_period = (data->timestamp - data->old_timestamp);\n\tdo_div(sample_period, count);\n\ttstamp = data->timestamp - (count - 1) * sample_period;\n\n\tret = fxls8962af_fifo_transfer(data, buffer, count);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tint j, bit;\n\n\t\tj = 0;\n\t\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t\t indio_dev->masklength) {\n\t\t\tmemcpy(&data->scan.channels[j++], &buffer[i * 3 + bit],\n\t\t\t       sizeof(data->scan.channels[0]));\n\t\t}\n\n\t\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t\t   tstamp);\n\n\t\ttstamp += sample_period;\n\t}\n\n\treturn count;\n}\n\nstatic int fxls8962af_event_interrupt(struct iio_dev *indio_dev)\n{\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\ts64 ts = iio_get_time_ns(indio_dev);\n\tunsigned int reg;\n\tu64 ev_code;\n\tint ret;\n\n\tret = regmap_read(data->regmap, FXLS8962AF_SDCD_INT_SRC1, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reg & FXLS8962AF_SDCD_INT_SRC1_X_OT) {\n\t\tev_code = reg & FXLS8962AF_SDCD_INT_SRC1_X_POL ?\n\t\t\tIIO_EV_DIR_RISING : IIO_EV_DIR_FALLING;\n\t\tiio_push_event(indio_dev,\n\t\t\t\tIIO_MOD_EVENT_CODE(IIO_ACCEL, 0, IIO_MOD_X,\n\t\t\t\t\tIIO_EV_TYPE_THRESH, ev_code), ts);\n\t}\n\n\tif (reg & FXLS8962AF_SDCD_INT_SRC1_Y_OT) {\n\t\tev_code = reg & FXLS8962AF_SDCD_INT_SRC1_Y_POL ?\n\t\t\tIIO_EV_DIR_RISING : IIO_EV_DIR_FALLING;\n\t\tiio_push_event(indio_dev,\n\t\t\t\tIIO_MOD_EVENT_CODE(IIO_ACCEL, 0, IIO_MOD_X,\n\t\t\t\t\tIIO_EV_TYPE_THRESH, ev_code), ts);\n\t}\n\n\tif (reg & FXLS8962AF_SDCD_INT_SRC1_Z_OT) {\n\t\tev_code = reg & FXLS8962AF_SDCD_INT_SRC1_Z_POL ?\n\t\t\tIIO_EV_DIR_RISING : IIO_EV_DIR_FALLING;\n\t\tiio_push_event(indio_dev,\n\t\t\t\tIIO_MOD_EVENT_CODE(IIO_ACCEL, 0, IIO_MOD_X,\n\t\t\t\t\tIIO_EV_TYPE_THRESH, ev_code), ts);\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t fxls8962af_interrupt(int irq, void *p)\n{\n\tstruct iio_dev *indio_dev = p;\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(data->regmap, FXLS8962AF_INT_STATUS, &reg);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tif (reg & FXLS8962AF_INT_STATUS_SRC_BUF) {\n\t\tret = fxls8962af_fifo_flush(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn IRQ_NONE;\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (reg & FXLS8962AF_INT_STATUS_SRC_SDCD_OT) {\n\t\tret = fxls8962af_event_interrupt(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn IRQ_NONE;\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic void fxls8962af_pm_disable(void *dev_ptr)\n{\n\tstruct device *dev = dev_ptr;\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_put_noidle(dev);\n\n\tfxls8962af_standby(iio_priv(indio_dev));\n}\n\nstatic void fxls8962af_get_irq(struct device_node *of_node,\n\t\t\t       enum fxls8962af_int_pin *pin)\n{\n\tint irq;\n\n\tirq = of_irq_get_byname(of_node, \"INT2\");\n\tif (irq > 0) {\n\t\t*pin = FXLS8962AF_PIN_INT2;\n\t\treturn;\n\t}\n\n\t*pin = FXLS8962AF_PIN_INT1;\n}\n\nstatic int fxls8962af_irq_setup(struct iio_dev *indio_dev, int irq)\n{\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tunsigned long irq_type;\n\tbool irq_active_high;\n\tenum fxls8962af_int_pin int_pin;\n\tu8 int_pin_sel;\n\tint ret;\n\n\tfxls8962af_get_irq(dev->of_node, &int_pin);\n\tswitch (int_pin) {\n\tcase FXLS8962AF_PIN_INT1:\n\t\tint_pin_sel = FXLS8962AF_INT_PIN_SEL_INT1;\n\t\tbreak;\n\tcase FXLS8962AF_PIN_INT2:\n\t\tint_pin_sel = FXLS8962AF_INT_PIN_SEL_INT2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported int pin selected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(data->regmap, FXLS8962AF_INT_PIN_SEL,\n\t\t\t\t FXLS8962AF_INT_PIN_SEL_MASK, int_pin_sel);\n\tif (ret)\n\t\treturn ret;\n\n\tirq_type = irqd_get_trigger_type(irq_get_irq_data(irq));\n\n\tswitch (irq_type) {\n\tcase IRQF_TRIGGER_HIGH:\n\tcase IRQF_TRIGGER_RISING:\n\t\tirq_active_high = true;\n\t\tbreak;\n\tcase IRQF_TRIGGER_LOW:\n\tcase IRQF_TRIGGER_FALLING:\n\t\tirq_active_high = false;\n\t\tbreak;\n\tdefault:\n\t\tdev_info(dev, \"mode %lx unsupported\\n\", irq_type);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(data->regmap, FXLS8962AF_SENS_CONFIG4,\n\t\t\t\t FXLS8962AF_SC4_INT_POL_MASK,\n\t\t\t\t FXLS8962AF_SC4_INT_POL_PREP(irq_active_high));\n\tif (ret)\n\t\treturn ret;\n\n\tif (device_property_read_bool(dev, \"drive-open-drain\")) {\n\t\tret = regmap_update_bits(data->regmap, FXLS8962AF_SENS_CONFIG4,\n\t\t\t\t\t FXLS8962AF_SC4_INT_PP_OD_MASK,\n\t\t\t\t\t FXLS8962AF_SC4_INT_PP_OD_PREP(1));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tirq_type |= IRQF_SHARED;\n\t}\n\n\treturn devm_request_threaded_irq(dev,\n\t\t\t\t\t irq,\n\t\t\t\t\t NULL, fxls8962af_interrupt,\n\t\t\t\t\t irq_type | IRQF_ONESHOT,\n\t\t\t\t\t indio_dev->name, indio_dev);\n}\n\nint fxls8962af_core_probe(struct device *dev, struct regmap *regmap, int irq)\n{\n\tstruct fxls8962af_data *data;\n\tstruct iio_dev *indio_dev;\n\tunsigned int reg;\n\tint ret, i;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdev_set_drvdata(dev, indio_dev);\n\tdata->regmap = regmap;\n\tdata->irq = irq;\n\n\tret = iio_read_mount_matrix(dev, &data->orientation);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_regulator_get_enable(dev, \"vdd\");\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to get vdd regulator\\n\");\n\n\tret = regmap_read(data->regmap, FXLS8962AF_WHO_AM_I, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(fxls_chip_info_table); i++) {\n\t\tif (fxls_chip_info_table[i].chip_id == reg) {\n\t\t\tdata->chip_info = &fxls_chip_info_table[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(fxls_chip_info_table)) {\n\t\tdev_err(dev, \"failed to match device in table\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tindio_dev->channels = data->chip_info->channels;\n\tindio_dev->num_channels = data->chip_info->num_channels;\n\tindio_dev->name = data->chip_info->name;\n\tindio_dev->info = &fxls8962af_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = fxls8962af_reset(data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (irq) {\n\t\tret = fxls8962af_irq_setup(indio_dev, irq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_iio_kfifo_buffer_setup(dev, indio_dev,\n\t\t\t\t\t\t  &fxls8962af_buffer_ops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = pm_runtime_set_active(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev, FXLS8962AF_AUTO_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\n\tret = devm_add_action_or_reset(dev, fxls8962af_pm_disable, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (device_property_read_bool(dev, \"wakeup-source\"))\n\t\tdevice_init_wakeup(dev, true);\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(fxls8962af_core_probe, IIO_FXLS8962AF);\n\nstatic int fxls8962af_runtime_suspend(struct device *dev)\n{\n\tstruct fxls8962af_data *data = iio_priv(dev_get_drvdata(dev));\n\tint ret;\n\n\tret = fxls8962af_standby(data);\n\tif (ret) {\n\t\tdev_err(dev, \"powering off device failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fxls8962af_runtime_resume(struct device *dev)\n{\n\tstruct fxls8962af_data *data = iio_priv(dev_get_drvdata(dev));\n\n\treturn fxls8962af_active(data);\n}\n\nstatic int fxls8962af_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\n\tif (device_may_wakeup(dev) && data->enable_event) {\n\t\tenable_irq_wake(data->irq);\n\n\t\t \n\t\tif (iio_buffer_enabled(indio_dev))\n\t\t\tfxls8962af_buffer_predisable(indio_dev);\n\t} else {\n\t\tfxls8962af_runtime_suspend(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int fxls8962af_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct fxls8962af_data *data = iio_priv(indio_dev);\n\n\tif (device_may_wakeup(dev) && data->enable_event) {\n\t\tdisable_irq_wake(data->irq);\n\n\t\tif (iio_buffer_enabled(indio_dev))\n\t\t\tfxls8962af_buffer_postenable(indio_dev);\n\t} else {\n\t\tfxls8962af_runtime_resume(dev);\n\t}\n\n\treturn 0;\n}\n\nEXPORT_NS_GPL_DEV_PM_OPS(fxls8962af_pm_ops, IIO_FXLS8962AF) = {\n\tSYSTEM_SLEEP_PM_OPS(fxls8962af_suspend, fxls8962af_resume)\n\tRUNTIME_PM_OPS(fxls8962af_runtime_suspend, fxls8962af_runtime_resume, NULL)\n};\n\nMODULE_AUTHOR(\"Sean Nyekjaer <sean@geanix.com>\");\nMODULE_DESCRIPTION(\"NXP FXLS8962AF/FXLS8964AF accelerometer driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}