{
  "module_name": "sca3000.c",
  "hash_id": "87276e93aa09e3ab2bb5edcbc78d7e38e06fd805194a6820c1141a4eebdfc9ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/sca3000.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/sysfs.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/kfifo_buf.h>\n\n#define SCA3000_WRITE_REG(a) (((a) << 2) | 0x02)\n#define SCA3000_READ_REG(a) ((a) << 2)\n\n#define SCA3000_REG_REVID_ADDR\t\t\t\t0x00\n#define   SCA3000_REG_REVID_MAJOR_MASK\t\t\tGENMASK(8, 4)\n#define   SCA3000_REG_REVID_MINOR_MASK\t\t\tGENMASK(3, 0)\n\n#define SCA3000_REG_STATUS_ADDR\t\t\t\t0x02\n#define   SCA3000_LOCKED\t\t\t\tBIT(5)\n#define   SCA3000_EEPROM_CS_ERROR\t\t\tBIT(1)\n#define   SCA3000_SPI_FRAME_ERROR\t\t\tBIT(0)\n\n \n#define SCA3000_REG_X_MSB_ADDR\t\t\t\t0x05\n#define SCA3000_REG_Y_MSB_ADDR\t\t\t\t0x07\n#define SCA3000_REG_Z_MSB_ADDR\t\t\t\t0x09\n\n#define SCA3000_REG_RING_OUT_ADDR\t\t\t0x0f\n\n \n#define SCA3000_REG_TEMP_MSB_ADDR\t\t\t0x13\n\n#define SCA3000_REG_MODE_ADDR\t\t\t\t0x14\n#define SCA3000_MODE_PROT_MASK\t\t\t\t0x28\n#define   SCA3000_REG_MODE_RING_BUF_ENABLE\t\tBIT(7)\n#define   SCA3000_REG_MODE_RING_BUF_8BIT\t\tBIT(6)\n\n \n#define   SCA3000_REG_MODE_FREE_FALL_DETECT\t\tBIT(4)\n#define   SCA3000_REG_MODE_MEAS_MODE_NORMAL\t\t0x00\n#define   SCA3000_REG_MODE_MEAS_MODE_OP_1\t\t0x01\n#define   SCA3000_REG_MODE_MEAS_MODE_OP_2\t\t0x02\n\n \n#define   SCA3000_REG_MODE_MEAS_MODE_MOT_DET\t\t0x03\n#define   SCA3000_REG_MODE_MODE_MASK\t\t\t0x03\n\n#define SCA3000_REG_BUF_COUNT_ADDR\t\t\t0x15\n\n#define SCA3000_REG_INT_STATUS_ADDR\t\t\t0x16\n#define   SCA3000_REG_INT_STATUS_THREE_QUARTERS\t\tBIT(7)\n#define   SCA3000_REG_INT_STATUS_HALF\t\t\tBIT(6)\n\n#define SCA3000_INT_STATUS_FREE_FALL\t\t\tBIT(3)\n#define SCA3000_INT_STATUS_Y_TRIGGER\t\t\tBIT(2)\n#define SCA3000_INT_STATUS_X_TRIGGER\t\t\tBIT(1)\n#define SCA3000_INT_STATUS_Z_TRIGGER\t\t\tBIT(0)\n\n \n#define SCA3000_REG_CTRL_SEL_ADDR\t\t\t0x18\n \n#define   SCA3000_REG_CTRL_SEL_I2C_DISABLE\t\t0x01\n#define   SCA3000_REG_CTRL_SEL_MD_CTRL\t\t\t0x02\n#define   SCA3000_REG_CTRL_SEL_MD_Y_TH\t\t\t0x03\n#define   SCA3000_REG_CTRL_SEL_MD_X_TH\t\t\t0x04\n#define   SCA3000_REG_CTRL_SEL_MD_Z_TH\t\t\t0x05\n \n#define   SCA3000_REG_CTRL_SEL_OUT_CTRL\t\t\t0x0B\n\n#define     SCA3000_REG_OUT_CTRL_PROT_MASK\t\t0xE0\n#define     SCA3000_REG_OUT_CTRL_BUF_X_EN\t\t0x10\n#define     SCA3000_REG_OUT_CTRL_BUF_Y_EN\t\t0x08\n#define     SCA3000_REG_OUT_CTRL_BUF_Z_EN\t\t0x04\n#define     SCA3000_REG_OUT_CTRL_BUF_DIV_MASK\t\t0x03\n#define     SCA3000_REG_OUT_CTRL_BUF_DIV_4\t\t0x02\n#define     SCA3000_REG_OUT_CTRL_BUF_DIV_2\t\t0x01\n\n\n \n#define SCA3000_MD_CTRL_PROT_MASK\t\t\t0xC0\n#define SCA3000_MD_CTRL_OR_Y\t\t\t\tBIT(0)\n#define SCA3000_MD_CTRL_OR_X\t\t\t\tBIT(1)\n#define SCA3000_MD_CTRL_OR_Z\t\t\t\tBIT(2)\n \n#define SCA3000_MD_CTRL_AND_Y\t\t\t\tBIT(3)\n#define SCA3000_MD_CTRL_AND_X\t\t\t\tBIT(4)\n#define SCA3000_MD_CTRL_AND_Z\t\t\t\tBIT(5)\n\n \n#define SCA3000_REG_UNLOCK_ADDR\t\t\t\t0x1e\n\n#define SCA3000_REG_INT_MASK_ADDR\t\t\t0x21\n#define   SCA3000_REG_INT_MASK_PROT_MASK\t\t0x1C\n\n#define   SCA3000_REG_INT_MASK_RING_THREE_QUARTER\tBIT(7)\n#define   SCA3000_REG_INT_MASK_RING_HALF\t\tBIT(6)\n\n#define SCA3000_REG_INT_MASK_ALL_INTS\t\t\t0x02\n#define SCA3000_REG_INT_MASK_ACTIVE_HIGH\t\t0x01\n#define SCA3000_REG_INT_MASK_ACTIVE_LOW\t\t\t0x00\n \n#define SCA3000_REG_CTRL_DATA_ADDR\t\t\t0x22\n\n \n#define SCA3000_OP_MODE_BYPASS\t\t\t\t0x01\n#define SCA3000_OP_MODE_NARROW\t\t\t\t0x02\n#define SCA3000_OP_MODE_WIDE\t\t\t\t0x04\n#define SCA3000_MAX_TX 6\n#define SCA3000_MAX_RX 2\n\n \nstruct sca3000_state {\n\tstruct spi_device\t\t*us;\n\tconst struct sca3000_chip_info\t*info;\n\ts64\t\t\t\tlast_timestamp;\n\tint\t\t\t\tmo_det_use_count;\n\tstruct mutex\t\t\tlock;\n\t \n\tu8\t\t\t\trx[384] __aligned(IIO_DMA_MINALIGN);\n\tu8\t\t\t\ttx[6] __aligned(IIO_DMA_MINALIGN);\n};\n\n \nstruct sca3000_chip_info {\n\tunsigned int\t\tscale;\n\tbool\t\t\ttemp_output;\n\tint\t\t\tmeasurement_mode_freq;\n\tint\t\t\tmeasurement_mode_3db_freq;\n\tint\t\t\toption_mode_1;\n\tint\t\t\toption_mode_1_freq;\n\tint\t\t\toption_mode_1_3db_freq;\n\tint\t\t\toption_mode_2;\n\tint\t\t\toption_mode_2_freq;\n\tint\t\t\toption_mode_2_3db_freq;\n\tint\t\t\tmot_det_mult_xz[6];\n\tint\t\t\tmot_det_mult_y[7];\n};\n\nenum sca3000_variant {\n\td01,\n\te02,\n\te04,\n\te05,\n};\n\n \nstatic const struct sca3000_chip_info sca3000_spi_chip_info_tbl[] = {\n\t[d01] = {\n\t\t.scale = 7357,\n\t\t.temp_output = true,\n\t\t.measurement_mode_freq = 250,\n\t\t.measurement_mode_3db_freq = 45,\n\t\t.option_mode_1 = SCA3000_OP_MODE_BYPASS,\n\t\t.option_mode_1_freq = 250,\n\t\t.option_mode_1_3db_freq = 70,\n\t\t.mot_det_mult_xz = {50, 100, 200, 350, 650, 1300},\n\t\t.mot_det_mult_y = {50, 100, 150, 250, 450, 850, 1750},\n\t},\n\t[e02] = {\n\t\t.scale = 9810,\n\t\t.measurement_mode_freq = 125,\n\t\t.measurement_mode_3db_freq = 40,\n\t\t.option_mode_1 = SCA3000_OP_MODE_NARROW,\n\t\t.option_mode_1_freq = 63,\n\t\t.option_mode_1_3db_freq = 11,\n\t\t.mot_det_mult_xz = {100, 150, 300, 550, 1050, 2050},\n\t\t.mot_det_mult_y = {50, 100, 200, 350, 700, 1350, 2700},\n\t},\n\t[e04] = {\n\t\t.scale = 19620,\n\t\t.measurement_mode_freq = 100,\n\t\t.measurement_mode_3db_freq = 38,\n\t\t.option_mode_1 = SCA3000_OP_MODE_NARROW,\n\t\t.option_mode_1_freq = 50,\n\t\t.option_mode_1_3db_freq = 9,\n\t\t.option_mode_2 = SCA3000_OP_MODE_WIDE,\n\t\t.option_mode_2_freq = 400,\n\t\t.option_mode_2_3db_freq = 70,\n\t\t.mot_det_mult_xz = {200, 300, 600, 1100, 2100, 4100},\n\t\t.mot_det_mult_y = {100, 200, 400, 7000, 1400, 2700, 54000},\n\t},\n\t[e05] = {\n\t\t.scale = 61313,\n\t\t.measurement_mode_freq = 200,\n\t\t.measurement_mode_3db_freq = 60,\n\t\t.option_mode_1 = SCA3000_OP_MODE_NARROW,\n\t\t.option_mode_1_freq = 50,\n\t\t.option_mode_1_3db_freq = 9,\n\t\t.option_mode_2 = SCA3000_OP_MODE_WIDE,\n\t\t.option_mode_2_freq = 400,\n\t\t.option_mode_2_3db_freq = 75,\n\t\t.mot_det_mult_xz = {600, 900, 1700, 3200, 6100, 11900},\n\t\t.mot_det_mult_y = {300, 600, 1200, 2000, 4100, 7800, 15600},\n\t},\n};\n\nstatic int sca3000_write_reg(struct sca3000_state *st, u8 address, u8 val)\n{\n\tst->tx[0] = SCA3000_WRITE_REG(address);\n\tst->tx[1] = val;\n\treturn spi_write(st->us, st->tx, 2);\n}\n\nstatic int sca3000_read_data_short(struct sca3000_state *st,\n\t\t\t\t   u8 reg_address_high,\n\t\t\t\t   int len)\n{\n\tstruct spi_transfer xfer[2] = {\n\t\t{\n\t\t\t.len = 1,\n\t\t\t.tx_buf = st->tx,\n\t\t}, {\n\t\t\t.len = len,\n\t\t\t.rx_buf = st->rx,\n\t\t}\n\t};\n\tst->tx[0] = SCA3000_READ_REG(reg_address_high);\n\n\treturn spi_sync_transfer(st->us, xfer, ARRAY_SIZE(xfer));\n}\n\n \nstatic int sca3000_reg_lock_on(struct sca3000_state *st)\n{\n\tint ret;\n\n\tret = sca3000_read_data_short(st, SCA3000_REG_STATUS_ADDR, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !(st->rx[0] & SCA3000_LOCKED);\n}\n\n \nstatic int __sca3000_unlock_reg_lock(struct sca3000_state *st)\n{\n\tstruct spi_transfer xfer[3] = {\n\t\t{\n\t\t\t.len = 2,\n\t\t\t.cs_change = 1,\n\t\t\t.tx_buf = st->tx,\n\t\t}, {\n\t\t\t.len = 2,\n\t\t\t.cs_change = 1,\n\t\t\t.tx_buf = st->tx + 2,\n\t\t}, {\n\t\t\t.len = 2,\n\t\t\t.tx_buf = st->tx + 4,\n\t\t},\n\t};\n\tst->tx[0] = SCA3000_WRITE_REG(SCA3000_REG_UNLOCK_ADDR);\n\tst->tx[1] = 0x00;\n\tst->tx[2] = SCA3000_WRITE_REG(SCA3000_REG_UNLOCK_ADDR);\n\tst->tx[3] = 0x50;\n\tst->tx[4] = SCA3000_WRITE_REG(SCA3000_REG_UNLOCK_ADDR);\n\tst->tx[5] = 0xA0;\n\n\treturn spi_sync_transfer(st->us, xfer, ARRAY_SIZE(xfer));\n}\n\n \nstatic int sca3000_write_ctrl_reg(struct sca3000_state *st,\n\t\t\t\t  u8 sel,\n\t\t\t\t  uint8_t val)\n{\n\tint ret;\n\n\tret = sca3000_reg_lock_on(st);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tif (ret) {\n\t\tret = __sca3000_unlock_reg_lock(st);\n\t\tif (ret)\n\t\t\tgoto error_ret;\n\t}\n\n\t \n\tret = sca3000_write_reg(st, SCA3000_REG_CTRL_SEL_ADDR, sel);\n\tif (ret)\n\t\tgoto error_ret;\n\n\t \n\tret = sca3000_write_reg(st, SCA3000_REG_CTRL_DATA_ADDR, val);\n\nerror_ret:\n\treturn ret;\n}\n\n \nstatic int sca3000_read_ctrl_reg(struct sca3000_state *st,\n\t\t\t\t u8 ctrl_reg)\n{\n\tint ret;\n\n\tret = sca3000_reg_lock_on(st);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tif (ret) {\n\t\tret = __sca3000_unlock_reg_lock(st);\n\t\tif (ret)\n\t\t\tgoto error_ret;\n\t}\n\t \n\tret = sca3000_write_reg(st, SCA3000_REG_CTRL_SEL_ADDR, ctrl_reg);\n\tif (ret)\n\t\tgoto error_ret;\n\tret = sca3000_read_data_short(st, SCA3000_REG_CTRL_DATA_ADDR, 1);\n\tif (ret)\n\t\tgoto error_ret;\n\treturn st->rx[0];\nerror_ret:\n\treturn ret;\n}\n\n \nstatic int sca3000_print_rev(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\n\tmutex_lock(&st->lock);\n\tret = sca3000_read_data_short(st, SCA3000_REG_REVID_ADDR, 1);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tdev_info(&indio_dev->dev,\n\t\t \"sca3000 revision major=%lu, minor=%lu\\n\",\n\t\t st->rx[0] & SCA3000_REG_REVID_MAJOR_MASK,\n\t\t st->rx[0] & SCA3000_REG_REVID_MINOR_MASK);\nerror_ret:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic ssize_t\nsca3000_show_available_3db_freqs(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\tint len;\n\n\tlen = sprintf(buf, \"%d\", st->info->measurement_mode_3db_freq);\n\tif (st->info->option_mode_1)\n\t\tlen += sprintf(buf + len, \" %d\",\n\t\t\t       st->info->option_mode_1_3db_freq);\n\tif (st->info->option_mode_2)\n\t\tlen += sprintf(buf + len, \" %d\",\n\t\t\t       st->info->option_mode_2_3db_freq);\n\tlen += sprintf(buf + len, \"\\n\");\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(in_accel_filter_low_pass_3db_frequency_available,\n\t\t       S_IRUGO, sca3000_show_available_3db_freqs,\n\t\t       NULL, 0);\n\nstatic const struct iio_event_spec sca3000_event = {\n\t.type = IIO_EV_TYPE_MAG,\n\t.dir = IIO_EV_DIR_RISING,\n\t.mask_separate = BIT(IIO_EV_INFO_VALUE) | BIT(IIO_EV_INFO_ENABLE),\n};\n\n \n#define SCA3000_CHAN(index, mod)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.type = IIO_ACCEL,\t\t\t\t\\\n\t\t.modified = 1,\t\t\t\t\t\\\n\t\t.channel2 = mod,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\\\n\t\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\\\n\t\t.address = index,\t\t\t\t\\\n\t\t.scan_index = index,\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\\\n\t\t\t.realbits = 13,\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\\\n\t\t\t.shift = 3,\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.event_spec = &sca3000_event,\t\t\t\\\n\t\t.num_event_specs = 1,\t\t\t\t\\\n\t}\n\nstatic const struct iio_event_spec sca3000_freefall_event_spec = {\n\t.type = IIO_EV_TYPE_MAG,\n\t.dir = IIO_EV_DIR_FALLING,\n\t.mask_separate = BIT(IIO_EV_INFO_ENABLE) |\n\t\tBIT(IIO_EV_INFO_PERIOD),\n};\n\nstatic const struct iio_chan_spec sca3000_channels[] = {\n\tSCA3000_CHAN(0, IIO_MOD_X),\n\tSCA3000_CHAN(1, IIO_MOD_Y),\n\tSCA3000_CHAN(2, IIO_MOD_Z),\n\t{\n\t\t.type = IIO_ACCEL,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_X_AND_Y_AND_Z,\n\t\t.scan_index = -1,  \n\t\t.event_spec = &sca3000_freefall_event_spec,\n\t\t.num_event_specs = 1,\n\t},\n};\n\nstatic const struct iio_chan_spec sca3000_channels_with_temp[] = {\n\tSCA3000_CHAN(0, IIO_MOD_X),\n\tSCA3000_CHAN(1, IIO_MOD_Y),\n\tSCA3000_CHAN(2, IIO_MOD_Z),\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\n\t\t \n\t\t.scan_index = -1,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 9,\n\t\t\t.storagebits = 16,\n\t\t\t.shift = 5,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_ACCEL,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_X_AND_Y_AND_Z,\n\t\t.scan_index = -1,  \n\t\t.event_spec = &sca3000_freefall_event_spec,\n\t\t.num_event_specs = 1,\n\t},\n};\n\nstatic u8 sca3000_addresses[3][3] = {\n\t[0] = {SCA3000_REG_X_MSB_ADDR, SCA3000_REG_CTRL_SEL_MD_X_TH,\n\t       SCA3000_MD_CTRL_OR_X},\n\t[1] = {SCA3000_REG_Y_MSB_ADDR, SCA3000_REG_CTRL_SEL_MD_Y_TH,\n\t       SCA3000_MD_CTRL_OR_Y},\n\t[2] = {SCA3000_REG_Z_MSB_ADDR, SCA3000_REG_CTRL_SEL_MD_Z_TH,\n\t       SCA3000_MD_CTRL_OR_Z},\n};\n\n \nstatic inline int __sca3000_get_base_freq(struct sca3000_state *st,\n\t\t\t\t\t  const struct sca3000_chip_info *info,\n\t\t\t\t\t  int *base_freq)\n{\n\tint ret;\n\n\tret = sca3000_read_data_short(st, SCA3000_REG_MODE_ADDR, 1);\n\tif (ret)\n\t\tgoto error_ret;\n\tswitch (SCA3000_REG_MODE_MODE_MASK & st->rx[0]) {\n\tcase SCA3000_REG_MODE_MEAS_MODE_NORMAL:\n\t\t*base_freq = info->measurement_mode_freq;\n\t\tbreak;\n\tcase SCA3000_REG_MODE_MEAS_MODE_OP_1:\n\t\t*base_freq = info->option_mode_1_freq;\n\t\tbreak;\n\tcase SCA3000_REG_MODE_MEAS_MODE_OP_2:\n\t\t*base_freq = info->option_mode_2_freq;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nerror_ret:\n\treturn ret;\n}\n\n \nstatic int sca3000_read_raw_samp_freq(struct sca3000_state *st, int *val)\n{\n\tint ret;\n\n\tret = __sca3000_get_base_freq(st, st->info, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sca3000_read_ctrl_reg(st, SCA3000_REG_CTRL_SEL_OUT_CTRL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (*val > 0) {\n\t\tret &= SCA3000_REG_OUT_CTRL_BUF_DIV_MASK;\n\t\tswitch (ret) {\n\t\tcase SCA3000_REG_OUT_CTRL_BUF_DIV_2:\n\t\t\t*val /= 2;\n\t\t\tbreak;\n\t\tcase SCA3000_REG_OUT_CTRL_BUF_DIV_4:\n\t\t\t*val /= 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sca3000_write_raw_samp_freq(struct sca3000_state *st, int val)\n{\n\tint ret, base_freq, ctrlval;\n\n\tret = __sca3000_get_base_freq(st, st->info, &base_freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sca3000_read_ctrl_reg(st, SCA3000_REG_CTRL_SEL_OUT_CTRL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctrlval = ret & ~SCA3000_REG_OUT_CTRL_BUF_DIV_MASK;\n\n\tif (val == base_freq / 2)\n\t\tctrlval |= SCA3000_REG_OUT_CTRL_BUF_DIV_2;\n\tif (val == base_freq / 4)\n\t\tctrlval |= SCA3000_REG_OUT_CTRL_BUF_DIV_4;\n\telse if (val != base_freq)\n\t\treturn -EINVAL;\n\n\treturn sca3000_write_ctrl_reg(st, SCA3000_REG_CTRL_SEL_OUT_CTRL,\n\t\t\t\t     ctrlval);\n}\n\nstatic int sca3000_read_3db_freq(struct sca3000_state *st, int *val)\n{\n\tint ret;\n\n\tret = sca3000_read_data_short(st, SCA3000_REG_MODE_ADDR, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tst->rx[0] &= SCA3000_REG_MODE_MODE_MASK;\n\tswitch (st->rx[0]) {\n\tcase SCA3000_REG_MODE_MEAS_MODE_NORMAL:\n\t\t*val = st->info->measurement_mode_3db_freq;\n\t\treturn IIO_VAL_INT;\n\tcase SCA3000_REG_MODE_MEAS_MODE_MOT_DET:\n\t\treturn -EBUSY;\n\tcase SCA3000_REG_MODE_MEAS_MODE_OP_1:\n\t\t*val = st->info->option_mode_1_3db_freq;\n\t\treturn IIO_VAL_INT;\n\tcase SCA3000_REG_MODE_MEAS_MODE_OP_2:\n\t\t*val = st->info->option_mode_2_3db_freq;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sca3000_write_3db_freq(struct sca3000_state *st, int val)\n{\n\tint ret;\n\tint mode;\n\n\tif (val == st->info->measurement_mode_3db_freq)\n\t\tmode = SCA3000_REG_MODE_MEAS_MODE_NORMAL;\n\telse if (st->info->option_mode_1 &&\n\t\t (val == st->info->option_mode_1_3db_freq))\n\t\tmode = SCA3000_REG_MODE_MEAS_MODE_OP_1;\n\telse if (st->info->option_mode_2 &&\n\t\t (val == st->info->option_mode_2_3db_freq))\n\t\tmode = SCA3000_REG_MODE_MEAS_MODE_OP_2;\n\telse\n\t\treturn -EINVAL;\n\tret = sca3000_read_data_short(st, SCA3000_REG_MODE_ADDR, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tst->rx[0] &= ~SCA3000_REG_MODE_MODE_MASK;\n\tst->rx[0] |= (mode & SCA3000_REG_MODE_MODE_MASK);\n\n\treturn sca3000_write_reg(st, SCA3000_REG_MODE_ADDR, st->rx[0]);\n}\n\nstatic int sca3000_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val,\n\t\t\t    int *val2,\n\t\t\t    long mask)\n{\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\tint ret;\n\tu8 address;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&st->lock);\n\t\tif (chan->type == IIO_ACCEL) {\n\t\t\tif (st->mo_det_use_count) {\n\t\t\t\tmutex_unlock(&st->lock);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\taddress = sca3000_addresses[chan->address][0];\n\t\t\tret = sca3000_read_data_short(st, address, 2);\n\t\t\tif (ret < 0) {\n\t\t\t\tmutex_unlock(&st->lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t*val = sign_extend32(be16_to_cpup((__be16 *)st->rx) >>\n\t\t\t\t\t     chan->scan_type.shift,\n\t\t\t\t\t     chan->scan_type.realbits - 1);\n\t\t} else {\n\t\t\t \n\t\t\tret = sca3000_read_data_short(st,\n\t\t\t\t\t\t      SCA3000_REG_TEMP_MSB_ADDR,\n\t\t\t\t\t\t      2);\n\t\t\tif (ret < 0) {\n\t\t\t\tmutex_unlock(&st->lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t*val = (be16_to_cpup((__be16 *)st->rx) >>\n\t\t\t\tchan->scan_type.shift) &\n\t\t\t\tGENMASK(chan->scan_type.realbits - 1, 0);\n\t\t}\n\t\tmutex_unlock(&st->lock);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\tif (chan->type == IIO_ACCEL)\n\t\t\t*val2 = st->info->scale;\n\t\telse  \n\t\t\t*val2 = 555556;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = -214;\n\t\t*val2 = 600000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tmutex_lock(&st->lock);\n\t\tret = sca3000_read_raw_samp_freq(st, val);\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret ? ret : IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tmutex_lock(&st->lock);\n\t\tret = sca3000_read_3db_freq(st, val);\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sca3000_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (val2)\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&st->lock);\n\t\tret = sca3000_write_raw_samp_freq(st, val);\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tif (val2)\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&st->lock);\n\t\tret = sca3000_write_3db_freq(st, val);\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic ssize_t sca3000_read_av_freq(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\tint len = 0, ret, val;\n\n\tmutex_lock(&st->lock);\n\tret = sca3000_read_data_short(st, SCA3000_REG_MODE_ADDR, 1);\n\tval = st->rx[0];\n\tmutex_unlock(&st->lock);\n\tif (ret)\n\t\tgoto error_ret;\n\n\tswitch (val & SCA3000_REG_MODE_MODE_MASK) {\n\tcase SCA3000_REG_MODE_MEAS_MODE_NORMAL:\n\t\tlen += sprintf(buf + len, \"%d %d %d\\n\",\n\t\t\t       st->info->measurement_mode_freq,\n\t\t\t       st->info->measurement_mode_freq / 2,\n\t\t\t       st->info->measurement_mode_freq / 4);\n\t\tbreak;\n\tcase SCA3000_REG_MODE_MEAS_MODE_OP_1:\n\t\tlen += sprintf(buf + len, \"%d %d %d\\n\",\n\t\t\t       st->info->option_mode_1_freq,\n\t\t\t       st->info->option_mode_1_freq / 2,\n\t\t\t       st->info->option_mode_1_freq / 4);\n\t\tbreak;\n\tcase SCA3000_REG_MODE_MEAS_MODE_OP_2:\n\t\tlen += sprintf(buf + len, \"%d %d %d\\n\",\n\t\t\t       st->info->option_mode_2_freq,\n\t\t\t       st->info->option_mode_2_freq / 2,\n\t\t\t       st->info->option_mode_2_freq / 4);\n\t\tbreak;\n\t}\n\treturn len;\nerror_ret:\n\treturn ret;\n}\n\n \nstatic IIO_DEV_ATTR_SAMP_FREQ_AVAIL(sca3000_read_av_freq);\n\n \nstatic int sca3000_read_event_value(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir,\n\t\t\t\t    enum iio_event_info info,\n\t\t\t\t    int *val, int *val2)\n{\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\tlong ret;\n\tint i;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tmutex_lock(&st->lock);\n\t\tret = sca3000_read_ctrl_reg(st,\n\t\t\t\t\t    sca3000_addresses[chan->address][1]);\n\t\tmutex_unlock(&st->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = 0;\n\t\tif (chan->channel2 == IIO_MOD_Y)\n\t\t\tfor_each_set_bit(i, &ret,\n\t\t\t\t\t ARRAY_SIZE(st->info->mot_det_mult_y))\n\t\t\t\t*val += st->info->mot_det_mult_y[i];\n\t\telse\n\t\t\tfor_each_set_bit(i, &ret,\n\t\t\t\t\t ARRAY_SIZE(st->info->mot_det_mult_xz))\n\t\t\t\t*val += st->info->mot_det_mult_xz[i];\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_EV_INFO_PERIOD:\n\t\t*val = 0;\n\t\t*val2 = 226000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int sca3000_write_event_value(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir,\n\t\t\t\t     enum iio_event_info info,\n\t\t\t\t     int val, int val2)\n{\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\tint ret;\n\tint i;\n\tu8 nonlinear = 0;\n\n\tif (chan->channel2 == IIO_MOD_Y) {\n\t\ti = ARRAY_SIZE(st->info->mot_det_mult_y);\n\t\twhile (i > 0)\n\t\t\tif (val >= st->info->mot_det_mult_y[--i]) {\n\t\t\t\tnonlinear |= (1 << i);\n\t\t\t\tval -= st->info->mot_det_mult_y[i];\n\t\t\t}\n\t} else {\n\t\ti = ARRAY_SIZE(st->info->mot_det_mult_xz);\n\t\twhile (i > 0)\n\t\t\tif (val >= st->info->mot_det_mult_xz[--i]) {\n\t\t\t\tnonlinear |= (1 << i);\n\t\t\t\tval -= st->info->mot_det_mult_xz[i];\n\t\t\t}\n\t}\n\n\tmutex_lock(&st->lock);\n\tret = sca3000_write_ctrl_reg(st,\n\t\t\t\t     sca3000_addresses[chan->address][1],\n\t\t\t\t     nonlinear);\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic struct attribute *sca3000_attributes[] = {\n\t&iio_dev_attr_in_accel_filter_low_pass_3db_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group sca3000_attribute_group = {\n\t.attrs = sca3000_attributes,\n};\n\nstatic int sca3000_read_data(struct sca3000_state *st,\n\t\t\t     u8 reg_address_high,\n\t\t\t     u8 *rx,\n\t\t\t     int len)\n{\n\tint ret;\n\tstruct spi_transfer xfer[2] = {\n\t\t{\n\t\t\t.len = 1,\n\t\t\t.tx_buf = st->tx,\n\t\t}, {\n\t\t\t.len = len,\n\t\t\t.rx_buf = rx,\n\t\t}\n\t};\n\n\tst->tx[0] = SCA3000_READ_REG(reg_address_high);\n\tret = spi_sync_transfer(st->us, xfer, ARRAY_SIZE(xfer));\n\tif (ret) {\n\t\tdev_err(&st->us->dev, \"problem reading register\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void sca3000_ring_int_process(u8 val, struct iio_dev *indio_dev)\n{\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\tint ret, i, num_available;\n\n\tmutex_lock(&st->lock);\n\n\tif (val & SCA3000_REG_INT_STATUS_HALF) {\n\t\tret = sca3000_read_data_short(st, SCA3000_REG_BUF_COUNT_ADDR,\n\t\t\t\t\t      1);\n\t\tif (ret)\n\t\t\tgoto error_ret;\n\t\tnum_available = st->rx[0];\n\t\t \n\t\tret = sca3000_read_data(st, SCA3000_REG_RING_OUT_ADDR, st->rx,\n\t\t\t\t\tnum_available * 2);\n\t\tif (ret)\n\t\t\tgoto error_ret;\n\t\tfor (i = 0; i < num_available / 3; i++) {\n\t\t\t \n\t\t\tiio_push_to_buffers(indio_dev, st->rx + i * 3 * 2);\n\t\t}\n\t}\nerror_ret:\n\tmutex_unlock(&st->lock);\n}\n\n \nstatic irqreturn_t sca3000_event_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\tint ret, val;\n\ts64 last_timestamp = iio_get_time_ns(indio_dev);\n\n\t \n\tmutex_lock(&st->lock);\n\tret = sca3000_read_data_short(st, SCA3000_REG_INT_STATUS_ADDR, 1);\n\tval = st->rx[0];\n\tmutex_unlock(&st->lock);\n\tif (ret)\n\t\tgoto done;\n\n\tsca3000_ring_int_process(val, indio_dev);\n\n\tif (val & SCA3000_INT_STATUS_FREE_FALL)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  IIO_MOD_X_AND_Y_AND_Z,\n\t\t\t\t\t\t  IIO_EV_TYPE_MAG,\n\t\t\t\t\t\t  IIO_EV_DIR_FALLING),\n\t\t\t       last_timestamp);\n\n\tif (val & SCA3000_INT_STATUS_Y_TRIGGER)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  IIO_MOD_Y,\n\t\t\t\t\t\t  IIO_EV_TYPE_MAG,\n\t\t\t\t\t\t  IIO_EV_DIR_RISING),\n\t\t\t       last_timestamp);\n\n\tif (val & SCA3000_INT_STATUS_X_TRIGGER)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  IIO_MOD_X,\n\t\t\t\t\t\t  IIO_EV_TYPE_MAG,\n\t\t\t\t\t\t  IIO_EV_DIR_RISING),\n\t\t\t       last_timestamp);\n\n\tif (val & SCA3000_INT_STATUS_Z_TRIGGER)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  IIO_MOD_Z,\n\t\t\t\t\t\t  IIO_EV_TYPE_MAG,\n\t\t\t\t\t\t  IIO_EV_DIR_RISING),\n\t\t\t       last_timestamp);\n\ndone:\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int sca3000_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir)\n{\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\tint ret;\n\t \n\tmutex_lock(&st->lock);\n\n\tret = sca3000_read_data_short(st, SCA3000_REG_MODE_ADDR, 1);\n\tif (ret)\n\t\tgoto error_ret;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X_AND_Y_AND_Z:\n\t\tret = !!(st->rx[0] & SCA3000_REG_MODE_FREE_FALL_DETECT);\n\t\tbreak;\n\tcase IIO_MOD_X:\n\tcase IIO_MOD_Y:\n\tcase IIO_MOD_Z:\n\t\t \n\t\tif ((st->rx[0] & SCA3000_REG_MODE_MODE_MASK)\n\t\t    != SCA3000_REG_MODE_MEAS_MODE_MOT_DET) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = sca3000_read_ctrl_reg(st,\n\t\t\t\t\t\tSCA3000_REG_CTRL_SEL_MD_CTRL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_ret;\n\t\t\t \n\t\t\tret = !!(ret & sca3000_addresses[chan->address][2]);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nerror_ret:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int sca3000_freefall_set_state(struct iio_dev *indio_dev, int state)\n{\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\t \n\tret = sca3000_read_data_short(st, SCA3000_REG_MODE_ADDR, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (state && !(st->rx[0] & SCA3000_REG_MODE_FREE_FALL_DETECT))\n\t\treturn sca3000_write_reg(st, SCA3000_REG_MODE_ADDR,\n\t\t\t\t\t st->rx[0] | SCA3000_REG_MODE_FREE_FALL_DETECT);\n\t \n\telse if (!state && (st->rx[0] & SCA3000_REG_MODE_FREE_FALL_DETECT))\n\t\treturn sca3000_write_reg(st, SCA3000_REG_MODE_ADDR,\n\t\t\t\t\t st->rx[0] & ~SCA3000_REG_MODE_FREE_FALL_DETECT);\n\telse\n\t\treturn 0;\n}\n\nstatic int sca3000_motion_detect_set_state(struct iio_dev *indio_dev, int axis,\n\t\t\t\t\t   int state)\n{\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\tint ret, ctrlval;\n\n\t \n\tret = sca3000_read_ctrl_reg(st, SCA3000_REG_CTRL_SEL_MD_CTRL);\n\tif (ret < 0)\n\t\treturn ret;\n\tctrlval = ret;\n\t \n\tif (state && !(ctrlval & sca3000_addresses[axis][2])) {\n\t\tret = sca3000_write_ctrl_reg(st,\n\t\t\t\t\t     SCA3000_REG_CTRL_SEL_MD_CTRL,\n\t\t\t\t\t     ctrlval |\n\t\t\t\t\t     sca3000_addresses[axis][2]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tst->mo_det_use_count++;\n\t} else if (!state && (ctrlval & sca3000_addresses[axis][2])) {\n\t\tret = sca3000_write_ctrl_reg(st,\n\t\t\t\t\t     SCA3000_REG_CTRL_SEL_MD_CTRL,\n\t\t\t\t\t     ctrlval &\n\t\t\t\t\t     ~(sca3000_addresses[axis][2]));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tst->mo_det_use_count--;\n\t}\n\n\t \n\tret = sca3000_read_data_short(st, SCA3000_REG_MODE_ADDR, 1);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif ((st->mo_det_use_count) &&\n\t    ((st->rx[0] & SCA3000_REG_MODE_MODE_MASK)\n\t     != SCA3000_REG_MODE_MEAS_MODE_MOT_DET))\n\t\treturn sca3000_write_reg(st, SCA3000_REG_MODE_ADDR,\n\t\t\t(st->rx[0] & ~SCA3000_REG_MODE_MODE_MASK)\n\t\t\t| SCA3000_REG_MODE_MEAS_MODE_MOT_DET);\n\t \n\telse if (!(st->mo_det_use_count) &&\n\t\t ((st->rx[0] & SCA3000_REG_MODE_MODE_MASK)\n\t\t  == SCA3000_REG_MODE_MEAS_MODE_MOT_DET))\n\t\treturn sca3000_write_reg(st, SCA3000_REG_MODE_ADDR,\n\t\t\tst->rx[0] & SCA3000_REG_MODE_MODE_MASK);\n\telse\n\t\treturn 0;\n}\n\n \nstatic int sca3000_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir,\n\t\t\t\t      int state)\n{\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X_AND_Y_AND_Z:\n\t\tret = sca3000_freefall_set_state(indio_dev, state);\n\t\tbreak;\n\n\tcase IIO_MOD_X:\n\tcase IIO_MOD_Y:\n\tcase IIO_MOD_Z:\n\t\tret = sca3000_motion_detect_set_state(indio_dev,\n\t\t\t\t\t\t      chan->address,\n\t\t\t\t\t\t      state);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic inline\nint __sca3000_hw_ring_state_set(struct iio_dev *indio_dev, bool state)\n{\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = sca3000_read_data_short(st, SCA3000_REG_MODE_ADDR, 1);\n\tif (ret)\n\t\tgoto error_ret;\n\tif (state) {\n\t\tdev_info(&indio_dev->dev, \"supposedly enabling ring buffer\\n\");\n\t\tret = sca3000_write_reg(st,\n\t\t\tSCA3000_REG_MODE_ADDR,\n\t\t\t(st->rx[0] | SCA3000_REG_MODE_RING_BUF_ENABLE));\n\t} else\n\t\tret = sca3000_write_reg(st,\n\t\t\tSCA3000_REG_MODE_ADDR,\n\t\t\t(st->rx[0] & ~SCA3000_REG_MODE_RING_BUF_ENABLE));\nerror_ret:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\n \nstatic int sca3000_hw_ring_preenable(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\n\tmutex_lock(&st->lock);\n\n\t \n\tret = sca3000_read_data_short(st, SCA3000_REG_INT_MASK_ADDR, 1);\n\tif (ret)\n\t\tgoto error_unlock;\n\tret = sca3000_write_reg(st,\n\t\t\t\tSCA3000_REG_INT_MASK_ADDR,\n\t\t\t\tst->rx[0] | SCA3000_REG_INT_MASK_RING_HALF);\n\tif (ret)\n\t\tgoto error_unlock;\n\n\tmutex_unlock(&st->lock);\n\n\treturn __sca3000_hw_ring_state_set(indio_dev, 1);\n\nerror_unlock:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int sca3000_hw_ring_postdisable(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\n\tret = __sca3000_hw_ring_state_set(indio_dev, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmutex_lock(&st->lock);\n\n\tret = sca3000_read_data_short(st, SCA3000_REG_INT_MASK_ADDR, 1);\n\tif (ret)\n\t\tgoto unlock;\n\tret = sca3000_write_reg(st,\n\t\t\t\tSCA3000_REG_INT_MASK_ADDR,\n\t\t\t\tst->rx[0] & ~SCA3000_REG_INT_MASK_RING_HALF);\nunlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic const struct iio_buffer_setup_ops sca3000_ring_setup_ops = {\n\t.preenable = &sca3000_hw_ring_preenable,\n\t.postdisable = &sca3000_hw_ring_postdisable,\n};\n\n \nstatic int sca3000_clean_setup(struct sca3000_state *st)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\t \n\tret = sca3000_read_data_short(st, SCA3000_REG_INT_STATUS_ADDR, 1);\n\tif (ret)\n\t\tgoto error_ret;\n\n\t \n\tret = sca3000_read_ctrl_reg(st, SCA3000_REG_CTRL_SEL_MD_CTRL);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tret = sca3000_write_ctrl_reg(st, SCA3000_REG_CTRL_SEL_MD_CTRL,\n\t\t\t\t     ret & SCA3000_MD_CTRL_PROT_MASK);\n\tif (ret)\n\t\tgoto error_ret;\n\n\t \n\tret = sca3000_read_ctrl_reg(st, SCA3000_REG_CTRL_SEL_OUT_CTRL);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\tret = sca3000_write_ctrl_reg(st, SCA3000_REG_CTRL_SEL_OUT_CTRL,\n\t\t\t\t     (ret & SCA3000_REG_OUT_CTRL_PROT_MASK)\n\t\t\t\t     | SCA3000_REG_OUT_CTRL_BUF_X_EN\n\t\t\t\t     | SCA3000_REG_OUT_CTRL_BUF_Y_EN\n\t\t\t\t     | SCA3000_REG_OUT_CTRL_BUF_Z_EN\n\t\t\t\t     | SCA3000_REG_OUT_CTRL_BUF_DIV_4);\n\tif (ret)\n\t\tgoto error_ret;\n\t \n\tret = sca3000_read_data_short(st, SCA3000_REG_INT_MASK_ADDR, 1);\n\tif (ret)\n\t\tgoto error_ret;\n\tret = sca3000_write_reg(st,\n\t\t\t\tSCA3000_REG_INT_MASK_ADDR,\n\t\t\t\t(ret & SCA3000_REG_INT_MASK_PROT_MASK)\n\t\t\t\t| SCA3000_REG_INT_MASK_ACTIVE_LOW);\n\tif (ret)\n\t\tgoto error_ret;\n\t \n\tret = sca3000_read_data_short(st, SCA3000_REG_MODE_ADDR, 1);\n\tif (ret)\n\t\tgoto error_ret;\n\tret = sca3000_write_reg(st, SCA3000_REG_MODE_ADDR,\n\t\t\t\t(st->rx[0] & SCA3000_MODE_PROT_MASK));\n\nerror_ret:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic const struct iio_info sca3000_info = {\n\t.attrs = &sca3000_attribute_group,\n\t.read_raw = &sca3000_read_raw,\n\t.write_raw = &sca3000_write_raw,\n\t.read_event_value = &sca3000_read_event_value,\n\t.write_event_value = &sca3000_write_event_value,\n\t.read_event_config = &sca3000_read_event_config,\n\t.write_event_config = &sca3000_write_event_config,\n};\n\nstatic int sca3000_probe(struct spi_device *spi)\n{\n\tint ret;\n\tstruct sca3000_state *st;\n\tstruct iio_dev *indio_dev;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tspi_set_drvdata(spi, indio_dev);\n\tst->us = spi;\n\tmutex_init(&st->lock);\n\tst->info = &sca3000_spi_chip_info_tbl[spi_get_device_id(spi)\n\t\t\t\t\t      ->driver_data];\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->info = &sca3000_info;\n\tif (st->info->temp_output) {\n\t\tindio_dev->channels = sca3000_channels_with_temp;\n\t\tindio_dev->num_channels =\n\t\t\tARRAY_SIZE(sca3000_channels_with_temp);\n\t} else {\n\t\tindio_dev->channels = sca3000_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(sca3000_channels);\n\t}\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = devm_iio_kfifo_buffer_setup(&spi->dev, indio_dev,\n\t\t\t\t\t  &sca3000_ring_setup_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tif (spi->irq) {\n\t\tret = request_threaded_irq(spi->irq,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   &sca3000_event_handler,\n\t\t\t\t\t   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t   \"sca3000\",\n\t\t\t\t\t   indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tret = sca3000_clean_setup(st);\n\tif (ret)\n\t\tgoto error_free_irq;\n\n\tret = sca3000_print_rev(indio_dev);\n\tif (ret)\n\t\tgoto error_free_irq;\n\n\treturn iio_device_register(indio_dev);\n\nerror_free_irq:\n\tif (spi->irq)\n\t\tfree_irq(spi->irq, indio_dev);\n\n\treturn ret;\n}\n\nstatic int sca3000_stop_all_interrupts(struct sca3000_state *st)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = sca3000_read_data_short(st, SCA3000_REG_INT_MASK_ADDR, 1);\n\tif (ret)\n\t\tgoto error_ret;\n\tret = sca3000_write_reg(st, SCA3000_REG_INT_MASK_ADDR,\n\t\t\t\t(st->rx[0] &\n\t\t\t\t ~(SCA3000_REG_INT_MASK_RING_THREE_QUARTER |\n\t\t\t\t   SCA3000_REG_INT_MASK_RING_HALF |\n\t\t\t\t   SCA3000_REG_INT_MASK_ALL_INTS)));\nerror_ret:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic void sca3000_remove(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev = spi_get_drvdata(spi);\n\tstruct sca3000_state *st = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\t \n\tsca3000_stop_all_interrupts(st);\n\tif (spi->irq)\n\t\tfree_irq(spi->irq, indio_dev);\n}\n\nstatic const struct spi_device_id sca3000_id[] = {\n\t{\"sca3000_d01\", d01},\n\t{\"sca3000_e02\", e02},\n\t{\"sca3000_e04\", e04},\n\t{\"sca3000_e05\", e05},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, sca3000_id);\n\nstatic struct spi_driver sca3000_driver = {\n\t.driver = {\n\t\t.name = \"sca3000\",\n\t},\n\t.probe = sca3000_probe,\n\t.remove = sca3000_remove,\n\t.id_table = sca3000_id,\n};\nmodule_spi_driver(sca3000_driver);\n\nMODULE_AUTHOR(\"Jonathan Cameron <jic23@kernel.org>\");\nMODULE_DESCRIPTION(\"VTI SCA3000 Series Accelerometers SPI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}