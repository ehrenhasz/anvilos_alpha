{
  "module_name": "adxl372.c",
  "hash_id": "0ba7a10a26db4e2ca03d0e657ae76d321b1e3b4ad6178919afaa3757766e1318",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/adxl372.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/events.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#include \"adxl372.h\"\n\n \n#define ADXL372_DEVID\t\t\t0x00\n#define ADXL372_DEVID_MST\t\t0x01\n#define ADXL372_PARTID\t\t\t0x02\n#define ADXL372_STATUS_1\t\t0x04\n#define ADXL372_STATUS_2\t\t0x05\n#define ADXL372_FIFO_ENTRIES_2\t\t0x06\n#define ADXL372_FIFO_ENTRIES_1\t\t0x07\n#define ADXL372_X_DATA_H\t\t0x08\n#define ADXL372_X_DATA_L\t\t0x09\n#define ADXL372_Y_DATA_H\t\t0x0A\n#define ADXL372_Y_DATA_L\t\t0x0B\n#define ADXL372_Z_DATA_H\t\t0x0C\n#define ADXL372_Z_DATA_L\t\t0x0D\n#define ADXL372_X_MAXPEAK_H\t\t0x15\n#define ADXL372_X_MAXPEAK_L\t\t0x16\n#define ADXL372_Y_MAXPEAK_H\t\t0x17\n#define ADXL372_Y_MAXPEAK_L\t\t0x18\n#define ADXL372_Z_MAXPEAK_H\t\t0x19\n#define ADXL372_Z_MAXPEAK_L\t\t0x1A\n#define ADXL372_OFFSET_X\t\t0x20\n#define ADXL372_OFFSET_Y\t\t0x21\n#define ADXL372_OFFSET_Z\t\t0x22\n#define ADXL372_X_THRESH_ACT_H\t\t0x23\n#define ADXL372_X_THRESH_ACT_L\t\t0x24\n#define ADXL372_Y_THRESH_ACT_H\t\t0x25\n#define ADXL372_Y_THRESH_ACT_L\t\t0x26\n#define ADXL372_Z_THRESH_ACT_H\t\t0x27\n#define ADXL372_Z_THRESH_ACT_L\t\t0x28\n#define ADXL372_TIME_ACT\t\t0x29\n#define ADXL372_X_THRESH_INACT_H\t0x2A\n#define ADXL372_X_THRESH_INACT_L\t0x2B\n#define ADXL372_Y_THRESH_INACT_H\t0x2C\n#define ADXL372_Y_THRESH_INACT_L\t0x2D\n#define ADXL372_Z_THRESH_INACT_H\t0x2E\n#define ADXL372_Z_THRESH_INACT_L\t0x2F\n#define ADXL372_TIME_INACT_H\t\t0x30\n#define ADXL372_TIME_INACT_L\t\t0x31\n#define ADXL372_X_THRESH_ACT2_H\t\t0x32\n#define ADXL372_X_THRESH_ACT2_L\t\t0x33\n#define ADXL372_Y_THRESH_ACT2_H\t\t0x34\n#define ADXL372_Y_THRESH_ACT2_L\t\t0x35\n#define ADXL372_Z_THRESH_ACT2_H\t\t0x36\n#define ADXL372_Z_THRESH_ACT2_L\t\t0x37\n#define ADXL372_HPF\t\t\t0x38\n#define ADXL372_FIFO_SAMPLES\t\t0x39\n#define ADXL372_FIFO_CTL\t\t0x3A\n#define ADXL372_INT1_MAP\t\t0x3B\n#define ADXL372_INT2_MAP\t\t0x3C\n#define ADXL372_TIMING\t\t\t0x3D\n#define ADXL372_MEASURE\t\t\t0x3E\n#define ADXL372_POWER_CTL\t\t0x3F\n#define ADXL372_SELF_TEST\t\t0x40\n#define ADXL372_RESET\t\t\t0x41\n#define ADXL372_FIFO_DATA\t\t0x42\n\n#define ADXL372_DEVID_VAL\t\t0xAD\n#define ADXL372_PARTID_VAL\t\t0xFA\n#define ADXL372_RESET_CODE\t\t0x52\n\n \n#define ADXL372_POWER_CTL_MODE_MSK\t\tGENMASK_ULL(1, 0)\n#define ADXL372_POWER_CTL_MODE(x)\t\t(((x) & 0x3) << 0)\n\n \n#define ADXL372_MEASURE_LINKLOOP_MSK\t\tGENMASK_ULL(5, 4)\n#define ADXL372_MEASURE_LINKLOOP_MODE(x)\t(((x) & 0x3) << 4)\n#define ADXL372_MEASURE_BANDWIDTH_MSK\t\tGENMASK_ULL(2, 0)\n#define ADXL372_MEASURE_BANDWIDTH_MODE(x)\t(((x) & 0x7) << 0)\n\n \n#define ADXL372_TIMING_ODR_MSK\t\t\tGENMASK_ULL(7, 5)\n#define ADXL372_TIMING_ODR_MODE(x)\t\t(((x) & 0x7) << 5)\n\n \n#define ADXL372_FIFO_CTL_FORMAT_MSK\t\tGENMASK(5, 3)\n#define ADXL372_FIFO_CTL_FORMAT_MODE(x)\t\t(((x) & 0x7) << 3)\n#define ADXL372_FIFO_CTL_MODE_MSK\t\tGENMASK(2, 1)\n#define ADXL372_FIFO_CTL_MODE_MODE(x)\t\t(((x) & 0x3) << 1)\n#define ADXL372_FIFO_CTL_SAMPLES_MSK\t\tBIT(1)\n#define ADXL372_FIFO_CTL_SAMPLES_MODE(x)\t(((x) > 0xFF) ? 1 : 0)\n\n \n#define ADXL372_STATUS_1_DATA_RDY(x)\t\t(((x) >> 0) & 0x1)\n#define ADXL372_STATUS_1_FIFO_RDY(x)\t\t(((x) >> 1) & 0x1)\n#define ADXL372_STATUS_1_FIFO_FULL(x)\t\t(((x) >> 2) & 0x1)\n#define ADXL372_STATUS_1_FIFO_OVR(x)\t\t(((x) >> 3) & 0x1)\n#define ADXL372_STATUS_1_USR_NVM_BUSY(x)\t(((x) >> 5) & 0x1)\n#define ADXL372_STATUS_1_AWAKE(x)\t\t(((x) >> 6) & 0x1)\n#define ADXL372_STATUS_1_ERR_USR_REGS(x)\t(((x) >> 7) & 0x1)\n\n \n#define ADXL372_STATUS_2_INACT(x)\t\t(((x) >> 4) & 0x1)\n#define ADXL372_STATUS_2_ACT(x)\t\t\t(((x) >> 5) & 0x1)\n#define ADXL372_STATUS_2_AC2(x)\t\t\t(((x) >> 6) & 0x1)\n\n \n#define ADXL372_INT1_MAP_DATA_RDY_MSK\t\tBIT(0)\n#define ADXL372_INT1_MAP_DATA_RDY_MODE(x)\t(((x) & 0x1) << 0)\n#define ADXL372_INT1_MAP_FIFO_RDY_MSK\t\tBIT(1)\n#define ADXL372_INT1_MAP_FIFO_RDY_MODE(x)\t(((x) & 0x1) << 1)\n#define ADXL372_INT1_MAP_FIFO_FULL_MSK\t\tBIT(2)\n#define ADXL372_INT1_MAP_FIFO_FULL_MODE(x)\t(((x) & 0x1) << 2)\n#define ADXL372_INT1_MAP_FIFO_OVR_MSK\t\tBIT(3)\n#define ADXL372_INT1_MAP_FIFO_OVR_MODE(x)\t(((x) & 0x1) << 3)\n#define ADXL372_INT1_MAP_INACT_MSK\t\tBIT(4)\n#define ADXL372_INT1_MAP_INACT_MODE(x)\t\t(((x) & 0x1) << 4)\n#define ADXL372_INT1_MAP_ACT_MSK\t\tBIT(5)\n#define ADXL372_INT1_MAP_ACT_MODE(x)\t\t(((x) & 0x1) << 5)\n#define ADXL372_INT1_MAP_AWAKE_MSK\t\tBIT(6)\n#define ADXL372_INT1_MAP_AWAKE_MODE(x)\t\t(((x) & 0x1) << 6)\n#define ADXL372_INT1_MAP_LOW_MSK\t\tBIT(7)\n#define ADXL372_INT1_MAP_LOW_MODE(x)\t\t(((x) & 0x1) << 7)\n\n \n#define ADXL372_THRESH_VAL_H_MSK\tGENMASK(10, 3)\n#define ADXL372_THRESH_VAL_H_SEL(x)\tFIELD_GET(ADXL372_THRESH_VAL_H_MSK, x)\n#define ADXL372_THRESH_VAL_L_MSK\tGENMASK(2, 0)\n#define ADXL372_THRESH_VAL_L_SEL(x)\tFIELD_GET(ADXL372_THRESH_VAL_L_MSK, x)\n\n \n#define ADXL372_FIFO_SIZE\t\t\t512\n#define ADXL372_X_AXIS_EN(x)\t\t\t((x) & BIT(0))\n#define ADXL372_Y_AXIS_EN(x)\t\t\t((x) & BIT(1))\n#define ADXL372_Z_AXIS_EN(x)\t\t\t((x) & BIT(2))\n\n \n#define ADXL372_USCALE\t958241\n\nenum adxl372_op_mode {\n\tADXL372_STANDBY,\n\tADXL372_WAKE_UP,\n\tADXL372_INSTANT_ON,\n\tADXL372_FULL_BW_MEASUREMENT,\n};\n\nenum adxl372_act_proc_mode {\n\tADXL372_DEFAULT,\n\tADXL372_LINKED,\n\tADXL372_LOOPED,\n};\n\nenum adxl372_th_activity {\n\tADXL372_ACTIVITY,\n\tADXL372_ACTIVITY2,\n\tADXL372_INACTIVITY,\n};\n\nenum adxl372_odr {\n\tADXL372_ODR_400HZ,\n\tADXL372_ODR_800HZ,\n\tADXL372_ODR_1600HZ,\n\tADXL372_ODR_3200HZ,\n\tADXL372_ODR_6400HZ,\n};\n\nenum adxl372_bandwidth {\n\tADXL372_BW_200HZ,\n\tADXL372_BW_400HZ,\n\tADXL372_BW_800HZ,\n\tADXL372_BW_1600HZ,\n\tADXL372_BW_3200HZ,\n};\n\nstatic const unsigned int adxl372_th_reg_high_addr[3] = {\n\t[ADXL372_ACTIVITY] = ADXL372_X_THRESH_ACT_H,\n\t[ADXL372_ACTIVITY2] = ADXL372_X_THRESH_ACT2_H,\n\t[ADXL372_INACTIVITY] = ADXL372_X_THRESH_INACT_H,\n};\n\nenum adxl372_fifo_format {\n\tADXL372_XYZ_FIFO,\n\tADXL372_X_FIFO,\n\tADXL372_Y_FIFO,\n\tADXL372_XY_FIFO,\n\tADXL372_Z_FIFO,\n\tADXL372_XZ_FIFO,\n\tADXL372_YZ_FIFO,\n\tADXL372_XYZ_PEAK_FIFO,\n};\n\nenum adxl372_fifo_mode {\n\tADXL372_FIFO_BYPASSED,\n\tADXL372_FIFO_STREAMED,\n\tADXL372_FIFO_TRIGGERED,\n\tADXL372_FIFO_OLD_SAVED\n};\n\nstatic const int adxl372_samp_freq_tbl[5] = {\n\t400, 800, 1600, 3200, 6400,\n};\n\nstatic const int adxl372_bw_freq_tbl[5] = {\n\t200, 400, 800, 1600, 3200,\n};\n\nstruct adxl372_axis_lookup {\n\tunsigned int bits;\n\tenum adxl372_fifo_format fifo_format;\n};\n\nstatic const struct adxl372_axis_lookup adxl372_axis_lookup_table[] = {\n\t{ BIT(0), ADXL372_X_FIFO },\n\t{ BIT(1), ADXL372_Y_FIFO },\n\t{ BIT(2), ADXL372_Z_FIFO },\n\t{ BIT(0) | BIT(1), ADXL372_XY_FIFO },\n\t{ BIT(0) | BIT(2), ADXL372_XZ_FIFO },\n\t{ BIT(1) | BIT(2), ADXL372_YZ_FIFO },\n\t{ BIT(0) | BIT(1) | BIT(2), ADXL372_XYZ_FIFO },\n};\n\nstatic const struct iio_event_spec adxl372_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t\t.mask_shared_by_all = BIT(IIO_EV_INFO_PERIOD) | BIT(IIO_EV_INFO_ENABLE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t\t.mask_shared_by_all = BIT(IIO_EV_INFO_PERIOD) | BIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\n#define ADXL372_ACCEL_CHANNEL(index, reg, axis) {\t\t\t\\\n\t.type = IIO_ACCEL,\t\t\t\t\t\t\\\n\t.address = reg,\t\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##axis,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\t\\\n\t\t\t\t    BIT(IIO_CHAN_INFO_SAMP_FREQ) |\t\\\n\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\t\\\n\t.scan_index = index,\t\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\t\\\n\t\t.realbits = 12,\t\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\t\\\n\t\t.shift = 4,\t\t\t\t\t\t\\\n\t\t.endianness = IIO_BE,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.event_spec = adxl372_events,\t\t\t\t\t\\\n\t.num_event_specs = ARRAY_SIZE(adxl372_events)\t\t\t\\\n}\n\nstatic const struct iio_chan_spec adxl372_channels[] = {\n\tADXL372_ACCEL_CHANNEL(0, ADXL372_X_DATA_H, X),\n\tADXL372_ACCEL_CHANNEL(1, ADXL372_Y_DATA_H, Y),\n\tADXL372_ACCEL_CHANNEL(2, ADXL372_Z_DATA_H, Z),\n};\n\nstruct adxl372_state {\n\tint\t\t\t\tirq;\n\tstruct device\t\t\t*dev;\n\tstruct regmap\t\t\t*regmap;\n\tstruct iio_trigger\t\t*dready_trig;\n\tstruct iio_trigger\t\t*peak_datardy_trig;\n\tenum adxl372_fifo_mode\t\tfifo_mode;\n\tenum adxl372_fifo_format\tfifo_format;\n\tunsigned int\t\t\tfifo_axis_mask;\n\tenum adxl372_op_mode\t\top_mode;\n\tenum adxl372_act_proc_mode\tact_proc_mode;\n\tenum adxl372_odr\t\todr;\n\tenum adxl372_bandwidth\t\tbw;\n\tu32\t\t\t\tact_time_ms;\n\tu32\t\t\t\tinact_time_ms;\n\tu8\t\t\t\tfifo_set_size;\n\tunsigned long\t\t\tint1_bitmask;\n\tunsigned long\t\t\tint2_bitmask;\n\tu16\t\t\t\twatermark;\n\t__be16\t\t\t\tfifo_buf[ADXL372_FIFO_SIZE];\n\tbool\t\t\t\tpeak_fifo_mode_en;\n\tstruct mutex\t\t\tthreshold_m;  \n};\n\nstatic const unsigned long adxl372_channel_masks[] = {\n\tBIT(0), BIT(1), BIT(2),\n\tBIT(0) | BIT(1),\n\tBIT(0) | BIT(2),\n\tBIT(1) | BIT(2),\n\tBIT(0) | BIT(1) | BIT(2),\n\t0\n};\n\nstatic ssize_t adxl372_read_threshold_value(struct iio_dev *indio_dev, unsigned int addr,\n\t\t\t\t\t    u16 *threshold)\n{\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\t__be16 raw_regval;\n\tu16 regval;\n\tint ret;\n\n\tret = regmap_bulk_read(st->regmap, addr, &raw_regval, sizeof(raw_regval));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregval = be16_to_cpu(raw_regval);\n\tregval >>= 5;\n\n\t*threshold = regval;\n\n\treturn 0;\n}\n\nstatic ssize_t adxl372_write_threshold_value(struct iio_dev *indio_dev, unsigned int addr,\n\t\t\t\t\t     u16 threshold)\n{\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->threshold_m);\n\tret = regmap_write(st->regmap, addr, ADXL372_THRESH_VAL_H_SEL(threshold));\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = regmap_update_bits(st->regmap, addr + 1, GENMASK(7, 5),\n\t\t\t\t ADXL372_THRESH_VAL_L_SEL(threshold) << 5);\n\nunlock:\n\tmutex_unlock(&st->threshold_m);\n\n\treturn ret;\n}\n\nstatic int adxl372_read_axis(struct adxl372_state *st, u8 addr)\n{\n\t__be16 regval;\n\tint ret;\n\n\tret = regmap_bulk_read(st->regmap, addr, &regval, sizeof(regval));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn be16_to_cpu(regval);\n}\n\nstatic int adxl372_set_op_mode(struct adxl372_state *st,\n\t\t\t       enum adxl372_op_mode op_mode)\n{\n\tint ret;\n\n\tret = regmap_update_bits(st->regmap, ADXL372_POWER_CTL,\n\t\t\t\t ADXL372_POWER_CTL_MODE_MSK,\n\t\t\t\t ADXL372_POWER_CTL_MODE(op_mode));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->op_mode = op_mode;\n\n\treturn ret;\n}\n\nstatic int adxl372_set_odr(struct adxl372_state *st,\n\t\t\t   enum adxl372_odr odr)\n{\n\tint ret;\n\n\tret = regmap_update_bits(st->regmap, ADXL372_TIMING,\n\t\t\t\t ADXL372_TIMING_ODR_MSK,\n\t\t\t\t ADXL372_TIMING_ODR_MODE(odr));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->odr = odr;\n\n\treturn ret;\n}\n\nstatic int adxl372_find_closest_match(const int *array,\n\t\t\t\t      unsigned int size, int val)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (val <= array[i])\n\t\t\treturn i;\n\t}\n\n\treturn size - 1;\n}\n\nstatic int adxl372_set_bandwidth(struct adxl372_state *st,\n\t\t\t\t enum adxl372_bandwidth bw)\n{\n\tint ret;\n\n\tret = regmap_update_bits(st->regmap, ADXL372_MEASURE,\n\t\t\t\t ADXL372_MEASURE_BANDWIDTH_MSK,\n\t\t\t\t ADXL372_MEASURE_BANDWIDTH_MODE(bw));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->bw = bw;\n\n\treturn ret;\n}\n\nstatic int adxl372_set_act_proc_mode(struct adxl372_state *st,\n\t\t\t\t     enum adxl372_act_proc_mode mode)\n{\n\tint ret;\n\n\tret = regmap_update_bits(st->regmap,\n\t\t\t\t ADXL372_MEASURE,\n\t\t\t\t ADXL372_MEASURE_LINKLOOP_MSK,\n\t\t\t\t ADXL372_MEASURE_LINKLOOP_MODE(mode));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->act_proc_mode = mode;\n\n\treturn ret;\n}\n\nstatic int adxl372_set_activity_threshold(struct adxl372_state *st,\n\t\t\t\t\t  enum adxl372_th_activity act,\n\t\t\t\t\t  bool ref_en, bool enable,\n\t\t\t\t\t  unsigned int threshold)\n{\n\tunsigned char buf[6];\n\tunsigned char th_reg_high_val, th_reg_low_val, th_reg_high_addr;\n\n\t \n\tth_reg_high_val = (threshold / 100) >> 3;\n\tth_reg_low_val = ((threshold / 100) << 5) | (ref_en << 1) | enable;\n\tth_reg_high_addr = adxl372_th_reg_high_addr[act];\n\n\tbuf[0] = th_reg_high_val;\n\tbuf[1] = th_reg_low_val;\n\tbuf[2] = th_reg_high_val;\n\tbuf[3] = th_reg_low_val;\n\tbuf[4] = th_reg_high_val;\n\tbuf[5] = th_reg_low_val;\n\n\treturn regmap_bulk_write(st->regmap, th_reg_high_addr,\n\t\t\t\t buf, ARRAY_SIZE(buf));\n}\n\nstatic int adxl372_set_activity_time_ms(struct adxl372_state *st,\n\t\t\t\t\tunsigned int act_time_ms)\n{\n\tunsigned int reg_val, scale_factor;\n\tint ret;\n\n\t \n\tif (st->odr == ADXL372_ODR_6400HZ)\n\t\tscale_factor = 3300;\n\telse\n\t\tscale_factor = 6600;\n\n\treg_val = DIV_ROUND_CLOSEST(act_time_ms * 1000, scale_factor);\n\n\t \n\tif (reg_val > 0xFF)\n\t\treg_val = 0xFF;\n\n\tret = regmap_write(st->regmap, ADXL372_TIME_ACT, reg_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->act_time_ms = act_time_ms;\n\n\treturn ret;\n}\n\nstatic int adxl372_set_inactivity_time_ms(struct adxl372_state *st,\n\t\t\t\t\t  unsigned int inact_time_ms)\n{\n\tunsigned int reg_val_h, reg_val_l, res, scale_factor;\n\tint ret;\n\n\t \n\tif (st->odr == ADXL372_ODR_6400HZ)\n\t\tscale_factor = 13;\n\telse\n\t\tscale_factor = 26;\n\n\tres = DIV_ROUND_CLOSEST(inact_time_ms, scale_factor);\n\treg_val_h = (res >> 8) & 0xFF;\n\treg_val_l = res & 0xFF;\n\n\tret = regmap_write(st->regmap, ADXL372_TIME_INACT_H, reg_val_h);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(st->regmap, ADXL372_TIME_INACT_L, reg_val_l);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->inact_time_ms = inact_time_ms;\n\n\treturn ret;\n}\n\nstatic int adxl372_set_interrupts(struct adxl372_state *st,\n\t\t\t\t  unsigned long int1_bitmask,\n\t\t\t\t  unsigned long int2_bitmask)\n{\n\tint ret;\n\n\tret = regmap_write(st->regmap, ADXL372_INT1_MAP, int1_bitmask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_write(st->regmap, ADXL372_INT2_MAP, int2_bitmask);\n}\n\nstatic int adxl372_configure_fifo(struct adxl372_state *st)\n{\n\tunsigned int fifo_samples, fifo_ctl;\n\tint ret;\n\n\t \n\tret = adxl372_set_op_mode(st, ADXL372_STANDBY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfifo_samples = (st->watermark * st->fifo_set_size);\n\tfifo_ctl = ADXL372_FIFO_CTL_FORMAT_MODE(st->fifo_format) |\n\t\t   ADXL372_FIFO_CTL_MODE_MODE(st->fifo_mode) |\n\t\t   ADXL372_FIFO_CTL_SAMPLES_MODE(fifo_samples);\n\n\tret = regmap_write(st->regmap,\n\t\t\t   ADXL372_FIFO_SAMPLES, fifo_samples & 0xFF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(st->regmap, ADXL372_FIFO_CTL, fifo_ctl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn adxl372_set_op_mode(st, ADXL372_FULL_BW_MEASUREMENT);\n}\n\nstatic int adxl372_get_status(struct adxl372_state *st,\n\t\t\t      u8 *status1, u8 *status2,\n\t\t\t      u16 *fifo_entries)\n{\n\t__be32 buf;\n\tu32 val;\n\tint ret;\n\n\t \n\tret = regmap_bulk_read(st->regmap, ADXL372_STATUS_1,\n\t\t\t       &buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = be32_to_cpu(buf);\n\n\t*status1 = (val >> 24) & 0x0F;\n\t*status2 = (val >> 16) & 0x0F;\n\t \n\t*fifo_entries = val & 0x3FF;\n\n\treturn ret;\n}\n\nstatic void adxl372_arrange_axis_data(struct adxl372_state *st, __be16 *sample)\n{\n\t__be16\taxis_sample[3];\n\tint i = 0;\n\n\tmemset(axis_sample, 0, 3 * sizeof(__be16));\n\tif (ADXL372_X_AXIS_EN(st->fifo_axis_mask))\n\t\taxis_sample[i++] = sample[0];\n\tif (ADXL372_Y_AXIS_EN(st->fifo_axis_mask))\n\t\taxis_sample[i++] = sample[1];\n\tif (ADXL372_Z_AXIS_EN(st->fifo_axis_mask))\n\t\taxis_sample[i++] = sample[2];\n\n\tmemcpy(sample, axis_sample, 3 * sizeof(__be16));\n}\n\nstatic void adxl372_push_event(struct iio_dev *indio_dev, s64 timestamp, u8 status2)\n{\n\tunsigned int ev_dir = IIO_EV_DIR_NONE;\n\n\tif (ADXL372_STATUS_2_ACT(status2))\n\t\tev_dir = IIO_EV_DIR_RISING;\n\n\tif (ADXL372_STATUS_2_INACT(status2))\n\t\tev_dir = IIO_EV_DIR_FALLING;\n\n\tif (ev_dir != IIO_EV_DIR_NONE)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL, 0, IIO_MOD_X_OR_Y_OR_Z,\n\t\t\t\t\t\t  IIO_EV_TYPE_THRESH, ev_dir),\n\t\t\t       timestamp);\n}\n\nstatic irqreturn_t adxl372_trigger_handler(int irq, void  *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\tu8 status1, status2;\n\tu16 fifo_entries;\n\tint i, ret;\n\n\tret = adxl372_get_status(st, &status1, &status2, &fifo_entries);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tadxl372_push_event(indio_dev, iio_get_time_ns(indio_dev), status2);\n\n\tif (st->fifo_mode != ADXL372_FIFO_BYPASSED &&\n\t    ADXL372_STATUS_1_FIFO_FULL(status1)) {\n\t\t \n\t\tfifo_entries -= st->fifo_set_size;\n\n\t\t \n\t\tret = regmap_noinc_read(st->regmap, ADXL372_FIFO_DATA,\n\t\t\t\t\tst->fifo_buf,\n\t\t\t\t\tfifo_entries * sizeof(u16));\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\t \n\t\tfor (i = 0; i < fifo_entries; i += st->fifo_set_size) {\n\t\t\t \n\t\t\tif (st->peak_fifo_mode_en)\n\t\t\t\tadxl372_arrange_axis_data(st, &st->fifo_buf[i]);\n\t\t\tiio_push_to_buffers(indio_dev, &st->fifo_buf[i]);\n\t\t}\n\t}\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\nstatic int adxl372_setup(struct adxl372_state *st)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(st->regmap, ADXL372_DEVID, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (regval != ADXL372_DEVID_VAL) {\n\t\tdev_err(st->dev, \"Invalid chip id %x\\n\", regval);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = regmap_write(st->regmap, ADXL372_RESET, ADXL372_RESET_CODE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adxl372_set_op_mode(st, ADXL372_STANDBY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = adxl372_set_activity_threshold(st, ADXL372_ACTIVITY,\n\t\t\t\t\t     true, true, 1000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = adxl372_set_activity_threshold(st, ADXL372_INACTIVITY,\n\t\t\t\t\t     true, true, 100);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = adxl372_set_act_proc_mode(st, ADXL372_LOOPED);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adxl372_set_odr(st, ADXL372_ODR_6400HZ);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adxl372_set_bandwidth(st, ADXL372_BW_3200HZ);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = adxl372_set_activity_time_ms(st, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = adxl372_set_inactivity_time_ms(st, 10000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn adxl372_set_op_mode(st, ADXL372_FULL_BW_MEASUREMENT);\n}\n\nstatic int adxl372_reg_access(struct iio_dev *indio_dev,\n\t\t\t      unsigned int reg,\n\t\t\t      unsigned int writeval,\n\t\t\t      unsigned int *readval)\n{\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\n\tif (readval)\n\t\treturn regmap_read(st->regmap, reg, readval);\n\telse\n\t\treturn regmap_write(st->regmap, reg, writeval);\n}\n\nstatic int adxl372_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long info)\n{\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adxl372_read_axis(st, chan->address);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = sign_extend32(ret >> chan->scan_type.shift,\n\t\t\t\t     chan->scan_type.realbits - 1);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = ADXL372_USCALE;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = adxl372_samp_freq_tbl[st->odr];\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\t*val = adxl372_bw_freq_tbl[st->bw];\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int adxl372_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long info)\n{\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\tint odr_index, bw_index, ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\todr_index = adxl372_find_closest_match(adxl372_samp_freq_tbl,\n\t\t\t\t\tARRAY_SIZE(adxl372_samp_freq_tbl),\n\t\t\t\t\tval);\n\t\tret = adxl372_set_odr(st, odr_index);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tret = adxl372_set_activity_time_ms(st, st->act_time_ms);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tret = adxl372_set_inactivity_time_ms(st, st->inact_time_ms);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tif (st->bw > odr_index)\n\t\t\tret = adxl372_set_bandwidth(st, odr_index);\n\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tbw_index = adxl372_find_closest_match(adxl372_bw_freq_tbl,\n\t\t\t\t\tARRAY_SIZE(adxl372_bw_freq_tbl),\n\t\t\t\t\tval);\n\t\treturn adxl372_set_bandwidth(st, bw_index);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxl372_read_event_value(struct iio_dev *indio_dev, const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type, enum iio_event_direction dir,\n\t\t\t\t    enum iio_event_info info, int *val, int *val2)\n{\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\tunsigned int addr;\n\tu16 raw_value;\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\taddr = ADXL372_X_THRESH_ACT_H + 2 * chan->scan_index;\n\t\t\tret = adxl372_read_threshold_value(indio_dev, addr, &raw_value);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = raw_value * ADXL372_USCALE;\n\t\t\t*val2 = 1000000;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\taddr = ADXL372_X_THRESH_INACT_H + 2 * chan->scan_index;\n\t\t\tret =  adxl372_read_threshold_value(indio_dev, addr, &raw_value);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = raw_value * ADXL372_USCALE;\n\t\t\t*val2 = 1000000;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_EV_INFO_PERIOD:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\t*val = st->act_time_ms;\n\t\t\t*val2 = 1000;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\t*val = st->inact_time_ms;\n\t\t\t*val2 = 1000;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxl372_write_event_value(struct iio_dev *indio_dev, const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type, enum iio_event_direction dir,\n\t\t\t\t     enum iio_event_info info, int val, int val2)\n{\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\tunsigned int val_ms;\n\tunsigned int addr;\n\tu16 raw_val;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\traw_val = DIV_ROUND_UP(val * 1000000, ADXL372_USCALE);\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\taddr = ADXL372_X_THRESH_ACT_H + 2 * chan->scan_index;\n\t\t\treturn adxl372_write_threshold_value(indio_dev, addr, raw_val);\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\taddr = ADXL372_X_THRESH_INACT_H + 2 * chan->scan_index;\n\t\t\treturn adxl372_write_threshold_value(indio_dev, addr, raw_val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_EV_INFO_PERIOD:\n\t\tval_ms = val * 1000 + DIV_ROUND_UP(val2, 1000);\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\treturn adxl372_set_activity_time_ms(st, val_ms);\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\treturn adxl372_set_inactivity_time_ms(st, val_ms);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxl372_read_event_config(struct iio_dev *indio_dev, const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type, enum iio_event_direction dir)\n{\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\treturn FIELD_GET(ADXL372_INT1_MAP_ACT_MSK, st->int1_bitmask);\n\tcase IIO_EV_DIR_FALLING:\n\t\treturn FIELD_GET(ADXL372_INT1_MAP_INACT_MSK, st->int1_bitmask);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxl372_write_event_config(struct iio_dev *indio_dev, const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type, enum iio_event_direction dir,\n\t\t\t\t      int state)\n{\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\tset_mask_bits(&st->int1_bitmask, ADXL372_INT1_MAP_ACT_MSK,\n\t\t\t      ADXL372_INT1_MAP_ACT_MODE(state));\n\t\tbreak;\n\tcase IIO_EV_DIR_FALLING:\n\t\tset_mask_bits(&st->int1_bitmask, ADXL372_INT1_MAP_INACT_MSK,\n\t\t\t      ADXL372_INT1_MAP_INACT_MODE(state));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn adxl372_set_interrupts(st, st->int1_bitmask, 0);\n}\n\nstatic ssize_t adxl372_show_filter_freq_avail(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\tint i;\n\tsize_t len = 0;\n\n\tfor (i = 0; i <= st->odr; i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t \"%d \", adxl372_bw_freq_tbl[i]);\n\n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic ssize_t adxl372_get_fifo_enabled(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\n\treturn sprintf(buf, \"%d\\n\", st->fifo_mode);\n}\n\nstatic ssize_t adxl372_get_fifo_watermark(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\n\treturn sprintf(buf, \"%d\\n\", st->watermark);\n}\n\nIIO_STATIC_CONST_DEVICE_ATTR(hwfifo_watermark_min, \"1\");\nIIO_STATIC_CONST_DEVICE_ATTR(hwfifo_watermark_max,\n\t\t\t     __stringify(ADXL372_FIFO_SIZE));\nstatic IIO_DEVICE_ATTR(hwfifo_watermark, 0444,\n\t\t       adxl372_get_fifo_watermark, NULL, 0);\nstatic IIO_DEVICE_ATTR(hwfifo_enabled, 0444,\n\t\t       adxl372_get_fifo_enabled, NULL, 0);\n\nstatic const struct iio_dev_attr *adxl372_fifo_attributes[] = {\n\t&iio_dev_attr_hwfifo_watermark_min,\n\t&iio_dev_attr_hwfifo_watermark_max,\n\t&iio_dev_attr_hwfifo_watermark,\n\t&iio_dev_attr_hwfifo_enabled,\n\tNULL,\n};\n\nstatic int adxl372_set_watermark(struct iio_dev *indio_dev, unsigned int val)\n{\n\tstruct adxl372_state *st  = iio_priv(indio_dev);\n\n\tif (val > ADXL372_FIFO_SIZE)\n\t\tval = ADXL372_FIFO_SIZE;\n\n\tst->watermark = val;\n\n\treturn 0;\n}\n\nstatic int adxl372_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\tunsigned int mask;\n\tint i, ret;\n\n\tst->int1_bitmask |= ADXL372_INT1_MAP_FIFO_FULL_MSK;\n\tret = adxl372_set_interrupts(st, st->int1_bitmask, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmask = *indio_dev->active_scan_mask;\n\n\tfor (i = 0; i < ARRAY_SIZE(adxl372_axis_lookup_table); i++) {\n\t\tif (mask == adxl372_axis_lookup_table[i].bits)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(adxl372_axis_lookup_table))\n\t\treturn -EINVAL;\n\n\tst->fifo_format = adxl372_axis_lookup_table[i].fifo_format;\n\tst->fifo_axis_mask = adxl372_axis_lookup_table[i].bits;\n\tst->fifo_set_size = bitmap_weight(indio_dev->active_scan_mask,\n\t\t\t\t\t  indio_dev->masklength);\n\n\t \n\tif (st->peak_fifo_mode_en) {\n\t\tst->fifo_set_size = 3;\n\t\tst->fifo_format = ADXL372_XYZ_PEAK_FIFO;\n\t}\n\n\t \n\tif ((st->watermark * st->fifo_set_size) > ADXL372_FIFO_SIZE)\n\t\tst->watermark = (ADXL372_FIFO_SIZE  / st->fifo_set_size);\n\n\tst->fifo_mode = ADXL372_FIFO_STREAMED;\n\n\tret = adxl372_configure_fifo(st);\n\tif (ret < 0) {\n\t\tst->fifo_mode = ADXL372_FIFO_BYPASSED;\n\t\tst->int1_bitmask &= ~ADXL372_INT1_MAP_FIFO_FULL_MSK;\n\t\tadxl372_set_interrupts(st, st->int1_bitmask, 0);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int adxl372_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\n\tst->int1_bitmask &= ~ADXL372_INT1_MAP_FIFO_FULL_MSK;\n\tadxl372_set_interrupts(st, st->int1_bitmask, 0);\n\tst->fifo_mode = ADXL372_FIFO_BYPASSED;\n\tadxl372_configure_fifo(st);\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops adxl372_buffer_ops = {\n\t.postenable = adxl372_buffer_postenable,\n\t.predisable = adxl372_buffer_predisable,\n};\n\nstatic int adxl372_dready_trig_set_state(struct iio_trigger *trig,\n\t\t\t\t\t bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\n\tif (state)\n\t\tst->int1_bitmask |= ADXL372_INT1_MAP_FIFO_FULL_MSK;\n\n\treturn adxl372_set_interrupts(st, st->int1_bitmask, 0);\n}\n\nstatic int adxl372_validate_trigger(struct iio_dev *indio_dev,\n\t\t\t\t    struct iio_trigger *trig)\n{\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\n\tif (st->dready_trig != trig && st->peak_datardy_trig != trig)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct iio_trigger_ops adxl372_trigger_ops = {\n\t.validate_device = &iio_trigger_validate_own_device,\n\t.set_trigger_state = adxl372_dready_trig_set_state,\n};\n\nstatic int adxl372_peak_dready_trig_set_state(struct iio_trigger *trig,\n\t\t\t\t\t      bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct adxl372_state *st = iio_priv(indio_dev);\n\n\tif (state)\n\t\tst->int1_bitmask |= ADXL372_INT1_MAP_FIFO_FULL_MSK;\n\n\tst->peak_fifo_mode_en = state;\n\n\treturn adxl372_set_interrupts(st, st->int1_bitmask, 0);\n}\n\nstatic const struct iio_trigger_ops adxl372_peak_data_trigger_ops = {\n\t.validate_device = &iio_trigger_validate_own_device,\n\t.set_trigger_state = adxl372_peak_dready_trig_set_state,\n};\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\"400 800 1600 3200 6400\");\nstatic IIO_DEVICE_ATTR(in_accel_filter_low_pass_3db_frequency_available,\n\t\t       0444, adxl372_show_filter_freq_avail, NULL, 0);\n\nstatic struct attribute *adxl372_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_in_accel_filter_low_pass_3db_frequency_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group adxl372_attrs_group = {\n\t.attrs = adxl372_attributes,\n};\n\nstatic const struct iio_info adxl372_info = {\n\t.validate_trigger = &adxl372_validate_trigger,\n\t.attrs = &adxl372_attrs_group,\n\t.read_raw = adxl372_read_raw,\n\t.write_raw = adxl372_write_raw,\n\t.read_event_config = adxl372_read_event_config,\n\t.write_event_config = adxl372_write_event_config,\n\t.read_event_value = adxl372_read_event_value,\n\t.write_event_value = adxl372_write_event_value,\n\t.debugfs_reg_access = &adxl372_reg_access,\n\t.hwfifo_set_watermark = adxl372_set_watermark,\n};\n\nbool adxl372_readable_noinc_reg(struct device *dev, unsigned int reg)\n{\n\treturn (reg == ADXL372_FIFO_DATA);\n}\nEXPORT_SYMBOL_NS_GPL(adxl372_readable_noinc_reg, IIO_ADXL372);\n\nint adxl372_probe(struct device *dev, struct regmap *regmap,\n\t\t  int irq, const char *name)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct adxl372_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tdev_set_drvdata(dev, indio_dev);\n\n\tst->dev = dev;\n\tst->regmap = regmap;\n\tst->irq = irq;\n\n\tmutex_init(&st->threshold_m);\n\n\tindio_dev->channels = adxl372_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adxl372_channels);\n\tindio_dev->available_scan_masks = adxl372_channel_masks;\n\tindio_dev->name = name;\n\tindio_dev->info = &adxl372_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE | INDIO_BUFFER_SOFTWARE;\n\n\tret = adxl372_setup(st);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"ADXL372 setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_iio_triggered_buffer_setup_ext(dev,\n\t\t\t\t\t\t  indio_dev, NULL,\n\t\t\t\t\t\t  adxl372_trigger_handler,\n\t\t\t\t\t\t  IIO_BUFFER_DIRECTION_IN,\n\t\t\t\t\t\t  &adxl372_buffer_ops,\n\t\t\t\t\t\t  adxl372_fifo_attributes);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (st->irq) {\n\t\tst->dready_trig = devm_iio_trigger_alloc(dev,\n\t\t\t\t\t\t\t \"%s-dev%d\",\n\t\t\t\t\t\t\t indio_dev->name,\n\t\t\t\t\t\t\t iio_device_id(indio_dev));\n\t\tif (st->dready_trig == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tst->peak_datardy_trig = devm_iio_trigger_alloc(dev,\n\t\t\t\t\t\t\t       \"%s-dev%d-peak\",\n\t\t\t\t\t\t\t       indio_dev->name,\n\t\t\t\t\t\t\t       iio_device_id(indio_dev));\n\t\tif (!st->peak_datardy_trig)\n\t\t\treturn -ENOMEM;\n\n\t\tst->dready_trig->ops = &adxl372_trigger_ops;\n\t\tst->peak_datardy_trig->ops = &adxl372_peak_data_trigger_ops;\n\t\tiio_trigger_set_drvdata(st->dready_trig, indio_dev);\n\t\tiio_trigger_set_drvdata(st->peak_datardy_trig, indio_dev);\n\t\tret = devm_iio_trigger_register(dev, st->dready_trig);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = devm_iio_trigger_register(dev, st->peak_datardy_trig);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tindio_dev->trig = iio_trigger_get(st->dready_trig);\n\n\t\tret = devm_request_threaded_irq(dev, st->irq,\n\t\t\t\t\tiio_trigger_generic_data_rdy_poll,\n\t\t\t\t\tNULL,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tindio_dev->name, st->dready_trig);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(adxl372_probe, IIO_ADXL372);\n\nMODULE_AUTHOR(\"Stefan Popa <stefan.popa@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADXL372 3-axis accelerometer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}