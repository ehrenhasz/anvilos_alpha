{
  "module_name": "kionix-kx022a.c",
  "hash_id": "0c44c90a4cc35505836866b2f8a78a41614ee87862a3f4af203118f87e540f30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/kionix-kx022a.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/string_helpers.h>\n#include <linux/units.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#include \"kionix-kx022a.h\"\n\n \n#define KX022A_FIFO_LENGTH\t\t\t43\n#define KX022A_FIFO_FULL_VALUE\t\t\t255\n#define KX022A_SOFT_RESET_WAIT_TIME_US\t\t(5 * USEC_PER_MSEC)\n#define KX022A_SOFT_RESET_TOTAL_WAIT_TIME_US\t(500 * USEC_PER_MSEC)\n\n \n#define KX022A_FIFO_SAMPLES_SIZE_BYTES\t\t6\n#define KX022A_FIFO_MAX_BYTES\t\t\t\t\t\\\n\t(KX022A_FIFO_LENGTH * KX022A_FIFO_SAMPLES_SIZE_BYTES)\n\nenum {\n\tKX022A_STATE_SAMPLE,\n\tKX022A_STATE_FIFO,\n};\n\n \nstatic const struct regmap_range kx022a_volatile_ranges[] = {\n\t{\n\t\t.range_min = KX022A_REG_XHP_L,\n\t\t.range_max = KX022A_REG_COTR,\n\t}, {\n\t\t.range_min = KX022A_REG_TSCP,\n\t\t.range_max = KX022A_REG_INT_REL,\n\t}, {\n\t\t \n\t\t.range_min = KX022A_REG_CNTL2,\n\t\t.range_max = KX022A_REG_CNTL2,\n\t}, {\n\t\t.range_min = KX022A_REG_BUF_STATUS_1,\n\t\t.range_max = KX022A_REG_BUF_READ,\n\t},\n};\n\nstatic const struct regmap_access_table kx022a_volatile_regs = {\n\t.yes_ranges = &kx022a_volatile_ranges[0],\n\t.n_yes_ranges = ARRAY_SIZE(kx022a_volatile_ranges),\n};\n\nstatic const struct regmap_range kx022a_precious_ranges[] = {\n\t{\n\t\t.range_min = KX022A_REG_INT_REL,\n\t\t.range_max = KX022A_REG_INT_REL,\n\t},\n};\n\nstatic const struct regmap_access_table kx022a_precious_regs = {\n\t.yes_ranges = &kx022a_precious_ranges[0],\n\t.n_yes_ranges = ARRAY_SIZE(kx022a_precious_ranges),\n};\n\n \nstatic const struct regmap_range kx022a_read_only_ranges[] = {\n\t{\n\t\t.range_min = KX022A_REG_XHP_L,\n\t\t.range_max = KX022A_REG_INT_REL,\n\t}, {\n\t\t.range_min = KX022A_REG_BUF_STATUS_1,\n\t\t.range_max = KX022A_REG_BUF_STATUS_2,\n\t}, {\n\t\t.range_min = KX022A_REG_BUF_READ,\n\t\t.range_max = KX022A_REG_BUF_READ,\n\t},\n};\n\nstatic const struct regmap_access_table kx022a_ro_regs = {\n\t.no_ranges = &kx022a_read_only_ranges[0],\n\t.n_no_ranges = ARRAY_SIZE(kx022a_read_only_ranges),\n};\n\nstatic const struct regmap_range kx022a_write_only_ranges[] = {\n\t{\n\t\t.range_min = KX022A_REG_BTS_WUF_TH,\n\t\t.range_max = KX022A_REG_BTS_WUF_TH,\n\t}, {\n\t\t.range_min = KX022A_REG_MAN_WAKE,\n\t\t.range_max = KX022A_REG_MAN_WAKE,\n\t}, {\n\t\t.range_min = KX022A_REG_SELF_TEST,\n\t\t.range_max = KX022A_REG_SELF_TEST,\n\t}, {\n\t\t.range_min = KX022A_REG_BUF_CLEAR,\n\t\t.range_max = KX022A_REG_BUF_CLEAR,\n\t},\n};\n\nstatic const struct regmap_access_table kx022a_wo_regs = {\n\t.no_ranges = &kx022a_write_only_ranges[0],\n\t.n_no_ranges = ARRAY_SIZE(kx022a_write_only_ranges),\n};\n\nstatic const struct regmap_range kx022a_noinc_read_ranges[] = {\n\t{\n\t\t.range_min = KX022A_REG_BUF_READ,\n\t\t.range_max = KX022A_REG_BUF_READ,\n\t},\n};\n\nstatic const struct regmap_access_table kx022a_nir_regs = {\n\t.yes_ranges = &kx022a_noinc_read_ranges[0],\n\t.n_yes_ranges = ARRAY_SIZE(kx022a_noinc_read_ranges),\n};\n\nconst struct regmap_config kx022a_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.volatile_table = &kx022a_volatile_regs,\n\t.rd_table = &kx022a_wo_regs,\n\t.wr_table = &kx022a_ro_regs,\n\t.rd_noinc_table = &kx022a_nir_regs,\n\t.precious_table = &kx022a_precious_regs,\n\t.max_register = KX022A_MAX_REGISTER,\n\t.cache_type = REGCACHE_RBTREE,\n};\nEXPORT_SYMBOL_NS_GPL(kx022a_regmap, IIO_KX022A);\n\nstruct kx022a_data {\n\tstruct regmap *regmap;\n\tstruct iio_trigger *trig;\n\tstruct device *dev;\n\tstruct iio_mount_matrix orientation;\n\tint64_t timestamp, old_timestamp;\n\n\tint irq;\n\tint inc_reg;\n\tint ien_reg;\n\n\tunsigned int state;\n\tunsigned int odr_ns;\n\n\tbool trigger_enabled;\n\t \n\tstruct mutex mutex;\n\tu8 watermark;\n\n\t \n\t__le16 buffer[8] __aligned(IIO_DMA_MINALIGN);\n\tstruct {\n\t\t__le16 channels[3];\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\nstatic const struct iio_mount_matrix *\nkx022a_get_mount_matrix(const struct iio_dev *idev,\n\t\t\tconst struct iio_chan_spec *chan)\n{\n\tstruct kx022a_data *data = iio_priv(idev);\n\n\treturn &data->orientation;\n}\n\nenum {\n\tAXIS_X,\n\tAXIS_Y,\n\tAXIS_Z,\n\tAXIS_MAX\n};\n\nstatic const unsigned long kx022a_scan_masks[] = {\n\tBIT(AXIS_X) | BIT(AXIS_Y) | BIT(AXIS_Z), 0\n};\n\nstatic const struct iio_chan_spec_ext_info kx022a_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_TYPE, kx022a_get_mount_matrix),\n\t{ }\n};\n\n#define KX022A_ACCEL_CHAN(axis, index)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.type = IIO_ACCEL,\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##axis,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n\t.info_mask_shared_by_type_available =\t\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n\t.ext_info = kx022a_ext_info,\t\t\t\t\\\n\t.address = KX022A_REG_##axis##OUT_L,\t\t\t\\\n\t.scan_index = index,\t\t\t\t\t\\\n\t.scan_type = {                                          \\\n\t\t.sign = 's',\t\t\t\t\t\\\n\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.endianness = IIO_LE,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec kx022a_channels[] = {\n\tKX022A_ACCEL_CHAN(X, 0),\n\tKX022A_ACCEL_CHAN(Y, 1),\n\tKX022A_ACCEL_CHAN(Z, 2),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\n \nstatic const int kx022a_accel_samp_freq_table[][2] = {\n\t{ 0, 780000 },\n\t{ 1, 563000 },\n\t{ 3, 125000 },\n\t{ 6, 250000 },\n\t{ 12, 500000 },\n\t{ 25, 0 },\n\t{ 50, 0 },\n\t{ 100, 0 },\n\t{ 200, 0 },\n};\n\nstatic const unsigned int kx022a_odrs[] = {\n\t1282051282,\n\t639795266,\n\t320 * MEGA,\n\t160 * MEGA,\n\t80 * MEGA,\n\t40 * MEGA,\n\t20 * MEGA,\n\t10 * MEGA,\n\t5 * MEGA,\n};\n\n \nstatic const int kx022a_scale_table[][2] = {\n\t{ 0, 598550 },\n\t{ 0, 1197101 },\n\t{ 0, 2394202 },\n\t{ 0, 4788403 },\n};\n\nstatic int kx022a_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type, int *length,\n\t\t\t     long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*vals = (const int *)kx022a_accel_samp_freq_table;\n\t\t*length = ARRAY_SIZE(kx022a_accel_samp_freq_table) *\n\t\t\t  ARRAY_SIZE(kx022a_accel_samp_freq_table[0]);\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*vals = (const int *)kx022a_scale_table;\n\t\t*length = ARRAY_SIZE(kx022a_scale_table) *\n\t\t\t  ARRAY_SIZE(kx022a_scale_table[0]);\n\t\t*type = IIO_VAL_INT_PLUS_NANO;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#define KX022A_DEFAULT_PERIOD_NS (20 * NSEC_PER_MSEC)\n\nstatic void kx022a_reg2freq(unsigned int val,  int *val1, int *val2)\n{\n\t*val1 = kx022a_accel_samp_freq_table[val & KX022A_MASK_ODR][0];\n\t*val2 = kx022a_accel_samp_freq_table[val & KX022A_MASK_ODR][1];\n}\n\nstatic void kx022a_reg2scale(unsigned int val, unsigned int *val1,\n\t\t\t     unsigned int *val2)\n{\n\tval &= KX022A_MASK_GSEL;\n\tval >>= KX022A_GSEL_SHIFT;\n\n\t*val1 = kx022a_scale_table[val][0];\n\t*val2 = kx022a_scale_table[val][1];\n}\n\nstatic int kx022a_turn_on_off_unlocked(struct kx022a_data *data, bool on)\n{\n\tint ret;\n\n\tif (on)\n\t\tret = regmap_set_bits(data->regmap, KX022A_REG_CNTL,\n\t\t\t\t      KX022A_MASK_PC1);\n\telse\n\t\tret = regmap_clear_bits(data->regmap, KX022A_REG_CNTL,\n\t\t\t\t\tKX022A_MASK_PC1);\n\tif (ret)\n\t\tdev_err(data->dev, \"Turn %s fail %d\\n\", str_on_off(on), ret);\n\n\treturn ret;\n\n}\n\nstatic int kx022a_turn_off_lock(struct kx022a_data *data)\n{\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = kx022a_turn_on_off_unlocked(data, false);\n\tif (ret)\n\t\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int kx022a_turn_on_unlock(struct kx022a_data *data)\n{\n\tint ret;\n\n\tret = kx022a_turn_on_off_unlocked(data, true);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int kx022a_write_raw_get_fmt(struct iio_dev *idev,\n\t\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t\t    long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int kx022a_write_raw(struct iio_dev *idev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct kx022a_data *data = iio_priv(idev);\n\tint ret, n;\n\n\t \n\tret = iio_device_claim_direct_mode(idev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tn = ARRAY_SIZE(kx022a_accel_samp_freq_table);\n\n\t\twhile (n--)\n\t\t\tif (val == kx022a_accel_samp_freq_table[n][0] &&\n\t\t\t    val2 == kx022a_accel_samp_freq_table[n][1])\n\t\t\t\tbreak;\n\t\tif (n < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tret = kx022a_turn_off_lock(data);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = regmap_update_bits(data->regmap,\n\t\t\t\t\t KX022A_REG_ODCNTL,\n\t\t\t\t\t KX022A_MASK_ODR, n);\n\t\tdata->odr_ns = kx022a_odrs[n];\n\t\tkx022a_turn_on_unlock(data);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tn = ARRAY_SIZE(kx022a_scale_table);\n\n\t\twhile (n-- > 0)\n\t\t\tif (val == kx022a_scale_table[n][0] &&\n\t\t\t    val2 == kx022a_scale_table[n][1])\n\t\t\t\tbreak;\n\t\tif (n < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock_out;\n\t\t}\n\n\t\tret = kx022a_turn_off_lock(data);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = regmap_update_bits(data->regmap, KX022A_REG_CNTL,\n\t\t\t\t\t KX022A_MASK_GSEL,\n\t\t\t\t\t n << KX022A_GSEL_SHIFT);\n\t\tkx022a_turn_on_unlock(data);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock_out:\n\tiio_device_release_direct_mode(idev);\n\n\treturn ret;\n}\n\nstatic int kx022a_fifo_set_wmi(struct kx022a_data *data)\n{\n\tu8 threshold;\n\n\tthreshold = data->watermark;\n\n\treturn regmap_update_bits(data->regmap, KX022A_REG_BUF_CNTL1,\n\t\t\t\t  KX022A_MASK_WM_TH, threshold);\n}\n\nstatic int kx022a_get_axis(struct kx022a_data *data,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val)\n{\n\tint ret;\n\n\tret = regmap_bulk_read(data->regmap, chan->address, &data->buffer[0],\n\t\t\t       sizeof(__le16));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = le16_to_cpu(data->buffer[0]);\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int kx022a_read_raw(struct iio_dev *idev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct kx022a_data *data = iio_priv(idev);\n\tunsigned int regval;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(idev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&data->mutex);\n\t\tret = kx022a_get_axis(data, chan, val);\n\t\tmutex_unlock(&data->mutex);\n\n\t\tiio_device_release_direct_mode(idev);\n\n\t\treturn ret;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = regmap_read(data->regmap, KX022A_REG_ODCNTL, &regval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((regval & KX022A_MASK_ODR) >\n\t\t    ARRAY_SIZE(kx022a_accel_samp_freq_table)) {\n\t\t\tdev_err(data->dev, \"Invalid ODR\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tkx022a_reg2freq(regval, val, val2);\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = regmap_read(data->regmap, KX022A_REG_CNTL, &regval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tkx022a_reg2scale(regval, val, val2);\n\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t}\n\n\treturn -EINVAL;\n};\n\nstatic int kx022a_set_watermark(struct iio_dev *idev, unsigned int val)\n{\n\tstruct kx022a_data *data = iio_priv(idev);\n\n\tif (val > KX022A_FIFO_LENGTH)\n\t\tval = KX022A_FIFO_LENGTH;\n\n\tmutex_lock(&data->mutex);\n\tdata->watermark = val;\n\tmutex_unlock(&data->mutex);\n\n\treturn 0;\n}\n\nstatic ssize_t hwfifo_enabled_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct iio_dev *idev = dev_to_iio_dev(dev);\n\tstruct kx022a_data *data = iio_priv(idev);\n\tbool state;\n\n\tmutex_lock(&data->mutex);\n\tstate = data->state;\n\tmutex_unlock(&data->mutex);\n\n\treturn sysfs_emit(buf, \"%d\\n\", state);\n}\n\nstatic ssize_t hwfifo_watermark_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct iio_dev *idev = dev_to_iio_dev(dev);\n\tstruct kx022a_data *data = iio_priv(idev);\n\tint wm;\n\n\tmutex_lock(&data->mutex);\n\twm = data->watermark;\n\tmutex_unlock(&data->mutex);\n\n\treturn sysfs_emit(buf, \"%d\\n\", wm);\n}\n\nstatic IIO_DEVICE_ATTR_RO(hwfifo_enabled, 0);\nstatic IIO_DEVICE_ATTR_RO(hwfifo_watermark, 0);\n\nstatic const struct iio_dev_attr *kx022a_fifo_attributes[] = {\n\t&iio_dev_attr_hwfifo_watermark,\n\t&iio_dev_attr_hwfifo_enabled,\n\tNULL\n};\n\nstatic int kx022a_drop_fifo_contents(struct kx022a_data *data)\n{\n\t \n\tdata->timestamp = 0;\n\n\treturn regmap_write(data->regmap, KX022A_REG_BUF_CLEAR, 0x0);\n}\n\nstatic int __kx022a_fifo_flush(struct iio_dev *idev, unsigned int samples,\n\t\t\t       bool irq)\n{\n\tstruct kx022a_data *data = iio_priv(idev);\n\tstruct device *dev = regmap_get_device(data->regmap);\n\t__le16 buffer[KX022A_FIFO_LENGTH * 3];\n\tuint64_t sample_period;\n\tint count, fifo_bytes;\n\tbool renable = false;\n\tint64_t tstamp;\n\tint ret, i;\n\n\tret = regmap_read(data->regmap, KX022A_REG_BUF_STATUS_1, &fifo_bytes);\n\tif (ret) {\n\t\tdev_err(dev, \"Error reading buffer status\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (fifo_bytes == KX022A_FIFO_FULL_VALUE)\n\t\tfifo_bytes = KX022A_FIFO_MAX_BYTES;\n\n\tif (fifo_bytes % KX022A_FIFO_SAMPLES_SIZE_BYTES)\n\t\tdev_warn(data->dev, \"Bad FIFO alignment. Data may be corrupt\\n\");\n\n\tcount = fifo_bytes / KX022A_FIFO_SAMPLES_SIZE_BYTES;\n\tif (!count)\n\t\treturn 0;\n\n\t \n\tif (!irq) {\n\t\t \n\t\tdisable_irq(data->irq);\n\t\trenable = true;\n\n\t\tdata->old_timestamp = data->timestamp;\n\t\tdata->timestamp = iio_get_time_ns(idev);\n\t}\n\n\t \n\tif (data->old_timestamp) {\n\t\tsample_period = data->timestamp - data->old_timestamp;\n\t\tdo_div(sample_period, count);\n\t} else {\n\t\tsample_period = data->odr_ns;\n\t}\n\ttstamp = data->timestamp - (count - 1) * sample_period;\n\n\tif (samples && count > samples) {\n\t\t \n\t\tdata->timestamp -= (count - samples) * sample_period;\n\t\tcount = samples;\n\t}\n\n\tfifo_bytes = count * KX022A_FIFO_SAMPLES_SIZE_BYTES;\n\tret = regmap_noinc_read(data->regmap, KX022A_REG_BUF_READ,\n\t\t\t\t&buffer[0], fifo_bytes);\n\tif (ret)\n\t\tgoto renable_out;\n\n\tfor (i = 0; i < count; i++) {\n\t\t__le16 *sam = &buffer[i * 3];\n\t\t__le16 *chs;\n\t\tint bit;\n\n\t\tchs = &data->scan.channels[0];\n\t\tfor_each_set_bit(bit, idev->active_scan_mask, AXIS_MAX)\n\t\t\tchs[bit] = sam[bit];\n\n\t\tiio_push_to_buffers_with_timestamp(idev, &data->scan, tstamp);\n\n\t\ttstamp += sample_period;\n\t}\n\n\tret = count;\n\nrenable_out:\n\tif (renable)\n\t\tenable_irq(data->irq);\n\n\treturn ret;\n}\n\nstatic int kx022a_fifo_flush(struct iio_dev *idev, unsigned int samples)\n{\n\tstruct kx022a_data *data = iio_priv(idev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = __kx022a_fifo_flush(idev, samples, false);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic const struct iio_info kx022a_info = {\n\t.read_raw = &kx022a_read_raw,\n\t.write_raw = &kx022a_write_raw,\n\t.write_raw_get_fmt = &kx022a_write_raw_get_fmt,\n\t.read_avail = &kx022a_read_avail,\n\n\t.validate_trigger\t= iio_validate_own_trigger,\n\t.hwfifo_set_watermark\t= kx022a_set_watermark,\n\t.hwfifo_flush_to_buffer\t= kx022a_fifo_flush,\n};\n\nstatic int kx022a_set_drdy_irq(struct kx022a_data *data, bool en)\n{\n\tif (en)\n\t\treturn regmap_set_bits(data->regmap, KX022A_REG_CNTL,\n\t\t\t\t       KX022A_MASK_DRDY);\n\n\treturn regmap_clear_bits(data->regmap, KX022A_REG_CNTL,\n\t\t\t\t KX022A_MASK_DRDY);\n}\n\nstatic int kx022a_prepare_irq_pin(struct kx022a_data *data)\n{\n\t \n\tint mask = KX022A_MASK_IEN | KX022A_MASK_IPOL |\n\t\t   KX022A_MASK_ITYP;\n\tint val = KX022A_MASK_IEN | KX022A_IPOL_LOW |\n\t\t  KX022A_ITYP_LEVEL;\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap, data->inc_reg, mask, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmask = KX022A_MASK_INS2_DRDY;\n\n\treturn regmap_set_bits(data->regmap, data->ien_reg, mask);\n}\n\nstatic int kx022a_fifo_disable(struct kx022a_data *data)\n{\n\tint ret = 0;\n\n\tret = kx022a_turn_off_lock(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_clear_bits(data->regmap, data->ien_reg, KX022A_MASK_WMI);\n\tif (ret)\n\t\tgoto unlock_out;\n\n\tret = regmap_clear_bits(data->regmap, KX022A_REG_BUF_CNTL2,\n\t\t\t\tKX022A_MASK_BUF_EN);\n\tif (ret)\n\t\tgoto unlock_out;\n\n\tdata->state &= ~KX022A_STATE_FIFO;\n\n\tkx022a_drop_fifo_contents(data);\n\n\treturn kx022a_turn_on_unlock(data);\n\nunlock_out:\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int kx022a_buffer_predisable(struct iio_dev *idev)\n{\n\tstruct kx022a_data *data = iio_priv(idev);\n\n\tif (iio_device_get_current_mode(idev) == INDIO_BUFFER_TRIGGERED)\n\t\treturn 0;\n\n\treturn kx022a_fifo_disable(data);\n}\n\nstatic int kx022a_fifo_enable(struct kx022a_data *data)\n{\n\tint ret;\n\n\tret = kx022a_turn_off_lock(data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = kx022a_fifo_set_wmi(data);\n\tif (ret)\n\t\tgoto unlock_out;\n\n\t \n\tret = regmap_set_bits(data->regmap, KX022A_REG_BUF_CNTL2,\n\t\t\t      KX022A_MASK_BUF_EN);\n\tif (ret)\n\t\tgoto unlock_out;\n\n\tdata->state |= KX022A_STATE_FIFO;\n\tret = regmap_set_bits(data->regmap, data->ien_reg,\n\t\t\t      KX022A_MASK_WMI);\n\tif (ret)\n\t\tgoto unlock_out;\n\n\treturn kx022a_turn_on_unlock(data);\n\nunlock_out:\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int kx022a_buffer_postenable(struct iio_dev *idev)\n{\n\tstruct kx022a_data *data = iio_priv(idev);\n\n\t \n\tif (iio_device_get_current_mode(idev) == INDIO_BUFFER_TRIGGERED)\n\t\treturn 0;\n\n\treturn kx022a_fifo_enable(data);\n}\n\nstatic const struct iio_buffer_setup_ops kx022a_buffer_ops = {\n\t.postenable = kx022a_buffer_postenable,\n\t.predisable = kx022a_buffer_predisable,\n};\n\nstatic irqreturn_t kx022a_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *idev = pf->indio_dev;\n\tstruct kx022a_data *data = iio_priv(idev);\n\tint ret;\n\n\tret = regmap_bulk_read(data->regmap, KX022A_REG_XOUT_L, data->buffer,\n\t\t\t       KX022A_FIFO_SAMPLES_SIZE_BYTES);\n\tif (ret < 0)\n\t\tgoto err_read;\n\n\tiio_push_to_buffers_with_timestamp(idev, data->buffer, data->timestamp);\nerr_read:\n\tiio_trigger_notify_done(idev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t kx022a_irq_handler(int irq, void *private)\n{\n\tstruct iio_dev *idev = private;\n\tstruct kx022a_data *data = iio_priv(idev);\n\n\tdata->old_timestamp = data->timestamp;\n\tdata->timestamp = iio_get_time_ns(idev);\n\n\tif (data->state & KX022A_STATE_FIFO || data->trigger_enabled)\n\t\treturn IRQ_WAKE_THREAD;\n\n\treturn IRQ_NONE;\n}\n\n \nstatic irqreturn_t kx022a_irq_thread_handler(int irq, void *private)\n{\n\tstruct iio_dev *idev = private;\n\tstruct kx022a_data *data = iio_priv(idev);\n\tirqreturn_t ret = IRQ_NONE;\n\n\tmutex_lock(&data->mutex);\n\n\tif (data->trigger_enabled) {\n\t\tiio_trigger_poll_nested(data->trig);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (data->state & KX022A_STATE_FIFO) {\n\t\tint ok;\n\n\t\tok = __kx022a_fifo_flush(idev, KX022A_FIFO_LENGTH, true);\n\t\tif (ok > 0)\n\t\t\tret = IRQ_HANDLED;\n\t}\n\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int kx022a_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t    bool state)\n{\n\tstruct kx022a_data *data = iio_trigger_get_drvdata(trig);\n\tint ret = 0;\n\n\tmutex_lock(&data->mutex);\n\n\tif (data->trigger_enabled == state)\n\t\tgoto unlock_out;\n\n\tif (data->state & KX022A_STATE_FIFO) {\n\t\tdev_warn(data->dev, \"Can't set trigger when FIFO enabled\\n\");\n\t\tret = -EBUSY;\n\t\tgoto unlock_out;\n\t}\n\n\tret = kx022a_turn_on_off_unlocked(data, false);\n\tif (ret)\n\t\tgoto unlock_out;\n\n\tdata->trigger_enabled = state;\n\tret = kx022a_set_drdy_irq(data, state);\n\tif (ret)\n\t\tgoto unlock_out;\n\n\tret = kx022a_turn_on_off_unlocked(data, true);\n\nunlock_out:\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic const struct iio_trigger_ops kx022a_trigger_ops = {\n\t.set_trigger_state = kx022a_trigger_set_state,\n};\n\nstatic int kx022a_chip_init(struct kx022a_data *data)\n{\n\tint ret, val;\n\n\t \n\tret = regmap_write(data->regmap, KX022A_REG_CNTL2, KX022A_MASK_SRST);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(1);\n\n\tret = regmap_read_poll_timeout(data->regmap, KX022A_REG_CNTL2, val,\n\t\t\t\t       !(val & KX022A_MASK_SRST),\n\t\t\t\t       KX022A_SOFT_RESET_WAIT_TIME_US,\n\t\t\t\t       KX022A_SOFT_RESET_TOTAL_WAIT_TIME_US);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Sensor reset %s\\n\",\n\t\t\tval & KX022A_MASK_SRST ? \"timeout\" : \"fail#\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_reinit_cache(data->regmap, &kx022a_regmap);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to reinit reg cache\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_set_bits(data->regmap, KX022A_REG_BUF_CNTL2,\n\t\t\t      KX022A_MASK_BRES16);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to set data resolution\\n\");\n\t\treturn ret;\n\t}\n\n\treturn kx022a_prepare_irq_pin(data);\n}\n\nint kx022a_probe_internal(struct device *dev)\n{\n\tstatic const char * const regulator_names[] = {\"io-vdd\", \"vdd\"};\n\tstruct iio_trigger *indio_trig;\n\tstruct fwnode_handle *fwnode;\n\tstruct kx022a_data *data;\n\tstruct regmap *regmap;\n\tunsigned int chip_id;\n\tstruct iio_dev *idev;\n\tint ret, irq;\n\tchar *name;\n\n\tregmap = dev_get_regmap(dev, NULL);\n\tif (!regmap) {\n\t\tdev_err(dev, \"no regmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfwnode = dev_fwnode(dev);\n\tif (!fwnode)\n\t\treturn -ENODEV;\n\n\tidev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(idev);\n\n\t \n\tret = devm_regulator_bulk_get_enable(dev, ARRAY_SIZE(regulator_names),\n\t\t\t\t\t     regulator_names);\n\tif (ret && ret != -ENODEV)\n\t\treturn dev_err_probe(dev, ret, \"failed to enable regulator\\n\");\n\n\tret = regmap_read(regmap, KX022A_REG_WHO, &chip_id);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to access sensor\\n\");\n\n\tif (chip_id != KX022A_ID) {\n\t\tdev_err(dev, \"unsupported device 0x%x\\n\", chip_id);\n\t\treturn -EINVAL;\n\t}\n\n\tirq = fwnode_irq_get_byname(fwnode, \"INT1\");\n\tif (irq > 0) {\n\t\tdata->inc_reg = KX022A_REG_INC1;\n\t\tdata->ien_reg = KX022A_REG_INC4;\n\t} else {\n\t\tirq = fwnode_irq_get_byname(fwnode, \"INT2\");\n\t\tif (irq < 0)\n\t\t\treturn dev_err_probe(dev, irq, \"No suitable IRQ\\n\");\n\n\t\tdata->inc_reg = KX022A_REG_INC5;\n\t\tdata->ien_reg = KX022A_REG_INC6;\n\t}\n\n\tdata->regmap = regmap;\n\tdata->dev = dev;\n\tdata->irq = irq;\n\tdata->odr_ns = KX022A_DEFAULT_PERIOD_NS;\n\tmutex_init(&data->mutex);\n\n\tidev->channels = kx022a_channels;\n\tidev->num_channels = ARRAY_SIZE(kx022a_channels);\n\tidev->name = \"kx022-accel\";\n\tidev->info = &kx022a_info;\n\tidev->modes = INDIO_DIRECT_MODE | INDIO_BUFFER_SOFTWARE;\n\tidev->available_scan_masks = kx022a_scan_masks;\n\n\t \n\tret = iio_read_mount_matrix(dev, &data->orientation);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = kx022a_turn_off_lock(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kx022a_chip_init(data);\n\tif (ret) {\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\n\tret = kx022a_turn_on_unlock(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup_ext(dev, idev,\n\t\t\t\t\t\t  &iio_pollfunc_store_time,\n\t\t\t\t\t\t  kx022a_trigger_handler,\n\t\t\t\t\t\t  IIO_BUFFER_DIRECTION_IN,\n\t\t\t\t\t\t  &kx022a_buffer_ops,\n\t\t\t\t\t\t  kx022a_fifo_attributes);\n\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret,\n\t\t\t\t     \"iio_triggered_buffer_setup_ext FAIL\\n\");\n\tindio_trig = devm_iio_trigger_alloc(dev, \"%sdata-rdy-dev%d\", idev->name,\n\t\t\t\t\t    iio_device_id(idev));\n\tif (!indio_trig)\n\t\treturn -ENOMEM;\n\n\tdata->trig = indio_trig;\n\n\tindio_trig->ops = &kx022a_trigger_ops;\n\tiio_trigger_set_drvdata(indio_trig, data);\n\n\t \n\tname = devm_kasprintf(data->dev, GFP_KERNEL, \"%s-kx022a\",\n\t\t\t      dev_name(data->dev));\n\n\tret = devm_request_threaded_irq(data->dev, irq, kx022a_irq_handler,\n\t\t\t\t\t&kx022a_irq_thread_handler,\n\t\t\t\t\tIRQF_ONESHOT, name, idev);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret, \"Could not request IRQ\\n\");\n\n\n\tret = devm_iio_trigger_register(dev, indio_trig);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret,\n\t\t\t\t     \"Trigger registration failed\\n\");\n\n\tret = devm_iio_device_register(data->dev, idev);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Unable to register iio device\\n\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(kx022a_probe_internal, IIO_KX022A);\n\nMODULE_DESCRIPTION(\"ROHM/Kionix KX022A accelerometer driver\");\nMODULE_AUTHOR(\"Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}