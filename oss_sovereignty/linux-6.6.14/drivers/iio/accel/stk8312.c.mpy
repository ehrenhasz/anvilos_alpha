{
  "module_name": "stk8312.c",
  "hash_id": "438927c44eb4b5c3b90917e48d150867c53d4b120cbf48baa479ae6e4f7bb6eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/stk8312.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#define STK8312_REG_XOUT\t\t0x00\n#define STK8312_REG_YOUT\t\t0x01\n#define STK8312_REG_ZOUT\t\t0x02\n#define STK8312_REG_INTSU\t\t0x06\n#define STK8312_REG_MODE\t\t0x07\n#define STK8312_REG_SR\t\t\t0x08\n#define STK8312_REG_STH\t\t\t0x13\n#define STK8312_REG_RESET\t\t0x20\n#define STK8312_REG_AFECTRL\t\t0x24\n#define STK8312_REG_OTPADDR\t\t0x3D\n#define STK8312_REG_OTPDATA\t\t0x3E\n#define STK8312_REG_OTPCTRL\t\t0x3F\n\n#define STK8312_MODE_ACTIVE\t\tBIT(0)\n#define STK8312_MODE_STANDBY\t\t0x00\n#define STK8312_MODE_INT_AH_PP\t\t0xC0\t \n#define STK8312_DREADY_BIT\t\tBIT(4)\n#define STK8312_RNG_6G\t\t\t1\n#define STK8312_RNG_SHIFT\t\t6\n#define STK8312_RNG_MASK\t\tGENMASK(7, 6)\n#define STK8312_SR_MASK\t\t\tGENMASK(2, 0)\n#define STK8312_SR_400HZ_IDX\t\t0\n#define STK8312_ALL_CHANNEL_MASK\tGENMASK(2, 0)\n#define STK8312_ALL_CHANNEL_SIZE\t3\n\n#define STK8312_DRIVER_NAME\t\t\"stk8312\"\n#define STK8312_IRQ_NAME\t\t\"stk8312_event\"\n\n \n#define STK8312_SCALE_AVAIL\t\t\"0.4616 1.2311\"\n\nstatic const int stk8312_scale_table[][2] = {\n\t{0, 461600}, {1, 231100}\n};\n\nstatic const struct {\n\tint val;\n\tint val2;\n} stk8312_samp_freq_table[] = {\n\t{400, 0}, {200, 0}, {100, 0}, {50, 0}, {25, 0},\n\t{12, 500000}, {6, 250000}, {3, 125000}\n};\n\n#define STK8312_ACCEL_CHANNEL(index, reg, axis) {\t\t\t\\\n\t.type = IIO_ACCEL,\t\t\t\t\t\t\\\n\t.address = reg,\t\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##axis,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\t\\\n\t\t\t\t    BIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n\t.scan_index = index,\t\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\t\\\n\t\t.realbits = 8,\t\t\t\t\t\t\\\n\t\t.storagebits = 8,\t\t\t\t\t\\\n\t\t.endianness = IIO_CPU,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec stk8312_channels[] = {\n\tSTK8312_ACCEL_CHANNEL(0, STK8312_REG_XOUT, X),\n\tSTK8312_ACCEL_CHANNEL(1, STK8312_REG_YOUT, Y),\n\tSTK8312_ACCEL_CHANNEL(2, STK8312_REG_ZOUT, Z),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstruct stk8312_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tu8 range;\n\tu8 sample_rate_idx;\n\tu8 mode;\n\tstruct iio_trigger *dready_trig;\n\tbool dready_trigger_on;\n\t \n\tstruct {\n\t\ts8 chans[3];\n\t\ts64 timestamp __aligned(8);\n\t} scan;\n};\n\nstatic IIO_CONST_ATTR(in_accel_scale_available, STK8312_SCALE_AVAIL);\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\"3.125 6.25 12.5 25 50 100 200 400\");\n\nstatic struct attribute *stk8312_attributes[] = {\n\t&iio_const_attr_in_accel_scale_available.dev_attr.attr,\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group stk8312_attribute_group = {\n\t.attrs = stk8312_attributes\n};\n\nstatic int stk8312_otp_init(struct stk8312_data *data)\n{\n\tint ret;\n\tint count = 10;\n\tstruct i2c_client *client = data->client;\n\n\tret = i2c_smbus_write_byte_data(client, STK8312_REG_OTPADDR, 0x70);\n\tif (ret < 0)\n\t\tgoto exit_err;\n\tret = i2c_smbus_write_byte_data(client, STK8312_REG_OTPCTRL, 0x02);\n\tif (ret < 0)\n\t\tgoto exit_err;\n\n\tdo {\n\t\tusleep_range(1000, 5000);\n\t\tret = i2c_smbus_read_byte_data(client, STK8312_REG_OTPCTRL);\n\t\tif (ret < 0)\n\t\t\tgoto exit_err;\n\t\tcount--;\n\t} while (!(ret & BIT(7)) && count > 0);\n\n\tif (count == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto exit_err;\n\t}\n\n\tret = i2c_smbus_read_byte_data(client, STK8312_REG_OTPDATA);\n\tif (ret == 0)\n\t\tret = -EINVAL;\n\tif (ret < 0)\n\t\tgoto exit_err;\n\n\tret = i2c_smbus_write_byte_data(data->client, STK8312_REG_AFECTRL, ret);\n\tif (ret < 0)\n\t\tgoto exit_err;\n\tmsleep(150);\n\n\treturn 0;\n\nexit_err:\n\tdev_err(&client->dev, \"failed to initialize sensor\\n\");\n\treturn ret;\n}\n\nstatic int stk8312_set_mode(struct stk8312_data *data, u8 mode)\n{\n\tint ret;\n\tstruct i2c_client *client = data->client;\n\n\tif (mode == data->mode)\n\t\treturn 0;\n\n\tret = i2c_smbus_write_byte_data(client, STK8312_REG_MODE, mode);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to change sensor mode\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->mode = mode;\n\tif (mode & STK8312_MODE_ACTIVE) {\n\t\t \n\t\tusleep_range(1000, 5000);\n\t\tret = stk8312_otp_init(data);\n\t}\n\n\treturn ret;\n}\n\nstatic int stk8312_set_interrupts(struct stk8312_data *data, u8 int_mask)\n{\n\tint ret;\n\tu8 mode;\n\tstruct i2c_client *client = data->client;\n\n\tmode = data->mode;\n\t \n\tret = stk8312_set_mode(data, STK8312_MODE_STANDBY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(client, STK8312_REG_INTSU, int_mask);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to set interrupts\\n\");\n\t\tstk8312_set_mode(data, mode);\n\t\treturn ret;\n\t}\n\n\treturn stk8312_set_mode(data, mode);\n}\n\nstatic int stk8312_data_rdy_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t      bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct stk8312_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (state)\n\t\tret = stk8312_set_interrupts(data, STK8312_DREADY_BIT);\n\telse\n\t\tret = stk8312_set_interrupts(data, 0x00);\n\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"failed to set trigger state\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->dready_trigger_on = state;\n\n\treturn 0;\n}\n\nstatic const struct iio_trigger_ops stk8312_trigger_ops = {\n\t.set_trigger_state = stk8312_data_rdy_trigger_set_state,\n};\n\nstatic int stk8312_set_sample_rate(struct stk8312_data *data, u8 rate)\n{\n\tint ret;\n\tu8 masked_reg;\n\tu8 mode;\n\tstruct i2c_client *client = data->client;\n\n\tif (rate == data->sample_rate_idx)\n\t\treturn 0;\n\n\tmode = data->mode;\n\t \n\tret = stk8312_set_mode(data, STK8312_MODE_STANDBY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_byte_data(client, STK8312_REG_SR);\n\tif (ret < 0)\n\t\tgoto err_activate;\n\n\tmasked_reg = (ret & (~STK8312_SR_MASK)) | rate;\n\n\tret = i2c_smbus_write_byte_data(client, STK8312_REG_SR, masked_reg);\n\tif (ret < 0)\n\t\tgoto err_activate;\n\n\tdata->sample_rate_idx = rate;\n\n\treturn stk8312_set_mode(data, mode);\n\nerr_activate:\n\tdev_err(&client->dev, \"failed to set sampling rate\\n\");\n\tstk8312_set_mode(data, mode);\n\n\treturn ret;\n}\n\nstatic int stk8312_set_range(struct stk8312_data *data, u8 range)\n{\n\tint ret;\n\tu8 masked_reg;\n\tu8 mode;\n\tstruct i2c_client *client = data->client;\n\n\tif (range != 1 && range != 2)\n\t\treturn -EINVAL;\n\telse if (range == data->range)\n\t\treturn 0;\n\n\tmode = data->mode;\n\t \n\tret = stk8312_set_mode(data, STK8312_MODE_STANDBY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_byte_data(client, STK8312_REG_STH);\n\tif (ret < 0)\n\t\tgoto err_activate;\n\n\tmasked_reg = ret & (~STK8312_RNG_MASK);\n\tmasked_reg |= range << STK8312_RNG_SHIFT;\n\n\tret = i2c_smbus_write_byte_data(client, STK8312_REG_STH, masked_reg);\n\tif (ret < 0)\n\t\tgoto err_activate;\n\n\tdata->range = range;\n\n\treturn stk8312_set_mode(data, mode);\n\nerr_activate:\n\tdev_err(&client->dev, \"failed to change sensor range\\n\");\n\tstk8312_set_mode(data, mode);\n\n\treturn ret;\n}\n\nstatic int stk8312_read_accel(struct stk8312_data *data, u8 address)\n{\n\tint ret;\n\tstruct i2c_client *client = data->client;\n\n\tif (address > 2)\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_read_byte_data(client, address);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"register read failed\\n\");\n\n\treturn ret;\n}\n\nstatic int stk8312_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct stk8312_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (iio_buffer_enabled(indio_dev))\n\t\t\treturn -EBUSY;\n\t\tmutex_lock(&data->lock);\n\t\tret = stk8312_set_mode(data, data->mode | STK8312_MODE_ACTIVE);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn ret;\n\t\t}\n\t\tret = stk8312_read_accel(data, chan->address);\n\t\tif (ret < 0) {\n\t\t\tstk8312_set_mode(data,\n\t\t\t\t\t data->mode & (~STK8312_MODE_ACTIVE));\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn ret;\n\t\t}\n\t\t*val = sign_extend32(ret, chan->scan_type.realbits - 1);\n\t\tret = stk8312_set_mode(data,\n\t\t\t\t       data->mode & (~STK8312_MODE_ACTIVE));\n\t\tmutex_unlock(&data->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = stk8312_scale_table[data->range - 1][0];\n\t\t*val2 = stk8312_scale_table[data->range - 1][1];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = stk8312_samp_freq_table[data->sample_rate_idx].val;\n\t\t*val2 = stk8312_samp_freq_table[data->sample_rate_idx].val2;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stk8312_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tint i;\n\tint index = -1;\n\tint ret;\n\tstruct stk8312_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tfor (i = 0; i < ARRAY_SIZE(stk8312_scale_table); i++)\n\t\t\tif (val == stk8312_scale_table[i][0] &&\n\t\t\t    val2 == stk8312_scale_table[i][1]) {\n\t\t\t\tindex = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (index < 0)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&data->lock);\n\t\tret = stk8312_set_range(data, index);\n\t\tmutex_unlock(&data->lock);\n\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tfor (i = 0; i < ARRAY_SIZE(stk8312_samp_freq_table); i++)\n\t\t\tif (val == stk8312_samp_freq_table[i].val &&\n\t\t\t    val2 == stk8312_samp_freq_table[i].val2) {\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (index < 0)\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&data->lock);\n\t\tret = stk8312_set_sample_rate(data, index);\n\t\tmutex_unlock(&data->lock);\n\n\t\treturn ret;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info stk8312_info = {\n\t.read_raw\t\t= stk8312_read_raw,\n\t.write_raw\t\t= stk8312_write_raw,\n\t.attrs\t\t\t= &stk8312_attribute_group,\n};\n\nstatic irqreturn_t stk8312_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct stk8312_data *data = iio_priv(indio_dev);\n\tint bit, ret, i = 0;\n\n\tmutex_lock(&data->lock);\n\t \n\tif (*(indio_dev->active_scan_mask) == STK8312_ALL_CHANNEL_MASK) {\n\t\tret = i2c_smbus_read_i2c_block_data(data->client,\n\t\t\t\t\t\t    STK8312_REG_XOUT,\n\t\t\t\t\t\t    STK8312_ALL_CHANNEL_SIZE,\n\t\t\t\t\t\t    data->scan.chans);\n\t\tif (ret < STK8312_ALL_CHANNEL_SIZE) {\n\t\t\tdev_err(&data->client->dev, \"register read failed\\n\");\n\t\t\tmutex_unlock(&data->lock);\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t\t indio_dev->masklength) {\n\t\t\tret = stk8312_read_accel(data, bit);\n\t\t\tif (ret < 0) {\n\t\t\t\tmutex_unlock(&data->lock);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tdata->scan.chans[i++] = ret;\n\t\t}\n\t}\n\tmutex_unlock(&data->lock);\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t   pf->timestamp);\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t stk8312_data_rdy_trig_poll(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct stk8312_data *data = iio_priv(indio_dev);\n\n\tif (data->dready_trigger_on)\n\t\tiio_trigger_poll(data->dready_trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int stk8312_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct stk8312_data *data = iio_priv(indio_dev);\n\n\treturn stk8312_set_mode(data, data->mode | STK8312_MODE_ACTIVE);\n}\n\nstatic int stk8312_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct stk8312_data *data = iio_priv(indio_dev);\n\n\treturn stk8312_set_mode(data, data->mode & (~STK8312_MODE_ACTIVE));\n}\n\nstatic const struct iio_buffer_setup_ops stk8312_buffer_setup_ops = {\n\t.preenable   = stk8312_buffer_preenable,\n\t.postdisable = stk8312_buffer_postdisable,\n};\n\nstatic int stk8312_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\tstruct stk8312_data *data;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev) {\n\t\tdev_err(&client->dev, \"iio allocation failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\ti2c_set_clientdata(client, indio_dev);\n\tmutex_init(&data->lock);\n\n\tindio_dev->info = &stk8312_info;\n\tindio_dev->name = STK8312_DRIVER_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = stk8312_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(stk8312_channels);\n\n\t \n\tret = i2c_smbus_write_byte_data(data->client, STK8312_REG_RESET, 0x00);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to reset sensor\\n\");\n\t\treturn ret;\n\t}\n\tdata->sample_rate_idx = STK8312_SR_400HZ_IDX;\n\tret = stk8312_set_range(data, STK8312_RNG_6G);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = stk8312_set_mode(data,\n\t\t\t       STK8312_MODE_INT_AH_PP | STK8312_MODE_ACTIVE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (client->irq > 0) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tstk8312_data_rdy_trig_poll,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tSTK8312_IRQ_NAME,\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"request irq %d failed\\n\",\n\t\t\t\tclient->irq);\n\t\t\tgoto err_power_off;\n\t\t}\n\n\t\tdata->dready_trig = devm_iio_trigger_alloc(&client->dev,\n\t\t\t\t\t\t\t   \"%s-dev%d\",\n\t\t\t\t\t\t\t   indio_dev->name,\n\t\t\t\t\t\t\t   iio_device_id(indio_dev));\n\t\tif (!data->dready_trig) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_power_off;\n\t\t}\n\n\t\tdata->dready_trig->ops = &stk8312_trigger_ops;\n\t\tiio_trigger_set_drvdata(data->dready_trig, indio_dev);\n\t\tret = iio_trigger_register(data->dready_trig);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"iio trigger register failed\\n\");\n\t\t\tgoto err_power_off;\n\t\t}\n\t}\n\n\tret = iio_triggered_buffer_setup(indio_dev,\n\t\t\t\t\t iio_pollfunc_store_time,\n\t\t\t\t\t stk8312_trigger_handler,\n\t\t\t\t\t &stk8312_buffer_setup_ops);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"iio triggered buffer setup failed\\n\");\n\t\tgoto err_trigger_unregister;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"device_register failed\\n\");\n\t\tgoto err_buffer_cleanup;\n\t}\n\n\treturn 0;\n\nerr_buffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\nerr_trigger_unregister:\n\tif (data->dready_trig)\n\t\tiio_trigger_unregister(data->dready_trig);\nerr_power_off:\n\tstk8312_set_mode(data, STK8312_MODE_STANDBY);\n\treturn ret;\n}\n\nstatic void stk8312_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct stk8312_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\n\tif (data->dready_trig)\n\t\tiio_trigger_unregister(data->dready_trig);\n\n\tstk8312_set_mode(data, STK8312_MODE_STANDBY);\n}\n\nstatic int stk8312_suspend(struct device *dev)\n{\n\tstruct stk8312_data *data;\n\n\tdata = iio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\n\treturn stk8312_set_mode(data, data->mode & (~STK8312_MODE_ACTIVE));\n}\n\nstatic int stk8312_resume(struct device *dev)\n{\n\tstruct stk8312_data *data;\n\n\tdata = iio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\n\treturn stk8312_set_mode(data, data->mode | STK8312_MODE_ACTIVE);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(stk8312_pm_ops, stk8312_suspend,\n\t\t\t\tstk8312_resume);\n\nstatic const struct i2c_device_id stk8312_i2c_id[] = {\n\t \n\t{ \"STK8312\", 0 },\n\t{ \"stk8312\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, stk8312_i2c_id);\n\nstatic struct i2c_driver stk8312_driver = {\n\t.driver = {\n\t\t.name = STK8312_DRIVER_NAME,\n\t\t.pm = pm_sleep_ptr(&stk8312_pm_ops),\n\t},\n\t.probe =        stk8312_probe,\n\t.remove =           stk8312_remove,\n\t.id_table =         stk8312_i2c_id,\n};\n\nmodule_i2c_driver(stk8312_driver);\n\nMODULE_AUTHOR(\"Tiberiu Breana <tiberiu.a.breana@intel.com>\");\nMODULE_DESCRIPTION(\"STK8312 3-Axis Accelerometer driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}