{
  "module_name": "bma400_spi.c",
  "hash_id": "e9c9afadf53d2f2d1f8c815ad103bebaa51b8fe17648febe0a941e6463095c93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/bma400_spi.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/init.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n\n#include \"bma400.h\"\n\n#define BMA400_MAX_SPI_READ 2\n#define BMA400_SPI_READ_BUFFER_SIZE (BMA400_MAX_SPI_READ + 1)\n\nstatic int bma400_regmap_spi_read(void *context,\n\t\t\t\t  const void *reg, size_t reg_size,\n\t\t\t\t  void *val, size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\tu8 result[BMA400_SPI_READ_BUFFER_SIZE];\n\tssize_t status;\n\n\tif (val_size > BMA400_MAX_SPI_READ)\n\t\treturn -EINVAL;\n\n\tstatus = spi_write_then_read(spi, reg, 1, result, val_size + 1);\n\tif (status)\n\t\treturn status;\n\n\t \n\tmemcpy(val, result + 1, val_size);\n\n\treturn 0;\n}\n\nstatic int bma400_regmap_spi_write(void *context, const void *data,\n\t\t\t\t   size_t count)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\n\treturn spi_write(spi, data, count);\n}\n\nstatic struct regmap_bus bma400_regmap_bus = {\n\t.read = bma400_regmap_spi_read,\n\t.write = bma400_regmap_spi_write,\n\t.read_flag_mask = BIT(7),\n\t.max_raw_read = BMA400_MAX_SPI_READ,\n};\n\nstatic int bma400_spi_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tstruct regmap *regmap;\n\tunsigned int val;\n\tint ret;\n\n\tregmap = devm_regmap_init(&spi->dev, &bma400_regmap_bus,\n\t\t\t\t  &spi->dev, &bma400_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&spi->dev, \"failed to create regmap\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\t \n\tret = regmap_read(regmap, BMA400_CHIP_ID_REG, &val);\n\tif (ret)\n\t\tdev_err(&spi->dev, \"Failed to read chip id register\\n\");\n\n\treturn bma400_probe(&spi->dev, regmap, spi->irq, id->name);\n}\n\nstatic const struct spi_device_id bma400_spi_ids[] = {\n\t{ \"bma400\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, bma400_spi_ids);\n\nstatic const struct of_device_id bma400_of_spi_match[] = {\n\t{ .compatible = \"bosch,bma400\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, bma400_of_spi_match);\n\nstatic struct spi_driver bma400_spi_driver = {\n\t.driver = {\n\t\t.name = \"bma400\",\n\t\t.of_match_table = bma400_of_spi_match,\n\t},\n\t.probe    = bma400_spi_probe,\n\t.id_table = bma400_spi_ids,\n};\n\nmodule_spi_driver(bma400_spi_driver);\nMODULE_AUTHOR(\"Dan Robertson <dan@dlrobertson.com>\");\nMODULE_DESCRIPTION(\"Bosch BMA400 triaxial acceleration sensor (SPI)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IIO_BMA400);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}