{
  "module_name": "da311.c",
  "hash_id": "f3acc4741264775144c50e4d03a5a445795f289ef34e71b56711c888c5ab3778",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/da311.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/byteorder/generic.h>\n\n#define DA311_CHIP_ID\t\t\t0x13\n\n \n\n \n#define DA311_REG_BANK\t\t\t0x0000\n#define DA311_REG_LDO_REG\t\t0x0006\n#define DA311_REG_CHIP_ID\t\t0x000f\n#define DA311_REG_TEMP_CFG_REG\t\t0x001f\n#define DA311_REG_CTRL_REG1\t\t0x0020\n#define DA311_REG_CTRL_REG3\t\t0x0022\n#define DA311_REG_CTRL_REG4\t\t0x0023\n#define DA311_REG_CTRL_REG5\t\t0x0024\n#define DA311_REG_CTRL_REG6\t\t0x0025\n#define DA311_REG_STATUS_REG\t\t0x0027\n#define DA311_REG_OUT_X_L\t\t0x0028\n#define DA311_REG_OUT_X_H\t\t0x0029\n#define DA311_REG_OUT_Y_L\t\t0x002a\n#define DA311_REG_OUT_Y_H\t\t0x002b\n#define DA311_REG_OUT_Z_L\t\t0x002c\n#define DA311_REG_OUT_Z_H\t\t0x002d\n#define DA311_REG_INT1_CFG\t\t0x0030\n#define DA311_REG_INT1_SRC\t\t0x0031\n#define DA311_REG_INT1_THS\t\t0x0032\n#define DA311_REG_INT1_DURATION\t\t0x0033\n#define DA311_REG_INT2_CFG\t\t0x0034\n#define DA311_REG_INT2_SRC\t\t0x0035\n#define DA311_REG_INT2_THS\t\t0x0036\n#define DA311_REG_INT2_DURATION\t\t0x0037\n#define DA311_REG_CLICK_CFG\t\t0x0038\n#define DA311_REG_CLICK_SRC\t\t0x0039\n#define DA311_REG_CLICK_THS\t\t0x003a\n#define DA311_REG_TIME_LIMIT\t\t0x003b\n#define DA311_REG_TIME_LATENCY\t\t0x003c\n#define DA311_REG_TIME_WINDOW\t\t0x003d\n\n \n#define DA311_REG_SOFT_RESET\t\t0x0105\n#define DA311_REG_OTP_XOFF_L\t\t0x0110\n#define DA311_REG_OTP_XOFF_H\t\t0x0111\n#define DA311_REG_OTP_YOFF_L\t\t0x0112\n#define DA311_REG_OTP_YOFF_H\t\t0x0113\n#define DA311_REG_OTP_ZOFF_L\t\t0x0114\n#define DA311_REG_OTP_ZOFF_H\t\t0x0115\n#define DA311_REG_OTP_XSO\t\t0x0116\n#define DA311_REG_OTP_YSO\t\t0x0117\n#define DA311_REG_OTP_ZSO\t\t0x0118\n#define DA311_REG_OTP_TRIM_OSC\t\t0x011b\n#define DA311_REG_LPF_ABSOLUTE\t\t0x011c\n#define DA311_REG_TEMP_OFF1\t\t0x0127\n#define DA311_REG_TEMP_OFF2\t\t0x0128\n#define DA311_REG_TEMP_OFF3\t\t0x0129\n#define DA311_REG_OTP_TRIM_THERM_H\t0x011a\n\n \n\nstatic const int da311_nscale = 9580078;\n\n#define DA311_CHANNEL(reg, axis) {\t\\\n\t.type = IIO_ACCEL,\t\\\n\t.address = reg,\t\\\n\t.modified = 1,\t\\\n\t.channel2 = IIO_MOD_##axis,\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n}\n\nstatic const struct iio_chan_spec da311_channels[] = {\n\t \n\tDA311_CHANNEL(DA311_REG_OUT_X_L | 0x80, X),\n\tDA311_CHANNEL(DA311_REG_OUT_Y_L | 0x80, Y),\n\tDA311_CHANNEL(DA311_REG_OUT_Z_L | 0x80, Z),\n};\n\nstruct da311_data {\n\tstruct i2c_client *client;\n};\n\nstatic int da311_register_mask_write(struct i2c_client *client, u16 addr,\n\t\t\t\t     u8 mask, u8 data)\n{\n\tint ret;\n\tu8 tmp_data = 0;\n\n\tif (addr & 0xff00) {\n\t\t \n\t\tret = i2c_smbus_write_byte_data(client, DA311_REG_BANK, 0x01);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (mask != 0xff) {\n\t\tret = i2c_smbus_read_byte_data(client, addr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ttmp_data = ret;\n\t}\n\n\ttmp_data &= ~mask;\n\ttmp_data |= data & mask;\n\tret = i2c_smbus_write_byte_data(client, addr & 0xff, tmp_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (addr & 0xff00) {\n\t\t \n\t\tret = i2c_smbus_write_byte_data(client, DA311_REG_BANK, 0x00);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int da311_reset(struct i2c_client *client)\n{\n\tstatic const struct {\n\t\tu16 addr;\n\t\tu8 mask;\n\t\tu8 data;\n\t} init_data[] = {\n\t\t{ DA311_REG_TEMP_CFG_REG,       0xff,   0x08 },\n\t\t{ DA311_REG_CTRL_REG5,          0xff,   0x80 },\n\t\t{ DA311_REG_CTRL_REG4,          0x30,   0x00 },\n\t\t{ DA311_REG_CTRL_REG1,          0xff,   0x6f },\n\t\t{ DA311_REG_TEMP_CFG_REG,       0xff,   0x88 },\n\t\t{ DA311_REG_LDO_REG,            0xff,   0x02 },\n\t\t{ DA311_REG_OTP_TRIM_OSC,       0xff,   0x27 },\n\t\t{ DA311_REG_LPF_ABSOLUTE,       0xff,   0x30 },\n\t\t{ DA311_REG_TEMP_OFF1,          0xff,   0x3f },\n\t\t{ DA311_REG_TEMP_OFF2,          0xff,   0xff },\n\t\t{ DA311_REG_TEMP_OFF3,          0xff,   0x0f },\n\t};\n\tint i, ret;\n\n\t \n\tret = da311_register_mask_write(client, DA311_REG_SOFT_RESET,\n\t\t\t\t\t0xff, 0xaa);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(init_data); i++) {\n\t\tret = da311_register_mask_write(client,\n\t\t\t\t\t\tinit_data[i].addr,\n\t\t\t\t\t\tinit_data[i].mask,\n\t\t\t\t\t\tinit_data[i].data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int da311_enable(struct i2c_client *client, bool enable)\n{\n\tu8 data = enable ? 0x00 : 0x20;\n\n\treturn da311_register_mask_write(client, DA311_REG_TEMP_CFG_REG,\n\t\t\t\t\t 0x20, data);\n}\n\nstatic int da311_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tstruct da311_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = i2c_smbus_read_word_data(data->client, chan->address);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\t*val = (short)ret >> 4;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = da311_nscale;\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info da311_info = {\n\t.read_raw\t= da311_read_raw,\n};\n\nstatic void da311_disable(void *client)\n{\n\tda311_enable(client, false);\n}\n\nstatic int da311_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\tstruct da311_data *data;\n\n\tret = i2c_smbus_read_byte_data(client, DA311_REG_CHIP_ID);\n\tif (ret != DA311_CHIP_ID)\n\t\treturn (ret < 0) ? ret : -ENODEV;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\n\tindio_dev->info = &da311_info;\n\tindio_dev->name = \"da311\";\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = da311_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(da311_channels);\n\n\tret = da311_reset(client);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = da311_enable(client, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&client->dev, da311_disable, client);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic int da311_suspend(struct device *dev)\n{\n\treturn da311_enable(to_i2c_client(dev), false);\n}\n\nstatic int da311_resume(struct device *dev)\n{\n\treturn da311_enable(to_i2c_client(dev), true);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(da311_pm_ops, da311_suspend, da311_resume);\n\nstatic const struct i2c_device_id da311_i2c_id[] = {\n\t{\"da311\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, da311_i2c_id);\n\nstatic struct i2c_driver da311_driver = {\n\t.driver = {\n\t\t.name = \"da311\",\n\t\t.pm = pm_sleep_ptr(&da311_pm_ops),\n\t},\n\t.probe\t\t= da311_probe,\n\t.id_table\t= da311_i2c_id,\n};\n\nmodule_i2c_driver(da311_driver);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"MiraMEMS DA311 3-Axis Accelerometer driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}