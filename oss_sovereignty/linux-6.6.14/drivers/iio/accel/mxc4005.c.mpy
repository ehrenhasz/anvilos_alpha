{
  "module_name": "mxc4005.c",
  "hash_id": "aa3308f1dc4032cbdf180ea2825ff360877dc9b9f401ed153cae4c557f238568",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/mxc4005.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/acpi.h>\n#include <linux/regmap.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#define MXC4005_DRV_NAME\t\t\"mxc4005\"\n#define MXC4005_IRQ_NAME\t\t\"mxc4005_event\"\n#define MXC4005_REGMAP_NAME\t\t\"mxc4005_regmap\"\n\n#define MXC4005_REG_XOUT_UPPER\t\t0x03\n#define MXC4005_REG_XOUT_LOWER\t\t0x04\n#define MXC4005_REG_YOUT_UPPER\t\t0x05\n#define MXC4005_REG_YOUT_LOWER\t\t0x06\n#define MXC4005_REG_ZOUT_UPPER\t\t0x07\n#define MXC4005_REG_ZOUT_LOWER\t\t0x08\n\n#define MXC4005_REG_INT_MASK1\t\t0x0B\n#define MXC4005_REG_INT_MASK1_BIT_DRDYE\t0x01\n\n#define MXC4005_REG_INT_CLR1\t\t0x01\n#define MXC4005_REG_INT_CLR1_BIT_DRDYC\t0x01\n\n#define MXC4005_REG_CONTROL\t\t0x0D\n#define MXC4005_REG_CONTROL_MASK_FSR\tGENMASK(6, 5)\n#define MXC4005_CONTROL_FSR_SHIFT\t5\n\n#define MXC4005_REG_DEVICE_ID\t\t0x0E\n\nenum mxc4005_axis {\n\tAXIS_X,\n\tAXIS_Y,\n\tAXIS_Z,\n};\n\nenum mxc4005_range {\n\tMXC4005_RANGE_2G,\n\tMXC4005_RANGE_4G,\n\tMXC4005_RANGE_8G,\n};\n\nstruct mxc4005_data {\n\tstruct device *dev;\n\tstruct mutex mutex;\n\tstruct regmap *regmap;\n\tstruct iio_trigger *dready_trig;\n\t \n\tstruct {\n\t\t__be16 chans[3];\n\t\ts64 timestamp __aligned(8);\n\t} scan;\n\tbool trigger_enabled;\n};\n\n \nstatic const struct {\n\tu8 range;\n\tint scale;\n} mxc4005_scale_table[] = {\n\t{MXC4005_RANGE_2G, 9582},\n\t{MXC4005_RANGE_4G, 19164},\n\t{MXC4005_RANGE_8G, 38329},\n};\n\n\nstatic IIO_CONST_ATTR(in_accel_scale_available, \"0.009582 0.019164 0.038329\");\n\nstatic struct attribute *mxc4005_attributes[] = {\n\t&iio_const_attr_in_accel_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mxc4005_attrs_group = {\n\t.attrs = mxc4005_attributes,\n};\n\nstatic bool mxc4005_is_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MXC4005_REG_XOUT_UPPER:\n\tcase MXC4005_REG_XOUT_LOWER:\n\tcase MXC4005_REG_YOUT_UPPER:\n\tcase MXC4005_REG_YOUT_LOWER:\n\tcase MXC4005_REG_ZOUT_UPPER:\n\tcase MXC4005_REG_ZOUT_LOWER:\n\tcase MXC4005_REG_DEVICE_ID:\n\tcase MXC4005_REG_CONTROL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool mxc4005_is_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MXC4005_REG_INT_CLR1:\n\tcase MXC4005_REG_INT_MASK1:\n\tcase MXC4005_REG_CONTROL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config mxc4005_regmap_config = {\n\t.name = MXC4005_REGMAP_NAME,\n\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = MXC4005_REG_DEVICE_ID,\n\n\t.readable_reg = mxc4005_is_readable_reg,\n\t.writeable_reg = mxc4005_is_writeable_reg,\n};\n\nstatic int mxc4005_read_xyz(struct mxc4005_data *data)\n{\n\tint ret;\n\n\tret = regmap_bulk_read(data->regmap, MXC4005_REG_XOUT_UPPER,\n\t\t\t       data->scan.chans, sizeof(data->scan.chans));\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"failed to read axes\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxc4005_read_axis(struct mxc4005_data *data,\n\t\t\t     unsigned int addr)\n{\n\t__be16 reg;\n\tint ret;\n\n\tret = regmap_bulk_read(data->regmap, addr, &reg, sizeof(reg));\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"failed to read reg %02x\\n\", addr);\n\t\treturn ret;\n\t}\n\n\treturn be16_to_cpu(reg);\n}\n\nstatic int mxc4005_read_scale(struct mxc4005_data *data)\n{\n\tunsigned int reg;\n\tint ret;\n\tint i;\n\n\tret = regmap_read(data->regmap, MXC4005_REG_CONTROL, &reg);\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"failed to read reg_control\\n\");\n\t\treturn ret;\n\t}\n\n\ti = reg >> MXC4005_CONTROL_FSR_SHIFT;\n\n\tif (i < 0 || i >= ARRAY_SIZE(mxc4005_scale_table))\n\t\treturn -EINVAL;\n\n\treturn mxc4005_scale_table[i].scale;\n}\n\nstatic int mxc4005_set_scale(struct mxc4005_data *data, int val)\n{\n\tunsigned int reg;\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(mxc4005_scale_table); i++) {\n\t\tif (mxc4005_scale_table[i].scale == val) {\n\t\t\treg = i << MXC4005_CONTROL_FSR_SHIFT;\n\t\t\tret = regmap_update_bits(data->regmap,\n\t\t\t\t\t\t MXC4005_REG_CONTROL,\n\t\t\t\t\t\t MXC4005_REG_CONTROL_MASK_FSR,\n\t\t\t\t\t\t reg);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(data->dev,\n\t\t\t\t\t\"failed to write reg_control\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mxc4005_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct mxc4005_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ACCEL:\n\t\t\tif (iio_buffer_enabled(indio_dev))\n\t\t\t\treturn -EBUSY;\n\n\t\t\tret = mxc4005_read_axis(data, chan->address);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = sign_extend32(ret >> chan->scan_type.shift,\n\t\t\t\t\t     chan->scan_type.realbits - 1);\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = mxc4005_read_scale(data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = 0;\n\t\t*val2 = ret;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mxc4005_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct mxc4005_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (val != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn mxc4005_set_scale(data, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info mxc4005_info = {\n\t.read_raw\t= mxc4005_read_raw,\n\t.write_raw\t= mxc4005_write_raw,\n\t.attrs\t\t= &mxc4005_attrs_group,\n};\n\nstatic const unsigned long mxc4005_scan_masks[] = {\n\tBIT(AXIS_X) | BIT(AXIS_Y) | BIT(AXIS_Z),\n\t0\n};\n\n#define MXC4005_CHANNEL(_axis, _addr) {\t\t\t\t\\\n\t.type = IIO_ACCEL,\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##_axis,\t\t\t\t\\\n\t.address = _addr,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.scan_index = AXIS_##_axis,\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\\\n\t\t.realbits = 12,\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\\\n\t\t.shift = 4,\t\t\t\t\t\\\n\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec mxc4005_channels[] = {\n\tMXC4005_CHANNEL(X, MXC4005_REG_XOUT_UPPER),\n\tMXC4005_CHANNEL(Y, MXC4005_REG_YOUT_UPPER),\n\tMXC4005_CHANNEL(Z, MXC4005_REG_ZOUT_UPPER),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic irqreturn_t mxc4005_trigger_handler(int irq, void *private)\n{\n\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct mxc4005_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = mxc4005_read_xyz(data);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t   pf->timestamp);\n\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mxc4005_clr_intr(struct mxc4005_data *data)\n{\n\tint ret;\n\n\t \n\tret = regmap_write(data->regmap, MXC4005_REG_INT_CLR1,\n\t\t\t   MXC4005_REG_INT_CLR1_BIT_DRDYC);\n\tif (ret < 0)\n\t\tdev_err(data->dev, \"failed to write to reg_int_clr1\\n\");\n}\n\nstatic int mxc4005_set_trigger_state(struct iio_trigger *trig,\n\t\t\t\t     bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct mxc4005_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tif (state) {\n\t\tret = regmap_write(data->regmap, MXC4005_REG_INT_MASK1,\n\t\t\t\t   MXC4005_REG_INT_MASK1_BIT_DRDYE);\n\t} else {\n\t\tret = regmap_write(data->regmap, MXC4005_REG_INT_MASK1,\n\t\t\t\t   ~MXC4005_REG_INT_MASK1_BIT_DRDYE);\n\t}\n\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->mutex);\n\t\tdev_err(data->dev, \"failed to update reg_int_mask1\");\n\t\treturn ret;\n\t}\n\n\tdata->trigger_enabled = state;\n\tmutex_unlock(&data->mutex);\n\n\treturn 0;\n}\n\nstatic void mxc4005_trigger_reen(struct iio_trigger *trig)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct mxc4005_data *data = iio_priv(indio_dev);\n\n\tif (!data->dready_trig)\n\t\treturn;\n\n\tmxc4005_clr_intr(data);\n}\n\nstatic const struct iio_trigger_ops mxc4005_trigger_ops = {\n\t.set_trigger_state = mxc4005_set_trigger_state,\n\t.reenable = mxc4005_trigger_reen,\n};\n\nstatic int mxc4005_chip_init(struct mxc4005_data *data)\n{\n\tint ret;\n\tunsigned int reg;\n\n\tret = regmap_read(data->regmap, MXC4005_REG_DEVICE_ID, &reg);\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"failed to read chip id\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(data->dev, \"MXC4005 chip id %02x\\n\", reg);\n\n\treturn 0;\n}\n\nstatic int mxc4005_probe(struct i2c_client *client)\n{\n\tstruct mxc4005_data *data;\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_i2c(client, &mxc4005_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"failed to initialize regmap\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->dev = &client->dev;\n\tdata->regmap = regmap;\n\n\tret = mxc4005_chip_init(data);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to initialize chip\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_init(&data->mutex);\n\n\tindio_dev->channels = mxc4005_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mxc4005_channels);\n\tindio_dev->available_scan_masks = mxc4005_scan_masks;\n\tindio_dev->name = MXC4005_DRV_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &mxc4005_info;\n\n\tret = devm_iio_triggered_buffer_setup(&client->dev, indio_dev,\n\t\t\t\t\t iio_pollfunc_store_time,\n\t\t\t\t\t mxc4005_trigger_handler,\n\t\t\t\t\t NULL);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to setup iio triggered buffer\\n\");\n\t\treturn ret;\n\t}\n\n\tif (client->irq > 0) {\n\t\tdata->dready_trig = devm_iio_trigger_alloc(&client->dev,\n\t\t\t\t\t\t\t   \"%s-dev%d\",\n\t\t\t\t\t\t\t   indio_dev->name,\n\t\t\t\t\t\t\t   iio_device_id(indio_dev));\n\t\tif (!data->dready_trig)\n\t\t\treturn -ENOMEM;\n\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tiio_trigger_generic_data_rdy_poll,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tMXC4005_IRQ_NAME,\n\t\t\t\t\t\tdata->dready_trig);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to init threaded irq\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->dready_trig->ops = &mxc4005_trigger_ops;\n\t\tiio_trigger_set_drvdata(data->dready_trig, indio_dev);\n\t\tret = devm_iio_trigger_register(&client->dev,\n\t\t\t\t\t\tdata->dready_trig);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to register trigger\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tindio_dev->trig = iio_trigger_get(data->dready_trig);\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct acpi_device_id mxc4005_acpi_match[] = {\n\t{\"MXC4005\",\t0},\n\t{\"MXC6655\",\t0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, mxc4005_acpi_match);\n\nstatic const struct i2c_device_id mxc4005_id[] = {\n\t{\"mxc4005\",\t0},\n\t{\"mxc6655\",\t0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, mxc4005_id);\n\nstatic struct i2c_driver mxc4005_driver = {\n\t.driver = {\n\t\t.name = MXC4005_DRV_NAME,\n\t\t.acpi_match_table = ACPI_PTR(mxc4005_acpi_match),\n\t},\n\t.probe\t\t= mxc4005_probe,\n\t.id_table\t= mxc4005_id,\n};\n\nmodule_i2c_driver(mxc4005_driver);\n\nMODULE_AUTHOR(\"Teodora Baluta <teodora.baluta@intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MXC4005 3-axis accelerometer driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}