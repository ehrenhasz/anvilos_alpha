{
  "module_name": "adxl345_core.c",
  "hash_id": "e2b34eb375e3d2afd6a737f5b34a1367c4d30cfa7efa54882d20b948a642ae21",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/adxl345_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/units.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#include \"adxl345.h\"\n\n#define ADXL345_REG_DEVID\t\t0x00\n#define ADXL345_REG_OFSX\t\t0x1e\n#define ADXL345_REG_OFSY\t\t0x1f\n#define ADXL345_REG_OFSZ\t\t0x20\n#define ADXL345_REG_OFS_AXIS(index)\t(ADXL345_REG_OFSX + (index))\n#define ADXL345_REG_BW_RATE\t\t0x2C\n#define ADXL345_REG_POWER_CTL\t\t0x2D\n#define ADXL345_REG_DATA_FORMAT\t\t0x31\n#define ADXL345_REG_DATAX0\t\t0x32\n#define ADXL345_REG_DATAY0\t\t0x34\n#define ADXL345_REG_DATAZ0\t\t0x36\n#define ADXL345_REG_DATA_AXIS(index)\t\\\n\t(ADXL345_REG_DATAX0 + (index) * sizeof(__le16))\n\n#define ADXL345_BW_RATE\t\t\tGENMASK(3, 0)\n#define ADXL345_BASE_RATE_NANO_HZ\t97656250LL\n\n#define ADXL345_POWER_CTL_MEASURE\tBIT(3)\n#define ADXL345_POWER_CTL_STANDBY\t0x00\n\n#define ADXL345_DATA_FORMAT_FULL_RES\tBIT(3)  \n#define ADXL345_DATA_FORMAT_2G\t\t0\n#define ADXL345_DATA_FORMAT_4G\t\t1\n#define ADXL345_DATA_FORMAT_8G\t\t2\n#define ADXL345_DATA_FORMAT_16G\t\t3\n\n#define ADXL345_DEVID\t\t\t0xE5\n\n \nstatic const int adxl345_uscale = 38300;\n\n \nstatic const int adxl375_uscale = 480000;\n\nstruct adxl345_data {\n\tstruct regmap *regmap;\n\tu8 data_range;\n\tenum adxl345_device_type type;\n};\n\n#define ADXL345_CHANNEL(index, axis) {\t\t\t\t\t\\\n\t.type = IIO_ACCEL,\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##axis,\t\t\t\t\t\\\n\t.address = index,\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\t\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec adxl345_channels[] = {\n\tADXL345_CHANNEL(0, X),\n\tADXL345_CHANNEL(1, Y),\n\tADXL345_CHANNEL(2, Z),\n};\n\nstatic int adxl345_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct adxl345_data *data = iio_priv(indio_dev);\n\t__le16 accel;\n\tlong long samp_freq_nhz;\n\tunsigned int regval;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t \n\t\tret = regmap_bulk_read(data->regmap,\n\t\t\t\t       ADXL345_REG_DATA_AXIS(chan->address),\n\t\t\t\t       &accel, sizeof(accel));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = sign_extend32(le16_to_cpu(accel), 12);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\tswitch (data->type) {\n\t\tcase ADXL345:\n\t\t\t*val2 = adxl345_uscale;\n\t\t\tbreak;\n\t\tcase ADXL375:\n\t\t\t*val2 = adxl375_uscale;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = regmap_read(data->regmap,\n\t\t\t\t  ADXL345_REG_OFS_AXIS(chan->address), &regval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\t*val = sign_extend32(regval, 7) * 4;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = regmap_read(data->regmap, ADXL345_REG_BW_RATE, &regval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tsamp_freq_nhz = ADXL345_BASE_RATE_NANO_HZ <<\n\t\t\t\t(regval & ADXL345_BW_RATE);\n\t\t*val = div_s64_rem(samp_freq_nhz, NANOHZ_PER_HZ, val2);\n\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int adxl345_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct adxl345_data *data = iio_priv(indio_dev);\n\ts64 n;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\t \n\t\treturn regmap_write(data->regmap,\n\t\t\t\t    ADXL345_REG_OFS_AXIS(chan->address),\n\t\t\t\t    val / 4);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tn = div_s64(val * NANOHZ_PER_HZ + val2,\n\t\t\t    ADXL345_BASE_RATE_NANO_HZ);\n\n\t\treturn regmap_update_bits(data->regmap, ADXL345_REG_BW_RATE,\n\t\t\t\t\t  ADXL345_BW_RATE,\n\t\t\t\t\t  clamp_val(ilog2(n), 0,\n\t\t\t\t\t\t    ADXL345_BW_RATE));\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int adxl345_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t\t     long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\n\"0.09765625 0.1953125 0.390625 0.78125 1.5625 3.125 6.25 12.5 25 50 100 200 400 800 1600 3200\"\n);\n\nstatic struct attribute *adxl345_attrs[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adxl345_attrs_group = {\n\t.attrs = adxl345_attrs,\n};\n\nstatic const struct iio_info adxl345_info = {\n\t.attrs\t\t= &adxl345_attrs_group,\n\t.read_raw\t= adxl345_read_raw,\n\t.write_raw\t= adxl345_write_raw,\n\t.write_raw_get_fmt\t= adxl345_write_raw_get_fmt,\n};\n\nstatic int adxl345_powerup(void *regmap)\n{\n\treturn regmap_write(regmap, ADXL345_REG_POWER_CTL, ADXL345_POWER_CTL_MEASURE);\n}\n\nstatic void adxl345_powerdown(void *regmap)\n{\n\tregmap_write(regmap, ADXL345_REG_POWER_CTL, ADXL345_POWER_CTL_STANDBY);\n}\n\nint adxl345_core_probe(struct device *dev, struct regmap *regmap)\n{\n\tenum adxl345_device_type type;\n\tstruct adxl345_data *data;\n\tstruct iio_dev *indio_dev;\n\tconst char *name;\n\tu32 regval;\n\tint ret;\n\n\ttype = (uintptr_t)device_get_match_data(dev);\n\tswitch (type) {\n\tcase ADXL345:\n\t\tname = \"adxl345\";\n\t\tbreak;\n\tcase ADXL375:\n\t\tname = \"adxl375\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_read(regmap, ADXL345_REG_DEVID, &regval);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Error reading device ID\\n\");\n\n\tif (regval != ADXL345_DEVID)\n\t\treturn dev_err_probe(dev, -ENODEV, \"Invalid device ID: %x, expected %x\\n\",\n\t\t\t\t     regval, ADXL345_DEVID);\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->regmap = regmap;\n\tdata->type = type;\n\t \n\tdata->data_range = ADXL345_DATA_FORMAT_FULL_RES;\n\n\tret = regmap_write(data->regmap, ADXL345_REG_DATA_FORMAT,\n\t\t\t   data->data_range);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Failed to set data range\\n\");\n\n\tindio_dev->name = name;\n\tindio_dev->info = &adxl345_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = adxl345_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adxl345_channels);\n\n\t \n\tret = adxl345_powerup(data->regmap);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Failed to enable measurement mode\\n\");\n\n\tret = devm_add_action_or_reset(dev, adxl345_powerdown, data->regmap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(adxl345_core_probe, IIO_ADXL345);\n\nMODULE_AUTHOR(\"Eva Rachel Retuya <eraretuya@gmail.com>\");\nMODULE_DESCRIPTION(\"ADXL345 3-Axis Digital Accelerometer core driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}