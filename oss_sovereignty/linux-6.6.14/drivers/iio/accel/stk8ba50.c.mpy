{
  "module_name": "stk8ba50.c",
  "hash_id": "2d3beecf1b4784d4c79ad2d456b2c880f66b6a91f6752e74c79528faf3e928e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/stk8ba50.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#define STK8BA50_REG_XOUT\t\t\t0x02\n#define STK8BA50_REG_YOUT\t\t\t0x04\n#define STK8BA50_REG_ZOUT\t\t\t0x06\n#define STK8BA50_REG_RANGE\t\t\t0x0F\n#define STK8BA50_REG_BWSEL\t\t\t0x10\n#define STK8BA50_REG_POWMODE\t\t\t0x11\n#define STK8BA50_REG_SWRST\t\t\t0x14\n#define STK8BA50_REG_INTEN2\t\t\t0x17\n#define STK8BA50_REG_INTMAP2\t\t\t0x1A\n\n#define STK8BA50_MODE_NORMAL\t\t\t0\n#define STK8BA50_MODE_SUSPEND\t\t\t1\n#define STK8BA50_MODE_POWERBIT\t\t\tBIT(7)\n#define STK8BA50_DATA_SHIFT\t\t\t6\n#define STK8BA50_RESET_CMD\t\t\t0xB6\n#define STK8BA50_SR_1792HZ_IDX\t\t\t7\n#define STK8BA50_DREADY_INT_MASK\t\t0x10\n#define STK8BA50_DREADY_INT_MAP\t\t\t0x81\n#define STK8BA50_ALL_CHANNEL_MASK\t\t7\n#define STK8BA50_ALL_CHANNEL_SIZE\t\t6\n\n#define STK8BA50_DRIVER_NAME\t\t\t\"stk8ba50\"\n#define STK8BA50_IRQ_NAME\t\t\t\"stk8ba50_event\"\n\n#define STK8BA50_SCALE_AVAIL\t\t\t\"0.0384 0.0767 0.1534 0.3069\"\n\n \nstatic const struct {\n\tu8 reg_val;\n\tu32 scale_val;\n} stk8ba50_scale_table[] = {\n\t{3, 38400}, {5, 76700}, {8, 153400}, {12, 306900}\n};\n\n \nstatic const struct {\n\tu8 reg_val;\n\tu16 samp_freq;\n} stk8ba50_samp_freq_table[] = {\n\t{0x08, 14},  {0x09, 25},  {0x0A, 56},  {0x0B, 112},\n\t{0x0C, 224}, {0x0D, 448}, {0x0E, 896}, {0x0F, 1792}\n};\n\n \nstatic const int stk8ba50_channel_table[] = {\n\tSTK8BA50_REG_XOUT,\n\tSTK8BA50_REG_YOUT,\n\tSTK8BA50_REG_ZOUT\n};\n\nstruct stk8ba50_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tint range;\n\tu8 sample_rate_idx;\n\tstruct iio_trigger *dready_trig;\n\tbool dready_trigger_on;\n\t \n\tstruct {\n\t\ts16 chans[3];\n\t\ts64 timetamp __aligned(8);\n\t} scan;\n};\n\n#define STK8BA50_ACCEL_CHANNEL(index, reg, axis) {\t\t\t\\\n\t.type = IIO_ACCEL,\t\t\t\t\t\t\\\n\t.address = reg,\t\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##axis,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t\t\t\t    BIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n\t.scan_index = index,\t\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\t\\\n\t\t.realbits = 10,\t\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\t\\\n\t\t.shift = STK8BA50_DATA_SHIFT,\t\t\t\t\\\n\t\t.endianness = IIO_CPU,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec stk8ba50_channels[] = {\n\tSTK8BA50_ACCEL_CHANNEL(0, STK8BA50_REG_XOUT, X),\n\tSTK8BA50_ACCEL_CHANNEL(1, STK8BA50_REG_YOUT, Y),\n\tSTK8BA50_ACCEL_CHANNEL(2, STK8BA50_REG_ZOUT, Z),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic IIO_CONST_ATTR(in_accel_scale_available, STK8BA50_SCALE_AVAIL);\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\"14 25 56 112 224 448 896 1792\");\n\nstatic struct attribute *stk8ba50_attributes[] = {\n\t&iio_const_attr_in_accel_scale_available.dev_attr.attr,\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group stk8ba50_attribute_group = {\n\t.attrs = stk8ba50_attributes\n};\n\nstatic int stk8ba50_read_accel(struct stk8ba50_data *data, u8 reg)\n{\n\tint ret;\n\tstruct i2c_client *client = data->client;\n\n\tret = i2c_smbus_read_word_data(client, reg);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"register read failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int stk8ba50_data_rdy_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t       bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct stk8ba50_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (state)\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\tSTK8BA50_REG_INTEN2, STK8BA50_DREADY_INT_MASK);\n\telse\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\tSTK8BA50_REG_INTEN2, 0x00);\n\n\tif (ret < 0)\n\t\tdev_err(&data->client->dev, \"failed to set trigger state\\n\");\n\telse\n\t\tdata->dready_trigger_on = state;\n\n\treturn ret;\n}\n\nstatic const struct iio_trigger_ops stk8ba50_trigger_ops = {\n\t.set_trigger_state = stk8ba50_data_rdy_trigger_set_state,\n};\n\nstatic int stk8ba50_set_power(struct stk8ba50_data *data, bool mode)\n{\n\tint ret;\n\tu8 masked_reg;\n\tstruct i2c_client *client = data->client;\n\n\tret = i2c_smbus_read_byte_data(client, STK8BA50_REG_POWMODE);\n\tif (ret < 0)\n\t\tgoto exit_err;\n\n\tif (mode)\n\t\tmasked_reg = ret | STK8BA50_MODE_POWERBIT;\n\telse\n\t\tmasked_reg = ret & (~STK8BA50_MODE_POWERBIT);\n\n\tret = i2c_smbus_write_byte_data(client, STK8BA50_REG_POWMODE,\n\t\t\t\t\tmasked_reg);\n\tif (ret < 0)\n\t\tgoto exit_err;\n\n\treturn ret;\n\nexit_err:\n\tdev_err(&client->dev, \"failed to change sensor mode\\n\");\n\treturn ret;\n}\n\nstatic int stk8ba50_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct stk8ba50_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (iio_buffer_enabled(indio_dev))\n\t\t\treturn -EBUSY;\n\t\tmutex_lock(&data->lock);\n\t\tret = stk8ba50_set_power(data, STK8BA50_MODE_NORMAL);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = stk8ba50_read_accel(data, chan->address);\n\t\tif (ret < 0) {\n\t\t\tstk8ba50_set_power(data, STK8BA50_MODE_SUSPEND);\n\t\t\tmutex_unlock(&data->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*val = sign_extend32(ret >> chan->scan_type.shift,\n\t\t\t\t     chan->scan_type.realbits - 1);\n\t\tstk8ba50_set_power(data, STK8BA50_MODE_SUSPEND);\n\t\tmutex_unlock(&data->lock);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = stk8ba50_scale_table[data->range].scale_val;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = stk8ba50_samp_freq_table\n\t\t\t\t[data->sample_rate_idx].samp_freq;\n\t\t*val2 = 0;\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stk8ba50_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tint ret;\n\tint i;\n\tint index = -1;\n\tstruct stk8ba50_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (val != 0)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(stk8ba50_scale_table); i++)\n\t\t\tif (val2 == stk8ba50_scale_table[i].scale_val) {\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (index < 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\tSTK8BA50_REG_RANGE,\n\t\t\t\tstk8ba50_scale_table[index].reg_val);\n\t\tif (ret < 0)\n\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\t\"failed to set measurement range\\n\");\n\t\telse\n\t\t\tdata->range = index;\n\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tfor (i = 0; i < ARRAY_SIZE(stk8ba50_samp_freq_table); i++)\n\t\t\tif (val == stk8ba50_samp_freq_table[i].samp_freq) {\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (index < 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\tSTK8BA50_REG_BWSEL,\n\t\t\t\tstk8ba50_samp_freq_table[index].reg_val);\n\t\tif (ret < 0)\n\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\t\"failed to set sampling rate\\n\");\n\t\telse\n\t\t\tdata->sample_rate_idx = index;\n\n\t\treturn ret;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info stk8ba50_info = {\n\t.read_raw\t\t= stk8ba50_read_raw,\n\t.write_raw\t\t= stk8ba50_write_raw,\n\t.attrs\t\t\t= &stk8ba50_attribute_group,\n};\n\nstatic irqreturn_t stk8ba50_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct stk8ba50_data *data = iio_priv(indio_dev);\n\tint bit, ret, i = 0;\n\n\tmutex_lock(&data->lock);\n\t \n\tif (*(indio_dev->active_scan_mask) == STK8BA50_ALL_CHANNEL_MASK) {\n\t\tret = i2c_smbus_read_i2c_block_data(data->client,\n\t\t\t\t\t\t    STK8BA50_REG_XOUT,\n\t\t\t\t\t\t    STK8BA50_ALL_CHANNEL_SIZE,\n\t\t\t\t\t\t    (u8 *)data->scan.chans);\n\t\tif (ret < STK8BA50_ALL_CHANNEL_SIZE) {\n\t\t\tdev_err(&data->client->dev, \"register read failed\\n\");\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t\t indio_dev->masklength) {\n\t\t\tret = stk8ba50_read_accel(data,\n\t\t\t\t\t\t  stk8ba50_channel_table[bit]);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\tdata->scan.chans[i++] = ret;\n\t\t}\n\t}\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t   pf->timestamp);\nerr:\n\tmutex_unlock(&data->lock);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t stk8ba50_data_rdy_trig_poll(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct stk8ba50_data *data = iio_priv(indio_dev);\n\n\tif (data->dready_trigger_on)\n\t\tiio_trigger_poll(data->dready_trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int stk8ba50_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct stk8ba50_data *data = iio_priv(indio_dev);\n\n\treturn stk8ba50_set_power(data, STK8BA50_MODE_NORMAL);\n}\n\nstatic int stk8ba50_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct stk8ba50_data *data = iio_priv(indio_dev);\n\n\treturn stk8ba50_set_power(data, STK8BA50_MODE_SUSPEND);\n}\n\nstatic const struct iio_buffer_setup_ops stk8ba50_buffer_setup_ops = {\n\t.preenable   = stk8ba50_buffer_preenable,\n\t.postdisable = stk8ba50_buffer_postdisable,\n};\n\nstatic int stk8ba50_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\tstruct stk8ba50_data *data;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev) {\n\t\tdev_err(&client->dev, \"iio allocation failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\ti2c_set_clientdata(client, indio_dev);\n\tmutex_init(&data->lock);\n\n\tindio_dev->info = &stk8ba50_info;\n\tindio_dev->name = STK8BA50_DRIVER_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = stk8ba50_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(stk8ba50_channels);\n\n\t \n\tret = i2c_smbus_write_byte_data(client,\n\t\t\tSTK8BA50_REG_SWRST, STK8BA50_RESET_CMD);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to reset sensor\\n\");\n\t\tgoto err_power_off;\n\t}\n\n\t \n\tdata->range = 0;\n\n\t \n\tdata->sample_rate_idx = STK8BA50_SR_1792HZ_IDX;\n\n\t \n\tret = i2c_smbus_write_byte_data(client,\n\t\t\tSTK8BA50_REG_INTEN2, STK8BA50_DREADY_INT_MASK);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to set up interrupts\\n\");\n\t\tgoto err_power_off;\n\t}\n\tret = i2c_smbus_write_byte_data(client,\n\t\t\tSTK8BA50_REG_INTMAP2, STK8BA50_DREADY_INT_MAP);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to set up interrupts\\n\");\n\t\tgoto err_power_off;\n\t}\n\n\tif (client->irq > 0) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tstk8ba50_data_rdy_trig_poll,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tSTK8BA50_IRQ_NAME,\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"request irq %d failed\\n\",\n\t\t\t\tclient->irq);\n\t\t\tgoto err_power_off;\n\t\t}\n\n\t\tdata->dready_trig = devm_iio_trigger_alloc(&client->dev,\n\t\t\t\t\t\t\t   \"%s-dev%d\",\n\t\t\t\t\t\t\t   indio_dev->name,\n\t\t\t\t\t\t\t   iio_device_id(indio_dev));\n\t\tif (!data->dready_trig) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_power_off;\n\t\t}\n\n\t\tdata->dready_trig->ops = &stk8ba50_trigger_ops;\n\t\tiio_trigger_set_drvdata(data->dready_trig, indio_dev);\n\t\tret = iio_trigger_register(data->dready_trig);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"iio trigger register failed\\n\");\n\t\t\tgoto err_power_off;\n\t\t}\n\t}\n\n\tret = iio_triggered_buffer_setup(indio_dev,\n\t\t\t\t\t iio_pollfunc_store_time,\n\t\t\t\t\t stk8ba50_trigger_handler,\n\t\t\t\t\t &stk8ba50_buffer_setup_ops);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"iio triggered buffer setup failed\\n\");\n\t\tgoto err_trigger_unregister;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"device_register failed\\n\");\n\t\tgoto err_buffer_cleanup;\n\t}\n\n\treturn ret;\n\nerr_buffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\nerr_trigger_unregister:\n\tif (data->dready_trig)\n\t\tiio_trigger_unregister(data->dready_trig);\nerr_power_off:\n\tstk8ba50_set_power(data, STK8BA50_MODE_SUSPEND);\n\treturn ret;\n}\n\nstatic void stk8ba50_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct stk8ba50_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\n\tif (data->dready_trig)\n\t\tiio_trigger_unregister(data->dready_trig);\n\n\tstk8ba50_set_power(data, STK8BA50_MODE_SUSPEND);\n}\n\nstatic int stk8ba50_suspend(struct device *dev)\n{\n\tstruct stk8ba50_data *data;\n\n\tdata = iio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\n\treturn stk8ba50_set_power(data, STK8BA50_MODE_SUSPEND);\n}\n\nstatic int stk8ba50_resume(struct device *dev)\n{\n\tstruct stk8ba50_data *data;\n\n\tdata = iio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\n\treturn stk8ba50_set_power(data, STK8BA50_MODE_NORMAL);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(stk8ba50_pm_ops, stk8ba50_suspend,\n\t\t\t\tstk8ba50_resume);\n\nstatic const struct i2c_device_id stk8ba50_i2c_id[] = {\n\t{\"stk8ba50\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, stk8ba50_i2c_id);\n\nstatic const struct acpi_device_id stk8ba50_acpi_id[] = {\n\t{\"STK8BA50\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(acpi, stk8ba50_acpi_id);\n\nstatic struct i2c_driver stk8ba50_driver = {\n\t.driver = {\n\t\t.name = \"stk8ba50\",\n\t\t.pm = pm_sleep_ptr(&stk8ba50_pm_ops),\n\t\t.acpi_match_table = ACPI_PTR(stk8ba50_acpi_id),\n\t},\n\t.probe =        stk8ba50_probe,\n\t.remove =           stk8ba50_remove,\n\t.id_table =         stk8ba50_i2c_id,\n};\n\nmodule_i2c_driver(stk8ba50_driver);\n\nMODULE_AUTHOR(\"Tiberiu Breana <tiberiu.a.breana@intel.com>\");\nMODULE_DESCRIPTION(\"STK8BA50 3-Axis Accelerometer driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}