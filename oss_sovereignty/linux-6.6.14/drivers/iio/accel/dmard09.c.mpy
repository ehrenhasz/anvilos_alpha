{
  "module_name": "dmard09.c",
  "hash_id": "d75462fee82f10155e25c5a8b1d41d675708941916c5ed2afaa3316028a15660",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/dmard09.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n\n#define DMARD09_DRV_NAME\t\"dmard09\"\n\n#define DMARD09_REG_CHIPID      0x18\n#define DMARD09_REG_STAT\t0x0A\n#define DMARD09_REG_X\t\t0x0C\n#define DMARD09_REG_Y\t\t0x0E\n#define DMARD09_REG_Z\t\t0x10\n#define DMARD09_CHIPID\t\t0x95\n\n#define DMARD09_BUF_LEN 8\n#define DMARD09_AXIS_X 0\n#define DMARD09_AXIS_Y 1\n#define DMARD09_AXIS_Z 2\n#define DMARD09_AXIS_X_OFFSET ((DMARD09_AXIS_X + 1) * 2)\n#define DMARD09_AXIS_Y_OFFSET ((DMARD09_AXIS_Y + 1) * 2)\n#define DMARD09_AXIS_Z_OFFSET ((DMARD09_AXIS_Z + 1) * 2)\n\nstruct dmard09_data {\n\tstruct i2c_client *client;\n};\n\n#define DMARD09_CHANNEL(_axis, offset) {\t\t\t\\\n\t.type = IIO_ACCEL,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.modified = 1,\t\t\t\t\t\t\\\n\t.address = offset,\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##_axis,\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec dmard09_channels[] = {\n\tDMARD09_CHANNEL(X, DMARD09_AXIS_X_OFFSET),\n\tDMARD09_CHANNEL(Y, DMARD09_AXIS_Y_OFFSET),\n\tDMARD09_CHANNEL(Z, DMARD09_AXIS_Z_OFFSET),\n};\n\nstatic int dmard09_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct dmard09_data *data = iio_priv(indio_dev);\n\tu8 buf[DMARD09_BUF_LEN];\n\tint ret;\n\ts16 accel;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t \n\t\tret = i2c_smbus_read_i2c_block_data(data->client,\n\t\t\t\t\t\t    DMARD09_REG_STAT,\n\t\t\t\t\t\t    DMARD09_BUF_LEN, buf);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&data->client->dev, \"Error reading reg %d\\n\",\n\t\t\t\tDMARD09_REG_STAT);\n\t\t\treturn ret;\n\t\t}\n\n\t\taccel = get_unaligned_le16(&buf[chan->address]);\n\n\t\t \n\t\taccel <<= 4;\n\t\taccel >>= 7;\n\n\t\t*val = accel;\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info dmard09_info = {\n\t.read_raw\t= dmard09_read_raw,\n};\n\nstatic int dmard09_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\tstruct dmard09_data *data;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev) {\n\t\tdev_err(&client->dev, \"iio allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\n\tret = i2c_smbus_read_byte_data(data->client, DMARD09_REG_CHIPID);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Error reading chip id %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ret != DMARD09_CHIPID) {\n\t\tdev_err(&client->dev, \"Invalid chip id %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\ti2c_set_clientdata(client, indio_dev);\n\tindio_dev->name = DMARD09_DRV_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = dmard09_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(dmard09_channels);\n\tindio_dev->info = &dmard09_info;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id dmard09_id[] = {\n\t{ \"dmard09\", 0 },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(i2c, dmard09_id);\n\nstatic struct i2c_driver dmard09_driver = {\n\t.driver = {\n\t\t.name = DMARD09_DRV_NAME\n\t},\n\t.probe = dmard09_probe,\n\t.id_table = dmard09_id,\n};\n\nmodule_i2c_driver(dmard09_driver);\n\nMODULE_AUTHOR(\"Jelle van der Waa <jelle@vdwaa.nl>\");\nMODULE_DESCRIPTION(\"DMARD09 3-axis accelerometer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}