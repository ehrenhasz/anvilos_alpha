{
  "module_name": "adxl367.c",
  "hash_id": "934305d1e08f7ea12e79dee5097425530a85952e49e110dfa0c9708cfc684c3f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/adxl367.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/kfifo_buf.h>\n#include <linux/iio/sysfs.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/mod_devicetable.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <asm/unaligned.h>\n\n#include \"adxl367.h\"\n\n#define ADXL367_REG_DEVID\t\t0x00\n#define ADXL367_DEVID_AD\t\t0xAD\n\n#define ADXL367_REG_STATUS\t\t0x0B\n#define ADXL367_STATUS_INACT_MASK\tBIT(5)\n#define ADXL367_STATUS_ACT_MASK\t\tBIT(4)\n#define ADXL367_STATUS_FIFO_FULL_MASK\tBIT(2)\n\n#define ADXL367_FIFO_ENT_H_MASK\t\tGENMASK(1, 0)\n\n#define ADXL367_REG_X_DATA_H\t\t0x0E\n#define ADXL367_REG_Y_DATA_H\t\t0x10\n#define ADXL367_REG_Z_DATA_H\t\t0x12\n#define ADXL367_REG_TEMP_DATA_H\t\t0x14\n#define ADXL367_REG_EX_ADC_DATA_H\t0x16\n#define ADXL367_DATA_MASK\t\tGENMASK(15, 2)\n\n#define ADXL367_TEMP_25C\t\t165\n#define ADXL367_TEMP_PER_C\t\t54\n\n#define ADXL367_VOLTAGE_OFFSET\t\t8192\n#define ADXL367_VOLTAGE_MAX_MV\t\t1000\n#define ADXL367_VOLTAGE_MAX_RAW\t\tGENMASK(13, 0)\n\n#define ADXL367_REG_RESET\t\t0x1F\n#define ADXL367_RESET_CODE\t\t0x52\n\n#define ADXL367_REG_THRESH_ACT_H\t0x20\n#define ADXL367_REG_THRESH_INACT_H\t0x23\n#define ADXL367_THRESH_MAX\t\tGENMASK(12, 0)\n#define ADXL367_THRESH_VAL_H_MASK\tGENMASK(12, 6)\n#define ADXL367_THRESH_H_MASK\t\tGENMASK(6, 0)\n#define ADXL367_THRESH_VAL_L_MASK\tGENMASK(5, 0)\n#define ADXL367_THRESH_L_MASK\t\tGENMASK(7, 2)\n\n#define ADXL367_REG_TIME_ACT\t\t0x22\n#define ADXL367_REG_TIME_INACT_H\t0x25\n#define ADXL367_TIME_ACT_MAX\t\tGENMASK(7, 0)\n#define ADXL367_TIME_INACT_MAX\t\tGENMASK(15, 0)\n#define ADXL367_TIME_INACT_VAL_H_MASK\tGENMASK(15, 8)\n#define ADXL367_TIME_INACT_H_MASK\tGENMASK(7, 0)\n#define ADXL367_TIME_INACT_VAL_L_MASK\tGENMASK(7, 0)\n#define ADXL367_TIME_INACT_L_MASK\tGENMASK(7, 0)\n\n#define ADXL367_REG_ACT_INACT_CTL\t0x27\n#define ADXL367_ACT_EN_MASK\t\tGENMASK(1, 0)\n#define ADXL367_ACT_LINKLOOP_MASK\tGENMASK(5, 4)\n\n#define ADXL367_REG_FIFO_CTL\t\t0x28\n#define ADXL367_FIFO_CTL_FORMAT_MASK\tGENMASK(6, 3)\n#define ADXL367_FIFO_CTL_MODE_MASK\tGENMASK(1, 0)\n\n#define ADXL367_REG_FIFO_SAMPLES\t0x29\n#define ADXL367_FIFO_SIZE\t\t512\n#define ADXL367_FIFO_MAX_WATERMARK\t511\n\n#define ADXL367_SAMPLES_VAL_H_MASK\tBIT(8)\n#define ADXL367_SAMPLES_H_MASK\t\tBIT(2)\n#define ADXL367_SAMPLES_VAL_L_MASK\tGENMASK(7, 0)\n#define ADXL367_SAMPLES_L_MASK\t\tGENMASK(7, 0)\n\n#define ADXL367_REG_INT1_MAP\t\t0x2A\n#define ADXL367_INT_INACT_MASK\t\tBIT(5)\n#define ADXL367_INT_ACT_MASK\t\tBIT(4)\n#define ADXL367_INT_FIFO_WATERMARK_MASK\tBIT(2)\n\n#define ADXL367_REG_FILTER_CTL\t\t0x2C\n#define ADXL367_FILTER_CTL_RANGE_MASK\tGENMASK(7, 6)\n#define ADXL367_2G_RANGE_1G\t\t4095\n#define ADXL367_2G_RANGE_100MG\t\t409\n#define ADXL367_FILTER_CTL_ODR_MASK\tGENMASK(2, 0)\n\n#define ADXL367_REG_POWER_CTL\t\t0x2D\n#define ADXL367_POWER_CTL_MODE_MASK\tGENMASK(1, 0)\n\n#define ADXL367_REG_ADC_CTL\t\t0x3C\n#define ADXL367_REG_TEMP_CTL\t\t0x3D\n#define ADXL367_ADC_EN_MASK\t\tBIT(0)\n\nenum adxl367_range {\n\tADXL367_2G_RANGE,\n\tADXL367_4G_RANGE,\n\tADXL367_8G_RANGE,\n};\n\nenum adxl367_fifo_mode {\n\tADXL367_FIFO_MODE_DISABLED = 0b00,\n\tADXL367_FIFO_MODE_STREAM = 0b10,\n};\n\nenum adxl367_fifo_format {\n\tADXL367_FIFO_FORMAT_XYZ,\n\tADXL367_FIFO_FORMAT_X,\n\tADXL367_FIFO_FORMAT_Y,\n\tADXL367_FIFO_FORMAT_Z,\n\tADXL367_FIFO_FORMAT_XYZT,\n\tADXL367_FIFO_FORMAT_XT,\n\tADXL367_FIFO_FORMAT_YT,\n\tADXL367_FIFO_FORMAT_ZT,\n\tADXL367_FIFO_FORMAT_XYZA,\n\tADXL367_FIFO_FORMAT_XA,\n\tADXL367_FIFO_FORMAT_YA,\n\tADXL367_FIFO_FORMAT_ZA,\n};\n\nenum adxl367_op_mode {\n\tADXL367_OP_STANDBY = 0b00,\n\tADXL367_OP_MEASURE = 0b10,\n};\n\nenum adxl367_act_proc_mode {\n\tADXL367_LOOPED = 0b11,\n};\n\nenum adxl367_act_en_mode {\n\tADXL367_ACT_DISABLED = 0b00,\n\tADCL367_ACT_REF_ENABLED = 0b11,\n};\n\nenum adxl367_activity_type {\n\tADXL367_ACTIVITY,\n\tADXL367_INACTIVITY,\n};\n\nenum adxl367_odr {\n\tADXL367_ODR_12P5HZ,\n\tADXL367_ODR_25HZ,\n\tADXL367_ODR_50HZ,\n\tADXL367_ODR_100HZ,\n\tADXL367_ODR_200HZ,\n\tADXL367_ODR_400HZ,\n};\n\nstruct adxl367_state {\n\tconst struct adxl367_ops\t*ops;\n\tvoid\t\t\t\t*context;\n\n\tstruct device\t\t\t*dev;\n\tstruct regmap\t\t\t*regmap;\n\n\t \n\tstruct mutex\t\tlock;\n\n\tenum adxl367_odr\todr;\n\tenum adxl367_range\trange;\n\n\tunsigned int\tact_threshold;\n\tunsigned int\tact_time_ms;\n\tunsigned int\tinact_threshold;\n\tunsigned int\tinact_time_ms;\n\n\tunsigned int\tfifo_set_size;\n\tunsigned int\tfifo_watermark;\n\n\t__be16\t\tfifo_buf[ADXL367_FIFO_SIZE] __aligned(IIO_DMA_MINALIGN);\n\t__be16\t\tsample_buf;\n\tu8\t\tact_threshold_buf[2];\n\tu8\t\tinact_time_buf[2];\n\tu8\t\tstatus_buf[3];\n};\n\nstatic const unsigned int adxl367_threshold_h_reg_tbl[] = {\n\t[ADXL367_ACTIVITY]   = ADXL367_REG_THRESH_ACT_H,\n\t[ADXL367_INACTIVITY] = ADXL367_REG_THRESH_INACT_H,\n};\n\nstatic const unsigned int adxl367_act_en_shift_tbl[] = {\n\t[ADXL367_ACTIVITY]   = 0,\n\t[ADXL367_INACTIVITY] = 2,\n};\n\nstatic const unsigned int adxl367_act_int_mask_tbl[] = {\n\t[ADXL367_ACTIVITY]   = ADXL367_INT_ACT_MASK,\n\t[ADXL367_INACTIVITY] = ADXL367_INT_INACT_MASK,\n};\n\nstatic const int adxl367_samp_freq_tbl[][2] = {\n\t[ADXL367_ODR_12P5HZ] = {12, 500000},\n\t[ADXL367_ODR_25HZ]   = {25, 0},\n\t[ADXL367_ODR_50HZ]   = {50, 0},\n\t[ADXL367_ODR_100HZ]  = {100, 0},\n\t[ADXL367_ODR_200HZ]  = {200, 0},\n\t[ADXL367_ODR_400HZ]  = {400, 0},\n};\n\n \nstatic const int adxl367_range_scale_tbl[][2] = {\n\t[ADXL367_2G_RANGE] = {0, 2394347},\n\t[ADXL367_4G_RANGE] = {0, 4788695},\n\t[ADXL367_8G_RANGE] = {0, 9577391},\n};\n\nstatic const int adxl367_range_scale_factor_tbl[] = {\n\t[ADXL367_2G_RANGE] = 1,\n\t[ADXL367_4G_RANGE] = 2,\n\t[ADXL367_8G_RANGE] = 4,\n};\n\nenum {\n\tADXL367_X_CHANNEL_INDEX,\n\tADXL367_Y_CHANNEL_INDEX,\n\tADXL367_Z_CHANNEL_INDEX,\n\tADXL367_TEMP_CHANNEL_INDEX,\n\tADXL367_EX_ADC_CHANNEL_INDEX\n};\n\n#define ADXL367_X_CHANNEL_MASK\t\tBIT(ADXL367_X_CHANNEL_INDEX)\n#define ADXL367_Y_CHANNEL_MASK\t\tBIT(ADXL367_Y_CHANNEL_INDEX)\n#define ADXL367_Z_CHANNEL_MASK\t\tBIT(ADXL367_Z_CHANNEL_INDEX)\n#define ADXL367_TEMP_CHANNEL_MASK\tBIT(ADXL367_TEMP_CHANNEL_INDEX)\n#define ADXL367_EX_ADC_CHANNEL_MASK\tBIT(ADXL367_EX_ADC_CHANNEL_INDEX)\n\nstatic const enum adxl367_fifo_format adxl367_fifo_formats[] = {\n\tADXL367_FIFO_FORMAT_X,\n\tADXL367_FIFO_FORMAT_Y,\n\tADXL367_FIFO_FORMAT_Z,\n\tADXL367_FIFO_FORMAT_XT,\n\tADXL367_FIFO_FORMAT_YT,\n\tADXL367_FIFO_FORMAT_ZT,\n\tADXL367_FIFO_FORMAT_XA,\n\tADXL367_FIFO_FORMAT_YA,\n\tADXL367_FIFO_FORMAT_ZA,\n\tADXL367_FIFO_FORMAT_XYZ,\n\tADXL367_FIFO_FORMAT_XYZT,\n\tADXL367_FIFO_FORMAT_XYZA,\n};\n\nstatic const unsigned long adxl367_channel_masks[] = {\n\tADXL367_X_CHANNEL_MASK,\n\tADXL367_Y_CHANNEL_MASK,\n\tADXL367_Z_CHANNEL_MASK,\n\tADXL367_X_CHANNEL_MASK | ADXL367_TEMP_CHANNEL_MASK,\n\tADXL367_Y_CHANNEL_MASK | ADXL367_TEMP_CHANNEL_MASK,\n\tADXL367_Z_CHANNEL_MASK | ADXL367_TEMP_CHANNEL_MASK,\n\tADXL367_X_CHANNEL_MASK | ADXL367_EX_ADC_CHANNEL_MASK,\n\tADXL367_Y_CHANNEL_MASK | ADXL367_EX_ADC_CHANNEL_MASK,\n\tADXL367_Z_CHANNEL_MASK | ADXL367_EX_ADC_CHANNEL_MASK,\n\tADXL367_X_CHANNEL_MASK | ADXL367_Y_CHANNEL_MASK | ADXL367_Z_CHANNEL_MASK,\n\tADXL367_X_CHANNEL_MASK | ADXL367_Y_CHANNEL_MASK | ADXL367_Z_CHANNEL_MASK |\n\t\tADXL367_TEMP_CHANNEL_MASK,\n\tADXL367_X_CHANNEL_MASK | ADXL367_Y_CHANNEL_MASK | ADXL367_Z_CHANNEL_MASK |\n\t\tADXL367_EX_ADC_CHANNEL_MASK,\n\t0,\n};\n\nstatic int adxl367_set_measure_en(struct adxl367_state *st, bool en)\n{\n\tenum adxl367_op_mode op_mode = en ? ADXL367_OP_MEASURE\n\t\t\t\t\t  : ADXL367_OP_STANDBY;\n\tint ret;\n\n\tret = regmap_update_bits(st->regmap, ADXL367_REG_POWER_CTL,\n\t\t\t\t ADXL367_POWER_CTL_MODE_MASK,\n\t\t\t\t FIELD_PREP(ADXL367_POWER_CTL_MODE_MASK,\n\t\t\t\t\t    op_mode));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (en)\n\t\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic void adxl367_scale_act_thresholds(struct adxl367_state *st,\n\t\t\t\t\t enum adxl367_range old_range,\n\t\t\t\t\t enum adxl367_range new_range)\n{\n\tst->act_threshold = st->act_threshold\n\t\t\t    * adxl367_range_scale_factor_tbl[old_range]\n\t\t\t    / adxl367_range_scale_factor_tbl[new_range];\n\tst->inact_threshold = st->inact_threshold\n\t\t\t      * adxl367_range_scale_factor_tbl[old_range]\n\t\t\t      / adxl367_range_scale_factor_tbl[new_range];\n}\n\nstatic int _adxl367_set_act_threshold(struct adxl367_state *st,\n\t\t\t\t      enum adxl367_activity_type act,\n\t\t\t\t      unsigned int threshold)\n{\n\tu8 reg = adxl367_threshold_h_reg_tbl[act];\n\tint ret;\n\n\tif (threshold > ADXL367_THRESH_MAX)\n\t\treturn -EINVAL;\n\n\tst->act_threshold_buf[0] = FIELD_PREP(ADXL367_THRESH_H_MASK,\n\t\t\t\t\t      FIELD_GET(ADXL367_THRESH_VAL_H_MASK,\n\t\t\t\t\t\t\tthreshold));\n\tst->act_threshold_buf[1] = FIELD_PREP(ADXL367_THRESH_L_MASK,\n\t\t\t\t\t      FIELD_GET(ADXL367_THRESH_VAL_L_MASK,\n\t\t\t\t\t\t\tthreshold));\n\n\tret = regmap_bulk_write(st->regmap, reg, st->act_threshold_buf,\n\t\t\t\tsizeof(st->act_threshold_buf));\n\tif (ret)\n\t\treturn ret;\n\n\tif (act == ADXL367_ACTIVITY)\n\t\tst->act_threshold = threshold;\n\telse\n\t\tst->inact_threshold = threshold;\n\n\treturn 0;\n}\n\nstatic int adxl367_set_act_threshold(struct adxl367_state *st,\n\t\t\t\t     enum adxl367_activity_type act,\n\t\t\t\t     unsigned int threshold)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = adxl367_set_measure_en(st, false);\n\tif (ret)\n\t\tgoto out;\n\n\tret = _adxl367_set_act_threshold(st, act, threshold);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_measure_en(st, true);\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int adxl367_set_act_proc_mode(struct adxl367_state *st,\n\t\t\t\t     enum adxl367_act_proc_mode mode)\n{\n\treturn regmap_update_bits(st->regmap, ADXL367_REG_ACT_INACT_CTL,\n\t\t\t\t  ADXL367_ACT_LINKLOOP_MASK,\n\t\t\t\t  FIELD_PREP(ADXL367_ACT_LINKLOOP_MASK,\n\t\t\t\t\t     mode));\n}\n\nstatic int adxl367_set_act_interrupt_en(struct adxl367_state *st,\n\t\t\t\t\tenum adxl367_activity_type act,\n\t\t\t\t\tbool en)\n{\n\tunsigned int mask = adxl367_act_int_mask_tbl[act];\n\n\treturn regmap_update_bits(st->regmap, ADXL367_REG_INT1_MAP,\n\t\t\t\t  mask, en ? mask : 0);\n}\n\nstatic int adxl367_get_act_interrupt_en(struct adxl367_state *st,\n\t\t\t\t\tenum adxl367_activity_type act,\n\t\t\t\t\tbool *en)\n{\n\tunsigned int mask = adxl367_act_int_mask_tbl[act];\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(st->regmap, ADXL367_REG_INT1_MAP, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t*en = !!(val & mask);\n\n\treturn 0;\n}\n\nstatic int adxl367_set_act_en(struct adxl367_state *st,\n\t\t\t      enum adxl367_activity_type act,\n\t\t\t      enum adxl367_act_en_mode en)\n{\n\tunsigned int ctl_shift = adxl367_act_en_shift_tbl[act];\n\n\treturn regmap_update_bits(st->regmap, ADXL367_REG_ACT_INACT_CTL,\n\t\t\t\t  ADXL367_ACT_EN_MASK << ctl_shift,\n\t\t\t\t  en << ctl_shift);\n}\n\nstatic int adxl367_set_fifo_watermark_interrupt_en(struct adxl367_state *st,\n\t\t\t\t\t\t   bool en)\n{\n\treturn regmap_update_bits(st->regmap, ADXL367_REG_INT1_MAP,\n\t\t\t\t  ADXL367_INT_FIFO_WATERMARK_MASK,\n\t\t\t\t  en ? ADXL367_INT_FIFO_WATERMARK_MASK : 0);\n}\n\nstatic int adxl367_get_fifo_mode(struct adxl367_state *st,\n\t\t\t\t enum adxl367_fifo_mode *fifo_mode)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(st->regmap, ADXL367_REG_FIFO_CTL, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t*fifo_mode = FIELD_GET(ADXL367_FIFO_CTL_MODE_MASK, val);\n\n\treturn 0;\n}\n\nstatic int adxl367_set_fifo_mode(struct adxl367_state *st,\n\t\t\t\t enum adxl367_fifo_mode fifo_mode)\n{\n\treturn regmap_update_bits(st->regmap, ADXL367_REG_FIFO_CTL,\n\t\t\t\t  ADXL367_FIFO_CTL_MODE_MASK,\n\t\t\t\t  FIELD_PREP(ADXL367_FIFO_CTL_MODE_MASK,\n\t\t\t\t\t     fifo_mode));\n}\n\nstatic int adxl367_set_fifo_format(struct adxl367_state *st,\n\t\t\t\t   enum adxl367_fifo_format fifo_format)\n{\n\treturn regmap_update_bits(st->regmap, ADXL367_REG_FIFO_CTL,\n\t\t\t\t  ADXL367_FIFO_CTL_FORMAT_MASK,\n\t\t\t\t  FIELD_PREP(ADXL367_FIFO_CTL_FORMAT_MASK,\n\t\t\t\t\t     fifo_format));\n}\n\nstatic int adxl367_set_fifo_watermark(struct adxl367_state *st,\n\t\t\t\t      unsigned int fifo_watermark)\n{\n\tunsigned int fifo_samples = fifo_watermark * st->fifo_set_size;\n\tunsigned int fifo_samples_h, fifo_samples_l;\n\tint ret;\n\n\tif (fifo_samples > ADXL367_FIFO_MAX_WATERMARK)\n\t\tfifo_samples = ADXL367_FIFO_MAX_WATERMARK;\n\n\tfifo_samples /= st->fifo_set_size;\n\n\tfifo_samples_h = FIELD_PREP(ADXL367_SAMPLES_H_MASK,\n\t\t\t\t    FIELD_GET(ADXL367_SAMPLES_VAL_H_MASK,\n\t\t\t\t\t      fifo_samples));\n\tfifo_samples_l = FIELD_PREP(ADXL367_SAMPLES_L_MASK,\n\t\t\t\t    FIELD_GET(ADXL367_SAMPLES_VAL_L_MASK,\n\t\t\t\t\t      fifo_samples));\n\n\tret = regmap_update_bits(st->regmap, ADXL367_REG_FIFO_CTL,\n\t\t\t\t ADXL367_SAMPLES_H_MASK, fifo_samples_h);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(st->regmap, ADXL367_REG_FIFO_SAMPLES,\n\t\t\t\t ADXL367_SAMPLES_L_MASK, fifo_samples_l);\n\tif (ret)\n\t\treturn ret;\n\n\tst->fifo_watermark = fifo_watermark;\n\n\treturn 0;\n}\n\nstatic int adxl367_set_range(struct iio_dev *indio_dev,\n\t\t\t     enum adxl367_range range)\n{\n\tstruct adxl367_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = adxl367_set_measure_en(st, false);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_update_bits(st->regmap, ADXL367_REG_FILTER_CTL,\n\t\t\t\t ADXL367_FILTER_CTL_RANGE_MASK,\n\t\t\t\t FIELD_PREP(ADXL367_FILTER_CTL_RANGE_MASK,\n\t\t\t\t\t    range));\n\tif (ret)\n\t\tgoto out;\n\n\tadxl367_scale_act_thresholds(st, st->range, range);\n\n\t \n\tret = _adxl367_set_act_threshold(st, ADXL367_ACTIVITY,\n\t\t\t\t\t st->act_threshold);\n\tif (ret)\n\t\tgoto out;\n\n\tret = _adxl367_set_act_threshold(st, ADXL367_INACTIVITY,\n\t\t\t\t\t st->inact_threshold);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_measure_en(st, true);\n\tif (ret)\n\t\tgoto out;\n\n\tst->range = range;\n\nout:\n\tmutex_unlock(&st->lock);\n\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret;\n}\n\nstatic int adxl367_time_ms_to_samples(struct adxl367_state *st, unsigned int ms)\n{\n\tint freq_hz = adxl367_samp_freq_tbl[st->odr][0];\n\tint freq_microhz = adxl367_samp_freq_tbl[st->odr][1];\n\t \n\tint freq_dhz = freq_hz * 10 + freq_microhz / 100000;\n\n\treturn DIV_ROUND_CLOSEST(ms * freq_dhz, 10000);\n}\n\nstatic int _adxl367_set_act_time_ms(struct adxl367_state *st, unsigned int ms)\n{\n\tunsigned int val = adxl367_time_ms_to_samples(st, ms);\n\tint ret;\n\n\tif (val > ADXL367_TIME_ACT_MAX)\n\t\tval = ADXL367_TIME_ACT_MAX;\n\n\tret = regmap_write(st->regmap, ADXL367_REG_TIME_ACT, val);\n\tif (ret)\n\t\treturn ret;\n\n\tst->act_time_ms = ms;\n\n\treturn 0;\n}\n\nstatic int _adxl367_set_inact_time_ms(struct adxl367_state *st, unsigned int ms)\n{\n\tunsigned int val = adxl367_time_ms_to_samples(st, ms);\n\tint ret;\n\n\tif (val > ADXL367_TIME_INACT_MAX)\n\t\tval = ADXL367_TIME_INACT_MAX;\n\n\tst->inact_time_buf[0] = FIELD_PREP(ADXL367_TIME_INACT_H_MASK,\n\t\t\t\t\t   FIELD_GET(ADXL367_TIME_INACT_VAL_H_MASK,\n\t\t\t\t\t\t     val));\n\tst->inact_time_buf[1] = FIELD_PREP(ADXL367_TIME_INACT_L_MASK,\n\t\t\t\t\t   FIELD_GET(ADXL367_TIME_INACT_VAL_L_MASK,\n\t\t\t\t\t\t     val));\n\n\tret = regmap_bulk_write(st->regmap, ADXL367_REG_TIME_INACT_H,\n\t\t\t\tst->inact_time_buf, sizeof(st->inact_time_buf));\n\tif (ret)\n\t\treturn ret;\n\n\tst->inact_time_ms = ms;\n\n\treturn 0;\n}\n\nstatic int adxl367_set_act_time_ms(struct adxl367_state *st,\n\t\t\t\t   enum adxl367_activity_type act,\n\t\t\t\t   unsigned int ms)\n{\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = adxl367_set_measure_en(st, false);\n\tif (ret)\n\t\tgoto out;\n\n\tif (act == ADXL367_ACTIVITY)\n\t\tret = _adxl367_set_act_time_ms(st, ms);\n\telse\n\t\tret = _adxl367_set_inact_time_ms(st, ms);\n\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_measure_en(st, true);\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int _adxl367_set_odr(struct adxl367_state *st, enum adxl367_odr odr)\n{\n\tint ret;\n\n\tret = regmap_update_bits(st->regmap, ADXL367_REG_FILTER_CTL,\n\t\t\t\t ADXL367_FILTER_CTL_ODR_MASK,\n\t\t\t\t FIELD_PREP(ADXL367_FILTER_CTL_ODR_MASK,\n\t\t\t\t\t    odr));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = _adxl367_set_act_time_ms(st, st->act_time_ms);\n\tif (ret)\n\t\treturn ret;\n\n\tret = _adxl367_set_inact_time_ms(st, st->inact_time_ms);\n\tif (ret)\n\t\treturn ret;\n\n\tst->odr = odr;\n\n\treturn 0;\n}\n\nstatic int adxl367_set_odr(struct iio_dev *indio_dev, enum adxl367_odr odr)\n{\n\tstruct adxl367_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = adxl367_set_measure_en(st, false);\n\tif (ret)\n\t\tgoto out;\n\n\tret = _adxl367_set_odr(st, odr);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_measure_en(st, true);\n\nout:\n\tmutex_unlock(&st->lock);\n\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret;\n}\n\nstatic int adxl367_set_temp_adc_en(struct adxl367_state *st, unsigned int reg,\n\t\t\t\t   bool en)\n{\n\treturn regmap_update_bits(st->regmap, reg, ADXL367_ADC_EN_MASK,\n\t\t\t\t  en ? ADXL367_ADC_EN_MASK : 0);\n}\n\nstatic int adxl367_set_temp_adc_reg_en(struct adxl367_state *st,\n\t\t\t\t       unsigned int reg, bool en)\n{\n\tint ret;\n\n\tswitch (reg) {\n\tcase ADXL367_REG_TEMP_DATA_H:\n\t\tret = adxl367_set_temp_adc_en(st, ADXL367_REG_TEMP_CTL, en);\n\t\tbreak;\n\tcase ADXL367_REG_EX_ADC_DATA_H:\n\t\tret = adxl367_set_temp_adc_en(st, ADXL367_REG_ADC_CTL, en);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (en)\n\t\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic int adxl367_set_temp_adc_mask_en(struct adxl367_state *st,\n\t\t\t\t\tconst unsigned long *active_scan_mask,\n\t\t\t\t\tbool en)\n{\n\tif (*active_scan_mask & ADXL367_TEMP_CHANNEL_MASK)\n\t\treturn adxl367_set_temp_adc_en(st, ADXL367_REG_TEMP_CTL, en);\n\telse if (*active_scan_mask & ADXL367_EX_ADC_CHANNEL_MASK)\n\t\treturn adxl367_set_temp_adc_en(st, ADXL367_REG_ADC_CTL, en);\n\n\treturn 0;\n}\n\nstatic int adxl367_find_odr(struct adxl367_state *st, int val, int val2,\n\t\t\t    enum adxl367_odr *odr)\n{\n\tsize_t size = ARRAY_SIZE(adxl367_samp_freq_tbl);\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tif (val == adxl367_samp_freq_tbl[i][0] &&\n\t\t    val2 == adxl367_samp_freq_tbl[i][1])\n\t\t\tbreak;\n\n\tif (i == size)\n\t\treturn -EINVAL;\n\n\t*odr = i;\n\n\treturn 0;\n}\n\nstatic int adxl367_find_range(struct adxl367_state *st, int val, int val2,\n\t\t\t      enum adxl367_range *range)\n{\n\tsize_t size = ARRAY_SIZE(adxl367_range_scale_tbl);\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tif (val == adxl367_range_scale_tbl[i][0] &&\n\t\t    val2 == adxl367_range_scale_tbl[i][1])\n\t\t\tbreak;\n\n\tif (i == size)\n\t\treturn -EINVAL;\n\n\t*range = i;\n\n\treturn 0;\n}\n\nstatic int adxl367_read_sample(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int *val)\n{\n\tstruct adxl367_state *st = iio_priv(indio_dev);\n\tu16 sample;\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = adxl367_set_temp_adc_reg_en(st, chan->address, true);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_bulk_read(st->regmap, chan->address, &st->sample_buf,\n\t\t\t       sizeof(st->sample_buf));\n\tif (ret)\n\t\tgoto out;\n\n\tsample = FIELD_GET(ADXL367_DATA_MASK, be16_to_cpu(st->sample_buf));\n\t*val = sign_extend32(sample, chan->scan_type.realbits - 1);\n\n\tret = adxl367_set_temp_adc_reg_en(st, chan->address, false);\n\nout:\n\tmutex_unlock(&st->lock);\n\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret ?: IIO_VAL_INT;\n}\n\nstatic int adxl367_get_status(struct adxl367_state *st, u8 *status,\n\t\t\t      u16 *fifo_entries)\n{\n\tint ret;\n\n\t \n\tret = regmap_bulk_read(st->regmap, ADXL367_REG_STATUS,\n\t\t\t       st->status_buf, sizeof(st->status_buf));\n\tif (ret)\n\t\treturn ret;\n\n\tst->status_buf[2] &= ADXL367_FIFO_ENT_H_MASK;\n\n\t*status = st->status_buf[0];\n\t*fifo_entries = get_unaligned_le16(&st->status_buf[1]);\n\n\treturn 0;\n}\n\nstatic bool adxl367_push_event(struct iio_dev *indio_dev, u8 status)\n{\n\tunsigned int ev_dir;\n\n\tif (FIELD_GET(ADXL367_STATUS_ACT_MASK, status))\n\t\tev_dir = IIO_EV_DIR_RISING;\n\telse if (FIELD_GET(ADXL367_STATUS_INACT_MASK, status))\n\t\tev_dir = IIO_EV_DIR_FALLING;\n\telse\n\t\treturn false;\n\n\tiio_push_event(indio_dev,\n\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL, 0, IIO_MOD_X_OR_Y_OR_Z,\n\t\t\t\t\t  IIO_EV_TYPE_THRESH, ev_dir),\n\t\t       iio_get_time_ns(indio_dev));\n\n\treturn true;\n}\n\nstatic bool adxl367_push_fifo_data(struct iio_dev *indio_dev, u8 status,\n\t\t\t\t   u16 fifo_entries)\n{\n\tstruct adxl367_state *st = iio_priv(indio_dev);\n\tint ret;\n\tint i;\n\n\tif (!FIELD_GET(ADXL367_STATUS_FIFO_FULL_MASK, status))\n\t\treturn false;\n\n\tfifo_entries -= fifo_entries % st->fifo_set_size;\n\n\tret = st->ops->read_fifo(st->context, st->fifo_buf, fifo_entries);\n\tif (ret) {\n\t\tdev_err(st->dev, \"Failed to read FIFO: %d\\n\", ret);\n\t\treturn true;\n\t}\n\n\tfor (i = 0; i < fifo_entries; i += st->fifo_set_size)\n\t\tiio_push_to_buffers(indio_dev, &st->fifo_buf[i]);\n\n\treturn true;\n}\n\nstatic irqreturn_t adxl367_irq_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct adxl367_state *st = iio_priv(indio_dev);\n\tu16 fifo_entries;\n\tbool handled;\n\tu8 status;\n\tint ret;\n\n\tret = adxl367_get_status(st, &status, &fifo_entries);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\thandled = adxl367_push_event(indio_dev, status);\n\thandled |= adxl367_push_fifo_data(indio_dev, status, fifo_entries);\n\n\treturn handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int adxl367_reg_access(struct iio_dev *indio_dev,\n\t\t\t      unsigned int reg,\n\t\t\t      unsigned int writeval,\n\t\t\t      unsigned int *readval)\n{\n\tstruct adxl367_state *st = iio_priv(indio_dev);\n\n\tif (readval)\n\t\treturn regmap_read(st->regmap, reg, readval);\n\telse\n\t\treturn regmap_write(st->regmap, reg, writeval);\n}\n\nstatic int adxl367_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long info)\n{\n\tstruct adxl367_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn adxl367_read_sample(indio_dev, chan, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ACCEL:\n\t\t\tmutex_lock(&st->lock);\n\t\t\t*val = adxl367_range_scale_tbl[st->range][0];\n\t\t\t*val2 = adxl367_range_scale_tbl[st->range][1];\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tcase IIO_TEMP:\n\t\t\t*val = 1000;\n\t\t\t*val2 = ADXL367_TEMP_PER_C;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_VOLTAGE:\n\t\t\t*val = ADXL367_VOLTAGE_MAX_MV;\n\t\t\t*val2 = ADXL367_VOLTAGE_MAX_RAW;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t*val = 25 * ADXL367_TEMP_PER_C - ADXL367_TEMP_25C;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_VOLTAGE:\n\t\t\t*val = ADXL367_VOLTAGE_OFFSET;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tmutex_lock(&st->lock);\n\t\t*val = adxl367_samp_freq_tbl[st->odr][0];\n\t\t*val2 = adxl367_samp_freq_tbl[st->odr][1];\n\t\tmutex_unlock(&st->lock);\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxl367_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long info)\n{\n\tstruct adxl367_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ: {\n\t\tenum adxl367_odr odr;\n\n\t\tret = adxl367_find_odr(st, val, val2, &odr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn adxl367_set_odr(indio_dev, odr);\n\t}\n\tcase IIO_CHAN_INFO_SCALE: {\n\t\tenum adxl367_range range;\n\n\t\tret = adxl367_find_range(st, val, val2, &range);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn adxl367_set_range(indio_dev, range);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxl367_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t\t     long info)\n{\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type != IIO_ACCEL)\n\t\t\treturn -EINVAL;\n\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tdefault:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n}\n\nstatic int adxl367_read_avail(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      const int **vals, int *type, int *length,\n\t\t\t      long info)\n{\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type != IIO_ACCEL)\n\t\t\treturn -EINVAL;\n\n\t\t*vals = (int *)adxl367_range_scale_tbl;\n\t\t*type = IIO_VAL_INT_PLUS_NANO;\n\t\t*length = ARRAY_SIZE(adxl367_range_scale_tbl) * 2;\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*vals = (int *)adxl367_samp_freq_tbl;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t*length = ARRAY_SIZE(adxl367_samp_freq_tbl) * 2;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxl367_read_event_value(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir,\n\t\t\t\t    enum iio_event_info info,\n\t\t\t\t    int *val, int *val2)\n{\n\tstruct adxl367_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE: {\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\tmutex_lock(&st->lock);\n\t\t\t*val = st->act_threshold;\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\tmutex_lock(&st->lock);\n\t\t\t*val = st->inact_threshold;\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tcase IIO_EV_INFO_PERIOD:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\tmutex_lock(&st->lock);\n\t\t\t*val = st->act_time_ms;\n\t\t\tmutex_unlock(&st->lock);\n\t\t\t*val2 = 1000;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\tmutex_lock(&st->lock);\n\t\t\t*val = st->inact_time_ms;\n\t\t\tmutex_unlock(&st->lock);\n\t\t\t*val2 = 1000;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxl367_write_event_value(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir,\n\t\t\t\t     enum iio_event_info info,\n\t\t\t\t     int val, int val2)\n{\n\tstruct adxl367_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tif (val < 0)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\treturn adxl367_set_act_threshold(st, ADXL367_ACTIVITY, val);\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\treturn adxl367_set_act_threshold(st, ADXL367_INACTIVITY, val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_EV_INFO_PERIOD:\n\t\tif (val < 0)\n\t\t\treturn -EINVAL;\n\n\t\tval = val * 1000 + DIV_ROUND_UP(val2, 1000);\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\treturn adxl367_set_act_time_ms(st, ADXL367_ACTIVITY, val);\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\treturn adxl367_set_act_time_ms(st, ADXL367_INACTIVITY, val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxl367_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir)\n{\n\tstruct adxl367_state *st = iio_priv(indio_dev);\n\tbool en;\n\tint ret;\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\tret = adxl367_get_act_interrupt_en(st, ADXL367_ACTIVITY, &en);\n\t\treturn ret ?: en;\n\tcase IIO_EV_DIR_FALLING:\n\t\tret = adxl367_get_act_interrupt_en(st, ADXL367_INACTIVITY, &en);\n\t\treturn ret ?: en;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxl367_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir,\n\t\t\t\t      int state)\n{\n\tstruct adxl367_state *st = iio_priv(indio_dev);\n\tenum adxl367_activity_type act;\n\tint ret;\n\n\tswitch (dir) {\n\tcase IIO_EV_DIR_RISING:\n\t\tact = ADXL367_ACTIVITY;\n\t\tbreak;\n\tcase IIO_EV_DIR_FALLING:\n\t\tact = ADXL367_INACTIVITY;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = adxl367_set_measure_en(st, false);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_act_interrupt_en(st, act, state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_act_en(st, act, state ? ADCL367_ACT_REF_ENABLED\n\t\t\t\t\t\t: ADXL367_ACT_DISABLED);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_measure_en(st, true);\n\nout:\n\tmutex_unlock(&st->lock);\n\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret;\n}\n\nstatic ssize_t adxl367_get_fifo_enabled(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct adxl367_state *st = iio_priv(dev_to_iio_dev(dev));\n\tenum adxl367_fifo_mode fifo_mode;\n\tint ret;\n\n\tret = adxl367_get_fifo_mode(st, &fifo_mode);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", fifo_mode != ADXL367_FIFO_MODE_DISABLED);\n}\n\nstatic ssize_t adxl367_get_fifo_watermark(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct adxl367_state *st = iio_priv(dev_to_iio_dev(dev));\n\tunsigned int fifo_watermark;\n\n\tmutex_lock(&st->lock);\n\tfifo_watermark = st->fifo_watermark;\n\tmutex_unlock(&st->lock);\n\n\treturn sysfs_emit(buf, \"%d\\n\", fifo_watermark);\n}\n\nIIO_STATIC_CONST_DEVICE_ATTR(hwfifo_watermark_min, \"1\");\nIIO_STATIC_CONST_DEVICE_ATTR(hwfifo_watermark_max,\n\t\t\t     __stringify(ADXL367_FIFO_MAX_WATERMARK));\nstatic IIO_DEVICE_ATTR(hwfifo_watermark, 0444,\n\t\t       adxl367_get_fifo_watermark, NULL, 0);\nstatic IIO_DEVICE_ATTR(hwfifo_enabled, 0444,\n\t\t       adxl367_get_fifo_enabled, NULL, 0);\n\nstatic const struct iio_dev_attr *adxl367_fifo_attributes[] = {\n\t&iio_dev_attr_hwfifo_watermark_min,\n\t&iio_dev_attr_hwfifo_watermark_max,\n\t&iio_dev_attr_hwfifo_watermark,\n\t&iio_dev_attr_hwfifo_enabled,\n\tNULL,\n};\n\nstatic int adxl367_set_watermark(struct iio_dev *indio_dev, unsigned int val)\n{\n\tstruct adxl367_state *st  = iio_priv(indio_dev);\n\tint ret;\n\n\tif (val > ADXL367_FIFO_MAX_WATERMARK)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&st->lock);\n\n\tret = adxl367_set_measure_en(st, false);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_fifo_watermark(st, val);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_measure_en(st, true);\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic bool adxl367_find_mask_fifo_format(const unsigned long *scan_mask,\n\t\t\t\t\t  enum adxl367_fifo_format *fifo_format)\n{\n\tsize_t size = ARRAY_SIZE(adxl367_fifo_formats);\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tif (*scan_mask == adxl367_channel_masks[i])\n\t\t\tbreak;\n\n\tif (i == size)\n\t\treturn false;\n\n\t*fifo_format = adxl367_fifo_formats[i];\n\n\treturn true;\n}\n\nstatic int adxl367_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t    const unsigned long *active_scan_mask)\n{\n\tstruct adxl367_state *st  = iio_priv(indio_dev);\n\tenum adxl367_fifo_format fifo_format;\n\tint ret;\n\n\tif (!adxl367_find_mask_fifo_format(active_scan_mask, &fifo_format))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&st->lock);\n\n\tret = adxl367_set_measure_en(st, false);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_fifo_format(st, fifo_format);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_measure_en(st, true);\n\tif (ret)\n\t\tgoto out;\n\n\tst->fifo_set_size = bitmap_weight(active_scan_mask,\n\t\t\t\t\t  indio_dev->masklength);\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int adxl367_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct adxl367_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = adxl367_set_temp_adc_mask_en(st, indio_dev->active_scan_mask,\n\t\t\t\t\t   true);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_measure_en(st, false);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_fifo_watermark_interrupt_en(st, true);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_fifo_mode(st, ADXL367_FIFO_MODE_STREAM);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_measure_en(st, true);\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int adxl367_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct adxl367_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = adxl367_set_measure_en(st, false);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_fifo_mode(st, ADXL367_FIFO_MODE_DISABLED);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_fifo_watermark_interrupt_en(st, false);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_measure_en(st, true);\n\tif (ret)\n\t\tgoto out;\n\n\tret = adxl367_set_temp_adc_mask_en(st, indio_dev->active_scan_mask,\n\t\t\t\t\t   false);\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_buffer_setup_ops adxl367_buffer_ops = {\n\t.postenable = adxl367_buffer_postenable,\n\t.predisable = adxl367_buffer_predisable,\n};\n\nstatic const struct iio_info adxl367_info = {\n\t.read_raw = adxl367_read_raw,\n\t.write_raw = adxl367_write_raw,\n\t.write_raw_get_fmt = adxl367_write_raw_get_fmt,\n\t.read_avail = adxl367_read_avail,\n\t.read_event_config = adxl367_read_event_config,\n\t.write_event_config = adxl367_write_event_config,\n\t.read_event_value = adxl367_read_event_value,\n\t.write_event_value = adxl367_write_event_value,\n\t.debugfs_reg_access = adxl367_reg_access,\n\t.hwfifo_set_watermark = adxl367_set_watermark,\n\t.update_scan_mode = adxl367_update_scan_mode,\n};\n\nstatic const struct iio_event_spec adxl367_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_MAG_REFERENCED,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_shared_by_type = BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t\t       BIT(IIO_EV_INFO_PERIOD) |\n\t\t\t\t       BIT(IIO_EV_INFO_VALUE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_MAG_REFERENCED,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_shared_by_type = BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t\t       BIT(IIO_EV_INFO_PERIOD) |\n\t\t\t\t       BIT(IIO_EV_INFO_VALUE),\n\t},\n};\n\n#define ADXL367_ACCEL_CHANNEL(index, reg, axis) {\t\t\t\\\n\t.type = IIO_ACCEL,\t\t\t\t\t\t\\\n\t.address = (reg),\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##axis,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n\t.info_mask_shared_by_all_available =\t\t\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t\\\n\t.event_spec = adxl367_events,\t\t\t\t\t\\\n\t.num_event_specs = ARRAY_SIZE(adxl367_events),\t\t\t\\\n\t.scan_index = (index),\t\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\t\\\n\t\t.realbits = 14,\t\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\t\\\n\t\t.endianness = IIO_BE,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\n#define ADXL367_CHANNEL(index, reg, _type) {\t\t\t\t\\\n\t.type = (_type),\t\t\t\t\t\t\\\n\t.address = (reg),\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_OFFSET) |\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\t\t\t\\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n\t.scan_index = (index),\t\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\t\\\n\t\t.realbits = 14,\t\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\t\\\n\t\t.endianness = IIO_BE,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec adxl367_channels[] = {\n\tADXL367_ACCEL_CHANNEL(ADXL367_X_CHANNEL_INDEX, ADXL367_REG_X_DATA_H, X),\n\tADXL367_ACCEL_CHANNEL(ADXL367_Y_CHANNEL_INDEX, ADXL367_REG_Y_DATA_H, Y),\n\tADXL367_ACCEL_CHANNEL(ADXL367_Z_CHANNEL_INDEX, ADXL367_REG_Z_DATA_H, Z),\n\tADXL367_CHANNEL(ADXL367_TEMP_CHANNEL_INDEX, ADXL367_REG_TEMP_DATA_H,\n\t\t\tIIO_TEMP),\n\tADXL367_CHANNEL(ADXL367_EX_ADC_CHANNEL_INDEX, ADXL367_REG_EX_ADC_DATA_H,\n\t\t\tIIO_VOLTAGE),\n};\n\nstatic int adxl367_verify_devid(struct adxl367_state *st)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read_poll_timeout(st->regmap, ADXL367_REG_DEVID, val,\n\t\t\t\t       val == ADXL367_DEVID_AD, 1000, 10000);\n\tif (ret)\n\t\treturn dev_err_probe(st->dev, -ENODEV,\n\t\t\t\t     \"Invalid dev id 0x%02X, expected 0x%02X\\n\",\n\t\t\t\t     val, ADXL367_DEVID_AD);\n\n\treturn 0;\n}\n\nstatic int adxl367_setup(struct adxl367_state *st)\n{\n\tint ret;\n\n\tret = _adxl367_set_act_threshold(st, ADXL367_ACTIVITY,\n\t\t\t\t\t ADXL367_2G_RANGE_1G);\n\tif (ret)\n\t\treturn ret;\n\n\tret = _adxl367_set_act_threshold(st, ADXL367_INACTIVITY,\n\t\t\t\t\t ADXL367_2G_RANGE_100MG);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adxl367_set_act_proc_mode(st, ADXL367_LOOPED);\n\tif (ret)\n\t\treturn ret;\n\n\tret = _adxl367_set_odr(st, ADXL367_ODR_400HZ);\n\tif (ret)\n\t\treturn ret;\n\n\tret = _adxl367_set_act_time_ms(st, 10);\n\tif (ret)\n\t\treturn ret;\n\n\tret = _adxl367_set_inact_time_ms(st, 10000);\n\tif (ret)\n\t\treturn ret;\n\n\treturn adxl367_set_measure_en(st, true);\n}\n\nint adxl367_probe(struct device *dev, const struct adxl367_ops *ops,\n\t\t  void *context, struct regmap *regmap, int irq)\n{\n\tstatic const char * const regulator_names[] = { \"vdd\", \"vddio\" };\n\tstruct iio_dev *indio_dev;\n\tstruct adxl367_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tst->dev = dev;\n\tst->regmap = regmap;\n\tst->context = context;\n\tst->ops = ops;\n\n\tmutex_init(&st->lock);\n\n\tindio_dev->channels = adxl367_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adxl367_channels);\n\tindio_dev->available_scan_masks = adxl367_channel_masks;\n\tindio_dev->name = \"adxl367\";\n\tindio_dev->info = &adxl367_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = devm_regulator_bulk_get_enable(st->dev,\n\t\t\t\t\t     ARRAY_SIZE(regulator_names),\n\t\t\t\t\t     regulator_names);\n\tif (ret)\n\t\treturn dev_err_probe(st->dev, ret,\n\t\t\t\t     \"Failed to get regulators\\n\");\n\n\tret = regmap_write(st->regmap, ADXL367_REG_RESET, ADXL367_RESET_CODE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adxl367_verify_devid(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adxl367_setup(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_kfifo_buffer_setup_ext(st->dev, indio_dev,\n\t\t\t\t\t      &adxl367_buffer_ops,\n\t\t\t\t\t      adxl367_fifo_attributes);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_threaded_irq(st->dev, irq, NULL,\n\t\t\t\t\tadxl367_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\tindio_dev->name, indio_dev);\n\tif (ret)\n\t\treturn dev_err_probe(st->dev, ret, \"Failed to request irq\\n\");\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(adxl367_probe, IIO_ADXL367);\n\nMODULE_AUTHOR(\"Cosmin Tanislav <cosmin.tanislav@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADXL367 3-axis accelerometer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}