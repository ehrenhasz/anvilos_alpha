{
  "module_name": "adis16209.c",
  "hash_id": "d902731a0432a3a89d5abbe5ad390e23c7cb1465e7e0aab82022defe0575e1f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/adis16209.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/imu/adis.h>\n\n#define ADIS16209_STARTUP_DELAY_MS\t220\n#define ADIS16209_FLASH_CNT_REG\t\t0x00\n\n \n#define ADIS16209_SUPPLY_OUT_REG\t0x02\n#define ADIS16209_XACCL_OUT_REG\t\t0x04\n#define ADIS16209_YACCL_OUT_REG\t\t0x06\n \n#define ADIS16209_AUX_ADC_REG\t\t0x08\n \n#define ADIS16209_TEMP_OUT_REG\t\t0x0A\n \n#define ADIS16209_XINCL_OUT_REG\t\t0x0C\n#define ADIS16209_YINCL_OUT_REG\t\t0x0E\n \n#define ADIS16209_ROT_OUT_REG\t\t0x10\n\n \n#define ADIS16209_XACCL_NULL_REG\t0x12\n#define ADIS16209_YACCL_NULL_REG\t0x14\n#define ADIS16209_XINCL_NULL_REG\t0x16\n#define ADIS16209_YINCL_NULL_REG\t0x18\n#define ADIS16209_ROT_NULL_REG\t\t0x1A\n\n \n#define ADIS16209_ALM_MAG1_REG\t\t0x20\n#define ADIS16209_ALM_MAG2_REG\t\t0x22\n#define ADIS16209_ALM_SMPL1_REG\t\t0x24\n#define ADIS16209_ALM_SMPL2_REG\t\t0x26\n#define ADIS16209_ALM_CTRL_REG\t\t0x28\n\n#define ADIS16209_AUX_DAC_REG\t\t0x30\n#define ADIS16209_GPIO_CTRL_REG\t\t0x32\n#define ADIS16209_SMPL_PRD_REG\t\t0x36\n#define ADIS16209_AVG_CNT_REG\t\t0x38\n#define ADIS16209_SLP_CNT_REG\t\t0x3A\n\n#define ADIS16209_MSC_CTRL_REG\t\t\t0x34\n#define  ADIS16209_MSC_CTRL_PWRUP_SELF_TEST\tBIT(10)\n#define  ADIS16209_MSC_CTRL_SELF_TEST_EN\tBIT(8)\n#define  ADIS16209_MSC_CTRL_DATA_RDY_EN\t\tBIT(2)\n \n#define  ADIS16209_MSC_CTRL_ACTIVE_HIGH\t\tBIT(1)\n#define  ADIS16209_MSC_CTRL_DATA_RDY_DIO2\tBIT(0)\n\n#define ADIS16209_STAT_REG\t\t\t0x3C\n#define  ADIS16209_STAT_ALARM2\t\t\tBIT(9)\n#define  ADIS16209_STAT_ALARM1\t\t\tBIT(8)\n#define  ADIS16209_STAT_SELFTEST_FAIL_BIT\t5\n#define  ADIS16209_STAT_SPI_FAIL_BIT\t\t3\n#define  ADIS16209_STAT_FLASH_UPT_FAIL_BIT\t2\n \n#define  ADIS16209_STAT_POWER_HIGH_BIT\t\t1\n \n#define  ADIS16209_STAT_POWER_LOW_BIT\t\t0\n\n#define ADIS16209_CMD_REG\t\t\t0x3E\n#define  ADIS16209_CMD_SW_RESET\t\t\tBIT(7)\n#define  ADIS16209_CMD_CLEAR_STAT\t\tBIT(4)\n#define  ADIS16209_CMD_FACTORY_CAL\t\tBIT(1)\n\n#define ADIS16209_ERROR_ACTIVE\t\t\tBIT(14)\n\nenum adis16209_scan {\n\tADIS16209_SCAN_SUPPLY,\n\tADIS16209_SCAN_ACC_X,\n\tADIS16209_SCAN_ACC_Y,\n\tADIS16209_SCAN_AUX_ADC,\n\tADIS16209_SCAN_TEMP,\n\tADIS16209_SCAN_INCLI_X,\n\tADIS16209_SCAN_INCLI_Y,\n\tADIS16209_SCAN_ROT,\n};\n\nstatic const u8 adis16209_addresses[8][1] = {\n\t[ADIS16209_SCAN_SUPPLY] = { },\n\t[ADIS16209_SCAN_AUX_ADC] = { },\n\t[ADIS16209_SCAN_ACC_X] = { ADIS16209_XACCL_NULL_REG },\n\t[ADIS16209_SCAN_ACC_Y] = { ADIS16209_YACCL_NULL_REG },\n\t[ADIS16209_SCAN_INCLI_X] = { ADIS16209_XINCL_NULL_REG },\n\t[ADIS16209_SCAN_INCLI_Y] = { ADIS16209_YINCL_NULL_REG },\n\t[ADIS16209_SCAN_ROT] = { },\n\t[ADIS16209_SCAN_TEMP] = { },\n};\n\nstatic int adis16209_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val,\n\t\t\t       int val2,\n\t\t\t       long mask)\n{\n\tstruct adis *st = iio_priv(indio_dev);\n\tint m;\n\n\tif (mask != IIO_CHAN_INFO_CALIBBIAS)\n\t\treturn -EINVAL;\n\n\tswitch (chan->type) {\n\tcase IIO_ACCEL:\n\tcase IIO_INCLI:\n\t\tm = GENMASK(13, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn adis_write_reg_16(st, adis16209_addresses[chan->scan_index][0],\n\t\t\t\t val & m);\n}\n\nstatic int adis16209_read_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int *val, int *val2,\n\t\t\t      long mask)\n{\n\tstruct adis *st = iio_priv(indio_dev);\n\tint ret;\n\tint bits;\n\tu8 addr;\n\ts16 val16;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn adis_single_conversion(indio_dev, chan,\n\t\t\tADIS16209_ERROR_ACTIVE, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\t*val = 0;\n\t\t\tswitch (chan->channel) {\n\t\t\tcase 0:\n\t\t\t\t*val2 = 305180;  \n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t*val2 = 610500;  \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_TEMP:\n\t\t\t*val = -470;\n\t\t\t*val2 = 0;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_ACCEL:\n\t\t\t \n\t\t\t*val = 0;\n\t\t\t*val2 = IIO_G_TO_M_S_2(244140);\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tcase IIO_INCLI:\n\t\tcase IIO_ROT:\n\t\t\t \n\t\t\t*val = 0;\n\t\t\t*val2 = 25000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\t*val = 25000 / -470 - 0x4FE;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ACCEL:\n\t\t\tbits = 14;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\taddr = adis16209_addresses[chan->scan_index][0];\n\t\tret = adis_read_reg_16(st, addr, &val16);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = sign_extend32(val16, bits - 1);\n\t\treturn IIO_VAL_INT;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct iio_chan_spec adis16209_channels[] = {\n\tADIS_SUPPLY_CHAN(ADIS16209_SUPPLY_OUT_REG, ADIS16209_SCAN_SUPPLY,\n\t\t\t 0, 14),\n\tADIS_TEMP_CHAN(ADIS16209_TEMP_OUT_REG, ADIS16209_SCAN_TEMP, 0, 12),\n\tADIS_ACCEL_CHAN(X, ADIS16209_XACCL_OUT_REG, ADIS16209_SCAN_ACC_X,\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS), 0, 14),\n\tADIS_ACCEL_CHAN(Y, ADIS16209_YACCL_OUT_REG, ADIS16209_SCAN_ACC_Y,\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS), 0, 14),\n\tADIS_AUX_ADC_CHAN(ADIS16209_AUX_ADC_REG, ADIS16209_SCAN_AUX_ADC, 0, 12),\n\tADIS_INCLI_CHAN(X, ADIS16209_XINCL_OUT_REG, ADIS16209_SCAN_INCLI_X,\n\t\t\t0, 0, 14),\n\tADIS_INCLI_CHAN(Y, ADIS16209_YINCL_OUT_REG, ADIS16209_SCAN_INCLI_Y,\n\t\t\t0, 0, 14),\n\tADIS_ROT_CHAN(X, ADIS16209_ROT_OUT_REG, ADIS16209_SCAN_ROT, 0, 0, 14),\n\tIIO_CHAN_SOFT_TIMESTAMP(8)\n};\n\nstatic const struct iio_info adis16209_info = {\n\t.read_raw = adis16209_read_raw,\n\t.write_raw = adis16209_write_raw,\n\t.update_scan_mode = adis_update_scan_mode,\n};\n\nstatic const char * const adis16209_status_error_msgs[] = {\n\t[ADIS16209_STAT_SELFTEST_FAIL_BIT] = \"Self test failure\",\n\t[ADIS16209_STAT_SPI_FAIL_BIT] = \"SPI failure\",\n\t[ADIS16209_STAT_FLASH_UPT_FAIL_BIT] = \"Flash update failed\",\n\t[ADIS16209_STAT_POWER_HIGH_BIT] = \"Power supply above 3.625V\",\n\t[ADIS16209_STAT_POWER_LOW_BIT] = \"Power supply below 2.975V\",\n};\n\nstatic const struct adis_timeout adis16209_timeouts = {\n\t.reset_ms = ADIS16209_STARTUP_DELAY_MS,\n\t.self_test_ms = ADIS16209_STARTUP_DELAY_MS,\n\t.sw_reset_ms = ADIS16209_STARTUP_DELAY_MS,\n};\n\nstatic const struct adis_data adis16209_data = {\n\t.read_delay = 30,\n\t.msc_ctrl_reg = ADIS16209_MSC_CTRL_REG,\n\t.glob_cmd_reg = ADIS16209_CMD_REG,\n\t.diag_stat_reg = ADIS16209_STAT_REG,\n\n\t.self_test_mask = ADIS16209_MSC_CTRL_SELF_TEST_EN,\n\t.self_test_reg = ADIS16209_MSC_CTRL_REG,\n\t.self_test_no_autoclear = true,\n\t.timeouts = &adis16209_timeouts,\n\n\t.status_error_msgs = adis16209_status_error_msgs,\n\t.status_error_mask = BIT(ADIS16209_STAT_SELFTEST_FAIL_BIT) |\n\t\tBIT(ADIS16209_STAT_SPI_FAIL_BIT) |\n\t\tBIT(ADIS16209_STAT_FLASH_UPT_FAIL_BIT) |\n\t\tBIT(ADIS16209_STAT_POWER_HIGH_BIT) |\n\t\tBIT(ADIS16209_STAT_POWER_LOW_BIT),\n};\n\nstatic int adis16209_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct adis *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tindio_dev->name = spi->dev.driver->name;\n\tindio_dev->info = &adis16209_info;\n\tindio_dev->channels = adis16209_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adis16209_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = adis_init(st, indio_dev, spi, &adis16209_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_adis_setup_buffer_and_trigger(st, indio_dev, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __adis_initial_startup(st);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic struct spi_driver adis16209_driver = {\n\t.driver = {\n\t\t.name = \"adis16209\",\n\t},\n\t.probe = adis16209_probe,\n};\nmodule_spi_driver(adis16209_driver);\n\nMODULE_AUTHOR(\"Barry Song <21cnbao@gmail.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADIS16209 Dual-Axis Digital Inclinometer and Accelerometer\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"spi:adis16209\");\nMODULE_IMPORT_NS(IIO_ADISLIB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}