{
  "module_name": "adxl355_core.c",
  "hash_id": "19bb752676f9404e681c231852a09de9ebb25154b164a9502936a19a5b934ab3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/adxl355_core.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/limits.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/units.h>\n\n#include <asm/unaligned.h>\n\n#include \"adxl355.h\"\n\n \n#define ADXL355_DEVID_AD_REG\t\t0x00\n#define ADXL355_DEVID_MST_REG\t\t0x01\n#define ADXL355_PARTID_REG\t\t0x02\n#define ADXL355_STATUS_REG\t\t0x04\n#define ADXL355_FIFO_ENTRIES_REG\t0x05\n#define ADXL355_TEMP2_REG\t\t0x06\n#define ADXL355_XDATA3_REG\t\t0x08\n#define ADXL355_YDATA3_REG\t\t0x0B\n#define ADXL355_ZDATA3_REG\t\t0x0E\n#define ADXL355_FIFO_DATA_REG\t\t0x11\n#define ADXL355_OFFSET_X_H_REG\t\t0x1E\n#define ADXL355_OFFSET_Y_H_REG\t\t0x20\n#define ADXL355_OFFSET_Z_H_REG\t\t0x22\n#define ADXL355_ACT_EN_REG\t\t0x24\n#define ADXL355_ACT_THRESH_H_REG\t0x25\n#define ADXL355_ACT_THRESH_L_REG\t0x26\n#define ADXL355_ACT_COUNT_REG\t\t0x27\n#define ADXL355_FILTER_REG\t\t0x28\n#define  ADXL355_FILTER_ODR_MSK GENMASK(3, 0)\n#define  ADXL355_FILTER_HPF_MSK\tGENMASK(6, 4)\n#define ADXL355_FIFO_SAMPLES_REG\t0x29\n#define ADXL355_INT_MAP_REG\t\t0x2A\n#define ADXL355_SYNC_REG\t\t0x2B\n#define ADXL355_RANGE_REG\t\t0x2C\n#define ADXL355_POWER_CTL_REG\t\t0x2D\n#define  ADXL355_POWER_CTL_MODE_MSK\tGENMASK(1, 0)\n#define  ADXL355_POWER_CTL_DRDY_MSK\tBIT(2)\n#define ADXL355_SELF_TEST_REG\t\t0x2E\n#define ADXL355_RESET_REG\t\t0x2F\n\n#define ADXL355_DEVID_AD_VAL\t\t0xAD\n#define ADXL355_DEVID_MST_VAL\t\t0x1D\n#define ADXL355_PARTID_VAL\t\t0xED\n#define ADXL359_PARTID_VAL\t\t0xE9\n#define ADXL355_RESET_CODE\t\t0x52\n\nstatic const struct regmap_range adxl355_read_reg_range[] = {\n\tregmap_reg_range(ADXL355_DEVID_AD_REG, ADXL355_FIFO_DATA_REG),\n\tregmap_reg_range(ADXL355_OFFSET_X_H_REG, ADXL355_SELF_TEST_REG),\n};\n\nconst struct regmap_access_table adxl355_readable_regs_tbl = {\n\t.yes_ranges = adxl355_read_reg_range,\n\t.n_yes_ranges = ARRAY_SIZE(adxl355_read_reg_range),\n};\nEXPORT_SYMBOL_NS_GPL(adxl355_readable_regs_tbl, IIO_ADXL355);\n\nstatic const struct regmap_range adxl355_write_reg_range[] = {\n\tregmap_reg_range(ADXL355_OFFSET_X_H_REG, ADXL355_RESET_REG),\n};\n\nconst struct regmap_access_table adxl355_writeable_regs_tbl = {\n\t.yes_ranges = adxl355_write_reg_range,\n\t.n_yes_ranges = ARRAY_SIZE(adxl355_write_reg_range),\n};\nEXPORT_SYMBOL_NS_GPL(adxl355_writeable_regs_tbl, IIO_ADXL355);\n\nconst struct adxl355_chip_info adxl35x_chip_info[] = {\n\t[ADXL355] = {\n\t\t.name = \"adxl355\",\n\t\t.part_id = ADXL355_PARTID_VAL,\n\t\t \n\t\t.accel_scale = {\n\t\t\t.integer = 0,\n\t\t\t.decimal = 38245,\n\t\t},\n\t\t \n\t\t.temp_offset = {\n\t\t\t.integer =  -2111,\n\t\t\t.decimal = 250000,\n\t\t},\n\t},\n\t[ADXL359] = {\n\t\t.name = \"adxl359\",\n\t\t.part_id = ADXL359_PARTID_VAL,\n\t\t \n\t\t.accel_scale = {\n\t\t\t.integer = 0,\n\t\t\t.decimal = 191229,\n\t\t},\n\t\t \n\t\t.temp_offset = {\n\t\t\t.integer = -2079,\n\t\t\t.decimal = 250000,\n\t\t},\n\t},\n};\nEXPORT_SYMBOL_NS_GPL(adxl35x_chip_info, IIO_ADXL355);\n\nenum adxl355_op_mode {\n\tADXL355_MEASUREMENT,\n\tADXL355_STANDBY,\n\tADXL355_TEMP_OFF,\n};\n\nenum adxl355_odr {\n\tADXL355_ODR_4000HZ,\n\tADXL355_ODR_2000HZ,\n\tADXL355_ODR_1000HZ,\n\tADXL355_ODR_500HZ,\n\tADXL355_ODR_250HZ,\n\tADXL355_ODR_125HZ,\n\tADXL355_ODR_62_5HZ,\n\tADXL355_ODR_31_25HZ,\n\tADXL355_ODR_15_625HZ,\n\tADXL355_ODR_7_813HZ,\n\tADXL355_ODR_3_906HZ,\n};\n\nenum adxl355_hpf_3db {\n\tADXL355_HPF_OFF,\n\tADXL355_HPF_24_7,\n\tADXL355_HPF_6_2084,\n\tADXL355_HPF_1_5545,\n\tADXL355_HPF_0_3862,\n\tADXL355_HPF_0_0954,\n\tADXL355_HPF_0_0238,\n};\n\nstatic const int adxl355_odr_table[][2] = {\n\t[0] = {4000, 0},\n\t[1] = {2000, 0},\n\t[2] = {1000, 0},\n\t[3] = {500, 0},\n\t[4] = {250, 0},\n\t[5] = {125, 0},\n\t[6] = {62, 500000},\n\t[7] = {31, 250000},\n\t[8] = {15, 625000},\n\t[9] = {7, 813000},\n\t[10] = {3, 906000},\n};\n\nstatic const int adxl355_hpf_3db_multipliers[] = {\n\t0,\n\t247000,\n\t62084,\n\t15545,\n\t3862,\n\t954,\n\t238,\n};\n\nenum adxl355_chans {\n\tchan_x, chan_y, chan_z,\n};\n\nstruct adxl355_chan_info {\n\tu8 data_reg;\n\tu8 offset_reg;\n};\n\nstatic const struct adxl355_chan_info adxl355_chans[] = {\n\t[chan_x] = {\n\t\t.data_reg = ADXL355_XDATA3_REG,\n\t\t.offset_reg = ADXL355_OFFSET_X_H_REG\n\t},\n\t[chan_y] = {\n\t\t.data_reg = ADXL355_YDATA3_REG,\n\t\t.offset_reg = ADXL355_OFFSET_Y_H_REG\n\t},\n\t[chan_z] = {\n\t\t.data_reg = ADXL355_ZDATA3_REG,\n\t\t.offset_reg = ADXL355_OFFSET_Z_H_REG\n\t},\n};\n\nstruct adxl355_data {\n\tconst struct adxl355_chip_info *chip_info;\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tstruct mutex lock;  \n\tenum adxl355_op_mode op_mode;\n\tenum adxl355_odr odr;\n\tenum adxl355_hpf_3db hpf_3db;\n\tint calibbias[3];\n\tint adxl355_hpf_3db_table[7][2];\n\tstruct iio_trigger *dready_trig;\n\tunion {\n\t\tu8 transf_buf[3];\n\t\tstruct {\n\t\t\tu8 buf[14];\n\t\t\ts64 ts;\n\t\t} buffer;\n\t} __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic int adxl355_set_op_mode(struct adxl355_data *data,\n\t\t\t       enum adxl355_op_mode op_mode)\n{\n\tint ret;\n\n\tif (data->op_mode == op_mode)\n\t\treturn 0;\n\n\tret = regmap_update_bits(data->regmap, ADXL355_POWER_CTL_REG,\n\t\t\t\t ADXL355_POWER_CTL_MODE_MSK, op_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->op_mode = op_mode;\n\n\treturn ret;\n}\n\nstatic int adxl355_data_rdy_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t      bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct adxl355_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = regmap_update_bits(data->regmap, ADXL355_POWER_CTL_REG,\n\t\t\t\t ADXL355_POWER_CTL_DRDY_MSK,\n\t\t\t\t FIELD_PREP(ADXL355_POWER_CTL_DRDY_MSK,\n\t\t\t\t\t    state ? 0 : 1));\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic void adxl355_fill_3db_frequency_table(struct adxl355_data *data)\n{\n\tu32 multiplier;\n\tu64 div, rem;\n\tu64 odr;\n\tint i;\n\n\todr = mul_u64_u32_shr(adxl355_odr_table[data->odr][0], MEGA, 0) +\n\t\t\t      adxl355_odr_table[data->odr][1];\n\n\tfor (i = 0; i < ARRAY_SIZE(adxl355_hpf_3db_multipliers); i++) {\n\t\tmultiplier = adxl355_hpf_3db_multipliers[i];\n\t\tdiv = div64_u64_rem(mul_u64_u32_shr(odr, multiplier, 0),\n\t\t\t\t    TERA * 100, &rem);\n\n\t\tdata->adxl355_hpf_3db_table[i][0] = div;\n\t\tdata->adxl355_hpf_3db_table[i][1] = div_u64(rem, MEGA * 100);\n\t}\n}\n\nstatic int adxl355_setup(struct adxl355_data *data)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(data->regmap, ADXL355_DEVID_AD_REG, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tif (regval != ADXL355_DEVID_AD_VAL) {\n\t\tdev_err(data->dev, \"Invalid ADI ID 0x%02x\\n\", regval);\n\t\treturn -ENODEV;\n\t}\n\n\tret = regmap_read(data->regmap, ADXL355_DEVID_MST_REG, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tif (regval != ADXL355_DEVID_MST_VAL) {\n\t\tdev_err(data->dev, \"Invalid MEMS ID 0x%02x\\n\", regval);\n\t\treturn -ENODEV;\n\t}\n\n\tret = regmap_read(data->regmap, ADXL355_PARTID_REG, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tif (regval != ADXL355_PARTID_VAL)\n\t\tdev_warn(data->dev, \"Invalid DEV ID 0x%02x\\n\", regval);\n\n\t \n\tret = regmap_write(data->regmap, ADXL355_RESET_REG, ADXL355_RESET_CODE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(data->regmap, ADXL355_POWER_CTL_REG,\n\t\t\t\t ADXL355_POWER_CTL_DRDY_MSK,\n\t\t\t\t FIELD_PREP(ADXL355_POWER_CTL_DRDY_MSK, 1));\n\tif (ret)\n\t\treturn ret;\n\n\tadxl355_fill_3db_frequency_table(data);\n\n\treturn adxl355_set_op_mode(data, ADXL355_MEASUREMENT);\n}\n\nstatic int adxl355_get_temp_data(struct adxl355_data *data, u8 addr)\n{\n\treturn regmap_bulk_read(data->regmap, addr, data->transf_buf, 2);\n}\n\nstatic int adxl355_read_axis(struct adxl355_data *data, u8 addr)\n{\n\tint ret;\n\n\tret = regmap_bulk_read(data->regmap, addr, data->transf_buf,\n\t\t\t       ARRAY_SIZE(data->transf_buf));\n\tif (ret)\n\t\treturn ret;\n\n\treturn get_unaligned_be24(data->transf_buf);\n}\n\nstatic int adxl355_find_match(const int (*freq_tbl)[2], const int n,\n\t\t\t      const int val, const int val2)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (freq_tbl[i][0] == val && freq_tbl[i][1] == val2)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int adxl355_set_odr(struct adxl355_data *data,\n\t\t\t   enum adxl355_odr odr)\n{\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\n\tif (data->odr == odr) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn 0;\n\t}\n\n\tret = adxl355_set_op_mode(data, ADXL355_STANDBY);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tret = regmap_update_bits(data->regmap, ADXL355_FILTER_REG,\n\t\t\t\t ADXL355_FILTER_ODR_MSK,\n\t\t\t\t FIELD_PREP(ADXL355_FILTER_ODR_MSK, odr));\n\tif (ret)\n\t\tgoto err_set_opmode;\n\n\tdata->odr = odr;\n\tadxl355_fill_3db_frequency_table(data);\n\n\tret = adxl355_set_op_mode(data, ADXL355_MEASUREMENT);\n\tif (ret)\n\t\tgoto err_set_opmode;\n\n\tmutex_unlock(&data->lock);\n\treturn 0;\n\nerr_set_opmode:\n\tadxl355_set_op_mode(data, ADXL355_MEASUREMENT);\nerr_unlock:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int adxl355_set_hpf_3db(struct adxl355_data *data,\n\t\t\t       enum adxl355_hpf_3db hpf)\n{\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\n\tif (data->hpf_3db == hpf) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn 0;\n\t}\n\n\tret = adxl355_set_op_mode(data, ADXL355_STANDBY);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tret = regmap_update_bits(data->regmap, ADXL355_FILTER_REG,\n\t\t\t\t ADXL355_FILTER_HPF_MSK,\n\t\t\t\t FIELD_PREP(ADXL355_FILTER_HPF_MSK, hpf));\n\tif (ret)\n\t\tgoto err_set_opmode;\n\n\tdata->hpf_3db = hpf;\n\n\tret = adxl355_set_op_mode(data, ADXL355_MEASUREMENT);\n\tif (ret)\n\t\tgoto err_set_opmode;\n\n\tmutex_unlock(&data->lock);\n\treturn 0;\n\nerr_set_opmode:\n\tadxl355_set_op_mode(data, ADXL355_MEASUREMENT);\nerr_unlock:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int adxl355_set_calibbias(struct adxl355_data *data,\n\t\t\t\t enum adxl355_chans chan, int calibbias)\n{\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\n\tret = adxl355_set_op_mode(data, ADXL355_STANDBY);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tput_unaligned_be16(calibbias, data->transf_buf);\n\tret = regmap_bulk_write(data->regmap,\n\t\t\t\tadxl355_chans[chan].offset_reg,\n\t\t\t\tdata->transf_buf, 2);\n\tif (ret)\n\t\tgoto err_set_opmode;\n\n\tdata->calibbias[chan] = calibbias;\n\n\tret = adxl355_set_op_mode(data, ADXL355_MEASUREMENT);\n\tif (ret)\n\t\tgoto err_set_opmode;\n\n\tmutex_unlock(&data->lock);\n\treturn 0;\n\nerr_set_opmode:\n\tadxl355_set_op_mode(data, ADXL355_MEASUREMENT);\nerr_unlock:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int adxl355_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct adxl355_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\tret = adxl355_get_temp_data(data, chan->address);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = get_unaligned_be16(data->transf_buf);\n\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_ACCEL:\n\t\t\tret = adxl355_read_axis(data, adxl355_chans[\n\t\t\t\t\t\tchan->address].data_reg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = sign_extend32(ret >> chan->scan_type.shift,\n\t\t\t\t\t     chan->scan_type.realbits - 1);\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = -110;\n\t\t\t*val2 = 497238;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_ACCEL:\n\t\t\t*val = data->chip_info->accel_scale.integer;\n\t\t\t*val2 = data->chip_info->accel_scale.decimal;\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = data->chip_info->temp_offset.integer;\n\t\t*val2 = data->chip_info->temp_offset.decimal;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\t*val = sign_extend32(data->calibbias[chan->address], 15);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = adxl355_odr_table[data->odr][0];\n\t\t*val2 = adxl355_odr_table[data->odr][1];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\t*val = data->adxl355_hpf_3db_table[data->hpf_3db][0];\n\t\t*val2 = data->adxl355_hpf_3db_table[data->hpf_3db][1];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxl355_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct adxl355_data *data = iio_priv(indio_dev);\n\tint odr_idx, hpf_idx, calibbias;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\todr_idx = adxl355_find_match(adxl355_odr_table,\n\t\t\t\t\t     ARRAY_SIZE(adxl355_odr_table),\n\t\t\t\t\t     val, val2);\n\t\tif (odr_idx < 0)\n\t\t\treturn odr_idx;\n\n\t\treturn adxl355_set_odr(data, odr_idx);\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\thpf_idx = adxl355_find_match(data->adxl355_hpf_3db_table,\n\t\t\t\t\tARRAY_SIZE(data->adxl355_hpf_3db_table),\n\t\t\t\t\t     val, val2);\n\t\tif (hpf_idx < 0)\n\t\t\treturn hpf_idx;\n\n\t\treturn adxl355_set_hpf_3db(data, hpf_idx);\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tcalibbias = clamp_t(int, val, S16_MIN, S16_MAX);\n\n\t\treturn adxl355_set_calibbias(data, chan->address, calibbias);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxl355_read_avail(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      const int **vals, int *type, int *length,\n\t\t\t      long mask)\n{\n\tstruct adxl355_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*vals = (const int *)adxl355_odr_table;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t \n\t\t*length = ARRAY_SIZE(adxl355_odr_table) * 2;\n\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\t*vals = (const int *)data->adxl355_hpf_3db_table;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t \n\t\t*length = ARRAY_SIZE(data->adxl355_hpf_3db_table) * 2;\n\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const unsigned long adxl355_avail_scan_masks[] = {\n\tGENMASK(3, 0),\n\t0\n};\n\nstatic const struct iio_info adxl355_info = {\n\t.read_raw\t= adxl355_read_raw,\n\t.write_raw\t= adxl355_write_raw,\n\t.read_avail\t= &adxl355_read_avail,\n};\n\nstatic const struct iio_trigger_ops adxl355_trigger_ops = {\n\t.set_trigger_state = &adxl355_data_rdy_trigger_set_state,\n\t.validate_device = &iio_trigger_validate_own_device,\n};\n\nstatic irqreturn_t adxl355_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct adxl355_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\n\t \n\tdata->buffer.buf[0] = 0;\n\n\t \n\tret = regmap_bulk_read(data->regmap, ADXL355_XDATA3_REG,\n\t\t\t       &data->buffer.buf[1], 3);\n\tif (ret)\n\t\tgoto out_unlock_notify;\n\n\tret = regmap_bulk_read(data->regmap, ADXL355_YDATA3_REG,\n\t\t\t       &data->buffer.buf[5], 3);\n\tif (ret)\n\t\tgoto out_unlock_notify;\n\n\tret = regmap_bulk_read(data->regmap, ADXL355_ZDATA3_REG,\n\t\t\t       &data->buffer.buf[9], 3);\n\tif (ret)\n\t\tgoto out_unlock_notify;\n\n\tret = regmap_bulk_read(data->regmap, ADXL355_TEMP2_REG,\n\t\t\t       &data->buffer.buf[12], 2);\n\tif (ret)\n\t\tgoto out_unlock_notify;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->buffer,\n\t\t\t\t\t   pf->timestamp);\n\nout_unlock_notify:\n\tmutex_unlock(&data->lock);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\n#define ADXL355_ACCEL_CHANNEL(index, reg, axis) {\t\t\t\\\n\t.type = IIO_ACCEL,\t\t\t\t\t\t\\\n\t.address = reg,\t\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##axis,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_CALIBBIAS),\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\t\\\n\t\t\t\t    BIT(IIO_CHAN_INFO_SAMP_FREQ) |\t\\\n\t\tBIT(IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY),\t\\\n\t.info_mask_shared_by_type_available =\t\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ) |\t\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY),\t\\\n\t.scan_index = index,\t\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\t\\\n\t\t.realbits = 20,\t\t\t\t\t\t\\\n\t\t.storagebits = 32,\t\t\t\t\t\\\n\t\t.shift = 4,\t\t\t\t\t\t\\\n\t\t.endianness = IIO_BE,\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec adxl355_channels[] = {\n\tADXL355_ACCEL_CHANNEL(0, chan_x, X),\n\tADXL355_ACCEL_CHANNEL(1, chan_y, Y),\n\tADXL355_ACCEL_CHANNEL(2, chan_z, Z),\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = ADXL355_TEMP2_REG,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.scan_index = 3,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 12,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic int adxl355_probe_trigger(struct iio_dev *indio_dev, int irq)\n{\n\tstruct adxl355_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tdata->dready_trig = devm_iio_trigger_alloc(data->dev, \"%s-dev%d\",\n\t\t\t\t\t\t   indio_dev->name,\n\t\t\t\t\t\t   iio_device_id(indio_dev));\n\tif (!data->dready_trig)\n\t\treturn -ENOMEM;\n\n\tdata->dready_trig->ops = &adxl355_trigger_ops;\n\tiio_trigger_set_drvdata(data->dready_trig, indio_dev);\n\n\tret = devm_request_irq(data->dev, irq,\n\t\t\t       &iio_trigger_generic_data_rdy_poll,\n\t\t\t       IRQF_ONESHOT, \"adxl355_irq\", data->dready_trig);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret, \"request irq %d failed\\n\",\n\t\t\t\t     irq);\n\n\tret = devm_iio_trigger_register(data->dev, data->dready_trig);\n\tif (ret) {\n\t\tdev_err(data->dev, \"iio trigger register failed\\n\");\n\t\treturn ret;\n\t}\n\n\tindio_dev->trig = iio_trigger_get(data->dready_trig);\n\n\treturn 0;\n}\n\nint adxl355_core_probe(struct device *dev, struct regmap *regmap,\n\t\t       const struct adxl355_chip_info *chip_info)\n{\n\tstruct adxl355_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\tint irq;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->regmap = regmap;\n\tdata->dev = dev;\n\tdata->op_mode = ADXL355_STANDBY;\n\tdata->chip_info = chip_info;\n\tmutex_init(&data->lock);\n\n\tindio_dev->name = chip_info->name;\n\tindio_dev->info = &adxl355_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = adxl355_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adxl355_channels);\n\tindio_dev->available_scan_masks = adxl355_avail_scan_masks;\n\n\tret = adxl355_setup(data);\n\tif (ret) {\n\t\tdev_err(dev, \"ADXL355 setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev,\n\t\t\t\t\t      &iio_pollfunc_store_time,\n\t\t\t\t\t      &adxl355_trigger_handler, NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"iio triggered buffer setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tirq = fwnode_irq_get_byname(dev_fwnode(dev), \"DRDY\");\n\tif (irq > 0) {\n\t\tret = adxl355_probe_trigger(indio_dev, irq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(adxl355_core_probe, IIO_ADXL355);\n\nMODULE_AUTHOR(\"Puranjay Mohan <puranjay12@gmail.com>\");\nMODULE_DESCRIPTION(\"ADXL355 3-Axis Digital Accelerometer core driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}