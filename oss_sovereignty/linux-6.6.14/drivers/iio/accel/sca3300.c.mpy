{
  "module_name": "sca3300.c",
  "hash_id": "00f6422c42f09b1345d9127ab3739d31c792f6a18bb80f47aaa18c61b64d4de9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/sca3300.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/crc8.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n\n#include <asm/unaligned.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define SCA3300_ALIAS \"sca3300\"\n\n#define SCA3300_CRC8_POLYNOMIAL 0x1d\n\n \n#define SCA3300_REG_MODE\t0xd\n#define SCA3300_MODE_SW_RESET\t0x20\n\n \n#define SCA3300_REG_SELBANK\t0x1f\n\n \n#define SCA3300_REG_STATUS\t0x6\n#define SCA3300_STATUS_MASK\tGENMASK(8, 0)\n\n \n#define SCA3300_REG_WHOAMI\t0x10\n#define SCA3300_WHOAMI_ID\t0x51\n#define SCL3300_WHOAMI_ID\t0xC1\n\n \n#define SCA3300_VALUE_RS_ERROR\t0x3\n#define SCA3300_MASK_RS_STATUS\tGENMASK(1, 0)\n\n#define SCL3300_REG_ANG_CTRL 0x0C\n#define SCL3300_ANG_ENABLE   0x1F\n\nenum sca3300_scan_indexes {\n\tSCA3300_ACC_X = 0,\n\tSCA3300_ACC_Y,\n\tSCA3300_ACC_Z,\n\tSCA3300_TEMP,\n\tSCA3300_INCLI_X,\n\tSCA3300_INCLI_Y,\n\tSCA3300_INCLI_Z,\n\tSCA3300_SCAN_MAX\n};\n\n \n#define SCA3300_MAX_BUFFER_SIZE (ALIGN(sizeof(s16) * SCA3300_SCAN_MAX, sizeof(s64)) + sizeof(s64))\n\n#define SCA3300_ACCEL_CHANNEL(index, reg, axis) {\t\t\t\\\n\t.type = IIO_ACCEL,\t\t\t\t\t\t\\\n\t.address = reg,\t\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##axis,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type =\t\t\t\t\t\\\n\tBIT(IIO_CHAN_INFO_SCALE) |\t\t\t\t\t\\\n\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\t\t\\\n\t.info_mask_shared_by_type_available =\t\t\t\t\\\n\tBIT(IIO_CHAN_INFO_SCALE) |\t\t\t\t\t\\\n\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\t\t\\\n\t.scan_index = index,\t\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\t\\\n\t\t.realbits = 16,\t\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\t\\\n\t\t.endianness = IIO_CPU,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\n#define SCA3300_INCLI_CHANNEL(index, reg, axis) {\t\t\t\\\n\t.type = IIO_INCLI,\t\t\t\t\t\t\\\n\t.address = reg,\t\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##axis,\t\t\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SCALE), \\\n\t.scan_index = index,\t\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\t\\\n\t\t.realbits = 16,\t\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\t\\\n\t\t.endianness = IIO_CPU,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\n#define SCA3300_TEMP_CHANNEL(index, reg) {\t\t\t\t\\\n\t\t.type = IIO_TEMP,\t\t\t\t\t\\\n\t\t.address = reg,\t\t\t\t\t\t\\\n\t\t.scan_index = index,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\t\\\n\t\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.endianness = IIO_CPU,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec sca3300_channels[] = {\n\tSCA3300_ACCEL_CHANNEL(SCA3300_ACC_X, 0x1, X),\n\tSCA3300_ACCEL_CHANNEL(SCA3300_ACC_Y, 0x2, Y),\n\tSCA3300_ACCEL_CHANNEL(SCA3300_ACC_Z, 0x3, Z),\n\tSCA3300_TEMP_CHANNEL(SCA3300_TEMP, 0x05),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic const int sca3300_lp_freq[] = {70, 10};\nstatic const int sca3300_lp_freq_map[] = {0, 0, 0, 1};\n\nstatic const int scl3300_lp_freq[] = {40, 70, 10};\nstatic const int scl3300_lp_freq_map[] = {0, 1, 2};\n\nstatic const int sca3300_accel_scale[][2] = {{0, 370}, {0, 741}, {0, 185}};\nstatic const int sca3300_accel_scale_map[] = {0, 1, 2, 2};\n\nstatic const int scl3300_accel_scale[][2] = {{0, 167}, {0, 333}, {0, 83}};\nstatic const int scl3300_accel_scale_map[] = {0, 1, 2};\n\nstatic const int scl3300_incli_scale[][2] = {{0, 5495}};\nstatic const int scl3300_incli_scale_map[] = {0, 0, 0};\n\nstatic const int sca3300_avail_modes_map[] = {0, 1, 2, 3};\nstatic const int scl3300_avail_modes_map[] = {0, 1, 3};\n\nstatic const struct iio_chan_spec scl3300_channels[] = {\n\tSCA3300_ACCEL_CHANNEL(SCA3300_ACC_X, 0x1, X),\n\tSCA3300_ACCEL_CHANNEL(SCA3300_ACC_Y, 0x2, Y),\n\tSCA3300_ACCEL_CHANNEL(SCA3300_ACC_Z, 0x3, Z),\n\tSCA3300_TEMP_CHANNEL(SCA3300_TEMP, 0x05),\n\tSCA3300_INCLI_CHANNEL(SCA3300_INCLI_X, 0x09, X),\n\tSCA3300_INCLI_CHANNEL(SCA3300_INCLI_Y, 0x0A, Y),\n\tSCA3300_INCLI_CHANNEL(SCA3300_INCLI_Z, 0x0B, Z),\n\tIIO_CHAN_SOFT_TIMESTAMP(7),\n};\n\nstatic const unsigned long sca3300_scan_masks[] = {\n\tBIT(SCA3300_ACC_X) | BIT(SCA3300_ACC_Y) | BIT(SCA3300_ACC_Z) |\n\tBIT(SCA3300_TEMP),\n\t0\n};\n\nstatic const unsigned long scl3300_scan_masks[] = {\n\tBIT(SCA3300_ACC_X) | BIT(SCA3300_ACC_Y) | BIT(SCA3300_ACC_Z) |\n\tBIT(SCA3300_TEMP) |\n\tBIT(SCA3300_INCLI_X) | BIT(SCA3300_INCLI_Y) | BIT(SCA3300_INCLI_Z),\n\t0\n};\n\nstruct sca3300_chip_info {\n\tconst char *name;\n\tconst unsigned long *scan_masks;\n\tconst struct iio_chan_spec *channels;\n\tu8 num_channels;\n\tu8 num_accel_scales;\n\tconst int (*accel_scale)[2];\n\tconst int *accel_scale_map;\n\tconst int (*incli_scale)[2];\n\tconst int *incli_scale_map;\n\tu8 num_incli_scales;\n\tu8 num_freqs;\n\tconst int *freq_table;\n\tconst int *freq_map;\n\tconst int *avail_modes_table;\n\tu8 num_avail_modes;\n\tu8 chip_id;\n\tbool angle_supported;\n};\n\n \nstruct sca3300_data {\n\tstruct spi_device *spi;\n\tstruct mutex lock;\n\tconst struct sca3300_chip_info *chip;\n\tu8 buffer[SCA3300_MAX_BUFFER_SIZE] __aligned(sizeof(s64));\n\tu8 txbuf[4] __aligned(IIO_DMA_MINALIGN);\n\tu8 rxbuf[4];\n};\n\nstatic const struct sca3300_chip_info sca3300_chip_tbl[] = {\n\t{\n\t\t.name = \"sca3300\",\n\t\t.scan_masks = sca3300_scan_masks,\n\t\t.channels = sca3300_channels,\n\t\t.num_channels = ARRAY_SIZE(sca3300_channels),\n\t\t.num_accel_scales = ARRAY_SIZE(sca3300_accel_scale)*2,\n\t\t.accel_scale = sca3300_accel_scale,\n\t\t.accel_scale_map = sca3300_accel_scale_map,\n\t\t.num_freqs = ARRAY_SIZE(sca3300_lp_freq),\n\t\t.freq_table = sca3300_lp_freq,\n\t\t.freq_map = sca3300_lp_freq_map,\n\t\t.avail_modes_table = sca3300_avail_modes_map,\n\t\t.num_avail_modes = 4,\n\t\t.chip_id = SCA3300_WHOAMI_ID,\n\t\t.angle_supported = false,\n\t},\n\t{\n\t\t.name = \"scl3300\",\n\t\t.scan_masks = scl3300_scan_masks,\n\t\t.channels = scl3300_channels,\n\t\t.num_channels = ARRAY_SIZE(scl3300_channels),\n\t\t.num_accel_scales = ARRAY_SIZE(scl3300_accel_scale)*2,\n\t\t.accel_scale = scl3300_accel_scale,\n\t\t.accel_scale_map = scl3300_accel_scale_map,\n\t\t.incli_scale = scl3300_incli_scale,\n\t\t.incli_scale_map = scl3300_incli_scale_map,\n\t\t.num_incli_scales =  ARRAY_SIZE(scl3300_incli_scale)*2,\n\t\t.num_freqs = ARRAY_SIZE(scl3300_lp_freq),\n\t\t.freq_table = scl3300_lp_freq,\n\t\t.freq_map = scl3300_lp_freq_map,\n\t\t.avail_modes_table = scl3300_avail_modes_map,\n\t\t.num_avail_modes = 3,\n\t\t.chip_id = SCL3300_WHOAMI_ID,\n\t\t.angle_supported = true,\n\t},\n};\n\nDECLARE_CRC8_TABLE(sca3300_crc_table);\n\nstatic int sca3300_transfer(struct sca3300_data *sca_data, int *val)\n{\n\t \n\tstruct spi_delay delay = { .value = 10, .unit = SPI_DELAY_UNIT_USECS };\n\tint32_t ret;\n\tint rs;\n\tu8 crc;\n\tstruct spi_transfer xfers[2] = {\n\t\t{\n\t\t\t.tx_buf = sca_data->txbuf,\n\t\t\t.len = ARRAY_SIZE(sca_data->txbuf),\n\t\t\t.delay = delay,\n\t\t\t.cs_change = 1,\n\t\t},\n\t\t{\n\t\t\t.rx_buf = sca_data->rxbuf,\n\t\t\t.len = ARRAY_SIZE(sca_data->rxbuf),\n\t\t\t.delay = delay,\n\t\t}\n\t};\n\n\t \n\tcrc = ~crc8(sca3300_crc_table, &sca_data->txbuf[0], 3, CRC8_INIT_VALUE);\n\tsca_data->txbuf[3] = crc;\n\n\tret = spi_sync_transfer(sca_data->spi, xfers, ARRAY_SIZE(xfers));\n\tif (ret) {\n\t\tdev_err(&sca_data->spi->dev,\n\t\t\t\"transfer error, error: %d\\n\", ret);\n\t\treturn -EIO;\n\t}\n\n\tcrc = ~crc8(sca3300_crc_table, &sca_data->rxbuf[0], 3, CRC8_INIT_VALUE);\n\tif (sca_data->rxbuf[3] != crc) {\n\t\tdev_err(&sca_data->spi->dev, \"CRC checksum mismatch\");\n\t\treturn -EIO;\n\t}\n\n\t \n\trs = sca_data->rxbuf[0] & SCA3300_MASK_RS_STATUS;\n\tif (rs == SCA3300_VALUE_RS_ERROR)\n\t\tret = -EINVAL;\n\n\t*val = sign_extend32(get_unaligned_be16(&sca_data->rxbuf[1]), 15);\n\n\treturn ret;\n}\n\nstatic int sca3300_error_handler(struct sca3300_data *sca_data)\n{\n\tint ret;\n\tint val;\n\n\tmutex_lock(&sca_data->lock);\n\tsca_data->txbuf[0] = SCA3300_REG_STATUS << 2;\n\tret = sca3300_transfer(sca_data, &val);\n\tmutex_unlock(&sca_data->lock);\n\t \n\tif (ret != -EINVAL) {\n\t\tdev_err(&sca_data->spi->dev,\n\t\t\t\"error reading device status: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_err(&sca_data->spi->dev, \"device status: 0x%lx\\n\",\n\t\tval & SCA3300_STATUS_MASK);\n\n\treturn 0;\n}\n\nstatic int sca3300_read_reg(struct sca3300_data *sca_data, u8 reg, int *val)\n{\n\tint ret;\n\n\tmutex_lock(&sca_data->lock);\n\tsca_data->txbuf[0] = reg << 2;\n\tret = sca3300_transfer(sca_data, val);\n\tmutex_unlock(&sca_data->lock);\n\tif (ret != -EINVAL)\n\t\treturn ret;\n\n\treturn sca3300_error_handler(sca_data);\n}\n\nstatic int sca3300_write_reg(struct sca3300_data *sca_data, u8 reg, int val)\n{\n\tint reg_val = 0;\n\tint ret;\n\n\tmutex_lock(&sca_data->lock);\n\t \n\tsca_data->txbuf[0] = BIT(7) | (reg << 2);\n\tput_unaligned_be16(val, &sca_data->txbuf[1]);\n\tret = sca3300_transfer(sca_data, &reg_val);\n\tmutex_unlock(&sca_data->lock);\n\tif (ret != -EINVAL)\n\t\treturn ret;\n\n\treturn sca3300_error_handler(sca_data);\n}\n\nstatic int sca3300_set_op_mode(struct sca3300_data *sca_data, int index)\n{\n\tif ((index < 0) || (index >= sca_data->chip->num_avail_modes))\n\t\treturn -EINVAL;\n\n\treturn sca3300_write_reg(sca_data, SCA3300_REG_MODE,\n\t\t\t\t sca_data->chip->avail_modes_table[index]);\n}\n\nstatic int sca3300_get_op_mode(struct sca3300_data *sca_data, int *index)\n{\n\tint reg_val;\n\tint ret;\n\tint i;\n\n\tret = sca3300_read_reg(sca_data, SCA3300_REG_MODE, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < sca_data->chip->num_avail_modes; i++) {\n\t\tif (sca_data->chip->avail_modes_table[i] == reg_val)\n\t\t\tbreak;\n\t}\n\tif (i == sca_data->chip->num_avail_modes)\n\t\treturn -EINVAL;\n\n\t*index = i;\n\treturn 0;\n}\n\nstatic int sca3300_set_frequency(struct sca3300_data *data, int val)\n{\n\tconst struct sca3300_chip_info *chip = data->chip;\n\tunsigned int index;\n\tint *opmode_scale;\n\tint *new_scale;\n\tunsigned int i;\n\n\tif (sca3300_get_op_mode(data, &index))\n\t\treturn -EINVAL;\n\n\t \n\topmode_scale = (int *)chip->accel_scale[chip->accel_scale_map[index]];\n\tfor (i = 0; i < chip->num_avail_modes; i++) {\n\t\tnew_scale = (int *)chip->accel_scale[chip->accel_scale_map[i]];\n\t\tif ((val == chip->freq_table[chip->freq_map[i]]) &&\n\t\t    (opmode_scale[1] == new_scale[1]) &&\n\t\t    (opmode_scale[0] == new_scale[0]))\n\t\t\tbreak;\n\t}\n\tif (i == chip->num_avail_modes)\n\t\treturn -EINVAL;\n\n\treturn sca3300_set_op_mode(data, i);\n}\n\nstatic int sca3300_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct sca3300_data *data = iio_priv(indio_dev);\n\tint index;\n\tint i;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type != IIO_ACCEL)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tfor (i = 0; i < data->chip->num_avail_modes; i++) {\n\t\t\tindex = data->chip->accel_scale_map[i];\n\t\t\tif ((val  == data->chip->accel_scale[index][0]) &&\n\t\t\t    (val2 == data->chip->accel_scale[index][1]))\n\t\t\t\treturn sca3300_set_op_mode(data, i);\n\t\t}\n\t\treturn -EINVAL;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn sca3300_set_frequency(data, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sca3300_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct sca3300_data *data = iio_priv(indio_dev);\n\tint index;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = sca3300_read_reg(data, chan->address, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = sca3300_get_op_mode(data, &index);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tswitch (chan->type) {\n\t\tcase IIO_INCLI:\n\t\t\tindex = data->chip->incli_scale_map[index];\n\t\t\t*val  = data->chip->incli_scale[index][0];\n\t\t\t*val2 = data->chip->incli_scale[index][1];\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_ACCEL:\n\t\t\tindex = data->chip->accel_scale_map[index];\n\t\t\t*val  = data->chip->accel_scale[index][0];\n\t\t\t*val2 = data->chip->accel_scale[index][1];\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tret = sca3300_get_op_mode(data, &index);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tindex = data->chip->freq_map[index];\n\t\t*val = data->chip->freq_table[index];\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic irqreturn_t sca3300_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct sca3300_data *data = iio_priv(indio_dev);\n\tint bit, ret, val, i = 0;\n\ts16 *channels = (s16 *)data->buffer;\n\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\tret = sca3300_read_reg(data, indio_dev->channels[bit].address, &val);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(&data->spi->dev,\n\t\t\t\t\"failed to read register, error: %d\\n\", ret);\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\t\tchannels[i++] = val;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, data->buffer,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\nout:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int sca3300_init(struct sca3300_data *sca_data,\n\t\t\tstruct iio_dev *indio_dev)\n{\n\tint value = 0;\n\tint ret;\n\tint i;\n\n\tret = sca3300_write_reg(sca_data, SCA3300_REG_MODE,\n\t\t\t\tSCA3300_MODE_SW_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(26e3, 50e3);\n\n\tret = sca3300_read_reg(sca_data, SCA3300_REG_WHOAMI, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(sca3300_chip_tbl); i++) {\n\t\tif (sca3300_chip_tbl[i].chip_id == value)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(sca3300_chip_tbl)) {\n\t\tdev_err(&sca_data->spi->dev, \"unknown chip id %x\\n\", value);\n\t\treturn -ENODEV;\n\t}\n\n\tsca_data->chip = &sca3300_chip_tbl[i];\n\n\tif (sca_data->chip->angle_supported) {\n\t\tret = sca3300_write_reg(sca_data, SCL3300_REG_ANG_CTRL,\n\t\t\t\t\tSCL3300_ANG_ENABLE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sca3300_debugfs_reg_access(struct iio_dev *indio_dev,\n\t\t\t\t      unsigned int reg, unsigned int writeval,\n\t\t\t\t      unsigned int *readval)\n{\n\tstruct sca3300_data *data = iio_priv(indio_dev);\n\tint value;\n\tint ret;\n\n\tif (reg > SCA3300_REG_SELBANK)\n\t\treturn -EINVAL;\n\n\tif (!readval)\n\t\treturn sca3300_write_reg(data, reg, writeval);\n\n\tret = sca3300_read_reg(data, reg, &value);\n\tif (ret)\n\t\treturn ret;\n\n\t*readval = value;\n\n\treturn 0;\n}\n\nstatic int sca3300_read_avail(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      const int **vals, int *type, int *length,\n\t\t\t      long mask)\n{\n\tstruct sca3300_data *data = iio_priv(indio_dev);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INCLI:\n\t\t\t*vals = (const int *)data->chip->incli_scale;\n\t\t\t*length = data->chip->num_incli_scales;\n\t\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t\treturn IIO_AVAIL_LIST;\n\t\tcase IIO_ACCEL:\n\t\t\t*vals = (const int *)data->chip->accel_scale;\n\t\t\t*length = data->chip->num_accel_scales;\n\t\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t\treturn IIO_AVAIL_LIST;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\t*vals = (const int *)data->chip->freq_table;\n\t\t*length = data->chip->num_freqs;\n\t\t*type = IIO_VAL_INT;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info sca3300_info = {\n\t.read_raw = sca3300_read_raw,\n\t.write_raw = sca3300_write_raw,\n\t.debugfs_reg_access = &sca3300_debugfs_reg_access,\n\t.read_avail = sca3300_read_avail,\n};\n\nstatic int sca3300_probe(struct spi_device *spi)\n{\n\tstruct sca3300_data *sca_data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*sca_data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tsca_data = iio_priv(indio_dev);\n\tmutex_init(&sca_data->lock);\n\tsca_data->spi = spi;\n\n\tcrc8_populate_msb(sca3300_crc_table, SCA3300_CRC8_POLYNOMIAL);\n\n\tindio_dev->info = &sca3300_info;\n\n\tret = sca3300_init(sca_data, indio_dev);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to init device, error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tindio_dev->name = sca_data->chip->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = sca_data->chip->channels;\n\tindio_dev->num_channels = sca_data->chip->num_channels;\n\tindio_dev->available_scan_masks = sca_data->chip->scan_masks;\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev,\n\t\t\t\t\t      iio_pollfunc_store_time,\n\t\t\t\t\t      sca3300_trigger_handler, NULL);\n\tif (ret) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"iio triggered buffer setup failed, error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_iio_device_register(&spi->dev, indio_dev);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"iio device register failed, error: %d\\n\",\n\t\t\tret);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct of_device_id sca3300_dt_ids[] = {\n\t{ .compatible = \"murata,sca3300\"},\n\t{ .compatible = \"murata,scl3300\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sca3300_dt_ids);\n\nstatic const struct spi_device_id sca3300_ids[] = {\n\t{ \"sca3300\" },\n\t{ \"scl3300\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, sca3300_ids);\n\nstatic struct spi_driver sca3300_driver = {\n\t.driver   = {\n\t\t.name\t\t= SCA3300_ALIAS,\n\t\t.of_match_table = sca3300_dt_ids,\n\t},\n\t.probe\t  = sca3300_probe,\n\t.id_table = sca3300_ids,\n};\nmodule_spi_driver(sca3300_driver);\n\nMODULE_AUTHOR(\"Tomas Melin <tomas.melin@vaisala.com>\");\nMODULE_DESCRIPTION(\"Murata SCA3300 SPI Accelerometer\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}