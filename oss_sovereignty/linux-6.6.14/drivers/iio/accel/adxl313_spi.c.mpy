{
  "module_name": "adxl313_spi.c",
  "hash_id": "f98b9184d400af6d8785a312badd72c340e617fb9c32456dd6a96bf26bde892d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/adxl313_spi.c",
  "human_readable_source": "\n \n\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/property.h>\n\n#include \"adxl313.h\"\n\nstatic const struct regmap_config adxl31x_spi_regmap_config[] = {\n\t[ADXL312] = {\n\t\t.reg_bits\t= 8,\n\t\t.val_bits\t= 8,\n\t\t.rd_table\t= &adxl312_readable_regs_table,\n\t\t.wr_table\t= &adxl312_writable_regs_table,\n\t\t.max_register\t= 0x39,\n\t\t \n\t\t.read_flag_mask\t= BIT(7) | BIT(6),\n\t},\n\t[ADXL313] = {\n\t\t.reg_bits\t= 8,\n\t\t.val_bits\t= 8,\n\t\t.rd_table\t= &adxl313_readable_regs_table,\n\t\t.wr_table\t= &adxl313_writable_regs_table,\n\t\t.max_register\t= 0x39,\n\t\t \n\t\t.read_flag_mask\t= BIT(7) | BIT(6),\n\t},\n\t[ADXL314] = {\n\t\t.reg_bits\t= 8,\n\t\t.val_bits\t= 8,\n\t\t.rd_table\t= &adxl314_readable_regs_table,\n\t\t.wr_table\t= &adxl314_writable_regs_table,\n\t\t.max_register\t= 0x39,\n\t\t \n\t\t.read_flag_mask\t= BIT(7) | BIT(6),\n\t},\n};\n\nstatic int adxl313_spi_setup(struct device *dev, struct regmap *regmap)\n{\n\tstruct spi_device *spi = container_of(dev, struct spi_device, dev);\n\tint ret;\n\n\tif (spi->mode & SPI_3WIRE) {\n\t\tret = regmap_write(regmap, ADXL313_REG_DATA_FORMAT,\n\t\t\t\t   ADXL313_SPI_3WIRE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn regmap_update_bits(regmap, ADXL313_REG_POWER_CTL,\n\t\t\t\t  ADXL313_I2C_DISABLE, ADXL313_I2C_DISABLE);\n}\n\nstatic int adxl313_spi_probe(struct spi_device *spi)\n{\n\tconst struct adxl313_chip_info *chip_data;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tspi->mode |= SPI_MODE_3;\n\tret = spi_setup(spi);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tchip_data = device_get_match_data(&spi->dev);\n\tif (!chip_data)\n\t\tchip_data = (const struct adxl313_chip_info *)spi_get_device_id(spi)->driver_data;\n\n\tregmap = devm_regmap_init_spi(spi,\n\t\t\t\t      &adxl31x_spi_regmap_config[chip_data->type]);\n\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&spi->dev, \"Error initializing spi regmap: %ld\\n\",\n\t\t\tPTR_ERR(regmap));\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\treturn adxl313_core_probe(&spi->dev, regmap,\n\t\t\t\t  chip_data, &adxl313_spi_setup);\n}\n\nstatic const struct spi_device_id adxl313_spi_id[] = {\n\t{ .name = \"adxl312\", .driver_data = (kernel_ulong_t)&adxl31x_chip_info[ADXL312] },\n\t{ .name = \"adxl313\", .driver_data = (kernel_ulong_t)&adxl31x_chip_info[ADXL313] },\n\t{ .name = \"adxl314\", .driver_data = (kernel_ulong_t)&adxl31x_chip_info[ADXL314] },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(spi, adxl313_spi_id);\n\nstatic const struct of_device_id adxl313_of_match[] = {\n\t{ .compatible = \"adi,adxl312\", .data = &adxl31x_chip_info[ADXL312] },\n\t{ .compatible = \"adi,adxl313\", .data = &adxl31x_chip_info[ADXL313] },\n\t{ .compatible = \"adi,adxl314\", .data = &adxl31x_chip_info[ADXL314] },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, adxl313_of_match);\n\nstatic struct spi_driver adxl313_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"adxl313_spi\",\n\t\t.of_match_table = adxl313_of_match,\n\t},\n\t.probe\t\t= adxl313_spi_probe,\n\t.id_table\t= adxl313_spi_id,\n};\n\nmodule_spi_driver(adxl313_spi_driver);\n\nMODULE_AUTHOR(\"Lucas Stankus <lucas.p.stankus@gmail.com>\");\nMODULE_DESCRIPTION(\"ADXL313 3-Axis Digital Accelerometer SPI driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_ADXL313);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}