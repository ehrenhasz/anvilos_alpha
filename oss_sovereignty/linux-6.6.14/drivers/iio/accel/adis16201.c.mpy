{
  "module_name": "adis16201.c",
  "hash_id": "7b457f20be6f8cb6e23c579af926d42c8c359db3ee24d2275a65aacf457cde4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/adis16201.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/imu/adis.h>\n\n#define ADIS16201_STARTUP_DELAY_MS\t\t\t220\n#define ADIS16201_FLASH_CNT\t\t\t\t0x00\n\n \n#define ADIS16201_SUPPLY_OUT_REG\t\t\t0x02\n#define ADIS16201_XACCL_OUT_REG\t\t\t\t0x04\n#define ADIS16201_YACCL_OUT_REG\t\t\t\t0x06\n#define ADIS16201_AUX_ADC_REG\t\t\t\t0x08\n#define ADIS16201_TEMP_OUT_REG\t\t\t\t0x0A\n#define ADIS16201_XINCL_OUT_REG\t\t\t\t0x0C\n#define ADIS16201_YINCL_OUT_REG\t\t\t\t0x0E\n\n \n#define ADIS16201_XACCL_OFFS_REG\t\t\t0x10\n#define ADIS16201_YACCL_OFFS_REG\t\t\t0x12\n#define ADIS16201_XACCL_SCALE_REG\t\t\t0x14\n#define ADIS16201_YACCL_SCALE_REG\t\t\t0x16\n#define ADIS16201_XINCL_OFFS_REG\t\t\t0x18\n#define ADIS16201_YINCL_OFFS_REG\t\t\t0x1A\n#define ADIS16201_XINCL_SCALE_REG\t\t\t0x1C\n#define ADIS16201_YINCL_SCALE_REG\t\t\t0x1E\n\n \n#define ADIS16201_ALM_MAG1_REG\t\t\t\t0x20\n#define ADIS16201_ALM_MAG2_REG\t\t\t\t0x22\n#define ADIS16201_ALM_SMPL1_REG\t\t\t\t0x24\n#define ADIS16201_ALM_SMPL2_REG\t\t\t\t0x26\n#define ADIS16201_ALM_CTRL_REG\t\t\t\t0x28\n\n#define ADIS16201_AUX_DAC_REG\t\t\t\t0x30\n#define ADIS16201_GPIO_CTRL_REG\t\t\t\t0x32\n#define ADIS16201_SMPL_PRD_REG\t\t\t\t0x36\n \n#define ADIS16201_AVG_CNT_REG\t\t\t\t0x38\n#define ADIS16201_SLP_CNT_REG\t\t\t\t0x3A\n\n \n#define ADIS16201_MSC_CTRL_REG\t\t\t\t0x34\n#define  ADIS16201_MSC_CTRL_SELF_TEST_EN\t\tBIT(8)\n \n#define  ADIS16201_MSC_CTRL_DATA_RDY_EN\t\t\tBIT(2)\n \n#define  ADIS16201_MSC_CTRL_ACTIVE_DATA_RDY_HIGH\tBIT(1)\n \n#define  ADIS16201_MSC_CTRL_DATA_RDY_DIO1\t\tBIT(0)\n\n \n#define ADIS16201_DIAG_STAT_REG\t\t\t\t0x3C\n#define  ADIS16201_DIAG_STAT_ALARM2\t\t\tBIT(9)\n#define  ADIS16201_DIAG_STAT_ALARM1\t\t\tBIT(8)\n#define  ADIS16201_DIAG_STAT_SPI_FAIL_BIT\t\t3\n#define  ADIS16201_DIAG_STAT_FLASH_UPT_FAIL_BIT\t\t2\n \n#define  ADIS16201_DIAG_STAT_POWER_HIGH_BIT\t\t1\n \n#define  ADIS16201_DIAG_STAT_POWER_LOW_BIT\t\t0\n\n \n#define ADIS16201_GLOB_CMD_REG\t\t\t\t0x3E\n#define  ADIS16201_GLOB_CMD_SW_RESET\t\t\tBIT(7)\n#define  ADIS16201_GLOB_CMD_FACTORY_RESET\t\tBIT(1)\n\n#define ADIS16201_ERROR_ACTIVE\t\t\t\tBIT(14)\n\nenum adis16201_scan {\n\tADIS16201_SCAN_ACC_X,\n\tADIS16201_SCAN_ACC_Y,\n\tADIS16201_SCAN_INCLI_X,\n\tADIS16201_SCAN_INCLI_Y,\n\tADIS16201_SCAN_SUPPLY,\n\tADIS16201_SCAN_AUX_ADC,\n\tADIS16201_SCAN_TEMP,\n};\n\nstatic const u8 adis16201_addresses[] = {\n\t[ADIS16201_SCAN_ACC_X] = ADIS16201_XACCL_OFFS_REG,\n\t[ADIS16201_SCAN_ACC_Y] = ADIS16201_YACCL_OFFS_REG,\n\t[ADIS16201_SCAN_INCLI_X] = ADIS16201_XINCL_OFFS_REG,\n\t[ADIS16201_SCAN_INCLI_Y] = ADIS16201_YINCL_OFFS_REG,\n};\n\nstatic int adis16201_read_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int *val, int *val2,\n\t\t\t      long mask)\n{\n\tstruct adis *st = iio_priv(indio_dev);\n\tint ret;\n\tint bits;\n\tu8 addr;\n\ts16 val16;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn adis_single_conversion(indio_dev, chan,\n\t\t\t\t\t      ADIS16201_ERROR_ACTIVE, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tif (chan->channel == 0) {\n\t\t\t \n\t\t\t\t*val = 1;\n\t\t\t\t*val2 = 220000;\n\t\t\t} else {\n\t\t\t \n\t\t\t\t*val = 0;\n\t\t\t\t*val2 = 610000;\n\t\t\t}\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_TEMP:\n\t\t\t*val = -470;\n\t\t\t*val2 = 0;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_ACCEL:\n\t\t\t \n\t\t\t*val = 0;\n\t\t\t*val2 = IIO_G_TO_M_S_2(462400);\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tcase IIO_INCLI:\n\t\t\t*val = 0;\n\t\t\t*val2 = 100000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\t*val = 25000 / -470 - 1278;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ACCEL:\n\t\t\tbits = 12;\n\t\t\tbreak;\n\t\tcase IIO_INCLI:\n\t\t\tbits = 9;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\taddr = adis16201_addresses[chan->scan_index];\n\t\tret = adis_read_reg_16(st, addr, &val16);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = sign_extend32(val16, bits - 1);\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int adis16201_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val,\n\t\t\t       int val2,\n\t\t\t       long mask)\n{\n\tstruct adis *st = iio_priv(indio_dev);\n\tint m;\n\n\tif (mask != IIO_CHAN_INFO_CALIBBIAS)\n\t\treturn -EINVAL;\n\n\tswitch (chan->type) {\n\tcase IIO_ACCEL:\n\t\tm = GENMASK(11, 0);\n\t\tbreak;\n\tcase IIO_INCLI:\n\t\tm = GENMASK(8, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn adis_write_reg_16(st, adis16201_addresses[chan->scan_index],\n\t\t\t\t val & m);\n}\n\nstatic const struct iio_chan_spec adis16201_channels[] = {\n\tADIS_SUPPLY_CHAN(ADIS16201_SUPPLY_OUT_REG, ADIS16201_SCAN_SUPPLY, 0,\n\t\t\t 12),\n\tADIS_TEMP_CHAN(ADIS16201_TEMP_OUT_REG, ADIS16201_SCAN_TEMP, 0, 12),\n\tADIS_ACCEL_CHAN(X, ADIS16201_XACCL_OUT_REG, ADIS16201_SCAN_ACC_X,\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS), 0, 14),\n\tADIS_ACCEL_CHAN(Y, ADIS16201_YACCL_OUT_REG, ADIS16201_SCAN_ACC_Y,\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS), 0, 14),\n\tADIS_AUX_ADC_CHAN(ADIS16201_AUX_ADC_REG, ADIS16201_SCAN_AUX_ADC, 0, 12),\n\tADIS_INCLI_CHAN(X, ADIS16201_XINCL_OUT_REG, ADIS16201_SCAN_INCLI_X,\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS), 0, 14),\n\tADIS_INCLI_CHAN(Y, ADIS16201_YINCL_OUT_REG, ADIS16201_SCAN_INCLI_Y,\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS), 0, 14),\n\tIIO_CHAN_SOFT_TIMESTAMP(7)\n};\n\nstatic const struct iio_info adis16201_info = {\n\t.read_raw = adis16201_read_raw,\n\t.write_raw = adis16201_write_raw,\n\t.update_scan_mode = adis_update_scan_mode,\n};\n\nstatic const char * const adis16201_status_error_msgs[] = {\n\t[ADIS16201_DIAG_STAT_SPI_FAIL_BIT] = \"SPI failure\",\n\t[ADIS16201_DIAG_STAT_FLASH_UPT_FAIL_BIT] = \"Flash update failed\",\n\t[ADIS16201_DIAG_STAT_POWER_HIGH_BIT] = \"Power supply above 3.625V\",\n\t[ADIS16201_DIAG_STAT_POWER_LOW_BIT] = \"Power supply below 2.975V\",\n};\n\nstatic const struct adis_timeout adis16201_timeouts = {\n\t.reset_ms = ADIS16201_STARTUP_DELAY_MS,\n\t.sw_reset_ms = ADIS16201_STARTUP_DELAY_MS,\n\t.self_test_ms = ADIS16201_STARTUP_DELAY_MS,\n};\n\nstatic const struct adis_data adis16201_data = {\n\t.read_delay = 20,\n\t.msc_ctrl_reg = ADIS16201_MSC_CTRL_REG,\n\t.glob_cmd_reg = ADIS16201_GLOB_CMD_REG,\n\t.diag_stat_reg = ADIS16201_DIAG_STAT_REG,\n\n\t.self_test_mask = ADIS16201_MSC_CTRL_SELF_TEST_EN,\n\t.self_test_reg = ADIS16201_MSC_CTRL_REG,\n\t.self_test_no_autoclear = true,\n\t.timeouts = &adis16201_timeouts,\n\n\t.status_error_msgs = adis16201_status_error_msgs,\n\t.status_error_mask = BIT(ADIS16201_DIAG_STAT_SPI_FAIL_BIT) |\n\t\tBIT(ADIS16201_DIAG_STAT_FLASH_UPT_FAIL_BIT) |\n\t\tBIT(ADIS16201_DIAG_STAT_POWER_HIGH_BIT) |\n\t\tBIT(ADIS16201_DIAG_STAT_POWER_LOW_BIT),\n};\n\nstatic int adis16201_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct adis *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tindio_dev->name = spi->dev.driver->name;\n\tindio_dev->info = &adis16201_info;\n\n\tindio_dev->channels = adis16201_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adis16201_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = adis_init(st, indio_dev, spi, &adis16201_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_adis_setup_buffer_and_trigger(st, indio_dev, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __adis_initial_startup(st);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic struct spi_driver adis16201_driver = {\n\t.driver = {\n\t\t.name = \"adis16201\",\n\t},\n\t.probe = adis16201_probe,\n};\nmodule_spi_driver(adis16201_driver);\n\nMODULE_AUTHOR(\"Barry Song <21cnbao@gmail.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADIS16201 Dual-Axis Digital Inclinometer and Accelerometer\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"spi:adis16201\");\nMODULE_IMPORT_NS(IIO_ADISLIB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}