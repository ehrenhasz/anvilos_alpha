{
  "module_name": "bmc150-accel-core.c",
  "hash_id": "59e8ba555c9224430e1a1d83aeb3cc4e77bb847b992b47db722cabdcd06d8cc2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/bmc150-accel-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/of_irq.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/events.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include \"bmc150-accel.h\"\n\n#define BMC150_ACCEL_DRV_NAME\t\t\t\"bmc150_accel\"\n#define BMC150_ACCEL_IRQ_NAME\t\t\t\"bmc150_accel_event\"\n\n#define BMC150_ACCEL_REG_CHIP_ID\t\t0x00\n\n#define BMC150_ACCEL_REG_INT_STATUS_2\t\t0x0B\n#define BMC150_ACCEL_ANY_MOTION_MASK\t\t0x07\n#define BMC150_ACCEL_ANY_MOTION_BIT_X\t\tBIT(0)\n#define BMC150_ACCEL_ANY_MOTION_BIT_Y\t\tBIT(1)\n#define BMC150_ACCEL_ANY_MOTION_BIT_Z\t\tBIT(2)\n#define BMC150_ACCEL_ANY_MOTION_BIT_SIGN\tBIT(3)\n\n#define BMC150_ACCEL_REG_PMU_LPW\t\t0x11\n#define BMC150_ACCEL_PMU_MODE_MASK\t\t0xE0\n#define BMC150_ACCEL_PMU_MODE_SHIFT\t\t5\n#define BMC150_ACCEL_PMU_BIT_SLEEP_DUR_MASK\t0x17\n#define BMC150_ACCEL_PMU_BIT_SLEEP_DUR_SHIFT\t1\n\n#define BMC150_ACCEL_REG_PMU_RANGE\t\t0x0F\n\n#define BMC150_ACCEL_DEF_RANGE_2G\t\t0x03\n#define BMC150_ACCEL_DEF_RANGE_4G\t\t0x05\n#define BMC150_ACCEL_DEF_RANGE_8G\t\t0x08\n#define BMC150_ACCEL_DEF_RANGE_16G\t\t0x0C\n\n \n#define BMC150_ACCEL_REG_PMU_BW\t\t0x10\n#define BMC150_ACCEL_DEF_BW\t\t\t125\n\n#define BMC150_ACCEL_REG_RESET\t\t\t0x14\n#define BMC150_ACCEL_RESET_VAL\t\t\t0xB6\n\n#define BMC150_ACCEL_REG_INT_MAP_0\t\t0x19\n#define BMC150_ACCEL_INT_MAP_0_BIT_INT1_SLOPE\tBIT(2)\n\n#define BMC150_ACCEL_REG_INT_MAP_1\t\t0x1A\n#define BMC150_ACCEL_INT_MAP_1_BIT_INT1_DATA\tBIT(0)\n#define BMC150_ACCEL_INT_MAP_1_BIT_INT1_FWM\tBIT(1)\n#define BMC150_ACCEL_INT_MAP_1_BIT_INT1_FFULL\tBIT(2)\n#define BMC150_ACCEL_INT_MAP_1_BIT_INT2_FFULL\tBIT(5)\n#define BMC150_ACCEL_INT_MAP_1_BIT_INT2_FWM\tBIT(6)\n#define BMC150_ACCEL_INT_MAP_1_BIT_INT2_DATA\tBIT(7)\n\n#define BMC150_ACCEL_REG_INT_MAP_2\t\t0x1B\n#define BMC150_ACCEL_INT_MAP_2_BIT_INT2_SLOPE\tBIT(2)\n\n#define BMC150_ACCEL_REG_INT_RST_LATCH\t\t0x21\n#define BMC150_ACCEL_INT_MODE_LATCH_RESET\t0x80\n#define BMC150_ACCEL_INT_MODE_LATCH_INT\t0x0F\n#define BMC150_ACCEL_INT_MODE_NON_LATCH_INT\t0x00\n\n#define BMC150_ACCEL_REG_INT_EN_0\t\t0x16\n#define BMC150_ACCEL_INT_EN_BIT_SLP_X\t\tBIT(0)\n#define BMC150_ACCEL_INT_EN_BIT_SLP_Y\t\tBIT(1)\n#define BMC150_ACCEL_INT_EN_BIT_SLP_Z\t\tBIT(2)\n\n#define BMC150_ACCEL_REG_INT_EN_1\t\t0x17\n#define BMC150_ACCEL_INT_EN_BIT_DATA_EN\t\tBIT(4)\n#define BMC150_ACCEL_INT_EN_BIT_FFULL_EN\tBIT(5)\n#define BMC150_ACCEL_INT_EN_BIT_FWM_EN\t\tBIT(6)\n\n#define BMC150_ACCEL_REG_INT_OUT_CTRL\t\t0x20\n#define BMC150_ACCEL_INT_OUT_CTRL_INT1_LVL\tBIT(0)\n#define BMC150_ACCEL_INT_OUT_CTRL_INT2_LVL\tBIT(2)\n\n#define BMC150_ACCEL_REG_INT_5\t\t\t0x27\n#define BMC150_ACCEL_SLOPE_DUR_MASK\t\t0x03\n\n#define BMC150_ACCEL_REG_INT_6\t\t\t0x28\n#define BMC150_ACCEL_SLOPE_THRES_MASK\t\t0xFF\n\n \n#define BMC150_ACCEL_DEF_SLOPE_DURATION\t\t1\n \n#define BMC150_ACCEL_DEF_SLOPE_THRESHOLD\t1\n\n#define BMC150_ACCEL_REG_XOUT_L\t\t0x02\n\n#define BMC150_ACCEL_MAX_STARTUP_TIME_MS\t100\n\n \n#define BMC150_ACCEL_SLEEP_500_MICRO\t\t0x05\n#define BMC150_ACCEL_SLEEP_1_MS\t\t0x06\n#define BMC150_ACCEL_SLEEP_2_MS\t\t0x07\n#define BMC150_ACCEL_SLEEP_4_MS\t\t0x08\n#define BMC150_ACCEL_SLEEP_6_MS\t\t0x09\n#define BMC150_ACCEL_SLEEP_10_MS\t\t0x0A\n#define BMC150_ACCEL_SLEEP_25_MS\t\t0x0B\n#define BMC150_ACCEL_SLEEP_50_MS\t\t0x0C\n#define BMC150_ACCEL_SLEEP_100_MS\t\t0x0D\n#define BMC150_ACCEL_SLEEP_500_MS\t\t0x0E\n#define BMC150_ACCEL_SLEEP_1_SEC\t\t0x0F\n\n#define BMC150_ACCEL_REG_TEMP\t\t\t0x08\n#define BMC150_ACCEL_TEMP_CENTER_VAL\t\t23\n\n#define BMC150_ACCEL_AXIS_TO_REG(axis)\t(BMC150_ACCEL_REG_XOUT_L + (axis * 2))\n#define BMC150_AUTO_SUSPEND_DELAY_MS\t\t2000\n\n#define BMC150_ACCEL_REG_FIFO_STATUS\t\t0x0E\n#define BMC150_ACCEL_REG_FIFO_CONFIG0\t\t0x30\n#define BMC150_ACCEL_REG_FIFO_CONFIG1\t\t0x3E\n#define BMC150_ACCEL_REG_FIFO_DATA\t\t0x3F\n#define BMC150_ACCEL_FIFO_LENGTH\t\t32\n\nenum bmc150_accel_axis {\n\tAXIS_X,\n\tAXIS_Y,\n\tAXIS_Z,\n\tAXIS_MAX,\n};\n\nenum bmc150_power_modes {\n\tBMC150_ACCEL_SLEEP_MODE_NORMAL,\n\tBMC150_ACCEL_SLEEP_MODE_DEEP_SUSPEND,\n\tBMC150_ACCEL_SLEEP_MODE_LPM,\n\tBMC150_ACCEL_SLEEP_MODE_SUSPEND = 0x04,\n};\n\nstruct bmc150_scale_info {\n\tint scale;\n\tu8 reg_range;\n};\n\nstruct bmc150_accel_chip_info {\n\tconst char *name;\n\tu8 chip_id;\n\tconst struct iio_chan_spec *channels;\n\tint num_channels;\n\tconst struct bmc150_scale_info scale_table[4];\n};\n\nstatic const struct {\n\tint val;\n\tint val2;\n\tu8 bw_bits;\n} bmc150_accel_samp_freq_table[] = { {15, 620000, 0x08},\n\t\t\t\t     {31, 260000, 0x09},\n\t\t\t\t     {62, 500000, 0x0A},\n\t\t\t\t     {125, 0, 0x0B},\n\t\t\t\t     {250, 0, 0x0C},\n\t\t\t\t     {500, 0, 0x0D},\n\t\t\t\t     {1000, 0, 0x0E},\n\t\t\t\t     {2000, 0, 0x0F} };\n\nstatic __maybe_unused const struct {\n\tint bw_bits;\n\tint msec;\n} bmc150_accel_sample_upd_time[] = { {0x08, 64},\n\t\t\t\t     {0x09, 32},\n\t\t\t\t     {0x0A, 16},\n\t\t\t\t     {0x0B, 8},\n\t\t\t\t     {0x0C, 4},\n\t\t\t\t     {0x0D, 2},\n\t\t\t\t     {0x0E, 1},\n\t\t\t\t     {0x0F, 1} };\n\nstatic const struct {\n\tint sleep_dur;\n\tu8 reg_value;\n} bmc150_accel_sleep_value_table[] = { {0, 0},\n\t\t\t\t       {500, BMC150_ACCEL_SLEEP_500_MICRO},\n\t\t\t\t       {1000, BMC150_ACCEL_SLEEP_1_MS},\n\t\t\t\t       {2000, BMC150_ACCEL_SLEEP_2_MS},\n\t\t\t\t       {4000, BMC150_ACCEL_SLEEP_4_MS},\n\t\t\t\t       {6000, BMC150_ACCEL_SLEEP_6_MS},\n\t\t\t\t       {10000, BMC150_ACCEL_SLEEP_10_MS},\n\t\t\t\t       {25000, BMC150_ACCEL_SLEEP_25_MS},\n\t\t\t\t       {50000, BMC150_ACCEL_SLEEP_50_MS},\n\t\t\t\t       {100000, BMC150_ACCEL_SLEEP_100_MS},\n\t\t\t\t       {500000, BMC150_ACCEL_SLEEP_500_MS},\n\t\t\t\t       {1000000, BMC150_ACCEL_SLEEP_1_SEC} };\n\nconst struct regmap_config bmc150_regmap_conf = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x3f,\n};\nEXPORT_SYMBOL_NS_GPL(bmc150_regmap_conf, IIO_BMC150);\n\nstatic int bmc150_accel_set_mode(struct bmc150_accel_data *data,\n\t\t\t\t enum bmc150_power_modes mode,\n\t\t\t\t int dur_us)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint i;\n\tint ret;\n\tu8 lpw_bits;\n\tint dur_val = -1;\n\n\tif (dur_us > 0) {\n\t\tfor (i = 0; i < ARRAY_SIZE(bmc150_accel_sleep_value_table);\n\t\t\t\t\t\t\t\t\t ++i) {\n\t\t\tif (bmc150_accel_sleep_value_table[i].sleep_dur ==\n\t\t\t\t\t\t\t\t\tdur_us)\n\t\t\t\tdur_val =\n\t\t\t\tbmc150_accel_sleep_value_table[i].reg_value;\n\t\t}\n\t} else {\n\t\tdur_val = 0;\n\t}\n\n\tif (dur_val < 0)\n\t\treturn -EINVAL;\n\n\tlpw_bits = mode << BMC150_ACCEL_PMU_MODE_SHIFT;\n\tlpw_bits |= (dur_val << BMC150_ACCEL_PMU_BIT_SLEEP_DUR_SHIFT);\n\n\tdev_dbg(dev, \"Set Mode bits %x\\n\", lpw_bits);\n\n\tret = regmap_write(data->regmap, BMC150_ACCEL_REG_PMU_LPW, lpw_bits);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error writing reg_pmu_lpw\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmc150_accel_set_bw(struct bmc150_accel_data *data, int val,\n\t\t\t       int val2)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(bmc150_accel_samp_freq_table); ++i) {\n\t\tif (bmc150_accel_samp_freq_table[i].val == val &&\n\t\t    bmc150_accel_samp_freq_table[i].val2 == val2) {\n\t\t\tret = regmap_write(data->regmap,\n\t\t\t\tBMC150_ACCEL_REG_PMU_BW,\n\t\t\t\tbmc150_accel_samp_freq_table[i].bw_bits);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tdata->bw_bits =\n\t\t\t\tbmc150_accel_samp_freq_table[i].bw_bits;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int bmc150_accel_update_slope(struct bmc150_accel_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\n\tret = regmap_write(data->regmap, BMC150_ACCEL_REG_INT_6,\n\t\t\t\t\tdata->slope_thres);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error writing reg_int_6\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(data->regmap, BMC150_ACCEL_REG_INT_5,\n\t\t\t\t BMC150_ACCEL_SLOPE_DUR_MASK, data->slope_dur);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error updating reg_int_5\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"%x %x\\n\", data->slope_thres, data->slope_dur);\n\n\treturn ret;\n}\n\nstatic int bmc150_accel_any_motion_setup(struct bmc150_accel_trigger *t,\n\t\t\t\t\t bool state)\n{\n\tif (state)\n\t\treturn bmc150_accel_update_slope(t->data);\n\n\treturn 0;\n}\n\nstatic int bmc150_accel_get_bw(struct bmc150_accel_data *data, int *val,\n\t\t\t       int *val2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bmc150_accel_samp_freq_table); ++i) {\n\t\tif (bmc150_accel_samp_freq_table[i].bw_bits == data->bw_bits) {\n\t\t\t*val = bmc150_accel_samp_freq_table[i].val;\n\t\t\t*val2 = bmc150_accel_samp_freq_table[i].val2;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_PM\nstatic int bmc150_accel_get_startup_times(struct bmc150_accel_data *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bmc150_accel_sample_upd_time); ++i) {\n\t\tif (bmc150_accel_sample_upd_time[i].bw_bits == data->bw_bits)\n\t\t\treturn bmc150_accel_sample_upd_time[i].msec;\n\t}\n\n\treturn BMC150_ACCEL_MAX_STARTUP_TIME_MS;\n}\n\nstatic int bmc150_accel_set_power_state(struct bmc150_accel_data *data, bool on)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(dev);\n\t} else {\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tret = pm_runtime_put_autosuspend(dev);\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"Failed: %s for %d\\n\", __func__, on);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#else\nstatic int bmc150_accel_set_power_state(struct bmc150_accel_data *data, bool on)\n{\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_ACPI\n \nstatic bool bmc150_apply_bosc0200_acpi_orientation(struct device *dev,\n\t\t\t\t\t\t   struct iio_mount_matrix *orientation)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tchar *name, *alt_name, *label, *str;\n\tunion acpi_object *obj, *elements;\n\tacpi_status status;\n\tint i, j, val[3];\n\n\tif (strcmp(dev_name(dev), \"i2c-BOSC0200:base\") == 0) {\n\t\talt_name = \"ROMK\";\n\t\tlabel = \"accel-base\";\n\t} else {\n\t\talt_name = \"ROMS\";\n\t\tlabel = \"accel-display\";\n\t}\n\n\tif (acpi_has_method(adev->handle, \"ROTM\")) {\n\t\tname = \"ROTM\";\n\t} else if (acpi_has_method(adev->handle, alt_name)) {\n\t\tname = alt_name;\n\t\tindio_dev->label = label;\n\t} else {\n\t\treturn false;\n\t}\n\n\tstatus = acpi_evaluate_object(adev->handle, name, NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_warn(dev, \"Failed to get ACPI mount matrix: %d\\n\", status);\n\t\treturn false;\n\t}\n\n\tobj = buffer.pointer;\n\tif (obj->type != ACPI_TYPE_PACKAGE || obj->package.count != 3)\n\t\tgoto unknown_format;\n\n\telements = obj->package.elements;\n\tfor (i = 0; i < 3; i++) {\n\t\tif (elements[i].type != ACPI_TYPE_STRING)\n\t\t\tgoto unknown_format;\n\n\t\tstr = elements[i].string.pointer;\n\t\tif (sscanf(str, \"%d %d %d\", &val[0], &val[1], &val[2]) != 3)\n\t\t\tgoto unknown_format;\n\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tswitch (val[j]) {\n\t\t\tcase -1: str = \"-1\"; break;\n\t\t\tcase 0:  str = \"0\";  break;\n\t\t\tcase 1:  str = \"1\";  break;\n\t\t\tdefault: goto unknown_format;\n\t\t\t}\n\t\t\torientation->rotation[i * 3 + j] = str;\n\t\t}\n\t}\n\n\tkfree(buffer.pointer);\n\treturn true;\n\nunknown_format:\n\tdev_warn(dev, \"Unknown ACPI mount matrix format, ignoring\\n\");\n\tkfree(buffer.pointer);\n\treturn false;\n}\n\nstatic bool bmc150_apply_dual250e_acpi_orientation(struct device *dev,\n\t\t\t\t\t\t   struct iio_mount_matrix *orientation)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\n\tif (strcmp(dev_name(dev), \"i2c-DUAL250E:base\") == 0)\n\t\tindio_dev->label = \"accel-base\";\n\telse\n\t\tindio_dev->label = \"accel-display\";\n\n\treturn false;  \n}\n\nstatic bool bmc150_apply_acpi_orientation(struct device *dev,\n\t\t\t\t\t  struct iio_mount_matrix *orientation)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\n\tif (adev && acpi_dev_hid_uid_match(adev, \"BOSC0200\", NULL))\n\t\treturn bmc150_apply_bosc0200_acpi_orientation(dev, orientation);\n\n\tif (adev && acpi_dev_hid_uid_match(adev, \"DUAL250E\", NULL))\n\t\treturn bmc150_apply_dual250e_acpi_orientation(dev, orientation);\n\n\treturn false;\n}\n#else\nstatic bool bmc150_apply_acpi_orientation(struct device *dev,\n\t\t\t\t\t  struct iio_mount_matrix *orientation)\n{\n\treturn false;\n}\n#endif\n\nstruct bmc150_accel_interrupt_info {\n\tu8 map_reg;\n\tu8 map_bitmask;\n\tu8 en_reg;\n\tu8 en_bitmask;\n};\n\nstatic const struct bmc150_accel_interrupt_info\nbmc150_accel_interrupts_int1[BMC150_ACCEL_INTERRUPTS] = {\n\t{  \n\t\t.map_reg = BMC150_ACCEL_REG_INT_MAP_1,\n\t\t.map_bitmask = BMC150_ACCEL_INT_MAP_1_BIT_INT1_DATA,\n\t\t.en_reg = BMC150_ACCEL_REG_INT_EN_1,\n\t\t.en_bitmask = BMC150_ACCEL_INT_EN_BIT_DATA_EN,\n\t},\n\t{   \n\t\t.map_reg = BMC150_ACCEL_REG_INT_MAP_0,\n\t\t.map_bitmask = BMC150_ACCEL_INT_MAP_0_BIT_INT1_SLOPE,\n\t\t.en_reg = BMC150_ACCEL_REG_INT_EN_0,\n\t\t.en_bitmask =  BMC150_ACCEL_INT_EN_BIT_SLP_X |\n\t\t\tBMC150_ACCEL_INT_EN_BIT_SLP_Y |\n\t\t\tBMC150_ACCEL_INT_EN_BIT_SLP_Z\n\t},\n\t{  \n\t\t.map_reg = BMC150_ACCEL_REG_INT_MAP_1,\n\t\t.map_bitmask = BMC150_ACCEL_INT_MAP_1_BIT_INT1_FWM,\n\t\t.en_reg = BMC150_ACCEL_REG_INT_EN_1,\n\t\t.en_bitmask = BMC150_ACCEL_INT_EN_BIT_FWM_EN,\n\t},\n};\n\nstatic const struct bmc150_accel_interrupt_info\nbmc150_accel_interrupts_int2[BMC150_ACCEL_INTERRUPTS] = {\n\t{  \n\t\t.map_reg = BMC150_ACCEL_REG_INT_MAP_1,\n\t\t.map_bitmask = BMC150_ACCEL_INT_MAP_1_BIT_INT2_DATA,\n\t\t.en_reg = BMC150_ACCEL_REG_INT_EN_1,\n\t\t.en_bitmask = BMC150_ACCEL_INT_EN_BIT_DATA_EN,\n\t},\n\t{   \n\t\t.map_reg = BMC150_ACCEL_REG_INT_MAP_2,\n\t\t.map_bitmask = BMC150_ACCEL_INT_MAP_2_BIT_INT2_SLOPE,\n\t\t.en_reg = BMC150_ACCEL_REG_INT_EN_0,\n\t\t.en_bitmask =  BMC150_ACCEL_INT_EN_BIT_SLP_X |\n\t\t\tBMC150_ACCEL_INT_EN_BIT_SLP_Y |\n\t\t\tBMC150_ACCEL_INT_EN_BIT_SLP_Z\n\t},\n\t{  \n\t\t.map_reg = BMC150_ACCEL_REG_INT_MAP_1,\n\t\t.map_bitmask = BMC150_ACCEL_INT_MAP_1_BIT_INT2_FWM,\n\t\t.en_reg = BMC150_ACCEL_REG_INT_EN_1,\n\t\t.en_bitmask = BMC150_ACCEL_INT_EN_BIT_FWM_EN,\n\t},\n};\n\nstatic void bmc150_accel_interrupts_setup(struct iio_dev *indio_dev,\n\t\t\t\t\t  struct bmc150_accel_data *data, int irq)\n{\n\tconst struct bmc150_accel_interrupt_info *irq_info = NULL;\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint i;\n\n\t \n\tirq_info = bmc150_accel_interrupts_int1;\n\tif (data->type == BOSCH_BMC156 ||\n\t    irq == of_irq_get_byname(dev->of_node, \"INT2\"))\n\t\tirq_info = bmc150_accel_interrupts_int2;\n\n\tfor (i = 0; i < BMC150_ACCEL_INTERRUPTS; i++)\n\t\tdata->interrupts[i].info = &irq_info[i];\n}\n\nstatic int bmc150_accel_set_interrupt(struct bmc150_accel_data *data, int i,\n\t\t\t\t      bool state)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tstruct bmc150_accel_interrupt *intr = &data->interrupts[i];\n\tconst struct bmc150_accel_interrupt_info *info = intr->info;\n\tint ret;\n\n\tif (state) {\n\t\tif (atomic_inc_return(&intr->users) > 1)\n\t\t\treturn 0;\n\t} else {\n\t\tif (atomic_dec_return(&intr->users) > 0)\n\t\t\treturn 0;\n\t}\n\n\t \n\tret = bmc150_accel_set_power_state(data, state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, info->map_reg, info->map_bitmask,\n\t\t\t\t (state ? info->map_bitmask : 0));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error updating reg_int_map\\n\");\n\t\tgoto out_fix_power_state;\n\t}\n\n\t \n\tret = regmap_update_bits(data->regmap, info->en_reg, info->en_bitmask,\n\t\t\t\t (state ? info->en_bitmask : 0));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error updating reg_int_en\\n\");\n\t\tgoto out_fix_power_state;\n\t}\n\n\treturn 0;\n\nout_fix_power_state:\n\tbmc150_accel_set_power_state(data, false);\n\treturn ret;\n}\n\nstatic int bmc150_accel_set_scale(struct bmc150_accel_data *data, int val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(data->chip_info->scale_table); ++i) {\n\t\tif (data->chip_info->scale_table[i].scale == val) {\n\t\t\tret = regmap_write(data->regmap,\n\t\t\t\t     BMC150_ACCEL_REG_PMU_RANGE,\n\t\t\t\t     data->chip_info->scale_table[i].reg_range);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"Error writing pmu_range\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tdata->range = data->chip_info->scale_table[i].reg_range;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int bmc150_accel_get_temp(struct bmc150_accel_data *data, int *val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\tunsigned int value;\n\n\tmutex_lock(&data->mutex);\n\n\tret = regmap_read(data->regmap, BMC150_ACCEL_REG_TEMP, &value);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading reg_temp\\n\");\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\t*val = sign_extend32(value, 7);\n\n\tmutex_unlock(&data->mutex);\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int bmc150_accel_get_axis(struct bmc150_accel_data *data,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int *val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\tint axis = chan->scan_index;\n\t__le16 raw_val;\n\n\tmutex_lock(&data->mutex);\n\tret = bmc150_accel_set_power_state(data, true);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\n\tret = regmap_bulk_read(data->regmap, BMC150_ACCEL_AXIS_TO_REG(axis),\n\t\t\t       &raw_val, sizeof(raw_val));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading axis %d\\n\", axis);\n\t\tbmc150_accel_set_power_state(data, false);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\t*val = sign_extend32(le16_to_cpu(raw_val) >> chan->scan_type.shift,\n\t\t\t     chan->scan_type.realbits - 1);\n\tret = bmc150_accel_set_power_state(data, false);\n\tmutex_unlock(&data->mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int bmc150_accel_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int *val, int *val2, long mask)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\treturn bmc150_accel_get_temp(data, val);\n\t\tcase IIO_ACCEL:\n\t\t\tif (iio_buffer_enabled(indio_dev))\n\t\t\t\treturn -EBUSY;\n\t\t\telse\n\t\t\t\treturn bmc150_accel_get_axis(data, chan, val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (chan->type == IIO_TEMP) {\n\t\t\t*val = BMC150_ACCEL_TEMP_CENTER_VAL;\n\t\t\treturn IIO_VAL_INT;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t*val2 = 500000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_ACCEL:\n\t\t{\n\t\t\tint i;\n\t\t\tconst struct bmc150_scale_info *si;\n\t\t\tint st_size = ARRAY_SIZE(data->chip_info->scale_table);\n\n\t\t\tfor (i = 0; i < st_size; ++i) {\n\t\t\t\tsi = &data->chip_info->scale_table[i];\n\t\t\t\tif (si->reg_range == data->range) {\n\t\t\t\t\t*val2 = si->scale;\n\t\t\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tmutex_lock(&data->mutex);\n\t\tret = bmc150_accel_get_bw(data, val, val2);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bmc150_accel_write_raw(struct iio_dev *indio_dev,\n\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t  int val, int val2, long mask)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tmutex_lock(&data->mutex);\n\t\tret = bmc150_accel_set_bw(data, val, val2);\n\t\tmutex_unlock(&data->mutex);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (val)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&data->mutex);\n\t\tret = bmc150_accel_set_scale(data, val2);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int bmc150_accel_read_event(struct iio_dev *indio_dev,\n\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t   enum iio_event_type type,\n\t\t\t\t   enum iio_event_direction dir,\n\t\t\t\t   enum iio_event_info info,\n\t\t\t\t   int *val, int *val2)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\n\t*val2 = 0;\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\t*val = data->slope_thres;\n\t\tbreak;\n\tcase IIO_EV_INFO_PERIOD:\n\t\t*val = data->slope_dur;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int bmc150_accel_write_event(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir,\n\t\t\t\t    enum iio_event_info info,\n\t\t\t\t    int val, int val2)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\n\tif (data->ev_enable_state)\n\t\treturn -EBUSY;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tdata->slope_thres = val & BMC150_ACCEL_SLOPE_THRES_MASK;\n\t\tbreak;\n\tcase IIO_EV_INFO_PERIOD:\n\t\tdata->slope_dur = val & BMC150_ACCEL_SLOPE_DUR_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmc150_accel_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t\t  enum iio_event_type type,\n\t\t\t\t\t  enum iio_event_direction dir)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\n\treturn data->ev_enable_state;\n}\n\nstatic int bmc150_accel_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t\t   enum iio_event_type type,\n\t\t\t\t\t   enum iio_event_direction dir,\n\t\t\t\t\t   int state)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (state == data->ev_enable_state)\n\t\treturn 0;\n\n\tmutex_lock(&data->mutex);\n\n\tret = bmc150_accel_set_interrupt(data, BMC150_ACCEL_INT_ANY_MOTION,\n\t\t\t\t\t state);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\n\tdata->ev_enable_state = state;\n\tmutex_unlock(&data->mutex);\n\n\treturn 0;\n}\n\nstatic int bmc150_accel_validate_trigger(struct iio_dev *indio_dev,\n\t\t\t\t\t struct iio_trigger *trig)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tint i;\n\n\tfor (i = 0; i < BMC150_ACCEL_TRIGGERS; i++) {\n\t\tif (data->triggers[i].indio_trig == trig)\n\t\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t bmc150_accel_get_fifo_watermark(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tint wm;\n\n\tmutex_lock(&data->mutex);\n\twm = data->watermark;\n\tmutex_unlock(&data->mutex);\n\n\treturn sprintf(buf, \"%d\\n\", wm);\n}\n\nstatic ssize_t bmc150_accel_get_fifo_state(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tbool state;\n\n\tmutex_lock(&data->mutex);\n\tstate = data->fifo_mode;\n\tmutex_unlock(&data->mutex);\n\n\treturn sprintf(buf, \"%d\\n\", state);\n}\n\nstatic const struct iio_mount_matrix *\nbmc150_accel_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\t\tconst struct iio_chan_spec *chan)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\n\treturn &data->orientation;\n}\n\nstatic const struct iio_chan_spec_ext_info bmc150_accel_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_DIR, bmc150_accel_get_mount_matrix),\n\t{ }\n};\n\nIIO_STATIC_CONST_DEVICE_ATTR(hwfifo_watermark_min, \"1\");\nIIO_STATIC_CONST_DEVICE_ATTR(hwfifo_watermark_max,\n\t\t\t     __stringify(BMC150_ACCEL_FIFO_LENGTH));\nstatic IIO_DEVICE_ATTR(hwfifo_enabled, S_IRUGO,\n\t\t       bmc150_accel_get_fifo_state, NULL, 0);\nstatic IIO_DEVICE_ATTR(hwfifo_watermark, S_IRUGO,\n\t\t       bmc150_accel_get_fifo_watermark, NULL, 0);\n\nstatic const struct iio_dev_attr *bmc150_accel_fifo_attributes[] = {\n\t&iio_dev_attr_hwfifo_watermark_min,\n\t&iio_dev_attr_hwfifo_watermark_max,\n\t&iio_dev_attr_hwfifo_watermark,\n\t&iio_dev_attr_hwfifo_enabled,\n\tNULL,\n};\n\nstatic int bmc150_accel_set_watermark(struct iio_dev *indio_dev, unsigned val)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\n\tif (val > BMC150_ACCEL_FIFO_LENGTH)\n\t\tval = BMC150_ACCEL_FIFO_LENGTH;\n\n\tmutex_lock(&data->mutex);\n\tdata->watermark = val;\n\tmutex_unlock(&data->mutex);\n\n\treturn 0;\n}\n\n \nstatic int bmc150_accel_fifo_transfer(struct bmc150_accel_data *data,\n\t\t\t\t      char *buffer, int samples)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint sample_length = 3 * 2;\n\tint ret;\n\tint total_length = samples * sample_length;\n\n\tret = regmap_raw_read(data->regmap, BMC150_ACCEL_REG_FIFO_DATA,\n\t\t\t      buffer, total_length);\n\tif (ret)\n\t\tdev_err(dev,\n\t\t\t\"Error transferring data from fifo: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int __bmc150_accel_fifo_flush(struct iio_dev *indio_dev,\n\t\t\t\t     unsigned samples, bool irq)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret, i;\n\tu8 count;\n\tu16 buffer[BMC150_ACCEL_FIFO_LENGTH * 3];\n\tint64_t tstamp;\n\tuint64_t sample_period;\n\tunsigned int val;\n\n\tret = regmap_read(data->regmap, BMC150_ACCEL_REG_FIFO_STATUS, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading reg_fifo_status\\n\");\n\t\treturn ret;\n\t}\n\n\tcount = val & 0x7F;\n\n\tif (!count)\n\t\treturn 0;\n\n\t \n\tif (!irq) {\n\t\tdata->old_timestamp = data->timestamp;\n\t\tdata->timestamp = iio_get_time_ns(indio_dev);\n\t}\n\n\t \n\tsample_period = (data->timestamp - data->old_timestamp);\n\tdo_div(sample_period, count);\n\ttstamp = data->timestamp - (count - 1) * sample_period;\n\n\tif (samples && count > samples)\n\t\tcount = samples;\n\n\tret = bmc150_accel_fifo_transfer(data, (u8 *)buffer, count);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tint j, bit;\n\n\t\tj = 0;\n\t\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t\t indio_dev->masklength)\n\t\t\tmemcpy(&data->scan.channels[j++], &buffer[i * 3 + bit],\n\t\t\t       sizeof(data->scan.channels[0]));\n\n\t\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t\t   tstamp);\n\n\t\ttstamp += sample_period;\n\t}\n\n\treturn count;\n}\n\nstatic int bmc150_accel_fifo_flush(struct iio_dev *indio_dev, unsigned samples)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = __bmc150_accel_fifo_flush(indio_dev, samples, false);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\n\t\t\"15.620000 31.260000 62.50000 125 250 500 1000 2000\");\n\nstatic struct attribute *bmc150_accel_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group bmc150_accel_attrs_group = {\n\t.attrs = bmc150_accel_attributes,\n};\n\nstatic const struct iio_event_spec bmc150_accel_event = {\n\t\t.type = IIO_EV_TYPE_ROC,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t\t BIT(IIO_EV_INFO_PERIOD)\n};\n\n#define BMC150_ACCEL_CHANNEL(_axis, bits) {\t\t\t\t\\\n\t.type = IIO_ACCEL,\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##_axis,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\t\\\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\\\n\t.scan_index = AXIS_##_axis,\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\t\\\n\t\t.realbits = (bits),\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\t\\\n\t\t.shift = 16 - (bits),\t\t\t\t\t\\\n\t\t.endianness = IIO_LE,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.ext_info = bmc150_accel_ext_info,\t\t\t\t\\\n\t.event_spec = &bmc150_accel_event,\t\t\t\t\\\n\t.num_event_specs = 1\t\t\t\t\t\t\\\n}\n\n#define BMC150_ACCEL_CHANNELS(bits) {\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_TEMP,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\t\\\n\t\t.scan_index = -1,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\tBMC150_ACCEL_CHANNEL(X, bits),\t\t\t\t\t\\\n\tBMC150_ACCEL_CHANNEL(Y, bits),\t\t\t\t\t\\\n\tBMC150_ACCEL_CHANNEL(Z, bits),\t\t\t\t\t\\\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec bma222e_accel_channels[] =\n\tBMC150_ACCEL_CHANNELS(8);\nstatic const struct iio_chan_spec bma250e_accel_channels[] =\n\tBMC150_ACCEL_CHANNELS(10);\nstatic const struct iio_chan_spec bmc150_accel_channels[] =\n\tBMC150_ACCEL_CHANNELS(12);\nstatic const struct iio_chan_spec bma280_accel_channels[] =\n\tBMC150_ACCEL_CHANNELS(14);\n\n \nstatic const struct bmc150_accel_chip_info bmc150_accel_chip_info_tbl[] = {\n\t{\n\t\t.name = \"BMA222\",\n\t\t.chip_id = 0x03,\n\t\t.channels = bma222e_accel_channels,\n\t\t.num_channels = ARRAY_SIZE(bma222e_accel_channels),\n\t\t.scale_table = { {153229, BMC150_ACCEL_DEF_RANGE_2G},\n\t\t\t\t {306458, BMC150_ACCEL_DEF_RANGE_4G},\n\t\t\t\t {612916, BMC150_ACCEL_DEF_RANGE_8G},\n\t\t\t\t {1225831, BMC150_ACCEL_DEF_RANGE_16G} },\n\t},\n\t{\n\t\t.name = \"BMA222E\",\n\t\t.chip_id = 0xF8,\n\t\t.channels = bma222e_accel_channels,\n\t\t.num_channels = ARRAY_SIZE(bma222e_accel_channels),\n\t\t.scale_table = { {153229, BMC150_ACCEL_DEF_RANGE_2G},\n\t\t\t\t {306458, BMC150_ACCEL_DEF_RANGE_4G},\n\t\t\t\t {612916, BMC150_ACCEL_DEF_RANGE_8G},\n\t\t\t\t {1225831, BMC150_ACCEL_DEF_RANGE_16G} },\n\t},\n\t{\n\t\t.name = \"BMA250E\",\n\t\t.chip_id = 0xF9,\n\t\t.channels = bma250e_accel_channels,\n\t\t.num_channels = ARRAY_SIZE(bma250e_accel_channels),\n\t\t.scale_table = { {38307, BMC150_ACCEL_DEF_RANGE_2G},\n\t\t\t\t {76614, BMC150_ACCEL_DEF_RANGE_4G},\n\t\t\t\t {153229, BMC150_ACCEL_DEF_RANGE_8G},\n\t\t\t\t {306458, BMC150_ACCEL_DEF_RANGE_16G} },\n\t},\n\t{\n\t\t.name = \"BMA253/BMA254/BMA255/BMC150/BMC156/BMI055\",\n\t\t.chip_id = 0xFA,\n\t\t.channels = bmc150_accel_channels,\n\t\t.num_channels = ARRAY_SIZE(bmc150_accel_channels),\n\t\t.scale_table = { {9577, BMC150_ACCEL_DEF_RANGE_2G},\n\t\t\t\t {19154, BMC150_ACCEL_DEF_RANGE_4G},\n\t\t\t\t {38307, BMC150_ACCEL_DEF_RANGE_8G},\n\t\t\t\t {76614, BMC150_ACCEL_DEF_RANGE_16G} },\n\t},\n\t{\n\t\t.name = \"BMA280\",\n\t\t.chip_id = 0xFB,\n\t\t.channels = bma280_accel_channels,\n\t\t.num_channels = ARRAY_SIZE(bma280_accel_channels),\n\t\t.scale_table = { {2394, BMC150_ACCEL_DEF_RANGE_2G},\n\t\t\t\t {4788, BMC150_ACCEL_DEF_RANGE_4G},\n\t\t\t\t {9577, BMC150_ACCEL_DEF_RANGE_8G},\n\t\t\t\t {19154, BMC150_ACCEL_DEF_RANGE_16G} },\n\t},\n};\n\nstatic const struct iio_info bmc150_accel_info = {\n\t.attrs\t\t\t= &bmc150_accel_attrs_group,\n\t.read_raw\t\t= bmc150_accel_read_raw,\n\t.write_raw\t\t= bmc150_accel_write_raw,\n\t.read_event_value\t= bmc150_accel_read_event,\n\t.write_event_value\t= bmc150_accel_write_event,\n\t.write_event_config\t= bmc150_accel_write_event_config,\n\t.read_event_config\t= bmc150_accel_read_event_config,\n};\n\nstatic const struct iio_info bmc150_accel_info_fifo = {\n\t.attrs\t\t\t= &bmc150_accel_attrs_group,\n\t.read_raw\t\t= bmc150_accel_read_raw,\n\t.write_raw\t\t= bmc150_accel_write_raw,\n\t.read_event_value\t= bmc150_accel_read_event,\n\t.write_event_value\t= bmc150_accel_write_event,\n\t.write_event_config\t= bmc150_accel_write_event_config,\n\t.read_event_config\t= bmc150_accel_read_event_config,\n\t.validate_trigger\t= bmc150_accel_validate_trigger,\n\t.hwfifo_set_watermark\t= bmc150_accel_set_watermark,\n\t.hwfifo_flush_to_buffer\t= bmc150_accel_fifo_flush,\n};\n\nstatic const unsigned long bmc150_accel_scan_masks[] = {\n\t\t\t\t\tBIT(AXIS_X) | BIT(AXIS_Y) | BIT(AXIS_Z),\n\t\t\t\t\t0};\n\nstatic irqreturn_t bmc150_accel_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = regmap_bulk_read(data->regmap, BMC150_ACCEL_REG_XOUT_L,\n\t\t\t       data->buffer, AXIS_MAX * 2);\n\tmutex_unlock(&data->mutex);\n\tif (ret < 0)\n\t\tgoto err_read;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, data->buffer,\n\t\t\t\t\t   pf->timestamp);\nerr_read:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void bmc150_accel_trig_reen(struct iio_trigger *trig)\n{\n\tstruct bmc150_accel_trigger *t = iio_trigger_get_drvdata(trig);\n\tstruct bmc150_accel_data *data = t->data;\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\n\t \n\tif (t == &t->data->triggers[BMC150_ACCEL_TRIGGER_DATA_READY])\n\t\treturn;\n\n\tmutex_lock(&data->mutex);\n\t \n\tret = regmap_write(data->regmap, BMC150_ACCEL_REG_INT_RST_LATCH,\n\t\t\t   BMC150_ACCEL_INT_MODE_LATCH_INT |\n\t\t\t   BMC150_ACCEL_INT_MODE_LATCH_RESET);\n\tmutex_unlock(&data->mutex);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Error writing reg_int_rst_latch\\n\");\n}\n\nstatic int bmc150_accel_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t  bool state)\n{\n\tstruct bmc150_accel_trigger *t = iio_trigger_get_drvdata(trig);\n\tstruct bmc150_accel_data *data = t->data;\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\n\tif (t->enabled == state) {\n\t\tmutex_unlock(&data->mutex);\n\t\treturn 0;\n\t}\n\n\tif (t->setup) {\n\t\tret = t->setup(t, state);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = bmc150_accel_set_interrupt(data, t->intr, state);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\n\tt->enabled = state;\n\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic const struct iio_trigger_ops bmc150_accel_trigger_ops = {\n\t.set_trigger_state = bmc150_accel_trigger_set_state,\n\t.reenable = bmc150_accel_trig_reen,\n};\n\nstatic int bmc150_accel_handle_roc_event(struct iio_dev *indio_dev)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint dir;\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(data->regmap, BMC150_ACCEL_REG_INT_STATUS_2, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading reg_int_status_2\\n\");\n\t\treturn ret;\n\t}\n\n\tif (val & BMC150_ACCEL_ANY_MOTION_BIT_SIGN)\n\t\tdir = IIO_EV_DIR_FALLING;\n\telse\n\t\tdir = IIO_EV_DIR_RISING;\n\n\tif (val & BMC150_ACCEL_ANY_MOTION_BIT_X)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  IIO_MOD_X,\n\t\t\t\t\t\t  IIO_EV_TYPE_ROC,\n\t\t\t\t\t\t  dir),\n\t\t\t       data->timestamp);\n\n\tif (val & BMC150_ACCEL_ANY_MOTION_BIT_Y)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  IIO_MOD_Y,\n\t\t\t\t\t\t  IIO_EV_TYPE_ROC,\n\t\t\t\t\t\t  dir),\n\t\t\t       data->timestamp);\n\n\tif (val & BMC150_ACCEL_ANY_MOTION_BIT_Z)\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_MOD_EVENT_CODE(IIO_ACCEL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  IIO_MOD_Z,\n\t\t\t\t\t\t  IIO_EV_TYPE_ROC,\n\t\t\t\t\t\t  dir),\n\t\t\t       data->timestamp);\n\n\treturn ret;\n}\n\nstatic irqreturn_t bmc150_accel_irq_thread_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tbool ack = false;\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\n\tif (data->fifo_mode) {\n\t\tret = __bmc150_accel_fifo_flush(indio_dev,\n\t\t\t\t\t\tBMC150_ACCEL_FIFO_LENGTH, true);\n\t\tif (ret > 0)\n\t\t\tack = true;\n\t}\n\n\tif (data->ev_enable_state) {\n\t\tret = bmc150_accel_handle_roc_event(indio_dev);\n\t\tif (ret > 0)\n\t\t\tack = true;\n\t}\n\n\tif (ack) {\n\t\tret = regmap_write(data->regmap, BMC150_ACCEL_REG_INT_RST_LATCH,\n\t\t\t\t   BMC150_ACCEL_INT_MODE_LATCH_INT |\n\t\t\t\t   BMC150_ACCEL_INT_MODE_LATCH_RESET);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Error writing reg_int_rst_latch\\n\");\n\n\t\tret = IRQ_HANDLED;\n\t} else {\n\t\tret = IRQ_NONE;\n\t}\n\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic irqreturn_t bmc150_accel_irq_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tbool ack = false;\n\tint i;\n\n\tdata->old_timestamp = data->timestamp;\n\tdata->timestamp = iio_get_time_ns(indio_dev);\n\n\tfor (i = 0; i < BMC150_ACCEL_TRIGGERS; i++) {\n\t\tif (data->triggers[i].enabled) {\n\t\t\tiio_trigger_poll(data->triggers[i].indio_trig);\n\t\t\tack = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (data->ev_enable_state || data->fifo_mode)\n\t\treturn IRQ_WAKE_THREAD;\n\n\tif (ack)\n\t\treturn IRQ_HANDLED;\n\n\treturn IRQ_NONE;\n}\n\nstatic const struct {\n\tint intr;\n\tconst char *name;\n\tint (*setup)(struct bmc150_accel_trigger *t, bool state);\n} bmc150_accel_triggers[BMC150_ACCEL_TRIGGERS] = {\n\t{\n\t\t.intr = 0,\n\t\t.name = \"%s-dev%d\",\n\t},\n\t{\n\t\t.intr = 1,\n\t\t.name = \"%s-any-motion-dev%d\",\n\t\t.setup = bmc150_accel_any_motion_setup,\n\t},\n};\n\nstatic void bmc150_accel_unregister_triggers(struct bmc150_accel_data *data,\n\t\t\t\t\t     int from)\n{\n\tint i;\n\n\tfor (i = from; i >= 0; i--) {\n\t\tif (data->triggers[i].indio_trig) {\n\t\t\tiio_trigger_unregister(data->triggers[i].indio_trig);\n\t\t\tdata->triggers[i].indio_trig = NULL;\n\t\t}\n\t}\n}\n\nstatic int bmc150_accel_triggers_setup(struct iio_dev *indio_dev,\n\t\t\t\t       struct bmc150_accel_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint i, ret;\n\n\tfor (i = 0; i < BMC150_ACCEL_TRIGGERS; i++) {\n\t\tstruct bmc150_accel_trigger *t = &data->triggers[i];\n\n\t\tt->indio_trig = devm_iio_trigger_alloc(dev,\n\t\t\t\t\t\t       bmc150_accel_triggers[i].name,\n\t\t\t\t\t\t       indio_dev->name,\n\t\t\t\t\t\t       iio_device_id(indio_dev));\n\t\tif (!t->indio_trig) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tt->indio_trig->ops = &bmc150_accel_trigger_ops;\n\t\tt->intr = bmc150_accel_triggers[i].intr;\n\t\tt->data = data;\n\t\tt->setup = bmc150_accel_triggers[i].setup;\n\t\tiio_trigger_set_drvdata(t->indio_trig, t);\n\n\t\tret = iio_trigger_register(t->indio_trig);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tbmc150_accel_unregister_triggers(data, i - 1);\n\n\treturn ret;\n}\n\n#define BMC150_ACCEL_FIFO_MODE_STREAM          0x80\n#define BMC150_ACCEL_FIFO_MODE_FIFO            0x40\n#define BMC150_ACCEL_FIFO_MODE_BYPASS          0x00\n\nstatic int bmc150_accel_fifo_set_mode(struct bmc150_accel_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tu8 reg = BMC150_ACCEL_REG_FIFO_CONFIG1;\n\tint ret;\n\n\tret = regmap_write(data->regmap, reg, data->fifo_mode);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error writing reg_fifo_config1\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!data->fifo_mode)\n\t\treturn 0;\n\n\tret = regmap_write(data->regmap, BMC150_ACCEL_REG_FIFO_CONFIG0,\n\t\t\t   data->watermark);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Error writing reg_fifo_config0\\n\");\n\n\treturn ret;\n}\n\nstatic int bmc150_accel_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\n\treturn bmc150_accel_set_power_state(data, true);\n}\n\nstatic int bmc150_accel_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tint ret = 0;\n\n\tif (iio_device_get_current_mode(indio_dev) == INDIO_BUFFER_TRIGGERED)\n\t\treturn 0;\n\n\tmutex_lock(&data->mutex);\n\n\tif (!data->watermark)\n\t\tgoto out;\n\n\tret = bmc150_accel_set_interrupt(data, BMC150_ACCEL_INT_WATERMARK,\n\t\t\t\t\t true);\n\tif (ret)\n\t\tgoto out;\n\n\tdata->fifo_mode = BMC150_ACCEL_FIFO_MODE_FIFO;\n\n\tret = bmc150_accel_fifo_set_mode(data);\n\tif (ret) {\n\t\tdata->fifo_mode = 0;\n\t\tbmc150_accel_set_interrupt(data, BMC150_ACCEL_INT_WATERMARK,\n\t\t\t\t\t   false);\n\t}\n\nout:\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int bmc150_accel_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\n\tif (iio_device_get_current_mode(indio_dev) == INDIO_BUFFER_TRIGGERED)\n\t\treturn 0;\n\n\tmutex_lock(&data->mutex);\n\n\tif (!data->fifo_mode)\n\t\tgoto out;\n\n\tbmc150_accel_set_interrupt(data, BMC150_ACCEL_INT_WATERMARK, false);\n\t__bmc150_accel_fifo_flush(indio_dev, BMC150_ACCEL_FIFO_LENGTH, false);\n\tdata->fifo_mode = 0;\n\tbmc150_accel_fifo_set_mode(data);\n\nout:\n\tmutex_unlock(&data->mutex);\n\n\treturn 0;\n}\n\nstatic int bmc150_accel_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\n\treturn bmc150_accel_set_power_state(data, false);\n}\n\nstatic const struct iio_buffer_setup_ops bmc150_accel_buffer_ops = {\n\t.preenable = bmc150_accel_buffer_preenable,\n\t.postenable = bmc150_accel_buffer_postenable,\n\t.predisable = bmc150_accel_buffer_predisable,\n\t.postdisable = bmc150_accel_buffer_postdisable,\n};\n\nstatic int bmc150_accel_chip_init(struct bmc150_accel_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret, i;\n\tunsigned int val;\n\n\t \n\tregmap_write(data->regmap, BMC150_ACCEL_REG_RESET,\n\t\t     BMC150_ACCEL_RESET_VAL);\n\tusleep_range(1800, 2500);\n\n\tret = regmap_read(data->regmap, BMC150_ACCEL_REG_CHIP_ID, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error: Reading chip id\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"Chip Id %x\\n\", val);\n\tfor (i = 0; i < ARRAY_SIZE(bmc150_accel_chip_info_tbl); i++) {\n\t\tif (bmc150_accel_chip_info_tbl[i].chip_id == val) {\n\t\t\tdata->chip_info = &bmc150_accel_chip_info_tbl[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!data->chip_info) {\n\t\tdev_err(dev, \"Invalid chip %x\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tret = bmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_NORMAL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = bmc150_accel_set_bw(data, BMC150_ACCEL_DEF_BW, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, BMC150_ACCEL_REG_PMU_RANGE,\n\t\t\t   BMC150_ACCEL_DEF_RANGE_4G);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error writing reg_pmu_range\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->range = BMC150_ACCEL_DEF_RANGE_4G;\n\n\t \n\tdata->slope_thres = BMC150_ACCEL_DEF_SLOPE_THRESHOLD;\n\tdata->slope_dur = BMC150_ACCEL_DEF_SLOPE_DURATION;\n\tret = bmc150_accel_update_slope(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, BMC150_ACCEL_REG_INT_RST_LATCH,\n\t\t\t   BMC150_ACCEL_INT_MODE_LATCH_INT |\n\t\t\t   BMC150_ACCEL_INT_MODE_LATCH_RESET);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error writing reg_int_rst_latch\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint bmc150_accel_core_probe(struct device *dev, struct regmap *regmap, int irq,\n\t\t\t    enum bmc150_type type, const char *name,\n\t\t\t    bool block_supported)\n{\n\tconst struct iio_dev_attr **fifo_attrs;\n\tstruct bmc150_accel_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdev_set_drvdata(dev, indio_dev);\n\n\tdata->regmap = regmap;\n\tdata->type = type;\n\n\tif (!bmc150_apply_acpi_orientation(dev, &data->orientation)) {\n\t\tret = iio_read_mount_matrix(dev, &data->orientation);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tdata->regulators[0].supply = \"vdd\";\n\tdata->regulators[1].supply = \"vddio\";\n\tret = devm_regulator_bulk_get(dev,\n\t\t\t\t      ARRAY_SIZE(data->regulators),\n\t\t\t\t      data->regulators);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to get regulators\\n\");\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(data->regulators),\n\t\t\t\t    data->regulators);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t \n\tmsleep(5);\n\n\tret = bmc150_accel_chip_init(data);\n\tif (ret < 0)\n\t\tgoto err_disable_regulators;\n\n\tmutex_init(&data->mutex);\n\n\tindio_dev->channels = data->chip_info->channels;\n\tindio_dev->num_channels = data->chip_info->num_channels;\n\tindio_dev->name = name ? name : data->chip_info->name;\n\tindio_dev->available_scan_masks = bmc150_accel_scan_masks;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &bmc150_accel_info;\n\n\tif (block_supported) {\n\t\tindio_dev->modes |= INDIO_BUFFER_SOFTWARE;\n\t\tindio_dev->info = &bmc150_accel_info_fifo;\n\t\tfifo_attrs = bmc150_accel_fifo_attributes;\n\t} else {\n\t\tfifo_attrs = NULL;\n\t}\n\n\tret = iio_triggered_buffer_setup_ext(indio_dev,\n\t\t\t\t\t     &iio_pollfunc_store_time,\n\t\t\t\t\t     bmc150_accel_trigger_handler,\n\t\t\t\t\t     IIO_BUFFER_DIRECTION_IN,\n\t\t\t\t\t     &bmc150_accel_buffer_ops,\n\t\t\t\t\t     fifo_attrs);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed: iio triggered buffer setup\\n\");\n\t\tgoto err_disable_regulators;\n\t}\n\n\tif (irq > 0) {\n\t\tret = devm_request_threaded_irq(dev, irq,\n\t\t\t\t\t\tbmc150_accel_irq_handler,\n\t\t\t\t\t\tbmc150_accel_irq_thread_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING,\n\t\t\t\t\t\tBMC150_ACCEL_IRQ_NAME,\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret)\n\t\t\tgoto err_buffer_cleanup;\n\n\t\t \n\t\tret = regmap_write(data->regmap, BMC150_ACCEL_REG_INT_RST_LATCH,\n\t\t\t\t   BMC150_ACCEL_INT_MODE_LATCH_RESET);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Error writing reg_int_rst_latch\\n\");\n\t\t\tgoto err_buffer_cleanup;\n\t\t}\n\n\t\tbmc150_accel_interrupts_setup(indio_dev, data, irq);\n\n\t\tret = bmc150_accel_triggers_setup(indio_dev, data);\n\t\tif (ret)\n\t\t\tgoto err_buffer_cleanup;\n\t}\n\n\tret = pm_runtime_set_active(dev);\n\tif (ret)\n\t\tgoto err_trigger_unregister;\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev, BMC150_AUTO_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Unable to register iio device\\n\");\n\t\tgoto err_pm_cleanup;\n\t}\n\n\treturn 0;\n\nerr_pm_cleanup:\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\nerr_trigger_unregister:\n\tbmc150_accel_unregister_triggers(data, BMC150_ACCEL_TRIGGERS - 1);\nerr_buffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\nerr_disable_regulators:\n\tregulator_bulk_disable(ARRAY_SIZE(data->regulators),\n\t\t\t       data->regulators);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(bmc150_accel_core_probe, IIO_BMC150);\n\nvoid bmc150_accel_core_remove(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\n\tbmc150_accel_unregister_triggers(data, BMC150_ACCEL_TRIGGERS - 1);\n\n\tiio_triggered_buffer_cleanup(indio_dev);\n\n\tmutex_lock(&data->mutex);\n\tbmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_DEEP_SUSPEND, 0);\n\tmutex_unlock(&data->mutex);\n\n\tregulator_bulk_disable(ARRAY_SIZE(data->regulators),\n\t\t\t       data->regulators);\n}\nEXPORT_SYMBOL_NS_GPL(bmc150_accel_core_remove, IIO_BMC150);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int bmc150_accel_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\n\tmutex_lock(&data->mutex);\n\tbmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_SUSPEND, 0);\n\tmutex_unlock(&data->mutex);\n\n\treturn 0;\n}\n\nstatic int bmc150_accel_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\n\tmutex_lock(&data->mutex);\n\tbmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_NORMAL, 0);\n\tbmc150_accel_fifo_set_mode(data);\n\tmutex_unlock(&data->mutex);\n\n\tif (data->resume_callback)\n\t\tdata->resume_callback(dev);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int bmc150_accel_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = bmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_SUSPEND, 0);\n\tif (ret < 0)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int bmc150_accel_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmc150_accel_data *data = iio_priv(indio_dev);\n\tint ret;\n\tint sleep_val;\n\n\tret = bmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_NORMAL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = bmc150_accel_fifo_set_mode(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsleep_val = bmc150_accel_get_startup_times(data);\n\tif (sleep_val < 20)\n\t\tusleep_range(sleep_val * 1000, 20000);\n\telse\n\t\tmsleep_interruptible(sleep_val);\n\n\treturn 0;\n}\n#endif\n\nconst struct dev_pm_ops bmc150_accel_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(bmc150_accel_suspend, bmc150_accel_resume)\n\tSET_RUNTIME_PM_OPS(bmc150_accel_runtime_suspend,\n\t\t\t   bmc150_accel_runtime_resume, NULL)\n};\nEXPORT_SYMBOL_NS_GPL(bmc150_accel_pm_ops, IIO_BMC150);\n\nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"BMC150 accelerometer driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}