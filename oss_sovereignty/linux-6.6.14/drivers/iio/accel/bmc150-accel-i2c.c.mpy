{
  "module_name": "bmc150-accel-i2c.c",
  "hash_id": "09830b2b17518423bc94b805f025b22ded5c91777e342edf79245d5d9d898cef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/bmc150-accel-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/regmap.h>\n\n#include \"bmc150-accel.h\"\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id bmc150_acpi_dual_accel_ids[] = {\n\t{\"BOSC0200\"},\n\t{\"DUAL250E\"},\n\t{ }\n};\n\n \n\n#define BMC150_DSM_GUID\t\t\t\t\"7681541e-8827-4239-8d9d-36be7fe12542\"\n#define DUAL250E_SET_ANGLE_FN_INDEX\t\t3\n\nstruct dual250e_set_angle_args {\n\tu32 aux0;\n\tu32 ang0;\n\tu32 rawx;\n\tu32 rawy;\n\tu32 rawz;\n} __packed;\n\nstatic bool bmc150_acpi_set_angle_dsm(struct i2c_client *client, u32 aux0, u32 ang0)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&client->dev);\n\tstruct dual250e_set_angle_args args = {\n\t\t.aux0 = aux0,\n\t\t.ang0 = ang0,\n\t};\n\tunion acpi_object args_obj, *obj;\n\tguid_t guid;\n\n\tif (!acpi_dev_hid_uid_match(adev, \"DUAL250E\", NULL))\n\t\treturn false;\n\n\tguid_parse(BMC150_DSM_GUID, &guid);\n\n\tif (!acpi_check_dsm(adev->handle, &guid, 0, BIT(DUAL250E_SET_ANGLE_FN_INDEX)))\n\t\treturn false;\n\n\t \n\targs_obj.type = ACPI_TYPE_BUFFER;\n\targs_obj.buffer.length = sizeof(args);\n\targs_obj.buffer.pointer = (u8 *)&args;\n\n\tobj = acpi_evaluate_dsm(adev->handle, &guid, 0, DUAL250E_SET_ANGLE_FN_INDEX, &args_obj);\n\tif (!obj) {\n\t\tdev_err(&client->dev, \"Failed to call DSM to enable keyboard and touchpad\\n\");\n\t\treturn false;\n\t}\n\n\tACPI_FREE(obj);\n\treturn true;\n}\n\nstatic bool bmc150_acpi_enable_keyboard(struct i2c_client *client)\n{\n\t \n\tif (!bmc150_acpi_set_angle_dsm(client, 0, 270))\n\t\treturn false;\n\n\t \n\tmsleep(100);\n\n\treturn bmc150_acpi_set_angle_dsm(client, 0, 90);\n}\n\nstatic void bmc150_acpi_resume_work(struct work_struct *work)\n{\n\tstruct bmc150_accel_data *data =\n\t\tcontainer_of(work, struct bmc150_accel_data, resume_work.work);\n\n\tbmc150_acpi_enable_keyboard(data->second_device);\n}\n\nstatic void bmc150_acpi_resume_handler(struct device *dev)\n{\n\tstruct bmc150_accel_data *data = iio_priv(dev_get_drvdata(dev));\n\n\t \n\tschedule_delayed_work(&data->resume_work, msecs_to_jiffies(1000));\n}\n\n \nstatic void bmc150_acpi_dual_accel_probe(struct i2c_client *client)\n{\n\tstruct bmc150_accel_data *data = iio_priv(i2c_get_clientdata(client));\n\tstruct acpi_device *adev = ACPI_COMPANION(&client->dev);\n\tchar dev_name[16];\n\tstruct i2c_board_info board_info = {\n\t\t.type = \"bmc150_accel\",\n\t\t.dev_name = dev_name,\n\t\t.fwnode = client->dev.fwnode,\n\t};\n\n\tif (acpi_match_device_ids(adev, bmc150_acpi_dual_accel_ids))\n\t\treturn;\n\n\t \n\tsnprintf(dev_name, sizeof(dev_name), \"%s:base\", acpi_device_hid(adev));\n\n\tboard_info.irq = acpi_dev_gpio_irq_get(adev, 1);\n\n\tdata->second_device = i2c_acpi_new_device(&client->dev, 1, &board_info);\n\n\tif (!IS_ERR(data->second_device) && bmc150_acpi_enable_keyboard(data->second_device)) {\n\t\tINIT_DELAYED_WORK(&data->resume_work, bmc150_acpi_resume_work);\n\t\tdata->resume_callback = bmc150_acpi_resume_handler;\n\t}\n}\n\nstatic void bmc150_acpi_dual_accel_remove(struct i2c_client *client)\n{\n\tstruct bmc150_accel_data *data = iio_priv(i2c_get_clientdata(client));\n\n\tif (data->resume_callback)\n\t\tcancel_delayed_work_sync(&data->resume_work);\n\n\ti2c_unregister_device(data->second_device);\n}\n#else\nstatic void bmc150_acpi_dual_accel_probe(struct i2c_client *client) {}\nstatic void bmc150_acpi_dual_accel_remove(struct i2c_client *client) {}\n#endif\n\nstatic int bmc150_accel_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct regmap *regmap;\n\tconst char *name = NULL;\n\tenum bmc150_type type = BOSCH_UNKNOWN;\n\tbool block_supported =\n\t\ti2c_check_functionality(client->adapter, I2C_FUNC_I2C) ||\n\t\ti2c_check_functionality(client->adapter,\n\t\t\t\t\tI2C_FUNC_SMBUS_READ_I2C_BLOCK);\n\tint ret;\n\n\tregmap = devm_regmap_init_i2c(client, &bmc150_regmap_conf);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"Failed to initialize i2c regmap\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tif (id) {\n\t\tname = id->name;\n\t\ttype = id->driver_data;\n\t}\n\n\tret = bmc150_accel_core_probe(&client->dev, regmap, client->irq,\n\t\t\t\t      type, name, block_supported);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!id && has_acpi_companion(&client->dev))\n\t\tbmc150_acpi_dual_accel_probe(client);\n\n\treturn 0;\n}\n\nstatic void bmc150_accel_remove(struct i2c_client *client)\n{\n\tbmc150_acpi_dual_accel_remove(client);\n\n\tbmc150_accel_core_remove(&client->dev);\n}\n\nstatic const struct acpi_device_id bmc150_accel_acpi_match[] = {\n\t{\"BMA0255\"},\n\t{\"BMA0280\"},\n\t{\"BMA222\"},\n\t{\"BMA222E\"},\n\t{\"BMA250E\"},\n\t{\"BMC150A\"},\n\t{\"BMI055A\"},\n\t{\"BOSC0200\"},\n\t{\"BSBA0150\"},\n\t{\"DUAL250E\"},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, bmc150_accel_acpi_match);\n\nstatic const struct i2c_device_id bmc150_accel_id[] = {\n\t{\"bma222\"},\n\t{\"bma222e\"},\n\t{\"bma250e\"},\n\t{\"bma253\"},\n\t{\"bma254\"},\n\t{\"bma255\"},\n\t{\"bma280\"},\n\t{\"bmc150_accel\"},\n\t{\"bmc156_accel\", BOSCH_BMC156},\n\t{\"bmi055_accel\"},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, bmc150_accel_id);\n\nstatic const struct of_device_id bmc150_accel_of_match[] = {\n\t{ .compatible = \"bosch,bma222\" },\n\t{ .compatible = \"bosch,bma222e\" },\n\t{ .compatible = \"bosch,bma250e\" },\n\t{ .compatible = \"bosch,bma253\" },\n\t{ .compatible = \"bosch,bma254\" },\n\t{ .compatible = \"bosch,bma255\" },\n\t{ .compatible = \"bosch,bma280\" },\n\t{ .compatible = \"bosch,bmc150_accel\" },\n\t{ .compatible = \"bosch,bmc156_accel\" },\n\t{ .compatible = \"bosch,bmi055_accel\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bmc150_accel_of_match);\n\nstatic struct i2c_driver bmc150_accel_driver = {\n\t.driver = {\n\t\t.name\t= \"bmc150_accel_i2c\",\n\t\t.of_match_table = bmc150_accel_of_match,\n\t\t.acpi_match_table = ACPI_PTR(bmc150_accel_acpi_match),\n\t\t.pm\t= &bmc150_accel_pm_ops,\n\t},\n\t.probe\t\t= bmc150_accel_probe,\n\t.remove\t\t= bmc150_accel_remove,\n\t.id_table\t= bmc150_accel_id,\n};\nmodule_i2c_driver(bmc150_accel_driver);\n\nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"BMC150 I2C accelerometer driver\");\nMODULE_IMPORT_NS(IIO_BMC150);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}