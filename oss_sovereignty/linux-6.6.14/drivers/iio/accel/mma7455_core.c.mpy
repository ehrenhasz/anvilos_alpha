{
  "module_name": "mma7455_core.c",
  "hash_id": "e8f5023ccc0cab220cf404e9089ddf49fccfb0d6612df4e9cb85a3ce2fb7f3a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/mma7455_core.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n#include \"mma7455.h\"\n\n#define MMA7455_REG_XOUTL\t\t0x00\n#define MMA7455_REG_XOUTH\t\t0x01\n#define MMA7455_REG_YOUTL\t\t0x02\n#define MMA7455_REG_YOUTH\t\t0x03\n#define MMA7455_REG_ZOUTL\t\t0x04\n#define MMA7455_REG_ZOUTH\t\t0x05\n#define MMA7455_REG_STATUS\t\t0x09\n#define  MMA7455_STATUS_DRDY\t\tBIT(0)\n#define MMA7455_REG_WHOAMI\t\t0x0f\n#define  MMA7455_WHOAMI_ID\t\t0x55\n#define MMA7455_REG_MCTL\t\t0x16\n#define  MMA7455_MCTL_MODE_STANDBY\t0x00\n#define  MMA7455_MCTL_MODE_MEASURE\t0x01\n#define MMA7455_REG_CTL1\t\t0x18\n#define  MMA7455_CTL1_DFBW_MASK\t\tBIT(7)\n#define  MMA7455_CTL1_DFBW_125HZ\tBIT(7)\n#define  MMA7455_CTL1_DFBW_62_5HZ\t0\n#define MMA7455_REG_TW\t\t\t0x1e\n\n \n#define MMA7455_10BIT_SCALE\t153229\n\nstruct mma7455_data {\n\tstruct regmap *regmap;\n\t \n\tstruct {\n\t\t__le16 channels[3];\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\nstatic int mma7455_drdy(struct mma7455_data *mma7455)\n{\n\tstruct device *dev = regmap_get_device(mma7455->regmap);\n\tunsigned int reg;\n\tint tries = 3;\n\tint ret;\n\n\twhile (tries-- > 0) {\n\t\tret = regmap_read(mma7455->regmap, MMA7455_REG_STATUS, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (reg & MMA7455_STATUS_DRDY)\n\t\t\treturn 0;\n\n\t\tmsleep(20);\n\t}\n\n\tdev_warn(dev, \"data not ready\\n\");\n\n\treturn -EIO;\n}\n\nstatic irqreturn_t mma7455_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct mma7455_data *mma7455 = iio_priv(indio_dev);\n\tint ret;\n\n\tret = mma7455_drdy(mma7455);\n\tif (ret)\n\t\tgoto done;\n\n\tret = regmap_bulk_read(mma7455->regmap, MMA7455_REG_XOUTL,\n\t\t\t       mma7455->scan.channels,\n\t\t\t       sizeof(mma7455->scan.channels));\n\tif (ret)\n\t\tgoto done;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &mma7455->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mma7455_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct mma7455_data *mma7455 = iio_priv(indio_dev);\n\tunsigned int reg;\n\t__le16 data;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (iio_buffer_enabled(indio_dev))\n\t\t\treturn -EBUSY;\n\n\t\tret = mma7455_drdy(mma7455);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_bulk_read(mma7455->regmap, chan->address, &data,\n\t\t\t\t       sizeof(data));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = sign_extend32(le16_to_cpu(data),\n\t\t\t\t     chan->scan_type.realbits - 1);\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = MMA7455_10BIT_SCALE;\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = regmap_read(mma7455->regmap, MMA7455_REG_CTL1, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (reg & MMA7455_CTL1_DFBW_MASK)\n\t\t\t*val = 250;\n\t\telse\n\t\t\t*val = 125;\n\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mma7455_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct mma7455_data *mma7455 = iio_priv(indio_dev);\n\tint i;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (val == 250 && val2 == 0)\n\t\t\ti = MMA7455_CTL1_DFBW_125HZ;\n\t\telse if (val == 125 && val2 == 0)\n\t\t\ti = MMA7455_CTL1_DFBW_62_5HZ;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\treturn regmap_update_bits(mma7455->regmap, MMA7455_REG_CTL1,\n\t\t\t\t\t  MMA7455_CTL1_DFBW_MASK, i);\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\tif (val == 0 && val2 == MMA7455_10BIT_SCALE)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic IIO_CONST_ATTR(sampling_frequency_available, \"125 250\");\n\nstatic struct attribute *mma7455_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group mma7455_group = {\n\t.attrs = mma7455_attributes,\n};\n\nstatic const struct iio_info mma7455_info = {\n\t.attrs = &mma7455_group,\n\t.read_raw = mma7455_read_raw,\n\t.write_raw = mma7455_write_raw,\n};\n\n#define MMA7455_CHANNEL(axis, idx) { \\\n\t.type = IIO_ACCEL, \\\n\t.modified = 1, \\\n\t.address = MMA7455_REG_##axis##OUTL,\\\n\t.channel2 = IIO_MOD_##axis, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\t\t\t    BIT(IIO_CHAN_INFO_SCALE), \\\n\t.scan_index = idx, \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = 10, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_LE, \\\n\t}, \\\n}\n\nstatic const struct iio_chan_spec mma7455_channels[] = {\n\tMMA7455_CHANNEL(X, 0),\n\tMMA7455_CHANNEL(Y, 1),\n\tMMA7455_CHANNEL(Z, 2),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic const unsigned long mma7455_scan_masks[] = {0x7, 0};\n\nconst struct regmap_config mma7455_core_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = MMA7455_REG_TW,\n};\nEXPORT_SYMBOL_NS_GPL(mma7455_core_regmap, IIO_MMA7455);\n\nint mma7455_core_probe(struct device *dev, struct regmap *regmap,\n\t\t       const char *name)\n{\n\tstruct mma7455_data *mma7455;\n\tstruct iio_dev *indio_dev;\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(regmap, MMA7455_REG_WHOAMI, &reg);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to read reg\\n\");\n\t\treturn ret;\n\t}\n\n\tif (reg != MMA7455_WHOAMI_ID) {\n\t\tdev_err(dev, \"device id mismatch\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*mma7455));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, indio_dev);\n\tmma7455 = iio_priv(indio_dev);\n\tmma7455->regmap = regmap;\n\n\tindio_dev->info = &mma7455_info;\n\tindio_dev->name = name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = mma7455_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mma7455_channels);\n\tindio_dev->available_scan_masks = mma7455_scan_masks;\n\n\tregmap_write(mma7455->regmap, MMA7455_REG_MCTL,\n\t\t     MMA7455_MCTL_MODE_MEASURE);\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL,\n\t\t\t\t\t mma7455_trigger_handler, NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to setup triggered buffer\\n\");\n\t\treturn ret;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to register device\\n\");\n\t\tiio_triggered_buffer_cleanup(indio_dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(mma7455_core_probe, IIO_MMA7455);\n\nvoid mma7455_core_remove(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct mma7455_data *mma7455 = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\n\tregmap_write(mma7455->regmap, MMA7455_REG_MCTL,\n\t\t     MMA7455_MCTL_MODE_STANDBY);\n}\nEXPORT_SYMBOL_NS_GPL(mma7455_core_remove, IIO_MMA7455);\n\nMODULE_AUTHOR(\"Joachim Eastwood <manabian@gmail.com>\");\nMODULE_DESCRIPTION(\"Freescale MMA7455L core accelerometer driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}