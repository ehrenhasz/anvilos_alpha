{
  "module_name": "mma7660.c",
  "hash_id": "bf249bd53f5f2d5f973f811d68f7b2b0383d796a68b2b3c62100cc55739dcc0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/mma7660.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define MMA7660_DRIVER_NAME\t\"mma7660\"\n\n#define MMA7660_REG_XOUT\t0x00\n#define MMA7660_REG_YOUT\t0x01\n#define MMA7660_REG_ZOUT\t0x02\n#define MMA7660_REG_OUT_BIT_ALERT\tBIT(6)\n\n#define MMA7660_REG_MODE\t0x07\n#define MMA7660_REG_MODE_BIT_MODE\tBIT(0)\n#define MMA7660_REG_MODE_BIT_TON\tBIT(2)\n\n#define MMA7660_I2C_READ_RETRIES\t5\n\n \n\n#define MMA7660_SCALE_AVAIL\t\"0.467142857\"\n\nstatic const int mma7660_nscale = 467142857;\n\n#define MMA7660_CHANNEL(reg, axis) {\t\\\n\t.type = IIO_ACCEL,\t\\\n\t.address = reg,\t\\\n\t.modified = 1,\t\\\n\t.channel2 = IIO_MOD_##axis,\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n}\n\nstatic const struct iio_chan_spec mma7660_channels[] = {\n\tMMA7660_CHANNEL(MMA7660_REG_XOUT, X),\n\tMMA7660_CHANNEL(MMA7660_REG_YOUT, Y),\n\tMMA7660_CHANNEL(MMA7660_REG_ZOUT, Z),\n};\n\nenum mma7660_mode {\n\tMMA7660_MODE_STANDBY,\n\tMMA7660_MODE_ACTIVE\n};\n\nstruct mma7660_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tenum mma7660_mode mode;\n};\n\nstatic IIO_CONST_ATTR(in_accel_scale_available, MMA7660_SCALE_AVAIL);\n\nstatic struct attribute *mma7660_attributes[] = {\n\t&iio_const_attr_in_accel_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mma7660_attribute_group = {\n\t.attrs = mma7660_attributes\n};\n\nstatic int mma7660_set_mode(struct mma7660_data *data,\n\t\t\t\tenum mma7660_mode mode)\n{\n\tint ret;\n\tstruct i2c_client *client = data->client;\n\n\tif (mode == data->mode)\n\t\treturn 0;\n\n\tret = i2c_smbus_read_byte_data(client, MMA7660_REG_MODE);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to read sensor mode\\n\");\n\t\treturn ret;\n\t}\n\n\tif (mode == MMA7660_MODE_ACTIVE) {\n\t\tret &= ~MMA7660_REG_MODE_BIT_TON;\n\t\tret |= MMA7660_REG_MODE_BIT_MODE;\n\t} else {\n\t\tret &= ~MMA7660_REG_MODE_BIT_TON;\n\t\tret &= ~MMA7660_REG_MODE_BIT_MODE;\n\t}\n\n\tret = i2c_smbus_write_byte_data(client, MMA7660_REG_MODE, ret);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to change sensor mode\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->mode = mode;\n\n\treturn ret;\n}\n\nstatic int mma7660_read_accel(struct mma7660_data *data, u8 address)\n{\n\tint ret, retries = MMA7660_I2C_READ_RETRIES;\n\tstruct i2c_client *client = data->client;\n\n\t \n\tdo {\n\t\tret = i2c_smbus_read_byte_data(client, address);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"register read failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} while (retries-- > 0 && ret & MMA7660_REG_OUT_BIT_ALERT);\n\n\tif (ret & MMA7660_REG_OUT_BIT_ALERT) {\n\t\tdev_err(&client->dev, \"all register read retries failed\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn ret;\n}\n\nstatic int mma7660_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tstruct mma7660_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&data->lock);\n\t\tret = mma7660_read_accel(data, chan->address);\n\t\tmutex_unlock(&data->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = sign_extend32(ret, 5);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = mma7660_nscale;\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info mma7660_info = {\n\t.read_raw\t\t= mma7660_read_raw,\n\t.attrs\t\t\t= &mma7660_attribute_group,\n};\n\nstatic int mma7660_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\tstruct mma7660_data *data;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev) {\n\t\tdev_err(&client->dev, \"iio allocation failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\ti2c_set_clientdata(client, indio_dev);\n\tmutex_init(&data->lock);\n\tdata->mode = MMA7660_MODE_STANDBY;\n\n\tindio_dev->info = &mma7660_info;\n\tindio_dev->name = MMA7660_DRIVER_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = mma7660_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mma7660_channels);\n\n\tret = mma7660_set_mode(data, MMA7660_MODE_ACTIVE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"device_register failed\\n\");\n\t\tmma7660_set_mode(data, MMA7660_MODE_STANDBY);\n\t}\n\n\treturn ret;\n}\n\nstatic void mma7660_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tint ret;\n\n\tiio_device_unregister(indio_dev);\n\n\tret = mma7660_set_mode(iio_priv(indio_dev), MMA7660_MODE_STANDBY);\n\tif (ret)\n\t\tdev_warn(&client->dev, \"Failed to put device in stand-by mode (%pe), ignoring\\n\",\n\t\t\t ERR_PTR(ret));\n}\n\nstatic int mma7660_suspend(struct device *dev)\n{\n\tstruct mma7660_data *data;\n\n\tdata = iio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\n\treturn mma7660_set_mode(data, MMA7660_MODE_STANDBY);\n}\n\nstatic int mma7660_resume(struct device *dev)\n{\n\tstruct mma7660_data *data;\n\n\tdata = iio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\n\treturn mma7660_set_mode(data, MMA7660_MODE_ACTIVE);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mma7660_pm_ops, mma7660_suspend,\n\t\t\t\tmma7660_resume);\n\nstatic const struct i2c_device_id mma7660_i2c_id[] = {\n\t{\"mma7660\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, mma7660_i2c_id);\n\nstatic const struct of_device_id mma7660_of_match[] = {\n\t{ .compatible = \"fsl,mma7660\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mma7660_of_match);\n\nstatic const struct acpi_device_id mma7660_acpi_id[] = {\n\t{\"MMA7660\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(acpi, mma7660_acpi_id);\n\nstatic struct i2c_driver mma7660_driver = {\n\t.driver = {\n\t\t.name = \"mma7660\",\n\t\t.pm = pm_sleep_ptr(&mma7660_pm_ops),\n\t\t.of_match_table = mma7660_of_match,\n\t\t.acpi_match_table = mma7660_acpi_id,\n\t},\n\t.probe\t\t= mma7660_probe,\n\t.remove\t\t= mma7660_remove,\n\t.id_table\t= mma7660_i2c_id,\n};\n\nmodule_i2c_driver(mma7660_driver);\n\nMODULE_AUTHOR(\"Constantin Musca <constantin.musca@intel.com>\");\nMODULE_DESCRIPTION(\"Freescale MMA7660FC 3-Axis Accelerometer driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}