{
  "module_name": "mma9551.c",
  "hash_id": "a71623bb6e167a5aa4559fa68f0ee6d1171156c4014618a98fc15ba522b70636",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/mma9551.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n#include <linux/pm_runtime.h>\n#include \"mma9551_core.h\"\n\n#define MMA9551_DRV_NAME\t\t\"mma9551\"\n#define MMA9551_IRQ_NAME\t\t\"mma9551_event\"\n#define MMA9551_GPIO_COUNT\t\t4\n\n \n#define MMA9551_TILT_XZ_ANG_REG\t\t0x00\n#define MMA9551_TILT_YZ_ANG_REG\t\t0x01\n#define MMA9551_TILT_XY_ANG_REG\t\t0x02\n#define MMA9551_TILT_ANGFLG\t\tBIT(7)\n#define MMA9551_TILT_QUAD_REG\t\t0x03\n#define MMA9551_TILT_XY_QUAD_SHIFT\t0\n#define MMA9551_TILT_YZ_QUAD_SHIFT\t2\n#define MMA9551_TILT_XZ_QUAD_SHIFT\t4\n#define MMA9551_TILT_CFG_REG\t\t0x01\n#define MMA9551_TILT_ANG_THRESH_MASK\tGENMASK(3, 0)\n\n#define MMA9551_DEFAULT_SAMPLE_RATE\t122\t \n\n \nenum mma9551_tilt_axis {\n\tmma9551_x = 0,\n\tmma9551_y,\n\tmma9551_z,\n};\n\nstruct mma9551_data {\n\tstruct i2c_client *client;\n\tstruct mutex mutex;\n\tint event_enabled[3];\n\tint irqs[MMA9551_GPIO_COUNT];\n};\n\nstatic int mma9551_read_incli_chan(struct i2c_client *client,\n\t\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t\t   int *val)\n{\n\tu8 quad_shift, angle, quadrant;\n\tu16 reg_addr;\n\tint ret;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_X:\n\t\treg_addr = MMA9551_TILT_YZ_ANG_REG;\n\t\tquad_shift = MMA9551_TILT_YZ_QUAD_SHIFT;\n\t\tbreak;\n\tcase IIO_MOD_Y:\n\t\treg_addr = MMA9551_TILT_XZ_ANG_REG;\n\t\tquad_shift = MMA9551_TILT_XZ_QUAD_SHIFT;\n\t\tbreak;\n\tcase IIO_MOD_Z:\n\t\treg_addr = MMA9551_TILT_XY_ANG_REG;\n\t\tquad_shift = MMA9551_TILT_XY_QUAD_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = mma9551_set_power_state(client, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mma9551_read_status_byte(client, MMA9551_APPID_TILT,\n\t\t\t\t       reg_addr, &angle);\n\tif (ret < 0)\n\t\tgoto out_poweroff;\n\n\tret = mma9551_read_status_byte(client, MMA9551_APPID_TILT,\n\t\t\t\t       MMA9551_TILT_QUAD_REG, &quadrant);\n\tif (ret < 0)\n\t\tgoto out_poweroff;\n\n\tangle &= ~MMA9551_TILT_ANGFLG;\n\tquadrant = (quadrant >> quad_shift) & 0x03;\n\n\tif (quadrant == 1 || quadrant == 3)\n\t\t*val = 90 * (quadrant + 1) - angle;\n\telse\n\t\t*val = angle + 90 * quadrant;\n\n\tret = IIO_VAL_INT;\n\nout_poweroff:\n\tmma9551_set_power_state(client, false);\n\treturn ret;\n}\n\nstatic int mma9551_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct mma9551_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_INCLI:\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tret = mma9551_read_incli_chan(data->client, chan, val);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ACCEL:\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tret = mma9551_read_accel_chan(data->client,\n\t\t\t\t\t\t      chan, val, val2);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ACCEL:\n\t\t\treturn mma9551_read_accel_scale(val, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mma9551_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir)\n{\n\tstruct mma9551_data *data = iio_priv(indio_dev);\n\n\tswitch (chan->type) {\n\tcase IIO_INCLI:\n\t\t \n\t\treturn data->event_enabled[chan->channel2 - 1];\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mma9551_config_incli_event(struct iio_dev *indio_dev,\n\t\t\t\t      enum iio_modifier axis,\n\t\t\t\t      int state)\n{\n\tstruct mma9551_data *data = iio_priv(indio_dev);\n\tenum mma9551_tilt_axis mma_axis;\n\tint ret;\n\n\t \n\tmma_axis = axis - 1;\n\n\tif (data->event_enabled[mma_axis] == state)\n\t\treturn 0;\n\n\tif (state == 0) {\n\t\tret = mma9551_gpio_config(data->client,\n\t\t\t\t\t  (enum mma9551_gpio_pin)mma_axis,\n\t\t\t\t\t  MMA9551_APPID_NONE, 0, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = mma9551_set_power_state(data->client, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tint bitnum;\n\n\t\t \n\t\tswitch (axis) {\n\t\tcase IIO_MOD_X:\n\t\t\tbitnum = 7 + 8 * MMA9551_TILT_YZ_ANG_REG;\n\t\t\tbreak;\n\t\tcase IIO_MOD_Y:\n\t\t\tbitnum = 7 + 8 * MMA9551_TILT_XZ_ANG_REG;\n\t\t\tbreak;\n\t\tcase IIO_MOD_Z:\n\t\t\tbitnum = 7 + 8 * MMA9551_TILT_XY_ANG_REG;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\n\t\tret = mma9551_set_power_state(data->client, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = mma9551_gpio_config(data->client,\n\t\t\t\t\t  (enum mma9551_gpio_pin)mma_axis,\n\t\t\t\t\t  MMA9551_APPID_TILT, bitnum, 0);\n\t\tif (ret < 0) {\n\t\t\tmma9551_set_power_state(data->client, false);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdata->event_enabled[mma_axis] = state;\n\n\treturn ret;\n}\n\nstatic int mma9551_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir,\n\t\t\t\t      int state)\n{\n\tstruct mma9551_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (chan->type) {\n\tcase IIO_INCLI:\n\t\tmutex_lock(&data->mutex);\n\t\tret = mma9551_config_incli_event(indio_dev,\n\t\t\t\t\t\t chan->channel2, state);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mma9551_write_event_value(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir,\n\t\t\t\t     enum iio_event_info info,\n\t\t\t\t     int val, int val2)\n{\n\tstruct mma9551_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (chan->type) {\n\tcase IIO_INCLI:\n\t\tif (val2 != 0 || val < 1 || val > 10)\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&data->mutex);\n\t\tret = mma9551_update_config_bits(data->client,\n\t\t\t\t\t\t MMA9551_APPID_TILT,\n\t\t\t\t\t\t MMA9551_TILT_CFG_REG,\n\t\t\t\t\t\t MMA9551_TILT_ANG_THRESH_MASK,\n\t\t\t\t\t\t val);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mma9551_read_event_value(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir,\n\t\t\t\t    enum iio_event_info info,\n\t\t\t\t    int *val, int *val2)\n{\n\tstruct mma9551_data *data = iio_priv(indio_dev);\n\tint ret;\n\tu8 tmp;\n\n\tswitch (chan->type) {\n\tcase IIO_INCLI:\n\t\tmutex_lock(&data->mutex);\n\t\tret = mma9551_read_config_byte(data->client,\n\t\t\t\t\t       MMA9551_APPID_TILT,\n\t\t\t\t\t       MMA9551_TILT_CFG_REG, &tmp);\n\t\tmutex_unlock(&data->mutex);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = tmp & MMA9551_TILT_ANG_THRESH_MASK;\n\t\t*val2 = 0;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_event_spec mma9551_incli_event = {\n\t.type = IIO_EV_TYPE_ROC,\n\t.dir = IIO_EV_DIR_RISING,\n\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t.mask_shared_by_type = BIT(IIO_EV_INFO_VALUE),\n};\n\n#define MMA9551_INCLI_CHANNEL(axis) {\t\t\t\t\\\n\t.type = IIO_INCLI,\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\\\n\t.channel2 = axis,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\t\\\n\t.event_spec = &mma9551_incli_event,\t\t\t\\\n\t.num_event_specs = 1,\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec mma9551_channels[] = {\n\tMMA9551_ACCEL_CHANNEL(IIO_MOD_X),\n\tMMA9551_ACCEL_CHANNEL(IIO_MOD_Y),\n\tMMA9551_ACCEL_CHANNEL(IIO_MOD_Z),\n\n\tMMA9551_INCLI_CHANNEL(IIO_MOD_X),\n\tMMA9551_INCLI_CHANNEL(IIO_MOD_Y),\n\tMMA9551_INCLI_CHANNEL(IIO_MOD_Z),\n};\n\nstatic const struct iio_info mma9551_info = {\n\t.read_raw = mma9551_read_raw,\n\t.read_event_config = mma9551_read_event_config,\n\t.write_event_config = mma9551_write_event_config,\n\t.read_event_value = mma9551_read_event_value,\n\t.write_event_value = mma9551_write_event_value,\n};\n\nstatic irqreturn_t mma9551_event_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct mma9551_data *data = iio_priv(indio_dev);\n\tint i, ret, mma_axis = -1;\n\tu16 reg;\n\tu8 val;\n\n\tmutex_lock(&data->mutex);\n\n\tfor (i = 0; i < 3; i++)\n\t\tif (irq == data->irqs[i]) {\n\t\t\tmma_axis = i;\n\t\t\tbreak;\n\t\t}\n\n\tif (mma_axis == -1) {\n\t\t \n\t\tdev_warn(&data->client->dev,\n\t\t\t \"irq triggered on unused line %d\\n\", data->irqs[3]);\n\t\tgoto out;\n\t}\n\n\tswitch (mma_axis) {\n\tcase mma9551_x:\n\t\treg = MMA9551_TILT_YZ_ANG_REG;\n\t\tbreak;\n\tcase mma9551_y:\n\t\treg = MMA9551_TILT_XZ_ANG_REG;\n\t\tbreak;\n\tcase mma9551_z:\n\t\treg = MMA9551_TILT_XY_ANG_REG;\n\t\tbreak;\n\t}\n\n\t \n\tret = mma9551_read_status_byte(data->client, MMA9551_APPID_TILT,\n\t\t\t\t       reg, &val);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"error %d reading tilt register in IRQ\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tiio_push_event(indio_dev,\n\t\t       IIO_MOD_EVENT_CODE(IIO_INCLI, 0, (mma_axis + 1),\n\t\t\t\t\t  IIO_EV_TYPE_ROC, IIO_EV_DIR_RISING),\n\t\t       iio_get_time_ns(indio_dev));\n\nout:\n\tmutex_unlock(&data->mutex);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mma9551_init(struct mma9551_data *data)\n{\n\tint ret;\n\n\tret = mma9551_read_version(data->client);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mma9551_set_device_state(data->client, true);\n}\n\nstatic int mma9551_gpio_probe(struct iio_dev *indio_dev)\n{\n\tstruct gpio_desc *gpio;\n\tint i, ret;\n\tstruct mma9551_data *data = iio_priv(indio_dev);\n\tstruct device *dev = &data->client->dev;\n\n\tfor (i = 0; i < MMA9551_GPIO_COUNT; i++) {\n\t\tgpio = devm_gpiod_get_index(dev, NULL, i, GPIOD_IN);\n\t\tif (IS_ERR(gpio)) {\n\t\t\tdev_err(dev, \"acpi gpio get index failed\\n\");\n\t\t\treturn PTR_ERR(gpio);\n\t\t}\n\n\t\tret = gpiod_to_irq(gpio);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata->irqs[i] = ret;\n\t\tret = devm_request_threaded_irq(dev, data->irqs[i],\n\t\t\t\tNULL, mma9551_event_handler,\n\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\tMMA9551_IRQ_NAME, indio_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"request irq %d failed\\n\", data->irqs[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_dbg(dev, \"gpio resource, no:%d irq:%d\\n\",\n\t\t\tdesc_to_gpio(gpio), data->irqs[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic const char *mma9551_match_acpi_device(struct device *dev)\n{\n\tconst struct acpi_device_id *id;\n\n\tid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\tif (!id)\n\t\treturn NULL;\n\n\treturn dev_name(dev);\n}\n\nstatic int mma9551_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct mma9551_data *data;\n\tstruct iio_dev *indio_dev;\n\tconst char *name = NULL;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tif (id)\n\t\tname = id->name;\n\telse if (ACPI_HANDLE(&client->dev))\n\t\tname = mma9551_match_acpi_device(&client->dev);\n\n\tret = mma9551_init(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_init(&data->mutex);\n\n\tindio_dev->channels = mma9551_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mma9551_channels);\n\tindio_dev->name = name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &mma9551_info;\n\n\tret = mma9551_gpio_probe(indio_dev);\n\tif (ret < 0)\n\t\tgoto out_poweroff;\n\n\tret = pm_runtime_set_active(&client->dev);\n\tif (ret < 0)\n\t\tgoto out_poweroff;\n\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev,\n\t\t\t\t\t MMA9551_AUTO_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"unable to register iio device\\n\");\n\t\tgoto err_pm_cleanup;\n\t}\n\n\treturn 0;\n\nerr_pm_cleanup:\n\tpm_runtime_dont_use_autosuspend(&client->dev);\n\tpm_runtime_disable(&client->dev);\nout_poweroff:\n\tmma9551_set_device_state(client, false);\n\n\treturn ret;\n}\n\nstatic void mma9551_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct mma9551_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tmutex_lock(&data->mutex);\n\tmma9551_set_device_state(data->client, false);\n\tmutex_unlock(&data->mutex);\n}\n\nstatic int mma9551_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mma9551_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = mma9551_set_device_state(data->client, false);\n\tmutex_unlock(&data->mutex);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"powering off device failed\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic int mma9551_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mma9551_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = mma9551_set_device_state(data->client, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmma9551_sleep(MMA9551_DEFAULT_SAMPLE_RATE);\n\n\treturn 0;\n}\n\nstatic int mma9551_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mma9551_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = mma9551_set_device_state(data->client, false);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int mma9551_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mma9551_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = mma9551_set_device_state(data->client, true);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops mma9551_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(mma9551_suspend, mma9551_resume)\n\tRUNTIME_PM_OPS(mma9551_runtime_suspend, mma9551_runtime_resume, NULL)\n};\n\nstatic const struct acpi_device_id mma9551_acpi_match[] = {\n\t{\"MMA9551\", 0},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(acpi, mma9551_acpi_match);\n\nstatic const struct i2c_device_id mma9551_id[] = {\n\t{\"mma9551\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, mma9551_id);\n\nstatic struct i2c_driver mma9551_driver = {\n\t.driver = {\n\t\t   .name = MMA9551_DRV_NAME,\n\t\t   .acpi_match_table = ACPI_PTR(mma9551_acpi_match),\n\t\t   .pm = pm_ptr(&mma9551_pm_ops),\n\t\t   },\n\t.probe = mma9551_probe,\n\t.remove = mma9551_remove,\n\t.id_table = mma9551_id,\n};\n\nmodule_i2c_driver(mma9551_driver);\n\nMODULE_AUTHOR(\"Irina Tirdea <irina.tirdea@intel.com>\");\nMODULE_AUTHOR(\"Vlad Dogaru <vlad.dogaru@intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MMA9551L motion-sensing platform driver\");\nMODULE_IMPORT_NS(IIO_MMA9551);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}