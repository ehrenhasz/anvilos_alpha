{
  "module_name": "kxsd9.c",
  "hash_id": "3d8f8a3cd865a53d0c863a3370b46c9a155612d1f323b59de9f96578c8c60844",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/accel/kxsd9.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#include \"kxsd9.h\"\n\n#define KXSD9_REG_X\t\t0x00\n#define KXSD9_REG_Y\t\t0x02\n#define KXSD9_REG_Z\t\t0x04\n#define KXSD9_REG_AUX\t\t0x06\n#define KXSD9_REG_RESET\t\t0x0a\n#define KXSD9_REG_CTRL_C\t0x0c\n\n#define KXSD9_CTRL_C_FS_MASK\t0x03\n#define KXSD9_CTRL_C_FS_8G\t0x00\n#define KXSD9_CTRL_C_FS_6G\t0x01\n#define KXSD9_CTRL_C_FS_4G\t0x02\n#define KXSD9_CTRL_C_FS_2G\t0x03\n#define KXSD9_CTRL_C_MOT_LAT\tBIT(3)\n#define KXSD9_CTRL_C_MOT_LEV\tBIT(4)\n#define KXSD9_CTRL_C_LP_MASK\t0xe0\n#define KXSD9_CTRL_C_LP_NONE\t0x00\n#define KXSD9_CTRL_C_LP_2000HZC\tBIT(5)\n#define KXSD9_CTRL_C_LP_2000HZB\tBIT(6)\n#define KXSD9_CTRL_C_LP_2000HZA\t(BIT(5)|BIT(6))\n#define KXSD9_CTRL_C_LP_1000HZ\tBIT(7)\n#define KXSD9_CTRL_C_LP_500HZ\t(BIT(7)|BIT(5))\n#define KXSD9_CTRL_C_LP_100HZ\t(BIT(7)|BIT(6))\n#define KXSD9_CTRL_C_LP_50HZ\t(BIT(7)|BIT(6)|BIT(5))\n\n#define KXSD9_REG_CTRL_B\t0x0d\n\n#define KXSD9_CTRL_B_CLK_HLD\tBIT(7)\n#define KXSD9_CTRL_B_ENABLE\tBIT(6)\n#define KXSD9_CTRL_B_ST\t\tBIT(5)  \n\n#define KXSD9_REG_CTRL_A\t0x0e\n\n \nstruct kxsd9_state {\n\tstruct device *dev;\n\tstruct regmap *map;\n\tstruct iio_mount_matrix orientation;\n\tstruct regulator_bulk_data regs[2];\n\tu8 scale;\n};\n\n#define KXSD9_SCALE_2G \"0.011978\"\n#define KXSD9_SCALE_4G \"0.023927\"\n#define KXSD9_SCALE_6G \"0.035934\"\n#define KXSD9_SCALE_8G \"0.047853\"\n\n \nstatic const int kxsd9_micro_scales[4] = { 47853, 35934, 23927, 11978 };\n\n#define KXSD9_ZERO_G_OFFSET -2048\n\n \nstatic const char kxsd9_reg_vdd[] = \"vdd\";\nstatic const char kxsd9_reg_iovdd[] = \"iovdd\";\n\nstatic int kxsd9_write_scale(struct iio_dev *indio_dev, int micro)\n{\n\tint ret, i;\n\tstruct kxsd9_state *st = iio_priv(indio_dev);\n\tbool foundit = false;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (micro == kxsd9_micro_scales[i]) {\n\t\t\tfoundit = true;\n\t\t\tbreak;\n\t\t}\n\tif (!foundit)\n\t\treturn -EINVAL;\n\n\tret = regmap_update_bits(st->map,\n\t\t\t\t KXSD9_REG_CTRL_C,\n\t\t\t\t KXSD9_CTRL_C_FS_MASK,\n\t\t\t\t i);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\n\t \n\tst->scale = i;\n\nerror_ret:\n\treturn ret;\n}\n\nstatic IIO_CONST_ATTR(accel_scale_available,\n\t\tKXSD9_SCALE_2G \" \"\n\t\tKXSD9_SCALE_4G \" \"\n\t\tKXSD9_SCALE_6G \" \"\n\t\tKXSD9_SCALE_8G);\n\nstatic struct attribute *kxsd9_attributes[] = {\n\t&iio_const_attr_accel_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic int kxsd9_write_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int val,\n\t\t\t   int val2,\n\t\t\t   long mask)\n{\n\tint ret = -EINVAL;\n\tstruct kxsd9_state *st = iio_priv(indio_dev);\n\n\tpm_runtime_get_sync(st->dev);\n\n\tif (mask == IIO_CHAN_INFO_SCALE) {\n\t\t \n\t\tif (val)\n\t\t\treturn -EINVAL;\n\t\tret = kxsd9_write_scale(indio_dev, val2);\n\t}\n\n\tpm_runtime_mark_last_busy(st->dev);\n\tpm_runtime_put_autosuspend(st->dev);\n\n\treturn ret;\n}\n\nstatic int kxsd9_read_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t  int *val, int *val2, long mask)\n{\n\tint ret = -EINVAL;\n\tstruct kxsd9_state *st = iio_priv(indio_dev);\n\tunsigned int regval;\n\t__be16 raw_val;\n\tu16 nval;\n\n\tpm_runtime_get_sync(st->dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = regmap_bulk_read(st->map, chan->address, &raw_val,\n\t\t\t\t       sizeof(raw_val));\n\t\tif (ret)\n\t\t\tgoto error_ret;\n\t\tnval = be16_to_cpu(raw_val);\n\t\t \n\t\tnval >>= 4;\n\t\t*val = nval;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\t*val = KXSD9_ZERO_G_OFFSET;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = regmap_read(st->map,\n\t\t\t\t  KXSD9_REG_CTRL_C,\n\t\t\t\t  &regval);\n\t\tif (ret < 0)\n\t\t\tgoto error_ret;\n\t\t*val = 0;\n\t\t*val2 = kxsd9_micro_scales[regval & KXSD9_CTRL_C_FS_MASK];\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\t}\n\nerror_ret:\n\tpm_runtime_mark_last_busy(st->dev);\n\tpm_runtime_put_autosuspend(st->dev);\n\n\treturn ret;\n};\n\nstatic irqreturn_t kxsd9_trigger_handler(int irq, void *p)\n{\n\tconst struct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct kxsd9_state *st = iio_priv(indio_dev);\n\t \n\tstruct {\n\t\t__be16 chan[4];\n\t\ts64 ts __aligned(8);\n\t} hw_values;\n\tint ret;\n\n\tret = regmap_bulk_read(st->map,\n\t\t\t       KXSD9_REG_X,\n\t\t\t       hw_values.chan,\n\t\t\t       sizeof(hw_values.chan));\n\tif (ret) {\n\t\tdev_err(st->dev, \"error reading data: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev,\n\t\t\t\t\t   &hw_values,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\nout:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int kxsd9_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct kxsd9_state *st = iio_priv(indio_dev);\n\n\tpm_runtime_get_sync(st->dev);\n\n\treturn 0;\n}\n\nstatic int kxsd9_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct kxsd9_state *st = iio_priv(indio_dev);\n\n\tpm_runtime_mark_last_busy(st->dev);\n\tpm_runtime_put_autosuspend(st->dev);\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops kxsd9_buffer_setup_ops = {\n\t.preenable = kxsd9_buffer_preenable,\n\t.postdisable = kxsd9_buffer_postdisable,\n};\n\nstatic const struct iio_mount_matrix *\nkxsd9_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t       const struct iio_chan_spec *chan)\n{\n\tstruct kxsd9_state *st = iio_priv(indio_dev);\n\n\treturn &st->orientation;\n}\n\nstatic const struct iio_chan_spec_ext_info kxsd9_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_TYPE, kxsd9_get_mount_matrix),\n\t{ },\n};\n\n#define KXSD9_ACCEL_CHAN(axis, index)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_ACCEL,\t\t\t\t\t\\\n\t\t.modified = 1,\t\t\t\t\t\t\\\n\t\t.channel2 = IIO_MOD_##axis,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\t\\\n\t\t.ext_info = kxsd9_ext_info,\t\t\t\t\\\n\t\t.address = KXSD9_REG_##axis,\t\t\t\t\\\n\t\t.scan_index = index,\t\t\t\t\t\\\n\t\t.scan_type = {                                          \\\n\t\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t\t.realbits = 12,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.shift = 4,\t\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec kxsd9_channels[] = {\n\tKXSD9_ACCEL_CHAN(X, 0),\n\tKXSD9_ACCEL_CHAN(Y, 1),\n\tKXSD9_ACCEL_CHAN(Z, 2),\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.indexed = 1,\n\t\t.address = KXSD9_REG_AUX,\n\t\t.scan_index = 3,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 12,\n\t\t\t.storagebits = 16,\n\t\t\t.shift = 4,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic const struct attribute_group kxsd9_attribute_group = {\n\t.attrs = kxsd9_attributes,\n};\n\nstatic int kxsd9_power_up(struct kxsd9_state *st)\n{\n\tint ret;\n\n\t \n\tret = regulator_bulk_enable(ARRAY_SIZE(st->regs), st->regs);\n\tif (ret) {\n\t\tdev_err(st->dev, \"Cannot enable regulators\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write(st->map,\n\t\t\t   KXSD9_REG_CTRL_B,\n\t\t\t   KXSD9_CTRL_B_ENABLE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(st->map,\n\t\t\t   KXSD9_REG_CTRL_C,\n\t\t\t   KXSD9_CTRL_C_LP_1000HZ |\n\t\t\t   KXSD9_CTRL_C_MOT_LEV\t|\n\t\t\t   KXSD9_CTRL_C_MOT_LAT |\n\t\t\t   st->scale);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(20);\n\n\treturn 0;\n};\n\nstatic int kxsd9_power_down(struct kxsd9_state *st)\n{\n\tint ret;\n\n\t \n\tret = regmap_update_bits(st->map,\n\t\t\t\t KXSD9_REG_CTRL_B,\n\t\t\t\t KXSD9_CTRL_B_ENABLE,\n\t\t\t\t 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regulator_bulk_disable(ARRAY_SIZE(st->regs), st->regs);\n\tif (ret) {\n\t\tdev_err(st->dev, \"Cannot disable regulators\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iio_info kxsd9_info = {\n\t.read_raw = &kxsd9_read_raw,\n\t.write_raw = &kxsd9_write_raw,\n\t.attrs = &kxsd9_attribute_group,\n};\n\n \nstatic const unsigned long kxsd9_scan_masks[] = { 0xf, 0 };\n\nint kxsd9_common_probe(struct device *dev,\n\t\t       struct regmap *map,\n\t\t       const char *name)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct kxsd9_state *st;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tst->dev = dev;\n\tst->map = map;\n\n\tindio_dev->channels = kxsd9_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(kxsd9_channels);\n\tindio_dev->name = name;\n\tindio_dev->info = &kxsd9_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->available_scan_masks = kxsd9_scan_masks;\n\n\t \n\tret = iio_read_mount_matrix(dev, &st->orientation);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tst->regs[0].supply = kxsd9_reg_vdd;\n\tst->regs[1].supply = kxsd9_reg_iovdd;\n\tret = devm_regulator_bulk_get(dev,\n\t\t\t\t      ARRAY_SIZE(st->regs),\n\t\t\t\t      st->regs);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot get regulators\\n\");\n\t\treturn ret;\n\t}\n\t \n\tst->scale = KXSD9_CTRL_C_FS_2G;\n\n\tkxsd9_power_up(st);\n\n\tret = iio_triggered_buffer_setup(indio_dev,\n\t\t\t\t\t iio_pollfunc_store_time,\n\t\t\t\t\t kxsd9_trigger_handler,\n\t\t\t\t\t &kxsd9_buffer_setup_ops);\n\tif (ret) {\n\t\tdev_err(dev, \"triggered buffer setup failed\\n\");\n\t\tgoto err_power_down;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto err_cleanup_buffer;\n\n\tdev_set_drvdata(dev, indio_dev);\n\n\t \n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 2000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_put(dev);\n\n\treturn 0;\n\nerr_cleanup_buffer:\n\tiio_triggered_buffer_cleanup(indio_dev);\nerr_power_down:\n\tkxsd9_power_down(st);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS(kxsd9_common_probe, IIO_KXSD9);\n\nvoid kxsd9_common_remove(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct kxsd9_state *st = iio_priv(indio_dev);\n\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tiio_device_unregister(indio_dev);\n\tpm_runtime_get_sync(dev);\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_disable(dev);\n\tkxsd9_power_down(st);\n}\nEXPORT_SYMBOL_NS(kxsd9_common_remove, IIO_KXSD9);\n\nstatic int kxsd9_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct kxsd9_state *st = iio_priv(indio_dev);\n\n\treturn kxsd9_power_down(st);\n}\n\nstatic int kxsd9_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct kxsd9_state *st = iio_priv(indio_dev);\n\n\treturn kxsd9_power_up(st);\n}\n\nEXPORT_NS_RUNTIME_DEV_PM_OPS(kxsd9_dev_pm_ops, kxsd9_runtime_suspend,\n\t\t\t     kxsd9_runtime_resume, NULL, IIO_KXSD9);\n\nMODULE_AUTHOR(\"Jonathan Cameron <jic23@kernel.org>\");\nMODULE_DESCRIPTION(\"Kionix KXSD9 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}