{
  "module_name": "industrialio-sw-trigger.c",
  "hash_id": "b4e83c643302ff9149eda53248f17a74f387bbc518a500c46dad4883f666e8bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/industrialio-sw-trigger.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <linux/iio/sw_trigger.h>\n#include <linux/iio/configfs.h>\n#include <linux/configfs.h>\n\nstatic struct config_group *iio_triggers_group;\nstatic const struct config_item_type iio_trigger_type_group_type;\n\nstatic const struct config_item_type iio_triggers_group_type = {\n\t.ct_owner = THIS_MODULE,\n};\n\nstatic LIST_HEAD(iio_trigger_types_list);\nstatic DEFINE_MUTEX(iio_trigger_types_lock);\n\nstatic\nstruct iio_sw_trigger_type *__iio_find_sw_trigger_type(const char *name,\n\t\t\t\t\t\t       unsigned int len)\n{\n\tstruct iio_sw_trigger_type *t = NULL, *iter;\n\n\tlist_for_each_entry(iter, &iio_trigger_types_list, list)\n\t\tif (!strcmp(iter->name, name)) {\n\t\t\tt = iter;\n\t\t\tbreak;\n\t\t}\n\n\treturn t;\n}\n\nint iio_register_sw_trigger_type(struct iio_sw_trigger_type *t)\n{\n\tstruct iio_sw_trigger_type *iter;\n\tint ret = 0;\n\n\tmutex_lock(&iio_trigger_types_lock);\n\titer = __iio_find_sw_trigger_type(t->name, strlen(t->name));\n\tif (iter)\n\t\tret = -EBUSY;\n\telse\n\t\tlist_add_tail(&t->list, &iio_trigger_types_list);\n\tmutex_unlock(&iio_trigger_types_lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\tt->group = configfs_register_default_group(iio_triggers_group, t->name,\n\t\t\t\t\t\t&iio_trigger_type_group_type);\n\tif (IS_ERR(t->group)) {\n\t\tmutex_lock(&iio_trigger_types_lock);\n\t\tlist_del(&t->list);\n\t\tmutex_unlock(&iio_trigger_types_lock);\n\t\tret = PTR_ERR(t->group);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(iio_register_sw_trigger_type);\n\nvoid iio_unregister_sw_trigger_type(struct iio_sw_trigger_type *t)\n{\n\tstruct iio_sw_trigger_type *iter;\n\n\tmutex_lock(&iio_trigger_types_lock);\n\titer = __iio_find_sw_trigger_type(t->name, strlen(t->name));\n\tif (iter)\n\t\tlist_del(&t->list);\n\tmutex_unlock(&iio_trigger_types_lock);\n\n\tconfigfs_unregister_default_group(t->group);\n}\nEXPORT_SYMBOL(iio_unregister_sw_trigger_type);\n\nstatic\nstruct iio_sw_trigger_type *iio_get_sw_trigger_type(const char *name)\n{\n\tstruct iio_sw_trigger_type *t;\n\n\tmutex_lock(&iio_trigger_types_lock);\n\tt = __iio_find_sw_trigger_type(name, strlen(name));\n\tif (t && !try_module_get(t->owner))\n\t\tt = NULL;\n\tmutex_unlock(&iio_trigger_types_lock);\n\n\treturn t;\n}\n\nstruct iio_sw_trigger *iio_sw_trigger_create(const char *type, const char *name)\n{\n\tstruct iio_sw_trigger *t;\n\tstruct iio_sw_trigger_type *tt;\n\n\ttt = iio_get_sw_trigger_type(type);\n\tif (!tt) {\n\t\tpr_err(\"Invalid trigger type: %s\\n\", type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tt = tt->ops->probe(name);\n\tif (IS_ERR(t))\n\t\tgoto out_module_put;\n\n\tt->trigger_type = tt;\n\n\treturn t;\nout_module_put:\n\tmodule_put(tt->owner);\n\treturn t;\n}\nEXPORT_SYMBOL(iio_sw_trigger_create);\n\nvoid iio_sw_trigger_destroy(struct iio_sw_trigger *t)\n{\n\tstruct iio_sw_trigger_type *tt = t->trigger_type;\n\n\ttt->ops->remove(t);\n\tmodule_put(tt->owner);\n}\nEXPORT_SYMBOL(iio_sw_trigger_destroy);\n\nstatic struct config_group *trigger_make_group(struct config_group *group,\n\t\t\t\t\t       const char *name)\n{\n\tstruct iio_sw_trigger *t;\n\n\tt = iio_sw_trigger_create(group->cg_item.ci_name, name);\n\tif (IS_ERR(t))\n\t\treturn ERR_CAST(t);\n\n\tconfig_item_set_name(&t->group.cg_item, \"%s\", name);\n\n\treturn &t->group;\n}\n\nstatic void trigger_drop_group(struct config_group *group,\n\t\t\t       struct config_item *item)\n{\n\tstruct iio_sw_trigger *t = to_iio_sw_trigger(item);\n\n\tiio_sw_trigger_destroy(t);\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations trigger_ops = {\n\t.make_group\t= &trigger_make_group,\n\t.drop_item\t= &trigger_drop_group,\n};\n\nstatic const struct config_item_type iio_trigger_type_group_type = {\n\t.ct_group_ops = &trigger_ops,\n\t.ct_owner       = THIS_MODULE,\n};\n\nstatic int __init iio_sw_trigger_init(void)\n{\n\tiio_triggers_group =\n\t\tconfigfs_register_default_group(&iio_configfs_subsys.su_group,\n\t\t\t\t\t\t\"triggers\",\n\t\t\t\t\t\t&iio_triggers_group_type);\n\treturn PTR_ERR_OR_ZERO(iio_triggers_group);\n}\nmodule_init(iio_sw_trigger_init);\n\nstatic void __exit iio_sw_trigger_exit(void)\n{\n\tconfigfs_unregister_default_group(iio_triggers_group);\n}\nmodule_exit(iio_sw_trigger_exit);\n\nMODULE_AUTHOR(\"Daniel Baluta <daniel.baluta@intel.com>\");\nMODULE_DESCRIPTION(\"Industrial I/O software triggers support\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}