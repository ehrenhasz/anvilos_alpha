{
  "module_name": "srf04.c",
  "hash_id": "6f3a80f432ac7f11468c8e15a5169a1ab8406ed26a8b37e8c69a400e4b8a088b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/proximity/srf04.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\nstruct srf04_cfg {\n\tunsigned long trigger_pulse_us;\n};\n\nstruct srf04_data {\n\tstruct device\t\t*dev;\n\tstruct gpio_desc\t*gpiod_trig;\n\tstruct gpio_desc\t*gpiod_echo;\n\tstruct gpio_desc\t*gpiod_power;\n\tstruct mutex\t\tlock;\n\tint\t\t\tirqnr;\n\tktime_t\t\t\tts_rising;\n\tktime_t\t\t\tts_falling;\n\tstruct completion\trising;\n\tstruct completion\tfalling;\n\tconst struct srf04_cfg\t*cfg;\n\tint\t\t\tstartup_time_ms;\n};\n\nstatic const struct srf04_cfg srf04_cfg = {\n\t.trigger_pulse_us = 10,\n};\n\nstatic const struct srf04_cfg mb_lv_cfg = {\n\t.trigger_pulse_us = 20,\n};\n\nstatic irqreturn_t srf04_handle_irq(int irq, void *dev_id)\n{\n\tstruct iio_dev *indio_dev = dev_id;\n\tstruct srf04_data *data = iio_priv(indio_dev);\n\tktime_t now = ktime_get();\n\n\tif (gpiod_get_value(data->gpiod_echo)) {\n\t\tdata->ts_rising = now;\n\t\tcomplete(&data->rising);\n\t} else {\n\t\tdata->ts_falling = now;\n\t\tcomplete(&data->falling);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int srf04_read(struct srf04_data *data)\n{\n\tint ret;\n\tktime_t ktime_dt;\n\tu64 dt_ns;\n\tu32 time_ns, distance_mm;\n\n\tif (data->gpiod_power) {\n\t\tret = pm_runtime_resume_and_get(data->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\t \n\tmutex_lock(&data->lock);\n\n\treinit_completion(&data->rising);\n\treinit_completion(&data->falling);\n\n\tgpiod_set_value(data->gpiod_trig, 1);\n\tudelay(data->cfg->trigger_pulse_us);\n\tgpiod_set_value(data->gpiod_trig, 0);\n\n\tif (data->gpiod_power) {\n\t\tpm_runtime_mark_last_busy(data->dev);\n\t\tpm_runtime_put_autosuspend(data->dev);\n\t}\n\n\t \n\tret = wait_for_completion_killable_timeout(&data->rising, HZ/50);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t} else if (ret == 0) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tret = wait_for_completion_killable_timeout(&data->falling, HZ/20);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t} else if (ret == 0) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tktime_dt = ktime_sub(data->ts_falling, data->ts_rising);\n\n\tmutex_unlock(&data->lock);\n\n\tdt_ns = ktime_to_ns(ktime_dt);\n\t \n\tif (dt_ns > 40438871)\n\t\treturn -EIO;\n\n\ttime_ns = dt_ns;\n\n\t \n\tdistance_mm = time_ns * 106 / 617176;\n\n\treturn distance_mm;\n}\n\nstatic int srf04_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *channel, int *val,\n\t\t\t    int *val2, long info)\n{\n\tstruct srf04_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (channel->type != IIO_DISTANCE)\n\t\treturn -EINVAL;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = srf04_read(data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*val = 0;\n\t\t*val2 = 1000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info srf04_iio_info = {\n\t.read_raw\t\t= srf04_read_raw,\n};\n\nstatic const struct iio_chan_spec srf04_chan_spec[] = {\n\t{\n\t\t.type = IIO_DISTANCE,\n\t\t.info_mask_separate =\n\t\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t},\n};\n\nstatic const struct of_device_id of_srf04_match[] = {\n\t{ .compatible = \"devantech,srf04\", .data = &srf04_cfg },\n\t{ .compatible = \"maxbotix,mb1000\", .data = &mb_lv_cfg },\n\t{ .compatible = \"maxbotix,mb1010\", .data = &mb_lv_cfg },\n\t{ .compatible = \"maxbotix,mb1020\", .data = &mb_lv_cfg },\n\t{ .compatible = \"maxbotix,mb1030\", .data = &mb_lv_cfg },\n\t{ .compatible = \"maxbotix,mb1040\", .data = &mb_lv_cfg },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, of_srf04_match);\n\nstatic int srf04_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct srf04_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(struct srf04_data));\n\tif (!indio_dev) {\n\t\tdev_err(dev, \"failed to allocate IIO device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = iio_priv(indio_dev);\n\tdata->dev = dev;\n\tdata->cfg = device_get_match_data(dev);\n\n\tmutex_init(&data->lock);\n\tinit_completion(&data->rising);\n\tinit_completion(&data->falling);\n\n\tdata->gpiod_trig = devm_gpiod_get(dev, \"trig\", GPIOD_OUT_LOW);\n\tif (IS_ERR(data->gpiod_trig)) {\n\t\tdev_err(dev, \"failed to get trig-gpios: err=%ld\\n\",\n\t\t\t\t\tPTR_ERR(data->gpiod_trig));\n\t\treturn PTR_ERR(data->gpiod_trig);\n\t}\n\n\tdata->gpiod_echo = devm_gpiod_get(dev, \"echo\", GPIOD_IN);\n\tif (IS_ERR(data->gpiod_echo)) {\n\t\tdev_err(dev, \"failed to get echo-gpios: err=%ld\\n\",\n\t\t\t\t\tPTR_ERR(data->gpiod_echo));\n\t\treturn PTR_ERR(data->gpiod_echo);\n\t}\n\n\tdata->gpiod_power = devm_gpiod_get_optional(dev, \"power\",\n\t\t\t\t\t\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(data->gpiod_power)) {\n\t\tdev_err(dev, \"failed to get power-gpios: err=%ld\\n\",\n\t\t\t\t\t\tPTR_ERR(data->gpiod_power));\n\t\treturn PTR_ERR(data->gpiod_power);\n\t}\n\tif (data->gpiod_power) {\n\t\tdata->startup_time_ms = 100;\n\t\tdevice_property_read_u32(dev, \"startup-time-ms\", &data->startup_time_ms);\n\t\tdev_dbg(dev, \"using power gpio: startup-time-ms=%d\\n\",\n\t\t\t\t\t\t\tdata->startup_time_ms);\n\t}\n\n\tif (gpiod_cansleep(data->gpiod_echo)) {\n\t\tdev_err(data->dev, \"cansleep-GPIOs not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata->irqnr = gpiod_to_irq(data->gpiod_echo);\n\tif (data->irqnr < 0) {\n\t\tdev_err(data->dev, \"gpiod_to_irq: %d\\n\", data->irqnr);\n\t\treturn data->irqnr;\n\t}\n\n\tret = devm_request_irq(dev, data->irqnr, srf04_handle_irq,\n\t\t\tIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\t\t\tpdev->name, indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"request_irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tindio_dev->name = \"srf04\";\n\tindio_dev->info = &srf04_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = srf04_chan_spec;\n\tindio_dev->num_channels = ARRAY_SIZE(srf04_chan_spec);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"iio_device_register: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (data->gpiod_power) {\n\t\tpm_runtime_set_autosuspend_delay(data->dev, 1000);\n\t\tpm_runtime_use_autosuspend(data->dev);\n\n\t\tret = pm_runtime_set_active(data->dev);\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"pm_runtime_set_active: %d\\n\", ret);\n\t\t\tiio_device_unregister(indio_dev);\n\t\t}\n\n\t\tpm_runtime_enable(data->dev);\n\t\tpm_runtime_idle(data->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int srf04_remove(struct platform_device *pdev)\n{\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct srf04_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tif (data->gpiod_power) {\n\t\tpm_runtime_disable(data->dev);\n\t\tpm_runtime_set_suspended(data->dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int  srf04_pm_runtime_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = container_of(dev,\n\t\t\t\t\t\tstruct platform_device, dev);\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct srf04_data *data = iio_priv(indio_dev);\n\n\tgpiod_set_value(data->gpiod_power, 0);\n\n\treturn 0;\n}\n\nstatic int srf04_pm_runtime_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = container_of(dev,\n\t\t\t\t\t\tstruct platform_device, dev);\n\tstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\n\tstruct srf04_data *data = iio_priv(indio_dev);\n\n\tgpiod_set_value(data->gpiod_power, 1);\n\tmsleep(data->startup_time_ms);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops srf04_pm_ops = {\n\tRUNTIME_PM_OPS(srf04_pm_runtime_suspend,\n\t\t       srf04_pm_runtime_resume, NULL)\n};\n\nstatic struct platform_driver srf04_driver = {\n\t.probe\t\t= srf04_probe,\n\t.remove\t\t= srf04_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"srf04-gpio\",\n\t\t.of_match_table\t= of_srf04_match,\n\t\t.pm\t\t= pm_ptr(&srf04_pm_ops),\n\t},\n};\n\nmodule_platform_driver(srf04_driver);\n\nMODULE_AUTHOR(\"Andreas Klinger <ak@it-klinger.de>\");\nMODULE_DESCRIPTION(\"SRF04 ultrasonic sensor for distance measuring using GPIOs\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:srf04\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}