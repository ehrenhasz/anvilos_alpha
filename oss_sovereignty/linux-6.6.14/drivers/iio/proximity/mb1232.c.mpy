{
  "module_name": "mb1232.c",
  "hash_id": "8f225653fb056e646e5ffcc8c5f25cb7b0728acd3685a4a7eb8eaa7eac522afe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/proximity/mb1232.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n \n#define MB1232_RANGE_COMMAND\t0x51\t \n#define MB1232_ADDR_UNLOCK_1\t0xAA\t \n#define MB1232_ADDR_UNLOCK_2\t0xA5\t \n\nstruct mb1232_data {\n\tstruct i2c_client\t*client;\n\n\tstruct mutex\t\tlock;\n\n\t \n\tstruct completion\tranging;\n\tint\t\t\tirqnr;\n\t \n\tstruct {\n\t\ts16 distance;\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\nstatic irqreturn_t mb1232_handle_irq(int irq, void *dev_id)\n{\n\tstruct iio_dev *indio_dev = dev_id;\n\tstruct mb1232_data *data = iio_priv(indio_dev);\n\n\tcomplete(&data->ranging);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic s16 mb1232_read_distance(struct mb1232_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\ts16 distance;\n\t__be16 buf;\n\n\tmutex_lock(&data->lock);\n\n\treinit_completion(&data->ranging);\n\n\tret = i2c_smbus_write_byte(client, MB1232_RANGE_COMMAND);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"write command - err: %d\\n\", ret);\n\t\tgoto error_unlock;\n\t}\n\n\tif (data->irqnr > 0) {\n\t\t \n\t\tret = wait_for_completion_killable_timeout(&data->ranging,\n\t\t\t\t\t\t\t\t\tHZ/10);\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock;\n\t\telse if (ret == 0) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto error_unlock;\n\t\t}\n\t} else {\n\t\t \n\t\tmsleep(15);\n\t}\n\n\tret = i2c_master_recv(client, (char *)&buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"i2c_master_recv: ret=%d\\n\", ret);\n\t\tgoto error_unlock;\n\t}\n\n\tdistance = __be16_to_cpu(buf);\n\t \n\tif (distance < 0) {\n\t\tdev_err(&client->dev, \"distance=%d\\n\", distance);\n\t\tret = -EINVAL;\n\t\tgoto error_unlock;\n\t}\n\n\tmutex_unlock(&data->lock);\n\n\treturn distance;\n\nerror_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t mb1232_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct mb1232_data *data = iio_priv(indio_dev);\n\n\tdata->scan.distance = mb1232_read_distance(data);\n\tif (data->scan.distance < 0)\n\t\tgoto err;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t   pf->timestamp);\n\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\nstatic int mb1232_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *channel, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct mb1232_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (channel->type != IIO_DISTANCE)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = mb1232_read_distance(data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*val = 0;\n\t\t*val2 = 10000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_chan_spec mb1232_channels[] = {\n\t{\n\t\t.type = IIO_DISTANCE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n};\n\nstatic const struct iio_info mb1232_info = {\n\t.read_raw = mb1232_read_raw,\n};\n\nstatic int mb1232_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct iio_dev *indio_dev;\n\tstruct mb1232_data *data;\n\tint ret;\n\tstruct device *dev = &client->dev;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t\tI2C_FUNC_SMBUS_READ_BYTE |\n\t\t\t\t\tI2C_FUNC_SMBUS_WRITE_BYTE))\n\t\treturn -ENODEV;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tindio_dev->info = &mb1232_info;\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = mb1232_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mb1232_channels);\n\n\tmutex_init(&data->lock);\n\n\tinit_completion(&data->ranging);\n\n\tdata->irqnr = fwnode_irq_get(dev_fwnode(&client->dev), 0);\n\tif (data->irqnr > 0) {\n\t\tret = devm_request_irq(dev, data->irqnr, mb1232_handle_irq,\n\t\t\t\tIRQF_TRIGGER_FALLING, id->name, indio_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"request_irq: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev,\n\t\t\tiio_pollfunc_store_time, mb1232_trigger_handler, NULL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"setup of iio triggered buffer failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id of_mb1232_match[] = {\n\t{ .compatible = \"maxbotix,mb1202\", },\n\t{ .compatible = \"maxbotix,mb1212\", },\n\t{ .compatible = \"maxbotix,mb1222\", },\n\t{ .compatible = \"maxbotix,mb1232\", },\n\t{ .compatible = \"maxbotix,mb1242\", },\n\t{ .compatible = \"maxbotix,mb7040\", },\n\t{ .compatible = \"maxbotix,mb7137\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, of_mb1232_match);\n\nstatic const struct i2c_device_id mb1232_id[] = {\n\t{ \"maxbotix-mb1202\", },\n\t{ \"maxbotix-mb1212\", },\n\t{ \"maxbotix-mb1222\", },\n\t{ \"maxbotix-mb1232\", },\n\t{ \"maxbotix-mb1242\", },\n\t{ \"maxbotix-mb7040\", },\n\t{ \"maxbotix-mb7137\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mb1232_id);\n\nstatic struct i2c_driver mb1232_driver = {\n\t.driver = {\n\t\t.name\t= \"maxbotix-mb1232\",\n\t\t.of_match_table\t= of_mb1232_match,\n\t},\n\t.probe = mb1232_probe,\n\t.id_table = mb1232_id,\n};\nmodule_i2c_driver(mb1232_driver);\n\nMODULE_AUTHOR(\"Andreas Klinger <ak@it-klinger.de>\");\nMODULE_DESCRIPTION(\"Maxbotix I2CXL-MaxSonar i2c ultrasonic ranger driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}