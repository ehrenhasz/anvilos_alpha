{
  "module_name": "vcnl3020.c",
  "hash_id": "11b823c711ead1310ac1476d971150e7ed0b935153f39ce2db95f4680eb1f48a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/proximity/vcnl3020.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/regmap.h>\n#include <linux/interrupt.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/events.h>\n\n#define VCNL3020_PROD_ID\t0x21\n\n#define VCNL_COMMAND\t\t0x80  \n#define VCNL_PROD_REV\t\t0x81  \n#define VCNL_PROXIMITY_RATE\t0x82  \n#define VCNL_LED_CURRENT\t0x83  \n#define VCNL_PS_RESULT_HI\t0x87  \n#define VCNL_PS_RESULT_LO\t0x88  \n#define VCNL_PS_ICR\t\t0x89  \n#define VCNL_PS_LO_THR_HI\t0x8a  \n#define VCNL_PS_LO_THR_LO\t0x8b  \n#define VCNL_PS_HI_THR_HI\t0x8c  \n#define VCNL_PS_HI_THR_LO\t0x8d  \n#define VCNL_ISR\t\t0x8e  \n#define VCNL_PS_MOD_ADJ\t\t0x8f  \n\n \n#define VCNL_PS_RDY\t\tBIT(5)  \n#define VCNL_PS_OD\t\tBIT(3)  \n\n \n#define VCNL_PS_EN\t\tBIT(1)\n\n \n#define VCNL_PS_SELFTIMED_EN\tBIT(0)\n\n \n\n \n#define  VCNL_ICR_THRES_EN\tBIT(1)\n\n \n#define VCNL_INT_TH_HI\t\tBIT(0)\t \n#define VCNL_INT_TH_LOW\t\tBIT(1)\t \n\n#define VCNL_ON_DEMAND_TIMEOUT_US\t100000\n#define VCNL_POLL_US\t\t\t20000\n\nstatic const int vcnl3020_prox_sampling_frequency[][2] = {\n\t{1, 950000},\n\t{3, 906250},\n\t{7, 812500},\n\t{16, 625000},\n\t{31, 250000},\n\t{62, 500000},\n\t{125, 0},\n\t{250, 0},\n};\n\n \nstruct vcnl3020_data {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tu8 rev;\n\tstruct mutex lock;\n\t__be16 buf;\n};\n\n \nstruct vcnl3020_property {\n\tconst char *name;\n\tu32 reg;\n\tu32 (*conversion_func)(u32 *val);\n};\n\nstatic u32 microamp_to_reg(u32 *val)\n{\n\t \n\treturn *val /= 10000;\n};\n\nstatic struct vcnl3020_property vcnl3020_led_current_property = {\n\t.name = \"vishay,led-current-microamp\",\n\t.reg = VCNL_LED_CURRENT,\n\t.conversion_func = microamp_to_reg,\n};\n\nstatic int vcnl3020_get_and_apply_property(struct vcnl3020_data *data,\n\t\t\t\t\t   struct vcnl3020_property prop)\n{\n\tint rc;\n\tu32 val;\n\n\trc = device_property_read_u32(data->dev, prop.name, &val);\n\tif (rc)\n\t\treturn 0;\n\n\tif (prop.conversion_func)\n\t\tprop.conversion_func(&val);\n\n\trc = regmap_write(data->regmap, prop.reg, val);\n\tif (rc) {\n\t\tdev_err(data->dev, \"Error (%d) setting property (%s)\\n\",\n\t\t\trc, prop.name);\n\t}\n\n\treturn rc;\n}\n\nstatic int vcnl3020_init(struct vcnl3020_data *data)\n{\n\tint rc;\n\tunsigned int reg;\n\n\trc = regmap_read(data->regmap, VCNL_PROD_REV, &reg);\n\tif (rc) {\n\t\tdev_err(data->dev,\n\t\t\t\"Error (%d) reading product revision\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (reg != VCNL3020_PROD_ID) {\n\t\tdev_err(data->dev,\n\t\t\t\"Product id (%x) did not match vcnl3020 (%x)\\n\", reg,\n\t\t\tVCNL3020_PROD_ID);\n\t\treturn -ENODEV;\n\t}\n\n\tdata->rev = reg;\n\tmutex_init(&data->lock);\n\n\treturn vcnl3020_get_and_apply_property(data,\n\t\t\t\t\t       vcnl3020_led_current_property);\n};\n\nstatic bool vcnl3020_is_in_periodic_mode(struct vcnl3020_data *data)\n{\n\tint rc;\n\tunsigned int cmd;\n\n\trc = regmap_read(data->regmap, VCNL_COMMAND, &cmd);\n\tif (rc) {\n\t\tdev_err(data->dev,\n\t\t\t\"Error (%d) reading command register\\n\", rc);\n\t\treturn false;\n\t}\n\n\treturn !!(cmd & VCNL_PS_SELFTIMED_EN);\n}\n\nstatic int vcnl3020_measure_proximity(struct vcnl3020_data *data, int *val)\n{\n\tint rc;\n\tunsigned int reg;\n\n\tmutex_lock(&data->lock);\n\n\t \n\tif (vcnl3020_is_in_periodic_mode(data)) {\n\t\trc = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\trc = regmap_write(data->regmap, VCNL_COMMAND, VCNL_PS_OD);\n\tif (rc)\n\t\tgoto err_unlock;\n\n\t \n\trc = regmap_read_poll_timeout(data->regmap, VCNL_COMMAND, reg,\n\t\t\t\t      reg & VCNL_PS_RDY, VCNL_POLL_US,\n\t\t\t\t      VCNL_ON_DEMAND_TIMEOUT_US);\n\tif (rc) {\n\t\tdev_err(data->dev,\n\t\t\t\"Error (%d) reading vcnl3020 command register\\n\", rc);\n\t\tgoto err_unlock;\n\t}\n\n\t \n\trc = regmap_bulk_read(data->regmap, VCNL_PS_RESULT_HI, &data->buf,\n\t\t\t      sizeof(data->buf));\n\tif (rc)\n\t\tgoto err_unlock;\n\n\t*val = be16_to_cpu(data->buf);\n\nerr_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn rc;\n}\n\nstatic int vcnl3020_read_proxy_samp_freq(struct vcnl3020_data *data, int *val,\n\t\t\t\t\t int *val2)\n{\n\tint rc;\n\tunsigned int prox_rate;\n\n\trc = regmap_read(data->regmap, VCNL_PROXIMITY_RATE, &prox_rate);\n\tif (rc)\n\t\treturn rc;\n\n\tif (prox_rate >= ARRAY_SIZE(vcnl3020_prox_sampling_frequency))\n\t\treturn -EINVAL;\n\n\t*val = vcnl3020_prox_sampling_frequency[prox_rate][0];\n\t*val2 = vcnl3020_prox_sampling_frequency[prox_rate][1];\n\n\treturn 0;\n}\n\nstatic int vcnl3020_write_proxy_samp_freq(struct vcnl3020_data *data, int val,\n\t\t\t\t\t  int val2)\n{\n\tunsigned int i;\n\tint index = -1;\n\tint rc;\n\n\tmutex_lock(&data->lock);\n\n\t \n\tif (vcnl3020_is_in_periodic_mode(data)) {\n\t\trc = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(vcnl3020_prox_sampling_frequency); i++) {\n\t\tif (val == vcnl3020_prox_sampling_frequency[i][0] &&\n\t\t    val2 == vcnl3020_prox_sampling_frequency[i][1]) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (index < 0) {\n\t\trc = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\n\trc = regmap_write(data->regmap, VCNL_PROXIMITY_RATE, index);\n\tif (rc)\n\t\tdev_err(data->dev,\n\t\t\t\"Error (%d) writing proximity rate register\\n\", rc);\n\nerr_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn rc;\n}\n\nstatic bool vcnl3020_is_thr_enabled(struct vcnl3020_data *data)\n{\n\tint rc;\n\tunsigned int icr;\n\n\trc = regmap_read(data->regmap, VCNL_PS_ICR, &icr);\n\tif (rc) {\n\t\tdev_err(data->dev,\n\t\t\t\"Error (%d) reading ICR register\\n\", rc);\n\t\treturn false;\n\t}\n\n\treturn !!(icr & VCNL_ICR_THRES_EN);\n}\n\nstatic int vcnl3020_read_event(struct iio_dev *indio_dev,\n\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t       enum iio_event_type type,\n\t\t\t       enum iio_event_direction dir,\n\t\t\t       enum iio_event_info info,\n\t\t\t       int *val, int *val2)\n{\n\tint rc;\n\tstruct vcnl3020_data *data = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\trc = regmap_bulk_read(data->regmap, VCNL_PS_HI_THR_HI,\n\t\t\t\t\t      &data->buf, sizeof(data->buf));\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\t*val = be16_to_cpu(data->buf);\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\trc = regmap_bulk_read(data->regmap, VCNL_PS_LO_THR_HI,\n\t\t\t\t\t      &data->buf, sizeof(data->buf));\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\t*val = be16_to_cpu(data->buf);\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl3020_write_event(struct iio_dev *indio_dev,\n\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\tenum iio_event_type type,\n\t\t\t\tenum iio_event_direction dir,\n\t\t\t\tenum iio_event_info info,\n\t\t\t\tint val, int val2)\n{\n\tint rc;\n\tstruct vcnl3020_data *data = iio_priv(indio_dev);\n\n\tmutex_lock(&data->lock);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\t \n\t\t\tdata->buf = cpu_to_be16(val);\n\t\t\trc = regmap_bulk_write(data->regmap, VCNL_PS_HI_THR_HI,\n\t\t\t\t\t       &data->buf, sizeof(data->buf));\n\t\t\tif (rc < 0)\n\t\t\t\tgoto err_unlock;\n\t\t\trc = IIO_VAL_INT;\n\t\t\tgoto err_unlock;\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\tdata->buf = cpu_to_be16(val);\n\t\t\trc = regmap_bulk_write(data->regmap, VCNL_PS_LO_THR_HI,\n\t\t\t\t\t       &data->buf, sizeof(data->buf));\n\t\t\tif (rc < 0)\n\t\t\t\tgoto err_unlock;\n\t\t\trc = IIO_VAL_INT;\n\t\t\tgoto err_unlock;\n\t\tdefault:\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\tdefault:\n\t\trc = -EINVAL;\n\t\tgoto err_unlock;\n\t}\nerr_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn rc;\n}\n\nstatic int vcnl3020_enable_periodic(struct iio_dev *indio_dev,\n\t\t\t\t    struct vcnl3020_data *data)\n{\n\tint rc;\n\tint cmd;\n\n\tmutex_lock(&data->lock);\n\n\t \n\tcmd = VCNL_PS_EN | VCNL_PS_SELFTIMED_EN;\n\n\trc = regmap_write(data->regmap, VCNL_COMMAND, cmd);\n\tif (rc) {\n\t\tdev_err(data->dev,\n\t\t\t\"Error (%d) writing command register\\n\", rc);\n\t\tgoto err_unlock;\n\t}\n\n\t \n\trc = regmap_write(data->regmap, VCNL_PS_ICR, VCNL_ICR_THRES_EN);\n\tif (rc)\n\t\tdev_err(data->dev,\n\t\t\t\"Error (%d) reading ICR register\\n\", rc);\n\nerr_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn rc;\n}\n\nstatic int vcnl3020_disable_periodic(struct iio_dev *indio_dev,\n\t\t\t\t     struct vcnl3020_data *data)\n{\n\tint rc;\n\n\tmutex_lock(&data->lock);\n\n\trc = regmap_write(data->regmap, VCNL_COMMAND, 0);\n\tif (rc) {\n\t\tdev_err(data->dev,\n\t\t\t\"Error (%d) writing command register\\n\", rc);\n\t\tgoto err_unlock;\n\t}\n\n\trc = regmap_write(data->regmap, VCNL_PS_ICR, 0);\n\tif (rc) {\n\t\tdev_err(data->dev,\n\t\t\t\"Error (%d) writing ICR register\\n\", rc);\n\t\tgoto err_unlock;\n\t}\n\n\t \n\trc = regmap_write(data->regmap, VCNL_ISR, 0);\n\tif (rc)\n\t\tdev_err(data->dev,\n\t\t\t\"Error (%d) writing ISR register\\n\", rc);\n\nerr_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn rc;\n}\n\nstatic int vcnl3020_config_threshold(struct iio_dev *indio_dev, bool state)\n{\n\tstruct vcnl3020_data *data = iio_priv(indio_dev);\n\n\tif (state) {\n\t\treturn vcnl3020_enable_periodic(indio_dev, data);\n\t} else {\n\t\tif (!vcnl3020_is_thr_enabled(data))\n\t\t\treturn 0;\n\t\treturn vcnl3020_disable_periodic(indio_dev, data);\n\t}\n}\n\nstatic int vcnl3020_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t       enum iio_event_type type,\n\t\t\t\t       enum iio_event_direction dir,\n\t\t\t\t       int state)\n{\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\treturn vcnl3020_config_threshold(indio_dev, state);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl3020_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir)\n{\n\tstruct vcnl3020_data *data = iio_priv(indio_dev);\n\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\treturn vcnl3020_is_thr_enabled(data);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_event_spec vcnl3020_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t}, {\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec vcnl3020_channels[] = {\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_separate_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.event_spec = vcnl3020_event_spec,\n\t\t.num_event_specs = ARRAY_SIZE(vcnl3020_event_spec),\n\t},\n};\n\nstatic int vcnl3020_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int *val,\n\t\t\t     int *val2, long mask)\n{\n\tint rc;\n\tstruct vcnl3020_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\trc = vcnl3020_measure_proximity(data, val);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\trc = vcnl3020_read_proxy_samp_freq(data, val, val2);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl3020_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tstruct vcnl3020_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn vcnl3020_write_proxy_samp_freq(data, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vcnl3020_read_avail(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length,\n\t\t\t       long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*vals = (int *)vcnl3020_prox_sampling_frequency;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t*length = 2 * ARRAY_SIZE(vcnl3020_prox_sampling_frequency);\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info vcnl3020_info = {\n\t.read_raw = vcnl3020_read_raw,\n\t.write_raw = vcnl3020_write_raw,\n\t.read_avail = vcnl3020_read_avail,\n\t.read_event_value = vcnl3020_read_event,\n\t.write_event_value = vcnl3020_write_event,\n\t.read_event_config = vcnl3020_read_event_config,\n\t.write_event_config = vcnl3020_write_event_config,\n};\n\nstatic const struct regmap_config vcnl3020_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= VCNL_PS_MOD_ADJ,\n};\n\nstatic irqreturn_t vcnl3020_handle_irq_thread(int irq, void *p)\n{\n\tstruct iio_dev *indio_dev = p;\n\tstruct vcnl3020_data *data = iio_priv(indio_dev);\n\tunsigned int isr;\n\tint rc;\n\n\trc = regmap_read(data->regmap, VCNL_ISR, &isr);\n\tif (rc) {\n\t\tdev_err(data->dev, \"Error (%d) reading reg (0x%x)\\n\",\n\t\t\trc, VCNL_ISR);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (!(isr & VCNL_ICR_THRES_EN))\n\t\treturn IRQ_NONE;\n\n\tiio_push_event(indio_dev,\n\t\t       IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 1,\n\t\t\t\t            IIO_EV_TYPE_THRESH,\n\t\t\t\t            IIO_EV_DIR_RISING),\n\t\t       iio_get_time_ns(indio_dev));\n\n\trc = regmap_write(data->regmap, VCNL_ISR, isr & VCNL_ICR_THRES_EN);\n\tif (rc)\n\t\tdev_err(data->dev, \"Error (%d) writing in reg (0x%x)\\n\",\n\t\t\trc, VCNL_ISR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int vcnl3020_probe(struct i2c_client *client)\n{\n\tstruct vcnl3020_data *data;\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *regmap;\n\tint rc;\n\n\tregmap = devm_regmap_init_i2c(client, &vcnl3020_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"regmap_init failed\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->regmap = regmap;\n\tdata->dev = &client->dev;\n\n\trc = vcnl3020_init(data);\n\tif (rc)\n\t\treturn rc;\n\n\tindio_dev->info = &vcnl3020_info;\n\tindio_dev->channels = vcnl3020_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(vcnl3020_channels);\n\tindio_dev->name = \"vcnl3020\";\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tif (client->irq) {\n\t\trc = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t       NULL, vcnl3020_handle_irq_thread,\n\t\t\t\t\t       IRQF_ONESHOT, indio_dev->name,\n\t\t\t\t\t       indio_dev);\n\t\tif (rc) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Error (%d) irq request failed (%u)\\n\", rc,\n\t\t\t\tclient->irq);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct of_device_id vcnl3020_of_match[] = {\n\t{\n\t\t.compatible = \"vishay,vcnl3020\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, vcnl3020_of_match);\n\nstatic struct i2c_driver vcnl3020_driver = {\n\t.driver = {\n\t\t.name   = \"vcnl3020\",\n\t\t.of_match_table = vcnl3020_of_match,\n\t},\n\t.probe      = vcnl3020_probe,\n};\nmodule_i2c_driver(vcnl3020_driver);\n\nMODULE_AUTHOR(\"Ivan Mikhaylov <i.mikhaylov@yadro.com>\");\nMODULE_DESCRIPTION(\"Vishay VCNL3020 proximity sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}