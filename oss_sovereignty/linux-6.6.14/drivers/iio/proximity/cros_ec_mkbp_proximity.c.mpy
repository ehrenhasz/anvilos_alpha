{
  "module_name": "cros_ec_mkbp_proximity.c",
  "hash_id": "036b7a778061cbced88bdb9814b7cf4ab995a8ed04f1ce35b8f57f7a6c24a7ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/proximity/cros_ec_mkbp_proximity.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/notifier.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#include <asm/unaligned.h>\n\nstruct cros_ec_mkbp_proximity_data {\n\tstruct cros_ec_device *ec;\n\tstruct iio_dev *indio_dev;\n\tstruct mutex lock;\n\tstruct notifier_block notifier;\n\tint last_proximity;\n\tbool enabled;\n};\n\nstatic const struct iio_event_spec cros_ec_mkbp_proximity_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec cros_ec_mkbp_proximity_chan_spec[] = {\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.event_spec = cros_ec_mkbp_proximity_events,\n\t\t.num_event_specs = ARRAY_SIZE(cros_ec_mkbp_proximity_events),\n\t},\n};\n\nstatic int cros_ec_mkbp_proximity_parse_state(const void *data)\n{\n\tu32 switches = get_unaligned_le32(data);\n\n\treturn !!(switches & BIT(EC_MKBP_FRONT_PROXIMITY));\n}\n\nstatic int cros_ec_mkbp_proximity_query(struct cros_ec_device *ec_dev,\n\t\t\t\t\tint *state)\n{\n\tstruct {\n\t\tstruct cros_ec_command msg;\n\t\tunion {\n\t\t\tstruct ec_params_mkbp_info params;\n\t\t\tu32 switches;\n\t\t};\n\t} __packed buf = { };\n\tstruct ec_params_mkbp_info *params = &buf.params;\n\tstruct cros_ec_command *msg = &buf.msg;\n\tu32 *switches = &buf.switches;\n\tsize_t insize = sizeof(*switches);\n\tint ret;\n\n\tmsg->command = EC_CMD_MKBP_INFO;\n\tmsg->version = 1;\n\tmsg->outsize = sizeof(*params);\n\tmsg->insize = insize;\n\n\tparams->info_type = EC_MKBP_INFO_CURRENT;\n\tparams->event_type = EC_MKBP_EVENT_SWITCH;\n\n\tret = cros_ec_cmd_xfer_status(ec_dev, msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != insize) {\n\t\tdev_warn(ec_dev->dev, \"wrong result size: %d != %zu\\n\", ret,\n\t\t\t insize);\n\t\treturn -EPROTO;\n\t}\n\n\t*state = cros_ec_mkbp_proximity_parse_state(switches);\n\treturn IIO_VAL_INT;\n}\n\nstatic void cros_ec_mkbp_proximity_push_event(struct cros_ec_mkbp_proximity_data *data, int state)\n{\n\ts64 timestamp;\n\tu64 ev;\n\tint dir;\n\tstruct iio_dev *indio_dev = data->indio_dev;\n\tstruct cros_ec_device *ec = data->ec;\n\n\tmutex_lock(&data->lock);\n\tif (state != data->last_proximity) {\n\t\tif (data->enabled) {\n\t\t\ttimestamp = ktime_to_ns(ec->last_event_time);\n\t\t\tif (iio_device_get_clock(indio_dev) != CLOCK_BOOTTIME)\n\t\t\t\ttimestamp = iio_get_time_ns(indio_dev);\n\n\t\t\tdir = state ? IIO_EV_DIR_FALLING : IIO_EV_DIR_RISING;\n\t\t\tev = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 0,\n\t\t\t\t\t\t  IIO_EV_TYPE_THRESH, dir);\n\t\t\tiio_push_event(indio_dev, ev, timestamp);\n\t\t}\n\t\tdata->last_proximity = state;\n\t}\n\tmutex_unlock(&data->lock);\n}\n\nstatic int cros_ec_mkbp_proximity_notify(struct notifier_block *nb,\n\t\t\t\t\t unsigned long queued_during_suspend,\n\t\t\t\t\t void *_ec)\n{\n\tstruct cros_ec_mkbp_proximity_data *data;\n\tstruct cros_ec_device *ec = _ec;\n\tu8 event_type = ec->event_data.event_type & EC_MKBP_EVENT_TYPE_MASK;\n\tvoid *switches;\n\tint state;\n\n\tif (event_type == EC_MKBP_EVENT_SWITCH) {\n\t\tdata = container_of(nb, struct cros_ec_mkbp_proximity_data,\n\t\t\t\t    notifier);\n\n\t\tswitches = &ec->event_data.data.switches;\n\t\tstate = cros_ec_mkbp_proximity_parse_state(switches);\n\t\tcros_ec_mkbp_proximity_push_event(data, state);\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic int cros_ec_mkbp_proximity_read_raw(struct iio_dev *indio_dev,\n\t\t\t   const struct iio_chan_spec *chan, int *val,\n\t\t\t   int *val2, long mask)\n{\n\tstruct cros_ec_mkbp_proximity_data *data = iio_priv(indio_dev);\n\tstruct cros_ec_device *ec = data->ec;\n\n\tif (chan->type == IIO_PROXIMITY && mask == IIO_CHAN_INFO_RAW)\n\t\treturn cros_ec_mkbp_proximity_query(ec, val);\n\n\treturn -EINVAL;\n}\n\nstatic int cros_ec_mkbp_proximity_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir)\n{\n\tstruct cros_ec_mkbp_proximity_data *data = iio_priv(indio_dev);\n\n\treturn data->enabled;\n}\n\nstatic int cros_ec_mkbp_proximity_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir, int state)\n{\n\tstruct cros_ec_mkbp_proximity_data *data = iio_priv(indio_dev);\n\n\tmutex_lock(&data->lock);\n\tdata->enabled = state;\n\tmutex_unlock(&data->lock);\n\n\treturn 0;\n}\n\nstatic const struct iio_info cros_ec_mkbp_proximity_info = {\n\t.read_raw = cros_ec_mkbp_proximity_read_raw,\n\t.read_event_config = cros_ec_mkbp_proximity_read_event_config,\n\t.write_event_config = cros_ec_mkbp_proximity_write_event_config,\n};\n\nstatic int cros_ec_mkbp_proximity_resume(struct device *dev)\n{\n\tstruct cros_ec_mkbp_proximity_data *data = dev_get_drvdata(dev);\n\tstruct cros_ec_device *ec = data->ec;\n\tint ret, state;\n\n\tret = cros_ec_mkbp_proximity_query(ec, &state);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"failed to fetch proximity state on resume: %d\\n\",\n\t\t\t ret);\n\t} else {\n\t\tcros_ec_mkbp_proximity_push_event(data, state);\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(cros_ec_mkbp_proximity_pm_ops, NULL,\n\t\t\t\tcros_ec_mkbp_proximity_resume);\n\nstatic int cros_ec_mkbp_proximity_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cros_ec_device *ec = dev_get_drvdata(dev->parent);\n\tstruct iio_dev *indio_dev;\n\tstruct cros_ec_mkbp_proximity_data *data;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->ec = ec;\n\tdata->indio_dev = indio_dev;\n\tdata->last_proximity = -1;  \n\tmutex_init(&data->lock);\n\tplatform_set_drvdata(pdev, data);\n\n\tindio_dev->name = dev->driver->name;\n\tindio_dev->info = &cros_ec_mkbp_proximity_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = cros_ec_mkbp_proximity_chan_spec;\n\tindio_dev->num_channels = ARRAY_SIZE(cros_ec_mkbp_proximity_chan_spec);\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->notifier.notifier_call = cros_ec_mkbp_proximity_notify;\n\tblocking_notifier_chain_register(&ec->event_notifier, &data->notifier);\n\n\treturn 0;\n}\n\nstatic int cros_ec_mkbp_proximity_remove(struct platform_device *pdev)\n{\n\tstruct cros_ec_mkbp_proximity_data *data = platform_get_drvdata(pdev);\n\tstruct cros_ec_device *ec = data->ec;\n\n\tblocking_notifier_chain_unregister(&ec->event_notifier,\n\t\t\t\t\t   &data->notifier);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id cros_ec_mkbp_proximity_of_match[] = {\n\t{ .compatible = \"google,cros-ec-mkbp-proximity\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, cros_ec_mkbp_proximity_of_match);\n\nstatic struct platform_driver cros_ec_mkbp_proximity_driver = {\n\t.driver = {\n\t\t.name = \"cros-ec-mkbp-proximity\",\n\t\t.of_match_table = cros_ec_mkbp_proximity_of_match,\n\t\t.pm = pm_sleep_ptr(&cros_ec_mkbp_proximity_pm_ops),\n\t},\n\t.probe = cros_ec_mkbp_proximity_probe,\n\t.remove = cros_ec_mkbp_proximity_remove,\n};\nmodule_platform_driver(cros_ec_mkbp_proximity_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ChromeOS EC MKBP proximity sensor driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}