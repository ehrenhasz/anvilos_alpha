{
  "module_name": "vl53l0x-i2c.c",
  "hash_id": "6e8bef284da3bfe1b1862e6573edba9f27840f50e45aa892272e0d14c182c089",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/proximity/vl53l0x-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n\n#define VL_REG_SYSRANGE_START\t\t\t\t0x00\n\n#define VL_REG_SYSRANGE_MODE_MASK\t\t\tGENMASK(3, 0)\n#define VL_REG_SYSRANGE_MODE_SINGLESHOT\t\t\t0x00\n#define VL_REG_SYSRANGE_MODE_START_STOP\t\t\tBIT(0)\n#define VL_REG_SYSRANGE_MODE_BACKTOBACK\t\t\tBIT(1)\n#define VL_REG_SYSRANGE_MODE_TIMED\t\t\tBIT(2)\n#define VL_REG_SYSRANGE_MODE_HISTOGRAM\t\t\tBIT(3)\n\n#define VL_REG_SYSTEM_INTERRUPT_CONFIG_GPIO\t\t0x0A\n#define VL_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY\tBIT(2)\n\n#define VL_REG_SYSTEM_INTERRUPT_CLEAR\t\t\t0x0B\n\n#define VL_REG_RESULT_INT_STATUS\t\t\t0x13\n#define VL_REG_RESULT_RANGE_STATUS\t\t\t0x14\n#define VL_REG_RESULT_RANGE_STATUS_COMPLETE\t\tBIT(0)\n\nstruct vl53l0x_data {\n\tstruct i2c_client *client;\n\tstruct completion completion;\n\tstruct regulator *vdd_supply;\n\tstruct gpio_desc *reset_gpio;\n};\n\nstatic irqreturn_t vl53l0x_handle_irq(int irq, void *priv)\n{\n\tstruct iio_dev *indio_dev = priv;\n\tstruct vl53l0x_data *data = iio_priv(indio_dev);\n\n\tcomplete(&data->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int vl53l0x_configure_irq(struct i2c_client *client,\n\t\t\t\t struct iio_dev *indio_dev)\n{\n\tint irq_flags = irq_get_trigger_type(client->irq);\n\tstruct vl53l0x_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (!irq_flags)\n\t\tirq_flags = IRQF_TRIGGER_FALLING;\n\n\tret = devm_request_irq(&client->dev, client->irq, vl53l0x_handle_irq,\n\t\t\tirq_flags, indio_dev->name, indio_dev);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"devm_request_irq error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\tVL_REG_SYSTEM_INTERRUPT_CONFIG_GPIO,\n\t\t\tVL_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"failed to configure IRQ: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void vl53l0x_clear_irq(struct vl53l0x_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tVL_REG_SYSTEM_INTERRUPT_CLEAR, 1);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to clear error irq: %d\\n\", ret);\n\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tVL_REG_SYSTEM_INTERRUPT_CLEAR, 0);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to clear range irq: %d\\n\", ret);\n\n\tret = i2c_smbus_read_byte_data(data->client, VL_REG_RESULT_INT_STATUS);\n\tif (ret < 0 || ret & 0x07)\n\t\tdev_err(dev, \"failed to clear irq: %d\\n\", ret);\n}\n\nstatic int vl53l0x_read_proximity(struct vl53l0x_data *data,\n\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t  int *val)\n{\n\tstruct i2c_client *client = data->client;\n\tu16 tries = 20;\n\tu8 buffer[12];\n\tint ret;\n\tunsigned long time_left;\n\n\tret = i2c_smbus_write_byte_data(client, VL_REG_SYSRANGE_START, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (data->client->irq) {\n\t\treinit_completion(&data->completion);\n\n\t\ttime_left = wait_for_completion_timeout(&data->completion, HZ/10);\n\t\tif (time_left == 0)\n\t\t\treturn -ETIMEDOUT;\n\n\t\tvl53l0x_clear_irq(data);\n\t} else {\n\t\tdo {\n\t\t\tret = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t       VL_REG_RESULT_RANGE_STATUS);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (ret & VL_REG_RESULT_RANGE_STATUS_COMPLETE)\n\t\t\t\tbreak;\n\n\t\t\tusleep_range(1000, 5000);\n\t\t} while (--tries);\n\t\tif (!tries)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\tret = i2c_smbus_read_i2c_block_data(client, VL_REG_RESULT_RANGE_STATUS,\n\t\t\t\t\t    12, buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != 12)\n\t\treturn -EREMOTEIO;\n\n\t \n\t*val = (buffer[10] << 8) + buffer[11];\n\n\treturn 0;\n}\n\nstatic const struct iio_chan_spec vl53l0x_channels[] = {\n\t{\n\t\t.type = IIO_DISTANCE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t},\n};\n\nstatic int vl53l0x_read_raw(struct iio_dev *indio_dev,\n\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct vl53l0x_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (chan->type != IIO_DISTANCE)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = vl53l0x_read_proximity(data, chan, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = 1000;\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info vl53l0x_info = {\n\t.read_raw = vl53l0x_read_raw,\n};\n\nstatic void vl53l0x_power_off(void *_data)\n{\n\tstruct vl53l0x_data *data = _data;\n\n\tgpiod_set_value_cansleep(data->reset_gpio, 1);\n\n\tregulator_disable(data->vdd_supply);\n}\n\nstatic int vl53l0x_power_on(struct vl53l0x_data *data)\n{\n\tint ret;\n\n\tret = regulator_enable(data->vdd_supply);\n\tif (ret)\n\t\treturn ret;\n\n\tgpiod_set_value_cansleep(data->reset_gpio, 0);\n\n\tusleep_range(3200, 5000);\n\n\treturn 0;\n}\n\nstatic int vl53l0x_probe(struct i2c_client *client)\n{\n\tstruct vl53l0x_data *data;\n\tstruct iio_dev *indio_dev;\n\tint error;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\ti2c_set_clientdata(client, indio_dev);\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_READ_I2C_BLOCK |\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tdata->vdd_supply = devm_regulator_get(&client->dev, \"vdd\");\n\tif (IS_ERR(data->vdd_supply))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(data->vdd_supply),\n\t\t\t\t     \"Unable to get VDD regulator\\n\");\n\n\tdata->reset_gpio = devm_gpiod_get_optional(&client->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(data->reset_gpio))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(data->reset_gpio),\n\t\t\t\t     \"Cannot get reset GPIO\\n\");\n\n\terror = vl53l0x_power_on(data);\n\tif (error)\n\t\treturn dev_err_probe(&client->dev, error,\n\t\t\t\t     \"Failed to power on the chip\\n\");\n\n\terror = devm_add_action_or_reset(&client->dev, vl53l0x_power_off, data);\n\tif (error)\n\t\treturn dev_err_probe(&client->dev, error,\n\t\t\t\t     \"Failed to install poweroff action\\n\");\n\n\tindio_dev->name = \"vl53l0x\";\n\tindio_dev->info = &vl53l0x_info;\n\tindio_dev->channels = vl53l0x_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(vl53l0x_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\t \n\tif (client->irq) {\n\t\tint ret;\n\n\t\tinit_completion(&data->completion);\n\n\t\tret = vl53l0x_configure_irq(client, indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id vl53l0x_id[] = {\n\t{ \"vl53l0x\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, vl53l0x_id);\n\nstatic const struct of_device_id st_vl53l0x_dt_match[] = {\n\t{ .compatible = \"st,vl53l0x\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, st_vl53l0x_dt_match);\n\nstatic struct i2c_driver vl53l0x_driver = {\n\t.driver = {\n\t\t.name = \"vl53l0x-i2c\",\n\t\t.of_match_table = st_vl53l0x_dt_match,\n\t},\n\t.probe = vl53l0x_probe,\n\t.id_table = vl53l0x_id,\n};\nmodule_i2c_driver(vl53l0x_driver);\n\nMODULE_AUTHOR(\"Song Qiang <songqiang1304521@gmail.com>\");\nMODULE_DESCRIPTION(\"ST vl53l0x ToF ranging sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}