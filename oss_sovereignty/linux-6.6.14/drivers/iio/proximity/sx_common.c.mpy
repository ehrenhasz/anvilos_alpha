{
  "module_name": "sx_common.c",
  "hash_id": "38ab0af5ed052606ced4e25aff63a4708f605b225c7258d4f7a66fe54d457886",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/proximity/sx_common.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/byteorder/generic.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/irqreturn.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <vdso/bits.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#include \"sx_common.h\"\n\n \n#define   SX_COMMON_CONVDONE_IRQ\t\t\tBIT(0)\n#define   SX_COMMON_FAR_IRQ\t\t\t\tBIT(2)\n#define   SX_COMMON_CLOSE_IRQ\t\t\t\tBIT(3)\n\nconst struct iio_event_spec sx_common_events[3] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_shared_by_all = BIT(IIO_EV_INFO_PERIOD),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_shared_by_all = BIT(IIO_EV_INFO_PERIOD),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE) |\n\t\t\t\t BIT(IIO_EV_INFO_HYSTERESIS) |\n\t\t\t\t BIT(IIO_EV_INFO_VALUE),\n\t},\n};\nEXPORT_SYMBOL_NS_GPL(sx_common_events, SEMTECH_PROX);\n\nstatic irqreturn_t sx_common_irq_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\n\tif (data->trigger_enabled)\n\t\tiio_trigger_poll(data->trig);\n\n\t \n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic void sx_common_push_events(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tunsigned int val, chan;\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\ts64 timestamp = iio_get_time_ns(indio_dev);\n\tunsigned long prox_changed;\n\n\t \n\tret = regmap_read(data->regmap, data->chip_info->reg_stat, &val);\n\tif (ret) {\n\t\tdev_err(&data->client->dev, \"i2c transfer error in irq\\n\");\n\t\treturn;\n\t}\n\n\tval >>= data->chip_info->stat_offset;\n\n\t \n\tprox_changed = (data->chan_prox_stat ^ val) & data->chan_event;\n\n\tfor_each_set_bit(chan, &prox_changed, data->chip_info->num_channels) {\n\t\tint dir;\n\t\tu64 ev;\n\n\t\tdir = (val & BIT(chan)) ? IIO_EV_DIR_FALLING : IIO_EV_DIR_RISING;\n\t\tev = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, chan,\n\t\t\t\t\t  IIO_EV_TYPE_THRESH, dir);\n\n\t\tiio_push_event(indio_dev, ev, timestamp);\n\t}\n\tdata->chan_prox_stat = val;\n}\n\nstatic int sx_common_enable_irq(struct sx_common_data *data, unsigned int irq)\n{\n\tif (!data->client->irq)\n\t\treturn 0;\n\treturn regmap_update_bits(data->regmap, data->chip_info->reg_irq_msk,\n\t\t\t\t  irq << data->chip_info->irq_msk_offset,\n\t\t\t\t  irq << data->chip_info->irq_msk_offset);\n}\n\nstatic int sx_common_disable_irq(struct sx_common_data *data, unsigned int irq)\n{\n\tif (!data->client->irq)\n\t\treturn 0;\n\treturn regmap_update_bits(data->regmap, data->chip_info->reg_irq_msk,\n\t\t\t\t  irq << data->chip_info->irq_msk_offset, 0);\n}\n\nstatic int sx_common_update_chan_en(struct sx_common_data *data,\n\t\t\t\t    unsigned long chan_read,\n\t\t\t\t    unsigned long chan_event)\n{\n\tint ret;\n\tunsigned long channels = chan_read | chan_event;\n\n\tif ((data->chan_read | data->chan_event) != channels) {\n\t\tret = regmap_update_bits(data->regmap,\n\t\t\t\t\t data->chip_info->reg_enable_chan,\n\t\t\t\t\t data->chip_info->mask_enable_chan,\n\t\t\t\t\t channels);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tdata->chan_read = chan_read;\n\tdata->chan_event = chan_event;\n\treturn 0;\n}\n\nstatic int sx_common_get_read_channel(struct sx_common_data *data, int channel)\n{\n\treturn sx_common_update_chan_en(data, data->chan_read | BIT(channel),\n\t\t\t\t     data->chan_event);\n}\n\nstatic int sx_common_put_read_channel(struct sx_common_data *data, int channel)\n{\n\treturn sx_common_update_chan_en(data, data->chan_read & ~BIT(channel),\n\t\t\t\t     data->chan_event);\n}\n\nstatic int sx_common_get_event_channel(struct sx_common_data *data, int channel)\n{\n\treturn sx_common_update_chan_en(data, data->chan_read,\n\t\t\t\t     data->chan_event | BIT(channel));\n}\n\nstatic int sx_common_put_event_channel(struct sx_common_data *data, int channel)\n{\n\treturn sx_common_update_chan_en(data, data->chan_read,\n\t\t\t\t     data->chan_event & ~BIT(channel));\n}\n\n \nint sx_common_read_proximity(struct sx_common_data *data,\n\t\t\t     const struct iio_chan_spec *chan, int *val)\n{\n\tint ret;\n\t__be16 rawval;\n\n\tmutex_lock(&data->mutex);\n\n\tret = sx_common_get_read_channel(data, chan->channel);\n\tif (ret)\n\t\tgoto out;\n\n\tret = sx_common_enable_irq(data, SX_COMMON_CONVDONE_IRQ);\n\tif (ret)\n\t\tgoto out_put_channel;\n\n\tmutex_unlock(&data->mutex);\n\n\tif (data->client->irq) {\n\t\tret = wait_for_completion_interruptible(&data->completion);\n\t\treinit_completion(&data->completion);\n\t} else {\n\t\tret = data->chip_info->ops.wait_for_sample(data);\n\t}\n\n\tmutex_lock(&data->mutex);\n\n\tif (ret)\n\t\tgoto out_disable_irq;\n\n\tret = data->chip_info->ops.read_prox_data(data, chan, &rawval);\n\tif (ret)\n\t\tgoto out_disable_irq;\n\n\t*val = sign_extend32(be16_to_cpu(rawval), chan->scan_type.realbits - 1);\n\n\tret = sx_common_disable_irq(data, SX_COMMON_CONVDONE_IRQ);\n\tif (ret)\n\t\tgoto out_put_channel;\n\n\tret = sx_common_put_read_channel(data, chan->channel);\n\tif (ret)\n\t\tgoto out;\n\n\tmutex_unlock(&data->mutex);\n\n\treturn IIO_VAL_INT;\n\nout_disable_irq:\n\tsx_common_disable_irq(data, SX_COMMON_CONVDONE_IRQ);\nout_put_channel:\n\tsx_common_put_read_channel(data, chan->channel);\nout:\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(sx_common_read_proximity, SEMTECH_PROX);\n\n \nint sx_common_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\tconst struct iio_chan_spec *chan,\n\t\t\t\tenum iio_event_type type,\n\t\t\t\tenum iio_event_direction dir)\n{\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\n\treturn !!(data->chan_event & BIT(chan->channel));\n}\nEXPORT_SYMBOL_NS_GPL(sx_common_read_event_config, SEMTECH_PROX);\n\n \nint sx_common_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t enum iio_event_type type,\n\t\t\t\t enum iio_event_direction dir, int state)\n{\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\tunsigned int eventirq = SX_COMMON_FAR_IRQ | SX_COMMON_CLOSE_IRQ;\n\tint ret;\n\n\t \n\tif (!!(data->chan_event & BIT(chan->channel)) == state)\n\t\treturn 0;\n\n\tmutex_lock(&data->mutex);\n\tif (state) {\n\t\tret = sx_common_get_event_channel(data, chan->channel);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tif (!(data->chan_event & ~BIT(chan->channel))) {\n\t\t\tret = sx_common_enable_irq(data, eventirq);\n\t\t\tif (ret)\n\t\t\t\tsx_common_put_event_channel(data, chan->channel);\n\t\t}\n\t} else {\n\t\tret = sx_common_put_event_channel(data, chan->channel);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tif (!data->chan_event) {\n\t\t\tret = sx_common_disable_irq(data, eventirq);\n\t\t\tif (ret)\n\t\t\t\tsx_common_get_event_channel(data, chan->channel);\n\t\t}\n\t}\n\nout_unlock:\n\tmutex_unlock(&data->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(sx_common_write_event_config, SEMTECH_PROX);\n\nstatic int sx_common_set_trigger_state(struct iio_trigger *trig, bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\tint ret = 0;\n\n\tmutex_lock(&data->mutex);\n\n\tif (state)\n\t\tret = sx_common_enable_irq(data, SX_COMMON_CONVDONE_IRQ);\n\telse if (!data->chan_read)\n\t\tret = sx_common_disable_irq(data, SX_COMMON_CONVDONE_IRQ);\n\tif (ret)\n\t\tgoto out;\n\n\tdata->trigger_enabled = state;\n\nout:\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic const struct iio_trigger_ops sx_common_trigger_ops = {\n\t.set_trigger_state = sx_common_set_trigger_state,\n};\n\nstatic irqreturn_t sx_common_irq_thread_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\tint ret;\n\tunsigned int val;\n\n\tmutex_lock(&data->mutex);\n\n\tret = regmap_read(data->regmap, SX_COMMON_REG_IRQ_SRC, &val);\n\tif (ret) {\n\t\tdev_err(&data->client->dev, \"i2c transfer error in irq\\n\");\n\t\tgoto out;\n\t}\n\n\tif (val & ((SX_COMMON_FAR_IRQ | SX_COMMON_CLOSE_IRQ) << data->chip_info->irq_msk_offset))\n\t\tsx_common_push_events(indio_dev);\n\n\tif (val & (SX_COMMON_CONVDONE_IRQ << data->chip_info->irq_msk_offset))\n\t\tcomplete(&data->completion);\n\nout:\n\tmutex_unlock(&data->mutex);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t sx_common_trigger_handler(int irq, void *private)\n{\n\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\t__be16 val;\n\tint bit, ret, i = 0;\n\n\tmutex_lock(&data->mutex);\n\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\tret = data->chip_info->ops.read_prox_data(data,\n\t\t\t\t\t\t     &indio_dev->channels[bit],\n\t\t\t\t\t\t     &val);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tdata->buffer.channels[i++] = val;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->buffer,\n\t\t\t\t\t   pf->timestamp);\n\nout:\n\tmutex_unlock(&data->mutex);\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sx_common_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\tunsigned long channels = 0;\n\tint bit, ret;\n\n\tmutex_lock(&data->mutex);\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength)\n\t\t__set_bit(indio_dev->channels[bit].channel, &channels);\n\n\tret = sx_common_update_chan_en(data, channels, data->chan_event);\n\tmutex_unlock(&data->mutex);\n\treturn ret;\n}\n\nstatic int sx_common_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = sx_common_update_chan_en(data, 0, data->chan_event);\n\tmutex_unlock(&data->mutex);\n\treturn ret;\n}\n\nstatic const struct iio_buffer_setup_ops sx_common_buffer_setup_ops = {\n\t.preenable = sx_common_buffer_preenable,\n\t.postdisable = sx_common_buffer_postdisable,\n};\n\nvoid sx_common_get_raw_register_config(struct device *dev,\n\t\t\t\t       struct sx_common_reg_default *reg_def)\n{\n#ifdef CONFIG_ACPI\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tu32 raw = 0, ret;\n\tchar prop[80];\n\n\tif (!reg_def->property || !adev)\n\t\treturn;\n\n\tsnprintf(prop, ARRAY_SIZE(prop), \"%s,reg_%s\", acpi_device_hid(adev), reg_def->property);\n\tret = device_property_read_u32(dev, prop, &raw);\n\tif (ret)\n\t\treturn;\n\n\treg_def->def = raw;\n#endif\n}\nEXPORT_SYMBOL_NS_GPL(sx_common_get_raw_register_config, SEMTECH_PROX);\n\n#define SX_COMMON_SOFT_RESET\t\t\t\t0xde\n\nstatic int sx_common_init_device(struct device *dev, struct iio_dev *indio_dev)\n{\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\tstruct sx_common_reg_default tmp;\n\tconst struct sx_common_reg_default *initval;\n\tint ret;\n\tunsigned int i, val;\n\n\tret = regmap_write(data->regmap, data->chip_info->reg_reset,\n\t\t\t   SX_COMMON_SOFT_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(1000, 2000);  \n\n\t \n\tret = regmap_read(data->regmap, SX_COMMON_REG_IRQ_SRC, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < data->chip_info->num_default_regs; i++) {\n\t\tinitval = data->chip_info->ops.get_default_reg(dev, i, &tmp);\n\t\tret = regmap_write(data->regmap, initval->reg, initval->def);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn data->chip_info->ops.init_compensation(indio_dev);\n}\n\n \nint sx_common_probe(struct i2c_client *client,\n\t\t    const struct sx_common_chip_info *chip_info,\n\t\t    const struct regmap_config *regmap_config)\n{\n\tstatic const char * const regulator_names[] = { \"vdd\", \"svdd\" };\n\tstruct device *dev = &client->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct sx_common_data *data;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\n\tdata->chip_info = chip_info;\n\tdata->client = client;\n\tmutex_init(&data->mutex);\n\tinit_completion(&data->completion);\n\n\tdata->regmap = devm_regmap_init_i2c(client, regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->regmap),\n\t\t\t\t     \"Could init register map\\n\");\n\n\tret = devm_regulator_bulk_get_enable(dev, ARRAY_SIZE(regulator_names),\n\t\t\t\t\t     regulator_names);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Unable to get regulators\\n\");\n\n\t \n\tusleep_range(1000, 1100);\n\n\tret = data->chip_info->ops.check_whoami(dev, indio_dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"error reading WHOAMI\\n\");\n\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tindio_dev->channels =  data->chip_info->iio_channels;\n\tindio_dev->num_channels = data->chip_info->num_iio_channels;\n\tindio_dev->info = &data->chip_info->iio_info;\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\tret = sx_common_init_device(dev, indio_dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Unable to initialize sensor\\n\");\n\n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\t\tsx_common_irq_handler,\n\t\t\t\t\t\tsx_common_irq_thread_handler,\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"sx_event\", indio_dev);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"No IRQ\\n\");\n\n\t\tdata->trig = devm_iio_trigger_alloc(dev, \"%s-dev%d\",\n\t\t\t\t\t\t    indio_dev->name,\n\t\t\t\t\t\t    iio_device_id(indio_dev));\n\t\tif (!data->trig)\n\t\t\treturn -ENOMEM;\n\n\t\tdata->trig->ops = &sx_common_trigger_ops;\n\t\tiio_trigger_set_drvdata(data->trig, indio_dev);\n\n\t\tret = devm_iio_trigger_register(dev, data->trig);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev,\n\t\t\t\t\t      iio_pollfunc_store_time,\n\t\t\t\t\t      sx_common_trigger_handler,\n\t\t\t\t\t      &sx_common_buffer_setup_ops);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(sx_common_probe, SEMTECH_PROX);\n\nMODULE_AUTHOR(\"Gwendal Grignou <gwendal@chromium.org>\");\nMODULE_DESCRIPTION(\"Common functions and structures for Semtech sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}