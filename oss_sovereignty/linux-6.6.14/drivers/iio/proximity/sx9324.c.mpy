{
  "module_name": "sx9324.c",
  "hash_id": "0da7af5531fd47d9a60754c884bc32e299d8df53f8aba2cf1e87986c35ccbb7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/proximity/sx9324.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\n#include <linux/iio/iio.h>\n\n#include \"sx_common.h\"\n\n \n#define SX9324_REG_IRQ_SRC\t\tSX_COMMON_REG_IRQ_SRC\n#define SX9324_REG_STAT0\t\t0x01\n#define SX9324_REG_STAT1\t\t0x02\n#define SX9324_REG_STAT2\t\t0x03\n#define SX9324_REG_STAT2_COMPSTAT_MASK\tGENMASK(3, 0)\n#define SX9324_REG_STAT3\t\t0x04\n#define SX9324_REG_IRQ_MSK\t\t0x05\n#define SX9324_CONVDONE_IRQ\t\tBIT(3)\n#define SX9324_FAR_IRQ\t\t\tBIT(5)\n#define SX9324_CLOSE_IRQ\t\tBIT(6)\n#define SX9324_REG_IRQ_CFG0\t\t0x06\n#define SX9324_REG_IRQ_CFG1\t\t0x07\n#define SX9324_REG_IRQ_CFG1_FAILCOND    0x80\n#define SX9324_REG_IRQ_CFG2\t\t0x08\n\n#define SX9324_REG_GNRL_CTRL0\t\t0x10\n#define SX9324_REG_GNRL_CTRL0_SCANPERIOD_MASK GENMASK(4, 0)\n#define SX9324_REG_GNRL_CTRL0_SCANPERIOD_100MS 0x16\n#define SX9324_REG_GNRL_CTRL1\t\t0x11\n#define SX9324_REG_GNRL_CTRL1_PHEN_MASK GENMASK(3, 0)\n#define SX9324_REG_GNRL_CTRL1_PAUSECTRL 0x20\n\n#define SX9324_REG_I2C_ADDR\t\t0x14\n#define SX9324_REG_CLK_SPRD\t\t0x15\n\n#define SX9324_REG_AFE_CTRL0\t\t0x20\n#define SX9324_REG_AFE_CTRL0_RINT_SHIFT\t\t6\n#define SX9324_REG_AFE_CTRL0_RINT_MASK \\\n\tGENMASK(SX9324_REG_AFE_CTRL0_RINT_SHIFT + 1, \\\n\t\tSX9324_REG_AFE_CTRL0_RINT_SHIFT)\n#define SX9324_REG_AFE_CTRL0_RINT_LOWEST\t0x00\n#define SX9324_REG_AFE_CTRL0_CSIDLE_SHIFT\t4\n#define SX9324_REG_AFE_CTRL0_CSIDLE_MASK \\\n\tGENMASK(SX9324_REG_AFE_CTRL0_CSIDLE_SHIFT + 1, \\\n\t\tSX9324_REG_AFE_CTRL0_CSIDLE_SHIFT)\n#define SX9324_REG_AFE_CTRL0_RINT_LOWEST\t0x00\n#define SX9324_REG_AFE_CTRL1\t\t0x21\n#define SX9324_REG_AFE_CTRL2\t\t0x22\n#define SX9324_REG_AFE_CTRL3\t\t0x23\n#define SX9324_REG_AFE_CTRL4\t\t0x24\n#define SX9324_REG_AFE_CTRL4_FREQ_83_33HZ 0x40\n#define SX9324_REG_AFE_CTRL4_RESOLUTION_MASK GENMASK(2, 0)\n#define SX9324_REG_AFE_CTRL4_RES_100\t0x04\n#define SX9324_REG_AFE_CTRL5\t\t0x25\n#define SX9324_REG_AFE_CTRL6\t\t0x26\n#define SX9324_REG_AFE_CTRL7\t\t0x27\n#define SX9324_REG_AFE_PH0\t\t0x28\n#define SX9324_REG_AFE_PH0_PIN_MASK(_pin) \\\n\tGENMASK(2 * (_pin) + 1, 2 * (_pin))\n\n#define SX9324_REG_AFE_PH1\t\t0x29\n#define SX9324_REG_AFE_PH2\t\t0x2a\n#define SX9324_REG_AFE_PH3\t\t0x2b\n#define SX9324_REG_AFE_CTRL8\t\t0x2c\n#define SX9324_REG_AFE_CTRL8_RESERVED\t0x10\n#define SX9324_REG_AFE_CTRL8_RESFILTIN_4KOHM 0x02\n#define SX9324_REG_AFE_CTRL8_RESFILTIN_MASK GENMASK(3, 0)\n#define SX9324_REG_AFE_CTRL9\t\t0x2d\n#define SX9324_REG_AFE_CTRL9_AGAIN_MASK\t\t\tGENMASK(3, 0)\n#define SX9324_REG_AFE_CTRL9_AGAIN_1\t0x08\n\n#define SX9324_REG_PROX_CTRL0\t\t0x30\n#define SX9324_REG_PROX_CTRL0_GAIN_MASK\tGENMASK(5, 3)\n#define SX9324_REG_PROX_CTRL0_GAIN_SHIFT\t3\n#define SX9324_REG_PROX_CTRL0_GAIN_RSVD\t\t0x0\n#define SX9324_REG_PROX_CTRL0_GAIN_1\t\t0x1\n#define SX9324_REG_PROX_CTRL0_GAIN_8\t\t0x4\n#define SX9324_REG_PROX_CTRL0_RAWFILT_MASK\tGENMASK(2, 0)\n#define SX9324_REG_PROX_CTRL0_RAWFILT_1P50\t0x01\n#define SX9324_REG_PROX_CTRL1\t\t0x31\n#define SX9324_REG_PROX_CTRL2\t\t0x32\n#define SX9324_REG_PROX_CTRL2_AVGNEG_THRESH_16K 0x20\n#define SX9324_REG_PROX_CTRL3\t\t0x33\n#define SX9324_REG_PROX_CTRL3_AVGDEB_2SAMPLES\t0x40\n#define SX9324_REG_PROX_CTRL3_AVGPOS_THRESH_16K 0x20\n#define SX9324_REG_PROX_CTRL4\t\t0x34\n#define SX9324_REG_PROX_CTRL4_AVGNEGFILT_MASK\tGENMASK(5, 3)\n#define SX9324_REG_PROX_CTRL4_AVGNEG_FILT_2 0x08\n#define SX9324_REG_PROX_CTRL4_AVGPOSFILT_MASK\tGENMASK(2, 0)\n#define SX9324_REG_PROX_CTRL4_AVGPOS_FILT_256 0x04\n#define SX9324_REG_PROX_CTRL5\t\t0x35\n#define SX9324_REG_PROX_CTRL5_HYST_MASK\t\t\tGENMASK(5, 4)\n#define SX9324_REG_PROX_CTRL5_CLOSE_DEBOUNCE_MASK\tGENMASK(3, 2)\n#define SX9324_REG_PROX_CTRL5_FAR_DEBOUNCE_MASK\t\tGENMASK(1, 0)\n#define SX9324_REG_PROX_CTRL6\t\t0x36\n#define SX9324_REG_PROX_CTRL6_PROXTHRESH_32\t0x08\n#define SX9324_REG_PROX_CTRL7\t\t0x37\n\n#define SX9324_REG_ADV_CTRL0\t\t0x40\n#define SX9324_REG_ADV_CTRL1\t\t0x41\n#define SX9324_REG_ADV_CTRL2\t\t0x42\n#define SX9324_REG_ADV_CTRL3\t\t0x43\n#define SX9324_REG_ADV_CTRL4\t\t0x44\n#define SX9324_REG_ADV_CTRL5\t\t0x45\n#define SX9324_REG_ADV_CTRL5_STARTUPSENS_MASK GENMASK(3, 2)\n#define SX9324_REG_ADV_CTRL5_STARTUP_SENSOR_1\t0x04\n#define SX9324_REG_ADV_CTRL5_STARTUP_METHOD_1\t0x01\n#define SX9324_REG_ADV_CTRL6\t\t0x46\n#define SX9324_REG_ADV_CTRL7\t\t0x47\n#define SX9324_REG_ADV_CTRL8\t\t0x48\n#define SX9324_REG_ADV_CTRL9\t\t0x49\n#define SX9324_REG_ADV_CTRL10\t\t0x4a\n#define SX9324_REG_ADV_CTRL11\t\t0x4b\n#define SX9324_REG_ADV_CTRL12\t\t0x4c\n#define SX9324_REG_ADV_CTRL13\t\t0x4d\n#define SX9324_REG_ADV_CTRL14\t\t0x4e\n#define SX9324_REG_ADV_CTRL15\t\t0x4f\n#define SX9324_REG_ADV_CTRL16\t\t0x50\n#define SX9324_REG_ADV_CTRL17\t\t0x51\n#define SX9324_REG_ADV_CTRL18\t\t0x52\n#define SX9324_REG_ADV_CTRL19\t\t0x53\n#define SX9324_REG_ADV_CTRL20\t\t0x54\n#define SX9324_REG_ADV_CTRL19_HIGHT_FAILURE_THRESH_SATURATION 0xf0\n\n#define SX9324_REG_PHASE_SEL\t\t0x60\n\n#define SX9324_REG_USEFUL_MSB\t\t0x61\n#define SX9324_REG_USEFUL_LSB\t\t0x62\n\n#define SX9324_REG_AVG_MSB\t\t0x63\n#define SX9324_REG_AVG_LSB\t\t0x64\n\n#define SX9324_REG_DIFF_MSB\t\t0x65\n#define SX9324_REG_DIFF_LSB\t\t0x66\n\n#define SX9324_REG_OFFSET_MSB\t\t0x67\n#define SX9324_REG_OFFSET_LSB\t\t0x68\n\n#define SX9324_REG_SAR_MSB\t\t0x69\n#define SX9324_REG_SAR_LSB\t\t0x6a\n\n#define SX9324_REG_RESET\t\t0x9f\n \n#define SX9324_SOFT_RESET\t\t0xde\n\n#define SX9324_REG_WHOAMI\t\t0xfa\n#define   SX9324_WHOAMI_VALUE\t\t0x23\n\n#define SX9324_REG_REVISION\t\t0xfe\n\n \n#define SX9324_NUM_CHANNELS\t\t4\n \n#define SX9324_NUM_PINS\t\t\t3\n\nstatic const char * const sx9324_cs_pin_usage[] = { \"HZ\", \"MI\", \"DS\", \"GD\" };\n\nstatic ssize_t sx9324_phase_configuration_show(struct iio_dev *indio_dev,\n\t\t\t\t\t       uintptr_t private,\n\t\t\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t\t\t       char *buf)\n{\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\tunsigned int val;\n\tint i, ret, pin_idx;\n\tsize_t len = 0;\n\n\tret = regmap_read(data->regmap, SX9324_REG_AFE_PH0 + chan->channel, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < SX9324_NUM_PINS; i++) {\n\t\tpin_idx = (val & SX9324_REG_AFE_PH0_PIN_MASK(i)) >> (2 * i);\n\t\tlen += sysfs_emit_at(buf, len, \"%s,\",\n\t\t\t\t     sx9324_cs_pin_usage[pin_idx]);\n\t}\n\tbuf[len - 1] = '\\n';\n\treturn len;\n}\n\nstatic const struct iio_chan_spec_ext_info sx9324_channel_ext_info[] = {\n\t{\n\t\t.name = \"setup\",\n\t\t.shared = IIO_SEPARATE,\n\t\t.read = sx9324_phase_configuration_show,\n\t},\n\t{}\n};\n\n#define SX9324_CHANNEL(idx)\t\t\t\t\t \\\n{\t\t\t\t\t\t\t\t \\\n\t.type = IIO_PROXIMITY,\t\t\t\t\t \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t \\\n\t\t\t      BIT(IIO_CHAN_INFO_HARDWAREGAIN),\t \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.info_mask_separate_available =\t\t\t\t \\\n\t\tBIT(IIO_CHAN_INFO_HARDWAREGAIN),\t\t \\\n\t.info_mask_shared_by_all_available =\t\t\t \\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t \\\n\t.indexed = 1,\t\t\t\t\t\t \\\n\t.channel = idx,\t\t\t\t\t\t \\\n\t.address = SX9324_REG_DIFF_MSB,\t\t\t\t \\\n\t.event_spec = sx_common_events,\t\t\t\t \\\n\t.num_event_specs = ARRAY_SIZE(sx_common_events),\t \\\n\t.scan_index = idx,\t\t\t\t\t \\\n\t.scan_type = {\t\t\t\t\t\t \\\n\t\t.sign = 's',\t\t\t\t\t \\\n\t\t.realbits = 12,\t\t\t\t\t \\\n\t\t.storagebits = 16,\t\t\t\t \\\n\t\t.endianness = IIO_BE,\t\t\t\t \\\n\t},\t\t\t\t\t\t\t \\\n\t.ext_info = sx9324_channel_ext_info,\t\t\t \\\n}\n\nstatic const struct iio_chan_spec sx9324_channels[] = {\n\tSX9324_CHANNEL(0),\t\t\t \n\tSX9324_CHANNEL(1),\t\t\t \n\tSX9324_CHANNEL(2),\t\t\t \n\tSX9324_CHANNEL(3),\t\t\t \n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\n \nstatic const struct {\n\tint val;\n\tint val2;\n} sx9324_samp_freq_table[] = {\n\t{ 1000, 0 },   \n\t{ 500, 0 },   \n\t{ 250, 0 },   \n\t{ 166, 666666 },   \n\t{ 125, 0 },   \n\t{ 100, 0 },   \n\t{ 71, 428571 },   \n\t{ 55, 555556 },   \n\t{ 45, 454545 },   \n\t{ 38, 461538 },   \n\t{ 33, 333333 },   \n\t{ 29, 411765 },   \n\t{ 26, 315789 },   \n\t{ 23, 809524 },   \n\t{ 21, 739130 },   \n\t{ 20, 0 },   \n\t{ 17, 857143 },   \n\t{ 16, 129032 },   \n\t{ 14, 705882 },   \n\t{ 13, 513514 },   \n\t{ 12, 500000 },   \n\t{ 11, 111111 },   \n\t{ 10, 0 },   \n\t{ 5, 0 },   \n\t{ 3, 333333 },   \n\t{ 2, 500000 },   \n\t{ 1, 666667 },   \n\t{ 1, 250000 },   \n\t{ 1, 0 },   \n\t{ 0, 500000 },   \n\t{ 0, 333333 },   \n\t{ 0, 250000 },   \n};\n\nstatic const unsigned int sx9324_scan_period_table[] = {\n\t2,   15,  30,  45,   60,   90,\t 120,  200,\n\t400, 600, 800, 1000, 2000, 3000, 4000, 5000,\n};\n\nstatic const struct regmap_range sx9324_writable_reg_ranges[] = {\n\t \n\tregmap_reg_range(SX9324_REG_STAT2, SX9324_REG_STAT2),\n\tregmap_reg_range(SX9324_REG_IRQ_MSK, SX9324_REG_IRQ_CFG2),\n\tregmap_reg_range(SX9324_REG_GNRL_CTRL0, SX9324_REG_GNRL_CTRL1),\n\t \n\tregmap_reg_range(SX9324_REG_AFE_CTRL0, SX9324_REG_AFE_CTRL9),\n\tregmap_reg_range(SX9324_REG_PROX_CTRL0, SX9324_REG_PROX_CTRL7),\n\tregmap_reg_range(SX9324_REG_ADV_CTRL0, SX9324_REG_ADV_CTRL20),\n\tregmap_reg_range(SX9324_REG_PHASE_SEL, SX9324_REG_PHASE_SEL),\n\tregmap_reg_range(SX9324_REG_OFFSET_MSB, SX9324_REG_OFFSET_LSB),\n\tregmap_reg_range(SX9324_REG_RESET, SX9324_REG_RESET),\n};\n\nstatic const struct regmap_access_table sx9324_writeable_regs = {\n\t.yes_ranges = sx9324_writable_reg_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(sx9324_writable_reg_ranges),\n};\n\n \nstatic const struct regmap_range sx9324_non_readable_reg_ranges[] = {\n\tregmap_reg_range(SX9324_REG_IRQ_CFG2 + 1, SX9324_REG_GNRL_CTRL0 - 1),\n\tregmap_reg_range(SX9324_REG_GNRL_CTRL1 + 1, SX9324_REG_AFE_CTRL0 - 1),\n\tregmap_reg_range(SX9324_REG_AFE_CTRL9 + 1, SX9324_REG_PROX_CTRL0 - 1),\n\tregmap_reg_range(SX9324_REG_PROX_CTRL7 + 1, SX9324_REG_ADV_CTRL0 - 1),\n\tregmap_reg_range(SX9324_REG_ADV_CTRL20 + 1, SX9324_REG_PHASE_SEL - 1),\n\tregmap_reg_range(SX9324_REG_SAR_LSB + 1, SX9324_REG_RESET - 1),\n\tregmap_reg_range(SX9324_REG_RESET + 1, SX9324_REG_WHOAMI - 1),\n\tregmap_reg_range(SX9324_REG_WHOAMI + 1, SX9324_REG_REVISION - 1),\n};\n\nstatic const struct regmap_access_table sx9324_readable_regs = {\n\t.no_ranges = sx9324_non_readable_reg_ranges,\n\t.n_no_ranges = ARRAY_SIZE(sx9324_non_readable_reg_ranges),\n};\n\nstatic const struct regmap_range sx9324_volatile_reg_ranges[] = {\n\tregmap_reg_range(SX9324_REG_IRQ_SRC, SX9324_REG_STAT3),\n\tregmap_reg_range(SX9324_REG_USEFUL_MSB, SX9324_REG_DIFF_LSB),\n\tregmap_reg_range(SX9324_REG_SAR_MSB, SX9324_REG_SAR_LSB),\n\tregmap_reg_range(SX9324_REG_WHOAMI, SX9324_REG_WHOAMI),\n\tregmap_reg_range(SX9324_REG_REVISION, SX9324_REG_REVISION),\n};\n\nstatic const struct regmap_access_table sx9324_volatile_regs = {\n\t.yes_ranges = sx9324_volatile_reg_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(sx9324_volatile_reg_ranges),\n};\n\nstatic const struct regmap_config sx9324_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = SX9324_REG_REVISION,\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.wr_table = &sx9324_writeable_regs,\n\t.rd_table = &sx9324_readable_regs,\n\t.volatile_table = &sx9324_volatile_regs,\n};\n\nstatic int sx9324_read_prox_data(struct sx_common_data *data,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t __be16 *val)\n{\n\tint ret;\n\n\tret = regmap_write(data->regmap, SX9324_REG_PHASE_SEL, chan->channel);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_bulk_read(data->regmap, chan->address, val, sizeof(*val));\n}\n\n \nstatic int sx9324_wait_for_sample(struct sx_common_data *data)\n{\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(data->regmap, SX9324_REG_GNRL_CTRL0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tval = FIELD_GET(SX9324_REG_GNRL_CTRL0_SCANPERIOD_MASK, val);\n\n\tmsleep(sx9324_scan_period_table[val]);\n\n\treturn 0;\n}\n\nstatic int sx9324_read_gain(struct sx_common_data *data,\n\t\t\t    const struct iio_chan_spec *chan, int *val)\n{\n\tunsigned int reg, regval;\n\tint ret;\n\n\treg = SX9324_REG_PROX_CTRL0 + chan->channel / 2;\n\tret = regmap_read(data->regmap, reg, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tregval = FIELD_GET(SX9324_REG_PROX_CTRL0_GAIN_MASK, regval);\n\tif (regval)\n\t\tregval--;\n\telse if (regval == SX9324_REG_PROX_CTRL0_GAIN_RSVD ||\n\t\t regval > SX9324_REG_PROX_CTRL0_GAIN_8)\n\t\treturn -EINVAL;\n\n\t*val = 1 << regval;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int sx9324_read_samp_freq(struct sx_common_data *data,\n\t\t\t\t int *val, int *val2)\n{\n\tint ret;\n\tunsigned int regval;\n\n\tret = regmap_read(data->regmap, SX9324_REG_GNRL_CTRL0, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tregval = FIELD_GET(SX9324_REG_GNRL_CTRL0_SCANPERIOD_MASK, regval);\n\t*val = sx9324_samp_freq_table[regval].val;\n\t*val2 = sx9324_samp_freq_table[regval].val2;\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int sx9324_read_raw(struct iio_dev *indio_dev,\n\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = sx_common_read_proximity(data, chan, val);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = sx9324_read_gain(data, chan, val);\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn sx9324_read_samp_freq(data, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const int sx9324_gain_vals[] = { 1, 2, 4, 8 };\n\nstatic int sx9324_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type, int *length,\n\t\t\t     long mask)\n{\n\tif (chan->type != IIO_PROXIMITY)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\t*type = IIO_VAL_INT;\n\t\t*length = ARRAY_SIZE(sx9324_gain_vals);\n\t\t*vals = sx9324_gain_vals;\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t*length = ARRAY_SIZE(sx9324_samp_freq_table) * 2;\n\t\t*vals = (int *)sx9324_samp_freq_table;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sx9324_set_samp_freq(struct sx_common_data *data,\n\t\t\t\tint val, int val2)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(sx9324_samp_freq_table); i++)\n\t\tif (val == sx9324_samp_freq_table[i].val &&\n\t\t    val2 == sx9324_samp_freq_table[i].val2)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(sx9324_samp_freq_table))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->mutex);\n\n\tret = regmap_update_bits(data->regmap,\n\t\t\t\t SX9324_REG_GNRL_CTRL0,\n\t\t\t\t SX9324_REG_GNRL_CTRL0_SCANPERIOD_MASK, i);\n\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int sx9324_read_thresh(struct sx_common_data *data,\n\t\t\t      const struct iio_chan_spec *chan, int *val)\n{\n\tunsigned int regval;\n\tunsigned int reg;\n\tint ret;\n\n\t \n\treg = SX9324_REG_PROX_CTRL6 + chan->channel / 2;\n\tret = regmap_read(data->regmap, reg, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tif (regval <= 1)\n\t\t*val = regval;\n\telse\n\t\t*val = (regval * regval) / 2;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int sx9324_read_hysteresis(struct sx_common_data *data,\n\t\t\t\t  const struct iio_chan_spec *chan, int *val)\n{\n\tunsigned int regval, pthresh;\n\tint ret;\n\n\tret = sx9324_read_thresh(data, chan, &pthresh);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(data->regmap, SX9324_REG_PROX_CTRL5, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tregval = FIELD_GET(SX9324_REG_PROX_CTRL5_HYST_MASK, regval);\n\tif (!regval)\n\t\t*val = 0;\n\telse\n\t\t*val = pthresh >> (5 - regval);\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int sx9324_read_far_debounce(struct sx_common_data *data, int *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(data->regmap, SX9324_REG_PROX_CTRL5, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tregval = FIELD_GET(SX9324_REG_PROX_CTRL5_FAR_DEBOUNCE_MASK, regval);\n\tif (regval)\n\t\t*val = 1 << regval;\n\telse\n\t\t*val = 0;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int sx9324_read_close_debounce(struct sx_common_data *data, int *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(data->regmap, SX9324_REG_PROX_CTRL5, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tregval = FIELD_GET(SX9324_REG_PROX_CTRL5_CLOSE_DEBOUNCE_MASK, regval);\n\tif (regval)\n\t\t*val = 1 << regval;\n\telse\n\t\t*val = 0;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int sx9324_read_event_val(struct iio_dev *indio_dev,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t enum iio_event_type type,\n\t\t\t\t enum iio_event_direction dir,\n\t\t\t\t enum iio_event_info info, int *val, int *val2)\n{\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\n\tif (chan->type != IIO_PROXIMITY)\n\t\treturn -EINVAL;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\treturn sx9324_read_thresh(data, chan, val);\n\tcase IIO_EV_INFO_PERIOD:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\treturn sx9324_read_far_debounce(data, val);\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\treturn sx9324_read_close_debounce(data, val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_EV_INFO_HYSTERESIS:\n\t\treturn sx9324_read_hysteresis(data, chan, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sx9324_write_thresh(struct sx_common_data *data,\n\t\t\t       const struct iio_chan_spec *chan, int _val)\n{\n\tunsigned int reg, val = _val;\n\tint ret;\n\n\treg = SX9324_REG_PROX_CTRL6 + chan->channel / 2;\n\n\tif (val >= 1)\n\t\tval = int_sqrt(2 * val);\n\n\tif (val > 0xff)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->mutex);\n\tret = regmap_write(data->regmap, reg, val);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int sx9324_write_hysteresis(struct sx_common_data *data,\n\t\t\t\t   const struct iio_chan_spec *chan, int _val)\n{\n\tunsigned int hyst, val = _val;\n\tint ret, pthresh;\n\n\tret = sx9324_read_thresh(data, chan, &pthresh);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val == 0)\n\t\thyst = 0;\n\telse if (val >= pthresh >> 2)\n\t\thyst = 3;\n\telse if (val >= pthresh >> 3)\n\t\thyst = 2;\n\telse if (val >= pthresh >> 4)\n\t\thyst = 1;\n\telse\n\t\treturn -EINVAL;\n\n\thyst = FIELD_PREP(SX9324_REG_PROX_CTRL5_HYST_MASK, hyst);\n\tmutex_lock(&data->mutex);\n\tret = regmap_update_bits(data->regmap, SX9324_REG_PROX_CTRL5,\n\t\t\t\t SX9324_REG_PROX_CTRL5_HYST_MASK, hyst);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int sx9324_write_far_debounce(struct sx_common_data *data, int _val)\n{\n\tunsigned int regval, val = _val;\n\tint ret;\n\n\tif (val > 0)\n\t\tval = ilog2(val);\n\tif (!FIELD_FIT(SX9324_REG_PROX_CTRL5_FAR_DEBOUNCE_MASK, val))\n\t\treturn -EINVAL;\n\n\tregval = FIELD_PREP(SX9324_REG_PROX_CTRL5_FAR_DEBOUNCE_MASK, val);\n\n\tmutex_lock(&data->mutex);\n\tret = regmap_update_bits(data->regmap, SX9324_REG_PROX_CTRL5,\n\t\t\t\t SX9324_REG_PROX_CTRL5_FAR_DEBOUNCE_MASK,\n\t\t\t\t regval);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int sx9324_write_close_debounce(struct sx_common_data *data, int _val)\n{\n\tunsigned int regval, val = _val;\n\tint ret;\n\n\tif (val > 0)\n\t\tval = ilog2(val);\n\tif (!FIELD_FIT(SX9324_REG_PROX_CTRL5_CLOSE_DEBOUNCE_MASK, val))\n\t\treturn -EINVAL;\n\n\tregval = FIELD_PREP(SX9324_REG_PROX_CTRL5_CLOSE_DEBOUNCE_MASK, val);\n\n\tmutex_lock(&data->mutex);\n\tret = regmap_update_bits(data->regmap, SX9324_REG_PROX_CTRL5,\n\t\t\t\t SX9324_REG_PROX_CTRL5_CLOSE_DEBOUNCE_MASK,\n\t\t\t\t regval);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int sx9324_write_event_val(struct iio_dev *indio_dev,\n\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t  enum iio_event_type type,\n\t\t\t\t  enum iio_event_direction dir,\n\t\t\t\t  enum iio_event_info info, int val, int val2)\n{\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\n\tif (chan->type != IIO_PROXIMITY)\n\t\treturn -EINVAL;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\treturn sx9324_write_thresh(data, chan, val);\n\tcase IIO_EV_INFO_PERIOD:\n\t\tswitch (dir) {\n\t\tcase IIO_EV_DIR_RISING:\n\t\t\treturn sx9324_write_far_debounce(data, val);\n\t\tcase IIO_EV_DIR_FALLING:\n\t\t\treturn sx9324_write_close_debounce(data, val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_EV_INFO_HYSTERESIS:\n\t\treturn sx9324_write_hysteresis(data, chan, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sx9324_write_gain(struct sx_common_data *data,\n\t\t\t     const struct iio_chan_spec *chan, int val)\n{\n\tunsigned int gain, reg;\n\tint ret;\n\n\treg = SX9324_REG_PROX_CTRL0 + chan->channel / 2;\n\n\tgain = ilog2(val) + 1;\n\tif (val <= 0 || gain > SX9324_REG_PROX_CTRL0_GAIN_8)\n\t\treturn -EINVAL;\n\n\tgain = FIELD_PREP(SX9324_REG_PROX_CTRL0_GAIN_MASK, gain);\n\n\tmutex_lock(&data->mutex);\n\tret = regmap_update_bits(data->regmap, reg,\n\t\t\t\t SX9324_REG_PROX_CTRL0_GAIN_MASK,\n\t\t\t\t gain);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int sx9324_write_raw(struct iio_dev *indio_dev,\n\t\t\t    const struct iio_chan_spec *chan, int val, int val2,\n\t\t\t    long mask)\n{\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn sx9324_set_samp_freq(data, val, val2);\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\treturn sx9324_write_gain(data, chan, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct sx_common_reg_default sx9324_default_regs[] = {\n\t{ SX9324_REG_IRQ_MSK, 0x00 },\n\t{ SX9324_REG_IRQ_CFG0, 0x00, \"irq_cfg0\" },\n\t{ SX9324_REG_IRQ_CFG1, SX9324_REG_IRQ_CFG1_FAILCOND, \"irq_cfg1\" },\n\t{ SX9324_REG_IRQ_CFG2, 0x00, \"irq_cfg2\" },\n\t{ SX9324_REG_GNRL_CTRL0, SX9324_REG_GNRL_CTRL0_SCANPERIOD_100MS, \"gnrl_ctrl0\" },\n\t \n\t{ SX9324_REG_GNRL_CTRL1, SX9324_REG_GNRL_CTRL1_PAUSECTRL, \"gnrl_ctrl1\" },\n\n\t{ SX9324_REG_AFE_CTRL0, SX9324_REG_AFE_CTRL0_RINT_LOWEST, \"afe_ctrl0\" },\n\t{ SX9324_REG_AFE_CTRL3, 0x00, \"afe_ctrl3\" },\n\t{ SX9324_REG_AFE_CTRL4, SX9324_REG_AFE_CTRL4_FREQ_83_33HZ |\n\t\tSX9324_REG_AFE_CTRL4_RES_100, \"afe_ctrl4\" },\n\t{ SX9324_REG_AFE_CTRL6, 0x00, \"afe_ctrl6\" },\n\t{ SX9324_REG_AFE_CTRL7, SX9324_REG_AFE_CTRL4_FREQ_83_33HZ |\n\t\tSX9324_REG_AFE_CTRL4_RES_100, \"afe_ctrl7\" },\n\n\t \n\t{ SX9324_REG_AFE_PH0, 0x29, \"afe_ph0\" },\n\t{ SX9324_REG_AFE_PH1, 0x26, \"afe_ph1\" },\n\t{ SX9324_REG_AFE_PH2, 0x1a, \"afe_ph2\" },\n\t{ SX9324_REG_AFE_PH3, 0x16, \"afe_ph3\" },\n\n\t{ SX9324_REG_AFE_CTRL8, SX9324_REG_AFE_CTRL8_RESERVED |\n\t\tSX9324_REG_AFE_CTRL8_RESFILTIN_4KOHM, \"afe_ctrl8\" },\n\t{ SX9324_REG_AFE_CTRL9, SX9324_REG_AFE_CTRL9_AGAIN_1, \"afe_ctrl9\" },\n\n\t{ SX9324_REG_PROX_CTRL0,\n\t\tSX9324_REG_PROX_CTRL0_GAIN_1 << SX9324_REG_PROX_CTRL0_GAIN_SHIFT |\n\t\tSX9324_REG_PROX_CTRL0_RAWFILT_1P50, \"prox_ctrl0\" },\n\t{ SX9324_REG_PROX_CTRL1,\n\t\tSX9324_REG_PROX_CTRL0_GAIN_1 << SX9324_REG_PROX_CTRL0_GAIN_SHIFT |\n\t\tSX9324_REG_PROX_CTRL0_RAWFILT_1P50, \"prox_ctrl1\" },\n\t{ SX9324_REG_PROX_CTRL2, SX9324_REG_PROX_CTRL2_AVGNEG_THRESH_16K, \"prox_ctrl2\" },\n\t{ SX9324_REG_PROX_CTRL3, SX9324_REG_PROX_CTRL3_AVGDEB_2SAMPLES |\n\t\tSX9324_REG_PROX_CTRL3_AVGPOS_THRESH_16K, \"prox_ctrl3\" },\n\t{ SX9324_REG_PROX_CTRL4, SX9324_REG_PROX_CTRL4_AVGNEG_FILT_2 |\n\t\tSX9324_REG_PROX_CTRL4_AVGPOS_FILT_256, \"prox_ctrl4\" },\n\t{ SX9324_REG_PROX_CTRL5, 0x00, \"prox_ctrl5\" },\n\t{ SX9324_REG_PROX_CTRL6, SX9324_REG_PROX_CTRL6_PROXTHRESH_32, \"prox_ctrl6\" },\n\t{ SX9324_REG_PROX_CTRL7, SX9324_REG_PROX_CTRL6_PROXTHRESH_32, \"prox_ctrl7\" },\n\t{ SX9324_REG_ADV_CTRL0, 0x00, \"adv_ctrl0\" },\n\t{ SX9324_REG_ADV_CTRL1, 0x00, \"adv_ctrl1\" },\n\t{ SX9324_REG_ADV_CTRL2, 0x00, \"adv_ctrl2\" },\n\t{ SX9324_REG_ADV_CTRL3, 0x00, \"adv_ctrl3\" },\n\t{ SX9324_REG_ADV_CTRL4, 0x00, \"adv_ctrl4\" },\n\t{ SX9324_REG_ADV_CTRL5, SX9324_REG_ADV_CTRL5_STARTUP_SENSOR_1 |\n\t\tSX9324_REG_ADV_CTRL5_STARTUP_METHOD_1, \"adv_ctrl5\" },\n\t{ SX9324_REG_ADV_CTRL6, 0x00, \"adv_ctrl6\" },\n\t{ SX9324_REG_ADV_CTRL7, 0x00, \"adv_ctrl7\" },\n\t{ SX9324_REG_ADV_CTRL8, 0x00, \"adv_ctrl8\" },\n\t{ SX9324_REG_ADV_CTRL9, 0x00, \"adv_ctrl9\" },\n\t \n\t{ SX9324_REG_ADV_CTRL10, 0x00, \"adv_ctrl10\" },\n\t{ SX9324_REG_ADV_CTRL11, 0x00, \"adv_ctrl11\" },\n\t{ SX9324_REG_ADV_CTRL12, 0x00, \"adv_ctrl12\" },\n\t \n\t{ SX9324_REG_ADV_CTRL13, 0x00, \"adv_ctrl13\" },\n\t{ SX9324_REG_ADV_CTRL14, 0x00, \"adv_ctrl14\" },\n\t{ SX9324_REG_ADV_CTRL15, 0x00, \"adv_ctrl15\" },\n\t{ SX9324_REG_ADV_CTRL16, 0x00, \"adv_ctrl16\" },\n\t{ SX9324_REG_ADV_CTRL17, 0x00, \"adv_ctrl17\" },\n\t{ SX9324_REG_ADV_CTRL18, 0x00, \"adv_ctrl18\" },\n\t{ SX9324_REG_ADV_CTRL19,\n\t\tSX9324_REG_ADV_CTRL19_HIGHT_FAILURE_THRESH_SATURATION, \"adv_ctrl19\" },\n\t{ SX9324_REG_ADV_CTRL20,\n\t\tSX9324_REG_ADV_CTRL19_HIGHT_FAILURE_THRESH_SATURATION, \"adv_ctrl20\" },\n};\n\n \nstatic int sx9324_init_compensation(struct iio_dev *indio_dev)\n{\n\tstruct sx_common_data *data = iio_priv(indio_dev);\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, SX9324_REG_STAT2,\n\t\t\t\t SX9324_REG_STAT2_COMPSTAT_MASK,\n\t\t\t\t SX9324_REG_STAT2_COMPSTAT_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_read_poll_timeout(data->regmap, SX9324_REG_STAT2, val,\n\t\t\t\t\t!(val & SX9324_REG_STAT2_COMPSTAT_MASK),\n\t\t\t\t\t20000, 2000000);\n}\n\nstatic const struct sx_common_reg_default *\nsx9324_get_default_reg(struct device *dev, int idx,\n\t\t       struct sx_common_reg_default *reg_def)\n{\n\tstatic const char * const sx9324_rints[] = { \"lowest\", \"low\", \"high\",\n\t\t\"highest\" };\n\tstatic const char * const sx9324_csidle[] = { \"hi-z\", \"hi-z\", \"gnd\",\n\t\t\"vdd\" };\n#define SX9324_PIN_DEF \"semtech,ph0-pin\"\n#define SX9324_RESOLUTION_DEF \"semtech,ph01-resolution\"\n#define SX9324_PROXRAW_DEF \"semtech,ph01-proxraw-strength\"\n\tunsigned int pin_defs[SX9324_NUM_PINS];\n\tchar prop[] = SX9324_PROXRAW_DEF;\n\tu32 start = 0, raw = 0, pos = 0;\n\tint ret, count, ph, pin;\n\tconst char *res;\n\n\tmemcpy(reg_def, &sx9324_default_regs[idx], sizeof(*reg_def));\n\n\tsx_common_get_raw_register_config(dev, reg_def);\n\tswitch (reg_def->reg) {\n\tcase SX9324_REG_AFE_PH0:\n\tcase SX9324_REG_AFE_PH1:\n\tcase SX9324_REG_AFE_PH2:\n\tcase SX9324_REG_AFE_PH3:\n\t\tph = reg_def->reg - SX9324_REG_AFE_PH0;\n\t\tsnprintf(prop, ARRAY_SIZE(prop), \"semtech,ph%d-pin\", ph);\n\n\t\tcount = device_property_count_u32(dev, prop);\n\t\tif (count != ARRAY_SIZE(pin_defs))\n\t\t\tbreak;\n\t\tret = device_property_read_u32_array(dev, prop, pin_defs,\n\t\t\t\t\t\t     ARRAY_SIZE(pin_defs));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tfor (pin = 0; pin < SX9324_NUM_PINS; pin++)\n\t\t\traw |= (pin_defs[pin] << (2 * pin)) &\n\t\t\t       SX9324_REG_AFE_PH0_PIN_MASK(pin);\n\t\treg_def->def = raw;\n\t\tbreak;\n\tcase SX9324_REG_AFE_CTRL0:\n\t\tret = device_property_read_string(dev,\n\t\t\t\t\"semtech,cs-idle-sleep\", &res);\n\t\tif (!ret)\n\t\t\tret = match_string(sx9324_csidle, ARRAY_SIZE(sx9324_csidle), res);\n\t\tif (ret >= 0) {\n\t\t\treg_def->def &= ~SX9324_REG_AFE_CTRL0_CSIDLE_MASK;\n\t\t\treg_def->def |= ret << SX9324_REG_AFE_CTRL0_CSIDLE_SHIFT;\n\t\t}\n\n\t\tret = device_property_read_string(dev,\n\t\t\t\t\"semtech,int-comp-resistor\", &res);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = match_string(sx9324_rints, ARRAY_SIZE(sx9324_rints), res);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\treg_def->def &= ~SX9324_REG_AFE_CTRL0_RINT_MASK;\n\t\treg_def->def |= ret << SX9324_REG_AFE_CTRL0_RINT_SHIFT;\n\t\tbreak;\n\tcase SX9324_REG_AFE_CTRL4:\n\tcase SX9324_REG_AFE_CTRL7:\n\t\tif (reg_def->reg == SX9324_REG_AFE_CTRL4)\n\t\t\tstrncpy(prop, \"semtech,ph01-resolution\",\n\t\t\t\tARRAY_SIZE(prop));\n\t\telse\n\t\t\tstrncpy(prop, \"semtech,ph23-resolution\",\n\t\t\t\tARRAY_SIZE(prop));\n\n\t\tret = device_property_read_u32(dev, prop, &raw);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\traw = ilog2(raw) - 3;\n\n\t\treg_def->def &= ~SX9324_REG_AFE_CTRL4_RESOLUTION_MASK;\n\t\treg_def->def |= FIELD_PREP(SX9324_REG_AFE_CTRL4_RESOLUTION_MASK,\n\t\t\t\t\t   raw);\n\t\tbreak;\n\tcase SX9324_REG_AFE_CTRL8:\n\t\tret = device_property_read_u32(dev,\n\t\t\t\t\"semtech,input-precharge-resistor-ohms\",\n\t\t\t\t&raw);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\treg_def->def &= ~SX9324_REG_AFE_CTRL8_RESFILTIN_MASK;\n\t\treg_def->def |= FIELD_PREP(SX9324_REG_AFE_CTRL8_RESFILTIN_MASK,\n\t\t\t\t\t   raw / 2000);\n\t\tbreak;\n\n\tcase SX9324_REG_AFE_CTRL9:\n\t\tret = device_property_read_u32(dev,\n\t\t\t\t\"semtech,input-analog-gain\", &raw);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t \n\t\treg_def->def &= ~SX9324_REG_AFE_CTRL9_AGAIN_MASK;\n\t\treg_def->def |= FIELD_PREP(SX9324_REG_AFE_CTRL9_AGAIN_MASK,\n\t\t\t\t\t   6 + raw * (raw + 3) / 2);\n\t\tbreak;\n\n\tcase SX9324_REG_ADV_CTRL5:\n\t\tret = device_property_read_u32(dev, \"semtech,startup-sensor\",\n\t\t\t\t\t       &start);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\treg_def->def &= ~SX9324_REG_ADV_CTRL5_STARTUPSENS_MASK;\n\t\treg_def->def |= FIELD_PREP(SX9324_REG_ADV_CTRL5_STARTUPSENS_MASK,\n\t\t\t\t\t   start);\n\t\tbreak;\n\tcase SX9324_REG_PROX_CTRL4:\n\t\tret = device_property_read_u32(dev, \"semtech,avg-pos-strength\",\n\t\t\t\t\t       &pos);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\traw = clamp(ilog2(pos), 3, 11) - (pos >= 32 ? 4 : 3);\n\n\t\treg_def->def &= ~SX9324_REG_PROX_CTRL4_AVGPOSFILT_MASK;\n\t\treg_def->def |= FIELD_PREP(SX9324_REG_PROX_CTRL4_AVGPOSFILT_MASK,\n\t\t\t\t\t   raw);\n\t\tbreak;\n\tcase SX9324_REG_PROX_CTRL0:\n\tcase SX9324_REG_PROX_CTRL1:\n\t\tif (reg_def->reg == SX9324_REG_PROX_CTRL0)\n\t\t\tstrncpy(prop, \"semtech,ph01-proxraw-strength\",\n\t\t\t\tARRAY_SIZE(prop));\n\t\telse\n\t\t\tstrncpy(prop, \"semtech,ph23-proxraw-strength\",\n\t\t\t\tARRAY_SIZE(prop));\n\t\tret = device_property_read_u32(dev, prop, &raw);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\treg_def->def &= ~SX9324_REG_PROX_CTRL0_RAWFILT_MASK;\n\t\treg_def->def |= FIELD_PREP(SX9324_REG_PROX_CTRL0_RAWFILT_MASK,\n\t\t\t\t\t   raw);\n\t\tbreak;\n\t}\n\treturn reg_def;\n}\n\nstatic int sx9324_check_whoami(struct device *dev,\n\t\t\t       struct iio_dev *indio_dev)\n{\n\t \n\tindio_dev->name = \"sx9324\";\n\treturn 0;\n}\n\nstatic const struct sx_common_chip_info sx9324_chip_info = {\n\t.reg_stat = SX9324_REG_STAT0,\n\t.reg_irq_msk = SX9324_REG_IRQ_MSK,\n\t.reg_enable_chan = SX9324_REG_GNRL_CTRL1,\n\t.reg_reset = SX9324_REG_RESET,\n\n\t.mask_enable_chan = SX9324_REG_GNRL_CTRL1_PHEN_MASK,\n\t.irq_msk_offset = 3,\n\t.num_channels = SX9324_NUM_CHANNELS,\n\t.num_default_regs = ARRAY_SIZE(sx9324_default_regs),\n\n\t.ops = {\n\t\t.read_prox_data = sx9324_read_prox_data,\n\t\t.check_whoami = sx9324_check_whoami,\n\t\t.init_compensation = sx9324_init_compensation,\n\t\t.wait_for_sample = sx9324_wait_for_sample,\n\t\t.get_default_reg = sx9324_get_default_reg,\n\t},\n\n\t.iio_channels = sx9324_channels,\n\t.num_iio_channels = ARRAY_SIZE(sx9324_channels),\n\t.iio_info =  {\n\t\t.read_raw = sx9324_read_raw,\n\t\t.read_avail = sx9324_read_avail,\n\t\t.read_event_value = sx9324_read_event_val,\n\t\t.write_event_value = sx9324_write_event_val,\n\t\t.write_raw = sx9324_write_raw,\n\t\t.read_event_config = sx_common_read_event_config,\n\t\t.write_event_config = sx_common_write_event_config,\n\t},\n};\n\nstatic int sx9324_probe(struct i2c_client *client)\n{\n\treturn sx_common_probe(client, &sx9324_chip_info, &sx9324_regmap_config);\n}\n\nstatic int sx9324_suspend(struct device *dev)\n{\n\tstruct sx_common_data *data = iio_priv(dev_get_drvdata(dev));\n\tunsigned int regval;\n\tint ret;\n\n\tdisable_irq_nosync(data->client->irq);\n\n\tmutex_lock(&data->mutex);\n\tret = regmap_read(data->regmap, SX9324_REG_GNRL_CTRL1, &regval);\n\n\tdata->suspend_ctrl =\n\t\tFIELD_GET(SX9324_REG_GNRL_CTRL1_PHEN_MASK, regval);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = regmap_write(data->regmap, SX9324_REG_GNRL_CTRL1, 0);\n\nout:\n\tmutex_unlock(&data->mutex);\n\treturn ret;\n}\n\nstatic int sx9324_resume(struct device *dev)\n{\n\tstruct sx_common_data *data = iio_priv(dev_get_drvdata(dev));\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = regmap_write(data->regmap, SX9324_REG_GNRL_CTRL1,\n\t\t\t   data->suspend_ctrl | SX9324_REG_GNRL_CTRL1_PAUSECTRL);\n\tmutex_unlock(&data->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tenable_irq(data->client->irq);\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(sx9324_pm_ops, sx9324_suspend, sx9324_resume);\n\nstatic const struct acpi_device_id sx9324_acpi_match[] = {\n\t{ \"STH9324\", SX9324_WHOAMI_VALUE },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, sx9324_acpi_match);\n\nstatic const struct of_device_id sx9324_of_match[] = {\n\t{ .compatible = \"semtech,sx9324\", (void *)SX9324_WHOAMI_VALUE },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sx9324_of_match);\n\nstatic const struct i2c_device_id sx9324_id[] = {\n\t{ \"sx9324\", SX9324_WHOAMI_VALUE },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sx9324_id);\n\nstatic struct i2c_driver sx9324_driver = {\n\t.driver = {\n\t\t.name\t= \"sx9324\",\n\t\t.acpi_match_table = sx9324_acpi_match,\n\t\t.of_match_table = sx9324_of_match,\n\t\t.pm = pm_sleep_ptr(&sx9324_pm_ops),\n\n\t\t \n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t\t= sx9324_probe,\n\t.id_table\t= sx9324_id,\n};\nmodule_i2c_driver(sx9324_driver);\n\nMODULE_AUTHOR(\"Gwendal Grignou <gwendal@chromium.org>\");\nMODULE_DESCRIPTION(\"Driver for Semtech SX9324 proximity sensor\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(SEMTECH_PROX);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}