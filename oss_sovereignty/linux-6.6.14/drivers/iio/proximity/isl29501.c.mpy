{
  "module_name": "isl29501.c",
  "hash_id": "3b596f45e61d587ad00cd823f6dbde9b99f00a30cfded5bc4e690dd6a4066849",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/proximity/isl29501.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/mod_devicetable.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n\n \n#define ISL29501_DEVICE_ID\t\t\t0x00\n#define ISL29501_ID\t\t\t\t0x0A\n\n \n#define ISL29501_INTEGRATION_PERIOD\t\t0x10\n#define ISL29501_SAMPLE_PERIOD\t\t\t0x11\n\n \n#define ISL29501_CROSSTALK_I_MSB\t\t0x24\n#define ISL29501_CROSSTALK_I_LSB\t\t0x25\n#define ISL29501_CROSSTALK_I_EXPONENT\t\t0x26\n#define ISL29501_CROSSTALK_Q_MSB\t\t0x27\n#define ISL29501_CROSSTALK_Q_LSB\t\t0x28\n#define ISL29501_CROSSTALK_Q_EXPONENT\t\t0x29\n#define ISL29501_CROSSTALK_GAIN_MSB\t\t0x2A\n#define ISL29501_CROSSTALK_GAIN_LSB\t\t0x2B\n#define ISL29501_MAGNITUDE_REF_EXP\t\t0x2C\n#define ISL29501_MAGNITUDE_REF_MSB\t\t0x2D\n#define ISL29501_MAGNITUDE_REF_LSB\t\t0x2E\n#define ISL29501_PHASE_OFFSET_MSB\t\t0x2F\n#define ISL29501_PHASE_OFFSET_LSB\t\t0x30\n\n \n#define ISL29501_DRIVER_RANGE\t\t\t0x90\n#define ISL29501_EMITTER_DAC\t\t\t0x91\n\n#define ISL29501_COMMAND_REGISTER\t\t0xB0\n\n \n#define ISL29501_EMUL_SAMPLE_START_PIN\t\t0x49\n#define ISL29501_RESET_ALL_REGISTERS\t\t0xD7\n#define ISL29501_RESET_INT_SM\t\t\t0xD1\n\n \n#define ISL29501_TEMP_REFERENCE\t\t\t0x31\n#define ISL29501_PHASE_EXPONENT\t\t\t0x33\n#define ISL29501_TEMP_COEFF_A\t\t\t0x34\n#define ISL29501_TEMP_COEFF_B\t\t\t0x39\n#define ISL29501_AMBIANT_COEFF_A\t\t0x36\n#define ISL29501_AMBIANT_COEFF_B\t\t0x3B\n\n \n#define ISL29501_DISTANCE_MSB_DATA\t\t0xD1\n#define ISL29501_DISTANCE_LSB_DATA\t\t0xD2\n#define ISL29501_PRECISION_MSB\t\t\t0xD3\n#define ISL29501_PRECISION_LSB\t\t\t0xD4\n#define ISL29501_MAGNITUDE_EXPONENT\t\t0xD5\n#define ISL29501_MAGNITUDE_MSB\t\t\t0xD6\n#define ISL29501_MAGNITUDE_LSB\t\t\t0xD7\n#define ISL29501_PHASE_MSB\t\t\t0xD8\n#define ISL29501_PHASE_LSB\t\t\t0xD9\n#define ISL29501_I_RAW_EXPONENT\t\t\t0xDA\n#define ISL29501_I_RAW_MSB\t\t\t0xDB\n#define ISL29501_I_RAW_LSB\t\t\t0xDC\n#define ISL29501_Q_RAW_EXPONENT\t\t\t0xDD\n#define ISL29501_Q_RAW_MSB\t\t\t0xDE\n#define ISL29501_Q_RAW_LSB\t\t\t0xDF\n#define ISL29501_DIE_TEMPERATURE\t\t0xE2\n#define ISL29501_AMBIENT_LIGHT\t\t\t0xE3\n#define ISL29501_GAIN_MSB\t\t\t0xE6\n#define ISL29501_GAIN_LSB\t\t\t0xE7\n\n#define ISL29501_MAX_EXP_VAL 15\n\n#define ISL29501_INT_TIME_AVAILABLE \\\n\t\"0.00007 0.00014 0.00028 0.00057 0.00114 \" \\\n\t\"0.00228 0.00455 0.00910 0.01820 0.03640 \" \\\n\t\"0.07281 0.14561\"\n\n#define ISL29501_CURRENT_SCALE_AVAILABLE \\\n\t\"0.0039 0.0078 0.0118 0.0157 0.0196 \" \\\n\t\"0.0235 0.0275 0.0314 0.0352 0.0392 \" \\\n\t\"0.0431 0.0471 0.0510 0.0549 0.0588\"\n\nenum isl29501_correction_coeff {\n\tCOEFF_TEMP_A,\n\tCOEFF_TEMP_B,\n\tCOEFF_LIGHT_A,\n\tCOEFF_LIGHT_B,\n\tCOEFF_MAX,\n};\n\nstruct isl29501_private {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\t \n\tunsigned int shadow_coeffs[COEFF_MAX];\n};\n\nenum isl29501_register_name {\n\tREG_DISTANCE,\n\tREG_PHASE,\n\tREG_TEMPERATURE,\n\tREG_AMBIENT_LIGHT,\n\tREG_GAIN,\n\tREG_GAIN_BIAS,\n\tREG_PHASE_EXP,\n\tREG_CALIB_PHASE_TEMP_A,\n\tREG_CALIB_PHASE_TEMP_B,\n\tREG_CALIB_PHASE_LIGHT_A,\n\tREG_CALIB_PHASE_LIGHT_B,\n\tREG_DISTANCE_BIAS,\n\tREG_TEMPERATURE_BIAS,\n\tREG_INT_TIME,\n\tREG_SAMPLE_TIME,\n\tREG_DRIVER_RANGE,\n\tREG_EMITTER_DAC,\n};\n\nstruct isl29501_register_desc {\n\tu8 msb;\n\tu8 lsb;\n};\n\nstatic const struct isl29501_register_desc isl29501_registers[] = {\n\t[REG_DISTANCE] = {\n\t\t.msb = ISL29501_DISTANCE_MSB_DATA,\n\t\t.lsb = ISL29501_DISTANCE_LSB_DATA,\n\t},\n\t[REG_PHASE] = {\n\t\t.msb = ISL29501_PHASE_MSB,\n\t\t.lsb = ISL29501_PHASE_LSB,\n\t},\n\t[REG_TEMPERATURE] = {\n\t\t.lsb = ISL29501_DIE_TEMPERATURE,\n\t},\n\t[REG_AMBIENT_LIGHT] = {\n\t\t.lsb = ISL29501_AMBIENT_LIGHT,\n\t},\n\t[REG_GAIN] = {\n\t\t.msb = ISL29501_GAIN_MSB,\n\t\t.lsb = ISL29501_GAIN_LSB,\n\t},\n\t[REG_GAIN_BIAS] = {\n\t\t.msb = ISL29501_CROSSTALK_GAIN_MSB,\n\t\t.lsb = ISL29501_CROSSTALK_GAIN_LSB,\n\t},\n\t[REG_PHASE_EXP] = {\n\t\t.lsb = ISL29501_PHASE_EXPONENT,\n\t},\n\t[REG_CALIB_PHASE_TEMP_A] = {\n\t\t.lsb = ISL29501_TEMP_COEFF_A,\n\t},\n\t[REG_CALIB_PHASE_TEMP_B] = {\n\t\t.lsb = ISL29501_TEMP_COEFF_B,\n\t},\n\t[REG_CALIB_PHASE_LIGHT_A] = {\n\t\t.lsb = ISL29501_AMBIANT_COEFF_A,\n\t},\n\t[REG_CALIB_PHASE_LIGHT_B] = {\n\t\t.lsb = ISL29501_AMBIANT_COEFF_B,\n\t},\n\t[REG_DISTANCE_BIAS] = {\n\t\t.msb = ISL29501_PHASE_OFFSET_MSB,\n\t\t.lsb = ISL29501_PHASE_OFFSET_LSB,\n\t},\n\t[REG_TEMPERATURE_BIAS] = {\n\t\t.lsb = ISL29501_TEMP_REFERENCE,\n\t},\n\t[REG_INT_TIME] = {\n\t\t.lsb = ISL29501_INTEGRATION_PERIOD,\n\t},\n\t[REG_SAMPLE_TIME] = {\n\t\t.lsb = ISL29501_SAMPLE_PERIOD,\n\t},\n\t[REG_DRIVER_RANGE] = {\n\t\t.lsb = ISL29501_DRIVER_RANGE,\n\t},\n\t[REG_EMITTER_DAC] = {\n\t\t.lsb = ISL29501_EMITTER_DAC,\n\t},\n};\n\nstatic int isl29501_register_read(struct isl29501_private *isl29501,\n\t\t\t\t  enum isl29501_register_name name,\n\t\t\t\t  u32 *val)\n{\n\tconst struct isl29501_register_desc *reg = &isl29501_registers[name];\n\tu8 msb = 0, lsb = 0;\n\ts32 ret;\n\n\tmutex_lock(&isl29501->lock);\n\tif (reg->msb) {\n\t\tret = i2c_smbus_read_byte_data(isl29501->client, reg->msb);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tmsb = ret;\n\t}\n\n\tif (reg->lsb) {\n\t\tret = i2c_smbus_read_byte_data(isl29501->client, reg->lsb);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tlsb = ret;\n\t}\n\tmutex_unlock(&isl29501->lock);\n\n\t*val = (msb << 8) + lsb;\n\n\treturn 0;\nerr:\n\tmutex_unlock(&isl29501->lock);\n\n\treturn ret;\n}\n\nstatic u32 isl29501_register_write(struct isl29501_private *isl29501,\n\t\t\t\t   enum isl29501_register_name name,\n\t\t\t\t   u32 value)\n{\n\tconst struct isl29501_register_desc *reg = &isl29501_registers[name];\n\tint ret;\n\n\tif (!reg->msb && value > U8_MAX)\n\t\treturn -ERANGE;\n\n\tif (value > U16_MAX)\n\t\treturn -ERANGE;\n\n\tmutex_lock(&isl29501->lock);\n\tif (reg->msb) {\n\t\tret = i2c_smbus_write_byte_data(isl29501->client,\n\t\t\t\t\t\treg->msb, value >> 8);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tret = i2c_smbus_write_byte_data(isl29501->client, reg->lsb, value);\n\nerr:\n\tmutex_unlock(&isl29501->lock);\n\treturn ret;\n}\n\nstatic ssize_t isl29501_read_ext(struct iio_dev *indio_dev,\n\t\t\t\t uintptr_t private,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t char *buf)\n{\n\tstruct isl29501_private *isl29501 = iio_priv(indio_dev);\n\tenum isl29501_register_name reg = private;\n\tint ret;\n\tu32 value, gain, coeff, exp;\n\n\tswitch (reg) {\n\tcase REG_GAIN:\n\tcase REG_GAIN_BIAS:\n\t\tret = isl29501_register_read(isl29501, reg, &gain);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tvalue = gain;\n\t\tbreak;\n\tcase REG_CALIB_PHASE_TEMP_A:\n\tcase REG_CALIB_PHASE_TEMP_B:\n\tcase REG_CALIB_PHASE_LIGHT_A:\n\tcase REG_CALIB_PHASE_LIGHT_B:\n\t\tret = isl29501_register_read(isl29501, REG_PHASE_EXP, &exp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = isl29501_register_read(isl29501, reg, &coeff);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tvalue = coeff << exp;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sprintf(buf, \"%u\\n\", value);\n}\n\nstatic int isl29501_set_shadow_coeff(struct isl29501_private *isl29501,\n\t\t\t\t     enum isl29501_register_name reg,\n\t\t\t\t     unsigned int val)\n{\n\tenum isl29501_correction_coeff coeff;\n\n\tswitch (reg) {\n\tcase REG_CALIB_PHASE_TEMP_A:\n\t\tcoeff = COEFF_TEMP_A;\n\t\tbreak;\n\tcase REG_CALIB_PHASE_TEMP_B:\n\t\tcoeff = COEFF_TEMP_B;\n\t\tbreak;\n\tcase REG_CALIB_PHASE_LIGHT_A:\n\t\tcoeff = COEFF_LIGHT_A;\n\t\tbreak;\n\tcase REG_CALIB_PHASE_LIGHT_B:\n\t\tcoeff = COEFF_LIGHT_B;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tisl29501->shadow_coeffs[coeff] = val;\n\n\treturn 0;\n}\n\nstatic int isl29501_write_coeff(struct isl29501_private *isl29501,\n\t\t\t\tenum isl29501_correction_coeff coeff,\n\t\t\t\tint val)\n{\n\tenum isl29501_register_name reg;\n\n\tswitch (coeff) {\n\tcase COEFF_TEMP_A:\n\t\treg = REG_CALIB_PHASE_TEMP_A;\n\t\tbreak;\n\tcase COEFF_TEMP_B:\n\t\treg = REG_CALIB_PHASE_TEMP_B;\n\t\tbreak;\n\tcase COEFF_LIGHT_A:\n\t\treg = REG_CALIB_PHASE_LIGHT_A;\n\t\tbreak;\n\tcase COEFF_LIGHT_B:\n\t\treg = REG_CALIB_PHASE_LIGHT_B;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn isl29501_register_write(isl29501, reg, val);\n}\n\nstatic unsigned int isl29501_find_corr_exp(unsigned int val,\n\t\t\t\t\t   unsigned int max_exp,\n\t\t\t\t\t   unsigned int max_mantissa)\n{\n\tunsigned int exp = 1;\n\n\t \n\tif (val <= max_mantissa)\n\t\treturn 0;\n\n\twhile ((val >> exp) > max_mantissa) {\n\t\texp++;\n\n\t\tif (exp > max_exp)\n\t\t\treturn max_exp;\n\t}\n\n\treturn exp;\n}\n\nstatic ssize_t isl29501_write_ext(struct iio_dev *indio_dev,\n\t\t\t\t  uintptr_t private,\n\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct isl29501_private *isl29501 = iio_priv(indio_dev);\n\tenum isl29501_register_name reg = private;\n\tunsigned int val;\n\tint max_exp = 0;\n\tint ret;\n\tint i;\n\n\tret = kstrtouint(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (reg) {\n\tcase REG_GAIN_BIAS:\n\t\tif (val > U16_MAX)\n\t\t\treturn -ERANGE;\n\n\t\tret = isl29501_register_write(isl29501, reg, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\tcase REG_CALIB_PHASE_TEMP_A:\n\tcase REG_CALIB_PHASE_TEMP_B:\n\tcase REG_CALIB_PHASE_LIGHT_A:\n\tcase REG_CALIB_PHASE_LIGHT_B:\n\n\t\tif (val > (U8_MAX << ISL29501_MAX_EXP_VAL))\n\t\t\treturn -ERANGE;\n\n\t\t \n\t\tret = isl29501_set_shadow_coeff(isl29501, reg, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tfor (i = 0; i < COEFF_MAX; i++) {\n\t\t\tint corr;\n\t\t\tint corr_exp;\n\n\t\t\tcorr = isl29501->shadow_coeffs[i];\n\t\t\tcorr_exp = isl29501_find_corr_exp(corr,\n\t\t\t\t\t\t\t  ISL29501_MAX_EXP_VAL,\n\t\t\t\t\t\t\t  U8_MAX / 2);\n\t\t\tdev_dbg(&isl29501->client->dev,\n\t\t\t\t\"found exp of corr(%d) = %d\\n\", corr, corr_exp);\n\n\t\t\tmax_exp = max(max_exp, corr_exp);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < COEFF_MAX; i++) {\n\t\t\tint corr;\n\t\t\tint mantissa;\n\n\t\t\tcorr = isl29501->shadow_coeffs[i];\n\t\t\tif (!corr)\n\t\t\t\tcontinue;\n\n\t\t\tmantissa = corr >> max_exp;\n\n\t\t\tret = isl29501_write_coeff(isl29501, i, mantissa);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = isl29501_register_write(isl29501, REG_PHASE_EXP, max_exp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn len;\n}\n\n#define _ISL29501_EXT_INFO(_name, _ident) { \\\n\t.name = _name, \\\n\t.read = isl29501_read_ext, \\\n\t.write = isl29501_write_ext, \\\n\t.private = _ident, \\\n\t.shared = IIO_SEPARATE, \\\n}\n\nstatic const struct iio_chan_spec_ext_info isl29501_ext_info[] = {\n\t_ISL29501_EXT_INFO(\"agc_gain\", REG_GAIN),\n\t_ISL29501_EXT_INFO(\"agc_gain_bias\", REG_GAIN_BIAS),\n\t_ISL29501_EXT_INFO(\"calib_phase_temp_a\", REG_CALIB_PHASE_TEMP_A),\n\t_ISL29501_EXT_INFO(\"calib_phase_temp_b\", REG_CALIB_PHASE_TEMP_B),\n\t_ISL29501_EXT_INFO(\"calib_phase_light_a\", REG_CALIB_PHASE_LIGHT_A),\n\t_ISL29501_EXT_INFO(\"calib_phase_light_b\", REG_CALIB_PHASE_LIGHT_B),\n\t{ },\n};\n\n#define ISL29501_DISTANCE_SCAN_INDEX 0\n#define ISL29501_TIMESTAMP_SCAN_INDEX 1\n\nstatic const struct iio_chan_spec isl29501_channels[] = {\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.scan_index = ISL29501_DISTANCE_SCAN_INDEX,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW)   |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_INT_TIME) |\n\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.ext_info = isl29501_ext_info,\n\t},\n\t{\n\t\t.type = IIO_PHASE,\n\t\t.scan_index = -1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t},\n\t{\n\t\t.type = IIO_CURRENT,\n\t\t.scan_index = -1,\n\t\t.output = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.scan_index = -1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE)     |\n\t\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\n\t},\n\t{\n\t\t.type = IIO_INTENSITY,\n\t\t.scan_index = -1,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_LIGHT_CLEAR,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(ISL29501_TIMESTAMP_SCAN_INDEX),\n};\n\nstatic int isl29501_reset_registers(struct isl29501_private *isl29501)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(isl29501->client,\n\t\t\t\t\tISL29501_COMMAND_REGISTER,\n\t\t\t\t\tISL29501_RESET_ALL_REGISTERS);\n\tif (ret < 0) {\n\t\tdev_err(&isl29501->client->dev,\n\t\t\t\"cannot reset registers %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_write_byte_data(isl29501->client,\n\t\t\t\t\tISL29501_COMMAND_REGISTER,\n\t\t\t\t\tISL29501_RESET_INT_SM);\n\tif (ret < 0)\n\t\tdev_err(&isl29501->client->dev,\n\t\t\t\"cannot reset state machine %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int isl29501_begin_acquisition(struct isl29501_private *isl29501)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(isl29501->client,\n\t\t\t\t\tISL29501_COMMAND_REGISTER,\n\t\t\t\t\tISL29501_EMUL_SAMPLE_START_PIN);\n\tif (ret < 0)\n\t\tdev_err(&isl29501->client->dev,\n\t\t\t\"cannot begin acquisition %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic IIO_CONST_ATTR_INT_TIME_AVAIL(ISL29501_INT_TIME_AVAILABLE);\nstatic IIO_CONST_ATTR(out_current_scale_available,\n\t\t      ISL29501_CURRENT_SCALE_AVAILABLE);\n\nstatic struct attribute *isl29501_attributes[] = {\n\t&iio_const_attr_integration_time_available.dev_attr.attr,\n\t&iio_const_attr_out_current_scale_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group isl29501_attribute_group = {\n\t.attrs = isl29501_attributes,\n};\n\nstatic const int isl29501_current_scale_table[][2] = {\n\t{0, 3900}, {0, 7800}, {0, 11800}, {0, 15700},\n\t{0, 19600}, {0, 23500}, {0, 27500}, {0, 31400},\n\t{0, 35200}, {0, 39200}, {0, 43100}, {0, 47100},\n\t{0, 51000}, {0, 54900}, {0, 58800},\n};\n\nstatic const int isl29501_int_time[][2] = {\n\t{0, 70},     \n\t{0, 140},    \n\t{0, 280},    \n\t{0, 570},    \n\t{0, 1140},   \n\t{0, 2280},   \n\t{0, 4550},   \n\t{0, 9100},   \n\t{0, 18200},  \n\t{0, 36400},  \n\t{0, 72810},  \n\t{0, 145610}  \n};\n\nstatic int isl29501_get_raw(struct isl29501_private *isl29501,\n\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t    int *raw)\n{\n\tint ret;\n\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\tret = isl29501_register_read(isl29501, REG_DISTANCE, raw);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_INTENSITY:\n\t\tret = isl29501_register_read(isl29501,\n\t\t\t\t\t     REG_AMBIENT_LIGHT,\n\t\t\t\t\t     raw);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_PHASE:\n\t\tret = isl29501_register_read(isl29501, REG_PHASE, raw);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CURRENT:\n\t\tret = isl29501_register_read(isl29501, REG_EMITTER_DAC, raw);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_TEMP:\n\t\tret = isl29501_register_read(isl29501, REG_TEMPERATURE, raw);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int isl29501_get_scale(struct isl29501_private *isl29501,\n\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t      int *val, int *val2)\n{\n\tint ret;\n\tu32 current_scale;\n\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\t \n\t\t*val = 3331;\n\t\t*val2 = 6553600;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase IIO_PHASE:\n\t\t \n\t\t*val = 0;\n\t\t*val2 = 95874;\n\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_INTENSITY:\n\t\t \n\t\t*val = 35;\n\t\t*val2 = 10000;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase IIO_CURRENT:\n\t\tret = isl29501_register_read(isl29501,\n\t\t\t\t\t     REG_DRIVER_RANGE,\n\t\t\t\t\t     &current_scale);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (current_scale > ARRAY_SIZE(isl29501_current_scale_table))\n\t\t\treturn -EINVAL;\n\n\t\tif (!current_scale) {\n\t\t\t*val = 0;\n\t\t\t*val2 = 0;\n\t\t\treturn IIO_VAL_INT;\n\t\t}\n\n\t\t*val = isl29501_current_scale_table[current_scale - 1][0];\n\t\t*val2 = isl29501_current_scale_table[current_scale - 1][1];\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_TEMP:\n\t\t \n\t\t*val = 125;\n\t\t*val2 = 100000;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int isl29501_get_calibbias(struct isl29501_private *isl29501,\n\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t  int *bias)\n{\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\treturn isl29501_register_read(isl29501,\n\t\t\t\t\t      REG_DISTANCE_BIAS,\n\t\t\t\t\t      bias);\n\tcase IIO_TEMP:\n\t\treturn isl29501_register_read(isl29501,\n\t\t\t\t\t      REG_TEMPERATURE_BIAS,\n\t\t\t\t\t      bias);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int isl29501_get_inttime(struct isl29501_private *isl29501,\n\t\t\t\tint *val, int *val2)\n{\n\tint ret;\n\tu32 inttime;\n\n\tret = isl29501_register_read(isl29501, REG_INT_TIME, &inttime);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (inttime >= ARRAY_SIZE(isl29501_int_time))\n\t\treturn -EINVAL;\n\n\t*val = isl29501_int_time[inttime][0];\n\t*val2 = isl29501_int_time[inttime][1];\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int isl29501_get_freq(struct isl29501_private *isl29501,\n\t\t\t     int *val, int *val2)\n{\n\tint ret;\n\tint sample_time;\n\tunsigned long long freq;\n\tu32 temp;\n\n\tret = isl29501_register_read(isl29501, REG_SAMPLE_TIME, &sample_time);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfreq = 1000000ULL * 1000000ULL;\n\n\tdo_div(freq, 450 * (sample_time + 1));\n\n\ttemp = do_div(freq, 1000000);\n\t*val = freq;\n\t*val2 = temp;\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int isl29501_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int *val,\n\t\t\t     int *val2, long mask)\n{\n\tstruct isl29501_private *isl29501 = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn isl29501_get_raw(isl29501, chan, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn isl29501_get_scale(isl29501, chan, val, val2);\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\treturn isl29501_get_inttime(isl29501, val, val2);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn isl29501_get_freq(isl29501, val, val2);\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treturn isl29501_get_calibbias(isl29501, chan, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int isl29501_set_raw(struct isl29501_private *isl29501,\n\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t    int raw)\n{\n\tswitch (chan->type) {\n\tcase IIO_CURRENT:\n\t\treturn isl29501_register_write(isl29501, REG_EMITTER_DAC, raw);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int isl29501_set_inttime(struct isl29501_private *isl29501,\n\t\t\t\tint val, int val2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(isl29501_int_time); i++) {\n\t\tif (isl29501_int_time[i][0] == val &&\n\t\t    isl29501_int_time[i][1] == val2) {\n\t\t\treturn isl29501_register_write(isl29501,\n\t\t\t\t\t\t       REG_INT_TIME,\n\t\t\t\t\t\t       i);\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int isl29501_set_scale(struct isl29501_private *isl29501,\n\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t      int val, int val2)\n{\n\tint i;\n\n\tif (chan->type != IIO_CURRENT)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(isl29501_current_scale_table); i++) {\n\t\tif (isl29501_current_scale_table[i][0] == val &&\n\t\t    isl29501_current_scale_table[i][1] == val2) {\n\t\t\treturn isl29501_register_write(isl29501,\n\t\t\t\t\t\t       REG_DRIVER_RANGE,\n\t\t\t\t\t\t       i + 1);\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int isl29501_set_calibbias(struct isl29501_private *isl29501,\n\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t  int bias)\n{\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\treturn isl29501_register_write(isl29501,\n\t\t\t\t\t      REG_DISTANCE_BIAS,\n\t\t\t\t\t      bias);\n\tcase IIO_TEMP:\n\t\treturn isl29501_register_write(isl29501,\n\t\t\t\t\t       REG_TEMPERATURE_BIAS,\n\t\t\t\t\t       bias);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int isl29501_set_freq(struct isl29501_private *isl29501,\n\t\t\t     int val, int val2)\n{\n\tint freq;\n\tunsigned long long sample_time;\n\n\t \n\tfreq = val * 1000000 + val2 % 1000000;\n\tsample_time = 2222ULL * 1000000ULL;\n\tdo_div(sample_time, freq);\n\n\tsample_time -= 1;\n\n\tif (sample_time > 255)\n\t\treturn -ERANGE;\n\n\treturn isl29501_register_write(isl29501, REG_SAMPLE_TIME, sample_time);\n}\n\nstatic int isl29501_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tstruct isl29501_private *isl29501 = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn isl29501_set_raw(isl29501, chan, val);\n\tcase IIO_CHAN_INFO_INT_TIME:\n\t\treturn isl29501_set_inttime(isl29501, val, val2);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn isl29501_set_freq(isl29501, val, val2);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn isl29501_set_scale(isl29501, chan, val, val2);\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treturn isl29501_set_calibbias(isl29501, chan, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info isl29501_info = {\n\t.read_raw = &isl29501_read_raw,\n\t.write_raw = &isl29501_write_raw,\n\t.attrs = &isl29501_attribute_group,\n};\n\nstatic int isl29501_init_chip(struct isl29501_private *isl29501)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(isl29501->client, ISL29501_DEVICE_ID);\n\tif (ret < 0) {\n\t\tdev_err(&isl29501->client->dev, \"Error reading device id\\n\");\n\t\treturn ret;\n\t}\n\n\tif (ret != ISL29501_ID) {\n\t\tdev_err(&isl29501->client->dev,\n\t\t\t\"Wrong chip id, got %x expected %x\\n\",\n\t\t\tret, ISL29501_DEVICE_ID);\n\t\treturn -ENODEV;\n\t}\n\n\tret = isl29501_reset_registers(isl29501);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn isl29501_begin_acquisition(isl29501);\n}\n\nstatic irqreturn_t isl29501_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct isl29501_private *isl29501 = iio_priv(indio_dev);\n\tconst unsigned long *active_mask = indio_dev->active_scan_mask;\n\tu32 buffer[4] __aligned(8) = {};  \n\n\tif (test_bit(ISL29501_DISTANCE_SCAN_INDEX, active_mask))\n\t\tisl29501_register_read(isl29501, REG_DISTANCE, buffer);\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, buffer, pf->timestamp);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int isl29501_probe(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct isl29501_private *isl29501;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*isl29501));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tisl29501 = iio_priv(indio_dev);\n\n\ti2c_set_clientdata(client, indio_dev);\n\tisl29501->client = client;\n\n\tmutex_init(&isl29501->lock);\n\n\tret = isl29501_init_chip(isl29501);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = isl29501_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(isl29501_channels);\n\tindio_dev->name = client->name;\n\tindio_dev->info = &isl29501_info;\n\n\tret = devm_iio_triggered_buffer_setup(&client->dev, indio_dev,\n\t\t\t\t\t      iio_pollfunc_store_time,\n\t\t\t\t\t      isl29501_trigger_handler,\n\t\t\t\t\t      NULL);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"unable to setup iio triggered buffer\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id isl29501_id[] = {\n\t{\"isl29501\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, isl29501_id);\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id isl29501_i2c_matches[] = {\n\t{ .compatible = \"renesas,isl29501\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, isl29501_i2c_matches);\n#endif\n\nstatic struct i2c_driver isl29501_driver = {\n\t.driver = {\n\t\t.name\t= \"isl29501\",\n\t},\n\t.id_table\t= isl29501_id,\n\t.probe\t\t= isl29501_probe,\n};\nmodule_i2c_driver(isl29501_driver);\n\nMODULE_AUTHOR(\"Mathieu Othacehe <m.othacehe@gmail.com>\");\nMODULE_DESCRIPTION(\"ISL29501 Time of Flight sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}