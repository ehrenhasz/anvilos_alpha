{
  "module_name": "srf08.c",
  "hash_id": "17667dc1f52d698c58bf27f3d44f05a034ab479cd50723795d8b56a76b6a6b75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/proximity/srf08.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n \n#define SRF08_WRITE_COMMAND\t0x00\t \n#define SRF08_WRITE_MAX_GAIN\t0x01\t \n#define SRF08_WRITE_RANGE\t0x02\t \n#define SRF08_READ_SW_REVISION\t0x00\t \n#define SRF08_READ_LIGHT\t0x01\t \n#define SRF08_READ_ECHO_1_HIGH\t0x02\t \n#define SRF08_READ_ECHO_1_LOW\t0x03\t \n\n#define SRF08_CMD_RANGING_CM\t0x51\t \n\nenum srf08_sensor_type {\n\tSRF02,\n\tSRF08,\n\tSRF10,\n\tSRF_MAX_TYPE\n};\n\nstruct srf08_chip_info {\n\tconst int\t\t*sensitivity_avail;\n\tint\t\t\tnum_sensitivity_avail;\n\tint\t\t\tsensitivity_default;\n\n\t \n\tint\t\t\trange_default;\n};\n\nstruct srf08_data {\n\tstruct i2c_client\t*client;\n\n\t \n\tint\t\t\tsensitivity;\n\n\t \n\tint\t\t\trange_mm;\n\tstruct mutex\t\tlock;\n\n\t \n\tstruct {\n\t\ts16 chan;\n\t\ts64 timestamp __aligned(8);\n\t} scan;\n\n\t \n\tenum srf08_sensor_type\tsensor_type;\n\n\t \n\tconst struct srf08_chip_info\t*chip_info;\n};\n\n \nstatic const struct srf08_chip_info srf02_chip_info = {\n\t.sensitivity_avail\t= NULL,\n\t.num_sensitivity_avail\t= 0,\n\t.sensitivity_default\t= 0,\n\n\t.range_default\t\t= 0,\n};\n\nstatic const int srf08_sensitivity_avail[] = {\n\t 94,  97, 100, 103, 107, 110, 114, 118,\n\t123, 128, 133, 139, 145, 152, 159, 168,\n\t177, 187, 199, 212, 227, 245, 265, 288,\n\t317, 352, 395, 450, 524, 626, 777, 1025\n\t};\n\nstatic const struct srf08_chip_info srf08_chip_info = {\n\t.sensitivity_avail\t= srf08_sensitivity_avail,\n\t.num_sensitivity_avail\t= ARRAY_SIZE(srf08_sensitivity_avail),\n\t.sensitivity_default\t= 1025,\n\n\t.range_default\t\t= 6020,\n};\n\nstatic const int srf10_sensitivity_avail[] = {\n\t 40,  40,  50,  60,  70,  80, 100, 120,\n\t140, 200, 250, 300, 350, 400, 500, 600,\n\t700,\n\t};\n\nstatic const struct srf08_chip_info srf10_chip_info = {\n\t.sensitivity_avail\t= srf10_sensitivity_avail,\n\t.num_sensitivity_avail\t= ARRAY_SIZE(srf10_sensitivity_avail),\n\t.sensitivity_default\t= 700,\n\n\t.range_default\t\t= 6020,\n};\n\nstatic int srf08_read_ranging(struct srf08_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret, i;\n\tint waittime;\n\n\tmutex_lock(&data->lock);\n\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\tSRF08_WRITE_COMMAND, SRF08_CMD_RANGING_CM);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"write command - err: %d\\n\", ret);\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\n\t \n\twaittime = 1 + data->range_mm / 172;\n\tmsleep(waittime);\n\tfor (i = 0; i < 4; i++) {\n\t\tret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t\tSRF08_READ_SW_REVISION);\n\n\t\t \n\t\tif (ret < 255 && ret > 0)\n\t\t\tbreak;\n\t\tmsleep(5);\n\t}\n\n\tif (ret >= 255 || ret <= 0) {\n\t\tdev_err(&client->dev, \"device not ready\\n\");\n\t\tmutex_unlock(&data->lock);\n\t\treturn -EIO;\n\t}\n\n\tret = i2c_smbus_read_word_swapped(data->client,\n\t\t\t\t\t\tSRF08_READ_ECHO_1_HIGH);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"cannot read distance: ret=%d\\n\", ret);\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t srf08_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct srf08_data *data = iio_priv(indio_dev);\n\ts16 sensor_data;\n\n\tsensor_data = srf08_read_ranging(data);\n\tif (sensor_data < 0)\n\t\tgoto err;\n\n\tmutex_lock(&data->lock);\n\n\tdata->scan.chan = sensor_data;\n\tiio_push_to_buffers_with_timestamp(indio_dev,\n\t\t\t\t\t   &data->scan, pf->timestamp);\n\n\tmutex_unlock(&data->lock);\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\nstatic int srf08_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *channel, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct srf08_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (channel->type != IIO_DISTANCE)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = srf08_read_ranging(data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*val = 0;\n\t\t*val2 = 10000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t srf08_show_range_mm_available(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"[0.043 0.043 11.008]\\n\");\n}\n\nstatic IIO_DEVICE_ATTR(sensor_max_range_available, S_IRUGO,\n\t\t\t\tsrf08_show_range_mm_available, NULL, 0);\n\nstatic ssize_t srf08_show_range_mm(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct srf08_data *data = iio_priv(indio_dev);\n\n\treturn sprintf(buf, \"%d.%03d\\n\", data->range_mm / 1000,\n\t\t\t\t\t\tdata->range_mm % 1000);\n}\n\n \nstatic ssize_t srf08_write_range_mm(struct srf08_data *data, unsigned int val)\n{\n\tint ret;\n\tstruct i2c_client *client = data->client;\n\tunsigned int mod;\n\tu8 regval;\n\n\tret = val / 43 - 1;\n\tmod = val % 43;\n\n\tif (mod || (ret < 0) || (ret > 255))\n\t\treturn -EINVAL;\n\n\tregval = ret;\n\n\tmutex_lock(&data->lock);\n\n\tret = i2c_smbus_write_byte_data(client, SRF08_WRITE_RANGE, regval);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"write_range - err: %d\\n\", ret);\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\n\tdata->range_mm = val;\n\n\tmutex_unlock(&data->lock);\n\n\treturn 0;\n}\n\nstatic ssize_t srf08_store_range_mm(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct srf08_data *data = iio_priv(indio_dev);\n\tint ret;\n\tint integer, fract;\n\n\tret = iio_str_to_fixpoint(buf, 100, &integer, &fract);\n\tif (ret)\n\t\treturn ret;\n\n\tret = srf08_write_range_mm(data, integer * 1000 + fract);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(sensor_max_range, S_IRUGO | S_IWUSR,\n\t\t\tsrf08_show_range_mm, srf08_store_range_mm, 0);\n\nstatic ssize_t srf08_show_sensitivity_available(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint i, len = 0;\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct srf08_data *data = iio_priv(indio_dev);\n\n\tfor (i = 0; i < data->chip_info->num_sensitivity_avail; i++)\n\t\tif (data->chip_info->sensitivity_avail[i])\n\t\t\tlen += sprintf(buf + len, \"%d \",\n\t\t\t\tdata->chip_info->sensitivity_avail[i]);\n\n\tlen += sprintf(buf + len, \"\\n\");\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(sensor_sensitivity_available, S_IRUGO,\n\t\t\t\tsrf08_show_sensitivity_available, NULL, 0);\n\nstatic ssize_t srf08_show_sensitivity(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct srf08_data *data = iio_priv(indio_dev);\n\tint len;\n\n\tlen = sprintf(buf, \"%d\\n\", data->sensitivity);\n\n\treturn len;\n}\n\nstatic ssize_t srf08_write_sensitivity(struct srf08_data *data,\n\t\t\t\t\t\t\tunsigned int val)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret, i;\n\tu8 regval;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < data->chip_info->num_sensitivity_avail; i++)\n\t\tif (val == data->chip_info->sensitivity_avail[i]) {\n\t\t\tregval = i;\n\t\t\tbreak;\n\t\t}\n\n\tif (i >= data->chip_info->num_sensitivity_avail)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->lock);\n\n\tret = i2c_smbus_write_byte_data(client, SRF08_WRITE_MAX_GAIN, regval);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"write_sensitivity - err: %d\\n\", ret);\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\n\tdata->sensitivity = val;\n\n\tmutex_unlock(&data->lock);\n\n\treturn 0;\n}\n\nstatic ssize_t srf08_store_sensitivity(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct srf08_data *data = iio_priv(indio_dev);\n\tint ret;\n\tunsigned int val;\n\n\tret = kstrtouint(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = srf08_write_sensitivity(data, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(sensor_sensitivity, S_IRUGO | S_IWUSR,\n\t\t\tsrf08_show_sensitivity, srf08_store_sensitivity, 0);\n\nstatic struct attribute *srf08_attributes[] = {\n\t&iio_dev_attr_sensor_max_range.dev_attr.attr,\n\t&iio_dev_attr_sensor_max_range_available.dev_attr.attr,\n\t&iio_dev_attr_sensor_sensitivity.dev_attr.attr,\n\t&iio_dev_attr_sensor_sensitivity_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group srf08_attribute_group = {\n\t.attrs = srf08_attributes,\n};\n\nstatic const struct iio_chan_spec srf08_channels[] = {\n\t{\n\t\t.type = IIO_DISTANCE,\n\t\t.info_mask_separate =\n\t\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n};\n\nstatic const struct iio_info srf08_info = {\n\t.read_raw = srf08_read_raw,\n\t.attrs = &srf08_attribute_group,\n};\n\n \nstatic const struct iio_info srf02_info = {\n\t.read_raw = srf08_read_raw,\n};\n\nstatic int srf08_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct iio_dev *indio_dev;\n\tstruct srf08_data *data;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t\tI2C_FUNC_SMBUS_READ_BYTE_DATA |\n\t\t\t\t\tI2C_FUNC_SMBUS_WRITE_BYTE_DATA |\n\t\t\t\t\tI2C_FUNC_SMBUS_READ_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tdata->sensor_type = (enum srf08_sensor_type)id->driver_data;\n\n\tswitch (data->sensor_type) {\n\tcase SRF02:\n\t\tdata->chip_info = &srf02_chip_info;\n\t\tindio_dev->info = &srf02_info;\n\t\tbreak;\n\tcase SRF08:\n\t\tdata->chip_info = &srf08_chip_info;\n\t\tindio_dev->info = &srf08_info;\n\t\tbreak;\n\tcase SRF10:\n\t\tdata->chip_info = &srf10_chip_info;\n\t\tindio_dev->info = &srf08_info;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = srf08_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(srf08_channels);\n\n\tmutex_init(&data->lock);\n\n\tret = devm_iio_triggered_buffer_setup(&client->dev, indio_dev,\n\t\t\tiio_pollfunc_store_time, srf08_trigger_handler, NULL);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"setup of iio triggered buffer failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (data->chip_info->range_default) {\n\t\t \n\t\tret = srf08_write_range_mm(data,\n\t\t\t\t\tdata->chip_info->range_default);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (data->chip_info->sensitivity_default) {\n\t\t \n\t\tret = srf08_write_sensitivity(data,\n\t\t\t\tdata->chip_info->sensitivity_default);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct of_device_id of_srf08_match[] = {\n\t{ .compatible = \"devantech,srf02\", (void *)SRF02 },\n\t{ .compatible = \"devantech,srf08\", (void *)SRF08 },\n\t{ .compatible = \"devantech,srf10\", (void *)SRF10 },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, of_srf08_match);\n\nstatic const struct i2c_device_id srf08_id[] = {\n\t{ \"srf02\", SRF02 },\n\t{ \"srf08\", SRF08 },\n\t{ \"srf10\", SRF10 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, srf08_id);\n\nstatic struct i2c_driver srf08_driver = {\n\t.driver = {\n\t\t.name\t= \"srf08\",\n\t\t.of_match_table\t= of_srf08_match,\n\t},\n\t.probe = srf08_probe,\n\t.id_table = srf08_id,\n};\nmodule_i2c_driver(srf08_driver);\n\nMODULE_AUTHOR(\"Andreas Klinger <ak@it-klinger.de>\");\nMODULE_DESCRIPTION(\"Devantech SRF02/SRF08/SRF10 i2c ultrasonic ranger driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}