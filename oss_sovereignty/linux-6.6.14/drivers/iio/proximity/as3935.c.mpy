{
  "module_name": "as3935.c",
  "hash_id": "45211173fc6a03512528b882cabc26568828a3cda6996d625dd54f20d7f9630f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/proximity/as3935.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <linux/devm-helpers.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/irq.h>\n#include <linux/spi/spi.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define AS3935_AFE_GAIN\t\t0x00\n#define AS3935_AFE_MASK\t\t0x3F\n#define AS3935_AFE_GAIN_MAX\t0x1F\n#define AS3935_AFE_PWR_BIT\tBIT(0)\n\n#define AS3935_NFLWDTH\t\t0x01\n#define AS3935_NFLWDTH_MASK\t0x7f\n\n#define AS3935_INT\t\t0x03\n#define AS3935_INT_MASK\t\t0x0f\n#define AS3935_DISTURB_INT\tBIT(2)\n#define AS3935_EVENT_INT\tBIT(3)\n#define AS3935_NOISE_INT\tBIT(0)\n\n#define AS3935_DATA\t\t0x07\n#define AS3935_DATA_MASK\t0x3F\n\n#define AS3935_TUNE_CAP\t\t0x08\n#define AS3935_DEFAULTS\t\t0x3C\n#define AS3935_CALIBRATE\t0x3D\n\n#define AS3935_READ_DATA\tBIT(14)\n#define AS3935_ADDRESS(x)\t((x) << 8)\n\n#define MAX_PF_CAP\t\t120\n#define TUNE_CAP_DIV\t\t8\n\nstruct as3935_state {\n\tstruct spi_device *spi;\n\tstruct iio_trigger *trig;\n\tstruct mutex lock;\n\tstruct delayed_work work;\n\n\tunsigned long noise_tripped;\n\tu32 tune_cap;\n\tu32 nflwdth_reg;\n\t \n\tstruct {\n\t\tu8 chan;\n\t\ts64 timestamp __aligned(8);\n\t} scan;\n\tu8 buf[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic const struct iio_chan_spec as3935_channels[] = {\n\t{\n\t\t.type           = IIO_PROXIMITY,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index     = 0,\n\t\t.scan_type = {\n\t\t\t.sign           = 'u',\n\t\t\t.realbits       = 6,\n\t\t\t.storagebits    = 8,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n};\n\nstatic int as3935_read(struct as3935_state *st, unsigned int reg, int *val)\n{\n\tu8 cmd;\n\tint ret;\n\n\tcmd = (AS3935_READ_DATA | AS3935_ADDRESS(reg)) >> 8;\n\tret = spi_w8r8(st->spi, cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\t*val = ret;\n\n\treturn 0;\n}\n\nstatic int as3935_write(struct as3935_state *st,\n\t\t\t\tunsigned int reg,\n\t\t\t\tunsigned int val)\n{\n\tu8 *buf = st->buf;\n\n\tbuf[0] = AS3935_ADDRESS(reg) >> 8;\n\tbuf[1] = val;\n\n\treturn spi_write(st->spi, buf, 2);\n}\n\nstatic ssize_t as3935_sensor_sensitivity_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct as3935_state *st = iio_priv(dev_to_iio_dev(dev));\n\tint val, ret;\n\n\tret = as3935_read(st, AS3935_AFE_GAIN, &val);\n\tif (ret)\n\t\treturn ret;\n\tval = (val & AS3935_AFE_MASK) >> 1;\n\n\treturn sysfs_emit(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t as3935_sensor_sensitivity_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct as3935_state *st = iio_priv(dev_to_iio_dev(dev));\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (val > AS3935_AFE_GAIN_MAX)\n\t\treturn -EINVAL;\n\n\tas3935_write(st, AS3935_AFE_GAIN, val << 1);\n\n\treturn len;\n}\n\nstatic ssize_t as3935_noise_level_tripped_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct as3935_state *st = iio_priv(dev_to_iio_dev(dev));\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\tret = sysfs_emit(buf, \"%d\\n\", !time_after(jiffies, st->noise_tripped + HZ));\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic IIO_DEVICE_ATTR(sensor_sensitivity, S_IRUGO | S_IWUSR,\n\tas3935_sensor_sensitivity_show, as3935_sensor_sensitivity_store, 0);\n\nstatic IIO_DEVICE_ATTR(noise_level_tripped, S_IRUGO,\n\tas3935_noise_level_tripped_show, NULL, 0);\n\nstatic struct attribute *as3935_attributes[] = {\n\t&iio_dev_attr_sensor_sensitivity.dev_attr.attr,\n\t&iio_dev_attr_noise_level_tripped.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group as3935_attribute_group = {\n\t.attrs = as3935_attributes,\n};\n\nstatic int as3935_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val,\n\t\t\t   int *val2,\n\t\t\t   long m)\n{\n\tstruct as3935_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\n\tswitch (m) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*val2 = 0;\n\t\tret = as3935_read(st, AS3935_DATA, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (*val == AS3935_DATA_MASK)\n\t\t\treturn -EINVAL;\n\n\t\tif (m == IIO_CHAN_INFO_RAW)\n\t\t\treturn IIO_VAL_INT;\n\n\t\tif (m == IIO_CHAN_INFO_PROCESSED)\n\t\t\t*val *= 1000;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 1000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn IIO_VAL_INT;\n}\n\nstatic const struct iio_info as3935_info = {\n\t.attrs = &as3935_attribute_group,\n\t.read_raw = &as3935_read_raw,\n};\n\nstatic irqreturn_t as3935_trigger_handler(int irq, void *private)\n{\n\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct as3935_state *st = iio_priv(indio_dev);\n\tint val, ret;\n\n\tret = as3935_read(st, AS3935_DATA, &val);\n\tif (ret)\n\t\tgoto err_read;\n\n\tst->scan.chan = val & AS3935_DATA_MASK;\n\tiio_push_to_buffers_with_timestamp(indio_dev, &st->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\nerr_read:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void as3935_event_work(struct work_struct *work)\n{\n\tstruct as3935_state *st;\n\tint val;\n\tint ret;\n\n\tst = container_of(work, struct as3935_state, work.work);\n\n\tret = as3935_read(st, AS3935_INT, &val);\n\tif (ret) {\n\t\tdev_warn(&st->spi->dev, \"read error\\n\");\n\t\treturn;\n\t}\n\n\tval &= AS3935_INT_MASK;\n\n\tswitch (val) {\n\tcase AS3935_EVENT_INT:\n\t\tiio_trigger_poll_nested(st->trig);\n\t\tbreak;\n\tcase AS3935_DISTURB_INT:\n\tcase AS3935_NOISE_INT:\n\t\tmutex_lock(&st->lock);\n\t\tst->noise_tripped = jiffies;\n\t\tmutex_unlock(&st->lock);\n\t\tdev_warn(&st->spi->dev, \"noise level is too high\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t as3935_interrupt_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct as3935_state *st = iio_priv(indio_dev);\n\n\t \n\n\tschedule_delayed_work(&st->work, msecs_to_jiffies(3));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void calibrate_as3935(struct as3935_state *st)\n{\n\tas3935_write(st, AS3935_DEFAULTS, 0x96);\n\tas3935_write(st, AS3935_CALIBRATE, 0x96);\n\tas3935_write(st, AS3935_TUNE_CAP,\n\t\tBIT(5) | (st->tune_cap / TUNE_CAP_DIV));\n\n\tmdelay(2);\n\tas3935_write(st, AS3935_TUNE_CAP, (st->tune_cap / TUNE_CAP_DIV));\n\tas3935_write(st, AS3935_NFLWDTH, st->nflwdth_reg);\n}\n\nstatic int as3935_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct as3935_state *st = iio_priv(indio_dev);\n\tint val, ret;\n\n\tmutex_lock(&st->lock);\n\tret = as3935_read(st, AS3935_AFE_GAIN, &val);\n\tif (ret)\n\t\tgoto err_suspend;\n\tval |= AS3935_AFE_PWR_BIT;\n\n\tret = as3935_write(st, AS3935_AFE_GAIN, val);\n\nerr_suspend:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int as3935_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct as3935_state *st = iio_priv(indio_dev);\n\tint val, ret;\n\n\tmutex_lock(&st->lock);\n\tret = as3935_read(st, AS3935_AFE_GAIN, &val);\n\tif (ret)\n\t\tgoto err_resume;\n\tval &= ~AS3935_AFE_PWR_BIT;\n\tret = as3935_write(st, AS3935_AFE_GAIN, val);\n\n\tcalibrate_as3935(st);\n\nerr_resume:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(as3935_pm_ops, as3935_suspend, as3935_resume);\n\nstatic int as3935_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct iio_trigger *trig;\n\tstruct as3935_state *st;\n\tint ret;\n\n\t \n\tif (!spi->irq) {\n\t\tdev_err(dev, \"unable to get event interrupt\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tst->spi = spi;\n\n\tspi_set_drvdata(spi, indio_dev);\n\tmutex_init(&st->lock);\n\n\tret = device_property_read_u32(dev,\n\t\t\t\"ams,tuning-capacitor-pf\", &st->tune_cap);\n\tif (ret) {\n\t\tst->tune_cap = 0;\n\t\tdev_warn(dev, \"no tuning-capacitor-pf set, defaulting to %d\",\n\t\t\tst->tune_cap);\n\t}\n\n\tif (st->tune_cap > MAX_PF_CAP) {\n\t\tdev_err(dev, \"wrong tuning-capacitor-pf setting of %d\\n\",\n\t\t\tst->tune_cap);\n\t\treturn -EINVAL;\n\t}\n\n\tret = device_property_read_u32(dev,\n\t\t\t\"ams,nflwdth\", &st->nflwdth_reg);\n\tif (!ret && st->nflwdth_reg > AS3935_NFLWDTH_MASK) {\n\t\tdev_err(dev, \"invalid nflwdth setting of %d\\n\",\n\t\t\tst->nflwdth_reg);\n\t\treturn -EINVAL;\n\t}\n\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->channels = as3935_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(as3935_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &as3935_info;\n\n\ttrig = devm_iio_trigger_alloc(dev, \"%s-dev%d\",\n\t\t\t\t      indio_dev->name,\n\t\t\t\t      iio_device_id(indio_dev));\n\n\tif (!trig)\n\t\treturn -ENOMEM;\n\n\tst->trig = trig;\n\tst->noise_tripped = jiffies - HZ;\n\tiio_trigger_set_drvdata(trig, indio_dev);\n\n\tret = devm_iio_trigger_register(dev, trig);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register trigger\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev,\n\t\t\t\t\t      iio_pollfunc_store_time,\n\t\t\t\t\t      as3935_trigger_handler, NULL);\n\n\tif (ret) {\n\t\tdev_err(dev, \"cannot setup iio trigger\\n\");\n\t\treturn ret;\n\t}\n\n\tcalibrate_as3935(st);\n\n\tret = devm_delayed_work_autocancel(dev, &st->work, as3935_event_work);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_irq(dev, spi->irq,\n\t\t\t\t&as3935_interrupt_handler,\n\t\t\t\tIRQF_TRIGGER_RISING,\n\t\t\t\tdev_name(dev),\n\t\t\t\tindio_dev);\n\n\tif (ret) {\n\t\tdev_err(dev, \"unable to request irq\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to register device\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic const struct of_device_id as3935_of_match[] = {\n\t{ .compatible = \"ams,as3935\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, as3935_of_match);\n\nstatic const struct spi_device_id as3935_id[] = {\n\t{\"as3935\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(spi, as3935_id);\n\nstatic struct spi_driver as3935_driver = {\n\t.driver = {\n\t\t.name\t= \"as3935\",\n\t\t.of_match_table = as3935_of_match,\n\t\t.pm\t= pm_sleep_ptr(&as3935_pm_ops),\n\t},\n\t.probe\t\t= as3935_probe,\n\t.id_table\t= as3935_id,\n};\nmodule_spi_driver(as3935_driver);\n\nMODULE_AUTHOR(\"Matt Ranostay <matt.ranostay@konsulko.com>\");\nMODULE_DESCRIPTION(\"AS3935 lightning sensor\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}