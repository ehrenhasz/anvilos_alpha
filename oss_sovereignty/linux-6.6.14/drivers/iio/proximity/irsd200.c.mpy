{
  "module_name": "irsd200.c",
  "hash_id": "bd2da7809887436cc6f10876fa030be5ba896563374c25ea6b58aac6d1cc03a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/proximity/irsd200.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/bitfield.h>\n#include <linux/gpio.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/types.h>\n\n#define IRS_DRV_NAME \"irsd200\"\n\n \n#define IRS_REG_OP\t\t0x00\t \n#define IRS_REG_DATA_LO\t\t0x02\t \n#define IRS_REG_DATA_HI\t\t0x03\t \n#define IRS_REG_STATUS\t\t0x04\t \n#define IRS_REG_COUNT\t\t0x05\t \n#define IRS_REG_DATA_RATE\t0x06\t \n#define IRS_REG_FILTER\t\t0x07\t \n#define IRS_REG_INTR\t\t0x09\t \n#define IRS_REG_NR_COUNT\t0x0a\t \n#define IRS_REG_THR_HI\t\t0x0b\t \n#define IRS_REG_THR_LO\t\t0x0c\t \n#define IRS_REG_TIMER_LO\t0x0d\t \n#define IRS_REG_TIMER_HI\t0x0e\t \n\n \n#define IRS_INTR_DATA\t\t0\t \n#define IRS_INTR_TIMER\t\t1\t \n#define IRS_INTR_COUNT_THR_AND\t2\t \n#define IRS_INTR_COUNT_THR_OR\t3\t \n\n \n#define IRS_OP_ACTIVE\t\t0x00\n#define IRS_OP_SLEEP\t\t0x01\n\n \n#define IRS_THR_QUANT_SCALE\t128\n\n#define IRS_UPPER_COUNT(count)\tFIELD_GET(GENMASK(7, 4), count)\n#define IRS_LOWER_COUNT(count)\tFIELD_GET(GENMASK(3, 0), count)\n\n \nstatic const int irsd200_data_rates[] = {\n\t50,\n\t100,\n};\n\n \nstatic const unsigned int irsd200_lp_filter_freq[] = {\n\t10,\n\t7,\n};\n\n \nstatic const unsigned int irsd200_hp_filter_freq[][2] = {\n\t{ 3, 10 },\n\t{ 5, 10 },\n};\n\n \nenum irsd200_regfield {\n\t \n\tIRS_REGF_INTR_DATA,\n\t \n\tIRS_REGF_INTR_TIMER,\n\t \n\tIRS_REGF_INTR_COUNT_THR_AND,\n\t \n\tIRS_REGF_INTR_COUNT_THR_OR,\n\n\t \n\tIRS_REGF_LP_FILTER,\n\t \n\tIRS_REGF_HP_FILTER,\n\n\t \n\tIRS_REGF_MAX\n};\n\nstatic const struct reg_field irsd200_regfields[] = {\n\t[IRS_REGF_INTR_DATA] =\n\t\tREG_FIELD(IRS_REG_INTR, IRS_INTR_DATA, IRS_INTR_DATA),\n\t[IRS_REGF_INTR_TIMER] =\n\t\tREG_FIELD(IRS_REG_INTR, IRS_INTR_TIMER, IRS_INTR_TIMER),\n\t[IRS_REGF_INTR_COUNT_THR_AND] = REG_FIELD(\n\t\tIRS_REG_INTR, IRS_INTR_COUNT_THR_AND, IRS_INTR_COUNT_THR_AND),\n\t[IRS_REGF_INTR_COUNT_THR_OR] = REG_FIELD(\n\t\tIRS_REG_INTR, IRS_INTR_COUNT_THR_OR, IRS_INTR_COUNT_THR_OR),\n\n\t[IRS_REGF_LP_FILTER] = REG_FIELD(IRS_REG_FILTER, 1, 1),\n\t[IRS_REGF_HP_FILTER] = REG_FIELD(IRS_REG_FILTER, 0, 0),\n};\n\nstatic const struct regmap_config irsd200_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = IRS_REG_TIMER_HI,\n};\n\nstruct irsd200_data {\n\tstruct regmap *regmap;\n\tstruct regmap_field *regfields[IRS_REGF_MAX];\n\tstruct device *dev;\n};\n\nstatic int irsd200_setup(struct irsd200_data *data)\n{\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_write(data->regmap, IRS_REG_INTR, 0);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not set interrupt sources (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write(data->regmap, IRS_REG_OP, IRS_OP_ACTIVE);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not set operation mode (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_read(data->regmap, IRS_REG_COUNT, &val);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not clear threshold count (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write(data->regmap, IRS_REG_STATUS, 0x0f);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not clear status (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int irsd200_read_threshold(struct irsd200_data *data,\n\t\t\t\t  enum iio_event_direction dir, int *val)\n{\n\tunsigned int regval;\n\tunsigned int reg;\n\tint scale;\n\tint ret;\n\n\t \n\tif (dir == IIO_EV_DIR_RISING) {\n\t\tscale = IRS_THR_QUANT_SCALE;\n\t\treg = IRS_REG_THR_HI;\n\t} else if (dir == IIO_EV_DIR_FALLING) {\n\t\tscale = -IRS_THR_QUANT_SCALE;\n\t\treg = IRS_REG_THR_LO;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_read(data->regmap, reg, &regval);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not read threshold (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*val = ((int)regval) * scale;\n\n\treturn 0;\n}\n\nstatic int irsd200_write_threshold(struct irsd200_data *data,\n\t\t\t\t   enum iio_event_direction dir, int val)\n{\n\tunsigned int regval;\n\tunsigned int reg;\n\tint scale;\n\tint ret;\n\n\t \n\tif (dir == IIO_EV_DIR_RISING) {\n\t\tif (val < 0)\n\t\t\treturn -ERANGE;\n\n\t\tscale = IRS_THR_QUANT_SCALE;\n\t\treg = IRS_REG_THR_HI;\n\t} else if (dir == IIO_EV_DIR_FALLING) {\n\t\tif (val > 0)\n\t\t\treturn -ERANGE;\n\n\t\tscale = -IRS_THR_QUANT_SCALE;\n\t\treg = IRS_REG_THR_LO;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tregval = val / scale;\n\n\tif (regval >= BIT(8))\n\t\treturn -ERANGE;\n\n\tret = regmap_write(data->regmap, reg, regval);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not write threshold (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int irsd200_read_data(struct irsd200_data *data, s16 *val)\n{\n\t__le16 buf;\n\tint ret;\n\n\tret = regmap_bulk_read(data->regmap, IRS_REG_DATA_LO, &buf,\n\t\t\t       sizeof(buf));\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not bulk read data (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*val = le16_to_cpu(buf);\n\n\treturn 0;\n}\n\nstatic int irsd200_read_data_rate(struct irsd200_data *data, int *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(data->regmap, IRS_REG_DATA_RATE, &regval);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not read data rate (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (regval >= ARRAY_SIZE(irsd200_data_rates))\n\t\treturn -ERANGE;\n\n\t*val = irsd200_data_rates[regval];\n\n\treturn 0;\n}\n\nstatic int irsd200_write_data_rate(struct irsd200_data *data, int val)\n{\n\tsize_t idx;\n\tint ret;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(irsd200_data_rates); ++idx) {\n\t\tif (irsd200_data_rates[idx] == val)\n\t\t\tbreak;\n\t}\n\n\tif (idx == ARRAY_SIZE(irsd200_data_rates))\n\t\treturn -ERANGE;\n\n\tret = regmap_write(data->regmap, IRS_REG_DATA_RATE, idx);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not write data rate (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tssleep(3);\n\n\treturn 0;\n}\n\nstatic int irsd200_read_timer(struct irsd200_data *data, int *val, int *val2)\n{\n\t__le16 buf;\n\tint ret;\n\n\tret = regmap_bulk_read(data->regmap, IRS_REG_TIMER_LO, &buf,\n\t\t\t       sizeof(buf));\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not bulk read timer (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = irsd200_read_data_rate(data, val2);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = le16_to_cpu(buf);\n\n\treturn 0;\n}\n\nstatic int irsd200_write_timer(struct irsd200_data *data, int val, int val2)\n{\n\tunsigned int regval;\n\tint data_rate;\n\t__le16 buf;\n\tint ret;\n\n\tif (val < 0 || val2 < 0)\n\t\treturn -ERANGE;\n\n\tret = irsd200_read_data_rate(data, &data_rate);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregval = val * data_rate + (val2 * data_rate) / 1000000;\n\n\t \n\tif (regval >= BIT(10))\n\t\treturn -ERANGE;\n\n\tbuf = cpu_to_le16((u16)regval);\n\n\tret = regmap_bulk_write(data->regmap, IRS_REG_TIMER_LO, &buf,\n\t\t\t\tsizeof(buf));\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not bulk write timer (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int irsd200_read_nr_count(struct irsd200_data *data, int *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(data->regmap, IRS_REG_NR_COUNT, &regval);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not read nr count (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*val = regval;\n\n\treturn 0;\n}\n\nstatic int irsd200_write_nr_count(struct irsd200_data *data, int val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\t \n\tif (val <= 0 || val >= 8)\n\t\treturn -ERANGE;\n\n\tregval = val;\n\n\tif (regval >= 2) {\n\t\t \n\t\tret = irsd200_read_timer(data, &val, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (val == 0) {\n\t\t\tdev_err(data->dev,\n\t\t\t\t\"Timer must be non-zero when nr count is %u\\n\",\n\t\t\t\tregval);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\tret = regmap_write(data->regmap, IRS_REG_NR_COUNT, regval);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not write nr count (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int irsd200_read_lp_filter(struct irsd200_data *data, int *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_field_read(data->regfields[IRS_REGF_LP_FILTER], &regval);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not read lp filter frequency (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t*val = irsd200_lp_filter_freq[regval];\n\n\treturn 0;\n}\n\nstatic int irsd200_write_lp_filter(struct irsd200_data *data, int val)\n{\n\tsize_t idx;\n\tint ret;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(irsd200_lp_filter_freq); ++idx) {\n\t\tif (irsd200_lp_filter_freq[idx] == val)\n\t\t\tbreak;\n\t}\n\n\tif (idx == ARRAY_SIZE(irsd200_lp_filter_freq))\n\t\treturn -ERANGE;\n\n\tret = regmap_field_write(data->regfields[IRS_REGF_LP_FILTER], idx);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not write lp filter frequency (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int irsd200_read_hp_filter(struct irsd200_data *data, int *val,\n\t\t\t\t  int *val2)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_field_read(data->regfields[IRS_REGF_HP_FILTER], &regval);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not read hp filter frequency (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t*val = irsd200_hp_filter_freq[regval][0];\n\t*val2 = irsd200_hp_filter_freq[regval][1];\n\n\treturn 0;\n}\n\nstatic int irsd200_write_hp_filter(struct irsd200_data *data, int val, int val2)\n{\n\tsize_t idx;\n\tint ret;\n\n\t \n\tval2 /= 100000;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(irsd200_hp_filter_freq); ++idx) {\n\t\tif (irsd200_hp_filter_freq[idx][0] == val2)\n\t\t\tbreak;\n\t}\n\n\tif (idx == ARRAY_SIZE(irsd200_hp_filter_freq) || val != 0)\n\t\treturn -ERANGE;\n\n\tret = regmap_field_write(data->regfields[IRS_REGF_HP_FILTER], idx);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not write hp filter frequency (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int irsd200_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct irsd200_data *data = iio_priv(indio_dev);\n\tint ret;\n\ts16 buf;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = irsd200_read_data(data, &buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = buf;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = irsd200_read_data_rate(data, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tret = irsd200_read_lp_filter(data, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\tret = irsd200_read_hp_filter(data, val, val2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int irsd200_read_avail(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      const int **vals, int *type, int *length,\n\t\t\t      long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*vals = irsd200_data_rates;\n\t\t*type = IIO_VAL_INT;\n\t\t*length = ARRAY_SIZE(irsd200_data_rates);\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\t*vals = irsd200_lp_filter_freq;\n\t\t*type = IIO_VAL_INT;\n\t\t*length = ARRAY_SIZE(irsd200_lp_filter_freq);\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\t*vals = (int *)irsd200_hp_filter_freq;\n\t\t*type = IIO_VAL_FRACTIONAL;\n\t\t*length = 2 * ARRAY_SIZE(irsd200_hp_filter_freq);\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int irsd200_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int val,\n\t\t\t     int val2, long mask)\n{\n\tstruct irsd200_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn irsd200_write_data_rate(data, val);\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn irsd200_write_lp_filter(data, val);\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn irsd200_write_hp_filter(data, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int irsd200_read_event(struct iio_dev *indio_dev,\n\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t      enum iio_event_type type,\n\t\t\t      enum iio_event_direction dir,\n\t\t\t      enum iio_event_info info, int *val, int *val2)\n{\n\tstruct irsd200_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tret = irsd200_read_threshold(data, dir, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_EV_INFO_RUNNING_PERIOD:\n\t\tret = irsd200_read_timer(data, val, val2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase IIO_EV_INFO_RUNNING_COUNT:\n\t\tret = irsd200_read_nr_count(data, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int irsd200_write_event(struct iio_dev *indio_dev,\n\t\t\t       const struct iio_chan_spec *chan,\n\t\t\t       enum iio_event_type type,\n\t\t\t       enum iio_event_direction dir,\n\t\t\t       enum iio_event_info info, int val, int val2)\n{\n\tstruct irsd200_data *data = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\treturn irsd200_write_threshold(data, dir, val);\n\tcase IIO_EV_INFO_RUNNING_PERIOD:\n\t\treturn irsd200_write_timer(data, val, val2);\n\tcase IIO_EV_INFO_RUNNING_COUNT:\n\t\treturn irsd200_write_nr_count(data, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int irsd200_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir)\n{\n\tstruct irsd200_data *data = iio_priv(indio_dev);\n\tunsigned int val;\n\tint ret;\n\n\tswitch (type) {\n\tcase IIO_EV_TYPE_THRESH:\n\t\tret = regmap_field_read(\n\t\t\tdata->regfields[IRS_REGF_INTR_COUNT_THR_OR], &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn val;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int irsd200_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t\t      enum iio_event_type type,\n\t\t\t\t      enum iio_event_direction dir, int state)\n{\n\tstruct irsd200_data *data = iio_priv(indio_dev);\n\tunsigned int tmp;\n\tint ret;\n\n\tswitch (type) {\n\tcase IIO_EV_TYPE_THRESH:\n\t\t \n\t\tret = regmap_read(data->regmap, IRS_REG_COUNT, &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn regmap_field_write(\n\t\t\tdata->regfields[IRS_REGF_INTR_COUNT_THR_OR], !!state);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic irqreturn_t irsd200_irq_thread(int irq, void *dev_id)\n{\n\tstruct iio_dev *indio_dev = dev_id;\n\tstruct irsd200_data *data = iio_priv(indio_dev);\n\tenum iio_event_direction dir;\n\tunsigned int lower_count;\n\tunsigned int upper_count;\n\tunsigned int status = 0;\n\tunsigned int source = 0;\n\tunsigned int clear = 0;\n\tunsigned int count = 0;\n\tint ret;\n\n\tret = regmap_read(data->regmap, IRS_REG_INTR, &source);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not read interrupt source (%d)\\n\",\n\t\t\tret);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tret = regmap_read(data->regmap, IRS_REG_STATUS, &status);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not acknowledge interrupt (%d)\\n\",\n\t\t\tret);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (status & BIT(IRS_INTR_DATA) && iio_buffer_enabled(indio_dev)) {\n\t\tiio_trigger_poll_nested(indio_dev->trig);\n\t\tclear |= BIT(IRS_INTR_DATA);\n\t}\n\n\tif (status & BIT(IRS_INTR_COUNT_THR_OR) &&\n\t    source & BIT(IRS_INTR_COUNT_THR_OR)) {\n\t\t \n\t\tret = regmap_read(data->regmap, IRS_REG_COUNT, &count);\n\t\tif (ret)\n\t\t\tdev_err(data->dev, \"Could not read count (%d)\\n\", ret);\n\n\t\tupper_count = IRS_UPPER_COUNT(count);\n\t\tlower_count = IRS_LOWER_COUNT(count);\n\n\t\t \n\t\tif (upper_count && !lower_count)\n\t\t\tdir = IIO_EV_DIR_RISING;\n\t\telse if (!upper_count && lower_count)\n\t\t\tdir = IIO_EV_DIR_FALLING;\n\t\telse\n\t\t\tdir = IIO_EV_DIR_EITHER;\n\n\t\tiio_push_event(indio_dev,\n\t\t\t       IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 0,\n\t\t\t\t\t\t    IIO_EV_TYPE_THRESH, dir),\n\t\t\t       iio_get_time_ns(indio_dev));\n\n\t\t \n\t\tclear |= BIT(IRS_INTR_COUNT_THR_OR) |\n\t\t\t BIT(IRS_INTR_COUNT_THR_AND);\n\t}\n\n\tif (!clear)\n\t\treturn IRQ_NONE;\n\n\tret = regmap_write(data->regmap, IRS_REG_STATUS, clear);\n\tif (ret)\n\t\tdev_err(data->dev,\n\t\t\t\"Could not clear interrupt status (%d)\\n\", ret);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t irsd200_trigger_handler(int irq, void *pollf)\n{\n\tstruct iio_dev *indio_dev = ((struct iio_poll_func *)pollf)->indio_dev;\n\tstruct irsd200_data *data = iio_priv(indio_dev);\n\ts64 buf[2] = {};\n\tint ret;\n\n\tret = irsd200_read_data(data, (s16 *)buf);\n\tif (ret)\n\t\tgoto end;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, buf,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\nend:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int irsd200_set_trigger_state(struct iio_trigger *trig, bool state)\n{\n\tstruct irsd200_data *data = iio_trigger_get_drvdata(trig);\n\tint ret;\n\n\tret = regmap_field_write(data->regfields[IRS_REGF_INTR_DATA], state);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Could not %s data interrupt source (%d)\\n\",\n\t\t\tstate ? \"enable\" : \"disable\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct iio_info irsd200_info = {\n\t.read_raw = irsd200_read_raw,\n\t.read_avail = irsd200_read_avail,\n\t.write_raw = irsd200_write_raw,\n\t.read_event_value = irsd200_read_event,\n\t.write_event_value = irsd200_write_event,\n\t.read_event_config = irsd200_read_event_config,\n\t.write_event_config = irsd200_write_event_config,\n};\n\nstatic const struct iio_trigger_ops irsd200_trigger_ops = {\n\t.set_trigger_state = irsd200_set_trigger_state,\n\t.validate_device = iio_trigger_validate_own_device,\n};\n\nstatic const struct iio_event_spec irsd200_event_spec[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate =\n\t\t\tBIT(IIO_EV_INFO_RUNNING_PERIOD) |\n\t\t\tBIT(IIO_EV_INFO_RUNNING_COUNT) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec irsd200_channels[] = {\n\t{\n\t\t.type = IIO_PROXIMITY,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ) |\n\t\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY) |\n\t\t\tBIT(IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY),\n\t\t.info_mask_separate_available =\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ) |\n\t\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY) |\n\t\t\tBIT(IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY),\n\t\t.event_spec = irsd200_event_spec,\n\t\t.num_event_specs = ARRAY_SIZE(irsd200_event_spec),\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n};\n\nstatic int irsd200_probe(struct i2c_client *client)\n{\n\tstruct iio_trigger *trigger;\n\tstruct irsd200_data *data;\n\tstruct iio_dev *indio_dev;\n\tsize_t i;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn dev_err_probe(&client->dev, -ENOMEM,\n\t\t\t\t     \"Could not allocate iio device\\n\");\n\n\tdata = iio_priv(indio_dev);\n\tdata->dev = &client->dev;\n\n\tdata->regmap = devm_regmap_init_i2c(client, &irsd200_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn dev_err_probe(data->dev, PTR_ERR(data->regmap),\n\t\t\t\t     \"Could not initialize regmap\\n\");\n\n\tfor (i = 0; i < IRS_REGF_MAX; ++i) {\n\t\tdata->regfields[i] = devm_regmap_field_alloc(\n\t\t\tdata->dev, data->regmap, irsd200_regfields[i]);\n\t\tif (IS_ERR(data->regfields[i]))\n\t\t\treturn dev_err_probe(\n\t\t\t\tdata->dev, PTR_ERR(data->regfields[i]),\n\t\t\t\t\"Could not allocate register field %zu\\n\", i);\n\t}\n\n\tret = devm_regulator_get_enable(data->dev, \"vdd\");\n\tif (ret)\n\t\treturn dev_err_probe(\n\t\t\tdata->dev, ret,\n\t\t\t\"Could not get and enable regulator (%d)\\n\", ret);\n\n\tret = irsd200_setup(data);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->info = &irsd200_info;\n\tindio_dev->name = IRS_DRV_NAME;\n\tindio_dev->channels = irsd200_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(irsd200_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tif (!client->irq)\n\t\treturn dev_err_probe(data->dev, -ENXIO, \"No irq available\\n\");\n\n\tret = devm_iio_triggered_buffer_setup(data->dev, indio_dev, NULL,\n\t\t\t\t\t      irsd200_trigger_handler, NULL);\n\tif (ret)\n\t\treturn dev_err_probe(\n\t\t\tdata->dev, ret,\n\t\t\t\"Could not setup iio triggered buffer (%d)\\n\", ret);\n\n\tret = devm_request_threaded_irq(data->dev, client->irq, NULL,\n\t\t\t\t\tirsd200_irq_thread,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tNULL, indio_dev);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret,\n\t\t\t\t     \"Could not request irq (%d)\\n\", ret);\n\n\ttrigger = devm_iio_trigger_alloc(data->dev, \"%s-dev%d\", indio_dev->name,\n\t\t\t\t\t iio_device_id(indio_dev));\n\tif (!trigger)\n\t\treturn dev_err_probe(data->dev, -ENOMEM,\n\t\t\t\t     \"Could not allocate iio trigger\\n\");\n\n\ttrigger->ops = &irsd200_trigger_ops;\n\tiio_trigger_set_drvdata(trigger, data);\n\n\tret = devm_iio_trigger_register(data->dev, trigger);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret,\n\t\t\t\t     \"Could not register iio trigger (%d)\\n\",\n\t\t\t\t     ret);\n\n\tret = devm_iio_device_register(data->dev, indio_dev);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret,\n\t\t\t\t     \"Could not register iio device (%d)\\n\",\n\t\t\t\t     ret);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id irsd200_of_match[] = {\n\t{\n\t\t.compatible = \"murata,irsd200\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, irsd200_of_match);\n\nstatic struct i2c_driver irsd200_driver = {\n\t.driver = {\n\t\t.name = IRS_DRV_NAME,\n\t\t.of_match_table = irsd200_of_match,\n\t},\n\t.probe = irsd200_probe,\n};\nmodule_i2c_driver(irsd200_driver);\n\nMODULE_AUTHOR(\"Waqar Hameed <waqar.hameed@axis.com>\");\nMODULE_DESCRIPTION(\"Murata IRS-D200 PIR sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}