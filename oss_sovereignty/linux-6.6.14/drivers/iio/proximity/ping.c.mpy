{
  "module_name": "ping.c",
  "hash_id": "97ce83c6d8088b0e076218762aa0ec5f4f3cc3bb3f9e7bee151f6665b8443525",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/proximity/ping.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\nstruct ping_cfg {\n\tunsigned long\ttrigger_pulse_us;\t \n\tint\t\tlaserping_error;\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\ts64\t\ttimeout_ns;\t\t \n};\n\nstruct ping_data {\n\tstruct device\t\t*dev;\n\tstruct gpio_desc\t*gpiod_ping;\n\tstruct mutex\t\tlock;\n\tint\t\t\tirqnr;\n\tktime_t\t\t\tts_rising;\n\tktime_t\t\t\tts_falling;\n\tstruct completion\trising;\n\tstruct completion\tfalling;\n\tconst struct ping_cfg\t*cfg;\n};\n\nstatic const struct ping_cfg pa_ping_cfg = {\n\t.trigger_pulse_us\t= 5,\n\t.laserping_error\t= 0,\n\t.timeout_ns\t\t= 18500000,\t \n};\n\nstatic const struct ping_cfg pa_laser_ping_cfg = {\n\t.trigger_pulse_us\t= 5,\n\t.laserping_error\t= 1,\n\t.timeout_ns\t\t= 15500000,\t \n};\n\nstatic irqreturn_t ping_handle_irq(int irq, void *dev_id)\n{\n\tstruct iio_dev *indio_dev = dev_id;\n\tstruct ping_data *data = iio_priv(indio_dev);\n\tktime_t now = ktime_get();\n\n\tif (gpiod_get_value(data->gpiod_ping)) {\n\t\tdata->ts_rising = now;\n\t\tcomplete(&data->rising);\n\t} else {\n\t\tdata->ts_falling = now;\n\t\tcomplete(&data->falling);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ping_read(struct iio_dev *indio_dev)\n{\n\tstruct ping_data *data = iio_priv(indio_dev);\n\tint ret;\n\tktime_t ktime_dt;\n\ts64 dt_ns;\n\tu32 time_ns, distance_mm;\n\tstruct platform_device *pdev = to_platform_device(data->dev);\n\n\t \n\tmutex_lock(&data->lock);\n\n\treinit_completion(&data->rising);\n\treinit_completion(&data->falling);\n\n\tgpiod_set_value(data->gpiod_ping, 1);\n\tudelay(data->cfg->trigger_pulse_us);\n\tgpiod_set_value(data->gpiod_ping, 0);\n\n\tret = gpiod_direction_input(data->gpiod_ping);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\n\tdata->irqnr = gpiod_to_irq(data->gpiod_ping);\n\tif (data->irqnr < 0) {\n\t\tdev_err(data->dev, \"gpiod_to_irq: %d\\n\", data->irqnr);\n\t\tmutex_unlock(&data->lock);\n\t\treturn data->irqnr;\n\t}\n\n\tret = request_irq(data->irqnr, ping_handle_irq,\n\t\t\t\tIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\t\t\t\t\t\t\tpdev->name, indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"request_irq: %d\\n\", ret);\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\n\t \n\tret = wait_for_completion_killable_timeout(&data->rising, HZ/50);\n\tif (ret < 0)\n\t\tgoto err_reset_direction;\n\telse if (ret == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_reset_direction;\n\t}\n\n\t \n\tret = wait_for_completion_killable_timeout(&data->falling, HZ/20);\n\tif (ret < 0)\n\t\tgoto err_reset_direction;\n\telse if (ret == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_reset_direction;\n\t}\n\n\tktime_dt = ktime_sub(data->ts_falling, data->ts_rising);\n\n\tfree_irq(data->irqnr, indio_dev);\n\n\tret = gpiod_direction_output(data->gpiod_ping, GPIOD_OUT_LOW);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\n\tmutex_unlock(&data->lock);\n\n\tdt_ns = ktime_to_ns(ktime_dt);\n\tif (dt_ns > data->cfg->timeout_ns) {\n\t\tdev_dbg(data->dev, \"distance out of range: dt=%lldns\\n\",\n\t\t\t\t\t\t\t\tdt_ns);\n\t\treturn -EIO;\n\t}\n\n\ttime_ns = dt_ns;\n\n\t \n\tif (data->cfg->laserping_error) {\n\t\tif ((time_ns > 12500000) && (time_ns <= 13500000)) {\n\t\t\tdev_dbg(data->dev, \"target too close or to far\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif ((time_ns > 13500000) && (time_ns <= 14500000)) {\n\t\t\tdev_dbg(data->dev, \"internal sensor error\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif ((time_ns > 14500000) && (time_ns <= 15500000)) {\n\t\t\tdev_dbg(data->dev, \"internal sensor timeout\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tdistance_mm = time_ns * 232 / 1350800;\n\n\treturn distance_mm;\n\nerr_reset_direction:\n\tfree_irq(data->irqnr, indio_dev);\n\tmutex_unlock(&data->lock);\n\n\tif (gpiod_direction_output(data->gpiod_ping, GPIOD_OUT_LOW))\n\t\tdev_dbg(data->dev, \"error in gpiod_direction_output\\n\");\n\treturn ret;\n}\n\nstatic int ping_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *channel, int *val,\n\t\t\t    int *val2, long info)\n{\n\tint ret;\n\n\tif (channel->type != IIO_DISTANCE)\n\t\treturn -EINVAL;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = ping_read(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*val = 0;\n\t\t*val2 = 1000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info ping_iio_info = {\n\t.read_raw\t\t= ping_read_raw,\n};\n\nstatic const struct iio_chan_spec ping_chan_spec[] = {\n\t{\n\t\t.type = IIO_DISTANCE,\n\t\t.info_mask_separate =\n\t\t\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t},\n};\n\nstatic const struct of_device_id of_ping_match[] = {\n\t{ .compatible = \"parallax,ping\", .data = &pa_ping_cfg },\n\t{ .compatible = \"parallax,laserping\", .data = &pa_laser_ping_cfg },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, of_ping_match);\n\nstatic int ping_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ping_data *data;\n\tstruct iio_dev *indio_dev;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(struct ping_data));\n\tif (!indio_dev) {\n\t\tdev_err(dev, \"failed to allocate IIO device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = iio_priv(indio_dev);\n\tdata->dev = dev;\n\tdata->cfg = device_get_match_data(dev);\n\n\tmutex_init(&data->lock);\n\tinit_completion(&data->rising);\n\tinit_completion(&data->falling);\n\n\tdata->gpiod_ping = devm_gpiod_get(dev, \"ping\", GPIOD_OUT_LOW);\n\tif (IS_ERR(data->gpiod_ping)) {\n\t\tdev_err(dev, \"failed to get ping-gpios: err=%ld\\n\",\n\t\t\t\t\t\tPTR_ERR(data->gpiod_ping));\n\t\treturn PTR_ERR(data->gpiod_ping);\n\t}\n\n\tif (gpiod_cansleep(data->gpiod_ping)) {\n\t\tdev_err(data->dev, \"cansleep-GPIOs not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tplatform_set_drvdata(pdev, indio_dev);\n\n\tindio_dev->name = \"ping\";\n\tindio_dev->info = &ping_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = ping_chan_spec;\n\tindio_dev->num_channels = ARRAY_SIZE(ping_chan_spec);\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic struct platform_driver ping_driver = {\n\t.probe\t\t= ping_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"ping-gpio\",\n\t\t.of_match_table\t= of_ping_match,\n\t},\n};\n\nmodule_platform_driver(ping_driver);\n\nMODULE_AUTHOR(\"Andreas Klinger <ak@it-klinger.de>\");\nMODULE_DESCRIPTION(\"PING sensors for distance measuring using one GPIOs\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:ping\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}