{
  "module_name": "sx9500.c",
  "hash_id": "184d7676b6e191679176d74cc42224414889247f0184073d0255ae7bf3bf5ebf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/proximity/sx9500.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/irq.h>\n#include <linux/acpi.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regmap.h>\n#include <linux/pm.h>\n#include <linux/delay.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#define SX9500_DRIVER_NAME\t\t\"sx9500\"\n#define SX9500_IRQ_NAME\t\t\t\"sx9500_event\"\n\n \n#define SX9500_REG_IRQ_SRC\t\t0x00\n#define SX9500_REG_STAT\t\t\t0x01\n#define SX9500_REG_IRQ_MSK\t\t0x03\n\n#define SX9500_REG_PROX_CTRL0\t\t0x06\n#define SX9500_REG_PROX_CTRL1\t\t0x07\n#define SX9500_REG_PROX_CTRL2\t\t0x08\n#define SX9500_REG_PROX_CTRL3\t\t0x09\n#define SX9500_REG_PROX_CTRL4\t\t0x0a\n#define SX9500_REG_PROX_CTRL5\t\t0x0b\n#define SX9500_REG_PROX_CTRL6\t\t0x0c\n#define SX9500_REG_PROX_CTRL7\t\t0x0d\n#define SX9500_REG_PROX_CTRL8\t\t0x0e\n\n#define SX9500_REG_SENSOR_SEL\t\t0x20\n#define SX9500_REG_USE_MSB\t\t0x21\n#define SX9500_REG_USE_LSB\t\t0x22\n#define SX9500_REG_AVG_MSB\t\t0x23\n#define SX9500_REG_AVG_LSB\t\t0x24\n#define SX9500_REG_DIFF_MSB\t\t0x25\n#define SX9500_REG_DIFF_LSB\t\t0x26\n#define SX9500_REG_OFFSET_MSB\t\t0x27\n#define SX9500_REG_OFFSET_LSB\t\t0x28\n\n#define SX9500_REG_RESET\t\t0x7f\n\n \n#define SX9500_SOFT_RESET\t\t0xde\n\n#define SX9500_SCAN_PERIOD_MASK\t\tGENMASK(6, 4)\n#define SX9500_SCAN_PERIOD_SHIFT\t4\n\n \n#define SX9500_CLOSE_IRQ\t\tBIT(6)\n#define SX9500_FAR_IRQ\t\t\tBIT(5)\n#define SX9500_CONVDONE_IRQ\t\tBIT(3)\n\n#define SX9500_PROXSTAT_SHIFT\t\t4\n#define SX9500_COMPSTAT_MASK\t\tGENMASK(3, 0)\n\n#define SX9500_NUM_CHANNELS\t\t4\n#define SX9500_CHAN_MASK\t\tGENMASK(SX9500_NUM_CHANNELS - 1, 0)\n\nstruct sx9500_data {\n\tstruct mutex mutex;\n\tstruct i2c_client *client;\n\tstruct iio_trigger *trig;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *gpiod_rst;\n\t \n\tbool prox_stat[SX9500_NUM_CHANNELS];\n\tbool event_enabled[SX9500_NUM_CHANNELS];\n\tbool trigger_enabled;\n\tu16 *buffer;\n\t \n\tunsigned int suspend_ctrl0;\n\tstruct completion completion;\n\tint data_rdy_users, close_far_users;\n\tint channel_users[SX9500_NUM_CHANNELS];\n};\n\nstatic const struct iio_event_spec sx9500_events[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\n#define SX9500_CHANNEL(idx)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.type = IIO_PROXIMITY,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t\t.indexed = 1,\t\t\t\t\t\\\n\t\t.channel = idx,\t\t\t\t\t\\\n\t\t.event_spec = sx9500_events,\t\t\t\\\n\t\t.num_event_specs = ARRAY_SIZE(sx9500_events),\t\\\n\t\t.scan_index = idx,\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\\\n\t\t\t.sign = 'u',\t\t\t\t\\\n\t\t\t.realbits = 16,\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\\\n\t\t\t.shift = 0,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec sx9500_channels[] = {\n\tSX9500_CHANNEL(0),\n\tSX9500_CHANNEL(1),\n\tSX9500_CHANNEL(2),\n\tSX9500_CHANNEL(3),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic const struct {\n\tint val;\n\tint val2;\n} sx9500_samp_freq_table[] = {\n\t{33, 333333},\n\t{16, 666666},\n\t{11, 111111},\n\t{8, 333333},\n\t{6, 666666},\n\t{5, 0},\n\t{3, 333333},\n\t{2, 500000},\n};\n\nstatic const unsigned int sx9500_scan_period_table[] = {\n\t30, 60, 90, 120, 150, 200, 300, 400,\n};\n\nstatic const struct regmap_range sx9500_writable_reg_ranges[] = {\n\tregmap_reg_range(SX9500_REG_IRQ_MSK, SX9500_REG_IRQ_MSK),\n\tregmap_reg_range(SX9500_REG_PROX_CTRL0, SX9500_REG_PROX_CTRL8),\n\tregmap_reg_range(SX9500_REG_SENSOR_SEL, SX9500_REG_SENSOR_SEL),\n\tregmap_reg_range(SX9500_REG_OFFSET_MSB, SX9500_REG_OFFSET_LSB),\n\tregmap_reg_range(SX9500_REG_RESET, SX9500_REG_RESET),\n};\n\nstatic const struct regmap_access_table sx9500_writeable_regs = {\n\t.yes_ranges = sx9500_writable_reg_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(sx9500_writable_reg_ranges),\n};\n\n \nstatic const struct regmap_range sx9500_non_readable_reg_ranges[] = {\n\tregmap_reg_range(SX9500_REG_STAT + 1, SX9500_REG_STAT + 1),\n\tregmap_reg_range(SX9500_REG_IRQ_MSK + 1, SX9500_REG_PROX_CTRL0 - 1),\n\tregmap_reg_range(SX9500_REG_PROX_CTRL8 + 1, SX9500_REG_SENSOR_SEL - 1),\n\tregmap_reg_range(SX9500_REG_OFFSET_LSB + 1, SX9500_REG_RESET - 1),\n};\n\nstatic const struct regmap_access_table sx9500_readable_regs = {\n\t.no_ranges = sx9500_non_readable_reg_ranges,\n\t.n_no_ranges = ARRAY_SIZE(sx9500_non_readable_reg_ranges),\n};\n\nstatic const struct regmap_range sx9500_volatile_reg_ranges[] = {\n\tregmap_reg_range(SX9500_REG_IRQ_SRC, SX9500_REG_STAT),\n\tregmap_reg_range(SX9500_REG_USE_MSB, SX9500_REG_OFFSET_LSB),\n\tregmap_reg_range(SX9500_REG_RESET, SX9500_REG_RESET),\n};\n\nstatic const struct regmap_access_table sx9500_volatile_regs = {\n\t.yes_ranges = sx9500_volatile_reg_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(sx9500_volatile_reg_ranges),\n};\n\nstatic const struct regmap_config sx9500_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = SX9500_REG_RESET,\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.wr_table = &sx9500_writeable_regs,\n\t.rd_table = &sx9500_readable_regs,\n\t.volatile_table = &sx9500_volatile_regs,\n};\n\nstatic int sx9500_inc_users(struct sx9500_data *data, int *counter,\n\t\t\t    unsigned int reg, unsigned int bitmask)\n{\n\t(*counter)++;\n\tif (*counter != 1)\n\t\t \n\t\treturn 0;\n\n\treturn regmap_update_bits(data->regmap, reg, bitmask, bitmask);\n}\n\nstatic int sx9500_dec_users(struct sx9500_data *data, int *counter,\n\t\t\t    unsigned int reg, unsigned int bitmask)\n{\n\t(*counter)--;\n\tif (*counter != 0)\n\t\t \n\t\treturn 0;\n\n\treturn regmap_update_bits(data->regmap, reg, bitmask, 0);\n}\n\nstatic int sx9500_inc_chan_users(struct sx9500_data *data, int chan)\n{\n\treturn sx9500_inc_users(data, &data->channel_users[chan],\n\t\t\t\tSX9500_REG_PROX_CTRL0, BIT(chan));\n}\n\nstatic int sx9500_dec_chan_users(struct sx9500_data *data, int chan)\n{\n\treturn sx9500_dec_users(data, &data->channel_users[chan],\n\t\t\t\tSX9500_REG_PROX_CTRL0, BIT(chan));\n}\n\nstatic int sx9500_inc_data_rdy_users(struct sx9500_data *data)\n{\n\treturn sx9500_inc_users(data, &data->data_rdy_users,\n\t\t\t\tSX9500_REG_IRQ_MSK, SX9500_CONVDONE_IRQ);\n}\n\nstatic int sx9500_dec_data_rdy_users(struct sx9500_data *data)\n{\n\treturn sx9500_dec_users(data, &data->data_rdy_users,\n\t\t\t\tSX9500_REG_IRQ_MSK, SX9500_CONVDONE_IRQ);\n}\n\nstatic int sx9500_inc_close_far_users(struct sx9500_data *data)\n{\n\treturn sx9500_inc_users(data, &data->close_far_users,\n\t\t\t\tSX9500_REG_IRQ_MSK,\n\t\t\t\tSX9500_CLOSE_IRQ | SX9500_FAR_IRQ);\n}\n\nstatic int sx9500_dec_close_far_users(struct sx9500_data *data)\n{\n\treturn sx9500_dec_users(data, &data->close_far_users,\n\t\t\t\tSX9500_REG_IRQ_MSK,\n\t\t\t\tSX9500_CLOSE_IRQ | SX9500_FAR_IRQ);\n}\n\nstatic int sx9500_read_prox_data(struct sx9500_data *data,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t int *val)\n{\n\tint ret;\n\t__be16 regval;\n\n\tret = regmap_write(data->regmap, SX9500_REG_SENSOR_SEL, chan->channel);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, SX9500_REG_USE_MSB, &regval, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = be16_to_cpu(regval);\n\n\treturn IIO_VAL_INT;\n}\n\n \nstatic int sx9500_wait_for_sample(struct sx9500_data *data)\n{\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(data->regmap, SX9500_REG_PROX_CTRL0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = (val & SX9500_SCAN_PERIOD_MASK) >> SX9500_SCAN_PERIOD_SHIFT;\n\n\tmsleep(sx9500_scan_period_table[val]);\n\n\treturn 0;\n}\n\nstatic int sx9500_read_proximity(struct sx9500_data *data,\n\t\t\t\t const struct iio_chan_spec *chan,\n\t\t\t\t int *val)\n{\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\n\tret = sx9500_inc_chan_users(data, chan->channel);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = sx9500_inc_data_rdy_users(data);\n\tif (ret < 0)\n\t\tgoto out_dec_chan;\n\n\tmutex_unlock(&data->mutex);\n\n\tif (data->client->irq > 0)\n\t\tret = wait_for_completion_interruptible(&data->completion);\n\telse\n\t\tret = sx9500_wait_for_sample(data);\n\n\tmutex_lock(&data->mutex);\n\n\tif (ret < 0)\n\t\tgoto out_dec_data_rdy;\n\n\tret = sx9500_read_prox_data(data, chan, val);\n\tif (ret < 0)\n\t\tgoto out_dec_data_rdy;\n\n\tret = sx9500_dec_data_rdy_users(data);\n\tif (ret < 0)\n\t\tgoto out_dec_chan;\n\n\tret = sx9500_dec_chan_users(data, chan->channel);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = IIO_VAL_INT;\n\n\tgoto out;\n\nout_dec_data_rdy:\n\tsx9500_dec_data_rdy_users(data);\nout_dec_chan:\n\tsx9500_dec_chan_users(data, chan->channel);\nout:\n\tmutex_unlock(&data->mutex);\n\treinit_completion(&data->completion);\n\n\treturn ret;\n}\n\nstatic int sx9500_read_samp_freq(struct sx9500_data *data,\n\t\t\t\t int *val, int *val2)\n{\n\tint ret;\n\tunsigned int regval;\n\n\tmutex_lock(&data->mutex);\n\tret = regmap_read(data->regmap, SX9500_REG_PROX_CTRL0, &regval);\n\tmutex_unlock(&data->mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregval = (regval & SX9500_SCAN_PERIOD_MASK) >> SX9500_SCAN_PERIOD_SHIFT;\n\t*val = sx9500_samp_freq_table[regval].val;\n\t*val2 = sx9500_samp_freq_table[regval].val2;\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int sx9500_read_raw(struct iio_dev *indio_dev,\n\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\tswitch (mask) {\n\t\tcase IIO_CHAN_INFO_RAW:\n\t\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = sx9500_read_proximity(data, chan, val);\n\t\t\tiio_device_release_direct_mode(indio_dev);\n\t\t\treturn ret;\n\t\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t\treturn sx9500_read_samp_freq(data, val, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sx9500_set_samp_freq(struct sx9500_data *data,\n\t\t\t\tint val, int val2)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(sx9500_samp_freq_table); i++)\n\t\tif (val == sx9500_samp_freq_table[i].val &&\n\t\t    val2 == sx9500_samp_freq_table[i].val2)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(sx9500_samp_freq_table))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->mutex);\n\n\tret = regmap_update_bits(data->regmap, SX9500_REG_PROX_CTRL0,\n\t\t\t\t SX9500_SCAN_PERIOD_MASK,\n\t\t\t\t i << SX9500_SCAN_PERIOD_SHIFT);\n\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int sx9500_write_raw(struct iio_dev *indio_dev,\n\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\n\tswitch (chan->type) {\n\tcase IIO_PROXIMITY:\n\t\tswitch (mask) {\n\t\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t\treturn sx9500_set_samp_freq(data, val, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic irqreturn_t sx9500_irq_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\n\tif (data->trigger_enabled)\n\t\tiio_trigger_poll(data->trig);\n\n\t \n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic void sx9500_push_events(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tunsigned int val, chan;\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\n\tret = regmap_read(data->regmap, SX9500_REG_STAT, &val);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"i2c transfer error in irq\\n\");\n\t\treturn;\n\t}\n\n\tval >>= SX9500_PROXSTAT_SHIFT;\n\tfor (chan = 0; chan < SX9500_NUM_CHANNELS; chan++) {\n\t\tint dir;\n\t\tu64 ev;\n\t\tbool new_prox = val & BIT(chan);\n\n\t\tif (!data->event_enabled[chan])\n\t\t\tcontinue;\n\t\tif (new_prox == data->prox_stat[chan])\n\t\t\t \n\t\t\tcontinue;\n\n\t\tdir = new_prox ? IIO_EV_DIR_FALLING : IIO_EV_DIR_RISING;\n\t\tev = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, chan,\n\t\t\t\t\t  IIO_EV_TYPE_THRESH, dir);\n\t\tiio_push_event(indio_dev, ev, iio_get_time_ns(indio_dev));\n\t\tdata->prox_stat[chan] = new_prox;\n\t}\n}\n\nstatic irqreturn_t sx9500_irq_thread_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\tint ret;\n\tunsigned int val;\n\n\tmutex_lock(&data->mutex);\n\n\tret = regmap_read(data->regmap, SX9500_REG_IRQ_SRC, &val);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"i2c transfer error in irq\\n\");\n\t\tgoto out;\n\t}\n\n\tif (val & (SX9500_CLOSE_IRQ | SX9500_FAR_IRQ))\n\t\tsx9500_push_events(indio_dev);\n\n\tif (val & SX9500_CONVDONE_IRQ)\n\t\tcomplete(&data->completion);\n\nout:\n\tmutex_unlock(&data->mutex);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sx9500_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir)\n{\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\n\tif (chan->type != IIO_PROXIMITY || type != IIO_EV_TYPE_THRESH ||\n\t    dir != IIO_EV_DIR_EITHER)\n\t\treturn -EINVAL;\n\n\treturn data->event_enabled[chan->channel];\n}\n\nstatic int sx9500_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir,\n\t\t\t\t     int state)\n{\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (chan->type != IIO_PROXIMITY || type != IIO_EV_TYPE_THRESH ||\n\t    dir != IIO_EV_DIR_EITHER)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->mutex);\n\n\tif (state == 1) {\n\t\tret = sx9500_inc_chan_users(data, chan->channel);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\t\tret = sx9500_inc_close_far_users(data);\n\t\tif (ret < 0)\n\t\t\tgoto out_undo_chan;\n\t} else {\n\t\tret = sx9500_dec_chan_users(data, chan->channel);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\t\tret = sx9500_dec_close_far_users(data);\n\t\tif (ret < 0)\n\t\t\tgoto out_undo_chan;\n\t}\n\n\tdata->event_enabled[chan->channel] = state;\n\tgoto out_unlock;\n\nout_undo_chan:\n\tif (state == 1)\n\t\tsx9500_dec_chan_users(data, chan->channel);\n\telse\n\t\tsx9500_inc_chan_users(data, chan->channel);\nout_unlock:\n\tmutex_unlock(&data->mutex);\n\treturn ret;\n}\n\nstatic int sx9500_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t   const unsigned long *scan_mask)\n{\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\n\tmutex_lock(&data->mutex);\n\tkfree(data->buffer);\n\tdata->buffer = kzalloc(indio_dev->scan_bytes, GFP_KERNEL);\n\tmutex_unlock(&data->mutex);\n\n\tif (data->buffer == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\n\t\"2.500000 3.333333 5 6.666666 8.333333 11.111111 16.666666 33.333333\");\n\nstatic struct attribute *sx9500_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group sx9500_attribute_group = {\n\t.attrs = sx9500_attributes,\n};\n\nstatic const struct iio_info sx9500_info = {\n\t.attrs = &sx9500_attribute_group,\n\t.read_raw = &sx9500_read_raw,\n\t.write_raw = &sx9500_write_raw,\n\t.read_event_config = &sx9500_read_event_config,\n\t.write_event_config = &sx9500_write_event_config,\n\t.update_scan_mode = &sx9500_update_scan_mode,\n};\n\nstatic int sx9500_set_trigger_state(struct iio_trigger *trig,\n\t\t\t\t    bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\n\tif (state)\n\t\tret = sx9500_inc_data_rdy_users(data);\n\telse\n\t\tret = sx9500_dec_data_rdy_users(data);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdata->trigger_enabled = state;\n\nout:\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic const struct iio_trigger_ops sx9500_trigger_ops = {\n\t.set_trigger_state = sx9500_set_trigger_state,\n};\n\nstatic irqreturn_t sx9500_trigger_handler(int irq, void *private)\n{\n\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\tint val, bit, ret, i = 0;\n\n\tmutex_lock(&data->mutex);\n\n\tfor_each_set_bit(bit, indio_dev->active_scan_mask,\n\t\t\t indio_dev->masklength) {\n\t\tret = sx9500_read_prox_data(data, &indio_dev->channels[bit],\n\t\t\t\t\t    &val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tdata->buffer[i++] = val;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, data->buffer,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\nout:\n\tmutex_unlock(&data->mutex);\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sx9500_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\tint ret = 0, i;\n\n\tmutex_lock(&data->mutex);\n\n\tfor (i = 0; i < SX9500_NUM_CHANNELS; i++)\n\t\tif (test_bit(i, indio_dev->active_scan_mask)) {\n\t\t\tret = sx9500_inc_chan_users(data, i);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\tif (ret)\n\t\tfor (i = i - 1; i >= 0; i--)\n\t\t\tif (test_bit(i, indio_dev->active_scan_mask))\n\t\t\t\tsx9500_dec_chan_users(data, i);\n\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int sx9500_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\tint ret = 0, i;\n\n\tmutex_lock(&data->mutex);\n\n\tfor (i = 0; i < SX9500_NUM_CHANNELS; i++)\n\t\tif (test_bit(i, indio_dev->active_scan_mask)) {\n\t\t\tret = sx9500_dec_chan_users(data, i);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\tif (ret)\n\t\tfor (i = i - 1; i >= 0; i--)\n\t\t\tif (test_bit(i, indio_dev->active_scan_mask))\n\t\t\t\tsx9500_inc_chan_users(data, i);\n\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic const struct iio_buffer_setup_ops sx9500_buffer_setup_ops = {\n\t.postenable = sx9500_buffer_postenable,\n\t.predisable = sx9500_buffer_predisable,\n};\n\nstruct sx9500_reg_default {\n\tu8 reg;\n\tu8 def;\n};\n\nstatic const struct sx9500_reg_default sx9500_default_regs[] = {\n\t{\n\t\t.reg = SX9500_REG_PROX_CTRL1,\n\t\t \n\t\t.def = 0x43,\n\t},\n\t{\n\t\t.reg = SX9500_REG_PROX_CTRL2,\n\t\t \n\t\t.def = 0x77,\n\t},\n\t{\n\t\t.reg = SX9500_REG_PROX_CTRL3,\n\t\t \n\t\t.def = 0x40,\n\t},\n\t{\n\t\t.reg = SX9500_REG_PROX_CTRL4,\n\t\t \n\t\t.def = 0x30,\n\t},\n\t{\n\t\t.reg = SX9500_REG_PROX_CTRL5,\n\t\t \n\t\t.def = 0x0f,\n\t},\n\t{\n\t\t.reg = SX9500_REG_PROX_CTRL6,\n\t\t \n\t\t.def = 0x0e,\n\t},\n\t{\n\t\t.reg = SX9500_REG_PROX_CTRL7,\n\t\t \n\t\t.def = 0x00,\n\t},\n\t{\n\t\t.reg = SX9500_REG_PROX_CTRL8,\n\t\t \n\t\t.def = 0x00,\n\t},\n\t{\n\t\t.reg = SX9500_REG_PROX_CTRL0,\n\t\t \n\t\t.def = 0x00,\n\t},\n};\n\n \nstatic int sx9500_init_compensation(struct iio_dev *indio_dev)\n{\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\tint i, ret;\n\tunsigned int val;\n\n\tret = regmap_update_bits(data->regmap, SX9500_REG_PROX_CTRL0,\n\t\t\t\t SX9500_CHAN_MASK, SX9500_CHAN_MASK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 10; i >= 0; i--) {\n\t\tusleep_range(10000, 20000);\n\t\tret = regmap_read(data->regmap, SX9500_REG_STAT, &val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!(val & SX9500_COMPSTAT_MASK))\n\t\t\tbreak;\n\t}\n\n\tif (i < 0) {\n\t\tdev_err(&data->client->dev, \"initial compensation timed out\");\n\t\tret = -ETIMEDOUT;\n\t}\n\nout:\n\tregmap_update_bits(data->regmap, SX9500_REG_PROX_CTRL0,\n\t\t\t   SX9500_CHAN_MASK, 0);\n\treturn ret;\n}\n\nstatic int sx9500_init_device(struct iio_dev *indio_dev)\n{\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\tint ret, i;\n\tunsigned int val;\n\n\tif (data->gpiod_rst) {\n\t\tgpiod_set_value_cansleep(data->gpiod_rst, 0);\n\t\tusleep_range(1000, 2000);\n\t\tgpiod_set_value_cansleep(data->gpiod_rst, 1);\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tret = regmap_write(data->regmap, SX9500_REG_IRQ_MSK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(data->regmap, SX9500_REG_RESET,\n\t\t\t   SX9500_SOFT_RESET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(data->regmap, SX9500_REG_IRQ_SRC, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(sx9500_default_regs); i++) {\n\t\tret = regmap_write(data->regmap,\n\t\t\t\t   sx9500_default_regs[i].reg,\n\t\t\t\t   sx9500_default_regs[i].def);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn sx9500_init_compensation(indio_dev);\n}\n\nstatic const struct acpi_gpio_params reset_gpios = { 0, 0, false };\nstatic const struct acpi_gpio_params interrupt_gpios = { 2, 0, false };\n\nstatic const struct acpi_gpio_mapping acpi_sx9500_gpios[] = {\n\t{ \"reset-gpios\", &reset_gpios, 1 },\n\t \n\t{ \"interrupt-gpios\", &interrupt_gpios, 1, ACPI_GPIO_QUIRK_NO_IO_RESTRICTION },\n\t{ },\n};\n\nstatic void sx9500_gpio_probe(struct i2c_client *client,\n\t\t\t      struct sx9500_data *data)\n{\n\tstruct gpio_desc *gpiod_int;\n\tstruct device *dev;\n\tint ret;\n\n\tif (!client)\n\t\treturn;\n\n\tdev = &client->dev;\n\n\tret = devm_acpi_dev_add_driver_gpios(dev, acpi_sx9500_gpios);\n\tif (ret)\n\t\tdev_dbg(dev, \"Unable to add GPIO mapping table\\n\");\n\n\tif (client->irq <= 0) {\n\t\tgpiod_int = devm_gpiod_get(dev, \"interrupt\", GPIOD_IN);\n\t\tif (IS_ERR(gpiod_int))\n\t\t\tdev_err(dev, \"gpio get irq failed\\n\");\n\t\telse\n\t\t\tclient->irq = gpiod_to_irq(gpiod_int);\n\t}\n\n\tdata->gpiod_rst = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(data->gpiod_rst)) {\n\t\tdev_warn(dev, \"gpio get reset pin failed\\n\");\n\t\tdata->gpiod_rst = NULL;\n\t}\n}\n\nstatic int sx9500_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\tstruct sx9500_data *data;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->mutex);\n\tinit_completion(&data->completion);\n\tdata->trigger_enabled = false;\n\n\tdata->regmap = devm_regmap_init_i2c(client, &sx9500_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\tindio_dev->name = SX9500_DRIVER_NAME;\n\tindio_dev->channels = sx9500_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(sx9500_channels);\n\tindio_dev->info = &sx9500_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\ti2c_set_clientdata(client, indio_dev);\n\n\tsx9500_gpio_probe(client, data);\n\n\tret = sx9500_init_device(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (client->irq <= 0)\n\t\tdev_warn(&client->dev, \"no valid irq found\\n\");\n\telse {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\tsx9500_irq_handler, sx9500_irq_thread_handler,\n\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\tSX9500_IRQ_NAME, indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata->trig = devm_iio_trigger_alloc(&client->dev,\n\t\t\t\t\"%s-dev%d\", indio_dev->name, iio_device_id(indio_dev));\n\t\tif (!data->trig)\n\t\t\treturn -ENOMEM;\n\n\t\tdata->trig->ops = &sx9500_trigger_ops;\n\t\tiio_trigger_set_drvdata(data->trig, indio_dev);\n\n\t\tret = iio_trigger_register(data->trig);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL,\n\t\t\t\t\t sx9500_trigger_handler,\n\t\t\t\t\t &sx9500_buffer_setup_ops);\n\tif (ret < 0)\n\t\tgoto out_trigger_unregister;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto out_buffer_cleanup;\n\n\treturn 0;\n\nout_buffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\nout_trigger_unregister:\n\tif (client->irq > 0)\n\t\tiio_trigger_unregister(data->trig);\n\n\treturn ret;\n}\n\nstatic void sx9500_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tif (client->irq > 0)\n\t\tiio_trigger_unregister(data->trig);\n\tkfree(data->buffer);\n}\n\nstatic int sx9500_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = regmap_read(data->regmap, SX9500_REG_PROX_CTRL0,\n\t\t\t  &data->suspend_ctrl0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = regmap_write(data->regmap, SX9500_REG_PROX_CTRL0, 0);\n\nout:\n\tmutex_unlock(&data->mutex);\n\treturn ret;\n}\n\nstatic int sx9500_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct sx9500_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = regmap_write(data->regmap, SX9500_REG_PROX_CTRL0,\n\t\t\t   data->suspend_ctrl0);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(sx9500_pm_ops, sx9500_suspend, sx9500_resume);\n\nstatic const struct acpi_device_id sx9500_acpi_match[] = {\n\t{\"SSX9500\", 0},\n\t{\"SASX9500\", 0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, sx9500_acpi_match);\n\nstatic const struct of_device_id sx9500_of_match[] = {\n\t{ .compatible = \"semtech,sx9500\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sx9500_of_match);\n\nstatic const struct i2c_device_id sx9500_id[] = {\n\t{\"sx9500\", 0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, sx9500_id);\n\nstatic struct i2c_driver sx9500_driver = {\n\t.driver = {\n\t\t.name\t= SX9500_DRIVER_NAME,\n\t\t.acpi_match_table = sx9500_acpi_match,\n\t\t.of_match_table = sx9500_of_match,\n\t\t.pm = pm_sleep_ptr(&sx9500_pm_ops),\n\t},\n\t.probe\t\t= sx9500_probe,\n\t.remove\t\t= sx9500_remove,\n\t.id_table\t= sx9500_id,\n};\nmodule_i2c_driver(sx9500_driver);\n\nMODULE_AUTHOR(\"Vlad Dogaru <vlad.dogaru@intel.com>\");\nMODULE_DESCRIPTION(\"Driver for Semtech SX9500 proximity sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}