{
  "module_name": "pulsedlight-lidar-lite-v2.c",
  "hash_id": "530dc685bcf01b767e77d71d9489048a0111ba7980ceb493514186764c694ab9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/proximity/pulsedlight-lidar-lite-v2.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pm_runtime.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#define LIDAR_REG_CONTROL\t\t0x00\n#define LIDAR_REG_CONTROL_ACQUIRE\tBIT(2)\n\n#define LIDAR_REG_STATUS\t\t0x01\n#define LIDAR_REG_STATUS_INVALID\tBIT(3)\n#define LIDAR_REG_STATUS_READY\t\tBIT(0)\n\n#define LIDAR_REG_DATA_HBYTE\t\t0x0f\n#define LIDAR_REG_DATA_LBYTE\t\t0x10\n#define LIDAR_REG_DATA_WORD_READ\tBIT(7)\n\n#define LIDAR_REG_PWR_CONTROL\t0x65\n\n#define LIDAR_DRV_NAME \"lidar\"\n\nstruct lidar_data {\n\tstruct iio_dev *indio_dev;\n\tstruct i2c_client *client;\n\n\tint (*xfer)(struct lidar_data *data, u8 reg, u8 *val, int len);\n\tint i2c_enabled;\n\n\t \n\tstruct {\n\t\tu16 chan;\n\t\ts64 timestamp __aligned(8);\n\t} scan;\n};\n\nstatic const struct iio_chan_spec lidar_channels[] = {\n\t{\n\t\t.type = IIO_DISTANCE,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(1),\n};\n\nstatic int lidar_i2c_xfer(struct lidar_data *data, u8 reg, u8 *val, int len)\n{\n\tstruct i2c_client *client = data->client;\n\tstruct i2c_msg msg[2];\n\tint ret;\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = client->flags | I2C_M_STOP;\n\tmsg[0].len = 1;\n\tmsg[0].buf  = (char *) &reg;\n\n\tmsg[1].addr = client->addr;\n\tmsg[1].flags = client->flags | I2C_M_RD;\n\tmsg[1].len = len;\n\tmsg[1].buf = (char *) val;\n\n\tret = i2c_transfer(client->adapter, msg, 2);\n\n\treturn (ret == 2) ? 0 : -EIO;\n}\n\nstatic int lidar_smbus_xfer(struct lidar_data *data, u8 reg, u8 *val, int len)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\t \n\n\twhile (len--) {\n\t\tret = i2c_smbus_write_byte(client, reg++);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"cannot write addr value\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = i2c_smbus_read_byte(client);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"cannot read data value\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t*(val++) = ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lidar_read_byte(struct lidar_data *data, u8 reg)\n{\n\tint ret;\n\tu8 val;\n\n\tret = data->xfer(data, reg, &val, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn val;\n}\n\nstatic inline int lidar_write_control(struct lidar_data *data, int val)\n{\n\treturn i2c_smbus_write_byte_data(data->client, LIDAR_REG_CONTROL, val);\n}\n\nstatic inline int lidar_write_power(struct lidar_data *data, int val)\n{\n\treturn i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\t LIDAR_REG_PWR_CONTROL, val);\n}\n\nstatic int lidar_read_measurement(struct lidar_data *data, u16 *reg)\n{\n\t__be16 value;\n\tint ret = data->xfer(data, LIDAR_REG_DATA_HBYTE |\n\t\t\t(data->i2c_enabled ? LIDAR_REG_DATA_WORD_READ : 0),\n\t\t\t(u8 *) &value, 2);\n\n\tif (!ret)\n\t\t*reg = be16_to_cpu(value);\n\n\treturn ret;\n}\n\nstatic int lidar_get_measurement(struct lidar_data *data, u16 *reg)\n{\n\tstruct i2c_client *client = data->client;\n\tint tries = 10;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(&client->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = lidar_write_control(data, LIDAR_REG_CONTROL_ACQUIRE);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"cannot send start measurement command\");\n\t\tpm_runtime_put_noidle(&client->dev);\n\t\treturn ret;\n\t}\n\n\twhile (tries--) {\n\t\tusleep_range(1000, 2000);\n\n\t\tret = lidar_read_byte(data, LIDAR_REG_STATUS);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (ret & LIDAR_REG_STATUS_INVALID) {\n\t\t\t*reg = 0;\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!(ret & LIDAR_REG_STATUS_READY)) {\n\t\t\tret = lidar_read_measurement(data, reg);\n\t\t\tbreak;\n\t\t}\n\t\tret = -EIO;\n\t}\n\tpm_runtime_mark_last_busy(&client->dev);\n\tpm_runtime_put_autosuspend(&client->dev);\n\n\treturn ret;\n}\n\nstatic int lidar_read_raw(struct iio_dev *indio_dev,\n\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t  int *val, int *val2, long mask)\n{\n\tstruct lidar_data *data = iio_priv(indio_dev);\n\tint ret = -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW: {\n\t\tu16 reg;\n\n\t\tif (iio_device_claim_direct_mode(indio_dev))\n\t\t\treturn -EBUSY;\n\n\t\tret = lidar_get_measurement(data, &reg);\n\t\tif (!ret) {\n\t\t\t*val = reg;\n\t\t\tret = IIO_VAL_INT;\n\t\t}\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\tbreak;\n\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = 10000;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t lidar_trigger_handler(int irq, void *private)\n{\n\tstruct iio_poll_func *pf = private;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct lidar_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = lidar_get_measurement(data, &data->scan.chan);\n\tif (!ret) {\n\t\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\t} else if (ret != -EINVAL) {\n\t\tdev_err(&data->client->dev, \"cannot read LIDAR measurement\");\n\t}\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_info lidar_info = {\n\t.read_raw = lidar_read_raw,\n};\n\nstatic int lidar_probe(struct i2c_client *client)\n{\n\tstruct lidar_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tdata = iio_priv(indio_dev);\n\n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdata->xfer = lidar_i2c_xfer;\n\t\tdata->i2c_enabled = 1;\n\t} else if (i2c_check_functionality(client->adapter,\n\t\t\t\tI2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_BYTE))\n\t\tdata->xfer = lidar_smbus_xfer;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\tindio_dev->info = &lidar_info;\n\tindio_dev->name = LIDAR_DRV_NAME;\n\tindio_dev->channels = lidar_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(lidar_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\tdata->client = client;\n\tdata->indio_dev = indio_dev;\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL,\n\t\t\t\t\t lidar_trigger_handler, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto error_unreg_buffer;\n\n\tpm_runtime_set_autosuspend_delay(&client->dev, 1000);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\tret = pm_runtime_set_active(&client->dev);\n\tif (ret)\n\t\tgoto error_unreg_buffer;\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_idle(&client->dev);\n\n\treturn 0;\n\nerror_unreg_buffer:\n\tiio_triggered_buffer_cleanup(indio_dev);\n\n\treturn ret;\n}\n\nstatic void lidar_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n}\n\nstatic const struct i2c_device_id lidar_id[] = {\n\t{\"lidar-lite-v2\", 0},\n\t{\"lidar-lite-v3\", 0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, lidar_id);\n\nstatic const struct of_device_id lidar_dt_ids[] = {\n\t{ .compatible = \"pulsedlight,lidar-lite-v2\" },\n\t{ .compatible = \"grmn,lidar-lite-v3\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lidar_dt_ids);\n\nstatic int lidar_pm_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lidar_data *data = iio_priv(indio_dev);\n\n\treturn lidar_write_power(data, 0x0f);\n}\n\nstatic int lidar_pm_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct lidar_data *data = iio_priv(indio_dev);\n\tint ret = lidar_write_power(data, 0);\n\n\t \n\tusleep_range(15000, 20000);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops lidar_pm_ops = {\n\tRUNTIME_PM_OPS(lidar_pm_runtime_suspend, lidar_pm_runtime_resume, NULL)\n};\n\nstatic struct i2c_driver lidar_driver = {\n\t.driver = {\n\t\t.name\t= LIDAR_DRV_NAME,\n\t\t.of_match_table\t= lidar_dt_ids,\n\t\t.pm\t= pm_ptr(&lidar_pm_ops),\n\t},\n\t.probe\t\t= lidar_probe,\n\t.remove\t\t= lidar_remove,\n\t.id_table\t= lidar_id,\n};\nmodule_i2c_driver(lidar_driver);\n\nMODULE_AUTHOR(\"Matt Ranostay <matt.ranostay@konsulko.com>\");\nMODULE_DESCRIPTION(\"PulsedLight LIDAR sensor\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}