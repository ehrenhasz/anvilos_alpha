{
  "module_name": "stx104.c",
  "hash_id": "6c178b641840bc693668c4984b21c769e40730ae27639208b8ae5177eb682b49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/addac/stx104.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/regmap.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/types.h>\n#include <linux/isa.h>\n#include <linux/kernel.h>\n#include <linux/limits.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\n#define STX104_OUT_CHAN(chan) {\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\\\n\t.channel = chan,\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\\\n\t.indexed = 1,\t\t\t\t\t\\\n\t.output = 1\t\t\t\t\t\\\n}\n#define STX104_IN_CHAN(chan, diff) {\t\t\t\t\t\\\n\t.type = IIO_VOLTAGE,\t\t\t\t\t\t\\\n\t.channel = chan,\t\t\t\t\t\t\\\n\t.channel2 = chan,\t\t\t\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_HARDWAREGAIN) |\t\\\n\t\tBIT(IIO_CHAN_INFO_OFFSET) | BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.differential = diff\t\t\t\t\t\t\\\n}\n\n#define STX104_NUM_OUT_CHAN 2\n\n#define STX104_EXTENT 16\n\nstatic unsigned int base[max_num_isa_dev(STX104_EXTENT)];\nstatic unsigned int num_stx104;\nmodule_param_hw_array(base, uint, ioport, &num_stx104, 0);\nMODULE_PARM_DESC(base, \"Apex Embedded Systems STX104 base addresses\");\n\n#define STX104_AIO_BASE 0x0\n#define STX104_SOFTWARE_STROBE STX104_AIO_BASE\n#define STX104_ADC_DATA STX104_AIO_BASE\n#define STX104_ADC_CHANNEL (STX104_AIO_BASE + 0x2)\n#define STX104_DIO_REG (STX104_AIO_BASE + 0x3)\n#define STX104_DAC_BASE (STX104_AIO_BASE + 0x4)\n#define STX104_ADC_STATUS (STX104_AIO_BASE + 0x8)\n#define STX104_ADC_CONTROL (STX104_AIO_BASE + 0x9)\n#define STX104_ADC_CONFIGURATION (STX104_AIO_BASE + 0x11)\n\n#define STX104_AIO_DATA_STRIDE 2\n#define STX104_DAC_OFFSET(_channel) (STX104_DAC_BASE + STX104_AIO_DATA_STRIDE * (_channel))\n\n \n#define STX104_FC GENMASK(3, 0)\n#define STX104_LC GENMASK(7, 4)\n#define STX104_SINGLE_CHANNEL(_channel) \\\n\t(u8_encode_bits(_channel, STX104_FC) | u8_encode_bits(_channel, STX104_LC))\n\n \n#define STX104_SD BIT(5)\n#define STX104_CNV BIT(7)\n#define STX104_DIFFERENTIAL 1\n\n \n#define STX104_ALSS GENMASK(1, 0)\n#define STX104_SOFTWARE_TRIGGER u8_encode_bits(0x0, STX104_ALSS)\n\n \n#define STX104_GAIN GENMASK(1, 0)\n#define STX104_ADBU BIT(2)\n#define STX104_BIPOLAR 0\n#define STX104_GAIN_X1 0\n#define STX104_GAIN_X2 1\n#define STX104_GAIN_X4 2\n#define STX104_GAIN_X8 3\n\n \nstruct stx104_iio {\n\tstruct mutex lock;\n\tstruct regmap *aio_data_map;\n\tstruct regmap *aio_ctl_map;\n};\n\nstatic const struct regmap_range aio_ctl_wr_ranges[] = {\n\tregmap_reg_range(0x0, 0x0), regmap_reg_range(0x2, 0x2), regmap_reg_range(0x9, 0x9),\n\tregmap_reg_range(0x11, 0x11),\n};\nstatic const struct regmap_range aio_ctl_rd_ranges[] = {\n\tregmap_reg_range(0x2, 0x2), regmap_reg_range(0x8, 0x9), regmap_reg_range(0x11, 0x11),\n};\nstatic const struct regmap_range aio_ctl_volatile_ranges[] = {\n\tregmap_reg_range(0x8, 0x8),\n};\nstatic const struct regmap_access_table aio_ctl_wr_table = {\n\t.yes_ranges = aio_ctl_wr_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(aio_ctl_wr_ranges),\n};\nstatic const struct regmap_access_table aio_ctl_rd_table = {\n\t.yes_ranges = aio_ctl_rd_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(aio_ctl_rd_ranges),\n};\nstatic const struct regmap_access_table aio_ctl_volatile_table = {\n\t.yes_ranges = aio_ctl_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(aio_ctl_volatile_ranges),\n};\n\nstatic const struct regmap_config aio_ctl_regmap_config = {\n\t.name = \"aio_ctl\",\n\t.reg_bits = 8,\n\t.reg_stride = 1,\n\t.reg_base = STX104_AIO_BASE,\n\t.val_bits = 8,\n\t.io_port = true,\n\t.wr_table = &aio_ctl_wr_table,\n\t.rd_table = &aio_ctl_rd_table,\n\t.volatile_table = &aio_ctl_volatile_table,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct regmap_range aio_data_wr_ranges[] = {\n\tregmap_reg_range(0x4, 0x6),\n};\nstatic const struct regmap_range aio_data_rd_ranges[] = {\n\tregmap_reg_range(0x0, 0x0),\n};\nstatic const struct regmap_access_table aio_data_wr_table = {\n\t.yes_ranges = aio_data_wr_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(aio_data_wr_ranges),\n};\nstatic const struct regmap_access_table aio_data_rd_table = {\n\t.yes_ranges = aio_data_rd_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(aio_data_rd_ranges),\n};\n\nstatic const struct regmap_config aio_data_regmap_config = {\n\t.name = \"aio_data\",\n\t.reg_bits = 16,\n\t.reg_stride = STX104_AIO_DATA_STRIDE,\n\t.reg_base = STX104_AIO_BASE,\n\t.val_bits = 16,\n\t.io_port = true,\n\t.wr_table = &aio_data_wr_table,\n\t.rd_table = &aio_data_rd_table,\n\t.volatile_table = &aio_data_rd_table,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct regmap_config dio_regmap_config = {\n\t.name = \"dio\",\n\t.reg_bits = 8,\n\t.reg_stride = 1,\n\t.reg_base = STX104_DIO_REG,\n\t.val_bits = 8,\n\t.io_port = true,\n};\n\nstatic int stx104_read_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int *val, int *val2, long mask)\n{\n\tstruct stx104_iio *const priv = iio_priv(indio_dev);\n\tint err;\n\tunsigned int adc_config;\n\tunsigned int value;\n\tunsigned int adc_status;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\terr = regmap_read(priv->aio_ctl_map, STX104_ADC_CONFIGURATION, &adc_config);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*val = BIT(u8_get_bits(adc_config, STX104_GAIN));\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->output) {\n\t\t\terr = regmap_read(priv->aio_data_map, STX104_DAC_OFFSET(chan->channel),\n\t\t\t\t\t  &value);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t*val = value;\n\t\t\treturn IIO_VAL_INT;\n\t\t}\n\n\t\tmutex_lock(&priv->lock);\n\n\t\t \n\t\terr = regmap_write(priv->aio_ctl_map, STX104_ADC_CHANNEL,\n\t\t\t\t   STX104_SINGLE_CHANNEL(chan->channel));\n\t\tif (err) {\n\t\t\tmutex_unlock(&priv->lock);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\terr = regmap_write(priv->aio_ctl_map, STX104_SOFTWARE_STROBE, 0);\n\t\tif (err) {\n\t\t\tmutex_unlock(&priv->lock);\n\t\t\treturn err;\n\t\t}\n\t\terr = regmap_read_poll_timeout(priv->aio_ctl_map, STX104_ADC_STATUS, adc_status,\n\t\t\t\t\t       !u8_get_bits(adc_status, STX104_CNV), 0, 53687092);\n\t\tif (err) {\n\t\t\tmutex_unlock(&priv->lock);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = regmap_read(priv->aio_data_map, STX104_ADC_DATA, &value);\n\t\tif (err) {\n\t\t\tmutex_unlock(&priv->lock);\n\t\t\treturn err;\n\t\t}\n\t\t*val = value;\n\n\t\tmutex_unlock(&priv->lock);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\terr = regmap_read(priv->aio_ctl_map, STX104_ADC_CONFIGURATION, &adc_config);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*val = (u8_get_bits(adc_config, STX104_ADBU) == STX104_BIPOLAR) ? -32768 : 0;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\terr = regmap_read(priv->aio_ctl_map, STX104_ADC_CONFIGURATION, &adc_config);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*val = 5;\n\t\t*val2 = (u8_get_bits(adc_config, STX104_ADBU) == STX104_BIPOLAR) ? 14 : 15;\n\t\t*val2 += u8_get_bits(adc_config, STX104_GAIN);\n\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stx104_write_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec const *chan, int val, int val2, long mask)\n{\n\tstruct stx104_iio *const priv = iio_priv(indio_dev);\n\tu8 gain;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_HARDWAREGAIN:\n\t\t \n\t\tswitch (val) {\n\t\tcase 1:\n\t\t\tgain = STX104_GAIN_X1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgain = STX104_GAIN_X2;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tgain = STX104_GAIN_X4;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tgain = STX104_GAIN_X8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn regmap_write(priv->aio_ctl_map, STX104_ADC_CONFIGURATION, gain);\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (!chan->output)\n\t\t\treturn -EINVAL;\n\n\t\tif (val < 0 || val > U16_MAX)\n\t\t\treturn -EINVAL;\n\n\t\treturn regmap_write(priv->aio_data_map, STX104_DAC_OFFSET(chan->channel), val);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info stx104_info = {\n\t.read_raw = stx104_read_raw,\n\t.write_raw = stx104_write_raw\n};\n\n \nstatic const struct iio_chan_spec stx104_channels_sing[] = {\n\tSTX104_OUT_CHAN(0), STX104_OUT_CHAN(1),\n\tSTX104_IN_CHAN(0, 0), STX104_IN_CHAN(1, 0), STX104_IN_CHAN(2, 0),\n\tSTX104_IN_CHAN(3, 0), STX104_IN_CHAN(4, 0), STX104_IN_CHAN(5, 0),\n\tSTX104_IN_CHAN(6, 0), STX104_IN_CHAN(7, 0), STX104_IN_CHAN(8, 0),\n\tSTX104_IN_CHAN(9, 0), STX104_IN_CHAN(10, 0), STX104_IN_CHAN(11, 0),\n\tSTX104_IN_CHAN(12, 0), STX104_IN_CHAN(13, 0), STX104_IN_CHAN(14, 0),\n\tSTX104_IN_CHAN(15, 0)\n};\n \nstatic const struct iio_chan_spec stx104_channels_diff[] = {\n\tSTX104_OUT_CHAN(0), STX104_OUT_CHAN(1),\n\tSTX104_IN_CHAN(0, 1), STX104_IN_CHAN(1, 1), STX104_IN_CHAN(2, 1),\n\tSTX104_IN_CHAN(3, 1), STX104_IN_CHAN(4, 1), STX104_IN_CHAN(5, 1),\n\tSTX104_IN_CHAN(6, 1), STX104_IN_CHAN(7, 1)\n};\n\nstatic int stx104_reg_mask_xlate(struct gpio_regmap *const gpio, const unsigned int base,\n\t\t\t\t unsigned int offset, unsigned int *const reg,\n\t\t\t\t unsigned int *const mask)\n{\n\t \n\tif (offset >= 4)\n\t\toffset -= 4;\n\n\t*reg = base;\n\t*mask = BIT(offset);\n\n\treturn 0;\n}\n\n#define STX104_NGPIO 8\nstatic const char *stx104_names[STX104_NGPIO] = {\n\t\"DIN0\", \"DIN1\", \"DIN2\", \"DIN3\", \"DOUT0\", \"DOUT1\", \"DOUT2\", \"DOUT3\"\n};\n\nstatic int stx104_init_hw(struct stx104_iio *const priv)\n{\n\tint err;\n\n\t \n\terr = regmap_write(priv->aio_ctl_map, STX104_ADC_CONTROL, STX104_SOFTWARE_TRIGGER);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_write(priv->aio_ctl_map, STX104_ADC_CONFIGURATION, STX104_GAIN_X1);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_write(priv->aio_data_map, STX104_DAC_BASE, 0);\n\tif (err)\n\t\treturn err;\n\terr = regmap_write(priv->aio_data_map, STX104_DAC_BASE + STX104_AIO_DATA_STRIDE, 0);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int stx104_probe(struct device *dev, unsigned int id)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct stx104_iio *priv;\n\tstruct gpio_regmap_config gpio_config;\n\tvoid __iomem *stx104_base;\n\tstruct regmap *aio_ctl_map;\n\tstruct regmap *aio_data_map;\n\tstruct regmap *dio_map;\n\tint err;\n\tunsigned int adc_status;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*priv));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tif (!devm_request_region(dev, base[id], STX104_EXTENT,\n\t\tdev_name(dev))) {\n\t\tdev_err(dev, \"Unable to lock port addresses (0x%X-0x%X)\\n\",\n\t\t\tbase[id], base[id] + STX104_EXTENT);\n\t\treturn -EBUSY;\n\t}\n\n\tstx104_base = devm_ioport_map(dev, base[id], STX104_EXTENT);\n\tif (!stx104_base)\n\t\treturn -ENOMEM;\n\n\taio_ctl_map = devm_regmap_init_mmio(dev, stx104_base, &aio_ctl_regmap_config);\n\tif (IS_ERR(aio_ctl_map))\n\t\treturn dev_err_probe(dev, PTR_ERR(aio_ctl_map),\n\t\t\t\t     \"Unable to initialize aio_ctl register map\\n\");\n\n\taio_data_map = devm_regmap_init_mmio(dev, stx104_base, &aio_data_regmap_config);\n\tif (IS_ERR(aio_data_map))\n\t\treturn dev_err_probe(dev, PTR_ERR(aio_data_map),\n\t\t\t\t     \"Unable to initialize aio_data register map\\n\");\n\n\tdio_map = devm_regmap_init_mmio(dev, stx104_base, &dio_regmap_config);\n\tif (IS_ERR(dio_map))\n\t\treturn dev_err_probe(dev, PTR_ERR(dio_map),\n\t\t\t\t     \"Unable to initialize dio register map\\n\");\n\n\tpriv = iio_priv(indio_dev);\n\tpriv->aio_ctl_map = aio_ctl_map;\n\tpriv->aio_data_map = aio_data_map;\n\n\tindio_dev->info = &stx104_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\terr = regmap_read(aio_ctl_map, STX104_ADC_STATUS, &adc_status);\n\tif (err)\n\t\treturn err;\n\n\tif (u8_get_bits(adc_status, STX104_SD) == STX104_DIFFERENTIAL) {\n\t\tindio_dev->num_channels = ARRAY_SIZE(stx104_channels_diff);\n\t\tindio_dev->channels = stx104_channels_diff;\n\t} else {\n\t\tindio_dev->num_channels = ARRAY_SIZE(stx104_channels_sing);\n\t\tindio_dev->channels = stx104_channels_sing;\n\t}\n\n\tindio_dev->name = dev_name(dev);\n\n\tmutex_init(&priv->lock);\n\n\terr = stx104_init_hw(priv);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_iio_device_register(dev, indio_dev);\n\tif (err)\n\t\treturn err;\n\n\tgpio_config = (struct gpio_regmap_config) {\n\t\t.parent = dev,\n\t\t.regmap = dio_map,\n\t\t.ngpio = STX104_NGPIO,\n\t\t.names = stx104_names,\n\t\t.reg_dat_base = GPIO_REGMAP_ADDR(STX104_DIO_REG),\n\t\t.reg_set_base = GPIO_REGMAP_ADDR(STX104_DIO_REG),\n\t\t.ngpio_per_reg = STX104_NGPIO,\n\t\t.reg_mask_xlate = stx104_reg_mask_xlate,\n\t\t.drvdata = dio_map,\n\t};\n\n\treturn PTR_ERR_OR_ZERO(devm_gpio_regmap_register(dev, &gpio_config));\n}\n\nstatic struct isa_driver stx104_driver = {\n\t.probe = stx104_probe,\n\t.driver = {\n\t\t.name = \"stx104\"\n\t},\n};\n\nmodule_isa_driver(stx104_driver, num_stx104);\n\nMODULE_AUTHOR(\"William Breathitt Gray <vilhelm.gray@gmail.com>\");\nMODULE_DESCRIPTION(\"Apex Embedded Systems STX104 IIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}