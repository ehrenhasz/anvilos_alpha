{
  "module_name": "ad74413r.c",
  "hash_id": "9c3ff696685543c4e4bf7960d353322f46863b6cbb3583c9cfa56b3db303f3e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/addac/ad74413r.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/bitfield.h>\n#include <linux/crc8.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/interrupt.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n\n#include <dt-bindings/iio/addac/adi,ad74413r.h>\n\n#define AD74413R_CRC_POLYNOMIAL\t0x7\nDECLARE_CRC8_TABLE(ad74413r_crc8_table);\n\n#define AD74413R_CHANNEL_MAX\t4\n\n#define AD74413R_FRAME_SIZE\t4\n\nstruct ad74413r_chip_info {\n\tconst char\t*name;\n\tbool\t\thart_support;\n};\n\nstruct ad74413r_channel_config {\n\tu32\t\tfunc;\n\tu32\t\tdrive_strength;\n\tbool\t\tgpo_comparator;\n\tbool\t\tinitialized;\n};\n\nstruct ad74413r_channels {\n\tstruct iio_chan_spec\t*channels;\n\tunsigned int\t\tnum_channels;\n};\n\nstruct ad74413r_state {\n\tstruct ad74413r_channel_config\tchannel_configs[AD74413R_CHANNEL_MAX];\n\tunsigned int\t\t\tgpo_gpio_offsets[AD74413R_CHANNEL_MAX];\n\tunsigned int\t\t\tcomp_gpio_offsets[AD74413R_CHANNEL_MAX];\n\tstruct gpio_chip\t\tgpo_gpiochip;\n\tstruct gpio_chip\t\tcomp_gpiochip;\n\tstruct completion\t\tadc_data_completion;\n\tunsigned int\t\t\tnum_gpo_gpios;\n\tunsigned int\t\t\tnum_comparator_gpios;\n\tu32\t\t\t\tsense_resistor_ohms;\n\n\t \n\tstruct mutex\t\t\tlock;\n\n\tconst struct ad74413r_chip_info\t*chip_info;\n\tstruct spi_device\t\t*spi;\n\tstruct regulator\t\t*refin_reg;\n\tstruct regmap\t\t\t*regmap;\n\tstruct device\t\t\t*dev;\n\tstruct iio_trigger\t\t*trig;\n\tstruct gpio_desc\t\t*reset_gpio;\n\n\tsize_t\t\t\tadc_active_channels;\n\tstruct spi_message\tadc_samples_msg;\n\tstruct spi_transfer\tadc_samples_xfer[AD74413R_CHANNEL_MAX + 1];\n\n\t \n\tstruct {\n\t\tu8 rx_buf[AD74413R_FRAME_SIZE * AD74413R_CHANNEL_MAX];\n\t\ts64 timestamp;\n\t} adc_samples_buf __aligned(IIO_DMA_MINALIGN);\n\n\tu8\tadc_samples_tx_buf[AD74413R_FRAME_SIZE * AD74413R_CHANNEL_MAX];\n\tu8\treg_tx_buf[AD74413R_FRAME_SIZE];\n\tu8\treg_rx_buf[AD74413R_FRAME_SIZE];\n};\n\n#define AD74413R_REG_NOP\t\t0x00\n\n#define AD74413R_REG_CH_FUNC_SETUP_X(x)\t(0x01 + (x))\n#define AD74413R_CH_FUNC_SETUP_MASK\tGENMASK(3, 0)\n\n#define AD74413R_REG_ADC_CONFIG_X(x)\t\t(0x05 + (x))\n#define AD74413R_ADC_CONFIG_RANGE_MASK\t\tGENMASK(7, 5)\n#define AD74413R_ADC_CONFIG_REJECTION_MASK\tGENMASK(4, 3)\n#define AD74413R_ADC_CONFIG_CH_200K_TO_GND\tBIT(2)\n#define AD74413R_ADC_RANGE_10V\t\t\t0b000\n#define AD74413R_ADC_RANGE_2P5V_EXT_POW\t\t0b001\n#define AD74413R_ADC_RANGE_2P5V_INT_POW\t\t0b010\n#define AD74413R_ADC_RANGE_5V_BI_DIR\t\t0b011\n#define AD74413R_ADC_REJECTION_50_60\t\t0b00\n#define AD74413R_ADC_REJECTION_NONE\t\t0b01\n#define AD74413R_ADC_REJECTION_50_60_HART\t0b10\n#define AD74413R_ADC_REJECTION_HART\t\t0b11\n\n#define AD74413R_REG_DIN_CONFIG_X(x)\t(0x09 + (x))\n#define AD74413R_DIN_DEBOUNCE_MASK\tGENMASK(4, 0)\n#define AD74413R_DIN_DEBOUNCE_LEN\tBIT(5)\n#define AD74413R_DIN_SINK_MASK\t\tGENMASK(9, 6)\n\n#define AD74413R_REG_DAC_CODE_X(x)\t(0x16 + (x))\n#define AD74413R_DAC_CODE_MAX\t\tGENMASK(12, 0)\n#define AD74413R_DAC_VOLTAGE_MAX\t11000\n\n#define AD74413R_REG_GPO_PAR_DATA\t\t0x0d\n#define AD74413R_REG_GPO_CONFIG_X(x)\t\t(0x0e + (x))\n#define AD74413R_GPO_CONFIG_DATA_MASK\tBIT(3)\n#define AD74413R_GPO_CONFIG_SELECT_MASK\t\tGENMASK(2, 0)\n#define AD74413R_GPO_CONFIG_100K_PULL_DOWN\t0b000\n#define AD74413R_GPO_CONFIG_LOGIC\t\t0b001\n#define AD74413R_GPO_CONFIG_LOGIC_PARALLEL\t0b010\n#define AD74413R_GPO_CONFIG_COMPARATOR\t\t0b011\n#define AD74413R_GPO_CONFIG_HIGH_IMPEDANCE\t0b100\n\n#define AD74413R_REG_ADC_CONV_CTRL\t0x23\n#define AD74413R_CONV_SEQ_MASK\t\tGENMASK(9, 8)\n#define AD74413R_CONV_SEQ_ON\t\t0b00\n#define AD74413R_CONV_SEQ_SINGLE\t0b01\n#define AD74413R_CONV_SEQ_CONTINUOUS\t0b10\n#define AD74413R_CONV_SEQ_OFF\t\t0b11\n#define AD74413R_CH_EN_MASK(x)\t\tBIT(x)\n\n#define AD74413R_REG_DIN_COMP_OUT\t\t0x25\n\n#define AD74413R_REG_ADC_RESULT_X(x)\t(0x26 + (x))\n#define AD74413R_ADC_RESULT_MAX\t\tGENMASK(15, 0)\n\n#define AD74413R_REG_READ_SELECT\t0x41\n\n#define AD74413R_REG_CMD_KEY\t\t0x44\n#define AD74413R_CMD_KEY_LDAC\t\t0x953a\n#define AD74413R_CMD_KEY_RESET1\t\t0x15fa\n#define AD74413R_CMD_KEY_RESET2\t\t0xaf51\n\nstatic const int ad74413r_adc_sampling_rates[] = {\n\t20, 4800,\n};\n\nstatic const int ad74413r_adc_sampling_rates_hart[] = {\n\t10, 20, 1200, 4800,\n};\n\nstatic int ad74413r_crc(u8 *buf)\n{\n\treturn crc8(ad74413r_crc8_table, buf, 3, 0);\n}\n\nstatic void ad74413r_format_reg_write(u8 reg, u16 val, u8 *buf)\n{\n\tbuf[0] = reg;\n\tput_unaligned_be16(val, &buf[1]);\n\tbuf[3] = ad74413r_crc(buf);\n}\n\nstatic int ad74413r_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct ad74413r_state *st = context;\n\n\tad74413r_format_reg_write(reg, val, st->reg_tx_buf);\n\n\treturn spi_write(st->spi, st->reg_tx_buf, AD74413R_FRAME_SIZE);\n}\n\nstatic int ad74413r_crc_check(struct ad74413r_state *st, u8 *buf)\n{\n\tu8 expected_crc = ad74413r_crc(buf);\n\n\tif (buf[3] != expected_crc) {\n\t\tdev_err(st->dev, \"Bad CRC %02x for %02x%02x%02x\\n\",\n\t\t\tbuf[3], buf[0], buf[1], buf[2]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad74413r_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct ad74413r_state *st = context;\n\tstruct spi_transfer reg_read_xfer[] = {\n\t\t{\n\t\t\t.tx_buf = st->reg_tx_buf,\n\t\t\t.len = AD74413R_FRAME_SIZE,\n\t\t\t.cs_change = 1,\n\t\t},\n\t\t{\n\t\t\t.rx_buf = st->reg_rx_buf,\n\t\t\t.len = AD74413R_FRAME_SIZE,\n\t\t},\n\t};\n\tint ret;\n\n\tad74413r_format_reg_write(AD74413R_REG_READ_SELECT, reg,\n\t\t\t\t  st->reg_tx_buf);\n\n\tret = spi_sync_transfer(st->spi, reg_read_xfer,\n\t\t\t\tARRAY_SIZE(reg_read_xfer));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74413r_crc_check(st, st->reg_rx_buf);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = get_unaligned_be16(&st->reg_rx_buf[1]);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config ad74413r_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.reg_read = ad74413r_reg_read,\n\t.reg_write = ad74413r_reg_write,\n};\n\nstatic int ad74413r_set_gpo_config(struct ad74413r_state *st,\n\t\t\t\t   unsigned int offset, u8 mode)\n{\n\treturn regmap_update_bits(st->regmap, AD74413R_REG_GPO_CONFIG_X(offset),\n\t\t\t\t  AD74413R_GPO_CONFIG_SELECT_MASK, mode);\n}\n\nstatic const unsigned int ad74413r_debounce_map[AD74413R_DIN_DEBOUNCE_LEN] = {\n\t0,     13,    18,    24,    32,    42,    56,    75,\n\t100,   130,   180,   240,   320,   420,   560,   750,\n\t1000,  1300,  1800,  2400,  3200,  4200,  5600,  7500,\n\t10000, 13000, 18000, 24000, 32000, 42000, 56000, 75000,\n};\n\nstatic int ad74413r_set_comp_debounce(struct ad74413r_state *st,\n\t\t\t\t      unsigned int offset,\n\t\t\t\t      unsigned int debounce)\n{\n\tunsigned int val = AD74413R_DIN_DEBOUNCE_LEN - 1;\n\tunsigned int i;\n\n\tfor (i = 0; i < AD74413R_DIN_DEBOUNCE_LEN; i++)\n\t\tif (debounce <= ad74413r_debounce_map[i]) {\n\t\t\tval = i;\n\t\t\tbreak;\n\t\t}\n\n\treturn regmap_update_bits(st->regmap,\n\t\t\t\t  AD74413R_REG_DIN_CONFIG_X(offset),\n\t\t\t\t  AD74413R_DIN_DEBOUNCE_MASK,\n\t\t\t\t  val);\n}\n\nstatic int ad74413r_set_comp_drive_strength(struct ad74413r_state *st,\n\t\t\t\t\t    unsigned int offset,\n\t\t\t\t\t    unsigned int strength)\n{\n\tstrength = min(strength, 1800U);\n\n\treturn regmap_update_bits(st->regmap, AD74413R_REG_DIN_CONFIG_X(offset),\n\t\t\t\t  AD74413R_DIN_SINK_MASK,\n\t\t\t\t  FIELD_PREP(AD74413R_DIN_SINK_MASK, strength / 120));\n}\n\n\nstatic void ad74413r_gpio_set(struct gpio_chip *chip,\n\t\t\t      unsigned int offset, int val)\n{\n\tstruct ad74413r_state *st = gpiochip_get_data(chip);\n\tunsigned int real_offset = st->gpo_gpio_offsets[offset];\n\tint ret;\n\n\tret = ad74413r_set_gpo_config(st, real_offset,\n\t\t\t\t      AD74413R_GPO_CONFIG_LOGIC);\n\tif (ret)\n\t\treturn;\n\n\tregmap_update_bits(st->regmap, AD74413R_REG_GPO_CONFIG_X(real_offset),\n\t\t\t   AD74413R_GPO_CONFIG_DATA_MASK,\n\t\t\t   val ? AD74413R_GPO_CONFIG_DATA_MASK : 0);\n}\n\nstatic void ad74413r_gpio_set_multiple(struct gpio_chip *chip,\n\t\t\t\t       unsigned long *mask,\n\t\t\t\t       unsigned long *bits)\n{\n\tstruct ad74413r_state *st = gpiochip_get_data(chip);\n\tunsigned long real_mask = 0;\n\tunsigned long real_bits = 0;\n\tunsigned int offset;\n\tint ret;\n\n\tfor_each_set_bit(offset, mask, chip->ngpio) {\n\t\tunsigned int real_offset = st->gpo_gpio_offsets[offset];\n\n\t\tret = ad74413r_set_gpo_config(st, real_offset,\n\t\t\tAD74413R_GPO_CONFIG_LOGIC_PARALLEL);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\treal_mask |= BIT(real_offset);\n\t\tif (*bits & offset)\n\t\t\treal_bits |= BIT(real_offset);\n\t}\n\n\tregmap_update_bits(st->regmap, AD74413R_REG_GPO_PAR_DATA,\n\t\t\t   real_mask, real_bits);\n}\n\nstatic int ad74413r_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct ad74413r_state *st = gpiochip_get_data(chip);\n\tunsigned int real_offset = st->comp_gpio_offsets[offset];\n\tunsigned int status;\n\tint ret;\n\n\tret = regmap_read(st->regmap, AD74413R_REG_DIN_COMP_OUT, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tstatus &= BIT(real_offset);\n\n\treturn status ? 1 : 0;\n}\n\nstatic int ad74413r_gpio_get_multiple(struct gpio_chip *chip,\n\t\t\t\t      unsigned long *mask,\n\t\t\t\t      unsigned long *bits)\n{\n\tstruct ad74413r_state *st = gpiochip_get_data(chip);\n\tunsigned int offset;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(st->regmap, AD74413R_REG_DIN_COMP_OUT, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_set_bit(offset, mask, chip->ngpio) {\n\t\tunsigned int real_offset = st->comp_gpio_offsets[offset];\n\n\t\t__assign_bit(offset, bits, val & BIT(real_offset));\n\t}\n\n\treturn ret;\n}\n\nstatic int ad74413r_gpio_get_gpo_direction(struct gpio_chip *chip,\n\t\t\t\t\t   unsigned int offset)\n{\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int ad74413r_gpio_get_comp_direction(struct gpio_chip *chip,\n\t\t\t\t\t    unsigned int offset)\n{\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int ad74413r_gpio_set_gpo_config(struct gpio_chip *chip,\n\t\t\t\t\tunsigned int offset,\n\t\t\t\t\tunsigned long config)\n{\n\tstruct ad74413r_state *st = gpiochip_get_data(chip);\n\tunsigned int real_offset = st->gpo_gpio_offsets[offset];\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\treturn ad74413r_set_gpo_config(st, real_offset,\n\t\t\tAD74413R_GPO_CONFIG_100K_PULL_DOWN);\n\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\treturn ad74413r_set_gpo_config(st, real_offset,\n\t\t\tAD74413R_GPO_CONFIG_HIGH_IMPEDANCE);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic int ad74413r_gpio_set_comp_config(struct gpio_chip *chip,\n\t\t\t\t\t unsigned int offset,\n\t\t\t\t\t unsigned long config)\n{\n\tstruct ad74413r_state *st = gpiochip_get_data(chip);\n\tunsigned int real_offset = st->comp_gpio_offsets[offset];\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\treturn ad74413r_set_comp_debounce(st, real_offset,\n\t\t\tpinconf_to_config_argument(config));\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic int ad74413r_reset(struct ad74413r_state *st)\n{\n\tint ret;\n\n\tif (st->reset_gpio) {\n\t\tgpiod_set_value_cansleep(st->reset_gpio, 1);\n\t\tfsleep(50);\n\t\tgpiod_set_value_cansleep(st->reset_gpio, 0);\n\t\treturn 0;\n\t}\n\n\tret = regmap_write(st->regmap, AD74413R_REG_CMD_KEY,\n\t\t\t   AD74413R_CMD_KEY_RESET1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(st->regmap, AD74413R_REG_CMD_KEY,\n\t\t\t    AD74413R_CMD_KEY_RESET2);\n}\n\nstatic int ad74413r_set_channel_dac_code(struct ad74413r_state *st,\n\t\t\t\t\t unsigned int channel, int dac_code)\n{\n\tstruct reg_sequence reg_seq[2] = {\n\t\t{ AD74413R_REG_DAC_CODE_X(channel), dac_code },\n\t\t{ AD74413R_REG_CMD_KEY, AD74413R_CMD_KEY_LDAC },\n\t};\n\n\treturn regmap_multi_reg_write(st->regmap, reg_seq, 2);\n}\n\nstatic int ad74413r_set_channel_function(struct ad74413r_state *st,\n\t\t\t\t\t unsigned int channel, u8 func)\n{\n\tint ret;\n\n\tret = regmap_update_bits(st->regmap,\n\t\t\t\t  AD74413R_REG_CH_FUNC_SETUP_X(channel),\n\t\t\t\t  AD74413R_CH_FUNC_SETUP_MASK, func);\n\tif (ret)\n\t\treturn ret;\n\n\tif (func == CH_FUNC_CURRENT_INPUT_LOOP_POWER)\n\t\tret = regmap_set_bits(st->regmap,\n\t\t\t\t      AD74413R_REG_ADC_CONFIG_X(channel),\n\t\t\t\t      AD74413R_ADC_CONFIG_CH_200K_TO_GND);\n\n\treturn ret;\n}\n\nstatic int ad74413r_set_adc_conv_seq(struct ad74413r_state *st,\n\t\t\t\t     unsigned int status)\n{\n\tint ret;\n\n\t \n\tret = regmap_write_bits(st->regmap, AD74413R_REG_ADC_CONV_CTRL,\n\t\t\t\tAD74413R_CONV_SEQ_MASK,\n\t\t\t\tFIELD_PREP(AD74413R_CONV_SEQ_MASK, status));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(100, 120);\n\n\treturn 0;\n}\n\nstatic int ad74413r_set_adc_channel_enable(struct ad74413r_state *st,\n\t\t\t\t\t   unsigned int channel,\n\t\t\t\t\t   bool status)\n{\n\treturn regmap_update_bits(st->regmap, AD74413R_REG_ADC_CONV_CTRL,\n\t\t\t\t  AD74413R_CH_EN_MASK(channel),\n\t\t\t\t  status ? AD74413R_CH_EN_MASK(channel) : 0);\n}\n\nstatic int ad74413r_get_adc_range(struct ad74413r_state *st,\n\t\t\t\t  unsigned int channel,\n\t\t\t\t  unsigned int *val)\n{\n\tint ret;\n\n\tret = regmap_read(st->regmap, AD74413R_REG_ADC_CONFIG_X(channel), val);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = FIELD_GET(AD74413R_ADC_CONFIG_RANGE_MASK, *val);\n\n\treturn 0;\n}\n\nstatic int ad74413r_get_adc_rejection(struct ad74413r_state *st,\n\t\t\t\t      unsigned int channel,\n\t\t\t\t      unsigned int *val)\n{\n\tint ret;\n\n\tret = regmap_read(st->regmap, AD74413R_REG_ADC_CONFIG_X(channel), val);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = FIELD_GET(AD74413R_ADC_CONFIG_REJECTION_MASK, *val);\n\n\treturn 0;\n}\n\nstatic int ad74413r_set_adc_rejection(struct ad74413r_state *st,\n\t\t\t\t      unsigned int channel,\n\t\t\t\t      unsigned int val)\n{\n\treturn regmap_update_bits(st->regmap,\n\t\t\t\t  AD74413R_REG_ADC_CONFIG_X(channel),\n\t\t\t\t  AD74413R_ADC_CONFIG_REJECTION_MASK,\n\t\t\t\t  FIELD_PREP(AD74413R_ADC_CONFIG_REJECTION_MASK,\n\t\t\t\t\t     val));\n}\n\nstatic int ad74413r_rejection_to_rate(struct ad74413r_state *st,\n\t\t\t\t      unsigned int rej, int *val)\n{\n\tswitch (rej) {\n\tcase AD74413R_ADC_REJECTION_50_60:\n\t\t*val = 20;\n\t\treturn 0;\n\tcase AD74413R_ADC_REJECTION_NONE:\n\t\t*val = 4800;\n\t\treturn 0;\n\tcase AD74413R_ADC_REJECTION_50_60_HART:\n\t\t*val = 10;\n\t\treturn 0;\n\tcase AD74413R_ADC_REJECTION_HART:\n\t\t*val = 1200;\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(st->dev, \"ADC rejection invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad74413r_rate_to_rejection(struct ad74413r_state *st,\n\t\t\t\t      int rate, unsigned int *val)\n{\n\tswitch (rate) {\n\tcase 20:\n\t\t*val = AD74413R_ADC_REJECTION_50_60;\n\t\treturn 0;\n\tcase 4800:\n\t\t*val = AD74413R_ADC_REJECTION_NONE;\n\t\treturn 0;\n\tcase 10:\n\t\t*val = AD74413R_ADC_REJECTION_50_60_HART;\n\t\treturn 0;\n\tcase 1200:\n\t\t*val = AD74413R_ADC_REJECTION_HART;\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(st->dev, \"ADC rate invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad74413r_range_to_voltage_range(struct ad74413r_state *st,\n\t\t\t\t\t   unsigned int range, int *val)\n{\n\tswitch (range) {\n\tcase AD74413R_ADC_RANGE_10V:\n\t\t*val = 10000;\n\t\treturn 0;\n\tcase AD74413R_ADC_RANGE_2P5V_EXT_POW:\n\tcase AD74413R_ADC_RANGE_2P5V_INT_POW:\n\t\t*val = 2500;\n\t\treturn 0;\n\tcase AD74413R_ADC_RANGE_5V_BI_DIR:\n\t\t*val = 5000;\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(st->dev, \"ADC range invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad74413r_range_to_voltage_offset(struct ad74413r_state *st,\n\t\t\t\t\t    unsigned int range, int *val)\n{\n\tswitch (range) {\n\tcase AD74413R_ADC_RANGE_10V:\n\tcase AD74413R_ADC_RANGE_2P5V_EXT_POW:\n\t\t*val = 0;\n\t\treturn 0;\n\tcase AD74413R_ADC_RANGE_2P5V_INT_POW:\n\tcase AD74413R_ADC_RANGE_5V_BI_DIR:\n\t\t*val = -2500;\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(st->dev, \"ADC range invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad74413r_range_to_voltage_offset_raw(struct ad74413r_state *st,\n\t\t\t\t\t\tunsigned int range, int *val)\n{\n\tswitch (range) {\n\tcase AD74413R_ADC_RANGE_10V:\n\tcase AD74413R_ADC_RANGE_2P5V_EXT_POW:\n\t\t*val = 0;\n\t\treturn 0;\n\tcase AD74413R_ADC_RANGE_2P5V_INT_POW:\n\t\t*val = -((int)AD74413R_ADC_RESULT_MAX);\n\t\treturn 0;\n\tcase AD74413R_ADC_RANGE_5V_BI_DIR:\n\t\t*val = -((int)AD74413R_ADC_RESULT_MAX / 2);\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(st->dev, \"ADC range invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad74413r_get_output_voltage_scale(struct ad74413r_state *st,\n\t\t\t\t\t     int *val, int *val2)\n{\n\t*val = AD74413R_DAC_VOLTAGE_MAX;\n\t*val2 = AD74413R_DAC_CODE_MAX;\n\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int ad74413r_get_output_current_scale(struct ad74413r_state *st,\n\t\t\t\t\t     int *val, int *val2)\n{\n\t*val = regulator_get_voltage(st->refin_reg);\n\t*val2 = st->sense_resistor_ohms * AD74413R_DAC_CODE_MAX * 1000;\n\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int ad74413r_get_input_voltage_scale(struct ad74413r_state *st,\n\t\t\t\t\t    unsigned int channel,\n\t\t\t\t\t    int *val, int *val2)\n{\n\tunsigned int range;\n\tint ret;\n\n\tret = ad74413r_get_adc_range(st, channel, &range);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74413r_range_to_voltage_range(st, range, val);\n\tif (ret)\n\t\treturn ret;\n\n\t*val2 = AD74413R_ADC_RESULT_MAX;\n\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int ad74413r_get_input_voltage_offset(struct ad74413r_state *st,\n\t\t\t\t\t     unsigned int channel, int *val)\n{\n\tunsigned int range;\n\tint ret;\n\n\tret = ad74413r_get_adc_range(st, channel, &range);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74413r_range_to_voltage_offset_raw(st, range, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int ad74413r_get_input_current_scale(struct ad74413r_state *st,\n\t\t\t\t\t    unsigned int channel, int *val,\n\t\t\t\t\t    int *val2)\n{\n\tunsigned int range;\n\tint ret;\n\n\tret = ad74413r_get_adc_range(st, channel, &range);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74413r_range_to_voltage_range(st, range, val);\n\tif (ret)\n\t\treturn ret;\n\n\t*val2 = AD74413R_ADC_RESULT_MAX * st->sense_resistor_ohms;\n\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int ad74413_get_input_current_offset(struct ad74413r_state *st,\n\t\t\t\t\t    unsigned int channel, int *val)\n{\n\tunsigned int range;\n\tint voltage_range;\n\tint voltage_offset;\n\tint ret;\n\n\tret = ad74413r_get_adc_range(st, channel, &range);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74413r_range_to_voltage_range(st, range, &voltage_range);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74413r_range_to_voltage_offset(st, range, &voltage_offset);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = voltage_offset * (int)AD74413R_ADC_RESULT_MAX / voltage_range;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int ad74413r_get_adc_rate(struct ad74413r_state *st,\n\t\t\t\t unsigned int channel, int *val)\n{\n\tunsigned int rejection;\n\tint ret;\n\n\tret = ad74413r_get_adc_rejection(st, channel, &rejection);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74413r_rejection_to_rate(st, rejection, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int ad74413r_set_adc_rate(struct ad74413r_state *st,\n\t\t\t\t unsigned int channel, int val)\n{\n\tunsigned int rejection;\n\tint ret;\n\n\tret = ad74413r_rate_to_rejection(st, val, &rejection);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ad74413r_set_adc_rejection(st, channel, rejection);\n}\n\nstatic irqreturn_t ad74413r_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ad74413r_state *st = iio_priv(indio_dev);\n\tu8 *rx_buf = st->adc_samples_buf.rx_buf;\n\tunsigned int i;\n\tint ret;\n\n\tret = spi_sync(st->spi, &st->adc_samples_msg);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < st->adc_active_channels; i++)\n\t\tad74413r_crc_check(st, &rx_buf[i * AD74413R_FRAME_SIZE]);\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &st->adc_samples_buf,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\nout:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ad74413r_adc_data_interrupt(int irq, void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct ad74413r_state *st = iio_priv(indio_dev);\n\n\tif (iio_buffer_enabled(indio_dev))\n\t\tiio_trigger_poll(st->trig);\n\telse\n\t\tcomplete(&st->adc_data_completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int _ad74413r_get_single_adc_result(struct ad74413r_state *st,\n\t\t\t\t\t   unsigned int channel, int *val)\n{\n\tunsigned int uval;\n\tint ret;\n\n\treinit_completion(&st->adc_data_completion);\n\n\tret = ad74413r_set_adc_channel_enable(st, channel, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74413r_set_adc_conv_seq(st, AD74413R_CONV_SEQ_SINGLE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_for_completion_timeout(&st->adc_data_completion,\n\t\t\t\t\t  msecs_to_jiffies(1000));\n\tif (!ret) {\n\t\tret = -ETIMEDOUT;\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(st->regmap, AD74413R_REG_ADC_RESULT_X(channel),\n\t\t\t  &uval);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74413r_set_adc_conv_seq(st, AD74413R_CONV_SEQ_OFF);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74413r_set_adc_channel_enable(st, channel, false);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = uval;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int ad74413r_get_single_adc_result(struct iio_dev *indio_dev,\n\t\t\t\t\t  unsigned int channel, int *val)\n{\n\tstruct ad74413r_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\tret = _ad74413r_get_single_adc_result(st, channel, val);\n\tmutex_unlock(&st->lock);\n\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret;\n}\n\nstatic void ad74413r_adc_to_resistance_result(int adc_result, int *val)\n{\n\tif (adc_result == AD74413R_ADC_RESULT_MAX)\n\t\tadc_result = AD74413R_ADC_RESULT_MAX - 1;\n\n\t*val = DIV_ROUND_CLOSEST(adc_result * 2100,\n\t\t\t\t AD74413R_ADC_RESULT_MAX - adc_result);\n}\n\nstatic int ad74413r_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t     const unsigned long *active_scan_mask)\n{\n\tstruct ad74413r_state *st = iio_priv(indio_dev);\n\tstruct spi_transfer *xfer = st->adc_samples_xfer;\n\tu8 *rx_buf = st->adc_samples_buf.rx_buf;\n\tu8 *tx_buf = st->adc_samples_tx_buf;\n\tunsigned int channel;\n\tint ret = -EINVAL;\n\n\tmutex_lock(&st->lock);\n\n\tspi_message_init(&st->adc_samples_msg);\n\tst->adc_active_channels = 0;\n\n\tfor_each_clear_bit(channel, active_scan_mask, AD74413R_CHANNEL_MAX) {\n\t\tret = ad74413r_set_adc_channel_enable(st, channel, false);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (*active_scan_mask == 0)\n\t\tgoto out;\n\n\t \n\n\tfor_each_set_bit(channel, active_scan_mask, AD74413R_CHANNEL_MAX) {\n\t\tret = ad74413r_set_adc_channel_enable(st, channel, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tst->adc_active_channels++;\n\n\t\tif (xfer == st->adc_samples_xfer)\n\t\t\txfer->rx_buf = NULL;\n\t\telse\n\t\t\txfer->rx_buf = rx_buf;\n\n\t\txfer->tx_buf = tx_buf;\n\t\txfer->len = AD74413R_FRAME_SIZE;\n\t\txfer->cs_change = 1;\n\n\t\tad74413r_format_reg_write(AD74413R_REG_READ_SELECT,\n\t\t\t\t\t  AD74413R_REG_ADC_RESULT_X(channel),\n\t\t\t\t\t  tx_buf);\n\n\t\tspi_message_add_tail(xfer, &st->adc_samples_msg);\n\n\t\ttx_buf += AD74413R_FRAME_SIZE;\n\t\tif (xfer != st->adc_samples_xfer)\n\t\t\trx_buf += AD74413R_FRAME_SIZE;\n\t\txfer++;\n\t}\n\n\txfer->rx_buf = rx_buf;\n\txfer->tx_buf = NULL;\n\txfer->len = AD74413R_FRAME_SIZE;\n\txfer->cs_change = 0;\n\n\tspi_message_add_tail(xfer, &st->adc_samples_msg);\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad74413r_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct ad74413r_state *st = iio_priv(indio_dev);\n\n\treturn ad74413r_set_adc_conv_seq(st, AD74413R_CONV_SEQ_CONTINUOUS);\n}\n\nstatic int ad74413r_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct ad74413r_state *st = iio_priv(indio_dev);\n\n\treturn ad74413r_set_adc_conv_seq(st, AD74413R_CONV_SEQ_OFF);\n}\n\nstatic int ad74413r_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long info)\n{\n\tstruct ad74413r_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tif (chan->output)\n\t\t\t\treturn ad74413r_get_output_voltage_scale(st,\n\t\t\t\t\tval, val2);\n\t\t\telse\n\t\t\t\treturn ad74413r_get_input_voltage_scale(st,\n\t\t\t\t\tchan->channel, val, val2);\n\t\tcase IIO_CURRENT:\n\t\t\tif (chan->output)\n\t\t\t\treturn ad74413r_get_output_current_scale(st,\n\t\t\t\t\tval, val2);\n\t\t\telse\n\t\t\t\treturn ad74413r_get_input_current_scale(st,\n\t\t\t\t\tchan->channel, val, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\treturn ad74413r_get_input_voltage_offset(st,\n\t\t\t\tchan->channel, val);\n\t\tcase IIO_CURRENT:\n\t\t\treturn ad74413_get_input_current_offset(st,\n\t\t\t\tchan->channel, val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->output)\n\t\t\treturn -EINVAL;\n\n\t\treturn ad74413r_get_single_adc_result(indio_dev, chan->channel,\n\t\t\t\t\t\t      val);\n\tcase IIO_CHAN_INFO_PROCESSED: {\n\t\tint ret;\n\n\t\tret = ad74413r_get_single_adc_result(indio_dev, chan->channel,\n\t\t\t\t\t\t     val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tad74413r_adc_to_resistance_result(*val, val);\n\n\t\treturn ret;\n\t}\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn ad74413r_get_adc_rate(st, chan->channel, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad74413r_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long info)\n{\n\tstruct ad74413r_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (!chan->output)\n\t\t\treturn -EINVAL;\n\n\t\tif (val < 0 || val > AD74413R_DAC_CODE_MAX) {\n\t\t\tdev_err(st->dev, \"Invalid DAC code\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn ad74413r_set_channel_dac_code(st, chan->channel, val);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn ad74413r_set_adc_rate(st, chan->channel, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad74413r_read_avail(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length,\n\t\t\t       long info)\n{\n\tstruct ad74413r_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (st->chip_info->hart_support) {\n\t\t\t*vals = ad74413r_adc_sampling_rates_hart;\n\t\t\t*length = ARRAY_SIZE(ad74413r_adc_sampling_rates_hart);\n\t\t} else {\n\t\t\t*vals = ad74413r_adc_sampling_rates;\n\t\t\t*length = ARRAY_SIZE(ad74413r_adc_sampling_rates);\n\t\t}\n\t\t*type = IIO_VAL_INT;\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_buffer_setup_ops ad74413r_buffer_ops = {\n\t.postenable = &ad74413r_buffer_postenable,\n\t.predisable = &ad74413r_buffer_predisable,\n};\n\nstatic const struct iio_trigger_ops ad74413r_trigger_ops = {\n\t.validate_device = iio_trigger_validate_own_device,\n};\n\nstatic const struct iio_info ad74413r_info = {\n\t.read_raw = &ad74413r_read_raw,\n\t.write_raw = &ad74413r_write_raw,\n\t.read_avail = &ad74413r_read_avail,\n\t.update_scan_mode = &ad74413r_update_scan_mode,\n};\n\n#define AD74413R_DAC_CHANNEL(_type, extra_mask_separate)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = (_type),\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.output = 1,\t\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)\t\t\\\n\t\t\t\t      | (extra_mask_separate),\t\t\\\n\t}\n\n#define AD74413R_ADC_CHANNEL(_type, extra_mask_separate)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = (_type),\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.output = 0,\t\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)\t\t\\\n\t\t\t\t      | BIT(IIO_CHAN_INFO_SAMP_FREQ)\t\\\n\t\t\t\t      | (extra_mask_separate),\t\t\\\n\t\t.info_mask_separate_available =\t\t\t\t\\\n\t\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t\t.storagebits = 32,\t\t\t\t\\\n\t\t\t.shift = 8,\t\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\n#define AD74413R_ADC_VOLTAGE_CHANNEL\t\t\t\t\t\\\n\tAD74413R_ADC_CHANNEL(IIO_VOLTAGE, BIT(IIO_CHAN_INFO_SCALE)\t\\\n\t\t\t     | BIT(IIO_CHAN_INFO_OFFSET))\n\n#define AD74413R_ADC_CURRENT_CHANNEL\t\t\t\t\t\\\n\tAD74413R_ADC_CHANNEL(IIO_CURRENT,  BIT(IIO_CHAN_INFO_SCALE)\t\\\n\t\t\t     | BIT(IIO_CHAN_INFO_OFFSET))\n\nstatic struct iio_chan_spec ad74413r_voltage_output_channels[] = {\n\tAD74413R_DAC_CHANNEL(IIO_VOLTAGE, BIT(IIO_CHAN_INFO_SCALE)),\n\tAD74413R_ADC_CURRENT_CHANNEL,\n};\n\nstatic struct iio_chan_spec ad74413r_current_output_channels[] = {\n\tAD74413R_DAC_CHANNEL(IIO_CURRENT, BIT(IIO_CHAN_INFO_SCALE)),\n\tAD74413R_ADC_VOLTAGE_CHANNEL,\n};\n\nstatic struct iio_chan_spec ad74413r_voltage_input_channels[] = {\n\tAD74413R_ADC_VOLTAGE_CHANNEL,\n};\n\nstatic struct iio_chan_spec ad74413r_current_input_channels[] = {\n\tAD74413R_ADC_CURRENT_CHANNEL,\n};\n\nstatic struct iio_chan_spec ad74413r_current_input_loop_channels[] = {\n\tAD74413R_DAC_CHANNEL(IIO_CURRENT, BIT(IIO_CHAN_INFO_SCALE)),\n\tAD74413R_ADC_CURRENT_CHANNEL,\n};\n\nstatic struct iio_chan_spec ad74413r_resistance_input_channels[] = {\n\tAD74413R_ADC_CHANNEL(IIO_RESISTANCE, BIT(IIO_CHAN_INFO_PROCESSED)),\n};\n\nstatic struct iio_chan_spec ad74413r_digital_input_channels[] = {\n\tAD74413R_ADC_VOLTAGE_CHANNEL,\n};\n\n#define _AD74413R_CHANNELS(_channels)\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.channels = _channels,\t\t\t\\\n\t\t.num_channels = ARRAY_SIZE(_channels),\t\\\n\t}\n\n#define AD74413R_CHANNELS(name) \\\n\t_AD74413R_CHANNELS(ad74413r_ ## name ## _channels)\n\nstatic const struct ad74413r_channels ad74413r_channels_map[] = {\n\t[CH_FUNC_HIGH_IMPEDANCE] = AD74413R_CHANNELS(voltage_input),\n\t[CH_FUNC_VOLTAGE_OUTPUT] = AD74413R_CHANNELS(voltage_output),\n\t[CH_FUNC_CURRENT_OUTPUT] = AD74413R_CHANNELS(current_output),\n\t[CH_FUNC_VOLTAGE_INPUT] = AD74413R_CHANNELS(voltage_input),\n\t[CH_FUNC_CURRENT_INPUT_EXT_POWER] = AD74413R_CHANNELS(current_input),\n\t[CH_FUNC_CURRENT_INPUT_LOOP_POWER] = AD74413R_CHANNELS(current_input_loop),\n\t[CH_FUNC_RESISTANCE_INPUT] = AD74413R_CHANNELS(resistance_input),\n\t[CH_FUNC_DIGITAL_INPUT_LOGIC] = AD74413R_CHANNELS(digital_input),\n\t[CH_FUNC_DIGITAL_INPUT_LOOP_POWER] = AD74413R_CHANNELS(digital_input),\n\t[CH_FUNC_CURRENT_INPUT_EXT_POWER_HART] = AD74413R_CHANNELS(current_input),\n\t[CH_FUNC_CURRENT_INPUT_LOOP_POWER_HART] = AD74413R_CHANNELS(current_input),\n};\n\nstatic int ad74413r_parse_channel_config(struct iio_dev *indio_dev,\n\t\t\t\t\t struct fwnode_handle *channel_node)\n{\n\tstruct ad74413r_state *st = iio_priv(indio_dev);\n\tstruct ad74413r_channel_config *config;\n\tu32 index;\n\tint ret;\n\n\tret = fwnode_property_read_u32(channel_node, \"reg\", &index);\n\tif (ret) {\n\t\tdev_err(st->dev, \"Failed to read channel reg: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (index >= AD74413R_CHANNEL_MAX) {\n\t\tdev_err(st->dev, \"Channel index %u is too large\\n\", index);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig = &st->channel_configs[index];\n\tif (config->initialized) {\n\t\tdev_err(st->dev, \"Channel %u already initialized\\n\", index);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig->func = CH_FUNC_HIGH_IMPEDANCE;\n\tfwnode_property_read_u32(channel_node, \"adi,ch-func\", &config->func);\n\n\tif (config->func < CH_FUNC_MIN || config->func > CH_FUNC_MAX) {\n\t\tdev_err(st->dev, \"Invalid channel function %u\\n\", config->func);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!st->chip_info->hart_support &&\n\t    (config->func == CH_FUNC_CURRENT_INPUT_EXT_POWER_HART ||\n\t     config->func == CH_FUNC_CURRENT_INPUT_LOOP_POWER_HART)) {\n\t\tdev_err(st->dev, \"Unsupported HART function %u\\n\", config->func);\n\t\treturn -EINVAL;\n\t}\n\n\tif (config->func == CH_FUNC_DIGITAL_INPUT_LOGIC ||\n\t    config->func == CH_FUNC_DIGITAL_INPUT_LOOP_POWER)\n\t\tst->num_comparator_gpios++;\n\n\tconfig->gpo_comparator = fwnode_property_read_bool(channel_node,\n\t\t\"adi,gpo-comparator\");\n\n\tfwnode_property_read_u32(channel_node, \"drive-strength-microamp\",\n\t\t\t\t &config->drive_strength);\n\n\tif (!config->gpo_comparator)\n\t\tst->num_gpo_gpios++;\n\n\tindio_dev->num_channels += ad74413r_channels_map[config->func].num_channels;\n\n\tconfig->initialized = true;\n\n\treturn 0;\n}\n\nstatic int ad74413r_parse_channel_configs(struct iio_dev *indio_dev)\n{\n\tstruct ad74413r_state *st = iio_priv(indio_dev);\n\tstruct fwnode_handle *channel_node = NULL;\n\tint ret;\n\n\tfwnode_for_each_available_child_node(dev_fwnode(st->dev), channel_node) {\n\t\tret = ad74413r_parse_channel_config(indio_dev, channel_node);\n\t\tif (ret)\n\t\t\tgoto put_channel_node;\n\t}\n\n\treturn 0;\n\nput_channel_node:\n\tfwnode_handle_put(channel_node);\n\n\treturn ret;\n}\n\nstatic int ad74413r_setup_channels(struct iio_dev *indio_dev)\n{\n\tstruct ad74413r_state *st = iio_priv(indio_dev);\n\tstruct ad74413r_channel_config *config;\n\tstruct iio_chan_spec *channels, *chans;\n\tunsigned int i, num_chans, chan_i;\n\tint ret;\n\n\tchannels = devm_kcalloc(st->dev, sizeof(*channels),\n\t\t\t\tindio_dev->num_channels, GFP_KERNEL);\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\tindio_dev->channels = channels;\n\n\tfor (i = 0; i < AD74413R_CHANNEL_MAX; i++) {\n\t\tconfig = &st->channel_configs[i];\n\t\tchans = ad74413r_channels_map[config->func].channels;\n\t\tnum_chans = ad74413r_channels_map[config->func].num_channels;\n\n\t\tmemcpy(channels, chans, num_chans * sizeof(*chans));\n\n\t\tfor (chan_i = 0; chan_i < num_chans; chan_i++) {\n\t\t\tstruct iio_chan_spec *chan = &channels[chan_i];\n\n\t\t\tchan->channel = i;\n\t\t\tif (chan->output)\n\t\t\t\tchan->scan_index = -1;\n\t\t\telse\n\t\t\t\tchan->scan_index = i;\n\t\t}\n\n\t\tret = ad74413r_set_channel_function(st, i, config->func);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tchannels += num_chans;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad74413r_setup_gpios(struct ad74413r_state *st)\n{\n\tstruct ad74413r_channel_config *config;\n\tunsigned int comp_gpio_i = 0;\n\tunsigned int gpo_gpio_i = 0;\n\tunsigned int i;\n\tu8 gpo_config;\n\tu32 strength;\n\tint ret;\n\n\tfor (i = 0; i < AD74413R_CHANNEL_MAX; i++) {\n\t\tconfig = &st->channel_configs[i];\n\n\t\tif (config->gpo_comparator) {\n\t\t\tgpo_config = AD74413R_GPO_CONFIG_COMPARATOR;\n\t\t} else {\n\t\t\tgpo_config = AD74413R_GPO_CONFIG_LOGIC;\n\t\t\tst->gpo_gpio_offsets[gpo_gpio_i++] = i;\n\t\t}\n\n\t\tif (config->func == CH_FUNC_DIGITAL_INPUT_LOGIC ||\n\t\t    config->func == CH_FUNC_DIGITAL_INPUT_LOOP_POWER) {\n\t\t\tst->comp_gpio_offsets[comp_gpio_i++] = i;\n\n\t\t\tstrength = config->drive_strength;\n\t\t\tret = ad74413r_set_comp_drive_strength(st, i, strength);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = ad74413r_set_gpo_config(st, i, gpo_config);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ad74413r_regulator_disable(void *regulator)\n{\n\tregulator_disable(regulator);\n}\n\nstatic int ad74413r_probe(struct spi_device *spi)\n{\n\tstruct ad74413r_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->spi = spi;\n\tst->dev = &spi->dev;\n\tst->chip_info = device_get_match_data(&spi->dev);\n\tif (!st->chip_info) {\n\t\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\n\t\tif (id)\n\t\t\tst->chip_info =\n\t\t\t\t(struct ad74413r_chip_info *)id->driver_data;\n\t\tif (!st->chip_info)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&st->lock);\n\tinit_completion(&st->adc_data_completion);\n\n\tst->regmap = devm_regmap_init(st->dev, NULL, st,\n\t\t\t\t      &ad74413r_regmap_config);\n\tif (IS_ERR(st->regmap))\n\t\treturn PTR_ERR(st->regmap);\n\n\tst->reset_gpio = devm_gpiod_get_optional(st->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(st->reset_gpio))\n\t\treturn PTR_ERR(st->reset_gpio);\n\n\tst->refin_reg = devm_regulator_get(st->dev, \"refin\");\n\tif (IS_ERR(st->refin_reg))\n\t\treturn dev_err_probe(st->dev, PTR_ERR(st->refin_reg),\n\t\t\t\t     \"Failed to get refin regulator\\n\");\n\n\tret = regulator_enable(st->refin_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(st->dev, ad74413r_regulator_disable,\n\t\t\t\t       st->refin_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tst->sense_resistor_ohms = 100000000;\n\tdevice_property_read_u32(st->dev, \"shunt-resistor-micro-ohms\",\n\t\t\t\t &st->sense_resistor_ohms);\n\tst->sense_resistor_ohms /= 1000000;\n\n\tst->trig = devm_iio_trigger_alloc(st->dev, \"%s-dev%d\",\n\t\t\t\t\t  st->chip_info->name, iio_device_id(indio_dev));\n\tif (!st->trig)\n\t\treturn -ENOMEM;\n\n\tst->trig->ops = &ad74413r_trigger_ops;\n\tiio_trigger_set_drvdata(st->trig, st);\n\n\tret = devm_iio_trigger_register(st->dev, st->trig);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->name = st->chip_info->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &ad74413r_info;\n\tindio_dev->trig = iio_trigger_get(st->trig);\n\n\tret = ad74413r_reset(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74413r_parse_channel_configs(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74413r_setup_channels(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74413r_setup_gpios(st);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->num_gpo_gpios) {\n\t\tst->gpo_gpiochip.owner = THIS_MODULE;\n\t\tst->gpo_gpiochip.label = st->chip_info->name;\n\t\tst->gpo_gpiochip.base = -1;\n\t\tst->gpo_gpiochip.ngpio = st->num_gpo_gpios;\n\t\tst->gpo_gpiochip.parent = st->dev;\n\t\tst->gpo_gpiochip.can_sleep = true;\n\t\tst->gpo_gpiochip.set = ad74413r_gpio_set;\n\t\tst->gpo_gpiochip.set_multiple = ad74413r_gpio_set_multiple;\n\t\tst->gpo_gpiochip.set_config = ad74413r_gpio_set_gpo_config;\n\t\tst->gpo_gpiochip.get_direction =\n\t\t\tad74413r_gpio_get_gpo_direction;\n\n\t\tret = devm_gpiochip_add_data(st->dev, &st->gpo_gpiochip, st);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (st->num_comparator_gpios) {\n\t\tst->comp_gpiochip.owner = THIS_MODULE;\n\t\tst->comp_gpiochip.label = st->chip_info->name;\n\t\tst->comp_gpiochip.base = -1;\n\t\tst->comp_gpiochip.ngpio = st->num_comparator_gpios;\n\t\tst->comp_gpiochip.parent = st->dev;\n\t\tst->comp_gpiochip.can_sleep = true;\n\t\tst->comp_gpiochip.get = ad74413r_gpio_get;\n\t\tst->comp_gpiochip.get_multiple = ad74413r_gpio_get_multiple;\n\t\tst->comp_gpiochip.set_config = ad74413r_gpio_set_comp_config;\n\t\tst->comp_gpiochip.get_direction =\n\t\t\tad74413r_gpio_get_comp_direction;\n\n\t\tret = devm_gpiochip_add_data(st->dev, &st->comp_gpiochip, st);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ad74413r_set_adc_conv_seq(st, AD74413R_CONV_SEQ_OFF);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_irq(st->dev, spi->irq, ad74413r_adc_data_interrupt,\n\t\t\t       0, st->chip_info->name, indio_dev);\n\tif (ret)\n\t\treturn dev_err_probe(st->dev, ret, \"Failed to request irq\\n\");\n\n\tret = devm_iio_triggered_buffer_setup(st->dev, indio_dev,\n\t\t\t\t\t      &iio_pollfunc_store_time,\n\t\t\t\t\t      &ad74413r_trigger_handler,\n\t\t\t\t\t      &ad74413r_buffer_ops);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(st->dev, indio_dev);\n}\n\nstatic int ad74413r_unregister_driver(struct spi_driver *spi)\n{\n\tspi_unregister_driver(spi);\n\n\treturn 0;\n}\n\nstatic int __init ad74413r_register_driver(struct spi_driver *spi)\n{\n\tcrc8_populate_msb(ad74413r_crc8_table, AD74413R_CRC_POLYNOMIAL);\n\n\treturn spi_register_driver(spi);\n}\n\nstatic const struct ad74413r_chip_info ad74412r_chip_info_data = {\n\t.hart_support = false,\n\t.name = \"ad74412r\",\n};\n\nstatic const struct ad74413r_chip_info ad74413r_chip_info_data = {\n\t.hart_support = true,\n\t.name = \"ad74413r\",\n};\n\nstatic const struct of_device_id ad74413r_dt_id[] = {\n\t{\n\t\t.compatible = \"adi,ad74412r\",\n\t\t.data = &ad74412r_chip_info_data,\n\t},\n\t{\n\t\t.compatible = \"adi,ad74413r\",\n\t\t.data = &ad74413r_chip_info_data,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ad74413r_dt_id);\n\nstatic const struct spi_device_id ad74413r_spi_id[] = {\n\t{ .name = \"ad74412r\", .driver_data = (kernel_ulong_t)&ad74412r_chip_info_data },\n\t{ .name = \"ad74413r\", .driver_data = (kernel_ulong_t)&ad74413r_chip_info_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ad74413r_spi_id);\n\nstatic struct spi_driver ad74413r_driver = {\n\t.driver = {\n\t\t   .name = \"ad74413r\",\n\t\t   .of_match_table = ad74413r_dt_id,\n\t},\n\t.probe = ad74413r_probe,\n\t.id_table = ad74413r_spi_id,\n};\n\nmodule_driver(ad74413r_driver,\n\t      ad74413r_register_driver,\n\t      ad74413r_unregister_driver);\n\nMODULE_AUTHOR(\"Cosmin Tanislav <cosmin.tanislav@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD74413R ADDAC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}