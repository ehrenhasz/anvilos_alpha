{
  "module_name": "ad74115.c",
  "hash_id": "cb651810e13691ce803f2b1980e7358569808aa74b139143feee12a41cb32599",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/addac/ad74115.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/crc8.h>\n#include <linux/device.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/units.h>\n\n#include <asm/unaligned.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#define AD74115_NAME\t\t\t\t\"ad74115\"\n\n#define AD74115_CH_FUNC_SETUP_REG\t\t0x01\n\n#define AD74115_ADC_CONFIG_REG\t\t\t0x02\n#define AD74115_ADC_CONFIG_CONV2_RATE_MASK\tGENMASK(15, 13)\n#define AD74115_ADC_CONFIG_CONV1_RATE_MASK\tGENMASK(12, 10)\n#define AD74115_ADC_CONFIG_CONV2_RANGE_MASK\tGENMASK(9, 7)\n#define AD74115_ADC_CONFIG_CONV1_RANGE_MASK\tGENMASK(6, 4)\n\n#define AD74115_PWR_OPTIM_CONFIG_REG\t\t0x03\n\n#define AD74115_DIN_CONFIG1_REG\t\t\t0x04\n#define AD74115_DIN_COMPARATOR_EN_MASK\t\tBIT(13)\n#define AD74115_DIN_SINK_MASK\t\t\tGENMASK(11, 7)\n#define AD74115_DIN_DEBOUNCE_MASK\t\tGENMASK(4, 0)\n\n#define AD74115_DIN_CONFIG2_REG\t\t\t0x05\n#define AD74115_COMP_THRESH_MASK\t\tGENMASK(6, 0)\n\n#define AD74115_OUTPUT_CONFIG_REG\t\t0x06\n#define AD74115_OUTPUT_SLEW_EN_MASK\t\tGENMASK(6, 5)\n#define AD74115_OUTPUT_SLEW_LIN_STEP_MASK\tGENMASK(4, 3)\n#define AD74115_OUTPUT_SLEW_LIN_RATE_MASK\tGENMASK(2, 1)\n\n#define AD74115_RTD3W4W_CONFIG_REG\t\t0x07\n\n#define AD74115_BURNOUT_CONFIG_REG\t\t0x0a\n#define AD74115_BURNOUT_EXT2_EN_MASK\t\tBIT(10)\n#define AD74115_BURNOUT_EXT1_EN_MASK\t\tBIT(5)\n#define AD74115_BURNOUT_VIOUT_EN_MASK\t\tBIT(0)\n\n#define AD74115_DAC_CODE_REG\t\t\t0x0b\n\n#define AD74115_DAC_ACTIVE_REG\t\t\t0x0d\n\n#define AD74115_GPIO_CONFIG_X_REG(x)\t\t(0x35 + (x))\n#define AD74115_GPIO_CONFIG_GPI_DATA\t\tBIT(5)\n#define AD74115_GPIO_CONFIG_GPO_DATA\t\tBIT(4)\n#define AD74115_GPIO_CONFIG_SELECT_MASK\t\tGENMASK(2, 0)\n\n#define AD74115_CHARGE_PUMP_REG\t\t\t0x3a\n\n#define AD74115_ADC_CONV_CTRL_REG\t\t0x3b\n#define AD74115_ADC_CONV_SEQ_MASK\t\tGENMASK(13, 12)\n\n#define AD74115_DIN_COMP_OUT_REG\t\t0x40\n\n#define AD74115_LIVE_STATUS_REG\t\t\t0x42\n#define AD74115_ADC_DATA_RDY_MASK\t\tBIT(3)\n\n#define AD74115_READ_SELECT_REG\t\t\t0x64\n\n#define AD74115_CMD_KEY_REG\t\t\t0x78\n#define AD74115_CMD_KEY_RESET1\t\t\t0x15fa\n#define AD74115_CMD_KEY_RESET2\t\t\t0xaf51\n\n#define AD74115_CRC_POLYNOMIAL\t\t\t0x7\nDECLARE_CRC8_TABLE(ad74115_crc8_table);\n\n#define AD74115_ADC_CODE_MAX\t\t\t((int)GENMASK(15, 0))\n#define AD74115_ADC_CODE_HALF\t\t\t(AD74115_ADC_CODE_MAX / 2)\n\n#define AD74115_DAC_VOLTAGE_MAX\t\t\t12000\n#define AD74115_DAC_CURRENT_MAX\t\t\t25\n#define AD74115_DAC_CODE_MAX\t\t\t((int)GENMASK(13, 0))\n#define AD74115_DAC_CODE_HALF\t\t\t(AD74115_DAC_CODE_MAX / 2)\n\n#define AD74115_COMP_THRESH_MAX\t\t\t98\n\n#define AD74115_SENSE_RESISTOR_OHMS\t\t100\n#define AD74115_REF_RESISTOR_OHMS\t\t2100\n\n#define AD74115_DIN_SINK_LOW_STEP\t\t120\n#define AD74115_DIN_SINK_HIGH_STEP\t\t240\n#define AD74115_DIN_SINK_MAX\t\t\t31\n\n#define AD74115_FRAME_SIZE\t\t\t4\n#define AD74115_GPIO_NUM\t\t\t4\n\n#define AD74115_CONV_TIME_US\t\t\t1000000\n\nenum ad74115_dac_ch {\n\tAD74115_DAC_CH_MAIN,\n\tAD74115_DAC_CH_COMPARATOR,\n};\n\nenum ad74115_adc_ch {\n\tAD74115_ADC_CH_CONV1,\n\tAD74115_ADC_CH_CONV2,\n\tAD74115_ADC_CH_NUM\n};\n\nenum ad74115_ch_func {\n\tAD74115_CH_FUNC_HIGH_IMPEDANCE,\n\tAD74115_CH_FUNC_VOLTAGE_OUTPUT,\n\tAD74115_CH_FUNC_CURRENT_OUTPUT,\n\tAD74115_CH_FUNC_VOLTAGE_INPUT,\n\tAD74115_CH_FUNC_CURRENT_INPUT_EXT_POWER,\n\tAD74115_CH_FUNC_CURRENT_INPUT_LOOP_POWER,\n\tAD74115_CH_FUNC_2_WIRE_RESISTANCE_INPUT,\n\tAD74115_CH_FUNC_3_4_WIRE_RESISTANCE_INPUT,\n\tAD74115_CH_FUNC_DIGITAL_INPUT_LOGIC,\n\tAD74115_CH_FUNC_DIGITAL_INPUT_LOOP_POWER,\n\tAD74115_CH_FUNC_CURRENT_OUTPUT_HART,\n\tAD74115_CH_FUNC_CURRENT_INPUT_EXT_POWER_HART,\n\tAD74115_CH_FUNC_CURRENT_INPUT_LOOP_POWER_HART,\n\tAD74115_CH_FUNC_MAX = AD74115_CH_FUNC_CURRENT_INPUT_LOOP_POWER_HART,\n\tAD74115_CH_FUNC_NUM\n};\n\nenum ad74115_adc_range {\n\tAD74115_ADC_RANGE_12V,\n\tAD74115_ADC_RANGE_12V_BIPOLAR,\n\tAD74115_ADC_RANGE_2_5V_BIPOLAR,\n\tAD74115_ADC_RANGE_2_5V_NEG,\n\tAD74115_ADC_RANGE_2_5V,\n\tAD74115_ADC_RANGE_0_625V,\n\tAD74115_ADC_RANGE_104MV_BIPOLAR,\n\tAD74115_ADC_RANGE_12V_OTHER,\n\tAD74115_ADC_RANGE_MAX = AD74115_ADC_RANGE_12V_OTHER,\n\tAD74115_ADC_RANGE_NUM\n};\n\nenum ad74115_adc_conv_seq {\n\tAD74115_ADC_CONV_SEQ_STANDBY = 0b00,\n\tAD74115_ADC_CONV_SEQ_SINGLE = 0b01,\n\tAD74115_ADC_CONV_SEQ_CONTINUOUS = 0b10,\n};\n\nenum ad74115_din_threshold_mode {\n\tAD74115_DIN_THRESHOLD_MODE_AVDD,\n\tAD74115_DIN_THRESHOLD_MODE_FIXED,\n\tAD74115_DIN_THRESHOLD_MODE_MAX = AD74115_DIN_THRESHOLD_MODE_FIXED,\n};\n\nenum ad74115_slew_mode {\n\tAD74115_SLEW_MODE_DISABLED,\n\tAD74115_SLEW_MODE_LINEAR,\n\tAD74115_SLEW_MODE_HART,\n};\n\nenum ad74115_slew_step {\n\tAD74115_SLEW_STEP_0_8_PERCENT,\n\tAD74115_SLEW_STEP_1_5_PERCENT,\n\tAD74115_SLEW_STEP_6_1_PERCENT,\n\tAD74115_SLEW_STEP_22_2_PERCENT,\n};\n\nenum ad74115_slew_rate {\n\tAD74115_SLEW_RATE_4KHZ,\n\tAD74115_SLEW_RATE_64KHZ,\n\tAD74115_SLEW_RATE_150KHZ,\n\tAD74115_SLEW_RATE_240KHZ,\n};\n\nenum ad74115_gpio_config {\n\tAD74115_GPIO_CONFIG_OUTPUT_BUFFERED = 0b010,\n\tAD74115_GPIO_CONFIG_INPUT = 0b011,\n};\n\nenum ad74115_gpio_mode {\n\tAD74115_GPIO_MODE_LOGIC = 1,\n\tAD74115_GPIO_MODE_SPECIAL = 2,\n};\n\nstruct ad74115_channels {\n\tstruct iio_chan_spec\t\t*channels;\n\tunsigned int\t\t\tnum_channels;\n};\n\nstruct ad74115_state {\n\tstruct spi_device\t\t*spi;\n\tstruct regmap\t\t\t*regmap;\n\tstruct iio_trigger\t\t*trig;\n\tstruct regulator\t\t*avdd;\n\n\t \n\tstruct mutex\t\t\tlock;\n\tstruct gpio_chip\t\tgc;\n\tstruct gpio_chip\t\tcomp_gc;\n\tint\t\t\t\tirq;\n\n\tunsigned int\t\t\tavdd_mv;\n\tunsigned long\t\t\tgpio_valid_mask;\n\tbool\t\t\t\tdac_bipolar;\n\tbool\t\t\t\tdac_hart_slew;\n\tbool\t\t\t\trtd_mode_4_wire;\n\tenum ad74115_ch_func\t\tch_func;\n\tenum ad74115_din_threshold_mode\tdin_threshold_mode;\n\n\tstruct completion\t\tadc_data_completion;\n\tstruct spi_message\t\tadc_samples_msg;\n\tstruct spi_transfer\t\tadc_samples_xfer[AD74115_ADC_CH_NUM + 1];\n\n\t \n\tu8\t\t\t\treg_tx_buf[AD74115_FRAME_SIZE] __aligned(IIO_DMA_MINALIGN);\n\tu8\t\t\t\treg_rx_buf[AD74115_FRAME_SIZE];\n\tu8\t\t\t\tadc_samples_tx_buf[AD74115_FRAME_SIZE * AD74115_ADC_CH_NUM];\n\tu8\t\t\t\tadc_samples_rx_buf[AD74115_FRAME_SIZE * AD74115_ADC_CH_NUM];\n};\n\nstruct ad74115_fw_prop {\n\tconst char\t\t\t*name;\n\tbool\t\t\t\tis_boolean;\n\tbool\t\t\t\tnegate;\n\tunsigned int\t\t\tmax;\n\tunsigned int\t\t\treg;\n\tunsigned int\t\t\tmask;\n\tconst unsigned int\t\t*lookup_tbl;\n\tunsigned int\t\t\tlookup_tbl_len;\n};\n\n#define AD74115_FW_PROP(_name, _max, _reg, _mask)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.name = (_name),\t\t\t\t\t\\\n\t.max = (_max),\t\t\t\t\t\t\\\n\t.reg = (_reg),\t\t\t\t\t\t\\\n\t.mask = (_mask),\t\t\t\t\t\\\n}\n\n#define AD74115_FW_PROP_TBL(_name, _tbl, _reg, _mask)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.name = (_name),\t\t\t\t\t\\\n\t.reg = (_reg),\t\t\t\t\t\t\\\n\t.mask = (_mask),\t\t\t\t\t\\\n\t.lookup_tbl = (_tbl),\t\t\t\t\t\\\n\t.lookup_tbl_len = ARRAY_SIZE(_tbl),\t\t\t\\\n}\n\n#define AD74115_FW_PROP_BOOL(_name, _reg, _mask)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.name = (_name),\t\t\t\t\t\\\n\t.is_boolean = true,\t\t\t\t\t\\\n\t.reg = (_reg),\t\t\t\t\t\t\\\n\t.mask = (_mask),\t\t\t\t\t\\\n}\n\n#define AD74115_FW_PROP_BOOL_NEG(_name, _reg, _mask)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.name = (_name),\t\t\t\t\t\\\n\t.is_boolean = true,\t\t\t\t\t\\\n\t.negate = true,\t\t\t\t\t\t\\\n\t.reg = (_reg),\t\t\t\t\t\t\\\n\t.mask = (_mask),\t\t\t\t\t\\\n}\n\nstatic const int ad74115_dac_rate_tbl[] = {\n\t0,\n\t4 * 8,\n\t4 * 15,\n\t4 * 61,\n\t4 * 222,\n\t64 * 8,\n\t64 * 15,\n\t64 * 61,\n\t64 * 222,\n\t150 * 8,\n\t150 * 15,\n\t150 * 61,\n\t150 * 222,\n\t240 * 8,\n\t240 * 15,\n\t240 * 61,\n\t240 * 222,\n};\n\nstatic const unsigned int ad74115_dac_rate_step_tbl[][3] = {\n\t{ AD74115_SLEW_MODE_DISABLED },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_0_8_PERCENT, AD74115_SLEW_RATE_4KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_1_5_PERCENT, AD74115_SLEW_RATE_4KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_6_1_PERCENT, AD74115_SLEW_RATE_4KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_22_2_PERCENT, AD74115_SLEW_RATE_4KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_0_8_PERCENT, AD74115_SLEW_RATE_64KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_1_5_PERCENT, AD74115_SLEW_RATE_64KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_6_1_PERCENT, AD74115_SLEW_RATE_64KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_22_2_PERCENT, AD74115_SLEW_RATE_64KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_0_8_PERCENT, AD74115_SLEW_RATE_150KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_1_5_PERCENT, AD74115_SLEW_RATE_150KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_6_1_PERCENT, AD74115_SLEW_RATE_150KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_22_2_PERCENT, AD74115_SLEW_RATE_150KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_0_8_PERCENT, AD74115_SLEW_RATE_240KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_1_5_PERCENT, AD74115_SLEW_RATE_240KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_6_1_PERCENT, AD74115_SLEW_RATE_240KHZ },\n\t{ AD74115_SLEW_MODE_LINEAR, AD74115_SLEW_STEP_22_2_PERCENT, AD74115_SLEW_RATE_240KHZ },\n};\n\nstatic const unsigned int ad74115_rtd_excitation_current_ua_tbl[] = {\n\t250, 500, 750, 1000\n};\n\nstatic const unsigned int ad74115_burnout_current_na_tbl[] = {\n\t0, 50, 0, 500, 1000, 0, 10000, 0\n};\n\nstatic const unsigned int ad74115_viout_burnout_current_na_tbl[] = {\n\t0, 0, 0, 0, 1000, 0, 10000, 0\n};\n\nstatic const unsigned int ad74115_gpio_mode_tbl[] = {\n\t0, 0, 0, 1, 2, 3, 4, 5\n};\n\nstatic const unsigned int ad74115_adc_conv_rate_tbl[] = {\n\t10, 20, 1200, 4800, 9600\n};\n\nstatic const unsigned int ad74115_debounce_tbl[] = {\n\t0,     13,    18,    24,    32,    42,    56,    75,\n\t100,   130,   180,   240,   320,   420,   560,   750,\n\t1000,  1300,  1800,  2400,  3200,  4200,  5600,  7500,\n\t10000, 13000, 18000, 24000, 32000, 42000, 56000, 75000,\n};\n\nstatic const unsigned int ad74115_adc_ch_data_regs_tbl[] = {\n\t[AD74115_ADC_CH_CONV1] = 0x44,\n\t[AD74115_ADC_CH_CONV2] = 0x46,\n};\n\nstatic const unsigned int ad74115_adc_ch_en_bit_tbl[] = {\n\t[AD74115_ADC_CH_CONV1] = BIT(0),\n\t[AD74115_ADC_CH_CONV2] = BIT(1),\n};\n\nstatic const bool ad74115_adc_bipolar_tbl[AD74115_ADC_RANGE_NUM] = {\n\t[AD74115_ADC_RANGE_12V_BIPOLAR]\t\t= true,\n\t[AD74115_ADC_RANGE_2_5V_BIPOLAR]\t= true,\n\t[AD74115_ADC_RANGE_104MV_BIPOLAR]\t= true,\n};\n\nstatic const unsigned int ad74115_adc_conv_mul_tbl[AD74115_ADC_RANGE_NUM] = {\n\t[AD74115_ADC_RANGE_12V]\t\t\t= 12000,\n\t[AD74115_ADC_RANGE_12V_BIPOLAR]\t\t= 24000,\n\t[AD74115_ADC_RANGE_2_5V_BIPOLAR]\t= 5000,\n\t[AD74115_ADC_RANGE_2_5V_NEG]\t\t= 2500,\n\t[AD74115_ADC_RANGE_2_5V]\t\t= 2500,\n\t[AD74115_ADC_RANGE_0_625V]\t\t= 625,\n\t[AD74115_ADC_RANGE_104MV_BIPOLAR]\t= 208,\n\t[AD74115_ADC_RANGE_12V_OTHER]\t\t= 12000,\n};\n\nstatic const unsigned int ad74115_adc_gain_tbl[AD74115_ADC_RANGE_NUM][2] = {\n\t[AD74115_ADC_RANGE_12V]\t\t\t= { 5, 24 },\n\t[AD74115_ADC_RANGE_12V_BIPOLAR]\t\t= { 5, 24 },\n\t[AD74115_ADC_RANGE_2_5V_BIPOLAR]\t= { 1, 1 },\n\t[AD74115_ADC_RANGE_2_5V_NEG]\t\t= { 1, 1 },\n\t[AD74115_ADC_RANGE_2_5V]\t\t= { 1, 1 },\n\t[AD74115_ADC_RANGE_0_625V]\t\t= { 4, 1 },\n\t[AD74115_ADC_RANGE_104MV_BIPOLAR]\t= { 24, 1 },\n\t[AD74115_ADC_RANGE_12V_OTHER]\t\t= { 5, 24 },\n};\n\nstatic const int ad74115_adc_range_tbl[AD74115_ADC_RANGE_NUM][2] = {\n\t[AD74115_ADC_RANGE_12V]\t\t\t= { 0,         12000000 },\n\t[AD74115_ADC_RANGE_12V_BIPOLAR]\t\t= { -12000000, 12000000 },\n\t[AD74115_ADC_RANGE_2_5V_BIPOLAR]\t= { -2500000,  2500000 },\n\t[AD74115_ADC_RANGE_2_5V_NEG]\t\t= { -2500000,  0 },\n\t[AD74115_ADC_RANGE_2_5V]\t\t= { 0,         2500000 },\n\t[AD74115_ADC_RANGE_0_625V]\t\t= { 0,         625000 },\n\t[AD74115_ADC_RANGE_104MV_BIPOLAR]\t= { -104000,   104000 },\n\t[AD74115_ADC_RANGE_12V_OTHER]\t\t= { 0,         12000000 },\n};\n\nstatic int _ad74115_find_tbl_index(const unsigned int *tbl, unsigned int tbl_len,\n\t\t\t\t   unsigned int val, unsigned int *index)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < tbl_len; i++)\n\t\tif (val == tbl[i]) {\n\t\t\t*index = i;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -EINVAL;\n}\n\n#define ad74115_find_tbl_index(tbl, val, index)\t\\\n\t_ad74115_find_tbl_index(tbl, ARRAY_SIZE(tbl), val, index)\n\nstatic int ad74115_crc(u8 *buf)\n{\n\treturn crc8(ad74115_crc8_table, buf, 3, 0);\n}\n\nstatic void ad74115_format_reg_write(u8 reg, u16 val, u8 *buf)\n{\n\tbuf[0] = reg;\n\tput_unaligned_be16(val, &buf[1]);\n\tbuf[3] = ad74115_crc(buf);\n}\n\nstatic int ad74115_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct ad74115_state *st = context;\n\n\tad74115_format_reg_write(reg, val, st->reg_tx_buf);\n\n\treturn spi_write(st->spi, st->reg_tx_buf, AD74115_FRAME_SIZE);\n}\n\nstatic int ad74115_crc_check(struct ad74115_state *st, u8 *buf)\n{\n\tstruct device *dev = &st->spi->dev;\n\tu8 expected_crc = ad74115_crc(buf);\n\n\tif (buf[3] != expected_crc) {\n\t\tdev_err(dev, \"Bad CRC %02x for %02x%02x%02x, expected %02x\\n\",\n\t\t\tbuf[3], buf[0], buf[1], buf[2], expected_crc);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad74115_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct ad74115_state *st = context;\n\tstruct spi_transfer reg_read_xfer[] = {\n\t\t{\n\t\t\t.tx_buf = st->reg_tx_buf,\n\t\t\t.len = sizeof(st->reg_tx_buf),\n\t\t\t.cs_change = 1,\n\t\t},\n\t\t{\n\t\t\t.rx_buf = st->reg_rx_buf,\n\t\t\t.len = sizeof(st->reg_rx_buf),\n\t\t},\n\t};\n\tint ret;\n\n\tad74115_format_reg_write(AD74115_READ_SELECT_REG, reg, st->reg_tx_buf);\n\n\tret = spi_sync_transfer(st->spi, reg_read_xfer, ARRAY_SIZE(reg_read_xfer));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74115_crc_check(st, st->reg_rx_buf);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = get_unaligned_be16(&st->reg_rx_buf[1]);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config ad74115_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.reg_read = ad74115_reg_read,\n\t.reg_write = ad74115_reg_write,\n};\n\nstatic int ad74115_gpio_config_set(struct ad74115_state *st, unsigned int offset,\n\t\t\t\t   enum ad74115_gpio_config cfg)\n{\n\treturn regmap_update_bits(st->regmap, AD74115_GPIO_CONFIG_X_REG(offset),\n\t\t\t\t  AD74115_GPIO_CONFIG_SELECT_MASK,\n\t\t\t\t  FIELD_PREP(AD74115_GPIO_CONFIG_SELECT_MASK, cfg));\n}\n\nstatic int ad74115_gpio_init_valid_mask(struct gpio_chip *gc,\n\t\t\t\t\tunsigned long *valid_mask,\n\t\t\t\t\tunsigned int ngpios)\n{\n\tstruct ad74115_state *st = gpiochip_get_data(gc);\n\n\t*valid_mask = st->gpio_valid_mask;\n\n\treturn 0;\n}\n\nstatic int ad74115_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct ad74115_state *st = gpiochip_get_data(gc);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(st->regmap, AD74115_GPIO_CONFIG_X_REG(offset), &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn FIELD_GET(AD74115_GPIO_CONFIG_SELECT_MASK, val) == AD74115_GPIO_CONFIG_INPUT;\n}\n\nstatic int ad74115_gpio_direction_input(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct ad74115_state *st = gpiochip_get_data(gc);\n\n\treturn ad74115_gpio_config_set(st, offset, AD74115_GPIO_CONFIG_INPUT);\n}\n\nstatic int ad74115_gpio_direction_output(struct gpio_chip *gc, unsigned int offset,\n\t\t\t\t\t int value)\n{\n\tstruct ad74115_state *st = gpiochip_get_data(gc);\n\n\treturn ad74115_gpio_config_set(st, offset, AD74115_GPIO_CONFIG_OUTPUT_BUFFERED);\n}\n\nstatic int ad74115_gpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct ad74115_state *st = gpiochip_get_data(gc);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(st->regmap, AD74115_GPIO_CONFIG_X_REG(offset), &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn FIELD_GET(AD74115_GPIO_CONFIG_GPI_DATA, val);\n}\n\nstatic void ad74115_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)\n{\n\tstruct ad74115_state *st = gpiochip_get_data(gc);\n\tstruct device *dev = &st->spi->dev;\n\tint ret;\n\n\tret = regmap_update_bits(st->regmap, AD74115_GPIO_CONFIG_X_REG(offset),\n\t\t\t\t AD74115_GPIO_CONFIG_GPO_DATA,\n\t\t\t\t FIELD_PREP(AD74115_GPIO_CONFIG_GPO_DATA, value));\n\tif (ret)\n\t\tdev_err(dev, \"Failed to set GPIO %u output value, err: %d\\n\",\n\t\t\toffset, ret);\n}\n\nstatic int ad74115_set_comp_debounce(struct ad74115_state *st, unsigned int val)\n{\n\tunsigned int len = ARRAY_SIZE(ad74115_debounce_tbl);\n\tunsigned int i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (val <= ad74115_debounce_tbl[i])\n\t\t\tbreak;\n\n\tif (i == len)\n\t\ti = len - 1;\n\n\treturn regmap_update_bits(st->regmap, AD74115_DIN_CONFIG1_REG,\n\t\t\t\t  AD74115_DIN_DEBOUNCE_MASK,\n\t\t\t\t  FIELD_PREP(AD74115_DIN_DEBOUNCE_MASK, val));\n}\n\nstatic int ad74115_comp_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t\t   unsigned int offset)\n{\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int ad74115_comp_gpio_set_config(struct gpio_chip *chip,\n\t\t\t\t\tunsigned int offset,\n\t\t\t\t\tunsigned long config)\n{\n\tstruct ad74115_state *st = gpiochip_get_data(chip);\n\tu32 param = pinconf_to_config_param(config);\n\tu32 arg = pinconf_to_config_argument(config);\n\n\tswitch (param) {\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\treturn ad74115_set_comp_debounce(st, arg);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic int ad74115_comp_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct ad74115_state *st = gpiochip_get_data(chip);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(st->regmap, AD74115_DIN_COMP_OUT_REG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!val;\n}\n\nstatic irqreturn_t ad74115_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct ad74115_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = spi_sync(st->spi, &st->adc_samples_msg);\n\tif (ret)\n\t\tgoto out;\n\n\tiio_push_to_buffers(indio_dev, st->adc_samples_rx_buf);\n\nout:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ad74115_adc_data_interrupt(int irq, void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\tstruct ad74115_state *st = iio_priv(indio_dev);\n\n\tif (iio_buffer_enabled(indio_dev))\n\t\tiio_trigger_poll(st->trig);\n\telse\n\t\tcomplete(&st->adc_data_completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ad74115_set_adc_ch_en(struct ad74115_state *st,\n\t\t\t\t enum ad74115_adc_ch channel, bool status)\n{\n\tunsigned int mask = ad74115_adc_ch_en_bit_tbl[channel];\n\n\treturn regmap_update_bits(st->regmap, AD74115_ADC_CONV_CTRL_REG, mask,\n\t\t\t\t  status ? mask : 0);\n}\n\nstatic int ad74115_set_adc_conv_seq(struct ad74115_state *st,\n\t\t\t\t    enum ad74115_adc_conv_seq conv_seq)\n{\n\treturn regmap_update_bits(st->regmap, AD74115_ADC_CONV_CTRL_REG,\n\t\t\t\t  AD74115_ADC_CONV_SEQ_MASK,\n\t\t\t\t  FIELD_PREP(AD74115_ADC_CONV_SEQ_MASK, conv_seq));\n}\n\nstatic int ad74115_update_scan_mode(struct iio_dev *indio_dev,\n\t\t\t\t    const unsigned long *active_scan_mask)\n{\n\tstruct ad74115_state *st = iio_priv(indio_dev);\n\tstruct spi_transfer *xfer = st->adc_samples_xfer;\n\tu8 *rx_buf = st->adc_samples_rx_buf;\n\tu8 *tx_buf = st->adc_samples_tx_buf;\n\tunsigned int i;\n\tint ret = 0;\n\n\tmutex_lock(&st->lock);\n\n\tspi_message_init(&st->adc_samples_msg);\n\n\tfor_each_clear_bit(i, active_scan_mask, AD74115_ADC_CH_NUM) {\n\t\tret = ad74115_set_adc_ch_en(st, i, false);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tfor_each_set_bit(i, active_scan_mask, AD74115_ADC_CH_NUM) {\n\t\tret = ad74115_set_adc_ch_en(st, i, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (xfer == st->adc_samples_xfer)\n\t\t\txfer->rx_buf = NULL;\n\t\telse\n\t\t\txfer->rx_buf = rx_buf;\n\n\t\txfer->tx_buf = tx_buf;\n\t\txfer->len = AD74115_FRAME_SIZE;\n\t\txfer->cs_change = 1;\n\n\t\tad74115_format_reg_write(AD74115_READ_SELECT_REG,\n\t\t\t\t\t ad74115_adc_ch_data_regs_tbl[i], tx_buf);\n\n\t\tspi_message_add_tail(xfer, &st->adc_samples_msg);\n\n\t\ttx_buf += AD74115_FRAME_SIZE;\n\t\tif (xfer != st->adc_samples_xfer)\n\t\t\trx_buf += AD74115_FRAME_SIZE;\n\t\txfer++;\n\t}\n\n\txfer->rx_buf = rx_buf;\n\txfer->tx_buf = NULL;\n\txfer->len = AD74115_FRAME_SIZE;\n\txfer->cs_change = 0;\n\n\tspi_message_add_tail(xfer, &st->adc_samples_msg);\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic int ad74115_buffer_postenable(struct iio_dev *indio_dev)\n{\n\tstruct ad74115_state *st = iio_priv(indio_dev);\n\n\treturn ad74115_set_adc_conv_seq(st, AD74115_ADC_CONV_SEQ_CONTINUOUS);\n}\n\nstatic int ad74115_buffer_predisable(struct iio_dev *indio_dev)\n{\n\tstruct ad74115_state *st = iio_priv(indio_dev);\n\tunsigned int i;\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\tret = ad74115_set_adc_conv_seq(st, AD74115_ADC_CONV_SEQ_STANDBY);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < AD74115_ADC_CH_NUM; i++) {\n\t\tret = ad74115_set_adc_ch_en(st, i, false);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&st->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_buffer_setup_ops ad74115_buffer_ops = {\n\t.postenable = &ad74115_buffer_postenable,\n\t.predisable = &ad74115_buffer_predisable,\n};\n\nstatic const struct iio_trigger_ops ad74115_trigger_ops = {\n\t.validate_device = iio_trigger_validate_own_device,\n};\n\nstatic int ad74115_get_adc_rate(struct ad74115_state *st,\n\t\t\t\tenum ad74115_adc_ch channel, int *val)\n{\n\tunsigned int i;\n\tint ret;\n\n\tret = regmap_read(st->regmap, AD74115_ADC_CONFIG_REG, &i);\n\tif (ret)\n\t\treturn ret;\n\n\tif (channel == AD74115_ADC_CH_CONV1)\n\t\ti = FIELD_GET(AD74115_ADC_CONFIG_CONV1_RATE_MASK, i);\n\telse\n\t\ti = FIELD_GET(AD74115_ADC_CONFIG_CONV2_RATE_MASK, i);\n\n\t*val = ad74115_adc_conv_rate_tbl[i];\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int _ad74115_get_adc_code(struct ad74115_state *st,\n\t\t\t\t enum ad74115_adc_ch channel, int *val)\n{\n\tunsigned int uval;\n\tint ret;\n\n\treinit_completion(&st->adc_data_completion);\n\n\tret = ad74115_set_adc_ch_en(st, channel, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74115_set_adc_conv_seq(st, AD74115_ADC_CONV_SEQ_SINGLE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->irq) {\n\t\tret = wait_for_completion_timeout(&st->adc_data_completion,\n\t\t\t\t\t\t  msecs_to_jiffies(1000));\n\t\tif (!ret)\n\t\t\treturn -ETIMEDOUT;\n\t} else {\n\t\tunsigned int regval, wait_time;\n\t\tint rate;\n\n\t\tret = ad74115_get_adc_rate(st, channel, &rate);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\twait_time = DIV_ROUND_CLOSEST(AD74115_CONV_TIME_US, rate);\n\n\t\tret = regmap_read_poll_timeout(st->regmap, AD74115_LIVE_STATUS_REG,\n\t\t\t\t\t       regval, regval & AD74115_ADC_DATA_RDY_MASK,\n\t\t\t\t\t       wait_time, 5 * wait_time);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_write_bits(st->regmap, AD74115_LIVE_STATUS_REG,\n\t\t\t\t\tAD74115_ADC_DATA_RDY_MASK,\n\t\t\t\t\tFIELD_PREP(AD74115_ADC_DATA_RDY_MASK, 1));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = regmap_read(st->regmap, ad74115_adc_ch_data_regs_tbl[channel], &uval);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74115_set_adc_conv_seq(st, AD74115_ADC_CONV_SEQ_STANDBY);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74115_set_adc_ch_en(st, channel, false);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = uval;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int ad74115_get_adc_code(struct iio_dev *indio_dev,\n\t\t\t\tenum ad74115_adc_ch channel, int *val)\n{\n\tstruct ad74115_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&st->lock);\n\tret = _ad74115_get_adc_code(st, channel, val);\n\tmutex_unlock(&st->lock);\n\n\tiio_device_release_direct_mode(indio_dev);\n\n\treturn ret;\n}\n\nstatic int ad74115_adc_code_to_resistance(int code, int *val, int *val2)\n{\n\tif (code == AD74115_ADC_CODE_MAX)\n\t\tcode--;\n\n\t*val = code * AD74115_REF_RESISTOR_OHMS;\n\t*val2 = AD74115_ADC_CODE_MAX - code;\n\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int ad74115_set_dac_code(struct ad74115_state *st,\n\t\t\t\tenum ad74115_dac_ch channel, int val)\n{\n\tif (val < 0)\n\t\treturn -EINVAL;\n\n\tif (channel == AD74115_DAC_CH_COMPARATOR) {\n\t\tif (val > AD74115_COMP_THRESH_MAX)\n\t\t\treturn -EINVAL;\n\n\t\treturn regmap_update_bits(st->regmap, AD74115_DIN_CONFIG2_REG,\n\t\t\t\t\t  AD74115_COMP_THRESH_MASK,\n\t\t\t\t\t  FIELD_PREP(AD74115_COMP_THRESH_MASK, val));\n\t}\n\n\tif (val > AD74115_DAC_CODE_MAX)\n\t\treturn -EINVAL;\n\n\treturn regmap_write(st->regmap, AD74115_DAC_CODE_REG, val);\n}\n\nstatic int ad74115_get_dac_code(struct ad74115_state *st,\n\t\t\t\tenum ad74115_dac_ch channel, int *val)\n{\n\tunsigned int uval;\n\tint ret;\n\n\tif (channel == AD74115_DAC_CH_COMPARATOR)\n\t\treturn -EINVAL;\n\n\tret = regmap_read(st->regmap, AD74115_DAC_ACTIVE_REG, &uval);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = uval;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int ad74115_set_adc_rate(struct ad74115_state *st,\n\t\t\t\tenum ad74115_adc_ch channel, int val)\n{\n\tunsigned int i;\n\tint ret;\n\n\tret = ad74115_find_tbl_index(ad74115_adc_conv_rate_tbl, val, &i);\n\tif (ret)\n\t\treturn ret;\n\n\tif (channel == AD74115_ADC_CH_CONV1)\n\t\treturn regmap_update_bits(st->regmap, AD74115_ADC_CONFIG_REG,\n\t\t\t\t\t  AD74115_ADC_CONFIG_CONV1_RATE_MASK,\n\t\t\t\t\t  FIELD_PREP(AD74115_ADC_CONFIG_CONV1_RATE_MASK, i));\n\n\treturn regmap_update_bits(st->regmap, AD74115_ADC_CONFIG_REG,\n\t\t\t\t  AD74115_ADC_CONFIG_CONV2_RATE_MASK,\n\t\t\t\t  FIELD_PREP(AD74115_ADC_CONFIG_CONV2_RATE_MASK, i));\n}\n\nstatic int ad74115_get_dac_rate(struct ad74115_state *st, int *val)\n{\n\tunsigned int i, en_val, step_val, rate_val, tmp;\n\tint ret;\n\n\tret = regmap_read(st->regmap, AD74115_OUTPUT_CONFIG_REG, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\ten_val = FIELD_GET(AD74115_OUTPUT_SLEW_EN_MASK, tmp);\n\tstep_val = FIELD_GET(AD74115_OUTPUT_SLEW_LIN_STEP_MASK, tmp);\n\trate_val = FIELD_GET(AD74115_OUTPUT_SLEW_LIN_RATE_MASK, tmp);\n\n\tfor (i = 0; i < ARRAY_SIZE(ad74115_dac_rate_step_tbl); i++)\n\t\tif (en_val == ad74115_dac_rate_step_tbl[i][0] &&\n\t\t    step_val == ad74115_dac_rate_step_tbl[i][1] &&\n\t\t    rate_val == ad74115_dac_rate_step_tbl[i][2])\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(ad74115_dac_rate_step_tbl))\n\t\treturn -EINVAL;\n\n\t*val = ad74115_dac_rate_tbl[i];\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int ad74115_set_dac_rate(struct ad74115_state *st, int val)\n{\n\tunsigned int i, en_val, step_val, rate_val, mask, tmp;\n\tint ret;\n\n\tret = ad74115_find_tbl_index(ad74115_dac_rate_tbl, val, &i);\n\tif (ret)\n\t\treturn ret;\n\n\ten_val = ad74115_dac_rate_step_tbl[i][0];\n\tstep_val = ad74115_dac_rate_step_tbl[i][1];\n\trate_val = ad74115_dac_rate_step_tbl[i][2];\n\n\tmask = AD74115_OUTPUT_SLEW_EN_MASK;\n\tmask |= AD74115_OUTPUT_SLEW_LIN_STEP_MASK;\n\tmask |= AD74115_OUTPUT_SLEW_LIN_RATE_MASK;\n\n\ttmp = FIELD_PREP(AD74115_OUTPUT_SLEW_EN_MASK, en_val);\n\ttmp |= FIELD_PREP(AD74115_OUTPUT_SLEW_LIN_STEP_MASK, step_val);\n\ttmp |= FIELD_PREP(AD74115_OUTPUT_SLEW_LIN_RATE_MASK, rate_val);\n\n\treturn regmap_update_bits(st->regmap, AD74115_OUTPUT_CONFIG_REG, mask, tmp);\n}\n\nstatic int ad74115_get_dac_scale(struct ad74115_state *st,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int *val, int *val2)\n{\n\tif (chan->channel == AD74115_DAC_CH_MAIN) {\n\t\tif (chan->type == IIO_VOLTAGE) {\n\t\t\t*val = AD74115_DAC_VOLTAGE_MAX;\n\n\t\t\tif (st->dac_bipolar)\n\t\t\t\t*val *= 2;\n\n\t\t} else {\n\t\t\t*val = AD74115_DAC_CURRENT_MAX;\n\t\t}\n\n\t\t*val2 = AD74115_DAC_CODE_MAX;\n\t} else {\n\t\tif (st->din_threshold_mode == AD74115_DIN_THRESHOLD_MODE_AVDD) {\n\t\t\t*val = 196 * st->avdd_mv;\n\t\t\t*val2 = 10 * AD74115_COMP_THRESH_MAX;\n\t\t} else {\n\t\t\t*val = 49000;\n\t\t\t*val2 = AD74115_COMP_THRESH_MAX;\n\t\t}\n\t}\n\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int ad74115_get_dac_offset(struct ad74115_state *st,\n\t\t\t\t  struct iio_chan_spec const *chan, int *val)\n{\n\tif (chan->channel == AD74115_DAC_CH_MAIN) {\n\t\tif (chan->type == IIO_VOLTAGE && st->dac_bipolar)\n\t\t\t*val = -AD74115_DAC_CODE_HALF;\n\t\telse\n\t\t\t*val = 0;\n\t} else {\n\t\tif (st->din_threshold_mode == AD74115_DIN_THRESHOLD_MODE_AVDD)\n\t\t\t*val = -48;\n\t\telse\n\t\t\t*val = -38;\n\t}\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int ad74115_get_adc_range(struct ad74115_state *st,\n\t\t\t\t enum ad74115_adc_ch channel, unsigned int *val)\n{\n\tint ret;\n\n\tret = regmap_read(st->regmap, AD74115_ADC_CONFIG_REG, val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (channel == AD74115_ADC_CH_CONV1)\n\t\t*val = FIELD_GET(AD74115_ADC_CONFIG_CONV1_RANGE_MASK, *val);\n\telse\n\t\t*val = FIELD_GET(AD74115_ADC_CONFIG_CONV2_RANGE_MASK, *val);\n\n\treturn 0;\n}\n\nstatic int ad74115_get_adc_resistance_scale(struct ad74115_state *st,\n\t\t\t\t\t    unsigned int range,\n\t\t\t\t\t    int *val, int *val2)\n{\n\t*val = ad74115_adc_gain_tbl[range][1] * AD74115_REF_RESISTOR_OHMS;\n\t*val2 = ad74115_adc_gain_tbl[range][0];\n\n\tif (ad74115_adc_bipolar_tbl[range])\n\t\t*val2 *= AD74115_ADC_CODE_HALF;\n\telse\n\t\t*val2 *= AD74115_ADC_CODE_MAX;\n\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int ad74115_get_adc_scale(struct ad74115_state *st,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int *val, int *val2)\n{\n\tunsigned int range;\n\tint ret;\n\n\tret = ad74115_get_adc_range(st, chan->channel, &range);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chan->type == IIO_RESISTANCE)\n\t\treturn ad74115_get_adc_resistance_scale(st, range, val, val2);\n\n\t*val = ad74115_adc_conv_mul_tbl[range];\n\t*val2 = AD74115_ADC_CODE_MAX;\n\n\tif (chan->type == IIO_CURRENT)\n\t\t*val2 *= AD74115_SENSE_RESISTOR_OHMS;\n\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int ad74115_get_adc_resistance_offset(struct ad74115_state *st,\n\t\t\t\t\t     unsigned int range,\n\t\t\t\t\t     int *val, int *val2)\n{\n\tunsigned int d = 10 * AD74115_REF_RESISTOR_OHMS\n\t\t\t * ad74115_adc_gain_tbl[range][1];\n\n\t*val = 5;\n\n\tif (ad74115_adc_bipolar_tbl[range])\n\t\t*val -= AD74115_ADC_CODE_HALF;\n\n\t*val *= d;\n\n\tif (!st->rtd_mode_4_wire) {\n\t\t \n\t\tunsigned int v = 2 * ad74115_adc_gain_tbl[range][0];\n\n\t\tif (ad74115_adc_bipolar_tbl[range])\n\t\t\tv *= AD74115_ADC_CODE_HALF;\n\t\telse\n\t\t\tv *= AD74115_ADC_CODE_MAX;\n\n\t\t*val += v;\n\t}\n\n\t*val2 = d;\n\n\treturn IIO_VAL_FRACTIONAL;\n}\n\nstatic int ad74115_get_adc_offset(struct ad74115_state *st,\n\t\t\t\t  struct iio_chan_spec const *chan,\n\t\t\t\t  int *val, int *val2)\n{\n\tunsigned int range;\n\tint ret;\n\n\tret = ad74115_get_adc_range(st, chan->channel, &range);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chan->type == IIO_RESISTANCE)\n\t\treturn ad74115_get_adc_resistance_offset(st, range, val, val2);\n\n\tif (ad74115_adc_bipolar_tbl[range])\n\t\t*val = -AD74115_ADC_CODE_HALF;\n\telse if (range == AD74115_ADC_RANGE_2_5V_NEG)\n\t\t*val = -AD74115_ADC_CODE_MAX;\n\telse\n\t\t*val = 0;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int ad74115_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long info)\n{\n\tstruct ad74115_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->output)\n\t\t\treturn ad74115_get_dac_code(st, chan->channel, val);\n\n\t\treturn ad74115_get_adc_code(indio_dev, chan->channel, val);\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tret = ad74115_get_adc_code(indio_dev, chan->channel, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn ad74115_adc_code_to_resistance(*val, val, val2);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->output)\n\t\t\treturn ad74115_get_dac_scale(st, chan, val, val2);\n\n\t\treturn ad74115_get_adc_scale(st, chan, val, val2);\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (chan->output)\n\t\t\treturn ad74115_get_dac_offset(st, chan, val);\n\n\t\treturn ad74115_get_adc_offset(st, chan, val, val2);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (chan->output)\n\t\t\treturn ad74115_get_dac_rate(st, val);\n\n\t\treturn ad74115_get_adc_rate(st, chan->channel, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad74115_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int val, int val2,\n\t\t\t     long info)\n{\n\tstruct ad74115_state *st = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (!chan->output)\n\t\t\treturn -EINVAL;\n\n\t\treturn ad74115_set_dac_code(st, chan->channel, val);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (chan->output)\n\t\t\treturn ad74115_set_dac_rate(st, val);\n\n\t\treturn ad74115_set_adc_rate(st, chan->channel, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad74115_read_avail(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      const int **vals, int *type, int *length, long info)\n{\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (chan->output) {\n\t\t\t*vals = ad74115_dac_rate_tbl;\n\t\t\t*length = ARRAY_SIZE(ad74115_dac_rate_tbl);\n\t\t} else {\n\t\t\t*vals = ad74115_adc_conv_rate_tbl;\n\t\t\t*length = ARRAY_SIZE(ad74115_adc_conv_rate_tbl);\n\t\t}\n\n\t\t*type = IIO_VAL_INT;\n\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad74115_reg_access(struct iio_dev *indio_dev, unsigned int reg,\n\t\t\t      unsigned int writeval, unsigned int *readval)\n{\n\tstruct ad74115_state *st = iio_priv(indio_dev);\n\n\tif (readval)\n\t\treturn regmap_read(st->regmap, reg, readval);\n\n\treturn regmap_write(st->regmap, reg, writeval);\n}\n\nstatic const struct iio_info ad74115_info = {\n\t.read_raw = ad74115_read_raw,\n\t.write_raw = ad74115_write_raw,\n\t.read_avail = ad74115_read_avail,\n\t.update_scan_mode = ad74115_update_scan_mode,\n\t.debugfs_reg_access = ad74115_reg_access,\n};\n\n#define AD74115_DAC_CHANNEL(_type, index)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = (_type),\t\t\t\t\t\\\n\t\t.channel = (index),\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.output = 1,\t\t\t\t\t\t\\\n\t\t.scan_index = -1,\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)\t\t\\\n\t\t\t\t      | BIT(IIO_CHAN_INFO_SCALE)\t\\\n\t\t\t\t      | BIT(IIO_CHAN_INFO_OFFSET),\t\\\n\t}\n\n#define _AD74115_ADC_CHANNEL(_type, index, extra_mask_separate)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = (_type),\t\t\t\t\t\\\n\t\t.channel = (index),\t\t\t\t\t\\\n\t\t.indexed = 1,\t\t\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)\t\t\\\n\t\t\t\t      | BIT(IIO_CHAN_INFO_SAMP_FREQ)\t\\\n\t\t\t\t      | (extra_mask_separate),\t\t\\\n\t\t.info_mask_separate_available =\t\t\t\t\\\n\t\t\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\\\n\t\t.scan_index = index,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 'u',\t\t\t\t\t\\\n\t\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t\t.storagebits = 32,\t\t\t\t\\\n\t\t\t.shift = 8,\t\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\n#define AD74115_ADC_CHANNEL(_type, index)\t\t\t\t\\\n\t_AD74115_ADC_CHANNEL(_type, index, BIT(IIO_CHAN_INFO_SCALE)\t\\\n\t\t\t\t\t   | BIT(IIO_CHAN_INFO_OFFSET))\n\nstatic struct iio_chan_spec ad74115_voltage_input_channels[] = {\n\tAD74115_ADC_CHANNEL(IIO_VOLTAGE, AD74115_ADC_CH_CONV1),\n\tAD74115_ADC_CHANNEL(IIO_VOLTAGE, AD74115_ADC_CH_CONV2),\n};\n\nstatic struct iio_chan_spec ad74115_voltage_output_channels[] = {\n\tAD74115_DAC_CHANNEL(IIO_VOLTAGE, AD74115_DAC_CH_MAIN),\n\tAD74115_ADC_CHANNEL(IIO_CURRENT, AD74115_ADC_CH_CONV1),\n\tAD74115_ADC_CHANNEL(IIO_VOLTAGE, AD74115_ADC_CH_CONV2),\n};\n\nstatic struct iio_chan_spec ad74115_current_input_channels[] = {\n\tAD74115_ADC_CHANNEL(IIO_CURRENT, AD74115_ADC_CH_CONV1),\n\tAD74115_ADC_CHANNEL(IIO_VOLTAGE, AD74115_ADC_CH_CONV2),\n};\n\nstatic struct iio_chan_spec ad74115_current_output_channels[] = {\n\tAD74115_DAC_CHANNEL(IIO_CURRENT, AD74115_DAC_CH_MAIN),\n\tAD74115_ADC_CHANNEL(IIO_VOLTAGE, AD74115_ADC_CH_CONV1),\n\tAD74115_ADC_CHANNEL(IIO_VOLTAGE, AD74115_ADC_CH_CONV2),\n};\n\nstatic struct iio_chan_spec ad74115_2_wire_resistance_input_channels[] = {\n\t_AD74115_ADC_CHANNEL(IIO_RESISTANCE, AD74115_ADC_CH_CONV1,\n\t\t\t     BIT(IIO_CHAN_INFO_PROCESSED)),\n\tAD74115_ADC_CHANNEL(IIO_VOLTAGE, AD74115_ADC_CH_CONV2),\n};\n\nstatic struct iio_chan_spec ad74115_3_4_wire_resistance_input_channels[] = {\n\tAD74115_ADC_CHANNEL(IIO_RESISTANCE, AD74115_ADC_CH_CONV1),\n\tAD74115_ADC_CHANNEL(IIO_VOLTAGE, AD74115_ADC_CH_CONV2),\n};\n\nstatic struct iio_chan_spec ad74115_digital_input_logic_channels[] = {\n\tAD74115_DAC_CHANNEL(IIO_VOLTAGE, AD74115_DAC_CH_COMPARATOR),\n\tAD74115_ADC_CHANNEL(IIO_VOLTAGE, AD74115_ADC_CH_CONV1),\n\tAD74115_ADC_CHANNEL(IIO_VOLTAGE, AD74115_ADC_CH_CONV2),\n};\n\nstatic struct iio_chan_spec ad74115_digital_input_loop_channels[] = {\n\tAD74115_DAC_CHANNEL(IIO_CURRENT, AD74115_DAC_CH_MAIN),\n\tAD74115_DAC_CHANNEL(IIO_VOLTAGE, AD74115_DAC_CH_COMPARATOR),\n\tAD74115_ADC_CHANNEL(IIO_VOLTAGE, AD74115_ADC_CH_CONV1),\n\tAD74115_ADC_CHANNEL(IIO_VOLTAGE, AD74115_ADC_CH_CONV2),\n};\n\n#define _AD74115_CHANNELS(_channels)\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.channels = _channels,\t\t\t\\\n\t\t.num_channels = ARRAY_SIZE(_channels),\t\\\n\t}\n\n#define AD74115_CHANNELS(name) \\\n\t_AD74115_CHANNELS(ad74115_ ## name ## _channels)\n\nstatic const struct ad74115_channels ad74115_channels_map[AD74115_CH_FUNC_NUM] = {\n\t[AD74115_CH_FUNC_HIGH_IMPEDANCE] = AD74115_CHANNELS(voltage_input),\n\t[AD74115_CH_FUNC_VOLTAGE_INPUT] = AD74115_CHANNELS(voltage_input),\n\n\t[AD74115_CH_FUNC_VOLTAGE_OUTPUT] = AD74115_CHANNELS(voltage_output),\n\n\t[AD74115_CH_FUNC_CURRENT_INPUT_EXT_POWER] = AD74115_CHANNELS(current_input),\n\t[AD74115_CH_FUNC_CURRENT_INPUT_LOOP_POWER] = AD74115_CHANNELS(current_input),\n\t[AD74115_CH_FUNC_CURRENT_INPUT_EXT_POWER_HART] = AD74115_CHANNELS(current_input),\n\t[AD74115_CH_FUNC_CURRENT_INPUT_LOOP_POWER_HART] = AD74115_CHANNELS(current_input),\n\n\t[AD74115_CH_FUNC_CURRENT_OUTPUT] = AD74115_CHANNELS(current_output),\n\t[AD74115_CH_FUNC_CURRENT_OUTPUT_HART] = AD74115_CHANNELS(current_output),\n\n\t[AD74115_CH_FUNC_2_WIRE_RESISTANCE_INPUT] = AD74115_CHANNELS(2_wire_resistance_input),\n\t[AD74115_CH_FUNC_3_4_WIRE_RESISTANCE_INPUT] = AD74115_CHANNELS(3_4_wire_resistance_input),\n\n\t[AD74115_CH_FUNC_DIGITAL_INPUT_LOGIC] = AD74115_CHANNELS(digital_input_logic),\n\n\t[AD74115_CH_FUNC_DIGITAL_INPUT_LOOP_POWER] = AD74115_CHANNELS(digital_input_loop),\n};\n\n#define AD74115_GPIO_MODE_FW_PROP(i)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.name = \"adi,gpio\" __stringify(i) \"-mode\",\t\t\t\\\n\t.reg = AD74115_GPIO_CONFIG_X_REG(i),\t\t\t\t\\\n\t.mask = AD74115_GPIO_CONFIG_SELECT_MASK,\t\t\t\\\n\t.lookup_tbl = ad74115_gpio_mode_tbl,\t\t\t\t\\\n\t.lookup_tbl_len = ARRAY_SIZE(ad74115_gpio_mode_tbl),\t\t\\\n}\n\nstatic const struct ad74115_fw_prop ad74115_gpio_mode_fw_props[] = {\n\tAD74115_GPIO_MODE_FW_PROP(0),\n\tAD74115_GPIO_MODE_FW_PROP(1),\n\tAD74115_GPIO_MODE_FW_PROP(2),\n\tAD74115_GPIO_MODE_FW_PROP(3),\n};\n\nstatic const struct ad74115_fw_prop ad74115_din_threshold_mode_fw_prop =\n\tAD74115_FW_PROP_BOOL(\"adi,digital-input-threshold-mode-fixed\",\n\t\t\t     AD74115_DIN_CONFIG2_REG, BIT(7));\n\nstatic const struct ad74115_fw_prop ad74115_dac_bipolar_fw_prop =\n\tAD74115_FW_PROP_BOOL(\"adi,dac-bipolar\", AD74115_OUTPUT_CONFIG_REG, BIT(7));\n\nstatic const struct ad74115_fw_prop ad74115_ch_func_fw_prop =\n\tAD74115_FW_PROP(\"adi,ch-func\", AD74115_CH_FUNC_MAX,\n\t\t\tAD74115_CH_FUNC_SETUP_REG, GENMASK(3, 0));\n\nstatic const struct ad74115_fw_prop ad74115_rtd_mode_fw_prop =\n\tAD74115_FW_PROP_BOOL(\"adi,4-wire-rtd\", AD74115_RTD3W4W_CONFIG_REG, BIT(3));\n\nstatic const struct ad74115_fw_prop ad74115_din_range_fw_prop =\n\tAD74115_FW_PROP_BOOL(\"adi,digital-input-sink-range-high\",\n\t\t\t     AD74115_DIN_CONFIG1_REG, BIT(12));\n\nstatic const struct ad74115_fw_prop ad74115_ext2_burnout_current_fw_prop =\n\tAD74115_FW_PROP_TBL(\"adi,ext2-burnout-current-nanoamp\",\n\t\t\t    ad74115_burnout_current_na_tbl,\n\t\t\t    AD74115_BURNOUT_CONFIG_REG, GENMASK(14, 12));\n\nstatic const struct ad74115_fw_prop ad74115_ext1_burnout_current_fw_prop =\n\tAD74115_FW_PROP_TBL(\"adi,ext1-burnout-current-nanoamp\",\n\t\t\t    ad74115_burnout_current_na_tbl,\n\t\t\t    AD74115_BURNOUT_CONFIG_REG, GENMASK(9, 7));\n\nstatic const struct ad74115_fw_prop ad74115_viout_burnout_current_fw_prop =\n\tAD74115_FW_PROP_TBL(\"adi,viout-burnout-current-nanoamp\",\n\t\t\t    ad74115_viout_burnout_current_na_tbl,\n\t\t\t    AD74115_BURNOUT_CONFIG_REG, GENMASK(4, 2));\n\nstatic const struct ad74115_fw_prop ad74115_fw_props[] = {\n\tAD74115_FW_PROP(\"adi,conv2-mux\", 3,\n\t\t\tAD74115_ADC_CONFIG_REG, GENMASK(3, 2)),\n\n\tAD74115_FW_PROP_BOOL_NEG(\"adi,sense-agnd-buffer-low-power\",\n\t\t\t\t AD74115_PWR_OPTIM_CONFIG_REG, BIT(4)),\n\tAD74115_FW_PROP_BOOL_NEG(\"adi,lf-buffer-low-power\",\n\t\t\t\t AD74115_PWR_OPTIM_CONFIG_REG, BIT(3)),\n\tAD74115_FW_PROP_BOOL_NEG(\"adi,hf-buffer-low-power\",\n\t\t\t\t AD74115_PWR_OPTIM_CONFIG_REG, BIT(2)),\n\tAD74115_FW_PROP_BOOL_NEG(\"adi,ext2-buffer-low-power\",\n\t\t\t\t AD74115_PWR_OPTIM_CONFIG_REG, BIT(1)),\n\tAD74115_FW_PROP_BOOL_NEG(\"adi,ext1-buffer-low-power\",\n\t\t\t\t AD74115_PWR_OPTIM_CONFIG_REG, BIT(0)),\n\n\tAD74115_FW_PROP_BOOL(\"adi,comparator-invert\",\n\t\t\t     AD74115_DIN_CONFIG1_REG, BIT(14)),\n\tAD74115_FW_PROP_BOOL(\"adi,digital-input-debounce-mode-counter-reset\",\n\t\t\t     AD74115_DIN_CONFIG1_REG, BIT(6)),\n\n\tAD74115_FW_PROP_BOOL(\"adi,digital-input-unbuffered\",\n\t\t\t     AD74115_DIN_CONFIG2_REG, BIT(10)),\n\tAD74115_FW_PROP_BOOL(\"adi,digital-input-short-circuit-detection\",\n\t\t\t     AD74115_DIN_CONFIG2_REG, BIT(9)),\n\tAD74115_FW_PROP_BOOL(\"adi,digital-input-open-circuit-detection\",\n\t\t\t     AD74115_DIN_CONFIG2_REG, BIT(8)),\n\n\tAD74115_FW_PROP_BOOL(\"adi,dac-current-limit-low\",\n\t\t\t     AD74115_OUTPUT_CONFIG_REG, BIT(0)),\n\n\tAD74115_FW_PROP_BOOL(\"adi,3-wire-rtd-excitation-swap\",\n\t\t\t     AD74115_RTD3W4W_CONFIG_REG, BIT(2)),\n\tAD74115_FW_PROP_TBL(\"adi,rtd-excitation-current-microamp\",\n\t\t\t    ad74115_rtd_excitation_current_ua_tbl,\n\t\t\t    AD74115_RTD3W4W_CONFIG_REG, GENMASK(1, 0)),\n\n\tAD74115_FW_PROP_BOOL(\"adi,ext2-burnout-current-polarity-sourcing\",\n\t\t\t     AD74115_BURNOUT_CONFIG_REG, BIT(11)),\n\tAD74115_FW_PROP_BOOL(\"adi,ext1-burnout-current-polarity-sourcing\",\n\t\t\t     AD74115_BURNOUT_CONFIG_REG, BIT(6)),\n\tAD74115_FW_PROP_BOOL(\"adi,viout-burnout-current-polarity-sourcing\",\n\t\t\t     AD74115_BURNOUT_CONFIG_REG, BIT(1)),\n\n\tAD74115_FW_PROP_BOOL(\"adi,charge-pump\",\n\t\t\t     AD74115_CHARGE_PUMP_REG, BIT(0)),\n};\n\nstatic int ad74115_apply_fw_prop(struct ad74115_state *st,\n\t\t\t\t const struct ad74115_fw_prop *prop, u32 *retval)\n{\n\tstruct device *dev = &st->spi->dev;\n\tu32 val = 0;\n\tint ret;\n\n\tif (prop->is_boolean) {\n\t\tval = device_property_read_bool(dev, prop->name);\n\t} else {\n\t\tret = device_property_read_u32(dev, prop->name, &val);\n\t\tif (ret && prop->lookup_tbl)\n\t\t\tval = prop->lookup_tbl[0];\n\t}\n\n\t*retval = val;\n\n\tif (prop->negate)\n\t\tval = !val;\n\n\tif (prop->lookup_tbl)\n\t\tret = _ad74115_find_tbl_index(prop->lookup_tbl,\n\t\t\t\t\t      prop->lookup_tbl_len, val, &val);\n\telse if (prop->max && val > prop->max)\n\t\tret = -EINVAL;\n\telse\n\t\tret = 0;\n\n\tif (ret)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Invalid value %u for prop %s\\n\",\n\t\t\t\t     val, prop->name);\n\n\tWARN(!prop->mask, \"Prop %s mask is empty\\n\", prop->name);\n\n\tval = (val << __ffs(prop->mask)) & prop->mask;\n\n\treturn regmap_update_bits(st->regmap, prop->reg, prop->mask, val);\n}\n\nstatic int ad74115_setup_adc_conv2_range(struct ad74115_state *st)\n{\n\tunsigned int tbl_len = ARRAY_SIZE(ad74115_adc_range_tbl);\n\tconst char *prop_name = \"adi,conv2-range-microvolt\";\n\ts32 vals[2] = {\n\t\tad74115_adc_range_tbl[0][0],\n\t\tad74115_adc_range_tbl[0][1],\n\t};\n\tstruct device *dev = &st->spi->dev;\n\tunsigned int i;\n\n\tdevice_property_read_u32_array(dev, prop_name, vals, 2);\n\n\tfor (i = 0; i < tbl_len; i++)\n\t\tif (vals[0] == ad74115_adc_range_tbl[i][0] &&\n\t\t    vals[1] == ad74115_adc_range_tbl[i][1])\n\t\t\tbreak;\n\n\tif (i == tbl_len)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Invalid value %d, %d for prop %s\\n\",\n\t\t\t\t     vals[0], vals[1], prop_name);\n\n\treturn regmap_update_bits(st->regmap, AD74115_ADC_CONFIG_REG,\n\t\t\t\t  AD74115_ADC_CONFIG_CONV2_RANGE_MASK,\n\t\t\t\t  FIELD_PREP(AD74115_ADC_CONFIG_CONV2_RANGE_MASK, i));\n}\n\nstatic int ad74115_setup_iio_channels(struct iio_dev *indio_dev)\n{\n\tstruct ad74115_state *st = iio_priv(indio_dev);\n\tstruct device *dev = &st->spi->dev;\n\tstruct iio_chan_spec *channels;\n\n\tchannels = devm_kcalloc(dev, sizeof(*channels),\n\t\t\t\tindio_dev->num_channels, GFP_KERNEL);\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\tindio_dev->channels = channels;\n\n\tmemcpy(channels, ad74115_channels_map[st->ch_func].channels,\n\t       sizeof(*channels) * ad74115_channels_map[st->ch_func].num_channels);\n\n\tif (channels[0].output && channels[0].channel == AD74115_DAC_CH_MAIN &&\n\t    channels[0].type == IIO_VOLTAGE && !st->dac_hart_slew) {\n\t\tchannels[0].info_mask_separate |= BIT(IIO_CHAN_INFO_SAMP_FREQ);\n\t\tchannels[0].info_mask_separate_available |= BIT(IIO_CHAN_INFO_SAMP_FREQ);\n\t}\n\n\treturn 0;\n}\n\nstatic int ad74115_setup_gpio_chip(struct ad74115_state *st)\n{\n\tstruct device *dev = &st->spi->dev;\n\n\tif (!st->gpio_valid_mask)\n\t\treturn 0;\n\n\tst->gc = (struct gpio_chip) {\n\t\t.owner = THIS_MODULE,\n\t\t.label = AD74115_NAME,\n\t\t.base = -1,\n\t\t.ngpio = AD74115_GPIO_NUM,\n\t\t.parent = dev,\n\t\t.can_sleep = true,\n\t\t.init_valid_mask = ad74115_gpio_init_valid_mask,\n\t\t.get_direction = ad74115_gpio_get_direction,\n\t\t.direction_input = ad74115_gpio_direction_input,\n\t\t.direction_output = ad74115_gpio_direction_output,\n\t\t.get = ad74115_gpio_get,\n\t\t.set = ad74115_gpio_set,\n\t};\n\n\treturn devm_gpiochip_add_data(dev, &st->gc, st);\n}\n\nstatic int ad74115_setup_comp_gpio_chip(struct ad74115_state *st)\n{\n\tstruct device *dev = &st->spi->dev;\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(st->regmap, AD74115_DIN_CONFIG1_REG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(val & AD74115_DIN_COMPARATOR_EN_MASK))\n\t\treturn 0;\n\n\tst->comp_gc = (struct gpio_chip) {\n\t\t.owner = THIS_MODULE,\n\t\t.label = AD74115_NAME,\n\t\t.base = -1,\n\t\t.ngpio = 1,\n\t\t.parent = dev,\n\t\t.can_sleep = true,\n\t\t.get_direction = ad74115_comp_gpio_get_direction,\n\t\t.get = ad74115_comp_gpio_get,\n\t\t.set_config = ad74115_comp_gpio_set_config,\n\t};\n\n\treturn devm_gpiochip_add_data(dev, &st->comp_gc, st);\n}\n\nstatic int ad74115_setup(struct iio_dev *indio_dev)\n{\n\tstruct ad74115_state *st = iio_priv(indio_dev);\n\tstruct device *dev = &st->spi->dev;\n\tu32 val, din_range_high;\n\tunsigned int i;\n\tint ret;\n\n\tret = ad74115_apply_fw_prop(st, &ad74115_ch_func_fw_prop, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->num_channels += ad74115_channels_map[val].num_channels;\n\tst->ch_func = val;\n\n\tret = ad74115_setup_adc_conv2_range(st);\n\tif (ret)\n\t\treturn ret;\n\n\tval = device_property_read_bool(dev, \"adi,dac-hart-slew\");\n\tif (val) {\n\t\tst->dac_hart_slew = val;\n\n\t\tret = regmap_update_bits(st->regmap, AD74115_OUTPUT_CONFIG_REG,\n\t\t\t\t\t AD74115_OUTPUT_SLEW_EN_MASK,\n\t\t\t\t\t FIELD_PREP(AD74115_OUTPUT_SLEW_EN_MASK,\n\t\t\t\t\t\t    AD74115_SLEW_MODE_HART));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ad74115_apply_fw_prop(st, &ad74115_din_range_fw_prop,\n\t\t\t\t    &din_range_high);\n\tif (ret)\n\t\treturn ret;\n\n\tret = device_property_read_u32(dev, \"adi,digital-input-sink-microamp\", &val);\n\tif (!ret) {\n\t\tif (din_range_high)\n\t\t\tval = DIV_ROUND_CLOSEST(val, AD74115_DIN_SINK_LOW_STEP);\n\t\telse\n\t\t\tval = DIV_ROUND_CLOSEST(val, AD74115_DIN_SINK_HIGH_STEP);\n\n\t\tif (val > AD74115_DIN_SINK_MAX)\n\t\t\tval = AD74115_DIN_SINK_MAX;\n\n\t\tret = regmap_update_bits(st->regmap, AD74115_DIN_CONFIG1_REG,\n\t\t\t\t\t AD74115_DIN_SINK_MASK,\n\t\t\t\t\t FIELD_PREP(AD74115_DIN_SINK_MASK, val));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ad74115_apply_fw_prop(st, &ad74115_din_threshold_mode_fw_prop, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val == AD74115_DIN_THRESHOLD_MODE_AVDD) {\n\t\tret = regulator_get_voltage(st->avdd);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tst->avdd_mv = ret / 1000;\n\t}\n\n\tst->din_threshold_mode = val;\n\n\tret = ad74115_apply_fw_prop(st, &ad74115_dac_bipolar_fw_prop, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tst->dac_bipolar = val;\n\n\tret = ad74115_apply_fw_prop(st, &ad74115_rtd_mode_fw_prop, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tst->rtd_mode_4_wire = val;\n\n\tret = ad74115_apply_fw_prop(st, &ad74115_ext2_burnout_current_fw_prop, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val) {\n\t\tret = regmap_update_bits(st->regmap, AD74115_BURNOUT_CONFIG_REG,\n\t\t\t\t\t AD74115_BURNOUT_EXT2_EN_MASK,\n\t\t\t\t\t FIELD_PREP(AD74115_BURNOUT_EXT2_EN_MASK, 1));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ad74115_apply_fw_prop(st, &ad74115_ext1_burnout_current_fw_prop, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val) {\n\t\tret = regmap_update_bits(st->regmap, AD74115_BURNOUT_CONFIG_REG,\n\t\t\t\t\t AD74115_BURNOUT_EXT1_EN_MASK,\n\t\t\t\t\t FIELD_PREP(AD74115_BURNOUT_EXT1_EN_MASK, 1));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ad74115_apply_fw_prop(st, &ad74115_viout_burnout_current_fw_prop, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val) {\n\t\tret = regmap_update_bits(st->regmap, AD74115_BURNOUT_CONFIG_REG,\n\t\t\t\t\t AD74115_BURNOUT_VIOUT_EN_MASK,\n\t\t\t\t\t FIELD_PREP(AD74115_BURNOUT_VIOUT_EN_MASK, 1));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < AD74115_GPIO_NUM; i++) {\n\t\tret = ad74115_apply_fw_prop(st, &ad74115_gpio_mode_fw_props[i], &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (val == AD74115_GPIO_MODE_LOGIC)\n\t\t\tst->gpio_valid_mask |= BIT(i);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ad74115_fw_props); i++) {\n\t\tret = ad74115_apply_fw_prop(st, &ad74115_fw_props[i], &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ad74115_setup_gpio_chip(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74115_setup_comp_gpio_chip(st);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ad74115_setup_iio_channels(indio_dev);\n}\n\nstatic int ad74115_reset(struct ad74115_state *st)\n{\n\tstruct device *dev = &st->spi->dev;\n\tstruct gpio_desc *reset_gpio;\n\tint ret;\n\n\treset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(reset_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(reset_gpio),\n\t\t\t\t     \"Failed to find reset GPIO\\n\");\n\n\tif (reset_gpio) {\n\t\tfsleep(100);\n\n\t\tgpiod_set_value_cansleep(reset_gpio, 0);\n\t} else {\n\t\tret = regmap_write(st->regmap, AD74115_CMD_KEY_REG,\n\t\t\t\t   AD74115_CMD_KEY_RESET1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(st->regmap, AD74115_CMD_KEY_REG,\n\t\t\t\t   AD74115_CMD_KEY_RESET2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfsleep(1000);\n\n\treturn 0;\n}\n\nstatic void ad74115_regulator_disable(void *data)\n{\n\tregulator_disable(data);\n}\n\nstatic int ad74115_setup_trigger(struct iio_dev *indio_dev)\n{\n\tstruct ad74115_state *st = iio_priv(indio_dev);\n\tstruct device *dev = &st->spi->dev;\n\tint ret;\n\n\tst->irq = fwnode_irq_get_byname(dev_fwnode(dev), \"adc_rdy\");\n\n\tif (st->irq == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tif (st->irq < 0) {\n\t\tst->irq = 0;\n\t\treturn 0;\n\t}\n\n\tret = devm_request_irq(dev, st->irq, ad74115_adc_data_interrupt,\n\t\t\t       0, AD74115_NAME, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tst->trig = devm_iio_trigger_alloc(dev, \"%s-dev%d\", AD74115_NAME,\n\t\t\t\t\t  iio_device_id(indio_dev));\n\tif (!st->trig)\n\t\treturn -ENOMEM;\n\n\tst->trig->ops = &ad74115_trigger_ops;\n\tiio_trigger_set_drvdata(st->trig, st);\n\n\tret = devm_iio_trigger_register(dev, st->trig);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->trig = iio_trigger_get(st->trig);\n\n\treturn 0;\n}\n\nstatic int ad74115_probe(struct spi_device *spi)\n{\n\tstatic const char * const regulator_names[] = {\n\t\t\"avcc\", \"dvcc\", \"dovdd\", \"refin\",\n\t};\n\tstruct device *dev = &spi->dev;\n\tstruct ad74115_state *st;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->spi = spi;\n\tmutex_init(&st->lock);\n\tinit_completion(&st->adc_data_completion);\n\n\tindio_dev->name = AD74115_NAME;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &ad74115_info;\n\n\tst->avdd = devm_regulator_get(dev, \"avdd\");\n\tif (IS_ERR(st->avdd))\n\t\treturn PTR_ERR(st->avdd);\n\n\tret = regulator_enable(st->avdd);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable avdd regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev, ad74115_regulator_disable, st->avdd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_regulator_bulk_get_enable(dev, ARRAY_SIZE(regulator_names),\n\t\t\t\t\t     regulator_names);\n\tif (ret)\n\t\treturn ret;\n\n\tst->regmap = devm_regmap_init(dev, NULL, st, &ad74115_regmap_config);\n\tif (IS_ERR(st->regmap))\n\t\treturn PTR_ERR(st->regmap);\n\n\tret = ad74115_reset(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74115_setup(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad74115_setup_trigger(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,\n\t\t\t\t\t      ad74115_trigger_handler,\n\t\t\t\t\t      &ad74115_buffer_ops);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic int ad74115_unregister_driver(struct spi_driver *spi)\n{\n\tspi_unregister_driver(spi);\n\n\treturn 0;\n}\n\nstatic int __init ad74115_register_driver(struct spi_driver *spi)\n{\n\tcrc8_populate_msb(ad74115_crc8_table, AD74115_CRC_POLYNOMIAL);\n\n\treturn spi_register_driver(spi);\n}\n\nstatic const struct spi_device_id ad74115_spi_id[] = {\n\t{ \"ad74115h\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(spi, ad74115_spi_id);\n\nstatic const struct of_device_id ad74115_dt_id[] = {\n\t{ .compatible = \"adi,ad74115h\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ad74115_dt_id);\n\nstatic struct spi_driver ad74115_driver = {\n\t.driver = {\n\t\t   .name = \"ad74115\",\n\t\t   .of_match_table = ad74115_dt_id,\n\t},\n\t.probe = ad74115_probe,\n\t.id_table = ad74115_spi_id,\n};\n\nmodule_driver(ad74115_driver,\n\t      ad74115_register_driver, ad74115_unregister_driver);\n\nMODULE_AUTHOR(\"Cosmin Tanislav <cosmin.tanislav@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices AD74115 ADDAC\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}