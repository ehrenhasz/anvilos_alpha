{
  "module_name": "adxrs290.c",
  "hash_id": "4742bab5ac792f0e7f3bd7a7750553bb258970dc1afa100a6d4dd5313d998661",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/gyro/adxrs290.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#define ADXRS290_ADI_ID\t\t0xAD\n#define ADXRS290_MEMS_ID\t0x1D\n#define ADXRS290_DEV_ID\t\t0x92\n\n#define ADXRS290_REG_ADI_ID\t0x00\n#define ADXRS290_REG_MEMS_ID\t0x01\n#define ADXRS290_REG_DEV_ID\t0x02\n#define ADXRS290_REG_REV_ID\t0x03\n#define ADXRS290_REG_SN0\t0x04  \n#define ADXRS290_REG_DATAX0\t0x08  \n#define ADXRS290_REG_DATAY0\t0x0A  \n#define ADXRS290_REG_TEMP0\t0x0C\n#define ADXRS290_REG_POWER_CTL\t0x10\n#define ADXRS290_REG_FILTER\t0x11\n#define ADXRS290_REG_DATA_RDY\t0x12\n\n#define ADXRS290_READ\t\tBIT(7)\n#define ADXRS290_TSM\t\tBIT(0)\n#define ADXRS290_MEASUREMENT\tBIT(1)\n#define ADXRS290_DATA_RDY_OUT\tBIT(0)\n#define ADXRS290_SYNC_MASK\tGENMASK(1, 0)\n#define ADXRS290_SYNC(x)\tFIELD_PREP(ADXRS290_SYNC_MASK, x)\n#define ADXRS290_LPF_MASK\tGENMASK(2, 0)\n#define ADXRS290_LPF(x)\t\tFIELD_PREP(ADXRS290_LPF_MASK, x)\n#define ADXRS290_HPF_MASK\tGENMASK(7, 4)\n#define ADXRS290_HPF(x)\t\tFIELD_PREP(ADXRS290_HPF_MASK, x)\n\n#define ADXRS290_READ_REG(reg)\t(ADXRS290_READ | (reg))\n\n#define ADXRS290_MAX_TRANSITION_TIME_MS 100\n\nenum adxrs290_mode {\n\tADXRS290_MODE_STANDBY,\n\tADXRS290_MODE_MEASUREMENT,\n};\n\nenum adxrs290_scan_index {\n\tADXRS290_IDX_X,\n\tADXRS290_IDX_Y,\n\tADXRS290_IDX_TEMP,\n\tADXRS290_IDX_TS,\n};\n\nstruct adxrs290_state {\n\tstruct spi_device\t*spi;\n\t \n\tstruct mutex\t\tlock;\n\tenum adxrs290_mode\tmode;\n\tunsigned int\t\tlpf_3db_freq_idx;\n\tunsigned int\t\thpf_3db_freq_idx;\n\tstruct iio_trigger      *dready_trig;\n\t \n\tstruct {\n\t\ts16 channels[3];\n\t\ts64 ts __aligned(8);\n\t} buffer;\n};\n\n \nstatic const int adxrs290_lpf_3db_freq_hz_table[][2] = {\n\t[0] = {480, 0},\n\t[1] = {320, 0},\n\t[2] = {160, 0},\n\t[3] = {80, 0},\n\t[4] = {56, 600000},\n\t[5] = {40, 0},\n\t[6] = {28, 300000},\n\t[7] = {20, 0},\n};\n\n \nstatic const int adxrs290_hpf_3db_freq_hz_table[][2] = {\n\t[0] = {0, 0},\n\t[1] = {0, 11000},\n\t[2] = {0, 22000},\n\t[3] = {0, 44000},\n\t[4] = {0, 87000},\n\t[5] = {0, 175000},\n\t[6] = {0, 350000},\n\t[7] = {0, 700000},\n\t[8] = {1, 400000},\n\t[9] = {2, 800000},\n\t[10] = {11, 300000},\n};\n\nstatic int adxrs290_get_rate_data(struct iio_dev *indio_dev, const u8 cmd, int *val)\n{\n\tstruct adxrs290_state *st = iio_priv(indio_dev);\n\tint ret = 0;\n\tint temp;\n\n\tmutex_lock(&st->lock);\n\ttemp = spi_w8r16(st->spi, cmd);\n\tif (temp < 0) {\n\t\tret = temp;\n\t\tgoto err_unlock;\n\t}\n\n\t*val = sign_extend32(temp, 15);\n\nerr_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic int adxrs290_get_temp_data(struct iio_dev *indio_dev, int *val)\n{\n\tconst u8 cmd = ADXRS290_READ_REG(ADXRS290_REG_TEMP0);\n\tstruct adxrs290_state *st = iio_priv(indio_dev);\n\tint ret = 0;\n\tint temp;\n\n\tmutex_lock(&st->lock);\n\ttemp = spi_w8r16(st->spi, cmd);\n\tif (temp < 0) {\n\t\tret = temp;\n\t\tgoto err_unlock;\n\t}\n\n\t \n\t*val = sign_extend32(temp, 11);\n\nerr_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic int adxrs290_get_3db_freq(struct iio_dev *indio_dev, u8 *val, u8 *val2)\n{\n\tconst u8 cmd = ADXRS290_READ_REG(ADXRS290_REG_FILTER);\n\tstruct adxrs290_state *st = iio_priv(indio_dev);\n\tint ret = 0;\n\tshort temp;\n\n\tmutex_lock(&st->lock);\n\ttemp = spi_w8r8(st->spi, cmd);\n\tif (temp < 0) {\n\t\tret = temp;\n\t\tgoto err_unlock;\n\t}\n\n\t*val = FIELD_GET(ADXRS290_LPF_MASK, temp);\n\t*val2 = FIELD_GET(ADXRS290_HPF_MASK, temp);\n\nerr_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic int adxrs290_spi_write_reg(struct spi_device *spi, const u8 reg,\n\t\t\t\t  const u8 val)\n{\n\tu8 buf[2];\n\n\tbuf[0] = reg;\n\tbuf[1] = val;\n\n\treturn spi_write_then_read(spi, buf, ARRAY_SIZE(buf), NULL, 0);\n}\n\nstatic int adxrs290_find_match(const int (*freq_tbl)[2], const int n,\n\t\t\t       const int val, const int val2)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (freq_tbl[i][0] == val && freq_tbl[i][1] == val2)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int adxrs290_set_filter_freq(struct iio_dev *indio_dev,\n\t\t\t\t    const unsigned int lpf_idx,\n\t\t\t\t    const unsigned int hpf_idx)\n{\n\tstruct adxrs290_state *st = iio_priv(indio_dev);\n\tu8 val;\n\n\tval = ADXRS290_HPF(hpf_idx) | ADXRS290_LPF(lpf_idx);\n\n\treturn adxrs290_spi_write_reg(st->spi, ADXRS290_REG_FILTER, val);\n}\n\nstatic int adxrs290_set_mode(struct iio_dev *indio_dev, enum adxrs290_mode mode)\n{\n\tstruct adxrs290_state *st = iio_priv(indio_dev);\n\tint val, ret;\n\n\tif (st->mode == mode)\n\t\treturn 0;\n\n\tmutex_lock(&st->lock);\n\n\tret = spi_w8r8(st->spi, ADXRS290_READ_REG(ADXRS290_REG_POWER_CTL));\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tval = ret;\n\n\tswitch (mode) {\n\tcase ADXRS290_MODE_STANDBY:\n\t\tval &= ~ADXRS290_MEASUREMENT;\n\t\tbreak;\n\tcase ADXRS290_MODE_MEASUREMENT:\n\t\tval |= ADXRS290_MEASUREMENT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = adxrs290_spi_write_reg(st->spi, ADXRS290_REG_POWER_CTL, val);\n\tif (ret < 0) {\n\t\tdev_err(&st->spi->dev, \"unable to set mode: %d\\n\", ret);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tst->mode = mode;\n\nout_unlock:\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\nstatic void adxrs290_chip_off_action(void *data)\n{\n\tstruct iio_dev *indio_dev = data;\n\n\tadxrs290_set_mode(indio_dev, ADXRS290_MODE_STANDBY);\n}\n\nstatic int adxrs290_initial_setup(struct iio_dev *indio_dev)\n{\n\tstruct adxrs290_state *st = iio_priv(indio_dev);\n\tstruct spi_device *spi = st->spi;\n\tint ret;\n\n\tret = adxrs290_spi_write_reg(spi, ADXRS290_REG_POWER_CTL,\n\t\t\t\t     ADXRS290_MEASUREMENT | ADXRS290_TSM);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->mode = ADXRS290_MODE_MEASUREMENT;\n\n\treturn devm_add_action_or_reset(&spi->dev, adxrs290_chip_off_action,\n\t\t\t\t\tindio_dev);\n}\n\nstatic int adxrs290_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val,\n\t\t\t     int *val2,\n\t\t\t     long mask)\n{\n\tstruct adxrs290_state *st = iio_priv(indio_dev);\n\tunsigned int t;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\tret = adxrs290_get_rate_data(indio_dev,\n\t\t\t\t\t\t     ADXRS290_READ_REG(chan->address),\n\t\t\t\t\t\t     val);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_TEMP:\n\t\t\tret = adxrs290_get_temp_data(indio_dev, val);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\t \n\t\t\t*val = 0;\n\t\t\t*val2 = 87266;\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = 100;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\tt = st->lpf_3db_freq_idx;\n\t\t\t*val = adxrs290_lpf_3db_freq_hz_table[t][0];\n\t\t\t*val2 = adxrs290_lpf_3db_freq_hz_table[t][1];\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\tt = st->hpf_3db_freq_idx;\n\t\t\t*val = adxrs290_hpf_3db_freq_hz_table[t][0];\n\t\t\t*val2 = adxrs290_hpf_3db_freq_hz_table[t][1];\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int adxrs290_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val,\n\t\t\t      int val2,\n\t\t\t      long mask)\n{\n\tstruct adxrs290_state *st = iio_priv(indio_dev);\n\tint ret, lpf_idx, hpf_idx;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tlpf_idx = adxrs290_find_match(adxrs290_lpf_3db_freq_hz_table,\n\t\t\t\t\t      ARRAY_SIZE(adxrs290_lpf_3db_freq_hz_table),\n\t\t\t\t\t      val, val2);\n\t\tif (lpf_idx < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tst->lpf_3db_freq_idx = lpf_idx;\n\t\t \n\t\thpf_idx = st->hpf_3db_freq_idx;\n\t\tret = adxrs290_set_filter_freq(indio_dev, lpf_idx, hpf_idx);\n\t\tbreak;\n\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\thpf_idx = adxrs290_find_match(adxrs290_hpf_3db_freq_hz_table,\n\t\t\t\t\t      ARRAY_SIZE(adxrs290_hpf_3db_freq_hz_table),\n\t\t\t\t\t      val, val2);\n\t\tif (hpf_idx < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tst->hpf_3db_freq_idx = hpf_idx;\n\t\t \n\t\tlpf_idx = st->lpf_3db_freq_idx;\n\t\tret = adxrs290_set_filter_freq(indio_dev, lpf_idx, hpf_idx);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tiio_device_release_direct_mode(indio_dev);\n\treturn ret;\n}\n\nstatic int adxrs290_read_avail(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length,\n\t\t\t       long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\t*vals = (const int *)adxrs290_lpf_3db_freq_hz_table;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t \n\t\t*length = ARRAY_SIZE(adxrs290_lpf_3db_freq_hz_table) * 2;\n\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\t*vals = (const int *)adxrs290_hpf_3db_freq_hz_table;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t \n\t\t*length = ARRAY_SIZE(adxrs290_hpf_3db_freq_hz_table) * 2;\n\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adxrs290_reg_access_rw(struct spi_device *spi, unsigned int reg,\n\t\t\t\t  unsigned int *readval)\n{\n\tint ret;\n\n\tret = spi_w8r8(spi, ADXRS290_READ_REG(reg));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*readval = ret;\n\n\treturn 0;\n}\n\nstatic int adxrs290_reg_access(struct iio_dev *indio_dev, unsigned int reg,\n\t\t\t       unsigned int writeval, unsigned int *readval)\n{\n\tstruct adxrs290_state *st = iio_priv(indio_dev);\n\n\tif (readval)\n\t\treturn adxrs290_reg_access_rw(st->spi, reg, readval);\n\telse\n\t\treturn adxrs290_spi_write_reg(st->spi, reg, writeval);\n}\n\nstatic int adxrs290_data_rdy_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t       bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct adxrs290_state *st = iio_priv(indio_dev);\n\tint ret;\n\tu8 val;\n\n\tval = state ? ADXRS290_SYNC(ADXRS290_DATA_RDY_OUT) : 0;\n\n\tret = adxrs290_spi_write_reg(st->spi, ADXRS290_REG_DATA_RDY, val);\n\tif (ret < 0)\n\t\tdev_err(&st->spi->dev, \"failed to start data rdy interrupt\\n\");\n\n\treturn ret;\n}\n\nstatic void adxrs290_reset_trig(struct iio_trigger *trig)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tint val;\n\n\t \n\tadxrs290_get_rate_data(indio_dev,\n\t\t\t       ADXRS290_READ_REG(ADXRS290_REG_DATAY0), &val);\n}\n\nstatic const struct iio_trigger_ops adxrs290_trigger_ops = {\n\t.set_trigger_state = &adxrs290_data_rdy_trigger_set_state,\n\t.validate_device = &iio_trigger_validate_own_device,\n\t.reenable = &adxrs290_reset_trig,\n};\n\nstatic irqreturn_t adxrs290_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct adxrs290_state *st = iio_priv(indio_dev);\n\tu8 tx = ADXRS290_READ_REG(ADXRS290_REG_DATAX0);\n\tint ret;\n\n\tmutex_lock(&st->lock);\n\n\t \n\tret = spi_write_then_read(st->spi, &tx, sizeof(tx), st->buffer.channels,\n\t\t\t\t  sizeof(st->buffer.channels));\n\tif (ret < 0)\n\t\tgoto out_unlock_notify;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &st->buffer,\n\t\t\t\t\t   pf->timestamp);\n\nout_unlock_notify:\n\tmutex_unlock(&st->lock);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\n#define ADXRS290_ANGL_VEL_CHANNEL(reg, axis) {\t\t\t\t\\\n\t.type = IIO_ANGL_VEL,\t\t\t\t\t\t\\\n\t.address = reg,\t\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##axis,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\t\\\n\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY) |\t\t\\\n\tBIT(IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY),\t\t\\\n\t.info_mask_shared_by_type_available =\t\t\t\t\\\n\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY) |\t\t\\\n\tBIT(IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY),\t\t\\\n\t.scan_index = ADXRS290_IDX_##axis,\t\t\t\t\\\n\t.scan_type = {                                                  \\\n\t\t.sign = 's',                                            \\\n\t\t.realbits = 16,                                         \\\n\t\t.storagebits = 16,                                      \\\n\t\t.endianness = IIO_LE,\t\t\t\t\t\\\n\t},                                                              \\\n}\n\nstatic const struct iio_chan_spec adxrs290_channels[] = {\n\tADXRS290_ANGL_VEL_CHANNEL(ADXRS290_REG_DATAX0, X),\n\tADXRS290_ANGL_VEL_CHANNEL(ADXRS290_REG_DATAY0, Y),\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.address = ADXRS290_REG_TEMP0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = ADXRS290_IDX_TEMP,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 12,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_LE,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(ADXRS290_IDX_TS),\n};\n\nstatic const unsigned long adxrs290_avail_scan_masks[] = {\n\tBIT(ADXRS290_IDX_X) | BIT(ADXRS290_IDX_Y) | BIT(ADXRS290_IDX_TEMP),\n\t0\n};\n\nstatic const struct iio_info adxrs290_info = {\n\t.read_raw = &adxrs290_read_raw,\n\t.write_raw = &adxrs290_write_raw,\n\t.read_avail = &adxrs290_read_avail,\n\t.debugfs_reg_access = &adxrs290_reg_access,\n};\n\nstatic int adxrs290_probe_trigger(struct iio_dev *indio_dev)\n{\n\tstruct adxrs290_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tif (!st->spi->irq) {\n\t\tdev_info(&st->spi->dev, \"no irq, using polling\\n\");\n\t\treturn 0;\n\t}\n\n\tst->dready_trig = devm_iio_trigger_alloc(&st->spi->dev, \"%s-dev%d\",\n\t\t\t\t\t\t indio_dev->name,\n\t\t\t\t\t\t iio_device_id(indio_dev));\n\tif (!st->dready_trig)\n\t\treturn -ENOMEM;\n\n\tst->dready_trig->ops = &adxrs290_trigger_ops;\n\tiio_trigger_set_drvdata(st->dready_trig, indio_dev);\n\n\tret = devm_request_irq(&st->spi->dev, st->spi->irq,\n\t\t\t       &iio_trigger_generic_data_rdy_poll,\n\t\t\t       IRQF_ONESHOT, \"adxrs290_irq\", st->dready_trig);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&st->spi->dev, ret,\n\t\t\t\t     \"request irq %d failed\\n\", st->spi->irq);\n\n\tret = devm_iio_trigger_register(&st->spi->dev, st->dready_trig);\n\tif (ret) {\n\t\tdev_err(&st->spi->dev, \"iio trigger register failed\\n\");\n\t\treturn ret;\n\t}\n\n\tindio_dev->trig = iio_trigger_get(st->dready_trig);\n\n\treturn 0;\n}\n\nstatic int adxrs290_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct adxrs290_state *st;\n\tu8 val, val2;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\tst->spi = spi;\n\n\tindio_dev->name = \"adxrs290\";\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = adxrs290_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adxrs290_channels);\n\tindio_dev->info = &adxrs290_info;\n\tindio_dev->available_scan_masks = adxrs290_avail_scan_masks;\n\n\tmutex_init(&st->lock);\n\n\tval = spi_w8r8(spi, ADXRS290_READ_REG(ADXRS290_REG_ADI_ID));\n\tif (val != ADXRS290_ADI_ID) {\n\t\tdev_err(&spi->dev, \"Wrong ADI ID 0x%02x\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tval = spi_w8r8(spi, ADXRS290_READ_REG(ADXRS290_REG_MEMS_ID));\n\tif (val != ADXRS290_MEMS_ID) {\n\t\tdev_err(&spi->dev, \"Wrong MEMS ID 0x%02x\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tval = spi_w8r8(spi, ADXRS290_READ_REG(ADXRS290_REG_DEV_ID));\n\tif (val != ADXRS290_DEV_ID) {\n\t\tdev_err(&spi->dev, \"Wrong DEV ID 0x%02x\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tst->mode = ADXRS290_MODE_STANDBY;\n\n\t \n\tret = adxrs290_initial_setup(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmsleep(ADXRS290_MAX_TRANSITION_TIME_MS);\n\n\tret = adxrs290_get_3db_freq(indio_dev, &val, &val2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->lpf_3db_freq_idx = val;\n\tst->hpf_3db_freq_idx = val2;\n\n\tret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev,\n\t\t\t\t\t      &iio_pollfunc_store_time,\n\t\t\t\t\t      &adxrs290_trigger_handler, NULL);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&spi->dev, ret,\n\t\t\t\t     \"iio triggered buffer setup failed\\n\");\n\n\tret = adxrs290_probe_trigger(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id adxrs290_of_match[] = {\n\t{ .compatible = \"adi,adxrs290\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adxrs290_of_match);\n\nstatic struct spi_driver adxrs290_driver = {\n\t.driver = {\n\t\t.name = \"adxrs290\",\n\t\t.of_match_table = adxrs290_of_match,\n\t},\n\t.probe = adxrs290_probe,\n};\nmodule_spi_driver(adxrs290_driver);\n\nMODULE_AUTHOR(\"Nishant Malpani <nish.malpani25@gmail.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADXRS290 Gyroscope SPI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}