{
  "module_name": "mpu3050-i2c.c",
  "hash_id": "5e47d4272cbaae5e2dd2c8b1d418226aa971a2df33b1104c08468227e31ea2e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/gyro/mpu3050-i2c.c",
  "human_readable_source": "\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/pm_runtime.h>\n\n#include \"mpu3050.h\"\n\nstatic const struct regmap_config mpu3050_i2c_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int mpu3050_i2c_bypass_select(struct i2c_mux_core *mux, u32 chan_id)\n{\n\tstruct mpu3050 *mpu3050 = i2c_mux_priv(mux);\n\n\t \n\tpm_runtime_get_sync(mpu3050->dev);\n\treturn 0;\n}\n\nstatic int mpu3050_i2c_bypass_deselect(struct i2c_mux_core *mux, u32 chan_id)\n{\n\tstruct mpu3050 *mpu3050 = i2c_mux_priv(mux);\n\n\tpm_runtime_mark_last_busy(mpu3050->dev);\n\tpm_runtime_put_autosuspend(mpu3050->dev);\n\treturn 0;\n}\n\nstatic int mpu3050_i2c_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct regmap *regmap;\n\tconst char *name;\n\tstruct mpu3050 *mpu3050;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_I2C_BLOCK))\n\t\treturn -EOPNOTSUPP;\n\n\tif (id)\n\t\tname = id->name;\n\telse\n\t\treturn -ENODEV;\n\n\tregmap = devm_regmap_init_i2c(client, &mpu3050_i2c_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"Failed to register i2c regmap: %pe\\n\",\n\t\t\tregmap);\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tret = mpu3050_common_probe(&client->dev, regmap, client->irq, name);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmpu3050 = iio_priv(dev_get_drvdata(&client->dev));\n\tmpu3050->i2cmux = i2c_mux_alloc(client->adapter, &client->dev,\n\t\t\t\t\t1, 0, I2C_MUX_LOCKED | I2C_MUX_GATE,\n\t\t\t\t\tmpu3050_i2c_bypass_select,\n\t\t\t\t\tmpu3050_i2c_bypass_deselect);\n\t \n\tif (!mpu3050->i2cmux)\n\t\tdev_err(&client->dev, \"failed to allocate I2C mux\\n\");\n\telse {\n\t\tmpu3050->i2cmux->priv = mpu3050;\n\t\t \n\t\ti2c_mux_add_adapter(mpu3050->i2cmux, 0, 0, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic void mpu3050_i2c_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(&client->dev);\n\tstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\n\n\tif (mpu3050->i2cmux)\n\t\ti2c_mux_del_adapters(mpu3050->i2cmux);\n\n\tmpu3050_common_remove(&client->dev);\n}\n\n \nstatic const struct i2c_device_id mpu3050_i2c_id[] = {\n\t{ \"mpu3050\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, mpu3050_i2c_id);\n\nstatic const struct of_device_id mpu3050_i2c_of_match[] = {\n\t{ .compatible = \"invensense,mpu3050\", .data = \"mpu3050\" },\n\t \n\t{ .compatible = \"invn,mpu3050\", .data = \"mpu3050\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mpu3050_i2c_of_match);\n\nstatic struct i2c_driver mpu3050_i2c_driver = {\n\t.probe = mpu3050_i2c_probe,\n\t.remove = mpu3050_i2c_remove,\n\t.id_table = mpu3050_i2c_id,\n\t.driver = {\n\t\t.of_match_table = mpu3050_i2c_of_match,\n\t\t.name = \"mpu3050-i2c\",\n\t\t.pm = pm_ptr(&mpu3050_dev_pm_ops),\n\t},\n};\nmodule_i2c_driver(mpu3050_i2c_driver);\n\nMODULE_AUTHOR(\"Linus Walleij\");\nMODULE_DESCRIPTION(\"Invensense MPU3050 gyroscope driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}