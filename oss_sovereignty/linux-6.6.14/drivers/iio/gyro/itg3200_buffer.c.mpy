{
  "module_name": "itg3200_buffer.c",
  "hash_id": "016a7fc3828bd1625c71a2ea80c4f3f7fe927809b4c33ce89e689f6e270f8eb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/gyro/itg3200_buffer.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/gyro/itg3200.h>\n\n\nstatic int itg3200_read_all_channels(struct i2c_client *i2c, __be16 *buf)\n{\n\tu8 tx = 0x80 | ITG3200_REG_TEMP_OUT_H;\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = i2c->addr,\n\t\t\t.flags = i2c->flags,\n\t\t\t.len = 1,\n\t\t\t.buf = &tx,\n\t\t},\n\t\t{\n\t\t\t.addr = i2c->addr,\n\t\t\t.flags = i2c->flags | I2C_M_RD,\n\t\t\t.len = ITG3200_SCAN_ELEMENTS * sizeof(s16),\n\t\t\t.buf = (char *)&buf,\n\t\t},\n\t};\n\n\treturn i2c_transfer(i2c->adapter, msg, 2);\n}\n\nstatic irqreturn_t itg3200_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct itg3200 *st = iio_priv(indio_dev);\n\t \n\tstruct {\n\t\t__be16 buf[ITG3200_SCAN_ELEMENTS];\n\t\ts64 ts __aligned(8);\n\t} scan;\n\n\tint ret = itg3200_read_all_channels(st->i2c, scan.buf);\n\tif (ret < 0)\n\t\tgoto error_ret;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &scan, pf->timestamp);\n\nerror_ret:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nint itg3200_buffer_configure(struct iio_dev *indio_dev)\n{\n\treturn iio_triggered_buffer_setup(indio_dev, &iio_pollfunc_store_time,\n\t\titg3200_trigger_handler, NULL);\n}\n\nvoid itg3200_buffer_unconfigure(struct iio_dev *indio_dev)\n{\n\tiio_triggered_buffer_cleanup(indio_dev);\n}\n\n\nstatic int itg3200_data_rdy_trigger_set_state(struct iio_trigger *trig,\n\t\tbool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tint ret;\n\tu8 msc;\n\n\tret = itg3200_read_reg_8(indio_dev, ITG3200_REG_IRQ_CONFIG, &msc);\n\tif (ret)\n\t\tgoto error_ret;\n\n\tif (state)\n\t\tmsc |= ITG3200_IRQ_DATA_RDY_ENABLE;\n\telse\n\t\tmsc &= ~ITG3200_IRQ_DATA_RDY_ENABLE;\n\n\tret = itg3200_write_reg_8(indio_dev, ITG3200_REG_IRQ_CONFIG, msc);\n\tif (ret)\n\t\tgoto error_ret;\n\nerror_ret:\n\treturn ret;\n\n}\n\nstatic const struct iio_trigger_ops itg3200_trigger_ops = {\n\t.set_trigger_state = &itg3200_data_rdy_trigger_set_state,\n};\n\nint itg3200_probe_trigger(struct iio_dev *indio_dev)\n{\n\tint ret;\n\tstruct itg3200 *st = iio_priv(indio_dev);\n\n\tst->trig = iio_trigger_alloc(&st->i2c->dev, \"%s-dev%d\", indio_dev->name,\n\t\t\t\t     iio_device_id(indio_dev));\n\tif (!st->trig)\n\t\treturn -ENOMEM;\n\n\tret = request_irq(st->i2c->irq,\n\t\t\t  &iio_trigger_generic_data_rdy_poll,\n\t\t\t  IRQF_TRIGGER_RISING,\n\t\t\t  \"itg3200_data_rdy\",\n\t\t\t  st->trig);\n\tif (ret)\n\t\tgoto error_free_trig;\n\n\n\tst->trig->ops = &itg3200_trigger_ops;\n\tiio_trigger_set_drvdata(st->trig, indio_dev);\n\tret = iio_trigger_register(st->trig);\n\tif (ret)\n\t\tgoto error_free_irq;\n\n\t \n\tindio_dev->trig = iio_trigger_get(st->trig);\n\n\treturn 0;\n\nerror_free_irq:\n\tfree_irq(st->i2c->irq, st->trig);\nerror_free_trig:\n\tiio_trigger_free(st->trig);\n\treturn ret;\n}\n\nvoid itg3200_remove_trigger(struct iio_dev *indio_dev)\n{\n\tstruct itg3200 *st = iio_priv(indio_dev);\n\n\tiio_trigger_unregister(st->trig);\n\tfree_irq(st->i2c->irq, st->trig);\n\tiio_trigger_free(st->trig);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}