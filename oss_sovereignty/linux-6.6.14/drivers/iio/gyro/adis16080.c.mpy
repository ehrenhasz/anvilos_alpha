{
  "module_name": "adis16080.c",
  "hash_id": "7a29e3b95beba686c07e1fb47fded56afbfba7e4a1dd1383d4e852c5d62de3f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/gyro/adis16080.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define ADIS16080_DIN_GYRO   (0 << 10)  \n#define ADIS16080_DIN_TEMP   (1 << 10)  \n#define ADIS16080_DIN_AIN1   (2 << 10)\n#define ADIS16080_DIN_AIN2   (3 << 10)\n\n \n\n#define ADIS16080_DIN_WRITE  (1 << 15)\n\nstruct adis16080_chip_info {\n\tint scale_val;\n\tint scale_val2;\n};\n\n \nstruct adis16080_state {\n\tstruct spi_device\t\t*us;\n\tconst struct adis16080_chip_info *info;\n\tstruct mutex\t\t\tlock;\n\n\t__be16 buf __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic int adis16080_read_sample(struct iio_dev *indio_dev,\n\t\tu16 addr, int *val)\n{\n\tstruct adis16080_state *st = iio_priv(indio_dev);\n\tint ret;\n\tstruct spi_transfer\tt[] = {\n\t\t{\n\t\t\t.tx_buf\t\t= &st->buf,\n\t\t\t.len\t\t= 2,\n\t\t\t.cs_change\t= 1,\n\t\t}, {\n\t\t\t.rx_buf\t\t= &st->buf,\n\t\t\t.len\t\t= 2,\n\t\t},\n\t};\n\n\tst->buf = cpu_to_be16(addr | ADIS16080_DIN_WRITE);\n\n\tret = spi_sync_transfer(st->us, t, ARRAY_SIZE(t));\n\tif (ret == 0)\n\t\t*val = sign_extend32(be16_to_cpu(st->buf), 11);\n\n\treturn ret;\n}\n\nstatic int adis16080_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val,\n\t\t\t     int *val2,\n\t\t\t     long mask)\n{\n\tstruct adis16080_state *st = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&st->lock);\n\t\tret = adis16080_read_sample(indio_dev, chan->address, val);\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret ? ret : IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\t*val = st->info->scale_val;\n\t\t\t*val2 = st->info->scale_val2;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_VOLTAGE:\n\t\t\t \n\t\t\t*val = 5000;\n\t\t\t*val2 = 12;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = 85000 - 25000;\n\t\t\t*val2 = 585;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\t \n\t\t\t*val = 2048;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = DIV_ROUND_CLOSEST(25 * 585, 85 - 25);\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct iio_chan_spec adis16080_channels[] = {\n\t{\n\t\t.type = IIO_ANGL_VEL,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_Z,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = ADIS16080_DIN_GYRO,\n\t}, {\n\t\t.type = IIO_VOLTAGE,\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\n\t\t.address = ADIS16080_DIN_AIN1,\n\t}, {\n\t\t.type = IIO_VOLTAGE,\n\t\t.indexed = 1,\n\t\t.channel = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\n\t\t.address = ADIS16080_DIN_AIN2,\n\t}, {\n\t\t.type = IIO_TEMP,\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\n\t\t.address = ADIS16080_DIN_TEMP,\n\t}\n};\n\nstatic const struct iio_info adis16080_info = {\n\t.read_raw = &adis16080_read_raw,\n};\n\nenum {\n\tID_ADIS16080,\n\tID_ADIS16100,\n};\n\nstatic const struct adis16080_chip_info adis16080_chip_info[] = {\n\t[ID_ADIS16080] = {\n\t\t \n\t\t.scale_val = 80,\n\t\t.scale_val2 = 46925,\n\t},\n\t[ID_ADIS16100] = {\n\t\t \n\t\t.scale_val = 300,\n\t\t.scale_val2 = 70474,\n\t},\n};\n\nstatic int adis16080_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tstruct adis16080_state *st;\n\tstruct iio_dev *indio_dev;\n\n\t \n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tst = iio_priv(indio_dev);\n\n\tmutex_init(&st->lock);\n\n\t \n\tst->us = spi;\n\tst->info = &adis16080_chip_info[id->driver_data];\n\n\tindio_dev->name = spi->dev.driver->name;\n\tindio_dev->channels = adis16080_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adis16080_channels);\n\tindio_dev->info = &adis16080_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id adis16080_ids[] = {\n\t{ \"adis16080\", ID_ADIS16080 },\n\t{ \"adis16100\", ID_ADIS16100 },\n\t{},\n};\nMODULE_DEVICE_TABLE(spi, adis16080_ids);\n\nstatic struct spi_driver adis16080_driver = {\n\t.driver = {\n\t\t.name = \"adis16080\",\n\t},\n\t.probe = adis16080_probe,\n\t.id_table = adis16080_ids,\n};\nmodule_spi_driver(adis16080_driver);\n\nMODULE_AUTHOR(\"Barry Song <21cnbao@gmail.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADIS16080/100 Yaw Rate Gyroscope Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}