{
  "module_name": "fxas21002c_core.c",
  "hash_id": "75a72bc7391e2e4f96f58e4bfc96e02d9267da8387bc4144c187cf4a07ca571e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/gyro/fxas21002c_core.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/iio/events.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#include \"fxas21002c.h\"\n\n#define FXAS21002C_CHIP_ID_1\t0xD6\n#define FXAS21002C_CHIP_ID_2\t0xD7\n\nenum fxas21002c_mode_state {\n\tFXAS21002C_MODE_STANDBY,\n\tFXAS21002C_MODE_READY,\n\tFXAS21002C_MODE_ACTIVE,\n};\n\n#define FXAS21002C_STANDBY_ACTIVE_TIME_MS\t62\n#define FXAS21002C_READY_ACTIVE_TIME_MS\t\t7\n\n#define FXAS21002C_ODR_LIST_MAX\t\t10\n\n#define FXAS21002C_SCALE_FRACTIONAL\t32\n#define FXAS21002C_RANGE_LIMIT_DOUBLE\t2000\n\n#define FXAS21002C_AXIS_TO_REG(axis) (FXAS21002C_REG_OUT_X_MSB + ((axis) * 2))\n\nstatic const struct reg_field fxas21002c_reg_fields[] = {\n\t[F_DR_STATUS]\t\t= REG_FIELD(FXAS21002C_REG_STATUS, 0, 7),\n\t[F_OUT_X_MSB]\t\t= REG_FIELD(FXAS21002C_REG_OUT_X_MSB, 0, 7),\n\t[F_OUT_X_LSB]\t\t= REG_FIELD(FXAS21002C_REG_OUT_X_LSB, 0, 7),\n\t[F_OUT_Y_MSB]\t\t= REG_FIELD(FXAS21002C_REG_OUT_Y_MSB, 0, 7),\n\t[F_OUT_Y_LSB]\t\t= REG_FIELD(FXAS21002C_REG_OUT_Y_LSB, 0, 7),\n\t[F_OUT_Z_MSB]\t\t= REG_FIELD(FXAS21002C_REG_OUT_Z_MSB, 0, 7),\n\t[F_OUT_Z_LSB]\t\t= REG_FIELD(FXAS21002C_REG_OUT_Z_LSB, 0, 7),\n\t[F_ZYX_OW]\t\t= REG_FIELD(FXAS21002C_REG_DR_STATUS, 7, 7),\n\t[F_Z_OW]\t\t= REG_FIELD(FXAS21002C_REG_DR_STATUS, 6, 6),\n\t[F_Y_OW]\t\t= REG_FIELD(FXAS21002C_REG_DR_STATUS, 5, 5),\n\t[F_X_OW]\t\t= REG_FIELD(FXAS21002C_REG_DR_STATUS, 4, 4),\n\t[F_ZYX_DR]\t\t= REG_FIELD(FXAS21002C_REG_DR_STATUS, 3, 3),\n\t[F_Z_DR]\t\t= REG_FIELD(FXAS21002C_REG_DR_STATUS, 2, 2),\n\t[F_Y_DR]\t\t= REG_FIELD(FXAS21002C_REG_DR_STATUS, 1, 1),\n\t[F_X_DR]\t\t= REG_FIELD(FXAS21002C_REG_DR_STATUS, 0, 0),\n\t[F_OVF]\t\t\t= REG_FIELD(FXAS21002C_REG_F_STATUS, 7, 7),\n\t[F_WMKF]\t\t= REG_FIELD(FXAS21002C_REG_F_STATUS, 6, 6),\n\t[F_CNT]\t\t\t= REG_FIELD(FXAS21002C_REG_F_STATUS, 0, 5),\n\t[F_MODE]\t\t= REG_FIELD(FXAS21002C_REG_F_SETUP, 6, 7),\n\t[F_WMRK]\t\t= REG_FIELD(FXAS21002C_REG_F_SETUP, 0, 5),\n\t[F_EVENT]\t\t= REG_FIELD(FXAS21002C_REG_F_EVENT, 5, 5),\n\t[FE_TIME]\t\t= REG_FIELD(FXAS21002C_REG_F_EVENT, 0, 4),\n\t[F_BOOTEND]\t\t= REG_FIELD(FXAS21002C_REG_INT_SRC_FLAG, 3, 3),\n\t[F_SRC_FIFO]\t\t= REG_FIELD(FXAS21002C_REG_INT_SRC_FLAG, 2, 2),\n\t[F_SRC_RT]\t\t= REG_FIELD(FXAS21002C_REG_INT_SRC_FLAG, 1, 1),\n\t[F_SRC_DRDY]\t\t= REG_FIELD(FXAS21002C_REG_INT_SRC_FLAG, 0, 0),\n\t[F_WHO_AM_I]\t\t= REG_FIELD(FXAS21002C_REG_WHO_AM_I, 0, 7),\n\t[F_BW]\t\t\t= REG_FIELD(FXAS21002C_REG_CTRL0, 6, 7),\n\t[F_SPIW]\t\t= REG_FIELD(FXAS21002C_REG_CTRL0, 5, 5),\n\t[F_SEL]\t\t\t= REG_FIELD(FXAS21002C_REG_CTRL0, 3, 4),\n\t[F_HPF_EN]\t\t= REG_FIELD(FXAS21002C_REG_CTRL0, 2, 2),\n\t[F_FS]\t\t\t= REG_FIELD(FXAS21002C_REG_CTRL0, 0, 1),\n\t[F_ELE]\t\t\t= REG_FIELD(FXAS21002C_REG_RT_CFG, 3, 3),\n\t[F_ZTEFE]\t\t= REG_FIELD(FXAS21002C_REG_RT_CFG, 2, 2),\n\t[F_YTEFE]\t\t= REG_FIELD(FXAS21002C_REG_RT_CFG, 1, 1),\n\t[F_XTEFE]\t\t= REG_FIELD(FXAS21002C_REG_RT_CFG, 0, 0),\n\t[F_EA]\t\t\t= REG_FIELD(FXAS21002C_REG_RT_SRC, 6, 6),\n\t[F_ZRT]\t\t\t= REG_FIELD(FXAS21002C_REG_RT_SRC, 5, 5),\n\t[F_ZRT_POL]\t\t= REG_FIELD(FXAS21002C_REG_RT_SRC, 4, 4),\n\t[F_YRT]\t\t\t= REG_FIELD(FXAS21002C_REG_RT_SRC, 3, 3),\n\t[F_YRT_POL]\t\t= REG_FIELD(FXAS21002C_REG_RT_SRC, 2, 2),\n\t[F_XRT]\t\t\t= REG_FIELD(FXAS21002C_REG_RT_SRC, 1, 1),\n\t[F_XRT_POL]\t\t= REG_FIELD(FXAS21002C_REG_RT_SRC, 0, 0),\n\t[F_DBCNTM]\t\t= REG_FIELD(FXAS21002C_REG_RT_THS, 7, 7),\n\t[F_THS]\t\t\t= REG_FIELD(FXAS21002C_REG_RT_SRC, 0, 6),\n\t[F_RT_COUNT]\t\t= REG_FIELD(FXAS21002C_REG_RT_COUNT, 0, 7),\n\t[F_TEMP]\t\t= REG_FIELD(FXAS21002C_REG_TEMP, 0, 7),\n\t[F_RST]\t\t\t= REG_FIELD(FXAS21002C_REG_CTRL1, 6, 6),\n\t[F_ST]\t\t\t= REG_FIELD(FXAS21002C_REG_CTRL1, 5, 5),\n\t[F_DR]\t\t\t= REG_FIELD(FXAS21002C_REG_CTRL1, 2, 4),\n\t[F_ACTIVE]\t\t= REG_FIELD(FXAS21002C_REG_CTRL1, 1, 1),\n\t[F_READY]\t\t= REG_FIELD(FXAS21002C_REG_CTRL1, 0, 0),\n\t[F_INT_CFG_FIFO]\t= REG_FIELD(FXAS21002C_REG_CTRL2, 7, 7),\n\t[F_INT_EN_FIFO]\t\t= REG_FIELD(FXAS21002C_REG_CTRL2, 6, 6),\n\t[F_INT_CFG_RT]\t\t= REG_FIELD(FXAS21002C_REG_CTRL2, 5, 5),\n\t[F_INT_EN_RT]\t\t= REG_FIELD(FXAS21002C_REG_CTRL2, 4, 4),\n\t[F_INT_CFG_DRDY]\t= REG_FIELD(FXAS21002C_REG_CTRL2, 3, 3),\n\t[F_INT_EN_DRDY]\t\t= REG_FIELD(FXAS21002C_REG_CTRL2, 2, 2),\n\t[F_IPOL]\t\t= REG_FIELD(FXAS21002C_REG_CTRL2, 1, 1),\n\t[F_PP_OD]\t\t= REG_FIELD(FXAS21002C_REG_CTRL2, 0, 0),\n\t[F_WRAPTOONE]\t\t= REG_FIELD(FXAS21002C_REG_CTRL3, 3, 3),\n\t[F_EXTCTRLEN]\t\t= REG_FIELD(FXAS21002C_REG_CTRL3, 2, 2),\n\t[F_FS_DOUBLE]\t\t= REG_FIELD(FXAS21002C_REG_CTRL3, 0, 0),\n};\n\nstatic const int fxas21002c_odr_values[] = {\n\t800, 400, 200, 100, 50, 25, 12, 12\n};\n\n \nstatic const int fxas21002c_lpf_values[] = {\n\t32, 16, 8\n};\n\n \nstatic const int fxas21002c_hpf_values[] = {\n\t18750, 9625, 4875, 2475\n};\n\nstatic const int fxas21002c_range_values[] = {\n\t4000, 2000, 1000, 500, 250\n};\n\nstruct fxas21002c_data {\n\tu8 chip_id;\n\tenum fxas21002c_mode_state mode;\n\tenum fxas21002c_mode_state prev_mode;\n\n\tstruct mutex lock;\t\t \n\tstruct regmap *regmap;\n\tstruct regmap_field *regmap_fields[F_MAX_FIELDS];\n\tstruct iio_trigger *dready_trig;\n\ts64 timestamp;\n\tint irq;\n\n\tstruct regulator *vdd;\n\tstruct regulator *vddio;\n\n\t \n\ts16 buffer[8] __aligned(IIO_DMA_MINALIGN);\n};\n\nenum fxas21002c_channel_index {\n\tCHANNEL_SCAN_INDEX_X,\n\tCHANNEL_SCAN_INDEX_Y,\n\tCHANNEL_SCAN_INDEX_Z,\n\tCHANNEL_SCAN_MAX,\n};\n\nstatic int fxas21002c_odr_hz_from_value(struct fxas21002c_data *data, u8 value)\n{\n\tint odr_value_max = ARRAY_SIZE(fxas21002c_odr_values) - 1;\n\n\tvalue = min_t(u8, value, odr_value_max);\n\n\treturn fxas21002c_odr_values[value];\n}\n\nstatic int fxas21002c_odr_value_from_hz(struct fxas21002c_data *data,\n\t\t\t\t\tunsigned int hz)\n{\n\tint odr_table_size = ARRAY_SIZE(fxas21002c_odr_values);\n\tint i;\n\n\tfor (i = 0; i < odr_table_size; i++)\n\t\tif (fxas21002c_odr_values[i] == hz)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int fxas21002c_lpf_bw_from_value(struct fxas21002c_data *data, u8 value)\n{\n\tint lpf_value_max = ARRAY_SIZE(fxas21002c_lpf_values) - 1;\n\n\tvalue = min_t(u8, value, lpf_value_max);\n\n\treturn fxas21002c_lpf_values[value];\n}\n\nstatic int fxas21002c_lpf_value_from_bw(struct fxas21002c_data *data,\n\t\t\t\t\tunsigned int hz)\n{\n\tint lpf_table_size = ARRAY_SIZE(fxas21002c_lpf_values);\n\tint i;\n\n\tfor (i = 0; i < lpf_table_size; i++)\n\t\tif (fxas21002c_lpf_values[i] == hz)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int fxas21002c_hpf_sel_from_value(struct fxas21002c_data *data, u8 value)\n{\n\tint hpf_value_max = ARRAY_SIZE(fxas21002c_hpf_values) - 1;\n\n\tvalue = min_t(u8, value, hpf_value_max);\n\n\treturn fxas21002c_hpf_values[value];\n}\n\nstatic int fxas21002c_hpf_value_from_sel(struct fxas21002c_data *data,\n\t\t\t\t\t unsigned int hz)\n{\n\tint hpf_table_size = ARRAY_SIZE(fxas21002c_hpf_values);\n\tint i;\n\n\tfor (i = 0; i < hpf_table_size; i++)\n\t\tif (fxas21002c_hpf_values[i] == hz)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int fxas21002c_range_fs_from_value(struct fxas21002c_data *data,\n\t\t\t\t\t  u8 value)\n{\n\tint range_value_max = ARRAY_SIZE(fxas21002c_range_values) - 1;\n\tunsigned int fs_double;\n\tint ret;\n\n\t \n\tret = regmap_field_read(data->regmap_fields[F_FS_DOUBLE], &fs_double);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!fs_double)\n\t\tvalue += 1;\n\n\tvalue = min_t(u8, value, range_value_max);\n\n\treturn fxas21002c_range_values[value];\n}\n\nstatic int fxas21002c_range_value_from_fs(struct fxas21002c_data *data,\n\t\t\t\t\t  unsigned int range)\n{\n\tint range_table_size = ARRAY_SIZE(fxas21002c_range_values);\n\tbool found = false;\n\tint fs_double = 0;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < range_table_size; i++)\n\t\tif (fxas21002c_range_values[i] == range) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\tif (range > FXAS21002C_RANGE_LIMIT_DOUBLE)\n\t\tfs_double = 1;\n\n\tret = regmap_field_write(data->regmap_fields[F_FS_DOUBLE], fs_double);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn i;\n}\n\nstatic int fxas21002c_mode_get(struct fxas21002c_data *data)\n{\n\tunsigned int active;\n\tunsigned int ready;\n\tint ret;\n\n\tret = regmap_field_read(data->regmap_fields[F_ACTIVE], &active);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (active)\n\t\treturn FXAS21002C_MODE_ACTIVE;\n\n\tret = regmap_field_read(data->regmap_fields[F_READY], &ready);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ready)\n\t\treturn FXAS21002C_MODE_READY;\n\n\treturn FXAS21002C_MODE_STANDBY;\n}\n\nstatic int fxas21002c_mode_set(struct fxas21002c_data *data,\n\t\t\t       enum fxas21002c_mode_state mode)\n{\n\tint ret;\n\n\tif (mode == data->mode)\n\t\treturn 0;\n\n\tif (mode == FXAS21002C_MODE_READY)\n\t\tret = regmap_field_write(data->regmap_fields[F_READY], 1);\n\telse\n\t\tret = regmap_field_write(data->regmap_fields[F_READY], 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (mode == FXAS21002C_MODE_ACTIVE)\n\t\tret = regmap_field_write(data->regmap_fields[F_ACTIVE], 1);\n\telse\n\t\tret = regmap_field_write(data->regmap_fields[F_ACTIVE], 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (mode == FXAS21002C_MODE_ACTIVE &&\n\t    data->mode == FXAS21002C_MODE_STANDBY)\n\t\tmsleep_interruptible(FXAS21002C_STANDBY_ACTIVE_TIME_MS);\n\n\tif (data->mode == FXAS21002C_MODE_READY)\n\t\tmsleep_interruptible(FXAS21002C_READY_ACTIVE_TIME_MS);\n\n\tdata->prev_mode = data->mode;\n\tdata->mode = mode;\n\n\treturn ret;\n}\n\nstatic int fxas21002c_write(struct fxas21002c_data *data,\n\t\t\t    enum fxas21002c_fields field, int bits)\n{\n\tint actual_mode;\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\n\tactual_mode = fxas21002c_mode_get(data);\n\tif (actual_mode < 0) {\n\t\tret = actual_mode;\n\t\tgoto out_unlock;\n\t}\n\n\tret = fxas21002c_mode_set(data, FXAS21002C_MODE_READY);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tret = regmap_field_write(data->regmap_fields[field], bits);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tret = fxas21002c_mode_set(data, data->prev_mode);\n\nout_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int  fxas21002c_pm_get(struct fxas21002c_data *data)\n{\n\treturn pm_runtime_resume_and_get(regmap_get_device(data->regmap));\n}\n\nstatic int  fxas21002c_pm_put(struct fxas21002c_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\n\tpm_runtime_mark_last_busy(dev);\n\n\treturn pm_runtime_put_autosuspend(dev);\n}\n\nstatic int fxas21002c_temp_get(struct fxas21002c_data *data, int *val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tunsigned int temp;\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = fxas21002c_pm_get(data);\n\tif (ret < 0)\n\t\tgoto data_unlock;\n\n\tret = regmap_field_read(data->regmap_fields[F_TEMP], &temp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read temp: %d\\n\", ret);\n\t\tfxas21002c_pm_put(data);\n\t\tgoto data_unlock;\n\t}\n\n\t*val = sign_extend32(temp, 7);\n\n\tret = fxas21002c_pm_put(data);\n\tif (ret < 0)\n\t\tgoto data_unlock;\n\n\tret = IIO_VAL_INT;\n\ndata_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int fxas21002c_axis_get(struct fxas21002c_data *data,\n\t\t\t       int index, int *val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\t__be16 axis_be;\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = fxas21002c_pm_get(data);\n\tif (ret < 0)\n\t\tgoto data_unlock;\n\n\tret = regmap_bulk_read(data->regmap, FXAS21002C_AXIS_TO_REG(index),\n\t\t\t       &axis_be, sizeof(axis_be));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read axis: %d: %d\\n\", index, ret);\n\t\tfxas21002c_pm_put(data);\n\t\tgoto data_unlock;\n\t}\n\n\t*val = sign_extend32(be16_to_cpu(axis_be), 15);\n\n\tret = fxas21002c_pm_put(data);\n\tif (ret < 0)\n\t\tgoto data_unlock;\n\n\tret = IIO_VAL_INT;\n\ndata_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int fxas21002c_odr_get(struct fxas21002c_data *data, int *odr)\n{\n\tunsigned int odr_bits;\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = regmap_field_read(data->regmap_fields[F_DR], &odr_bits);\n\tif (ret < 0)\n\t\tgoto data_unlock;\n\n\t*odr = fxas21002c_odr_hz_from_value(data, odr_bits);\n\n\tret = IIO_VAL_INT;\n\ndata_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int fxas21002c_odr_set(struct fxas21002c_data *data, int odr)\n{\n\tint odr_bits;\n\n\todr_bits = fxas21002c_odr_value_from_hz(data, odr);\n\tif (odr_bits < 0)\n\t\treturn odr_bits;\n\n\treturn fxas21002c_write(data, F_DR, odr_bits);\n}\n\nstatic int fxas21002c_lpf_get(struct fxas21002c_data *data, int *val2)\n{\n\tunsigned int bw_bits;\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = regmap_field_read(data->regmap_fields[F_BW], &bw_bits);\n\tif (ret < 0)\n\t\tgoto data_unlock;\n\n\t*val2 = fxas21002c_lpf_bw_from_value(data, bw_bits) * 10000;\n\n\tret = IIO_VAL_INT_PLUS_MICRO;\n\ndata_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int fxas21002c_lpf_set(struct fxas21002c_data *data, int bw)\n{\n\tint bw_bits;\n\tint odr;\n\tint ret;\n\n\tbw_bits = fxas21002c_lpf_value_from_bw(data, bw);\n\tif (bw_bits < 0)\n\t\treturn bw_bits;\n\n\t \n\tret = fxas21002c_odr_get(data, &odr);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tif ((odr == 25 && bw_bits > 0x01) || (odr == 12 && bw_bits > 0))\n\t\treturn -EINVAL;\n\n\treturn fxas21002c_write(data, F_BW, bw_bits);\n}\n\nstatic int fxas21002c_hpf_get(struct fxas21002c_data *data, int *val2)\n{\n\tunsigned int sel_bits;\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = regmap_field_read(data->regmap_fields[F_SEL], &sel_bits);\n\tif (ret < 0)\n\t\tgoto data_unlock;\n\n\t*val2 = fxas21002c_hpf_sel_from_value(data, sel_bits);\n\n\tret = IIO_VAL_INT_PLUS_MICRO;\n\ndata_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int fxas21002c_hpf_set(struct fxas21002c_data *data, int sel)\n{\n\tint sel_bits;\n\n\tsel_bits = fxas21002c_hpf_value_from_sel(data, sel);\n\tif (sel_bits < 0)\n\t\treturn sel_bits;\n\n\treturn fxas21002c_write(data, F_SEL, sel_bits);\n}\n\nstatic int fxas21002c_scale_get(struct fxas21002c_data *data, int *val)\n{\n\tint fs_bits;\n\tint scale;\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = regmap_field_read(data->regmap_fields[F_FS], &fs_bits);\n\tif (ret < 0)\n\t\tgoto data_unlock;\n\n\tscale = fxas21002c_range_fs_from_value(data, fs_bits);\n\tif (scale < 0) {\n\t\tret = scale;\n\t\tgoto data_unlock;\n\t}\n\n\t*val = scale;\n\ndata_unlock:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int fxas21002c_scale_set(struct fxas21002c_data *data, int range)\n{\n\tint fs_bits;\n\n\tfs_bits = fxas21002c_range_value_from_fs(data, range);\n\tif (fs_bits < 0)\n\t\treturn fs_bits;\n\n\treturn fxas21002c_write(data, F_FS, fs_bits);\n}\n\nstatic int fxas21002c_read_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan, int *val,\n\t\t\t       int *val2, long mask)\n{\n\tstruct fxas21002c_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\treturn fxas21002c_temp_get(data, val);\n\t\tcase IIO_ANGL_VEL:\n\t\t\treturn fxas21002c_axis_get(data, chan->scan_index, val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\t*val2 = FXAS21002C_SCALE_FRACTIONAL;\n\t\t\tret = fxas21002c_scale_get(data, val);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\t*val = 0;\n\t\treturn fxas21002c_lpf_get(data, val2);\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\t*val = 0;\n\t\treturn fxas21002c_hpf_get(data, val2);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val2 = 0;\n\t\treturn fxas21002c_odr_get(data, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int fxas21002c_write_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan, int val,\n\t\t\t\tint val2, long mask)\n{\n\tstruct fxas21002c_data *data = iio_priv(indio_dev);\n\tint range;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (val2)\n\t\t\treturn -EINVAL;\n\n\t\treturn fxas21002c_odr_set(data, val);\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tif (val)\n\t\t\treturn -EINVAL;\n\n\t\tval2 = val2 / 10000;\n\t\treturn fxas21002c_lpf_set(data, val2);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\trange = (((val * 1000 + val2 / 1000) *\n\t\t\t\t  FXAS21002C_SCALE_FRACTIONAL) / 1000);\n\t\t\treturn fxas21002c_scale_set(data, range);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn fxas21002c_hpf_set(data, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\"12.5 25 50 100 200 400 800\");\n\nstatic IIO_CONST_ATTR(in_anglvel_filter_low_pass_3db_frequency_available,\n\t\t      \"0.32 0.16 0.08\");\n\nstatic IIO_CONST_ATTR(in_anglvel_filter_high_pass_3db_frequency_available,\n\t\t      \"0.018750 0.009625 0.004875 0.002475\");\n\nstatic IIO_CONST_ATTR(in_anglvel_scale_available,\n\t\t      \"125.0 62.5 31.25 15.625 7.8125\");\n\nstatic struct attribute *fxas21002c_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_const_attr_in_anglvel_filter_low_pass_3db_frequency_available.dev_attr.attr,\n\t&iio_const_attr_in_anglvel_filter_high_pass_3db_frequency_available.dev_attr.attr,\n\t&iio_const_attr_in_anglvel_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group fxas21002c_attrs_group = {\n\t.attrs = fxas21002c_attributes,\n};\n\n#define FXAS21002C_CHANNEL(_axis) {\t\t\t\t\t\\\n\t.type = IIO_ANGL_VEL,\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##_axis,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY) |\t\\\n\t\tBIT(IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY) |\t\\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t\t\\\n\t.scan_index = CHANNEL_SCAN_INDEX_##_axis,\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\t\\\n\t\t.realbits = 16,\t\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\t\\\n\t\t.endianness = IIO_BE,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec fxas21002c_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.scan_index = -1,\n\t},\n\tFXAS21002C_CHANNEL(X),\n\tFXAS21002C_CHANNEL(Y),\n\tFXAS21002C_CHANNEL(Z),\n};\n\nstatic const struct iio_info fxas21002c_info = {\n\t.attrs\t\t\t= &fxas21002c_attrs_group,\n\t.read_raw\t\t= &fxas21002c_read_raw,\n\t.write_raw\t\t= &fxas21002c_write_raw,\n};\n\nstatic irqreturn_t fxas21002c_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct fxas21002c_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = regmap_bulk_read(data->regmap, FXAS21002C_REG_OUT_X_MSB,\n\t\t\t       data->buffer, CHANNEL_SCAN_MAX * sizeof(s16));\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, data->buffer,\n\t\t\t\t\t   data->timestamp);\n\nout_unlock:\n\tmutex_unlock(&data->lock);\n\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int fxas21002c_chip_init(struct fxas21002c_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tunsigned int chip_id;\n\tint ret;\n\n\tret = regmap_field_read(data->regmap_fields[F_WHO_AM_I], &chip_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (chip_id != FXAS21002C_CHIP_ID_1 &&\n\t    chip_id != FXAS21002C_CHIP_ID_2) {\n\t\tdev_err(dev, \"chip id 0x%02x is not supported\\n\", chip_id);\n\t\treturn -EINVAL;\n\t}\n\n\tdata->chip_id = chip_id;\n\n\tret = fxas21002c_mode_set(data, FXAS21002C_MODE_STANDBY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = fxas21002c_odr_set(data, 200);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to set ODR: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int fxas21002c_data_rdy_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t\t bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct fxas21002c_data *data = iio_priv(indio_dev);\n\n\treturn regmap_field_write(data->regmap_fields[F_INT_EN_DRDY], state);\n}\n\nstatic const struct iio_trigger_ops fxas21002c_trigger_ops = {\n\t.set_trigger_state = &fxas21002c_data_rdy_trigger_set_state,\n};\n\nstatic irqreturn_t fxas21002c_data_rdy_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct fxas21002c_data *data = iio_priv(indio_dev);\n\n\tdata->timestamp = iio_get_time_ns(indio_dev);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t fxas21002c_data_rdy_thread(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct fxas21002c_data *data = iio_priv(indio_dev);\n\tunsigned int data_ready;\n\tint ret;\n\n\tret = regmap_field_read(data->regmap_fields[F_SRC_DRDY], &data_ready);\n\tif (ret < 0)\n\t\treturn IRQ_NONE;\n\n\tif (!data_ready)\n\t\treturn IRQ_NONE;\n\n\tiio_trigger_poll_nested(data->dready_trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int fxas21002c_trigger_probe(struct fxas21002c_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tunsigned long irq_trig;\n\tbool irq_open_drain;\n\tint irq1;\n\tint ret;\n\n\tif (!data->irq)\n\t\treturn 0;\n\n\tirq1 = fwnode_irq_get_byname(dev_fwnode(dev), \"INT1\");\n\tif (irq1 == data->irq) {\n\t\tdev_info(dev, \"using interrupt line INT1\\n\");\n\t\tret = regmap_field_write(data->regmap_fields[F_INT_CFG_DRDY],\n\t\t\t\t\t 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tdev_info(dev, \"using interrupt line INT2\\n\");\n\n\tirq_open_drain = device_property_read_bool(dev, \"drive-open-drain\");\n\n\tdata->dready_trig = devm_iio_trigger_alloc(dev, \"%s-dev%d\",\n\t\t\t\t\t\t   indio_dev->name,\n\t\t\t\t\t\t   iio_device_id(indio_dev));\n\tif (!data->dready_trig)\n\t\treturn -ENOMEM;\n\n\tirq_trig = irqd_get_trigger_type(irq_get_irq_data(data->irq));\n\n\tif (irq_trig == IRQF_TRIGGER_RISING) {\n\t\tret = regmap_field_write(data->regmap_fields[F_IPOL], 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (irq_open_drain)\n\t\tirq_trig |= IRQF_SHARED;\n\n\tret = devm_request_threaded_irq(dev, data->irq,\n\t\t\t\t\tfxas21002c_data_rdy_handler,\n\t\t\t\t\tfxas21002c_data_rdy_thread,\n\t\t\t\t\tirq_trig, \"fxas21002c_data_ready\",\n\t\t\t\t\tindio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->dready_trig->ops = &fxas21002c_trigger_ops;\n\tiio_trigger_set_drvdata(data->dready_trig, indio_dev);\n\n\treturn devm_iio_trigger_register(dev, data->dready_trig);\n}\n\nstatic int fxas21002c_power_enable(struct fxas21002c_data *data)\n{\n\tint ret;\n\n\tret = regulator_enable(data->vdd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regulator_enable(data->vddio);\n\tif (ret < 0) {\n\t\tregulator_disable(data->vdd);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void fxas21002c_power_disable(struct fxas21002c_data *data)\n{\n\tregulator_disable(data->vdd);\n\tregulator_disable(data->vddio);\n}\n\nstatic void fxas21002c_power_disable_action(void *_data)\n{\n\tstruct fxas21002c_data *data = _data;\n\n\tfxas21002c_power_disable(data);\n}\n\nstatic int fxas21002c_regulators_get(struct fxas21002c_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\n\tdata->vdd = devm_regulator_get(dev->parent, \"vdd\");\n\tif (IS_ERR(data->vdd))\n\t\treturn PTR_ERR(data->vdd);\n\n\tdata->vddio = devm_regulator_get(dev->parent, \"vddio\");\n\n\treturn PTR_ERR_OR_ZERO(data->vddio);\n}\n\nint fxas21002c_core_probe(struct device *dev, struct regmap *regmap, int irq,\n\t\t\t  const char *name)\n{\n\tstruct fxas21002c_data *data;\n\tstruct iio_dev *indio_dev;\n\tstruct regmap_field *f;\n\tint i;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdev_set_drvdata(dev, indio_dev);\n\tdata->irq = irq;\n\tdata->regmap = regmap;\n\n\tfor (i = 0; i < F_MAX_FIELDS; i++) {\n\t\tf = devm_regmap_field_alloc(dev, data->regmap,\n\t\t\t\t\t    fxas21002c_reg_fields[i]);\n\t\tif (IS_ERR(f))\n\t\t\treturn PTR_ERR(f);\n\n\t\tdata->regmap_fields[i] = f;\n\t}\n\n\tmutex_init(&data->lock);\n\n\tret = fxas21002c_regulators_get(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = fxas21002c_power_enable(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, fxas21002c_power_disable_action,\n\t\t\t\t       data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = fxas21002c_chip_init(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tindio_dev->channels = fxas21002c_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(fxas21002c_channels);\n\tindio_dev->name = name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &fxas21002c_info;\n\n\tret = fxas21002c_trigger_probe(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,\n\t\t\t\t\t      fxas21002c_trigger_handler, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pm_runtime_set_active(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 2000);\n\tpm_runtime_use_autosuspend(dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto pm_disable;\n\n\treturn 0;\n\npm_disable:\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(fxas21002c_core_probe, IIO_FXAS21002C);\n\nvoid fxas21002c_core_remove(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n}\nEXPORT_SYMBOL_NS_GPL(fxas21002c_core_remove, IIO_FXAS21002C);\n\nstatic int fxas21002c_suspend(struct device *dev)\n{\n\tstruct fxas21002c_data *data = iio_priv(dev_get_drvdata(dev));\n\n\tfxas21002c_mode_set(data, FXAS21002C_MODE_STANDBY);\n\tfxas21002c_power_disable(data);\n\n\treturn 0;\n}\n\nstatic int fxas21002c_resume(struct device *dev)\n{\n\tstruct fxas21002c_data *data = iio_priv(dev_get_drvdata(dev));\n\tint ret;\n\n\tret = fxas21002c_power_enable(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn fxas21002c_mode_set(data, data->prev_mode);\n}\n\nstatic int fxas21002c_runtime_suspend(struct device *dev)\n{\n\tstruct fxas21002c_data *data = iio_priv(dev_get_drvdata(dev));\n\n\treturn fxas21002c_mode_set(data, FXAS21002C_MODE_READY);\n}\n\nstatic int fxas21002c_runtime_resume(struct device *dev)\n{\n\tstruct fxas21002c_data *data = iio_priv(dev_get_drvdata(dev));\n\n\treturn fxas21002c_mode_set(data, FXAS21002C_MODE_ACTIVE);\n}\n\nEXPORT_NS_GPL_DEV_PM_OPS(fxas21002c_pm_ops, IIO_FXAS21002C) = {\n\tSYSTEM_SLEEP_PM_OPS(fxas21002c_suspend, fxas21002c_resume)\n\tRUNTIME_PM_OPS(fxas21002c_runtime_suspend, fxas21002c_runtime_resume,\n\t\t       NULL)\n};\n\nMODULE_AUTHOR(\"Rui Miguel Silva <rui.silva@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"FXAS21002C Gyro driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}