{
  "module_name": "adxrs450.c",
  "hash_id": "5270b82bab28017a80fa5431a660f25a6101d44ef99064a2dfbee7999a151a2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/gyro/adxrs450.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define ADXRS450_STARTUP_DELAY\t50  \n\n \n#define ADXRS450_SENSOR_DATA    (0x20 << 24)\n#define ADXRS450_WRITE_DATA\t(0x40 << 24)\n#define ADXRS450_READ_DATA\t(0x80 << 24)\n\n#define ADXRS450_RATE1\t0x00\t \n#define ADXRS450_TEMP1\t0x02\t \n#define ADXRS450_LOCST1\t0x04\t \n#define ADXRS450_HICST1\t0x06\t \n#define ADXRS450_QUAD1\t0x08\t \n#define ADXRS450_FAULT1\t0x0A\t \n#define ADXRS450_PID1\t0x0C\t \n#define ADXRS450_SNH\t0x0E\t \n#define ADXRS450_SNL\t0x10\n#define ADXRS450_DNC1\t0x12\t \n \n#define ADXRS450_P\t0x01\n#define ADXRS450_CHK\t0x02\n#define ADXRS450_CST\t0x04\n#define ADXRS450_PWR\t0x08\n#define ADXRS450_POR\t0x10\n#define ADXRS450_NVM\t0x20\n#define ADXRS450_Q\t0x40\n#define ADXRS450_PLL\t0x80\n#define ADXRS450_UV\t0x100\n#define ADXRS450_OV\t0x200\n#define ADXRS450_AMP\t0x400\n#define ADXRS450_FAIL\t0x800\n\n#define ADXRS450_WRERR_MASK\t(0x7 << 29)\n\n#define ADXRS450_MAX_RX 4\n#define ADXRS450_MAX_TX 4\n\n#define ADXRS450_GET_ST(a)\t((a >> 26) & 0x3)\n\nenum {\n\tID_ADXRS450,\n\tID_ADXRS453,\n};\n\n \nstruct adxrs450_state {\n\tstruct spi_device\t*us;\n\tstruct mutex\t\tbuf_lock;\n\t__be32\t\t\ttx __aligned(IIO_DMA_MINALIGN);\n\t__be32\t\t\trx;\n\n};\n\n \nstatic int adxrs450_spi_read_reg_16(struct iio_dev *indio_dev,\n\t\t\t\t    u8 reg_address,\n\t\t\t\t    u16 *val)\n{\n\tstruct adxrs450_state *st = iio_priv(indio_dev);\n\tu32 tx;\n\tint ret;\n\tstruct spi_transfer xfers[] = {\n\t\t{\n\t\t\t.tx_buf = &st->tx,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = sizeof(st->tx),\n\t\t\t.cs_change = 1,\n\t\t}, {\n\t\t\t.rx_buf = &st->rx,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = sizeof(st->rx),\n\t\t},\n\t};\n\n\tmutex_lock(&st->buf_lock);\n\ttx = ADXRS450_READ_DATA | (reg_address << 17);\n\n\tif (!(hweight32(tx) & 1))\n\t\ttx |= ADXRS450_P;\n\n\tst->tx = cpu_to_be32(tx);\n\tret = spi_sync_transfer(st->us, xfers, ARRAY_SIZE(xfers));\n\tif (ret) {\n\t\tdev_err(&st->us->dev, \"problem while reading 16 bit register 0x%02x\\n\",\n\t\t\t\treg_address);\n\t\tgoto error_ret;\n\t}\n\n\t*val = (be32_to_cpu(st->rx) >> 5) & 0xFFFF;\n\nerror_ret:\n\tmutex_unlock(&st->buf_lock);\n\treturn ret;\n}\n\n \nstatic int adxrs450_spi_write_reg_16(struct iio_dev *indio_dev,\n\t\t\t\t     u8 reg_address,\n\t\t\t\t     u16 val)\n{\n\tstruct adxrs450_state *st = iio_priv(indio_dev);\n\tu32 tx;\n\tint ret;\n\n\tmutex_lock(&st->buf_lock);\n\ttx = ADXRS450_WRITE_DATA | (reg_address << 17) | (val << 1);\n\n\tif (!(hweight32(tx) & 1))\n\t\ttx |= ADXRS450_P;\n\n\tst->tx = cpu_to_be32(tx);\n\tret = spi_write(st->us, &st->tx, sizeof(st->tx));\n\tif (ret)\n\t\tdev_err(&st->us->dev, \"problem while writing 16 bit register 0x%02x\\n\",\n\t\t\treg_address);\n\tusleep_range(100, 1000);  \n\tmutex_unlock(&st->buf_lock);\n\treturn ret;\n}\n\n \nstatic int adxrs450_spi_sensor_data(struct iio_dev *indio_dev, s16 *val)\n{\n\tstruct adxrs450_state *st = iio_priv(indio_dev);\n\tint ret;\n\tstruct spi_transfer xfers[] = {\n\t\t{\n\t\t\t.tx_buf = &st->tx,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = sizeof(st->tx),\n\t\t\t.cs_change = 1,\n\t\t}, {\n\t\t\t.rx_buf = &st->rx,\n\t\t\t.bits_per_word = 8,\n\t\t\t.len = sizeof(st->rx),\n\t\t},\n\t};\n\n\tmutex_lock(&st->buf_lock);\n\tst->tx = cpu_to_be32(ADXRS450_SENSOR_DATA);\n\n\tret = spi_sync_transfer(st->us, xfers, ARRAY_SIZE(xfers));\n\tif (ret) {\n\t\tdev_err(&st->us->dev, \"Problem while reading sensor data\\n\");\n\t\tgoto error_ret;\n\t}\n\n\t*val = (be32_to_cpu(st->rx) >> 10) & 0xFFFF;\n\nerror_ret:\n\tmutex_unlock(&st->buf_lock);\n\treturn ret;\n}\n\n \nstatic int adxrs450_spi_initial(struct adxrs450_state *st,\n\t\tu32 *val, char chk)\n{\n\tint ret;\n\tu32 tx;\n\tstruct spi_transfer xfers = {\n\t\t.tx_buf = &st->tx,\n\t\t.rx_buf = &st->rx,\n\t\t.bits_per_word = 8,\n\t\t.len = sizeof(st->tx),\n\t};\n\n\tmutex_lock(&st->buf_lock);\n\ttx = ADXRS450_SENSOR_DATA;\n\tif (chk)\n\t\ttx |= (ADXRS450_CHK | ADXRS450_P);\n\tst->tx = cpu_to_be32(tx);\n\tret = spi_sync_transfer(st->us, &xfers, 1);\n\tif (ret) {\n\t\tdev_err(&st->us->dev, \"Problem while reading initializing data\\n\");\n\t\tgoto error_ret;\n\t}\n\n\t*val = be32_to_cpu(st->rx);\n\nerror_ret:\n\tmutex_unlock(&st->buf_lock);\n\treturn ret;\n}\n\n \nstatic int adxrs450_initial_setup(struct iio_dev *indio_dev)\n{\n\tu32 t;\n\tu16 data;\n\tint ret;\n\tstruct adxrs450_state *st = iio_priv(indio_dev);\n\n\tmsleep(ADXRS450_STARTUP_DELAY*2);\n\tret = adxrs450_spi_initial(st, &t, 1);\n\tif (ret)\n\t\treturn ret;\n\tif (t != 0x01)\n\t\tdev_warn(&st->us->dev, \"The initial power on response is not correct! Restart without reset?\\n\");\n\n\tmsleep(ADXRS450_STARTUP_DELAY);\n\tret = adxrs450_spi_initial(st, &t, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(ADXRS450_STARTUP_DELAY);\n\tret = adxrs450_spi_initial(st, &t, 0);\n\tif (ret)\n\t\treturn ret;\n\tif (((t & 0xff) | 0x01) != 0xff || ADXRS450_GET_ST(t) != 2) {\n\t\tdev_err(&st->us->dev, \"The second response is not correct!\\n\");\n\t\treturn -EIO;\n\n\t}\n\tret = adxrs450_spi_initial(st, &t, 0);\n\tif (ret)\n\t\treturn ret;\n\tif (((t & 0xff) | 0x01) != 0xff || ADXRS450_GET_ST(t) != 2) {\n\t\tdev_err(&st->us->dev, \"The third response is not correct!\\n\");\n\t\treturn -EIO;\n\n\t}\n\tret = adxrs450_spi_read_reg_16(indio_dev, ADXRS450_FAULT1, &data);\n\tif (ret)\n\t\treturn ret;\n\tif (data & 0x0fff) {\n\t\tdev_err(&st->us->dev, \"The device is not in normal status!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int adxrs450_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val,\n\t\t\t      int val2,\n\t\t\t      long mask)\n{\n\tint ret;\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif (val < -0x400 || val >= 0x400)\n\t\t\treturn -EINVAL;\n\t\tret = adxrs450_spi_write_reg_16(indio_dev,\n\t\t\t\t\t\tADXRS450_DNC1, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int adxrs450_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val,\n\t\t\t     int *val2,\n\t\t\t     long mask)\n{\n\tint ret;\n\ts16 t;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\tret = adxrs450_spi_sensor_data(indio_dev, &t);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\t*val = t;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_TEMP:\n\t\t\tret = adxrs450_spi_read_reg_16(indio_dev,\n\t\t\t\t\t\t       ADXRS450_TEMP1, &t);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\t*val = (t >> 6) + 225;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\t*val = 0;\n\t\t\t*val2 = 218166;\n\t\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t\tcase IIO_TEMP:\n\t\t\t*val = 200;\n\t\t\t*val2 = 0;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW:\n\t\tret = adxrs450_spi_read_reg_16(indio_dev, ADXRS450_QUAD1, &t);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t*val = t;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = adxrs450_spi_read_reg_16(indio_dev, ADXRS450_DNC1, &t);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t*val = sign_extend32(t, 9);\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct iio_chan_spec adxrs450_channels[2][2] = {\n\t[ID_ADXRS450] = {\n\t\t{\n\t\t\t.type = IIO_ANGL_VEL,\n\t\t\t.modified = 1,\n\t\t\t.channel2 = IIO_MOD_Z,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS) |\n\t\t\tBIT(IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t}, {\n\t\t\t.type = IIO_TEMP,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t}\n\t},\n\t[ID_ADXRS453] = {\n\t\t{\n\t\t\t.type = IIO_ANGL_VEL,\n\t\t\t.modified = 1,\n\t\t\t.channel2 = IIO_MOD_Z,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW),\n\t\t}, {\n\t\t\t.type = IIO_TEMP,\n\t\t\t.indexed = 1,\n\t\t\t.channel = 0,\n\t\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t}\n\t},\n};\n\nstatic const struct iio_info adxrs450_info = {\n\t.read_raw = &adxrs450_read_raw,\n\t.write_raw = &adxrs450_write_raw,\n};\n\nstatic int adxrs450_probe(struct spi_device *spi)\n{\n\tint ret;\n\tstruct adxrs450_state *st;\n\tstruct iio_dev *indio_dev;\n\n\t \n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tst = iio_priv(indio_dev);\n\tst->us = spi;\n\tmutex_init(&st->buf_lock);\n\t \n\tspi_set_drvdata(spi, indio_dev);\n\n\tindio_dev->info = &adxrs450_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels =\n\t\tadxrs450_channels[spi_get_device_id(spi)->driver_data];\n\tindio_dev->num_channels = ARRAY_SIZE(adxrs450_channels);\n\tindio_dev->name = spi->dev.driver->name;\n\n\tret = devm_iio_device_register(&spi->dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = adxrs450_initial_setup(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct spi_device_id adxrs450_id[] = {\n\t{\"adxrs450\", ID_ADXRS450},\n\t{\"adxrs453\", ID_ADXRS453},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, adxrs450_id);\n\nstatic struct spi_driver adxrs450_driver = {\n\t.driver = {\n\t\t.name = \"adxrs450\",\n\t},\n\t.probe = adxrs450_probe,\n\t.id_table\t= adxrs450_id,\n};\nmodule_spi_driver(adxrs450_driver);\n\nMODULE_AUTHOR(\"Cliff Cai <cliff.cai@xxxxxxxxxx>\");\nMODULE_DESCRIPTION(\"Analog Devices ADXRS450/ADXRS453 Gyroscope SPI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}