{
  "module_name": "bmg160_core.c",
  "hash_id": "b81ad12176555fd8f189513b8e774a3d4c0924aca50ffce85af1c076040b51d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/gyro/bmg160_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/events.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include \"bmg160.h\"\n\n#define BMG160_IRQ_NAME\t\t\"bmg160_event\"\n\n#define BMG160_REG_CHIP_ID\t\t0x00\n#define BMG160_CHIP_ID_VAL\t\t0x0F\n\n#define BMG160_REG_PMU_LPW\t\t0x11\n#define BMG160_MODE_NORMAL\t\t0x00\n#define BMG160_MODE_DEEP_SUSPEND\t0x20\n#define BMG160_MODE_SUSPEND\t\t0x80\n\n#define BMG160_REG_RANGE\t\t0x0F\n\n#define BMG160_RANGE_2000DPS\t\t0\n#define BMG160_RANGE_1000DPS\t\t1\n#define BMG160_RANGE_500DPS\t\t2\n#define BMG160_RANGE_250DPS\t\t3\n#define BMG160_RANGE_125DPS\t\t4\n\n#define BMG160_REG_PMU_BW\t\t0x10\n#define BMG160_NO_FILTER\t\t0\n#define BMG160_DEF_BW\t\t\t100\n#define BMG160_REG_PMU_BW_RES\t\tBIT(7)\n\n#define BMG160_GYRO_REG_RESET\t\t0x14\n#define BMG160_GYRO_RESET_VAL\t\t0xb6\n\n#define BMG160_REG_INT_MAP_0\t\t0x17\n#define BMG160_INT_MAP_0_BIT_ANY\tBIT(1)\n\n#define BMG160_REG_INT_MAP_1\t\t0x18\n#define BMG160_INT_MAP_1_BIT_NEW_DATA\tBIT(0)\n\n#define BMG160_REG_INT_RST_LATCH\t0x21\n#define BMG160_INT_MODE_LATCH_RESET\t0x80\n#define BMG160_INT_MODE_LATCH_INT\t0x0F\n#define BMG160_INT_MODE_NON_LATCH_INT\t0x00\n\n#define BMG160_REG_INT_EN_0\t\t0x15\n#define BMG160_DATA_ENABLE_INT\t\tBIT(7)\n\n#define BMG160_REG_INT_EN_1\t\t0x16\n#define BMG160_INT1_BIT_OD\t\tBIT(1)\n\n#define BMG160_REG_XOUT_L\t\t0x02\n#define BMG160_AXIS_TO_REG(axis)\t(BMG160_REG_XOUT_L + (axis * 2))\n\n#define BMG160_REG_SLOPE_THRES\t\t0x1B\n#define BMG160_SLOPE_THRES_MASK\t0x0F\n\n#define BMG160_REG_MOTION_INTR\t\t0x1C\n#define BMG160_INT_MOTION_X\t\tBIT(0)\n#define BMG160_INT_MOTION_Y\t\tBIT(1)\n#define BMG160_INT_MOTION_Z\t\tBIT(2)\n#define BMG160_ANY_DUR_MASK\t\t0x30\n#define BMG160_ANY_DUR_SHIFT\t\t4\n\n#define BMG160_REG_INT_STATUS_2\t0x0B\n#define BMG160_ANY_MOTION_MASK\t\t0x07\n#define BMG160_ANY_MOTION_BIT_X\t\tBIT(0)\n#define BMG160_ANY_MOTION_BIT_Y\t\tBIT(1)\n#define BMG160_ANY_MOTION_BIT_Z\t\tBIT(2)\n\n#define BMG160_REG_TEMP\t\t0x08\n#define BMG160_TEMP_CENTER_VAL\t\t23\n\n#define BMG160_MAX_STARTUP_TIME_MS\t80\n\n#define BMG160_AUTO_SUSPEND_DELAY_MS\t2000\n\nstruct bmg160_data {\n\tstruct regmap *regmap;\n\tstruct iio_trigger *dready_trig;\n\tstruct iio_trigger *motion_trig;\n\tstruct iio_mount_matrix orientation;\n\tstruct mutex mutex;\n\t \n\tstruct {\n\t\ts16 chans[3];\n\t\ts64 timestamp __aligned(8);\n\t} scan;\n\tu32 dps_range;\n\tint ev_enable_state;\n\tint slope_thres;\n\tbool dready_trigger_on;\n\tbool motion_trigger_on;\n\tint irq;\n};\n\nenum bmg160_axis {\n\tAXIS_X,\n\tAXIS_Y,\n\tAXIS_Z,\n\tAXIS_MAX,\n};\n\nstatic const struct {\n\tint odr;\n\tint filter;\n\tint bw_bits;\n} bmg160_samp_freq_table[] = { {100, 32, 0x07},\n\t\t\t       {200, 64, 0x06},\n\t\t\t       {100, 12, 0x05},\n\t\t\t       {200, 23, 0x04},\n\t\t\t       {400, 47, 0x03},\n\t\t\t       {1000, 116, 0x02},\n\t\t\t       {2000, 230, 0x01} };\n\nstatic const struct {\n\tint scale;\n\tint dps_range;\n} bmg160_scale_table[] = { { 1065, BMG160_RANGE_2000DPS},\n\t\t\t   { 532, BMG160_RANGE_1000DPS},\n\t\t\t   { 266, BMG160_RANGE_500DPS},\n\t\t\t   { 133, BMG160_RANGE_250DPS},\n\t\t\t   { 66, BMG160_RANGE_125DPS} };\n\nstatic int bmg160_set_mode(struct bmg160_data *data, u8 mode)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\n\tret = regmap_write(data->regmap, BMG160_REG_PMU_LPW, mode);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error writing reg_pmu_lpw\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmg160_convert_freq_to_bit(int val)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bmg160_samp_freq_table); ++i) {\n\t\tif (bmg160_samp_freq_table[i].odr == val)\n\t\t\treturn bmg160_samp_freq_table[i].bw_bits;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int bmg160_set_bw(struct bmg160_data *data, int val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\tint bw_bits;\n\n\tbw_bits = bmg160_convert_freq_to_bit(val);\n\tif (bw_bits < 0)\n\t\treturn bw_bits;\n\n\tret = regmap_write(data->regmap, BMG160_REG_PMU_BW, bw_bits);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error writing reg_pmu_bw\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmg160_get_filter(struct bmg160_data *data, int *val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\tint i;\n\tunsigned int bw_bits;\n\n\tret = regmap_read(data->regmap, BMG160_REG_PMU_BW, &bw_bits);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading reg_pmu_bw\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tbw_bits &= ~BMG160_REG_PMU_BW_RES;\n\n\tfor (i = 0; i < ARRAY_SIZE(bmg160_samp_freq_table); ++i) {\n\t\tif (bmg160_samp_freq_table[i].bw_bits == bw_bits)\n\t\t\tbreak;\n\t}\n\n\t*val = bmg160_samp_freq_table[i].filter;\n\n\treturn ret ? ret : IIO_VAL_INT;\n}\n\n\nstatic int bmg160_set_filter(struct bmg160_data *data, int val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bmg160_samp_freq_table); ++i) {\n\t\tif (bmg160_samp_freq_table[i].filter == val)\n\t\t\tbreak;\n\t}\n\n\tret = regmap_write(data->regmap, BMG160_REG_PMU_BW,\n\t\t\t   bmg160_samp_freq_table[i].bw_bits);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error writing reg_pmu_bw\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmg160_chip_init(struct bmg160_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\tunsigned int val;\n\n\t \n\tregmap_write(data->regmap, BMG160_GYRO_REG_RESET,\n\t\t     BMG160_GYRO_RESET_VAL);\n\tusleep_range(30000, 30700);\n\n\tret = regmap_read(data->regmap, BMG160_REG_CHIP_ID, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading reg_chip_id\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"Chip Id %x\\n\", val);\n\tif (val != BMG160_CHIP_ID_VAL) {\n\t\tdev_err(dev, \"invalid chip %x\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tret = bmg160_set_mode(data, BMG160_MODE_NORMAL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tusleep_range(500, 1000);\n\n\t \n\tret = bmg160_set_bw(data, BMG160_DEF_BW);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(data->regmap, BMG160_REG_RANGE, BMG160_RANGE_500DPS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error writing reg_range\\n\");\n\t\treturn ret;\n\t}\n\tdata->dps_range = BMG160_RANGE_500DPS;\n\n\tret = regmap_read(data->regmap, BMG160_REG_SLOPE_THRES, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading reg_slope_thres\\n\");\n\t\treturn ret;\n\t}\n\tdata->slope_thres = val;\n\n\t \n\tret = regmap_update_bits(data->regmap, BMG160_REG_INT_EN_1,\n\t\t\t\t BMG160_INT1_BIT_OD, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error updating bits in reg_int_en_1\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(data->regmap, BMG160_REG_INT_RST_LATCH,\n\t\t\t   BMG160_INT_MODE_LATCH_INT |\n\t\t\t   BMG160_INT_MODE_LATCH_RESET);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"Error writing reg_motion_intr\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmg160_set_power_state(struct bmg160_data *data, bool on)\n{\n#ifdef CONFIG_PM\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\n\tif (on)\n\t\tret = pm_runtime_get_sync(dev);\n\telse {\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tret = pm_runtime_put_autosuspend(dev);\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed: bmg160_set_power_state for %d\\n\", on);\n\n\t\tif (on)\n\t\t\tpm_runtime_put_noidle(dev);\n\n\t\treturn ret;\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic int bmg160_setup_any_motion_interrupt(struct bmg160_data *data,\n\t\t\t\t\t     bool status)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, BMG160_REG_INT_MAP_0,\n\t\t\t\t BMG160_INT_MAP_0_BIT_ANY,\n\t\t\t\t (status ? BMG160_INT_MAP_0_BIT_ANY : 0));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error updating bits reg_int_map0\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (status) {\n\t\t \n\t\tret = regmap_write(data->regmap, BMG160_REG_SLOPE_THRES,\n\t\t\t\t   data->slope_thres);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Error writing reg_slope_thres\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_write(data->regmap, BMG160_REG_MOTION_INTR,\n\t\t\t\t   BMG160_INT_MOTION_X | BMG160_INT_MOTION_Y |\n\t\t\t\t   BMG160_INT_MOTION_Z);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Error writing reg_motion_intr\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (!data->dready_trigger_on) {\n\t\t\tret = regmap_write(data->regmap,\n\t\t\t\t\t   BMG160_REG_INT_RST_LATCH,\n\t\t\t\t\t   BMG160_INT_MODE_LATCH_INT |\n\t\t\t\t\t   BMG160_INT_MODE_LATCH_RESET);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"Error writing reg_rst_latch\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = regmap_write(data->regmap, BMG160_REG_INT_EN_0,\n\t\t\t\t   BMG160_DATA_ENABLE_INT);\n\n\t} else {\n\t\tret = regmap_write(data->regmap, BMG160_REG_INT_EN_0, 0);\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error writing reg_int_en0\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmg160_setup_new_data_interrupt(struct bmg160_data *data,\n\t\t\t\t\t   bool status)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, BMG160_REG_INT_MAP_1,\n\t\t\t\t BMG160_INT_MAP_1_BIT_NEW_DATA,\n\t\t\t\t (status ? BMG160_INT_MAP_1_BIT_NEW_DATA : 0));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error updating bits in reg_int_map1\\n\");\n\t\treturn ret;\n\t}\n\n\tif (status) {\n\t\tret = regmap_write(data->regmap, BMG160_REG_INT_RST_LATCH,\n\t\t\t\t   BMG160_INT_MODE_NON_LATCH_INT |\n\t\t\t\t   BMG160_INT_MODE_LATCH_RESET);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Error writing reg_rst_latch\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_write(data->regmap, BMG160_REG_INT_EN_0,\n\t\t\t\t   BMG160_DATA_ENABLE_INT);\n\n\t} else {\n\t\t \n\t\tret = regmap_write(data->regmap, BMG160_REG_INT_RST_LATCH,\n\t\t\t\t   BMG160_INT_MODE_LATCH_INT |\n\t\t\t\t   BMG160_INT_MODE_LATCH_RESET);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Error writing reg_rst_latch\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_write(data->regmap, BMG160_REG_INT_EN_0, 0);\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error writing reg_int_en0\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmg160_get_bw(struct bmg160_data *data, int *val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\t\n\tint i;\n\tunsigned int bw_bits;\n\tint ret;\n\n\tret = regmap_read(data->regmap, BMG160_REG_PMU_BW, &bw_bits);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading reg_pmu_bw\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tbw_bits &= ~BMG160_REG_PMU_BW_RES;\n\n\tfor (i = 0; i < ARRAY_SIZE(bmg160_samp_freq_table); ++i) {\n\t\tif (bmg160_samp_freq_table[i].bw_bits == bw_bits) {\n\t\t\t*val = bmg160_samp_freq_table[i].odr;\n\t\t\treturn IIO_VAL_INT;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int bmg160_set_scale(struct bmg160_data *data, int val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bmg160_scale_table); ++i) {\n\t\tif (bmg160_scale_table[i].scale == val) {\n\t\t\tret = regmap_write(data->regmap, BMG160_REG_RANGE,\n\t\t\t\t\t   bmg160_scale_table[i].dps_range);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"Error writing reg_range\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdata->dps_range = bmg160_scale_table[i].dps_range;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int bmg160_get_temp(struct bmg160_data *data, int *val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\tunsigned int raw_val;\n\n\tmutex_lock(&data->mutex);\n\tret = bmg160_set_power_state(data, true);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(data->regmap, BMG160_REG_TEMP, &raw_val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading reg_temp\\n\");\n\t\tbmg160_set_power_state(data, false);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\n\t*val = sign_extend32(raw_val, 7);\n\tret = bmg160_set_power_state(data, false);\n\tmutex_unlock(&data->mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int bmg160_get_axis(struct bmg160_data *data, int axis, int *val)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\t__le16 raw_val;\n\n\tmutex_lock(&data->mutex);\n\tret = bmg160_set_power_state(data, true);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\n\tret = regmap_bulk_read(data->regmap, BMG160_AXIS_TO_REG(axis), &raw_val,\n\t\t\t       sizeof(raw_val));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading axis %d\\n\", axis);\n\t\tbmg160_set_power_state(data, false);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\n\t*val = sign_extend32(le16_to_cpu(raw_val), 15);\n\tret = bmg160_set_power_state(data, false);\n\tmutex_unlock(&data->mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int bmg160_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\treturn bmg160_get_temp(data, val);\n\t\tcase IIO_ANGL_VEL:\n\t\t\tif (iio_buffer_enabled(indio_dev))\n\t\t\t\treturn -EBUSY;\n\t\t\telse\n\t\t\t\treturn bmg160_get_axis(data, chan->scan_index,\n\t\t\t\t\t\t       val);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tif (chan->type == IIO_TEMP) {\n\t\t\t*val = BMG160_TEMP_CENTER_VAL;\n\t\t\treturn IIO_VAL_INT;\n\t\t} else\n\t\t\treturn -EINVAL;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn bmg160_get_filter(data, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t*val = 500;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_ANGL_VEL:\n\t\t{\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < ARRAY_SIZE(bmg160_scale_table); ++i) {\n\t\t\t\tif (bmg160_scale_table[i].dps_range ==\n\t\t\t\t\t\t\tdata->dps_range) {\n\t\t\t\t\t*val = 0;\n\t\t\t\t\t*val2 = bmg160_scale_table[i].scale;\n\t\t\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val2 = 0;\n\t\tmutex_lock(&data->mutex);\n\t\tret = bmg160_get_bw(data, val);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bmg160_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tmutex_lock(&data->mutex);\n\t\t \n\t\tret = bmg160_set_power_state(data, true);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tret = bmg160_set_bw(data, val);\n\t\tif (ret < 0) {\n\t\t\tbmg160_set_power_state(data, false);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tret = bmg160_set_power_state(data, false);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tif (val2)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&data->mutex);\n\t\tret = bmg160_set_power_state(data, true);\n\t\tif (ret < 0) {\n\t\t\tbmg160_set_power_state(data, false);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tret = bmg160_set_filter(data, val);\n\t\tif (ret < 0) {\n\t\t\tbmg160_set_power_state(data, false);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tret = bmg160_set_power_state(data, false);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (val)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&data->mutex);\n\t\t \n\t\tret = bmg160_set_power_state(data, true);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tret = bmg160_set_scale(data, val2);\n\t\tif (ret < 0) {\n\t\t\tbmg160_set_power_state(data, false);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tret = bmg160_set_power_state(data, false);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int bmg160_read_event(struct iio_dev *indio_dev,\n\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t     enum iio_event_type type,\n\t\t\t     enum iio_event_direction dir,\n\t\t\t     enum iio_event_info info,\n\t\t\t     int *val, int *val2)\n{\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\n\t*val2 = 0;\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\t*val = data->slope_thres & BMG160_SLOPE_THRES_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int bmg160_write_event(struct iio_dev *indio_dev,\n\t\t\t      const struct iio_chan_spec *chan,\n\t\t\t      enum iio_event_type type,\n\t\t\t      enum iio_event_direction dir,\n\t\t\t      enum iio_event_info info,\n\t\t\t      int val, int val2)\n{\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\tif (data->ev_enable_state)\n\t\t\treturn -EBUSY;\n\t\tdata->slope_thres &= ~BMG160_SLOPE_THRES_MASK;\n\t\tdata->slope_thres |= (val & BMG160_SLOPE_THRES_MASK);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmg160_read_event_config(struct iio_dev *indio_dev,\n\t\t\t\t    const struct iio_chan_spec *chan,\n\t\t\t\t    enum iio_event_type type,\n\t\t\t\t    enum iio_event_direction dir)\n{\n\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\n\treturn data->ev_enable_state;\n}\n\nstatic int bmg160_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t\t     enum iio_event_type type,\n\t\t\t\t     enum iio_event_direction dir,\n\t\t\t\t     int state)\n{\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (state && data->ev_enable_state)\n\t\treturn 0;\n\n\tmutex_lock(&data->mutex);\n\n\tif (!state && data->motion_trigger_on) {\n\t\tdata->ev_enable_state = 0;\n\t\tmutex_unlock(&data->mutex);\n\t\treturn 0;\n\t}\n\t \n\tret = bmg160_set_power_state(data, state);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\n\tret =  bmg160_setup_any_motion_interrupt(data, state);\n\tif (ret < 0) {\n\t\tbmg160_set_power_state(data, false);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\n\tdata->ev_enable_state = state;\n\tmutex_unlock(&data->mutex);\n\n\treturn 0;\n}\n\nstatic const struct iio_mount_matrix *\nbmg160_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\t const struct iio_chan_spec *chan)\n{\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\n\treturn &data->orientation;\n}\n\nstatic const struct iio_chan_spec_ext_info bmg160_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_DIR, bmg160_get_mount_matrix),\n\t{ }\n};\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\"100 200 400 1000 2000\");\n\nstatic IIO_CONST_ATTR(in_anglvel_scale_available,\n\t\t      \"0.001065 0.000532 0.000266 0.000133 0.000066\");\n\nstatic struct attribute *bmg160_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_const_attr_in_anglvel_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group bmg160_attrs_group = {\n\t.attrs = bmg160_attributes,\n};\n\nstatic const struct iio_event_spec bmg160_event = {\n\t\t.type = IIO_EV_TYPE_ROC,\n\t\t.dir = IIO_EV_DIR_EITHER,\n\t\t.mask_shared_by_type = BIT(IIO_EV_INFO_VALUE) |\n\t\t\t\t       BIT(IIO_EV_INFO_ENABLE)\n};\n\n#define BMG160_CHANNEL(_axis) {\t\t\t\t\t\\\n\t.type = IIO_ANGL_VEL,\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##_axis,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\t\\\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ) |\t\t\t\t\\\n\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\t\\\n\t.scan_index = AXIS_##_axis,\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\t\\\n\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t.storagebits = 16,\t\t\t\t\t\\\n\t\t.endianness = IIO_LE,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.ext_info = bmg160_ext_info,\t\t\t\t\t\\\n\t.event_spec = &bmg160_event,\t\t\t\t\t\\\n\t.num_event_specs = 1\t\t\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec bmg160_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.scan_index = -1,\n\t},\n\tBMG160_CHANNEL(X),\n\tBMG160_CHANNEL(Y),\n\tBMG160_CHANNEL(Z),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic const struct iio_info bmg160_info = {\n\t.attrs\t\t\t= &bmg160_attrs_group,\n\t.read_raw\t\t= bmg160_read_raw,\n\t.write_raw\t\t= bmg160_write_raw,\n\t.read_event_value\t= bmg160_read_event,\n\t.write_event_value\t= bmg160_write_event,\n\t.write_event_config\t= bmg160_write_event_config,\n\t.read_event_config\t= bmg160_read_event_config,\n};\n\nstatic const unsigned long bmg160_accel_scan_masks[] = {\n\t\t\t\t\tBIT(AXIS_X) | BIT(AXIS_Y) | BIT(AXIS_Z),\n\t\t\t\t\t0};\n\nstatic irqreturn_t bmg160_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = regmap_bulk_read(data->regmap, BMG160_REG_XOUT_L,\n\t\t\t       data->scan.chans, AXIS_MAX * 2);\n\tmutex_unlock(&data->mutex);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t   pf->timestamp);\nerr:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void bmg160_trig_reen(struct iio_trigger *trig)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\n\t \n\tif (data->dready_trigger_on)\n\t\treturn;\n\n\t \n\tret = regmap_write(data->regmap, BMG160_REG_INT_RST_LATCH,\n\t\t\t   BMG160_INT_MODE_LATCH_INT |\n\t\t\t   BMG160_INT_MODE_LATCH_RESET);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Error writing reg_rst_latch\\n\");\n}\n\nstatic int bmg160_data_rdy_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t     bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\n\tif (!state && data->ev_enable_state && data->motion_trigger_on) {\n\t\tdata->motion_trigger_on = false;\n\t\tmutex_unlock(&data->mutex);\n\t\treturn 0;\n\t}\n\n\t \n\tret = bmg160_set_power_state(data, state);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\tif (data->motion_trig == trig)\n\t\tret =  bmg160_setup_any_motion_interrupt(data, state);\n\telse\n\t\tret = bmg160_setup_new_data_interrupt(data, state);\n\tif (ret < 0) {\n\t\tbmg160_set_power_state(data, false);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\t}\n\tif (data->motion_trig == trig)\n\t\tdata->motion_trigger_on = state;\n\telse\n\t\tdata->dready_trigger_on = state;\n\n\tmutex_unlock(&data->mutex);\n\n\treturn 0;\n}\n\nstatic const struct iio_trigger_ops bmg160_trigger_ops = {\n\t.set_trigger_state = bmg160_data_rdy_trigger_set_state,\n\t.reenable = bmg160_trig_reen,\n};\n\nstatic irqreturn_t bmg160_event_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\tint dir;\n\tunsigned int val;\n\n\tret = regmap_read(data->regmap, BMG160_REG_INT_STATUS_2, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading reg_int_status2\\n\");\n\t\tgoto ack_intr_status;\n\t}\n\n\tif (val & 0x08)\n\t\tdir = IIO_EV_DIR_RISING;\n\telse\n\t\tdir = IIO_EV_DIR_FALLING;\n\n\tif (val & BMG160_ANY_MOTION_BIT_X)\n\t\tiio_push_event(indio_dev, IIO_MOD_EVENT_CODE(IIO_ANGL_VEL,\n\t\t\t\t\t\t\t     0,\n\t\t\t\t\t\t\t     IIO_MOD_X,\n\t\t\t\t\t\t\t     IIO_EV_TYPE_ROC,\n\t\t\t\t\t\t\t     dir),\n\t\t\t       iio_get_time_ns(indio_dev));\n\tif (val & BMG160_ANY_MOTION_BIT_Y)\n\t\tiio_push_event(indio_dev, IIO_MOD_EVENT_CODE(IIO_ANGL_VEL,\n\t\t\t\t\t\t\t     0,\n\t\t\t\t\t\t\t     IIO_MOD_Y,\n\t\t\t\t\t\t\t     IIO_EV_TYPE_ROC,\n\t\t\t\t\t\t\t     dir),\n\t\t\t       iio_get_time_ns(indio_dev));\n\tif (val & BMG160_ANY_MOTION_BIT_Z)\n\t\tiio_push_event(indio_dev, IIO_MOD_EVENT_CODE(IIO_ANGL_VEL,\n\t\t\t\t\t\t\t     0,\n\t\t\t\t\t\t\t     IIO_MOD_Z,\n\t\t\t\t\t\t\t     IIO_EV_TYPE_ROC,\n\t\t\t\t\t\t\t     dir),\n\t\t\t       iio_get_time_ns(indio_dev));\n\nack_intr_status:\n\tif (!data->dready_trigger_on) {\n\t\tret = regmap_write(data->regmap, BMG160_REG_INT_RST_LATCH,\n\t\t\t\t   BMG160_INT_MODE_LATCH_INT |\n\t\t\t\t   BMG160_INT_MODE_LATCH_RESET);\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"Error writing reg_rst_latch\\n\");\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t bmg160_data_rdy_trig_poll(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\n\tif (data->dready_trigger_on)\n\t\tiio_trigger_poll(data->dready_trig);\n\telse if (data->motion_trigger_on)\n\t\tiio_trigger_poll(data->motion_trig);\n\n\tif (data->ev_enable_state)\n\t\treturn IRQ_WAKE_THREAD;\n\telse\n\t\treturn IRQ_HANDLED;\n\n}\n\nstatic int bmg160_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\n\treturn bmg160_set_power_state(data, true);\n}\n\nstatic int bmg160_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\n\treturn bmg160_set_power_state(data, false);\n}\n\nstatic const struct iio_buffer_setup_ops bmg160_buffer_setup_ops = {\n\t.preenable = bmg160_buffer_preenable,\n\t.postdisable = bmg160_buffer_postdisable,\n};\n\nstatic const char *bmg160_match_acpi_device(struct device *dev)\n{\n\tconst struct acpi_device_id *id;\n\n\tid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\tif (!id)\n\t\treturn NULL;\n\n\treturn dev_name(dev);\n}\n\nint bmg160_core_probe(struct device *dev, struct regmap *regmap, int irq,\n\t\t      const char *name)\n{\n\tstatic const char * const regulators[] = { \"vdd\", \"vddio\" };\n\tstruct bmg160_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdev_set_drvdata(dev, indio_dev);\n\tdata->irq = irq;\n\tdata->regmap = regmap;\n\n\tret = devm_regulator_bulk_get_enable(dev, ARRAY_SIZE(regulators),\n\t\t\t\t\t     regulators);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to get regulators\\n\");\n\n\tret = iio_read_mount_matrix(dev, &data->orientation);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bmg160_chip_init(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_init(&data->mutex);\n\n\tif (ACPI_HANDLE(dev))\n\t\tname = bmg160_match_acpi_device(dev);\n\n\tindio_dev->channels = bmg160_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(bmg160_channels);\n\tindio_dev->name = name;\n\tindio_dev->available_scan_masks = bmg160_accel_scan_masks;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &bmg160_info;\n\n\tif (data->irq > 0) {\n\t\tret = devm_request_threaded_irq(dev,\n\t\t\t\t\t\tdata->irq,\n\t\t\t\t\t\tbmg160_data_rdy_trig_poll,\n\t\t\t\t\t\tbmg160_event_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING,\n\t\t\t\t\t\tBMG160_IRQ_NAME,\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata->dready_trig = devm_iio_trigger_alloc(dev,\n\t\t\t\t\t\t\t   \"%s-dev%d\",\n\t\t\t\t\t\t\t   indio_dev->name,\n\t\t\t\t\t\t\t   iio_device_id(indio_dev));\n\t\tif (!data->dready_trig)\n\t\t\treturn -ENOMEM;\n\n\t\tdata->motion_trig = devm_iio_trigger_alloc(dev,\n\t\t\t\t\t\t\t  \"%s-any-motion-dev%d\",\n\t\t\t\t\t\t\t  indio_dev->name,\n\t\t\t\t\t\t\t  iio_device_id(indio_dev));\n\t\tif (!data->motion_trig)\n\t\t\treturn -ENOMEM;\n\n\t\tdata->dready_trig->ops = &bmg160_trigger_ops;\n\t\tiio_trigger_set_drvdata(data->dready_trig, indio_dev);\n\t\tret = iio_trigger_register(data->dready_trig);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata->motion_trig->ops = &bmg160_trigger_ops;\n\t\tiio_trigger_set_drvdata(data->motion_trig, indio_dev);\n\t\tret = iio_trigger_register(data->motion_trig);\n\t\tif (ret) {\n\t\t\tdata->motion_trig = NULL;\n\t\t\tgoto err_trigger_unregister;\n\t\t}\n\t}\n\n\tret = iio_triggered_buffer_setup(indio_dev,\n\t\t\t\t\t iio_pollfunc_store_time,\n\t\t\t\t\t bmg160_trigger_handler,\n\t\t\t\t\t &bmg160_buffer_setup_ops);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"iio triggered buffer setup failed\\n\");\n\t\tgoto err_trigger_unregister;\n\t}\n\n\tret = pm_runtime_set_active(dev);\n\tif (ret)\n\t\tgoto err_buffer_cleanup;\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev,\n\t\t\t\t\t BMG160_AUTO_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to register iio device\\n\");\n\t\tgoto err_pm_cleanup;\n\t}\n\n\treturn 0;\n\nerr_pm_cleanup:\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\nerr_buffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\nerr_trigger_unregister:\n\tif (data->dready_trig)\n\t\tiio_trigger_unregister(data->dready_trig);\n\tif (data->motion_trig)\n\t\tiio_trigger_unregister(data->motion_trig);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(bmg160_core_probe);\n\nvoid bmg160_core_remove(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_put_noidle(dev);\n\n\tiio_triggered_buffer_cleanup(indio_dev);\n\n\tif (data->dready_trig) {\n\t\tiio_trigger_unregister(data->dready_trig);\n\t\tiio_trigger_unregister(data->motion_trig);\n\t}\n\n\tmutex_lock(&data->mutex);\n\tbmg160_set_mode(data, BMG160_MODE_DEEP_SUSPEND);\n\tmutex_unlock(&data->mutex);\n}\nEXPORT_SYMBOL_GPL(bmg160_core_remove);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int bmg160_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\n\tmutex_lock(&data->mutex);\n\tbmg160_set_mode(data, BMG160_MODE_SUSPEND);\n\tmutex_unlock(&data->mutex);\n\n\treturn 0;\n}\n\nstatic int bmg160_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\n\tmutex_lock(&data->mutex);\n\tif (data->dready_trigger_on || data->motion_trigger_on ||\n\t\t\t\t\t\t\tdata->ev_enable_state)\n\t\tbmg160_set_mode(data, BMG160_MODE_NORMAL);\n\tmutex_unlock(&data->mutex);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int bmg160_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = bmg160_set_mode(data, BMG160_MODE_SUSPEND);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"set mode failed\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmg160_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmg160_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = bmg160_set_mode(data, BMG160_MODE_NORMAL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep_interruptible(BMG160_MAX_STARTUP_TIME_MS);\n\n\treturn 0;\n}\n#endif\n\nconst struct dev_pm_ops bmg160_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(bmg160_suspend, bmg160_resume)\n\tSET_RUNTIME_PM_OPS(bmg160_runtime_suspend,\n\t\t\t   bmg160_runtime_resume, NULL)\n};\nEXPORT_SYMBOL_GPL(bmg160_pm_ops);\n\nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"BMG160 Gyro driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}