{
  "module_name": "st_gyro_core.c",
  "hash_id": "b892f1c42142a9b0bfd2cf95cd0b9b8aa0c9205b9f639f1e222d2032c251f2b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/gyro/st_gyro_core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/interrupt.h>\n#include <linux/sysfs.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n\n#include <linux/iio/common/st_sensors.h>\n#include \"st_gyro.h\"\n\n#define ST_GYRO_NUMBER_DATA_CHANNELS\t\t3\n\n \n#define ST_GYRO_DEFAULT_OUT_X_L_ADDR\t\t0x28\n#define ST_GYRO_DEFAULT_OUT_Y_L_ADDR\t\t0x2a\n#define ST_GYRO_DEFAULT_OUT_Z_L_ADDR\t\t0x2c\n\n \n#define ST_GYRO_FS_AVL_245DPS\t\t\t245\n#define ST_GYRO_FS_AVL_250DPS\t\t\t250\n#define ST_GYRO_FS_AVL_500DPS\t\t\t500\n#define ST_GYRO_FS_AVL_2000DPS\t\t\t2000\n\nstatic const struct iio_mount_matrix *\nst_gyro_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\t const struct iio_chan_spec *chan)\n{\n\tstruct st_sensor_data *gdata = iio_priv(indio_dev);\n\n\treturn &gdata->mount_matrix;\n}\n\nstatic const struct iio_chan_spec_ext_info st_gyro_mount_matrix_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_ALL, st_gyro_get_mount_matrix),\n\t{ }\n};\n\nstatic const struct iio_chan_spec st_gyro_16bit_channels[] = {\n\tST_SENSORS_LSM_CHANNELS_EXT(IIO_ANGL_VEL,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_X, 1, IIO_MOD_X, 's', IIO_LE, 16, 16,\n\t\t\tST_GYRO_DEFAULT_OUT_X_L_ADDR,\n\t\t\tst_gyro_mount_matrix_ext_info),\n\tST_SENSORS_LSM_CHANNELS_EXT(IIO_ANGL_VEL,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_Y, 1, IIO_MOD_Y, 's', IIO_LE, 16, 16,\n\t\t\tST_GYRO_DEFAULT_OUT_Y_L_ADDR,\n\t\t\tst_gyro_mount_matrix_ext_info),\n\tST_SENSORS_LSM_CHANNELS_EXT(IIO_ANGL_VEL,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_Z, 1, IIO_MOD_Z, 's', IIO_LE, 16, 16,\n\t\t\tST_GYRO_DEFAULT_OUT_Z_L_ADDR,\n\t\t\tst_gyro_mount_matrix_ext_info),\n\tIIO_CHAN_SOFT_TIMESTAMP(3)\n};\n\nstatic const struct st_sensor_settings st_gyro_sensors_settings[] = {\n\t{\n\t\t.wai = 0xd3,\n\t\t.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,\n\t\t.sensors_supported = {\n\t\t\t[0] = L3G4200D_GYRO_DEV_NAME,\n\t\t\t[1] = LSM330DL_GYRO_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_gyro_16bit_channels,\n\t\t.odr = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0xc0,\n\t\t\t.odr_avl = {\n\t\t\t\t{ .hz = 100, .value = 0x00, },\n\t\t\t\t{ .hz = 200, .value = 0x01, },\n\t\t\t\t{ .hz = 400, .value = 0x02, },\n\t\t\t\t{ .hz = 800, .value = 0x03, },\n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0x08,\n\t\t\t.value_on = ST_SENSORS_DEFAULT_POWER_ON_VALUE,\n\t\t\t.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,\n\t\t},\n\t\t.enable_axis = {\n\t\t\t.addr = ST_SENSORS_DEFAULT_AXIS_ADDR,\n\t\t\t.mask = ST_SENSORS_DEFAULT_AXIS_MASK,\n\t\t},\n\t\t.fs = {\n\t\t\t.addr = 0x23,\n\t\t\t.mask = 0x30,\n\t\t\t.fs_avl = {\n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_GYRO_FS_AVL_250DPS,\n\t\t\t\t\t.value = 0x00,\n\t\t\t\t\t.gain = IIO_DEGREE_TO_RAD(8750),\n\t\t\t\t},\n\t\t\t\t[1] = {\n\t\t\t\t\t.num = ST_GYRO_FS_AVL_500DPS,\n\t\t\t\t\t.value = 0x01,\n\t\t\t\t\t.gain = IIO_DEGREE_TO_RAD(17500),\n\t\t\t\t},\n\t\t\t\t[2] = {\n\t\t\t\t\t.num = ST_GYRO_FS_AVL_2000DPS,\n\t\t\t\t\t.value = 0x02,\n\t\t\t\t\t.gain = IIO_DEGREE_TO_RAD(70000),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x23,\n\t\t\t.mask = 0x80,\n\t\t},\n\t\t.drdy_irq = {\n\t\t\t.int2 = {\n\t\t\t\t.addr = 0x22,\n\t\t\t\t.mask = 0x08,\n\t\t\t},\n\t\t\t \n\t\t\t.stat_drdy = {\n\t\t\t\t.addr = ST_SENSORS_DEFAULT_STAT_ADDR,\n\t\t\t\t.mask = 0x07,\n\t\t\t},\n\t\t},\n\t\t.sim = {\n\t\t\t.addr = 0x23,\n\t\t\t.value = BIT(0),\n\t\t},\n\t\t.multi_read_bit = true,\n\t\t.bootime = 2,\n\t},\n\t{\n\t\t.wai = 0xd4,\n\t\t.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,\n\t\t.sensors_supported = {\n\t\t\t[0] = L3GD20_GYRO_DEV_NAME,\n\t\t\t[1] = LSM330D_GYRO_DEV_NAME,\n\t\t\t[2] = LSM330DLC_GYRO_DEV_NAME,\n\t\t\t[3] = L3G4IS_GYRO_DEV_NAME,\n\t\t\t[4] = LSM330_GYRO_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_gyro_16bit_channels,\n\t\t.odr = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0xc0,\n\t\t\t.odr_avl = {\n\t\t\t\t{ .hz = 95, .value = 0x00, },\n\t\t\t\t{ .hz = 190, .value = 0x01, },\n\t\t\t\t{ .hz = 380, .value = 0x02, },\n\t\t\t\t{ .hz = 760, .value = 0x03, },\n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0x08,\n\t\t\t.value_on = ST_SENSORS_DEFAULT_POWER_ON_VALUE,\n\t\t\t.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,\n\t\t},\n\t\t.enable_axis = {\n\t\t\t.addr = ST_SENSORS_DEFAULT_AXIS_ADDR,\n\t\t\t.mask = ST_SENSORS_DEFAULT_AXIS_MASK,\n\t\t},\n\t\t.fs = {\n\t\t\t.addr = 0x23,\n\t\t\t.mask = 0x30,\n\t\t\t.fs_avl = {\n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_GYRO_FS_AVL_250DPS,\n\t\t\t\t\t.value = 0x00,\n\t\t\t\t\t.gain = IIO_DEGREE_TO_RAD(8750),\n\t\t\t\t},\n\t\t\t\t[1] = {\n\t\t\t\t\t.num = ST_GYRO_FS_AVL_500DPS,\n\t\t\t\t\t.value = 0x01,\n\t\t\t\t\t.gain = IIO_DEGREE_TO_RAD(17500),\n\t\t\t\t},\n\t\t\t\t[2] = {\n\t\t\t\t\t.num = ST_GYRO_FS_AVL_2000DPS,\n\t\t\t\t\t.value = 0x02,\n\t\t\t\t\t.gain = IIO_DEGREE_TO_RAD(70000),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x23,\n\t\t\t.mask = 0x80,\n\t\t},\n\t\t.drdy_irq = {\n\t\t\t.int2 = {\n\t\t\t\t.addr = 0x22,\n\t\t\t\t.mask = 0x08,\n\t\t\t},\n\t\t\t \n\t\t\t.stat_drdy = {\n\t\t\t\t.addr = ST_SENSORS_DEFAULT_STAT_ADDR,\n\t\t\t\t.mask = 0x07,\n\t\t\t},\n\t\t},\n\t\t.sim = {\n\t\t\t.addr = 0x23,\n\t\t\t.value = BIT(0),\n\t\t},\n\t\t.multi_read_bit = true,\n\t\t.bootime = 2,\n\t},\n\t{\n\t\t.wai = 0xd4,\n\t\t.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,\n\t\t.sensors_supported = {\n\t\t\t[0] = LSM9DS0_GYRO_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_gyro_16bit_channels,\n\t\t.odr = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = GENMASK(7, 6),\n\t\t\t.odr_avl = {\n\t\t\t\t{ .hz = 95, .value = 0x00, },\n\t\t\t\t{ .hz = 190, .value = 0x01, },\n\t\t\t\t{ .hz = 380, .value = 0x02, },\n\t\t\t\t{ .hz = 760, .value = 0x03, },\n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = BIT(3),\n\t\t\t.value_on = ST_SENSORS_DEFAULT_POWER_ON_VALUE,\n\t\t\t.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,\n\t\t},\n\t\t.enable_axis = {\n\t\t\t.addr = ST_SENSORS_DEFAULT_AXIS_ADDR,\n\t\t\t.mask = ST_SENSORS_DEFAULT_AXIS_MASK,\n\t\t},\n\t\t.fs = {\n\t\t\t.addr = 0x23,\n\t\t\t.mask = GENMASK(5, 4),\n\t\t\t.fs_avl = {\n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_GYRO_FS_AVL_245DPS,\n\t\t\t\t\t.value = 0x00,\n\t\t\t\t\t.gain = IIO_DEGREE_TO_RAD(8750),\n\t\t\t\t},\n\t\t\t\t[1] = {\n\t\t\t\t\t.num = ST_GYRO_FS_AVL_500DPS,\n\t\t\t\t\t.value = 0x01,\n\t\t\t\t\t.gain = IIO_DEGREE_TO_RAD(17500),\n\t\t\t\t},\n\t\t\t\t[2] = {\n\t\t\t\t\t.num = ST_GYRO_FS_AVL_2000DPS,\n\t\t\t\t\t.value = 0x02,\n\t\t\t\t\t.gain = IIO_DEGREE_TO_RAD(70000),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x23,\n\t\t\t.mask = BIT(7),\n\t\t},\n\t\t.drdy_irq = {\n\t\t\t.int2 = {\n\t\t\t\t.addr = 0x22,\n\t\t\t\t.mask = BIT(3),\n\t\t\t},\n\t\t\t \n\t\t\t.stat_drdy = {\n\t\t\t\t.addr = ST_SENSORS_DEFAULT_STAT_ADDR,\n\t\t\t\t.mask = GENMASK(2, 0),\n\t\t\t},\n\t\t},\n\t\t.sim = {\n\t\t\t.addr = 0x23,\n\t\t\t.value = BIT(0),\n\t\t},\n\t\t.multi_read_bit = true,\n\t\t.bootime = 2,\n\t},\n\t{\n\t\t.wai = 0xd7,\n\t\t.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,\n\t\t.sensors_supported = {\n\t\t\t[0] = L3GD20H_GYRO_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_gyro_16bit_channels,\n\t\t.odr = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0xc0,\n\t\t\t.odr_avl = {\n\t\t\t\t{ .hz = 100, .value = 0x00, },\n\t\t\t\t{ .hz = 200, .value = 0x01, },\n\t\t\t\t{ .hz = 400, .value = 0x02, },\n\t\t\t\t{ .hz = 800, .value = 0x03, },\n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0x08,\n\t\t\t.value_on = ST_SENSORS_DEFAULT_POWER_ON_VALUE,\n\t\t\t.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,\n\t\t},\n\t\t.enable_axis = {\n\t\t\t.addr = ST_SENSORS_DEFAULT_AXIS_ADDR,\n\t\t\t.mask = ST_SENSORS_DEFAULT_AXIS_MASK,\n\t\t},\n\t\t.fs = {\n\t\t\t.addr = 0x23,\n\t\t\t.mask = 0x30,\n\t\t\t.fs_avl = {\n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_GYRO_FS_AVL_245DPS,\n\t\t\t\t\t.value = 0x00,\n\t\t\t\t\t.gain = IIO_DEGREE_TO_RAD(8750),\n\t\t\t\t},\n\t\t\t\t[1] = {\n\t\t\t\t\t.num = ST_GYRO_FS_AVL_500DPS,\n\t\t\t\t\t.value = 0x01,\n\t\t\t\t\t.gain = IIO_DEGREE_TO_RAD(17500),\n\t\t\t\t},\n\t\t\t\t[2] = {\n\t\t\t\t\t.num = ST_GYRO_FS_AVL_2000DPS,\n\t\t\t\t\t.value = 0x02,\n\t\t\t\t\t.gain = IIO_DEGREE_TO_RAD(70000),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x23,\n\t\t\t.mask = 0x80,\n\t\t},\n\t\t.drdy_irq = {\n\t\t\t.int2 = {\n\t\t\t\t.addr = 0x22,\n\t\t\t\t.mask = 0x08,\n\t\t\t},\n\t\t\t \n\t\t\t.stat_drdy = {\n\t\t\t\t.addr = ST_SENSORS_DEFAULT_STAT_ADDR,\n\t\t\t\t.mask = 0x07,\n\t\t\t},\n\t\t},\n\t\t.sim = {\n\t\t\t.addr = 0x23,\n\t\t\t.value = BIT(0),\n\t\t},\n\t\t.multi_read_bit = true,\n\t\t.bootime = 2,\n\t},\n};\n\n \nstatic const struct st_sensors_platform_data gyro_pdata = {\n\t.drdy_int_pin = 2,\n};\n\nstatic int st_gyro_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *ch, int *val,\n\t\t\t\t\t\t\tint *val2, long mask)\n{\n\tint err;\n\tstruct st_sensor_data *gdata = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\terr = st_sensors_read_info_raw(indio_dev, ch, val);\n\t\tif (err < 0)\n\t\t\tgoto read_error;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = gdata->current_fullscale->gain;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = gdata->odr;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\nread_error:\n\treturn err;\n}\n\nstatic int st_gyro_write_raw(struct iio_dev *indio_dev,\n\t\tstruct iio_chan_spec const *chan, int val, int val2, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn st_sensors_set_fullscale_by_gain(indio_dev, val2);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (val2)\n\t\t\treturn -EINVAL;\n\n\t\treturn st_sensors_set_odr(indio_dev, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ST_SENSORS_DEV_ATTR_SAMP_FREQ_AVAIL();\nstatic ST_SENSORS_DEV_ATTR_SCALE_AVAIL(in_anglvel_scale_available);\n\nstatic struct attribute *st_gyro_attributes[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_in_anglvel_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group st_gyro_attribute_group = {\n\t.attrs = st_gyro_attributes,\n};\n\nstatic const struct iio_info gyro_info = {\n\t.attrs = &st_gyro_attribute_group,\n\t.read_raw = &st_gyro_read_raw,\n\t.write_raw = &st_gyro_write_raw,\n\t.debugfs_reg_access = &st_sensors_debugfs_reg_access,\n};\n\n#ifdef CONFIG_IIO_TRIGGER\nstatic const struct iio_trigger_ops st_gyro_trigger_ops = {\n\t.set_trigger_state = ST_GYRO_TRIGGER_SET_STATE,\n\t.validate_device = st_sensors_validate_device,\n};\n#define ST_GYRO_TRIGGER_OPS (&st_gyro_trigger_ops)\n#else\n#define ST_GYRO_TRIGGER_OPS NULL\n#endif\n\n \nconst struct st_sensor_settings *st_gyro_get_settings(const char *name)\n{\n\tint index = st_sensors_get_settings_index(name,\n\t\t\t\t\tst_gyro_sensors_settings,\n\t\t\t\t\tARRAY_SIZE(st_gyro_sensors_settings));\n\tif (index < 0)\n\t\treturn NULL;\n\n\treturn &st_gyro_sensors_settings[index];\n}\nEXPORT_SYMBOL_NS(st_gyro_get_settings, IIO_ST_SENSORS);\n\nint st_gyro_common_probe(struct iio_dev *indio_dev)\n{\n\tstruct st_sensor_data *gdata = iio_priv(indio_dev);\n\tstruct st_sensors_platform_data *pdata;\n\tstruct device *parent = indio_dev->dev.parent;\n\tint err;\n\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &gyro_info;\n\n\terr = st_sensors_verify_id(indio_dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tgdata->num_data_channels = ST_GYRO_NUMBER_DATA_CHANNELS;\n\tindio_dev->channels = gdata->sensor_settings->ch;\n\tindio_dev->num_channels = ST_SENSORS_NUMBER_ALL_CHANNELS;\n\n\terr = iio_read_mount_matrix(parent, &gdata->mount_matrix);\n\tif (err)\n\t\treturn err;\n\n\tgdata->current_fullscale = &gdata->sensor_settings->fs.fs_avl[0];\n\tgdata->odr = gdata->sensor_settings->odr.odr_avl[0].hz;\n\n\tpdata = (struct st_sensors_platform_data *)&gyro_pdata;\n\n\terr = st_sensors_init_sensor(indio_dev, pdata);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = st_gyro_allocate_ring(indio_dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (gdata->irq > 0) {\n\t\terr = st_sensors_allocate_trigger(indio_dev,\n\t\t\t\t\t\t  ST_GYRO_TRIGGER_OPS);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn devm_iio_device_register(parent, indio_dev);\n}\nEXPORT_SYMBOL_NS(st_gyro_common_probe, IIO_ST_SENSORS);\n\nMODULE_AUTHOR(\"Denis Ciocca <denis.ciocca@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics gyroscopes driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_ST_SENSORS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}