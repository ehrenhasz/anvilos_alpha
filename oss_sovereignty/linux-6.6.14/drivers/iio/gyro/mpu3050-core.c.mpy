{
  "module_name": "mpu3050-core.c",
  "hash_id": "cb4850adbc1f5ec55817571ecfdedf12d08f8e0fdfcda01d7b10819341ff89e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/gyro/mpu3050-core.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n\n#include \"mpu3050.h\"\n\n#define MPU3050_CHIP_ID\t\t0x68\n#define MPU3050_CHIP_ID_MASK\t0x7E\n\n \n#define MPU3050_CHIP_ID_REG\t0x00\n#define MPU3050_PRODUCT_ID_REG\t0x01\n#define MPU3050_XG_OFFS_TC\t0x05\n#define MPU3050_YG_OFFS_TC\t0x08\n#define MPU3050_ZG_OFFS_TC\t0x0B\n#define MPU3050_X_OFFS_USR_H\t0x0C\n#define MPU3050_Y_OFFS_USR_H\t0x0E\n#define MPU3050_Z_OFFS_USR_H\t0x10\n#define MPU3050_FIFO_EN\t\t0x12\n#define MPU3050_AUX_VDDIO\t0x13\n#define MPU3050_SLV_ADDR\t0x14\n#define MPU3050_SMPLRT_DIV\t0x15\n#define MPU3050_DLPF_FS_SYNC\t0x16\n#define MPU3050_INT_CFG\t\t0x17\n#define MPU3050_AUX_ADDR\t0x18\n#define MPU3050_INT_STATUS\t0x1A\n#define MPU3050_TEMP_H\t\t0x1B\n#define MPU3050_XOUT_H\t\t0x1D\n#define MPU3050_YOUT_H\t\t0x1F\n#define MPU3050_ZOUT_H\t\t0x21\n#define MPU3050_DMP_CFG1\t0x35\n#define MPU3050_DMP_CFG2\t0x36\n#define MPU3050_BANK_SEL\t0x37\n#define MPU3050_MEM_START_ADDR\t0x38\n#define MPU3050_MEM_R_W\t\t0x39\n#define MPU3050_FIFO_COUNT_H\t0x3A\n#define MPU3050_FIFO_R\t\t0x3C\n#define MPU3050_USR_CTRL\t0x3D\n#define MPU3050_PWR_MGM\t\t0x3E\n\n \n#define MPU3050_MEM_PRFTCH\tBIT(5)\n#define MPU3050_MEM_USER_BANK\tBIT(4)\n \n#define MPU3050_MEM_RAM_BANK_0\t0\n#define MPU3050_MEM_RAM_BANK_1\t1\n#define MPU3050_MEM_RAM_BANK_2\t2\n#define MPU3050_MEM_RAM_BANK_3\t3\n#define MPU3050_MEM_OTP_BANK_0\t4\n\n#define MPU3050_AXIS_REGS(axis) (MPU3050_XOUT_H + (axis * 2))\n\n \n\n \n#define MPU3050_FIFO_EN_FOOTER\t\tBIT(0)\n#define MPU3050_FIFO_EN_AUX_ZOUT\tBIT(1)\n#define MPU3050_FIFO_EN_AUX_YOUT\tBIT(2)\n#define MPU3050_FIFO_EN_AUX_XOUT\tBIT(3)\n#define MPU3050_FIFO_EN_GYRO_ZOUT\tBIT(4)\n#define MPU3050_FIFO_EN_GYRO_YOUT\tBIT(5)\n#define MPU3050_FIFO_EN_GYRO_XOUT\tBIT(6)\n#define MPU3050_FIFO_EN_TEMP_OUT\tBIT(7)\n\n \n#define MPU3050_EXT_SYNC_NONE\t\t0x00\n#define MPU3050_EXT_SYNC_TEMP\t\t0x20\n#define MPU3050_EXT_SYNC_GYROX\t\t0x40\n#define MPU3050_EXT_SYNC_GYROY\t\t0x60\n#define MPU3050_EXT_SYNC_GYROZ\t\t0x80\n#define MPU3050_EXT_SYNC_ACCELX\t0xA0\n#define MPU3050_EXT_SYNC_ACCELY\t0xC0\n#define MPU3050_EXT_SYNC_ACCELZ\t0xE0\n#define MPU3050_EXT_SYNC_MASK\t\t0xE0\n#define MPU3050_EXT_SYNC_SHIFT\t\t5\n\n#define MPU3050_FS_250DPS\t\t0x00\n#define MPU3050_FS_500DPS\t\t0x08\n#define MPU3050_FS_1000DPS\t\t0x10\n#define MPU3050_FS_2000DPS\t\t0x18\n#define MPU3050_FS_MASK\t\t\t0x18\n#define MPU3050_FS_SHIFT\t\t3\n\n#define MPU3050_DLPF_CFG_256HZ_NOLPF2\t0x00\n#define MPU3050_DLPF_CFG_188HZ\t\t0x01\n#define MPU3050_DLPF_CFG_98HZ\t\t0x02\n#define MPU3050_DLPF_CFG_42HZ\t\t0x03\n#define MPU3050_DLPF_CFG_20HZ\t\t0x04\n#define MPU3050_DLPF_CFG_10HZ\t\t0x05\n#define MPU3050_DLPF_CFG_5HZ\t\t0x06\n#define MPU3050_DLPF_CFG_2100HZ_NOLPF\t0x07\n#define MPU3050_DLPF_CFG_MASK\t\t0x07\n#define MPU3050_DLPF_CFG_SHIFT\t\t0\n\n \n#define MPU3050_INT_RAW_RDY_EN\t\tBIT(0)\n#define MPU3050_INT_DMP_DONE_EN\t\tBIT(1)\n#define MPU3050_INT_MPU_RDY_EN\t\tBIT(2)\n#define MPU3050_INT_ANYRD_2CLEAR\tBIT(4)\n#define MPU3050_INT_LATCH_EN\t\tBIT(5)\n#define MPU3050_INT_OPEN\t\tBIT(6)\n#define MPU3050_INT_ACTL\t\tBIT(7)\n \n#define MPU3050_INT_STATUS_RAW_RDY\tBIT(0)\n#define MPU3050_INT_STATUS_DMP_DONE\tBIT(1)\n#define MPU3050_INT_STATUS_MPU_RDY\tBIT(2)\n#define MPU3050_INT_STATUS_FIFO_OVFLW\tBIT(7)\n \n#define MPU3050_USR_CTRL_FIFO_EN\tBIT(6)\n#define MPU3050_USR_CTRL_AUX_IF_EN\tBIT(5)\n#define MPU3050_USR_CTRL_AUX_IF_RST\tBIT(3)\n#define MPU3050_USR_CTRL_FIFO_RST\tBIT(1)\n#define MPU3050_USR_CTRL_GYRO_RST\tBIT(0)\n \n#define MPU3050_PWR_MGM_PLL_X\t\t0x01\n#define MPU3050_PWR_MGM_PLL_Y\t\t0x02\n#define MPU3050_PWR_MGM_PLL_Z\t\t0x03\n#define MPU3050_PWR_MGM_CLKSEL_MASK\t0x07\n#define MPU3050_PWR_MGM_STBY_ZG\t\tBIT(3)\n#define MPU3050_PWR_MGM_STBY_YG\t\tBIT(4)\n#define MPU3050_PWR_MGM_STBY_XG\t\tBIT(5)\n#define MPU3050_PWR_MGM_SLEEP\t\tBIT(6)\n#define MPU3050_PWR_MGM_RESET\t\tBIT(7)\n#define MPU3050_PWR_MGM_MASK\t\t0xff\n\n \nstatic unsigned int mpu3050_fs_precision[] = {\n\tIIO_DEGREE_TO_RAD(250),\n\tIIO_DEGREE_TO_RAD(500),\n\tIIO_DEGREE_TO_RAD(1000),\n\tIIO_DEGREE_TO_RAD(2000)\n};\n\n \nstatic const char mpu3050_reg_vdd[] = \"vdd\";\nstatic const char mpu3050_reg_vlogic[] = \"vlogic\";\n\nstatic unsigned int mpu3050_get_freq(struct mpu3050 *mpu3050)\n{\n\tunsigned int freq;\n\n\tif (mpu3050->lpf == MPU3050_DLPF_CFG_256HZ_NOLPF2)\n\t\tfreq = 8000;\n\telse\n\t\tfreq = 1000;\n\tfreq /= (mpu3050->divisor + 1);\n\n\treturn freq;\n}\n\nstatic int mpu3050_start_sampling(struct mpu3050 *mpu3050)\n{\n\t__be16 raw_val[3];\n\tint ret;\n\tint i;\n\n\t \n\tret = regmap_update_bits(mpu3050->map, MPU3050_PWR_MGM,\n\t\t\t\t MPU3050_PWR_MGM_RESET, MPU3050_PWR_MGM_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(mpu3050->map, MPU3050_PWR_MGM,\n\t\t\t\t MPU3050_PWR_MGM_CLKSEL_MASK,\n\t\t\t\t MPU3050_PWR_MGM_PLL_Z);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < 3; i++)\n\t\traw_val[i] = cpu_to_be16(mpu3050->calibration[i]);\n\n\tret = regmap_bulk_write(mpu3050->map, MPU3050_X_OFFS_USR_H, raw_val,\n\t\t\t\tsizeof(raw_val));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(mpu3050->map, MPU3050_DLPF_FS_SYNC,\n\t\t\t   MPU3050_EXT_SYNC_NONE << MPU3050_EXT_SYNC_SHIFT |\n\t\t\t   mpu3050->fullscale << MPU3050_FS_SHIFT |\n\t\t\t   mpu3050->lpf << MPU3050_DLPF_CFG_SHIFT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(mpu3050->map, MPU3050_SMPLRT_DIV, mpu3050->divisor);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(50 + 1000 / mpu3050_get_freq(mpu3050));\n\n\treturn 0;\n}\n\nstatic int mpu3050_set_8khz_samplerate(struct mpu3050 *mpu3050)\n{\n\tint ret;\n\tu8 divisor;\n\tenum mpu3050_lpf lpf;\n\n\tlpf = mpu3050->lpf;\n\tdivisor = mpu3050->divisor;\n\n\tmpu3050->lpf = LPF_256_HZ_NOLPF;  \n\tmpu3050->divisor = 0;  \n\tret = mpu3050_start_sampling(mpu3050);\n\n\tmpu3050->lpf = lpf;\n\tmpu3050->divisor = divisor;\n\n\treturn ret;\n}\n\nstatic int mpu3050_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2,\n\t\t\t    long mask)\n{\n\tstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\n\tint ret;\n\t__be16 raw_val;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = 23000;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\t*val = mpu3050->calibration[chan->scan_index-1];\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = mpu3050_get_freq(mpu3050);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = 1000;\n\t\t\t*val2 = 280;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_ANGL_VEL:\n\t\t\t \n\t\t\t*val = mpu3050_fs_precision[mpu3050->fullscale] * 2;\n\t\t\t*val2 = U16_MAX;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_RAW:\n\t\t \n\t\tpm_runtime_get_sync(mpu3050->dev);\n\t\tmutex_lock(&mpu3050->lock);\n\n\t\tret = mpu3050_set_8khz_samplerate(mpu3050);\n\t\tif (ret)\n\t\t\tgoto out_read_raw_unlock;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\tret = regmap_bulk_read(mpu3050->map, MPU3050_TEMP_H,\n\t\t\t\t\t       &raw_val, sizeof(raw_val));\n\t\t\tif (ret) {\n\t\t\t\tdev_err(mpu3050->dev,\n\t\t\t\t\t\"error reading temperature\\n\");\n\t\t\t\tgoto out_read_raw_unlock;\n\t\t\t}\n\n\t\t\t*val = (s16)be16_to_cpu(raw_val);\n\t\t\tret = IIO_VAL_INT;\n\n\t\t\tgoto out_read_raw_unlock;\n\t\tcase IIO_ANGL_VEL:\n\t\t\tret = regmap_bulk_read(mpu3050->map,\n\t\t\t\t       MPU3050_AXIS_REGS(chan->scan_index-1),\n\t\t\t\t       &raw_val,\n\t\t\t\t       sizeof(raw_val));\n\t\t\tif (ret) {\n\t\t\t\tdev_err(mpu3050->dev,\n\t\t\t\t\t\"error reading axis data\\n\");\n\t\t\t\tgoto out_read_raw_unlock;\n\t\t\t}\n\n\t\t\t*val = be16_to_cpu(raw_val);\n\t\t\tret = IIO_VAL_INT;\n\n\t\t\tgoto out_read_raw_unlock;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_read_raw_unlock;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n\nout_read_raw_unlock:\n\tmutex_unlock(&mpu3050->lock);\n\tpm_runtime_mark_last_busy(mpu3050->dev);\n\tpm_runtime_put_autosuspend(mpu3050->dev);\n\n\treturn ret;\n}\n\nstatic int mpu3050_write_raw(struct iio_dev *indio_dev,\n\t\t\t     const struct iio_chan_spec *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\n\t \n\tunsigned int fs250 =\n\t\tDIV_ROUND_CLOSEST(mpu3050_fs_precision[0] * 1000000 * 2,\n\t\t\t\t  U16_MAX);\n\tunsigned int fs500 =\n\t\tDIV_ROUND_CLOSEST(mpu3050_fs_precision[1] * 1000000 * 2,\n\t\t\t\t  U16_MAX);\n\tunsigned int fs1000 =\n\t\tDIV_ROUND_CLOSEST(mpu3050_fs_precision[2] * 1000000 * 2,\n\t\t\t\t  U16_MAX);\n\tunsigned int fs2000 =\n\t\tDIV_ROUND_CLOSEST(mpu3050_fs_precision[3] * 1000000 * 2,\n\t\t\t\t  U16_MAX);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif (chan->type != IIO_ANGL_VEL)\n\t\t\treturn -EINVAL;\n\t\tmpu3050->calibration[chan->scan_index-1] = val;\n\t\treturn 0;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t \n\t\tif (val < 4 || val > 8000)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (val > 1000) {\n\t\t\tmpu3050->lpf = LPF_256_HZ_NOLPF;\n\t\t\tmpu3050->divisor = DIV_ROUND_CLOSEST(8000, val) - 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmpu3050->lpf = LPF_188_HZ;\n\t\tmpu3050->divisor = DIV_ROUND_CLOSEST(1000, val) - 1;\n\t\treturn 0;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (chan->type != IIO_ANGL_VEL)\n\t\t\treturn -EINVAL;\n\t\t \n\n\t\t \n\t\tif (val != 0) {\n\t\t\tmpu3050->fullscale = FS_2000_DPS;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (val2 <= fs250 ||\n\t\t    val2 < ((fs500 + fs250) / 2))\n\t\t\tmpu3050->fullscale = FS_250_DPS;\n\t\telse if (val2 <= fs500 ||\n\t\t\t val2 < ((fs1000 + fs500) / 2))\n\t\t\tmpu3050->fullscale = FS_500_DPS;\n\t\telse if (val2 <= fs1000 ||\n\t\t\t val2 < ((fs2000 + fs1000) / 2))\n\t\t\tmpu3050->fullscale = FS_1000_DPS;\n\t\telse\n\t\t\t \n\t\t\tmpu3050->fullscale = FS_2000_DPS;\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic irqreturn_t mpu3050_trigger_handler(int irq, void *p)\n{\n\tconst struct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\n\tint ret;\n\tstruct {\n\t\t__be16 chans[4];\n\t\ts64 timestamp __aligned(8);\n\t} scan;\n\ts64 timestamp;\n\tunsigned int datums_from_fifo = 0;\n\n\t \n\tif (iio_trigger_using_own(indio_dev))\n\t\ttimestamp = mpu3050->hw_timestamp;\n\telse\n\t\ttimestamp = iio_get_time_ns(indio_dev);\n\n\tmutex_lock(&mpu3050->lock);\n\n\t \n\tif (mpu3050->hw_irq_trigger) {\n\t\t__be16 raw_fifocnt;\n\t\tu16 fifocnt;\n\t\t \n\t\tunsigned int bytes_per_datum = 8;\n\t\tbool fifo_overflow = false;\n\n\t\tret = regmap_bulk_read(mpu3050->map,\n\t\t\t\t       MPU3050_FIFO_COUNT_H,\n\t\t\t\t       &raw_fifocnt,\n\t\t\t\t       sizeof(raw_fifocnt));\n\t\tif (ret)\n\t\t\tgoto out_trigger_unlock;\n\t\tfifocnt = be16_to_cpu(raw_fifocnt);\n\n\t\tif (fifocnt == 512) {\n\t\t\tdev_info(mpu3050->dev,\n\t\t\t\t \"FIFO overflow! Emptying and resetting FIFO\\n\");\n\t\t\tfifo_overflow = true;\n\t\t\t \n\t\t\tret = regmap_update_bits(mpu3050->map,\n\t\t\t\t\t\t MPU3050_USR_CTRL,\n\t\t\t\t\t\t MPU3050_USR_CTRL_FIFO_EN |\n\t\t\t\t\t\t MPU3050_USR_CTRL_FIFO_RST,\n\t\t\t\t\t\t MPU3050_USR_CTRL_FIFO_EN |\n\t\t\t\t\t\t MPU3050_USR_CTRL_FIFO_RST);\n\t\t\tif (ret) {\n\t\t\t\tdev_info(mpu3050->dev, \"error resetting FIFO\\n\");\n\t\t\t\tgoto out_trigger_unlock;\n\t\t\t}\n\t\t\tmpu3050->pending_fifo_footer = false;\n\t\t}\n\n\t\tif (fifocnt)\n\t\t\tdev_dbg(mpu3050->dev,\n\t\t\t\t\"%d bytes in the FIFO\\n\",\n\t\t\t\tfifocnt);\n\n\t\twhile (!fifo_overflow && fifocnt > bytes_per_datum) {\n\t\t\tunsigned int toread;\n\t\t\tunsigned int offset;\n\t\t\t__be16 fifo_values[5];\n\n\t\t\t \n\t\t\tif (mpu3050->pending_fifo_footer) {\n\t\t\t\ttoread = bytes_per_datum + 2;\n\t\t\t\toffset = 0;\n\t\t\t} else {\n\t\t\t\ttoread = bytes_per_datum;\n\t\t\t\toffset = 1;\n\t\t\t\t \n\t\t\t\tfifo_values[0] = cpu_to_be16(0xAAAA);\n\t\t\t}\n\n\t\t\tret = regmap_bulk_read(mpu3050->map,\n\t\t\t\t\t       MPU3050_FIFO_R,\n\t\t\t\t\t       &fifo_values[offset],\n\t\t\t\t\t       toread);\n\t\t\tif (ret)\n\t\t\t\tgoto out_trigger_unlock;\n\n\t\t\tdev_dbg(mpu3050->dev,\n\t\t\t\t\"%04x %04x %04x %04x %04x\\n\",\n\t\t\t\tfifo_values[0],\n\t\t\t\tfifo_values[1],\n\t\t\t\tfifo_values[2],\n\t\t\t\tfifo_values[3],\n\t\t\t\tfifo_values[4]);\n\n\t\t\t \n\t\t\tiio_push_to_buffers_with_ts_unaligned(indio_dev,\n\t\t\t\t\t\t\t      &fifo_values[1],\n\t\t\t\t\t\t\t      sizeof(__be16) * 4,\n\t\t\t\t\t\t\t      timestamp);\n\n\t\t\tfifocnt -= toread;\n\t\t\tdatums_from_fifo++;\n\t\t\tmpu3050->pending_fifo_footer = true;\n\n\t\t\t \n\t\t\tif (fifocnt < bytes_per_datum) {\n\t\t\t\tret = regmap_bulk_read(mpu3050->map,\n\t\t\t\t\t\t       MPU3050_FIFO_COUNT_H,\n\t\t\t\t\t\t       &raw_fifocnt,\n\t\t\t\t\t\t       sizeof(raw_fifocnt));\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_trigger_unlock;\n\t\t\t\tfifocnt = be16_to_cpu(raw_fifocnt);\n\t\t\t}\n\n\t\t\tif (fifocnt < bytes_per_datum)\n\t\t\t\tdev_dbg(mpu3050->dev,\n\t\t\t\t\t\"%d bytes left in the FIFO\\n\",\n\t\t\t\t\tfifocnt);\n\n\t\t\t \n\t\t\ttimestamp = 0;\n\t\t}\n\t}\n\n\t \n\tif (datums_from_fifo) {\n\t\tdev_dbg(mpu3050->dev,\n\t\t\t\"read %d datums from the FIFO\\n\",\n\t\t\tdatums_from_fifo);\n\t\tgoto out_trigger_unlock;\n\t}\n\n\tret = regmap_bulk_read(mpu3050->map, MPU3050_TEMP_H, scan.chans,\n\t\t\t       sizeof(scan.chans));\n\tif (ret) {\n\t\tdev_err(mpu3050->dev,\n\t\t\t\"error reading axis data\\n\");\n\t\tgoto out_trigger_unlock;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &scan, timestamp);\n\nout_trigger_unlock:\n\tmutex_unlock(&mpu3050->lock);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mpu3050_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\n\n\tpm_runtime_get_sync(mpu3050->dev);\n\n\t \n\tif (!mpu3050->hw_irq_trigger)\n\t\treturn mpu3050_set_8khz_samplerate(mpu3050);\n\n\treturn 0;\n}\n\nstatic int mpu3050_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\n\n\tpm_runtime_mark_last_busy(mpu3050->dev);\n\tpm_runtime_put_autosuspend(mpu3050->dev);\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops mpu3050_buffer_setup_ops = {\n\t.preenable = mpu3050_buffer_preenable,\n\t.postdisable = mpu3050_buffer_postdisable,\n};\n\nstatic const struct iio_mount_matrix *\nmpu3050_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\t const struct iio_chan_spec *chan)\n{\n\tstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\n\n\treturn &mpu3050->orientation;\n}\n\nstatic const struct iio_chan_spec_ext_info mpu3050_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_TYPE, mpu3050_get_mount_matrix),\n\t{ },\n};\n\n#define MPU3050_AXIS_CHANNEL(axis, index)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_ANGL_VEL,\t\t\t\t\t\\\n\t\t.modified = 1,\t\t\t\t\t\t\\\n\t\t.channel2 = IIO_MOD_##axis,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\t\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\\\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\\\n\t\t.ext_info = mpu3050_ext_info,\t\t\t\t\\\n\t\t.scan_index = index,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\t\\\n\t\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec mpu3050_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_OFFSET),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\tMPU3050_AXIS_CHANNEL(X, 1),\n\tMPU3050_AXIS_CHANNEL(Y, 2),\n\tMPU3050_AXIS_CHANNEL(Z, 3),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\n \nstatic const unsigned long mpu3050_scan_masks[] = { 0xf, 0 };\n\n \nstatic IIO_CONST_ATTR(anglevel_scale_available,\n\t\t      \"0.000122070 \"\n\t\t      \"0.000274658 \"\n\t\t      \"0.000518798 \"\n\t\t      \"0.001068115\");\n\nstatic struct attribute *mpu3050_attributes[] = {\n\t&iio_const_attr_anglevel_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mpu3050_attribute_group = {\n\t.attrs = mpu3050_attributes,\n};\n\nstatic const struct iio_info mpu3050_info = {\n\t.read_raw = mpu3050_read_raw,\n\t.write_raw = mpu3050_write_raw,\n\t.attrs = &mpu3050_attribute_group,\n};\n\n \nstatic int mpu3050_read_mem(struct mpu3050 *mpu3050,\n\t\t\t    u8 bank,\n\t\t\t    u8 addr,\n\t\t\t    u8 len,\n\t\t\t    u8 *buf)\n{\n\tint ret;\n\n\tret = regmap_write(mpu3050->map,\n\t\t\t   MPU3050_BANK_SEL,\n\t\t\t   bank);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(mpu3050->map,\n\t\t\t   MPU3050_MEM_START_ADDR,\n\t\t\t   addr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_bulk_read(mpu3050->map,\n\t\t\t\tMPU3050_MEM_R_W,\n\t\t\t\tbuf,\n\t\t\t\tlen);\n}\n\nstatic int mpu3050_hw_init(struct mpu3050 *mpu3050)\n{\n\tint ret;\n\t__le64 otp_le;\n\tu64 otp;\n\n\t \n\tret = regmap_update_bits(mpu3050->map,\n\t\t\t\t MPU3050_PWR_MGM,\n\t\t\t\t MPU3050_PWR_MGM_RESET,\n\t\t\t\t MPU3050_PWR_MGM_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(mpu3050->map,\n\t\t\t\t MPU3050_PWR_MGM,\n\t\t\t\t MPU3050_PWR_MGM_CLKSEL_MASK,\n\t\t\t\t MPU3050_PWR_MGM_PLL_Z);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(mpu3050->map,\n\t\t\t   MPU3050_INT_CFG,\n\t\t\t   0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mpu3050_read_mem(mpu3050,\n\t\t\t       (MPU3050_MEM_PRFTCH |\n\t\t\t\tMPU3050_MEM_USER_BANK |\n\t\t\t\tMPU3050_MEM_OTP_BANK_0),\n\t\t\t       0,\n\t\t\t       sizeof(otp_le),\n\t\t\t       (u8 *)&otp_le);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tadd_device_randomness(&otp_le, sizeof(otp_le));\n\n\totp = le64_to_cpu(otp_le);\n\n\tdev_info(mpu3050->dev,\n\t\t \"die ID: %04llX, wafer ID: %02llX, A lot ID: %04llX, \"\n\t\t \"W lot ID: %03llX, WP ID: %01llX, rev ID: %02llX\\n\",\n\t\t  \n\t\t FIELD_GET(GENMASK_ULL(12, 0), otp),\n\t\t  \n\t\t FIELD_GET(GENMASK_ULL(17, 13), otp),\n\t\t  \n\t\t FIELD_GET(GENMASK_ULL(33, 18), otp),\n\t\t  \n\t\t FIELD_GET(GENMASK_ULL(45, 34), otp),\n\t\t  \n\t\t FIELD_GET(GENMASK_ULL(49, 47), otp),\n\t\t  \n\t\t FIELD_GET(GENMASK_ULL(55, 50), otp));\n\n\treturn 0;\n}\n\nstatic int mpu3050_power_up(struct mpu3050 *mpu3050)\n{\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(mpu3050->regs), mpu3050->regs);\n\tif (ret) {\n\t\tdev_err(mpu3050->dev, \"cannot enable regulators\\n\");\n\t\treturn ret;\n\t}\n\t \n\tmsleep(200);\n\n\t \n\tret = regmap_update_bits(mpu3050->map, MPU3050_PWR_MGM,\n\t\t\t\t MPU3050_PWR_MGM_SLEEP, 0);\n\tif (ret) {\n\t\tregulator_bulk_disable(ARRAY_SIZE(mpu3050->regs), mpu3050->regs);\n\t\tdev_err(mpu3050->dev, \"error setting power mode\\n\");\n\t\treturn ret;\n\t}\n\tusleep_range(10000, 20000);\n\n\treturn 0;\n}\n\nstatic int mpu3050_power_down(struct mpu3050 *mpu3050)\n{\n\tint ret;\n\n\t \n\tret = regmap_update_bits(mpu3050->map, MPU3050_PWR_MGM,\n\t\t\t\t MPU3050_PWR_MGM_SLEEP, MPU3050_PWR_MGM_SLEEP);\n\tif (ret)\n\t\tdev_err(mpu3050->dev, \"error putting to sleep\\n\");\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(mpu3050->regs), mpu3050->regs);\n\tif (ret)\n\t\tdev_err(mpu3050->dev, \"error disabling regulators\\n\");\n\n\treturn 0;\n}\n\nstatic irqreturn_t mpu3050_irq_handler(int irq, void *p)\n{\n\tstruct iio_trigger *trig = p;\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\n\n\tif (!mpu3050->hw_irq_trigger)\n\t\treturn IRQ_NONE;\n\n\t \n\tmpu3050->hw_timestamp = iio_get_time_ns(indio_dev);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t mpu3050_irq_thread(int irq, void *p)\n{\n\tstruct iio_trigger *trig = p;\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_read(mpu3050->map, MPU3050_INT_STATUS, &val);\n\tif (ret) {\n\t\tdev_err(mpu3050->dev, \"error reading IRQ status\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\tif (!(val & MPU3050_INT_STATUS_RAW_RDY))\n\t\treturn IRQ_NONE;\n\n\tiio_trigger_poll_nested(p);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int mpu3050_drdy_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t  bool enable)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\n\tunsigned int val;\n\tint ret;\n\n\t \n\tif (!enable) {\n\t\t \n\t\tret = regmap_write(mpu3050->map,\n\t\t\t\t   MPU3050_INT_CFG,\n\t\t\t\t   0);\n\t\tif (ret)\n\t\t\tdev_err(mpu3050->dev, \"error disabling IRQ\\n\");\n\n\t\t \n\t\tret = regmap_read(mpu3050->map, MPU3050_INT_STATUS, &val);\n\t\tif (ret)\n\t\t\tdev_err(mpu3050->dev, \"error clearing IRQ status\\n\");\n\n\t\t \n\t\tret = regmap_write(mpu3050->map, MPU3050_FIFO_EN, 0);\n\t\tif (ret)\n\t\t\tdev_err(mpu3050->dev, \"error disabling FIFO\\n\");\n\n\t\tret = regmap_write(mpu3050->map, MPU3050_USR_CTRL,\n\t\t\t\t   MPU3050_USR_CTRL_FIFO_RST);\n\t\tif (ret)\n\t\t\tdev_err(mpu3050->dev, \"error resetting FIFO\\n\");\n\n\t\tpm_runtime_mark_last_busy(mpu3050->dev);\n\t\tpm_runtime_put_autosuspend(mpu3050->dev);\n\t\tmpu3050->hw_irq_trigger = false;\n\n\t\treturn 0;\n\t} else {\n\t\t \n\t\tpm_runtime_get_sync(mpu3050->dev);\n\t\tmpu3050->hw_irq_trigger = true;\n\n\t\t \n\t\tret = regmap_write(mpu3050->map, MPU3050_FIFO_EN, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_update_bits(mpu3050->map, MPU3050_USR_CTRL,\n\t\t\t\t\t MPU3050_USR_CTRL_FIFO_EN |\n\t\t\t\t\t MPU3050_USR_CTRL_FIFO_RST,\n\t\t\t\t\t MPU3050_USR_CTRL_FIFO_EN |\n\t\t\t\t\t MPU3050_USR_CTRL_FIFO_RST);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmpu3050->pending_fifo_footer = false;\n\n\t\t \n\t\tret = regmap_write(mpu3050->map, MPU3050_FIFO_EN,\n\t\t\t\t   MPU3050_FIFO_EN_TEMP_OUT |\n\t\t\t\t   MPU3050_FIFO_EN_GYRO_XOUT |\n\t\t\t\t   MPU3050_FIFO_EN_GYRO_YOUT |\n\t\t\t\t   MPU3050_FIFO_EN_GYRO_ZOUT |\n\t\t\t\t   MPU3050_FIFO_EN_FOOTER);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = mpu3050_start_sampling(mpu3050);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_read(mpu3050->map, MPU3050_INT_STATUS, &val);\n\t\tif (ret)\n\t\t\tdev_err(mpu3050->dev, \"error clearing IRQ status\\n\");\n\n\t\t \n\t\tval = MPU3050_INT_RAW_RDY_EN;\n\n\t\tif (mpu3050->irq_actl)\n\t\t\tval |= MPU3050_INT_ACTL;\n\t\tif (mpu3050->irq_latch)\n\t\t\tval |= MPU3050_INT_LATCH_EN;\n\t\tif (mpu3050->irq_opendrain)\n\t\t\tval |= MPU3050_INT_OPEN;\n\n\t\tret = regmap_write(mpu3050->map, MPU3050_INT_CFG, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iio_trigger_ops mpu3050_trigger_ops = {\n\t.set_trigger_state = mpu3050_drdy_trigger_set_state,\n};\n\nstatic int mpu3050_trigger_probe(struct iio_dev *indio_dev, int irq)\n{\n\tstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\n\tstruct device *dev = mpu3050->dev;\n\tunsigned long irq_trig;\n\tint ret;\n\n\tmpu3050->trig = devm_iio_trigger_alloc(&indio_dev->dev,\n\t\t\t\t\t       \"%s-dev%d\",\n\t\t\t\t\t       indio_dev->name,\n\t\t\t\t\t       iio_device_id(indio_dev));\n\tif (!mpu3050->trig)\n\t\treturn -ENOMEM;\n\n\t \n\tmpu3050->irq_opendrain = device_property_read_bool(dev, \"drive-open-drain\");\n\n\tirq_trig = irqd_get_trigger_type(irq_get_irq_data(irq));\n\t \n\tswitch (irq_trig) {\n\tcase IRQF_TRIGGER_RISING:\n\t\tdev_info(&indio_dev->dev,\n\t\t\t \"pulse interrupts on the rising edge\\n\");\n\t\tbreak;\n\tcase IRQF_TRIGGER_FALLING:\n\t\tmpu3050->irq_actl = true;\n\t\tdev_info(&indio_dev->dev,\n\t\t\t \"pulse interrupts on the falling edge\\n\");\n\t\tbreak;\n\tcase IRQF_TRIGGER_HIGH:\n\t\tmpu3050->irq_latch = true;\n\t\tdev_info(&indio_dev->dev,\n\t\t\t \"interrupts active high level\\n\");\n\t\t \n\t\tirq_trig |= IRQF_ONESHOT;\n\t\tbreak;\n\tcase IRQF_TRIGGER_LOW:\n\t\tmpu3050->irq_latch = true;\n\t\tmpu3050->irq_actl = true;\n\t\tirq_trig |= IRQF_ONESHOT;\n\t\tdev_info(&indio_dev->dev,\n\t\t\t \"interrupts active low level\\n\");\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_err(&indio_dev->dev,\n\t\t\t\"unsupported IRQ trigger specified (%lx), enforce \"\n\t\t\t\"rising edge\\n\", irq_trig);\n\t\tirq_trig = IRQF_TRIGGER_RISING;\n\t\tbreak;\n\t}\n\n\t \n\tif (mpu3050->irq_opendrain)\n\t\tirq_trig |= IRQF_SHARED;\n\n\tret = request_threaded_irq(irq,\n\t\t\t\t   mpu3050_irq_handler,\n\t\t\t\t   mpu3050_irq_thread,\n\t\t\t\t   irq_trig,\n\t\t\t\t   mpu3050->trig->name,\n\t\t\t\t   mpu3050->trig);\n\tif (ret) {\n\t\tdev_err(dev, \"can't get IRQ %d, error %d\\n\", irq, ret);\n\t\treturn ret;\n\t}\n\n\tmpu3050->irq = irq;\n\tmpu3050->trig->dev.parent = dev;\n\tmpu3050->trig->ops = &mpu3050_trigger_ops;\n\tiio_trigger_set_drvdata(mpu3050->trig, indio_dev);\n\n\tret = iio_trigger_register(mpu3050->trig);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->trig = iio_trigger_get(mpu3050->trig);\n\n\treturn 0;\n}\n\nint mpu3050_common_probe(struct device *dev,\n\t\t\t struct regmap *map,\n\t\t\t int irq,\n\t\t\t const char *name)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct mpu3050 *mpu3050;\n\tunsigned int val;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*mpu3050));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tmpu3050 = iio_priv(indio_dev);\n\n\tmpu3050->dev = dev;\n\tmpu3050->map = map;\n\tmutex_init(&mpu3050->lock);\n\t \n\tmpu3050->fullscale = FS_2000_DPS;\n\t \n\tmpu3050->lpf = MPU3050_DLPF_CFG_188HZ;\n\tmpu3050->divisor = 99;\n\n\t \n\tret = iio_read_mount_matrix(dev, &mpu3050->orientation);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmpu3050->regs[0].supply = mpu3050_reg_vdd;\n\tmpu3050->regs[1].supply = mpu3050_reg_vlogic;\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(mpu3050->regs),\n\t\t\t\t      mpu3050->regs);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot get regulators\\n\");\n\t\treturn ret;\n\t}\n\n\tret = mpu3050_power_up(mpu3050);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(map, MPU3050_CHIP_ID_REG, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"could not read device ID\\n\");\n\t\tret = -ENODEV;\n\n\t\tgoto err_power_down;\n\t}\n\n\tif ((val & MPU3050_CHIP_ID_MASK) != MPU3050_CHIP_ID) {\n\t\tdev_err(dev, \"unsupported chip id %02x\\n\",\n\t\t\t\t(u8)(val & MPU3050_CHIP_ID_MASK));\n\t\tret = -ENODEV;\n\t\tgoto err_power_down;\n\t}\n\n\tret = regmap_read(map, MPU3050_PRODUCT_ID_REG, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"could not read device ID\\n\");\n\t\tret = -ENODEV;\n\n\t\tgoto err_power_down;\n\t}\n\tdev_info(dev, \"found MPU-3050 part no: %d, version: %d\\n\",\n\t\t ((val >> 4) & 0xf), (val & 0xf));\n\n\tret = mpu3050_hw_init(mpu3050);\n\tif (ret)\n\t\tgoto err_power_down;\n\n\tindio_dev->channels = mpu3050_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mpu3050_channels);\n\tindio_dev->info = &mpu3050_info;\n\tindio_dev->available_scan_masks = mpu3050_scan_masks;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->name = name;\n\n\tret = iio_triggered_buffer_setup(indio_dev, iio_pollfunc_store_time,\n\t\t\t\t\t mpu3050_trigger_handler,\n\t\t\t\t\t &mpu3050_buffer_setup_ops);\n\tif (ret) {\n\t\tdev_err(dev, \"triggered buffer setup failed\\n\");\n\t\tgoto err_power_down;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"device register failed\\n\");\n\t\tgoto err_cleanup_buffer;\n\t}\n\n\tdev_set_drvdata(dev, indio_dev);\n\n\t \n\tif (irq) {\n\t\tret = mpu3050_trigger_probe(indio_dev, irq);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"failed to register trigger\\n\");\n\t}\n\n\t \n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 10000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_put(dev);\n\n\treturn 0;\n\nerr_cleanup_buffer:\n\tiio_triggered_buffer_cleanup(indio_dev);\nerr_power_down:\n\tmpu3050_power_down(mpu3050);\n\n\treturn ret;\n}\n\nvoid mpu3050_common_remove(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\n\n\tpm_runtime_get_sync(dev);\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_disable(dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tif (mpu3050->irq)\n\t\tfree_irq(mpu3050->irq, mpu3050);\n\tiio_device_unregister(indio_dev);\n\tmpu3050_power_down(mpu3050);\n}\n\nstatic int mpu3050_runtime_suspend(struct device *dev)\n{\n\treturn mpu3050_power_down(iio_priv(dev_get_drvdata(dev)));\n}\n\nstatic int mpu3050_runtime_resume(struct device *dev)\n{\n\treturn mpu3050_power_up(iio_priv(dev_get_drvdata(dev)));\n}\n\nDEFINE_RUNTIME_DEV_PM_OPS(mpu3050_dev_pm_ops, mpu3050_runtime_suspend,\n\t\t\t  mpu3050_runtime_resume, NULL);\nMODULE_AUTHOR(\"Linus Walleij\");\nMODULE_DESCRIPTION(\"MPU3050 gyroscope driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}