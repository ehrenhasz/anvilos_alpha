{
  "module_name": "itg3200_core.c",
  "hash_id": "529092d475d87fd3293ea451cfa704556bb6e4efbc6bfb3d6338bb2641715a57",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/gyro/itg3200_core.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n#include <linux/iio/buffer.h>\n\n#include <linux/iio/gyro/itg3200.h>\n\n\nint itg3200_write_reg_8(struct iio_dev *indio_dev,\n\t\tu8 reg_address, u8 val)\n{\n\tstruct itg3200 *st = iio_priv(indio_dev);\n\n\treturn i2c_smbus_write_byte_data(st->i2c, 0x80 | reg_address, val);\n}\n\nint itg3200_read_reg_8(struct iio_dev *indio_dev,\n\t\tu8 reg_address, u8 *val)\n{\n\tstruct itg3200 *st = iio_priv(indio_dev);\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(st->i2c, reg_address);\n\tif (ret < 0)\n\t\treturn ret;\n\t*val = ret;\n\treturn 0;\n}\n\nstatic int itg3200_read_reg_s16(struct iio_dev *indio_dev, u8 lower_reg_address,\n\t\tint *val)\n{\n\tstruct itg3200 *st = iio_priv(indio_dev);\n\tstruct i2c_client *client = st->i2c;\n\tint ret;\n\ts16 out;\n\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = client->flags,\n\t\t\t.len = 1,\n\t\t\t.buf = (char *)&lower_reg_address,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = client->flags | I2C_M_RD,\n\t\t\t.len = 2,\n\t\t\t.buf = (char *)&out,\n\t\t},\n\t};\n\n\tlower_reg_address |= 0x80;\n\tret = i2c_transfer(client->adapter, msg, 2);\n\tbe16_to_cpus(&out);\n\t*val = out;\n\n\treturn (ret == 2) ? 0 : ret;\n}\n\nstatic int itg3200_read_raw(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan,\n\t\tint *val, int *val2, long info)\n{\n\tint ret = 0;\n\tu8 reg;\n\tu8 regval;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treg = (u8)chan->address;\n\t\tret = itg3200_read_reg_s16(indio_dev, reg, val);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\tif (chan->type == IIO_TEMP)\n\t\t\t*val2 = 1000000000/280;\n\t\telse\n\t\t\t*val2 = 1214142;  \n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\t*val = 23000;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = itg3200_read_reg_8(indio_dev, ITG3200_REG_DLPF, &regval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = (regval & ITG3200_DLPF_CFG_MASK) ? 1000 : 8000;\n\n\t\tret = itg3200_read_reg_8(indio_dev,\n\t\t\t\t\t ITG3200_REG_SAMPLE_RATE_DIV,\n\t\t\t\t\t &regval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val /= regval + 1;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int itg3200_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val,\n\t\t\t     int val2,\n\t\t\t     long mask)\n{\n\tstruct itg3200 *st = iio_priv(indio_dev);\n\tint ret;\n\tu8 t;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (val == 0 || val2 != 0)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&st->lock);\n\n\t\tret = itg3200_read_reg_8(indio_dev, ITG3200_REG_DLPF, &t);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn ret;\n\t\t}\n\t\tt = ((t & ITG3200_DLPF_CFG_MASK) ? 1000u : 8000u) / val - 1;\n\n\t\tret = itg3200_write_reg_8(indio_dev,\n\t\t\t\t\t  ITG3200_REG_SAMPLE_RATE_DIV,\n\t\t\t\t\t  t);\n\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int itg3200_reset(struct iio_dev *indio_dev)\n{\n\tstruct itg3200 *st = iio_priv(indio_dev);\n\tint ret;\n\n\tdev_dbg(&st->i2c->dev, \"reset device\");\n\n\tret = itg3200_write_reg_8(indio_dev,\n\t\t\tITG3200_REG_POWER_MANAGEMENT,\n\t\t\tITG3200_RESET);\n\tif (ret) {\n\t\tdev_err(&st->i2c->dev, \"error resetting device\");\n\t\tgoto error_ret;\n\t}\n\n\t \n\tudelay(1500);\n\n\tret = itg3200_write_reg_8(indio_dev,\n\t\t\tITG3200_REG_IRQ_CONFIG,\n\t\t\tITG3200_IRQ_ACTIVE_HIGH |\n\t\t\tITG3200_IRQ_PUSH_PULL |\n\t\t\tITG3200_IRQ_LATCH_50US_PULSE |\n\t\t\tITG3200_IRQ_LATCH_CLEAR_ANY);\n\n\tif (ret)\n\t\tdev_err(&st->i2c->dev, \"error init device\");\n\nerror_ret:\n\treturn ret;\n}\n\n \nstatic int itg3200_enable_full_scale(struct iio_dev *indio_dev)\n{\n\tu8 val;\n\tint ret;\n\n\tret = itg3200_read_reg_8(indio_dev, ITG3200_REG_DLPF, &val);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tval |= ITG3200_DLPF_FS_SEL_2000;\n\treturn itg3200_write_reg_8(indio_dev, ITG3200_REG_DLPF, val);\n\nerr_ret:\n\treturn ret;\n}\n\nstatic int itg3200_initial_setup(struct iio_dev *indio_dev)\n{\n\tstruct itg3200 *st = iio_priv(indio_dev);\n\tint ret;\n\tu8 val;\n\n\tret = itg3200_reset(indio_dev);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = itg3200_read_reg_8(indio_dev, ITG3200_REG_ADDRESS, &val);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tif (((val >> 1) & 0x3f) != 0x34) {\n\t\tdev_err(&st->i2c->dev, \"invalid reg value 0x%02x\", val);\n\t\tret = -ENXIO;\n\t\tgoto err_ret;\n\t}\n\n\tret = itg3200_enable_full_scale(indio_dev);\nerr_ret:\n\treturn ret;\n}\n\nstatic const struct iio_mount_matrix *\nitg3200_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\t  const struct iio_chan_spec *chan)\n{\n\tstruct itg3200 *data = iio_priv(indio_dev);\n\n\treturn &data->orientation;\n}\n\nstatic const struct iio_chan_spec_ext_info itg3200_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_DIR, itg3200_get_mount_matrix),\n\t{ }\n};\n\n#define ITG3200_ST\t\t\t\t\t\t\\\n\t{ .sign = 's', .realbits = 16, .storagebits = 16, .endianness = IIO_BE }\n\n#define ITG3200_GYRO_CHAN(_mod) { \\\n\t.type = IIO_ANGL_VEL, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_ ## _mod, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \\\n\t.address = ITG3200_REG_GYRO_ ## _mod ## OUT_H, \\\n\t.scan_index = ITG3200_SCAN_GYRO_ ## _mod, \\\n\t.scan_type = ITG3200_ST, \\\n\t.ext_info = itg3200_ext_info, \\\n}\n\nstatic const struct iio_chan_spec itg3200_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.channel2 = IIO_NO_MOD,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET) |\n\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.address = ITG3200_REG_TEMP_OUT_H,\n\t\t.scan_index = ITG3200_SCAN_TEMP,\n\t\t.scan_type = ITG3200_ST,\n\t},\n\tITG3200_GYRO_CHAN(X),\n\tITG3200_GYRO_CHAN(Y),\n\tITG3200_GYRO_CHAN(Z),\n\tIIO_CHAN_SOFT_TIMESTAMP(ITG3200_SCAN_ELEMENTS),\n};\n\nstatic const struct iio_info itg3200_info = {\n\t.read_raw = &itg3200_read_raw,\n\t.write_raw = &itg3200_write_raw,\n};\n\nstatic const unsigned long itg3200_available_scan_masks[] = { 0xffffffff, 0x0 };\n\nstatic int itg3200_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct itg3200 *st;\n\tstruct iio_dev *indio_dev;\n\n\tdev_dbg(&client->dev, \"probe I2C dev with IRQ %i\", client->irq);\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tret = iio_read_mount_matrix(&client->dev, &st->orientation);\n\tif (ret)\n\t\treturn ret;\n\n\ti2c_set_clientdata(client, indio_dev);\n\tst->i2c = client;\n\n\tindio_dev->name = client->dev.driver->name;\n\tindio_dev->channels = itg3200_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(itg3200_channels);\n\tindio_dev->available_scan_masks = itg3200_available_scan_masks;\n\tindio_dev->info = &itg3200_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = itg3200_buffer_configure(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (client->irq) {\n\t\tret = itg3200_probe_trigger(indio_dev);\n\t\tif (ret)\n\t\t\tgoto error_unconfigure_buffer;\n\t}\n\n\tret = itg3200_initial_setup(indio_dev);\n\tif (ret)\n\t\tgoto error_remove_trigger;\n\n\tmutex_init(&st->lock);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret)\n\t\tgoto error_remove_trigger;\n\n\treturn 0;\n\nerror_remove_trigger:\n\tif (client->irq)\n\t\titg3200_remove_trigger(indio_dev);\nerror_unconfigure_buffer:\n\titg3200_buffer_unconfigure(indio_dev);\n\treturn ret;\n}\n\nstatic void itg3200_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\n\tiio_device_unregister(indio_dev);\n\n\tif (client->irq)\n\t\titg3200_remove_trigger(indio_dev);\n\n\titg3200_buffer_unconfigure(indio_dev);\n}\n\nstatic int itg3200_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct itg3200 *st = iio_priv(indio_dev);\n\n\tdev_dbg(&st->i2c->dev, \"suspend device\");\n\n\treturn itg3200_write_reg_8(indio_dev, ITG3200_REG_POWER_MANAGEMENT,\n\t\t\t\t   ITG3200_SLEEP);\n}\n\nstatic int itg3200_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\n\treturn itg3200_initial_setup(indio_dev);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(itg3200_pm_ops, itg3200_suspend,\n\t\t\t\titg3200_resume);\n\nstatic const struct i2c_device_id itg3200_id[] = {\n\t{ \"itg3200\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, itg3200_id);\n\nstatic const struct of_device_id itg3200_of_match[] = {\n\t{ .compatible = \"invensense,itg3200\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, itg3200_of_match);\n\nstatic struct i2c_driver itg3200_driver = {\n\t.driver = {\n\t\t.name\t= \"itg3200\",\n\t\t.of_match_table = itg3200_of_match,\n\t\t.pm\t= pm_sleep_ptr(&itg3200_pm_ops),\n\t},\n\t.id_table\t= itg3200_id,\n\t.probe\t\t= itg3200_probe,\n\t.remove\t\t= itg3200_remove,\n};\n\nmodule_i2c_driver(itg3200_driver);\n\nMODULE_AUTHOR(\"Christian Strobel <christian.strobel@iis.fraunhofer.de>\");\nMODULE_DESCRIPTION(\"ITG3200 Gyroscope I2C driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}