{
  "module_name": "adis16136.c",
  "hash_id": "969a093ba5921d7b7ccb65a1b4830a280d68b0c08aaec82b8c2a2b12d2699eff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/gyro/adis16136.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/sysfs.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/imu/adis.h>\n\n#include <linux/debugfs.h>\n\n#define ADIS16136_REG_FLASH_CNT\t\t0x00\n#define ADIS16136_REG_TEMP_OUT\t\t0x02\n#define ADIS16136_REG_GYRO_OUT2\t\t0x04\n#define ADIS16136_REG_GYRO_OUT\t\t0x06\n#define ADIS16136_REG_GYRO_OFF2\t\t0x08\n#define ADIS16136_REG_GYRO_OFF\t\t0x0A\n#define ADIS16136_REG_ALM_MAG1\t\t0x10\n#define ADIS16136_REG_ALM_MAG2\t\t0x12\n#define ADIS16136_REG_ALM_SAMPL1\t0x14\n#define ADIS16136_REG_ALM_SAMPL2\t0x16\n#define ADIS16136_REG_ALM_CTRL\t\t0x18\n#define ADIS16136_REG_GPIO_CTRL\t\t0x1A\n#define ADIS16136_REG_MSC_CTRL\t\t0x1C\n#define ADIS16136_REG_SMPL_PRD\t\t0x1E\n#define ADIS16136_REG_AVG_CNT\t\t0x20\n#define ADIS16136_REG_DEC_RATE\t\t0x22\n#define ADIS16136_REG_SLP_CTRL\t\t0x24\n#define ADIS16136_REG_DIAG_STAT\t\t0x26\n#define ADIS16136_REG_GLOB_CMD\t\t0x28\n#define ADIS16136_REG_LOT1\t\t0x32\n#define ADIS16136_REG_LOT2\t\t0x34\n#define ADIS16136_REG_LOT3\t\t0x36\n#define ADIS16136_REG_PROD_ID\t\t0x38\n#define ADIS16136_REG_SERIAL_NUM\t0x3A\n\n#define ADIS16136_DIAG_STAT_FLASH_UPDATE_FAIL\t2\n#define ADIS16136_DIAG_STAT_SPI_FAIL\t\t3\n#define ADIS16136_DIAG_STAT_SELF_TEST_FAIL\t5\n#define ADIS16136_DIAG_STAT_FLASH_CHKSUM_FAIL\t6\n\n#define ADIS16136_MSC_CTRL_MEMORY_TEST BIT(11)\n#define ADIS16136_MSC_CTRL_SELF_TEST BIT(10)\n\nstruct adis16136_chip_info {\n\tunsigned int precision;\n\tunsigned int fullscale;\n\tconst struct adis_data adis_data;\n};\n\nstruct adis16136 {\n\tconst struct adis16136_chip_info *chip_info;\n\n\tstruct adis adis;\n};\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic ssize_t adis16136_show_serial(struct file *file,\n\t\tchar __user *userbuf, size_t count, loff_t *ppos)\n{\n\tstruct adis16136 *adis16136 = file->private_data;\n\tuint16_t lot1, lot2, lot3, serial;\n\tchar buf[20];\n\tsize_t len;\n\tint ret;\n\n\tret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_SERIAL_NUM,\n\t\t&serial);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_LOT1, &lot1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_LOT2, &lot2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_LOT3, &lot3);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = snprintf(buf, sizeof(buf), \"%.4x%.4x%.4x-%.4x\\n\", lot1, lot2,\n\t\tlot3, serial);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations adis16136_serial_fops = {\n\t.open = simple_open,\n\t.read = adis16136_show_serial,\n\t.llseek = default_llseek,\n\t.owner = THIS_MODULE,\n};\n\nstatic int adis16136_show_product_id(void *arg, u64 *val)\n{\n\tstruct adis16136 *adis16136 = arg;\n\tu16 prod_id;\n\tint ret;\n\n\tret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_PROD_ID,\n\t\t&prod_id);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = prod_id;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(adis16136_product_id_fops,\n\tadis16136_show_product_id, NULL, \"%llu\\n\");\n\nstatic int adis16136_show_flash_count(void *arg, u64 *val)\n{\n\tstruct adis16136 *adis16136 = arg;\n\tuint16_t flash_count;\n\tint ret;\n\n\tret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_FLASH_CNT,\n\t\t&flash_count);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = flash_count;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(adis16136_flash_count_fops,\n\tadis16136_show_flash_count, NULL, \"%lld\\n\");\n\nstatic int adis16136_debugfs_init(struct iio_dev *indio_dev)\n{\n\tstruct adis16136 *adis16136 = iio_priv(indio_dev);\n\tstruct dentry *d = iio_get_debugfs_dentry(indio_dev);\n\n\tdebugfs_create_file_unsafe(\"serial_number\", 0400,\n\t\td, adis16136, &adis16136_serial_fops);\n\tdebugfs_create_file_unsafe(\"product_id\", 0400,\n\t\td, adis16136, &adis16136_product_id_fops);\n\tdebugfs_create_file_unsafe(\"flash_count\", 0400,\n\t\td, adis16136, &adis16136_flash_count_fops);\n\n\treturn 0;\n}\n\n#else\n\nstatic int adis16136_debugfs_init(struct iio_dev *indio_dev)\n{\n\treturn 0;\n}\n\n#endif\n\nstatic int adis16136_set_freq(struct adis16136 *adis16136, unsigned int freq)\n{\n\tunsigned int t;\n\n\tt = 32768 / freq;\n\tif (t < 0xf)\n\t\tt = 0xf;\n\telse if (t > 0xffff)\n\t\tt = 0xffff;\n\telse\n\t\tt--;\n\n\treturn adis_write_reg_16(&adis16136->adis, ADIS16136_REG_SMPL_PRD, t);\n}\n\nstatic int __adis16136_get_freq(struct adis16136 *adis16136, unsigned int *freq)\n{\n\tuint16_t t;\n\tint ret;\n\n\tret = __adis_read_reg_16(&adis16136->adis, ADIS16136_REG_SMPL_PRD, &t);\n\tif (ret)\n\t\treturn ret;\n\n\t*freq = 32768 / (t + 1);\n\n\treturn 0;\n}\n\nstatic ssize_t adis16136_write_frequency(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct adis16136 *adis16136 = iio_priv(indio_dev);\n\tunsigned int val;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val == 0)\n\t\treturn -EINVAL;\n\n\tret = adis16136_set_freq(adis16136, val);\n\n\treturn ret ? ret : len;\n}\n\nstatic ssize_t adis16136_read_frequency(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct adis16136 *adis16136 = iio_priv(indio_dev);\n\tunsigned int freq;\n\tint ret;\n\n\tadis_dev_lock(&adis16136->adis);\n\tret = __adis16136_get_freq(adis16136, &freq);\n\tadis_dev_unlock(&adis16136->adis);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", freq);\n}\n\nstatic IIO_DEV_ATTR_SAMP_FREQ(S_IWUSR | S_IRUGO,\n\t\t\t\t  adis16136_read_frequency,\n\t\t\t\t  adis16136_write_frequency);\n\nstatic const unsigned adis16136_3db_divisors[] = {\n\t[0] = 2,  \n\t[1] = 6,\n\t[2] = 12,\n\t[3] = 25,\n\t[4] = 50,\n\t[5] = 100,\n\t[6] = 200,\n\t[7] = 200,  \n};\n\nstatic int adis16136_set_filter(struct iio_dev *indio_dev, int val)\n{\n\tstruct adis16136 *adis16136 = iio_priv(indio_dev);\n\tunsigned int freq;\n\tint i, ret;\n\n\tadis_dev_lock(&adis16136->adis);\n\tret = __adis16136_get_freq(adis16136, &freq);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tfor (i = ARRAY_SIZE(adis16136_3db_divisors) - 1; i >= 1; i--) {\n\t\tif (freq / adis16136_3db_divisors[i] >= val)\n\t\t\tbreak;\n\t}\n\n\tret = __adis_write_reg_16(&adis16136->adis, ADIS16136_REG_AVG_CNT, i);\nout_unlock:\n\tadis_dev_unlock(&adis16136->adis);\n\n\treturn ret;\n}\n\nstatic int adis16136_get_filter(struct iio_dev *indio_dev, int *val)\n{\n\tstruct adis16136 *adis16136 = iio_priv(indio_dev);\n\tunsigned int freq;\n\tuint16_t val16;\n\tint ret;\n\n\tadis_dev_lock(&adis16136->adis);\n\n\tret = __adis_read_reg_16(&adis16136->adis, ADIS16136_REG_AVG_CNT,\n\t\t\t\t &val16);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tret = __adis16136_get_freq(adis16136, &freq);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\t*val = freq / adis16136_3db_divisors[val16 & 0x07];\n\nerr_unlock:\n\tadis_dev_unlock(&adis16136->adis);\n\n\treturn ret ? ret : IIO_VAL_INT;\n}\n\nstatic int adis16136_read_raw(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int *val, int *val2, long info)\n{\n\tstruct adis16136 *adis16136 = iio_priv(indio_dev);\n\tuint32_t val32;\n\tint ret;\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn adis_single_conversion(indio_dev, chan, 0, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\t*val = adis16136->chip_info->precision;\n\t\t\t*val2 = (adis16136->chip_info->fullscale << 16);\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_TEMP:\n\t\t\t*val = 10;\n\t\t\t*val2 = 697000;  \n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = adis_read_reg_32(&adis16136->adis,\n\t\t\tADIS16136_REG_GYRO_OFF2, &val32);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = sign_extend32(val32, 31);\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn adis16136_get_filter(indio_dev, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adis16136_write_raw(struct iio_dev *indio_dev,\n\tconst struct iio_chan_spec *chan, int val, int val2, long info)\n{\n\tstruct adis16136 *adis16136 = iio_priv(indio_dev);\n\n\tswitch (info) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\treturn adis_write_reg_32(&adis16136->adis,\n\t\t\tADIS16136_REG_GYRO_OFF2, val);\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn adis16136_set_filter(indio_dev, val);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nenum {\n\tADIS16136_SCAN_GYRO,\n\tADIS16136_SCAN_TEMP,\n};\n\nstatic const struct iio_chan_spec adis16136_channels[] = {\n\t{\n\t\t.type = IIO_ANGL_VEL,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_X,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_CALIBBIAS) |\n\t\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\n\t\t.address = ADIS16136_REG_GYRO_OUT2,\n\t\t.scan_index = ADIS16136_SCAN_GYRO,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 32,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t}, {\n\t\t.type = IIO_TEMP,\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.address = ADIS16136_REG_TEMP_OUT,\n\t\t.scan_index = ADIS16136_SCAN_TEMP,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_BE,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(2),\n};\n\nstatic struct attribute *adis16136_attributes[] = {\n\t&iio_dev_attr_sampling_frequency.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adis16136_attribute_group = {\n\t.attrs = adis16136_attributes,\n};\n\nstatic const struct iio_info adis16136_info = {\n\t.attrs = &adis16136_attribute_group,\n\t.read_raw = &adis16136_read_raw,\n\t.write_raw = &adis16136_write_raw,\n\t.update_scan_mode = adis_update_scan_mode,\n\t.debugfs_reg_access = adis_debugfs_reg_access,\n};\n\nstatic int adis16136_stop_device(struct iio_dev *indio_dev)\n{\n\tstruct adis16136 *adis16136 = iio_priv(indio_dev);\n\tint ret;\n\n\tret = adis_write_reg_16(&adis16136->adis, ADIS16136_REG_SLP_CTRL, 0xff);\n\tif (ret)\n\t\tdev_err(&indio_dev->dev,\n\t\t\t\"Could not power down device: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int adis16136_initial_setup(struct iio_dev *indio_dev)\n{\n\tstruct adis16136 *adis16136 = iio_priv(indio_dev);\n\tunsigned int device_id;\n\tuint16_t prod_id;\n\tint ret;\n\n\tret = __adis_initial_startup(&adis16136->adis);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adis_read_reg_16(&adis16136->adis, ADIS16136_REG_PROD_ID,\n\t\t&prod_id);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sscanf(indio_dev->name, \"adis%u\\n\", &device_id);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tif (prod_id != device_id)\n\t\tdev_warn(&indio_dev->dev, \"Device ID(%u) and product ID(%u) do not match.\",\n\t\t\t\tdevice_id, prod_id);\n\n\treturn 0;\n}\n\nstatic const char * const adis16136_status_error_msgs[] = {\n\t[ADIS16136_DIAG_STAT_FLASH_UPDATE_FAIL] = \"Flash update failed\",\n\t[ADIS16136_DIAG_STAT_SPI_FAIL] = \"SPI failure\",\n\t[ADIS16136_DIAG_STAT_SELF_TEST_FAIL] = \"Self test error\",\n\t[ADIS16136_DIAG_STAT_FLASH_CHKSUM_FAIL] = \"Flash checksum error\",\n};\n\n#define ADIS16136_DATA(_timeouts)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.diag_stat_reg = ADIS16136_REG_DIAG_STAT,\t\t\t\\\n\t.glob_cmd_reg = ADIS16136_REG_GLOB_CMD,\t\t\t\t\\\n\t.msc_ctrl_reg = ADIS16136_REG_MSC_CTRL,\t\t\t\t\\\n\t.self_test_reg = ADIS16136_REG_MSC_CTRL,\t\t\t\\\n\t.self_test_mask = ADIS16136_MSC_CTRL_SELF_TEST,\t\t\t\\\n\t.read_delay = 10,\t\t\t\t\t\t\\\n\t.write_delay = 10,\t\t\t\t\t\t\\\n\t.status_error_msgs = adis16136_status_error_msgs,\t\t\\\n\t.status_error_mask = BIT(ADIS16136_DIAG_STAT_FLASH_UPDATE_FAIL) |\t\\\n\t\tBIT(ADIS16136_DIAG_STAT_SPI_FAIL) |\t\t\t\\\n\t\tBIT(ADIS16136_DIAG_STAT_SELF_TEST_FAIL) |\t\t\\\n\t\tBIT(ADIS16136_DIAG_STAT_FLASH_CHKSUM_FAIL),\t\t\\\n\t.timeouts = (_timeouts),\t\t\t\t\t\\\n}\n\nenum adis16136_id {\n\tID_ADIS16133,\n\tID_ADIS16135,\n\tID_ADIS16136,\n\tID_ADIS16137,\n};\n\nstatic const struct adis_timeout adis16133_timeouts = {\n\t.reset_ms = 75,\n\t.sw_reset_ms = 75,\n\t.self_test_ms = 50,\n};\n\nstatic const struct adis_timeout adis16136_timeouts = {\n\t.reset_ms = 128,\n\t.sw_reset_ms = 75,\n\t.self_test_ms = 245,\n};\n\nstatic const struct adis16136_chip_info adis16136_chip_info[] = {\n\t[ID_ADIS16133] = {\n\t\t.precision = IIO_DEGREE_TO_RAD(1200),\n\t\t.fullscale = 24000,\n\t\t.adis_data = ADIS16136_DATA(&adis16133_timeouts),\n\t},\n\t[ID_ADIS16135] = {\n\t\t.precision = IIO_DEGREE_TO_RAD(300),\n\t\t.fullscale = 24000,\n\t\t.adis_data = ADIS16136_DATA(&adis16133_timeouts),\n\t},\n\t[ID_ADIS16136] = {\n\t\t.precision = IIO_DEGREE_TO_RAD(450),\n\t\t.fullscale = 24623,\n\t\t.adis_data = ADIS16136_DATA(&adis16136_timeouts),\n\t},\n\t[ID_ADIS16137] = {\n\t\t.precision = IIO_DEGREE_TO_RAD(1000),\n\t\t.fullscale = 24609,\n\t\t.adis_data = ADIS16136_DATA(&adis16136_timeouts),\n\t},\n};\n\nstatic void adis16136_stop(void *data)\n{\n\tadis16136_stop_device(data);\n}\n\nstatic int adis16136_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tstruct adis16136 *adis16136;\n\tstruct iio_dev *indio_dev;\n\tconst struct adis_data *adis16136_data;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adis16136));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, indio_dev);\n\n\tadis16136 = iio_priv(indio_dev);\n\n\tadis16136->chip_info = &adis16136_chip_info[id->driver_data];\n\tindio_dev->name = spi_get_device_id(spi)->name;\n\tindio_dev->channels = adis16136_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(adis16136_channels);\n\tindio_dev->info = &adis16136_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tadis16136_data = &adis16136->chip_info->adis_data;\n\n\tret = adis_init(&adis16136->adis, indio_dev, spi, adis16136_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_adis_setup_buffer_and_trigger(&adis16136->adis, indio_dev, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adis16136_initial_setup(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, adis16136_stop, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_device_register(&spi->dev, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tadis16136_debugfs_init(indio_dev);\n\n\treturn 0;\n}\n\nstatic const struct spi_device_id adis16136_ids[] = {\n\t{ \"adis16133\", ID_ADIS16133 },\n\t{ \"adis16135\", ID_ADIS16135 },\n\t{ \"adis16136\", ID_ADIS16136 },\n\t{ \"adis16137\", ID_ADIS16137 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, adis16136_ids);\n\nstatic struct spi_driver adis16136_driver = {\n\t.driver = {\n\t\t.name = \"adis16136\",\n\t},\n\t.id_table = adis16136_ids,\n\t.probe = adis16136_probe,\n};\nmodule_spi_driver(adis16136_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Analog Devices ADIS16133/ADIS16135/ADIS16136 gyroscope driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_ADISLIB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}