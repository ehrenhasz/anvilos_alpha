{
  "module_name": "adis16260.c",
  "hash_id": "3b8a6ed28db3d447b5f1a4f5ce286edb505dd3cd1aa763d82ea48690a2de6c4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/gyro/adis16260.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/spi/spi.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/imu/adis.h>\n\n#define ADIS16260_STARTUP_DELAY\t220  \n\n#define ADIS16260_FLASH_CNT  0x00  \n#define ADIS16260_SUPPLY_OUT 0x02  \n#define ADIS16260_GYRO_OUT   0x04  \n#define ADIS16260_AUX_ADC    0x0A  \n#define ADIS16260_TEMP_OUT   0x0C  \n#define ADIS16260_ANGL_OUT   0x0E  \n#define ADIS16260_GYRO_OFF   0x14  \n#define ADIS16260_GYRO_SCALE 0x16  \n#define ADIS16260_ALM_MAG1   0x20  \n#define ADIS16260_ALM_MAG2   0x22  \n#define ADIS16260_ALM_SMPL1  0x24  \n#define ADIS16260_ALM_SMPL2  0x26  \n#define ADIS16260_ALM_CTRL   0x28  \n#define ADIS16260_AUX_DAC    0x30  \n#define ADIS16260_GPIO_CTRL  0x32  \n#define ADIS16260_MSC_CTRL   0x34  \n#define ADIS16260_SMPL_PRD   0x36  \n#define ADIS16260_SENS_AVG   0x38  \n#define ADIS16260_SLP_CNT    0x3A  \n#define ADIS16260_DIAG_STAT  0x3C  \n#define ADIS16260_GLOB_CMD   0x3E  \n#define ADIS16260_LOT_ID1    0x52  \n#define ADIS16260_LOT_ID2    0x54  \n#define ADIS16260_PROD_ID    0x56  \n#define ADIS16260_SERIAL_NUM 0x58  \n\n#define ADIS16260_ERROR_ACTIVE\t\t\t(1<<14)\n#define ADIS16260_NEW_DATA\t\t\t(1<<15)\n\n \n#define ADIS16260_MSC_CTRL_MEM_TEST\t\t(1<<11)\n \n#define ADIS16260_MSC_CTRL_INT_SELF_TEST\t(1<<10)\n#define ADIS16260_MSC_CTRL_NEG_SELF_TEST\t(1<<9)\n#define ADIS16260_MSC_CTRL_POS_SELF_TEST\t(1<<8)\n#define ADIS16260_MSC_CTRL_DATA_RDY_EN\t\t(1<<2)\n#define ADIS16260_MSC_CTRL_DATA_RDY_POL_HIGH\t(1<<1)\n#define ADIS16260_MSC_CTRL_DATA_RDY_DIO2\t(1<<0)\n\n \n \n#define ADIS16260_SMPL_PRD_TIME_BASE\t(1<<7)\n#define ADIS16260_SMPL_PRD_DIV_MASK\t0x7F\n\n \n#define ADIS16260_SLP_CNT_POWER_OFF     0x80\n\n \n#define ADIS16260_DIAG_STAT_ALARM2\t(1<<9)\n#define ADIS16260_DIAG_STAT_ALARM1\t(1<<8)\n#define ADIS16260_DIAG_STAT_FLASH_CHK_BIT\t6\n#define ADIS16260_DIAG_STAT_SELF_TEST_BIT\t5\n#define ADIS16260_DIAG_STAT_OVERFLOW_BIT\t4\n#define ADIS16260_DIAG_STAT_SPI_FAIL_BIT\t3\n#define ADIS16260_DIAG_STAT_FLASH_UPT_BIT\t2\n#define ADIS16260_DIAG_STAT_POWER_HIGH_BIT\t1\n#define ADIS16260_DIAG_STAT_POWER_LOW_BIT\t0\n\n \n#define ADIS16260_GLOB_CMD_SW_RESET\t(1<<7)\n#define ADIS16260_GLOB_CMD_FLASH_UPD\t(1<<3)\n#define ADIS16260_GLOB_CMD_DAC_LATCH\t(1<<2)\n#define ADIS16260_GLOB_CMD_FAC_CALIB\t(1<<1)\n#define ADIS16260_GLOB_CMD_AUTO_NULL\t(1<<0)\n\n#define ADIS16260_SPI_SLOW\t(u32)(300 * 1000)\n#define ADIS16260_SPI_BURST\t(u32)(1000 * 1000)\n#define ADIS16260_SPI_FAST\t(u32)(2000 * 1000)\n\n \n\n#define ADIS16260_SCAN_GYRO\t0\n#define ADIS16260_SCAN_SUPPLY\t1\n#define ADIS16260_SCAN_AUX_ADC\t2\n#define ADIS16260_SCAN_TEMP\t3\n#define ADIS16260_SCAN_ANGL\t4\n\nstruct adis16260_chip_info {\n\tunsigned int gyro_max_val;\n\tunsigned int gyro_max_scale;\n\tconst struct iio_chan_spec *channels;\n\tunsigned int num_channels;\n};\n\nstruct adis16260 {\n\tconst struct adis16260_chip_info *info;\n\n\tstruct adis adis;\n};\n\nenum adis16260_type {\n\tADIS16251,\n\tADIS16260,\n\tADIS16266,\n};\n\nstatic const struct iio_chan_spec adis16260_channels[] = {\n\tADIS_GYRO_CHAN(X, ADIS16260_GYRO_OUT, ADIS16260_SCAN_GYRO,\n\t\tBIT(IIO_CHAN_INFO_CALIBBIAS) |\n\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ), 14),\n\tADIS_INCLI_CHAN(X, ADIS16260_ANGL_OUT, ADIS16260_SCAN_ANGL, 0,\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ), 14),\n\tADIS_TEMP_CHAN(ADIS16260_TEMP_OUT, ADIS16260_SCAN_TEMP,\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ), 12),\n\tADIS_SUPPLY_CHAN(ADIS16260_SUPPLY_OUT, ADIS16260_SCAN_SUPPLY,\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ), 12),\n\tADIS_AUX_ADC_CHAN(ADIS16260_AUX_ADC, ADIS16260_SCAN_AUX_ADC,\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ), 12),\n\tIIO_CHAN_SOFT_TIMESTAMP(5),\n};\n\nstatic const struct iio_chan_spec adis16266_channels[] = {\n\tADIS_GYRO_CHAN(X, ADIS16260_GYRO_OUT, ADIS16260_SCAN_GYRO,\n\t\tBIT(IIO_CHAN_INFO_CALIBBIAS) |\n\t\tBIT(IIO_CHAN_INFO_CALIBSCALE),\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ), 14),\n\tADIS_TEMP_CHAN(ADIS16260_TEMP_OUT, ADIS16260_SCAN_TEMP,\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ), 12),\n\tADIS_SUPPLY_CHAN(ADIS16260_SUPPLY_OUT, ADIS16260_SCAN_SUPPLY,\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ), 12),\n\tADIS_AUX_ADC_CHAN(ADIS16260_AUX_ADC, ADIS16260_SCAN_AUX_ADC,\n\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ), 12),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic const struct adis16260_chip_info adis16260_chip_info_table[] = {\n\t[ADIS16251] = {\n\t\t.gyro_max_scale = 80,\n\t\t.gyro_max_val = IIO_RAD_TO_DEGREE(4368),\n\t\t.channels = adis16260_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16260_channels),\n\t},\n\t[ADIS16260] = {\n\t\t.gyro_max_scale = 320,\n\t\t.gyro_max_val = IIO_RAD_TO_DEGREE(4368),\n\t\t.channels = adis16260_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16260_channels),\n\t},\n\t[ADIS16266] = {\n\t\t.gyro_max_scale = 14000,\n\t\t.gyro_max_val = IIO_RAD_TO_DEGREE(3357),\n\t\t.channels = adis16266_channels,\n\t\t.num_channels = ARRAY_SIZE(adis16266_channels),\n\t},\n};\n\n \nstatic int adis16260_stop_device(struct iio_dev *indio_dev)\n{\n\tstruct adis16260 *adis16260 = iio_priv(indio_dev);\n\tint ret;\n\tu16 val = ADIS16260_SLP_CNT_POWER_OFF;\n\n\tret = adis_write_reg_16(&adis16260->adis, ADIS16260_SLP_CNT, val);\n\tif (ret)\n\t\tdev_err(&indio_dev->dev, \"problem with turning device off: SLP_CNT\");\n\n\treturn ret;\n}\n\nstatic const u8 adis16260_addresses[][2] = {\n\t[ADIS16260_SCAN_GYRO] = { ADIS16260_GYRO_OFF, ADIS16260_GYRO_SCALE },\n};\n\nstatic int adis16260_read_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int *val, int *val2,\n\t\t\t      long mask)\n{\n\tstruct adis16260 *adis16260 = iio_priv(indio_dev);\n\tconst struct adis16260_chip_info *info = adis16260->info;\n\tstruct adis *adis = &adis16260->adis;\n\tint ret;\n\tu8 addr;\n\ts16 val16;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn adis_single_conversion(indio_dev, chan,\n\t\t\t\tADIS16260_ERROR_ACTIVE, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_ANGL_VEL:\n\t\t\t*val = info->gyro_max_scale;\n\t\t\t*val2 = info->gyro_max_val;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_INCLI:\n\t\t\t*val = 0;\n\t\t\t*val2 = IIO_DEGREE_TO_RAD(36630);\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_VOLTAGE:\n\t\t\tif (chan->channel == 0) {\n\t\t\t\t*val = 1;\n\t\t\t\t*val2 = 831500;  \n\t\t\t} else {\n\t\t\t\t*val = 0;\n\t\t\t\t*val2 = 610500;  \n\t\t\t}\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_TEMP:\n\t\t\t*val = 145;\n\t\t\t*val2 = 300000;  \n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = 250000 / 1453;  \n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\taddr = adis16260_addresses[chan->scan_index][0];\n\t\tret = adis_read_reg_16(adis, addr, &val16);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = sign_extend32(val16, 11);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\taddr = adis16260_addresses[chan->scan_index][1];\n\t\tret = adis_read_reg_16(adis, addr, &val16);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = val16;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = adis_read_reg_16(adis, ADIS16260_SMPL_PRD, &val16);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (spi_get_device_id(adis->spi)->driver_data)\n\t\t \n\t\t\t*val = (val16 & ADIS16260_SMPL_PRD_TIME_BASE) ?\n\t\t\t\t8 : 256;\n\t\telse\n\t\t\t*val = (val16 & ADIS16260_SMPL_PRD_TIME_BASE) ?\n\t\t\t\t66 : 2048;\n\t\t*val /= (val16 & ADIS16260_SMPL_PRD_DIV_MASK) + 1;\n\t\treturn IIO_VAL_INT;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int adis16260_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val,\n\t\t\t       int val2,\n\t\t\t       long mask)\n{\n\tstruct adis16260 *adis16260 = iio_priv(indio_dev);\n\tstruct adis *adis = &adis16260->adis;\n\tint ret;\n\tu8 addr;\n\tu8 t;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif (val < -2048 || val >= 2048)\n\t\t\treturn -EINVAL;\n\n\t\taddr = adis16260_addresses[chan->scan_index][0];\n\t\treturn adis_write_reg_16(adis, addr, val);\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tif (val < 0 || val >= 4096)\n\t\t\treturn -EINVAL;\n\n\t\taddr = adis16260_addresses[chan->scan_index][1];\n\t\treturn adis_write_reg_16(adis, addr, val);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tadis_dev_lock(adis);\n\t\tif (spi_get_device_id(adis->spi)->driver_data)\n\t\t\tt = 256 / val;\n\t\telse\n\t\t\tt = 2048 / val;\n\n\t\tif (t > ADIS16260_SMPL_PRD_DIV_MASK)\n\t\t\tt = ADIS16260_SMPL_PRD_DIV_MASK;\n\t\telse if (t > 0)\n\t\t\tt--;\n\n\t\tif (t >= 0x0A)\n\t\t\tadis->spi->max_speed_hz = ADIS16260_SPI_SLOW;\n\t\telse\n\t\t\tadis->spi->max_speed_hz = ADIS16260_SPI_FAST;\n\t\tret = __adis_write_reg_8(adis, ADIS16260_SMPL_PRD, t);\n\n\t\tadis_dev_unlock(adis);\n\t\treturn ret;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info adis16260_info = {\n\t.read_raw = &adis16260_read_raw,\n\t.write_raw = &adis16260_write_raw,\n\t.update_scan_mode = adis_update_scan_mode,\n};\n\nstatic const char * const adis1620_status_error_msgs[] = {\n\t[ADIS16260_DIAG_STAT_FLASH_CHK_BIT] = \"Flash checksum error\",\n\t[ADIS16260_DIAG_STAT_SELF_TEST_BIT] = \"Self test error\",\n\t[ADIS16260_DIAG_STAT_OVERFLOW_BIT] = \"Sensor overrange\",\n\t[ADIS16260_DIAG_STAT_SPI_FAIL_BIT] = \"SPI failure\",\n\t[ADIS16260_DIAG_STAT_FLASH_UPT_BIT] = \"Flash update failed\",\n\t[ADIS16260_DIAG_STAT_POWER_HIGH_BIT] = \"Power supply above 5.25\",\n\t[ADIS16260_DIAG_STAT_POWER_LOW_BIT] = \"Power supply below 4.75\",\n};\n\nstatic const struct adis_timeout adis16260_timeouts = {\n\t.reset_ms = ADIS16260_STARTUP_DELAY,\n\t.sw_reset_ms = ADIS16260_STARTUP_DELAY,\n\t.self_test_ms = ADIS16260_STARTUP_DELAY,\n};\n\nstatic const struct adis_data adis16260_data = {\n\t.write_delay = 30,\n\t.read_delay = 30,\n\t.msc_ctrl_reg = ADIS16260_MSC_CTRL,\n\t.glob_cmd_reg = ADIS16260_GLOB_CMD,\n\t.diag_stat_reg = ADIS16260_DIAG_STAT,\n\n\t.self_test_mask = ADIS16260_MSC_CTRL_MEM_TEST,\n\t.self_test_reg = ADIS16260_MSC_CTRL,\n\t.timeouts = &adis16260_timeouts,\n\n\t.status_error_msgs = adis1620_status_error_msgs,\n\t.status_error_mask = BIT(ADIS16260_DIAG_STAT_FLASH_CHK_BIT) |\n\t\tBIT(ADIS16260_DIAG_STAT_SELF_TEST_BIT) |\n\t\tBIT(ADIS16260_DIAG_STAT_OVERFLOW_BIT) |\n\t\tBIT(ADIS16260_DIAG_STAT_SPI_FAIL_BIT) |\n\t\tBIT(ADIS16260_DIAG_STAT_FLASH_UPT_BIT) |\n\t\tBIT(ADIS16260_DIAG_STAT_POWER_HIGH_BIT) |\n\t\tBIT(ADIS16260_DIAG_STAT_POWER_LOW_BIT),\n};\n\nstatic void adis16260_stop(void *data)\n{\n\tadis16260_stop_device(data);\n}\n\nstatic int adis16260_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id;\n\tstruct adis16260 *adis16260;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tid = spi_get_device_id(spi);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\t \n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adis16260));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\tadis16260 = iio_priv(indio_dev);\n\t \n\tspi_set_drvdata(spi, indio_dev);\n\n\tadis16260->info = &adis16260_chip_info_table[id->driver_data];\n\n\tindio_dev->name = id->name;\n\tindio_dev->info = &adis16260_info;\n\tindio_dev->channels = adis16260->info->channels;\n\tindio_dev->num_channels = adis16260->info->num_channels;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = adis_init(&adis16260->adis, indio_dev, spi, &adis16260_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_adis_setup_buffer_and_trigger(&adis16260->adis, indio_dev, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = __adis_initial_startup(&adis16260->adis);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&spi->dev, adis16260_stop, indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\n \nstatic const struct spi_device_id adis16260_id[] = {\n\t{\"adis16260\", ADIS16260},\n\t{\"adis16265\", ADIS16260},\n\t{\"adis16266\", ADIS16266},\n\t{\"adis16250\", ADIS16260},\n\t{\"adis16255\", ADIS16260},\n\t{\"adis16251\", ADIS16251},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, adis16260_id);\n\nstatic struct spi_driver adis16260_driver = {\n\t.driver = {\n\t\t.name = \"adis16260\",\n\t},\n\t.probe = adis16260_probe,\n\t.id_table = adis16260_id,\n};\nmodule_spi_driver(adis16260_driver);\n\nMODULE_AUTHOR(\"Barry Song <21cnbao@gmail.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADIS16260/5 Digital Gyroscope Sensor\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_ADISLIB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}