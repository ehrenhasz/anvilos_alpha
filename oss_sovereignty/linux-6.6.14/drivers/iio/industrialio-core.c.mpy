{
  "module_name": "industrialio-core.c",
  "hash_id": "7e3ecc32774305f9455af7d050081536198f81950c1b1a3d376d561b283124dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/industrialio-core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"iio-core: \" fmt\n\n#include <linux/anon_inodes.h>\n#include <linux/cdev.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/idr.h>\n#include <linux/kdev_t.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/property.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/buffer_impl.h>\n#include <linux/iio/events.h>\n#include <linux/iio/iio-opaque.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#include \"iio_core.h\"\n#include \"iio_core_trigger.h\"\n\n \nstatic DEFINE_IDA(iio_ida);\n\nstatic dev_t iio_devt;\n\n#define IIO_DEV_MAX 256\nstruct bus_type iio_bus_type = {\n\t.name = \"iio\",\n};\nEXPORT_SYMBOL(iio_bus_type);\n\nstatic struct dentry *iio_debugfs_dentry;\n\nstatic const char * const iio_direction[] = {\n\t[0] = \"in\",\n\t[1] = \"out\",\n};\n\nstatic const char * const iio_chan_type_name_spec[] = {\n\t[IIO_VOLTAGE] = \"voltage\",\n\t[IIO_CURRENT] = \"current\",\n\t[IIO_POWER] = \"power\",\n\t[IIO_ACCEL] = \"accel\",\n\t[IIO_ANGL_VEL] = \"anglvel\",\n\t[IIO_MAGN] = \"magn\",\n\t[IIO_LIGHT] = \"illuminance\",\n\t[IIO_INTENSITY] = \"intensity\",\n\t[IIO_PROXIMITY] = \"proximity\",\n\t[IIO_TEMP] = \"temp\",\n\t[IIO_INCLI] = \"incli\",\n\t[IIO_ROT] = \"rot\",\n\t[IIO_ANGL] = \"angl\",\n\t[IIO_TIMESTAMP] = \"timestamp\",\n\t[IIO_CAPACITANCE] = \"capacitance\",\n\t[IIO_ALTVOLTAGE] = \"altvoltage\",\n\t[IIO_CCT] = \"cct\",\n\t[IIO_PRESSURE] = \"pressure\",\n\t[IIO_HUMIDITYRELATIVE] = \"humidityrelative\",\n\t[IIO_ACTIVITY] = \"activity\",\n\t[IIO_STEPS] = \"steps\",\n\t[IIO_ENERGY] = \"energy\",\n\t[IIO_DISTANCE] = \"distance\",\n\t[IIO_VELOCITY] = \"velocity\",\n\t[IIO_CONCENTRATION] = \"concentration\",\n\t[IIO_RESISTANCE] = \"resistance\",\n\t[IIO_PH] = \"ph\",\n\t[IIO_UVINDEX] = \"uvindex\",\n\t[IIO_ELECTRICALCONDUCTIVITY] = \"electricalconductivity\",\n\t[IIO_COUNT] = \"count\",\n\t[IIO_INDEX] = \"index\",\n\t[IIO_GRAVITY]  = \"gravity\",\n\t[IIO_POSITIONRELATIVE]  = \"positionrelative\",\n\t[IIO_PHASE] = \"phase\",\n\t[IIO_MASSCONCENTRATION] = \"massconcentration\",\n};\n\nstatic const char * const iio_modifier_names[] = {\n\t[IIO_MOD_X] = \"x\",\n\t[IIO_MOD_Y] = \"y\",\n\t[IIO_MOD_Z] = \"z\",\n\t[IIO_MOD_X_AND_Y] = \"x&y\",\n\t[IIO_MOD_X_AND_Z] = \"x&z\",\n\t[IIO_MOD_Y_AND_Z] = \"y&z\",\n\t[IIO_MOD_X_AND_Y_AND_Z] = \"x&y&z\",\n\t[IIO_MOD_X_OR_Y] = \"x|y\",\n\t[IIO_MOD_X_OR_Z] = \"x|z\",\n\t[IIO_MOD_Y_OR_Z] = \"y|z\",\n\t[IIO_MOD_X_OR_Y_OR_Z] = \"x|y|z\",\n\t[IIO_MOD_ROOT_SUM_SQUARED_X_Y] = \"sqrt(x^2+y^2)\",\n\t[IIO_MOD_SUM_SQUARED_X_Y_Z] = \"x^2+y^2+z^2\",\n\t[IIO_MOD_LIGHT_BOTH] = \"both\",\n\t[IIO_MOD_LIGHT_IR] = \"ir\",\n\t[IIO_MOD_LIGHT_CLEAR] = \"clear\",\n\t[IIO_MOD_LIGHT_RED] = \"red\",\n\t[IIO_MOD_LIGHT_GREEN] = \"green\",\n\t[IIO_MOD_LIGHT_BLUE] = \"blue\",\n\t[IIO_MOD_LIGHT_UV] = \"uv\",\n\t[IIO_MOD_LIGHT_DUV] = \"duv\",\n\t[IIO_MOD_QUATERNION] = \"quaternion\",\n\t[IIO_MOD_TEMP_AMBIENT] = \"ambient\",\n\t[IIO_MOD_TEMP_OBJECT] = \"object\",\n\t[IIO_MOD_NORTH_MAGN] = \"from_north_magnetic\",\n\t[IIO_MOD_NORTH_TRUE] = \"from_north_true\",\n\t[IIO_MOD_NORTH_MAGN_TILT_COMP] = \"from_north_magnetic_tilt_comp\",\n\t[IIO_MOD_NORTH_TRUE_TILT_COMP] = \"from_north_true_tilt_comp\",\n\t[IIO_MOD_RUNNING] = \"running\",\n\t[IIO_MOD_JOGGING] = \"jogging\",\n\t[IIO_MOD_WALKING] = \"walking\",\n\t[IIO_MOD_STILL] = \"still\",\n\t[IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z] = \"sqrt(x^2+y^2+z^2)\",\n\t[IIO_MOD_I] = \"i\",\n\t[IIO_MOD_Q] = \"q\",\n\t[IIO_MOD_CO2] = \"co2\",\n\t[IIO_MOD_VOC] = \"voc\",\n\t[IIO_MOD_PM1] = \"pm1\",\n\t[IIO_MOD_PM2P5] = \"pm2p5\",\n\t[IIO_MOD_PM4] = \"pm4\",\n\t[IIO_MOD_PM10] = \"pm10\",\n\t[IIO_MOD_ETHANOL] = \"ethanol\",\n\t[IIO_MOD_H2] = \"h2\",\n\t[IIO_MOD_O2] = \"o2\",\n\t[IIO_MOD_LINEAR_X] = \"linear_x\",\n\t[IIO_MOD_LINEAR_Y] = \"linear_y\",\n\t[IIO_MOD_LINEAR_Z] = \"linear_z\",\n\t[IIO_MOD_PITCH] = \"pitch\",\n\t[IIO_MOD_YAW] = \"yaw\",\n\t[IIO_MOD_ROLL] = \"roll\",\n};\n\n \nstatic const char * const iio_chan_info_postfix[] = {\n\t[IIO_CHAN_INFO_RAW] = \"raw\",\n\t[IIO_CHAN_INFO_PROCESSED] = \"input\",\n\t[IIO_CHAN_INFO_SCALE] = \"scale\",\n\t[IIO_CHAN_INFO_OFFSET] = \"offset\",\n\t[IIO_CHAN_INFO_CALIBSCALE] = \"calibscale\",\n\t[IIO_CHAN_INFO_CALIBBIAS] = \"calibbias\",\n\t[IIO_CHAN_INFO_PEAK] = \"peak_raw\",\n\t[IIO_CHAN_INFO_PEAK_SCALE] = \"peak_scale\",\n\t[IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW] = \"quadrature_correction_raw\",\n\t[IIO_CHAN_INFO_AVERAGE_RAW] = \"mean_raw\",\n\t[IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY]\n\t= \"filter_low_pass_3db_frequency\",\n\t[IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY]\n\t= \"filter_high_pass_3db_frequency\",\n\t[IIO_CHAN_INFO_SAMP_FREQ] = \"sampling_frequency\",\n\t[IIO_CHAN_INFO_FREQUENCY] = \"frequency\",\n\t[IIO_CHAN_INFO_PHASE] = \"phase\",\n\t[IIO_CHAN_INFO_HARDWAREGAIN] = \"hardwaregain\",\n\t[IIO_CHAN_INFO_HYSTERESIS] = \"hysteresis\",\n\t[IIO_CHAN_INFO_HYSTERESIS_RELATIVE] = \"hysteresis_relative\",\n\t[IIO_CHAN_INFO_INT_TIME] = \"integration_time\",\n\t[IIO_CHAN_INFO_ENABLE] = \"en\",\n\t[IIO_CHAN_INFO_CALIBHEIGHT] = \"calibheight\",\n\t[IIO_CHAN_INFO_CALIBWEIGHT] = \"calibweight\",\n\t[IIO_CHAN_INFO_DEBOUNCE_COUNT] = \"debounce_count\",\n\t[IIO_CHAN_INFO_DEBOUNCE_TIME] = \"debounce_time\",\n\t[IIO_CHAN_INFO_CALIBEMISSIVITY] = \"calibemissivity\",\n\t[IIO_CHAN_INFO_OVERSAMPLING_RATIO] = \"oversampling_ratio\",\n\t[IIO_CHAN_INFO_THERMOCOUPLE_TYPE] = \"thermocouple_type\",\n\t[IIO_CHAN_INFO_CALIBAMBIENT] = \"calibambient\",\n\t[IIO_CHAN_INFO_ZEROPOINT] = \"zeropoint\",\n};\n \nint iio_device_id(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\n\treturn iio_dev_opaque->id;\n}\nEXPORT_SYMBOL_GPL(iio_device_id);\n\n \nbool iio_buffer_enabled(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\n\treturn iio_dev_opaque->currentmode &\n\t       (INDIO_BUFFER_HARDWARE | INDIO_BUFFER_SOFTWARE |\n\t\tINDIO_BUFFER_TRIGGERED);\n}\nEXPORT_SYMBOL_GPL(iio_buffer_enabled);\n\n#if defined(CONFIG_DEBUG_FS)\n \nstruct dentry *iio_get_debugfs_dentry(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\n\treturn iio_dev_opaque->debugfs_dentry;\n}\nEXPORT_SYMBOL_GPL(iio_get_debugfs_dentry);\n#endif\n\n \nconst struct iio_chan_spec\n*iio_find_channel_from_si(struct iio_dev *indio_dev, int si)\n{\n\tint i;\n\n\tfor (i = 0; i < indio_dev->num_channels; i++)\n\t\tif (indio_dev->channels[i].scan_index == si)\n\t\t\treturn &indio_dev->channels[i];\n\treturn NULL;\n}\n\n \nssize_t iio_read_const_attr(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", to_iio_const_attr(attr)->string);\n}\nEXPORT_SYMBOL(iio_read_const_attr);\n\n \nint iio_device_set_clock(struct iio_dev *indio_dev, clockid_t clock_id)\n{\n\tint ret;\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tconst struct iio_event_interface *ev_int = iio_dev_opaque->event_interface;\n\n\tret = mutex_lock_interruptible(&iio_dev_opaque->mlock);\n\tif (ret)\n\t\treturn ret;\n\tif ((ev_int && iio_event_enabled(ev_int)) ||\n\t    iio_buffer_enabled(indio_dev)) {\n\t\tmutex_unlock(&iio_dev_opaque->mlock);\n\t\treturn -EBUSY;\n\t}\n\tiio_dev_opaque->clock_id = clock_id;\n\tmutex_unlock(&iio_dev_opaque->mlock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iio_device_set_clock);\n\n \nclockid_t iio_device_get_clock(const struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\n\treturn iio_dev_opaque->clock_id;\n}\nEXPORT_SYMBOL(iio_device_get_clock);\n\n \ns64 iio_get_time_ns(const struct iio_dev *indio_dev)\n{\n\tstruct timespec64 tp;\n\n\tswitch (iio_device_get_clock(indio_dev)) {\n\tcase CLOCK_REALTIME:\n\t\treturn ktime_get_real_ns();\n\tcase CLOCK_MONOTONIC:\n\t\treturn ktime_get_ns();\n\tcase CLOCK_MONOTONIC_RAW:\n\t\treturn ktime_get_raw_ns();\n\tcase CLOCK_REALTIME_COARSE:\n\t\treturn ktime_to_ns(ktime_get_coarse_real());\n\tcase CLOCK_MONOTONIC_COARSE:\n\t\tktime_get_coarse_ts64(&tp);\n\t\treturn timespec64_to_ns(&tp);\n\tcase CLOCK_BOOTTIME:\n\t\treturn ktime_get_boottime_ns();\n\tcase CLOCK_TAI:\n\t\treturn ktime_get_clocktai_ns();\n\tdefault:\n\t\tBUG();\n\t}\n}\nEXPORT_SYMBOL(iio_get_time_ns);\n\nstatic int __init iio_init(void)\n{\n\tint ret;\n\n\t \n\tret  = bus_register(&iio_bus_type);\n\tif (ret < 0) {\n\t\tpr_err(\"could not register bus type\\n\");\n\t\tgoto error_nothing;\n\t}\n\n\tret = alloc_chrdev_region(&iio_devt, 0, IIO_DEV_MAX, \"iio\");\n\tif (ret < 0) {\n\t\tpr_err(\"failed to allocate char dev region\\n\");\n\t\tgoto error_unregister_bus_type;\n\t}\n\n\tiio_debugfs_dentry = debugfs_create_dir(\"iio\", NULL);\n\n\treturn 0;\n\nerror_unregister_bus_type:\n\tbus_unregister(&iio_bus_type);\nerror_nothing:\n\treturn ret;\n}\n\nstatic void __exit iio_exit(void)\n{\n\tif (iio_devt)\n\t\tunregister_chrdev_region(iio_devt, IIO_DEV_MAX);\n\tbus_unregister(&iio_bus_type);\n\tdebugfs_remove(iio_debugfs_dentry);\n}\n\n#if defined(CONFIG_DEBUG_FS)\nstatic ssize_t iio_debugfs_read_reg(struct file *file, char __user *userbuf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct iio_dev *indio_dev = file->private_data;\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tunsigned int val = 0;\n\tint ret;\n\n\tif (*ppos > 0)\n\t\treturn simple_read_from_buffer(userbuf, count, ppos,\n\t\t\t\t\t       iio_dev_opaque->read_buf,\n\t\t\t\t\t       iio_dev_opaque->read_buf_len);\n\n\tret = indio_dev->info->debugfs_reg_access(indio_dev,\n\t\t\t\t\t\t  iio_dev_opaque->cached_reg_addr,\n\t\t\t\t\t\t  0, &val);\n\tif (ret) {\n\t\tdev_err(indio_dev->dev.parent, \"%s: read failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tiio_dev_opaque->read_buf_len = snprintf(iio_dev_opaque->read_buf,\n\t\t\t\t\t\tsizeof(iio_dev_opaque->read_buf),\n\t\t\t\t\t\t\"0x%X\\n\", val);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos,\n\t\t\t\t       iio_dev_opaque->read_buf,\n\t\t\t\t       iio_dev_opaque->read_buf_len);\n}\n\nstatic ssize_t iio_debugfs_write_reg(struct file *file,\n\t\t     const char __user *userbuf, size_t count, loff_t *ppos)\n{\n\tstruct iio_dev *indio_dev = file->private_data;\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tunsigned int reg, val;\n\tchar buf[80];\n\tint ret;\n\n\tcount = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, userbuf, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\tret = sscanf(buf, \"%i %i\", &reg, &val);\n\n\tswitch (ret) {\n\tcase 1:\n\t\tiio_dev_opaque->cached_reg_addr = reg;\n\t\tbreak;\n\tcase 2:\n\t\tiio_dev_opaque->cached_reg_addr = reg;\n\t\tret = indio_dev->info->debugfs_reg_access(indio_dev, reg,\n\t\t\t\t\t\t\t  val, NULL);\n\t\tif (ret) {\n\t\t\tdev_err(indio_dev->dev.parent, \"%s: write failed\\n\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations iio_debugfs_reg_fops = {\n\t.open = simple_open,\n\t.read = iio_debugfs_read_reg,\n\t.write = iio_debugfs_write_reg,\n};\n\nstatic void iio_device_unregister_debugfs(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\n\tdebugfs_remove_recursive(iio_dev_opaque->debugfs_dentry);\n}\n\nstatic void iio_device_register_debugfs(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque;\n\n\tif (indio_dev->info->debugfs_reg_access == NULL)\n\t\treturn;\n\n\tif (!iio_debugfs_dentry)\n\t\treturn;\n\n\tiio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\n\tiio_dev_opaque->debugfs_dentry =\n\t\tdebugfs_create_dir(dev_name(&indio_dev->dev),\n\t\t\t\t   iio_debugfs_dentry);\n\n\tdebugfs_create_file(\"direct_reg_access\", 0644,\n\t\t\t    iio_dev_opaque->debugfs_dentry, indio_dev,\n\t\t\t    &iio_debugfs_reg_fops);\n}\n#else\nstatic void iio_device_register_debugfs(struct iio_dev *indio_dev)\n{\n}\n\nstatic void iio_device_unregister_debugfs(struct iio_dev *indio_dev)\n{\n}\n#endif  \n\nstatic ssize_t iio_read_channel_ext_info(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tconst struct iio_chan_spec_ext_info *ext_info;\n\n\text_info = &this_attr->c->ext_info[this_attr->address];\n\n\treturn ext_info->read(indio_dev, ext_info->private, this_attr->c, buf);\n}\n\nstatic ssize_t iio_write_channel_ext_info(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tconst struct iio_chan_spec_ext_info *ext_info;\n\n\text_info = &this_attr->c->ext_info[this_attr->address];\n\n\treturn ext_info->write(indio_dev, ext_info->private,\n\t\t\t       this_attr->c, buf, len);\n}\n\nssize_t iio_enum_available_read(struct iio_dev *indio_dev,\n\tuintptr_t priv, const struct iio_chan_spec *chan, char *buf)\n{\n\tconst struct iio_enum *e = (const struct iio_enum *)priv;\n\tunsigned int i;\n\tsize_t len = 0;\n\n\tif (!e->num_items)\n\t\treturn 0;\n\n\tfor (i = 0; i < e->num_items; ++i) {\n\t\tif (!e->items[i])\n\t\t\tcontinue;\n\t\tlen += sysfs_emit_at(buf, len, \"%s \", e->items[i]);\n\t}\n\n\t \n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(iio_enum_available_read);\n\nssize_t iio_enum_read(struct iio_dev *indio_dev,\n\tuintptr_t priv, const struct iio_chan_spec *chan, char *buf)\n{\n\tconst struct iio_enum *e = (const struct iio_enum *)priv;\n\tint i;\n\n\tif (!e->get)\n\t\treturn -EINVAL;\n\n\ti = e->get(indio_dev, chan);\n\tif (i < 0)\n\t\treturn i;\n\tif (i >= e->num_items || !e->items[i])\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(buf, \"%s\\n\", e->items[i]);\n}\nEXPORT_SYMBOL_GPL(iio_enum_read);\n\nssize_t iio_enum_write(struct iio_dev *indio_dev,\n\tuintptr_t priv, const struct iio_chan_spec *chan, const char *buf,\n\tsize_t len)\n{\n\tconst struct iio_enum *e = (const struct iio_enum *)priv;\n\tint ret;\n\n\tif (!e->set)\n\t\treturn -EINVAL;\n\n\tret = __sysfs_match_string(e->items, e->num_items, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = e->set(indio_dev, chan, ret);\n\treturn ret ? ret : len;\n}\nEXPORT_SYMBOL_GPL(iio_enum_write);\n\nstatic const struct iio_mount_matrix iio_mount_idmatrix = {\n\t.rotation = {\n\t\t\"1\", \"0\", \"0\",\n\t\t\"0\", \"1\", \"0\",\n\t\t\"0\", \"0\", \"1\"\n\t}\n};\n\nstatic int iio_setup_mount_idmatrix(const struct device *dev,\n\t\t\t\t    struct iio_mount_matrix *matrix)\n{\n\t*matrix = iio_mount_idmatrix;\n\tdev_info(dev, \"mounting matrix not found: using identity...\\n\");\n\treturn 0;\n}\n\nssize_t iio_show_mount_matrix(struct iio_dev *indio_dev, uintptr_t priv,\n\t\t\t      const struct iio_chan_spec *chan, char *buf)\n{\n\tconst struct iio_mount_matrix *mtx;\n\n\tmtx = ((iio_get_mount_matrix_t *)priv)(indio_dev, chan);\n\tif (IS_ERR(mtx))\n\t\treturn PTR_ERR(mtx);\n\n\tif (!mtx)\n\t\tmtx = &iio_mount_idmatrix;\n\n\treturn sysfs_emit(buf, \"%s, %s, %s; %s, %s, %s; %s, %s, %s\\n\",\n\t\t\t  mtx->rotation[0], mtx->rotation[1], mtx->rotation[2],\n\t\t\t  mtx->rotation[3], mtx->rotation[4], mtx->rotation[5],\n\t\t\t  mtx->rotation[6], mtx->rotation[7], mtx->rotation[8]);\n}\nEXPORT_SYMBOL_GPL(iio_show_mount_matrix);\n\n \nint iio_read_mount_matrix(struct device *dev, struct iio_mount_matrix *matrix)\n{\n\tsize_t len = ARRAY_SIZE(iio_mount_idmatrix.rotation);\n\tint err;\n\n\terr = device_property_read_string_array(dev, \"mount-matrix\", matrix->rotation, len);\n\tif (err == len)\n\t\treturn 0;\n\n\tif (err >= 0)\n\t\t \n\t\treturn -EINVAL;\n\n\tif (err != -EINVAL)\n\t\t \n\t\treturn err;\n\n\t \n\treturn iio_setup_mount_idmatrix(dev, matrix);\n}\nEXPORT_SYMBOL(iio_read_mount_matrix);\n\nstatic ssize_t __iio_format_value(char *buf, size_t offset, unsigned int type,\n\t\t\t\t  int size, const int *vals)\n{\n\tint tmp0, tmp1;\n\ts64 tmp2;\n\tbool scale_db = false;\n\n\tswitch (type) {\n\tcase IIO_VAL_INT:\n\t\treturn sysfs_emit_at(buf, offset, \"%d\", vals[0]);\n\tcase IIO_VAL_INT_PLUS_MICRO_DB:\n\t\tscale_db = true;\n\t\tfallthrough;\n\tcase IIO_VAL_INT_PLUS_MICRO:\n\t\tif (vals[1] < 0)\n\t\t\treturn sysfs_emit_at(buf, offset, \"-%d.%06u%s\",\n\t\t\t\t\t     abs(vals[0]), -vals[1],\n\t\t\t\t\t     scale_db ? \" dB\" : \"\");\n\t\telse\n\t\t\treturn sysfs_emit_at(buf, offset, \"%d.%06u%s\", vals[0],\n\t\t\t\t\t     vals[1], scale_db ? \" dB\" : \"\");\n\tcase IIO_VAL_INT_PLUS_NANO:\n\t\tif (vals[1] < 0)\n\t\t\treturn sysfs_emit_at(buf, offset, \"-%d.%09u\",\n\t\t\t\t\t     abs(vals[0]), -vals[1]);\n\t\telse\n\t\t\treturn sysfs_emit_at(buf, offset, \"%d.%09u\", vals[0],\n\t\t\t\t\t     vals[1]);\n\tcase IIO_VAL_FRACTIONAL:\n\t\ttmp2 = div_s64((s64)vals[0] * 1000000000LL, vals[1]);\n\t\ttmp1 = vals[1];\n\t\ttmp0 = (int)div_s64_rem(tmp2, 1000000000, &tmp1);\n\t\tif ((tmp2 < 0) && (tmp0 == 0))\n\t\t\treturn sysfs_emit_at(buf, offset, \"-0.%09u\", abs(tmp1));\n\t\telse\n\t\t\treturn sysfs_emit_at(buf, offset, \"%d.%09u\", tmp0,\n\t\t\t\t\t     abs(tmp1));\n\tcase IIO_VAL_FRACTIONAL_LOG2:\n\t\ttmp2 = shift_right((s64)vals[0] * 1000000000LL, vals[1]);\n\t\ttmp0 = (int)div_s64_rem(tmp2, 1000000000LL, &tmp1);\n\t\tif (tmp0 == 0 && tmp2 < 0)\n\t\t\treturn sysfs_emit_at(buf, offset, \"-0.%09u\", abs(tmp1));\n\t\telse\n\t\t\treturn sysfs_emit_at(buf, offset, \"%d.%09u\", tmp0,\n\t\t\t\t\t     abs(tmp1));\n\tcase IIO_VAL_INT_MULTIPLE:\n\t{\n\t\tint i;\n\t\tint l = 0;\n\n\t\tfor (i = 0; i < size; ++i)\n\t\t\tl += sysfs_emit_at(buf, offset + l, \"%d \", vals[i]);\n\t\treturn l;\n\t}\n\tcase IIO_VAL_CHAR:\n\t\treturn sysfs_emit_at(buf, offset, \"%c\", (char)vals[0]);\n\tcase IIO_VAL_INT_64:\n\t\ttmp2 = (s64)((((u64)vals[1]) << 32) | (u32)vals[0]);\n\t\treturn sysfs_emit_at(buf, offset, \"%lld\", tmp2);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nssize_t iio_format_value(char *buf, unsigned int type, int size, int *vals)\n{\n\tssize_t len;\n\n\tlen = __iio_format_value(buf, 0, type, size, vals);\n\tif (len >= PAGE_SIZE - 1)\n\t\treturn -EFBIG;\n\n\treturn len + sysfs_emit_at(buf, len, \"\\n\");\n}\nEXPORT_SYMBOL_GPL(iio_format_value);\n\nstatic ssize_t iio_read_channel_label(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\n\tif (indio_dev->info->read_label)\n\t\treturn indio_dev->info->read_label(indio_dev, this_attr->c, buf);\n\n\tif (this_attr->c->extend_name)\n\t\treturn sysfs_emit(buf, \"%s\\n\", this_attr->c->extend_name);\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t iio_read_channel_info(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tint vals[INDIO_MAX_RAW_ELEMENTS];\n\tint ret;\n\tint val_len = 2;\n\n\tif (indio_dev->info->read_raw_multi)\n\t\tret = indio_dev->info->read_raw_multi(indio_dev, this_attr->c,\n\t\t\t\t\t\t\tINDIO_MAX_RAW_ELEMENTS,\n\t\t\t\t\t\t\tvals, &val_len,\n\t\t\t\t\t\t\tthis_attr->address);\n\telse\n\t\tret = indio_dev->info->read_raw(indio_dev, this_attr->c,\n\t\t\t\t    &vals[0], &vals[1], this_attr->address);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn iio_format_value(buf, ret, val_len, vals);\n}\n\nstatic ssize_t iio_format_list(char *buf, const int *vals, int type, int length,\n\t\t\t       const char *prefix, const char *suffix)\n{\n\tssize_t len;\n\tint stride;\n\tint i;\n\n\tswitch (type) {\n\tcase IIO_VAL_INT:\n\t\tstride = 1;\n\t\tbreak;\n\tdefault:\n\t\tstride = 2;\n\t\tbreak;\n\t}\n\n\tlen = sysfs_emit(buf, prefix);\n\n\tfor (i = 0; i <= length - stride; i += stride) {\n\t\tif (i != 0) {\n\t\t\tlen += sysfs_emit_at(buf, len, \" \");\n\t\t\tif (len >= PAGE_SIZE)\n\t\t\t\treturn -EFBIG;\n\t\t}\n\n\t\tlen += __iio_format_value(buf, len, type, stride, &vals[i]);\n\t\tif (len >= PAGE_SIZE)\n\t\t\treturn -EFBIG;\n\t}\n\n\tlen += sysfs_emit_at(buf, len, \"%s\\n\", suffix);\n\n\treturn len;\n}\n\nstatic ssize_t iio_format_avail_list(char *buf, const int *vals,\n\t\t\t\t     int type, int length)\n{\n\n\treturn iio_format_list(buf, vals, type, length, \"\", \"\");\n}\n\nstatic ssize_t iio_format_avail_range(char *buf, const int *vals, int type)\n{\n\tint length;\n\n\t \n\tswitch (type) {\n\tcase IIO_VAL_INT:\n\t\tlength = 3;\n\t\tbreak;\n\tdefault:\n\t\tlength = 6;\n\t\tbreak;\n\t}\n\n\treturn iio_format_list(buf, vals, type, length, \"[\", \"]\");\n}\n\nstatic ssize_t iio_read_channel_info_avail(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tconst int *vals;\n\tint ret;\n\tint length;\n\tint type;\n\n\tret = indio_dev->info->read_avail(indio_dev, this_attr->c,\n\t\t\t\t\t  &vals, &type, &length,\n\t\t\t\t\t  this_attr->address);\n\n\tif (ret < 0)\n\t\treturn ret;\n\tswitch (ret) {\n\tcase IIO_AVAIL_LIST:\n\t\treturn iio_format_avail_list(buf, vals, type, length);\n\tcase IIO_AVAIL_RANGE:\n\t\treturn iio_format_avail_range(buf, vals, type);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int __iio_str_to_fixpoint(const char *str, int fract_mult,\n\t\t\t\t int *integer, int *fract, bool scale_db)\n{\n\tint i = 0, f = 0;\n\tbool integer_part = true, negative = false;\n\n\tif (fract_mult == 0) {\n\t\t*fract = 0;\n\n\t\treturn kstrtoint(str, 0, integer);\n\t}\n\n\tif (str[0] == '-') {\n\t\tnegative = true;\n\t\tstr++;\n\t} else if (str[0] == '+') {\n\t\tstr++;\n\t}\n\n\twhile (*str) {\n\t\tif ('0' <= *str && *str <= '9') {\n\t\t\tif (integer_part) {\n\t\t\t\ti = i * 10 + *str - '0';\n\t\t\t} else {\n\t\t\t\tf += fract_mult * (*str - '0');\n\t\t\t\tfract_mult /= 10;\n\t\t\t}\n\t\t} else if (*str == '\\n') {\n\t\t\tif (*(str + 1) == '\\0')\n\t\t\t\tbreak;\n\t\t\treturn -EINVAL;\n\t\t} else if (!strncmp(str, \" dB\", sizeof(\" dB\") - 1) && scale_db) {\n\t\t\t \n\t\t\tstr += sizeof(\" dB\") - 1;\n\t\t\tcontinue;\n\t\t} else if (!strncmp(str, \"dB\", sizeof(\"dB\") - 1) && scale_db) {\n\t\t\t \n\t\t\tstr += sizeof(\"dB\") - 1;\n\t\t\tcontinue;\n\t\t} else if (*str == '.' && integer_part) {\n\t\t\tinteger_part = false;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstr++;\n\t}\n\n\tif (negative) {\n\t\tif (i)\n\t\t\ti = -i;\n\t\telse\n\t\t\tf = -f;\n\t}\n\n\t*integer = i;\n\t*fract = f;\n\n\treturn 0;\n}\n\n \nint iio_str_to_fixpoint(const char *str, int fract_mult,\n\t\t\tint *integer, int *fract)\n{\n\treturn __iio_str_to_fixpoint(str, fract_mult, integer, fract, false);\n}\nEXPORT_SYMBOL_GPL(iio_str_to_fixpoint);\n\nstatic ssize_t iio_write_channel_info(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf,\n\t\t\t\t      size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tint ret, fract_mult = 100000;\n\tint integer, fract = 0;\n\tbool is_char = false;\n\tbool scale_db = false;\n\n\t \n\tif (!indio_dev->info->write_raw)\n\t\treturn -EINVAL;\n\n\tif (indio_dev->info->write_raw_get_fmt)\n\t\tswitch (indio_dev->info->write_raw_get_fmt(indio_dev,\n\t\t\tthis_attr->c, this_attr->address)) {\n\t\tcase IIO_VAL_INT:\n\t\t\tfract_mult = 0;\n\t\t\tbreak;\n\t\tcase IIO_VAL_INT_PLUS_MICRO_DB:\n\t\t\tscale_db = true;\n\t\t\tfallthrough;\n\t\tcase IIO_VAL_INT_PLUS_MICRO:\n\t\t\tfract_mult = 100000;\n\t\t\tbreak;\n\t\tcase IIO_VAL_INT_PLUS_NANO:\n\t\t\tfract_mult = 100000000;\n\t\t\tbreak;\n\t\tcase IIO_VAL_CHAR:\n\t\t\tis_char = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tif (is_char) {\n\t\tchar ch;\n\n\t\tif (sscanf(buf, \"%c\", &ch) != 1)\n\t\t\treturn -EINVAL;\n\t\tinteger = ch;\n\t} else {\n\t\tret = __iio_str_to_fixpoint(buf, fract_mult, &integer, &fract,\n\t\t\t\t\t    scale_db);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = indio_dev->info->write_raw(indio_dev, this_attr->c,\n\t\t\t\t\t integer, fract, this_attr->address);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic\nint __iio_device_attr_init(struct device_attribute *dev_attr,\n\t\t\t   const char *postfix,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   ssize_t (*readfunc)(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf),\n\t\t\t   ssize_t (*writefunc)(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf,\n\t\t\t\t\t\tsize_t len),\n\t\t\t   enum iio_shared_by shared_by)\n{\n\tint ret = 0;\n\tchar *name = NULL;\n\tchar *full_postfix;\n\n\tsysfs_attr_init(&dev_attr->attr);\n\n\t \n\tif (chan->modified && (shared_by == IIO_SEPARATE)) {\n\t\tif (chan->extend_name)\n\t\t\tfull_postfix = kasprintf(GFP_KERNEL, \"%s_%s_%s\",\n\t\t\t\t\t\t iio_modifier_names[chan->channel2],\n\t\t\t\t\t\t chan->extend_name,\n\t\t\t\t\t\t postfix);\n\t\telse\n\t\t\tfull_postfix = kasprintf(GFP_KERNEL, \"%s_%s\",\n\t\t\t\t\t\t iio_modifier_names[chan->channel2],\n\t\t\t\t\t\t postfix);\n\t} else {\n\t\tif (chan->extend_name == NULL || shared_by != IIO_SEPARATE)\n\t\t\tfull_postfix = kstrdup(postfix, GFP_KERNEL);\n\t\telse\n\t\t\tfull_postfix = kasprintf(GFP_KERNEL,\n\t\t\t\t\t\t \"%s_%s\",\n\t\t\t\t\t\t chan->extend_name,\n\t\t\t\t\t\t postfix);\n\t}\n\tif (full_postfix == NULL)\n\t\treturn -ENOMEM;\n\n\tif (chan->differential) {  \n\t\tswitch (shared_by) {\n\t\tcase IIO_SHARED_BY_ALL:\n\t\t\tname = kasprintf(GFP_KERNEL, \"%s\", full_postfix);\n\t\t\tbreak;\n\t\tcase IIO_SHARED_BY_DIR:\n\t\t\tname = kasprintf(GFP_KERNEL, \"%s_%s\",\n\t\t\t\t\t\tiio_direction[chan->output],\n\t\t\t\t\t\tfull_postfix);\n\t\t\tbreak;\n\t\tcase IIO_SHARED_BY_TYPE:\n\t\t\tname = kasprintf(GFP_KERNEL, \"%s_%s-%s_%s\",\n\t\t\t\t\t    iio_direction[chan->output],\n\t\t\t\t\t    iio_chan_type_name_spec[chan->type],\n\t\t\t\t\t    iio_chan_type_name_spec[chan->type],\n\t\t\t\t\t    full_postfix);\n\t\t\tbreak;\n\t\tcase IIO_SEPARATE:\n\t\t\tif (!chan->indexed) {\n\t\t\t\tWARN(1, \"Differential channels must be indexed\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto error_free_full_postfix;\n\t\t\t}\n\t\t\tname = kasprintf(GFP_KERNEL,\n\t\t\t\t\t    \"%s_%s%d-%s%d_%s\",\n\t\t\t\t\t    iio_direction[chan->output],\n\t\t\t\t\t    iio_chan_type_name_spec[chan->type],\n\t\t\t\t\t    chan->channel,\n\t\t\t\t\t    iio_chan_type_name_spec[chan->type],\n\t\t\t\t\t    chan->channel2,\n\t\t\t\t\t    full_postfix);\n\t\t\tbreak;\n\t\t}\n\t} else {  \n\t\tswitch (shared_by) {\n\t\tcase IIO_SHARED_BY_ALL:\n\t\t\tname = kasprintf(GFP_KERNEL, \"%s\", full_postfix);\n\t\t\tbreak;\n\t\tcase IIO_SHARED_BY_DIR:\n\t\t\tname = kasprintf(GFP_KERNEL, \"%s_%s\",\n\t\t\t\t\t\tiio_direction[chan->output],\n\t\t\t\t\t\tfull_postfix);\n\t\t\tbreak;\n\t\tcase IIO_SHARED_BY_TYPE:\n\t\t\tname = kasprintf(GFP_KERNEL, \"%s_%s_%s\",\n\t\t\t\t\t    iio_direction[chan->output],\n\t\t\t\t\t    iio_chan_type_name_spec[chan->type],\n\t\t\t\t\t    full_postfix);\n\t\t\tbreak;\n\n\t\tcase IIO_SEPARATE:\n\t\t\tif (chan->indexed)\n\t\t\t\tname = kasprintf(GFP_KERNEL, \"%s_%s%d_%s\",\n\t\t\t\t\t\t    iio_direction[chan->output],\n\t\t\t\t\t\t    iio_chan_type_name_spec[chan->type],\n\t\t\t\t\t\t    chan->channel,\n\t\t\t\t\t\t    full_postfix);\n\t\t\telse\n\t\t\t\tname = kasprintf(GFP_KERNEL, \"%s_%s_%s\",\n\t\t\t\t\t\t    iio_direction[chan->output],\n\t\t\t\t\t\t    iio_chan_type_name_spec[chan->type],\n\t\t\t\t\t\t    full_postfix);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (name == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto error_free_full_postfix;\n\t}\n\tdev_attr->attr.name = name;\n\n\tif (readfunc) {\n\t\tdev_attr->attr.mode |= 0444;\n\t\tdev_attr->show = readfunc;\n\t}\n\n\tif (writefunc) {\n\t\tdev_attr->attr.mode |= 0200;\n\t\tdev_attr->store = writefunc;\n\t}\n\nerror_free_full_postfix:\n\tkfree(full_postfix);\n\n\treturn ret;\n}\n\nstatic void __iio_device_attr_deinit(struct device_attribute *dev_attr)\n{\n\tkfree(dev_attr->attr.name);\n}\n\nint __iio_add_chan_devattr(const char *postfix,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   ssize_t (*readfunc)(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf),\n\t\t\t   ssize_t (*writefunc)(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf,\n\t\t\t\t\t\tsize_t len),\n\t\t\t   u64 mask,\n\t\t\t   enum iio_shared_by shared_by,\n\t\t\t   struct device *dev,\n\t\t\t   struct iio_buffer *buffer,\n\t\t\t   struct list_head *attr_list)\n{\n\tint ret;\n\tstruct iio_dev_attr *iio_attr, *t;\n\n\tiio_attr = kzalloc(sizeof(*iio_attr), GFP_KERNEL);\n\tif (iio_attr == NULL)\n\t\treturn -ENOMEM;\n\tret = __iio_device_attr_init(&iio_attr->dev_attr,\n\t\t\t\t     postfix, chan,\n\t\t\t\t     readfunc, writefunc, shared_by);\n\tif (ret)\n\t\tgoto error_iio_dev_attr_free;\n\tiio_attr->c = chan;\n\tiio_attr->address = mask;\n\tiio_attr->buffer = buffer;\n\tlist_for_each_entry(t, attr_list, l)\n\t\tif (strcmp(t->dev_attr.attr.name,\n\t\t\t   iio_attr->dev_attr.attr.name) == 0) {\n\t\t\tif (shared_by == IIO_SEPARATE)\n\t\t\t\tdev_err(dev, \"tried to double register : %s\\n\",\n\t\t\t\t\tt->dev_attr.attr.name);\n\t\t\tret = -EBUSY;\n\t\t\tgoto error_device_attr_deinit;\n\t\t}\n\tlist_add(&iio_attr->l, attr_list);\n\n\treturn 0;\n\nerror_device_attr_deinit:\n\t__iio_device_attr_deinit(&iio_attr->dev_attr);\nerror_iio_dev_attr_free:\n\tkfree(iio_attr);\n\treturn ret;\n}\n\nstatic int iio_device_add_channel_label(struct iio_dev *indio_dev,\n\t\t\t\t\t struct iio_chan_spec const *chan)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tint ret;\n\n\tif (!indio_dev->info->read_label && !chan->extend_name)\n\t\treturn 0;\n\n\tret = __iio_add_chan_devattr(\"label\",\n\t\t\t\t     chan,\n\t\t\t\t     &iio_read_channel_label,\n\t\t\t\t     NULL,\n\t\t\t\t     0,\n\t\t\t\t     IIO_SEPARATE,\n\t\t\t\t     &indio_dev->dev,\n\t\t\t\t     NULL,\n\t\t\t\t     &iio_dev_opaque->channel_attr_list);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 1;\n}\n\nstatic int iio_device_add_info_mask_type(struct iio_dev *indio_dev,\n\t\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t\t enum iio_shared_by shared_by,\n\t\t\t\t\t const long *infomask)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tint i, ret, attrcount = 0;\n\n\tfor_each_set_bit(i, infomask, sizeof(*infomask)*8) {\n\t\tif (i >= ARRAY_SIZE(iio_chan_info_postfix))\n\t\t\treturn -EINVAL;\n\t\tret = __iio_add_chan_devattr(iio_chan_info_postfix[i],\n\t\t\t\t\t     chan,\n\t\t\t\t\t     &iio_read_channel_info,\n\t\t\t\t\t     &iio_write_channel_info,\n\t\t\t\t\t     i,\n\t\t\t\t\t     shared_by,\n\t\t\t\t\t     &indio_dev->dev,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     &iio_dev_opaque->channel_attr_list);\n\t\tif ((ret == -EBUSY) && (shared_by != IIO_SEPARATE))\n\t\t\tcontinue;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tattrcount++;\n\t}\n\n\treturn attrcount;\n}\n\nstatic int iio_device_add_info_mask_type_avail(struct iio_dev *indio_dev,\n\t\t\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t\t\t       enum iio_shared_by shared_by,\n\t\t\t\t\t       const long *infomask)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tint i, ret, attrcount = 0;\n\tchar *avail_postfix;\n\n\tfor_each_set_bit(i, infomask, sizeof(*infomask) * 8) {\n\t\tif (i >= ARRAY_SIZE(iio_chan_info_postfix))\n\t\t\treturn -EINVAL;\n\t\tavail_postfix = kasprintf(GFP_KERNEL,\n\t\t\t\t\t  \"%s_available\",\n\t\t\t\t\t  iio_chan_info_postfix[i]);\n\t\tif (!avail_postfix)\n\t\t\treturn -ENOMEM;\n\n\t\tret = __iio_add_chan_devattr(avail_postfix,\n\t\t\t\t\t     chan,\n\t\t\t\t\t     &iio_read_channel_info_avail,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     i,\n\t\t\t\t\t     shared_by,\n\t\t\t\t\t     &indio_dev->dev,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     &iio_dev_opaque->channel_attr_list);\n\t\tkfree(avail_postfix);\n\t\tif ((ret == -EBUSY) && (shared_by != IIO_SEPARATE))\n\t\t\tcontinue;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tattrcount++;\n\t}\n\n\treturn attrcount;\n}\n\nstatic int iio_device_add_channel_sysfs(struct iio_dev *indio_dev,\n\t\t\t\t\tstruct iio_chan_spec const *chan)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tint ret, attrcount = 0;\n\tconst struct iio_chan_spec_ext_info *ext_info;\n\n\tif (chan->channel < 0)\n\t\treturn 0;\n\tret = iio_device_add_info_mask_type(indio_dev, chan,\n\t\t\t\t\t    IIO_SEPARATE,\n\t\t\t\t\t    &chan->info_mask_separate);\n\tif (ret < 0)\n\t\treturn ret;\n\tattrcount += ret;\n\n\tret = iio_device_add_info_mask_type_avail(indio_dev, chan,\n\t\t\t\t\t\t  IIO_SEPARATE,\n\t\t\t\t\t\t  &chan->info_mask_separate_available);\n\tif (ret < 0)\n\t\treturn ret;\n\tattrcount += ret;\n\n\tret = iio_device_add_info_mask_type(indio_dev, chan,\n\t\t\t\t\t    IIO_SHARED_BY_TYPE,\n\t\t\t\t\t    &chan->info_mask_shared_by_type);\n\tif (ret < 0)\n\t\treturn ret;\n\tattrcount += ret;\n\n\tret = iio_device_add_info_mask_type_avail(indio_dev, chan,\n\t\t\t\t\t\t  IIO_SHARED_BY_TYPE,\n\t\t\t\t\t\t  &chan->info_mask_shared_by_type_available);\n\tif (ret < 0)\n\t\treturn ret;\n\tattrcount += ret;\n\n\tret = iio_device_add_info_mask_type(indio_dev, chan,\n\t\t\t\t\t    IIO_SHARED_BY_DIR,\n\t\t\t\t\t    &chan->info_mask_shared_by_dir);\n\tif (ret < 0)\n\t\treturn ret;\n\tattrcount += ret;\n\n\tret = iio_device_add_info_mask_type_avail(indio_dev, chan,\n\t\t\t\t\t\t  IIO_SHARED_BY_DIR,\n\t\t\t\t\t\t  &chan->info_mask_shared_by_dir_available);\n\tif (ret < 0)\n\t\treturn ret;\n\tattrcount += ret;\n\n\tret = iio_device_add_info_mask_type(indio_dev, chan,\n\t\t\t\t\t    IIO_SHARED_BY_ALL,\n\t\t\t\t\t    &chan->info_mask_shared_by_all);\n\tif (ret < 0)\n\t\treturn ret;\n\tattrcount += ret;\n\n\tret = iio_device_add_info_mask_type_avail(indio_dev, chan,\n\t\t\t\t\t\t  IIO_SHARED_BY_ALL,\n\t\t\t\t\t\t  &chan->info_mask_shared_by_all_available);\n\tif (ret < 0)\n\t\treturn ret;\n\tattrcount += ret;\n\n\tret = iio_device_add_channel_label(indio_dev, chan);\n\tif (ret < 0)\n\t\treturn ret;\n\tattrcount += ret;\n\n\tif (chan->ext_info) {\n\t\tunsigned int i = 0;\n\n\t\tfor (ext_info = chan->ext_info; ext_info->name; ext_info++) {\n\t\t\tret = __iio_add_chan_devattr(ext_info->name,\n\t\t\t\t\tchan,\n\t\t\t\t\text_info->read ?\n\t\t\t\t\t    &iio_read_channel_ext_info : NULL,\n\t\t\t\t\text_info->write ?\n\t\t\t\t\t    &iio_write_channel_ext_info : NULL,\n\t\t\t\t\ti,\n\t\t\t\t\text_info->shared,\n\t\t\t\t\t&indio_dev->dev,\n\t\t\t\t\tNULL,\n\t\t\t\t\t&iio_dev_opaque->channel_attr_list);\n\t\t\ti++;\n\t\t\tif (ret == -EBUSY && ext_info->shared)\n\t\t\t\tcontinue;\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tattrcount++;\n\t\t}\n\t}\n\n\treturn attrcount;\n}\n\n \nvoid iio_free_chan_devattr_list(struct list_head *attr_list)\n{\n\tstruct iio_dev_attr *p, *n;\n\n\tlist_for_each_entry_safe(p, n, attr_list, l) {\n\t\tkfree_const(p->dev_attr.attr.name);\n\t\tlist_del(&p->l);\n\t\tkfree(p);\n\t}\n}\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", indio_dev->name);\n}\n\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t label_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", indio_dev->label);\n}\n\nstatic DEVICE_ATTR_RO(label);\n\nstatic const char * const clock_names[] = {\n\t[CLOCK_REALTIME]\t \t= \"realtime\",\n\t[CLOCK_MONOTONIC]\t \t= \"monotonic\",\n\t[CLOCK_PROCESS_CPUTIME_ID]\t= \"process_cputime_id\",\n\t[CLOCK_THREAD_CPUTIME_ID]\t= \"thread_cputime_id\",\n\t[CLOCK_MONOTONIC_RAW]\t \t= \"monotonic_raw\",\n\t[CLOCK_REALTIME_COARSE]\t \t= \"realtime_coarse\",\n\t[CLOCK_MONOTONIC_COARSE] \t= \"monotonic_coarse\",\n\t[CLOCK_BOOTTIME]\t \t= \"boottime\",\n\t[CLOCK_REALTIME_ALARM]\t\t= \"realtime_alarm\",\n\t[CLOCK_BOOTTIME_ALARM]\t\t= \"boottime_alarm\",\n\t[CLOCK_SGI_CYCLE]\t\t= \"sgi_cycle\",\n\t[CLOCK_TAI]\t\t \t= \"tai\",\n};\n\nstatic ssize_t current_timestamp_clock_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tconst struct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tconst clockid_t clk = iio_device_get_clock(indio_dev);\n\n\tswitch (clk) {\n\tcase CLOCK_REALTIME:\n\tcase CLOCK_MONOTONIC:\n\tcase CLOCK_MONOTONIC_RAW:\n\tcase CLOCK_REALTIME_COARSE:\n\tcase CLOCK_MONOTONIC_COARSE:\n\tcase CLOCK_BOOTTIME:\n\tcase CLOCK_TAI:\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn sysfs_emit(buf, \"%s\\n\", clock_names[clk]);\n}\n\nstatic ssize_t current_timestamp_clock_store(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t len)\n{\n\tclockid_t clk;\n\tint ret;\n\n\tret = sysfs_match_string(clock_names, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\tclk = ret;\n\n\tswitch (clk) {\n\tcase CLOCK_REALTIME:\n\tcase CLOCK_MONOTONIC:\n\tcase CLOCK_MONOTONIC_RAW:\n\tcase CLOCK_REALTIME_COARSE:\n\tcase CLOCK_MONOTONIC_COARSE:\n\tcase CLOCK_BOOTTIME:\n\tcase CLOCK_TAI:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = iio_device_set_clock(dev_to_iio_dev(dev), clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nint iio_device_register_sysfs_group(struct iio_dev *indio_dev,\n\t\t\t\t    const struct attribute_group *group)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tconst struct attribute_group **new, **old = iio_dev_opaque->groups;\n\tunsigned int cnt = iio_dev_opaque->groupcounter;\n\n\tnew = krealloc_array(old, cnt + 2, sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew[iio_dev_opaque->groupcounter++] = group;\n\tnew[iio_dev_opaque->groupcounter] = NULL;\n\n\tiio_dev_opaque->groups = new;\n\n\treturn 0;\n}\n\nstatic DEVICE_ATTR_RW(current_timestamp_clock);\n\nstatic int iio_device_register_sysfs(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tint i, ret = 0, attrcount, attrn, attrcount_orig = 0;\n\tstruct iio_dev_attr *p;\n\tstruct attribute **attr, *clk = NULL;\n\n\t \n\tif (indio_dev->info->attrs) {\n\t\tattr = indio_dev->info->attrs->attrs;\n\t\twhile (*attr++ != NULL)\n\t\t\tattrcount_orig++;\n\t}\n\tattrcount = attrcount_orig;\n\t \n\tif (indio_dev->channels)\n\t\tfor (i = 0; i < indio_dev->num_channels; i++) {\n\t\t\tconst struct iio_chan_spec *chan =\n\t\t\t\t&indio_dev->channels[i];\n\n\t\t\tif (chan->type == IIO_TIMESTAMP)\n\t\t\t\tclk = &dev_attr_current_timestamp_clock.attr;\n\n\t\t\tret = iio_device_add_channel_sysfs(indio_dev, chan);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_clear_attrs;\n\t\t\tattrcount += ret;\n\t\t}\n\n\tif (iio_dev_opaque->event_interface)\n\t\tclk = &dev_attr_current_timestamp_clock.attr;\n\n\tif (indio_dev->name)\n\t\tattrcount++;\n\tif (indio_dev->label)\n\t\tattrcount++;\n\tif (clk)\n\t\tattrcount++;\n\n\tiio_dev_opaque->chan_attr_group.attrs =\n\t\tkcalloc(attrcount + 1,\n\t\t\tsizeof(iio_dev_opaque->chan_attr_group.attrs[0]),\n\t\t\tGFP_KERNEL);\n\tif (iio_dev_opaque->chan_attr_group.attrs == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto error_clear_attrs;\n\t}\n\t \n\tif (indio_dev->info->attrs) {\n\t\tmemcpy(iio_dev_opaque->chan_attr_group.attrs,\n\t\t       indio_dev->info->attrs->attrs,\n\t\t       sizeof(iio_dev_opaque->chan_attr_group.attrs[0])\n\t\t       *attrcount_orig);\n\t\tiio_dev_opaque->chan_attr_group.is_visible =\n\t\t\tindio_dev->info->attrs->is_visible;\n\t\tiio_dev_opaque->chan_attr_group.bin_attrs =\n\t\t\tindio_dev->info->attrs->bin_attrs;\n\t}\n\tattrn = attrcount_orig;\n\t \n\tlist_for_each_entry(p, &iio_dev_opaque->channel_attr_list, l)\n\t\tiio_dev_opaque->chan_attr_group.attrs[attrn++] = &p->dev_attr.attr;\n\tif (indio_dev->name)\n\t\tiio_dev_opaque->chan_attr_group.attrs[attrn++] = &dev_attr_name.attr;\n\tif (indio_dev->label)\n\t\tiio_dev_opaque->chan_attr_group.attrs[attrn++] = &dev_attr_label.attr;\n\tif (clk)\n\t\tiio_dev_opaque->chan_attr_group.attrs[attrn++] = clk;\n\n\tret = iio_device_register_sysfs_group(indio_dev,\n\t\t\t\t\t      &iio_dev_opaque->chan_attr_group);\n\tif (ret)\n\t\tgoto error_clear_attrs;\n\n\treturn 0;\n\nerror_clear_attrs:\n\tiio_free_chan_devattr_list(&iio_dev_opaque->channel_attr_list);\n\n\treturn ret;\n}\n\nstatic void iio_device_unregister_sysfs(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\n\tiio_free_chan_devattr_list(&iio_dev_opaque->channel_attr_list);\n\tkfree(iio_dev_opaque->chan_attr_group.attrs);\n\tiio_dev_opaque->chan_attr_group.attrs = NULL;\n\tkfree(iio_dev_opaque->groups);\n\tiio_dev_opaque->groups = NULL;\n}\n\nstatic void iio_dev_release(struct device *device)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(device);\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\n\tif (indio_dev->modes & INDIO_ALL_TRIGGERED_MODES)\n\t\tiio_device_unregister_trigger_consumer(indio_dev);\n\tiio_device_unregister_eventset(indio_dev);\n\tiio_device_unregister_sysfs(indio_dev);\n\n\tiio_device_detach_buffers(indio_dev);\n\n\tlockdep_unregister_key(&iio_dev_opaque->mlock_key);\n\n\tida_free(&iio_ida, iio_dev_opaque->id);\n\tkfree(iio_dev_opaque);\n}\n\nconst struct device_type iio_device_type = {\n\t.name = \"iio_device\",\n\t.release = iio_dev_release,\n};\n\n \nstruct iio_dev *iio_device_alloc(struct device *parent, int sizeof_priv)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque;\n\tstruct iio_dev *indio_dev;\n\tsize_t alloc_size;\n\n\talloc_size = sizeof(struct iio_dev_opaque);\n\tif (sizeof_priv) {\n\t\talloc_size = ALIGN(alloc_size, IIO_DMA_MINALIGN);\n\t\talloc_size += sizeof_priv;\n\t}\n\n\tiio_dev_opaque = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!iio_dev_opaque)\n\t\treturn NULL;\n\n\tindio_dev = &iio_dev_opaque->indio_dev;\n\tindio_dev->priv = (char *)iio_dev_opaque +\n\t\tALIGN(sizeof(struct iio_dev_opaque), IIO_DMA_MINALIGN);\n\n\tindio_dev->dev.parent = parent;\n\tindio_dev->dev.type = &iio_device_type;\n\tindio_dev->dev.bus = &iio_bus_type;\n\tdevice_initialize(&indio_dev->dev);\n\tmutex_init(&iio_dev_opaque->mlock);\n\tmutex_init(&iio_dev_opaque->info_exist_lock);\n\tINIT_LIST_HEAD(&iio_dev_opaque->channel_attr_list);\n\n\tiio_dev_opaque->id = ida_alloc(&iio_ida, GFP_KERNEL);\n\tif (iio_dev_opaque->id < 0) {\n\t\t \n\t\tpr_err(\"failed to get device id\\n\");\n\t\tkfree(iio_dev_opaque);\n\t\treturn NULL;\n\t}\n\n\tif (dev_set_name(&indio_dev->dev, \"iio:device%d\", iio_dev_opaque->id)) {\n\t\tida_free(&iio_ida, iio_dev_opaque->id);\n\t\tkfree(iio_dev_opaque);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&iio_dev_opaque->buffer_list);\n\tINIT_LIST_HEAD(&iio_dev_opaque->ioctl_handlers);\n\n\tlockdep_register_key(&iio_dev_opaque->mlock_key);\n\tlockdep_set_class(&iio_dev_opaque->mlock, &iio_dev_opaque->mlock_key);\n\n\treturn indio_dev;\n}\nEXPORT_SYMBOL(iio_device_alloc);\n\n \nvoid iio_device_free(struct iio_dev *dev)\n{\n\tif (dev)\n\t\tput_device(&dev->dev);\n}\nEXPORT_SYMBOL(iio_device_free);\n\nstatic void devm_iio_device_release(void *iio_dev)\n{\n\tiio_device_free(iio_dev);\n}\n\n \nstruct iio_dev *devm_iio_device_alloc(struct device *parent, int sizeof_priv)\n{\n\tstruct iio_dev *iio_dev;\n\tint ret;\n\n\tiio_dev = iio_device_alloc(parent, sizeof_priv);\n\tif (!iio_dev)\n\t\treturn NULL;\n\n\tret = devm_add_action_or_reset(parent, devm_iio_device_release,\n\t\t\t\t       iio_dev);\n\tif (ret)\n\t\treturn NULL;\n\n\treturn iio_dev;\n}\nEXPORT_SYMBOL_GPL(devm_iio_device_alloc);\n\n \nstatic int iio_chrdev_open(struct inode *inode, struct file *filp)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque =\n\t\tcontainer_of(inode->i_cdev, struct iio_dev_opaque, chrdev);\n\tstruct iio_dev *indio_dev = &iio_dev_opaque->indio_dev;\n\tstruct iio_dev_buffer_pair *ib;\n\n\tif (test_and_set_bit(IIO_BUSY_BIT_POS, &iio_dev_opaque->flags))\n\t\treturn -EBUSY;\n\n\tiio_device_get(indio_dev);\n\n\tib = kmalloc(sizeof(*ib), GFP_KERNEL);\n\tif (!ib) {\n\t\tiio_device_put(indio_dev);\n\t\tclear_bit(IIO_BUSY_BIT_POS, &iio_dev_opaque->flags);\n\t\treturn -ENOMEM;\n\t}\n\n\tib->indio_dev = indio_dev;\n\tib->buffer = indio_dev->buffer;\n\n\tfilp->private_data = ib;\n\n\treturn 0;\n}\n\n \nstatic int iio_chrdev_release(struct inode *inode, struct file *filp)\n{\n\tstruct iio_dev_buffer_pair *ib = filp->private_data;\n\tstruct iio_dev_opaque *iio_dev_opaque =\n\t\tcontainer_of(inode->i_cdev, struct iio_dev_opaque, chrdev);\n\tstruct iio_dev *indio_dev = &iio_dev_opaque->indio_dev;\n\n\tkfree(ib);\n\tclear_bit(IIO_BUSY_BIT_POS, &iio_dev_opaque->flags);\n\tiio_device_put(indio_dev);\n\n\treturn 0;\n}\n\nvoid iio_device_ioctl_handler_register(struct iio_dev *indio_dev,\n\t\t\t\t       struct iio_ioctl_handler *h)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\n\tlist_add_tail(&h->entry, &iio_dev_opaque->ioctl_handlers);\n}\n\nvoid iio_device_ioctl_handler_unregister(struct iio_ioctl_handler *h)\n{\n\tlist_del(&h->entry);\n}\n\nstatic long iio_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct iio_dev_buffer_pair *ib = filp->private_data;\n\tstruct iio_dev *indio_dev = ib->indio_dev;\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tstruct iio_ioctl_handler *h;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&iio_dev_opaque->info_exist_lock);\n\n\t \n\tif (!indio_dev->info)\n\t\tgoto out_unlock;\n\n\tlist_for_each_entry(h, &iio_dev_opaque->ioctl_handlers, entry) {\n\t\tret = h->ioctl(indio_dev, filp, cmd, arg);\n\t\tif (ret != IIO_IOCTL_UNHANDLED)\n\t\t\tbreak;\n\t}\n\n\tif (ret == IIO_IOCTL_UNHANDLED)\n\t\tret = -ENODEV;\n\nout_unlock:\n\tmutex_unlock(&iio_dev_opaque->info_exist_lock);\n\n\treturn ret;\n}\n\nstatic const struct file_operations iio_buffer_fileops = {\n\t.owner = THIS_MODULE,\n\t.llseek = noop_llseek,\n\t.read = iio_buffer_read_outer_addr,\n\t.write = iio_buffer_write_outer_addr,\n\t.poll = iio_buffer_poll_addr,\n\t.unlocked_ioctl = iio_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.open = iio_chrdev_open,\n\t.release = iio_chrdev_release,\n};\n\nstatic const struct file_operations iio_event_fileops = {\n\t.owner = THIS_MODULE,\n\t.llseek = noop_llseek,\n\t.unlocked_ioctl = iio_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.open = iio_chrdev_open,\n\t.release = iio_chrdev_release,\n};\n\nstatic int iio_check_unique_scan_index(struct iio_dev *indio_dev)\n{\n\tint i, j;\n\tconst struct iio_chan_spec *channels = indio_dev->channels;\n\n\tif (!(indio_dev->modes & INDIO_ALL_BUFFER_MODES))\n\t\treturn 0;\n\n\tfor (i = 0; i < indio_dev->num_channels - 1; i++) {\n\t\tif (channels[i].scan_index < 0)\n\t\t\tcontinue;\n\t\tfor (j = i + 1; j < indio_dev->num_channels; j++)\n\t\t\tif (channels[i].scan_index == channels[j].scan_index) {\n\t\t\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\t\"Duplicate scan index %d\\n\",\n\t\t\t\t\tchannels[i].scan_index);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int iio_check_extended_name(const struct iio_dev *indio_dev)\n{\n\tunsigned int i;\n\n\tif (!indio_dev->info->read_label)\n\t\treturn 0;\n\n\tfor (i = 0; i < indio_dev->num_channels; i++) {\n\t\tif (indio_dev->channels[i].extend_name) {\n\t\t\tdev_err(&indio_dev->dev,\n\t\t\t\t\"Cannot use labels and extend_name at the same time\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct iio_buffer_setup_ops noop_ring_setup_ops;\n\nint __iio_device_register(struct iio_dev *indio_dev, struct module *this_mod)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\tstruct fwnode_handle *fwnode = NULL;\n\tint ret;\n\n\tif (!indio_dev->info)\n\t\treturn -EINVAL;\n\n\tiio_dev_opaque->driver_module = this_mod;\n\n\t \n\tif (dev_fwnode(&indio_dev->dev))\n\t\tfwnode = dev_fwnode(&indio_dev->dev);\n\t \n\telse if (indio_dev->dev.parent)\n\t\tfwnode = dev_fwnode(indio_dev->dev.parent);\n\tdevice_set_node(&indio_dev->dev, fwnode);\n\n\tfwnode_property_read_string(fwnode, \"label\", &indio_dev->label);\n\n\tret = iio_check_unique_scan_index(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iio_check_extended_name(indio_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tiio_device_register_debugfs(indio_dev);\n\n\tret = iio_buffers_alloc_sysfs_and_mask(indio_dev);\n\tif (ret) {\n\t\tdev_err(indio_dev->dev.parent,\n\t\t\t\"Failed to create buffer sysfs interfaces\\n\");\n\t\tgoto error_unreg_debugfs;\n\t}\n\n\tret = iio_device_register_sysfs(indio_dev);\n\tif (ret) {\n\t\tdev_err(indio_dev->dev.parent,\n\t\t\t\"Failed to register sysfs interfaces\\n\");\n\t\tgoto error_buffer_free_sysfs;\n\t}\n\tret = iio_device_register_eventset(indio_dev);\n\tif (ret) {\n\t\tdev_err(indio_dev->dev.parent,\n\t\t\t\"Failed to register event set\\n\");\n\t\tgoto error_free_sysfs;\n\t}\n\tif (indio_dev->modes & INDIO_ALL_TRIGGERED_MODES)\n\t\tiio_device_register_trigger_consumer(indio_dev);\n\n\tif ((indio_dev->modes & INDIO_ALL_BUFFER_MODES) &&\n\t\tindio_dev->setup_ops == NULL)\n\t\tindio_dev->setup_ops = &noop_ring_setup_ops;\n\n\tif (iio_dev_opaque->attached_buffers_cnt)\n\t\tcdev_init(&iio_dev_opaque->chrdev, &iio_buffer_fileops);\n\telse if (iio_dev_opaque->event_interface)\n\t\tcdev_init(&iio_dev_opaque->chrdev, &iio_event_fileops);\n\n\tif (iio_dev_opaque->attached_buffers_cnt || iio_dev_opaque->event_interface) {\n\t\tindio_dev->dev.devt = MKDEV(MAJOR(iio_devt), iio_dev_opaque->id);\n\t\tiio_dev_opaque->chrdev.owner = this_mod;\n\t}\n\n\t \n\tindio_dev->dev.groups = iio_dev_opaque->groups;\n\n\tret = cdev_device_add(&iio_dev_opaque->chrdev, &indio_dev->dev);\n\tif (ret < 0)\n\t\tgoto error_unreg_eventset;\n\n\treturn 0;\n\nerror_unreg_eventset:\n\tiio_device_unregister_eventset(indio_dev);\nerror_free_sysfs:\n\tiio_device_unregister_sysfs(indio_dev);\nerror_buffer_free_sysfs:\n\tiio_buffers_free_sysfs_and_mask(indio_dev);\nerror_unreg_debugfs:\n\tiio_device_unregister_debugfs(indio_dev);\n\treturn ret;\n}\nEXPORT_SYMBOL(__iio_device_register);\n\n \nvoid iio_device_unregister(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\n\tcdev_device_del(&iio_dev_opaque->chrdev, &indio_dev->dev);\n\n\tmutex_lock(&iio_dev_opaque->info_exist_lock);\n\n\tiio_device_unregister_debugfs(indio_dev);\n\n\tiio_disable_all_buffers(indio_dev);\n\n\tindio_dev->info = NULL;\n\n\tiio_device_wakeup_eventset(indio_dev);\n\tiio_buffer_wakeup_poll(indio_dev);\n\n\tmutex_unlock(&iio_dev_opaque->info_exist_lock);\n\n\tiio_buffers_free_sysfs_and_mask(indio_dev);\n}\nEXPORT_SYMBOL(iio_device_unregister);\n\nstatic void devm_iio_device_unreg(void *indio_dev)\n{\n\tiio_device_unregister(indio_dev);\n}\n\nint __devm_iio_device_register(struct device *dev, struct iio_dev *indio_dev,\n\t\t\t       struct module *this_mod)\n{\n\tint ret;\n\n\tret = __iio_device_register(indio_dev, this_mod);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, devm_iio_device_unreg, indio_dev);\n}\nEXPORT_SYMBOL_GPL(__devm_iio_device_register);\n\n \nint iio_device_claim_direct_mode(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\n\tmutex_lock(&iio_dev_opaque->mlock);\n\n\tif (iio_buffer_enabled(indio_dev)) {\n\t\tmutex_unlock(&iio_dev_opaque->mlock);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iio_device_claim_direct_mode);\n\n \nvoid iio_device_release_direct_mode(struct iio_dev *indio_dev)\n{\n\tmutex_unlock(&to_iio_dev_opaque(indio_dev)->mlock);\n}\nEXPORT_SYMBOL_GPL(iio_device_release_direct_mode);\n\n \nint iio_device_claim_buffer_mode(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\n\tmutex_lock(&iio_dev_opaque->mlock);\n\n\tif (iio_buffer_enabled(indio_dev))\n\t\treturn 0;\n\n\tmutex_unlock(&iio_dev_opaque->mlock);\n\treturn -EBUSY;\n}\nEXPORT_SYMBOL_GPL(iio_device_claim_buffer_mode);\n\n \nvoid iio_device_release_buffer_mode(struct iio_dev *indio_dev)\n{\n\tmutex_unlock(&to_iio_dev_opaque(indio_dev)->mlock);\n}\nEXPORT_SYMBOL_GPL(iio_device_release_buffer_mode);\n\n \nint iio_device_get_current_mode(struct iio_dev *indio_dev)\n{\n\tstruct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(indio_dev);\n\n\treturn iio_dev_opaque->currentmode;\n}\nEXPORT_SYMBOL_GPL(iio_device_get_current_mode);\n\nsubsys_initcall(iio_init);\nmodule_exit(iio_exit);\n\nMODULE_AUTHOR(\"Jonathan Cameron <jic23@kernel.org>\");\nMODULE_DESCRIPTION(\"Industrial I/O core\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}