{
  "module_name": "iio_dummy_evgen.c",
  "hash_id": "3329fa99cb90a31f2606c4e36dd6abff45ca78bfde9ed6bcbe801550344662ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dummy/iio_dummy_evgen.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/sysfs.h>\n\n#include \"iio_dummy_evgen.h\"\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/irq_sim.h>\n\n \n#define IIO_EVENTGEN_NO 10\n\n \nstruct iio_dummy_eventgen {\n\tstruct iio_dummy_regs regs[IIO_EVENTGEN_NO];\n\tstruct mutex lock;\n\tbool inuse[IIO_EVENTGEN_NO];\n\tstruct irq_domain *irq_sim_domain;\n};\n\n \nstatic struct iio_dummy_eventgen *iio_evgen;\n\nstatic int iio_dummy_evgen_create(void)\n{\n\tint ret;\n\n\tiio_evgen = kzalloc(sizeof(*iio_evgen), GFP_KERNEL);\n\tif (!iio_evgen)\n\t\treturn -ENOMEM;\n\n\tiio_evgen->irq_sim_domain = irq_domain_create_sim(NULL,\n\t\t\t\t\t\t\t  IIO_EVENTGEN_NO);\n\tif (IS_ERR(iio_evgen->irq_sim_domain)) {\n\t\tret = PTR_ERR(iio_evgen->irq_sim_domain);\n\t\tkfree(iio_evgen);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&iio_evgen->lock);\n\n\treturn 0;\n}\n\n \nint iio_dummy_evgen_get_irq(void)\n{\n\tint i, ret = 0;\n\n\tif (!iio_evgen)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&iio_evgen->lock);\n\tfor (i = 0; i < IIO_EVENTGEN_NO; i++) {\n\t\tif (!iio_evgen->inuse[i]) {\n\t\t\tret = irq_create_mapping(iio_evgen->irq_sim_domain, i);\n\t\t\tiio_evgen->inuse[i] = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&iio_evgen->lock);\n\tif (i == IIO_EVENTGEN_NO)\n\t\treturn -ENOMEM;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iio_dummy_evgen_get_irq);\n\n \nvoid iio_dummy_evgen_release_irq(int irq)\n{\n\tstruct irq_data *irqd = irq_get_irq_data(irq);\n\n\tmutex_lock(&iio_evgen->lock);\n\tiio_evgen->inuse[irqd_to_hwirq(irqd)] = false;\n\tirq_dispose_mapping(irq);\n\tmutex_unlock(&iio_evgen->lock);\n}\nEXPORT_SYMBOL_GPL(iio_dummy_evgen_release_irq);\n\nstruct iio_dummy_regs *iio_dummy_evgen_get_regs(int irq)\n{\n\tstruct irq_data *irqd = irq_get_irq_data(irq);\n\n\treturn &iio_evgen->regs[irqd_to_hwirq(irqd)];\n\n}\nEXPORT_SYMBOL_GPL(iio_dummy_evgen_get_regs);\n\nstatic void iio_dummy_evgen_free(void)\n{\n\tirq_domain_remove_sim(iio_evgen->irq_sim_domain);\n\tkfree(iio_evgen);\n}\n\nstatic void iio_evgen_release(struct device *dev)\n{\n\tiio_dummy_evgen_free();\n}\n\nstatic ssize_t iio_evgen_poke(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf,\n\t\t\t      size_t len)\n{\n\tstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\n\tunsigned long event;\n\tint ret, irq;\n\n\tret = kstrtoul(buf, 10, &event);\n\tif (ret)\n\t\treturn ret;\n\n\tiio_evgen->regs[this_attr->address].reg_id   = this_attr->address;\n\tiio_evgen->regs[this_attr->address].reg_data = event;\n\n\tirq = irq_find_mapping(iio_evgen->irq_sim_domain, this_attr->address);\n\tret = irq_set_irqchip_state(irq, IRQCHIP_STATE_PENDING, true);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(poke_ev0, S_IWUSR, NULL, &iio_evgen_poke, 0);\nstatic IIO_DEVICE_ATTR(poke_ev1, S_IWUSR, NULL, &iio_evgen_poke, 1);\nstatic IIO_DEVICE_ATTR(poke_ev2, S_IWUSR, NULL, &iio_evgen_poke, 2);\nstatic IIO_DEVICE_ATTR(poke_ev3, S_IWUSR, NULL, &iio_evgen_poke, 3);\nstatic IIO_DEVICE_ATTR(poke_ev4, S_IWUSR, NULL, &iio_evgen_poke, 4);\nstatic IIO_DEVICE_ATTR(poke_ev5, S_IWUSR, NULL, &iio_evgen_poke, 5);\nstatic IIO_DEVICE_ATTR(poke_ev6, S_IWUSR, NULL, &iio_evgen_poke, 6);\nstatic IIO_DEVICE_ATTR(poke_ev7, S_IWUSR, NULL, &iio_evgen_poke, 7);\nstatic IIO_DEVICE_ATTR(poke_ev8, S_IWUSR, NULL, &iio_evgen_poke, 8);\nstatic IIO_DEVICE_ATTR(poke_ev9, S_IWUSR, NULL, &iio_evgen_poke, 9);\n\nstatic struct attribute *iio_evgen_attrs[] = {\n\t&iio_dev_attr_poke_ev0.dev_attr.attr,\n\t&iio_dev_attr_poke_ev1.dev_attr.attr,\n\t&iio_dev_attr_poke_ev2.dev_attr.attr,\n\t&iio_dev_attr_poke_ev3.dev_attr.attr,\n\t&iio_dev_attr_poke_ev4.dev_attr.attr,\n\t&iio_dev_attr_poke_ev5.dev_attr.attr,\n\t&iio_dev_attr_poke_ev6.dev_attr.attr,\n\t&iio_dev_attr_poke_ev7.dev_attr.attr,\n\t&iio_dev_attr_poke_ev8.dev_attr.attr,\n\t&iio_dev_attr_poke_ev9.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group iio_evgen_group = {\n\t.attrs = iio_evgen_attrs,\n};\n\nstatic const struct attribute_group *iio_evgen_groups[] = {\n\t&iio_evgen_group,\n\tNULL\n};\n\nstatic struct device iio_evgen_dev = {\n\t.bus = &iio_bus_type,\n\t.groups = iio_evgen_groups,\n\t.release = &iio_evgen_release,\n};\n\nstatic __init int iio_dummy_evgen_init(void)\n{\n\tint ret = iio_dummy_evgen_create();\n\n\tif (ret < 0)\n\t\treturn ret;\n\tdevice_initialize(&iio_evgen_dev);\n\tdev_set_name(&iio_evgen_dev, \"iio_evgen\");\n\tret = device_add(&iio_evgen_dev);\n\tif (ret)\n\t\tput_device(&iio_evgen_dev);\n\treturn ret;\n}\nmodule_init(iio_dummy_evgen_init);\n\nstatic __exit void iio_dummy_evgen_exit(void)\n{\n\tdevice_unregister(&iio_evgen_dev);\n}\nmodule_exit(iio_dummy_evgen_exit);\n\nMODULE_AUTHOR(\"Jonathan Cameron <jic23@kernel.org>\");\nMODULE_DESCRIPTION(\"IIO dummy driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}