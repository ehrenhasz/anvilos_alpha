{
  "module_name": "iio_simple_dummy.c",
  "hash_id": "cd05c9411393f1be83366df4368f513fa10e361e772a53f45d42e2f204529622",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/dummy/iio_simple_dummy.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/sw_device.h>\n#include \"iio_simple_dummy.h\"\n\nstatic const struct config_item_type iio_dummy_type = {\n\t.ct_owner = THIS_MODULE,\n};\n\n \nstruct iio_dummy_accel_calibscale {\n\tint val;\n\tint val2;\n\tint regval;  \n};\n\nstatic const struct iio_dummy_accel_calibscale dummy_scales[] = {\n\t{ 0, 100, 0x8 },  \n\t{ 0, 133, 0x7 },  \n\t{ 733, 13, 0x9 },  \n};\n\n#ifdef CONFIG_IIO_SIMPLE_DUMMY_EVENTS\n\n \nstatic const struct iio_event_spec iio_dummy_event = {\n\t.type = IIO_EV_TYPE_THRESH,\n\t.dir = IIO_EV_DIR_RISING,\n\t.mask_separate = BIT(IIO_EV_INFO_VALUE) | BIT(IIO_EV_INFO_ENABLE),\n};\n\n \nstatic const struct iio_event_spec step_detect_event = {\n\t.type = IIO_EV_TYPE_CHANGE,\n\t.dir = IIO_EV_DIR_NONE,\n\t.mask_separate = BIT(IIO_EV_INFO_ENABLE),\n};\n\n \nstatic const struct iio_event_spec iio_running_event = {\n\t.type = IIO_EV_TYPE_THRESH,\n\t.dir = IIO_EV_DIR_RISING,\n\t.mask_separate = BIT(IIO_EV_INFO_VALUE) | BIT(IIO_EV_INFO_ENABLE),\n};\n\n \nstatic const struct iio_event_spec iio_walking_event = {\n\t.type = IIO_EV_TYPE_THRESH,\n\t.dir = IIO_EV_DIR_FALLING,\n\t.mask_separate = BIT(IIO_EV_INFO_VALUE) | BIT(IIO_EV_INFO_ENABLE),\n};\n#endif\n\n \nstatic const struct iio_chan_spec iio_dummy_channels[] = {\n\t \n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t \n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t\t \n\t\t.info_mask_separate =\n\t\t \n\t\tBIT(IIO_CHAN_INFO_RAW) |\n\t\t \n\t\tBIT(IIO_CHAN_INFO_OFFSET) |\n\t\t \n\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t \n\t\t.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t \n\t\t.scan_index = DUMMY_INDEX_VOLTAGE_0,\n\t\t.scan_type = {  \n\t\t\t.sign = 'u',  \n\t\t\t.realbits = 13,  \n\t\t\t.storagebits = 16,  \n\t\t\t.shift = 0,  \n\t\t},\n#ifdef CONFIG_IIO_SIMPLE_DUMMY_EVENTS\n\t\t.event_spec = &iio_dummy_event,\n\t\t.num_event_specs = 1,\n#endif  \n\t},\n\t \n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.differential = 1,\n\t\t \n\t\t.indexed = 1,\n\t\t.channel = 1,\n\t\t.channel2 = 2,\n\t\t \n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t \n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t\t \n\t\t.scan_index = DUMMY_INDEX_DIFFVOLTAGE_1M2,\n\t\t.scan_type = {  \n\t\t\t.sign = 's',  \n\t\t\t.realbits = 12,  \n\t\t\t.storagebits = 16,  \n\t\t\t.shift = 0,  \n\t\t},\n\t},\n\t \n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.differential = 1,\n\t\t.indexed = 1,\n\t\t.channel = 3,\n\t\t.channel2 = 4,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.scan_index = DUMMY_INDEX_DIFFVOLTAGE_3M4,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 11,\n\t\t\t.storagebits = 16,\n\t\t\t.shift = 0,\n\t\t},\n\t},\n\t \n\t{\n\t\t.type = IIO_ACCEL,\n\t\t.modified = 1,\n\t\t \n\t\t.channel2 = IIO_MOD_X,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t \n\t\tBIT(IIO_CHAN_INFO_CALIBSCALE) |\n\t\tBIT(IIO_CHAN_INFO_CALIBBIAS),\n\t\t.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.scan_index = DUMMY_INDEX_ACCELX,\n\t\t.scan_type = {  \n\t\t\t.sign = 's',  \n\t\t\t.realbits = 16,  \n\t\t\t.storagebits = 16,  \n\t\t\t.shift = 0,  \n\t\t},\n\t},\n\t \n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n\t \n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.scan_index = -1,  \n\t\t.output = 1,\n\t\t.indexed = 1,\n\t\t.channel = 0,\n\t},\n\t{\n\t\t.type = IIO_STEPS,\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_ENABLE) |\n\t\t\tBIT(IIO_CHAN_INFO_CALIBHEIGHT),\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.scan_index = -1,  \n#ifdef CONFIG_IIO_SIMPLE_DUMMY_EVENTS\n\t\t.event_spec = &step_detect_event,\n\t\t.num_event_specs = 1,\n#endif  \n\t},\n\t{\n\t\t.type = IIO_ACTIVITY,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_RUNNING,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.scan_index = -1,  \n#ifdef CONFIG_IIO_SIMPLE_DUMMY_EVENTS\n\t\t.event_spec = &iio_running_event,\n\t\t.num_event_specs = 1,\n#endif  \n\t},\n\t{\n\t\t.type = IIO_ACTIVITY,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_WALKING,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.scan_index = -1,  \n#ifdef CONFIG_IIO_SIMPLE_DUMMY_EVENTS\n\t\t.event_spec = &iio_walking_event,\n\t\t.num_event_specs = 1,\n#endif  \n\t},\n};\n\n \nstatic int iio_dummy_read_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int *val,\n\t\t\t      int *val2,\n\t\t\t      long mask)\n{\n\tstruct iio_dummy_state *st = iio_priv(indio_dev);\n\tint ret = -EINVAL;\n\n\tmutex_lock(&st->lock);\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:  \n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tif (chan->output) {\n\t\t\t\t \n\t\t\t\t*val = st->dac_val;\n\t\t\t\tret = IIO_VAL_INT;\n\t\t\t} else if (chan->differential) {\n\t\t\t\tif (chan->channel == 1)\n\t\t\t\t\t*val = st->differential_adc_val[0];\n\t\t\t\telse\n\t\t\t\t\t*val = st->differential_adc_val[1];\n\t\t\t\tret = IIO_VAL_INT;\n\t\t\t} else {\n\t\t\t\t*val = st->single_ended_adc_val;\n\t\t\t\tret = IIO_VAL_INT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IIO_ACCEL:\n\t\t\t*val = st->accel_val;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_STEPS:\n\t\t\t*val = st->steps;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_ACTIVITY:\n\t\t\tswitch (chan->channel2) {\n\t\t\tcase IIO_MOD_RUNNING:\n\t\t\t\t*val = st->activity_running;\n\t\t\t\tret = IIO_VAL_INT;\n\t\t\t\tbreak;\n\t\t\tcase IIO_MOD_WALKING:\n\t\t\t\t*val = st->activity_walking;\n\t\t\t\tret = IIO_VAL_INT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t \n\t\t*val = 7;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tswitch (chan->differential) {\n\t\t\tcase 0:\n\t\t\t\t \n\t\t\t\t*val = 0;\n\t\t\t\t*val2 = 1333;\n\t\t\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t \n\t\t\t\t*val = 0;\n\t\t\t\t*val2 = 1344;\n\t\t\t\tret = IIO_VAL_INT_PLUS_NANO;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\t \n\t\t*val = st->accel_calibbias;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\t*val = st->accel_calibscale->val;\n\t\t*val2 = st->accel_calibscale->val2;\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = 3;\n\t\t*val2 = 33;\n\t\tret = IIO_VAL_INT_PLUS_NANO;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_STEPS:\n\t\t\t*val = st->steps_enabled;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBHEIGHT:\n\t\tswitch (chan->type) {\n\t\tcase IIO_STEPS:\n\t\t\t*val = st->height;\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&st->lock);\n\treturn ret;\n}\n\n \nstatic int iio_dummy_write_raw(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       int val,\n\t\t\t       int val2,\n\t\t\t       long mask)\n{\n\tint i;\n\tint ret = 0;\n\tstruct iio_dummy_state *st = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (chan->type) {\n\t\tcase IIO_VOLTAGE:\n\t\t\tif (chan->output == 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tmutex_lock(&st->lock);\n\t\t\tst->dac_val = val;\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (chan->type) {\n\t\tcase IIO_STEPS:\n\t\t\tmutex_lock(&st->lock);\n\t\t\tst->steps = val;\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn 0;\n\t\tcase IIO_ACTIVITY:\n\t\t\tif (val < 0)\n\t\t\t\tval = 0;\n\t\t\tif (val > 100)\n\t\t\t\tval = 100;\n\t\t\tswitch (chan->channel2) {\n\t\t\tcase IIO_MOD_RUNNING:\n\t\t\t\tst->activity_running = val;\n\t\t\t\treturn 0;\n\t\t\tcase IIO_MOD_WALKING:\n\t\t\t\tst->activity_walking = val;\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_CALIBSCALE:\n\t\tmutex_lock(&st->lock);\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(dummy_scales); i++)\n\t\t\tif (val == dummy_scales[i].val &&\n\t\t\t    val2 == dummy_scales[i].val2)\n\t\t\t\tbreak;\n\t\tif (i == ARRAY_SIZE(dummy_scales))\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tst->accel_calibscale = &dummy_scales[i];\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tmutex_lock(&st->lock);\n\t\tst->accel_calibbias = val;\n\t\tmutex_unlock(&st->lock);\n\t\treturn 0;\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_STEPS:\n\t\t\tmutex_lock(&st->lock);\n\t\t\tst->steps_enabled = val;\n\t\t\tmutex_unlock(&st->lock);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_CALIBHEIGHT:\n\t\tswitch (chan->type) {\n\t\tcase IIO_STEPS:\n\t\t\tst->height = val;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic const struct iio_info iio_dummy_info = {\n\t.read_raw = &iio_dummy_read_raw,\n\t.write_raw = &iio_dummy_write_raw,\n#ifdef CONFIG_IIO_SIMPLE_DUMMY_EVENTS\n\t.read_event_config = &iio_simple_dummy_read_event_config,\n\t.write_event_config = &iio_simple_dummy_write_event_config,\n\t.read_event_value = &iio_simple_dummy_read_event_value,\n\t.write_event_value = &iio_simple_dummy_write_event_value,\n#endif  \n};\n\n \nstatic int iio_dummy_init_device(struct iio_dev *indio_dev)\n{\n\tstruct iio_dummy_state *st = iio_priv(indio_dev);\n\n\tst->dac_val = 0;\n\tst->single_ended_adc_val = 73;\n\tst->differential_adc_val[0] = 33;\n\tst->differential_adc_val[1] = -34;\n\tst->accel_val = 34;\n\tst->accel_calibbias = -7;\n\tst->accel_calibscale = &dummy_scales[0];\n\tst->steps = 47;\n\tst->activity_running = 98;\n\tst->activity_walking = 4;\n\n\treturn 0;\n}\n\n \nstatic struct iio_sw_device *iio_dummy_probe(const char *name)\n{\n\tint ret;\n\tstruct iio_dev *indio_dev;\n\tstruct iio_dummy_state *st;\n\tstruct iio_sw_device *swd;\n\tstruct device *parent = NULL;\n\n\t \n\n\tswd = kzalloc(sizeof(*swd), GFP_KERNEL);\n\tif (!swd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tindio_dev = iio_device_alloc(parent, sizeof(*st));\n\tif (!indio_dev) {\n\t\tret = -ENOMEM;\n\t\tgoto error_free_swd;\n\t}\n\n\tst = iio_priv(indio_dev);\n\tmutex_init(&st->lock);\n\n\tiio_dummy_init_device(indio_dev);\n\n\t  \n\tswd->device = indio_dev;\n\n\t \n\tindio_dev->name = kstrdup(name, GFP_KERNEL);\n\tif (!indio_dev->name) {\n\t\tret = -ENOMEM;\n\t\tgoto error_free_device;\n\t}\n\n\t \n\tindio_dev->channels = iio_dummy_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(iio_dummy_channels);\n\n\t \n\tindio_dev->info = &iio_dummy_info;\n\n\t \n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = iio_simple_dummy_events_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto error_free_name;\n\n\tret = iio_simple_dummy_configure_buffer(indio_dev);\n\tif (ret < 0)\n\t\tgoto error_unregister_events;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto error_unconfigure_buffer;\n\n\tiio_swd_group_init_type_name(swd, name, &iio_dummy_type);\n\n\treturn swd;\nerror_unconfigure_buffer:\n\tiio_simple_dummy_unconfigure_buffer(indio_dev);\nerror_unregister_events:\n\tiio_simple_dummy_events_unregister(indio_dev);\nerror_free_name:\n\tkfree(indio_dev->name);\nerror_free_device:\n\tiio_device_free(indio_dev);\nerror_free_swd:\n\tkfree(swd);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic int iio_dummy_remove(struct iio_sw_device *swd)\n{\n\t \n\tstruct iio_dev *indio_dev = swd->device;\n\n\t \n\tiio_device_unregister(indio_dev);\n\n\t \n\n\t \n\tiio_simple_dummy_unconfigure_buffer(indio_dev);\n\n\tiio_simple_dummy_events_unregister(indio_dev);\n\n\t \n\tkfree(indio_dev->name);\n\tiio_device_free(indio_dev);\n\n\treturn 0;\n}\n\n \nstatic const struct iio_sw_device_ops iio_dummy_device_ops = {\n\t.probe = iio_dummy_probe,\n\t.remove = iio_dummy_remove,\n};\n\nstatic struct iio_sw_device_type iio_dummy_device = {\n\t.name = \"dummy\",\n\t.owner = THIS_MODULE,\n\t.ops = &iio_dummy_device_ops,\n};\n\nmodule_iio_sw_device_driver(iio_dummy_device);\n\nMODULE_AUTHOR(\"Jonathan Cameron <jic23@kernel.org>\");\nMODULE_DESCRIPTION(\"IIO dummy driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}