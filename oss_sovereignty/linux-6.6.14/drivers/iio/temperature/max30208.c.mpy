{
  "module_name": "max30208.c",
  "hash_id": "5800db56b1d86633ffa2fcfb4607a12622637bf19bdd4bbdc3308b0a79cfe96e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/temperature/max30208.c",
  "human_readable_source": "\n\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/iio/iio.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/types.h>\n\n#define MAX30208_STATUS\t\t\t0x00\n#define MAX30208_STATUS_TEMP_RDY\tBIT(0)\n#define MAX30208_INT_ENABLE\t\t0x01\n#define MAX30208_INT_ENABLE_TEMP_RDY\tBIT(0)\n\n#define MAX30208_FIFO_OVF_CNTR\t\t0x06\n#define MAX30208_FIFO_DATA_CNTR\t\t0x07\n#define MAX30208_FIFO_DATA\t\t0x08\n\n#define MAX30208_FIFO_CONFIG\t\t0x0a\n#define MAX30208_FIFO_CONFIG_RO\t\tBIT(1)\n\n#define MAX30208_SYSTEM_CTRL\t\t0x0c\n#define MAX30208_SYSTEM_CTRL_RESET\t0x01\n\n#define MAX30208_TEMP_SENSOR_SETUP\t0x14\n#define MAX30208_TEMP_SENSOR_SETUP_CONV\tBIT(0)\n\nstruct max30208_data {\n\tstruct i2c_client *client;\n\tstruct iio_dev *indio_dev;\n\tstruct mutex lock;  \n};\n\nstatic const struct iio_chan_spec max30208_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t},\n};\n\n \nstatic int max30208_request(struct max30208_data *data)\n{\n\t \n\tint retries = 10;\n\tu8 regval;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, MAX30208_TEMP_SENSOR_SETUP);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregval = ret | MAX30208_TEMP_SENSOR_SETUP_CONV;\n\n\tret = i2c_smbus_write_byte_data(data->client, MAX30208_TEMP_SENSOR_SETUP, regval);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (retries--) {\n\t\tret = i2c_smbus_read_byte_data(data->client, MAX30208_STATUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret & MAX30208_STATUS_TEMP_RDY)\n\t\t\treturn 0;\n\n\t\tmsleep(50);\n\t}\n\tdev_err(&data->client->dev, \"Temperature conversion failed\\n\");\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int max30208_update_temp(struct max30208_data *data)\n{\n\tu8 data_count;\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\n\tret = max30208_request(data);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = i2c_smbus_read_byte_data(data->client, MAX30208_FIFO_OVF_CNTR);\n\tif (ret < 0)\n\t\tgoto unlock;\n\telse if (!ret) {\n\t\tret = i2c_smbus_read_byte_data(data->client, MAX30208_FIFO_DATA_CNTR);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\n\t\tdata_count = ret;\n\t} else\n\t\tdata_count = 1;\n\n\twhile (data_count) {\n\t\tret = i2c_smbus_read_word_swapped(data->client, MAX30208_FIFO_DATA);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\n\t\tdata_count--;\n\t}\n\nunlock:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\n \nstatic int max30208_config_setup(struct max30208_data *data)\n{\n\tu8 regval;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, MAX30208_FIFO_CONFIG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregval = ret | MAX30208_FIFO_CONFIG_RO;\n\n\tret = i2c_smbus_write_byte_data(data->client, MAX30208_FIFO_CONFIG, regval);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int max30208_read(struct iio_dev *indio_dev,\n\t\t\t struct iio_chan_spec const *chan,\n\t\t\t int *val, int *val2, long mask)\n{\n\tstruct max30208_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = max30208_update_temp(data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val = sign_extend32(ret, 15);\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 5;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info max30208_info = {\n\t.read_raw = max30208_read,\n};\n\nstatic int max30208_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct max30208_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = i2c;\n\tmutex_init(&data->lock);\n\n\tindio_dev->name = \"max30208\";\n\tindio_dev->channels = max30208_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(max30208_channels);\n\tindio_dev->info = &max30208_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = i2c_smbus_write_byte_data(data->client, MAX30208_SYSTEM_CTRL,\n\t\t\t\t\tMAX30208_SYSTEM_CTRL_RESET);\n\tif (ret) {\n\t\tdev_err(dev, \"Failure in performing reset\\n\");\n\t\treturn ret;\n\t}\n\n\tmsleep(50);\n\n\tret = max30208_config_setup(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register IIO device\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max30208_id_table[] = {\n\t{ \"max30208\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max30208_id_table);\n\nstatic const struct acpi_device_id max30208_acpi_match[] = {\n\t{ \"MAX30208\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, max30208_acpi_match);\n\nstatic const struct of_device_id max30208_of_match[] = {\n\t{ .compatible = \"maxim,max30208\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max30208_of_match);\n\nstatic struct i2c_driver max30208_driver = {\n\t.driver = {\n\t\t.name = \"max30208\",\n\t\t.of_match_table = max30208_of_match,\n\t\t.acpi_match_table = max30208_acpi_match,\n\t},\n\t.probe = max30208_probe,\n\t.id_table = max30208_id_table,\n};\nmodule_i2c_driver(max30208_driver);\n\nMODULE_AUTHOR(\"Rajat Khandelwal <rajat.khandelwal@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Maxim MAX30208 digital temperature sensor\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}