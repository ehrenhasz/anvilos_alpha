{
  "module_name": "tsys01.c",
  "hash_id": "4f78524c0398c3dc8fe066f1da3f6d95e4d08c24bb42c148bbbcad79dea2fe8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/temperature/tsys01.c",
  "human_readable_source": "\n \n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include \"../common/ms_sensors/ms_sensors_i2c.h\"\n\n \n#define TSYS01_RESET\t\t\t\t0x1E\n#define TSYS01_CONVERSION_START\t\t\t0x48\n#define TSYS01_ADC_READ\t\t\t\t0x00\n#define TSYS01_PROM_READ\t\t\t0xA0\n\n#define TSYS01_PROM_WORDS_NB\t\t\t8\n\nstruct tsys01_dev {\n\tvoid *client;\n\tstruct mutex lock;  \n\n\tint (*reset)(void *cli, u8 cmd, unsigned int delay);\n\tint (*convert_and_read)(void *cli, u8 conv, u8 rd,\n\t\t\t\tunsigned int delay, u32 *adc);\n\tint (*read_prom_word)(void *cli, int cmd, u16 *word);\n\n\tu16 prom[TSYS01_PROM_WORDS_NB];\n};\n\n \nstatic const int coeff_mul[] = { -1500000, 1000000, -2000000,\n\t\t\t\t 4000000, -2000000 };\n\nstatic int tsys01_read_temperature(struct iio_dev *indio_dev,\n\t\t\t\t   s32 *temperature)\n{\n\tint ret, i;\n\tu32 adc;\n\ts64 temp = 0;\n\tstruct tsys01_dev *dev_data = iio_priv(indio_dev);\n\n\tmutex_lock(&dev_data->lock);\n\tret = dev_data->convert_and_read(dev_data->client,\n\t\t\t\t\t TSYS01_CONVERSION_START,\n\t\t\t\t\t TSYS01_ADC_READ, 9000, &adc);\n\tmutex_unlock(&dev_data->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tadc >>= 8;\n\n\t \n\tfor (i = 4; i > 0; i--) {\n\t\ttemp += coeff_mul[i] *\n\t\t\t(s64)dev_data->prom[5 - i];\n\t\ttemp *= (s64)adc;\n\t\ttemp = div64_s64(temp, 100000);\n\t}\n\ttemp *= 10;\n\ttemp += coeff_mul[0] * (s64)dev_data->prom[5];\n\ttemp = div64_s64(temp, 100000);\n\n\t*temperature = temp;\n\n\treturn 0;\n}\n\nstatic int tsys01_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *channel, int *val,\n\t\t\t   int *val2, long mask)\n{\n\tint ret;\n\ts32 temperature;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (channel->type) {\n\t\tcase IIO_TEMP:\t \n\t\t\tret = tsys01_read_temperature(indio_dev, &temperature);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\t*val = temperature;\n\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_chan_spec tsys01_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_PROCESSED),\n\t}\n};\n\nstatic const struct iio_info tsys01_info = {\n\t.read_raw = tsys01_read_raw,\n};\n\nstatic bool tsys01_crc_valid(u16 *n_prom)\n{\n\tu8 cnt;\n\tu8 sum = 0;\n\n\tfor (cnt = 0; cnt < TSYS01_PROM_WORDS_NB; cnt++)\n\t\tsum += ((n_prom[0] >> 8) + (n_prom[0] & 0xFF));\n\n\treturn (sum == 0);\n}\n\nstatic int tsys01_read_prom(struct iio_dev *indio_dev)\n{\n\tint i, ret;\n\tstruct tsys01_dev *dev_data = iio_priv(indio_dev);\n\tchar buf[7 * TSYS01_PROM_WORDS_NB + 1];\n\tchar *ptr = buf;\n\n\tfor (i = 0; i < TSYS01_PROM_WORDS_NB; i++) {\n\t\tret = dev_data->read_prom_word(dev_data->client,\n\t\t\t\t\t       TSYS01_PROM_READ + (i << 1),\n\t\t\t\t\t       &dev_data->prom[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = sprintf(ptr, \"0x%04x \", dev_data->prom[i]);\n\t\tptr += ret;\n\t}\n\n\tif (!tsys01_crc_valid(dev_data->prom)) {\n\t\tdev_err(&indio_dev->dev, \"prom crc check error\\n\");\n\t\treturn -ENODEV;\n\t}\n\t*ptr = 0;\n\tdev_info(&indio_dev->dev, \"PROM coefficients : %s\\n\", buf);\n\n\treturn 0;\n}\n\nstatic int tsys01_probe(struct iio_dev *indio_dev, struct device *dev)\n{\n\tint ret;\n\tstruct tsys01_dev *dev_data = iio_priv(indio_dev);\n\n\tmutex_init(&dev_data->lock);\n\n\tindio_dev->info = &tsys01_info;\n\tindio_dev->name = dev->driver->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = tsys01_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(tsys01_channels);\n\n\tret = dev_data->reset(dev_data->client, TSYS01_RESET, 3000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tsys01_read_prom(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic int tsys01_i2c_probe(struct i2c_client *client)\n{\n\tstruct tsys01_dev *dev_data;\n\tstruct iio_dev *indio_dev;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_WORD_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_BYTE |\n\t\t\t\t     I2C_FUNC_SMBUS_READ_I2C_BLOCK)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Adapter does not support some i2c transaction\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*dev_data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdev_data = iio_priv(indio_dev);\n\tdev_data->client = client;\n\tdev_data->reset = ms_sensors_reset;\n\tdev_data->read_prom_word = ms_sensors_read_prom_word;\n\tdev_data->convert_and_read = ms_sensors_convert_and_read;\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\treturn tsys01_probe(indio_dev, &client->dev);\n}\n\nstatic const struct i2c_device_id tsys01_id[] = {\n\t{\"tsys01\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, tsys01_id);\n\nstatic const struct of_device_id tsys01_of_match[] = {\n\t{ .compatible = \"meas,tsys01\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tsys01_of_match);\n\nstatic struct i2c_driver tsys01_driver = {\n\t.probe = tsys01_i2c_probe,\n\t.id_table = tsys01_id,\n\t.driver = {\n\t\t   .name = \"tsys01\",\n\t\t   .of_match_table = tsys01_of_match,\n\t\t   },\n};\n\nmodule_i2c_driver(tsys01_driver);\n\nMODULE_DESCRIPTION(\"Measurement-Specialties tsys01 temperature driver\");\nMODULE_AUTHOR(\"William Markezana <william.markezana@meas-spec.com>\");\nMODULE_AUTHOR(\"Ludovic Tancerel <ludovic.tancerel@maplehightech.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_MEAS_SPEC_SENSORS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}