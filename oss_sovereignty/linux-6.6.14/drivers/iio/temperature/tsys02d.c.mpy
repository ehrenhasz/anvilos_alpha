{
  "module_name": "tsys02d.c",
  "hash_id": "e8f272d3e5cc272f22a1065960e23f6f1273936d1a65110c5b23a00afe9851b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/temperature/tsys02d.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#include \"../common/ms_sensors/ms_sensors_i2c.h\"\n\n#define TSYS02D_RESET\t\t\t\t0xFE\n\nstatic const int tsys02d_samp_freq[4] = { 20, 40, 70, 140 };\n \nstatic const char tsys02d_show_samp_freq[] = \"20 40 70 140\";\n\nstatic int tsys02d_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *channel, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tint ret;\n\ts32 temperature;\n\tstruct ms_ht_dev *dev_data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (channel->type) {\n\t\tcase IIO_TEMP:\t \n\t\t\tret = ms_sensors_ht_read_temperature(dev_data,\n\t\t\t\t\t\t\t     &temperature);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\t*val = temperature;\n\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = tsys02d_samp_freq[dev_data->res_index];\n\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tsys02d_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct ms_ht_dev *dev_data = iio_priv(indio_dev);\n\tint i, ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\ti = ARRAY_SIZE(tsys02d_samp_freq);\n\t\twhile (i-- > 0)\n\t\t\tif (val == tsys02d_samp_freq[i])\n\t\t\t\tbreak;\n\t\tif (i < 0)\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&dev_data->lock);\n\t\tdev_data->res_index = i;\n\t\tret = ms_sensors_write_resolution(dev_data, i);\n\t\tmutex_unlock(&dev_data->lock);\n\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_chan_spec tsys02d_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t}\n};\n\nstatic ssize_t tsys02_read_battery_low(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ms_ht_dev *dev_data = iio_priv(indio_dev);\n\n\treturn ms_sensors_show_battery_low(dev_data, buf);\n}\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(tsys02d_show_samp_freq);\nstatic IIO_DEVICE_ATTR(battery_low, S_IRUGO,\n\t\t       tsys02_read_battery_low, NULL, 0);\n\nstatic struct attribute *tsys02d_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_battery_low.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group tsys02d_attribute_group = {\n\t.attrs = tsys02d_attributes,\n};\n\nstatic const struct iio_info tsys02d_info = {\n\t.read_raw = tsys02d_read_raw,\n\t.write_raw = tsys02d_write_raw,\n\t.attrs = &tsys02d_attribute_group,\n};\n\nstatic int tsys02d_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct ms_ht_dev *dev_data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\tu64 serial_number;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_BYTE |\n\t\t\t\t     I2C_FUNC_SMBUS_READ_I2C_BLOCK)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Adapter does not support some i2c transaction\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*dev_data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdev_data = iio_priv(indio_dev);\n\tdev_data->client = client;\n\tdev_data->res_index = 0;\n\tmutex_init(&dev_data->lock);\n\n\tindio_dev->info = &tsys02d_info;\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = tsys02d_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(tsys02d_channels);\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\tret = ms_sensors_reset(client, TSYS02D_RESET, 15000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ms_sensors_read_serial(client, &serial_number);\n\tif (ret)\n\t\treturn ret;\n\tdev_info(&client->dev, \"Serial number : %llx\", serial_number);\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id tsys02d_id[] = {\n\t{\"tsys02d\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, tsys02d_id);\n\nstatic struct i2c_driver tsys02d_driver = {\n\t.probe = tsys02d_probe,\n\t.id_table = tsys02d_id,\n\t.driver = {\n\t\t   .name = \"tsys02d\",\n\t\t   },\n};\n\nmodule_i2c_driver(tsys02d_driver);\n\nMODULE_DESCRIPTION(\"Measurement-Specialties tsys02d temperature driver\");\nMODULE_AUTHOR(\"William Markezana <william.markezana@meas-spec.com>\");\nMODULE_AUTHOR(\"Ludovic Tancerel <ludovic.tancerel@maplehightech.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_MEAS_SPEC_SENSORS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}