{
  "module_name": "max31865.c",
  "hash_id": "9e6e8b295de8e0c439289350aba18558acb6c97b7130491115b56cdf07d754ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/temperature/max31865.c",
  "human_readable_source": "\n\n \n\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n#include <asm/unaligned.h>\n\n \n#define MAX31865_RD_WR_BIT\t\t\tBIT(7)\n\n#define MAX31865_CFG_VBIAS\t\t\tBIT(7)\n#define MAX31865_CFG_1SHOT\t\t\tBIT(5)\n#define MAX31865_3WIRE_RTD\t\t\tBIT(4)\n#define MAX31865_FAULT_STATUS_CLEAR\t\tBIT(1)\n#define MAX31865_FILTER_50HZ\t\t\tBIT(0)\n\n \n#define MAX31865_CFG_REG\t\t\t0x00\n#define MAX31865_RTD_MSB\t\t\t0x01\n#define MAX31865_FAULT_STATUS\t\t\t0x07\n\n#define MAX31865_FAULT_OVUV\t\t\tBIT(2)\n\nstatic const char max31865_show_samp_freq[] = \"50 60\";\n\nstatic const struct iio_chan_spec max31865_channels[] = {\n\t{\t \n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE)\n\t},\n};\n\nstruct max31865_data {\n\tstruct spi_device *spi;\n\tstruct mutex lock;\n\tbool filter_50hz;\n\tbool three_wire;\n\tu8 buf[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic int max31865_read(struct max31865_data *data, u8 reg,\n\t\t\t unsigned int read_size)\n{\n\treturn spi_write_then_read(data->spi, &reg, 1, data->buf, read_size);\n}\n\nstatic int max31865_write(struct max31865_data *data, size_t len)\n{\n\treturn spi_write(data->spi, data->buf, len);\n}\n\nstatic int enable_bias(struct max31865_data *data)\n{\n\tu8 cfg;\n\tint ret;\n\n\tret = max31865_read(data, MAX31865_CFG_REG, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tcfg = data->buf[0];\n\n\tdata->buf[0] = MAX31865_CFG_REG | MAX31865_RD_WR_BIT;\n\tdata->buf[1] = cfg | MAX31865_CFG_VBIAS;\n\n\treturn max31865_write(data, 2);\n}\n\nstatic int disable_bias(struct max31865_data *data)\n{\n\tu8 cfg;\n\tint ret;\n\n\tret = max31865_read(data, MAX31865_CFG_REG, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tcfg = data->buf[0];\n\tcfg &= ~MAX31865_CFG_VBIAS;\n\n\tdata->buf[0] = MAX31865_CFG_REG | MAX31865_RD_WR_BIT;\n\tdata->buf[1] = cfg;\n\n\treturn max31865_write(data, 2);\n}\n\nstatic int max31865_rtd_read(struct max31865_data *data, int *val)\n{\n\tu8 reg;\n\tint ret;\n\n\t \n\tret = enable_bias(data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(11);\n\n\tret = max31865_read(data, MAX31865_CFG_REG, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treg = data->buf[0];\n\treg |= MAX31865_CFG_1SHOT | MAX31865_FAULT_STATUS_CLEAR;\n\tdata->buf[0] = MAX31865_CFG_REG | MAX31865_RD_WR_BIT;\n\tdata->buf[1] = reg;\n\n\tret = max31865_write(data, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data->filter_50hz) {\n\t\t \n\t\tmsleep(63);\n\t} else {\n\t\t \n\t\tmsleep(52);\n\t}\n\n\tret = max31865_read(data, MAX31865_RTD_MSB, 2);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = get_unaligned_be16(&data->buf) >> 1;\n\n\treturn disable_bias(data);\n}\n\nstatic int max31865_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct max31865_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&data->lock);\n\t\tret = max31865_rtd_read(data, val);\n\t\tmutex_unlock(&data->lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*val = 31;\n\t\t*val2 = 250000;  \n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int max31865_init(struct max31865_data *data)\n{\n\tu8 cfg;\n\tint ret;\n\n\tret = max31865_read(data, MAX31865_CFG_REG, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tcfg = data->buf[0];\n\n\tif (data->three_wire)\n\t\t \n\t\tcfg |= MAX31865_3WIRE_RTD;\n\n\tif (data->filter_50hz)\n\t\t \n\t\tcfg |= MAX31865_FILTER_50HZ;\n\n\tdata->buf[0] = MAX31865_CFG_REG | MAX31865_RD_WR_BIT;\n\tdata->buf[1] = cfg;\n\n\treturn max31865_write(data, 2);\n}\n\nstatic ssize_t show_fault(struct device *dev, u8 faultbit, char *buf)\n{\n\tint ret;\n\tbool fault;\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct max31865_data *data = iio_priv(indio_dev);\n\n\tret = max31865_read(data, MAX31865_FAULT_STATUS, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tfault = data->buf[0] & faultbit;\n\n\treturn sysfs_emit(buf, \"%d\\n\", fault);\n}\n\nstatic ssize_t show_fault_ovuv(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn show_fault(dev, MAX31865_FAULT_OVUV, buf);\n}\n\nstatic ssize_t show_filter(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct max31865_data *data = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", data->filter_50hz ? 50 : 60);\n}\n\nstatic ssize_t set_filter(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  const char *buf,\n\t\t\t  size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct max31865_data *data = iio_priv(indio_dev);\n\tunsigned int freq;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &freq);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (freq) {\n\tcase 50:\n\t\tdata->filter_50hz = true;\n\t\tbreak;\n\tcase 60:\n\t\tdata->filter_50hz = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&data->lock);\n\tret = max31865_init(data);\n\tmutex_unlock(&data->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(max31865_show_samp_freq);\nstatic IIO_DEVICE_ATTR(fault_ovuv, 0444, show_fault_ovuv, NULL, 0);\nstatic IIO_DEVICE_ATTR(in_filter_notch_center_frequency, 0644,\n\t\t    show_filter, set_filter, 0);\n\nstatic struct attribute *max31865_attributes[] = {\n\t&iio_dev_attr_fault_ovuv.dev_attr.attr,\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_in_filter_notch_center_frequency.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group max31865_group = {\n\t.attrs = max31865_attributes,\n};\n\nstatic const struct iio_info max31865_info = {\n\t.read_raw = max31865_read_raw,\n\t.attrs = &max31865_group,\n};\n\nstatic int max31865_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tstruct iio_dev *indio_dev;\n\tstruct max31865_data *data;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->spi = spi;\n\tdata->filter_50hz = false;\n\tmutex_init(&data->lock);\n\n\tindio_dev->info = &max31865_info;\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = max31865_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(max31865_channels);\n\n\tif (device_property_read_bool(&spi->dev, \"maxim,3-wire\")) {\n\t\t \n\t\tdata->three_wire = 1;\n\t} else {\n\t\t \n\t\tdata->three_wire = 0;\n\t}\n\n\tret = max31865_init(data);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"error: Failed to configure max31865\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id max31865_id[] = {\n\t{ \"max31865\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, max31865_id);\n\nstatic const struct of_device_id max31865_of_match[] = {\n\t{ .compatible = \"maxim,max31865\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max31865_of_match);\n\nstatic struct spi_driver max31865_driver = {\n\t.driver = {\n\t\t.name\t= \"max31865\",\n\t\t.of_match_table = max31865_of_match,\n\t},\n\t.probe = max31865_probe,\n\t.id_table = max31865_id,\n};\nmodule_spi_driver(max31865_driver);\n\nMODULE_AUTHOR(\"Navin Sankar Velliangiri <navin@linumiz.com>\");\nMODULE_DESCRIPTION(\"Maxim MAX31865 RTD-to-Digital Converter sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}