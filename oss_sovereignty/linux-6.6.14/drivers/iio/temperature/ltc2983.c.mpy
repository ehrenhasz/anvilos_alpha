{
  "module_name": "ltc2983.c",
  "hash_id": "abaa4c1ce81f2417718803595926f0d4b5744d986c5d34b7c66ea933e75af558",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/temperature/ltc2983.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/iio/iio.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n\n \n#define LTC2983_STATUS_REG\t\t\t0x0000\n#define LTC2983_TEMP_RES_START_REG\t\t0x0010\n#define LTC2983_TEMP_RES_END_REG\t\t0x005F\n#define LTC2983_EEPROM_KEY_REG\t\t\t0x00B0\n#define LTC2983_EEPROM_READ_STATUS_REG\t\t0x00D0\n#define LTC2983_GLOBAL_CONFIG_REG\t\t0x00F0\n#define LTC2983_MULT_CHANNEL_START_REG\t\t0x00F4\n#define LTC2983_MULT_CHANNEL_END_REG\t\t0x00F7\n#define LTC2986_EEPROM_STATUS_REG\t\t0x00F9\n#define LTC2983_MUX_CONFIG_REG\t\t\t0x00FF\n#define LTC2983_CHAN_ASSIGN_START_REG\t\t0x0200\n#define LTC2983_CHAN_ASSIGN_END_REG\t\t0x024F\n#define LTC2983_CUST_SENS_TBL_START_REG\t\t0x0250\n#define LTC2983_CUST_SENS_TBL_END_REG\t\t0x03CF\n\n#define LTC2983_DIFFERENTIAL_CHAN_MIN\t\t2\n#define LTC2983_MIN_CHANNELS_NR\t\t\t1\n#define LTC2983_SLEEP\t\t\t\t0x97\n#define LTC2983_CUSTOM_STEINHART_SIZE\t\t24\n#define LTC2983_CUSTOM_SENSOR_ENTRY_SZ\t\t6\n#define LTC2983_CUSTOM_STEINHART_ENTRY_SZ\t4\n\n#define LTC2983_EEPROM_KEY\t\t\t0xA53C0F5A\n#define LTC2983_EEPROM_WRITE_CMD\t\t0x15\n#define LTC2983_EEPROM_READ_CMD\t\t\t0x16\n#define LTC2983_EEPROM_STATUS_FAILURE_MASK\tGENMASK(3, 1)\n#define LTC2983_EEPROM_READ_FAILURE_MASK\tGENMASK(7, 0)\n\n#define LTC2983_EEPROM_WRITE_TIME_MS\t\t2600\n#define LTC2983_EEPROM_READ_TIME_MS\t\t20\n\n#define LTC2983_CHAN_START_ADDR(chan) \\\n\t\t\t(((chan - 1) * 4) + LTC2983_CHAN_ASSIGN_START_REG)\n#define LTC2983_CHAN_RES_ADDR(chan) \\\n\t\t\t(((chan - 1) * 4) + LTC2983_TEMP_RES_START_REG)\n#define LTC2983_THERMOCOUPLE_DIFF_MASK\t\tBIT(3)\n#define LTC2983_THERMOCOUPLE_SGL(x) \\\n\t\t\t\tFIELD_PREP(LTC2983_THERMOCOUPLE_DIFF_MASK, x)\n#define LTC2983_THERMOCOUPLE_OC_CURR_MASK\tGENMASK(1, 0)\n#define LTC2983_THERMOCOUPLE_OC_CURR(x) \\\n\t\t\t\tFIELD_PREP(LTC2983_THERMOCOUPLE_OC_CURR_MASK, x)\n#define LTC2983_THERMOCOUPLE_OC_CHECK_MASK\tBIT(2)\n#define LTC2983_THERMOCOUPLE_OC_CHECK(x) \\\n\t\t\tFIELD_PREP(LTC2983_THERMOCOUPLE_OC_CHECK_MASK, x)\n\n#define LTC2983_THERMISTOR_DIFF_MASK\t\tBIT(2)\n#define LTC2983_THERMISTOR_SGL(x) \\\n\t\t\t\tFIELD_PREP(LTC2983_THERMISTOR_DIFF_MASK, x)\n#define LTC2983_THERMISTOR_R_SHARE_MASK\t\tBIT(1)\n#define LTC2983_THERMISTOR_R_SHARE(x) \\\n\t\t\t\tFIELD_PREP(LTC2983_THERMISTOR_R_SHARE_MASK, x)\n#define LTC2983_THERMISTOR_C_ROTATE_MASK\tBIT(0)\n#define LTC2983_THERMISTOR_C_ROTATE(x) \\\n\t\t\t\tFIELD_PREP(LTC2983_THERMISTOR_C_ROTATE_MASK, x)\n\n#define LTC2983_DIODE_DIFF_MASK\t\t\tBIT(2)\n#define LTC2983_DIODE_SGL(x) \\\n\t\t\tFIELD_PREP(LTC2983_DIODE_DIFF_MASK, x)\n#define LTC2983_DIODE_3_CONV_CYCLE_MASK\t\tBIT(1)\n#define LTC2983_DIODE_3_CONV_CYCLE(x) \\\n\t\t\t\tFIELD_PREP(LTC2983_DIODE_3_CONV_CYCLE_MASK, x)\n#define LTC2983_DIODE_AVERAGE_ON_MASK\t\tBIT(0)\n#define LTC2983_DIODE_AVERAGE_ON(x) \\\n\t\t\t\tFIELD_PREP(LTC2983_DIODE_AVERAGE_ON_MASK, x)\n\n#define LTC2983_RTD_4_WIRE_MASK\t\t\tBIT(3)\n#define LTC2983_RTD_ROTATION_MASK\t\tBIT(1)\n#define LTC2983_RTD_C_ROTATE(x) \\\n\t\t\tFIELD_PREP(LTC2983_RTD_ROTATION_MASK, x)\n#define LTC2983_RTD_KELVIN_R_SENSE_MASK\t\tGENMASK(3, 2)\n#define LTC2983_RTD_N_WIRES_MASK\t\tGENMASK(3, 2)\n#define LTC2983_RTD_N_WIRES(x) \\\n\t\t\tFIELD_PREP(LTC2983_RTD_N_WIRES_MASK, x)\n#define LTC2983_RTD_R_SHARE_MASK\t\tBIT(0)\n#define LTC2983_RTD_R_SHARE(x) \\\n\t\t\tFIELD_PREP(LTC2983_RTD_R_SHARE_MASK, 1)\n\n#define LTC2983_COMMON_HARD_FAULT_MASK\tGENMASK(31, 30)\n#define LTC2983_COMMON_SOFT_FAULT_MASK\tGENMASK(27, 25)\n\n#define\tLTC2983_STATUS_START_MASK\tBIT(7)\n#define\tLTC2983_STATUS_START(x)\t\tFIELD_PREP(LTC2983_STATUS_START_MASK, x)\n#define\tLTC2983_STATUS_UP_MASK\t\tGENMASK(7, 6)\n#define\tLTC2983_STATUS_UP(reg)\t\tFIELD_GET(LTC2983_STATUS_UP_MASK, reg)\n\n#define\tLTC2983_STATUS_CHAN_SEL_MASK\tGENMASK(4, 0)\n#define\tLTC2983_STATUS_CHAN_SEL(x) \\\n\t\t\t\tFIELD_PREP(LTC2983_STATUS_CHAN_SEL_MASK, x)\n\n#define LTC2983_TEMP_UNITS_MASK\t\tBIT(2)\n#define LTC2983_TEMP_UNITS(x)\t\tFIELD_PREP(LTC2983_TEMP_UNITS_MASK, x)\n\n#define LTC2983_NOTCH_FREQ_MASK\t\tGENMASK(1, 0)\n#define LTC2983_NOTCH_FREQ(x)\t\tFIELD_PREP(LTC2983_NOTCH_FREQ_MASK, x)\n\n#define LTC2983_RES_VALID_MASK\t\tBIT(24)\n#define LTC2983_DATA_MASK\t\tGENMASK(23, 0)\n#define LTC2983_DATA_SIGN_BIT\t\t23\n\n#define LTC2983_CHAN_TYPE_MASK\t\tGENMASK(31, 27)\n#define LTC2983_CHAN_TYPE(x)\t\tFIELD_PREP(LTC2983_CHAN_TYPE_MASK, x)\n\n \n#define LTC2983_CHAN_ASSIGN_MASK\tGENMASK(26, 22)\n#define LTC2983_CHAN_ASSIGN(x)\t\tFIELD_PREP(LTC2983_CHAN_ASSIGN_MASK, x)\n\n#define LTC2983_CUSTOM_LEN_MASK\t\tGENMASK(5, 0)\n#define LTC2983_CUSTOM_LEN(x)\t\tFIELD_PREP(LTC2983_CUSTOM_LEN_MASK, x)\n\n#define LTC2983_CUSTOM_ADDR_MASK\tGENMASK(11, 6)\n#define LTC2983_CUSTOM_ADDR(x)\t\tFIELD_PREP(LTC2983_CUSTOM_ADDR_MASK, x)\n\n#define LTC2983_THERMOCOUPLE_CFG_MASK\tGENMASK(21, 18)\n#define LTC2983_THERMOCOUPLE_CFG(x) \\\n\t\t\t\tFIELD_PREP(LTC2983_THERMOCOUPLE_CFG_MASK, x)\n#define LTC2983_THERMOCOUPLE_HARD_FAULT_MASK\tGENMASK(31, 29)\n#define LTC2983_THERMOCOUPLE_SOFT_FAULT_MASK\tGENMASK(28, 25)\n\n#define LTC2983_RTD_CFG_MASK\t\tGENMASK(21, 18)\n#define LTC2983_RTD_CFG(x)\t\tFIELD_PREP(LTC2983_RTD_CFG_MASK, x)\n#define LTC2983_RTD_EXC_CURRENT_MASK\tGENMASK(17, 14)\n#define LTC2983_RTD_EXC_CURRENT(x) \\\n\t\t\t\tFIELD_PREP(LTC2983_RTD_EXC_CURRENT_MASK, x)\n#define LTC2983_RTD_CURVE_MASK\t\tGENMASK(13, 12)\n#define LTC2983_RTD_CURVE(x)\t\tFIELD_PREP(LTC2983_RTD_CURVE_MASK, x)\n\n#define LTC2983_THERMISTOR_CFG_MASK\tGENMASK(21, 19)\n#define LTC2983_THERMISTOR_CFG(x) \\\n\t\t\t\tFIELD_PREP(LTC2983_THERMISTOR_CFG_MASK, x)\n#define LTC2983_THERMISTOR_EXC_CURRENT_MASK\tGENMASK(18, 15)\n#define LTC2983_THERMISTOR_EXC_CURRENT(x) \\\n\t\t\tFIELD_PREP(LTC2983_THERMISTOR_EXC_CURRENT_MASK, x)\n\n#define LTC2983_DIODE_CFG_MASK\t\tGENMASK(26, 24)\n#define LTC2983_DIODE_CFG(x)\t\tFIELD_PREP(LTC2983_DIODE_CFG_MASK, x)\n#define LTC2983_DIODE_EXC_CURRENT_MASK\tGENMASK(23, 22)\n#define LTC2983_DIODE_EXC_CURRENT(x) \\\n\t\t\t\tFIELD_PREP(LTC2983_DIODE_EXC_CURRENT_MASK, x)\n#define LTC2983_DIODE_IDEAL_FACTOR_MASK\tGENMASK(21, 0)\n#define LTC2983_DIODE_IDEAL_FACTOR(x) \\\n\t\t\t\tFIELD_PREP(LTC2983_DIODE_IDEAL_FACTOR_MASK, x)\n\n#define LTC2983_R_SENSE_VAL_MASK\tGENMASK(26, 0)\n#define LTC2983_R_SENSE_VAL(x)\t\tFIELD_PREP(LTC2983_R_SENSE_VAL_MASK, x)\n\n#define LTC2983_ADC_SINGLE_ENDED_MASK\tBIT(26)\n#define LTC2983_ADC_SINGLE_ENDED(x) \\\n\t\t\t\tFIELD_PREP(LTC2983_ADC_SINGLE_ENDED_MASK, x)\n\nenum {\n\tLTC2983_SENSOR_THERMOCOUPLE = 1,\n\tLTC2983_SENSOR_THERMOCOUPLE_CUSTOM = 9,\n\tLTC2983_SENSOR_RTD = 10,\n\tLTC2983_SENSOR_RTD_CUSTOM = 18,\n\tLTC2983_SENSOR_THERMISTOR = 19,\n\tLTC2983_SENSOR_THERMISTOR_STEINHART = 26,\n\tLTC2983_SENSOR_THERMISTOR_CUSTOM = 27,\n\tLTC2983_SENSOR_DIODE = 28,\n\tLTC2983_SENSOR_SENSE_RESISTOR = 29,\n\tLTC2983_SENSOR_DIRECT_ADC = 30,\n\tLTC2983_SENSOR_ACTIVE_TEMP = 31,\n};\n\n#define to_thermocouple(_sensor) \\\n\t\tcontainer_of(_sensor, struct ltc2983_thermocouple, sensor)\n\n#define to_rtd(_sensor) \\\n\t\tcontainer_of(_sensor, struct ltc2983_rtd, sensor)\n\n#define to_thermistor(_sensor) \\\n\t\tcontainer_of(_sensor, struct ltc2983_thermistor, sensor)\n\n#define to_diode(_sensor) \\\n\t\tcontainer_of(_sensor, struct ltc2983_diode, sensor)\n\n#define to_rsense(_sensor) \\\n\t\tcontainer_of(_sensor, struct ltc2983_rsense, sensor)\n\n#define to_adc(_sensor) \\\n\t\tcontainer_of(_sensor, struct ltc2983_adc, sensor)\n\n#define to_temp(_sensor) \\\n\t\tcontainer_of(_sensor, struct ltc2983_temp, sensor)\n\nstruct ltc2983_chip_info {\n\tunsigned int max_channels_nr;\n\tbool has_temp;\n\tbool has_eeprom;\n};\n\nstruct ltc2983_data {\n\tconst struct ltc2983_chip_info *info;\n\tstruct regmap *regmap;\n\tstruct spi_device *spi;\n\tstruct mutex lock;\n\tstruct completion completion;\n\tstruct iio_chan_spec *iio_chan;\n\tstruct ltc2983_sensor **sensors;\n\tu32 mux_delay_config;\n\tu32 filter_notch_freq;\n\tu16 custom_table_size;\n\tu8 num_channels;\n\tu8 iio_channels;\n\t \n\t__be32 temp __aligned(IIO_DMA_MINALIGN);\n\t__be32 chan_val;\n\t__be32 eeprom_key;\n};\n\nstruct ltc2983_sensor {\n\tint (*fault_handler)(const struct ltc2983_data *st, const u32 result);\n\tint (*assign_chan)(struct ltc2983_data *st,\n\t\t\t   const struct ltc2983_sensor *sensor);\n\t \n\tu32 chan;\n\t \n\tu32 type;\n};\n\nstruct ltc2983_custom_sensor {\n\t \n\tvoid *table;\n\tsize_t size;\n\t \n\ts8 offset;\n\tbool is_steinhart;\n};\n\nstruct ltc2983_thermocouple {\n\tstruct ltc2983_sensor sensor;\n\tstruct ltc2983_custom_sensor *custom;\n\tu32 sensor_config;\n\tu32 cold_junction_chan;\n};\n\nstruct ltc2983_rtd {\n\tstruct ltc2983_sensor sensor;\n\tstruct ltc2983_custom_sensor *custom;\n\tu32 sensor_config;\n\tu32 r_sense_chan;\n\tu32 excitation_current;\n\tu32 rtd_curve;\n};\n\nstruct ltc2983_thermistor {\n\tstruct ltc2983_sensor sensor;\n\tstruct ltc2983_custom_sensor *custom;\n\tu32 sensor_config;\n\tu32 r_sense_chan;\n\tu32 excitation_current;\n};\n\nstruct ltc2983_diode {\n\tstruct ltc2983_sensor sensor;\n\tu32 sensor_config;\n\tu32 excitation_current;\n\tu32 ideal_factor_value;\n};\n\nstruct ltc2983_rsense {\n\tstruct ltc2983_sensor sensor;\n\tu32 r_sense_val;\n};\n\nstruct ltc2983_adc {\n\tstruct ltc2983_sensor sensor;\n\tbool single_ended;\n};\n\nstruct ltc2983_temp {\n\tstruct ltc2983_sensor sensor;\n\tstruct ltc2983_custom_sensor *custom;\n\tbool single_ended;\n};\n\n \nstatic u32 __convert_to_raw(const u64 val, const u32 resolution)\n{\n\tu64 __res = val * resolution;\n\n\t \n\tdo_div(__res, 1000000);\n\n\treturn __res;\n}\n\nstatic u32 __convert_to_raw_sign(const u64 val, const u32 resolution)\n{\n\ts64 __res = -(s32)val;\n\n\t__res = __convert_to_raw(__res, resolution);\n\n\treturn (u32)-__res;\n}\n\nstatic int __ltc2983_fault_handler(const struct ltc2983_data *st,\n\t\t\t\t   const u32 result, const u32 hard_mask,\n\t\t\t\t   const u32 soft_mask)\n{\n\tconst struct device *dev = &st->spi->dev;\n\n\tif (result & hard_mask) {\n\t\tdev_err(dev, \"Invalid conversion: Sensor HARD fault\\n\");\n\t\treturn -EIO;\n\t} else if (result & soft_mask) {\n\t\t \n\t\tdev_warn(dev, \"Suspicious conversion: Sensor SOFT fault\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int __ltc2983_chan_assign_common(struct ltc2983_data *st,\n\t\t\t\t\tconst struct ltc2983_sensor *sensor,\n\t\t\t\t\tu32 chan_val)\n{\n\tu32 reg = LTC2983_CHAN_START_ADDR(sensor->chan);\n\n\tchan_val |= LTC2983_CHAN_TYPE(sensor->type);\n\tdev_dbg(&st->spi->dev, \"Assign reg:0x%04X, val:0x%08X\\n\", reg,\n\t\tchan_val);\n\tst->chan_val = cpu_to_be32(chan_val);\n\treturn regmap_bulk_write(st->regmap, reg, &st->chan_val,\n\t\t\t\t sizeof(st->chan_val));\n}\n\nstatic int __ltc2983_chan_custom_sensor_assign(struct ltc2983_data *st,\n\t\t\t\t\t  struct ltc2983_custom_sensor *custom,\n\t\t\t\t\t  u32 *chan_val)\n{\n\tu32 reg;\n\tu8 mult = custom->is_steinhart ? LTC2983_CUSTOM_STEINHART_ENTRY_SZ :\n\t\tLTC2983_CUSTOM_SENSOR_ENTRY_SZ;\n\tconst struct device *dev = &st->spi->dev;\n\t \n\tconst u8 len = custom->is_steinhart ? 0 :\n\t\t(custom->size / LTC2983_CUSTOM_SENSOR_ENTRY_SZ) - 1;\n\t \n\tif (custom->offset < 0) {\n\t\t \n\t\tif (st->custom_table_size + custom->size >\n\t\t    (LTC2983_CUST_SENS_TBL_END_REG -\n\t\t     LTC2983_CUST_SENS_TBL_START_REG) + 1) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Not space left(%d) for new custom sensor(%zu)\",\n\t\t\t\tst->custom_table_size,\n\t\t\t\tcustom->size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcustom->offset = st->custom_table_size /\n\t\t\t\t\tLTC2983_CUSTOM_SENSOR_ENTRY_SZ;\n\t\tst->custom_table_size += custom->size;\n\t}\n\n\treg = (custom->offset * mult) + LTC2983_CUST_SENS_TBL_START_REG;\n\n\t*chan_val |= LTC2983_CUSTOM_LEN(len);\n\t*chan_val |= LTC2983_CUSTOM_ADDR(custom->offset);\n\tdev_dbg(dev, \"Assign custom sensor, reg:0x%04X, off:%d, sz:%zu\",\n\t\treg, custom->offset,\n\t\tcustom->size);\n\t \n\treturn regmap_bulk_write(st->regmap, reg, custom->table, custom->size);\n}\n\nstatic struct ltc2983_custom_sensor *\n__ltc2983_custom_sensor_new(struct ltc2983_data *st, const struct fwnode_handle *fn,\n\t\t\t    const char *propname, const bool is_steinhart,\n\t\t\t    const u32 resolution, const bool has_signed)\n{\n\tstruct ltc2983_custom_sensor *new_custom;\n\tstruct device *dev = &st->spi->dev;\n\t \n\tconst u8 n_size = is_steinhart ? 4 : 3;\n\tu8 index, n_entries;\n\tint ret;\n\n\tif (is_steinhart)\n\t\tn_entries = fwnode_property_count_u32(fn, propname);\n\telse\n\t\tn_entries = fwnode_property_count_u64(fn, propname);\n\t \n\tif (!n_entries || (n_entries % 2) != 0) {\n\t\tdev_err(dev, \"Number of entries either 0 or not even\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tnew_custom = devm_kzalloc(dev, sizeof(*new_custom), GFP_KERNEL);\n\tif (!new_custom)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_custom->size = n_entries * n_size;\n\t \n\tif (is_steinhart && new_custom->size != LTC2983_CUSTOM_STEINHART_SIZE) {\n\t\tdev_err(dev, \"Steinhart sensors size(%zu) must be %u\\n\", new_custom->size,\n\t\t\tLTC2983_CUSTOM_STEINHART_SIZE);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\t \n\tif (st->custom_table_size + new_custom->size >\n\t    (LTC2983_CUST_SENS_TBL_END_REG -\n\t     LTC2983_CUST_SENS_TBL_START_REG) + 1) {\n\t\tdev_err(dev, \"No space left(%d) for new custom sensor(%zu)\",\n\t\t\t\tst->custom_table_size, new_custom->size);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tif (is_steinhart)\n\t\tnew_custom->table = devm_kcalloc(dev, n_entries, sizeof(u32), GFP_KERNEL);\n\telse\n\t\tnew_custom->table = devm_kcalloc(dev, n_entries, sizeof(u64), GFP_KERNEL);\n\tif (!new_custom->table)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tif (is_steinhart) {\n\t\tret = fwnode_property_read_u32_array(fn, propname, new_custom->table, n_entries);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\n\t\tcpu_to_be32_array(new_custom->table, new_custom->table, n_entries);\n\t} else {\n\t\tret = fwnode_property_read_u64_array(fn, propname, new_custom->table, n_entries);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\n\t\tfor (index = 0; index < n_entries; index++) {\n\t\t\tu64 temp = ((u64 *)new_custom->table)[index];\n\n\t\t\tif ((index % 2) != 0)\n\t\t\t\ttemp = __convert_to_raw(temp, 1024);\n\t\t\telse if (has_signed && (s64)temp < 0)\n\t\t\t\ttemp = __convert_to_raw_sign(temp, resolution);\n\t\t\telse\n\t\t\t\ttemp = __convert_to_raw(temp, resolution);\n\n\t\t\tput_unaligned_be24(temp, new_custom->table + index * 3);\n\t\t}\n\t}\n\n\tnew_custom->is_steinhart = is_steinhart;\n\t \n\tif (is_steinhart) {\n\t\tnew_custom->offset = st->custom_table_size /\n\t\t\t\t\tLTC2983_CUSTOM_STEINHART_ENTRY_SZ;\n\t\tst->custom_table_size += new_custom->size;\n\t} else {\n\t\t \n\t\tnew_custom->offset = -1;\n\t}\n\n\treturn new_custom;\n}\n\nstatic int ltc2983_thermocouple_fault_handler(const struct ltc2983_data *st,\n\t\t\t\t\t      const u32 result)\n{\n\treturn __ltc2983_fault_handler(st, result,\n\t\t\t\t       LTC2983_THERMOCOUPLE_HARD_FAULT_MASK,\n\t\t\t\t       LTC2983_THERMOCOUPLE_SOFT_FAULT_MASK);\n}\n\nstatic int ltc2983_common_fault_handler(const struct ltc2983_data *st,\n\t\t\t\t\tconst u32 result)\n{\n\treturn __ltc2983_fault_handler(st, result,\n\t\t\t\t       LTC2983_COMMON_HARD_FAULT_MASK,\n\t\t\t\t       LTC2983_COMMON_SOFT_FAULT_MASK);\n}\n\nstatic int ltc2983_thermocouple_assign_chan(struct ltc2983_data *st,\n\t\t\t\tconst struct ltc2983_sensor *sensor)\n{\n\tstruct ltc2983_thermocouple *thermo = to_thermocouple(sensor);\n\tu32 chan_val;\n\n\tchan_val = LTC2983_CHAN_ASSIGN(thermo->cold_junction_chan);\n\tchan_val |= LTC2983_THERMOCOUPLE_CFG(thermo->sensor_config);\n\n\tif (thermo->custom) {\n\t\tint ret;\n\n\t\tret = __ltc2983_chan_custom_sensor_assign(st, thermo->custom,\n\t\t\t\t\t\t\t  &chan_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn __ltc2983_chan_assign_common(st, sensor, chan_val);\n}\n\nstatic int ltc2983_rtd_assign_chan(struct ltc2983_data *st,\n\t\t\t\t   const struct ltc2983_sensor *sensor)\n{\n\tstruct ltc2983_rtd *rtd = to_rtd(sensor);\n\tu32 chan_val;\n\n\tchan_val = LTC2983_CHAN_ASSIGN(rtd->r_sense_chan);\n\tchan_val |= LTC2983_RTD_CFG(rtd->sensor_config);\n\tchan_val |= LTC2983_RTD_EXC_CURRENT(rtd->excitation_current);\n\tchan_val |= LTC2983_RTD_CURVE(rtd->rtd_curve);\n\n\tif (rtd->custom) {\n\t\tint ret;\n\n\t\tret = __ltc2983_chan_custom_sensor_assign(st, rtd->custom,\n\t\t\t\t\t\t\t  &chan_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn __ltc2983_chan_assign_common(st, sensor, chan_val);\n}\n\nstatic int ltc2983_thermistor_assign_chan(struct ltc2983_data *st,\n\t\t\t\t\t  const struct ltc2983_sensor *sensor)\n{\n\tstruct ltc2983_thermistor *thermistor = to_thermistor(sensor);\n\tu32 chan_val;\n\n\tchan_val = LTC2983_CHAN_ASSIGN(thermistor->r_sense_chan);\n\tchan_val |= LTC2983_THERMISTOR_CFG(thermistor->sensor_config);\n\tchan_val |=\n\t\tLTC2983_THERMISTOR_EXC_CURRENT(thermistor->excitation_current);\n\n\tif (thermistor->custom) {\n\t\tint ret;\n\n\t\tret = __ltc2983_chan_custom_sensor_assign(st,\n\t\t\t\t\t\t\t  thermistor->custom,\n\t\t\t\t\t\t\t  &chan_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn __ltc2983_chan_assign_common(st, sensor, chan_val);\n}\n\nstatic int ltc2983_diode_assign_chan(struct ltc2983_data *st,\n\t\t\t\t     const struct ltc2983_sensor *sensor)\n{\n\tstruct ltc2983_diode *diode = to_diode(sensor);\n\tu32 chan_val;\n\n\tchan_val = LTC2983_DIODE_CFG(diode->sensor_config);\n\tchan_val |= LTC2983_DIODE_EXC_CURRENT(diode->excitation_current);\n\tchan_val |= LTC2983_DIODE_IDEAL_FACTOR(diode->ideal_factor_value);\n\n\treturn __ltc2983_chan_assign_common(st, sensor, chan_val);\n}\n\nstatic int ltc2983_r_sense_assign_chan(struct ltc2983_data *st,\n\t\t\t\t       const struct ltc2983_sensor *sensor)\n{\n\tstruct ltc2983_rsense *rsense = to_rsense(sensor);\n\tu32 chan_val;\n\n\tchan_val = LTC2983_R_SENSE_VAL(rsense->r_sense_val);\n\n\treturn __ltc2983_chan_assign_common(st, sensor, chan_val);\n}\n\nstatic int ltc2983_adc_assign_chan(struct ltc2983_data *st,\n\t\t\t\t   const struct ltc2983_sensor *sensor)\n{\n\tstruct ltc2983_adc *adc = to_adc(sensor);\n\tu32 chan_val;\n\n\tchan_val = LTC2983_ADC_SINGLE_ENDED(adc->single_ended);\n\n\treturn __ltc2983_chan_assign_common(st, sensor, chan_val);\n}\n\nstatic int ltc2983_temp_assign_chan(struct ltc2983_data *st,\n\t\t\t\t    const struct ltc2983_sensor *sensor)\n{\n\tstruct ltc2983_temp *temp = to_temp(sensor);\n\tu32 chan_val;\n\tint ret;\n\n\tchan_val = LTC2983_ADC_SINGLE_ENDED(temp->single_ended);\n\n\tret = __ltc2983_chan_custom_sensor_assign(st, temp->custom, &chan_val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __ltc2983_chan_assign_common(st, sensor, chan_val);\n}\n\nstatic struct ltc2983_sensor *\nltc2983_thermocouple_new(const struct fwnode_handle *child, struct ltc2983_data *st,\n\t\t\t const struct ltc2983_sensor *sensor)\n{\n\tstruct ltc2983_thermocouple *thermo;\n\tstruct fwnode_handle *ref;\n\tu32 oc_current;\n\tint ret;\n\n\tthermo = devm_kzalloc(&st->spi->dev, sizeof(*thermo), GFP_KERNEL);\n\tif (!thermo)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (fwnode_property_read_bool(child, \"adi,single-ended\"))\n\t\tthermo->sensor_config = LTC2983_THERMOCOUPLE_SGL(1);\n\n\tret = fwnode_property_read_u32(child, \"adi,sensor-oc-current-microamp\", &oc_current);\n\tif (!ret) {\n\t\tswitch (oc_current) {\n\t\tcase 10:\n\t\t\tthermo->sensor_config |=\n\t\t\t\t\tLTC2983_THERMOCOUPLE_OC_CURR(0);\n\t\t\tbreak;\n\t\tcase 100:\n\t\t\tthermo->sensor_config |=\n\t\t\t\t\tLTC2983_THERMOCOUPLE_OC_CURR(1);\n\t\t\tbreak;\n\t\tcase 500:\n\t\t\tthermo->sensor_config |=\n\t\t\t\t\tLTC2983_THERMOCOUPLE_OC_CURR(2);\n\t\t\tbreak;\n\t\tcase 1000:\n\t\t\tthermo->sensor_config |=\n\t\t\t\t\tLTC2983_THERMOCOUPLE_OC_CURR(3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&st->spi->dev,\n\t\t\t\t\"Invalid open circuit current:%u\", oc_current);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tthermo->sensor_config |= LTC2983_THERMOCOUPLE_OC_CHECK(1);\n\t}\n\t \n\tif (!(thermo->sensor_config & LTC2983_THERMOCOUPLE_DIFF_MASK) &&\n\t    sensor->chan < LTC2983_DIFFERENTIAL_CHAN_MIN) {\n\t\tdev_err(&st->spi->dev,\n\t\t\t\"Invalid chann:%d for differential thermocouple\",\n\t\t\tsensor->chan);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tref = fwnode_find_reference(child, \"adi,cold-junction-handle\", 0);\n\tif (IS_ERR(ref)) {\n\t\tref = NULL;\n\t} else {\n\t\tret = fwnode_property_read_u32(ref, \"reg\", &thermo->cold_junction_chan);\n\t\tif (ret) {\n\t\t\t \n\t\t\tdev_err(&st->spi->dev, \"Property reg must be given\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tif (sensor->type == LTC2983_SENSOR_THERMOCOUPLE_CUSTOM) {\n\t\tconst char *propname = \"adi,custom-thermocouple\";\n\n\t\tthermo->custom = __ltc2983_custom_sensor_new(st, child,\n\t\t\t\t\t\t\t     propname, false,\n\t\t\t\t\t\t\t     16384, true);\n\t\tif (IS_ERR(thermo->custom)) {\n\t\t\tret = PTR_ERR(thermo->custom);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tthermo->sensor.fault_handler = ltc2983_thermocouple_fault_handler;\n\tthermo->sensor.assign_chan = ltc2983_thermocouple_assign_chan;\n\n\tfwnode_handle_put(ref);\n\treturn &thermo->sensor;\n\nfail:\n\tfwnode_handle_put(ref);\n\treturn ERR_PTR(ret);\n}\n\nstatic struct ltc2983_sensor *\nltc2983_rtd_new(const struct fwnode_handle *child, struct ltc2983_data *st,\n\t\tconst struct ltc2983_sensor *sensor)\n{\n\tstruct ltc2983_rtd *rtd;\n\tint ret = 0;\n\tstruct device *dev = &st->spi->dev;\n\tstruct fwnode_handle *ref;\n\tu32 excitation_current = 0, n_wires = 0;\n\n\trtd = devm_kzalloc(dev, sizeof(*rtd), GFP_KERNEL);\n\tif (!rtd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tref = fwnode_find_reference(child, \"adi,rsense-handle\", 0);\n\tif (IS_ERR(ref)) {\n\t\tdev_err(dev, \"Property adi,rsense-handle missing or invalid\");\n\t\treturn ERR_CAST(ref);\n\t}\n\n\tret = fwnode_property_read_u32(ref, \"reg\", &rtd->r_sense_chan);\n\tif (ret) {\n\t\tdev_err(dev, \"Property reg must be given\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = fwnode_property_read_u32(child, \"adi,number-of-wires\", &n_wires);\n\tif (!ret) {\n\t\tswitch (n_wires) {\n\t\tcase 2:\n\t\t\trtd->sensor_config = LTC2983_RTD_N_WIRES(0);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\trtd->sensor_config = LTC2983_RTD_N_WIRES(1);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\trtd->sensor_config = LTC2983_RTD_N_WIRES(2);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t \n\t\t\trtd->sensor_config = LTC2983_RTD_N_WIRES(3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Invalid number of wires:%u\\n\", n_wires);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (fwnode_property_read_bool(child, \"adi,rsense-share\")) {\n\t\t \n\t\tif (fwnode_property_read_bool(child, \"adi,current-rotate\")) {\n\t\t\tif (n_wires == 2 || n_wires == 3) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Rotation not allowed for 2/3 Wire RTDs\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trtd->sensor_config |= LTC2983_RTD_C_ROTATE(1);\n\t\t} else {\n\t\t\trtd->sensor_config |= LTC2983_RTD_R_SHARE(1);\n\t\t}\n\t}\n\t \n\tif (rtd->sensor_config & LTC2983_RTD_4_WIRE_MASK) {\n\t\t \n\t\tu8 min = LTC2983_DIFFERENTIAL_CHAN_MIN,\n\t\t\tmax = st->info->max_channels_nr;\n\n\t\tif (rtd->sensor_config & LTC2983_RTD_ROTATION_MASK)\n\t\t\tmax = st->info->max_channels_nr - 1;\n\n\t\tif (((rtd->sensor_config & LTC2983_RTD_KELVIN_R_SENSE_MASK)\n\t\t     == LTC2983_RTD_KELVIN_R_SENSE_MASK) &&\n\t\t    (rtd->r_sense_chan <=  min)) {\n\t\t\t \n\t\t\tdev_err(dev,\n\t\t\t\t\"Invalid rsense chann:%d to use in kelvin rsense\",\n\t\t\t\trtd->r_sense_chan);\n\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (sensor->chan < min || sensor->chan > max) {\n\t\t\tdev_err(dev, \"Invalid chann:%d for the rtd config\",\n\t\t\t\tsensor->chan);\n\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\t \n\t\tif (sensor->chan < LTC2983_DIFFERENTIAL_CHAN_MIN) {\n\t\t\tdev_err(&st->spi->dev,\n\t\t\t\t\"Invalid chann:%d for RTD\", sensor->chan);\n\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tif (sensor->type == LTC2983_SENSOR_RTD_CUSTOM) {\n\t\trtd->custom = __ltc2983_custom_sensor_new(st, child,\n\t\t\t\t\t\t\t  \"adi,custom-rtd\",\n\t\t\t\t\t\t\t  false, 2048, false);\n\t\tif (IS_ERR(rtd->custom)) {\n\t\t\tret = PTR_ERR(rtd->custom);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\trtd->sensor.fault_handler = ltc2983_common_fault_handler;\n\trtd->sensor.assign_chan = ltc2983_rtd_assign_chan;\n\n\tret = fwnode_property_read_u32(child, \"adi,excitation-current-microamp\",\n\t\t\t\t       &excitation_current);\n\tif (ret) {\n\t\t \n\t\trtd->excitation_current = 1;\n\t} else {\n\t\tswitch (excitation_current) {\n\t\tcase 5:\n\t\t\trtd->excitation_current = 0x01;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\trtd->excitation_current = 0x02;\n\t\t\tbreak;\n\t\tcase 25:\n\t\t\trtd->excitation_current = 0x03;\n\t\t\tbreak;\n\t\tcase 50:\n\t\t\trtd->excitation_current = 0x04;\n\t\t\tbreak;\n\t\tcase 100:\n\t\t\trtd->excitation_current = 0x05;\n\t\t\tbreak;\n\t\tcase 250:\n\t\t\trtd->excitation_current = 0x06;\n\t\t\tbreak;\n\t\tcase 500:\n\t\t\trtd->excitation_current = 0x07;\n\t\t\tbreak;\n\t\tcase 1000:\n\t\t\trtd->excitation_current = 0x08;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&st->spi->dev,\n\t\t\t\t\"Invalid value for excitation current(%u)\",\n\t\t\t\texcitation_current);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfwnode_property_read_u32(child, \"adi,rtd-curve\", &rtd->rtd_curve);\n\n\tfwnode_handle_put(ref);\n\treturn &rtd->sensor;\nfail:\n\tfwnode_handle_put(ref);\n\treturn ERR_PTR(ret);\n}\n\nstatic struct ltc2983_sensor *\nltc2983_thermistor_new(const struct fwnode_handle *child, struct ltc2983_data *st,\n\t\t       const struct ltc2983_sensor *sensor)\n{\n\tstruct ltc2983_thermistor *thermistor;\n\tstruct device *dev = &st->spi->dev;\n\tstruct fwnode_handle *ref;\n\tu32 excitation_current = 0;\n\tint ret = 0;\n\n\tthermistor = devm_kzalloc(dev, sizeof(*thermistor), GFP_KERNEL);\n\tif (!thermistor)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tref = fwnode_find_reference(child, \"adi,rsense-handle\", 0);\n\tif (IS_ERR(ref)) {\n\t\tdev_err(dev, \"Property adi,rsense-handle missing or invalid\");\n\t\treturn ERR_CAST(ref);\n\t}\n\n\tret = fwnode_property_read_u32(ref, \"reg\", &thermistor->r_sense_chan);\n\tif (ret) {\n\t\tdev_err(dev, \"rsense channel must be configured...\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (fwnode_property_read_bool(child, \"adi,single-ended\")) {\n\t\tthermistor->sensor_config = LTC2983_THERMISTOR_SGL(1);\n\t} else if (fwnode_property_read_bool(child, \"adi,rsense-share\")) {\n\t\t \n\t\tif (fwnode_property_read_bool(child, \"adi,current-rotate\"))\n\t\t\tthermistor->sensor_config =\n\t\t\t\t\t\tLTC2983_THERMISTOR_C_ROTATE(1);\n\t\telse\n\t\t\tthermistor->sensor_config =\n\t\t\t\t\t\tLTC2983_THERMISTOR_R_SHARE(1);\n\t}\n\t \n\tif (!(thermistor->sensor_config & LTC2983_THERMISTOR_DIFF_MASK) &&\n\t    sensor->chan < LTC2983_DIFFERENTIAL_CHAN_MIN) {\n\t\tdev_err(&st->spi->dev,\n\t\t\t\"Invalid chann:%d for differential thermistor\",\n\t\t\tsensor->chan);\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (sensor->type >= LTC2983_SENSOR_THERMISTOR_STEINHART) {\n\t\tbool steinhart = false;\n\t\tconst char *propname;\n\n\t\tif (sensor->type == LTC2983_SENSOR_THERMISTOR_STEINHART) {\n\t\t\tsteinhart = true;\n\t\t\tpropname = \"adi,custom-steinhart\";\n\t\t} else {\n\t\t\tpropname = \"adi,custom-thermistor\";\n\t\t}\n\n\t\tthermistor->custom = __ltc2983_custom_sensor_new(st, child,\n\t\t\t\t\t\t\t\t propname,\n\t\t\t\t\t\t\t\t steinhart,\n\t\t\t\t\t\t\t\t 64, false);\n\t\tif (IS_ERR(thermistor->custom)) {\n\t\t\tret = PTR_ERR(thermistor->custom);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t \n\tthermistor->sensor.fault_handler = ltc2983_common_fault_handler;\n\tthermistor->sensor.assign_chan = ltc2983_thermistor_assign_chan;\n\n\tret = fwnode_property_read_u32(child, \"adi,excitation-current-nanoamp\",\n\t\t\t\t       &excitation_current);\n\tif (ret) {\n\t\t \n\t\tif (sensor->type >= LTC2983_SENSOR_THERMISTOR_STEINHART)\n\t\t\t \n\t\t\tthermistor->excitation_current = 0x03;\n\t\telse\n\t\t\t \n\t\t\tthermistor->excitation_current = 0x0c;\n\t} else {\n\t\tswitch (excitation_current) {\n\t\tcase 0:\n\t\t\t \n\t\t\tif (sensor->type >=\n\t\t\t    LTC2983_SENSOR_THERMISTOR_STEINHART) {\n\t\t\t\tdev_err(&st->spi->dev,\n\t\t\t\t\t\"Auto Range not allowed for custom sensors\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tthermistor->excitation_current = 0x0c;\n\t\t\tbreak;\n\t\tcase 250:\n\t\t\tthermistor->excitation_current = 0x01;\n\t\t\tbreak;\n\t\tcase 500:\n\t\t\tthermistor->excitation_current = 0x02;\n\t\t\tbreak;\n\t\tcase 1000:\n\t\t\tthermistor->excitation_current = 0x03;\n\t\t\tbreak;\n\t\tcase 5000:\n\t\t\tthermistor->excitation_current = 0x04;\n\t\t\tbreak;\n\t\tcase 10000:\n\t\t\tthermistor->excitation_current = 0x05;\n\t\t\tbreak;\n\t\tcase 25000:\n\t\t\tthermistor->excitation_current = 0x06;\n\t\t\tbreak;\n\t\tcase 50000:\n\t\t\tthermistor->excitation_current = 0x07;\n\t\t\tbreak;\n\t\tcase 100000:\n\t\t\tthermistor->excitation_current = 0x08;\n\t\t\tbreak;\n\t\tcase 250000:\n\t\t\tthermistor->excitation_current = 0x09;\n\t\t\tbreak;\n\t\tcase 500000:\n\t\t\tthermistor->excitation_current = 0x0a;\n\t\t\tbreak;\n\t\tcase 1000000:\n\t\t\tthermistor->excitation_current = 0x0b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&st->spi->dev,\n\t\t\t\t\"Invalid value for excitation current(%u)\",\n\t\t\t\texcitation_current);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfwnode_handle_put(ref);\n\treturn &thermistor->sensor;\nfail:\n\tfwnode_handle_put(ref);\n\treturn ERR_PTR(ret);\n}\n\nstatic struct ltc2983_sensor *\nltc2983_diode_new(const struct fwnode_handle *child, const struct ltc2983_data *st,\n\t\t  const struct ltc2983_sensor *sensor)\n{\n\tstruct ltc2983_diode *diode;\n\tu32 temp = 0, excitation_current = 0;\n\tint ret;\n\n\tdiode = devm_kzalloc(&st->spi->dev, sizeof(*diode), GFP_KERNEL);\n\tif (!diode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (fwnode_property_read_bool(child, \"adi,single-ended\"))\n\t\tdiode->sensor_config = LTC2983_DIODE_SGL(1);\n\n\tif (fwnode_property_read_bool(child, \"adi,three-conversion-cycles\"))\n\t\tdiode->sensor_config |= LTC2983_DIODE_3_CONV_CYCLE(1);\n\n\tif (fwnode_property_read_bool(child, \"adi,average-on\"))\n\t\tdiode->sensor_config |= LTC2983_DIODE_AVERAGE_ON(1);\n\n\t \n\tif (!(diode->sensor_config & LTC2983_DIODE_DIFF_MASK) &&\n\t    sensor->chan < LTC2983_DIFFERENTIAL_CHAN_MIN) {\n\t\tdev_err(&st->spi->dev,\n\t\t\t\"Invalid chann:%d for differential thermistor\",\n\t\t\tsensor->chan);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\t \n\tdiode->sensor.fault_handler = ltc2983_common_fault_handler;\n\tdiode->sensor.assign_chan = ltc2983_diode_assign_chan;\n\n\tret = fwnode_property_read_u32(child, \"adi,excitation-current-microamp\",\n\t\t\t\t       &excitation_current);\n\tif (!ret) {\n\t\tswitch (excitation_current) {\n\t\tcase 10:\n\t\t\tdiode->excitation_current = 0x00;\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tdiode->excitation_current = 0x01;\n\t\t\tbreak;\n\t\tcase 40:\n\t\t\tdiode->excitation_current = 0x02;\n\t\t\tbreak;\n\t\tcase 80:\n\t\t\tdiode->excitation_current = 0x03;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&st->spi->dev,\n\t\t\t\t\"Invalid value for excitation current(%u)\",\n\t\t\t\texcitation_current);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\tfwnode_property_read_u32(child, \"adi,ideal-factor-value\", &temp);\n\n\t \n\tdiode->ideal_factor_value = __convert_to_raw(temp, 1048576);\n\n\treturn &diode->sensor;\n}\n\nstatic struct ltc2983_sensor *ltc2983_r_sense_new(struct fwnode_handle *child,\n\t\t\t\t\tstruct ltc2983_data *st,\n\t\t\t\t\tconst struct ltc2983_sensor *sensor)\n{\n\tstruct ltc2983_rsense *rsense;\n\tint ret;\n\tu32 temp;\n\n\trsense = devm_kzalloc(&st->spi->dev, sizeof(*rsense), GFP_KERNEL);\n\tif (!rsense)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tif (sensor->chan < LTC2983_DIFFERENTIAL_CHAN_MIN) {\n\t\tdev_err(&st->spi->dev, \"Invalid chann:%d for r_sense\",\n\t\t\tsensor->chan);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tret = fwnode_property_read_u32(child, \"adi,rsense-val-milli-ohms\", &temp);\n\tif (ret) {\n\t\tdev_err(&st->spi->dev, \"Property adi,rsense-val-milli-ohms missing\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\t \n\trsense->r_sense_val = __convert_to_raw((u64)temp * 1000, 1024);\n\n\t \n\trsense->sensor.assign_chan = ltc2983_r_sense_assign_chan;\n\n\treturn &rsense->sensor;\n}\n\nstatic struct ltc2983_sensor *ltc2983_adc_new(struct fwnode_handle *child,\n\t\t\t\t\t struct ltc2983_data *st,\n\t\t\t\t\t const struct ltc2983_sensor *sensor)\n{\n\tstruct ltc2983_adc *adc;\n\n\tadc = devm_kzalloc(&st->spi->dev, sizeof(*adc), GFP_KERNEL);\n\tif (!adc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (fwnode_property_read_bool(child, \"adi,single-ended\"))\n\t\tadc->single_ended = true;\n\n\tif (!adc->single_ended &&\n\t    sensor->chan < LTC2983_DIFFERENTIAL_CHAN_MIN) {\n\t\tdev_err(&st->spi->dev, \"Invalid chan:%d for differential adc\\n\",\n\t\t\tsensor->chan);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\t \n\tadc->sensor.assign_chan = ltc2983_adc_assign_chan;\n\tadc->sensor.fault_handler = ltc2983_common_fault_handler;\n\n\treturn &adc->sensor;\n}\n\nstatic struct ltc2983_sensor *ltc2983_temp_new(struct fwnode_handle *child,\n\t\t\t\t\t       struct ltc2983_data *st,\n\t\t\t\t\t       const struct ltc2983_sensor *sensor)\n{\n\tstruct ltc2983_temp *temp;\n\n\ttemp = devm_kzalloc(&st->spi->dev, sizeof(*temp), GFP_KERNEL);\n\tif (!temp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (fwnode_property_read_bool(child, \"adi,single-ended\"))\n\t\ttemp->single_ended = true;\n\n\tif (!temp->single_ended &&\n\t    sensor->chan < LTC2983_DIFFERENTIAL_CHAN_MIN) {\n\t\tdev_err(&st->spi->dev, \"Invalid chan:%d for differential temp\\n\",\n\t\t\tsensor->chan);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\ttemp->custom = __ltc2983_custom_sensor_new(st, child, \"adi,custom-temp\",\n\t\t\t\t\t\t   false, 4096, true);\n\tif (IS_ERR(temp->custom))\n\t\treturn ERR_CAST(temp->custom);\n\n\t \n\ttemp->sensor.assign_chan = ltc2983_temp_assign_chan;\n\ttemp->sensor.fault_handler = ltc2983_common_fault_handler;\n\n\treturn &temp->sensor;\n}\n\nstatic int ltc2983_chan_read(struct ltc2983_data *st,\n\t\t\tconst struct ltc2983_sensor *sensor, int *val)\n{\n\tu32 start_conversion = 0;\n\tint ret;\n\tunsigned long time;\n\n\tstart_conversion = LTC2983_STATUS_START(true);\n\tstart_conversion |= LTC2983_STATUS_CHAN_SEL(sensor->chan);\n\tdev_dbg(&st->spi->dev, \"Start conversion on chan:%d, status:%02X\\n\",\n\t\tsensor->chan, start_conversion);\n\t \n\tret = regmap_write(st->regmap, LTC2983_STATUS_REG, start_conversion);\n\tif (ret)\n\t\treturn ret;\n\n\treinit_completion(&st->completion);\n\t \n\ttime = wait_for_completion_timeout(&st->completion,\n\t\t\t\t\t   msecs_to_jiffies(300));\n\tif (!time) {\n\t\tdev_warn(&st->spi->dev, \"Conversion timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tret = regmap_bulk_read(st->regmap, LTC2983_CHAN_RES_ADDR(sensor->chan),\n\t\t\t       &st->temp, sizeof(st->temp));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = __be32_to_cpu(st->temp);\n\n\tif (!(LTC2983_RES_VALID_MASK & *val)) {\n\t\tdev_err(&st->spi->dev, \"Invalid conversion detected\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = sensor->fault_handler(st, *val);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = sign_extend32((*val) & LTC2983_DATA_MASK, LTC2983_DATA_SIGN_BIT);\n\treturn 0;\n}\n\nstatic int ltc2983_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct ltc2983_data *st = iio_priv(indio_dev);\n\tint ret;\n\n\t \n\tif (chan->address >= st->num_channels) {\n\t\tdev_err(&st->spi->dev, \"Invalid chan address:%ld\",\n\t\t\tchan->address);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&st->lock);\n\t\tret = ltc2983_chan_read(st, st->sensors[chan->address], val);\n\t\tmutex_unlock(&st->lock);\n\t\treturn ret ?: IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = 1000;\n\t\t\t \n\t\t\t*val2 = 1024;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_VOLTAGE:\n\t\t\t \n\t\t\t*val = 1000;\n\t\t\t \n\t\t\t*val2 = 2097152;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ltc2983_reg_access(struct iio_dev *indio_dev,\n\t\t\t      unsigned int reg,\n\t\t\t      unsigned int writeval,\n\t\t\t      unsigned int *readval)\n{\n\tstruct ltc2983_data *st = iio_priv(indio_dev);\n\n\tif (readval)\n\t\treturn regmap_read(st->regmap, reg, readval);\n\telse\n\t\treturn regmap_write(st->regmap, reg, writeval);\n}\n\nstatic irqreturn_t ltc2983_irq_handler(int irq, void *data)\n{\n\tstruct ltc2983_data *st = data;\n\n\tcomplete(&st->completion);\n\treturn IRQ_HANDLED;\n}\n\n#define LTC2983_CHAN(__type, index, __address) ({ \\\n\tstruct iio_chan_spec __chan = { \\\n\t\t.type = __type, \\\n\t\t.indexed = 1, \\\n\t\t.channel = index, \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \\\n\t\t.address = __address, \\\n\t}; \\\n\t__chan; \\\n})\n\nstatic int ltc2983_parse_dt(struct ltc2983_data *st)\n{\n\tstruct device *dev = &st->spi->dev;\n\tstruct fwnode_handle *child;\n\tint ret = 0, chan = 0, channel_avail_mask = 0;\n\n\tdevice_property_read_u32(dev, \"adi,mux-delay-config-us\", &st->mux_delay_config);\n\n\tdevice_property_read_u32(dev, \"adi,filter-notch-freq\", &st->filter_notch_freq);\n\n\tst->num_channels = device_get_child_node_count(dev);\n\tif (!st->num_channels) {\n\t\tdev_err(&st->spi->dev, \"At least one channel must be given!\");\n\t\treturn -EINVAL;\n\t}\n\n\tst->sensors = devm_kcalloc(dev, st->num_channels, sizeof(*st->sensors),\n\t\t\t\t   GFP_KERNEL);\n\tif (!st->sensors)\n\t\treturn -ENOMEM;\n\n\tst->iio_channels = st->num_channels;\n\tdevice_for_each_child_node(dev, child) {\n\t\tstruct ltc2983_sensor sensor;\n\n\t\tret = fwnode_property_read_u32(child, \"reg\", &sensor.chan);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"reg property must given for child nodes\\n\");\n\t\t\tgoto put_child;\n\t\t}\n\n\t\t \n\t\tif (sensor.chan < LTC2983_MIN_CHANNELS_NR ||\n\t\t    sensor.chan > st->info->max_channels_nr) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(dev, \"chan:%d must be from %u to %u\\n\", sensor.chan,\n\t\t\t\tLTC2983_MIN_CHANNELS_NR, st->info->max_channels_nr);\n\t\t\tgoto put_child;\n\t\t} else if (channel_avail_mask & BIT(sensor.chan)) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(dev, \"chan:%d already in use\\n\", sensor.chan);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tret = fwnode_property_read_u32(child, \"adi,sensor-type\", &sensor.type);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"adi,sensor-type property must given for child nodes\\n\");\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tdev_dbg(dev, \"Create new sensor, type %u, chann %u\",\n\t\t\t\t\t\t\t\tsensor.type,\n\t\t\t\t\t\t\t\tsensor.chan);\n\n\t\tif (sensor.type >= LTC2983_SENSOR_THERMOCOUPLE &&\n\t\t    sensor.type <= LTC2983_SENSOR_THERMOCOUPLE_CUSTOM) {\n\t\t\tst->sensors[chan] = ltc2983_thermocouple_new(child, st,\n\t\t\t\t\t\t\t\t     &sensor);\n\t\t} else if (sensor.type >= LTC2983_SENSOR_RTD &&\n\t\t\t   sensor.type <= LTC2983_SENSOR_RTD_CUSTOM) {\n\t\t\tst->sensors[chan] = ltc2983_rtd_new(child, st, &sensor);\n\t\t} else if (sensor.type >= LTC2983_SENSOR_THERMISTOR &&\n\t\t\t   sensor.type <= LTC2983_SENSOR_THERMISTOR_CUSTOM) {\n\t\t\tst->sensors[chan] = ltc2983_thermistor_new(child, st,\n\t\t\t\t\t\t\t\t   &sensor);\n\t\t} else if (sensor.type == LTC2983_SENSOR_DIODE) {\n\t\t\tst->sensors[chan] = ltc2983_diode_new(child, st,\n\t\t\t\t\t\t\t      &sensor);\n\t\t} else if (sensor.type == LTC2983_SENSOR_SENSE_RESISTOR) {\n\t\t\tst->sensors[chan] = ltc2983_r_sense_new(child, st,\n\t\t\t\t\t\t\t\t&sensor);\n\t\t\t \n\t\t\tst->iio_channels--;\n\t\t} else if (sensor.type == LTC2983_SENSOR_DIRECT_ADC) {\n\t\t\tst->sensors[chan] = ltc2983_adc_new(child, st, &sensor);\n\t\t} else if (st->info->has_temp &&\n\t\t\t   sensor.type == LTC2983_SENSOR_ACTIVE_TEMP) {\n\t\t\tst->sensors[chan] = ltc2983_temp_new(child, st, &sensor);\n\t\t} else {\n\t\t\tdev_err(dev, \"Unknown sensor type %d\\n\", sensor.type);\n\t\t\tret = -EINVAL;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tif (IS_ERR(st->sensors[chan])) {\n\t\t\tdev_err(dev, \"Failed to create sensor %ld\",\n\t\t\t\tPTR_ERR(st->sensors[chan]));\n\t\t\tret = PTR_ERR(st->sensors[chan]);\n\t\t\tgoto put_child;\n\t\t}\n\t\t \n\t\tst->sensors[chan]->chan = sensor.chan;\n\t\tst->sensors[chan]->type = sensor.type;\n\n\t\tchannel_avail_mask |= BIT(sensor.chan);\n\t\tchan++;\n\t}\n\n\treturn 0;\nput_child:\n\tfwnode_handle_put(child);\n\treturn ret;\n}\n\nstatic int ltc2983_eeprom_cmd(struct ltc2983_data *st, unsigned int cmd,\n\t\t\t      unsigned int wait_time, unsigned int status_reg,\n\t\t\t      unsigned long status_fail_mask)\n{\n\tunsigned long time;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_bulk_write(st->regmap, LTC2983_EEPROM_KEY_REG,\n\t\t\t\t&st->eeprom_key, sizeof(st->eeprom_key));\n\tif (ret)\n\t\treturn ret;\n\n\treinit_completion(&st->completion);\n\n\tret = regmap_write(st->regmap, LTC2983_STATUS_REG,\n\t\t\t   LTC2983_STATUS_START(true) | cmd);\n\tif (ret)\n\t\treturn ret;\n\n\ttime = wait_for_completion_timeout(&st->completion,\n\t\t\t\t\t   msecs_to_jiffies(wait_time));\n\tif (!time) {\n\t\tdev_err(&st->spi->dev, \"EEPROM command timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tret = regmap_read(st->regmap, status_reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & status_fail_mask) {\n\t\tdev_err(&st->spi->dev, \"EEPROM command failed: 0x%02X\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ltc2983_setup(struct ltc2983_data *st, bool assign_iio)\n{\n\tu32 iio_chan_t = 0, iio_chan_v = 0, chan, iio_idx = 0, status;\n\tint ret;\n\n\t \n\tret = regmap_read_poll_timeout(st->regmap, LTC2983_STATUS_REG, status,\n\t\t\t\t       LTC2983_STATUS_UP(status) == 1, 25000,\n\t\t\t\t       25000 * 10);\n\tif (ret) {\n\t\tdev_err(&st->spi->dev, \"Device startup timed out\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(st->regmap, LTC2983_GLOBAL_CONFIG_REG,\n\t\t\t\t LTC2983_NOTCH_FREQ_MASK,\n\t\t\t\t LTC2983_NOTCH_FREQ(st->filter_notch_freq));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(st->regmap, LTC2983_MUX_CONFIG_REG,\n\t\t\t   st->mux_delay_config);\n\tif (ret)\n\t\treturn ret;\n\n\tif (st->info->has_eeprom && !assign_iio) {\n\t\tret = ltc2983_eeprom_cmd(st, LTC2983_EEPROM_READ_CMD,\n\t\t\t\t\t LTC2983_EEPROM_READ_TIME_MS,\n\t\t\t\t\t LTC2983_EEPROM_READ_STATUS_REG,\n\t\t\t\t\t LTC2983_EEPROM_READ_FAILURE_MASK);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\tfor (chan = 0; chan < st->num_channels; chan++) {\n\t\tu32 chan_type = 0, *iio_chan;\n\n\t\tret = st->sensors[chan]->assign_chan(st, st->sensors[chan]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tif (st->sensors[chan]->type == LTC2983_SENSOR_SENSE_RESISTOR ||\n\t\t    !assign_iio)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (st->sensors[chan]->type != LTC2983_SENSOR_DIRECT_ADC) {\n\t\t\tchan_type = IIO_TEMP;\n\t\t\tiio_chan = &iio_chan_t;\n\t\t} else {\n\t\t\tchan_type = IIO_VOLTAGE;\n\t\t\tiio_chan = &iio_chan_v;\n\t\t}\n\n\t\t \n\t\tst->iio_chan[iio_idx++] = LTC2983_CHAN(chan_type, (*iio_chan)++,\n\t\t\t\t\t\t       chan);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_range ltc2983_reg_ranges[] = {\n\tregmap_reg_range(LTC2983_STATUS_REG, LTC2983_STATUS_REG),\n\tregmap_reg_range(LTC2983_TEMP_RES_START_REG, LTC2983_TEMP_RES_END_REG),\n\tregmap_reg_range(LTC2983_EEPROM_KEY_REG, LTC2983_EEPROM_KEY_REG),\n\tregmap_reg_range(LTC2983_EEPROM_READ_STATUS_REG,\n\t\t\t LTC2983_EEPROM_READ_STATUS_REG),\n\tregmap_reg_range(LTC2983_GLOBAL_CONFIG_REG, LTC2983_GLOBAL_CONFIG_REG),\n\tregmap_reg_range(LTC2983_MULT_CHANNEL_START_REG,\n\t\t\t LTC2983_MULT_CHANNEL_END_REG),\n\tregmap_reg_range(LTC2986_EEPROM_STATUS_REG, LTC2986_EEPROM_STATUS_REG),\n\tregmap_reg_range(LTC2983_MUX_CONFIG_REG, LTC2983_MUX_CONFIG_REG),\n\tregmap_reg_range(LTC2983_CHAN_ASSIGN_START_REG,\n\t\t\t LTC2983_CHAN_ASSIGN_END_REG),\n\tregmap_reg_range(LTC2983_CUST_SENS_TBL_START_REG,\n\t\t\t LTC2983_CUST_SENS_TBL_END_REG),\n};\n\nstatic const struct regmap_access_table ltc2983_reg_table = {\n\t.yes_ranges = ltc2983_reg_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(ltc2983_reg_ranges),\n};\n\n \nstatic const struct regmap_config ltc2983_regmap_config = {\n\t.reg_bits = 24,\n\t.val_bits = 8,\n\t.wr_table = &ltc2983_reg_table,\n\t.rd_table = &ltc2983_reg_table,\n\t.read_flag_mask = GENMASK(1, 0),\n\t.write_flag_mask = BIT(1),\n};\n\nstatic const struct  iio_info ltc2983_iio_info = {\n\t.read_raw = ltc2983_read_raw,\n\t.debugfs_reg_access = ltc2983_reg_access,\n};\n\nstatic int ltc2983_probe(struct spi_device *spi)\n{\n\tstruct ltc2983_data *st;\n\tstruct iio_dev *indio_dev;\n\tstruct gpio_desc *gpio;\n\tconst char *name = spi_get_device_id(spi)->name;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tst = iio_priv(indio_dev);\n\n\tst->info = device_get_match_data(&spi->dev);\n\tif (!st->info)\n\t\tst->info = (void *)spi_get_device_id(spi)->driver_data;\n\tif (!st->info)\n\t\treturn -ENODEV;\n\n\tst->regmap = devm_regmap_init_spi(spi, &ltc2983_regmap_config);\n\tif (IS_ERR(st->regmap)) {\n\t\tdev_err(&spi->dev, \"Failed to initialize regmap\\n\");\n\t\treturn PTR_ERR(st->regmap);\n\t}\n\n\tmutex_init(&st->lock);\n\tinit_completion(&st->completion);\n\tst->spi = spi;\n\tst->eeprom_key = cpu_to_be32(LTC2983_EEPROM_KEY);\n\tspi_set_drvdata(spi, st);\n\n\tret = ltc2983_parse_dt(st);\n\tif (ret)\n\t\treturn ret;\n\n\tgpio = devm_gpiod_get_optional(&st->spi->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(gpio))\n\t\treturn PTR_ERR(gpio);\n\n\tif (gpio) {\n\t\t \n\t\tusleep_range(1000, 1200);\n\t\tgpiod_set_value_cansleep(gpio, 0);\n\t}\n\n\tst->iio_chan = devm_kzalloc(&spi->dev,\n\t\t\t\t    st->iio_channels * sizeof(*st->iio_chan),\n\t\t\t\t    GFP_KERNEL);\n\tif (!st->iio_chan)\n\t\treturn -ENOMEM;\n\n\tret = ltc2983_setup(st, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_irq(&spi->dev, spi->irq, ltc2983_irq_handler,\n\t\t\t       IRQF_TRIGGER_RISING, name, st);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to request an irq, %d\", ret);\n\t\treturn ret;\n\t}\n\n\tif (st->info->has_eeprom) {\n\t\tret = ltc2983_eeprom_cmd(st, LTC2983_EEPROM_WRITE_CMD,\n\t\t\t\t\t LTC2983_EEPROM_WRITE_TIME_MS,\n\t\t\t\t\t LTC2986_EEPROM_STATUS_REG,\n\t\t\t\t\t LTC2983_EEPROM_STATUS_FAILURE_MASK);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tindio_dev->name = name;\n\tindio_dev->num_channels = st->iio_channels;\n\tindio_dev->channels = st->iio_chan;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &ltc2983_iio_info;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic int ltc2983_resume(struct device *dev)\n{\n\tstruct ltc2983_data *st = spi_get_drvdata(to_spi_device(dev));\n\tint dummy;\n\n\t \n\tregmap_read(st->regmap, LTC2983_STATUS_REG, &dummy);\n\t \n\treturn ltc2983_setup(st, false);\n}\n\nstatic int ltc2983_suspend(struct device *dev)\n{\n\tstruct ltc2983_data *st = spi_get_drvdata(to_spi_device(dev));\n\n\treturn regmap_write(st->regmap, LTC2983_STATUS_REG, LTC2983_SLEEP);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ltc2983_pm_ops, ltc2983_suspend,\n\t\t\t\tltc2983_resume);\n\nstatic const struct ltc2983_chip_info ltc2983_chip_info_data = {\n\t.max_channels_nr = 20,\n};\n\nstatic const struct ltc2983_chip_info ltc2984_chip_info_data = {\n\t.max_channels_nr = 20,\n\t.has_eeprom = true,\n};\n\nstatic const struct ltc2983_chip_info ltc2986_chip_info_data = {\n\t.max_channels_nr = 10,\n\t.has_temp = true,\n\t.has_eeprom = true,\n};\n\nstatic const struct spi_device_id ltc2983_id_table[] = {\n\t{ \"ltc2983\", (kernel_ulong_t)&ltc2983_chip_info_data },\n\t{ \"ltc2984\", (kernel_ulong_t)&ltc2984_chip_info_data },\n\t{ \"ltc2986\", (kernel_ulong_t)&ltc2986_chip_info_data },\n\t{ \"ltm2985\", (kernel_ulong_t)&ltc2986_chip_info_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(spi, ltc2983_id_table);\n\nstatic const struct of_device_id ltc2983_of_match[] = {\n\t{ .compatible = \"adi,ltc2983\", .data = &ltc2983_chip_info_data },\n\t{ .compatible = \"adi,ltc2984\", .data = &ltc2984_chip_info_data },\n\t{ .compatible = \"adi,ltc2986\", .data = &ltc2986_chip_info_data },\n\t{ .compatible = \"adi,ltm2985\", .data = &ltc2986_chip_info_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ltc2983_of_match);\n\nstatic struct spi_driver ltc2983_driver = {\n\t.driver = {\n\t\t.name = \"ltc2983\",\n\t\t.of_match_table = ltc2983_of_match,\n\t\t.pm = pm_sleep_ptr(&ltc2983_pm_ops),\n\t},\n\t.probe = ltc2983_probe,\n\t.id_table = ltc2983_id_table,\n};\n\nmodule_spi_driver(ltc2983_driver);\n\nMODULE_AUTHOR(\"Nuno Sa <nuno.sa@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices LTC2983 SPI Temperature sensors\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}