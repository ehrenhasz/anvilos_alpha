{
  "module_name": "max31856.c",
  "hash_id": "af932767ceeadf5d9445ab80c0fb36f55043fdc74c1bd5500593e624fcfefcc6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/temperature/max31856.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/util_macros.h>\n#include <asm/unaligned.h>\n#include <dt-bindings/iio/temperature/thermocouple.h>\n \n#define MAX31856_RD_WR_BIT         BIT(7)\n\n#define MAX31856_CR0_AUTOCONVERT   BIT(7)\n#define MAX31856_CR0_1SHOT         BIT(6)\n#define MAX31856_CR0_OCFAULT       BIT(4)\n#define MAX31856_CR0_OCFAULT_MASK  GENMASK(5, 4)\n#define MAX31856_CR0_FILTER_50HZ   BIT(0)\n#define MAX31856_AVERAGING_MASK    GENMASK(6, 4)\n#define MAX31856_AVERAGING_SHIFT   4\n#define MAX31856_TC_TYPE_MASK      GENMASK(3, 0)\n#define MAX31856_FAULT_OVUV        BIT(1)\n#define MAX31856_FAULT_OPEN        BIT(0)\n\n \n#define MAX31856_CR0_REG           0x00\n#define MAX31856_CR1_REG           0x01\n#define MAX31856_MASK_REG          0x02\n#define MAX31856_CJHF_REG          0x03\n#define MAX31856_CJLF_REG          0x04\n#define MAX31856_LTHFTH_REG        0x05\n#define MAX31856_LTHFTL_REG        0x06\n#define MAX31856_LTLFTH_REG        0x07\n#define MAX31856_LTLFTL_REG        0x08\n#define MAX31856_CJTO_REG          0x09\n#define MAX31856_CJTH_REG          0x0A\n#define MAX31856_CJTL_REG          0x0B\n#define MAX31856_LTCBH_REG         0x0C\n#define MAX31856_LTCBM_REG         0x0D\n#define MAX31856_LTCBL_REG         0x0E\n#define MAX31856_SR_REG            0x0F\n\nstatic const struct iio_chan_spec max31856_channels[] = {\n\t{\t \n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_THERMOCOUPLE_TYPE),\n\t\t.info_mask_shared_by_type =\n\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO)\n\t},\n\t{\t \n\t\t.type = IIO_TEMP,\n\t\t.channel2 = IIO_MOD_TEMP_AMBIENT,\n\t\t.modified = 1,\n\t\t.info_mask_separate =\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_type =\n\t\t\tBIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO)\n\t},\n};\n\nstruct max31856_data {\n\tstruct spi_device *spi;\n\tu32 thermocouple_type;\n\tbool filter_50hz;\n\tint averaging;\n};\n\nstatic const char max31856_tc_types[] = {\n\t'B', 'E', 'J', 'K', 'N', 'R', 'S', 'T'\n};\n\nstatic int max31856_read(struct max31856_data *data, u8 reg,\n\t\t\t u8 val[], unsigned int read_size)\n{\n\treturn spi_write_then_read(data->spi, &reg, 1, val, read_size);\n}\n\nstatic int max31856_write(struct max31856_data *data, u8 reg,\n\t\t\t  unsigned int val)\n{\n\tu8 buf[2];\n\n\tbuf[0] = reg | (MAX31856_RD_WR_BIT);\n\tbuf[1] = val;\n\n\treturn spi_write(data->spi, buf, 2);\n}\n\nstatic int max31856_init(struct max31856_data *data)\n{\n\tint ret;\n\tu8 reg_cr0_val, reg_cr1_val;\n\n\t \n\tret = max31856_read(data, MAX31856_CR0_REG, &reg_cr0_val, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treg_cr0_val &= ~MAX31856_CR0_AUTOCONVERT;\n\tret = max31856_write(data, MAX31856_CR0_REG, reg_cr0_val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = max31856_read(data, MAX31856_CR1_REG, &reg_cr1_val, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treg_cr1_val &= ~MAX31856_TC_TYPE_MASK;\n\treg_cr1_val |= data->thermocouple_type;\n\n\treg_cr1_val &= ~MAX31856_AVERAGING_MASK;\n\treg_cr1_val |= data->averaging << MAX31856_AVERAGING_SHIFT;\n\n\tret = max31856_write(data, MAX31856_CR1_REG, reg_cr1_val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treg_cr0_val &= ~MAX31856_CR0_OCFAULT_MASK;\n\treg_cr0_val |= MAX31856_CR0_OCFAULT;\n\n\t \n\treg_cr0_val &= ~MAX31856_CR0_1SHOT;\n\treg_cr0_val |= MAX31856_CR0_AUTOCONVERT;\n\n\tif (data->filter_50hz)\n\t\treg_cr0_val |= MAX31856_CR0_FILTER_50HZ;\n\telse\n\t\treg_cr0_val &= ~MAX31856_CR0_FILTER_50HZ;\n\n\treturn max31856_write(data, MAX31856_CR0_REG, reg_cr0_val);\n}\n\nstatic int max31856_thermocouple_read(struct max31856_data *data,\n\t\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t\t      int *val)\n{\n\tint ret, offset_cjto;\n\tu8 reg_val[3];\n\n\tswitch (chan->channel2) {\n\tcase IIO_NO_MOD:\n\t\t \n\t\tret = max31856_read(data, MAX31856_LTCBH_REG, reg_val, 3);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\t*val = get_unaligned_be24(&reg_val[0]) >> 5;\n\t\t \n\t\tif (reg_val[0] & 0x80)\n\t\t\t*val -= 0x80000;\n\t\tbreak;\n\n\tcase IIO_MOD_TEMP_AMBIENT:\n\t\t \n\t\tret = max31856_read(data, MAX31856_CJTO_REG, reg_val, 3);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\toffset_cjto = reg_val[0];\n\t\t \n\t\t*val = get_unaligned_be16(&reg_val[1]) >> 2;\n\t\t \n\t\t*val += offset_cjto;\n\t\t \n\t\tif (reg_val[1] & 0x80)\n\t\t\t*val -= 0x4000;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = max31856_read(data, MAX31856_SR_REG, reg_val, 1);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (reg_val[0] & (MAX31856_FAULT_OVUV | MAX31856_FAULT_OPEN))\n\t\treturn -EIO;\n\n\treturn ret;\n}\n\nstatic int max31856_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int *val, int *val2, long mask)\n{\n\tstruct max31856_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = max31856_thermocouple_read(data, chan, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->channel2) {\n\t\tcase IIO_MOD_TEMP_AMBIENT:\n\t\t\t \n\t\t\t*val = 15;\n\t\t\t*val2 = 625000;  \n\t\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\t*val = 7;\n\t\t\t*val2 = 812500;  \n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t*val = 1 << data->averaging;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_THERMOCOUPLE_TYPE:\n\t\t*val = max31856_tc_types[data->thermocouple_type];\n\t\treturn IIO_VAL_CHAR;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int max31856_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t\t      long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_THERMOCOUPLE_TYPE:\n\t\treturn IIO_VAL_CHAR;\n\tdefault:\n\t\treturn IIO_VAL_INT;\n\t}\n}\n\nstatic int max31856_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t      int val, int val2, long mask)\n{\n\tstruct max31856_data *data = iio_priv(indio_dev);\n\tint msb;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tif (val > 16 || val < 1)\n\t\t\treturn -EINVAL;\n\t\tmsb = fls(val) - 1;\n\t\t \n\t\tif (BIT(msb) < val)\n\t\t\tmsb++;\n\n\t\tdata->averaging = msb;\n\t\tmax31856_init(data);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_THERMOCOUPLE_TYPE:\n\t{\n\t\tint tc_type = -1;\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(max31856_tc_types); i++) {\n\t\t\tif (max31856_tc_types[i] == toupper(val)) {\n\t\t\t\ttc_type = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (tc_type < 0)\n\t\t\treturn -EINVAL;\n\n\t\tdata->thermocouple_type = tc_type;\n\t\tmax31856_init(data);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t show_fault(struct device *dev, u8 faultbit, char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct max31856_data *data = iio_priv(indio_dev);\n\tu8 reg_val;\n\tint ret;\n\tbool fault;\n\n\tret = max31856_read(data, MAX31856_SR_REG, &reg_val, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tfault = reg_val & faultbit;\n\n\treturn sysfs_emit(buf, \"%d\\n\", fault);\n}\n\nstatic ssize_t show_fault_ovuv(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\treturn show_fault(dev, MAX31856_FAULT_OVUV, buf);\n}\n\nstatic ssize_t show_fault_oc(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn show_fault(dev, MAX31856_FAULT_OPEN, buf);\n}\n\nstatic ssize_t show_filter(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct max31856_data *data = iio_priv(indio_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", data->filter_50hz ? 50 : 60);\n}\n\nstatic ssize_t set_filter(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  const char *buf,\n\t\t\t  size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct max31856_data *data = iio_priv(indio_dev);\n\tunsigned int freq;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &freq);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (freq) {\n\tcase 50:\n\t\tdata->filter_50hz = true;\n\t\tbreak;\n\tcase 60:\n\t\tdata->filter_50hz = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmax31856_init(data);\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(fault_ovuv, 0444, show_fault_ovuv, NULL, 0);\nstatic IIO_DEVICE_ATTR(fault_oc, 0444, show_fault_oc, NULL, 0);\nstatic IIO_DEVICE_ATTR(in_temp_filter_notch_center_frequency, 0644,\n\t\t       show_filter, set_filter, 0);\n\nstatic struct attribute *max31856_attributes[] = {\n\t&iio_dev_attr_fault_ovuv.dev_attr.attr,\n\t&iio_dev_attr_fault_oc.dev_attr.attr,\n\t&iio_dev_attr_in_temp_filter_notch_center_frequency.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group max31856_group = {\n\t.attrs = max31856_attributes,\n};\n\nstatic const struct iio_info max31856_info = {\n\t.read_raw = max31856_read_raw,\n\t.write_raw = max31856_write_raw,\n\t.write_raw_get_fmt = max31856_write_raw_get_fmt,\n\t.attrs = &max31856_group,\n};\n\nstatic int max31856_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *id = spi_get_device_id(spi);\n\tstruct iio_dev *indio_dev;\n\tstruct max31856_data *data;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->spi = spi;\n\tdata->filter_50hz = false;\n\n\tspi_set_drvdata(spi, indio_dev);\n\n\tindio_dev->info = &max31856_info;\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = max31856_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(max31856_channels);\n\n\tret = device_property_read_u32(&spi->dev, \"thermocouple-type\", &data->thermocouple_type);\n\tif (ret) {\n\t\tdev_info(&spi->dev,\n\t\t\t \"Could not read thermocouple type DT property, configuring as a K-Type\\n\");\n\t\tdata->thermocouple_type = THERMOCOUPLE_TYPE_K;\n\t}\n\n\t \n\tswitch (data->thermocouple_type) {\n\tcase THERMOCOUPLE_TYPE_B:\n\tcase THERMOCOUPLE_TYPE_E:\n\tcase THERMOCOUPLE_TYPE_J:\n\tcase THERMOCOUPLE_TYPE_K:\n\tcase THERMOCOUPLE_TYPE_N:\n\tcase THERMOCOUPLE_TYPE_R:\n\tcase THERMOCOUPLE_TYPE_S:\n\tcase THERMOCOUPLE_TYPE_T:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&spi->dev,\n\t\t\t\"error: thermocouple-type %u not supported by max31856\\n\"\n\t\t\t, data->thermocouple_type);\n\t\treturn -EINVAL;\n\t}\n\n\tret = max31856_init(data);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"error: Failed to configure max31856\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct spi_device_id max31856_id[] = {\n\t{ \"max31856\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, max31856_id);\n\nstatic const struct of_device_id max31856_of_match[] = {\n\t{ .compatible = \"maxim,max31856\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max31856_of_match);\n\nstatic struct spi_driver max31856_driver = {\n\t.driver = {\n\t\t.name = \"max31856\",\n\t\t.of_match_table = max31856_of_match,\n\t},\n\t.probe = max31856_probe,\n\t.id_table = max31856_id,\n};\nmodule_spi_driver(max31856_driver);\n\nMODULE_AUTHOR(\"Paresh Chaudhary <paresh.chaudhary@rockwellcollins.com>\");\nMODULE_AUTHOR(\"Patrick Havelange <patrick.havelange@essensium.com>\");\nMODULE_DESCRIPTION(\"Maxim MAX31856 thermocouple sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}