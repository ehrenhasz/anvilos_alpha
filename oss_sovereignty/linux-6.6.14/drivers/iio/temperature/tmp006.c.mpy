{
  "module_name": "tmp006.c",
  "hash_id": "8281e6289adb3f550b97a40780e44d98a86df4559fbe1879ce6ccb0c65dbb898",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/temperature/tmp006.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pm.h>\n#include <linux/bitops.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define TMP006_VOBJECT 0x00\n#define TMP006_TAMBIENT 0x01\n#define TMP006_CONFIG 0x02\n#define TMP006_MANUFACTURER_ID 0xfe\n#define TMP006_DEVICE_ID 0xff\n\n#define TMP006_TAMBIENT_SHIFT 2\n\n#define TMP006_CONFIG_RESET BIT(15)\n#define TMP006_CONFIG_DRDY_EN BIT(8)\n#define TMP006_CONFIG_DRDY BIT(7)\n\n#define TMP006_CONFIG_MOD_MASK GENMASK(14, 12)\n\n#define TMP006_CONFIG_CR_MASK GENMASK(11, 9)\n#define TMP006_CONFIG_CR_SHIFT 9\n\n#define TMP006_MANUFACTURER_MAGIC 0x5449\n#define TMP006_DEVICE_MAGIC 0x0067\n\nstruct tmp006_data {\n\tstruct i2c_client *client;\n\tu16 config;\n};\n\nstatic int tmp006_read_measurement(struct tmp006_data *data, u8 reg)\n{\n\ts32 ret;\n\tint tries = 50;\n\n\twhile (tries-- > 0) {\n\t\tret = i2c_smbus_read_word_swapped(data->client,\n\t\t\tTMP006_CONFIG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret & TMP006_CONFIG_DRDY)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\n\tif (tries < 0)\n\t\treturn -EIO;\n\n\treturn i2c_smbus_read_word_swapped(data->client, reg);\n}\n\nstatic const int tmp006_freqs[5][2] = { {4, 0}, {2, 0}, {1, 0},\n\t\t\t\t\t{0, 500000}, {0, 250000} };\n\nstatic int tmp006_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *channel, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct tmp006_data *data = iio_priv(indio_dev);\n\ts32 ret;\n\tint cr;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (channel->type == IIO_VOLTAGE) {\n\t\t\t \n\t\t\tret = tmp006_read_measurement(data, TMP006_VOBJECT);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = sign_extend32(ret, 15);\n\t\t} else if (channel->type == IIO_TEMP) {\n\t\t\t \n\t\t\tret = tmp006_read_measurement(data, TMP006_TAMBIENT);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = sign_extend32(ret, 15) >> TMP006_TAMBIENT_SHIFT;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tif (channel->type == IIO_VOLTAGE) {\n\t\t\t*val = 0;\n\t\t\t*val2 = 156250;\n\t\t} else if (channel->type == IIO_TEMP) {\n\t\t\t*val = 31;\n\t\t\t*val2 = 250000;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tcr = (data->config & TMP006_CONFIG_CR_MASK)\n\t\t\t>> TMP006_CONFIG_CR_SHIFT;\n\t\t*val = tmp006_freqs[cr][0];\n\t\t*val2 = tmp006_freqs[cr][1];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int tmp006_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val,\n\t\t\t    int val2,\n\t\t\t    long mask)\n{\n\tstruct tmp006_data *data = iio_priv(indio_dev);\n\tint i;\n\n\tif (mask != IIO_CHAN_INFO_SAMP_FREQ)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(tmp006_freqs); i++)\n\t\tif ((val == tmp006_freqs[i][0]) &&\n\t\t    (val2 == tmp006_freqs[i][1])) {\n\t\t\tdata->config &= ~TMP006_CONFIG_CR_MASK;\n\t\t\tdata->config |= i << TMP006_CONFIG_CR_SHIFT;\n\n\t\t\treturn i2c_smbus_write_word_swapped(data->client,\n\t\t\t\t\t\t\t    TMP006_CONFIG,\n\t\t\t\t\t\t\t    data->config);\n\n\t\t}\n\treturn -EINVAL;\n}\n\nstatic IIO_CONST_ATTR(sampling_frequency_available, \"4 2 1 0.5 0.25\");\n\nstatic struct attribute *tmp006_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tmp006_attribute_group = {\n\t.attrs = tmp006_attributes,\n};\n\nstatic const struct iio_chan_spec tmp006_channels[] = {\n\t{\n\t\t.type = IIO_VOLTAGE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t}\n};\n\nstatic const struct iio_info tmp006_info = {\n\t.read_raw = tmp006_read_raw,\n\t.write_raw = tmp006_write_raw,\n\t.attrs = &tmp006_attribute_group,\n};\n\nstatic bool tmp006_check_identification(struct i2c_client *client)\n{\n\tint mid, did;\n\n\tmid = i2c_smbus_read_word_swapped(client, TMP006_MANUFACTURER_ID);\n\tif (mid < 0)\n\t\treturn false;\n\n\tdid = i2c_smbus_read_word_swapped(client, TMP006_DEVICE_ID);\n\tif (did < 0)\n\t\treturn false;\n\n\treturn mid == TMP006_MANUFACTURER_MAGIC && did == TMP006_DEVICE_MAGIC;\n}\n\nstatic int tmp006_power(struct device *dev, bool up)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct tmp006_data *data = iio_priv(indio_dev);\n\n\tif (up)\n\t\tdata->config |= TMP006_CONFIG_MOD_MASK;\n\telse\n\t\tdata->config &= ~TMP006_CONFIG_MOD_MASK;\n\n\treturn i2c_smbus_write_word_swapped(data->client, TMP006_CONFIG,\n\t\tdata->config);\n}\n\nstatic void tmp006_powerdown_cleanup(void *dev)\n{\n\ttmp006_power(dev, false);\n}\n\nstatic int tmp006_probe(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct tmp006_data *data;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tmp006_check_identification(client)) {\n\t\tdev_err(&client->dev, \"no TMP006 sensor\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\n\tindio_dev->name = dev_name(&client->dev);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &tmp006_info;\n\n\tindio_dev->channels = tmp006_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(tmp006_channels);\n\n\tret = i2c_smbus_read_word_swapped(data->client, TMP006_CONFIG);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->config = ret;\n\n\tif ((ret & TMP006_CONFIG_MOD_MASK) != TMP006_CONFIG_MOD_MASK) {\n\t\tret = tmp006_power(&client->dev, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&client->dev, tmp006_powerdown_cleanup,\n\t\t\t\t       &client->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic int tmp006_suspend(struct device *dev)\n{\n\treturn tmp006_power(dev, false);\n}\n\nstatic int tmp006_resume(struct device *dev)\n{\n\treturn tmp006_power(dev, true);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tmp006_pm_ops, tmp006_suspend, tmp006_resume);\n\nstatic const struct of_device_id tmp006_of_match[] = {\n\t{ .compatible = \"ti,tmp006\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tmp006_of_match);\n\nstatic const struct i2c_device_id tmp006_id[] = {\n\t{ \"tmp006\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tmp006_id);\n\nstatic struct i2c_driver tmp006_driver = {\n\t.driver = {\n\t\t.name\t= \"tmp006\",\n\t\t.of_match_table = tmp006_of_match,\n\t\t.pm\t= pm_sleep_ptr(&tmp006_pm_ops),\n\t},\n\t.probe = tmp006_probe,\n\t.id_table = tmp006_id,\n};\nmodule_i2c_driver(tmp006_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"TI TMP006 IR thermopile sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}