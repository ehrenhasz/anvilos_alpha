{
  "module_name": "mlx90632.c",
  "hash_id": "b73211f3e757c82cdbb2e0b91e359c8d6bbac40809edebbbd55d650a09da45b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/temperature/mlx90632.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/iopoll.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/limits.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n \n#define MLX90632_ADDR_RAM\t0x4000  \n#define MLX90632_ADDR_EEPROM\t0x2480  \n\n \n#define MLX90632_EE_CTRL\t0x24d4  \n#define MLX90632_EE_I2C_ADDR\t0x24d5  \n#define MLX90632_EE_VERSION\t0x240b  \n#define MLX90632_EE_P_R\t\t0x240c  \n#define MLX90632_EE_P_G\t\t0x240e  \n#define MLX90632_EE_P_T\t\t0x2410  \n#define MLX90632_EE_P_O\t\t0x2412  \n#define MLX90632_EE_Aa\t\t0x2414  \n#define MLX90632_EE_Ab\t\t0x2416  \n#define MLX90632_EE_Ba\t\t0x2418  \n#define MLX90632_EE_Bb\t\t0x241a  \n#define MLX90632_EE_Ca\t\t0x241c  \n#define MLX90632_EE_Cb\t\t0x241e  \n#define MLX90632_EE_Da\t\t0x2420  \n#define MLX90632_EE_Db\t\t0x2422  \n#define MLX90632_EE_Ea\t\t0x2424  \n#define MLX90632_EE_Eb\t\t0x2426  \n#define MLX90632_EE_Fa\t\t0x2428  \n#define MLX90632_EE_Fb\t\t0x242a  \n#define MLX90632_EE_Ga\t\t0x242c  \n\n#define MLX90632_EE_Gb\t\t0x242e  \n#define MLX90632_EE_Ka\t\t0x242f  \n\n#define MLX90632_EE_Ha\t\t0x2481  \n#define MLX90632_EE_Hb\t\t0x2482  \n\n#define MLX90632_EE_MEDICAL_MEAS1      0x24E1  \n#define MLX90632_EE_MEDICAL_MEAS2      0x24E2  \n#define MLX90632_EE_EXTENDED_MEAS1     0x24F1  \n#define MLX90632_EE_EXTENDED_MEAS2     0x24F2  \n#define MLX90632_EE_EXTENDED_MEAS3     0x24F3  \n\n \n#define MLX90632_REG_I2C_ADDR\t0x3000  \n\n \n#define MLX90632_REG_CONTROL\t0x3001  \n#define   MLX90632_CFG_PWR_MASK\t\tGENMASK(2, 1)  \n#define   MLX90632_CFG_MTYP_MASK\t\tGENMASK(8, 4)  \n#define   MLX90632_CFG_SOB_MASK BIT(11)\n\n \n#define MLX90632_PWR_STATUS(ctrl_val) (ctrl_val << 1)\n#define MLX90632_PWR_STATUS_HALT MLX90632_PWR_STATUS(0)  \n#define MLX90632_PWR_STATUS_SLEEP_STEP MLX90632_PWR_STATUS(1)  \n#define MLX90632_PWR_STATUS_STEP MLX90632_PWR_STATUS(2)  \n#define MLX90632_PWR_STATUS_CONTINUOUS MLX90632_PWR_STATUS(3)  \n\n#define MLX90632_EE_RR GENMASK(10, 8)  \n#define MLX90632_REFRESH_RATE(ee_val) FIELD_GET(MLX90632_EE_RR, ee_val)\n\t\t\t\t\t \n#define MLX90632_REFRESH_RATE_STATUS(refresh_rate) (refresh_rate << 8)\n\n \n#define MLX90632_MTYP_MEDICAL 0\n#define MLX90632_MTYP_EXTENDED 17\n\n \n#define MLX90632_MTYP_STATUS(ctrl_val) (ctrl_val << 4)\n#define MLX90632_MTYP_STATUS_MEDICAL MLX90632_MTYP_STATUS(MLX90632_MTYP_MEDICAL)\n#define MLX90632_MTYP_STATUS_EXTENDED MLX90632_MTYP_STATUS(MLX90632_MTYP_EXTENDED)\n\n \n#define MLX90632_REG_I2C_CMD    0x3005  \n\n \n#define MLX90632_REG_STATUS\t0x3fff  \n#define   MLX90632_STAT_BUSY\t\tBIT(10)  \n#define   MLX90632_STAT_EE_BUSY\t\tBIT(9)  \n#define   MLX90632_STAT_BRST\t\tBIT(8)  \n#define   MLX90632_STAT_CYCLE_POS\tGENMASK(6, 2)  \n#define   MLX90632_STAT_DATA_RDY\tBIT(0)  \n\n \n#define MLX90632_RAM_1(meas_num)\t(MLX90632_ADDR_RAM + 3 * meas_num)\n#define MLX90632_RAM_2(meas_num)\t(MLX90632_ADDR_RAM + 3 * meas_num + 1)\n#define MLX90632_RAM_3(meas_num)\t(MLX90632_ADDR_RAM + 3 * meas_num + 2)\n\n \n#define MLX90632_RAM_DSP5_EXTENDED_AMBIENT_1 MLX90632_RAM_3(17)\n#define MLX90632_RAM_DSP5_EXTENDED_AMBIENT_2 MLX90632_RAM_3(18)\n#define MLX90632_RAM_DSP5_EXTENDED_OBJECT_1 MLX90632_RAM_1(17)\n#define MLX90632_RAM_DSP5_EXTENDED_OBJECT_2 MLX90632_RAM_2(17)\n#define MLX90632_RAM_DSP5_EXTENDED_OBJECT_3 MLX90632_RAM_1(18)\n#define MLX90632_RAM_DSP5_EXTENDED_OBJECT_4 MLX90632_RAM_2(18)\n#define MLX90632_RAM_DSP5_EXTENDED_OBJECT_5 MLX90632_RAM_1(19)\n#define MLX90632_RAM_DSP5_EXTENDED_OBJECT_6 MLX90632_RAM_2(19)\n\n \n#define MLX90632_ID_MEDICAL\t0x0105  \n#define MLX90632_ID_CONSUMER\t0x0205  \n#define MLX90632_ID_EXTENDED\t0x0505  \n#define MLX90632_ID_MASK\tGENMASK(14, 0)  \n#define MLX90632_DSP_VERSION\t5  \n#define MLX90632_DSP_MASK\tGENMASK(7, 0)  \n#define MLX90632_RESET_CMD\t0x0006  \n#define MLX90632_REF_12 \t12LL  \n#define MLX90632_REF_3\t\t12LL  \n#define MLX90632_MAX_MEAS_NUM\t31  \n#define MLX90632_SLEEP_DELAY_MS 6000  \n#define MLX90632_EXTENDED_LIMIT 27000  \n#define MLX90632_MEAS_MAX_TIME 2000  \n\n \nstruct mlx90632_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tstruct regmap *regmap;\n\tu16 emissivity;\n\tu8 mtyp;\n\tu32 object_ambient_temperature;\n\tstruct regulator *regulator;\n\tint powerstatus;\n\tunsigned long interaction_ts;\n};\n\nstatic const struct regmap_range mlx90632_volatile_reg_range[] = {\n\tregmap_reg_range(MLX90632_REG_I2C_ADDR, MLX90632_REG_CONTROL),\n\tregmap_reg_range(MLX90632_REG_I2C_CMD, MLX90632_REG_I2C_CMD),\n\tregmap_reg_range(MLX90632_REG_STATUS, MLX90632_REG_STATUS),\n\tregmap_reg_range(MLX90632_RAM_1(0),\n\t\t\t MLX90632_RAM_3(MLX90632_MAX_MEAS_NUM)),\n};\n\nstatic const struct regmap_access_table mlx90632_volatile_regs_tbl = {\n\t.yes_ranges = mlx90632_volatile_reg_range,\n\t.n_yes_ranges = ARRAY_SIZE(mlx90632_volatile_reg_range),\n};\n\nstatic const struct regmap_range mlx90632_read_reg_range[] = {\n\tregmap_reg_range(MLX90632_EE_VERSION, MLX90632_EE_Ka),\n\tregmap_reg_range(MLX90632_EE_CTRL, MLX90632_EE_I2C_ADDR),\n\tregmap_reg_range(MLX90632_EE_Ha, MLX90632_EE_Hb),\n\tregmap_reg_range(MLX90632_EE_MEDICAL_MEAS1, MLX90632_EE_MEDICAL_MEAS2),\n\tregmap_reg_range(MLX90632_EE_EXTENDED_MEAS1, MLX90632_EE_EXTENDED_MEAS3),\n\tregmap_reg_range(MLX90632_REG_I2C_ADDR, MLX90632_REG_CONTROL),\n\tregmap_reg_range(MLX90632_REG_I2C_CMD, MLX90632_REG_I2C_CMD),\n\tregmap_reg_range(MLX90632_REG_STATUS, MLX90632_REG_STATUS),\n\tregmap_reg_range(MLX90632_RAM_1(0),\n\t\t\t MLX90632_RAM_3(MLX90632_MAX_MEAS_NUM)),\n};\n\nstatic const struct regmap_access_table mlx90632_readable_regs_tbl = {\n\t.yes_ranges = mlx90632_read_reg_range,\n\t.n_yes_ranges = ARRAY_SIZE(mlx90632_read_reg_range),\n};\n\nstatic const struct regmap_range mlx90632_no_write_reg_range[] = {\n\tregmap_reg_range(MLX90632_EE_VERSION, MLX90632_EE_Ka),\n\tregmap_reg_range(MLX90632_RAM_1(0),\n\t\t\t MLX90632_RAM_3(MLX90632_MAX_MEAS_NUM)),\n};\n\nstatic const struct regmap_access_table mlx90632_writeable_regs_tbl = {\n\t.no_ranges = mlx90632_no_write_reg_range,\n\t.n_no_ranges = ARRAY_SIZE(mlx90632_no_write_reg_range),\n};\n\nstatic const struct regmap_config mlx90632_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\n\t.volatile_table = &mlx90632_volatile_regs_tbl,\n\t.rd_table = &mlx90632_readable_regs_tbl,\n\t.wr_table = &mlx90632_writeable_regs_tbl,\n\n\t.use_single_read = true,\n\t.use_single_write = true,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int mlx90632_pwr_set_sleep_step(struct regmap *regmap)\n{\n\tstruct mlx90632_data *data =\n\t\tiio_priv(dev_get_drvdata(regmap_get_device(regmap)));\n\tint ret;\n\n\tif (data->powerstatus == MLX90632_PWR_STATUS_SLEEP_STEP)\n\t\treturn 0;\n\n\tret = regmap_write_bits(regmap, MLX90632_REG_CONTROL, MLX90632_CFG_PWR_MASK,\n\t\t\t\tMLX90632_PWR_STATUS_SLEEP_STEP);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->powerstatus = MLX90632_PWR_STATUS_SLEEP_STEP;\n\treturn 0;\n}\n\nstatic int mlx90632_pwr_continuous(struct regmap *regmap)\n{\n\tstruct mlx90632_data *data =\n\t\tiio_priv(dev_get_drvdata(regmap_get_device(regmap)));\n\tint ret;\n\n\tif (data->powerstatus == MLX90632_PWR_STATUS_CONTINUOUS)\n\t\treturn 0;\n\n\tret = regmap_write_bits(regmap, MLX90632_REG_CONTROL, MLX90632_CFG_PWR_MASK,\n\t\t\t\tMLX90632_PWR_STATUS_CONTINUOUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->powerstatus = MLX90632_PWR_STATUS_CONTINUOUS;\n\treturn 0;\n}\n\n \nstatic void mlx90632_reset_delay(void)\n{\n\tusleep_range(150, 200);\n}\n\nstatic int mlx90632_get_measurement_time(struct regmap *regmap, u16 meas)\n{\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(regmap, meas, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn MLX90632_MEAS_MAX_TIME >> FIELD_GET(MLX90632_EE_RR, reg);\n}\n\nstatic int mlx90632_calculate_dataset_ready_time(struct mlx90632_data *data)\n{\n\tunsigned int refresh_time;\n\tint ret;\n\n\tif (data->mtyp == MLX90632_MTYP_MEDICAL) {\n\t\tret = mlx90632_get_measurement_time(data->regmap,\n\t\t\t\t\t\t    MLX90632_EE_MEDICAL_MEAS1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\trefresh_time = ret;\n\n\t\tret = mlx90632_get_measurement_time(data->regmap,\n\t\t\t\t\t\t    MLX90632_EE_MEDICAL_MEAS2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\trefresh_time += ret;\n\t} else {\n\t\tret = mlx90632_get_measurement_time(data->regmap,\n\t\t\t\t\t\t    MLX90632_EE_EXTENDED_MEAS1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\trefresh_time = ret;\n\n\t\tret = mlx90632_get_measurement_time(data->regmap,\n\t\t\t\t\t\t    MLX90632_EE_EXTENDED_MEAS2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\trefresh_time += ret;\n\n\t\tret = mlx90632_get_measurement_time(data->regmap,\n\t\t\t\t\t\t    MLX90632_EE_EXTENDED_MEAS3);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\trefresh_time += ret;\n\t}\n\n\treturn refresh_time;\n}\n\n \nstatic int mlx90632_perform_measurement(struct mlx90632_data *data)\n{\n\tunsigned int reg_status;\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap, MLX90632_REG_STATUS,\n\t\t\t\t MLX90632_STAT_DATA_RDY, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read_poll_timeout(data->regmap, MLX90632_REG_STATUS, reg_status,\n\t\t\t\t       !(reg_status & MLX90632_STAT_DATA_RDY), 10000,\n\t\t\t\t       100 * 10000);\n\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"data not ready\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn (reg_status & MLX90632_STAT_CYCLE_POS) >> 2;\n}\n\n \nstatic int mlx90632_perform_measurement_burst(struct mlx90632_data *data)\n{\n\tunsigned int reg_status;\n\tint ret;\n\n\tret = regmap_write_bits(data->regmap, MLX90632_REG_CONTROL,\n\t\t\t\tMLX90632_CFG_SOB_MASK, MLX90632_CFG_SOB_MASK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mlx90632_calculate_dataset_ready_time(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep(ret);  \n\n\tret = regmap_read_poll_timeout(data->regmap, MLX90632_REG_STATUS,\n\t\t\t\t       reg_status,\n\t\t\t\t       (reg_status & MLX90632_STAT_BUSY) == 0,\n\t\t\t\t       10000, 100 * 10000);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"data not ready\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 2;\n}\n\nstatic int mlx90632_set_meas_type(struct mlx90632_data *data, u8 type)\n{\n\tint current_powerstatus;\n\tint ret;\n\n\tif (data->mtyp == type)\n\t\treturn 0;\n\n\tcurrent_powerstatus = data->powerstatus;\n\tret = mlx90632_pwr_continuous(data->regmap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(data->regmap, MLX90632_REG_I2C_CMD, MLX90632_RESET_CMD);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmlx90632_reset_delay();\n\n\tret = regmap_update_bits(data->regmap, MLX90632_REG_CONTROL,\n\t\t\t\t (MLX90632_CFG_MTYP_MASK | MLX90632_CFG_PWR_MASK),\n\t\t\t\t (MLX90632_MTYP_STATUS(type) | MLX90632_PWR_STATUS_HALT));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->mtyp = type;\n\tdata->powerstatus = MLX90632_PWR_STATUS_HALT;\n\n\tif (current_powerstatus == MLX90632_PWR_STATUS_SLEEP_STEP)\n\t\treturn mlx90632_pwr_set_sleep_step(data->regmap);\n\n\treturn mlx90632_pwr_continuous(data->regmap);\n}\n\nstatic int mlx90632_channel_new_select(int perform_ret, uint8_t *channel_new,\n\t\t\t\t       uint8_t *channel_old)\n{\n\tswitch (perform_ret) {\n\tcase 1:\n\t\t*channel_new = 1;\n\t\t*channel_old = 2;\n\t\tbreak;\n\tcase 2:\n\t\t*channel_new = 2;\n\t\t*channel_old = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -ECHRNG;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx90632_read_ambient_raw(struct regmap *regmap,\n\t\t\t\t     s16 *ambient_new_raw, s16 *ambient_old_raw)\n{\n\tunsigned int read_tmp;\n\tint ret;\n\n\tret = regmap_read(regmap, MLX90632_RAM_3(1), &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\t*ambient_new_raw = (s16)read_tmp;\n\n\tret = regmap_read(regmap, MLX90632_RAM_3(2), &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\t*ambient_old_raw = (s16)read_tmp;\n\n\treturn ret;\n}\n\nstatic int mlx90632_read_object_raw(struct regmap *regmap,\n\t\t\t\t    int perform_measurement_ret,\n\t\t\t\t    s16 *object_new_raw, s16 *object_old_raw)\n{\n\tunsigned int read_tmp;\n\tu8 channel_old = 0;\n\tu8 channel = 0;\n\ts16 read;\n\tint ret;\n\n\tret = mlx90632_channel_new_select(perform_measurement_ret, &channel,\n\t\t\t\t\t  &channel_old);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = regmap_read(regmap, MLX90632_RAM_2(channel), &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tread = (s16)read_tmp;\n\n\tret = regmap_read(regmap, MLX90632_RAM_1(channel), &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\t*object_new_raw = (read + (s16)read_tmp) / 2;\n\n\tret = regmap_read(regmap, MLX90632_RAM_2(channel_old), &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tread = (s16)read_tmp;\n\n\tret = regmap_read(regmap, MLX90632_RAM_1(channel_old), &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\t*object_old_raw = (read + (s16)read_tmp) / 2;\n\n\treturn ret;\n}\n\nstatic int mlx90632_read_all_channel(struct mlx90632_data *data,\n\t\t\t\t     s16 *ambient_new_raw, s16 *ambient_old_raw,\n\t\t\t\t     s16 *object_new_raw, s16 *object_old_raw)\n{\n\ts32 measurement;\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = mlx90632_set_meas_type(data, MLX90632_MTYP_MEDICAL);\n\tif (ret < 0)\n\t\tgoto read_unlock;\n\n\tswitch (data->powerstatus) {\n\tcase MLX90632_PWR_STATUS_CONTINUOUS:\n\t\tret = mlx90632_perform_measurement(data);\n\t\tif (ret < 0)\n\t\t\tgoto read_unlock;\n\n\t\tbreak;\n\tcase MLX90632_PWR_STATUS_SLEEP_STEP:\n\t\tret = mlx90632_perform_measurement_burst(data);\n\t\tif (ret < 0)\n\t\t\tgoto read_unlock;\n\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tgoto read_unlock;\n\t}\n\n\tmeasurement = ret;  \n\n\tret = mlx90632_read_ambient_raw(data->regmap, ambient_new_raw,\n\t\t\t\t\tambient_old_raw);\n\tif (ret < 0)\n\t\tgoto read_unlock;\n\n\tret = mlx90632_read_object_raw(data->regmap, measurement,\n\t\t\t\t       object_new_raw, object_old_raw);\nread_unlock:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int mlx90632_read_ambient_raw_extended(struct regmap *regmap,\n\t\t\t\t\t      s16 *ambient_new_raw, s16 *ambient_old_raw)\n{\n\tunsigned int read_tmp;\n\tint ret;\n\n\tret = regmap_read(regmap, MLX90632_RAM_DSP5_EXTENDED_AMBIENT_1, &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\t*ambient_new_raw = (s16)read_tmp;\n\n\tret = regmap_read(regmap, MLX90632_RAM_DSP5_EXTENDED_AMBIENT_2, &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\t*ambient_old_raw = (s16)read_tmp;\n\n\treturn 0;\n}\n\nstatic int mlx90632_read_object_raw_extended(struct regmap *regmap, s16 *object_new_raw)\n{\n\tunsigned int read_tmp;\n\ts32 read;\n\tint ret;\n\n\tret = regmap_read(regmap, MLX90632_RAM_DSP5_EXTENDED_OBJECT_1, &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tread = (s16)read_tmp;\n\n\tret = regmap_read(regmap, MLX90632_RAM_DSP5_EXTENDED_OBJECT_2, &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tread = read - (s16)read_tmp;\n\n\tret = regmap_read(regmap, MLX90632_RAM_DSP5_EXTENDED_OBJECT_3, &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tread = read - (s16)read_tmp;\n\n\tret = regmap_read(regmap, MLX90632_RAM_DSP5_EXTENDED_OBJECT_4, &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tread = (read + (s16)read_tmp) / 2;\n\n\tret = regmap_read(regmap, MLX90632_RAM_DSP5_EXTENDED_OBJECT_5, &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tread = read + (s16)read_tmp;\n\n\tret = regmap_read(regmap, MLX90632_RAM_DSP5_EXTENDED_OBJECT_6, &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tread = read + (s16)read_tmp;\n\n\tif (read > S16_MAX || read < S16_MIN)\n\t\treturn -ERANGE;\n\n\t*object_new_raw = read;\n\n\treturn 0;\n}\n\nstatic int mlx90632_read_all_channel_extended(struct mlx90632_data *data, s16 *object_new_raw,\n\t\t\t\t\t      s16 *ambient_new_raw, s16 *ambient_old_raw)\n{\n\ts32 ret, meas;\n\n\tmutex_lock(&data->lock);\n\tret = mlx90632_set_meas_type(data, MLX90632_MTYP_EXTENDED);\n\tif (ret < 0)\n\t\tgoto read_unlock;\n\n\tswitch (data->powerstatus) {\n\tcase MLX90632_PWR_STATUS_CONTINUOUS:\n\t\tret = read_poll_timeout(mlx90632_perform_measurement, meas, meas == 19,\n\t\t\t\t\t50000, 800000, false, data);\n\t\tif (ret)\n\t\t\tgoto read_unlock;\n\t\tbreak;\n\tcase MLX90632_PWR_STATUS_SLEEP_STEP:\n\t\tret = mlx90632_perform_measurement_burst(data);\n\t\tif (ret < 0)\n\t\t\tgoto read_unlock;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tgoto read_unlock;\n\t}\n\n\tret = mlx90632_read_object_raw_extended(data->regmap, object_new_raw);\n\tif (ret < 0)\n\t\tgoto read_unlock;\n\n\tret = mlx90632_read_ambient_raw_extended(data->regmap, ambient_new_raw, ambient_old_raw);\n\nread_unlock:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int mlx90632_read_ee_register(struct regmap *regmap, u16 reg_lsb,\n\t\t\t\t     s32 *reg_value)\n{\n\tunsigned int read;\n\tu32 value;\n\tint ret;\n\n\tret = regmap_read(regmap, reg_lsb, &read);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvalue = read;\n\n\tret = regmap_read(regmap, reg_lsb + 1, &read);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*reg_value = (read << 16) | (value & 0xffff);\n\n\treturn 0;\n}\n\nstatic s64 mlx90632_preprocess_temp_amb(s16 ambient_new_raw,\n\t\t\t\t\ts16 ambient_old_raw, s16 Gb)\n{\n\ts64 VR_Ta, kGb, tmp;\n\n\tkGb = ((s64)Gb * 1000LL) >> 10ULL;\n\tVR_Ta = (s64)ambient_old_raw * 1000000LL +\n\t\tkGb * div64_s64(((s64)ambient_new_raw * 1000LL),\n\t\t\t(MLX90632_REF_3));\n\ttmp = div64_s64(\n\t\t\t div64_s64(((s64)ambient_new_raw * 1000000000000LL),\n\t\t\t\t   (MLX90632_REF_3)), VR_Ta);\n\treturn div64_s64(tmp << 19ULL, 1000LL);\n}\n\nstatic s64 mlx90632_preprocess_temp_obj(s16 object_new_raw, s16 object_old_raw,\n\t\t\t\t\ts16 ambient_new_raw,\n\t\t\t\t\ts16 ambient_old_raw, s16 Ka)\n{\n\ts64 VR_IR, kKa, tmp;\n\n\tkKa = ((s64)Ka * 1000LL) >> 10ULL;\n\tVR_IR = (s64)ambient_old_raw * 1000000LL +\n\t\tkKa * div64_s64(((s64)ambient_new_raw * 1000LL),\n\t\t\t(MLX90632_REF_3));\n\ttmp = div64_s64(\n\t\t\tdiv64_s64(((s64)((object_new_raw + object_old_raw) / 2)\n\t\t\t\t   * 1000000000000LL), (MLX90632_REF_12)),\n\t\t\tVR_IR);\n\treturn div64_s64((tmp << 19ULL), 1000LL);\n}\n\nstatic s64 mlx90632_preprocess_temp_obj_extended(s16 object_new_raw, s16 ambient_new_raw,\n\t\t\t\t\t\t s16 ambient_old_raw, s16 Ka)\n{\n\ts64 VR_IR, kKa, tmp;\n\n\tkKa = ((s64)Ka * 1000LL) >> 10ULL;\n\tVR_IR = (s64)ambient_old_raw * 1000000LL +\n\t\tkKa * div64_s64((s64)ambient_new_raw * 1000LL,\n\t\t\t\tMLX90632_REF_3);\n\ttmp = div64_s64(\n\t\t\tdiv64_s64((s64) object_new_raw * 1000000000000LL, MLX90632_REF_12),\n\t\t\tVR_IR);\n\treturn div64_s64(tmp << 19ULL, 1000LL);\n}\n\nstatic s32 mlx90632_calc_temp_ambient(s16 ambient_new_raw, s16 ambient_old_raw,\n\t\t\t\t      s32 P_T, s32 P_R, s32 P_G, s32 P_O, s16 Gb)\n{\n\ts64 Asub, Bsub, Ablock, Bblock, Cblock, AMB, sum;\n\n\tAMB = mlx90632_preprocess_temp_amb(ambient_new_raw, ambient_old_raw,\n\t\t\t\t\t   Gb);\n\tAsub = ((s64)P_T * 10000000000LL) >> 44ULL;\n\tBsub = AMB - (((s64)P_R * 1000LL) >> 8ULL);\n\tAblock = Asub * (Bsub * Bsub);\n\tBblock = (div64_s64(Bsub * 10000000LL, P_G)) << 20ULL;\n\tCblock = ((s64)P_O * 10000000000LL) >> 8ULL;\n\n\tsum = div64_s64(Ablock, 1000000LL) + Bblock + Cblock;\n\n\treturn div64_s64(sum, 10000000LL);\n}\n\nstatic s32 mlx90632_calc_temp_object_iteration(s32 prev_object_temp, s64 object,\n\t\t\t\t\t       s64 TAdut, s64 TAdut4, s32 Fa, s32 Fb,\n\t\t\t\t\t       s32 Ga, s16 Ha, s16 Hb,\n\t\t\t\t\t       u16 emissivity)\n{\n\ts64 calcedKsTO, calcedKsTA, ir_Alpha, Alpha_corr;\n\ts64 Ha_customer, Hb_customer;\n\n\tHa_customer = ((s64)Ha * 1000000LL) >> 14ULL;\n\tHb_customer = ((s64)Hb * 100) >> 10ULL;\n\n\tcalcedKsTO = ((s64)((s64)Ga * (prev_object_temp - 25 * 1000LL)\n\t\t\t     * 1000LL)) >> 36LL;\n\tcalcedKsTA = ((s64)(Fb * (TAdut - 25 * 1000000LL))) >> 36LL;\n\tAlpha_corr = div64_s64((((s64)(Fa * 10000000000LL) >> 46LL)\n\t\t\t\t* Ha_customer), 1000LL);\n\tAlpha_corr *= ((s64)(1 * 1000000LL + calcedKsTO + calcedKsTA));\n\tAlpha_corr = emissivity * div64_s64(Alpha_corr, 100000LL);\n\tAlpha_corr = div64_s64(Alpha_corr, 1000LL);\n\tir_Alpha = div64_s64((s64)object * 10000000LL, Alpha_corr);\n\n\treturn (int_sqrt64(int_sqrt64(ir_Alpha * 1000000000000LL + TAdut4))\n\t\t- 27315 - Hb_customer) * 10;\n}\n\nstatic s64 mlx90632_calc_ta4(s64 TAdut, s64 scale)\n{\n\treturn (div64_s64(TAdut, scale) + 27315) *\n\t\t(div64_s64(TAdut, scale) + 27315) *\n\t\t(div64_s64(TAdut, scale) + 27315) *\n\t\t(div64_s64(TAdut, scale) + 27315);\n}\n\nstatic s32 mlx90632_calc_temp_object(s64 object, s64 ambient, s32 Ea, s32 Eb,\n\t\t\t\t     s32 Fa, s32 Fb, s32 Ga, s16 Ha, s16 Hb,\n\t\t\t\t     u16 tmp_emi)\n{\n\ts64 kTA, kTA0, TAdut, TAdut4;\n\ts64 temp = 25000;\n\ts8 i;\n\n\tkTA = (Ea * 1000LL) >> 16LL;\n\tkTA0 = (Eb * 1000LL) >> 8LL;\n\tTAdut = div64_s64(((ambient - kTA0) * 1000000LL), kTA) + 25 * 1000000LL;\n\tTAdut4 = mlx90632_calc_ta4(TAdut, 10000LL);\n\n\t \n\tfor (i = 0; i < 5; ++i) {\n\t\ttemp = mlx90632_calc_temp_object_iteration(temp, object, TAdut, TAdut4,\n\t\t\t\t\t\t\t   Fa, Fb, Ga, Ha, Hb,\n\t\t\t\t\t\t\t   tmp_emi);\n\t}\n\treturn temp;\n}\n\nstatic s32 mlx90632_calc_temp_object_extended(s64 object, s64 ambient, s64 reflected,\n\t\t\t\t\t      s32 Ea, s32 Eb, s32 Fa, s32 Fb, s32 Ga,\n\t\t\t\t\t      s16 Ha, s16 Hb, u16 tmp_emi)\n{\n\ts64 kTA, kTA0, TAdut, TAdut4, Tr4, TaTr4;\n\ts64 temp = 25000;\n\ts8 i;\n\n\tkTA = (Ea * 1000LL) >> 16LL;\n\tkTA0 = (Eb * 1000LL) >> 8LL;\n\tTAdut = div64_s64((ambient - kTA0) * 1000000LL, kTA) + 25 * 1000000LL;\n\tTr4 = mlx90632_calc_ta4(reflected, 10);\n\tTAdut4 = mlx90632_calc_ta4(TAdut, 10000LL);\n\tTaTr4 = Tr4 - div64_s64(Tr4 - TAdut4, tmp_emi) * 1000;\n\n\t \n\tfor (i = 0; i < 5; ++i) {\n\t\ttemp = mlx90632_calc_temp_object_iteration(temp, object, TAdut, TaTr4,\n\t\t\t\t\t\t\t   Fa / 2, Fb, Ga, Ha, Hb,\n\t\t\t\t\t\t\t   tmp_emi);\n\t}\n\n\treturn temp;\n}\n\nstatic int mlx90632_calc_object_dsp105(struct mlx90632_data *data, int *val)\n{\n\ts16 ambient_new_raw, ambient_old_raw, object_new_raw, object_old_raw;\n\ts32 Ea, Eb, Fa, Fb, Ga;\n\tunsigned int read_tmp;\n\ts64 object, ambient;\n\ts16 Ha, Hb, Gb, Ka;\n\tint ret;\n\n\tret = mlx90632_read_ee_register(data->regmap, MLX90632_EE_Ea, &Ea);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mlx90632_read_ee_register(data->regmap, MLX90632_EE_Eb, &Eb);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mlx90632_read_ee_register(data->regmap, MLX90632_EE_Fa, &Fa);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mlx90632_read_ee_register(data->regmap, MLX90632_EE_Fb, &Fb);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mlx90632_read_ee_register(data->regmap, MLX90632_EE_Ga, &Ga);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = regmap_read(data->regmap, MLX90632_EE_Ha, &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tHa = (s16)read_tmp;\n\tret = regmap_read(data->regmap, MLX90632_EE_Hb, &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tHb = (s16)read_tmp;\n\tret = regmap_read(data->regmap, MLX90632_EE_Gb, &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tGb = (s16)read_tmp;\n\tret = regmap_read(data->regmap, MLX90632_EE_Ka, &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tKa = (s16)read_tmp;\n\n\tret = mlx90632_read_all_channel(data,\n\t\t\t\t\t&ambient_new_raw, &ambient_old_raw,\n\t\t\t\t\t&object_new_raw, &object_old_raw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (object_new_raw > MLX90632_EXTENDED_LIMIT &&\n\t    data->mtyp == MLX90632_MTYP_EXTENDED) {\n\t\tret = mlx90632_read_all_channel_extended(data, &object_new_raw,\n\t\t\t\t\t\t\t &ambient_new_raw, &ambient_old_raw);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tambient = mlx90632_preprocess_temp_amb(ambient_new_raw,\n\t\t\t\t\t\t       ambient_old_raw, Gb);\n\t\tobject = mlx90632_preprocess_temp_obj_extended(object_new_raw,\n\t\t\t\t\t\t\t       ambient_new_raw,\n\t\t\t\t\t\t\t       ambient_old_raw, Ka);\n\t\t*val = mlx90632_calc_temp_object_extended(object, ambient,\n\t\t\t\t\t\t\t  data->object_ambient_temperature,\n\t\t\t\t\t\t\t  Ea, Eb, Fa, Fb, Ga,\n\t\t\t\t\t\t\t  Ha, Hb, data->emissivity);\n\t\treturn 0;\n\t}\n\n\tambient = mlx90632_preprocess_temp_amb(ambient_new_raw,\n\t\t\t\t\t       ambient_old_raw, Gb);\n\tobject = mlx90632_preprocess_temp_obj(object_new_raw,\n\t\t\t\t\t      object_old_raw,\n\t\t\t\t\t      ambient_new_raw,\n\t\t\t\t\t      ambient_old_raw, Ka);\n\n\t*val = mlx90632_calc_temp_object(object, ambient, Ea, Eb, Fa, Fb, Ga,\n\t\t\t\t\t Ha, Hb, data->emissivity);\n\treturn 0;\n}\n\nstatic int mlx90632_calc_ambient_dsp105(struct mlx90632_data *data, int *val)\n{\n\ts16 ambient_new_raw, ambient_old_raw;\n\tunsigned int read_tmp;\n\ts32 PT, PR, PG, PO;\n\tint ret;\n\ts16 Gb;\n\n\tret = mlx90632_read_ee_register(data->regmap, MLX90632_EE_P_R, &PR);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mlx90632_read_ee_register(data->regmap, MLX90632_EE_P_G, &PG);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mlx90632_read_ee_register(data->regmap, MLX90632_EE_P_T, &PT);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mlx90632_read_ee_register(data->regmap, MLX90632_EE_P_O, &PO);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = regmap_read(data->regmap, MLX90632_EE_Gb, &read_tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tGb = (s16)read_tmp;\n\n\tret = mlx90632_read_ambient_raw(data->regmap, &ambient_new_raw,\n\t\t\t\t\t&ambient_old_raw);\n\tif (ret < 0)\n\t\treturn ret;\n\t*val = mlx90632_calc_temp_ambient(ambient_new_raw, ambient_old_raw,\n\t\t\t\t\t  PT, PR, PG, PO, Gb);\n\treturn ret;\n}\n\nstatic int mlx90632_get_refresh_rate(struct mlx90632_data *data,\n\t\t\t\t     int *refresh_rate)\n{\n\tunsigned int meas1;\n\tint ret;\n\n\tret = regmap_read(data->regmap, MLX90632_EE_MEDICAL_MEAS1, &meas1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*refresh_rate = MLX90632_REFRESH_RATE(meas1);\n\n\treturn ret;\n}\n\nstatic const int mlx90632_freqs[][2] = {\n\t{0, 500000},\n\t{1, 0},\n\t{2, 0},\n\t{4, 0},\n\t{8, 0},\n\t{16, 0},\n\t{32, 0},\n\t{64, 0}\n};\n\n \nstatic int mlx90632_pm_interraction_wakeup(struct mlx90632_data *data)\n{\n\tunsigned long now;\n\tint ret;\n\n\tnow = jiffies;\n\tif (time_in_range(now, data->interaction_ts,\n\t\t\t  data->interaction_ts +\n\t\t\t  msecs_to_jiffies(MLX90632_MEAS_MAX_TIME + 100))) {\n\t\tif (data->powerstatus == MLX90632_PWR_STATUS_SLEEP_STEP) {\n\t\t\tret = mlx90632_pwr_continuous(data->regmap);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdata->interaction_ts = now;\n\n\treturn 0;\n}\n\nstatic int mlx90632_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *channel, int *val,\n\t\t\t     int *val2, long mask)\n{\n\tstruct mlx90632_data *data = iio_priv(indio_dev);\n\tint ret;\n\tint cr;\n\n\tpm_runtime_get_sync(&data->client->dev);\n\tret = mlx90632_pm_interraction_wakeup(data);\n\tif (ret < 0)\n\t\tgoto mlx90632_read_raw_pm;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\t\tswitch (channel->channel2) {\n\t\tcase IIO_MOD_TEMP_AMBIENT:\n\t\t\tret = mlx90632_calc_ambient_dsp105(data, val);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto mlx90632_read_raw_pm;\n\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_MOD_TEMP_OBJECT:\n\t\t\tret = mlx90632_calc_object_dsp105(data, val);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto mlx90632_read_raw_pm;\n\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBEMISSIVITY:\n\t\tif (data->emissivity == 1000) {\n\t\t\t*val = 1;\n\t\t\t*val2 = 0;\n\t\t} else {\n\t\t\t*val = 0;\n\t\t\t*val2 = data->emissivity * 1000;\n\t\t}\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBAMBIENT:\n\t\t*val = data->object_ambient_temperature;\n\t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = mlx90632_get_refresh_rate(data, &cr);\n\t\tif (ret < 0)\n\t\t\tgoto mlx90632_read_raw_pm;\n\n\t\t*val = mlx90632_freqs[cr][0];\n\t\t*val2 = mlx90632_freqs[cr][1];\n\t\tret = IIO_VAL_INT_PLUS_MICRO;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nmlx90632_read_raw_pm:\n\tpm_runtime_mark_last_busy(&data->client->dev);\n\tpm_runtime_put_autosuspend(&data->client->dev);\n\treturn ret;\n}\n\nstatic int mlx90632_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *channel, int val,\n\t\t\t      int val2, long mask)\n{\n\tstruct mlx90632_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBEMISSIVITY:\n\t\t \n\t\tif (val < 0 || val2 < 0 || val > 1 ||\n\t\t    (val == 1 && val2 != 0))\n\t\t\treturn -EINVAL;\n\t\tdata->emissivity = val * 1000 + val2 / 1000;\n\t\treturn 0;\n\tcase IIO_CHAN_INFO_CALIBAMBIENT:\n\t\tdata->object_ambient_temperature = val;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mlx90632_read_avail(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length,\n\t\t\t       long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*vals = (int *)mlx90632_freqs;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t*length = 2 * ARRAY_SIZE(mlx90632_freqs);\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_chan_spec mlx90632_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_TEMP_AMBIENT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_TEMP_OBJECT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |\n\t\t\tBIT(IIO_CHAN_INFO_CALIBEMISSIVITY) | BIT(IIO_CHAN_INFO_CALIBAMBIENT),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t},\n};\n\nstatic const struct iio_info mlx90632_info = {\n\t.read_raw = mlx90632_read_raw,\n\t.write_raw = mlx90632_write_raw,\n\t.read_avail = mlx90632_read_avail,\n};\n\nstatic void mlx90632_sleep(void *_data)\n{\n\tstruct mlx90632_data *data = _data;\n\n\tmlx90632_pwr_set_sleep_step(data->regmap);\n}\n\nstatic int mlx90632_suspend(struct mlx90632_data *data)\n{\n\tregcache_mark_dirty(data->regmap);\n\n\tdev_dbg(&data->client->dev, \"Requesting suspend\");\n\treturn mlx90632_pwr_set_sleep_step(data->regmap);\n}\n\nstatic int mlx90632_wakeup(struct mlx90632_data *data)\n{\n\tint ret;\n\n\tret = regcache_sync(data->regmap);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev,\n\t\t\t\"Failed to sync regmap registers: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&data->client->dev, \"Requesting wake-up\\n\");\n\treturn mlx90632_pwr_continuous(data->regmap);\n}\n\nstatic void mlx90632_disable_regulator(void *_data)\n{\n\tstruct mlx90632_data *data = _data;\n\tint ret;\n\n\tret = regulator_disable(data->regulator);\n\tif (ret < 0)\n\t\tdev_err(regmap_get_device(data->regmap),\n\t\t\t\"Failed to disable power regulator: %d\\n\", ret);\n}\n\nstatic int mlx90632_enable_regulator(struct mlx90632_data *data)\n{\n\tint ret;\n\n\tret = regulator_enable(data->regulator);\n\tif (ret < 0) {\n\t\tdev_err(regmap_get_device(data->regmap), \"Failed to enable power regulator!\\n\");\n\t\treturn ret;\n\t}\n\n\tmlx90632_reset_delay();\n\n\treturn ret;\n}\n\nstatic int mlx90632_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct mlx90632_data *mlx90632;\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *regmap;\n\tunsigned int read;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*mlx90632));\n\tif (!indio_dev) {\n\t\tdev_err(&client->dev, \"Failed to allocate device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tregmap = devm_regmap_init_i2c(client, &mlx90632_regmap);\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmlx90632 = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tmlx90632->client = client;\n\tmlx90632->regmap = regmap;\n\tmlx90632->mtyp = MLX90632_MTYP_MEDICAL;\n\tmlx90632->powerstatus = MLX90632_PWR_STATUS_HALT;\n\n\tmutex_init(&mlx90632->lock);\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &mlx90632_info;\n\tindio_dev->channels = mlx90632_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mlx90632_channels);\n\n\tmlx90632->regulator = devm_regulator_get(&client->dev, \"vdd\");\n\tif (IS_ERR(mlx90632->regulator))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(mlx90632->regulator),\n\t\t\t\t     \"failed to get vdd regulator\");\n\n\tret = mlx90632_enable_regulator(mlx90632);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&client->dev, mlx90632_disable_regulator,\n\t\t\t\t       mlx90632);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to setup regulator cleanup action %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = mlx90632_wakeup(mlx90632);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Wakeup failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&client->dev, mlx90632_sleep, mlx90632);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to setup low power cleanup action %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(mlx90632->regmap, MLX90632_EE_VERSION, &read);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"read of version failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tread = read & MLX90632_ID_MASK;\n\tif (read == MLX90632_ID_MEDICAL) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"Detected Medical EEPROM calibration %x\\n\", read);\n\t} else if (read == MLX90632_ID_CONSUMER) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"Detected Consumer EEPROM calibration %x\\n\", read);\n\t} else if (read == MLX90632_ID_EXTENDED) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"Detected Extended range EEPROM calibration %x\\n\", read);\n\t\tmlx90632->mtyp = MLX90632_MTYP_EXTENDED;\n\t} else if ((read & MLX90632_DSP_MASK) == MLX90632_DSP_VERSION) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"Detected Unknown EEPROM calibration %x\\n\", read);\n\t} else {\n\t\tdev_err(&client->dev,\n\t\t\t\"Wrong DSP version %x (expected %x)\\n\",\n\t\t\tread, MLX90632_DSP_VERSION);\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\tmlx90632->emissivity = 1000;\n\tmlx90632->object_ambient_temperature = 25000;  \n\tmlx90632->interaction_ts = jiffies;  \n\n\tpm_runtime_get_noresume(&client->dev);\n\tpm_runtime_set_active(&client->dev);\n\n\tret = devm_pm_runtime_enable(&client->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_set_autosuspend_delay(&client->dev, MLX90632_SLEEP_DELAY_MS);\n\tpm_runtime_use_autosuspend(&client->dev);\n\tpm_runtime_put_autosuspend(&client->dev);\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct i2c_device_id mlx90632_id[] = {\n\t{ \"mlx90632\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mlx90632_id);\n\nstatic const struct of_device_id mlx90632_of_match[] = {\n\t{ .compatible = \"melexis,mlx90632\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mlx90632_of_match);\n\nstatic int mlx90632_pm_suspend(struct device *dev)\n{\n\tstruct mlx90632_data *data = iio_priv(dev_get_drvdata(dev));\n\tint ret;\n\n\tret = mlx90632_suspend(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regulator_disable(data->regulator);\n\tif (ret < 0)\n\t\tdev_err(regmap_get_device(data->regmap),\n\t\t\t\"Failed to disable power regulator: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int mlx90632_pm_resume(struct device *dev)\n{\n\tstruct mlx90632_data *data = iio_priv(dev_get_drvdata(dev));\n\tint ret;\n\n\tret = mlx90632_enable_regulator(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mlx90632_wakeup(data);\n}\n\nstatic int mlx90632_pm_runtime_suspend(struct device *dev)\n{\n\tstruct mlx90632_data *data = iio_priv(dev_get_drvdata(dev));\n\n\treturn mlx90632_pwr_set_sleep_step(data->regmap);\n}\n\nstatic const struct dev_pm_ops mlx90632_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(mlx90632_pm_suspend, mlx90632_pm_resume)\n\tRUNTIME_PM_OPS(mlx90632_pm_runtime_suspend, NULL, NULL)\n};\n\nstatic struct i2c_driver mlx90632_driver = {\n\t.driver = {\n\t\t.name\t= \"mlx90632\",\n\t\t.of_match_table = mlx90632_of_match,\n\t\t.pm\t= pm_ptr(&mlx90632_pm_ops),\n\t},\n\t.probe = mlx90632_probe,\n\t.id_table = mlx90632_id,\n};\nmodule_i2c_driver(mlx90632_driver);\n\nMODULE_AUTHOR(\"Crt Mori <cmo@melexis.com>\");\nMODULE_DESCRIPTION(\"Melexis MLX90632 contactless Infra Red temperature sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}