{
  "module_name": "mlx90614.c",
  "hash_id": "30ec3913a34776e463b63b1cab07f3e291ed14a7cacb59eaae61ea3de3aa7f80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/temperature/mlx90614.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/jiffies.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define MLX90614_OP_RAM\t\t0x00\n#define MLX90614_OP_EEPROM\t0x20\n#define MLX90614_OP_SLEEP\t0xff\n\n#define MLX90615_OP_EEPROM\t0x10\n#define MLX90615_OP_RAM\t\t0x20\n#define MLX90615_OP_SLEEP\t0xc6\n\n \n#define MLX90614_CONFIG_IIR_SHIFT 0  \n#define MLX90614_CONFIG_IIR_MASK (0x7 << MLX90614_CONFIG_IIR_SHIFT)\n#define MLX90614_CONFIG_DUAL_SHIFT 6  \n#define MLX90614_CONFIG_DUAL_MASK (1 << MLX90614_CONFIG_DUAL_SHIFT)\n#define MLX90614_CONFIG_FIR_SHIFT 8  \n#define MLX90614_CONFIG_FIR_MASK (0x7 << MLX90614_CONFIG_FIR_SHIFT)\n\n#define MLX90615_CONFIG_IIR_SHIFT 12  \n#define MLX90615_CONFIG_IIR_MASK (0x7 << MLX90615_CONFIG_IIR_SHIFT)\n\n \n#define MLX90614_TIMING_EEPROM 20  \n#define MLX90614_TIMING_WAKEUP 34  \n#define MLX90614_TIMING_STARTUP 250  \n\n#define MLX90615_TIMING_WAKEUP 22  \n\n#define MLX90614_AUTOSLEEP_DELAY 5000  \n\n \n#define MLX90614_CONST_OFFSET_DEC -13657  \n#define MLX90614_CONST_OFFSET_REM 500000  \n#define MLX90614_CONST_SCALE 20  \n#define MLX90614_CONST_FIR 0x7  \n\n \n#define field_get(_mask, _reg)\t(((_reg) & (_mask)) >> (ffs(_mask) - 1))\n#define field_prep(_mask, _val)\t(((_val) << (ffs(_mask) - 1)) & (_mask))\n\nstruct mlx_chip_info {\n\t \n\t \n\tu8\t\t\top_eeprom_emissivity;\n\tu8\t\t\top_eeprom_config1;\n\t \n\t \n\tu8\t\t\top_ram_ta;\n\t \n\tu8\t\t\top_ram_tobj1;\n\t \n\tu8\t\t\top_ram_tobj2;\n\tu8\t\t\top_sleep;\n\t \n\tu8\t\t\tdual_channel;\n\tu8\t\t\twakeup_delay_ms;\n\tu16\t\t\temissivity_max;\n\tu16\t\t\tfir_config_mask;\n\tu16\t\t\tiir_config_mask;\n\tint\t\t\tiir_valid_offset;\n\tu16\t\t\tiir_values[8];\n\tint\t\t\tiir_freqs[8][2];\n};\n\nstruct mlx90614_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;  \n\tstruct gpio_desc *wakeup_gpio;  \n\tconst struct mlx_chip_info *chip_info;  \n\tunsigned long ready_timestamp;  \n};\n\n \nstatic s32 mlx90614_write_word(const struct i2c_client *client, u8 command,\n\t\t\t       u16 value)\n{\n\t \n\tunion i2c_smbus_data data;\n\ts32 ret;\n\n\tdev_dbg(&client->dev, \"Writing 0x%x to address 0x%x\", value, command);\n\n\tdata.word = 0x0000;  \n\tret = i2c_smbus_xfer(client->adapter, client->addr,\n\t\t\t     client->flags | I2C_CLIENT_PEC,\n\t\t\t     I2C_SMBUS_WRITE, command,\n\t\t\t     I2C_SMBUS_WORD_DATA, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep(MLX90614_TIMING_EEPROM);\n\n\tdata.word = value;  \n\tret = i2c_smbus_xfer(client->adapter, client->addr,\n\t\t\t     client->flags | I2C_CLIENT_PEC,\n\t\t\t     I2C_SMBUS_WRITE, command,\n\t\t\t     I2C_SMBUS_WORD_DATA, &data);\n\n\tmsleep(MLX90614_TIMING_EEPROM);\n\n\treturn ret;\n}\n\n \nstatic inline s32 mlx90614_iir_search(const struct i2c_client *client,\n\t\t\t\t      int value)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct mlx90614_data *data = iio_priv(indio_dev);\n\tconst struct mlx_chip_info *chip_info = data->chip_info;\n\tint i;\n\ts32 ret;\n\n\tfor (i = chip_info->iir_valid_offset;\n\t     i < ARRAY_SIZE(chip_info->iir_values);\n\t     i++) {\n\t\tif (value == chip_info->iir_values[i])\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(chip_info->iir_values))\n\t\treturn -EINVAL;\n\n\t \n\tret = i2c_smbus_read_word_data(client, chip_info->op_eeprom_config1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (chip_info->fir_config_mask) {\n\t\tret &= ~chip_info->fir_config_mask;\n\t\tret |= field_prep(chip_info->fir_config_mask, MLX90614_CONST_FIR);\n\t}\n\n\tret &= ~chip_info->iir_config_mask;\n\tret |= field_prep(chip_info->iir_config_mask, i);\n\n\t \n\tret = mlx90614_write_word(client, chip_info->op_eeprom_config1, ret);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\n \nstatic int mlx90614_power_get(struct mlx90614_data *data, bool startup)\n{\n\tunsigned long now;\n\tint ret;\n\n\tif (!data->wakeup_gpio)\n\t\treturn 0;\n\n\tret = pm_runtime_resume_and_get(&data->client->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (startup) {\n\t\tnow = jiffies;\n\t\tif (time_before(now, data->ready_timestamp) &&\n\t\t    msleep_interruptible(jiffies_to_msecs(\n\t\t\t\tdata->ready_timestamp - now)) != 0) {\n\t\t\tpm_runtime_put_autosuspend(&data->client->dev);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void mlx90614_power_put(struct mlx90614_data *data)\n{\n\tif (!data->wakeup_gpio)\n\t\treturn;\n\n\tpm_runtime_mark_last_busy(&data->client->dev);\n\tpm_runtime_put_autosuspend(&data->client->dev);\n}\n#else\nstatic inline int mlx90614_power_get(struct mlx90614_data *data, bool startup)\n{\n\treturn 0;\n}\n\nstatic inline void mlx90614_power_put(struct mlx90614_data *data)\n{\n}\n#endif\n\nstatic int mlx90614_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *channel, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct mlx90614_data *data = iio_priv(indio_dev);\n\tconst struct mlx_chip_info *chip_info = data->chip_info;\n\tu8 cmd, idx;\n\ts32 ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:  \n\t\tswitch (channel->channel2) {\n\t\tcase IIO_MOD_TEMP_AMBIENT:\n\t\t\tcmd = chip_info->op_ram_ta;\n\t\t\tbreak;\n\t\tcase IIO_MOD_TEMP_OBJECT:\n\t\t\tif (chip_info->dual_channel && channel->channel)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tswitch (channel->channel) {\n\t\t\tcase 0:\n\t\t\t\tcmd = chip_info->op_ram_tobj1;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcmd = chip_info->op_ram_tobj2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = mlx90614_power_get(data, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = i2c_smbus_read_word_data(data->client, cmd);\n\t\tmlx90614_power_put(data);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (ret & 0x8000)\n\t\t\treturn -EIO;\n\n\t\t*val = ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = MLX90614_CONST_OFFSET_DEC;\n\t\t*val2 = MLX90614_CONST_OFFSET_REM;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = MLX90614_CONST_SCALE;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_CALIBEMISSIVITY:  \n\t\tret = mlx90614_power_get(data, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&data->lock);\n\t\tret = i2c_smbus_read_word_data(data->client,\n\t\t\t\t\t       chip_info->op_eeprom_emissivity);\n\t\tmutex_unlock(&data->lock);\n\t\tmlx90614_power_put(data);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret == chip_info->emissivity_max) {\n\t\t\t*val = 1;\n\t\t\t*val2 = 0;\n\t\t} else {\n\t\t\t*val = 0;\n\t\t\t*val2 = ret * NSEC_PER_SEC / chip_info->emissivity_max;\n\t\t}\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\t \n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\tret = mlx90614_power_get(data, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&data->lock);\n\t\tret = i2c_smbus_read_word_data(data->client,\n\t\t\t\t\t       chip_info->op_eeprom_config1);\n\t\tmutex_unlock(&data->lock);\n\t\tmlx90614_power_put(data);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tidx = field_get(chip_info->iir_config_mask, ret) -\n\t\t      chip_info->iir_valid_offset;\n\n\t\t*val = chip_info->iir_values[idx] / 100;\n\t\t*val2 = (chip_info->iir_values[idx] % 100) * 10000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mlx90614_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *channel, int val,\n\t\t\t     int val2, long mask)\n{\n\tstruct mlx90614_data *data = iio_priv(indio_dev);\n\tconst struct mlx_chip_info *chip_info = data->chip_info;\n\ts32 ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBEMISSIVITY:  \n\t\tif (val < 0 || val2 < 0 || val > 1 || (val == 1 && val2 != 0))\n\t\t\treturn -EINVAL;\n\t\tval = val * chip_info->emissivity_max +\n\t\t      val2 * chip_info->emissivity_max / NSEC_PER_SEC;\n\n\t\tret = mlx90614_power_get(data, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&data->lock);\n\t\tret = mlx90614_write_word(data->client,\n\t\t\t\t\t  chip_info->op_eeprom_emissivity, val);\n\t\tmutex_unlock(&data->lock);\n\t\tmlx90614_power_put(data);\n\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:  \n\t\tif (val < 0 || val2 < 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = mlx90614_power_get(data, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&data->lock);\n\t\tret = mlx90614_iir_search(data->client,\n\t\t\t\t\t  val * 100 + val2 / 10000);\n\t\tmutex_unlock(&data->lock);\n\t\tmlx90614_power_put(data);\n\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mlx90614_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t     struct iio_chan_spec const *channel,\n\t\t\t\t     long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBEMISSIVITY:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mlx90614_read_avail(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length,\n\t\t\t       long mask)\n{\n\tstruct mlx90614_data *data = iio_priv(indio_dev);\n\tconst struct mlx_chip_info *chip_info = data->chip_info;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\n\t\t*vals = (int *)chip_info->iir_freqs;\n\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t*length = 2 * (ARRAY_SIZE(chip_info->iir_freqs) -\n\t\t\t       chip_info->iir_valid_offset);\n\t\treturn IIO_AVAIL_LIST;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_chan_spec mlx90614_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_TEMP_AMBIENT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET) |\n\t\t    BIT(IIO_CHAN_INFO_SCALE),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_TEMP_OBJECT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t    BIT(IIO_CHAN_INFO_CALIBEMISSIVITY) |\n\t\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t\t.info_mask_separate_available =\n\t\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET) |\n\t\t    BIT(IIO_CHAN_INFO_SCALE),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.indexed = 1,\n\t\t.modified = 1,\n\t\t.channel = 1,\n\t\t.channel2 = IIO_MOD_TEMP_OBJECT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t    BIT(IIO_CHAN_INFO_CALIBEMISSIVITY) |\n\t\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t\t.info_mask_separate_available =\n\t\t\tBIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET) |\n\t\t    BIT(IIO_CHAN_INFO_SCALE),\n\t},\n};\n\nstatic const struct iio_info mlx90614_info = {\n\t.read_raw = mlx90614_read_raw,\n\t.write_raw = mlx90614_write_raw,\n\t.write_raw_get_fmt = mlx90614_write_raw_get_fmt,\n\t.read_avail = mlx90614_read_avail,\n};\n\n#ifdef CONFIG_PM\nstatic int mlx90614_sleep(struct mlx90614_data *data)\n{\n\tconst struct mlx_chip_info *chip_info = data->chip_info;\n\ts32 ret;\n\n\tif (!data->wakeup_gpio) {\n\t\tdev_dbg(&data->client->dev, \"Sleep disabled\");\n\t\treturn -ENOSYS;\n\t}\n\n\tdev_dbg(&data->client->dev, \"Requesting sleep\");\n\n\tmutex_lock(&data->lock);\n\tret = i2c_smbus_xfer(data->client->adapter, data->client->addr,\n\t\t\t     data->client->flags | I2C_CLIENT_PEC,\n\t\t\t     I2C_SMBUS_WRITE, chip_info->op_sleep,\n\t\t\t     I2C_SMBUS_BYTE, NULL);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int mlx90614_wakeup(struct mlx90614_data *data)\n{\n\tconst struct mlx_chip_info *chip_info = data->chip_info;\n\n\tif (!data->wakeup_gpio) {\n\t\tdev_dbg(&data->client->dev, \"Wake-up disabled\");\n\t\treturn -ENOSYS;\n\t}\n\n\tdev_dbg(&data->client->dev, \"Requesting wake-up\");\n\n\ti2c_lock_bus(data->client->adapter, I2C_LOCK_ROOT_ADAPTER);\n\tgpiod_direction_output(data->wakeup_gpio, 0);\n\tmsleep(chip_info->wakeup_delay_ms);\n\tgpiod_direction_input(data->wakeup_gpio);\n\ti2c_unlock_bus(data->client->adapter, I2C_LOCK_ROOT_ADAPTER);\n\n\tdata->ready_timestamp = jiffies +\n\t\t\tmsecs_to_jiffies(MLX90614_TIMING_STARTUP);\n\n\t \n\ti2c_smbus_read_word_data(data->client, chip_info->op_eeprom_config1);\n\n\treturn 0;\n}\n\n \nstatic struct gpio_desc *mlx90614_probe_wakeup(struct i2c_client *client)\n{\n\tstruct gpio_desc *gpio;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t\t\tI2C_FUNC_SMBUS_WRITE_BYTE)) {\n\t\tdev_info(&client->dev,\n\t\t\t \"i2c adapter does not support SMBUS_WRITE_BYTE, sleep disabled\");\n\t\treturn NULL;\n\t}\n\n\tgpio = devm_gpiod_get_optional(&client->dev, \"wakeup\", GPIOD_IN);\n\n\tif (IS_ERR(gpio)) {\n\t\tdev_warn(&client->dev,\n\t\t\t \"gpio acquisition failed with error %ld, sleep disabled\",\n\t\t\t PTR_ERR(gpio));\n\t\treturn NULL;\n\t} else if (!gpio) {\n\t\tdev_info(&client->dev,\n\t\t\t \"wakeup-gpio not found, sleep disabled\");\n\t}\n\n\treturn gpio;\n}\n#else\nstatic inline int mlx90614_sleep(struct mlx90614_data *data)\n{\n\treturn -ENOSYS;\n}\nstatic inline int mlx90614_wakeup(struct mlx90614_data *data)\n{\n\treturn -ENOSYS;\n}\nstatic inline struct gpio_desc *mlx90614_probe_wakeup(struct i2c_client *client)\n{\n\treturn NULL;\n}\n#endif\n\n \nstatic int mlx90614_probe_num_ir_sensors(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct mlx90614_data *data = iio_priv(indio_dev);\n\tconst struct mlx_chip_info *chip_info = data->chip_info;\n\ts32 ret;\n\n\tif (chip_info->dual_channel)\n\t\treturn 0;\n\n\tret = i2c_smbus_read_word_data(client, chip_info->op_eeprom_config1);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (ret & MLX90614_CONFIG_DUAL_MASK) ? 1 : 0;\n}\n\nstatic int mlx90614_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct iio_dev *indio_dev;\n\tstruct mlx90614_data *data;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\tdata->wakeup_gpio = mlx90614_probe_wakeup(client);\n\tdata->chip_info = device_get_match_data(&client->dev);\n\n\tmlx90614_wakeup(data);\n\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &mlx90614_info;\n\n\tret = mlx90614_probe_num_ir_sensors(client);\n\tswitch (ret) {\n\tcase 0:\n\t\tdev_dbg(&client->dev, \"Found single sensor\");\n\t\tindio_dev->channels = mlx90614_channels;\n\t\tindio_dev->num_channels = 2;\n\t\tbreak;\n\tcase 1:\n\t\tdev_dbg(&client->dev, \"Found dual sensor\");\n\t\tindio_dev->channels = mlx90614_channels;\n\t\tindio_dev->num_channels = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn ret;\n\t}\n\n\tif (data->wakeup_gpio) {\n\t\tpm_runtime_set_autosuspend_delay(&client->dev,\n\t\t\t\t\t\t MLX90614_AUTOSLEEP_DELAY);\n\t\tpm_runtime_use_autosuspend(&client->dev);\n\t\tpm_runtime_set_active(&client->dev);\n\t\tpm_runtime_enable(&client->dev);\n\t}\n\n\treturn iio_device_register(indio_dev);\n}\n\nstatic void mlx90614_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct mlx90614_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tif (data->wakeup_gpio) {\n\t\tpm_runtime_disable(&client->dev);\n\t\tif (!pm_runtime_status_suspended(&client->dev))\n\t\t\tmlx90614_sleep(data);\n\t\tpm_runtime_set_suspended(&client->dev);\n\t}\n}\n\nstatic const struct mlx_chip_info mlx90614_chip_info = {\n\t.op_eeprom_emissivity\t\t= MLX90614_OP_EEPROM | 0x04,\n\t.op_eeprom_config1\t\t= MLX90614_OP_EEPROM | 0x05,\n\t.op_ram_ta\t\t\t= MLX90614_OP_RAM | 0x06,\n\t.op_ram_tobj1\t\t\t= MLX90614_OP_RAM | 0x07,\n\t.op_ram_tobj2\t\t\t= MLX90614_OP_RAM | 0x08,\n\t.op_sleep\t\t\t= MLX90614_OP_SLEEP,\n\t.dual_channel\t\t\t= true,\n\t.wakeup_delay_ms\t\t= MLX90614_TIMING_WAKEUP,\n\t.emissivity_max\t\t\t= 65535,\n\t.fir_config_mask\t\t= MLX90614_CONFIG_FIR_MASK,\n\t.iir_config_mask\t\t= MLX90614_CONFIG_IIR_MASK,\n\t.iir_valid_offset\t\t= 0,\n\t.iir_values\t\t\t= { 77, 31, 20, 15, 723, 153, 110, 86 },\n\t.iir_freqs\t\t\t= {\n\t\t{ 0, 150000 },\t \n\t\t{ 0, 200000 },\t \n\t\t{ 0, 310000 },\t \n\t\t{ 0, 770000 },\t \n\t\t{ 0, 860000 },\t \n\t\t{ 1, 100000 },\t \n\t\t{ 1, 530000 },\t \n\t\t{ 7, 230000 }\t \n\t},\n};\n\nstatic const struct mlx_chip_info mlx90615_chip_info = {\n\t.op_eeprom_emissivity\t\t= MLX90615_OP_EEPROM | 0x03,\n\t.op_eeprom_config1\t\t= MLX90615_OP_EEPROM | 0x02,\n\t.op_ram_ta\t\t\t= MLX90615_OP_RAM | 0x06,\n\t.op_ram_tobj1\t\t\t= MLX90615_OP_RAM | 0x07,\n\t.op_ram_tobj2\t\t\t= MLX90615_OP_RAM | 0x08,\n\t.op_sleep\t\t\t= MLX90615_OP_SLEEP,\n\t.dual_channel\t\t\t= false,\n\t.wakeup_delay_ms\t\t= MLX90615_TIMING_WAKEUP,\n\t.emissivity_max\t\t\t= 16383,\n\t.fir_config_mask\t\t= 0,\t \n\t.iir_config_mask\t\t= MLX90615_CONFIG_IIR_MASK,\n\t \n\t.iir_valid_offset\t\t= 1,\n\t.iir_values\t\t\t= { 500, 50, 30, 20, 15, 13, 10 },\n\t.iir_freqs\t\t\t= {\n\t\t{ 0, 100000 },\t \n\t\t{ 0, 130000 },\t \n\t\t{ 0, 150000 },\t \n\t\t{ 0, 200000 },\t \n\t\t{ 0, 300000 },\t \n\t\t{ 0, 500000 },\t \n\t\t{ 5, 000000 },\t \n\t},\n};\n\nstatic const struct i2c_device_id mlx90614_id[] = {\n\t{ \"mlx90614\", .driver_data = (kernel_ulong_t)&mlx90614_chip_info },\n\t{ \"mlx90615\", .driver_data = (kernel_ulong_t)&mlx90615_chip_info },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mlx90614_id);\n\nstatic const struct of_device_id mlx90614_of_match[] = {\n\t{ .compatible = \"melexis,mlx90614\", .data = &mlx90614_chip_info },\n\t{ .compatible = \"melexis,mlx90615\", .data = &mlx90615_chip_info },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mlx90614_of_match);\n\nstatic int mlx90614_pm_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mlx90614_data *data = iio_priv(indio_dev);\n\n\tif (data->wakeup_gpio && pm_runtime_active(dev))\n\t\treturn mlx90614_sleep(data);\n\n\treturn 0;\n}\n\nstatic int mlx90614_pm_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mlx90614_data *data = iio_priv(indio_dev);\n\tint err;\n\n\tif (data->wakeup_gpio) {\n\t\terr = mlx90614_wakeup(data);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tpm_runtime_disable(dev);\n\t\tpm_runtime_set_active(dev);\n\t\tpm_runtime_enable(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx90614_pm_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mlx90614_data *data = iio_priv(indio_dev);\n\n\treturn mlx90614_sleep(data);\n}\n\nstatic int mlx90614_pm_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mlx90614_data *data = iio_priv(indio_dev);\n\n\treturn mlx90614_wakeup(data);\n}\n\nstatic const struct dev_pm_ops mlx90614_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(mlx90614_pm_suspend, mlx90614_pm_resume)\n\tRUNTIME_PM_OPS(mlx90614_pm_runtime_suspend,\n\t\t       mlx90614_pm_runtime_resume, NULL)\n};\n\nstatic struct i2c_driver mlx90614_driver = {\n\t.driver = {\n\t\t.name\t= \"mlx90614\",\n\t\t.of_match_table = mlx90614_of_match,\n\t\t.pm\t= pm_ptr(&mlx90614_pm_ops),\n\t},\n\t.probe = mlx90614_probe,\n\t.remove = mlx90614_remove,\n\t.id_table = mlx90614_id,\n};\nmodule_i2c_driver(mlx90614_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_AUTHOR(\"Vianney le Cl\u00e9ment de Saint-Marcq <vianney.leclement@essensium.com>\");\nMODULE_AUTHOR(\"Crt Mori <cmo@melexis.com>\");\nMODULE_DESCRIPTION(\"Melexis MLX90614 contactless IR temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}