{
  "module_name": "tmp117.c",
  "hash_id": "237a2da69c218fa90685ad9b360c9b27deab9febaf5907c9cb75125cb335a70a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/temperature/tmp117.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/limits.h>\n#include <linux/property.h>\n\n#include <linux/iio/iio.h>\n\n#define TMP117_REG_TEMP\t\t\t0x0\n#define TMP117_REG_CFGR\t\t\t0x1\n#define TMP117_REG_HIGH_LIM\t\t0x2\n#define TMP117_REG_LOW_LIM\t\t0x3\n#define TMP117_REG_EEPROM_UL\t\t0x4\n#define TMP117_REG_EEPROM1\t\t0x5\n#define TMP117_REG_EEPROM2\t\t0x6\n#define TMP117_REG_TEMP_OFFSET\t\t0x7\n#define TMP117_REG_EEPROM3\t\t0x8\n#define TMP117_REG_DEVICE_ID\t\t0xF\n\n#define TMP117_RESOLUTION_10UC\t\t78125\n#define MICRODEGREE_PER_10MILLIDEGREE\t10000\n\n#define TMP116_DEVICE_ID\t\t0x1116\n#define TMP117_DEVICE_ID\t\t0x0117\n\nstruct tmp117_data {\n\tstruct i2c_client *client;\n\ts16 calibbias;\n};\n\nstatic int tmp117_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *channel, int *val,\n\t\t\t   int *val2, long mask)\n{\n\tstruct tmp117_data *data = iio_priv(indio_dev);\n\ts32 ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = i2c_smbus_read_word_swapped(data->client,\n\t\t\t\t\t\t  TMP117_REG_TEMP);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = sign_extend32(ret, 15);\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = i2c_smbus_read_word_swapped(data->client,\n\t\t\t\t\t\t  TMP117_REG_TEMP_OFFSET);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = sign_extend32(ret, 15);\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*val = TMP117_RESOLUTION_10UC / MICRODEGREE_PER_10MILLIDEGREE;\n\t\t*val2 = (TMP117_RESOLUTION_10UC %\n\t\t\t\t\tMICRODEGREE_PER_10MILLIDEGREE) * 100;\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tmp117_write_raw(struct iio_dev *indio_dev, struct iio_chan_spec\n\t\t\t    const *channel, int val, int val2, long mask)\n{\n\tstruct tmp117_data *data = iio_priv(indio_dev);\n\ts16 off;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\toff = clamp_t(int, val, S16_MIN, S16_MAX);\n\t\tif (off == data->calibbias)\n\t\t\treturn 0;\n\t\tdata->calibbias = off;\n\t\treturn i2c_smbus_write_word_swapped(data->client,\n\t\t\t\t\t\tTMP117_REG_TEMP_OFFSET, off);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_chan_spec tmp117_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_CALIBBIAS) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t},\n};\n\nstatic const struct iio_chan_spec tmp116_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\n\t},\n};\n\nstatic const struct iio_info tmp117_info = {\n\t.read_raw = tmp117_read_raw,\n\t.write_raw = tmp117_write_raw,\n};\n\nstatic int tmp117_identify(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id;\n\tunsigned long match_data;\n\tint dev_id;\n\n\tdev_id = i2c_smbus_read_word_swapped(client, TMP117_REG_DEVICE_ID);\n\tif (dev_id < 0)\n\t\treturn dev_id;\n\n\tswitch (dev_id) {\n\tcase TMP116_DEVICE_ID:\n\tcase TMP117_DEVICE_ID:\n\t\treturn dev_id;\n\t}\n\n\tdev_info(&client->dev, \"Unknown device id (0x%x), use fallback compatible\\n\",\n\t\t dev_id);\n\n\tmatch_data = (uintptr_t)device_get_match_data(&client->dev);\n\tif (match_data)\n\t\treturn match_data;\n\n\tid = i2c_client_get_device_id(client);\n\tif (id)\n\t\treturn id->driver_data;\n\n\tdev_err(&client->dev, \"Failed to identify unsupported device\\n\");\n\n\treturn -ENODEV;\n}\n\nstatic int tmp117_probe(struct i2c_client *client)\n{\n\tstruct tmp117_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret, dev_id;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tret = tmp117_identify(client);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_id = ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\tdata->calibbias = 0;\n\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &tmp117_info;\n\n\tswitch (dev_id) {\n\tcase TMP116_DEVICE_ID:\n\t\tindio_dev->channels = tmp116_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(tmp116_channels);\n\t\tindio_dev->name = \"tmp116\";\n\t\tbreak;\n\tcase TMP117_DEVICE_ID:\n\t\tindio_dev->channels = tmp117_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(tmp117_channels);\n\t\tindio_dev->name = \"tmp117\";\n\t\tbreak;\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic const struct of_device_id tmp117_of_match[] = {\n\t{ .compatible = \"ti,tmp116\", .data = (void *)TMP116_DEVICE_ID },\n\t{ .compatible = \"ti,tmp117\", .data = (void *)TMP117_DEVICE_ID },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tmp117_of_match);\n\nstatic const struct i2c_device_id tmp117_id[] = {\n\t{ \"tmp116\", TMP116_DEVICE_ID },\n\t{ \"tmp117\", TMP117_DEVICE_ID },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tmp117_id);\n\nstatic struct i2c_driver tmp117_driver = {\n\t.driver = {\n\t\t.name\t= \"tmp117\",\n\t\t.of_match_table = tmp117_of_match,\n\t},\n\t.probe\t\t= tmp117_probe,\n\t.id_table\t= tmp117_id,\n};\nmodule_i2c_driver(tmp117_driver);\n\nMODULE_AUTHOR(\"Puranjay Mohan <puranjay12@gmail.com>\");\nMODULE_DESCRIPTION(\"TI TMP117 Temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}