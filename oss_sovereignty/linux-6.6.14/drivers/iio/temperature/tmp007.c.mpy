{
  "module_name": "tmp007.c",
  "hash_id": "47458e29d07cd8c500f671fae31321fd65ab0e66dc4d9b801f90ebc2d62688ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/temperature/tmp007.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/bitops.h>\n#include <linux/mod_devicetable.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/events.h>\n\n#define TMP007_TDIE 0x01\n#define TMP007_CONFIG 0x02\n#define TMP007_TOBJECT 0x03\n#define TMP007_STATUS 0x04\n#define TMP007_STATUS_MASK 0x05\n#define TMP007_TOBJ_HIGH_LIMIT 0x06\n#define TMP007_TOBJ_LOW_LIMIT 0x07\n#define TMP007_TDIE_HIGH_LIMIT 0x08\n#define TMP007_TDIE_LOW_LIMIT 0x09\n#define TMP007_MANUFACTURER_ID 0x1e\n#define TMP007_DEVICE_ID 0x1f\n\n#define TMP007_CONFIG_CONV_EN BIT(12)\n#define TMP007_CONFIG_TC_EN BIT(6)\n#define TMP007_CONFIG_CR_MASK GENMASK(11, 9)\n#define TMP007_CONFIG_ALERT_EN BIT(8)\n#define TMP007_CONFIG_CR_SHIFT 9\n\n \n#define TMP007_STATUS_ALERT BIT(15)\n#define TMP007_STATUS_CONV_READY BIT(14)\n#define TMP007_STATUS_OHF BIT(13)\n#define TMP007_STATUS_OLF BIT(12)\n#define TMP007_STATUS_LHF BIT(11)\n#define TMP007_STATUS_LLF BIT(10)\n#define TMP007_STATUS_DATA_VALID BIT(9)\n\n#define TMP007_MANUFACTURER_MAGIC 0x5449\n#define TMP007_DEVICE_MAGIC 0x0078\n\n#define TMP007_TEMP_SHIFT 2\n\nstruct tmp007_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tu16 config;\n\tu16 status_mask;\n};\n\nstatic const int tmp007_avgs[5][2] = { {4, 0}, {2, 0}, {1, 0},\n\t\t\t\t\t{0, 500000}, {0, 250000} };\n\nstatic int tmp007_read_temperature(struct tmp007_data *data, u8 reg)\n{\n\ts32 ret;\n\tint tries = 50;\n\n\twhile (tries-- > 0) {\n\t\tret = i2c_smbus_read_word_swapped(data->client,\n\t\t\tTMP007_STATUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif ((ret & TMP007_STATUS_CONV_READY) &&\n\t\t\t!(ret & TMP007_STATUS_DATA_VALID))\n\t\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\n\tif (tries < 0)\n\t\treturn -EIO;\n\n\treturn i2c_smbus_read_word_swapped(data->client, reg);\n}\n\nstatic int tmp007_powerdown(struct tmp007_data *data)\n{\n\treturn i2c_smbus_write_word_swapped(data->client, TMP007_CONFIG,\n\t\t\tdata->config & ~TMP007_CONFIG_CONV_EN);\n}\n\nstatic int tmp007_read_raw(struct iio_dev *indio_dev,\n\t\tstruct iio_chan_spec const *channel, int *val,\n\t\tint *val2, long mask)\n{\n\tstruct tmp007_data *data = iio_priv(indio_dev);\n\ts32 ret;\n\tint conv_rate;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tswitch (channel->channel2) {\n\t\tcase IIO_MOD_TEMP_AMBIENT:  \n\t\t\tret = i2c_smbus_read_word_swapped(data->client, TMP007_TDIE);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase IIO_MOD_TEMP_OBJECT:\n\t\t\tret = tmp007_read_temperature(data, TMP007_TOBJECT);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*val = sign_extend32(ret, 15) >> TMP007_TEMP_SHIFT;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 31;\n\t\t*val2 = 250000;\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tconv_rate = (data->config & TMP007_CONFIG_CR_MASK)\n\t\t\t\t>> TMP007_CONFIG_CR_SHIFT;\n\t\t*val = tmp007_avgs[conv_rate][0];\n\t\t*val2 = tmp007_avgs[conv_rate][1];\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tmp007_write_raw(struct iio_dev *indio_dev,\n\t\tstruct iio_chan_spec const *channel, int val,\n\t\tint val2, long mask)\n{\n\tstruct tmp007_data *data = iio_priv(indio_dev);\n\tint i;\n\tu16 tmp;\n\n\tif (mask == IIO_CHAN_INFO_SAMP_FREQ) {\n\t\tfor (i = 0; i < ARRAY_SIZE(tmp007_avgs); i++) {\n\t\t\tif ((val == tmp007_avgs[i][0]) &&\n\t\t\t(val2 == tmp007_avgs[i][1])) {\n\t\t\t\ttmp = data->config & ~TMP007_CONFIG_CR_MASK;\n\t\t\t\ttmp |= (i << TMP007_CONFIG_CR_SHIFT);\n\n\t\t\t\treturn i2c_smbus_write_word_swapped(data->client,\n\t\t\t\t\t\t\t\tTMP007_CONFIG,\n\t\t\t\t\t\t\t\tdata->config = tmp);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic irqreturn_t tmp007_interrupt_handler(int irq, void *private)\n{\n\tstruct iio_dev *indio_dev = private;\n\tstruct tmp007_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = i2c_smbus_read_word_swapped(data->client, TMP007_STATUS);\n\tif ((ret < 0) || !(ret & (TMP007_STATUS_OHF | TMP007_STATUS_OLF |\n\t\t\t\tTMP007_STATUS_LHF | TMP007_STATUS_LLF)))\n\t\treturn IRQ_NONE;\n\n\tif (ret & TMP007_STATUS_OHF)\n\t\tiio_push_event(indio_dev,\n\t\t\t\tIIO_MOD_EVENT_CODE(IIO_TEMP, 0,\n\t\t\t\t\tIIO_MOD_TEMP_OBJECT,\n\t\t\t\t\tIIO_EV_TYPE_THRESH,\n\t\t\t\t\tIIO_EV_DIR_RISING),\n\t\t\t\tiio_get_time_ns(indio_dev));\n\n\tif (ret & TMP007_STATUS_OLF)\n\t\tiio_push_event(indio_dev,\n\t\t\t\tIIO_MOD_EVENT_CODE(IIO_TEMP, 0,\n\t\t\t\t\tIIO_MOD_TEMP_OBJECT,\n\t\t\t\t\tIIO_EV_TYPE_THRESH,\n\t\t\t\t\tIIO_EV_DIR_FALLING),\n\t\t\t\tiio_get_time_ns(indio_dev));\n\n\tif (ret & TMP007_STATUS_LHF)\n\t\tiio_push_event(indio_dev,\n\t\t\t\tIIO_MOD_EVENT_CODE(IIO_TEMP, 0,\n\t\t\t\t\tIIO_MOD_TEMP_AMBIENT,\n\t\t\t\t\tIIO_EV_TYPE_THRESH,\n\t\t\t\t\tIIO_EV_DIR_RISING),\n\t\t\t\tiio_get_time_ns(indio_dev));\n\n\tif (ret & TMP007_STATUS_LLF)\n\t\tiio_push_event(indio_dev,\n\t\t\t\tIIO_MOD_EVENT_CODE(IIO_TEMP, 0,\n\t\t\t\t\tIIO_MOD_TEMP_AMBIENT,\n\t\t\t\t\tIIO_EV_TYPE_THRESH,\n\t\t\t\t\tIIO_EV_DIR_FALLING),\n\t\t\t\tiio_get_time_ns(indio_dev));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tmp007_write_event_config(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir, int state)\n{\n\tstruct tmp007_data *data = iio_priv(indio_dev);\n\tunsigned int status_mask;\n\tint ret;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_TEMP_AMBIENT:\n\tif (dir == IIO_EV_DIR_RISING)\n\t\t\tstatus_mask = TMP007_STATUS_LHF;\n\t\telse\n\t\t\tstatus_mask = TMP007_STATUS_LLF;\n\t\tbreak;\n\tcase IIO_MOD_TEMP_OBJECT:\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\tstatus_mask = TMP007_STATUS_OHF;\n\t\telse\n\t\t\tstatus_mask = TMP007_STATUS_OLF;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&data->lock);\n\tret = i2c_smbus_read_word_swapped(data->client, TMP007_STATUS_MASK);\n\tmutex_unlock(&data->lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (state)\n\t\tret |= status_mask;\n\telse\n\t\tret &= ~status_mask;\n\n\treturn i2c_smbus_write_word_swapped(data->client, TMP007_STATUS_MASK,\n\t\t\t\t\tdata->status_mask = ret);\n}\n\nstatic int tmp007_read_event_config(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir)\n{\n\tstruct tmp007_data *data = iio_priv(indio_dev);\n\tunsigned int mask;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_TEMP_AMBIENT:\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\tmask = TMP007_STATUS_LHF;\n\t\telse\n\t\t\tmask = TMP007_STATUS_LLF;\n\t\tbreak;\n\tcase IIO_MOD_TEMP_OBJECT:\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\tmask = TMP007_STATUS_OHF;\n\t\telse\n\t\t\tmask = TMP007_STATUS_OLF;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn !!(data->status_mask & mask);\n}\n\nstatic int tmp007_read_thresh(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir, enum iio_event_info info,\n\t\tint *val, int *val2)\n{\n\tstruct tmp007_data *data = iio_priv(indio_dev);\n\tint ret;\n\tu8 reg;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_TEMP_AMBIENT:  \n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\treg = TMP007_TDIE_HIGH_LIMIT;\n\t\telse\n\t\t\treg = TMP007_TDIE_LOW_LIMIT;\n\t\tbreak;\n\tcase IIO_MOD_TEMP_OBJECT:\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\treg = TMP007_TOBJ_HIGH_LIMIT;\n\telse\n\t\t\treg = TMP007_TOBJ_LOW_LIMIT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = i2c_smbus_read_word_swapped(data->client, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t*val = sign_extend32(ret, 15) >> 7;\n\n\treturn IIO_VAL_INT;\n}\n\nstatic int tmp007_write_thresh(struct iio_dev *indio_dev,\n\t\tconst struct iio_chan_spec *chan, enum iio_event_type type,\n\t\tenum iio_event_direction dir, enum iio_event_info info,\n\t\tint val, int val2)\n{\n\tstruct tmp007_data *data = iio_priv(indio_dev);\n\tu8 reg;\n\n\tswitch (chan->channel2) {\n\tcase IIO_MOD_TEMP_AMBIENT:\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\treg = TMP007_TDIE_HIGH_LIMIT;\n\t\telse\n\t\t\treg = TMP007_TDIE_LOW_LIMIT;\n\t\tbreak;\n\tcase IIO_MOD_TEMP_OBJECT:\n\t\tif (dir == IIO_EV_DIR_RISING)\n\t\t\treg = TMP007_TOBJ_HIGH_LIMIT;\n\t\telse\n\t\t\treg = TMP007_TOBJ_LOW_LIMIT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (val < -256 || val > 255)\n\t\treturn -EINVAL;\n\n\t \n\treturn i2c_smbus_write_word_swapped(data->client, reg, (val << 7));\n}\n\nstatic IIO_CONST_ATTR(sampling_frequency_available, \"4 2 1 0.5 0.25\");\n\nstatic struct attribute *tmp007_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tmp007_attribute_group = {\n\t.attrs = tmp007_attributes,\n};\n\nstatic const struct iio_event_spec tmp007_obj_event[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_event_spec tmp007_die_event[] = {\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_RISING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n\t{\n\t\t.type = IIO_EV_TYPE_THRESH,\n\t\t.dir = IIO_EV_DIR_FALLING,\n\t\t.mask_separate = BIT(IIO_EV_INFO_VALUE) |\n\t\t\tBIT(IIO_EV_INFO_ENABLE),\n\t},\n};\n\nstatic const struct iio_chan_spec tmp007_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_TEMP_AMBIENT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.event_spec = tmp007_die_event,\n\t\t.num_event_specs = ARRAY_SIZE(tmp007_die_event),\n\t},\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.modified = 1,\n\t\t.channel2 = IIO_MOD_TEMP_OBJECT,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n\t\t.event_spec = tmp007_obj_event,\n\t\t.num_event_specs = ARRAY_SIZE(tmp007_obj_event),\n\t}\n};\n\nstatic const struct iio_info tmp007_info = {\n\t.read_raw = tmp007_read_raw,\n\t.write_raw = tmp007_write_raw,\n\t.read_event_config = tmp007_read_event_config,\n\t.write_event_config = tmp007_write_event_config,\n\t.read_event_value = tmp007_read_thresh,\n\t.write_event_value = tmp007_write_thresh,\n\t.attrs = &tmp007_attribute_group,\n};\n\nstatic bool tmp007_identify(struct i2c_client *client)\n{\n\tint manf_id, dev_id;\n\n\tmanf_id = i2c_smbus_read_word_swapped(client, TMP007_MANUFACTURER_ID);\n\tif (manf_id < 0)\n\t\treturn false;\n\n\tdev_id = i2c_smbus_read_word_swapped(client, TMP007_DEVICE_ID);\n\tif (dev_id < 0)\n\t\treturn false;\n\n\treturn (manf_id == TMP007_MANUFACTURER_MAGIC && dev_id == TMP007_DEVICE_MAGIC);\n}\n\nstatic void tmp007_powerdown_action_cb(void *priv)\n{\n\tstruct tmp007_data *data = priv;\n\n\ttmp007_powerdown(data);\n}\n\nstatic int tmp007_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *tmp007_id = i2c_client_get_device_id(client);\n\tstruct tmp007_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tmp007_identify(client)) {\n\t\tdev_err(&client->dev, \"TMP007 not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\tindio_dev->name = \"tmp007\";\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &tmp007_info;\n\n\tindio_dev->channels = tmp007_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(tmp007_channels);\n\n\t \n\n\tret = i2c_smbus_read_word_swapped(data->client, TMP007_CONFIG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->config = ret;\n\tdata->config |= (TMP007_CONFIG_CONV_EN | TMP007_CONFIG_ALERT_EN | TMP007_CONFIG_TC_EN);\n\n\tret = i2c_smbus_write_word_swapped(data->client, TMP007_CONFIG,\n\t\t\t\t\tdata->config);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&client->dev, tmp007_powerdown_action_cb, data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = i2c_smbus_read_word_swapped(data->client, TMP007_STATUS_MASK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->status_mask = ret;\n\tdata->status_mask |= (TMP007_STATUS_OHF | TMP007_STATUS_OLF\n\t\t\t\t| TMP007_STATUS_LHF | TMP007_STATUS_LLF);\n\n\tret = i2c_smbus_write_word_swapped(data->client, TMP007_STATUS_MASK, data->status_mask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\tNULL, tmp007_interrupt_handler,\n\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\ttmp007_id->name, indio_dev);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"irq request error %d\\n\", -ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic int tmp007_suspend(struct device *dev)\n{\n\tstruct tmp007_data *data = iio_priv(i2c_get_clientdata(\n\t\t\tto_i2c_client(dev)));\n\n\treturn tmp007_powerdown(data);\n}\n\nstatic int tmp007_resume(struct device *dev)\n{\n\tstruct tmp007_data *data = iio_priv(i2c_get_clientdata(\n\t\t\tto_i2c_client(dev)));\n\n\treturn i2c_smbus_write_word_swapped(data->client, TMP007_CONFIG,\n\t\t\tdata->config | TMP007_CONFIG_CONV_EN);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tmp007_pm_ops, tmp007_suspend, tmp007_resume);\n\nstatic const struct of_device_id tmp007_of_match[] = {\n\t{ .compatible = \"ti,tmp007\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tmp007_of_match);\n\nstatic const struct i2c_device_id tmp007_id[] = {\n\t{ \"tmp007\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tmp007_id);\n\nstatic struct i2c_driver tmp007_driver = {\n\t.driver = {\n\t\t.name\t= \"tmp007\",\n\t\t.of_match_table = tmp007_of_match,\n\t\t.pm\t= pm_sleep_ptr(&tmp007_pm_ops),\n\t},\n\t.probe\t\t= tmp007_probe,\n\t.id_table\t= tmp007_id,\n};\nmodule_i2c_driver(tmp007_driver);\n\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannanece23@gmail.com>\");\nMODULE_DESCRIPTION(\"TI TMP007 IR thermopile sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}