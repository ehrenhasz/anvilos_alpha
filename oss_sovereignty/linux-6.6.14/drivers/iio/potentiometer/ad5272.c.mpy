{
  "module_name": "ad5272.c",
  "hash_id": "a5de5b3a995f1dc8ea0ed9fa575f9a62ef38b2f3ed5d801e97ad998d8e4e85ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/potentiometer/ad5272.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n\n#define  AD5272_RDAC_WR  1\n#define  AD5272_RDAC_RD  2\n#define  AD5272_RESET    4\n#define  AD5272_CTL      7\n\n#define  AD5272_RDAC_WR_EN  BIT(1)\n\nstruct ad5272_cfg {\n\tint max_pos;\n\tint kohms;\n\tint shift;\n};\n\nenum ad5272_type {\n\tAD5272_020,\n\tAD5272_050,\n\tAD5272_100,\n\tAD5274_020,\n\tAD5274_100,\n};\n\nstatic const struct ad5272_cfg ad5272_cfg[] = {\n\t[AD5272_020] = { .max_pos = 1024, .kohms = 20 },\n\t[AD5272_050] = { .max_pos = 1024, .kohms = 50 },\n\t[AD5272_100] = { .max_pos = 1024, .kohms = 100 },\n\t[AD5274_020] = { .max_pos = 256,  .kohms = 20,  .shift = 2 },\n\t[AD5274_100] = { .max_pos = 256,  .kohms = 100, .shift = 2 },\n};\n\nstruct ad5272_data {\n\tstruct i2c_client       *client;\n\tstruct mutex            lock;\n\tconst struct ad5272_cfg *cfg;\n\tu8                      buf[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic const struct iio_chan_spec ad5272_channel = {\n\t.type = IIO_RESISTANCE,\n\t.output = 1,\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n};\n\nstatic int ad5272_write(struct ad5272_data *data, int reg, int val)\n{\n\tint ret;\n\n\tdata->buf[0] = (reg << 2) | ((val >> 8) & 0x3);\n\tdata->buf[1] = (u8)val;\n\n\tmutex_lock(&data->lock);\n\tret = i2c_master_send(data->client, data->buf, sizeof(data->buf));\n\tmutex_unlock(&data->lock);\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int ad5272_read(struct ad5272_data *data, int reg, int *val)\n{\n\tint ret;\n\n\tdata->buf[0] = reg << 2;\n\tdata->buf[1] = 0;\n\n\tmutex_lock(&data->lock);\n\tret = i2c_master_send(data->client, data->buf, sizeof(data->buf));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = i2c_master_recv(data->client, data->buf, sizeof(data->buf));\n\tif (ret < 0)\n\t\tgoto error;\n\n\t*val = ((data->buf[0] & 0x3) << 8) | data->buf[1];\n\tret = 0;\nerror:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int ad5272_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct ad5272_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW: {\n\t\tret = ad5272_read(data, AD5272_RDAC_RD, val);\n\t\t*val = *val >> data->cfg->shift;\n\t\treturn ret ? ret : IIO_VAL_INT;\n\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 1000 * data->cfg->kohms;\n\t\t*val2 = data->cfg->max_pos;\n\t\treturn IIO_VAL_FRACTIONAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ad5272_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct ad5272_data *data = iio_priv(indio_dev);\n\n\tif (mask != IIO_CHAN_INFO_RAW)\n\t\treturn -EINVAL;\n\n\tif (val >= data->cfg->max_pos || val < 0 || val2)\n\t\treturn -EINVAL;\n\n\treturn ad5272_write(data, AD5272_RDAC_WR, val << data->cfg->shift);\n}\n\nstatic const struct iio_info ad5272_info = {\n\t.read_raw = ad5272_read_raw,\n\t.write_raw = ad5272_write_raw,\n};\n\nstatic int ad5272_reset(struct ad5272_data *data)\n{\n\tstruct gpio_desc *reset_gpio;\n\n\treset_gpio = devm_gpiod_get_optional(&data->client->dev, \"reset\",\n\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(reset_gpio))\n\t\treturn PTR_ERR(reset_gpio);\n\n\tif (reset_gpio) {\n\t\tudelay(1);\n\t\tgpiod_set_value(reset_gpio, 0);\n\t} else {\n\t\tad5272_write(data, AD5272_RESET, 0);\n\t}\n\tusleep_range(1000, 2000);\n\n\treturn 0;\n}\n\nstatic int ad5272_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct ad5272_data *data;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\tdata->cfg = &ad5272_cfg[id->driver_data];\n\n\tret = ad5272_reset(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ad5272_write(data, AD5272_CTL, AD5272_RDAC_WR_EN);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\tindio_dev->info = &ad5272_info;\n\tindio_dev->channels = &ad5272_channel;\n\tindio_dev->num_channels = 1;\n\tindio_dev->name = client->name;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id ad5272_dt_ids[] = {\n\t{ .compatible = \"adi,ad5272-020\", .data = (void *)AD5272_020 },\n\t{ .compatible = \"adi,ad5272-050\", .data = (void *)AD5272_050 },\n\t{ .compatible = \"adi,ad5272-100\", .data = (void *)AD5272_100 },\n\t{ .compatible = \"adi,ad5274-020\", .data = (void *)AD5274_020 },\n\t{ .compatible = \"adi,ad5274-100\", .data = (void *)AD5274_100 },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ad5272_dt_ids);\n\nstatic const struct i2c_device_id ad5272_id[] = {\n\t{ \"ad5272-020\", AD5272_020 },\n\t{ \"ad5272-050\", AD5272_050 },\n\t{ \"ad5272-100\", AD5272_100 },\n\t{ \"ad5274-020\", AD5274_020 },\n\t{ \"ad5274-100\", AD5274_100 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ad5272_id);\n\nstatic struct i2c_driver ad5272_driver = {\n\t.driver = {\n\t\t.name\t= \"ad5272\",\n\t\t.of_match_table = ad5272_dt_ids,\n\t},\n\t.probe\t\t= ad5272_probe,\n\t.id_table\t= ad5272_id,\n};\n\nmodule_i2c_driver(ad5272_driver);\n\nMODULE_AUTHOR(\"Phil Reid <preid@eletromag.com.au>\");\nMODULE_DESCRIPTION(\"AD5272 digital potentiometer\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}