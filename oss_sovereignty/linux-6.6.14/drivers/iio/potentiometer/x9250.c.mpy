{
  "module_name": "x9250.c",
  "hash_id": "3f4903bd7921bc5884d0a9f6b85002ff21f77a7791dfc88b2aae9cf0806cb084",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/potentiometer/x9250.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iio/iio.h>\n#include <linux/limits.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n\nstruct x9250_cfg {\n\tconst char *name;\n\tint kohms;\n};\n\nstruct x9250 {\n\tstruct spi_device *spi;\n\tconst struct x9250_cfg *cfg;\n\tstruct gpio_desc *wp_gpio;\n};\n\n#define X9250_ID\t\t0x50\n#define X9250_CMD_RD_WCR(_p)    (0x90 | (_p))\n#define X9250_CMD_WR_WCR(_p)    (0xa0 | (_p))\n\nstatic int x9250_write8(struct x9250 *x9250, u8 cmd, u8 val)\n{\n\tu8 txbuf[3];\n\n\ttxbuf[0] = X9250_ID;\n\ttxbuf[1] = cmd;\n\ttxbuf[2] = val;\n\n\treturn spi_write_then_read(x9250->spi, txbuf, ARRAY_SIZE(txbuf), NULL, 0);\n}\n\nstatic int x9250_read8(struct x9250 *x9250, u8 cmd, u8 *val)\n{\n\tu8 txbuf[2];\n\n\ttxbuf[0] = X9250_ID;\n\ttxbuf[1] = cmd;\n\n\treturn spi_write_then_read(x9250->spi, txbuf, ARRAY_SIZE(txbuf), val, 1);\n}\n\n#define X9250_CHANNEL(ch) {\t\t\t\t\t\t\\\n\t.type = IIO_RESISTANCE,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\t\\\n\t.channel = (ch),\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_RAW),\t\\\n}\n\nstatic const struct iio_chan_spec x9250_channels[] = {\n\tX9250_CHANNEL(0),\n\tX9250_CHANNEL(1),\n\tX9250_CHANNEL(2),\n\tX9250_CHANNEL(3),\n};\n\nstatic int x9250_read_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,\n\t\t\t  int *val, int *val2, long mask)\n{\n\tstruct x9250 *x9250 = iio_priv(indio_dev);\n\tint ch = chan->channel;\n\tint ret;\n\tu8 v;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = x9250_read8(x9250, X9250_CMD_RD_WCR(ch), &v);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*val = v;\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 1000 * x9250->cfg->kohms;\n\t\t*val2 = U8_MAX;\n\t\treturn IIO_VAL_FRACTIONAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int x9250_read_avail(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,\n\t\t\t    const int **vals, int *type, int *length, long mask)\n{\n\tstatic const int range[] = {0, 1, 255};  \n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*length = ARRAY_SIZE(range);\n\t\t*vals = range;\n\t\t*type = IIO_VAL_INT;\n\t\treturn IIO_AVAIL_RANGE;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int x9250_write_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,\n\t\t\t   int val, int val2, long mask)\n{\n\tstruct x9250 *x9250 = iio_priv(indio_dev);\n\tint ch = chan->channel;\n\tint ret;\n\n\tif (mask != IIO_CHAN_INFO_RAW)\n\t\treturn -EINVAL;\n\n\tif (val > U8_MAX || val < 0)\n\t\treturn -EINVAL;\n\n\tgpiod_set_value_cansleep(x9250->wp_gpio, 0);\n\tret = x9250_write8(x9250, X9250_CMD_WR_WCR(ch), val);\n\tgpiod_set_value_cansleep(x9250->wp_gpio, 1);\n\n\treturn ret;\n}\n\nstatic const struct iio_info x9250_info = {\n\t.read_raw = x9250_read_raw,\n\t.read_avail = x9250_read_avail,\n\t.write_raw = x9250_write_raw,\n};\n\nenum x9250_type {\n\tX9250T,\n\tX9250U,\n};\n\nstatic const struct x9250_cfg x9250_cfg[] = {\n\t[X9250T] = { .name = \"x9250t\", .kohms =  100, },\n\t[X9250U] = { .name = \"x9250u\", .kohms =  50, },\n};\n\nstatic const char *const x9250_regulator_names[] = {\n\t\"vcc\",\n\t\"avp\",\n\t\"avn\",\n};\n\nstatic int x9250_probe(struct spi_device *spi)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct x9250 *x9250;\n\tint ret;\n\n\tret = devm_regulator_bulk_get_enable(&spi->dev, ARRAY_SIZE(x9250_regulator_names),\n\t\t\t\t\t     x9250_regulator_names);\n\tif (ret)\n\t\treturn dev_err_probe(&spi->dev, ret, \"Failed to get regulators\\n\");\n\n\t \n\tusleep_range(5000, 6000);\n\n\tindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*x9250));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tx9250 = iio_priv(indio_dev);\n\tx9250->spi = spi;\n\tx9250->cfg = spi_get_device_match_data(spi);\n\tx9250->wp_gpio = devm_gpiod_get_optional(&spi->dev, \"wp\", GPIOD_OUT_LOW);\n\tif (IS_ERR(x9250->wp_gpio))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(x9250->wp_gpio),\n\t\t\t\t     \"failed to get wp gpio\\n\");\n\n\tindio_dev->info = &x9250_info;\n\tindio_dev->channels = x9250_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(x9250_channels);\n\tindio_dev->name = x9250->cfg->name;\n\n\treturn devm_iio_device_register(&spi->dev, indio_dev);\n}\n\nstatic const struct of_device_id x9250_of_match[] = {\n\t{ .compatible = \"renesas,x9250t\", .data = &x9250_cfg[X9250T]},\n\t{ .compatible = \"renesas,x9250u\", .data = &x9250_cfg[X9250U]},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, x9250_of_match);\n\nstatic const struct spi_device_id x9250_id_table[] = {\n\t{ \"x9250t\", (kernel_ulong_t)&x9250_cfg[X9250T] },\n\t{ \"x9250u\", (kernel_ulong_t)&x9250_cfg[X9250U] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, x9250_id_table);\n\nstatic struct spi_driver x9250_spi_driver = {\n\t.driver  = {\n\t\t.name = \"x9250\",\n\t\t.of_match_table = x9250_of_match,\n\t},\n\t.id_table = x9250_id_table,\n\t.probe  = x9250_probe,\n};\n\nmodule_spi_driver(x9250_spi_driver);\n\nMODULE_AUTHOR(\"Herve Codina <herve.codina@bootlin.com>\");\nMODULE_DESCRIPTION(\"X9250 ALSA SoC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}