{
  "module_name": "ds1803.c",
  "hash_id": "72be577c79c878c0ca9ae301320c261f049cd74f20aa66bbeb611acc8161ed0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/potentiometer/ds1803.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n\n#define DS1803_WIPER_0         0xA9\n#define DS1803_WIPER_1         0xAA\n#define DS3502_WR_IVR          0x00\n\nenum ds1803_type {\n\tDS1803_010,\n\tDS1803_050,\n\tDS1803_100,\n\tDS3502,\n};\n\nstruct ds1803_cfg {\n\tint wipers;\n\tint avail[3];\n\tint kohms;\n\tconst struct iio_chan_spec *channels;\n\tu8 num_channels;\n\tint (*read)(struct iio_dev *indio_dev,\n\t\t    struct iio_chan_spec const *chan, int *val);\n};\n\nstruct ds1803_data {\n\tstruct i2c_client *client;\n\tconst struct ds1803_cfg *cfg;\n};\n\n#define DS1803_CHANNEL(ch, addr) {\t\t\t\t\t\\\n\t.type = IIO_RESISTANCE,\t\t\t\t\t\t\\\n\t.indexed = 1,\t\t\t\t\t\t\t\\\n\t.output = 1,\t\t\t\t\t\t\t\\\n\t.channel = (ch),\t\t\t\t\t\t\\\n\t.address = (addr),\t\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_RAW),   \\\n}\n\nstatic const struct iio_chan_spec ds1803_channels[] = {\n\tDS1803_CHANNEL(0, DS1803_WIPER_0),\n\tDS1803_CHANNEL(1, DS1803_WIPER_1),\n};\n\nstatic const struct iio_chan_spec ds3502_channels[] = {\n\tDS1803_CHANNEL(0, DS3502_WR_IVR),\n};\n\nstatic int ds1803_read(struct iio_dev *indio_dev,\n\t\t       struct iio_chan_spec const *chan,\n\t\t       int *val)\n{\n\tstruct ds1803_data *data = iio_priv(indio_dev);\n\tint ret;\n\tu8 result[ARRAY_SIZE(ds1803_channels)];\n\n\tret = i2c_master_recv(data->client, result, indio_dev->num_channels);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = result[chan->channel];\n\treturn ret;\n}\n\nstatic int ds3502_read(struct iio_dev *indio_dev,\n\t\t       struct iio_chan_spec const *chan,\n\t\t       int *val)\n{\n\tstruct ds1803_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(data->client, chan->address);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\treturn ret;\n}\n\nstatic const struct ds1803_cfg ds1803_cfg[] = {\n\t[DS1803_010] = {\n\t\t.wipers = 2,\n\t\t.avail = { 0, 1, 255 },\n\t\t.kohms =  10,\n\t\t.channels = ds1803_channels,\n\t\t.num_channels = ARRAY_SIZE(ds1803_channels),\n\t\t.read = ds1803_read,\n\t},\n\t[DS1803_050] = {\n\t\t.wipers = 2,\n\t\t.avail = { 0, 1, 255 },\n\t\t.kohms =  50,\n\t\t.channels = ds1803_channels,\n\t\t.num_channels = ARRAY_SIZE(ds1803_channels),\n\t\t.read = ds1803_read,\n\t},\n\t[DS1803_100] = {\n\t\t.wipers = 2,\n\t\t.avail = { 0, 1, 255 },\n\t\t.kohms = 100,\n\t\t.channels = ds1803_channels,\n\t\t.num_channels = ARRAY_SIZE(ds1803_channels),\n\t\t.read = ds1803_read,\n\t},\n\t[DS3502] = {\n\t  .wipers = 1,\n\t  .avail = { 0, 1, 127 },\n\t  .kohms =  10,\n\t  .channels = ds3502_channels,\n\t  .num_channels = ARRAY_SIZE(ds3502_channels),\n\t  .read = ds3502_read,\n\t},\n};\n\nstatic int ds1803_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct ds1803_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = data->cfg->read(indio_dev, chan, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn IIO_VAL_INT;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 1000 * data->cfg->kohms;\n\t\t*val2 = data->cfg->avail[2];  \n\t\treturn IIO_VAL_FRACTIONAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ds1803_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct ds1803_data *data = iio_priv(indio_dev);\n\tu8 addr = chan->address;\n\tint max_pos = data->cfg->avail[2];\n\n\tif (val2 != 0)\n\t\treturn -EINVAL;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val > max_pos || val < 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn i2c_smbus_write_byte_data(data->client, addr, val);\n}\n\nstatic int ds1803_read_avail(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     const int **vals, int *type,\n\t\t\t     int *length, long mask)\n{\n\tstruct ds1803_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\t*vals = data->cfg->avail;\n\t\t*length = ARRAY_SIZE(data->cfg->avail);\n\t\t*type = IIO_VAL_INT;\n\t\treturn IIO_AVAIL_RANGE;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct iio_info ds1803_info = {\n\t.read_raw = ds1803_read_raw,\n\t.write_raw = ds1803_write_raw,\n\t.read_avail = ds1803_read_avail,\n};\n\nstatic int ds1803_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tstruct ds1803_data *data;\n\tstruct iio_dev *indio_dev;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, indio_dev);\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\tdata->cfg = device_get_match_data(dev);\n\tif (!data->cfg)\n\t\tdata->cfg = &ds1803_cfg[id->driver_data];\n\n\tindio_dev->info = &ds1803_info;\n\tindio_dev->channels = data->cfg->channels;\n\tindio_dev->num_channels = data->cfg->num_channels;\n\tindio_dev->name = client->name;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic const struct of_device_id ds1803_dt_ids[] = {\n\t{ .compatible = \"maxim,ds1803-010\", .data = &ds1803_cfg[DS1803_010] },\n\t{ .compatible = \"maxim,ds1803-050\", .data = &ds1803_cfg[DS1803_050] },\n\t{ .compatible = \"maxim,ds1803-100\", .data = &ds1803_cfg[DS1803_100] },\n\t{ .compatible = \"maxim,ds3502\", .data = &ds1803_cfg[DS3502] },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ds1803_dt_ids);\n\nstatic const struct i2c_device_id ds1803_id[] = {\n\t{ \"ds1803-010\", DS1803_010 },\n\t{ \"ds1803-050\", DS1803_050 },\n\t{ \"ds1803-100\", DS1803_100 },\n\t{ \"ds3502\", DS3502 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ds1803_id);\n\nstatic struct i2c_driver ds1803_driver = {\n\t.driver = {\n\t\t.name\t= \"ds1803\",\n\t\t.of_match_table = ds1803_dt_ids,\n\t},\n\t.probe\t\t= ds1803_probe,\n\t.id_table\t= ds1803_id,\n};\n\nmodule_i2c_driver(ds1803_driver);\n\nMODULE_AUTHOR(\"Slawomir Stepien <sst@poczta.fm>\");\nMODULE_AUTHOR(\"Jagath Jog J <jagathjog1996@gmail.com>\");\nMODULE_DESCRIPTION(\"DS1803 digital potentiometer\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}