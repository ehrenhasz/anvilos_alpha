{
  "module_name": "ad5110.c",
  "hash_id": "57063d62f19fda97d2abff038bc235aea4097cea8265502e14937b536d0588b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/potentiometer/ad5110.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n \n#define AD5110_EEPROM_WR\t1\n#define AD5110_RDAC_WR\t\t2\n#define AD5110_SHUTDOWN\t3\n#define AD5110_RESET\t\t4\n#define AD5110_RDAC_RD\t\t5\n#define AD5110_EEPROM_RD\t6\n\n \n#define AD5110_WIPER_POS\t0\n#define AD5110_RESISTOR_TOL\t1\n\n#define AD5110_WIPER_RESISTANCE\t70\n\nstruct ad5110_cfg {\n\tint max_pos;\n\tint kohms;\n\tint shift;\n};\n\nenum ad5110_type {\n\tAD5110_10,\n\tAD5110_80,\n\tAD5112_05,\n\tAD5112_10,\n\tAD5112_80,\n\tAD5114_10,\n\tAD5114_80,\n};\n\nstatic const struct ad5110_cfg ad5110_cfg[] = {\n\t[AD5110_10] = { .max_pos = 128, .kohms = 10 },\n\t[AD5110_80] = { .max_pos = 128, .kohms = 80 },\n\t[AD5112_05] = { .max_pos = 64, .kohms = 5, .shift = 1 },\n\t[AD5112_10] = { .max_pos = 64, .kohms = 10, .shift = 1 },\n\t[AD5112_80] = { .max_pos = 64, .kohms = 80, .shift = 1 },\n\t[AD5114_10] = { .max_pos = 32, .kohms = 10, .shift = 2 },\n\t[AD5114_80] = { .max_pos = 32, .kohms = 80, .shift = 2 },\n};\n\nstruct ad5110_data {\n\tstruct i2c_client       *client;\n\ts16\t\t\ttol;\t\t \n\tbool\t\t\tenable;\n\tstruct mutex            lock;\n\tconst struct ad5110_cfg\t*cfg;\n\t \n\tu8\t\t\tbuf[2] __aligned(IIO_DMA_MINALIGN);\n};\n\nstatic const struct iio_chan_spec ad5110_channels[] = {\n\t{\n\t\t.type = IIO_RESISTANCE,\n\t\t.output = 1,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_OFFSET) |\n\t\t\t\t\tBIT(IIO_CHAN_INFO_SCALE) | BIT(IIO_CHAN_INFO_ENABLE),\n\t},\n};\n\nstatic int ad5110_read(struct ad5110_data *data, u8 cmd, int *val)\n{\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tdata->buf[0] = cmd;\n\tdata->buf[1] = *val;\n\n\tret = i2c_master_send_dmasafe(data->client, data->buf, sizeof(data->buf));\n\tif (ret < 0) {\n\t\tgoto error;\n\t} else if (ret != sizeof(data->buf)) {\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\n\tret = i2c_master_recv_dmasafe(data->client, data->buf, 1);\n\tif (ret < 0) {\n\t\tgoto error;\n\t} else if (ret != 1) {\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\n\t*val = data->buf[0];\n\tret = 0;\n\nerror:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int ad5110_write(struct ad5110_data *data, u8 cmd, u8 val)\n{\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tdata->buf[0] = cmd;\n\tdata->buf[1] = val;\n\n\tret = i2c_master_send_dmasafe(data->client, data->buf, sizeof(data->buf));\n\tif (ret < 0) {\n\t\tgoto error;\n\t} else if (ret != sizeof(data->buf)) {\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\n\tret = 0;\n\nerror:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int ad5110_resistor_tol(struct ad5110_data *data, u8 cmd, int val)\n{\n\tint ret;\n\n\tret = ad5110_read(data, cmd, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->tol = data->cfg->kohms * (val & GENMASK(6, 0)) * 10 / 8;\n\tif (!(val & BIT(7)))\n\t\tdata->tol *= -1;\n\n\treturn 0;\n}\n\nstatic ssize_t store_eeprom_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad5110_data *data = iio_priv(indio_dev);\n\tint val = AD5110_WIPER_POS;\n\tint ret;\n\n\tret = ad5110_read(data, AD5110_EEPROM_RD, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = val >> data->cfg->shift;\n\treturn iio_format_value(buf, IIO_VAL_INT, 1, &val);\n}\n\nstatic ssize_t store_eeprom_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t len)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct ad5110_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = ad5110_write(data, AD5110_EEPROM_WR, 0);\n\tif (ret) {\n\t\tdev_err(&data->client->dev, \"RDAC to EEPROM write failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tmsleep(20);\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR_RW(store_eeprom, 0);\n\nstatic struct attribute *ad5110_attributes[] = {\n\t&iio_dev_attr_store_eeprom.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ad5110_attribute_group = {\n\t.attrs = ad5110_attributes,\n};\n\nstatic int ad5110_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct ad5110_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = ad5110_read(data, AD5110_RDAC_RD, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = *val >> data->cfg->shift;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\t*val = AD5110_WIPER_RESISTANCE * data->cfg->max_pos;\n\t\t*val2 = 1000 * data->cfg->kohms + data->tol;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 1000 * data->cfg->kohms + data->tol;\n\t\t*val2 = data->cfg->max_pos;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\t*val = data->enable;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ad5110_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tstruct ad5110_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (val > data->cfg->max_pos || val < 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn ad5110_write(data, AD5110_RDAC_WR, val << data->cfg->shift);\n\tcase IIO_CHAN_INFO_ENABLE:\n\t\tif (val < 0 || val > 1)\n\t\t\treturn -EINVAL;\n\t\tif (data->enable == val)\n\t\t\treturn 0;\n\t\tret = ad5110_write(data, AD5110_SHUTDOWN, val ? 0 : 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdata->enable = val;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info ad5110_info = {\n\t.read_raw = ad5110_read_raw,\n\t.write_raw = ad5110_write_raw,\n\t.attrs = &ad5110_attribute_group,\n};\n\n#define AD5110_COMPATIBLE(of_compatible, cfg) {\t\\\n\t\t\t.compatible = of_compatible,\t\\\n\t\t\t.data = &ad5110_cfg[cfg],\t\\\n}\n\nstatic const struct of_device_id ad5110_of_match[] = {\n\tAD5110_COMPATIBLE(\"adi,ad5110-10\", AD5110_10),\n\tAD5110_COMPATIBLE(\"adi,ad5110-80\", AD5110_80),\n\tAD5110_COMPATIBLE(\"adi,ad5112-05\", AD5112_05),\n\tAD5110_COMPATIBLE(\"adi,ad5112-10\", AD5112_10),\n\tAD5110_COMPATIBLE(\"adi,ad5112-80\", AD5112_80),\n\tAD5110_COMPATIBLE(\"adi,ad5114-10\", AD5114_10),\n\tAD5110_COMPATIBLE(\"adi,ad5114-80\", AD5114_80),\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ad5110_of_match);\n\nstatic const struct i2c_device_id ad5110_id[] = {\n\t{ \"ad5110-10\", AD5110_10 },\n\t{ \"ad5110-80\", AD5110_80 },\n\t{ \"ad5112-05\", AD5112_05 },\n\t{ \"ad5112-10\", AD5112_10 },\n\t{ \"ad5112-80\", AD5112_80 },\n\t{ \"ad5114-10\", AD5114_10 },\n\t{ \"ad5114-80\", AD5114_80 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ad5110_id);\n\nstatic int ad5110_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct iio_dev *indio_dev;\n\tstruct ad5110_data *data;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\tdata->enable = 1;\n\tdata->cfg = device_get_match_data(dev);\n\n\t \n\tret = ad5110_write(data, AD5110_RESET, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Refresh RDAC with EEPROM failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ad5110_resistor_tol(data, AD5110_EEPROM_RD, AD5110_RESISTOR_TOL);\n\tif (ret) {\n\t\tdev_err(dev, \"Read resistor tolerance failed\\n\");\n\t\treturn ret;\n\t}\n\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &ad5110_info;\n\tindio_dev->channels = ad5110_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ad5110_channels);\n\tindio_dev->name = client->name;\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\n\nstatic struct i2c_driver ad5110_driver = {\n\t.driver = {\n\t\t.name\t= \"ad5110\",\n\t\t.of_match_table = ad5110_of_match,\n\t},\n\t.probe\t\t= ad5110_probe,\n\t.id_table\t= ad5110_id,\n};\nmodule_i2c_driver(ad5110_driver);\n\nMODULE_AUTHOR(\"Mugilraj Dhavachelvan <dmugil2000@gmail.com>\");\nMODULE_DESCRIPTION(\"AD5110 digital potentiometer\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}