{
  "module_name": "yamaha-yas530.c",
  "hash_id": "f0714d97a9fda59ed7613d1118ba8766efbe2f0ea7bf8fc27979d6c96fab9a9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/magnetometer/yamaha-yas530.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/random.h>\n#include <linux/units.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n#include <asm/unaligned.h>\n\n \n#define YAS5XX_DEVICE_ID\t\t0x80\n#define YAS5XX_MEASURE_DATA\t\t0xB0\n\n \n#define YAS530_ACTUATE_INIT_COIL\t0x81\n#define YAS530_MEASURE\t\t\t0x82\n#define YAS530_CONFIG\t\t\t0x83\n#define YAS530_MEASURE_INTERVAL\t\t0x84\n#define YAS530_OFFSET_X\t\t\t0x85  \n#define YAS530_OFFSET_Y1\t\t0x86  \n#define YAS530_OFFSET_Y2\t\t0x87  \n#define YAS530_TEST1\t\t\t0x88\n#define YAS530_TEST2\t\t\t0x89\n#define YAS530_CAL\t\t\t0x90\n\n \n#define YAS537_MEASURE\t\t\t0x81  \n#define YAS537_CONFIG\t\t\t0x82  \n#define YAS537_MEASURE_INTERVAL\t\t0x83  \n#define YAS537_OFFSET_X\t\t\t0x84  \n#define YAS537_OFFSET_Y1\t\t0x85  \n#define YAS537_OFFSET_Y2\t\t0x86  \n#define YAS537_AVR\t\t\t0x87\n#define YAS537_HCK\t\t\t0x88\n#define YAS537_LCK\t\t\t0x89\n#define YAS537_SRST\t\t\t0x90\n#define YAS537_ADCCAL\t\t\t0x91\n#define YAS537_MTC\t\t\t0x93\n#define YAS537_OC\t\t\t0x9E\n#define YAS537_TRM\t\t\t0x9F\n#define YAS537_CAL\t\t\t0xC0\n\n \n#define YAS5XX_CONFIG_INTON\t\tBIT(0)  \n#define YAS5XX_CONFIG_INTHACT\t\tBIT(1)  \n#define YAS5XX_CONFIG_CCK_MASK\t\tGENMASK(4, 2)\n#define YAS5XX_CONFIG_CCK_SHIFT\t\t2\n\n \n#define YAS5XX_MEASURE_START\t\tBIT(0)\n#define YAS5XX_MEASURE_LDTC\t\tBIT(1)\n#define YAS5XX_MEASURE_FORS\t\tBIT(2)\n#define YAS5XX_MEASURE_DLYMES\t\tBIT(4)\n#define YAS5XX_MEASURE_CONT\t\tBIT(5)\n\n \n#define YAS5XX_MEASURE_DATA_BUSY\tBIT(7)\n\n#define YAS530_DEVICE_ID\t\t0x01  \n#define YAS530_VERSION_A\t\t0  \n#define YAS530_VERSION_B\t\t1  \n#define YAS530_VERSION_A_COEF\t\t380\n#define YAS530_VERSION_B_COEF\t\t550\n#define YAS530_DATA_BITS\t\t12\n#define YAS530_DATA_CENTER\t\tBIT(YAS530_DATA_BITS - 1)\n#define YAS530_DATA_OVERFLOW\t\t(BIT(YAS530_DATA_BITS) - 1)\n\n#define YAS532_DEVICE_ID\t\t0x02  \n#define YAS532_VERSION_AB\t\t0  \n#define YAS532_VERSION_AC\t\t1  \n#define YAS532_VERSION_AB_COEF\t\t1800\n#define YAS532_VERSION_AC_COEF_X\t850\n#define YAS532_VERSION_AC_COEF_Y1\t750\n#define YAS532_VERSION_AC_COEF_Y2\t750\n#define YAS532_DATA_BITS\t\t13\n#define YAS532_DATA_CENTER\t\tBIT(YAS532_DATA_BITS - 1)\n#define YAS532_DATA_OVERFLOW\t\t(BIT(YAS532_DATA_BITS) - 1)\n\n#define YAS537_DEVICE_ID\t\t0x07  \n#define YAS537_VERSION_0\t\t0  \n#define YAS537_VERSION_1\t\t1  \n#define YAS537_MAG_AVERAGE_32_MASK\tGENMASK(6, 4)\n#define YAS537_MEASURE_TIME_WORST_US\t1500\n#define YAS537_DEFAULT_SENSOR_DELAY_MS\t50\n#define YAS537_MAG_RCOIL_TIME_US\t65\n#define YAS537_MTC3_MASK_PREP\t\tGENMASK(7, 0)\n#define YAS537_MTC3_MASK_GET\t\tGENMASK(7, 5)\n#define YAS537_MTC3_ADD_BIT\t\tBIT(4)\n#define YAS537_HCK_MASK_PREP\t\tGENMASK(4, 0)\n#define YAS537_HCK_MASK_GET\t\tGENMASK(7, 4)\n#define YAS537_LCK_MASK_PREP\t\tGENMASK(4, 0)\n#define YAS537_LCK_MASK_GET\t\tGENMASK(3, 0)\n#define YAS537_OC_MASK_GET\t\tGENMASK(5, 0)\n\n \n#define YAS5XX_AUTOSUSPEND_DELAY_MS\t5000\n\nenum chip_ids {\n\tyas530,\n\tyas532,\n\tyas533,\n\tyas537,\n};\n\nstatic const int yas530_volatile_reg[] = {\n\tYAS530_ACTUATE_INIT_COIL,\n\tYAS530_MEASURE,\n};\n\nstatic const int yas537_volatile_reg[] = {\n\tYAS537_MEASURE,\n};\n\nstruct yas5xx_calibration {\n\t \n\ts32 r[3];\n\tu32 f[3];\n\t \n\ts16 Cx, Cy1, Cy2;\n\t \n\ts8  a2, a3, a4, a6, a7, a8;\n\ts16 a5, a9;\n\tu8  k;\n\t \n\tu8 dck;\n};\n\nstruct yas5xx;\n\n \nstruct yas5xx_chip_info {\n\tunsigned int devid;\n\tconst char *product_name;\n\tconst char *version_names[2];\n\tconst int *volatile_reg;\n\tint volatile_reg_qty;\n\tu32 scaling_val2;\n\tu16 t_ref;\n\ts16 min_temp_x10;\n\tint (*get_measure)(struct yas5xx *yas5xx, s32 *to, s32 *xo, s32 *yo, s32 *zo);\n\tint (*get_calibration_data)(struct yas5xx *yas5xx);\n\tvoid (*dump_calibration)(struct yas5xx *yas5xx);\n\tint (*measure_offsets)(struct yas5xx *yas5xx);\n\tint (*power_on)(struct yas5xx *yas5xx);\n};\n\n \nstruct yas5xx {\n\tstruct device *dev;\n\tconst struct yas5xx_chip_info *chip_info;\n\tunsigned int version;\n\tstruct yas5xx_calibration calibration;\n\ts8 hard_offsets[3];\n\tstruct iio_mount_matrix orientation;\n\tstruct regmap *map;\n\tstruct regulator_bulk_data regs[2];\n\tstruct gpio_desc *reset;\n\tstruct mutex lock;\n\t \n\tstruct {\n\t\ts32 channels[4];\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\n \nstatic u16 yas530_extract_axis(u8 *data)\n{\n\tu16 val;\n\n\t \n\tval = get_unaligned_be16(&data[0]);\n\tval = FIELD_GET(GENMASK(14, 3), val);\n\treturn val;\n}\n\n \nstatic u16 yas532_extract_axis(u8 *data)\n{\n\tu16 val;\n\n\t \n\tval = get_unaligned_be16(&data[0]);\n\tval = FIELD_GET(GENMASK(14, 2), val);\n\treturn val;\n}\n\n \nstatic int yas530_measure(struct yas5xx *yas5xx, u16 *t, u16 *x, u16 *y1, u16 *y2)\n{\n\tconst struct yas5xx_chip_info *ci = yas5xx->chip_info;\n\tunsigned int busy;\n\tu8 data[8];\n\tint ret;\n\tu16 val;\n\n\tmutex_lock(&yas5xx->lock);\n\tret = regmap_write(yas5xx->map, YAS530_MEASURE, YAS5XX_MEASURE_START);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\t \n\tret = regmap_read_poll_timeout(yas5xx->map, YAS5XX_MEASURE_DATA, busy,\n\t\t\t\t       !(busy & YAS5XX_MEASURE_DATA_BUSY),\n\t\t\t\t       500, 20000);\n\tif (ret) {\n\t\tdev_err(yas5xx->dev, \"timeout waiting for measurement\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tret = regmap_bulk_read(yas5xx->map, YAS5XX_MEASURE_DATA,\n\t\t\t       data, sizeof(data));\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tmutex_unlock(&yas5xx->lock);\n\n\tswitch (ci->devid) {\n\tcase YAS530_DEVICE_ID:\n\t\t \n\t\tval = get_unaligned_be16(&data[0]);\n\t\tval = FIELD_GET(GENMASK(14, 6), val);\n\t\t*t = val;\n\t\t*x = yas530_extract_axis(&data[2]);\n\t\t*y1 = yas530_extract_axis(&data[4]);\n\t\t*y2 = yas530_extract_axis(&data[6]);\n\t\tbreak;\n\tcase YAS532_DEVICE_ID:\n\t\t \n\t\tval = get_unaligned_be16(&data[0]);\n\t\tval = FIELD_GET(GENMASK(14, 5), val);\n\t\t*t = val;\n\t\t*x = yas532_extract_axis(&data[2]);\n\t\t*y1 = yas532_extract_axis(&data[4]);\n\t\t*y2 = yas532_extract_axis(&data[6]);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(yas5xx->dev, \"unknown data format\\n\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n\nout_unlock:\n\tmutex_unlock(&yas5xx->lock);\n\treturn ret;\n}\n\n \nstatic int yas537_measure(struct yas5xx *yas5xx, u16 *t, u16 *x, u16 *y1, u16 *y2)\n{\n\tstruct yas5xx_calibration *c = &yas5xx->calibration;\n\tunsigned int busy;\n\tu8 data[8];\n\tu16 xy1y2[3];\n\ts32 h[3], s[3];\n\tint i, ret;\n\n\tmutex_lock(&yas5xx->lock);\n\n\t \n\tret = regmap_write(yas5xx->map, YAS537_MEASURE, YAS5XX_MEASURE_START |\n\t\t\t   YAS5XX_MEASURE_CONT);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\t \n\tret = regmap_read_poll_timeout(yas5xx->map, YAS5XX_MEASURE_DATA + 2, busy,\n\t\t\t\t       !(busy & YAS5XX_MEASURE_DATA_BUSY),\n\t\t\t\t       500, 20000);\n\tif (ret) {\n\t\tdev_err(yas5xx->dev, \"timeout waiting for measurement\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tret = regmap_bulk_read(yas5xx->map, YAS5XX_MEASURE_DATA,\n\t\t\t       data, sizeof(data));\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tmutex_unlock(&yas5xx->lock);\n\n\t*t = get_unaligned_be16(&data[0]);\n\txy1y2[0] = FIELD_GET(GENMASK(13, 0), get_unaligned_be16(&data[2]));\n\txy1y2[1] = get_unaligned_be16(&data[4]);\n\txy1y2[2] = get_unaligned_be16(&data[6]);\n\n\t \n\tif (yas5xx->version == YAS537_VERSION_1) {\n\t\tfor (i = 0; i < 3; i++)\n\t\t\ts[i] = xy1y2[i] - BIT(13);\n\t\th[0] = (c->k *   (128 * s[0] + c->a2 * s[1] + c->a3 * s[2])) / BIT(13);\n\t\th[1] = (c->k * (c->a4 * s[0] + c->a5 * s[1] + c->a6 * s[2])) / BIT(13);\n\t\th[2] = (c->k * (c->a7 * s[0] + c->a8 * s[1] + c->a9 * s[2])) / BIT(13);\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tclamp_val(h[i], -BIT(13), BIT(13) - 1);\n\t\t\txy1y2[i] = h[i] + BIT(13);\n\t\t}\n\t}\n\n\t*x = xy1y2[0];\n\t*y1 = xy1y2[1];\n\t*y2 = xy1y2[2];\n\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&yas5xx->lock);\n\treturn ret;\n}\n\n \nstatic s32 yas530_linearize(struct yas5xx *yas5xx, u16 val, int axis)\n{\n\tconst struct yas5xx_chip_info *ci = yas5xx->chip_info;\n\tstruct yas5xx_calibration *c = &yas5xx->calibration;\n\tstatic const s32 yas532ac_coef[] = {\n\t\tYAS532_VERSION_AC_COEF_X,\n\t\tYAS532_VERSION_AC_COEF_Y1,\n\t\tYAS532_VERSION_AC_COEF_Y2,\n\t};\n\ts32 coef;\n\n\t \n\tswitch (ci->devid) {\n\tcase YAS530_DEVICE_ID:\n\t\tif (yas5xx->version == YAS530_VERSION_A)\n\t\t\tcoef = YAS530_VERSION_A_COEF;\n\t\telse\n\t\t\tcoef = YAS530_VERSION_B_COEF;\n\t\tbreak;\n\tcase YAS532_DEVICE_ID:\n\t\tif (yas5xx->version == YAS532_VERSION_AB)\n\t\t\tcoef = YAS532_VERSION_AB_COEF;\n\t\telse\n\t\t\t \n\t\t\tcoef = yas532ac_coef[axis];\n\t\tbreak;\n\tdefault:\n\t\tdev_err(yas5xx->dev, \"unknown device type\\n\");\n\t\treturn val;\n\t}\n\t \n\treturn val - (3721 + 50 * c->f[axis]) +\n\t\t(yas5xx->hard_offsets[axis] - c->r[axis]) * coef;\n}\n\nstatic s32 yas5xx_calc_temperature(struct yas5xx *yas5xx, u16 t)\n{\n\tconst struct yas5xx_chip_info *ci = yas5xx->chip_info;\n\ts32 to;\n\tu16 t_ref;\n\ts16 min_temp_x10;\n\tint ref_temp_x10;\n\n\tt_ref = ci->t_ref;\n\tmin_temp_x10 = ci->min_temp_x10;\n\tref_temp_x10 = 200;\n\n\tto = (min_temp_x10 + ((ref_temp_x10 - min_temp_x10) * t / t_ref)) * 100;\n\treturn to;\n}\n\n \nstatic int yas530_get_measure(struct yas5xx *yas5xx, s32 *to, s32 *xo, s32 *yo, s32 *zo)\n{\n\tconst struct yas5xx_chip_info *ci = yas5xx->chip_info;\n\tstruct yas5xx_calibration *c = &yas5xx->calibration;\n\tu16 t_ref, t_comp, t, x, y1, y2;\n\t \n\ts32 sx, sy1, sy2, sy, sz;\n\tint ret;\n\n\t \n\tret = yas530_measure(yas5xx, &t, &x, &y1, &y2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsx = yas530_linearize(yas5xx, x, 0);\n\tsy1 = yas530_linearize(yas5xx, y1, 1);\n\tsy2 = yas530_linearize(yas5xx, y2, 2);\n\n\t \n\tt_ref = ci->t_ref;\n\tif (ci->devid == YAS532_DEVICE_ID &&\n\t    yas5xx->version == YAS532_VERSION_AC) {\n\t\tt_comp = t - t_ref;\n\t} else {\n\t\tt_comp = t;\n\t}\n\n\t \n\tsx = sx - (c->Cx * t_comp) / 100;\n\tsy1 = sy1 - (c->Cy1 * t_comp) / 100;\n\tsy2 = sy2 - (c->Cy2 * t_comp) / 100;\n\n\t \n\tsy = sy1 - sy2;\n\tsz = -sy1 - sy2;\n\n\t \n\t*to = yas5xx_calc_temperature(yas5xx, t);\n\n\t \n\t*xo = c->k * ((100 * sx + c->a2 * sy + c->a3 * sz) / 10);\n\t*yo = c->k * ((c->a4 * sx + c->a5 * sy + c->a6 * sz) / 10);\n\t*zo = c->k * ((c->a7 * sx + c->a8 * sy + c->a9 * sz) / 10);\n\n\treturn 0;\n}\n\n \nstatic int yas537_get_measure(struct yas5xx *yas5xx, s32 *to, s32 *xo, s32 *yo, s32 *zo)\n{\n\tu16 t, x, y1, y2;\n\tint ret;\n\n\t \n\tret = yas537_measure(yas5xx, &t, &x, &y1, &y2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*to = yas5xx_calc_temperature(yas5xx, t);\n\n\t \n\n\t \n\t*xo = (x - BIT(13)) * 300;\n\t*yo = (y1 - y2) * 1732 / 10;\n\t*zo = (-y1 - y2 + BIT(14)) * 300;\n\n\treturn 0;\n}\n\nstatic int yas5xx_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2,\n\t\t\t   long mask)\n{\n\tstruct yas5xx *yas5xx = iio_priv(indio_dev);\n\tconst struct yas5xx_chip_info *ci = yas5xx->chip_info;\n\ts32 t, x, y, z;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\tcase IIO_CHAN_INFO_RAW:\n\t\tpm_runtime_get_sync(yas5xx->dev);\n\t\tret = ci->get_measure(yas5xx, &t, &x, &y, &z);\n\t\tpm_runtime_mark_last_busy(yas5xx->dev);\n\t\tpm_runtime_put_autosuspend(yas5xx->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tswitch (chan->address) {\n\t\tcase 0:\n\t\t\t*val = t;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*val = x;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*val = y;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t*val = z;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(yas5xx->dev, \"unknown channel\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 1;\n\t\t*val2 = ci->scaling_val2;\n\t\treturn IIO_VAL_FRACTIONAL;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void yas5xx_fill_buffer(struct iio_dev *indio_dev)\n{\n\tstruct yas5xx *yas5xx = iio_priv(indio_dev);\n\tconst struct yas5xx_chip_info *ci = yas5xx->chip_info;\n\ts32 t, x, y, z;\n\tint ret;\n\n\tpm_runtime_get_sync(yas5xx->dev);\n\tret = ci->get_measure(yas5xx, &t, &x, &y, &z);\n\tpm_runtime_mark_last_busy(yas5xx->dev);\n\tpm_runtime_put_autosuspend(yas5xx->dev);\n\tif (ret) {\n\t\tdev_err(yas5xx->dev, \"error refilling buffer\\n\");\n\t\treturn;\n\t}\n\tyas5xx->scan.channels[0] = t;\n\tyas5xx->scan.channels[1] = x;\n\tyas5xx->scan.channels[2] = y;\n\tyas5xx->scan.channels[3] = z;\n\tiio_push_to_buffers_with_timestamp(indio_dev, &yas5xx->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n}\n\nstatic irqreturn_t yas5xx_handle_trigger(int irq, void *p)\n{\n\tconst struct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\n\tyas5xx_fill_buffer(indio_dev);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\n\nstatic const struct iio_mount_matrix *\nyas5xx_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\tconst struct iio_chan_spec *chan)\n{\n\tstruct yas5xx *yas5xx = iio_priv(indio_dev);\n\n\treturn &yas5xx->orientation;\n}\n\nstatic const struct iio_chan_spec_ext_info yas5xx_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_DIR, yas5xx_get_mount_matrix),\n\t{ }\n};\n\n#define YAS5XX_AXIS_CHANNEL(axis, index)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_MAGN,\t\t\t\t\t\\\n\t\t.modified = 1,\t\t\t\t\t\t\\\n\t\t.channel2 = IIO_MOD_##axis,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\t\t\t\\\n\t\t.ext_info = yas5xx_ext_info,\t\t\t\t\\\n\t\t.address = index,\t\t\t\t\t\\\n\t\t.scan_index = index,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\t\\\n\t\t\t.realbits = 32,\t\t\t\t\t\\\n\t\t\t.storagebits = 32,\t\t\t\t\\\n\t\t\t.endianness = IIO_CPU,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec yas5xx_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n\t\t.address = 0,\n\t\t.scan_index = 0,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 32,\n\t\t\t.storagebits = 32,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\tYAS5XX_AXIS_CHANNEL(X, 1),\n\tYAS5XX_AXIS_CHANNEL(Y, 2),\n\tYAS5XX_AXIS_CHANNEL(Z, 3),\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic const unsigned long yas5xx_scan_masks[] = { GENMASK(3, 0), 0 };\n\nstatic const struct iio_info yas5xx_info = {\n\t.read_raw = &yas5xx_read_raw,\n};\n\nstatic bool yas5xx_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct yas5xx *yas5xx = iio_priv(indio_dev);\n\tconst struct yas5xx_chip_info *ci = yas5xx->chip_info;\n\tint reg_qty;\n\tint i;\n\n\tif (reg >= YAS5XX_MEASURE_DATA && reg < YAS5XX_MEASURE_DATA + 8)\n\t\treturn true;\n\n\t \n\treg_qty = ci->volatile_reg_qty;\n\tfor (i = 0; i < reg_qty; i++) {\n\t\tif (reg == ci->volatile_reg[i])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic const struct regmap_config yas5xx_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xff,\n\t.volatile_reg = yas5xx_volatile_reg,\n};\n\n \nstatic void yas530_extract_calibration(u8 *data, struct yas5xx_calibration *c)\n{\n\tu64 val = get_unaligned_be64(data);\n\n\t \n\tc->a2 = FIELD_GET(GENMASK_ULL(63, 58), val) - 32;\n\tc->a3 = FIELD_GET(GENMASK_ULL(57, 54), val) - 8;\n\tc->a4 = FIELD_GET(GENMASK_ULL(53, 48), val) - 32;\n\tc->a5 = FIELD_GET(GENMASK_ULL(47, 42), val) + 38;\n\tc->a6 = FIELD_GET(GENMASK_ULL(41, 36), val) - 32;\n\tc->a7 = FIELD_GET(GENMASK_ULL(35, 29), val) - 64;\n\tc->a8 = FIELD_GET(GENMASK_ULL(28, 23), val) - 32;\n\tc->a9 = FIELD_GET(GENMASK_ULL(22, 15), val);\n\tc->k = FIELD_GET(GENMASK_ULL(14, 10), val) + 10;\n\tc->dck = FIELD_GET(GENMASK_ULL(9, 7), val);\n}\n\nstatic int yas530_get_calibration_data(struct yas5xx *yas5xx)\n{\n\tstruct yas5xx_calibration *c = &yas5xx->calibration;\n\tu8 data[16];\n\tu32 val;\n\tint ret;\n\n\t \n\tret = regmap_bulk_read(yas5xx->map, YAS530_CAL, data, sizeof(data));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_bulk_read(yas5xx->map, YAS530_CAL, data, sizeof(data));\n\tif (ret)\n\t\treturn ret;\n\tdev_dbg(yas5xx->dev, \"calibration data: %16ph\\n\", data);\n\n\t \n\tadd_device_randomness(data, sizeof(data));\n\n\t \n\tyas5xx->version = data[15] & GENMASK(1, 0);\n\n\t \n\tc->Cx = data[0] * 6 - 768;\n\tc->Cy1 = data[1] * 6 - 768;\n\tc->Cy2 = data[2] * 6 - 768;\n\tyas530_extract_calibration(&data[3], c);\n\n\t \n\tval = get_unaligned_be32(&data[11]);\n\tc->f[0] = FIELD_GET(GENMASK(22, 21), val);\n\tc->f[1] = FIELD_GET(GENMASK(14, 13), val);\n\tc->f[2] = FIELD_GET(GENMASK(6, 5), val);\n\tc->r[0] = sign_extend32(FIELD_GET(GENMASK(28, 23), val), 5);\n\tc->r[1] = sign_extend32(FIELD_GET(GENMASK(20, 15), val), 5);\n\tc->r[2] = sign_extend32(FIELD_GET(GENMASK(12, 7), val), 5);\n\n\treturn 0;\n}\n\nstatic int yas532_get_calibration_data(struct yas5xx *yas5xx)\n{\n\tstruct yas5xx_calibration *c = &yas5xx->calibration;\n\tu8 data[14];\n\tu32 val;\n\tint ret;\n\n\t \n\tret = regmap_bulk_read(yas5xx->map, YAS530_CAL, data, sizeof(data));\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = regmap_bulk_read(yas5xx->map, YAS530_CAL, data, sizeof(data));\n\tif (ret)\n\t\treturn ret;\n\tdev_dbg(yas5xx->dev, \"calibration data: %14ph\\n\", data);\n\n\t \n\tif (!memchr_inv(data, 0x00, 13) && !(data[13] & BIT(7)))\n\t\tdev_warn(yas5xx->dev, \"calibration is blank!\\n\");\n\n\t \n\tadd_device_randomness(data, sizeof(data));\n\n\t \n\tyas5xx->version = data[13] & BIT(0);\n\n\t \n\tc->Cx = data[0] * 10 - 1280;\n\tc->Cy1 = data[1] * 10 - 1280;\n\tc->Cy2 = data[2] * 10 - 1280;\n\tyas530_extract_calibration(&data[3], c);\n\n\t \n\tval = get_unaligned_be32(&data[10]);\n\tc->f[0] = FIELD_GET(GENMASK(24, 23), val);\n\tc->f[1] = FIELD_GET(GENMASK(16, 15), val);\n\tc->f[2] = FIELD_GET(GENMASK(8, 7), val);\n\tc->r[0] = sign_extend32(FIELD_GET(GENMASK(30, 25), val), 5);\n\tc->r[1] = sign_extend32(FIELD_GET(GENMASK(22, 17), val), 5);\n\tc->r[2] = sign_extend32(FIELD_GET(GENMASK(14, 7), val), 5);\n\n\treturn 0;\n}\n\nstatic int yas537_get_calibration_data(struct yas5xx *yas5xx)\n{\n\tstruct yas5xx_calibration *c = &yas5xx->calibration;\n\tu8 data[17];\n\tu32 val1, val2, val3, val4;\n\tint i, ret;\n\n\t \n\tret = regmap_write(yas5xx->map, YAS537_SRST, BIT(1));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_bulk_read(yas5xx->map, YAS537_CAL, data, sizeof(data));\n\tif (ret)\n\t\treturn ret;\n\tdev_dbg(yas5xx->dev, \"calibration data: %17ph\\n\", data);\n\n\t \n\tif (!memchr_inv(data, 0x00, 16) && !FIELD_GET(GENMASK(5, 0), data[16]))\n\t\tdev_warn(yas5xx->dev, \"calibration is blank!\\n\");\n\n\t \n\tadd_device_randomness(data, sizeof(data));\n\n\t \n\tyas5xx->version = FIELD_GET(GENMASK(7, 6), data[16]);\n\n\t \n\tswitch (yas5xx->version) {\n\tcase YAS537_VERSION_0:\n\t\t \n\t\tfor (i = 0; i < 12; i++) {\n\t\t\tret = regmap_write(yas5xx->map, YAS537_MTC + i,\n\t\t\t\t\t   data[i]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tret = regmap_write(yas5xx->map, YAS537_OFFSET_X + i,\n\t\t\t\t\t   data[i + 12]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tyas5xx->hard_offsets[i] = data[i + 12];\n\t\t}\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tret = regmap_write(yas5xx->map, YAS537_HCK + i,\n\t\t\t\t\t   data[i + 15]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase YAS537_VERSION_1:\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tret = regmap_write(yas5xx->map, YAS537_MTC + i,\n\t\t\t\t\t   data[i]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tret = regmap_write(yas5xx->map, YAS537_OFFSET_X + i,\n\t\t\t\t\t   data[i + 12]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tyas5xx->hard_offsets[i] = data[i + 12];\n\t\t}\n\t\t \n\t\tret = regmap_write(yas5xx->map, YAS537_MTC + 3,\n\t\t\t\t   FIELD_PREP(YAS537_MTC3_MASK_PREP,\n\t\t\t\t   FIELD_GET(YAS537_MTC3_MASK_GET, data[3])) |\n\t\t\t\t   YAS537_MTC3_ADD_BIT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = regmap_write(yas5xx->map, YAS537_HCK,\n\t\t\t\t   FIELD_PREP(YAS537_HCK_MASK_PREP,\n\t\t\t\t   FIELD_GET(YAS537_HCK_MASK_GET, data[15])));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = regmap_write(yas5xx->map, YAS537_LCK,\n\t\t\t\t   FIELD_PREP(YAS537_LCK_MASK_PREP,\n\t\t\t\t   FIELD_GET(YAS537_LCK_MASK_GET, data[15])));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = regmap_write(yas5xx->map, YAS537_OC,\n\t\t\t\t   FIELD_GET(YAS537_OC_MASK_GET, data[16]));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tval1 = get_unaligned_be32(&data[0]);\n\t\tval2 = get_unaligned_be32(&data[3]);\n\t\tval3 = get_unaligned_be32(&data[6]);\n\t\tval4 = get_unaligned_be32(&data[9]);\n\t\t \n\t\tc->Cx  = FIELD_GET(GENMASK(31, 23), val1) - 256;\n\t\tc->Cy1 = FIELD_GET(GENMASK(22, 14), val1) - 256;\n\t\tc->Cy2 = FIELD_GET(GENMASK(13,  5), val1) - 256;\n\t\tc->a2  = FIELD_GET(GENMASK(28, 22), val2) -  64;\n\t\tc->a3  = FIELD_GET(GENMASK(21, 15), val2) -  64;\n\t\tc->a4  = FIELD_GET(GENMASK(14,  7), val2) - 128;\n\t\tc->a5  = FIELD_GET(GENMASK(30, 22), val3) - 112;\n\t\tc->a6  = FIELD_GET(GENMASK(21, 15), val3) -  64;\n\t\tc->a7  = FIELD_GET(GENMASK(14,  7), val3) - 128;\n\t\tc->a8  = FIELD_GET(GENMASK(30, 24), val4) -  64;\n\t\tc->a9  = FIELD_GET(GENMASK(23, 15), val4) - 112;\n\t\tc->k   = FIELD_GET(GENMASK(14,  8), val4);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(yas5xx->dev, \"unknown version of YAS537\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void yas530_dump_calibration(struct yas5xx *yas5xx)\n{\n\tstruct yas5xx_calibration *c = &yas5xx->calibration;\n\n\tdev_dbg(yas5xx->dev, \"f[] = [%d, %d, %d]\\n\",\n\t\tc->f[0], c->f[1], c->f[2]);\n\tdev_dbg(yas5xx->dev, \"r[] = [%d, %d, %d]\\n\",\n\t\tc->r[0], c->r[1], c->r[2]);\n\tdev_dbg(yas5xx->dev, \"Cx = %d\\n\", c->Cx);\n\tdev_dbg(yas5xx->dev, \"Cy1 = %d\\n\", c->Cy1);\n\tdev_dbg(yas5xx->dev, \"Cy2 = %d\\n\", c->Cy2);\n\tdev_dbg(yas5xx->dev, \"a2 = %d\\n\", c->a2);\n\tdev_dbg(yas5xx->dev, \"a3 = %d\\n\", c->a3);\n\tdev_dbg(yas5xx->dev, \"a4 = %d\\n\", c->a4);\n\tdev_dbg(yas5xx->dev, \"a5 = %d\\n\", c->a5);\n\tdev_dbg(yas5xx->dev, \"a6 = %d\\n\", c->a6);\n\tdev_dbg(yas5xx->dev, \"a7 = %d\\n\", c->a7);\n\tdev_dbg(yas5xx->dev, \"a8 = %d\\n\", c->a8);\n\tdev_dbg(yas5xx->dev, \"a9 = %d\\n\", c->a9);\n\tdev_dbg(yas5xx->dev, \"k = %d\\n\", c->k);\n\tdev_dbg(yas5xx->dev, \"dck = %d\\n\", c->dck);\n}\n\nstatic void yas537_dump_calibration(struct yas5xx *yas5xx)\n{\n\tstruct yas5xx_calibration *c = &yas5xx->calibration;\n\n\tif (yas5xx->version == YAS537_VERSION_1) {\n\t\tdev_dbg(yas5xx->dev, \"Cx = %d\\n\", c->Cx);\n\t\tdev_dbg(yas5xx->dev, \"Cy1 = %d\\n\", c->Cy1);\n\t\tdev_dbg(yas5xx->dev, \"Cy2 = %d\\n\", c->Cy2);\n\t\tdev_dbg(yas5xx->dev, \"a2 = %d\\n\", c->a2);\n\t\tdev_dbg(yas5xx->dev, \"a3 = %d\\n\", c->a3);\n\t\tdev_dbg(yas5xx->dev, \"a4 = %d\\n\", c->a4);\n\t\tdev_dbg(yas5xx->dev, \"a5 = %d\\n\", c->a5);\n\t\tdev_dbg(yas5xx->dev, \"a6 = %d\\n\", c->a6);\n\t\tdev_dbg(yas5xx->dev, \"a7 = %d\\n\", c->a7);\n\t\tdev_dbg(yas5xx->dev, \"a8 = %d\\n\", c->a8);\n\t\tdev_dbg(yas5xx->dev, \"a9 = %d\\n\", c->a9);\n\t\tdev_dbg(yas5xx->dev, \"k = %d\\n\", c->k);\n\t}\n}\n\n \nstatic int yas530_set_offsets(struct yas5xx *yas5xx, s8 ox, s8 oy1, s8 oy2)\n{\n\tint ret;\n\n\tret = regmap_write(yas5xx->map, YAS530_OFFSET_X, ox);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(yas5xx->map, YAS530_OFFSET_Y1, oy1);\n\tif (ret)\n\t\treturn ret;\n\treturn regmap_write(yas5xx->map, YAS530_OFFSET_Y2, oy2);\n}\n\n \nstatic s8 yas530_adjust_offset(s8 old, int bit, u16 center, u16 measure)\n{\n\tif (measure > center)\n\t\treturn old + BIT(bit);\n\tif (measure < center)\n\t\treturn old - BIT(bit);\n\treturn old;\n}\n\n \nstatic int yas530_measure_offsets(struct yas5xx *yas5xx)\n{\n\tconst struct yas5xx_chip_info *ci = yas5xx->chip_info;\n\tint ret;\n\tu16 center;\n\tu16 t, x, y1, y2;\n\ts8 ox, oy1, oy2;\n\tint i;\n\n\t \n\tret = regmap_write(yas5xx->map, YAS530_ACTUATE_INIT_COIL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (ci->devid) {\n\tcase YAS530_DEVICE_ID:\n\t\tcenter = YAS530_DATA_CENTER;\n\t\tbreak;\n\tcase YAS532_DEVICE_ID:\n\t\tcenter = YAS532_DATA_CENTER;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(yas5xx->dev, \"unknown device type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tox = 0;\n\toy1 = 0;\n\toy2 = 0;\n\n\tfor (i = 4; i >= 0; i--) {\n\t\tret = yas530_set_offsets(yas5xx, ox, oy1, oy2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = yas530_measure(yas5xx, &t, &x, &y1, &y2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdev_dbg(yas5xx->dev, \"measurement %d: x=%d, y1=%d, y2=%d\\n\",\n\t\t\t5-i, x, y1, y2);\n\n\t\tox = yas530_adjust_offset(ox, i, center, x);\n\t\toy1 = yas530_adjust_offset(oy1, i, center, y1);\n\t\toy2 = yas530_adjust_offset(oy2, i, center, y2);\n\t}\n\n\t \n\tyas5xx->hard_offsets[0] = ox;\n\tyas5xx->hard_offsets[1] = oy1;\n\tyas5xx->hard_offsets[2] = oy2;\n\tret = yas530_set_offsets(yas5xx, ox, oy1, oy2);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(yas5xx->dev, \"discovered hard offsets: x=%d, y1=%d, y2=%d\\n\",\n\t\t ox, oy1, oy2);\n\treturn 0;\n}\n\n \nstatic int yas530_power_on(struct yas5xx *yas5xx)\n{\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_write(yas5xx->map, YAS530_TEST1, 0);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(yas5xx->map, YAS530_TEST2, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = FIELD_PREP(YAS5XX_CONFIG_CCK_MASK, yas5xx->calibration.dck);\n\tret = regmap_write(yas5xx->map, YAS530_CONFIG, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_write(yas5xx->map, YAS530_MEASURE_INTERVAL, 0);\n}\n\nstatic int yas537_power_on(struct yas5xx *yas5xx)\n{\n\t__be16 buf;\n\tint ret;\n\tu8 intrvl;\n\n\t \n\tbuf = cpu_to_be16(GENMASK(9, 3));\n\tret = regmap_bulk_write(yas5xx->map, YAS537_ADCCAL, &buf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(yas5xx->map, YAS537_TRM, GENMASK(7, 0));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tintrvl = (YAS537_DEFAULT_SENSOR_DELAY_MS * MILLI\n\t\t - YAS537_MEASURE_TIME_WORST_US) / 4100;\n\tret = regmap_write(yas5xx->map, YAS537_MEASURE_INTERVAL, intrvl);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(yas5xx->map, YAS537_AVR, YAS537_MAG_AVERAGE_32_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(yas5xx->map, YAS537_CONFIG, BIT(3));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(YAS537_MAG_RCOIL_TIME_US, YAS537_MAG_RCOIL_TIME_US + 100);\n\n\treturn 0;\n}\n\nstatic const struct yas5xx_chip_info yas5xx_chip_info_tbl[] = {\n\t[yas530] = {\n\t\t.devid = YAS530_DEVICE_ID,\n\t\t.product_name = \"YAS530 MS-3E\",\n\t\t.version_names = { \"A\", \"B\" },\n\t\t.volatile_reg = yas530_volatile_reg,\n\t\t.volatile_reg_qty = ARRAY_SIZE(yas530_volatile_reg),\n\t\t.scaling_val2 = 100000000,  \n\t\t.t_ref = 182,  \n\t\t.min_temp_x10 = -620,  \n\t\t.get_measure = yas530_get_measure,\n\t\t.get_calibration_data = yas530_get_calibration_data,\n\t\t.dump_calibration = yas530_dump_calibration,\n\t\t.measure_offsets = yas530_measure_offsets,\n\t\t.power_on = yas530_power_on,\n\t},\n\t[yas532] = {\n\t\t.devid = YAS532_DEVICE_ID,\n\t\t.product_name = \"YAS532 MS-3R\",\n\t\t.version_names = { \"AB\", \"AC\" },\n\t\t.volatile_reg = yas530_volatile_reg,\n\t\t.volatile_reg_qty = ARRAY_SIZE(yas530_volatile_reg),\n\t\t.scaling_val2 = 100000,  \n\t\t.t_ref = 390,  \n\t\t.min_temp_x10 = -500,  \n\t\t.get_measure = yas530_get_measure,\n\t\t.get_calibration_data = yas532_get_calibration_data,\n\t\t.dump_calibration = yas530_dump_calibration,\n\t\t.measure_offsets = yas530_measure_offsets,\n\t\t.power_on = yas530_power_on,\n\t},\n\t[yas533] = {\n\t\t.devid = YAS532_DEVICE_ID,\n\t\t.product_name = \"YAS533 MS-3F\",\n\t\t.version_names = { \"AB\", \"AC\" },\n\t\t.volatile_reg = yas530_volatile_reg,\n\t\t.volatile_reg_qty = ARRAY_SIZE(yas530_volatile_reg),\n\t\t.scaling_val2 = 100000,  \n\t\t.t_ref = 390,  \n\t\t.min_temp_x10 = -500,  \n\t\t.get_measure = yas530_get_measure,\n\t\t.get_calibration_data = yas532_get_calibration_data,\n\t\t.dump_calibration = yas530_dump_calibration,\n\t\t.measure_offsets = yas530_measure_offsets,\n\t\t.power_on = yas530_power_on,\n\t},\n\t[yas537] = {\n\t\t.devid = YAS537_DEVICE_ID,\n\t\t.product_name = \"YAS537 MS-3T\",\n\t\t.version_names = { \"v0\", \"v1\" },  \n\t\t.volatile_reg = yas537_volatile_reg,\n\t\t.volatile_reg_qty = ARRAY_SIZE(yas537_volatile_reg),\n\t\t.scaling_val2 = 100000,  \n\t\t.t_ref = 8120,  \n\t\t.min_temp_x10 = -3860,  \n\t\t.get_measure = yas537_get_measure,\n\t\t.get_calibration_data = yas537_get_calibration_data,\n\t\t.dump_calibration = yas537_dump_calibration,\n\t\t \n\t\t.power_on = yas537_power_on,\n\t},\n};\n\nstatic int yas5xx_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tstruct iio_dev *indio_dev;\n\tstruct device *dev = &i2c->dev;\n\tstruct yas5xx *yas5xx;\n\tconst struct yas5xx_chip_info *ci;\n\tint id_check;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*yas5xx));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tyas5xx = iio_priv(indio_dev);\n\ti2c_set_clientdata(i2c, indio_dev);\n\tyas5xx->dev = dev;\n\tmutex_init(&yas5xx->lock);\n\n\tret = iio_read_mount_matrix(dev, &yas5xx->orientation);\n\tif (ret)\n\t\treturn ret;\n\n\tyas5xx->regs[0].supply = \"vdd\";\n\tyas5xx->regs[1].supply = \"iovdd\";\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(yas5xx->regs),\n\t\t\t\t      yas5xx->regs);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"cannot get regulators\\n\");\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(yas5xx->regs), yas5xx->regs);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"cannot enable regulators\\n\");\n\n\t \n\tusleep_range(31000, 40000);\n\n\t \n\tyas5xx->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(yas5xx->reset)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(yas5xx->reset), \"failed to get reset line\\n\");\n\t\tgoto reg_off;\n\t}\n\n\tyas5xx->map = devm_regmap_init_i2c(i2c, &yas5xx_regmap_config);\n\tif (IS_ERR(yas5xx->map)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(yas5xx->map), \"failed to allocate register map\\n\");\n\t\tgoto assert_reset;\n\t}\n\n\tci = device_get_match_data(dev);\n\tif (!ci)\n\t\tci = (const struct yas5xx_chip_info *)id->driver_data;\n\tyas5xx->chip_info = ci;\n\n\tret = regmap_read(yas5xx->map, YAS5XX_DEVICE_ID, &id_check);\n\tif (ret)\n\t\tgoto assert_reset;\n\n\tif (id_check != ci->devid) {\n\t\tret = dev_err_probe(dev, -ENODEV,\n\t\t\t\t    \"device ID %02x doesn't match %s\\n\",\n\t\t\t\t    id_check, id->name);\n\t\tgoto assert_reset;\n\t}\n\n\tret = ci->get_calibration_data(yas5xx);\n\tif (ret)\n\t\tgoto assert_reset;\n\n\tdev_info(dev, \"detected %s %s\\n\", ci->product_name,\n\t\t ci->version_names[yas5xx->version]);\n\n\tci->dump_calibration(yas5xx);\n\n\tret = ci->power_on(yas5xx);\n\tif (ret)\n\t\tgoto assert_reset;\n\n\tif (ci->measure_offsets) {\n\t\tret = ci->measure_offsets(yas5xx);\n\t\tif (ret)\n\t\t\tgoto assert_reset;\n\t}\n\n\tindio_dev->info = &yas5xx_info;\n\tindio_dev->available_scan_masks = yas5xx_scan_masks;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->name = id->name;\n\tindio_dev->channels = yas5xx_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(yas5xx_channels);\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL,\n\t\t\t\t\t yas5xx_handle_trigger,\n\t\t\t\t\t NULL);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"triggered buffer setup failed\\n\");\n\t\tgoto assert_reset;\n\t}\n\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"device register failed\\n\");\n\t\tgoto cleanup_buffer;\n\t}\n\n\t \n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\tpm_runtime_set_autosuspend_delay(dev, YAS5XX_AUTOSUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_put(dev);\n\n\treturn 0;\n\ncleanup_buffer:\n\tiio_triggered_buffer_cleanup(indio_dev);\nassert_reset:\n\tgpiod_set_value_cansleep(yas5xx->reset, 1);\nreg_off:\n\tregulator_bulk_disable(ARRAY_SIZE(yas5xx->regs), yas5xx->regs);\n\n\treturn ret;\n}\n\nstatic void yas5xx_remove(struct i2c_client *i2c)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(i2c);\n\tstruct yas5xx *yas5xx = iio_priv(indio_dev);\n\tstruct device *dev = &i2c->dev;\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\t \n\tpm_runtime_get_sync(dev);\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_disable(dev);\n\tgpiod_set_value_cansleep(yas5xx->reset, 1);\n\tregulator_bulk_disable(ARRAY_SIZE(yas5xx->regs), yas5xx->regs);\n}\n\nstatic int yas5xx_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct yas5xx *yas5xx = iio_priv(indio_dev);\n\n\tgpiod_set_value_cansleep(yas5xx->reset, 1);\n\tregulator_bulk_disable(ARRAY_SIZE(yas5xx->regs), yas5xx->regs);\n\n\treturn 0;\n}\n\nstatic int yas5xx_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct yas5xx *yas5xx = iio_priv(indio_dev);\n\tconst struct yas5xx_chip_info *ci = yas5xx->chip_info;\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(yas5xx->regs), yas5xx->regs);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot enable regulators\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tusleep_range(31000, 40000);\n\tgpiod_set_value_cansleep(yas5xx->reset, 0);\n\n\tret = ci->power_on(yas5xx);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot power on\\n\");\n\t\tgoto out_reset;\n\t}\n\n\treturn 0;\n\nout_reset:\n\tgpiod_set_value_cansleep(yas5xx->reset, 1);\n\tregulator_bulk_disable(ARRAY_SIZE(yas5xx->regs), yas5xx->regs);\n\n\treturn ret;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(yas5xx_dev_pm_ops, yas5xx_runtime_suspend,\n\t\t\t\t yas5xx_runtime_resume, NULL);\n\nstatic const struct i2c_device_id yas5xx_id[] = {\n\t{\"yas530\", (kernel_ulong_t)&yas5xx_chip_info_tbl[yas530] },\n\t{\"yas532\", (kernel_ulong_t)&yas5xx_chip_info_tbl[yas532] },\n\t{\"yas533\", (kernel_ulong_t)&yas5xx_chip_info_tbl[yas533] },\n\t{\"yas537\", (kernel_ulong_t)&yas5xx_chip_info_tbl[yas537] },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, yas5xx_id);\n\nstatic const struct of_device_id yas5xx_of_match[] = {\n\t{ .compatible = \"yamaha,yas530\", &yas5xx_chip_info_tbl[yas530] },\n\t{ .compatible = \"yamaha,yas532\", &yas5xx_chip_info_tbl[yas532] },\n\t{ .compatible = \"yamaha,yas533\", &yas5xx_chip_info_tbl[yas533] },\n\t{ .compatible = \"yamaha,yas537\", &yas5xx_chip_info_tbl[yas537] },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, yas5xx_of_match);\n\nstatic struct i2c_driver yas5xx_driver = {\n\t.driver\t = {\n\t\t.name\t= \"yas5xx\",\n\t\t.of_match_table = yas5xx_of_match,\n\t\t.pm = pm_ptr(&yas5xx_dev_pm_ops),\n\t},\n\t.probe = yas5xx_probe,\n\t.remove\t  = yas5xx_remove,\n\t.id_table = yas5xx_id,\n};\nmodule_i2c_driver(yas5xx_driver);\n\nMODULE_DESCRIPTION(\"Yamaha YAS53x 3-axis magnetometer driver\");\nMODULE_AUTHOR(\"Linus Walleij\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}