{
  "module_name": "hmc5843_core.c",
  "hash_id": "f8e68e88de0784d9a31847a807d4cb40b50118614773ddbdc7d0439287114657",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/magnetometer/hmc5843_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/delay.h>\n\n#include \"hmc5843.h\"\n\n \n#define HMC5843_RANGE_GAIN_OFFSET\t\t0x05\n#define HMC5843_RANGE_GAIN_DEFAULT\t\t0x01\n#define HMC5843_RANGE_GAIN_MASK\t\t0xe0\n\n \n#define HMC5843_DATA_READY\t\t\t0x01\n#define HMC5843_DATA_OUTPUT_LOCK\t\t0x02\n\n \n#define HMC5843_MODE_CONVERSION_CONTINUOUS\t0x00\n#define HMC5843_MODE_CONVERSION_SINGLE\t\t0x01\n#define HMC5843_MODE_IDLE\t\t\t0x02\n#define HMC5843_MODE_SLEEP\t\t\t0x03\n#define HMC5843_MODE_MASK\t\t\t0x03\n\n \n#define HMC5843_RATE_OFFSET\t\t\t0x02\n#define HMC5843_RATE_DEFAULT\t\t\t0x04\n#define HMC5843_RATE_MASK\t\t0x1c\n\n \n#define HMC5843_MEAS_CONF_NORMAL\t\t0x00\n#define HMC5843_MEAS_CONF_POSITIVE_BIAS\t\t0x01\n#define HMC5843_MEAS_CONF_NEGATIVE_BIAS\t\t0x02\n#define HMC5843_MEAS_CONF_MASK\t\t\t0x03\n\n \n\nstatic const char *const hmc5843_meas_conf_modes[] = {\"normal\", \"positivebias\",\n\t\t\t\t\t\t      \"negativebias\"};\n\nstatic const char *const hmc5983_meas_conf_modes[] = {\"normal\", \"positivebias\",\n\t\t\t\t\t\t      \"negativebias\",\n\t\t\t\t\t\t      \"disabled\"};\n \nstatic const int hmc5843_regval_to_nanoscale[] = {\n\t6173, 7692, 10309, 12821, 18868, 21739, 25641, 35714\n};\n\nstatic const int hmc5883_regval_to_nanoscale[] = {\n\t7812, 9766, 13021, 16287, 24096, 27701, 32573, 45662\n};\n\nstatic const int hmc5883l_regval_to_nanoscale[] = {\n\t7299, 9174, 12195, 15152, 22727, 25641, 30303, 43478\n};\n\n \nstatic const int hmc5843_regval_to_samp_freq[][2] = {\n\t{0, 500000}, {1, 0}, {2, 0}, {5, 0}, {10, 0}, {20, 0}, {50, 0}\n};\n\nstatic const int hmc5883_regval_to_samp_freq[][2] = {\n\t{0, 750000}, {1, 500000}, {3, 0}, {7, 500000}, {15, 0}, {30, 0},\n\t{75, 0}\n};\n\nstatic const int hmc5983_regval_to_samp_freq[][2] = {\n\t{0, 750000}, {1, 500000}, {3, 0}, {7, 500000}, {15, 0}, {30, 0},\n\t{75, 0}, {220, 0}\n};\n\n \nstruct hmc5843_chip_info {\n\tconst struct iio_chan_spec *channels;\n\tconst int (*regval_to_samp_freq)[2];\n\tconst int n_regval_to_samp_freq;\n\tconst int *regval_to_nanoscale;\n\tconst int n_regval_to_nanoscale;\n};\n\n \nstatic s32 hmc5843_set_mode(struct hmc5843_data *data, u8 operating_mode)\n{\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = regmap_update_bits(data->regmap, HMC5843_MODE_REG,\n\t\t\t\t HMC5843_MODE_MASK, operating_mode);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int hmc5843_wait_measurement(struct hmc5843_data *data)\n{\n\tint tries = 150;\n\tunsigned int val;\n\tint ret;\n\n\twhile (tries-- > 0) {\n\t\tret = regmap_read(data->regmap, HMC5843_STATUS_REG, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (val & HMC5843_DATA_READY)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\n\tif (tries < 0) {\n\t\tdev_err(data->dev, \"data not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hmc5843_read_measurement(struct hmc5843_data *data,\n\t\t\t\t    int idx, int *val)\n{\n\t__be16 values[3];\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = hmc5843_wait_measurement(data);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\tret = regmap_bulk_read(data->regmap, HMC5843_DATA_OUT_MSB_REGS,\n\t\t\t       values, sizeof(values));\n\tmutex_unlock(&data->lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = sign_extend32(be16_to_cpu(values[idx]), 15);\n\treturn IIO_VAL_INT;\n}\n\nstatic int hmc5843_set_meas_conf(struct hmc5843_data *data, u8 meas_conf)\n{\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = regmap_update_bits(data->regmap, HMC5843_CONFIG_REG_A,\n\t\t\t\t HMC5843_MEAS_CONF_MASK, meas_conf);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic\nint hmc5843_show_measurement_configuration(struct iio_dev *indio_dev,\n\t\t\t\t\t   const struct iio_chan_spec *chan)\n{\n\tstruct hmc5843_data *data = iio_priv(indio_dev);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(data->regmap, HMC5843_CONFIG_REG_A, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val & HMC5843_MEAS_CONF_MASK;\n}\n\nstatic\nint hmc5843_set_measurement_configuration(struct iio_dev *indio_dev,\n\t\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t\t  unsigned int meas_conf)\n{\n\tstruct hmc5843_data *data = iio_priv(indio_dev);\n\n\treturn hmc5843_set_meas_conf(data, meas_conf);\n}\n\nstatic const struct iio_mount_matrix *\nhmc5843_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\t  const struct iio_chan_spec *chan)\n{\n\tstruct hmc5843_data *data = iio_priv(indio_dev);\n\n\treturn &data->orientation;\n}\n\nstatic const struct iio_enum hmc5843_meas_conf_enum = {\n\t.items = hmc5843_meas_conf_modes,\n\t.num_items = ARRAY_SIZE(hmc5843_meas_conf_modes),\n\t.get = hmc5843_show_measurement_configuration,\n\t.set = hmc5843_set_measurement_configuration,\n};\n\nstatic const struct iio_chan_spec_ext_info hmc5843_ext_info[] = {\n\tIIO_ENUM(\"meas_conf\", IIO_SHARED_BY_TYPE, &hmc5843_meas_conf_enum),\n\tIIO_ENUM_AVAILABLE(\"meas_conf\", IIO_SHARED_BY_TYPE, &hmc5843_meas_conf_enum),\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_DIR, hmc5843_get_mount_matrix),\n\t{ }\n};\n\nstatic const struct iio_enum hmc5983_meas_conf_enum = {\n\t.items = hmc5983_meas_conf_modes,\n\t.num_items = ARRAY_SIZE(hmc5983_meas_conf_modes),\n\t.get = hmc5843_show_measurement_configuration,\n\t.set = hmc5843_set_measurement_configuration,\n};\n\nstatic const struct iio_chan_spec_ext_info hmc5983_ext_info[] = {\n\tIIO_ENUM(\"meas_conf\", IIO_SHARED_BY_TYPE, &hmc5983_meas_conf_enum),\n\tIIO_ENUM_AVAILABLE(\"meas_conf\", IIO_SHARED_BY_TYPE, &hmc5983_meas_conf_enum),\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_DIR, hmc5843_get_mount_matrix),\n\t{ }\n};\n\nstatic\nssize_t hmc5843_show_samp_freq_avail(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct hmc5843_data *data = iio_priv(dev_to_iio_dev(dev));\n\tsize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < data->variant->n_regval_to_samp_freq; i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"%d.%d \", data->variant->regval_to_samp_freq[i][0],\n\t\t\tdata->variant->regval_to_samp_freq[i][1]);\n\n\t \n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic IIO_DEV_ATTR_SAMP_FREQ_AVAIL(hmc5843_show_samp_freq_avail);\n\nstatic int hmc5843_set_samp_freq(struct hmc5843_data *data, u8 rate)\n{\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = regmap_update_bits(data->regmap, HMC5843_CONFIG_REG_A,\n\t\t\t\t HMC5843_RATE_MASK,\n\t\t\t\t rate << HMC5843_RATE_OFFSET);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int hmc5843_get_samp_freq_index(struct hmc5843_data *data,\n\t\t\t\t       int val, int val2)\n{\n\tint i;\n\n\tfor (i = 0; i < data->variant->n_regval_to_samp_freq; i++)\n\t\tif (val == data->variant->regval_to_samp_freq[i][0] &&\n\t\t    val2 == data->variant->regval_to_samp_freq[i][1])\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int hmc5843_set_range_gain(struct hmc5843_data *data, u8 range)\n{\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = regmap_update_bits(data->regmap, HMC5843_CONFIG_REG_B,\n\t\t\t\t HMC5843_RANGE_GAIN_MASK,\n\t\t\t\t range << HMC5843_RANGE_GAIN_OFFSET);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic ssize_t hmc5843_show_scale_avail(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct hmc5843_data *data = iio_priv(dev_to_iio_dev(dev));\n\n\tsize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < data->variant->n_regval_to_nanoscale; i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"0.%09d \", data->variant->regval_to_nanoscale[i]);\n\n\t \n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic IIO_DEVICE_ATTR(scale_available, S_IRUGO,\n\thmc5843_show_scale_avail, NULL, 0);\n\nstatic int hmc5843_get_scale_index(struct hmc5843_data *data, int val, int val2)\n{\n\tint i;\n\n\tif (val)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < data->variant->n_regval_to_nanoscale; i++)\n\t\tif (val2 == data->variant->regval_to_nanoscale[i])\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int hmc5843_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct hmc5843_data *data = iio_priv(indio_dev);\n\tunsigned int rval;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn hmc5843_read_measurement(data, chan->scan_index, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tret = regmap_read(data->regmap, HMC5843_CONFIG_REG_B, &rval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\trval >>= HMC5843_RANGE_GAIN_OFFSET;\n\t\t*val = 0;\n\t\t*val2 = data->variant->regval_to_nanoscale[rval];\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = regmap_read(data->regmap, HMC5843_CONFIG_REG_A, &rval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\trval >>= HMC5843_RATE_OFFSET;\n\t\t*val = data->variant->regval_to_samp_freq[rval][0];\n\t\t*val2 = data->variant->regval_to_samp_freq[rval][1];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int hmc5843_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct hmc5843_data *data = iio_priv(indio_dev);\n\tint rate, range;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\trate = hmc5843_get_samp_freq_index(data, val, val2);\n\t\tif (rate < 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn hmc5843_set_samp_freq(data, rate);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\trange = hmc5843_get_scale_index(data, val, val2);\n\t\tif (range < 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn hmc5843_set_range_gain(data, range);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int hmc5843_write_raw_get_fmt(struct iio_dev *indio_dev,\n\t\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t\t     long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn IIO_VAL_INT_PLUS_NANO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic irqreturn_t hmc5843_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct hmc5843_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = hmc5843_wait_measurement(data);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->lock);\n\t\tgoto done;\n\t}\n\n\tret = regmap_bulk_read(data->regmap, HMC5843_DATA_OUT_MSB_REGS,\n\t\t\t       data->scan.chans, sizeof(data->scan.chans));\n\n\tmutex_unlock(&data->lock);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\n#define HMC5843_CHANNEL(axis, idx)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_MAGN,\t\t\t\t\t\\\n\t\t.modified = 1,\t\t\t\t\t\t\\\n\t\t.channel2 = IIO_MOD_##axis,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t\\\n\t\t.scan_index = idx,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\t\\\n\t\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.ext_info = hmc5843_ext_info,\t\\\n\t}\n\n#define HMC5983_CHANNEL(axis, idx)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_MAGN,\t\t\t\t\t\\\n\t\t.modified = 1,\t\t\t\t\t\t\\\n\t\t.channel2 = IIO_MOD_##axis,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t\\\n\t\t.scan_index = idx,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\t\\\n\t\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.ext_info = hmc5983_ext_info,\t\\\n\t}\n\nstatic const struct iio_chan_spec hmc5843_channels[] = {\n\tHMC5843_CHANNEL(X, 0),\n\tHMC5843_CHANNEL(Y, 1),\n\tHMC5843_CHANNEL(Z, 2),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\n \nstatic const struct iio_chan_spec hmc5883_channels[] = {\n\tHMC5843_CHANNEL(X, 0),\n\tHMC5843_CHANNEL(Z, 1),\n\tHMC5843_CHANNEL(Y, 2),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic const struct iio_chan_spec hmc5983_channels[] = {\n\tHMC5983_CHANNEL(X, 0),\n\tHMC5983_CHANNEL(Z, 1),\n\tHMC5983_CHANNEL(Y, 2),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic struct attribute *hmc5843_attributes[] = {\n\t&iio_dev_attr_scale_available.dev_attr.attr,\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hmc5843_group = {\n\t.attrs = hmc5843_attributes,\n};\n\nstatic const struct hmc5843_chip_info hmc5843_chip_info_tbl[] = {\n\t[HMC5843_ID] = {\n\t\t.channels = hmc5843_channels,\n\t\t.regval_to_samp_freq = hmc5843_regval_to_samp_freq,\n\t\t.n_regval_to_samp_freq =\n\t\t\t\tARRAY_SIZE(hmc5843_regval_to_samp_freq),\n\t\t.regval_to_nanoscale = hmc5843_regval_to_nanoscale,\n\t\t.n_regval_to_nanoscale =\n\t\t\t\tARRAY_SIZE(hmc5843_regval_to_nanoscale),\n\t},\n\t[HMC5883_ID] = {\n\t\t.channels = hmc5883_channels,\n\t\t.regval_to_samp_freq = hmc5883_regval_to_samp_freq,\n\t\t.n_regval_to_samp_freq =\n\t\t\t\tARRAY_SIZE(hmc5883_regval_to_samp_freq),\n\t\t.regval_to_nanoscale = hmc5883_regval_to_nanoscale,\n\t\t.n_regval_to_nanoscale =\n\t\t\t\tARRAY_SIZE(hmc5883_regval_to_nanoscale),\n\t},\n\t[HMC5883L_ID] = {\n\t\t.channels = hmc5883_channels,\n\t\t.regval_to_samp_freq = hmc5883_regval_to_samp_freq,\n\t\t.n_regval_to_samp_freq =\n\t\t\t\tARRAY_SIZE(hmc5883_regval_to_samp_freq),\n\t\t.regval_to_nanoscale = hmc5883l_regval_to_nanoscale,\n\t\t.n_regval_to_nanoscale =\n\t\t\t\tARRAY_SIZE(hmc5883l_regval_to_nanoscale),\n\t},\n\t[HMC5983_ID] = {\n\t\t.channels = hmc5983_channels,\n\t\t.regval_to_samp_freq = hmc5983_regval_to_samp_freq,\n\t\t.n_regval_to_samp_freq =\n\t\t\t\tARRAY_SIZE(hmc5983_regval_to_samp_freq),\n\t\t.regval_to_nanoscale = hmc5883l_regval_to_nanoscale,\n\t\t.n_regval_to_nanoscale =\n\t\t\t\tARRAY_SIZE(hmc5883l_regval_to_nanoscale),\n\t}\n};\n\nstatic int hmc5843_init(struct hmc5843_data *data)\n{\n\tint ret;\n\tu8 id[3];\n\n\tret = regmap_bulk_read(data->regmap, HMC5843_ID_REG,\n\t\t\t       id, ARRAY_SIZE(id));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (id[0] != 'H' || id[1] != '4' || id[2] != '3') {\n\t\tdev_err(data->dev, \"no HMC5843/5883/5883L/5983 sensor\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = hmc5843_set_meas_conf(data, HMC5843_MEAS_CONF_NORMAL);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = hmc5843_set_samp_freq(data, HMC5843_RATE_DEFAULT);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = hmc5843_set_range_gain(data, HMC5843_RANGE_GAIN_DEFAULT);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn hmc5843_set_mode(data, HMC5843_MODE_CONVERSION_CONTINUOUS);\n}\n\nstatic const struct iio_info hmc5843_info = {\n\t.attrs = &hmc5843_group,\n\t.read_raw = &hmc5843_read_raw,\n\t.write_raw = &hmc5843_write_raw,\n\t.write_raw_get_fmt = &hmc5843_write_raw_get_fmt,\n};\n\nstatic const unsigned long hmc5843_scan_masks[] = {0x7, 0};\n\nstatic int hmc5843_common_suspend(struct device *dev)\n{\n\treturn hmc5843_set_mode(iio_priv(dev_get_drvdata(dev)),\n\t\t\t\tHMC5843_MODE_SLEEP);\n}\n\nstatic int hmc5843_common_resume(struct device *dev)\n{\n\treturn hmc5843_set_mode(iio_priv(dev_get_drvdata(dev)),\n\t\tHMC5843_MODE_CONVERSION_CONTINUOUS);\n}\nEXPORT_NS_SIMPLE_DEV_PM_OPS(hmc5843_pm_ops, hmc5843_common_suspend,\n\t\t\t    hmc5843_common_resume, IIO_HMC5843);\n\nint hmc5843_common_probe(struct device *dev, struct regmap *regmap,\n\t\t\t enum hmc5843_ids id, const char *name)\n{\n\tstruct hmc5843_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, indio_dev);\n\n\t \n\tdata = iio_priv(indio_dev);\n\tdata->dev = dev;\n\tdata->regmap = regmap;\n\tdata->variant = &hmc5843_chip_info_tbl[id];\n\tmutex_init(&data->lock);\n\n\tret = iio_read_mount_matrix(dev, &data->orientation);\n\tif (ret)\n\t\treturn ret;\n\n\tindio_dev->name = name;\n\tindio_dev->info = &hmc5843_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = data->variant->channels;\n\tindio_dev->num_channels = 4;\n\tindio_dev->available_scan_masks = hmc5843_scan_masks;\n\n\tret = hmc5843_init(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL,\n\t\t\t\t\t hmc5843_trigger_handler, NULL);\n\tif (ret < 0)\n\t\tgoto buffer_setup_err;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto buffer_cleanup;\n\n\treturn 0;\n\nbuffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\nbuffer_setup_err:\n\thmc5843_set_mode(iio_priv(indio_dev), HMC5843_MODE_SLEEP);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS(hmc5843_common_probe, IIO_HMC5843);\n\nvoid hmc5843_common_remove(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\n\t \n\thmc5843_set_mode(iio_priv(indio_dev), HMC5843_MODE_SLEEP);\n}\nEXPORT_SYMBOL_NS(hmc5843_common_remove, IIO_HMC5843);\n\nMODULE_AUTHOR(\"Shubhrajyoti Datta <shubhrajyoti@ti.com>\");\nMODULE_DESCRIPTION(\"HMC5843/5883/5883L/5983 core driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}