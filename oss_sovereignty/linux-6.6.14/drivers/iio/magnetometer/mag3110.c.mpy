{
  "module_name": "mag3110.c",
  "hash_id": "3bea6905894af15ff1dd2ce739da54a81abfee74f26f58315fee5ca46315eae2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/magnetometer/mag3110.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/delay.h>\n#include <linux/regulator/consumer.h>\n\n#define MAG3110_STATUS 0x00\n#define MAG3110_OUT_X 0x01  \n#define MAG3110_OUT_Y 0x03\n#define MAG3110_OUT_Z 0x05\n#define MAG3110_WHO_AM_I 0x07\n#define MAG3110_SYSMOD 0x08\n#define MAG3110_OFF_X 0x09  \n#define MAG3110_OFF_Y 0x0b\n#define MAG3110_OFF_Z 0x0d\n#define MAG3110_DIE_TEMP 0x0f\n#define MAG3110_CTRL_REG1 0x10\n#define MAG3110_CTRL_REG2 0x11\n\n#define MAG3110_STATUS_DRDY (BIT(2) | BIT(1) | BIT(0))\n\n#define MAG3110_CTRL_DR_MASK (BIT(7) | BIT(6) | BIT(5))\n#define MAG3110_CTRL_DR_SHIFT 5\n#define MAG3110_CTRL_DR_DEFAULT 0\n\n#define MAG3110_SYSMOD_MODE_MASK GENMASK(1, 0)\n\n#define MAG3110_CTRL_TM BIT(1)  \n#define MAG3110_CTRL_AC BIT(0)  \n\n#define MAG3110_CTRL_AUTO_MRST_EN BIT(7)  \n#define MAG3110_CTRL_RAW BIT(5)  \n\n#define MAG3110_DEVICE_ID 0xc4\n\n \nstruct mag3110_data {\n\tstruct i2c_client *client;\n\tstruct mutex lock;\n\tu8 ctrl_reg1;\n\tint sleep_val;\n\tstruct regulator *vdd_reg;\n\tstruct regulator *vddio_reg;\n\t \n\tstruct {\n\t\t__be16 channels[3];\n\t\tu8 temperature;\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\nstatic int mag3110_request(struct mag3110_data *data)\n{\n\tint ret, tries = 150;\n\n\tif ((data->ctrl_reg1 & MAG3110_CTRL_AC) == 0) {\n\t\t \n\t\tret = i2c_smbus_write_byte_data(data->client, MAG3110_CTRL_REG1,\n\t\t\tdata->ctrl_reg1 | MAG3110_CTRL_TM);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\twhile (tries-- > 0) {\n\t\tret = i2c_smbus_read_byte_data(data->client, MAG3110_STATUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tif ((ret & MAG3110_STATUS_DRDY) == MAG3110_STATUS_DRDY)\n\t\t\tbreak;\n\n\t\tif (data->sleep_val <= 20)\n\t\t\tusleep_range(data->sleep_val * 250, data->sleep_val * 500);\n\t\telse\n\t\t\tmsleep(20);\n\t}\n\n\tif (tries < 0) {\n\t\tdev_err(&data->client->dev, \"data not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int mag3110_read(struct mag3110_data *data, __be16 buf[3])\n{\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = mag3110_request(data);\n\tif (ret < 0) {\n\t\tmutex_unlock(&data->lock);\n\t\treturn ret;\n\t}\n\tret = i2c_smbus_read_i2c_block_data(data->client,\n\t\tMAG3110_OUT_X, 3 * sizeof(__be16), (u8 *) buf);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic ssize_t mag3110_show_int_plus_micros(char *buf,\n\tconst int (*vals)[2], int n)\n{\n\tsize_t len = 0;\n\n\twhile (n-- > 0)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"%d.%06d \", vals[n][0], vals[n][1]);\n\n\t \n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic int mag3110_get_int_plus_micros_index(const int (*vals)[2], int n,\n\t\t\t\t\tint val, int val2)\n{\n\twhile (n-- > 0)\n\t\tif (val == vals[n][0] && val2 == vals[n][1])\n\t\t\treturn n;\n\n\treturn -EINVAL;\n}\n\nstatic const int mag3110_samp_freq[8][2] = {\n\t{80, 0}, {40, 0}, {20, 0}, {10, 0}, {5, 0}, {2, 500000},\n\t{1, 250000}, {0, 625000}\n};\n\nstatic ssize_t mag3110_show_samp_freq_avail(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn mag3110_show_int_plus_micros(buf, mag3110_samp_freq, 8);\n}\n\nstatic IIO_DEV_ATTR_SAMP_FREQ_AVAIL(mag3110_show_samp_freq_avail);\n\nstatic int mag3110_get_samp_freq_index(struct mag3110_data *data,\n\tint val, int val2)\n{\n\treturn mag3110_get_int_plus_micros_index(mag3110_samp_freq, 8, val,\n\t\tval2);\n}\n\nstatic int mag3110_calculate_sleep(struct mag3110_data *data)\n{\n\tint ret, i = data->ctrl_reg1 >> MAG3110_CTRL_DR_SHIFT;\n\n\tif (mag3110_samp_freq[i][0] > 0)\n\t\tret = 1000 / mag3110_samp_freq[i][0];\n\telse\n\t\tret = 1000;\n\n\treturn ret == 0 ? 1 : ret;\n}\n\nstatic int mag3110_standby(struct mag3110_data *data)\n{\n\treturn i2c_smbus_write_byte_data(data->client, MAG3110_CTRL_REG1,\n\t\tdata->ctrl_reg1 & ~MAG3110_CTRL_AC);\n}\n\nstatic int mag3110_wait_standby(struct mag3110_data *data)\n{\n\tint ret, tries = 30;\n\n\t \n\twhile (tries-- > 0) {\n\t\tret = i2c_smbus_read_byte_data(data->client, MAG3110_SYSMOD);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&data->client->dev, \"i2c error\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tif ((ret & MAG3110_SYSMOD_MODE_MASK) == 0)\n\t\t\tbreak;\n\n\t\tmsleep_interruptible(500);\n\t}\n\n\tif (tries < 0) {\n\t\tdev_err(&data->client->dev, \"device not entering standby mode\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int mag3110_active(struct mag3110_data *data)\n{\n\treturn i2c_smbus_write_byte_data(data->client, MAG3110_CTRL_REG1,\n\t\t\t\t\t data->ctrl_reg1);\n}\n\n \nstatic int mag3110_is_active(struct mag3110_data *data)\n{\n\tint reg;\n\n\treg = i2c_smbus_read_byte_data(data->client, MAG3110_CTRL_REG1);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treturn reg & MAG3110_CTRL_AC;\n}\n\nstatic int mag3110_change_config(struct mag3110_data *data, u8 reg, u8 val)\n{\n\tint ret;\n\tint is_active;\n\n\tmutex_lock(&data->lock);\n\n\tis_active = mag3110_is_active(data);\n\tif (is_active < 0) {\n\t\tret = is_active;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (is_active > 0) {\n\t\tret = mag3110_standby(data);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tret = mag3110_wait_standby(data);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = i2c_smbus_write_byte_data(data->client, reg, val);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (is_active > 0) {\n\t\tret = mag3110_active(data);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\n\tret = 0;\nfail:\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int mag3110_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct mag3110_data *data = iio_priv(indio_dev);\n\t__be16 buffer[3];\n\tint i, ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswitch (chan->type) {\n\t\tcase IIO_MAGN:  \n\t\t\tret = mag3110_read(data, buffer);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto release;\n\t\t\t*val = sign_extend32(\n\t\t\t\tbe16_to_cpu(buffer[chan->scan_index]),\n\t\t\t\t\t    chan->scan_type.realbits - 1);\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tcase IIO_TEMP:  \n\t\t\tmutex_lock(&data->lock);\n\t\t\tret = mag3110_request(data);\n\t\t\tif (ret < 0) {\n\t\t\t\tmutex_unlock(&data->lock);\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tret = i2c_smbus_read_byte_data(data->client,\n\t\t\t\tMAG3110_DIE_TEMP);\n\t\t\tmutex_unlock(&data->lock);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto release;\n\t\t\t*val = sign_extend32(ret,\n\t\t\t\t\t     chan->scan_type.realbits - 1);\n\t\t\tret = IIO_VAL_INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\nrelease:\n\t\tiio_device_release_direct_mode(indio_dev);\n\t\treturn ret;\n\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_MAGN:\n\t\t\t*val = 0;\n\t\t\t*val2 = 1000;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_TEMP:\n\t\t\t*val = 1000;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\ti = data->ctrl_reg1 >> MAG3110_CTRL_DR_SHIFT;\n\t\t*val = mag3110_samp_freq[i][0];\n\t\t*val2 = mag3110_samp_freq[i][1];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tret = i2c_smbus_read_word_swapped(data->client,\n\t\t\tMAG3110_OFF_X +\t2 * chan->scan_index);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = sign_extend32(ret >> 1, 14);\n\t\treturn IIO_VAL_INT;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int mag3110_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct mag3110_data *data = iio_priv(indio_dev);\n\tint rate, ret;\n\n\tret = iio_device_claim_direct_mode(indio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\trate = mag3110_get_samp_freq_index(data, val, val2);\n\t\tif (rate < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdata->ctrl_reg1 &= 0xff & ~MAG3110_CTRL_DR_MASK\n\t\t\t\t\t& ~MAG3110_CTRL_AC;\n\t\tdata->ctrl_reg1 |= rate << MAG3110_CTRL_DR_SHIFT;\n\t\tdata->sleep_val = mag3110_calculate_sleep(data);\n\t\tif (data->sleep_val < 40)\n\t\t\tdata->ctrl_reg1 |= MAG3110_CTRL_AC;\n\n\t\tret = mag3110_change_config(data, MAG3110_CTRL_REG1,\n\t\t\t\t\t    data->ctrl_reg1);\n\t\tbreak;\n\tcase IIO_CHAN_INFO_CALIBBIAS:\n\t\tif (val < -10000 || val > 10000) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = i2c_smbus_write_word_swapped(data->client,\n\t\t\tMAG3110_OFF_X + 2 * chan->scan_index, val << 1);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tiio_device_release_direct_mode(indio_dev);\n\treturn ret;\n}\n\nstatic irqreturn_t mag3110_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct mag3110_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = mag3110_read(data, data->scan.channels);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tif (test_bit(3, indio_dev->active_scan_mask)) {\n\t\tret = i2c_smbus_read_byte_data(data->client,\n\t\t\tMAG3110_DIE_TEMP);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tdata->scan.temperature = ret;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\tiio_get_time_ns(indio_dev));\n\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\n#define MAG3110_CHANNEL(axis, idx) { \\\n\t.type = IIO_MAGN, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_##axis, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \\\n\t\tBIT(IIO_CHAN_INFO_CALIBBIAS), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\tBIT(IIO_CHAN_INFO_SCALE), \\\n\t.scan_index = idx, \\\n\t.scan_type = { \\\n\t\t.sign = 's', \\\n\t\t.realbits = 16, \\\n\t\t.storagebits = 16, \\\n\t\t.endianness = IIO_BE, \\\n\t}, \\\n}\n\nstatic const struct iio_chan_spec mag3110_channels[] = {\n\tMAG3110_CHANNEL(X, 0),\n\tMAG3110_CHANNEL(Y, 1),\n\tMAG3110_CHANNEL(Z, 2),\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\n\t\t.scan_index = 3,\n\t\t.scan_type = {\n\t\t\t.sign = 's',\n\t\t\t.realbits = 8,\n\t\t\t.storagebits = 8,\n\t\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(4),\n};\n\nstatic struct attribute *mag3110_attributes[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group mag3110_group = {\n\t.attrs = mag3110_attributes,\n};\n\nstatic const struct iio_info mag3110_info = {\n\t.attrs = &mag3110_group,\n\t.read_raw = &mag3110_read_raw,\n\t.write_raw = &mag3110_write_raw,\n};\n\nstatic const unsigned long mag3110_scan_masks[] = {0x7, 0xf, 0};\n\nstatic int mag3110_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct mag3110_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\n\tdata->vdd_reg = devm_regulator_get(&client->dev, \"vdd\");\n\tif (IS_ERR(data->vdd_reg))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(data->vdd_reg),\n\t\t\t\t     \"failed to get VDD regulator!\\n\");\n\n\tdata->vddio_reg = devm_regulator_get(&client->dev, \"vddio\");\n\tif (IS_ERR(data->vddio_reg))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(data->vddio_reg),\n\t\t\t\t     \"failed to get VDDIO regulator!\\n\");\n\n\tret = regulator_enable(data->vdd_reg);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to enable VDD regulator!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_enable(data->vddio_reg);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to enable VDDIO regulator!\\n\");\n\t\tgoto disable_regulator_vdd;\n\t}\n\n\tret = i2c_smbus_read_byte_data(client, MAG3110_WHO_AM_I);\n\tif (ret < 0)\n\t\tgoto disable_regulators;\n\tif (ret != MAG3110_DEVICE_ID) {\n\t\tret = -ENODEV;\n\t\tgoto disable_regulators;\n\t}\n\n\tdata->client = client;\n\tmutex_init(&data->lock);\n\n\ti2c_set_clientdata(client, indio_dev);\n\tindio_dev->info = &mag3110_info;\n\tindio_dev->name = id->name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = mag3110_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mag3110_channels);\n\tindio_dev->available_scan_masks = mag3110_scan_masks;\n\n\tdata->ctrl_reg1 = MAG3110_CTRL_DR_DEFAULT << MAG3110_CTRL_DR_SHIFT;\n\tdata->sleep_val = mag3110_calculate_sleep(data);\n\tif (data->sleep_val < 40)\n\t\tdata->ctrl_reg1 |= MAG3110_CTRL_AC;\n\n\tret = mag3110_change_config(data, MAG3110_CTRL_REG1, data->ctrl_reg1);\n\tif (ret < 0)\n\t\tgoto disable_regulators;\n\n\tret = i2c_smbus_write_byte_data(client, MAG3110_CTRL_REG2,\n\t\tMAG3110_CTRL_AUTO_MRST_EN);\n\tif (ret < 0)\n\t\tgoto standby_on_error;\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL,\n\t\tmag3110_trigger_handler, NULL);\n\tif (ret < 0)\n\t\tgoto standby_on_error;\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0)\n\t\tgoto buffer_cleanup;\n\treturn 0;\n\nbuffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\nstandby_on_error:\n\tmag3110_standby(iio_priv(indio_dev));\ndisable_regulators:\n\tregulator_disable(data->vddio_reg);\ndisable_regulator_vdd:\n\tregulator_disable(data->vdd_reg);\n\n\treturn ret;\n}\n\nstatic void mag3110_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct mag3110_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tmag3110_standby(iio_priv(indio_dev));\n\tregulator_disable(data->vddio_reg);\n\tregulator_disable(data->vdd_reg);\n}\n\nstatic int mag3110_suspend(struct device *dev)\n{\n\tstruct mag3110_data *data = iio_priv(i2c_get_clientdata(\n\t\tto_i2c_client(dev)));\n\tint ret;\n\n\tret = mag3110_standby(iio_priv(i2c_get_clientdata(\n\t\tto_i2c_client(dev))));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_disable(data->vddio_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to disable VDDIO regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_disable(data->vdd_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to disable VDD regulator\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mag3110_resume(struct device *dev)\n{\n\tstruct mag3110_data *data = iio_priv(i2c_get_clientdata(\n\t\tto_i2c_client(dev)));\n\tint ret;\n\n\tret = regulator_enable(data->vdd_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable VDD regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_enable(data->vddio_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable VDDIO regulator\\n\");\n\t\tregulator_disable(data->vdd_reg);\n\t\treturn ret;\n\t}\n\n\treturn i2c_smbus_write_byte_data(data->client, MAG3110_CTRL_REG1,\n\t\tdata->ctrl_reg1);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mag3110_pm_ops, mag3110_suspend,\n\t\t\t\tmag3110_resume);\n\nstatic const struct i2c_device_id mag3110_id[] = {\n\t{ \"mag3110\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mag3110_id);\n\nstatic const struct of_device_id mag3110_of_match[] = {\n\t{ .compatible = \"fsl,mag3110\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mag3110_of_match);\n\nstatic struct i2c_driver mag3110_driver = {\n\t.driver = {\n\t\t.name\t= \"mag3110\",\n\t\t.of_match_table = mag3110_of_match,\n\t\t.pm\t= pm_sleep_ptr(&mag3110_pm_ops),\n\t},\n\t.probe = mag3110_probe,\n\t.remove = mag3110_remove,\n\t.id_table = mag3110_id,\n};\nmodule_i2c_driver(mag3110_driver);\n\nMODULE_AUTHOR(\"Peter Meerwald <pmeerw@pmeerw.net>\");\nMODULE_DESCRIPTION(\"Freescale MAG3110 magnetometer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}