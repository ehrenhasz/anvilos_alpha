{
  "module_name": "mmc35240.c",
  "hash_id": "efe5465ee810be9ed7d64765229df640776520e73eaac3f4749ebdba587e6ba5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/magnetometer/mmc35240.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/regmap.h>\n#include <linux/acpi.h>\n#include <linux/pm.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define MMC35240_DRV_NAME \"mmc35240\"\n#define MMC35240_REGMAP_NAME \"mmc35240_regmap\"\n\n#define MMC35240_REG_XOUT_L\t0x00\n#define MMC35240_REG_XOUT_H\t0x01\n#define MMC35240_REG_YOUT_L\t0x02\n#define MMC35240_REG_YOUT_H\t0x03\n#define MMC35240_REG_ZOUT_L\t0x04\n#define MMC35240_REG_ZOUT_H\t0x05\n\n#define MMC35240_REG_STATUS\t0x06\n#define MMC35240_REG_CTRL0\t0x07\n#define MMC35240_REG_CTRL1\t0x08\n\n#define MMC35240_REG_ID\t\t0x20\n\n#define MMC35240_STATUS_MEAS_DONE_BIT\tBIT(0)\n\n#define MMC35240_CTRL0_REFILL_BIT\tBIT(7)\n#define MMC35240_CTRL0_RESET_BIT\tBIT(6)\n#define MMC35240_CTRL0_SET_BIT\t\tBIT(5)\n#define MMC35240_CTRL0_CMM_BIT\t\tBIT(1)\n#define MMC35240_CTRL0_TM_BIT\t\tBIT(0)\n\n \n#define MMC35240_CTRL1_BW0_BIT\t\tBIT(0)\n#define MMC35240_CTRL1_BW1_BIT\t\tBIT(1)\n\n#define MMC35240_CTRL1_BW_MASK\t (MMC35240_CTRL1_BW0_BIT | \\\n\t\t MMC35240_CTRL1_BW1_BIT)\n#define MMC35240_CTRL1_BW_SHIFT\t\t0\n\n#define MMC35240_WAIT_CHARGE_PUMP\t50000\t \n#define MMC35240_WAIT_SET_RESET\t\t1000\t \n\n \n\n \n#define MMC35240_OTP_CONVERT_Y(REG) (((REG) >= 32 ? (32 - (REG)) : (REG)) * 6)\n\n \n#define MMC35240_OTP_CONVERT_Z(REG) (((REG) >= 32 ? (32 - (REG)) : (REG)) * 81)\n\n#define MMC35240_X_COEFF(x)\t(x)\n#define MMC35240_Y_COEFF(y)\t(y + 1000)\n#define MMC35240_Z_COEFF(z)\t(z + 13500)\n\n#define MMC35240_OTP_START_ADDR\t\t0x1B\n\nenum mmc35240_resolution {\n\tMMC35240_16_BITS_SLOW = 0,  \n\tMMC35240_16_BITS_FAST,      \n\tMMC35240_14_BITS,           \n\tMMC35240_12_BITS,           \n};\n\nenum mmc35240_axis {\n\tAXIS_X = 0,\n\tAXIS_Y,\n\tAXIS_Z,\n};\n\nstatic const struct {\n\tint sens[3];  \n\tint nfo;  \n} mmc35240_props_table[] = {\n\t \n\t{\n\t\t{1024, 1024, 1024},\n\t\t32768,\n\t},\n\t \n\t{\n\t\t{1024, 1024, 770},\n\t\t32768,\n\t},\n\t \n\t{\n\t\t{256, 256, 193},\n\t\t8192,\n\t},\n\t \n\t{\n\t\t{64, 64, 48},\n\t\t2048,\n\t},\n};\n\nstruct mmc35240_data {\n\tstruct i2c_client *client;\n\tstruct mutex mutex;\n\tstruct regmap *regmap;\n\tenum mmc35240_resolution res;\n\n\t \n\tint axis_coef[3];\n\tint axis_scale[3];\n};\n\nstatic const struct {\n\tint val;\n\tint val2;\n} mmc35240_samp_freq[] = { {1, 500000},\n\t\t\t   {13, 0},\n\t\t\t   {25, 0},\n\t\t\t   {50, 0} };\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\"1.5 13 25 50\");\n\n#define MMC35240_CHANNEL(_axis) { \\\n\t.type = IIO_MAGN, \\\n\t.modified = 1, \\\n\t.channel2 = IIO_MOD_ ## _axis, \\\n\t.address = AXIS_ ## _axis, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE), \\\n}\n\nstatic const struct iio_chan_spec mmc35240_channels[] = {\n\tMMC35240_CHANNEL(X),\n\tMMC35240_CHANNEL(Y),\n\tMMC35240_CHANNEL(Z),\n};\n\nstatic struct attribute *mmc35240_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group mmc35240_attribute_group = {\n\t.attrs = mmc35240_attributes,\n};\n\nstatic int mmc35240_get_samp_freq_index(struct mmc35240_data *data,\n\t\t\t\t\tint val, int val2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mmc35240_samp_freq); i++)\n\t\tif (mmc35240_samp_freq[i].val == val &&\n\t\t    mmc35240_samp_freq[i].val2 == val2)\n\t\t\treturn i;\n\treturn -EINVAL;\n}\n\nstatic int mmc35240_hw_set(struct mmc35240_data *data, bool set)\n{\n\tint ret;\n\tu8 coil_bit;\n\n\t \n\tret = regmap_update_bits(data->regmap, MMC35240_REG_CTRL0,\n\t\t\t\t MMC35240_CTRL0_REFILL_BIT,\n\t\t\t\t MMC35240_CTRL0_REFILL_BIT);\n\tif (ret < 0)\n\t\treturn ret;\n\tusleep_range(MMC35240_WAIT_CHARGE_PUMP, MMC35240_WAIT_CHARGE_PUMP + 1);\n\n\tif (set)\n\t\tcoil_bit = MMC35240_CTRL0_SET_BIT;\n\telse\n\t\tcoil_bit = MMC35240_CTRL0_RESET_BIT;\n\n\treturn regmap_update_bits(data->regmap, MMC35240_REG_CTRL0,\n\t\t\t\t  coil_bit, coil_bit);\n\n}\n\nstatic int mmc35240_init(struct mmc35240_data *data)\n{\n\tint ret, y_convert, z_convert;\n\tunsigned int reg_id;\n\tu8 otp_data[6];\n\n\tret = regmap_read(data->regmap, MMC35240_REG_ID, &reg_id);\n\tif (ret < 0) {\n\t\tdev_err(&data->client->dev, \"Error reading product id\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&data->client->dev, \"MMC35240 chip id %x\\n\", reg_id);\n\n\t \n\tret = mmc35240_hw_set(data, true);\n\tif (ret < 0)\n\t\treturn ret;\n\tusleep_range(MMC35240_WAIT_SET_RESET, MMC35240_WAIT_SET_RESET + 1);\n\n\tret = mmc35240_hw_set(data, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, MMC35240_REG_CTRL1,\n\t\t\t\t MMC35240_CTRL1_BW_MASK,\n\t\t\t\t data->res << MMC35240_CTRL1_BW_SHIFT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, MMC35240_OTP_START_ADDR,\n\t\t\t       otp_data, sizeof(otp_data));\n\tif (ret < 0)\n\t\treturn ret;\n\n\ty_convert = MMC35240_OTP_CONVERT_Y(((otp_data[1] & 0x03) << 4) |\n\t\t\t\t\t   (otp_data[2] >> 4));\n\tz_convert = MMC35240_OTP_CONVERT_Z(otp_data[3] & 0x3f);\n\n\tdata->axis_coef[0] = MMC35240_X_COEFF(1);\n\tdata->axis_coef[1] = MMC35240_Y_COEFF(y_convert);\n\tdata->axis_coef[2] = MMC35240_Z_COEFF(z_convert);\n\n\tdata->axis_scale[0] = 1;\n\tdata->axis_scale[1] = 1000;\n\tdata->axis_scale[2] = 10000;\n\n\treturn 0;\n}\n\nstatic int mmc35240_take_measurement(struct mmc35240_data *data)\n{\n\tint ret, tries = 100;\n\tunsigned int reg_status;\n\n\tret = regmap_write(data->regmap, MMC35240_REG_CTRL0,\n\t\t\t   MMC35240_CTRL0_TM_BIT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (tries-- > 0) {\n\t\tret = regmap_read(data->regmap, MMC35240_REG_STATUS,\n\t\t\t\t  &reg_status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (reg_status & MMC35240_STATUS_MEAS_DONE_BIT)\n\t\t\tbreak;\n\t\t \n\t\tusleep_range(10000, 11000);\n\t}\n\n\tif (tries < 0) {\n\t\tdev_err(&data->client->dev, \"data not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int mmc35240_read_measurement(struct mmc35240_data *data, __le16 buf[3])\n{\n\tint ret;\n\n\tret = mmc35240_take_measurement(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_bulk_read(data->regmap, MMC35240_REG_XOUT_L, buf,\n\t\t\t\t3 * sizeof(__le16));\n}\n\n \nstatic int mmc35240_raw_to_mgauss(struct mmc35240_data *data, int index,\n\t\t\t\t  __le16 buf[], int *val)\n{\n\tint raw[3];\n\tint sens[3];\n\tint nfo;\n\n\traw[AXIS_X] = le16_to_cpu(buf[AXIS_X]);\n\traw[AXIS_Y] = le16_to_cpu(buf[AXIS_Y]);\n\traw[AXIS_Z] = le16_to_cpu(buf[AXIS_Z]);\n\n\tsens[AXIS_X] = mmc35240_props_table[data->res].sens[AXIS_X];\n\tsens[AXIS_Y] = mmc35240_props_table[data->res].sens[AXIS_Y];\n\tsens[AXIS_Z] = mmc35240_props_table[data->res].sens[AXIS_Z];\n\n\tnfo = mmc35240_props_table[data->res].nfo;\n\n\tswitch (index) {\n\tcase AXIS_X:\n\t\t*val = (raw[AXIS_X] - nfo) * 1000 / sens[AXIS_X];\n\t\tbreak;\n\tcase AXIS_Y:\n\t\t*val = (raw[AXIS_Y] - nfo) * 1000 / sens[AXIS_Y] -\n\t\t\t(raw[AXIS_Z] - nfo)  * 1000 / sens[AXIS_Z];\n\t\tbreak;\n\tcase AXIS_Z:\n\t\t*val = (raw[AXIS_Y] - nfo) * 1000 / sens[AXIS_Y] +\n\t\t\t(raw[AXIS_Z] - nfo) * 1000 / sens[AXIS_Z];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t \n\t*val = (*val) * data->axis_coef[index] / data->axis_scale[index];\n\n\treturn 0;\n}\n\nstatic int mmc35240_read_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan, int *val,\n\t\t\t     int *val2, long mask)\n{\n\tstruct mmc35240_data *data = iio_priv(indio_dev);\n\tint ret, i;\n\tunsigned int reg;\n\t__le16 buf[3];\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tmutex_lock(&data->mutex);\n\t\tret = mmc35240_read_measurement(data, buf);\n\t\tmutex_unlock(&data->mutex);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = mmc35240_raw_to_mgauss(data, chan->address, buf, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = 1000;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tmutex_lock(&data->mutex);\n\t\tret = regmap_read(data->regmap, MMC35240_REG_CTRL1, &reg);\n\t\tmutex_unlock(&data->mutex);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ti = (reg & MMC35240_CTRL1_BW_MASK) >> MMC35240_CTRL1_BW_SHIFT;\n\t\tif (i < 0 || i >= ARRAY_SIZE(mmc35240_samp_freq))\n\t\t\treturn -EINVAL;\n\n\t\t*val = mmc35240_samp_freq[i].val;\n\t\t*val2 = mmc35240_samp_freq[i].val2;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mmc35240_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan, int val,\n\t\t\t      int val2, long mask)\n{\n\tstruct mmc35240_data *data = iio_priv(indio_dev);\n\tint i, ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\ti = mmc35240_get_samp_freq_index(data, val, val2);\n\t\tif (i < 0)\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&data->mutex);\n\t\tret = regmap_update_bits(data->regmap, MMC35240_REG_CTRL1,\n\t\t\t\t\t MMC35240_CTRL1_BW_MASK,\n\t\t\t\t\t i << MMC35240_CTRL1_BW_SHIFT);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info mmc35240_info = {\n\t.read_raw\t= mmc35240_read_raw,\n\t.write_raw\t= mmc35240_write_raw,\n\t.attrs\t\t= &mmc35240_attribute_group,\n};\n\nstatic bool mmc35240_is_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MMC35240_REG_CTRL0:\n\tcase MMC35240_REG_CTRL1:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool mmc35240_is_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MMC35240_REG_XOUT_L:\n\tcase MMC35240_REG_XOUT_H:\n\tcase MMC35240_REG_YOUT_L:\n\tcase MMC35240_REG_YOUT_H:\n\tcase MMC35240_REG_ZOUT_L:\n\tcase MMC35240_REG_ZOUT_H:\n\tcase MMC35240_REG_STATUS:\n\tcase MMC35240_REG_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool mmc35240_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MMC35240_REG_CTRL0:\n\tcase MMC35240_REG_CTRL1:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic const struct reg_default mmc35240_reg_defaults[] = {\n\t{ MMC35240_REG_CTRL0,  0x00 },\n\t{ MMC35240_REG_CTRL1,  0x00 },\n};\n\nstatic const struct regmap_config mmc35240_regmap_config = {\n\t.name = MMC35240_REGMAP_NAME,\n\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = MMC35240_REG_ID,\n\t.cache_type = REGCACHE_FLAT,\n\n\t.writeable_reg = mmc35240_is_writeable_reg,\n\t.readable_reg = mmc35240_is_readable_reg,\n\t.volatile_reg = mmc35240_is_volatile_reg,\n\n\t.reg_defaults = mmc35240_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(mmc35240_reg_defaults),\n};\n\nstatic int mmc35240_probe(struct i2c_client *client)\n{\n\tstruct mmc35240_data *data;\n\tstruct iio_dev *indio_dev;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_i2c(client, &mmc35240_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"regmap initialization failed\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\tdata->client = client;\n\tdata->regmap = regmap;\n\tdata->res = MMC35240_16_BITS_SLOW;\n\n\tmutex_init(&data->mutex);\n\n\tindio_dev->info = &mmc35240_info;\n\tindio_dev->name = MMC35240_DRV_NAME;\n\tindio_dev->channels = mmc35240_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(mmc35240_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tret = mmc35240_init(data);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"mmc35240 chip init failed\\n\");\n\t\treturn ret;\n\t}\n\treturn devm_iio_device_register(&client->dev, indio_dev);\n}\n\nstatic int mmc35240_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mmc35240_data *data = iio_priv(indio_dev);\n\n\tregcache_cache_only(data->regmap, true);\n\n\treturn 0;\n}\n\nstatic int mmc35240_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct mmc35240_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tregcache_mark_dirty(data->regmap);\n\tret = regcache_sync_region(data->regmap, MMC35240_REG_CTRL0,\n\t\t\t\t   MMC35240_REG_CTRL1);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to restore control registers\\n\");\n\n\tregcache_cache_only(data->regmap, false);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mmc35240_pm_ops, mmc35240_suspend,\n\t\t\t\tmmc35240_resume);\n\nstatic const struct of_device_id mmc35240_of_match[] = {\n\t{ .compatible = \"memsic,mmc35240\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mmc35240_of_match);\n\nstatic const struct acpi_device_id mmc35240_acpi_match[] = {\n\t{\"MMC35240\", 0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, mmc35240_acpi_match);\n\nstatic const struct i2c_device_id mmc35240_id[] = {\n\t{\"mmc35240\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, mmc35240_id);\n\nstatic struct i2c_driver mmc35240_driver = {\n\t.driver = {\n\t\t.name = MMC35240_DRV_NAME,\n\t\t.of_match_table = mmc35240_of_match,\n\t\t.pm = pm_sleep_ptr(&mmc35240_pm_ops),\n\t\t.acpi_match_table = ACPI_PTR(mmc35240_acpi_match),\n\t},\n\t.probe\t\t= mmc35240_probe,\n\t.id_table\t= mmc35240_id,\n};\n\nmodule_i2c_driver(mmc35240_driver);\n\nMODULE_AUTHOR(\"Daniel Baluta <daniel.baluta@intel.com>\");\nMODULE_DESCRIPTION(\"MEMSIC MMC35240 magnetic sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}