{
  "module_name": "bmc150_magn.c",
  "hash_id": "75787edce9d4c64a2059e15916f74e0e748c62da70a47fa45af597bafa78d366",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/magnetometer/bmc150_magn.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/events.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include \"bmc150_magn.h\"\n\n#define BMC150_MAGN_DRV_NAME\t\t\t\"bmc150_magn\"\n#define BMC150_MAGN_IRQ_NAME\t\t\t\"bmc150_magn_event\"\n\n#define BMC150_MAGN_REG_CHIP_ID\t\t\t0x40\n#define BMC150_MAGN_CHIP_ID_VAL\t\t\t0x32\n\n#define BMC150_MAGN_REG_X_L\t\t\t0x42\n#define BMC150_MAGN_REG_X_M\t\t\t0x43\n#define BMC150_MAGN_REG_Y_L\t\t\t0x44\n#define BMC150_MAGN_REG_Y_M\t\t\t0x45\n#define BMC150_MAGN_SHIFT_XY_L\t\t\t3\n#define BMC150_MAGN_REG_Z_L\t\t\t0x46\n#define BMC150_MAGN_REG_Z_M\t\t\t0x47\n#define BMC150_MAGN_SHIFT_Z_L\t\t\t1\n#define BMC150_MAGN_REG_RHALL_L\t\t\t0x48\n#define BMC150_MAGN_REG_RHALL_M\t\t\t0x49\n#define BMC150_MAGN_SHIFT_RHALL_L\t\t2\n\n#define BMC150_MAGN_REG_INT_STATUS\t\t0x4A\n\n#define BMC150_MAGN_REG_POWER\t\t\t0x4B\n#define BMC150_MAGN_MASK_POWER_CTL\t\tBIT(0)\n\n#define BMC150_MAGN_REG_OPMODE_ODR\t\t0x4C\n#define BMC150_MAGN_MASK_OPMODE\t\t\tGENMASK(2, 1)\n#define BMC150_MAGN_SHIFT_OPMODE\t\t1\n#define BMC150_MAGN_MODE_NORMAL\t\t\t0x00\n#define BMC150_MAGN_MODE_FORCED\t\t\t0x01\n#define BMC150_MAGN_MODE_SLEEP\t\t\t0x03\n#define BMC150_MAGN_MASK_ODR\t\t\tGENMASK(5, 3)\n#define BMC150_MAGN_SHIFT_ODR\t\t\t3\n\n#define BMC150_MAGN_REG_INT\t\t\t0x4D\n\n#define BMC150_MAGN_REG_INT_DRDY\t\t0x4E\n#define BMC150_MAGN_MASK_DRDY_EN\t\tBIT(7)\n#define BMC150_MAGN_SHIFT_DRDY_EN\t\t7\n#define BMC150_MAGN_MASK_DRDY_INT3\t\tBIT(6)\n#define BMC150_MAGN_MASK_DRDY_Z_EN\t\tBIT(5)\n#define BMC150_MAGN_MASK_DRDY_Y_EN\t\tBIT(4)\n#define BMC150_MAGN_MASK_DRDY_X_EN\t\tBIT(3)\n#define BMC150_MAGN_MASK_DRDY_DR_POLARITY\tBIT(2)\n#define BMC150_MAGN_MASK_DRDY_LATCHING\t\tBIT(1)\n#define BMC150_MAGN_MASK_DRDY_INT3_POLARITY\tBIT(0)\n\n#define BMC150_MAGN_REG_LOW_THRESH\t\t0x4F\n#define BMC150_MAGN_REG_HIGH_THRESH\t\t0x50\n#define BMC150_MAGN_REG_REP_XY\t\t\t0x51\n#define BMC150_MAGN_REG_REP_Z\t\t\t0x52\n#define BMC150_MAGN_REG_REP_DATAMASK\t\tGENMASK(7, 0)\n\n#define BMC150_MAGN_REG_TRIM_START\t\t0x5D\n#define BMC150_MAGN_REG_TRIM_END\t\t0x71\n\n#define BMC150_MAGN_XY_OVERFLOW_VAL\t\t-4096\n#define BMC150_MAGN_Z_OVERFLOW_VAL\t\t-16384\n\n \n#define BMC150_MAGN_START_UP_TIME_MS\t\t3\n\n#define BMC150_MAGN_AUTO_SUSPEND_DELAY_MS\t2000\n\n#define BMC150_MAGN_REGVAL_TO_REPXY(regval) (((regval) * 2) + 1)\n#define BMC150_MAGN_REGVAL_TO_REPZ(regval) ((regval) + 1)\n#define BMC150_MAGN_REPXY_TO_REGVAL(rep) (((rep) - 1) / 2)\n#define BMC150_MAGN_REPZ_TO_REGVAL(rep) ((rep) - 1)\n\nenum bmc150_magn_axis {\n\tAXIS_X,\n\tAXIS_Y,\n\tAXIS_Z,\n\tRHALL,\n\tAXIS_XYZ_MAX = RHALL,\n\tAXIS_XYZR_MAX,\n};\n\nenum bmc150_magn_power_modes {\n\tBMC150_MAGN_POWER_MODE_SUSPEND,\n\tBMC150_MAGN_POWER_MODE_SLEEP,\n\tBMC150_MAGN_POWER_MODE_NORMAL,\n};\n\nstruct bmc150_magn_trim_regs {\n\ts8 x1;\n\ts8 y1;\n\t__le16 reserved1;\n\tu8 reserved2;\n\t__le16 z4;\n\ts8 x2;\n\ts8 y2;\n\t__le16 reserved3;\n\t__le16 z2;\n\t__le16 z1;\n\t__le16 xyz1;\n\t__le16 z3;\n\ts8 xy2;\n\tu8 xy1;\n} __packed;\n\nstruct bmc150_magn_data {\n\tstruct device *dev;\n\t \n\tstruct mutex mutex;\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data regulators[2];\n\tstruct iio_mount_matrix orientation;\n\t \n\tstruct {\n\t\ts32 chans[3];\n\t\ts64 timestamp __aligned(8);\n\t} scan;\n\tstruct iio_trigger *dready_trig;\n\tbool dready_trigger_on;\n\tint max_odr;\n\tint irq;\n};\n\nstatic const struct {\n\tint freq;\n\tu8 reg_val;\n} bmc150_magn_samp_freq_table[] = { {2, 0x01},\n\t\t\t\t    {6, 0x02},\n\t\t\t\t    {8, 0x03},\n\t\t\t\t    {10, 0x00},\n\t\t\t\t    {15, 0x04},\n\t\t\t\t    {20, 0x05},\n\t\t\t\t    {25, 0x06},\n\t\t\t\t    {30, 0x07} };\n\nenum bmc150_magn_presets {\n\tLOW_POWER_PRESET,\n\tREGULAR_PRESET,\n\tENHANCED_REGULAR_PRESET,\n\tHIGH_ACCURACY_PRESET\n};\n\nstatic const struct bmc150_magn_preset {\n\tu8 rep_xy;\n\tu8 rep_z;\n\tu8 odr;\n} bmc150_magn_presets_table[] = {\n\t[LOW_POWER_PRESET] = {3, 3, 10},\n\t[REGULAR_PRESET] =  {9, 15, 10},\n\t[ENHANCED_REGULAR_PRESET] =  {15, 27, 10},\n\t[HIGH_ACCURACY_PRESET] =  {47, 83, 20},\n};\n\n#define BMC150_MAGN_DEFAULT_PRESET REGULAR_PRESET\n\nstatic bool bmc150_magn_is_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase BMC150_MAGN_REG_POWER:\n\tcase BMC150_MAGN_REG_OPMODE_ODR:\n\tcase BMC150_MAGN_REG_INT:\n\tcase BMC150_MAGN_REG_INT_DRDY:\n\tcase BMC150_MAGN_REG_LOW_THRESH:\n\tcase BMC150_MAGN_REG_HIGH_THRESH:\n\tcase BMC150_MAGN_REG_REP_XY:\n\tcase BMC150_MAGN_REG_REP_Z:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool bmc150_magn_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase BMC150_MAGN_REG_X_L:\n\tcase BMC150_MAGN_REG_X_M:\n\tcase BMC150_MAGN_REG_Y_L:\n\tcase BMC150_MAGN_REG_Y_M:\n\tcase BMC150_MAGN_REG_Z_L:\n\tcase BMC150_MAGN_REG_Z_M:\n\tcase BMC150_MAGN_REG_RHALL_L:\n\tcase BMC150_MAGN_REG_RHALL_M:\n\tcase BMC150_MAGN_REG_INT_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nconst struct regmap_config bmc150_magn_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = BMC150_MAGN_REG_TRIM_END,\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.writeable_reg = bmc150_magn_is_writeable_reg,\n\t.volatile_reg = bmc150_magn_is_volatile_reg,\n};\nEXPORT_SYMBOL_NS(bmc150_magn_regmap_config, IIO_BMC150_MAGN);\n\nstatic int bmc150_magn_set_power_mode(struct bmc150_magn_data *data,\n\t\t\t\t      enum bmc150_magn_power_modes mode,\n\t\t\t\t      bool state)\n{\n\tint ret;\n\n\tswitch (mode) {\n\tcase BMC150_MAGN_POWER_MODE_SUSPEND:\n\t\tret = regmap_update_bits(data->regmap, BMC150_MAGN_REG_POWER,\n\t\t\t\t\t BMC150_MAGN_MASK_POWER_CTL, !state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tusleep_range(BMC150_MAGN_START_UP_TIME_MS * 1000, 20000);\n\t\treturn 0;\n\tcase BMC150_MAGN_POWER_MODE_SLEEP:\n\t\treturn regmap_update_bits(data->regmap,\n\t\t\t\t\t  BMC150_MAGN_REG_OPMODE_ODR,\n\t\t\t\t\t  BMC150_MAGN_MASK_OPMODE,\n\t\t\t\t\t  BMC150_MAGN_MODE_SLEEP <<\n\t\t\t\t\t  BMC150_MAGN_SHIFT_OPMODE);\n\tcase BMC150_MAGN_POWER_MODE_NORMAL:\n\t\treturn regmap_update_bits(data->regmap,\n\t\t\t\t\t  BMC150_MAGN_REG_OPMODE_ODR,\n\t\t\t\t\t  BMC150_MAGN_MASK_OPMODE,\n\t\t\t\t\t  BMC150_MAGN_MODE_NORMAL <<\n\t\t\t\t\t  BMC150_MAGN_SHIFT_OPMODE);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int bmc150_magn_set_power_state(struct bmc150_magn_data *data, bool on)\n{\n#ifdef CONFIG_PM\n\tint ret;\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(data->dev);\n\t} else {\n\t\tpm_runtime_mark_last_busy(data->dev);\n\t\tret = pm_runtime_put_autosuspend(data->dev);\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(data->dev,\n\t\t\t\"failed to change power state to %d\\n\", on);\n\t\treturn ret;\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic int bmc150_magn_get_odr(struct bmc150_magn_data *data, int *val)\n{\n\tint ret, reg_val;\n\tu8 i, odr_val;\n\n\tret = regmap_read(data->regmap, BMC150_MAGN_REG_OPMODE_ODR, &reg_val);\n\tif (ret < 0)\n\t\treturn ret;\n\todr_val = (reg_val & BMC150_MAGN_MASK_ODR) >> BMC150_MAGN_SHIFT_ODR;\n\n\tfor (i = 0; i < ARRAY_SIZE(bmc150_magn_samp_freq_table); i++)\n\t\tif (bmc150_magn_samp_freq_table[i].reg_val == odr_val) {\n\t\t\t*val = bmc150_magn_samp_freq_table[i].freq;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -EINVAL;\n}\n\nstatic int bmc150_magn_set_odr(struct bmc150_magn_data *data, int val)\n{\n\tint ret;\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bmc150_magn_samp_freq_table); i++) {\n\t\tif (bmc150_magn_samp_freq_table[i].freq == val) {\n\t\t\tret = regmap_update_bits(data->regmap,\n\t\t\t\t\t\t BMC150_MAGN_REG_OPMODE_ODR,\n\t\t\t\t\t\t BMC150_MAGN_MASK_ODR,\n\t\t\t\t\t\t bmc150_magn_samp_freq_table[i].\n\t\t\t\t\t\t reg_val <<\n\t\t\t\t\t\t BMC150_MAGN_SHIFT_ODR);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int bmc150_magn_set_max_odr(struct bmc150_magn_data *data, int rep_xy,\n\t\t\t\t   int rep_z, int odr)\n{\n\tint ret, reg_val, max_odr;\n\n\tif (rep_xy <= 0) {\n\t\tret = regmap_read(data->regmap, BMC150_MAGN_REG_REP_XY,\n\t\t\t\t  &reg_val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\trep_xy = BMC150_MAGN_REGVAL_TO_REPXY(reg_val);\n\t}\n\tif (rep_z <= 0) {\n\t\tret = regmap_read(data->regmap, BMC150_MAGN_REG_REP_Z,\n\t\t\t\t  &reg_val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\trep_z = BMC150_MAGN_REGVAL_TO_REPZ(reg_val);\n\t}\n\tif (odr <= 0) {\n\t\tret = bmc150_magn_get_odr(data, &odr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\t \n\tmax_odr = 1000000 / (145 * rep_xy + 500 * rep_z + 980);\n\tif (odr > max_odr) {\n\t\tdev_err(data->dev,\n\t\t\t\"Can't set oversampling with sampling freq %d\\n\",\n\t\t\todr);\n\t\treturn -EINVAL;\n\t}\n\tdata->max_odr = max_odr;\n\n\treturn 0;\n}\n\nstatic s32 bmc150_magn_compensate_x(struct bmc150_magn_trim_regs *tregs, s16 x,\n\t\t\t\t    u16 rhall)\n{\n\ts16 val;\n\tu16 xyz1 = le16_to_cpu(tregs->xyz1);\n\n\tif (x == BMC150_MAGN_XY_OVERFLOW_VAL)\n\t\treturn S32_MIN;\n\n\tif (!rhall)\n\t\trhall = xyz1;\n\n\tval = ((s16)(((u16)((((s32)xyz1) << 14) / rhall)) - ((u16)0x4000)));\n\tval = ((s16)((((s32)x) * ((((((((s32)tregs->xy2) * ((((s32)val) *\n\t      ((s32)val)) >> 7)) + (((s32)val) *\n\t      ((s32)(((s16)tregs->xy1) << 7)))) >> 9) + ((s32)0x100000)) *\n\t      ((s32)(((s16)tregs->x2) + ((s16)0xA0)))) >> 12)) >> 13)) +\n\t      (((s16)tregs->x1) << 3);\n\n\treturn (s32)val;\n}\n\nstatic s32 bmc150_magn_compensate_y(struct bmc150_magn_trim_regs *tregs, s16 y,\n\t\t\t\t    u16 rhall)\n{\n\ts16 val;\n\tu16 xyz1 = le16_to_cpu(tregs->xyz1);\n\n\tif (y == BMC150_MAGN_XY_OVERFLOW_VAL)\n\t\treturn S32_MIN;\n\n\tif (!rhall)\n\t\trhall = xyz1;\n\n\tval = ((s16)(((u16)((((s32)xyz1) << 14) / rhall)) - ((u16)0x4000)));\n\tval = ((s16)((((s32)y) * ((((((((s32)tregs->xy2) * ((((s32)val) *\n\t      ((s32)val)) >> 7)) + (((s32)val) *\n\t      ((s32)(((s16)tregs->xy1) << 7)))) >> 9) + ((s32)0x100000)) *\n\t      ((s32)(((s16)tregs->y2) + ((s16)0xA0)))) >> 12)) >> 13)) +\n\t      (((s16)tregs->y1) << 3);\n\n\treturn (s32)val;\n}\n\nstatic s32 bmc150_magn_compensate_z(struct bmc150_magn_trim_regs *tregs, s16 z,\n\t\t\t\t    u16 rhall)\n{\n\ts32 val;\n\tu16 xyz1 = le16_to_cpu(tregs->xyz1);\n\tu16 z1 = le16_to_cpu(tregs->z1);\n\ts16 z2 = le16_to_cpu(tregs->z2);\n\ts16 z3 = le16_to_cpu(tregs->z3);\n\ts16 z4 = le16_to_cpu(tregs->z4);\n\n\tif (z == BMC150_MAGN_Z_OVERFLOW_VAL)\n\t\treturn S32_MIN;\n\n\tval = (((((s32)(z - z4)) << 15) - ((((s32)z3) * ((s32)(((s16)rhall) -\n\t      ((s16)xyz1)))) >> 2)) / (z2 + ((s16)(((((s32)z1) *\n\t      ((((s16)rhall) << 1))) + (1 << 15)) >> 16))));\n\n\treturn val;\n}\n\nstatic int bmc150_magn_read_xyz(struct bmc150_magn_data *data, s32 *buffer)\n{\n\tint ret;\n\t__le16 values[AXIS_XYZR_MAX];\n\ts16 raw_x, raw_y, raw_z;\n\tu16 rhall;\n\tstruct bmc150_magn_trim_regs tregs;\n\n\tret = regmap_bulk_read(data->regmap, BMC150_MAGN_REG_X_L,\n\t\t\t       values, sizeof(values));\n\tif (ret < 0)\n\t\treturn ret;\n\n\traw_x = (s16)le16_to_cpu(values[AXIS_X]) >> BMC150_MAGN_SHIFT_XY_L;\n\traw_y = (s16)le16_to_cpu(values[AXIS_Y]) >> BMC150_MAGN_SHIFT_XY_L;\n\traw_z = (s16)le16_to_cpu(values[AXIS_Z]) >> BMC150_MAGN_SHIFT_Z_L;\n\trhall = le16_to_cpu(values[RHALL]) >> BMC150_MAGN_SHIFT_RHALL_L;\n\n\tret = regmap_bulk_read(data->regmap, BMC150_MAGN_REG_TRIM_START,\n\t\t\t       &tregs, sizeof(tregs));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbuffer[AXIS_X] = bmc150_magn_compensate_x(&tregs, raw_x, rhall);\n\tbuffer[AXIS_Y] = bmc150_magn_compensate_y(&tregs, raw_y, rhall);\n\tbuffer[AXIS_Z] = bmc150_magn_compensate_z(&tregs, raw_z, rhall);\n\n\treturn 0;\n}\n\nstatic int bmc150_magn_read_raw(struct iio_dev *indio_dev,\n\t\t\t\tstruct iio_chan_spec const *chan,\n\t\t\t\tint *val, int *val2, long mask)\n{\n\tstruct bmc150_magn_data *data = iio_priv(indio_dev);\n\tint ret, tmp;\n\ts32 values[AXIS_XYZ_MAX];\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (iio_buffer_enabled(indio_dev))\n\t\t\treturn -EBUSY;\n\t\tmutex_lock(&data->mutex);\n\n\t\tret = bmc150_magn_set_power_state(data, true);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = bmc150_magn_read_xyz(data, values);\n\t\tif (ret < 0) {\n\t\t\tbmc150_magn_set_power_state(data, false);\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\t}\n\t\t*val = values[chan->scan_index];\n\n\t\tret = bmc150_magn_set_power_state(data, false);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmutex_unlock(&data->mutex);\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t \n\t\t*val = 0;\n\t\t*val2 = 625;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tret = bmc150_magn_get_odr(data, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tswitch (chan->channel2) {\n\t\tcase IIO_MOD_X:\n\t\tcase IIO_MOD_Y:\n\t\t\tret = regmap_read(data->regmap, BMC150_MAGN_REG_REP_XY,\n\t\t\t\t\t  &tmp);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = BMC150_MAGN_REGVAL_TO_REPXY(tmp);\n\t\t\treturn IIO_VAL_INT;\n\t\tcase IIO_MOD_Z:\n\t\t\tret = regmap_read(data->regmap, BMC150_MAGN_REG_REP_Z,\n\t\t\t\t\t  &tmp);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t*val = BMC150_MAGN_REGVAL_TO_REPZ(tmp);\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bmc150_magn_write_raw(struct iio_dev *indio_dev,\n\t\t\t\t struct iio_chan_spec const *chan,\n\t\t\t\t int val, int val2, long mask)\n{\n\tstruct bmc150_magn_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (val > data->max_odr)\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&data->mutex);\n\t\tret = bmc150_magn_set_odr(data, val);\n\t\tmutex_unlock(&data->mutex);\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\tswitch (chan->channel2) {\n\t\tcase IIO_MOD_X:\n\t\tcase IIO_MOD_Y:\n\t\t\tif (val < 1 || val > 511)\n\t\t\t\treturn -EINVAL;\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tret = bmc150_magn_set_max_odr(data, val, 0, 0);\n\t\t\tif (ret < 0) {\n\t\t\t\tmutex_unlock(&data->mutex);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret = regmap_update_bits(data->regmap,\n\t\t\t\t\t\t BMC150_MAGN_REG_REP_XY,\n\t\t\t\t\t\t BMC150_MAGN_REG_REP_DATAMASK,\n\t\t\t\t\t\t BMC150_MAGN_REPXY_TO_REGVAL\n\t\t\t\t\t\t (val));\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\tcase IIO_MOD_Z:\n\t\t\tif (val < 1 || val > 256)\n\t\t\t\treturn -EINVAL;\n\t\t\tmutex_lock(&data->mutex);\n\t\t\tret = bmc150_magn_set_max_odr(data, 0, val, 0);\n\t\t\tif (ret < 0) {\n\t\t\t\tmutex_unlock(&data->mutex);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret = regmap_update_bits(data->regmap,\n\t\t\t\t\t\t BMC150_MAGN_REG_REP_Z,\n\t\t\t\t\t\t BMC150_MAGN_REG_REP_DATAMASK,\n\t\t\t\t\t\t BMC150_MAGN_REPZ_TO_REGVAL\n\t\t\t\t\t\t (val));\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t bmc150_magn_show_samp_freq_avail(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tchar *buf)\n{\n\tstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\n\tstruct bmc150_magn_data *data = iio_priv(indio_dev);\n\tsize_t len = 0;\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bmc150_magn_samp_freq_table); i++) {\n\t\tif (bmc150_magn_samp_freq_table[i].freq > data->max_odr)\n\t\t\tbreak;\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%d \",\n\t\t\t\t bmc150_magn_samp_freq_table[i].freq);\n\t}\n\t \n\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic const struct iio_mount_matrix *\nbmc150_magn_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\t      const struct iio_chan_spec *chan)\n{\n\tstruct bmc150_magn_data *data = iio_priv(indio_dev);\n\n\treturn &data->orientation;\n}\n\nstatic const struct iio_chan_spec_ext_info bmc150_magn_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_DIR, bmc150_magn_get_mount_matrix),\n\t{ }\n};\n\nstatic IIO_DEV_ATTR_SAMP_FREQ_AVAIL(bmc150_magn_show_samp_freq_avail);\n\nstatic struct attribute *bmc150_magn_attributes[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group bmc150_magn_attrs_group = {\n\t.attrs = bmc150_magn_attributes,\n};\n\n#define BMC150_MAGN_CHANNEL(_axis) {\t\t\t\t\t\\\n\t.type = IIO_MAGN,\t\t\t\t\t\t\\\n\t.modified = 1,\t\t\t\t\t\t\t\\\n\t.channel2 = IIO_MOD_##_axis,\t\t\t\t\t\\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\t\\\n\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\t\\\n\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ) |\t\\\n\t\t\t\t    BIT(IIO_CHAN_INFO_SCALE),\t\t\\\n\t.scan_index = AXIS_##_axis,\t\t\t\t\t\\\n\t.scan_type = {\t\t\t\t\t\t\t\\\n\t\t.sign = 's',\t\t\t\t\t\t\\\n\t\t.realbits = 32,\t\t\t\t\t\t\\\n\t\t.storagebits = 32,\t\t\t\t\t\\\n\t\t.endianness = IIO_LE\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.ext_info = bmc150_magn_ext_info,\t\t\t\t\\\n}\n\nstatic const struct iio_chan_spec bmc150_magn_channels[] = {\n\tBMC150_MAGN_CHANNEL(X),\n\tBMC150_MAGN_CHANNEL(Y),\n\tBMC150_MAGN_CHANNEL(Z),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic const struct iio_info bmc150_magn_info = {\n\t.attrs = &bmc150_magn_attrs_group,\n\t.read_raw = bmc150_magn_read_raw,\n\t.write_raw = bmc150_magn_write_raw,\n};\n\nstatic const unsigned long bmc150_magn_scan_masks[] = {\n\t\t\t\t\tBIT(AXIS_X) | BIT(AXIS_Y) | BIT(AXIS_Z),\n\t\t\t\t\t0};\n\nstatic irqreturn_t bmc150_magn_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tstruct bmc150_magn_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = bmc150_magn_read_xyz(data, data->scan.chans);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t   pf->timestamp);\n\nerr:\n\tmutex_unlock(&data->mutex);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bmc150_magn_init(struct bmc150_magn_data *data)\n{\n\tint ret, chip_id;\n\tstruct bmc150_magn_preset preset;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(data->regulators),\n\t\t\t\t    data->regulators);\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"Failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t \n\tmsleep(5);\n\n\tret = bmc150_magn_set_power_mode(data, BMC150_MAGN_POWER_MODE_SUSPEND,\n\t\t\t\t\t false);\n\tif (ret < 0) {\n\t\tdev_err(data->dev,\n\t\t\t\"Failed to bring up device from suspend mode\\n\");\n\t\tgoto err_regulator_disable;\n\t}\n\n\tret = regmap_read(data->regmap, BMC150_MAGN_REG_CHIP_ID, &chip_id);\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"Failed reading chip id\\n\");\n\t\tgoto err_poweroff;\n\t}\n\tif (chip_id != BMC150_MAGN_CHIP_ID_VAL) {\n\t\tdev_err(data->dev, \"Invalid chip id 0x%x\\n\", chip_id);\n\t\tret = -ENODEV;\n\t\tgoto err_poweroff;\n\t}\n\tdev_dbg(data->dev, \"Chip id %x\\n\", chip_id);\n\n\tpreset = bmc150_magn_presets_table[BMC150_MAGN_DEFAULT_PRESET];\n\tret = bmc150_magn_set_odr(data, preset.odr);\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"Failed to set ODR to %d\\n\",\n\t\t\tpreset.odr);\n\t\tgoto err_poweroff;\n\t}\n\n\tret = regmap_write(data->regmap, BMC150_MAGN_REG_REP_XY,\n\t\t\t   BMC150_MAGN_REPXY_TO_REGVAL(preset.rep_xy));\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"Failed to set REP XY to %d\\n\",\n\t\t\tpreset.rep_xy);\n\t\tgoto err_poweroff;\n\t}\n\n\tret = regmap_write(data->regmap, BMC150_MAGN_REG_REP_Z,\n\t\t\t   BMC150_MAGN_REPZ_TO_REGVAL(preset.rep_z));\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"Failed to set REP Z to %d\\n\",\n\t\t\tpreset.rep_z);\n\t\tgoto err_poweroff;\n\t}\n\n\tret = bmc150_magn_set_max_odr(data, preset.rep_xy, preset.rep_z,\n\t\t\t\t      preset.odr);\n\tif (ret < 0)\n\t\tgoto err_poweroff;\n\n\tret = bmc150_magn_set_power_mode(data, BMC150_MAGN_POWER_MODE_NORMAL,\n\t\t\t\t\t true);\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"Failed to power on device\\n\");\n\t\tgoto err_poweroff;\n\t}\n\n\treturn 0;\n\nerr_poweroff:\n\tbmc150_magn_set_power_mode(data, BMC150_MAGN_POWER_MODE_SUSPEND, true);\nerr_regulator_disable:\n\tregulator_bulk_disable(ARRAY_SIZE(data->regulators), data->regulators);\n\treturn ret;\n}\n\nstatic int bmc150_magn_reset_intr(struct bmc150_magn_data *data)\n{\n\tint tmp;\n\n\t \n\treturn regmap_read(data->regmap, BMC150_MAGN_REG_X_L, &tmp);\n}\n\nstatic void bmc150_magn_trig_reen(struct iio_trigger *trig)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct bmc150_magn_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tif (!data->dready_trigger_on)\n\t\treturn;\n\n\tmutex_lock(&data->mutex);\n\tret = bmc150_magn_reset_intr(data);\n\tmutex_unlock(&data->mutex);\n\tif (ret)\n\t\tdev_err(data->dev, \"Failed to reset interrupt\\n\");\n}\n\nstatic int bmc150_magn_data_rdy_trigger_set_state(struct iio_trigger *trig,\n\t\t\t\t\t\t  bool state)\n{\n\tstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\n\tstruct bmc150_magn_data *data = iio_priv(indio_dev);\n\tint ret = 0;\n\n\tmutex_lock(&data->mutex);\n\tif (state == data->dready_trigger_on)\n\t\tgoto err_unlock;\n\n\tret = regmap_update_bits(data->regmap, BMC150_MAGN_REG_INT_DRDY,\n\t\t\t\t BMC150_MAGN_MASK_DRDY_EN,\n\t\t\t\t state << BMC150_MAGN_SHIFT_DRDY_EN);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\tdata->dready_trigger_on = state;\n\n\tif (state) {\n\t\tret = bmc150_magn_reset_intr(data);\n\t\tif (ret < 0)\n\t\t\tgoto err_unlock;\n\t}\n\tmutex_unlock(&data->mutex);\n\n\treturn 0;\n\nerr_unlock:\n\tmutex_unlock(&data->mutex);\n\treturn ret;\n}\n\nstatic const struct iio_trigger_ops bmc150_magn_trigger_ops = {\n\t.set_trigger_state = bmc150_magn_data_rdy_trigger_set_state,\n\t.reenable = bmc150_magn_trig_reen,\n};\n\nstatic int bmc150_magn_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct bmc150_magn_data *data = iio_priv(indio_dev);\n\n\treturn bmc150_magn_set_power_state(data, true);\n}\n\nstatic int bmc150_magn_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct bmc150_magn_data *data = iio_priv(indio_dev);\n\n\treturn bmc150_magn_set_power_state(data, false);\n}\n\nstatic const struct iio_buffer_setup_ops bmc150_magn_buffer_setup_ops = {\n\t.preenable = bmc150_magn_buffer_preenable,\n\t.postdisable = bmc150_magn_buffer_postdisable,\n};\n\nstatic const char *bmc150_magn_match_acpi_device(struct device *dev)\n{\n\tconst struct acpi_device_id *id;\n\n\tid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\tif (!id)\n\t\treturn NULL;\n\n\treturn dev_name(dev);\n}\n\nint bmc150_magn_probe(struct device *dev, struct regmap *regmap,\n\t\t      int irq, const char *name)\n{\n\tstruct bmc150_magn_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdev_set_drvdata(dev, indio_dev);\n\tdata->regmap = regmap;\n\tdata->irq = irq;\n\tdata->dev = dev;\n\n\tdata->regulators[0].supply = \"vdd\";\n\tdata->regulators[1].supply = \"vddio\";\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(data->regulators),\n\t\t\t\t      data->regulators);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to get regulators\\n\");\n\n\tret = iio_read_mount_matrix(dev, &data->orientation);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!name && ACPI_HANDLE(dev))\n\t\tname = bmc150_magn_match_acpi_device(dev);\n\n\tmutex_init(&data->mutex);\n\n\tret = bmc150_magn_init(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tindio_dev->channels = bmc150_magn_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(bmc150_magn_channels);\n\tindio_dev->available_scan_masks = bmc150_magn_scan_masks;\n\tindio_dev->name = name;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &bmc150_magn_info;\n\n\tif (irq > 0) {\n\t\tdata->dready_trig = devm_iio_trigger_alloc(dev,\n\t\t\t\t\t\t\t   \"%s-dev%d\",\n\t\t\t\t\t\t\t   indio_dev->name,\n\t\t\t\t\t\t\t   iio_device_id(indio_dev));\n\t\tif (!data->dready_trig) {\n\t\t\tret = -ENOMEM;\n\t\t\tdev_err(dev, \"iio trigger alloc failed\\n\");\n\t\t\tgoto err_poweroff;\n\t\t}\n\n\t\tdata->dready_trig->ops = &bmc150_magn_trigger_ops;\n\t\tiio_trigger_set_drvdata(data->dready_trig, indio_dev);\n\t\tret = iio_trigger_register(data->dready_trig);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"iio trigger register failed\\n\");\n\t\t\tgoto err_poweroff;\n\t\t}\n\n\t\tret = request_threaded_irq(irq,\n\t\t\t\t\t   iio_trigger_generic_data_rdy_poll,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t   BMC150_MAGN_IRQ_NAME,\n\t\t\t\t\t   data->dready_trig);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"request irq %d failed\\n\", irq);\n\t\t\tgoto err_trigger_unregister;\n\t\t}\n\t}\n\n\tret = iio_triggered_buffer_setup(indio_dev,\n\t\t\t\t\t iio_pollfunc_store_time,\n\t\t\t\t\t bmc150_magn_trigger_handler,\n\t\t\t\t\t &bmc150_magn_buffer_setup_ops);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"iio triggered buffer setup failed\\n\");\n\t\tgoto err_free_irq;\n\t}\n\n\tret = pm_runtime_set_active(dev);\n\tif (ret)\n\t\tgoto err_buffer_cleanup;\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev,\n\t\t\t\t\t BMC150_MAGN_AUTO_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\n\tret = iio_device_register(indio_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to register iio device\\n\");\n\t\tgoto err_pm_cleanup;\n\t}\n\n\tdev_dbg(dev, \"Registered device %s\\n\", name);\n\treturn 0;\n\nerr_pm_cleanup:\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\nerr_buffer_cleanup:\n\tiio_triggered_buffer_cleanup(indio_dev);\nerr_free_irq:\n\tif (irq > 0)\n\t\tfree_irq(irq, data->dready_trig);\nerr_trigger_unregister:\n\tif (data->dready_trig)\n\t\tiio_trigger_unregister(data->dready_trig);\nerr_poweroff:\n\tbmc150_magn_set_power_mode(data, BMC150_MAGN_POWER_MODE_SUSPEND, true);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS(bmc150_magn_probe, IIO_BMC150_MAGN);\n\nvoid bmc150_magn_remove(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmc150_magn_data *data = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\n\tiio_triggered_buffer_cleanup(indio_dev);\n\n\tif (data->irq > 0)\n\t\tfree_irq(data->irq, data->dready_trig);\n\n\tif (data->dready_trig)\n\t\tiio_trigger_unregister(data->dready_trig);\n\n\tmutex_lock(&data->mutex);\n\tbmc150_magn_set_power_mode(data, BMC150_MAGN_POWER_MODE_SUSPEND, true);\n\tmutex_unlock(&data->mutex);\n\n\tregulator_bulk_disable(ARRAY_SIZE(data->regulators), data->regulators);\n}\nEXPORT_SYMBOL_NS(bmc150_magn_remove, IIO_BMC150_MAGN);\n\n#ifdef CONFIG_PM\nstatic int bmc150_magn_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmc150_magn_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = bmc150_magn_set_power_mode(data, BMC150_MAGN_POWER_MODE_SLEEP,\n\t\t\t\t\t true);\n\tmutex_unlock(&data->mutex);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"powering off device failed\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int bmc150_magn_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmc150_magn_data *data = iio_priv(indio_dev);\n\n\treturn bmc150_magn_set_power_mode(data, BMC150_MAGN_POWER_MODE_NORMAL,\n\t\t\t\t\t  true);\n}\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nstatic int bmc150_magn_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmc150_magn_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = bmc150_magn_set_power_mode(data, BMC150_MAGN_POWER_MODE_SLEEP,\n\t\t\t\t\t true);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n\nstatic int bmc150_magn_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct bmc150_magn_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tmutex_lock(&data->mutex);\n\tret = bmc150_magn_set_power_mode(data, BMC150_MAGN_POWER_MODE_NORMAL,\n\t\t\t\t\t true);\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\n#endif\n\nconst struct dev_pm_ops bmc150_magn_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(bmc150_magn_suspend, bmc150_magn_resume)\n\tSET_RUNTIME_PM_OPS(bmc150_magn_runtime_suspend,\n\t\t\t   bmc150_magn_runtime_resume, NULL)\n};\nEXPORT_SYMBOL_NS(bmc150_magn_pm_ops, IIO_BMC150_MAGN);\n\nMODULE_AUTHOR(\"Irina Tirdea <irina.tirdea@intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"BMC150 magnetometer core driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}