{
  "module_name": "rm3100-core.c",
  "hash_id": "73b86196ba39a306be56e3d4663ce2372fb83364b23d2cd2eac8112997f01d14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/magnetometer/rm3100-core.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/iio/buffer.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/triggered_buffer.h>\n#include <linux/iio/trigger_consumer.h>\n\n#include <asm/unaligned.h>\n\n#include \"rm3100.h\"\n\n \n#define RM3100_REG_CC_X\t\t\t0x05\n#define RM3100_REG_CC_Y\t\t\t0x07\n#define RM3100_REG_CC_Z\t\t\t0x09\n\n \n#define RM3100_REG_POLL\t\t\t0x00\n#define\t\tRM3100_POLL_X\t\tBIT(4)\n#define\t\tRM3100_POLL_Y\t\tBIT(5)\n#define\t\tRM3100_POLL_Z\t\tBIT(6)\n\n \n#define RM3100_REG_CMM\t\t\t0x01\n#define\t\tRM3100_CMM_START\tBIT(0)\n#define\t\tRM3100_CMM_X\t\tBIT(4)\n#define\t\tRM3100_CMM_Y\t\tBIT(5)\n#define\t\tRM3100_CMM_Z\t\tBIT(6)\n\n \n#define RM3100_REG_TMRC\t\t\t0x0B\n#define RM3100_TMRC_OFFSET\t\t0x92\n\n \n#define RM3100_REG_STATUS\t\t0x34\n#define\t\tRM3100_STATUS_DRDY\tBIT(7)\n\n \n#define RM3100_REG_MX2\t\t\t0x24\n#define RM3100_REG_MY2\t\t\t0x27\n#define RM3100_REG_MZ2\t\t\t0x2a\n\n#define RM3100_W_REG_START\t\tRM3100_REG_POLL\n#define RM3100_W_REG_END\t\tRM3100_REG_TMRC\n#define RM3100_R_REG_START\t\tRM3100_REG_POLL\n#define RM3100_R_REG_END\t\tRM3100_REG_STATUS\n#define RM3100_V_REG_START\t\tRM3100_REG_POLL\n#define RM3100_V_REG_END\t\tRM3100_REG_STATUS\n\n \n#define RM3100_SCAN_BYTES\t\t24\n\n#define RM3100_CMM_AXIS_SHIFT\t\t4\n\nstruct rm3100_data {\n\tstruct regmap *regmap;\n\tstruct completion measuring_done;\n\tbool use_interrupt;\n\tint conversion_time;\n\tint scale;\n\t \n\tu8 buffer[RM3100_SCAN_BYTES] __aligned(8);\n\tstruct iio_trigger *drdy_trig;\n\n\t \n\tstruct mutex lock;\n};\n\nstatic const struct regmap_range rm3100_readable_ranges[] = {\n\tregmap_reg_range(RM3100_R_REG_START, RM3100_R_REG_END),\n};\n\nconst struct regmap_access_table rm3100_readable_table = {\n\t.yes_ranges = rm3100_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(rm3100_readable_ranges),\n};\nEXPORT_SYMBOL_NS_GPL(rm3100_readable_table, IIO_RM3100);\n\nstatic const struct regmap_range rm3100_writable_ranges[] = {\n\tregmap_reg_range(RM3100_W_REG_START, RM3100_W_REG_END),\n};\n\nconst struct regmap_access_table rm3100_writable_table = {\n\t.yes_ranges = rm3100_writable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(rm3100_writable_ranges),\n};\nEXPORT_SYMBOL_NS_GPL(rm3100_writable_table, IIO_RM3100);\n\nstatic const struct regmap_range rm3100_volatile_ranges[] = {\n\tregmap_reg_range(RM3100_V_REG_START, RM3100_V_REG_END),\n};\n\nconst struct regmap_access_table rm3100_volatile_table = {\n\t.yes_ranges = rm3100_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(rm3100_volatile_ranges),\n};\nEXPORT_SYMBOL_NS_GPL(rm3100_volatile_table, IIO_RM3100);\n\nstatic irqreturn_t rm3100_thread_fn(int irq, void *d)\n{\n\tstruct iio_dev *indio_dev = d;\n\tstruct rm3100_data *data = iio_priv(indio_dev);\n\n\t \n\tregmap_write(data->regmap, RM3100_REG_POLL, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rm3100_irq_handler(int irq, void *d)\n{\n\tstruct iio_dev *indio_dev = d;\n\tstruct rm3100_data *data = iio_priv(indio_dev);\n\n\tif (!iio_buffer_enabled(indio_dev))\n\t\tcomplete(&data->measuring_done);\n\telse\n\t\tiio_trigger_poll(data->drdy_trig);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic int rm3100_wait_measurement(struct rm3100_data *data)\n{\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int val;\n\tint tries = 20;\n\tint ret;\n\n\t \n\tif (data->use_interrupt)\n\t\treinit_completion(&data->measuring_done);\n\n\tret = regmap_read(regmap, RM3100_REG_STATUS, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((val & RM3100_STATUS_DRDY) != RM3100_STATUS_DRDY) {\n\t\tif (data->use_interrupt) {\n\t\t\tret = wait_for_completion_timeout(&data->measuring_done,\n\t\t\t\tmsecs_to_jiffies(data->conversion_time));\n\t\t\tif (!ret)\n\t\t\t\treturn -ETIMEDOUT;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tusleep_range(1000, 5000);\n\n\t\t\t\tret = regmap_read(regmap, RM3100_REG_STATUS,\n\t\t\t\t\t\t  &val);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tif (val & RM3100_STATUS_DRDY)\n\t\t\t\t\tbreak;\n\t\t\t} while (--tries);\n\t\t\tif (!tries)\n\t\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int rm3100_read_mag(struct rm3100_data *data, int idx, int *val)\n{\n\tstruct regmap *regmap = data->regmap;\n\tu8 buffer[3];\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = regmap_write(regmap, RM3100_REG_POLL, BIT(4 + idx));\n\tif (ret < 0)\n\t\tgoto unlock_return;\n\n\tret = rm3100_wait_measurement(data);\n\tif (ret < 0)\n\t\tgoto unlock_return;\n\n\tret = regmap_bulk_read(regmap, RM3100_REG_MX2 + 3 * idx, buffer, 3);\n\tif (ret < 0)\n\t\tgoto unlock_return;\n\tmutex_unlock(&data->lock);\n\n\t*val = sign_extend32(get_unaligned_be24(&buffer[0]), 23);\n\n\treturn IIO_VAL_INT;\n\nunlock_return:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\n#define RM3100_CHANNEL(axis, idx)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_MAGN,\t\t\t\t\t\\\n\t\t.modified = 1,\t\t\t\t\t\t\\\n\t\t.channel2 = IIO_MOD_##axis,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\t\t\\\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SAMP_FREQ),\t\t\t\\\n\t\t.scan_index = idx,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\t\\\n\t\t\t.realbits = 24,\t\t\t\t\t\\\n\t\t\t.storagebits = 32,\t\t\t\t\\\n\t\t\t.shift = 8,\t\t\t\t\t\\\n\t\t\t.endianness = IIO_BE,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec rm3100_channels[] = {\n\tRM3100_CHANNEL(X, 0),\n\tRM3100_CHANNEL(Y, 1),\n\tRM3100_CHANNEL(Z, 2),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic IIO_CONST_ATTR_SAMP_FREQ_AVAIL(\n\t\"600 300 150 75 37 18 9 4.5 2.3 1.2 0.6 0.3 0.015 0.075\"\n);\n\nstatic struct attribute *rm3100_attributes[] = {\n\t&iio_const_attr_sampling_frequency_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group rm3100_attribute_group = {\n\t.attrs = rm3100_attributes,\n};\n\n#define RM3100_SAMP_NUM\t\t\t14\n\n \nstatic const int rm3100_samp_rates[RM3100_SAMP_NUM][3] = {\n\t{600, 0, 2}, {300, 0, 3}, {150, 0, 7}, {75, 0, 13}, {37, 0, 27},\n\t{18, 0, 55}, {9, 0, 110}, {4, 500000, 220}, {2, 300000, 440},\n\t{1, 200000, 800}, {0, 600000, 1600}, {0, 300000, 3300},\n\t{0, 15000, 6700},  {0, 75000, 13000}\n};\n\nstatic int rm3100_get_samp_freq(struct rm3100_data *data, int *val, int *val2)\n{\n\tunsigned int tmp;\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\tret = regmap_read(data->regmap, RM3100_REG_TMRC, &tmp);\n\tmutex_unlock(&data->lock);\n\tif (ret < 0)\n\t\treturn ret;\n\t*val = rm3100_samp_rates[tmp - RM3100_TMRC_OFFSET][0];\n\t*val2 = rm3100_samp_rates[tmp - RM3100_TMRC_OFFSET][1];\n\n\treturn IIO_VAL_INT_PLUS_MICRO;\n}\n\nstatic int rm3100_set_cycle_count(struct rm3100_data *data, int val)\n{\n\tint ret;\n\tu8 i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = regmap_write(data->regmap, RM3100_REG_CC_X + 2 * i, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tswitch (val) {\n\tcase 50:\n\t\tdata->scale = 500;\n\t\tbreak;\n\tcase 100:\n\t\tdata->scale = 263;\n\t\tbreak;\n\t \n\tdefault:\n\t\tdata->scale = 133;\n\t}\n\n\treturn 0;\n}\n\nstatic int rm3100_set_samp_freq(struct iio_dev *indio_dev, int val, int val2)\n{\n\tstruct rm3100_data *data = iio_priv(indio_dev);\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int cycle_count;\n\tint ret;\n\tint i;\n\n\tmutex_lock(&data->lock);\n\t \n\tret = regmap_read(regmap, RM3100_REG_CC_X, &cycle_count);\n\tif (ret < 0)\n\t\tgoto unlock_return;\n\n\tfor (i = 0; i < RM3100_SAMP_NUM; i++) {\n\t\tif (val == rm3100_samp_rates[i][0] &&\n\t\t    val2 == rm3100_samp_rates[i][1])\n\t\t\tbreak;\n\t}\n\tif (i == RM3100_SAMP_NUM) {\n\t\tret = -EINVAL;\n\t\tgoto unlock_return;\n\t}\n\n\tret = regmap_write(regmap, RM3100_REG_TMRC, i + RM3100_TMRC_OFFSET);\n\tif (ret < 0)\n\t\tgoto unlock_return;\n\n\t \n\tif (val == 600 && cycle_count == 200) {\n\t\tret = rm3100_set_cycle_count(data, 100);\n\t\tif (ret < 0)\n\t\t\tgoto unlock_return;\n\t} else if (val != 600 && cycle_count == 100) {\n\t\tret = rm3100_set_cycle_count(data, 200);\n\t\tif (ret < 0)\n\t\t\tgoto unlock_return;\n\t}\n\n\tif (iio_buffer_enabled(indio_dev)) {\n\t\t \n\t\tret = regmap_write(regmap, RM3100_REG_CMM, 0);\n\t\tif (ret < 0)\n\t\t\tgoto unlock_return;\n\t\tret = regmap_write(data->regmap, RM3100_REG_CMM,\n\t\t\t(*indio_dev->active_scan_mask & 0x7) <<\n\t\t\tRM3100_CMM_AXIS_SHIFT | RM3100_CMM_START);\n\t\tif (ret < 0)\n\t\t\tgoto unlock_return;\n\t}\n\tmutex_unlock(&data->lock);\n\n\tdata->conversion_time = rm3100_samp_rates[i][2] * 2;\n\treturn 0;\n\nunlock_return:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int rm3100_read_raw(struct iio_dev *indio_dev,\n\t\t\t   const struct iio_chan_spec *chan,\n\t\t\t   int *val, int *val2, long mask)\n{\n\tstruct rm3100_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = iio_device_claim_direct_mode(indio_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = rm3100_read_mag(data, chan->scan_index, val);\n\t\tiio_device_release_direct_mode(indio_dev);\n\n\t\treturn ret;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = data->scale;\n\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn rm3100_get_samp_freq(data, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rm3100_write_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int val, int val2, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\treturn rm3100_set_samp_freq(indio_dev, val, val2);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct iio_info rm3100_info = {\n\t.attrs = &rm3100_attribute_group,\n\t.read_raw = rm3100_read_raw,\n\t.write_raw = rm3100_write_raw,\n};\n\nstatic int rm3100_buffer_preenable(struct iio_dev *indio_dev)\n{\n\tstruct rm3100_data *data = iio_priv(indio_dev);\n\n\t \n\treturn regmap_write(data->regmap, RM3100_REG_CMM,\n\t\t(*indio_dev->active_scan_mask & 0x7) << RM3100_CMM_AXIS_SHIFT |\n\t\tRM3100_CMM_START);\n}\n\nstatic int rm3100_buffer_postdisable(struct iio_dev *indio_dev)\n{\n\tstruct rm3100_data *data = iio_priv(indio_dev);\n\n\treturn regmap_write(data->regmap, RM3100_REG_CMM, 0);\n}\n\nstatic const struct iio_buffer_setup_ops rm3100_buffer_ops = {\n\t.preenable = rm3100_buffer_preenable,\n\t.postdisable = rm3100_buffer_postdisable,\n};\n\nstatic irqreturn_t rm3100_trigger_handler(int irq, void *p)\n{\n\tstruct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\tunsigned long scan_mask = *indio_dev->active_scan_mask;\n\tunsigned int mask_len = indio_dev->masklength;\n\tstruct rm3100_data *data = iio_priv(indio_dev);\n\tstruct regmap *regmap = data->regmap;\n\tint ret, i, bit;\n\n\tmutex_lock(&data->lock);\n\tswitch (scan_mask) {\n\tcase BIT(0) | BIT(1) | BIT(2):\n\t\tret = regmap_bulk_read(regmap, RM3100_REG_MX2, data->buffer, 9);\n\t\tmutex_unlock(&data->lock);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\t \n\t\tfor (i = 2; i > 0; i--)\n\t\t\tmemmove(data->buffer + i * 4, data->buffer + i * 3, 3);\n\t\tbreak;\n\tcase BIT(0) | BIT(1):\n\t\tret = regmap_bulk_read(regmap, RM3100_REG_MX2, data->buffer, 6);\n\t\tmutex_unlock(&data->lock);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tmemmove(data->buffer + 4, data->buffer + 3, 3);\n\t\tbreak;\n\tcase BIT(1) | BIT(2):\n\t\tret = regmap_bulk_read(regmap, RM3100_REG_MY2, data->buffer, 6);\n\t\tmutex_unlock(&data->lock);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tmemmove(data->buffer + 4, data->buffer + 3, 3);\n\t\tbreak;\n\tcase BIT(0) | BIT(2):\n\t\tret = regmap_bulk_read(regmap, RM3100_REG_MX2, data->buffer, 9);\n\t\tmutex_unlock(&data->lock);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tmemmove(data->buffer + 4, data->buffer + 6, 3);\n\t\tbreak;\n\tdefault:\n\t\tfor_each_set_bit(bit, &scan_mask, mask_len) {\n\t\t\tret = regmap_bulk_read(regmap, RM3100_REG_MX2 + 3 * bit,\n\t\t\t\t\t       data->buffer, 3);\n\t\t\tif (ret < 0) {\n\t\t\t\tmutex_unlock(&data->lock);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&data->lock);\n\t}\n\t \n\tiio_push_to_buffers_with_timestamp(indio_dev, data->buffer,\n\t\t\t\t\t   pf->timestamp);\ndone:\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nint rm3100_common_probe(struct device *dev, struct regmap *regmap, int irq)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct rm3100_data *data;\n\tunsigned int tmp;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->regmap = regmap;\n\n\tmutex_init(&data->lock);\n\n\tindio_dev->name = \"rm3100\";\n\tindio_dev->info = &rm3100_info;\n\tindio_dev->channels = rm3100_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(rm3100_channels);\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\n\tif (!irq)\n\t\tdata->use_interrupt = false;\n\telse {\n\t\tdata->use_interrupt = true;\n\n\t\tinit_completion(&data->measuring_done);\n\t\tret = devm_request_threaded_irq(dev,\n\t\t\t\t\t\tirq,\n\t\t\t\t\t\trm3100_irq_handler,\n\t\t\t\t\t\trm3100_thread_fn,\n\t\t\t\t\t\tIRQF_TRIGGER_HIGH |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tindio_dev->name,\n\t\t\t\t\t\tindio_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"request irq line failed.\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->drdy_trig = devm_iio_trigger_alloc(dev, \"%s-drdy%d\",\n\t\t\t\t\t\t\t indio_dev->name,\n\t\t\t\t\t\t\t iio_device_id(indio_dev));\n\t\tif (!data->drdy_trig)\n\t\t\treturn -ENOMEM;\n\n\t\tret = devm_iio_trigger_register(dev, data->drdy_trig);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_iio_triggered_buffer_setup(dev, indio_dev,\n\t\t\t\t\t      &iio_pollfunc_store_time,\n\t\t\t\t\t      rm3100_trigger_handler,\n\t\t\t\t\t      &rm3100_buffer_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(regmap, RM3100_REG_TMRC, &tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tdata->conversion_time = rm3100_samp_rates[tmp - RM3100_TMRC_OFFSET][2]\n\t\t\t\t* 2;\n\n\t \n\tif ((tmp - RM3100_TMRC_OFFSET) == 0)\n\t\trm3100_set_cycle_count(data, 100);\n\telse\n\t\trm3100_set_cycle_count(data, 200);\n\n\treturn devm_iio_device_register(dev, indio_dev);\n}\nEXPORT_SYMBOL_NS_GPL(rm3100_common_probe, IIO_RM3100);\n\nMODULE_AUTHOR(\"Song Qiang <songqiang1304521@gmail.com>\");\nMODULE_DESCRIPTION(\"PNI RM3100 3-axis magnetometer i2c driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}