{
  "module_name": "ak8974.c",
  "hash_id": "43b05cdd780f29056cfe0931890856d624cdb5d9a7a5af6846a726bb98cbf0b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/magnetometer/ak8974.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/kernel.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>  \n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n#include <linux/random.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_runtime.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n \n\n \n#define AK8974_SELFTEST\t\t0x0C\n#define AK8974_SELFTEST_IDLE\t0x55\n#define AK8974_SELFTEST_OK\t0xAA\n\n#define AK8974_INFO\t\t0x0D\n\n#define AK8974_WHOAMI\t\t0x0F\n#define AK8974_WHOAMI_VALUE_AMI306 0x46\n#define AK8974_WHOAMI_VALUE_AMI305 0x47\n#define AK8974_WHOAMI_VALUE_AK8974 0x48\n#define AK8974_WHOAMI_VALUE_HSCDTD008A 0x49\n\n#define AK8974_DATA_X\t\t0x10\n#define AK8974_DATA_Y\t\t0x12\n#define AK8974_DATA_Z\t\t0x14\n#define AK8974_INT_SRC\t\t0x16\n#define AK8974_STATUS\t\t0x18\n#define AK8974_INT_CLEAR\t0x1A\n#define AK8974_CTRL1\t\t0x1B\n#define AK8974_CTRL2\t\t0x1C\n#define AK8974_CTRL3\t\t0x1D\n#define AK8974_INT_CTRL\t\t0x1E\n#define AK8974_INT_THRES\t0x26   \n#define AK8974_PRESET\t\t0x30\n\n \n#define AK8974_OFFSET_X\t\t0x20\n#define AK8974_OFFSET_Y\t\t0x22\n#define AK8974_OFFSET_Z\t\t0x24\n \n#define AMI305_OFFSET_X\t\t0x6C\n#define AMI305_OFFSET_Y\t\t0x72\n#define AMI305_OFFSET_Z\t\t0x78\n\n \n#define AK8974_TEMP\t\t0x31\n#define AMI305_TEMP\t\t0x60\n\n \n#define AMI306_CTRL4\t\t0x5C\n\n \n\n \n#define AMI306_FINEOUTPUT_X\t0x90\n#define AMI306_FINEOUTPUT_Y\t0x92\n#define AMI306_FINEOUTPUT_Z\t0x94\n\n \n#define AMI306_SENS_X\t\t0x96\n#define AMI306_SENS_Y\t\t0x98\n#define AMI306_SENS_Z\t\t0x9A\n\n \n#define AMI306_GAIN_PARA_XZ\t0x9C\n#define AMI306_GAIN_PARA_XY\t0x9D\n#define AMI306_GAIN_PARA_YZ\t0x9E\n#define AMI306_GAIN_PARA_YX\t0x9F\n#define AMI306_GAIN_PARA_ZY\t0xA0\n#define AMI306_GAIN_PARA_ZX\t0xA1\n\n \n#define AMI306_OFFZERO_X\t0xF8\n#define AMI306_OFFZERO_Y\t0xFA\n#define AMI306_OFFZERO_Z\t0xFC\n\n\n#define AK8974_INT_X_HIGH\tBIT(7)  \n#define AK8974_INT_Y_HIGH\tBIT(6)\n#define AK8974_INT_Z_HIGH\tBIT(5)\n#define AK8974_INT_X_LOW\tBIT(4)  \n#define AK8974_INT_Y_LOW\tBIT(3)\n#define AK8974_INT_Z_LOW\tBIT(2)\n#define AK8974_INT_RANGE\tBIT(1)  \n\n#define AK8974_STATUS_DRDY\tBIT(6)  \n#define AK8974_STATUS_OVERRUN\tBIT(5)  \n#define AK8974_STATUS_INT\tBIT(4)  \n\n#define AK8974_CTRL1_POWER\tBIT(7)  \n#define AK8974_CTRL1_RATE\tBIT(4)  \n#define AK8974_CTRL1_FORCE_EN\tBIT(1)  \n#define AK8974_CTRL1_MODE2\tBIT(0)  \n\n#define AK8974_CTRL2_INT_EN\tBIT(4)   \n#define AK8974_CTRL2_DRDY_EN\tBIT(3)   \n#define AK8974_CTRL2_DRDY_POL\tBIT(2)   \n#define AK8974_CTRL2_RESDEF\t(AK8974_CTRL2_DRDY_POL)\n\n#define AK8974_CTRL3_RESET\tBIT(7)  \n#define AK8974_CTRL3_FORCE\tBIT(6)  \n#define AK8974_CTRL3_SELFTEST\tBIT(4)  \n#define AK8974_CTRL3_RESDEF\t0x00\n\n#define AK8974_INT_CTRL_XEN\tBIT(7)  \n#define AK8974_INT_CTRL_YEN\tBIT(6)\n#define AK8974_INT_CTRL_ZEN\tBIT(5)\n#define AK8974_INT_CTRL_XYZEN\t(BIT(7)|BIT(6)|BIT(5))\n#define AK8974_INT_CTRL_POL\tBIT(3)  \n#define AK8974_INT_CTRL_PULSE\tBIT(1)  \n#define AK8974_INT_CTRL_RESDEF\t(AK8974_INT_CTRL_XYZEN | AK8974_INT_CTRL_POL)\n\n \n#define HSCDTD008A_CTRL4\t0x1E\n#define HSCDTD008A_CTRL4_MMD\tBIT(7)\t \n#define HSCDTD008A_CTRL4_RANGE\tBIT(4)\t \n#define HSCDTD008A_CTRL4_RESDEF\t(HSCDTD008A_CTRL4_MMD | HSCDTD008A_CTRL4_RANGE)\n\n \n#define AMI305_VER\t\t0xE8\n#define AMI305_SN\t\t0xEA\n\n#define AK8974_MAX_RANGE\t2048\n\n#define AK8974_POWERON_DELAY\t50\n#define AK8974_ACTIVATE_DELAY\t1\n#define AK8974_SELFTEST_DELAY\t1\n \n#define AK8974_AUTOSUSPEND_DELAY 5000\n\n#define AK8974_MEASTIME\t\t3\n\n#define AK8974_PWR_ON\t\t1\n#define AK8974_PWR_OFF\t\t0\n\n \nstruct ak8974 {\n\tstruct i2c_client *i2c;\n\tstruct iio_mount_matrix orientation;\n\tstruct regmap *map;\n\tstruct regulator_bulk_data regs[2];\n\tconst char *name;\n\tu8 variant;\n\tstruct mutex lock;\n\tbool drdy_irq;\n\tstruct completion drdy_complete;\n\tbool drdy_active_low;\n\t \n\tstruct {\n\t\t__le16 channels[3];\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\nstatic const char ak8974_reg_avdd[] = \"avdd\";\nstatic const char ak8974_reg_dvdd[] = \"dvdd\";\n\nstatic int ak8974_get_u16_val(struct ak8974 *ak8974, u8 reg, u16 *val)\n{\n\tint ret;\n\t__le16 bulk;\n\n\tret = regmap_bulk_read(ak8974->map, reg, &bulk, 2);\n\tif (ret)\n\t\treturn ret;\n\t*val = le16_to_cpu(bulk);\n\n\treturn 0;\n}\n\nstatic int ak8974_set_u16_val(struct ak8974 *ak8974, u8 reg, u16 val)\n{\n\t__le16 bulk = cpu_to_le16(val);\n\n\treturn regmap_bulk_write(ak8974->map, reg, &bulk, 2);\n}\n\nstatic int ak8974_set_power(struct ak8974 *ak8974, bool mode)\n{\n\tint ret;\n\tu8 val;\n\n\tval = mode ? AK8974_CTRL1_POWER : 0;\n\tval |= AK8974_CTRL1_FORCE_EN;\n\tret = regmap_write(ak8974->map, AK8974_CTRL1, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (mode)\n\t\tmsleep(AK8974_ACTIVATE_DELAY);\n\n\treturn 0;\n}\n\nstatic int ak8974_reset(struct ak8974 *ak8974)\n{\n\tint ret;\n\n\t \n\tret = ak8974_set_power(ak8974, AK8974_PWR_ON);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(ak8974->map, AK8974_CTRL2, AK8974_CTRL2_RESDEF);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(ak8974->map, AK8974_CTRL3, AK8974_CTRL3_RESDEF);\n\tif (ret)\n\t\treturn ret;\n\tif (ak8974->variant != AK8974_WHOAMI_VALUE_HSCDTD008A) {\n\t\tret = regmap_write(ak8974->map, AK8974_INT_CTRL,\n\t\t\t\t   AK8974_INT_CTRL_RESDEF);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = regmap_write(ak8974->map, HSCDTD008A_CTRL4,\n\t\t\t\t   HSCDTD008A_CTRL4_RESDEF);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\treturn ak8974_set_power(ak8974, AK8974_PWR_OFF);\n}\n\nstatic int ak8974_configure(struct ak8974 *ak8974)\n{\n\tint ret;\n\n\tret = regmap_write(ak8974->map, AK8974_CTRL2, AK8974_CTRL2_DRDY_EN |\n\t\t\t   AK8974_CTRL2_INT_EN);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(ak8974->map, AK8974_CTRL3, 0);\n\tif (ret)\n\t\treturn ret;\n\tif (ak8974->variant == AK8974_WHOAMI_VALUE_AMI306) {\n\t\t \n\t\tret = ak8974_set_u16_val(ak8974, AMI306_CTRL4, 0xA07E);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (ak8974->variant == AK8974_WHOAMI_VALUE_HSCDTD008A)\n\t\treturn 0;\n\tret = regmap_write(ak8974->map, AK8974_INT_CTRL, AK8974_INT_CTRL_POL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(ak8974->map, AK8974_PRESET, 0);\n}\n\nstatic int ak8974_trigmeas(struct ak8974 *ak8974)\n{\n\tunsigned int clear;\n\tu8 mask;\n\tu8 val;\n\tint ret;\n\n\t \n\tret = regmap_read(ak8974->map, AK8974_INT_CLEAR, &clear);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ak8974->drdy_irq) {\n\t\tmask = AK8974_CTRL2_INT_EN |\n\t\t\tAK8974_CTRL2_DRDY_EN |\n\t\t\tAK8974_CTRL2_DRDY_POL;\n\t\tval = AK8974_CTRL2_DRDY_EN;\n\n\t\tif (!ak8974->drdy_active_low)\n\t\t\tval |= AK8974_CTRL2_DRDY_POL;\n\n\t\tinit_completion(&ak8974->drdy_complete);\n\t\tret = regmap_update_bits(ak8974->map, AK8974_CTRL2,\n\t\t\t\t\t mask, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\treturn regmap_update_bits(ak8974->map,\n\t\t\t\t  AK8974_CTRL3,\n\t\t\t\t  AK8974_CTRL3_FORCE,\n\t\t\t\t  AK8974_CTRL3_FORCE);\n}\n\nstatic int ak8974_await_drdy(struct ak8974 *ak8974)\n{\n\tint timeout = 2;\n\tunsigned int val;\n\tint ret;\n\n\tif (ak8974->drdy_irq) {\n\t\tret = wait_for_completion_timeout(&ak8974->drdy_complete,\n\t\t\t\t\t1 + msecs_to_jiffies(1000));\n\t\tif (!ret) {\n\t\t\tdev_err(&ak8974->i2c->dev,\n\t\t\t\t\"timeout waiting for DRDY IRQ\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tdo {\n\t\tmsleep(AK8974_MEASTIME);\n\t\tret = regmap_read(ak8974->map, AK8974_STATUS, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (val & AK8974_STATUS_DRDY)\n\t\t\treturn 0;\n\t} while (--timeout);\n\n\tdev_err(&ak8974->i2c->dev, \"timeout waiting for DRDY\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int ak8974_getresult(struct ak8974 *ak8974, __le16 *result)\n{\n\tunsigned int src;\n\tint ret;\n\n\tret = ak8974_await_drdy(ak8974);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_read(ak8974->map, AK8974_INT_SRC, &src);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (src & AK8974_INT_RANGE) {\n\t\tdev_err(&ak8974->i2c->dev,\n\t\t\t\"range overflow in sensor\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\tret = regmap_bulk_read(ak8974->map, AK8974_DATA_X, result, 6);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic irqreturn_t ak8974_drdy_irq(int irq, void *d)\n{\n\tstruct ak8974 *ak8974 = d;\n\n\tif (!ak8974->drdy_irq)\n\t\treturn IRQ_NONE;\n\n\t \n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t ak8974_drdy_irq_thread(int irq, void *d)\n{\n\tstruct ak8974 *ak8974 = d;\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_read(ak8974->map, AK8974_STATUS, &val);\n\tif (ret < 0) {\n\t\tdev_err(&ak8974->i2c->dev, \"error reading DRDY status\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\tif (val & AK8974_STATUS_DRDY) {\n\t\t \n\t\tcomplete(&ak8974->drdy_complete);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\treturn IRQ_NONE;\n}\n\nstatic int ak8974_selftest(struct ak8974 *ak8974)\n{\n\tstruct device *dev = &ak8974->i2c->dev;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(ak8974->map, AK8974_SELFTEST, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val != AK8974_SELFTEST_IDLE) {\n\t\tdev_err(dev, \"selftest not idle before test\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tret = regmap_update_bits(ak8974->map,\n\t\t\tAK8974_CTRL3,\n\t\t\tAK8974_CTRL3_SELFTEST,\n\t\t\tAK8974_CTRL3_SELFTEST);\n\tif (ret) {\n\t\tdev_err(dev, \"could not write CTRL3\\n\");\n\t\treturn ret;\n\t}\n\n\tmsleep(AK8974_SELFTEST_DELAY);\n\n\tret = regmap_read(ak8974->map, AK8974_SELFTEST, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val != AK8974_SELFTEST_OK) {\n\t\tdev_err(dev, \"selftest result NOT OK (%02x)\\n\", val);\n\t\treturn -EIO;\n\t}\n\n\tret = regmap_read(ak8974->map, AK8974_SELFTEST, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val != AK8974_SELFTEST_IDLE) {\n\t\tdev_err(dev, \"selftest not idle after test (%02x)\\n\", val);\n\t\treturn -EIO;\n\t}\n\tdev_dbg(dev, \"passed self-test\\n\");\n\n\treturn 0;\n}\n\nstatic void ak8974_read_calib_data(struct ak8974 *ak8974, unsigned int reg,\n\t\t\t\t   __le16 *tab, size_t tab_size)\n{\n\tint ret = regmap_bulk_read(ak8974->map, reg, tab, tab_size);\n\tif (ret) {\n\t\tmemset(tab, 0xFF, tab_size);\n\t\tdev_warn(&ak8974->i2c->dev,\n\t\t\t \"can't read calibration data (regs %u..%zu): %d\\n\",\n\t\t\t reg, reg + tab_size - 1, ret);\n\t} else {\n\t\tadd_device_randomness(tab, tab_size);\n\t}\n}\n\nstatic int ak8974_detect(struct ak8974 *ak8974)\n{\n\tunsigned int whoami;\n\tconst char *name;\n\tint ret;\n\tunsigned int fw;\n\tu16 sn;\n\n\tret = regmap_read(ak8974->map, AK8974_WHOAMI, &whoami);\n\tif (ret)\n\t\treturn ret;\n\n\tname = \"ami305\";\n\n\tswitch (whoami) {\n\tcase AK8974_WHOAMI_VALUE_AMI306:\n\t\tname = \"ami306\";\n\t\tfallthrough;\n\tcase AK8974_WHOAMI_VALUE_AMI305:\n\t\tret = regmap_read(ak8974->map, AMI305_VER, &fw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tfw &= 0x7f;  \n\t\tret = ak8974_get_u16_val(ak8974, AMI305_SN, &sn);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tadd_device_randomness(&sn, sizeof(sn));\n\t\tdev_info(&ak8974->i2c->dev,\n\t\t\t \"detected %s, FW ver %02x, S/N: %04x\\n\",\n\t\t\t name, fw, sn);\n\t\tbreak;\n\tcase AK8974_WHOAMI_VALUE_AK8974:\n\t\tname = \"ak8974\";\n\t\tdev_info(&ak8974->i2c->dev, \"detected AK8974\\n\");\n\t\tbreak;\n\tcase AK8974_WHOAMI_VALUE_HSCDTD008A:\n\t\tname = \"hscdtd008a\";\n\t\tdev_info(&ak8974->i2c->dev, \"detected hscdtd008a\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&ak8974->i2c->dev, \"unsupported device (%02x) \",\n\t\t\twhoami);\n\t\treturn -ENODEV;\n\t}\n\n\tak8974->name = name;\n\tak8974->variant = whoami;\n\n\tif (whoami == AK8974_WHOAMI_VALUE_AMI306) {\n\t\t__le16 fab_data1[9], fab_data2[3];\n\t\tint i;\n\n\t\tak8974_read_calib_data(ak8974, AMI306_FINEOUTPUT_X,\n\t\t\t\t       fab_data1, sizeof(fab_data1));\n\t\tak8974_read_calib_data(ak8974, AMI306_OFFZERO_X,\n\t\t\t\t       fab_data2, sizeof(fab_data2));\n\n\t\tfor (i = 0; i < 3; ++i) {\n\t\t\tstatic const char axis[3] = \"XYZ\";\n\t\t\tstatic const char pgaxis[6] = \"ZYZXYX\";\n\t\t\tunsigned offz = le16_to_cpu(fab_data2[i]) & 0x7F;\n\t\t\tunsigned fine = le16_to_cpu(fab_data1[i]);\n\t\t\tunsigned sens = le16_to_cpu(fab_data1[i + 3]);\n\t\t\tunsigned pgain1 = le16_to_cpu(fab_data1[i + 6]);\n\t\t\tunsigned pgain2 = pgain1 >> 8;\n\n\t\t\tpgain1 &= 0xFF;\n\n\t\t\tdev_info(&ak8974->i2c->dev,\n\t\t\t\t \"factory calibration for axis %c: offz=%u sens=%u fine=%u pga%c=%u pga%c=%u\\n\",\n\t\t\t\t axis[i], offz, sens, fine, pgaxis[i * 2],\n\t\t\t\t pgain1, pgaxis[i * 2 + 1], pgain2);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ak8974_measure_channel(struct ak8974 *ak8974, unsigned long address,\n\t\t\t\t  int *val)\n{\n\t__le16 hw_values[3];\n\tint ret;\n\n\tpm_runtime_get_sync(&ak8974->i2c->dev);\n\tmutex_lock(&ak8974->lock);\n\n\t \n\tret = ak8974_trigmeas(ak8974);\n\tif (ret)\n\t\tgoto out_unlock;\n\tret = ak8974_getresult(ak8974, hw_values);\n\tif (ret)\n\t\tgoto out_unlock;\n\t \n\t*val = (s16)le16_to_cpu(hw_values[address]);\nout_unlock:\n\tmutex_unlock(&ak8974->lock);\n\tpm_runtime_mark_last_busy(&ak8974->i2c->dev);\n\tpm_runtime_put_autosuspend(&ak8974->i2c->dev);\n\n\treturn ret;\n}\n\nstatic int ak8974_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2,\n\t\t\t   long mask)\n{\n\tstruct ak8974 *ak8974 = iio_priv(indio_dev);\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tif (chan->address > 2) {\n\t\t\tdev_err(&ak8974->i2c->dev, \"faulty channel address\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tret = ak8974_measure_channel(ak8974, chan->address, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (ak8974->variant) {\n\t\tcase AK8974_WHOAMI_VALUE_AMI306:\n\t\tcase AK8974_WHOAMI_VALUE_AMI305:\n\t\t\t \n\t\t\t*val = 12;\n\t\t\t \n\t\t\t*val2 = 11;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\tcase AK8974_WHOAMI_VALUE_HSCDTD008A:\n\t\t\t \n\t\t\t*val = 24;\n\t\t\t \n\t\t\t*val2 = 14;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\tdefault:\n\t\t\t \n\t\t\t*val = 12;\n\t\t\t \n\t\t\t*val2 = 11;\n\t\t\treturn IIO_VAL_FRACTIONAL_LOG2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void ak8974_fill_buffer(struct iio_dev *indio_dev)\n{\n\tstruct ak8974 *ak8974 = iio_priv(indio_dev);\n\tint ret;\n\n\tpm_runtime_get_sync(&ak8974->i2c->dev);\n\tmutex_lock(&ak8974->lock);\n\n\tret = ak8974_trigmeas(ak8974);\n\tif (ret) {\n\t\tdev_err(&ak8974->i2c->dev, \"error triggering measure\\n\");\n\t\tgoto out_unlock;\n\t}\n\tret = ak8974_getresult(ak8974, ak8974->scan.channels);\n\tif (ret) {\n\t\tdev_err(&ak8974->i2c->dev, \"error getting measures\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &ak8974->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\n out_unlock:\n\tmutex_unlock(&ak8974->lock);\n\tpm_runtime_mark_last_busy(&ak8974->i2c->dev);\n\tpm_runtime_put_autosuspend(&ak8974->i2c->dev);\n}\n\nstatic irqreturn_t ak8974_handle_trigger(int irq, void *p)\n{\n\tconst struct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\n\tak8974_fill_buffer(indio_dev);\n\tiio_trigger_notify_done(indio_dev->trig);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct iio_mount_matrix *\nak8974_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\tconst struct iio_chan_spec *chan)\n{\n\tstruct ak8974 *ak8974 = iio_priv(indio_dev);\n\n\treturn &ak8974->orientation;\n}\n\nstatic const struct iio_chan_spec_ext_info ak8974_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_DIR, ak8974_get_mount_matrix),\n\t{ },\n};\n\n#define AK8974_AXIS_CHANNEL(axis, index, bits)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_MAGN,\t\t\t\t\t\\\n\t\t.modified = 1,\t\t\t\t\t\t\\\n\t\t.channel2 = IIO_MOD_##axis,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\t\tBIT(IIO_CHAN_INFO_SCALE),\t\t\t\\\n\t\t.ext_info = ak8974_ext_info,\t\t\t\t\\\n\t\t.address = index,\t\t\t\t\t\\\n\t\t.scan_index = index,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\t\\\n\t\t\t.realbits = bits,\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.endianness = IIO_LE\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\n \nstatic const struct iio_chan_spec ak8974_12_bits_channels[] = {\n\tAK8974_AXIS_CHANNEL(X, 0, 12),\n\tAK8974_AXIS_CHANNEL(Y, 1, 12),\n\tAK8974_AXIS_CHANNEL(Z, 2, 12),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\n \nstatic const struct iio_chan_spec ak8974_15_bits_channels[] = {\n\tAK8974_AXIS_CHANNEL(X, 0, 15),\n\tAK8974_AXIS_CHANNEL(Y, 1, 15),\n\tAK8974_AXIS_CHANNEL(Z, 2, 15),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic const unsigned long ak8974_scan_masks[] = { 0x7, 0 };\n\nstatic const struct iio_info ak8974_info = {\n\t.read_raw = &ak8974_read_raw,\n};\n\nstatic bool ak8974_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(i2c);\n\tstruct ak8974 *ak8974 = iio_priv(indio_dev);\n\n\tswitch (reg) {\n\tcase AK8974_CTRL1:\n\tcase AK8974_CTRL2:\n\tcase AK8974_CTRL3:\n\tcase AK8974_INT_CTRL:\n\tcase AK8974_INT_THRES:\n\tcase AK8974_INT_THRES + 1:\n\t\treturn true;\n\tcase AK8974_PRESET:\n\tcase AK8974_PRESET + 1:\n\t\treturn ak8974->variant != AK8974_WHOAMI_VALUE_HSCDTD008A;\n\tcase AK8974_OFFSET_X:\n\tcase AK8974_OFFSET_X + 1:\n\tcase AK8974_OFFSET_Y:\n\tcase AK8974_OFFSET_Y + 1:\n\tcase AK8974_OFFSET_Z:\n\tcase AK8974_OFFSET_Z + 1:\n\t\treturn ak8974->variant == AK8974_WHOAMI_VALUE_AK8974 ||\n\t\t       ak8974->variant == AK8974_WHOAMI_VALUE_HSCDTD008A;\n\tcase AMI305_OFFSET_X:\n\tcase AMI305_OFFSET_X + 1:\n\tcase AMI305_OFFSET_Y:\n\tcase AMI305_OFFSET_Y + 1:\n\tcase AMI305_OFFSET_Z:\n\tcase AMI305_OFFSET_Z + 1:\n\t\treturn ak8974->variant == AK8974_WHOAMI_VALUE_AMI305 ||\n\t\t       ak8974->variant == AK8974_WHOAMI_VALUE_AMI306;\n\tcase AMI306_CTRL4:\n\tcase AMI306_CTRL4 + 1:\n\t\treturn ak8974->variant == AK8974_WHOAMI_VALUE_AMI306;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool ak8974_precious_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg == AK8974_INT_CLEAR;\n}\n\nstatic const struct regmap_config ak8974_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xff,\n\t.writeable_reg = ak8974_writeable_reg,\n\t.precious_reg = ak8974_precious_reg,\n};\n\nstatic int ak8974_probe(struct i2c_client *i2c)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct ak8974 *ak8974;\n\tunsigned long irq_trig;\n\tint irq = i2c->irq;\n\tint ret;\n\n\t \n\tindio_dev = devm_iio_device_alloc(&i2c->dev, sizeof(*ak8974));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tak8974 = iio_priv(indio_dev);\n\ti2c_set_clientdata(i2c, indio_dev);\n\tak8974->i2c = i2c;\n\tmutex_init(&ak8974->lock);\n\n\tret = iio_read_mount_matrix(&i2c->dev, &ak8974->orientation);\n\tif (ret)\n\t\treturn ret;\n\n\tak8974->regs[0].supply = ak8974_reg_avdd;\n\tak8974->regs[1].supply = ak8974_reg_dvdd;\n\n\tret = devm_regulator_bulk_get(&i2c->dev,\n\t\t\t\t      ARRAY_SIZE(ak8974->regs),\n\t\t\t\t      ak8974->regs);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&i2c->dev, ret, \"cannot get regulators\\n\");\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ak8974->regs), ak8974->regs);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"cannot enable regulators\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpm_runtime_get_noresume(&i2c->dev);\n\tpm_runtime_set_active(&i2c->dev);\n\tpm_runtime_enable(&i2c->dev);\n\n\tak8974->map = devm_regmap_init_i2c(i2c, &ak8974_regmap_config);\n\tif (IS_ERR(ak8974->map)) {\n\t\tdev_err(&i2c->dev, \"failed to allocate register map\\n\");\n\t\tpm_runtime_put_noidle(&i2c->dev);\n\t\tpm_runtime_disable(&i2c->dev);\n\t\treturn PTR_ERR(ak8974->map);\n\t}\n\n\tret = ak8974_set_power(ak8974, AK8974_PWR_ON);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"could not power on\\n\");\n\t\tgoto disable_pm;\n\t}\n\n\tret = ak8974_detect(ak8974);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"neither AK8974 nor AMI30x found\\n\");\n\t\tgoto disable_pm;\n\t}\n\n\tret = ak8974_selftest(ak8974);\n\tif (ret)\n\t\tdev_err(&i2c->dev, \"selftest failed (continuing anyway)\\n\");\n\n\tret = ak8974_reset(ak8974);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"AK8974 reset failed\\n\");\n\t\tgoto disable_pm;\n\t}\n\n\tswitch (ak8974->variant) {\n\tcase AK8974_WHOAMI_VALUE_AMI306:\n\tcase AK8974_WHOAMI_VALUE_AMI305:\n\t\tindio_dev->channels = ak8974_12_bits_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(ak8974_12_bits_channels);\n\t\tbreak;\n\tcase AK8974_WHOAMI_VALUE_HSCDTD008A:\n\t\tindio_dev->channels = ak8974_15_bits_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(ak8974_15_bits_channels);\n\t\tbreak;\n\tdefault:\n\t\tindio_dev->channels = ak8974_12_bits_channels;\n\t\tindio_dev->num_channels = ARRAY_SIZE(ak8974_12_bits_channels);\n\t\tbreak;\n\t}\n\tindio_dev->info = &ak8974_info;\n\tindio_dev->available_scan_masks = ak8974_scan_masks;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->name = ak8974->name;\n\n\tret = iio_triggered_buffer_setup(indio_dev, NULL,\n\t\t\t\t\t ak8974_handle_trigger,\n\t\t\t\t\t NULL);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"triggered buffer setup failed\\n\");\n\t\tgoto disable_pm;\n\t}\n\n\t \n\tif (irq > 0) {\n\t\tirq_trig = irqd_get_trigger_type(irq_get_irq_data(irq));\n\t\tif (irq_trig == IRQF_TRIGGER_RISING) {\n\t\t\tdev_info(&i2c->dev, \"enable rising edge DRDY IRQ\\n\");\n\t\t} else if (irq_trig == IRQF_TRIGGER_FALLING) {\n\t\t\tak8974->drdy_active_low = true;\n\t\t\tdev_info(&i2c->dev, \"enable falling edge DRDY IRQ\\n\");\n\t\t} else {\n\t\t\tirq_trig = IRQF_TRIGGER_RISING;\n\t\t}\n\t\tirq_trig |= IRQF_ONESHOT;\n\t\tirq_trig |= IRQF_SHARED;\n\n\t\tret = devm_request_threaded_irq(&i2c->dev,\n\t\t\t\t\t\tirq,\n\t\t\t\t\t\tak8974_drdy_irq,\n\t\t\t\t\t\tak8974_drdy_irq_thread,\n\t\t\t\t\t\tirq_trig,\n\t\t\t\t\t\tak8974->name,\n\t\t\t\t\t\tak8974);\n\t\tif (ret) {\n\t\t\tdev_err(&i2c->dev, \"unable to request DRDY IRQ \"\n\t\t\t\t\"- proceeding without IRQ\\n\");\n\t\t\tgoto no_irq;\n\t\t}\n\t\tak8974->drdy_irq = true;\n\t}\n\nno_irq:\n\tret = iio_device_register(indio_dev);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"device register failed\\n\");\n\t\tgoto cleanup_buffer;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&i2c->dev,\n\t\t\t\t\t AK8974_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(&i2c->dev);\n\tpm_runtime_put(&i2c->dev);\n\n\treturn 0;\n\ncleanup_buffer:\n\tiio_triggered_buffer_cleanup(indio_dev);\ndisable_pm:\n\tpm_runtime_put_noidle(&i2c->dev);\n\tpm_runtime_disable(&i2c->dev);\n\tak8974_set_power(ak8974, AK8974_PWR_OFF);\n\tregulator_bulk_disable(ARRAY_SIZE(ak8974->regs), ak8974->regs);\n\n\treturn ret;\n}\n\nstatic void ak8974_remove(struct i2c_client *i2c)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(i2c);\n\tstruct ak8974 *ak8974 = iio_priv(indio_dev);\n\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tpm_runtime_get_sync(&i2c->dev);\n\tpm_runtime_put_noidle(&i2c->dev);\n\tpm_runtime_disable(&i2c->dev);\n\tak8974_set_power(ak8974, AK8974_PWR_OFF);\n\tregulator_bulk_disable(ARRAY_SIZE(ak8974->regs), ak8974->regs);\n}\n\nstatic int ak8974_runtime_suspend(struct device *dev)\n{\n\tstruct ak8974 *ak8974 =\n\t\tiio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\n\tak8974_set_power(ak8974, AK8974_PWR_OFF);\n\tregulator_bulk_disable(ARRAY_SIZE(ak8974->regs), ak8974->regs);\n\n\treturn 0;\n}\n\nstatic int ak8974_runtime_resume(struct device *dev)\n{\n\tstruct ak8974 *ak8974 =\n\t\tiio_priv(i2c_get_clientdata(to_i2c_client(dev)));\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ak8974->regs), ak8974->regs);\n\tif (ret)\n\t\treturn ret;\n\tmsleep(AK8974_POWERON_DELAY);\n\tret = ak8974_set_power(ak8974, AK8974_PWR_ON);\n\tif (ret)\n\t\tgoto out_regulator_disable;\n\n\tret = ak8974_configure(ak8974);\n\tif (ret)\n\t\tgoto out_disable_power;\n\n\treturn 0;\n\nout_disable_power:\n\tak8974_set_power(ak8974, AK8974_PWR_OFF);\nout_regulator_disable:\n\tregulator_bulk_disable(ARRAY_SIZE(ak8974->regs), ak8974->regs);\n\n\treturn ret;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(ak8974_dev_pm_ops, ak8974_runtime_suspend,\n\t\t\t\t ak8974_runtime_resume, NULL);\n\nstatic const struct i2c_device_id ak8974_id[] = {\n\t{\"ami305\", 0 },\n\t{\"ami306\", 0 },\n\t{\"ak8974\", 0 },\n\t{\"hscdtd008a\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ak8974_id);\n\nstatic const struct of_device_id ak8974_of_match[] = {\n\t{ .compatible = \"asahi-kasei,ak8974\", },\n\t{ .compatible = \"alps,hscdtd008a\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ak8974_of_match);\n\nstatic struct i2c_driver ak8974_driver = {\n\t.driver\t = {\n\t\t.name\t= \"ak8974\",\n\t\t.pm = pm_ptr(&ak8974_dev_pm_ops),\n\t\t.of_match_table = ak8974_of_match,\n\t},\n\t.probe = ak8974_probe,\n\t.remove\t  = ak8974_remove,\n\t.id_table = ak8974_id,\n};\nmodule_i2c_driver(ak8974_driver);\n\nMODULE_DESCRIPTION(\"AK8974 and AMI30x 3-axis magnetometer driver\");\nMODULE_AUTHOR(\"Samu Onkalo\");\nMODULE_AUTHOR(\"Linus Walleij\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}