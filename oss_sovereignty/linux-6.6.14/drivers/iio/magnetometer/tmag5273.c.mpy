{
  "module_name": "tmag5273.c",
  "hash_id": "fbc62fbcd9407d8073d7c25103eff7f11cdbb1858c4181852880546cf90dfa44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/magnetometer/tmag5273.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/pm_runtime.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n\n#define TMAG5273_DEVICE_CONFIG_1\t 0x00\n#define TMAG5273_DEVICE_CONFIG_2\t 0x01\n#define TMAG5273_SENSOR_CONFIG_1\t 0x02\n#define TMAG5273_SENSOR_CONFIG_2\t 0x03\n#define TMAG5273_X_THR_CONFIG\t\t 0x04\n#define TMAG5273_Y_THR_CONFIG\t\t 0x05\n#define TMAG5273_Z_THR_CONFIG\t\t 0x06\n#define TMAG5273_T_CONFIG\t\t 0x07\n#define TMAG5273_INT_CONFIG_1\t\t 0x08\n#define TMAG5273_MAG_GAIN_CONFIG\t 0x09\n#define TMAG5273_MAG_OFFSET_CONFIG_1\t 0x0A\n#define TMAG5273_MAG_OFFSET_CONFIG_2\t 0x0B\n#define TMAG5273_I2C_ADDRESS\t\t 0x0C\n#define TMAG5273_DEVICE_ID\t\t 0x0D\n#define TMAG5273_MANUFACTURER_ID_LSB\t 0x0E\n#define TMAG5273_MANUFACTURER_ID_MSB\t 0x0F\n#define TMAG5273_T_MSB_RESULT\t\t 0x10\n#define TMAG5273_T_LSB_RESULT\t\t 0x11\n#define TMAG5273_X_MSB_RESULT\t\t 0x12\n#define TMAG5273_X_LSB_RESULT\t\t 0x13\n#define TMAG5273_Y_MSB_RESULT\t\t 0x14\n#define TMAG5273_Y_LSB_RESULT\t\t 0x15\n#define TMAG5273_Z_MSB_RESULT\t\t 0x16\n#define TMAG5273_Z_LSB_RESULT\t\t 0x17\n#define TMAG5273_CONV_STATUS\t\t 0x18\n#define TMAG5273_ANGLE_RESULT_MSB\t 0x19\n#define TMAG5273_ANGLE_RESULT_LSB\t 0x1A\n#define TMAG5273_MAGNITUDE_RESULT\t 0x1B\n#define TMAG5273_DEVICE_STATUS\t\t 0x1C\n#define TMAG5273_MAX_REG\t\t TMAG5273_DEVICE_STATUS\n\n#define TMAG5273_AUTOSLEEP_DELAY_MS\t 5000\n#define TMAG5273_MAX_AVERAGE             32\n\n \n#define TMAG5273_MANUFACTURER_ID\t 0x5449\n\n \n#define TMAG5273_AVG_MODE_MASK\t\t GENMASK(4, 2)\n#define TMAG5273_AVG_1_MODE\t\t FIELD_PREP(TMAG5273_AVG_MODE_MASK, 0)\n#define TMAG5273_AVG_2_MODE\t\t FIELD_PREP(TMAG5273_AVG_MODE_MASK, 1)\n#define TMAG5273_AVG_4_MODE\t\t FIELD_PREP(TMAG5273_AVG_MODE_MASK, 2)\n#define TMAG5273_AVG_8_MODE\t\t FIELD_PREP(TMAG5273_AVG_MODE_MASK, 3)\n#define TMAG5273_AVG_16_MODE\t\t FIELD_PREP(TMAG5273_AVG_MODE_MASK, 4)\n#define TMAG5273_AVG_32_MODE\t\t FIELD_PREP(TMAG5273_AVG_MODE_MASK, 5)\n\n \n#define TMAG5273_OP_MODE_MASK\t\t GENMASK(1, 0)\n#define TMAG5273_OP_MODE_STANDBY\t FIELD_PREP(TMAG5273_OP_MODE_MASK, 0)\n#define TMAG5273_OP_MODE_SLEEP\t\t FIELD_PREP(TMAG5273_OP_MODE_MASK, 1)\n#define TMAG5273_OP_MODE_CONT\t\t FIELD_PREP(TMAG5273_OP_MODE_MASK, 2)\n#define TMAG5273_OP_MODE_WAKEUP\t\t FIELD_PREP(TMAG5273_OP_MODE_MASK, 3)\n\n \n#define TMAG5273_MAG_CH_EN_MASK\t\t GENMASK(7, 4)\n#define TMAG5273_MAG_CH_EN_X_Y_Z\t 7\n\n \n#define TMAG5273_Z_RANGE_MASK\t\t BIT(0)\n#define TMAG5273_X_Y_RANGE_MASK\t\t BIT(1)\n#define TMAG5273_ANGLE_EN_MASK\t\t GENMASK(3, 2)\n#define TMAG5273_ANGLE_EN_OFF\t\t 0\n#define TMAG5273_ANGLE_EN_X_Y\t\t 1\n#define TMAG5273_ANGLE_EN_Y_Z\t\t 2\n#define TMAG5273_ANGLE_EN_X_Z\t\t 3\n\n \n#define TMAG5273_T_CH_EN\t\t BIT(0)\n\n \n#define TMAG5273_VERSION_MASK\t\t GENMASK(1, 0)\n\n \n#define TMAG5273_CONV_STATUS_COMPLETE\t BIT(0)\n\nenum tmag5273_channels {\n\tTEMPERATURE = 0,\n\tAXIS_X,\n\tAXIS_Y,\n\tAXIS_Z,\n\tANGLE,\n\tMAGNITUDE,\n};\n\nenum tmag5273_scale_index {\n\tMAGN_RANGE_LOW = 0,\n\tMAGN_RANGE_HIGH,\n\tMAGN_RANGE_NUM\n};\n\n \nstruct tmag5273_data {\n\tstruct device *dev;\n\tunsigned int devid;\n\tunsigned int version;\n\tchar name[16];\n\tunsigned int conv_avg;\n\tunsigned int scale;\n\tenum tmag5273_scale_index scale_index;\n\tunsigned int angle_measurement;\n\tstruct regmap *map;\n\tstruct regulator *vcc;\n\n\t \n\tstruct mutex lock;\n};\n\nstatic const char *const tmag5273_angle_names[] = { \"off\", \"x-y\", \"y-z\", \"x-z\" };\n\n \nstatic const unsigned int tmag5273_avg_table[] = {\n\t1, 2, 4, 8, 16, 32,\n};\n\n \nstatic const struct iio_val_int_plus_micro tmag5273_scale[][MAGN_RANGE_NUM] = {\n\t{ { 0,     0 }, { 0,     0 } },\n\t{ { 0, 12200 }, { 0, 24400 } },\n\t{ { 0, 40600 }, { 0, 81200 } },\n\t{ { 0,     0 }, { 0,     0 } },\n};\n\nstatic int tmag5273_get_measure(struct tmag5273_data *data, s16 *t, s16 *x,\n\t\t\t\ts16 *y, s16 *z, u16 *angle, u16 *magnitude)\n{\n\tunsigned int status, val;\n\t__be16 reg_data[4];\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\n\t \n\tret = regmap_read_poll_timeout(data->map, TMAG5273_CONV_STATUS, status,\n\t\t\t\t       status & TMAG5273_CONV_STATUS_COMPLETE,\n\t\t\t\t       100, 10000);\n\tif (ret) {\n\t\tdev_err(data->dev, \"timeout waiting for measurement\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tret = regmap_bulk_read(data->map, TMAG5273_T_MSB_RESULT, reg_data,\n\t\t\t       sizeof(reg_data));\n\tif (ret)\n\t\tgoto out_unlock;\n\t*t = be16_to_cpu(reg_data[0]);\n\t*x = be16_to_cpu(reg_data[1]);\n\t*y = be16_to_cpu(reg_data[2]);\n\t*z = be16_to_cpu(reg_data[3]);\n\n\tret = regmap_bulk_read(data->map, TMAG5273_ANGLE_RESULT_MSB,\n\t\t\t       &reg_data[0], sizeof(reg_data[0]));\n\tif (ret)\n\t\tgoto out_unlock;\n\t \n\t*angle = be16_to_cpu(reg_data[0]);\n\n\tret = regmap_read(data->map, TMAG5273_MAGNITUDE_RESULT, &val);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\t*magnitude = val;\n\nout_unlock:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int tmag5273_write_osr(struct tmag5273_data *data, int val)\n{\n\tint i;\n\n\tif (val == data->conv_avg)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(tmag5273_avg_table); i++) {\n\t\tif (tmag5273_avg_table[i] == val)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(tmag5273_avg_table))\n\t\treturn -EINVAL;\n\tdata->conv_avg = val;\n\n\treturn regmap_update_bits(data->map, TMAG5273_DEVICE_CONFIG_1,\n\t\t\t\t  TMAG5273_AVG_MODE_MASK,\n\t\t\t\t  FIELD_PREP(TMAG5273_AVG_MODE_MASK, i));\n}\n\nstatic int tmag5273_write_scale(struct tmag5273_data *data, int scale_micro)\n{\n\tu32 value;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tmag5273_scale[0]); i++) {\n\t\tif (tmag5273_scale[data->version][i].micro == scale_micro)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(tmag5273_scale[0]))\n\t\treturn -EINVAL;\n\tdata->scale_index = i;\n\n\tif (data->scale_index == MAGN_RANGE_LOW)\n\t\tvalue = 0;\n\telse\n\t\tvalue = TMAG5273_Z_RANGE_MASK | TMAG5273_X_Y_RANGE_MASK;\n\n\treturn regmap_update_bits(data->map, TMAG5273_SENSOR_CONFIG_2,\n\t\t\t\t  TMAG5273_Z_RANGE_MASK | TMAG5273_X_Y_RANGE_MASK, value);\n}\n\nstatic int tmag5273_read_avail(struct iio_dev *indio_dev,\n\t\t\t       struct iio_chan_spec const *chan,\n\t\t\t       const int **vals, int *type, int *length,\n\t\t\t       long mask)\n{\n\tstruct tmag5273_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t*vals = tmag5273_avg_table;\n\t\t*type = IIO_VAL_INT;\n\t\t*length = ARRAY_SIZE(tmag5273_avg_table);\n\t\treturn IIO_AVAIL_LIST;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_MAGN:\n\t\t\t*type = IIO_VAL_INT_PLUS_MICRO;\n\t\t\t*vals = (int *)tmag5273_scale[data->version];\n\t\t\t*length = ARRAY_SIZE(tmag5273_scale[data->version]) *\n\t\t\t\t  MAGN_RANGE_NUM;\n\t\t\treturn IIO_AVAIL_LIST;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tmag5273_read_raw(struct iio_dev *indio_dev,\n\t\t\t     const struct iio_chan_spec *chan, int *val,\n\t\t\t     int *val2, long mask)\n{\n\tstruct tmag5273_data *data = iio_priv(indio_dev);\n\ts16 t, x, y, z;\n\tu16 angle, magnitude;\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_PROCESSED:\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = pm_runtime_resume_and_get(data->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = tmag5273_get_measure(data, &t, &x, &y, &z, &angle, &magnitude);\n\n\t\tpm_runtime_mark_last_busy(data->dev);\n\t\tpm_runtime_put_autosuspend(data->dev);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswitch (chan->address) {\n\t\tcase TEMPERATURE:\n\t\t\t*val = t;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase AXIS_X:\n\t\t\t*val = x;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase AXIS_Y:\n\t\t\t*val = y;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase AXIS_Z:\n\t\t\t*val = z;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase ANGLE:\n\t\t\t*val = angle;\n\t\t\treturn IIO_VAL_INT;\n\t\tcase MAGNITUDE:\n\t\t\t*val = magnitude;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t \n\t\t\t*val = 10000;\n\t\t\t*val2 = 601;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tcase IIO_MAGN:\n\t\t\t \n\t\t\t*val = 0;\n\t\t\t*val2 = tmag5273_scale[data->version]\n\t\t\t\t\t      [data->scale_index].micro;\n\t\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t\tcase IIO_ANGL:\n\t\t\t \n\t\t\t*val = 1000;\n\t\t\t*val2 = 916732;\n\t\t\treturn IIO_VAL_FRACTIONAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OFFSET:\n\t\tswitch (chan->type) {\n\t\tcase IIO_TEMP:\n\t\t\t*val = -16005;\n\t\t\treturn IIO_VAL_INT;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\t*val = data->conv_avg;\n\t\treturn IIO_VAL_INT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tmag5273_write_raw(struct iio_dev *indio_dev,\n\t\t\t      struct iio_chan_spec const *chan, int val,\n\t\t\t      int val2, long mask)\n{\n\tstruct tmag5273_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\n\t\treturn tmag5273_write_osr(data, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\tswitch (chan->type) {\n\t\tcase IIO_MAGN:\n\t\t\tif (val)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn tmag5273_write_scale(data, val2);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#define TMAG5273_AXIS_CHANNEL(axis, index)\t\t\t\t     \\\n\t{\t\t\t\t\t\t\t\t     \\\n\t\t.type = IIO_MAGN,\t\t\t\t\t     \\\n\t\t.modified = 1,\t\t\t\t\t\t     \\\n\t\t.channel2 = IIO_MOD_##axis,\t\t\t\t     \\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t     \\\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\t\t     \\\n\t\t.info_mask_shared_by_type_available =\t\t\t     \\\n\t\t\t\t      BIT(IIO_CHAN_INFO_SCALE),\t\t     \\\n\t\t.info_mask_shared_by_all =\t\t\t\t     \\\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \\\n\t\t.info_mask_shared_by_all_available =\t\t\t     \\\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \\\n\t\t.address = index,\t\t\t\t\t     \\\n\t\t.scan_index = index,\t\t\t\t\t     \\\n\t\t.scan_type = {\t\t\t\t\t\t     \\\n\t\t\t.sign = 's',\t\t\t\t\t     \\\n\t\t\t.realbits = 16,\t\t\t\t\t     \\\n\t\t\t.storagebits = 16,\t\t\t\t     \\\n\t\t\t.endianness = IIO_CPU,\t\t\t\t     \\\n\t\t},\t\t\t\t\t\t\t     \\\n\t}\n\nstatic const struct iio_chan_spec tmag5273_channels[] = {\n\t{\n\t\t.type = IIO_TEMP,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n\t\t\tBIT(IIO_CHAN_INFO_SCALE) |\n\t\t\tBIT(IIO_CHAN_INFO_OFFSET),\n\t\t.address = TEMPERATURE,\n\t\t.scan_index = TEMPERATURE,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\tTMAG5273_AXIS_CHANNEL(X, AXIS_X),\n\tTMAG5273_AXIS_CHANNEL(Y, AXIS_Y),\n\tTMAG5273_AXIS_CHANNEL(Z, AXIS_Z),\n\t{\n\t\t.type = IIO_ANGL,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\n\t\t.info_mask_shared_by_all =\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.info_mask_shared_by_all_available =\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.address = ANGLE,\n\t\t.scan_index = ANGLE,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\t{\n\t\t.type = IIO_DISTANCE,\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n\t\t.info_mask_shared_by_all =\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.info_mask_shared_by_all_available =\n\t\t\t\t      BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\n\t\t.address = MAGNITUDE,\n\t\t.scan_index = MAGNITUDE,\n\t\t.scan_type = {\n\t\t\t.sign = 'u',\n\t\t\t.realbits = 16,\n\t\t\t.storagebits = 16,\n\t\t\t.endianness = IIO_CPU,\n\t\t},\n\t},\n\tIIO_CHAN_SOFT_TIMESTAMP(6),\n};\n\nstatic const struct iio_info tmag5273_info = {\n\t.read_avail = tmag5273_read_avail,\n\t.read_raw = tmag5273_read_raw,\n\t.write_raw = tmag5273_write_raw,\n};\n\nstatic bool tmag5273_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg >= TMAG5273_T_MSB_RESULT && reg <= TMAG5273_MAGNITUDE_RESULT;\n}\n\nstatic const struct regmap_config tmag5273_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = TMAG5273_MAX_REG,\n\t.volatile_reg = tmag5273_volatile_reg,\n};\n\nstatic int tmag5273_set_operating_mode(struct tmag5273_data *data,\n\t\t\t\t       unsigned int val)\n{\n\treturn regmap_write(data->map, TMAG5273_DEVICE_CONFIG_2, val);\n}\n\nstatic void tmag5273_read_device_property(struct tmag5273_data *data)\n{\n\tstruct device *dev = data->dev;\n\tconst char *str;\n\tint ret;\n\n\tdata->angle_measurement = TMAG5273_ANGLE_EN_X_Y;\n\n\tret = device_property_read_string(dev, \"ti,angle-measurement\", &str);\n\tif (ret)\n\t\treturn;\n\n\tret = match_string(tmag5273_angle_names,\n\t\t\t   ARRAY_SIZE(tmag5273_angle_names), str);\n\tif (ret >= 0)\n\t\tdata->angle_measurement = ret;\n}\n\nstatic void tmag5273_wake_up(struct tmag5273_data *data)\n{\n\tint val;\n\n\t \n\tregmap_read(data->map, TMAG5273_DEVICE_ID, &val);\n\t \n\tusleep_range(80, 200);\n}\n\nstatic int tmag5273_chip_init(struct tmag5273_data *data)\n{\n\tint ret;\n\n\tret = regmap_write(data->map, TMAG5273_DEVICE_CONFIG_1,\n\t\t\t   TMAG5273_AVG_32_MODE);\n\tif (ret)\n\t\treturn ret;\n\tdata->conv_avg = 32;\n\n\tret = regmap_write(data->map, TMAG5273_DEVICE_CONFIG_2,\n\t\t\t   TMAG5273_OP_MODE_CONT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(data->map, TMAG5273_SENSOR_CONFIG_1,\n\t\t\t   FIELD_PREP(TMAG5273_MAG_CH_EN_MASK,\n\t\t\t\t      TMAG5273_MAG_CH_EN_X_Y_Z));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(data->map, TMAG5273_SENSOR_CONFIG_2,\n\t\t\t   FIELD_PREP(TMAG5273_ANGLE_EN_MASK,\n\t\t\t\t      data->angle_measurement));\n\tif (ret)\n\t\treturn ret;\n\tdata->scale_index = MAGN_RANGE_LOW;\n\n\treturn regmap_write(data->map, TMAG5273_T_CONFIG, TMAG5273_T_CH_EN);\n}\n\nstatic int tmag5273_check_device_id(struct tmag5273_data *data)\n{\n\t__le16 devid;\n\tint val, ret;\n\n\tret = regmap_read(data->map, TMAG5273_DEVICE_ID, &val);\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret, \"failed to power on device\\n\");\n\tdata->version = FIELD_PREP(TMAG5273_VERSION_MASK, val);\n\n\tret = regmap_bulk_read(data->map, TMAG5273_MANUFACTURER_ID_LSB, &devid,\n\t\t\t       sizeof(devid));\n\tif (ret)\n\t\treturn dev_err_probe(data->dev, ret, \"failed to read device ID\\n\");\n\tdata->devid = le16_to_cpu(devid);\n\n\tswitch (data->devid) {\n\tcase TMAG5273_MANUFACTURER_ID:\n\t\t \n\t\tsnprintf(data->name, sizeof(data->name), \"tmag5273x%1u\", data->version);\n\t\tif (data->version < 1 || data->version > 2)\n\t\t\tdev_warn(data->dev, \"Unsupported device %s\\n\", data->name);\n\t\treturn 0;\n\tdefault:\n\t\t \n\t\tdev_warn(data->dev, \"Unknown device ID 0x%x\\n\", data->devid);\n\t\treturn 0;\n\t}\n}\n\nstatic void tmag5273_power_down(void *data)\n{\n\ttmag5273_set_operating_mode(data, TMAG5273_OP_MODE_SLEEP);\n}\n\nstatic int tmag5273_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct tmag5273_data *data;\n\tstruct iio_dev *indio_dev;\n\tint ret;\n\n\tindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\n\tif (!indio_dev)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\tdata->dev = dev;\n\ti2c_set_clientdata(i2c, indio_dev);\n\n\tdata->map = devm_regmap_init_i2c(i2c, &tmag5273_regmap_config);\n\tif (IS_ERR(data->map))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->map),\n\t\t\t\t     \"failed to allocate register map\\n\");\n\n\tmutex_init(&data->lock);\n\n\tret = devm_regulator_get_enable(dev, \"vcc\");\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to enable regulator\\n\");\n\n\ttmag5273_wake_up(data);\n\n\tret = tmag5273_check_device_id(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tmag5273_set_operating_mode(data, TMAG5273_OP_MODE_CONT);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to power on device\\n\");\n\n\t \n\tret = devm_add_action_or_reset(dev, tmag5273_power_down, data);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to add powerdown action\\n\");\n\n\tret = pm_runtime_set_active(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_pm_runtime_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_autosuspend_delay(dev, TMAG5273_AUTOSLEEP_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\n\ttmag5273_read_device_property(data);\n\n\tret = tmag5273_chip_init(data);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to init device\\n\");\n\n\tindio_dev->info = &tmag5273_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->name = data->name;\n\tindio_dev->channels = tmag5273_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(tmag5273_channels);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\tret = devm_iio_device_register(dev, indio_dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"device register failed\\n\");\n\n\treturn 0;\n}\n\nstatic int tmag5273_runtime_suspend(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct tmag5273_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\tret = tmag5273_set_operating_mode(data, TMAG5273_OP_MODE_SLEEP);\n\tif (ret)\n\t\tdev_err(dev, \"failed to power off device (%pe)\\n\", ERR_PTR(ret));\n\n\treturn ret;\n}\n\nstatic int tmag5273_runtime_resume(struct device *dev)\n{\n\tstruct iio_dev *indio_dev = dev_get_drvdata(dev);\n\tstruct tmag5273_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\ttmag5273_wake_up(data);\n\n\tret = tmag5273_set_operating_mode(data, TMAG5273_OP_MODE_CONT);\n\tif (ret)\n\t\tdev_err(dev, \"failed to power on device (%pe)\\n\", ERR_PTR(ret));\n\n\treturn ret;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(tmag5273_pm_ops,\n\t\t\t\t tmag5273_runtime_suspend, tmag5273_runtime_resume,\n\t\t\t\t NULL);\n\nstatic const struct i2c_device_id tmag5273_id[] = {\n\t{ \"tmag5273\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, tmag5273_id);\n\nstatic const struct of_device_id tmag5273_of_match[] = {\n\t{ .compatible = \"ti,tmag5273\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, tmag5273_of_match);\n\nstatic struct i2c_driver tmag5273_driver = {\n\t.driver\t = {\n\t\t.name = \"tmag5273\",\n\t\t.of_match_table = tmag5273_of_match,\n\t\t.pm = pm_ptr(&tmag5273_pm_ops),\n\t},\n\t.probe = tmag5273_probe,\n\t.id_table = tmag5273_id,\n};\nmodule_i2c_driver(tmag5273_driver);\n\nMODULE_DESCRIPTION(\"TI TMAG5273 Low-Power Linear 3D Hall-Effect Sensor driver\");\nMODULE_AUTHOR(\"Gerald Loacker <gerald.loacker@wolfvision.net>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}