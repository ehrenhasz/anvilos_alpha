{
  "module_name": "ak8975.c",
  "hash_id": "2e48a47649191861e3fd6c470ae07d8c6ae57c45f55cf069c2d7cd9843d455b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/magnetometer/ak8975.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_runtime.h>\n\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/buffer.h>\n#include <linux/iio/trigger.h>\n#include <linux/iio/trigger_consumer.h>\n#include <linux/iio/triggered_buffer.h>\n\n \n#define AK8975_REG_WIA\t\t\t0x00\n#define AK8975_DEVICE_ID\t\t0x48\n\n#define AK8975_REG_INFO\t\t\t0x01\n\n#define AK8975_REG_ST1\t\t\t0x02\n#define AK8975_REG_ST1_DRDY_SHIFT\t0\n#define AK8975_REG_ST1_DRDY_MASK\t(1 << AK8975_REG_ST1_DRDY_SHIFT)\n\n#define AK8975_REG_HXL\t\t\t0x03\n#define AK8975_REG_HXH\t\t\t0x04\n#define AK8975_REG_HYL\t\t\t0x05\n#define AK8975_REG_HYH\t\t\t0x06\n#define AK8975_REG_HZL\t\t\t0x07\n#define AK8975_REG_HZH\t\t\t0x08\n#define AK8975_REG_ST2\t\t\t0x09\n#define AK8975_REG_ST2_DERR_SHIFT\t2\n#define AK8975_REG_ST2_DERR_MASK\t(1 << AK8975_REG_ST2_DERR_SHIFT)\n\n#define AK8975_REG_ST2_HOFL_SHIFT\t3\n#define AK8975_REG_ST2_HOFL_MASK\t(1 << AK8975_REG_ST2_HOFL_SHIFT)\n\n#define AK8975_REG_CNTL\t\t\t0x0A\n#define AK8975_REG_CNTL_MODE_SHIFT\t0\n#define AK8975_REG_CNTL_MODE_MASK\t(0xF << AK8975_REG_CNTL_MODE_SHIFT)\n#define AK8975_REG_CNTL_MODE_POWER_DOWN\t0x00\n#define AK8975_REG_CNTL_MODE_ONCE\t0x01\n#define AK8975_REG_CNTL_MODE_SELF_TEST\t0x08\n#define AK8975_REG_CNTL_MODE_FUSE_ROM\t0x0F\n\n#define AK8975_REG_RSVC\t\t\t0x0B\n#define AK8975_REG_ASTC\t\t\t0x0C\n#define AK8975_REG_TS1\t\t\t0x0D\n#define AK8975_REG_TS2\t\t\t0x0E\n#define AK8975_REG_I2CDIS\t\t0x0F\n#define AK8975_REG_ASAX\t\t\t0x10\n#define AK8975_REG_ASAY\t\t\t0x11\n#define AK8975_REG_ASAZ\t\t\t0x12\n\n#define AK8975_MAX_REGS\t\t\tAK8975_REG_ASAZ\n\n \n#define AK09912_REG_WIA1\t\t0x00\n#define AK09912_REG_WIA2\t\t0x01\n#define AK09916_DEVICE_ID\t\t0x09\n#define AK09912_DEVICE_ID\t\t0x04\n#define AK09911_DEVICE_ID\t\t0x05\n\n#define AK09911_REG_INFO1\t\t0x02\n#define AK09911_REG_INFO2\t\t0x03\n\n#define AK09912_REG_ST1\t\t\t0x10\n\n#define AK09912_REG_ST1_DRDY_SHIFT\t0\n#define AK09912_REG_ST1_DRDY_MASK\t(1 << AK09912_REG_ST1_DRDY_SHIFT)\n\n#define AK09912_REG_HXL\t\t\t0x11\n#define AK09912_REG_HXH\t\t\t0x12\n#define AK09912_REG_HYL\t\t\t0x13\n#define AK09912_REG_HYH\t\t\t0x14\n#define AK09912_REG_HZL\t\t\t0x15\n#define AK09912_REG_HZH\t\t\t0x16\n#define AK09912_REG_TMPS\t\t0x17\n\n#define AK09912_REG_ST2\t\t\t0x18\n#define AK09912_REG_ST2_HOFL_SHIFT\t3\n#define AK09912_REG_ST2_HOFL_MASK\t(1 << AK09912_REG_ST2_HOFL_SHIFT)\n\n#define AK09912_REG_CNTL1\t\t0x30\n\n#define AK09912_REG_CNTL2\t\t0x31\n#define AK09912_REG_CNTL_MODE_POWER_DOWN\t0x00\n#define AK09912_REG_CNTL_MODE_ONCE\t0x01\n#define AK09912_REG_CNTL_MODE_SELF_TEST\t0x10\n#define AK09912_REG_CNTL_MODE_FUSE_ROM\t0x1F\n#define AK09912_REG_CNTL2_MODE_SHIFT\t0\n#define AK09912_REG_CNTL2_MODE_MASK\t(0x1F << AK09912_REG_CNTL2_MODE_SHIFT)\n\n#define AK09912_REG_CNTL3\t\t0x32\n\n#define AK09912_REG_TS1\t\t\t0x33\n#define AK09912_REG_TS2\t\t\t0x34\n#define AK09912_REG_TS3\t\t\t0x35\n#define AK09912_REG_I2CDIS\t\t0x36\n#define AK09912_REG_TS4\t\t\t0x37\n\n#define AK09912_REG_ASAX\t\t0x60\n#define AK09912_REG_ASAY\t\t0x61\n#define AK09912_REG_ASAZ\t\t0x62\n\n#define AK09912_MAX_REGS\t\tAK09912_REG_ASAZ\n\n \n#define AK8975_MAX_CONVERSION_TIMEOUT\t500\n#define AK8975_CONVERSION_DONE_POLL_TIME 10\n#define AK8975_DATA_READY_TIMEOUT\t((100*HZ)/1000)\n\n \nstatic long ak8975_raw_to_gauss(u16 data)\n{\n\treturn (((long)data + 128) * 3000) / 256;\n}\n\n \n\nstatic long ak8963_09911_raw_to_gauss(u16 data)\n{\n\treturn (((long)data + 128) * 6000) / 256;\n}\n\n \nstatic long ak09912_raw_to_gauss(u16 data)\n{\n\treturn (((long)data + 128) * 1500) / 256;\n}\n\n \nenum asahi_compass_chipset {\n\tAKXXXX\t\t= 0,\n\tAK8975,\n\tAK8963,\n\tAK09911,\n\tAK09912,\n\tAK09916,\n};\n\nenum ak_ctrl_reg_addr {\n\tST1,\n\tST2,\n\tCNTL,\n\tASA_BASE,\n\tMAX_REGS,\n\tREGS_END,\n};\n\nenum ak_ctrl_reg_mask {\n\tST1_DRDY,\n\tST2_HOFL,\n\tST2_DERR,\n\tCNTL_MODE,\n\tMASK_END,\n};\n\nenum ak_ctrl_mode {\n\tPOWER_DOWN,\n\tMODE_ONCE,\n\tSELF_TEST,\n\tFUSE_ROM,\n\tMODE_END,\n};\n\nstruct ak_def {\n\tenum asahi_compass_chipset type;\n\tlong (*raw_to_gauss)(u16 data);\n\tu16 range;\n\tu8 ctrl_regs[REGS_END];\n\tu8 ctrl_masks[MASK_END];\n\tu8 ctrl_modes[MODE_END];\n\tu8 data_regs[3];\n};\n\nstatic const struct ak_def ak_def_array[] = {\n\t{\n\t\t.type = AK8975,\n\t\t.raw_to_gauss = ak8975_raw_to_gauss,\n\t\t.range = 4096,\n\t\t.ctrl_regs = {\n\t\t\tAK8975_REG_ST1,\n\t\t\tAK8975_REG_ST2,\n\t\t\tAK8975_REG_CNTL,\n\t\t\tAK8975_REG_ASAX,\n\t\t\tAK8975_MAX_REGS},\n\t\t.ctrl_masks = {\n\t\t\tAK8975_REG_ST1_DRDY_MASK,\n\t\t\tAK8975_REG_ST2_HOFL_MASK,\n\t\t\tAK8975_REG_ST2_DERR_MASK,\n\t\t\tAK8975_REG_CNTL_MODE_MASK},\n\t\t.ctrl_modes = {\n\t\t\tAK8975_REG_CNTL_MODE_POWER_DOWN,\n\t\t\tAK8975_REG_CNTL_MODE_ONCE,\n\t\t\tAK8975_REG_CNTL_MODE_SELF_TEST,\n\t\t\tAK8975_REG_CNTL_MODE_FUSE_ROM},\n\t\t.data_regs = {\n\t\t\tAK8975_REG_HXL,\n\t\t\tAK8975_REG_HYL,\n\t\t\tAK8975_REG_HZL},\n\t},\n\t{\n\t\t.type = AK8963,\n\t\t.raw_to_gauss = ak8963_09911_raw_to_gauss,\n\t\t.range = 8190,\n\t\t.ctrl_regs = {\n\t\t\tAK8975_REG_ST1,\n\t\t\tAK8975_REG_ST2,\n\t\t\tAK8975_REG_CNTL,\n\t\t\tAK8975_REG_ASAX,\n\t\t\tAK8975_MAX_REGS},\n\t\t.ctrl_masks = {\n\t\t\tAK8975_REG_ST1_DRDY_MASK,\n\t\t\tAK8975_REG_ST2_HOFL_MASK,\n\t\t\t0,\n\t\t\tAK8975_REG_CNTL_MODE_MASK},\n\t\t.ctrl_modes = {\n\t\t\tAK8975_REG_CNTL_MODE_POWER_DOWN,\n\t\t\tAK8975_REG_CNTL_MODE_ONCE,\n\t\t\tAK8975_REG_CNTL_MODE_SELF_TEST,\n\t\t\tAK8975_REG_CNTL_MODE_FUSE_ROM},\n\t\t.data_regs = {\n\t\t\tAK8975_REG_HXL,\n\t\t\tAK8975_REG_HYL,\n\t\t\tAK8975_REG_HZL},\n\t},\n\t{\n\t\t.type = AK09911,\n\t\t.raw_to_gauss = ak8963_09911_raw_to_gauss,\n\t\t.range = 8192,\n\t\t.ctrl_regs = {\n\t\t\tAK09912_REG_ST1,\n\t\t\tAK09912_REG_ST2,\n\t\t\tAK09912_REG_CNTL2,\n\t\t\tAK09912_REG_ASAX,\n\t\t\tAK09912_MAX_REGS},\n\t\t.ctrl_masks = {\n\t\t\tAK09912_REG_ST1_DRDY_MASK,\n\t\t\tAK09912_REG_ST2_HOFL_MASK,\n\t\t\t0,\n\t\t\tAK09912_REG_CNTL2_MODE_MASK},\n\t\t.ctrl_modes = {\n\t\t\tAK09912_REG_CNTL_MODE_POWER_DOWN,\n\t\t\tAK09912_REG_CNTL_MODE_ONCE,\n\t\t\tAK09912_REG_CNTL_MODE_SELF_TEST,\n\t\t\tAK09912_REG_CNTL_MODE_FUSE_ROM},\n\t\t.data_regs = {\n\t\t\tAK09912_REG_HXL,\n\t\t\tAK09912_REG_HYL,\n\t\t\tAK09912_REG_HZL},\n\t},\n\t{\n\t\t.type = AK09912,\n\t\t.raw_to_gauss = ak09912_raw_to_gauss,\n\t\t.range = 32752,\n\t\t.ctrl_regs = {\n\t\t\tAK09912_REG_ST1,\n\t\t\tAK09912_REG_ST2,\n\t\t\tAK09912_REG_CNTL2,\n\t\t\tAK09912_REG_ASAX,\n\t\t\tAK09912_MAX_REGS},\n\t\t.ctrl_masks = {\n\t\t\tAK09912_REG_ST1_DRDY_MASK,\n\t\t\tAK09912_REG_ST2_HOFL_MASK,\n\t\t\t0,\n\t\t\tAK09912_REG_CNTL2_MODE_MASK},\n\t\t.ctrl_modes = {\n\t\t\tAK09912_REG_CNTL_MODE_POWER_DOWN,\n\t\t\tAK09912_REG_CNTL_MODE_ONCE,\n\t\t\tAK09912_REG_CNTL_MODE_SELF_TEST,\n\t\t\tAK09912_REG_CNTL_MODE_FUSE_ROM},\n\t\t.data_regs = {\n\t\t\tAK09912_REG_HXL,\n\t\t\tAK09912_REG_HYL,\n\t\t\tAK09912_REG_HZL},\n\t},\n\t{\n\t\t.type = AK09916,\n\t\t.raw_to_gauss = ak09912_raw_to_gauss,\n\t\t.range = 32752,\n\t\t.ctrl_regs = {\n\t\t\tAK09912_REG_ST1,\n\t\t\tAK09912_REG_ST2,\n\t\t\tAK09912_REG_CNTL2,\n\t\t\tAK09912_REG_ASAX,\n\t\t\tAK09912_MAX_REGS},\n\t\t.ctrl_masks = {\n\t\t\tAK09912_REG_ST1_DRDY_MASK,\n\t\t\tAK09912_REG_ST2_HOFL_MASK,\n\t\t\t0,\n\t\t\tAK09912_REG_CNTL2_MODE_MASK},\n\t\t.ctrl_modes = {\n\t\t\tAK09912_REG_CNTL_MODE_POWER_DOWN,\n\t\t\tAK09912_REG_CNTL_MODE_ONCE,\n\t\t\tAK09912_REG_CNTL_MODE_SELF_TEST,\n\t\t\tAK09912_REG_CNTL_MODE_FUSE_ROM},\n\t\t.data_regs = {\n\t\t\tAK09912_REG_HXL,\n\t\t\tAK09912_REG_HYL,\n\t\t\tAK09912_REG_HZL},\n\t}\n};\n\n \nstruct ak8975_data {\n\tstruct i2c_client\t*client;\n\tconst struct ak_def\t*def;\n\tstruct mutex\t\tlock;\n\tu8\t\t\tasa[3];\n\tlong\t\t\traw_to_gauss[3];\n\tstruct gpio_desc\t*eoc_gpiod;\n\tstruct gpio_desc\t*reset_gpiod;\n\tint\t\t\teoc_irq;\n\twait_queue_head_t\tdata_ready_queue;\n\tunsigned long\t\tflags;\n\tu8\t\t\tcntl_cache;\n\tstruct iio_mount_matrix orientation;\n\tstruct regulator\t*vdd;\n\tstruct regulator\t*vid;\n\n\t \n\tstruct {\n\t\ts16 channels[3];\n\t\ts64 ts __aligned(8);\n\t} scan;\n};\n\n \nstatic int ak8975_power_on(const struct ak8975_data *data)\n{\n\tint ret;\n\n\tret = regulator_enable(data->vdd);\n\tif (ret) {\n\t\tdev_warn(&data->client->dev,\n\t\t\t \"Failed to enable specified Vdd supply\\n\");\n\t\treturn ret;\n\t}\n\tret = regulator_enable(data->vid);\n\tif (ret) {\n\t\tdev_warn(&data->client->dev,\n\t\t\t \"Failed to enable specified Vid supply\\n\");\n\t\tregulator_disable(data->vdd);\n\t\treturn ret;\n\t}\n\n\tgpiod_set_value_cansleep(data->reset_gpiod, 0);\n\n\t \n\tusleep_range(500, 1000);\n\treturn 0;\n}\n\n \nstatic void ak8975_power_off(const struct ak8975_data *data)\n{\n\tgpiod_set_value_cansleep(data->reset_gpiod, 1);\n\n\tregulator_disable(data->vid);\n\tregulator_disable(data->vdd);\n}\n\n \nstatic int ak8975_who_i_am(struct i2c_client *client,\n\t\t\t   enum asahi_compass_chipset type)\n{\n\tu8 wia_val[2];\n\tint ret;\n\n\t \n\tret = i2c_smbus_read_i2c_block_data_or_emulated(\n\t\t\tclient, AK09912_REG_WIA1, 2, wia_val);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Error reading WIA\\n\");\n\t\treturn ret;\n\t}\n\n\tif (wia_val[0] != AK8975_DEVICE_ID)\n\t\treturn -ENODEV;\n\n\tswitch (type) {\n\tcase AK8975:\n\tcase AK8963:\n\t\treturn 0;\n\tcase AK09911:\n\t\tif (wia_val[1] == AK09911_DEVICE_ID)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase AK09912:\n\t\tif (wia_val[1] == AK09912_DEVICE_ID)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase AK09916:\n\t\tif (wia_val[1] == AK09916_DEVICE_ID)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, \"Type %d unknown\\n\", type);\n\t}\n\treturn -ENODEV;\n}\n\n \nstatic int ak8975_set_mode(struct ak8975_data *data, enum ak_ctrl_mode mode)\n{\n\tu8 regval;\n\tint ret;\n\n\tregval = (data->cntl_cache & ~data->def->ctrl_masks[CNTL_MODE]) |\n\t\t data->def->ctrl_modes[mode];\n\tret = i2c_smbus_write_byte_data(data->client,\n\t\t\t\t\tdata->def->ctrl_regs[CNTL], regval);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\tdata->cntl_cache = regval;\n\t \n\tusleep_range(100, 500);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t ak8975_irq_handler(int irq, void *data)\n{\n\tstruct ak8975_data *ak8975 = data;\n\n\tset_bit(0, &ak8975->flags);\n\twake_up(&ak8975->data_ready_queue);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int ak8975_setup_irq(struct ak8975_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint rc;\n\tint irq;\n\n\tinit_waitqueue_head(&data->data_ready_queue);\n\tclear_bit(0, &data->flags);\n\tif (client->irq)\n\t\tirq = client->irq;\n\telse\n\t\tirq = gpiod_to_irq(data->eoc_gpiod);\n\n\trc = devm_request_irq(&client->dev, irq, ak8975_irq_handler,\n\t\t\t      IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t      dev_name(&client->dev), data);\n\tif (rc < 0) {\n\t\tdev_err(&client->dev, \"irq %d request failed: %d\\n\", irq, rc);\n\t\treturn rc;\n\t}\n\n\tdata->eoc_irq = irq;\n\n\treturn rc;\n}\n\n\n \nstatic int ak8975_setup(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct ak8975_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\t \n\tret = ak8975_set_mode(data, FUSE_ROM);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Error in setting fuse access mode\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = i2c_smbus_read_i2c_block_data_or_emulated(\n\t\t\tclient, data->def->ctrl_regs[ASA_BASE],\n\t\t\t3, data->asa);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Not able to read asa data\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ak8975_set_mode(data, POWER_DOWN);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Error in setting power-down mode\\n\");\n\t\treturn ret;\n\t}\n\n\tif (data->eoc_gpiod || client->irq > 0) {\n\t\tret = ak8975_setup_irq(data);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Error setting data ready interrupt\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdata->raw_to_gauss[0] = data->def->raw_to_gauss(data->asa[0]);\n\tdata->raw_to_gauss[1] = data->def->raw_to_gauss(data->asa[1]);\n\tdata->raw_to_gauss[2] = data->def->raw_to_gauss(data->asa[2]);\n\n\treturn 0;\n}\n\nstatic int wait_conversion_complete_gpio(struct ak8975_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tu32 timeout_ms = AK8975_MAX_CONVERSION_TIMEOUT;\n\tint ret;\n\n\t \n\twhile (timeout_ms) {\n\t\tmsleep(AK8975_CONVERSION_DONE_POLL_TIME);\n\t\tif (gpiod_get_value(data->eoc_gpiod))\n\t\t\tbreak;\n\t\ttimeout_ms -= AK8975_CONVERSION_DONE_POLL_TIME;\n\t}\n\tif (!timeout_ms) {\n\t\tdev_err(&client->dev, \"Conversion timeout happened\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = i2c_smbus_read_byte_data(client, data->def->ctrl_regs[ST1]);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Error in reading ST1\\n\");\n\n\treturn ret;\n}\n\nstatic int wait_conversion_complete_polled(struct ak8975_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tu8 read_status;\n\tu32 timeout_ms = AK8975_MAX_CONVERSION_TIMEOUT;\n\tint ret;\n\n\t \n\twhile (timeout_ms) {\n\t\tmsleep(AK8975_CONVERSION_DONE_POLL_TIME);\n\t\tret = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t       data->def->ctrl_regs[ST1]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"Error in reading ST1\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tread_status = ret;\n\t\tif (read_status)\n\t\t\tbreak;\n\t\ttimeout_ms -= AK8975_CONVERSION_DONE_POLL_TIME;\n\t}\n\tif (!timeout_ms) {\n\t\tdev_err(&client->dev, \"Conversion timeout happened\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn read_status;\n}\n\n \nstatic int wait_conversion_complete_interrupt(struct ak8975_data *data)\n{\n\tint ret;\n\n\tret = wait_event_timeout(data->data_ready_queue,\n\t\t\t\t test_bit(0, &data->flags),\n\t\t\t\t AK8975_DATA_READY_TIMEOUT);\n\tclear_bit(0, &data->flags);\n\n\treturn ret > 0 ? 0 : -ETIME;\n}\n\nstatic int ak8975_start_read_axis(struct ak8975_data *data,\n\t\t\t\t  const struct i2c_client *client)\n{\n\t \n\tint ret = ak8975_set_mode(data, MODE_ONCE);\n\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Error in setting operating mode\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (data->eoc_irq)\n\t\tret = wait_conversion_complete_interrupt(data);\n\telse if (data->eoc_gpiod)\n\t\tret = wait_conversion_complete_gpio(data);\n\telse\n\t\tret = wait_conversion_complete_polled(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ret & data->def->ctrl_masks[ST1_DRDY]) {\n\t\tret = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t       data->def->ctrl_regs[ST2]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"Error in reading ST2\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (ret & (data->def->ctrl_masks[ST2_DERR] |\n\t\t\t   data->def->ctrl_masks[ST2_HOFL])) {\n\t\t\tdev_err(&client->dev, \"ST2 status error 0x%x\\n\", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ak8975_read_axis(struct iio_dev *indio_dev, int index, int *val)\n{\n\tstruct ak8975_data *data = iio_priv(indio_dev);\n\tconst struct i2c_client *client = data->client;\n\tconst struct ak_def *def = data->def;\n\t__le16 rval;\n\tu16 buff;\n\tint ret;\n\n\tpm_runtime_get_sync(&data->client->dev);\n\n\tmutex_lock(&data->lock);\n\n\tret = ak8975_start_read_axis(data, client);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = i2c_smbus_read_i2c_block_data_or_emulated(\n\t\t\tclient, def->data_regs[index],\n\t\t\tsizeof(rval), (u8*)&rval);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tmutex_unlock(&data->lock);\n\n\tpm_runtime_mark_last_busy(&data->client->dev);\n\tpm_runtime_put_autosuspend(&data->client->dev);\n\n\t \n\tbuff = le16_to_cpu(rval);\n\t*val = clamp_t(s16, buff, -def->range, def->range);\n\treturn IIO_VAL_INT;\n\nexit:\n\tmutex_unlock(&data->lock);\n\tdev_err(&client->dev, \"Error in reading axis\\n\");\n\treturn ret;\n}\n\nstatic int ak8975_read_raw(struct iio_dev *indio_dev,\n\t\t\t   struct iio_chan_spec const *chan,\n\t\t\t   int *val, int *val2,\n\t\t\t   long mask)\n{\n\tstruct ak8975_data *data = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\treturn ak8975_read_axis(indio_dev, chan->address, val);\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\t*val2 = data->raw_to_gauss[chan->address];\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct iio_mount_matrix *\nak8975_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\tconst struct iio_chan_spec *chan)\n{\n\tstruct ak8975_data *data = iio_priv(indio_dev);\n\n\treturn &data->orientation;\n}\n\nstatic const struct iio_chan_spec_ext_info ak8975_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_DIR, ak8975_get_mount_matrix),\n\t{ }\n};\n\n#define AK8975_CHANNEL(axis, index)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.type = IIO_MAGN,\t\t\t\t\t\\\n\t\t.modified = 1,\t\t\t\t\t\t\\\n\t\t.channel2 = IIO_MOD_##axis,\t\t\t\t\\\n\t\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\t\\\n\t\t\t     BIT(IIO_CHAN_INFO_SCALE),\t\t\t\\\n\t\t.address = index,\t\t\t\t\t\\\n\t\t.scan_index = index,\t\t\t\t\t\\\n\t\t.scan_type = {\t\t\t\t\t\t\\\n\t\t\t.sign = 's',\t\t\t\t\t\\\n\t\t\t.realbits = 16,\t\t\t\t\t\\\n\t\t\t.storagebits = 16,\t\t\t\t\\\n\t\t\t.endianness = IIO_CPU\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.ext_info = ak8975_ext_info,\t\t\t\t\\\n\t}\n\nstatic const struct iio_chan_spec ak8975_channels[] = {\n\tAK8975_CHANNEL(X, 0), AK8975_CHANNEL(Y, 1), AK8975_CHANNEL(Z, 2),\n\tIIO_CHAN_SOFT_TIMESTAMP(3),\n};\n\nstatic const unsigned long ak8975_scan_masks[] = { 0x7, 0 };\n\nstatic const struct iio_info ak8975_info = {\n\t.read_raw = &ak8975_read_raw,\n};\n\nstatic const struct acpi_device_id ak_acpi_match[] = {\n\t{\"AK8975\", AK8975},\n\t{\"AK8963\", AK8963},\n\t{\"INVN6500\", AK8963},\n\t{\"AK009911\", AK09911},\n\t{\"AK09911\", AK09911},\n\t{\"AKM9911\", AK09911},\n\t{\"AK09912\", AK09912},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, ak_acpi_match);\n\nstatic void ak8975_fill_buffer(struct iio_dev *indio_dev)\n{\n\tstruct ak8975_data *data = iio_priv(indio_dev);\n\tconst struct i2c_client *client = data->client;\n\tconst struct ak_def *def = data->def;\n\tint ret;\n\t__le16 fval[3];\n\n\tmutex_lock(&data->lock);\n\n\tret = ak8975_start_read_axis(data, client);\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tret = i2c_smbus_read_i2c_block_data_or_emulated(client,\n\t\t\t\t\t\t\tdef->data_regs[0],\n\t\t\t\t\t\t\t3 * sizeof(fval[0]),\n\t\t\t\t\t\t\t(u8 *)fval);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tmutex_unlock(&data->lock);\n\n\t \n\tdata->scan.channels[0] = clamp_t(s16, le16_to_cpu(fval[0]), -def->range, def->range);\n\tdata->scan.channels[1] = clamp_t(s16, le16_to_cpu(fval[1]), -def->range, def->range);\n\tdata->scan.channels[2] = clamp_t(s16, le16_to_cpu(fval[2]), -def->range, def->range);\n\n\tiio_push_to_buffers_with_timestamp(indio_dev, &data->scan,\n\t\t\t\t\t   iio_get_time_ns(indio_dev));\n\n\treturn;\n\nunlock:\n\tmutex_unlock(&data->lock);\n\tdev_err(&client->dev, \"Error in reading axes block\\n\");\n}\n\nstatic irqreturn_t ak8975_handle_trigger(int irq, void *p)\n{\n\tconst struct iio_poll_func *pf = p;\n\tstruct iio_dev *indio_dev = pf->indio_dev;\n\n\tak8975_fill_buffer(indio_dev);\n\tiio_trigger_notify_done(indio_dev->trig);\n\treturn IRQ_HANDLED;\n}\n\nstatic int ak8975_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct ak8975_data *data;\n\tstruct iio_dev *indio_dev;\n\tstruct gpio_desc *eoc_gpiod;\n\tstruct gpio_desc *reset_gpiod;\n\tconst void *match;\n\tunsigned int i;\n\tint err;\n\tenum asahi_compass_chipset chipset;\n\tconst char *name = NULL;\n\n\t \n\teoc_gpiod = devm_gpiod_get_optional(&client->dev, NULL, GPIOD_IN);\n\tif (IS_ERR(eoc_gpiod))\n\t\treturn PTR_ERR(eoc_gpiod);\n\tif (eoc_gpiod)\n\t\tgpiod_set_consumer_name(eoc_gpiod, \"ak_8975\");\n\n\t \n\treset_gpiod = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t      \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(reset_gpiod))\n\t\treturn PTR_ERR(reset_gpiod);\n\n\t \n\tindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\n\tif (indio_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdata = iio_priv(indio_dev);\n\ti2c_set_clientdata(client, indio_dev);\n\n\tdata->client = client;\n\tdata->eoc_gpiod = eoc_gpiod;\n\tdata->reset_gpiod = reset_gpiod;\n\tdata->eoc_irq = 0;\n\n\terr = iio_read_mount_matrix(&client->dev, &data->orientation);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmatch = device_get_match_data(&client->dev);\n\tif (match) {\n\t\tchipset = (uintptr_t)match;\n\t\tname = dev_name(&client->dev);\n\t} else if (id) {\n\t\tchipset = (enum asahi_compass_chipset)(id->driver_data);\n\t\tname = id->name;\n\t} else\n\t\treturn -ENOSYS;\n\n\tfor (i = 0; i < ARRAY_SIZE(ak_def_array); i++)\n\t\tif (ak_def_array[i].type == chipset)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(ak_def_array)) {\n\t\tdev_err(&client->dev, \"AKM device type unsupported: %d\\n\",\n\t\t\tchipset);\n\t\treturn -ENODEV;\n\t}\n\n\tdata->def = &ak_def_array[i];\n\n\t \n\tdata->vdd = devm_regulator_get(&client->dev, \"vdd\");\n\tif (IS_ERR(data->vdd))\n\t\treturn PTR_ERR(data->vdd);\n\tdata->vid = devm_regulator_get(&client->dev, \"vid\");\n\tif (IS_ERR(data->vid))\n\t\treturn PTR_ERR(data->vid);\n\n\terr = ak8975_power_on(data);\n\tif (err)\n\t\treturn err;\n\n\terr = ak8975_who_i_am(client, data->def->type);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Unexpected device\\n\");\n\t\tgoto power_off;\n\t}\n\tdev_dbg(&client->dev, \"Asahi compass chip %s\\n\", name);\n\n\t \n\terr = ak8975_setup(client);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"%s initialization fails\\n\", name);\n\t\tgoto power_off;\n\t}\n\n\tmutex_init(&data->lock);\n\tindio_dev->channels = ak8975_channels;\n\tindio_dev->num_channels = ARRAY_SIZE(ak8975_channels);\n\tindio_dev->info = &ak8975_info;\n\tindio_dev->available_scan_masks = ak8975_scan_masks;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->name = name;\n\n\terr = iio_triggered_buffer_setup(indio_dev, NULL, ak8975_handle_trigger,\n\t\t\t\t\t NULL);\n\tif (err) {\n\t\tdev_err(&client->dev, \"triggered buffer setup failed\\n\");\n\t\tgoto power_off;\n\t}\n\n\terr = iio_device_register(indio_dev);\n\tif (err) {\n\t\tdev_err(&client->dev, \"device register failed\\n\");\n\t\tgoto cleanup_buffer;\n\t}\n\n\t \n\tpm_runtime_get_noresume(&client->dev);\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\t \n\tpm_runtime_set_autosuspend_delay(&client->dev, 50);\n\tpm_runtime_use_autosuspend(&client->dev);\n\tpm_runtime_put(&client->dev);\n\n\treturn 0;\n\ncleanup_buffer:\n\tiio_triggered_buffer_cleanup(indio_dev);\npower_off:\n\tak8975_power_off(data);\n\treturn err;\n}\n\nstatic void ak8975_remove(struct i2c_client *client)\n{\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct ak8975_data *data = iio_priv(indio_dev);\n\n\tpm_runtime_get_sync(&client->dev);\n\tpm_runtime_put_noidle(&client->dev);\n\tpm_runtime_disable(&client->dev);\n\tiio_device_unregister(indio_dev);\n\tiio_triggered_buffer_cleanup(indio_dev);\n\tak8975_set_mode(data, POWER_DOWN);\n\tak8975_power_off(data);\n}\n\nstatic int ak8975_runtime_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct ak8975_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\t \n\tret = ak8975_set_mode(data, POWER_DOWN);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Error in setting power-down mode\\n\");\n\t\treturn ret;\n\t}\n\t \n\tak8975_power_off(data);\n\n\treturn 0;\n}\n\nstatic int ak8975_runtime_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct iio_dev *indio_dev = i2c_get_clientdata(client);\n\tstruct ak8975_data *data = iio_priv(indio_dev);\n\tint ret;\n\n\t \n\tak8975_power_on(data);\n\t \n\tret = ak8975_set_mode(data, POWER_DOWN);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Error in setting power-down mode\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(ak8975_dev_pm_ops, ak8975_runtime_suspend,\n\t\t\t\t ak8975_runtime_resume, NULL);\n\nstatic const struct i2c_device_id ak8975_id[] = {\n\t{\"ak8975\", AK8975},\n\t{\"ak8963\", AK8963},\n\t{\"AK8963\", AK8963},\n\t{\"ak09911\", AK09911},\n\t{\"ak09912\", AK09912},\n\t{\"ak09916\", AK09916},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, ak8975_id);\n\nstatic const struct of_device_id ak8975_of_match[] = {\n\t{ .compatible = \"asahi-kasei,ak8975\", },\n\t{ .compatible = \"ak8975\", },\n\t{ .compatible = \"asahi-kasei,ak8963\", },\n\t{ .compatible = \"ak8963\", },\n\t{ .compatible = \"asahi-kasei,ak09911\", },\n\t{ .compatible = \"ak09911\", },\n\t{ .compatible = \"asahi-kasei,ak09912\", },\n\t{ .compatible = \"ak09912\", },\n\t{ .compatible = \"asahi-kasei,ak09916\", },\n\t{ .compatible = \"ak09916\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ak8975_of_match);\n\nstatic struct i2c_driver ak8975_driver = {\n\t.driver = {\n\t\t.name\t= \"ak8975\",\n\t\t.pm = pm_ptr(&ak8975_dev_pm_ops),\n\t\t.of_match_table = ak8975_of_match,\n\t\t.acpi_match_table = ak_acpi_match,\n\t},\n\t.probe\t\t= ak8975_probe,\n\t.remove\t\t= ak8975_remove,\n\t.id_table\t= ak8975_id,\n};\nmodule_i2c_driver(ak8975_driver);\n\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_DESCRIPTION(\"AK8975 magnetometer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}