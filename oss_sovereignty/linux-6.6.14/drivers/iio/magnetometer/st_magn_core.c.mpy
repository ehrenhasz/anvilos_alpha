{
  "module_name": "st_magn_core.c",
  "hash_id": "49a7893d7189229a3418eaf7fe69e03ab164c4c172c212907e1e7e37f34544b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iio/magnetometer/st_magn_core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/sysfs.h>\n#include <linux/iio/trigger.h>\n\n#include <linux/iio/common/st_sensors.h>\n#include \"st_magn.h\"\n\n#define ST_MAGN_NUMBER_DATA_CHANNELS\t\t3\n\n \n#define ST_MAGN_DEFAULT_OUT_X_H_ADDR\t\t0x03\n#define ST_MAGN_DEFAULT_OUT_Y_H_ADDR\t\t0x07\n#define ST_MAGN_DEFAULT_OUT_Z_H_ADDR\t\t0x05\n\n \n#define ST_MAGN_FS_AVL_1300MG\t\t\t1300\n#define ST_MAGN_FS_AVL_1900MG\t\t\t1900\n#define ST_MAGN_FS_AVL_2000MG\t\t\t2000\n#define ST_MAGN_FS_AVL_2500MG\t\t\t2500\n#define ST_MAGN_FS_AVL_4000MG\t\t\t4000\n#define ST_MAGN_FS_AVL_4700MG\t\t\t4700\n#define ST_MAGN_FS_AVL_5600MG\t\t\t5600\n#define ST_MAGN_FS_AVL_8000MG\t\t\t8000\n#define ST_MAGN_FS_AVL_8100MG\t\t\t8100\n#define ST_MAGN_FS_AVL_12000MG\t\t\t12000\n#define ST_MAGN_FS_AVL_15000MG\t\t\t15000\n#define ST_MAGN_FS_AVL_16000MG\t\t\t16000\n\n \n#define ST_MAGN_2_OUT_X_L_ADDR\t\t\t0x28\n#define ST_MAGN_2_OUT_Y_L_ADDR\t\t\t0x2a\n#define ST_MAGN_2_OUT_Z_L_ADDR\t\t\t0x2c\n\n \n#define ST_MAGN_3_OUT_X_L_ADDR\t\t\t0x68\n#define ST_MAGN_3_OUT_Y_L_ADDR\t\t\t0x6a\n#define ST_MAGN_3_OUT_Z_L_ADDR\t\t\t0x6c\n\n \n#define ST_MAGN_4_OUT_X_L_ADDR\t\t\t0x08\n#define ST_MAGN_4_OUT_Y_L_ADDR\t\t\t0x0a\n#define ST_MAGN_4_OUT_Z_L_ADDR\t\t\t0x0c\n\nstatic const struct iio_mount_matrix *\nst_magn_get_mount_matrix(const struct iio_dev *indio_dev,\n\t\t\t const struct iio_chan_spec *chan)\n{\n\tstruct st_sensor_data *mdata = iio_priv(indio_dev);\n\n\treturn &mdata->mount_matrix;\n}\n\nstatic const struct iio_chan_spec_ext_info st_magn_mount_matrix_ext_info[] = {\n\tIIO_MOUNT_MATRIX(IIO_SHARED_BY_ALL, st_magn_get_mount_matrix),\n\t{ }\n};\n\nstatic const struct iio_chan_spec st_magn_16bit_channels[] = {\n\tST_SENSORS_LSM_CHANNELS_EXT(IIO_MAGN,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_X, 1, IIO_MOD_X, 's', IIO_BE, 16, 16,\n\t\t\tST_MAGN_DEFAULT_OUT_X_H_ADDR,\n\t\t\tst_magn_mount_matrix_ext_info),\n\tST_SENSORS_LSM_CHANNELS_EXT(IIO_MAGN,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_Y, 1, IIO_MOD_Y, 's', IIO_BE, 16, 16,\n\t\t\tST_MAGN_DEFAULT_OUT_Y_H_ADDR,\n\t\t\tst_magn_mount_matrix_ext_info),\n\tST_SENSORS_LSM_CHANNELS_EXT(IIO_MAGN,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_Z, 1, IIO_MOD_Z, 's', IIO_BE, 16, 16,\n\t\t\tST_MAGN_DEFAULT_OUT_Z_H_ADDR,\n\t\t\tst_magn_mount_matrix_ext_info),\n\tIIO_CHAN_SOFT_TIMESTAMP(3)\n};\n\nstatic const struct iio_chan_spec st_magn_2_16bit_channels[] = {\n\tST_SENSORS_LSM_CHANNELS_EXT(IIO_MAGN,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_X, 1, IIO_MOD_X, 's', IIO_LE, 16, 16,\n\t\t\tST_MAGN_2_OUT_X_L_ADDR,\n\t\t\tst_magn_mount_matrix_ext_info),\n\tST_SENSORS_LSM_CHANNELS_EXT(IIO_MAGN,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_Y, 1, IIO_MOD_Y, 's', IIO_LE, 16, 16,\n\t\t\tST_MAGN_2_OUT_Y_L_ADDR,\n\t\t\tst_magn_mount_matrix_ext_info),\n\tST_SENSORS_LSM_CHANNELS_EXT(IIO_MAGN,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_Z, 1, IIO_MOD_Z, 's', IIO_LE, 16, 16,\n\t\t\tST_MAGN_2_OUT_Z_L_ADDR,\n\t\t\tst_magn_mount_matrix_ext_info),\n\tIIO_CHAN_SOFT_TIMESTAMP(3)\n};\n\nstatic const struct iio_chan_spec st_magn_3_16bit_channels[] = {\n\tST_SENSORS_LSM_CHANNELS_EXT(IIO_MAGN,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_X, 1, IIO_MOD_X, 's', IIO_LE, 16, 16,\n\t\t\tST_MAGN_3_OUT_X_L_ADDR,\n\t\t\tst_magn_mount_matrix_ext_info),\n\tST_SENSORS_LSM_CHANNELS_EXT(IIO_MAGN,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_Y, 1, IIO_MOD_Y, 's', IIO_LE, 16, 16,\n\t\t\tST_MAGN_3_OUT_Y_L_ADDR,\n\t\t\tst_magn_mount_matrix_ext_info),\n\tST_SENSORS_LSM_CHANNELS_EXT(IIO_MAGN,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_Z, 1, IIO_MOD_Z, 's', IIO_LE, 16, 16,\n\t\t\tST_MAGN_3_OUT_Z_L_ADDR,\n\t\t\tst_magn_mount_matrix_ext_info),\n\tIIO_CHAN_SOFT_TIMESTAMP(3)\n};\n\nstatic const struct iio_chan_spec st_magn_4_16bit_channels[] = {\n\tST_SENSORS_LSM_CHANNELS(IIO_MAGN,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_X, 1, IIO_MOD_X, 's', IIO_LE, 16, 16,\n\t\t\tST_MAGN_4_OUT_X_L_ADDR),\n\tST_SENSORS_LSM_CHANNELS(IIO_MAGN,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_Y, 1, IIO_MOD_Y, 's', IIO_LE, 16, 16,\n\t\t\tST_MAGN_4_OUT_Y_L_ADDR),\n\tST_SENSORS_LSM_CHANNELS(IIO_MAGN,\n\t\t\tBIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),\n\t\t\tST_SENSORS_SCAN_Z, 1, IIO_MOD_Z, 's', IIO_LE, 16, 16,\n\t\t\tST_MAGN_4_OUT_Z_L_ADDR),\n\tIIO_CHAN_SOFT_TIMESTAMP(3)\n};\n\nstatic const struct st_sensor_settings st_magn_sensors_settings[] = {\n\t{\n\t\t.wai = 0,  \n\t\t.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,\n\t\t.sensors_supported = {\n\t\t\t[0] = LSM303DLH_MAGN_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_magn_16bit_channels,\n\t\t.odr = {\n\t\t\t.addr = 0x00,\n\t\t\t.mask = 0x1c,\n\t\t\t.odr_avl = {\n\t\t\t\t{ .hz = 1, .value = 0x00 },\n\t\t\t\t{ .hz = 2, .value = 0x01 },\n\t\t\t\t{ .hz = 3, .value = 0x02 },\n\t\t\t\t{ .hz = 8, .value = 0x03 },\n\t\t\t\t{ .hz = 15, .value = 0x04 },\n\t\t\t\t{ .hz = 30, .value = 0x05 },\n\t\t\t\t{ .hz = 75, .value = 0x06 },\n\t\t\t\t \n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x02,\n\t\t\t.mask = 0x03,\n\t\t\t.value_on = 0x00,\n\t\t\t.value_off = 0x03,\n\t\t},\n\t\t.fs = {\n\t\t\t.addr = 0x01,\n\t\t\t.mask = 0xe0,\n\t\t\t.fs_avl = {\n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_1300MG,\n\t\t\t\t\t.value = 0x01,\n\t\t\t\t\t.gain = 1100,\n\t\t\t\t\t.gain2 = 980,\n\t\t\t\t},\n\t\t\t\t[1] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_1900MG,\n\t\t\t\t\t.value = 0x02,\n\t\t\t\t\t.gain = 855,\n\t\t\t\t\t.gain2 = 760,\n\t\t\t\t},\n\t\t\t\t[2] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_2500MG,\n\t\t\t\t\t.value = 0x03,\n\t\t\t\t\t.gain = 670,\n\t\t\t\t\t.gain2 = 600,\n\t\t\t\t},\n\t\t\t\t[3] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_4000MG,\n\t\t\t\t\t.value = 0x04,\n\t\t\t\t\t.gain = 450,\n\t\t\t\t\t.gain2 = 400,\n\t\t\t\t},\n\t\t\t\t[4] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_4700MG,\n\t\t\t\t\t.value = 0x05,\n\t\t\t\t\t.gain = 400,\n\t\t\t\t\t.gain2 = 355,\n\t\t\t\t},\n\t\t\t\t[5] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_5600MG,\n\t\t\t\t\t.value = 0x06,\n\t\t\t\t\t.gain = 330,\n\t\t\t\t\t.gain2 = 295,\n\t\t\t\t},\n\t\t\t\t[6] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_8100MG,\n\t\t\t\t\t.value = 0x07,\n\t\t\t\t\t.gain = 230,\n\t\t\t\t\t.gain2 = 205,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.multi_read_bit = false,\n\t\t.bootime = 2,\n\t},\n\t{\n\t\t.wai = 0x3c,\n\t\t.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,\n\t\t.sensors_supported = {\n\t\t\t[0] = LSM303DLHC_MAGN_DEV_NAME,\n\t\t\t[1] = LSM303DLM_MAGN_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_magn_16bit_channels,\n\t\t.odr = {\n\t\t\t.addr = 0x00,\n\t\t\t.mask = 0x1c,\n\t\t\t.odr_avl = {\n\t\t\t\t{ .hz = 1, .value = 0x00 },\n\t\t\t\t{ .hz = 2, .value = 0x01 },\n\t\t\t\t{ .hz = 3, .value = 0x02 },\n\t\t\t\t{ .hz = 8, .value = 0x03 },\n\t\t\t\t{ .hz = 15, .value = 0x04 },\n\t\t\t\t{ .hz = 30, .value = 0x05 },\n\t\t\t\t{ .hz = 75, .value = 0x06 },\n\t\t\t\t{ .hz = 220, .value = 0x07 },\n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x02,\n\t\t\t.mask = 0x03,\n\t\t\t.value_on = 0x00,\n\t\t\t.value_off = 0x03,\n\t\t},\n\t\t.fs = {\n\t\t\t.addr = 0x01,\n\t\t\t.mask = 0xe0,\n\t\t\t.fs_avl = {\n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_1300MG,\n\t\t\t\t\t.value = 0x01,\n\t\t\t\t\t.gain = 909,\n\t\t\t\t\t.gain2 = 1020,\n\t\t\t\t},\n\t\t\t\t[1] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_1900MG,\n\t\t\t\t\t.value = 0x02,\n\t\t\t\t\t.gain = 1169,\n\t\t\t\t\t.gain2 = 1315,\n\t\t\t\t},\n\t\t\t\t[2] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_2500MG,\n\t\t\t\t\t.value = 0x03,\n\t\t\t\t\t.gain = 1492,\n\t\t\t\t\t.gain2 = 1666,\n\t\t\t\t},\n\t\t\t\t[3] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_4000MG,\n\t\t\t\t\t.value = 0x04,\n\t\t\t\t\t.gain = 2222,\n\t\t\t\t\t.gain2 = 2500,\n\t\t\t\t},\n\t\t\t\t[4] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_4700MG,\n\t\t\t\t\t.value = 0x05,\n\t\t\t\t\t.gain = 2500,\n\t\t\t\t\t.gain2 = 2816,\n\t\t\t\t},\n\t\t\t\t[5] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_5600MG,\n\t\t\t\t\t.value = 0x06,\n\t\t\t\t\t.gain = 3030,\n\t\t\t\t\t.gain2 = 3389,\n\t\t\t\t},\n\t\t\t\t[6] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_8100MG,\n\t\t\t\t\t.value = 0x07,\n\t\t\t\t\t.gain = 4347,\n\t\t\t\t\t.gain2 = 4878,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.multi_read_bit = false,\n\t\t.bootime = 2,\n\t},\n\t{\n\t\t.wai = 0x3d,\n\t\t.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,\n\t\t.sensors_supported = {\n\t\t\t[0] = LIS3MDL_MAGN_DEV_NAME,\n\t\t\t[1] = LSM9DS1_MAGN_DEV_NAME,\n\t\t\t[2] = LSM303C_MAGN_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_magn_2_16bit_channels,\n\t\t.odr = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = 0x1c,\n\t\t\t.odr_avl = {\n\t\t\t\t{ .hz = 1, .value = 0x00 },\n\t\t\t\t{ .hz = 2, .value = 0x01 },\n\t\t\t\t{ .hz = 3, .value = 0x02 },\n\t\t\t\t{ .hz = 5, .value = 0x03 },\n\t\t\t\t{ .hz = 10, .value = 0x04 },\n\t\t\t\t{ .hz = 20, .value = 0x05 },\n\t\t\t\t{ .hz = 40, .value = 0x06 },\n\t\t\t\t{ .hz = 80, .value = 0x07 },\n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x22,\n\t\t\t.mask = 0x03,\n\t\t\t.value_on = 0x00,\n\t\t\t.value_off = 0x03,\n\t\t},\n\t\t.fs = {\n\t\t\t.addr = 0x21,\n\t\t\t.mask = 0x60,\n\t\t\t.fs_avl = {\n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_4000MG,\n\t\t\t\t\t.value = 0x00,\n\t\t\t\t\t.gain = 146,\n\t\t\t\t},\n\t\t\t\t[1] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_8000MG,\n\t\t\t\t\t.value = 0x01,\n\t\t\t\t\t.gain = 292,\n\t\t\t\t},\n\t\t\t\t[2] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_12000MG,\n\t\t\t\t\t.value = 0x02,\n\t\t\t\t\t.gain = 438,\n\t\t\t\t},\n\t\t\t\t[3] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_16000MG,\n\t\t\t\t\t.value = 0x03,\n\t\t\t\t\t.gain = 584,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x24,\n\t\t\t.mask = 0x40,\n\t\t},\n\t\t.drdy_irq = {\n\t\t\t \n\t\t\t.stat_drdy = {\n\t\t\t\t.addr = ST_SENSORS_DEFAULT_STAT_ADDR,\n\t\t\t\t.mask = 0x07,\n\t\t\t},\n\t\t},\n\t\t.sim = {\n\t\t\t.addr = 0x22,\n\t\t\t.value = BIT(2),\n\t\t},\n\t\t.multi_read_bit = true,\n\t\t.bootime = 2,\n\t},\n\t{\n\t\t.wai = 0x40,\n\t\t.wai_addr = 0x4f,\n\t\t.sensors_supported = {\n\t\t\t[0] = LSM303AGR_MAGN_DEV_NAME,\n\t\t\t[1] = LIS2MDL_MAGN_DEV_NAME,\n\t\t\t[2] = IIS2MDC_MAGN_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_magn_3_16bit_channels,\n\t\t.odr = {\n\t\t\t.addr = 0x60,\n\t\t\t.mask = 0x0c,\n\t\t\t.odr_avl = {\n\t\t\t\t{ .hz = 10, .value = 0x00 },\n\t\t\t\t{ .hz = 20, .value = 0x01 },\n\t\t\t\t{ .hz = 50, .value = 0x02 },\n\t\t\t\t{ .hz = 100, .value = 0x03 },\n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x60,\n\t\t\t.mask = 0x03,\n\t\t\t.value_on = 0x00,\n\t\t\t.value_off = 0x03,\n\t\t},\n\t\t.fs = {\n\t\t\t.fs_avl = {\n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_15000MG,\n\t\t\t\t\t.gain = 1500,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x62,\n\t\t\t.mask = 0x10,\n\t\t},\n\t\t.drdy_irq = {\n\t\t\t.int1 = {\n\t\t\t\t.addr = 0x62,\n\t\t\t\t.mask = 0x01,\n\t\t\t},\n\t\t\t.stat_drdy = {\n\t\t\t\t.addr = 0x67,\n\t\t\t\t.mask = 0x07,\n\t\t\t},\n\t\t},\n\t\t.multi_read_bit = false,\n\t\t.bootime = 2,\n\t},\n\t{\n\t\t.wai = 0x49,\n\t\t.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,\n\t\t.sensors_supported = {\n\t\t\t[0] = LSM9DS0_IMU_DEV_NAME,\n\t\t\t[1] = LSM303D_IMU_DEV_NAME,\n\t\t},\n\t\t.ch = (struct iio_chan_spec *)st_magn_4_16bit_channels,\n\t\t.odr = {\n\t\t\t.addr = 0x24,\n\t\t\t.mask = GENMASK(4, 2),\n\t\t\t.odr_avl = {\n\t\t\t\t{ 3, 0x00, },\n\t\t\t\t{ 6, 0x01, },\n\t\t\t\t{ 12, 0x02, },\n\t\t\t\t{ 25, 0x03, },\n\t\t\t\t{ 50, 0x04, },\n\t\t\t\t{ 100, 0x05, },\n\t\t\t},\n\t\t},\n\t\t.pw = {\n\t\t\t.addr = 0x26,\n\t\t\t.mask = GENMASK(1, 0),\n\t\t\t.value_on = 0x00,\n\t\t\t.value_off = 0x03,\n\t\t},\n\t\t.fs = {\n\t\t\t.addr = 0x25,\n\t\t\t.mask = GENMASK(6, 5),\n\t\t\t.fs_avl = {\n\t\t\t\t[0] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_2000MG,\n\t\t\t\t\t.value = 0x00,\n\t\t\t\t\t.gain = 73,\n\t\t\t\t},\n\t\t\t\t[1] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_4000MG,\n\t\t\t\t\t.value = 0x01,\n\t\t\t\t\t.gain = 146,\n\t\t\t\t},\n\t\t\t\t[2] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_8000MG,\n\t\t\t\t\t.value = 0x02,\n\t\t\t\t\t.gain = 292,\n\t\t\t\t},\n\t\t\t\t[3] = {\n\t\t\t\t\t.num = ST_MAGN_FS_AVL_12000MG,\n\t\t\t\t\t.value = 0x03,\n\t\t\t\t\t.gain = 438,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t.bdu = {\n\t\t\t.addr = 0x20,\n\t\t\t.mask = BIT(3),\n\t\t},\n\t\t.drdy_irq = {\n\t\t\t.int1 = {\n\t\t\t\t.addr = 0x22,\n\t\t\t\t.mask = BIT(1),\n\t\t\t},\n\t\t\t.int2 = {\n\t\t\t\t.addr = 0x23,\n\t\t\t\t.mask = BIT(2),\n\t\t\t},\n\t\t\t.stat_drdy = {\n\t\t\t\t.addr = 0x07,\n\t\t\t\t.mask = GENMASK(2, 0),\n\t\t\t},\n\t\t},\n\t\t.sim = {\n\t\t\t.addr = 0x21,\n\t\t\t.value = BIT(0),\n\t\t},\n\t\t.multi_read_bit = true,\n\t\t.bootime = 2,\n\t},\n};\n\n \nstatic const struct st_sensors_platform_data default_magn_pdata = {\n\t.drdy_int_pin = 2,\n};\n\nstatic int st_magn_read_raw(struct iio_dev *indio_dev,\n\t\t\tstruct iio_chan_spec const *ch, int *val,\n\t\t\t\t\t\t\tint *val2, long mask)\n{\n\tint err;\n\tstruct st_sensor_data *mdata = iio_priv(indio_dev);\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\terr = st_sensors_read_info_raw(indio_dev, ch, val);\n\t\tif (err < 0)\n\t\t\tgoto read_error;\n\n\t\treturn IIO_VAL_INT;\n\tcase IIO_CHAN_INFO_SCALE:\n\t\t*val = 0;\n\t\tif ((ch->scan_index == ST_SENSORS_SCAN_Z) &&\n\t\t\t\t\t(mdata->current_fullscale->gain2 != 0))\n\t\t\t*val2 = mdata->current_fullscale->gain2;\n\t\telse\n\t\t\t*val2 = mdata->current_fullscale->gain;\n\t\treturn IIO_VAL_INT_PLUS_MICRO;\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\t*val = mdata->odr;\n\t\treturn IIO_VAL_INT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\nread_error:\n\treturn err;\n}\n\nstatic int st_magn_write_raw(struct iio_dev *indio_dev,\n\t\tstruct iio_chan_spec const *chan, int val, int val2, long mask)\n{\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_SCALE:\n\t\treturn st_sensors_set_fullscale_by_gain(indio_dev, val2);\n\tcase IIO_CHAN_INFO_SAMP_FREQ:\n\t\tif (val2)\n\t\t\treturn -EINVAL;\n\n\t\treturn st_sensors_set_odr(indio_dev, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ST_SENSORS_DEV_ATTR_SAMP_FREQ_AVAIL();\nstatic ST_SENSORS_DEV_ATTR_SCALE_AVAIL(in_magn_scale_available);\n\nstatic struct attribute *st_magn_attributes[] = {\n\t&iio_dev_attr_sampling_frequency_available.dev_attr.attr,\n\t&iio_dev_attr_in_magn_scale_available.dev_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group st_magn_attribute_group = {\n\t.attrs = st_magn_attributes,\n};\n\nstatic const struct iio_info magn_info = {\n\t.attrs = &st_magn_attribute_group,\n\t.read_raw = &st_magn_read_raw,\n\t.write_raw = &st_magn_write_raw,\n\t.debugfs_reg_access = &st_sensors_debugfs_reg_access,\n};\n\n#ifdef CONFIG_IIO_TRIGGER\nstatic const struct iio_trigger_ops st_magn_trigger_ops = {\n\t.set_trigger_state = ST_MAGN_TRIGGER_SET_STATE,\n\t.validate_device = st_sensors_validate_device,\n};\n#define ST_MAGN_TRIGGER_OPS (&st_magn_trigger_ops)\n#else\n#define ST_MAGN_TRIGGER_OPS NULL\n#endif\n\n \nconst struct st_sensor_settings *st_magn_get_settings(const char *name)\n{\n\tint index = st_sensors_get_settings_index(name,\n\t\t\t\t\tst_magn_sensors_settings,\n\t\t\t\t\tARRAY_SIZE(st_magn_sensors_settings));\n\tif (index < 0)\n\t\treturn NULL;\n\n\treturn &st_magn_sensors_settings[index];\n}\nEXPORT_SYMBOL_NS(st_magn_get_settings, IIO_ST_SENSORS);\n\nint st_magn_common_probe(struct iio_dev *indio_dev)\n{\n\tstruct st_sensor_data *mdata = iio_priv(indio_dev);\n\tstruct device *parent = indio_dev->dev.parent;\n\tstruct st_sensors_platform_data *pdata = dev_get_platdata(parent);\n\tint err;\n\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &magn_info;\n\n\terr = st_sensors_verify_id(indio_dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tmdata->num_data_channels = ST_MAGN_NUMBER_DATA_CHANNELS;\n\tindio_dev->channels = mdata->sensor_settings->ch;\n\tindio_dev->num_channels = ST_SENSORS_NUMBER_ALL_CHANNELS;\n\n\terr = iio_read_mount_matrix(parent, &mdata->mount_matrix);\n\tif (err)\n\t\treturn err;\n\n\tmdata->current_fullscale = &mdata->sensor_settings->fs.fs_avl[0];\n\tmdata->odr = mdata->sensor_settings->odr.odr_avl[0].hz;\n\n\tif (!pdata)\n\t\tpdata = (struct st_sensors_platform_data *)&default_magn_pdata;\n\n\terr = st_sensors_init_sensor(indio_dev, pdata);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = st_magn_allocate_ring(indio_dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (mdata->irq > 0) {\n\t\terr = st_sensors_allocate_trigger(indio_dev,\n\t\t\t\t\t\tST_MAGN_TRIGGER_OPS);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn devm_iio_device_register(parent, indio_dev);\n}\nEXPORT_SYMBOL_NS(st_magn_common_probe, IIO_ST_SENSORS);\n\nMODULE_AUTHOR(\"Denis Ciocca <denis.ciocca@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics magnetometers driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(IIO_ST_SENSORS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}