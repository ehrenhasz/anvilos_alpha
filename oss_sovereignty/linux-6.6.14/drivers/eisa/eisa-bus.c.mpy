{
  "module_name": "eisa-bus.c",
  "hash_id": "cd73eb14df443868467c44cd1253cd46653b95e00d4572799e54e62ee1c4ea4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/eisa/eisa-bus.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/eisa.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <asm/io.h>\n\n#define SLOT_ADDRESS(r,n) (r->bus_base_addr + (0x1000 * n))\n\n#define EISA_DEVINFO(i,s) { .id = { .sig = i }, .name = s }\n\nstruct eisa_device_info {\n\tstruct eisa_device_id id;\n\tchar name[50];\n};\n\n#ifdef CONFIG_EISA_NAMES\nstatic struct eisa_device_info __initdata eisa_table[] = {\n#include \"devlist.h\"\n};\n#define EISA_INFOS (sizeof (eisa_table) / (sizeof (struct eisa_device_info)))\n#endif\n\n#define EISA_MAX_FORCED_DEV 16\n\nstatic int enable_dev[EISA_MAX_FORCED_DEV];\nstatic unsigned int enable_dev_count;\nstatic int disable_dev[EISA_MAX_FORCED_DEV];\nstatic unsigned int disable_dev_count;\n\nstatic int is_forced_dev(int *forced_tab,\n\t\t\t int forced_count,\n\t\t\t struct eisa_root_device *root,\n\t\t\t struct eisa_device *edev)\n{\n\tint i, x;\n\n\tfor (i = 0; i < forced_count; i++) {\n\t\tx = (root->bus_nr << 8) | edev->slot;\n\t\tif (forced_tab[i] == x)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void __init eisa_name_device(struct eisa_device *edev)\n{\n#ifdef CONFIG_EISA_NAMES\n\tint i;\n\tfor (i = 0; i < EISA_INFOS; i++) {\n\t\tif (!strcmp(edev->id.sig, eisa_table[i].id.sig)) {\n\t\t\tstrscpy(edev->pretty_name,\n\t\t\t\teisa_table[i].name,\n\t\t\t\tsizeof(edev->pretty_name));\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tsprintf(edev->pretty_name, \"EISA device %.7s\", edev->id.sig);\n#endif\n}\n\nstatic char __init *decode_eisa_sig(unsigned long addr)\n{\n\tstatic char sig_str[EISA_SIG_LEN];\n\tu8 sig[4];\n\tu16 rev;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n#ifdef CONFIG_EISA_VLB_PRIMING\n\t\t \n\t\toutb(0x80 + i, addr);\n#endif\n\t\tsig[i] = inb(addr + i);\n\n\t\tif (!i && (sig[0] & 0x80))\n\t\t\treturn NULL;\n\t}\n\n\tsig_str[0] = ((sig[0] >> 2) & 0x1f) + ('A' - 1);\n\tsig_str[1] = (((sig[0] & 3) << 3) | (sig[1] >> 5)) + ('A' - 1);\n\tsig_str[2] = (sig[1] & 0x1f) + ('A' - 1);\n\trev = (sig[2] << 8) | sig[3];\n\tsprintf(sig_str + 3, \"%04X\", rev);\n\n\treturn sig_str;\n}\n\nstatic int eisa_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct eisa_device *edev = to_eisa_device(dev);\n\tstruct eisa_driver *edrv = to_eisa_driver(drv);\n\tconst struct eisa_device_id *eids = edrv->id_table;\n\n\tif (!eids)\n\t\treturn 0;\n\n\twhile (strlen(eids->sig)) {\n\t\tif (!strcmp(eids->sig, edev->id.sig) &&\n\t\t    edev->state & EISA_CONFIG_ENABLED) {\n\t\t\tedev->id.driver_data = eids->driver_data;\n\t\t\treturn 1;\n\t\t}\n\n\t\teids++;\n\t}\n\n\treturn 0;\n}\n\nstatic int eisa_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct eisa_device *edev = to_eisa_device(dev);\n\n\tadd_uevent_var(env, \"MODALIAS=\" EISA_DEVICE_MODALIAS_FMT, edev->id.sig);\n\treturn 0;\n}\n\nstruct bus_type eisa_bus_type = {\n\t.name  = \"eisa\",\n\t.match = eisa_bus_match,\n\t.uevent = eisa_bus_uevent,\n};\nEXPORT_SYMBOL(eisa_bus_type);\n\nint eisa_driver_register(struct eisa_driver *edrv)\n{\n\tedrv->driver.bus = &eisa_bus_type;\n\treturn driver_register(&edrv->driver);\n}\nEXPORT_SYMBOL(eisa_driver_register);\n\nvoid eisa_driver_unregister(struct eisa_driver *edrv)\n{\n\tdriver_unregister(&edrv->driver);\n}\nEXPORT_SYMBOL(eisa_driver_unregister);\n\nstatic ssize_t signature_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct eisa_device *edev = to_eisa_device(dev);\n\treturn sprintf(buf, \"%s\\n\", edev->id.sig);\n}\nstatic DEVICE_ATTR_RO(signature);\n\nstatic ssize_t enabled_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct eisa_device *edev = to_eisa_device(dev);\n\treturn sprintf(buf, \"%d\\n\", edev->state & EISA_CONFIG_ENABLED);\n}\nstatic DEVICE_ATTR_RO(enabled);\n\nstatic ssize_t modalias_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct eisa_device *edev = to_eisa_device(dev);\n\treturn sprintf(buf, EISA_DEVICE_MODALIAS_FMT \"\\n\", edev->id.sig);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic int __init eisa_init_device(struct eisa_root_device *root,\n\t\t\t\t   struct eisa_device *edev,\n\t\t\t\t   int slot)\n{\n\tchar *sig;\n\tunsigned long sig_addr;\n\tint i;\n\n\tsig_addr = SLOT_ADDRESS(root, slot) + EISA_VENDOR_ID_OFFSET;\n\n\tsig = decode_eisa_sig(sig_addr);\n\tif (!sig)\n\t\treturn -1;\t \n\n\tmemcpy(edev->id.sig, sig, EISA_SIG_LEN);\n\tedev->slot = slot;\n\tedev->state = inb(SLOT_ADDRESS(root, slot) + EISA_CONFIG_OFFSET)\n\t\t      & EISA_CONFIG_ENABLED;\n\tedev->base_addr = SLOT_ADDRESS(root, slot);\n\tedev->dma_mask = root->dma_mask;  \n\teisa_name_device(edev);\n\tedev->dev.parent = root->dev;\n\tedev->dev.bus = &eisa_bus_type;\n\tedev->dev.dma_mask = &edev->dma_mask;\n\tedev->dev.coherent_dma_mask = edev->dma_mask;\n\tdev_set_name(&edev->dev, \"%02X:%02X\", root->bus_nr, slot);\n\n\tfor (i = 0; i < EISA_MAX_RESOURCES; i++) {\n#ifdef CONFIG_EISA_NAMES\n\t\tedev->res[i].name = edev->pretty_name;\n#else\n\t\tedev->res[i].name = edev->id.sig;\n#endif\n\t}\n\n\tif (is_forced_dev(enable_dev, enable_dev_count, root, edev))\n\t\tedev->state = EISA_CONFIG_ENABLED | EISA_CONFIG_FORCED;\n\n\tif (is_forced_dev(disable_dev, disable_dev_count, root, edev))\n\t\tedev->state = EISA_CONFIG_FORCED;\n\n\treturn 0;\n}\n\nstatic int __init eisa_register_device(struct eisa_device *edev)\n{\n\tint rc = device_register(&edev->dev);\n\tif (rc) {\n\t\tput_device(&edev->dev);\n\t\treturn rc;\n\t}\n\n\trc = device_create_file(&edev->dev, &dev_attr_signature);\n\tif (rc)\n\t\tgoto err_devreg;\n\trc = device_create_file(&edev->dev, &dev_attr_enabled);\n\tif (rc)\n\t\tgoto err_sig;\n\trc = device_create_file(&edev->dev, &dev_attr_modalias);\n\tif (rc)\n\t\tgoto err_enab;\n\n\treturn 0;\n\nerr_enab:\n\tdevice_remove_file(&edev->dev, &dev_attr_enabled);\nerr_sig:\n\tdevice_remove_file(&edev->dev, &dev_attr_signature);\nerr_devreg:\n\tdevice_unregister(&edev->dev);\n\treturn rc;\n}\n\nstatic int __init eisa_request_resources(struct eisa_root_device *root,\n\t\t\t\t\t struct eisa_device *edev,\n\t\t\t\t\t int slot)\n{\n\tint i;\n\n\tfor (i = 0; i < EISA_MAX_RESOURCES; i++) {\n\t\t \n\n\t\t \n\t\tif (!slot && i > 0) {\n\t\t\tedev->res[i].start = edev->res[i].end = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (slot) {\n\t\t\tedev->res[i].name  = NULL;\n\t\t\tedev->res[i].start = SLOT_ADDRESS(root, slot)\n\t\t\t\t\t     + (i * 0x400);\n\t\t\tedev->res[i].end   = edev->res[i].start + 0xff;\n\t\t\tedev->res[i].flags = IORESOURCE_IO;\n\t\t} else {\n\t\t\tedev->res[i].name  = NULL;\n\t\t\tedev->res[i].start = SLOT_ADDRESS(root, slot)\n\t\t\t\t\t     + EISA_VENDOR_ID_OFFSET;\n\t\t\tedev->res[i].end   = edev->res[i].start + 3;\n\t\t\tedev->res[i].flags = IORESOURCE_IO | IORESOURCE_BUSY;\n\t\t}\n\n\t\tif (request_resource(root->res, &edev->res[i]))\n\t\t\tgoto failed;\n\t}\n\n\treturn 0;\n\n failed:\n\twhile (--i >= 0)\n\t\trelease_resource(&edev->res[i]);\n\n\treturn -1;\n}\n\nstatic void __init eisa_release_resources(struct eisa_device *edev)\n{\n\tint i;\n\n\tfor (i = 0; i < EISA_MAX_RESOURCES; i++)\n\t\tif (edev->res[i].start || edev->res[i].end)\n\t\t\trelease_resource(&edev->res[i]);\n}\n\nstatic int __init eisa_probe(struct eisa_root_device *root)\n{\n\tint i, c;\n\tstruct eisa_device *edev;\n\tchar *enabled_str;\n\n\tdev_info(root->dev, \"Probing EISA bus %d\\n\", root->bus_nr);\n\n\t \n\n\tedev = kzalloc(sizeof(*edev), GFP_KERNEL);\n\tif (!edev)\n\t\treturn -ENOMEM;\n\n\tif (eisa_request_resources(root, edev, 0)) {\n\t\tdev_warn(root->dev,\n\t\t\t \"EISA: Cannot allocate resource for mainboard\\n\");\n\t\tkfree(edev);\n\t\tif (!root->force_probe)\n\t\t\treturn -EBUSY;\n\t\tgoto force_probe;\n\t}\n\n\tif (eisa_init_device(root, edev, 0)) {\n\t\teisa_release_resources(edev);\n\t\tkfree(edev);\n\t\tif (!root->force_probe)\n\t\t\treturn -ENODEV;\n\t\tgoto force_probe;\n\t}\n\n\tdev_info(&edev->dev, \"EISA: Mainboard %s detected\\n\", edev->id.sig);\n\n\tif (eisa_register_device(edev)) {\n\t\tdev_err(&edev->dev, \"EISA: Failed to register %s\\n\",\n\t\t\tedev->id.sig);\n\t\teisa_release_resources(edev);\n\t\tkfree(edev);\n\t}\n\n force_probe:\n\n\tfor (c = 0, i = 1; i <= root->slots; i++) {\n\t\tedev = kzalloc(sizeof(*edev), GFP_KERNEL);\n\t\tif (!edev) {\n\t\t\tdev_err(root->dev, \"EISA: Out of memory for slot %d\\n\",\n\t\t\t\ti);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (eisa_request_resources(root, edev, i)) {\n\t\t\tdev_warn(root->dev,\n\t\t\t\t \"Cannot allocate resource for EISA slot %d\\n\",\n\t\t\t\t i);\n\t\t\tkfree(edev);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (eisa_init_device(root, edev, i)) {\n\t\t\teisa_release_resources(edev);\n\t\t\tkfree(edev);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (edev->state == (EISA_CONFIG_ENABLED | EISA_CONFIG_FORCED))\n\t\t\tenabled_str = \" (forced enabled)\";\n\t\telse if (edev->state == EISA_CONFIG_FORCED)\n\t\t\tenabled_str = \" (forced disabled)\";\n\t\telse if (edev->state == 0)\n\t\t\tenabled_str = \" (disabled)\";\n\t\telse\n\t\t\tenabled_str = \"\";\n\n\t\tdev_info(&edev->dev, \"EISA: slot %d: %s detected%s\\n\", i,\n\t\t\t edev->id.sig, enabled_str);\n\n\t\tc++;\n\n\t\tif (eisa_register_device(edev)) {\n\t\t\tdev_err(&edev->dev, \"EISA: Failed to register %s\\n\",\n\t\t\t\tedev->id.sig);\n\t\t\teisa_release_resources(edev);\n\t\t\tkfree(edev);\n\t\t}\n\t}\n\n\tdev_info(root->dev, \"EISA: Detected %d card%s\\n\", c, c == 1 ? \"\" : \"s\");\n\treturn 0;\n}\n\nstatic struct resource eisa_root_res = {\n\t.name  = \"EISA root resource\",\n\t.start = 0,\n\t.end   = 0xffffffff,\n\t.flags = IORESOURCE_IO,\n};\n\nstatic int eisa_bus_count;\n\nint __init eisa_root_register(struct eisa_root_device *root)\n{\n\tint err;\n\n\t \n\n\troot->eisa_root_res.name  = eisa_root_res.name;\n\troot->eisa_root_res.start = root->res->start;\n\troot->eisa_root_res.end   = root->res->end;\n\troot->eisa_root_res.flags = IORESOURCE_BUSY;\n\n\terr = request_resource(&eisa_root_res, &root->eisa_root_res);\n\tif (err)\n\t\treturn err;\n\n\troot->bus_nr = eisa_bus_count++;\n\n\terr = eisa_probe(root);\n\tif (err)\n\t\trelease_resource(&root->eisa_root_res);\n\n\treturn err;\n}\n\nstatic int __init eisa_init(void)\n{\n\tint r;\n\n\tr = bus_register(&eisa_bus_type);\n\tif (r)\n\t\treturn r;\n\n\tprintk(KERN_INFO \"EISA bus registered\\n\");\n\treturn 0;\n}\n\nmodule_param_array(enable_dev, int, &enable_dev_count, 0444);\nmodule_param_array(disable_dev, int, &disable_dev_count, 0444);\n\npostcore_initcall(eisa_init);\n\nint EISA_bus;\t\t \nEXPORT_SYMBOL(EISA_bus);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}