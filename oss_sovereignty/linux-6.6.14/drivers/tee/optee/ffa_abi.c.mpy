{
  "module_name": "ffa_abi.c",
  "hash_id": "9dca5bdab4e954a0ecee88d8eb057281802c0bdaafa91445602200fd761785c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tee/optee/ffa_abi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/arm_ffa.h>\n#include <linux/errno.h>\n#include <linux/scatterlist.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/tee_drv.h>\n#include <linux/types.h>\n#include \"optee_private.h\"\n#include \"optee_ffa.h\"\n#include \"optee_rpc_cmd.h\"\n\n \n\n \nstruct shm_rhash {\n\tstruct tee_shm *shm;\n\tu64 global_id;\n\tstruct rhash_head linkage;\n};\n\nstatic void rh_free_fn(void *ptr, void *arg)\n{\n\tkfree(ptr);\n}\n\nstatic const struct rhashtable_params shm_rhash_params = {\n\t.head_offset = offsetof(struct shm_rhash, linkage),\n\t.key_len     = sizeof(u64),\n\t.key_offset  = offsetof(struct shm_rhash, global_id),\n\t.automatic_shrinking = true,\n};\n\nstatic struct tee_shm *optee_shm_from_ffa_handle(struct optee *optee,\n\t\t\t\t\t\t u64 global_id)\n{\n\tstruct tee_shm *shm = NULL;\n\tstruct shm_rhash *r;\n\n\tmutex_lock(&optee->ffa.mutex);\n\tr = rhashtable_lookup_fast(&optee->ffa.global_ids, &global_id,\n\t\t\t\t   shm_rhash_params);\n\tif (r)\n\t\tshm = r->shm;\n\tmutex_unlock(&optee->ffa.mutex);\n\n\treturn shm;\n}\n\nstatic int optee_shm_add_ffa_handle(struct optee *optee, struct tee_shm *shm,\n\t\t\t\t    u64 global_id)\n{\n\tstruct shm_rhash *r;\n\tint rc;\n\n\tr = kmalloc(sizeof(*r), GFP_KERNEL);\n\tif (!r)\n\t\treturn -ENOMEM;\n\tr->shm = shm;\n\tr->global_id = global_id;\n\n\tmutex_lock(&optee->ffa.mutex);\n\trc = rhashtable_lookup_insert_fast(&optee->ffa.global_ids, &r->linkage,\n\t\t\t\t\t   shm_rhash_params);\n\tmutex_unlock(&optee->ffa.mutex);\n\n\tif (rc)\n\t\tkfree(r);\n\n\treturn rc;\n}\n\nstatic int optee_shm_rem_ffa_handle(struct optee *optee, u64 global_id)\n{\n\tstruct shm_rhash *r;\n\tint rc = -ENOENT;\n\n\tmutex_lock(&optee->ffa.mutex);\n\tr = rhashtable_lookup_fast(&optee->ffa.global_ids, &global_id,\n\t\t\t\t   shm_rhash_params);\n\tif (r)\n\t\trc = rhashtable_remove_fast(&optee->ffa.global_ids,\n\t\t\t\t\t    &r->linkage, shm_rhash_params);\n\tmutex_unlock(&optee->ffa.mutex);\n\n\tif (!rc)\n\t\tkfree(r);\n\n\treturn rc;\n}\n\n \n\nstatic void from_msg_param_ffa_mem(struct optee *optee, struct tee_param *p,\n\t\t\t\t   u32 attr, const struct optee_msg_param *mp)\n{\n\tstruct tee_shm *shm = NULL;\n\tu64 offs_high = 0;\n\tu64 offs_low = 0;\n\n\tp->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT +\n\t\t  attr - OPTEE_MSG_ATTR_TYPE_FMEM_INPUT;\n\tp->u.memref.size = mp->u.fmem.size;\n\n\tif (mp->u.fmem.global_id != OPTEE_MSG_FMEM_INVALID_GLOBAL_ID)\n\t\tshm = optee_shm_from_ffa_handle(optee, mp->u.fmem.global_id);\n\tp->u.memref.shm = shm;\n\n\tif (shm) {\n\t\toffs_low = mp->u.fmem.offs_low;\n\t\toffs_high = mp->u.fmem.offs_high;\n\t}\n\tp->u.memref.shm_offs = offs_low | offs_high << 32;\n}\n\n \nstatic int optee_ffa_from_msg_param(struct optee *optee,\n\t\t\t\t    struct tee_param *params, size_t num_params,\n\t\t\t\t    const struct optee_msg_param *msg_params)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tstruct tee_param *p = params + n;\n\t\tconst struct optee_msg_param *mp = msg_params + n;\n\t\tu32 attr = mp->attr & OPTEE_MSG_ATTR_TYPE_MASK;\n\n\t\tswitch (attr) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_NONE:\n\t\t\tp->attr = TEE_IOCTL_PARAM_ATTR_TYPE_NONE;\n\t\t\tmemset(&p->u, 0, sizeof(p->u));\n\t\t\tbreak;\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_INOUT:\n\t\t\toptee_from_msg_param_value(p, attr, mp);\n\t\t\tbreak;\n\t\tcase OPTEE_MSG_ATTR_TYPE_FMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_FMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_FMEM_INOUT:\n\t\t\tfrom_msg_param_ffa_mem(optee, p, attr, mp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int to_msg_param_ffa_mem(struct optee_msg_param *mp,\n\t\t\t\tconst struct tee_param *p)\n{\n\tstruct tee_shm *shm = p->u.memref.shm;\n\n\tmp->attr = OPTEE_MSG_ATTR_TYPE_FMEM_INPUT + p->attr -\n\t\t   TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;\n\n\tif (shm) {\n\t\tu64 shm_offs = p->u.memref.shm_offs;\n\n\t\tmp->u.fmem.internal_offs = shm->offset;\n\n\t\tmp->u.fmem.offs_low = shm_offs;\n\t\tmp->u.fmem.offs_high = shm_offs >> 32;\n\t\t \n\t\tif (mp->u.fmem.offs_high != shm_offs >> 32)\n\t\t\treturn -EINVAL;\n\n\t\tmp->u.fmem.global_id = shm->sec_world_id;\n\t} else {\n\t\tmemset(&mp->u, 0, sizeof(mp->u));\n\t\tmp->u.fmem.global_id = OPTEE_MSG_FMEM_INVALID_GLOBAL_ID;\n\t}\n\tmp->u.fmem.size = p->u.memref.size;\n\n\treturn 0;\n}\n\n \nstatic int optee_ffa_to_msg_param(struct optee *optee,\n\t\t\t\t  struct optee_msg_param *msg_params,\n\t\t\t\t  size_t num_params,\n\t\t\t\t  const struct tee_param *params)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tconst struct tee_param *p = params + n;\n\t\tstruct optee_msg_param *mp = msg_params + n;\n\n\t\tswitch (p->attr) {\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_NONE:\n\t\t\tmp->attr = TEE_IOCTL_PARAM_ATTR_TYPE_NONE;\n\t\t\tmemset(&mp->u, 0, sizeof(mp->u));\n\t\t\tbreak;\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:\n\t\t\toptee_to_msg_param_value(mp, p);\n\t\t\tbreak;\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:\n\t\t\tif (to_msg_param_ffa_mem(mp, p))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int optee_ffa_shm_register(struct tee_context *ctx, struct tee_shm *shm,\n\t\t\t\t  struct page **pages, size_t num_pages,\n\t\t\t\t  unsigned long start)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tstruct ffa_device *ffa_dev = optee->ffa.ffa_dev;\n\tconst struct ffa_mem_ops *mem_ops = ffa_dev->ops->mem_ops;\n\tstruct ffa_mem_region_attributes mem_attr = {\n\t\t.receiver = ffa_dev->vm_id,\n\t\t.attrs = FFA_MEM_RW,\n\t};\n\tstruct ffa_mem_ops_args args = {\n\t\t.use_txbuf = true,\n\t\t.attrs = &mem_attr,\n\t\t.nattrs = 1,\n\t};\n\tstruct sg_table sgt;\n\tint rc;\n\n\trc = optee_check_mem_type(start, num_pages);\n\tif (rc)\n\t\treturn rc;\n\n\trc = sg_alloc_table_from_pages(&sgt, pages, num_pages, 0,\n\t\t\t\t       num_pages * PAGE_SIZE, GFP_KERNEL);\n\tif (rc)\n\t\treturn rc;\n\targs.sg = sgt.sgl;\n\trc = mem_ops->memory_share(&args);\n\tsg_free_table(&sgt);\n\tif (rc)\n\t\treturn rc;\n\n\trc = optee_shm_add_ffa_handle(optee, shm, args.g_handle);\n\tif (rc) {\n\t\tmem_ops->memory_reclaim(args.g_handle, 0);\n\t\treturn rc;\n\t}\n\n\tshm->sec_world_id = args.g_handle;\n\n\treturn 0;\n}\n\nstatic int optee_ffa_shm_unregister(struct tee_context *ctx,\n\t\t\t\t    struct tee_shm *shm)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tstruct ffa_device *ffa_dev = optee->ffa.ffa_dev;\n\tconst struct ffa_msg_ops *msg_ops = ffa_dev->ops->msg_ops;\n\tconst struct ffa_mem_ops *mem_ops = ffa_dev->ops->mem_ops;\n\tu64 global_handle = shm->sec_world_id;\n\tstruct ffa_send_direct_data data = {\n\t\t.data0 = OPTEE_FFA_UNREGISTER_SHM,\n\t\t.data1 = (u32)global_handle,\n\t\t.data2 = (u32)(global_handle >> 32)\n\t};\n\tint rc;\n\n\toptee_shm_rem_ffa_handle(optee, global_handle);\n\tshm->sec_world_id = 0;\n\n\trc = msg_ops->sync_send_receive(ffa_dev, &data);\n\tif (rc)\n\t\tpr_err(\"Unregister SHM id 0x%llx rc %d\\n\", global_handle, rc);\n\n\trc = mem_ops->memory_reclaim(global_handle, 0);\n\tif (rc)\n\t\tpr_err(\"mem_reclaim: 0x%llx %d\", global_handle, rc);\n\n\treturn rc;\n}\n\nstatic int optee_ffa_shm_unregister_supp(struct tee_context *ctx,\n\t\t\t\t\t struct tee_shm *shm)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tconst struct ffa_mem_ops *mem_ops;\n\tu64 global_handle = shm->sec_world_id;\n\tint rc;\n\n\t \n\n\toptee_shm_rem_ffa_handle(optee, global_handle);\n\tmem_ops = optee->ffa.ffa_dev->ops->mem_ops;\n\trc = mem_ops->memory_reclaim(global_handle, 0);\n\tif (rc)\n\t\tpr_err(\"mem_reclaim: 0x%llx %d\", global_handle, rc);\n\n\tshm->sec_world_id = 0;\n\n\treturn rc;\n}\n\n \n\nstatic int pool_ffa_op_alloc(struct tee_shm_pool *pool,\n\t\t\t     struct tee_shm *shm, size_t size, size_t align)\n{\n\treturn optee_pool_op_alloc_helper(pool, shm, size, align,\n\t\t\t\t\t  optee_ffa_shm_register);\n}\n\nstatic void pool_ffa_op_free(struct tee_shm_pool *pool,\n\t\t\t     struct tee_shm *shm)\n{\n\toptee_pool_op_free_helper(pool, shm, optee_ffa_shm_unregister);\n}\n\nstatic void pool_ffa_op_destroy_pool(struct tee_shm_pool *pool)\n{\n\tkfree(pool);\n}\n\nstatic const struct tee_shm_pool_ops pool_ffa_ops = {\n\t.alloc = pool_ffa_op_alloc,\n\t.free = pool_ffa_op_free,\n\t.destroy_pool = pool_ffa_op_destroy_pool,\n};\n\n \nstatic struct tee_shm_pool *optee_ffa_shm_pool_alloc_pages(void)\n{\n\tstruct tee_shm_pool *pool = kzalloc(sizeof(*pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpool->ops = &pool_ffa_ops;\n\n\treturn pool;\n}\n\n \n\nstatic void handle_ffa_rpc_func_cmd_shm_alloc(struct tee_context *ctx,\n\t\t\t\t\t      struct optee *optee,\n\t\t\t\t\t      struct optee_msg_arg *arg)\n{\n\tstruct tee_shm *shm;\n\n\tif (arg->num_params != 1 ||\n\t    arg->params[0].attr != OPTEE_MSG_ATTR_TYPE_VALUE_INPUT) {\n\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n\t\treturn;\n\t}\n\n\tswitch (arg->params[0].u.value.a) {\n\tcase OPTEE_RPC_SHM_TYPE_APPL:\n\t\tshm = optee_rpc_cmd_alloc_suppl(ctx, arg->params[0].u.value.b);\n\t\tbreak;\n\tcase OPTEE_RPC_SHM_TYPE_KERNEL:\n\t\tshm = tee_shm_alloc_priv_buf(optee->ctx,\n\t\t\t\t\t     arg->params[0].u.value.b);\n\t\tbreak;\n\tdefault:\n\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n\t\treturn;\n\t}\n\n\tif (IS_ERR(shm)) {\n\t\targ->ret = TEEC_ERROR_OUT_OF_MEMORY;\n\t\treturn;\n\t}\n\n\targ->params[0] = (struct optee_msg_param){\n\t\t.attr = OPTEE_MSG_ATTR_TYPE_FMEM_OUTPUT,\n\t\t.u.fmem.size = tee_shm_get_size(shm),\n\t\t.u.fmem.global_id = shm->sec_world_id,\n\t\t.u.fmem.internal_offs = shm->offset,\n\t};\n\n\targ->ret = TEEC_SUCCESS;\n}\n\nstatic void handle_ffa_rpc_func_cmd_shm_free(struct tee_context *ctx,\n\t\t\t\t\t     struct optee *optee,\n\t\t\t\t\t     struct optee_msg_arg *arg)\n{\n\tstruct tee_shm *shm;\n\n\tif (arg->num_params != 1 ||\n\t    arg->params[0].attr != OPTEE_MSG_ATTR_TYPE_VALUE_INPUT)\n\t\tgoto err_bad_param;\n\n\tshm = optee_shm_from_ffa_handle(optee, arg->params[0].u.value.b);\n\tif (!shm)\n\t\tgoto err_bad_param;\n\tswitch (arg->params[0].u.value.a) {\n\tcase OPTEE_RPC_SHM_TYPE_APPL:\n\t\toptee_rpc_cmd_free_suppl(ctx, shm);\n\t\tbreak;\n\tcase OPTEE_RPC_SHM_TYPE_KERNEL:\n\t\ttee_shm_free(shm);\n\t\tbreak;\n\tdefault:\n\t\tgoto err_bad_param;\n\t}\n\targ->ret = TEEC_SUCCESS;\n\treturn;\n\nerr_bad_param:\n\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n}\n\nstatic void handle_ffa_rpc_func_cmd(struct tee_context *ctx,\n\t\t\t\t    struct optee *optee,\n\t\t\t\t    struct optee_msg_arg *arg)\n{\n\targ->ret_origin = TEEC_ORIGIN_COMMS;\n\tswitch (arg->cmd) {\n\tcase OPTEE_RPC_CMD_SHM_ALLOC:\n\t\thandle_ffa_rpc_func_cmd_shm_alloc(ctx, optee, arg);\n\t\tbreak;\n\tcase OPTEE_RPC_CMD_SHM_FREE:\n\t\thandle_ffa_rpc_func_cmd_shm_free(ctx, optee, arg);\n\t\tbreak;\n\tdefault:\n\t\toptee_rpc_cmd(ctx, optee, arg);\n\t}\n}\n\nstatic void optee_handle_ffa_rpc(struct tee_context *ctx, struct optee *optee,\n\t\t\t\t u32 cmd, struct optee_msg_arg *arg)\n{\n\tswitch (cmd) {\n\tcase OPTEE_FFA_YIELDING_CALL_RETURN_RPC_CMD:\n\t\thandle_ffa_rpc_func_cmd(ctx, optee, arg);\n\t\tbreak;\n\tcase OPTEE_FFA_YIELDING_CALL_RETURN_INTERRUPT:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Unknown RPC func 0x%x\\n\", cmd);\n\t\tbreak;\n\t}\n}\n\nstatic int optee_ffa_yielding_call(struct tee_context *ctx,\n\t\t\t\t   struct ffa_send_direct_data *data,\n\t\t\t\t   struct optee_msg_arg *rpc_arg)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tstruct ffa_device *ffa_dev = optee->ffa.ffa_dev;\n\tconst struct ffa_msg_ops *msg_ops = ffa_dev->ops->msg_ops;\n\tstruct optee_call_waiter w;\n\tu32 cmd = data->data0;\n\tu32 w4 = data->data1;\n\tu32 w5 = data->data2;\n\tu32 w6 = data->data3;\n\tint rc;\n\n\t \n\toptee_cq_wait_init(&optee->call_queue, &w);\n\twhile (true) {\n\t\trc = msg_ops->sync_send_receive(ffa_dev, data);\n\t\tif (rc)\n\t\t\tgoto done;\n\n\t\tswitch ((int)data->data0) {\n\t\tcase TEEC_SUCCESS:\n\t\t\tbreak;\n\t\tcase TEEC_ERROR_BUSY:\n\t\t\tif (cmd == OPTEE_FFA_YIELDING_CALL_RESUME) {\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t \n\t\t\toptee_cq_wait_for_completion(&optee->call_queue, &w);\n\t\t\tdata->data0 = cmd;\n\t\t\tdata->data1 = w4;\n\t\t\tdata->data2 = w5;\n\t\t\tdata->data3 = w6;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\trc = -EIO;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (data->data1 == OPTEE_FFA_YIELDING_CALL_RETURN_DONE)\n\t\t\tgoto done;\n\n\t\t \n\t\tcond_resched();\n\t\toptee_handle_ffa_rpc(ctx, optee, data->data1, rpc_arg);\n\t\tcmd = OPTEE_FFA_YIELDING_CALL_RESUME;\n\t\tdata->data0 = cmd;\n\t\tdata->data1 = 0;\n\t\tdata->data2 = 0;\n\t\tdata->data3 = 0;\n\t}\ndone:\n\t \n\toptee_cq_wait_final(&optee->call_queue, &w);\n\n\treturn rc;\n}\n\n \n\nstatic int optee_ffa_do_call_with_arg(struct tee_context *ctx,\n\t\t\t\t      struct tee_shm *shm, u_int offs)\n{\n\tstruct ffa_send_direct_data data = {\n\t\t.data0 = OPTEE_FFA_YIELDING_CALL_WITH_ARG,\n\t\t.data1 = (u32)shm->sec_world_id,\n\t\t.data2 = (u32)(shm->sec_world_id >> 32),\n\t\t.data3 = offs,\n\t};\n\tstruct optee_msg_arg *arg;\n\tunsigned int rpc_arg_offs;\n\tstruct optee_msg_arg *rpc_arg;\n\n\t \n\tif (shm->offset)\n\t\treturn -EINVAL;\n\n\targ = tee_shm_get_va(shm, offs);\n\tif (IS_ERR(arg))\n\t\treturn PTR_ERR(arg);\n\n\trpc_arg_offs = OPTEE_MSG_GET_ARG_SIZE(arg->num_params);\n\trpc_arg = tee_shm_get_va(shm, offs + rpc_arg_offs);\n\tif (IS_ERR(rpc_arg))\n\t\treturn PTR_ERR(rpc_arg);\n\n\treturn optee_ffa_yielding_call(ctx, &data, rpc_arg);\n}\n\n \n\nstatic bool optee_ffa_api_is_compatbile(struct ffa_device *ffa_dev,\n\t\t\t\t\tconst struct ffa_ops *ops)\n{\n\tconst struct ffa_msg_ops *msg_ops = ops->msg_ops;\n\tstruct ffa_send_direct_data data = { OPTEE_FFA_GET_API_VERSION };\n\tint rc;\n\n\tmsg_ops->mode_32bit_set(ffa_dev);\n\n\trc = msg_ops->sync_send_receive(ffa_dev, &data);\n\tif (rc) {\n\t\tpr_err(\"Unexpected error %d\\n\", rc);\n\t\treturn false;\n\t}\n\tif (data.data0 != OPTEE_FFA_VERSION_MAJOR ||\n\t    data.data1 < OPTEE_FFA_VERSION_MINOR) {\n\t\tpr_err(\"Incompatible OP-TEE API version %lu.%lu\",\n\t\t       data.data0, data.data1);\n\t\treturn false;\n\t}\n\n\tdata = (struct ffa_send_direct_data){ OPTEE_FFA_GET_OS_VERSION };\n\trc = msg_ops->sync_send_receive(ffa_dev, &data);\n\tif (rc) {\n\t\tpr_err(\"Unexpected error %d\\n\", rc);\n\t\treturn false;\n\t}\n\tif (data.data2)\n\t\tpr_info(\"revision %lu.%lu (%08lx)\",\n\t\t\tdata.data0, data.data1, data.data2);\n\telse\n\t\tpr_info(\"revision %lu.%lu\", data.data0, data.data1);\n\n\treturn true;\n}\n\nstatic bool optee_ffa_exchange_caps(struct ffa_device *ffa_dev,\n\t\t\t\t    const struct ffa_ops *ops,\n\t\t\t\t    u32 *sec_caps,\n\t\t\t\t    unsigned int *rpc_param_count)\n{\n\tstruct ffa_send_direct_data data = { OPTEE_FFA_EXCHANGE_CAPABILITIES };\n\tint rc;\n\n\trc = ops->msg_ops->sync_send_receive(ffa_dev, &data);\n\tif (rc) {\n\t\tpr_err(\"Unexpected error %d\", rc);\n\t\treturn false;\n\t}\n\tif (data.data0) {\n\t\tpr_err(\"Unexpected exchange error %lu\", data.data0);\n\t\treturn false;\n\t}\n\n\t*rpc_param_count = (u8)data.data1;\n\t*sec_caps = data.data2;\n\n\treturn true;\n}\n\nstatic void optee_ffa_get_version(struct tee_device *teedev,\n\t\t\t\t  struct tee_ioctl_version_data *vers)\n{\n\tstruct tee_ioctl_version_data v = {\n\t\t.impl_id = TEE_IMPL_ID_OPTEE,\n\t\t.impl_caps = TEE_OPTEE_CAP_TZ,\n\t\t.gen_caps = TEE_GEN_CAP_GP | TEE_GEN_CAP_REG_MEM |\n\t\t\t    TEE_GEN_CAP_MEMREF_NULL,\n\t};\n\n\t*vers = v;\n}\n\nstatic int optee_ffa_open(struct tee_context *ctx)\n{\n\treturn optee_open(ctx, true);\n}\n\nstatic const struct tee_driver_ops optee_ffa_clnt_ops = {\n\t.get_version = optee_ffa_get_version,\n\t.open = optee_ffa_open,\n\t.release = optee_release,\n\t.open_session = optee_open_session,\n\t.close_session = optee_close_session,\n\t.invoke_func = optee_invoke_func,\n\t.cancel_req = optee_cancel_req,\n\t.shm_register = optee_ffa_shm_register,\n\t.shm_unregister = optee_ffa_shm_unregister,\n};\n\nstatic const struct tee_desc optee_ffa_clnt_desc = {\n\t.name = DRIVER_NAME \"-ffa-clnt\",\n\t.ops = &optee_ffa_clnt_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct tee_driver_ops optee_ffa_supp_ops = {\n\t.get_version = optee_ffa_get_version,\n\t.open = optee_ffa_open,\n\t.release = optee_release_supp,\n\t.supp_recv = optee_supp_recv,\n\t.supp_send = optee_supp_send,\n\t.shm_register = optee_ffa_shm_register,  \n\t.shm_unregister = optee_ffa_shm_unregister_supp,\n};\n\nstatic const struct tee_desc optee_ffa_supp_desc = {\n\t.name = DRIVER_NAME \"-ffa-supp\",\n\t.ops = &optee_ffa_supp_ops,\n\t.owner = THIS_MODULE,\n\t.flags = TEE_DESC_PRIVILEGED,\n};\n\nstatic const struct optee_ops optee_ffa_ops = {\n\t.do_call_with_arg = optee_ffa_do_call_with_arg,\n\t.to_msg_param = optee_ffa_to_msg_param,\n\t.from_msg_param = optee_ffa_from_msg_param,\n};\n\nstatic void optee_ffa_remove(struct ffa_device *ffa_dev)\n{\n\tstruct optee *optee = ffa_dev_get_drvdata(ffa_dev);\n\n\toptee_remove_common(optee);\n\n\tmutex_destroy(&optee->ffa.mutex);\n\trhashtable_free_and_destroy(&optee->ffa.global_ids, rh_free_fn, NULL);\n\n\tkfree(optee);\n}\n\nstatic int optee_ffa_probe(struct ffa_device *ffa_dev)\n{\n\tconst struct ffa_ops *ffa_ops;\n\tunsigned int rpc_param_count;\n\tstruct tee_shm_pool *pool;\n\tstruct tee_device *teedev;\n\tstruct tee_context *ctx;\n\tu32 arg_cache_flags = 0;\n\tstruct optee *optee;\n\tu32 sec_caps;\n\tint rc;\n\n\tffa_ops = ffa_dev->ops;\n\n\tif (!optee_ffa_api_is_compatbile(ffa_dev, ffa_ops))\n\t\treturn -EINVAL;\n\n\tif (!optee_ffa_exchange_caps(ffa_dev, ffa_ops, &sec_caps,\n\t\t\t\t     &rpc_param_count))\n\t\treturn -EINVAL;\n\tif (sec_caps & OPTEE_FFA_SEC_CAP_ARG_OFFSET)\n\t\targ_cache_flags |= OPTEE_SHM_ARG_SHARED;\n\n\toptee = kzalloc(sizeof(*optee), GFP_KERNEL);\n\tif (!optee)\n\t\treturn -ENOMEM;\n\n\tpool = optee_ffa_shm_pool_alloc_pages();\n\tif (IS_ERR(pool)) {\n\t\trc = PTR_ERR(pool);\n\t\tgoto err_free_optee;\n\t}\n\toptee->pool = pool;\n\n\toptee->ops = &optee_ffa_ops;\n\toptee->ffa.ffa_dev = ffa_dev;\n\toptee->rpc_param_count = rpc_param_count;\n\n\tteedev = tee_device_alloc(&optee_ffa_clnt_desc, NULL, optee->pool,\n\t\t\t\t  optee);\n\tif (IS_ERR(teedev)) {\n\t\trc = PTR_ERR(teedev);\n\t\tgoto err_free_pool;\n\t}\n\toptee->teedev = teedev;\n\n\tteedev = tee_device_alloc(&optee_ffa_supp_desc, NULL, optee->pool,\n\t\t\t\t  optee);\n\tif (IS_ERR(teedev)) {\n\t\trc = PTR_ERR(teedev);\n\t\tgoto err_unreg_teedev;\n\t}\n\toptee->supp_teedev = teedev;\n\n\trc = tee_device_register(optee->teedev);\n\tif (rc)\n\t\tgoto err_unreg_supp_teedev;\n\n\trc = tee_device_register(optee->supp_teedev);\n\tif (rc)\n\t\tgoto err_unreg_supp_teedev;\n\n\trc = rhashtable_init(&optee->ffa.global_ids, &shm_rhash_params);\n\tif (rc)\n\t\tgoto err_unreg_supp_teedev;\n\tmutex_init(&optee->ffa.mutex);\n\tmutex_init(&optee->call_queue.mutex);\n\tINIT_LIST_HEAD(&optee->call_queue.waiters);\n\toptee_supp_init(&optee->supp);\n\toptee_shm_arg_cache_init(optee, arg_cache_flags);\n\tffa_dev_set_drvdata(ffa_dev, optee);\n\tctx = teedev_open(optee->teedev);\n\tif (IS_ERR(ctx)) {\n\t\trc = PTR_ERR(ctx);\n\t\tgoto err_rhashtable_free;\n\t}\n\toptee->ctx = ctx;\n\trc = optee_notif_init(optee, OPTEE_DEFAULT_MAX_NOTIF_VALUE);\n\tif (rc)\n\t\tgoto err_close_ctx;\n\n\trc = optee_enumerate_devices(PTA_CMD_GET_DEVICES);\n\tif (rc)\n\t\tgoto err_unregister_devices;\n\n\tpr_info(\"initialized driver\\n\");\n\treturn 0;\n\nerr_unregister_devices:\n\toptee_unregister_devices();\n\toptee_notif_uninit(optee);\nerr_close_ctx:\n\tteedev_close_context(ctx);\nerr_rhashtable_free:\n\trhashtable_free_and_destroy(&optee->ffa.global_ids, rh_free_fn, NULL);\n\toptee_supp_uninit(&optee->supp);\n\tmutex_destroy(&optee->call_queue.mutex);\n\tmutex_destroy(&optee->ffa.mutex);\nerr_unreg_supp_teedev:\n\ttee_device_unregister(optee->supp_teedev);\nerr_unreg_teedev:\n\ttee_device_unregister(optee->teedev);\nerr_free_pool:\n\ttee_shm_pool_free(pool);\nerr_free_optee:\n\tkfree(optee);\n\treturn rc;\n}\n\nstatic const struct ffa_device_id optee_ffa_device_id[] = {\n\t \n\t{ UUID_INIT(0x486178e0, 0xe7f8, 0x11e3,\n\t\t    0xbc, 0x5e, 0x00, 0x02, 0xa5, 0xd5, 0xc5, 0x1b) },\n\t{}\n};\n\nstatic struct ffa_driver optee_ffa_driver = {\n\t.name = \"optee\",\n\t.probe = optee_ffa_probe,\n\t.remove = optee_ffa_remove,\n\t.id_table = optee_ffa_device_id,\n};\n\nint optee_ffa_abi_register(void)\n{\n\tif (IS_REACHABLE(CONFIG_ARM_FFA_TRANSPORT))\n\t\treturn ffa_register(&optee_ffa_driver);\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nvoid optee_ffa_abi_unregister(void)\n{\n\tif (IS_REACHABLE(CONFIG_ARM_FFA_TRANSPORT))\n\t\tffa_unregister(&optee_ffa_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}