{
  "module_name": "core.c",
  "hash_id": "ad2a00fcc4429d56d9d81c70d0756bf41bd8be0ce4ebfca4b51db3f5f55d7bfa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tee/optee/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/crash_dump.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/tee_drv.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include \"optee_private.h\"\n\nint optee_pool_op_alloc_helper(struct tee_shm_pool *pool, struct tee_shm *shm,\n\t\t\t       size_t size, size_t align,\n\t\t\t       int (*shm_register)(struct tee_context *ctx,\n\t\t\t\t\t\t   struct tee_shm *shm,\n\t\t\t\t\t\t   struct page **pages,\n\t\t\t\t\t\t   size_t num_pages,\n\t\t\t\t\t\t   unsigned long start))\n{\n\tunsigned int order = get_order(size);\n\tstruct page *page;\n\tint rc = 0;\n\n\t \n\tpage = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tshm->kaddr = page_address(page);\n\tshm->paddr = page_to_phys(page);\n\tshm->size = PAGE_SIZE << order;\n\n\tif (shm_register) {\n\t\tunsigned int nr_pages = 1 << order, i;\n\t\tstruct page **pages;\n\n\t\tpages = kcalloc(nr_pages, sizeof(*pages), GFP_KERNEL);\n\t\tif (!pages) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\tpages[i] = page + i;\n\n\t\trc = shm_register(shm->ctx, shm, pages, nr_pages,\n\t\t\t\t  (unsigned long)shm->kaddr);\n\t\tkfree(pages);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tfree_pages((unsigned long)shm->kaddr, order);\n\treturn rc;\n}\n\nvoid optee_pool_op_free_helper(struct tee_shm_pool *pool, struct tee_shm *shm,\n\t\t\t       int (*shm_unregister)(struct tee_context *ctx,\n\t\t\t\t\t\t     struct tee_shm *shm))\n{\n\tif (shm_unregister)\n\t\tshm_unregister(shm->ctx, shm);\n\tfree_pages((unsigned long)shm->kaddr, get_order(shm->size));\n\tshm->kaddr = NULL;\n}\n\nstatic void optee_bus_scan(struct work_struct *work)\n{\n\tWARN_ON(optee_enumerate_devices(PTA_CMD_GET_DEVICES_SUPP));\n}\n\nint optee_open(struct tee_context *ctx, bool cap_memref_null)\n{\n\tstruct optee_context_data *ctxdata;\n\tstruct tee_device *teedev = ctx->teedev;\n\tstruct optee *optee = tee_get_drvdata(teedev);\n\n\tctxdata = kzalloc(sizeof(*ctxdata), GFP_KERNEL);\n\tif (!ctxdata)\n\t\treturn -ENOMEM;\n\n\tif (teedev == optee->supp_teedev) {\n\t\tbool busy = true;\n\n\t\tmutex_lock(&optee->supp.mutex);\n\t\tif (!optee->supp.ctx) {\n\t\t\tbusy = false;\n\t\t\toptee->supp.ctx = ctx;\n\t\t}\n\t\tmutex_unlock(&optee->supp.mutex);\n\t\tif (busy) {\n\t\t\tkfree(ctxdata);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tif (!optee->scan_bus_done) {\n\t\t\tINIT_WORK(&optee->scan_bus_work, optee_bus_scan);\n\t\t\toptee->scan_bus_wq = create_workqueue(\"optee_bus_scan\");\n\t\t\tif (!optee->scan_bus_wq) {\n\t\t\t\tkfree(ctxdata);\n\t\t\t\treturn -ECHILD;\n\t\t\t}\n\t\t\tqueue_work(optee->scan_bus_wq, &optee->scan_bus_work);\n\t\t\toptee->scan_bus_done = true;\n\t\t}\n\t}\n\tmutex_init(&ctxdata->mutex);\n\tINIT_LIST_HEAD(&ctxdata->sess_list);\n\n\tctx->cap_memref_null = cap_memref_null;\n\tctx->data = ctxdata;\n\treturn 0;\n}\n\nstatic void optee_release_helper(struct tee_context *ctx,\n\t\t\t\t int (*close_session)(struct tee_context *ctx,\n\t\t\t\t\t\t      u32 session))\n{\n\tstruct optee_context_data *ctxdata = ctx->data;\n\tstruct optee_session *sess;\n\tstruct optee_session *sess_tmp;\n\n\tif (!ctxdata)\n\t\treturn;\n\n\tlist_for_each_entry_safe(sess, sess_tmp, &ctxdata->sess_list,\n\t\t\t\t list_node) {\n\t\tlist_del(&sess->list_node);\n\t\tclose_session(ctx, sess->session_id);\n\t\tkfree(sess);\n\t}\n\tkfree(ctxdata);\n\tctx->data = NULL;\n}\n\nvoid optee_release(struct tee_context *ctx)\n{\n\toptee_release_helper(ctx, optee_close_session_helper);\n}\n\nvoid optee_release_supp(struct tee_context *ctx)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\n\toptee_release_helper(ctx, optee_close_session_helper);\n\tif (optee->scan_bus_wq) {\n\t\tdestroy_workqueue(optee->scan_bus_wq);\n\t\toptee->scan_bus_wq = NULL;\n\t}\n\toptee_supp_release(&optee->supp);\n}\n\nvoid optee_remove_common(struct optee *optee)\n{\n\t \n\toptee_unregister_devices();\n\n\toptee_notif_uninit(optee);\n\toptee_shm_arg_cache_uninit(optee);\n\tteedev_close_context(optee->ctx);\n\t \n\ttee_device_unregister(optee->supp_teedev);\n\ttee_device_unregister(optee->teedev);\n\n\ttee_shm_pool_free(optee->pool);\n\toptee_supp_uninit(&optee->supp);\n\tmutex_destroy(&optee->call_queue.mutex);\n}\n\nstatic int smc_abi_rc;\nstatic int ffa_abi_rc;\n\nstatic int __init optee_core_init(void)\n{\n\t \n\tif (is_kdump_kernel())\n\t\treturn -ENODEV;\n\n\tsmc_abi_rc = optee_smc_abi_register();\n\tffa_abi_rc = optee_ffa_abi_register();\n\n\t \n\tif (smc_abi_rc && ffa_abi_rc)\n\t\treturn smc_abi_rc;\n\treturn 0;\n}\nmodule_init(optee_core_init);\n\nstatic void __exit optee_core_exit(void)\n{\n\tif (!smc_abi_rc)\n\t\toptee_smc_abi_unregister();\n\tif (!ffa_abi_rc)\n\t\toptee_ffa_abi_unregister();\n}\nmodule_exit(optee_core_exit);\n\nMODULE_AUTHOR(\"Linaro\");\nMODULE_DESCRIPTION(\"OP-TEE driver\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:optee\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}