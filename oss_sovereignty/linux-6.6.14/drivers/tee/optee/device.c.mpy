{
  "module_name": "device.c",
  "hash_id": "8dc0e535d81d23122946706a89adeaeacd8c7069cf29a68a95299363b1108ac5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tee/optee/device.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/tee_drv.h>\n#include <linux/uuid.h>\n#include \"optee_private.h\"\n\nstatic int optee_ctx_match(struct tee_ioctl_version_data *ver, const void *data)\n{\n\tif (ver->impl_id == TEE_IMPL_ID_OPTEE)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int get_devices(struct tee_context *ctx, u32 session,\n\t\t       struct tee_shm *device_shm, u32 *shm_size,\n\t\t       u32 func)\n{\n\tint ret = 0;\n\tstruct tee_ioctl_invoke_arg inv_arg;\n\tstruct tee_param param[4];\n\n\tmemset(&inv_arg, 0, sizeof(inv_arg));\n\tmemset(&param, 0, sizeof(param));\n\n\tinv_arg.func = func;\n\tinv_arg.session = session;\n\tinv_arg.num_params = 4;\n\n\t \n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;\n\tparam[0].u.memref.shm = device_shm;\n\tparam[0].u.memref.size = *shm_size;\n\tparam[0].u.memref.shm_offs = 0;\n\n\tret = tee_client_invoke_func(ctx, &inv_arg, param);\n\tif ((ret < 0) || ((inv_arg.ret != TEEC_SUCCESS) &&\n\t\t\t  (inv_arg.ret != TEEC_ERROR_SHORT_BUFFER))) {\n\t\tpr_err(\"PTA_CMD_GET_DEVICES invoke function err: %x\\n\",\n\t\t       inv_arg.ret);\n\t\treturn -EINVAL;\n\t}\n\n\t*shm_size = param[0].u.memref.size;\n\n\treturn 0;\n}\n\nstatic void optee_release_device(struct device *dev)\n{\n\tstruct tee_client_device *optee_device = to_tee_client_device(dev);\n\n\tkfree(optee_device);\n}\n\nstatic ssize_t need_supplicant_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\treturn 0;\n}\n\nstatic DEVICE_ATTR_RO(need_supplicant);\n\nstatic int optee_register_device(const uuid_t *device_uuid, u32 func)\n{\n\tstruct tee_client_device *optee_device = NULL;\n\tint rc;\n\n\toptee_device = kzalloc(sizeof(*optee_device), GFP_KERNEL);\n\tif (!optee_device)\n\t\treturn -ENOMEM;\n\n\toptee_device->dev.bus = &tee_bus_type;\n\toptee_device->dev.release = optee_release_device;\n\tif (dev_set_name(&optee_device->dev, \"optee-ta-%pUb\", device_uuid)) {\n\t\tkfree(optee_device);\n\t\treturn -ENOMEM;\n\t}\n\tuuid_copy(&optee_device->id.uuid, device_uuid);\n\n\trc = device_register(&optee_device->dev);\n\tif (rc) {\n\t\tpr_err(\"device registration failed, err: %d\\n\", rc);\n\t\tput_device(&optee_device->dev);\n\t}\n\n\tif (func == PTA_CMD_GET_DEVICES_SUPP)\n\t\tdevice_create_file(&optee_device->dev,\n\t\t\t\t   &dev_attr_need_supplicant);\n\n\treturn rc;\n}\n\nstatic int __optee_enumerate_devices(u32 func)\n{\n\tconst uuid_t pta_uuid =\n\t\tUUID_INIT(0x7011a688, 0xddde, 0x4053,\n\t\t\t  0xa5, 0xa9, 0x7b, 0x3c, 0x4d, 0xdf, 0x13, 0xb8);\n\tstruct tee_ioctl_open_session_arg sess_arg;\n\tstruct tee_shm *device_shm = NULL;\n\tconst uuid_t *device_uuid = NULL;\n\tstruct tee_context *ctx = NULL;\n\tu32 shm_size = 0, idx, num_devices = 0;\n\tint rc;\n\n\tmemset(&sess_arg, 0, sizeof(sess_arg));\n\n\t \n\tctx = tee_client_open_context(NULL, optee_ctx_match, NULL, NULL);\n\tif (IS_ERR(ctx))\n\t\treturn -ENODEV;\n\n\t \n\texport_uuid(sess_arg.uuid, &pta_uuid);\n\tsess_arg.clnt_login = TEE_IOCTL_LOGIN_PUBLIC;\n\tsess_arg.num_params = 0;\n\n\trc = tee_client_open_session(ctx, &sess_arg, NULL);\n\tif ((rc < 0) || (sess_arg.ret != TEEC_SUCCESS)) {\n\t\t \n\t\trc = 0;\n\t\tgoto out_ctx;\n\t}\n\n\trc = get_devices(ctx, sess_arg.session, NULL, &shm_size, func);\n\tif (rc < 0 || !shm_size)\n\t\tgoto out_sess;\n\n\tdevice_shm = tee_shm_alloc_kernel_buf(ctx, shm_size);\n\tif (IS_ERR(device_shm)) {\n\t\tpr_err(\"tee_shm_alloc_kernel_buf failed\\n\");\n\t\trc = PTR_ERR(device_shm);\n\t\tgoto out_sess;\n\t}\n\n\trc = get_devices(ctx, sess_arg.session, device_shm, &shm_size, func);\n\tif (rc < 0)\n\t\tgoto out_shm;\n\n\tdevice_uuid = tee_shm_get_va(device_shm, 0);\n\tif (IS_ERR(device_uuid)) {\n\t\tpr_err(\"tee_shm_get_va failed\\n\");\n\t\trc = PTR_ERR(device_uuid);\n\t\tgoto out_shm;\n\t}\n\n\tnum_devices = shm_size / sizeof(uuid_t);\n\n\tfor (idx = 0; idx < num_devices; idx++) {\n\t\trc = optee_register_device(&device_uuid[idx], func);\n\t\tif (rc)\n\t\t\tgoto out_shm;\n\t}\n\nout_shm:\n\ttee_shm_free(device_shm);\nout_sess:\n\ttee_client_close_session(ctx, sess_arg.session);\nout_ctx:\n\ttee_client_close_context(ctx);\n\n\treturn rc;\n}\n\nint optee_enumerate_devices(u32 func)\n{\n\treturn  __optee_enumerate_devices(func);\n}\n\nstatic int __optee_unregister_device(struct device *dev, void *data)\n{\n\tif (!strncmp(dev_name(dev), \"optee-ta\", strlen(\"optee-ta\")))\n\t\tdevice_unregister(dev);\n\n\treturn 0;\n}\n\nvoid optee_unregister_devices(void)\n{\n\tbus_for_each_dev(&tee_bus_type, NULL, NULL,\n\t\t\t __optee_unregister_device);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}