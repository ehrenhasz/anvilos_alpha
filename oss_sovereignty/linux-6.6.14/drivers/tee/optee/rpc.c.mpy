{
  "module_name": "rpc.c",
  "hash_id": "7e097835057602d14b1b3c9bbf46d5781b6b0be1fbf4c6c14d1c65adf5872bc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tee/optee/rpc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/tee_drv.h>\n#include \"optee_private.h\"\n#include \"optee_rpc_cmd.h\"\n\nstatic void handle_rpc_func_cmd_get_time(struct optee_msg_arg *arg)\n{\n\tstruct timespec64 ts;\n\n\tif (arg->num_params != 1)\n\t\tgoto bad;\n\tif ((arg->params[0].attr & OPTEE_MSG_ATTR_TYPE_MASK) !=\n\t\t\tOPTEE_MSG_ATTR_TYPE_VALUE_OUTPUT)\n\t\tgoto bad;\n\n\tktime_get_real_ts64(&ts);\n\targ->params[0].u.value.a = ts.tv_sec;\n\targ->params[0].u.value.b = ts.tv_nsec;\n\n\targ->ret = TEEC_SUCCESS;\n\treturn;\nbad:\n\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n}\n\n#if IS_REACHABLE(CONFIG_I2C)\nstatic void handle_rpc_func_cmd_i2c_transfer(struct tee_context *ctx,\n\t\t\t\t\t     struct optee_msg_arg *arg)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tstruct tee_param *params;\n\tstruct i2c_adapter *adapter;\n\tstruct i2c_msg msg = { };\n\tsize_t i;\n\tint ret = -EOPNOTSUPP;\n\tu8 attr[] = {\n\t\tTEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT,\n\t\tTEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT,\n\t\tTEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT,\n\t\tTEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT,\n\t};\n\n\tif (arg->num_params != ARRAY_SIZE(attr)) {\n\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n\t\treturn;\n\t}\n\n\tparams = kmalloc_array(arg->num_params, sizeof(struct tee_param),\n\t\t\t       GFP_KERNEL);\n\tif (!params) {\n\t\targ->ret = TEEC_ERROR_OUT_OF_MEMORY;\n\t\treturn;\n\t}\n\n\tif (optee->ops->from_msg_param(optee, params, arg->num_params,\n\t\t\t\t       arg->params))\n\t\tgoto bad;\n\n\tfor (i = 0; i < arg->num_params; i++) {\n\t\tif (params[i].attr != attr[i])\n\t\t\tgoto bad;\n\t}\n\n\tadapter = i2c_get_adapter(params[0].u.value.b);\n\tif (!adapter)\n\t\tgoto bad;\n\n\tif (params[1].u.value.a & OPTEE_RPC_I2C_FLAGS_TEN_BIT) {\n\t\tif (!i2c_check_functionality(adapter,\n\t\t\t\t\t     I2C_FUNC_10BIT_ADDR)) {\n\t\t\ti2c_put_adapter(adapter);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tmsg.flags = I2C_M_TEN;\n\t}\n\n\tmsg.addr = params[0].u.value.c;\n\tmsg.buf  = params[2].u.memref.shm->kaddr;\n\tmsg.len  = params[2].u.memref.size;\n\n\tswitch (params[0].u.value.a) {\n\tcase OPTEE_RPC_I2C_TRANSFER_RD:\n\t\tmsg.flags |= I2C_M_RD;\n\t\tbreak;\n\tcase OPTEE_RPC_I2C_TRANSFER_WR:\n\t\tbreak;\n\tdefault:\n\t\ti2c_put_adapter(adapter);\n\t\tgoto bad;\n\t}\n\n\tret = i2c_transfer(adapter, &msg, 1);\n\n\tif (ret < 0) {\n\t\targ->ret = TEEC_ERROR_COMMUNICATION;\n\t} else {\n\t\tparams[3].u.value.a = msg.len;\n\t\tif (optee->ops->to_msg_param(optee, arg->params,\n\t\t\t\t\t     arg->num_params, params))\n\t\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n\t\telse\n\t\t\targ->ret = TEEC_SUCCESS;\n\t}\n\n\ti2c_put_adapter(adapter);\n\tkfree(params);\n\treturn;\nbad:\n\tkfree(params);\n\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n}\n#else\nstatic void handle_rpc_func_cmd_i2c_transfer(struct tee_context *ctx,\n\t\t\t\t\t     struct optee_msg_arg *arg)\n{\n\targ->ret = TEEC_ERROR_NOT_SUPPORTED;\n}\n#endif\n\nstatic void handle_rpc_func_cmd_wq(struct optee *optee,\n\t\t\t\t   struct optee_msg_arg *arg)\n{\n\tif (arg->num_params != 1)\n\t\tgoto bad;\n\n\tif ((arg->params[0].attr & OPTEE_MSG_ATTR_TYPE_MASK) !=\n\t\t\tOPTEE_MSG_ATTR_TYPE_VALUE_INPUT)\n\t\tgoto bad;\n\n\tswitch (arg->params[0].u.value.a) {\n\tcase OPTEE_RPC_NOTIFICATION_WAIT:\n\t\tif (optee_notif_wait(optee, arg->params[0].u.value.b))\n\t\t\tgoto bad;\n\t\tbreak;\n\tcase OPTEE_RPC_NOTIFICATION_SEND:\n\t\tif (optee_notif_send(optee, arg->params[0].u.value.b))\n\t\t\tgoto bad;\n\t\tbreak;\n\tdefault:\n\t\tgoto bad;\n\t}\n\n\targ->ret = TEEC_SUCCESS;\n\treturn;\nbad:\n\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n}\n\nstatic void handle_rpc_func_cmd_wait(struct optee_msg_arg *arg)\n{\n\tu32 msec_to_wait;\n\n\tif (arg->num_params != 1)\n\t\tgoto bad;\n\n\tif ((arg->params[0].attr & OPTEE_MSG_ATTR_TYPE_MASK) !=\n\t\t\tOPTEE_MSG_ATTR_TYPE_VALUE_INPUT)\n\t\tgoto bad;\n\n\tmsec_to_wait = arg->params[0].u.value.a;\n\n\t \n\tmsleep_interruptible(msec_to_wait);\n\n\targ->ret = TEEC_SUCCESS;\n\treturn;\nbad:\n\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n}\n\nstatic void handle_rpc_supp_cmd(struct tee_context *ctx, struct optee *optee,\n\t\t\t\tstruct optee_msg_arg *arg)\n{\n\tstruct tee_param *params;\n\n\targ->ret_origin = TEEC_ORIGIN_COMMS;\n\n\tparams = kmalloc_array(arg->num_params, sizeof(struct tee_param),\n\t\t\t       GFP_KERNEL);\n\tif (!params) {\n\t\targ->ret = TEEC_ERROR_OUT_OF_MEMORY;\n\t\treturn;\n\t}\n\n\tif (optee->ops->from_msg_param(optee, params, arg->num_params,\n\t\t\t\t       arg->params)) {\n\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\targ->ret = optee_supp_thrd_req(ctx, arg->cmd, arg->num_params, params);\n\n\tif (optee->ops->to_msg_param(optee, arg->params, arg->num_params,\n\t\t\t\t     params))\n\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\nout:\n\tkfree(params);\n}\n\nstruct tee_shm *optee_rpc_cmd_alloc_suppl(struct tee_context *ctx, size_t sz)\n{\n\tu32 ret;\n\tstruct tee_param param;\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tstruct tee_shm *shm;\n\n\tparam.attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT;\n\tparam.u.value.a = OPTEE_RPC_SHM_TYPE_APPL;\n\tparam.u.value.b = sz;\n\tparam.u.value.c = 0;\n\n\tret = optee_supp_thrd_req(ctx, OPTEE_RPC_CMD_SHM_ALLOC, 1, &param);\n\tif (ret)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&optee->supp.mutex);\n\t \n\tshm = tee_shm_get_from_id(optee->supp.ctx, param.u.value.c);\n\tmutex_unlock(&optee->supp.mutex);\n\treturn shm;\n}\n\nvoid optee_rpc_cmd_free_suppl(struct tee_context *ctx, struct tee_shm *shm)\n{\n\tstruct tee_param param;\n\n\tparam.attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT;\n\tparam.u.value.a = OPTEE_RPC_SHM_TYPE_APPL;\n\tparam.u.value.b = tee_shm_get_id(shm);\n\tparam.u.value.c = 0;\n\n\t \n\ttee_shm_put(shm);\n\n\toptee_supp_thrd_req(ctx, OPTEE_RPC_CMD_SHM_FREE, 1, &param);\n}\n\nvoid optee_rpc_cmd(struct tee_context *ctx, struct optee *optee,\n\t\t   struct optee_msg_arg *arg)\n{\n\tswitch (arg->cmd) {\n\tcase OPTEE_RPC_CMD_GET_TIME:\n\t\thandle_rpc_func_cmd_get_time(arg);\n\t\tbreak;\n\tcase OPTEE_RPC_CMD_NOTIFICATION:\n\t\thandle_rpc_func_cmd_wq(optee, arg);\n\t\tbreak;\n\tcase OPTEE_RPC_CMD_SUSPEND:\n\t\thandle_rpc_func_cmd_wait(arg);\n\t\tbreak;\n\tcase OPTEE_RPC_CMD_I2C_TRANSFER:\n\t\thandle_rpc_func_cmd_i2c_transfer(ctx, arg);\n\t\tbreak;\n\tdefault:\n\t\thandle_rpc_supp_cmd(ctx, optee, arg);\n\t}\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}