{
  "module_name": "smc_abi.c",
  "hash_id": "4d6027b22df295607095d136f0c1fa53a93b4b42b1c31e94c03ac8261ba0e5df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tee/optee/smc_abi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/arm-smccc.h>\n#include <linux/cpuhotplug.h>\n#include <linux/errno.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/tee_drv.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include \"optee_private.h\"\n#include \"optee_smc.h\"\n#include \"optee_rpc_cmd.h\"\n#include <linux/kmemleak.h>\n#define CREATE_TRACE_POINTS\n#include \"optee_trace.h\"\n\n \n\n \n#define OPTEE_MIN_STATIC_POOL_ALIGN    9  \n\n \nstatic unsigned int pcpu_irq_num;\n\nstatic int optee_cpuhp_enable_pcpu_irq(unsigned int cpu)\n{\n\tenable_percpu_irq(pcpu_irq_num, IRQ_TYPE_NONE);\n\n\treturn 0;\n}\n\nstatic int optee_cpuhp_disable_pcpu_irq(unsigned int cpu)\n{\n\tdisable_percpu_irq(pcpu_irq_num);\n\n\treturn 0;\n}\n\n \n\nstatic int from_msg_param_tmp_mem(struct tee_param *p, u32 attr,\n\t\t\t\t  const struct optee_msg_param *mp)\n{\n\tstruct tee_shm *shm;\n\tphys_addr_t pa;\n\tint rc;\n\n\tp->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT +\n\t\t  attr - OPTEE_MSG_ATTR_TYPE_TMEM_INPUT;\n\tp->u.memref.size = mp->u.tmem.size;\n\tshm = (struct tee_shm *)(unsigned long)mp->u.tmem.shm_ref;\n\tif (!shm) {\n\t\tp->u.memref.shm_offs = 0;\n\t\tp->u.memref.shm = NULL;\n\t\treturn 0;\n\t}\n\n\trc = tee_shm_get_pa(shm, 0, &pa);\n\tif (rc)\n\t\treturn rc;\n\n\tp->u.memref.shm_offs = mp->u.tmem.buf_ptr - pa;\n\tp->u.memref.shm = shm;\n\n\treturn 0;\n}\n\nstatic void from_msg_param_reg_mem(struct tee_param *p, u32 attr,\n\t\t\t\t   const struct optee_msg_param *mp)\n{\n\tstruct tee_shm *shm;\n\n\tp->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT +\n\t\t  attr - OPTEE_MSG_ATTR_TYPE_RMEM_INPUT;\n\tp->u.memref.size = mp->u.rmem.size;\n\tshm = (struct tee_shm *)(unsigned long)mp->u.rmem.shm_ref;\n\n\tif (shm) {\n\t\tp->u.memref.shm_offs = mp->u.rmem.offs;\n\t\tp->u.memref.shm = shm;\n\t} else {\n\t\tp->u.memref.shm_offs = 0;\n\t\tp->u.memref.shm = NULL;\n\t}\n}\n\n \nstatic int optee_from_msg_param(struct optee *optee, struct tee_param *params,\n\t\t\t\tsize_t num_params,\n\t\t\t\tconst struct optee_msg_param *msg_params)\n{\n\tint rc;\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tstruct tee_param *p = params + n;\n\t\tconst struct optee_msg_param *mp = msg_params + n;\n\t\tu32 attr = mp->attr & OPTEE_MSG_ATTR_TYPE_MASK;\n\n\t\tswitch (attr) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_NONE:\n\t\t\tp->attr = TEE_IOCTL_PARAM_ATTR_TYPE_NONE;\n\t\t\tmemset(&p->u, 0, sizeof(p->u));\n\t\t\tbreak;\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_INOUT:\n\t\t\toptee_from_msg_param_value(p, attr, mp);\n\t\t\tbreak;\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n\t\t\trc = from_msg_param_tmp_mem(p, attr, mp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n\t\t\tfrom_msg_param_reg_mem(p, attr, mp);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int to_msg_param_tmp_mem(struct optee_msg_param *mp,\n\t\t\t\tconst struct tee_param *p)\n{\n\tint rc;\n\tphys_addr_t pa;\n\n\tmp->attr = OPTEE_MSG_ATTR_TYPE_TMEM_INPUT + p->attr -\n\t\t   TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;\n\n\tmp->u.tmem.shm_ref = (unsigned long)p->u.memref.shm;\n\tmp->u.tmem.size = p->u.memref.size;\n\n\tif (!p->u.memref.shm) {\n\t\tmp->u.tmem.buf_ptr = 0;\n\t\treturn 0;\n\t}\n\n\trc = tee_shm_get_pa(p->u.memref.shm, p->u.memref.shm_offs, &pa);\n\tif (rc)\n\t\treturn rc;\n\n\tmp->u.tmem.buf_ptr = pa;\n\tmp->attr |= OPTEE_MSG_ATTR_CACHE_PREDEFINED <<\n\t\t    OPTEE_MSG_ATTR_CACHE_SHIFT;\n\n\treturn 0;\n}\n\nstatic int to_msg_param_reg_mem(struct optee_msg_param *mp,\n\t\t\t\tconst struct tee_param *p)\n{\n\tmp->attr = OPTEE_MSG_ATTR_TYPE_RMEM_INPUT + p->attr -\n\t\t   TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;\n\n\tmp->u.rmem.shm_ref = (unsigned long)p->u.memref.shm;\n\tmp->u.rmem.size = p->u.memref.size;\n\tmp->u.rmem.offs = p->u.memref.shm_offs;\n\treturn 0;\n}\n\n \nstatic int optee_to_msg_param(struct optee *optee,\n\t\t\t      struct optee_msg_param *msg_params,\n\t\t\t      size_t num_params, const struct tee_param *params)\n{\n\tint rc;\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tconst struct tee_param *p = params + n;\n\t\tstruct optee_msg_param *mp = msg_params + n;\n\n\t\tswitch (p->attr) {\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_NONE:\n\t\t\tmp->attr = TEE_IOCTL_PARAM_ATTR_TYPE_NONE;\n\t\t\tmemset(&mp->u, 0, sizeof(mp->u));\n\t\t\tbreak;\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:\n\t\t\toptee_to_msg_param_value(mp, p);\n\t\t\tbreak;\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:\n\t\t\tif (tee_shm_is_dynamic(p->u.memref.shm))\n\t\t\t\trc = to_msg_param_reg_mem(mp, p);\n\t\t\telse\n\t\t\t\trc = to_msg_param_tmp_mem(mp, p);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\n \nstatic void optee_enable_shm_cache(struct optee *optee)\n{\n\tstruct optee_call_waiter w;\n\n\t \n\toptee_cq_wait_init(&optee->call_queue, &w);\n\twhile (true) {\n\t\tstruct arm_smccc_res res;\n\n\t\toptee->smc.invoke_fn(OPTEE_SMC_ENABLE_SHM_CACHE,\n\t\t\t\t     0, 0, 0, 0, 0, 0, 0, &res);\n\t\tif (res.a0 == OPTEE_SMC_RETURN_OK)\n\t\t\tbreak;\n\t\toptee_cq_wait_for_completion(&optee->call_queue, &w);\n\t}\n\toptee_cq_wait_final(&optee->call_queue, &w);\n}\n\n \nstatic void __optee_disable_shm_cache(struct optee *optee, bool is_mapped)\n{\n\tstruct optee_call_waiter w;\n\n\t \n\toptee_cq_wait_init(&optee->call_queue, &w);\n\twhile (true) {\n\t\tunion {\n\t\t\tstruct arm_smccc_res smccc;\n\t\t\tstruct optee_smc_disable_shm_cache_result result;\n\t\t} res;\n\n\t\toptee->smc.invoke_fn(OPTEE_SMC_DISABLE_SHM_CACHE,\n\t\t\t\t     0, 0, 0, 0, 0, 0, 0, &res.smccc);\n\t\tif (res.result.status == OPTEE_SMC_RETURN_ENOTAVAIL)\n\t\t\tbreak;  \n\t\tif (res.result.status == OPTEE_SMC_RETURN_OK) {\n\t\t\tstruct tee_shm *shm;\n\n\t\t\t \n\t\t\tif (!is_mapped)\n\t\t\t\tcontinue;\n\n\t\t\tshm = reg_pair_to_ptr(res.result.shm_upper32,\n\t\t\t\t\t      res.result.shm_lower32);\n\t\t\ttee_shm_free(shm);\n\t\t} else {\n\t\t\toptee_cq_wait_for_completion(&optee->call_queue, &w);\n\t\t}\n\t}\n\toptee_cq_wait_final(&optee->call_queue, &w);\n}\n\n \nstatic void optee_disable_shm_cache(struct optee *optee)\n{\n\treturn __optee_disable_shm_cache(optee, true);\n}\n\n \nstatic void optee_disable_unmapped_shm_cache(struct optee *optee)\n{\n\treturn __optee_disable_shm_cache(optee, false);\n}\n\n#define PAGELIST_ENTRIES_PER_PAGE\t\t\t\t\\\n\t((OPTEE_MSG_NONCONTIG_PAGE_SIZE / sizeof(u64)) - 1)\n\n \nstatic size_t get_pages_list_size(size_t num_entries)\n{\n\tint pages = DIV_ROUND_UP(num_entries, PAGELIST_ENTRIES_PER_PAGE);\n\n\treturn pages * OPTEE_MSG_NONCONTIG_PAGE_SIZE;\n}\n\nstatic u64 *optee_allocate_pages_list(size_t num_entries)\n{\n\treturn alloc_pages_exact(get_pages_list_size(num_entries), GFP_KERNEL);\n}\n\nstatic void optee_free_pages_list(void *list, size_t num_entries)\n{\n\tfree_pages_exact(list, get_pages_list_size(num_entries));\n}\n\n \nstatic void optee_fill_pages_list(u64 *dst, struct page **pages, int num_pages,\n\t\t\t\t  size_t page_offset)\n{\n\tint n = 0;\n\tphys_addr_t optee_page;\n\t \n\tstruct {\n\t\tu64 pages_list[PAGELIST_ENTRIES_PER_PAGE];\n\t\tu64 next_page_data;\n\t} *pages_data;\n\n\t \n\tBUILD_BUG_ON(PAGE_SIZE < OPTEE_MSG_NONCONTIG_PAGE_SIZE);\n\n\tpages_data = (void *)dst;\n\t \n\toptee_page = page_to_phys(*pages) +\n\t\tround_down(page_offset, OPTEE_MSG_NONCONTIG_PAGE_SIZE);\n\n\twhile (true) {\n\t\tpages_data->pages_list[n++] = optee_page;\n\n\t\tif (n == PAGELIST_ENTRIES_PER_PAGE) {\n\t\t\tpages_data->next_page_data =\n\t\t\t\tvirt_to_phys(pages_data + 1);\n\t\t\tpages_data++;\n\t\t\tn = 0;\n\t\t}\n\n\t\toptee_page += OPTEE_MSG_NONCONTIG_PAGE_SIZE;\n\t\tif (!(optee_page & ~PAGE_MASK)) {\n\t\t\tif (!--num_pages)\n\t\t\t\tbreak;\n\t\t\tpages++;\n\t\t\toptee_page = page_to_phys(*pages);\n\t\t}\n\t}\n}\n\nstatic int optee_shm_register(struct tee_context *ctx, struct tee_shm *shm,\n\t\t\t      struct page **pages, size_t num_pages,\n\t\t\t      unsigned long start)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tstruct optee_msg_arg *msg_arg;\n\tstruct tee_shm *shm_arg;\n\tu64 *pages_list;\n\tsize_t sz;\n\tint rc;\n\n\tif (!num_pages)\n\t\treturn -EINVAL;\n\n\trc = optee_check_mem_type(start, num_pages);\n\tif (rc)\n\t\treturn rc;\n\n\tpages_list = optee_allocate_pages_list(num_pages);\n\tif (!pages_list)\n\t\treturn -ENOMEM;\n\n\t \n\tsz = optee_msg_arg_size(optee->rpc_param_count);\n\tshm_arg = tee_shm_alloc_priv_buf(ctx, sz);\n\tif (IS_ERR(shm_arg)) {\n\t\trc = PTR_ERR(shm_arg);\n\t\tgoto out;\n\t}\n\tmsg_arg = tee_shm_get_va(shm_arg, 0);\n\tif (IS_ERR(msg_arg)) {\n\t\trc = PTR_ERR(msg_arg);\n\t\tgoto out;\n\t}\n\n\toptee_fill_pages_list(pages_list, pages, num_pages,\n\t\t\t      tee_shm_get_page_offset(shm));\n\n\tmemset(msg_arg, 0, OPTEE_MSG_GET_ARG_SIZE(1));\n\tmsg_arg->num_params = 1;\n\tmsg_arg->cmd = OPTEE_MSG_CMD_REGISTER_SHM;\n\tmsg_arg->params->attr = OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT |\n\t\t\t\tOPTEE_MSG_ATTR_NONCONTIG;\n\tmsg_arg->params->u.tmem.shm_ref = (unsigned long)shm;\n\tmsg_arg->params->u.tmem.size = tee_shm_get_size(shm);\n\t \n\tmsg_arg->params->u.tmem.buf_ptr = virt_to_phys(pages_list) |\n\t  (tee_shm_get_page_offset(shm) & (OPTEE_MSG_NONCONTIG_PAGE_SIZE - 1));\n\n\tif (optee->ops->do_call_with_arg(ctx, shm_arg, 0) ||\n\t    msg_arg->ret != TEEC_SUCCESS)\n\t\trc = -EINVAL;\n\n\ttee_shm_free(shm_arg);\nout:\n\toptee_free_pages_list(pages_list, num_pages);\n\treturn rc;\n}\n\nstatic int optee_shm_unregister(struct tee_context *ctx, struct tee_shm *shm)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tstruct optee_msg_arg *msg_arg;\n\tstruct tee_shm *shm_arg;\n\tint rc = 0;\n\tsize_t sz;\n\n\t \n\tsz = optee_msg_arg_size(optee->rpc_param_count);\n\tshm_arg = tee_shm_alloc_priv_buf(ctx, sz);\n\tif (IS_ERR(shm_arg))\n\t\treturn PTR_ERR(shm_arg);\n\tmsg_arg = tee_shm_get_va(shm_arg, 0);\n\tif (IS_ERR(msg_arg)) {\n\t\trc = PTR_ERR(msg_arg);\n\t\tgoto out;\n\t}\n\n\tmemset(msg_arg, 0, sz);\n\tmsg_arg->num_params = 1;\n\tmsg_arg->cmd = OPTEE_MSG_CMD_UNREGISTER_SHM;\n\tmsg_arg->params[0].attr = OPTEE_MSG_ATTR_TYPE_RMEM_INPUT;\n\tmsg_arg->params[0].u.rmem.shm_ref = (unsigned long)shm;\n\n\tif (optee->ops->do_call_with_arg(ctx, shm_arg, 0) ||\n\t    msg_arg->ret != TEEC_SUCCESS)\n\t\trc = -EINVAL;\nout:\n\ttee_shm_free(shm_arg);\n\treturn rc;\n}\n\nstatic int optee_shm_register_supp(struct tee_context *ctx, struct tee_shm *shm,\n\t\t\t\t   struct page **pages, size_t num_pages,\n\t\t\t\t   unsigned long start)\n{\n\t \n\treturn optee_check_mem_type(start, num_pages);\n}\n\nstatic int optee_shm_unregister_supp(struct tee_context *ctx,\n\t\t\t\t     struct tee_shm *shm)\n{\n\treturn 0;\n}\n\n \n\nstatic int pool_op_alloc(struct tee_shm_pool *pool,\n\t\t\t struct tee_shm *shm, size_t size, size_t align)\n{\n\t \n\tif (shm->flags & TEE_SHM_PRIV)\n\t\treturn optee_pool_op_alloc_helper(pool, shm, size, align, NULL);\n\n\treturn optee_pool_op_alloc_helper(pool, shm, size, align,\n\t\t\t\t\t  optee_shm_register);\n}\n\nstatic void pool_op_free(struct tee_shm_pool *pool,\n\t\t\t struct tee_shm *shm)\n{\n\tif (!(shm->flags & TEE_SHM_PRIV))\n\t\toptee_pool_op_free_helper(pool, shm, optee_shm_unregister);\n\telse\n\t\toptee_pool_op_free_helper(pool, shm, NULL);\n}\n\nstatic void pool_op_destroy_pool(struct tee_shm_pool *pool)\n{\n\tkfree(pool);\n}\n\nstatic const struct tee_shm_pool_ops pool_ops = {\n\t.alloc = pool_op_alloc,\n\t.free = pool_op_free,\n\t.destroy_pool = pool_op_destroy_pool,\n};\n\n \nstatic struct tee_shm_pool *optee_shm_pool_alloc_pages(void)\n{\n\tstruct tee_shm_pool *pool = kzalloc(sizeof(*pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpool->ops = &pool_ops;\n\n\treturn pool;\n}\n\n \n\nstatic void handle_rpc_func_cmd_shm_free(struct tee_context *ctx,\n\t\t\t\t\t struct optee_msg_arg *arg)\n{\n\tstruct tee_shm *shm;\n\n\targ->ret_origin = TEEC_ORIGIN_COMMS;\n\n\tif (arg->num_params != 1 ||\n\t    arg->params[0].attr != OPTEE_MSG_ATTR_TYPE_VALUE_INPUT) {\n\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n\t\treturn;\n\t}\n\n\tshm = (struct tee_shm *)(unsigned long)arg->params[0].u.value.b;\n\tswitch (arg->params[0].u.value.a) {\n\tcase OPTEE_RPC_SHM_TYPE_APPL:\n\t\toptee_rpc_cmd_free_suppl(ctx, shm);\n\t\tbreak;\n\tcase OPTEE_RPC_SHM_TYPE_KERNEL:\n\t\ttee_shm_free(shm);\n\t\tbreak;\n\tdefault:\n\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n\t}\n\targ->ret = TEEC_SUCCESS;\n}\n\nstatic void handle_rpc_func_cmd_shm_alloc(struct tee_context *ctx,\n\t\t\t\t\t  struct optee *optee,\n\t\t\t\t\t  struct optee_msg_arg *arg,\n\t\t\t\t\t  struct optee_call_ctx *call_ctx)\n{\n\tphys_addr_t pa;\n\tstruct tee_shm *shm;\n\tsize_t sz;\n\tsize_t n;\n\n\targ->ret_origin = TEEC_ORIGIN_COMMS;\n\n\tif (!arg->num_params ||\n\t    arg->params[0].attr != OPTEE_MSG_ATTR_TYPE_VALUE_INPUT) {\n\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n\t\treturn;\n\t}\n\n\tfor (n = 1; n < arg->num_params; n++) {\n\t\tif (arg->params[n].attr != OPTEE_MSG_ATTR_TYPE_NONE) {\n\t\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsz = arg->params[0].u.value.b;\n\tswitch (arg->params[0].u.value.a) {\n\tcase OPTEE_RPC_SHM_TYPE_APPL:\n\t\tshm = optee_rpc_cmd_alloc_suppl(ctx, sz);\n\t\tbreak;\n\tcase OPTEE_RPC_SHM_TYPE_KERNEL:\n\t\tshm = tee_shm_alloc_priv_buf(optee->ctx, sz);\n\t\tbreak;\n\tdefault:\n\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n\t\treturn;\n\t}\n\n\tif (IS_ERR(shm)) {\n\t\targ->ret = TEEC_ERROR_OUT_OF_MEMORY;\n\t\treturn;\n\t}\n\n\tif (tee_shm_get_pa(shm, 0, &pa)) {\n\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n\t\tgoto bad;\n\t}\n\n\tsz = tee_shm_get_size(shm);\n\n\tif (tee_shm_is_dynamic(shm)) {\n\t\tstruct page **pages;\n\t\tu64 *pages_list;\n\t\tsize_t page_num;\n\n\t\tpages = tee_shm_get_pages(shm, &page_num);\n\t\tif (!pages || !page_num) {\n\t\t\targ->ret = TEEC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto bad;\n\t\t}\n\n\t\tpages_list = optee_allocate_pages_list(page_num);\n\t\tif (!pages_list) {\n\t\t\targ->ret = TEEC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto bad;\n\t\t}\n\n\t\tcall_ctx->pages_list = pages_list;\n\t\tcall_ctx->num_entries = page_num;\n\n\t\targ->params[0].attr = OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT |\n\t\t\t\t      OPTEE_MSG_ATTR_NONCONTIG;\n\t\t \n\t\targ->params[0].u.tmem.buf_ptr = virt_to_phys(pages_list) |\n\t\t\t(tee_shm_get_page_offset(shm) &\n\t\t\t (OPTEE_MSG_NONCONTIG_PAGE_SIZE - 1));\n\t\targ->params[0].u.tmem.size = tee_shm_get_size(shm);\n\t\targ->params[0].u.tmem.shm_ref = (unsigned long)shm;\n\n\t\toptee_fill_pages_list(pages_list, pages, page_num,\n\t\t\t\t      tee_shm_get_page_offset(shm));\n\t} else {\n\t\targ->params[0].attr = OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT;\n\t\targ->params[0].u.tmem.buf_ptr = pa;\n\t\targ->params[0].u.tmem.size = sz;\n\t\targ->params[0].u.tmem.shm_ref = (unsigned long)shm;\n\t}\n\n\targ->ret = TEEC_SUCCESS;\n\treturn;\nbad:\n\ttee_shm_free(shm);\n}\n\nstatic void free_pages_list(struct optee_call_ctx *call_ctx)\n{\n\tif (call_ctx->pages_list) {\n\t\toptee_free_pages_list(call_ctx->pages_list,\n\t\t\t\t      call_ctx->num_entries);\n\t\tcall_ctx->pages_list = NULL;\n\t\tcall_ctx->num_entries = 0;\n\t}\n}\n\nstatic void optee_rpc_finalize_call(struct optee_call_ctx *call_ctx)\n{\n\tfree_pages_list(call_ctx);\n}\n\nstatic void handle_rpc_func_cmd(struct tee_context *ctx, struct optee *optee,\n\t\t\t\tstruct optee_msg_arg *arg,\n\t\t\t\tstruct optee_call_ctx *call_ctx)\n{\n\n\tswitch (arg->cmd) {\n\tcase OPTEE_RPC_CMD_SHM_ALLOC:\n\t\tfree_pages_list(call_ctx);\n\t\thandle_rpc_func_cmd_shm_alloc(ctx, optee, arg, call_ctx);\n\t\tbreak;\n\tcase OPTEE_RPC_CMD_SHM_FREE:\n\t\thandle_rpc_func_cmd_shm_free(ctx, arg);\n\t\tbreak;\n\tdefault:\n\t\toptee_rpc_cmd(ctx, optee, arg);\n\t}\n}\n\n \nstatic void optee_handle_rpc(struct tee_context *ctx,\n\t\t\t     struct optee_msg_arg *rpc_arg,\n\t\t\t     struct optee_rpc_param *param,\n\t\t\t     struct optee_call_ctx *call_ctx)\n{\n\tstruct tee_device *teedev = ctx->teedev;\n\tstruct optee *optee = tee_get_drvdata(teedev);\n\tstruct optee_msg_arg *arg;\n\tstruct tee_shm *shm;\n\tphys_addr_t pa;\n\n\tswitch (OPTEE_SMC_RETURN_GET_RPC_FUNC(param->a0)) {\n\tcase OPTEE_SMC_RPC_FUNC_ALLOC:\n\t\tshm = tee_shm_alloc_priv_buf(optee->ctx, param->a1);\n\t\tif (!IS_ERR(shm) && !tee_shm_get_pa(shm, 0, &pa)) {\n\t\t\treg_pair_from_64(&param->a1, &param->a2, pa);\n\t\t\treg_pair_from_64(&param->a4, &param->a5,\n\t\t\t\t\t (unsigned long)shm);\n\t\t} else {\n\t\t\tparam->a1 = 0;\n\t\t\tparam->a2 = 0;\n\t\t\tparam->a4 = 0;\n\t\t\tparam->a5 = 0;\n\t\t}\n\t\tkmemleak_not_leak(shm);\n\t\tbreak;\n\tcase OPTEE_SMC_RPC_FUNC_FREE:\n\t\tshm = reg_pair_to_ptr(param->a1, param->a2);\n\t\ttee_shm_free(shm);\n\t\tbreak;\n\tcase OPTEE_SMC_RPC_FUNC_FOREIGN_INTR:\n\t\t \n\t\tbreak;\n\tcase OPTEE_SMC_RPC_FUNC_CMD:\n\t\tif (rpc_arg) {\n\t\t\targ = rpc_arg;\n\t\t} else {\n\t\t\tshm = reg_pair_to_ptr(param->a1, param->a2);\n\t\t\targ = tee_shm_get_va(shm, 0);\n\t\t\tif (IS_ERR(arg)) {\n\t\t\t\tpr_err(\"%s: tee_shm_get_va %p failed\\n\",\n\t\t\t\t       __func__, shm);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\thandle_rpc_func_cmd(ctx, optee, arg, call_ctx);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Unknown RPC func 0x%x\\n\",\n\t\t\t(u32)OPTEE_SMC_RETURN_GET_RPC_FUNC(param->a0));\n\t\tbreak;\n\t}\n\n\tparam->a0 = OPTEE_SMC_CALL_RETURN_FROM_RPC;\n}\n\n \nstatic int optee_smc_do_call_with_arg(struct tee_context *ctx,\n\t\t\t\t      struct tee_shm *shm, u_int offs)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tstruct optee_call_waiter w;\n\tstruct optee_rpc_param param = { };\n\tstruct optee_call_ctx call_ctx = { };\n\tstruct optee_msg_arg *rpc_arg = NULL;\n\tint rc;\n\n\tif (optee->rpc_param_count) {\n\t\tstruct optee_msg_arg *arg;\n\t\tunsigned int rpc_arg_offs;\n\n\t\targ = tee_shm_get_va(shm, offs);\n\t\tif (IS_ERR(arg))\n\t\t\treturn PTR_ERR(arg);\n\n\t\trpc_arg_offs = OPTEE_MSG_GET_ARG_SIZE(arg->num_params);\n\t\trpc_arg = tee_shm_get_va(shm, offs + rpc_arg_offs);\n\t\tif (IS_ERR(rpc_arg))\n\t\t\treturn PTR_ERR(rpc_arg);\n\t}\n\n\tif  (rpc_arg && tee_shm_is_dynamic(shm)) {\n\t\tparam.a0 = OPTEE_SMC_CALL_WITH_REGD_ARG;\n\t\treg_pair_from_64(&param.a1, &param.a2, (u_long)shm);\n\t\tparam.a3 = offs;\n\t} else {\n\t\tphys_addr_t parg;\n\n\t\trc = tee_shm_get_pa(shm, offs, &parg);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tif (rpc_arg)\n\t\t\tparam.a0 = OPTEE_SMC_CALL_WITH_RPC_ARG;\n\t\telse\n\t\t\tparam.a0 = OPTEE_SMC_CALL_WITH_ARG;\n\t\treg_pair_from_64(&param.a1, &param.a2, parg);\n\t}\n\t \n\toptee_cq_wait_init(&optee->call_queue, &w);\n\twhile (true) {\n\t\tstruct arm_smccc_res res;\n\n\t\ttrace_optee_invoke_fn_begin(&param);\n\t\toptee->smc.invoke_fn(param.a0, param.a1, param.a2, param.a3,\n\t\t\t\t     param.a4, param.a5, param.a6, param.a7,\n\t\t\t\t     &res);\n\t\ttrace_optee_invoke_fn_end(&param, &res);\n\n\t\tif (res.a0 == OPTEE_SMC_RETURN_ETHREAD_LIMIT) {\n\t\t\t \n\t\t\toptee_cq_wait_for_completion(&optee->call_queue, &w);\n\t\t} else if (OPTEE_SMC_RETURN_IS_RPC(res.a0)) {\n\t\t\tcond_resched();\n\t\t\tparam.a0 = res.a0;\n\t\t\tparam.a1 = res.a1;\n\t\t\tparam.a2 = res.a2;\n\t\t\tparam.a3 = res.a3;\n\t\t\toptee_handle_rpc(ctx, rpc_arg, &param, &call_ctx);\n\t\t} else {\n\t\t\trc = res.a0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\toptee_rpc_finalize_call(&call_ctx);\n\t \n\toptee_cq_wait_final(&optee->call_queue, &w);\n\n\treturn rc;\n}\n\nstatic int simple_call_with_arg(struct tee_context *ctx, u32 cmd)\n{\n\tstruct optee_shm_arg_entry *entry;\n\tstruct optee_msg_arg *msg_arg;\n\tstruct tee_shm *shm;\n\tu_int offs;\n\n\tmsg_arg = optee_get_msg_arg(ctx, 0, &entry, &shm, &offs);\n\tif (IS_ERR(msg_arg))\n\t\treturn PTR_ERR(msg_arg);\n\n\tmsg_arg->cmd = cmd;\n\toptee_smc_do_call_with_arg(ctx, shm, offs);\n\n\toptee_free_msg_arg(ctx, entry, offs);\n\treturn 0;\n}\n\nstatic int optee_smc_do_bottom_half(struct tee_context *ctx)\n{\n\treturn simple_call_with_arg(ctx, OPTEE_MSG_CMD_DO_BOTTOM_HALF);\n}\n\nstatic int optee_smc_stop_async_notif(struct tee_context *ctx)\n{\n\treturn simple_call_with_arg(ctx, OPTEE_MSG_CMD_STOP_ASYNC_NOTIF);\n}\n\n \n\nstatic u32 get_async_notif_value(optee_invoke_fn *invoke_fn, bool *value_valid,\n\t\t\t\t bool *value_pending)\n{\n\tstruct arm_smccc_res res;\n\n\tinvoke_fn(OPTEE_SMC_GET_ASYNC_NOTIF_VALUE, 0, 0, 0, 0, 0, 0, 0, &res);\n\n\tif (res.a0) {\n\t\t*value_valid = false;\n\t\treturn 0;\n\t}\n\t*value_valid = (res.a2 & OPTEE_SMC_ASYNC_NOTIF_VALUE_VALID);\n\t*value_pending = (res.a2 & OPTEE_SMC_ASYNC_NOTIF_VALUE_PENDING);\n\treturn res.a1;\n}\n\nstatic irqreturn_t irq_handler(struct optee *optee)\n{\n\tbool do_bottom_half = false;\n\tbool value_valid;\n\tbool value_pending;\n\tu32 value;\n\n\tdo {\n\t\tvalue = get_async_notif_value(optee->smc.invoke_fn,\n\t\t\t\t\t      &value_valid, &value_pending);\n\t\tif (!value_valid)\n\t\t\tbreak;\n\n\t\tif (value == OPTEE_SMC_ASYNC_NOTIF_VALUE_DO_BOTTOM_HALF)\n\t\t\tdo_bottom_half = true;\n\t\telse\n\t\t\toptee_notif_send(optee, value);\n\t} while (value_pending);\n\n\tif (do_bottom_half)\n\t\treturn IRQ_WAKE_THREAD;\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t notif_irq_handler(int irq, void *dev_id)\n{\n\tstruct optee *optee = dev_id;\n\n\treturn irq_handler(optee);\n}\n\nstatic irqreturn_t notif_irq_thread_fn(int irq, void *dev_id)\n{\n\tstruct optee *optee = dev_id;\n\n\toptee_smc_do_bottom_half(optee->ctx);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int init_irq(struct optee *optee, u_int irq)\n{\n\tint rc;\n\n\trc = request_threaded_irq(irq, notif_irq_handler,\n\t\t\t\t  notif_irq_thread_fn,\n\t\t\t\t  0, \"optee_notification\", optee);\n\tif (rc)\n\t\treturn rc;\n\n\toptee->smc.notif_irq = irq;\n\n\treturn 0;\n}\n\nstatic irqreturn_t notif_pcpu_irq_handler(int irq, void *dev_id)\n{\n\tstruct optee_pcpu *pcpu = dev_id;\n\tstruct optee *optee = pcpu->optee;\n\n\tif (irq_handler(optee) == IRQ_WAKE_THREAD)\n\t\tqueue_work(optee->smc.notif_pcpu_wq,\n\t\t\t   &optee->smc.notif_pcpu_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void notif_pcpu_irq_work_fn(struct work_struct *work)\n{\n\tstruct optee_smc *optee_smc = container_of(work, struct optee_smc,\n\t\t\t\t\t\t   notif_pcpu_work);\n\tstruct optee *optee = container_of(optee_smc, struct optee, smc);\n\n\toptee_smc_do_bottom_half(optee->ctx);\n}\n\nstatic int init_pcpu_irq(struct optee *optee, u_int irq)\n{\n\tstruct optee_pcpu __percpu *optee_pcpu;\n\tint cpu, rc;\n\n\toptee_pcpu = alloc_percpu(struct optee_pcpu);\n\tif (!optee_pcpu)\n\t\treturn -ENOMEM;\n\n\tfor_each_present_cpu(cpu)\n\t\tper_cpu_ptr(optee_pcpu, cpu)->optee = optee;\n\n\trc = request_percpu_irq(irq, notif_pcpu_irq_handler,\n\t\t\t\t\"optee_pcpu_notification\", optee_pcpu);\n\tif (rc)\n\t\tgoto err_free_pcpu;\n\n\tINIT_WORK(&optee->smc.notif_pcpu_work, notif_pcpu_irq_work_fn);\n\toptee->smc.notif_pcpu_wq = create_workqueue(\"optee_pcpu_notification\");\n\tif (!optee->smc.notif_pcpu_wq) {\n\t\trc = -EINVAL;\n\t\tgoto err_free_pcpu_irq;\n\t}\n\n\toptee->smc.optee_pcpu = optee_pcpu;\n\toptee->smc.notif_irq = irq;\n\n\tpcpu_irq_num = irq;\n\trc = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"optee/pcpu-notif:starting\",\n\t\t\t       optee_cpuhp_enable_pcpu_irq,\n\t\t\t       optee_cpuhp_disable_pcpu_irq);\n\tif (!rc)\n\t\trc = -EINVAL;\n\tif (rc < 0)\n\t\tgoto err_free_pcpu_irq;\n\n\toptee->smc.notif_cpuhp_state = rc;\n\n\treturn 0;\n\nerr_free_pcpu_irq:\n\tfree_percpu_irq(irq, optee_pcpu);\nerr_free_pcpu:\n\tfree_percpu(optee_pcpu);\n\n\treturn rc;\n}\n\nstatic int optee_smc_notif_init_irq(struct optee *optee, u_int irq)\n{\n\tif (irq_is_percpu_devid(irq))\n\t\treturn init_pcpu_irq(optee, irq);\n\telse\n\t\treturn init_irq(optee, irq);\n}\n\nstatic void uninit_pcpu_irq(struct optee *optee)\n{\n\tcpuhp_remove_state(optee->smc.notif_cpuhp_state);\n\n\tdestroy_workqueue(optee->smc.notif_pcpu_wq);\n\n\tfree_percpu_irq(optee->smc.notif_irq, optee->smc.optee_pcpu);\n\tfree_percpu(optee->smc.optee_pcpu);\n}\n\nstatic void optee_smc_notif_uninit_irq(struct optee *optee)\n{\n\tif (optee->smc.sec_caps & OPTEE_SMC_SEC_CAP_ASYNC_NOTIF) {\n\t\toptee_smc_stop_async_notif(optee->ctx);\n\t\tif (optee->smc.notif_irq) {\n\t\t\tif (irq_is_percpu_devid(optee->smc.notif_irq))\n\t\t\t\tuninit_pcpu_irq(optee);\n\t\t\telse\n\t\t\t\tfree_irq(optee->smc.notif_irq, optee);\n\n\t\t\tirq_dispose_mapping(optee->smc.notif_irq);\n\t\t}\n\t}\n}\n\n \n\nstatic void optee_get_version(struct tee_device *teedev,\n\t\t\t      struct tee_ioctl_version_data *vers)\n{\n\tstruct tee_ioctl_version_data v = {\n\t\t.impl_id = TEE_IMPL_ID_OPTEE,\n\t\t.impl_caps = TEE_OPTEE_CAP_TZ,\n\t\t.gen_caps = TEE_GEN_CAP_GP,\n\t};\n\tstruct optee *optee = tee_get_drvdata(teedev);\n\n\tif (optee->smc.sec_caps & OPTEE_SMC_SEC_CAP_DYNAMIC_SHM)\n\t\tv.gen_caps |= TEE_GEN_CAP_REG_MEM;\n\tif (optee->smc.sec_caps & OPTEE_SMC_SEC_CAP_MEMREF_NULL)\n\t\tv.gen_caps |= TEE_GEN_CAP_MEMREF_NULL;\n\t*vers = v;\n}\n\nstatic int optee_smc_open(struct tee_context *ctx)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tu32 sec_caps = optee->smc.sec_caps;\n\n\treturn optee_open(ctx, sec_caps & OPTEE_SMC_SEC_CAP_MEMREF_NULL);\n}\n\nstatic const struct tee_driver_ops optee_clnt_ops = {\n\t.get_version = optee_get_version,\n\t.open = optee_smc_open,\n\t.release = optee_release,\n\t.open_session = optee_open_session,\n\t.close_session = optee_close_session,\n\t.invoke_func = optee_invoke_func,\n\t.cancel_req = optee_cancel_req,\n\t.shm_register = optee_shm_register,\n\t.shm_unregister = optee_shm_unregister,\n};\n\nstatic const struct tee_desc optee_clnt_desc = {\n\t.name = DRIVER_NAME \"-clnt\",\n\t.ops = &optee_clnt_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct tee_driver_ops optee_supp_ops = {\n\t.get_version = optee_get_version,\n\t.open = optee_smc_open,\n\t.release = optee_release_supp,\n\t.supp_recv = optee_supp_recv,\n\t.supp_send = optee_supp_send,\n\t.shm_register = optee_shm_register_supp,\n\t.shm_unregister = optee_shm_unregister_supp,\n};\n\nstatic const struct tee_desc optee_supp_desc = {\n\t.name = DRIVER_NAME \"-supp\",\n\t.ops = &optee_supp_ops,\n\t.owner = THIS_MODULE,\n\t.flags = TEE_DESC_PRIVILEGED,\n};\n\nstatic const struct optee_ops optee_ops = {\n\t.do_call_with_arg = optee_smc_do_call_with_arg,\n\t.to_msg_param = optee_to_msg_param,\n\t.from_msg_param = optee_from_msg_param,\n};\n\nstatic int enable_async_notif(optee_invoke_fn *invoke_fn)\n{\n\tstruct arm_smccc_res res;\n\n\tinvoke_fn(OPTEE_SMC_ENABLE_ASYNC_NOTIF, 0, 0, 0, 0, 0, 0, 0, &res);\n\n\tif (res.a0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic bool optee_msg_api_uid_is_optee_api(optee_invoke_fn *invoke_fn)\n{\n\tstruct arm_smccc_res res;\n\n\tinvoke_fn(OPTEE_SMC_CALLS_UID, 0, 0, 0, 0, 0, 0, 0, &res);\n\n\tif (res.a0 == OPTEE_MSG_UID_0 && res.a1 == OPTEE_MSG_UID_1 &&\n\t    res.a2 == OPTEE_MSG_UID_2 && res.a3 == OPTEE_MSG_UID_3)\n\t\treturn true;\n\treturn false;\n}\n\n#ifdef CONFIG_OPTEE_INSECURE_LOAD_IMAGE\nstatic bool optee_msg_api_uid_is_optee_image_load(optee_invoke_fn *invoke_fn)\n{\n\tstruct arm_smccc_res res;\n\n\tinvoke_fn(OPTEE_SMC_CALLS_UID, 0, 0, 0, 0, 0, 0, 0, &res);\n\n\tif (res.a0 == OPTEE_MSG_IMAGE_LOAD_UID_0 &&\n\t    res.a1 == OPTEE_MSG_IMAGE_LOAD_UID_1 &&\n\t    res.a2 == OPTEE_MSG_IMAGE_LOAD_UID_2 &&\n\t    res.a3 == OPTEE_MSG_IMAGE_LOAD_UID_3)\n\t\treturn true;\n\treturn false;\n}\n#endif\n\nstatic void optee_msg_get_os_revision(optee_invoke_fn *invoke_fn)\n{\n\tunion {\n\t\tstruct arm_smccc_res smccc;\n\t\tstruct optee_smc_call_get_os_revision_result result;\n\t} res = {\n\t\t.result = {\n\t\t\t.build_id = 0\n\t\t}\n\t};\n\n\tinvoke_fn(OPTEE_SMC_CALL_GET_OS_REVISION, 0, 0, 0, 0, 0, 0, 0,\n\t\t  &res.smccc);\n\n\tif (res.result.build_id)\n\t\tpr_info(\"revision %lu.%lu (%08lx)\", res.result.major,\n\t\t\tres.result.minor, res.result.build_id);\n\telse\n\t\tpr_info(\"revision %lu.%lu\", res.result.major, res.result.minor);\n}\n\nstatic bool optee_msg_api_revision_is_compatible(optee_invoke_fn *invoke_fn)\n{\n\tunion {\n\t\tstruct arm_smccc_res smccc;\n\t\tstruct optee_smc_calls_revision_result result;\n\t} res;\n\n\tinvoke_fn(OPTEE_SMC_CALLS_REVISION, 0, 0, 0, 0, 0, 0, 0, &res.smccc);\n\n\tif (res.result.major == OPTEE_MSG_REVISION_MAJOR &&\n\t    (int)res.result.minor >= OPTEE_MSG_REVISION_MINOR)\n\t\treturn true;\n\treturn false;\n}\n\nstatic bool optee_msg_exchange_capabilities(optee_invoke_fn *invoke_fn,\n\t\t\t\t\t    u32 *sec_caps, u32 *max_notif_value,\n\t\t\t\t\t    unsigned int *rpc_param_count)\n{\n\tunion {\n\t\tstruct arm_smccc_res smccc;\n\t\tstruct optee_smc_exchange_capabilities_result result;\n\t} res;\n\tu32 a1 = 0;\n\n\t \n\tif (!IS_ENABLED(CONFIG_SMP) || nr_cpu_ids == 1)\n\t\ta1 |= OPTEE_SMC_NSEC_CAP_UNIPROCESSOR;\n\n\tinvoke_fn(OPTEE_SMC_EXCHANGE_CAPABILITIES, a1, 0, 0, 0, 0, 0, 0,\n\t\t  &res.smccc);\n\n\tif (res.result.status != OPTEE_SMC_RETURN_OK)\n\t\treturn false;\n\n\t*sec_caps = res.result.capabilities;\n\tif (*sec_caps & OPTEE_SMC_SEC_CAP_ASYNC_NOTIF)\n\t\t*max_notif_value = res.result.max_notif_value;\n\telse\n\t\t*max_notif_value = OPTEE_DEFAULT_MAX_NOTIF_VALUE;\n\tif (*sec_caps & OPTEE_SMC_SEC_CAP_RPC_ARG)\n\t\t*rpc_param_count = (u8)res.result.data;\n\telse\n\t\t*rpc_param_count = 0;\n\n\treturn true;\n}\n\nstatic struct tee_shm_pool *\noptee_config_shm_memremap(optee_invoke_fn *invoke_fn, void **memremaped_shm)\n{\n\tunion {\n\t\tstruct arm_smccc_res smccc;\n\t\tstruct optee_smc_get_shm_config_result result;\n\t} res;\n\tunsigned long vaddr;\n\tphys_addr_t paddr;\n\tsize_t size;\n\tphys_addr_t begin;\n\tphys_addr_t end;\n\tvoid *va;\n\tvoid *rc;\n\n\tinvoke_fn(OPTEE_SMC_GET_SHM_CONFIG, 0, 0, 0, 0, 0, 0, 0, &res.smccc);\n\tif (res.result.status != OPTEE_SMC_RETURN_OK) {\n\t\tpr_err(\"static shm service not available\\n\");\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tif (res.result.settings != OPTEE_SMC_SHM_CACHED) {\n\t\tpr_err(\"only normal cached shared memory supported\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbegin = roundup(res.result.start, PAGE_SIZE);\n\tend = rounddown(res.result.start + res.result.size, PAGE_SIZE);\n\tpaddr = begin;\n\tsize = end - begin;\n\n\tva = memremap(paddr, size, MEMREMAP_WB);\n\tif (!va) {\n\t\tpr_err(\"shared memory ioremap failed\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tvaddr = (unsigned long)va;\n\n\trc = tee_shm_pool_alloc_res_mem(vaddr, paddr, size,\n\t\t\t\t\tOPTEE_MIN_STATIC_POOL_ALIGN);\n\tif (IS_ERR(rc))\n\t\tmemunmap(va);\n\telse\n\t\t*memremaped_shm = va;\n\n\treturn rc;\n}\n\n \nstatic void optee_smccc_smc(unsigned long a0, unsigned long a1,\n\t\t\t    unsigned long a2, unsigned long a3,\n\t\t\t    unsigned long a4, unsigned long a5,\n\t\t\t    unsigned long a6, unsigned long a7,\n\t\t\t    struct arm_smccc_res *res)\n{\n\tarm_smccc_smc(a0, a1, a2, a3, a4, a5, a6, a7, res);\n}\n\nstatic void optee_smccc_hvc(unsigned long a0, unsigned long a1,\n\t\t\t    unsigned long a2, unsigned long a3,\n\t\t\t    unsigned long a4, unsigned long a5,\n\t\t\t    unsigned long a6, unsigned long a7,\n\t\t\t    struct arm_smccc_res *res)\n{\n\tarm_smccc_hvc(a0, a1, a2, a3, a4, a5, a6, a7, res);\n}\n\nstatic optee_invoke_fn *get_invoke_func(struct device *dev)\n{\n\tconst char *method;\n\n\tpr_info(\"probing for conduit method.\\n\");\n\n\tif (device_property_read_string(dev, \"method\", &method)) {\n\t\tpr_warn(\"missing \\\"method\\\" property\\n\");\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\tif (!strcmp(\"hvc\", method))\n\t\treturn optee_smccc_hvc;\n\telse if (!strcmp(\"smc\", method))\n\t\treturn optee_smccc_smc;\n\n\tpr_warn(\"invalid \\\"method\\\" property: %s\\n\", method);\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstatic int optee_smc_remove(struct platform_device *pdev)\n{\n\tstruct optee *optee = platform_get_drvdata(pdev);\n\n\t \n\tif (!optee->rpc_param_count)\n\t\toptee_disable_shm_cache(optee);\n\n\toptee_smc_notif_uninit_irq(optee);\n\n\toptee_remove_common(optee);\n\n\tif (optee->smc.memremaped_shm)\n\t\tmemunmap(optee->smc.memremaped_shm);\n\n\tkfree(optee);\n\n\treturn 0;\n}\n\n \nstatic void optee_shutdown(struct platform_device *pdev)\n{\n\tstruct optee *optee = platform_get_drvdata(pdev);\n\n\tif (!optee->rpc_param_count)\n\t\toptee_disable_shm_cache(optee);\n}\n\n#ifdef CONFIG_OPTEE_INSECURE_LOAD_IMAGE\n\n#define OPTEE_FW_IMAGE \"optee/tee.bin\"\n\nstatic optee_invoke_fn *cpuhp_invoke_fn;\n\nstatic int optee_cpuhp_probe(unsigned int cpu)\n{\n\t \n\tif (optee_msg_api_uid_is_optee_api(cpuhp_invoke_fn))\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic int optee_load_fw(struct platform_device *pdev,\n\t\t\t optee_invoke_fn *invoke_fn)\n{\n\tconst struct firmware *fw = NULL;\n\tstruct arm_smccc_res res;\n\tphys_addr_t data_pa;\n\tu8 *data_buf = NULL;\n\tu64 data_size;\n\tu32 data_pa_high, data_pa_low;\n\tu32 data_size_high, data_size_low;\n\tint rc;\n\tint hp_state;\n\n\tif (!optee_msg_api_uid_is_optee_image_load(invoke_fn))\n\t\treturn 0;\n\n\trc = request_firmware(&fw, OPTEE_FW_IMAGE, &pdev->dev);\n\tif (rc) {\n\t\t \n\t\tif (system_state < SYSTEM_RUNNING)\n\t\t\treturn -EPROBE_DEFER;\n\t\tgoto fw_err;\n\t}\n\n\tdata_size = fw->size;\n\t \n\tdata_buf = kmemdup(fw->data, fw->size, GFP_KERNEL | GFP_DMA);\n\tif (!data_buf) {\n\t\trc = -ENOMEM;\n\t\tgoto fw_err;\n\t}\n\tdata_pa = virt_to_phys(data_buf);\n\treg_pair_from_64(&data_pa_high, &data_pa_low, data_pa);\n\treg_pair_from_64(&data_size_high, &data_size_low, data_size);\n\tgoto fw_load;\n\nfw_err:\n\tpr_warn(\"image loading failed\\n\");\n\tdata_pa_high = 0;\n\tdata_pa_low = 0;\n\tdata_size_high = 0;\n\tdata_size_low = 0;\n\nfw_load:\n\t \n\tpr_warn(\"OP-TEE image loaded from kernel, this can be insecure\");\n\tinvoke_fn(OPTEE_SMC_CALL_LOAD_IMAGE, data_size_high, data_size_low,\n\t\t  data_pa_high, data_pa_low, 0, 0, 0, &res);\n\tif (!rc)\n\t\trc = res.a0;\n\tif (fw)\n\t\trelease_firmware(fw);\n\tkfree(data_buf);\n\n\tif (!rc) {\n\t\t \n\t\tcpuhp_invoke_fn = invoke_fn;\n\t\thp_state = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"optee:probe\",\n\t\t\t\t\t     optee_cpuhp_probe, NULL);\n\t\tif (hp_state < 0) {\n\t\t\tpr_warn(\"Failed with CPU hotplug setup for OP-TEE\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcpuhp_remove_state(hp_state);\n\t\tcpuhp_invoke_fn = NULL;\n\t}\n\n\treturn rc;\n}\n#else\nstatic inline int optee_load_fw(struct platform_device *pdev,\n\t\t\t\toptee_invoke_fn *invoke_fn)\n{\n\treturn 0;\n}\n#endif\n\nstatic int optee_probe(struct platform_device *pdev)\n{\n\toptee_invoke_fn *invoke_fn;\n\tstruct tee_shm_pool *pool = ERR_PTR(-EINVAL);\n\tstruct optee *optee = NULL;\n\tvoid *memremaped_shm = NULL;\n\tunsigned int rpc_param_count;\n\tstruct tee_device *teedev;\n\tstruct tee_context *ctx;\n\tu32 max_notif_value;\n\tu32 arg_cache_flags;\n\tu32 sec_caps;\n\tint rc;\n\n\tinvoke_fn = get_invoke_func(&pdev->dev);\n\tif (IS_ERR(invoke_fn))\n\t\treturn PTR_ERR(invoke_fn);\n\n\trc = optee_load_fw(pdev, invoke_fn);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!optee_msg_api_uid_is_optee_api(invoke_fn)) {\n\t\tpr_warn(\"api uid mismatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toptee_msg_get_os_revision(invoke_fn);\n\n\tif (!optee_msg_api_revision_is_compatible(invoke_fn)) {\n\t\tpr_warn(\"api revision mismatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!optee_msg_exchange_capabilities(invoke_fn, &sec_caps,\n\t\t\t\t\t     &max_notif_value,\n\t\t\t\t\t     &rpc_param_count)) {\n\t\tpr_warn(\"capabilities mismatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (sec_caps & OPTEE_SMC_SEC_CAP_DYNAMIC_SHM) {\n\t\t \n\t\tif (sec_caps & OPTEE_SMC_SEC_CAP_RPC_ARG)\n\t\t\targ_cache_flags = OPTEE_SHM_ARG_SHARED;\n\t\telse\n\t\t\targ_cache_flags = OPTEE_SHM_ARG_ALLOC_PRIV;\n\n\t\tpool = optee_shm_pool_alloc_pages();\n\t}\n\n\t \n\tif (IS_ERR(pool) && (sec_caps & OPTEE_SMC_SEC_CAP_HAVE_RESERVED_SHM)) {\n\t\t \n\t\targ_cache_flags = OPTEE_SHM_ARG_SHARED |\n\t\t\t\t  OPTEE_SHM_ARG_ALLOC_PRIV;\n\t\tpool = optee_config_shm_memremap(invoke_fn, &memremaped_shm);\n\t}\n\n\tif (IS_ERR(pool))\n\t\treturn PTR_ERR(pool);\n\n\toptee = kzalloc(sizeof(*optee), GFP_KERNEL);\n\tif (!optee) {\n\t\trc = -ENOMEM;\n\t\tgoto err_free_pool;\n\t}\n\n\toptee->ops = &optee_ops;\n\toptee->smc.invoke_fn = invoke_fn;\n\toptee->smc.sec_caps = sec_caps;\n\toptee->rpc_param_count = rpc_param_count;\n\n\tteedev = tee_device_alloc(&optee_clnt_desc, NULL, pool, optee);\n\tif (IS_ERR(teedev)) {\n\t\trc = PTR_ERR(teedev);\n\t\tgoto err_free_optee;\n\t}\n\toptee->teedev = teedev;\n\n\tteedev = tee_device_alloc(&optee_supp_desc, NULL, pool, optee);\n\tif (IS_ERR(teedev)) {\n\t\trc = PTR_ERR(teedev);\n\t\tgoto err_unreg_teedev;\n\t}\n\toptee->supp_teedev = teedev;\n\n\trc = tee_device_register(optee->teedev);\n\tif (rc)\n\t\tgoto err_unreg_supp_teedev;\n\n\trc = tee_device_register(optee->supp_teedev);\n\tif (rc)\n\t\tgoto err_unreg_supp_teedev;\n\n\tmutex_init(&optee->call_queue.mutex);\n\tINIT_LIST_HEAD(&optee->call_queue.waiters);\n\toptee_supp_init(&optee->supp);\n\toptee->smc.memremaped_shm = memremaped_shm;\n\toptee->pool = pool;\n\toptee_shm_arg_cache_init(optee, arg_cache_flags);\n\n\tplatform_set_drvdata(pdev, optee);\n\tctx = teedev_open(optee->teedev);\n\tif (IS_ERR(ctx)) {\n\t\trc = PTR_ERR(ctx);\n\t\tgoto err_supp_uninit;\n\t}\n\toptee->ctx = ctx;\n\trc = optee_notif_init(optee, max_notif_value);\n\tif (rc)\n\t\tgoto err_close_ctx;\n\n\tif (sec_caps & OPTEE_SMC_SEC_CAP_ASYNC_NOTIF) {\n\t\tunsigned int irq;\n\n\t\trc = platform_get_irq(pdev, 0);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"platform_get_irq: ret %d\\n\", rc);\n\t\t\tgoto err_notif_uninit;\n\t\t}\n\t\tirq = rc;\n\n\t\trc = optee_smc_notif_init_irq(optee, irq);\n\t\tif (rc) {\n\t\t\tirq_dispose_mapping(irq);\n\t\t\tgoto err_notif_uninit;\n\t\t}\n\t\tenable_async_notif(optee->smc.invoke_fn);\n\t\tpr_info(\"Asynchronous notifications enabled\\n\");\n\t}\n\n\t \n\toptee_disable_unmapped_shm_cache(optee);\n\n\t \n\tif (!optee->rpc_param_count)\n\t\toptee_enable_shm_cache(optee);\n\n\tif (optee->smc.sec_caps & OPTEE_SMC_SEC_CAP_DYNAMIC_SHM)\n\t\tpr_info(\"dynamic shared memory is enabled\\n\");\n\n\trc = optee_enumerate_devices(PTA_CMD_GET_DEVICES);\n\tif (rc)\n\t\tgoto err_disable_shm_cache;\n\n\tpr_info(\"initialized driver\\n\");\n\treturn 0;\n\nerr_disable_shm_cache:\n\tif (!optee->rpc_param_count)\n\t\toptee_disable_shm_cache(optee);\n\toptee_smc_notif_uninit_irq(optee);\n\toptee_unregister_devices();\nerr_notif_uninit:\n\toptee_notif_uninit(optee);\nerr_close_ctx:\n\tteedev_close_context(ctx);\nerr_supp_uninit:\n\toptee_shm_arg_cache_uninit(optee);\n\toptee_supp_uninit(&optee->supp);\n\tmutex_destroy(&optee->call_queue.mutex);\nerr_unreg_supp_teedev:\n\ttee_device_unregister(optee->supp_teedev);\nerr_unreg_teedev:\n\ttee_device_unregister(optee->teedev);\nerr_free_optee:\n\tkfree(optee);\nerr_free_pool:\n\ttee_shm_pool_free(pool);\n\tif (memremaped_shm)\n\t\tmemunmap(memremaped_shm);\n\treturn rc;\n}\n\nstatic const struct of_device_id optee_dt_match[] = {\n\t{ .compatible = \"linaro,optee-tz\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, optee_dt_match);\n\nstatic struct platform_driver optee_driver = {\n\t.probe  = optee_probe,\n\t.remove = optee_smc_remove,\n\t.shutdown = optee_shutdown,\n\t.driver = {\n\t\t.name = \"optee\",\n\t\t.of_match_table = optee_dt_match,\n\t},\n};\n\nint optee_smc_abi_register(void)\n{\n\treturn platform_driver_register(&optee_driver);\n}\n\nvoid optee_smc_abi_unregister(void)\n{\n\tplatform_driver_unregister(&optee_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}