{
  "module_name": "call.c",
  "hash_id": "0b02c9a9a3d01c4354a4bd792be6b7fc597d3670527da57ea751032b1d78c284",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tee/optee/call.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/tee_drv.h>\n#include <linux/types.h>\n#include \"optee_private.h\"\n\n#define MAX_ARG_PARAM_COUNT\t6\n\n \n#define SHM_ENTRY_SIZE\t\tPAGE_SIZE\n\n \n#define MIN_ARG_SIZE\t\tOPTEE_MSG_GET_ARG_SIZE(MAX_ARG_PARAM_COUNT)\n#define MAX_ARG_COUNT_PER_ENTRY\t(SHM_ENTRY_SIZE / MIN_ARG_SIZE)\n\n \nstruct optee_shm_arg_entry {\n\tstruct list_head list_node;\n\tstruct tee_shm *shm;\n\tDECLARE_BITMAP(map, MAX_ARG_COUNT_PER_ENTRY);\n};\n\nvoid optee_cq_wait_init(struct optee_call_queue *cq,\n\t\t\tstruct optee_call_waiter *w)\n{\n\t \n\tmutex_lock(&cq->mutex);\n\n\t \n\tinit_completion(&w->c);\n\tlist_add_tail(&w->list_node, &cq->waiters);\n\n\tmutex_unlock(&cq->mutex);\n}\n\nvoid optee_cq_wait_for_completion(struct optee_call_queue *cq,\n\t\t\t\t  struct optee_call_waiter *w)\n{\n\twait_for_completion(&w->c);\n\n\tmutex_lock(&cq->mutex);\n\n\t \n\tlist_del(&w->list_node);\n\treinit_completion(&w->c);\n\tlist_add_tail(&w->list_node, &cq->waiters);\n\n\tmutex_unlock(&cq->mutex);\n}\n\nstatic void optee_cq_complete_one(struct optee_call_queue *cq)\n{\n\tstruct optee_call_waiter *w;\n\n\tlist_for_each_entry(w, &cq->waiters, list_node) {\n\t\tif (!completion_done(&w->c)) {\n\t\t\tcomplete(&w->c);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid optee_cq_wait_final(struct optee_call_queue *cq,\n\t\t\t struct optee_call_waiter *w)\n{\n\t \n\tmutex_lock(&cq->mutex);\n\n\t \n\tlist_del(&w->list_node);\n\n\t \n\toptee_cq_complete_one(cq);\n\n\t \n\tif (completion_done(&w->c))\n\t\toptee_cq_complete_one(cq);\n\n\tmutex_unlock(&cq->mutex);\n}\n\n \nstatic struct optee_session *find_session(struct optee_context_data *ctxdata,\n\t\t\t\t\t  u32 session_id)\n{\n\tstruct optee_session *sess;\n\n\tlist_for_each_entry(sess, &ctxdata->sess_list, list_node)\n\t\tif (sess->session_id == session_id)\n\t\t\treturn sess;\n\n\treturn NULL;\n}\n\nvoid optee_shm_arg_cache_init(struct optee *optee, u32 flags)\n{\n\tINIT_LIST_HEAD(&optee->shm_arg_cache.shm_args);\n\tmutex_init(&optee->shm_arg_cache.mutex);\n\toptee->shm_arg_cache.flags = flags;\n}\n\nvoid optee_shm_arg_cache_uninit(struct optee *optee)\n{\n\tstruct list_head *head = &optee->shm_arg_cache.shm_args;\n\tstruct optee_shm_arg_entry *entry;\n\n\tmutex_destroy(&optee->shm_arg_cache.mutex);\n\twhile (!list_empty(head)) {\n\t\tentry = list_first_entry(head, struct optee_shm_arg_entry,\n\t\t\t\t\t list_node);\n\t\tlist_del(&entry->list_node);\n\t\tif (find_first_bit(entry->map, MAX_ARG_COUNT_PER_ENTRY) !=\n\t\t     MAX_ARG_COUNT_PER_ENTRY) {\n\t\t\tpr_err(\"Freeing non-free entry\\n\");\n\t\t}\n\t\ttee_shm_free(entry->shm);\n\t\tkfree(entry);\n\t}\n}\n\nsize_t optee_msg_arg_size(size_t rpc_param_count)\n{\n\tsize_t sz = OPTEE_MSG_GET_ARG_SIZE(MAX_ARG_PARAM_COUNT);\n\n\tif (rpc_param_count)\n\t\tsz += OPTEE_MSG_GET_ARG_SIZE(rpc_param_count);\n\n\treturn sz;\n}\n\n \nstruct optee_msg_arg *optee_get_msg_arg(struct tee_context *ctx,\n\t\t\t\t\tsize_t num_params,\n\t\t\t\t\tstruct optee_shm_arg_entry **entry_ret,\n\t\t\t\t\tstruct tee_shm **shm_ret,\n\t\t\t\t\tu_int *offs_ret)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tsize_t sz = optee_msg_arg_size(optee->rpc_param_count);\n\tstruct optee_shm_arg_entry *entry;\n\tstruct optee_msg_arg *ma;\n\tsize_t args_per_entry;\n\tu_long bit;\n\tu_int offs;\n\tvoid *res;\n\n\tif (num_params > MAX_ARG_PARAM_COUNT)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (optee->shm_arg_cache.flags & OPTEE_SHM_ARG_SHARED)\n\t\targs_per_entry = SHM_ENTRY_SIZE / sz;\n\telse\n\t\targs_per_entry = 1;\n\n\tmutex_lock(&optee->shm_arg_cache.mutex);\n\tlist_for_each_entry(entry, &optee->shm_arg_cache.shm_args, list_node) {\n\t\tbit = find_first_zero_bit(entry->map, MAX_ARG_COUNT_PER_ENTRY);\n\t\tif (bit < args_per_entry)\n\t\t\tgoto have_entry;\n\t}\n\n\t \n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\tres = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tif (optee->shm_arg_cache.flags & OPTEE_SHM_ARG_ALLOC_PRIV)\n\t\tres = tee_shm_alloc_priv_buf(ctx, SHM_ENTRY_SIZE);\n\telse\n\t\tres = tee_shm_alloc_kernel_buf(ctx, SHM_ENTRY_SIZE);\n\n\tif (IS_ERR(res)) {\n\t\tkfree(entry);\n\t\tgoto out;\n\t}\n\tentry->shm = res;\n\tlist_add(&entry->list_node, &optee->shm_arg_cache.shm_args);\n\tbit = 0;\n\nhave_entry:\n\toffs = bit * sz;\n\tres = tee_shm_get_va(entry->shm, offs);\n\tif (IS_ERR(res))\n\t\tgoto out;\n\tma = res;\n\tset_bit(bit, entry->map);\n\tmemset(ma, 0, sz);\n\tma->num_params = num_params;\n\t*entry_ret = entry;\n\t*shm_ret = entry->shm;\n\t*offs_ret = offs;\nout:\n\tmutex_unlock(&optee->shm_arg_cache.mutex);\n\treturn res;\n}\n\n \nvoid optee_free_msg_arg(struct tee_context *ctx,\n\t\t\tstruct optee_shm_arg_entry *entry, u_int offs)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tsize_t sz = optee_msg_arg_size(optee->rpc_param_count);\n\tu_long bit;\n\n\tif (offs > SHM_ENTRY_SIZE || offs % sz) {\n\t\tpr_err(\"Invalid offs %u\\n\", offs);\n\t\treturn;\n\t}\n\tbit = offs / sz;\n\n\tmutex_lock(&optee->shm_arg_cache.mutex);\n\n\tif (!test_bit(bit, entry->map))\n\t\tpr_err(\"Bit pos %lu is already free\\n\", bit);\n\tclear_bit(bit, entry->map);\n\n\tmutex_unlock(&optee->shm_arg_cache.mutex);\n}\n\nint optee_open_session(struct tee_context *ctx,\n\t\t       struct tee_ioctl_open_session_arg *arg,\n\t\t       struct tee_param *param)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tstruct optee_context_data *ctxdata = ctx->data;\n\tstruct optee_shm_arg_entry *entry;\n\tstruct tee_shm *shm;\n\tstruct optee_msg_arg *msg_arg;\n\tstruct optee_session *sess = NULL;\n\tuuid_t client_uuid;\n\tu_int offs;\n\tint rc;\n\n\t \n\tmsg_arg = optee_get_msg_arg(ctx, arg->num_params + 2,\n\t\t\t\t    &entry, &shm, &offs);\n\tif (IS_ERR(msg_arg))\n\t\treturn PTR_ERR(msg_arg);\n\n\tmsg_arg->cmd = OPTEE_MSG_CMD_OPEN_SESSION;\n\tmsg_arg->cancel_id = arg->cancel_id;\n\n\t \n\tmsg_arg->params[0].attr = OPTEE_MSG_ATTR_TYPE_VALUE_INPUT |\n\t\t\t\t  OPTEE_MSG_ATTR_META;\n\tmsg_arg->params[1].attr = OPTEE_MSG_ATTR_TYPE_VALUE_INPUT |\n\t\t\t\t  OPTEE_MSG_ATTR_META;\n\tmemcpy(&msg_arg->params[0].u.value, arg->uuid, sizeof(arg->uuid));\n\tmsg_arg->params[1].u.value.c = arg->clnt_login;\n\n\trc = tee_session_calc_client_uuid(&client_uuid, arg->clnt_login,\n\t\t\t\t\t  arg->clnt_uuid);\n\tif (rc)\n\t\tgoto out;\n\texport_uuid(msg_arg->params[1].u.octets, &client_uuid);\n\n\trc = optee->ops->to_msg_param(optee, msg_arg->params + 2,\n\t\t\t\t      arg->num_params, param);\n\tif (rc)\n\t\tgoto out;\n\n\tsess = kzalloc(sizeof(*sess), GFP_KERNEL);\n\tif (!sess) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (optee->ops->do_call_with_arg(ctx, shm, offs)) {\n\t\tmsg_arg->ret = TEEC_ERROR_COMMUNICATION;\n\t\tmsg_arg->ret_origin = TEEC_ORIGIN_COMMS;\n\t}\n\n\tif (msg_arg->ret == TEEC_SUCCESS) {\n\t\t \n\t\tsess->session_id = msg_arg->session;\n\t\tmutex_lock(&ctxdata->mutex);\n\t\tlist_add(&sess->list_node, &ctxdata->sess_list);\n\t\tmutex_unlock(&ctxdata->mutex);\n\t} else {\n\t\tkfree(sess);\n\t}\n\n\tif (optee->ops->from_msg_param(optee, param, arg->num_params,\n\t\t\t\t       msg_arg->params + 2)) {\n\t\targ->ret = TEEC_ERROR_COMMUNICATION;\n\t\targ->ret_origin = TEEC_ORIGIN_COMMS;\n\t\t \n\t\toptee_close_session(ctx, msg_arg->session);\n\t} else {\n\t\targ->session = msg_arg->session;\n\t\targ->ret = msg_arg->ret;\n\t\targ->ret_origin = msg_arg->ret_origin;\n\t}\nout:\n\toptee_free_msg_arg(ctx, entry, offs);\n\n\treturn rc;\n}\n\nint optee_close_session_helper(struct tee_context *ctx, u32 session)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tstruct optee_shm_arg_entry *entry;\n\tstruct optee_msg_arg *msg_arg;\n\tstruct tee_shm *shm;\n\tu_int offs;\n\n\tmsg_arg = optee_get_msg_arg(ctx, 0, &entry, &shm, &offs);\n\tif (IS_ERR(msg_arg))\n\t\treturn PTR_ERR(msg_arg);\n\n\tmsg_arg->cmd = OPTEE_MSG_CMD_CLOSE_SESSION;\n\tmsg_arg->session = session;\n\toptee->ops->do_call_with_arg(ctx, shm, offs);\n\n\toptee_free_msg_arg(ctx, entry, offs);\n\n\treturn 0;\n}\n\nint optee_close_session(struct tee_context *ctx, u32 session)\n{\n\tstruct optee_context_data *ctxdata = ctx->data;\n\tstruct optee_session *sess;\n\n\t \n\tmutex_lock(&ctxdata->mutex);\n\tsess = find_session(ctxdata, session);\n\tif (sess)\n\t\tlist_del(&sess->list_node);\n\tmutex_unlock(&ctxdata->mutex);\n\tif (!sess)\n\t\treturn -EINVAL;\n\tkfree(sess);\n\n\treturn optee_close_session_helper(ctx, session);\n}\n\nint optee_invoke_func(struct tee_context *ctx, struct tee_ioctl_invoke_arg *arg,\n\t\t      struct tee_param *param)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tstruct optee_context_data *ctxdata = ctx->data;\n\tstruct optee_shm_arg_entry *entry;\n\tstruct optee_msg_arg *msg_arg;\n\tstruct optee_session *sess;\n\tstruct tee_shm *shm;\n\tu_int offs;\n\tint rc;\n\n\t \n\tmutex_lock(&ctxdata->mutex);\n\tsess = find_session(ctxdata, arg->session);\n\tmutex_unlock(&ctxdata->mutex);\n\tif (!sess)\n\t\treturn -EINVAL;\n\n\tmsg_arg = optee_get_msg_arg(ctx, arg->num_params,\n\t\t\t\t    &entry, &shm, &offs);\n\tif (IS_ERR(msg_arg))\n\t\treturn PTR_ERR(msg_arg);\n\tmsg_arg->cmd = OPTEE_MSG_CMD_INVOKE_COMMAND;\n\tmsg_arg->func = arg->func;\n\tmsg_arg->session = arg->session;\n\tmsg_arg->cancel_id = arg->cancel_id;\n\n\trc = optee->ops->to_msg_param(optee, msg_arg->params, arg->num_params,\n\t\t\t\t      param);\n\tif (rc)\n\t\tgoto out;\n\n\tif (optee->ops->do_call_with_arg(ctx, shm, offs)) {\n\t\tmsg_arg->ret = TEEC_ERROR_COMMUNICATION;\n\t\tmsg_arg->ret_origin = TEEC_ORIGIN_COMMS;\n\t}\n\n\tif (optee->ops->from_msg_param(optee, param, arg->num_params,\n\t\t\t\t       msg_arg->params)) {\n\t\tmsg_arg->ret = TEEC_ERROR_COMMUNICATION;\n\t\tmsg_arg->ret_origin = TEEC_ORIGIN_COMMS;\n\t}\n\n\targ->ret = msg_arg->ret;\n\targ->ret_origin = msg_arg->ret_origin;\nout:\n\toptee_free_msg_arg(ctx, entry, offs);\n\treturn rc;\n}\n\nint optee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session)\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tstruct optee_context_data *ctxdata = ctx->data;\n\tstruct optee_shm_arg_entry *entry;\n\tstruct optee_msg_arg *msg_arg;\n\tstruct optee_session *sess;\n\tstruct tee_shm *shm;\n\tu_int offs;\n\n\t \n\tmutex_lock(&ctxdata->mutex);\n\tsess = find_session(ctxdata, session);\n\tmutex_unlock(&ctxdata->mutex);\n\tif (!sess)\n\t\treturn -EINVAL;\n\n\tmsg_arg = optee_get_msg_arg(ctx, 0, &entry, &shm, &offs);\n\tif (IS_ERR(msg_arg))\n\t\treturn PTR_ERR(msg_arg);\n\n\tmsg_arg->cmd = OPTEE_MSG_CMD_CANCEL;\n\tmsg_arg->session = session;\n\tmsg_arg->cancel_id = cancel_id;\n\toptee->ops->do_call_with_arg(ctx, shm, offs);\n\n\toptee_free_msg_arg(ctx, entry, offs);\n\treturn 0;\n}\n\nstatic bool is_normal_memory(pgprot_t p)\n{\n#if defined(CONFIG_ARM)\n\treturn (((pgprot_val(p) & L_PTE_MT_MASK) == L_PTE_MT_WRITEALLOC) ||\n\t\t((pgprot_val(p) & L_PTE_MT_MASK) == L_PTE_MT_WRITEBACK));\n#elif defined(CONFIG_ARM64)\n\treturn (pgprot_val(p) & PTE_ATTRINDX_MASK) == PTE_ATTRINDX(MT_NORMAL);\n#else\n#error \"Unsupported architecture\"\n#endif\n}\n\nstatic int __check_mem_type(struct mm_struct *mm, unsigned long start,\n\t\t\t\tunsigned long end)\n{\n\tstruct vm_area_struct *vma;\n\tVMA_ITERATOR(vmi, mm, start);\n\n\tfor_each_vma_range(vmi, vma, end) {\n\t\tif (!is_normal_memory(vma->vm_page_prot))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint optee_check_mem_type(unsigned long start, size_t num_pages)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint rc;\n\n\t \n\tif (virt_addr_valid((void *)start) || is_vmalloc_addr((void *)start))\n\t\treturn 0;\n\n\tmmap_read_lock(mm);\n\trc = __check_mem_type(mm, start, start + num_pages * PAGE_SIZE);\n\tmmap_read_unlock(mm);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}