{
  "module_name": "notif.c",
  "hash_id": "09f3d85cf19c1833762fdecde3e6d0c0116a8b9b003dd744d540e1588385814f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tee/optee/notif.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/arm-smccc.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/tee_drv.h>\n#include \"optee_private.h\"\n\nstruct notif_entry {\n\tstruct list_head link;\n\tstruct completion c;\n\tu_int key;\n};\n\nstatic bool have_key(struct optee *optee, u_int key)\n{\n\tstruct notif_entry *entry;\n\n\tlist_for_each_entry(entry, &optee->notif.db, link)\n\t\tif (entry->key == key)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nint optee_notif_wait(struct optee *optee, u_int key)\n{\n\tunsigned long flags;\n\tstruct notif_entry *entry;\n\tint rc = 0;\n\n\tif (key > optee->notif.max_key)\n\t\treturn -EINVAL;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tinit_completion(&entry->c);\n\tentry->key = key;\n\n\tspin_lock_irqsave(&optee->notif.lock, flags);\n\n\t \n\tif (test_bit(key, optee->notif.bitmap)) {\n\t\tclear_bit(key, optee->notif.bitmap);\n\t\tgoto out;\n\t}\n\n\t \n\tif (have_key(optee, key)) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&entry->link, &optee->notif.db);\n\n\t \n\tspin_unlock_irqrestore(&optee->notif.lock, flags);\n\twait_for_completion(&entry->c);\n\tspin_lock_irqsave(&optee->notif.lock, flags);\n\n\tlist_del(&entry->link);\nout:\n\tspin_unlock_irqrestore(&optee->notif.lock, flags);\n\n\tkfree(entry);\n\n\treturn rc;\n}\n\nint optee_notif_send(struct optee *optee, u_int key)\n{\n\tunsigned long flags;\n\tstruct notif_entry *entry;\n\n\tif (key > optee->notif.max_key)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&optee->notif.lock, flags);\n\n\tlist_for_each_entry(entry, &optee->notif.db, link)\n\t\tif (entry->key == key) {\n\t\t\tcomplete(&entry->c);\n\t\t\tgoto out;\n\t\t}\n\n\t \n\tset_bit(key, optee->notif.bitmap);\nout:\n\tspin_unlock_irqrestore(&optee->notif.lock, flags);\n\n\treturn 0;\n}\n\nint optee_notif_init(struct optee *optee, u_int max_key)\n{\n\tspin_lock_init(&optee->notif.lock);\n\tINIT_LIST_HEAD(&optee->notif.db);\n\toptee->notif.bitmap = bitmap_zalloc(max_key, GFP_KERNEL);\n\tif (!optee->notif.bitmap)\n\t\treturn -ENOMEM;\n\n\toptee->notif.max_key = max_key;\n\n\treturn 0;\n}\n\nvoid optee_notif_uninit(struct optee *optee)\n{\n\tbitmap_free(optee->notif.bitmap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}