{
  "module_name": "supp.c",
  "hash_id": "2d7bb98c73032034821d73a79a560ed7a6be30f2d59f3787a54a0f95e03fc564",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tee/optee/supp.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include \"optee_private.h\"\n\nstruct optee_supp_req {\n\tstruct list_head link;\n\n\tbool in_queue;\n\tu32 func;\n\tu32 ret;\n\tsize_t num_params;\n\tstruct tee_param *param;\n\n\tstruct completion c;\n};\n\nvoid optee_supp_init(struct optee_supp *supp)\n{\n\tmemset(supp, 0, sizeof(*supp));\n\tmutex_init(&supp->mutex);\n\tinit_completion(&supp->reqs_c);\n\tidr_init(&supp->idr);\n\tINIT_LIST_HEAD(&supp->reqs);\n\tsupp->req_id = -1;\n}\n\nvoid optee_supp_uninit(struct optee_supp *supp)\n{\n\tmutex_destroy(&supp->mutex);\n\tidr_destroy(&supp->idr);\n}\n\nvoid optee_supp_release(struct optee_supp *supp)\n{\n\tint id;\n\tstruct optee_supp_req *req;\n\tstruct optee_supp_req *req_tmp;\n\n\tmutex_lock(&supp->mutex);\n\n\t \n\tidr_for_each_entry(&supp->idr, req, id) {\n\t\tidr_remove(&supp->idr, id);\n\t\treq->ret = TEEC_ERROR_COMMUNICATION;\n\t\tcomplete(&req->c);\n\t}\n\n\t \n\tlist_for_each_entry_safe(req, req_tmp, &supp->reqs, link) {\n\t\tlist_del(&req->link);\n\t\treq->in_queue = false;\n\t\treq->ret = TEEC_ERROR_COMMUNICATION;\n\t\tcomplete(&req->c);\n\t}\n\n\tsupp->ctx = NULL;\n\tsupp->req_id = -1;\n\n\tmutex_unlock(&supp->mutex);\n}\n\n \nu32 optee_supp_thrd_req(struct tee_context *ctx, u32 func, size_t num_params,\n\t\t\tstruct tee_param *param)\n\n{\n\tstruct optee *optee = tee_get_drvdata(ctx->teedev);\n\tstruct optee_supp *supp = &optee->supp;\n\tstruct optee_supp_req *req;\n\tbool interruptable;\n\tu32 ret;\n\n\t \n\tif (!supp->ctx && ctx->supp_nowait)\n\t\treturn TEEC_ERROR_COMMUNICATION;\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn TEEC_ERROR_OUT_OF_MEMORY;\n\n\tinit_completion(&req->c);\n\treq->func = func;\n\treq->num_params = num_params;\n\treq->param = param;\n\n\t \n\tmutex_lock(&supp->mutex);\n\tlist_add_tail(&req->link, &supp->reqs);\n\treq->in_queue = true;\n\tmutex_unlock(&supp->mutex);\n\n\t \n\tcomplete(&supp->reqs_c);\n\n\t \n\twhile (wait_for_completion_interruptible(&req->c)) {\n\t\tmutex_lock(&supp->mutex);\n\t\tinterruptable = !supp->ctx;\n\t\tif (interruptable) {\n\t\t\t \n\t\t\tif (req->in_queue) {\n\t\t\t\tlist_del(&req->link);\n\t\t\t\treq->in_queue = false;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&supp->mutex);\n\n\t\tif (interruptable) {\n\t\t\treq->ret = TEEC_ERROR_COMMUNICATION;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = req->ret;\n\tkfree(req);\n\n\treturn ret;\n}\n\nstatic struct optee_supp_req  *supp_pop_entry(struct optee_supp *supp,\n\t\t\t\t\t      int num_params, int *id)\n{\n\tstruct optee_supp_req *req;\n\n\tif (supp->req_id != -1) {\n\t\t \n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (list_empty(&supp->reqs))\n\t\treturn NULL;\n\n\treq = list_first_entry(&supp->reqs, struct optee_supp_req, link);\n\n\tif (num_params < req->num_params) {\n\t\t \n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t*id = idr_alloc(&supp->idr, req, 1, 0, GFP_KERNEL);\n\tif (*id < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlist_del(&req->link);\n\treq->in_queue = false;\n\n\treturn req;\n}\n\nstatic int supp_check_recv_params(size_t num_params, struct tee_param *params,\n\t\t\t\t  size_t *num_meta)\n{\n\tsize_t n;\n\n\tif (!num_params)\n\t\treturn -EINVAL;\n\n\t \n\tfor (n = 0; n < num_params; n++)\n\t\tif (tee_param_is_memref(params + n) && params[n].u.memref.shm)\n\t\t\ttee_shm_put(params[n].u.memref.shm);\n\n\t \n\tfor (n = 0; n < num_params; n++)\n\t\tif (params[n].attr &&\n\t\t    params[n].attr != TEE_IOCTL_PARAM_ATTR_META)\n\t\t\treturn -EINVAL;\n\n\t \n\tif (params->attr == TEE_IOCTL_PARAM_ATTR_META)\n\t\t*num_meta = 1;\n\telse\n\t\t*num_meta = 0;\n\n\treturn 0;\n}\n\n \nint optee_supp_recv(struct tee_context *ctx, u32 *func, u32 *num_params,\n\t\t    struct tee_param *param)\n{\n\tstruct tee_device *teedev = ctx->teedev;\n\tstruct optee *optee = tee_get_drvdata(teedev);\n\tstruct optee_supp *supp = &optee->supp;\n\tstruct optee_supp_req *req = NULL;\n\tint id;\n\tsize_t num_meta;\n\tint rc;\n\n\trc = supp_check_recv_params(*num_params, param, &num_meta);\n\tif (rc)\n\t\treturn rc;\n\n\twhile (true) {\n\t\tmutex_lock(&supp->mutex);\n\t\treq = supp_pop_entry(supp, *num_params - num_meta, &id);\n\t\tmutex_unlock(&supp->mutex);\n\n\t\tif (req) {\n\t\t\tif (IS_ERR(req))\n\t\t\t\treturn PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (wait_for_completion_interruptible(&supp->reqs_c))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\tif (num_meta) {\n\t\t \n\t\tparam->attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT |\n\t\t\t      TEE_IOCTL_PARAM_ATTR_META;\n\t\tparam->u.value.a = id;\n\t\tparam->u.value.b = 0;\n\t\tparam->u.value.c = 0;\n\t} else {\n\t\tmutex_lock(&supp->mutex);\n\t\tsupp->req_id = id;\n\t\tmutex_unlock(&supp->mutex);\n\t}\n\n\t*func = req->func;\n\t*num_params = req->num_params + num_meta;\n\tmemcpy(param + num_meta, req->param,\n\t       sizeof(struct tee_param) * req->num_params);\n\n\treturn 0;\n}\n\nstatic struct optee_supp_req *supp_pop_req(struct optee_supp *supp,\n\t\t\t\t\t   size_t num_params,\n\t\t\t\t\t   struct tee_param *param,\n\t\t\t\t\t   size_t *num_meta)\n{\n\tstruct optee_supp_req *req;\n\tint id;\n\tsize_t nm;\n\tconst u32 attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT |\n\t\t\t TEE_IOCTL_PARAM_ATTR_META;\n\n\tif (!num_params)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (supp->req_id == -1) {\n\t\tif (param->attr != attr)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tid = param->u.value.a;\n\t\tnm = 1;\n\t} else {\n\t\tid = supp->req_id;\n\t\tnm = 0;\n\t}\n\n\treq = idr_find(&supp->idr, id);\n\tif (!req)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif ((num_params - nm) != req->num_params)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tidr_remove(&supp->idr, id);\n\tsupp->req_id = -1;\n\t*num_meta = nm;\n\n\treturn req;\n}\n\n \nint optee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,\n\t\t    struct tee_param *param)\n{\n\tstruct tee_device *teedev = ctx->teedev;\n\tstruct optee *optee = tee_get_drvdata(teedev);\n\tstruct optee_supp *supp = &optee->supp;\n\tstruct optee_supp_req *req;\n\tsize_t n;\n\tsize_t num_meta;\n\n\tmutex_lock(&supp->mutex);\n\treq = supp_pop_req(supp, num_params, param, &num_meta);\n\tmutex_unlock(&supp->mutex);\n\n\tif (IS_ERR(req)) {\n\t\t \n\t\treturn PTR_ERR(req);\n\t}\n\n\t \n\tfor (n = 0; n < req->num_params; n++) {\n\t\tstruct tee_param *p = req->param + n;\n\n\t\tswitch (p->attr & TEE_IOCTL_PARAM_ATTR_TYPE_MASK) {\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:\n\t\t\tp->u.value.a = param[n + num_meta].u.value.a;\n\t\t\tp->u.value.b = param[n + num_meta].u.value.b;\n\t\t\tp->u.value.c = param[n + num_meta].u.value.c;\n\t\t\tbreak;\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:\n\t\t\tp->u.memref.size = param[n + num_meta].u.memref.size;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treq->ret = ret;\n\n\t \n\tcomplete(&req->c);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}