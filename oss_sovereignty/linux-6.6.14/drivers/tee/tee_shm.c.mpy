{
  "module_name": "tee_shm.c",
  "hash_id": "0c9ce594521ecf713067911d734ea421406902ecd2598594f4bd8b79588ba35f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tee/tee_shm.c",
  "human_readable_source": "\n \n#include <linux/anon_inodes.h>\n#include <linux/device.h>\n#include <linux/idr.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/tee_drv.h>\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/highmem.h>\n#include \"tee_private.h\"\n\nstatic void shm_put_kernel_pages(struct page **pages, size_t page_count)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < page_count; n++)\n\t\tput_page(pages[n]);\n}\n\nstatic int shm_get_kernel_pages(unsigned long start, size_t page_count,\n\t\t\t\tstruct page **pages)\n{\n\tstruct page *page;\n\tsize_t n;\n\n\tif (WARN_ON_ONCE(is_vmalloc_addr((void *)start) ||\n\t\t\t is_kmap_addr((void *)start)))\n\t\treturn -EINVAL;\n\n\tpage = virt_to_page((void *)start);\n\tfor (n = 0; n < page_count; n++) {\n\t\tpages[n] = page + n;\n\t\tget_page(pages[n]);\n\t}\n\n\treturn page_count;\n}\n\nstatic void release_registered_pages(struct tee_shm *shm)\n{\n\tif (shm->pages) {\n\t\tif (shm->flags & TEE_SHM_USER_MAPPED)\n\t\t\tunpin_user_pages(shm->pages, shm->num_pages);\n\t\telse\n\t\t\tshm_put_kernel_pages(shm->pages, shm->num_pages);\n\n\t\tkfree(shm->pages);\n\t}\n}\n\nstatic void tee_shm_release(struct tee_device *teedev, struct tee_shm *shm)\n{\n\tif (shm->flags & TEE_SHM_POOL) {\n\t\tteedev->pool->ops->free(teedev->pool, shm);\n\t} else if (shm->flags & TEE_SHM_DYNAMIC) {\n\t\tint rc = teedev->desc->ops->shm_unregister(shm->ctx, shm);\n\n\t\tif (rc)\n\t\t\tdev_err(teedev->dev.parent,\n\t\t\t\t\"unregister shm %p failed: %d\", shm, rc);\n\n\t\trelease_registered_pages(shm);\n\t}\n\n\tteedev_ctx_put(shm->ctx);\n\n\tkfree(shm);\n\n\ttee_device_put(teedev);\n}\n\nstatic struct tee_shm *shm_alloc_helper(struct tee_context *ctx, size_t size,\n\t\t\t\t\tsize_t align, u32 flags, int id)\n{\n\tstruct tee_device *teedev = ctx->teedev;\n\tstruct tee_shm *shm;\n\tvoid *ret;\n\tint rc;\n\n\tif (!tee_device_get(teedev))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!teedev->pool) {\n\t\t \n\t\tret = ERR_PTR(-EINVAL);\n\t\tgoto err_dev_put;\n\t}\n\n\tshm = kzalloc(sizeof(*shm), GFP_KERNEL);\n\tif (!shm) {\n\t\tret = ERR_PTR(-ENOMEM);\n\t\tgoto err_dev_put;\n\t}\n\n\trefcount_set(&shm->refcount, 1);\n\tshm->flags = flags;\n\tshm->id = id;\n\n\t \n\tshm->ctx = ctx;\n\n\trc = teedev->pool->ops->alloc(teedev->pool, shm, size, align);\n\tif (rc) {\n\t\tret = ERR_PTR(rc);\n\t\tgoto err_kfree;\n\t}\n\n\tteedev_ctx_get(ctx);\n\treturn shm;\nerr_kfree:\n\tkfree(shm);\nerr_dev_put:\n\ttee_device_put(teedev);\n\treturn ret;\n}\n\n \nstruct tee_shm *tee_shm_alloc_user_buf(struct tee_context *ctx, size_t size)\n{\n\tu32 flags = TEE_SHM_DYNAMIC | TEE_SHM_POOL;\n\tstruct tee_device *teedev = ctx->teedev;\n\tstruct tee_shm *shm;\n\tvoid *ret;\n\tint id;\n\n\tmutex_lock(&teedev->mutex);\n\tid = idr_alloc(&teedev->idr, NULL, 1, 0, GFP_KERNEL);\n\tmutex_unlock(&teedev->mutex);\n\tif (id < 0)\n\t\treturn ERR_PTR(id);\n\n\tshm = shm_alloc_helper(ctx, size, PAGE_SIZE, flags, id);\n\tif (IS_ERR(shm)) {\n\t\tmutex_lock(&teedev->mutex);\n\t\tidr_remove(&teedev->idr, id);\n\t\tmutex_unlock(&teedev->mutex);\n\t\treturn shm;\n\t}\n\n\tmutex_lock(&teedev->mutex);\n\tret = idr_replace(&teedev->idr, shm, id);\n\tmutex_unlock(&teedev->mutex);\n\tif (IS_ERR(ret)) {\n\t\ttee_shm_free(shm);\n\t\treturn ret;\n\t}\n\n\treturn shm;\n}\n\n \nstruct tee_shm *tee_shm_alloc_kernel_buf(struct tee_context *ctx, size_t size)\n{\n\tu32 flags = TEE_SHM_DYNAMIC | TEE_SHM_POOL;\n\n\treturn shm_alloc_helper(ctx, size, PAGE_SIZE, flags, -1);\n}\nEXPORT_SYMBOL_GPL(tee_shm_alloc_kernel_buf);\n\n \nstruct tee_shm *tee_shm_alloc_priv_buf(struct tee_context *ctx, size_t size)\n{\n\tu32 flags = TEE_SHM_PRIV | TEE_SHM_POOL;\n\n\treturn shm_alloc_helper(ctx, size, sizeof(long) * 2, flags, -1);\n}\nEXPORT_SYMBOL_GPL(tee_shm_alloc_priv_buf);\n\nstatic struct tee_shm *\nregister_shm_helper(struct tee_context *ctx, unsigned long addr,\n\t\t    size_t length, u32 flags, int id)\n{\n\tstruct tee_device *teedev = ctx->teedev;\n\tstruct tee_shm *shm;\n\tunsigned long start;\n\tsize_t num_pages;\n\tvoid *ret;\n\tint rc;\n\n\tif (!tee_device_get(teedev))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!teedev->desc->ops->shm_register ||\n\t    !teedev->desc->ops->shm_unregister) {\n\t\tret = ERR_PTR(-ENOTSUPP);\n\t\tgoto err_dev_put;\n\t}\n\n\tteedev_ctx_get(ctx);\n\n\tshm = kzalloc(sizeof(*shm), GFP_KERNEL);\n\tif (!shm) {\n\t\tret = ERR_PTR(-ENOMEM);\n\t\tgoto err_ctx_put;\n\t}\n\n\trefcount_set(&shm->refcount, 1);\n\tshm->flags = flags;\n\tshm->ctx = ctx;\n\tshm->id = id;\n\taddr = untagged_addr(addr);\n\tstart = rounddown(addr, PAGE_SIZE);\n\tshm->offset = addr - start;\n\tshm->size = length;\n\tnum_pages = (roundup(addr + length, PAGE_SIZE) - start) / PAGE_SIZE;\n\tshm->pages = kcalloc(num_pages, sizeof(*shm->pages), GFP_KERNEL);\n\tif (!shm->pages) {\n\t\tret = ERR_PTR(-ENOMEM);\n\t\tgoto err_free_shm;\n\t}\n\n\tif (flags & TEE_SHM_USER_MAPPED)\n\t\trc = pin_user_pages_fast(start, num_pages, FOLL_WRITE,\n\t\t\t\t\t shm->pages);\n\telse\n\t\trc = shm_get_kernel_pages(start, num_pages, shm->pages);\n\tif (rc > 0)\n\t\tshm->num_pages = rc;\n\tif (rc != num_pages) {\n\t\tif (rc >= 0)\n\t\t\trc = -ENOMEM;\n\t\tret = ERR_PTR(rc);\n\t\tgoto err_put_shm_pages;\n\t}\n\n\trc = teedev->desc->ops->shm_register(ctx, shm, shm->pages,\n\t\t\t\t\t     shm->num_pages, start);\n\tif (rc) {\n\t\tret = ERR_PTR(rc);\n\t\tgoto err_put_shm_pages;\n\t}\n\n\treturn shm;\nerr_put_shm_pages:\n\tif (flags & TEE_SHM_USER_MAPPED)\n\t\tunpin_user_pages(shm->pages, shm->num_pages);\n\telse\n\t\tshm_put_kernel_pages(shm->pages, shm->num_pages);\n\tkfree(shm->pages);\nerr_free_shm:\n\tkfree(shm);\nerr_ctx_put:\n\tteedev_ctx_put(ctx);\nerr_dev_put:\n\ttee_device_put(teedev);\n\treturn ret;\n}\n\n \nstruct tee_shm *tee_shm_register_user_buf(struct tee_context *ctx,\n\t\t\t\t\t  unsigned long addr, size_t length)\n{\n\tu32 flags = TEE_SHM_USER_MAPPED | TEE_SHM_DYNAMIC;\n\tstruct tee_device *teedev = ctx->teedev;\n\tstruct tee_shm *shm;\n\tvoid *ret;\n\tint id;\n\n\tif (!access_ok((void __user *)addr, length))\n\t\treturn ERR_PTR(-EFAULT);\n\n\tmutex_lock(&teedev->mutex);\n\tid = idr_alloc(&teedev->idr, NULL, 1, 0, GFP_KERNEL);\n\tmutex_unlock(&teedev->mutex);\n\tif (id < 0)\n\t\treturn ERR_PTR(id);\n\n\tshm = register_shm_helper(ctx, addr, length, flags, id);\n\tif (IS_ERR(shm)) {\n\t\tmutex_lock(&teedev->mutex);\n\t\tidr_remove(&teedev->idr, id);\n\t\tmutex_unlock(&teedev->mutex);\n\t\treturn shm;\n\t}\n\n\tmutex_lock(&teedev->mutex);\n\tret = idr_replace(&teedev->idr, shm, id);\n\tmutex_unlock(&teedev->mutex);\n\tif (IS_ERR(ret)) {\n\t\ttee_shm_free(shm);\n\t\treturn ret;\n\t}\n\n\treturn shm;\n}\n\n \n\nstruct tee_shm *tee_shm_register_kernel_buf(struct tee_context *ctx,\n\t\t\t\t\t    void *addr, size_t length)\n{\n\tu32 flags = TEE_SHM_DYNAMIC;\n\n\treturn register_shm_helper(ctx, (unsigned long)addr, length, flags, -1);\n}\nEXPORT_SYMBOL_GPL(tee_shm_register_kernel_buf);\n\nstatic int tee_shm_fop_release(struct inode *inode, struct file *filp)\n{\n\ttee_shm_put(filp->private_data);\n\treturn 0;\n}\n\nstatic int tee_shm_fop_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct tee_shm *shm = filp->private_data;\n\tsize_t size = vma->vm_end - vma->vm_start;\n\n\t \n\tif (shm->flags & TEE_SHM_USER_MAPPED)\n\t\treturn -EINVAL;\n\n\t \n\tif (vma->vm_pgoff + vma_pages(vma) > shm->size >> PAGE_SHIFT)\n\t\treturn -EINVAL;\n\n\treturn remap_pfn_range(vma, vma->vm_start, shm->paddr >> PAGE_SHIFT,\n\t\t\t       size, vma->vm_page_prot);\n}\n\nstatic const struct file_operations tee_shm_fops = {\n\t.owner = THIS_MODULE,\n\t.release = tee_shm_fop_release,\n\t.mmap = tee_shm_fop_mmap,\n};\n\n \nint tee_shm_get_fd(struct tee_shm *shm)\n{\n\tint fd;\n\n\tif (shm->id < 0)\n\t\treturn -EINVAL;\n\n\t \n\trefcount_inc(&shm->refcount);\n\tfd = anon_inode_getfd(\"tee_shm\", &tee_shm_fops, shm, O_RDWR);\n\tif (fd < 0)\n\t\ttee_shm_put(shm);\n\treturn fd;\n}\n\n \nvoid tee_shm_free(struct tee_shm *shm)\n{\n\ttee_shm_put(shm);\n}\nEXPORT_SYMBOL_GPL(tee_shm_free);\n\n \nvoid *tee_shm_get_va(struct tee_shm *shm, size_t offs)\n{\n\tif (!shm->kaddr)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (offs >= shm->size)\n\t\treturn ERR_PTR(-EINVAL);\n\treturn (char *)shm->kaddr + offs;\n}\nEXPORT_SYMBOL_GPL(tee_shm_get_va);\n\n \nint tee_shm_get_pa(struct tee_shm *shm, size_t offs, phys_addr_t *pa)\n{\n\tif (offs >= shm->size)\n\t\treturn -EINVAL;\n\tif (pa)\n\t\t*pa = shm->paddr + offs;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tee_shm_get_pa);\n\n \nstruct tee_shm *tee_shm_get_from_id(struct tee_context *ctx, int id)\n{\n\tstruct tee_device *teedev;\n\tstruct tee_shm *shm;\n\n\tif (!ctx)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tteedev = ctx->teedev;\n\tmutex_lock(&teedev->mutex);\n\tshm = idr_find(&teedev->idr, id);\n\t \n\tif (!shm || shm->ctx != ctx)\n\t\tshm = ERR_PTR(-EINVAL);\n\telse\n\t\trefcount_inc(&shm->refcount);\n\tmutex_unlock(&teedev->mutex);\n\treturn shm;\n}\nEXPORT_SYMBOL_GPL(tee_shm_get_from_id);\n\n \nvoid tee_shm_put(struct tee_shm *shm)\n{\n\tstruct tee_device *teedev = shm->ctx->teedev;\n\tbool do_release = false;\n\n\tmutex_lock(&teedev->mutex);\n\tif (refcount_dec_and_test(&shm->refcount)) {\n\t\t \n\t\tif (shm->id >= 0)\n\t\t\tidr_remove(&teedev->idr, shm->id);\n\t\tdo_release = true;\n\t}\n\tmutex_unlock(&teedev->mutex);\n\n\tif (do_release)\n\t\ttee_shm_release(teedev, shm);\n}\nEXPORT_SYMBOL_GPL(tee_shm_put);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}