{
  "module_name": "call.c",
  "hash_id": "f186f05094fb63d010631857154065b52ac7c0e5e80ac338ad479977f32fe95c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tee/amdtee/call.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/tee.h>\n#include <linux/tee_drv.h>\n#include <linux/psp-tee.h>\n#include <linux/slab.h>\n#include <linux/psp.h>\n#include \"amdtee_if.h\"\n#include \"amdtee_private.h\"\n\nstatic int tee_params_to_amd_params(struct tee_param *tee, u32 count,\n\t\t\t\t    struct tee_operation *amd)\n{\n\tint i, ret = 0;\n\tu32 type;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (!tee || !amd || count > TEE_MAX_PARAMS)\n\t\treturn -EINVAL;\n\n\tamd->param_types = 0;\n\tfor (i = 0; i < count; i++) {\n\t\t \n\t\tif (tee[i].attr > TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT)\n\t\t\treturn -EINVAL;\n\n\t\tamd->param_types |= ((tee[i].attr & 0xF) << i * 4);\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\ttype = TEE_PARAM_TYPE_GET(amd->param_types, i);\n\t\tpr_debug(\"%s: type[%d] = 0x%x\\n\", __func__, i, type);\n\n\t\tif (type == TEE_OP_PARAM_TYPE_INVALID)\n\t\t\treturn -EINVAL;\n\n\t\tif (type == TEE_OP_PARAM_TYPE_NONE)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (type > TEE_OP_PARAM_TYPE_VALUE_INOUT) {\n\t\t\tu32 buf_id = get_buffer_id(tee[i].u.memref.shm);\n\n\t\t\tamd->params[i].mref.buf_id = buf_id;\n\t\t\tamd->params[i].mref.offset = tee[i].u.memref.shm_offs;\n\t\t\tamd->params[i].mref.size = tee[i].u.memref.size;\n\t\t\tpr_debug(\"%s: bufid[%d] = 0x%x, offset[%d] = 0x%x, size[%d] = 0x%x\\n\",\n\t\t\t\t __func__,\n\t\t\t\t i, amd->params[i].mref.buf_id,\n\t\t\t\t i, amd->params[i].mref.offset,\n\t\t\t\t i, amd->params[i].mref.size);\n\t\t} else {\n\t\t\tif (tee[i].u.value.c)\n\t\t\t\tpr_warn(\"%s: Discarding value c\", __func__);\n\n\t\t\tamd->params[i].val.a = tee[i].u.value.a;\n\t\t\tamd->params[i].val.b = tee[i].u.value.b;\n\t\t\tpr_debug(\"%s: a[%d] = 0x%x, b[%d] = 0x%x\\n\", __func__,\n\t\t\t\t i, amd->params[i].val.a,\n\t\t\t\t i, amd->params[i].val.b);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int amd_params_to_tee_params(struct tee_param *tee, u32 count,\n\t\t\t\t    struct tee_operation *amd)\n{\n\tint i, ret = 0;\n\tu32 type;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (!tee || !amd || count > TEE_MAX_PARAMS)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\ttype = TEE_PARAM_TYPE_GET(amd->param_types, i);\n\t\tpr_debug(\"%s: type[%d] = 0x%x\\n\", __func__, i, type);\n\n\t\tif (type == TEE_OP_PARAM_TYPE_INVALID ||\n\t\t    type > TEE_OP_PARAM_TYPE_MEMREF_INOUT)\n\t\t\treturn -EINVAL;\n\n\t\tif (type == TEE_OP_PARAM_TYPE_NONE ||\n\t\t    type == TEE_OP_PARAM_TYPE_VALUE_INPUT ||\n\t\t    type == TEE_OP_PARAM_TYPE_MEMREF_INPUT)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (type > TEE_OP_PARAM_TYPE_MEMREF_INPUT) {\n\t\t\ttee[i].u.memref.shm_offs = amd->params[i].mref.offset;\n\t\t\ttee[i].u.memref.size = amd->params[i].mref.size;\n\t\t\tpr_debug(\"%s: bufid[%d] = 0x%x, offset[%d] = 0x%x, size[%d] = 0x%x\\n\",\n\t\t\t\t __func__,\n\t\t\t\t i, amd->params[i].mref.buf_id,\n\t\t\t\t i, amd->params[i].mref.offset,\n\t\t\t\t i, amd->params[i].mref.size);\n\t\t} else {\n\t\t\t \n\t\t\ttee[i].u.value.a = amd->params[i].val.a;\n\t\t\ttee[i].u.value.b = amd->params[i].val.b;\n\t\t\ttee[i].u.value.c = 0;\n\t\t\tpr_debug(\"%s: a[%d] = 0x%x, b[%d] = 0x%x\\n\",\n\t\t\t\t __func__,\n\t\t\t\t i, amd->params[i].val.a,\n\t\t\t\t i, amd->params[i].val.b);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic DEFINE_MUTEX(ta_refcount_mutex);\nstatic LIST_HEAD(ta_list);\n\nstatic u32 get_ta_refcount(u32 ta_handle)\n{\n\tstruct amdtee_ta_data *ta_data;\n\tu32 count = 0;\n\n\t \n\tlist_for_each_entry(ta_data, &ta_list, list_node)\n\t\tif (ta_data->ta_handle == ta_handle)\n\t\t\treturn ++ta_data->refcount;\n\n\tta_data = kzalloc(sizeof(*ta_data), GFP_KERNEL);\n\tif (ta_data) {\n\t\tta_data->ta_handle = ta_handle;\n\t\tta_data->refcount = 1;\n\t\tcount = ta_data->refcount;\n\t\tlist_add(&ta_data->list_node, &ta_list);\n\t}\n\n\treturn count;\n}\n\nstatic u32 put_ta_refcount(u32 ta_handle)\n{\n\tstruct amdtee_ta_data *ta_data;\n\tu32 count = 0;\n\n\t \n\tlist_for_each_entry(ta_data, &ta_list, list_node)\n\t\tif (ta_data->ta_handle == ta_handle) {\n\t\t\tcount = --ta_data->refcount;\n\t\t\tif (count == 0) {\n\t\t\t\tlist_del(&ta_data->list_node);\n\t\t\t\tkfree(ta_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\treturn count;\n}\n\nint handle_unload_ta(u32 ta_handle)\n{\n\tstruct tee_cmd_unload_ta cmd = {0};\n\tu32 status, count;\n\tint ret;\n\n\tif (!ta_handle)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ta_refcount_mutex);\n\n\tcount = put_ta_refcount(ta_handle);\n\n\tif (count) {\n\t\tpr_debug(\"unload ta: not unloading %u count %u\\n\",\n\t\t\t ta_handle, count);\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tcmd.ta_handle = ta_handle;\n\n\tret = psp_tee_process_cmd(TEE_CMD_ID_UNLOAD_TA, (void *)&cmd,\n\t\t\t\t  sizeof(cmd), &status);\n\tif (!ret && status != 0) {\n\t\tpr_err(\"unload ta: status = 0x%x\\n\", status);\n\t\tret = -EBUSY;\n\t} else {\n\t\tpr_debug(\"unloaded ta handle %u\\n\", ta_handle);\n\t}\n\nunlock:\n\tmutex_unlock(&ta_refcount_mutex);\n\treturn ret;\n}\n\nint handle_close_session(u32 ta_handle, u32 info)\n{\n\tstruct tee_cmd_close_session cmd = {0};\n\tu32 status;\n\tint ret;\n\n\tif (ta_handle == 0)\n\t\treturn -EINVAL;\n\n\tcmd.ta_handle = ta_handle;\n\tcmd.session_info = info;\n\n\tret = psp_tee_process_cmd(TEE_CMD_ID_CLOSE_SESSION, (void *)&cmd,\n\t\t\t\t  sizeof(cmd), &status);\n\tif (!ret && status != 0) {\n\t\tpr_err(\"close session: status = 0x%x\\n\", status);\n\t\tret = -EBUSY;\n\t}\n\n\treturn ret;\n}\n\nvoid handle_unmap_shmem(u32 buf_id)\n{\n\tstruct tee_cmd_unmap_shared_mem cmd = {0};\n\tu32 status;\n\tint ret;\n\n\tcmd.buf_id = buf_id;\n\n\tret = psp_tee_process_cmd(TEE_CMD_ID_UNMAP_SHARED_MEM, (void *)&cmd,\n\t\t\t\t  sizeof(cmd), &status);\n\tif (!ret)\n\t\tpr_debug(\"unmap shared memory: buf_id %u status = 0x%x\\n\",\n\t\t\t buf_id, status);\n}\n\nint handle_invoke_cmd(struct tee_ioctl_invoke_arg *arg, u32 sinfo,\n\t\t      struct tee_param *p)\n{\n\tstruct tee_cmd_invoke_cmd cmd = {0};\n\tint ret;\n\n\tif (!arg || (!p && arg->num_params))\n\t\treturn -EINVAL;\n\n\targ->ret_origin = TEEC_ORIGIN_COMMS;\n\n\tif (arg->session == 0) {\n\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n\t\treturn -EINVAL;\n\t}\n\n\tret = tee_params_to_amd_params(p, arg->num_params, &cmd.op);\n\tif (ret) {\n\t\tpr_err(\"invalid Params. Abort invoke command\\n\");\n\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n\t\treturn ret;\n\t}\n\n\tcmd.ta_handle = get_ta_handle(arg->session);\n\tcmd.cmd_id = arg->func;\n\tcmd.session_info = sinfo;\n\n\tret = psp_tee_process_cmd(TEE_CMD_ID_INVOKE_CMD, (void *)&cmd,\n\t\t\t\t  sizeof(cmd), &arg->ret);\n\tif (ret) {\n\t\targ->ret = TEEC_ERROR_COMMUNICATION;\n\t} else {\n\t\tret = amd_params_to_tee_params(p, arg->num_params, &cmd.op);\n\t\tif (unlikely(ret)) {\n\t\t\tpr_err(\"invoke command: failed to copy output\\n\");\n\t\t\targ->ret = TEEC_ERROR_GENERIC;\n\t\t\treturn ret;\n\t\t}\n\t\targ->ret_origin = cmd.return_origin;\n\t\tpr_debug(\"invoke command: RO = 0x%x ret = 0x%x\\n\",\n\t\t\t arg->ret_origin, arg->ret);\n\t}\n\n\treturn ret;\n}\n\nint handle_map_shmem(u32 count, struct shmem_desc *start, u32 *buf_id)\n{\n\tstruct tee_cmd_map_shared_mem *cmd;\n\tphys_addr_t paddr;\n\tint ret, i;\n\tu32 status;\n\n\tif (!count || !start || !buf_id)\n\t\treturn -EINVAL;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < count ; i++) {\n\t\tif (!start[i].kaddr || (start[i].size & (PAGE_SIZE - 1))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_cmd;\n\t\t}\n\n\t\tif ((u64)start[i].kaddr & (PAGE_SIZE - 1)) {\n\t\t\tpr_err(\"map shared memory: page unaligned. addr 0x%llx\",\n\t\t\t       (u64)start[i].kaddr);\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_cmd;\n\t\t}\n\t}\n\n\tcmd->sg_list.count = count;\n\n\t \n\tfor (i = 0; i < count ; i++) {\n\t\tpaddr = __psp_pa(start[i].kaddr);\n\t\tcmd->sg_list.buf[i].hi_addr = upper_32_bits(paddr);\n\t\tcmd->sg_list.buf[i].low_addr = lower_32_bits(paddr);\n\t\tcmd->sg_list.buf[i].size = start[i].size;\n\t\tcmd->sg_list.size += cmd->sg_list.buf[i].size;\n\n\t\tpr_debug(\"buf[%d]:hi addr = 0x%x\\n\", i,\n\t\t\t cmd->sg_list.buf[i].hi_addr);\n\t\tpr_debug(\"buf[%d]:low addr = 0x%x\\n\", i,\n\t\t\t cmd->sg_list.buf[i].low_addr);\n\t\tpr_debug(\"buf[%d]:size = 0x%x\\n\", i, cmd->sg_list.buf[i].size);\n\t\tpr_debug(\"list size = 0x%x\\n\", cmd->sg_list.size);\n\t}\n\n\t*buf_id = 0;\n\n\tret = psp_tee_process_cmd(TEE_CMD_ID_MAP_SHARED_MEM, (void *)cmd,\n\t\t\t\t  sizeof(*cmd), &status);\n\tif (!ret && !status) {\n\t\t*buf_id = cmd->buf_id;\n\t\tpr_debug(\"mapped buffer ID = 0x%x\\n\", *buf_id);\n\t} else {\n\t\tpr_err(\"map shared memory: status = 0x%x\\n\", status);\n\t\tret = -ENOMEM;\n\t}\n\nfree_cmd:\n\tkfree(cmd);\n\n\treturn ret;\n}\n\nint handle_open_session(struct tee_ioctl_open_session_arg *arg, u32 *info,\n\t\t\tstruct tee_param *p)\n{\n\tstruct tee_cmd_open_session cmd = {0};\n\tint ret;\n\n\tif (!arg || !info || (!p && arg->num_params))\n\t\treturn -EINVAL;\n\n\targ->ret_origin = TEEC_ORIGIN_COMMS;\n\n\tif (arg->session == 0) {\n\t\targ->ret = TEEC_ERROR_GENERIC;\n\t\treturn -EINVAL;\n\t}\n\n\tret = tee_params_to_amd_params(p, arg->num_params, &cmd.op);\n\tif (ret) {\n\t\tpr_err(\"invalid Params. Abort open session\\n\");\n\t\targ->ret = TEEC_ERROR_BAD_PARAMETERS;\n\t\treturn ret;\n\t}\n\n\tcmd.ta_handle = get_ta_handle(arg->session);\n\t*info = 0;\n\n\tret = psp_tee_process_cmd(TEE_CMD_ID_OPEN_SESSION, (void *)&cmd,\n\t\t\t\t  sizeof(cmd), &arg->ret);\n\tif (ret) {\n\t\targ->ret = TEEC_ERROR_COMMUNICATION;\n\t} else {\n\t\tret = amd_params_to_tee_params(p, arg->num_params, &cmd.op);\n\t\tif (unlikely(ret)) {\n\t\t\tpr_err(\"open session: failed to copy output\\n\");\n\t\t\targ->ret = TEEC_ERROR_GENERIC;\n\t\t\treturn ret;\n\t\t}\n\t\targ->ret_origin = cmd.return_origin;\n\t\t*info = cmd.session_info;\n\t\tpr_debug(\"open session: session info = 0x%x\\n\", *info);\n\t}\n\n\tpr_debug(\"open session: ret = 0x%x RO = 0x%x\\n\", arg->ret,\n\t\t arg->ret_origin);\n\n\treturn ret;\n}\n\nint handle_load_ta(void *data, u32 size, struct tee_ioctl_open_session_arg *arg)\n{\n\tstruct tee_cmd_unload_ta unload_cmd = {};\n\tstruct tee_cmd_load_ta load_cmd = {};\n\tphys_addr_t blob;\n\tint ret;\n\n\tif (size == 0 || !data || !arg)\n\t\treturn -EINVAL;\n\n\tblob = __psp_pa(data);\n\tif (blob & (PAGE_SIZE - 1)) {\n\t\tpr_err(\"load TA: page unaligned. blob 0x%llx\", blob);\n\t\treturn -EINVAL;\n\t}\n\n\tload_cmd.hi_addr = upper_32_bits(blob);\n\tload_cmd.low_addr = lower_32_bits(blob);\n\tload_cmd.size = size;\n\n\tmutex_lock(&ta_refcount_mutex);\n\n\tret = psp_tee_process_cmd(TEE_CMD_ID_LOAD_TA, (void *)&load_cmd,\n\t\t\t\t  sizeof(load_cmd), &arg->ret);\n\tif (ret) {\n\t\targ->ret_origin = TEEC_ORIGIN_COMMS;\n\t\targ->ret = TEEC_ERROR_COMMUNICATION;\n\t} else {\n\t\targ->ret_origin = load_cmd.return_origin;\n\n\t\tif (arg->ret == TEEC_SUCCESS) {\n\t\t\tret = get_ta_refcount(load_cmd.ta_handle);\n\t\t\tif (!ret) {\n\t\t\t\targ->ret_origin = TEEC_ORIGIN_COMMS;\n\t\t\t\targ->ret = TEEC_ERROR_OUT_OF_MEMORY;\n\n\t\t\t\t \n\t\t\t\tunload_cmd.ta_handle = load_cmd.ta_handle;\n\t\t\t\tpsp_tee_process_cmd(TEE_CMD_ID_UNLOAD_TA,\n\t\t\t\t\t\t    (void *)&unload_cmd,\n\t\t\t\t\t\t    sizeof(unload_cmd), &ret);\n\t\t\t} else {\n\t\t\t\tset_session_id(load_cmd.ta_handle, 0, &arg->session);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ta_refcount_mutex);\n\n\tpr_debug(\"load TA: TA handle = 0x%x, RO = 0x%x, ret = 0x%x\\n\",\n\t\t load_cmd.ta_handle, arg->ret_origin, arg->ret);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}