{
  "module_name": "core.c",
  "hash_id": "96f43e942c190ae65e7347249e581a17f59edade33091f36d905bef1c2399e36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tee/amdtee/core.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/tee_drv.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/uaccess.h>\n#include <linux/firmware.h>\n#include \"amdtee_private.h\"\n#include \"../tee_private.h\"\n#include <linux/psp-tee.h>\n\nstatic struct amdtee_driver_data *drv_data;\nstatic DEFINE_MUTEX(session_list_mutex);\n\nstatic void amdtee_get_version(struct tee_device *teedev,\n\t\t\t       struct tee_ioctl_version_data *vers)\n{\n\tstruct tee_ioctl_version_data v = {\n\t\t.impl_id = TEE_IMPL_ID_AMDTEE,\n\t\t.impl_caps = 0,\n\t\t.gen_caps = TEE_GEN_CAP_GP,\n\t};\n\t*vers = v;\n}\n\nstatic int amdtee_open(struct tee_context *ctx)\n{\n\tstruct amdtee_context_data *ctxdata;\n\n\tctxdata = kzalloc(sizeof(*ctxdata), GFP_KERNEL);\n\tif (!ctxdata)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ctxdata->sess_list);\n\tINIT_LIST_HEAD(&ctxdata->shm_list);\n\tmutex_init(&ctxdata->shm_mutex);\n\n\tctx->data = ctxdata;\n\treturn 0;\n}\n\nstatic void release_session(struct amdtee_session *sess)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < TEE_NUM_SESSIONS; ++i) {\n\t\t \n\t\tif (!test_bit(i, sess->sess_mask))\n\t\t\tcontinue;\n\n\t\thandle_close_session(sess->ta_handle, sess->session_info[i]);\n\t\thandle_unload_ta(sess->ta_handle);\n\t}\n\n\tkfree(sess);\n}\n\nstatic void amdtee_release(struct tee_context *ctx)\n{\n\tstruct amdtee_context_data *ctxdata = ctx->data;\n\n\tif (!ctxdata)\n\t\treturn;\n\n\twhile (true) {\n\t\tstruct amdtee_session *sess;\n\n\t\tsess = list_first_entry_or_null(&ctxdata->sess_list,\n\t\t\t\t\t\tstruct amdtee_session,\n\t\t\t\t\t\tlist_node);\n\n\t\tif (!sess)\n\t\t\tbreak;\n\n\t\tlist_del(&sess->list_node);\n\t\trelease_session(sess);\n\t}\n\tmutex_destroy(&ctxdata->shm_mutex);\n\tkfree(ctxdata);\n\n\tctx->data = NULL;\n}\n\n \nstatic struct amdtee_session *alloc_session(struct amdtee_context_data *ctxdata,\n\t\t\t\t\t    u32 session)\n{\n\tstruct amdtee_session *sess;\n\tu32 ta_handle = get_ta_handle(session);\n\n\t \n\tlist_for_each_entry(sess, &ctxdata->sess_list, list_node)\n\t\tif (sess->ta_handle == ta_handle) {\n\t\t\tkref_get(&sess->refcount);\n\t\t\treturn sess;\n\t\t}\n\n\t \n\tsess = kzalloc(sizeof(*sess), GFP_KERNEL);\n\tif (sess) {\n\t\tsess->ta_handle = ta_handle;\n\t\tkref_init(&sess->refcount);\n\t\tspin_lock_init(&sess->lock);\n\t\tlist_add(&sess->list_node, &ctxdata->sess_list);\n\t}\n\n\treturn sess;\n}\n\n \nstatic struct amdtee_session *find_session(struct amdtee_context_data *ctxdata,\n\t\t\t\t\t   u32 session)\n{\n\tu32 ta_handle = get_ta_handle(session);\n\tu32 index = get_session_index(session);\n\tstruct amdtee_session *sess;\n\n\tif (index >= TEE_NUM_SESSIONS)\n\t\treturn NULL;\n\n\tlist_for_each_entry(sess, &ctxdata->sess_list, list_node)\n\t\tif (ta_handle == sess->ta_handle &&\n\t\t    test_bit(index, sess->sess_mask))\n\t\t\treturn sess;\n\n\treturn NULL;\n}\n\nu32 get_buffer_id(struct tee_shm *shm)\n{\n\tstruct amdtee_context_data *ctxdata = shm->ctx->data;\n\tstruct amdtee_shm_data *shmdata;\n\tu32 buf_id = 0;\n\n\tmutex_lock(&ctxdata->shm_mutex);\n\tlist_for_each_entry(shmdata, &ctxdata->shm_list, shm_node)\n\t\tif (shmdata->kaddr == shm->kaddr) {\n\t\t\tbuf_id = shmdata->buf_id;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&ctxdata->shm_mutex);\n\n\treturn buf_id;\n}\n\nstatic DEFINE_MUTEX(drv_mutex);\nstatic int copy_ta_binary(struct tee_context *ctx, void *ptr, void **ta,\n\t\t\t  size_t *ta_size)\n{\n\tconst struct firmware *fw;\n\tchar fw_name[TA_PATH_MAX];\n\tstruct {\n\t\tu32 lo;\n\t\tu16 mid;\n\t\tu16 hi_ver;\n\t\tu8 seq_n[8];\n\t} *uuid = ptr;\n\tint n, rc = 0;\n\n\tn = snprintf(fw_name, TA_PATH_MAX,\n\t\t     \"%s/%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x.bin\",\n\t\t     TA_LOAD_PATH, uuid->lo, uuid->mid, uuid->hi_ver,\n\t\t     uuid->seq_n[0], uuid->seq_n[1],\n\t\t     uuid->seq_n[2], uuid->seq_n[3],\n\t\t     uuid->seq_n[4], uuid->seq_n[5],\n\t\t     uuid->seq_n[6], uuid->seq_n[7]);\n\tif (n < 0 || n >= TA_PATH_MAX) {\n\t\tpr_err(\"failed to get firmware name\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&drv_mutex);\n\tn = request_firmware(&fw, fw_name, &ctx->teedev->dev);\n\tif (n) {\n\t\tpr_err(\"failed to load firmware %s\\n\", fw_name);\n\t\trc = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\t*ta_size = roundup(fw->size, PAGE_SIZE);\n\t*ta = (void *)__get_free_pages(GFP_KERNEL, get_order(*ta_size));\n\tif (!*ta) {\n\t\tpr_err(\"%s: get_free_pages failed\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto rel_fw;\n\t}\n\n\tmemcpy(*ta, fw->data, fw->size);\nrel_fw:\n\trelease_firmware(fw);\nunlock:\n\tmutex_unlock(&drv_mutex);\n\treturn rc;\n}\n\n \nstatic void destroy_session(struct kref *ref)\n{\n\tstruct amdtee_session *sess = container_of(ref, struct amdtee_session,\n\t\t\t\t\t\t   refcount);\n\n\tlist_del(&sess->list_node);\n\tmutex_unlock(&session_list_mutex);\n\tkfree(sess);\n}\n\nint amdtee_open_session(struct tee_context *ctx,\n\t\t\tstruct tee_ioctl_open_session_arg *arg,\n\t\t\tstruct tee_param *param)\n{\n\tstruct amdtee_context_data *ctxdata = ctx->data;\n\tstruct amdtee_session *sess = NULL;\n\tu32 session_info, ta_handle;\n\tsize_t ta_size;\n\tint rc, i;\n\tvoid *ta;\n\n\tif (arg->clnt_login != TEE_IOCTL_LOGIN_PUBLIC) {\n\t\tpr_err(\"unsupported client login method\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = copy_ta_binary(ctx, &arg->uuid[0], &ta, &ta_size);\n\tif (rc) {\n\t\tpr_err(\"failed to copy TA binary\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\thandle_load_ta(ta, ta_size, arg);\n\tif (arg->ret != TEEC_SUCCESS)\n\t\tgoto out;\n\n\tta_handle = get_ta_handle(arg->session);\n\n\tmutex_lock(&session_list_mutex);\n\tsess = alloc_session(ctxdata, arg->session);\n\tmutex_unlock(&session_list_mutex);\n\n\tif (!sess) {\n\t\thandle_unload_ta(ta_handle);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\thandle_open_session(arg, &session_info, param);\n\tif (arg->ret != TEEC_SUCCESS) {\n\t\tpr_err(\"open_session failed %d\\n\", arg->ret);\n\t\thandle_unload_ta(ta_handle);\n\t\tkref_put_mutex(&sess->refcount, destroy_session,\n\t\t\t       &session_list_mutex);\n\t\tgoto out;\n\t}\n\n\t \n\tspin_lock(&sess->lock);\n\ti = find_first_zero_bit(sess->sess_mask, TEE_NUM_SESSIONS);\n\tif (i < TEE_NUM_SESSIONS) {\n\t\tsess->session_info[i] = session_info;\n\t\tset_session_id(ta_handle, i, &arg->session);\n\t\tset_bit(i, sess->sess_mask);\n\t}\n\tspin_unlock(&sess->lock);\n\n\tif (i >= TEE_NUM_SESSIONS) {\n\t\tpr_err(\"reached maximum session count %d\\n\", TEE_NUM_SESSIONS);\n\t\thandle_close_session(ta_handle, session_info);\n\t\thandle_unload_ta(ta_handle);\n\t\tkref_put_mutex(&sess->refcount, destroy_session,\n\t\t\t       &session_list_mutex);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\nout:\n\tfree_pages((u64)ta, get_order(ta_size));\n\treturn rc;\n}\n\nint amdtee_close_session(struct tee_context *ctx, u32 session)\n{\n\tstruct amdtee_context_data *ctxdata = ctx->data;\n\tu32 i, ta_handle, session_info;\n\tstruct amdtee_session *sess;\n\n\tpr_debug(\"%s: sid = 0x%x\\n\", __func__, session);\n\n\t \n\tmutex_lock(&session_list_mutex);\n\tsess = find_session(ctxdata, session);\n\tif (sess) {\n\t\tta_handle = get_ta_handle(session);\n\t\ti = get_session_index(session);\n\t\tsession_info = sess->session_info[i];\n\t\tspin_lock(&sess->lock);\n\t\tclear_bit(i, sess->sess_mask);\n\t\tspin_unlock(&sess->lock);\n\t}\n\tmutex_unlock(&session_list_mutex);\n\n\tif (!sess)\n\t\treturn -EINVAL;\n\n\t \n\thandle_close_session(ta_handle, session_info);\n\thandle_unload_ta(ta_handle);\n\n\tkref_put_mutex(&sess->refcount, destroy_session, &session_list_mutex);\n\n\treturn 0;\n}\n\nint amdtee_map_shmem(struct tee_shm *shm)\n{\n\tstruct amdtee_context_data *ctxdata;\n\tstruct amdtee_shm_data *shmnode;\n\tstruct shmem_desc shmem;\n\tint rc, count;\n\tu32 buf_id;\n\n\tif (!shm)\n\t\treturn -EINVAL;\n\n\tshmnode = kmalloc(sizeof(*shmnode), GFP_KERNEL);\n\tif (!shmnode)\n\t\treturn -ENOMEM;\n\n\tcount = 1;\n\tshmem.kaddr = shm->kaddr;\n\tshmem.size = shm->size;\n\n\t \n\trc = handle_map_shmem(count, &shmem, &buf_id);\n\tif (rc) {\n\t\tpr_err(\"map_shmem failed: ret = %d\\n\", rc);\n\t\tkfree(shmnode);\n\t\treturn rc;\n\t}\n\n\tshmnode->kaddr = shm->kaddr;\n\tshmnode->buf_id = buf_id;\n\tctxdata = shm->ctx->data;\n\tmutex_lock(&ctxdata->shm_mutex);\n\tlist_add(&shmnode->shm_node, &ctxdata->shm_list);\n\tmutex_unlock(&ctxdata->shm_mutex);\n\n\tpr_debug(\"buf_id :[%x] kaddr[%p]\\n\", shmnode->buf_id, shmnode->kaddr);\n\n\treturn 0;\n}\n\nvoid amdtee_unmap_shmem(struct tee_shm *shm)\n{\n\tstruct amdtee_context_data *ctxdata;\n\tstruct amdtee_shm_data *shmnode;\n\tu32 buf_id;\n\n\tif (!shm)\n\t\treturn;\n\n\tbuf_id = get_buffer_id(shm);\n\t \n\thandle_unmap_shmem(buf_id);\n\n\tctxdata = shm->ctx->data;\n\tmutex_lock(&ctxdata->shm_mutex);\n\tlist_for_each_entry(shmnode, &ctxdata->shm_list, shm_node)\n\t\tif (buf_id == shmnode->buf_id) {\n\t\t\tlist_del(&shmnode->shm_node);\n\t\t\tkfree(shmnode);\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&ctxdata->shm_mutex);\n}\n\nint amdtee_invoke_func(struct tee_context *ctx,\n\t\t       struct tee_ioctl_invoke_arg *arg,\n\t\t       struct tee_param *param)\n{\n\tstruct amdtee_context_data *ctxdata = ctx->data;\n\tstruct amdtee_session *sess;\n\tu32 i, session_info;\n\n\t \n\tmutex_lock(&session_list_mutex);\n\tsess = find_session(ctxdata, arg->session);\n\tif (sess) {\n\t\ti = get_session_index(arg->session);\n\t\tsession_info = sess->session_info[i];\n\t}\n\tmutex_unlock(&session_list_mutex);\n\n\tif (!sess)\n\t\treturn -EINVAL;\n\n\thandle_invoke_cmd(arg, session_info, param);\n\n\treturn 0;\n}\n\nint amdtee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct tee_driver_ops amdtee_ops = {\n\t.get_version = amdtee_get_version,\n\t.open = amdtee_open,\n\t.release = amdtee_release,\n\t.open_session = amdtee_open_session,\n\t.close_session = amdtee_close_session,\n\t.invoke_func = amdtee_invoke_func,\n\t.cancel_req = amdtee_cancel_req,\n};\n\nstatic const struct tee_desc amdtee_desc = {\n\t.name = DRIVER_NAME \"-clnt\",\n\t.ops = &amdtee_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int __init amdtee_driver_init(void)\n{\n\tstruct tee_device *teedev;\n\tstruct tee_shm_pool *pool;\n\tstruct amdtee *amdtee;\n\tint rc;\n\n\trc = psp_check_tee_status();\n\tif (rc) {\n\t\tpr_err(\"amd-tee driver: tee not present\\n\");\n\t\treturn rc;\n\t}\n\n\tdrv_data = kzalloc(sizeof(*drv_data), GFP_KERNEL);\n\tif (!drv_data)\n\t\treturn -ENOMEM;\n\n\tamdtee = kzalloc(sizeof(*amdtee), GFP_KERNEL);\n\tif (!amdtee) {\n\t\trc = -ENOMEM;\n\t\tgoto err_kfree_drv_data;\n\t}\n\n\tpool = amdtee_config_shm();\n\tif (IS_ERR(pool)) {\n\t\tpr_err(\"shared pool configuration error\\n\");\n\t\trc = PTR_ERR(pool);\n\t\tgoto err_kfree_amdtee;\n\t}\n\n\tteedev = tee_device_alloc(&amdtee_desc, NULL, pool, amdtee);\n\tif (IS_ERR(teedev)) {\n\t\trc = PTR_ERR(teedev);\n\t\tgoto err_free_pool;\n\t}\n\tamdtee->teedev = teedev;\n\n\trc = tee_device_register(amdtee->teedev);\n\tif (rc)\n\t\tgoto err_device_unregister;\n\n\tamdtee->pool = pool;\n\n\tdrv_data->amdtee = amdtee;\n\n\tpr_info(\"amd-tee driver initialization successful\\n\");\n\treturn 0;\n\nerr_device_unregister:\n\ttee_device_unregister(amdtee->teedev);\n\nerr_free_pool:\n\ttee_shm_pool_free(pool);\n\nerr_kfree_amdtee:\n\tkfree(amdtee);\n\nerr_kfree_drv_data:\n\tkfree(drv_data);\n\tdrv_data = NULL;\n\n\tpr_err(\"amd-tee driver initialization failed\\n\");\n\treturn rc;\n}\nmodule_init(amdtee_driver_init);\n\nstatic void __exit amdtee_driver_exit(void)\n{\n\tstruct amdtee *amdtee;\n\n\tif (!drv_data || !drv_data->amdtee)\n\t\treturn;\n\n\tamdtee = drv_data->amdtee;\n\n\ttee_device_unregister(amdtee->teedev);\n\ttee_shm_pool_free(amdtee->pool);\n}\nmodule_exit(amdtee_driver_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(\"AMD-TEE driver\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}