{
  "module_name": "tee_core.c",
  "hash_id": "980f86a2658eb1fe4f17a83dd60fb9ed01ac779d4c6c1c78a206cfe40aecb4b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tee/tee_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#include <linux/cdev.h>\n#include <linux/cred.h>\n#include <linux/fs.h>\n#include <linux/idr.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/tee_drv.h>\n#include <linux/uaccess.h>\n#include <crypto/hash.h>\n#include <crypto/sha1.h>\n#include \"tee_private.h\"\n\n#define TEE_NUM_DEVICES\t32\n\n#define TEE_IOCTL_PARAM_SIZE(x) (sizeof(struct tee_param) * (x))\n\n#define TEE_UUID_NS_NAME_SIZE\t128\n\n \nstatic const uuid_t tee_client_uuid_ns = UUID_INIT(0x58ac9ca0, 0x2086, 0x4683,\n\t\t\t\t\t\t   0xa1, 0xb8, 0xec, 0x4b,\n\t\t\t\t\t\t   0xc0, 0x8e, 0x01, 0xb6);\n\n \nstatic DECLARE_BITMAP(dev_mask, TEE_NUM_DEVICES);\nstatic DEFINE_SPINLOCK(driver_lock);\n\nstatic struct class *tee_class;\nstatic dev_t tee_devt;\n\nstruct tee_context *teedev_open(struct tee_device *teedev)\n{\n\tint rc;\n\tstruct tee_context *ctx;\n\n\tif (!tee_device_get(teedev))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tkref_init(&ctx->refcount);\n\tctx->teedev = teedev;\n\trc = teedev->desc->ops->open(ctx);\n\tif (rc)\n\t\tgoto err;\n\n\treturn ctx;\nerr:\n\tkfree(ctx);\n\ttee_device_put(teedev);\n\treturn ERR_PTR(rc);\n\n}\nEXPORT_SYMBOL_GPL(teedev_open);\n\nvoid teedev_ctx_get(struct tee_context *ctx)\n{\n\tif (ctx->releasing)\n\t\treturn;\n\n\tkref_get(&ctx->refcount);\n}\n\nstatic void teedev_ctx_release(struct kref *ref)\n{\n\tstruct tee_context *ctx = container_of(ref, struct tee_context,\n\t\t\t\t\t       refcount);\n\tctx->releasing = true;\n\tctx->teedev->desc->ops->release(ctx);\n\tkfree(ctx);\n}\n\nvoid teedev_ctx_put(struct tee_context *ctx)\n{\n\tif (ctx->releasing)\n\t\treturn;\n\n\tkref_put(&ctx->refcount, teedev_ctx_release);\n}\n\nvoid teedev_close_context(struct tee_context *ctx)\n{\n\tstruct tee_device *teedev = ctx->teedev;\n\n\tteedev_ctx_put(ctx);\n\ttee_device_put(teedev);\n}\nEXPORT_SYMBOL_GPL(teedev_close_context);\n\nstatic int tee_open(struct inode *inode, struct file *filp)\n{\n\tstruct tee_context *ctx;\n\n\tctx = teedev_open(container_of(inode->i_cdev, struct tee_device, cdev));\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\t \n\tctx->supp_nowait = false;\n\tfilp->private_data = ctx;\n\treturn 0;\n}\n\nstatic int tee_release(struct inode *inode, struct file *filp)\n{\n\tteedev_close_context(filp->private_data);\n\treturn 0;\n}\n\n \nstatic int uuid_v5(uuid_t *uuid, const uuid_t *ns, const void *name,\n\t\t   size_t size)\n{\n\tunsigned char hash[SHA1_DIGEST_SIZE];\n\tstruct crypto_shash *shash = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint rc;\n\n\tshash = crypto_alloc_shash(\"sha1\", 0, 0);\n\tif (IS_ERR(shash)) {\n\t\trc = PTR_ERR(shash);\n\t\tpr_err(\"shash(sha1) allocation failed\\n\");\n\t\treturn rc;\n\t}\n\n\tdesc = kzalloc(sizeof(*desc) + crypto_shash_descsize(shash),\n\t\t       GFP_KERNEL);\n\tif (!desc) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_shash;\n\t}\n\n\tdesc->tfm = shash;\n\n\trc = crypto_shash_init(desc);\n\tif (rc < 0)\n\t\tgoto out_free_desc;\n\n\trc = crypto_shash_update(desc, (const u8 *)ns, sizeof(*ns));\n\tif (rc < 0)\n\t\tgoto out_free_desc;\n\n\trc = crypto_shash_update(desc, (const u8 *)name, size);\n\tif (rc < 0)\n\t\tgoto out_free_desc;\n\n\trc = crypto_shash_final(desc, hash);\n\tif (rc < 0)\n\t\tgoto out_free_desc;\n\n\tmemcpy(uuid->b, hash, UUID_SIZE);\n\n\t \n\tuuid->b[6] = (hash[6] & 0x0F) | 0x50;\n\tuuid->b[8] = (hash[8] & 0x3F) | 0x80;\n\nout_free_desc:\n\tkfree(desc);\n\nout_free_shash:\n\tcrypto_free_shash(shash);\n\treturn rc;\n}\n\nint tee_session_calc_client_uuid(uuid_t *uuid, u32 connection_method,\n\t\t\t\t const u8 connection_data[TEE_IOCTL_UUID_LEN])\n{\n\tgid_t ns_grp = (gid_t)-1;\n\tkgid_t grp = INVALID_GID;\n\tchar *name = NULL;\n\tint name_len;\n\tint rc;\n\n\tif (connection_method == TEE_IOCTL_LOGIN_PUBLIC ||\n\t    connection_method == TEE_IOCTL_LOGIN_REE_KERNEL) {\n\t\t \n\t\tuuid_copy(uuid, &uuid_null);\n\t\treturn 0;\n\t}\n\n\t \n\n\tname = kzalloc(TEE_UUID_NS_NAME_SIZE, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tswitch (connection_method) {\n\tcase TEE_IOCTL_LOGIN_USER:\n\t\tname_len = snprintf(name, TEE_UUID_NS_NAME_SIZE, \"uid=%x\",\n\t\t\t\t    current_euid().val);\n\t\tif (name_len >= TEE_UUID_NS_NAME_SIZE) {\n\t\t\trc = -E2BIG;\n\t\t\tgoto out_free_name;\n\t\t}\n\t\tbreak;\n\n\tcase TEE_IOCTL_LOGIN_GROUP:\n\t\tmemcpy(&ns_grp, connection_data, sizeof(gid_t));\n\t\tgrp = make_kgid(current_user_ns(), ns_grp);\n\t\tif (!gid_valid(grp) || !in_egroup_p(grp)) {\n\t\t\trc = -EPERM;\n\t\t\tgoto out_free_name;\n\t\t}\n\n\t\tname_len = snprintf(name, TEE_UUID_NS_NAME_SIZE, \"gid=%x\",\n\t\t\t\t    grp.val);\n\t\tif (name_len >= TEE_UUID_NS_NAME_SIZE) {\n\t\t\trc = -E2BIG;\n\t\t\tgoto out_free_name;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = -EINVAL;\n\t\tgoto out_free_name;\n\t}\n\n\trc = uuid_v5(uuid, &tee_client_uuid_ns, name, name_len);\nout_free_name:\n\tkfree(name);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tee_session_calc_client_uuid);\n\nstatic int tee_ioctl_version(struct tee_context *ctx,\n\t\t\t     struct tee_ioctl_version_data __user *uvers)\n{\n\tstruct tee_ioctl_version_data vers;\n\n\tctx->teedev->desc->ops->get_version(ctx->teedev, &vers);\n\n\tif (ctx->teedev->desc->flags & TEE_DESC_PRIVILEGED)\n\t\tvers.gen_caps |= TEE_GEN_CAP_PRIVILEGED;\n\n\tif (copy_to_user(uvers, &vers, sizeof(vers)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int tee_ioctl_shm_alloc(struct tee_context *ctx,\n\t\t\t       struct tee_ioctl_shm_alloc_data __user *udata)\n{\n\tlong ret;\n\tstruct tee_ioctl_shm_alloc_data data;\n\tstruct tee_shm *shm;\n\n\tif (copy_from_user(&data, udata, sizeof(data)))\n\t\treturn -EFAULT;\n\n\t \n\tif (data.flags)\n\t\treturn -EINVAL;\n\n\tshm = tee_shm_alloc_user_buf(ctx, data.size);\n\tif (IS_ERR(shm))\n\t\treturn PTR_ERR(shm);\n\n\tdata.id = shm->id;\n\tdata.size = shm->size;\n\n\tif (copy_to_user(udata, &data, sizeof(data)))\n\t\tret = -EFAULT;\n\telse\n\t\tret = tee_shm_get_fd(shm);\n\n\t \n\ttee_shm_put(shm);\n\treturn ret;\n}\n\nstatic int\ntee_ioctl_shm_register(struct tee_context *ctx,\n\t\t       struct tee_ioctl_shm_register_data __user *udata)\n{\n\tlong ret;\n\tstruct tee_ioctl_shm_register_data data;\n\tstruct tee_shm *shm;\n\n\tif (copy_from_user(&data, udata, sizeof(data)))\n\t\treturn -EFAULT;\n\n\t \n\tif (data.flags)\n\t\treturn -EINVAL;\n\n\tshm = tee_shm_register_user_buf(ctx, data.addr, data.length);\n\tif (IS_ERR(shm))\n\t\treturn PTR_ERR(shm);\n\n\tdata.id = shm->id;\n\tdata.length = shm->size;\n\n\tif (copy_to_user(udata, &data, sizeof(data)))\n\t\tret = -EFAULT;\n\telse\n\t\tret = tee_shm_get_fd(shm);\n\t \n\ttee_shm_put(shm);\n\treturn ret;\n}\n\nstatic int params_from_user(struct tee_context *ctx, struct tee_param *params,\n\t\t\t    size_t num_params,\n\t\t\t    struct tee_ioctl_param __user *uparams)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tstruct tee_shm *shm;\n\t\tstruct tee_ioctl_param ip;\n\n\t\tif (copy_from_user(&ip, uparams + n, sizeof(ip)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif (ip.attr & ~TEE_IOCTL_PARAM_ATTR_MASK)\n\t\t\treturn -EINVAL;\n\n\t\tparams[n].attr = ip.attr;\n\t\tswitch (ip.attr & TEE_IOCTL_PARAM_ATTR_TYPE_MASK) {\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_NONE:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:\n\t\t\tbreak;\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:\n\t\t\tparams[n].u.value.a = ip.a;\n\t\t\tparams[n].u.value.b = ip.b;\n\t\t\tparams[n].u.value.c = ip.c;\n\t\t\tbreak;\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:\n\t\t\t \n\t\t\tif (ip.c != TEE_MEMREF_NULL) {\n\t\t\t\t \n\t\t\t\tshm = tee_shm_get_from_id(ctx, ip.c);\n\t\t\t\tif (IS_ERR(shm))\n\t\t\t\t\treturn PTR_ERR(shm);\n\n\t\t\t\t \n\t\t\t\tif ((ip.a + ip.b) < ip.a ||\n\t\t\t\t    (ip.a + ip.b) > shm->size) {\n\t\t\t\t\ttee_shm_put(shm);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t} else if (ctx->cap_memref_null) {\n\t\t\t\t \n\t\t\t\tshm = NULL;\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tparams[n].u.memref.shm_offs = ip.a;\n\t\t\tparams[n].u.memref.size = ip.b;\n\t\t\tparams[n].u.memref.shm = shm;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int params_to_user(struct tee_ioctl_param __user *uparams,\n\t\t\t  size_t num_params, struct tee_param *params)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tstruct tee_ioctl_param __user *up = uparams + n;\n\t\tstruct tee_param *p = params + n;\n\n\t\tswitch (p->attr) {\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:\n\t\t\tif (put_user(p->u.value.a, &up->a) ||\n\t\t\t    put_user(p->u.value.b, &up->b) ||\n\t\t\t    put_user(p->u.value.c, &up->c))\n\t\t\t\treturn -EFAULT;\n\t\t\tbreak;\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:\n\t\t\tif (put_user((u64)p->u.memref.size, &up->b))\n\t\t\t\treturn -EFAULT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int tee_ioctl_open_session(struct tee_context *ctx,\n\t\t\t\t  struct tee_ioctl_buf_data __user *ubuf)\n{\n\tint rc;\n\tsize_t n;\n\tstruct tee_ioctl_buf_data buf;\n\tstruct tee_ioctl_open_session_arg __user *uarg;\n\tstruct tee_ioctl_open_session_arg arg;\n\tstruct tee_ioctl_param __user *uparams = NULL;\n\tstruct tee_param *params = NULL;\n\tbool have_session = false;\n\n\tif (!ctx->teedev->desc->ops->open_session)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&buf, ubuf, sizeof(buf)))\n\t\treturn -EFAULT;\n\n\tif (buf.buf_len > TEE_MAX_ARG_SIZE ||\n\t    buf.buf_len < sizeof(struct tee_ioctl_open_session_arg))\n\t\treturn -EINVAL;\n\n\tuarg = u64_to_user_ptr(buf.buf_ptr);\n\tif (copy_from_user(&arg, uarg, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\tif (sizeof(arg) + TEE_IOCTL_PARAM_SIZE(arg.num_params) != buf.buf_len)\n\t\treturn -EINVAL;\n\n\tif (arg.num_params) {\n\t\tparams = kcalloc(arg.num_params, sizeof(struct tee_param),\n\t\t\t\t GFP_KERNEL);\n\t\tif (!params)\n\t\t\treturn -ENOMEM;\n\t\tuparams = uarg->params;\n\t\trc = params_from_user(ctx, params, arg.num_params, uparams);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tif (arg.clnt_login >= TEE_IOCTL_LOGIN_REE_KERNEL_MIN &&\n\t    arg.clnt_login <= TEE_IOCTL_LOGIN_REE_KERNEL_MAX) {\n\t\tpr_debug(\"login method not allowed for user-space client\\n\");\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\trc = ctx->teedev->desc->ops->open_session(ctx, &arg, params);\n\tif (rc)\n\t\tgoto out;\n\thave_session = true;\n\n\tif (put_user(arg.session, &uarg->session) ||\n\t    put_user(arg.ret, &uarg->ret) ||\n\t    put_user(arg.ret_origin, &uarg->ret_origin)) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\trc = params_to_user(uparams, arg.num_params, params);\nout:\n\t \n\tif (rc && have_session && ctx->teedev->desc->ops->close_session)\n\t\tctx->teedev->desc->ops->close_session(ctx, arg.session);\n\n\tif (params) {\n\t\t \n\t\tfor (n = 0; n < arg.num_params; n++)\n\t\t\tif (tee_param_is_memref(params + n) &&\n\t\t\t    params[n].u.memref.shm)\n\t\t\t\ttee_shm_put(params[n].u.memref.shm);\n\t\tkfree(params);\n\t}\n\n\treturn rc;\n}\n\nstatic int tee_ioctl_invoke(struct tee_context *ctx,\n\t\t\t    struct tee_ioctl_buf_data __user *ubuf)\n{\n\tint rc;\n\tsize_t n;\n\tstruct tee_ioctl_buf_data buf;\n\tstruct tee_ioctl_invoke_arg __user *uarg;\n\tstruct tee_ioctl_invoke_arg arg;\n\tstruct tee_ioctl_param __user *uparams = NULL;\n\tstruct tee_param *params = NULL;\n\n\tif (!ctx->teedev->desc->ops->invoke_func)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&buf, ubuf, sizeof(buf)))\n\t\treturn -EFAULT;\n\n\tif (buf.buf_len > TEE_MAX_ARG_SIZE ||\n\t    buf.buf_len < sizeof(struct tee_ioctl_invoke_arg))\n\t\treturn -EINVAL;\n\n\tuarg = u64_to_user_ptr(buf.buf_ptr);\n\tif (copy_from_user(&arg, uarg, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\tif (sizeof(arg) + TEE_IOCTL_PARAM_SIZE(arg.num_params) != buf.buf_len)\n\t\treturn -EINVAL;\n\n\tif (arg.num_params) {\n\t\tparams = kcalloc(arg.num_params, sizeof(struct tee_param),\n\t\t\t\t GFP_KERNEL);\n\t\tif (!params)\n\t\t\treturn -ENOMEM;\n\t\tuparams = uarg->params;\n\t\trc = params_from_user(ctx, params, arg.num_params, uparams);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = ctx->teedev->desc->ops->invoke_func(ctx, &arg, params);\n\tif (rc)\n\t\tgoto out;\n\n\tif (put_user(arg.ret, &uarg->ret) ||\n\t    put_user(arg.ret_origin, &uarg->ret_origin)) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\trc = params_to_user(uparams, arg.num_params, params);\nout:\n\tif (params) {\n\t\t \n\t\tfor (n = 0; n < arg.num_params; n++)\n\t\t\tif (tee_param_is_memref(params + n) &&\n\t\t\t    params[n].u.memref.shm)\n\t\t\t\ttee_shm_put(params[n].u.memref.shm);\n\t\tkfree(params);\n\t}\n\treturn rc;\n}\n\nstatic int tee_ioctl_cancel(struct tee_context *ctx,\n\t\t\t    struct tee_ioctl_cancel_arg __user *uarg)\n{\n\tstruct tee_ioctl_cancel_arg arg;\n\n\tif (!ctx->teedev->desc->ops->cancel_req)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&arg, uarg, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\treturn ctx->teedev->desc->ops->cancel_req(ctx, arg.cancel_id,\n\t\t\t\t\t\t  arg.session);\n}\n\nstatic int\ntee_ioctl_close_session(struct tee_context *ctx,\n\t\t\tstruct tee_ioctl_close_session_arg __user *uarg)\n{\n\tstruct tee_ioctl_close_session_arg arg;\n\n\tif (!ctx->teedev->desc->ops->close_session)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&arg, uarg, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\treturn ctx->teedev->desc->ops->close_session(ctx, arg.session);\n}\n\nstatic int params_to_supp(struct tee_context *ctx,\n\t\t\t  struct tee_ioctl_param __user *uparams,\n\t\t\t  size_t num_params, struct tee_param *params)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tstruct tee_ioctl_param ip;\n\t\tstruct tee_param *p = params + n;\n\n\t\tip.attr = p->attr;\n\t\tswitch (p->attr & TEE_IOCTL_PARAM_ATTR_TYPE_MASK) {\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:\n\t\t\tip.a = p->u.value.a;\n\t\t\tip.b = p->u.value.b;\n\t\t\tip.c = p->u.value.c;\n\t\t\tbreak;\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:\n\t\t\tip.b = p->u.memref.size;\n\t\t\tif (!p->u.memref.shm) {\n\t\t\t\tip.a = 0;\n\t\t\t\tip.c = (u64)-1;  \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tip.a = p->u.memref.shm_offs;\n\t\t\tip.c = p->u.memref.shm->id;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tip.a = 0;\n\t\t\tip.b = 0;\n\t\t\tip.c = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(uparams + n, &ip, sizeof(ip)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int tee_ioctl_supp_recv(struct tee_context *ctx,\n\t\t\t       struct tee_ioctl_buf_data __user *ubuf)\n{\n\tint rc;\n\tstruct tee_ioctl_buf_data buf;\n\tstruct tee_iocl_supp_recv_arg __user *uarg;\n\tstruct tee_param *params;\n\tu32 num_params;\n\tu32 func;\n\n\tif (!ctx->teedev->desc->ops->supp_recv)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&buf, ubuf, sizeof(buf)))\n\t\treturn -EFAULT;\n\n\tif (buf.buf_len > TEE_MAX_ARG_SIZE ||\n\t    buf.buf_len < sizeof(struct tee_iocl_supp_recv_arg))\n\t\treturn -EINVAL;\n\n\tuarg = u64_to_user_ptr(buf.buf_ptr);\n\tif (get_user(num_params, &uarg->num_params))\n\t\treturn -EFAULT;\n\n\tif (sizeof(*uarg) + TEE_IOCTL_PARAM_SIZE(num_params) != buf.buf_len)\n\t\treturn -EINVAL;\n\n\tparams = kcalloc(num_params, sizeof(struct tee_param), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\trc = params_from_user(ctx, params, num_params, uarg->params);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ctx->teedev->desc->ops->supp_recv(ctx, &func, &num_params, params);\n\tif (rc)\n\t\tgoto out;\n\n\tif (put_user(func, &uarg->func) ||\n\t    put_user(num_params, &uarg->num_params)) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\trc = params_to_supp(ctx, uarg->params, num_params, params);\nout:\n\tkfree(params);\n\treturn rc;\n}\n\nstatic int params_from_supp(struct tee_param *params, size_t num_params,\n\t\t\t    struct tee_ioctl_param __user *uparams)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tstruct tee_param *p = params + n;\n\t\tstruct tee_ioctl_param ip;\n\n\t\tif (copy_from_user(&ip, uparams + n, sizeof(ip)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif (ip.attr & ~TEE_IOCTL_PARAM_ATTR_MASK)\n\t\t\treturn -EINVAL;\n\n\t\tp->attr = ip.attr;\n\t\tswitch (ip.attr & TEE_IOCTL_PARAM_ATTR_TYPE_MASK) {\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:\n\t\t\t \n\t\t\tp->u.value.a = ip.a;\n\t\t\tp->u.value.b = ip.b;\n\t\t\tp->u.value.c = ip.c;\n\t\t\tbreak;\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:\n\t\t\t \n\t\t\tp->u.memref.shm = NULL;\n\t\t\tp->u.memref.shm_offs = 0;\n\t\t\tp->u.memref.size = ip.b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u, 0, sizeof(p->u));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int tee_ioctl_supp_send(struct tee_context *ctx,\n\t\t\t       struct tee_ioctl_buf_data __user *ubuf)\n{\n\tlong rc;\n\tstruct tee_ioctl_buf_data buf;\n\tstruct tee_iocl_supp_send_arg __user *uarg;\n\tstruct tee_param *params;\n\tu32 num_params;\n\tu32 ret;\n\n\t \n\tif (!ctx->teedev->desc->ops->supp_send)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&buf, ubuf, sizeof(buf)))\n\t\treturn -EFAULT;\n\n\tif (buf.buf_len > TEE_MAX_ARG_SIZE ||\n\t    buf.buf_len < sizeof(struct tee_iocl_supp_send_arg))\n\t\treturn -EINVAL;\n\n\tuarg = u64_to_user_ptr(buf.buf_ptr);\n\tif (get_user(ret, &uarg->ret) ||\n\t    get_user(num_params, &uarg->num_params))\n\t\treturn -EFAULT;\n\n\tif (sizeof(*uarg) + TEE_IOCTL_PARAM_SIZE(num_params) > buf.buf_len)\n\t\treturn -EINVAL;\n\n\tparams = kcalloc(num_params, sizeof(struct tee_param), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\trc = params_from_supp(params, num_params, uarg->params);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ctx->teedev->desc->ops->supp_send(ctx, ret, num_params, params);\nout:\n\tkfree(params);\n\treturn rc;\n}\n\nstatic long tee_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct tee_context *ctx = filp->private_data;\n\tvoid __user *uarg = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase TEE_IOC_VERSION:\n\t\treturn tee_ioctl_version(ctx, uarg);\n\tcase TEE_IOC_SHM_ALLOC:\n\t\treturn tee_ioctl_shm_alloc(ctx, uarg);\n\tcase TEE_IOC_SHM_REGISTER:\n\t\treturn tee_ioctl_shm_register(ctx, uarg);\n\tcase TEE_IOC_OPEN_SESSION:\n\t\treturn tee_ioctl_open_session(ctx, uarg);\n\tcase TEE_IOC_INVOKE:\n\t\treturn tee_ioctl_invoke(ctx, uarg);\n\tcase TEE_IOC_CANCEL:\n\t\treturn tee_ioctl_cancel(ctx, uarg);\n\tcase TEE_IOC_CLOSE_SESSION:\n\t\treturn tee_ioctl_close_session(ctx, uarg);\n\tcase TEE_IOC_SUPPL_RECV:\n\t\treturn tee_ioctl_supp_recv(ctx, uarg);\n\tcase TEE_IOC_SUPPL_SEND:\n\t\treturn tee_ioctl_supp_send(ctx, uarg);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct file_operations tee_fops = {\n\t.owner = THIS_MODULE,\n\t.open = tee_open,\n\t.release = tee_release,\n\t.unlocked_ioctl = tee_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n};\n\nstatic void tee_release_device(struct device *dev)\n{\n\tstruct tee_device *teedev = container_of(dev, struct tee_device, dev);\n\n\tspin_lock(&driver_lock);\n\tclear_bit(teedev->id, dev_mask);\n\tspin_unlock(&driver_lock);\n\tmutex_destroy(&teedev->mutex);\n\tidr_destroy(&teedev->idr);\n\tkfree(teedev);\n}\n\n \nstruct tee_device *tee_device_alloc(const struct tee_desc *teedesc,\n\t\t\t\t    struct device *dev,\n\t\t\t\t    struct tee_shm_pool *pool,\n\t\t\t\t    void *driver_data)\n{\n\tstruct tee_device *teedev;\n\tvoid *ret;\n\tint rc, max_id;\n\tint offs = 0;\n\n\tif (!teedesc || !teedesc->name || !teedesc->ops ||\n\t    !teedesc->ops->get_version || !teedesc->ops->open ||\n\t    !teedesc->ops->release || !pool)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tteedev = kzalloc(sizeof(*teedev), GFP_KERNEL);\n\tif (!teedev) {\n\t\tret = ERR_PTR(-ENOMEM);\n\t\tgoto err;\n\t}\n\n\tmax_id = TEE_NUM_DEVICES / 2;\n\n\tif (teedesc->flags & TEE_DESC_PRIVILEGED) {\n\t\toffs = TEE_NUM_DEVICES / 2;\n\t\tmax_id = TEE_NUM_DEVICES;\n\t}\n\n\tspin_lock(&driver_lock);\n\tteedev->id = find_next_zero_bit(dev_mask, max_id, offs);\n\tif (teedev->id < max_id)\n\t\tset_bit(teedev->id, dev_mask);\n\tspin_unlock(&driver_lock);\n\n\tif (teedev->id >= max_id) {\n\t\tret = ERR_PTR(-ENOMEM);\n\t\tgoto err;\n\t}\n\n\tsnprintf(teedev->name, sizeof(teedev->name), \"tee%s%d\",\n\t\t teedesc->flags & TEE_DESC_PRIVILEGED ? \"priv\" : \"\",\n\t\t teedev->id - offs);\n\n\tteedev->dev.class = tee_class;\n\tteedev->dev.release = tee_release_device;\n\tteedev->dev.parent = dev;\n\n\tteedev->dev.devt = MKDEV(MAJOR(tee_devt), teedev->id);\n\n\trc = dev_set_name(&teedev->dev, \"%s\", teedev->name);\n\tif (rc) {\n\t\tret = ERR_PTR(rc);\n\t\tgoto err_devt;\n\t}\n\n\tcdev_init(&teedev->cdev, &tee_fops);\n\tteedev->cdev.owner = teedesc->owner;\n\n\tdev_set_drvdata(&teedev->dev, driver_data);\n\tdevice_initialize(&teedev->dev);\n\n\t \n\tteedev->num_users = 1;\n\tinit_completion(&teedev->c_no_users);\n\tmutex_init(&teedev->mutex);\n\tidr_init(&teedev->idr);\n\n\tteedev->desc = teedesc;\n\tteedev->pool = pool;\n\n\treturn teedev;\nerr_devt:\n\tunregister_chrdev_region(teedev->dev.devt, 1);\nerr:\n\tpr_err(\"could not register %s driver\\n\",\n\t       teedesc->flags & TEE_DESC_PRIVILEGED ? \"privileged\" : \"client\");\n\tif (teedev && teedev->id < TEE_NUM_DEVICES) {\n\t\tspin_lock(&driver_lock);\n\t\tclear_bit(teedev->id, dev_mask);\n\t\tspin_unlock(&driver_lock);\n\t}\n\tkfree(teedev);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tee_device_alloc);\n\nstatic ssize_t implementation_id_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct tee_device *teedev = container_of(dev, struct tee_device, dev);\n\tstruct tee_ioctl_version_data vers;\n\n\tteedev->desc->ops->get_version(teedev, &vers);\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", vers.impl_id);\n}\nstatic DEVICE_ATTR_RO(implementation_id);\n\nstatic struct attribute *tee_dev_attrs[] = {\n\t&dev_attr_implementation_id.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(tee_dev);\n\n \nint tee_device_register(struct tee_device *teedev)\n{\n\tint rc;\n\n\tif (teedev->flags & TEE_DEVICE_FLAG_REGISTERED) {\n\t\tdev_err(&teedev->dev, \"attempt to register twice\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tteedev->dev.groups = tee_dev_groups;\n\n\trc = cdev_device_add(&teedev->cdev, &teedev->dev);\n\tif (rc) {\n\t\tdev_err(&teedev->dev,\n\t\t\t\"unable to cdev_device_add() %s, major %d, minor %d, err=%d\\n\",\n\t\t\tteedev->name, MAJOR(teedev->dev.devt),\n\t\t\tMINOR(teedev->dev.devt), rc);\n\t\treturn rc;\n\t}\n\n\tteedev->flags |= TEE_DEVICE_FLAG_REGISTERED;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tee_device_register);\n\nvoid tee_device_put(struct tee_device *teedev)\n{\n\tmutex_lock(&teedev->mutex);\n\t \n\tif (!WARN_ON(!teedev->desc)) {\n\t\tteedev->num_users--;\n\t\tif (!teedev->num_users) {\n\t\t\tteedev->desc = NULL;\n\t\t\tcomplete(&teedev->c_no_users);\n\t\t}\n\t}\n\tmutex_unlock(&teedev->mutex);\n}\n\nbool tee_device_get(struct tee_device *teedev)\n{\n\tmutex_lock(&teedev->mutex);\n\tif (!teedev->desc) {\n\t\tmutex_unlock(&teedev->mutex);\n\t\treturn false;\n\t}\n\tteedev->num_users++;\n\tmutex_unlock(&teedev->mutex);\n\treturn true;\n}\n\n \nvoid tee_device_unregister(struct tee_device *teedev)\n{\n\tif (!teedev)\n\t\treturn;\n\n\tif (teedev->flags & TEE_DEVICE_FLAG_REGISTERED)\n\t\tcdev_device_del(&teedev->cdev, &teedev->dev);\n\n\ttee_device_put(teedev);\n\twait_for_completion(&teedev->c_no_users);\n\n\t \n\n\tteedev->pool = NULL;\n\n\tput_device(&teedev->dev);\n}\nEXPORT_SYMBOL_GPL(tee_device_unregister);\n\n \nvoid *tee_get_drvdata(struct tee_device *teedev)\n{\n\treturn dev_get_drvdata(&teedev->dev);\n}\nEXPORT_SYMBOL_GPL(tee_get_drvdata);\n\nstruct match_dev_data {\n\tstruct tee_ioctl_version_data *vers;\n\tconst void *data;\n\tint (*match)(struct tee_ioctl_version_data *, const void *);\n};\n\nstatic int match_dev(struct device *dev, const void *data)\n{\n\tconst struct match_dev_data *match_data = data;\n\tstruct tee_device *teedev = container_of(dev, struct tee_device, dev);\n\n\tteedev->desc->ops->get_version(teedev, match_data->vers);\n\treturn match_data->match(match_data->vers, match_data->data);\n}\n\nstruct tee_context *\ntee_client_open_context(struct tee_context *start,\n\t\t\tint (*match)(struct tee_ioctl_version_data *,\n\t\t\t\t     const void *),\n\t\t\tconst void *data, struct tee_ioctl_version_data *vers)\n{\n\tstruct device *dev = NULL;\n\tstruct device *put_dev = NULL;\n\tstruct tee_context *ctx = NULL;\n\tstruct tee_ioctl_version_data v;\n\tstruct match_dev_data match_data = { vers ? vers : &v, data, match };\n\n\tif (start)\n\t\tdev = &start->teedev->dev;\n\n\tdo {\n\t\tdev = class_find_device(tee_class, dev, &match_data, match_dev);\n\t\tif (!dev) {\n\t\t\tctx = ERR_PTR(-ENOENT);\n\t\t\tbreak;\n\t\t}\n\n\t\tput_device(put_dev);\n\t\tput_dev = dev;\n\n\t\tctx = teedev_open(container_of(dev, struct tee_device, dev));\n\t} while (IS_ERR(ctx) && PTR_ERR(ctx) != -ENOMEM);\n\n\tput_device(put_dev);\n\t \n\tif (!IS_ERR(ctx))\n\t\tctx->supp_nowait = true;\n\n\treturn ctx;\n}\nEXPORT_SYMBOL_GPL(tee_client_open_context);\n\nvoid tee_client_close_context(struct tee_context *ctx)\n{\n\tteedev_close_context(ctx);\n}\nEXPORT_SYMBOL_GPL(tee_client_close_context);\n\nvoid tee_client_get_version(struct tee_context *ctx,\n\t\t\t    struct tee_ioctl_version_data *vers)\n{\n\tctx->teedev->desc->ops->get_version(ctx->teedev, vers);\n}\nEXPORT_SYMBOL_GPL(tee_client_get_version);\n\nint tee_client_open_session(struct tee_context *ctx,\n\t\t\t    struct tee_ioctl_open_session_arg *arg,\n\t\t\t    struct tee_param *param)\n{\n\tif (!ctx->teedev->desc->ops->open_session)\n\t\treturn -EINVAL;\n\treturn ctx->teedev->desc->ops->open_session(ctx, arg, param);\n}\nEXPORT_SYMBOL_GPL(tee_client_open_session);\n\nint tee_client_close_session(struct tee_context *ctx, u32 session)\n{\n\tif (!ctx->teedev->desc->ops->close_session)\n\t\treturn -EINVAL;\n\treturn ctx->teedev->desc->ops->close_session(ctx, session);\n}\nEXPORT_SYMBOL_GPL(tee_client_close_session);\n\nint tee_client_invoke_func(struct tee_context *ctx,\n\t\t\t   struct tee_ioctl_invoke_arg *arg,\n\t\t\t   struct tee_param *param)\n{\n\tif (!ctx->teedev->desc->ops->invoke_func)\n\t\treturn -EINVAL;\n\treturn ctx->teedev->desc->ops->invoke_func(ctx, arg, param);\n}\nEXPORT_SYMBOL_GPL(tee_client_invoke_func);\n\nint tee_client_cancel_req(struct tee_context *ctx,\n\t\t\t  struct tee_ioctl_cancel_arg *arg)\n{\n\tif (!ctx->teedev->desc->ops->cancel_req)\n\t\treturn -EINVAL;\n\treturn ctx->teedev->desc->ops->cancel_req(ctx, arg->cancel_id,\n\t\t\t\t\t\t  arg->session);\n}\n\nstatic int tee_client_device_match(struct device *dev,\n\t\t\t\t   struct device_driver *drv)\n{\n\tconst struct tee_client_device_id *id_table;\n\tstruct tee_client_device *tee_device;\n\n\tid_table = to_tee_client_driver(drv)->id_table;\n\ttee_device = to_tee_client_device(dev);\n\n\twhile (!uuid_is_null(&id_table->uuid)) {\n\t\tif (uuid_equal(&tee_device->id.uuid, &id_table->uuid))\n\t\t\treturn 1;\n\t\tid_table++;\n\t}\n\n\treturn 0;\n}\n\nstatic int tee_client_device_uevent(const struct device *dev,\n\t\t\t\t    struct kobj_uevent_env *env)\n{\n\tuuid_t *dev_id = &to_tee_client_device(dev)->id.uuid;\n\n\treturn add_uevent_var(env, \"MODALIAS=tee:%pUb\", dev_id);\n}\n\nstruct bus_type tee_bus_type = {\n\t.name\t\t= \"tee\",\n\t.match\t\t= tee_client_device_match,\n\t.uevent\t\t= tee_client_device_uevent,\n};\nEXPORT_SYMBOL_GPL(tee_bus_type);\n\nstatic int __init tee_init(void)\n{\n\tint rc;\n\n\ttee_class = class_create(\"tee\");\n\tif (IS_ERR(tee_class)) {\n\t\tpr_err(\"couldn't create class\\n\");\n\t\treturn PTR_ERR(tee_class);\n\t}\n\n\trc = alloc_chrdev_region(&tee_devt, 0, TEE_NUM_DEVICES, \"tee\");\n\tif (rc) {\n\t\tpr_err(\"failed to allocate char dev region\\n\");\n\t\tgoto out_unreg_class;\n\t}\n\n\trc = bus_register(&tee_bus_type);\n\tif (rc) {\n\t\tpr_err(\"failed to register tee bus\\n\");\n\t\tgoto out_unreg_chrdev;\n\t}\n\n\treturn 0;\n\nout_unreg_chrdev:\n\tunregister_chrdev_region(tee_devt, TEE_NUM_DEVICES);\nout_unreg_class:\n\tclass_destroy(tee_class);\n\ttee_class = NULL;\n\n\treturn rc;\n}\n\nstatic void __exit tee_exit(void)\n{\n\tbus_unregister(&tee_bus_type);\n\tunregister_chrdev_region(tee_devt, TEE_NUM_DEVICES);\n\tclass_destroy(tee_class);\n\ttee_class = NULL;\n}\n\nsubsys_initcall(tee_init);\nmodule_exit(tee_exit);\n\nMODULE_AUTHOR(\"Linaro\");\nMODULE_DESCRIPTION(\"TEE Driver\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}