{
  "module_name": "clk-highbank.c",
  "hash_id": "6d6f3311a55a4e094a84171357e4306bceb0339185ccf94f53f50897c2fc7816",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-highbank.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n#define HB_PLL_LOCK_500\t\t0x20000000\n#define HB_PLL_LOCK\t\t0x10000000\n#define HB_PLL_DIVF_SHIFT\t20\n#define HB_PLL_DIVF_MASK\t0x0ff00000\n#define HB_PLL_DIVQ_SHIFT\t16\n#define HB_PLL_DIVQ_MASK\t0x00070000\n#define HB_PLL_DIVR_SHIFT\t8\n#define HB_PLL_DIVR_MASK\t0x00001f00\n#define HB_PLL_RANGE_SHIFT\t4\n#define HB_PLL_RANGE_MASK\t0x00000070\n#define HB_PLL_BYPASS\t\t0x00000008\n#define HB_PLL_RESET\t\t0x00000004\n#define HB_PLL_EXT_BYPASS\t0x00000002\n#define HB_PLL_EXT_ENA\t\t0x00000001\n\n#define HB_PLL_VCO_MIN_FREQ\t2133000000\n#define HB_PLL_MAX_FREQ\t\tHB_PLL_VCO_MIN_FREQ\n#define HB_PLL_MIN_FREQ\t\t(HB_PLL_VCO_MIN_FREQ / 64)\n\n#define HB_A9_BCLK_DIV_MASK\t0x00000006\n#define HB_A9_BCLK_DIV_SHIFT\t1\n#define HB_A9_PCLK_DIV\t\t0x00000001\n\nstruct hb_clk {\n        struct clk_hw\thw;\n\tvoid __iomem\t*reg;\n\tchar *parent_name;\n};\n#define to_hb_clk(p) container_of(p, struct hb_clk, hw)\n\nstatic int clk_pll_prepare(struct clk_hw *hwclk)\n\t{\n\tstruct hb_clk *hbclk = to_hb_clk(hwclk);\n\tu32 reg;\n\n\treg = readl(hbclk->reg);\n\treg &= ~HB_PLL_RESET;\n\twritel(reg, hbclk->reg);\n\n\twhile ((readl(hbclk->reg) & HB_PLL_LOCK) == 0)\n\t\t;\n\twhile ((readl(hbclk->reg) & HB_PLL_LOCK_500) == 0)\n\t\t;\n\n\treturn 0;\n}\n\nstatic void clk_pll_unprepare(struct clk_hw *hwclk)\n{\n\tstruct hb_clk *hbclk = to_hb_clk(hwclk);\n\tu32 reg;\n\n\treg = readl(hbclk->reg);\n\treg |= HB_PLL_RESET;\n\twritel(reg, hbclk->reg);\n}\n\nstatic int clk_pll_enable(struct clk_hw *hwclk)\n{\n\tstruct hb_clk *hbclk = to_hb_clk(hwclk);\n\tu32 reg;\n\n\treg = readl(hbclk->reg);\n\treg |= HB_PLL_EXT_ENA;\n\twritel(reg, hbclk->reg);\n\n\treturn 0;\n}\n\nstatic void clk_pll_disable(struct clk_hw *hwclk)\n{\n\tstruct hb_clk *hbclk = to_hb_clk(hwclk);\n\tu32 reg;\n\n\treg = readl(hbclk->reg);\n\treg &= ~HB_PLL_EXT_ENA;\n\twritel(reg, hbclk->reg);\n}\n\nstatic unsigned long clk_pll_recalc_rate(struct clk_hw *hwclk,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct hb_clk *hbclk = to_hb_clk(hwclk);\n\tunsigned long divf, divq, vco_freq, reg;\n\n\treg = readl(hbclk->reg);\n\tif (reg & HB_PLL_EXT_BYPASS)\n\t\treturn parent_rate;\n\n\tdivf = (reg & HB_PLL_DIVF_MASK) >> HB_PLL_DIVF_SHIFT;\n\tdivq = (reg & HB_PLL_DIVQ_MASK) >> HB_PLL_DIVQ_SHIFT;\n\tvco_freq = parent_rate * (divf + 1);\n\n\treturn vco_freq / (1 << divq);\n}\n\nstatic void clk_pll_calc(unsigned long rate, unsigned long ref_freq,\n\t\t\tu32 *pdivq, u32 *pdivf)\n{\n\tu32 divq, divf;\n\tunsigned long vco_freq;\n\n\tif (rate < HB_PLL_MIN_FREQ)\n\t\trate = HB_PLL_MIN_FREQ;\n\tif (rate > HB_PLL_MAX_FREQ)\n\t\trate = HB_PLL_MAX_FREQ;\n\n\tfor (divq = 1; divq <= 6; divq++) {\n\t\tif ((rate * (1 << divq)) >= HB_PLL_VCO_MIN_FREQ)\n\t\t\tbreak;\n\t}\n\n\tvco_freq = rate * (1 << divq);\n\tdivf = (vco_freq + (ref_freq / 2)) / ref_freq;\n\tdivf--;\n\n\t*pdivq = divq;\n\t*pdivf = divf;\n}\n\nstatic long clk_pll_round_rate(struct clk_hw *hwclk, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\tu32 divq, divf;\n\tunsigned long ref_freq = *parent_rate;\n\n\tclk_pll_calc(rate, ref_freq, &divq, &divf);\n\n\treturn (ref_freq * (divf + 1)) / (1 << divq);\n}\n\nstatic int clk_pll_set_rate(struct clk_hw *hwclk, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct hb_clk *hbclk = to_hb_clk(hwclk);\n\tu32 divq, divf;\n\tu32 reg;\n\n\tclk_pll_calc(rate, parent_rate, &divq, &divf);\n\n\treg = readl(hbclk->reg);\n\tif (divf != ((reg & HB_PLL_DIVF_MASK) >> HB_PLL_DIVF_SHIFT)) {\n\t\t \n\t\treg |= HB_PLL_EXT_BYPASS;\n\t\twritel(reg | HB_PLL_EXT_BYPASS, hbclk->reg);\n\n\t\twritel(reg | HB_PLL_RESET, hbclk->reg);\n\t\treg &= ~(HB_PLL_DIVF_MASK | HB_PLL_DIVQ_MASK);\n\t\treg |= (divf << HB_PLL_DIVF_SHIFT) | (divq << HB_PLL_DIVQ_SHIFT);\n\t\twritel(reg | HB_PLL_RESET, hbclk->reg);\n\t\twritel(reg, hbclk->reg);\n\n\t\twhile ((readl(hbclk->reg) & HB_PLL_LOCK) == 0)\n\t\t\t;\n\t\twhile ((readl(hbclk->reg) & HB_PLL_LOCK_500) == 0)\n\t\t\t;\n\t\treg |= HB_PLL_EXT_ENA;\n\t\treg &= ~HB_PLL_EXT_BYPASS;\n\t} else {\n\t\twritel(reg | HB_PLL_EXT_BYPASS, hbclk->reg);\n\t\treg &= ~HB_PLL_DIVQ_MASK;\n\t\treg |= divq << HB_PLL_DIVQ_SHIFT;\n\t\twritel(reg | HB_PLL_EXT_BYPASS, hbclk->reg);\n\t}\n\twritel(reg, hbclk->reg);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_pll_ops = {\n\t.prepare = clk_pll_prepare,\n\t.unprepare = clk_pll_unprepare,\n\t.enable = clk_pll_enable,\n\t.disable = clk_pll_disable,\n\t.recalc_rate = clk_pll_recalc_rate,\n\t.round_rate = clk_pll_round_rate,\n\t.set_rate = clk_pll_set_rate,\n};\n\nstatic unsigned long clk_cpu_periphclk_recalc_rate(struct clk_hw *hwclk,\n\t\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct hb_clk *hbclk = to_hb_clk(hwclk);\n\tu32 div = (readl(hbclk->reg) & HB_A9_PCLK_DIV) ? 8 : 4;\n\treturn parent_rate / div;\n}\n\nstatic const struct clk_ops a9periphclk_ops = {\n\t.recalc_rate = clk_cpu_periphclk_recalc_rate,\n};\n\nstatic unsigned long clk_cpu_a9bclk_recalc_rate(struct clk_hw *hwclk,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct hb_clk *hbclk = to_hb_clk(hwclk);\n\tu32 div = (readl(hbclk->reg) & HB_A9_BCLK_DIV_MASK) >> HB_A9_BCLK_DIV_SHIFT;\n\n\treturn parent_rate / (div + 2);\n}\n\nstatic const struct clk_ops a9bclk_ops = {\n\t.recalc_rate = clk_cpu_a9bclk_recalc_rate,\n};\n\nstatic unsigned long clk_periclk_recalc_rate(struct clk_hw *hwclk,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct hb_clk *hbclk = to_hb_clk(hwclk);\n\tu32 div;\n\n\tdiv = readl(hbclk->reg) & 0x1f;\n\tdiv++;\n\tdiv *= 2;\n\n\treturn parent_rate / div;\n}\n\nstatic long clk_periclk_round_rate(struct clk_hw *hwclk, unsigned long rate,\n\t\t\t\t   unsigned long *parent_rate)\n{\n\tu32 div;\n\n\tdiv = *parent_rate / rate;\n\tdiv++;\n\tdiv &= ~0x1;\n\n\treturn *parent_rate / div;\n}\n\nstatic int clk_periclk_set_rate(struct clk_hw *hwclk, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct hb_clk *hbclk = to_hb_clk(hwclk);\n\tu32 div;\n\n\tdiv = parent_rate / rate;\n\tif (div & 0x1)\n\t\treturn -EINVAL;\n\n\twritel(div >> 1, hbclk->reg);\n\treturn 0;\n}\n\nstatic const struct clk_ops periclk_ops = {\n\t.recalc_rate = clk_periclk_recalc_rate,\n\t.round_rate = clk_periclk_round_rate,\n\t.set_rate = clk_periclk_set_rate,\n};\n\nstatic void __init hb_clk_init(struct device_node *node, const struct clk_ops *ops, unsigned long clkflags)\n{\n\tu32 reg;\n\tstruct hb_clk *hb_clk;\n\tconst char *clk_name = node->name;\n\tconst char *parent_name;\n\tstruct clk_init_data init;\n\tstruct device_node *srnp;\n\tint rc;\n\n\trc = of_property_read_u32(node, \"reg\", &reg);\n\tif (WARN_ON(rc))\n\t\treturn;\n\n\thb_clk = kzalloc(sizeof(*hb_clk), GFP_KERNEL);\n\tif (WARN_ON(!hb_clk))\n\t\treturn;\n\n\t \n\tsrnp = of_find_compatible_node(NULL, NULL, \"calxeda,hb-sregs\");\n\thb_clk->reg = of_iomap(srnp, 0);\n\tof_node_put(srnp);\n\tBUG_ON(!hb_clk->reg);\n\thb_clk->reg += reg;\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\n\tinit.name = clk_name;\n\tinit.ops = ops;\n\tinit.flags = clkflags;\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\thb_clk->hw.init = &init;\n\n\trc = clk_hw_register(NULL, &hb_clk->hw);\n\tif (WARN_ON(rc)) {\n\t\tkfree(hb_clk);\n\t\treturn;\n\t}\n\tof_clk_add_hw_provider(node, of_clk_hw_simple_get, &hb_clk->hw);\n}\n\nstatic void __init hb_pll_init(struct device_node *node)\n{\n\thb_clk_init(node, &clk_pll_ops, 0);\n}\nCLK_OF_DECLARE(hb_pll, \"calxeda,hb-pll-clock\", hb_pll_init);\n\nstatic void __init hb_a9periph_init(struct device_node *node)\n{\n\thb_clk_init(node, &a9periphclk_ops, 0);\n}\nCLK_OF_DECLARE(hb_a9periph, \"calxeda,hb-a9periph-clock\", hb_a9periph_init);\n\nstatic void __init hb_a9bus_init(struct device_node *node)\n{\n\thb_clk_init(node, &a9bclk_ops, CLK_IS_CRITICAL);\n}\nCLK_OF_DECLARE(hb_a9bus, \"calxeda,hb-a9bus-clock\", hb_a9bus_init);\n\nstatic void __init hb_emmc_init(struct device_node *node)\n{\n\thb_clk_init(node, &periclk_ops, 0);\n}\nCLK_OF_DECLARE(hb_emmc, \"calxeda,hb-emmc-clock\", hb_emmc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}