{
  "module_name": "wrpll-cln28hpc.c",
  "hash_id": "cc0b46ee9b2d44772c4d7fe703558abc27e4714ebd7fee8533b319cebc4bdd0c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/analogbits/wrpll-cln28hpc.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/err.h>\n#include <linux/limits.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/math.h>\n#include <linux/minmax.h>\n\n#include <linux/clk/analogbits-wrpll-cln28hpc.h>\n\n \n#define MIN_INPUT_FREQ\t\t\t7000000\n\n \n#define MAX_INPUT_FREQ\t\t\t600000000\n\n \n#define MIN_POST_DIVR_FREQ\t\t7000000\n\n \n#define MAX_POST_DIVR_FREQ\t\t200000000\n\n \n#define MIN_VCO_FREQ\t\t\t2400000000UL\n\n \n#define MAX_VCO_FREQ\t\t\t4800000000ULL\n\n \n#define MAX_DIVQ_DIVISOR\t\t64\n\n \n#define MAX_DIVR_DIVISOR\t\t64\n\n \n#define MAX_LOCK_US\t\t\t70\n\n \n#define ROUND_SHIFT\t\t\t20\n\n \n\n \nstatic int __wrpll_calc_filter_range(unsigned long post_divr_freq)\n{\n\tif (post_divr_freq < MIN_POST_DIVR_FREQ ||\n\t    post_divr_freq > MAX_POST_DIVR_FREQ) {\n\t\tWARN(1, \"%s: post-divider reference freq out of range: %lu\",\n\t\t     __func__, post_divr_freq);\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (post_divr_freq) {\n\tcase 0 ... 10999999:\n\t\treturn 1;\n\tcase 11000000 ... 17999999:\n\t\treturn 2;\n\tcase 18000000 ... 29999999:\n\t\treturn 3;\n\tcase 30000000 ... 49999999:\n\t\treturn 4;\n\tcase 50000000 ... 79999999:\n\t\treturn 5;\n\tcase 80000000 ... 129999999:\n\t\treturn 6;\n\t}\n\n\treturn 7;\n}\n\n \nstatic u8 __wrpll_calc_fbdiv(const struct wrpll_cfg *c)\n{\n\treturn (c->flags & WRPLL_FLAGS_INT_FEEDBACK_MASK) ? 2 : 1;\n}\n\n \nstatic u8 __wrpll_calc_divq(u32 target_rate, u64 *vco_rate)\n{\n\tu64 s;\n\tu8 divq = 0;\n\n\tif (!vco_rate) {\n\t\tWARN_ON(1);\n\t\tgoto wcd_out;\n\t}\n\n\ts = div_u64(MAX_VCO_FREQ, target_rate);\n\tif (s <= 1) {\n\t\tdivq = 1;\n\t\t*vco_rate = MAX_VCO_FREQ;\n\t} else if (s > MAX_DIVQ_DIVISOR) {\n\t\tdivq = ilog2(MAX_DIVQ_DIVISOR);\n\t\t*vco_rate = MIN_VCO_FREQ;\n\t} else {\n\t\tdivq = ilog2(s);\n\t\t*vco_rate = (u64)target_rate << divq;\n\t}\n\nwcd_out:\n\treturn divq;\n}\n\n \nstatic int __wrpll_update_parent_rate(struct wrpll_cfg *c,\n\t\t\t\t      unsigned long parent_rate)\n{\n\tu8 max_r_for_parent;\n\n\tif (parent_rate > MAX_INPUT_FREQ || parent_rate < MIN_POST_DIVR_FREQ)\n\t\treturn -ERANGE;\n\n\tc->parent_rate = parent_rate;\n\tmax_r_for_parent = div_u64(parent_rate, MIN_POST_DIVR_FREQ);\n\tc->max_r = min_t(u8, MAX_DIVR_DIVISOR, max_r_for_parent);\n\n\tc->init_r = DIV_ROUND_UP_ULL(parent_rate, MAX_POST_DIVR_FREQ);\n\n\treturn 0;\n}\n\n \nint wrpll_configure_for_rate(struct wrpll_cfg *c, u32 target_rate,\n\t\t\t     unsigned long parent_rate)\n{\n\tunsigned long ratio;\n\tu64 target_vco_rate, delta, best_delta, f_pre_div, vco, vco_pre;\n\tu32 best_f, f, post_divr_freq;\n\tu8 fbdiv, divq, best_r, r;\n\tint range;\n\n\tif (c->flags == 0) {\n\t\tWARN(1, \"%s called with uninitialized PLL config\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (parent_rate != c->parent_rate) {\n\t\tif (__wrpll_update_parent_rate(c, parent_rate)) {\n\t\t\tpr_err(\"%s: PLL input rate is out of range\\n\",\n\t\t\t       __func__);\n\t\t\treturn -ERANGE;\n\t\t}\n\t}\n\n\tc->flags &= ~WRPLL_FLAGS_RESET_MASK;\n\n\t \n\tif (target_rate == parent_rate) {\n\t\tc->flags |= WRPLL_FLAGS_BYPASS_MASK;\n\t\treturn 0;\n\t}\n\n\tc->flags &= ~WRPLL_FLAGS_BYPASS_MASK;\n\n\t \n\tdivq = __wrpll_calc_divq(target_rate, &target_vco_rate);\n\tif (!divq)\n\t\treturn -1;\n\tc->divq = divq;\n\n\t \n\tratio = div64_u64((target_vco_rate << ROUND_SHIFT), parent_rate);\n\n\tfbdiv = __wrpll_calc_fbdiv(c);\n\tbest_r = 0;\n\tbest_f = 0;\n\tbest_delta = MAX_VCO_FREQ;\n\n\t \n\tfor (r = c->init_r; r <= c->max_r; ++r) {\n\t\tf_pre_div = ratio * r;\n\t\tf = (f_pre_div + (1 << ROUND_SHIFT)) >> ROUND_SHIFT;\n\t\tf >>= (fbdiv - 1);\n\n\t\tpost_divr_freq = div_u64(parent_rate, r);\n\t\tvco_pre = fbdiv * post_divr_freq;\n\t\tvco = vco_pre * f;\n\n\t\t \n\t\tif (vco > target_vco_rate) {\n\t\t\t--f;\n\t\t\tvco = vco_pre * f;\n\t\t} else if (vco < MIN_VCO_FREQ) {\n\t\t\t++f;\n\t\t\tvco = vco_pre * f;\n\t\t}\n\n\t\tdelta = abs(target_rate - vco);\n\t\tif (delta < best_delta) {\n\t\t\tbest_delta = delta;\n\t\t\tbest_r = r;\n\t\t\tbest_f = f;\n\t\t}\n\t}\n\n\tc->divr = best_r - 1;\n\tc->divf = best_f - 1;\n\n\tpost_divr_freq = div_u64(parent_rate, best_r);\n\n\t \n\trange = __wrpll_calc_filter_range(post_divr_freq);\n\tif (range < 0)\n\t\treturn range;\n\tc->range = range;\n\n\treturn 0;\n}\n\n \nunsigned long wrpll_calc_output_rate(const struct wrpll_cfg *c,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tu8 fbdiv;\n\tu64 n;\n\n\tif (c->flags & WRPLL_FLAGS_EXT_FEEDBACK_MASK) {\n\t\tWARN(1, \"external feedback mode not yet supported\");\n\t\treturn ULONG_MAX;\n\t}\n\n\tfbdiv = __wrpll_calc_fbdiv(c);\n\tn = parent_rate * fbdiv * (c->divf + 1);\n\tn = div_u64(n, c->divr + 1);\n\tn >>= c->divq;\n\n\treturn n;\n}\n\n \nunsigned int wrpll_calc_max_lock_us(const struct wrpll_cfg *c)\n{\n\treturn MAX_LOCK_US;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}