{
  "module_name": "clk-vt8500.c",
  "hash_id": "429245867785a37a74504debb8964cc6aa4eafbe4941e4eb4fc725ecc577f396",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-vt8500.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n\n#define LEGACY_PMC_BASE\t\t0xD8130000\n\n \nstatic DEFINE_SPINLOCK(_lock);\n\nstruct clk_device {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*div_reg;\n\tunsigned int\tdiv_mask;\n\tvoid __iomem\t*en_reg;\n\tint\t\ten_bit;\n\tspinlock_t\t*lock;\n};\n\n \n\n#define PLL_TYPE_VT8500\t\t0\n#define PLL_TYPE_WM8650\t\t1\n#define PLL_TYPE_WM8750\t\t2\n#define PLL_TYPE_WM8850\t\t3\n\nstruct clk_pll {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*reg;\n\tspinlock_t\t*lock;\n\tint\t\ttype;\n};\n\nstatic void __iomem *pmc_base;\n\nstatic __init void vtwm_set_pmc_base(void)\n{\n\tstruct device_node *np =\n\t\tof_find_compatible_node(NULL, NULL, \"via,vt8500-pmc\");\n\n\tif (np)\n\t\tpmc_base = of_iomap(np, 0);\n\telse\n\t\tpmc_base = ioremap(LEGACY_PMC_BASE, 0x1000);\n\tof_node_put(np);\n\n\tif (!pmc_base)\n\t\tpr_err(\"%s:of_iomap(pmc) failed\\n\", __func__);\n}\n\n#define to_clk_device(_hw) container_of(_hw, struct clk_device, hw)\n\n#define VT8500_PMC_BUSY_MASK\t\t0x18\n\nstatic void vt8500_pmc_wait_busy(void)\n{\n\twhile (readl(pmc_base) & VT8500_PMC_BUSY_MASK)\n\t\tcpu_relax();\n}\n\nstatic int vt8500_dclk_enable(struct clk_hw *hw)\n{\n\tstruct clk_device *cdev = to_clk_device(hw);\n\tu32 en_val;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(cdev->lock, flags);\n\n\ten_val = readl(cdev->en_reg);\n\ten_val |= BIT(cdev->en_bit);\n\twritel(en_val, cdev->en_reg);\n\n\tspin_unlock_irqrestore(cdev->lock, flags);\n\treturn 0;\n}\n\nstatic void vt8500_dclk_disable(struct clk_hw *hw)\n{\n\tstruct clk_device *cdev = to_clk_device(hw);\n\tu32 en_val;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(cdev->lock, flags);\n\n\ten_val = readl(cdev->en_reg);\n\ten_val &= ~BIT(cdev->en_bit);\n\twritel(en_val, cdev->en_reg);\n\n\tspin_unlock_irqrestore(cdev->lock, flags);\n}\n\nstatic int vt8500_dclk_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_device *cdev = to_clk_device(hw);\n\tu32 en_val = (readl(cdev->en_reg) & BIT(cdev->en_bit));\n\n\treturn en_val ? 1 : 0;\n}\n\nstatic unsigned long vt8500_dclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_device *cdev = to_clk_device(hw);\n\tu32 div = readl(cdev->div_reg) & cdev->div_mask;\n\n\t \n\tif ((cdev->div_mask == 0x3F) && (div & BIT(5)))\n\t\tdiv = 64 * (div & 0x1f);\n\n\t \n\tif (div == 0)\n\t\tdiv = (cdev->div_mask + 1);\n\n\treturn parent_rate / div;\n}\n\nstatic long vt8500_dclk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *prate)\n{\n\tstruct clk_device *cdev = to_clk_device(hw);\n\tu32 divisor;\n\n\tif (rate == 0)\n\t\treturn 0;\n\n\tdivisor = *prate / rate;\n\n\t \n\tif (rate * divisor < *prate)\n\t\tdivisor++;\n\n\t \n\tif ((cdev->div_mask == 0x3F) && (divisor > 31)) {\n\t\tdivisor = 64 * ((divisor / 64) + 1);\n\t}\n\n\treturn *prate / divisor;\n}\n\nstatic int vt8500_dclk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_device *cdev = to_clk_device(hw);\n\tu32 divisor;\n\tunsigned long flags = 0;\n\n\tif (rate == 0)\n\t\treturn 0;\n\n\tdivisor =  parent_rate / rate;\n\n\tif (divisor == cdev->div_mask + 1)\n\t\tdivisor = 0;\n\n\t \n\tif ((cdev->div_mask == 0x3F) && (divisor > 31)) {\n\t\t \n\t\tdivisor = 0x20 + (divisor / 64);\n\t}\n\n\tif (divisor > cdev->div_mask) {\n\t\tpr_err(\"%s: invalid divisor for clock\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(cdev->lock, flags);\n\n\tvt8500_pmc_wait_busy();\n\twritel(divisor, cdev->div_reg);\n\tvt8500_pmc_wait_busy();\n\n\tspin_unlock_irqrestore(cdev->lock, flags);\n\n\treturn 0;\n}\n\n\nstatic const struct clk_ops vt8500_gated_clk_ops = {\n\t.enable = vt8500_dclk_enable,\n\t.disable = vt8500_dclk_disable,\n\t.is_enabled = vt8500_dclk_is_enabled,\n};\n\nstatic const struct clk_ops vt8500_divisor_clk_ops = {\n\t.round_rate = vt8500_dclk_round_rate,\n\t.set_rate = vt8500_dclk_set_rate,\n\t.recalc_rate = vt8500_dclk_recalc_rate,\n};\n\nstatic const struct clk_ops vt8500_gated_divisor_clk_ops = {\n\t.enable = vt8500_dclk_enable,\n\t.disable = vt8500_dclk_disable,\n\t.is_enabled = vt8500_dclk_is_enabled,\n\t.round_rate = vt8500_dclk_round_rate,\n\t.set_rate = vt8500_dclk_set_rate,\n\t.recalc_rate = vt8500_dclk_recalc_rate,\n};\n\n#define CLK_INIT_GATED\t\t\tBIT(0)\n#define CLK_INIT_DIVISOR\t\tBIT(1)\n#define CLK_INIT_GATED_DIVISOR\t\t(CLK_INIT_DIVISOR | CLK_INIT_GATED)\n\nstatic __init void vtwm_device_clk_init(struct device_node *node)\n{\n\tu32 en_reg, div_reg;\n\tstruct clk_hw *hw;\n\tstruct clk_device *dev_clk;\n\tconst char *clk_name = node->name;\n\tconst char *parent_name;\n\tstruct clk_init_data init;\n\tint rc;\n\tint clk_init_flags = 0;\n\n\tif (!pmc_base)\n\t\tvtwm_set_pmc_base();\n\n\tdev_clk = kzalloc(sizeof(*dev_clk), GFP_KERNEL);\n\tif (WARN_ON(!dev_clk))\n\t\treturn;\n\n\tdev_clk->lock = &_lock;\n\n\trc = of_property_read_u32(node, \"enable-reg\", &en_reg);\n\tif (!rc) {\n\t\tdev_clk->en_reg = pmc_base + en_reg;\n\t\trc = of_property_read_u32(node, \"enable-bit\", &dev_clk->en_bit);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: enable-bit property required for gated clock\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\t\treturn;\n\t\t}\n\t\tclk_init_flags |= CLK_INIT_GATED;\n\t}\n\n\trc = of_property_read_u32(node, \"divisor-reg\", &div_reg);\n\tif (!rc) {\n\t\tdev_clk->div_reg = pmc_base + div_reg;\n\t\t \n\t\tdev_clk->div_mask = 0x1f;\n\n\t\tof_property_read_u32(node, \"divisor-mask\", &dev_clk->div_mask);\n\t\tclk_init_flags |= CLK_INIT_DIVISOR;\n\t}\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\n\tswitch (clk_init_flags) {\n\tcase CLK_INIT_GATED:\n\t\tinit.ops = &vt8500_gated_clk_ops;\n\t\tbreak;\n\tcase CLK_INIT_DIVISOR:\n\t\tinit.ops = &vt8500_divisor_clk_ops;\n\t\tbreak;\n\tcase CLK_INIT_GATED_DIVISOR:\n\t\tinit.ops = &vt8500_gated_divisor_clk_ops;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: Invalid clock description in device tree\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\tkfree(dev_clk);\n\t\treturn;\n\t}\n\n\tinit.name = clk_name;\n\tinit.flags = 0;\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tdev_clk->hw.init = &init;\n\n\thw = &dev_clk->hw;\n\trc = clk_hw_register(NULL, hw);\n\tif (WARN_ON(rc)) {\n\t\tkfree(dev_clk);\n\t\treturn;\n\t}\n\trc = of_clk_add_hw_provider(node, of_clk_hw_simple_get, hw);\n\tclk_hw_register_clkdev(hw, clk_name, NULL);\n}\nCLK_OF_DECLARE(vt8500_device, \"via,vt8500-device-clock\", vtwm_device_clk_init);\n\n \n\n#define to_clk_pll(_hw) container_of(_hw, struct clk_pll, hw)\n\n \n#define VT8500_PLL_MUL(x)\t((x & 0x1F) << 1)\n#define VT8500_PLL_DIV(x)\t((x & 0x100) ? 1 : 2)\n\n#define VT8500_BITS_TO_FREQ(r, m, d)\t\t\t\t\t\\\n\t\t\t\t((r / d) * m)\n\n#define VT8500_BITS_TO_VAL(m, d)\t\t\t\t\t\\\n\t\t\t\t((d == 2 ? 0 : 0x100) | ((m >> 1) & 0x1F))\n\n \n#define WM8650_PLL_MUL(x)\t(x & 0x3FF)\n#define WM8650_PLL_DIV(x)\t(((x >> 10) & 7) * (1 << ((x >> 13) & 3)))\n\n#define WM8650_BITS_TO_FREQ(r, m, d1, d2)\t\t\t\t\\\n\t\t\t\t(r * m / (d1 * (1 << d2)))\n\n#define WM8650_BITS_TO_VAL(m, d1, d2)\t\t\t\t\t\\\n\t\t\t\t((d2 << 13) | (d1 << 10) | (m & 0x3FF))\n\n \n#define WM8750_PLL_MUL(x)\t(((x >> 16) & 0xFF) + 1)\n#define WM8750_PLL_DIV(x)\t((((x >> 8) & 1) + 1) * (1 << (x & 7)))\n\n#define WM8750_BITS_TO_FREQ(r, m, d1, d2)\t\t\t\t\\\n\t\t\t\t(r * (m+1) / ((d1+1) * (1 << d2)))\n\n#define WM8750_BITS_TO_VAL(f, m, d1, d2)\t\t\t\t\\\n\t\t((f << 24) | ((m - 1) << 16) | ((d1 - 1) << 8) | d2)\n\n \n#define WM8850_PLL_MUL(x)\t((((x >> 16) & 0x7F) + 1) * 2)\n#define WM8850_PLL_DIV(x)\t((((x >> 8) & 1) + 1) * (1 << (x & 3)))\n\n#define WM8850_BITS_TO_FREQ(r, m, d1, d2)\t\t\t\t\\\n\t\t\t\t(r * ((m + 1) * 2) / ((d1+1) * (1 << d2)))\n\n#define WM8850_BITS_TO_VAL(m, d1, d2)\t\t\t\t\t\\\n\t\t((((m / 2) - 1) << 16) | ((d1 - 1) << 8) | d2)\n\nstatic int vt8500_find_pll_bits(unsigned long rate, unsigned long parent_rate,\n\t\t\t\tu32 *multiplier, u32 *prediv)\n{\n\tunsigned long tclk;\n\n\t \n\tif ((rate < parent_rate * 4) || (rate > parent_rate * 62)) {\n\t\tpr_err(\"%s: requested rate out of range\\n\", __func__);\n\t\t*multiplier = 0;\n\t\t*prediv = 1;\n\t\treturn -EINVAL;\n\t}\n\tif (rate <= parent_rate * 31)\n\t\t \n\t\t*prediv = 2;\n\telse\n\t\t*prediv = 1;\n\n\t*multiplier = rate / (parent_rate / *prediv);\n\ttclk = (parent_rate / *prediv) * *multiplier;\n\n\tif (tclk != rate)\n\t\tpr_warn(\"%s: requested rate %lu, found rate %lu\\n\", __func__,\n\t\t\t\t\t\t\t\trate, tclk);\n\n\treturn 0;\n}\n\n \nstatic int wm8650_find_pll_bits(unsigned long rate,\n\tunsigned long parent_rate, u32 *multiplier, u32 *divisor1,\n\tu32 *divisor2)\n{\n\tunsigned long O1, min_err, rate_err;\n\n\tif (!parent_rate || (rate < 37500000) || (rate > 600000000))\n\t\treturn -EINVAL;\n\n\t*divisor2 = rate <= 75000000 ? 3 : rate <= 150000000 ? 2 :\n\t\t\t\t\t   rate <= 300000000 ? 1 : 0;\n\t \n\tmin_err = ULONG_MAX;\n\tfor (*divisor1 = 5; *divisor1 >= 3; (*divisor1)--) {\n\t\tO1 = rate * *divisor1 * (1 << (*divisor2));\n\t\trate_err = O1 % parent_rate;\n\t\tif (rate_err < min_err) {\n\t\t\t*multiplier = O1 / parent_rate;\n\t\t\tif (rate_err == 0)\n\t\t\t\treturn 0;\n\n\t\t\tmin_err = rate_err;\n\t\t}\n\t}\n\n\tif ((*multiplier < 3) || (*multiplier > 1023))\n\t\treturn -EINVAL;\n\n\tpr_warn(\"%s: rate error is %lu\\n\", __func__, min_err);\n\n\treturn 0;\n}\n\nstatic u32 wm8750_get_filter(u32 parent_rate, u32 divisor1)\n{\n\t \n\tu32 freq = (parent_rate / 1000000) / (divisor1 + 1);\n\n\tif ((freq < 10) || (freq > 200))\n\t\tpr_warn(\"%s: PLL recommended input frequency 10..200Mhz (requested %d Mhz)\\n\",\n\t\t\t\t__func__, freq);\n\n\tif (freq >= 166)\n\t\treturn 7;\n\telse if (freq >= 104)\n\t\treturn 6;\n\telse if (freq >= 65)\n\t\treturn 5;\n\telse if (freq >= 42)\n\t\treturn 4;\n\telse if (freq >= 26)\n\t\treturn 3;\n\telse if (freq >= 16)\n\t\treturn 2;\n\telse if (freq >= 10)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int wm8750_find_pll_bits(unsigned long rate, unsigned long parent_rate,\n\t\t\t\tu32 *filter, u32 *multiplier, u32 *divisor1, u32 *divisor2)\n{\n\tu32 mul;\n\tint div1, div2;\n\tunsigned long tclk, rate_err, best_err;\n\n\tbest_err = (unsigned long)-1;\n\n\t \n\tfor (div1 = 1; div1 >= 0; div1--)\n\t\tfor (div2 = 7; div2 >= 0; div2--)\n\t\t\tfor (mul = 0; mul <= 255; mul++) {\n\t\t\t\ttclk = parent_rate * (mul + 1) / ((div1 + 1) * (1 << div2));\n\t\t\t\tif (tclk > rate)\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\trate_err = rate - tclk;\n\t\t\t\tif (rate_err == 0) {\n\t\t\t\t\t*filter = wm8750_get_filter(parent_rate, div1);\n\t\t\t\t\t*multiplier = mul;\n\t\t\t\t\t*divisor1 = div1;\n\t\t\t\t\t*divisor2 = div2;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tif (rate_err < best_err) {\n\t\t\t\t\tbest_err = rate_err;\n\t\t\t\t\t*multiplier = mul;\n\t\t\t\t\t*divisor1 = div1;\n\t\t\t\t\t*divisor2 = div2;\n\t\t\t\t}\n\t\t\t}\n\n\tif (best_err == (unsigned long)-1) {\n\t\tpr_warn(\"%s: impossible rate %lu\\n\", __func__, rate);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpr_warn(\"%s: requested rate %lu, found rate %lu\\n\", __func__, rate,\n\t\t\t\t\t\t\trate - best_err);\n\n\t*filter = wm8750_get_filter(parent_rate, *divisor1);\n\n\treturn 0;\n}\n\nstatic int wm8850_find_pll_bits(unsigned long rate, unsigned long parent_rate,\n\t\t\t\tu32 *multiplier, u32 *divisor1, u32 *divisor2)\n{\n\tu32 mul;\n\tint div1, div2;\n\tunsigned long tclk, rate_err, best_err;\n\n\tbest_err = (unsigned long)-1;\n\n\t \n\tfor (div1 = 1; div1 >= 0; div1--)\n\t\tfor (div2 = 3; div2 >= 0; div2--)\n\t\t\tfor (mul = 0; mul <= 127; mul++) {\n\t\t\t\ttclk = parent_rate * ((mul + 1) * 2) /\n\t\t\t\t\t\t((div1 + 1) * (1 << div2));\n\t\t\t\tif (tclk > rate)\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\trate_err = rate - tclk;\n\t\t\t\tif (rate_err == 0) {\n\t\t\t\t\t*multiplier = mul;\n\t\t\t\t\t*divisor1 = div1;\n\t\t\t\t\t*divisor2 = div2;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tif (rate_err < best_err) {\n\t\t\t\t\tbest_err = rate_err;\n\t\t\t\t\t*multiplier = mul;\n\t\t\t\t\t*divisor1 = div1;\n\t\t\t\t\t*divisor2 = div2;\n\t\t\t\t}\n\t\t\t}\n\n\tif (best_err == (unsigned long)-1) {\n\t\tpr_warn(\"%s: impossible rate %lu\\n\", __func__, rate);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpr_warn(\"%s: requested rate %lu, found rate %lu\\n\", __func__, rate,\n\t\t\t\t\t\t\trate - best_err);\n\n\treturn 0;\n}\n\nstatic int vtwm_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tu32 filter, mul, div1, div2;\n\tu32 pll_val;\n\tunsigned long flags = 0;\n\tint ret;\n\n\t \n\n\tswitch (pll->type) {\n\tcase PLL_TYPE_VT8500:\n\t\tret = vt8500_find_pll_bits(rate, parent_rate, &mul, &div1);\n\t\tif (!ret)\n\t\t\tpll_val = VT8500_BITS_TO_VAL(mul, div1);\n\t\tbreak;\n\tcase PLL_TYPE_WM8650:\n\t\tret = wm8650_find_pll_bits(rate, parent_rate, &mul, &div1, &div2);\n\t\tif (!ret)\n\t\t\tpll_val = WM8650_BITS_TO_VAL(mul, div1, div2);\n\t\tbreak;\n\tcase PLL_TYPE_WM8750:\n\t\tret = wm8750_find_pll_bits(rate, parent_rate, &filter, &mul, &div1, &div2);\n\t\tif (!ret)\n\t\t\tpll_val = WM8750_BITS_TO_VAL(filter, mul, div1, div2);\n\t\tbreak;\n\tcase PLL_TYPE_WM8850:\n\t\tret = wm8850_find_pll_bits(rate, parent_rate, &mul, &div1, &div2);\n\t\tif (!ret)\n\t\t\tpll_val = WM8850_BITS_TO_VAL(mul, div1, div2);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: invalid pll type\\n\", __func__);\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(pll->lock, flags);\n\n\tvt8500_pmc_wait_busy();\n\twritel(pll_val, pll->reg);\n\tvt8500_pmc_wait_busy();\n\n\tspin_unlock_irqrestore(pll->lock, flags);\n\n\treturn 0;\n}\n\nstatic long vtwm_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *prate)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tu32 filter, mul, div1, div2;\n\tlong round_rate;\n\tint ret;\n\n\tswitch (pll->type) {\n\tcase PLL_TYPE_VT8500:\n\t\tret = vt8500_find_pll_bits(rate, *prate, &mul, &div1);\n\t\tif (!ret)\n\t\t\tround_rate = VT8500_BITS_TO_FREQ(*prate, mul, div1);\n\t\tbreak;\n\tcase PLL_TYPE_WM8650:\n\t\tret = wm8650_find_pll_bits(rate, *prate, &mul, &div1, &div2);\n\t\tif (!ret)\n\t\t\tround_rate = WM8650_BITS_TO_FREQ(*prate, mul, div1, div2);\n\t\tbreak;\n\tcase PLL_TYPE_WM8750:\n\t\tret = wm8750_find_pll_bits(rate, *prate, &filter, &mul, &div1, &div2);\n\t\tif (!ret)\n\t\t\tround_rate = WM8750_BITS_TO_FREQ(*prate, mul, div1, div2);\n\t\tbreak;\n\tcase PLL_TYPE_WM8850:\n\t\tret = wm8850_find_pll_bits(rate, *prate, &mul, &div1, &div2);\n\t\tif (!ret)\n\t\t\tround_rate = WM8850_BITS_TO_FREQ(*prate, mul, div1, div2);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn round_rate;\n}\n\nstatic unsigned long vtwm_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tu32 pll_val = readl(pll->reg);\n\tunsigned long pll_freq;\n\n\tswitch (pll->type) {\n\tcase PLL_TYPE_VT8500:\n\t\tpll_freq = parent_rate * VT8500_PLL_MUL(pll_val);\n\t\tpll_freq /= VT8500_PLL_DIV(pll_val);\n\t\tbreak;\n\tcase PLL_TYPE_WM8650:\n\t\tpll_freq = parent_rate * WM8650_PLL_MUL(pll_val);\n\t\tpll_freq /= WM8650_PLL_DIV(pll_val);\n\t\tbreak;\n\tcase PLL_TYPE_WM8750:\n\t\tpll_freq = parent_rate * WM8750_PLL_MUL(pll_val);\n\t\tpll_freq /= WM8750_PLL_DIV(pll_val);\n\t\tbreak;\n\tcase PLL_TYPE_WM8850:\n\t\tpll_freq = parent_rate * WM8850_PLL_MUL(pll_val);\n\t\tpll_freq /= WM8850_PLL_DIV(pll_val);\n\t\tbreak;\n\tdefault:\n\t\tpll_freq = 0;\n\t}\n\n\treturn pll_freq;\n}\n\nstatic const struct clk_ops vtwm_pll_ops = {\n\t.round_rate = vtwm_pll_round_rate,\n\t.set_rate = vtwm_pll_set_rate,\n\t.recalc_rate = vtwm_pll_recalc_rate,\n};\n\nstatic __init void vtwm_pll_clk_init(struct device_node *node, int pll_type)\n{\n\tu32 reg;\n\tstruct clk_hw *hw;\n\tstruct clk_pll *pll_clk;\n\tconst char *clk_name = node->name;\n\tconst char *parent_name;\n\tstruct clk_init_data init;\n\tint rc;\n\n\tif (!pmc_base)\n\t\tvtwm_set_pmc_base();\n\n\trc = of_property_read_u32(node, \"reg\", &reg);\n\tif (WARN_ON(rc))\n\t\treturn;\n\n\tpll_clk = kzalloc(sizeof(*pll_clk), GFP_KERNEL);\n\tif (WARN_ON(!pll_clk))\n\t\treturn;\n\n\tpll_clk->reg = pmc_base + reg;\n\tpll_clk->lock = &_lock;\n\tpll_clk->type = pll_type;\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\n\tinit.name = clk_name;\n\tinit.ops = &vtwm_pll_ops;\n\tinit.flags = 0;\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tpll_clk->hw.init = &init;\n\n\thw = &pll_clk->hw;\n\trc = clk_hw_register(NULL, &pll_clk->hw);\n\tif (WARN_ON(rc)) {\n\t\tkfree(pll_clk);\n\t\treturn;\n\t}\n\trc = of_clk_add_hw_provider(node, of_clk_hw_simple_get, hw);\n\tclk_hw_register_clkdev(hw, clk_name, NULL);\n}\n\n\n \n\nstatic void __init vt8500_pll_init(struct device_node *node)\n{\n\tvtwm_pll_clk_init(node, PLL_TYPE_VT8500);\n}\nCLK_OF_DECLARE(vt8500_pll, \"via,vt8500-pll-clock\", vt8500_pll_init);\n\nstatic void __init wm8650_pll_init(struct device_node *node)\n{\n\tvtwm_pll_clk_init(node, PLL_TYPE_WM8650);\n}\nCLK_OF_DECLARE(wm8650_pll, \"wm,wm8650-pll-clock\", wm8650_pll_init);\n\nstatic void __init wm8750_pll_init(struct device_node *node)\n{\n\tvtwm_pll_clk_init(node, PLL_TYPE_WM8750);\n}\nCLK_OF_DECLARE(wm8750_pll, \"wm,wm8750-pll-clock\", wm8750_pll_init);\n\nstatic void __init wm8850_pll_init(struct device_node *node)\n{\n\tvtwm_pll_clk_init(node, PLL_TYPE_WM8850);\n}\nCLK_OF_DECLARE(wm8850_pll, \"wm,wm8850-pll-clock\", wm8850_pll_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}