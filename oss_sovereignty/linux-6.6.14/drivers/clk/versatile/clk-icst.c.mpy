{
  "module_name": "clk-icst.c",
  "hash_id": "193f120008b0acb9e4c234c8aea2e1cd45600140e611a26254967c2f0eeaadb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/versatile/clk-icst.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/err.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n\n#include \"icst.h\"\n#include \"clk-icst.h\"\n\n \n#define VERSATILE_LOCK_VAL\t0xA05F\n\n#define VERSATILE_AUX_OSC_BITS 0x7FFFF\n#define INTEGRATOR_AP_CM_BITS 0xFF\n#define INTEGRATOR_AP_SYS_BITS 0xFF\n#define INTEGRATOR_CP_CM_CORE_BITS 0x7FF\n#define INTEGRATOR_CP_CM_MEM_BITS 0x7FF000\n\n#define INTEGRATOR_AP_PCI_25_33_MHZ BIT(8)\n\n \nstruct clk_icst {\n\tstruct clk_hw hw;\n\tstruct regmap *map;\n\tu32 vcoreg_off;\n\tu32 lockreg_off;\n\tstruct icst_params *params;\n\tunsigned long rate;\n\tenum icst_control_type ctype;\n};\n\n#define to_icst(_hw) container_of(_hw, struct clk_icst, hw)\n\n \nstatic int vco_get(struct clk_icst *icst, struct icst_vco *vco)\n{\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(icst->map, icst->vcoreg_off, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (icst->ctype == ICST_INTEGRATOR_AP_CM) {\n\t\tvco->v = val & INTEGRATOR_AP_CM_BITS;\n\t\tvco->r = 22;\n\t\tvco->s = 1;\n\t\treturn 0;\n\t}\n\n\t \n\tif (icst->ctype == ICST_INTEGRATOR_AP_SYS) {\n\t\tvco->v = val & INTEGRATOR_AP_SYS_BITS;\n\t\tvco->r = 46;\n\t\tvco->s = 3;\n\t\treturn 0;\n\t}\n\n\t \n\tif (icst->ctype == ICST_INTEGRATOR_AP_PCI) {\n\t\tbool divxy = !!(val & INTEGRATOR_AP_PCI_25_33_MHZ);\n\n\t\tvco->v = divxy ? 17 : 14;\n\t\tvco->r = divxy ? 22 : 14;\n\t\tvco->s = 1;\n\t\treturn 0;\n\t}\n\n\t \n\tif (icst->ctype == ICST_INTEGRATOR_CP_CM_CORE) {\n\t\tvco->v = val & 0xFF;\n\t\tvco->r = 22;\n\t\tvco->s = (val >> 8) & 7;\n\t\treturn 0;\n\t}\n\n\tif (icst->ctype == ICST_INTEGRATOR_CP_CM_MEM) {\n\t\tvco->v = (val >> 12) & 0xFF;\n\t\tvco->r = 22;\n\t\tvco->s = (val >> 20) & 7;\n\t\treturn 0;\n\t}\n\n\tvco->v = val & 0x1ff;\n\tvco->r = (val >> 9) & 0x7f;\n\tvco->s = (val >> 16) & 03;\n\treturn 0;\n}\n\n \nstatic int vco_set(struct clk_icst *icst, struct icst_vco vco)\n{\n\tu32 mask;\n\tu32 val;\n\tint ret;\n\n\t \n\tswitch (icst->ctype) {\n\tcase ICST_INTEGRATOR_AP_CM:\n\t\tmask = INTEGRATOR_AP_CM_BITS;\n\t\tval = vco.v & 0xFF;\n\t\tif (vco.v & 0x100)\n\t\t\tpr_err(\"ICST error: tried to set bit 8 of VDW\\n\");\n\t\tif (vco.s != 1)\n\t\t\tpr_err(\"ICST error: tried to use VOD != 1\\n\");\n\t\tif (vco.r != 22)\n\t\t\tpr_err(\"ICST error: tried to use RDW != 22\\n\");\n\t\tbreak;\n\tcase ICST_INTEGRATOR_AP_SYS:\n\t\tmask = INTEGRATOR_AP_SYS_BITS;\n\t\tval = vco.v & 0xFF;\n\t\tif (vco.v & 0x100)\n\t\t\tpr_err(\"ICST error: tried to set bit 8 of VDW\\n\");\n\t\tif (vco.s != 3)\n\t\t\tpr_err(\"ICST error: tried to use VOD != 1\\n\");\n\t\tif (vco.r != 46)\n\t\t\tpr_err(\"ICST error: tried to use RDW != 22\\n\");\n\t\tbreak;\n\tcase ICST_INTEGRATOR_CP_CM_CORE:\n\t\tmask = INTEGRATOR_CP_CM_CORE_BITS;  \n\t\tval = (vco.v & 0xFF) | vco.s << 8;\n\t\tif (vco.v & 0x100)\n\t\t\tpr_err(\"ICST error: tried to set bit 8 of VDW\\n\");\n\t\tif (vco.r != 22)\n\t\t\tpr_err(\"ICST error: tried to use RDW != 22\\n\");\n\t\tbreak;\n\tcase ICST_INTEGRATOR_CP_CM_MEM:\n\t\tmask = INTEGRATOR_CP_CM_MEM_BITS;  \n\t\tval = ((vco.v & 0xFF) << 12) | (vco.s << 20);\n\t\tif (vco.v & 0x100)\n\t\t\tpr_err(\"ICST error: tried to set bit 8 of VDW\\n\");\n\t\tif (vco.r != 22)\n\t\t\tpr_err(\"ICST error: tried to use RDW != 22\\n\");\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tmask = VERSATILE_AUX_OSC_BITS;\n\t\tval = vco.v | (vco.r << 9) | (vco.s << 16);\n\t\tbreak;\n\t}\n\n\tpr_debug(\"ICST: new val = 0x%08x\\n\", val);\n\n\t \n\tret = regmap_write(icst->map, icst->lockreg_off, VERSATILE_LOCK_VAL);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_update_bits(icst->map, icst->vcoreg_off, mask, val);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = regmap_write(icst->map, icst->lockreg_off, 0);\n\tif (ret)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic unsigned long icst_recalc_rate(struct clk_hw *hw,\n\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct clk_icst *icst = to_icst(hw);\n\tstruct icst_vco vco;\n\tint ret;\n\n\tif (parent_rate)\n\t\ticst->params->ref = parent_rate;\n\tret = vco_get(icst, &vco);\n\tif (ret) {\n\t\tpr_err(\"ICST: could not get VCO setting\\n\");\n\t\treturn 0;\n\t}\n\ticst->rate = icst_hz(icst->params, vco);\n\treturn icst->rate;\n}\n\nstatic long icst_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long *prate)\n{\n\tstruct clk_icst *icst = to_icst(hw);\n\tstruct icst_vco vco;\n\n\tif (icst->ctype == ICST_INTEGRATOR_AP_CM ||\n\t    icst->ctype == ICST_INTEGRATOR_CP_CM_CORE) {\n\t\tif (rate <= 12000000)\n\t\t\treturn 12000000;\n\t\tif (rate >= 160000000)\n\t\t\treturn 160000000;\n\t\t \n\t\treturn DIV_ROUND_CLOSEST(rate, 1000000) * 1000000;\n\t}\n\n\tif (icst->ctype == ICST_INTEGRATOR_CP_CM_MEM) {\n\t\tif (rate <= 6000000)\n\t\t\treturn 6000000;\n\t\tif (rate >= 66000000)\n\t\t\treturn 66000000;\n\t\t \n\t\treturn DIV_ROUND_CLOSEST(rate, 500000) * 500000;\n\t}\n\n\tif (icst->ctype == ICST_INTEGRATOR_AP_SYS) {\n\t\t \n\t\tif (rate <= 3000000)\n\t\t\treturn 3000000;\n\t\tif (rate >= 50000000)\n\t\t\treturn 5000000;\n\t\t \n\t\treturn DIV_ROUND_CLOSEST(rate, 250000) * 250000;\n\t}\n\n\tif (icst->ctype == ICST_INTEGRATOR_AP_PCI) {\n\t\t \n\t\tif (rate <= 25000000 || rate < 29000000)\n\t\t\treturn 25000000;\n\t\t \n\t\treturn 33000000;\n\t}\n\n\tvco = icst_hz_to_vco(icst->params, rate);\n\treturn icst_hz(icst->params, vco);\n}\n\nstatic int icst_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_icst *icst = to_icst(hw);\n\tstruct icst_vco vco;\n\n\tif (icst->ctype == ICST_INTEGRATOR_AP_PCI) {\n\t\t \n\t\tunsigned int val;\n\t\tint ret;\n\n\t\tif (rate == 25000000) {\n\t\t\tval = 0;\n\t\t} else if (rate == 33000000) {\n\t\t\tval = INTEGRATOR_AP_PCI_25_33_MHZ;\n\t\t} else {\n\t\t\tpr_err(\"ICST: cannot set PCI frequency %lu\\n\",\n\t\t\t       rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = regmap_write(icst->map, icst->lockreg_off,\n\t\t\t\t   VERSATILE_LOCK_VAL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = regmap_update_bits(icst->map, icst->vcoreg_off,\n\t\t\t\t\t INTEGRATOR_AP_PCI_25_33_MHZ,\n\t\t\t\t\t val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tret = regmap_write(icst->map, icst->lockreg_off, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\tif (parent_rate)\n\t\ticst->params->ref = parent_rate;\n\tvco = icst_hz_to_vco(icst->params, rate);\n\ticst->rate = icst_hz(icst->params, vco);\n\treturn vco_set(icst, vco);\n}\n\nstatic const struct clk_ops icst_ops = {\n\t.recalc_rate = icst_recalc_rate,\n\t.round_rate = icst_round_rate,\n\t.set_rate = icst_set_rate,\n};\n\nstruct clk *icst_clk_setup(struct device *dev,\n\t\t\t   const struct clk_icst_desc *desc,\n\t\t\t   const char *name,\n\t\t\t   const char *parent_name,\n\t\t\t   struct regmap *map,\n\t\t\t   enum icst_control_type ctype)\n{\n\tstruct clk *clk;\n\tstruct clk_icst *icst;\n\tstruct clk_init_data init;\n\tstruct icst_params *pclone;\n\n\ticst = kzalloc(sizeof(*icst), GFP_KERNEL);\n\tif (!icst)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpclone = kmemdup(desc->params, sizeof(*pclone), GFP_KERNEL);\n\tif (!pclone) {\n\t\tkfree(icst);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinit.name = name;\n\tinit.ops = &icst_ops;\n\tinit.flags = 0;\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\ticst->map = map;\n\ticst->hw.init = &init;\n\ticst->params = pclone;\n\ticst->vcoreg_off = desc->vco_offset;\n\ticst->lockreg_off = desc->lock_offset;\n\ticst->ctype = ctype;\n\n\tclk = clk_register(dev, &icst->hw);\n\tif (IS_ERR(clk)) {\n\t\tkfree(pclone);\n\t\tkfree(icst);\n\t}\n\n\treturn clk;\n}\nEXPORT_SYMBOL_GPL(icst_clk_setup);\n\nstruct clk *icst_clk_register(struct device *dev,\n\t\t\tconst struct clk_icst_desc *desc,\n\t\t\tconst char *name,\n\t\t\tconst char *parent_name,\n\t\t\tvoid __iomem *base)\n{\n\tstruct regmap_config icst_regmap_conf = {\n\t\t.reg_bits = 32,\n\t\t.val_bits = 32,\n\t\t.reg_stride = 4,\n\t};\n\tstruct regmap *map;\n\n\tmap = regmap_init_mmio(dev, base, &icst_regmap_conf);\n\tif (IS_ERR(map)) {\n\t\tpr_err(\"could not initialize ICST regmap\\n\");\n\t\treturn ERR_CAST(map);\n\t}\n\treturn icst_clk_setup(dev, desc, name, parent_name, map,\n\t\t\t      ICST_VERSATILE);\n}\nEXPORT_SYMBOL_GPL(icst_clk_register);\n\n#ifdef CONFIG_OF\n \n\nstatic const struct icst_params icst525_params = {\n\t.vco_max\t= ICST525_VCO_MAX_5V,\n\t.vco_min\t= ICST525_VCO_MIN,\n\t.vd_min\t\t= 8,\n\t.vd_max\t\t= 263,\n\t.rd_min\t\t= 3,\n\t.rd_max\t\t= 65,\n\t.s2div\t\t= icst525_s2div,\n\t.idx2s\t\t= icst525_idx2s,\n};\n\nstatic const struct icst_params icst307_params = {\n\t.vco_max\t= ICST307_VCO_MAX,\n\t.vco_min\t= ICST307_VCO_MIN,\n\t.vd_min\t\t= 4 + 8,\n\t.vd_max\t\t= 511 + 8,\n\t.rd_min\t\t= 1 + 2,\n\t.rd_max\t\t= 127 + 2,\n\t.s2div\t\t= icst307_s2div,\n\t.idx2s\t\t= icst307_idx2s,\n};\n\n \nstatic const struct icst_params icst525_apcp_cm_params = {\n\t.vco_max\t= ICST525_VCO_MAX_5V,\n\t.vco_min\t= ICST525_VCO_MIN,\n\t \n\t.vd_min\t\t= 12,\n\t \n\t.vd_max\t\t= 192,\n\t \n\t.rd_min\t\t= 24,\n\t.rd_max\t\t= 24,\n\t.s2div\t\t= icst525_s2div,\n\t.idx2s\t\t= icst525_idx2s,\n};\n\nstatic const struct icst_params icst525_ap_sys_params = {\n\t.vco_max\t= ICST525_VCO_MAX_5V,\n\t.vco_min\t= ICST525_VCO_MIN,\n\t \n\t.vd_min\t\t= 3,\n\t \n\t.vd_max\t\t= 50,\n\t \n\t.rd_min\t\t= 48,\n\t.rd_max\t\t= 48,\n\t.s2div\t\t= icst525_s2div,\n\t.idx2s\t\t= icst525_idx2s,\n};\n\nstatic const struct icst_params icst525_ap_pci_params = {\n\t.vco_max\t= ICST525_VCO_MAX_5V,\n\t.vco_min\t= ICST525_VCO_MIN,\n\t \n\t.vd_min\t\t= 25,\n\t \n\t.vd_max\t\t= 33,\n\t \n\t.rd_min\t\t= 16,\n\t.rd_max\t\t= 24,\n\t.s2div\t\t= icst525_s2div,\n\t.idx2s\t\t= icst525_idx2s,\n};\n\nstatic void __init of_syscon_icst_setup(struct device_node *np)\n{\n\tstruct device_node *parent;\n\tstruct regmap *map;\n\tstruct clk_icst_desc icst_desc;\n\tconst char *name;\n\tconst char *parent_name;\n\tstruct clk *regclk;\n\tenum icst_control_type ctype;\n\n\t \n\tparent = of_get_parent(np);\n\tif (!parent) {\n\t\tpr_err(\"no parent node for syscon ICST clock\\n\");\n\t\treturn;\n\t}\n\tmap = syscon_node_to_regmap(parent);\n\tif (IS_ERR(map)) {\n\t\tpr_err(\"no regmap for syscon ICST clock parent\\n\");\n\t\treturn;\n\t}\n\n\tif (of_property_read_u32(np, \"reg\", &icst_desc.vco_offset) &&\n\t    of_property_read_u32(np, \"vco-offset\", &icst_desc.vco_offset)) {\n\t\tpr_err(\"no VCO register offset for ICST clock\\n\");\n\t\treturn;\n\t}\n\tif (of_property_read_u32(np, \"lock-offset\", &icst_desc.lock_offset)) {\n\t\tpr_err(\"no lock register offset for ICST clock\\n\");\n\t\treturn;\n\t}\n\n\tif (of_device_is_compatible(np, \"arm,syscon-icst525\")) {\n\t\ticst_desc.params = &icst525_params;\n\t\tctype = ICST_VERSATILE;\n\t} else if (of_device_is_compatible(np, \"arm,syscon-icst307\")) {\n\t\ticst_desc.params = &icst307_params;\n\t\tctype = ICST_VERSATILE;\n\t} else if (of_device_is_compatible(np, \"arm,syscon-icst525-integratorap-cm\")) {\n\t\ticst_desc.params = &icst525_apcp_cm_params;\n\t\tctype = ICST_INTEGRATOR_AP_CM;\n\t} else if (of_device_is_compatible(np, \"arm,syscon-icst525-integratorap-sys\")) {\n\t\ticst_desc.params = &icst525_ap_sys_params;\n\t\tctype = ICST_INTEGRATOR_AP_SYS;\n\t} else if (of_device_is_compatible(np, \"arm,syscon-icst525-integratorap-pci\")) {\n\t\ticst_desc.params = &icst525_ap_pci_params;\n\t\tctype = ICST_INTEGRATOR_AP_PCI;\n\t} else if (of_device_is_compatible(np, \"arm,syscon-icst525-integratorcp-cm-core\")) {\n\t\ticst_desc.params = &icst525_apcp_cm_params;\n\t\tctype = ICST_INTEGRATOR_CP_CM_CORE;\n\t} else if (of_device_is_compatible(np, \"arm,syscon-icst525-integratorcp-cm-mem\")) {\n\t\ticst_desc.params = &icst525_apcp_cm_params;\n\t\tctype = ICST_INTEGRATOR_CP_CM_MEM;\n\t} else {\n\t\tpr_err(\"unknown ICST clock %pOF\\n\", np);\n\t\treturn;\n\t}\n\n\t \n\tparent_name = of_clk_get_parent_name(np, 0);\n\tname = kasprintf(GFP_KERNEL, \"%pOFP\", np);\n\n\tregclk = icst_clk_setup(NULL, &icst_desc, name, parent_name, map, ctype);\n\tif (IS_ERR(regclk)) {\n\t\tpr_err(\"error setting up syscon ICST clock %s\\n\", name);\n\t\tkfree(name);\n\t\treturn;\n\t}\n\tof_clk_add_provider(np, of_clk_src_simple_get, regclk);\n\tpr_debug(\"registered syscon ICST clock %s\\n\", name);\n}\n\nCLK_OF_DECLARE(arm_syscon_icst525_clk,\n\t       \"arm,syscon-icst525\", of_syscon_icst_setup);\nCLK_OF_DECLARE(arm_syscon_icst307_clk,\n\t       \"arm,syscon-icst307\", of_syscon_icst_setup);\nCLK_OF_DECLARE(arm_syscon_integratorap_cm_clk,\n\t       \"arm,syscon-icst525-integratorap-cm\", of_syscon_icst_setup);\nCLK_OF_DECLARE(arm_syscon_integratorap_sys_clk,\n\t       \"arm,syscon-icst525-integratorap-sys\", of_syscon_icst_setup);\nCLK_OF_DECLARE(arm_syscon_integratorap_pci_clk,\n\t       \"arm,syscon-icst525-integratorap-pci\", of_syscon_icst_setup);\nCLK_OF_DECLARE(arm_syscon_integratorcp_cm_core_clk,\n\t       \"arm,syscon-icst525-integratorcp-cm-core\", of_syscon_icst_setup);\nCLK_OF_DECLARE(arm_syscon_integratorcp_cm_mem_clk,\n\t       \"arm,syscon-icst525-integratorcp-cm-mem\", of_syscon_icst_setup);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}