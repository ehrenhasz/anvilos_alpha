{
  "module_name": "clk-sp810.c",
  "hash_id": "7c72512be1dac8a17513300b627120a945f7f7b80b20ceed40e2d323eff41fbc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/versatile/clk-sp810.c",
  "human_readable_source": "\n \n\n#include <linux/amba/sp810.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n#define to_clk_sp810_timerclken(_hw) \\\n\t\tcontainer_of(_hw, struct clk_sp810_timerclken, hw)\n\nstruct clk_sp810;\n\nstruct clk_sp810_timerclken {\n\tstruct clk_hw hw;\n\tstruct clk *clk;\n\tstruct clk_sp810 *sp810;\n\tint channel;\n};\n\nstruct clk_sp810 {\n\tstruct device_node *node;\n\tvoid __iomem *base;\n\tspinlock_t lock;\n\tstruct clk_sp810_timerclken timerclken[4];\n};\n\nstatic u8 clk_sp810_timerclken_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_sp810_timerclken *timerclken = to_clk_sp810_timerclken(hw);\n\tu32 val = readl(timerclken->sp810->base + SCCTRL);\n\n\treturn !!(val & (1 << SCCTRL_TIMERENnSEL_SHIFT(timerclken->channel)));\n}\n\nstatic int clk_sp810_timerclken_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_sp810_timerclken *timerclken = to_clk_sp810_timerclken(hw);\n\tstruct clk_sp810 *sp810 = timerclken->sp810;\n\tu32 val, shift = SCCTRL_TIMERENnSEL_SHIFT(timerclken->channel);\n\tunsigned long flags = 0;\n\n\tif (WARN_ON(index > 1))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&sp810->lock, flags);\n\n\tval = readl(sp810->base + SCCTRL);\n\tval &= ~(1 << shift);\n\tval |= index << shift;\n\twritel(val, sp810->base + SCCTRL);\n\n\tspin_unlock_irqrestore(&sp810->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_sp810_timerclken_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.get_parent = clk_sp810_timerclken_get_parent,\n\t.set_parent = clk_sp810_timerclken_set_parent,\n};\n\nstatic struct clk *clk_sp810_timerclken_of_get(struct of_phandle_args *clkspec,\n\t\tvoid *data)\n{\n\tstruct clk_sp810 *sp810 = data;\n\n\tif (WARN_ON(clkspec->args_count != 1 ||\n\t\t    clkspec->args[0] >=\tARRAY_SIZE(sp810->timerclken)))\n\t\treturn NULL;\n\n\treturn sp810->timerclken[clkspec->args[0]].clk;\n}\n\nstatic void __init clk_sp810_of_setup(struct device_node *node)\n{\n\tstruct clk_sp810 *sp810 = kzalloc(sizeof(*sp810), GFP_KERNEL);\n\tconst char *parent_names[2];\n\tint num = ARRAY_SIZE(parent_names);\n\tchar name[12];\n\tstruct clk_init_data init;\n\tstatic int instance;\n\tint i;\n\tbool deprecated;\n\n\tif (!sp810)\n\t\treturn;\n\n\tif (of_clk_parent_fill(node, parent_names, num) != num) {\n\t\tpr_warn(\"Failed to obtain parent clocks for SP810!\\n\");\n\t\tkfree(sp810);\n\t\treturn;\n\t}\n\n\tsp810->node = node;\n\tsp810->base = of_iomap(node, 0);\n\tspin_lock_init(&sp810->lock);\n\n\tinit.name = name;\n\tinit.ops = &clk_sp810_timerclken_ops;\n\tinit.flags = 0;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num;\n\n\tdeprecated = !of_find_property(node, \"assigned-clock-parents\", NULL);\n\n\tfor (i = 0; i < ARRAY_SIZE(sp810->timerclken); i++) {\n\t\tsnprintf(name, sizeof(name), \"sp810_%d_%d\", instance, i);\n\n\t\tsp810->timerclken[i].sp810 = sp810;\n\t\tsp810->timerclken[i].channel = i;\n\t\tsp810->timerclken[i].hw.init = &init;\n\n\t\t \n\t\tif (deprecated)\n\t\t\tinit.ops->set_parent(&sp810->timerclken[i].hw, 1);\n\n\t\tsp810->timerclken[i].clk = clk_register(NULL,\n\t\t\t\t&sp810->timerclken[i].hw);\n\t\tWARN_ON(IS_ERR(sp810->timerclken[i].clk));\n\t}\n\n\tof_clk_add_provider(node, clk_sp810_timerclken_of_get, sp810);\n\tinstance++;\n}\nCLK_OF_DECLARE(sp810, \"arm,sp810\", clk_sp810_of_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}