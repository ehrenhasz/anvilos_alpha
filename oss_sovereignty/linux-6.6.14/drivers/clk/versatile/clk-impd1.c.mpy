{
  "module_name": "clk-impd1.c",
  "hash_id": "c75787334371ebf3a2017c74b8018fd2d8dea1746a4d35bda88530ac56270e5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/versatile/clk-impd1.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include \"icst.h\"\n#include \"clk-icst.h\"\n\n#define IMPD1_OSC1\t0x00\n#define IMPD1_OSC2\t0x04\n#define IMPD1_LOCK\t0x08\n\n \n\nstatic const struct icst_params impd1_vco1_params = {\n\t.ref\t\t= 24000000,\t \n\t.vco_max\t= ICST525_VCO_MAX_3V,\n\t.vco_min\t= ICST525_VCO_MIN,\n\t.vd_min\t\t= 12,\n\t.vd_max\t\t= 519,\n\t.rd_min\t\t= 3,\n\t.rd_max\t\t= 120,\n\t.s2div\t\t= icst525_s2div,\n\t.idx2s\t\t= icst525_idx2s,\n};\n\nstatic const struct clk_icst_desc impd1_icst1_desc = {\n\t.params = &impd1_vco1_params,\n\t.vco_offset = IMPD1_OSC1,\n\t.lock_offset = IMPD1_LOCK,\n};\n\nstatic const struct icst_params impd1_vco2_params = {\n\t.ref\t\t= 24000000,\t \n\t.vco_max\t= ICST525_VCO_MAX_3V,\n\t.vco_min\t= ICST525_VCO_MIN,\n\t.vd_min\t\t= 12,\n\t.vd_max\t\t= 519,\n\t.rd_min\t\t= 3,\n\t.rd_max\t\t= 120,\n\t.s2div\t\t= icst525_s2div,\n\t.idx2s\t\t= icst525_idx2s,\n};\n\nstatic const struct clk_icst_desc impd1_icst2_desc = {\n\t.params = &impd1_vco2_params,\n\t.vco_offset = IMPD1_OSC2,\n\t.lock_offset = IMPD1_LOCK,\n};\n\nstatic int integrator_impd1_clk_spawn(struct device *dev,\n\t\t\t\t      struct device_node *parent,\n\t\t\t\t      struct device_node *np)\n{\n\tstruct regmap *map;\n\tstruct clk *clk = ERR_PTR(-EINVAL);\n\tconst char *name = np->name;\n\tconst char *parent_name;\n\tconst struct clk_icst_desc *desc;\n\tint ret;\n\n\tmap = syscon_node_to_regmap(parent);\n\tif (IS_ERR(map)) {\n\t\tpr_err(\"no regmap for syscon IM-PD1 ICST clock parent\\n\");\n\t\treturn PTR_ERR(map);\n\t}\n\n\tif (of_device_is_compatible(np, \"arm,impd1-vco1\")) {\n\t\tdesc = &impd1_icst1_desc;\n\t} else if (of_device_is_compatible(np, \"arm,impd1-vco2\")) {\n\t\tdesc = &impd1_icst2_desc;\n\t} else {\n\t\tdev_err(dev, \"not a clock node %s\\n\", name);\n\t\treturn -ENODEV;\n\t}\n\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\tparent_name = of_clk_get_parent_name(np, 0);\n\tclk = icst_clk_setup(NULL, desc, name, parent_name, map,\n\t\t\t     ICST_INTEGRATOR_IM_PD1);\n\tif (!IS_ERR(clk)) {\n\t\tof_clk_add_provider(np, of_clk_src_simple_get, clk);\n\t\tret = 0;\n\t} else {\n\t\tdev_err(dev, \"error setting up IM-PD1 ICST clock\\n\");\n\t\tret = PTR_ERR(clk);\n\t}\n\n\treturn ret;\n}\n\nstatic int integrator_impd1_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child;\n\tint ret = 0;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tret = integrator_impd1_clk_spawn(dev, np, child);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic const struct of_device_id impd1_syscon_match[] = {\n\t{ .compatible = \"arm,im-pd1-syscon\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, impd1_syscon_match);\n\nstatic struct platform_driver impd1_clk_driver = {\n\t.driver = {\n\t\t.name = \"impd1-clk\",\n\t\t.of_match_table = impd1_syscon_match,\n\t},\n\t.probe  = integrator_impd1_clk_probe,\n};\nbuiltin_platform_driver(impd1_clk_driver);\n\nMODULE_AUTHOR(\"Linus Walleij <linusw@kernel.org>\");\nMODULE_DESCRIPTION(\"Arm IM-PD1 module clock driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}