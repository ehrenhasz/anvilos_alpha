{
  "module_name": "clk-vexpress-osc.c",
  "hash_id": "86fcc2e94a8fd74806f275b6ac1db9c19820113c5de774b810f01e7936bb620f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/versatile/clk-vexpress-osc.c",
  "human_readable_source": "\n \n\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/vexpress.h>\n\nstruct vexpress_osc {\n\tstruct regmap *reg;\n\tstruct clk_hw hw;\n\tunsigned long rate_min;\n\tunsigned long rate_max;\n};\n\n#define to_vexpress_osc(osc) container_of(osc, struct vexpress_osc, hw)\n\nstatic unsigned long vexpress_osc_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct vexpress_osc *osc = to_vexpress_osc(hw);\n\tu32 rate;\n\n\tregmap_read(osc->reg, 0, &rate);\n\n\treturn rate;\n}\n\nstatic long vexpress_osc_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long *parent_rate)\n{\n\tstruct vexpress_osc *osc = to_vexpress_osc(hw);\n\n\tif (osc->rate_min && rate < osc->rate_min)\n\t\trate = osc->rate_min;\n\n\tif (osc->rate_max && rate > osc->rate_max)\n\t\trate = osc->rate_max;\n\n\treturn rate;\n}\n\nstatic int vexpress_osc_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct vexpress_osc *osc = to_vexpress_osc(hw);\n\n\treturn regmap_write(osc->reg, 0, rate);\n}\n\nstatic const struct clk_ops vexpress_osc_ops = {\n\t.recalc_rate = vexpress_osc_recalc_rate,\n\t.round_rate = vexpress_osc_round_rate,\n\t.set_rate = vexpress_osc_set_rate,\n};\n\n\nstatic int vexpress_osc_probe(struct platform_device *pdev)\n{\n\tstruct clk_init_data init;\n\tstruct vexpress_osc *osc;\n\tu32 range[2];\n\tint ret;\n\n\tosc = devm_kzalloc(&pdev->dev, sizeof(*osc), GFP_KERNEL);\n\tif (!osc)\n\t\treturn -ENOMEM;\n\n\tosc->reg = devm_regmap_init_vexpress_config(&pdev->dev);\n\tif (IS_ERR(osc->reg))\n\t\treturn PTR_ERR(osc->reg);\n\n\tif (of_property_read_u32_array(pdev->dev.of_node, \"freq-range\", range,\n\t\t\tARRAY_SIZE(range)) == 0) {\n\t\tosc->rate_min = range[0];\n\t\tosc->rate_max = range[1];\n\t}\n\n\tif (of_property_read_string(pdev->dev.of_node, \"clock-output-names\",\n\t\t\t&init.name) != 0)\n\t\tinit.name = dev_name(&pdev->dev);\n\n\tinit.ops = &vexpress_osc_ops;\n\tinit.flags = 0;\n\tinit.num_parents = 0;\n\n\tosc->hw.init = &init;\n\n\tret = devm_clk_hw_register(&pdev->dev, &osc->hw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdevm_of_clk_add_hw_provider(&pdev->dev, of_clk_hw_simple_get, &osc->hw);\n\tclk_hw_set_rate_range(&osc->hw, osc->rate_min, osc->rate_max);\n\n\tdev_dbg(&pdev->dev, \"Registered clock '%s'\\n\", init.name);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id vexpress_osc_of_match[] = {\n\t{ .compatible = \"arm,vexpress-osc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, vexpress_osc_of_match);\n\nstatic struct platform_driver vexpress_osc_driver = {\n\t.driver\t= {\n\t\t.name = \"vexpress-osc\",\n\t\t.of_match_table = vexpress_osc_of_match,\n\t},\n\t.probe = vexpress_osc_probe,\n};\nmodule_platform_driver(vexpress_osc_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}