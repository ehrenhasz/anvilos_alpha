{
  "module_name": "clk-starfive-jh71x0.c",
  "hash_id": "5572946b5eebb3cc42c4104527668194dd6381e0bff5d9cde10740fd0e32f029",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/starfive/clk-starfive-jh71x0.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/io.h>\n\n#include \"clk-starfive-jh71x0.h\"\n\nstatic struct jh71x0_clk *jh71x0_clk_from(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct jh71x0_clk, hw);\n}\n\nstatic struct jh71x0_clk_priv *jh71x0_priv_from(struct jh71x0_clk *clk)\n{\n\treturn container_of(clk, struct jh71x0_clk_priv, reg[clk->idx]);\n}\n\nstatic u32 jh71x0_clk_reg_get(struct jh71x0_clk *clk)\n{\n\tstruct jh71x0_clk_priv *priv = jh71x0_priv_from(clk);\n\tvoid __iomem *reg = priv->base + 4 * clk->idx;\n\n\treturn readl_relaxed(reg);\n}\n\nstatic void jh71x0_clk_reg_rmw(struct jh71x0_clk *clk, u32 mask, u32 value)\n{\n\tstruct jh71x0_clk_priv *priv = jh71x0_priv_from(clk);\n\tvoid __iomem *reg = priv->base + 4 * clk->idx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->rmw_lock, flags);\n\tvalue |= readl_relaxed(reg) & ~mask;\n\twritel_relaxed(value, reg);\n\tspin_unlock_irqrestore(&priv->rmw_lock, flags);\n}\n\nstatic int jh71x0_clk_enable(struct clk_hw *hw)\n{\n\tstruct jh71x0_clk *clk = jh71x0_clk_from(hw);\n\n\tjh71x0_clk_reg_rmw(clk, JH71X0_CLK_ENABLE, JH71X0_CLK_ENABLE);\n\treturn 0;\n}\n\nstatic void jh71x0_clk_disable(struct clk_hw *hw)\n{\n\tstruct jh71x0_clk *clk = jh71x0_clk_from(hw);\n\n\tjh71x0_clk_reg_rmw(clk, JH71X0_CLK_ENABLE, 0);\n}\n\nstatic int jh71x0_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct jh71x0_clk *clk = jh71x0_clk_from(hw);\n\n\treturn !!(jh71x0_clk_reg_get(clk) & JH71X0_CLK_ENABLE);\n}\n\nstatic unsigned long jh71x0_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct jh71x0_clk *clk = jh71x0_clk_from(hw);\n\tu32 div = jh71x0_clk_reg_get(clk) & JH71X0_CLK_DIV_MASK;\n\n\treturn div ? parent_rate / div : 0;\n}\n\nstatic int jh71x0_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t     struct clk_rate_request *req)\n{\n\tstruct jh71x0_clk *clk = jh71x0_clk_from(hw);\n\tunsigned long parent = req->best_parent_rate;\n\tunsigned long rate = clamp(req->rate, req->min_rate, req->max_rate);\n\tunsigned long div = min_t(unsigned long, DIV_ROUND_UP(parent, rate), clk->max_div);\n\tunsigned long result = parent / div;\n\n\t \n\tif (result < req->min_rate && div > 1)\n\t\tresult = parent / (div - 1);\n\n\treq->rate = result;\n\treturn 0;\n}\n\nstatic int jh71x0_clk_set_rate(struct clk_hw *hw,\n\t\t\t       unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct jh71x0_clk *clk = jh71x0_clk_from(hw);\n\tunsigned long div = clamp(DIV_ROUND_CLOSEST(parent_rate, rate),\n\t\t\t\t  1UL, (unsigned long)clk->max_div);\n\n\tjh71x0_clk_reg_rmw(clk, JH71X0_CLK_DIV_MASK, div);\n\treturn 0;\n}\n\nstatic unsigned long jh71x0_clk_frac_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct jh71x0_clk *clk = jh71x0_clk_from(hw);\n\tu32 reg = jh71x0_clk_reg_get(clk);\n\tunsigned long div100 = 100 * (reg & JH71X0_CLK_INT_MASK) +\n\t\t\t       ((reg & JH71X0_CLK_FRAC_MASK) >> JH71X0_CLK_FRAC_SHIFT);\n\n\treturn (div100 >= JH71X0_CLK_FRAC_MIN) ? 100 * parent_rate / div100 : 0;\n}\n\nstatic int jh71x0_clk_frac_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t  struct clk_rate_request *req)\n{\n\tunsigned long parent100 = 100 * req->best_parent_rate;\n\tunsigned long rate = clamp(req->rate, req->min_rate, req->max_rate);\n\tunsigned long div100 = clamp(DIV_ROUND_CLOSEST(parent100, rate),\n\t\t\t\t     JH71X0_CLK_FRAC_MIN, JH71X0_CLK_FRAC_MAX);\n\tunsigned long result = parent100 / div100;\n\n\t \n\tif (result > req->max_rate && div100 < JH71X0_CLK_FRAC_MAX)\n\t\tresult = parent100 / (div100 + 1);\n\tif (result < req->min_rate && div100 > JH71X0_CLK_FRAC_MIN)\n\t\tresult = parent100 / (div100 - 1);\n\n\treq->rate = result;\n\treturn 0;\n}\n\nstatic int jh71x0_clk_frac_set_rate(struct clk_hw *hw,\n\t\t\t\t    unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct jh71x0_clk *clk = jh71x0_clk_from(hw);\n\tunsigned long div100 = clamp(DIV_ROUND_CLOSEST(100 * parent_rate, rate),\n\t\t\t\t     JH71X0_CLK_FRAC_MIN, JH71X0_CLK_FRAC_MAX);\n\tu32 value = ((div100 % 100) << JH71X0_CLK_FRAC_SHIFT) | (div100 / 100);\n\n\tjh71x0_clk_reg_rmw(clk, JH71X0_CLK_DIV_MASK, value);\n\treturn 0;\n}\n\nstatic u8 jh71x0_clk_get_parent(struct clk_hw *hw)\n{\n\tstruct jh71x0_clk *clk = jh71x0_clk_from(hw);\n\tu32 value = jh71x0_clk_reg_get(clk);\n\n\treturn (value & JH71X0_CLK_MUX_MASK) >> JH71X0_CLK_MUX_SHIFT;\n}\n\nstatic int jh71x0_clk_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct jh71x0_clk *clk = jh71x0_clk_from(hw);\n\tu32 value = (u32)index << JH71X0_CLK_MUX_SHIFT;\n\n\tjh71x0_clk_reg_rmw(clk, JH71X0_CLK_MUX_MASK, value);\n\treturn 0;\n}\n\nstatic int jh71x0_clk_get_phase(struct clk_hw *hw)\n{\n\tstruct jh71x0_clk *clk = jh71x0_clk_from(hw);\n\tu32 value = jh71x0_clk_reg_get(clk);\n\n\treturn (value & JH71X0_CLK_INVERT) ? 180 : 0;\n}\n\nstatic int jh71x0_clk_set_phase(struct clk_hw *hw, int degrees)\n{\n\tstruct jh71x0_clk *clk = jh71x0_clk_from(hw);\n\tu32 value;\n\n\tif (degrees == 0)\n\t\tvalue = 0;\n\telse if (degrees == 180)\n\t\tvalue = JH71X0_CLK_INVERT;\n\telse\n\t\treturn -EINVAL;\n\n\tjh71x0_clk_reg_rmw(clk, JH71X0_CLK_INVERT, value);\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void jh71x0_clk_debug_init(struct clk_hw *hw, struct dentry *dentry)\n{\n\tstatic const struct debugfs_reg32 jh71x0_clk_reg = {\n\t\t.name = \"CTRL\",\n\t\t.offset = 0,\n\t};\n\tstruct jh71x0_clk *clk = jh71x0_clk_from(hw);\n\tstruct jh71x0_clk_priv *priv = jh71x0_priv_from(clk);\n\tstruct debugfs_regset32 *regset;\n\n\tregset = devm_kzalloc(priv->dev, sizeof(*regset), GFP_KERNEL);\n\tif (!regset)\n\t\treturn;\n\n\tregset->regs = &jh71x0_clk_reg;\n\tregset->nregs = 1;\n\tregset->base = priv->base + 4 * clk->idx;\n\n\tdebugfs_create_regset32(\"registers\", 0400, dentry, regset);\n}\n#else\n#define jh71x0_clk_debug_init NULL\n#endif\n\nstatic const struct clk_ops jh71x0_clk_gate_ops = {\n\t.enable = jh71x0_clk_enable,\n\t.disable = jh71x0_clk_disable,\n\t.is_enabled = jh71x0_clk_is_enabled,\n\t.debug_init = jh71x0_clk_debug_init,\n};\n\nstatic const struct clk_ops jh71x0_clk_div_ops = {\n\t.recalc_rate = jh71x0_clk_recalc_rate,\n\t.determine_rate = jh71x0_clk_determine_rate,\n\t.set_rate = jh71x0_clk_set_rate,\n\t.debug_init = jh71x0_clk_debug_init,\n};\n\nstatic const struct clk_ops jh71x0_clk_fdiv_ops = {\n\t.recalc_rate = jh71x0_clk_frac_recalc_rate,\n\t.determine_rate = jh71x0_clk_frac_determine_rate,\n\t.set_rate = jh71x0_clk_frac_set_rate,\n\t.debug_init = jh71x0_clk_debug_init,\n};\n\nstatic const struct clk_ops jh71x0_clk_gdiv_ops = {\n\t.enable = jh71x0_clk_enable,\n\t.disable = jh71x0_clk_disable,\n\t.is_enabled = jh71x0_clk_is_enabled,\n\t.recalc_rate = jh71x0_clk_recalc_rate,\n\t.determine_rate = jh71x0_clk_determine_rate,\n\t.set_rate = jh71x0_clk_set_rate,\n\t.debug_init = jh71x0_clk_debug_init,\n};\n\nstatic const struct clk_ops jh71x0_clk_mux_ops = {\n\t.determine_rate = __clk_mux_determine_rate,\n\t.set_parent = jh71x0_clk_set_parent,\n\t.get_parent = jh71x0_clk_get_parent,\n\t.debug_init = jh71x0_clk_debug_init,\n};\n\nstatic const struct clk_ops jh71x0_clk_gmux_ops = {\n\t.enable = jh71x0_clk_enable,\n\t.disable = jh71x0_clk_disable,\n\t.is_enabled = jh71x0_clk_is_enabled,\n\t.determine_rate = __clk_mux_determine_rate,\n\t.set_parent = jh71x0_clk_set_parent,\n\t.get_parent = jh71x0_clk_get_parent,\n\t.debug_init = jh71x0_clk_debug_init,\n};\n\nstatic const struct clk_ops jh71x0_clk_mdiv_ops = {\n\t.recalc_rate = jh71x0_clk_recalc_rate,\n\t.determine_rate = jh71x0_clk_determine_rate,\n\t.get_parent = jh71x0_clk_get_parent,\n\t.set_parent = jh71x0_clk_set_parent,\n\t.set_rate = jh71x0_clk_set_rate,\n\t.debug_init = jh71x0_clk_debug_init,\n};\n\nstatic const struct clk_ops jh71x0_clk_gmd_ops = {\n\t.enable = jh71x0_clk_enable,\n\t.disable = jh71x0_clk_disable,\n\t.is_enabled = jh71x0_clk_is_enabled,\n\t.recalc_rate = jh71x0_clk_recalc_rate,\n\t.determine_rate = jh71x0_clk_determine_rate,\n\t.get_parent = jh71x0_clk_get_parent,\n\t.set_parent = jh71x0_clk_set_parent,\n\t.set_rate = jh71x0_clk_set_rate,\n\t.debug_init = jh71x0_clk_debug_init,\n};\n\nstatic const struct clk_ops jh71x0_clk_inv_ops = {\n\t.get_phase = jh71x0_clk_get_phase,\n\t.set_phase = jh71x0_clk_set_phase,\n\t.debug_init = jh71x0_clk_debug_init,\n};\n\nconst struct clk_ops *starfive_jh71x0_clk_ops(u32 max)\n{\n\tif (max & JH71X0_CLK_DIV_MASK) {\n\t\tif (max & JH71X0_CLK_MUX_MASK) {\n\t\t\tif (max & JH71X0_CLK_ENABLE)\n\t\t\t\treturn &jh71x0_clk_gmd_ops;\n\t\t\treturn &jh71x0_clk_mdiv_ops;\n\t\t}\n\t\tif (max & JH71X0_CLK_ENABLE)\n\t\t\treturn &jh71x0_clk_gdiv_ops;\n\t\tif (max == JH71X0_CLK_FRAC_MAX)\n\t\t\treturn &jh71x0_clk_fdiv_ops;\n\t\treturn &jh71x0_clk_div_ops;\n\t}\n\n\tif (max & JH71X0_CLK_MUX_MASK) {\n\t\tif (max & JH71X0_CLK_ENABLE)\n\t\t\treturn &jh71x0_clk_gmux_ops;\n\t\treturn &jh71x0_clk_mux_ops;\n\t}\n\n\tif (max & JH71X0_CLK_ENABLE)\n\t\treturn &jh71x0_clk_gate_ops;\n\n\treturn &jh71x0_clk_inv_ops;\n}\nEXPORT_SYMBOL_GPL(starfive_jh71x0_clk_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}