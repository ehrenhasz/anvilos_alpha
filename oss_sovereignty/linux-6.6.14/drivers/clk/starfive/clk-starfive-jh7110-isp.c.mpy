{
  "module_name": "clk-starfive-jh7110-isp.c",
  "hash_id": "29730b396b9efaaea25019a209d6ee4c42f94d1917465eeba70c33a1b911b01d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/starfive/clk-starfive-jh7110-isp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <dt-bindings/clock/starfive,jh7110-crg.h>\n\n#include \"clk-starfive-jh7110.h\"\n\n \n#define JH7110_ISPCLK_ISP_TOP_CORE\t\t(JH7110_ISPCLK_END + 0)\n#define JH7110_ISPCLK_ISP_TOP_AXI\t\t(JH7110_ISPCLK_END + 1)\n#define JH7110_ISPCLK_NOC_BUS_ISP_AXI\t\t(JH7110_ISPCLK_END + 2)\n#define JH7110_ISPCLK_DVP_CLK\t\t\t(JH7110_ISPCLK_END + 3)\n#define JH7110_ISPCLK_EXT_END\t\t\t(JH7110_ISPCLK_END + 4)\n\nstatic struct clk_bulk_data jh7110_isp_top_clks[] = {\n\t{ .id = \"isp_top_core\" },\n\t{ .id = \"isp_top_axi\" }\n};\n\nstatic const struct jh71x0_clk_data jh7110_ispclk_data[] = {\n\t \n\tJH71X0__DIV(JH7110_ISPCLK_DOM4_APB_FUNC, \"dom4_apb_func\", 15,\n\t\t    JH7110_ISPCLK_ISP_TOP_AXI),\n\tJH71X0__DIV(JH7110_ISPCLK_MIPI_RX0_PXL, \"mipi_rx0_pxl\", 8,\n\t\t    JH7110_ISPCLK_ISP_TOP_CORE),\n\tJH71X0__INV(JH7110_ISPCLK_DVP_INV, \"dvp_inv\", JH7110_ISPCLK_DVP_CLK),\n\t \n\tJH71X0__DIV(JH7110_ISPCLK_M31DPHY_CFG_IN, \"m31dphy_cfg_in\", 16,\n\t\t    JH7110_ISPCLK_ISP_TOP_CORE),\n\tJH71X0__DIV(JH7110_ISPCLK_M31DPHY_REF_IN, \"m31dphy_ref_in\", 16,\n\t\t    JH7110_ISPCLK_ISP_TOP_CORE),\n\tJH71X0__DIV(JH7110_ISPCLK_M31DPHY_TX_ESC_LAN0, \"m31dphy_tx_esc_lan0\", 60,\n\t\t    JH7110_ISPCLK_ISP_TOP_CORE),\n\tJH71X0_GATE(JH7110_ISPCLK_VIN_APB, \"vin_apb\", 0,\n\t\t    JH7110_ISPCLK_DOM4_APB_FUNC),\n\tJH71X0__DIV(JH7110_ISPCLK_VIN_SYS, \"vin_sys\", 8, JH7110_ISPCLK_ISP_TOP_CORE),\n\tJH71X0_GATE(JH7110_ISPCLK_VIN_PIXEL_IF0, \"vin_pixel_if0\", 0,\n\t\t    JH7110_ISPCLK_MIPI_RX0_PXL),\n\tJH71X0_GATE(JH7110_ISPCLK_VIN_PIXEL_IF1, \"vin_pixel_if1\", 0,\n\t\t    JH7110_ISPCLK_MIPI_RX0_PXL),\n\tJH71X0_GATE(JH7110_ISPCLK_VIN_PIXEL_IF2, \"vin_pixel_if2\", 0,\n\t\t    JH7110_ISPCLK_MIPI_RX0_PXL),\n\tJH71X0_GATE(JH7110_ISPCLK_VIN_PIXEL_IF3, \"vin_pixel_if3\", 0,\n\t\t    JH7110_ISPCLK_MIPI_RX0_PXL),\n\tJH71X0__MUX(JH7110_ISPCLK_VIN_P_AXI_WR, \"vin_p_axi_wr\", 2,\n\t\t    JH7110_ISPCLK_MIPI_RX0_PXL,\n\t\t    JH7110_ISPCLK_DVP_INV),\n\t \n\tJH71X0_GMUX(JH7110_ISPCLK_ISPV2_TOP_WRAPPER_C, \"ispv2_top_wrapper_c\", 0, 2,\n\t\t    JH7110_ISPCLK_MIPI_RX0_PXL,\n\t\t    JH7110_ISPCLK_DVP_INV),\n};\n\nstatic inline int jh7110_isp_top_rst_init(struct jh71x0_clk_priv *priv)\n{\n\tstruct reset_control *top_rsts;\n\n\t \n\ttop_rsts = devm_reset_control_array_get_shared(priv->dev);\n\tif (IS_ERR(top_rsts))\n\t\treturn dev_err_probe(priv->dev, PTR_ERR(top_rsts),\n\t\t\t\t     \"failed to get top resets\\n\");\n\n\treturn reset_control_deassert(top_rsts);\n}\n\nstatic struct clk_hw *jh7110_ispclk_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct jh71x0_clk_priv *priv = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx < JH7110_ISPCLK_END)\n\t\treturn &priv->reg[idx].hw;\n\n\treturn ERR_PTR(-EINVAL);\n}\n\n#ifdef CONFIG_PM\nstatic int jh7110_ispcrg_suspend(struct device *dev)\n{\n\tstruct jh7110_top_sysclk *top = dev_get_drvdata(dev);\n\n\tclk_bulk_disable_unprepare(top->top_clks_num, top->top_clks);\n\n\treturn 0;\n}\n\nstatic int jh7110_ispcrg_resume(struct device *dev)\n{\n\tstruct jh7110_top_sysclk *top = dev_get_drvdata(dev);\n\n\treturn clk_bulk_prepare_enable(top->top_clks_num, top->top_clks);\n}\n\nstatic const struct dev_pm_ops jh7110_ispcrg_pm_ops = {\n\tRUNTIME_PM_OPS(jh7110_ispcrg_suspend, jh7110_ispcrg_resume, NULL)\n};\n#endif\n\nstatic int jh7110_ispcrg_probe(struct platform_device *pdev)\n{\n\tstruct jh71x0_clk_priv *priv;\n\tstruct jh7110_top_sysclk *top;\n\tunsigned int idx;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev,\n\t\t\t    struct_size(priv, reg, JH7110_ISPCLK_END),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\ttop = devm_kzalloc(&pdev->dev, sizeof(*top), GFP_KERNEL);\n\tif (!top)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->rmw_lock);\n\tpriv->dev = &pdev->dev;\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\ttop->top_clks = jh7110_isp_top_clks;\n\ttop->top_clks_num = ARRAY_SIZE(jh7110_isp_top_clks);\n\tret = devm_clk_bulk_get(priv->dev, top->top_clks_num, top->top_clks);\n\tif (ret)\n\t\treturn dev_err_probe(priv->dev, ret, \"failed to get main clocks\\n\");\n\tdev_set_drvdata(priv->dev, top);\n\n\t \n\tpm_runtime_enable(priv->dev);\n\tret = pm_runtime_get_sync(priv->dev);\n\tif (ret < 0)\n\t\treturn dev_err_probe(priv->dev, ret, \"failed to turn on power\\n\");\n\n\tret = jh7110_isp_top_rst_init(priv);\n\tif (ret)\n\t\tgoto err_exit;\n\n\tfor (idx = 0; idx < JH7110_ISPCLK_END; idx++) {\n\t\tu32 max = jh7110_ispclk_data[idx].max;\n\t\tstruct clk_parent_data parents[4] = {};\n\t\tstruct clk_init_data init = {\n\t\t\t.name = jh7110_ispclk_data[idx].name,\n\t\t\t.ops = starfive_jh71x0_clk_ops(max),\n\t\t\t.parent_data = parents,\n\t\t\t.num_parents =\n\t\t\t\t((max & JH71X0_CLK_MUX_MASK) >> JH71X0_CLK_MUX_SHIFT) + 1,\n\t\t\t.flags = jh7110_ispclk_data[idx].flags,\n\t\t};\n\t\tstruct jh71x0_clk *clk = &priv->reg[idx];\n\t\tunsigned int i;\n\t\tconst char *fw_name[JH7110_ISPCLK_EXT_END - JH7110_ISPCLK_END] = {\n\t\t\t\"isp_top_core\",\n\t\t\t\"isp_top_axi\",\n\t\t\t\"noc_bus_isp_axi\",\n\t\t\t\"dvp_clk\"\n\t\t};\n\n\t\tfor (i = 0; i < init.num_parents; i++) {\n\t\t\tunsigned int pidx = jh7110_ispclk_data[idx].parents[i];\n\n\t\t\tif (pidx < JH7110_ISPCLK_END)\n\t\t\t\tparents[i].hw = &priv->reg[pidx].hw;\n\t\t\telse\n\t\t\t\tparents[i].fw_name = fw_name[pidx - JH7110_ISPCLK_END];\n\t\t}\n\n\t\tclk->hw.init = &init;\n\t\tclk->idx = idx;\n\t\tclk->max_div = max & JH71X0_CLK_DIV_MASK;\n\n\t\tret = devm_clk_hw_register(&pdev->dev, &clk->hw);\n\t\tif (ret)\n\t\t\tgoto err_exit;\n\t}\n\n\tret = devm_of_clk_add_hw_provider(&pdev->dev, jh7110_ispclk_get, priv);\n\tif (ret)\n\t\tgoto err_exit;\n\n\tret = jh7110_reset_controller_register(priv, \"rst-isp\", 3);\n\tif (ret)\n\t\tgoto err_exit;\n\n\treturn 0;\n\nerr_exit:\n\tpm_runtime_put_sync(priv->dev);\n\tpm_runtime_disable(priv->dev);\n\treturn ret;\n}\n\nstatic int jh7110_ispcrg_remove(struct platform_device *pdev)\n{\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id jh7110_ispcrg_match[] = {\n\t{ .compatible = \"starfive,jh7110-ispcrg\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, jh7110_ispcrg_match);\n\nstatic struct platform_driver jh7110_ispcrg_driver = {\n\t.probe = jh7110_ispcrg_probe,\n\t.remove = jh7110_ispcrg_remove,\n\t.driver = {\n\t\t.name = \"clk-starfive-jh7110-isp\",\n\t\t.of_match_table = jh7110_ispcrg_match,\n\t\t.pm = pm_ptr(&jh7110_ispcrg_pm_ops),\n\t},\n};\nmodule_platform_driver(jh7110_ispcrg_driver);\n\nMODULE_AUTHOR(\"Xingyu Wu <xingyu.wu@starfivetech.com>\");\nMODULE_DESCRIPTION(\"StarFive JH7110 Image-Signal-Process clock driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}