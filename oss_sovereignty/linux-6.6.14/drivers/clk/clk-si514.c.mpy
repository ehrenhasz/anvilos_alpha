{
  "module_name": "clk-si514.c",
  "hash_id": "368193b452dd8dea1d25e4cc42502f09824100794794f9317b4cf35bdc596aaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-si514.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n \n#define SI514_REG_LP\t\t0\n#define SI514_REG_M_FRAC1\t5\n#define SI514_REG_M_FRAC2\t6\n#define SI514_REG_M_FRAC3\t7\n#define SI514_REG_M_INT_FRAC\t8\n#define SI514_REG_M_INT\t\t9\n#define SI514_REG_HS_DIV\t10\n#define SI514_REG_LS_HS_DIV\t11\n#define SI514_REG_OE_STATE\t14\n#define SI514_REG_RESET\t\t128\n#define SI514_REG_CONTROL\t132\n\n \n#define SI514_RESET_RST\t\tBIT(7)\n\n#define SI514_CONTROL_FCAL\tBIT(0)\n#define SI514_CONTROL_OE\tBIT(2)\n\n#define SI514_MIN_FREQ\t    100000U\n#define SI514_MAX_FREQ\t 250000000U\n\n#define FXO\t\t  31980000U\n\n#define FVCO_MIN\t2080000000U\n#define FVCO_MAX\t2500000000U\n\n#define HS_DIV_MAX\t1022\n\nstruct clk_si514 {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tstruct i2c_client *i2c_client;\n};\n#define to_clk_si514(_hw)\tcontainer_of(_hw, struct clk_si514, hw)\n\n \nstruct clk_si514_muldiv {\n\tu32 m_frac;   \n\tu8 m_int;  \n\tu8 ls_div_bits;  \n\tu16 hs_div;  \n};\n\n \nstatic int si514_enable_output(struct clk_si514 *data, bool enable)\n{\n\treturn regmap_update_bits(data->regmap, SI514_REG_CONTROL,\n\t\tSI514_CONTROL_OE, enable ? SI514_CONTROL_OE : 0);\n}\n\nstatic int si514_prepare(struct clk_hw *hw)\n{\n\tstruct clk_si514 *data = to_clk_si514(hw);\n\n\treturn si514_enable_output(data, true);\n}\n\nstatic void si514_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_si514 *data = to_clk_si514(hw);\n\n\tsi514_enable_output(data, false);\n}\n\nstatic int si514_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_si514 *data = to_clk_si514(hw);\n\tunsigned int val;\n\tint err;\n\n\terr = regmap_read(data->regmap, SI514_REG_CONTROL, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn !!(val & SI514_CONTROL_OE);\n}\n\n \nstatic int si514_get_muldiv(struct clk_si514 *data,\n\tstruct clk_si514_muldiv *settings)\n{\n\tint err;\n\tu8 reg[7];\n\n\terr = regmap_bulk_read(data->regmap, SI514_REG_M_FRAC1,\n\t\t\treg, ARRAY_SIZE(reg));\n\tif (err)\n\t\treturn err;\n\n\tsettings->m_frac = reg[0] | reg[1] << 8 | reg[2] << 16 |\n\t\t\t   (reg[3] & 0x1F) << 24;\n\tsettings->m_int = (reg[4] & 0x3f) << 3 | reg[3] >> 5;\n\tsettings->ls_div_bits = (reg[6] >> 4) & 0x07;\n\tsettings->hs_div = (reg[6] & 0x03) << 8 | reg[5];\n\treturn 0;\n}\n\nstatic int si514_set_muldiv(struct clk_si514 *data,\n\tstruct clk_si514_muldiv *settings)\n{\n\tu8 lp;\n\tu8 reg[7];\n\tint err;\n\n\t \n\t \n\tif (settings->m_int < 65 ||\n\t\t(settings->m_int == 65 && settings->m_frac <= 139575831))\n\t\tlp = 0x22;\n\t \n\telse if (settings->m_int < 67 ||\n\t\t(settings->m_int == 67 && settings->m_frac <= 461581994))\n\t\tlp = 0x23;\n\t \n\telse if (settings->m_int < 72 ||\n\t\t(settings->m_int == 72 && settings->m_frac <= 503383578))\n\t\tlp = 0x33;\n\t \n\telse if (settings->m_int < 75 ||\n\t\t(settings->m_int == 75 && settings->m_frac <= 452724474))\n\t\tlp = 0x34;\n\telse\n\t\tlp = 0x44;\n\n\terr = regmap_write(data->regmap, SI514_REG_LP, lp);\n\tif (err < 0)\n\t\treturn err;\n\n\treg[0] = settings->m_frac;\n\treg[1] = settings->m_frac >> 8;\n\treg[2] = settings->m_frac >> 16;\n\treg[3] = settings->m_frac >> 24 | settings->m_int << 5;\n\treg[4] = settings->m_int >> 3;\n\treg[5] = settings->hs_div;\n\treg[6] = (settings->hs_div >> 8) | (settings->ls_div_bits << 4);\n\n\terr = regmap_bulk_write(data->regmap, SI514_REG_HS_DIV, reg + 5, 2);\n\tif (err < 0)\n\t\treturn err;\n\t \n\treturn regmap_bulk_write(data->regmap, SI514_REG_M_FRAC1, reg, 5);\n}\n\n \nstatic int si514_calc_muldiv(struct clk_si514_muldiv *settings,\n\tunsigned long frequency)\n{\n\tu64 m;\n\tu32 ls_freq;\n\tu32 tmp;\n\tu8 res;\n\n\tif ((frequency < SI514_MIN_FREQ) || (frequency > SI514_MAX_FREQ))\n\t\treturn -EINVAL;\n\n\t \n\tls_freq = frequency;\n\tif (frequency >= (FVCO_MIN / HS_DIV_MAX))\n\t\tsettings->ls_div_bits = 0;\n\telse {\n\t\tres = 1;\n\t\ttmp = 2 * HS_DIV_MAX;\n\t\twhile (tmp <= (HS_DIV_MAX * 32)) {\n\t\t\tif ((frequency * tmp) >= FVCO_MIN)\n\t\t\t\tbreak;\n\t\t\t++res;\n\t\t\ttmp <<= 1;\n\t\t}\n\t\tsettings->ls_div_bits = res;\n\t\tls_freq = frequency << res;\n\t}\n\n\t \n\tsettings->hs_div = DIV_ROUND_UP(FVCO_MIN >> 1, ls_freq) << 1;\n\n\t \n\tm = ((u64)(ls_freq * settings->hs_div) << 29) + (FXO / 2);\n\tdo_div(m, FXO);\n\tsettings->m_frac = (u32)m & (BIT(29) - 1);\n\tsettings->m_int = (u32)(m >> 29);\n\n\treturn 0;\n}\n\n \nstatic unsigned long si514_calc_rate(struct clk_si514_muldiv *settings)\n{\n\tu64 m = settings->m_frac | ((u64)settings->m_int << 29);\n\tu32 d = settings->hs_div * BIT(settings->ls_div_bits);\n\n\treturn ((u32)(((m * FXO) + (FXO / 2)) >> 29)) / d;\n}\n\nstatic unsigned long si514_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_si514 *data = to_clk_si514(hw);\n\tstruct clk_si514_muldiv settings;\n\tint err;\n\n\terr = si514_get_muldiv(data, &settings);\n\tif (err) {\n\t\tdev_err(&data->i2c_client->dev, \"unable to retrieve settings\\n\");\n\t\treturn 0;\n\t}\n\n\treturn si514_calc_rate(&settings);\n}\n\nstatic long si514_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long *parent_rate)\n{\n\tstruct clk_si514_muldiv settings;\n\tint err;\n\n\tif (!rate)\n\t\treturn 0;\n\n\terr = si514_calc_muldiv(&settings, rate);\n\tif (err)\n\t\treturn err;\n\n\treturn si514_calc_rate(&settings);\n}\n\n \nstatic int si514_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_si514 *data = to_clk_si514(hw);\n\tstruct clk_si514_muldiv settings;\n\tunsigned int old_oe_state;\n\tint err;\n\n\terr = si514_calc_muldiv(&settings, rate);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_read(data->regmap, SI514_REG_CONTROL, &old_oe_state);\n\tif (err)\n\t\treturn err;\n\n\tsi514_enable_output(data, false);\n\n\terr = si514_set_muldiv(data, &settings);\n\tif (err < 0)\n\t\treturn err;  \n\n\t \n\terr = regmap_write(data->regmap, SI514_REG_CONTROL, SI514_CONTROL_FCAL);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tusleep_range(10000, 12000);\n\n\tif (old_oe_state & SI514_CONTROL_OE)\n\t\tsi514_enable_output(data, true);\n\n\treturn err;\n}\n\nstatic const struct clk_ops si514_clk_ops = {\n\t.prepare = si514_prepare,\n\t.unprepare = si514_unprepare,\n\t.is_prepared = si514_is_prepared,\n\t.recalc_rate = si514_recalc_rate,\n\t.round_rate = si514_round_rate,\n\t.set_rate = si514_set_rate,\n};\n\nstatic bool si514_regmap_is_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SI514_REG_CONTROL:\n\tcase SI514_REG_RESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool si514_regmap_is_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SI514_REG_LP:\n\tcase SI514_REG_M_FRAC1 ... SI514_REG_LS_HS_DIV:\n\tcase SI514_REG_OE_STATE:\n\tcase SI514_REG_RESET:\n\tcase SI514_REG_CONTROL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config si514_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = SI514_REG_CONTROL,\n\t.writeable_reg = si514_regmap_is_writeable,\n\t.volatile_reg = si514_regmap_is_volatile,\n};\n\nstatic int si514_probe(struct i2c_client *client)\n{\n\tstruct clk_si514 *data;\n\tstruct clk_init_data init;\n\tint err;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinit.ops = &si514_clk_ops;\n\tinit.flags = 0;\n\tinit.num_parents = 0;\n\tdata->hw.init = &init;\n\tdata->i2c_client = client;\n\n\tif (of_property_read_string(client->dev.of_node, \"clock-output-names\",\n\t\t\t&init.name))\n\t\tinit.name = client->dev.of_node->name;\n\n\tdata->regmap = devm_regmap_init_i2c(client, &si514_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(&client->dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(data->regmap);\n\t}\n\n\ti2c_set_clientdata(client, data);\n\n\terr = devm_clk_hw_register(&client->dev, &data->hw);\n\tif (err) {\n\t\tdev_err(&client->dev, \"clock registration failed\\n\");\n\t\treturn err;\n\t}\n\terr = devm_of_clk_add_hw_provider(&client->dev, of_clk_hw_simple_get,\n\t\t\t\t\t  &data->hw);\n\tif (err) {\n\t\tdev_err(&client->dev, \"unable to add clk provider\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id si514_id[] = {\n\t{ \"si514\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, si514_id);\n\nstatic const struct of_device_id clk_si514_of_match[] = {\n\t{ .compatible = \"silabs,si514\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, clk_si514_of_match);\n\nstatic struct i2c_driver si514_driver = {\n\t.driver = {\n\t\t.name = \"si514\",\n\t\t.of_match_table = clk_si514_of_match,\n\t},\n\t.probe\t\t= si514_probe,\n\t.id_table\t= si514_id,\n};\nmodule_i2c_driver(si514_driver);\n\nMODULE_AUTHOR(\"Mike Looijmans <mike.looijmans@topic.nl>\");\nMODULE_DESCRIPTION(\"Si514 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}