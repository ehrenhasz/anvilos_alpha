{
  "module_name": "clk-mt7621.c",
  "hash_id": "160194e17ad090a3adf05fe16071e70588f56625fa75047021dd7509d55727cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ralink/clk-mt7621.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include <dt-bindings/clock/mt7621-clk.h>\n#include <dt-bindings/reset/mt7621-reset.h>\n\n \n#define SYSC_REG_SYSTEM_CONFIG0         0x10\n#define SYSC_REG_SYSTEM_CONFIG1         0x14\n#define SYSC_REG_CLKCFG0\t\t0x2c\n#define SYSC_REG_CLKCFG1\t\t0x30\n#define SYSC_REG_RESET_CTRL\t\t0x34\n#define SYSC_REG_CUR_CLK_STS\t\t0x44\n#define MEMC_REG_CPU_PLL\t\t0x648\n\n#define XTAL_MODE_SEL_MASK\t\tGENMASK(8, 6)\n#define CPU_CLK_SEL_MASK\t\tGENMASK(31, 30)\n#define CUR_CPU_FDIV_MASK\t\tGENMASK(12, 8)\n#define CUR_CPU_FFRAC_MASK\t\tGENMASK(4, 0)\n#define CPU_PLL_PREDIV_MASK\t\tGENMASK(13, 12)\n#define CPU_PLL_FBDIV_MASK\t\tGENMASK(10, 4)\n\nstruct mt7621_clk_priv {\n\tstruct regmap *sysc;\n\tstruct regmap *memc;\n};\n\nstruct mt7621_clk {\n\tstruct clk_hw hw;\n\tstruct mt7621_clk_priv *priv;\n};\n\nstruct mt7621_fixed_clk {\n\tu8 idx;\n\tconst char *name;\n\tconst char *parent_name;\n\tunsigned long rate;\n\tstruct clk_hw *hw;\n};\n\nstruct mt7621_gate {\n\tu8 idx;\n\tconst char *name;\n\tconst char *parent_name;\n\tstruct mt7621_clk_priv *priv;\n\tu32 bit_idx;\n\tstruct clk_hw hw;\n};\n\n#define GATE(_id, _name, _pname, _shift)\t\\\n\t{\t\t\t\t\t\\\n\t\t.idx\t\t= _id,\t\t\\\n\t\t.name\t\t= _name,\t\\\n\t\t.parent_name\t= _pname,\t\\\n\t\t.bit_idx\t= _shift\t\\\n\t}\n\nstatic struct mt7621_gate mt7621_gates[] = {\n\tGATE(MT7621_CLK_HSDMA, \"hsdma\", \"150m\", BIT(5)),\n\tGATE(MT7621_CLK_FE, \"fe\", \"250m\", BIT(6)),\n\tGATE(MT7621_CLK_SP_DIVTX, \"sp_divtx\", \"270m\", BIT(7)),\n\tGATE(MT7621_CLK_TIMER, \"timer\", \"50m\", BIT(8)),\n\tGATE(MT7621_CLK_PCM, \"pcm\", \"270m\", BIT(11)),\n\tGATE(MT7621_CLK_PIO, \"pio\", \"50m\", BIT(13)),\n\tGATE(MT7621_CLK_GDMA, \"gdma\", \"bus\", BIT(14)),\n\tGATE(MT7621_CLK_NAND, \"nand\", \"125m\", BIT(15)),\n\tGATE(MT7621_CLK_I2C, \"i2c\", \"50m\", BIT(16)),\n\tGATE(MT7621_CLK_I2S, \"i2s\", \"270m\", BIT(17)),\n\tGATE(MT7621_CLK_SPI, \"spi\", \"bus\", BIT(18)),\n\tGATE(MT7621_CLK_UART1, \"uart1\", \"50m\", BIT(19)),\n\tGATE(MT7621_CLK_UART2, \"uart2\", \"50m\", BIT(20)),\n\tGATE(MT7621_CLK_UART3, \"uart3\", \"50m\", BIT(21)),\n\tGATE(MT7621_CLK_ETH, \"eth\", \"50m\", BIT(23)),\n\tGATE(MT7621_CLK_PCIE0, \"pcie0\", \"125m\", BIT(24)),\n\tGATE(MT7621_CLK_PCIE1, \"pcie1\", \"125m\", BIT(25)),\n\tGATE(MT7621_CLK_PCIE2, \"pcie2\", \"125m\", BIT(26)),\n\tGATE(MT7621_CLK_CRYPTO, \"crypto\", \"250m\", BIT(29)),\n\tGATE(MT7621_CLK_SHXC, \"shxc\", \"50m\", BIT(30))\n};\n\nstatic inline struct mt7621_gate *to_mt7621_gate(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct mt7621_gate, hw);\n}\n\nstatic int mt7621_gate_enable(struct clk_hw *hw)\n{\n\tstruct mt7621_gate *clk_gate = to_mt7621_gate(hw);\n\tstruct regmap *sysc = clk_gate->priv->sysc;\n\n\treturn regmap_update_bits(sysc, SYSC_REG_CLKCFG1,\n\t\t\t\t  clk_gate->bit_idx, clk_gate->bit_idx);\n}\n\nstatic void mt7621_gate_disable(struct clk_hw *hw)\n{\n\tstruct mt7621_gate *clk_gate = to_mt7621_gate(hw);\n\tstruct regmap *sysc = clk_gate->priv->sysc;\n\n\tregmap_update_bits(sysc, SYSC_REG_CLKCFG1, clk_gate->bit_idx, 0);\n}\n\nstatic int mt7621_gate_is_enabled(struct clk_hw *hw)\n{\n\tstruct mt7621_gate *clk_gate = to_mt7621_gate(hw);\n\tstruct regmap *sysc = clk_gate->priv->sysc;\n\tu32 val;\n\n\tif (regmap_read(sysc, SYSC_REG_CLKCFG1, &val))\n\t\treturn 0;\n\n\treturn val & clk_gate->bit_idx;\n}\n\nstatic const struct clk_ops mt7621_gate_ops = {\n\t.enable = mt7621_gate_enable,\n\t.disable = mt7621_gate_disable,\n\t.is_enabled = mt7621_gate_is_enabled,\n};\n\nstatic int mt7621_gate_ops_init(struct device *dev,\n\t\t\t\tstruct mt7621_gate *sclk)\n{\n\t \n\tstruct clk_init_data init = {\n\t\t.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,\n\t\t.num_parents = 1,\n\t\t.parent_names = &sclk->parent_name,\n\t\t.ops = &mt7621_gate_ops,\n\t\t.name = sclk->name,\n\t};\n\n\tsclk->hw.init = &init;\n\treturn devm_clk_hw_register(dev, &sclk->hw);\n}\n\nstatic int mt7621_register_gates(struct device *dev,\n\t\t\t\t struct clk_hw_onecell_data *clk_data,\n\t\t\t\t struct mt7621_clk_priv *priv)\n{\n\tstruct clk_hw **hws = clk_data->hws;\n\tstruct mt7621_gate *sclk;\n\tint ret, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mt7621_gates); i++) {\n\t\tsclk = &mt7621_gates[i];\n\t\tsclk->priv = priv;\n\t\tret = mt7621_gate_ops_init(dev, sclk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Couldn't register clock %s\\n\", sclk->name);\n\t\t\tgoto err_clk_unreg;\n\t\t}\n\n\t\thws[sclk->idx] = &sclk->hw;\n\t}\n\n\treturn 0;\n\nerr_clk_unreg:\n\twhile (--i >= 0) {\n\t\tsclk = &mt7621_gates[i];\n\t\tclk_hw_unregister(&sclk->hw);\n\t}\n\treturn ret;\n}\n\n#define FIXED(_id, _name, _rate)\t\t\\\n\t{\t\t\t\t\t\\\n\t\t.idx\t\t= _id,\t\t\\\n\t\t.name\t\t= _name,\t\\\n\t\t.parent_name\t= \"xtal\",\t\\\n\t\t.rate\t\t= _rate\t\t\\\n\t}\n\nstatic struct mt7621_fixed_clk mt7621_fixed_clks[] = {\n\tFIXED(MT7621_CLK_50M, \"50m\", 50000000),\n\tFIXED(MT7621_CLK_125M, \"125m\", 125000000),\n\tFIXED(MT7621_CLK_150M, \"150m\", 150000000),\n\tFIXED(MT7621_CLK_250M, \"250m\", 250000000),\n\tFIXED(MT7621_CLK_270M, \"270m\", 270000000),\n};\n\nstatic int mt7621_register_fixed_clocks(struct device *dev,\n\t\t\t\t\tstruct clk_hw_onecell_data *clk_data)\n{\n\tstruct clk_hw **hws = clk_data->hws;\n\tstruct mt7621_fixed_clk *sclk;\n\tint ret, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mt7621_fixed_clks); i++) {\n\t\tsclk = &mt7621_fixed_clks[i];\n\t\tsclk->hw = clk_hw_register_fixed_rate(dev, sclk->name,\n\t\t\t\t\t\t      sclk->parent_name, 0,\n\t\t\t\t\t\t      sclk->rate);\n\t\tif (IS_ERR(sclk->hw)) {\n\t\t\tdev_err(dev, \"Couldn't register clock %s\\n\", sclk->name);\n\t\t\tret = PTR_ERR(sclk->hw);\n\t\t\tgoto err_clk_unreg;\n\t\t}\n\n\t\thws[sclk->idx] = sclk->hw;\n\t}\n\n\treturn 0;\n\nerr_clk_unreg:\n\twhile (--i >= 0) {\n\t\tsclk = &mt7621_fixed_clks[i];\n\t\tclk_hw_unregister_fixed_rate(sclk->hw);\n\t}\n\treturn ret;\n}\n\nstatic inline struct mt7621_clk *to_mt7621_clk(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct mt7621_clk, hw);\n}\n\nstatic unsigned long mt7621_xtal_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct mt7621_clk *clk = to_mt7621_clk(hw);\n\tstruct regmap *sysc = clk->priv->sysc;\n\tu32 val;\n\n\tregmap_read(sysc, SYSC_REG_SYSTEM_CONFIG0, &val);\n\tval = FIELD_GET(XTAL_MODE_SEL_MASK, val);\n\n\tif (val <= 2)\n\t\treturn 20000000;\n\tif (val <= 5)\n\t\treturn 40000000;\n\n\treturn 25000000;\n}\n\nstatic unsigned long mt7621_cpu_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long xtal_clk)\n{\n\tstatic const u32 prediv_tbl[] = { 0, 1, 2, 2 };\n\tstruct mt7621_clk *clk = to_mt7621_clk(hw);\n\tstruct regmap *sysc = clk->priv->sysc;\n\tstruct regmap *memc = clk->priv->memc;\n\tu32 clkcfg, clk_sel, curclk, ffiv, ffrac;\n\tu32 pll, prediv, fbdiv;\n\tunsigned long cpu_clk;\n\n\tregmap_read(sysc, SYSC_REG_CLKCFG0, &clkcfg);\n\tclk_sel = FIELD_GET(CPU_CLK_SEL_MASK, clkcfg);\n\n\tregmap_read(sysc, SYSC_REG_CUR_CLK_STS, &curclk);\n\tffiv = FIELD_GET(CUR_CPU_FDIV_MASK, curclk);\n\tffrac = FIELD_GET(CUR_CPU_FFRAC_MASK, curclk);\n\n\tswitch (clk_sel) {\n\tcase 0:\n\t\tcpu_clk = 500000000;\n\t\tbreak;\n\tcase 1:\n\t\tregmap_read(memc, MEMC_REG_CPU_PLL, &pll);\n\t\tfbdiv = FIELD_GET(CPU_PLL_FBDIV_MASK, pll);\n\t\tprediv = FIELD_GET(CPU_PLL_PREDIV_MASK, pll);\n\t\tcpu_clk = ((fbdiv + 1) * xtal_clk) >> prediv_tbl[prediv];\n\t\tbreak;\n\tdefault:\n\t\tcpu_clk = xtal_clk;\n\t}\n\n\treturn cpu_clk / ffiv * ffrac;\n}\n\nstatic unsigned long mt7621_bus_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\treturn parent_rate / 4;\n}\n\n#define CLK_BASE(_name, _parent, _recalc) {\t\t\t\t\\\n\t.init = &(struct clk_init_data) {\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.ops = &(const struct clk_ops) {\t\t\t\\\n\t\t\t.recalc_rate = _recalc,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.parent_data = &(const struct clk_parent_data) {\t\\\n\t\t\t.name = _parent,\t\t\t\t\\\n\t\t\t.fw_name = _parent\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.num_parents = _parent ? 1 : 0\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nstatic struct mt7621_clk mt7621_clks_base[] = {\n\t{ CLK_BASE(\"xtal\", NULL, mt7621_xtal_recalc_rate) },\n\t{ CLK_BASE(\"cpu\", \"xtal\", mt7621_cpu_recalc_rate) },\n\t{ CLK_BASE(\"bus\", \"cpu\", mt7621_bus_recalc_rate) },\n};\n\nstatic struct clk_hw *mt7621_clk_early[MT7621_CLK_MAX];\n\nstatic int mt7621_register_early_clocks(struct device_node *np,\n\t\t\t\t\tstruct clk_hw_onecell_data *clk_data,\n\t\t\t\t\tstruct mt7621_clk_priv *priv)\n{\n\tstruct clk_hw **hws = clk_data->hws;\n\tstruct mt7621_clk *sclk;\n\tint ret, i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(mt7621_clks_base); i++) {\n\t\tsclk = &mt7621_clks_base[i];\n\t\tsclk->priv = priv;\n\t\tret = of_clk_hw_register(np, &sclk->hw);\n\t\tif (ret) {\n\t\t\tpr_err(\"Couldn't register top clock %i\\n\", i);\n\t\t\tgoto err_clk_unreg;\n\t\t}\n\n\t\thws[i] = &sclk->hw;\n\t\tmt7621_clk_early[i] = &sclk->hw;\n\t}\n\n\tfor (j = i; j < MT7621_CLK_MAX; j++)\n\t\tmt7621_clk_early[j] = ERR_PTR(-EPROBE_DEFER);\n\n\treturn 0;\n\nerr_clk_unreg:\n\twhile (--i >= 0) {\n\t\tsclk = &mt7621_clks_base[i];\n\t\tclk_hw_unregister(&sclk->hw);\n\t}\n\treturn ret;\n}\n\nstatic void __init mt7621_clk_init(struct device_node *node)\n{\n\tstruct mt7621_clk_priv *priv;\n\tstruct clk_hw_onecell_data *clk_data;\n\tint ret, i, count;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn;\n\n\tpriv->sysc = syscon_node_to_regmap(node);\n\tif (IS_ERR(priv->sysc)) {\n\t\tpr_err(\"Could not get sysc syscon regmap\\n\");\n\t\tgoto free_clk_priv;\n\t}\n\n\tpriv->memc = syscon_regmap_lookup_by_phandle(node, \"ralink,memctl\");\n\tif (IS_ERR(priv->memc)) {\n\t\tpr_err(\"Could not get memc syscon regmap\\n\");\n\t\tgoto free_clk_priv;\n\t}\n\n\tcount = ARRAY_SIZE(mt7621_clks_base) +\n\t\tARRAY_SIZE(mt7621_fixed_clks) + ARRAY_SIZE(mt7621_gates);\n\tclk_data = kzalloc(struct_size(clk_data, hws, count), GFP_KERNEL);\n\tif (!clk_data)\n\t\tgoto free_clk_priv;\n\n\tret = mt7621_register_early_clocks(node, clk_data, priv);\n\tif (ret) {\n\t\tpr_err(\"Couldn't register top clocks\\n\");\n\t\tgoto free_clk_data;\n\t}\n\n\tclk_data->num = count;\n\n\tret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, clk_data);\n\tif (ret) {\n\t\tpr_err(\"Couldn't add clk hw provider\\n\");\n\t\tgoto unreg_clk_top;\n\t}\n\n\treturn;\n\nunreg_clk_top:\n\tfor (i = 0; i < ARRAY_SIZE(mt7621_clks_base); i++) {\n\t\tstruct mt7621_clk *sclk = &mt7621_clks_base[i];\n\n\t\tclk_hw_unregister(&sclk->hw);\n\t}\n\nfree_clk_data:\n\tkfree(clk_data);\n\nfree_clk_priv:\n\tkfree(priv);\n}\nCLK_OF_DECLARE_DRIVER(mt7621_clk, \"mediatek,mt7621-sysc\", mt7621_clk_init);\n\nstruct mt7621_rst {\n\tstruct reset_controller_dev rcdev;\n\tstruct regmap *sysc;\n};\n\nstatic struct mt7621_rst *to_mt7621_rst(struct reset_controller_dev *dev)\n{\n\treturn container_of(dev, struct mt7621_rst, rcdev);\n}\n\nstatic int mt7621_assert_device(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\tstruct mt7621_rst *data = to_mt7621_rst(rcdev);\n\tstruct regmap *sysc = data->sysc;\n\n\treturn regmap_update_bits(sysc, SYSC_REG_RESET_CTRL, BIT(id), BIT(id));\n}\n\nstatic int mt7621_deassert_device(struct reset_controller_dev *rcdev,\n\t\t\t\t  unsigned long id)\n{\n\tstruct mt7621_rst *data = to_mt7621_rst(rcdev);\n\tstruct regmap *sysc = data->sysc;\n\n\treturn regmap_update_bits(sysc, SYSC_REG_RESET_CTRL, BIT(id), 0);\n}\n\nstatic int mt7621_reset_device(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tint ret;\n\n\tret = mt7621_assert_device(rcdev, id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mt7621_deassert_device(rcdev, id);\n}\n\nstatic int mt7621_rst_xlate(struct reset_controller_dev *rcdev,\n\t\t\t    const struct of_phandle_args *reset_spec)\n{\n\tunsigned long id = reset_spec->args[0];\n\n\tif (id == MT7621_RST_SYS || id >= rcdev->nr_resets)\n\t\treturn -EINVAL;\n\n\treturn id;\n}\n\nstatic const struct reset_control_ops reset_ops = {\n\t.reset = mt7621_reset_device,\n\t.assert = mt7621_assert_device,\n\t.deassert = mt7621_deassert_device\n};\n\nstatic int mt7621_reset_init(struct device *dev, struct regmap *sysc)\n{\n\tstruct mt7621_rst *rst_data;\n\n\trst_data = devm_kzalloc(dev, sizeof(*rst_data), GFP_KERNEL);\n\tif (!rst_data)\n\t\treturn -ENOMEM;\n\n\trst_data->sysc = sysc;\n\trst_data->rcdev.ops = &reset_ops;\n\trst_data->rcdev.owner = THIS_MODULE;\n\trst_data->rcdev.nr_resets = 32;\n\trst_data->rcdev.of_reset_n_cells = 1;\n\trst_data->rcdev.of_xlate = mt7621_rst_xlate;\n\trst_data->rcdev.of_node = dev_of_node(dev);\n\n\treturn devm_reset_controller_register(dev, &rst_data->rcdev);\n}\n\nstatic int mt7621_clk_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct clk_hw_onecell_data *clk_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct mt7621_clk_priv *priv;\n\tint ret, i, count;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->sysc = syscon_node_to_regmap(np);\n\tif (IS_ERR(priv->sysc)) {\n\t\tret = PTR_ERR(priv->sysc);\n\t\tdev_err(dev, \"Could not get sysc syscon regmap\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->memc = syscon_regmap_lookup_by_phandle(np, \"ralink,memctl\");\n\tif (IS_ERR(priv->memc)) {\n\t\tret = PTR_ERR(priv->memc);\n\t\tdev_err(dev, \"Could not get memc syscon regmap\\n\");\n\t\treturn ret;\n\t}\n\n\tret = mt7621_reset_init(dev, priv->sysc);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not init reset controller\\n\");\n\t\treturn ret;\n\t}\n\n\tcount = ARRAY_SIZE(mt7621_clks_base) +\n\t\tARRAY_SIZE(mt7621_fixed_clks) + ARRAY_SIZE(mt7621_gates);\n\tclk_data = devm_kzalloc(dev, struct_size(clk_data, hws, count),\n\t\t\t\tGFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\tclk_data->num = count;\n\n\tfor (i = 0; i < ARRAY_SIZE(mt7621_clks_base); i++)\n\t\tclk_data->hws[i] = mt7621_clk_early[i];\n\n\tret = mt7621_register_fixed_clocks(dev, clk_data);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't register fixed clocks\\n\");\n\t\treturn ret;\n\t}\n\n\tret = mt7621_register_gates(dev, clk_data, priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't register fixed clock gates\\n\");\n\t\tgoto unreg_clk_fixed;\n\t}\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't add clk hw provider\\n\");\n\t\tgoto unreg_clk_gates;\n\t}\n\n\treturn 0;\n\nunreg_clk_gates:\n\tfor (i = 0; i < ARRAY_SIZE(mt7621_gates); i++) {\n\t\tstruct mt7621_gate *sclk = &mt7621_gates[i];\n\n\t\tclk_hw_unregister(&sclk->hw);\n\t}\n\nunreg_clk_fixed:\n\tfor (i = 0; i < ARRAY_SIZE(mt7621_fixed_clks); i++) {\n\t\tstruct mt7621_fixed_clk *sclk = &mt7621_fixed_clks[i];\n\n\t\tclk_hw_unregister_fixed_rate(sclk->hw);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct of_device_id mt7621_clk_of_match[] = {\n\t{ .compatible = \"mediatek,mt7621-sysc\" },\n\t{}\n};\n\nstatic struct platform_driver mt7621_clk_driver = {\n\t.probe = mt7621_clk_probe,\n\t.driver = {\n\t\t.name = \"mt7621-clk\",\n\t\t.of_match_table = mt7621_clk_of_match,\n\t},\n};\n\nstatic int __init mt7621_clk_reset_init(void)\n{\n\treturn platform_driver_register(&mt7621_clk_driver);\n}\narch_initcall(mt7621_clk_reset_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}