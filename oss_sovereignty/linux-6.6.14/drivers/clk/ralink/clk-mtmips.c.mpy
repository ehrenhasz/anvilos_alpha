{
  "module_name": "clk-mtmips.c",
  "hash_id": "52a976ec42448b00d53ef61acd530c4567f1a0adfd0554f82907b3fd8fa2e199",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ralink/clk-mtmips.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk-provider.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n\n \n#define SYSC_REG_SYSTEM_CONFIG\t\t0x10\n#define SYSC_REG_CLKCFG0\t\t0x2c\n#define SYSC_REG_RESET_CTRL\t\t0x34\n#define SYSC_REG_CPU_SYS_CLKCFG\t\t0x3c\n#define SYSC_REG_CPLL_CONFIG0\t\t0x54\n#define SYSC_REG_CPLL_CONFIG1\t\t0x58\n\n \n#define RT2880_CONFIG_CPUCLK_SHIFT\t20\n#define RT2880_CONFIG_CPUCLK_MASK\t0x3\n#define RT2880_CONFIG_CPUCLK_250\t0x0\n#define RT2880_CONFIG_CPUCLK_266\t0x1\n#define RT2880_CONFIG_CPUCLK_280\t0x2\n#define RT2880_CONFIG_CPUCLK_300\t0x3\n\n \n#define RT305X_SYSCFG_CPUCLK_SHIFT\t18\n#define RT305X_SYSCFG_CPUCLK_MASK\t0x1\n#define RT305X_SYSCFG_CPUCLK_LOW\t0x0\n#define RT305X_SYSCFG_CPUCLK_HIGH\t0x1\n\n \n#define RT3352_SYSCFG0_CPUCLK_SHIFT\t8\n#define RT3352_SYSCFG0_CPUCLK_MASK\t0x1\n#define RT3352_SYSCFG0_CPUCLK_LOW\t0x0\n#define RT3352_SYSCFG0_CPUCLK_HIGH\t0x1\n\n \n#define RT3883_SYSCFG0_DRAM_TYPE_DDR2\tBIT(17)\n#define RT3883_SYSCFG0_CPUCLK_SHIFT\t8\n#define RT3883_SYSCFG0_CPUCLK_MASK\t0x3\n#define RT3883_SYSCFG0_CPUCLK_250\t0x0\n#define RT3883_SYSCFG0_CPUCLK_384\t0x1\n#define RT3883_SYSCFG0_CPUCLK_480\t0x2\n#define RT3883_SYSCFG0_CPUCLK_500\t0x3\n\n \n#define RT5350_CLKCFG0_XTAL_SEL\t\tBIT(20)\n#define RT5350_SYSCFG0_CPUCLK_SHIFT\t8\n#define RT5350_SYSCFG0_CPUCLK_MASK\t0x3\n#define RT5350_SYSCFG0_CPUCLK_360\t0x0\n#define RT5350_SYSCFG0_CPUCLK_320\t0x2\n#define RT5350_SYSCFG0_CPUCLK_300\t0x3\n\n \n#define MT7620_XTAL_FREQ_SEL\t\tBIT(6)\n#define CPLL_CFG0_SW_CFG\t\tBIT(31)\n#define CPLL_CFG0_PLL_MULT_RATIO_SHIFT\t16\n#define CPLL_CFG0_PLL_MULT_RATIO_MASK   0x7\n#define CPLL_CFG0_LC_CURFCK\t\tBIT(15)\n#define CPLL_CFG0_BYPASS_REF_CLK\tBIT(14)\n#define CPLL_CFG0_PLL_DIV_RATIO_SHIFT\t10\n#define CPLL_CFG0_PLL_DIV_RATIO_MASK\t0x3\n#define CPLL_CFG1_CPU_AUX1\t\tBIT(25)\n#define CPLL_CFG1_CPU_AUX0\t\tBIT(24)\n#define CLKCFG0_PERI_CLK_SEL\t\tBIT(4)\n#define CPU_SYS_CLKCFG_OCP_RATIO_SHIFT\t16\n#define CPU_SYS_CLKCFG_OCP_RATIO_MASK\t0xf\n#define CPU_SYS_CLKCFG_OCP_RATIO_1\t0\t \n#define CPU_SYS_CLKCFG_OCP_RATIO_1_5\t1\t \n#define CPU_SYS_CLKCFG_OCP_RATIO_2\t2\t \n#define CPU_SYS_CLKCFG_OCP_RATIO_2_5\t3        \n#define CPU_SYS_CLKCFG_OCP_RATIO_3\t4\t \n#define CPU_SYS_CLKCFG_OCP_RATIO_3_5\t5\t \n#define CPU_SYS_CLKCFG_OCP_RATIO_4\t6\t \n#define CPU_SYS_CLKCFG_OCP_RATIO_5\t7\t \n#define CPU_SYS_CLKCFG_OCP_RATIO_10\t8\t \n#define CPU_SYS_CLKCFG_CPU_FDIV_SHIFT\t8\n#define CPU_SYS_CLKCFG_CPU_FDIV_MASK\t0x1f\n#define CPU_SYS_CLKCFG_CPU_FFRAC_SHIFT\t0\n#define CPU_SYS_CLKCFG_CPU_FFRAC_MASK\t0x1f\n\n \n#define CLKCFG_FDIV_MASK\t\t0x1f00\n#define CLKCFG_FDIV_USB_VAL\t\t0x0300\n#define CLKCFG_FFRAC_MASK\t\t0x001f\n#define CLKCFG_FFRAC_USB_VAL\t\t0x0003\n\nstruct mtmips_clk;\nstruct mtmips_clk_fixed;\nstruct mtmips_clk_factor;\n\nstruct mtmips_clk_data {\n\tstruct mtmips_clk *clk_base;\n\tsize_t num_clk_base;\n\tstruct mtmips_clk_fixed *clk_fixed;\n\tsize_t num_clk_fixed;\n\tstruct mtmips_clk_factor *clk_factor;\n\tsize_t num_clk_factor;\n\tstruct mtmips_clk *clk_periph;\n\tsize_t num_clk_periph;\n};\n\nstruct mtmips_clk_priv {\n\tstruct regmap *sysc;\n\tconst struct mtmips_clk_data *data;\n};\n\nstruct mtmips_clk {\n\tstruct clk_hw hw;\n\tstruct mtmips_clk_priv *priv;\n};\n\nstruct mtmips_clk_fixed {\n\tconst char *name;\n\tconst char *parent;\n\tunsigned long rate;\n\tstruct clk_hw *hw;\n};\n\nstruct mtmips_clk_factor {\n\tconst char *name;\n\tconst char *parent;\n\tint mult;\n\tint div;\n\tunsigned long flags;\n\tstruct clk_hw *hw;\n};\n\nstatic unsigned long mtmips_pherip_clk_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\treturn parent_rate;\n}\n\nstatic const struct clk_ops mtmips_periph_clk_ops = {\n\t.recalc_rate = mtmips_pherip_clk_rate,\n};\n\n#define CLK_PERIPH(_name, _parent) {\t\t\t\t\\\n\t.init = &(const struct clk_init_data) {\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\\\n\t\t.ops = &mtmips_periph_clk_ops,\t\t\t\\\n\t\t.parent_data = &(const struct clk_parent_data) {\\\n\t\t\t.name = _parent,\t\t\t\\\n\t\t\t.fw_name = _parent\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.num_parents = 1,\t\t\t\t\\\n\t\t \t\t\t\t\t\t\\\n\t\t.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\nstatic struct mtmips_clk rt2880_pherip_clks[] = {\n\t{ CLK_PERIPH(\"300100.timer\", \"bus\") },\n\t{ CLK_PERIPH(\"300120.watchdog\", \"bus\") },\n\t{ CLK_PERIPH(\"300500.uart\", \"bus\") },\n\t{ CLK_PERIPH(\"300900.i2c\", \"bus\") },\n\t{ CLK_PERIPH(\"300c00.uartlite\", \"bus\") },\n\t{ CLK_PERIPH(\"400000.ethernet\", \"bus\") },\n\t{ CLK_PERIPH(\"480000.wmac\", \"xtal\") }\n};\n\nstatic struct mtmips_clk rt305x_pherip_clks[] = {\n\t{ CLK_PERIPH(\"10000100.timer\", \"bus\") },\n\t{ CLK_PERIPH(\"10000120.watchdog\", \"bus\") },\n\t{ CLK_PERIPH(\"10000500.uart\", \"bus\") },\n\t{ CLK_PERIPH(\"10000900.i2c\", \"bus\") },\n\t{ CLK_PERIPH(\"10000a00.i2s\", \"bus\") },\n\t{ CLK_PERIPH(\"10000b00.spi\", \"bus\") },\n\t{ CLK_PERIPH(\"10000b40.spi\", \"bus\") },\n\t{ CLK_PERIPH(\"10000c00.uartlite\", \"bus\") },\n\t{ CLK_PERIPH(\"10100000.ethernet\", \"bus\") },\n\t{ CLK_PERIPH(\"10180000.wmac\", \"xtal\") }\n};\n\nstatic struct mtmips_clk rt5350_pherip_clks[] = {\n\t{ CLK_PERIPH(\"10000100.timer\", \"bus\") },\n\t{ CLK_PERIPH(\"10000120.watchdog\", \"bus\") },\n\t{ CLK_PERIPH(\"10000500.uart\", \"periph\") },\n\t{ CLK_PERIPH(\"10000900.i2c\", \"periph\") },\n\t{ CLK_PERIPH(\"10000a00.i2s\", \"periph\") },\n\t{ CLK_PERIPH(\"10000b00.spi\", \"bus\") },\n\t{ CLK_PERIPH(\"10000b40.spi\", \"bus\") },\n\t{ CLK_PERIPH(\"10000c00.uartlite\", \"periph\") },\n\t{ CLK_PERIPH(\"10100000.ethernet\", \"bus\") },\n\t{ CLK_PERIPH(\"10180000.wmac\", \"xtal\") }\n};\n\nstatic struct mtmips_clk mt7620_pherip_clks[] = {\n\t{ CLK_PERIPH(\"10000100.timer\", \"periph\") },\n\t{ CLK_PERIPH(\"10000120.watchdog\", \"periph\") },\n\t{ CLK_PERIPH(\"10000500.uart\", \"periph\") },\n\t{ CLK_PERIPH(\"10000900.i2c\", \"periph\") },\n\t{ CLK_PERIPH(\"10000a00.i2s\", \"periph\") },\n\t{ CLK_PERIPH(\"10000b00.spi\", \"bus\") },\n\t{ CLK_PERIPH(\"10000b40.spi\", \"bus\") },\n\t{ CLK_PERIPH(\"10000c00.uartlite\", \"periph\") },\n\t{ CLK_PERIPH(\"10180000.wmac\", \"xtal\") }\n};\n\nstatic struct mtmips_clk mt76x8_pherip_clks[] = {\n\t{ CLK_PERIPH(\"10000100.timer\", \"periph\") },\n\t{ CLK_PERIPH(\"10000120.watchdog\", \"periph\") },\n\t{ CLK_PERIPH(\"10000900.i2c\", \"periph\") },\n\t{ CLK_PERIPH(\"10000a00.i2s\", \"pcmi2s\") },\n\t{ CLK_PERIPH(\"10000b00.spi\", \"bus\") },\n\t{ CLK_PERIPH(\"10000b40.spi\", \"bus\") },\n\t{ CLK_PERIPH(\"10000c00.uart0\", \"periph\") },\n\t{ CLK_PERIPH(\"10000d00.uart1\", \"periph\") },\n\t{ CLK_PERIPH(\"10000e00.uart2\", \"periph\") },\n\t{ CLK_PERIPH(\"10300000.wmac\", \"xtal\") }\n};\n\nstatic int mtmips_register_pherip_clocks(struct device_node *np,\n\t\t\t\t\t struct clk_hw_onecell_data *clk_data,\n\t\t\t\t\t struct mtmips_clk_priv *priv)\n{\n\tstruct clk_hw **hws = clk_data->hws;\n\tstruct mtmips_clk *sclk;\n\tsize_t idx_start = priv->data->num_clk_base + priv->data->num_clk_fixed +\n\t\t\t   priv->data->num_clk_factor;\n\tint ret, i;\n\n\tfor (i = 0; i < priv->data->num_clk_periph; i++) {\n\t\tint idx = idx_start + i;\n\n\t\tsclk = &priv->data->clk_periph[i];\n\t\tret = of_clk_hw_register(np, &sclk->hw);\n\t\tif (ret) {\n\t\t\tpr_err(\"Couldn't register peripheral clock %d\\n\", idx);\n\t\t\tgoto err_clk_unreg;\n\t\t}\n\n\t\thws[idx] = &sclk->hw;\n\t}\n\n\treturn 0;\n\nerr_clk_unreg:\n\twhile (--i >= 0) {\n\t\tsclk = &priv->data->clk_periph[i];\n\t\tclk_hw_unregister(&sclk->hw);\n\t}\n\treturn ret;\n}\n\n#define CLK_FIXED(_name, _parent, _rate) \\\n\t{\t\t\t\t \\\n\t\t.name = _name,\t\t \\\n\t\t.parent = _parent,\t \\\n\t\t.rate = _rate\t\t \\\n\t}\n\nstatic struct mtmips_clk_fixed rt305x_fixed_clocks[] = {\n\tCLK_FIXED(\"xtal\", NULL, 40000000)\n};\n\nstatic struct mtmips_clk_fixed rt3352_fixed_clocks[] = {\n\tCLK_FIXED(\"periph\", \"xtal\", 40000000)\n};\n\nstatic struct mtmips_clk_fixed mt76x8_fixed_clocks[] = {\n\tCLK_FIXED(\"pcmi2s\", \"xtal\", 480000000),\n\tCLK_FIXED(\"periph\", \"xtal\", 40000000)\n};\n\nstatic int mtmips_register_fixed_clocks(struct clk_hw_onecell_data *clk_data,\n\t\t\t\t\tstruct mtmips_clk_priv *priv)\n{\n\tstruct clk_hw **hws = clk_data->hws;\n\tstruct mtmips_clk_fixed *sclk;\n\tsize_t idx_start = priv->data->num_clk_base;\n\tint ret, i;\n\n\tfor (i = 0; i < priv->data->num_clk_fixed; i++) {\n\t\tint idx = idx_start + i;\n\n\t\tsclk = &priv->data->clk_fixed[i];\n\t\tsclk->hw = clk_hw_register_fixed_rate(NULL, sclk->name,\n\t\t\t\t\t\t      sclk->parent, 0,\n\t\t\t\t\t\t      sclk->rate);\n\t\tif (IS_ERR(sclk->hw)) {\n\t\t\tret = PTR_ERR(sclk->hw);\n\t\t\tpr_err(\"Couldn't register fixed clock %d\\n\", idx);\n\t\t\tgoto err_clk_unreg;\n\t\t}\n\n\t\thws[idx] = sclk->hw;\n\t}\n\n\treturn 0;\n\nerr_clk_unreg:\n\twhile (--i >= 0) {\n\t\tsclk = &priv->data->clk_fixed[i];\n\t\tclk_hw_unregister_fixed_rate(sclk->hw);\n\t}\n\treturn ret;\n}\n\n#define CLK_FACTOR(_name, _parent, _mult, _div)\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\\\n\t\t.parent = _parent,\t\t\t\\\n\t\t.mult = _mult,\t\t\t\t\\\n\t\t.div = _div,\t\t\t\t\\\n\t\t.flags = CLK_SET_RATE_PARENT\t\t\\\n\t}\n\nstatic struct mtmips_clk_factor rt2880_factor_clocks[] = {\n\tCLK_FACTOR(\"bus\", \"cpu\", 1, 2)\n};\n\nstatic struct mtmips_clk_factor rt305x_factor_clocks[] = {\n\tCLK_FACTOR(\"bus\", \"cpu\", 1, 3)\n};\n\nstatic int mtmips_register_factor_clocks(struct clk_hw_onecell_data *clk_data,\n\t\t\t\t\t struct mtmips_clk_priv *priv)\n{\n\tstruct clk_hw **hws = clk_data->hws;\n\tstruct mtmips_clk_factor *sclk;\n\tsize_t idx_start = priv->data->num_clk_base + priv->data->num_clk_fixed;\n\tint ret, i;\n\n\tfor (i = 0; i < priv->data->num_clk_factor; i++) {\n\t\tint idx = idx_start + i;\n\n\t\tsclk = &priv->data->clk_factor[i];\n\t\tsclk->hw = clk_hw_register_fixed_factor(NULL, sclk->name,\n\t\t\t\t\t\t  sclk->parent, sclk->flags,\n\t\t\t\t\t\t  sclk->mult, sclk->div);\n\t\tif (IS_ERR(sclk->hw)) {\n\t\t\tret = PTR_ERR(sclk->hw);\n\t\t\tpr_err(\"Couldn't register factor clock %d\\n\", idx);\n\t\t\tgoto err_clk_unreg;\n\t\t}\n\n\t\thws[idx] = sclk->hw;\n\t}\n\n\treturn 0;\n\nerr_clk_unreg:\n\twhile (--i >= 0) {\n\t\tsclk = &priv->data->clk_factor[i];\n\t\tclk_hw_unregister_fixed_factor(sclk->hw);\n\t}\n\treturn ret;\n}\n\nstatic inline struct mtmips_clk *to_mtmips_clk(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct mtmips_clk, hw);\n}\n\nstatic unsigned long rt5350_xtal_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct mtmips_clk *clk = to_mtmips_clk(hw);\n\tstruct regmap *sysc = clk->priv->sysc;\n\tu32 val;\n\n\tregmap_read(sysc, SYSC_REG_SYSTEM_CONFIG, &val);\n\tif (!(val & RT5350_CLKCFG0_XTAL_SEL))\n\t\treturn 20000000;\n\n\treturn 40000000;\n}\n\nstatic unsigned long rt5350_cpu_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long xtal_clk)\n{\n\tstruct mtmips_clk *clk = to_mtmips_clk(hw);\n\tstruct regmap *sysc = clk->priv->sysc;\n\tu32 t;\n\n\tregmap_read(sysc, SYSC_REG_SYSTEM_CONFIG, &t);\n\tt = (t >> RT5350_SYSCFG0_CPUCLK_SHIFT) & RT5350_SYSCFG0_CPUCLK_MASK;\n\n\tswitch (t) {\n\tcase RT5350_SYSCFG0_CPUCLK_360:\n\t\treturn 360000000;\n\tcase RT5350_SYSCFG0_CPUCLK_320:\n\t\treturn 320000000;\n\tcase RT5350_SYSCFG0_CPUCLK_300:\n\t\treturn 300000000;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic unsigned long rt5350_bus_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tif (parent_rate == 320000000)\n\t\treturn parent_rate / 4;\n\n\treturn parent_rate / 3;\n}\n\nstatic unsigned long rt3352_cpu_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long xtal_clk)\n{\n\tstruct mtmips_clk *clk = to_mtmips_clk(hw);\n\tstruct regmap *sysc = clk->priv->sysc;\n\tu32 t;\n\n\tregmap_read(sysc, SYSC_REG_SYSTEM_CONFIG, &t);\n\tt = (t >> RT3352_SYSCFG0_CPUCLK_SHIFT) & RT3352_SYSCFG0_CPUCLK_MASK;\n\n\tswitch (t) {\n\tcase RT3352_SYSCFG0_CPUCLK_LOW:\n\t\treturn 384000000;\n\tcase RT3352_SYSCFG0_CPUCLK_HIGH:\n\t\treturn 400000000;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic unsigned long rt305x_cpu_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long xtal_clk)\n{\n\tstruct mtmips_clk *clk = to_mtmips_clk(hw);\n\tstruct regmap *sysc = clk->priv->sysc;\n\tu32 t;\n\n\tregmap_read(sysc, SYSC_REG_SYSTEM_CONFIG, &t);\n\tt = (t >> RT305X_SYSCFG_CPUCLK_SHIFT) & RT305X_SYSCFG_CPUCLK_MASK;\n\n\tswitch (t) {\n\tcase RT305X_SYSCFG_CPUCLK_LOW:\n\t\treturn 320000000;\n\tcase RT305X_SYSCFG_CPUCLK_HIGH:\n\t\treturn 384000000;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic unsigned long rt3883_cpu_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long xtal_clk)\n{\n\tstruct mtmips_clk *clk = to_mtmips_clk(hw);\n\tstruct regmap *sysc = clk->priv->sysc;\n\tu32 t;\n\n\tregmap_read(sysc, SYSC_REG_SYSTEM_CONFIG, &t);\n\tt = (t >> RT3883_SYSCFG0_CPUCLK_SHIFT) & RT3883_SYSCFG0_CPUCLK_MASK;\n\n\tswitch (t) {\n\tcase RT3883_SYSCFG0_CPUCLK_250:\n\t\treturn 250000000;\n\tcase RT3883_SYSCFG0_CPUCLK_384:\n\t\treturn 384000000;\n\tcase RT3883_SYSCFG0_CPUCLK_480:\n\t\treturn 480000000;\n\tcase RT3883_SYSCFG0_CPUCLK_500:\n\t\treturn 500000000;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic unsigned long rt3883_bus_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct mtmips_clk *clk = to_mtmips_clk(hw);\n\tstruct regmap *sysc = clk->priv->sysc;\n\tu32 ddr2;\n\tu32 t;\n\n\tregmap_read(sysc, SYSC_REG_SYSTEM_CONFIG, &t);\n\tddr2 = t & RT3883_SYSCFG0_DRAM_TYPE_DDR2;\n\n\tswitch (parent_rate) {\n\tcase 250000000:\n\t\treturn (ddr2) ? 125000000 : 83000000;\n\tcase 384000000:\n\t\treturn (ddr2) ? 128000000 : 96000000;\n\tcase 480000000:\n\t\treturn (ddr2) ? 160000000 : 120000000;\n\tcase 500000000:\n\t\treturn (ddr2) ? 166000000 : 125000000;\n\tdefault:\n\t\tWARN_ON_ONCE(parent_rate == 0);\n\t\treturn parent_rate / 4;\n\t}\n}\n\nstatic unsigned long rt2880_cpu_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long xtal_clk)\n{\n\tstruct mtmips_clk *clk = to_mtmips_clk(hw);\n\tstruct regmap *sysc = clk->priv->sysc;\n\tu32 t;\n\n\tregmap_read(sysc, SYSC_REG_SYSTEM_CONFIG, &t);\n\tt = (t >> RT2880_CONFIG_CPUCLK_SHIFT) & RT2880_CONFIG_CPUCLK_MASK;\n\n\tswitch (t) {\n\tcase RT2880_CONFIG_CPUCLK_250:\n\t\treturn 250000000;\n\tcase RT2880_CONFIG_CPUCLK_266:\n\t\treturn 266000000;\n\tcase RT2880_CONFIG_CPUCLK_280:\n\t\treturn 280000000;\n\tcase RT2880_CONFIG_CPUCLK_300:\n\t\treturn 300000000;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic u32 mt7620_calc_rate(u32 ref_rate, u32 mul, u32 div)\n{\n\tu64 t;\n\n\tt = ref_rate;\n\tt *= mul;\n\tt = div_u64(t, div);\n\n\treturn t;\n}\n\nstatic unsigned long mt7620_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstatic const u32 clk_divider[] = { 2, 3, 4, 8 };\n\tstruct mtmips_clk *clk = to_mtmips_clk(hw);\n\tstruct regmap *sysc = clk->priv->sysc;\n\tunsigned long cpu_pll;\n\tu32 t;\n\tu32 mul;\n\tu32 div;\n\n\tregmap_read(sysc, SYSC_REG_CPLL_CONFIG0, &t);\n\tif (t & CPLL_CFG0_BYPASS_REF_CLK) {\n\t\tcpu_pll = parent_rate;\n\t} else if ((t & CPLL_CFG0_SW_CFG) == 0) {\n\t\tcpu_pll = 600000000;\n\t} else {\n\t\tmul = (t >> CPLL_CFG0_PLL_MULT_RATIO_SHIFT) &\n\t\t\tCPLL_CFG0_PLL_MULT_RATIO_MASK;\n\t\tmul += 24;\n\t\tif (t & CPLL_CFG0_LC_CURFCK)\n\t\t\tmul *= 2;\n\n\t\tdiv = (t >> CPLL_CFG0_PLL_DIV_RATIO_SHIFT) &\n\t\t\tCPLL_CFG0_PLL_DIV_RATIO_MASK;\n\n\t\tWARN_ON_ONCE(div >= ARRAY_SIZE(clk_divider));\n\n\t\tcpu_pll = mt7620_calc_rate(parent_rate, mul, clk_divider[div]);\n\t}\n\n\tregmap_read(sysc, SYSC_REG_CPLL_CONFIG1, &t);\n\tif (t & CPLL_CFG1_CPU_AUX1)\n\t\treturn parent_rate;\n\n\tif (t & CPLL_CFG1_CPU_AUX0)\n\t\treturn 480000000;\n\n\treturn cpu_pll;\n}\n\nstatic unsigned long mt7620_cpu_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct mtmips_clk *clk = to_mtmips_clk(hw);\n\tstruct regmap *sysc = clk->priv->sysc;\n\tu32 t;\n\tu32 mul;\n\tu32 div;\n\n\tregmap_read(sysc, SYSC_REG_CPU_SYS_CLKCFG, &t);\n\tmul = t & CPU_SYS_CLKCFG_CPU_FFRAC_MASK;\n\tdiv = (t >> CPU_SYS_CLKCFG_CPU_FDIV_SHIFT) &\n\t\tCPU_SYS_CLKCFG_CPU_FDIV_MASK;\n\n\treturn mt7620_calc_rate(parent_rate, mul, div);\n}\n\nstatic unsigned long mt7620_bus_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstatic const u32 ocp_dividers[16] = {\n\t\t[CPU_SYS_CLKCFG_OCP_RATIO_2] = 2,\n\t\t[CPU_SYS_CLKCFG_OCP_RATIO_3] = 3,\n\t\t[CPU_SYS_CLKCFG_OCP_RATIO_4] = 4,\n\t\t[CPU_SYS_CLKCFG_OCP_RATIO_5] = 5,\n\t\t[CPU_SYS_CLKCFG_OCP_RATIO_10] = 10,\n\t};\n\tstruct mtmips_clk *clk = to_mtmips_clk(hw);\n\tstruct regmap *sysc = clk->priv->sysc;\n\tu32 t;\n\tu32 ocp_ratio;\n\tu32 div;\n\n\tregmap_read(sysc, SYSC_REG_CPU_SYS_CLKCFG, &t);\n\tocp_ratio = (t >> CPU_SYS_CLKCFG_OCP_RATIO_SHIFT) &\n\t\tCPU_SYS_CLKCFG_OCP_RATIO_MASK;\n\n\tif (WARN_ON_ONCE(ocp_ratio >= ARRAY_SIZE(ocp_dividers)))\n\t\treturn parent_rate;\n\n\tdiv = ocp_dividers[ocp_ratio];\n\n\tif (WARN(!div, \"invalid divider for OCP ratio %u\", ocp_ratio))\n\t\treturn parent_rate;\n\n\treturn parent_rate / div;\n}\n\nstatic unsigned long mt7620_periph_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct mtmips_clk *clk = to_mtmips_clk(hw);\n\tstruct regmap *sysc = clk->priv->sysc;\n\tu32 t;\n\n\tregmap_read(sysc, SYSC_REG_CLKCFG0, &t);\n\tif (t & CLKCFG0_PERI_CLK_SEL)\n\t\treturn parent_rate;\n\n\treturn 40000000;\n}\n\nstatic unsigned long mt76x8_xtal_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct mtmips_clk *clk = to_mtmips_clk(hw);\n\tstruct regmap *sysc = clk->priv->sysc;\n\tu32 t;\n\n\tregmap_read(sysc, SYSC_REG_SYSTEM_CONFIG, &t);\n\tif (t & MT7620_XTAL_FREQ_SEL)\n\t\treturn 40000000;\n\n\treturn 20000000;\n}\n\nstatic unsigned long mt76x8_cpu_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long xtal_clk)\n{\n\tif (xtal_clk == 40000000)\n\t\treturn 580000000;\n\n\treturn 575000000;\n}\n\n#define CLK_BASE(_name, _parent, _recalc) {\t\t\t\t\\\n\t.init = &(const struct clk_init_data) {\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.ops = &(const struct clk_ops) {\t\t\t\\\n\t\t\t.recalc_rate = _recalc,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.parent_data = &(const struct clk_parent_data) {\t\\\n\t\t\t.name = _parent,\t\t\t\t\\\n\t\t\t.fw_name = _parent\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.num_parents = _parent ? 1 : 0\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nstatic struct mtmips_clk rt2880_clks_base[] = {\n\t{ CLK_BASE(\"cpu\", \"xtal\", rt2880_cpu_recalc_rate) }\n};\n\nstatic struct mtmips_clk rt305x_clks_base[] = {\n\t{ CLK_BASE(\"cpu\", \"xtal\", rt305x_cpu_recalc_rate) }\n};\n\nstatic struct mtmips_clk rt3352_clks_base[] = {\n\t{ CLK_BASE(\"xtal\", NULL, rt5350_xtal_recalc_rate) },\n\t{ CLK_BASE(\"cpu\", \"xtal\", rt3352_cpu_recalc_rate) }\n};\n\nstatic struct mtmips_clk rt3883_clks_base[] = {\n\t{ CLK_BASE(\"cpu\", \"xtal\", rt3883_cpu_recalc_rate) },\n\t{ CLK_BASE(\"bus\", \"cpu\", rt3883_bus_recalc_rate) }\n};\n\nstatic struct mtmips_clk rt5350_clks_base[] = {\n\t{ CLK_BASE(\"xtal\", NULL, rt5350_xtal_recalc_rate) },\n\t{ CLK_BASE(\"cpu\", \"xtal\", rt5350_cpu_recalc_rate) },\n\t{ CLK_BASE(\"bus\", \"cpu\", rt5350_bus_recalc_rate) }\n};\n\nstatic struct mtmips_clk mt7620_clks_base[] = {\n\t{ CLK_BASE(\"xtal\", NULL, mt76x8_xtal_recalc_rate) },\n\t{ CLK_BASE(\"pll\", \"xtal\", mt7620_pll_recalc_rate) },\n\t{ CLK_BASE(\"cpu\", \"pll\", mt7620_cpu_recalc_rate) },\n\t{ CLK_BASE(\"periph\", \"xtal\", mt7620_periph_recalc_rate) },\n\t{ CLK_BASE(\"bus\", \"cpu\", mt7620_bus_recalc_rate) }\n};\n\nstatic struct mtmips_clk mt76x8_clks_base[] = {\n\t{ CLK_BASE(\"xtal\", NULL, mt76x8_xtal_recalc_rate) },\n\t{ CLK_BASE(\"cpu\", \"xtal\", mt76x8_cpu_recalc_rate) }\n};\n\nstatic int mtmips_register_clocks(struct device_node *np,\n\t\t\t\t  struct clk_hw_onecell_data *clk_data,\n\t\t\t\t  struct mtmips_clk_priv *priv)\n{\n\tstruct clk_hw **hws = clk_data->hws;\n\tstruct mtmips_clk *sclk;\n\tint ret, i;\n\n\tfor (i = 0; i < priv->data->num_clk_base; i++) {\n\t\tsclk = &priv->data->clk_base[i];\n\t\tsclk->priv = priv;\n\t\tret = of_clk_hw_register(np, &sclk->hw);\n\t\tif (ret) {\n\t\t\tpr_err(\"Couldn't register top clock %i\\n\", i);\n\t\t\tgoto err_clk_unreg;\n\t\t}\n\n\t\thws[i] = &sclk->hw;\n\t}\n\n\treturn 0;\n\nerr_clk_unreg:\n\twhile (--i >= 0) {\n\t\tsclk = &priv->data->clk_base[i];\n\t\tclk_hw_unregister(&sclk->hw);\n\t}\n\treturn ret;\n}\n\nstatic const struct mtmips_clk_data rt2880_clk_data = {\n\t.clk_base = rt2880_clks_base,\n\t.num_clk_base = ARRAY_SIZE(rt2880_clks_base),\n\t.clk_fixed = rt305x_fixed_clocks,\n\t.num_clk_fixed = ARRAY_SIZE(rt305x_fixed_clocks),\n\t.clk_factor = rt2880_factor_clocks,\n\t.num_clk_factor = ARRAY_SIZE(rt2880_factor_clocks),\n\t.clk_periph = rt2880_pherip_clks,\n\t.num_clk_periph = ARRAY_SIZE(rt2880_pherip_clks),\n};\n\nstatic const struct mtmips_clk_data rt305x_clk_data = {\n\t.clk_base = rt305x_clks_base,\n\t.num_clk_base = ARRAY_SIZE(rt305x_clks_base),\n\t.clk_fixed = rt305x_fixed_clocks,\n\t.num_clk_fixed = ARRAY_SIZE(rt305x_fixed_clocks),\n\t.clk_factor = rt305x_factor_clocks,\n\t.num_clk_factor = ARRAY_SIZE(rt305x_factor_clocks),\n\t.clk_periph = rt305x_pherip_clks,\n\t.num_clk_periph = ARRAY_SIZE(rt305x_pherip_clks),\n};\n\nstatic const struct mtmips_clk_data rt3352_clk_data = {\n\t.clk_base = rt3352_clks_base,\n\t.num_clk_base = ARRAY_SIZE(rt3352_clks_base),\n\t.clk_fixed = rt3352_fixed_clocks,\n\t.num_clk_fixed = ARRAY_SIZE(rt3352_fixed_clocks),\n\t.clk_factor = rt305x_factor_clocks,\n\t.num_clk_factor = ARRAY_SIZE(rt305x_factor_clocks),\n\t.clk_periph = rt5350_pherip_clks,\n\t.num_clk_periph = ARRAY_SIZE(rt5350_pherip_clks),\n};\n\nstatic const struct mtmips_clk_data rt3883_clk_data = {\n\t.clk_base = rt3883_clks_base,\n\t.num_clk_base = ARRAY_SIZE(rt3883_clks_base),\n\t.clk_fixed = rt305x_fixed_clocks,\n\t.num_clk_fixed = ARRAY_SIZE(rt305x_fixed_clocks),\n\t.clk_factor = NULL,\n\t.num_clk_factor = 0,\n\t.clk_periph = rt5350_pherip_clks,\n\t.num_clk_periph = ARRAY_SIZE(rt5350_pherip_clks),\n};\n\nstatic const struct mtmips_clk_data rt5350_clk_data = {\n\t.clk_base = rt5350_clks_base,\n\t.num_clk_base = ARRAY_SIZE(rt5350_clks_base),\n\t.clk_fixed = rt3352_fixed_clocks,\n\t.num_clk_fixed = ARRAY_SIZE(rt3352_fixed_clocks),\n\t.clk_factor = NULL,\n\t.num_clk_factor = 0,\n\t.clk_periph = rt5350_pherip_clks,\n\t.num_clk_periph = ARRAY_SIZE(rt5350_pherip_clks),\n};\n\nstatic const struct mtmips_clk_data mt7620_clk_data = {\n\t.clk_base = mt7620_clks_base,\n\t.num_clk_base = ARRAY_SIZE(mt7620_clks_base),\n\t.clk_fixed = NULL,\n\t.num_clk_fixed = 0,\n\t.clk_factor = NULL,\n\t.num_clk_factor = 0,\n\t.clk_periph = mt7620_pherip_clks,\n\t.num_clk_periph = ARRAY_SIZE(mt7620_pherip_clks),\n};\n\nstatic const struct mtmips_clk_data mt76x8_clk_data = {\n\t.clk_base = mt76x8_clks_base,\n\t.num_clk_base = ARRAY_SIZE(mt76x8_clks_base),\n\t.clk_fixed = mt76x8_fixed_clocks,\n\t.num_clk_fixed = ARRAY_SIZE(mt76x8_fixed_clocks),\n\t.clk_factor = rt305x_factor_clocks,\n\t.num_clk_factor = ARRAY_SIZE(rt305x_factor_clocks),\n\t.clk_periph = mt76x8_pherip_clks,\n\t.num_clk_periph = ARRAY_SIZE(mt76x8_pherip_clks),\n};\n\nstatic const struct of_device_id mtmips_of_match[] = {\n\t{\n\t\t.compatible = \"ralink,rt2880-reset\",\n\t\t.data = NULL,\n\t},\n\t{\n\t\t.compatible = \"ralink,rt2880-sysc\",\n\t\t.data = &rt2880_clk_data,\n\t},\n\t{\n\t\t.compatible = \"ralink,rt3050-sysc\",\n\t\t.data = &rt305x_clk_data,\n\t},\n\t{\n\t\t.compatible = \"ralink,rt3052-sysc\",\n\t\t.data = &rt305x_clk_data,\n\t},\n\t{\n\t\t.compatible = \"ralink,rt3352-sysc\",\n\t\t.data = &rt3352_clk_data,\n\t},\n\t{\n\t\t.compatible = \"ralink,rt3883-sysc\",\n\t\t.data = &rt3883_clk_data,\n\t},\n\t{\n\t\t.compatible = \"ralink,rt5350-sysc\",\n\t\t.data = &rt5350_clk_data,\n\t},\n\t{\n\t\t.compatible = \"ralink,mt7620-sysc\",\n\t\t.data = &mt7620_clk_data,\n\t},\n\t{\n\t\t.compatible = \"ralink,mt7628-sysc\",\n\t\t.data = &mt76x8_clk_data,\n\t},\n\t{\n\t\t.compatible = \"ralink,mt7688-sysc\",\n\t\t.data = &mt76x8_clk_data,\n\t},\n\t{}\n};\n\nstatic void __init mtmips_clk_regs_init(struct device_node *node,\n\t\t\t\t\tstruct mtmips_clk_priv *priv)\n{\n\tu32 t;\n\n\tif (!of_device_is_compatible(node, \"ralink,mt7620-sysc\"))\n\t\treturn;\n\n\t \n\tregmap_read(priv->sysc, SYSC_REG_CPU_SYS_CLKCFG, &t);\n\tt &= ~(CLKCFG_FDIV_MASK | CLKCFG_FFRAC_MASK);\n\tt |= CLKCFG_FDIV_USB_VAL | CLKCFG_FFRAC_USB_VAL;\n\tregmap_write(priv->sysc, SYSC_REG_CPU_SYS_CLKCFG, t);\n}\n\nstatic void __init mtmips_clk_init(struct device_node *node)\n{\n\tconst struct of_device_id *match;\n\tconst struct mtmips_clk_data *data;\n\tstruct mtmips_clk_priv *priv;\n\tstruct clk_hw_onecell_data *clk_data;\n\tint ret, i, count;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn;\n\n\tpriv->sysc = syscon_node_to_regmap(node);\n\tif (IS_ERR(priv->sysc)) {\n\t\tpr_err(\"Could not get sysc syscon regmap\\n\");\n\t\tgoto free_clk_priv;\n\t}\n\n\tmtmips_clk_regs_init(node, priv);\n\n\tmatch = of_match_node(mtmips_of_match, node);\n\tif (WARN_ON(!match))\n\t\treturn;\n\n\tdata = match->data;\n\tpriv->data = data;\n\tcount = priv->data->num_clk_base + priv->data->num_clk_fixed +\n\t\tpriv->data->num_clk_factor + priv->data->num_clk_periph;\n\tclk_data = kzalloc(struct_size(clk_data, hws, count), GFP_KERNEL);\n\tif (!clk_data)\n\t\tgoto free_clk_priv;\n\n\tret = mtmips_register_clocks(node, clk_data, priv);\n\tif (ret) {\n\t\tpr_err(\"Couldn't register top clocks\\n\");\n\t\tgoto free_clk_data;\n\t}\n\n\tret = mtmips_register_fixed_clocks(clk_data, priv);\n\tif (ret) {\n\t\tpr_err(\"Couldn't register fixed clocks\\n\");\n\t\tgoto unreg_clk_top;\n\t}\n\n\tret = mtmips_register_factor_clocks(clk_data, priv);\n\tif (ret) {\n\t\tpr_err(\"Couldn't register factor clocks\\n\");\n\t\tgoto unreg_clk_fixed;\n\t}\n\n\tret = mtmips_register_pherip_clocks(node, clk_data, priv);\n\tif (ret) {\n\t\tpr_err(\"Couldn't register peripheral clocks\\n\");\n\t\tgoto unreg_clk_factor;\n\t}\n\n\tclk_data->num = count;\n\n\tret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, clk_data);\n\tif (ret) {\n\t\tpr_err(\"Couldn't add clk hw provider\\n\");\n\t\tgoto unreg_clk_periph;\n\t}\n\n\treturn;\n\nunreg_clk_periph:\n\tfor (i = 0; i < priv->data->num_clk_periph; i++) {\n\t\tstruct mtmips_clk *sclk = &priv->data->clk_periph[i];\n\n\t\tclk_hw_unregister(&sclk->hw);\n\t}\n\nunreg_clk_factor:\n\tfor (i = 0; i < priv->data->num_clk_factor; i++) {\n\t\tstruct mtmips_clk_factor *sclk = &priv->data->clk_factor[i];\n\n\t\tclk_hw_unregister_fixed_factor(sclk->hw);\n\t}\n\nunreg_clk_fixed:\n\tfor (i = 0; i < priv->data->num_clk_fixed; i++) {\n\t\tstruct mtmips_clk_fixed *sclk = &priv->data->clk_fixed[i];\n\n\t\tclk_hw_unregister_fixed_rate(sclk->hw);\n\t}\n\nunreg_clk_top:\n\tfor (i = 0; i < priv->data->num_clk_base; i++) {\n\t\tstruct mtmips_clk *sclk = &priv->data->clk_base[i];\n\n\t\tclk_hw_unregister(&sclk->hw);\n\t}\n\nfree_clk_data:\n\tkfree(clk_data);\n\nfree_clk_priv:\n\tkfree(priv);\n}\nCLK_OF_DECLARE_DRIVER(rt2880_clk, \"ralink,rt2880-sysc\", mtmips_clk_init);\nCLK_OF_DECLARE_DRIVER(rt3050_clk, \"ralink,rt3050-sysc\", mtmips_clk_init);\nCLK_OF_DECLARE_DRIVER(rt3052_clk, \"ralink,rt3052-sysc\", mtmips_clk_init);\nCLK_OF_DECLARE_DRIVER(rt3352_clk, \"ralink,rt3352-sysc\", mtmips_clk_init);\nCLK_OF_DECLARE_DRIVER(rt3883_clk, \"ralink,rt3883-sysc\", mtmips_clk_init);\nCLK_OF_DECLARE_DRIVER(rt5350_clk, \"ralink,rt5350-sysc\", mtmips_clk_init);\nCLK_OF_DECLARE_DRIVER(mt7620_clk, \"ralink,mt7620-sysc\", mtmips_clk_init);\nCLK_OF_DECLARE_DRIVER(mt7628_clk, \"ralink,mt7628-sysc\", mtmips_clk_init);\nCLK_OF_DECLARE_DRIVER(mt7688_clk, \"ralink,mt7688-sysc\", mtmips_clk_init);\n\nstruct mtmips_rst {\n\tstruct reset_controller_dev rcdev;\n\tstruct regmap *sysc;\n};\n\nstatic struct mtmips_rst *to_mtmips_rst(struct reset_controller_dev *dev)\n{\n\treturn container_of(dev, struct mtmips_rst, rcdev);\n}\n\nstatic int mtmips_assert_device(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\tstruct mtmips_rst *data = to_mtmips_rst(rcdev);\n\tstruct regmap *sysc = data->sysc;\n\n\treturn regmap_update_bits(sysc, SYSC_REG_RESET_CTRL, BIT(id), BIT(id));\n}\n\nstatic int mtmips_deassert_device(struct reset_controller_dev *rcdev,\n\t\t\t\t  unsigned long id)\n{\n\tstruct mtmips_rst *data = to_mtmips_rst(rcdev);\n\tstruct regmap *sysc = data->sysc;\n\n\treturn regmap_update_bits(sysc, SYSC_REG_RESET_CTRL, BIT(id), 0);\n}\n\nstatic int mtmips_reset_device(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tint ret;\n\n\tret = mtmips_assert_device(rcdev, id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mtmips_deassert_device(rcdev, id);\n}\n\nstatic int mtmips_rst_xlate(struct reset_controller_dev *rcdev,\n\t\t\t    const struct of_phandle_args *reset_spec)\n{\n\tunsigned long id = reset_spec->args[0];\n\n\tif (id == 0 || id >= rcdev->nr_resets)\n\t\treturn -EINVAL;\n\n\treturn id;\n}\n\nstatic const struct reset_control_ops reset_ops = {\n\t.reset = mtmips_reset_device,\n\t.assert = mtmips_assert_device,\n\t.deassert = mtmips_deassert_device\n};\n\nstatic int mtmips_reset_init(struct device *dev, struct regmap *sysc)\n{\n\tstruct mtmips_rst *rst_data;\n\n\trst_data = devm_kzalloc(dev, sizeof(*rst_data), GFP_KERNEL);\n\tif (!rst_data)\n\t\treturn -ENOMEM;\n\n\trst_data->sysc = sysc;\n\trst_data->rcdev.ops = &reset_ops;\n\trst_data->rcdev.owner = THIS_MODULE;\n\trst_data->rcdev.nr_resets = 32;\n\trst_data->rcdev.of_reset_n_cells = 1;\n\trst_data->rcdev.of_xlate = mtmips_rst_xlate;\n\trst_data->rcdev.of_node = dev_of_node(dev);\n\n\treturn devm_reset_controller_register(dev, &rst_data->rcdev);\n}\n\nstatic int mtmips_clk_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct mtmips_clk_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->sysc = syscon_node_to_regmap(np);\n\tif (IS_ERR(priv->sysc))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->sysc),\n\t\t\t\t     \"Could not get sysc syscon regmap\\n\");\n\n\tret = mtmips_reset_init(dev, priv->sysc);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Could not init reset controller\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver mtmips_clk_driver = {\n\t.probe = mtmips_clk_probe,\n\t.driver = {\n\t\t.name = \"mtmips-clk\",\n\t\t.of_match_table = mtmips_of_match,\n\t},\n};\n\nstatic int __init mtmips_clk_reset_init(void)\n{\n\treturn platform_driver_register(&mtmips_clk_driver);\n}\narch_initcall(mtmips_clk_reset_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}