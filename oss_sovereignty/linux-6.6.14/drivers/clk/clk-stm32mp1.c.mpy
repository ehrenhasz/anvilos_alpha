{
  "module_name": "clk-stm32mp1.c",
  "hash_id": "ee9130a081efa0e4a23f1997250ceb48787e31832bca20ba8501af9613168b1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-stm32mp1.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <dt-bindings/clock/stm32mp1-clks.h>\n\nstatic DEFINE_SPINLOCK(rlock);\n\n#define RCC_OCENSETR\t\t0x0C\n#define RCC_HSICFGR\t\t0x18\n#define RCC_RDLSICR\t\t0x144\n#define RCC_PLL1CR\t\t0x80\n#define RCC_PLL1CFGR1\t\t0x84\n#define RCC_PLL1CFGR2\t\t0x88\n#define RCC_PLL2CR\t\t0x94\n#define RCC_PLL2CFGR1\t\t0x98\n#define RCC_PLL2CFGR2\t\t0x9C\n#define RCC_PLL3CR\t\t0x880\n#define RCC_PLL3CFGR1\t\t0x884\n#define RCC_PLL3CFGR2\t\t0x888\n#define RCC_PLL4CR\t\t0x894\n#define RCC_PLL4CFGR1\t\t0x898\n#define RCC_PLL4CFGR2\t\t0x89C\n#define RCC_APB1ENSETR\t\t0xA00\n#define RCC_APB2ENSETR\t\t0xA08\n#define RCC_APB3ENSETR\t\t0xA10\n#define RCC_APB4ENSETR\t\t0x200\n#define RCC_APB5ENSETR\t\t0x208\n#define RCC_AHB2ENSETR\t\t0xA18\n#define RCC_AHB3ENSETR\t\t0xA20\n#define RCC_AHB4ENSETR\t\t0xA28\n#define RCC_AHB5ENSETR\t\t0x210\n#define RCC_AHB6ENSETR\t\t0x218\n#define RCC_AHB6LPENSETR\t0x318\n#define RCC_RCK12SELR\t\t0x28\n#define RCC_RCK3SELR\t\t0x820\n#define RCC_RCK4SELR\t\t0x824\n#define RCC_MPCKSELR\t\t0x20\n#define RCC_ASSCKSELR\t\t0x24\n#define RCC_MSSCKSELR\t\t0x48\n#define RCC_SPI6CKSELR\t\t0xC4\n#define RCC_SDMMC12CKSELR\t0x8F4\n#define RCC_SDMMC3CKSELR\t0x8F8\n#define RCC_FMCCKSELR\t\t0x904\n#define RCC_I2C46CKSELR\t\t0xC0\n#define RCC_I2C12CKSELR\t\t0x8C0\n#define RCC_I2C35CKSELR\t\t0x8C4\n#define RCC_UART1CKSELR\t\t0xC8\n#define RCC_QSPICKSELR\t\t0x900\n#define RCC_ETHCKSELR\t\t0x8FC\n#define RCC_RNG1CKSELR\t\t0xCC\n#define RCC_RNG2CKSELR\t\t0x920\n#define RCC_GPUCKSELR\t\t0x938\n#define RCC_USBCKSELR\t\t0x91C\n#define RCC_STGENCKSELR\t\t0xD4\n#define RCC_SPDIFCKSELR\t\t0x914\n#define RCC_SPI2S1CKSELR\t0x8D8\n#define RCC_SPI2S23CKSELR\t0x8DC\n#define RCC_SPI2S45CKSELR\t0x8E0\n#define RCC_CECCKSELR\t\t0x918\n#define RCC_LPTIM1CKSELR\t0x934\n#define RCC_LPTIM23CKSELR\t0x930\n#define RCC_LPTIM45CKSELR\t0x92C\n#define RCC_UART24CKSELR\t0x8E8\n#define RCC_UART35CKSELR\t0x8EC\n#define RCC_UART6CKSELR\t\t0x8E4\n#define RCC_UART78CKSELR\t0x8F0\n#define RCC_FDCANCKSELR\t\t0x90C\n#define RCC_SAI1CKSELR\t\t0x8C8\n#define RCC_SAI2CKSELR\t\t0x8CC\n#define RCC_SAI3CKSELR\t\t0x8D0\n#define RCC_SAI4CKSELR\t\t0x8D4\n#define RCC_ADCCKSELR\t\t0x928\n#define RCC_MPCKDIVR\t\t0x2C\n#define RCC_DSICKSELR\t\t0x924\n#define RCC_CPERCKSELR\t\t0xD0\n#define RCC_MCO1CFGR\t\t0x800\n#define RCC_MCO2CFGR\t\t0x804\n#define RCC_BDCR\t\t0x140\n#define RCC_AXIDIVR\t\t0x30\n#define RCC_MCUDIVR\t\t0x830\n#define RCC_APB1DIVR\t\t0x834\n#define RCC_APB2DIVR\t\t0x838\n#define RCC_APB3DIVR\t\t0x83C\n#define RCC_APB4DIVR\t\t0x3C\n#define RCC_APB5DIVR\t\t0x40\n#define RCC_TIMG1PRER\t\t0x828\n#define RCC_TIMG2PRER\t\t0x82C\n#define RCC_RTCDIVR\t\t0x44\n#define RCC_DBGCFGR\t\t0x80C\n\n#define RCC_CLR\t0x4\n\nstatic const char * const ref12_parents[] = {\n\t\"ck_hsi\", \"ck_hse\"\n};\n\nstatic const char * const ref3_parents[] = {\n\t\"ck_hsi\", \"ck_hse\", \"ck_csi\"\n};\n\nstatic const char * const ref4_parents[] = {\n\t\"ck_hsi\", \"ck_hse\", \"ck_csi\"\n};\n\nstatic const char * const cpu_src[] = {\n\t\"ck_hsi\", \"ck_hse\", \"pll1_p\"\n};\n\nstatic const char * const axi_src[] = {\n\t\"ck_hsi\", \"ck_hse\", \"pll2_p\"\n};\n\nstatic const char * const per_src[] = {\n\t\"ck_hsi\", \"ck_csi\", \"ck_hse\"\n};\n\nstatic const char * const mcu_src[] = {\n\t\"ck_hsi\", \"ck_hse\", \"ck_csi\", \"pll3_p\"\n};\n\nstatic const char * const sdmmc12_src[] = {\n\t\"ck_axi\", \"pll3_r\", \"pll4_p\", \"ck_hsi\"\n};\n\nstatic const char * const sdmmc3_src[] = {\n\t\"ck_mcu\", \"pll3_r\", \"pll4_p\", \"ck_hsi\"\n};\n\nstatic const char * const fmc_src[] = {\n\t\"ck_axi\", \"pll3_r\", \"pll4_p\", \"ck_per\"\n};\n\nstatic const char * const qspi_src[] = {\n\t\"ck_axi\", \"pll3_r\", \"pll4_p\", \"ck_per\"\n};\n\nstatic const char * const eth_src[] = {\n\t\"pll4_p\", \"pll3_q\"\n};\n\nstatic const struct clk_parent_data ethrx_src[] = {\n\t{ .name = \"ethck_k\", .fw_name = \"ETH_RX_CLK/ETH_REF_CLK\" },\n};\n\nstatic const char * const rng_src[] = {\n\t\"ck_csi\", \"pll4_r\", \"ck_lse\", \"ck_lsi\"\n};\n\nstatic const char * const usbphy_src[] = {\n\t\"ck_hse\", \"pll4_r\", \"clk-hse-div2\"\n};\n\nstatic const char * const usbo_src[] = {\n\t\"pll4_r\", \"ck_usbo_48m\"\n};\n\nstatic const char * const stgen_src[] = {\n\t\"ck_hsi\", \"ck_hse\"\n};\n\nstatic const char * const spdif_src[] = {\n\t\"pll4_p\", \"pll3_q\", \"ck_hsi\"\n};\n\nstatic const char * const spi123_src[] = {\n\t\"pll4_p\", \"pll3_q\", \"i2s_ckin\", \"ck_per\", \"pll3_r\"\n};\n\nstatic const char * const spi45_src[] = {\n\t\"pclk2\", \"pll4_q\", \"ck_hsi\", \"ck_csi\", \"ck_hse\"\n};\n\nstatic const char * const spi6_src[] = {\n\t\"pclk5\", \"pll4_q\", \"ck_hsi\", \"ck_csi\", \"ck_hse\", \"pll3_q\"\n};\n\nstatic const char * const cec_src[] = {\n\t\"ck_lse\", \"ck_lsi\", \"ck_csi\"\n};\n\nstatic const char * const i2c12_src[] = {\n\t\"pclk1\", \"pll4_r\", \"ck_hsi\", \"ck_csi\"\n};\n\nstatic const char * const i2c35_src[] = {\n\t\"pclk1\", \"pll4_r\", \"ck_hsi\", \"ck_csi\"\n};\n\nstatic const char * const i2c46_src[] = {\n\t\"pclk5\", \"pll3_q\", \"ck_hsi\", \"ck_csi\"\n};\n\nstatic const char * const lptim1_src[] = {\n\t\"pclk1\", \"pll4_p\", \"pll3_q\", \"ck_lse\", \"ck_lsi\", \"ck_per\"\n};\n\nstatic const char * const lptim23_src[] = {\n\t\"pclk3\", \"pll4_q\", \"ck_per\", \"ck_lse\", \"ck_lsi\"\n};\n\nstatic const char * const lptim45_src[] = {\n\t\"pclk3\", \"pll4_p\", \"pll3_q\", \"ck_lse\", \"ck_lsi\", \"ck_per\"\n};\n\nstatic const char * const usart1_src[] = {\n\t\"pclk5\", \"pll3_q\", \"ck_hsi\", \"ck_csi\", \"pll4_q\", \"ck_hse\"\n};\n\nstatic const char * const usart234578_src[] = {\n\t\"pclk1\", \"pll4_q\", \"ck_hsi\", \"ck_csi\", \"ck_hse\"\n};\n\nstatic const char * const usart6_src[] = {\n\t\"pclk2\", \"pll4_q\", \"ck_hsi\", \"ck_csi\", \"ck_hse\"\n};\n\nstatic const char * const fdcan_src[] = {\n\t\"ck_hse\", \"pll3_q\", \"pll4_q\", \"pll4_r\"\n};\n\nstatic const char * const sai_src[] = {\n\t\"pll4_q\", \"pll3_q\", \"i2s_ckin\", \"ck_per\", \"pll3_r\"\n};\n\nstatic const char * const sai2_src[] = {\n\t\"pll4_q\", \"pll3_q\", \"i2s_ckin\", \"ck_per\", \"spdif_ck_symb\", \"pll3_r\"\n};\n\nstatic const char * const adc12_src[] = {\n\t\"pll4_r\", \"ck_per\", \"pll3_q\"\n};\n\nstatic const char * const dsi_src[] = {\n\t\"ck_dsi_phy\", \"pll4_p\"\n};\n\nstatic const char * const rtc_src[] = {\n\t\"off\", \"ck_lse\", \"ck_lsi\", \"ck_hse\"\n};\n\nstatic const char * const mco1_src[] = {\n\t\"ck_hsi\", \"ck_hse\", \"ck_csi\", \"ck_lsi\", \"ck_lse\"\n};\n\nstatic const char * const mco2_src[] = {\n\t\"ck_mpu\", \"ck_axi\", \"ck_mcu\", \"pll4_p\", \"ck_hse\", \"ck_hsi\"\n};\n\nstatic const char * const ck_trace_src[] = {\n\t\"ck_axi\"\n};\n\nstatic const struct clk_div_table axi_div_table[] = {\n\t{ 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 },\n\t{ 4, 4 }, { 5, 4 }, { 6, 4 }, { 7, 4 },\n\t{ 0 },\n};\n\nstatic const struct clk_div_table mcu_div_table[] = {\n\t{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },\n\t{ 4, 16 }, { 5, 32 }, { 6, 64 }, { 7, 128 },\n\t{ 8, 256 }, { 9, 512 }, { 10, 512}, { 11, 512 },\n\t{ 12, 512 }, { 13, 512 }, { 14, 512}, { 15, 512 },\n\t{ 0 },\n};\n\nstatic const struct clk_div_table apb_div_table[] = {\n\t{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },\n\t{ 4, 16 }, { 5, 16 }, { 6, 16 }, { 7, 16 },\n\t{ 0 },\n};\n\nstatic const struct clk_div_table ck_trace_div_table[] = {\n\t{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },\n\t{ 4, 16 }, { 5, 16 }, { 6, 16 }, { 7, 16 },\n\t{ 0 },\n};\n\n#define MAX_MUX_CLK 2\n\nstruct stm32_mmux {\n\tu8 nbr_clk;\n\tstruct clk_hw *hws[MAX_MUX_CLK];\n};\n\nstruct stm32_clk_mmux {\n\tstruct clk_mux mux;\n\tstruct stm32_mmux *mmux;\n};\n\nstruct stm32_mgate {\n\tu8 nbr_clk;\n\tu32 flag;\n};\n\nstruct stm32_clk_mgate {\n\tstruct clk_gate gate;\n\tstruct stm32_mgate *mgate;\n\tu32 mask;\n};\n\nstruct clock_config {\n\tu32 id;\n\tconst char *name;\n\tconst char *parent_name;\n\tconst char * const *parent_names;\n\tconst struct clk_parent_data *parent_data;\n\tint num_parents;\n\tunsigned long flags;\n\tvoid *cfg;\n\tstruct clk_hw * (*func)(struct device *dev,\n\t\t\t\tstruct clk_hw_onecell_data *clk_data,\n\t\t\t\tvoid __iomem *base, spinlock_t *lock,\n\t\t\t\tconst struct clock_config *cfg);\n};\n\n#define NO_ID ~0\n\nstruct gate_cfg {\n\tu32 reg_off;\n\tu8 bit_idx;\n\tu8 gate_flags;\n};\n\nstruct fixed_factor_cfg {\n\tunsigned int mult;\n\tunsigned int div;\n};\n\nstruct div_cfg {\n\tu32 reg_off;\n\tu8 shift;\n\tu8 width;\n\tu8 div_flags;\n\tconst struct clk_div_table *table;\n};\n\nstruct mux_cfg {\n\tu32 reg_off;\n\tu8 shift;\n\tu8 width;\n\tu8 mux_flags;\n\tu32 *table;\n};\n\nstruct stm32_gate_cfg {\n\tstruct gate_cfg\t\t*gate;\n\tstruct stm32_mgate\t*mgate;\n\tconst struct clk_ops\t*ops;\n};\n\nstruct stm32_div_cfg {\n\tstruct div_cfg\t\t*div;\n\tconst struct clk_ops\t*ops;\n};\n\nstruct stm32_mux_cfg {\n\tstruct mux_cfg\t\t*mux;\n\tstruct stm32_mmux\t*mmux;\n\tconst struct clk_ops\t*ops;\n};\n\n \nstruct stm32_composite_cfg {\n\tconst struct stm32_gate_cfg\t*gate;\n\tconst struct stm32_div_cfg\t*div;\n\tconst struct stm32_mux_cfg\t*mux;\n};\n\nstatic struct clk_hw *\n_clk_hw_register_gate(struct device *dev,\n\t\t      struct clk_hw_onecell_data *clk_data,\n\t\t      void __iomem *base, spinlock_t *lock,\n\t\t      const struct clock_config *cfg)\n{\n\tstruct gate_cfg *gate_cfg = cfg->cfg;\n\n\treturn clk_hw_register_gate(dev,\n\t\t\t\t    cfg->name,\n\t\t\t\t    cfg->parent_name,\n\t\t\t\t    cfg->flags,\n\t\t\t\t    gate_cfg->reg_off + base,\n\t\t\t\t    gate_cfg->bit_idx,\n\t\t\t\t    gate_cfg->gate_flags,\n\t\t\t\t    lock);\n}\n\nstatic struct clk_hw *\n_clk_hw_register_fixed_factor(struct device *dev,\n\t\t\t      struct clk_hw_onecell_data *clk_data,\n\t\t\t      void __iomem *base, spinlock_t *lock,\n\t\t\t      const struct clock_config *cfg)\n{\n\tstruct fixed_factor_cfg *ff_cfg = cfg->cfg;\n\n\treturn clk_hw_register_fixed_factor(dev, cfg->name, cfg->parent_name,\n\t\t\t\t\t    cfg->flags, ff_cfg->mult,\n\t\t\t\t\t    ff_cfg->div);\n}\n\nstatic struct clk_hw *\n_clk_hw_register_divider_table(struct device *dev,\n\t\t\t       struct clk_hw_onecell_data *clk_data,\n\t\t\t       void __iomem *base, spinlock_t *lock,\n\t\t\t       const struct clock_config *cfg)\n{\n\tstruct div_cfg *div_cfg = cfg->cfg;\n\n\treturn clk_hw_register_divider_table(dev,\n\t\t\t\t\t     cfg->name,\n\t\t\t\t\t     cfg->parent_name,\n\t\t\t\t\t     cfg->flags,\n\t\t\t\t\t     div_cfg->reg_off + base,\n\t\t\t\t\t     div_cfg->shift,\n\t\t\t\t\t     div_cfg->width,\n\t\t\t\t\t     div_cfg->div_flags,\n\t\t\t\t\t     div_cfg->table,\n\t\t\t\t\t     lock);\n}\n\nstatic struct clk_hw *\n_clk_hw_register_mux(struct device *dev,\n\t\t     struct clk_hw_onecell_data *clk_data,\n\t\t     void __iomem *base, spinlock_t *lock,\n\t\t     const struct clock_config *cfg)\n{\n\tstruct mux_cfg *mux_cfg = cfg->cfg;\n\n\treturn clk_hw_register_mux(dev, cfg->name, cfg->parent_names,\n\t\t\t\t   cfg->num_parents, cfg->flags,\n\t\t\t\t   mux_cfg->reg_off + base, mux_cfg->shift,\n\t\t\t\t   mux_cfg->width, mux_cfg->mux_flags, lock);\n}\n\n \n\nstatic int mp1_gate_clk_enable(struct clk_hw *hw)\n{\n\tif (!clk_gate_ops.is_enabled(hw))\n\t\tclk_gate_ops.enable(hw);\n\n\treturn 0;\n}\n\nstatic void mp1_gate_clk_disable(struct clk_hw *hw)\n{\n\tstruct clk_gate *gate = to_clk_gate(hw);\n\tunsigned long flags = 0;\n\n\tif (clk_gate_ops.is_enabled(hw)) {\n\t\tspin_lock_irqsave(gate->lock, flags);\n\t\twritel_relaxed(BIT(gate->bit_idx), gate->reg + RCC_CLR);\n\t\tspin_unlock_irqrestore(gate->lock, flags);\n\t}\n}\n\nstatic const struct clk_ops mp1_gate_clk_ops = {\n\t.enable\t\t= mp1_gate_clk_enable,\n\t.disable\t= mp1_gate_clk_disable,\n\t.is_enabled\t= clk_gate_is_enabled,\n};\n\nstatic struct clk_hw *_get_stm32_mux(struct device *dev, void __iomem *base,\n\t\t\t\t     const struct stm32_mux_cfg *cfg,\n\t\t\t\t     spinlock_t *lock)\n{\n\tstruct stm32_clk_mmux *mmux;\n\tstruct clk_mux *mux;\n\tstruct clk_hw *mux_hw;\n\n\tif (cfg->mmux) {\n\t\tmmux = devm_kzalloc(dev, sizeof(*mmux), GFP_KERNEL);\n\t\tif (!mmux)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tmmux->mux.reg = cfg->mux->reg_off + base;\n\t\tmmux->mux.shift = cfg->mux->shift;\n\t\tmmux->mux.mask = (1 << cfg->mux->width) - 1;\n\t\tmmux->mux.flags = cfg->mux->mux_flags;\n\t\tmmux->mux.table = cfg->mux->table;\n\t\tmmux->mux.lock = lock;\n\t\tmmux->mmux = cfg->mmux;\n\t\tmux_hw = &mmux->mux.hw;\n\t\tcfg->mmux->hws[cfg->mmux->nbr_clk++] = mux_hw;\n\n\t} else {\n\t\tmux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);\n\t\tif (!mux)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tmux->reg = cfg->mux->reg_off + base;\n\t\tmux->shift = cfg->mux->shift;\n\t\tmux->mask = (1 << cfg->mux->width) - 1;\n\t\tmux->flags = cfg->mux->mux_flags;\n\t\tmux->table = cfg->mux->table;\n\t\tmux->lock = lock;\n\t\tmux_hw = &mux->hw;\n\t}\n\n\treturn mux_hw;\n}\n\nstatic struct clk_hw *_get_stm32_div(struct device *dev, void __iomem *base,\n\t\t\t\t     const struct stm32_div_cfg *cfg,\n\t\t\t\t     spinlock_t *lock)\n{\n\tstruct clk_divider *div;\n\n\tdiv = devm_kzalloc(dev, sizeof(*div), GFP_KERNEL);\n\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdiv->reg = cfg->div->reg_off + base;\n\tdiv->shift = cfg->div->shift;\n\tdiv->width = cfg->div->width;\n\tdiv->flags = cfg->div->div_flags;\n\tdiv->table = cfg->div->table;\n\tdiv->lock = lock;\n\n\treturn &div->hw;\n}\n\nstatic struct clk_hw *_get_stm32_gate(struct device *dev, void __iomem *base,\n\t\t\t\t      const struct stm32_gate_cfg *cfg,\n\t\t\t\t      spinlock_t *lock)\n{\n\tstruct stm32_clk_mgate *mgate;\n\tstruct clk_gate *gate;\n\tstruct clk_hw *gate_hw;\n\n\tif (cfg->mgate) {\n\t\tmgate = devm_kzalloc(dev, sizeof(*mgate), GFP_KERNEL);\n\t\tif (!mgate)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tmgate->gate.reg = cfg->gate->reg_off + base;\n\t\tmgate->gate.bit_idx = cfg->gate->bit_idx;\n\t\tmgate->gate.flags = cfg->gate->gate_flags;\n\t\tmgate->gate.lock = lock;\n\t\tmgate->mask = BIT(cfg->mgate->nbr_clk++);\n\n\t\tmgate->mgate = cfg->mgate;\n\n\t\tgate_hw = &mgate->gate.hw;\n\n\t} else {\n\t\tgate = devm_kzalloc(dev, sizeof(*gate), GFP_KERNEL);\n\t\tif (!gate)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tgate->reg = cfg->gate->reg_off + base;\n\t\tgate->bit_idx = cfg->gate->bit_idx;\n\t\tgate->flags = cfg->gate->gate_flags;\n\t\tgate->lock = lock;\n\n\t\tgate_hw = &gate->hw;\n\t}\n\n\treturn gate_hw;\n}\n\nstatic struct clk_hw *\nclk_stm32_register_gate_ops(struct device *dev,\n\t\t\t    const char *name,\n\t\t\t    const char *parent_name,\n\t\t\t    const struct clk_parent_data *parent_data,\n\t\t\t    unsigned long flags,\n\t\t\t    void __iomem *base,\n\t\t\t    const struct stm32_gate_cfg *cfg,\n\t\t\t    spinlock_t *lock)\n{\n\tstruct clk_init_data init = { NULL };\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tinit.name = name;\n\tif (parent_name)\n\t\tinit.parent_names = &parent_name;\n\tif (parent_data)\n\t\tinit.parent_data = parent_data;\n\tinit.num_parents = 1;\n\tinit.flags = flags;\n\n\tinit.ops = &clk_gate_ops;\n\n\tif (cfg->ops)\n\t\tinit.ops = cfg->ops;\n\n\thw = _get_stm32_gate(dev, base, cfg, lock);\n\tif (IS_ERR(hw))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thw->init = &init;\n\n\tret = clk_hw_register(dev, hw);\n\tif (ret)\n\t\thw = ERR_PTR(ret);\n\n\treturn hw;\n}\n\nstatic struct clk_hw *\nclk_stm32_register_composite(struct device *dev,\n\t\t\t     const char *name, const char * const *parent_names,\n\t\t\t     const struct clk_parent_data *parent_data,\n\t\t\t     int num_parents, void __iomem *base,\n\t\t\t     const struct stm32_composite_cfg *cfg,\n\t\t\t     unsigned long flags, spinlock_t *lock)\n{\n\tconst struct clk_ops *mux_ops, *div_ops, *gate_ops;\n\tstruct clk_hw *mux_hw, *div_hw, *gate_hw;\n\n\tmux_hw = NULL;\n\tdiv_hw = NULL;\n\tgate_hw = NULL;\n\tmux_ops = NULL;\n\tdiv_ops = NULL;\n\tgate_ops = NULL;\n\n\tif (cfg->mux) {\n\t\tmux_hw = _get_stm32_mux(dev, base, cfg->mux, lock);\n\n\t\tif (!IS_ERR(mux_hw)) {\n\t\t\tmux_ops = &clk_mux_ops;\n\n\t\t\tif (cfg->mux->ops)\n\t\t\t\tmux_ops = cfg->mux->ops;\n\t\t}\n\t}\n\n\tif (cfg->div) {\n\t\tdiv_hw = _get_stm32_div(dev, base, cfg->div, lock);\n\n\t\tif (!IS_ERR(div_hw)) {\n\t\t\tdiv_ops = &clk_divider_ops;\n\n\t\t\tif (cfg->div->ops)\n\t\t\t\tdiv_ops = cfg->div->ops;\n\t\t}\n\t}\n\n\tif (cfg->gate) {\n\t\tgate_hw = _get_stm32_gate(dev, base, cfg->gate, lock);\n\n\t\tif (!IS_ERR(gate_hw)) {\n\t\t\tgate_ops = &clk_gate_ops;\n\n\t\t\tif (cfg->gate->ops)\n\t\t\t\tgate_ops = cfg->gate->ops;\n\t\t}\n\t}\n\n\treturn clk_hw_register_composite(dev, name, parent_names, num_parents,\n\t\t\t\t       mux_hw, mux_ops, div_hw, div_ops,\n\t\t\t\t       gate_hw, gate_ops, flags);\n}\n\n#define to_clk_mgate(_gate) container_of(_gate, struct stm32_clk_mgate, gate)\n\nstatic int mp1_mgate_clk_enable(struct clk_hw *hw)\n{\n\tstruct clk_gate *gate = to_clk_gate(hw);\n\tstruct stm32_clk_mgate *clk_mgate = to_clk_mgate(gate);\n\n\tclk_mgate->mgate->flag |= clk_mgate->mask;\n\n\tmp1_gate_clk_enable(hw);\n\n\treturn  0;\n}\n\nstatic void mp1_mgate_clk_disable(struct clk_hw *hw)\n{\n\tstruct clk_gate *gate = to_clk_gate(hw);\n\tstruct stm32_clk_mgate *clk_mgate = to_clk_mgate(gate);\n\n\tclk_mgate->mgate->flag &= ~clk_mgate->mask;\n\n\tif (clk_mgate->mgate->flag == 0)\n\t\tmp1_gate_clk_disable(hw);\n}\n\nstatic const struct clk_ops mp1_mgate_clk_ops = {\n\t.enable\t\t= mp1_mgate_clk_enable,\n\t.disable\t= mp1_mgate_clk_disable,\n\t.is_enabled\t= clk_gate_is_enabled,\n\n};\n\n#define to_clk_mmux(_mux) container_of(_mux, struct stm32_clk_mmux, mux)\n\nstatic u8 clk_mmux_get_parent(struct clk_hw *hw)\n{\n\treturn clk_mux_ops.get_parent(hw);\n}\n\nstatic int clk_mmux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_mux *mux = to_clk_mux(hw);\n\tstruct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);\n\tstruct clk_hw *hwp;\n\tint ret, n;\n\n\tret = clk_mux_ops.set_parent(hw, index);\n\tif (ret)\n\t\treturn ret;\n\n\thwp = clk_hw_get_parent(hw);\n\n\tfor (n = 0; n < clk_mmux->mmux->nbr_clk; n++)\n\t\tif (clk_mmux->mmux->hws[n] != hw)\n\t\t\tclk_hw_reparent(clk_mmux->mmux->hws[n], hwp);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_mmux_ops = {\n\t.get_parent\t= clk_mmux_get_parent,\n\t.set_parent\t= clk_mmux_set_parent,\n\t.determine_rate\t= __clk_mux_determine_rate,\n};\n\n \nstruct stm32_pll_obj {\n\t \n\tspinlock_t *lock;\n\tvoid __iomem *reg;\n\tstruct clk_hw hw;\n\tstruct clk_mux mux;\n};\n\n#define to_pll(_hw) container_of(_hw, struct stm32_pll_obj, hw)\n\n#define PLL_ON\t\tBIT(0)\n#define PLL_RDY\t\tBIT(1)\n#define DIVN_MASK\t0x1FF\n#define DIVM_MASK\t0x3F\n#define DIVM_SHIFT\t16\n#define DIVN_SHIFT\t0\n#define FRAC_OFFSET\t0xC\n#define FRAC_MASK\t0x1FFF\n#define FRAC_SHIFT\t3\n#define FRACLE\t\tBIT(16)\n#define PLL_MUX_SHIFT\t0\n#define PLL_MUX_MASK\t3\n\nstatic int __pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct stm32_pll_obj *clk_elem = to_pll(hw);\n\n\treturn readl_relaxed(clk_elem->reg) & PLL_ON;\n}\n\n#define TIMEOUT 5\n\nstatic int pll_enable(struct clk_hw *hw)\n{\n\tstruct stm32_pll_obj *clk_elem = to_pll(hw);\n\tu32 reg;\n\tunsigned long flags = 0;\n\tunsigned int timeout = TIMEOUT;\n\tint bit_status = 0;\n\n\tspin_lock_irqsave(clk_elem->lock, flags);\n\n\tif (__pll_is_enabled(hw))\n\t\tgoto unlock;\n\n\treg = readl_relaxed(clk_elem->reg);\n\treg |= PLL_ON;\n\twritel_relaxed(reg, clk_elem->reg);\n\n\t \n\tdo {\n\t\tbit_status = !(readl_relaxed(clk_elem->reg) & PLL_RDY);\n\n\t\tif (bit_status)\n\t\t\tudelay(120);\n\n\t} while (bit_status && --timeout);\n\nunlock:\n\tspin_unlock_irqrestore(clk_elem->lock, flags);\n\n\treturn bit_status;\n}\n\nstatic void pll_disable(struct clk_hw *hw)\n{\n\tstruct stm32_pll_obj *clk_elem = to_pll(hw);\n\tu32 reg;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(clk_elem->lock, flags);\n\n\treg = readl_relaxed(clk_elem->reg);\n\treg &= ~PLL_ON;\n\twritel_relaxed(reg, clk_elem->reg);\n\n\tspin_unlock_irqrestore(clk_elem->lock, flags);\n}\n\nstatic u32 pll_frac_val(struct clk_hw *hw)\n{\n\tstruct stm32_pll_obj *clk_elem = to_pll(hw);\n\tu32 reg, frac = 0;\n\n\treg = readl_relaxed(clk_elem->reg + FRAC_OFFSET);\n\tif (reg & FRACLE)\n\t\tfrac = (reg >> FRAC_SHIFT) & FRAC_MASK;\n\n\treturn frac;\n}\n\nstatic unsigned long pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct stm32_pll_obj *clk_elem = to_pll(hw);\n\tu32 reg;\n\tu32 frac, divm, divn;\n\tu64 rate, rate_frac = 0;\n\n\treg = readl_relaxed(clk_elem->reg + 4);\n\n\tdivm = ((reg >> DIVM_SHIFT) & DIVM_MASK) + 1;\n\tdivn = ((reg >> DIVN_SHIFT) & DIVN_MASK) + 1;\n\trate = (u64)parent_rate * divn;\n\n\tdo_div(rate, divm);\n\n\tfrac = pll_frac_val(hw);\n\tif (frac) {\n\t\trate_frac = (u64)parent_rate * (u64)frac;\n\t\tdo_div(rate_frac, (divm * 8192));\n\t}\n\n\treturn rate + rate_frac;\n}\n\nstatic int pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct stm32_pll_obj *clk_elem = to_pll(hw);\n\tunsigned long flags = 0;\n\tint ret;\n\n\tspin_lock_irqsave(clk_elem->lock, flags);\n\tret = __pll_is_enabled(hw);\n\tspin_unlock_irqrestore(clk_elem->lock, flags);\n\n\treturn ret;\n}\n\nstatic u8 pll_get_parent(struct clk_hw *hw)\n{\n\tstruct stm32_pll_obj *clk_elem = to_pll(hw);\n\tstruct clk_hw *mux_hw = &clk_elem->mux.hw;\n\n\t__clk_hw_set_clk(mux_hw, hw);\n\n\treturn clk_mux_ops.get_parent(mux_hw);\n}\n\nstatic const struct clk_ops pll_ops = {\n\t.enable\t\t= pll_enable,\n\t.disable\t= pll_disable,\n\t.recalc_rate\t= pll_recalc_rate,\n\t.is_enabled\t= pll_is_enabled,\n\t.get_parent\t= pll_get_parent,\n};\n\nstatic struct clk_hw *clk_register_pll(struct device *dev, const char *name,\n\t\t\t\t       const char * const *parent_names,\n\t\t\t\t       int num_parents,\n\t\t\t\t       void __iomem *reg,\n\t\t\t\t       void __iomem *mux_reg,\n\t\t\t\t       unsigned long flags,\n\t\t\t\t       spinlock_t *lock)\n{\n\tstruct stm32_pll_obj *element;\n\tstruct clk_init_data init;\n\tstruct clk_hw *hw;\n\tint err;\n\n\telement = devm_kzalloc(dev, sizeof(*element), GFP_KERNEL);\n\tif (!element)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &pll_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\n\telement->mux.lock = lock;\n\telement->mux.reg =  mux_reg;\n\telement->mux.shift = PLL_MUX_SHIFT;\n\telement->mux.mask =  PLL_MUX_MASK;\n\telement->mux.flags =  CLK_MUX_READ_ONLY;\n\telement->mux.reg =  mux_reg;\n\n\telement->hw.init = &init;\n\telement->reg = reg;\n\telement->lock = lock;\n\n\thw = &element->hw;\n\terr = clk_hw_register(dev, hw);\n\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn hw;\n}\n\n \nstruct timer_cker {\n\t \n\tspinlock_t *lock;\n\tvoid __iomem *apbdiv;\n\tvoid __iomem *timpre;\n\tstruct clk_hw hw;\n};\n\n#define to_timer_cker(_hw) container_of(_hw, struct timer_cker, hw)\n\n#define APB_DIV_MASK 0x07\n#define TIM_PRE_MASK 0x01\n\nstatic unsigned long __bestmult(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct timer_cker *tim_ker = to_timer_cker(hw);\n\tu32 prescaler;\n\tunsigned int mult = 0;\n\n\tprescaler = readl_relaxed(tim_ker->apbdiv) & APB_DIV_MASK;\n\tif (prescaler < 2)\n\t\treturn 1;\n\n\tmult = 2;\n\n\tif (rate / parent_rate >= 4)\n\t\tmult = 4;\n\n\treturn mult;\n}\n\nstatic long timer_ker_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long *parent_rate)\n{\n\tunsigned long factor = __bestmult(hw, rate, *parent_rate);\n\n\treturn *parent_rate * factor;\n}\n\nstatic int timer_ker_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct timer_cker *tim_ker = to_timer_cker(hw);\n\tunsigned long flags = 0;\n\tunsigned long factor = __bestmult(hw, rate, parent_rate);\n\tint ret = 0;\n\n\tspin_lock_irqsave(tim_ker->lock, flags);\n\n\tswitch (factor) {\n\tcase 1:\n\t\tbreak;\n\tcase 2:\n\t\twritel_relaxed(0, tim_ker->timpre);\n\t\tbreak;\n\tcase 4:\n\t\twritel_relaxed(1, tim_ker->timpre);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tspin_unlock_irqrestore(tim_ker->lock, flags);\n\n\treturn ret;\n}\n\nstatic unsigned long timer_ker_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct timer_cker *tim_ker = to_timer_cker(hw);\n\tu32 prescaler, timpre;\n\tu32 mul;\n\n\tprescaler = readl_relaxed(tim_ker->apbdiv) & APB_DIV_MASK;\n\n\ttimpre = readl_relaxed(tim_ker->timpre) & TIM_PRE_MASK;\n\n\tif (!prescaler)\n\t\treturn parent_rate;\n\n\tmul = (timpre + 1) * 2;\n\n\treturn parent_rate * mul;\n}\n\nstatic const struct clk_ops timer_ker_ops = {\n\t.recalc_rate\t= timer_ker_recalc_rate,\n\t.round_rate\t= timer_ker_round_rate,\n\t.set_rate\t= timer_ker_set_rate,\n\n};\n\nstatic struct clk_hw *clk_register_cktim(struct device *dev, const char *name,\n\t\t\t\t\t const char *parent_name,\n\t\t\t\t\t unsigned long flags,\n\t\t\t\t\t void __iomem *apbdiv,\n\t\t\t\t\t void __iomem *timpre,\n\t\t\t\t\t spinlock_t *lock)\n{\n\tstruct timer_cker *tim_ker;\n\tstruct clk_init_data init;\n\tstruct clk_hw *hw;\n\tint err;\n\n\ttim_ker = devm_kzalloc(dev, sizeof(*tim_ker), GFP_KERNEL);\n\tif (!tim_ker)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &timer_ker_ops;\n\tinit.flags = flags;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\ttim_ker->hw.init = &init;\n\ttim_ker->lock = lock;\n\ttim_ker->apbdiv = apbdiv;\n\ttim_ker->timpre = timpre;\n\n\thw = &tim_ker->hw;\n\terr = clk_hw_register(dev, hw);\n\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn hw;\n}\n\n \n#define HSE_RTC 3\n\nstatic unsigned long clk_divider_rtc_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tif (clk_hw_get_parent(hw) == clk_hw_get_parent_by_index(hw, HSE_RTC))\n\t\treturn clk_divider_ops.recalc_rate(hw, parent_rate);\n\n\treturn parent_rate;\n}\n\nstatic int clk_divider_rtc_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tif (clk_hw_get_parent(hw) == clk_hw_get_parent_by_index(hw, HSE_RTC))\n\t\treturn clk_divider_ops.set_rate(hw, rate, parent_rate);\n\n\treturn parent_rate;\n}\n\nstatic int clk_divider_rtc_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)\n{\n\tif (req->best_parent_hw == clk_hw_get_parent_by_index(hw, HSE_RTC))\n\t\treturn clk_divider_ops.determine_rate(hw, req);\n\n\treq->rate = req->best_parent_rate;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops rtc_div_clk_ops = {\n\t.recalc_rate\t= clk_divider_rtc_recalc_rate,\n\t.set_rate\t= clk_divider_rtc_set_rate,\n\t.determine_rate = clk_divider_rtc_determine_rate\n};\n\nstruct stm32_pll_cfg {\n\tu32 offset;\n\tu32 muxoff;\n};\n\nstatic struct clk_hw *_clk_register_pll(struct device *dev,\n\t\t\t\t\tstruct clk_hw_onecell_data *clk_data,\n\t\t\t\t\tvoid __iomem *base, spinlock_t *lock,\n\t\t\t\t\tconst struct clock_config *cfg)\n{\n\tstruct stm32_pll_cfg *stm_pll_cfg = cfg->cfg;\n\n\treturn clk_register_pll(dev, cfg->name, cfg->parent_names,\n\t\t\t\tcfg->num_parents,\n\t\t\t\tbase + stm_pll_cfg->offset,\n\t\t\t\tbase + stm_pll_cfg->muxoff,\n\t\t\t\tcfg->flags, lock);\n}\n\nstruct stm32_cktim_cfg {\n\tu32 offset_apbdiv;\n\tu32 offset_timpre;\n};\n\nstatic struct clk_hw *_clk_register_cktim(struct device *dev,\n\t\t\t\t\t  struct clk_hw_onecell_data *clk_data,\n\t\t\t\t\t  void __iomem *base, spinlock_t *lock,\n\t\t\t\t\t  const struct clock_config *cfg)\n{\n\tstruct stm32_cktim_cfg *cktim_cfg = cfg->cfg;\n\n\treturn clk_register_cktim(dev, cfg->name, cfg->parent_name, cfg->flags,\n\t\t\t\t  cktim_cfg->offset_apbdiv + base,\n\t\t\t\t  cktim_cfg->offset_timpre + base, lock);\n}\n\nstatic struct clk_hw *\n_clk_stm32_register_gate(struct device *dev,\n\t\t\t struct clk_hw_onecell_data *clk_data,\n\t\t\t void __iomem *base, spinlock_t *lock,\n\t\t\t const struct clock_config *cfg)\n{\n\treturn clk_stm32_register_gate_ops(dev,\n\t\t\t\t    cfg->name,\n\t\t\t\t    cfg->parent_name,\n\t\t\t\t    cfg->parent_data,\n\t\t\t\t    cfg->flags,\n\t\t\t\t    base,\n\t\t\t\t    cfg->cfg,\n\t\t\t\t    lock);\n}\n\nstatic struct clk_hw *\n_clk_stm32_register_composite(struct device *dev,\n\t\t\t      struct clk_hw_onecell_data *clk_data,\n\t\t\t      void __iomem *base, spinlock_t *lock,\n\t\t\t      const struct clock_config *cfg)\n{\n\treturn clk_stm32_register_composite(dev, cfg->name, cfg->parent_names,\n\t\t\t\t\t    cfg->parent_data, cfg->num_parents,\n\t\t\t\t\t    base, cfg->cfg, cfg->flags, lock);\n}\n\n#define GATE(_id, _name, _parent, _flags, _offset, _bit_idx, _gate_flags)\\\n{\\\n\t.id\t\t= _id,\\\n\t.name\t\t= _name,\\\n\t.parent_name\t= _parent,\\\n\t.flags\t\t= _flags,\\\n\t.cfg\t\t=  &(struct gate_cfg) {\\\n\t\t.reg_off\t= _offset,\\\n\t\t.bit_idx\t= _bit_idx,\\\n\t\t.gate_flags\t= _gate_flags,\\\n\t},\\\n\t.func\t\t= _clk_hw_register_gate,\\\n}\n\n#define FIXED_FACTOR(_id, _name, _parent, _flags, _mult, _div)\\\n{\\\n\t.id\t\t= _id,\\\n\t.name\t\t= _name,\\\n\t.parent_name\t= _parent,\\\n\t.flags\t\t= _flags,\\\n\t.cfg\t\t=  &(struct fixed_factor_cfg) {\\\n\t\t.mult = _mult,\\\n\t\t.div = _div,\\\n\t},\\\n\t.func\t\t= _clk_hw_register_fixed_factor,\\\n}\n\n#define DIV_TABLE(_id, _name, _parent, _flags, _offset, _shift, _width,\\\n\t\t  _div_flags, _div_table)\\\n{\\\n\t.id\t\t= _id,\\\n\t.name\t\t= _name,\\\n\t.parent_name\t= _parent,\\\n\t.flags\t\t= _flags,\\\n\t.cfg\t\t=  &(struct div_cfg) {\\\n\t\t.reg_off\t= _offset,\\\n\t\t.shift\t\t= _shift,\\\n\t\t.width\t\t= _width,\\\n\t\t.div_flags\t= _div_flags,\\\n\t\t.table\t\t= _div_table,\\\n\t},\\\n\t.func\t\t= _clk_hw_register_divider_table,\\\n}\n\n#define DIV(_id, _name, _parent, _flags, _offset, _shift, _width, _div_flags)\\\n\tDIV_TABLE(_id, _name, _parent, _flags, _offset, _shift, _width,\\\n\t\t  _div_flags, NULL)\n\n#define MUX(_id, _name, _parents, _flags, _offset, _shift, _width, _mux_flags)\\\n{\\\n\t.id\t\t= _id,\\\n\t.name\t\t= _name,\\\n\t.parent_names\t= _parents,\\\n\t.num_parents\t= ARRAY_SIZE(_parents),\\\n\t.flags\t\t= _flags,\\\n\t.cfg\t\t=  &(struct mux_cfg) {\\\n\t\t.reg_off\t= _offset,\\\n\t\t.shift\t\t= _shift,\\\n\t\t.width\t\t= _width,\\\n\t\t.mux_flags\t= _mux_flags,\\\n\t},\\\n\t.func\t\t= _clk_hw_register_mux,\\\n}\n\n#define PLL(_id, _name, _parents, _flags, _offset_p, _offset_mux)\\\n{\\\n\t.id\t\t= _id,\\\n\t.name\t\t= _name,\\\n\t.parent_names\t= _parents,\\\n\t.num_parents\t= ARRAY_SIZE(_parents),\\\n\t.flags\t\t= CLK_IGNORE_UNUSED | (_flags),\\\n\t.cfg\t\t=  &(struct stm32_pll_cfg) {\\\n\t\t.offset = _offset_p,\\\n\t\t.muxoff = _offset_mux,\\\n\t},\\\n\t.func\t\t= _clk_register_pll,\\\n}\n\n#define STM32_CKTIM(_name, _parent, _flags, _offset_apbdiv, _offset_timpre)\\\n{\\\n\t.id\t\t= NO_ID,\\\n\t.name\t\t= _name,\\\n\t.parent_name\t= _parent,\\\n\t.flags\t\t= _flags,\\\n\t.cfg\t\t=  &(struct stm32_cktim_cfg) {\\\n\t\t.offset_apbdiv = _offset_apbdiv,\\\n\t\t.offset_timpre = _offset_timpre,\\\n\t},\\\n\t.func\t\t= _clk_register_cktim,\\\n}\n\n#define STM32_TIM(_id, _name, _parent, _offset_set, _bit_idx)\\\n\t\t  GATE_MP1(_id, _name, _parent, CLK_SET_RATE_PARENT,\\\n\t\t\t   _offset_set, _bit_idx, 0)\n\n \n#define STM32_GATE(_id, _name, _parent, _flags, _gate)\\\n{\\\n\t.id\t\t= _id,\\\n\t.name\t\t= _name,\\\n\t.parent_name\t= _parent,\\\n\t.flags\t\t= _flags,\\\n\t.cfg\t\t= (struct stm32_gate_cfg *) {_gate},\\\n\t.func\t\t= _clk_stm32_register_gate,\\\n}\n\n#define STM32_GATE_PDATA(_id, _name, _parent, _flags, _gate)\\\n{\\\n\t.id\t\t= _id,\\\n\t.name\t\t= _name,\\\n\t.parent_data\t= _parent,\\\n\t.flags\t\t= _flags,\\\n\t.cfg\t\t= (struct stm32_gate_cfg *) {_gate},\\\n\t.func\t\t= _clk_stm32_register_gate,\\\n}\n\n#define _STM32_GATE(_gate_offset, _gate_bit_idx, _gate_flags, _mgate, _ops)\\\n\t(&(struct stm32_gate_cfg) {\\\n\t\t&(struct gate_cfg) {\\\n\t\t\t.reg_off\t= _gate_offset,\\\n\t\t\t.bit_idx\t= _gate_bit_idx,\\\n\t\t\t.gate_flags\t= _gate_flags,\\\n\t\t},\\\n\t\t.mgate\t\t= _mgate,\\\n\t\t.ops\t\t= _ops,\\\n\t})\n\n#define _STM32_MGATE(_mgate)\\\n\t(&per_gate_cfg[_mgate])\n\n#define _GATE(_gate_offset, _gate_bit_idx, _gate_flags)\\\n\t_STM32_GATE(_gate_offset, _gate_bit_idx, _gate_flags,\\\n\t\t    NULL, NULL)\\\n\n#define _GATE_MP1(_gate_offset, _gate_bit_idx, _gate_flags)\\\n\t_STM32_GATE(_gate_offset, _gate_bit_idx, _gate_flags,\\\n\t\t    NULL, &mp1_gate_clk_ops)\\\n\n#define _MGATE_MP1(_mgate)\\\n\t.gate = &per_gate_cfg[_mgate]\n\n#define GATE_MP1(_id, _name, _parent, _flags, _offset, _bit_idx, _gate_flags)\\\n\tSTM32_GATE(_id, _name, _parent, _flags,\\\n\t\t   _GATE_MP1(_offset, _bit_idx, _gate_flags))\n\n#define MGATE_MP1(_id, _name, _parent, _flags, _mgate)\\\n\tSTM32_GATE(_id, _name, _parent, _flags,\\\n\t\t   _STM32_MGATE(_mgate))\n\n#define MGATE_MP1_PDATA(_id, _name, _parent, _flags, _mgate)\\\n\tSTM32_GATE_PDATA(_id, _name, _parent, _flags,\\\n\t\t   _STM32_MGATE(_mgate))\n\n#define _STM32_DIV(_div_offset, _div_shift, _div_width,\\\n\t\t   _div_flags, _div_table, _ops)\\\n\t.div = &(struct stm32_div_cfg) {\\\n\t\t&(struct div_cfg) {\\\n\t\t\t.reg_off\t= _div_offset,\\\n\t\t\t.shift\t\t= _div_shift,\\\n\t\t\t.width\t\t= _div_width,\\\n\t\t\t.div_flags\t= _div_flags,\\\n\t\t\t.table\t\t= _div_table,\\\n\t\t},\\\n\t\t.ops\t\t= _ops,\\\n\t}\n\n#define _DIV(_div_offset, _div_shift, _div_width, _div_flags, _div_table)\\\n\t_STM32_DIV(_div_offset, _div_shift, _div_width,\\\n\t\t   _div_flags, _div_table, NULL)\\\n\n#define _DIV_RTC(_div_offset, _div_shift, _div_width, _div_flags, _div_table)\\\n\t_STM32_DIV(_div_offset, _div_shift, _div_width,\\\n\t\t   _div_flags, _div_table, &rtc_div_clk_ops)\n\n#define _STM32_MUX(_offset, _shift, _width, _mux_flags, _mmux, _ops)\\\n\t.mux = &(struct stm32_mux_cfg) {\\\n\t\t&(struct mux_cfg) {\\\n\t\t\t.reg_off\t= _offset,\\\n\t\t\t.shift\t\t= _shift,\\\n\t\t\t.width\t\t= _width,\\\n\t\t\t.mux_flags\t= _mux_flags,\\\n\t\t\t.table\t\t= NULL,\\\n\t\t},\\\n\t\t.mmux\t\t= _mmux,\\\n\t\t.ops\t\t= _ops,\\\n\t}\n\n#define _MUX(_offset, _shift, _width, _mux_flags)\\\n\t_STM32_MUX(_offset, _shift, _width, _mux_flags, NULL, NULL)\\\n\n#define _MMUX(_mmux) .mux = &ker_mux_cfg[_mmux]\n\n#define PARENT(_parent) ((const char *[]) { _parent})\n\n#define _NO_MUX .mux = NULL\n#define _NO_DIV .div = NULL\n#define _NO_GATE .gate = NULL\n\n#define COMPOSITE(_id, _name, _parents, _flags, _gate, _mux, _div)\\\n{\\\n\t.id\t\t= _id,\\\n\t.name\t\t= _name,\\\n\t.parent_names\t= _parents,\\\n\t.num_parents\t= ARRAY_SIZE(_parents),\\\n\t.flags\t\t= _flags,\\\n\t.cfg\t\t= &(struct stm32_composite_cfg) {\\\n\t\t_gate,\\\n\t\t_mux,\\\n\t\t_div,\\\n\t},\\\n\t.func\t\t= _clk_stm32_register_composite,\\\n}\n\n#define PCLK(_id, _name, _parent, _flags, _mgate)\\\n\tMGATE_MP1(_id, _name, _parent, _flags, _mgate)\n\n#define PCLK_PDATA(_id, _name, _parent, _flags, _mgate)\\\n\tMGATE_MP1_PDATA(_id, _name, _parent, _flags, _mgate)\n\n#define KCLK(_id, _name, _parents, _flags, _mgate, _mmux)\\\n\t     COMPOSITE(_id, _name, _parents, CLK_OPS_PARENT_ENABLE |\\\n\t\t       CLK_SET_RATE_NO_REPARENT | _flags,\\\n\t\t       _MGATE_MP1(_mgate),\\\n\t\t       _MMUX(_mmux),\\\n\t\t       _NO_DIV)\n\nenum {\n\tG_SAI1,\n\tG_SAI2,\n\tG_SAI3,\n\tG_SAI4,\n\tG_SPI1,\n\tG_SPI2,\n\tG_SPI3,\n\tG_SPI4,\n\tG_SPI5,\n\tG_SPI6,\n\tG_SPDIF,\n\tG_I2C1,\n\tG_I2C2,\n\tG_I2C3,\n\tG_I2C4,\n\tG_I2C5,\n\tG_I2C6,\n\tG_USART2,\n\tG_UART4,\n\tG_USART3,\n\tG_UART5,\n\tG_USART1,\n\tG_USART6,\n\tG_UART7,\n\tG_UART8,\n\tG_LPTIM1,\n\tG_LPTIM2,\n\tG_LPTIM3,\n\tG_LPTIM4,\n\tG_LPTIM5,\n\tG_LTDC,\n\tG_DSI,\n\tG_QSPI,\n\tG_FMC,\n\tG_SDMMC1,\n\tG_SDMMC2,\n\tG_SDMMC3,\n\tG_USBO,\n\tG_USBPHY,\n\tG_RNG1,\n\tG_RNG2,\n\tG_FDCAN,\n\tG_DAC12,\n\tG_CEC,\n\tG_ADC12,\n\tG_GPU,\n\tG_STGEN,\n\tG_DFSDM,\n\tG_ADFSDM,\n\tG_TIM2,\n\tG_TIM3,\n\tG_TIM4,\n\tG_TIM5,\n\tG_TIM6,\n\tG_TIM7,\n\tG_TIM12,\n\tG_TIM13,\n\tG_TIM14,\n\tG_MDIO,\n\tG_TIM1,\n\tG_TIM8,\n\tG_TIM15,\n\tG_TIM16,\n\tG_TIM17,\n\tG_SYSCFG,\n\tG_VREF,\n\tG_TMPSENS,\n\tG_PMBCTRL,\n\tG_HDP,\n\tG_IWDG2,\n\tG_STGENRO,\n\tG_DMA1,\n\tG_DMA2,\n\tG_DMAMUX,\n\tG_DCMI,\n\tG_CRYP2,\n\tG_HASH2,\n\tG_CRC2,\n\tG_HSEM,\n\tG_IPCC,\n\tG_GPIOA,\n\tG_GPIOB,\n\tG_GPIOC,\n\tG_GPIOD,\n\tG_GPIOE,\n\tG_GPIOF,\n\tG_GPIOG,\n\tG_GPIOH,\n\tG_GPIOI,\n\tG_GPIOJ,\n\tG_GPIOK,\n\tG_MDMA,\n\tG_ETHCK,\n\tG_ETHTX,\n\tG_ETHRX,\n\tG_ETHMAC,\n\tG_CRC1,\n\tG_USBH,\n\tG_ETHSTP,\n\tG_RTCAPB,\n\tG_TZC1,\n\tG_TZC2,\n\tG_TZPC,\n\tG_IWDG1,\n\tG_BSEC,\n\tG_GPIOZ,\n\tG_CRYP1,\n\tG_HASH1,\n\tG_BKPSRAM,\n\tG_DDRPERFM,\n\n\tG_LAST\n};\n\nstatic struct stm32_mgate mp1_mgate[G_LAST];\n\n#define _K_GATE(_id, _gate_offset, _gate_bit_idx, _gate_flags,\\\n\t       _mgate, _ops)\\\n\t[_id] = {\\\n\t\t&(struct gate_cfg) {\\\n\t\t\t.reg_off\t= _gate_offset,\\\n\t\t\t.bit_idx\t= _gate_bit_idx,\\\n\t\t\t.gate_flags\t= _gate_flags,\\\n\t\t},\\\n\t\t.mgate\t\t= _mgate,\\\n\t\t.ops\t\t= _ops,\\\n\t}\n\n#define K_GATE(_id, _gate_offset, _gate_bit_idx, _gate_flags)\\\n\t_K_GATE(_id, _gate_offset, _gate_bit_idx, _gate_flags,\\\n\t       NULL, &mp1_gate_clk_ops)\n\n#define K_MGATE(_id, _gate_offset, _gate_bit_idx, _gate_flags)\\\n\t_K_GATE(_id, _gate_offset, _gate_bit_idx, _gate_flags,\\\n\t       &mp1_mgate[_id], &mp1_mgate_clk_ops)\n\n \nstatic struct stm32_gate_cfg per_gate_cfg[G_LAST] = {\n\t \n\tK_GATE(G_MDIO,\t\tRCC_APB1ENSETR, 31, 0),\n\tK_MGATE(G_DAC12,\tRCC_APB1ENSETR, 29, 0),\n\tK_MGATE(G_CEC,\t\tRCC_APB1ENSETR, 27, 0),\n\tK_MGATE(G_SPDIF,\tRCC_APB1ENSETR, 26, 0),\n\tK_MGATE(G_I2C5,\t\tRCC_APB1ENSETR, 24, 0),\n\tK_MGATE(G_I2C3,\t\tRCC_APB1ENSETR, 23, 0),\n\tK_MGATE(G_I2C2,\t\tRCC_APB1ENSETR, 22, 0),\n\tK_MGATE(G_I2C1,\t\tRCC_APB1ENSETR, 21, 0),\n\tK_MGATE(G_UART8,\tRCC_APB1ENSETR, 19, 0),\n\tK_MGATE(G_UART7,\tRCC_APB1ENSETR, 18, 0),\n\tK_MGATE(G_UART5,\tRCC_APB1ENSETR, 17, 0),\n\tK_MGATE(G_UART4,\tRCC_APB1ENSETR, 16, 0),\n\tK_MGATE(G_USART3,\tRCC_APB1ENSETR, 15, 0),\n\tK_MGATE(G_USART2,\tRCC_APB1ENSETR, 14, 0),\n\tK_MGATE(G_SPI3,\t\tRCC_APB1ENSETR, 12, 0),\n\tK_MGATE(G_SPI2,\t\tRCC_APB1ENSETR, 11, 0),\n\tK_MGATE(G_LPTIM1,\tRCC_APB1ENSETR, 9, 0),\n\tK_GATE(G_TIM14,\t\tRCC_APB1ENSETR, 8, 0),\n\tK_GATE(G_TIM13,\t\tRCC_APB1ENSETR, 7, 0),\n\tK_GATE(G_TIM12,\t\tRCC_APB1ENSETR, 6, 0),\n\tK_GATE(G_TIM7,\t\tRCC_APB1ENSETR, 5, 0),\n\tK_GATE(G_TIM6,\t\tRCC_APB1ENSETR, 4, 0),\n\tK_GATE(G_TIM5,\t\tRCC_APB1ENSETR, 3, 0),\n\tK_GATE(G_TIM4,\t\tRCC_APB1ENSETR, 2, 0),\n\tK_GATE(G_TIM3,\t\tRCC_APB1ENSETR, 1, 0),\n\tK_GATE(G_TIM2,\t\tRCC_APB1ENSETR, 0, 0),\n\n\tK_MGATE(G_FDCAN,\tRCC_APB2ENSETR, 24, 0),\n\tK_GATE(G_ADFSDM,\tRCC_APB2ENSETR, 21, 0),\n\tK_GATE(G_DFSDM,\t\tRCC_APB2ENSETR, 20, 0),\n\tK_MGATE(G_SAI3,\t\tRCC_APB2ENSETR, 18, 0),\n\tK_MGATE(G_SAI2,\t\tRCC_APB2ENSETR, 17, 0),\n\tK_MGATE(G_SAI1,\t\tRCC_APB2ENSETR, 16, 0),\n\tK_MGATE(G_USART6,\tRCC_APB2ENSETR, 13, 0),\n\tK_MGATE(G_SPI5,\t\tRCC_APB2ENSETR, 10, 0),\n\tK_MGATE(G_SPI4,\t\tRCC_APB2ENSETR, 9, 0),\n\tK_MGATE(G_SPI1,\t\tRCC_APB2ENSETR, 8, 0),\n\tK_GATE(G_TIM17,\t\tRCC_APB2ENSETR, 4, 0),\n\tK_GATE(G_TIM16,\t\tRCC_APB2ENSETR, 3, 0),\n\tK_GATE(G_TIM15,\t\tRCC_APB2ENSETR, 2, 0),\n\tK_GATE(G_TIM8,\t\tRCC_APB2ENSETR, 1, 0),\n\tK_GATE(G_TIM1,\t\tRCC_APB2ENSETR, 0, 0),\n\n\tK_GATE(G_HDP,\t\tRCC_APB3ENSETR, 20, 0),\n\tK_GATE(G_PMBCTRL,\tRCC_APB3ENSETR, 17, 0),\n\tK_GATE(G_TMPSENS,\tRCC_APB3ENSETR, 16, 0),\n\tK_GATE(G_VREF,\t\tRCC_APB3ENSETR, 13, 0),\n\tK_GATE(G_SYSCFG,\tRCC_APB3ENSETR, 11, 0),\n\tK_MGATE(G_SAI4,\t\tRCC_APB3ENSETR, 8, 0),\n\tK_MGATE(G_LPTIM5,\tRCC_APB3ENSETR, 3, 0),\n\tK_MGATE(G_LPTIM4,\tRCC_APB3ENSETR, 2, 0),\n\tK_MGATE(G_LPTIM3,\tRCC_APB3ENSETR, 1, 0),\n\tK_MGATE(G_LPTIM2,\tRCC_APB3ENSETR, 0, 0),\n\n\tK_GATE(G_STGENRO,\tRCC_APB4ENSETR, 20, 0),\n\tK_MGATE(G_USBPHY,\tRCC_APB4ENSETR, 16, 0),\n\tK_GATE(G_IWDG2,\t\tRCC_APB4ENSETR, 15, 0),\n\tK_GATE(G_DDRPERFM,\tRCC_APB4ENSETR, 8, 0),\n\tK_MGATE(G_DSI,\t\tRCC_APB4ENSETR, 4, 0),\n\tK_MGATE(G_LTDC,\t\tRCC_APB4ENSETR, 0, 0),\n\n\tK_GATE(G_STGEN,\t\tRCC_APB5ENSETR, 20, 0),\n\tK_GATE(G_BSEC,\t\tRCC_APB5ENSETR, 16, 0),\n\tK_GATE(G_IWDG1,\t\tRCC_APB5ENSETR, 15, 0),\n\tK_GATE(G_TZPC,\t\tRCC_APB5ENSETR, 13, 0),\n\tK_GATE(G_TZC2,\t\tRCC_APB5ENSETR, 12, 0),\n\tK_GATE(G_TZC1,\t\tRCC_APB5ENSETR, 11, 0),\n\tK_GATE(G_RTCAPB,\tRCC_APB5ENSETR, 8, 0),\n\tK_MGATE(G_USART1,\tRCC_APB5ENSETR, 4, 0),\n\tK_MGATE(G_I2C6,\t\tRCC_APB5ENSETR, 3, 0),\n\tK_MGATE(G_I2C4,\t\tRCC_APB5ENSETR, 2, 0),\n\tK_MGATE(G_SPI6,\t\tRCC_APB5ENSETR, 0, 0),\n\n\tK_MGATE(G_SDMMC3,\tRCC_AHB2ENSETR, 16, 0),\n\tK_MGATE(G_USBO,\t\tRCC_AHB2ENSETR, 8, 0),\n\tK_MGATE(G_ADC12,\tRCC_AHB2ENSETR, 5, 0),\n\tK_GATE(G_DMAMUX,\tRCC_AHB2ENSETR, 2, 0),\n\tK_GATE(G_DMA2,\t\tRCC_AHB2ENSETR, 1, 0),\n\tK_GATE(G_DMA1,\t\tRCC_AHB2ENSETR, 0, 0),\n\n\tK_GATE(G_IPCC,\t\tRCC_AHB3ENSETR, 12, 0),\n\tK_GATE(G_HSEM,\t\tRCC_AHB3ENSETR, 11, 0),\n\tK_GATE(G_CRC2,\t\tRCC_AHB3ENSETR, 7, 0),\n\tK_MGATE(G_RNG2,\t\tRCC_AHB3ENSETR, 6, 0),\n\tK_GATE(G_HASH2,\t\tRCC_AHB3ENSETR, 5, 0),\n\tK_GATE(G_CRYP2,\t\tRCC_AHB3ENSETR, 4, 0),\n\tK_GATE(G_DCMI,\t\tRCC_AHB3ENSETR, 0, 0),\n\n\tK_GATE(G_GPIOK,\t\tRCC_AHB4ENSETR, 10, 0),\n\tK_GATE(G_GPIOJ,\t\tRCC_AHB4ENSETR, 9, 0),\n\tK_GATE(G_GPIOI,\t\tRCC_AHB4ENSETR, 8, 0),\n\tK_GATE(G_GPIOH,\t\tRCC_AHB4ENSETR, 7, 0),\n\tK_GATE(G_GPIOG,\t\tRCC_AHB4ENSETR, 6, 0),\n\tK_GATE(G_GPIOF,\t\tRCC_AHB4ENSETR, 5, 0),\n\tK_GATE(G_GPIOE,\t\tRCC_AHB4ENSETR, 4, 0),\n\tK_GATE(G_GPIOD,\t\tRCC_AHB4ENSETR, 3, 0),\n\tK_GATE(G_GPIOC,\t\tRCC_AHB4ENSETR, 2, 0),\n\tK_GATE(G_GPIOB,\t\tRCC_AHB4ENSETR, 1, 0),\n\tK_GATE(G_GPIOA,\t\tRCC_AHB4ENSETR, 0, 0),\n\n\tK_GATE(G_BKPSRAM,\tRCC_AHB5ENSETR, 8, 0),\n\tK_MGATE(G_RNG1,\t\tRCC_AHB5ENSETR, 6, 0),\n\tK_GATE(G_HASH1,\t\tRCC_AHB5ENSETR, 5, 0),\n\tK_GATE(G_CRYP1,\t\tRCC_AHB5ENSETR, 4, 0),\n\tK_GATE(G_GPIOZ,\t\tRCC_AHB5ENSETR, 0, 0),\n\n\tK_GATE(G_USBH,\t\tRCC_AHB6ENSETR, 24, 0),\n\tK_GATE(G_CRC1,\t\tRCC_AHB6ENSETR, 20, 0),\n\tK_MGATE(G_SDMMC2,\tRCC_AHB6ENSETR, 17, 0),\n\tK_MGATE(G_SDMMC1,\tRCC_AHB6ENSETR, 16, 0),\n\tK_MGATE(G_QSPI,\t\tRCC_AHB6ENSETR, 14, 0),\n\tK_MGATE(G_FMC,\t\tRCC_AHB6ENSETR, 12, 0),\n\tK_GATE(G_ETHMAC,\tRCC_AHB6ENSETR, 10, 0),\n\tK_GATE(G_ETHRX,\t\tRCC_AHB6ENSETR, 9, 0),\n\tK_GATE(G_ETHTX,\t\tRCC_AHB6ENSETR, 8, 0),\n\tK_GATE(G_ETHCK,\t\tRCC_AHB6ENSETR, 7, 0),\n\tK_MGATE(G_GPU,\t\tRCC_AHB6ENSETR, 5, 0),\n\tK_GATE(G_MDMA,\t\tRCC_AHB6ENSETR, 0, 0),\n\tK_GATE(G_ETHSTP,\tRCC_AHB6LPENSETR, 11, 0),\n};\n\nenum {\n\tM_SDMMC12,\n\tM_SDMMC3,\n\tM_FMC,\n\tM_QSPI,\n\tM_RNG1,\n\tM_RNG2,\n\tM_USBPHY,\n\tM_USBO,\n\tM_STGEN,\n\tM_SPDIF,\n\tM_SPI1,\n\tM_SPI23,\n\tM_SPI45,\n\tM_SPI6,\n\tM_CEC,\n\tM_I2C12,\n\tM_I2C35,\n\tM_I2C46,\n\tM_LPTIM1,\n\tM_LPTIM23,\n\tM_LPTIM45,\n\tM_USART1,\n\tM_UART24,\n\tM_UART35,\n\tM_USART6,\n\tM_UART78,\n\tM_SAI1,\n\tM_SAI2,\n\tM_SAI3,\n\tM_SAI4,\n\tM_DSI,\n\tM_FDCAN,\n\tM_ADC12,\n\tM_ETHCK,\n\tM_CKPER,\n\tM_LAST\n};\n\nstatic struct stm32_mmux ker_mux[M_LAST];\n\n#define _K_MUX(_id, _offset, _shift, _width, _mux_flags, _mmux, _ops)\\\n\t[_id] = {\\\n\t\t&(struct mux_cfg) {\\\n\t\t\t.reg_off\t= _offset,\\\n\t\t\t.shift\t\t= _shift,\\\n\t\t\t.width\t\t= _width,\\\n\t\t\t.mux_flags\t= _mux_flags,\\\n\t\t\t.table\t\t= NULL,\\\n\t\t},\\\n\t\t.mmux\t\t= _mmux,\\\n\t\t.ops\t\t= _ops,\\\n\t}\n\n#define K_MUX(_id, _offset, _shift, _width, _mux_flags)\\\n\t_K_MUX(_id, _offset, _shift, _width, _mux_flags,\\\n\t\t\tNULL, NULL)\n\n#define K_MMUX(_id, _offset, _shift, _width, _mux_flags)\\\n\t_K_MUX(_id, _offset, _shift, _width, _mux_flags,\\\n\t\t\t&ker_mux[_id], &clk_mmux_ops)\n\nstatic const struct stm32_mux_cfg ker_mux_cfg[M_LAST] = {\n\t \n\tK_MMUX(M_SDMMC12, RCC_SDMMC12CKSELR, 0, 3, 0),\n\tK_MMUX(M_SPI23, RCC_SPI2S23CKSELR, 0, 3, 0),\n\tK_MMUX(M_SPI45, RCC_SPI2S45CKSELR, 0, 3, 0),\n\tK_MMUX(M_I2C12, RCC_I2C12CKSELR, 0, 3, 0),\n\tK_MMUX(M_I2C35, RCC_I2C35CKSELR, 0, 3, 0),\n\tK_MMUX(M_LPTIM23, RCC_LPTIM23CKSELR, 0, 3, 0),\n\tK_MMUX(M_LPTIM45, RCC_LPTIM45CKSELR, 0, 3, 0),\n\tK_MMUX(M_UART24, RCC_UART24CKSELR, 0, 3, 0),\n\tK_MMUX(M_UART35, RCC_UART35CKSELR, 0, 3, 0),\n\tK_MMUX(M_UART78, RCC_UART78CKSELR, 0, 3, 0),\n\tK_MMUX(M_SAI1, RCC_SAI1CKSELR, 0, 3, 0),\n\tK_MMUX(M_ETHCK, RCC_ETHCKSELR, 0, 2, 0),\n\tK_MMUX(M_I2C46, RCC_I2C46CKSELR, 0, 3, 0),\n\n\t \n\tK_MUX(M_RNG2, RCC_RNG2CKSELR, 0, 2, 0),\n\tK_MUX(M_SDMMC3, RCC_SDMMC3CKSELR, 0, 3, 0),\n\tK_MUX(M_FMC, RCC_FMCCKSELR, 0, 2, 0),\n\tK_MUX(M_QSPI, RCC_QSPICKSELR, 0, 2, 0),\n\tK_MUX(M_USBPHY, RCC_USBCKSELR, 0, 2, 0),\n\tK_MUX(M_USBO, RCC_USBCKSELR, 4, 1, 0),\n\tK_MUX(M_SPDIF, RCC_SPDIFCKSELR, 0, 2, 0),\n\tK_MUX(M_SPI1, RCC_SPI2S1CKSELR, 0, 3, 0),\n\tK_MUX(M_CEC, RCC_CECCKSELR, 0, 2, 0),\n\tK_MUX(M_LPTIM1, RCC_LPTIM1CKSELR, 0, 3, 0),\n\tK_MUX(M_USART6, RCC_UART6CKSELR, 0, 3, 0),\n\tK_MUX(M_FDCAN, RCC_FDCANCKSELR, 0, 2, 0),\n\tK_MUX(M_SAI2, RCC_SAI2CKSELR, 0, 3, 0),\n\tK_MUX(M_SAI3, RCC_SAI3CKSELR, 0, 3, 0),\n\tK_MUX(M_SAI4, RCC_SAI4CKSELR, 0, 3, 0),\n\tK_MUX(M_ADC12, RCC_ADCCKSELR, 0, 2, 0),\n\tK_MUX(M_DSI, RCC_DSICKSELR, 0, 1, 0),\n\tK_MUX(M_CKPER, RCC_CPERCKSELR, 0, 2, 0),\n\tK_MUX(M_RNG1, RCC_RNG1CKSELR, 0, 2, 0),\n\tK_MUX(M_STGEN, RCC_STGENCKSELR, 0, 2, 0),\n\tK_MUX(M_USART1, RCC_UART1CKSELR, 0, 3, 0),\n\tK_MUX(M_SPI6, RCC_SPI6CKSELR, 0, 3, 0),\n};\n\nstatic const struct clock_config stm32mp1_clock_cfg[] = {\n\t \n\tGATE_MP1(CK_HSE, \"ck_hse\", \"clk-hse\", 0, RCC_OCENSETR, 8, 0),\n\t \n\tGATE_MP1(CK_CSI, \"ck_csi\", \"clk-csi\", CLK_IS_CRITICAL,\n\t\t RCC_OCENSETR, 4, 0),\n\tCOMPOSITE(CK_HSI, \"ck_hsi\", PARENT(\"clk-hsi\"), 0,\n\t\t  _GATE_MP1(RCC_OCENSETR, 0, 0),\n\t\t  _NO_MUX,\n\t\t  _DIV(RCC_HSICFGR, 0, 2, CLK_DIVIDER_POWER_OF_TWO |\n\t\t       CLK_DIVIDER_READ_ONLY, NULL)),\n\tGATE(CK_LSI, \"ck_lsi\", \"clk-lsi\", 0, RCC_RDLSICR, 0, 0),\n\tGATE(CK_LSE, \"ck_lse\", \"clk-lse\", 0, RCC_BDCR, 0, 0),\n\n\tFIXED_FACTOR(CK_HSE_DIV2, \"clk-hse-div2\", \"ck_hse\", 0, 1, 2),\n\n\t \n\tPLL(PLL1, \"pll1\", ref12_parents, 0, RCC_PLL1CR, RCC_RCK12SELR),\n\tPLL(PLL2, \"pll2\", ref12_parents, 0, RCC_PLL2CR, RCC_RCK12SELR),\n\tPLL(PLL3, \"pll3\", ref3_parents, 0, RCC_PLL3CR, RCC_RCK3SELR),\n\tPLL(PLL4, \"pll4\", ref4_parents, 0, RCC_PLL4CR, RCC_RCK4SELR),\n\n\t \n\tCOMPOSITE(PLL1_P, \"pll1_p\", PARENT(\"pll1\"), 0,\n\t\t  _GATE(RCC_PLL1CR, 4, 0),\n\t\t  _NO_MUX,\n\t\t  _DIV(RCC_PLL1CFGR2, 0, 7, 0, NULL)),\n\n\tCOMPOSITE(PLL2_P, \"pll2_p\", PARENT(\"pll2\"), 0,\n\t\t  _GATE(RCC_PLL2CR, 4, 0),\n\t\t  _NO_MUX,\n\t\t  _DIV(RCC_PLL2CFGR2, 0, 7, 0, NULL)),\n\n\tCOMPOSITE(PLL2_Q, \"pll2_q\", PARENT(\"pll2\"), 0,\n\t\t  _GATE(RCC_PLL2CR, 5, 0),\n\t\t  _NO_MUX,\n\t\t  _DIV(RCC_PLL2CFGR2, 8, 7, 0, NULL)),\n\n\tCOMPOSITE(PLL2_R, \"pll2_r\", PARENT(\"pll2\"), CLK_IS_CRITICAL,\n\t\t  _GATE(RCC_PLL2CR, 6, 0),\n\t\t  _NO_MUX,\n\t\t  _DIV(RCC_PLL2CFGR2, 16, 7, 0, NULL)),\n\n\tCOMPOSITE(PLL3_P, \"pll3_p\", PARENT(\"pll3\"), 0,\n\t\t  _GATE(RCC_PLL3CR, 4, 0),\n\t\t  _NO_MUX,\n\t\t  _DIV(RCC_PLL3CFGR2, 0, 7, 0, NULL)),\n\n\tCOMPOSITE(PLL3_Q, \"pll3_q\", PARENT(\"pll3\"), 0,\n\t\t  _GATE(RCC_PLL3CR, 5, 0),\n\t\t  _NO_MUX,\n\t\t  _DIV(RCC_PLL3CFGR2, 8, 7, 0, NULL)),\n\n\tCOMPOSITE(PLL3_R, \"pll3_r\", PARENT(\"pll3\"), 0,\n\t\t  _GATE(RCC_PLL3CR, 6, 0),\n\t\t  _NO_MUX,\n\t\t  _DIV(RCC_PLL3CFGR2, 16, 7, 0, NULL)),\n\n\tCOMPOSITE(PLL4_P, \"pll4_p\", PARENT(\"pll4\"), 0,\n\t\t  _GATE(RCC_PLL4CR, 4, 0),\n\t\t  _NO_MUX,\n\t\t  _DIV(RCC_PLL4CFGR2, 0, 7, 0, NULL)),\n\n\tCOMPOSITE(PLL4_Q, \"pll4_q\", PARENT(\"pll4\"), 0,\n\t\t  _GATE(RCC_PLL4CR, 5, 0),\n\t\t  _NO_MUX,\n\t\t  _DIV(RCC_PLL4CFGR2, 8, 7, 0, NULL)),\n\n\tCOMPOSITE(PLL4_R, \"pll4_r\", PARENT(\"pll4\"), 0,\n\t\t  _GATE(RCC_PLL4CR, 6, 0),\n\t\t  _NO_MUX,\n\t\t  _DIV(RCC_PLL4CFGR2, 16, 7, 0, NULL)),\n\n\t \n\tMUX(CK_PER, \"ck_per\", per_src, CLK_OPS_PARENT_ENABLE,\n\t    RCC_CPERCKSELR, 0, 2, 0),\n\n\tMUX(CK_MPU, \"ck_mpu\", cpu_src, CLK_OPS_PARENT_ENABLE |\n\t     CLK_IS_CRITICAL, RCC_MPCKSELR, 0, 2, 0),\n\n\tCOMPOSITE(CK_AXI, \"ck_axi\", axi_src, CLK_IS_CRITICAL |\n\t\t   CLK_OPS_PARENT_ENABLE,\n\t\t   _NO_GATE,\n\t\t   _MUX(RCC_ASSCKSELR, 0, 2, 0),\n\t\t   _DIV(RCC_AXIDIVR, 0, 3, 0, axi_div_table)),\n\n\tCOMPOSITE(CK_MCU, \"ck_mcu\", mcu_src, CLK_IS_CRITICAL |\n\t\t   CLK_OPS_PARENT_ENABLE,\n\t\t   _NO_GATE,\n\t\t   _MUX(RCC_MSSCKSELR, 0, 2, 0),\n\t\t   _DIV(RCC_MCUDIVR, 0, 4, 0, mcu_div_table)),\n\n\tDIV_TABLE(NO_ID, \"pclk1\", \"ck_mcu\", CLK_IGNORE_UNUSED, RCC_APB1DIVR, 0,\n\t\t  3, CLK_DIVIDER_READ_ONLY, apb_div_table),\n\n\tDIV_TABLE(NO_ID, \"pclk2\", \"ck_mcu\", CLK_IGNORE_UNUSED, RCC_APB2DIVR, 0,\n\t\t  3, CLK_DIVIDER_READ_ONLY, apb_div_table),\n\n\tDIV_TABLE(NO_ID, \"pclk3\", \"ck_mcu\", CLK_IGNORE_UNUSED, RCC_APB3DIVR, 0,\n\t\t  3, CLK_DIVIDER_READ_ONLY, apb_div_table),\n\n\tDIV_TABLE(NO_ID, \"pclk4\", \"ck_axi\", CLK_IGNORE_UNUSED, RCC_APB4DIVR, 0,\n\t\t  3, CLK_DIVIDER_READ_ONLY, apb_div_table),\n\n\tDIV_TABLE(NO_ID, \"pclk5\", \"ck_axi\", CLK_IGNORE_UNUSED, RCC_APB5DIVR, 0,\n\t\t  3, CLK_DIVIDER_READ_ONLY, apb_div_table),\n\n\t \n\tSTM32_CKTIM(\"ck1_tim\", \"pclk1\", 0, RCC_APB1DIVR, RCC_TIMG1PRER),\n\tSTM32_CKTIM(\"ck2_tim\", \"pclk2\", 0, RCC_APB2DIVR, RCC_TIMG2PRER),\n\n\tSTM32_TIM(TIM2_K, \"tim2_k\", \"ck1_tim\", RCC_APB1ENSETR, 0),\n\tSTM32_TIM(TIM3_K, \"tim3_k\", \"ck1_tim\", RCC_APB1ENSETR, 1),\n\tSTM32_TIM(TIM4_K, \"tim4_k\", \"ck1_tim\", RCC_APB1ENSETR, 2),\n\tSTM32_TIM(TIM5_K, \"tim5_k\", \"ck1_tim\", RCC_APB1ENSETR, 3),\n\tSTM32_TIM(TIM6_K, \"tim6_k\", \"ck1_tim\", RCC_APB1ENSETR, 4),\n\tSTM32_TIM(TIM7_K, \"tim7_k\", \"ck1_tim\", RCC_APB1ENSETR, 5),\n\tSTM32_TIM(TIM12_K, \"tim12_k\", \"ck1_tim\", RCC_APB1ENSETR, 6),\n\tSTM32_TIM(TIM13_K, \"tim13_k\", \"ck1_tim\", RCC_APB1ENSETR, 7),\n\tSTM32_TIM(TIM14_K, \"tim14_k\", \"ck1_tim\", RCC_APB1ENSETR, 8),\n\tSTM32_TIM(TIM1_K, \"tim1_k\", \"ck2_tim\", RCC_APB2ENSETR, 0),\n\tSTM32_TIM(TIM8_K, \"tim8_k\", \"ck2_tim\", RCC_APB2ENSETR, 1),\n\tSTM32_TIM(TIM15_K, \"tim15_k\", \"ck2_tim\", RCC_APB2ENSETR, 2),\n\tSTM32_TIM(TIM16_K, \"tim16_k\", \"ck2_tim\", RCC_APB2ENSETR, 3),\n\tSTM32_TIM(TIM17_K, \"tim17_k\", \"ck2_tim\", RCC_APB2ENSETR, 4),\n\n\t \n\tPCLK(TIM2, \"tim2\", \"pclk1\", CLK_IGNORE_UNUSED, G_TIM2),\n\tPCLK(TIM3, \"tim3\", \"pclk1\", CLK_IGNORE_UNUSED, G_TIM3),\n\tPCLK(TIM4, \"tim4\", \"pclk1\", CLK_IGNORE_UNUSED, G_TIM4),\n\tPCLK(TIM5, \"tim5\", \"pclk1\", CLK_IGNORE_UNUSED, G_TIM5),\n\tPCLK(TIM6, \"tim6\", \"pclk1\", CLK_IGNORE_UNUSED, G_TIM6),\n\tPCLK(TIM7, \"tim7\", \"pclk1\", CLK_IGNORE_UNUSED, G_TIM7),\n\tPCLK(TIM12, \"tim12\", \"pclk1\", CLK_IGNORE_UNUSED, G_TIM12),\n\tPCLK(TIM13, \"tim13\", \"pclk1\", CLK_IGNORE_UNUSED, G_TIM13),\n\tPCLK(TIM14, \"tim14\", \"pclk1\", CLK_IGNORE_UNUSED, G_TIM14),\n\tPCLK(LPTIM1, \"lptim1\", \"pclk1\", 0, G_LPTIM1),\n\tPCLK(SPI2, \"spi2\", \"pclk1\", 0, G_SPI2),\n\tPCLK(SPI3, \"spi3\", \"pclk1\", 0, G_SPI3),\n\tPCLK(USART2, \"usart2\", \"pclk1\", 0, G_USART2),\n\tPCLK(USART3, \"usart3\", \"pclk1\", 0, G_USART3),\n\tPCLK(UART4, \"uart4\", \"pclk1\", 0, G_UART4),\n\tPCLK(UART5, \"uart5\", \"pclk1\", 0, G_UART5),\n\tPCLK(UART7, \"uart7\", \"pclk1\", 0, G_UART7),\n\tPCLK(UART8, \"uart8\", \"pclk1\", 0, G_UART8),\n\tPCLK(I2C1, \"i2c1\", \"pclk1\", 0, G_I2C1),\n\tPCLK(I2C2, \"i2c2\", \"pclk1\", 0, G_I2C2),\n\tPCLK(I2C3, \"i2c3\", \"pclk1\", 0, G_I2C3),\n\tPCLK(I2C5, \"i2c5\", \"pclk1\", 0, G_I2C5),\n\tPCLK(SPDIF, \"spdif\", \"pclk1\", 0, G_SPDIF),\n\tPCLK(CEC, \"cec\", \"pclk1\", 0, G_CEC),\n\tPCLK(DAC12, \"dac12\", \"pclk1\", 0, G_DAC12),\n\tPCLK(MDIO, \"mdio\", \"pclk1\", 0, G_MDIO),\n\tPCLK(TIM1, \"tim1\", \"pclk2\", CLK_IGNORE_UNUSED, G_TIM1),\n\tPCLK(TIM8, \"tim8\", \"pclk2\", CLK_IGNORE_UNUSED, G_TIM8),\n\tPCLK(TIM15, \"tim15\", \"pclk2\", CLK_IGNORE_UNUSED, G_TIM15),\n\tPCLK(TIM16, \"tim16\", \"pclk2\", CLK_IGNORE_UNUSED, G_TIM16),\n\tPCLK(TIM17, \"tim17\", \"pclk2\", CLK_IGNORE_UNUSED, G_TIM17),\n\tPCLK(SPI1, \"spi1\", \"pclk2\", 0, G_SPI1),\n\tPCLK(SPI4, \"spi4\", \"pclk2\", 0, G_SPI4),\n\tPCLK(SPI5, \"spi5\", \"pclk2\", 0, G_SPI5),\n\tPCLK(USART6, \"usart6\", \"pclk2\", 0, G_USART6),\n\tPCLK(SAI1, \"sai1\", \"pclk2\", 0, G_SAI1),\n\tPCLK(SAI2, \"sai2\", \"pclk2\", 0, G_SAI2),\n\tPCLK(SAI3, \"sai3\", \"pclk2\", 0, G_SAI3),\n\tPCLK(DFSDM, \"dfsdm\", \"pclk2\", 0, G_DFSDM),\n\tPCLK(FDCAN, \"fdcan\", \"pclk2\", 0, G_FDCAN),\n\tPCLK(LPTIM2, \"lptim2\", \"pclk3\", 0, G_LPTIM2),\n\tPCLK(LPTIM3, \"lptim3\", \"pclk3\", 0, G_LPTIM3),\n\tPCLK(LPTIM4, \"lptim4\", \"pclk3\", 0, G_LPTIM4),\n\tPCLK(LPTIM5, \"lptim5\", \"pclk3\", 0, G_LPTIM5),\n\tPCLK(SAI4, \"sai4\", \"pclk3\", 0, G_SAI4),\n\tPCLK(SYSCFG, \"syscfg\", \"pclk3\", 0, G_SYSCFG),\n\tPCLK(VREF, \"vref\", \"pclk3\", 13, G_VREF),\n\tPCLK(TMPSENS, \"tmpsens\", \"pclk3\", 0, G_TMPSENS),\n\tPCLK(PMBCTRL, \"pmbctrl\", \"pclk3\", 0, G_PMBCTRL),\n\tPCLK(HDP, \"hdp\", \"pclk3\", 0, G_HDP),\n\tPCLK(LTDC, \"ltdc\", \"pclk4\", 0, G_LTDC),\n\tPCLK(DSI, \"dsi\", \"pclk4\", 0, G_DSI),\n\tPCLK(IWDG2, \"iwdg2\", \"pclk4\", 0, G_IWDG2),\n\tPCLK(USBPHY, \"usbphy\", \"pclk4\", 0, G_USBPHY),\n\tPCLK(STGENRO, \"stgenro\", \"pclk4\", 0, G_STGENRO),\n\tPCLK(SPI6, \"spi6\", \"pclk5\", 0, G_SPI6),\n\tPCLK(I2C4, \"i2c4\", \"pclk5\", 0, G_I2C4),\n\tPCLK(I2C6, \"i2c6\", \"pclk5\", 0, G_I2C6),\n\tPCLK(USART1, \"usart1\", \"pclk5\", 0, G_USART1),\n\tPCLK(RTCAPB, \"rtcapb\", \"pclk5\", CLK_IGNORE_UNUSED |\n\t     CLK_IS_CRITICAL, G_RTCAPB),\n\tPCLK(TZC1, \"tzc1\", \"ck_axi\", CLK_IGNORE_UNUSED, G_TZC1),\n\tPCLK(TZC2, \"tzc2\", \"ck_axi\", CLK_IGNORE_UNUSED, G_TZC2),\n\tPCLK(TZPC, \"tzpc\", \"pclk5\", CLK_IGNORE_UNUSED, G_TZPC),\n\tPCLK(IWDG1, \"iwdg1\", \"pclk5\", 0, G_IWDG1),\n\tPCLK(BSEC, \"bsec\", \"pclk5\", CLK_IGNORE_UNUSED, G_BSEC),\n\tPCLK(STGEN, \"stgen\", \"pclk5\", CLK_IGNORE_UNUSED, G_STGEN),\n\tPCLK(DMA1, \"dma1\", \"ck_mcu\", 0, G_DMA1),\n\tPCLK(DMA2, \"dma2\", \"ck_mcu\",  0, G_DMA2),\n\tPCLK(DMAMUX, \"dmamux\", \"ck_mcu\", 0, G_DMAMUX),\n\tPCLK(ADC12, \"adc12\", \"ck_mcu\", 0, G_ADC12),\n\tPCLK(USBO, \"usbo\", \"ck_mcu\", 0, G_USBO),\n\tPCLK(SDMMC3, \"sdmmc3\", \"ck_mcu\", 0, G_SDMMC3),\n\tPCLK(DCMI, \"dcmi\", \"ck_mcu\", 0, G_DCMI),\n\tPCLK(CRYP2, \"cryp2\", \"ck_mcu\", 0, G_CRYP2),\n\tPCLK(HASH2, \"hash2\", \"ck_mcu\", 0, G_HASH2),\n\tPCLK(RNG2, \"rng2\", \"ck_mcu\", 0, G_RNG2),\n\tPCLK(CRC2, \"crc2\", \"ck_mcu\", 0, G_CRC2),\n\tPCLK(HSEM, \"hsem\", \"ck_mcu\", 0, G_HSEM),\n\tPCLK(IPCC, \"ipcc\", \"ck_mcu\", 0, G_IPCC),\n\tPCLK(GPIOA, \"gpioa\", \"ck_mcu\", 0, G_GPIOA),\n\tPCLK(GPIOB, \"gpiob\", \"ck_mcu\", 0, G_GPIOB),\n\tPCLK(GPIOC, \"gpioc\", \"ck_mcu\", 0, G_GPIOC),\n\tPCLK(GPIOD, \"gpiod\", \"ck_mcu\", 0, G_GPIOD),\n\tPCLK(GPIOE, \"gpioe\", \"ck_mcu\", 0, G_GPIOE),\n\tPCLK(GPIOF, \"gpiof\", \"ck_mcu\", 0, G_GPIOF),\n\tPCLK(GPIOG, \"gpiog\", \"ck_mcu\", 0, G_GPIOG),\n\tPCLK(GPIOH, \"gpioh\", \"ck_mcu\", 0, G_GPIOH),\n\tPCLK(GPIOI, \"gpioi\", \"ck_mcu\", 0, G_GPIOI),\n\tPCLK(GPIOJ, \"gpioj\", \"ck_mcu\", 0, G_GPIOJ),\n\tPCLK(GPIOK, \"gpiok\", \"ck_mcu\", 0, G_GPIOK),\n\tPCLK(GPIOZ, \"gpioz\", \"ck_axi\", CLK_IGNORE_UNUSED, G_GPIOZ),\n\tPCLK(CRYP1, \"cryp1\", \"ck_axi\", CLK_IGNORE_UNUSED, G_CRYP1),\n\tPCLK(HASH1, \"hash1\", \"ck_axi\", CLK_IGNORE_UNUSED, G_HASH1),\n\tPCLK(RNG1, \"rng1\", \"ck_axi\", 0, G_RNG1),\n\tPCLK(BKPSRAM, \"bkpsram\", \"ck_axi\", CLK_IGNORE_UNUSED, G_BKPSRAM),\n\tPCLK(MDMA, \"mdma\", \"ck_axi\", 0, G_MDMA),\n\tPCLK(GPU, \"gpu\", \"ck_axi\", 0, G_GPU),\n\tPCLK(ETHTX, \"ethtx\", \"ck_axi\", 0, G_ETHTX),\n\tPCLK_PDATA(ETHRX, \"ethrx\", ethrx_src, 0, G_ETHRX),\n\tPCLK(ETHMAC, \"ethmac\", \"ck_axi\", 0, G_ETHMAC),\n\tPCLK(FMC, \"fmc\", \"ck_axi\", CLK_IGNORE_UNUSED, G_FMC),\n\tPCLK(QSPI, \"qspi\", \"ck_axi\", CLK_IGNORE_UNUSED, G_QSPI),\n\tPCLK(SDMMC1, \"sdmmc1\", \"ck_axi\", 0, G_SDMMC1),\n\tPCLK(SDMMC2, \"sdmmc2\", \"ck_axi\", 0, G_SDMMC2),\n\tPCLK(CRC1, \"crc1\", \"ck_axi\", 0, G_CRC1),\n\tPCLK(USBH, \"usbh\", \"ck_axi\", 0, G_USBH),\n\tPCLK(ETHSTP, \"ethstp\", \"ck_axi\", 0, G_ETHSTP),\n\tPCLK(DDRPERFM, \"ddrperfm\", \"pclk4\", 0, G_DDRPERFM),\n\n\t \n\tKCLK(SDMMC1_K, \"sdmmc1_k\", sdmmc12_src, 0, G_SDMMC1, M_SDMMC12),\n\tKCLK(SDMMC2_K, \"sdmmc2_k\", sdmmc12_src, 0, G_SDMMC2, M_SDMMC12),\n\tKCLK(SDMMC3_K, \"sdmmc3_k\", sdmmc3_src, 0, G_SDMMC3, M_SDMMC3),\n\tKCLK(FMC_K, \"fmc_k\", fmc_src, 0, G_FMC, M_FMC),\n\tKCLK(QSPI_K, \"qspi_k\", qspi_src, 0, G_QSPI, M_QSPI),\n\tKCLK(RNG1_K, \"rng1_k\", rng_src, 0, G_RNG1, M_RNG1),\n\tKCLK(RNG2_K, \"rng2_k\", rng_src, 0, G_RNG2, M_RNG2),\n\tKCLK(USBPHY_K, \"usbphy_k\", usbphy_src, 0, G_USBPHY, M_USBPHY),\n\tKCLK(STGEN_K, \"stgen_k\", stgen_src, CLK_IS_CRITICAL, G_STGEN, M_STGEN),\n\tKCLK(SPDIF_K, \"spdif_k\", spdif_src, 0, G_SPDIF, M_SPDIF),\n\tKCLK(SPI1_K, \"spi1_k\", spi123_src, 0, G_SPI1, M_SPI1),\n\tKCLK(SPI2_K, \"spi2_k\", spi123_src, 0, G_SPI2, M_SPI23),\n\tKCLK(SPI3_K, \"spi3_k\", spi123_src, 0, G_SPI3, M_SPI23),\n\tKCLK(SPI4_K, \"spi4_k\", spi45_src, 0, G_SPI4, M_SPI45),\n\tKCLK(SPI5_K, \"spi5_k\", spi45_src, 0, G_SPI5, M_SPI45),\n\tKCLK(SPI6_K, \"spi6_k\", spi6_src, 0, G_SPI6, M_SPI6),\n\tKCLK(CEC_K, \"cec_k\", cec_src, 0, G_CEC, M_CEC),\n\tKCLK(I2C1_K, \"i2c1_k\", i2c12_src, 0, G_I2C1, M_I2C12),\n\tKCLK(I2C2_K, \"i2c2_k\", i2c12_src, 0, G_I2C2, M_I2C12),\n\tKCLK(I2C3_K, \"i2c3_k\", i2c35_src, 0, G_I2C3, M_I2C35),\n\tKCLK(I2C5_K, \"i2c5_k\", i2c35_src, 0, G_I2C5, M_I2C35),\n\tKCLK(I2C4_K, \"i2c4_k\", i2c46_src, 0, G_I2C4, M_I2C46),\n\tKCLK(I2C6_K, \"i2c6_k\", i2c46_src, 0, G_I2C6, M_I2C46),\n\tKCLK(LPTIM1_K, \"lptim1_k\", lptim1_src, 0, G_LPTIM1, M_LPTIM1),\n\tKCLK(LPTIM2_K, \"lptim2_k\", lptim23_src, 0, G_LPTIM2, M_LPTIM23),\n\tKCLK(LPTIM3_K, \"lptim3_k\", lptim23_src, 0, G_LPTIM3, M_LPTIM23),\n\tKCLK(LPTIM4_K, \"lptim4_k\", lptim45_src, 0, G_LPTIM4, M_LPTIM45),\n\tKCLK(LPTIM5_K, \"lptim5_k\", lptim45_src, 0, G_LPTIM5, M_LPTIM45),\n\tKCLK(USART1_K, \"usart1_k\", usart1_src, 0, G_USART1, M_USART1),\n\tKCLK(USART2_K, \"usart2_k\", usart234578_src, 0, G_USART2, M_UART24),\n\tKCLK(USART3_K, \"usart3_k\", usart234578_src, 0, G_USART3, M_UART35),\n\tKCLK(UART4_K, \"uart4_k\", usart234578_src, 0, G_UART4, M_UART24),\n\tKCLK(UART5_K, \"uart5_k\", usart234578_src, 0, G_UART5, M_UART35),\n\tKCLK(USART6_K, \"uart6_k\", usart6_src, 0, G_USART6, M_USART6),\n\tKCLK(UART7_K, \"uart7_k\", usart234578_src, 0, G_UART7, M_UART78),\n\tKCLK(UART8_K, \"uart8_k\", usart234578_src, 0, G_UART8, M_UART78),\n\tKCLK(FDCAN_K, \"fdcan_k\", fdcan_src, 0, G_FDCAN, M_FDCAN),\n\tKCLK(SAI1_K, \"sai1_k\", sai_src, 0, G_SAI1, M_SAI1),\n\tKCLK(SAI2_K, \"sai2_k\", sai2_src, 0, G_SAI2, M_SAI2),\n\tKCLK(SAI3_K, \"sai3_k\", sai_src, 0, G_SAI3, M_SAI3),\n\tKCLK(SAI4_K, \"sai4_k\", sai_src, 0, G_SAI4, M_SAI4),\n\tKCLK(ADC12_K, \"adc12_k\", adc12_src, 0, G_ADC12, M_ADC12),\n\tKCLK(DSI_K, \"dsi_k\", dsi_src, 0, G_DSI, M_DSI),\n\tKCLK(ADFSDM_K, \"adfsdm_k\", sai_src, 0, G_ADFSDM, M_SAI1),\n\tKCLK(USBO_K, \"usbo_k\", usbo_src, 0, G_USBO, M_USBO),\n\n\t \n\tMGATE_MP1(DFSDM_K, \"dfsdm_k\", \"ck_mcu\", 0, G_DFSDM),\n\tMGATE_MP1(DSI_PX, \"dsi_px\", \"pll4_q\", CLK_SET_RATE_PARENT, G_DSI),\n\tMGATE_MP1(LTDC_PX, \"ltdc_px\", \"pll4_q\", CLK_SET_RATE_PARENT, G_LTDC),\n\tMGATE_MP1(GPU_K, \"gpu_k\", \"pll2_q\", 0, G_GPU),\n\tMGATE_MP1(DAC12_K, \"dac12_k\", \"ck_lsi\", 0, G_DAC12),\n\n\tCOMPOSITE(NO_ID, \"ck_ker_eth\", eth_src, CLK_OPS_PARENT_ENABLE |\n\t\t  CLK_SET_RATE_NO_REPARENT,\n\t\t  _NO_GATE,\n\t\t  _MMUX(M_ETHCK),\n\t\t  _NO_DIV),\n\n\tMGATE_MP1(ETHCK_K, \"ethck_k\", \"ck_ker_eth\", 0, G_ETHCK),\n\n\tDIV(ETHPTP_K, \"ethptp_k\", \"ck_ker_eth\", CLK_OPS_PARENT_ENABLE |\n\t    CLK_SET_RATE_NO_REPARENT, RCC_ETHCKSELR, 4, 4, 0),\n\n\t \n\tCOMPOSITE(RTC, \"ck_rtc\", rtc_src, CLK_OPS_PARENT_ENABLE,\n\t\t  _GATE(RCC_BDCR, 20, 0),\n\t\t  _MUX(RCC_BDCR, 16, 2, 0),\n\t\t  _DIV_RTC(RCC_RTCDIVR, 0, 6, 0, NULL)),\n\n\t \n\tCOMPOSITE(CK_MCO1, \"ck_mco1\", mco1_src, CLK_OPS_PARENT_ENABLE |\n\t\t  CLK_SET_RATE_NO_REPARENT,\n\t\t  _GATE(RCC_MCO1CFGR, 12, 0),\n\t\t  _MUX(RCC_MCO1CFGR, 0, 3, 0),\n\t\t  _DIV(RCC_MCO1CFGR, 4, 4, 0, NULL)),\n\n\tCOMPOSITE(CK_MCO2, \"ck_mco2\", mco2_src, CLK_OPS_PARENT_ENABLE |\n\t\t  CLK_SET_RATE_NO_REPARENT,\n\t\t  _GATE(RCC_MCO2CFGR, 12, 0),\n\t\t  _MUX(RCC_MCO2CFGR, 0, 3, 0),\n\t\t  _DIV(RCC_MCO2CFGR, 4, 4, 0, NULL)),\n\n\t \n\tGATE(CK_DBG, \"ck_sys_dbg\", \"ck_axi\", CLK_IGNORE_UNUSED,\n\t     RCC_DBGCFGR, 8, 0),\n\n\tCOMPOSITE(CK_TRACE, \"ck_trace\", ck_trace_src, CLK_OPS_PARENT_ENABLE,\n\t\t  _GATE(RCC_DBGCFGR, 9, 0),\n\t\t  _NO_MUX,\n\t\t  _DIV(RCC_DBGCFGR, 0, 3, 0, ck_trace_div_table)),\n};\n\nstatic const u32 stm32mp1_clock_secured[] = {\n\tCK_HSE,\n\tCK_HSI,\n\tCK_CSI,\n\tCK_LSI,\n\tCK_LSE,\n\tPLL1,\n\tPLL2,\n\tPLL1_P,\n\tPLL2_P,\n\tPLL2_Q,\n\tPLL2_R,\n\tCK_MPU,\n\tCK_AXI,\n\tSPI6,\n\tI2C4,\n\tI2C6,\n\tUSART1,\n\tRTCAPB,\n\tTZC1,\n\tTZC2,\n\tTZPC,\n\tIWDG1,\n\tBSEC,\n\tSTGEN,\n\tGPIOZ,\n\tCRYP1,\n\tHASH1,\n\tRNG1,\n\tBKPSRAM,\n\tRNG1_K,\n\tSTGEN_K,\n\tSPI6_K,\n\tI2C4_K,\n\tI2C6_K,\n\tUSART1_K,\n\tRTC,\n};\n\nstatic bool stm32_check_security(const struct clock_config *cfg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(stm32mp1_clock_secured); i++)\n\t\tif (cfg->id == stm32mp1_clock_secured[i])\n\t\t\treturn true;\n\treturn false;\n}\n\nstruct stm32_rcc_match_data {\n\tconst struct clock_config *cfg;\n\tunsigned int num;\n\tunsigned int maxbinding;\n\tu32 clear_offset;\n\tbool (*check_security)(const struct clock_config *cfg);\n};\n\nstatic struct stm32_rcc_match_data stm32mp1_data = {\n\t.cfg\t\t= stm32mp1_clock_cfg,\n\t.num\t\t= ARRAY_SIZE(stm32mp1_clock_cfg),\n\t.maxbinding\t= STM32MP1_LAST_CLK,\n\t.clear_offset\t= RCC_CLR,\n};\n\nstatic struct stm32_rcc_match_data stm32mp1_data_secure = {\n\t.cfg\t\t= stm32mp1_clock_cfg,\n\t.num\t\t= ARRAY_SIZE(stm32mp1_clock_cfg),\n\t.maxbinding\t= STM32MP1_LAST_CLK,\n\t.clear_offset\t= RCC_CLR,\n\t.check_security = &stm32_check_security\n};\n\nstatic const struct of_device_id stm32mp1_match_data[] = {\n\t{\n\t\t.compatible = \"st,stm32mp1-rcc\",\n\t\t.data = &stm32mp1_data,\n\t},\n\t{\n\t\t.compatible = \"st,stm32mp1-rcc-secure\",\n\t\t.data = &stm32mp1_data_secure,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, stm32mp1_match_data);\n\nstatic int stm32_register_hw_clk(struct device *dev,\n\t\t\t\t struct clk_hw_onecell_data *clk_data,\n\t\t\t\t void __iomem *base, spinlock_t *lock,\n\t\t\t\t const struct clock_config *cfg)\n{\n\tstruct clk_hw **hws;\n\tstruct clk_hw *hw = ERR_PTR(-ENOENT);\n\n\thws = clk_data->hws;\n\n\tif (cfg->func)\n\t\thw = (*cfg->func)(dev, clk_data, base, lock, cfg);\n\n\tif (IS_ERR(hw)) {\n\t\tpr_err(\"Unable to register %s\\n\", cfg->name);\n\t\treturn  PTR_ERR(hw);\n\t}\n\n\tif (cfg->id != NO_ID)\n\t\thws[cfg->id] = hw;\n\n\treturn 0;\n}\n\n#define STM32_RESET_ID_MASK GENMASK(15, 0)\n\nstruct stm32_reset_data {\n\t \n\tspinlock_t\t\t\tlock;\n\tstruct reset_controller_dev\trcdev;\n\tvoid __iomem\t\t\t*membase;\n\tu32\t\t\t\tclear_offset;\n};\n\nstatic inline struct stm32_reset_data *\nto_stm32_reset_data(struct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct stm32_reset_data, rcdev);\n}\n\nstatic int stm32_reset_update(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id, bool assert)\n{\n\tstruct stm32_reset_data *data = to_stm32_reset_data(rcdev);\n\tint reg_width = sizeof(u32);\n\tint bank = id / (reg_width * BITS_PER_BYTE);\n\tint offset = id % (reg_width * BITS_PER_BYTE);\n\n\tif (data->clear_offset) {\n\t\tvoid __iomem *addr;\n\n\t\taddr = data->membase + (bank * reg_width);\n\t\tif (!assert)\n\t\t\taddr += data->clear_offset;\n\n\t\twritel(BIT(offset), addr);\n\n\t} else {\n\t\tunsigned long flags;\n\t\tu32 reg;\n\n\t\tspin_lock_irqsave(&data->lock, flags);\n\n\t\treg = readl(data->membase + (bank * reg_width));\n\n\t\tif (assert)\n\t\t\treg |= BIT(offset);\n\t\telse\n\t\t\treg &= ~BIT(offset);\n\n\t\twritel(reg, data->membase + (bank * reg_width));\n\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\treturn stm32_reset_update(rcdev, id, true);\n}\n\nstatic int stm32_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\treturn stm32_reset_update(rcdev, id, false);\n}\n\nstatic int stm32_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct stm32_reset_data *data = to_stm32_reset_data(rcdev);\n\tint reg_width = sizeof(u32);\n\tint bank = id / (reg_width * BITS_PER_BYTE);\n\tint offset = id % (reg_width * BITS_PER_BYTE);\n\tu32 reg;\n\n\treg = readl(data->membase + (bank * reg_width));\n\n\treturn !!(reg & BIT(offset));\n}\n\nstatic const struct reset_control_ops stm32_reset_ops = {\n\t.assert\t\t= stm32_reset_assert,\n\t.deassert\t= stm32_reset_deassert,\n\t.status\t\t= stm32_reset_status,\n};\n\nstatic int stm32_rcc_reset_init(struct device *dev, void __iomem *base,\n\t\t\t\tconst struct of_device_id *match)\n{\n\tconst struct stm32_rcc_match_data *data = match->data;\n\tstruct stm32_reset_data *reset_data = NULL;\n\n\treset_data = kzalloc(sizeof(*reset_data), GFP_KERNEL);\n\tif (!reset_data)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&reset_data->lock);\n\treset_data->membase = base;\n\treset_data->rcdev.owner = THIS_MODULE;\n\treset_data->rcdev.ops = &stm32_reset_ops;\n\treset_data->rcdev.of_node = dev_of_node(dev);\n\treset_data->rcdev.nr_resets = STM32_RESET_ID_MASK;\n\treset_data->clear_offset = data->clear_offset;\n\n\treturn reset_controller_register(&reset_data->rcdev);\n}\n\nstatic int stm32_rcc_clock_init(struct device *dev, void __iomem *base,\n\t\t\t\tconst struct of_device_id *match)\n{\n\tconst struct stm32_rcc_match_data *data = match->data;\n\tstruct clk_hw_onecell_data *clk_data;\n\tstruct clk_hw **hws;\n\tint err, n, max_binding;\n\n\tmax_binding =  data->maxbinding;\n\n\tclk_data = devm_kzalloc(dev, struct_size(clk_data, hws, max_binding),\n\t\t\t\tGFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tclk_data->num = max_binding;\n\n\thws = clk_data->hws;\n\n\tfor (n = 0; n < max_binding; n++)\n\t\thws[n] = ERR_PTR(-ENOENT);\n\n\tfor (n = 0; n < data->num; n++) {\n\t\tif (data->check_security && data->check_security(&data->cfg[n]))\n\t\t\tcontinue;\n\n\t\terr = stm32_register_hw_clk(dev, clk_data, base, &rlock,\n\t\t\t\t\t    &data->cfg[n]);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Can't register clk %s: %d\\n\",\n\t\t\t\tdata->cfg[n].name, err);\n\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn of_clk_add_hw_provider(dev_of_node(dev), of_clk_hw_onecell_get, clk_data);\n}\n\nstatic int stm32_rcc_init(struct device *dev, void __iomem *base,\n\t\t\t  const struct of_device_id *match_data)\n{\n\tconst struct of_device_id *match;\n\tint err;\n\n\tmatch = of_match_node(match_data, dev_of_node(dev));\n\tif (!match) {\n\t\tdev_err(dev, \"match data not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\terr = stm32_rcc_reset_init(dev, base, match);\n\tif (err) {\n\t\tpr_err(\"stm32mp1 reset failed to initialize\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = stm32_rcc_clock_init(dev, base, match);\n\tif (err) {\n\t\tpr_err(\"stm32mp1 clock failed to initialize\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32mp1_rcc_init(struct device *dev)\n{\n\tvoid __iomem *base;\n\tint ret;\n\n\tbase = of_iomap(dev_of_node(dev), 0);\n\tif (!base) {\n\t\tpr_err(\"%pOFn: unable to map resource\", dev_of_node(dev));\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = stm32_rcc_init(dev, base, stm32mp1_match_data);\n\nout:\n\tif (ret) {\n\t\tif (base)\n\t\t\tiounmap(base);\n\n\t\tof_node_put(dev_of_node(dev));\n\t}\n\n\treturn ret;\n}\n\nstatic int get_clock_deps(struct device *dev)\n{\n\tstatic const char * const clock_deps_name[] = {\n\t\t\"hsi\", \"hse\", \"csi\", \"lsi\", \"lse\",\n\t};\n\tsize_t deps_size = sizeof(struct clk *) * ARRAY_SIZE(clock_deps_name);\n\tstruct clk **clk_deps;\n\tint i;\n\n\tclk_deps = devm_kzalloc(dev, deps_size, GFP_KERNEL);\n\tif (!clk_deps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(clock_deps_name); i++) {\n\t\tstruct clk *clk = of_clk_get_by_name(dev_of_node(dev),\n\t\t\t\t\t\t     clock_deps_name[i]);\n\n\t\tif (IS_ERR(clk)) {\n\t\t\tif (PTR_ERR(clk) != -EINVAL && PTR_ERR(clk) != -ENOENT)\n\t\t\t\treturn PTR_ERR(clk);\n\t\t} else {\n\t\t\t \n\t\t\tclk_deps[i] = devm_clk_get(dev, __clk_get_name(clk));\n\t\t\tclk_put(clk);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32mp1_rcc_clocks_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret = get_clock_deps(dev);\n\n\tif (!ret)\n\t\tret = stm32mp1_rcc_init(dev);\n\n\treturn ret;\n}\n\nstatic void stm32mp1_rcc_clocks_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *child, *np = dev_of_node(dev);\n\n\tfor_each_available_child_of_node(np, child)\n\t\tof_clk_del_provider(child);\n}\n\nstatic struct platform_driver stm32mp1_rcc_clocks_driver = {\n\t.driver\t= {\n\t\t.name = \"stm32mp1_rcc\",\n\t\t.of_match_table = stm32mp1_match_data,\n\t},\n\t.probe = stm32mp1_rcc_clocks_probe,\n\t.remove_new = stm32mp1_rcc_clocks_remove,\n};\n\nstatic int __init stm32mp1_clocks_init(void)\n{\n\treturn platform_driver_register(&stm32mp1_rcc_clocks_driver);\n}\ncore_initcall(stm32mp1_clocks_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}