{
  "module_name": "pll_clock.c",
  "hash_id": "fc8bbb905d6d7bdf4c7b02e275e9c25d3ef97c150b5504d505a8c8cb0a139341",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/axs10x/pll_clock.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n\n \n#define PLL_REG_IDIV\t0x0\n#define PLL_REG_FBDIV\t0x4\n#define PLL_REG_ODIV\t0x8\n\n \n\n#define PLL_REG_GET_LOW(reg)\t\t\t\\\n\t(((reg) & (0x3F << 0)) >> 0)\n#define PLL_REG_GET_HIGH(reg)\t\t\t\\\n\t(((reg) & (0x3F << 6)) >> 6)\n#define PLL_REG_GET_EDGE(reg)\t\t\t\\\n\t(((reg) & (BIT(12))) ? 1 : 0)\n#define PLL_REG_GET_BYPASS(reg)\t\t\t\\\n\t(((reg) & (BIT(13))) ? 1 : 0)\n#define PLL_REG_GET_NOUPD(reg)\t\t\t\\\n\t(((reg) & (BIT(14))) ? 1 : 0)\n#define PLL_REG_GET_PAD(reg)\t\t\t\\\n\t(((reg) & (0x1FFFF << 15)) >> 15)\n\n#define PLL_REG_SET_LOW(reg, value)\t\t\\\n\t{ reg |= (((value) & 0x3F) << 0); }\n#define PLL_REG_SET_HIGH(reg, value)\t\t\\\n\t{ reg |= (((value) & 0x3F) << 6); }\n#define PLL_REG_SET_EDGE(reg, value)\t\t\\\n\t{ reg |= (((value) & 0x01) << 12); }\n#define PLL_REG_SET_BYPASS(reg, value)\t\t\\\n\t{ reg |= (((value) & 0x01) << 13); }\n#define PLL_REG_SET_NOUPD(reg, value)\t\t\\\n\t{ reg |= (((value) & 0x01) << 14); }\n#define PLL_REG_SET_PAD(reg, value)\t\t\\\n\t{ reg |= (((value) & 0x1FFFF) << 15); }\n\n#define PLL_LOCK\tBIT(0)\n#define PLL_ERROR\tBIT(1)\n#define PLL_MAX_LOCK_TIME 100  \n\nstruct axs10x_pll_cfg {\n\tu32 rate;\n\tu32 idiv;\n\tu32 fbdiv;\n\tu32 odiv;\n};\n\nstatic const struct axs10x_pll_cfg arc_pll_cfg[] = {\n\t{ 33333333,  1, 1,  1 },\n\t{ 50000000,  1, 30, 20 },\n\t{ 75000000,  2, 45, 10 },\n\t{ 90000000,  2, 54, 10 },\n\t{ 100000000, 1, 30, 10 },\n\t{ 125000000, 2, 45, 6 },\n\t{}\n};\n\nstatic const struct axs10x_pll_cfg pgu_pll_cfg[] = {\n\t{ 25200000, 1, 84, 90 },\n\t{ 50000000, 1, 100, 54 },\n\t{ 74250000, 1, 44, 16 },\n\t{}\n};\n\nstruct axs10x_pll_clk {\n\tstruct clk_hw hw;\n\tvoid __iomem *base;\n\tvoid __iomem *lock;\n\tconst struct axs10x_pll_cfg *pll_cfg;\n\tstruct device *dev;\n};\n\nstatic inline void axs10x_pll_write(struct axs10x_pll_clk *clk, u32 reg,\n\t\t\t\t    u32 val)\n{\n\tiowrite32(val, clk->base + reg);\n}\n\nstatic inline u32 axs10x_pll_read(struct axs10x_pll_clk *clk, u32 reg)\n{\n\treturn ioread32(clk->base + reg);\n}\n\nstatic inline struct axs10x_pll_clk *to_axs10x_pll_clk(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct axs10x_pll_clk, hw);\n}\n\nstatic inline u32 axs10x_div_get_value(u32 reg)\n{\n\tif (PLL_REG_GET_BYPASS(reg))\n\t\treturn 1;\n\n\treturn PLL_REG_GET_HIGH(reg) + PLL_REG_GET_LOW(reg);\n}\n\nstatic inline u32 axs10x_encode_div(unsigned int id, int upd)\n{\n\tu32 div = 0;\n\n\tPLL_REG_SET_LOW(div, (id % 2 == 0) ? id >> 1 : (id >> 1) + 1);\n\tPLL_REG_SET_HIGH(div, id >> 1);\n\tPLL_REG_SET_EDGE(div, id % 2);\n\tPLL_REG_SET_BYPASS(div, id == 1 ? 1 : 0);\n\tPLL_REG_SET_NOUPD(div, upd == 0 ? 1 : 0);\n\n\treturn div;\n}\n\nstatic unsigned long axs10x_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tu64 rate;\n\tu32 idiv, fbdiv, odiv;\n\tstruct axs10x_pll_clk *clk = to_axs10x_pll_clk(hw);\n\n\tidiv = axs10x_div_get_value(axs10x_pll_read(clk, PLL_REG_IDIV));\n\tfbdiv = axs10x_div_get_value(axs10x_pll_read(clk, PLL_REG_FBDIV));\n\todiv = axs10x_div_get_value(axs10x_pll_read(clk, PLL_REG_ODIV));\n\n\trate = (u64)parent_rate * fbdiv;\n\tdo_div(rate, idiv * odiv);\n\n\treturn rate;\n}\n\nstatic long axs10x_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long *prate)\n{\n\tint i;\n\tlong best_rate;\n\tstruct axs10x_pll_clk *clk = to_axs10x_pll_clk(hw);\n\tconst struct axs10x_pll_cfg *pll_cfg = clk->pll_cfg;\n\n\tif (pll_cfg[0].rate == 0)\n\t\treturn -EINVAL;\n\n\tbest_rate = pll_cfg[0].rate;\n\n\tfor (i = 1; pll_cfg[i].rate != 0; i++) {\n\t\tif (abs(rate - pll_cfg[i].rate) < abs(rate - best_rate))\n\t\t\tbest_rate = pll_cfg[i].rate;\n\t}\n\n\treturn best_rate;\n}\n\nstatic int axs10x_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tint i;\n\tstruct axs10x_pll_clk *clk = to_axs10x_pll_clk(hw);\n\tconst struct axs10x_pll_cfg *pll_cfg = clk->pll_cfg;\n\n\tfor (i = 0; pll_cfg[i].rate != 0; i++) {\n\t\tif (pll_cfg[i].rate == rate) {\n\t\t\taxs10x_pll_write(clk, PLL_REG_IDIV,\n\t\t\t\t\t axs10x_encode_div(pll_cfg[i].idiv, 0));\n\t\t\taxs10x_pll_write(clk, PLL_REG_FBDIV,\n\t\t\t\t\t axs10x_encode_div(pll_cfg[i].fbdiv, 0));\n\t\t\taxs10x_pll_write(clk, PLL_REG_ODIV,\n\t\t\t\t\t axs10x_encode_div(pll_cfg[i].odiv, 1));\n\n\t\t\t \n\t\t\tudelay(PLL_MAX_LOCK_TIME);\n\t\t\tif (!(ioread32(clk->lock) & PLL_LOCK))\n\t\t\t\treturn -ETIMEDOUT;\n\n\t\t\tif (ioread32(clk->lock) & PLL_ERROR)\n\t\t\t\treturn -EINVAL;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(clk->dev, \"invalid rate=%ld, parent_rate=%ld\\n\", rate,\n\t\t\tparent_rate);\n\treturn -EINVAL;\n}\n\nstatic const struct clk_ops axs10x_pll_ops = {\n\t.recalc_rate = axs10x_pll_recalc_rate,\n\t.round_rate = axs10x_pll_round_rate,\n\t.set_rate = axs10x_pll_set_rate,\n};\n\nstatic int axs10x_pll_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst char *parent_name;\n\tstruct axs10x_pll_clk *pll_clk;\n\tstruct clk_init_data init = { };\n\tint ret;\n\n\tpll_clk = devm_kzalloc(dev, sizeof(*pll_clk), GFP_KERNEL);\n\tif (!pll_clk)\n\t\treturn -ENOMEM;\n\n\tpll_clk->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pll_clk->base))\n\t\treturn PTR_ERR(pll_clk->base);\n\n\tpll_clk->lock = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(pll_clk->lock))\n\t\treturn PTR_ERR(pll_clk->lock);\n\n\tinit.name = dev->of_node->name;\n\tinit.ops = &axs10x_pll_ops;\n\tparent_name = of_clk_get_parent_name(dev->of_node, 0);\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tpll_clk->hw.init = &init;\n\tpll_clk->dev = dev;\n\tpll_clk->pll_cfg = of_device_get_match_data(dev);\n\n\tif (!pll_clk->pll_cfg) {\n\t\tdev_err(dev, \"No OF match data provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = devm_clk_hw_register(dev, &pll_clk->hw);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register %s clock\\n\", init.name);\n\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,\n\t\t\t\t\t   &pll_clk->hw);\n}\n\nstatic void __init of_axs10x_pll_clk_setup(struct device_node *node)\n{\n\tconst char *parent_name;\n\tstruct axs10x_pll_clk *pll_clk;\n\tstruct clk_init_data init = { };\n\tint ret;\n\n\tpll_clk = kzalloc(sizeof(*pll_clk), GFP_KERNEL);\n\tif (!pll_clk)\n\t\treturn;\n\n\tpll_clk->base = of_iomap(node, 0);\n\tif (!pll_clk->base) {\n\t\tpr_err(\"failed to map pll div registers\\n\");\n\t\tgoto err_free_pll_clk;\n\t}\n\n\tpll_clk->lock = of_iomap(node, 1);\n\tif (!pll_clk->lock) {\n\t\tpr_err(\"failed to map pll lock register\\n\");\n\t\tgoto err_unmap_base;\n\t}\n\n\tinit.name = node->name;\n\tinit.ops = &axs10x_pll_ops;\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = parent_name ? 1 : 0;\n\tpll_clk->hw.init = &init;\n\tpll_clk->pll_cfg = arc_pll_cfg;\n\n\tret = clk_hw_register(NULL, &pll_clk->hw);\n\tif (ret) {\n\t\tpr_err(\"failed to register %pOFn clock\\n\", node);\n\t\tgoto err_unmap_lock;\n\t}\n\n\tret = of_clk_add_hw_provider(node, of_clk_hw_simple_get, &pll_clk->hw);\n\tif (ret) {\n\t\tpr_err(\"failed to add hw provider for %pOFn clock\\n\", node);\n\t\tgoto err_unregister_clk;\n\t}\n\n\treturn;\n\nerr_unregister_clk:\n\tclk_hw_unregister(&pll_clk->hw);\nerr_unmap_lock:\n\tiounmap(pll_clk->lock);\nerr_unmap_base:\n\tiounmap(pll_clk->base);\nerr_free_pll_clk:\n\tkfree(pll_clk);\n}\nCLK_OF_DECLARE(axs10x_pll_clock, \"snps,axs10x-arc-pll-clock\",\n\t       of_axs10x_pll_clk_setup);\n\nstatic const struct of_device_id axs10x_pll_clk_id[] = {\n\t{ .compatible = \"snps,axs10x-pgu-pll-clock\", .data = &pgu_pll_cfg},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, axs10x_pll_clk_id);\n\nstatic struct platform_driver axs10x_pll_clk_driver = {\n\t.driver = {\n\t\t.name = \"axs10x-pll-clock\",\n\t\t.of_match_table = axs10x_pll_clk_id,\n\t},\n\t.probe = axs10x_pll_clk_probe,\n};\nbuiltin_platform_driver(axs10x_pll_clk_driver);\n\nMODULE_AUTHOR(\"Vlad Zakharov <vzakhar@synopsys.com>\");\nMODULE_DESCRIPTION(\"Synopsys AXS10X SDP Generic PLL Clock Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}