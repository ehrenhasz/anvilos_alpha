{
  "module_name": "i2s_pll_clock.c",
  "hash_id": "3f67df32fef8a7eee0b374fee6d15e36aff6f7eae363c0b39e9bdefccd46fa79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/axs10x/i2s_pll_clock.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n \n#define PLL_IDIV_REG\t0x0\n#define PLL_FBDIV_REG\t0x4\n#define PLL_ODIV0_REG\t0x8\n#define PLL_ODIV1_REG\t0xC\n\nstruct i2s_pll_cfg {\n\tunsigned int rate;\n\tunsigned int idiv;\n\tunsigned int fbdiv;\n\tunsigned int odiv0;\n\tunsigned int odiv1;\n};\n\nstatic const struct i2s_pll_cfg i2s_pll_cfg_27m[] = {\n\t \n\t{ 1024000, 0x104, 0x451, 0x10E38, 0x2000 },\n\t{ 1411200, 0x104, 0x596, 0x10D35, 0x2000 },\n\t{ 1536000, 0x208, 0xA28, 0x10B2C, 0x2000 },\n\t{ 2048000, 0x82, 0x451, 0x10E38, 0x2000 },\n\t{ 2822400, 0x82, 0x596, 0x10D35, 0x2000 },\n\t{ 3072000, 0x104, 0xA28, 0x10B2C, 0x2000 },\n\t{ 2116800, 0x82, 0x3CF, 0x10C30, 0x2000 },\n\t{ 2304000, 0x104, 0x79E, 0x10B2C, 0x2000 },\n\t{ 0, 0, 0, 0, 0 },\n};\n\nstatic const struct i2s_pll_cfg i2s_pll_cfg_28m[] = {\n\t \n\t{ 1024000, 0x82, 0x105, 0x107DF, 0x2000 },\n\t{ 1411200, 0x28A, 0x1, 0x10001, 0x2000 },\n\t{ 1536000, 0xA28, 0x187, 0x10042, 0x2000 },\n\t{ 2048000, 0x41, 0x105, 0x107DF, 0x2000 },\n\t{ 2822400, 0x145, 0x1, 0x10001, 0x2000 },\n\t{ 3072000, 0x514, 0x187, 0x10042, 0x2000 },\n\t{ 2116800, 0x514, 0x42, 0x10001, 0x2000 },\n\t{ 2304000, 0x619, 0x82, 0x10001, 0x2000 },\n\t{ 0, 0, 0, 0, 0 },\n};\n\nstruct i2s_pll_clk {\n\tvoid __iomem *base;\n\tstruct clk_hw hw;\n\tstruct device *dev;\n};\n\nstatic inline void i2s_pll_write(struct i2s_pll_clk *clk, unsigned int reg,\n\t\tunsigned int val)\n{\n\twritel_relaxed(val, clk->base + reg);\n}\n\nstatic inline unsigned int i2s_pll_read(struct i2s_pll_clk *clk,\n\t\tunsigned int reg)\n{\n\treturn readl_relaxed(clk->base + reg);\n}\n\nstatic inline struct i2s_pll_clk *to_i2s_pll_clk(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct i2s_pll_clk, hw);\n}\n\nstatic inline unsigned int i2s_pll_get_value(unsigned int val)\n{\n\treturn (val & 0x3F) + ((val >> 6) & 0x3F);\n}\n\nstatic const struct i2s_pll_cfg *i2s_pll_get_cfg(unsigned long prate)\n{\n\tswitch (prate) {\n\tcase 27000000:\n\t\treturn i2s_pll_cfg_27m;\n\tcase 28224000:\n\t\treturn i2s_pll_cfg_28m;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic unsigned long i2s_pll_recalc_rate(struct clk_hw *hw,\n\t\t\tunsigned long parent_rate)\n{\n\tstruct i2s_pll_clk *clk = to_i2s_pll_clk(hw);\n\tunsigned int idiv, fbdiv, odiv;\n\n\tidiv = i2s_pll_get_value(i2s_pll_read(clk, PLL_IDIV_REG));\n\tfbdiv = i2s_pll_get_value(i2s_pll_read(clk, PLL_FBDIV_REG));\n\todiv = i2s_pll_get_value(i2s_pll_read(clk, PLL_ODIV0_REG));\n\n\treturn ((parent_rate / idiv) * fbdiv) / odiv;\n}\n\nstatic long i2s_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\tunsigned long *prate)\n{\n\tstruct i2s_pll_clk *clk = to_i2s_pll_clk(hw);\n\tconst struct i2s_pll_cfg *pll_cfg = i2s_pll_get_cfg(*prate);\n\tint i;\n\n\tif (!pll_cfg) {\n\t\tdev_err(clk->dev, \"invalid parent rate=%ld\\n\", *prate);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; pll_cfg[i].rate != 0; i++)\n\t\tif (pll_cfg[i].rate == rate)\n\t\t\treturn rate;\n\n\treturn -EINVAL;\n}\n\nstatic int i2s_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\tunsigned long parent_rate)\n{\n\tstruct i2s_pll_clk *clk = to_i2s_pll_clk(hw);\n\tconst struct i2s_pll_cfg *pll_cfg = i2s_pll_get_cfg(parent_rate);\n\tint i;\n\n\tif (!pll_cfg) {\n\t\tdev_err(clk->dev, \"invalid parent rate=%ld\\n\", parent_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; pll_cfg[i].rate != 0; i++) {\n\t\tif (pll_cfg[i].rate == rate) {\n\t\t\ti2s_pll_write(clk, PLL_IDIV_REG, pll_cfg[i].idiv);\n\t\t\ti2s_pll_write(clk, PLL_FBDIV_REG, pll_cfg[i].fbdiv);\n\t\t\ti2s_pll_write(clk, PLL_ODIV0_REG, pll_cfg[i].odiv0);\n\t\t\ti2s_pll_write(clk, PLL_ODIV1_REG, pll_cfg[i].odiv1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(clk->dev, \"invalid rate=%ld, parent_rate=%ld\\n\", rate,\n\t\t\tparent_rate);\n\treturn -EINVAL;\n}\n\nstatic const struct clk_ops i2s_pll_ops = {\n\t.recalc_rate = i2s_pll_recalc_rate,\n\t.round_rate = i2s_pll_round_rate,\n\t.set_rate = i2s_pll_set_rate,\n};\n\nstatic int i2s_pll_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tconst char *clk_name;\n\tconst char *parent_name;\n\tstruct clk *clk;\n\tstruct i2s_pll_clk *pll_clk;\n\tstruct clk_init_data init;\n\n\tpll_clk = devm_kzalloc(dev, sizeof(*pll_clk), GFP_KERNEL);\n\tif (!pll_clk)\n\t\treturn -ENOMEM;\n\n\tpll_clk->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pll_clk->base))\n\t\treturn PTR_ERR(pll_clk->base);\n\n\tmemset(&init, 0, sizeof(init));\n\tclk_name = node->name;\n\tinit.name = clk_name;\n\tinit.ops = &i2s_pll_ops;\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tpll_clk->hw.init = &init;\n\tpll_clk->dev = dev;\n\n\tclk = devm_clk_register(dev, &pll_clk->hw);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"failed to register %s clock (%ld)\\n\",\n\t\t\t\tclk_name, PTR_ERR(clk));\n\t\treturn PTR_ERR(clk);\n\t}\n\n\treturn of_clk_add_provider(node, of_clk_src_simple_get, clk);\n}\n\nstatic void i2s_pll_clk_remove(struct platform_device *pdev)\n{\n\tof_clk_del_provider(pdev->dev.of_node);\n}\n\nstatic const struct of_device_id i2s_pll_clk_id[] = {\n\t{ .compatible = \"snps,axs10x-i2s-pll-clock\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, i2s_pll_clk_id);\n\nstatic struct platform_driver i2s_pll_clk_driver = {\n\t.driver = {\n\t\t.name = \"axs10x-i2s-pll-clock\",\n\t\t.of_match_table = i2s_pll_clk_id,\n\t},\n\t.probe = i2s_pll_clk_probe,\n\t.remove_new = i2s_pll_clk_remove,\n};\nmodule_platform_driver(i2s_pll_clk_driver);\n\nMODULE_AUTHOR(\"Jose Abreu <joabreu@synopsys.com>\");\nMODULE_DESCRIPTION(\"Synopsys AXS10X SDP I2S PLL Clock Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}