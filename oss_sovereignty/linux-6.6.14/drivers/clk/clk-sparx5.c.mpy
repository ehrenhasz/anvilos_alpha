{
  "module_name": "clk-sparx5.c",
  "hash_id": "51c7fd5599e422d94dabe82ce32ef19816aa8dbf392e35cce753e1bfa11694d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-sparx5.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/clk-provider.h>\n#include <linux/bitfield.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <dt-bindings/clock/microchip,sparx5.h>\n\n#define PLL_DIV\t\tGENMASK(7, 0)\n#define PLL_PRE_DIV\tGENMASK(10, 8)\n#define PLL_ROT_DIR\tBIT(11)\n#define PLL_ROT_SEL\tGENMASK(13, 12)\n#define PLL_ROT_ENA\tBIT(14)\n#define PLL_CLK_ENA\tBIT(15)\n\n#define MAX_SEL 4\n#define MAX_PRE BIT(3)\n\nstatic const u8 sel_rates[MAX_SEL] = { 0, 2*8, 2*4, 2*2 };\n\nstatic const char *clk_names[N_CLOCKS] = {\n\t\"core\", \"ddr\", \"cpu2\", \"arm2\",\n\t\"aux1\", \"aux2\", \"aux3\", \"aux4\",\n\t\"synce\",\n};\n\nstruct s5_hw_clk {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n};\n\nstruct s5_clk_data {\n\tvoid __iomem *base;\n\tstruct s5_hw_clk s5_hw[N_CLOCKS];\n};\n\nstruct s5_pll_conf {\n\tunsigned long freq;\n\tu8 div;\n\tbool rot_ena;\n\tu8 rot_sel;\n\tu8 rot_dir;\n\tu8 pre_div;\n};\n\n#define to_s5_pll(hw) container_of(hw, struct s5_hw_clk, hw)\n\nstatic unsigned long s5_calc_freq(unsigned long parent_rate,\n\t\t\t\t  const struct s5_pll_conf *conf)\n{\n\tunsigned long rate = parent_rate / conf->div;\n\n\tif (conf->rot_ena) {\n\t\tint sign = conf->rot_dir ? -1 : 1;\n\t\tint divt = sel_rates[conf->rot_sel] * (1 + conf->pre_div);\n\t\tint divb = divt + sign;\n\n\t\trate = mult_frac(rate, divt, divb);\n\t\trate = roundup(rate, 1000);\n\t}\n\n\treturn rate;\n}\n\nstatic void s5_search_fractional(unsigned long rate,\n\t\t\t\t unsigned long parent_rate,\n\t\t\t\t int div,\n\t\t\t\t struct s5_pll_conf *conf)\n{\n\tstruct s5_pll_conf best;\n\tulong cur_offset, best_offset = rate;\n\tint d, i, j;\n\n\tmemset(conf, 0, sizeof(*conf));\n\tconf->div = div;\n\tconf->rot_ena = 1;\t \n\n\tfor (d = 0; best_offset > 0 && d <= 1 ; d++) {\n\t\tconf->rot_dir = !!d;\n\t\tfor (i = 0; best_offset > 0 && i < MAX_PRE; i++) {\n\t\t\tconf->pre_div = i;\n\t\t\tfor (j = 1; best_offset > 0 && j < MAX_SEL; j++) {\n\t\t\t\tconf->rot_sel = j;\n\t\t\t\tconf->freq = s5_calc_freq(parent_rate, conf);\n\t\t\t\tcur_offset = abs(rate - conf->freq);\n\t\t\t\tif (cur_offset < best_offset) {\n\t\t\t\t\tbest_offset = cur_offset;\n\t\t\t\t\tbest = *conf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\t*conf = best;\n}\n\nstatic unsigned long s5_calc_params(unsigned long rate,\n\t\t\t\t    unsigned long parent_rate,\n\t\t\t\t    struct s5_pll_conf *conf)\n{\n\tif (parent_rate % rate) {\n\t\tstruct s5_pll_conf alt1, alt2;\n\t\tint div;\n\n\t\tdiv = DIV_ROUND_CLOSEST_ULL(parent_rate, rate);\n\t\ts5_search_fractional(rate, parent_rate, div, &alt1);\n\n\t\t \n\t\tif (alt1.freq == rate) {\n\t\t\t*conf = alt1;\n\t\t} else {\n\t\t\t \n\t\t\tdiv = parent_rate / rate;\n\t\t\tif (div != alt1.div) {\n\t\t\t\ts5_search_fractional(rate, parent_rate, div,\n\t\t\t\t\t\t     &alt2);\n\t\t\t\t \n\t\t\t\tif (abs(rate - alt1.freq) <\n\t\t\t\t    abs(rate - alt2.freq))\n\t\t\t\t\t*conf = alt1;\n\t\t\t\telse\n\t\t\t\t\t*conf = alt2;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tmemset(conf, 0, sizeof(*conf));\n\t\tconf->div = parent_rate / rate;\n\t}\n\n\treturn conf->freq;\n}\n\nstatic int s5_pll_enable(struct clk_hw *hw)\n{\n\tstruct s5_hw_clk *pll = to_s5_pll(hw);\n\tu32 val = readl(pll->reg);\n\n\tval |= PLL_CLK_ENA;\n\twritel(val, pll->reg);\n\n\treturn 0;\n}\n\nstatic void s5_pll_disable(struct clk_hw *hw)\n{\n\tstruct s5_hw_clk *pll = to_s5_pll(hw);\n\tu32 val = readl(pll->reg);\n\n\tval &= ~PLL_CLK_ENA;\n\twritel(val, pll->reg);\n}\n\nstatic int s5_pll_set_rate(struct clk_hw *hw,\n\t\t\t   unsigned long rate,\n\t\t\t   unsigned long parent_rate)\n{\n\tstruct s5_hw_clk *pll = to_s5_pll(hw);\n\tstruct s5_pll_conf conf;\n\tunsigned long eff_rate;\n\tu32 val;\n\n\teff_rate = s5_calc_params(rate, parent_rate, &conf);\n\tif (eff_rate != rate)\n\t\treturn -EOPNOTSUPP;\n\n\tval = readl(pll->reg) & PLL_CLK_ENA;\n\tval |= FIELD_PREP(PLL_DIV, conf.div);\n\tif (conf.rot_ena) {\n\t\tval |= PLL_ROT_ENA;\n\t\tval |= FIELD_PREP(PLL_ROT_SEL, conf.rot_sel);\n\t\tval |= FIELD_PREP(PLL_PRE_DIV, conf.pre_div);\n\t\tif (conf.rot_dir)\n\t\t\tval |= PLL_ROT_DIR;\n\t}\n\twritel(val, pll->reg);\n\n\treturn 0;\n}\n\nstatic unsigned long s5_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct s5_hw_clk *pll = to_s5_pll(hw);\n\tstruct s5_pll_conf conf;\n\tu32 val;\n\n\tval = readl(pll->reg);\n\n\tif (val & PLL_CLK_ENA) {\n\t\tconf.div     = FIELD_GET(PLL_DIV, val);\n\t\tconf.pre_div = FIELD_GET(PLL_PRE_DIV, val);\n\t\tconf.rot_ena = FIELD_GET(PLL_ROT_ENA, val);\n\t\tconf.rot_dir = FIELD_GET(PLL_ROT_DIR, val);\n\t\tconf.rot_sel = FIELD_GET(PLL_ROT_SEL, val);\n\n\t\tconf.freq = s5_calc_freq(parent_rate, &conf);\n\t} else {\n\t\tconf.freq = 0;\n\t}\n\n\treturn conf.freq;\n}\n\nstatic long s5_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long *parent_rate)\n{\n\tstruct s5_pll_conf conf;\n\n\treturn s5_calc_params(rate, *parent_rate, &conf);\n}\n\nstatic const struct clk_ops s5_pll_ops = {\n\t.enable\t\t= s5_pll_enable,\n\t.disable\t= s5_pll_disable,\n\t.set_rate\t= s5_pll_set_rate,\n\t.round_rate\t= s5_pll_round_rate,\n\t.recalc_rate\t= s5_pll_recalc_rate,\n};\n\nstatic struct clk_hw *s5_clk_hw_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct s5_clk_data *s5_clk = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= N_CLOCKS) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &s5_clk->s5_hw[idx].hw;\n}\n\nstatic int s5_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint i, ret;\n\tstruct s5_clk_data *s5_clk;\n\tstruct clk_parent_data pdata = { .index = 0 };\n\tstruct clk_init_data init = {\n\t\t.ops = &s5_pll_ops,\n\t\t.num_parents = 1,\n\t\t.parent_data = &pdata,\n\t};\n\n\ts5_clk = devm_kzalloc(dev, sizeof(*s5_clk), GFP_KERNEL);\n\tif (!s5_clk)\n\t\treturn -ENOMEM;\n\n\ts5_clk->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(s5_clk->base))\n\t\treturn PTR_ERR(s5_clk->base);\n\n\tfor (i = 0; i < N_CLOCKS; i++) {\n\t\tstruct s5_hw_clk *s5_hw = &s5_clk->s5_hw[i];\n\n\t\tinit.name = clk_names[i];\n\t\ts5_hw->reg = s5_clk->base + (i * 4);\n\t\ts5_hw->hw.init = &init;\n\t\tret = devm_clk_hw_register(dev, &s5_hw->hw);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to register %s clock\\n\",\n\t\t\t\tinit.name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, s5_clk_hw_get, s5_clk);\n}\n\nstatic const struct of_device_id s5_clk_dt_ids[] = {\n\t{ .compatible = \"microchip,sparx5-dpll\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, s5_clk_dt_ids);\n\nstatic struct platform_driver s5_clk_driver = {\n\t.probe  = s5_clk_probe,\n\t.driver = {\n\t\t.name = \"sparx5-clk\",\n\t\t.of_match_table = s5_clk_dt_ids,\n\t},\n};\nbuiltin_platform_driver(s5_clk_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}