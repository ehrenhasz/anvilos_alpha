{
  "module_name": "clk-xlnx-clock-wizard.c",
  "hash_id": "0da34e9883097c15d027b849557c33fcc8fa1f69c732cb718670d8bf14c605f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/xilinx/clk-xlnx-clock-wizard.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/iopoll.h>\n\n#define WZRD_NUM_OUTPUTS\t7\n#define WZRD_ACLK_MAX_FREQ\t250000000UL\n\n#define WZRD_CLK_CFG_REG(n)\t(0x200 + 4 * (n))\n\n#define WZRD_CLKOUT0_FRAC_EN\tBIT(18)\n#define WZRD_CLKFBOUT_FRAC_EN\tBIT(26)\n\n#define WZRD_CLKFBOUT_MULT_SHIFT\t8\n#define WZRD_CLKFBOUT_MULT_MASK\t\t(0xff << WZRD_CLKFBOUT_MULT_SHIFT)\n#define WZRD_CLKFBOUT_FRAC_SHIFT\t16\n#define WZRD_CLKFBOUT_FRAC_MASK\t\t(0x3ff << WZRD_CLKFBOUT_FRAC_SHIFT)\n#define WZRD_DIVCLK_DIVIDE_SHIFT\t0\n#define WZRD_DIVCLK_DIVIDE_MASK\t\t(0xff << WZRD_DIVCLK_DIVIDE_SHIFT)\n#define WZRD_CLKOUT_DIVIDE_SHIFT\t0\n#define WZRD_CLKOUT_DIVIDE_WIDTH\t8\n#define WZRD_CLKOUT_DIVIDE_MASK\t\t(0xff << WZRD_DIVCLK_DIVIDE_SHIFT)\n#define WZRD_CLKOUT_FRAC_SHIFT\t\t8\n#define WZRD_CLKOUT_FRAC_MASK\t\t0x3ff\n#define WZRD_CLKOUT0_FRAC_MASK\t\tGENMASK(17, 8)\n\n#define WZRD_DR_MAX_INT_DIV_VALUE\t255\n#define WZRD_DR_STATUS_REG_OFFSET\t0x04\n#define WZRD_DR_LOCK_BIT_MASK\t\t0x00000001\n#define WZRD_DR_INIT_REG_OFFSET\t\t0x25C\n#define WZRD_DR_DIV_TO_PHASE_OFFSET\t4\n#define WZRD_DR_BEGIN_DYNA_RECONF\t0x03\n#define WZRD_DR_BEGIN_DYNA_RECONF_5_2\t0x07\n#define WZRD_DR_BEGIN_DYNA_RECONF1_5_2\t0x02\n\n#define WZRD_USEC_POLL\t\t10\n#define WZRD_TIMEOUT_POLL\t\t1000\n\n \n#define DIV_O\t\t\t\t0x01\n#define DIV_ALL\t\t\t\t0x03\n\n#define WZRD_M_MIN\t\t\t2\n#define WZRD_M_MAX\t\t\t128\n#define WZRD_D_MIN\t\t\t1\n#define WZRD_D_MAX\t\t\t106\n#define WZRD_VCO_MIN\t\t\t800000000\n#define WZRD_VCO_MAX\t\t\t1600000000\n#define WZRD_O_MIN\t\t\t1\n#define WZRD_O_MAX\t\t\t128\n#define WZRD_MIN_ERR\t\t\t20000\n#define WZRD_FRAC_POINTS\t\t1000\n\n \n#define div_mask(width)\t\t\t((1 << (width)) - 1)\n\n \n#define to_clk_wzrd_divider(_hw) container_of(_hw, struct clk_wzrd_divider, hw)\n\nenum clk_wzrd_int_clks {\n\twzrd_clk_mul,\n\twzrd_clk_mul_div,\n\twzrd_clk_mul_frac,\n\twzrd_clk_int_max\n};\n\n \nstruct clk_wzrd {\n\tstruct clk_onecell_data clk_data;\n\tstruct notifier_block nb;\n\tvoid __iomem *base;\n\tstruct clk *clk_in1;\n\tstruct clk *axi_clk;\n\tstruct clk *clks_internal[wzrd_clk_int_max];\n\tstruct clk *clkout[WZRD_NUM_OUTPUTS];\n\tunsigned int speed_grade;\n\tbool suspended;\n};\n\n \nstruct clk_wzrd_divider {\n\tstruct clk_hw hw;\n\tvoid __iomem *base;\n\tu16 offset;\n\tu8 shift;\n\tu8 width;\n\tu8 flags;\n\tconst struct clk_div_table *table;\n\tu32 m;\n\tu32 d;\n\tu32 o;\n\tspinlock_t *lock;   \n};\n\n#define to_clk_wzrd(_nb) container_of(_nb, struct clk_wzrd, nb)\n\n \nstatic const unsigned long clk_wzrd_max_freq[] = {\n\t800000000UL,\n\t933000000UL,\n\t1066000000UL\n};\n\n \nstatic DEFINE_SPINLOCK(clkwzrd_lock);\n\nstatic unsigned long clk_wzrd_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);\n\tvoid __iomem *div_addr = divider->base + divider->offset;\n\tunsigned int val;\n\n\tval = readl(div_addr) >> divider->shift;\n\tval &= div_mask(divider->width);\n\n\treturn divider_recalc_rate(hw, parent_rate, val, divider->table,\n\t\t\tdivider->flags, divider->width);\n}\n\nstatic int clk_wzrd_dynamic_reconfig(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tint err;\n\tu32 value;\n\tunsigned long flags = 0;\n\tstruct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);\n\tvoid __iomem *div_addr = divider->base + divider->offset;\n\n\tif (divider->lock)\n\t\tspin_lock_irqsave(divider->lock, flags);\n\telse\n\t\t__acquire(divider->lock);\n\n\tvalue = DIV_ROUND_CLOSEST(parent_rate, rate);\n\n\t \n\tmin_t(u32, value, WZRD_DR_MAX_INT_DIV_VALUE);\n\n\t \n\twritel(value, div_addr);\n\twritel(0x00, div_addr + WZRD_DR_DIV_TO_PHASE_OFFSET);\n\n\t \n\terr = readl_poll_timeout(divider->base + WZRD_DR_STATUS_REG_OFFSET,\n\t\t\t\t value, value & WZRD_DR_LOCK_BIT_MASK,\n\t\t\t\t WZRD_USEC_POLL, WZRD_TIMEOUT_POLL);\n\tif (err)\n\t\tgoto err_reconfig;\n\n\t \n\twritel(WZRD_DR_BEGIN_DYNA_RECONF_5_2,\n\t       divider->base + WZRD_DR_INIT_REG_OFFSET);\n\twritel(WZRD_DR_BEGIN_DYNA_RECONF1_5_2,\n\t       divider->base + WZRD_DR_INIT_REG_OFFSET);\n\n\t \n\terr = readl_poll_timeout(divider->base + WZRD_DR_STATUS_REG_OFFSET,\n\t\t\t\t value, value & WZRD_DR_LOCK_BIT_MASK,\n\t\t\t\t WZRD_USEC_POLL, WZRD_TIMEOUT_POLL);\nerr_reconfig:\n\tif (divider->lock)\n\t\tspin_unlock_irqrestore(divider->lock, flags);\n\telse\n\t\t__release(divider->lock);\n\treturn err;\n}\n\nstatic long clk_wzrd_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *prate)\n{\n\tu8 div;\n\n\t \n\tdiv = DIV_ROUND_CLOSEST(*prate, rate);\n\n\treturn *prate / div;\n}\n\nstatic int clk_wzrd_get_divisors(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);\n\tunsigned long vco_freq, freq, diff;\n\tu32 m, d, o;\n\n\tfor (m = WZRD_M_MIN; m <= WZRD_M_MAX; m++) {\n\t\tfor (d = WZRD_D_MIN; d <= WZRD_D_MAX; d++) {\n\t\t\tvco_freq = DIV_ROUND_CLOSEST((parent_rate * m), d);\n\t\t\tif (vco_freq >= WZRD_VCO_MIN && vco_freq <= WZRD_VCO_MAX) {\n\t\t\t\tfor (o = WZRD_O_MIN; o <= WZRD_O_MAX; o++) {\n\t\t\t\t\tfreq = DIV_ROUND_CLOSEST_ULL(vco_freq, o);\n\t\t\t\t\tdiff = abs(freq - rate);\n\n\t\t\t\t\tif (diff < WZRD_MIN_ERR) {\n\t\t\t\t\t\tdivider->m = m;\n\t\t\t\t\t\tdivider->d = d;\n\t\t\t\t\t\tdivider->o = o;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -EBUSY;\n}\n\nstatic int clk_wzrd_dynamic_all_nolock(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);\n\tunsigned long vco_freq, rate_div, clockout0_div;\n\tu32 reg, pre, value, f;\n\tint err;\n\n\terr = clk_wzrd_get_divisors(hw, rate, parent_rate);\n\tif (err)\n\t\treturn err;\n\n\tvco_freq = DIV_ROUND_CLOSEST(parent_rate * divider->m, divider->d);\n\trate_div = DIV_ROUND_CLOSEST_ULL((vco_freq * WZRD_FRAC_POINTS), rate);\n\n\tclockout0_div = div_u64(rate_div,  WZRD_FRAC_POINTS);\n\n\tpre = DIV_ROUND_CLOSEST_ULL(vco_freq * WZRD_FRAC_POINTS, rate);\n\tf = (pre - (clockout0_div * WZRD_FRAC_POINTS));\n\tf &= WZRD_CLKOUT_FRAC_MASK;\n\n\treg = FIELD_PREP(WZRD_CLKOUT_DIVIDE_MASK, clockout0_div) |\n\t      FIELD_PREP(WZRD_CLKOUT0_FRAC_MASK, f);\n\n\twritel(reg, divider->base + WZRD_CLK_CFG_REG(2));\n\t \n\treg = FIELD_PREP(WZRD_CLKFBOUT_MULT_MASK, divider->m) |\n\t      FIELD_PREP(WZRD_DIVCLK_DIVIDE_MASK, divider->d);\n\twritel(reg, divider->base + WZRD_CLK_CFG_REG(0));\n\twritel(divider->o, divider->base + WZRD_CLK_CFG_REG(2));\n\twritel(0, divider->base + WZRD_CLK_CFG_REG(3));\n\t \n\terr = readl_poll_timeout(divider->base + WZRD_DR_STATUS_REG_OFFSET, value,\n\t\t\t\t value & WZRD_DR_LOCK_BIT_MASK,\n\t\t\t\t WZRD_USEC_POLL, WZRD_TIMEOUT_POLL);\n\tif (err)\n\t\treturn -ETIMEDOUT;\n\n\t \n\twritel(WZRD_DR_BEGIN_DYNA_RECONF,\n\t       divider->base + WZRD_DR_INIT_REG_OFFSET);\n\n\t \n\treturn readl_poll_timeout(divider->base + WZRD_DR_STATUS_REG_OFFSET, value,\n\t\t\t\t value & WZRD_DR_LOCK_BIT_MASK,\n\t\t\t\t WZRD_USEC_POLL, WZRD_TIMEOUT_POLL);\n}\n\nstatic int clk_wzrd_dynamic_all(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);\n\tunsigned long flags = 0;\n\tint ret;\n\n\tspin_lock_irqsave(divider->lock, flags);\n\n\tret = clk_wzrd_dynamic_all_nolock(hw, rate, parent_rate);\n\n\tspin_unlock_irqrestore(divider->lock, flags);\n\n\treturn ret;\n}\n\nstatic unsigned long clk_wzrd_recalc_rate_all(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);\n\tu32 m, d, o, div, reg, f;\n\n\treg = readl(divider->base + WZRD_CLK_CFG_REG(0));\n\td = FIELD_GET(WZRD_DIVCLK_DIVIDE_MASK, reg);\n\tm = FIELD_GET(WZRD_CLKFBOUT_MULT_MASK, reg);\n\treg = readl(divider->base + WZRD_CLK_CFG_REG(2));\n\to = FIELD_GET(WZRD_DIVCLK_DIVIDE_MASK, reg);\n\tf = FIELD_GET(WZRD_CLKOUT0_FRAC_MASK, reg);\n\n\tdiv = DIV_ROUND_CLOSEST(d * (WZRD_FRAC_POINTS * o + f), WZRD_FRAC_POINTS);\n\treturn divider_recalc_rate(hw, parent_rate * m, div, divider->table,\n\t\t\tdivider->flags, divider->width);\n}\n\nstatic long clk_wzrd_round_rate_all(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *prate)\n{\n\tstruct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);\n\tunsigned long int_freq;\n\tu32 m, d, o, div, f;\n\tint err;\n\n\terr = clk_wzrd_get_divisors(hw, rate, *prate);\n\tif (err)\n\t\treturn err;\n\n\tm = divider->m;\n\td = divider->d;\n\to = divider->o;\n\n\tdiv = d * o;\n\tint_freq =  divider_recalc_rate(hw, *prate * m, div, divider->table,\n\t\t\t\t\tdivider->flags, divider->width);\n\n\tif (rate > int_freq) {\n\t\tf = DIV_ROUND_CLOSEST_ULL(rate * WZRD_FRAC_POINTS, int_freq);\n\t\trate = DIV_ROUND_CLOSEST(int_freq * f, WZRD_FRAC_POINTS);\n\t}\n\treturn rate;\n}\n\nstatic const struct clk_ops clk_wzrd_clk_divider_ops = {\n\t.round_rate = clk_wzrd_round_rate,\n\t.set_rate = clk_wzrd_dynamic_reconfig,\n\t.recalc_rate = clk_wzrd_recalc_rate,\n};\n\nstatic const struct clk_ops clk_wzrd_clk_div_all_ops = {\n\t.round_rate = clk_wzrd_round_rate_all,\n\t.set_rate = clk_wzrd_dynamic_all,\n\t.recalc_rate = clk_wzrd_recalc_rate_all,\n};\n\nstatic unsigned long clk_wzrd_recalc_ratef(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tunsigned int val;\n\tu32 div, frac;\n\tstruct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);\n\tvoid __iomem *div_addr = divider->base + divider->offset;\n\n\tval = readl(div_addr);\n\tdiv = val & div_mask(divider->width);\n\tfrac = (val >> WZRD_CLKOUT_FRAC_SHIFT) & WZRD_CLKOUT_FRAC_MASK;\n\n\treturn mult_frac(parent_rate, 1000, (div * 1000) + frac);\n}\n\nstatic int clk_wzrd_dynamic_reconfig_f(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long parent_rate)\n{\n\tint err;\n\tu32 value, pre;\n\tunsigned long rate_div, f, clockout0_div;\n\tstruct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);\n\tvoid __iomem *div_addr = divider->base + divider->offset;\n\n\trate_div = DIV_ROUND_DOWN_ULL(parent_rate * 1000, rate);\n\tclockout0_div = rate_div / 1000;\n\n\tpre = DIV_ROUND_CLOSEST((parent_rate * 1000), rate);\n\tf = (u32)(pre - (clockout0_div * 1000));\n\tf = f & WZRD_CLKOUT_FRAC_MASK;\n\tf = f << WZRD_CLKOUT_DIVIDE_WIDTH;\n\n\tvalue = (f  | (clockout0_div & WZRD_CLKOUT_DIVIDE_MASK));\n\n\t \n\twritel(value, div_addr);\n\twritel(0x0, div_addr + WZRD_DR_DIV_TO_PHASE_OFFSET);\n\n\t \n\terr = readl_poll_timeout(divider->base + WZRD_DR_STATUS_REG_OFFSET, value,\n\t\t\t\t value & WZRD_DR_LOCK_BIT_MASK,\n\t\t\t\t WZRD_USEC_POLL, WZRD_TIMEOUT_POLL);\n\tif (err)\n\t\treturn err;\n\n\t \n\twritel(WZRD_DR_BEGIN_DYNA_RECONF_5_2,\n\t       divider->base + WZRD_DR_INIT_REG_OFFSET);\n\twritel(WZRD_DR_BEGIN_DYNA_RECONF1_5_2,\n\t       divider->base + WZRD_DR_INIT_REG_OFFSET);\n\n\t \n\treturn readl_poll_timeout(divider->base + WZRD_DR_STATUS_REG_OFFSET, value,\n\t\t\t\tvalue & WZRD_DR_LOCK_BIT_MASK,\n\t\t\t\tWZRD_USEC_POLL, WZRD_TIMEOUT_POLL);\n}\n\nstatic long clk_wzrd_round_rate_f(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long *prate)\n{\n\treturn rate;\n}\n\nstatic const struct clk_ops clk_wzrd_clk_divider_ops_f = {\n\t.round_rate = clk_wzrd_round_rate_f,\n\t.set_rate = clk_wzrd_dynamic_reconfig_f,\n\t.recalc_rate = clk_wzrd_recalc_ratef,\n};\n\nstatic struct clk *clk_wzrd_register_divf(struct device *dev,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  const char *parent_name,\n\t\t\t\t\t  unsigned long flags,\n\t\t\t\t\t  void __iomem *base, u16 offset,\n\t\t\t\t\t  u8 shift, u8 width,\n\t\t\t\t\t  u8 clk_divider_flags,\n\t\t\t\t\t  u32 div_type,\n\t\t\t\t\t  spinlock_t *lock)\n{\n\tstruct clk_wzrd_divider *div;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tdiv = devm_kzalloc(dev, sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\n\tinit.ops = &clk_wzrd_clk_divider_ops_f;\n\n\tinit.flags = flags;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tdiv->base = base;\n\tdiv->offset = offset;\n\tdiv->shift = shift;\n\tdiv->width = width;\n\tdiv->flags = clk_divider_flags;\n\tdiv->lock = lock;\n\tdiv->hw.init = &init;\n\n\thw = &div->hw;\n\tret =  devm_clk_hw_register(dev, hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn hw->clk;\n}\n\nstatic struct clk *clk_wzrd_register_divider(struct device *dev,\n\t\t\t\t\t     const char *name,\n\t\t\t\t\t     const char *parent_name,\n\t\t\t\t\t     unsigned long flags,\n\t\t\t\t\t     void __iomem *base, u16 offset,\n\t\t\t\t\t     u8 shift, u8 width,\n\t\t\t\t\t     u8 clk_divider_flags,\n\t\t\t\t\t     u32 div_type,\n\t\t\t\t\t     spinlock_t *lock)\n{\n\tstruct clk_wzrd_divider *div;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tdiv = devm_kzalloc(dev, sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tif (clk_divider_flags & CLK_DIVIDER_READ_ONLY)\n\t\tinit.ops = &clk_divider_ro_ops;\n\telse if (div_type == DIV_O)\n\t\tinit.ops = &clk_wzrd_clk_divider_ops;\n\telse\n\t\tinit.ops = &clk_wzrd_clk_div_all_ops;\n\tinit.flags = flags;\n\tinit.parent_names =  &parent_name;\n\tinit.num_parents =  1;\n\n\tdiv->base = base;\n\tdiv->offset = offset;\n\tdiv->shift = shift;\n\tdiv->width = width;\n\tdiv->flags = clk_divider_flags;\n\tdiv->lock = lock;\n\tdiv->hw.init = &init;\n\n\thw = &div->hw;\n\tret = devm_clk_hw_register(dev, hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn hw->clk;\n}\n\nstatic int clk_wzrd_clk_notifier(struct notifier_block *nb, unsigned long event,\n\t\t\t\t void *data)\n{\n\tunsigned long max;\n\tstruct clk_notifier_data *ndata = data;\n\tstruct clk_wzrd *clk_wzrd = to_clk_wzrd(nb);\n\n\tif (clk_wzrd->suspended)\n\t\treturn NOTIFY_OK;\n\n\tif (ndata->clk == clk_wzrd->clk_in1)\n\t\tmax = clk_wzrd_max_freq[clk_wzrd->speed_grade - 1];\n\telse if (ndata->clk == clk_wzrd->axi_clk)\n\t\tmax = WZRD_ACLK_MAX_FREQ;\n\telse\n\t\treturn NOTIFY_DONE;\t \n\n\tswitch (event) {\n\tcase PRE_RATE_CHANGE:\n\t\tif (ndata->new_rate > max)\n\t\t\treturn NOTIFY_BAD;\n\t\treturn NOTIFY_OK;\n\tcase POST_RATE_CHANGE:\n\tcase ABORT_RATE_CHANGE:\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}\n\nstatic int __maybe_unused clk_wzrd_suspend(struct device *dev)\n{\n\tstruct clk_wzrd *clk_wzrd = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(clk_wzrd->axi_clk);\n\tclk_wzrd->suspended = true;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused clk_wzrd_resume(struct device *dev)\n{\n\tint ret;\n\tstruct clk_wzrd *clk_wzrd = dev_get_drvdata(dev);\n\n\tret = clk_prepare_enable(clk_wzrd->axi_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to enable s_axi_aclk\\n\");\n\t\treturn ret;\n\t}\n\n\tclk_wzrd->suspended = false;\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(clk_wzrd_dev_pm_ops, clk_wzrd_suspend,\n\t\t\t clk_wzrd_resume);\n\nstatic int clk_wzrd_probe(struct platform_device *pdev)\n{\n\tint i, ret;\n\tu32 reg, reg_f, mult;\n\tunsigned long rate;\n\tconst char *clk_name;\n\tvoid __iomem *ctrl_reg;\n\tstruct clk_wzrd *clk_wzrd;\n\tconst char *clkout_name;\n\tstruct device_node *np = pdev->dev.of_node;\n\tint nr_outputs;\n\tunsigned long flags = 0;\n\n\tclk_wzrd = devm_kzalloc(&pdev->dev, sizeof(*clk_wzrd), GFP_KERNEL);\n\tif (!clk_wzrd)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, clk_wzrd);\n\n\tclk_wzrd->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(clk_wzrd->base))\n\t\treturn PTR_ERR(clk_wzrd->base);\n\n\tret = of_property_read_u32(np, \"xlnx,speed-grade\", &clk_wzrd->speed_grade);\n\tif (!ret) {\n\t\tif (clk_wzrd->speed_grade < 1 || clk_wzrd->speed_grade > 3) {\n\t\t\tdev_warn(&pdev->dev, \"invalid speed grade '%d'\\n\",\n\t\t\t\t clk_wzrd->speed_grade);\n\t\t\tclk_wzrd->speed_grade = 0;\n\t\t}\n\t}\n\n\tclk_wzrd->clk_in1 = devm_clk_get(&pdev->dev, \"clk_in1\");\n\tif (IS_ERR(clk_wzrd->clk_in1))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(clk_wzrd->clk_in1),\n\t\t\t\t     \"clk_in1 not found\\n\");\n\n\tclk_wzrd->axi_clk = devm_clk_get(&pdev->dev, \"s_axi_aclk\");\n\tif (IS_ERR(clk_wzrd->axi_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(clk_wzrd->axi_clk),\n\t\t\t\t     \"s_axi_aclk not found\\n\");\n\tret = clk_prepare_enable(clk_wzrd->axi_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"enabling s_axi_aclk failed\\n\");\n\t\treturn ret;\n\t}\n\trate = clk_get_rate(clk_wzrd->axi_clk);\n\tif (rate > WZRD_ACLK_MAX_FREQ) {\n\t\tdev_err(&pdev->dev, \"s_axi_aclk frequency (%lu) too high\\n\",\n\t\t\trate);\n\t\tret = -EINVAL;\n\t\tgoto err_disable_clk;\n\t}\n\n\tret = of_property_read_u32(np, \"xlnx,nr-outputs\", &nr_outputs);\n\tif (ret || nr_outputs > WZRD_NUM_OUTPUTS) {\n\t\tret = -EINVAL;\n\t\tgoto err_disable_clk;\n\t}\n\n\tclkout_name = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"%s_out0\", dev_name(&pdev->dev));\n\tif (!clkout_name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_disable_clk;\n\t}\n\n\tif (nr_outputs == 1) {\n\t\tclk_wzrd->clkout[0] = clk_wzrd_register_divider\n\t\t\t\t(&pdev->dev, clkout_name,\n\t\t\t\t__clk_get_name(clk_wzrd->clk_in1), 0,\n\t\t\t\tclk_wzrd->base, WZRD_CLK_CFG_REG(3),\n\t\t\t\tWZRD_CLKOUT_DIVIDE_SHIFT,\n\t\t\t\tWZRD_CLKOUT_DIVIDE_WIDTH,\n\t\t\t\tCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\n\t\t\t\tDIV_ALL, &clkwzrd_lock);\n\n\t\tgoto out;\n\t}\n\n\treg = readl(clk_wzrd->base + WZRD_CLK_CFG_REG(0));\n\treg_f = reg & WZRD_CLKFBOUT_FRAC_MASK;\n\treg_f =  reg_f >> WZRD_CLKFBOUT_FRAC_SHIFT;\n\n\treg = reg & WZRD_CLKFBOUT_MULT_MASK;\n\treg =  reg >> WZRD_CLKFBOUT_MULT_SHIFT;\n\tmult = (reg * 1000) + reg_f;\n\tclk_name = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"%s_mul\", dev_name(&pdev->dev));\n\tif (!clk_name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_disable_clk;\n\t}\n\tclk_wzrd->clks_internal[wzrd_clk_mul] = clk_register_fixed_factor\n\t\t\t(&pdev->dev, clk_name,\n\t\t\t __clk_get_name(clk_wzrd->clk_in1),\n\t\t\t0, mult, 1000);\n\tif (IS_ERR(clk_wzrd->clks_internal[wzrd_clk_mul])) {\n\t\tdev_err(&pdev->dev, \"unable to register fixed-factor clock\\n\");\n\t\tret = PTR_ERR(clk_wzrd->clks_internal[wzrd_clk_mul]);\n\t\tgoto err_disable_clk;\n\t}\n\n\tclk_name = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"%s_mul_div\", dev_name(&pdev->dev));\n\tif (!clk_name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_rm_int_clk;\n\t}\n\n\tctrl_reg = clk_wzrd->base + WZRD_CLK_CFG_REG(0);\n\t \n\tclk_wzrd->clks_internal[wzrd_clk_mul_div] = clk_register_divider\n\t\t\t(&pdev->dev, clk_name,\n\t\t\t __clk_get_name(clk_wzrd->clks_internal[wzrd_clk_mul]),\n\t\t\tflags, ctrl_reg, 0, 8, CLK_DIVIDER_ONE_BASED |\n\t\t\tCLK_DIVIDER_ALLOW_ZERO, &clkwzrd_lock);\n\tif (IS_ERR(clk_wzrd->clks_internal[wzrd_clk_mul_div])) {\n\t\tdev_err(&pdev->dev, \"unable to register divider clock\\n\");\n\t\tret = PTR_ERR(clk_wzrd->clks_internal[wzrd_clk_mul_div]);\n\t\tgoto err_rm_int_clk;\n\t}\n\n\t \n\tfor (i = nr_outputs - 1; i >= 0 ; i--) {\n\t\tclkout_name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t     \"%s_out%d\", dev_name(&pdev->dev), i);\n\t\tif (!clkout_name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_rm_int_clk;\n\t\t}\n\n\t\tif (!i)\n\t\t\tclk_wzrd->clkout[i] = clk_wzrd_register_divf\n\t\t\t\t(&pdev->dev, clkout_name,\n\t\t\t\tclk_name, flags,\n\t\t\t\tclk_wzrd->base, (WZRD_CLK_CFG_REG(2) + i * 12),\n\t\t\t\tWZRD_CLKOUT_DIVIDE_SHIFT,\n\t\t\t\tWZRD_CLKOUT_DIVIDE_WIDTH,\n\t\t\t\tCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\n\t\t\t\tDIV_O, &clkwzrd_lock);\n\t\telse\n\t\t\tclk_wzrd->clkout[i] = clk_wzrd_register_divider\n\t\t\t\t(&pdev->dev, clkout_name,\n\t\t\t\tclk_name, 0,\n\t\t\t\tclk_wzrd->base, (WZRD_CLK_CFG_REG(2) + i * 12),\n\t\t\t\tWZRD_CLKOUT_DIVIDE_SHIFT,\n\t\t\t\tWZRD_CLKOUT_DIVIDE_WIDTH,\n\t\t\t\tCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\n\t\t\t\tDIV_O, &clkwzrd_lock);\n\t\tif (IS_ERR(clk_wzrd->clkout[i])) {\n\t\t\tint j;\n\n\t\t\tfor (j = i + 1; j < nr_outputs; j++)\n\t\t\t\tclk_unregister(clk_wzrd->clkout[j]);\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"unable to register divider clock\\n\");\n\t\t\tret = PTR_ERR(clk_wzrd->clkout[i]);\n\t\t\tgoto err_rm_int_clks;\n\t\t}\n\t}\n\nout:\n\tclk_wzrd->clk_data.clks = clk_wzrd->clkout;\n\tclk_wzrd->clk_data.clk_num = ARRAY_SIZE(clk_wzrd->clkout);\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &clk_wzrd->clk_data);\n\n\tif (clk_wzrd->speed_grade) {\n\t\tclk_wzrd->nb.notifier_call = clk_wzrd_clk_notifier;\n\n\t\tret = clk_notifier_register(clk_wzrd->clk_in1,\n\t\t\t\t\t    &clk_wzrd->nb);\n\t\tif (ret)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"unable to register clock notifier\\n\");\n\n\t\tret = clk_notifier_register(clk_wzrd->axi_clk, &clk_wzrd->nb);\n\t\tif (ret)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"unable to register clock notifier\\n\");\n\t}\n\n\treturn 0;\n\nerr_rm_int_clks:\n\tclk_unregister(clk_wzrd->clks_internal[1]);\nerr_rm_int_clk:\n\tclk_unregister(clk_wzrd->clks_internal[0]);\nerr_disable_clk:\n\tclk_disable_unprepare(clk_wzrd->axi_clk);\n\n\treturn ret;\n}\n\nstatic void clk_wzrd_remove(struct platform_device *pdev)\n{\n\tint i;\n\tstruct clk_wzrd *clk_wzrd = platform_get_drvdata(pdev);\n\n\tof_clk_del_provider(pdev->dev.of_node);\n\n\tfor (i = 0; i < WZRD_NUM_OUTPUTS; i++)\n\t\tclk_unregister(clk_wzrd->clkout[i]);\n\tfor (i = 0; i < wzrd_clk_int_max; i++)\n\t\tclk_unregister(clk_wzrd->clks_internal[i]);\n\n\tif (clk_wzrd->speed_grade) {\n\t\tclk_notifier_unregister(clk_wzrd->axi_clk, &clk_wzrd->nb);\n\t\tclk_notifier_unregister(clk_wzrd->clk_in1, &clk_wzrd->nb);\n\t}\n\n\tclk_disable_unprepare(clk_wzrd->axi_clk);\n}\n\nstatic const struct of_device_id clk_wzrd_ids[] = {\n\t{ .compatible = \"xlnx,clocking-wizard\" },\n\t{ .compatible = \"xlnx,clocking-wizard-v5.2\" },\n\t{ .compatible = \"xlnx,clocking-wizard-v6.0\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, clk_wzrd_ids);\n\nstatic struct platform_driver clk_wzrd_driver = {\n\t.driver = {\n\t\t.name = \"clk-wizard\",\n\t\t.of_match_table = clk_wzrd_ids,\n\t\t.pm = &clk_wzrd_dev_pm_ops,\n\t},\n\t.probe = clk_wzrd_probe,\n\t.remove_new = clk_wzrd_remove,\n};\nmodule_platform_driver(clk_wzrd_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Soeren Brinkmann <soren.brinkmann@xilinx.com\");\nMODULE_DESCRIPTION(\"Driver for the Xilinx Clocking Wizard IP core\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}