{
  "module_name": "xlnx_vcu.c",
  "hash_id": "0a2de7b24c1bd8016d052da5a0c4f739c87f0653063bd55472db4440b0617cf1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/xilinx/xlnx_vcu.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/xlnx-vcu.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/clock/xlnx-vcu.h>\n\n#define VCU_PLL_CTRL\t\t\t0x24\n#define VCU_PLL_CTRL_RESET\t\tBIT(0)\n#define VCU_PLL_CTRL_POR_IN\t\tBIT(1)\n#define VCU_PLL_CTRL_PWR_POR\t\tBIT(2)\n#define VCU_PLL_CTRL_BYPASS\t\tBIT(3)\n#define VCU_PLL_CTRL_FBDIV\t\tGENMASK(14, 8)\n#define VCU_PLL_CTRL_CLKOUTDIV\t\tGENMASK(18, 16)\n\n#define VCU_PLL_CFG\t\t\t0x28\n#define VCU_PLL_CFG_RES\t\t\tGENMASK(3, 0)\n#define VCU_PLL_CFG_CP\t\t\tGENMASK(8, 5)\n#define VCU_PLL_CFG_LFHF\t\tGENMASK(12, 10)\n#define VCU_PLL_CFG_LOCK_CNT\t\tGENMASK(22, 13)\n#define VCU_PLL_CFG_LOCK_DLY\t\tGENMASK(31, 25)\n#define VCU_ENC_CORE_CTRL\t\t0x30\n#define VCU_ENC_MCU_CTRL\t\t0x34\n#define VCU_DEC_CORE_CTRL\t\t0x38\n#define VCU_DEC_MCU_CTRL\t\t0x3c\n#define VCU_PLL_STATUS\t\t\t0x60\n#define VCU_PLL_STATUS_LOCK_STATUS\tBIT(0)\n\n#define MHZ\t\t\t\t1000000\n#define FVCO_MIN\t\t\t(1500U * MHZ)\n#define FVCO_MAX\t\t\t(3000U * MHZ)\n\n \nstruct xvcu_device {\n\tstruct device *dev;\n\tstruct clk *pll_ref;\n\tstruct clk *aclk;\n\tstruct regmap *logicore_reg_ba;\n\tvoid __iomem *vcu_slcr_ba;\n\tstruct clk_hw *pll;\n\tstruct clk_hw *pll_post;\n\tstruct clk_hw_onecell_data *clk_data;\n};\n\nstatic struct regmap_config vcu_settings_regmap_config = {\n\t.name = \"regmap\",\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = 0xfff,\n\t.cache_type = REGCACHE_NONE,\n};\n\n \nstruct xvcu_pll_cfg {\n\tu32 fbdiv;\n\tu32 cp;\n\tu32 res;\n\tu32 lfhf;\n\tu32 lock_dly;\n\tu32 lock_cnt;\n};\n\nstatic const struct xvcu_pll_cfg xvcu_pll_cfg[] = {\n\t{ 25, 3, 10, 3, 63, 1000 },\n\t{ 26, 3, 10, 3, 63, 1000 },\n\t{ 27, 4, 6, 3, 63, 1000 },\n\t{ 28, 4, 6, 3, 63, 1000 },\n\t{ 29, 4, 6, 3, 63, 1000 },\n\t{ 30, 4, 6, 3, 63, 1000 },\n\t{ 31, 6, 1, 3, 63, 1000 },\n\t{ 32, 6, 1, 3, 63, 1000 },\n\t{ 33, 4, 10, 3, 63, 1000 },\n\t{ 34, 5, 6, 3, 63, 1000 },\n\t{ 35, 5, 6, 3, 63, 1000 },\n\t{ 36, 5, 6, 3, 63, 1000 },\n\t{ 37, 5, 6, 3, 63, 1000 },\n\t{ 38, 5, 6, 3, 63, 975 },\n\t{ 39, 3, 12, 3, 63, 950 },\n\t{ 40, 3, 12, 3, 63, 925 },\n\t{ 41, 3, 12, 3, 63, 900 },\n\t{ 42, 3, 12, 3, 63, 875 },\n\t{ 43, 3, 12, 3, 63, 850 },\n\t{ 44, 3, 12, 3, 63, 850 },\n\t{ 45, 3, 12, 3, 63, 825 },\n\t{ 46, 3, 12, 3, 63, 800 },\n\t{ 47, 3, 12, 3, 63, 775 },\n\t{ 48, 3, 12, 3, 63, 775 },\n\t{ 49, 3, 12, 3, 63, 750 },\n\t{ 50, 3, 12, 3, 63, 750 },\n\t{ 51, 3, 2, 3, 63, 725 },\n\t{ 52, 3, 2, 3, 63, 700 },\n\t{ 53, 3, 2, 3, 63, 700 },\n\t{ 54, 3, 2, 3, 63, 675 },\n\t{ 55, 3, 2, 3, 63, 675 },\n\t{ 56, 3, 2, 3, 63, 650 },\n\t{ 57, 3, 2, 3, 63, 650 },\n\t{ 58, 3, 2, 3, 63, 625 },\n\t{ 59, 3, 2, 3, 63, 625 },\n\t{ 60, 3, 2, 3, 63, 625 },\n\t{ 61, 3, 2, 3, 63, 600 },\n\t{ 62, 3, 2, 3, 63, 600 },\n\t{ 63, 3, 2, 3, 63, 600 },\n\t{ 64, 3, 2, 3, 63, 600 },\n\t{ 65, 3, 2, 3, 63, 600 },\n\t{ 66, 3, 2, 3, 63, 600 },\n\t{ 67, 3, 2, 3, 63, 600 },\n\t{ 68, 3, 2, 3, 63, 600 },\n\t{ 69, 3, 2, 3, 63, 600 },\n\t{ 70, 3, 2, 3, 63, 600 },\n\t{ 71, 3, 2, 3, 63, 600 },\n\t{ 72, 3, 2, 3, 63, 600 },\n\t{ 73, 3, 2, 3, 63, 600 },\n\t{ 74, 3, 2, 3, 63, 600 },\n\t{ 75, 3, 2, 3, 63, 600 },\n\t{ 76, 3, 2, 3, 63, 600 },\n\t{ 77, 3, 2, 3, 63, 600 },\n\t{ 78, 3, 2, 3, 63, 600 },\n\t{ 79, 3, 2, 3, 63, 600 },\n\t{ 80, 3, 2, 3, 63, 600 },\n\t{ 81, 3, 2, 3, 63, 600 },\n\t{ 82, 3, 2, 3, 63, 600 },\n\t{ 83, 4, 2, 3, 63, 600 },\n\t{ 84, 4, 2, 3, 63, 600 },\n\t{ 85, 4, 2, 3, 63, 600 },\n\t{ 86, 4, 2, 3, 63, 600 },\n\t{ 87, 4, 2, 3, 63, 600 },\n\t{ 88, 4, 2, 3, 63, 600 },\n\t{ 89, 4, 2, 3, 63, 600 },\n\t{ 90, 4, 2, 3, 63, 600 },\n\t{ 91, 4, 2, 3, 63, 600 },\n\t{ 92, 4, 2, 3, 63, 600 },\n\t{ 93, 4, 2, 3, 63, 600 },\n\t{ 94, 4, 2, 3, 63, 600 },\n\t{ 95, 4, 2, 3, 63, 600 },\n\t{ 96, 4, 2, 3, 63, 600 },\n\t{ 97, 4, 2, 3, 63, 600 },\n\t{ 98, 4, 2, 3, 63, 600 },\n\t{ 99, 4, 2, 3, 63, 600 },\n\t{ 100, 4, 2, 3, 63, 600 },\n\t{ 101, 4, 2, 3, 63, 600 },\n\t{ 102, 4, 2, 3, 63, 600 },\n\t{ 103, 5, 2, 3, 63, 600 },\n\t{ 104, 5, 2, 3, 63, 600 },\n\t{ 105, 5, 2, 3, 63, 600 },\n\t{ 106, 5, 2, 3, 63, 600 },\n\t{ 107, 3, 4, 3, 63, 600 },\n\t{ 108, 3, 4, 3, 63, 600 },\n\t{ 109, 3, 4, 3, 63, 600 },\n\t{ 110, 3, 4, 3, 63, 600 },\n\t{ 111, 3, 4, 3, 63, 600 },\n\t{ 112, 3, 4, 3, 63, 600 },\n\t{ 113, 3, 4, 3, 63, 600 },\n\t{ 114, 3, 4, 3, 63, 600 },\n\t{ 115, 3, 4, 3, 63, 600 },\n\t{ 116, 3, 4, 3, 63, 600 },\n\t{ 117, 3, 4, 3, 63, 600 },\n\t{ 118, 3, 4, 3, 63, 600 },\n\t{ 119, 3, 4, 3, 63, 600 },\n\t{ 120, 3, 4, 3, 63, 600 },\n\t{ 121, 3, 4, 3, 63, 600 },\n\t{ 122, 3, 4, 3, 63, 600 },\n\t{ 123, 3, 4, 3, 63, 600 },\n\t{ 124, 3, 4, 3, 63, 600 },\n\t{ 125, 3, 4, 3, 63, 600 },\n};\n\n \nstatic inline u32 xvcu_read(void __iomem *iomem, u32 offset)\n{\n\treturn ioread32(iomem + offset);\n}\n\n \nstatic inline void xvcu_write(void __iomem *iomem, u32 offset, u32 value)\n{\n\tiowrite32(value, iomem + offset);\n}\n\n#define to_vcu_pll(_hw) container_of(_hw, struct vcu_pll, hw)\n\nstruct vcu_pll {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg_base;\n\tunsigned long fvco_min;\n\tunsigned long fvco_max;\n};\n\nstatic int xvcu_pll_wait_for_lock(struct vcu_pll *pll)\n{\n\tvoid __iomem *base = pll->reg_base;\n\tunsigned long timeout;\n\tu32 lock_status;\n\n\ttimeout = jiffies + msecs_to_jiffies(2000);\n\tdo {\n\t\tlock_status = xvcu_read(base, VCU_PLL_STATUS);\n\t\tif (lock_status & VCU_PLL_STATUS_LOCK_STATUS)\n\t\t\treturn 0;\n\t} while (!time_after(jiffies, timeout));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic struct clk_hw *xvcu_register_pll_post(struct device *dev,\n\t\t\t\t\t     const char *name,\n\t\t\t\t\t     const struct clk_hw *parent_hw,\n\t\t\t\t\t     void __iomem *reg_base)\n{\n\tu32 div;\n\tu32 vcu_pll_ctrl;\n\n\t \n\tvcu_pll_ctrl = xvcu_read(reg_base, VCU_PLL_CTRL);\n\tdiv = FIELD_GET(VCU_PLL_CTRL_CLKOUTDIV, vcu_pll_ctrl);\n\tif (div != 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn clk_hw_register_fixed_factor(dev, \"vcu_pll_post\",\n\t\t\t\t\t    clk_hw_get_name(parent_hw),\n\t\t\t\t\t    CLK_SET_RATE_PARENT, 1, 2);\n}\n\nstatic const struct xvcu_pll_cfg *xvcu_find_cfg(int div)\n{\n\tconst struct xvcu_pll_cfg *cfg = NULL;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(xvcu_pll_cfg) - 1; i++)\n\t\tif (xvcu_pll_cfg[i].fbdiv == div)\n\t\t\tcfg = &xvcu_pll_cfg[i];\n\n\treturn cfg;\n}\n\nstatic int xvcu_pll_set_div(struct vcu_pll *pll, int div)\n{\n\tvoid __iomem *base = pll->reg_base;\n\tconst struct xvcu_pll_cfg *cfg = NULL;\n\tu32 vcu_pll_ctrl;\n\tu32 cfg_val;\n\n\tcfg = xvcu_find_cfg(div);\n\tif (!cfg)\n\t\treturn -EINVAL;\n\n\tvcu_pll_ctrl = xvcu_read(base, VCU_PLL_CTRL);\n\tvcu_pll_ctrl &= ~VCU_PLL_CTRL_FBDIV;\n\tvcu_pll_ctrl |= FIELD_PREP(VCU_PLL_CTRL_FBDIV, cfg->fbdiv);\n\txvcu_write(base, VCU_PLL_CTRL, vcu_pll_ctrl);\n\n\tcfg_val = FIELD_PREP(VCU_PLL_CFG_RES, cfg->res) |\n\t\t  FIELD_PREP(VCU_PLL_CFG_CP, cfg->cp) |\n\t\t  FIELD_PREP(VCU_PLL_CFG_LFHF, cfg->lfhf) |\n\t\t  FIELD_PREP(VCU_PLL_CFG_LOCK_CNT, cfg->lock_cnt) |\n\t\t  FIELD_PREP(VCU_PLL_CFG_LOCK_DLY, cfg->lock_dly);\n\txvcu_write(base, VCU_PLL_CFG, cfg_val);\n\n\treturn 0;\n}\n\nstatic long xvcu_pll_round_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long rate, unsigned long *parent_rate)\n{\n\tstruct vcu_pll *pll = to_vcu_pll(hw);\n\tunsigned int feedback_div;\n\n\trate = clamp_t(unsigned long, rate, pll->fvco_min, pll->fvco_max);\n\n\tfeedback_div = DIV_ROUND_CLOSEST_ULL(rate, *parent_rate);\n\tfeedback_div = clamp_t(unsigned int, feedback_div, 25, 125);\n\n\treturn *parent_rate * feedback_div;\n}\n\nstatic unsigned long xvcu_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct vcu_pll *pll = to_vcu_pll(hw);\n\tvoid __iomem *base = pll->reg_base;\n\tunsigned int div;\n\tu32 vcu_pll_ctrl;\n\n\tvcu_pll_ctrl = xvcu_read(base, VCU_PLL_CTRL);\n\tdiv = FIELD_GET(VCU_PLL_CTRL_FBDIV, vcu_pll_ctrl);\n\n\treturn div * parent_rate;\n}\n\nstatic int xvcu_pll_set_rate(struct clk_hw *hw,\n\t\t\t     unsigned long rate, unsigned long parent_rate)\n{\n\tstruct vcu_pll *pll = to_vcu_pll(hw);\n\n\treturn xvcu_pll_set_div(pll, rate / parent_rate);\n}\n\nstatic int xvcu_pll_enable(struct clk_hw *hw)\n{\n\tstruct vcu_pll *pll = to_vcu_pll(hw);\n\tvoid __iomem *base = pll->reg_base;\n\tu32 vcu_pll_ctrl;\n\tint ret;\n\n\tvcu_pll_ctrl = xvcu_read(base, VCU_PLL_CTRL);\n\tvcu_pll_ctrl |= VCU_PLL_CTRL_BYPASS;\n\txvcu_write(base, VCU_PLL_CTRL, vcu_pll_ctrl);\n\n\tvcu_pll_ctrl = xvcu_read(base, VCU_PLL_CTRL);\n\tvcu_pll_ctrl &= ~VCU_PLL_CTRL_POR_IN;\n\tvcu_pll_ctrl &= ~VCU_PLL_CTRL_PWR_POR;\n\tvcu_pll_ctrl &= ~VCU_PLL_CTRL_RESET;\n\txvcu_write(base, VCU_PLL_CTRL, vcu_pll_ctrl);\n\n\tret = xvcu_pll_wait_for_lock(pll);\n\tif (ret) {\n\t\tpr_err(\"VCU PLL is not locked\\n\");\n\t\tgoto err;\n\t}\n\n\tvcu_pll_ctrl = xvcu_read(base, VCU_PLL_CTRL);\n\tvcu_pll_ctrl &= ~VCU_PLL_CTRL_BYPASS;\n\txvcu_write(base, VCU_PLL_CTRL, vcu_pll_ctrl);\n\nerr:\n\treturn ret;\n}\n\nstatic void xvcu_pll_disable(struct clk_hw *hw)\n{\n\tstruct vcu_pll *pll = to_vcu_pll(hw);\n\tvoid __iomem *base = pll->reg_base;\n\tu32 vcu_pll_ctrl;\n\n\tvcu_pll_ctrl = xvcu_read(base, VCU_PLL_CTRL);\n\tvcu_pll_ctrl |= VCU_PLL_CTRL_POR_IN;\n\tvcu_pll_ctrl |= VCU_PLL_CTRL_PWR_POR;\n\tvcu_pll_ctrl |= VCU_PLL_CTRL_RESET;\n\txvcu_write(base, VCU_PLL_CTRL, vcu_pll_ctrl);\n}\n\nstatic const struct clk_ops vcu_pll_ops = {\n\t.enable = xvcu_pll_enable,\n\t.disable = xvcu_pll_disable,\n\t.round_rate = xvcu_pll_round_rate,\n\t.recalc_rate = xvcu_pll_recalc_rate,\n\t.set_rate = xvcu_pll_set_rate,\n};\n\nstatic struct clk_hw *xvcu_register_pll(struct device *dev,\n\t\t\t\t\tvoid __iomem *reg_base,\n\t\t\t\t\tconst char *name, const char *parent,\n\t\t\t\t\tunsigned long flags)\n{\n\tstruct vcu_pll *pll;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tinit.name = name;\n\tinit.parent_names = &parent;\n\tinit.ops = &vcu_pll_ops;\n\tinit.num_parents = 1;\n\tinit.flags = flags;\n\n\tpll = devm_kmalloc(dev, sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpll->hw.init = &init;\n\tpll->reg_base = reg_base;\n\tpll->fvco_min = FVCO_MIN;\n\tpll->fvco_max = FVCO_MAX;\n\n\thw = &pll->hw;\n\tret = devm_clk_hw_register(dev, hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tclk_hw_set_rate_range(hw, pll->fvco_min, pll->fvco_max);\n\n\treturn hw;\n}\n\nstatic struct clk_hw *xvcu_clk_hw_register_leaf(struct device *dev,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tconst struct clk_parent_data *parent_data,\n\t\t\t\t\t\tu8 num_parents,\n\t\t\t\t\t\tvoid __iomem *reg)\n{\n\tu8 mux_flags = CLK_MUX_ROUND_CLOSEST;\n\tu8 divider_flags = CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO |\n\t\t\t   CLK_DIVIDER_ROUND_CLOSEST;\n\tstruct clk_hw *mux = NULL;\n\tstruct clk_hw *divider = NULL;\n\tstruct clk_hw *gate = NULL;\n\tchar *name_mux;\n\tchar *name_div;\n\tint err;\n\t \n\tspinlock_t *lock;\n\n\tlock = devm_kzalloc(dev, sizeof(*lock), GFP_KERNEL);\n\tif (!lock)\n\t\treturn ERR_PTR(-ENOMEM);\n\tspin_lock_init(lock);\n\n\tname_mux = devm_kasprintf(dev, GFP_KERNEL, \"%s%s\", name, \"_mux\");\n\tif (!name_mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmux = clk_hw_register_mux_parent_data(dev, name_mux,\n\t\t\t\t\t      parent_data, num_parents,\n\t\t\t\t\t      CLK_SET_RATE_PARENT,\n\t\t\t\t\t      reg, 0, 1, mux_flags, lock);\n\tif (IS_ERR(mux))\n\t\treturn mux;\n\n\tname_div = devm_kasprintf(dev, GFP_KERNEL, \"%s%s\", name, \"_div\");\n\tif (!name_div) {\n\t\terr = -ENOMEM;\n\t\tgoto unregister_mux;\n\t}\n\tdivider = clk_hw_register_divider_parent_hw(dev, name_div, mux,\n\t\t\t\t\t\t    CLK_SET_RATE_PARENT,\n\t\t\t\t\t\t    reg, 4, 6, divider_flags,\n\t\t\t\t\t\t    lock);\n\tif (IS_ERR(divider)) {\n\t\terr = PTR_ERR(divider);\n\t\tgoto unregister_mux;\n\t}\n\n\tgate = clk_hw_register_gate_parent_hw(dev, name, divider,\n\t\t\t\t\t      CLK_SET_RATE_PARENT, reg, 12, 0,\n\t\t\t\t\t      lock);\n\tif (IS_ERR(gate)) {\n\t\terr = PTR_ERR(gate);\n\t\tgoto unregister_divider;\n\t}\n\n\treturn gate;\n\nunregister_divider:\n\tclk_hw_unregister_divider(divider);\nunregister_mux:\n\tclk_hw_unregister_mux(mux);\n\n\treturn ERR_PTR(err);\n}\n\nstatic void xvcu_clk_hw_unregister_leaf(struct clk_hw *hw)\n{\n\tstruct clk_hw *gate = hw;\n\tstruct clk_hw *divider;\n\tstruct clk_hw *mux;\n\n\tif (!gate)\n\t\treturn;\n\n\tdivider = clk_hw_get_parent(gate);\n\tclk_hw_unregister_gate(gate);\n\tif (!divider)\n\t\treturn;\n\n\tmux = clk_hw_get_parent(divider);\n\tclk_hw_unregister_mux(mux);\n\tif (!divider)\n\t\treturn;\n\n\tclk_hw_unregister_divider(divider);\n}\n\nstatic int xvcu_register_clock_provider(struct xvcu_device *xvcu)\n{\n\tstruct device *dev = xvcu->dev;\n\tstruct clk_parent_data parent_data[2] = { 0 };\n\tstruct clk_hw_onecell_data *data;\n\tstruct clk_hw **hws;\n\tstruct clk_hw *hw;\n\tvoid __iomem *reg_base = xvcu->vcu_slcr_ba;\n\n\tdata = devm_kzalloc(dev, struct_size(data, hws, CLK_XVCU_NUM_CLOCKS), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->num = CLK_XVCU_NUM_CLOCKS;\n\thws = data->hws;\n\n\txvcu->clk_data = data;\n\n\thw = xvcu_register_pll(dev, reg_base,\n\t\t\t       \"vcu_pll\", __clk_get_name(xvcu->pll_ref),\n\t\t\t       CLK_SET_RATE_NO_REPARENT | CLK_OPS_PARENT_ENABLE);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\txvcu->pll = hw;\n\n\thw = xvcu_register_pll_post(dev, \"vcu_pll_post\", xvcu->pll, reg_base);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\txvcu->pll_post = hw;\n\n\tparent_data[0].fw_name = \"pll_ref\";\n\tparent_data[1].hw = xvcu->pll_post;\n\n\thws[CLK_XVCU_ENC_CORE] =\n\t\txvcu_clk_hw_register_leaf(dev, \"venc_core_clk\",\n\t\t\t\t\t  parent_data,\n\t\t\t\t\t  ARRAY_SIZE(parent_data),\n\t\t\t\t\t  reg_base + VCU_ENC_CORE_CTRL);\n\thws[CLK_XVCU_ENC_MCU] =\n\t\txvcu_clk_hw_register_leaf(dev, \"venc_mcu_clk\",\n\t\t\t\t\t  parent_data,\n\t\t\t\t\t  ARRAY_SIZE(parent_data),\n\t\t\t\t\t  reg_base + VCU_ENC_MCU_CTRL);\n\thws[CLK_XVCU_DEC_CORE] =\n\t\txvcu_clk_hw_register_leaf(dev, \"vdec_core_clk\",\n\t\t\t\t\t  parent_data,\n\t\t\t\t\t  ARRAY_SIZE(parent_data),\n\t\t\t\t\t  reg_base + VCU_DEC_CORE_CTRL);\n\thws[CLK_XVCU_DEC_MCU] =\n\t\txvcu_clk_hw_register_leaf(dev, \"vdec_mcu_clk\",\n\t\t\t\t\t  parent_data,\n\t\t\t\t\t  ARRAY_SIZE(parent_data),\n\t\t\t\t\t  reg_base + VCU_DEC_MCU_CTRL);\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, data);\n}\n\nstatic void xvcu_unregister_clock_provider(struct xvcu_device *xvcu)\n{\n\tstruct clk_hw_onecell_data *data = xvcu->clk_data;\n\tstruct clk_hw **hws = data->hws;\n\n\tif (!IS_ERR_OR_NULL(hws[CLK_XVCU_DEC_MCU]))\n\t\txvcu_clk_hw_unregister_leaf(hws[CLK_XVCU_DEC_MCU]);\n\tif (!IS_ERR_OR_NULL(hws[CLK_XVCU_DEC_CORE]))\n\t\txvcu_clk_hw_unregister_leaf(hws[CLK_XVCU_DEC_CORE]);\n\tif (!IS_ERR_OR_NULL(hws[CLK_XVCU_ENC_MCU]))\n\t\txvcu_clk_hw_unregister_leaf(hws[CLK_XVCU_ENC_MCU]);\n\tif (!IS_ERR_OR_NULL(hws[CLK_XVCU_ENC_CORE]))\n\t\txvcu_clk_hw_unregister_leaf(hws[CLK_XVCU_ENC_CORE]);\n\n\tclk_hw_unregister_fixed_factor(xvcu->pll_post);\n}\n\n \nstatic int xvcu_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct xvcu_device *xvcu;\n\tvoid __iomem *regs;\n\tint ret;\n\n\txvcu = devm_kzalloc(&pdev->dev, sizeof(*xvcu), GFP_KERNEL);\n\tif (!xvcu)\n\t\treturn -ENOMEM;\n\n\txvcu->dev = &pdev->dev;\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"vcu_slcr\");\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"get vcu_slcr memory resource failed.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\txvcu->vcu_slcr_ba = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\t resource_size(res));\n\tif (!xvcu->vcu_slcr_ba) {\n\t\tdev_err(&pdev->dev, \"vcu_slcr register mapping failed.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\txvcu->logicore_reg_ba =\n\t\tsyscon_regmap_lookup_by_compatible(\"xlnx,vcu-settings\");\n\tif (IS_ERR(xvcu->logicore_reg_ba)) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"could not find xlnx,vcu-settings: trying direct register access\\n\");\n\n\t\tres = platform_get_resource_byname(pdev,\n\t\t\t\t\t\t   IORESOURCE_MEM, \"logicore\");\n\t\tif (!res) {\n\t\t\tdev_err(&pdev->dev, \"get logicore memory resource failed.\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tregs = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\t\tif (!regs) {\n\t\t\tdev_err(&pdev->dev, \"logicore register mapping failed.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\txvcu->logicore_reg_ba =\n\t\t\tdevm_regmap_init_mmio(&pdev->dev, regs,\n\t\t\t\t\t      &vcu_settings_regmap_config);\n\t\tif (IS_ERR(xvcu->logicore_reg_ba)) {\n\t\t\tdev_err(&pdev->dev, \"failed to init regmap\\n\");\n\t\t\treturn PTR_ERR(xvcu->logicore_reg_ba);\n\t\t}\n\t}\n\n\txvcu->aclk = devm_clk_get(&pdev->dev, \"aclk\");\n\tif (IS_ERR(xvcu->aclk)) {\n\t\tdev_err(&pdev->dev, \"Could not get aclk clock\\n\");\n\t\treturn PTR_ERR(xvcu->aclk);\n\t}\n\n\txvcu->pll_ref = devm_clk_get(&pdev->dev, \"pll_ref\");\n\tif (IS_ERR(xvcu->pll_ref)) {\n\t\tdev_err(&pdev->dev, \"Could not get pll_ref clock\\n\");\n\t\treturn PTR_ERR(xvcu->pll_ref);\n\t}\n\n\tret = clk_prepare_enable(xvcu->aclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"aclk clock enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tregmap_write(xvcu->logicore_reg_ba, VCU_GASKET_INIT, VCU_GASKET_VALUE);\n\n\tret = xvcu_register_clock_provider(xvcu);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register clock provider\\n\");\n\t\tgoto error_clk_provider;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, xvcu);\n\n\treturn 0;\n\nerror_clk_provider:\n\txvcu_unregister_clock_provider(xvcu);\n\tclk_disable_unprepare(xvcu->aclk);\n\treturn ret;\n}\n\n \nstatic void xvcu_remove(struct platform_device *pdev)\n{\n\tstruct xvcu_device *xvcu;\n\n\txvcu = platform_get_drvdata(pdev);\n\n\txvcu_unregister_clock_provider(xvcu);\n\n\t \n\tregmap_write(xvcu->logicore_reg_ba, VCU_GASKET_INIT, 0);\n\n\tclk_disable_unprepare(xvcu->aclk);\n}\n\nstatic const struct of_device_id xvcu_of_id_table[] = {\n\t{ .compatible = \"xlnx,vcu\" },\n\t{ .compatible = \"xlnx,vcu-logicoreip-1.0\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, xvcu_of_id_table);\n\nstatic struct platform_driver xvcu_driver = {\n\t.driver = {\n\t\t.name           = \"xilinx-vcu\",\n\t\t.of_match_table = xvcu_of_id_table,\n\t},\n\t.probe                  = xvcu_probe,\n\t.remove_new             = xvcu_remove,\n};\n\nmodule_platform_driver(xvcu_driver);\n\nMODULE_AUTHOR(\"Dhaval Shah <dshah@xilinx.com>\");\nMODULE_DESCRIPTION(\"Xilinx VCU init Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}