{
  "module_name": "clk-axm5516.c",
  "hash_id": "50c6de733f5f55760c409b0cc7b5b31ee3a09448cd9801175b02ebe6812834dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-axm5516.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/clk-provider.h>\n#include <linux/regmap.h>\n#include <dt-bindings/clock/lsi,axm5516-clks.h>\n\n\n \nstruct axxia_clk {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n};\n#define to_axxia_clk(_hw) container_of(_hw, struct axxia_clk, hw)\n\n \nstruct axxia_pllclk {\n\tstruct axxia_clk aclk;\n\tu32 reg;\n};\n#define to_axxia_pllclk(_aclk) container_of(_aclk, struct axxia_pllclk, aclk)\n\n \nstatic unsigned long\naxxia_pllclk_recalc(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct axxia_clk *aclk = to_axxia_clk(hw);\n\tstruct axxia_pllclk *pll = to_axxia_pllclk(aclk);\n\tunsigned long rate, fbdiv, refdiv, postdiv;\n\tu32 control;\n\n\tregmap_read(aclk->regmap, pll->reg, &control);\n\tpostdiv = ((control >> 0) & 0xf) + 1;\n\tfbdiv   = ((control >> 4) & 0xfff) + 3;\n\trefdiv  = ((control >> 16) & 0x1f) + 1;\n\trate = (parent_rate / (refdiv * postdiv)) * fbdiv;\n\n\treturn rate;\n}\n\nstatic const struct clk_ops axxia_pllclk_ops = {\n\t.recalc_rate = axxia_pllclk_recalc,\n};\n\n \nstruct axxia_divclk {\n\tstruct axxia_clk aclk;\n\tu32 reg;\n\tu32 shift;\n\tu32 width;\n};\n#define to_axxia_divclk(_aclk) container_of(_aclk, struct axxia_divclk, aclk)\n\n \nstatic unsigned long\naxxia_divclk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct axxia_clk *aclk = to_axxia_clk(hw);\n\tstruct axxia_divclk *divclk = to_axxia_divclk(aclk);\n\tu32 ctrl, div;\n\n\tregmap_read(aclk->regmap, divclk->reg, &ctrl);\n\tdiv = 1 + ((ctrl >> divclk->shift) & ((1 << divclk->width)-1));\n\n\treturn parent_rate / div;\n}\n\nstatic const struct clk_ops axxia_divclk_ops = {\n\t.recalc_rate = axxia_divclk_recalc_rate,\n};\n\n \nstruct axxia_clkmux {\n\tstruct axxia_clk aclk;\n\tu32 reg;\n\tu32 shift;\n\tu32 width;\n};\n#define to_axxia_clkmux(_aclk) container_of(_aclk, struct axxia_clkmux, aclk)\n\n \nstatic u8 axxia_clkmux_get_parent(struct clk_hw *hw)\n{\n\tstruct axxia_clk *aclk = to_axxia_clk(hw);\n\tstruct axxia_clkmux *mux = to_axxia_clkmux(aclk);\n\tu32 ctrl, parent;\n\n\tregmap_read(aclk->regmap, mux->reg, &ctrl);\n\tparent = (ctrl >> mux->shift) & ((1 << mux->width) - 1);\n\n\treturn (u8) parent;\n}\n\nstatic const struct clk_ops axxia_clkmux_ops = {\n\t.get_parent = axxia_clkmux_get_parent,\n};\n\n\n \n\nstatic struct axxia_pllclk clk_fab_pll = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_fab_pll\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_ref0\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &axxia_pllclk_ops,\n\t},\n\t.reg   = 0x01800,\n};\n\nstatic struct axxia_pllclk clk_cpu_pll = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_cpu_pll\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_ref0\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &axxia_pllclk_ops,\n\t},\n\t.reg   = 0x02000,\n};\n\nstatic struct axxia_pllclk clk_sys_pll = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_sys_pll\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_ref0\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &axxia_pllclk_ops,\n\t},\n\t.reg   = 0x02800,\n};\n\nstatic struct axxia_pllclk clk_sm0_pll = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_sm0_pll\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_ref2\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &axxia_pllclk_ops,\n\t},\n\t.reg   = 0x03000,\n};\n\nstatic struct axxia_pllclk clk_sm1_pll = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_sm1_pll\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_ref1\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &axxia_pllclk_ops,\n\t},\n\t.reg   = 0x03800,\n};\n\n \n\nstatic struct axxia_divclk clk_cpu0_div = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_cpu0_div\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_cpu_pll\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &axxia_divclk_ops,\n\t},\n\t.reg   = 0x10008,\n\t.shift = 0,\n\t.width = 4,\n};\n\nstatic struct axxia_divclk clk_cpu1_div = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_cpu1_div\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_cpu_pll\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &axxia_divclk_ops,\n\t},\n\t.reg   = 0x10008,\n\t.shift = 4,\n\t.width = 4,\n};\n\nstatic struct axxia_divclk clk_cpu2_div = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_cpu2_div\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_cpu_pll\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &axxia_divclk_ops,\n\t},\n\t.reg   = 0x10008,\n\t.shift = 8,\n\t.width = 4,\n};\n\nstatic struct axxia_divclk clk_cpu3_div = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_cpu3_div\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_cpu_pll\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &axxia_divclk_ops,\n\t},\n\t.reg   = 0x10008,\n\t.shift = 12,\n\t.width = 4,\n};\n\nstatic struct axxia_divclk clk_nrcp_div = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_nrcp_div\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_sys_pll\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &axxia_divclk_ops,\n\t},\n\t.reg   = 0x1000c,\n\t.shift = 0,\n\t.width = 4,\n};\n\nstatic struct axxia_divclk clk_sys_div = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_sys_div\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_sys_pll\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &axxia_divclk_ops,\n\t},\n\t.reg   = 0x1000c,\n\t.shift = 4,\n\t.width = 4,\n};\n\nstatic struct axxia_divclk clk_fab_div = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_fab_div\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_fab_pll\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &axxia_divclk_ops,\n\t},\n\t.reg   = 0x1000c,\n\t.shift = 8,\n\t.width = 4,\n};\n\nstatic struct axxia_divclk clk_per_div = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_per_div\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_sm1_pll\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &axxia_divclk_ops,\n\t},\n\t.reg   = 0x1000c,\n\t.shift = 12,\n\t.width = 4,\n};\n\nstatic struct axxia_divclk clk_mmc_div = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_mmc_div\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_sm1_pll\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &axxia_divclk_ops,\n\t},\n\t.reg   = 0x1000c,\n\t.shift = 16,\n\t.width = 4,\n};\n\n \n\nstatic struct axxia_clkmux clk_cpu0_mux = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_cpu0\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_ref0\",\n\t\t\t\"clk_cpu_pll\",\n\t\t\t\"clk_cpu0_div\",\n\t\t\t\"clk_cpu0_div\"\n\t\t},\n\t\t.num_parents = 4,\n\t\t.ops = &axxia_clkmux_ops,\n\t},\n\t.reg   = 0x10000,\n\t.shift = 0,\n\t.width = 2,\n};\n\nstatic struct axxia_clkmux clk_cpu1_mux = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_cpu1\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_ref0\",\n\t\t\t\"clk_cpu_pll\",\n\t\t\t\"clk_cpu1_div\",\n\t\t\t\"clk_cpu1_div\"\n\t\t},\n\t\t.num_parents = 4,\n\t\t.ops = &axxia_clkmux_ops,\n\t},\n\t.reg   = 0x10000,\n\t.shift = 2,\n\t.width = 2,\n};\n\nstatic struct axxia_clkmux clk_cpu2_mux = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_cpu2\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_ref0\",\n\t\t\t\"clk_cpu_pll\",\n\t\t\t\"clk_cpu2_div\",\n\t\t\t\"clk_cpu2_div\"\n\t\t},\n\t\t.num_parents = 4,\n\t\t.ops = &axxia_clkmux_ops,\n\t},\n\t.reg   = 0x10000,\n\t.shift = 4,\n\t.width = 2,\n};\n\nstatic struct axxia_clkmux clk_cpu3_mux = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_cpu3\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_ref0\",\n\t\t\t\"clk_cpu_pll\",\n\t\t\t\"clk_cpu3_div\",\n\t\t\t\"clk_cpu3_div\"\n\t\t},\n\t\t.num_parents = 4,\n\t\t.ops = &axxia_clkmux_ops,\n\t},\n\t.reg   = 0x10000,\n\t.shift = 6,\n\t.width = 2,\n};\n\nstatic struct axxia_clkmux clk_nrcp_mux = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_nrcp\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_ref0\",\n\t\t\t\"clk_sys_pll\",\n\t\t\t\"clk_nrcp_div\",\n\t\t\t\"clk_nrcp_div\"\n\t\t},\n\t\t.num_parents = 4,\n\t\t.ops = &axxia_clkmux_ops,\n\t},\n\t.reg   = 0x10004,\n\t.shift = 0,\n\t.width = 2,\n};\n\nstatic struct axxia_clkmux clk_sys_mux = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_sys\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_ref0\",\n\t\t\t\"clk_sys_pll\",\n\t\t\t\"clk_sys_div\",\n\t\t\t\"clk_sys_div\"\n\t\t},\n\t\t.num_parents = 4,\n\t\t.ops = &axxia_clkmux_ops,\n\t},\n\t.reg   = 0x10004,\n\t.shift = 2,\n\t.width = 2,\n};\n\nstatic struct axxia_clkmux clk_fab_mux = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_fab\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_ref0\",\n\t\t\t\"clk_fab_pll\",\n\t\t\t\"clk_fab_div\",\n\t\t\t\"clk_fab_div\"\n\t\t},\n\t\t.num_parents = 4,\n\t\t.ops = &axxia_clkmux_ops,\n\t},\n\t.reg   = 0x10004,\n\t.shift = 4,\n\t.width = 2,\n};\n\nstatic struct axxia_clkmux clk_per_mux = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_per\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_ref1\",\n\t\t\t\"clk_per_div\"\n\t\t},\n\t\t.num_parents = 2,\n\t\t.ops = &axxia_clkmux_ops,\n\t},\n\t.reg   = 0x10004,\n\t.shift = 6,\n\t.width = 1,\n};\n\nstatic struct axxia_clkmux clk_mmc_mux = {\n\t.aclk.hw.init = &(struct clk_init_data){\n\t\t.name = \"clk_mmc\",\n\t\t.parent_names = (const char *[]){\n\t\t\t\"clk_ref1\",\n\t\t\t\"clk_mmc_div\"\n\t\t},\n\t\t.num_parents = 2,\n\t\t.ops = &axxia_clkmux_ops,\n\t},\n\t.reg   = 0x10004,\n\t.shift = 9,\n\t.width = 1,\n};\n\n \nstatic struct axxia_clk *axmclk_clocks[] = {\n\t[AXXIA_CLK_FAB_PLL]  = &clk_fab_pll.aclk,\n\t[AXXIA_CLK_CPU_PLL]  = &clk_cpu_pll.aclk,\n\t[AXXIA_CLK_SYS_PLL]  = &clk_sys_pll.aclk,\n\t[AXXIA_CLK_SM0_PLL]  = &clk_sm0_pll.aclk,\n\t[AXXIA_CLK_SM1_PLL]  = &clk_sm1_pll.aclk,\n\t[AXXIA_CLK_FAB_DIV]  = &clk_fab_div.aclk,\n\t[AXXIA_CLK_SYS_DIV]  = &clk_sys_div.aclk,\n\t[AXXIA_CLK_NRCP_DIV] = &clk_nrcp_div.aclk,\n\t[AXXIA_CLK_CPU0_DIV] = &clk_cpu0_div.aclk,\n\t[AXXIA_CLK_CPU1_DIV] = &clk_cpu1_div.aclk,\n\t[AXXIA_CLK_CPU2_DIV] = &clk_cpu2_div.aclk,\n\t[AXXIA_CLK_CPU3_DIV] = &clk_cpu3_div.aclk,\n\t[AXXIA_CLK_PER_DIV]  = &clk_per_div.aclk,\n\t[AXXIA_CLK_MMC_DIV]  = &clk_mmc_div.aclk,\n\t[AXXIA_CLK_FAB]      = &clk_fab_mux.aclk,\n\t[AXXIA_CLK_SYS]      = &clk_sys_mux.aclk,\n\t[AXXIA_CLK_NRCP]     = &clk_nrcp_mux.aclk,\n\t[AXXIA_CLK_CPU0]     = &clk_cpu0_mux.aclk,\n\t[AXXIA_CLK_CPU1]     = &clk_cpu1_mux.aclk,\n\t[AXXIA_CLK_CPU2]     = &clk_cpu2_mux.aclk,\n\t[AXXIA_CLK_CPU3]     = &clk_cpu3_mux.aclk,\n\t[AXXIA_CLK_PER]      = &clk_per_mux.aclk,\n\t[AXXIA_CLK_MMC]      = &clk_mmc_mux.aclk,\n};\n\nstatic struct clk_hw *\nof_clk_axmclk_get(struct of_phandle_args *clkspec, void *unused)\n{\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= ARRAY_SIZE(axmclk_clocks)) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &axmclk_clocks[idx]->hw;\n}\n\nstatic const struct regmap_config axmclk_regmap_config = {\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n\t.max_register\t= 0x1fffc,\n\t.fast_io\t= true,\n};\n\nstatic const struct of_device_id axmclk_match_table[] = {\n\t{ .compatible = \"lsi,axm5516-clks\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, axmclk_match_table);\n\nstatic int axmclk_probe(struct platform_device *pdev)\n{\n\tvoid __iomem *base;\n\tint i, ret;\n\tstruct device *dev = &pdev->dev;\n\tstruct regmap *regmap;\n\tsize_t num_clks;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio(dev, base, &axmclk_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tnum_clks = ARRAY_SIZE(axmclk_clocks);\n\tpr_info(\"axmclk: supporting %zu clocks\\n\", num_clks);\n\n\t \n\tfor (i = 0; i < num_clks; i++) {\n\t\taxmclk_clocks[i]->regmap = regmap;\n\t\tret = devm_clk_hw_register(dev, &axmclk_clocks[i]->hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_axmclk_get, NULL);\n}\n\nstatic struct platform_driver axmclk_driver = {\n\t.probe\t\t= axmclk_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"clk-axm5516\",\n\t\t.of_match_table = axmclk_match_table,\n\t},\n};\n\nstatic int __init axmclk_init(void)\n{\n\treturn platform_driver_register(&axmclk_driver);\n}\ncore_initcall(axmclk_init);\n\nstatic void __exit axmclk_exit(void)\n{\n\tplatform_driver_unregister(&axmclk_driver);\n}\nmodule_exit(axmclk_exit);\n\nMODULE_DESCRIPTION(\"AXM5516 clock driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:clk-axm5516\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}