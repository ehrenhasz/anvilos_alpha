{
  "module_name": "clk-ma35d1-pll.c",
  "hash_id": "d0947d8f04ba76db2f186c2e3ed4847e9b81e35ece16f3ee359b384710f1d60d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/nuvoton/clk-ma35d1-pll.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk-provider.h>\n#include <linux/container_of.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/units.h>\n#include <dt-bindings/clock/nuvoton,ma35d1-clk.h>\n\n#include \"clk-ma35d1.h\"\n\n \n#define PLL_FREF_MAX_FREQ\t(200 * HZ_PER_MHZ)\n#define PLL_FREF_MIN_FREQ\t(1 * HZ_PER_MHZ)\n#define PLL_FREF_M_MAX_FREQ\t(40 * HZ_PER_MHZ)\n#define PLL_FREF_M_MIN_FREQ\t(10 * HZ_PER_MHZ)\n#define PLL_FCLK_MAX_FREQ\t(2400 * HZ_PER_MHZ)\n#define PLL_FCLK_MIN_FREQ\t(600 * HZ_PER_MHZ)\n#define PLL_FCLKO_MAX_FREQ\t(2400 * HZ_PER_MHZ)\n#define PLL_FCLKO_MIN_FREQ\t(85700 * HZ_PER_KHZ)\n#define PLL_SS_RATE\t\t0x77\n#define PLL_SLOPE\t\t0x58CFA\n\n#define REG_PLL_CTL0_OFFSET\t0x0\n#define REG_PLL_CTL1_OFFSET\t0x4\n#define REG_PLL_CTL2_OFFSET\t0x8\n\n \n#define SPLL0_CTL0_FBDIV\tGENMASK(7, 0)\n#define SPLL0_CTL0_INDIV\tGENMASK(11, 8)\n#define SPLL0_CTL0_OUTDIV\tGENMASK(13, 12)\n#define SPLL0_CTL0_PD\t\tBIT(16)\n#define SPLL0_CTL0_BP\t\tBIT(17)\n\n \n#define PLL_CTL0_FBDIV\t\tGENMASK(10, 0)\n#define PLL_CTL0_INDIV\t\tGENMASK(17, 12)\n#define PLL_CTL0_MODE\t\tGENMASK(19, 18)\n#define PLL_CTL0_SSRATE\t\tGENMASK(30, 20)\n#define PLL_CTL1_PD\t\tBIT(0)\n#define PLL_CTL1_BP\t\tBIT(1)\n#define PLL_CTL1_OUTDIV\t\tGENMASK(6, 4)\n#define PLL_CTL1_FRAC\t\tGENMASK(31, 24)\n#define PLL_CTL2_SLOPE\t\tGENMASK(23, 0)\n\n#define INDIV_MIN\t\t1\n#define INDIV_MAX\t\t63\n#define FBDIV_MIN\t\t16\n#define FBDIV_MAX\t\t2047\n#define FBDIV_FRAC_MIN\t\t1600\n#define FBDIV_FRAC_MAX\t\t204700\n#define OUTDIV_MIN\t\t1\n#define OUTDIV_MAX\t\t7\n\n#define PLL_MODE_INT            0\n#define PLL_MODE_FRAC           1\n#define PLL_MODE_SS             2\n\nstruct ma35d1_clk_pll {\n\tstruct clk_hw hw;\n\tu32 id;\n\tu8 mode;\n\tvoid __iomem *ctl0_base;\n\tvoid __iomem *ctl1_base;\n\tvoid __iomem *ctl2_base;\n};\n\nstatic inline struct ma35d1_clk_pll *to_ma35d1_clk_pll(struct clk_hw *_hw)\n{\n\treturn container_of(_hw, struct ma35d1_clk_pll, hw);\n}\n\nstatic unsigned long ma35d1_calc_smic_pll_freq(u32 pll0_ctl0,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tu32 m, n, p, outdiv;\n\tu64 pll_freq;\n\n\tif (pll0_ctl0 & SPLL0_CTL0_BP)\n\t\treturn parent_rate;\n\n\tn = FIELD_GET(SPLL0_CTL0_FBDIV, pll0_ctl0);\n\tm = FIELD_GET(SPLL0_CTL0_INDIV, pll0_ctl0);\n\tp = FIELD_GET(SPLL0_CTL0_OUTDIV, pll0_ctl0);\n\toutdiv = 1 << p;\n\tpll_freq = (u64)parent_rate * n;\n\tdiv_u64(pll_freq, m * outdiv);\n\treturn pll_freq;\n}\n\nstatic unsigned long ma35d1_calc_pll_freq(u8 mode, u32 *reg_ctl, unsigned long parent_rate)\n{\n\tunsigned long pll_freq, x;\n\tu32 m, n, p;\n\n\tif (reg_ctl[1] & PLL_CTL1_BP)\n\t\treturn parent_rate;\n\n\tn = FIELD_GET(PLL_CTL0_FBDIV, reg_ctl[0]);\n\tm = FIELD_GET(PLL_CTL0_INDIV, reg_ctl[0]);\n\tp = FIELD_GET(PLL_CTL1_OUTDIV, reg_ctl[1]);\n\n\tif (mode == PLL_MODE_INT) {\n\t\tpll_freq = (u64)parent_rate * n;\n\t\tdiv_u64(pll_freq, m * p);\n\t} else {\n\t\tx = FIELD_GET(PLL_CTL1_FRAC, reg_ctl[1]);\n\t\t \n\t\tn = n * 100 + ((x * 100) / FIELD_MAX(PLL_CTL1_FRAC));\n\t\tpll_freq = div_u64(parent_rate * n, 100 * m * p);\n\t}\n\treturn pll_freq;\n}\n\nstatic int ma35d1_pll_find_closest(struct ma35d1_clk_pll *pll, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate, u32 *reg_ctl,\n\t\t\t\t   unsigned long *freq)\n{\n\tunsigned long min_diff = ULONG_MAX;\n\tint fbdiv_min, fbdiv_max;\n\tint p, m, n;\n\n\t*freq = 0;\n\tif (rate < PLL_FCLKO_MIN_FREQ || rate > PLL_FCLKO_MAX_FREQ)\n\t\treturn -EINVAL;\n\n\tif (pll->mode == PLL_MODE_INT) {\n\t\tfbdiv_min = FBDIV_MIN;\n\t\tfbdiv_max = FBDIV_MAX;\n\t} else {\n\t\tfbdiv_min = FBDIV_FRAC_MIN;\n\t\tfbdiv_max = FBDIV_FRAC_MAX;\n\t}\n\n\tfor (m = INDIV_MIN; m <= INDIV_MAX; m++) {\n\t\tfor (n = fbdiv_min; n <= fbdiv_max; n++) {\n\t\t\tfor (p = OUTDIV_MIN; p <= OUTDIV_MAX; p++) {\n\t\t\t\tunsigned long tmp, fout, fclk, diff;\n\n\t\t\t\ttmp = div_u64(parent_rate, m);\n\t\t\t\tif (tmp < PLL_FREF_M_MIN_FREQ ||\n\t\t\t\t    tmp > PLL_FREF_M_MAX_FREQ)\n\t\t\t\t\tcontinue;  \n\n\t\t\t\tfclk = div_u64(parent_rate * n, m);\n\t\t\t\t \n\t\t\t\tif (pll->mode != PLL_MODE_INT)\n\t\t\t\t\tfclk = div_u64(fclk, 100);\n\n\t\t\t\tif (fclk < PLL_FCLK_MIN_FREQ ||\n\t\t\t\t    fclk > PLL_FCLK_MAX_FREQ)\n\t\t\t\t\tcontinue;  \n\n\t\t\t\tfout = div_u64(fclk, p);\n\t\t\t\tif (fout < PLL_FCLKO_MIN_FREQ ||\n\t\t\t\t    fout > PLL_FCLKO_MAX_FREQ)\n\t\t\t\t\tcontinue;  \n\n\t\t\t\tdiff = abs(rate - fout);\n\t\t\t\tif (diff < min_diff) {\n\t\t\t\t\treg_ctl[0] = FIELD_PREP(PLL_CTL0_INDIV, m) |\n\t\t\t\t\t\t     FIELD_PREP(PLL_CTL0_FBDIV, n);\n\t\t\t\t\treg_ctl[1] = FIELD_PREP(PLL_CTL1_OUTDIV, p);\n\t\t\t\t\t*freq = fout;\n\t\t\t\t\tmin_diff = diff;\n\t\t\t\t\tif (min_diff == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (*freq == 0)\n\t\treturn -EINVAL;  \n\treturn 0;\n}\n\nstatic int ma35d1_clk_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct ma35d1_clk_pll *pll = to_ma35d1_clk_pll(hw);\n\tu32 reg_ctl[3] = { 0 };\n\tunsigned long pll_freq;\n\tint ret;\n\n\tif (parent_rate < PLL_FREF_MIN_FREQ || parent_rate > PLL_FREF_MAX_FREQ)\n\t\treturn -EINVAL;\n\n\tret = ma35d1_pll_find_closest(pll, rate, parent_rate, reg_ctl, &pll_freq);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tswitch (pll->mode) {\n\tcase PLL_MODE_INT:\n\t\treg_ctl[0] |= FIELD_PREP(PLL_CTL0_MODE, PLL_MODE_INT);\n\t\tbreak;\n\tcase PLL_MODE_FRAC:\n\t\treg_ctl[0] |= FIELD_PREP(PLL_CTL0_MODE, PLL_MODE_FRAC);\n\t\tbreak;\n\tcase PLL_MODE_SS:\n\t\treg_ctl[0] |= FIELD_PREP(PLL_CTL0_MODE, PLL_MODE_SS) |\n\t\t\t      FIELD_PREP(PLL_CTL0_SSRATE, PLL_SS_RATE);\n\t\treg_ctl[2] = FIELD_PREP(PLL_CTL2_SLOPE, PLL_SLOPE);\n\t\tbreak;\n\t}\n\treg_ctl[1] |= PLL_CTL1_PD;\n\n\twritel_relaxed(reg_ctl[0], pll->ctl0_base);\n\twritel_relaxed(reg_ctl[1], pll->ctl1_base);\n\twritel_relaxed(reg_ctl[2], pll->ctl2_base);\n\treturn 0;\n}\n\nstatic unsigned long ma35d1_clk_pll_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct ma35d1_clk_pll *pll = to_ma35d1_clk_pll(hw);\n\tu32 reg_ctl[3];\n\tunsigned long pll_freq;\n\n\tif (parent_rate < PLL_FREF_MIN_FREQ || parent_rate > PLL_FREF_MAX_FREQ)\n\t\treturn 0;\n\n\tswitch (pll->id) {\n\tcase CAPLL:\n\t\treg_ctl[0] = readl_relaxed(pll->ctl0_base);\n\t\tpll_freq = ma35d1_calc_smic_pll_freq(reg_ctl[0], parent_rate);\n\t\treturn pll_freq;\n\tcase DDRPLL:\n\tcase APLL:\n\tcase EPLL:\n\tcase VPLL:\n\t\treg_ctl[0] = readl_relaxed(pll->ctl0_base);\n\t\treg_ctl[1] = readl_relaxed(pll->ctl1_base);\n\t\tpll_freq = ma35d1_calc_pll_freq(pll->mode, reg_ctl, parent_rate);\n\t\treturn pll_freq;\n\t}\n\treturn 0;\n}\n\nstatic long ma35d1_clk_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long *parent_rate)\n{\n\tstruct ma35d1_clk_pll *pll = to_ma35d1_clk_pll(hw);\n\tu32 reg_ctl[3] = { 0 };\n\tunsigned long pll_freq;\n\tlong ret;\n\n\tif (*parent_rate < PLL_FREF_MIN_FREQ || *parent_rate > PLL_FREF_MAX_FREQ)\n\t\treturn -EINVAL;\n\n\tret = ma35d1_pll_find_closest(pll, rate, *parent_rate, reg_ctl, &pll_freq);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (pll->id) {\n\tcase CAPLL:\n\t\treg_ctl[0] = readl_relaxed(pll->ctl0_base);\n\t\tpll_freq = ma35d1_calc_smic_pll_freq(reg_ctl[0], *parent_rate);\n\t\treturn pll_freq;\n\tcase DDRPLL:\n\tcase APLL:\n\tcase EPLL:\n\tcase VPLL:\n\t\treg_ctl[0] = readl_relaxed(pll->ctl0_base);\n\t\treg_ctl[1] = readl_relaxed(pll->ctl1_base);\n\t\tpll_freq = ma35d1_calc_pll_freq(pll->mode, reg_ctl, *parent_rate);\n\t\treturn pll_freq;\n\t}\n\treturn 0;\n}\n\nstatic int ma35d1_clk_pll_is_prepared(struct clk_hw *hw)\n{\n\tstruct ma35d1_clk_pll *pll = to_ma35d1_clk_pll(hw);\n\tu32 val = readl_relaxed(pll->ctl1_base);\n\n\treturn !(val & PLL_CTL1_PD);\n}\n\nstatic int ma35d1_clk_pll_prepare(struct clk_hw *hw)\n{\n\tstruct ma35d1_clk_pll *pll = to_ma35d1_clk_pll(hw);\n\tu32 val;\n\n\tval = readl_relaxed(pll->ctl1_base);\n\tval &= ~PLL_CTL1_PD;\n\twritel_relaxed(val, pll->ctl1_base);\n\treturn 0;\n}\n\nstatic void ma35d1_clk_pll_unprepare(struct clk_hw *hw)\n{\n\tstruct ma35d1_clk_pll *pll = to_ma35d1_clk_pll(hw);\n\tu32 val;\n\n\tval = readl_relaxed(pll->ctl1_base);\n\tval |= PLL_CTL1_PD;\n\twritel_relaxed(val, pll->ctl1_base);\n}\n\nstatic const struct clk_ops ma35d1_clk_pll_ops = {\n\t.is_prepared = ma35d1_clk_pll_is_prepared,\n\t.prepare = ma35d1_clk_pll_prepare,\n\t.unprepare = ma35d1_clk_pll_unprepare,\n\t.set_rate = ma35d1_clk_pll_set_rate,\n\t.recalc_rate = ma35d1_clk_pll_recalc_rate,\n\t.round_rate = ma35d1_clk_pll_round_rate,\n};\n\nstatic const struct clk_ops ma35d1_clk_fixed_pll_ops = {\n\t.recalc_rate = ma35d1_clk_pll_recalc_rate,\n\t.round_rate = ma35d1_clk_pll_round_rate,\n};\n\nstruct clk_hw *ma35d1_reg_clk_pll(struct device *dev, u32 id, u8 u8mode, const char *name,\n\t\t\t\t  struct clk_hw *parent_hw, void __iomem *base)\n{\n\tstruct clk_parent_data pdata = { .index = 0 };\n\tstruct clk_init_data init = {};\n\tstruct ma35d1_clk_pll *pll;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tpll = devm_kzalloc(dev, sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpll->id = id;\n\tpll->mode = u8mode;\n\tpll->ctl0_base = base + REG_PLL_CTL0_OFFSET;\n\tpll->ctl1_base = base + REG_PLL_CTL1_OFFSET;\n\tpll->ctl2_base = base + REG_PLL_CTL2_OFFSET;\n\n\tinit.name = name;\n\tinit.flags = 0;\n\tpdata.hw = parent_hw;\n\tinit.parent_data = &pdata;\n\tinit.num_parents = 1;\n\n\tif (id == CAPLL || id == DDRPLL)\n\t\tinit.ops = &ma35d1_clk_fixed_pll_ops;\n\telse\n\t\tinit.ops = &ma35d1_clk_pll_ops;\n\n\tpll->hw.init = &init;\n\thw = &pll->hw;\n\n\tret = devm_clk_hw_register(dev, hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(ma35d1_reg_clk_pll);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}