{
  "module_name": "clk-ma35d1-divider.c",
  "hash_id": "40993c3baa2ba957bd288715f5c3f807ecddf83327a810a38427c5065aefd047",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/nuvoton/clk-ma35d1-divider.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/regmap.h>\n#include <linux/spinlock.h>\n\n#include \"clk-ma35d1.h\"\n\nstruct ma35d1_adc_clk_div {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n\tu8 shift;\n\tu8 width;\n\tu32 mask;\n\tconst struct clk_div_table *table;\n\t \n\tspinlock_t *lock;\n};\n\nstatic inline struct ma35d1_adc_clk_div *to_ma35d1_adc_clk_div(struct clk_hw *_hw)\n{\n\treturn container_of(_hw, struct ma35d1_adc_clk_div, hw);\n}\n\nstatic unsigned long ma35d1_clkdiv_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tunsigned int val;\n\tstruct ma35d1_adc_clk_div *dclk = to_ma35d1_adc_clk_div(hw);\n\n\tval = readl_relaxed(dclk->reg) >> dclk->shift;\n\tval &= clk_div_mask(dclk->width);\n\tval += 1;\n\treturn divider_recalc_rate(hw, parent_rate, val, dclk->table,\n\t\t\t\t   CLK_DIVIDER_ROUND_CLOSEST, dclk->width);\n}\n\nstatic long ma35d1_clkdiv_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *prate)\n{\n\tstruct ma35d1_adc_clk_div *dclk = to_ma35d1_adc_clk_div(hw);\n\n\treturn divider_round_rate(hw, rate, prate, dclk->table,\n\t\t\t\t  dclk->width, CLK_DIVIDER_ROUND_CLOSEST);\n}\n\nstatic int ma35d1_clkdiv_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate)\n{\n\tint value;\n\tunsigned long flags = 0;\n\tu32 data;\n\tstruct ma35d1_adc_clk_div *dclk = to_ma35d1_adc_clk_div(hw);\n\n\tvalue = divider_get_val(rate, parent_rate, dclk->table,\n\t\t\t\tdclk->width, CLK_DIVIDER_ROUND_CLOSEST);\n\n\tspin_lock_irqsave(dclk->lock, flags);\n\n\tdata = readl_relaxed(dclk->reg);\n\tdata &= ~(clk_div_mask(dclk->width) << dclk->shift);\n\tdata |= (value - 1) << dclk->shift;\n\tdata |= dclk->mask;\n\twritel_relaxed(data, dclk->reg);\n\n\tspin_unlock_irqrestore(dclk->lock, flags);\n\treturn 0;\n}\n\nstatic const struct clk_ops ma35d1_adc_clkdiv_ops = {\n\t.recalc_rate = ma35d1_clkdiv_recalc_rate,\n\t.round_rate = ma35d1_clkdiv_round_rate,\n\t.set_rate = ma35d1_clkdiv_set_rate,\n};\n\nstruct clk_hw *ma35d1_reg_adc_clkdiv(struct device *dev, const char *name,\n\t\t\t\t     struct clk_hw *parent_hw, spinlock_t *lock,\n\t\t\t\t     unsigned long flags, void __iomem *reg,\n\t\t\t\t     u8 shift, u8 width, u32 mask_bit)\n{\n\tstruct ma35d1_adc_clk_div *div;\n\tstruct clk_init_data init;\n\tstruct clk_div_table *table;\n\tstruct clk_parent_data pdata = { .index = 0 };\n\tu32 max_div, min_div;\n\tstruct clk_hw *hw;\n\tint ret;\n\tint i;\n\n\tdiv = devm_kzalloc(dev, sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmax_div = clk_div_mask(width) + 1;\n\tmin_div = 1;\n\n\ttable = devm_kcalloc(dev, max_div + 1, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < max_div; i++) {\n\t\ttable[i].val = min_div + i;\n\t\ttable[i].div = 2 * table[i].val;\n\t}\n\ttable[max_div].val = 0;\n\ttable[max_div].div = 0;\n\n\tmemset(&init, 0, sizeof(init));\n\tinit.name = name;\n\tinit.ops = &ma35d1_adc_clkdiv_ops;\n\tinit.flags |= flags;\n\tpdata.hw = parent_hw;\n\tinit.parent_data = &pdata;\n\tinit.num_parents = 1;\n\n\tdiv->reg = reg;\n\tdiv->shift = shift;\n\tdiv->width = width;\n\tdiv->mask = mask_bit ? BIT(mask_bit) : 0;\n\tdiv->lock = lock;\n\tdiv->hw.init = &init;\n\tdiv->table = table;\n\n\thw = &div->hw;\n\tret = devm_clk_hw_register(dev, hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(ma35d1_reg_adc_clkdiv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}