{
  "module_name": "clk.c",
  "hash_id": "22e6112e9beefe25f77de87a701056147e84d7df2bf97bcfe88843c1244f8063",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/pistachio/clk.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\nstruct pistachio_clk_provider *\npistachio_clk_alloc_provider(struct device_node *node, unsigned int num_clks)\n{\n\tstruct pistachio_clk_provider *p;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn p;\n\n\tp->clk_data.clks = kcalloc(num_clks, sizeof(struct clk *), GFP_KERNEL);\n\tif (!p->clk_data.clks)\n\t\tgoto free_provider;\n\tp->clk_data.clk_num = num_clks;\n\tp->node = node;\n\tp->base = of_iomap(node, 0);\n\tif (!p->base) {\n\t\tpr_err(\"Failed to map clock provider registers\\n\");\n\t\tgoto free_clks;\n\t}\n\n\treturn p;\n\nfree_clks:\n\tkfree(p->clk_data.clks);\nfree_provider:\n\tkfree(p);\n\treturn NULL;\n}\n\nvoid pistachio_clk_register_provider(struct pistachio_clk_provider *p)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < p->clk_data.clk_num; i++) {\n\t\tif (IS_ERR(p->clk_data.clks[i]))\n\t\t\tpr_warn(\"Failed to register clock %d: %ld\\n\", i,\n\t\t\t\tPTR_ERR(p->clk_data.clks[i]));\n\t}\n\n\tof_clk_add_provider(p->node, of_clk_src_onecell_get, &p->clk_data);\n}\n\nvoid pistachio_clk_register_gate(struct pistachio_clk_provider *p,\n\t\t\t\t struct pistachio_gate *gate,\n\t\t\t\t unsigned int num)\n{\n\tstruct clk *clk;\n\tunsigned int i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tclk = clk_register_gate(NULL, gate[i].name, gate[i].parent,\n\t\t\t\t\tCLK_SET_RATE_PARENT,\n\t\t\t\t\tp->base + gate[i].reg, gate[i].shift,\n\t\t\t\t\t0, NULL);\n\t\tp->clk_data.clks[gate[i].id] = clk;\n\t}\n}\n\nvoid pistachio_clk_register_mux(struct pistachio_clk_provider *p,\n\t\t\t\tstruct pistachio_mux *mux,\n\t\t\t\tunsigned int num)\n{\n\tstruct clk *clk;\n\tunsigned int i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tclk = clk_register_mux(NULL, mux[i].name, mux[i].parents,\n\t\t\t\t       mux[i].num_parents,\n\t\t\t\t       CLK_SET_RATE_NO_REPARENT,\n\t\t\t\t       p->base + mux[i].reg, mux[i].shift,\n\t\t\t\t       get_count_order(mux[i].num_parents),\n\t\t\t\t       0, NULL);\n\t\tp->clk_data.clks[mux[i].id] = clk;\n\t}\n}\n\nvoid pistachio_clk_register_div(struct pistachio_clk_provider *p,\n\t\t\t\tstruct pistachio_div *div,\n\t\t\t\tunsigned int num)\n{\n\tstruct clk *clk;\n\tunsigned int i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tclk = clk_register_divider(NULL, div[i].name, div[i].parent,\n\t\t\t\t\t   0, p->base + div[i].reg, 0,\n\t\t\t\t\t   div[i].width, div[i].div_flags,\n\t\t\t\t\t   NULL);\n\t\tp->clk_data.clks[div[i].id] = clk;\n\t}\n}\n\nvoid pistachio_clk_register_fixed_factor(struct pistachio_clk_provider *p,\n\t\t\t\t\t struct pistachio_fixed_factor *ff,\n\t\t\t\t\t unsigned int num)\n{\n\tstruct clk *clk;\n\tunsigned int i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tclk = clk_register_fixed_factor(NULL, ff[i].name, ff[i].parent,\n\t\t\t\t\t\t0, 1, ff[i].div);\n\t\tp->clk_data.clks[ff[i].id] = clk;\n\t}\n}\n\nvoid pistachio_clk_force_enable(struct pistachio_clk_provider *p,\n\t\t\t\tunsigned int *clk_ids, unsigned int num)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct clk *clk = p->clk_data.clks[clk_ids[i]];\n\n\t\tif (IS_ERR(clk))\n\t\t\tcontinue;\n\n\t\terr = clk_prepare_enable(clk);\n\t\tif (err)\n\t\t\tpr_err(\"Failed to enable clock %s: %d\\n\",\n\t\t\t       __clk_get_name(clk), err);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}