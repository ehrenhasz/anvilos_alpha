{
  "module_name": "clk-pll.c",
  "hash_id": "d83cfb7de5b3ef583af26e068fe6bf6dbae787d286916221fdab9052494a3050",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/pistachio/clk-pll.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\n#define PLL_STATUS\t\t\t0x0\n#define PLL_STATUS_LOCK\t\t\tBIT(0)\n\n#define PLL_CTRL1\t\t\t0x4\n#define PLL_CTRL1_REFDIV_SHIFT\t\t0\n#define PLL_CTRL1_REFDIV_MASK\t\t0x3f\n#define PLL_CTRL1_FBDIV_SHIFT\t\t6\n#define PLL_CTRL1_FBDIV_MASK\t\t0xfff\n#define PLL_INT_CTRL1_POSTDIV1_SHIFT\t18\n#define PLL_INT_CTRL1_POSTDIV1_MASK\t0x7\n#define PLL_INT_CTRL1_POSTDIV2_SHIFT\t21\n#define PLL_INT_CTRL1_POSTDIV2_MASK\t0x7\n#define PLL_INT_CTRL1_PD\t\tBIT(24)\n#define PLL_INT_CTRL1_DSMPD\t\tBIT(25)\n#define PLL_INT_CTRL1_FOUTPOSTDIVPD\tBIT(26)\n#define PLL_INT_CTRL1_FOUTVCOPD\t\tBIT(27)\n\n#define PLL_CTRL2\t\t\t0x8\n#define PLL_FRAC_CTRL2_FRAC_SHIFT\t0\n#define PLL_FRAC_CTRL2_FRAC_MASK\t0xffffff\n#define PLL_FRAC_CTRL2_POSTDIV1_SHIFT\t24\n#define PLL_FRAC_CTRL2_POSTDIV1_MASK\t0x7\n#define PLL_FRAC_CTRL2_POSTDIV2_SHIFT\t27\n#define PLL_FRAC_CTRL2_POSTDIV2_MASK\t0x7\n#define PLL_INT_CTRL2_BYPASS\t\tBIT(28)\n\n#define PLL_CTRL3\t\t\t0xc\n#define PLL_FRAC_CTRL3_PD\t\tBIT(0)\n#define PLL_FRAC_CTRL3_DACPD\t\tBIT(1)\n#define PLL_FRAC_CTRL3_DSMPD\t\tBIT(2)\n#define PLL_FRAC_CTRL3_FOUTPOSTDIVPD\tBIT(3)\n#define PLL_FRAC_CTRL3_FOUT4PHASEPD\tBIT(4)\n#define PLL_FRAC_CTRL3_FOUTVCOPD\tBIT(5)\n\n#define PLL_CTRL4\t\t\t0x10\n#define PLL_FRAC_CTRL4_BYPASS\t\tBIT(28)\n\n#define MIN_PFD\t\t\t\t9600000UL\n#define MIN_VCO_LA\t\t\t400000000UL\n#define MAX_VCO_LA\t\t\t1600000000UL\n#define MIN_VCO_FRAC_INT\t\t600000000UL\n#define MAX_VCO_FRAC_INT\t\t1600000000UL\n#define MIN_VCO_FRAC_FRAC\t\t600000000UL\n#define MAX_VCO_FRAC_FRAC\t\t2400000000UL\n#define MIN_OUTPUT_LA\t\t\t8000000UL\n#define MAX_OUTPUT_LA\t\t\t1600000000UL\n#define MIN_OUTPUT_FRAC\t\t\t12000000UL\n#define MAX_OUTPUT_FRAC\t\t\t1600000000UL\n\n \nenum pll_mode {\n\tPLL_MODE_FRAC,\n\tPLL_MODE_INT,\n};\n\nstruct pistachio_clk_pll {\n\tstruct clk_hw hw;\n\tvoid __iomem *base;\n\tstruct pistachio_pll_rate_table *rates;\n\tunsigned int nr_rates;\n};\n\nstatic inline u32 pll_readl(struct pistachio_clk_pll *pll, u32 reg)\n{\n\treturn readl(pll->base + reg);\n}\n\nstatic inline void pll_writel(struct pistachio_clk_pll *pll, u32 val, u32 reg)\n{\n\twritel(val, pll->base + reg);\n}\n\nstatic inline void pll_lock(struct pistachio_clk_pll *pll)\n{\n\twhile (!(pll_readl(pll, PLL_STATUS) & PLL_STATUS_LOCK))\n\t\tcpu_relax();\n}\n\nstatic inline u64 do_div_round_closest(u64 dividend, u64 divisor)\n{\n\tdividend += divisor / 2;\n\treturn div64_u64(dividend, divisor);\n}\n\nstatic inline struct pistachio_clk_pll *to_pistachio_pll(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct pistachio_clk_pll, hw);\n}\n\nstatic inline enum pll_mode pll_frac_get_mode(struct clk_hw *hw)\n{\n\tstruct pistachio_clk_pll *pll = to_pistachio_pll(hw);\n\tu32 val;\n\n\tval = pll_readl(pll, PLL_CTRL3) & PLL_FRAC_CTRL3_DSMPD;\n\treturn val ? PLL_MODE_INT : PLL_MODE_FRAC;\n}\n\nstatic inline void pll_frac_set_mode(struct clk_hw *hw, enum pll_mode mode)\n{\n\tstruct pistachio_clk_pll *pll = to_pistachio_pll(hw);\n\tu32 val;\n\n\tval = pll_readl(pll, PLL_CTRL3);\n\tif (mode == PLL_MODE_INT)\n\t\tval |= PLL_FRAC_CTRL3_DSMPD | PLL_FRAC_CTRL3_DACPD;\n\telse\n\t\tval &= ~(PLL_FRAC_CTRL3_DSMPD | PLL_FRAC_CTRL3_DACPD);\n\n\tpll_writel(pll, val, PLL_CTRL3);\n}\n\nstatic struct pistachio_pll_rate_table *\npll_get_params(struct pistachio_clk_pll *pll, unsigned long fref,\n\t       unsigned long fout)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pll->nr_rates; i++) {\n\t\tif (pll->rates[i].fref == fref && pll->rates[i].fout == fout)\n\t\t\treturn &pll->rates[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic long pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t   unsigned long *parent_rate)\n{\n\tstruct pistachio_clk_pll *pll = to_pistachio_pll(hw);\n\tunsigned int i;\n\n\tfor (i = 0; i < pll->nr_rates; i++) {\n\t\tif (i > 0 && pll->rates[i].fref == *parent_rate &&\n\t\t    pll->rates[i].fout <= rate)\n\t\t\treturn pll->rates[i - 1].fout;\n\t}\n\n\treturn pll->rates[0].fout;\n}\n\nstatic int pll_gf40lp_frac_enable(struct clk_hw *hw)\n{\n\tstruct pistachio_clk_pll *pll = to_pistachio_pll(hw);\n\tu32 val;\n\n\tval = pll_readl(pll, PLL_CTRL3);\n\tval &= ~(PLL_FRAC_CTRL3_PD | PLL_FRAC_CTRL3_FOUTPOSTDIVPD |\n\t\t PLL_FRAC_CTRL3_FOUT4PHASEPD | PLL_FRAC_CTRL3_FOUTVCOPD);\n\tpll_writel(pll, val, PLL_CTRL3);\n\n\tval = pll_readl(pll, PLL_CTRL4);\n\tval &= ~PLL_FRAC_CTRL4_BYPASS;\n\tpll_writel(pll, val, PLL_CTRL4);\n\n\tpll_lock(pll);\n\n\treturn 0;\n}\n\nstatic void pll_gf40lp_frac_disable(struct clk_hw *hw)\n{\n\tstruct pistachio_clk_pll *pll = to_pistachio_pll(hw);\n\tu32 val;\n\n\tval = pll_readl(pll, PLL_CTRL3);\n\tval |= PLL_FRAC_CTRL3_PD;\n\tpll_writel(pll, val, PLL_CTRL3);\n}\n\nstatic int pll_gf40lp_frac_is_enabled(struct clk_hw *hw)\n{\n\tstruct pistachio_clk_pll *pll = to_pistachio_pll(hw);\n\n\treturn !(pll_readl(pll, PLL_CTRL3) & PLL_FRAC_CTRL3_PD);\n}\n\nstatic int pll_gf40lp_frac_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct pistachio_clk_pll *pll = to_pistachio_pll(hw);\n\tstruct pistachio_pll_rate_table *params;\n\tint enabled = pll_gf40lp_frac_is_enabled(hw);\n\tu64 val, vco, old_postdiv1, old_postdiv2;\n\tconst char *name = clk_hw_get_name(hw);\n\n\tif (rate < MIN_OUTPUT_FRAC || rate > MAX_OUTPUT_FRAC)\n\t\treturn -EINVAL;\n\n\tparams = pll_get_params(pll, parent_rate, rate);\n\tif (!params || !params->refdiv)\n\t\treturn -EINVAL;\n\n\t \n\tvco = params->fref;\n\tvco *= (params->fbdiv << 24) + params->frac;\n\tvco = div64_u64(vco, params->refdiv << 24);\n\n\tif (vco < MIN_VCO_FRAC_FRAC || vco > MAX_VCO_FRAC_FRAC)\n\t\tpr_warn(\"%s: VCO %llu is out of range %lu..%lu\\n\", name, vco,\n\t\t\tMIN_VCO_FRAC_FRAC, MAX_VCO_FRAC_FRAC);\n\n\tval = div64_u64(params->fref, params->refdiv);\n\tif (val < MIN_PFD)\n\t\tpr_warn(\"%s: PFD %llu is too low (min %lu)\\n\",\n\t\t\tname, val, MIN_PFD);\n\tif (val > vco / 16)\n\t\tpr_warn(\"%s: PFD %llu is too high (max %llu)\\n\",\n\t\t\tname, val, vco / 16);\n\n\tval = pll_readl(pll, PLL_CTRL1);\n\tval &= ~((PLL_CTRL1_REFDIV_MASK << PLL_CTRL1_REFDIV_SHIFT) |\n\t\t (PLL_CTRL1_FBDIV_MASK << PLL_CTRL1_FBDIV_SHIFT));\n\tval |= (params->refdiv << PLL_CTRL1_REFDIV_SHIFT) |\n\t\t(params->fbdiv << PLL_CTRL1_FBDIV_SHIFT);\n\tpll_writel(pll, val, PLL_CTRL1);\n\n\tval = pll_readl(pll, PLL_CTRL2);\n\n\told_postdiv1 = (val >> PLL_FRAC_CTRL2_POSTDIV1_SHIFT) &\n\t\t       PLL_FRAC_CTRL2_POSTDIV1_MASK;\n\told_postdiv2 = (val >> PLL_FRAC_CTRL2_POSTDIV2_SHIFT) &\n\t\t       PLL_FRAC_CTRL2_POSTDIV2_MASK;\n\tif (enabled &&\n\t    (params->postdiv1 != old_postdiv1 ||\n\t     params->postdiv2 != old_postdiv2))\n\t\tpr_warn(\"%s: changing postdiv while PLL is enabled\\n\", name);\n\n\tif (params->postdiv2 > params->postdiv1)\n\t\tpr_warn(\"%s: postdiv2 should not exceed postdiv1\\n\", name);\n\n\tval &= ~((PLL_FRAC_CTRL2_FRAC_MASK << PLL_FRAC_CTRL2_FRAC_SHIFT) |\n\t\t (PLL_FRAC_CTRL2_POSTDIV1_MASK <<\n\t\t  PLL_FRAC_CTRL2_POSTDIV1_SHIFT) |\n\t\t (PLL_FRAC_CTRL2_POSTDIV2_MASK <<\n\t\t  PLL_FRAC_CTRL2_POSTDIV2_SHIFT));\n\tval |= (params->frac << PLL_FRAC_CTRL2_FRAC_SHIFT) |\n\t\t(params->postdiv1 << PLL_FRAC_CTRL2_POSTDIV1_SHIFT) |\n\t\t(params->postdiv2 << PLL_FRAC_CTRL2_POSTDIV2_SHIFT);\n\tpll_writel(pll, val, PLL_CTRL2);\n\n\t \n\tif (params->frac)\n\t\tpll_frac_set_mode(hw, PLL_MODE_FRAC);\n\telse\n\t\tpll_frac_set_mode(hw, PLL_MODE_INT);\n\n\tif (enabled)\n\t\tpll_lock(pll);\n\n\treturn 0;\n}\n\nstatic unsigned long pll_gf40lp_frac_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct pistachio_clk_pll *pll = to_pistachio_pll(hw);\n\tu64 val, prediv, fbdiv, frac, postdiv1, postdiv2, rate;\n\n\tval = pll_readl(pll, PLL_CTRL1);\n\tprediv = (val >> PLL_CTRL1_REFDIV_SHIFT) & PLL_CTRL1_REFDIV_MASK;\n\tfbdiv = (val >> PLL_CTRL1_FBDIV_SHIFT) & PLL_CTRL1_FBDIV_MASK;\n\n\tval = pll_readl(pll, PLL_CTRL2);\n\tpostdiv1 = (val >> PLL_FRAC_CTRL2_POSTDIV1_SHIFT) &\n\t\tPLL_FRAC_CTRL2_POSTDIV1_MASK;\n\tpostdiv2 = (val >> PLL_FRAC_CTRL2_POSTDIV2_SHIFT) &\n\t\tPLL_FRAC_CTRL2_POSTDIV2_MASK;\n\tfrac = (val >> PLL_FRAC_CTRL2_FRAC_SHIFT) & PLL_FRAC_CTRL2_FRAC_MASK;\n\n\t \n\trate = parent_rate;\n\tif (pll_frac_get_mode(hw) == PLL_MODE_FRAC)\n\t\trate *= (fbdiv << 24) + frac;\n\telse\n\t\trate *= (fbdiv << 24);\n\n\trate = do_div_round_closest(rate, (prediv * postdiv1 * postdiv2) << 24);\n\n\treturn rate;\n}\n\nstatic const struct clk_ops pll_gf40lp_frac_ops = {\n\t.enable = pll_gf40lp_frac_enable,\n\t.disable = pll_gf40lp_frac_disable,\n\t.is_enabled = pll_gf40lp_frac_is_enabled,\n\t.recalc_rate = pll_gf40lp_frac_recalc_rate,\n\t.round_rate = pll_round_rate,\n\t.set_rate = pll_gf40lp_frac_set_rate,\n};\n\nstatic const struct clk_ops pll_gf40lp_frac_fixed_ops = {\n\t.enable = pll_gf40lp_frac_enable,\n\t.disable = pll_gf40lp_frac_disable,\n\t.is_enabled = pll_gf40lp_frac_is_enabled,\n\t.recalc_rate = pll_gf40lp_frac_recalc_rate,\n};\n\nstatic int pll_gf40lp_laint_enable(struct clk_hw *hw)\n{\n\tstruct pistachio_clk_pll *pll = to_pistachio_pll(hw);\n\tu32 val;\n\n\tval = pll_readl(pll, PLL_CTRL1);\n\tval &= ~(PLL_INT_CTRL1_PD |\n\t\t PLL_INT_CTRL1_FOUTPOSTDIVPD | PLL_INT_CTRL1_FOUTVCOPD);\n\tpll_writel(pll, val, PLL_CTRL1);\n\n\tval = pll_readl(pll, PLL_CTRL2);\n\tval &= ~PLL_INT_CTRL2_BYPASS;\n\tpll_writel(pll, val, PLL_CTRL2);\n\n\tpll_lock(pll);\n\n\treturn 0;\n}\n\nstatic void pll_gf40lp_laint_disable(struct clk_hw *hw)\n{\n\tstruct pistachio_clk_pll *pll = to_pistachio_pll(hw);\n\tu32 val;\n\n\tval = pll_readl(pll, PLL_CTRL1);\n\tval |= PLL_INT_CTRL1_PD;\n\tpll_writel(pll, val, PLL_CTRL1);\n}\n\nstatic int pll_gf40lp_laint_is_enabled(struct clk_hw *hw)\n{\n\tstruct pistachio_clk_pll *pll = to_pistachio_pll(hw);\n\n\treturn !(pll_readl(pll, PLL_CTRL1) & PLL_INT_CTRL1_PD);\n}\n\nstatic int pll_gf40lp_laint_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct pistachio_clk_pll *pll = to_pistachio_pll(hw);\n\tstruct pistachio_pll_rate_table *params;\n\tint enabled = pll_gf40lp_laint_is_enabled(hw);\n\tu32 val, vco, old_postdiv1, old_postdiv2;\n\tconst char *name = clk_hw_get_name(hw);\n\n\tif (rate < MIN_OUTPUT_LA || rate > MAX_OUTPUT_LA)\n\t\treturn -EINVAL;\n\n\tparams = pll_get_params(pll, parent_rate, rate);\n\tif (!params || !params->refdiv)\n\t\treturn -EINVAL;\n\n\tvco = div_u64(params->fref * params->fbdiv, params->refdiv);\n\tif (vco < MIN_VCO_LA || vco > MAX_VCO_LA)\n\t\tpr_warn(\"%s: VCO %u is out of range %lu..%lu\\n\", name, vco,\n\t\t\tMIN_VCO_LA, MAX_VCO_LA);\n\n\tval = div_u64(params->fref, params->refdiv);\n\tif (val < MIN_PFD)\n\t\tpr_warn(\"%s: PFD %u is too low (min %lu)\\n\",\n\t\t\tname, val, MIN_PFD);\n\tif (val > vco / 16)\n\t\tpr_warn(\"%s: PFD %u is too high (max %u)\\n\",\n\t\t\tname, val, vco / 16);\n\n\tval = pll_readl(pll, PLL_CTRL1);\n\n\told_postdiv1 = (val >> PLL_INT_CTRL1_POSTDIV1_SHIFT) &\n\t\t       PLL_INT_CTRL1_POSTDIV1_MASK;\n\told_postdiv2 = (val >> PLL_INT_CTRL1_POSTDIV2_SHIFT) &\n\t\t       PLL_INT_CTRL1_POSTDIV2_MASK;\n\tif (enabled &&\n\t    (params->postdiv1 != old_postdiv1 ||\n\t     params->postdiv2 != old_postdiv2))\n\t\tpr_warn(\"%s: changing postdiv while PLL is enabled\\n\", name);\n\n\tif (params->postdiv2 > params->postdiv1)\n\t\tpr_warn(\"%s: postdiv2 should not exceed postdiv1\\n\", name);\n\n\tval &= ~((PLL_CTRL1_REFDIV_MASK << PLL_CTRL1_REFDIV_SHIFT) |\n\t\t (PLL_CTRL1_FBDIV_MASK << PLL_CTRL1_FBDIV_SHIFT) |\n\t\t (PLL_INT_CTRL1_POSTDIV1_MASK << PLL_INT_CTRL1_POSTDIV1_SHIFT) |\n\t\t (PLL_INT_CTRL1_POSTDIV2_MASK << PLL_INT_CTRL1_POSTDIV2_SHIFT));\n\tval |= (params->refdiv << PLL_CTRL1_REFDIV_SHIFT) |\n\t\t(params->fbdiv << PLL_CTRL1_FBDIV_SHIFT) |\n\t\t(params->postdiv1 << PLL_INT_CTRL1_POSTDIV1_SHIFT) |\n\t\t(params->postdiv2 << PLL_INT_CTRL1_POSTDIV2_SHIFT);\n\tpll_writel(pll, val, PLL_CTRL1);\n\n\tif (enabled)\n\t\tpll_lock(pll);\n\n\treturn 0;\n}\n\nstatic unsigned long pll_gf40lp_laint_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct pistachio_clk_pll *pll = to_pistachio_pll(hw);\n\tu32 val, prediv, fbdiv, postdiv1, postdiv2;\n\tu64 rate = parent_rate;\n\n\tval = pll_readl(pll, PLL_CTRL1);\n\tprediv = (val >> PLL_CTRL1_REFDIV_SHIFT) & PLL_CTRL1_REFDIV_MASK;\n\tfbdiv = (val >> PLL_CTRL1_FBDIV_SHIFT) & PLL_CTRL1_FBDIV_MASK;\n\tpostdiv1 = (val >> PLL_INT_CTRL1_POSTDIV1_SHIFT) &\n\t\tPLL_INT_CTRL1_POSTDIV1_MASK;\n\tpostdiv2 = (val >> PLL_INT_CTRL1_POSTDIV2_SHIFT) &\n\t\tPLL_INT_CTRL1_POSTDIV2_MASK;\n\n\trate *= fbdiv;\n\trate = do_div_round_closest(rate, prediv * postdiv1 * postdiv2);\n\n\treturn rate;\n}\n\nstatic const struct clk_ops pll_gf40lp_laint_ops = {\n\t.enable = pll_gf40lp_laint_enable,\n\t.disable = pll_gf40lp_laint_disable,\n\t.is_enabled = pll_gf40lp_laint_is_enabled,\n\t.recalc_rate = pll_gf40lp_laint_recalc_rate,\n\t.round_rate = pll_round_rate,\n\t.set_rate = pll_gf40lp_laint_set_rate,\n};\n\nstatic const struct clk_ops pll_gf40lp_laint_fixed_ops = {\n\t.enable = pll_gf40lp_laint_enable,\n\t.disable = pll_gf40lp_laint_disable,\n\t.is_enabled = pll_gf40lp_laint_is_enabled,\n\t.recalc_rate = pll_gf40lp_laint_recalc_rate,\n};\n\nstatic struct clk *pll_register(const char *name, const char *parent_name,\n\t\t\t\tunsigned long flags, void __iomem *base,\n\t\t\t\tenum pistachio_pll_type type,\n\t\t\t\tstruct pistachio_pll_rate_table *rates,\n\t\t\t\tunsigned int nr_rates)\n{\n\tstruct pistachio_clk_pll *pll;\n\tstruct clk_init_data init;\n\tstruct clk *clk;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.flags = flags | CLK_GET_RATE_NOCACHE;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tswitch (type) {\n\tcase PLL_GF40LP_FRAC:\n\t\tif (rates)\n\t\t\tinit.ops = &pll_gf40lp_frac_ops;\n\t\telse\n\t\t\tinit.ops = &pll_gf40lp_frac_fixed_ops;\n\t\tbreak;\n\tcase PLL_GF40LP_LAINT:\n\t\tif (rates)\n\t\t\tinit.ops = &pll_gf40lp_laint_ops;\n\t\telse\n\t\t\tinit.ops = &pll_gf40lp_laint_fixed_ops;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unrecognized PLL type %u\\n\", type);\n\t\tkfree(pll);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpll->hw.init = &init;\n\tpll->base = base;\n\tpll->rates = rates;\n\tpll->nr_rates = nr_rates;\n\n\tclk = clk_register(NULL, &pll->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\nvoid pistachio_clk_register_pll(struct pistachio_clk_provider *p,\n\t\t\t\tstruct pistachio_pll *pll,\n\t\t\t\tunsigned int num)\n{\n\tstruct clk *clk;\n\tunsigned int i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tclk = pll_register(pll[i].name, pll[i].parent,\n\t\t\t\t   0, p->base + pll[i].reg_base,\n\t\t\t\t   pll[i].type, pll[i].rates,\n\t\t\t\t   pll[i].nr_rates);\n\t\tp->clk_data.clks[pll[i].id] = clk;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}