{
  "module_name": "clk-pll.c",
  "hash_id": "9e6f157812f531557a8fbd3c2be20e650d20f955afb1d79cca95e84de893461e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/rockchip/clk-pll.c",
  "human_readable_source": "\n \n\n#include <asm/div64.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/clk-provider.h>\n#include <linux/iopoll.h>\n#include <linux/regmap.h>\n#include <linux/clk.h>\n#include \"clk.h\"\n\n#define PLL_MODE_MASK\t\t0x3\n#define PLL_MODE_SLOW\t\t0x0\n#define PLL_MODE_NORM\t\t0x1\n#define PLL_MODE_DEEP\t\t0x2\n#define PLL_RK3328_MODE_MASK\t0x1\n\nstruct rockchip_clk_pll {\n\tstruct clk_hw\t\thw;\n\n\tstruct clk_mux\t\tpll_mux;\n\tconst struct clk_ops\t*pll_mux_ops;\n\n\tstruct notifier_block\tclk_nb;\n\n\tvoid __iomem\t\t*reg_base;\n\tint\t\t\tlock_offset;\n\tunsigned int\t\tlock_shift;\n\tenum rockchip_pll_type\ttype;\n\tu8\t\t\tflags;\n\tconst struct rockchip_pll_rate_table *rate_table;\n\tunsigned int\t\trate_count;\n\tspinlock_t\t\t*lock;\n\n\tstruct rockchip_clk_provider *ctx;\n};\n\n#define to_rockchip_clk_pll(_hw) container_of(_hw, struct rockchip_clk_pll, hw)\n#define to_rockchip_clk_pll_nb(nb) \\\n\t\t\tcontainer_of(nb, struct rockchip_clk_pll, clk_nb)\n\nstatic const struct rockchip_pll_rate_table *rockchip_get_pll_settings(\n\t\t\t    struct rockchip_clk_pll *pll, unsigned long rate)\n{\n\tconst struct rockchip_pll_rate_table  *rate_table = pll->rate_table;\n\tint i;\n\n\tfor (i = 0; i < pll->rate_count; i++) {\n\t\tif (rate == rate_table[i].rate)\n\t\t\treturn &rate_table[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic long rockchip_pll_round_rate(struct clk_hw *hw,\n\t\t\t    unsigned long drate, unsigned long *prate)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tconst struct rockchip_pll_rate_table *rate_table = pll->rate_table;\n\tint i;\n\n\t \n\tfor (i = 0; i < pll->rate_count; i++) {\n\t\tif (drate >= rate_table[i].rate)\n\t\t\treturn rate_table[i].rate;\n\t}\n\n\t \n\treturn rate_table[i - 1].rate;\n}\n\n \nstatic int rockchip_pll_wait_lock(struct rockchip_clk_pll *pll)\n{\n\tstruct regmap *grf = pll->ctx->grf;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read_poll_timeout(grf, pll->lock_offset, val,\n\t\t\t\t       val & BIT(pll->lock_shift), 0, 1000);\n\tif (ret)\n\t\tpr_err(\"%s: timeout waiting for pll to lock\\n\", __func__);\n\n\treturn ret;\n}\n\n \n\n#define RK3036_PLLCON(i)\t\t\t(i * 0x4)\n#define RK3036_PLLCON0_FBDIV_MASK\t\t0xfff\n#define RK3036_PLLCON0_FBDIV_SHIFT\t\t0\n#define RK3036_PLLCON0_POSTDIV1_MASK\t\t0x7\n#define RK3036_PLLCON0_POSTDIV1_SHIFT\t\t12\n#define RK3036_PLLCON1_REFDIV_MASK\t\t0x3f\n#define RK3036_PLLCON1_REFDIV_SHIFT\t\t0\n#define RK3036_PLLCON1_POSTDIV2_MASK\t\t0x7\n#define RK3036_PLLCON1_POSTDIV2_SHIFT\t\t6\n#define RK3036_PLLCON1_LOCK_STATUS\t\tBIT(10)\n#define RK3036_PLLCON1_DSMPD_MASK\t\t0x1\n#define RK3036_PLLCON1_DSMPD_SHIFT\t\t12\n#define RK3036_PLLCON1_PWRDOWN\t\t\tBIT(13)\n#define RK3036_PLLCON2_FRAC_MASK\t\t0xffffff\n#define RK3036_PLLCON2_FRAC_SHIFT\t\t0\n\nstatic int rockchip_rk3036_pll_wait_lock(struct rockchip_clk_pll *pll)\n{\n\tu32 pllcon;\n\tint ret;\n\n\t \n\tret = readl_relaxed_poll_timeout(pll->reg_base + RK3036_PLLCON(1),\n\t\t\t\t\t pllcon,\n\t\t\t\t\t pllcon & RK3036_PLLCON1_LOCK_STATUS,\n\t\t\t\t\t 0, 1000);\n\tif (ret)\n\t\tpr_err(\"%s: timeout waiting for pll to lock\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic void rockchip_rk3036_pll_get_params(struct rockchip_clk_pll *pll,\n\t\t\t\t\tstruct rockchip_pll_rate_table *rate)\n{\n\tu32 pllcon;\n\n\tpllcon = readl_relaxed(pll->reg_base + RK3036_PLLCON(0));\n\trate->fbdiv = ((pllcon >> RK3036_PLLCON0_FBDIV_SHIFT)\n\t\t\t\t& RK3036_PLLCON0_FBDIV_MASK);\n\trate->postdiv1 = ((pllcon >> RK3036_PLLCON0_POSTDIV1_SHIFT)\n\t\t\t\t& RK3036_PLLCON0_POSTDIV1_MASK);\n\n\tpllcon = readl_relaxed(pll->reg_base + RK3036_PLLCON(1));\n\trate->refdiv = ((pllcon >> RK3036_PLLCON1_REFDIV_SHIFT)\n\t\t\t\t& RK3036_PLLCON1_REFDIV_MASK);\n\trate->postdiv2 = ((pllcon >> RK3036_PLLCON1_POSTDIV2_SHIFT)\n\t\t\t\t& RK3036_PLLCON1_POSTDIV2_MASK);\n\trate->dsmpd = ((pllcon >> RK3036_PLLCON1_DSMPD_SHIFT)\n\t\t\t\t& RK3036_PLLCON1_DSMPD_MASK);\n\n\tpllcon = readl_relaxed(pll->reg_base + RK3036_PLLCON(2));\n\trate->frac = ((pllcon >> RK3036_PLLCON2_FRAC_SHIFT)\n\t\t\t\t& RK3036_PLLCON2_FRAC_MASK);\n}\n\nstatic unsigned long rockchip_rk3036_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t     unsigned long prate)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tstruct rockchip_pll_rate_table cur;\n\tu64 rate64 = prate;\n\n\trockchip_rk3036_pll_get_params(pll, &cur);\n\n\trate64 *= cur.fbdiv;\n\tdo_div(rate64, cur.refdiv);\n\n\tif (cur.dsmpd == 0) {\n\t\t \n\t\tu64 frac_rate64 = prate * cur.frac;\n\n\t\tdo_div(frac_rate64, cur.refdiv);\n\t\trate64 += frac_rate64 >> 24;\n\t}\n\n\tdo_div(rate64, cur.postdiv1);\n\tdo_div(rate64, cur.postdiv2);\n\n\treturn (unsigned long)rate64;\n}\n\nstatic int rockchip_rk3036_pll_set_params(struct rockchip_clk_pll *pll,\n\t\t\t\tconst struct rockchip_pll_rate_table *rate)\n{\n\tconst struct clk_ops *pll_mux_ops = pll->pll_mux_ops;\n\tstruct clk_mux *pll_mux = &pll->pll_mux;\n\tstruct rockchip_pll_rate_table cur;\n\tu32 pllcon;\n\tint rate_change_remuxed = 0;\n\tint cur_parent;\n\tint ret;\n\n\tpr_debug(\"%s: rate settings for %lu fbdiv: %d, postdiv1: %d, refdiv: %d, postdiv2: %d, dsmpd: %d, frac: %d\\n\",\n\t\t__func__, rate->rate, rate->fbdiv, rate->postdiv1, rate->refdiv,\n\t\trate->postdiv2, rate->dsmpd, rate->frac);\n\n\trockchip_rk3036_pll_get_params(pll, &cur);\n\tcur.rate = 0;\n\n\tcur_parent = pll_mux_ops->get_parent(&pll_mux->hw);\n\tif (cur_parent == PLL_MODE_NORM) {\n\t\tpll_mux_ops->set_parent(&pll_mux->hw, PLL_MODE_SLOW);\n\t\trate_change_remuxed = 1;\n\t}\n\n\t \n\twritel_relaxed(HIWORD_UPDATE(rate->fbdiv, RK3036_PLLCON0_FBDIV_MASK,\n\t\t\t\t\t  RK3036_PLLCON0_FBDIV_SHIFT) |\n\t\t       HIWORD_UPDATE(rate->postdiv1, RK3036_PLLCON0_POSTDIV1_MASK,\n\t\t\t\t\t     RK3036_PLLCON0_POSTDIV1_SHIFT),\n\t\t       pll->reg_base + RK3036_PLLCON(0));\n\n\twritel_relaxed(HIWORD_UPDATE(rate->refdiv, RK3036_PLLCON1_REFDIV_MASK,\n\t\t\t\t\t\t   RK3036_PLLCON1_REFDIV_SHIFT) |\n\t\t       HIWORD_UPDATE(rate->postdiv2, RK3036_PLLCON1_POSTDIV2_MASK,\n\t\t\t\t\t\t     RK3036_PLLCON1_POSTDIV2_SHIFT) |\n\t\t       HIWORD_UPDATE(rate->dsmpd, RK3036_PLLCON1_DSMPD_MASK,\n\t\t\t\t\t\t  RK3036_PLLCON1_DSMPD_SHIFT),\n\t\t       pll->reg_base + RK3036_PLLCON(1));\n\n\t \n\tpllcon = readl_relaxed(pll->reg_base + RK3036_PLLCON(2));\n\tpllcon &= ~(RK3036_PLLCON2_FRAC_MASK << RK3036_PLLCON2_FRAC_SHIFT);\n\tpllcon |= rate->frac << RK3036_PLLCON2_FRAC_SHIFT;\n\twritel_relaxed(pllcon, pll->reg_base + RK3036_PLLCON(2));\n\n\t \n\tret = rockchip_rk3036_pll_wait_lock(pll);\n\tif (ret) {\n\t\tpr_warn(\"%s: pll update unsuccessful, trying to restore old params\\n\",\n\t\t\t__func__);\n\t\trockchip_rk3036_pll_set_params(pll, &cur);\n\t}\n\n\tif (rate_change_remuxed)\n\t\tpll_mux_ops->set_parent(&pll_mux->hw, PLL_MODE_NORM);\n\n\treturn ret;\n}\n\nstatic int rockchip_rk3036_pll_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t\tunsigned long prate)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tconst struct rockchip_pll_rate_table *rate;\n\n\tpr_debug(\"%s: changing %s to %lu with a parent rate of %lu\\n\",\n\t\t __func__, __clk_get_name(hw->clk), drate, prate);\n\n\t \n\trate = rockchip_get_pll_settings(pll, drate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for pll clk %s\\n\", __func__,\n\t\t\tdrate, __clk_get_name(hw->clk));\n\t\treturn -EINVAL;\n\t}\n\n\treturn rockchip_rk3036_pll_set_params(pll, rate);\n}\n\nstatic int rockchip_rk3036_pll_enable(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\n\twritel(HIWORD_UPDATE(0, RK3036_PLLCON1_PWRDOWN, 0),\n\t       pll->reg_base + RK3036_PLLCON(1));\n\trockchip_rk3036_pll_wait_lock(pll);\n\n\treturn 0;\n}\n\nstatic void rockchip_rk3036_pll_disable(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\n\twritel(HIWORD_UPDATE(RK3036_PLLCON1_PWRDOWN,\n\t\t\t     RK3036_PLLCON1_PWRDOWN, 0),\n\t       pll->reg_base + RK3036_PLLCON(1));\n}\n\nstatic int rockchip_rk3036_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tu32 pllcon = readl(pll->reg_base + RK3036_PLLCON(1));\n\n\treturn !(pllcon & RK3036_PLLCON1_PWRDOWN);\n}\n\nstatic int rockchip_rk3036_pll_init(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tconst struct rockchip_pll_rate_table *rate;\n\tstruct rockchip_pll_rate_table cur;\n\tunsigned long drate;\n\n\tif (!(pll->flags & ROCKCHIP_PLL_SYNC_RATE))\n\t\treturn 0;\n\n\tdrate = clk_hw_get_rate(hw);\n\trate = rockchip_get_pll_settings(pll, drate);\n\n\t \n\tif (!rate)\n\t\treturn 0;\n\n\trockchip_rk3036_pll_get_params(pll, &cur);\n\n\tpr_debug(\"%s: pll %s@%lu: Hz\\n\", __func__, __clk_get_name(hw->clk),\n\t\t drate);\n\tpr_debug(\"old - fbdiv: %d, postdiv1: %d, refdiv: %d, postdiv2: %d, dsmpd: %d, frac: %d\\n\",\n\t\t cur.fbdiv, cur.postdiv1, cur.refdiv, cur.postdiv2,\n\t\t cur.dsmpd, cur.frac);\n\tpr_debug(\"new - fbdiv: %d, postdiv1: %d, refdiv: %d, postdiv2: %d, dsmpd: %d, frac: %d\\n\",\n\t\t rate->fbdiv, rate->postdiv1, rate->refdiv, rate->postdiv2,\n\t\t rate->dsmpd, rate->frac);\n\n\tif (rate->fbdiv != cur.fbdiv || rate->postdiv1 != cur.postdiv1 ||\n\t\trate->refdiv != cur.refdiv || rate->postdiv2 != cur.postdiv2 ||\n\t\trate->dsmpd != cur.dsmpd ||\n\t\t(!cur.dsmpd && (rate->frac != cur.frac))) {\n\t\tstruct clk *parent = clk_get_parent(hw->clk);\n\n\t\tif (!parent) {\n\t\t\tpr_warn(\"%s: parent of %s not available\\n\",\n\t\t\t\t__func__, __clk_get_name(hw->clk));\n\t\t\treturn 0;\n\t\t}\n\n\t\tpr_debug(\"%s: pll %s: rate params do not match rate table, adjusting\\n\",\n\t\t\t __func__, __clk_get_name(hw->clk));\n\t\trockchip_rk3036_pll_set_params(pll, rate);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct clk_ops rockchip_rk3036_pll_clk_norate_ops = {\n\t.recalc_rate = rockchip_rk3036_pll_recalc_rate,\n\t.enable = rockchip_rk3036_pll_enable,\n\t.disable = rockchip_rk3036_pll_disable,\n\t.is_enabled = rockchip_rk3036_pll_is_enabled,\n};\n\nstatic const struct clk_ops rockchip_rk3036_pll_clk_ops = {\n\t.recalc_rate = rockchip_rk3036_pll_recalc_rate,\n\t.round_rate = rockchip_pll_round_rate,\n\t.set_rate = rockchip_rk3036_pll_set_rate,\n\t.enable = rockchip_rk3036_pll_enable,\n\t.disable = rockchip_rk3036_pll_disable,\n\t.is_enabled = rockchip_rk3036_pll_is_enabled,\n\t.init = rockchip_rk3036_pll_init,\n};\n\n \n\n#define RK3066_PLL_RESET_DELAY(nr)\t((nr * 500) / 24 + 1)\n\n#define RK3066_PLLCON(i)\t\t(i * 0x4)\n#define RK3066_PLLCON0_OD_MASK\t\t0xf\n#define RK3066_PLLCON0_OD_SHIFT\t\t0\n#define RK3066_PLLCON0_NR_MASK\t\t0x3f\n#define RK3066_PLLCON0_NR_SHIFT\t\t8\n#define RK3066_PLLCON1_NF_MASK\t\t0x1fff\n#define RK3066_PLLCON1_NF_SHIFT\t\t0\n#define RK3066_PLLCON2_NB_MASK\t\t0xfff\n#define RK3066_PLLCON2_NB_SHIFT\t\t0\n#define RK3066_PLLCON3_RESET\t\t(1 << 5)\n#define RK3066_PLLCON3_PWRDOWN\t\t(1 << 1)\n#define RK3066_PLLCON3_BYPASS\t\t(1 << 0)\n\nstatic void rockchip_rk3066_pll_get_params(struct rockchip_clk_pll *pll,\n\t\t\t\t\tstruct rockchip_pll_rate_table *rate)\n{\n\tu32 pllcon;\n\n\tpllcon = readl_relaxed(pll->reg_base + RK3066_PLLCON(0));\n\trate->nr = ((pllcon >> RK3066_PLLCON0_NR_SHIFT)\n\t\t\t\t& RK3066_PLLCON0_NR_MASK) + 1;\n\trate->no = ((pllcon >> RK3066_PLLCON0_OD_SHIFT)\n\t\t\t\t& RK3066_PLLCON0_OD_MASK) + 1;\n\n\tpllcon = readl_relaxed(pll->reg_base + RK3066_PLLCON(1));\n\trate->nf = ((pllcon >> RK3066_PLLCON1_NF_SHIFT)\n\t\t\t\t& RK3066_PLLCON1_NF_MASK) + 1;\n\n\tpllcon = readl_relaxed(pll->reg_base + RK3066_PLLCON(2));\n\trate->nb = ((pllcon >> RK3066_PLLCON2_NB_SHIFT)\n\t\t\t\t& RK3066_PLLCON2_NB_MASK) + 1;\n}\n\nstatic unsigned long rockchip_rk3066_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t     unsigned long prate)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tstruct rockchip_pll_rate_table cur;\n\tu64 rate64 = prate;\n\tu32 pllcon;\n\n\tpllcon = readl_relaxed(pll->reg_base + RK3066_PLLCON(3));\n\tif (pllcon & RK3066_PLLCON3_BYPASS) {\n\t\tpr_debug(\"%s: pll %s is bypassed\\n\", __func__,\n\t\t\tclk_hw_get_name(hw));\n\t\treturn prate;\n\t}\n\n\trockchip_rk3066_pll_get_params(pll, &cur);\n\n\trate64 *= cur.nf;\n\tdo_div(rate64, cur.nr);\n\tdo_div(rate64, cur.no);\n\n\treturn (unsigned long)rate64;\n}\n\nstatic int rockchip_rk3066_pll_set_params(struct rockchip_clk_pll *pll,\n\t\t\t\tconst struct rockchip_pll_rate_table *rate)\n{\n\tconst struct clk_ops *pll_mux_ops = pll->pll_mux_ops;\n\tstruct clk_mux *pll_mux = &pll->pll_mux;\n\tstruct rockchip_pll_rate_table cur;\n\tint rate_change_remuxed = 0;\n\tint cur_parent;\n\tint ret;\n\n\tpr_debug(\"%s: rate settings for %lu (nr, no, nf): (%d, %d, %d)\\n\",\n\t\t __func__, rate->rate, rate->nr, rate->no, rate->nf);\n\n\trockchip_rk3066_pll_get_params(pll, &cur);\n\tcur.rate = 0;\n\n\tcur_parent = pll_mux_ops->get_parent(&pll_mux->hw);\n\tif (cur_parent == PLL_MODE_NORM) {\n\t\tpll_mux_ops->set_parent(&pll_mux->hw, PLL_MODE_SLOW);\n\t\trate_change_remuxed = 1;\n\t}\n\n\t \n\twritel(HIWORD_UPDATE(RK3066_PLLCON3_RESET, RK3066_PLLCON3_RESET, 0),\n\t       pll->reg_base + RK3066_PLLCON(3));\n\n\t \n\twritel(HIWORD_UPDATE(rate->nr - 1, RK3066_PLLCON0_NR_MASK,\n\t\t\t\t\t   RK3066_PLLCON0_NR_SHIFT) |\n\t       HIWORD_UPDATE(rate->no - 1, RK3066_PLLCON0_OD_MASK,\n\t\t\t\t\t   RK3066_PLLCON0_OD_SHIFT),\n\t       pll->reg_base + RK3066_PLLCON(0));\n\n\twritel_relaxed(HIWORD_UPDATE(rate->nf - 1, RK3066_PLLCON1_NF_MASK,\n\t\t\t\t\t\t   RK3066_PLLCON1_NF_SHIFT),\n\t\t       pll->reg_base + RK3066_PLLCON(1));\n\twritel_relaxed(HIWORD_UPDATE(rate->nb - 1, RK3066_PLLCON2_NB_MASK,\n\t\t\t\t\t\t   RK3066_PLLCON2_NB_SHIFT),\n\t\t       pll->reg_base + RK3066_PLLCON(2));\n\n\t \n\twritel(HIWORD_UPDATE(0, RK3066_PLLCON3_RESET, 0),\n\t       pll->reg_base + RK3066_PLLCON(3));\n\tudelay(RK3066_PLL_RESET_DELAY(rate->nr));\n\n\t \n\tret = rockchip_pll_wait_lock(pll);\n\tif (ret) {\n\t\tpr_warn(\"%s: pll update unsuccessful, trying to restore old params\\n\",\n\t\t\t__func__);\n\t\trockchip_rk3066_pll_set_params(pll, &cur);\n\t}\n\n\tif (rate_change_remuxed)\n\t\tpll_mux_ops->set_parent(&pll_mux->hw, PLL_MODE_NORM);\n\n\treturn ret;\n}\n\nstatic int rockchip_rk3066_pll_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t\tunsigned long prate)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tconst struct rockchip_pll_rate_table *rate;\n\n\tpr_debug(\"%s: changing %s to %lu with a parent rate of %lu\\n\",\n\t\t __func__, clk_hw_get_name(hw), drate, prate);\n\n\t \n\trate = rockchip_get_pll_settings(pll, drate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for pll clk %s\\n\", __func__,\n\t\t\tdrate, clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\treturn rockchip_rk3066_pll_set_params(pll, rate);\n}\n\nstatic int rockchip_rk3066_pll_enable(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\n\twritel(HIWORD_UPDATE(0, RK3066_PLLCON3_PWRDOWN, 0),\n\t       pll->reg_base + RK3066_PLLCON(3));\n\trockchip_pll_wait_lock(pll);\n\n\treturn 0;\n}\n\nstatic void rockchip_rk3066_pll_disable(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\n\twritel(HIWORD_UPDATE(RK3066_PLLCON3_PWRDOWN,\n\t\t\t     RK3066_PLLCON3_PWRDOWN, 0),\n\t       pll->reg_base + RK3066_PLLCON(3));\n}\n\nstatic int rockchip_rk3066_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tu32 pllcon = readl(pll->reg_base + RK3066_PLLCON(3));\n\n\treturn !(pllcon & RK3066_PLLCON3_PWRDOWN);\n}\n\nstatic int rockchip_rk3066_pll_init(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tconst struct rockchip_pll_rate_table *rate;\n\tstruct rockchip_pll_rate_table cur;\n\tunsigned long drate;\n\n\tif (!(pll->flags & ROCKCHIP_PLL_SYNC_RATE))\n\t\treturn 0;\n\n\tdrate = clk_hw_get_rate(hw);\n\trate = rockchip_get_pll_settings(pll, drate);\n\n\t \n\tif (!rate)\n\t\treturn 0;\n\n\trockchip_rk3066_pll_get_params(pll, &cur);\n\n\tpr_debug(\"%s: pll %s@%lu: nr (%d:%d); no (%d:%d); nf(%d:%d), nb(%d:%d)\\n\",\n\t\t __func__, clk_hw_get_name(hw), drate, rate->nr, cur.nr,\n\t\t rate->no, cur.no, rate->nf, cur.nf, rate->nb, cur.nb);\n\tif (rate->nr != cur.nr || rate->no != cur.no || rate->nf != cur.nf\n\t\t\t\t\t\t     || rate->nb != cur.nb) {\n\t\tpr_debug(\"%s: pll %s: rate params do not match rate table, adjusting\\n\",\n\t\t\t __func__, clk_hw_get_name(hw));\n\t\trockchip_rk3066_pll_set_params(pll, rate);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct clk_ops rockchip_rk3066_pll_clk_norate_ops = {\n\t.recalc_rate = rockchip_rk3066_pll_recalc_rate,\n\t.enable = rockchip_rk3066_pll_enable,\n\t.disable = rockchip_rk3066_pll_disable,\n\t.is_enabled = rockchip_rk3066_pll_is_enabled,\n};\n\nstatic const struct clk_ops rockchip_rk3066_pll_clk_ops = {\n\t.recalc_rate = rockchip_rk3066_pll_recalc_rate,\n\t.round_rate = rockchip_pll_round_rate,\n\t.set_rate = rockchip_rk3066_pll_set_rate,\n\t.enable = rockchip_rk3066_pll_enable,\n\t.disable = rockchip_rk3066_pll_disable,\n\t.is_enabled = rockchip_rk3066_pll_is_enabled,\n\t.init = rockchip_rk3066_pll_init,\n};\n\n \n\n#define RK3399_PLLCON(i)\t\t\t(i * 0x4)\n#define RK3399_PLLCON0_FBDIV_MASK\t\t0xfff\n#define RK3399_PLLCON0_FBDIV_SHIFT\t\t0\n#define RK3399_PLLCON1_REFDIV_MASK\t\t0x3f\n#define RK3399_PLLCON1_REFDIV_SHIFT\t\t0\n#define RK3399_PLLCON1_POSTDIV1_MASK\t\t0x7\n#define RK3399_PLLCON1_POSTDIV1_SHIFT\t\t8\n#define RK3399_PLLCON1_POSTDIV2_MASK\t\t0x7\n#define RK3399_PLLCON1_POSTDIV2_SHIFT\t\t12\n#define RK3399_PLLCON2_FRAC_MASK\t\t0xffffff\n#define RK3399_PLLCON2_FRAC_SHIFT\t\t0\n#define RK3399_PLLCON2_LOCK_STATUS\t\tBIT(31)\n#define RK3399_PLLCON3_PWRDOWN\t\t\tBIT(0)\n#define RK3399_PLLCON3_DSMPD_MASK\t\t0x1\n#define RK3399_PLLCON3_DSMPD_SHIFT\t\t3\n\nstatic int rockchip_rk3399_pll_wait_lock(struct rockchip_clk_pll *pll)\n{\n\tu32 pllcon;\n\tint ret;\n\n\t \n\tret = readl_relaxed_poll_timeout(pll->reg_base + RK3399_PLLCON(2),\n\t\t\t\t\t pllcon,\n\t\t\t\t\t pllcon & RK3399_PLLCON2_LOCK_STATUS,\n\t\t\t\t\t 0, 1000);\n\tif (ret)\n\t\tpr_err(\"%s: timeout waiting for pll to lock\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic void rockchip_rk3399_pll_get_params(struct rockchip_clk_pll *pll,\n\t\t\t\t\tstruct rockchip_pll_rate_table *rate)\n{\n\tu32 pllcon;\n\n\tpllcon = readl_relaxed(pll->reg_base + RK3399_PLLCON(0));\n\trate->fbdiv = ((pllcon >> RK3399_PLLCON0_FBDIV_SHIFT)\n\t\t\t\t& RK3399_PLLCON0_FBDIV_MASK);\n\n\tpllcon = readl_relaxed(pll->reg_base + RK3399_PLLCON(1));\n\trate->refdiv = ((pllcon >> RK3399_PLLCON1_REFDIV_SHIFT)\n\t\t\t\t& RK3399_PLLCON1_REFDIV_MASK);\n\trate->postdiv1 = ((pllcon >> RK3399_PLLCON1_POSTDIV1_SHIFT)\n\t\t\t\t& RK3399_PLLCON1_POSTDIV1_MASK);\n\trate->postdiv2 = ((pllcon >> RK3399_PLLCON1_POSTDIV2_SHIFT)\n\t\t\t\t& RK3399_PLLCON1_POSTDIV2_MASK);\n\n\tpllcon = readl_relaxed(pll->reg_base + RK3399_PLLCON(2));\n\trate->frac = ((pllcon >> RK3399_PLLCON2_FRAC_SHIFT)\n\t\t\t\t& RK3399_PLLCON2_FRAC_MASK);\n\n\tpllcon = readl_relaxed(pll->reg_base + RK3399_PLLCON(3));\n\trate->dsmpd = ((pllcon >> RK3399_PLLCON3_DSMPD_SHIFT)\n\t\t\t\t& RK3399_PLLCON3_DSMPD_MASK);\n}\n\nstatic unsigned long rockchip_rk3399_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t     unsigned long prate)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tstruct rockchip_pll_rate_table cur;\n\tu64 rate64 = prate;\n\n\trockchip_rk3399_pll_get_params(pll, &cur);\n\n\trate64 *= cur.fbdiv;\n\tdo_div(rate64, cur.refdiv);\n\n\tif (cur.dsmpd == 0) {\n\t\t \n\t\tu64 frac_rate64 = prate * cur.frac;\n\n\t\tdo_div(frac_rate64, cur.refdiv);\n\t\trate64 += frac_rate64 >> 24;\n\t}\n\n\tdo_div(rate64, cur.postdiv1);\n\tdo_div(rate64, cur.postdiv2);\n\n\treturn (unsigned long)rate64;\n}\n\nstatic int rockchip_rk3399_pll_set_params(struct rockchip_clk_pll *pll,\n\t\t\t\tconst struct rockchip_pll_rate_table *rate)\n{\n\tconst struct clk_ops *pll_mux_ops = pll->pll_mux_ops;\n\tstruct clk_mux *pll_mux = &pll->pll_mux;\n\tstruct rockchip_pll_rate_table cur;\n\tu32 pllcon;\n\tint rate_change_remuxed = 0;\n\tint cur_parent;\n\tint ret;\n\n\tpr_debug(\"%s: rate settings for %lu fbdiv: %d, postdiv1: %d, refdiv: %d, postdiv2: %d, dsmpd: %d, frac: %d\\n\",\n\t\t__func__, rate->rate, rate->fbdiv, rate->postdiv1, rate->refdiv,\n\t\trate->postdiv2, rate->dsmpd, rate->frac);\n\n\trockchip_rk3399_pll_get_params(pll, &cur);\n\tcur.rate = 0;\n\n\tcur_parent = pll_mux_ops->get_parent(&pll_mux->hw);\n\tif (cur_parent == PLL_MODE_NORM) {\n\t\tpll_mux_ops->set_parent(&pll_mux->hw, PLL_MODE_SLOW);\n\t\trate_change_remuxed = 1;\n\t}\n\n\t \n\twritel_relaxed(HIWORD_UPDATE(rate->fbdiv, RK3399_PLLCON0_FBDIV_MASK,\n\t\t\t\t\t\t  RK3399_PLLCON0_FBDIV_SHIFT),\n\t\t       pll->reg_base + RK3399_PLLCON(0));\n\n\twritel_relaxed(HIWORD_UPDATE(rate->refdiv, RK3399_PLLCON1_REFDIV_MASK,\n\t\t\t\t\t\t   RK3399_PLLCON1_REFDIV_SHIFT) |\n\t\t       HIWORD_UPDATE(rate->postdiv1, RK3399_PLLCON1_POSTDIV1_MASK,\n\t\t\t\t\t\t     RK3399_PLLCON1_POSTDIV1_SHIFT) |\n\t\t       HIWORD_UPDATE(rate->postdiv2, RK3399_PLLCON1_POSTDIV2_MASK,\n\t\t\t\t\t\t     RK3399_PLLCON1_POSTDIV2_SHIFT),\n\t\t       pll->reg_base + RK3399_PLLCON(1));\n\n\t \n\tpllcon = readl_relaxed(pll->reg_base + RK3399_PLLCON(2));\n\tpllcon &= ~(RK3399_PLLCON2_FRAC_MASK << RK3399_PLLCON2_FRAC_SHIFT);\n\tpllcon |= rate->frac << RK3399_PLLCON2_FRAC_SHIFT;\n\twritel_relaxed(pllcon, pll->reg_base + RK3399_PLLCON(2));\n\n\twritel_relaxed(HIWORD_UPDATE(rate->dsmpd, RK3399_PLLCON3_DSMPD_MASK,\n\t\t\t\t\t    RK3399_PLLCON3_DSMPD_SHIFT),\n\t\t       pll->reg_base + RK3399_PLLCON(3));\n\n\t \n\tret = rockchip_rk3399_pll_wait_lock(pll);\n\tif (ret) {\n\t\tpr_warn(\"%s: pll update unsuccessful, trying to restore old params\\n\",\n\t\t\t__func__);\n\t\trockchip_rk3399_pll_set_params(pll, &cur);\n\t}\n\n\tif (rate_change_remuxed)\n\t\tpll_mux_ops->set_parent(&pll_mux->hw, PLL_MODE_NORM);\n\n\treturn ret;\n}\n\nstatic int rockchip_rk3399_pll_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t\tunsigned long prate)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tconst struct rockchip_pll_rate_table *rate;\n\n\tpr_debug(\"%s: changing %s to %lu with a parent rate of %lu\\n\",\n\t\t __func__, __clk_get_name(hw->clk), drate, prate);\n\n\t \n\trate = rockchip_get_pll_settings(pll, drate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for pll clk %s\\n\", __func__,\n\t\t\tdrate, __clk_get_name(hw->clk));\n\t\treturn -EINVAL;\n\t}\n\n\treturn rockchip_rk3399_pll_set_params(pll, rate);\n}\n\nstatic int rockchip_rk3399_pll_enable(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\n\twritel(HIWORD_UPDATE(0, RK3399_PLLCON3_PWRDOWN, 0),\n\t       pll->reg_base + RK3399_PLLCON(3));\n\trockchip_rk3399_pll_wait_lock(pll);\n\n\treturn 0;\n}\n\nstatic void rockchip_rk3399_pll_disable(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\n\twritel(HIWORD_UPDATE(RK3399_PLLCON3_PWRDOWN,\n\t\t\t     RK3399_PLLCON3_PWRDOWN, 0),\n\t       pll->reg_base + RK3399_PLLCON(3));\n}\n\nstatic int rockchip_rk3399_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tu32 pllcon = readl(pll->reg_base + RK3399_PLLCON(3));\n\n\treturn !(pllcon & RK3399_PLLCON3_PWRDOWN);\n}\n\nstatic int rockchip_rk3399_pll_init(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tconst struct rockchip_pll_rate_table *rate;\n\tstruct rockchip_pll_rate_table cur;\n\tunsigned long drate;\n\n\tif (!(pll->flags & ROCKCHIP_PLL_SYNC_RATE))\n\t\treturn 0;\n\n\tdrate = clk_hw_get_rate(hw);\n\trate = rockchip_get_pll_settings(pll, drate);\n\n\t \n\tif (!rate)\n\t\treturn 0;\n\n\trockchip_rk3399_pll_get_params(pll, &cur);\n\n\tpr_debug(\"%s: pll %s@%lu: Hz\\n\", __func__, __clk_get_name(hw->clk),\n\t\t drate);\n\tpr_debug(\"old - fbdiv: %d, postdiv1: %d, refdiv: %d, postdiv2: %d, dsmpd: %d, frac: %d\\n\",\n\t\t cur.fbdiv, cur.postdiv1, cur.refdiv, cur.postdiv2,\n\t\t cur.dsmpd, cur.frac);\n\tpr_debug(\"new - fbdiv: %d, postdiv1: %d, refdiv: %d, postdiv2: %d, dsmpd: %d, frac: %d\\n\",\n\t\t rate->fbdiv, rate->postdiv1, rate->refdiv, rate->postdiv2,\n\t\t rate->dsmpd, rate->frac);\n\n\tif (rate->fbdiv != cur.fbdiv || rate->postdiv1 != cur.postdiv1 ||\n\t\trate->refdiv != cur.refdiv || rate->postdiv2 != cur.postdiv2 ||\n\t\trate->dsmpd != cur.dsmpd ||\n\t\t(!cur.dsmpd && (rate->frac != cur.frac))) {\n\t\tstruct clk *parent = clk_get_parent(hw->clk);\n\n\t\tif (!parent) {\n\t\t\tpr_warn(\"%s: parent of %s not available\\n\",\n\t\t\t\t__func__, __clk_get_name(hw->clk));\n\t\t\treturn 0;\n\t\t}\n\n\t\tpr_debug(\"%s: pll %s: rate params do not match rate table, adjusting\\n\",\n\t\t\t __func__, __clk_get_name(hw->clk));\n\t\trockchip_rk3399_pll_set_params(pll, rate);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct clk_ops rockchip_rk3399_pll_clk_norate_ops = {\n\t.recalc_rate = rockchip_rk3399_pll_recalc_rate,\n\t.enable = rockchip_rk3399_pll_enable,\n\t.disable = rockchip_rk3399_pll_disable,\n\t.is_enabled = rockchip_rk3399_pll_is_enabled,\n};\n\nstatic const struct clk_ops rockchip_rk3399_pll_clk_ops = {\n\t.recalc_rate = rockchip_rk3399_pll_recalc_rate,\n\t.round_rate = rockchip_pll_round_rate,\n\t.set_rate = rockchip_rk3399_pll_set_rate,\n\t.enable = rockchip_rk3399_pll_enable,\n\t.disable = rockchip_rk3399_pll_disable,\n\t.is_enabled = rockchip_rk3399_pll_is_enabled,\n\t.init = rockchip_rk3399_pll_init,\n};\n\n \n\n#define RK3588_PLLCON(i)               (i * 0x4)\n#define RK3588_PLLCON0_M_MASK          0x3ff\n#define RK3588_PLLCON0_M_SHIFT         0\n#define RK3588_PLLCON1_P_MASK          0x3f\n#define RK3588_PLLCON1_P_SHIFT         0\n#define RK3588_PLLCON1_S_MASK          0x7\n#define RK3588_PLLCON1_S_SHIFT         6\n#define RK3588_PLLCON2_K_MASK          0xffff\n#define RK3588_PLLCON2_K_SHIFT         0\n#define RK3588_PLLCON1_PWRDOWN         BIT(13)\n#define RK3588_PLLCON6_LOCK_STATUS     BIT(15)\n\nstatic int rockchip_rk3588_pll_wait_lock(struct rockchip_clk_pll *pll)\n{\n\tu32 pllcon;\n\tint ret;\n\n\t \n\tret = readl_relaxed_poll_timeout(pll->reg_base + RK3588_PLLCON(6),\n\t\t\t\t\t pllcon,\n\t\t\t\t\t pllcon & RK3588_PLLCON6_LOCK_STATUS,\n\t\t\t\t\t 0, 1000);\n\tif (ret)\n\t\tpr_err(\"%s: timeout waiting for pll to lock\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic void rockchip_rk3588_pll_get_params(struct rockchip_clk_pll *pll,\n\t\t\t\t\t   struct rockchip_pll_rate_table *rate)\n{\n\tu32 pllcon;\n\n\tpllcon = readl_relaxed(pll->reg_base + RK3588_PLLCON(0));\n\trate->m = ((pllcon >> RK3588_PLLCON0_M_SHIFT) & RK3588_PLLCON0_M_MASK);\n\n\tpllcon = readl_relaxed(pll->reg_base + RK3588_PLLCON(1));\n\trate->p = ((pllcon >> RK3588_PLLCON1_P_SHIFT) & RK3588_PLLCON1_P_MASK);\n\trate->s = ((pllcon >> RK3588_PLLCON1_S_SHIFT) & RK3588_PLLCON1_S_MASK);\n\n\tpllcon = readl_relaxed(pll->reg_base + RK3588_PLLCON(2));\n\trate->k = ((pllcon >> RK3588_PLLCON2_K_SHIFT) & RK3588_PLLCON2_K_MASK);\n}\n\nstatic unsigned long rockchip_rk3588_pll_recalc_rate(struct clk_hw *hw, unsigned long prate)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tstruct rockchip_pll_rate_table cur;\n\tu64 rate64 = prate, postdiv;\n\n\trockchip_rk3588_pll_get_params(pll, &cur);\n\n\trate64 *= cur.m;\n\tdo_div(rate64, cur.p);\n\n\tif (cur.k) {\n\t\t \n\t\tu64 frac_rate64 = prate * cur.k;\n\n\t\tpostdiv = cur.p * 65535;\n\t\tdo_div(frac_rate64, postdiv);\n\t\trate64 += frac_rate64;\n\t}\n\trate64 = rate64 >> cur.s;\n\n\treturn (unsigned long)rate64;\n}\n\nstatic int rockchip_rk3588_pll_set_params(struct rockchip_clk_pll *pll,\n\t\t\t\t\t  const struct rockchip_pll_rate_table *rate)\n{\n\tconst struct clk_ops *pll_mux_ops = pll->pll_mux_ops;\n\tstruct clk_mux *pll_mux = &pll->pll_mux;\n\tstruct rockchip_pll_rate_table cur;\n\tint rate_change_remuxed = 0;\n\tint cur_parent;\n\tint ret;\n\n\tpr_debug(\"%s: rate settings for %lu p: %d, m: %d, s: %d, k: %d\\n\",\n\t\t __func__, rate->rate, rate->p, rate->m, rate->s, rate->k);\n\n\trockchip_rk3588_pll_get_params(pll, &cur);\n\tcur.rate = 0;\n\n\tif (pll->type == pll_rk3588) {\n\t\tcur_parent = pll_mux_ops->get_parent(&pll_mux->hw);\n\t\tif (cur_parent == PLL_MODE_NORM) {\n\t\t\tpll_mux_ops->set_parent(&pll_mux->hw, PLL_MODE_SLOW);\n\t\t\trate_change_remuxed = 1;\n\t\t}\n\t}\n\n\t \n\twritel(HIWORD_UPDATE(RK3588_PLLCON1_PWRDOWN,\n\t\t\t     RK3588_PLLCON1_PWRDOWN, 0),\n\t       pll->reg_base + RK3399_PLLCON(1));\n\n\t \n\twritel_relaxed(HIWORD_UPDATE(rate->m, RK3588_PLLCON0_M_MASK, RK3588_PLLCON0_M_SHIFT),\n\t\t       pll->reg_base + RK3399_PLLCON(0));\n\n\twritel_relaxed(HIWORD_UPDATE(rate->p, RK3588_PLLCON1_P_MASK, RK3588_PLLCON1_P_SHIFT) |\n\t\t       HIWORD_UPDATE(rate->s, RK3588_PLLCON1_S_MASK, RK3588_PLLCON1_S_SHIFT),\n\t\t       pll->reg_base + RK3399_PLLCON(1));\n\n\twritel_relaxed(HIWORD_UPDATE(rate->k, RK3588_PLLCON2_K_MASK, RK3588_PLLCON2_K_SHIFT),\n\t\t       pll->reg_base + RK3399_PLLCON(2));\n\n\t \n\twritel(HIWORD_UPDATE(0, RK3588_PLLCON1_PWRDOWN, 0),\n\t       pll->reg_base + RK3588_PLLCON(1));\n\n\t \n\tret = rockchip_rk3588_pll_wait_lock(pll);\n\tif (ret) {\n\t\tpr_warn(\"%s: pll update unsuccessful, trying to restore old params\\n\",\n\t\t\t__func__);\n\t\trockchip_rk3588_pll_set_params(pll, &cur);\n\t}\n\n\tif ((pll->type == pll_rk3588) && rate_change_remuxed)\n\t\tpll_mux_ops->set_parent(&pll_mux->hw, PLL_MODE_NORM);\n\n\treturn ret;\n}\n\nstatic int rockchip_rk3588_pll_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t\tunsigned long prate)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tconst struct rockchip_pll_rate_table *rate;\n\n\tpr_debug(\"%s: changing %s to %lu with a parent rate of %lu\\n\",\n\t\t __func__, __clk_get_name(hw->clk), drate, prate);\n\n\t \n\trate = rockchip_get_pll_settings(pll, drate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for pll clk %s\\n\", __func__,\n\t\t\tdrate, __clk_get_name(hw->clk));\n\t\treturn -EINVAL;\n\t}\n\n\treturn rockchip_rk3588_pll_set_params(pll, rate);\n}\n\nstatic int rockchip_rk3588_pll_enable(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\n\twritel(HIWORD_UPDATE(0, RK3588_PLLCON1_PWRDOWN, 0),\n\t       pll->reg_base + RK3588_PLLCON(1));\n\trockchip_rk3588_pll_wait_lock(pll);\n\n\treturn 0;\n}\n\nstatic void rockchip_rk3588_pll_disable(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\n\twritel(HIWORD_UPDATE(RK3588_PLLCON1_PWRDOWN, RK3588_PLLCON1_PWRDOWN, 0),\n\t       pll->reg_base + RK3588_PLLCON(1));\n}\n\nstatic int rockchip_rk3588_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\tu32 pllcon = readl(pll->reg_base + RK3588_PLLCON(1));\n\n\treturn !(pllcon & RK3588_PLLCON1_PWRDOWN);\n}\n\nstatic int rockchip_rk3588_pll_init(struct clk_hw *hw)\n{\n\tstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\n\n\tif (!(pll->flags & ROCKCHIP_PLL_SYNC_RATE))\n\t\treturn 0;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops rockchip_rk3588_pll_clk_norate_ops = {\n\t.recalc_rate = rockchip_rk3588_pll_recalc_rate,\n\t.enable = rockchip_rk3588_pll_enable,\n\t.disable = rockchip_rk3588_pll_disable,\n\t.is_enabled = rockchip_rk3588_pll_is_enabled,\n};\n\nstatic const struct clk_ops rockchip_rk3588_pll_clk_ops = {\n\t.recalc_rate = rockchip_rk3588_pll_recalc_rate,\n\t.round_rate = rockchip_pll_round_rate,\n\t.set_rate = rockchip_rk3588_pll_set_rate,\n\t.enable = rockchip_rk3588_pll_enable,\n\t.disable = rockchip_rk3588_pll_disable,\n\t.is_enabled = rockchip_rk3588_pll_is_enabled,\n\t.init = rockchip_rk3588_pll_init,\n};\n\n \n\nstruct clk *rockchip_clk_register_pll(struct rockchip_clk_provider *ctx,\n\t\tenum rockchip_pll_type pll_type,\n\t\tconst char *name, const char *const *parent_names,\n\t\tu8 num_parents, int con_offset, int grf_lock_offset,\n\t\tint lock_shift, int mode_offset, int mode_shift,\n\t\tstruct rockchip_pll_rate_table *rate_table,\n\t\tunsigned long flags, u8 clk_pll_flags)\n{\n\tconst char *pll_parents[3];\n\tstruct clk_init_data init;\n\tstruct rockchip_clk_pll *pll;\n\tstruct clk_mux *pll_mux;\n\tstruct clk *pll_clk, *mux_clk;\n\tchar pll_name[20];\n\n\tif ((pll_type != pll_rk3328 && num_parents != 2) ||\n\t    (pll_type == pll_rk3328 && num_parents != 1)) {\n\t\tpr_err(\"%s: needs two parent clocks\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tsnprintf(pll_name, sizeof(pll_name), \"pll_%s\", name);\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tpll->pll_mux_ops = &clk_mux_ops;\n\tpll_mux = &pll->pll_mux;\n\tpll_mux->reg = ctx->reg_base + mode_offset;\n\tpll_mux->shift = mode_shift;\n\tif (pll_type == pll_rk3328)\n\t\tpll_mux->mask = PLL_RK3328_MODE_MASK;\n\telse\n\t\tpll_mux->mask = PLL_MODE_MASK;\n\tpll_mux->flags = 0;\n\tpll_mux->lock = &ctx->lock;\n\tpll_mux->hw.init = &init;\n\n\tif (pll_type == pll_rk3036 ||\n\t    pll_type == pll_rk3066 ||\n\t    pll_type == pll_rk3328 ||\n\t    pll_type == pll_rk3399 ||\n\t    pll_type == pll_rk3588)\n\t\tpll_mux->flags |= CLK_MUX_HIWORD_MASK;\n\n\t \n\tpll_parents[0] = parent_names[0];\n\tpll_parents[1] = pll_name;\n\tpll_parents[2] = parent_names[1];\n\n\tinit.name = name;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.ops = pll->pll_mux_ops;\n\tinit.parent_names = pll_parents;\n\tif (pll_type == pll_rk3328)\n\t\tinit.num_parents = 2;\n\telse\n\t\tinit.num_parents = ARRAY_SIZE(pll_parents);\n\n\tmux_clk = clk_register(NULL, &pll_mux->hw);\n\tif (IS_ERR(mux_clk))\n\t\tgoto err_mux;\n\n\t \n\tinit.name = pll_name;\n\n\t \n\tinit.flags = flags | CLK_IGNORE_UNUSED;\n\n\tinit.parent_names = &parent_names[0];\n\tinit.num_parents = 1;\n\n\tif (rate_table) {\n\t\tint len;\n\n\t\t \n\t\tfor (len = 0; rate_table[len].rate != 0; )\n\t\t\tlen++;\n\n\t\tpll->rate_count = len;\n\t\tpll->rate_table = kmemdup(rate_table,\n\t\t\t\t\tpll->rate_count *\n\t\t\t\t\tsizeof(struct rockchip_pll_rate_table),\n\t\t\t\t\tGFP_KERNEL);\n\t\tWARN(!pll->rate_table,\n\t\t\t\"%s: could not allocate rate table for %s\\n\",\n\t\t\t__func__, name);\n\t}\n\n\tswitch (pll_type) {\n\tcase pll_rk3036:\n\tcase pll_rk3328:\n\t\tif (!pll->rate_table)\n\t\t\tinit.ops = &rockchip_rk3036_pll_clk_norate_ops;\n\t\telse\n\t\t\tinit.ops = &rockchip_rk3036_pll_clk_ops;\n\t\tbreak;\n\tcase pll_rk3066:\n\t\tif (!pll->rate_table || IS_ERR(ctx->grf))\n\t\t\tinit.ops = &rockchip_rk3066_pll_clk_norate_ops;\n\t\telse\n\t\t\tinit.ops = &rockchip_rk3066_pll_clk_ops;\n\t\tbreak;\n\tcase pll_rk3399:\n\t\tif (!pll->rate_table)\n\t\t\tinit.ops = &rockchip_rk3399_pll_clk_norate_ops;\n\t\telse\n\t\t\tinit.ops = &rockchip_rk3399_pll_clk_ops;\n\t\tbreak;\n\tcase pll_rk3588:\n\tcase pll_rk3588_core:\n\t\tif (!pll->rate_table)\n\t\t\tinit.ops = &rockchip_rk3588_pll_clk_norate_ops;\n\t\telse\n\t\t\tinit.ops = &rockchip_rk3588_pll_clk_ops;\n\t\tinit.flags = flags;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Unknown pll type for pll clk %s\\n\",\n\t\t\t__func__, name);\n\t}\n\n\tpll->hw.init = &init;\n\tpll->type = pll_type;\n\tpll->reg_base = ctx->reg_base + con_offset;\n\tpll->lock_offset = grf_lock_offset;\n\tpll->lock_shift = lock_shift;\n\tpll->flags = clk_pll_flags;\n\tpll->lock = &ctx->lock;\n\tpll->ctx = ctx;\n\n\tpll_clk = clk_register(NULL, &pll->hw);\n\tif (IS_ERR(pll_clk)) {\n\t\tpr_err(\"%s: failed to register pll clock %s : %ld\\n\",\n\t\t\t__func__, name, PTR_ERR(pll_clk));\n\t\tgoto err_pll;\n\t}\n\n\treturn mux_clk;\n\nerr_pll:\n\tkfree(pll->rate_table);\n\tclk_unregister(mux_clk);\n\tmux_clk = pll_clk;\nerr_mux:\n\tkfree(pll);\n\treturn mux_clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}