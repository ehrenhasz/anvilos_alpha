{
  "module_name": "clk-cpu.c",
  "hash_id": "14559a981e83e524f7ca9816cc9207b51e41b2e1052d49d2fff440900f96cf15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/rockchip/clk-cpu.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include \"clk.h\"\n\n \nstruct rockchip_cpuclk {\n\tstruct clk_hw\t\t\t\thw;\n\tstruct clk\t\t\t\t*alt_parent;\n\tvoid __iomem\t\t\t\t*reg_base;\n\tstruct notifier_block\t\t\tclk_nb;\n\tunsigned int\t\t\t\trate_count;\n\tstruct rockchip_cpuclk_rate_table\t*rate_table;\n\tconst struct rockchip_cpuclk_reg_data\t*reg_data;\n\tspinlock_t\t\t\t\t*lock;\n};\n\n#define to_rockchip_cpuclk_hw(hw) container_of(hw, struct rockchip_cpuclk, hw)\n#define to_rockchip_cpuclk_nb(nb) \\\n\t\t\tcontainer_of(nb, struct rockchip_cpuclk, clk_nb)\n\nstatic const struct rockchip_cpuclk_rate_table *rockchip_get_cpuclk_settings(\n\t\t\t    struct rockchip_cpuclk *cpuclk, unsigned long rate)\n{\n\tconst struct rockchip_cpuclk_rate_table *rate_table =\n\t\t\t\t\t\t\tcpuclk->rate_table;\n\tint i;\n\n\tfor (i = 0; i < cpuclk->rate_count; i++) {\n\t\tif (rate == rate_table[i].prate)\n\t\t\treturn &rate_table[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic unsigned long rockchip_cpuclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct rockchip_cpuclk *cpuclk = to_rockchip_cpuclk_hw(hw);\n\tconst struct rockchip_cpuclk_reg_data *reg_data = cpuclk->reg_data;\n\tu32 clksel0 = readl_relaxed(cpuclk->reg_base + reg_data->core_reg[0]);\n\n\tclksel0 >>= reg_data->div_core_shift[0];\n\tclksel0 &= reg_data->div_core_mask[0];\n\treturn parent_rate / (clksel0 + 1);\n}\n\nstatic const struct clk_ops rockchip_cpuclk_ops = {\n\t.recalc_rate = rockchip_cpuclk_recalc_rate,\n};\n\nstatic void rockchip_cpuclk_set_dividers(struct rockchip_cpuclk *cpuclk,\n\t\t\t\tconst struct rockchip_cpuclk_rate_table *rate)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(rate->divs); i++) {\n\t\tconst struct rockchip_cpuclk_clksel *clksel = &rate->divs[i];\n\n\t\tif (!clksel->reg)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"%s: setting reg 0x%x to 0x%x\\n\",\n\t\t\t __func__, clksel->reg, clksel->val);\n\t\twritel(clksel->val, cpuclk->reg_base + clksel->reg);\n\t}\n}\n\nstatic void rockchip_cpuclk_set_pre_muxs(struct rockchip_cpuclk *cpuclk,\n\t\t\t\t\t const struct rockchip_cpuclk_rate_table *rate)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(rate->pre_muxs); i++) {\n\t\tconst struct rockchip_cpuclk_clksel *clksel = &rate->pre_muxs[i];\n\n\t\tif (!clksel->reg)\n\t\t\tbreak;\n\n\t\tpr_debug(\"%s: setting reg 0x%x to 0x%x\\n\",\n\t\t\t __func__, clksel->reg, clksel->val);\n\t\twritel(clksel->val, cpuclk->reg_base + clksel->reg);\n\t}\n}\n\nstatic void rockchip_cpuclk_set_post_muxs(struct rockchip_cpuclk *cpuclk,\n\t\t\t\t\t  const struct rockchip_cpuclk_rate_table *rate)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(rate->post_muxs); i++) {\n\t\tconst struct rockchip_cpuclk_clksel *clksel = &rate->post_muxs[i];\n\n\t\tif (!clksel->reg)\n\t\t\tbreak;\n\n\t\tpr_debug(\"%s: setting reg 0x%x to 0x%x\\n\",\n\t\t\t __func__, clksel->reg, clksel->val);\n\t\twritel(clksel->val, cpuclk->reg_base + clksel->reg);\n\t}\n}\n\nstatic int rockchip_cpuclk_pre_rate_change(struct rockchip_cpuclk *cpuclk,\n\t\t\t\t\t   struct clk_notifier_data *ndata)\n{\n\tconst struct rockchip_cpuclk_reg_data *reg_data = cpuclk->reg_data;\n\tconst struct rockchip_cpuclk_rate_table *rate;\n\tunsigned long alt_prate, alt_div;\n\tunsigned long flags;\n\tint i = 0;\n\n\t \n\trate = rockchip_get_cpuclk_settings(cpuclk, ndata->new_rate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for cpuclk\\n\",\n\t\t       __func__, ndata->new_rate);\n\t\treturn -EINVAL;\n\t}\n\n\talt_prate = clk_get_rate(cpuclk->alt_parent);\n\n\tspin_lock_irqsave(cpuclk->lock, flags);\n\n\t \n\tif (alt_prate > ndata->old_rate) {\n\t\t \n\t\talt_div =  DIV_ROUND_UP(alt_prate, ndata->old_rate) - 1;\n\t\tif (alt_div > reg_data->div_core_mask[0]) {\n\t\t\tpr_warn(\"%s: limiting alt-divider %lu to %d\\n\",\n\t\t\t\t__func__, alt_div, reg_data->div_core_mask[0]);\n\t\t\talt_div = reg_data->div_core_mask[0];\n\t\t}\n\n\t\t \n\t\tpr_debug(\"%s: setting div %lu as alt-rate %lu > old-rate %lu\\n\",\n\t\t\t __func__, alt_div, alt_prate, ndata->old_rate);\n\n\t\tfor (i = 0; i < reg_data->num_cores; i++) {\n\t\t\twritel(HIWORD_UPDATE(alt_div, reg_data->div_core_mask[i],\n\t\t\t\t\t     reg_data->div_core_shift[i]),\n\t\t\t       cpuclk->reg_base + reg_data->core_reg[i]);\n\t\t}\n\t}\n\n\trockchip_cpuclk_set_pre_muxs(cpuclk, rate);\n\n\t \n\tif (reg_data->mux_core_reg)\n\t\twritel(HIWORD_UPDATE(reg_data->mux_core_alt,\n\t\t\t\t     reg_data->mux_core_mask,\n\t\t\t\t     reg_data->mux_core_shift),\n\t\t       cpuclk->reg_base + reg_data->mux_core_reg);\n\telse\n\t\twritel(HIWORD_UPDATE(reg_data->mux_core_alt,\n\t\t\t\t     reg_data->mux_core_mask,\n\t\t\t\t     reg_data->mux_core_shift),\n\t\t       cpuclk->reg_base + reg_data->core_reg[0]);\n\n\tspin_unlock_irqrestore(cpuclk->lock, flags);\n\treturn 0;\n}\n\nstatic int rockchip_cpuclk_post_rate_change(struct rockchip_cpuclk *cpuclk,\n\t\t\t\t\t    struct clk_notifier_data *ndata)\n{\n\tconst struct rockchip_cpuclk_reg_data *reg_data = cpuclk->reg_data;\n\tconst struct rockchip_cpuclk_rate_table *rate;\n\tunsigned long flags;\n\tint i = 0;\n\n\trate = rockchip_get_cpuclk_settings(cpuclk, ndata->new_rate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for cpuclk\\n\",\n\t\t       __func__, ndata->new_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(cpuclk->lock, flags);\n\n\tif (ndata->old_rate < ndata->new_rate)\n\t\trockchip_cpuclk_set_dividers(cpuclk, rate);\n\n\t \n\n\tif (reg_data->mux_core_reg)\n\t\twritel(HIWORD_UPDATE(reg_data->mux_core_main,\n\t\t\t\t     reg_data->mux_core_mask,\n\t\t\t\t     reg_data->mux_core_shift),\n\t\t       cpuclk->reg_base + reg_data->mux_core_reg);\n\telse\n\t\twritel(HIWORD_UPDATE(reg_data->mux_core_main,\n\t\t\t\t     reg_data->mux_core_mask,\n\t\t\t\t     reg_data->mux_core_shift),\n\t\t       cpuclk->reg_base + reg_data->core_reg[0]);\n\n\trockchip_cpuclk_set_post_muxs(cpuclk, rate);\n\n\t \n\tfor (i = 0; i < reg_data->num_cores; i++) {\n\t\twritel(HIWORD_UPDATE(0, reg_data->div_core_mask[i],\n\t\t\t\t     reg_data->div_core_shift[i]),\n\t\t       cpuclk->reg_base + reg_data->core_reg[i]);\n\t}\n\n\tif (ndata->old_rate > ndata->new_rate)\n\t\trockchip_cpuclk_set_dividers(cpuclk, rate);\n\n\tspin_unlock_irqrestore(cpuclk->lock, flags);\n\treturn 0;\n}\n\n \nstatic int rockchip_cpuclk_notifier_cb(struct notifier_block *nb,\n\t\t\t\t\tunsigned long event, void *data)\n{\n\tstruct clk_notifier_data *ndata = data;\n\tstruct rockchip_cpuclk *cpuclk = to_rockchip_cpuclk_nb(nb);\n\tint ret = 0;\n\n\tpr_debug(\"%s: event %lu, old_rate %lu, new_rate: %lu\\n\",\n\t\t __func__, event, ndata->old_rate, ndata->new_rate);\n\tif (event == PRE_RATE_CHANGE)\n\t\tret = rockchip_cpuclk_pre_rate_change(cpuclk, ndata);\n\telse if (event == POST_RATE_CHANGE)\n\t\tret = rockchip_cpuclk_post_rate_change(cpuclk, ndata);\n\n\treturn notifier_from_errno(ret);\n}\n\nstruct clk *rockchip_clk_register_cpuclk(const char *name,\n\t\t\tconst char *const *parent_names, u8 num_parents,\n\t\t\tconst struct rockchip_cpuclk_reg_data *reg_data,\n\t\t\tconst struct rockchip_cpuclk_rate_table *rates,\n\t\t\tint nrates, void __iomem *reg_base, spinlock_t *lock)\n{\n\tstruct rockchip_cpuclk *cpuclk;\n\tstruct clk_init_data init;\n\tstruct clk *clk, *cclk;\n\tint ret;\n\n\tif (num_parents < 2) {\n\t\tpr_err(\"%s: needs at least two parent clocks\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tcpuclk = kzalloc(sizeof(*cpuclk), GFP_KERNEL);\n\tif (!cpuclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.parent_names = &parent_names[reg_data->mux_core_main];\n\tinit.num_parents = 1;\n\tinit.ops = &rockchip_cpuclk_ops;\n\n\t \n\tinit.flags = (nrates > 0) ? CLK_SET_RATE_PARENT : 0;\n\n\t \n\tinit.flags |= CLK_SET_RATE_NO_REPARENT;\n\n\tinit.flags |= CLK_GET_RATE_NOCACHE;\n\n\tcpuclk->reg_base = reg_base;\n\tcpuclk->lock = lock;\n\tcpuclk->reg_data = reg_data;\n\tcpuclk->clk_nb.notifier_call = rockchip_cpuclk_notifier_cb;\n\tcpuclk->hw.init = &init;\n\n\tcpuclk->alt_parent = __clk_lookup(parent_names[reg_data->mux_core_alt]);\n\tif (!cpuclk->alt_parent) {\n\t\tpr_err(\"%s: could not lookup alternate parent: (%d)\\n\",\n\t\t       __func__, reg_data->mux_core_alt);\n\t\tret = -EINVAL;\n\t\tgoto free_cpuclk;\n\t}\n\n\tret = clk_prepare_enable(cpuclk->alt_parent);\n\tif (ret) {\n\t\tpr_err(\"%s: could not enable alternate parent\\n\",\n\t\t       __func__);\n\t\tgoto free_cpuclk;\n\t}\n\n\tclk = __clk_lookup(parent_names[reg_data->mux_core_main]);\n\tif (!clk) {\n\t\tpr_err(\"%s: could not lookup parent clock: (%d) %s\\n\",\n\t\t       __func__, reg_data->mux_core_main,\n\t\t       parent_names[reg_data->mux_core_main]);\n\t\tret = -EINVAL;\n\t\tgoto free_alt_parent;\n\t}\n\n\tret = clk_notifier_register(clk, &cpuclk->clk_nb);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to register clock notifier for %s\\n\",\n\t\t\t\t__func__, name);\n\t\tgoto free_alt_parent;\n\t}\n\n\tif (nrates > 0) {\n\t\tcpuclk->rate_count = nrates;\n\t\tcpuclk->rate_table = kmemdup(rates,\n\t\t\t\t\t     sizeof(*rates) * nrates,\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!cpuclk->rate_table) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unregister_notifier;\n\t\t}\n\t}\n\n\tcclk = clk_register(NULL, &cpuclk->hw);\n\tif (IS_ERR(cclk)) {\n\t\tpr_err(\"%s: could not register cpuclk %s\\n\", __func__,\tname);\n\t\tret = PTR_ERR(cclk);\n\t\tgoto free_rate_table;\n\t}\n\n\treturn cclk;\n\nfree_rate_table:\n\tkfree(cpuclk->rate_table);\nunregister_notifier:\n\tclk_notifier_unregister(clk, &cpuclk->clk_nb);\nfree_alt_parent:\n\tclk_disable_unprepare(cpuclk->alt_parent);\nfree_cpuclk:\n\tkfree(cpuclk);\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}