{
  "module_name": "clk-mmc-phase.c",
  "hash_id": "c969914af758910000f68f05744e003342305254b971611cd0d5e702aa36ceeb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/rockchip/clk-mmc-phase.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include \"clk.h\"\n\nstruct rockchip_mmc_clock {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*reg;\n\tint\t\tid;\n\tint\t\tshift;\n\tint\t\tcached_phase;\n\tstruct notifier_block clk_rate_change_nb;\n};\n\n#define to_mmc_clock(_hw) container_of(_hw, struct rockchip_mmc_clock, hw)\n\n#define RK3288_MMC_CLKGEN_DIV 2\n\nstatic unsigned long rockchip_mmc_recalc(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\treturn parent_rate / RK3288_MMC_CLKGEN_DIV;\n}\n\n#define ROCKCHIP_MMC_DELAY_SEL BIT(10)\n#define ROCKCHIP_MMC_DEGREE_MASK 0x3\n#define ROCKCHIP_MMC_DELAYNUM_OFFSET 2\n#define ROCKCHIP_MMC_DELAYNUM_MASK (0xff << ROCKCHIP_MMC_DELAYNUM_OFFSET)\n\n#define PSECS_PER_SEC 1000000000000LL\n\n \n#define ROCKCHIP_MMC_DELAY_ELEMENT_PSEC 60\n\nstatic int rockchip_mmc_get_phase(struct clk_hw *hw)\n{\n\tstruct rockchip_mmc_clock *mmc_clock = to_mmc_clock(hw);\n\tunsigned long rate = clk_hw_get_rate(hw);\n\tu32 raw_value;\n\tu16 degrees;\n\tu32 delay_num = 0;\n\n\t \n\tif (!rate)\n\t\treturn 0;\n\n\traw_value = readl(mmc_clock->reg) >> (mmc_clock->shift);\n\n\tdegrees = (raw_value & ROCKCHIP_MMC_DEGREE_MASK) * 90;\n\n\tif (raw_value & ROCKCHIP_MMC_DELAY_SEL) {\n\t\t \n\t\tunsigned long factor = (ROCKCHIP_MMC_DELAY_ELEMENT_PSEC / 10) *\n\t\t\t\t\t36 * (rate / 10000);\n\n\t\tdelay_num = (raw_value & ROCKCHIP_MMC_DELAYNUM_MASK);\n\t\tdelay_num >>= ROCKCHIP_MMC_DELAYNUM_OFFSET;\n\t\tdegrees += DIV_ROUND_CLOSEST(delay_num * factor, 1000000);\n\t}\n\n\treturn degrees % 360;\n}\n\nstatic int rockchip_mmc_set_phase(struct clk_hw *hw, int degrees)\n{\n\tstruct rockchip_mmc_clock *mmc_clock = to_mmc_clock(hw);\n\tunsigned long rate = clk_hw_get_rate(hw);\n\tu8 nineties, remainder;\n\tu8 delay_num;\n\tu32 raw_value;\n\tu32 delay;\n\n\t \n\tif (!rate) {\n\t\tpr_err(\"%s: invalid clk rate\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tnineties = degrees / 90;\n\tremainder = (degrees % 90);\n\n\t \n\n\t \n\tdelay = 10000000;  \n\tdelay *= remainder;\n\tdelay = DIV_ROUND_CLOSEST(delay,\n\t\t\t(rate / 1000) * 36 *\n\t\t\t\t(ROCKCHIP_MMC_DELAY_ELEMENT_PSEC / 10));\n\n\tdelay_num = (u8) min_t(u32, delay, 255);\n\n\traw_value = delay_num ? ROCKCHIP_MMC_DELAY_SEL : 0;\n\traw_value |= delay_num << ROCKCHIP_MMC_DELAYNUM_OFFSET;\n\traw_value |= nineties;\n\twritel(HIWORD_UPDATE(raw_value, 0x07ff, mmc_clock->shift),\n\t       mmc_clock->reg);\n\n\tpr_debug(\"%s->set_phase(%d) delay_nums=%u reg[0x%p]=0x%03x actual_degrees=%d\\n\",\n\t\tclk_hw_get_name(hw), degrees, delay_num,\n\t\tmmc_clock->reg, raw_value>>(mmc_clock->shift),\n\t\trockchip_mmc_get_phase(hw)\n\t);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops rockchip_mmc_clk_ops = {\n\t.recalc_rate\t= rockchip_mmc_recalc,\n\t.get_phase\t= rockchip_mmc_get_phase,\n\t.set_phase\t= rockchip_mmc_set_phase,\n};\n\n#define to_rockchip_mmc_clock(x) \\\n\tcontainer_of(x, struct rockchip_mmc_clock, clk_rate_change_nb)\nstatic int rockchip_mmc_clk_rate_notify(struct notifier_block *nb,\n\t\t\t\t\tunsigned long event, void *data)\n{\n\tstruct rockchip_mmc_clock *mmc_clock = to_rockchip_mmc_clock(nb);\n\tstruct clk_notifier_data *ndata = data;\n\n\t \n\tif (ndata->old_rate <= ndata->new_rate)\n\t\treturn NOTIFY_DONE;\n\n\tif (event == PRE_RATE_CHANGE)\n\t\tmmc_clock->cached_phase =\n\t\t\trockchip_mmc_get_phase(&mmc_clock->hw);\n\telse if (mmc_clock->cached_phase != -EINVAL &&\n\t\t event == POST_RATE_CHANGE)\n\t\trockchip_mmc_set_phase(&mmc_clock->hw, mmc_clock->cached_phase);\n\n\treturn NOTIFY_DONE;\n}\n\nstruct clk *rockchip_clk_register_mmc(const char *name,\n\t\t\t\tconst char *const *parent_names, u8 num_parents,\n\t\t\t\tvoid __iomem *reg, int shift)\n{\n\tstruct clk_init_data init;\n\tstruct rockchip_mmc_clock *mmc_clock;\n\tstruct clk *clk;\n\tint ret;\n\n\tmmc_clock = kmalloc(sizeof(*mmc_clock), GFP_KERNEL);\n\tif (!mmc_clock)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.flags = 0;\n\tinit.num_parents = num_parents;\n\tinit.parent_names = parent_names;\n\tinit.ops = &rockchip_mmc_clk_ops;\n\n\tmmc_clock->hw.init = &init;\n\tmmc_clock->reg = reg;\n\tmmc_clock->shift = shift;\n\n\tclk = clk_register(NULL, &mmc_clock->hw);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tgoto err_register;\n\t}\n\n\tmmc_clock->clk_rate_change_nb.notifier_call =\n\t\t\t\t&rockchip_mmc_clk_rate_notify;\n\tret = clk_notifier_register(clk, &mmc_clock->clk_rate_change_nb);\n\tif (ret)\n\t\tgoto err_notifier;\n\n\treturn clk;\nerr_notifier:\n\tclk_unregister(clk);\nerr_register:\n\tkfree(mmc_clock);\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}