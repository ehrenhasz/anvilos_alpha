{
  "module_name": "clk-half-divider.c",
  "hash_id": "30c5e2a11223587c9d409416a68220b6bcc641107fbc57d18fc2387968afa8b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/rockchip/clk-half-divider.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include \"clk.h\"\n\n#define div_mask(width)\t((1 << (width)) - 1)\n\nstatic bool _is_best_half_div(unsigned long rate, unsigned long now,\n\t\t\t      unsigned long best, unsigned long flags)\n{\n\tif (flags & CLK_DIVIDER_ROUND_CLOSEST)\n\t\treturn abs(rate - now) < abs(rate - best);\n\n\treturn now <= rate && now > best;\n}\n\nstatic unsigned long clk_half_divider_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\tunsigned int val;\n\n\tval = readl(divider->reg) >> divider->shift;\n\tval &= div_mask(divider->width);\n\tval = val * 2 + 3;\n\n\treturn DIV_ROUND_UP_ULL(((u64)parent_rate * 2), val);\n}\n\nstatic int clk_half_divider_bestdiv(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *best_parent_rate, u8 width,\n\t\t\t\t    unsigned long flags)\n{\n\tunsigned int i, bestdiv = 0;\n\tunsigned long parent_rate, best = 0, now, maxdiv;\n\tunsigned long parent_rate_saved = *best_parent_rate;\n\n\tif (!rate)\n\t\trate = 1;\n\n\tmaxdiv = div_mask(width);\n\n\tif (!(clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)) {\n\t\tparent_rate = *best_parent_rate;\n\t\tbestdiv = DIV_ROUND_UP_ULL(((u64)parent_rate * 2), rate);\n\t\tif (bestdiv < 3)\n\t\t\tbestdiv = 0;\n\t\telse\n\t\t\tbestdiv = (bestdiv - 3) / 2;\n\t\tbestdiv = bestdiv > maxdiv ? maxdiv : bestdiv;\n\t\treturn bestdiv;\n\t}\n\n\t \n\tmaxdiv = min(ULONG_MAX / rate, maxdiv);\n\n\tfor (i = 0; i <= maxdiv; i++) {\n\t\tif (((u64)rate * (i * 2 + 3)) == ((u64)parent_rate_saved * 2)) {\n\t\t\t \n\t\t\t*best_parent_rate = parent_rate_saved;\n\t\t\treturn i;\n\t\t}\n\t\tparent_rate = clk_hw_round_rate(clk_hw_get_parent(hw),\n\t\t\t\t\t\t((u64)rate * (i * 2 + 3)) / 2);\n\t\tnow = DIV_ROUND_UP_ULL(((u64)parent_rate * 2),\n\t\t\t\t       (i * 2 + 3));\n\n\t\tif (_is_best_half_div(rate, now, best, flags)) {\n\t\t\tbestdiv = i;\n\t\t\tbest = now;\n\t\t\t*best_parent_rate = parent_rate;\n\t\t}\n\t}\n\n\tif (!bestdiv) {\n\t\tbestdiv = div_mask(width);\n\t\t*best_parent_rate = clk_hw_round_rate(clk_hw_get_parent(hw), 1);\n\t}\n\n\treturn bestdiv;\n}\n\nstatic long clk_half_divider_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\tunsigned long *prate)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\tint div;\n\n\tdiv = clk_half_divider_bestdiv(hw, rate, prate,\n\t\t\t\t       divider->width,\n\t\t\t\t       divider->flags);\n\n\treturn DIV_ROUND_UP_ULL(((u64)*prate * 2), div * 2 + 3);\n}\n\nstatic int clk_half_divider_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\tunsigned int value;\n\tunsigned long flags = 0;\n\tu32 val;\n\n\tvalue = DIV_ROUND_UP_ULL(((u64)parent_rate * 2), rate);\n\tvalue = (value - 3) / 2;\n\tvalue =  min_t(unsigned int, value, div_mask(divider->width));\n\n\tif (divider->lock)\n\t\tspin_lock_irqsave(divider->lock, flags);\n\telse\n\t\t__acquire(divider->lock);\n\n\tif (divider->flags & CLK_DIVIDER_HIWORD_MASK) {\n\t\tval = div_mask(divider->width) << (divider->shift + 16);\n\t} else {\n\t\tval = readl(divider->reg);\n\t\tval &= ~(div_mask(divider->width) << divider->shift);\n\t}\n\tval |= value << divider->shift;\n\twritel(val, divider->reg);\n\n\tif (divider->lock)\n\t\tspin_unlock_irqrestore(divider->lock, flags);\n\telse\n\t\t__release(divider->lock);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_half_divider_ops = {\n\t.recalc_rate = clk_half_divider_recalc_rate,\n\t.round_rate = clk_half_divider_round_rate,\n\t.set_rate = clk_half_divider_set_rate,\n};\n\n \nstruct clk *rockchip_clk_register_halfdiv(const char *name,\n\t\t\t\t\t  const char *const *parent_names,\n\t\t\t\t\t  u8 num_parents, void __iomem *base,\n\t\t\t\t\t  int muxdiv_offset, u8 mux_shift,\n\t\t\t\t\t  u8 mux_width, u8 mux_flags,\n\t\t\t\t\t  u8 div_shift, u8 div_width,\n\t\t\t\t\t  u8 div_flags, int gate_offset,\n\t\t\t\t\t  u8 gate_shift, u8 gate_flags,\n\t\t\t\t\t  unsigned long flags,\n\t\t\t\t\t  spinlock_t *lock)\n{\n\tstruct clk_hw *hw = ERR_PTR(-ENOMEM);\n\tstruct clk_mux *mux = NULL;\n\tstruct clk_gate *gate = NULL;\n\tstruct clk_divider *div = NULL;\n\tconst struct clk_ops *mux_ops = NULL, *div_ops = NULL,\n\t\t\t     *gate_ops = NULL;\n\n\tif (num_parents > 1) {\n\t\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\t\tif (!mux)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tmux->reg = base + muxdiv_offset;\n\t\tmux->shift = mux_shift;\n\t\tmux->mask = BIT(mux_width) - 1;\n\t\tmux->flags = mux_flags;\n\t\tmux->lock = lock;\n\t\tmux_ops = (mux_flags & CLK_MUX_READ_ONLY) ? &clk_mux_ro_ops\n\t\t\t\t\t\t\t: &clk_mux_ops;\n\t}\n\n\tif (gate_offset >= 0) {\n\t\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\t\tif (!gate)\n\t\t\tgoto err_gate;\n\n\t\tgate->flags = gate_flags;\n\t\tgate->reg = base + gate_offset;\n\t\tgate->bit_idx = gate_shift;\n\t\tgate->lock = lock;\n\t\tgate_ops = &clk_gate_ops;\n\t}\n\n\tif (div_width > 0) {\n\t\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\t\tif (!div)\n\t\t\tgoto err_div;\n\n\t\tdiv->flags = div_flags;\n\t\tdiv->reg = base + muxdiv_offset;\n\t\tdiv->shift = div_shift;\n\t\tdiv->width = div_width;\n\t\tdiv->lock = lock;\n\t\tdiv_ops = &clk_half_divider_ops;\n\t}\n\n\thw = clk_hw_register_composite(NULL, name, parent_names, num_parents,\n\t\t\t\t       mux ? &mux->hw : NULL, mux_ops,\n\t\t\t\t       div ? &div->hw : NULL, div_ops,\n\t\t\t\t       gate ? &gate->hw : NULL, gate_ops,\n\t\t\t\t       flags);\n\tif (IS_ERR(hw))\n\t\tgoto err_div;\n\n\treturn hw->clk;\nerr_div:\n\tkfree(gate);\nerr_gate:\n\tkfree(mux);\n\treturn ERR_CAST(hw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}