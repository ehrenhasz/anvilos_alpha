{
  "module_name": "softrst.c",
  "hash_id": "cc945e555a6f3254ef1b419c6479b8710dc5ae4a478e1a2c7735c43c6b88308a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/rockchip/softrst.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/reset-controller.h>\n#include <linux/spinlock.h>\n#include \"clk.h\"\n\nstruct rockchip_softrst {\n\tstruct reset_controller_dev\trcdev;\n\tconst int\t\t\t*lut;\n\tvoid __iomem\t\t\t*reg_base;\n\tint\t\t\t\tnum_regs;\n\tint\t\t\t\tnum_per_reg;\n\tu8\t\t\t\tflags;\n\tspinlock_t\t\t\tlock;\n};\n\nstatic int rockchip_softrst_assert(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct rockchip_softrst *softrst = container_of(rcdev,\n\t\t\t\t\t\t     struct rockchip_softrst,\n\t\t\t\t\t\t     rcdev);\n\tint bank, offset;\n\n\tif (softrst->lut)\n\t\tid = softrst->lut[id];\n\n\tbank = id / softrst->num_per_reg;\n\toffset = id % softrst->num_per_reg;\n\n\tif (softrst->flags & ROCKCHIP_SOFTRST_HIWORD_MASK) {\n\t\twritel(BIT(offset) | (BIT(offset) << 16),\n\t\t       softrst->reg_base + (bank * 4));\n\t} else {\n\t\tunsigned long flags;\n\t\tu32 reg;\n\n\t\tspin_lock_irqsave(&softrst->lock, flags);\n\n\t\treg = readl(softrst->reg_base + (bank * 4));\n\t\twritel(reg | BIT(offset), softrst->reg_base + (bank * 4));\n\n\t\tspin_unlock_irqrestore(&softrst->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_softrst_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\tstruct rockchip_softrst *softrst = container_of(rcdev,\n\t\t\t\t\t\t     struct rockchip_softrst,\n\t\t\t\t\t\t     rcdev);\n\tint bank, offset;\n\n\tif (softrst->lut)\n\t\tid = softrst->lut[id];\n\n\tbank = id / softrst->num_per_reg;\n\toffset = id % softrst->num_per_reg;\n\n\tif (softrst->flags & ROCKCHIP_SOFTRST_HIWORD_MASK) {\n\t\twritel((BIT(offset) << 16), softrst->reg_base + (bank * 4));\n\t} else {\n\t\tunsigned long flags;\n\t\tu32 reg;\n\n\t\tspin_lock_irqsave(&softrst->lock, flags);\n\n\t\treg = readl(softrst->reg_base + (bank * 4));\n\t\twritel(reg & ~BIT(offset), softrst->reg_base + (bank * 4));\n\n\t\tspin_unlock_irqrestore(&softrst->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct reset_control_ops rockchip_softrst_ops = {\n\t.assert\t\t= rockchip_softrst_assert,\n\t.deassert\t= rockchip_softrst_deassert,\n};\n\nvoid rockchip_register_softrst_lut(struct device_node *np,\n\t\t\t\t   const int *lookup_table,\n\t\t\t\t   unsigned int num_regs,\n\t\t\t\t   void __iomem *base, u8 flags)\n{\n\tstruct rockchip_softrst *softrst;\n\tint ret;\n\n\tsoftrst = kzalloc(sizeof(*softrst), GFP_KERNEL);\n\tif (!softrst)\n\t\treturn;\n\n\tspin_lock_init(&softrst->lock);\n\n\tsoftrst->reg_base = base;\n\tsoftrst->lut = lookup_table;\n\tsoftrst->flags = flags;\n\tsoftrst->num_regs = num_regs;\n\tsoftrst->num_per_reg = (flags & ROCKCHIP_SOFTRST_HIWORD_MASK) ? 16\n\t\t\t\t\t\t\t\t      : 32;\n\n\tsoftrst->rcdev.owner = THIS_MODULE;\n\tif (lookup_table)\n\t\tsoftrst->rcdev.nr_resets = num_regs;\n\telse\n\t\tsoftrst->rcdev.nr_resets = num_regs * softrst->num_per_reg;\n\tsoftrst->rcdev.ops = &rockchip_softrst_ops;\n\tsoftrst->rcdev.of_node = np;\n\tret = reset_controller_register(&softrst->rcdev);\n\tif (ret) {\n\t\tpr_err(\"%s: could not register reset controller, %d\\n\",\n\t\t       __func__, ret);\n\t\tkfree(softrst);\n\t}\n};\nEXPORT_SYMBOL_GPL(rockchip_register_softrst_lut);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}