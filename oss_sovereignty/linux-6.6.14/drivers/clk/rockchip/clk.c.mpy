{
  "module_name": "clk.c",
  "hash_id": "f6792ed48979d0e9d077b9bed113e015c9e3a44bde6e8b596bc0116a800f132d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/rockchip/clk.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/reboot.h>\n\n#include \"../clk-fractional-divider.h\"\n#include \"clk.h\"\n\n \nstatic struct clk *rockchip_clk_register_branch(const char *name,\n\t\tconst char *const *parent_names, u8 num_parents,\n\t\tvoid __iomem *base,\n\t\tint muxdiv_offset, u8 mux_shift, u8 mux_width, u8 mux_flags,\n\t\tu32 *mux_table,\n\t\tint div_offset, u8 div_shift, u8 div_width, u8 div_flags,\n\t\tstruct clk_div_table *div_table, int gate_offset,\n\t\tu8 gate_shift, u8 gate_flags, unsigned long flags,\n\t\tspinlock_t *lock)\n{\n\tstruct clk_hw *hw;\n\tstruct clk_mux *mux = NULL;\n\tstruct clk_gate *gate = NULL;\n\tstruct clk_divider *div = NULL;\n\tconst struct clk_ops *mux_ops = NULL, *div_ops = NULL,\n\t\t\t     *gate_ops = NULL;\n\tint ret;\n\n\tif (num_parents > 1) {\n\t\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\t\tif (!mux)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tmux->reg = base + muxdiv_offset;\n\t\tmux->shift = mux_shift;\n\t\tmux->mask = BIT(mux_width) - 1;\n\t\tmux->flags = mux_flags;\n\t\tmux->table = mux_table;\n\t\tmux->lock = lock;\n\t\tmux_ops = (mux_flags & CLK_MUX_READ_ONLY) ? &clk_mux_ro_ops\n\t\t\t\t\t\t\t: &clk_mux_ops;\n\t}\n\n\tif (gate_offset >= 0) {\n\t\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\t\tif (!gate) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_gate;\n\t\t}\n\n\t\tgate->flags = gate_flags;\n\t\tgate->reg = base + gate_offset;\n\t\tgate->bit_idx = gate_shift;\n\t\tgate->lock = lock;\n\t\tgate_ops = &clk_gate_ops;\n\t}\n\n\tif (div_width > 0) {\n\t\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\t\tif (!div) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_div;\n\t\t}\n\n\t\tdiv->flags = div_flags;\n\t\tif (div_offset)\n\t\t\tdiv->reg = base + div_offset;\n\t\telse\n\t\t\tdiv->reg = base + muxdiv_offset;\n\t\tdiv->shift = div_shift;\n\t\tdiv->width = div_width;\n\t\tdiv->lock = lock;\n\t\tdiv->table = div_table;\n\t\tdiv_ops = (div_flags & CLK_DIVIDER_READ_ONLY)\n\t\t\t\t\t\t? &clk_divider_ro_ops\n\t\t\t\t\t\t: &clk_divider_ops;\n\t}\n\n\thw = clk_hw_register_composite(NULL, name, parent_names, num_parents,\n\t\t\t\t       mux ? &mux->hw : NULL, mux_ops,\n\t\t\t\t       div ? &div->hw : NULL, div_ops,\n\t\t\t\t       gate ? &gate->hw : NULL, gate_ops,\n\t\t\t\t       flags);\n\tif (IS_ERR(hw)) {\n\t\tkfree(div);\n\t\tkfree(gate);\n\t\treturn ERR_CAST(hw);\n\t}\n\n\treturn hw->clk;\nerr_div:\n\tkfree(gate);\nerr_gate:\n\tkfree(mux);\n\treturn ERR_PTR(ret);\n}\n\nstruct rockchip_clk_frac {\n\tstruct notifier_block\t\t\tclk_nb;\n\tstruct clk_fractional_divider\t\tdiv;\n\tstruct clk_gate\t\t\t\tgate;\n\n\tstruct clk_mux\t\t\t\tmux;\n\tconst struct clk_ops\t\t\t*mux_ops;\n\tint\t\t\t\t\tmux_frac_idx;\n\n\tbool\t\t\t\t\trate_change_remuxed;\n\tint\t\t\t\t\trate_change_idx;\n};\n\n#define to_rockchip_clk_frac_nb(nb) \\\n\t\t\tcontainer_of(nb, struct rockchip_clk_frac, clk_nb)\n\nstatic int rockchip_clk_frac_notifier_cb(struct notifier_block *nb,\n\t\t\t\t\t unsigned long event, void *data)\n{\n\tstruct clk_notifier_data *ndata = data;\n\tstruct rockchip_clk_frac *frac = to_rockchip_clk_frac_nb(nb);\n\tstruct clk_mux *frac_mux = &frac->mux;\n\tint ret = 0;\n\n\tpr_debug(\"%s: event %lu, old_rate %lu, new_rate: %lu\\n\",\n\t\t __func__, event, ndata->old_rate, ndata->new_rate);\n\tif (event == PRE_RATE_CHANGE) {\n\t\tfrac->rate_change_idx =\n\t\t\t\tfrac->mux_ops->get_parent(&frac_mux->hw);\n\t\tif (frac->rate_change_idx != frac->mux_frac_idx) {\n\t\t\tfrac->mux_ops->set_parent(&frac_mux->hw,\n\t\t\t\t\t\t  frac->mux_frac_idx);\n\t\t\tfrac->rate_change_remuxed = 1;\n\t\t}\n\t} else if (event == POST_RATE_CHANGE) {\n\t\t \n\t\tif (frac->rate_change_remuxed) {\n\t\t\tfrac->mux_ops->set_parent(&frac_mux->hw,\n\t\t\t\t\t\t  frac->rate_change_idx);\n\t\t\tfrac->rate_change_remuxed = 0;\n\t\t}\n\t}\n\n\treturn notifier_from_errno(ret);\n}\n\n \nstatic void rockchip_fractional_approximation(struct clk_hw *hw,\n\t\tunsigned long rate, unsigned long *parent_rate,\n\t\tunsigned long *m, unsigned long *n)\n{\n\tstruct clk_fractional_divider *fd = to_clk_fd(hw);\n\tunsigned long p_rate, p_parent_rate;\n\tstruct clk_hw *p_parent;\n\n\tp_rate = clk_hw_get_rate(clk_hw_get_parent(hw));\n\tif ((rate * 20 > p_rate) && (p_rate % rate != 0)) {\n\t\tp_parent = clk_hw_get_parent(clk_hw_get_parent(hw));\n\t\tp_parent_rate = clk_hw_get_rate(p_parent);\n\t\t*parent_rate = p_parent_rate;\n\t}\n\n\tfd->flags |= CLK_FRAC_DIVIDER_POWER_OF_TWO_PS;\n\n\tclk_fractional_divider_general_approximation(hw, rate, parent_rate, m, n);\n}\n\nstatic void rockchip_clk_add_lookup(struct rockchip_clk_provider *ctx,\n\t\t\t\t    struct clk *clk, unsigned int id)\n{\n\tctx->clk_data.clks[id] = clk;\n}\n\nstatic struct clk *rockchip_clk_register_frac_branch(\n\t\tstruct rockchip_clk_provider *ctx, const char *name,\n\t\tconst char *const *parent_names, u8 num_parents,\n\t\tvoid __iomem *base, int muxdiv_offset, u8 div_flags,\n\t\tint gate_offset, u8 gate_shift, u8 gate_flags,\n\t\tunsigned long flags, struct rockchip_clk_branch *child,\n\t\tspinlock_t *lock)\n{\n\tstruct clk_hw *hw;\n\tstruct rockchip_clk_frac *frac;\n\tstruct clk_gate *gate = NULL;\n\tstruct clk_fractional_divider *div = NULL;\n\tconst struct clk_ops *div_ops = NULL, *gate_ops = NULL;\n\n\tif (muxdiv_offset < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (child && child->branch_type != branch_mux) {\n\t\tpr_err(\"%s: fractional child clock for %s can only be a mux\\n\",\n\t\t       __func__, name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfrac = kzalloc(sizeof(*frac), GFP_KERNEL);\n\tif (!frac)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (gate_offset >= 0) {\n\t\tgate = &frac->gate;\n\t\tgate->flags = gate_flags;\n\t\tgate->reg = base + gate_offset;\n\t\tgate->bit_idx = gate_shift;\n\t\tgate->lock = lock;\n\t\tgate_ops = &clk_gate_ops;\n\t}\n\n\tdiv = &frac->div;\n\tdiv->flags = div_flags;\n\tdiv->reg = base + muxdiv_offset;\n\tdiv->mshift = 16;\n\tdiv->mwidth = 16;\n\tdiv->nshift = 0;\n\tdiv->nwidth = 16;\n\tdiv->lock = lock;\n\tdiv->approximation = rockchip_fractional_approximation;\n\tdiv_ops = &clk_fractional_divider_ops;\n\n\thw = clk_hw_register_composite(NULL, name, parent_names, num_parents,\n\t\t\t\t       NULL, NULL,\n\t\t\t\t       &div->hw, div_ops,\n\t\t\t\t       gate ? &gate->hw : NULL, gate_ops,\n\t\t\t\t       flags | CLK_SET_RATE_UNGATE);\n\tif (IS_ERR(hw)) {\n\t\tkfree(frac);\n\t\treturn ERR_CAST(hw);\n\t}\n\n\tif (child) {\n\t\tstruct clk_mux *frac_mux = &frac->mux;\n\t\tstruct clk_init_data init;\n\t\tstruct clk *mux_clk;\n\t\tint ret;\n\n\t\tfrac->mux_frac_idx = match_string(child->parent_names,\n\t\t\t\t\t\t  child->num_parents, name);\n\t\tfrac->mux_ops = &clk_mux_ops;\n\t\tfrac->clk_nb.notifier_call = rockchip_clk_frac_notifier_cb;\n\n\t\tfrac_mux->reg = base + child->muxdiv_offset;\n\t\tfrac_mux->shift = child->mux_shift;\n\t\tfrac_mux->mask = BIT(child->mux_width) - 1;\n\t\tfrac_mux->flags = child->mux_flags;\n\t\tif (child->mux_table)\n\t\t\tfrac_mux->table = child->mux_table;\n\t\tfrac_mux->lock = lock;\n\t\tfrac_mux->hw.init = &init;\n\n\t\tinit.name = child->name;\n\t\tinit.flags = child->flags | CLK_SET_RATE_PARENT;\n\t\tinit.ops = frac->mux_ops;\n\t\tinit.parent_names = child->parent_names;\n\t\tinit.num_parents = child->num_parents;\n\n\t\tmux_clk = clk_register(NULL, &frac_mux->hw);\n\t\tif (IS_ERR(mux_clk)) {\n\t\t\tkfree(frac);\n\t\t\treturn mux_clk;\n\t\t}\n\n\t\trockchip_clk_add_lookup(ctx, mux_clk, child->id);\n\n\t\t \n\t\tif (frac->mux_frac_idx >= 0) {\n\t\t\tpr_debug(\"%s: found fractional parent in mux at pos %d\\n\",\n\t\t\t\t __func__, frac->mux_frac_idx);\n\t\t\tret = clk_notifier_register(hw->clk, &frac->clk_nb);\n\t\t\tif (ret)\n\t\t\t\tpr_err(\"%s: failed to register clock notifier for %s\\n\",\n\t\t\t\t\t\t__func__, name);\n\t\t} else {\n\t\t\tpr_warn(\"%s: could not find %s as parent of %s, rate changes may not work\\n\",\n\t\t\t\t__func__, name, child->name);\n\t\t}\n\t}\n\n\treturn hw->clk;\n}\n\nstatic struct clk *rockchip_clk_register_factor_branch(const char *name,\n\t\tconst char *const *parent_names, u8 num_parents,\n\t\tvoid __iomem *base, unsigned int mult, unsigned int div,\n\t\tint gate_offset, u8 gate_shift, u8 gate_flags,\n\t\tunsigned long flags, spinlock_t *lock)\n{\n\tstruct clk_hw *hw;\n\tstruct clk_gate *gate = NULL;\n\tstruct clk_fixed_factor *fix = NULL;\n\n\t \n\tif (gate_offset == 0) {\n\t\treturn clk_register_fixed_factor(NULL, name,\n\t\t\t\tparent_names[0], flags, mult,\n\t\t\t\tdiv);\n\t}\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgate->flags = gate_flags;\n\tgate->reg = base + gate_offset;\n\tgate->bit_idx = gate_shift;\n\tgate->lock = lock;\n\n\tfix = kzalloc(sizeof(*fix), GFP_KERNEL);\n\tif (!fix) {\n\t\tkfree(gate);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfix->mult = mult;\n\tfix->div = div;\n\n\thw = clk_hw_register_composite(NULL, name, parent_names, num_parents,\n\t\t\t\t       NULL, NULL,\n\t\t\t\t       &fix->hw, &clk_fixed_factor_ops,\n\t\t\t\t       &gate->hw, &clk_gate_ops, flags);\n\tif (IS_ERR(hw)) {\n\t\tkfree(fix);\n\t\tkfree(gate);\n\t\treturn ERR_CAST(hw);\n\t}\n\n\treturn hw->clk;\n}\n\nstruct rockchip_clk_provider *rockchip_clk_init(struct device_node *np,\n\t\t\t\t\t\tvoid __iomem *base,\n\t\t\t\t\t\tunsigned long nr_clks)\n{\n\tstruct rockchip_clk_provider *ctx;\n\tstruct clk **clk_table;\n\tint i;\n\n\tctx = kzalloc(sizeof(struct rockchip_clk_provider), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk_table = kcalloc(nr_clks, sizeof(struct clk *), GFP_KERNEL);\n\tif (!clk_table)\n\t\tgoto err_free;\n\n\tfor (i = 0; i < nr_clks; ++i)\n\t\tclk_table[i] = ERR_PTR(-ENOENT);\n\n\tctx->reg_base = base;\n\tctx->clk_data.clks = clk_table;\n\tctx->clk_data.clk_num = nr_clks;\n\tctx->cru_node = np;\n\tspin_lock_init(&ctx->lock);\n\n\tctx->grf = syscon_regmap_lookup_by_phandle(ctx->cru_node,\n\t\t\t\t\t\t   \"rockchip,grf\");\n\n\treturn ctx;\n\nerr_free:\n\tkfree(ctx);\n\treturn ERR_PTR(-ENOMEM);\n}\nEXPORT_SYMBOL_GPL(rockchip_clk_init);\n\nvoid rockchip_clk_of_add_provider(struct device_node *np,\n\t\t\t\t  struct rockchip_clk_provider *ctx)\n{\n\tif (of_clk_add_provider(np, of_clk_src_onecell_get,\n\t\t\t\t&ctx->clk_data))\n\t\tpr_err(\"%s: could not register clk provider\\n\", __func__);\n}\nEXPORT_SYMBOL_GPL(rockchip_clk_of_add_provider);\n\nvoid rockchip_clk_register_plls(struct rockchip_clk_provider *ctx,\n\t\t\t\tstruct rockchip_pll_clock *list,\n\t\t\t\tunsigned int nr_pll, int grf_lock_offset)\n{\n\tstruct clk *clk;\n\tint idx;\n\n\tfor (idx = 0; idx < nr_pll; idx++, list++) {\n\t\tclk = rockchip_clk_register_pll(ctx, list->type, list->name,\n\t\t\t\tlist->parent_names, list->num_parents,\n\t\t\t\tlist->con_offset, grf_lock_offset,\n\t\t\t\tlist->lock_shift, list->mode_offset,\n\t\t\t\tlist->mode_shift, list->rate_table,\n\t\t\t\tlist->flags, list->pll_flags);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\", __func__,\n\t\t\t\tlist->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\trockchip_clk_add_lookup(ctx, clk, list->id);\n\t}\n}\nEXPORT_SYMBOL_GPL(rockchip_clk_register_plls);\n\nvoid rockchip_clk_register_branches(struct rockchip_clk_provider *ctx,\n\t\t\t\t    struct rockchip_clk_branch *list,\n\t\t\t\t    unsigned int nr_clk)\n{\n\tstruct clk *clk = NULL;\n\tunsigned int idx;\n\tunsigned long flags;\n\n\tfor (idx = 0; idx < nr_clk; idx++, list++) {\n\t\tflags = list->flags;\n\n\t\t \n\t\tswitch (list->branch_type) {\n\t\tcase branch_mux:\n\t\t\tif (list->mux_table)\n\t\t\t\tclk = clk_register_mux_table(NULL, list->name,\n\t\t\t\t\tlist->parent_names, list->num_parents,\n\t\t\t\t\tflags,\n\t\t\t\t\tctx->reg_base + list->muxdiv_offset,\n\t\t\t\t\tlist->mux_shift, list->mux_width,\n\t\t\t\t\tlist->mux_flags, list->mux_table,\n\t\t\t\t\t&ctx->lock);\n\t\t\telse\n\t\t\t\tclk = clk_register_mux(NULL, list->name,\n\t\t\t\t\tlist->parent_names, list->num_parents,\n\t\t\t\t\tflags,\n\t\t\t\t\tctx->reg_base + list->muxdiv_offset,\n\t\t\t\t\tlist->mux_shift, list->mux_width,\n\t\t\t\t\tlist->mux_flags, &ctx->lock);\n\t\t\tbreak;\n\t\tcase branch_muxgrf:\n\t\t\tclk = rockchip_clk_register_muxgrf(list->name,\n\t\t\t\tlist->parent_names, list->num_parents,\n\t\t\t\tflags, ctx->grf, list->muxdiv_offset,\n\t\t\t\tlist->mux_shift, list->mux_width,\n\t\t\t\tlist->mux_flags);\n\t\t\tbreak;\n\t\tcase branch_divider:\n\t\t\tif (list->div_table)\n\t\t\t\tclk = clk_register_divider_table(NULL,\n\t\t\t\t\tlist->name, list->parent_names[0],\n\t\t\t\t\tflags,\n\t\t\t\t\tctx->reg_base + list->muxdiv_offset,\n\t\t\t\t\tlist->div_shift, list->div_width,\n\t\t\t\t\tlist->div_flags, list->div_table,\n\t\t\t\t\t&ctx->lock);\n\t\t\telse\n\t\t\t\tclk = clk_register_divider(NULL, list->name,\n\t\t\t\t\tlist->parent_names[0], flags,\n\t\t\t\t\tctx->reg_base + list->muxdiv_offset,\n\t\t\t\t\tlist->div_shift, list->div_width,\n\t\t\t\t\tlist->div_flags, &ctx->lock);\n\t\t\tbreak;\n\t\tcase branch_fraction_divider:\n\t\t\tclk = rockchip_clk_register_frac_branch(ctx, list->name,\n\t\t\t\tlist->parent_names, list->num_parents,\n\t\t\t\tctx->reg_base, list->muxdiv_offset,\n\t\t\t\tlist->div_flags,\n\t\t\t\tlist->gate_offset, list->gate_shift,\n\t\t\t\tlist->gate_flags, flags, list->child,\n\t\t\t\t&ctx->lock);\n\t\t\tbreak;\n\t\tcase branch_half_divider:\n\t\t\tclk = rockchip_clk_register_halfdiv(list->name,\n\t\t\t\tlist->parent_names, list->num_parents,\n\t\t\t\tctx->reg_base, list->muxdiv_offset,\n\t\t\t\tlist->mux_shift, list->mux_width,\n\t\t\t\tlist->mux_flags, list->div_shift,\n\t\t\t\tlist->div_width, list->div_flags,\n\t\t\t\tlist->gate_offset, list->gate_shift,\n\t\t\t\tlist->gate_flags, flags, &ctx->lock);\n\t\t\tbreak;\n\t\tcase branch_gate:\n\t\t\tflags |= CLK_SET_RATE_PARENT;\n\n\t\t\tclk = clk_register_gate(NULL, list->name,\n\t\t\t\tlist->parent_names[0], flags,\n\t\t\t\tctx->reg_base + list->gate_offset,\n\t\t\t\tlist->gate_shift, list->gate_flags, &ctx->lock);\n\t\t\tbreak;\n\t\tcase branch_composite:\n\t\t\tclk = rockchip_clk_register_branch(list->name,\n\t\t\t\tlist->parent_names, list->num_parents,\n\t\t\t\tctx->reg_base, list->muxdiv_offset,\n\t\t\t\tlist->mux_shift,\n\t\t\t\tlist->mux_width, list->mux_flags,\n\t\t\t\tlist->mux_table, list->div_offset,\n\t\t\t\tlist->div_shift, list->div_width,\n\t\t\t\tlist->div_flags, list->div_table,\n\t\t\t\tlist->gate_offset, list->gate_shift,\n\t\t\t\tlist->gate_flags, flags, &ctx->lock);\n\t\t\tbreak;\n\t\tcase branch_mmc:\n\t\t\tclk = rockchip_clk_register_mmc(\n\t\t\t\tlist->name,\n\t\t\t\tlist->parent_names, list->num_parents,\n\t\t\t\tctx->reg_base + list->muxdiv_offset,\n\t\t\t\tlist->div_shift\n\t\t\t);\n\t\t\tbreak;\n\t\tcase branch_inverter:\n\t\t\tclk = rockchip_clk_register_inverter(\n\t\t\t\tlist->name, list->parent_names,\n\t\t\t\tlist->num_parents,\n\t\t\t\tctx->reg_base + list->muxdiv_offset,\n\t\t\t\tlist->div_shift, list->div_flags, &ctx->lock);\n\t\t\tbreak;\n\t\tcase branch_factor:\n\t\t\tclk = rockchip_clk_register_factor_branch(\n\t\t\t\tlist->name, list->parent_names,\n\t\t\t\tlist->num_parents, ctx->reg_base,\n\t\t\t\tlist->div_shift, list->div_width,\n\t\t\t\tlist->gate_offset, list->gate_shift,\n\t\t\t\tlist->gate_flags, flags, &ctx->lock);\n\t\t\tbreak;\n\t\tcase branch_ddrclk:\n\t\t\tclk = rockchip_clk_register_ddrclk(\n\t\t\t\tlist->name, list->flags,\n\t\t\t\tlist->parent_names, list->num_parents,\n\t\t\t\tlist->muxdiv_offset, list->mux_shift,\n\t\t\t\tlist->mux_width, list->div_shift,\n\t\t\t\tlist->div_width, list->div_flags,\n\t\t\t\tctx->reg_base, &ctx->lock);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!clk) {\n\t\t\tpr_err(\"%s: unknown clock type %d\\n\",\n\t\t\t       __func__, list->branch_type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s: %ld\\n\",\n\t\t\t       __func__, list->name, PTR_ERR(clk));\n\t\t\tcontinue;\n\t\t}\n\n\t\trockchip_clk_add_lookup(ctx, clk, list->id);\n\t}\n}\nEXPORT_SYMBOL_GPL(rockchip_clk_register_branches);\n\nvoid rockchip_clk_register_armclk(struct rockchip_clk_provider *ctx,\n\t\t\t\t  unsigned int lookup_id,\n\t\t\t\t  const char *name, const char *const *parent_names,\n\t\t\t\t  u8 num_parents,\n\t\t\t\t  const struct rockchip_cpuclk_reg_data *reg_data,\n\t\t\t\t  const struct rockchip_cpuclk_rate_table *rates,\n\t\t\t\t  int nrates)\n{\n\tstruct clk *clk;\n\n\tclk = rockchip_clk_register_cpuclk(name, parent_names, num_parents,\n\t\t\t\t\t   reg_data, rates, nrates,\n\t\t\t\t\t   ctx->reg_base, &ctx->lock);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: failed to register clock %s: %ld\\n\",\n\t\t       __func__, name, PTR_ERR(clk));\n\t\treturn;\n\t}\n\n\trockchip_clk_add_lookup(ctx, clk, lookup_id);\n}\nEXPORT_SYMBOL_GPL(rockchip_clk_register_armclk);\n\nvoid rockchip_clk_protect_critical(const char *const clocks[],\n\t\t\t\t   int nclocks)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < nclocks; i++) {\n\t\tstruct clk *clk = __clk_lookup(clocks[i]);\n\n\t\tclk_prepare_enable(clk);\n\t}\n}\nEXPORT_SYMBOL_GPL(rockchip_clk_protect_critical);\n\nstatic void __iomem *rst_base;\nstatic unsigned int reg_restart;\nstatic void (*cb_restart)(void);\nstatic int rockchip_restart_notify(struct notifier_block *this,\n\t\t\t\t   unsigned long mode, void *cmd)\n{\n\tif (cb_restart)\n\t\tcb_restart();\n\n\twritel(0xfdb9, rst_base + reg_restart);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block rockchip_restart_handler = {\n\t.notifier_call = rockchip_restart_notify,\n\t.priority = 128,\n};\n\nvoid\nrockchip_register_restart_notifier(struct rockchip_clk_provider *ctx,\n\t\t\t\t   unsigned int reg,\n\t\t\t\t   void (*cb)(void))\n{\n\tint ret;\n\n\trst_base = ctx->reg_base;\n\treg_restart = reg;\n\tcb_restart = cb;\n\tret = register_restart_handler(&rockchip_restart_handler);\n\tif (ret)\n\t\tpr_err(\"%s: cannot register restart handler, %d\\n\",\n\t\t       __func__, ret);\n}\nEXPORT_SYMBOL_GPL(rockchip_register_restart_notifier);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}