{
  "module_name": "clk-ddr.c",
  "hash_id": "581d78e0e1c661e5614035269d990d463f491b4a390967811a395a9f75a0328a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/rockchip/clk-ddr.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <soc/rockchip/rockchip_sip.h>\n#include \"clk.h\"\n\nstruct rockchip_ddrclk {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*reg_base;\n\tint\t\tmux_offset;\n\tint\t\tmux_shift;\n\tint\t\tmux_width;\n\tint\t\tdiv_shift;\n\tint\t\tdiv_width;\n\tint\t\tddr_flag;\n\tspinlock_t\t*lock;\n};\n\n#define to_rockchip_ddrclk_hw(hw) container_of(hw, struct rockchip_ddrclk, hw)\n\nstatic int rockchip_ddrclk_sip_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t\tunsigned long prate)\n{\n\tstruct rockchip_ddrclk *ddrclk = to_rockchip_ddrclk_hw(hw);\n\tunsigned long flags;\n\tstruct arm_smccc_res res;\n\n\tspin_lock_irqsave(ddrclk->lock, flags);\n\tarm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ, drate, 0,\n\t\t      ROCKCHIP_SIP_CONFIG_DRAM_SET_RATE,\n\t\t      0, 0, 0, 0, &res);\n\tspin_unlock_irqrestore(ddrclk->lock, flags);\n\n\treturn res.a0;\n}\n\nstatic unsigned long\nrockchip_ddrclk_sip_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ, 0, 0,\n\t\t      ROCKCHIP_SIP_CONFIG_DRAM_GET_RATE,\n\t\t      0, 0, 0, 0, &res);\n\n\treturn res.a0;\n}\n\nstatic long rockchip_ddrclk_sip_round_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long rate,\n\t\t\t\t\t   unsigned long *prate)\n{\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ, rate, 0,\n\t\t      ROCKCHIP_SIP_CONFIG_DRAM_ROUND_RATE,\n\t\t      0, 0, 0, 0, &res);\n\n\treturn res.a0;\n}\n\nstatic u8 rockchip_ddrclk_get_parent(struct clk_hw *hw)\n{\n\tstruct rockchip_ddrclk *ddrclk = to_rockchip_ddrclk_hw(hw);\n\tu32 val;\n\n\tval = readl(ddrclk->reg_base +\n\t\t\tddrclk->mux_offset) >> ddrclk->mux_shift;\n\tval &= GENMASK(ddrclk->mux_width - 1, 0);\n\n\treturn val;\n}\n\nstatic const struct clk_ops rockchip_ddrclk_sip_ops = {\n\t.recalc_rate = rockchip_ddrclk_sip_recalc_rate,\n\t.set_rate = rockchip_ddrclk_sip_set_rate,\n\t.round_rate = rockchip_ddrclk_sip_round_rate,\n\t.get_parent = rockchip_ddrclk_get_parent,\n};\n\nstruct clk *rockchip_clk_register_ddrclk(const char *name, int flags,\n\t\t\t\t\t const char *const *parent_names,\n\t\t\t\t\t u8 num_parents, int mux_offset,\n\t\t\t\t\t int mux_shift, int mux_width,\n\t\t\t\t\t int div_shift, int div_width,\n\t\t\t\t\t int ddr_flag, void __iomem *reg_base,\n\t\t\t\t\t spinlock_t *lock)\n{\n\tstruct rockchip_ddrclk *ddrclk;\n\tstruct clk_init_data init;\n\tstruct clk *clk;\n\n\tddrclk = kzalloc(sizeof(*ddrclk), GFP_KERNEL);\n\tif (!ddrclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\n\tinit.flags = flags;\n\tinit.flags |= CLK_SET_RATE_NO_REPARENT;\n\n\tswitch (ddr_flag) {\n\tcase ROCKCHIP_DDRCLK_SIP:\n\t\tinit.ops = &rockchip_ddrclk_sip_ops;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unsupported ddrclk type %d\\n\", __func__, ddr_flag);\n\t\tkfree(ddrclk);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tddrclk->reg_base = reg_base;\n\tddrclk->lock = lock;\n\tddrclk->hw.init = &init;\n\tddrclk->mux_offset = mux_offset;\n\tddrclk->mux_shift = mux_shift;\n\tddrclk->mux_width = mux_width;\n\tddrclk->div_shift = div_shift;\n\tddrclk->div_width = div_width;\n\tddrclk->ddr_flag = ddr_flag;\n\n\tclk = clk_register(NULL, &ddrclk->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(ddrclk);\n\n\treturn clk;\n}\nEXPORT_SYMBOL_GPL(rockchip_clk_register_ddrclk);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}