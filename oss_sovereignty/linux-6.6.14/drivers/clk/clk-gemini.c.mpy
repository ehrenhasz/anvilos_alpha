{
  "module_name": "clk-gemini.c",
  "hash_id": "d87ac88dce3074c8cce824f45fda275535c538ec68f9e58db11844de57558c64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-gemini.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"clk-gemini: \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/clk-provider.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/spinlock.h>\n#include <linux/reset-controller.h>\n#include <dt-bindings/reset/cortina,gemini-reset.h>\n#include <dt-bindings/clock/cortina,gemini-clock.h>\n\n \nstatic DEFINE_SPINLOCK(gemini_clk_lock);\n\n#define GEMINI_GLOBAL_STATUS\t\t0x04\n#define PLL_OSC_SEL\t\t\tBIT(30)\n#define AHBSPEED_SHIFT\t\t\t(15)\n#define AHBSPEED_MASK\t\t\t0x07\n#define CPU_AHB_RATIO_SHIFT\t\t(18)\n#define CPU_AHB_RATIO_MASK\t\t0x03\n\n#define GEMINI_GLOBAL_PLL_CONTROL\t0x08\n\n#define GEMINI_GLOBAL_SOFT_RESET\t0x0c\n\n#define GEMINI_GLOBAL_MISC_CONTROL\t0x30\n#define PCI_CLK_66MHZ\t\t\tBIT(18)\n\n#define GEMINI_GLOBAL_CLOCK_CONTROL\t0x34\n#define PCI_CLKRUN_EN\t\t\tBIT(16)\n#define TVC_HALFDIV_SHIFT\t\t(24)\n#define TVC_HALFDIV_MASK\t\t0x1f\n#define SECURITY_CLK_SEL\t\tBIT(29)\n\n#define GEMINI_GLOBAL_PCI_DLL_CONTROL\t0x44\n#define PCI_DLL_BYPASS\t\t\tBIT(31)\n#define PCI_DLL_TAP_SEL_MASK\t\t0x1f\n\n \nstruct gemini_gate_data {\n\tu8 bit_idx;\n\tconst char *name;\n\tconst char *parent_name;\n\tunsigned long flags;\n};\n\n \nstruct clk_gemini_pci {\n\tstruct clk_hw hw;\n\tstruct regmap *map;\n\tunsigned long rate;\n};\n\n \nstruct gemini_reset {\n\tstruct regmap *map;\n\tstruct reset_controller_dev rcdev;\n};\n\n \nstatic struct clk_hw_onecell_data *gemini_clk_data;\n\nstatic const struct gemini_gate_data gemini_gates[] = {\n\t{ 1, \"security-gate\", \"secdiv\", 0 },\n\t{ 2, \"gmac0-gate\", \"ahb\", 0 },\n\t{ 3, \"gmac1-gate\", \"ahb\", 0 },\n\t{ 4, \"sata0-gate\", \"ahb\", 0 },\n\t{ 5, \"sata1-gate\", \"ahb\", 0 },\n\t{ 6, \"usb0-gate\", \"ahb\", 0 },\n\t{ 7, \"usb1-gate\", \"ahb\", 0 },\n\t{ 8, \"ide-gate\", \"ahb\", 0 },\n\t{ 9, \"pci-gate\", \"ahb\", 0 },\n\t \n\t{ 10, \"ddr-gate\", \"ahb\", CLK_IS_CRITICAL },\n\t \n\t{ 11, \"flash-gate\", \"ahb\", CLK_IGNORE_UNUSED },\n\t{ 12, \"tvc-gate\", \"ahb\", 0 },\n\t{ 13, \"boot-gate\", \"apb\", 0 },\n};\n\n#define to_pciclk(_hw) container_of(_hw, struct clk_gemini_pci, hw)\n\n#define to_gemini_reset(p) container_of((p), struct gemini_reset, rcdev)\n\nstatic unsigned long gemini_pci_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_gemini_pci *pciclk = to_pciclk(hw);\n\tu32 val;\n\n\tregmap_read(pciclk->map, GEMINI_GLOBAL_MISC_CONTROL, &val);\n\tif (val & PCI_CLK_66MHZ)\n\t\treturn 66000000;\n\treturn 33000000;\n}\n\nstatic long gemini_pci_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long *prate)\n{\n\t \n\tif (rate < 48000000)\n\t\treturn 33000000;\n\treturn 66000000;\n}\n\nstatic int gemini_pci_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct clk_gemini_pci *pciclk = to_pciclk(hw);\n\n\tif (rate == 33000000)\n\t\treturn regmap_update_bits(pciclk->map,\n\t\t\t\t\t  GEMINI_GLOBAL_MISC_CONTROL,\n\t\t\t\t\t  PCI_CLK_66MHZ, 0);\n\tif (rate == 66000000)\n\t\treturn regmap_update_bits(pciclk->map,\n\t\t\t\t\t  GEMINI_GLOBAL_MISC_CONTROL,\n\t\t\t\t\t  0, PCI_CLK_66MHZ);\n\treturn -EINVAL;\n}\n\nstatic int gemini_pci_enable(struct clk_hw *hw)\n{\n\tstruct clk_gemini_pci *pciclk = to_pciclk(hw);\n\n\tregmap_update_bits(pciclk->map, GEMINI_GLOBAL_CLOCK_CONTROL,\n\t\t\t   0, PCI_CLKRUN_EN);\n\treturn 0;\n}\n\nstatic void gemini_pci_disable(struct clk_hw *hw)\n{\n\tstruct clk_gemini_pci *pciclk = to_pciclk(hw);\n\n\tregmap_update_bits(pciclk->map, GEMINI_GLOBAL_CLOCK_CONTROL,\n\t\t\t   PCI_CLKRUN_EN, 0);\n}\n\nstatic int gemini_pci_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_gemini_pci *pciclk = to_pciclk(hw);\n\tunsigned int val;\n\n\tregmap_read(pciclk->map, GEMINI_GLOBAL_CLOCK_CONTROL, &val);\n\treturn !!(val & PCI_CLKRUN_EN);\n}\n\nstatic const struct clk_ops gemini_pci_clk_ops = {\n\t.recalc_rate = gemini_pci_recalc_rate,\n\t.round_rate = gemini_pci_round_rate,\n\t.set_rate = gemini_pci_set_rate,\n\t.enable = gemini_pci_enable,\n\t.disable = gemini_pci_disable,\n\t.is_enabled = gemini_pci_is_enabled,\n};\n\nstatic struct clk_hw *gemini_pci_clk_setup(const char *name,\n\t\t\t\t\t   const char *parent_name,\n\t\t\t\t\t   struct regmap *map)\n{\n\tstruct clk_gemini_pci *pciclk;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tpciclk = kzalloc(sizeof(*pciclk), GFP_KERNEL);\n\tif (!pciclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &gemini_pci_clk_ops;\n\tinit.flags = 0;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tpciclk->map = map;\n\tpciclk->hw.init = &init;\n\n\tret = clk_hw_register(NULL, &pciclk->hw);\n\tif (ret) {\n\t\tkfree(pciclk);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn &pciclk->hw;\n}\n\n \nstatic int gemini_reset(struct reset_controller_dev *rcdev,\n\t\t\tunsigned long id)\n{\n\tstruct gemini_reset *gr = to_gemini_reset(rcdev);\n\n\t \n\treturn regmap_write(gr->map,\n\t\t\t    GEMINI_GLOBAL_SOFT_RESET,\n\t\t\t    BIT(GEMINI_RESET_CPU1) | BIT(id));\n}\n\nstatic int gemini_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\treturn 0;\n}\n\nstatic int gemini_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t unsigned long id)\n{\n\treturn 0;\n}\n\nstatic int gemini_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned long id)\n{\n\tstruct gemini_reset *gr = to_gemini_reset(rcdev);\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(gr->map, GEMINI_GLOBAL_SOFT_RESET, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(val & BIT(id));\n}\n\nstatic const struct reset_control_ops gemini_reset_ops = {\n\t.reset = gemini_reset,\n\t.assert = gemini_reset_assert,\n\t.deassert = gemini_reset_deassert,\n\t.status = gemini_reset_status,\n};\n\nstatic int gemini_clk_probe(struct platform_device *pdev)\n{\n\t \n\tunsigned int cpu_ahb_mult[4] = { 1, 3, 24, 2 };\n\tunsigned int cpu_ahb_div[4] = { 1, 2, 13, 1 };\n\tvoid __iomem *base;\n\tstruct gemini_reset *gr;\n\tstruct regmap *map;\n\tstruct clk_hw *hw;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tunsigned int mult, div;\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tgr = devm_kzalloc(dev, sizeof(*gr), GFP_KERNEL);\n\tif (!gr)\n\t\treturn -ENOMEM;\n\n\t \n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tmap = syscon_node_to_regmap(np);\n\tif (IS_ERR(map)) {\n\t\tdev_err(dev, \"no syscon regmap\\n\");\n\t\treturn PTR_ERR(map);\n\t}\n\n\tgr->map = map;\n\tgr->rcdev.owner = THIS_MODULE;\n\tgr->rcdev.nr_resets = 32;\n\tgr->rcdev.ops = &gemini_reset_ops;\n\tgr->rcdev.of_node = np;\n\n\tret = devm_reset_controller_register(dev, &gr->rcdev);\n\tif (ret) {\n\t\tdev_err(dev, \"could not register reset controller\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\thw = clk_hw_register_fixed_rate(NULL, \"rtc\", NULL, 0, 32768);\n\tgemini_clk_data->hws[GEMINI_CLK_RTC] = hw;\n\n\t \n\tregmap_read(map, GEMINI_GLOBAL_STATUS, &val);\n\tval >>= CPU_AHB_RATIO_SHIFT;\n\tval &= CPU_AHB_RATIO_MASK;\n\thw = clk_hw_register_fixed_factor(NULL, \"cpu\", \"ahb\", 0,\n\t\t\t\t\t  cpu_ahb_mult[val],\n\t\t\t\t\t  cpu_ahb_div[val]);\n\tgemini_clk_data->hws[GEMINI_CLK_CPU] = hw;\n\n\t \n\tregmap_read(map, GEMINI_GLOBAL_CLOCK_CONTROL, &val);\n\tif (val & SECURITY_CLK_SEL) {\n\t\tmult = 1;\n\t\tdiv = 1;\n\t} else {\n\t\tmult = 3;\n\t\tdiv = 4;\n\t}\n\thw = clk_hw_register_fixed_factor(NULL, \"secdiv\", \"ahb\", 0, mult, div);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(gemini_gates); i++) {\n\t\tconst struct gemini_gate_data *gd;\n\n\t\tgd = &gemini_gates[i];\n\t\tgemini_clk_data->hws[GEMINI_CLK_GATES + i] =\n\t\t\tclk_hw_register_gate(NULL, gd->name,\n\t\t\t\t\t     gd->parent_name,\n\t\t\t\t\t     gd->flags,\n\t\t\t\t\t     base + GEMINI_GLOBAL_CLOCK_CONTROL,\n\t\t\t\t\t     gd->bit_idx,\n\t\t\t\t\t     CLK_GATE_SET_TO_DISABLE,\n\t\t\t\t\t     &gemini_clk_lock);\n\t}\n\n\t \n\tmult = 1;\n\tdiv = ((val >> TVC_HALFDIV_SHIFT) & TVC_HALFDIV_MASK);\n\tdev_dbg(dev, \"TVC half divider value = %d\\n\", div);\n\tdiv += 1;\n\thw = clk_hw_register_fixed_rate(NULL, \"tvcdiv\", \"xtal\", 0, 27000000);\n\tgemini_clk_data->hws[GEMINI_CLK_TVC] = hw;\n\n\t \n\thw = gemini_pci_clk_setup(\"PCI\", \"xtal\", map);\n\tgemini_clk_data->hws[GEMINI_CLK_PCI] = hw;\n\n\t \n\thw = clk_hw_register_fixed_rate(NULL, \"uart\", \"xtal\", 0, 48000000);\n\tgemini_clk_data->hws[GEMINI_CLK_UART] = hw;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id gemini_clk_dt_ids[] = {\n\t{ .compatible = \"cortina,gemini-syscon\", },\n\t{   },\n};\n\nstatic struct platform_driver gemini_clk_driver = {\n\t.probe  = gemini_clk_probe,\n\t.driver = {\n\t\t.name = \"gemini-clk\",\n\t\t.of_match_table = gemini_clk_dt_ids,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(gemini_clk_driver);\n\nstatic void __init gemini_cc_init(struct device_node *np)\n{\n\tstruct regmap *map;\n\tstruct clk_hw *hw;\n\tunsigned long freq;\n\tunsigned int mult, div;\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tgemini_clk_data = kzalloc(struct_size(gemini_clk_data, hws,\n\t\t\t\t\t      GEMINI_NUM_CLKS),\n\t\t\t\t  GFP_KERNEL);\n\tif (!gemini_clk_data)\n\t\treturn;\n\tgemini_clk_data->num = GEMINI_NUM_CLKS;\n\n\t \n\tfor (i = 0; i < GEMINI_NUM_CLKS; i++)\n\t\tgemini_clk_data->hws[i] = ERR_PTR(-EPROBE_DEFER);\n\n\tmap = syscon_node_to_regmap(np);\n\tif (IS_ERR(map)) {\n\t\tpr_err(\"no syscon regmap\\n\");\n\t\treturn;\n\t}\n\t \n\tret = regmap_read(map, GEMINI_GLOBAL_STATUS, &val);\n\tif (ret) {\n\t\tpr_err(\"failed to read global status register\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (val & PLL_OSC_SEL)\n\t\tfreq = 30000000;\n\telse\n\t\tfreq = 60000000;\n\thw = clk_hw_register_fixed_rate(NULL, \"xtal\", NULL, 0, freq);\n\tpr_debug(\"main crystal @%lu MHz\\n\", freq / 1000000);\n\n\t \n\tmult = 13 + ((val >> AHBSPEED_SHIFT) & AHBSPEED_MASK);\n\tdiv = 2;\n\t \n\tif (val & PLL_OSC_SEL)\n\t\tmult *= 2;\n\thw = clk_hw_register_fixed_factor(NULL, \"vco\", \"xtal\", 0, mult, div);\n\n\t \n\thw = clk_hw_register_fixed_factor(NULL, \"ahb\", \"vco\", 0, 1, 3);\n\tgemini_clk_data->hws[GEMINI_CLK_AHB] = hw;\n\n\t \n\thw = clk_hw_register_fixed_factor(NULL, \"apb\", \"ahb\", 0, 1, 6);\n\tgemini_clk_data->hws[GEMINI_CLK_APB] = hw;\n\n\t \n\tof_clk_add_hw_provider(np, of_clk_hw_onecell_get, gemini_clk_data);\n}\nCLK_OF_DECLARE_DRIVER(gemini_cc, \"cortina,gemini-syscon\", gemini_cc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}