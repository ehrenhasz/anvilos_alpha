{
  "module_name": "clk-composite.c",
  "hash_id": "247510f1c4f6fe1b8ec84008c47ddfa52d4df16e1bf342021b3f171e0efdf93e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-composite.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n\nstatic u8 clk_composite_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_composite *composite = to_clk_composite(hw);\n\tconst struct clk_ops *mux_ops = composite->mux_ops;\n\tstruct clk_hw *mux_hw = composite->mux_hw;\n\n\t__clk_hw_set_clk(mux_hw, hw);\n\n\treturn mux_ops->get_parent(mux_hw);\n}\n\nstatic int clk_composite_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_composite *composite = to_clk_composite(hw);\n\tconst struct clk_ops *mux_ops = composite->mux_ops;\n\tstruct clk_hw *mux_hw = composite->mux_hw;\n\n\t__clk_hw_set_clk(mux_hw, hw);\n\n\treturn mux_ops->set_parent(mux_hw, index);\n}\n\nstatic unsigned long clk_composite_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_composite *composite = to_clk_composite(hw);\n\tconst struct clk_ops *rate_ops = composite->rate_ops;\n\tstruct clk_hw *rate_hw = composite->rate_hw;\n\n\t__clk_hw_set_clk(rate_hw, hw);\n\n\treturn rate_ops->recalc_rate(rate_hw, parent_rate);\n}\n\nstatic int clk_composite_determine_rate_for_parent(struct clk_hw *rate_hw,\n\t\t\t\t\t\t   struct clk_rate_request *req,\n\t\t\t\t\t\t   struct clk_hw *parent_hw,\n\t\t\t\t\t\t   const struct clk_ops *rate_ops)\n{\n\tlong rate;\n\n\treq->best_parent_hw = parent_hw;\n\treq->best_parent_rate = clk_hw_get_rate(parent_hw);\n\n\tif (rate_ops->determine_rate)\n\t\treturn rate_ops->determine_rate(rate_hw, req);\n\n\trate = rate_ops->round_rate(rate_hw, req->rate,\n\t\t\t\t    &req->best_parent_rate);\n\tif (rate < 0)\n\t\treturn rate;\n\n\treq->rate = rate;\n\n\treturn 0;\n}\n\nstatic int clk_composite_determine_rate(struct clk_hw *hw,\n\t\t\t\t\tstruct clk_rate_request *req)\n{\n\tstruct clk_composite *composite = to_clk_composite(hw);\n\tconst struct clk_ops *rate_ops = composite->rate_ops;\n\tconst struct clk_ops *mux_ops = composite->mux_ops;\n\tstruct clk_hw *rate_hw = composite->rate_hw;\n\tstruct clk_hw *mux_hw = composite->mux_hw;\n\tstruct clk_hw *parent;\n\tunsigned long rate_diff;\n\tunsigned long best_rate_diff = ULONG_MAX;\n\tunsigned long best_rate = 0;\n\tint i, ret;\n\n\tif (rate_hw && rate_ops &&\n\t    (rate_ops->determine_rate || rate_ops->round_rate) &&\n\t    mux_hw && mux_ops && mux_ops->set_parent) {\n\t\treq->best_parent_hw = NULL;\n\n\t\tif (clk_hw_get_flags(hw) & CLK_SET_RATE_NO_REPARENT) {\n\t\t\tstruct clk_rate_request tmp_req;\n\n\t\t\tparent = clk_hw_get_parent(mux_hw);\n\n\t\t\tclk_hw_forward_rate_request(hw, req, parent, &tmp_req, req->rate);\n\t\t\tret = clk_composite_determine_rate_for_parent(rate_hw,\n\t\t\t\t\t\t\t\t      &tmp_req,\n\t\t\t\t\t\t\t\t      parent,\n\t\t\t\t\t\t\t\t      rate_ops);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\treq->rate = tmp_req.rate;\n\t\t\treq->best_parent_hw = tmp_req.best_parent_hw;\n\t\t\treq->best_parent_rate = tmp_req.best_parent_rate;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (i = 0; i < clk_hw_get_num_parents(mux_hw); i++) {\n\t\t\tstruct clk_rate_request tmp_req;\n\n\t\t\tparent = clk_hw_get_parent_by_index(mux_hw, i);\n\t\t\tif (!parent)\n\t\t\t\tcontinue;\n\n\t\t\tclk_hw_forward_rate_request(hw, req, parent, &tmp_req, req->rate);\n\t\t\tret = clk_composite_determine_rate_for_parent(rate_hw,\n\t\t\t\t\t\t\t\t      &tmp_req,\n\t\t\t\t\t\t\t\t      parent,\n\t\t\t\t\t\t\t\t      rate_ops);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\n\t\t\tif (req->rate >= tmp_req.rate)\n\t\t\t\trate_diff = req->rate - tmp_req.rate;\n\t\t\telse\n\t\t\t\trate_diff = tmp_req.rate - req->rate;\n\n\t\t\tif (!rate_diff || !req->best_parent_hw\n\t\t\t\t       || best_rate_diff > rate_diff) {\n\t\t\t\treq->best_parent_hw = parent;\n\t\t\t\treq->best_parent_rate = tmp_req.best_parent_rate;\n\t\t\t\tbest_rate_diff = rate_diff;\n\t\t\t\tbest_rate = tmp_req.rate;\n\t\t\t}\n\n\t\t\tif (!rate_diff)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\treq->rate = best_rate;\n\t\treturn 0;\n\t} else if (rate_hw && rate_ops && rate_ops->determine_rate) {\n\t\t__clk_hw_set_clk(rate_hw, hw);\n\t\treturn rate_ops->determine_rate(rate_hw, req);\n\t} else if (mux_hw && mux_ops && mux_ops->determine_rate) {\n\t\t__clk_hw_set_clk(mux_hw, hw);\n\t\treturn mux_ops->determine_rate(mux_hw, req);\n\t} else {\n\t\tpr_err(\"clk: clk_composite_determine_rate function called, but no mux or rate callback set!\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic long clk_composite_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long *prate)\n{\n\tstruct clk_composite *composite = to_clk_composite(hw);\n\tconst struct clk_ops *rate_ops = composite->rate_ops;\n\tstruct clk_hw *rate_hw = composite->rate_hw;\n\n\t__clk_hw_set_clk(rate_hw, hw);\n\n\treturn rate_ops->round_rate(rate_hw, rate, prate);\n}\n\nstatic int clk_composite_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct clk_composite *composite = to_clk_composite(hw);\n\tconst struct clk_ops *rate_ops = composite->rate_ops;\n\tstruct clk_hw *rate_hw = composite->rate_hw;\n\n\t__clk_hw_set_clk(rate_hw, hw);\n\n\treturn rate_ops->set_rate(rate_hw, rate, parent_rate);\n}\n\nstatic int clk_composite_set_rate_and_parent(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long rate,\n\t\t\t\t\t     unsigned long parent_rate,\n\t\t\t\t\t     u8 index)\n{\n\tstruct clk_composite *composite = to_clk_composite(hw);\n\tconst struct clk_ops *rate_ops = composite->rate_ops;\n\tconst struct clk_ops *mux_ops = composite->mux_ops;\n\tstruct clk_hw *rate_hw = composite->rate_hw;\n\tstruct clk_hw *mux_hw = composite->mux_hw;\n\tunsigned long temp_rate;\n\n\t__clk_hw_set_clk(rate_hw, hw);\n\t__clk_hw_set_clk(mux_hw, hw);\n\n\ttemp_rate = rate_ops->recalc_rate(rate_hw, parent_rate);\n\tif (temp_rate > rate) {\n\t\trate_ops->set_rate(rate_hw, rate, parent_rate);\n\t\tmux_ops->set_parent(mux_hw, index);\n\t} else {\n\t\tmux_ops->set_parent(mux_hw, index);\n\t\trate_ops->set_rate(rate_hw, rate, parent_rate);\n\t}\n\n\treturn 0;\n}\n\nstatic int clk_composite_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_composite *composite = to_clk_composite(hw);\n\tconst struct clk_ops *gate_ops = composite->gate_ops;\n\tstruct clk_hw *gate_hw = composite->gate_hw;\n\n\t__clk_hw_set_clk(gate_hw, hw);\n\n\treturn gate_ops->is_enabled(gate_hw);\n}\n\nstatic int clk_composite_enable(struct clk_hw *hw)\n{\n\tstruct clk_composite *composite = to_clk_composite(hw);\n\tconst struct clk_ops *gate_ops = composite->gate_ops;\n\tstruct clk_hw *gate_hw = composite->gate_hw;\n\n\t__clk_hw_set_clk(gate_hw, hw);\n\n\treturn gate_ops->enable(gate_hw);\n}\n\nstatic void clk_composite_disable(struct clk_hw *hw)\n{\n\tstruct clk_composite *composite = to_clk_composite(hw);\n\tconst struct clk_ops *gate_ops = composite->gate_ops;\n\tstruct clk_hw *gate_hw = composite->gate_hw;\n\n\t__clk_hw_set_clk(gate_hw, hw);\n\n\tgate_ops->disable(gate_hw);\n}\n\nstatic struct clk_hw *__clk_hw_register_composite(struct device *dev,\n\t\t\tconst char *name, const char * const *parent_names,\n\t\t\tconst struct clk_parent_data *pdata, int num_parents,\n\t\t\tstruct clk_hw *mux_hw, const struct clk_ops *mux_ops,\n\t\t\tstruct clk_hw *rate_hw, const struct clk_ops *rate_ops,\n\t\t\tstruct clk_hw *gate_hw, const struct clk_ops *gate_ops,\n\t\t\tunsigned long flags)\n{\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tstruct clk_composite *composite;\n\tstruct clk_ops *clk_composite_ops;\n\tint ret;\n\n\tcomposite = kzalloc(sizeof(*composite), GFP_KERNEL);\n\tif (!composite)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.flags = flags;\n\tif (parent_names)\n\t\tinit.parent_names = parent_names;\n\telse\n\t\tinit.parent_data = pdata;\n\tinit.num_parents = num_parents;\n\thw = &composite->hw;\n\n\tclk_composite_ops = &composite->ops;\n\n\tif (mux_hw && mux_ops) {\n\t\tif (!mux_ops->get_parent) {\n\t\t\thw = ERR_PTR(-EINVAL);\n\t\t\tgoto err;\n\t\t}\n\n\t\tcomposite->mux_hw = mux_hw;\n\t\tcomposite->mux_ops = mux_ops;\n\t\tclk_composite_ops->get_parent = clk_composite_get_parent;\n\t\tif (mux_ops->set_parent)\n\t\t\tclk_composite_ops->set_parent = clk_composite_set_parent;\n\t\tif (mux_ops->determine_rate)\n\t\t\tclk_composite_ops->determine_rate = clk_composite_determine_rate;\n\t}\n\n\tif (rate_hw && rate_ops) {\n\t\tif (!rate_ops->recalc_rate) {\n\t\t\thw = ERR_PTR(-EINVAL);\n\t\t\tgoto err;\n\t\t}\n\t\tclk_composite_ops->recalc_rate = clk_composite_recalc_rate;\n\n\t\tif (rate_ops->determine_rate)\n\t\t\tclk_composite_ops->determine_rate =\n\t\t\t\tclk_composite_determine_rate;\n\t\telse if (rate_ops->round_rate)\n\t\t\tclk_composite_ops->round_rate =\n\t\t\t\tclk_composite_round_rate;\n\n\t\t \n\t\tif (rate_ops->set_rate) {\n\t\t\tif (rate_ops->determine_rate || rate_ops->round_rate)\n\t\t\t\tclk_composite_ops->set_rate =\n\t\t\t\t\t\tclk_composite_set_rate;\n\t\t\telse\n\t\t\t\tWARN(1, \"%s: missing round_rate op is required\\n\",\n\t\t\t\t\t\t__func__);\n\t\t}\n\n\t\tcomposite->rate_hw = rate_hw;\n\t\tcomposite->rate_ops = rate_ops;\n\t}\n\n\tif (mux_hw && mux_ops && rate_hw && rate_ops) {\n\t\tif (mux_ops->set_parent && rate_ops->set_rate)\n\t\t\tclk_composite_ops->set_rate_and_parent =\n\t\t\tclk_composite_set_rate_and_parent;\n\t}\n\n\tif (gate_hw && gate_ops) {\n\t\tif (!gate_ops->is_enabled || !gate_ops->enable ||\n\t\t    !gate_ops->disable) {\n\t\t\thw = ERR_PTR(-EINVAL);\n\t\t\tgoto err;\n\t\t}\n\n\t\tcomposite->gate_hw = gate_hw;\n\t\tcomposite->gate_ops = gate_ops;\n\t\tclk_composite_ops->is_enabled = clk_composite_is_enabled;\n\t\tclk_composite_ops->enable = clk_composite_enable;\n\t\tclk_composite_ops->disable = clk_composite_disable;\n\t}\n\n\tinit.ops = clk_composite_ops;\n\tcomposite->hw.init = &init;\n\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\thw = ERR_PTR(ret);\n\t\tgoto err;\n\t}\n\n\tif (composite->mux_hw)\n\t\tcomposite->mux_hw->clk = hw->clk;\n\n\tif (composite->rate_hw)\n\t\tcomposite->rate_hw->clk = hw->clk;\n\n\tif (composite->gate_hw)\n\t\tcomposite->gate_hw->clk = hw->clk;\n\n\treturn hw;\n\nerr:\n\tkfree(composite);\n\treturn hw;\n}\n\nstruct clk_hw *clk_hw_register_composite(struct device *dev, const char *name,\n\t\t\tconst char * const *parent_names, int num_parents,\n\t\t\tstruct clk_hw *mux_hw, const struct clk_ops *mux_ops,\n\t\t\tstruct clk_hw *rate_hw, const struct clk_ops *rate_ops,\n\t\t\tstruct clk_hw *gate_hw, const struct clk_ops *gate_ops,\n\t\t\tunsigned long flags)\n{\n\treturn __clk_hw_register_composite(dev, name, parent_names, NULL,\n\t\t\t\t\t   num_parents, mux_hw, mux_ops,\n\t\t\t\t\t   rate_hw, rate_ops, gate_hw,\n\t\t\t\t\t   gate_ops, flags);\n}\nEXPORT_SYMBOL_GPL(clk_hw_register_composite);\n\nstruct clk_hw *clk_hw_register_composite_pdata(struct device *dev,\n\t\t\tconst char *name,\n\t\t\tconst struct clk_parent_data *parent_data,\n\t\t\tint num_parents,\n\t\t\tstruct clk_hw *mux_hw, const struct clk_ops *mux_ops,\n\t\t\tstruct clk_hw *rate_hw, const struct clk_ops *rate_ops,\n\t\t\tstruct clk_hw *gate_hw, const struct clk_ops *gate_ops,\n\t\t\tunsigned long flags)\n{\n\treturn __clk_hw_register_composite(dev, name, NULL, parent_data,\n\t\t\t\t\t   num_parents, mux_hw, mux_ops,\n\t\t\t\t\t   rate_hw, rate_ops, gate_hw,\n\t\t\t\t\t   gate_ops, flags);\n}\n\nstruct clk *clk_register_composite(struct device *dev, const char *name,\n\t\t\tconst char * const *parent_names, int num_parents,\n\t\t\tstruct clk_hw *mux_hw, const struct clk_ops *mux_ops,\n\t\t\tstruct clk_hw *rate_hw, const struct clk_ops *rate_ops,\n\t\t\tstruct clk_hw *gate_hw, const struct clk_ops *gate_ops,\n\t\t\tunsigned long flags)\n{\n\tstruct clk_hw *hw;\n\n\thw = clk_hw_register_composite(dev, name, parent_names, num_parents,\n\t\t\tmux_hw, mux_ops, rate_hw, rate_ops, gate_hw, gate_ops,\n\t\t\tflags);\n\tif (IS_ERR(hw))\n\t\treturn ERR_CAST(hw);\n\treturn hw->clk;\n}\nEXPORT_SYMBOL_GPL(clk_register_composite);\n\nstruct clk *clk_register_composite_pdata(struct device *dev, const char *name,\n\t\t\tconst struct clk_parent_data *parent_data,\n\t\t\tint num_parents,\n\t\t\tstruct clk_hw *mux_hw, const struct clk_ops *mux_ops,\n\t\t\tstruct clk_hw *rate_hw, const struct clk_ops *rate_ops,\n\t\t\tstruct clk_hw *gate_hw, const struct clk_ops *gate_ops,\n\t\t\tunsigned long flags)\n{\n\tstruct clk_hw *hw;\n\n\thw = clk_hw_register_composite_pdata(dev, name, parent_data,\n\t\t\tnum_parents, mux_hw, mux_ops, rate_hw, rate_ops,\n\t\t\tgate_hw, gate_ops, flags);\n\tif (IS_ERR(hw))\n\t\treturn ERR_CAST(hw);\n\treturn hw->clk;\n}\n\nvoid clk_unregister_composite(struct clk *clk)\n{\n\tstruct clk_composite *composite;\n\tstruct clk_hw *hw;\n\n\thw = __clk_get_hw(clk);\n\tif (!hw)\n\t\treturn;\n\n\tcomposite = to_clk_composite(hw);\n\n\tclk_unregister(clk);\n\tkfree(composite);\n}\n\nvoid clk_hw_unregister_composite(struct clk_hw *hw)\n{\n\tstruct clk_composite *composite;\n\n\tcomposite = to_clk_composite(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(composite);\n}\nEXPORT_SYMBOL_GPL(clk_hw_unregister_composite);\n\nstatic void devm_clk_hw_release_composite(struct device *dev, void *res)\n{\n\tclk_hw_unregister_composite(*(struct clk_hw **)res);\n}\n\nstatic struct clk_hw *__devm_clk_hw_register_composite(struct device *dev,\n\t\t\tconst char *name, const char * const *parent_names,\n\t\t\tconst struct clk_parent_data *pdata, int num_parents,\n\t\t\tstruct clk_hw *mux_hw, const struct clk_ops *mux_ops,\n\t\t\tstruct clk_hw *rate_hw, const struct clk_ops *rate_ops,\n\t\t\tstruct clk_hw *gate_hw, const struct clk_ops *gate_ops,\n\t\t\tunsigned long flags)\n{\n\tstruct clk_hw **ptr, *hw;\n\n\tptr = devres_alloc(devm_clk_hw_release_composite, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thw = __clk_hw_register_composite(dev, name, parent_names, pdata,\n\t\t\t\t\t num_parents, mux_hw, mux_ops, rate_hw,\n\t\t\t\t\t rate_ops, gate_hw, gate_ops, flags);\n\n\tif (!IS_ERR(hw)) {\n\t\t*ptr = hw;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn hw;\n}\n\nstruct clk_hw *devm_clk_hw_register_composite_pdata(struct device *dev,\n\t\t\tconst char *name,\n\t\t\tconst struct clk_parent_data *parent_data,\n\t\t\tint num_parents,\n\t\t\tstruct clk_hw *mux_hw, const struct clk_ops *mux_ops,\n\t\t\tstruct clk_hw *rate_hw, const struct clk_ops *rate_ops,\n\t\t\tstruct clk_hw *gate_hw, const struct clk_ops *gate_ops,\n\t\t\tunsigned long flags)\n{\n\treturn __devm_clk_hw_register_composite(dev, name, NULL, parent_data,\n\t\t\t\t\t\tnum_parents, mux_hw, mux_ops,\n\t\t\t\t\t\trate_hw, rate_ops, gate_hw,\n\t\t\t\t\t\tgate_ops, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}