{
  "module_name": "clk-ccu-div.c",
  "hash_id": "8efca903746f01d13bfe919191a695e1998779bc44a83bcaefa9c452b6dd91f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/baikal-t1/clk-ccu-div.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"bt1-ccu-div: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/clk-provider.h>\n#include <linux/reset-controller.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/ioport.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/clock/bt1-ccu.h>\n\n#include \"ccu-div.h\"\n#include \"ccu-rst.h\"\n\n#define CCU_AXI_MAIN_BASE\t\t0x030\n#define CCU_AXI_DDR_BASE\t\t0x034\n#define CCU_AXI_SATA_BASE\t\t0x038\n#define CCU_AXI_GMAC0_BASE\t\t0x03C\n#define CCU_AXI_GMAC1_BASE\t\t0x040\n#define CCU_AXI_XGMAC_BASE\t\t0x044\n#define CCU_AXI_PCIE_M_BASE\t\t0x048\n#define CCU_AXI_PCIE_S_BASE\t\t0x04C\n#define CCU_AXI_USB_BASE\t\t0x050\n#define CCU_AXI_HWA_BASE\t\t0x054\n#define CCU_AXI_SRAM_BASE\t\t0x058\n\n#define CCU_SYS_SATA_REF_BASE\t\t0x060\n#define CCU_SYS_APB_BASE\t\t0x064\n#define CCU_SYS_GMAC0_BASE\t\t0x068\n#define CCU_SYS_GMAC1_BASE\t\t0x06C\n#define CCU_SYS_XGMAC_BASE\t\t0x070\n#define CCU_SYS_USB_BASE\t\t0x074\n#define CCU_SYS_PVT_BASE\t\t0x078\n#define CCU_SYS_HWA_BASE\t\t0x07C\n#define CCU_SYS_UART_BASE\t\t0x084\n#define CCU_SYS_TIMER0_BASE\t\t0x088\n#define CCU_SYS_TIMER1_BASE\t\t0x08C\n#define CCU_SYS_TIMER2_BASE\t\t0x090\n#define CCU_SYS_WDT_BASE\t\t0x150\n\n#define CCU_DIV_VAR_INFO(_id, _name, _pname, _base, _width, _flags, _features) \\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.parent_name = _pname,\t\t\t\t\t\\\n\t\t.base = _base,\t\t\t\t\t\t\\\n\t\t.type = CCU_DIV_VAR,\t\t\t\t\t\\\n\t\t.width = _width,\t\t\t\t\t\\\n\t\t.flags = _flags,\t\t\t\t\t\\\n\t\t.features = _features\t\t\t\t\t\\\n\t}\n\n#define CCU_DIV_GATE_INFO(_id, _name, _pname, _base, _divider)\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\\\n\t\t.parent_name = _pname,\t\t\t\t\\\n\t\t.base = _base,\t\t\t\t\t\\\n\t\t.type = CCU_DIV_GATE,\t\t\t\t\\\n\t\t.divider = _divider\t\t\t\t\\\n\t}\n\n#define CCU_DIV_BUF_INFO(_id, _name, _pname, _base, _flags)\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\\\n\t\t.parent_name = _pname,\t\t\t\t\\\n\t\t.base = _base,\t\t\t\t\t\\\n\t\t.type = CCU_DIV_BUF,\t\t\t\t\\\n\t\t.flags = _flags\t\t\t\t\t\\\n\t}\n\n#define CCU_DIV_FIXED_INFO(_id, _name, _pname, _divider)\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\\\n\t\t.parent_name = _pname,\t\t\t\t\\\n\t\t.type = CCU_DIV_FIXED,\t\t\t\t\\\n\t\t.divider = _divider\t\t\t\t\\\n\t}\n\nstruct ccu_div_info {\n\tunsigned int id;\n\tconst char *name;\n\tconst char *parent_name;\n\tunsigned int base;\n\tenum ccu_div_type type;\n\tunion {\n\t\tunsigned int width;\n\t\tunsigned int divider;\n\t};\n\tunsigned long flags;\n\tunsigned long features;\n};\n\nstruct ccu_div_data {\n\tstruct device_node *np;\n\tstruct regmap *sys_regs;\n\n\tunsigned int divs_num;\n\tconst struct ccu_div_info *divs_info;\n\tstruct ccu_div **divs;\n\n\tstruct ccu_rst *rsts;\n};\n\n \nstatic const struct ccu_div_info axi_info[] = {\n\tCCU_DIV_VAR_INFO(CCU_AXI_MAIN_CLK, \"axi_main_clk\", \"pcie_clk\",\n\t\t\t CCU_AXI_MAIN_BASE, 4,\n\t\t\t CLK_IS_CRITICAL, CCU_DIV_RESET_DOMAIN),\n\tCCU_DIV_VAR_INFO(CCU_AXI_DDR_CLK, \"axi_ddr_clk\", \"sata_clk\",\n\t\t\t CCU_AXI_DDR_BASE, 4,\n\t\t\t CLK_IS_CRITICAL | CLK_SET_RATE_GATE,\n\t\t\t CCU_DIV_RESET_DOMAIN),\n\tCCU_DIV_VAR_INFO(CCU_AXI_SATA_CLK, \"axi_sata_clk\", \"sata_clk\",\n\t\t\t CCU_AXI_SATA_BASE, 4,\n\t\t\t CLK_SET_RATE_GATE, CCU_DIV_RESET_DOMAIN),\n\tCCU_DIV_VAR_INFO(CCU_AXI_GMAC0_CLK, \"axi_gmac0_clk\", \"eth_clk\",\n\t\t\t CCU_AXI_GMAC0_BASE, 4,\n\t\t\t CLK_SET_RATE_GATE, CCU_DIV_RESET_DOMAIN),\n\tCCU_DIV_VAR_INFO(CCU_AXI_GMAC1_CLK, \"axi_gmac1_clk\", \"eth_clk\",\n\t\t\t CCU_AXI_GMAC1_BASE, 4,\n\t\t\t CLK_SET_RATE_GATE, CCU_DIV_RESET_DOMAIN),\n\tCCU_DIV_VAR_INFO(CCU_AXI_XGMAC_CLK, \"axi_xgmac_clk\", \"eth_clk\",\n\t\t\t CCU_AXI_XGMAC_BASE, 4,\n\t\t\t CLK_SET_RATE_GATE, CCU_DIV_RESET_DOMAIN),\n\tCCU_DIV_VAR_INFO(CCU_AXI_PCIE_M_CLK, \"axi_pcie_m_clk\", \"pcie_clk\",\n\t\t\t CCU_AXI_PCIE_M_BASE, 4,\n\t\t\t CLK_SET_RATE_GATE, CCU_DIV_RESET_DOMAIN),\n\tCCU_DIV_VAR_INFO(CCU_AXI_PCIE_S_CLK, \"axi_pcie_s_clk\", \"pcie_clk\",\n\t\t\t CCU_AXI_PCIE_S_BASE, 4,\n\t\t\t CLK_SET_RATE_GATE, CCU_DIV_RESET_DOMAIN),\n\tCCU_DIV_VAR_INFO(CCU_AXI_USB_CLK, \"axi_usb_clk\", \"sata_clk\",\n\t\t\t CCU_AXI_USB_BASE, 4,\n\t\t\t CLK_SET_RATE_GATE, CCU_DIV_RESET_DOMAIN),\n\tCCU_DIV_VAR_INFO(CCU_AXI_HWA_CLK, \"axi_hwa_clk\", \"sata_clk\",\n\t\t\t CCU_AXI_HWA_BASE, 4,\n\t\t\t CLK_SET_RATE_GATE, CCU_DIV_RESET_DOMAIN),\n\tCCU_DIV_VAR_INFO(CCU_AXI_SRAM_CLK, \"axi_sram_clk\", \"eth_clk\",\n\t\t\t CCU_AXI_SRAM_BASE, 4,\n\t\t\t CLK_SET_RATE_GATE, CCU_DIV_RESET_DOMAIN)\n};\n\n \nstatic const struct ccu_div_info sys_info[] = {\n\tCCU_DIV_VAR_INFO(CCU_SYS_SATA_CLK, \"sys_sata_clk\",\n\t\t\t \"sata_clk\", CCU_SYS_SATA_REF_BASE, 4,\n\t\t\t CLK_SET_RATE_GATE,\n\t\t\t CCU_DIV_SKIP_ONE | CCU_DIV_LOCK_SHIFTED |\n\t\t\t CCU_DIV_RESET_DOMAIN),\n\tCCU_DIV_BUF_INFO(CCU_SYS_SATA_REF_CLK, \"sys_sata_ref_clk\",\n\t\t\t \"sys_sata_clk\", CCU_SYS_SATA_REF_BASE,\n\t\t\t CLK_SET_RATE_PARENT),\n\tCCU_DIV_VAR_INFO(CCU_SYS_APB_CLK, \"sys_apb_clk\",\n\t\t\t \"pcie_clk\", CCU_SYS_APB_BASE, 5,\n\t\t\t CLK_IS_CRITICAL, CCU_DIV_BASIC | CCU_DIV_RESET_DOMAIN),\n\tCCU_DIV_GATE_INFO(CCU_SYS_GMAC0_TX_CLK, \"sys_gmac0_tx_clk\",\n\t\t\t  \"eth_clk\", CCU_SYS_GMAC0_BASE, 5),\n\tCCU_DIV_FIXED_INFO(CCU_SYS_GMAC0_PTP_CLK, \"sys_gmac0_ptp_clk\",\n\t\t\t   \"eth_clk\", 10),\n\tCCU_DIV_GATE_INFO(CCU_SYS_GMAC1_TX_CLK, \"sys_gmac1_tx_clk\",\n\t\t\t  \"eth_clk\", CCU_SYS_GMAC1_BASE, 5),\n\tCCU_DIV_FIXED_INFO(CCU_SYS_GMAC1_PTP_CLK, \"sys_gmac1_ptp_clk\",\n\t\t\t   \"eth_clk\", 10),\n\tCCU_DIV_GATE_INFO(CCU_SYS_XGMAC_CLK, \"sys_xgmac_clk\",\n\t\t\t  \"eth_clk\", CCU_SYS_XGMAC_BASE, 1),\n\tCCU_DIV_FIXED_INFO(CCU_SYS_XGMAC_REF_CLK, \"sys_xgmac_ref_clk\",\n\t\t\t   \"sys_xgmac_clk\", 8),\n\tCCU_DIV_FIXED_INFO(CCU_SYS_XGMAC_PTP_CLK, \"sys_xgmac_ptp_clk\",\n\t\t\t   \"sys_xgmac_clk\", 8),\n\tCCU_DIV_GATE_INFO(CCU_SYS_USB_CLK, \"sys_usb_clk\",\n\t\t\t  \"eth_clk\", CCU_SYS_USB_BASE, 10),\n\tCCU_DIV_VAR_INFO(CCU_SYS_PVT_CLK, \"sys_pvt_clk\",\n\t\t\t \"ref_clk\", CCU_SYS_PVT_BASE, 5,\n\t\t\t CLK_SET_RATE_GATE, 0),\n\tCCU_DIV_VAR_INFO(CCU_SYS_HWA_CLK, \"sys_hwa_clk\",\n\t\t\t \"sata_clk\", CCU_SYS_HWA_BASE, 4,\n\t\t\t CLK_SET_RATE_GATE, 0),\n\tCCU_DIV_VAR_INFO(CCU_SYS_UART_CLK, \"sys_uart_clk\",\n\t\t\t \"eth_clk\", CCU_SYS_UART_BASE, 17,\n\t\t\t CLK_SET_RATE_GATE, 0),\n\tCCU_DIV_FIXED_INFO(CCU_SYS_I2C1_CLK, \"sys_i2c1_clk\",\n\t\t\t   \"eth_clk\", 10),\n\tCCU_DIV_FIXED_INFO(CCU_SYS_I2C2_CLK, \"sys_i2c2_clk\",\n\t\t\t   \"eth_clk\", 10),\n\tCCU_DIV_FIXED_INFO(CCU_SYS_GPIO_CLK, \"sys_gpio_clk\",\n\t\t\t   \"ref_clk\", 25),\n\tCCU_DIV_VAR_INFO(CCU_SYS_TIMER0_CLK, \"sys_timer0_clk\",\n\t\t\t \"ref_clk\", CCU_SYS_TIMER0_BASE, 17,\n\t\t\t CLK_SET_RATE_GATE, CCU_DIV_BASIC),\n\tCCU_DIV_VAR_INFO(CCU_SYS_TIMER1_CLK, \"sys_timer1_clk\",\n\t\t\t \"ref_clk\", CCU_SYS_TIMER1_BASE, 17,\n\t\t\t CLK_SET_RATE_GATE, CCU_DIV_BASIC),\n\tCCU_DIV_VAR_INFO(CCU_SYS_TIMER2_CLK, \"sys_timer2_clk\",\n\t\t\t \"ref_clk\", CCU_SYS_TIMER2_BASE, 17,\n\t\t\t CLK_SET_RATE_GATE, CCU_DIV_BASIC),\n\tCCU_DIV_VAR_INFO(CCU_SYS_WDT_CLK, \"sys_wdt_clk\",\n\t\t\t \"eth_clk\", CCU_SYS_WDT_BASE, 17,\n\t\t\t CLK_SET_RATE_GATE, CCU_DIV_SKIP_ONE_TO_THREE)\n};\n\nstatic struct ccu_div_data *axi_data;\nstatic struct ccu_div_data *sys_data;\n\nstatic void ccu_div_set_data(struct ccu_div_data *data)\n{\n\tstruct device_node *np = data->np;\n\n\tif (of_device_is_compatible(np, \"baikal,bt1-ccu-axi\"))\n\t\taxi_data = data;\n\telse if (of_device_is_compatible(np, \"baikal,bt1-ccu-sys\"))\n\t\tsys_data = data;\n\telse\n\t\tpr_err(\"Invalid DT node '%s' specified\\n\", of_node_full_name(np));\n}\n\nstatic struct ccu_div_data *ccu_div_get_data(struct device_node *np)\n{\n\tif (of_device_is_compatible(np, \"baikal,bt1-ccu-axi\"))\n\t\treturn axi_data;\n\telse if (of_device_is_compatible(np, \"baikal,bt1-ccu-sys\"))\n\t\treturn sys_data;\n\n\tpr_err(\"Invalid DT node '%s' specified\\n\", of_node_full_name(np));\n\n\treturn NULL;\n}\n\nstatic struct ccu_div *ccu_div_find_desc(struct ccu_div_data *data,\n\t\t\t\t\t unsigned int clk_id)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < data->divs_num; ++idx) {\n\t\tif (data->divs_info[idx].id == clk_id)\n\t\t\treturn data->divs[idx];\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct ccu_div_data *ccu_div_create_data(struct device_node *np)\n{\n\tstruct ccu_div_data *data;\n\tint ret;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata->np = np;\n\tif (of_device_is_compatible(np, \"baikal,bt1-ccu-axi\")) {\n\t\tdata->divs_num = ARRAY_SIZE(axi_info);\n\t\tdata->divs_info = axi_info;\n\t} else if (of_device_is_compatible(np, \"baikal,bt1-ccu-sys\")) {\n\t\tdata->divs_num = ARRAY_SIZE(sys_info);\n\t\tdata->divs_info = sys_info;\n\t} else {\n\t\tpr_err(\"Incompatible DT node '%s' specified\\n\",\n\t\t\tof_node_full_name(np));\n\t\tret = -EINVAL;\n\t\tgoto err_kfree_data;\n\t}\n\n\tdata->divs = kcalloc(data->divs_num, sizeof(*data->divs), GFP_KERNEL);\n\tif (!data->divs) {\n\t\tret = -ENOMEM;\n\t\tgoto err_kfree_data;\n\t}\n\n\treturn data;\n\nerr_kfree_data:\n\tkfree(data);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic void ccu_div_free_data(struct ccu_div_data *data)\n{\n\tkfree(data->divs);\n\n\tkfree(data);\n}\n\nstatic int ccu_div_find_sys_regs(struct ccu_div_data *data)\n{\n\tdata->sys_regs = syscon_node_to_regmap(data->np->parent);\n\tif (IS_ERR(data->sys_regs)) {\n\t\tpr_err(\"Failed to find syscon regs for '%s'\\n\",\n\t\t\tof_node_full_name(data->np));\n\t\treturn PTR_ERR(data->sys_regs);\n\t}\n\n\treturn 0;\n}\n\nstatic struct clk_hw *ccu_div_of_clk_hw_get(struct of_phandle_args *clkspec,\n\t\t\t\t\t    void *priv)\n{\n\tstruct ccu_div_data *data = priv;\n\tstruct ccu_div *div;\n\tunsigned int clk_id;\n\n\tclk_id = clkspec->args[0];\n\tdiv = ccu_div_find_desc(data, clk_id);\n\tif (IS_ERR(div)) {\n\t\tif (div != ERR_PTR(-EPROBE_DEFER))\n\t\t\tpr_info(\"Invalid clock ID %d specified\\n\", clk_id);\n\n\t\treturn ERR_CAST(div);\n\t}\n\n\treturn ccu_div_get_clk_hw(div);\n}\n\nstatic int ccu_div_clk_register(struct ccu_div_data *data, bool defer)\n{\n\tint idx, ret;\n\n\tfor (idx = 0; idx < data->divs_num; ++idx) {\n\t\tconst struct ccu_div_info *info = &data->divs_info[idx];\n\t\tstruct ccu_div_init_data init = {0};\n\n\t\tif (!!(info->features & CCU_DIV_BASIC) ^ defer) {\n\t\t\tif (!data->divs[idx])\n\t\t\t\tdata->divs[idx] = ERR_PTR(-EPROBE_DEFER);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tinit.id = info->id;\n\t\tinit.name = info->name;\n\t\tinit.parent_name = info->parent_name;\n\t\tinit.np = data->np;\n\t\tinit.type = info->type;\n\t\tinit.flags = info->flags;\n\t\tinit.features = info->features;\n\n\t\tif (init.type == CCU_DIV_VAR) {\n\t\t\tinit.base = info->base;\n\t\t\tinit.sys_regs = data->sys_regs;\n\t\t\tinit.width = info->width;\n\t\t} else if (init.type == CCU_DIV_GATE) {\n\t\t\tinit.base = info->base;\n\t\t\tinit.sys_regs = data->sys_regs;\n\t\t\tinit.divider = info->divider;\n\t\t} else if (init.type == CCU_DIV_BUF) {\n\t\t\tinit.base = info->base;\n\t\t\tinit.sys_regs = data->sys_regs;\n\t\t} else {\n\t\t\tinit.divider = info->divider;\n\t\t}\n\n\t\tdata->divs[idx] = ccu_div_hw_register(&init);\n\t\tif (IS_ERR(data->divs[idx])) {\n\t\t\tret = PTR_ERR(data->divs[idx]);\n\t\t\tpr_err(\"Couldn't register divider '%s' hw\\n\",\n\t\t\t\tinit.name);\n\t\t\tgoto err_hw_unregister;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_hw_unregister:\n\tfor (--idx; idx >= 0; --idx) {\n\t\tif (!!(data->divs_info[idx].features & CCU_DIV_BASIC) ^ defer)\n\t\t\tcontinue;\n\n\t\tccu_div_hw_unregister(data->divs[idx]);\n\t}\n\n\treturn ret;\n}\n\nstatic void ccu_div_clk_unregister(struct ccu_div_data *data, bool defer)\n{\n\tint idx;\n\n\t \n\tfor (idx = 0; idx < data->divs_num; ++idx) {\n\t\tif (!!(data->divs_info[idx].features & CCU_DIV_BASIC) ^ defer)\n\t\t\tcontinue;\n\n\t\tccu_div_hw_unregister(data->divs[idx]);\n\t}\n}\n\nstatic int ccu_div_of_register(struct ccu_div_data *data)\n{\n\tint ret;\n\n\tret = of_clk_add_hw_provider(data->np, ccu_div_of_clk_hw_get, data);\n\tif (ret) {\n\t\tpr_err(\"Couldn't register dividers '%s' clock provider\\n\",\n\t\t       of_node_full_name(data->np));\n\t}\n\n\treturn ret;\n}\n\nstatic int ccu_div_rst_register(struct ccu_div_data *data)\n{\n\tstruct ccu_rst_init_data init = {0};\n\n\tinit.sys_regs = data->sys_regs;\n\tinit.np = data->np;\n\n\tdata->rsts = ccu_rst_hw_register(&init);\n\tif (IS_ERR(data->rsts)) {\n\t\tpr_err(\"Couldn't register divider '%s' reset controller\\n\",\n\t\t\tof_node_full_name(data->np));\n\t\treturn PTR_ERR(data->rsts);\n\t}\n\n\treturn 0;\n}\n\nstatic int ccu_div_probe(struct platform_device *pdev)\n{\n\tstruct ccu_div_data *data;\n\tint ret;\n\n\tdata = ccu_div_get_data(dev_of_node(&pdev->dev));\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tret = ccu_div_clk_register(data, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ccu_div_rst_register(data);\n\tif (ret)\n\t\tgoto err_clk_unregister;\n\n\treturn 0;\n\nerr_clk_unregister:\n\tccu_div_clk_unregister(data, false);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id ccu_div_of_match[] = {\n\t{ .compatible = \"baikal,bt1-ccu-axi\" },\n\t{ .compatible = \"baikal,bt1-ccu-sys\" },\n\t{ }\n};\n\nstatic struct platform_driver ccu_div_driver = {\n\t.probe  = ccu_div_probe,\n\t.driver = {\n\t\t.name = \"clk-ccu-div\",\n\t\t.of_match_table = ccu_div_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(ccu_div_driver);\n\nstatic __init void ccu_div_init(struct device_node *np)\n{\n\tstruct ccu_div_data *data;\n\tint ret;\n\n\tdata = ccu_div_create_data(np);\n\tif (IS_ERR(data))\n\t\treturn;\n\n\tret = ccu_div_find_sys_regs(data);\n\tif (ret)\n\t\tgoto err_free_data;\n\n\tret = ccu_div_clk_register(data, true);\n\tif (ret)\n\t\tgoto err_free_data;\n\n\tret = ccu_div_of_register(data);\n\tif (ret)\n\t\tgoto err_clk_unregister;\n\n\tccu_div_set_data(data);\n\n\treturn;\n\nerr_clk_unregister:\n\tccu_div_clk_unregister(data, true);\n\nerr_free_data:\n\tccu_div_free_data(data);\n}\nCLK_OF_DECLARE_DRIVER(ccu_axi, \"baikal,bt1-ccu-axi\", ccu_div_init);\nCLK_OF_DECLARE_DRIVER(ccu_sys, \"baikal,bt1-ccu-sys\", ccu_div_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}