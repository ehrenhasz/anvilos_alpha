{
  "module_name": "clk-ccu-pll.c",
  "hash_id": "d36a3c9cb946b96728235f3fe9efca43f1b33acaa9d24adc9a6ea73e3c1a8415",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/baikal-t1/clk-ccu-pll.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"bt1-ccu-pll: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/clk-provider.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/ioport.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/clock/bt1-ccu.h>\n\n#include \"ccu-pll.h\"\n\n#define CCU_CPU_PLL_BASE\t\t0x000\n#define CCU_SATA_PLL_BASE\t\t0x008\n#define CCU_DDR_PLL_BASE\t\t0x010\n#define CCU_PCIE_PLL_BASE\t\t0x018\n#define CCU_ETH_PLL_BASE\t\t0x020\n\n#define CCU_PLL_INFO(_id, _name, _pname, _base, _flags, _features)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.parent_name = _pname,\t\t\t\t\t\\\n\t\t.base = _base,\t\t\t\t\t\t\\\n\t\t.flags = _flags,\t\t\t\t\t\\\n\t\t.features = _features,\t\t\t\t\t\\\n\t}\n\n#define CCU_PLL_NUM\t\t\tARRAY_SIZE(pll_info)\n\nstruct ccu_pll_info {\n\tunsigned int id;\n\tconst char *name;\n\tconst char *parent_name;\n\tunsigned int base;\n\tunsigned long flags;\n\tunsigned long features;\n};\n\n \nstatic const struct ccu_pll_info pll_info[] = {\n\tCCU_PLL_INFO(CCU_CPU_PLL, \"cpu_pll\", \"ref_clk\", CCU_CPU_PLL_BASE,\n\t\t     CLK_IS_CRITICAL, CCU_PLL_BASIC),\n\tCCU_PLL_INFO(CCU_SATA_PLL, \"sata_pll\", \"ref_clk\", CCU_SATA_PLL_BASE,\n\t\t     CLK_IS_CRITICAL | CLK_SET_RATE_GATE, 0),\n\tCCU_PLL_INFO(CCU_DDR_PLL, \"ddr_pll\", \"ref_clk\", CCU_DDR_PLL_BASE,\n\t\t     CLK_IS_CRITICAL | CLK_SET_RATE_GATE, 0),\n\tCCU_PLL_INFO(CCU_PCIE_PLL, \"pcie_pll\", \"ref_clk\", CCU_PCIE_PLL_BASE,\n\t\t     CLK_IS_CRITICAL, CCU_PLL_BASIC),\n\tCCU_PLL_INFO(CCU_ETH_PLL, \"eth_pll\", \"ref_clk\", CCU_ETH_PLL_BASE,\n\t\t     CLK_IS_CRITICAL | CLK_SET_RATE_GATE, 0)\n};\n\nstruct ccu_pll_data {\n\tstruct device_node *np;\n\tstruct regmap *sys_regs;\n\tstruct ccu_pll *plls[CCU_PLL_NUM];\n};\n\nstatic struct ccu_pll_data *pll_data;\n\nstatic struct ccu_pll *ccu_pll_find_desc(struct ccu_pll_data *data,\n\t\t\t\t\t unsigned int clk_id)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < CCU_PLL_NUM; ++idx) {\n\t\tif (pll_info[idx].id == clk_id)\n\t\t\treturn data->plls[idx];\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct ccu_pll_data *ccu_pll_create_data(struct device_node *np)\n{\n\tstruct ccu_pll_data *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata->np = np;\n\n\treturn data;\n}\n\nstatic void ccu_pll_free_data(struct ccu_pll_data *data)\n{\n\tkfree(data);\n}\n\nstatic int ccu_pll_find_sys_regs(struct ccu_pll_data *data)\n{\n\tdata->sys_regs = syscon_node_to_regmap(data->np->parent);\n\tif (IS_ERR(data->sys_regs)) {\n\t\tpr_err(\"Failed to find syscon regs for '%s'\\n\",\n\t\t\tof_node_full_name(data->np));\n\t\treturn PTR_ERR(data->sys_regs);\n\t}\n\n\treturn 0;\n}\n\nstatic struct clk_hw *ccu_pll_of_clk_hw_get(struct of_phandle_args *clkspec,\n\t\t\t\t\t    void *priv)\n{\n\tstruct ccu_pll_data *data = priv;\n\tstruct ccu_pll *pll;\n\tunsigned int clk_id;\n\n\tclk_id = clkspec->args[0];\n\tpll = ccu_pll_find_desc(data, clk_id);\n\tif (IS_ERR(pll)) {\n\t\tif (pll != ERR_PTR(-EPROBE_DEFER))\n\t\t\tpr_info(\"Invalid PLL clock ID %d specified\\n\", clk_id);\n\n\t\treturn ERR_CAST(pll);\n\t}\n\n\treturn ccu_pll_get_clk_hw(pll);\n}\n\nstatic int ccu_pll_clk_register(struct ccu_pll_data *data, bool defer)\n{\n\tint idx, ret;\n\n\tfor (idx = 0; idx < CCU_PLL_NUM; ++idx) {\n\t\tconst struct ccu_pll_info *info = &pll_info[idx];\n\t\tstruct ccu_pll_init_data init = {0};\n\n\t\t \n\t\tif (!!(info->features & CCU_PLL_BASIC) ^ defer) {\n\t\t\tif (!data->plls[idx])\n\t\t\t\tdata->plls[idx] = ERR_PTR(-EPROBE_DEFER);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tinit.id = info->id;\n\t\tinit.name = info->name;\n\t\tinit.parent_name = info->parent_name;\n\t\tinit.base = info->base;\n\t\tinit.sys_regs = data->sys_regs;\n\t\tinit.np = data->np;\n\t\tinit.flags = info->flags;\n\t\tinit.features = info->features;\n\n\t\tdata->plls[idx] = ccu_pll_hw_register(&init);\n\t\tif (IS_ERR(data->plls[idx])) {\n\t\t\tret = PTR_ERR(data->plls[idx]);\n\t\t\tpr_err(\"Couldn't register PLL hw '%s'\\n\",\n\t\t\t\tinit.name);\n\t\t\tgoto err_hw_unregister;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_hw_unregister:\n\tfor (--idx; idx >= 0; --idx) {\n\t\tif (!!(pll_info[idx].features & CCU_PLL_BASIC) ^ defer)\n\t\t\tcontinue;\n\n\t\tccu_pll_hw_unregister(data->plls[idx]);\n\t}\n\n\treturn ret;\n}\n\nstatic void ccu_pll_clk_unregister(struct ccu_pll_data *data, bool defer)\n{\n\tint idx;\n\n\t \n\tfor (idx = 0; idx < CCU_PLL_NUM; ++idx) {\n\t\tif (!!(pll_info[idx].features & CCU_PLL_BASIC) ^ defer)\n\t\t\tcontinue;\n\n\t\tccu_pll_hw_unregister(data->plls[idx]);\n\t}\n}\n\nstatic int ccu_pll_of_register(struct ccu_pll_data *data)\n{\n\tint ret;\n\n\tret = of_clk_add_hw_provider(data->np, ccu_pll_of_clk_hw_get, data);\n\tif (ret) {\n\t\tpr_err(\"Couldn't register PLL provider of '%s'\\n\",\n\t\t\tof_node_full_name(data->np));\n\t}\n\n\treturn ret;\n}\n\nstatic int ccu_pll_probe(struct platform_device *pdev)\n{\n\tstruct ccu_pll_data *data = pll_data;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\treturn ccu_pll_clk_register(data, false);\n}\n\nstatic const struct of_device_id ccu_pll_of_match[] = {\n\t{ .compatible = \"baikal,bt1-ccu-pll\" },\n\t{ }\n};\n\nstatic struct platform_driver ccu_pll_driver = {\n\t.probe  = ccu_pll_probe,\n\t.driver = {\n\t\t.name = \"clk-ccu-pll\",\n\t\t.of_match_table = ccu_pll_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(ccu_pll_driver);\n\nstatic __init void ccu_pll_init(struct device_node *np)\n{\n\tstruct ccu_pll_data *data;\n\tint ret;\n\n\tdata = ccu_pll_create_data(np);\n\tif (IS_ERR(data))\n\t\treturn;\n\n\tret = ccu_pll_find_sys_regs(data);\n\tif (ret)\n\t\tgoto err_free_data;\n\n\tret = ccu_pll_clk_register(data, true);\n\tif (ret)\n\t\tgoto err_free_data;\n\n\tret = ccu_pll_of_register(data);\n\tif (ret)\n\t\tgoto err_clk_unregister;\n\n\tpll_data = data;\n\n\treturn;\n\nerr_clk_unregister:\n\tccu_pll_clk_unregister(data, true);\n\nerr_free_data:\n\tccu_pll_free_data(data);\n}\nCLK_OF_DECLARE_DRIVER(ccu_pll, \"baikal,bt1-ccu-pll\", ccu_pll_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}