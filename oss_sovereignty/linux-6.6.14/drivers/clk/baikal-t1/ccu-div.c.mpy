{
  "module_name": "ccu-div.c",
  "hash_id": "3da3a22c94a6f6f7b5605d76c8d859cce71e31a7fe9ddc45274390ae657fe94f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/baikal-t1/ccu-div.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"bt1-ccu-div: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/printk.h>\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/slab.h>\n#include <linux/clk-provider.h>\n#include <linux/of.h>\n#include <linux/spinlock.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n#include <linux/time64.h>\n#include <linux/debugfs.h>\n\n#include \"ccu-div.h\"\n\n#define CCU_DIV_CTL\t\t\t0x00\n#define CCU_DIV_CTL_EN\t\t\tBIT(0)\n#define CCU_DIV_CTL_RST\t\t\tBIT(1)\n#define CCU_DIV_CTL_SET_CLKDIV\t\tBIT(2)\n#define CCU_DIV_CTL_CLKDIV_FLD\t\t4\n#define CCU_DIV_CTL_CLKDIV_MASK(_width) \\\n\tGENMASK((_width) + CCU_DIV_CTL_CLKDIV_FLD - 1, CCU_DIV_CTL_CLKDIV_FLD)\n#define CCU_DIV_CTL_LOCK_SHIFTED\tBIT(27)\n#define CCU_DIV_CTL_GATE_REF_BUF\tBIT(28)\n#define CCU_DIV_CTL_LOCK_NORMAL\t\tBIT(31)\n\n#define CCU_DIV_LOCK_CHECK_RETRIES\t50\n\n#define CCU_DIV_CLKDIV_MIN\t\t0\n#define CCU_DIV_CLKDIV_MAX(_mask) \\\n\t((_mask) >> CCU_DIV_CTL_CLKDIV_FLD)\n\n \nstatic inline u32 ccu_div_get(u32 mask, u32 val)\n{\n\treturn (val & mask) >> CCU_DIV_CTL_CLKDIV_FLD;\n}\n\nstatic inline u32 ccu_div_prep(u32 mask, u32 val)\n{\n\treturn (val << CCU_DIV_CTL_CLKDIV_FLD) & mask;\n}\n\nstatic inline unsigned long ccu_div_lock_delay_ns(unsigned long ref_clk,\n\t\t\t\t\t\t  unsigned long div)\n{\n\tu64 ns = 4ULL * (div ?: 1) * NSEC_PER_SEC;\n\n\tdo_div(ns, ref_clk);\n\n\treturn ns;\n}\n\nstatic inline unsigned long ccu_div_calc_freq(unsigned long ref_clk,\n\t\t\t\t\t      unsigned long div)\n{\n\treturn ref_clk / (div ?: 1);\n}\n\nstatic int ccu_div_var_update_clkdiv(struct ccu_div *div,\n\t\t\t\t     unsigned long parent_rate,\n\t\t\t\t     unsigned long divider)\n{\n\tunsigned long nd;\n\tu32 val = 0;\n\tu32 lock;\n\tint count;\n\n\tnd = ccu_div_lock_delay_ns(parent_rate, divider);\n\n\tif (div->features & CCU_DIV_LOCK_SHIFTED)\n\t\tlock = CCU_DIV_CTL_LOCK_SHIFTED;\n\telse\n\t\tlock = CCU_DIV_CTL_LOCK_NORMAL;\n\n\tregmap_update_bits(div->sys_regs, div->reg_ctl,\n\t\t\t   CCU_DIV_CTL_SET_CLKDIV, CCU_DIV_CTL_SET_CLKDIV);\n\n\t \n\tcount = CCU_DIV_LOCK_CHECK_RETRIES;\n\tdo {\n\t\tndelay(nd);\n\t\tregmap_read(div->sys_regs, div->reg_ctl, &val);\n\t\tif (val & lock)\n\t\t\treturn 0;\n\t} while (--count);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int ccu_div_var_enable(struct clk_hw *hw)\n{\n\tstruct clk_hw *parent_hw = clk_hw_get_parent(hw);\n\tstruct ccu_div *div = to_ccu_div(hw);\n\tunsigned long flags;\n\tu32 val = 0;\n\tint ret;\n\n\tif (!parent_hw) {\n\t\tpr_err(\"Can't enable '%s' with no parent\", clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_read(div->sys_regs, div->reg_ctl, &val);\n\tif (val & CCU_DIV_CTL_EN)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&div->lock, flags);\n\tret = ccu_div_var_update_clkdiv(div, clk_hw_get_rate(parent_hw),\n\t\t\t\t\tccu_div_get(div->mask, val));\n\tif (!ret)\n\t\tregmap_update_bits(div->sys_regs, div->reg_ctl,\n\t\t\t\t   CCU_DIV_CTL_EN, CCU_DIV_CTL_EN);\n\tspin_unlock_irqrestore(&div->lock, flags);\n\tif (ret)\n\t\tpr_err(\"Divider '%s' lock timed out\\n\", clk_hw_get_name(hw));\n\n\treturn ret;\n}\n\nstatic int ccu_div_gate_enable(struct clk_hw *hw)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&div->lock, flags);\n\tregmap_update_bits(div->sys_regs, div->reg_ctl,\n\t\t\t   CCU_DIV_CTL_EN, CCU_DIV_CTL_EN);\n\tspin_unlock_irqrestore(&div->lock, flags);\n\n\treturn 0;\n}\n\nstatic void ccu_div_gate_disable(struct clk_hw *hw)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&div->lock, flags);\n\tregmap_update_bits(div->sys_regs, div->reg_ctl, CCU_DIV_CTL_EN, 0);\n\tspin_unlock_irqrestore(&div->lock, flags);\n}\n\nstatic int ccu_div_gate_is_enabled(struct clk_hw *hw)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\tu32 val = 0;\n\n\tregmap_read(div->sys_regs, div->reg_ctl, &val);\n\n\treturn !!(val & CCU_DIV_CTL_EN);\n}\n\nstatic int ccu_div_buf_enable(struct clk_hw *hw)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&div->lock, flags);\n\tregmap_update_bits(div->sys_regs, div->reg_ctl,\n\t\t\t   CCU_DIV_CTL_GATE_REF_BUF, 0);\n\tspin_unlock_irqrestore(&div->lock, flags);\n\n\treturn 0;\n}\n\nstatic void ccu_div_buf_disable(struct clk_hw *hw)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&div->lock, flags);\n\tregmap_update_bits(div->sys_regs, div->reg_ctl,\n\t\t\t   CCU_DIV_CTL_GATE_REF_BUF, CCU_DIV_CTL_GATE_REF_BUF);\n\tspin_unlock_irqrestore(&div->lock, flags);\n}\n\nstatic int ccu_div_buf_is_enabled(struct clk_hw *hw)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\tu32 val = 0;\n\n\tregmap_read(div->sys_regs, div->reg_ctl, &val);\n\n\treturn !(val & CCU_DIV_CTL_GATE_REF_BUF);\n}\n\nstatic unsigned long ccu_div_var_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\tunsigned long divider;\n\tu32 val = 0;\n\n\tregmap_read(div->sys_regs, div->reg_ctl, &val);\n\tdivider = ccu_div_get(div->mask, val);\n\n\treturn ccu_div_calc_freq(parent_rate, divider);\n}\n\nstatic inline unsigned long ccu_div_var_calc_divider(unsigned long rate,\n\t\t\t\t\t\t     unsigned long parent_rate,\n\t\t\t\t\t\t     unsigned int mask)\n{\n\tunsigned long divider;\n\n\tdivider = parent_rate / rate;\n\treturn clamp_t(unsigned long, divider, CCU_DIV_CLKDIV_MIN,\n\t\t       CCU_DIV_CLKDIV_MAX(mask));\n}\n\nstatic long ccu_div_var_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long *parent_rate)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\tunsigned long divider;\n\n\tdivider = ccu_div_var_calc_divider(rate, *parent_rate, div->mask);\n\n\treturn ccu_div_calc_freq(*parent_rate, divider);\n}\n\n \nstatic int ccu_div_var_set_rate_slow(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\tunsigned long flags, divider;\n\tu32 val;\n\tint ret;\n\n\tdivider = ccu_div_var_calc_divider(rate, parent_rate, div->mask);\n\tif (divider == 1 && div->features & CCU_DIV_SKIP_ONE) {\n\t\tdivider = 0;\n\t} else if (div->features & CCU_DIV_SKIP_ONE_TO_THREE) {\n\t\tif (divider == 1 || divider == 2)\n\t\t\tdivider = 0;\n\t\telse if (divider == 3)\n\t\t\tdivider = 4;\n\t}\n\n\tval = ccu_div_prep(div->mask, divider);\n\n\tspin_lock_irqsave(&div->lock, flags);\n\tregmap_update_bits(div->sys_regs, div->reg_ctl, div->mask, val);\n\tret = ccu_div_var_update_clkdiv(div, parent_rate, divider);\n\tspin_unlock_irqrestore(&div->lock, flags);\n\tif (ret)\n\t\tpr_err(\"Divider '%s' lock timed out\\n\", clk_hw_get_name(hw));\n\n\treturn ret;\n}\n\n \nstatic int ccu_div_var_set_rate_fast(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\tunsigned long flags, divider;\n\tu32 val;\n\n\tdivider = ccu_div_var_calc_divider(rate, parent_rate, div->mask);\n\tval = ccu_div_prep(div->mask, divider);\n\n\t \n\tspin_lock_irqsave(&div->lock, flags);\n\tregmap_update_bits(div->sys_regs, div->reg_ctl,\n\t\t\t   div->mask | CCU_DIV_CTL_EN, val);\n\tspin_unlock_irqrestore(&div->lock, flags);\n\n\treturn 0;\n}\n\nstatic unsigned long ccu_div_fixed_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\n\treturn ccu_div_calc_freq(parent_rate, div->divider);\n}\n\nstatic long ccu_div_fixed_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long *parent_rate)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\n\treturn ccu_div_calc_freq(*parent_rate, div->divider);\n}\n\nstatic int ccu_div_fixed_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\n\nstruct ccu_div_dbgfs_bit {\n\tstruct ccu_div *div;\n\tconst char *name;\n\tu32 mask;\n};\n\n#define CCU_DIV_DBGFS_BIT_ATTR(_name, _mask) {\t\\\n\t\t.name = _name,\t\t\t\\\n\t\t.mask = _mask\t\t\t\\\n\t}\n\nstatic const struct ccu_div_dbgfs_bit ccu_div_bits[] = {\n\tCCU_DIV_DBGFS_BIT_ATTR(\"div_en\", CCU_DIV_CTL_EN),\n\tCCU_DIV_DBGFS_BIT_ATTR(\"div_rst\", CCU_DIV_CTL_RST),\n\tCCU_DIV_DBGFS_BIT_ATTR(\"div_bypass\", CCU_DIV_CTL_SET_CLKDIV),\n\tCCU_DIV_DBGFS_BIT_ATTR(\"div_buf\", CCU_DIV_CTL_GATE_REF_BUF),\n\tCCU_DIV_DBGFS_BIT_ATTR(\"div_lock\", CCU_DIV_CTL_LOCK_NORMAL)\n};\n\n#define CCU_DIV_DBGFS_BIT_NUM\tARRAY_SIZE(ccu_div_bits)\n\n \n#undef CCU_DIV_ALLOW_WRITE_DEBUGFS\n#ifdef CCU_DIV_ALLOW_WRITE_DEBUGFS\n\nstatic int ccu_div_dbgfs_bit_set(void *priv, u64 val)\n{\n\tconst struct ccu_div_dbgfs_bit *bit = priv;\n\tstruct ccu_div *div = bit->div;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&div->lock, flags);\n\tregmap_update_bits(div->sys_regs, div->reg_ctl,\n\t\t\t   bit->mask, val ? bit->mask : 0);\n\tspin_unlock_irqrestore(&div->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ccu_div_dbgfs_var_clkdiv_set(void *priv, u64 val)\n{\n\tstruct ccu_div *div = priv;\n\tunsigned long flags;\n\tu32 data;\n\n\tval = clamp_t(u64, val, CCU_DIV_CLKDIV_MIN,\n\t\t      CCU_DIV_CLKDIV_MAX(div->mask));\n\tdata = ccu_div_prep(div->mask, val);\n\n\tspin_lock_irqsave(&div->lock, flags);\n\tregmap_update_bits(div->sys_regs, div->reg_ctl, div->mask, data);\n\tspin_unlock_irqrestore(&div->lock, flags);\n\n\treturn 0;\n}\n\n#define ccu_div_dbgfs_mode\t\t0644\n\n#else  \n\n#define ccu_div_dbgfs_bit_set\t\tNULL\n#define ccu_div_dbgfs_var_clkdiv_set\tNULL\n#define ccu_div_dbgfs_mode\t\t0444\n\n#endif  \n\nstatic int ccu_div_dbgfs_bit_get(void *priv, u64 *val)\n{\n\tconst struct ccu_div_dbgfs_bit *bit = priv;\n\tstruct ccu_div *div = bit->div;\n\tu32 data = 0;\n\n\tregmap_read(div->sys_regs, div->reg_ctl, &data);\n\t*val = !!(data & bit->mask);\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(ccu_div_dbgfs_bit_fops,\n\tccu_div_dbgfs_bit_get, ccu_div_dbgfs_bit_set, \"%llu\\n\");\n\nstatic int ccu_div_dbgfs_var_clkdiv_get(void *priv, u64 *val)\n{\n\tstruct ccu_div *div = priv;\n\tu32 data = 0;\n\n\tregmap_read(div->sys_regs, div->reg_ctl, &data);\n\t*val = ccu_div_get(div->mask, data);\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(ccu_div_dbgfs_var_clkdiv_fops,\n\tccu_div_dbgfs_var_clkdiv_get, ccu_div_dbgfs_var_clkdiv_set, \"%llu\\n\");\n\nstatic int ccu_div_dbgfs_fixed_clkdiv_get(void *priv, u64 *val)\n{\n\tstruct ccu_div *div = priv;\n\n\t*val = div->divider;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(ccu_div_dbgfs_fixed_clkdiv_fops,\n\tccu_div_dbgfs_fixed_clkdiv_get, NULL, \"%llu\\n\");\n\nstatic void ccu_div_var_debug_init(struct clk_hw *hw, struct dentry *dentry)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\tstruct ccu_div_dbgfs_bit *bits;\n\tint didx, bidx, num = 2;\n\tconst char *name;\n\n\tnum += !!(div->flags & CLK_SET_RATE_GATE) +\n\t\t!!(div->features & CCU_DIV_RESET_DOMAIN);\n\n\tbits = kcalloc(num, sizeof(*bits), GFP_KERNEL);\n\tif (!bits)\n\t\treturn;\n\n\tfor (didx = 0, bidx = 0; bidx < CCU_DIV_DBGFS_BIT_NUM; ++bidx) {\n\t\tname = ccu_div_bits[bidx].name;\n\t\tif (!(div->flags & CLK_SET_RATE_GATE) &&\n\t\t    !strcmp(\"div_en\", name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(div->features & CCU_DIV_RESET_DOMAIN) &&\n\t\t    !strcmp(\"div_rst\", name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(\"div_buf\", name))\n\t\t\tcontinue;\n\n\t\tbits[didx] = ccu_div_bits[bidx];\n\t\tbits[didx].div = div;\n\n\t\tif (div->features & CCU_DIV_LOCK_SHIFTED &&\n\t\t    !strcmp(\"div_lock\", name)) {\n\t\t\tbits[didx].mask = CCU_DIV_CTL_LOCK_SHIFTED;\n\t\t}\n\n\t\tdebugfs_create_file_unsafe(bits[didx].name, ccu_div_dbgfs_mode,\n\t\t\t\t\t   dentry, &bits[didx],\n\t\t\t\t\t   &ccu_div_dbgfs_bit_fops);\n\t\t++didx;\n\t}\n\n\tdebugfs_create_file_unsafe(\"div_clkdiv\", ccu_div_dbgfs_mode, dentry,\n\t\t\t\t   div, &ccu_div_dbgfs_var_clkdiv_fops);\n}\n\nstatic void ccu_div_gate_debug_init(struct clk_hw *hw, struct dentry *dentry)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\tstruct ccu_div_dbgfs_bit *bit;\n\n\tbit = kmalloc(sizeof(*bit), GFP_KERNEL);\n\tif (!bit)\n\t\treturn;\n\n\t*bit = ccu_div_bits[0];\n\tbit->div = div;\n\tdebugfs_create_file_unsafe(bit->name, ccu_div_dbgfs_mode, dentry, bit,\n\t\t\t\t   &ccu_div_dbgfs_bit_fops);\n\n\tdebugfs_create_file_unsafe(\"div_clkdiv\", 0400, dentry, div,\n\t\t\t\t   &ccu_div_dbgfs_fixed_clkdiv_fops);\n}\n\nstatic void ccu_div_buf_debug_init(struct clk_hw *hw, struct dentry *dentry)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\tstruct ccu_div_dbgfs_bit *bit;\n\n\tbit = kmalloc(sizeof(*bit), GFP_KERNEL);\n\tif (!bit)\n\t\treturn;\n\n\t*bit = ccu_div_bits[3];\n\tbit->div = div;\n\tdebugfs_create_file_unsafe(bit->name, ccu_div_dbgfs_mode, dentry, bit,\n\t\t\t\t   &ccu_div_dbgfs_bit_fops);\n}\n\nstatic void ccu_div_fixed_debug_init(struct clk_hw *hw, struct dentry *dentry)\n{\n\tstruct ccu_div *div = to_ccu_div(hw);\n\n\tdebugfs_create_file_unsafe(\"div_clkdiv\", 0400, dentry, div,\n\t\t\t\t   &ccu_div_dbgfs_fixed_clkdiv_fops);\n}\n\n#else  \n\n#define ccu_div_var_debug_init NULL\n#define ccu_div_gate_debug_init NULL\n#define ccu_div_buf_debug_init NULL\n#define ccu_div_fixed_debug_init NULL\n\n#endif  \n\nstatic const struct clk_ops ccu_div_var_gate_to_set_ops = {\n\t.enable = ccu_div_var_enable,\n\t.disable = ccu_div_gate_disable,\n\t.is_enabled = ccu_div_gate_is_enabled,\n\t.recalc_rate = ccu_div_var_recalc_rate,\n\t.round_rate = ccu_div_var_round_rate,\n\t.set_rate = ccu_div_var_set_rate_fast,\n\t.debug_init = ccu_div_var_debug_init\n};\n\nstatic const struct clk_ops ccu_div_var_nogate_ops = {\n\t.recalc_rate = ccu_div_var_recalc_rate,\n\t.round_rate = ccu_div_var_round_rate,\n\t.set_rate = ccu_div_var_set_rate_slow,\n\t.debug_init = ccu_div_var_debug_init\n};\n\nstatic const struct clk_ops ccu_div_gate_ops = {\n\t.enable = ccu_div_gate_enable,\n\t.disable = ccu_div_gate_disable,\n\t.is_enabled = ccu_div_gate_is_enabled,\n\t.recalc_rate = ccu_div_fixed_recalc_rate,\n\t.round_rate = ccu_div_fixed_round_rate,\n\t.set_rate = ccu_div_fixed_set_rate,\n\t.debug_init = ccu_div_gate_debug_init\n};\n\nstatic const struct clk_ops ccu_div_buf_ops = {\n\t.enable = ccu_div_buf_enable,\n\t.disable = ccu_div_buf_disable,\n\t.is_enabled = ccu_div_buf_is_enabled,\n\t.debug_init = ccu_div_buf_debug_init\n};\n\nstatic const struct clk_ops ccu_div_fixed_ops = {\n\t.recalc_rate = ccu_div_fixed_recalc_rate,\n\t.round_rate = ccu_div_fixed_round_rate,\n\t.set_rate = ccu_div_fixed_set_rate,\n\t.debug_init = ccu_div_fixed_debug_init\n};\n\nstruct ccu_div *ccu_div_hw_register(const struct ccu_div_init_data *div_init)\n{\n\tstruct clk_parent_data parent_data = { };\n\tstruct clk_init_data hw_init = { };\n\tstruct ccu_div *div;\n\tint ret;\n\n\tif (!div_init)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tdiv->hw.init = &hw_init;\n\tdiv->id = div_init->id;\n\tdiv->reg_ctl = div_init->base + CCU_DIV_CTL;\n\tdiv->sys_regs = div_init->sys_regs;\n\tdiv->flags = div_init->flags;\n\tdiv->features = div_init->features;\n\tspin_lock_init(&div->lock);\n\n\thw_init.name = div_init->name;\n\thw_init.flags = div_init->flags;\n\n\tif (div_init->type == CCU_DIV_VAR) {\n\t\tif (hw_init.flags & CLK_SET_RATE_GATE)\n\t\t\thw_init.ops = &ccu_div_var_gate_to_set_ops;\n\t\telse\n\t\t\thw_init.ops = &ccu_div_var_nogate_ops;\n\t\tdiv->mask = CCU_DIV_CTL_CLKDIV_MASK(div_init->width);\n\t} else if (div_init->type == CCU_DIV_GATE) {\n\t\thw_init.ops = &ccu_div_gate_ops;\n\t\tdiv->divider = div_init->divider;\n\t} else if (div_init->type == CCU_DIV_BUF) {\n\t\thw_init.ops = &ccu_div_buf_ops;\n\t} else if (div_init->type == CCU_DIV_FIXED) {\n\t\thw_init.ops = &ccu_div_fixed_ops;\n\t\tdiv->divider = div_init->divider;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto err_free_div;\n\t}\n\n\tif (!div_init->parent_name) {\n\t\tret = -EINVAL;\n\t\tgoto err_free_div;\n\t}\n\tparent_data.fw_name = div_init->parent_name;\n\tparent_data.name = div_init->parent_name;\n\thw_init.parent_data = &parent_data;\n\thw_init.num_parents = 1;\n\n\tret = of_clk_hw_register(div_init->np, &div->hw);\n\tif (ret)\n\t\tgoto err_free_div;\n\n\treturn div;\n\nerr_free_div:\n\tkfree(div);\n\n\treturn ERR_PTR(ret);\n}\n\nvoid ccu_div_hw_unregister(struct ccu_div *div)\n{\n\tclk_hw_unregister(&div->hw);\n\n\tkfree(div);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}