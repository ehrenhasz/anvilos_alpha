{
  "module_name": "ccu-pll.c",
  "hash_id": "3fd11ba7d0adbbf7cd7a113d2112582139010bec39a64c945d40b5d91552f28a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/baikal-t1/ccu-pll.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"bt1-ccu-pll: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/printk.h>\n#include <linux/limits.h>\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/slab.h>\n#include <linux/clk-provider.h>\n#include <linux/of.h>\n#include <linux/spinlock.h>\n#include <linux/regmap.h>\n#include <linux/iopoll.h>\n#include <linux/time64.h>\n#include <linux/rational.h>\n#include <linux/debugfs.h>\n\n#include \"ccu-pll.h\"\n\n#define CCU_PLL_CTL\t\t\t0x000\n#define CCU_PLL_CTL_EN\t\t\tBIT(0)\n#define CCU_PLL_CTL_RST\t\t\tBIT(1)\n#define CCU_PLL_CTL_CLKR_FLD\t\t2\n#define CCU_PLL_CTL_CLKR_MASK\t\tGENMASK(7, CCU_PLL_CTL_CLKR_FLD)\n#define CCU_PLL_CTL_CLKF_FLD\t\t8\n#define CCU_PLL_CTL_CLKF_MASK\t\tGENMASK(20, CCU_PLL_CTL_CLKF_FLD)\n#define CCU_PLL_CTL_CLKOD_FLD\t\t21\n#define CCU_PLL_CTL_CLKOD_MASK\t\tGENMASK(24, CCU_PLL_CTL_CLKOD_FLD)\n#define CCU_PLL_CTL_BYPASS\t\tBIT(30)\n#define CCU_PLL_CTL_LOCK\t\tBIT(31)\n#define CCU_PLL_CTL1\t\t\t0x004\n#define CCU_PLL_CTL1_BWADJ_FLD\t\t3\n#define CCU_PLL_CTL1_BWADJ_MASK\t\tGENMASK(14, CCU_PLL_CTL1_BWADJ_FLD)\n\n#define CCU_PLL_LOCK_CHECK_RETRIES\t50\n\n#define CCU_PLL_NR_MAX \\\n\t((CCU_PLL_CTL_CLKR_MASK >> CCU_PLL_CTL_CLKR_FLD) + 1)\n#define CCU_PLL_NF_MAX \\\n\t((CCU_PLL_CTL_CLKF_MASK >> (CCU_PLL_CTL_CLKF_FLD + 1)) + 1)\n#define CCU_PLL_OD_MAX \\\n\t((CCU_PLL_CTL_CLKOD_MASK >> CCU_PLL_CTL_CLKOD_FLD) + 1)\n#define CCU_PLL_NB_MAX \\\n\t((CCU_PLL_CTL1_BWADJ_MASK >> CCU_PLL_CTL1_BWADJ_FLD) + 1)\n#define CCU_PLL_FDIV_MIN\t\t427000UL\n#define CCU_PLL_FDIV_MAX\t\t3500000000UL\n#define CCU_PLL_FOUT_MIN\t\t200000000UL\n#define CCU_PLL_FOUT_MAX\t\t2500000000UL\n#define CCU_PLL_FVCO_MIN\t\t700000000UL\n#define CCU_PLL_FVCO_MAX\t\t3500000000UL\n#define CCU_PLL_CLKOD_FACTOR\t\t2\n\nstatic inline unsigned long ccu_pll_lock_delay_us(unsigned long ref_clk,\n\t\t\t\t\t\t  unsigned long nr)\n{\n\tu64 us = 500ULL * nr * USEC_PER_SEC;\n\n\tdo_div(us, ref_clk);\n\n\treturn us;\n}\n\nstatic inline unsigned long ccu_pll_calc_freq(unsigned long ref_clk,\n\t\t\t\t\t      unsigned long nr,\n\t\t\t\t\t      unsigned long nf,\n\t\t\t\t\t      unsigned long od)\n{\n\tu64 tmp = ref_clk;\n\n\tdo_div(tmp, nr);\n\ttmp *= nf;\n\tdo_div(tmp, od);\n\n\treturn tmp;\n}\n\nstatic int ccu_pll_reset(struct ccu_pll *pll, unsigned long ref_clk,\n\t\t\t unsigned long nr)\n{\n\tunsigned long ud, ut;\n\tu32 val;\n\n\tud = ccu_pll_lock_delay_us(ref_clk, nr);\n\tut = ud * CCU_PLL_LOCK_CHECK_RETRIES;\n\n\tregmap_update_bits(pll->sys_regs, pll->reg_ctl,\n\t\t\t   CCU_PLL_CTL_RST, CCU_PLL_CTL_RST);\n\n\treturn regmap_read_poll_timeout_atomic(pll->sys_regs, pll->reg_ctl, val,\n\t\t\t\t\t       val & CCU_PLL_CTL_LOCK, ud, ut);\n}\n\nstatic int ccu_pll_enable(struct clk_hw *hw)\n{\n\tstruct clk_hw *parent_hw = clk_hw_get_parent(hw);\n\tstruct ccu_pll *pll = to_ccu_pll(hw);\n\tunsigned long flags;\n\tu32 val = 0;\n\tint ret;\n\n\tif (!parent_hw) {\n\t\tpr_err(\"Can't enable '%s' with no parent\", clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_read(pll->sys_regs, pll->reg_ctl, &val);\n\tif (val & CCU_PLL_CTL_EN)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&pll->lock, flags);\n\tregmap_write(pll->sys_regs, pll->reg_ctl, val | CCU_PLL_CTL_EN);\n\tret = ccu_pll_reset(pll, clk_hw_get_rate(parent_hw),\n\t\t\t    FIELD_GET(CCU_PLL_CTL_CLKR_MASK, val) + 1);\n\tspin_unlock_irqrestore(&pll->lock, flags);\n\tif (ret)\n\t\tpr_err(\"PLL '%s' reset timed out\\n\", clk_hw_get_name(hw));\n\n\treturn ret;\n}\n\nstatic void ccu_pll_disable(struct clk_hw *hw)\n{\n\tstruct ccu_pll *pll = to_ccu_pll(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pll->lock, flags);\n\tregmap_update_bits(pll->sys_regs, pll->reg_ctl, CCU_PLL_CTL_EN, 0);\n\tspin_unlock_irqrestore(&pll->lock, flags);\n}\n\nstatic int ccu_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct ccu_pll *pll = to_ccu_pll(hw);\n\tu32 val = 0;\n\n\tregmap_read(pll->sys_regs, pll->reg_ctl, &val);\n\n\treturn !!(val & CCU_PLL_CTL_EN);\n}\n\nstatic unsigned long ccu_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct ccu_pll *pll = to_ccu_pll(hw);\n\tunsigned long nr, nf, od;\n\tu32 val = 0;\n\n\tregmap_read(pll->sys_regs, pll->reg_ctl, &val);\n\tnr = FIELD_GET(CCU_PLL_CTL_CLKR_MASK, val) + 1;\n\tnf = FIELD_GET(CCU_PLL_CTL_CLKF_MASK, val) + 1;\n\tod = FIELD_GET(CCU_PLL_CTL_CLKOD_MASK, val) + 1;\n\n\treturn ccu_pll_calc_freq(parent_rate, nr, nf, od);\n}\n\nstatic void ccu_pll_calc_factors(unsigned long rate, unsigned long parent_rate,\n\t\t\t\t unsigned long *nr, unsigned long *nf,\n\t\t\t\t unsigned long *od)\n{\n\tunsigned long err, freq, min_err = ULONG_MAX;\n\tunsigned long num, denom, n1, d1, nri;\n\tunsigned long nr_max, nf_max, od_max;\n\n\t \n\tnri = (parent_rate / CCU_PLL_FDIV_MAX) + 1;\n\tnr_max = min(parent_rate / CCU_PLL_FDIV_MIN, CCU_PLL_NR_MAX);\n\n\t \n\tfor (; nri <= nr_max; ++nri) {\n\t\t \n\t\tnum = CCU_PLL_CLKOD_FACTOR * rate;\n\t\tdenom = parent_rate / nri;\n\n\t\t \n\t\tnf_max = min(CCU_PLL_FVCO_MAX / denom, CCU_PLL_NF_MAX);\n\t\tod_max = CCU_PLL_OD_MAX / CCU_PLL_CLKOD_FACTOR;\n\n\t\t \n\t\tif (num / denom >= nf_max) {\n\t\t\tn1 = nf_max;\n\t\t\td1 = 1;\n\t\t} else if (denom / num >= od_max) {\n\t\t\tn1 = 1;\n\t\t\td1 = od_max;\n\t\t} else {\n\t\t\trational_best_approximation(num, denom, nf_max, od_max,\n\t\t\t\t\t\t    &n1, &d1);\n\t\t}\n\n\t\t \n\t\tfreq = ccu_pll_calc_freq(parent_rate, nri, n1, d1);\n\t\terr = abs((int64_t)freq - num);\n\t\tif (err < min_err) {\n\t\t\tmin_err = err;\n\t\t\t*nr = nri;\n\t\t\t*nf = n1;\n\t\t\t*od = CCU_PLL_CLKOD_FACTOR * d1;\n\t\t}\n\t}\n}\n\nstatic long ccu_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\tunsigned long nr = 1, nf = 1, od = 1;\n\n\tccu_pll_calc_factors(rate, *parent_rate, &nr, &nf, &od);\n\n\treturn ccu_pll_calc_freq(*parent_rate, nr, nf, od);\n}\n\n \nstatic int ccu_pll_set_rate_reset(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct ccu_pll *pll = to_ccu_pll(hw);\n\tunsigned long nr, nf, od;\n\tunsigned long flags;\n\tu32 mask, val;\n\tint ret;\n\n\tccu_pll_calc_factors(rate, parent_rate, &nr, &nf, &od);\n\n\tmask = CCU_PLL_CTL_CLKR_MASK | CCU_PLL_CTL_CLKF_MASK |\n\t       CCU_PLL_CTL_CLKOD_MASK;\n\tval = FIELD_PREP(CCU_PLL_CTL_CLKR_MASK, nr - 1) |\n\t      FIELD_PREP(CCU_PLL_CTL_CLKF_MASK, nf - 1) |\n\t      FIELD_PREP(CCU_PLL_CTL_CLKOD_MASK, od - 1);\n\n\tspin_lock_irqsave(&pll->lock, flags);\n\tregmap_update_bits(pll->sys_regs, pll->reg_ctl, mask, val);\n\tret = ccu_pll_reset(pll, parent_rate, nr);\n\tspin_unlock_irqrestore(&pll->lock, flags);\n\tif (ret)\n\t\tpr_err(\"PLL '%s' reset timed out\\n\", clk_hw_get_name(hw));\n\n\treturn ret;\n}\n\n \nstatic int ccu_pll_set_rate_norst(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct ccu_pll *pll = to_ccu_pll(hw);\n\tunsigned long nr, nf, od;\n\tunsigned long flags;\n\tu32 mask, val;\n\n\tccu_pll_calc_factors(rate, parent_rate, &nr, &nf, &od);\n\n\t \n\tmask = CCU_PLL_CTL_CLKR_MASK | CCU_PLL_CTL_CLKF_MASK |\n\t       CCU_PLL_CTL_CLKOD_MASK | CCU_PLL_CTL_EN;\n\tval = FIELD_PREP(CCU_PLL_CTL_CLKR_MASK, nr - 1) |\n\t      FIELD_PREP(CCU_PLL_CTL_CLKF_MASK, nf - 1) |\n\t      FIELD_PREP(CCU_PLL_CTL_CLKOD_MASK, od - 1);\n\n\tspin_lock_irqsave(&pll->lock, flags);\n\tregmap_update_bits(pll->sys_regs, pll->reg_ctl, mask, val);\n\tspin_unlock_irqrestore(&pll->lock, flags);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\n\nstruct ccu_pll_dbgfs_bit {\n\tstruct ccu_pll *pll;\n\tconst char *name;\n\tunsigned int reg;\n\tu32 mask;\n};\n\nstruct ccu_pll_dbgfs_fld {\n\tstruct ccu_pll *pll;\n\tconst char *name;\n\tunsigned int reg;\n\tunsigned int lsb;\n\tu32 mask;\n\tu32 min;\n\tu32 max;\n};\n\n#define CCU_PLL_DBGFS_BIT_ATTR(_name, _reg, _mask)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\\\n\t\t.reg = _reg,\t\t\t\t\\\n\t\t.mask = _mask\t\t\t\t\\\n\t}\n\n#define CCU_PLL_DBGFS_FLD_ATTR(_name, _reg, _lsb, _mask, _min, _max)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.reg = _reg,\t\t\t\t\t\t\\\n\t\t.lsb = _lsb,\t\t\t\t\t\t\\\n\t\t.mask = _mask,\t\t\t\t\t\t\\\n\t\t.min = _min,\t\t\t\t\t\t\\\n\t\t.max = _max\t\t\t\t\t\t\\\n\t}\n\nstatic const struct ccu_pll_dbgfs_bit ccu_pll_bits[] = {\n\tCCU_PLL_DBGFS_BIT_ATTR(\"pll_en\", CCU_PLL_CTL, CCU_PLL_CTL_EN),\n\tCCU_PLL_DBGFS_BIT_ATTR(\"pll_rst\", CCU_PLL_CTL, CCU_PLL_CTL_RST),\n\tCCU_PLL_DBGFS_BIT_ATTR(\"pll_bypass\", CCU_PLL_CTL, CCU_PLL_CTL_BYPASS),\n\tCCU_PLL_DBGFS_BIT_ATTR(\"pll_lock\", CCU_PLL_CTL, CCU_PLL_CTL_LOCK)\n};\n\n#define CCU_PLL_DBGFS_BIT_NUM\tARRAY_SIZE(ccu_pll_bits)\n\nstatic const struct ccu_pll_dbgfs_fld ccu_pll_flds[] = {\n\tCCU_PLL_DBGFS_FLD_ATTR(\"pll_nr\", CCU_PLL_CTL, CCU_PLL_CTL_CLKR_FLD,\n\t\t\t\tCCU_PLL_CTL_CLKR_MASK, 1, CCU_PLL_NR_MAX),\n\tCCU_PLL_DBGFS_FLD_ATTR(\"pll_nf\", CCU_PLL_CTL, CCU_PLL_CTL_CLKF_FLD,\n\t\t\t\tCCU_PLL_CTL_CLKF_MASK, 1, CCU_PLL_NF_MAX),\n\tCCU_PLL_DBGFS_FLD_ATTR(\"pll_od\", CCU_PLL_CTL, CCU_PLL_CTL_CLKOD_FLD,\n\t\t\t\tCCU_PLL_CTL_CLKOD_MASK, 1, CCU_PLL_OD_MAX),\n\tCCU_PLL_DBGFS_FLD_ATTR(\"pll_nb\", CCU_PLL_CTL1, CCU_PLL_CTL1_BWADJ_FLD,\n\t\t\t\tCCU_PLL_CTL1_BWADJ_MASK, 1, CCU_PLL_NB_MAX)\n};\n\n#define CCU_PLL_DBGFS_FLD_NUM\tARRAY_SIZE(ccu_pll_flds)\n\n \n#undef CCU_PLL_ALLOW_WRITE_DEBUGFS\n#ifdef CCU_PLL_ALLOW_WRITE_DEBUGFS\n\nstatic int ccu_pll_dbgfs_bit_set(void *priv, u64 val)\n{\n\tconst struct ccu_pll_dbgfs_bit *bit = priv;\n\tstruct ccu_pll *pll = bit->pll;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pll->lock, flags);\n\tregmap_update_bits(pll->sys_regs, pll->reg_ctl + bit->reg,\n\t\t\t   bit->mask, val ? bit->mask : 0);\n\tspin_unlock_irqrestore(&pll->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ccu_pll_dbgfs_fld_set(void *priv, u64 val)\n{\n\tstruct ccu_pll_dbgfs_fld *fld = priv;\n\tstruct ccu_pll *pll = fld->pll;\n\tunsigned long flags;\n\tu32 data;\n\n\tval = clamp_t(u64, val, fld->min, fld->max);\n\tdata = ((val - 1) << fld->lsb) & fld->mask;\n\n\tspin_lock_irqsave(&pll->lock, flags);\n\tregmap_update_bits(pll->sys_regs, pll->reg_ctl + fld->reg, fld->mask,\n\t\t\t   data);\n\tspin_unlock_irqrestore(&pll->lock, flags);\n\n\treturn 0;\n}\n\n#define ccu_pll_dbgfs_mode\t0644\n\n#else  \n\n#define ccu_pll_dbgfs_bit_set\tNULL\n#define ccu_pll_dbgfs_fld_set\tNULL\n#define ccu_pll_dbgfs_mode\t0444\n\n#endif  \n\nstatic int ccu_pll_dbgfs_bit_get(void *priv, u64 *val)\n{\n\tstruct ccu_pll_dbgfs_bit *bit = priv;\n\tstruct ccu_pll *pll = bit->pll;\n\tu32 data = 0;\n\n\tregmap_read(pll->sys_regs, pll->reg_ctl + bit->reg, &data);\n\t*val = !!(data & bit->mask);\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(ccu_pll_dbgfs_bit_fops,\n\tccu_pll_dbgfs_bit_get, ccu_pll_dbgfs_bit_set, \"%llu\\n\");\n\nstatic int ccu_pll_dbgfs_fld_get(void *priv, u64 *val)\n{\n\tstruct ccu_pll_dbgfs_fld *fld = priv;\n\tstruct ccu_pll *pll = fld->pll;\n\tu32 data = 0;\n\n\tregmap_read(pll->sys_regs, pll->reg_ctl + fld->reg, &data);\n\t*val = ((data & fld->mask) >> fld->lsb) + 1;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(ccu_pll_dbgfs_fld_fops,\n\tccu_pll_dbgfs_fld_get, ccu_pll_dbgfs_fld_set, \"%llu\\n\");\n\nstatic void ccu_pll_debug_init(struct clk_hw *hw, struct dentry *dentry)\n{\n\tstruct ccu_pll *pll = to_ccu_pll(hw);\n\tstruct ccu_pll_dbgfs_bit *bits;\n\tstruct ccu_pll_dbgfs_fld *flds;\n\tint idx;\n\n\tbits = kcalloc(CCU_PLL_DBGFS_BIT_NUM, sizeof(*bits), GFP_KERNEL);\n\tif (!bits)\n\t\treturn;\n\n\tfor (idx = 0; idx < CCU_PLL_DBGFS_BIT_NUM; ++idx) {\n\t\tbits[idx] = ccu_pll_bits[idx];\n\t\tbits[idx].pll = pll;\n\n\t\tdebugfs_create_file_unsafe(bits[idx].name, ccu_pll_dbgfs_mode,\n\t\t\t\t\t   dentry, &bits[idx],\n\t\t\t\t\t   &ccu_pll_dbgfs_bit_fops);\n\t}\n\n\tflds = kcalloc(CCU_PLL_DBGFS_FLD_NUM, sizeof(*flds), GFP_KERNEL);\n\tif (!flds)\n\t\treturn;\n\n\tfor (idx = 0; idx < CCU_PLL_DBGFS_FLD_NUM; ++idx) {\n\t\tflds[idx] = ccu_pll_flds[idx];\n\t\tflds[idx].pll = pll;\n\n\t\tdebugfs_create_file_unsafe(flds[idx].name, ccu_pll_dbgfs_mode,\n\t\t\t\t\t   dentry, &flds[idx],\n\t\t\t\t\t   &ccu_pll_dbgfs_fld_fops);\n\t}\n}\n\n#else  \n\n#define ccu_pll_debug_init NULL\n\n#endif  \n\nstatic const struct clk_ops ccu_pll_gate_to_set_ops = {\n\t.enable = ccu_pll_enable,\n\t.disable = ccu_pll_disable,\n\t.is_enabled = ccu_pll_is_enabled,\n\t.recalc_rate = ccu_pll_recalc_rate,\n\t.round_rate = ccu_pll_round_rate,\n\t.set_rate = ccu_pll_set_rate_norst,\n\t.debug_init = ccu_pll_debug_init\n};\n\nstatic const struct clk_ops ccu_pll_straight_set_ops = {\n\t.enable = ccu_pll_enable,\n\t.disable = ccu_pll_disable,\n\t.is_enabled = ccu_pll_is_enabled,\n\t.recalc_rate = ccu_pll_recalc_rate,\n\t.round_rate = ccu_pll_round_rate,\n\t.set_rate = ccu_pll_set_rate_reset,\n\t.debug_init = ccu_pll_debug_init\n};\n\nstruct ccu_pll *ccu_pll_hw_register(const struct ccu_pll_init_data *pll_init)\n{\n\tstruct clk_parent_data parent_data = { };\n\tstruct clk_init_data hw_init = { };\n\tstruct ccu_pll *pll;\n\tint ret;\n\n\tif (!pll_init)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tpll->hw.init = &hw_init;\n\tpll->reg_ctl = pll_init->base + CCU_PLL_CTL;\n\tpll->reg_ctl1 = pll_init->base + CCU_PLL_CTL1;\n\tpll->sys_regs = pll_init->sys_regs;\n\tpll->id = pll_init->id;\n\tspin_lock_init(&pll->lock);\n\n\thw_init.name = pll_init->name;\n\thw_init.flags = pll_init->flags;\n\n\tif (hw_init.flags & CLK_SET_RATE_GATE)\n\t\thw_init.ops = &ccu_pll_gate_to_set_ops;\n\telse\n\t\thw_init.ops = &ccu_pll_straight_set_ops;\n\n\tif (!pll_init->parent_name) {\n\t\tret = -EINVAL;\n\t\tgoto err_free_pll;\n\t}\n\tparent_data.fw_name = pll_init->parent_name;\n\thw_init.parent_data = &parent_data;\n\thw_init.num_parents = 1;\n\n\tret = of_clk_hw_register(pll_init->np, &pll->hw);\n\tif (ret)\n\t\tgoto err_free_pll;\n\n\treturn pll;\n\nerr_free_pll:\n\tkfree(pll);\n\n\treturn ERR_PTR(ret);\n}\n\nvoid ccu_pll_hw_unregister(struct ccu_pll *pll)\n{\n\tclk_hw_unregister(&pll->hw);\n\n\tkfree(pll);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}