{
  "module_name": "ccu-rst.c",
  "hash_id": "f869fc0b745f018098adb2981d42ead1509e87df6ce8775f5653d011595cea2c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/baikal-t1/ccu-rst.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"bt1-ccu-rst: \" fmt\n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/printk.h>\n#include <linux/regmap.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/reset/bt1-ccu.h>\n\n#include \"ccu-rst.h\"\n\n#define CCU_AXI_MAIN_BASE\t\t0x030\n#define CCU_AXI_DDR_BASE\t\t0x034\n#define CCU_AXI_SATA_BASE\t\t0x038\n#define CCU_AXI_GMAC0_BASE\t\t0x03C\n#define CCU_AXI_GMAC1_BASE\t\t0x040\n#define CCU_AXI_XGMAC_BASE\t\t0x044\n#define CCU_AXI_PCIE_M_BASE\t\t0x048\n#define CCU_AXI_PCIE_S_BASE\t\t0x04C\n#define CCU_AXI_USB_BASE\t\t0x050\n#define CCU_AXI_HWA_BASE\t\t0x054\n#define CCU_AXI_SRAM_BASE\t\t0x058\n\n#define CCU_SYS_DDR_BASE\t\t0x02c\n#define CCU_SYS_SATA_REF_BASE\t\t0x060\n#define CCU_SYS_APB_BASE\t\t0x064\n#define CCU_SYS_PCIE_BASE\t\t0x144\n\n#define CCU_RST_DELAY_US\t\t1\n\n#define CCU_RST_TRIG(_base, _ofs)\t\t\\\n\t{\t\t\t\t\t\\\n\t\t.type = CCU_RST_TRIG,\t\t\\\n\t\t.base = _base,\t\t\t\\\n\t\t.mask = BIT(_ofs),\t\t\\\n\t}\n\n#define CCU_RST_DIR(_base, _ofs)\t\t\\\n\t{\t\t\t\t\t\\\n\t\t.type = CCU_RST_DIR,\t\t\\\n\t\t.base = _base,\t\t\t\\\n\t\t.mask = BIT(_ofs),\t\t\\\n\t}\n\nstruct ccu_rst_info {\n\tenum ccu_rst_type type;\n\tunsigned int base;\n\tunsigned int mask;\n};\n\n \nstatic const struct ccu_rst_info axi_rst_info[] = {\n\t[CCU_AXI_MAIN_RST] = CCU_RST_TRIG(CCU_AXI_MAIN_BASE, 1),\n\t[CCU_AXI_DDR_RST] = CCU_RST_TRIG(CCU_AXI_DDR_BASE, 1),\n\t[CCU_AXI_SATA_RST] = CCU_RST_TRIG(CCU_AXI_SATA_BASE, 1),\n\t[CCU_AXI_GMAC0_RST] = CCU_RST_TRIG(CCU_AXI_GMAC0_BASE, 1),\n\t[CCU_AXI_GMAC1_RST] = CCU_RST_TRIG(CCU_AXI_GMAC1_BASE, 1),\n\t[CCU_AXI_XGMAC_RST] = CCU_RST_TRIG(CCU_AXI_XGMAC_BASE, 1),\n\t[CCU_AXI_PCIE_M_RST] = CCU_RST_TRIG(CCU_AXI_PCIE_M_BASE, 1),\n\t[CCU_AXI_PCIE_S_RST] = CCU_RST_TRIG(CCU_AXI_PCIE_S_BASE, 1),\n\t[CCU_AXI_USB_RST] = CCU_RST_TRIG(CCU_AXI_USB_BASE, 1),\n\t[CCU_AXI_HWA_RST] = CCU_RST_TRIG(CCU_AXI_HWA_BASE, 1),\n\t[CCU_AXI_SRAM_RST] = CCU_RST_TRIG(CCU_AXI_SRAM_BASE, 1),\n};\n\n \nstatic const struct ccu_rst_info sys_rst_info[] = {\n\t[CCU_SYS_SATA_REF_RST] = CCU_RST_TRIG(CCU_SYS_SATA_REF_BASE, 1),\n\t[CCU_SYS_APB_RST] = CCU_RST_TRIG(CCU_SYS_APB_BASE, 1),\n\t[CCU_SYS_DDR_FULL_RST] = CCU_RST_DIR(CCU_SYS_DDR_BASE, 1),\n\t[CCU_SYS_DDR_INIT_RST] = CCU_RST_DIR(CCU_SYS_DDR_BASE, 2),\n\t[CCU_SYS_PCIE_PCS_PHY_RST] = CCU_RST_DIR(CCU_SYS_PCIE_BASE, 0),\n\t[CCU_SYS_PCIE_PIPE0_RST] = CCU_RST_DIR(CCU_SYS_PCIE_BASE, 4),\n\t[CCU_SYS_PCIE_CORE_RST] = CCU_RST_DIR(CCU_SYS_PCIE_BASE, 8),\n\t[CCU_SYS_PCIE_PWR_RST] = CCU_RST_DIR(CCU_SYS_PCIE_BASE, 9),\n\t[CCU_SYS_PCIE_STICKY_RST] = CCU_RST_DIR(CCU_SYS_PCIE_BASE, 10),\n\t[CCU_SYS_PCIE_NSTICKY_RST] = CCU_RST_DIR(CCU_SYS_PCIE_BASE, 11),\n\t[CCU_SYS_PCIE_HOT_RST] = CCU_RST_DIR(CCU_SYS_PCIE_BASE, 12),\n};\n\nstatic int ccu_rst_reset(struct reset_controller_dev *rcdev, unsigned long idx)\n{\n\tstruct ccu_rst *rst = to_ccu_rst(rcdev);\n\tconst struct ccu_rst_info *info = &rst->rsts_info[idx];\n\n\tif (info->type != CCU_RST_TRIG)\n\t\treturn -EOPNOTSUPP;\n\n\tregmap_update_bits(rst->sys_regs, info->base, info->mask, info->mask);\n\n\t \n\tudelay(CCU_RST_DELAY_US);\n\n\treturn 0;\n}\n\nstatic int ccu_rst_set(struct reset_controller_dev *rcdev,\n\t\t       unsigned long idx, bool high)\n{\n\tstruct ccu_rst *rst = to_ccu_rst(rcdev);\n\tconst struct ccu_rst_info *info = &rst->rsts_info[idx];\n\n\tif (info->type != CCU_RST_DIR)\n\t\treturn high ? -EOPNOTSUPP : 0;\n\n\treturn regmap_update_bits(rst->sys_regs, info->base,\n\t\t\t\t  info->mask, high ? info->mask : 0);\n}\n\nstatic int ccu_rst_assert(struct reset_controller_dev *rcdev,\n\t\t\t  unsigned long idx)\n{\n\treturn ccu_rst_set(rcdev, idx, true);\n}\n\nstatic int ccu_rst_deassert(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long idx)\n{\n\treturn ccu_rst_set(rcdev, idx, false);\n}\n\nstatic int ccu_rst_status(struct reset_controller_dev *rcdev,\n\t\t\t  unsigned long idx)\n{\n\tstruct ccu_rst *rst = to_ccu_rst(rcdev);\n\tconst struct ccu_rst_info *info = &rst->rsts_info[idx];\n\tu32 val;\n\n\tif (info->type != CCU_RST_DIR)\n\t\treturn -EOPNOTSUPP;\n\n\tregmap_read(rst->sys_regs, info->base, &val);\n\n\treturn !!(val & info->mask);\n}\n\nstatic const struct reset_control_ops ccu_rst_ops = {\n\t.reset = ccu_rst_reset,\n\t.assert = ccu_rst_assert,\n\t.deassert = ccu_rst_deassert,\n\t.status = ccu_rst_status,\n};\n\nstruct ccu_rst *ccu_rst_hw_register(const struct ccu_rst_init_data *rst_init)\n{\n\tstruct ccu_rst *rst;\n\tint ret;\n\n\tif (!rst_init)\n\t\treturn ERR_PTR(-EINVAL);\n\n\trst = kzalloc(sizeof(*rst), GFP_KERNEL);\n\tif (!rst)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trst->sys_regs = rst_init->sys_regs;\n\tif (of_device_is_compatible(rst_init->np, \"baikal,bt1-ccu-axi\")) {\n\t\trst->rcdev.nr_resets = ARRAY_SIZE(axi_rst_info);\n\t\trst->rsts_info = axi_rst_info;\n\t} else if (of_device_is_compatible(rst_init->np, \"baikal,bt1-ccu-sys\")) {\n\t\trst->rcdev.nr_resets = ARRAY_SIZE(sys_rst_info);\n\t\trst->rsts_info = sys_rst_info;\n\t} else {\n\t\tpr_err(\"Incompatible DT node '%s' specified\\n\",\n\t\t       of_node_full_name(rst_init->np));\n\t\tret = -EINVAL;\n\t\tgoto err_kfree_rst;\n\t}\n\n\trst->rcdev.owner = THIS_MODULE;\n\trst->rcdev.ops = &ccu_rst_ops;\n\trst->rcdev.of_node = rst_init->np;\n\n\tret = reset_controller_register(&rst->rcdev);\n\tif (ret) {\n\t\tpr_err(\"Couldn't register '%s' reset controller\\n\",\n\t\t       of_node_full_name(rst_init->np));\n\t\tgoto err_kfree_rst;\n\t}\n\n\treturn rst;\n\nerr_kfree_rst:\n\tkfree(rst);\n\n\treturn ERR_PTR(ret);\n}\n\nvoid ccu_rst_hw_unregister(struct ccu_rst *rst)\n{\n\treset_controller_unregister(&rst->rcdev);\n\n\tkfree(rst);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}