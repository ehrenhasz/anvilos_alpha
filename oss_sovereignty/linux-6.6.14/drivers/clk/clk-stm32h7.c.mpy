{
  "module_name": "clk-stm32h7.c",
  "hash_id": "9b19c010cdd03dbd6498a9aae9729f6ad78b14a52040b87da4e26ae50ab4f87c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-stm32h7.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/clock/stm32h7-clks.h>\n\n \n#define RCC_CR\t\t0x00\n#define RCC_CFGR\t0x10\n#define RCC_D1CFGR\t0x18\n#define RCC_D2CFGR\t0x1C\n#define RCC_D3CFGR\t0x20\n#define RCC_PLLCKSELR\t0x28\n#define RCC_PLLCFGR\t0x2C\n#define RCC_PLL1DIVR\t0x30\n#define RCC_PLL1FRACR\t0x34\n#define RCC_PLL2DIVR\t0x38\n#define RCC_PLL2FRACR\t0x3C\n#define RCC_PLL3DIVR\t0x40\n#define RCC_PLL3FRACR\t0x44\n#define RCC_D1CCIPR\t0x4C\n#define RCC_D2CCIP1R\t0x50\n#define RCC_D2CCIP2R\t0x54\n#define RCC_D3CCIPR\t0x58\n#define RCC_BDCR\t0x70\n#define RCC_CSR\t\t0x74\n#define RCC_AHB3ENR\t0xD4\n#define RCC_AHB1ENR\t0xD8\n#define RCC_AHB2ENR\t0xDC\n#define RCC_AHB4ENR\t0xE0\n#define RCC_APB3ENR\t0xE4\n#define RCC_APB1LENR\t0xE8\n#define RCC_APB1HENR\t0xEC\n#define RCC_APB2ENR\t0xF0\n#define RCC_APB4ENR\t0xF4\n\nstatic DEFINE_SPINLOCK(stm32rcc_lock);\n\nstatic void __iomem *base;\nstatic struct clk_hw **hws;\n\n \nstatic const char * const sys_src[] = {\n\t\"hsi_ck\", \"csi_ck\", \"hse_ck\", \"pll1_p\" };\n\nstatic const char * const tracein_src[] = {\n\t\"hsi_ck\", \"csi_ck\", \"hse_ck\", \"pll1_r\" };\n\nstatic const char * const per_src[] = {\n\t\"hsi_ker\", \"csi_ker\", \"hse_ck\", \"disabled\" };\n\nstatic const char * const pll_src[] = {\n\t\"hsi_ck\", \"csi_ck\", \"hse_ck\", \"no clock\" };\n\nstatic const char * const sdmmc_src[] = { \"pll1_q\", \"pll2_r\" };\n\nstatic const char * const dsi_src[] = { \"ck_dsi_phy\", \"pll2_q\" };\n\nstatic const char * const qspi_src[] = {\n\t\"hclk\", \"pll1_q\", \"pll2_r\", \"per_ck\" };\n\nstatic const char * const fmc_src[] = {\n\t\"hclk\", \"pll1_q\", \"pll2_r\", \"per_ck\" };\n\n \nstatic const char * const swp_src[] = {\t\"pclk1\", \"hsi_ker\" };\n\nstatic const char * const fdcan_src[] = { \"hse_ck\", \"pll1_q\", \"pll2_q\" };\n\nstatic const char * const dfsdm1_src[] = { \"pclk2\", \"sys_ck\" };\n\nstatic const char * const spdifrx_src[] = {\n\t\"pll1_q\", \"pll2_r\", \"pll3_r\", \"hsi_ker\" };\n\nstatic const char *spi_src1[5] = {\n\t\"pll1_q\", \"pll2_p\", \"pll3_p\", NULL, \"per_ck\" };\n\nstatic const char * const spi_src2[] = {\n\t\"pclk2\", \"pll2_q\", \"pll3_q\", \"hsi_ker\", \"csi_ker\", \"hse_ck\" };\n\nstatic const char * const spi_src3[] = {\n\t\"pclk4\", \"pll2_q\", \"pll3_q\", \"hsi_ker\", \"csi_ker\", \"hse_ck\" };\n\nstatic const char * const lptim_src1[] = {\n\t\"pclk1\", \"pll2_p\", \"pll3_r\", \"lse_ck\", \"lsi_ck\", \"per_ck\" };\n\nstatic const char * const lptim_src2[] = {\n\t\"pclk4\", \"pll2_p\", \"pll3_r\", \"lse_ck\", \"lsi_ck\", \"per_ck\" };\n\nstatic const char * const cec_src[] = {\"lse_ck\", \"lsi_ck\", \"csi_ker_div122\" };\n\nstatic const char * const usbotg_src[] = {\"pll1_q\", \"pll3_q\", \"rc48_ck\" };\n\n \nstatic const char * const i2c_src1[] = {\n\t\"pclk1\", \"pll3_r\", \"hsi_ker\", \"csi_ker\" };\n\nstatic const char * const i2c_src2[] = {\n\t\"pclk4\", \"pll3_r\", \"hsi_ker\", \"csi_ker\" };\n\nstatic const char * const rng_src[] = {\n\t\"rc48_ck\", \"pll1_q\", \"lse_ck\", \"lsi_ck\" };\n\n \nstatic const char * const usart_src1[] = {\n\t\"pclk2\", \"pll2_q\", \"pll3_q\", \"hsi_ker\", \"csi_ker\", \"lse_ck\" };\n\n \nstatic const char * const usart_src2[] = {\n\t\"pclk1\", \"pll2_q\", \"pll3_q\", \"hsi_ker\", \"csi_ker\", \"lse_ck\" };\n\nstatic const char *sai_src[5] = {\n\t\"pll1_q\", \"pll2_p\", \"pll3_p\", NULL, \"per_ck\" };\n\nstatic const char * const adc_src[] = { \"pll2_p\", \"pll3_r\", \"per_ck\" };\n\n \nstatic const char * const lpuart1_src[] = {\n\t\"pclk3\", \"pll2_q\", \"pll3_q\", \"csi_ker\", \"lse_ck\" };\n\nstatic const char * const hrtim_src[] = { \"tim2_ker\", \"d1cpre\" };\n\n \nstatic const char * const rtc_src[] = { \"off\", \"lse_ck\", \"lsi_ck\", \"hse_1M\" };\n\n \nstatic const char * const mco_src1[] = {\n\t\"hsi_ck\", \"lse_ck\", \"hse_ck\", \"pll1_q\",\t\"rc48_ck\" };\n\nstatic const char * const mco_src2[] = {\n\t\"sys_ck\", \"pll2_p\", \"hse_ck\", \"pll1_p\", \"csi_ck\", \"lsi_ck\" };\n\n \nstatic const char * const ltdc_src[] = {\"pll3_r\"};\n\n \nstruct stm32_ready_gate {\n\tstruct\tclk_gate gate;\n\tu8\tbit_rdy;\n};\n\n#define to_ready_gate_clk(_rgate) container_of(_rgate, struct stm32_ready_gate,\\\n\t\tgate)\n\n#define RGATE_TIMEOUT 10000\n\nstatic int ready_gate_clk_enable(struct clk_hw *hw)\n{\n\tstruct clk_gate *gate = to_clk_gate(hw);\n\tstruct stm32_ready_gate *rgate = to_ready_gate_clk(gate);\n\tint bit_status;\n\tunsigned int timeout = RGATE_TIMEOUT;\n\n\tif (clk_gate_ops.is_enabled(hw))\n\t\treturn 0;\n\n\tclk_gate_ops.enable(hw);\n\n\t \n\tdo {\n\t\tbit_status = !(readl(gate->reg) & BIT(rgate->bit_rdy));\n\n\t\tif (bit_status)\n\t\t\tudelay(100);\n\n\t} while (bit_status && --timeout);\n\n\treturn bit_status;\n}\n\nstatic void ready_gate_clk_disable(struct clk_hw *hw)\n{\n\tstruct clk_gate *gate = to_clk_gate(hw);\n\tstruct stm32_ready_gate *rgate = to_ready_gate_clk(gate);\n\tint bit_status;\n\tunsigned int timeout = RGATE_TIMEOUT;\n\n\tif (!clk_gate_ops.is_enabled(hw))\n\t\treturn;\n\n\tclk_gate_ops.disable(hw);\n\n\tdo {\n\t\tbit_status = !!(readl(gate->reg) & BIT(rgate->bit_rdy));\n\n\t\tif (bit_status)\n\t\t\tudelay(100);\n\n\t} while (bit_status && --timeout);\n}\n\nstatic const struct clk_ops ready_gate_clk_ops = {\n\t.enable\t\t= ready_gate_clk_enable,\n\t.disable\t= ready_gate_clk_disable,\n\t.is_enabled\t= clk_gate_is_enabled,\n};\n\nstatic struct clk_hw *clk_register_ready_gate(struct device *dev,\n\t\tconst char *name, const char *parent_name,\n\t\tvoid __iomem *reg, u8 bit_idx, u8 bit_rdy,\n\t\tunsigned long flags, spinlock_t *lock)\n{\n\tstruct stm32_ready_gate *rgate;\n\tstruct clk_init_data init = { NULL };\n\tstruct clk_hw *hw;\n\tint ret;\n\n\trgate = kzalloc(sizeof(*rgate), GFP_KERNEL);\n\tif (!rgate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &ready_gate_clk_ops;\n\tinit.flags = flags;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\trgate->bit_rdy = bit_rdy;\n\trgate->gate.lock = lock;\n\trgate->gate.reg = reg;\n\trgate->gate.bit_idx = bit_idx;\n\trgate->gate.hw.init = &init;\n\n\thw = &rgate->gate.hw;\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\tkfree(rgate);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstruct gate_cfg {\n\tu32 offset;\n\tu8  bit_idx;\n};\n\nstruct muxdiv_cfg {\n\tu32 offset;\n\tu8 shift;\n\tu8 width;\n};\n\nstruct composite_clk_cfg {\n\tstruct gate_cfg *gate;\n\tstruct muxdiv_cfg *mux;\n\tstruct muxdiv_cfg *div;\n\tconst char *name;\n\tconst char * const *parent_name;\n\tint num_parents;\n\tu32 flags;\n};\n\nstruct composite_clk_gcfg_t {\n\tu8 flags;\n\tconst struct clk_ops *ops;\n};\n\n \nstruct composite_clk_gcfg {\n\tstruct composite_clk_gcfg_t *mux;\n\tstruct composite_clk_gcfg_t *div;\n\tstruct composite_clk_gcfg_t *gate;\n};\n\n#define M_CFG_MUX(_mux_ops, _mux_flags)\\\n\t.mux = &(struct composite_clk_gcfg_t) { _mux_flags, _mux_ops}\n\n#define M_CFG_DIV(_rate_ops, _rate_flags)\\\n\t.div = &(struct composite_clk_gcfg_t) {_rate_flags, _rate_ops}\n\n#define M_CFG_GATE(_gate_ops, _gate_flags)\\\n\t.gate = &(struct composite_clk_gcfg_t) { _gate_flags, _gate_ops}\n\nstatic struct clk_mux *_get_cmux(void __iomem *reg, u8 shift, u8 width,\n\t\tu32 flags, spinlock_t *lock)\n{\n\tstruct clk_mux *mux;\n\n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmux->reg\t= reg;\n\tmux->shift\t= shift;\n\tmux->mask\t= (1 << width) - 1;\n\tmux->flags\t= flags;\n\tmux->lock\t= lock;\n\n\treturn mux;\n}\n\nstatic struct clk_divider *_get_cdiv(void __iomem *reg, u8 shift, u8 width,\n\t\tu32 flags, spinlock_t *lock)\n{\n\tstruct clk_divider *div;\n\n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdiv->reg   = reg;\n\tdiv->shift = shift;\n\tdiv->width = width;\n\tdiv->flags = flags;\n\tdiv->lock  = lock;\n\n\treturn div;\n}\n\nstatic struct clk_gate *_get_cgate(void __iomem *reg, u8 bit_idx, u32 flags,\n\t\tspinlock_t *lock)\n{\n\tstruct clk_gate *gate;\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgate->reg\t= reg;\n\tgate->bit_idx\t= bit_idx;\n\tgate->flags\t= flags;\n\tgate->lock\t= lock;\n\n\treturn gate;\n}\n\nstruct composite_cfg {\n\tstruct clk_hw *mux_hw;\n\tstruct clk_hw *div_hw;\n\tstruct clk_hw *gate_hw;\n\n\tconst struct clk_ops *mux_ops;\n\tconst struct clk_ops *div_ops;\n\tconst struct clk_ops *gate_ops;\n};\n\nstatic void get_cfg_composite_div(const struct composite_clk_gcfg *gcfg,\n\t\tconst struct composite_clk_cfg *cfg,\n\t\tstruct composite_cfg *composite, spinlock_t *lock)\n{\n\tstruct clk_mux     *mux = NULL;\n\tstruct clk_divider *div = NULL;\n\tstruct clk_gate    *gate = NULL;\n\tconst struct clk_ops *mux_ops, *div_ops, *gate_ops;\n\tstruct clk_hw *mux_hw;\n\tstruct clk_hw *div_hw;\n\tstruct clk_hw *gate_hw;\n\n\tmux_ops = div_ops = gate_ops = NULL;\n\tmux_hw = div_hw = gate_hw = NULL;\n\n\tif (gcfg->mux && cfg->mux) {\n\t\tmux = _get_cmux(base + cfg->mux->offset,\n\t\t\t\tcfg->mux->shift,\n\t\t\t\tcfg->mux->width,\n\t\t\t\tgcfg->mux->flags, lock);\n\n\t\tif (!IS_ERR(mux)) {\n\t\t\tmux_hw = &mux->hw;\n\t\t\tmux_ops = gcfg->mux->ops ?\n\t\t\t\t  gcfg->mux->ops : &clk_mux_ops;\n\t\t}\n\t}\n\n\tif (gcfg->div && cfg->div) {\n\t\tdiv = _get_cdiv(base + cfg->div->offset,\n\t\t\t\tcfg->div->shift,\n\t\t\t\tcfg->div->width,\n\t\t\t\tgcfg->div->flags, lock);\n\n\t\tif (!IS_ERR(div)) {\n\t\t\tdiv_hw = &div->hw;\n\t\t\tdiv_ops = gcfg->div->ops ?\n\t\t\t\t  gcfg->div->ops : &clk_divider_ops;\n\t\t}\n\t}\n\n\tif (gcfg->gate && cfg->gate) {\n\t\tgate = _get_cgate(base + cfg->gate->offset,\n\t\t\t\tcfg->gate->bit_idx,\n\t\t\t\tgcfg->gate->flags, lock);\n\n\t\tif (!IS_ERR(gate)) {\n\t\t\tgate_hw = &gate->hw;\n\t\t\tgate_ops = gcfg->gate->ops ?\n\t\t\t\t   gcfg->gate->ops : &clk_gate_ops;\n\t\t}\n\t}\n\n\tcomposite->mux_hw = mux_hw;\n\tcomposite->mux_ops = mux_ops;\n\n\tcomposite->div_hw = div_hw;\n\tcomposite->div_ops = div_ops;\n\n\tcomposite->gate_hw = gate_hw;\n\tcomposite->gate_ops = gate_ops;\n}\n\n \nstruct timer_ker {\n\tu8 dppre_shift;\n\tstruct clk_hw hw;\n\tspinlock_t *lock;\n};\n\n#define to_timer_ker(_hw) container_of(_hw, struct timer_ker, hw)\n\nstatic unsigned long timer_ker_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct timer_ker *clk_elem = to_timer_ker(hw);\n\tu32 timpre;\n\tu32 dppre_shift = clk_elem->dppre_shift;\n\tu32 prescaler;\n\tu32 mul;\n\n\ttimpre = (readl(base + RCC_CFGR) >> 15) & 0x01;\n\n\tprescaler = (readl(base + RCC_D2CFGR) >> dppre_shift) & 0x03;\n\n\tmul = 2;\n\n\tif (prescaler < 4)\n\t\tmul = 1;\n\n\telse if (timpre && prescaler > 4)\n\t\tmul = 4;\n\n\treturn parent_rate * mul;\n}\n\nstatic const struct clk_ops timer_ker_ops = {\n\t.recalc_rate = timer_ker_recalc_rate,\n};\n\nstatic struct clk_hw *clk_register_stm32_timer_ker(struct device *dev,\n\t\tconst char *name, const char *parent_name,\n\t\tunsigned long flags,\n\t\tu8 dppre_shift,\n\t\tspinlock_t *lock)\n{\n\tstruct timer_ker *element;\n\tstruct clk_init_data init;\n\tstruct clk_hw *hw;\n\tint err;\n\n\telement = kzalloc(sizeof(*element), GFP_KERNEL);\n\tif (!element)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &timer_ker_ops;\n\tinit.flags = flags;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\telement->hw.init = &init;\n\telement->lock = lock;\n\telement->dppre_shift = dppre_shift;\n\n\thw = &element->hw;\n\terr = clk_hw_register(dev, hw);\n\n\tif (err) {\n\t\tkfree(element);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn hw;\n}\n\nstatic const struct clk_div_table d1cpre_div_table[] = {\n\t{ 0, 1 }, { 1, 1 }, { 2, 1 }, { 3, 1},\n\t{ 4, 1 }, { 5, 1 }, { 6, 1 }, { 7, 1},\n\t{ 8, 2 }, { 9, 4 }, { 10, 8 }, { 11, 16 },\n\t{ 12, 64 }, { 13, 128 }, { 14, 256 },\n\t{ 15, 512 },\n\t{ 0 },\n};\n\nstatic const struct clk_div_table ppre_div_table[] = {\n\t{ 0, 1 }, { 1, 1 }, { 2, 1 }, { 3, 1},\n\t{ 4, 2 }, { 5, 4 }, { 6, 8 }, { 7, 16 },\n\t{ 0 },\n};\n\nstatic void register_core_and_bus_clocks(void)\n{\n\t \n\thws[SYS_D1CPRE] = clk_hw_register_divider_table(NULL, \"d1cpre\",\n\t\t\t\"sys_ck\", CLK_IGNORE_UNUSED, base + RCC_D1CFGR, 8, 4, 0,\n\t\t\td1cpre_div_table, &stm32rcc_lock);\n\n\thws[HCLK] = clk_hw_register_divider_table(NULL, \"hclk\", \"d1cpre\",\n\t\t\tCLK_IGNORE_UNUSED, base + RCC_D1CFGR, 0, 4, 0,\n\t\t\td1cpre_div_table, &stm32rcc_lock);\n\n\t \n\t \n\thws[CPU_SYSTICK] = clk_hw_register_fixed_factor(NULL, \"systick\",\n\t\t\t\"d1cpre\", 0, 1, 8);\n\n\t \n\thws[PCLK3] = clk_hw_register_divider_table(NULL, \"pclk3\", \"hclk\", 0,\n\t\t\tbase + RCC_D1CFGR, 4, 3, 0,\n\t\t\tppre_div_table, &stm32rcc_lock);\n\n\t \n\t \n\thws[PCLK1] = clk_hw_register_divider_table(NULL, \"pclk1\", \"hclk\", 0,\n\t\t\tbase + RCC_D2CFGR, 4, 3, 0,\n\t\t\tppre_div_table, &stm32rcc_lock);\n\n\t \n\tclk_register_stm32_timer_ker(NULL, \"tim1_ker\", \"pclk1\", 0,\n\t\t\t4, &stm32rcc_lock);\n\n\t \n\thws[PCLK2] = clk_hw_register_divider_table(NULL, \"pclk2\", \"hclk\", 0,\n\t\t\tbase + RCC_D2CFGR, 8, 3, 0, ppre_div_table,\n\t\t\t&stm32rcc_lock);\n\n\tclk_register_stm32_timer_ker(NULL, \"tim2_ker\", \"pclk2\", 0, 8,\n\t\t\t&stm32rcc_lock);\n\n\t \n\t \n\thws[PCLK4] = clk_hw_register_divider_table(NULL, \"pclk4\", \"hclk\", 0,\n\t\t\tbase + RCC_D3CFGR, 4, 3, 0,\n\t\t\tppre_div_table, &stm32rcc_lock);\n}\n\n \nstruct stm32_mux_clk {\n\tconst char *name;\n\tconst char * const *parents;\n\tu8 num_parents;\n\tu32 offset;\n\tu8 shift;\n\tu8 width;\n\tu32 flags;\n};\n\n#define M_MCLOCF(_name, _parents, _mux_offset, _mux_shift, _mux_width, _flags)\\\n{\\\n\t.name\t\t= _name,\\\n\t.parents\t= _parents,\\\n\t.num_parents\t= ARRAY_SIZE(_parents),\\\n\t.offset\t\t= _mux_offset,\\\n\t.shift\t\t= _mux_shift,\\\n\t.width\t\t= _mux_width,\\\n\t.flags\t\t= _flags,\\\n}\n\n#define M_MCLOC(_name, _parents, _mux_offset, _mux_shift, _mux_width)\\\n\tM_MCLOCF(_name, _parents, _mux_offset, _mux_shift, _mux_width, 0)\\\n\nstatic const struct stm32_mux_clk stm32_mclk[] __initconst = {\n\tM_MCLOC(\"per_ck\",\tper_src,\tRCC_D1CCIPR,\t28, 3),\n\tM_MCLOC(\"pllsrc\",\tpll_src,\tRCC_PLLCKSELR,\t 0, 3),\n\tM_MCLOC(\"sys_ck\",\tsys_src,\tRCC_CFGR,\t 0, 3),\n\tM_MCLOC(\"tracein_ck\",\ttracein_src,\tRCC_CFGR,\t 0, 3),\n};\n\n \nstruct stm32_osc_clk {\n\tconst char *name;\n\tconst char *parent;\n\tu32 gate_offset;\n\tu8 bit_idx;\n\tu8 bit_rdy;\n\tu32 flags;\n};\n\n#define OSC_CLKF(_name, _parent, _gate_offset, _bit_idx, _bit_rdy, _flags)\\\n{\\\n\t.name\t\t= _name,\\\n\t.parent\t\t= _parent,\\\n\t.gate_offset\t= _gate_offset,\\\n\t.bit_idx\t= _bit_idx,\\\n\t.bit_rdy\t= _bit_rdy,\\\n\t.flags\t\t= _flags,\\\n}\n\n#define OSC_CLK(_name, _parent, _gate_offset, _bit_idx, _bit_rdy)\\\n\tOSC_CLKF(_name, _parent, _gate_offset, _bit_idx, _bit_rdy, 0)\n\nstatic const struct stm32_osc_clk stm32_oclk[] __initconst = {\n\tOSC_CLKF(\"hsi_ck\",  \"hsidiv\",   RCC_CR,   0,  2, CLK_IGNORE_UNUSED),\n\tOSC_CLKF(\"hsi_ker\", \"hsidiv\",   RCC_CR,   1,  2, CLK_IGNORE_UNUSED),\n\tOSC_CLKF(\"csi_ck\",  \"clk-csi\",  RCC_CR,   7,  8, CLK_IGNORE_UNUSED),\n\tOSC_CLKF(\"csi_ker\", \"clk-csi\",  RCC_CR,   9,  8, CLK_IGNORE_UNUSED),\n\tOSC_CLKF(\"rc48_ck\", \"clk-rc48\", RCC_CR,  12, 13, CLK_IGNORE_UNUSED),\n\tOSC_CLKF(\"lsi_ck\",  \"clk-lsi\",  RCC_CSR,  0,  1, CLK_IGNORE_UNUSED),\n};\n\n \nstruct st32h7_pll_cfg {\n\tu8 bit_idx;\n\tu32 offset_divr;\n\tu8 bit_frac_en;\n\tu32 offset_frac;\n\tu8 divm;\n};\n\nstruct stm32_pll_data {\n\tconst char *name;\n\tconst char *parent_name;\n\tunsigned long flags;\n\tconst struct st32h7_pll_cfg *cfg;\n};\n\nstatic const struct st32h7_pll_cfg stm32h7_pll1 = {\n\t.bit_idx = 24,\n\t.offset_divr = RCC_PLL1DIVR,\n\t.bit_frac_en = 0,\n\t.offset_frac = RCC_PLL1FRACR,\n\t.divm = 4,\n};\n\nstatic const struct st32h7_pll_cfg stm32h7_pll2 = {\n\t.bit_idx = 26,\n\t.offset_divr = RCC_PLL2DIVR,\n\t.bit_frac_en = 4,\n\t.offset_frac = RCC_PLL2FRACR,\n\t.divm = 12,\n};\n\nstatic const struct st32h7_pll_cfg stm32h7_pll3 = {\n\t.bit_idx = 28,\n\t.offset_divr = RCC_PLL3DIVR,\n\t.bit_frac_en = 8,\n\t.offset_frac = RCC_PLL3FRACR,\n\t.divm = 20,\n};\n\nstatic const struct stm32_pll_data stm32_pll[] = {\n\t{ \"vco1\", \"pllsrc\", CLK_IGNORE_UNUSED, &stm32h7_pll1 },\n\t{ \"vco2\", \"pllsrc\", 0, &stm32h7_pll2 },\n\t{ \"vco3\", \"pllsrc\", 0, &stm32h7_pll3 },\n};\n\nstruct stm32_fractional_divider {\n\tvoid __iomem\t*mreg;\n\tu8\t\tmshift;\n\tu8\t\tmwidth;\n\n\tvoid __iomem\t*nreg;\n\tu8\t\tnshift;\n\tu8\t\tnwidth;\n\n\tvoid __iomem\t*freg_status;\n\tu8\t\tfreg_bit;\n\tvoid __iomem\t*freg_value;\n\tu8\t\tfshift;\n\tu8\t\tfwidth;\n\n\tu8\t\tflags;\n\tstruct clk_hw\thw;\n\tspinlock_t\t*lock;\n};\n\nstruct stm32_pll_obj {\n\tspinlock_t *lock;\n\tstruct stm32_fractional_divider div;\n\tstruct stm32_ready_gate rgate;\n\tstruct clk_hw hw;\n};\n\n#define to_pll(_hw) container_of(_hw, struct stm32_pll_obj, hw)\n\nstatic int pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct stm32_pll_obj *clk_elem = to_pll(hw);\n\tstruct clk_hw *_hw = &clk_elem->rgate.gate.hw;\n\n\t__clk_hw_set_clk(_hw, hw);\n\n\treturn ready_gate_clk_ops.is_enabled(_hw);\n}\n\nstatic int pll_enable(struct clk_hw *hw)\n{\n\tstruct stm32_pll_obj *clk_elem = to_pll(hw);\n\tstruct clk_hw *_hw = &clk_elem->rgate.gate.hw;\n\n\t__clk_hw_set_clk(_hw, hw);\n\n\treturn ready_gate_clk_ops.enable(_hw);\n}\n\nstatic void pll_disable(struct clk_hw *hw)\n{\n\tstruct stm32_pll_obj *clk_elem = to_pll(hw);\n\tstruct clk_hw *_hw = &clk_elem->rgate.gate.hw;\n\n\t__clk_hw_set_clk(_hw, hw);\n\n\tready_gate_clk_ops.disable(_hw);\n}\n\nstatic int pll_frac_is_enabled(struct clk_hw *hw)\n{\n\tstruct stm32_pll_obj *clk_elem = to_pll(hw);\n\tstruct stm32_fractional_divider *fd = &clk_elem->div;\n\n\treturn (readl(fd->freg_status) >> fd->freg_bit) & 0x01;\n}\n\nstatic unsigned long pll_read_frac(struct clk_hw *hw)\n{\n\tstruct stm32_pll_obj *clk_elem = to_pll(hw);\n\tstruct stm32_fractional_divider *fd = &clk_elem->div;\n\n\treturn (readl(fd->freg_value) >> fd->fshift) &\n\t\tGENMASK(fd->fwidth - 1, 0);\n}\n\nstatic unsigned long pll_fd_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct stm32_pll_obj *clk_elem = to_pll(hw);\n\tstruct stm32_fractional_divider *fd = &clk_elem->div;\n\tunsigned long m, n;\n\tu32 val, mask;\n\tu64 rate, rate1 = 0;\n\n\tval = readl(fd->mreg);\n\tmask = GENMASK(fd->mwidth - 1, 0) << fd->mshift;\n\tm = (val & mask) >> fd->mshift;\n\n\tval = readl(fd->nreg);\n\tmask = GENMASK(fd->nwidth - 1, 0) << fd->nshift;\n\tn = ((val & mask) >> fd->nshift) + 1;\n\n\tif (!n || !m)\n\t\treturn parent_rate;\n\n\trate = (u64)parent_rate * n;\n\tdo_div(rate, m);\n\n\tif (pll_frac_is_enabled(hw)) {\n\t\tval = pll_read_frac(hw);\n\t\trate1 = (u64)parent_rate * (u64)val;\n\t\tdo_div(rate1, (m * 8191));\n\t}\n\n\treturn rate + rate1;\n}\n\nstatic const struct clk_ops pll_ops = {\n\t.enable\t\t= pll_enable,\n\t.disable\t= pll_disable,\n\t.is_enabled\t= pll_is_enabled,\n\t.recalc_rate\t= pll_fd_recalc_rate,\n};\n\nstatic struct clk_hw *clk_register_stm32_pll(struct device *dev,\n\t\tconst char *name,\n\t\tconst char *parent,\n\t\tunsigned long flags,\n\t\tconst struct st32h7_pll_cfg *cfg,\n\t\tspinlock_t *lock)\n{\n\tstruct stm32_pll_obj *pll;\n\tstruct clk_init_data init = { NULL };\n\tstruct clk_hw *hw;\n\tint ret;\n\tstruct stm32_fractional_divider *div = NULL;\n\tstruct stm32_ready_gate *rgate;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &pll_ops;\n\tinit.flags = flags;\n\tinit.parent_names = &parent;\n\tinit.num_parents = 1;\n\tpll->hw.init = &init;\n\n\thw = &pll->hw;\n\trgate = &pll->rgate;\n\n\trgate->bit_rdy = cfg->bit_idx + 1;\n\trgate->gate.lock = lock;\n\trgate->gate.reg = base + RCC_CR;\n\trgate->gate.bit_idx = cfg->bit_idx;\n\n\tdiv = &pll->div;\n\tdiv->flags = 0;\n\tdiv->mreg = base + RCC_PLLCKSELR;\n\tdiv->mshift = cfg->divm;\n\tdiv->mwidth = 6;\n\tdiv->nreg = base +  cfg->offset_divr;\n\tdiv->nshift = 0;\n\tdiv->nwidth = 9;\n\n\tdiv->freg_status = base + RCC_PLLCFGR;\n\tdiv->freg_bit = cfg->bit_frac_en;\n\tdiv->freg_value = base +  cfg->offset_frac;\n\tdiv->fshift = 3;\n\tdiv->fwidth = 13;\n\n\tdiv->lock = lock;\n\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\tkfree(pll);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\n \nstatic unsigned long odf_divider_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\treturn clk_divider_ops.recalc_rate(hw, parent_rate);\n}\n\nstatic int odf_divider_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\treturn clk_divider_ops.determine_rate(hw, req);\n}\n\nstatic int odf_divider_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_hw *hwp;\n\tint pll_status;\n\tint ret;\n\n\thwp = clk_hw_get_parent(hw);\n\n\tpll_status = pll_is_enabled(hwp);\n\n\tif (pll_status)\n\t\tpll_disable(hwp);\n\n\tret = clk_divider_ops.set_rate(hw, rate, parent_rate);\n\n\tif (pll_status)\n\t\tpll_enable(hwp);\n\n\treturn ret;\n}\n\nstatic const struct clk_ops odf_divider_ops = {\n\t.recalc_rate\t= odf_divider_recalc_rate,\n\t.determine_rate\t= odf_divider_determine_rate,\n\t.set_rate\t= odf_divider_set_rate,\n};\n\nstatic int odf_gate_enable(struct clk_hw *hw)\n{\n\tstruct clk_hw *hwp;\n\tint pll_status;\n\tint ret;\n\n\tif (clk_gate_ops.is_enabled(hw))\n\t\treturn 0;\n\n\thwp = clk_hw_get_parent(hw);\n\n\tpll_status = pll_is_enabled(hwp);\n\n\tif (pll_status)\n\t\tpll_disable(hwp);\n\n\tret = clk_gate_ops.enable(hw);\n\n\tif (pll_status)\n\t\tpll_enable(hwp);\n\n\treturn ret;\n}\n\nstatic void odf_gate_disable(struct clk_hw *hw)\n{\n\tstruct clk_hw *hwp;\n\tint pll_status;\n\n\tif (!clk_gate_ops.is_enabled(hw))\n\t\treturn;\n\n\thwp = clk_hw_get_parent(hw);\n\n\tpll_status = pll_is_enabled(hwp);\n\n\tif (pll_status)\n\t\tpll_disable(hwp);\n\n\tclk_gate_ops.disable(hw);\n\n\tif (pll_status)\n\t\tpll_enable(hwp);\n}\n\nstatic const struct clk_ops odf_gate_ops = {\n\t.enable\t\t= odf_gate_enable,\n\t.disable\t= odf_gate_disable,\n\t.is_enabled\t= clk_gate_is_enabled,\n};\n\nstatic struct composite_clk_gcfg odf_clk_gcfg = {\n\tM_CFG_DIV(&odf_divider_ops, 0),\n\tM_CFG_GATE(&odf_gate_ops, 0),\n};\n\n#define M_ODF_F(_name, _parent, _gate_offset,  _bit_idx, _rate_offset,\\\n\t\t_rate_shift, _rate_width, _flags)\\\n{\\\n\t.mux = NULL,\\\n\t.div = &(struct muxdiv_cfg) {_rate_offset, _rate_shift, _rate_width},\\\n\t.gate = &(struct gate_cfg) {_gate_offset, _bit_idx },\\\n\t.name = _name,\\\n\t.parent_name = &(const char *) {_parent},\\\n\t.num_parents = 1,\\\n\t.flags = _flags,\\\n}\n\n#define M_ODF(_name, _parent, _gate_offset,  _bit_idx, _rate_offset,\\\n\t\t_rate_shift, _rate_width)\\\nM_ODF_F(_name, _parent, _gate_offset,  _bit_idx, _rate_offset,\\\n\t\t_rate_shift, _rate_width, 0)\\\n\nstatic const struct composite_clk_cfg stm32_odf[3][3] = {\n\t{\n\t\tM_ODF_F(\"pll1_p\", \"vco1\", RCC_PLLCFGR, 16, RCC_PLL1DIVR,  9, 7,\n\t\t\t\tCLK_IGNORE_UNUSED),\n\t\tM_ODF_F(\"pll1_q\", \"vco1\", RCC_PLLCFGR, 17, RCC_PLL1DIVR, 16, 7,\n\t\t\t\tCLK_IGNORE_UNUSED),\n\t\tM_ODF_F(\"pll1_r\", \"vco1\", RCC_PLLCFGR, 18, RCC_PLL1DIVR, 24, 7,\n\t\t\t\tCLK_IGNORE_UNUSED),\n\t},\n\n\t{\n\t\tM_ODF(\"pll2_p\", \"vco2\", RCC_PLLCFGR, 19, RCC_PLL2DIVR,  9, 7),\n\t\tM_ODF(\"pll2_q\", \"vco2\", RCC_PLLCFGR, 20, RCC_PLL2DIVR, 16, 7),\n\t\tM_ODF(\"pll2_r\", \"vco2\", RCC_PLLCFGR, 21, RCC_PLL2DIVR, 24, 7),\n\t},\n\t{\n\t\tM_ODF(\"pll3_p\", \"vco3\", RCC_PLLCFGR, 22, RCC_PLL3DIVR,  9, 7),\n\t\tM_ODF(\"pll3_q\", \"vco3\", RCC_PLLCFGR, 23, RCC_PLL3DIVR, 16, 7),\n\t\tM_ODF(\"pll3_r\", \"vco3\", RCC_PLLCFGR, 24, RCC_PLL3DIVR, 24, 7),\n\t}\n};\n\n \nstruct pclk_t {\n\tu32 gate_offset;\n\tu8 bit_idx;\n\tconst char *name;\n\tconst char *parent;\n\tu32 flags;\n};\n\n#define PER_CLKF(_gate_offset, _bit_idx, _name, _parent, _flags)\\\n{\\\n\t.gate_offset\t= _gate_offset,\\\n\t.bit_idx\t= _bit_idx,\\\n\t.name\t\t= _name,\\\n\t.parent\t\t= _parent,\\\n\t.flags\t\t= _flags,\\\n}\n\n#define PER_CLK(_gate_offset, _bit_idx, _name, _parent)\\\n\tPER_CLKF(_gate_offset, _bit_idx, _name, _parent, 0)\n\nstatic const struct pclk_t pclk[] = {\n\tPER_CLK(RCC_AHB3ENR, 31, \"d1sram1\", \"hclk\"),\n\tPER_CLK(RCC_AHB3ENR, 30, \"itcm\", \"hclk\"),\n\tPER_CLK(RCC_AHB3ENR, 29, \"dtcm2\", \"hclk\"),\n\tPER_CLK(RCC_AHB3ENR, 28, \"dtcm1\", \"hclk\"),\n\tPER_CLK(RCC_AHB3ENR, 8, \"flitf\", \"hclk\"),\n\tPER_CLK(RCC_AHB3ENR, 5, \"jpgdec\", \"hclk\"),\n\tPER_CLK(RCC_AHB3ENR, 4, \"dma2d\", \"hclk\"),\n\tPER_CLK(RCC_AHB3ENR, 0, \"mdma\", \"hclk\"),\n\tPER_CLK(RCC_AHB1ENR, 28, \"usb2ulpi\", \"hclk\"),\n\tPER_CLK(RCC_AHB1ENR, 26, \"usb1ulpi\", \"hclk\"),\n\tPER_CLK(RCC_AHB1ENR, 17, \"eth1rx\", \"hclk\"),\n\tPER_CLK(RCC_AHB1ENR, 16, \"eth1tx\", \"hclk\"),\n\tPER_CLK(RCC_AHB1ENR, 15, \"eth1mac\", \"hclk\"),\n\tPER_CLK(RCC_AHB1ENR, 14, \"art\", \"hclk\"),\n\tPER_CLK(RCC_AHB1ENR, 1, \"dma2\", \"hclk\"),\n\tPER_CLK(RCC_AHB1ENR, 0, \"dma1\", \"hclk\"),\n\tPER_CLK(RCC_AHB2ENR, 31, \"d2sram3\", \"hclk\"),\n\tPER_CLK(RCC_AHB2ENR, 30, \"d2sram2\", \"hclk\"),\n\tPER_CLK(RCC_AHB2ENR, 29, \"d2sram1\", \"hclk\"),\n\tPER_CLK(RCC_AHB2ENR, 5, \"hash\", \"hclk\"),\n\tPER_CLK(RCC_AHB2ENR, 4, \"crypt\", \"hclk\"),\n\tPER_CLK(RCC_AHB2ENR, 0, \"camitf\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 28, \"bkpram\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 25, \"hsem\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 21, \"bdma\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 19, \"crc\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 10, \"gpiok\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 9, \"gpioj\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 8, \"gpioi\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 7, \"gpioh\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 6, \"gpiog\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 5, \"gpiof\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 4, \"gpioe\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 3, \"gpiod\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 2, \"gpioc\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 1, \"gpiob\", \"hclk\"),\n\tPER_CLK(RCC_AHB4ENR, 0, \"gpioa\", \"hclk\"),\n\tPER_CLK(RCC_APB3ENR, 6, \"wwdg1\", \"pclk3\"),\n\tPER_CLK(RCC_APB1LENR, 29, \"dac12\", \"pclk1\"),\n\tPER_CLK(RCC_APB1LENR, 11, \"wwdg2\", \"pclk1\"),\n\tPER_CLK(RCC_APB1LENR, 8, \"tim14\", \"tim1_ker\"),\n\tPER_CLK(RCC_APB1LENR, 7, \"tim13\", \"tim1_ker\"),\n\tPER_CLK(RCC_APB1LENR, 6, \"tim12\", \"tim1_ker\"),\n\tPER_CLK(RCC_APB1LENR, 5, \"tim7\", \"tim1_ker\"),\n\tPER_CLK(RCC_APB1LENR, 4, \"tim6\", \"tim1_ker\"),\n\tPER_CLK(RCC_APB1LENR, 3, \"tim5\", \"tim1_ker\"),\n\tPER_CLK(RCC_APB1LENR, 2, \"tim4\", \"tim1_ker\"),\n\tPER_CLK(RCC_APB1LENR, 1, \"tim3\", \"tim1_ker\"),\n\tPER_CLK(RCC_APB1LENR, 0, \"tim2\", \"tim1_ker\"),\n\tPER_CLK(RCC_APB1HENR, 5, \"mdios\", \"pclk1\"),\n\tPER_CLK(RCC_APB1HENR, 4, \"opamp\", \"pclk1\"),\n\tPER_CLK(RCC_APB1HENR, 1, \"crs\", \"pclk1\"),\n\tPER_CLK(RCC_APB2ENR, 18, \"tim17\", \"tim2_ker\"),\n\tPER_CLK(RCC_APB2ENR, 17, \"tim16\", \"tim2_ker\"),\n\tPER_CLK(RCC_APB2ENR, 16, \"tim15\", \"tim2_ker\"),\n\tPER_CLK(RCC_APB2ENR, 1, \"tim8\", \"tim2_ker\"),\n\tPER_CLK(RCC_APB2ENR, 0, \"tim1\", \"tim2_ker\"),\n\tPER_CLK(RCC_APB4ENR, 26, \"tmpsens\", \"pclk4\"),\n\tPER_CLK(RCC_APB4ENR, 16, \"rtcapb\", \"pclk4\"),\n\tPER_CLK(RCC_APB4ENR, 15, \"vref\", \"pclk4\"),\n\tPER_CLK(RCC_APB4ENR, 14, \"comp12\", \"pclk4\"),\n\tPER_CLK(RCC_APB4ENR, 1, \"syscfg\", \"pclk4\"),\n};\n\n \n#define KER_CLKF(_gate_offset, _bit_idx,\\\n\t\t_mux_offset, _mux_shift, _mux_width,\\\n\t\t_name, _parent_name,\\\n\t\t_flags) \\\n{ \\\n\t.gate = &(struct gate_cfg) {_gate_offset, _bit_idx},\\\n\t.mux = &(struct muxdiv_cfg) {_mux_offset, _mux_shift, _mux_width },\\\n\t.name = _name, \\\n\t.parent_name = _parent_name, \\\n\t.num_parents = ARRAY_SIZE(_parent_name),\\\n\t.flags = _flags,\\\n}\n\n#define KER_CLK(_gate_offset, _bit_idx, _mux_offset, _mux_shift, _mux_width,\\\n\t\t_name, _parent_name) \\\nKER_CLKF(_gate_offset, _bit_idx, _mux_offset, _mux_shift, _mux_width,\\\n\t\t_name, _parent_name, 0)\\\n\n#define KER_CLKF_NOMUX(_gate_offset, _bit_idx,\\\n\t\t_name, _parent_name,\\\n\t\t_flags) \\\n{ \\\n\t.gate = &(struct gate_cfg) {_gate_offset, _bit_idx},\\\n\t.mux = NULL,\\\n\t.name = _name, \\\n\t.parent_name = _parent_name, \\\n\t.num_parents = 1,\\\n\t.flags = _flags,\\\n}\n\nstatic const struct composite_clk_cfg kclk[] = {\n\tKER_CLK(RCC_AHB3ENR,  16, RCC_D1CCIPR,\t16, 1, \"sdmmc1\", sdmmc_src),\n\tKER_CLKF(RCC_AHB3ENR, 14, RCC_D1CCIPR,\t 4, 2, \"quadspi\", qspi_src,\n\t\t\tCLK_IGNORE_UNUSED),\n\tKER_CLKF(RCC_AHB3ENR, 12, RCC_D1CCIPR,\t 0, 2, \"fmc\", fmc_src,\n\t\t\tCLK_IGNORE_UNUSED),\n\tKER_CLK(RCC_AHB1ENR,  27, RCC_D2CCIP2R,\t20, 2, \"usb2otg\", usbotg_src),\n\tKER_CLK(RCC_AHB1ENR,  25, RCC_D2CCIP2R, 20, 2, \"usb1otg\", usbotg_src),\n\tKER_CLK(RCC_AHB1ENR,   5, RCC_D3CCIPR,\t16, 2, \"adc12\", adc_src),\n\tKER_CLK(RCC_AHB2ENR,   9, RCC_D1CCIPR,\t16, 1, \"sdmmc2\", sdmmc_src),\n\tKER_CLK(RCC_AHB2ENR,   6, RCC_D2CCIP2R,\t 8, 2, \"rng\", rng_src),\n\tKER_CLK(RCC_AHB4ENR,  24, RCC_D3CCIPR,  16, 2, \"adc3\", adc_src),\n\tKER_CLKF(RCC_APB3ENR,   4, RCC_D1CCIPR,\t 8, 1, \"dsi\", dsi_src,\n\t\t\tCLK_SET_RATE_PARENT),\n\tKER_CLKF_NOMUX(RCC_APB3ENR, 3, \"ltdc\", ltdc_src, CLK_SET_RATE_PARENT),\n\tKER_CLK(RCC_APB1LENR, 31, RCC_D2CCIP2R,  0, 3, \"usart8\", usart_src2),\n\tKER_CLK(RCC_APB1LENR, 30, RCC_D2CCIP2R,  0, 3, \"usart7\", usart_src2),\n\tKER_CLK(RCC_APB1LENR, 27, RCC_D2CCIP2R, 22, 2, \"hdmicec\", cec_src),\n\tKER_CLK(RCC_APB1LENR, 23, RCC_D2CCIP2R, 12, 2, \"i2c3\", i2c_src1),\n\tKER_CLK(RCC_APB1LENR, 22, RCC_D2CCIP2R, 12, 2, \"i2c2\", i2c_src1),\n\tKER_CLK(RCC_APB1LENR, 21, RCC_D2CCIP2R, 12, 2, \"i2c1\", i2c_src1),\n\tKER_CLK(RCC_APB1LENR, 20, RCC_D2CCIP2R,\t 0, 3, \"uart5\", usart_src2),\n\tKER_CLK(RCC_APB1LENR, 19, RCC_D2CCIP2R,  0, 3, \"uart4\", usart_src2),\n\tKER_CLK(RCC_APB1LENR, 18, RCC_D2CCIP2R,  0, 3, \"usart3\", usart_src2),\n\tKER_CLK(RCC_APB1LENR, 17, RCC_D2CCIP2R,  0, 3, \"usart2\", usart_src2),\n\tKER_CLK(RCC_APB1LENR, 16, RCC_D2CCIP1R, 20, 2, \"spdifrx\", spdifrx_src),\n\tKER_CLK(RCC_APB1LENR, 15, RCC_D2CCIP1R, 16, 3, \"spi3\", spi_src1),\n\tKER_CLK(RCC_APB1LENR, 14, RCC_D2CCIP1R, 16, 3, \"spi2\", spi_src1),\n\tKER_CLK(RCC_APB1LENR,  9, RCC_D2CCIP2R, 28, 3, \"lptim1\", lptim_src1),\n\tKER_CLK(RCC_APB1HENR,  8, RCC_D2CCIP1R, 28, 2, \"fdcan\", fdcan_src),\n\tKER_CLK(RCC_APB1HENR,  2, RCC_D2CCIP1R, 31, 1, \"swp\", swp_src),\n\tKER_CLK(RCC_APB2ENR,  29, RCC_CFGR,\t14, 1, \"hrtim\", hrtim_src),\n\tKER_CLK(RCC_APB2ENR,  28, RCC_D2CCIP1R, 24, 1, \"dfsdm1\", dfsdm1_src),\n\tKER_CLKF(RCC_APB2ENR,  24, RCC_D2CCIP1R,  6, 3, \"sai3\", sai_src,\n\t\t CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT),\n\tKER_CLKF(RCC_APB2ENR,  23, RCC_D2CCIP1R,  6, 3, \"sai2\", sai_src,\n\t\t CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT),\n\tKER_CLKF(RCC_APB2ENR,  22, RCC_D2CCIP1R,  0, 3, \"sai1\", sai_src,\n\t\t CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT),\n\tKER_CLK(RCC_APB2ENR,  20, RCC_D2CCIP1R, 16, 3, \"spi5\", spi_src2),\n\tKER_CLK(RCC_APB2ENR,  13, RCC_D2CCIP1R, 16, 3, \"spi4\", spi_src2),\n\tKER_CLK(RCC_APB2ENR,  12, RCC_D2CCIP1R, 16, 3, \"spi1\", spi_src1),\n\tKER_CLK(RCC_APB2ENR,   5, RCC_D2CCIP2R,  3, 3, \"usart6\", usart_src1),\n\tKER_CLK(RCC_APB2ENR,   4, RCC_D2CCIP2R,  3, 3, \"usart1\", usart_src1),\n\tKER_CLK(RCC_APB4ENR,  21, RCC_D3CCIPR,\t24, 3, \"sai4b\", sai_src),\n\tKER_CLK(RCC_APB4ENR,  21, RCC_D3CCIPR,\t21, 3, \"sai4a\", sai_src),\n\tKER_CLK(RCC_APB4ENR,  12, RCC_D3CCIPR,\t13, 3, \"lptim5\", lptim_src2),\n\tKER_CLK(RCC_APB4ENR,  11, RCC_D3CCIPR,\t13, 3, \"lptim4\", lptim_src2),\n\tKER_CLK(RCC_APB4ENR,  10, RCC_D3CCIPR,\t13, 3, \"lptim3\", lptim_src2),\n\tKER_CLK(RCC_APB4ENR,   9, RCC_D3CCIPR,\t10, 3, \"lptim2\", lptim_src2),\n\tKER_CLK(RCC_APB4ENR,   7, RCC_D3CCIPR,\t 8, 2, \"i2c4\", i2c_src2),\n\tKER_CLK(RCC_APB4ENR,   5, RCC_D3CCIPR,\t28, 3, \"spi6\", spi_src3),\n\tKER_CLK(RCC_APB4ENR,   3, RCC_D3CCIPR,\t 0, 3, \"lpuart1\", lpuart1_src),\n};\n\nstatic struct composite_clk_gcfg kernel_clk_cfg = {\n\tM_CFG_MUX(NULL, 0),\n\tM_CFG_GATE(NULL, 0),\n};\n\n \n \n \n#define PWR_CR\t\t\t\t0x00\n \n#define PWR_CR_DBP\t\t\tBIT(8)\n\nstatic struct composite_clk_gcfg rtc_clk_cfg = {\n\tM_CFG_MUX(NULL, 0),\n\tM_CFG_GATE(NULL, 0),\n};\n\nstatic const struct composite_clk_cfg rtc_clk =\n\tKER_CLK(RCC_BDCR, 15, RCC_BDCR, 8, 2, \"rtc_ck\", rtc_src);\n\n \nstatic struct composite_clk_gcfg mco_clk_cfg = {\n\tM_CFG_MUX(NULL, 0),\n\tM_CFG_DIV(NULL,\tCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO),\n};\n\n#define M_MCO_F(_name, _parents, _mux_offset,  _mux_shift, _mux_width,\\\n\t\t_rate_offset, _rate_shift, _rate_width,\\\n\t\t_flags)\\\n{\\\n\t.mux = &(struct muxdiv_cfg) {_mux_offset, _mux_shift, _mux_width },\\\n\t.div = &(struct muxdiv_cfg) {_rate_offset, _rate_shift, _rate_width},\\\n\t.gate = NULL,\\\n\t.name = _name,\\\n\t.parent_name = _parents,\\\n\t.num_parents = ARRAY_SIZE(_parents),\\\n\t.flags = _flags,\\\n}\n\nstatic const struct composite_clk_cfg mco_clk[] = {\n\tM_MCO_F(\"mco1\", mco_src1, RCC_CFGR, 22, 4, RCC_CFGR, 18, 4, 0),\n\tM_MCO_F(\"mco2\", mco_src2, RCC_CFGR, 29, 3, RCC_CFGR, 25, 4, 0),\n};\n\nstatic void __init stm32h7_rcc_init(struct device_node *np)\n{\n\tstruct clk_hw_onecell_data *clk_data;\n\tstruct composite_cfg c_cfg;\n\tint n;\n\tconst char *hse_clk, *lse_clk, *i2s_clk;\n\tstruct regmap *pdrm;\n\n\tclk_data = kzalloc(struct_size(clk_data, hws, STM32H7_MAX_CLKS),\n\t\t\t   GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn;\n\n\tclk_data->num = STM32H7_MAX_CLKS;\n\n\thws = clk_data->hws;\n\n\tfor (n = 0; n < STM32H7_MAX_CLKS; n++)\n\t\thws[n] = ERR_PTR(-ENOENT);\n\n\t \n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tpr_err(\"%pOFn: unable to map resource\", np);\n\t\tgoto err_free_clks;\n\t}\n\n\tpdrm = syscon_regmap_lookup_by_phandle(np, \"st,syscfg\");\n\tif (IS_ERR(pdrm))\n\t\tpr_warn(\"%s: Unable to get syscfg\\n\", __func__);\n\telse\n\t\t \n\t\tregmap_update_bits(pdrm, PWR_CR, PWR_CR_DBP, PWR_CR_DBP);\n\n\t \n\thse_clk = of_clk_get_parent_name(np, 0);\n\tlse_clk = of_clk_get_parent_name(np, 1);\n\ti2s_clk = of_clk_get_parent_name(np, 2);\n\n\tsai_src[3] = i2s_clk;\n\tspi_src1[3] = i2s_clk;\n\n\t \n\tclk_hw_register_fixed_rate(NULL, \"clk-hsi\", NULL, 0, 64000000);\n\tclk_hw_register_fixed_rate(NULL, \"clk-csi\", NULL, 0, 4000000);\n\tclk_hw_register_fixed_rate(NULL, \"clk-lsi\", NULL, 0, 32000);\n\tclk_hw_register_fixed_rate(NULL, \"clk-rc48\", NULL, 0, 48000);\n\n\t \n\thws[CK_DSI_PHY] = clk_hw_register_fixed_rate(NULL, \"ck_dsi_phy\", NULL,\n\t\t\t0, 0);\n\n\thws[HSI_DIV] = clk_hw_register_divider(NULL, \"hsidiv\", \"clk-hsi\", 0,\n\t\t\tbase + RCC_CR, 3, 2, CLK_DIVIDER_POWER_OF_TWO,\n\t\t\t&stm32rcc_lock);\n\n\thws[HSE_1M] = clk_hw_register_divider(NULL, \"hse_1M\", \"hse_ck\",\t0,\n\t\t\tbase + RCC_CFGR, 8, 6, CLK_DIVIDER_ONE_BASED |\n\t\t\tCLK_DIVIDER_ALLOW_ZERO,\n\t\t\t&stm32rcc_lock);\n\n\t \n\tfor (n = 0; n < ARRAY_SIZE(stm32_mclk); n++)\n\t\thws[MCLK_BANK + n] = clk_hw_register_mux(NULL,\n\t\t\t\tstm32_mclk[n].name,\n\t\t\t\tstm32_mclk[n].parents,\n\t\t\t\tstm32_mclk[n].num_parents,\n\t\t\t\tstm32_mclk[n].flags,\n\t\t\t\tstm32_mclk[n].offset + base,\n\t\t\t\tstm32_mclk[n].shift,\n\t\t\t\tstm32_mclk[n].width,\n\t\t\t\t0,\n\t\t\t\t&stm32rcc_lock);\n\n\tregister_core_and_bus_clocks();\n\n\t \n\tfor (n = 0; n < ARRAY_SIZE(stm32_oclk); n++)\n\t\thws[OSC_BANK + n] = clk_register_ready_gate(NULL,\n\t\t\t\tstm32_oclk[n].name,\n\t\t\t\tstm32_oclk[n].parent,\n\t\t\t\tstm32_oclk[n].gate_offset + base,\n\t\t\t\tstm32_oclk[n].bit_idx,\n\t\t\t\tstm32_oclk[n].bit_rdy,\n\t\t\t\tstm32_oclk[n].flags,\n\t\t\t\t&stm32rcc_lock);\n\n\thws[HSE_CK] = clk_register_ready_gate(NULL,\n\t\t\t\t\"hse_ck\",\n\t\t\t\thse_clk,\n\t\t\t\tRCC_CR + base,\n\t\t\t\t16, 17,\n\t\t\t\t0,\n\t\t\t\t&stm32rcc_lock);\n\n\thws[LSE_CK] = clk_register_ready_gate(NULL,\n\t\t\t\t\"lse_ck\",\n\t\t\t\tlse_clk,\n\t\t\t\tRCC_BDCR + base,\n\t\t\t\t0, 1,\n\t\t\t\t0,\n\t\t\t\t&stm32rcc_lock);\n\n\thws[CSI_KER_DIV122 + n] = clk_hw_register_fixed_factor(NULL,\n\t\t\t\"csi_ker_div122\", \"csi_ker\", 0, 1, 122);\n\n\t \n\tfor (n = 0; n < ARRAY_SIZE(stm32_pll); n++) {\n\t\tint odf;\n\n\t\t \n\t\tclk_register_stm32_pll(NULL, stm32_pll[n].name,\n\t\t\t\tstm32_pll[n].parent_name, stm32_pll[n].flags,\n\t\t\t\tstm32_pll[n].cfg,\n\t\t\t\t&stm32rcc_lock);\n\n\t\t \n\t\tfor (odf = 0; odf < 3; odf++) {\n\t\t\tint idx = n * 3 + odf;\n\n\t\t\tget_cfg_composite_div(&odf_clk_gcfg, &stm32_odf[n][odf],\n\t\t\t\t\t&c_cfg,\t&stm32rcc_lock);\n\n\t\t\thws[ODF_BANK + idx] = clk_hw_register_composite(NULL,\n\t\t\t\t\tstm32_odf[n][odf].name,\n\t\t\t\t\tstm32_odf[n][odf].parent_name,\n\t\t\t\t\tstm32_odf[n][odf].num_parents,\n\t\t\t\t\tc_cfg.mux_hw, c_cfg.mux_ops,\n\t\t\t\t\tc_cfg.div_hw, c_cfg.div_ops,\n\t\t\t\t\tc_cfg.gate_hw, c_cfg.gate_ops,\n\t\t\t\t\tstm32_odf[n][odf].flags);\n\t\t}\n\t}\n\n\t \n\tfor (n = 0; n < ARRAY_SIZE(pclk); n++)\n\t\thws[PERIF_BANK + n] = clk_hw_register_gate(NULL, pclk[n].name,\n\t\t\t\tpclk[n].parent,\n\t\t\t\tpclk[n].flags, base + pclk[n].gate_offset,\n\t\t\t\tpclk[n].bit_idx, pclk[n].flags, &stm32rcc_lock);\n\n\t \n\tfor (n = 0; n < ARRAY_SIZE(kclk); n++) {\n\t\tget_cfg_composite_div(&kernel_clk_cfg, &kclk[n], &c_cfg,\n\t\t\t\t&stm32rcc_lock);\n\n\t\thws[KERN_BANK + n] = clk_hw_register_composite(NULL,\n\t\t\t\tkclk[n].name,\n\t\t\t\tkclk[n].parent_name,\n\t\t\t\tkclk[n].num_parents,\n\t\t\t\tc_cfg.mux_hw, c_cfg.mux_ops,\n\t\t\t\tc_cfg.div_hw, c_cfg.div_ops,\n\t\t\t\tc_cfg.gate_hw, c_cfg.gate_ops,\n\t\t\t\tkclk[n].flags);\n\t}\n\n\t \n\tclk_hw_register_fixed_rate(NULL, \"off\", NULL, 0, 0);\n\n\tget_cfg_composite_div(&rtc_clk_cfg, &rtc_clk, &c_cfg, &stm32rcc_lock);\n\n\thws[RTC_CK] = clk_hw_register_composite(NULL,\n\t\t\trtc_clk.name,\n\t\t\trtc_clk.parent_name,\n\t\t\trtc_clk.num_parents,\n\t\t\tc_cfg.mux_hw, c_cfg.mux_ops,\n\t\t\tc_cfg.div_hw, c_cfg.div_ops,\n\t\t\tc_cfg.gate_hw, c_cfg.gate_ops,\n\t\t\trtc_clk.flags);\n\n\t \n\tfor (n = 0; n < ARRAY_SIZE(mco_clk); n++) {\n\t\tget_cfg_composite_div(&mco_clk_cfg, &mco_clk[n], &c_cfg,\n\t\t\t\t&stm32rcc_lock);\n\n\t\thws[MCO_BANK + n] = clk_hw_register_composite(NULL,\n\t\t\t\tmco_clk[n].name,\n\t\t\t\tmco_clk[n].parent_name,\n\t\t\t\tmco_clk[n].num_parents,\n\t\t\t\tc_cfg.mux_hw, c_cfg.mux_ops,\n\t\t\t\tc_cfg.div_hw, c_cfg.div_ops,\n\t\t\t\tc_cfg.gate_hw, c_cfg.gate_ops,\n\t\t\t\tmco_clk[n].flags);\n\t}\n\n\tof_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_data);\n\n\treturn;\n\nerr_free_clks:\n\tkfree(clk_data);\n}\n\n \nCLK_OF_DECLARE_DRIVER(stm32h7_rcc, \"st,stm32h743-rcc\", stm32h7_rcc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}