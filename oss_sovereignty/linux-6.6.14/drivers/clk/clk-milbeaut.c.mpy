{
  "module_name": "clk-milbeaut.c",
  "hash_id": "d5fa8ccbf4c1a80c45de9f50e5606d514dfab29147e9c5df9d8b4e1cb0844615",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-milbeaut.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#define M10V_CLKSEL1\t\t0x0\n#define CLKSEL(n)\t(((n) - 1) * 4 + M10V_CLKSEL1)\n\n#define M10V_PLL1\t\t\"pll1\"\n#define M10V_PLL1DIV2\t\t\"pll1-2\"\n#define M10V_PLL2\t\t\"pll2\"\n#define M10V_PLL2DIV2\t\t\"pll2-2\"\n#define M10V_PLL6\t\t\"pll6\"\n#define M10V_PLL6DIV2\t\t\"pll6-2\"\n#define M10V_PLL6DIV3\t\t\"pll6-3\"\n#define M10V_PLL7\t\t\"pll7\"\n#define M10V_PLL7DIV2\t\t\"pll7-2\"\n#define M10V_PLL7DIV5\t\t\"pll7-5\"\n#define M10V_PLL9\t\t\"pll9\"\n#define M10V_PLL10\t\t\"pll10\"\n#define M10V_PLL10DIV2\t\t\"pll10-2\"\n#define M10V_PLL11\t\t\"pll11\"\n\n#define M10V_SPI_PARENT0\t\"spi-parent0\"\n#define M10V_SPI_PARENT1\t\"spi-parent1\"\n#define M10V_SPI_PARENT2\t\"spi-parent2\"\n#define M10V_UHS1CLK2_PARENT0\t\"uhs1clk2-parent0\"\n#define M10V_UHS1CLK2_PARENT1\t\"uhs1clk2-parent1\"\n#define M10V_UHS1CLK2_PARENT2\t\"uhs1clk2-parent2\"\n#define M10V_UHS1CLK1_PARENT0\t\"uhs1clk1-parent0\"\n#define M10V_UHS1CLK1_PARENT1\t\"uhs1clk1-parent1\"\n#define M10V_NFCLK_PARENT0\t\"nfclk-parent0\"\n#define M10V_NFCLK_PARENT1\t\"nfclk-parent1\"\n#define M10V_NFCLK_PARENT2\t\"nfclk-parent2\"\n#define M10V_NFCLK_PARENT3\t\"nfclk-parent3\"\n#define M10V_NFCLK_PARENT4\t\"nfclk-parent4\"\n#define M10V_NFCLK_PARENT5\t\"nfclk-parent5\"\n\n#define M10V_DCHREQ\t\t1\n#define M10V_UPOLL_RATE\t\t1\n#define M10V_UTIMEOUT\t\t250\n\n#define M10V_EMMCCLK_ID\t\t0\n#define M10V_ACLK_ID\t\t1\n#define M10V_HCLK_ID\t\t2\n#define M10V_PCLK_ID\t\t3\n#define M10V_RCLK_ID\t\t4\n#define M10V_SPICLK_ID\t\t5\n#define M10V_NFCLK_ID\t\t6\n#define M10V_UHS1CLK2_ID\t7\n#define M10V_NUM_CLKS\t\t8\n\n#define to_m10v_div(_hw)        container_of(_hw, struct m10v_clk_divider, hw)\n\nstatic struct clk_hw_onecell_data *m10v_clk_data;\n\nstatic DEFINE_SPINLOCK(m10v_crglock);\n\nstruct m10v_clk_div_factors {\n\tconst char\t\t\t*name;\n\tconst char\t\t\t*parent_name;\n\tu32\t\t\t\toffset;\n\tu8\t\t\t\tshift;\n\tu8\t\t\t\twidth;\n\tconst struct clk_div_table\t*table;\n\tunsigned long\t\t\tdiv_flags;\n\tint\t\t\t\tonecell_idx;\n};\n\nstruct m10v_clk_div_fixed_data {\n\tconst char\t*name;\n\tconst char\t*parent_name;\n\tu8\t\tdiv;\n\tu8\t\tmult;\n\tint\t\tonecell_idx;\n};\n\nstruct m10v_clk_mux_factors {\n\tconst char\t\t*name;\n\tconst char * const\t*parent_names;\n\tu8\t\t\tnum_parents;\n\tu32\t\t\toffset;\n\tu8\t\t\tshift;\n\tu8\t\t\tmask;\n\tu32\t\t\t*table;\n\tunsigned long\t\tmux_flags;\n\tint\t\t\tonecell_idx;\n};\n\nstatic const struct clk_div_table emmcclk_table[] = {\n\t{ .val = 0, .div = 8 },\n\t{ .val = 1, .div = 9 },\n\t{ .val = 2, .div = 10 },\n\t{ .val = 3, .div = 15 },\n\t{ .div = 0 },\n};\n\nstatic const struct clk_div_table mclk400_table[] = {\n\t{ .val = 1, .div = 2 },\n\t{ .val = 3, .div = 4 },\n\t{ .div = 0 },\n};\n\nstatic const struct clk_div_table mclk200_table[] = {\n\t{ .val = 3, .div = 4 },\n\t{ .val = 7, .div = 8 },\n\t{ .div = 0 },\n};\n\nstatic const struct clk_div_table aclk400_table[] = {\n\t{ .val = 1, .div = 2 },\n\t{ .val = 3, .div = 4 },\n\t{ .div = 0 },\n};\n\nstatic const struct clk_div_table aclk300_table[] = {\n\t{ .val = 0, .div = 2 },\n\t{ .val = 1, .div = 3 },\n\t{ .div = 0 },\n};\n\nstatic const struct clk_div_table aclk_table[] = {\n\t{ .val = 3, .div = 4 },\n\t{ .val = 7, .div = 8 },\n\t{ .div = 0 },\n};\n\nstatic const struct clk_div_table aclkexs_table[] = {\n\t{ .val = 3, .div = 4 },\n\t{ .val = 4, .div = 5 },\n\t{ .val = 5, .div = 6 },\n\t{ .val = 7, .div = 8 },\n\t{ .div = 0 },\n};\n\nstatic const struct clk_div_table hclk_table[] = {\n\t{ .val = 7, .div = 8 },\n\t{ .val = 15, .div = 16 },\n\t{ .div = 0 },\n};\n\nstatic const struct clk_div_table hclkbmh_table[] = {\n\t{ .val = 3, .div = 4 },\n\t{ .val = 7, .div = 8 },\n\t{ .div = 0 },\n};\n\nstatic const struct clk_div_table pclk_table[] = {\n\t{ .val = 15, .div = 16 },\n\t{ .val = 31, .div = 32 },\n\t{ .div = 0 },\n};\n\nstatic const struct clk_div_table rclk_table[] = {\n\t{ .val = 0, .div = 8 },\n\t{ .val = 1, .div = 16 },\n\t{ .val = 2, .div = 24 },\n\t{ .val = 3, .div = 32 },\n\t{ .div = 0 },\n};\n\nstatic const struct clk_div_table uhs1clk0_table[] = {\n\t{ .val = 0, .div = 2 },\n\t{ .val = 1, .div = 3 },\n\t{ .val = 2, .div = 4 },\n\t{ .val = 3, .div = 8 },\n\t{ .val = 4, .div = 16 },\n\t{ .div = 0 },\n};\n\nstatic const struct clk_div_table uhs2clk_table[] = {\n\t{ .val = 0, .div = 9 },\n\t{ .val = 1, .div = 10 },\n\t{ .val = 2, .div = 11 },\n\t{ .val = 3, .div = 12 },\n\t{ .val = 4, .div = 13 },\n\t{ .val = 5, .div = 14 },\n\t{ .val = 6, .div = 16 },\n\t{ .val = 7, .div = 18 },\n\t{ .div = 0 },\n};\n\nstatic u32 spi_mux_table[] = {0, 1, 2};\nstatic const char * const spi_mux_names[] = {\n\tM10V_SPI_PARENT0, M10V_SPI_PARENT1, M10V_SPI_PARENT2\n};\n\nstatic u32 uhs1clk2_mux_table[] = {2, 3, 4, 8};\nstatic const char * const uhs1clk2_mux_names[] = {\n\tM10V_UHS1CLK2_PARENT0, M10V_UHS1CLK2_PARENT1,\n\tM10V_UHS1CLK2_PARENT2, M10V_PLL6DIV2\n};\n\nstatic u32 uhs1clk1_mux_table[] = {3, 4, 8};\nstatic const char * const uhs1clk1_mux_names[] = {\n\tM10V_UHS1CLK1_PARENT0, M10V_UHS1CLK1_PARENT1, M10V_PLL6DIV2\n};\n\nstatic u32 nfclk_mux_table[] = {0, 1, 2, 3, 4, 8};\nstatic const char * const nfclk_mux_names[] = {\n\tM10V_NFCLK_PARENT0, M10V_NFCLK_PARENT1, M10V_NFCLK_PARENT2,\n\tM10V_NFCLK_PARENT3, M10V_NFCLK_PARENT4, M10V_NFCLK_PARENT5\n};\n\nstatic const struct m10v_clk_div_fixed_data m10v_pll_fixed_data[] = {\n\t{M10V_PLL1, NULL, 1, 40, -1},\n\t{M10V_PLL2, NULL, 1, 30, -1},\n\t{M10V_PLL6, NULL, 1, 35, -1},\n\t{M10V_PLL7, NULL, 1, 40, -1},\n\t{M10V_PLL9, NULL, 1, 33, -1},\n\t{M10V_PLL10, NULL, 5, 108, -1},\n\t{M10V_PLL10DIV2, M10V_PLL10, 2, 1, -1},\n\t{M10V_PLL11, NULL, 2, 75, -1},\n};\n\nstatic const struct m10v_clk_div_fixed_data m10v_div_fixed_data[] = {\n\t{\"usb2\", NULL, 2, 1, -1},\n\t{\"pcisuppclk\", NULL, 20, 1, -1},\n\t{M10V_PLL1DIV2, M10V_PLL1, 2, 1, -1},\n\t{M10V_PLL2DIV2, M10V_PLL2, 2, 1, -1},\n\t{M10V_PLL6DIV2, M10V_PLL6, 2, 1, -1},\n\t{M10V_PLL6DIV3, M10V_PLL6, 3, 1, -1},\n\t{M10V_PLL7DIV2, M10V_PLL7, 2, 1, -1},\n\t{M10V_PLL7DIV5, M10V_PLL7, 5, 1, -1},\n\t{\"ca7wd\", M10V_PLL2DIV2, 12, 1, -1},\n\t{\"pclkca7wd\", M10V_PLL1DIV2, 16, 1, -1},\n\t{M10V_SPI_PARENT0, M10V_PLL10DIV2, 2, 1, -1},\n\t{M10V_SPI_PARENT1, M10V_PLL10DIV2, 4, 1, -1},\n\t{M10V_SPI_PARENT2, M10V_PLL7DIV2, 8, 1, -1},\n\t{M10V_UHS1CLK2_PARENT0, M10V_PLL7, 4, 1, -1},\n\t{M10V_UHS1CLK2_PARENT1, M10V_PLL7, 8, 1, -1},\n\t{M10V_UHS1CLK2_PARENT2, M10V_PLL7, 16, 1, -1},\n\t{M10V_UHS1CLK1_PARENT0, M10V_PLL7, 8, 1, -1},\n\t{M10V_UHS1CLK1_PARENT1, M10V_PLL7, 16, 1, -1},\n\t{M10V_NFCLK_PARENT0, M10V_PLL7DIV2, 8, 1, -1},\n\t{M10V_NFCLK_PARENT1, M10V_PLL7DIV2, 10, 1, -1},\n\t{M10V_NFCLK_PARENT2, M10V_PLL7DIV2, 13, 1, -1},\n\t{M10V_NFCLK_PARENT3, M10V_PLL7DIV2, 16, 1, -1},\n\t{M10V_NFCLK_PARENT4, M10V_PLL7DIV2, 40, 1, -1},\n\t{M10V_NFCLK_PARENT5, M10V_PLL7DIV5, 10, 1, -1},\n};\n\nstatic const struct m10v_clk_div_factors m10v_div_factor_data[] = {\n\t{\"emmc\", M10V_PLL11, CLKSEL(1), 28, 3, emmcclk_table, 0,\n\t\tM10V_EMMCCLK_ID},\n\t{\"mclk400\", M10V_PLL1DIV2, CLKSEL(10), 7, 3, mclk400_table, 0, -1},\n\t{\"mclk200\", M10V_PLL1DIV2, CLKSEL(10), 3, 4, mclk200_table, 0, -1},\n\t{\"aclk400\", M10V_PLL1DIV2, CLKSEL(10), 0, 3, aclk400_table, 0, -1},\n\t{\"aclk300\", M10V_PLL2DIV2, CLKSEL(12), 0, 2, aclk300_table, 0, -1},\n\t{\"aclk\", M10V_PLL1DIV2, CLKSEL(9), 20, 4, aclk_table, 0, M10V_ACLK_ID},\n\t{\"aclkexs\", M10V_PLL1DIV2, CLKSEL(9), 16, 4, aclkexs_table, 0, -1},\n\t{\"hclk\", M10V_PLL1DIV2, CLKSEL(9), 7, 5, hclk_table, 0, M10V_HCLK_ID},\n\t{\"hclkbmh\", M10V_PLL1DIV2, CLKSEL(9), 12, 4, hclkbmh_table, 0, -1},\n\t{\"pclk\", M10V_PLL1DIV2, CLKSEL(9), 0, 7, pclk_table, 0, M10V_PCLK_ID},\n\t{\"uhs1clk0\", M10V_PLL7, CLKSEL(1), 3, 5, uhs1clk0_table, 0, -1},\n\t{\"uhs2clk\", M10V_PLL6DIV3, CLKSEL(1), 18, 4, uhs2clk_table, 0, -1},\n};\n\nstatic const struct m10v_clk_mux_factors m10v_mux_factor_data[] = {\n\t{\"spi\", spi_mux_names, ARRAY_SIZE(spi_mux_names),\n\t\tCLKSEL(8), 3, 7, spi_mux_table, 0, M10V_SPICLK_ID},\n\t{\"uhs1clk2\", uhs1clk2_mux_names, ARRAY_SIZE(uhs1clk2_mux_names),\n\t\tCLKSEL(1), 13, 31, uhs1clk2_mux_table, 0, M10V_UHS1CLK2_ID},\n\t{\"uhs1clk1\", uhs1clk1_mux_names, ARRAY_SIZE(uhs1clk1_mux_names),\n\t\tCLKSEL(1), 8, 31, uhs1clk1_mux_table, 0, -1},\n\t{\"nfclk\", nfclk_mux_names, ARRAY_SIZE(nfclk_mux_names),\n\t\tCLKSEL(1), 22, 127, nfclk_mux_table, 0, M10V_NFCLK_ID},\n};\n\nstatic u8 m10v_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_mux *mux = to_clk_mux(hw);\n\tu32 val;\n\n\tval = readl(mux->reg) >> mux->shift;\n\tval &= mux->mask;\n\n\treturn clk_mux_val_to_index(hw, mux->table, mux->flags, val);\n}\n\nstatic int m10v_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_mux *mux = to_clk_mux(hw);\n\tu32 val = clk_mux_index_to_val(mux->table, mux->flags, index);\n\tunsigned long flags = 0;\n\tu32 reg;\n\tu32 write_en = BIT(fls(mux->mask) - 1);\n\n\tif (mux->lock)\n\t\tspin_lock_irqsave(mux->lock, flags);\n\telse\n\t\t__acquire(mux->lock);\n\n\treg = readl(mux->reg);\n\treg &= ~(mux->mask << mux->shift);\n\n\tval = (val | write_en) << mux->shift;\n\treg |= val;\n\twritel(reg, mux->reg);\n\n\tif (mux->lock)\n\t\tspin_unlock_irqrestore(mux->lock, flags);\n\telse\n\t\t__release(mux->lock);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops m10v_mux_ops = {\n\t.get_parent = m10v_mux_get_parent,\n\t.set_parent = m10v_mux_set_parent,\n\t.determine_rate = __clk_mux_determine_rate,\n};\n\nstatic struct clk_hw *m10v_clk_hw_register_mux(struct device *dev,\n\t\t\tconst char *name, const char * const *parent_names,\n\t\t\tu8 num_parents, unsigned long flags, void __iomem *reg,\n\t\t\tu8 shift, u32 mask, u8 clk_mux_flags, u32 *table,\n\t\t\tspinlock_t *lock)\n{\n\tstruct clk_mux *mux;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &m10v_mux_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\n\tmux->reg = reg;\n\tmux->shift = shift;\n\tmux->mask = mask;\n\tmux->flags = clk_mux_flags;\n\tmux->lock = lock;\n\tmux->table = table;\n\tmux->hw.init = &init;\n\n\thw = &mux->hw;\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\tkfree(mux);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n\n}\n\nstruct m10v_clk_divider {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*reg;\n\tu8\t\tshift;\n\tu8\t\twidth;\n\tu8\t\tflags;\n\tconst struct clk_div_table\t*table;\n\tspinlock_t\t*lock;\n\tvoid __iomem\t*write_valid_reg;\n};\n\nstatic unsigned long m10v_clk_divider_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct m10v_clk_divider *divider = to_m10v_div(hw);\n\tunsigned int val;\n\n\tval = readl(divider->reg) >> divider->shift;\n\tval &= clk_div_mask(divider->width);\n\n\treturn divider_recalc_rate(hw, parent_rate, val, divider->table,\n\t\t\t\t   divider->flags, divider->width);\n}\n\nstatic long m10v_clk_divider_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *prate)\n{\n\tstruct m10v_clk_divider *divider = to_m10v_div(hw);\n\n\t \n\tif (divider->flags & CLK_DIVIDER_READ_ONLY) {\n\t\tu32 val;\n\n\t\tval = readl(divider->reg) >> divider->shift;\n\t\tval &= clk_div_mask(divider->width);\n\n\t\treturn divider_ro_round_rate(hw, rate, prate, divider->table,\n\t\t\t\t\t     divider->width, divider->flags,\n\t\t\t\t\t     val);\n\t}\n\n\treturn divider_round_rate(hw, rate, prate, divider->table,\n\t\t\t\t  divider->width, divider->flags);\n}\n\nstatic int m10v_clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct m10v_clk_divider *divider = to_m10v_div(hw);\n\tint value;\n\tunsigned long flags = 0;\n\tu32 val;\n\tu32 write_en = BIT(divider->width - 1);\n\n\tvalue = divider_get_val(rate, parent_rate, divider->table,\n\t\t\t\tdivider->width, divider->flags);\n\tif (value < 0)\n\t\treturn value;\n\n\tif (divider->lock)\n\t\tspin_lock_irqsave(divider->lock, flags);\n\telse\n\t\t__acquire(divider->lock);\n\n\tval = readl(divider->reg);\n\tval &= ~(clk_div_mask(divider->width) << divider->shift);\n\n\tval |= ((u32)value | write_en) << divider->shift;\n\twritel(val, divider->reg);\n\n\tif (divider->write_valid_reg) {\n\t\twritel(M10V_DCHREQ, divider->write_valid_reg);\n\t\tif (readl_poll_timeout(divider->write_valid_reg, val,\n\t\t\t!val, M10V_UPOLL_RATE, M10V_UTIMEOUT))\n\t\t\tpr_err(\"%s:%s couldn't stabilize\\n\",\n\t\t\t\t__func__, clk_hw_get_name(hw));\n\t}\n\n\tif (divider->lock)\n\t\tspin_unlock_irqrestore(divider->lock, flags);\n\telse\n\t\t__release(divider->lock);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops m10v_clk_divider_ops = {\n\t.recalc_rate = m10v_clk_divider_recalc_rate,\n\t.round_rate = m10v_clk_divider_round_rate,\n\t.set_rate = m10v_clk_divider_set_rate,\n};\n\nstatic struct clk_hw *m10v_clk_hw_register_divider(struct device *dev,\n\t\tconst char *name, const char *parent_name, unsigned long flags,\n\t\tvoid __iomem *reg, u8 shift, u8 width,\n\t\tu8 clk_divider_flags, const struct clk_div_table *table,\n\t\tspinlock_t *lock, void __iomem *write_valid_reg)\n{\n\tstruct m10v_clk_divider *div;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &m10v_clk_divider_ops;\n\tinit.flags = flags;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tdiv->reg = reg;\n\tdiv->shift = shift;\n\tdiv->width = width;\n\tdiv->flags = clk_divider_flags;\n\tdiv->lock = lock;\n\tdiv->hw.init = &init;\n\tdiv->table = table;\n\tdiv->write_valid_reg = write_valid_reg;\n\n\t \n\thw = &div->hw;\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\tkfree(div);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstatic void m10v_reg_div_pre(const struct m10v_clk_div_factors *factors,\n\t\t\t     struct clk_hw_onecell_data *clk_data,\n\t\t\t     void __iomem *base)\n{\n\tstruct clk_hw *hw;\n\tvoid __iomem *write_valid_reg;\n\n\t \n\tif ((factors->offset == CLKSEL(9)) || (factors->offset == CLKSEL(10)))\n\t\twrite_valid_reg = base + CLKSEL(11);\n\telse\n\t\twrite_valid_reg = NULL;\n\n\thw = m10v_clk_hw_register_divider(NULL, factors->name,\n\t\t\t\t\t  factors->parent_name,\n\t\t\t\t\t  CLK_SET_RATE_PARENT,\n\t\t\t\t\t  base + factors->offset,\n\t\t\t\t\t  factors->shift,\n\t\t\t\t\t  factors->width, factors->div_flags,\n\t\t\t\t\t  factors->table,\n\t\t\t\t\t  &m10v_crglock, write_valid_reg);\n\n\tif (factors->onecell_idx >= 0)\n\t\tclk_data->hws[factors->onecell_idx] = hw;\n}\n\nstatic void m10v_reg_fixed_pre(const struct m10v_clk_div_fixed_data *factors,\n\t\t\t       struct clk_hw_onecell_data *clk_data,\n\t\t\t       const char *parent_name)\n{\n\tstruct clk_hw *hw;\n\tconst char *pn = factors->parent_name ?\n\t\t\t\tfactors->parent_name : parent_name;\n\n\thw = clk_hw_register_fixed_factor(NULL, factors->name, pn, 0,\n\t\t\t\t\t  factors->mult, factors->div);\n\n\tif (factors->onecell_idx >= 0)\n\t\tclk_data->hws[factors->onecell_idx] = hw;\n}\n\nstatic void m10v_reg_mux_pre(const struct m10v_clk_mux_factors *factors,\n\t\t\t       struct clk_hw_onecell_data *clk_data,\n\t\t\t       void __iomem *base)\n{\n\tstruct clk_hw *hw;\n\n\thw = m10v_clk_hw_register_mux(NULL, factors->name,\n\t\t\t\t      factors->parent_names,\n\t\t\t\t      factors->num_parents,\n\t\t\t\t      CLK_SET_RATE_PARENT,\n\t\t\t\t      base + factors->offset, factors->shift,\n\t\t\t\t      factors->mask, factors->mux_flags,\n\t\t\t\t      factors->table, &m10v_crglock);\n\n\tif (factors->onecell_idx >= 0)\n\t\tclk_data->hws[factors->onecell_idx] = hw;\n}\n\nstatic int m10v_clk_probe(struct platform_device *pdev)\n{\n\tint id;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tvoid __iomem *base;\n\tconst char *parent_name;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\n\tfor (id = 0; id < ARRAY_SIZE(m10v_div_factor_data); ++id)\n\t\tm10v_reg_div_pre(&m10v_div_factor_data[id],\n\t\t\t\t m10v_clk_data, base);\n\n\tfor (id = 0; id < ARRAY_SIZE(m10v_div_fixed_data); ++id)\n\t\tm10v_reg_fixed_pre(&m10v_div_fixed_data[id],\n\t\t\t\t   m10v_clk_data, parent_name);\n\n\tfor (id = 0; id < ARRAY_SIZE(m10v_mux_factor_data); ++id)\n\t\tm10v_reg_mux_pre(&m10v_mux_factor_data[id],\n\t\t\t\t m10v_clk_data, base);\n\n\tfor (id = 0; id < M10V_NUM_CLKS; id++) {\n\t\tif (IS_ERR(m10v_clk_data->hws[id]))\n\t\t\treturn PTR_ERR(m10v_clk_data->hws[id]);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id m10v_clk_dt_ids[] = {\n\t{ .compatible = \"socionext,milbeaut-m10v-ccu\", },\n\t{ }\n};\n\nstatic struct platform_driver m10v_clk_driver = {\n\t.probe  = m10v_clk_probe,\n\t.driver = {\n\t\t.name = \"m10v-ccu\",\n\t\t.of_match_table = m10v_clk_dt_ids,\n\t},\n};\nbuiltin_platform_driver(m10v_clk_driver);\n\nstatic void __init m10v_cc_init(struct device_node *np)\n{\n\tint id;\n\tvoid __iomem *base;\n\tconst char *parent_name;\n\tstruct clk_hw *hw;\n\n\tm10v_clk_data = kzalloc(struct_size(m10v_clk_data, hws,\n\t\t\t\t\tM10V_NUM_CLKS),\n\t\t\t\t\tGFP_KERNEL);\n\n\tif (!m10v_clk_data)\n\t\treturn;\n\tm10v_clk_data->num = M10V_NUM_CLKS;\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tkfree(m10v_clk_data);\n\t\treturn;\n\t}\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\tif (!parent_name) {\n\t\tkfree(m10v_clk_data);\n\t\tiounmap(base);\n\t\treturn;\n\t}\n\n\t \n\tfor (id = 0; id < M10V_NUM_CLKS; id++)\n\t\tm10v_clk_data->hws[id] = ERR_PTR(-EPROBE_DEFER);\n\n\t \n\tfor (id = 0; id < ARRAY_SIZE(m10v_pll_fixed_data); ++id)\n\t\tm10v_reg_fixed_pre(&m10v_pll_fixed_data[id],\n\t\t\t\t   m10v_clk_data, parent_name);\n\n\t \n\thw = m10v_clk_hw_register_divider(NULL, \"rclk\", M10V_PLL10DIV2, 0,\n\t\t\t\t\tbase + CLKSEL(1), 0, 3, 0, rclk_table,\n\t\t\t\t\t&m10v_crglock, NULL);\n\tm10v_clk_data->hws[M10V_RCLK_ID] = hw;\n\tof_clk_add_hw_provider(np, of_clk_hw_onecell_get, m10v_clk_data);\n}\nCLK_OF_DECLARE_DRIVER(m10v_cc, \"socionext,milbeaut-m10v-ccu\", m10v_cc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}