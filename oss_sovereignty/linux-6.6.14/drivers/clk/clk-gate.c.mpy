{
  "module_name": "clk-gate.c",
  "hash_id": "81ffe44ac394c2ab62db90200cefe1391c08f09a4264b771766ca4129f8e75bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-gate.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/string.h>\n\n \n\nstatic inline u32 clk_gate_readl(struct clk_gate *gate)\n{\n\tif (gate->flags & CLK_GATE_BIG_ENDIAN)\n\t\treturn ioread32be(gate->reg);\n\n\treturn readl(gate->reg);\n}\n\nstatic inline void clk_gate_writel(struct clk_gate *gate, u32 val)\n{\n\tif (gate->flags & CLK_GATE_BIG_ENDIAN)\n\t\tiowrite32be(val, gate->reg);\n\telse\n\t\twritel(val, gate->reg);\n}\n\n \nstatic void clk_gate_endisable(struct clk_hw *hw, int enable)\n{\n\tstruct clk_gate *gate = to_clk_gate(hw);\n\tint set = gate->flags & CLK_GATE_SET_TO_DISABLE ? 1 : 0;\n\tunsigned long flags;\n\tu32 reg;\n\n\tset ^= enable;\n\n\tif (gate->lock)\n\t\tspin_lock_irqsave(gate->lock, flags);\n\telse\n\t\t__acquire(gate->lock);\n\n\tif (gate->flags & CLK_GATE_HIWORD_MASK) {\n\t\treg = BIT(gate->bit_idx + 16);\n\t\tif (set)\n\t\t\treg |= BIT(gate->bit_idx);\n\t} else {\n\t\treg = clk_gate_readl(gate);\n\n\t\tif (set)\n\t\t\treg |= BIT(gate->bit_idx);\n\t\telse\n\t\t\treg &= ~BIT(gate->bit_idx);\n\t}\n\n\tclk_gate_writel(gate, reg);\n\n\tif (gate->lock)\n\t\tspin_unlock_irqrestore(gate->lock, flags);\n\telse\n\t\t__release(gate->lock);\n}\n\nstatic int clk_gate_enable(struct clk_hw *hw)\n{\n\tclk_gate_endisable(hw, 1);\n\n\treturn 0;\n}\n\nstatic void clk_gate_disable(struct clk_hw *hw)\n{\n\tclk_gate_endisable(hw, 0);\n}\n\nint clk_gate_is_enabled(struct clk_hw *hw)\n{\n\tu32 reg;\n\tstruct clk_gate *gate = to_clk_gate(hw);\n\n\treg = clk_gate_readl(gate);\n\n\t \n\tif (gate->flags & CLK_GATE_SET_TO_DISABLE)\n\t\treg ^= BIT(gate->bit_idx);\n\n\treg &= BIT(gate->bit_idx);\n\n\treturn reg ? 1 : 0;\n}\nEXPORT_SYMBOL_GPL(clk_gate_is_enabled);\n\nconst struct clk_ops clk_gate_ops = {\n\t.enable = clk_gate_enable,\n\t.disable = clk_gate_disable,\n\t.is_enabled = clk_gate_is_enabled,\n};\nEXPORT_SYMBOL_GPL(clk_gate_ops);\n\nstruct clk_hw *__clk_hw_register_gate(struct device *dev,\n\t\tstruct device_node *np, const char *name,\n\t\tconst char *parent_name, const struct clk_hw *parent_hw,\n\t\tconst struct clk_parent_data *parent_data,\n\t\tunsigned long flags,\n\t\tvoid __iomem *reg, u8 bit_idx,\n\t\tu8 clk_gate_flags, spinlock_t *lock)\n{\n\tstruct clk_gate *gate;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tint ret = -EINVAL;\n\n\tif (clk_gate_flags & CLK_GATE_HIWORD_MASK) {\n\t\tif (bit_idx > 15) {\n\t\t\tpr_err(\"gate bit exceeds LOWORD field\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\t \n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &clk_gate_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.parent_hws = parent_hw ? &parent_hw : NULL;\n\tinit.parent_data = parent_data;\n\tif (parent_name || parent_hw || parent_data)\n\t\tinit.num_parents = 1;\n\telse\n\t\tinit.num_parents = 0;\n\n\t \n\tgate->reg = reg;\n\tgate->bit_idx = bit_idx;\n\tgate->flags = clk_gate_flags;\n\tgate->lock = lock;\n\tgate->hw.init = &init;\n\n\thw = &gate->hw;\n\tif (dev || !np)\n\t\tret = clk_hw_register(dev, hw);\n\telse if (np)\n\t\tret = of_clk_hw_register(np, hw);\n\tif (ret) {\n\t\tkfree(gate);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n\n}\nEXPORT_SYMBOL_GPL(__clk_hw_register_gate);\n\nstruct clk *clk_register_gate(struct device *dev, const char *name,\n\t\tconst char *parent_name, unsigned long flags,\n\t\tvoid __iomem *reg, u8 bit_idx,\n\t\tu8 clk_gate_flags, spinlock_t *lock)\n{\n\tstruct clk_hw *hw;\n\n\thw = clk_hw_register_gate(dev, name, parent_name, flags, reg,\n\t\t\t\t  bit_idx, clk_gate_flags, lock);\n\tif (IS_ERR(hw))\n\t\treturn ERR_CAST(hw);\n\treturn hw->clk;\n}\nEXPORT_SYMBOL_GPL(clk_register_gate);\n\nvoid clk_unregister_gate(struct clk *clk)\n{\n\tstruct clk_gate *gate;\n\tstruct clk_hw *hw;\n\n\thw = __clk_get_hw(clk);\n\tif (!hw)\n\t\treturn;\n\n\tgate = to_clk_gate(hw);\n\n\tclk_unregister(clk);\n\tkfree(gate);\n}\nEXPORT_SYMBOL_GPL(clk_unregister_gate);\n\nvoid clk_hw_unregister_gate(struct clk_hw *hw)\n{\n\tstruct clk_gate *gate;\n\n\tgate = to_clk_gate(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(gate);\n}\nEXPORT_SYMBOL_GPL(clk_hw_unregister_gate);\n\nstatic void devm_clk_hw_release_gate(struct device *dev, void *res)\n{\n\tclk_hw_unregister_gate(*(struct clk_hw **)res);\n}\n\nstruct clk_hw *__devm_clk_hw_register_gate(struct device *dev,\n\t\tstruct device_node *np, const char *name,\n\t\tconst char *parent_name, const struct clk_hw *parent_hw,\n\t\tconst struct clk_parent_data *parent_data,\n\t\tunsigned long flags,\n\t\tvoid __iomem *reg, u8 bit_idx,\n\t\tu8 clk_gate_flags, spinlock_t *lock)\n{\n\tstruct clk_hw **ptr, *hw;\n\n\tptr = devres_alloc(devm_clk_hw_release_gate, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thw = __clk_hw_register_gate(dev, np, name, parent_name, parent_hw,\n\t\t\t\t    parent_data, flags, reg, bit_idx,\n\t\t\t\t    clk_gate_flags, lock);\n\n\tif (!IS_ERR(hw)) {\n\t\t*ptr = hw;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(__devm_clk_hw_register_gate);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}