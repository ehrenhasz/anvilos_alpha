{
  "module_name": "clk-en7523.c",
  "hash_id": "316524fd719b6a1f44816095211930d17f1f497ece7c307d0ea4d7fb19e98b58",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-en7523.c",
  "human_readable_source": "\n\n#include <linux/delay.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <dt-bindings/clock/en7523-clk.h>\n\n#define REG_PCI_CONTROL\t\t\t0x88\n#define   REG_PCI_CONTROL_PERSTOUT\tBIT(29)\n#define   REG_PCI_CONTROL_PERSTOUT1\tBIT(26)\n#define   REG_PCI_CONTROL_REFCLK_EN1\tBIT(22)\n#define REG_GSW_CLK_DIV_SEL\t\t0x1b4\n#define REG_EMI_CLK_DIV_SEL\t\t0x1b8\n#define REG_BUS_CLK_DIV_SEL\t\t0x1bc\n#define REG_SPI_CLK_DIV_SEL\t\t0x1c4\n#define REG_SPI_CLK_FREQ_SEL\t\t0x1c8\n#define REG_NPU_CLK_DIV_SEL\t\t0x1fc\n#define REG_CRYPTO_CLKSRC\t\t0x200\n#define REG_RESET_CONTROL\t\t0x834\n#define   REG_RESET_CONTROL_PCIEHB\tBIT(29)\n#define   REG_RESET_CONTROL_PCIE1\tBIT(27)\n#define   REG_RESET_CONTROL_PCIE2\tBIT(26)\n\nstruct en_clk_desc {\n\tint id;\n\tconst char *name;\n\tu32 base_reg;\n\tu8 base_bits;\n\tu8 base_shift;\n\tunion {\n\t\tconst unsigned int *base_values;\n\t\tunsigned int base_value;\n\t};\n\tsize_t n_base_values;\n\n\tu16 div_reg;\n\tu8 div_bits;\n\tu8 div_shift;\n\tu16 div_val0;\n\tu8 div_step;\n};\n\nstruct en_clk_gate {\n\tvoid __iomem *base;\n\tstruct clk_hw hw;\n};\n\nstatic const u32 gsw_base[] = { 400000000, 500000000 };\nstatic const u32 emi_base[] = { 333000000, 400000000 };\nstatic const u32 bus_base[] = { 500000000, 540000000 };\nstatic const u32 slic_base[] = { 100000000, 3125000 };\nstatic const u32 npu_base[] = { 333000000, 400000000, 500000000 };\n\nstatic const struct en_clk_desc en7523_base_clks[] = {\n\t{\n\t\t.id = EN7523_CLK_GSW,\n\t\t.name = \"gsw\",\n\n\t\t.base_reg = REG_GSW_CLK_DIV_SEL,\n\t\t.base_bits = 1,\n\t\t.base_shift = 8,\n\t\t.base_values = gsw_base,\n\t\t.n_base_values = ARRAY_SIZE(gsw_base),\n\n\t\t.div_bits = 3,\n\t\t.div_shift = 0,\n\t\t.div_step = 1,\n\t}, {\n\t\t.id = EN7523_CLK_EMI,\n\t\t.name = \"emi\",\n\n\t\t.base_reg = REG_EMI_CLK_DIV_SEL,\n\t\t.base_bits = 1,\n\t\t.base_shift = 8,\n\t\t.base_values = emi_base,\n\t\t.n_base_values = ARRAY_SIZE(emi_base),\n\n\t\t.div_bits = 3,\n\t\t.div_shift = 0,\n\t\t.div_step = 1,\n\t}, {\n\t\t.id = EN7523_CLK_BUS,\n\t\t.name = \"bus\",\n\n\t\t.base_reg = REG_BUS_CLK_DIV_SEL,\n\t\t.base_bits = 1,\n\t\t.base_shift = 8,\n\t\t.base_values = bus_base,\n\t\t.n_base_values = ARRAY_SIZE(bus_base),\n\n\t\t.div_bits = 3,\n\t\t.div_shift = 0,\n\t\t.div_step = 1,\n\t}, {\n\t\t.id = EN7523_CLK_SLIC,\n\t\t.name = \"slic\",\n\n\t\t.base_reg = REG_SPI_CLK_FREQ_SEL,\n\t\t.base_bits = 1,\n\t\t.base_shift = 0,\n\t\t.base_values = slic_base,\n\t\t.n_base_values = ARRAY_SIZE(slic_base),\n\n\t\t.div_reg = REG_SPI_CLK_DIV_SEL,\n\t\t.div_bits = 5,\n\t\t.div_shift = 24,\n\t\t.div_val0 = 20,\n\t\t.div_step = 2,\n\t}, {\n\t\t.id = EN7523_CLK_SPI,\n\t\t.name = \"spi\",\n\n\t\t.base_reg = REG_SPI_CLK_DIV_SEL,\n\n\t\t.base_value = 400000000,\n\n\t\t.div_bits = 5,\n\t\t.div_shift = 8,\n\t\t.div_val0 = 40,\n\t\t.div_step = 2,\n\t}, {\n\t\t.id = EN7523_CLK_NPU,\n\t\t.name = \"npu\",\n\n\t\t.base_reg = REG_NPU_CLK_DIV_SEL,\n\t\t.base_bits = 2,\n\t\t.base_shift = 8,\n\t\t.base_values = npu_base,\n\t\t.n_base_values = ARRAY_SIZE(npu_base),\n\n\t\t.div_bits = 3,\n\t\t.div_shift = 0,\n\t\t.div_step = 1,\n\t}, {\n\t\t.id = EN7523_CLK_CRYPTO,\n\t\t.name = \"crypto\",\n\n\t\t.base_reg = REG_CRYPTO_CLKSRC,\n\t\t.base_bits = 1,\n\t\t.base_shift = 8,\n\t\t.base_values = emi_base,\n\t\t.n_base_values = ARRAY_SIZE(emi_base),\n\t}\n};\n\nstatic const struct of_device_id of_match_clk_en7523[] = {\n\t{ .compatible = \"airoha,en7523-scu\", },\n\t{   }\n};\n\nstatic unsigned int en7523_get_base_rate(void __iomem *base, unsigned int i)\n{\n\tconst struct en_clk_desc *desc = &en7523_base_clks[i];\n\tu32 val;\n\n\tif (!desc->base_bits)\n\t\treturn desc->base_value;\n\n\tval = readl(base + desc->base_reg);\n\tval >>= desc->base_shift;\n\tval &= (1 << desc->base_bits) - 1;\n\n\tif (val >= desc->n_base_values)\n\t\treturn 0;\n\n\treturn desc->base_values[val];\n}\n\nstatic u32 en7523_get_div(void __iomem *base, int i)\n{\n\tconst struct en_clk_desc *desc = &en7523_base_clks[i];\n\tu32 reg, val;\n\n\tif (!desc->div_bits)\n\t\treturn 1;\n\n\treg = desc->div_reg ? desc->div_reg : desc->base_reg;\n\tval = readl(base + reg);\n\tval >>= desc->div_shift;\n\tval &= (1 << desc->div_bits) - 1;\n\n\tif (!val && desc->div_val0)\n\t\treturn desc->div_val0;\n\n\treturn (val + 1) * desc->div_step;\n}\n\nstatic int en7523_pci_is_enabled(struct clk_hw *hw)\n{\n\tstruct en_clk_gate *cg = container_of(hw, struct en_clk_gate, hw);\n\n\treturn !!(readl(cg->base + REG_PCI_CONTROL) & REG_PCI_CONTROL_REFCLK_EN1);\n}\n\nstatic int en7523_pci_prepare(struct clk_hw *hw)\n{\n\tstruct en_clk_gate *cg = container_of(hw, struct en_clk_gate, hw);\n\tvoid __iomem *np_base = cg->base;\n\tu32 val, mask;\n\n\t \n\tval = readl(np_base + REG_PCI_CONTROL);\n\tval &= ~(REG_PCI_CONTROL_PERSTOUT1 | REG_PCI_CONTROL_PERSTOUT);\n\twritel(val, np_base + REG_PCI_CONTROL);\n\tusleep_range(1000, 2000);\n\n\t \n\tval |= REG_PCI_CONTROL_REFCLK_EN1;\n\twritel(val, np_base + REG_PCI_CONTROL);\n\tusleep_range(1000, 2000);\n\n\t \n\tval = readl(np_base + REG_RESET_CONTROL);\n\tmask = REG_RESET_CONTROL_PCIE1 | REG_RESET_CONTROL_PCIE2 |\n\t       REG_RESET_CONTROL_PCIEHB;\n\twritel(val & ~mask, np_base + REG_RESET_CONTROL);\n\tusleep_range(1000, 2000);\n\twritel(val | mask, np_base + REG_RESET_CONTROL);\n\tmsleep(100);\n\twritel(val & ~mask, np_base + REG_RESET_CONTROL);\n\tusleep_range(5000, 10000);\n\n\t \n\tmask = REG_PCI_CONTROL_PERSTOUT1 | REG_PCI_CONTROL_PERSTOUT;\n\tval = readl(np_base + REG_PCI_CONTROL);\n\twritel(val & ~mask, np_base + REG_PCI_CONTROL);\n\tusleep_range(1000, 2000);\n\twritel(val | mask, np_base + REG_PCI_CONTROL);\n\tmsleep(250);\n\n\treturn 0;\n}\n\nstatic void en7523_pci_unprepare(struct clk_hw *hw)\n{\n\tstruct en_clk_gate *cg = container_of(hw, struct en_clk_gate, hw);\n\tvoid __iomem *np_base = cg->base;\n\tu32 val;\n\n\tval = readl(np_base + REG_PCI_CONTROL);\n\tval &= ~REG_PCI_CONTROL_REFCLK_EN1;\n\twritel(val, np_base + REG_PCI_CONTROL);\n}\n\nstatic struct clk_hw *en7523_register_pcie_clk(struct device *dev,\n\t\t\t\t\t       void __iomem *np_base)\n{\n\tstatic const struct clk_ops pcie_gate_ops = {\n\t\t.is_enabled = en7523_pci_is_enabled,\n\t\t.prepare = en7523_pci_prepare,\n\t\t.unprepare = en7523_pci_unprepare,\n\t};\n\tstruct clk_init_data init = {\n\t\t.name = \"pcie\",\n\t\t.ops = &pcie_gate_ops,\n\t};\n\tstruct en_clk_gate *cg;\n\n\tcg = devm_kzalloc(dev, sizeof(*cg), GFP_KERNEL);\n\tif (!cg)\n\t\treturn NULL;\n\n\tcg->base = np_base;\n\tcg->hw.init = &init;\n\ten7523_pci_unprepare(&cg->hw);\n\n\tif (clk_hw_register(dev, &cg->hw))\n\t\treturn NULL;\n\n\treturn &cg->hw;\n}\n\nstatic void en7523_register_clocks(struct device *dev, struct clk_hw_onecell_data *clk_data,\n\t\t\t\t   void __iomem *base, void __iomem *np_base)\n{\n\tstruct clk_hw *hw;\n\tu32 rate;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(en7523_base_clks); i++) {\n\t\tconst struct en_clk_desc *desc = &en7523_base_clks[i];\n\n\t\trate = en7523_get_base_rate(base, i);\n\t\trate /= en7523_get_div(base, i);\n\n\t\thw = clk_hw_register_fixed_rate(dev, desc->name, NULL, 0, rate);\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"Failed to register clk %s: %ld\\n\",\n\t\t\t       desc->name, PTR_ERR(hw));\n\t\t\tcontinue;\n\t\t}\n\n\t\tclk_data->hws[desc->id] = hw;\n\t}\n\n\thw = en7523_register_pcie_clk(dev, np_base);\n\tclk_data->hws[EN7523_CLK_PCIE] = hw;\n\n\tclk_data->num = EN7523_NUM_CLOCKS;\n}\n\nstatic int en7523_clk_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct clk_hw_onecell_data *clk_data;\n\tvoid __iomem *base, *np_base;\n\tint r;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tnp_base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(np_base))\n\t\treturn PTR_ERR(np_base);\n\n\tclk_data = devm_kzalloc(&pdev->dev,\n\t\t\t\tstruct_size(clk_data, hws, EN7523_NUM_CLOCKS),\n\t\t\t\tGFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\ten7523_register_clocks(&pdev->dev, clk_data, base, np_base);\n\n\tr = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, clk_data);\n\tif (r)\n\t\tdev_err(&pdev->dev,\n\t\t\t\"could not register clock provider: %s: %d\\n\",\n\t\t\tpdev->name, r);\n\n\treturn r;\n}\n\nstatic struct platform_driver clk_en7523_drv = {\n\t.probe = en7523_clk_probe,\n\t.driver = {\n\t\t.name = \"clk-en7523\",\n\t\t.of_match_table = of_match_clk_en7523,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nstatic int __init clk_en7523_init(void)\n{\n\treturn platform_driver_register(&clk_en7523_drv);\n}\n\narch_initcall(clk_en7523_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}