{
  "module_name": "clk-plldig.c",
  "hash_id": "b1d7bce95668d7e8da9cec695beb97e76241507cf985b6725d4f7e8fb451559f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-plldig.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/bitfield.h>\n\n \n#define PLLDIG_REG_PLLSR            0x24\n#define PLLDIG_LOCK_MASK            BIT(2)\n#define PLLDIG_REG_PLLDV            0x28\n#define PLLDIG_MFD_MASK             GENMASK(7, 0)\n#define PLLDIG_RFDPHI1_MASK         GENMASK(30, 25)\n#define PLLDIG_REG_PLLFM            0x2c\n#define PLLDIG_SSCGBYP_ENABLE       BIT(30)\n#define PLLDIG_REG_PLLFD            0x30\n#define PLLDIG_FDEN                 BIT(30)\n#define PLLDIG_FRAC_MASK            GENMASK(15, 0)\n#define PLLDIG_REG_PLLCAL1          0x38\n#define PLLDIG_REG_PLLCAL2          0x3c\n\n \n#define PLLDIG_MIN_VCO_FREQ         650000000\n#define PLLDIG_MAX_VCO_FREQ         1300000000\n\n \n#define PHI1_MIN_FREQ               27000000UL\n#define PHI1_MAX_FREQ               600000000UL\n\n \n#define MAX_RFDPHI1          63UL\n\n \n#define PLLDIG_DEFAULT_MFD   44\n\n \n#define MFDEN          20480\n\nstatic const struct clk_parent_data parent_data[] = {\n\t{ .index = 0 },\n};\n\nstruct clk_plldig {\n\tstruct clk_hw hw;\n\tvoid __iomem *regs;\n\tunsigned int vco_freq;\n};\n\n#define to_clk_plldig(_hw)\tcontainer_of(_hw, struct clk_plldig, hw)\n\nstatic int plldig_enable(struct clk_hw *hw)\n{\n\tstruct clk_plldig *data = to_clk_plldig(hw);\n\tu32 val;\n\n\tval = readl(data->regs + PLLDIG_REG_PLLFM);\n\t \n\tval |= PLLDIG_SSCGBYP_ENABLE;\n\twritel(val, data->regs + PLLDIG_REG_PLLFM);\n\n\treturn 0;\n}\n\nstatic void plldig_disable(struct clk_hw *hw)\n{\n\tstruct clk_plldig *data = to_clk_plldig(hw);\n\tu32 val;\n\n\tval = readl(data->regs + PLLDIG_REG_PLLFM);\n\n\tval &= ~PLLDIG_SSCGBYP_ENABLE;\n\tval |= FIELD_PREP(PLLDIG_SSCGBYP_ENABLE, 0x0);\n\n\twritel(val, data->regs + PLLDIG_REG_PLLFM);\n}\n\nstatic int plldig_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_plldig *data = to_clk_plldig(hw);\n\n\treturn readl(data->regs + PLLDIG_REG_PLLFM) &\n\t\t\t      PLLDIG_SSCGBYP_ENABLE;\n}\n\nstatic unsigned long plldig_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_plldig *data = to_clk_plldig(hw);\n\tu32 val, rfdphi1;\n\n\tval = readl(data->regs + PLLDIG_REG_PLLDV);\n\n\t \n\tif (val & PLLDIG_SSCGBYP_ENABLE)\n\t\treturn parent_rate;\n\n\trfdphi1 = FIELD_GET(PLLDIG_RFDPHI1_MASK, val);\n\n\t \n\tif (!rfdphi1)\n\t\trfdphi1 = 1;\n\n\treturn DIV_ROUND_UP(data->vco_freq, rfdphi1);\n}\n\nstatic unsigned long plldig_calc_target_div(unsigned long vco_freq,\n\t\t\t\t\t    unsigned long target_rate)\n{\n\tunsigned long div;\n\n\tdiv = DIV_ROUND_CLOSEST(vco_freq, target_rate);\n\tdiv = clamp(div, 1UL, MAX_RFDPHI1);\n\n\treturn div;\n}\n\nstatic int plldig_determine_rate(struct clk_hw *hw,\n\t\t\t\t struct clk_rate_request *req)\n{\n\tstruct clk_plldig *data = to_clk_plldig(hw);\n\tunsigned int div;\n\n\treq->rate = clamp(req->rate, PHI1_MIN_FREQ, PHI1_MAX_FREQ);\n\tdiv = plldig_calc_target_div(data->vco_freq, req->rate);\n\treq->rate = DIV_ROUND_UP(data->vco_freq, div);\n\n\treturn 0;\n}\n\nstatic int plldig_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_plldig *data = to_clk_plldig(hw);\n\tunsigned int val, cond;\n\tunsigned int rfdphi1;\n\n\trate = clamp(rate, PHI1_MIN_FREQ, PHI1_MAX_FREQ);\n\trfdphi1 = plldig_calc_target_div(data->vco_freq, rate);\n\n\t \n\tval = readl(data->regs + PLLDIG_REG_PLLDV);\n\tval &= ~PLLDIG_RFDPHI1_MASK;\n\tval |= FIELD_PREP(PLLDIG_RFDPHI1_MASK, rfdphi1);\n\twritel(val, data->regs + PLLDIG_REG_PLLDV);\n\n\t \n\tudelay(200);\n\n\t \n\treturn readl_poll_timeout_atomic(data->regs + PLLDIG_REG_PLLSR, cond,\n\t\t\t\t\t cond & PLLDIG_LOCK_MASK, 0,\n\t\t\t\t\t USEC_PER_MSEC);\n}\n\nstatic const struct clk_ops plldig_clk_ops = {\n\t.enable = plldig_enable,\n\t.disable = plldig_disable,\n\t.is_enabled = plldig_is_enabled,\n\t.recalc_rate = plldig_recalc_rate,\n\t.determine_rate = plldig_determine_rate,\n\t.set_rate = plldig_set_rate,\n};\n\nstatic int plldig_init(struct clk_hw *hw)\n{\n\tstruct clk_plldig *data = to_clk_plldig(hw);\n\tstruct clk_hw *parent = clk_hw_get_parent(hw);\n\tunsigned long parent_rate;\n\tunsigned long val;\n\tunsigned long long lltmp;\n\tunsigned int mfd, fracdiv = 0;\n\n\tif (!parent)\n\t\treturn -EINVAL;\n\n\tparent_rate = clk_hw_get_rate(parent);\n\n\tif (data->vco_freq) {\n\t\tmfd = data->vco_freq / parent_rate;\n\t\tlltmp = data->vco_freq % parent_rate;\n\t\tlltmp *= MFDEN;\n\t\tdo_div(lltmp, parent_rate);\n\t\tfracdiv = lltmp;\n\t} else {\n\t\tmfd = PLLDIG_DEFAULT_MFD;\n\t\tdata->vco_freq = parent_rate * mfd;\n\t}\n\n\tval = FIELD_PREP(PLLDIG_MFD_MASK, mfd);\n\twritel(val, data->regs + PLLDIG_REG_PLLDV);\n\n\t \n\tif (fracdiv) {\n\t\tval = FIELD_PREP(PLLDIG_FRAC_MASK, fracdiv);\n\t\tval |= PLLDIG_FDEN;\n\t\twritel(val, data->regs + PLLDIG_REG_PLLFD);\n\t}\n\n\treturn 0;\n}\n\nstatic int plldig_clk_probe(struct platform_device *pdev)\n{\n\tstruct clk_plldig *data;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->regs))\n\t\treturn PTR_ERR(data->regs);\n\n\tdata->hw.init = CLK_HW_INIT_PARENTS_DATA(\"dpclk\",\n\t\t\t\t\t\t parent_data,\n\t\t\t\t\t\t &plldig_clk_ops,\n\t\t\t\t\t\t 0);\n\n\tret = devm_clk_hw_register(dev, &data->hw);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register %s clock\\n\",\n\t\t\t\t\t\tdev->of_node->name);\n\t\treturn ret;\n\t}\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,\n\t\t\t\t\t  &data->hw);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to add clk provider\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (!of_property_read_u32(dev->of_node, \"fsl,vco-hz\",\n\t\t\t\t  &data->vco_freq)) {\n\t\tif (data->vco_freq < PLLDIG_MIN_VCO_FREQ ||\n\t\t    data->vco_freq > PLLDIG_MAX_VCO_FREQ)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn plldig_init(&data->hw);\n}\n\nstatic const struct of_device_id plldig_clk_id[] = {\n\t{ .compatible = \"fsl,ls1028a-plldig\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, plldig_clk_id);\n\nstatic struct platform_driver plldig_clk_driver = {\n\t.driver = {\n\t\t.name = \"plldig-clock\",\n\t\t.of_match_table = plldig_clk_id,\n\t},\n\t.probe = plldig_clk_probe,\n};\nmodule_platform_driver(plldig_clk_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Wen He <wen.he_1@nxp.com>\");\nMODULE_DESCRIPTION(\"LS1028A Display output interface pixel clock driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}