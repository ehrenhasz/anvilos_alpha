{
  "module_name": "clk-fixed-rate.c",
  "hash_id": "42a0df0b2aa3412cc01e8ef6a18a6781c435b67827dff5cb173ef1a42b528175",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-fixed-rate.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n \n\n#define to_clk_fixed_rate(_hw) container_of(_hw, struct clk_fixed_rate, hw)\n\nstatic unsigned long clk_fixed_rate_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\treturn to_clk_fixed_rate(hw)->fixed_rate;\n}\n\nstatic unsigned long clk_fixed_rate_recalc_accuracy(struct clk_hw *hw,\n\t\tunsigned long parent_accuracy)\n{\n\tstruct clk_fixed_rate *fixed = to_clk_fixed_rate(hw);\n\n\tif (fixed->flags & CLK_FIXED_RATE_PARENT_ACCURACY)\n\t\treturn parent_accuracy;\n\n\treturn fixed->fixed_accuracy;\n}\n\nconst struct clk_ops clk_fixed_rate_ops = {\n\t.recalc_rate = clk_fixed_rate_recalc_rate,\n\t.recalc_accuracy = clk_fixed_rate_recalc_accuracy,\n};\nEXPORT_SYMBOL_GPL(clk_fixed_rate_ops);\n\nstatic void devm_clk_hw_register_fixed_rate_release(struct device *dev, void *res)\n{\n\tstruct clk_fixed_rate *fix = res;\n\n\t \n\tclk_hw_unregister(&fix->hw);\n}\n\nstruct clk_hw *__clk_hw_register_fixed_rate(struct device *dev,\n\t\tstruct device_node *np, const char *name,\n\t\tconst char *parent_name, const struct clk_hw *parent_hw,\n\t\tconst struct clk_parent_data *parent_data, unsigned long flags,\n\t\tunsigned long fixed_rate, unsigned long fixed_accuracy,\n\t\tunsigned long clk_fixed_flags, bool devm)\n{\n\tstruct clk_fixed_rate *fixed;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tint ret = -EINVAL;\n\n\t \n\tif (devm)\n\t\tfixed = devres_alloc(devm_clk_hw_register_fixed_rate_release,\n\t\t\t\t     sizeof(*fixed), GFP_KERNEL);\n\telse\n\t\tfixed = kzalloc(sizeof(*fixed), GFP_KERNEL);\n\tif (!fixed)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &clk_fixed_rate_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.parent_hws = parent_hw ? &parent_hw : NULL;\n\tinit.parent_data = parent_data;\n\tif (parent_name || parent_hw || parent_data)\n\t\tinit.num_parents = 1;\n\telse\n\t\tinit.num_parents = 0;\n\n\t \n\tfixed->flags = clk_fixed_flags;\n\tfixed->fixed_rate = fixed_rate;\n\tfixed->fixed_accuracy = fixed_accuracy;\n\tfixed->hw.init = &init;\n\n\t \n\thw = &fixed->hw;\n\tif (dev || !np)\n\t\tret = clk_hw_register(dev, hw);\n\telse\n\t\tret = of_clk_hw_register(np, hw);\n\tif (ret) {\n\t\tif (devm)\n\t\t\tdevres_free(fixed);\n\t\telse\n\t\t\tkfree(fixed);\n\t\thw = ERR_PTR(ret);\n\t} else if (devm)\n\t\tdevres_add(dev, fixed);\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(__clk_hw_register_fixed_rate);\n\nstruct clk *clk_register_fixed_rate(struct device *dev, const char *name,\n\t\tconst char *parent_name, unsigned long flags,\n\t\tunsigned long fixed_rate)\n{\n\tstruct clk_hw *hw;\n\n\thw = clk_hw_register_fixed_rate_with_accuracy(dev, name, parent_name,\n\t\t\t\t\t\t      flags, fixed_rate, 0);\n\tif (IS_ERR(hw))\n\t\treturn ERR_CAST(hw);\n\treturn hw->clk;\n}\nEXPORT_SYMBOL_GPL(clk_register_fixed_rate);\n\nvoid clk_unregister_fixed_rate(struct clk *clk)\n{\n\tstruct clk_hw *hw;\n\n\thw = __clk_get_hw(clk);\n\tif (!hw)\n\t\treturn;\n\n\tclk_unregister(clk);\n\tkfree(to_clk_fixed_rate(hw));\n}\nEXPORT_SYMBOL_GPL(clk_unregister_fixed_rate);\n\nvoid clk_hw_unregister_fixed_rate(struct clk_hw *hw)\n{\n\tstruct clk_fixed_rate *fixed;\n\n\tfixed = to_clk_fixed_rate(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(fixed);\n}\nEXPORT_SYMBOL_GPL(clk_hw_unregister_fixed_rate);\n\n#ifdef CONFIG_OF\nstatic struct clk_hw *_of_fixed_clk_setup(struct device_node *node)\n{\n\tstruct clk_hw *hw;\n\tconst char *clk_name = node->name;\n\tu32 rate;\n\tu32 accuracy = 0;\n\tint ret;\n\n\tif (of_property_read_u32(node, \"clock-frequency\", &rate))\n\t\treturn ERR_PTR(-EIO);\n\n\tof_property_read_u32(node, \"clock-accuracy\", &accuracy);\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\n\thw = clk_hw_register_fixed_rate_with_accuracy(NULL, clk_name, NULL,\n\t\t\t\t\t\t    0, rate, accuracy);\n\tif (IS_ERR(hw))\n\t\treturn hw;\n\n\tret = of_clk_add_hw_provider(node, of_clk_hw_simple_get, hw);\n\tif (ret) {\n\t\tclk_hw_unregister_fixed_rate(hw);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\n \nvoid __init of_fixed_clk_setup(struct device_node *node)\n{\n\t_of_fixed_clk_setup(node);\n}\nCLK_OF_DECLARE(fixed_clk, \"fixed-clock\", of_fixed_clk_setup);\n\nstatic void of_fixed_clk_remove(struct platform_device *pdev)\n{\n\tstruct clk_hw *hw = platform_get_drvdata(pdev);\n\n\tof_clk_del_provider(pdev->dev.of_node);\n\tclk_hw_unregister_fixed_rate(hw);\n}\n\nstatic int of_fixed_clk_probe(struct platform_device *pdev)\n{\n\tstruct clk_hw *hw;\n\n\t \n\thw = _of_fixed_clk_setup(pdev->dev.of_node);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\n\tplatform_set_drvdata(pdev, hw);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_fixed_clk_ids[] = {\n\t{ .compatible = \"fixed-clock\" },\n\t{ }\n};\n\nstatic struct platform_driver of_fixed_clk_driver = {\n\t.driver = {\n\t\t.name = \"of_fixed_clk\",\n\t\t.of_match_table = of_fixed_clk_ids,\n\t},\n\t.probe = of_fixed_clk_probe,\n\t.remove_new = of_fixed_clk_remove,\n};\nbuiltin_platform_driver(of_fixed_clk_driver);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}