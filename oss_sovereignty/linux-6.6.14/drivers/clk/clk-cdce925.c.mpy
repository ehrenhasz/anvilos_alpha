{
  "module_name": "clk-cdce925.c",
  "hash_id": "803b350b1073eef1d41c983cc0f60900bb9d18f238398614a04c948a01cd4b6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-cdce925.c",
  "human_readable_source": " \n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/gcd.h>\n\n \n\nenum {\n\tCDCE913,\n\tCDCE925,\n\tCDCE937,\n\tCDCE949,\n};\n\nstruct clk_cdce925_chip_info {\n\tint num_plls;\n\tint num_outputs;\n};\n\nstatic const struct clk_cdce925_chip_info clk_cdce925_chip_info_tbl[] = {\n\t[CDCE913] = { .num_plls = 1, .num_outputs = 3 },\n\t[CDCE925] = { .num_plls = 2, .num_outputs = 5 },\n\t[CDCE937] = { .num_plls = 3, .num_outputs = 7 },\n\t[CDCE949] = { .num_plls = 4, .num_outputs = 9 },\n};\n\n#define MAX_NUMBER_OF_PLLS\t4\n#define MAX_NUMBER_OF_OUTPUTS\t9\n\n#define CDCE925_REG_GLOBAL1\t0x01\n#define CDCE925_REG_Y1SPIPDIVH\t0x02\n#define CDCE925_REG_PDIVL\t0x03\n#define CDCE925_REG_XCSEL\t0x05\n \n#define CDCE925_OFFSET_PLL\t0x10\n \n#define CDCE925_PLL_MUX_OUTPUTS\t0x14\n#define CDCE925_PLL_MULDIV\t0x18\n\n#define CDCE925_PLL_FREQUENCY_MIN\t 80000000ul\n#define CDCE925_PLL_FREQUENCY_MAX\t230000000ul\nstruct clk_cdce925_chip;\n\nstruct clk_cdce925_output {\n\tstruct clk_hw hw;\n\tstruct clk_cdce925_chip *chip;\n\tu8 index;\n\tu16 pdiv;  \n};\n#define to_clk_cdce925_output(_hw) \\\n\tcontainer_of(_hw, struct clk_cdce925_output, hw)\n\nstruct clk_cdce925_pll {\n\tstruct clk_hw hw;\n\tstruct clk_cdce925_chip *chip;\n\tu8 index;\n\tu16 m;    \n\tu16 n;    \n};\n#define to_clk_cdce925_pll(_hw)\tcontainer_of(_hw, struct clk_cdce925_pll, hw)\n\nstruct clk_cdce925_chip {\n\tstruct regmap *regmap;\n\tstruct i2c_client *i2c_client;\n\tconst struct clk_cdce925_chip_info *chip_info;\n\tstruct clk_cdce925_pll pll[MAX_NUMBER_OF_PLLS];\n\tstruct clk_cdce925_output clk[MAX_NUMBER_OF_OUTPUTS];\n};\n\n \n\nstatic unsigned long cdce925_pll_calculate_rate(unsigned long parent_rate,\n\tu16 n, u16 m)\n{\n\tif ((!m || !n) || (m == n))\n\t\treturn parent_rate;  \n\treturn mult_frac(parent_rate, (unsigned long)n, (unsigned long)m);\n}\n\nstatic unsigned long cdce925_pll_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\t \n\tstruct clk_cdce925_pll *data = to_clk_cdce925_pll(hw);\n\n\treturn cdce925_pll_calculate_rate(parent_rate, data->n, data->m);\n}\n\nstatic void cdce925_pll_find_rate(unsigned long rate,\n\t\tunsigned long parent_rate, u16 *n, u16 *m)\n{\n\tunsigned long un;\n\tunsigned long um;\n\tunsigned long g;\n\n\tif (rate <= parent_rate) {\n\t\t \n\t\trate = parent_rate;\n\t\t*n = 0;\n\t\t*m = 0;\n\t} else {\n\t\t \n\t\tif (rate < CDCE925_PLL_FREQUENCY_MIN)\n\t\t\trate = CDCE925_PLL_FREQUENCY_MIN;\n\t\telse if (rate > CDCE925_PLL_FREQUENCY_MAX)\n\t\t\trate = CDCE925_PLL_FREQUENCY_MAX;\n\n\t\tg = gcd(rate, parent_rate);\n\t\tum = parent_rate / g;\n\t\tun = rate / g;\n\t\t \n\t\twhile ((un > 4095) || (um > 511)) {\n\t\t\tun >>= 1;\n\t\t\tum >>= 1;\n\t\t}\n\t\tif (un == 0)\n\t\t\tun = 1;\n\t\tif (um == 0)\n\t\t\tum = 1;\n\n\t\t*n = un;\n\t\t*m = um;\n\t}\n}\n\nstatic long cdce925_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long *parent_rate)\n{\n\tu16 n, m;\n\n\tcdce925_pll_find_rate(rate, *parent_rate, &n, &m);\n\treturn (long)cdce925_pll_calculate_rate(*parent_rate, n, m);\n}\n\nstatic int cdce925_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_cdce925_pll *data = to_clk_cdce925_pll(hw);\n\n\tif (!rate || (rate == parent_rate)) {\n\t\tdata->m = 0;  \n\t\tdata->n = 0;\n\t\treturn 0;\n\t}\n\n\tif ((rate < CDCE925_PLL_FREQUENCY_MIN) ||\n\t\t(rate > CDCE925_PLL_FREQUENCY_MAX)) {\n\t\tpr_debug(\"%s: rate %lu outside PLL range.\\n\", __func__, rate);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rate < parent_rate) {\n\t\tpr_debug(\"%s: rate %lu less than parent rate %lu.\\n\", __func__,\n\t\t\trate, parent_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tcdce925_pll_find_rate(rate, parent_rate, &data->n, &data->m);\n\treturn 0;\n}\n\n\n \nstatic u8 cdce925_pll_calc_p(u16 n, u16 m)\n{\n\tu8 p;\n\tu16 r = n / m;\n\n\tif (r >= 16)\n\t\treturn 0;\n\tp = 4;\n\twhile (r > 1) {\n\t\tr >>= 1;\n\t\t--p;\n\t}\n\treturn p;\n}\n\n \nstatic u8 cdce925_pll_calc_range_bits(struct clk_hw *hw, u16 n, u16 m)\n{\n\tstruct clk *parent = clk_get_parent(hw->clk);\n\tunsigned long rate = clk_get_rate(parent);\n\n\trate = mult_frac(rate, (unsigned long)n, (unsigned long)m);\n\tif (rate >= 175000000)\n\t\treturn 0x3;\n\tif (rate >= 150000000)\n\t\treturn 0x02;\n\tif (rate >= 125000000)\n\t\treturn 0x01;\n\treturn 0x00;\n}\n\n \nstatic int cdce925_pll_prepare(struct clk_hw *hw)\n{\n\tstruct clk_cdce925_pll *data = to_clk_cdce925_pll(hw);\n\tu16 n = data->n;\n\tu16 m = data->m;\n\tu16 r;\n\tu8 q;\n\tu8 p;\n\tu16 nn;\n\tu8 pll[4];  \n\tu8 reg_ofs = data->index * CDCE925_OFFSET_PLL;\n\tunsigned i;\n\n\tif ((!m || !n) || (m == n)) {\n\t\t \n\t\tregmap_update_bits(data->chip->regmap,\n\t\t\treg_ofs + CDCE925_PLL_MUX_OUTPUTS, 0x80, 0x80);\n\t} else {\n\t\t \n\t\t \n\t\tp = cdce925_pll_calc_p(n, m);\n\t\t \n\t\tnn = n * BIT(p);\n\t\t \n\t\tq = nn / m;\n\t\tif ((q < 16) || (q > 63)) {\n\t\t\tpr_debug(\"%s invalid q=%d\\n\", __func__, q);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = nn - (m*q);\n\t\tif (r > 511) {\n\t\t\tpr_debug(\"%s invalid r=%d\\n\", __func__, r);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpr_debug(\"%s n=%d m=%d p=%d q=%d r=%d\\n\", __func__,\n\t\t\tn, m, p, q, r);\n\t\t \n\t\tpll[0] = n >> 4;\n\t\tpll[1] = ((n & 0x0F) << 4) | ((r >> 5) & 0x0F);\n\t\tpll[2] = ((r & 0x1F) << 3) | ((q >> 3) & 0x07);\n\t\tpll[3] = ((q & 0x07) << 5) | (p << 2) |\n\t\t\t\tcdce925_pll_calc_range_bits(hw, n, m);\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(pll); ++i)\n\t\t\tregmap_write(data->chip->regmap,\n\t\t\t\treg_ofs + CDCE925_PLL_MULDIV + i, pll[i]);\n\t\t \n\t\tregmap_update_bits(data->chip->regmap,\n\t\t\treg_ofs + CDCE925_PLL_MUX_OUTPUTS, 0x80, 0x00);\n\t}\n\n\treturn 0;\n}\n\nstatic void cdce925_pll_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_cdce925_pll *data = to_clk_cdce925_pll(hw);\n\tu8 reg_ofs = data->index * CDCE925_OFFSET_PLL;\n\n\tregmap_update_bits(data->chip->regmap,\n\t\t\treg_ofs + CDCE925_PLL_MUX_OUTPUTS, 0x80, 0x80);\n}\n\nstatic const struct clk_ops cdce925_pll_ops = {\n\t.prepare = cdce925_pll_prepare,\n\t.unprepare = cdce925_pll_unprepare,\n\t.recalc_rate = cdce925_pll_recalc_rate,\n\t.round_rate = cdce925_pll_round_rate,\n\t.set_rate = cdce925_pll_set_rate,\n};\n\n\nstatic void cdce925_clk_set_pdiv(struct clk_cdce925_output *data, u16 pdiv)\n{\n\tswitch (data->index) {\n\tcase 0:\n\t\tregmap_update_bits(data->chip->regmap,\n\t\t\tCDCE925_REG_Y1SPIPDIVH,\n\t\t\t0x03, (pdiv >> 8) & 0x03);\n\t\tregmap_write(data->chip->regmap, 0x03, pdiv & 0xFF);\n\t\tbreak;\n\tcase 1:\n\t\tregmap_update_bits(data->chip->regmap, 0x16, 0x7F, pdiv);\n\t\tbreak;\n\tcase 2:\n\t\tregmap_update_bits(data->chip->regmap, 0x17, 0x7F, pdiv);\n\t\tbreak;\n\tcase 3:\n\t\tregmap_update_bits(data->chip->regmap, 0x26, 0x7F, pdiv);\n\t\tbreak;\n\tcase 4:\n\t\tregmap_update_bits(data->chip->regmap, 0x27, 0x7F, pdiv);\n\t\tbreak;\n\tcase 5:\n\t\tregmap_update_bits(data->chip->regmap, 0x36, 0x7F, pdiv);\n\t\tbreak;\n\tcase 6:\n\t\tregmap_update_bits(data->chip->regmap, 0x37, 0x7F, pdiv);\n\t\tbreak;\n\tcase 7:\n\t\tregmap_update_bits(data->chip->regmap, 0x46, 0x7F, pdiv);\n\t\tbreak;\n\tcase 8:\n\t\tregmap_update_bits(data->chip->regmap, 0x47, 0x7F, pdiv);\n\t\tbreak;\n\t}\n}\n\nstatic void cdce925_clk_activate(struct clk_cdce925_output *data)\n{\n\tswitch (data->index) {\n\tcase 0:\n\t\tregmap_update_bits(data->chip->regmap,\n\t\t\tCDCE925_REG_Y1SPIPDIVH, 0x0c, 0x0c);\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\tregmap_update_bits(data->chip->regmap, 0x14, 0x03, 0x03);\n\t\tbreak;\n\tcase 3:\n\tcase 4:\n\t\tregmap_update_bits(data->chip->regmap, 0x24, 0x03, 0x03);\n\t\tbreak;\n\tcase 5:\n\tcase 6:\n\t\tregmap_update_bits(data->chip->regmap, 0x34, 0x03, 0x03);\n\t\tbreak;\n\tcase 7:\n\tcase 8:\n\t\tregmap_update_bits(data->chip->regmap, 0x44, 0x03, 0x03);\n\t\tbreak;\n\t}\n}\n\nstatic int cdce925_clk_prepare(struct clk_hw *hw)\n{\n\tstruct clk_cdce925_output *data = to_clk_cdce925_output(hw);\n\n\tcdce925_clk_set_pdiv(data, data->pdiv);\n\tcdce925_clk_activate(data);\n\treturn 0;\n}\n\nstatic void cdce925_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_cdce925_output *data = to_clk_cdce925_output(hw);\n\n\t \n\tcdce925_clk_set_pdiv(data, 0);\n}\n\nstatic unsigned long cdce925_clk_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_cdce925_output *data = to_clk_cdce925_output(hw);\n\n\tif (data->pdiv)\n\t\treturn parent_rate / data->pdiv;\n\treturn 0;\n}\n\nstatic u16 cdce925_calc_divider(unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tunsigned long divider;\n\n\tif (!rate)\n\t\treturn 0;\n\tif (rate >= parent_rate)\n\t\treturn 1;\n\n\tdivider = DIV_ROUND_CLOSEST(parent_rate, rate);\n\tif (divider > 0x7F)\n\t\tdivider = 0x7F;\n\n\treturn (u16)divider;\n}\n\nstatic unsigned long cdce925_clk_best_parent_rate(\n\tstruct clk_hw *hw, unsigned long rate)\n{\n\tstruct clk *pll = clk_get_parent(hw->clk);\n\tstruct clk *root = clk_get_parent(pll);\n\tunsigned long root_rate = clk_get_rate(root);\n\tunsigned long best_rate_error = rate;\n\tu16 pdiv_min;\n\tu16 pdiv_max;\n\tu16 pdiv_best;\n\tu16 pdiv_now;\n\n\tif (root_rate % rate == 0)\n\t\treturn root_rate;  \n\n\tpdiv_min = (u16)max(1ul, DIV_ROUND_UP(CDCE925_PLL_FREQUENCY_MIN, rate));\n\tpdiv_max = (u16)min(127ul, CDCE925_PLL_FREQUENCY_MAX / rate);\n\n\tif (pdiv_min > pdiv_max)\n\t\treturn 0;  \n\n\tpdiv_best = pdiv_min;\n\tfor (pdiv_now = pdiv_min; pdiv_now < pdiv_max; ++pdiv_now) {\n\t\tunsigned long target_rate = rate * pdiv_now;\n\t\tlong pll_rate = clk_round_rate(pll, target_rate);\n\t\tunsigned long actual_rate;\n\t\tunsigned long rate_error;\n\n\t\tif (pll_rate <= 0)\n\t\t\tcontinue;\n\t\tactual_rate = pll_rate / pdiv_now;\n\t\trate_error = abs((long)actual_rate - (long)rate);\n\t\tif (rate_error < best_rate_error) {\n\t\t\tpdiv_best = pdiv_now;\n\t\t\tbest_rate_error = rate_error;\n\t\t}\n\t\t \n\t}\n\n\treturn rate * pdiv_best;\n}\n\nstatic long cdce925_clk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long *parent_rate)\n{\n\tunsigned long l_parent_rate = *parent_rate;\n\tu16 divider = cdce925_calc_divider(rate, l_parent_rate);\n\n\tif (l_parent_rate / divider != rate) {\n\t\tl_parent_rate = cdce925_clk_best_parent_rate(hw, rate);\n\t\tdivider = cdce925_calc_divider(rate, l_parent_rate);\n\t\t*parent_rate = l_parent_rate;\n\t}\n\n\tif (divider)\n\t\treturn (long)(l_parent_rate / divider);\n\treturn 0;\n}\n\nstatic int cdce925_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_cdce925_output *data = to_clk_cdce925_output(hw);\n\n\tdata->pdiv = cdce925_calc_divider(rate, parent_rate);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops cdce925_clk_ops = {\n\t.prepare = cdce925_clk_prepare,\n\t.unprepare = cdce925_clk_unprepare,\n\t.recalc_rate = cdce925_clk_recalc_rate,\n\t.round_rate = cdce925_clk_round_rate,\n\t.set_rate = cdce925_clk_set_rate,\n};\n\n\nstatic u16 cdce925_y1_calc_divider(unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tunsigned long divider;\n\n\tif (!rate)\n\t\treturn 0;\n\tif (rate >= parent_rate)\n\t\treturn 1;\n\n\tdivider = DIV_ROUND_CLOSEST(parent_rate, rate);\n\tif (divider > 0x3FF)  \n\t\tdivider = 0x3FF;\n\n\treturn (u16)divider;\n}\n\nstatic long cdce925_clk_y1_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long *parent_rate)\n{\n\tunsigned long l_parent_rate = *parent_rate;\n\tu16 divider = cdce925_y1_calc_divider(rate, l_parent_rate);\n\n\tif (divider)\n\t\treturn (long)(l_parent_rate / divider);\n\treturn 0;\n}\n\nstatic int cdce925_clk_y1_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_cdce925_output *data = to_clk_cdce925_output(hw);\n\n\tdata->pdiv = cdce925_y1_calc_divider(rate, parent_rate);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops cdce925_clk_y1_ops = {\n\t.prepare = cdce925_clk_prepare,\n\t.unprepare = cdce925_clk_unprepare,\n\t.recalc_rate = cdce925_clk_recalc_rate,\n\t.round_rate = cdce925_clk_y1_round_rate,\n\t.set_rate = cdce925_clk_y1_set_rate,\n};\n\n#define CDCE925_I2C_COMMAND_BLOCK_TRANSFER\t0x00\n#define CDCE925_I2C_COMMAND_BYTE_TRANSFER\t0x80\n\nstatic int cdce925_regmap_i2c_write(\n\tvoid *context, const void *data, size_t count)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tint ret;\n\tu8 reg_data[2];\n\n\tif (count != 2)\n\t\treturn -ENOTSUPP;\n\n\t \n\treg_data[0] = CDCE925_I2C_COMMAND_BYTE_TRANSFER | ((u8 *)data)[0];\n\treg_data[1] = ((u8 *)data)[1];\n\n\tdev_dbg(&i2c->dev, \"%s(%zu) %#x %#x\\n\", __func__, count,\n\t\t\treg_data[0], reg_data[1]);\n\n\tret = i2c_master_send(i2c, reg_data, count);\n\tif (likely(ret == count))\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int cdce925_regmap_i2c_read(void *context,\n\t   const void *reg, size_t reg_size, void *val, size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct i2c_msg xfer[2];\n\tint ret;\n\tu8 reg_data[2];\n\n\tif (reg_size != 1)\n\t\treturn -ENOTSUPP;\n\n\txfer[0].addr = i2c->addr;\n\txfer[0].flags = 0;\n\txfer[0].buf = reg_data;\n\tif (val_size == 1) {\n\t\treg_data[0] =\n\t\t\tCDCE925_I2C_COMMAND_BYTE_TRANSFER | ((u8 *)reg)[0];\n\t\txfer[0].len = 1;\n\t} else {\n\t\treg_data[0] =\n\t\t\tCDCE925_I2C_COMMAND_BLOCK_TRANSFER | ((u8 *)reg)[0];\n\t\treg_data[1] = val_size;\n\t\txfer[0].len = 2;\n\t}\n\n\txfer[1].addr = i2c->addr;\n\txfer[1].flags = I2C_M_RD;\n\txfer[1].len = val_size;\n\txfer[1].buf = val;\n\n\tret = i2c_transfer(i2c->adapter, xfer, 2);\n\tif (likely(ret == 2)) {\n\t\tdev_dbg(&i2c->dev, \"%s(%zu, %zu) %#x %#x\\n\", __func__,\n\t\t\t\treg_size, val_size, reg_data[0], *((u8 *)val));\n\t\treturn 0;\n\t} else if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic struct clk_hw *\nof_clk_cdce925_get(struct of_phandle_args *clkspec, void *_data)\n{\n\tstruct clk_cdce925_chip *data = _data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= ARRAY_SIZE(data->clk)) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &data->clk[idx].hw;\n}\n\nstatic int cdce925_regulator_enable(struct device *dev, const char *name)\n{\n\tint err;\n\n\terr = devm_regulator_get_enable(dev, name);\n\tif (err)\n\t\tdev_err_probe(dev, err, \"Failed to enable %s:\\n\", name);\n\n\treturn err;\n}\n\n \nstatic struct regmap_bus regmap_cdce925_bus = {\n\t.write = cdce925_regmap_i2c_write,\n\t.read = cdce925_regmap_i2c_read,\n};\n\nstatic const struct i2c_device_id cdce925_id[] = {\n\t{ \"cdce913\", CDCE913 },\n\t{ \"cdce925\", CDCE925 },\n\t{ \"cdce937\", CDCE937 },\n\t{ \"cdce949\", CDCE949 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, cdce925_id);\n\nstatic int cdce925_probe(struct i2c_client *client)\n{\n\tstruct clk_cdce925_chip *data;\n\tstruct device_node *node = client->dev.of_node;\n\tconst struct i2c_device_id *id = i2c_match_id(cdce925_id, client);\n\tconst char *parent_name;\n\tconst char *pll_clk_name[MAX_NUMBER_OF_PLLS] = {NULL,};\n\tstruct clk_init_data init;\n\tu32 value;\n\tint i;\n\tint err;\n\tstruct device_node *np_output;\n\tchar child_name[6];\n\tstruct regmap_config config = {\n\t\t.name = \"configuration0\",\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.cache_type = REGCACHE_RBTREE,\n\t};\n\n\tdev_dbg(&client->dev, \"%s\\n\", __func__);\n\n\terr = cdce925_regulator_enable(&client->dev, \"vdd\");\n\tif (err)\n\t\treturn err;\n\n\terr = cdce925_regulator_enable(&client->dev, \"vddout\");\n\tif (err)\n\t\treturn err;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->i2c_client = client;\n\tdata->chip_info = &clk_cdce925_chip_info_tbl[id->driver_data];\n\tconfig.max_register = CDCE925_OFFSET_PLL +\n\t\tdata->chip_info->num_plls * 0x10 - 1;\n\tdata->regmap = devm_regmap_init(&client->dev, &regmap_cdce925_bus,\n\t\t\t&client->dev, &config);\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(&client->dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(data->regmap);\n\t}\n\ti2c_set_clientdata(client, data);\n\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tif (!parent_name) {\n\t\tdev_err(&client->dev, \"missing parent clock\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(&client->dev, \"parent is: %s\\n\", parent_name);\n\n\tif (of_property_read_u32(node, \"xtal-load-pf\", &value) == 0)\n\t\tregmap_write(data->regmap,\n\t\t\tCDCE925_REG_XCSEL, (value << 3) & 0xF8);\n\t \n\tregmap_update_bits(data->regmap, CDCE925_REG_GLOBAL1, BIT(4), 0);\n\n\t \n\tregmap_update_bits(data->regmap, 0x02, BIT(7), 0);\n\n\tinit.ops = &cdce925_pll_ops;\n\tinit.flags = 0;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\t \n\tfor (i = 0; i < data->chip_info->num_plls; ++i) {\n\t\tpll_clk_name[i] = kasprintf(GFP_KERNEL, \"%pOFn.pll%d\",\n\t\t\tclient->dev.of_node, i);\n\t\tif (!pll_clk_name[i]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tinit.name = pll_clk_name[i];\n\t\tdata->pll[i].chip = data;\n\t\tdata->pll[i].hw.init = &init;\n\t\tdata->pll[i].index = i;\n\t\terr = devm_clk_hw_register(&client->dev, &data->pll[i].hw);\n\t\tif (err) {\n\t\t\tdev_err(&client->dev, \"Failed register PLL %d\\n\", i);\n\t\t\tgoto error;\n\t\t}\n\t\tsprintf(child_name, \"PLL%d\", i+1);\n\t\tnp_output = of_get_child_by_name(node, child_name);\n\t\tif (!np_output)\n\t\t\tcontinue;\n\t\tif (!of_property_read_u32(np_output,\n\t\t\t\"clock-frequency\", &value)) {\n\t\t\terr = clk_set_rate(data->pll[i].hw.clk, value);\n\t\t\tif (err)\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"unable to set PLL frequency %ud\\n\",\n\t\t\t\t\tvalue);\n\t\t}\n\t\tif (!of_property_read_u32(np_output,\n\t\t\t\"spread-spectrum\", &value)) {\n\t\t\tu8 flag = of_property_read_bool(np_output,\n\t\t\t\t\"spread-spectrum-center\") ? 0x80 : 0x00;\n\t\t\tregmap_update_bits(data->regmap,\n\t\t\t\t0x16 + (i*CDCE925_OFFSET_PLL),\n\t\t\t\t0x80, flag);\n\t\t\tregmap_update_bits(data->regmap,\n\t\t\t\t0x12 + (i*CDCE925_OFFSET_PLL),\n\t\t\t\t0x07, value & 0x07);\n\t\t}\n\t\tof_node_put(np_output);\n\t}\n\n\t \n\tinit.ops = &cdce925_clk_y1_ops;\n\tinit.flags = 0;\n\tinit.num_parents = 1;\n\tinit.parent_names = &parent_name;  \n\tinit.name = kasprintf(GFP_KERNEL, \"%pOFn.Y1\", client->dev.of_node);\n\tif (!init.name) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tdata->clk[0].chip = data;\n\tdata->clk[0].hw.init = &init;\n\tdata->clk[0].index = 0;\n\tdata->clk[0].pdiv = 1;\n\terr = devm_clk_hw_register(&client->dev, &data->clk[0].hw);\n\tkfree(init.name);  \n\tif (err) {\n\t\tdev_err(&client->dev, \"clock registration Y1 failed\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tinit.ops = &cdce925_clk_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.num_parents = 1;\n\tfor (i = 1; i < data->chip_info->num_outputs; ++i) {\n\t\tinit.name = kasprintf(GFP_KERNEL, \"%pOFn.Y%d\",\n\t\t\tclient->dev.of_node, i+1);\n\t\tif (!init.name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tdata->clk[i].chip = data;\n\t\tdata->clk[i].hw.init = &init;\n\t\tdata->clk[i].index = i;\n\t\tdata->clk[i].pdiv = 1;\n\t\tswitch (i) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\t \n\t\t\tinit.parent_names = &pll_clk_name[0];\n\t\t\tbreak;\n\t\tcase 3:\n\t\tcase 4:\n\t\t\t \n\t\t\tinit.parent_names = &pll_clk_name[1];\n\t\t\tbreak;\n\t\tcase 5:\n\t\tcase 6:\n\t\t\t \n\t\t\tinit.parent_names = &pll_clk_name[2];\n\t\t\tbreak;\n\t\tcase 7:\n\t\tcase 8:\n\t\t\t \n\t\t\tinit.parent_names = &pll_clk_name[3];\n\t\t\tbreak;\n\t\t}\n\t\terr = devm_clk_hw_register(&client->dev, &data->clk[i].hw);\n\t\tkfree(init.name);  \n\t\tif (err) {\n\t\t\tdev_err(&client->dev, \"clock registration failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\terr = of_clk_add_hw_provider(client->dev.of_node, of_clk_cdce925_get,\n\t\t\t\t  data);\n\tif (err)\n\t\tdev_err(&client->dev, \"unable to add OF clock provider\\n\");\n\n\terr = 0;\n\nerror:\n\tfor (i = 0; i < data->chip_info->num_plls; ++i)\n\t\t \n\t\tkfree(pll_clk_name[i]);\n\n\treturn err;\n}\n\nstatic const struct of_device_id clk_cdce925_of_match[] = {\n\t{ .compatible = \"ti,cdce913\" },\n\t{ .compatible = \"ti,cdce925\" },\n\t{ .compatible = \"ti,cdce937\" },\n\t{ .compatible = \"ti,cdce949\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, clk_cdce925_of_match);\n\nstatic struct i2c_driver cdce925_driver = {\n\t.driver = {\n\t\t.name = \"cdce925\",\n\t\t.of_match_table = clk_cdce925_of_match,\n\t},\n\t.probe\t\t= cdce925_probe,\n\t.id_table\t= cdce925_id,\n};\nmodule_i2c_driver(cdce925_driver);\n\nMODULE_AUTHOR(\"Mike Looijmans <mike.looijmans@topic.nl>\");\nMODULE_DESCRIPTION(\"TI CDCE913/925/937/949 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}