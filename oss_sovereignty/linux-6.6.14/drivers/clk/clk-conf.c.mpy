{
  "module_name": "clk-conf.c",
  "hash_id": "9201d2e0890c488226e3b9d95fe688b7d8047b04e79fc3019cb569fa956038ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-conf.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clk/clk-conf.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/printk.h>\n\nstatic int __set_clk_parents(struct device_node *node, bool clk_supplier)\n{\n\tstruct of_phandle_args clkspec;\n\tint index, rc, num_parents;\n\tstruct clk *clk, *pclk;\n\n\tnum_parents = of_count_phandle_with_args(node, \"assigned-clock-parents\",\n\t\t\t\t\t\t \"#clock-cells\");\n\tif (num_parents == -EINVAL)\n\t\tpr_err(\"clk: invalid value of clock-parents property at %pOF\\n\",\n\t\t       node);\n\n\tfor (index = 0; index < num_parents; index++) {\n\t\trc = of_parse_phandle_with_args(node, \"assigned-clock-parents\",\n\t\t\t\t\t\"#clock-cells\",\tindex, &clkspec);\n\t\tif (rc < 0) {\n\t\t\t \n\t\t\tif (rc == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn rc;\n\t\t}\n\t\tif (clkspec.np == node && !clk_supplier) {\n\t\t\tof_node_put(clkspec.np);\n\t\t\treturn 0;\n\t\t}\n\t\tpclk = of_clk_get_from_provider(&clkspec);\n\t\tof_node_put(clkspec.np);\n\t\tif (IS_ERR(pclk)) {\n\t\t\tif (PTR_ERR(pclk) != -EPROBE_DEFER)\n\t\t\t\tpr_warn(\"clk: couldn't get parent clock %d for %pOF\\n\",\n\t\t\t\t\tindex, node);\n\t\t\treturn PTR_ERR(pclk);\n\t\t}\n\n\t\trc = of_parse_phandle_with_args(node, \"assigned-clocks\",\n\t\t\t\t\t\"#clock-cells\", index, &clkspec);\n\t\tif (rc < 0)\n\t\t\tgoto err;\n\t\tif (clkspec.np == node && !clk_supplier) {\n\t\t\tof_node_put(clkspec.np);\n\t\t\trc = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tclk = of_clk_get_from_provider(&clkspec);\n\t\tof_node_put(clkspec.np);\n\t\tif (IS_ERR(clk)) {\n\t\t\tif (PTR_ERR(clk) != -EPROBE_DEFER)\n\t\t\t\tpr_warn(\"clk: couldn't get assigned clock %d for %pOF\\n\",\n\t\t\t\t\tindex, node);\n\t\t\trc = PTR_ERR(clk);\n\t\t\tgoto err;\n\t\t}\n\n\t\trc = clk_set_parent(clk, pclk);\n\t\tif (rc < 0)\n\t\t\tpr_err(\"clk: failed to reparent %s to %s: %d\\n\",\n\t\t\t       __clk_get_name(clk), __clk_get_name(pclk), rc);\n\t\tclk_put(clk);\n\t\tclk_put(pclk);\n\t}\n\treturn 0;\nerr:\n\tclk_put(pclk);\n\treturn rc;\n}\n\nstatic int __set_clk_rates(struct device_node *node, bool clk_supplier)\n{\n\tstruct of_phandle_args clkspec;\n\tstruct property\t*prop;\n\tconst __be32 *cur;\n\tint rc, index = 0;\n\tstruct clk *clk;\n\tu32 rate;\n\n\tof_property_for_each_u32(node, \"assigned-clock-rates\", prop, cur, rate) {\n\t\tif (rate) {\n\t\t\trc = of_parse_phandle_with_args(node, \"assigned-clocks\",\n\t\t\t\t\t\"#clock-cells\",\tindex, &clkspec);\n\t\t\tif (rc < 0) {\n\t\t\t\t \n\t\t\t\tif (rc == -ENOENT)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tif (clkspec.np == node && !clk_supplier) {\n\t\t\t\tof_node_put(clkspec.np);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tclk = of_clk_get_from_provider(&clkspec);\n\t\t\tof_node_put(clkspec.np);\n\t\t\tif (IS_ERR(clk)) {\n\t\t\t\tif (PTR_ERR(clk) != -EPROBE_DEFER)\n\t\t\t\t\tpr_warn(\"clk: couldn't get clock %d for %pOF\\n\",\n\t\t\t\t\t\tindex, node);\n\t\t\t\treturn PTR_ERR(clk);\n\t\t\t}\n\n\t\t\trc = clk_set_rate(clk, rate);\n\t\t\tif (rc < 0)\n\t\t\t\tpr_err(\"clk: couldn't set %s clk rate to %u (%d), current rate: %lu\\n\",\n\t\t\t\t       __clk_get_name(clk), rate, rc,\n\t\t\t\t       clk_get_rate(clk));\n\t\t\tclk_put(clk);\n\t\t}\n\t\tindex++;\n\t}\n\treturn 0;\n}\n\n \nint of_clk_set_defaults(struct device_node *node, bool clk_supplier)\n{\n\tint rc;\n\n\tif (!node)\n\t\treturn 0;\n\n\trc = __set_clk_parents(node, clk_supplier);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn __set_clk_rates(node, clk_supplier);\n}\nEXPORT_SYMBOL_GPL(of_clk_set_defaults);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}