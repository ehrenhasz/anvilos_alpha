{
  "module_name": "clk-si521xx.c",
  "hash_id": "f67e4c27f1154210388de73c03062232dd655b78073c0edcb5865f71fce1a75a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-si521xx.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitrev.h>\n#include <linux/clk-provider.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n \n#define SI521XX_REG_OE(n)\t\t\t(((n) & 0x1) + 1)\n#define SI521XX_REG_ID\t\t\t\t0x3\n#define SI521XX_REG_ID_PROG\t\t\tGENMASK(7, 4)\n#define SI521XX_REG_ID_VENDOR\t\t\tGENMASK(3, 0)\n#define SI521XX_REG_BC\t\t\t\t0x4\n#define SI521XX_REG_DA\t\t\t\t0x5\n#define SI521XX_REG_DA_AMP_SEL\t\t\tBIT(7)\n#define SI521XX_REG_DA_AMP_MASK\t\t\tGENMASK(6, 4)\n#define SI521XX_REG_DA_AMP_MIN\t\t\t300000\n#define SI521XX_REG_DA_AMP_DEFAULT\t\t800000\n#define SI521XX_REG_DA_AMP_MAX\t\t\t1000000\n#define SI521XX_REG_DA_AMP_STEP\t\t\t100000\n#define SI521XX_REG_DA_AMP(UV)\t\t\t\\\n\tFIELD_PREP(SI521XX_REG_DA_AMP_MASK,\t\\\n\t\t   ((UV) - SI521XX_REG_DA_AMP_MIN) / SI521XX_REG_DA_AMP_STEP)\n#define SI521XX_REG_DA_UNKNOWN\t\t\tBIT(3)\t \n\n \n#define SI521XX_OE_MAP(cr1, cr2)\t(((cr2) << 8) | (cr1))\n#define SI521XX_OE_MAP_GET_OE(oe, map)\t(((map) >> (((oe) - 1) * 8)) & 0xff)\n\n#define SI521XX_DIFF_MULT\t4\n#define SI521XX_DIFF_DIV\t1\n\n \nenum si521xx_model {\n\tSI52144 = 0x44,\n\tSI52146 = 0x46,\n\tSI52147 = 0x47,\n};\n\nstruct si521xx;\n\nstruct si_clk {\n\tstruct clk_hw\t\thw;\n\tstruct si521xx\t\t*si;\n\tu8\t\t\treg;\n\tu8\t\t\tbit;\n};\n\nstruct si521xx {\n\tstruct i2c_client\t*client;\n\tstruct regmap\t\t*regmap;\n\tstruct si_clk\t\tclk_dif[9];\n\tu16\t\t\tchip_info;\n\tu8\t\t\tpll_amplitude;\n};\n\n \nstatic const struct regmap_range si521xx_readable_ranges[] = {\n\tregmap_reg_range(SI521XX_REG_OE(0), SI521XX_REG_DA),\n};\n\nstatic const struct regmap_access_table si521xx_readable_table = {\n\t.yes_ranges = si521xx_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(si521xx_readable_ranges),\n};\n\nstatic const struct regmap_range si521xx_writeable_ranges[] = {\n\tregmap_reg_range(SI521XX_REG_OE(0), SI521XX_REG_OE(1)),\n\tregmap_reg_range(SI521XX_REG_BC, SI521XX_REG_DA),\n};\n\nstatic const struct regmap_access_table si521xx_writeable_table = {\n\t.yes_ranges = si521xx_writeable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(si521xx_writeable_ranges),\n};\n\nstatic int si521xx_regmap_i2c_write(void *context, unsigned int reg,\n\t\t\t\t    unsigned int val)\n{\n\tstruct i2c_client *i2c = context;\n\tconst u8 data[2] = { reg, val };\n\tconst int count = ARRAY_SIZE(data);\n\tint ret;\n\n\tret = i2c_master_send(i2c, data, count);\n\tif (ret == count)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int si521xx_regmap_i2c_read(void *context, unsigned int reg,\n\t\t\t\t   unsigned int *val)\n{\n\tstruct i2c_client *i2c = context;\n\tstruct i2c_msg xfer[2];\n\tu8 txdata = reg;\n\tu8 rxdata[2];\n\tint ret;\n\n\txfer[0].addr = i2c->addr;\n\txfer[0].flags = 0;\n\txfer[0].len = 1;\n\txfer[0].buf = (void *)&txdata;\n\n\txfer[1].addr = i2c->addr;\n\txfer[1].flags = I2C_M_RD;\n\txfer[1].len = 2;\n\txfer[1].buf = (void *)rxdata;\n\n\tret = i2c_transfer(i2c->adapter, xfer, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != 2)\n\t\treturn -EIO;\n\n\t \n\t*val = rxdata[1];\n\treturn 0;\n}\n\nstatic const struct regmap_config si521xx_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_FLAT,\n\t.max_register = SI521XX_REG_DA,\n\t.rd_table = &si521xx_readable_table,\n\t.wr_table = &si521xx_writeable_table,\n\t.reg_write = si521xx_regmap_i2c_write,\n\t.reg_read = si521xx_regmap_i2c_read,\n};\n\nstatic unsigned long si521xx_diff_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\tunsigned long long rate;\n\n\trate = (unsigned long long)parent_rate * SI521XX_DIFF_MULT;\n\tdo_div(rate, SI521XX_DIFF_DIV);\n\treturn (unsigned long)rate;\n}\n\nstatic long si521xx_diff_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *prate)\n{\n\tunsigned long best_parent;\n\n\tbest_parent = (rate / SI521XX_DIFF_MULT) * SI521XX_DIFF_DIV;\n\t*prate = clk_hw_round_rate(clk_hw_get_parent(hw), best_parent);\n\n\treturn (*prate / SI521XX_DIFF_DIV) * SI521XX_DIFF_MULT;\n}\n\nstatic int si521xx_diff_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long parent_rate)\n{\n\t \n\n\treturn 0;\n}\n\n#define to_si521xx_clk(_hw) container_of(_hw, struct si_clk, hw)\n\nstatic int si521xx_diff_prepare(struct clk_hw *hw)\n{\n\tstruct si_clk *si_clk = to_si521xx_clk(hw);\n\tstruct si521xx *si = si_clk->si;\n\n\tregmap_set_bits(si->regmap, SI521XX_REG_OE(si_clk->reg), si_clk->bit);\n\n\treturn 0;\n}\n\nstatic void si521xx_diff_unprepare(struct clk_hw *hw)\n{\n\tstruct si_clk *si_clk = to_si521xx_clk(hw);\n\tstruct si521xx *si = si_clk->si;\n\n\tregmap_clear_bits(si->regmap, SI521XX_REG_OE(si_clk->reg), si_clk->bit);\n}\n\nstatic const struct clk_ops si521xx_diff_clk_ops = {\n\t.round_rate\t= si521xx_diff_round_rate,\n\t.set_rate\t= si521xx_diff_set_rate,\n\t.recalc_rate\t= si521xx_diff_recalc_rate,\n\t.prepare\t= si521xx_diff_prepare,\n\t.unprepare\t= si521xx_diff_unprepare,\n};\n\nstatic int si521xx_get_common_config(struct si521xx *si)\n{\n\tstruct i2c_client *client = si->client;\n\tstruct device_node *np = client->dev.of_node;\n\tunsigned int amp;\n\tint ret;\n\n\t \n\tsi->pll_amplitude = SI521XX_REG_DA_AMP(SI521XX_REG_DA_AMP_DEFAULT);\n\n\t \n\tret = of_property_read_u32(np, \"skyworks,out-amplitude-microvolt\",\n\t\t\t\t   &amp);\n\tif (!ret) {\n\t\tif (amp < SI521XX_REG_DA_AMP_MIN || amp > SI521XX_REG_DA_AMP_MAX ||\n\t\t    amp % SI521XX_REG_DA_AMP_STEP) {\n\t\t\treturn dev_err_probe(&client->dev, -EINVAL,\n\t\t\t\t\t     \"Invalid skyworks,out-amplitude-microvolt value\\n\");\n\t\t}\n\t\tsi->pll_amplitude = SI521XX_REG_DA_AMP(amp);\n\t}\n\n\treturn 0;\n}\n\nstatic void si521xx_update_config(struct si521xx *si)\n{\n\t \n\tif (si->pll_amplitude == SI521XX_REG_DA_AMP(SI521XX_REG_DA_AMP_DEFAULT))\n\t\treturn;\n\n\tregmap_update_bits(si->regmap, SI521XX_REG_DA,\n\t\t\t   SI521XX_REG_DA_AMP_MASK, si->pll_amplitude);\n}\n\nstatic void si521xx_diff_idx_to_reg_bit(const u16 chip_info, const int idx,\n\t\t\t\t\tstruct si_clk *clk)\n{\n\tunsigned long mask;\n\tint oe, b, ctr = 0;\n\n\tfor (oe = 1; oe <= 2; oe++) {\n\t\tmask = bitrev8(SI521XX_OE_MAP_GET_OE(oe, chip_info));\n\t\tfor_each_set_bit(b, &mask, 8) {\n\t\t\tif (ctr++ != idx)\n\t\t\t\tcontinue;\n\t\t\tclk->reg = SI521XX_REG_OE(oe);\n\t\t\tclk->bit = 7 - b;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic struct clk_hw *\nsi521xx_of_clk_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct si521xx *si = data;\n\tunsigned int idx = clkspec->args[0];\n\n\treturn &si->clk_dif[idx].hw;\n}\n\nstatic int si521xx_probe(struct i2c_client *client)\n{\n\tconst u16 chip_info = (u16)(uintptr_t)device_get_match_data(&client->dev);\n\tconst struct clk_parent_data clk_parent_data = { .index = 0 };\n\tconst u8 data[3] = { SI521XX_REG_BC, 1, 1 };\n\tunsigned char name[16] = \"DIFF0\";\n\tstruct clk_init_data init = {};\n\tstruct si521xx *si;\n\tint i, ret;\n\n\tif (!chip_info)\n\t\treturn -EINVAL;\n\n\tsi = devm_kzalloc(&client->dev, sizeof(*si), GFP_KERNEL);\n\tif (!si)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, si);\n\tsi->client = client;\n\n\t \n\tret = si521xx_get_common_config(si);\n\tif (ret)\n\t\treturn ret;\n\n\tsi->regmap = devm_regmap_init(&client->dev, NULL, client,\n\t\t\t\t      &si521xx_regmap_config);\n\tif (IS_ERR(si->regmap))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(si->regmap),\n\t\t\t\t     \"Failed to allocate register map\\n\");\n\n\t \n\tret = i2c_master_send(client, data, ARRAY_SIZE(data));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < hweight16(chip_info); i++) {\n\t\tmemset(&init, 0, sizeof(init));\n\t\tsnprintf(name, sizeof(name), \"DIFF%d\", i);\n\t\tinit.name = name;\n\t\tinit.ops = &si521xx_diff_clk_ops;\n\t\tinit.parent_data = &clk_parent_data;\n\t\tinit.num_parents = 1;\n\t\tinit.flags = CLK_SET_RATE_PARENT;\n\n\t\tsi->clk_dif[i].hw.init = &init;\n\t\tsi->clk_dif[i].si = si;\n\n\t\tsi521xx_diff_idx_to_reg_bit(chip_info, i, &si->clk_dif[i]);\n\n\t\tret = devm_clk_hw_register(&client->dev, &si->clk_dif[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_of_clk_add_hw_provider(&client->dev, si521xx_of_clk_get, si);\n\tif (!ret)\n\t\tsi521xx_update_config(si);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused si521xx_suspend(struct device *dev)\n{\n\tstruct si521xx *si = dev_get_drvdata(dev);\n\n\tregcache_cache_only(si->regmap, true);\n\tregcache_mark_dirty(si->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused si521xx_resume(struct device *dev)\n{\n\tstruct si521xx *si = dev_get_drvdata(dev);\n\tint ret;\n\n\tregcache_cache_only(si->regmap, false);\n\tret = regcache_sync(si->regmap);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to restore register map: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct i2c_device_id si521xx_id[] = {\n\t{ \"si52144\", .driver_data = SI521XX_OE_MAP(0x5, 0xc0) },\n\t{ \"si52146\", .driver_data = SI521XX_OE_MAP(0x15, 0xe0) },\n\t{ \"si52147\", .driver_data = SI521XX_OE_MAP(0x17, 0xf8) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, si521xx_id);\n\nstatic const struct of_device_id clk_si521xx_of_match[] = {\n\t{ .compatible = \"skyworks,si52144\", .data = (void *)SI521XX_OE_MAP(0x5, 0xc0) },\n\t{ .compatible = \"skyworks,si52146\", .data = (void *)SI521XX_OE_MAP(0x15, 0xe0) },\n\t{ .compatible = \"skyworks,si52147\", .data = (void *)SI521XX_OE_MAP(0x15, 0xf8) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, clk_si521xx_of_match);\n\nstatic SIMPLE_DEV_PM_OPS(si521xx_pm_ops, si521xx_suspend, si521xx_resume);\n\nstatic struct i2c_driver si521xx_driver = {\n\t.driver = {\n\t\t.name = \"clk-si521xx\",\n\t\t.pm\t= &si521xx_pm_ops,\n\t\t.of_match_table = clk_si521xx_of_match,\n\t},\n\t.probe\t\t= si521xx_probe,\n\t.id_table\t= si521xx_id,\n};\nmodule_i2c_driver(si521xx_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"Skyworks Si521xx PCIe clock generator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}