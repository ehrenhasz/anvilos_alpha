{
  "module_name": "clk-aspeed.c",
  "hash_id": "515c7a3df7678beff185b2fbdd893b00f4ad6bc8b2674234ec003ffab9053776",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-aspeed.c",
  "human_readable_source": "\n\n\n#define pr_fmt(fmt) \"clk-aspeed: \" fmt\n\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/clock/aspeed-clock.h>\n\n#include \"clk-aspeed.h\"\n\n#define ASPEED_NUM_CLKS\t\t38\n\n#define ASPEED_RESET2_OFFSET\t32\n\n#define ASPEED_RESET_CTRL\t0x04\n#define ASPEED_CLK_SELECTION\t0x08\n#define ASPEED_CLK_STOP_CTRL\t0x0c\n#define ASPEED_MPLL_PARAM\t0x20\n#define ASPEED_HPLL_PARAM\t0x24\n#define  AST2500_HPLL_BYPASS_EN\tBIT(20)\n#define  AST2400_HPLL_PROGRAMMED BIT(18)\n#define  AST2400_HPLL_BYPASS_EN\tBIT(17)\n#define ASPEED_MISC_CTRL\t0x2c\n#define  UART_DIV13_EN\t\tBIT(12)\n#define ASPEED_MAC_CLK_DLY\t0x48\n#define ASPEED_STRAP\t\t0x70\n#define  CLKIN_25MHZ_EN\t\tBIT(23)\n#define  AST2400_CLK_SOURCE_SEL\tBIT(18)\n#define ASPEED_CLK_SELECTION_2\t0xd8\n#define ASPEED_RESET_CTRL2\t0xd4\n\n \nstatic DEFINE_SPINLOCK(aspeed_clk_lock);\n\n \nstatic struct clk_hw_onecell_data *aspeed_clk_data;\n\nstatic void __iomem *scu_base;\n\n \nstatic const struct aspeed_gate_data aspeed_gates[] = {\n\t \n\t[ASPEED_CLK_GATE_ECLK] =\t{  0,  6, \"eclk-gate\",\t\t\"eclk\",\t0 },  \n\t[ASPEED_CLK_GATE_GCLK] =\t{  1,  7, \"gclk-gate\",\t\tNULL,\t0 },  \n\t[ASPEED_CLK_GATE_MCLK] =\t{  2, -1, \"mclk-gate\",\t\t\"mpll\",\tCLK_IS_CRITICAL },  \n\t[ASPEED_CLK_GATE_VCLK] =\t{  3, -1, \"vclk-gate\",\t\tNULL,\t0 },  \n\t[ASPEED_CLK_GATE_BCLK] =\t{  4,  8, \"bclk-gate\",\t\t\"bclk\",\tCLK_IS_CRITICAL },  \n\t[ASPEED_CLK_GATE_DCLK] =\t{  5, -1, \"dclk-gate\",\t\tNULL,\tCLK_IS_CRITICAL },  \n\t[ASPEED_CLK_GATE_REFCLK] =\t{  6, -1, \"refclk-gate\",\t\"clkin\", CLK_IS_CRITICAL },\n\t[ASPEED_CLK_GATE_USBPORT2CLK] =\t{  7,  3, \"usb-port2-gate\",\tNULL,\t0 },  \n\t[ASPEED_CLK_GATE_LCLK] =\t{  8,  5, \"lclk-gate\",\t\tNULL,\t0 },  \n\t[ASPEED_CLK_GATE_USBUHCICLK] =\t{  9, 15, \"usb-uhci-gate\",\tNULL,\t0 },  \n\t[ASPEED_CLK_GATE_D1CLK] =\t{ 10, 13, \"d1clk-gate\",\t\tNULL,\t0 },  \n\t[ASPEED_CLK_GATE_YCLK] =\t{ 13,  4, \"yclk-gate\",\t\tNULL,\t0 },  \n\t[ASPEED_CLK_GATE_USBPORT1CLK] = { 14, 14, \"usb-port1-gate\",\tNULL,\t0 },  \n\t[ASPEED_CLK_GATE_UART1CLK] =\t{ 15, -1, \"uart1clk-gate\",\t\"uart\",\t0 },  \n\t[ASPEED_CLK_GATE_UART2CLK] =\t{ 16, -1, \"uart2clk-gate\",\t\"uart\",\t0 },  \n\t[ASPEED_CLK_GATE_UART5CLK] =\t{ 17, -1, \"uart5clk-gate\",\t\"uart\",\t0 },  \n\t[ASPEED_CLK_GATE_ESPICLK] =\t{ 19, -1, \"espiclk-gate\",\tNULL,\t0 },  \n\t[ASPEED_CLK_GATE_MAC1CLK] =\t{ 20, 11, \"mac1clk-gate\",\t\"mac\",\t0 },  \n\t[ASPEED_CLK_GATE_MAC2CLK] =\t{ 21, 12, \"mac2clk-gate\",\t\"mac\",\t0 },  \n\t[ASPEED_CLK_GATE_RSACLK] =\t{ 24, -1, \"rsaclk-gate\",\tNULL,\t0 },  \n\t[ASPEED_CLK_GATE_UART3CLK] =\t{ 25, -1, \"uart3clk-gate\",\t\"uart\",\t0 },  \n\t[ASPEED_CLK_GATE_UART4CLK] =\t{ 26, -1, \"uart4clk-gate\",\t\"uart\",\t0 },  \n\t[ASPEED_CLK_GATE_SDCLK] =\t{ 27, 16, \"sdclk-gate\",\t\tNULL,\t0 },  \n\t[ASPEED_CLK_GATE_LHCCLK] =\t{ 28, -1, \"lhclk-gate\",\t\t\"lhclk\", 0 },  \n};\n\nstatic const char * const eclk_parent_names[] = {\n\t\"mpll\",\n\t\"hpll\",\n\t\"dpll\",\n};\n\nstatic const struct clk_div_table ast2500_eclk_div_table[] = {\n\t{ 0x0, 2 },\n\t{ 0x1, 2 },\n\t{ 0x2, 3 },\n\t{ 0x3, 4 },\n\t{ 0x4, 5 },\n\t{ 0x5, 6 },\n\t{ 0x6, 7 },\n\t{ 0x7, 8 },\n\t{ 0 }\n};\n\nstatic const struct clk_div_table ast2500_mac_div_table[] = {\n\t{ 0x0, 4 },  \n\t{ 0x1, 4 },\n\t{ 0x2, 6 },\n\t{ 0x3, 8 },\n\t{ 0x4, 10 },\n\t{ 0x5, 12 },\n\t{ 0x6, 14 },\n\t{ 0x7, 16 },\n\t{ 0 }\n};\n\nstatic const struct clk_div_table ast2400_div_table[] = {\n\t{ 0x0, 2 },\n\t{ 0x1, 4 },\n\t{ 0x2, 6 },\n\t{ 0x3, 8 },\n\t{ 0x4, 10 },\n\t{ 0x5, 12 },\n\t{ 0x6, 14 },\n\t{ 0x7, 16 },\n\t{ 0 }\n};\n\nstatic const struct clk_div_table ast2500_div_table[] = {\n\t{ 0x0, 4 },\n\t{ 0x1, 8 },\n\t{ 0x2, 12 },\n\t{ 0x3, 16 },\n\t{ 0x4, 20 },\n\t{ 0x5, 24 },\n\t{ 0x6, 28 },\n\t{ 0x7, 32 },\n\t{ 0 }\n};\n\nstatic struct clk_hw *aspeed_ast2400_calc_pll(const char *name, u32 val)\n{\n\tunsigned int mult, div;\n\n\tif (val & AST2400_HPLL_BYPASS_EN) {\n\t\t \n\t\tmult = div = 1;\n\t} else {\n\t\t \n\t\tu32 n = (val >> 5) & 0x3f;\n\t\tu32 od = (val >> 4) & 0x1;\n\t\tu32 d = val & 0xf;\n\n\t\tmult = (2 - od) * (n + 2);\n\t\tdiv = d + 1;\n\t}\n\treturn clk_hw_register_fixed_factor(NULL, name, \"clkin\", 0,\n\t\t\tmult, div);\n};\n\nstatic struct clk_hw *aspeed_ast2500_calc_pll(const char *name, u32 val)\n{\n\tunsigned int mult, div;\n\n\tif (val & AST2500_HPLL_BYPASS_EN) {\n\t\t \n\t\tmult = div = 1;\n\t} else {\n\t\t \n\t\tu32 p = (val >> 13) & 0x3f;\n\t\tu32 m = (val >> 5) & 0xff;\n\t\tu32 n = val & 0x1f;\n\n\t\tmult = (m + 1) / (n + 1);\n\t\tdiv = p + 1;\n\t}\n\n\treturn clk_hw_register_fixed_factor(NULL, name, \"clkin\", 0,\n\t\t\tmult, div);\n}\n\nstatic const struct aspeed_clk_soc_data ast2500_data = {\n\t.div_table = ast2500_div_table,\n\t.eclk_div_table = ast2500_eclk_div_table,\n\t.mac_div_table = ast2500_mac_div_table,\n\t.calc_pll = aspeed_ast2500_calc_pll,\n};\n\nstatic const struct aspeed_clk_soc_data ast2400_data = {\n\t.div_table = ast2400_div_table,\n\t.eclk_div_table = ast2400_div_table,\n\t.mac_div_table = ast2400_div_table,\n\t.calc_pll = aspeed_ast2400_calc_pll,\n};\n\nstatic int aspeed_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct aspeed_clk_gate *gate = to_aspeed_clk_gate(hw);\n\tu32 clk = BIT(gate->clock_idx);\n\tu32 rst = BIT(gate->reset_idx);\n\tu32 enval = (gate->flags & CLK_GATE_SET_TO_DISABLE) ? 0 : clk;\n\tu32 reg;\n\n\t \n\tif (gate->reset_idx >= 0) {\n\t\tregmap_read(gate->map, ASPEED_RESET_CTRL, &reg);\n\t\tif (reg & rst)\n\t\t\treturn 0;\n\t}\n\n\tregmap_read(gate->map, ASPEED_CLK_STOP_CTRL, &reg);\n\n\treturn ((reg & clk) == enval) ? 1 : 0;\n}\n\nstatic int aspeed_clk_enable(struct clk_hw *hw)\n{\n\tstruct aspeed_clk_gate *gate = to_aspeed_clk_gate(hw);\n\tunsigned long flags;\n\tu32 clk = BIT(gate->clock_idx);\n\tu32 rst = BIT(gate->reset_idx);\n\tu32 enval;\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tif (aspeed_clk_is_enabled(hw)) {\n\t\tspin_unlock_irqrestore(gate->lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (gate->reset_idx >= 0) {\n\t\t \n\t\tregmap_update_bits(gate->map, ASPEED_RESET_CTRL, rst, rst);\n\n\t\t \n\t\tudelay(100);\n\t}\n\n\t \n\tenval = (gate->flags & CLK_GATE_SET_TO_DISABLE) ? 0 : clk;\n\tregmap_update_bits(gate->map, ASPEED_CLK_STOP_CTRL, clk, enval);\n\n\tif (gate->reset_idx >= 0) {\n\t\t \n\t\tmdelay(10);\n\n\t\t \n\t\tregmap_update_bits(gate->map, ASPEED_RESET_CTRL, rst, 0);\n\t}\n\n\tspin_unlock_irqrestore(gate->lock, flags);\n\n\treturn 0;\n}\n\nstatic void aspeed_clk_disable(struct clk_hw *hw)\n{\n\tstruct aspeed_clk_gate *gate = to_aspeed_clk_gate(hw);\n\tunsigned long flags;\n\tu32 clk = BIT(gate->clock_idx);\n\tu32 enval;\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tenval = (gate->flags & CLK_GATE_SET_TO_DISABLE) ? clk : 0;\n\tregmap_update_bits(gate->map, ASPEED_CLK_STOP_CTRL, clk, enval);\n\n\tspin_unlock_irqrestore(gate->lock, flags);\n}\n\nstatic const struct clk_ops aspeed_clk_gate_ops = {\n\t.enable = aspeed_clk_enable,\n\t.disable = aspeed_clk_disable,\n\t.is_enabled = aspeed_clk_is_enabled,\n};\n\nstatic const u8 aspeed_resets[] = {\n\t \n\t[ASPEED_RESET_XDMA]\t= 25,\n\t[ASPEED_RESET_MCTP]\t= 24,\n\t[ASPEED_RESET_ADC]\t= 23,\n\t[ASPEED_RESET_JTAG_MASTER] = 22,\n\t[ASPEED_RESET_MIC]\t= 18,\n\t[ASPEED_RESET_PWM]\t=  9,\n\t[ASPEED_RESET_PECI]\t= 10,\n\t[ASPEED_RESET_I2C]\t=  2,\n\t[ASPEED_RESET_AHB]\t=  1,\n\n\t \n\t[ASPEED_RESET_CRT1]\t= ASPEED_RESET2_OFFSET + 5,\n};\n\nstatic int aspeed_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t unsigned long id)\n{\n\tstruct aspeed_reset *ar = to_aspeed_reset(rcdev);\n\tu32 reg = ASPEED_RESET_CTRL;\n\tu32 bit = aspeed_resets[id];\n\n\tif (bit >= ASPEED_RESET2_OFFSET) {\n\t\tbit -= ASPEED_RESET2_OFFSET;\n\t\treg = ASPEED_RESET_CTRL2;\n\t}\n\n\treturn regmap_update_bits(ar->map, reg, BIT(bit), 0);\n}\n\nstatic int aspeed_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tstruct aspeed_reset *ar = to_aspeed_reset(rcdev);\n\tu32 reg = ASPEED_RESET_CTRL;\n\tu32 bit = aspeed_resets[id];\n\n\tif (bit >= ASPEED_RESET2_OFFSET) {\n\t\tbit -= ASPEED_RESET2_OFFSET;\n\t\treg = ASPEED_RESET_CTRL2;\n\t}\n\n\treturn regmap_update_bits(ar->map, reg, BIT(bit), BIT(bit));\n}\n\nstatic int aspeed_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tstruct aspeed_reset *ar = to_aspeed_reset(rcdev);\n\tu32 reg = ASPEED_RESET_CTRL;\n\tu32 bit = aspeed_resets[id];\n\tint ret, val;\n\n\tif (bit >= ASPEED_RESET2_OFFSET) {\n\t\tbit -= ASPEED_RESET2_OFFSET;\n\t\treg = ASPEED_RESET_CTRL2;\n\t}\n\n\tret = regmap_read(ar->map, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(val & BIT(bit));\n}\n\nstatic const struct reset_control_ops aspeed_reset_ops = {\n\t.assert = aspeed_reset_assert,\n\t.deassert = aspeed_reset_deassert,\n\t.status = aspeed_reset_status,\n};\n\nstatic struct clk_hw *aspeed_clk_hw_register_gate(struct device *dev,\n\t\tconst char *name, const char *parent_name, unsigned long flags,\n\t\tstruct regmap *map, u8 clock_idx, u8 reset_idx,\n\t\tu8 clk_gate_flags, spinlock_t *lock)\n{\n\tstruct aspeed_clk_gate *gate;\n\tstruct clk_init_data init;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &aspeed_clk_gate_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\n\tgate->map = map;\n\tgate->clock_idx = clock_idx;\n\tgate->reset_idx = reset_idx;\n\tgate->flags = clk_gate_flags;\n\tgate->lock = lock;\n\tgate->hw.init = &init;\n\n\thw = &gate->hw;\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\tkfree(gate);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstatic int aspeed_clk_probe(struct platform_device *pdev)\n{\n\tconst struct aspeed_clk_soc_data *soc_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct aspeed_reset *ar;\n\tstruct regmap *map;\n\tstruct clk_hw *hw;\n\tu32 val, rate;\n\tint i, ret;\n\n\tmap = syscon_node_to_regmap(dev->of_node);\n\tif (IS_ERR(map)) {\n\t\tdev_err(dev, \"no syscon regmap\\n\");\n\t\treturn PTR_ERR(map);\n\t}\n\n\tar = devm_kzalloc(dev, sizeof(*ar), GFP_KERNEL);\n\tif (!ar)\n\t\treturn -ENOMEM;\n\n\tar->map = map;\n\tar->rcdev.owner = THIS_MODULE;\n\tar->rcdev.nr_resets = ARRAY_SIZE(aspeed_resets);\n\tar->rcdev.ops = &aspeed_reset_ops;\n\tar->rcdev.of_node = dev->of_node;\n\n\tret = devm_reset_controller_register(dev, &ar->rcdev);\n\tif (ret) {\n\t\tdev_err(dev, \"could not register reset controller\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tsoc_data = of_device_get_match_data(dev);\n\tif (!soc_data) {\n\t\tdev_err(dev, \"no match data for platform\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_read(map, ASPEED_MISC_CTRL, &val);\n\tif (val & UART_DIV13_EN)\n\t\trate = 24000000 / 13;\n\telse\n\t\trate = 24000000;\n\t \n\thw = clk_hw_register_fixed_rate(dev, \"uart\", NULL, 0, rate);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_clk_data->hws[ASPEED_CLK_UART] = hw;\n\n\t \n\tregmap_read(map, ASPEED_MPLL_PARAM, &val);\n\thw = soc_data->calc_pll(\"mpll\", val);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_clk_data->hws[ASPEED_CLK_MPLL] =\thw;\n\n\t \n\thw = clk_hw_register_gate(dev, \"sd_extclk_gate\", \"hpll\", 0,\n\t\t\t\t  scu_base + ASPEED_CLK_SELECTION, 15, 0,\n\t\t\t\t  &aspeed_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\thw = clk_hw_register_divider_table(dev, \"sd_extclk\", \"sd_extclk_gate\",\n\t\t\t0, scu_base + ASPEED_CLK_SELECTION, 12, 3, 0,\n\t\t\tsoc_data->div_table,\n\t\t\t&aspeed_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_clk_data->hws[ASPEED_CLK_SDIO] = hw;\n\n\t \n\thw = clk_hw_register_divider_table(dev, \"mac\", \"hpll\", 0,\n\t\t\tscu_base + ASPEED_CLK_SELECTION, 16, 3, 0,\n\t\t\tsoc_data->mac_div_table,\n\t\t\t&aspeed_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_clk_data->hws[ASPEED_CLK_MAC] = hw;\n\n\tif (of_device_is_compatible(pdev->dev.of_node, \"aspeed,ast2500-scu\")) {\n\t\t \n\t\thw = clk_hw_register_fixed_rate(dev, \"mac12rclk\", \"hpll\", 0,\n\t\t\t\t\t\t50000000);\n\t\tif (IS_ERR(hw))\n\t\t\treturn PTR_ERR(hw);\n\n\t\t \n\t\thw = clk_hw_register_gate(dev, \"mac1rclk\", \"mac12rclk\", 0,\n\t\t\t\tscu_base + ASPEED_MAC_CLK_DLY, 29, 0,\n\t\t\t\t&aspeed_clk_lock);\n\t\tif (IS_ERR(hw))\n\t\t\treturn PTR_ERR(hw);\n\t\taspeed_clk_data->hws[ASPEED_CLK_MAC1RCLK] = hw;\n\n\t\t \n\t\thw = clk_hw_register_gate(dev, \"mac2rclk\", \"mac12rclk\", 0,\n\t\t\t\tscu_base + ASPEED_MAC_CLK_DLY, 30, 0,\n\t\t\t\t&aspeed_clk_lock);\n\t\tif (IS_ERR(hw))\n\t\t\treturn PTR_ERR(hw);\n\t\taspeed_clk_data->hws[ASPEED_CLK_MAC2RCLK] = hw;\n\t}\n\n\t \n\thw = clk_hw_register_divider_table(dev, \"lhclk\", \"hpll\", 0,\n\t\t\tscu_base + ASPEED_CLK_SELECTION, 20, 3, 0,\n\t\t\tsoc_data->div_table,\n\t\t\t&aspeed_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_clk_data->hws[ASPEED_CLK_LHCLK] = hw;\n\n\t \n\thw = clk_hw_register_divider_table(dev, \"bclk\", \"hpll\", 0,\n\t\t\tscu_base + ASPEED_CLK_SELECTION_2, 0, 2, 0,\n\t\t\tsoc_data->div_table,\n\t\t\t&aspeed_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_clk_data->hws[ASPEED_CLK_BCLK] = hw;\n\n\t \n\thw = clk_hw_register_fixed_rate(NULL, \"fixed-24m\", \"clkin\",\n\t\t\t\t\t0, 24000000);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_clk_data->hws[ASPEED_CLK_24M] = hw;\n\n\thw = clk_hw_register_mux(dev, \"eclk-mux\", eclk_parent_names,\n\t\t\t\t ARRAY_SIZE(eclk_parent_names), 0,\n\t\t\t\t scu_base + ASPEED_CLK_SELECTION, 2, 0x3, 0,\n\t\t\t\t &aspeed_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_clk_data->hws[ASPEED_CLK_ECLK_MUX] = hw;\n\n\thw = clk_hw_register_divider_table(dev, \"eclk\", \"eclk-mux\", 0,\n\t\t\t\t\t   scu_base + ASPEED_CLK_SELECTION, 28,\n\t\t\t\t\t   3, 0, soc_data->eclk_div_table,\n\t\t\t\t\t   &aspeed_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_clk_data->hws[ASPEED_CLK_ECLK] = hw;\n\n\t \n\n\tfor (i = 0; i < ARRAY_SIZE(aspeed_gates); i++) {\n\t\tconst struct aspeed_gate_data *gd = &aspeed_gates[i];\n\t\tu32 gate_flags;\n\n\t\t \n\t\tgate_flags = (gd->clock_idx == 14) ? 0 : CLK_GATE_SET_TO_DISABLE;\n\t\thw = aspeed_clk_hw_register_gate(dev,\n\t\t\t\tgd->name,\n\t\t\t\tgd->parent_name,\n\t\t\t\tgd->flags,\n\t\t\t\tmap,\n\t\t\t\tgd->clock_idx,\n\t\t\t\tgd->reset_idx,\n\t\t\t\tgate_flags,\n\t\t\t\t&aspeed_clk_lock);\n\t\tif (IS_ERR(hw))\n\t\t\treturn PTR_ERR(hw);\n\t\taspeed_clk_data->hws[i] = hw;\n\t}\n\n\treturn 0;\n};\n\nstatic const struct of_device_id aspeed_clk_dt_ids[] = {\n\t{ .compatible = \"aspeed,ast2400-scu\", .data = &ast2400_data },\n\t{ .compatible = \"aspeed,ast2500-scu\", .data = &ast2500_data },\n\t{ }\n};\n\nstatic struct platform_driver aspeed_clk_driver = {\n\t.probe  = aspeed_clk_probe,\n\t.driver = {\n\t\t.name = \"aspeed-clk\",\n\t\t.of_match_table = aspeed_clk_dt_ids,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(aspeed_clk_driver);\n\nstatic void __init aspeed_ast2400_cc(struct regmap *map)\n{\n\tstruct clk_hw *hw;\n\tu32 val, div, clkin, hpll;\n\tconst u16 hpll_rates[][4] = {\n\t\t{384, 360, 336, 408},\n\t\t{400, 375, 350, 425},\n\t};\n\tint rate;\n\n\t \n\tregmap_read(map, ASPEED_STRAP, &val);\n\trate = (val >> 8) & 3;\n\tif (val & CLKIN_25MHZ_EN) {\n\t\tclkin = 25000000;\n\t\thpll = hpll_rates[1][rate];\n\t} else if (val & AST2400_CLK_SOURCE_SEL) {\n\t\tclkin = 48000000;\n\t\thpll = hpll_rates[0][rate];\n\t} else {\n\t\tclkin = 24000000;\n\t\thpll = hpll_rates[0][rate];\n\t}\n\thw = clk_hw_register_fixed_rate(NULL, \"clkin\", NULL, 0, clkin);\n\tpr_debug(\"clkin @%u MHz\\n\", clkin / 1000000);\n\n\t \n\tregmap_read(map, ASPEED_HPLL_PARAM, &val);\n\tif (val & AST2400_HPLL_PROGRAMMED)\n\t\thw = aspeed_ast2400_calc_pll(\"hpll\", val);\n\telse\n\t\thw = clk_hw_register_fixed_rate(NULL, \"hpll\", \"clkin\", 0,\n\t\t\t\thpll * 1000000);\n\n\taspeed_clk_data->hws[ASPEED_CLK_HPLL] = hw;\n\n\t \n\tregmap_read(map, ASPEED_STRAP, &val);\n\tval = (val >> 10) & 0x3;\n\tdiv = val + 1;\n\tif (div == 3)\n\t\tdiv = 4;\n\telse if (div == 4)\n\t\tdiv = 3;\n\thw = clk_hw_register_fixed_factor(NULL, \"ahb\", \"hpll\", 0, 1, div);\n\taspeed_clk_data->hws[ASPEED_CLK_AHB] = hw;\n\n\t \n\thw = clk_hw_register_divider_table(NULL, \"apb\", \"hpll\", 0,\n\t\t\tscu_base + ASPEED_CLK_SELECTION, 23, 3, 0,\n\t\t\tast2400_div_table,\n\t\t\t&aspeed_clk_lock);\n\taspeed_clk_data->hws[ASPEED_CLK_APB] = hw;\n}\n\nstatic void __init aspeed_ast2500_cc(struct regmap *map)\n{\n\tstruct clk_hw *hw;\n\tu32 val, freq, div;\n\n\t \n\tregmap_read(map, ASPEED_STRAP, &val);\n\tif (val & CLKIN_25MHZ_EN)\n\t\tfreq = 25000000;\n\telse\n\t\tfreq = 24000000;\n\thw = clk_hw_register_fixed_rate(NULL, \"clkin\", NULL, 0, freq);\n\tpr_debug(\"clkin @%u MHz\\n\", freq / 1000000);\n\n\t \n\tregmap_read(map, ASPEED_HPLL_PARAM, &val);\n\taspeed_clk_data->hws[ASPEED_CLK_HPLL] = aspeed_ast2500_calc_pll(\"hpll\", val);\n\n\t \n\tregmap_read(map, ASPEED_STRAP, &val);\n\tval = (val >> 9) & 0x7;\n\tWARN(val == 0, \"strapping is zero: cannot determine ahb clock\");\n\tdiv = 2 * (val + 1);\n\thw = clk_hw_register_fixed_factor(NULL, \"ahb\", \"hpll\", 0, 1, div);\n\taspeed_clk_data->hws[ASPEED_CLK_AHB] = hw;\n\n\t \n\tregmap_read(map, ASPEED_CLK_SELECTION, &val);\n\tval = (val >> 23) & 0x7;\n\tdiv = 4 * (val + 1);\n\thw = clk_hw_register_fixed_factor(NULL, \"apb\", \"hpll\", 0, 1, div);\n\taspeed_clk_data->hws[ASPEED_CLK_APB] = hw;\n};\n\nstatic void __init aspeed_cc_init(struct device_node *np)\n{\n\tstruct regmap *map;\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tscu_base = of_iomap(np, 0);\n\tif (!scu_base)\n\t\treturn;\n\n\taspeed_clk_data = kzalloc(struct_size(aspeed_clk_data, hws,\n\t\t\t\t\t      ASPEED_NUM_CLKS),\n\t\t\t\t  GFP_KERNEL);\n\tif (!aspeed_clk_data)\n\t\treturn;\n\taspeed_clk_data->num = ASPEED_NUM_CLKS;\n\n\t \n\tfor (i = 0; i < ASPEED_NUM_CLKS; i++)\n\t\taspeed_clk_data->hws[i] = ERR_PTR(-EPROBE_DEFER);\n\n\tmap = syscon_node_to_regmap(np);\n\tif (IS_ERR(map)) {\n\t\tpr_err(\"no syscon regmap\\n\");\n\t\treturn;\n\t}\n\t \n\tret = regmap_read(map, ASPEED_STRAP, &val);\n\tif (ret) {\n\t\tpr_err(\"failed to read strapping register\\n\");\n\t\treturn;\n\t}\n\n\tif (of_device_is_compatible(np, \"aspeed,ast2400-scu\"))\n\t\taspeed_ast2400_cc(map);\n\telse if (of_device_is_compatible(np, \"aspeed,ast2500-scu\"))\n\t\taspeed_ast2500_cc(map);\n\telse\n\t\tpr_err(\"unknown platform, failed to add clocks\\n\");\n\tret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, aspeed_clk_data);\n\tif (ret)\n\t\tpr_err(\"failed to add DT provider: %d\\n\", ret);\n};\nCLK_OF_DECLARE_DRIVER(aspeed_cc_g5, \"aspeed,ast2500-scu\", aspeed_cc_init);\nCLK_OF_DECLARE_DRIVER(aspeed_cc_g4, \"aspeed,ast2400-scu\", aspeed_cc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}