{
  "module_name": "clk-phase.c",
  "hash_id": "15a90db121543a55f425cc62a8e161190af488fda2d8c8fb16224b7b1ee93e2c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/meson/clk-phase.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/module.h>\n\n#include \"clk-regmap.h\"\n#include \"clk-phase.h\"\n\n#define phase_step(_width) (360 / (1 << (_width)))\n\nstatic inline struct meson_clk_phase_data *\nmeson_clk_phase_data(struct clk_regmap *clk)\n{\n\treturn (struct meson_clk_phase_data *)clk->data;\n}\n\nstatic int meson_clk_degrees_from_val(unsigned int val, unsigned int width)\n{\n\treturn phase_step(width) * val;\n}\n\nstatic unsigned int meson_clk_degrees_to_val(int degrees, unsigned int width)\n{\n\tunsigned int val = DIV_ROUND_CLOSEST(degrees, phase_step(width));\n\n\t \n\treturn val % (1 << width);\n}\n\nstatic int meson_clk_phase_get_phase(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_phase_data *phase = meson_clk_phase_data(clk);\n\tunsigned int val;\n\n\tval = meson_parm_read(clk->map, &phase->ph);\n\n\treturn meson_clk_degrees_from_val(val, phase->ph.width);\n}\n\nstatic int meson_clk_phase_set_phase(struct clk_hw *hw, int degrees)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_phase_data *phase = meson_clk_phase_data(clk);\n\tunsigned int val;\n\n\tval = meson_clk_degrees_to_val(degrees, phase->ph.width);\n\tmeson_parm_write(clk->map, &phase->ph, val);\n\n\treturn 0;\n}\n\nconst struct clk_ops meson_clk_phase_ops = {\n\t.get_phase\t= meson_clk_phase_get_phase,\n\t.set_phase\t= meson_clk_phase_set_phase,\n};\nEXPORT_SYMBOL_GPL(meson_clk_phase_ops);\n\n \nstatic inline struct meson_clk_triphase_data *\nmeson_clk_triphase_data(struct clk_regmap *clk)\n{\n\treturn (struct meson_clk_triphase_data *)clk->data;\n}\n\nstatic int meson_clk_triphase_sync(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_triphase_data *tph = meson_clk_triphase_data(clk);\n\tunsigned int val;\n\n\t \n\tval = meson_parm_read(clk->map, &tph->ph0);\n\tmeson_parm_write(clk->map, &tph->ph1, val);\n\tmeson_parm_write(clk->map, &tph->ph2, val);\n\n\treturn 0;\n}\n\nstatic int meson_clk_triphase_get_phase(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_triphase_data *tph = meson_clk_triphase_data(clk);\n\tunsigned int val;\n\n\t \n\tval = meson_parm_read(clk->map, &tph->ph0);\n\n\treturn meson_clk_degrees_from_val(val, tph->ph0.width);\n}\n\nstatic int meson_clk_triphase_set_phase(struct clk_hw *hw, int degrees)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_triphase_data *tph = meson_clk_triphase_data(clk);\n\tunsigned int val;\n\n\tval = meson_clk_degrees_to_val(degrees, tph->ph0.width);\n\tmeson_parm_write(clk->map, &tph->ph0, val);\n\tmeson_parm_write(clk->map, &tph->ph1, val);\n\tmeson_parm_write(clk->map, &tph->ph2, val);\n\n\treturn 0;\n}\n\nconst struct clk_ops meson_clk_triphase_ops = {\n\t.init\t\t= meson_clk_triphase_sync,\n\t.get_phase\t= meson_clk_triphase_get_phase,\n\t.set_phase\t= meson_clk_triphase_set_phase,\n};\nEXPORT_SYMBOL_GPL(meson_clk_triphase_ops);\n\n \nstatic inline struct meson_sclk_ws_inv_data *\nmeson_sclk_ws_inv_data(struct clk_regmap *clk)\n{\n\treturn (struct meson_sclk_ws_inv_data *)clk->data;\n}\n\nstatic int meson_sclk_ws_inv_sync(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_sclk_ws_inv_data *tph = meson_sclk_ws_inv_data(clk);\n\tunsigned int val;\n\n\t \n\tval = meson_parm_read(clk->map, &tph->ph);\n\tmeson_parm_write(clk->map, &tph->ws, val ? 0 : 1);\n\n\treturn 0;\n}\n\nstatic int meson_sclk_ws_inv_get_phase(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_sclk_ws_inv_data *tph = meson_sclk_ws_inv_data(clk);\n\tunsigned int val;\n\n\tval = meson_parm_read(clk->map, &tph->ph);\n\n\treturn meson_clk_degrees_from_val(val, tph->ph.width);\n}\n\nstatic int meson_sclk_ws_inv_set_phase(struct clk_hw *hw, int degrees)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_sclk_ws_inv_data *tph = meson_sclk_ws_inv_data(clk);\n\tunsigned int val;\n\n\tval = meson_clk_degrees_to_val(degrees, tph->ph.width);\n\tmeson_parm_write(clk->map, &tph->ph, val);\n\tmeson_parm_write(clk->map, &tph->ws, val ? 0 : 1);\n\treturn 0;\n}\n\nconst struct clk_ops meson_sclk_ws_inv_ops = {\n\t.init\t\t= meson_sclk_ws_inv_sync,\n\t.get_phase\t= meson_sclk_ws_inv_get_phase,\n\t.set_phase\t= meson_sclk_ws_inv_set_phase,\n};\nEXPORT_SYMBOL_GPL(meson_sclk_ws_inv_ops);\n\n\nMODULE_DESCRIPTION(\"Amlogic phase driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}