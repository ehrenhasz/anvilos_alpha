{
  "module_name": "gxbb-aoclk.c",
  "hash_id": "b91f0ac51bbbe4ed359859ce49e113cf2e9330fbda107a01de14894e6e0f1eb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/meson/gxbb-aoclk.c",
  "human_readable_source": "\n \n#include <linux/platform_device.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include \"meson-aoclk.h\"\n\n#include \"clk-regmap.h\"\n#include \"clk-dualdiv.h\"\n\n#include <dt-bindings/clock/gxbb-aoclkc.h>\n#include <dt-bindings/reset/gxbb-aoclkc.h>\n\n \n#define AO_RTI_PWR_CNTL_REG1\t0x0c\n#define AO_RTI_PWR_CNTL_REG0\t0x10\n#define AO_RTI_GEN_CNTL_REG0\t0x40\n#define AO_OSCIN_CNTL\t\t0x58\n#define AO_CRT_CLK_CNTL1\t0x68\n#define AO_RTC_ALT_CLK_CNTL0\t0x94\n#define AO_RTC_ALT_CLK_CNTL1\t0x98\n\n#define GXBB_AO_GATE(_name, _bit)\t\t\t\t\t\\\nstatic struct clk_regmap _name##_ao = {\t\t\t\t\t\\\n\t.data = &(struct clk_regmap_gate_data) {\t\t\t\\\n\t\t.offset = AO_RTI_GEN_CNTL_REG0,\t\t\t\t\\\n\t\t.bit_idx = (_bit),\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.hw.init = &(struct clk_init_data) {\t\t\t\t\\\n\t\t.name = #_name \"_ao\",\t\t\t\t\t\\\n\t\t.ops = &clk_regmap_gate_ops,\t\t\t\t\\\n\t\t.parent_data = &(const struct clk_parent_data) {\t\\\n\t\t\t.fw_name = \"mpeg-clk\",\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.num_parents = 1,\t\t\t\t\t\\\n\t\t.flags = CLK_IGNORE_UNUSED,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nGXBB_AO_GATE(remote, 0);\nGXBB_AO_GATE(i2c_master, 1);\nGXBB_AO_GATE(i2c_slave, 2);\nGXBB_AO_GATE(uart1, 3);\nGXBB_AO_GATE(uart2, 5);\nGXBB_AO_GATE(ir_blaster, 6);\n\nstatic struct clk_regmap ao_cts_oscin = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = AO_RTI_PWR_CNTL_REG0,\n\t\t.bit_idx = 6,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ao_cts_oscin\",\n\t\t.ops = &clk_regmap_gate_ro_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap ao_32k_pre = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = AO_RTC_ALT_CLK_CNTL0,\n\t\t.bit_idx = 31,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ao_32k_pre\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) { &ao_cts_oscin.hw },\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic const struct meson_clk_dualdiv_param gxbb_32k_div_table[] = {\n\t{\n\t\t.dual\t= 1,\n\t\t.n1\t= 733,\n\t\t.m1\t= 8,\n\t\t.n2\t= 732,\n\t\t.m2\t= 11,\n\t}, {}\n};\n\nstatic struct clk_regmap ao_32k_div = {\n\t.data = &(struct meson_clk_dualdiv_data){\n\t\t.n1 = {\n\t\t\t.reg_off = AO_RTC_ALT_CLK_CNTL0,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.n2 = {\n\t\t\t.reg_off = AO_RTC_ALT_CLK_CNTL0,\n\t\t\t.shift   = 12,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.m1 = {\n\t\t\t.reg_off = AO_RTC_ALT_CLK_CNTL1,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.m2 = {\n\t\t\t.reg_off = AO_RTC_ALT_CLK_CNTL1,\n\t\t\t.shift   = 12,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.dual = {\n\t\t\t.reg_off = AO_RTC_ALT_CLK_CNTL0,\n\t\t\t.shift   = 28,\n\t\t\t.width   = 1,\n\t\t},\n\t\t.table = gxbb_32k_div_table,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ao_32k_div\",\n\t\t.ops = &meson_clk_dualdiv_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) { &ao_32k_pre.hw },\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap ao_32k_sel = {\n\t.data = &(struct clk_regmap_mux_data) {\n\t\t.offset = AO_RTC_ALT_CLK_CNTL1,\n\t\t.mask = 0x1,\n\t\t.shift = 24,\n\t\t.flags = CLK_MUX_ROUND_CLOSEST,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ao_32k_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&ao_32k_div.hw,\n\t\t\t&ao_32k_pre.hw\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap ao_32k = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = AO_RTC_ALT_CLK_CNTL0,\n\t\t.bit_idx = 30,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ao_32k\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) { &ao_32k_sel.hw },\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap ao_cts_rtc_oscin = {\n\t.data = &(struct clk_regmap_mux_data) {\n\t\t.offset = AO_RTI_PWR_CNTL_REG0,\n\t\t.mask = 0x7,\n\t\t.shift = 10,\n\t\t.table = (u32[]){ 1, 2, 3, 4 },\n\t\t.flags = CLK_MUX_ROUND_CLOSEST,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ao_cts_rtc_oscin\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = (const struct clk_parent_data []) {\n\t\t\t{ .fw_name = \"ext-32k-0\", },\n\t\t\t{ .fw_name = \"ext-32k-1\", },\n\t\t\t{ .fw_name = \"ext-32k-2\", },\n\t\t\t{ .hw = &ao_32k.hw },\n\t\t},\n\t\t.num_parents = 4,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap ao_clk81 = {\n\t.data = &(struct clk_regmap_mux_data) {\n\t\t.offset = AO_RTI_PWR_CNTL_REG0,\n\t\t.mask = 0x1,\n\t\t.shift = 0,\n\t\t.flags = CLK_MUX_ROUND_CLOSEST,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ao_clk81\",\n\t\t.ops = &clk_regmap_mux_ro_ops,\n\t\t.parent_data = (const struct clk_parent_data []) {\n\t\t\t{ .fw_name = \"mpeg-clk\", },\n\t\t\t{ .hw = &ao_cts_rtc_oscin.hw },\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap ao_cts_cec = {\n\t.data = &(struct clk_regmap_mux_data) {\n\t\t.offset = AO_CRT_CLK_CNTL1,\n\t\t.mask = 0x1,\n\t\t.shift = 27,\n\t\t.flags = CLK_MUX_ROUND_CLOSEST,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ao_cts_cec\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t \n\t\t.parent_data = (const struct clk_parent_data []) {\n\t\t\t{ .name = \"fixme\", .index = -1, },\n\t\t\t{ .hw = &ao_cts_rtc_oscin.hw },\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic const unsigned int gxbb_aoclk_reset[] = {\n\t[RESET_AO_REMOTE] = 16,\n\t[RESET_AO_I2C_MASTER] = 18,\n\t[RESET_AO_I2C_SLAVE] = 19,\n\t[RESET_AO_UART1] = 17,\n\t[RESET_AO_UART2] = 22,\n\t[RESET_AO_IR_BLASTER] = 23,\n};\n\nstatic struct clk_regmap *gxbb_aoclk[] = {\n\t&remote_ao,\n\t&i2c_master_ao,\n\t&i2c_slave_ao,\n\t&uart1_ao,\n\t&uart2_ao,\n\t&ir_blaster_ao,\n\t&ao_cts_oscin,\n\t&ao_32k_pre,\n\t&ao_32k_div,\n\t&ao_32k_sel,\n\t&ao_32k,\n\t&ao_cts_rtc_oscin,\n\t&ao_clk81,\n\t&ao_cts_cec,\n};\n\nstatic struct clk_hw *gxbb_aoclk_hw_clks[] = {\n\t\t[CLKID_AO_REMOTE] = &remote_ao.hw,\n\t\t[CLKID_AO_I2C_MASTER] = &i2c_master_ao.hw,\n\t\t[CLKID_AO_I2C_SLAVE] = &i2c_slave_ao.hw,\n\t\t[CLKID_AO_UART1] = &uart1_ao.hw,\n\t\t[CLKID_AO_UART2] = &uart2_ao.hw,\n\t\t[CLKID_AO_IR_BLASTER] = &ir_blaster_ao.hw,\n\t\t[CLKID_AO_CEC_32K] = &ao_cts_cec.hw,\n\t\t[CLKID_AO_CTS_OSCIN] = &ao_cts_oscin.hw,\n\t\t[CLKID_AO_32K_PRE] = &ao_32k_pre.hw,\n\t\t[CLKID_AO_32K_DIV] = &ao_32k_div.hw,\n\t\t[CLKID_AO_32K_SEL] = &ao_32k_sel.hw,\n\t\t[CLKID_AO_32K] = &ao_32k.hw,\n\t\t[CLKID_AO_CTS_RTC_OSCIN] = &ao_cts_rtc_oscin.hw,\n\t\t[CLKID_AO_CLK81] = &ao_clk81.hw,\n};\n\nstatic const struct meson_aoclk_data gxbb_aoclkc_data = {\n\t.reset_reg\t= AO_RTI_GEN_CNTL_REG0,\n\t.num_reset\t= ARRAY_SIZE(gxbb_aoclk_reset),\n\t.reset\t\t= gxbb_aoclk_reset,\n\t.num_clks\t= ARRAY_SIZE(gxbb_aoclk),\n\t.clks\t\t= gxbb_aoclk,\n\t.hw_clks\t= {\n\t\t.hws\t= gxbb_aoclk_hw_clks,\n\t\t.num\t= ARRAY_SIZE(gxbb_aoclk_hw_clks),\n\t},\n};\n\nstatic const struct of_device_id gxbb_aoclkc_match_table[] = {\n\t{\n\t\t.compatible\t= \"amlogic,meson-gx-aoclkc\",\n\t\t.data\t\t= &gxbb_aoclkc_data,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, gxbb_aoclkc_match_table);\n\nstatic struct platform_driver gxbb_aoclkc_driver = {\n\t.probe\t\t= meson_aoclkc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"gxbb-aoclkc\",\n\t\t.of_match_table = gxbb_aoclkc_match_table,\n\t},\n};\nmodule_platform_driver(gxbb_aoclkc_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}