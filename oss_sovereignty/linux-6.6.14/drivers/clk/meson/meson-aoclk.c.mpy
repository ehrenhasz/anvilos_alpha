{
  "module_name": "meson-aoclk.c",
  "hash_id": "a6e9e9401c553a82fe6439493a60100eb5cc054e6768c1b0bb3c6d18193ba668",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/meson/meson-aoclk.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/module.h>\n\n#include <linux/slab.h>\n#include \"meson-aoclk.h\"\n\nstatic int meson_aoclk_do_reset(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tstruct meson_aoclk_reset_controller *rstc =\n\t\tcontainer_of(rcdev, struct meson_aoclk_reset_controller, reset);\n\n\treturn regmap_write(rstc->regmap, rstc->data->reset_reg,\n\t\t\t    BIT(rstc->data->reset[id]));\n}\n\nstatic const struct reset_control_ops meson_aoclk_reset_ops = {\n\t.reset = meson_aoclk_do_reset,\n};\n\nint meson_aoclkc_probe(struct platform_device *pdev)\n{\n\tstruct meson_aoclk_reset_controller *rstc;\n\tstruct meson_aoclk_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np;\n\tstruct regmap *regmap;\n\tint ret, clkid;\n\n\tdata = (struct meson_aoclk_data *) of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\trstc = devm_kzalloc(dev, sizeof(*rstc), GFP_KERNEL);\n\tif (!rstc)\n\t\treturn -ENOMEM;\n\n\tnp = of_get_parent(dev->of_node);\n\tregmap = syscon_node_to_regmap(np);\n\tof_node_put(np);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"failed to get regmap\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\t \n\trstc->data = data;\n\trstc->regmap = regmap;\n\trstc->reset.ops = &meson_aoclk_reset_ops;\n\trstc->reset.nr_resets = data->num_reset;\n\trstc->reset.of_node = dev->of_node;\n\tret = devm_reset_controller_register(dev, &rstc->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register reset controller\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (clkid = 0; clkid < data->num_clks; clkid++)\n\t\tdata->clks[clkid]->map = regmap;\n\n\t \n\tfor (clkid = 0; clkid < data->hw_clks.num; clkid++) {\n\t\tif (!data->hw_clks.hws[clkid])\n\t\t\tcontinue;\n\n\t\tret = devm_clk_hw_register(dev, data->hw_clks.hws[clkid]);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Clock registration failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, meson_clk_hw_get, (void *)&data->hw_clks);\n}\nEXPORT_SYMBOL_GPL(meson_aoclkc_probe);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}