{
  "module_name": "a1-pll.c",
  "hash_id": "a576eabba09fb0fe53bd72d602724b1f78ccd980c3ee3613f996405f3af7e7e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/meson/a1-pll.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include \"a1-pll.h\"\n#include \"clk-regmap.h\"\n#include \"meson-clkc-utils.h\"\n\n#include <dt-bindings/clock/amlogic,a1-pll-clkc.h>\n\nstatic struct clk_regmap fixed_pll_dco = {\n\t.data = &(struct meson_clk_pll_data){\n\t\t.en = {\n\t\t\t.reg_off = ANACTRL_FIXPLL_CTRL0,\n\t\t\t.shift   = 28,\n\t\t\t.width   = 1,\n\t\t},\n\t\t.m = {\n\t\t\t.reg_off = ANACTRL_FIXPLL_CTRL0,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 8,\n\t\t},\n\t\t.n = {\n\t\t\t.reg_off = ANACTRL_FIXPLL_CTRL0,\n\t\t\t.shift   = 10,\n\t\t\t.width   = 5,\n\t\t},\n\t\t.frac = {\n\t\t\t.reg_off = ANACTRL_FIXPLL_CTRL1,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 19,\n\t\t},\n\t\t.l = {\n\t\t\t.reg_off = ANACTRL_FIXPLL_STS,\n\t\t\t.shift   = 31,\n\t\t\t.width   = 1,\n\t\t},\n\t\t.rst = {\n\t\t\t.reg_off = ANACTRL_FIXPLL_CTRL0,\n\t\t\t.shift   = 29,\n\t\t\t.width   = 1,\n\t\t},\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"fixed_pll_dco\",\n\t\t.ops = &meson_clk_pll_ro_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"fixpll_in\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap fixed_pll = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = ANACTRL_FIXPLL_CTRL0,\n\t\t.bit_idx = 20,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"fixed_pll\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&fixed_pll_dco.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic const struct pll_mult_range hifi_pll_mult_range = {\n\t.min = 32,\n\t.max = 64,\n};\n\nstatic const struct reg_sequence hifi_init_regs[] = {\n\t{ .reg = ANACTRL_HIFIPLL_CTRL1, .def = 0x01800000 },\n\t{ .reg = ANACTRL_HIFIPLL_CTRL2, .def = 0x00001100 },\n\t{ .reg = ANACTRL_HIFIPLL_CTRL3, .def = 0x100a1100 },\n\t{ .reg = ANACTRL_HIFIPLL_CTRL4, .def = 0x00302000 },\n\t{ .reg = ANACTRL_HIFIPLL_CTRL0, .def = 0x01f18000 },\n};\n\nstatic struct clk_regmap hifi_pll = {\n\t.data = &(struct meson_clk_pll_data){\n\t\t.en = {\n\t\t\t.reg_off = ANACTRL_HIFIPLL_CTRL0,\n\t\t\t.shift   = 28,\n\t\t\t.width   = 1,\n\t\t},\n\t\t.m = {\n\t\t\t.reg_off = ANACTRL_HIFIPLL_CTRL0,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 8,\n\t\t},\n\t\t.n = {\n\t\t\t.reg_off = ANACTRL_HIFIPLL_CTRL0,\n\t\t\t.shift   = 10,\n\t\t\t.width   = 5,\n\t\t},\n\t\t.frac = {\n\t\t\t.reg_off = ANACTRL_HIFIPLL_CTRL1,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 19,\n\t\t},\n\t\t.l = {\n\t\t\t.reg_off = ANACTRL_HIFIPLL_STS,\n\t\t\t.shift   = 31,\n\t\t\t.width   = 1,\n\t\t},\n\t\t.current_en = {\n\t\t\t.reg_off = ANACTRL_HIFIPLL_CTRL0,\n\t\t\t.shift   = 26,\n\t\t\t.width   = 1,\n\t\t},\n\t\t.l_detect = {\n\t\t\t.reg_off = ANACTRL_HIFIPLL_CTRL2,\n\t\t\t.shift   = 6,\n\t\t\t.width   = 1,\n\t\t},\n\t\t.range = &hifi_pll_mult_range,\n\t\t.init_regs = hifi_init_regs,\n\t\t.init_count = ARRAY_SIZE(hifi_init_regs),\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"hifi_pll\",\n\t\t.ops = &meson_clk_pll_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"hifipll_in\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_fixed_factor fclk_div2_div = {\n\t.mult = 1,\n\t.div = 2,\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"fclk_div2_div\",\n\t\t.ops = &clk_fixed_factor_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&fixed_pll.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap fclk_div2 = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = ANACTRL_FIXPLL_CTRL0,\n\t\t.bit_idx = 21,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"fclk_div2\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&fclk_div2_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t \n\t\t.flags = CLK_IS_CRITICAL,\n\t},\n};\n\nstatic struct clk_fixed_factor fclk_div3_div = {\n\t.mult = 1,\n\t.div = 3,\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"fclk_div3_div\",\n\t\t.ops = &clk_fixed_factor_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&fixed_pll.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap fclk_div3 = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = ANACTRL_FIXPLL_CTRL0,\n\t\t.bit_idx = 22,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"fclk_div3\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&fclk_div3_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t \n\t\t.flags = CLK_IS_CRITICAL,\n\t},\n};\n\nstatic struct clk_fixed_factor fclk_div5_div = {\n\t.mult = 1,\n\t.div = 5,\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"fclk_div5_div\",\n\t\t.ops = &clk_fixed_factor_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&fixed_pll.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap fclk_div5 = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = ANACTRL_FIXPLL_CTRL0,\n\t\t.bit_idx = 23,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"fclk_div5\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&fclk_div5_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t \n\t\t.flags = CLK_IS_CRITICAL,\n\t},\n};\n\nstatic struct clk_fixed_factor fclk_div7_div = {\n\t.mult = 1,\n\t.div = 7,\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"fclk_div7_div\",\n\t\t.ops = &clk_fixed_factor_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&fixed_pll.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap fclk_div7 = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = ANACTRL_FIXPLL_CTRL0,\n\t\t.bit_idx = 24,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"fclk_div7\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&fclk_div7_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\n \nstatic struct clk_hw *a1_pll_hw_clks[] = {\n\t[CLKID_FIXED_PLL_DCO]\t= &fixed_pll_dco.hw,\n\t[CLKID_FIXED_PLL]\t= &fixed_pll.hw,\n\t[CLKID_FCLK_DIV2_DIV]\t= &fclk_div2_div.hw,\n\t[CLKID_FCLK_DIV3_DIV]\t= &fclk_div3_div.hw,\n\t[CLKID_FCLK_DIV5_DIV]\t= &fclk_div5_div.hw,\n\t[CLKID_FCLK_DIV7_DIV]\t= &fclk_div7_div.hw,\n\t[CLKID_FCLK_DIV2]\t= &fclk_div2.hw,\n\t[CLKID_FCLK_DIV3]\t= &fclk_div3.hw,\n\t[CLKID_FCLK_DIV5]\t= &fclk_div5.hw,\n\t[CLKID_FCLK_DIV7]\t= &fclk_div7.hw,\n\t[CLKID_HIFI_PLL]\t= &hifi_pll.hw,\n};\n\nstatic struct clk_regmap *const a1_pll_regmaps[] = {\n\t&fixed_pll_dco,\n\t&fixed_pll,\n\t&fclk_div2,\n\t&fclk_div3,\n\t&fclk_div5,\n\t&fclk_div7,\n\t&hifi_pll,\n};\n\nstatic struct regmap_config a1_pll_regmap_cfg = {\n\t.reg_bits   = 32,\n\t.val_bits   = 32,\n\t.reg_stride = 4,\n};\n\nstatic struct meson_clk_hw_data a1_pll_clks = {\n\t.hws = a1_pll_hw_clks,\n\t.num = ARRAY_SIZE(a1_pll_hw_clks),\n};\n\nstatic int meson_a1_pll_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *base;\n\tstruct regmap *map;\n\tint clkid, i, err;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn dev_err_probe(dev, PTR_ERR(base),\n\t\t\t\t     \"can't ioremap resource\\n\");\n\n\tmap = devm_regmap_init_mmio(dev, base, &a1_pll_regmap_cfg);\n\tif (IS_ERR(map))\n\t\treturn dev_err_probe(dev, PTR_ERR(map),\n\t\t\t\t     \"can't init regmap mmio region\\n\");\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(a1_pll_regmaps); i++)\n\t\ta1_pll_regmaps[i]->map = map;\n\n\t \n\tfor (clkid = 0; clkid < a1_pll_clks.num; clkid++) {\n\t\terr = devm_clk_hw_register(dev, a1_pll_clks.hws[clkid]);\n\t\tif (err)\n\t\t\treturn dev_err_probe(dev, err,\n\t\t\t\t\t     \"clock[%d] registration failed\\n\",\n\t\t\t\t\t     clkid);\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, meson_clk_hw_get,\n\t\t\t\t\t   &a1_pll_clks);\n}\n\nstatic const struct of_device_id a1_pll_clkc_match_table[] = {\n\t{ .compatible = \"amlogic,a1-pll-clkc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, a1_pll_clkc_match_table);\n\nstatic struct platform_driver a1_pll_clkc_driver = {\n\t.probe = meson_a1_pll_probe,\n\t.driver = {\n\t\t.name = \"a1-pll-clkc\",\n\t\t.of_match_table = a1_pll_clkc_match_table,\n\t},\n};\n\nmodule_platform_driver(a1_pll_clkc_driver);\nMODULE_AUTHOR(\"Jian Hu <jian.hu@amlogic.com>\");\nMODULE_AUTHOR(\"Dmitry Rokosov <ddrokosov@sberdevices.ru>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}