{
  "module_name": "clk-pll.c",
  "hash_id": "0e052b95abef9669e9c74a94698b9444132a2eb31f759f50ddaa5b13d65ce08b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/meson/clk-pll.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n\n#include \"clk-regmap.h\"\n#include \"clk-pll.h\"\n\nstatic inline struct meson_clk_pll_data *\nmeson_clk_pll_data(struct clk_regmap *clk)\n{\n\treturn (struct meson_clk_pll_data *)clk->data;\n}\n\nstatic int __pll_round_closest_mult(struct meson_clk_pll_data *pll)\n{\n\tif ((pll->flags & CLK_MESON_PLL_ROUND_CLOSEST) &&\n\t    !MESON_PARM_APPLICABLE(&pll->frac))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic unsigned long __pll_params_to_rate(unsigned long parent_rate,\n\t\t\t\t\t  unsigned int m, unsigned int n,\n\t\t\t\t\t  unsigned int frac,\n\t\t\t\t\t  struct meson_clk_pll_data *pll)\n{\n\tu64 rate = (u64)parent_rate * m;\n\n\tif (frac && MESON_PARM_APPLICABLE(&pll->frac)) {\n\t\tu64 frac_rate = (u64)parent_rate * frac;\n\n\t\trate += DIV_ROUND_UP_ULL(frac_rate,\n\t\t\t\t\t (1 << pll->frac.width));\n\t}\n\n\treturn DIV_ROUND_UP_ULL(rate, n);\n}\n\nstatic unsigned long meson_clk_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_pll_data *pll = meson_clk_pll_data(clk);\n\tunsigned int m, n, frac;\n\n\tn = meson_parm_read(clk->map, &pll->n);\n\n\t \n\tif (n == 0)\n\t\treturn 0;\n\n\tm = meson_parm_read(clk->map, &pll->m);\n\n\tfrac = MESON_PARM_APPLICABLE(&pll->frac) ?\n\t\tmeson_parm_read(clk->map, &pll->frac) :\n\t\t0;\n\n\treturn __pll_params_to_rate(parent_rate, m, n, frac, pll);\n}\n\nstatic unsigned int __pll_params_with_frac(unsigned long rate,\n\t\t\t\t\t   unsigned long parent_rate,\n\t\t\t\t\t   unsigned int m,\n\t\t\t\t\t   unsigned int n,\n\t\t\t\t\t   struct meson_clk_pll_data *pll)\n{\n\tunsigned int frac_max = (1 << pll->frac.width);\n\tu64 val = (u64)rate * n;\n\n\t \n\tif (rate < parent_rate * m / n)\n\t\treturn 0;\n\n\tif (pll->flags & CLK_MESON_PLL_ROUND_CLOSEST)\n\t\tval = DIV_ROUND_CLOSEST_ULL(val * frac_max, parent_rate);\n\telse\n\t\tval = div_u64(val * frac_max, parent_rate);\n\n\tval -= m * frac_max;\n\n\treturn min((unsigned int)val, (frac_max - 1));\n}\n\nstatic bool meson_clk_pll_is_better(unsigned long rate,\n\t\t\t\t    unsigned long best,\n\t\t\t\t    unsigned long now,\n\t\t\t\t    struct meson_clk_pll_data *pll)\n{\n\tif (__pll_round_closest_mult(pll)) {\n\t\t \n\t\tif (abs(now - rate) < abs(best - rate))\n\t\t\treturn true;\n\t} else {\n\t\t \n\t\tif (now <= rate && best < now)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int meson_clk_get_pll_table_index(unsigned int index,\n\t\t\t\t\t unsigned int *m,\n\t\t\t\t\t unsigned int *n,\n\t\t\t\t\t struct meson_clk_pll_data *pll)\n{\n\tif (!pll->table[index].n)\n\t\treturn -EINVAL;\n\n\t*m = pll->table[index].m;\n\t*n = pll->table[index].n;\n\n\treturn 0;\n}\n\nstatic unsigned int meson_clk_get_pll_range_m(unsigned long rate,\n\t\t\t\t\t      unsigned long parent_rate,\n\t\t\t\t\t      unsigned int n,\n\t\t\t\t\t      struct meson_clk_pll_data *pll)\n{\n\tu64 val = (u64)rate * n;\n\n\tif (__pll_round_closest_mult(pll))\n\t\treturn DIV_ROUND_CLOSEST_ULL(val, parent_rate);\n\n\treturn div_u64(val,  parent_rate);\n}\n\nstatic int meson_clk_get_pll_range_index(unsigned long rate,\n\t\t\t\t\t unsigned long parent_rate,\n\t\t\t\t\t unsigned int index,\n\t\t\t\t\t unsigned int *m,\n\t\t\t\t\t unsigned int *n,\n\t\t\t\t\t struct meson_clk_pll_data *pll)\n{\n\t*n = index + 1;\n\n\t \n\tif (*n >= (1 << pll->n.width))\n\t\treturn -EINVAL;\n\n\tif (*n == 1) {\n\t\t \n\t\tif (rate <= pll->range->min * parent_rate) {\n\t\t\t*m = pll->range->min;\n\t\t\treturn -ENODATA;\n\t\t} else if (rate >= pll->range->max * parent_rate) {\n\t\t\t*m = pll->range->max;\n\t\t\treturn -ENODATA;\n\t\t}\n\t}\n\n\t*m = meson_clk_get_pll_range_m(rate, parent_rate, *n, pll);\n\n\t \n\tif (*m >= (1 << pll->m.width))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int meson_clk_get_pll_get_index(unsigned long rate,\n\t\t\t\t       unsigned long parent_rate,\n\t\t\t\t       unsigned int index,\n\t\t\t\t       unsigned int *m,\n\t\t\t\t       unsigned int *n,\n\t\t\t\t       struct meson_clk_pll_data *pll)\n{\n\tif (pll->range)\n\t\treturn meson_clk_get_pll_range_index(rate, parent_rate,\n\t\t\t\t\t\t     index, m, n, pll);\n\telse if (pll->table)\n\t\treturn meson_clk_get_pll_table_index(index, m, n, pll);\n\n\treturn -EINVAL;\n}\n\nstatic int meson_clk_get_pll_settings(unsigned long rate,\n\t\t\t\t      unsigned long parent_rate,\n\t\t\t\t      unsigned int *best_m,\n\t\t\t\t      unsigned int *best_n,\n\t\t\t\t      struct meson_clk_pll_data *pll)\n{\n\tunsigned long best = 0, now = 0;\n\tunsigned int i, m, n;\n\tint ret;\n\n\tfor (i = 0, ret = 0; !ret; i++) {\n\t\tret = meson_clk_get_pll_get_index(rate, parent_rate,\n\t\t\t\t\t\t  i, &m, &n, pll);\n\t\tif (ret == -EINVAL)\n\t\t\tbreak;\n\n\t\tnow = __pll_params_to_rate(parent_rate, m, n, 0, pll);\n\t\tif (meson_clk_pll_is_better(rate, best, now, pll)) {\n\t\t\tbest = now;\n\t\t\t*best_m = m;\n\t\t\t*best_n = n;\n\n\t\t\tif (now == rate)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn best ? 0 : -EINVAL;\n}\n\nstatic int meson_clk_pll_determine_rate(struct clk_hw *hw,\n\t\t\t\t\tstruct clk_rate_request *req)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_pll_data *pll = meson_clk_pll_data(clk);\n\tunsigned int m, n, frac;\n\tunsigned long round;\n\tint ret;\n\n\tret = meson_clk_get_pll_settings(req->rate, req->best_parent_rate,\n\t\t\t\t\t &m, &n, pll);\n\tif (ret)\n\t\treturn ret;\n\n\tround = __pll_params_to_rate(req->best_parent_rate, m, n, 0, pll);\n\n\tif (!MESON_PARM_APPLICABLE(&pll->frac) || req->rate == round) {\n\t\treq->rate = round;\n\t\treturn 0;\n\t}\n\n\t \n\tfrac = __pll_params_with_frac(req->rate, req->best_parent_rate, m, n, pll);\n\treq->rate = __pll_params_to_rate(req->best_parent_rate, m, n, frac, pll);\n\n\treturn 0;\n}\n\nstatic int meson_clk_pll_wait_lock(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_pll_data *pll = meson_clk_pll_data(clk);\n\tint delay = 5000;\n\n\tdo {\n\t\t \n\t\tif (meson_parm_read(clk->map, &pll->l))\n\t\t\treturn 0;\n\n\t\tudelay(20);\n\t} while (--delay);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int meson_clk_pll_init(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_pll_data *pll = meson_clk_pll_data(clk);\n\n\tif (pll->init_count) {\n\t\tif (MESON_PARM_APPLICABLE(&pll->rst))\n\t\t\tmeson_parm_write(clk->map, &pll->rst, 1);\n\n\t\tregmap_multi_reg_write(clk->map, pll->init_regs,\n\t\t\t\t       pll->init_count);\n\n\t\tif (MESON_PARM_APPLICABLE(&pll->rst))\n\t\t\tmeson_parm_write(clk->map, &pll->rst, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int meson_clk_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_pll_data *pll = meson_clk_pll_data(clk);\n\n\tif (MESON_PARM_APPLICABLE(&pll->rst) &&\n\t    meson_parm_read(clk->map, &pll->rst))\n\t\treturn 0;\n\n\tif (!meson_parm_read(clk->map, &pll->en) ||\n\t    !meson_parm_read(clk->map, &pll->l))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int meson_clk_pcie_pll_enable(struct clk_hw *hw)\n{\n\tint retries = 10;\n\n\tdo {\n\t\tmeson_clk_pll_init(hw);\n\t\tif (!meson_clk_pll_wait_lock(hw))\n\t\t\treturn 0;\n\t\tpr_info(\"Retry enabling PCIe PLL clock\\n\");\n\t} while (--retries);\n\n\treturn -EIO;\n}\n\nstatic int meson_clk_pll_enable(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_pll_data *pll = meson_clk_pll_data(clk);\n\n\t \n\tif (clk_hw_is_enabled(hw))\n\t\treturn 0;\n\n\t \n\tif (MESON_PARM_APPLICABLE(&pll->rst))\n\t\tmeson_parm_write(clk->map, &pll->rst, 1);\n\n\t \n\tmeson_parm_write(clk->map, &pll->en, 1);\n\n\t \n\tif (MESON_PARM_APPLICABLE(&pll->rst))\n\t\tmeson_parm_write(clk->map, &pll->rst, 0);\n\n\t \n\tif (MESON_PARM_APPLICABLE(&pll->current_en)) {\n\t\tudelay(10);\n\t\tmeson_parm_write(clk->map, &pll->current_en, 1);\n\t\tudelay(40);\n\t}\n\n\tif (MESON_PARM_APPLICABLE(&pll->l_detect)) {\n\t\tmeson_parm_write(clk->map, &pll->l_detect, 1);\n\t\tmeson_parm_write(clk->map, &pll->l_detect, 0);\n\t}\n\n\tif (meson_clk_pll_wait_lock(hw))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void meson_clk_pll_disable(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_pll_data *pll = meson_clk_pll_data(clk);\n\n\t \n\tif (MESON_PARM_APPLICABLE(&pll->rst))\n\t\tmeson_parm_write(clk->map, &pll->rst, 1);\n\n\t \n\tmeson_parm_write(clk->map, &pll->en, 0);\n\n\t \n\tif (MESON_PARM_APPLICABLE(&pll->current_en))\n\t\tmeson_parm_write(clk->map, &pll->current_en, 0);\n}\n\nstatic int meson_clk_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_pll_data *pll = meson_clk_pll_data(clk);\n\tunsigned int enabled, m, n, frac = 0;\n\tunsigned long old_rate;\n\tint ret;\n\n\tif (parent_rate == 0 || rate == 0)\n\t\treturn -EINVAL;\n\n\told_rate = clk_hw_get_rate(hw);\n\n\tret = meson_clk_get_pll_settings(rate, parent_rate, &m, &n, pll);\n\tif (ret)\n\t\treturn ret;\n\n\tenabled = meson_parm_read(clk->map, &pll->en);\n\tif (enabled)\n\t\tmeson_clk_pll_disable(hw);\n\n\tmeson_parm_write(clk->map, &pll->n, n);\n\tmeson_parm_write(clk->map, &pll->m, m);\n\n\tif (MESON_PARM_APPLICABLE(&pll->frac)) {\n\t\tfrac = __pll_params_with_frac(rate, parent_rate, m, n, pll);\n\t\tmeson_parm_write(clk->map, &pll->frac, frac);\n\t}\n\n\t \n\tif (!enabled)\n\t\treturn 0;\n\n\tret = meson_clk_pll_enable(hw);\n\tif (ret) {\n\t\tpr_warn(\"%s: pll did not lock, trying to restore old rate %lu\\n\",\n\t\t\t__func__, old_rate);\n\t\t \n\t\tmeson_clk_pll_set_rate(hw, old_rate, parent_rate);\n\t}\n\n\treturn ret;\n}\n\n \nconst struct clk_ops meson_clk_pcie_pll_ops = {\n\t.recalc_rate\t= meson_clk_pll_recalc_rate,\n\t.determine_rate\t= meson_clk_pll_determine_rate,\n\t.is_enabled\t= meson_clk_pll_is_enabled,\n\t.enable\t\t= meson_clk_pcie_pll_enable,\n\t.disable\t= meson_clk_pll_disable\n};\nEXPORT_SYMBOL_GPL(meson_clk_pcie_pll_ops);\n\nconst struct clk_ops meson_clk_pll_ops = {\n\t.init\t\t= meson_clk_pll_init,\n\t.recalc_rate\t= meson_clk_pll_recalc_rate,\n\t.determine_rate\t= meson_clk_pll_determine_rate,\n\t.set_rate\t= meson_clk_pll_set_rate,\n\t.is_enabled\t= meson_clk_pll_is_enabled,\n\t.enable\t\t= meson_clk_pll_enable,\n\t.disable\t= meson_clk_pll_disable\n};\nEXPORT_SYMBOL_GPL(meson_clk_pll_ops);\n\nconst struct clk_ops meson_clk_pll_ro_ops = {\n\t.recalc_rate\t= meson_clk_pll_recalc_rate,\n\t.is_enabled\t= meson_clk_pll_is_enabled,\n};\nEXPORT_SYMBOL_GPL(meson_clk_pll_ro_ops);\n\nMODULE_DESCRIPTION(\"Amlogic PLL driver\");\nMODULE_AUTHOR(\"Carlo Caione <carlo@endlessm.com>\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}