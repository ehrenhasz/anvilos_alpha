{
  "module_name": "clk-mpll.c",
  "hash_id": "069d7a8c739be40b820be8dc098b6a62be2e10c618f356e2b6767aa68fd9e3dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/meson/clk-mpll.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk-provider.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n\n#include \"clk-regmap.h\"\n#include \"clk-mpll.h\"\n\n#define SDM_DEN 16384\n#define N2_MIN\t4\n#define N2_MAX\t511\n\nstatic inline struct meson_clk_mpll_data *\nmeson_clk_mpll_data(struct clk_regmap *clk)\n{\n\treturn (struct meson_clk_mpll_data *)clk->data;\n}\n\nstatic long rate_from_params(unsigned long parent_rate,\n\t\t\t     unsigned int sdm,\n\t\t\t     unsigned int n2)\n{\n\tunsigned long divisor = (SDM_DEN * n2) + sdm;\n\n\tif (n2 < N2_MIN)\n\t\treturn -EINVAL;\n\n\treturn DIV_ROUND_UP_ULL((u64)parent_rate * SDM_DEN, divisor);\n}\n\nstatic void params_from_rate(unsigned long requested_rate,\n\t\t\t     unsigned long parent_rate,\n\t\t\t     unsigned int *sdm,\n\t\t\t     unsigned int *n2,\n\t\t\t     u8 flags)\n{\n\tuint64_t div = parent_rate;\n\tuint64_t frac = do_div(div, requested_rate);\n\n\tfrac *= SDM_DEN;\n\n\tif (flags & CLK_MESON_MPLL_ROUND_CLOSEST)\n\t\t*sdm = DIV_ROUND_CLOSEST_ULL(frac, requested_rate);\n\telse\n\t\t*sdm = DIV_ROUND_UP_ULL(frac, requested_rate);\n\n\tif (*sdm == SDM_DEN) {\n\t\t*sdm = 0;\n\t\tdiv += 1;\n\t}\n\n\tif (div < N2_MIN) {\n\t\t*n2 = N2_MIN;\n\t\t*sdm = 0;\n\t} else if (div > N2_MAX) {\n\t\t*n2 = N2_MAX;\n\t\t*sdm = SDM_DEN - 1;\n\t} else {\n\t\t*n2 = div;\n\t}\n}\n\nstatic unsigned long mpll_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_mpll_data *mpll = meson_clk_mpll_data(clk);\n\tunsigned int sdm, n2;\n\tlong rate;\n\n\tsdm = meson_parm_read(clk->map, &mpll->sdm);\n\tn2 = meson_parm_read(clk->map, &mpll->n2);\n\n\trate = rate_from_params(parent_rate, sdm, n2);\n\treturn rate < 0 ? 0 : rate;\n}\n\nstatic int mpll_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_mpll_data *mpll = meson_clk_mpll_data(clk);\n\tunsigned int sdm, n2;\n\tlong rate;\n\n\tparams_from_rate(req->rate, req->best_parent_rate, &sdm, &n2,\n\t\t\t mpll->flags);\n\n\trate = rate_from_params(req->best_parent_rate, sdm, n2);\n\tif (rate < 0)\n\t\treturn rate;\n\n\treq->rate = rate;\n\treturn 0;\n}\n\nstatic int mpll_set_rate(struct clk_hw *hw,\n\t\t\t unsigned long rate,\n\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_mpll_data *mpll = meson_clk_mpll_data(clk);\n\tunsigned int sdm, n2;\n\tunsigned long flags = 0;\n\n\tparams_from_rate(rate, parent_rate, &sdm, &n2, mpll->flags);\n\n\tif (mpll->lock)\n\t\tspin_lock_irqsave(mpll->lock, flags);\n\telse\n\t\t__acquire(mpll->lock);\n\n\t \n\tmeson_parm_write(clk->map, &mpll->sdm, sdm);\n\n\t \n\tmeson_parm_write(clk->map, &mpll->n2, n2);\n\n\tif (mpll->lock)\n\t\tspin_unlock_irqrestore(mpll->lock, flags);\n\telse\n\t\t__release(mpll->lock);\n\n\treturn 0;\n}\n\nstatic int mpll_init(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_clk_mpll_data *mpll = meson_clk_mpll_data(clk);\n\n\tif (mpll->init_count)\n\t\tregmap_multi_reg_write(clk->map, mpll->init_regs,\n\t\t\t\t       mpll->init_count);\n\n\t \n\tmeson_parm_write(clk->map, &mpll->sdm_en, 1);\n\n\t \n\tif (MESON_PARM_APPLICABLE(&mpll->ssen)) {\n\t\tunsigned int ss =\n\t\t\tmpll->flags & CLK_MESON_MPLL_SPREAD_SPECTRUM ? 1 : 0;\n\t\tmeson_parm_write(clk->map, &mpll->ssen, ss);\n\t}\n\n\t \n\tif (MESON_PARM_APPLICABLE(&mpll->misc))\n\t\tmeson_parm_write(clk->map, &mpll->misc, 1);\n\n\treturn 0;\n}\n\nconst struct clk_ops meson_clk_mpll_ro_ops = {\n\t.recalc_rate\t= mpll_recalc_rate,\n\t.determine_rate\t= mpll_determine_rate,\n};\nEXPORT_SYMBOL_GPL(meson_clk_mpll_ro_ops);\n\nconst struct clk_ops meson_clk_mpll_ops = {\n\t.recalc_rate\t= mpll_recalc_rate,\n\t.determine_rate\t= mpll_determine_rate,\n\t.set_rate\t= mpll_set_rate,\n\t.init\t\t= mpll_init,\n};\nEXPORT_SYMBOL_GPL(meson_clk_mpll_ops);\n\nMODULE_DESCRIPTION(\"Amlogic MPLL driver\");\nMODULE_AUTHOR(\"Michael Turquette <mturquette@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}