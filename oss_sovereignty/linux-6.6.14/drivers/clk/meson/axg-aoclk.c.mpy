{
  "module_name": "axg-aoclk.c",
  "hash_id": "5af35178b8bcda882408ea0a2d64a62baae43c88922a299cdf6f9f4186df5a9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/meson/axg-aoclk.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include \"meson-aoclk.h\"\n\n#include \"clk-regmap.h\"\n#include \"clk-dualdiv.h\"\n\n#include <dt-bindings/clock/axg-aoclkc.h>\n#include <dt-bindings/reset/axg-aoclkc.h>\n\n \n#define AO_RTI_PWR_CNTL_REG1\t0x0C\n#define AO_RTI_PWR_CNTL_REG0\t0x10\n#define AO_RTI_GEN_CNTL_REG0\t0x40\n#define AO_OSCIN_CNTL\t\t0x58\n#define AO_CRT_CLK_CNTL1\t0x68\n#define AO_SAR_CLK\t\t0x90\n#define AO_RTC_ALT_CLK_CNTL0\t0x94\n#define AO_RTC_ALT_CLK_CNTL1\t0x98\n\n#define AXG_AO_GATE(_name, _bit)\t\t\t\t\t\\\nstatic struct clk_regmap axg_aoclk_##_name = {\t\t\t\t\\\n\t.data = &(struct clk_regmap_gate_data) {\t\t\t\\\n\t\t.offset = (AO_RTI_GEN_CNTL_REG0),\t\t\t\\\n\t\t.bit_idx = (_bit),\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.hw.init = &(struct clk_init_data) {\t\t\t\t\\\n\t\t.name =  \"axg_ao_\" #_name,\t\t\t\t\\\n\t\t.ops = &clk_regmap_gate_ops,\t\t\t\t\\\n\t\t.parent_data = &(const struct clk_parent_data) {\t\\\n\t\t\t.fw_name = \"mpeg-clk\",\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.num_parents = 1,\t\t\t\t\t\\\n\t\t.flags = CLK_IGNORE_UNUSED,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nAXG_AO_GATE(remote, 0);\nAXG_AO_GATE(i2c_master, 1);\nAXG_AO_GATE(i2c_slave, 2);\nAXG_AO_GATE(uart1, 3);\nAXG_AO_GATE(uart2, 5);\nAXG_AO_GATE(ir_blaster, 6);\nAXG_AO_GATE(saradc, 7);\n\nstatic struct clk_regmap axg_aoclk_cts_oscin = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = AO_RTI_PWR_CNTL_REG0,\n\t\t.bit_idx = 14,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"cts_oscin\",\n\t\t.ops = &clk_regmap_gate_ro_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap axg_aoclk_32k_pre = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = AO_RTC_ALT_CLK_CNTL0,\n\t\t.bit_idx = 31,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"axg_ao_32k_pre\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&axg_aoclk_cts_oscin.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic const struct meson_clk_dualdiv_param axg_32k_div_table[] = {\n\t{\n\t\t.dual\t= 1,\n\t\t.n1\t= 733,\n\t\t.m1\t= 8,\n\t\t.n2\t= 732,\n\t\t.m2\t= 11,\n\t}, {}\n};\n\nstatic struct clk_regmap axg_aoclk_32k_div = {\n\t.data = &(struct meson_clk_dualdiv_data){\n\t\t.n1 = {\n\t\t\t.reg_off = AO_RTC_ALT_CLK_CNTL0,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.n2 = {\n\t\t\t.reg_off = AO_RTC_ALT_CLK_CNTL0,\n\t\t\t.shift   = 12,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.m1 = {\n\t\t\t.reg_off = AO_RTC_ALT_CLK_CNTL1,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.m2 = {\n\t\t\t.reg_off = AO_RTC_ALT_CLK_CNTL1,\n\t\t\t.shift   = 12,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.dual = {\n\t\t\t.reg_off = AO_RTC_ALT_CLK_CNTL0,\n\t\t\t.shift   = 28,\n\t\t\t.width   = 1,\n\t\t},\n\t\t.table = axg_32k_div_table,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"axg_ao_32k_div\",\n\t\t.ops = &meson_clk_dualdiv_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&axg_aoclk_32k_pre.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap axg_aoclk_32k_sel = {\n\t.data = &(struct clk_regmap_mux_data) {\n\t\t.offset = AO_RTC_ALT_CLK_CNTL1,\n\t\t.mask = 0x1,\n\t\t.shift = 24,\n\t\t.flags = CLK_MUX_ROUND_CLOSEST,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"axg_ao_32k_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&axg_aoclk_32k_div.hw,\n\t\t\t&axg_aoclk_32k_pre.hw,\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap axg_aoclk_32k = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = AO_RTC_ALT_CLK_CNTL0,\n\t\t.bit_idx = 30,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"axg_ao_32k\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&axg_aoclk_32k_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap axg_aoclk_cts_rtc_oscin = {\n\t.data = &(struct clk_regmap_mux_data) {\n\t\t.offset = AO_RTI_PWR_CNTL_REG0,\n\t\t.mask = 0x1,\n\t\t.shift = 10,\n\t\t.flags = CLK_MUX_ROUND_CLOSEST,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"axg_ao_cts_rtc_oscin\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = (const struct clk_parent_data []) {\n\t\t\t{ .hw = &axg_aoclk_32k.hw },\n\t\t\t{ .fw_name = \"ext_32k-0\", },\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap axg_aoclk_clk81 = {\n\t.data = &(struct clk_regmap_mux_data) {\n\t\t.offset = AO_RTI_PWR_CNTL_REG0,\n\t\t.mask = 0x1,\n\t\t.shift = 8,\n\t\t.flags = CLK_MUX_ROUND_CLOSEST,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"axg_ao_clk81\",\n\t\t.ops = &clk_regmap_mux_ro_ops,\n\t\t.parent_data = (const struct clk_parent_data []) {\n\t\t\t{ .fw_name = \"mpeg-clk\", },\n\t\t\t{ .hw = &axg_aoclk_cts_rtc_oscin.hw },\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap axg_aoclk_saradc_mux = {\n\t.data = &(struct clk_regmap_mux_data) {\n\t\t.offset = AO_SAR_CLK,\n\t\t.mask = 0x3,\n\t\t.shift = 9,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"axg_ao_saradc_mux\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = (const struct clk_parent_data []) {\n\t\t\t{ .fw_name = \"xtal\", },\n\t\t\t{ .hw = &axg_aoclk_clk81.hw },\n\t\t},\n\t\t.num_parents = 2,\n\t},\n};\n\nstatic struct clk_regmap axg_aoclk_saradc_div = {\n\t.data = &(struct clk_regmap_div_data) {\n\t\t.offset = AO_SAR_CLK,\n\t\t.shift = 0,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"axg_ao_saradc_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&axg_aoclk_saradc_mux.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap axg_aoclk_saradc_gate = {\n\t.data = &(struct clk_regmap_gate_data) {\n\t\t.offset = AO_SAR_CLK,\n\t\t.bit_idx = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"axg_ao_saradc_gate\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&axg_aoclk_saradc_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic const unsigned int axg_aoclk_reset[] = {\n\t[RESET_AO_REMOTE]\t= 16,\n\t[RESET_AO_I2C_MASTER]\t= 18,\n\t[RESET_AO_I2C_SLAVE]\t= 19,\n\t[RESET_AO_UART1]\t= 17,\n\t[RESET_AO_UART2]\t= 22,\n\t[RESET_AO_IR_BLASTER]\t= 23,\n};\n\nstatic struct clk_regmap *axg_aoclk_regmap[] = {\n\t&axg_aoclk_remote,\n\t&axg_aoclk_i2c_master,\n\t&axg_aoclk_i2c_slave,\n\t&axg_aoclk_uart1,\n\t&axg_aoclk_uart2,\n\t&axg_aoclk_ir_blaster,\n\t&axg_aoclk_saradc,\n\t&axg_aoclk_cts_oscin,\n\t&axg_aoclk_32k_pre,\n\t&axg_aoclk_32k_div,\n\t&axg_aoclk_32k_sel,\n\t&axg_aoclk_32k,\n\t&axg_aoclk_cts_rtc_oscin,\n\t&axg_aoclk_clk81,\n\t&axg_aoclk_saradc_mux,\n\t&axg_aoclk_saradc_div,\n\t&axg_aoclk_saradc_gate,\n};\n\nstatic struct clk_hw *axg_aoclk_hw_clks[] = {\n\t[CLKID_AO_REMOTE]\t= &axg_aoclk_remote.hw,\n\t[CLKID_AO_I2C_MASTER]\t= &axg_aoclk_i2c_master.hw,\n\t[CLKID_AO_I2C_SLAVE]\t= &axg_aoclk_i2c_slave.hw,\n\t[CLKID_AO_UART1]\t= &axg_aoclk_uart1.hw,\n\t[CLKID_AO_UART2]\t= &axg_aoclk_uart2.hw,\n\t[CLKID_AO_IR_BLASTER]\t= &axg_aoclk_ir_blaster.hw,\n\t[CLKID_AO_SAR_ADC]\t= &axg_aoclk_saradc.hw,\n\t[CLKID_AO_CLK81]\t= &axg_aoclk_clk81.hw,\n\t[CLKID_AO_SAR_ADC_SEL]\t= &axg_aoclk_saradc_mux.hw,\n\t[CLKID_AO_SAR_ADC_DIV]\t= &axg_aoclk_saradc_div.hw,\n\t[CLKID_AO_SAR_ADC_CLK]\t= &axg_aoclk_saradc_gate.hw,\n\t[CLKID_AO_CTS_OSCIN]\t= &axg_aoclk_cts_oscin.hw,\n\t[CLKID_AO_32K_PRE]\t= &axg_aoclk_32k_pre.hw,\n\t[CLKID_AO_32K_DIV]\t= &axg_aoclk_32k_div.hw,\n\t[CLKID_AO_32K_SEL]\t= &axg_aoclk_32k_sel.hw,\n\t[CLKID_AO_32K]\t\t= &axg_aoclk_32k.hw,\n\t[CLKID_AO_CTS_RTC_OSCIN] = &axg_aoclk_cts_rtc_oscin.hw,\n};\n\nstatic const struct meson_aoclk_data axg_aoclkc_data = {\n\t.reset_reg\t= AO_RTI_GEN_CNTL_REG0,\n\t.num_reset\t= ARRAY_SIZE(axg_aoclk_reset),\n\t.reset\t\t= axg_aoclk_reset,\n\t.num_clks\t= ARRAY_SIZE(axg_aoclk_regmap),\n\t.clks\t\t= axg_aoclk_regmap,\n\t.hw_clks\t= {\n\t\t.hws\t= axg_aoclk_hw_clks,\n\t\t.num\t= ARRAY_SIZE(axg_aoclk_hw_clks),\n\t},\n};\n\nstatic const struct of_device_id axg_aoclkc_match_table[] = {\n\t{\n\t\t.compatible\t= \"amlogic,meson-axg-aoclkc\",\n\t\t.data\t\t= &axg_aoclkc_data,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, axg_aoclkc_match_table);\n\nstatic struct platform_driver axg_aoclkc_driver = {\n\t.probe\t\t= meson_aoclkc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"axg-aoclkc\",\n\t\t.of_match_table = axg_aoclkc_match_table,\n\t},\n};\n\nmodule_platform_driver(axg_aoclkc_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}