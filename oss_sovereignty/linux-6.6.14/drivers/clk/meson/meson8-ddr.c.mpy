{
  "module_name": "meson8-ddr.c",
  "hash_id": "edabcc29f902491ac8d7b5471630e7dbc5e9b1db6da647d65df51d2608bf51f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/meson/meson8-ddr.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/clock/meson8-ddr-clkc.h>\n\n#include <linux/clk-provider.h>\n#include <linux/platform_device.h>\n\n#include \"clk-regmap.h\"\n#include \"clk-pll.h\"\n\n#define AM_DDR_PLL_CNTL\t\t\t0x00\n#define AM_DDR_PLL_CNTL1\t\t0x04\n#define AM_DDR_PLL_CNTL2\t\t0x08\n#define AM_DDR_PLL_CNTL3\t\t0x0c\n#define AM_DDR_PLL_CNTL4\t\t0x10\n#define AM_DDR_PLL_STS\t\t\t0x14\n#define DDR_CLK_CNTL\t\t\t0x18\n#define DDR_CLK_STS\t\t\t0x1c\n\nstatic struct clk_regmap meson8_ddr_pll_dco = {\n\t.data = &(struct meson_clk_pll_data){\n\t\t.en = {\n\t\t\t.reg_off = AM_DDR_PLL_CNTL,\n\t\t\t.shift   = 30,\n\t\t\t.width   = 1,\n\t\t},\n\t\t.m = {\n\t\t\t.reg_off = AM_DDR_PLL_CNTL,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 9,\n\t\t},\n\t\t.n = {\n\t\t\t.reg_off = AM_DDR_PLL_CNTL,\n\t\t\t.shift   = 9,\n\t\t\t.width   = 5,\n\t\t},\n\t\t.l = {\n\t\t\t.reg_off = AM_DDR_PLL_CNTL,\n\t\t\t.shift   = 31,\n\t\t\t.width   = 1,\n\t\t},\n\t\t.rst = {\n\t\t\t.reg_off = AM_DDR_PLL_CNTL,\n\t\t\t.shift   = 29,\n\t\t\t.width   = 1,\n\t\t},\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ddr_pll_dco\",\n\t\t.ops = &meson_clk_pll_ro_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap meson8_ddr_pll = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = AM_DDR_PLL_CNTL,\n\t\t.shift = 16,\n\t\t.width = 2,\n\t\t.flags = CLK_DIVIDER_POWER_OF_TWO,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ddr_pll\",\n\t\t.ops = &clk_regmap_divider_ro_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&meson8_ddr_pll_dco.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_hw_onecell_data meson8_ddr_clk_hw_onecell_data = {\n\t.hws = {\n\t\t[DDR_CLKID_DDR_PLL_DCO]\t\t= &meson8_ddr_pll_dco.hw,\n\t\t[DDR_CLKID_DDR_PLL]\t\t= &meson8_ddr_pll.hw,\n\t},\n\t.num = 2,\n};\n\nstatic struct clk_regmap *const meson8_ddr_clk_regmaps[] = {\n\t&meson8_ddr_pll_dco,\n\t&meson8_ddr_pll,\n};\n\nstatic const struct regmap_config meson8_ddr_clkc_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = DDR_CLK_STS,\n};\n\nstatic int meson8_ddr_clkc_probe(struct platform_device *pdev)\n{\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tstruct clk_hw *hw;\n\tint ret, i;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t       &meson8_ddr_clkc_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(meson8_ddr_clk_regmaps); i++)\n\t\tmeson8_ddr_clk_regmaps[i]->map = regmap;\n\n\t \n\tfor (i = 0; i < meson8_ddr_clk_hw_onecell_data.num; i++) {\n\t\thw = meson8_ddr_clk_hw_onecell_data.hws[i];\n\n\t\tret = devm_clk_hw_register(&pdev->dev, hw);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Clock registration failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, of_clk_hw_onecell_get,\n\t\t\t\t\t   &meson8_ddr_clk_hw_onecell_data);\n}\n\nstatic const struct of_device_id meson8_ddr_clkc_match_table[] = {\n\t{ .compatible = \"amlogic,meson8-ddr-clkc\" },\n\t{ .compatible = \"amlogic,meson8b-ddr-clkc\" },\n\t{   }\n};\n\nstatic struct platform_driver meson8_ddr_clkc_driver = {\n\t.probe\t\t= meson8_ddr_clkc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"meson8-ddr-clkc\",\n\t\t.of_match_table = meson8_ddr_clkc_match_table,\n\t},\n};\n\nbuiltin_platform_driver(meson8_ddr_clkc_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}