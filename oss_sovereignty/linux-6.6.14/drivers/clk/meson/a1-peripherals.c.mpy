{
  "module_name": "a1-peripherals.c",
  "hash_id": "4f9e08c2a4461c70713c5fc9692cfd354c70643cc08bfcf1366e3713a8f01bb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/meson/a1-peripherals.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include \"a1-peripherals.h\"\n#include \"clk-dualdiv.h\"\n#include \"clk-regmap.h\"\n#include \"meson-clkc-utils.h\"\n\n#include <dt-bindings/clock/amlogic,a1-peripherals-clkc.h>\n\nstatic struct clk_regmap xtal_in = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = SYS_OSCIN_CTRL,\n\t\t.bit_idx = 0,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"xtal_in\",\n\t\t.ops = &clk_regmap_gate_ro_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap fixpll_in = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = SYS_OSCIN_CTRL,\n\t\t.bit_idx = 1,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"fixpll_in\",\n\t\t.ops = &clk_regmap_gate_ro_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap usb_phy_in = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = SYS_OSCIN_CTRL,\n\t\t.bit_idx = 2,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"usb_phy_in\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap usb_ctrl_in = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = SYS_OSCIN_CTRL,\n\t\t.bit_idx = 3,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"usb_ctrl_in\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap hifipll_in = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = SYS_OSCIN_CTRL,\n\t\t.bit_idx = 4,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"hifipll_in\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap syspll_in = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = SYS_OSCIN_CTRL,\n\t\t.bit_idx = 5,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"syspll_in\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap dds_in = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = SYS_OSCIN_CTRL,\n\t\t.bit_idx = 6,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"dds_in\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap rtc_32k_in = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = RTC_BY_OSCIN_CTRL0,\n\t\t.bit_idx = 31,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"rtc_32k_in\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic const struct meson_clk_dualdiv_param clk_32k_div_table[] = {\n\t{\n\t\t.dual\t\t= 1,\n\t\t.n1\t\t= 733,\n\t\t.m1\t\t= 8,\n\t\t.n2\t\t= 732,\n\t\t.m2\t\t= 11,\n\t},\n\t{}\n};\n\nstatic struct clk_regmap rtc_32k_div = {\n\t.data = &(struct meson_clk_dualdiv_data){\n\t\t.n1 = {\n\t\t\t.reg_off = RTC_BY_OSCIN_CTRL0,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.n2 = {\n\t\t\t.reg_off = RTC_BY_OSCIN_CTRL0,\n\t\t\t.shift   = 12,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.m1 = {\n\t\t\t.reg_off = RTC_BY_OSCIN_CTRL1,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.m2 = {\n\t\t\t.reg_off = RTC_BY_OSCIN_CTRL1,\n\t\t\t.shift   = 12,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.dual = {\n\t\t\t.reg_off = RTC_BY_OSCIN_CTRL0,\n\t\t\t.shift   = 28,\n\t\t\t.width   = 1,\n\t\t},\n\t\t.table = clk_32k_div_table,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"rtc_32k_div\",\n\t\t.ops = &meson_clk_dualdiv_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&rtc_32k_in.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap rtc_32k_xtal = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = RTC_BY_OSCIN_CTRL1,\n\t\t.bit_idx = 24,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"rtc_32k_xtal\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&rtc_32k_in.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap rtc_32k_sel = {\n\t.data = &(struct clk_regmap_mux_data) {\n\t\t.offset = RTC_CTRL,\n\t\t.mask = 0x3,\n\t\t.shift = 0,\n\t\t.flags = CLK_MUX_ROUND_CLOSEST,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"rtc_32k_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&rtc_32k_xtal.hw,\n\t\t\t&rtc_32k_div.hw,\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap rtc = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = RTC_BY_OSCIN_CTRL0,\n\t\t.bit_idx = 30,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"rtc\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&rtc_32k_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic u32 mux_table_sys[] = { 0, 1, 2, 3, 7 };\nstatic const struct clk_parent_data sys_parents[] = {\n\t{ .fw_name = \"xtal\" },\n\t{ .fw_name = \"fclk_div2\" },\n\t{ .fw_name = \"fclk_div3\" },\n\t{ .fw_name = \"fclk_div5\" },\n\t{ .hw = &rtc.hw },\n};\n\nstatic struct clk_regmap sys_b_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = SYS_CLK_CTRL0,\n\t\t.mask = 0x7,\n\t\t.shift = 26,\n\t\t.table = mux_table_sys,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"sys_b_sel\",\n\t\t.ops = &clk_regmap_mux_ro_ops,\n\t\t.parent_data = sys_parents,\n\t\t.num_parents = ARRAY_SIZE(sys_parents),\n\t},\n};\n\nstatic struct clk_regmap sys_b_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = SYS_CLK_CTRL0,\n\t\t.shift = 16,\n\t\t.width = 10,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"sys_b_div\",\n\t\t.ops = &clk_regmap_divider_ro_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&sys_b_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap sys_b = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = SYS_CLK_CTRL0,\n\t\t.bit_idx = 29,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"sys_b\",\n\t\t.ops = &clk_regmap_gate_ro_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&sys_b_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap sys_a_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = SYS_CLK_CTRL0,\n\t\t.mask = 0x7,\n\t\t.shift = 10,\n\t\t.table = mux_table_sys,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"sys_a_sel\",\n\t\t.ops = &clk_regmap_mux_ro_ops,\n\t\t.parent_data = sys_parents,\n\t\t.num_parents = ARRAY_SIZE(sys_parents),\n\t},\n};\n\nstatic struct clk_regmap sys_a_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = SYS_CLK_CTRL0,\n\t\t.shift = 0,\n\t\t.width = 10,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"sys_a_div\",\n\t\t.ops = &clk_regmap_divider_ro_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&sys_a_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap sys_a = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = SYS_CLK_CTRL0,\n\t\t.bit_idx = 13,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"sys_a\",\n\t\t.ops = &clk_regmap_gate_ro_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&sys_a_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap sys = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = SYS_CLK_CTRL0,\n\t\t.mask = 0x1,\n\t\t.shift = 31,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"sys\",\n\t\t.ops = &clk_regmap_mux_ro_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&sys_a.hw,\n\t\t\t&sys_b.hw,\n\t\t},\n\t\t.num_parents = 2,\n\t\t \n\t\t.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,\n\t},\n};\n\nstatic u32 mux_table_dsp_ab[] = { 0, 1, 2, 3, 4, 7 };\nstatic const struct clk_parent_data dsp_ab_parent_data[] = {\n\t{ .fw_name = \"xtal\", },\n\t{ .fw_name = \"fclk_div2\", },\n\t{ .fw_name = \"fclk_div3\", },\n\t{ .fw_name = \"fclk_div5\", },\n\t{ .fw_name = \"hifi_pll\", },\n\t{ .hw = &rtc.hw },\n};\n\nstatic struct clk_regmap dspa_a_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = DSPA_CLK_CTRL0,\n\t\t.mask = 0x7,\n\t\t.shift = 10,\n\t\t.table = mux_table_dsp_ab,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"dspa_a_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = dsp_ab_parent_data,\n\t\t.num_parents = ARRAY_SIZE(dsp_ab_parent_data),\n\t},\n};\n\nstatic struct clk_regmap dspa_a_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = DSPA_CLK_CTRL0,\n\t\t.shift = 0,\n\t\t.width = 10,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"dspa_a_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dspa_a_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dspa_a = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = DSPA_CLK_CTRL0,\n\t\t.bit_idx = 13,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"dspa_a\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dspa_a_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dspa_b_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = DSPA_CLK_CTRL0,\n\t\t.mask = 0x7,\n\t\t.shift = 26,\n\t\t.table = mux_table_dsp_ab,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"dspa_b_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = dsp_ab_parent_data,\n\t\t.num_parents = ARRAY_SIZE(dsp_ab_parent_data),\n\t},\n};\n\nstatic struct clk_regmap dspa_b_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = DSPA_CLK_CTRL0,\n\t\t.shift = 16,\n\t\t.width = 10,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"dspa_b_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dspa_b_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dspa_b = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = DSPA_CLK_CTRL0,\n\t\t.bit_idx = 29,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"dspa_b\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dspa_b_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dspa_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = DSPA_CLK_CTRL0,\n\t\t.mask = 0x1,\n\t\t.shift = 15,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"dspa_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dspa_a.hw,\n\t\t\t&dspa_b.hw,\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dspa_en = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = DSPA_CLK_EN,\n\t\t.bit_idx = 1,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"dspa_en\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dspa_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dspa_en_nic = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = DSPA_CLK_EN,\n\t\t.bit_idx = 0,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"dspa_en_nic\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dspa_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dspb_a_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = DSPB_CLK_CTRL0,\n\t\t.mask = 0x7,\n\t\t.shift = 10,\n\t\t.table = mux_table_dsp_ab,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"dspb_a_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = dsp_ab_parent_data,\n\t\t.num_parents = ARRAY_SIZE(dsp_ab_parent_data),\n\t},\n};\n\nstatic struct clk_regmap dspb_a_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = DSPB_CLK_CTRL0,\n\t\t.shift = 0,\n\t\t.width = 10,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"dspb_a_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dspb_a_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dspb_a = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = DSPB_CLK_CTRL0,\n\t\t.bit_idx = 13,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"dspb_a\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dspb_a_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dspb_b_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = DSPB_CLK_CTRL0,\n\t\t.mask = 0x7,\n\t\t.shift = 26,\n\t\t.table = mux_table_dsp_ab,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"dspb_b_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = dsp_ab_parent_data,\n\t\t.num_parents = ARRAY_SIZE(dsp_ab_parent_data),\n\t},\n};\n\nstatic struct clk_regmap dspb_b_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = DSPB_CLK_CTRL0,\n\t\t.shift = 16,\n\t\t.width = 10,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"dspb_b_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dspb_b_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dspb_b = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = DSPB_CLK_CTRL0,\n\t\t.bit_idx = 29,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"dspb_b\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dspb_b_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dspb_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = DSPB_CLK_CTRL0,\n\t\t.mask = 0x1,\n\t\t.shift = 15,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"dspb_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dspb_a.hw,\n\t\t\t&dspb_b.hw,\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dspb_en = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = DSPB_CLK_EN,\n\t\t.bit_idx = 1,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"dspb_en\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dspb_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dspb_en_nic = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = DSPB_CLK_EN,\n\t\t.bit_idx = 0,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"dspb_en_nic\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dspb_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap clk_24m = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = CLK12_24_CTRL,\n\t\t.bit_idx = 11,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"24m\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_fixed_factor clk_24m_div2 = {\n\t.mult = 1,\n\t.div = 2,\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"24m_div2\",\n\t\t.ops = &clk_fixed_factor_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&clk_24m.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap clk_12m = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = CLK12_24_CTRL,\n\t\t.bit_idx = 10,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"12m\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&clk_24m_div2.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap fclk_div2_divn_pre = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = CLK12_24_CTRL,\n\t\t.shift = 0,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"fclk_div2_divn_pre\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"fclk_div2\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap fclk_div2_divn = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = CLK12_24_CTRL,\n\t\t.bit_idx = 12,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"fclk_div2_divn\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&fclk_div2_divn_pre.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\n \nstatic u32 gen_table[] = { 0, 1, 3, 5, 6, 7, 8 };\nstatic const struct clk_parent_data gen_parent_data[] = {\n\t{ .fw_name = \"xtal\", },\n\t{ .hw = &rtc.hw },\n\t{ .fw_name = \"hifi_pll\", },\n\t{ .fw_name = \"fclk_div2\", },\n\t{ .fw_name = \"fclk_div3\", },\n\t{ .fw_name = \"fclk_div5\", },\n\t{ .fw_name = \"fclk_div7\", },\n};\n\nstatic struct clk_regmap gen_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = GEN_CLK_CTRL,\n\t\t.mask = 0xf,\n\t\t.shift = 12,\n\t\t.table = gen_table,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"gen_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = gen_parent_data,\n\t\t.num_parents = ARRAY_SIZE(gen_parent_data),\n\t\t \n\t\t.flags = CLK_SET_RATE_NO_REPARENT,\n\t},\n};\n\nstatic struct clk_regmap gen_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = GEN_CLK_CTRL,\n\t\t.shift = 0,\n\t\t.width = 11,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"gen_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&gen_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap gen = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = GEN_CLK_CTRL,\n\t\t.bit_idx = 11,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"gen\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&gen_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap saradc_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = SAR_ADC_CLK_CTRL,\n\t\t.mask = 0x1,\n\t\t.shift = 9,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"saradc_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = (const struct clk_parent_data []) {\n\t\t\t{ .fw_name = \"xtal\", },\n\t\t\t{ .hw = &sys.hw, },\n\t\t},\n\t\t.num_parents = 2,\n\t},\n};\n\nstatic struct clk_regmap saradc_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = SAR_ADC_CLK_CTRL,\n\t\t.shift = 0,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"saradc_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&saradc_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap saradc = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = SAR_ADC_CLK_CTRL,\n\t\t.bit_idx = 8,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"saradc\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&saradc_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic const struct clk_parent_data pwm_abcd_parents[] = {\n\t{ .fw_name = \"xtal\", },\n\t{ .hw = &sys.hw },\n\t{ .hw = &rtc.hw },\n};\n\nstatic struct clk_regmap pwm_a_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = PWM_CLK_AB_CTRL,\n\t\t.mask = 0x1,\n\t\t.shift = 9,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwm_a_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = pwm_abcd_parents,\n\t\t.num_parents = ARRAY_SIZE(pwm_abcd_parents),\n\t},\n};\n\nstatic struct clk_regmap pwm_a_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = PWM_CLK_AB_CTRL,\n\t\t.shift = 0,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwm_a_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&pwm_a_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap pwm_a = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = PWM_CLK_AB_CTRL,\n\t\t.bit_idx = 8,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"pwm_a\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&pwm_a_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap pwm_b_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = PWM_CLK_AB_CTRL,\n\t\t.mask = 0x1,\n\t\t.shift = 25,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwm_b_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = pwm_abcd_parents,\n\t\t.num_parents = ARRAY_SIZE(pwm_abcd_parents),\n\t},\n};\n\nstatic struct clk_regmap pwm_b_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = PWM_CLK_AB_CTRL,\n\t\t.shift = 16,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwm_b_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&pwm_b_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap pwm_b = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = PWM_CLK_AB_CTRL,\n\t\t.bit_idx = 24,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"pwm_b\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&pwm_b_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap pwm_c_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = PWM_CLK_CD_CTRL,\n\t\t.mask = 0x1,\n\t\t.shift = 9,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwm_c_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = pwm_abcd_parents,\n\t\t.num_parents = ARRAY_SIZE(pwm_abcd_parents),\n\t},\n};\n\nstatic struct clk_regmap pwm_c_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = PWM_CLK_CD_CTRL,\n\t\t.shift = 0,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwm_c_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&pwm_c_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap pwm_c = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = PWM_CLK_CD_CTRL,\n\t\t.bit_idx = 8,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"pwm_c\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&pwm_c_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap pwm_d_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = PWM_CLK_CD_CTRL,\n\t\t.mask = 0x1,\n\t\t.shift = 25,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwm_d_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = pwm_abcd_parents,\n\t\t.num_parents = ARRAY_SIZE(pwm_abcd_parents),\n\t},\n};\n\nstatic struct clk_regmap pwm_d_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = PWM_CLK_CD_CTRL,\n\t\t.shift = 16,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwm_d_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&pwm_d_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap pwm_d = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = PWM_CLK_CD_CTRL,\n\t\t.bit_idx = 24,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"pwm_d\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&pwm_d_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic const struct clk_parent_data pwm_ef_parents[] = {\n\t{ .fw_name = \"xtal\", },\n\t{ .hw = &sys.hw },\n\t{ .fw_name = \"fclk_div5\", },\n\t{ .hw = &rtc.hw },\n};\n\nstatic struct clk_regmap pwm_e_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = PWM_CLK_EF_CTRL,\n\t\t.mask = 0x3,\n\t\t.shift = 9,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwm_e_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = pwm_ef_parents,\n\t\t.num_parents = ARRAY_SIZE(pwm_ef_parents),\n\t},\n};\n\nstatic struct clk_regmap pwm_e_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = PWM_CLK_EF_CTRL,\n\t\t.shift = 0,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwm_e_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&pwm_e_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap pwm_e = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = PWM_CLK_EF_CTRL,\n\t\t.bit_idx = 8,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"pwm_e\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&pwm_e_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap pwm_f_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = PWM_CLK_EF_CTRL,\n\t\t.mask = 0x3,\n\t\t.shift = 25,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwm_f_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = pwm_ef_parents,\n\t\t.num_parents = ARRAY_SIZE(pwm_ef_parents),\n\t},\n};\n\nstatic struct clk_regmap pwm_f_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = PWM_CLK_EF_CTRL,\n\t\t.shift = 16,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwm_f_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&pwm_f_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap pwm_f = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = PWM_CLK_EF_CTRL,\n\t\t.bit_idx = 24,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"pwm_f\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&pwm_f_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\n \nstatic const struct clk_parent_data spicc_spifc_parents[] = {\n\t{ .fw_name = \"fclk_div2\"},\n\t{ .fw_name = \"fclk_div3\"},\n\t{ .fw_name = \"fclk_div5\"},\n\t{ .fw_name = \"hifi_pll\" },\n};\n\nstatic struct clk_regmap spicc_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = SPICC_CLK_CTRL,\n\t\t.mask = 0x3,\n\t\t.shift = 9,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"spicc_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = spicc_spifc_parents,\n\t\t.num_parents = ARRAY_SIZE(spicc_spifc_parents),\n\t},\n};\n\nstatic struct clk_regmap spicc_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = SPICC_CLK_CTRL,\n\t\t.shift = 0,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"spicc_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&spicc_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap spicc_sel2 = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = SPICC_CLK_CTRL,\n\t\t.mask = 0x1,\n\t\t.shift = 15,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"spicc_sel2\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = (const struct clk_parent_data []) {\n\t\t\t{ .hw = &spicc_div.hw },\n\t\t\t{ .fw_name = \"xtal\", },\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap spicc = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = SPICC_CLK_CTRL,\n\t\t.bit_idx = 8,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"spicc\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&spicc_sel2.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap ts_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = TS_CLK_CTRL,\n\t\t.shift = 0,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ts_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap ts = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = TS_CLK_CTRL,\n\t\t.bit_idx = 8,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"ts\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&ts_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap spifc_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = SPIFC_CLK_CTRL,\n\t\t.mask = 0x3,\n\t\t.shift = 9,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"spifc_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = spicc_spifc_parents,\n\t\t.num_parents = ARRAY_SIZE(spicc_spifc_parents),\n\t},\n};\n\nstatic struct clk_regmap spifc_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = SPIFC_CLK_CTRL,\n\t\t.shift = 0,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"spifc_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&spifc_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap spifc_sel2 = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = SPIFC_CLK_CTRL,\n\t\t.mask = 0x1,\n\t\t.shift = 15,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"spifc_sel2\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = (const struct clk_parent_data []) {\n\t\t\t{ .hw = &spifc_div.hw },\n\t\t\t{ .fw_name = \"xtal\", },\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap spifc = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = SPIFC_CLK_CTRL,\n\t\t.bit_idx = 8,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"spifc\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&spifc_sel2.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic const struct clk_parent_data usb_bus_parents[] = {\n\t{ .fw_name = \"xtal\", },\n\t{ .hw = &sys.hw },\n\t{ .fw_name = \"fclk_div3\", },\n\t{ .fw_name = \"fclk_div5\", },\n};\n\nstatic struct clk_regmap usb_bus_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = USB_BUSCLK_CTRL,\n\t\t.mask = 0x3,\n\t\t.shift = 9,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"usb_bus_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = usb_bus_parents,\n\t\t.num_parents = ARRAY_SIZE(usb_bus_parents),\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap usb_bus_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = USB_BUSCLK_CTRL,\n\t\t.shift = 0,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"usb_bus_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&usb_bus_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap usb_bus = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = USB_BUSCLK_CTRL,\n\t\t.bit_idx = 8,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"usb_bus\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&usb_bus_div.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic const struct clk_parent_data sd_emmc_psram_dmc_parents[] = {\n\t{ .fw_name = \"fclk_div2\", },\n\t{ .fw_name = \"fclk_div3\", },\n\t{ .fw_name = \"fclk_div5\", },\n\t{ .fw_name = \"hifi_pll\", },\n};\n\nstatic struct clk_regmap sd_emmc_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = SD_EMMC_CLK_CTRL,\n\t\t.mask = 0x3,\n\t\t.shift = 9,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"sd_emmc_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = sd_emmc_psram_dmc_parents,\n\t\t.num_parents = ARRAY_SIZE(sd_emmc_psram_dmc_parents),\n\t},\n};\n\nstatic struct clk_regmap sd_emmc_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = SD_EMMC_CLK_CTRL,\n\t\t.shift = 0,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"sd_emmc_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&sd_emmc_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap sd_emmc_sel2 = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = SD_EMMC_CLK_CTRL,\n\t\t.mask = 0x1,\n\t\t.shift = 15,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"sd_emmc_sel2\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = (const struct clk_parent_data []) {\n\t\t\t{ .hw = &sd_emmc_div.hw },\n\t\t\t{ .fw_name = \"xtal\", },\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap sd_emmc = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = SD_EMMC_CLK_CTRL,\n\t\t.bit_idx = 8,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"sd_emmc\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&sd_emmc_sel2.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap psram_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = PSRAM_CLK_CTRL,\n\t\t.mask = 0x3,\n\t\t.shift = 9,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"psram_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = sd_emmc_psram_dmc_parents,\n\t\t.num_parents = ARRAY_SIZE(sd_emmc_psram_dmc_parents),\n\t},\n};\n\nstatic struct clk_regmap psram_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = PSRAM_CLK_CTRL,\n\t\t.shift = 0,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"psram_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&psram_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap psram_sel2 = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = PSRAM_CLK_CTRL,\n\t\t.mask = 0x1,\n\t\t.shift = 15,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"psram_sel2\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = (const struct clk_parent_data []) {\n\t\t\t{ .hw = &psram_div.hw },\n\t\t\t{ .fw_name = \"xtal\", },\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap psram = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = PSRAM_CLK_CTRL,\n\t\t.bit_idx = 8,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"psram\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&psram_sel2.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dmc_sel = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = DMC_CLK_CTRL,\n\t\t.mask = 0x3,\n\t\t.shift = 9,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"dmc_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = sd_emmc_psram_dmc_parents,\n\t\t.num_parents = ARRAY_SIZE(sd_emmc_psram_dmc_parents),\n\t},\n};\n\nstatic struct clk_regmap dmc_div = {\n\t.data = &(struct clk_regmap_div_data){\n\t\t.offset = DMC_CLK_CTRL,\n\t\t.shift = 0,\n\t\t.width = 8,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"dmc_div\",\n\t\t.ops = &clk_regmap_divider_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dmc_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dmc_sel2 = {\n\t.data = &(struct clk_regmap_mux_data){\n\t\t.offset = DMC_CLK_CTRL,\n\t\t.mask = 0x1,\n\t\t.shift = 15,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"dmc_sel2\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_data = (const struct clk_parent_data []) {\n\t\t\t{ .hw = &dmc_div.hw },\n\t\t\t{ .fw_name = \"xtal\", },\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap dmc = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = DMC_CLK_CTRL,\n\t\t.bit_idx = 8,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"dmc\",\n\t\t.ops = &clk_regmap_gate_ro_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&dmc_sel2.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap ceca_32k_in = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = CECA_CLK_CTRL0,\n\t\t.bit_idx = 31,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"ceca_32k_in\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap ceca_32k_div = {\n\t.data = &(struct meson_clk_dualdiv_data){\n\t\t.n1 = {\n\t\t\t.reg_off = CECA_CLK_CTRL0,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.n2 = {\n\t\t\t.reg_off = CECA_CLK_CTRL0,\n\t\t\t.shift   = 12,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.m1 = {\n\t\t\t.reg_off = CECA_CLK_CTRL1,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.m2 = {\n\t\t\t.reg_off = CECA_CLK_CTRL1,\n\t\t\t.shift   = 12,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.dual = {\n\t\t\t.reg_off = CECA_CLK_CTRL0,\n\t\t\t.shift   = 28,\n\t\t\t.width   = 1,\n\t\t},\n\t\t.table = clk_32k_div_table,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ceca_32k_div\",\n\t\t.ops = &meson_clk_dualdiv_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&ceca_32k_in.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap ceca_32k_sel_pre = {\n\t.data = &(struct clk_regmap_mux_data) {\n\t\t.offset = CECA_CLK_CTRL1,\n\t\t.mask = 0x1,\n\t\t.shift = 24,\n\t\t.flags = CLK_MUX_ROUND_CLOSEST,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ceca_32k_sel_pre\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&ceca_32k_div.hw,\n\t\t\t&ceca_32k_in.hw,\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap ceca_32k_sel = {\n\t.data = &(struct clk_regmap_mux_data) {\n\t\t.offset = CECA_CLK_CTRL1,\n\t\t.mask = 0x1,\n\t\t.shift = 31,\n\t\t.flags = CLK_MUX_ROUND_CLOSEST,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ceca_32k_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&ceca_32k_sel_pre.hw,\n\t\t\t&rtc.hw,\n\t\t},\n\t\t.num_parents = 2,\n\t},\n};\n\nstatic struct clk_regmap ceca_32k_out = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = CECA_CLK_CTRL0,\n\t\t.bit_idx = 30,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"ceca_32k_out\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&ceca_32k_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap cecb_32k_in = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = CECB_CLK_CTRL0,\n\t\t.bit_idx = 31,\n\t},\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"cecb_32k_in\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"xtal\",\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap cecb_32k_div = {\n\t.data = &(struct meson_clk_dualdiv_data){\n\t\t.n1 = {\n\t\t\t.reg_off = CECB_CLK_CTRL0,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.n2 = {\n\t\t\t.reg_off = CECB_CLK_CTRL0,\n\t\t\t.shift   = 12,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.m1 = {\n\t\t\t.reg_off = CECB_CLK_CTRL1,\n\t\t\t.shift   = 0,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.m2 = {\n\t\t\t.reg_off = CECB_CLK_CTRL1,\n\t\t\t.shift   = 12,\n\t\t\t.width   = 12,\n\t\t},\n\t\t.dual = {\n\t\t\t.reg_off = CECB_CLK_CTRL0,\n\t\t\t.shift   = 28,\n\t\t\t.width   = 1,\n\t\t},\n\t\t.table = clk_32k_div_table,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"cecb_32k_div\",\n\t\t.ops = &meson_clk_dualdiv_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&cecb_32k_in.hw\n\t\t},\n\t\t.num_parents = 1,\n\t},\n};\n\nstatic struct clk_regmap cecb_32k_sel_pre = {\n\t.data = &(struct clk_regmap_mux_data) {\n\t\t.offset = CECB_CLK_CTRL1,\n\t\t.mask = 0x1,\n\t\t.shift = 24,\n\t\t.flags = CLK_MUX_ROUND_CLOSEST,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"cecb_32k_sel_pre\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&cecb_32k_div.hw,\n\t\t\t&cecb_32k_in.hw,\n\t\t},\n\t\t.num_parents = 2,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap cecb_32k_sel = {\n\t.data = &(struct clk_regmap_mux_data) {\n\t\t.offset = CECB_CLK_CTRL1,\n\t\t.mask = 0x1,\n\t\t.shift = 31,\n\t\t.flags = CLK_MUX_ROUND_CLOSEST,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"cecb_32k_sel\",\n\t\t.ops = &clk_regmap_mux_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&cecb_32k_sel_pre.hw,\n\t\t\t&rtc.hw,\n\t\t},\n\t\t.num_parents = 2,\n\t},\n};\n\nstatic struct clk_regmap cecb_32k_out = {\n\t.data = &(struct clk_regmap_gate_data){\n\t\t.offset = CECB_CLK_CTRL0,\n\t\t.bit_idx = 30,\n\t},\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"cecb_32k_out\",\n\t\t.ops = &clk_regmap_gate_ops,\n\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t&cecb_32k_sel.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\n#define MESON_GATE(_name, _reg, _bit) \\\n\tMESON_PCLK(_name, _reg, _bit, &sys.hw)\n\nstatic MESON_GATE(clktree,\tSYS_CLK_EN0,\t0);\nstatic MESON_GATE(reset_ctrl,\tSYS_CLK_EN0,\t1);\nstatic MESON_GATE(analog_ctrl,\tSYS_CLK_EN0,\t2);\nstatic MESON_GATE(pwr_ctrl,\tSYS_CLK_EN0,\t3);\nstatic MESON_GATE(pad_ctrl,\tSYS_CLK_EN0,\t4);\nstatic MESON_GATE(sys_ctrl,\tSYS_CLK_EN0,\t5);\nstatic MESON_GATE(temp_sensor,\tSYS_CLK_EN0,\t6);\nstatic MESON_GATE(am2axi_dev,\tSYS_CLK_EN0,\t7);\nstatic MESON_GATE(spicc_b,\tSYS_CLK_EN0,\t8);\nstatic MESON_GATE(spicc_a,\tSYS_CLK_EN0,\t9);\nstatic MESON_GATE(msr,\t\tSYS_CLK_EN0,\t10);\nstatic MESON_GATE(audio,\tSYS_CLK_EN0,\t11);\nstatic MESON_GATE(jtag_ctrl,\tSYS_CLK_EN0,\t12);\nstatic MESON_GATE(saradc_en,\tSYS_CLK_EN0,\t13);\nstatic MESON_GATE(pwm_ef,\tSYS_CLK_EN0,\t14);\nstatic MESON_GATE(pwm_cd,\tSYS_CLK_EN0,\t15);\nstatic MESON_GATE(pwm_ab,\tSYS_CLK_EN0,\t16);\nstatic MESON_GATE(cec,\t\tSYS_CLK_EN0,\t17);\nstatic MESON_GATE(i2c_s,\tSYS_CLK_EN0,\t18);\nstatic MESON_GATE(ir_ctrl,\tSYS_CLK_EN0,\t19);\nstatic MESON_GATE(i2c_m_d,\tSYS_CLK_EN0,\t20);\nstatic MESON_GATE(i2c_m_c,\tSYS_CLK_EN0,\t21);\nstatic MESON_GATE(i2c_m_b,\tSYS_CLK_EN0,\t22);\nstatic MESON_GATE(i2c_m_a,\tSYS_CLK_EN0,\t23);\nstatic MESON_GATE(acodec,\tSYS_CLK_EN0,\t24);\nstatic MESON_GATE(otp,\t\tSYS_CLK_EN0,\t25);\nstatic MESON_GATE(sd_emmc_a,\tSYS_CLK_EN0,\t26);\nstatic MESON_GATE(usb_phy,\tSYS_CLK_EN0,\t27);\nstatic MESON_GATE(usb_ctrl,\tSYS_CLK_EN0,\t28);\nstatic MESON_GATE(sys_dspb,\tSYS_CLK_EN0,\t29);\nstatic MESON_GATE(sys_dspa,\tSYS_CLK_EN0,\t30);\nstatic MESON_GATE(dma,\t\tSYS_CLK_EN0,\t31);\nstatic MESON_GATE(irq_ctrl,\tSYS_CLK_EN1,\t0);\nstatic MESON_GATE(nic,\t\tSYS_CLK_EN1,\t1);\nstatic MESON_GATE(gic,\t\tSYS_CLK_EN1,\t2);\nstatic MESON_GATE(uart_c,\tSYS_CLK_EN1,\t3);\nstatic MESON_GATE(uart_b,\tSYS_CLK_EN1,\t4);\nstatic MESON_GATE(uart_a,\tSYS_CLK_EN1,\t5);\nstatic MESON_GATE(sys_psram,\tSYS_CLK_EN1,\t6);\nstatic MESON_GATE(rsa,\t\tSYS_CLK_EN1,\t8);\nstatic MESON_GATE(coresight,\tSYS_CLK_EN1,\t9);\nstatic MESON_GATE(am2axi_vad,\tAXI_CLK_EN,\t0);\nstatic MESON_GATE(audio_vad,\tAXI_CLK_EN,\t1);\nstatic MESON_GATE(axi_dmc,\tAXI_CLK_EN,\t3);\nstatic MESON_GATE(axi_psram,\tAXI_CLK_EN,\t4);\nstatic MESON_GATE(ramb,\t\tAXI_CLK_EN,\t5);\nstatic MESON_GATE(rama,\t\tAXI_CLK_EN,\t6);\nstatic MESON_GATE(axi_spifc,\tAXI_CLK_EN,\t7);\nstatic MESON_GATE(axi_nic,\tAXI_CLK_EN,\t8);\nstatic MESON_GATE(axi_dma,\tAXI_CLK_EN,\t9);\nstatic MESON_GATE(cpu_ctrl,\tAXI_CLK_EN,\t10);\nstatic MESON_GATE(rom,\t\tAXI_CLK_EN,\t11);\nstatic MESON_GATE(prod_i2c,\tAXI_CLK_EN,\t12);\n\n \nstatic struct clk_hw *a1_periphs_hw_clks[] = {\n\t[CLKID_XTAL_IN]\t\t\t= &xtal_in.hw,\n\t[CLKID_FIXPLL_IN]\t\t= &fixpll_in.hw,\n\t[CLKID_USB_PHY_IN]\t\t= &usb_phy_in.hw,\n\t[CLKID_USB_CTRL_IN]\t\t= &usb_ctrl_in.hw,\n\t[CLKID_HIFIPLL_IN]\t\t= &hifipll_in.hw,\n\t[CLKID_SYSPLL_IN]\t\t= &syspll_in.hw,\n\t[CLKID_DDS_IN]\t\t\t= &dds_in.hw,\n\t[CLKID_SYS]\t\t\t= &sys.hw,\n\t[CLKID_CLKTREE]\t\t\t= &clktree.hw,\n\t[CLKID_RESET_CTRL]\t\t= &reset_ctrl.hw,\n\t[CLKID_ANALOG_CTRL]\t\t= &analog_ctrl.hw,\n\t[CLKID_PWR_CTRL]\t\t= &pwr_ctrl.hw,\n\t[CLKID_PAD_CTRL]\t\t= &pad_ctrl.hw,\n\t[CLKID_SYS_CTRL]\t\t= &sys_ctrl.hw,\n\t[CLKID_TEMP_SENSOR]\t\t= &temp_sensor.hw,\n\t[CLKID_AM2AXI_DIV]\t\t= &am2axi_dev.hw,\n\t[CLKID_SPICC_B]\t\t\t= &spicc_b.hw,\n\t[CLKID_SPICC_A]\t\t\t= &spicc_a.hw,\n\t[CLKID_MSR]\t\t\t= &msr.hw,\n\t[CLKID_AUDIO]\t\t\t= &audio.hw,\n\t[CLKID_JTAG_CTRL]\t\t= &jtag_ctrl.hw,\n\t[CLKID_SARADC_EN]\t\t= &saradc_en.hw,\n\t[CLKID_PWM_EF]\t\t\t= &pwm_ef.hw,\n\t[CLKID_PWM_CD]\t\t\t= &pwm_cd.hw,\n\t[CLKID_PWM_AB]\t\t\t= &pwm_ab.hw,\n\t[CLKID_CEC]\t\t\t= &cec.hw,\n\t[CLKID_I2C_S]\t\t\t= &i2c_s.hw,\n\t[CLKID_IR_CTRL]\t\t\t= &ir_ctrl.hw,\n\t[CLKID_I2C_M_D]\t\t\t= &i2c_m_d.hw,\n\t[CLKID_I2C_M_C]\t\t\t= &i2c_m_c.hw,\n\t[CLKID_I2C_M_B]\t\t\t= &i2c_m_b.hw,\n\t[CLKID_I2C_M_A]\t\t\t= &i2c_m_a.hw,\n\t[CLKID_ACODEC]\t\t\t= &acodec.hw,\n\t[CLKID_OTP]\t\t\t= &otp.hw,\n\t[CLKID_SD_EMMC_A]\t\t= &sd_emmc_a.hw,\n\t[CLKID_USB_PHY]\t\t\t= &usb_phy.hw,\n\t[CLKID_USB_CTRL]\t\t= &usb_ctrl.hw,\n\t[CLKID_SYS_DSPB]\t\t= &sys_dspb.hw,\n\t[CLKID_SYS_DSPA]\t\t= &sys_dspa.hw,\n\t[CLKID_DMA]\t\t\t= &dma.hw,\n\t[CLKID_IRQ_CTRL]\t\t= &irq_ctrl.hw,\n\t[CLKID_NIC]\t\t\t= &nic.hw,\n\t[CLKID_GIC]\t\t\t= &gic.hw,\n\t[CLKID_UART_C]\t\t\t= &uart_c.hw,\n\t[CLKID_UART_B]\t\t\t= &uart_b.hw,\n\t[CLKID_UART_A]\t\t\t= &uart_a.hw,\n\t[CLKID_SYS_PSRAM]\t\t= &sys_psram.hw,\n\t[CLKID_RSA]\t\t\t= &rsa.hw,\n\t[CLKID_CORESIGHT]\t\t= &coresight.hw,\n\t[CLKID_AM2AXI_VAD]\t\t= &am2axi_vad.hw,\n\t[CLKID_AUDIO_VAD]\t\t= &audio_vad.hw,\n\t[CLKID_AXI_DMC]\t\t\t= &axi_dmc.hw,\n\t[CLKID_AXI_PSRAM]\t\t= &axi_psram.hw,\n\t[CLKID_RAMB]\t\t\t= &ramb.hw,\n\t[CLKID_RAMA]\t\t\t= &rama.hw,\n\t[CLKID_AXI_SPIFC]\t\t= &axi_spifc.hw,\n\t[CLKID_AXI_NIC]\t\t\t= &axi_nic.hw,\n\t[CLKID_AXI_DMA]\t\t\t= &axi_dma.hw,\n\t[CLKID_CPU_CTRL]\t\t= &cpu_ctrl.hw,\n\t[CLKID_ROM]\t\t\t= &rom.hw,\n\t[CLKID_PROC_I2C]\t\t= &prod_i2c.hw,\n\t[CLKID_DSPA_SEL]\t\t= &dspa_sel.hw,\n\t[CLKID_DSPB_SEL]\t\t= &dspb_sel.hw,\n\t[CLKID_DSPA_EN]\t\t\t= &dspa_en.hw,\n\t[CLKID_DSPA_EN_NIC]\t\t= &dspa_en_nic.hw,\n\t[CLKID_DSPB_EN]\t\t\t= &dspb_en.hw,\n\t[CLKID_DSPB_EN_NIC]\t\t= &dspb_en_nic.hw,\n\t[CLKID_RTC]\t\t\t= &rtc.hw,\n\t[CLKID_CECA_32K]\t\t= &ceca_32k_out.hw,\n\t[CLKID_CECB_32K]\t\t= &cecb_32k_out.hw,\n\t[CLKID_24M]\t\t\t= &clk_24m.hw,\n\t[CLKID_12M]\t\t\t= &clk_12m.hw,\n\t[CLKID_FCLK_DIV2_DIVN]\t\t= &fclk_div2_divn.hw,\n\t[CLKID_GEN]\t\t\t= &gen.hw,\n\t[CLKID_SARADC_SEL]\t\t= &saradc_sel.hw,\n\t[CLKID_SARADC]\t\t\t= &saradc.hw,\n\t[CLKID_PWM_A]\t\t\t= &pwm_a.hw,\n\t[CLKID_PWM_B]\t\t\t= &pwm_b.hw,\n\t[CLKID_PWM_C]\t\t\t= &pwm_c.hw,\n\t[CLKID_PWM_D]\t\t\t= &pwm_d.hw,\n\t[CLKID_PWM_E]\t\t\t= &pwm_e.hw,\n\t[CLKID_PWM_F]\t\t\t= &pwm_f.hw,\n\t[CLKID_SPICC]\t\t\t= &spicc.hw,\n\t[CLKID_TS]\t\t\t= &ts.hw,\n\t[CLKID_SPIFC]\t\t\t= &spifc.hw,\n\t[CLKID_USB_BUS]\t\t\t= &usb_bus.hw,\n\t[CLKID_SD_EMMC]\t\t\t= &sd_emmc.hw,\n\t[CLKID_PSRAM]\t\t\t= &psram.hw,\n\t[CLKID_DMC]\t\t\t= &dmc.hw,\n\t[CLKID_SYS_A_SEL]\t\t= &sys_a_sel.hw,\n\t[CLKID_SYS_A_DIV]\t\t= &sys_a_div.hw,\n\t[CLKID_SYS_A]\t\t\t= &sys_a.hw,\n\t[CLKID_SYS_B_SEL]\t\t= &sys_b_sel.hw,\n\t[CLKID_SYS_B_DIV]\t\t= &sys_b_div.hw,\n\t[CLKID_SYS_B]\t\t\t= &sys_b.hw,\n\t[CLKID_DSPA_A_SEL]\t\t= &dspa_a_sel.hw,\n\t[CLKID_DSPA_A_DIV]\t\t= &dspa_a_div.hw,\n\t[CLKID_DSPA_A]\t\t\t= &dspa_a.hw,\n\t[CLKID_DSPA_B_SEL]\t\t= &dspa_b_sel.hw,\n\t[CLKID_DSPA_B_DIV]\t\t= &dspa_b_div.hw,\n\t[CLKID_DSPA_B]\t\t\t= &dspa_b.hw,\n\t[CLKID_DSPB_A_SEL]\t\t= &dspb_a_sel.hw,\n\t[CLKID_DSPB_A_DIV]\t\t= &dspb_a_div.hw,\n\t[CLKID_DSPB_A]\t\t\t= &dspb_a.hw,\n\t[CLKID_DSPB_B_SEL]\t\t= &dspb_b_sel.hw,\n\t[CLKID_DSPB_B_DIV]\t\t= &dspb_b_div.hw,\n\t[CLKID_DSPB_B]\t\t\t= &dspb_b.hw,\n\t[CLKID_RTC_32K_IN]\t\t= &rtc_32k_in.hw,\n\t[CLKID_RTC_32K_DIV]\t\t= &rtc_32k_div.hw,\n\t[CLKID_RTC_32K_XTAL]\t\t= &rtc_32k_xtal.hw,\n\t[CLKID_RTC_32K_SEL]\t\t= &rtc_32k_sel.hw,\n\t[CLKID_CECB_32K_IN]\t\t= &cecb_32k_in.hw,\n\t[CLKID_CECB_32K_DIV]\t\t= &cecb_32k_div.hw,\n\t[CLKID_CECB_32K_SEL_PRE]\t= &cecb_32k_sel_pre.hw,\n\t[CLKID_CECB_32K_SEL]\t\t= &cecb_32k_sel.hw,\n\t[CLKID_CECA_32K_IN]\t\t= &ceca_32k_in.hw,\n\t[CLKID_CECA_32K_DIV]\t\t= &ceca_32k_div.hw,\n\t[CLKID_CECA_32K_SEL_PRE]\t= &ceca_32k_sel_pre.hw,\n\t[CLKID_CECA_32K_SEL]\t\t= &ceca_32k_sel.hw,\n\t[CLKID_DIV2_PRE]\t\t= &fclk_div2_divn_pre.hw,\n\t[CLKID_24M_DIV2]\t\t= &clk_24m_div2.hw,\n\t[CLKID_GEN_SEL]\t\t\t= &gen_sel.hw,\n\t[CLKID_GEN_DIV]\t\t\t= &gen_div.hw,\n\t[CLKID_SARADC_DIV]\t\t= &saradc_div.hw,\n\t[CLKID_PWM_A_SEL]\t\t= &pwm_a_sel.hw,\n\t[CLKID_PWM_A_DIV]\t\t= &pwm_a_div.hw,\n\t[CLKID_PWM_B_SEL]\t\t= &pwm_b_sel.hw,\n\t[CLKID_PWM_B_DIV]\t\t= &pwm_b_div.hw,\n\t[CLKID_PWM_C_SEL]\t\t= &pwm_c_sel.hw,\n\t[CLKID_PWM_C_DIV]\t\t= &pwm_c_div.hw,\n\t[CLKID_PWM_D_SEL]\t\t= &pwm_d_sel.hw,\n\t[CLKID_PWM_D_DIV]\t\t= &pwm_d_div.hw,\n\t[CLKID_PWM_E_SEL]\t\t= &pwm_e_sel.hw,\n\t[CLKID_PWM_E_DIV]\t\t= &pwm_e_div.hw,\n\t[CLKID_PWM_F_SEL]\t\t= &pwm_f_sel.hw,\n\t[CLKID_PWM_F_DIV]\t\t= &pwm_f_div.hw,\n\t[CLKID_SPICC_SEL]\t\t= &spicc_sel.hw,\n\t[CLKID_SPICC_DIV]\t\t= &spicc_div.hw,\n\t[CLKID_SPICC_SEL2]\t\t= &spicc_sel2.hw,\n\t[CLKID_TS_DIV]\t\t\t= &ts_div.hw,\n\t[CLKID_SPIFC_SEL]\t\t= &spifc_sel.hw,\n\t[CLKID_SPIFC_DIV]\t\t= &spifc_div.hw,\n\t[CLKID_SPIFC_SEL2]\t\t= &spifc_sel2.hw,\n\t[CLKID_USB_BUS_SEL]\t\t= &usb_bus_sel.hw,\n\t[CLKID_USB_BUS_DIV]\t\t= &usb_bus_div.hw,\n\t[CLKID_SD_EMMC_SEL]\t\t= &sd_emmc_sel.hw,\n\t[CLKID_SD_EMMC_DIV]\t\t= &sd_emmc_div.hw,\n\t[CLKID_SD_EMMC_SEL2]\t\t= &sd_emmc_sel2.hw,\n\t[CLKID_PSRAM_SEL]\t\t= &psram_sel.hw,\n\t[CLKID_PSRAM_DIV]\t\t= &psram_div.hw,\n\t[CLKID_PSRAM_SEL2]\t\t= &psram_sel2.hw,\n\t[CLKID_DMC_SEL]\t\t\t= &dmc_sel.hw,\n\t[CLKID_DMC_DIV]\t\t\t= &dmc_div.hw,\n\t[CLKID_DMC_SEL2]\t\t= &dmc_sel2.hw,\n};\n\n \nstatic struct clk_regmap *const a1_periphs_regmaps[] = {\n\t&xtal_in,\n\t&fixpll_in,\n\t&usb_phy_in,\n\t&usb_ctrl_in,\n\t&hifipll_in,\n\t&syspll_in,\n\t&dds_in,\n\t&sys,\n\t&clktree,\n\t&reset_ctrl,\n\t&analog_ctrl,\n\t&pwr_ctrl,\n\t&pad_ctrl,\n\t&sys_ctrl,\n\t&temp_sensor,\n\t&am2axi_dev,\n\t&spicc_b,\n\t&spicc_a,\n\t&msr,\n\t&audio,\n\t&jtag_ctrl,\n\t&saradc_en,\n\t&pwm_ef,\n\t&pwm_cd,\n\t&pwm_ab,\n\t&cec,\n\t&i2c_s,\n\t&ir_ctrl,\n\t&i2c_m_d,\n\t&i2c_m_c,\n\t&i2c_m_b,\n\t&i2c_m_a,\n\t&acodec,\n\t&otp,\n\t&sd_emmc_a,\n\t&usb_phy,\n\t&usb_ctrl,\n\t&sys_dspb,\n\t&sys_dspa,\n\t&dma,\n\t&irq_ctrl,\n\t&nic,\n\t&gic,\n\t&uart_c,\n\t&uart_b,\n\t&uart_a,\n\t&sys_psram,\n\t&rsa,\n\t&coresight,\n\t&am2axi_vad,\n\t&audio_vad,\n\t&axi_dmc,\n\t&axi_psram,\n\t&ramb,\n\t&rama,\n\t&axi_spifc,\n\t&axi_nic,\n\t&axi_dma,\n\t&cpu_ctrl,\n\t&rom,\n\t&prod_i2c,\n\t&dspa_sel,\n\t&dspb_sel,\n\t&dspa_en,\n\t&dspa_en_nic,\n\t&dspb_en,\n\t&dspb_en_nic,\n\t&rtc,\n\t&ceca_32k_out,\n\t&cecb_32k_out,\n\t&clk_24m,\n\t&clk_12m,\n\t&fclk_div2_divn,\n\t&gen,\n\t&saradc_sel,\n\t&saradc,\n\t&pwm_a,\n\t&pwm_b,\n\t&pwm_c,\n\t&pwm_d,\n\t&pwm_e,\n\t&pwm_f,\n\t&spicc,\n\t&ts,\n\t&spifc,\n\t&usb_bus,\n\t&sd_emmc,\n\t&psram,\n\t&dmc,\n\t&sys_a_sel,\n\t&sys_a_div,\n\t&sys_a,\n\t&sys_b_sel,\n\t&sys_b_div,\n\t&sys_b,\n\t&dspa_a_sel,\n\t&dspa_a_div,\n\t&dspa_a,\n\t&dspa_b_sel,\n\t&dspa_b_div,\n\t&dspa_b,\n\t&dspb_a_sel,\n\t&dspb_a_div,\n\t&dspb_a,\n\t&dspb_b_sel,\n\t&dspb_b_div,\n\t&dspb_b,\n\t&rtc_32k_in,\n\t&rtc_32k_div,\n\t&rtc_32k_xtal,\n\t&rtc_32k_sel,\n\t&cecb_32k_in,\n\t&cecb_32k_div,\n\t&cecb_32k_sel_pre,\n\t&cecb_32k_sel,\n\t&ceca_32k_in,\n\t&ceca_32k_div,\n\t&ceca_32k_sel_pre,\n\t&ceca_32k_sel,\n\t&fclk_div2_divn_pre,\n\t&gen_sel,\n\t&gen_div,\n\t&saradc_div,\n\t&pwm_a_sel,\n\t&pwm_a_div,\n\t&pwm_b_sel,\n\t&pwm_b_div,\n\t&pwm_c_sel,\n\t&pwm_c_div,\n\t&pwm_d_sel,\n\t&pwm_d_div,\n\t&pwm_e_sel,\n\t&pwm_e_div,\n\t&pwm_f_sel,\n\t&pwm_f_div,\n\t&spicc_sel,\n\t&spicc_div,\n\t&spicc_sel2,\n\t&ts_div,\n\t&spifc_sel,\n\t&spifc_div,\n\t&spifc_sel2,\n\t&usb_bus_sel,\n\t&usb_bus_div,\n\t&sd_emmc_sel,\n\t&sd_emmc_div,\n\t&sd_emmc_sel2,\n\t&psram_sel,\n\t&psram_div,\n\t&psram_sel2,\n\t&dmc_sel,\n\t&dmc_div,\n\t&dmc_sel2,\n};\n\nstatic struct regmap_config a1_periphs_regmap_cfg = {\n\t.reg_bits   = 32,\n\t.val_bits   = 32,\n\t.reg_stride = 4,\n};\n\nstatic struct meson_clk_hw_data a1_periphs_clks = {\n\t.hws = a1_periphs_hw_clks,\n\t.num = ARRAY_SIZE(a1_periphs_hw_clks),\n};\n\nstatic int meson_a1_periphs_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *base;\n\tstruct regmap *map;\n\tint clkid, i, err;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn dev_err_probe(dev, PTR_ERR(base),\n\t\t\t\t     \"can't ioremap resource\\n\");\n\n\tmap = devm_regmap_init_mmio(dev, base, &a1_periphs_regmap_cfg);\n\tif (IS_ERR(map))\n\t\treturn dev_err_probe(dev, PTR_ERR(map),\n\t\t\t\t     \"can't init regmap mmio region\\n\");\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(a1_periphs_regmaps); i++)\n\t\ta1_periphs_regmaps[i]->map = map;\n\n\tfor (clkid = 0; clkid < a1_periphs_clks.num; clkid++) {\n\t\terr = devm_clk_hw_register(dev, a1_periphs_clks.hws[clkid]);\n\t\tif (err)\n\t\t\treturn dev_err_probe(dev, err,\n\t\t\t\t\t     \"clock[%d] registration failed\\n\",\n\t\t\t\t\t     clkid);\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, meson_clk_hw_get, &a1_periphs_clks);\n}\n\nstatic const struct of_device_id a1_periphs_clkc_match_table[] = {\n\t{ .compatible = \"amlogic,a1-peripherals-clkc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, a1_periphs_clkc_match_table);\n\nstatic struct platform_driver a1_periphs_clkc_driver = {\n\t.probe = meson_a1_periphs_probe,\n\t.driver = {\n\t\t.name = \"a1-peripherals-clkc\",\n\t\t.of_match_table = a1_periphs_clkc_match_table,\n\t},\n};\n\nmodule_platform_driver(a1_periphs_clkc_driver);\nMODULE_AUTHOR(\"Jian Hu <jian.hu@amlogic.com>\");\nMODULE_AUTHOR(\"Dmitry Rokosov <ddrokosov@sberdevices.ru>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}