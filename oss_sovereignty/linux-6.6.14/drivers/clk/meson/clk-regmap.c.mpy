{
  "module_name": "clk-regmap.c",
  "hash_id": "9820dbe04e22fe4f98e6707f94d26bb0c70dab7714f51235c23b51a8555862ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/meson/clk-regmap.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include \"clk-regmap.h\"\n\nstatic int clk_regmap_gate_endisable(struct clk_hw *hw, int enable)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct clk_regmap_gate_data *gate = clk_get_regmap_gate_data(clk);\n\tint set = gate->flags & CLK_GATE_SET_TO_DISABLE ? 1 : 0;\n\n\tset ^= enable;\n\n\treturn regmap_update_bits(clk->map, gate->offset, BIT(gate->bit_idx),\n\t\t\t\t  set ? BIT(gate->bit_idx) : 0);\n}\n\nstatic int clk_regmap_gate_enable(struct clk_hw *hw)\n{\n\treturn clk_regmap_gate_endisable(hw, 1);\n}\n\nstatic void clk_regmap_gate_disable(struct clk_hw *hw)\n{\n\tclk_regmap_gate_endisable(hw, 0);\n}\n\nstatic int clk_regmap_gate_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct clk_regmap_gate_data *gate = clk_get_regmap_gate_data(clk);\n\tunsigned int val;\n\n\tregmap_read(clk->map, gate->offset, &val);\n\tif (gate->flags & CLK_GATE_SET_TO_DISABLE)\n\t\tval ^= BIT(gate->bit_idx);\n\n\tval &= BIT(gate->bit_idx);\n\n\treturn val ? 1 : 0;\n}\n\nconst struct clk_ops clk_regmap_gate_ops = {\n\t.enable = clk_regmap_gate_enable,\n\t.disable = clk_regmap_gate_disable,\n\t.is_enabled = clk_regmap_gate_is_enabled,\n};\nEXPORT_SYMBOL_GPL(clk_regmap_gate_ops);\n\nconst struct clk_ops clk_regmap_gate_ro_ops = {\n\t.is_enabled = clk_regmap_gate_is_enabled,\n};\nEXPORT_SYMBOL_GPL(clk_regmap_gate_ro_ops);\n\nstatic unsigned long clk_regmap_div_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long prate)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(clk->map, div->offset, &val);\n\tif (ret)\n\t\t \n\t\treturn 0;\n\n\tval >>= div->shift;\n\tval &= clk_div_mask(div->width);\n\treturn divider_recalc_rate(hw, prate, val, div->table, div->flags,\n\t\t\t\t   div->width);\n}\n\nstatic int clk_regmap_div_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t struct clk_rate_request *req)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);\n\tunsigned int val;\n\tint ret;\n\n\t \n\tif (div->flags & CLK_DIVIDER_READ_ONLY) {\n\t\tret = regmap_read(clk->map, div->offset, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval >>= div->shift;\n\t\tval &= clk_div_mask(div->width);\n\n\t\treturn divider_ro_determine_rate(hw, req, div->table,\n\t\t\t\t\t\t div->width, div->flags, val);\n\t}\n\n\treturn divider_determine_rate(hw, req, div->table, div->width,\n\t\t\t\t      div->flags);\n}\n\nstatic int clk_regmap_div_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);\n\tunsigned int val;\n\tint ret;\n\n\tret = divider_get_val(rate, parent_rate, div->table, div->width,\n\t\t\t      div->flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = (unsigned int)ret << div->shift;\n\treturn regmap_update_bits(clk->map, div->offset,\n\t\t\t\t  clk_div_mask(div->width) << div->shift, val);\n};\n\n \n\nconst struct clk_ops clk_regmap_divider_ops = {\n\t.recalc_rate = clk_regmap_div_recalc_rate,\n\t.determine_rate = clk_regmap_div_determine_rate,\n\t.set_rate = clk_regmap_div_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_regmap_divider_ops);\n\nconst struct clk_ops clk_regmap_divider_ro_ops = {\n\t.recalc_rate = clk_regmap_div_recalc_rate,\n\t.determine_rate = clk_regmap_div_determine_rate,\n};\nEXPORT_SYMBOL_GPL(clk_regmap_divider_ro_ops);\n\nstatic u8 clk_regmap_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(clk->map, mux->offset, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval >>= mux->shift;\n\tval &= mux->mask;\n\treturn clk_mux_val_to_index(hw, mux->table, mux->flags, val);\n}\n\nstatic int clk_regmap_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);\n\tunsigned int val = clk_mux_index_to_val(mux->table, mux->flags, index);\n\n\treturn regmap_update_bits(clk->map, mux->offset,\n\t\t\t\t  mux->mask << mux->shift,\n\t\t\t\t  val << mux->shift);\n}\n\nstatic int clk_regmap_mux_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t struct clk_rate_request *req)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);\n\n\treturn clk_mux_determine_rate_flags(hw, req, mux->flags);\n}\n\nconst struct clk_ops clk_regmap_mux_ops = {\n\t.get_parent = clk_regmap_mux_get_parent,\n\t.set_parent = clk_regmap_mux_set_parent,\n\t.determine_rate = clk_regmap_mux_determine_rate,\n};\nEXPORT_SYMBOL_GPL(clk_regmap_mux_ops);\n\nconst struct clk_ops clk_regmap_mux_ro_ops = {\n\t.get_parent = clk_regmap_mux_get_parent,\n};\nEXPORT_SYMBOL_GPL(clk_regmap_mux_ro_ops);\n\nMODULE_DESCRIPTION(\"Amlogic regmap backed clock driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}