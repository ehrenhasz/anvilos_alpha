{
  "module_name": "sclk-div.c",
  "hash_id": "3710a0e99642512715e3132dfcb4130b7d9431c1443ba7791c4cc166d4a98e89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/meson/sclk-div.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/module.h>\n\n#include \"clk-regmap.h\"\n#include \"sclk-div.h\"\n\nstatic inline struct meson_sclk_div_data *\nmeson_sclk_div_data(struct clk_regmap *clk)\n{\n\treturn (struct meson_sclk_div_data *)clk->data;\n}\n\nstatic int sclk_div_maxval(struct meson_sclk_div_data *sclk)\n{\n\treturn (1 << sclk->div.width) - 1;\n}\n\nstatic int sclk_div_maxdiv(struct meson_sclk_div_data *sclk)\n{\n\treturn sclk_div_maxval(sclk) + 1;\n}\n\nstatic int sclk_div_getdiv(struct clk_hw *hw, unsigned long rate,\n\t\t\t   unsigned long prate, int maxdiv)\n{\n\tint div = DIV_ROUND_CLOSEST_ULL((u64)prate, rate);\n\n\treturn clamp(div, 2, maxdiv);\n}\n\nstatic int sclk_div_bestdiv(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long *prate,\n\t\t\t    struct meson_sclk_div_data *sclk)\n{\n\tstruct clk_hw *parent = clk_hw_get_parent(hw);\n\tint bestdiv = 0, i;\n\tunsigned long maxdiv, now, parent_now;\n\tunsigned long best = 0, best_parent = 0;\n\n\tif (!rate)\n\t\trate = 1;\n\n\tmaxdiv = sclk_div_maxdiv(sclk);\n\n\tif (!(clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT))\n\t\treturn sclk_div_getdiv(hw, rate, *prate, maxdiv);\n\n\t \n\tmaxdiv = min(ULONG_MAX / rate, maxdiv);\n\n\tfor (i = 2; i <= maxdiv; i++) {\n\t\t \n\t\tif (rate * i == *prate)\n\t\t\treturn i;\n\n\t\tparent_now = clk_hw_round_rate(parent, rate * i);\n\t\tnow = DIV_ROUND_UP_ULL((u64)parent_now, i);\n\n\t\tif (abs(rate - now) < abs(rate - best)) {\n\t\t\tbestdiv = i;\n\t\t\tbest = now;\n\t\t\tbest_parent = parent_now;\n\t\t}\n\t}\n\n\tif (!bestdiv)\n\t\tbestdiv = sclk_div_maxdiv(sclk);\n\telse\n\t\t*prate = best_parent;\n\n\treturn bestdiv;\n}\n\nstatic int sclk_div_determine_rate(struct clk_hw *hw,\n\t\t\t\t   struct clk_rate_request *req)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_sclk_div_data *sclk = meson_sclk_div_data(clk);\n\tint div;\n\n\tdiv = sclk_div_bestdiv(hw, req->rate, &req->best_parent_rate, sclk);\n\treq->rate = DIV_ROUND_UP_ULL((u64)req->best_parent_rate, div);\n\n\treturn 0;\n}\n\nstatic void sclk_apply_ratio(struct clk_regmap *clk,\n\t\t\t     struct meson_sclk_div_data *sclk)\n{\n\tunsigned int hi = DIV_ROUND_CLOSEST(sclk->cached_div *\n\t\t\t\t\t    sclk->cached_duty.num,\n\t\t\t\t\t    sclk->cached_duty.den);\n\n\tif (hi)\n\t\thi -= 1;\n\n\tmeson_parm_write(clk->map, &sclk->hi, hi);\n}\n\nstatic int sclk_div_set_duty_cycle(struct clk_hw *hw,\n\t\t\t\t   struct clk_duty *duty)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_sclk_div_data *sclk = meson_sclk_div_data(clk);\n\n\tif (MESON_PARM_APPLICABLE(&sclk->hi)) {\n\t\tmemcpy(&sclk->cached_duty, duty, sizeof(*duty));\n\t\tsclk_apply_ratio(clk, sclk);\n\t}\n\n\treturn 0;\n}\n\nstatic int sclk_div_get_duty_cycle(struct clk_hw *hw,\n\t\t\t\t   struct clk_duty *duty)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_sclk_div_data *sclk = meson_sclk_div_data(clk);\n\tint hi;\n\n\tif (!MESON_PARM_APPLICABLE(&sclk->hi)) {\n\t\tduty->num = 1;\n\t\tduty->den = 2;\n\t\treturn 0;\n\t}\n\n\thi = meson_parm_read(clk->map, &sclk->hi);\n\tduty->num = hi + 1;\n\tduty->den = sclk->cached_div;\n\treturn 0;\n}\n\nstatic void sclk_apply_divider(struct clk_regmap *clk,\n\t\t\t       struct meson_sclk_div_data *sclk)\n{\n\tif (MESON_PARM_APPLICABLE(&sclk->hi))\n\t\tsclk_apply_ratio(clk, sclk);\n\n\tmeson_parm_write(clk->map, &sclk->div, sclk->cached_div - 1);\n}\n\nstatic int sclk_div_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t     unsigned long prate)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_sclk_div_data *sclk = meson_sclk_div_data(clk);\n\tunsigned long maxdiv = sclk_div_maxdiv(sclk);\n\n\tsclk->cached_div = sclk_div_getdiv(hw, rate, prate, maxdiv);\n\n\tif (clk_hw_is_enabled(hw))\n\t\tsclk_apply_divider(clk, sclk);\n\n\treturn 0;\n}\n\nstatic unsigned long sclk_div_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long prate)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_sclk_div_data *sclk = meson_sclk_div_data(clk);\n\n\treturn DIV_ROUND_UP_ULL((u64)prate, sclk->cached_div);\n}\n\nstatic int sclk_div_enable(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_sclk_div_data *sclk = meson_sclk_div_data(clk);\n\n\tsclk_apply_divider(clk, sclk);\n\n\treturn 0;\n}\n\nstatic void sclk_div_disable(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_sclk_div_data *sclk = meson_sclk_div_data(clk);\n\n\tmeson_parm_write(clk->map, &sclk->div, 0);\n}\n\nstatic int sclk_div_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_sclk_div_data *sclk = meson_sclk_div_data(clk);\n\n\tif (meson_parm_read(clk->map, &sclk->div))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int sclk_div_init(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clk = to_clk_regmap(hw);\n\tstruct meson_sclk_div_data *sclk = meson_sclk_div_data(clk);\n\tunsigned int val;\n\n\tval = meson_parm_read(clk->map, &sclk->div);\n\n\t \n\tif (!val)\n\t\tsclk->cached_div = sclk_div_maxdiv(sclk);\n\telse\n\t\tsclk->cached_div = val + 1;\n\n\tsclk_div_get_duty_cycle(hw, &sclk->cached_duty);\n\n\treturn 0;\n}\n\nconst struct clk_ops meson_sclk_div_ops = {\n\t.recalc_rate\t= sclk_div_recalc_rate,\n\t.determine_rate\t= sclk_div_determine_rate,\n\t.set_rate\t= sclk_div_set_rate,\n\t.enable\t\t= sclk_div_enable,\n\t.disable\t= sclk_div_disable,\n\t.is_enabled\t= sclk_div_is_enabled,\n\t.get_duty_cycle\t= sclk_div_get_duty_cycle,\n\t.set_duty_cycle = sclk_div_set_duty_cycle,\n\t.init\t\t= sclk_div_init,\n};\nEXPORT_SYMBOL_GPL(meson_sclk_div_ops);\n\nMODULE_DESCRIPTION(\"Amlogic Sample divider driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}