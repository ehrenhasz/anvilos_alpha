{
  "module_name": "berlin2-avpll.c",
  "hash_id": "7e83aee4268dbe459b3c0966b6992db93788925ad9eba534e359d66fdc39248b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/berlin/berlin2-avpll.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n\n#include \"berlin2-avpll.h\"\n\n \n#define NUM_CHANNELS\t8\n\n#define AVPLL_CTRL(x)\t\t((x) * 0x4)\n\n#define VCO_CTRL0\t\tAVPLL_CTRL(0)\n \n#define  VCO_RESET\t\tBIT(0)\n#define  VCO_POWERUP\t\tBIT(1)\n#define  VCO_INTERPOL_SHIFT\t2\n#define  VCO_INTERPOL_MASK\t(0xf << VCO_INTERPOL_SHIFT)\n#define  VCO_REG1V45_SEL_SHIFT\t6\n#define  VCO_REG1V45_SEL(x)\t((x) << VCO_REG1V45_SEL_SHIFT)\n#define  VCO_REG1V45_SEL_1V40\tVCO_REG1V45_SEL(0)\n#define  VCO_REG1V45_SEL_1V45\tVCO_REG1V45_SEL(1)\n#define  VCO_REG1V45_SEL_1V50\tVCO_REG1V45_SEL(2)\n#define  VCO_REG1V45_SEL_1V55\tVCO_REG1V45_SEL(3)\n#define  VCO_REG1V45_SEL_MASK\tVCO_REG1V45_SEL(3)\n#define  VCO_REG0V9_SEL_SHIFT\t8\n#define  VCO_REG0V9_SEL_MASK\t(0xf << VCO_REG0V9_SEL_SHIFT)\n#define  VCO_VTHCAL_SHIFT\t12\n#define  VCO_VTHCAL(x)\t\t((x) << VCO_VTHCAL_SHIFT)\n#define  VCO_VTHCAL_0V90\tVCO_VTHCAL(0)\n#define  VCO_VTHCAL_0V95\tVCO_VTHCAL(1)\n#define  VCO_VTHCAL_1V00\tVCO_VTHCAL(2)\n#define  VCO_VTHCAL_1V05\tVCO_VTHCAL(3)\n#define  VCO_VTHCAL_MASK\tVCO_VTHCAL(3)\n#define  VCO_KVCOEXT_SHIFT\t14\n#define  VCO_KVCOEXT_MASK\t(0x3 << VCO_KVCOEXT_SHIFT)\n#define  VCO_KVCOEXT_ENABLE\tBIT(17)\n#define  VCO_V2IEXT_SHIFT\t18\n#define  VCO_V2IEXT_MASK\t(0xf << VCO_V2IEXT_SHIFT)\n#define  VCO_V2IEXT_ENABLE\tBIT(22)\n#define  VCO_SPEED_SHIFT\t23\n#define  VCO_SPEED(x)\t\t((x) << VCO_SPEED_SHIFT)\n#define  VCO_SPEED_1G08_1G21\tVCO_SPEED(0)\n#define  VCO_SPEED_1G21_1G40\tVCO_SPEED(1)\n#define  VCO_SPEED_1G40_1G61\tVCO_SPEED(2)\n#define  VCO_SPEED_1G61_1G86\tVCO_SPEED(3)\n#define  VCO_SPEED_1G86_2G00\tVCO_SPEED(4)\n#define  VCO_SPEED_2G00_2G22\tVCO_SPEED(5)\n#define  VCO_SPEED_2G22\t\tVCO_SPEED(6)\n#define  VCO_SPEED_MASK\t\tVCO_SPEED(0x7)\n#define  VCO_CLKDET_ENABLE\tBIT(26)\n#define VCO_CTRL1\t\tAVPLL_CTRL(1)\n#define  VCO_REFDIV_SHIFT\t0\n#define  VCO_REFDIV(x)\t\t((x) << VCO_REFDIV_SHIFT)\n#define  VCO_REFDIV_1\t\tVCO_REFDIV(0)\n#define  VCO_REFDIV_2\t\tVCO_REFDIV(1)\n#define  VCO_REFDIV_4\t\tVCO_REFDIV(2)\n#define  VCO_REFDIV_3\t\tVCO_REFDIV(3)\n#define  VCO_REFDIV_MASK\tVCO_REFDIV(0x3f)\n#define  VCO_FBDIV_SHIFT\t6\n#define  VCO_FBDIV(x)\t\t((x) << VCO_FBDIV_SHIFT)\n#define  VCO_FBDIV_MASK\t\tVCO_FBDIV(0xff)\n#define  VCO_ICP_SHIFT\t\t14\n \n#define  VCO_ICP(x)\t\t((x) << VCO_ICP_SHIFT)\n#define  VCO_ICP_MASK\t\tVCO_ICP(0xf)\n#define  VCO_LOAD_CAP\t\tBIT(18)\n#define  VCO_CALIBRATION_START\tBIT(19)\n#define VCO_FREQOFFSETn(x)\tAVPLL_CTRL(3 + (x))\n#define  VCO_FREQOFFSET_MASK\t0x7ffff\n#define VCO_CTRL10\t\tAVPLL_CTRL(10)\n#define  VCO_POWERUP_CH1\tBIT(20)\n#define VCO_CTRL11\t\tAVPLL_CTRL(11)\n#define VCO_CTRL12\t\tAVPLL_CTRL(12)\n#define VCO_CTRL13\t\tAVPLL_CTRL(13)\n#define VCO_CTRL14\t\tAVPLL_CTRL(14)\n#define VCO_CTRL15\t\tAVPLL_CTRL(15)\n#define VCO_SYNC1n(x)\t\tAVPLL_CTRL(15 + (x))\n#define  VCO_SYNC1_MASK\t\t0x1ffff\n#define VCO_SYNC2n(x)\t\tAVPLL_CTRL(23 + (x))\n#define  VCO_SYNC2_MASK\t\t0x1ffff\n#define VCO_CTRL30\t\tAVPLL_CTRL(30)\n#define  VCO_DPLL_CH1_ENABLE\tBIT(17)\n\nstruct berlin2_avpll_vco {\n\tstruct clk_hw hw;\n\tvoid __iomem *base;\n\tu8 flags;\n};\n\n#define to_avpll_vco(hw) container_of(hw, struct berlin2_avpll_vco, hw)\n\nstatic int berlin2_avpll_vco_is_enabled(struct clk_hw *hw)\n{\n\tstruct berlin2_avpll_vco *vco = to_avpll_vco(hw);\n\tu32 reg;\n\n\treg = readl_relaxed(vco->base + VCO_CTRL0);\n\tif (vco->flags & BERLIN2_AVPLL_BIT_QUIRK)\n\t\treg >>= 4;\n\n\treturn !!(reg & VCO_POWERUP);\n}\n\nstatic int berlin2_avpll_vco_enable(struct clk_hw *hw)\n{\n\tstruct berlin2_avpll_vco *vco = to_avpll_vco(hw);\n\tu32 reg;\n\n\treg = readl_relaxed(vco->base + VCO_CTRL0);\n\tif (vco->flags & BERLIN2_AVPLL_BIT_QUIRK)\n\t\treg |= VCO_POWERUP << 4;\n\telse\n\t\treg |= VCO_POWERUP;\n\twritel_relaxed(reg, vco->base + VCO_CTRL0);\n\n\treturn 0;\n}\n\nstatic void berlin2_avpll_vco_disable(struct clk_hw *hw)\n{\n\tstruct berlin2_avpll_vco *vco = to_avpll_vco(hw);\n\tu32 reg;\n\n\treg = readl_relaxed(vco->base + VCO_CTRL0);\n\tif (vco->flags & BERLIN2_AVPLL_BIT_QUIRK)\n\t\treg &= ~(VCO_POWERUP << 4);\n\telse\n\t\treg &= ~VCO_POWERUP;\n\twritel_relaxed(reg, vco->base + VCO_CTRL0);\n}\n\nstatic u8 vco_refdiv[] = { 1, 2, 4, 3 };\n\nstatic unsigned long\nberlin2_avpll_vco_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct berlin2_avpll_vco *vco = to_avpll_vco(hw);\n\tu32 reg, refdiv, fbdiv;\n\tu64 freq = parent_rate;\n\n\t \n\treg = readl_relaxed(vco->base + VCO_CTRL1);\n\trefdiv = (reg & VCO_REFDIV_MASK) >> VCO_REFDIV_SHIFT;\n\trefdiv = vco_refdiv[refdiv];\n\tfbdiv = (reg & VCO_FBDIV_MASK) >> VCO_FBDIV_SHIFT;\n\tfreq *= fbdiv;\n\tdo_div(freq, refdiv);\n\n\treturn (unsigned long)freq;\n}\n\nstatic const struct clk_ops berlin2_avpll_vco_ops = {\n\t.is_enabled\t= berlin2_avpll_vco_is_enabled,\n\t.enable\t\t= berlin2_avpll_vco_enable,\n\t.disable\t= berlin2_avpll_vco_disable,\n\t.recalc_rate\t= berlin2_avpll_vco_recalc_rate,\n};\n\nint __init berlin2_avpll_vco_register(void __iomem *base,\n\t\t\t       const char *name, const char *parent_name,\n\t\t\t       u8 vco_flags, unsigned long flags)\n{\n\tstruct berlin2_avpll_vco *vco;\n\tstruct clk_init_data init;\n\n\tvco = kzalloc(sizeof(*vco), GFP_KERNEL);\n\tif (!vco)\n\t\treturn -ENOMEM;\n\n\tvco->base = base;\n\tvco->flags = vco_flags;\n\tvco->hw.init = &init;\n\tinit.name = name;\n\tinit.ops = &berlin2_avpll_vco_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = flags;\n\n\treturn clk_hw_register(NULL, &vco->hw);\n}\n\nstruct berlin2_avpll_channel {\n\tstruct clk_hw hw;\n\tvoid __iomem *base;\n\tu8 flags;\n\tu8 index;\n};\n\n#define to_avpll_channel(hw) container_of(hw, struct berlin2_avpll_channel, hw)\n\nstatic int berlin2_avpll_channel_is_enabled(struct clk_hw *hw)\n{\n\tstruct berlin2_avpll_channel *ch = to_avpll_channel(hw);\n\tu32 reg;\n\n\tif (ch->index == 7)\n\t\treturn 1;\n\n\treg = readl_relaxed(ch->base + VCO_CTRL10);\n\treg &= VCO_POWERUP_CH1 << ch->index;\n\n\treturn !!reg;\n}\n\nstatic int berlin2_avpll_channel_enable(struct clk_hw *hw)\n{\n\tstruct berlin2_avpll_channel *ch = to_avpll_channel(hw);\n\tu32 reg;\n\n\treg = readl_relaxed(ch->base + VCO_CTRL10);\n\treg |= VCO_POWERUP_CH1 << ch->index;\n\twritel_relaxed(reg, ch->base + VCO_CTRL10);\n\n\treturn 0;\n}\n\nstatic void berlin2_avpll_channel_disable(struct clk_hw *hw)\n{\n\tstruct berlin2_avpll_channel *ch = to_avpll_channel(hw);\n\tu32 reg;\n\n\treg = readl_relaxed(ch->base + VCO_CTRL10);\n\treg &= ~(VCO_POWERUP_CH1 << ch->index);\n\twritel_relaxed(reg, ch->base + VCO_CTRL10);\n}\n\nstatic const u8 div_hdmi[] = { 1, 2, 4, 6 };\nstatic const u8 div_av1[] = { 1, 2, 5, 5 };\n\nstatic unsigned long\nberlin2_avpll_channel_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct berlin2_avpll_channel *ch = to_avpll_channel(hw);\n\tu32 reg, div_av2, div_av3, divider = 1;\n\tu64 freq = parent_rate;\n\n\treg = readl_relaxed(ch->base + VCO_CTRL30);\n\tif ((reg & (VCO_DPLL_CH1_ENABLE << ch->index)) == 0)\n\t\tgoto skip_div;\n\n\t \n\n\treg = readl_relaxed(ch->base + VCO_SYNC1n(ch->index));\n\t \n\tif (ch->flags & BERLIN2_AVPLL_BIT_QUIRK && ch->index == 0)\n\t\treg >>= 4;\n\tdivider = reg & VCO_SYNC1_MASK;\n\n\treg = readl_relaxed(ch->base + VCO_SYNC2n(ch->index));\n\tfreq *= reg & VCO_SYNC2_MASK;\n\n\t \n\tif (ch->index == 7)\n\t\tgoto skip_div;\n\n\t \n\treg = readl_relaxed(ch->base + VCO_CTRL11) >> 7;\n\treg = (reg >> (ch->index * 3));\n\tif (reg & BIT(2))\n\t\tdivider *= div_hdmi[reg & 0x3];\n\n\t \n\tif (ch->index == 0) {\n\t\treg = readl_relaxed(ch->base + VCO_CTRL11);\n\t\treg >>= 28;\n\t} else {\n\t\treg = readl_relaxed(ch->base + VCO_CTRL12);\n\t\treg >>= (ch->index-1) * 3;\n\t}\n\tif (reg & BIT(2))\n\t\tdivider *= div_av1[reg & 0x3];\n\n\t \n\tif (ch->index < 2) {\n\t\treg = readl_relaxed(ch->base + VCO_CTRL12);\n\t\treg >>= 18 + (ch->index * 7);\n\t} else if (ch->index < 7) {\n\t\treg = readl_relaxed(ch->base + VCO_CTRL13);\n\t\treg >>= (ch->index - 2) * 7;\n\t} else {\n\t\treg = readl_relaxed(ch->base + VCO_CTRL14);\n\t}\n\tdiv_av2 = reg & 0x7f;\n\tif (div_av2)\n\t\tdivider *= div_av2;\n\n\t \n\tif (ch->index < 6) {\n\t\treg = readl_relaxed(ch->base + VCO_CTRL14);\n\t\treg >>= 7 + (ch->index * 4);\n\t} else {\n\t\treg = readl_relaxed(ch->base + VCO_CTRL15);\n\t}\n\tdiv_av3 = reg & 0xf;\n\tif (div_av2 && div_av3)\n\t\tfreq *= 2;\n\nskip_div:\n\tdo_div(freq, divider);\n\treturn (unsigned long)freq;\n}\n\nstatic const struct clk_ops berlin2_avpll_channel_ops = {\n\t.is_enabled\t= berlin2_avpll_channel_is_enabled,\n\t.enable\t\t= berlin2_avpll_channel_enable,\n\t.disable\t= berlin2_avpll_channel_disable,\n\t.recalc_rate\t= berlin2_avpll_channel_recalc_rate,\n};\n\n \nstatic const u8 quirk_index[] __initconst = { 0, 6, 5, 4, 3, 2, 1, 7 };\n\nint __init berlin2_avpll_channel_register(void __iomem *base,\n\t\t\t   const char *name, u8 index, const char *parent_name,\n\t\t\t   u8 ch_flags, unsigned long flags)\n{\n\tstruct berlin2_avpll_channel *ch;\n\tstruct clk_init_data init;\n\n\tch = kzalloc(sizeof(*ch), GFP_KERNEL);\n\tif (!ch)\n\t\treturn -ENOMEM;\n\n\tch->base = base;\n\tif (ch_flags & BERLIN2_AVPLL_SCRAMBLE_QUIRK)\n\t\tch->index = quirk_index[index];\n\telse\n\t\tch->index = index;\n\n\tch->flags = ch_flags;\n\tch->hw.init = &init;\n\tinit.name = name;\n\tinit.ops = &berlin2_avpll_channel_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = flags;\n\n\treturn clk_hw_register(NULL, &ch->hw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}