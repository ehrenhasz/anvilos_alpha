{
  "module_name": "bg2q.c",
  "hash_id": "8303e338d4c2d34b8a4892a2f72ce020870da313b4bf13a7f98d857a11b29e4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/berlin/bg2q.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/clock/berlin2q.h>\n\n#include \"berlin2-div.h\"\n#include \"berlin2-pll.h\"\n#include \"common.h\"\n\n#define REG_PINMUX0\t\t0x0018\n#define REG_PINMUX5\t\t0x002c\n#define REG_SYSPLLCTL0\t\t0x0030\n#define REG_SYSPLLCTL4\t\t0x0040\n#define REG_CLKENABLE\t\t0x00e8\n#define REG_CLKSELECT0\t\t0x00ec\n#define REG_CLKSELECT1\t\t0x00f0\n#define REG_CLKSELECT2\t\t0x00f4\n#define REG_CLKSWITCH0\t\t0x00f8\n#define REG_CLKSWITCH1\t\t0x00fc\n#define REG_SW_GENERIC0\t\t0x0110\n#define REG_SW_GENERIC3\t\t0x011c\n#define REG_SDIO0XIN_CLKCTL\t0x0158\n#define REG_SDIO1XIN_CLKCTL\t0x015c\n\n#define\tMAX_CLKS 28\nstatic struct clk_hw_onecell_data *clk_data;\nstatic DEFINE_SPINLOCK(lock);\nstatic void __iomem *gbase;\nstatic void __iomem *cpupll_base;\n\nenum {\n\tREFCLK,\n\tSYSPLL, CPUPLL,\n\tAVPLL_B1, AVPLL_B2, AVPLL_B3, AVPLL_B4,\n\tAVPLL_B5, AVPLL_B6, AVPLL_B7, AVPLL_B8,\n};\n\nstatic const char *clk_names[] = {\n\t[REFCLK]\t\t= \"refclk\",\n\t[SYSPLL]\t\t= \"syspll\",\n\t[CPUPLL]\t\t= \"cpupll\",\n\t[AVPLL_B1]\t\t= \"avpll_b1\",\n\t[AVPLL_B2]\t\t= \"avpll_b2\",\n\t[AVPLL_B3]\t\t= \"avpll_b3\",\n\t[AVPLL_B4]\t\t= \"avpll_b4\",\n\t[AVPLL_B5]\t\t= \"avpll_b5\",\n\t[AVPLL_B6]\t\t= \"avpll_b6\",\n\t[AVPLL_B7]\t\t= \"avpll_b7\",\n\t[AVPLL_B8]\t\t= \"avpll_b8\",\n};\n\nstatic const struct berlin2_pll_map bg2q_pll_map __initconst = {\n\t.vcodiv\t\t= {1, 0, 2, 0, 3, 4, 0, 6, 8},\n\t.mult\t\t= 1,\n\t.fbdiv_shift\t= 7,\n\t.rfdiv_shift\t= 2,\n\t.divsel_shift\t= 9,\n};\n\nstatic const u8 default_parent_ids[] = {\n\tSYSPLL, AVPLL_B4, AVPLL_B5, AVPLL_B6, AVPLL_B7, SYSPLL\n};\n\nstatic const struct berlin2_div_data bg2q_divs[] __initconst = {\n\t{\n\t\t.name = \"sys\",\n\t\t.parent_ids = default_parent_ids,\n\t\t.num_parents = ARRAY_SIZE(default_parent_ids),\n\t\t.map = {\n\t\t\tBERLIN2_DIV_GATE(REG_CLKENABLE, 0),\n\t\t\tBERLIN2_PLL_SELECT(REG_CLKSELECT0, 0),\n\t\t\tBERLIN2_DIV_SELECT(REG_CLKSELECT0, 3),\n\t\t\tBERLIN2_PLL_SWITCH(REG_CLKSWITCH0, 3),\n\t\t\tBERLIN2_DIV_SWITCH(REG_CLKSWITCH0, 4),\n\t\t\tBERLIN2_DIV_D3SWITCH(REG_CLKSWITCH0, 5),\n\t\t},\n\t\t.div_flags = BERLIN2_DIV_HAS_GATE | BERLIN2_DIV_HAS_MUX,\n\t\t.flags = CLK_IGNORE_UNUSED,\n\t},\n\t{\n\t\t.name = \"drmfigo\",\n\t\t.parent_ids = default_parent_ids,\n\t\t.num_parents = ARRAY_SIZE(default_parent_ids),\n\t\t.map = {\n\t\t\tBERLIN2_DIV_GATE(REG_CLKENABLE, 17),\n\t\t\tBERLIN2_PLL_SELECT(REG_CLKSELECT0, 6),\n\t\t\tBERLIN2_DIV_SELECT(REG_CLKSELECT0, 9),\n\t\t\tBERLIN2_PLL_SWITCH(REG_CLKSWITCH0, 6),\n\t\t\tBERLIN2_DIV_SWITCH(REG_CLKSWITCH0, 7),\n\t\t\tBERLIN2_DIV_D3SWITCH(REG_CLKSWITCH0, 8),\n\t\t},\n\t\t.div_flags = BERLIN2_DIV_HAS_GATE | BERLIN2_DIV_HAS_MUX,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"cfg\",\n\t\t.parent_ids = default_parent_ids,\n\t\t.num_parents = ARRAY_SIZE(default_parent_ids),\n\t\t.map = {\n\t\t\tBERLIN2_DIV_GATE(REG_CLKENABLE, 1),\n\t\t\tBERLIN2_PLL_SELECT(REG_CLKSELECT0, 12),\n\t\t\tBERLIN2_DIV_SELECT(REG_CLKSELECT0, 15),\n\t\t\tBERLIN2_PLL_SWITCH(REG_CLKSWITCH0, 9),\n\t\t\tBERLIN2_DIV_SWITCH(REG_CLKSWITCH0, 10),\n\t\t\tBERLIN2_DIV_D3SWITCH(REG_CLKSWITCH0, 11),\n\t\t},\n\t\t.div_flags = BERLIN2_DIV_HAS_GATE | BERLIN2_DIV_HAS_MUX,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"gfx2d\",\n\t\t.parent_ids = default_parent_ids,\n\t\t.num_parents = ARRAY_SIZE(default_parent_ids),\n\t\t.map = {\n\t\t\tBERLIN2_DIV_GATE(REG_CLKENABLE, 4),\n\t\t\tBERLIN2_PLL_SELECT(REG_CLKSELECT0, 18),\n\t\t\tBERLIN2_DIV_SELECT(REG_CLKSELECT0, 21),\n\t\t\tBERLIN2_PLL_SWITCH(REG_CLKSWITCH0, 12),\n\t\t\tBERLIN2_DIV_SWITCH(REG_CLKSWITCH0, 13),\n\t\t\tBERLIN2_DIV_D3SWITCH(REG_CLKSWITCH0, 14),\n\t\t},\n\t\t.div_flags = BERLIN2_DIV_HAS_GATE | BERLIN2_DIV_HAS_MUX,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"zsp\",\n\t\t.parent_ids = default_parent_ids,\n\t\t.num_parents = ARRAY_SIZE(default_parent_ids),\n\t\t.map = {\n\t\t\tBERLIN2_DIV_GATE(REG_CLKENABLE, 6),\n\t\t\tBERLIN2_PLL_SELECT(REG_CLKSELECT0, 24),\n\t\t\tBERLIN2_DIV_SELECT(REG_CLKSELECT0, 27),\n\t\t\tBERLIN2_PLL_SWITCH(REG_CLKSWITCH0, 15),\n\t\t\tBERLIN2_DIV_SWITCH(REG_CLKSWITCH0, 16),\n\t\t\tBERLIN2_DIV_D3SWITCH(REG_CLKSWITCH0, 17),\n\t\t},\n\t\t.div_flags = BERLIN2_DIV_HAS_GATE | BERLIN2_DIV_HAS_MUX,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"perif\",\n\t\t.parent_ids = default_parent_ids,\n\t\t.num_parents = ARRAY_SIZE(default_parent_ids),\n\t\t.map = {\n\t\t\tBERLIN2_DIV_GATE(REG_CLKENABLE, 7),\n\t\t\tBERLIN2_PLL_SELECT(REG_CLKSELECT1, 0),\n\t\t\tBERLIN2_DIV_SELECT(REG_CLKSELECT1, 3),\n\t\t\tBERLIN2_PLL_SWITCH(REG_CLKSWITCH0, 18),\n\t\t\tBERLIN2_DIV_SWITCH(REG_CLKSWITCH0, 19),\n\t\t\tBERLIN2_DIV_D3SWITCH(REG_CLKSWITCH0, 20),\n\t\t},\n\t\t.div_flags = BERLIN2_DIV_HAS_GATE | BERLIN2_DIV_HAS_MUX,\n\t\t.flags = CLK_IGNORE_UNUSED,\n\t},\n\t{\n\t\t.name = \"pcube\",\n\t\t.parent_ids = default_parent_ids,\n\t\t.num_parents = ARRAY_SIZE(default_parent_ids),\n\t\t.map = {\n\t\t\tBERLIN2_DIV_GATE(REG_CLKENABLE, 2),\n\t\t\tBERLIN2_PLL_SELECT(REG_CLKSELECT1, 6),\n\t\t\tBERLIN2_DIV_SELECT(REG_CLKSELECT1, 9),\n\t\t\tBERLIN2_PLL_SWITCH(REG_CLKSWITCH0, 21),\n\t\t\tBERLIN2_DIV_SWITCH(REG_CLKSWITCH0, 22),\n\t\t\tBERLIN2_DIV_D3SWITCH(REG_CLKSWITCH0, 23),\n\t\t},\n\t\t.div_flags = BERLIN2_DIV_HAS_GATE | BERLIN2_DIV_HAS_MUX,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"vscope\",\n\t\t.parent_ids = default_parent_ids,\n\t\t.num_parents = ARRAY_SIZE(default_parent_ids),\n\t\t.map = {\n\t\t\tBERLIN2_DIV_GATE(REG_CLKENABLE, 3),\n\t\t\tBERLIN2_PLL_SELECT(REG_CLKSELECT1, 12),\n\t\t\tBERLIN2_DIV_SELECT(REG_CLKSELECT1, 15),\n\t\t\tBERLIN2_PLL_SWITCH(REG_CLKSWITCH0, 24),\n\t\t\tBERLIN2_DIV_SWITCH(REG_CLKSWITCH0, 25),\n\t\t\tBERLIN2_DIV_D3SWITCH(REG_CLKSWITCH0, 26),\n\t\t},\n\t\t.div_flags = BERLIN2_DIV_HAS_GATE | BERLIN2_DIV_HAS_MUX,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"nfc_ecc\",\n\t\t.parent_ids = default_parent_ids,\n\t\t.num_parents = ARRAY_SIZE(default_parent_ids),\n\t\t.map = {\n\t\t\tBERLIN2_DIV_GATE(REG_CLKENABLE, 19),\n\t\t\tBERLIN2_PLL_SELECT(REG_CLKSELECT1, 18),\n\t\t\tBERLIN2_DIV_SELECT(REG_CLKSELECT1, 21),\n\t\t\tBERLIN2_PLL_SWITCH(REG_CLKSWITCH0, 27),\n\t\t\tBERLIN2_DIV_SWITCH(REG_CLKSWITCH0, 28),\n\t\t\tBERLIN2_DIV_D3SWITCH(REG_CLKSWITCH0, 29),\n\t\t},\n\t\t.div_flags = BERLIN2_DIV_HAS_GATE | BERLIN2_DIV_HAS_MUX,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"vpp\",\n\t\t.parent_ids = default_parent_ids,\n\t\t.num_parents = ARRAY_SIZE(default_parent_ids),\n\t\t.map = {\n\t\t\tBERLIN2_DIV_GATE(REG_CLKENABLE, 21),\n\t\t\tBERLIN2_PLL_SELECT(REG_CLKSELECT1, 24),\n\t\t\tBERLIN2_DIV_SELECT(REG_CLKSELECT1, 27),\n\t\t\tBERLIN2_PLL_SWITCH(REG_CLKSWITCH0, 30),\n\t\t\tBERLIN2_DIV_SWITCH(REG_CLKSWITCH0, 31),\n\t\t\tBERLIN2_DIV_D3SWITCH(REG_CLKSWITCH1, 0),\n\t\t},\n\t\t.div_flags = BERLIN2_DIV_HAS_GATE | BERLIN2_DIV_HAS_MUX,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"app\",\n\t\t.parent_ids = default_parent_ids,\n\t\t.num_parents = ARRAY_SIZE(default_parent_ids),\n\t\t.map = {\n\t\t\tBERLIN2_DIV_GATE(REG_CLKENABLE, 20),\n\t\t\tBERLIN2_PLL_SELECT(REG_CLKSELECT2, 0),\n\t\t\tBERLIN2_DIV_SELECT(REG_CLKSELECT2, 3),\n\t\t\tBERLIN2_PLL_SWITCH(REG_CLKSWITCH1, 1),\n\t\t\tBERLIN2_DIV_SWITCH(REG_CLKSWITCH1, 2),\n\t\t\tBERLIN2_DIV_D3SWITCH(REG_CLKSWITCH1, 3),\n\t\t},\n\t\t.div_flags = BERLIN2_DIV_HAS_GATE | BERLIN2_DIV_HAS_MUX,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"sdio0xin\",\n\t\t.parent_ids = default_parent_ids,\n\t\t.num_parents = ARRAY_SIZE(default_parent_ids),\n\t\t.map = {\n\t\t\tBERLIN2_SINGLE_DIV(REG_SDIO0XIN_CLKCTL),\n\t\t},\n\t\t.div_flags = BERLIN2_DIV_HAS_GATE | BERLIN2_DIV_HAS_MUX,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"sdio1xin\",\n\t\t.parent_ids = default_parent_ids,\n\t\t.num_parents = ARRAY_SIZE(default_parent_ids),\n\t\t.map = {\n\t\t\tBERLIN2_SINGLE_DIV(REG_SDIO1XIN_CLKCTL),\n\t\t},\n\t\t.div_flags = BERLIN2_DIV_HAS_GATE | BERLIN2_DIV_HAS_MUX,\n\t\t.flags = 0,\n\t},\n};\n\nstatic const struct berlin2_gate_data bg2q_gates[] __initconst = {\n\t{ \"gfx2daxi\",\t\"perif\",\t5 },\n\t{ \"geth0\",\t\"perif\",\t8 },\n\t{ \"sata\",\t\"perif\",\t9 },\n\t{ \"ahbapb\",\t\"perif\",\t10, CLK_IGNORE_UNUSED },\n\t{ \"usb0\",\t\"perif\",\t11 },\n\t{ \"usb1\",\t\"perif\",\t12 },\n\t{ \"usb2\",\t\"perif\",\t13 },\n\t{ \"usb3\",\t\"perif\",\t14 },\n\t{ \"pbridge\",\t\"perif\",\t15, CLK_IGNORE_UNUSED },\n\t{ \"sdio\",\t\"perif\",\t16 },\n\t{ \"nfc\",\t\"perif\",\t18 },\n\t{ \"pcie\",\t\"perif\",\t22 },\n};\n\nstatic void __init berlin2q_clock_setup(struct device_node *np)\n{\n\tstruct device_node *parent_np = of_get_parent(np);\n\tconst char *parent_names[9];\n\tstruct clk *clk;\n\tstruct clk_hw **hws;\n\tint n, ret;\n\n\tclk_data = kzalloc(struct_size(clk_data, hws, MAX_CLKS), GFP_KERNEL);\n\tif (!clk_data) {\n\t\tof_node_put(parent_np);\n\t\treturn;\n\t}\n\tclk_data->num = MAX_CLKS;\n\thws = clk_data->hws;\n\n\tgbase = of_iomap(parent_np, 0);\n\tif (!gbase) {\n\t\tof_node_put(parent_np);\n\t\tpr_err(\"%pOF: Unable to map global base\\n\", np);\n\t\treturn;\n\t}\n\n\t \n\tcpupll_base = of_iomap(parent_np, 1);\n\tof_node_put(parent_np);\n\tif (!cpupll_base) {\n\t\tpr_err(\"%pOF: Unable to map cpupll base\\n\", np);\n\t\tiounmap(gbase);\n\t\treturn;\n\t}\n\n\t \n\tclk = of_clk_get_by_name(np, clk_names[REFCLK]);\n\tif (!IS_ERR(clk)) {\n\t\tclk_names[REFCLK] = __clk_get_name(clk);\n\t\tclk_put(clk);\n\t}\n\n\t \n\tret = berlin2_pll_register(&bg2q_pll_map, gbase + REG_SYSPLLCTL0,\n\t\t\t\t   clk_names[SYSPLL], clk_names[REFCLK], 0);\n\tif (ret)\n\t\tgoto bg2q_fail;\n\n\tret = berlin2_pll_register(&bg2q_pll_map, cpupll_base,\n\t\t\t\t   clk_names[CPUPLL], clk_names[REFCLK], 0);\n\tif (ret)\n\t\tgoto bg2q_fail;\n\n\t \n\n\t \n\n\t \n\tfor (n = 0; n < ARRAY_SIZE(bg2q_divs); n++) {\n\t\tconst struct berlin2_div_data *dd = &bg2q_divs[n];\n\t\tint k;\n\n\t\tfor (k = 0; k < dd->num_parents; k++)\n\t\t\tparent_names[k] = clk_names[dd->parent_ids[k]];\n\n\t\thws[CLKID_SYS + n] = berlin2_div_register(&dd->map, gbase,\n\t\t\t\tdd->name, dd->div_flags, parent_names,\n\t\t\t\tdd->num_parents, dd->flags, &lock);\n\t}\n\n\t \n\tfor (n = 0; n < ARRAY_SIZE(bg2q_gates); n++) {\n\t\tconst struct berlin2_gate_data *gd = &bg2q_gates[n];\n\n\t\thws[CLKID_GFX2DAXI + n] = clk_hw_register_gate(NULL, gd->name,\n\t\t\t    gd->parent_name, gd->flags, gbase + REG_CLKENABLE,\n\t\t\t    gd->bit_idx, 0, &lock);\n\t}\n\n\t \n\thws[CLKID_CPU] =\n\t\tclk_hw_register_fixed_factor(NULL, \"cpu\", clk_names[CPUPLL],\n\t\t\t\t\t  0, 1, 1);\n\t \n\thws[CLKID_TWD] =\n\t\tclk_hw_register_fixed_factor(NULL, \"twd\", \"cpu\", 0, 1, 3);\n\n\t \n\tfor (n = 0; n < MAX_CLKS; n++) {\n\t\tif (!IS_ERR(hws[n]))\n\t\t\tcontinue;\n\n\t\tpr_err(\"%pOF: Unable to register leaf clock %d\\n\", np, n);\n\t\tgoto bg2q_fail;\n\t}\n\n\t \n\tof_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_data);\n\n\treturn;\n\nbg2q_fail:\n\tiounmap(cpupll_base);\n\tiounmap(gbase);\n}\nCLK_OF_DECLARE(berlin2q_clk, \"marvell,berlin2q-clk\",\n\t       berlin2q_clock_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}