{
  "module_name": "berlin2-div.c",
  "hash_id": "e5ef4aa2c0f2caea1c4478304857ff76d65de2f152ab5669f00a10672ea860a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/berlin/berlin2-div.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include \"berlin2-div.h\"\n\n \n\n#define PLL_SELECT_MASK\t0x7\n#define DIV_SELECT_MASK\t0x7\n\nstruct berlin2_div {\n\tstruct clk_hw hw;\n\tvoid __iomem *base;\n\tstruct berlin2_div_map map;\n\tspinlock_t *lock;\n};\n\n#define to_berlin2_div(hw) container_of(hw, struct berlin2_div, hw)\n\nstatic u8 clk_div[] = { 1, 2, 4, 6, 8, 12, 1, 1 };\n\nstatic int berlin2_div_is_enabled(struct clk_hw *hw)\n{\n\tstruct berlin2_div *div = to_berlin2_div(hw);\n\tstruct berlin2_div_map *map = &div->map;\n\tu32 reg;\n\n\tif (div->lock)\n\t\tspin_lock(div->lock);\n\n\treg = readl_relaxed(div->base + map->gate_offs);\n\treg >>= map->gate_shift;\n\n\tif (div->lock)\n\t\tspin_unlock(div->lock);\n\n\treturn (reg & 0x1);\n}\n\nstatic int berlin2_div_enable(struct clk_hw *hw)\n{\n\tstruct berlin2_div *div = to_berlin2_div(hw);\n\tstruct berlin2_div_map *map = &div->map;\n\tu32 reg;\n\n\tif (div->lock)\n\t\tspin_lock(div->lock);\n\n\treg = readl_relaxed(div->base + map->gate_offs);\n\treg |= BIT(map->gate_shift);\n\twritel_relaxed(reg, div->base + map->gate_offs);\n\n\tif (div->lock)\n\t\tspin_unlock(div->lock);\n\n\treturn 0;\n}\n\nstatic void berlin2_div_disable(struct clk_hw *hw)\n{\n\tstruct berlin2_div *div = to_berlin2_div(hw);\n\tstruct berlin2_div_map *map = &div->map;\n\tu32 reg;\n\n\tif (div->lock)\n\t\tspin_lock(div->lock);\n\n\treg = readl_relaxed(div->base + map->gate_offs);\n\treg &= ~BIT(map->gate_shift);\n\twritel_relaxed(reg, div->base + map->gate_offs);\n\n\tif (div->lock)\n\t\tspin_unlock(div->lock);\n}\n\nstatic int berlin2_div_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct berlin2_div *div = to_berlin2_div(hw);\n\tstruct berlin2_div_map *map = &div->map;\n\tu32 reg;\n\n\tif (div->lock)\n\t\tspin_lock(div->lock);\n\n\t \n\treg = readl_relaxed(div->base + map->pll_switch_offs);\n\tif (index == 0)\n\t\treg &= ~BIT(map->pll_switch_shift);\n\telse\n\t\treg |= BIT(map->pll_switch_shift);\n\twritel_relaxed(reg, div->base + map->pll_switch_offs);\n\n\t \n\tif (index > 0) {\n\t\treg = readl_relaxed(div->base + map->pll_select_offs);\n\t\treg &= ~(PLL_SELECT_MASK << map->pll_select_shift);\n\t\treg |= (index - 1) << map->pll_select_shift;\n\t\twritel_relaxed(reg, div->base + map->pll_select_offs);\n\t}\n\n\tif (div->lock)\n\t\tspin_unlock(div->lock);\n\n\treturn 0;\n}\n\nstatic u8 berlin2_div_get_parent(struct clk_hw *hw)\n{\n\tstruct berlin2_div *div = to_berlin2_div(hw);\n\tstruct berlin2_div_map *map = &div->map;\n\tu32 reg;\n\tu8 index = 0;\n\n\tif (div->lock)\n\t\tspin_lock(div->lock);\n\n\t \n\treg = readl_relaxed(div->base + map->pll_switch_offs);\n\treg &= BIT(map->pll_switch_shift);\n\tif (reg) {\n\t\treg = readl_relaxed(div->base + map->pll_select_offs);\n\t\treg >>= map->pll_select_shift;\n\t\treg &= PLL_SELECT_MASK;\n\t\tindex = 1 + reg;\n\t}\n\n\tif (div->lock)\n\t\tspin_unlock(div->lock);\n\n\treturn index;\n}\n\nstatic unsigned long berlin2_div_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct berlin2_div *div = to_berlin2_div(hw);\n\tstruct berlin2_div_map *map = &div->map;\n\tu32 divsw, div3sw, divider = 1;\n\n\tif (div->lock)\n\t\tspin_lock(div->lock);\n\n\tdivsw = readl_relaxed(div->base + map->div_switch_offs) &\n\t\t(1 << map->div_switch_shift);\n\tdiv3sw = readl_relaxed(div->base + map->div3_switch_offs) &\n\t\t(1 << map->div3_switch_shift);\n\n\t \n\tif (div3sw != 0) {\n\t\tdivider = 3;\n\t \n\t} else if (divsw == 0) {\n\t\tdivider = 1;\n\t \n\t} else {\n\t\tu32 reg;\n\t\treg = readl_relaxed(div->base + map->div_select_offs);\n\t\treg >>= map->div_select_shift;\n\t\treg &= DIV_SELECT_MASK;\n\t\tdivider = clk_div[reg];\n\t}\n\n\tif (div->lock)\n\t\tspin_unlock(div->lock);\n\n\treturn parent_rate / divider;\n}\n\nstatic const struct clk_ops berlin2_div_rate_ops = {\n\t.determine_rate\t= clk_hw_determine_rate_no_reparent,\n\t.recalc_rate\t= berlin2_div_recalc_rate,\n};\n\nstatic const struct clk_ops berlin2_div_gate_ops = {\n\t.is_enabled\t= berlin2_div_is_enabled,\n\t.enable\t\t= berlin2_div_enable,\n\t.disable\t= berlin2_div_disable,\n};\n\nstatic const struct clk_ops berlin2_div_mux_ops = {\n\t.set_parent\t= berlin2_div_set_parent,\n\t.get_parent\t= berlin2_div_get_parent,\n};\n\nstruct clk_hw * __init\nberlin2_div_register(const struct berlin2_div_map *map,\n\t\t     void __iomem *base, const char *name, u8 div_flags,\n\t\t     const char **parent_names, int num_parents,\n\t\t     unsigned long flags, spinlock_t *lock)\n{\n\tconst struct clk_ops *mux_ops = &berlin2_div_mux_ops;\n\tconst struct clk_ops *rate_ops = &berlin2_div_rate_ops;\n\tconst struct clk_ops *gate_ops = &berlin2_div_gate_ops;\n\tstruct berlin2_div *div;\n\n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tmemcpy(&div->map, map, sizeof(*map));\n\tdiv->base = base;\n\tdiv->lock = lock;\n\n\tif ((div_flags & BERLIN2_DIV_HAS_GATE) == 0)\n\t\tgate_ops = NULL;\n\tif ((div_flags & BERLIN2_DIV_HAS_MUX) == 0)\n\t\tmux_ops = NULL;\n\n\treturn clk_hw_register_composite(NULL, name, parent_names, num_parents,\n\t\t\t\t      &div->hw, mux_ops, &div->hw, rate_ops,\n\t\t\t\t      &div->hw, gate_ops, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}