{
  "module_name": "clk_test.c",
  "hash_id": "367f0e7c531ca3033422bb6fb92597d5dee1c9e599f55a4cc72d49ea6e66791f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk_test.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n\n \n#include \"clk.h\"\n\n#include <kunit/test.h>\n\n#define DUMMY_CLOCK_INIT_RATE\t(42 * 1000 * 1000)\n#define DUMMY_CLOCK_RATE_1\t(142 * 1000 * 1000)\n#define DUMMY_CLOCK_RATE_2\t(242 * 1000 * 1000)\n\nstruct clk_dummy_context {\n\tstruct clk_hw hw;\n\tunsigned long rate;\n};\n\nstatic unsigned long clk_dummy_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct clk_dummy_context *ctx =\n\t\tcontainer_of(hw, struct clk_dummy_context, hw);\n\n\treturn ctx->rate;\n}\n\nstatic int clk_dummy_determine_rate(struct clk_hw *hw,\n\t\t\t\t    struct clk_rate_request *req)\n{\n\t \n\treturn 0;\n}\n\nstatic int clk_dummy_maximize_rate(struct clk_hw *hw,\n\t\t\t\t   struct clk_rate_request *req)\n{\n\t \n\tif (req->max_rate < ULONG_MAX)\n\t\treq->rate = req->max_rate;\n\n\treturn 0;\n}\n\nstatic int clk_dummy_minimize_rate(struct clk_hw *hw,\n\t\t\t\t   struct clk_rate_request *req)\n{\n\t \n\tif (req->min_rate > 0)\n\t\treq->rate = req->min_rate;\n\n\treturn 0;\n}\n\nstatic int clk_dummy_set_rate(struct clk_hw *hw,\n\t\t\t      unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct clk_dummy_context *ctx =\n\t\tcontainer_of(hw, struct clk_dummy_context, hw);\n\n\tctx->rate = rate;\n\treturn 0;\n}\n\nstatic int clk_dummy_single_set_parent(struct clk_hw *hw, u8 index)\n{\n\tif (index >= clk_hw_get_num_parents(hw))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic u8 clk_dummy_single_get_parent(struct clk_hw *hw)\n{\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_dummy_rate_ops = {\n\t.recalc_rate = clk_dummy_recalc_rate,\n\t.determine_rate = clk_dummy_determine_rate,\n\t.set_rate = clk_dummy_set_rate,\n};\n\nstatic const struct clk_ops clk_dummy_maximize_rate_ops = {\n\t.recalc_rate = clk_dummy_recalc_rate,\n\t.determine_rate = clk_dummy_maximize_rate,\n\t.set_rate = clk_dummy_set_rate,\n};\n\nstatic const struct clk_ops clk_dummy_minimize_rate_ops = {\n\t.recalc_rate = clk_dummy_recalc_rate,\n\t.determine_rate = clk_dummy_minimize_rate,\n\t.set_rate = clk_dummy_set_rate,\n};\n\nstatic const struct clk_ops clk_dummy_single_parent_ops = {\n\t \n\t.determine_rate = __clk_mux_determine_rate_closest,\n\t.set_parent = clk_dummy_single_set_parent,\n\t.get_parent = clk_dummy_single_get_parent,\n};\n\nstruct clk_multiple_parent_ctx {\n\tstruct clk_dummy_context parents_ctx[2];\n\tstruct clk_hw hw;\n\tu8 current_parent;\n};\n\nstatic int clk_multiple_parents_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_multiple_parent_ctx *ctx =\n\t\tcontainer_of(hw, struct clk_multiple_parent_ctx, hw);\n\n\tif (index >= clk_hw_get_num_parents(hw))\n\t\treturn -EINVAL;\n\n\tctx->current_parent = index;\n\n\treturn 0;\n}\n\nstatic u8 clk_multiple_parents_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_multiple_parent_ctx *ctx =\n\t\tcontainer_of(hw, struct clk_multiple_parent_ctx, hw);\n\n\treturn ctx->current_parent;\n}\n\nstatic const struct clk_ops clk_multiple_parents_mux_ops = {\n\t.get_parent = clk_multiple_parents_mux_get_parent,\n\t.set_parent = clk_multiple_parents_mux_set_parent,\n\t.determine_rate = __clk_mux_determine_rate_closest,\n};\n\nstatic const struct clk_ops clk_multiple_parents_no_reparent_mux_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.get_parent = clk_multiple_parents_mux_get_parent,\n\t.set_parent = clk_multiple_parents_mux_set_parent,\n};\n\nstatic int clk_test_init_with_ops(struct kunit *test, const struct clk_ops *ops)\n{\n\tstruct clk_dummy_context *ctx;\n\tstruct clk_init_data init = { };\n\tint ret;\n\n\tctx = kunit_kzalloc(test, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->rate = DUMMY_CLOCK_INIT_RATE;\n\ttest->priv = ctx;\n\n\tinit.name = \"test_dummy_rate\";\n\tinit.ops = ops;\n\tctx->hw.init = &init;\n\n\tret = clk_hw_register(NULL, &ctx->hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int clk_test_init(struct kunit *test)\n{\n\treturn clk_test_init_with_ops(test, &clk_dummy_rate_ops);\n}\n\nstatic int clk_maximize_test_init(struct kunit *test)\n{\n\treturn clk_test_init_with_ops(test, &clk_dummy_maximize_rate_ops);\n}\n\nstatic int clk_minimize_test_init(struct kunit *test)\n{\n\treturn clk_test_init_with_ops(test, &clk_dummy_minimize_rate_ops);\n}\n\nstatic void clk_test_exit(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\n\tclk_hw_unregister(&ctx->hw);\n}\n\n \nstatic void clk_test_get_rate(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, ctx->rate);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_test_set_get_rate(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate(clk, DUMMY_CLOCK_RATE_1),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_1);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_test_set_set_get_rate(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate(clk, DUMMY_CLOCK_RATE_1),\n\t\t\t0);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate(clk, DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_test_round_set_get_rate(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long set_rate;\n\tlong rounded_rate;\n\n\trounded_rate = clk_round_rate(clk, DUMMY_CLOCK_RATE_1);\n\tKUNIT_ASSERT_GT(test, rounded_rate, 0);\n\tKUNIT_EXPECT_EQ(test, rounded_rate, DUMMY_CLOCK_RATE_1);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate(clk, DUMMY_CLOCK_RATE_1),\n\t\t\t0);\n\n\tset_rate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, set_rate, 0);\n\tKUNIT_EXPECT_EQ(test, rounded_rate, set_rate);\n\n\tclk_put(clk);\n}\n\nstatic struct kunit_case clk_test_cases[] = {\n\tKUNIT_CASE(clk_test_get_rate),\n\tKUNIT_CASE(clk_test_set_get_rate),\n\tKUNIT_CASE(clk_test_set_set_get_rate),\n\tKUNIT_CASE(clk_test_round_set_get_rate),\n\t{}\n};\n\n \nstatic struct kunit_suite clk_test_suite = {\n\t.name = \"clk-test\",\n\t.init = clk_test_init,\n\t.exit = clk_test_exit,\n\t.test_cases = clk_test_cases,\n};\n\nstatic int clk_uncached_test_init(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx;\n\tint ret;\n\n\tctx = kunit_kzalloc(test, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\ttest->priv = ctx;\n\n\tctx->rate = DUMMY_CLOCK_INIT_RATE;\n\tctx->hw.init = CLK_HW_INIT_NO_PARENT(\"test-clk\",\n\t\t\t\t\t     &clk_dummy_rate_ops,\n\t\t\t\t\t     CLK_GET_RATE_NOCACHE);\n\n\tret = clk_hw_register(NULL, &ctx->hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic void clk_test_uncached_get_rate(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_INIT_RATE);\n\n\t \n\tctx->rate = DUMMY_CLOCK_RATE_1;\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_1);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_test_uncached_set_range(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_test_uncached_updated_rate_set_range(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\n\t \n\tctx->rate = DUMMY_CLOCK_RATE_1 + 1000;\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_1 + 1000);\n\n\tclk_put(clk);\n}\n\nstatic struct kunit_case clk_uncached_test_cases[] = {\n\tKUNIT_CASE(clk_test_uncached_get_rate),\n\tKUNIT_CASE(clk_test_uncached_set_range),\n\tKUNIT_CASE(clk_test_uncached_updated_rate_set_range),\n\t{}\n};\n\n \nstatic struct kunit_suite clk_uncached_test_suite = {\n\t.name = \"clk-uncached-test\",\n\t.init = clk_uncached_test_init,\n\t.exit = clk_test_exit,\n\t.test_cases = clk_uncached_test_cases,\n};\n\nstatic int\nclk_multiple_parents_mux_test_init(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx;\n\tconst char *parents[2] = { \"parent-0\", \"parent-1\"};\n\tint ret;\n\n\tctx = kunit_kzalloc(test, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\ttest->priv = ctx;\n\n\tctx->parents_ctx[0].hw.init = CLK_HW_INIT_NO_PARENT(\"parent-0\",\n\t\t\t\t\t\t\t    &clk_dummy_rate_ops,\n\t\t\t\t\t\t\t    0);\n\tctx->parents_ctx[0].rate = DUMMY_CLOCK_RATE_1;\n\tret = clk_hw_register(NULL, &ctx->parents_ctx[0].hw);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->parents_ctx[1].hw.init = CLK_HW_INIT_NO_PARENT(\"parent-1\",\n\t\t\t\t\t\t\t    &clk_dummy_rate_ops,\n\t\t\t\t\t\t\t    0);\n\tctx->parents_ctx[1].rate = DUMMY_CLOCK_RATE_2;\n\tret = clk_hw_register(NULL, &ctx->parents_ctx[1].hw);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->current_parent = 0;\n\tctx->hw.init = CLK_HW_INIT_PARENTS(\"test-mux\", parents,\n\t\t\t\t\t   &clk_multiple_parents_mux_ops,\n\t\t\t\t\t   CLK_SET_RATE_PARENT);\n\tret = clk_hw_register(NULL, &ctx->hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void\nclk_multiple_parents_mux_test_exit(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\n\tclk_hw_unregister(&ctx->hw);\n\tclk_hw_unregister(&ctx->parents_ctx[0].hw);\n\tclk_hw_unregister(&ctx->parents_ctx[1].hw);\n}\n\n \nstatic void\nclk_test_multiple_parents_mux_get_parent(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent = clk_hw_get_clk(&ctx->parents_ctx[0].hw, NULL);\n\n\tKUNIT_EXPECT_TRUE(test, clk_is_match(clk_get_parent(clk), parent));\n\n\tclk_put(parent);\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_multiple_parents_mux_has_parent(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent;\n\n\tparent = clk_hw_get_clk(&ctx->parents_ctx[0].hw, NULL);\n\tKUNIT_EXPECT_TRUE(test, clk_has_parent(clk, parent));\n\tclk_put(parent);\n\n\tparent = clk_hw_get_clk(&ctx->parents_ctx[1].hw, NULL);\n\tKUNIT_EXPECT_TRUE(test, clk_has_parent(clk, parent));\n\tclk_put(parent);\n\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_multiple_parents_mux_set_range_set_parent_get_rate(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent1, *parent2;\n\tunsigned long rate;\n\tint ret;\n\n\tkunit_skip(test, \"This needs to be fixed in the core.\");\n\n\tparent1 = clk_hw_get_clk(&ctx->parents_ctx[0].hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, parent1);\n\tKUNIT_ASSERT_TRUE(test, clk_is_match(clk_get_parent(clk), parent1));\n\n\tparent2 = clk_hw_get_clk(&ctx->parents_ctx[1].hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, parent2);\n\n\tret = clk_set_rate(parent1, DUMMY_CLOCK_RATE_1);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tret = clk_set_rate(parent2, DUMMY_CLOCK_RATE_2);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tret = clk_set_rate_range(clk,\n\t\t\t\t DUMMY_CLOCK_RATE_1 - 1000,\n\t\t\t\t DUMMY_CLOCK_RATE_1 + 1000);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tret = clk_set_parent(clk, parent2);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1 - 1000);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_1 + 1000);\n\n\tclk_put(parent2);\n\tclk_put(parent1);\n\tclk_put(clk);\n}\n\nstatic struct kunit_case clk_multiple_parents_mux_test_cases[] = {\n\tKUNIT_CASE(clk_test_multiple_parents_mux_get_parent),\n\tKUNIT_CASE(clk_test_multiple_parents_mux_has_parent),\n\tKUNIT_CASE(clk_test_multiple_parents_mux_set_range_set_parent_get_rate),\n\t{}\n};\n\n \nstatic struct kunit_suite\nclk_multiple_parents_mux_test_suite = {\n\t.name = \"clk-multiple-parents-mux-test\",\n\t.init = clk_multiple_parents_mux_test_init,\n\t.exit = clk_multiple_parents_mux_test_exit,\n\t.test_cases = clk_multiple_parents_mux_test_cases,\n};\n\nstatic int\nclk_orphan_transparent_multiple_parent_mux_test_init(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx;\n\tconst char *parents[2] = { \"missing-parent\", \"proper-parent\"};\n\tint ret;\n\n\tctx = kunit_kzalloc(test, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\ttest->priv = ctx;\n\n\tctx->parents_ctx[1].hw.init = CLK_HW_INIT_NO_PARENT(\"proper-parent\",\n\t\t\t\t\t\t\t    &clk_dummy_rate_ops,\n\t\t\t\t\t\t\t    0);\n\tctx->parents_ctx[1].rate = DUMMY_CLOCK_INIT_RATE;\n\tret = clk_hw_register(NULL, &ctx->parents_ctx[1].hw);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->hw.init = CLK_HW_INIT_PARENTS(\"test-orphan-mux\", parents,\n\t\t\t\t\t   &clk_multiple_parents_mux_ops,\n\t\t\t\t\t   CLK_SET_RATE_PARENT);\n\tret = clk_hw_register(NULL, &ctx->hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void\nclk_orphan_transparent_multiple_parent_mux_test_exit(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\n\tclk_hw_unregister(&ctx->hw);\n\tclk_hw_unregister(&ctx->parents_ctx[1].hw);\n}\n\n \nstatic void\nclk_test_orphan_transparent_multiple_parent_mux_get_parent(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\n\tKUNIT_EXPECT_PTR_EQ(test, clk_get_parent(clk), NULL);\n\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_orphan_transparent_multiple_parent_mux_set_parent(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent, *new_parent;\n\tint ret;\n\n\tparent = clk_hw_get_clk(&ctx->parents_ctx[1].hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, parent);\n\n\tret = clk_set_parent(clk, parent);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tnew_parent = clk_get_parent(clk);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, parent);\n\tKUNIT_EXPECT_TRUE(test, clk_is_match(parent, new_parent));\n\n\tclk_put(parent);\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_orphan_transparent_multiple_parent_mux_set_parent_drop_range(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent;\n\tunsigned long parent_rate, new_parent_rate;\n\tint ret;\n\n\tparent = clk_hw_get_clk(&ctx->parents_ctx[1].hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, parent);\n\n\tparent_rate = clk_get_rate(parent);\n\tKUNIT_ASSERT_GT(test, parent_rate, 0);\n\n\tret = clk_set_parent(clk, parent);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tret = clk_drop_range(clk);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tnew_parent_rate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, new_parent_rate, 0);\n\tKUNIT_EXPECT_EQ(test, parent_rate, new_parent_rate);\n\n\tclk_put(parent);\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_orphan_transparent_multiple_parent_mux_set_parent_get_rate(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent;\n\tunsigned long parent_rate, rate;\n\tint ret;\n\n\tparent = clk_hw_get_clk(&ctx->parents_ctx[1].hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, parent);\n\n\tparent_rate = clk_get_rate(parent);\n\tKUNIT_ASSERT_GT(test, parent_rate, 0);\n\n\tret = clk_set_parent(clk, parent);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, parent_rate, rate);\n\n\tclk_put(parent);\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_orphan_transparent_multiple_parent_mux_set_parent_put(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\tstruct clk *clk, *parent;\n\tunsigned long parent_rate, new_parent_rate;\n\tint ret;\n\n\tparent = clk_hw_get_clk(&ctx->parents_ctx[1].hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, parent);\n\n\tclk = clk_hw_get_clk(&ctx->hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, clk);\n\n\tparent_rate = clk_get_rate(parent);\n\tKUNIT_ASSERT_GT(test, parent_rate, 0);\n\n\tret = clk_set_parent(clk, parent);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tclk_put(clk);\n\n\tnew_parent_rate = clk_get_rate(parent);\n\tKUNIT_ASSERT_GT(test, new_parent_rate, 0);\n\tKUNIT_EXPECT_EQ(test, parent_rate, new_parent_rate);\n\n\tclk_put(parent);\n}\n\n \nstatic void\nclk_test_orphan_transparent_multiple_parent_mux_set_parent_set_range_modified(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent;\n\tunsigned long rate;\n\tint ret;\n\n\tparent = clk_hw_get_clk(&ctx->parents_ctx[1].hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, parent);\n\n\tret = clk_set_parent(clk, parent);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tret = clk_set_rate_range(clk, DUMMY_CLOCK_RATE_1, DUMMY_CLOCK_RATE_2);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(parent);\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_orphan_transparent_multiple_parent_mux_set_parent_set_range_untouched(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent;\n\tunsigned long parent_rate, new_parent_rate;\n\tint ret;\n\n\tparent = clk_hw_get_clk(&ctx->parents_ctx[1].hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, parent);\n\n\tparent_rate = clk_get_rate(parent);\n\tKUNIT_ASSERT_GT(test, parent_rate, 0);\n\n\tret = clk_set_parent(clk, parent);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tret = clk_set_rate_range(clk,\n\t\t\t\t DUMMY_CLOCK_INIT_RATE - 1000,\n\t\t\t\t DUMMY_CLOCK_INIT_RATE + 1000);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tnew_parent_rate = clk_get_rate(parent);\n\tKUNIT_ASSERT_GT(test, new_parent_rate, 0);\n\tKUNIT_EXPECT_EQ(test, parent_rate, new_parent_rate);\n\n\tclk_put(parent);\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_orphan_transparent_multiple_parent_mux_set_range_round_rate(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tlong rate;\n\tint ret;\n\n\tret = clk_set_rate_range(clk, DUMMY_CLOCK_RATE_1, DUMMY_CLOCK_RATE_2);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\trate = clk_round_rate(clk, DUMMY_CLOCK_RATE_1 - 1000);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_orphan_transparent_multiple_parent_mux_set_range_set_parent_get_rate(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent;\n\tunsigned long rate;\n\tint ret;\n\n\tkunit_skip(test, \"This needs to be fixed in the core.\");\n\n\tclk_hw_set_rate_range(hw, DUMMY_CLOCK_RATE_1, DUMMY_CLOCK_RATE_2);\n\n\tparent = clk_hw_get_clk(&ctx->parents_ctx[1].hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, parent);\n\n\tret = clk_set_parent(clk, parent);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(parent);\n\tclk_put(clk);\n}\n\nstatic struct kunit_case clk_orphan_transparent_multiple_parent_mux_test_cases[] = {\n\tKUNIT_CASE(clk_test_orphan_transparent_multiple_parent_mux_get_parent),\n\tKUNIT_CASE(clk_test_orphan_transparent_multiple_parent_mux_set_parent),\n\tKUNIT_CASE(clk_test_orphan_transparent_multiple_parent_mux_set_parent_drop_range),\n\tKUNIT_CASE(clk_test_orphan_transparent_multiple_parent_mux_set_parent_get_rate),\n\tKUNIT_CASE(clk_test_orphan_transparent_multiple_parent_mux_set_parent_put),\n\tKUNIT_CASE(clk_test_orphan_transparent_multiple_parent_mux_set_parent_set_range_modified),\n\tKUNIT_CASE(clk_test_orphan_transparent_multiple_parent_mux_set_parent_set_range_untouched),\n\tKUNIT_CASE(clk_test_orphan_transparent_multiple_parent_mux_set_range_round_rate),\n\tKUNIT_CASE(clk_test_orphan_transparent_multiple_parent_mux_set_range_set_parent_get_rate),\n\t{}\n};\n\n \nstatic struct kunit_suite clk_orphan_transparent_multiple_parent_mux_test_suite = {\n\t.name = \"clk-orphan-transparent-multiple-parent-mux-test\",\n\t.init = clk_orphan_transparent_multiple_parent_mux_test_init,\n\t.exit = clk_orphan_transparent_multiple_parent_mux_test_exit,\n\t.test_cases = clk_orphan_transparent_multiple_parent_mux_test_cases,\n};\n\nstruct clk_single_parent_ctx {\n\tstruct clk_dummy_context parent_ctx;\n\tstruct clk_hw hw;\n};\n\nstatic int clk_single_parent_mux_test_init(struct kunit *test)\n{\n\tstruct clk_single_parent_ctx *ctx;\n\tint ret;\n\n\tctx = kunit_kzalloc(test, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\ttest->priv = ctx;\n\n\tctx->parent_ctx.rate = DUMMY_CLOCK_INIT_RATE;\n\tctx->parent_ctx.hw.init =\n\t\tCLK_HW_INIT_NO_PARENT(\"parent-clk\",\n\t\t\t\t      &clk_dummy_rate_ops,\n\t\t\t\t      0);\n\n\tret = clk_hw_register(NULL, &ctx->parent_ctx.hw);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->hw.init = CLK_HW_INIT(\"test-clk\", \"parent-clk\",\n\t\t\t\t   &clk_dummy_single_parent_ops,\n\t\t\t\t   CLK_SET_RATE_PARENT);\n\n\tret = clk_hw_register(NULL, &ctx->hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void\nclk_single_parent_mux_test_exit(struct kunit *test)\n{\n\tstruct clk_single_parent_ctx *ctx = test->priv;\n\n\tclk_hw_unregister(&ctx->hw);\n\tclk_hw_unregister(&ctx->parent_ctx.hw);\n}\n\n \nstatic void\nclk_test_single_parent_mux_get_parent(struct kunit *test)\n{\n\tstruct clk_single_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent = clk_hw_get_clk(&ctx->parent_ctx.hw, NULL);\n\n\tKUNIT_EXPECT_TRUE(test, clk_is_match(clk_get_parent(clk), parent));\n\n\tclk_put(parent);\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_single_parent_mux_has_parent(struct kunit *test)\n{\n\tstruct clk_single_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent = clk_hw_get_clk(&ctx->parent_ctx.hw, NULL);\n\n\tKUNIT_EXPECT_TRUE(test, clk_has_parent(clk, parent));\n\n\tclk_put(parent);\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_single_parent_mux_set_range_disjoint_child_last(struct kunit *test)\n{\n\tstruct clk_single_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent;\n\tint ret;\n\n\tkunit_skip(test, \"This needs to be fixed in the core.\");\n\n\tparent = clk_get_parent(clk);\n\tKUNIT_ASSERT_PTR_NE(test, parent, NULL);\n\n\tret = clk_set_rate_range(parent, 1000, 2000);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tret = clk_set_rate_range(clk, 3000, 4000);\n\tKUNIT_EXPECT_LT(test, ret, 0);\n\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_single_parent_mux_set_range_disjoint_parent_last(struct kunit *test)\n{\n\tstruct clk_single_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent;\n\tint ret;\n\n\tkunit_skip(test, \"This needs to be fixed in the core.\");\n\n\tparent = clk_get_parent(clk);\n\tKUNIT_ASSERT_PTR_NE(test, parent, NULL);\n\n\tret = clk_set_rate_range(clk, 1000, 2000);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tret = clk_set_rate_range(parent, 3000, 4000);\n\tKUNIT_EXPECT_LT(test, ret, 0);\n\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_single_parent_mux_set_range_round_rate_parent_only(struct kunit *test)\n{\n\tstruct clk_single_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent;\n\tlong rate;\n\tint ret;\n\n\tparent = clk_get_parent(clk);\n\tKUNIT_ASSERT_PTR_NE(test, parent, NULL);\n\n\tret = clk_set_rate_range(parent, DUMMY_CLOCK_RATE_1, DUMMY_CLOCK_RATE_2);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\trate = clk_round_rate(clk, DUMMY_CLOCK_RATE_1 - 1000);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_single_parent_mux_set_range_round_rate_child_smaller(struct kunit *test)\n{\n\tstruct clk_single_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent;\n\tlong rate;\n\tint ret;\n\n\tparent = clk_get_parent(clk);\n\tKUNIT_ASSERT_PTR_NE(test, parent, NULL);\n\n\tret = clk_set_rate_range(parent, DUMMY_CLOCK_RATE_1, DUMMY_CLOCK_RATE_2);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tret = clk_set_rate_range(clk, DUMMY_CLOCK_RATE_1 + 1000, DUMMY_CLOCK_RATE_2 - 1000);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\trate = clk_round_rate(clk, DUMMY_CLOCK_RATE_1 - 1000);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1 + 1000);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_2 - 1000);\n\n\trate = clk_round_rate(clk, DUMMY_CLOCK_RATE_2 + 1000);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1 + 1000);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_2 - 1000);\n\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_test_single_parent_mux_set_range_round_rate_parent_smaller(struct kunit *test)\n{\n\tstruct clk_single_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *parent;\n\tlong rate;\n\tint ret;\n\n\tparent = clk_get_parent(clk);\n\tKUNIT_ASSERT_PTR_NE(test, parent, NULL);\n\n\tret = clk_set_rate_range(parent, DUMMY_CLOCK_RATE_1 + 1000, DUMMY_CLOCK_RATE_2 - 1000);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tret = clk_set_rate_range(clk, DUMMY_CLOCK_RATE_1, DUMMY_CLOCK_RATE_2);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\trate = clk_round_rate(clk, DUMMY_CLOCK_RATE_1 - 1000);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1 + 1000);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_2 - 1000);\n\n\trate = clk_round_rate(clk, DUMMY_CLOCK_RATE_2 + 1000);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1 + 1000);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_2 - 1000);\n\n\tclk_put(clk);\n}\n\nstatic struct kunit_case clk_single_parent_mux_test_cases[] = {\n\tKUNIT_CASE(clk_test_single_parent_mux_get_parent),\n\tKUNIT_CASE(clk_test_single_parent_mux_has_parent),\n\tKUNIT_CASE(clk_test_single_parent_mux_set_range_disjoint_child_last),\n\tKUNIT_CASE(clk_test_single_parent_mux_set_range_disjoint_parent_last),\n\tKUNIT_CASE(clk_test_single_parent_mux_set_range_round_rate_child_smaller),\n\tKUNIT_CASE(clk_test_single_parent_mux_set_range_round_rate_parent_only),\n\tKUNIT_CASE(clk_test_single_parent_mux_set_range_round_rate_parent_smaller),\n\t{}\n};\n\n \nstatic struct kunit_suite\nclk_single_parent_mux_test_suite = {\n\t.name = \"clk-single-parent-mux-test\",\n\t.init = clk_single_parent_mux_test_init,\n\t.exit = clk_single_parent_mux_test_exit,\n\t.test_cases = clk_single_parent_mux_test_cases,\n};\n\nstatic int clk_orphan_transparent_single_parent_mux_test_init(struct kunit *test)\n{\n\tstruct clk_single_parent_ctx *ctx;\n\tstruct clk_init_data init = { };\n\tconst char * const parents[] = { \"orphan_parent\" };\n\tint ret;\n\n\tctx = kunit_kzalloc(test, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\ttest->priv = ctx;\n\n\tinit.name = \"test_orphan_dummy_parent\";\n\tinit.ops = &clk_dummy_single_parent_ops;\n\tinit.parent_names = parents;\n\tinit.num_parents = ARRAY_SIZE(parents);\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tctx->hw.init = &init;\n\n\tret = clk_hw_register(NULL, &ctx->hw);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&init, 0, sizeof(init));\n\tinit.name = \"orphan_parent\";\n\tinit.ops = &clk_dummy_rate_ops;\n\tctx->parent_ctx.hw.init = &init;\n\tctx->parent_ctx.rate = DUMMY_CLOCK_INIT_RATE;\n\n\tret = clk_hw_register(NULL, &ctx->parent_ctx.hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic void clk_test_orphan_transparent_parent_mux_set_range(struct kunit *test)\n{\n\tstruct clk_single_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate, new_rate;\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   ctx->parent_ctx.rate - 1000,\n\t\t\t\t\t   ctx->parent_ctx.rate + 1000),\n\t\t\t0);\n\n\tnew_rate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, new_rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, new_rate);\n\n\tclk_put(clk);\n}\n\nstatic struct kunit_case clk_orphan_transparent_single_parent_mux_test_cases[] = {\n\tKUNIT_CASE(clk_test_orphan_transparent_parent_mux_set_range),\n\t{}\n};\n\n \nstatic struct kunit_suite clk_orphan_transparent_single_parent_test_suite = {\n\t.name = \"clk-orphan-transparent-single-parent-test\",\n\t.init = clk_orphan_transparent_single_parent_mux_test_init,\n\t.exit = clk_single_parent_mux_test_exit,\n\t.test_cases = clk_orphan_transparent_single_parent_mux_test_cases,\n};\n\nstruct clk_single_parent_two_lvl_ctx {\n\tstruct clk_dummy_context parent_parent_ctx;\n\tstruct clk_dummy_context parent_ctx;\n\tstruct clk_hw hw;\n};\n\nstatic int\nclk_orphan_two_level_root_last_test_init(struct kunit *test)\n{\n\tstruct clk_single_parent_two_lvl_ctx *ctx;\n\tint ret;\n\n\tctx = kunit_kzalloc(test, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\ttest->priv = ctx;\n\n\tctx->parent_ctx.hw.init =\n\t\tCLK_HW_INIT(\"intermediate-parent\",\n\t\t\t    \"root-parent\",\n\t\t\t    &clk_dummy_single_parent_ops,\n\t\t\t    CLK_SET_RATE_PARENT);\n\tret = clk_hw_register(NULL, &ctx->parent_ctx.hw);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->hw.init =\n\t\tCLK_HW_INIT(\"test-clk\", \"intermediate-parent\",\n\t\t\t    &clk_dummy_single_parent_ops,\n\t\t\t    CLK_SET_RATE_PARENT);\n\tret = clk_hw_register(NULL, &ctx->hw);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->parent_parent_ctx.rate = DUMMY_CLOCK_INIT_RATE;\n\tctx->parent_parent_ctx.hw.init =\n\t\tCLK_HW_INIT_NO_PARENT(\"root-parent\",\n\t\t\t\t      &clk_dummy_rate_ops,\n\t\t\t\t      0);\n\tret = clk_hw_register(NULL, &ctx->parent_parent_ctx.hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void\nclk_orphan_two_level_root_last_test_exit(struct kunit *test)\n{\n\tstruct clk_single_parent_two_lvl_ctx *ctx = test->priv;\n\n\tclk_hw_unregister(&ctx->hw);\n\tclk_hw_unregister(&ctx->parent_ctx.hw);\n\tclk_hw_unregister(&ctx->parent_parent_ctx.hw);\n}\n\n \nstatic void\nclk_orphan_two_level_root_last_test_get_rate(struct kunit *test)\n{\n\tstruct clk_single_parent_two_lvl_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\n\trate = clk_get_rate(clk);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_INIT_RATE);\n\n\tclk_put(clk);\n}\n\n \nstatic void\nclk_orphan_two_level_root_last_test_set_range(struct kunit *test)\n{\n\tstruct clk_single_parent_two_lvl_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\tint ret;\n\n\tret = clk_set_rate_range(clk,\n\t\t\t\t DUMMY_CLOCK_INIT_RATE - 1000,\n\t\t\t\t DUMMY_CLOCK_INIT_RATE + 1000);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_INIT_RATE);\n\n\tclk_put(clk);\n}\n\nstatic struct kunit_case\nclk_orphan_two_level_root_last_test_cases[] = {\n\tKUNIT_CASE(clk_orphan_two_level_root_last_test_get_rate),\n\tKUNIT_CASE(clk_orphan_two_level_root_last_test_set_range),\n\t{}\n};\n\n \nstatic struct kunit_suite\nclk_orphan_two_level_root_last_test_suite = {\n\t.name = \"clk-orphan-two-level-root-last-test\",\n\t.init = clk_orphan_two_level_root_last_test_init,\n\t.exit = clk_orphan_two_level_root_last_test_exit,\n\t.test_cases = clk_orphan_two_level_root_last_test_cases,\n};\n\n \nstatic void clk_range_test_set_range(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_range_test_set_range_invalid(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\n\tKUNIT_EXPECT_LT(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1 + 1000,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1),\n\t\t\t0);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_range_test_multiple_disjoints_range(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *user1, *user2;\n\n\tuser1 = clk_hw_get_clk(hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, user1);\n\n\tuser2 = clk_hw_get_clk(hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, user2);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(user1, 1000, 2000),\n\t\t\t0);\n\n\tKUNIT_EXPECT_LT(test,\n\t\t\tclk_set_rate_range(user2, 3000, 4000),\n\t\t\t0);\n\n\tclk_put(user2);\n\tclk_put(user1);\n}\n\n \nstatic void clk_range_test_set_range_round_rate_lower(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tlong rate;\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_round_rate(clk, DUMMY_CLOCK_RATE_1 - 1000);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_range_test_set_range_set_rate_lower(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate(clk, DUMMY_CLOCK_RATE_1 - 1000),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_range_test_set_range_set_round_rate_consistent_lower(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tlong rounded;\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trounded = clk_round_rate(clk, DUMMY_CLOCK_RATE_1 - 1000);\n\tKUNIT_ASSERT_GT(test, rounded, 0);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate(clk, DUMMY_CLOCK_RATE_1 - 1000),\n\t\t\t0);\n\n\tKUNIT_EXPECT_EQ(test, rounded, clk_get_rate(clk));\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_range_test_set_range_round_rate_higher(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tlong rate;\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_round_rate(clk, DUMMY_CLOCK_RATE_2 + 1000);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_range_test_set_range_set_rate_higher(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate(clk, DUMMY_CLOCK_RATE_2 + 1000),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_GE(test, rate, DUMMY_CLOCK_RATE_1);\n\tKUNIT_EXPECT_LE(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_range_test_set_range_set_round_rate_consistent_higher(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tlong rounded;\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trounded = clk_round_rate(clk, DUMMY_CLOCK_RATE_2 + 1000);\n\tKUNIT_ASSERT_GT(test, rounded, 0);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate(clk, DUMMY_CLOCK_RATE_2 + 1000),\n\t\t\t0);\n\n\tKUNIT_EXPECT_EQ(test, rounded, clk_get_rate(clk));\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_range_test_set_range_get_rate_raised(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate(clk, DUMMY_CLOCK_RATE_1 - 1000),\n\t\t\t0);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_1);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_range_test_set_range_get_rate_lowered(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate(clk, DUMMY_CLOCK_RATE_2 + 1000),\n\t\t\t0);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(clk);\n}\n\nstatic struct kunit_case clk_range_test_cases[] = {\n\tKUNIT_CASE(clk_range_test_set_range),\n\tKUNIT_CASE(clk_range_test_set_range_invalid),\n\tKUNIT_CASE(clk_range_test_multiple_disjoints_range),\n\tKUNIT_CASE(clk_range_test_set_range_round_rate_lower),\n\tKUNIT_CASE(clk_range_test_set_range_set_rate_lower),\n\tKUNIT_CASE(clk_range_test_set_range_set_round_rate_consistent_lower),\n\tKUNIT_CASE(clk_range_test_set_range_round_rate_higher),\n\tKUNIT_CASE(clk_range_test_set_range_set_rate_higher),\n\tKUNIT_CASE(clk_range_test_set_range_set_round_rate_consistent_higher),\n\tKUNIT_CASE(clk_range_test_set_range_get_rate_raised),\n\tKUNIT_CASE(clk_range_test_set_range_get_rate_lowered),\n\t{}\n};\n\n \nstatic struct kunit_suite clk_range_test_suite = {\n\t.name = \"clk-range-test\",\n\t.init = clk_test_init,\n\t.exit = clk_test_exit,\n\t.test_cases = clk_range_test_cases,\n};\n\n \nstatic void clk_range_test_set_range_rate_maximized(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate(clk, DUMMY_CLOCK_RATE_2 + 1000),\n\t\t\t0);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2 - 1000),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_2 - 1000);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_range_test_multiple_set_range_rate_maximized(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *user1, *user2;\n\tunsigned long rate;\n\n\tuser1 = clk_hw_get_clk(hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, user1);\n\n\tuser2 = clk_hw_get_clk(hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, user2);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate(clk, DUMMY_CLOCK_RATE_2 + 1000),\n\t\t\t0);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(user1,\n\t\t\t\t\t   0,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(user2,\n\t\t\t\t\t   0,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_1);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_drop_range(user2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(user2);\n\tclk_put(user1);\n\tclk_put(clk);\n}\n\n \nstatic void clk_range_test_multiple_set_range_rate_put_maximized(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *user1, *user2;\n\tunsigned long rate;\n\n\tuser1 = clk_hw_get_clk(hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, user1);\n\n\tuser2 = clk_hw_get_clk(hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, user2);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate(clk, DUMMY_CLOCK_RATE_2 + 1000),\n\t\t\t0);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(user1,\n\t\t\t\t\t   0,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(user2,\n\t\t\t\t\t   0,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_1);\n\n\tclk_put(user2);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(user1);\n\tclk_put(clk);\n}\n\nstatic struct kunit_case clk_range_maximize_test_cases[] = {\n\tKUNIT_CASE(clk_range_test_set_range_rate_maximized),\n\tKUNIT_CASE(clk_range_test_multiple_set_range_rate_maximized),\n\tKUNIT_CASE(clk_range_test_multiple_set_range_rate_put_maximized),\n\t{}\n};\n\n \nstatic struct kunit_suite clk_range_maximize_test_suite = {\n\t.name = \"clk-range-maximize-test\",\n\t.init = clk_maximize_test_init,\n\t.exit = clk_test_exit,\n\t.test_cases = clk_range_maximize_test_cases,\n};\n\n \nstatic void clk_range_test_set_range_rate_minimized(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tunsigned long rate;\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate(clk, DUMMY_CLOCK_RATE_1 - 1000),\n\t\t\t0);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_1);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1 + 1000,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_1 + 1000);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(clk,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_1);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_range_test_multiple_set_range_rate_minimized(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *user1, *user2;\n\tunsigned long rate;\n\n\tuser1 = clk_hw_get_clk(hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, user1);\n\n\tuser2 = clk_hw_get_clk(hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, user2);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(user1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   ULONG_MAX),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_1);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(user2,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2,\n\t\t\t\t\t   ULONG_MAX),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_drop_range(user2),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_1);\n\n\tclk_put(user2);\n\tclk_put(user1);\n\tclk_put(clk);\n}\n\n \nstatic void clk_range_test_multiple_set_range_rate_put_minimized(struct kunit *test)\n{\n\tstruct clk_dummy_context *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *user1, *user2;\n\tunsigned long rate;\n\n\tuser1 = clk_hw_get_clk(hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, user1);\n\n\tuser2 = clk_hw_get_clk(hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, user2);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(user1,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_1,\n\t\t\t\t\t   ULONG_MAX),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_1);\n\n\tKUNIT_ASSERT_EQ(test,\n\t\t\tclk_set_rate_range(user2,\n\t\t\t\t\t   DUMMY_CLOCK_RATE_2,\n\t\t\t\t\t   ULONG_MAX),\n\t\t\t0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(user2);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, DUMMY_CLOCK_RATE_1);\n\n\tclk_put(user1);\n\tclk_put(clk);\n}\n\nstatic struct kunit_case clk_range_minimize_test_cases[] = {\n\tKUNIT_CASE(clk_range_test_set_range_rate_minimized),\n\tKUNIT_CASE(clk_range_test_multiple_set_range_rate_minimized),\n\tKUNIT_CASE(clk_range_test_multiple_set_range_rate_put_minimized),\n\t{}\n};\n\n \nstatic struct kunit_suite clk_range_minimize_test_suite = {\n\t.name = \"clk-range-minimize-test\",\n\t.init = clk_minimize_test_init,\n\t.exit = clk_test_exit,\n\t.test_cases = clk_range_minimize_test_cases,\n};\n\nstruct clk_leaf_mux_ctx {\n\tstruct clk_multiple_parent_ctx mux_ctx;\n\tstruct clk_hw hw;\n};\n\nstatic int\nclk_leaf_mux_set_rate_parent_test_init(struct kunit *test)\n{\n\tstruct clk_leaf_mux_ctx *ctx;\n\tconst char *top_parents[2] = { \"parent-0\", \"parent-1\" };\n\tint ret;\n\n\tctx = kunit_kzalloc(test, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\ttest->priv = ctx;\n\n\tctx->mux_ctx.parents_ctx[0].hw.init = CLK_HW_INIT_NO_PARENT(\"parent-0\",\n\t\t\t\t\t\t\t\t    &clk_dummy_rate_ops,\n\t\t\t\t\t\t\t\t    0);\n\tctx->mux_ctx.parents_ctx[0].rate = DUMMY_CLOCK_RATE_1;\n\tret = clk_hw_register(NULL, &ctx->mux_ctx.parents_ctx[0].hw);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->mux_ctx.parents_ctx[1].hw.init = CLK_HW_INIT_NO_PARENT(\"parent-1\",\n\t\t\t\t\t\t\t\t    &clk_dummy_rate_ops,\n\t\t\t\t\t\t\t\t    0);\n\tctx->mux_ctx.parents_ctx[1].rate = DUMMY_CLOCK_RATE_2;\n\tret = clk_hw_register(NULL, &ctx->mux_ctx.parents_ctx[1].hw);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->mux_ctx.current_parent = 0;\n\tctx->mux_ctx.hw.init = CLK_HW_INIT_PARENTS(\"test-mux\", top_parents,\n\t\t\t\t\t\t   &clk_multiple_parents_mux_ops,\n\t\t\t\t\t\t   0);\n\tret = clk_hw_register(NULL, &ctx->mux_ctx.hw);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->hw.init = CLK_HW_INIT_HW(\"test-clock\", &ctx->mux_ctx.hw,\n\t\t\t\t      &clk_dummy_single_parent_ops,\n\t\t\t\t      CLK_SET_RATE_PARENT);\n\tret = clk_hw_register(NULL, &ctx->hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void clk_leaf_mux_set_rate_parent_test_exit(struct kunit *test)\n{\n\tstruct clk_leaf_mux_ctx *ctx = test->priv;\n\n\tclk_hw_unregister(&ctx->hw);\n\tclk_hw_unregister(&ctx->mux_ctx.hw);\n\tclk_hw_unregister(&ctx->mux_ctx.parents_ctx[0].hw);\n\tclk_hw_unregister(&ctx->mux_ctx.parents_ctx[1].hw);\n}\n\n \nstatic void clk_leaf_mux_set_rate_parent_determine_rate(struct kunit *test)\n{\n\tstruct clk_leaf_mux_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk_rate_request req;\n\tunsigned long rate;\n\tint ret;\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_EQ(test, rate, DUMMY_CLOCK_RATE_1);\n\n\tclk_hw_init_rate_request(hw, &req, DUMMY_CLOCK_RATE_2);\n\n\tret = __clk_determine_rate(hw, &req);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tKUNIT_EXPECT_EQ(test, req.rate, DUMMY_CLOCK_RATE_2);\n\tKUNIT_EXPECT_EQ(test, req.best_parent_rate, DUMMY_CLOCK_RATE_2);\n\tKUNIT_EXPECT_PTR_EQ(test, req.best_parent_hw, &ctx->mux_ctx.hw);\n\n\tclk_put(clk);\n}\n\nstatic struct kunit_case clk_leaf_mux_set_rate_parent_test_cases[] = {\n\tKUNIT_CASE(clk_leaf_mux_set_rate_parent_determine_rate),\n\t{}\n};\n\n \nstatic struct kunit_suite clk_leaf_mux_set_rate_parent_test_suite = {\n\t.name = \"clk-leaf-mux-set-rate-parent\",\n\t.init = clk_leaf_mux_set_rate_parent_test_init,\n\t.exit = clk_leaf_mux_set_rate_parent_test_exit,\n\t.test_cases = clk_leaf_mux_set_rate_parent_test_cases,\n};\n\nstruct clk_mux_notifier_rate_change {\n\tbool done;\n\tunsigned long old_rate;\n\tunsigned long new_rate;\n\twait_queue_head_t wq;\n};\n\nstruct clk_mux_notifier_ctx {\n\tstruct clk_multiple_parent_ctx mux_ctx;\n\tstruct clk *clk;\n\tstruct notifier_block clk_nb;\n\tstruct clk_mux_notifier_rate_change pre_rate_change;\n\tstruct clk_mux_notifier_rate_change post_rate_change;\n};\n\n#define NOTIFIER_TIMEOUT_MS 100\n\nstatic int clk_mux_notifier_callback(struct notifier_block *nb,\n\t\t\t\t     unsigned long action, void *data)\n{\n\tstruct clk_notifier_data *clk_data = data;\n\tstruct clk_mux_notifier_ctx *ctx = container_of(nb,\n\t\t\t\t\t\t\tstruct clk_mux_notifier_ctx,\n\t\t\t\t\t\t\tclk_nb);\n\n\tif (action & PRE_RATE_CHANGE) {\n\t\tctx->pre_rate_change.old_rate = clk_data->old_rate;\n\t\tctx->pre_rate_change.new_rate = clk_data->new_rate;\n\t\tctx->pre_rate_change.done = true;\n\t\twake_up_interruptible(&ctx->pre_rate_change.wq);\n\t}\n\n\tif (action & POST_RATE_CHANGE) {\n\t\tctx->post_rate_change.old_rate = clk_data->old_rate;\n\t\tctx->post_rate_change.new_rate = clk_data->new_rate;\n\t\tctx->post_rate_change.done = true;\n\t\twake_up_interruptible(&ctx->post_rate_change.wq);\n\t}\n\n\treturn 0;\n}\n\nstatic int clk_mux_notifier_test_init(struct kunit *test)\n{\n\tstruct clk_mux_notifier_ctx *ctx;\n\tconst char *top_parents[2] = { \"parent-0\", \"parent-1\" };\n\tint ret;\n\n\tctx = kunit_kzalloc(test, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\ttest->priv = ctx;\n\tctx->clk_nb.notifier_call = clk_mux_notifier_callback;\n\tinit_waitqueue_head(&ctx->pre_rate_change.wq);\n\tinit_waitqueue_head(&ctx->post_rate_change.wq);\n\n\tctx->mux_ctx.parents_ctx[0].hw.init = CLK_HW_INIT_NO_PARENT(\"parent-0\",\n\t\t\t\t\t\t\t\t    &clk_dummy_rate_ops,\n\t\t\t\t\t\t\t\t    0);\n\tctx->mux_ctx.parents_ctx[0].rate = DUMMY_CLOCK_RATE_1;\n\tret = clk_hw_register(NULL, &ctx->mux_ctx.parents_ctx[0].hw);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->mux_ctx.parents_ctx[1].hw.init = CLK_HW_INIT_NO_PARENT(\"parent-1\",\n\t\t\t\t\t\t\t\t    &clk_dummy_rate_ops,\n\t\t\t\t\t\t\t\t    0);\n\tctx->mux_ctx.parents_ctx[1].rate = DUMMY_CLOCK_RATE_2;\n\tret = clk_hw_register(NULL, &ctx->mux_ctx.parents_ctx[1].hw);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->mux_ctx.current_parent = 0;\n\tctx->mux_ctx.hw.init = CLK_HW_INIT_PARENTS(\"test-mux\", top_parents,\n\t\t\t\t\t\t   &clk_multiple_parents_mux_ops,\n\t\t\t\t\t\t   0);\n\tret = clk_hw_register(NULL, &ctx->mux_ctx.hw);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->clk = clk_hw_get_clk(&ctx->mux_ctx.hw, NULL);\n\tret = clk_notifier_register(ctx->clk, &ctx->clk_nb);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void clk_mux_notifier_test_exit(struct kunit *test)\n{\n\tstruct clk_mux_notifier_ctx *ctx = test->priv;\n\tstruct clk *clk = ctx->clk;\n\n\tclk_notifier_unregister(clk, &ctx->clk_nb);\n\tclk_put(clk);\n\n\tclk_hw_unregister(&ctx->mux_ctx.hw);\n\tclk_hw_unregister(&ctx->mux_ctx.parents_ctx[0].hw);\n\tclk_hw_unregister(&ctx->mux_ctx.parents_ctx[1].hw);\n}\n\n \nstatic void clk_mux_notifier_set_parent_test(struct kunit *test)\n{\n\tstruct clk_mux_notifier_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->mux_ctx.hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *new_parent = clk_hw_get_clk(&ctx->mux_ctx.parents_ctx[1].hw, NULL);\n\tint ret;\n\n\tret = clk_set_parent(clk, new_parent);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\tret = wait_event_interruptible_timeout(ctx->pre_rate_change.wq,\n\t\t\t\t\t       ctx->pre_rate_change.done,\n\t\t\t\t\t       msecs_to_jiffies(NOTIFIER_TIMEOUT_MS));\n\tKUNIT_ASSERT_GT(test, ret, 0);\n\n\tKUNIT_EXPECT_EQ(test, ctx->pre_rate_change.old_rate, DUMMY_CLOCK_RATE_1);\n\tKUNIT_EXPECT_EQ(test, ctx->pre_rate_change.new_rate, DUMMY_CLOCK_RATE_2);\n\n\tret = wait_event_interruptible_timeout(ctx->post_rate_change.wq,\n\t\t\t\t\t       ctx->post_rate_change.done,\n\t\t\t\t\t       msecs_to_jiffies(NOTIFIER_TIMEOUT_MS));\n\tKUNIT_ASSERT_GT(test, ret, 0);\n\n\tKUNIT_EXPECT_EQ(test, ctx->post_rate_change.old_rate, DUMMY_CLOCK_RATE_1);\n\tKUNIT_EXPECT_EQ(test, ctx->post_rate_change.new_rate, DUMMY_CLOCK_RATE_2);\n\n\tclk_put(new_parent);\n\tclk_put(clk);\n}\n\nstatic struct kunit_case clk_mux_notifier_test_cases[] = {\n\tKUNIT_CASE(clk_mux_notifier_set_parent_test),\n\t{}\n};\n\n \nstatic struct kunit_suite clk_mux_notifier_test_suite = {\n\t.name = \"clk-mux-notifier\",\n\t.init = clk_mux_notifier_test_init,\n\t.exit = clk_mux_notifier_test_exit,\n\t.test_cases = clk_mux_notifier_test_cases,\n};\n\nstatic int\nclk_mux_no_reparent_test_init(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx;\n\tconst char *parents[2] = { \"parent-0\", \"parent-1\"};\n\tint ret;\n\n\tctx = kunit_kzalloc(test, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\ttest->priv = ctx;\n\n\tctx->parents_ctx[0].hw.init = CLK_HW_INIT_NO_PARENT(\"parent-0\",\n\t\t\t\t\t\t\t    &clk_dummy_rate_ops,\n\t\t\t\t\t\t\t    0);\n\tctx->parents_ctx[0].rate = DUMMY_CLOCK_RATE_1;\n\tret = clk_hw_register(NULL, &ctx->parents_ctx[0].hw);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->parents_ctx[1].hw.init = CLK_HW_INIT_NO_PARENT(\"parent-1\",\n\t\t\t\t\t\t\t    &clk_dummy_rate_ops,\n\t\t\t\t\t\t\t    0);\n\tctx->parents_ctx[1].rate = DUMMY_CLOCK_RATE_2;\n\tret = clk_hw_register(NULL, &ctx->parents_ctx[1].hw);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->current_parent = 0;\n\tctx->hw.init = CLK_HW_INIT_PARENTS(\"test-mux\", parents,\n\t\t\t\t\t   &clk_multiple_parents_no_reparent_mux_ops,\n\t\t\t\t\t   0);\n\tret = clk_hw_register(NULL, &ctx->hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void\nclk_mux_no_reparent_test_exit(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\n\tclk_hw_unregister(&ctx->hw);\n\tclk_hw_unregister(&ctx->parents_ctx[0].hw);\n\tclk_hw_unregister(&ctx->parents_ctx[1].hw);\n}\n\n \nstatic void clk_mux_no_reparent_round_rate(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *other_parent, *parent;\n\tunsigned long other_parent_rate;\n\tunsigned long parent_rate;\n\tlong rounded_rate;\n\n\tparent = clk_get_parent(clk);\n\tKUNIT_ASSERT_PTR_NE(test, parent, NULL);\n\n\tparent_rate = clk_get_rate(parent);\n\tKUNIT_ASSERT_GT(test, parent_rate, 0);\n\n\tother_parent = clk_hw_get_clk(&ctx->parents_ctx[1].hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, other_parent);\n\tKUNIT_ASSERT_FALSE(test, clk_is_match(parent, other_parent));\n\n\tother_parent_rate = clk_get_rate(other_parent);\n\tKUNIT_ASSERT_GT(test, other_parent_rate, 0);\n\tclk_put(other_parent);\n\n\trounded_rate = clk_round_rate(clk, other_parent_rate);\n\tKUNIT_ASSERT_GT(test, rounded_rate, 0);\n\tKUNIT_EXPECT_EQ(test, rounded_rate, parent_rate);\n\n\tclk_put(clk);\n}\n\n \nstatic void clk_mux_no_reparent_set_rate(struct kunit *test)\n{\n\tstruct clk_multiple_parent_ctx *ctx = test->priv;\n\tstruct clk_hw *hw = &ctx->hw;\n\tstruct clk *clk = clk_hw_get_clk(hw, NULL);\n\tstruct clk *other_parent, *parent;\n\tunsigned long other_parent_rate;\n\tunsigned long parent_rate;\n\tunsigned long rate;\n\tint ret;\n\n\tparent = clk_get_parent(clk);\n\tKUNIT_ASSERT_PTR_NE(test, parent, NULL);\n\n\tparent_rate = clk_get_rate(parent);\n\tKUNIT_ASSERT_GT(test, parent_rate, 0);\n\n\tother_parent = clk_hw_get_clk(&ctx->parents_ctx[1].hw, NULL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, other_parent);\n\tKUNIT_ASSERT_FALSE(test, clk_is_match(parent, other_parent));\n\n\tother_parent_rate = clk_get_rate(other_parent);\n\tKUNIT_ASSERT_GT(test, other_parent_rate, 0);\n\tclk_put(other_parent);\n\n\tret = clk_set_rate(clk, other_parent_rate);\n\tKUNIT_ASSERT_EQ(test, ret, 0);\n\n\trate = clk_get_rate(clk);\n\tKUNIT_ASSERT_GT(test, rate, 0);\n\tKUNIT_EXPECT_EQ(test, rate, parent_rate);\n\n\tclk_put(clk);\n}\n\nstatic struct kunit_case clk_mux_no_reparent_test_cases[] = {\n\tKUNIT_CASE(clk_mux_no_reparent_round_rate),\n\tKUNIT_CASE(clk_mux_no_reparent_set_rate),\n\t{}\n};\n\n \nstatic struct kunit_suite clk_mux_no_reparent_test_suite = {\n\t.name = \"clk-mux-no-reparent\",\n\t.init = clk_mux_no_reparent_test_init,\n\t.exit = clk_mux_no_reparent_test_exit,\n\t.test_cases = clk_mux_no_reparent_test_cases,\n};\n\nkunit_test_suites(\n\t&clk_leaf_mux_set_rate_parent_test_suite,\n\t&clk_test_suite,\n\t&clk_multiple_parents_mux_test_suite,\n\t&clk_mux_no_reparent_test_suite,\n\t&clk_mux_notifier_test_suite,\n\t&clk_orphan_transparent_multiple_parent_mux_test_suite,\n\t&clk_orphan_transparent_single_parent_test_suite,\n\t&clk_orphan_two_level_root_last_test_suite,\n\t&clk_range_test_suite,\n\t&clk_range_maximize_test_suite,\n\t&clk_range_minimize_test_suite,\n\t&clk_single_parent_mux_test_suite,\n\t&clk_uncached_test_suite\n);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}