{
  "module_name": "cgu.c",
  "hash_id": "083ba0ca978d65f24e46151c9b449d436e660d37fb4adb4a184407aa1a11f329",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ingenic/cgu.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/math64.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/time.h>\n\n#include \"cgu.h\"\n\n#define MHZ (1000 * 1000)\n\nstatic inline const struct ingenic_cgu_clk_info *\nto_clk_info(struct ingenic_clk *clk)\n{\n\treturn &clk->cgu->clock_info[clk->idx];\n}\n\n \nstatic inline bool\ningenic_cgu_gate_get(struct ingenic_cgu *cgu,\n\t\t     const struct ingenic_cgu_gate_info *info)\n{\n\treturn !!(readl(cgu->base + info->reg) & BIT(info->bit))\n\t\t^ info->clear_to_gate;\n}\n\n \nstatic inline void\ningenic_cgu_gate_set(struct ingenic_cgu *cgu,\n\t\t     const struct ingenic_cgu_gate_info *info, bool val)\n{\n\tu32 clkgr = readl(cgu->base + info->reg);\n\n\tif (val ^ info->clear_to_gate)\n\t\tclkgr |= BIT(info->bit);\n\telse\n\t\tclkgr &= ~BIT(info->bit);\n\n\twritel(clkgr, cgu->base + info->reg);\n}\n\n \n\nstatic unsigned long\ningenic_pll_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\n\tconst struct ingenic_cgu_clk_info *clk_info = to_clk_info(ingenic_clk);\n\tstruct ingenic_cgu *cgu = ingenic_clk->cgu;\n\tconst struct ingenic_cgu_pll_info *pll_info;\n\tunsigned m, n, od, od_enc = 0;\n\tbool bypass;\n\tu32 ctl;\n\n\tBUG_ON(clk_info->type != CGU_CLK_PLL);\n\tpll_info = &clk_info->pll;\n\n\tctl = readl(cgu->base + pll_info->reg);\n\n\tm = (ctl >> pll_info->m_shift) & GENMASK(pll_info->m_bits - 1, 0);\n\tm += pll_info->m_offset;\n\tn = (ctl >> pll_info->n_shift) & GENMASK(pll_info->n_bits - 1, 0);\n\tn += pll_info->n_offset;\n\n\tif (pll_info->od_bits > 0) {\n\t\tod_enc = ctl >> pll_info->od_shift;\n\t\tod_enc &= GENMASK(pll_info->od_bits - 1, 0);\n\t}\n\n\tif (pll_info->bypass_bit >= 0) {\n\t\tctl = readl(cgu->base + pll_info->bypass_reg);\n\n\t\tbypass = !!(ctl & BIT(pll_info->bypass_bit));\n\n\t\tif (bypass)\n\t\t\treturn parent_rate;\n\t}\n\n\tfor (od = 0; od < pll_info->od_max; od++)\n\t\tif (pll_info->od_encoding[od] == od_enc)\n\t\t\tbreak;\n\n\t \n\tif (pll_info->od_max == 0)\n\t\tBUG_ON(pll_info->od_bits != 0);\n\telse\n\t\tBUG_ON(od == pll_info->od_max);\n\tod++;\n\n\treturn div_u64((u64)parent_rate * m * pll_info->rate_multiplier,\n\t\tn * od);\n}\n\nstatic void\ningenic_pll_calc_m_n_od(const struct ingenic_cgu_pll_info *pll_info,\n\t\t\tunsigned long rate, unsigned long parent_rate,\n\t\t\tunsigned int *pm, unsigned int *pn, unsigned int *pod)\n{\n\tunsigned int m, n, od = 1;\n\n\t \n\tn = parent_rate / (10 * MHZ);\n\tn = min_t(unsigned int, n, 1 << pll_info->n_bits);\n\tn = max_t(unsigned int, n, pll_info->n_offset);\n\n\tm = (rate / MHZ) * od * n / (parent_rate / MHZ);\n\tm = min_t(unsigned int, m, 1 << pll_info->m_bits);\n\tm = max_t(unsigned int, m, pll_info->m_offset);\n\n\t*pm = m;\n\t*pn = n;\n\t*pod = od;\n}\n\nstatic unsigned long\ningenic_pll_calc(const struct ingenic_cgu_clk_info *clk_info,\n\t\t unsigned long rate, unsigned long parent_rate,\n\t\t unsigned int *pm, unsigned int *pn, unsigned int *pod)\n{\n\tconst struct ingenic_cgu_pll_info *pll_info = &clk_info->pll;\n\tunsigned int m, n, od;\n\n\tif (pll_info->calc_m_n_od)\n\t\t(*pll_info->calc_m_n_od)(pll_info, rate, parent_rate, &m, &n, &od);\n\telse\n\t\tingenic_pll_calc_m_n_od(pll_info, rate, parent_rate, &m, &n, &od);\n\n\tif (pm)\n\t\t*pm = m;\n\tif (pn)\n\t\t*pn = n;\n\tif (pod)\n\t\t*pod = od;\n\n\treturn div_u64((u64)parent_rate * m * pll_info->rate_multiplier,\n\t\tn * od);\n}\n\nstatic long\ningenic_pll_round_rate(struct clk_hw *hw, unsigned long req_rate,\n\t\t       unsigned long *prate)\n{\n\tstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\n\tconst struct ingenic_cgu_clk_info *clk_info = to_clk_info(ingenic_clk);\n\n\treturn ingenic_pll_calc(clk_info, req_rate, *prate, NULL, NULL, NULL);\n}\n\nstatic inline int ingenic_pll_check_stable(struct ingenic_cgu *cgu,\n\t\t\t\t\t   const struct ingenic_cgu_pll_info *pll_info)\n{\n\tu32 ctl;\n\n\tif (pll_info->stable_bit < 0)\n\t\treturn 0;\n\n\treturn readl_poll_timeout(cgu->base + pll_info->reg, ctl,\n\t\t\t\t  ctl & BIT(pll_info->stable_bit),\n\t\t\t\t  0, 100 * USEC_PER_MSEC);\n}\n\nstatic int\ningenic_pll_set_rate(struct clk_hw *hw, unsigned long req_rate,\n\t\t     unsigned long parent_rate)\n{\n\tstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\n\tstruct ingenic_cgu *cgu = ingenic_clk->cgu;\n\tconst struct ingenic_cgu_clk_info *clk_info = to_clk_info(ingenic_clk);\n\tconst struct ingenic_cgu_pll_info *pll_info = &clk_info->pll;\n\tunsigned long rate, flags;\n\tunsigned int m, n, od;\n\tint ret = 0;\n\tu32 ctl;\n\n\trate = ingenic_pll_calc(clk_info, req_rate, parent_rate,\n\t\t\t       &m, &n, &od);\n\tif (rate != req_rate)\n\t\tpr_info(\"ingenic-cgu: request '%s' rate %luHz, actual %luHz\\n\",\n\t\t\tclk_info->name, req_rate, rate);\n\n\tspin_lock_irqsave(&cgu->lock, flags);\n\tctl = readl(cgu->base + pll_info->reg);\n\n\tctl &= ~(GENMASK(pll_info->m_bits - 1, 0) << pll_info->m_shift);\n\tctl |= (m - pll_info->m_offset) << pll_info->m_shift;\n\n\tctl &= ~(GENMASK(pll_info->n_bits - 1, 0) << pll_info->n_shift);\n\tctl |= (n - pll_info->n_offset) << pll_info->n_shift;\n\n\tif (pll_info->od_bits > 0) {\n\t\tctl &= ~(GENMASK(pll_info->od_bits - 1, 0) << pll_info->od_shift);\n\t\tctl |= pll_info->od_encoding[od - 1] << pll_info->od_shift;\n\t}\n\n\twritel(ctl, cgu->base + pll_info->reg);\n\n\tif (pll_info->set_rate_hook)\n\t\tpll_info->set_rate_hook(pll_info, rate, parent_rate);\n\n\t \n\tif (pll_info->enable_bit >= 0 && (ctl & BIT(pll_info->enable_bit)))\n\t\tret = ingenic_pll_check_stable(cgu, pll_info);\n\n\tspin_unlock_irqrestore(&cgu->lock, flags);\n\n\treturn ret;\n}\n\nstatic int ingenic_pll_enable(struct clk_hw *hw)\n{\n\tstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\n\tstruct ingenic_cgu *cgu = ingenic_clk->cgu;\n\tconst struct ingenic_cgu_clk_info *clk_info = to_clk_info(ingenic_clk);\n\tconst struct ingenic_cgu_pll_info *pll_info = &clk_info->pll;\n\tunsigned long flags;\n\tint ret;\n\tu32 ctl;\n\n\tif (pll_info->enable_bit < 0)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&cgu->lock, flags);\n\tif (pll_info->bypass_bit >= 0) {\n\t\tctl = readl(cgu->base + pll_info->bypass_reg);\n\n\t\tctl &= ~BIT(pll_info->bypass_bit);\n\n\t\twritel(ctl, cgu->base + pll_info->bypass_reg);\n\t}\n\n\tctl = readl(cgu->base + pll_info->reg);\n\n\tctl |= BIT(pll_info->enable_bit);\n\n\twritel(ctl, cgu->base + pll_info->reg);\n\n\tret = ingenic_pll_check_stable(cgu, pll_info);\n\tspin_unlock_irqrestore(&cgu->lock, flags);\n\n\treturn ret;\n}\n\nstatic void ingenic_pll_disable(struct clk_hw *hw)\n{\n\tstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\n\tstruct ingenic_cgu *cgu = ingenic_clk->cgu;\n\tconst struct ingenic_cgu_clk_info *clk_info = to_clk_info(ingenic_clk);\n\tconst struct ingenic_cgu_pll_info *pll_info = &clk_info->pll;\n\tunsigned long flags;\n\tu32 ctl;\n\n\tif (pll_info->enable_bit < 0)\n\t\treturn;\n\n\tspin_lock_irqsave(&cgu->lock, flags);\n\tctl = readl(cgu->base + pll_info->reg);\n\n\tctl &= ~BIT(pll_info->enable_bit);\n\n\twritel(ctl, cgu->base + pll_info->reg);\n\tspin_unlock_irqrestore(&cgu->lock, flags);\n}\n\nstatic int ingenic_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\n\tstruct ingenic_cgu *cgu = ingenic_clk->cgu;\n\tconst struct ingenic_cgu_clk_info *clk_info = to_clk_info(ingenic_clk);\n\tconst struct ingenic_cgu_pll_info *pll_info = &clk_info->pll;\n\tu32 ctl;\n\n\tif (pll_info->enable_bit < 0)\n\t\treturn true;\n\n\tctl = readl(cgu->base + pll_info->reg);\n\n\treturn !!(ctl & BIT(pll_info->enable_bit));\n}\n\nstatic const struct clk_ops ingenic_pll_ops = {\n\t.recalc_rate = ingenic_pll_recalc_rate,\n\t.round_rate = ingenic_pll_round_rate,\n\t.set_rate = ingenic_pll_set_rate,\n\n\t.enable = ingenic_pll_enable,\n\t.disable = ingenic_pll_disable,\n\t.is_enabled = ingenic_pll_is_enabled,\n};\n\n \n\nstatic u8 ingenic_clk_get_parent(struct clk_hw *hw)\n{\n\tstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\n\tconst struct ingenic_cgu_clk_info *clk_info = to_clk_info(ingenic_clk);\n\tstruct ingenic_cgu *cgu = ingenic_clk->cgu;\n\tu32 reg;\n\tu8 i, hw_idx, idx = 0;\n\n\tif (clk_info->type & CGU_CLK_MUX) {\n\t\treg = readl(cgu->base + clk_info->mux.reg);\n\t\thw_idx = (reg >> clk_info->mux.shift) &\n\t\t\t GENMASK(clk_info->mux.bits - 1, 0);\n\n\t\t \n\t\tfor (i = 0; i < hw_idx; i++) {\n\t\t\tif (clk_info->parents[i] != -1)\n\t\t\t\tidx++;\n\t\t}\n\t}\n\n\treturn idx;\n}\n\nstatic int ingenic_clk_set_parent(struct clk_hw *hw, u8 idx)\n{\n\tstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\n\tconst struct ingenic_cgu_clk_info *clk_info = to_clk_info(ingenic_clk);\n\tstruct ingenic_cgu *cgu = ingenic_clk->cgu;\n\tunsigned long flags;\n\tu8 curr_idx, hw_idx, num_poss;\n\tu32 reg, mask;\n\n\tif (clk_info->type & CGU_CLK_MUX) {\n\t\t \n\t\thw_idx = curr_idx = 0;\n\t\tnum_poss = 1 << clk_info->mux.bits;\n\t\tfor (; hw_idx < num_poss; hw_idx++) {\n\t\t\tif (clk_info->parents[hw_idx] == -1)\n\t\t\t\tcontinue;\n\t\t\tif (curr_idx == idx)\n\t\t\t\tbreak;\n\t\t\tcurr_idx++;\n\t\t}\n\n\t\t \n\t\tBUG_ON(curr_idx != idx);\n\n\t\tmask = GENMASK(clk_info->mux.bits - 1, 0);\n\t\tmask <<= clk_info->mux.shift;\n\n\t\tspin_lock_irqsave(&cgu->lock, flags);\n\n\t\t \n\t\treg = readl(cgu->base + clk_info->mux.reg);\n\t\treg &= ~mask;\n\t\treg |= hw_idx << clk_info->mux.shift;\n\t\twritel(reg, cgu->base + clk_info->mux.reg);\n\n\t\tspin_unlock_irqrestore(&cgu->lock, flags);\n\t\treturn 0;\n\t}\n\n\treturn idx ? -EINVAL : 0;\n}\n\nstatic unsigned long\ningenic_clk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\n\tconst struct ingenic_cgu_clk_info *clk_info = to_clk_info(ingenic_clk);\n\tstruct ingenic_cgu *cgu = ingenic_clk->cgu;\n\tunsigned long rate = parent_rate;\n\tu32 div_reg, div;\n\tu8 parent;\n\n\tif (clk_info->type & CGU_CLK_DIV) {\n\t\tparent = ingenic_clk_get_parent(hw);\n\n\t\tif (!(clk_info->div.bypass_mask & BIT(parent))) {\n\t\t\tdiv_reg = readl(cgu->base + clk_info->div.reg);\n\t\t\tdiv = (div_reg >> clk_info->div.shift) &\n\t\t\t      GENMASK(clk_info->div.bits - 1, 0);\n\n\t\t\tif (clk_info->div.div_table)\n\t\t\t\tdiv = clk_info->div.div_table[div];\n\t\t\telse\n\t\t\t\tdiv = (div + 1) * clk_info->div.div;\n\n\t\t\trate /= div;\n\t\t}\n\t} else if (clk_info->type & CGU_CLK_FIXDIV) {\n\t\trate /= clk_info->fixdiv.div;\n\t}\n\n\treturn rate;\n}\n\nstatic unsigned int\ningenic_clk_calc_hw_div(const struct ingenic_cgu_clk_info *clk_info,\n\t\t\tunsigned int div)\n{\n\tunsigned int i, best_i = 0, best = (unsigned int)-1;\n\n\tfor (i = 0; i < (1 << clk_info->div.bits)\n\t\t\t\t&& clk_info->div.div_table[i]; i++) {\n\t\tif (clk_info->div.div_table[i] >= div &&\n\t\t    clk_info->div.div_table[i] < best) {\n\t\t\tbest = clk_info->div.div_table[i];\n\t\t\tbest_i = i;\n\n\t\t\tif (div == best)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn best_i;\n}\n\nstatic unsigned\ningenic_clk_calc_div(struct clk_hw *hw,\n\t\t     const struct ingenic_cgu_clk_info *clk_info,\n\t\t     unsigned long parent_rate, unsigned long req_rate)\n{\n\tunsigned int div, hw_div;\n\tu8 parent;\n\n\tparent = ingenic_clk_get_parent(hw);\n\tif (clk_info->div.bypass_mask & BIT(parent))\n\t\treturn 1;\n\n\t \n\tdiv = DIV_ROUND_UP(parent_rate, req_rate);\n\n\tif (clk_info->div.div_table) {\n\t\thw_div = ingenic_clk_calc_hw_div(clk_info, div);\n\n\t\treturn clk_info->div.div_table[hw_div];\n\t}\n\n\t \n\tdiv = clamp_t(unsigned int, div, clk_info->div.div,\n\t\t      clk_info->div.div << clk_info->div.bits);\n\n\t \n\tdiv = DIV_ROUND_UP(div, clk_info->div.div);\n\tdiv *= clk_info->div.div;\n\n\treturn div;\n}\n\nstatic int ingenic_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\n\tconst struct ingenic_cgu_clk_info *clk_info = to_clk_info(ingenic_clk);\n\tunsigned int div = 1;\n\n\tif (clk_info->type & CGU_CLK_DIV)\n\t\tdiv = ingenic_clk_calc_div(hw, clk_info, req->best_parent_rate,\n\t\t\t\t\t   req->rate);\n\telse if (clk_info->type & CGU_CLK_FIXDIV)\n\t\tdiv = clk_info->fixdiv.div;\n\telse if (clk_hw_can_set_rate_parent(hw))\n\t\treq->best_parent_rate = req->rate;\n\n\treq->rate = DIV_ROUND_UP(req->best_parent_rate, div);\n\treturn 0;\n}\n\nstatic inline int ingenic_clk_check_stable(struct ingenic_cgu *cgu,\n\t\t\t\t\t   const struct ingenic_cgu_clk_info *clk_info)\n{\n\tu32 reg;\n\n\treturn readl_poll_timeout(cgu->base + clk_info->div.reg, reg,\n\t\t\t\t  !(reg & BIT(clk_info->div.busy_bit)),\n\t\t\t\t  0, 100 * USEC_PER_MSEC);\n}\n\nstatic int\ningenic_clk_set_rate(struct clk_hw *hw, unsigned long req_rate,\n\t\t     unsigned long parent_rate)\n{\n\tstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\n\tconst struct ingenic_cgu_clk_info *clk_info = to_clk_info(ingenic_clk);\n\tstruct ingenic_cgu *cgu = ingenic_clk->cgu;\n\tunsigned long rate, flags;\n\tunsigned int hw_div, div;\n\tu32 reg, mask;\n\tint ret = 0;\n\n\tif (clk_info->type & CGU_CLK_DIV) {\n\t\tdiv = ingenic_clk_calc_div(hw, clk_info, parent_rate, req_rate);\n\t\trate = DIV_ROUND_UP(parent_rate, div);\n\n\t\tif (rate != req_rate)\n\t\t\treturn -EINVAL;\n\n\t\tif (clk_info->div.div_table)\n\t\t\thw_div = ingenic_clk_calc_hw_div(clk_info, div);\n\t\telse\n\t\t\thw_div = ((div / clk_info->div.div) - 1);\n\n\t\tspin_lock_irqsave(&cgu->lock, flags);\n\t\treg = readl(cgu->base + clk_info->div.reg);\n\n\t\t \n\t\tmask = GENMASK(clk_info->div.bits - 1, 0);\n\t\treg &= ~(mask << clk_info->div.shift);\n\t\treg |= hw_div << clk_info->div.shift;\n\n\t\t \n\t\tif (clk_info->div.stop_bit != -1)\n\t\t\treg &= ~BIT(clk_info->div.stop_bit);\n\n\t\t \n\t\tif (clk_info->div.ce_bit != -1)\n\t\t\treg |= BIT(clk_info->div.ce_bit);\n\n\t\t \n\t\twritel(reg, cgu->base + clk_info->div.reg);\n\n\t\t \n\t\tif (clk_info->div.busy_bit != -1)\n\t\t\tret = ingenic_clk_check_stable(cgu, clk_info);\n\n\t\tspin_unlock_irqrestore(&cgu->lock, flags);\n\t\treturn ret;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ingenic_clk_enable(struct clk_hw *hw)\n{\n\tstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\n\tconst struct ingenic_cgu_clk_info *clk_info = to_clk_info(ingenic_clk);\n\tstruct ingenic_cgu *cgu = ingenic_clk->cgu;\n\tunsigned long flags;\n\n\tif (clk_info->type & CGU_CLK_GATE) {\n\t\t \n\t\tspin_lock_irqsave(&cgu->lock, flags);\n\t\tingenic_cgu_gate_set(cgu, &clk_info->gate, false);\n\t\tspin_unlock_irqrestore(&cgu->lock, flags);\n\n\t\tif (clk_info->gate.delay_us)\n\t\t\tudelay(clk_info->gate.delay_us);\n\t}\n\n\treturn 0;\n}\n\nstatic void ingenic_clk_disable(struct clk_hw *hw)\n{\n\tstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\n\tconst struct ingenic_cgu_clk_info *clk_info = to_clk_info(ingenic_clk);\n\tstruct ingenic_cgu *cgu = ingenic_clk->cgu;\n\tunsigned long flags;\n\n\tif (clk_info->type & CGU_CLK_GATE) {\n\t\t \n\t\tspin_lock_irqsave(&cgu->lock, flags);\n\t\tingenic_cgu_gate_set(cgu, &clk_info->gate, true);\n\t\tspin_unlock_irqrestore(&cgu->lock, flags);\n\t}\n}\n\nstatic int ingenic_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct ingenic_clk *ingenic_clk = to_ingenic_clk(hw);\n\tconst struct ingenic_cgu_clk_info *clk_info = to_clk_info(ingenic_clk);\n\tstruct ingenic_cgu *cgu = ingenic_clk->cgu;\n\tint enabled = 1;\n\n\tif (clk_info->type & CGU_CLK_GATE)\n\t\tenabled = !ingenic_cgu_gate_get(cgu, &clk_info->gate);\n\n\treturn enabled;\n}\n\nstatic const struct clk_ops ingenic_clk_ops = {\n\t.get_parent = ingenic_clk_get_parent,\n\t.set_parent = ingenic_clk_set_parent,\n\n\t.recalc_rate = ingenic_clk_recalc_rate,\n\t.determine_rate = ingenic_clk_determine_rate,\n\t.set_rate = ingenic_clk_set_rate,\n\n\t.enable = ingenic_clk_enable,\n\t.disable = ingenic_clk_disable,\n\t.is_enabled = ingenic_clk_is_enabled,\n};\n\n \n\nstatic int ingenic_register_clock(struct ingenic_cgu *cgu, unsigned idx)\n{\n\tconst struct ingenic_cgu_clk_info *clk_info = &cgu->clock_info[idx];\n\tstruct clk_init_data clk_init;\n\tstruct ingenic_clk *ingenic_clk = NULL;\n\tstruct clk *clk, *parent;\n\tconst char *parent_names[4];\n\tunsigned caps, i, num_possible;\n\tint err = -EINVAL;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(clk_info->parents) > ARRAY_SIZE(parent_names));\n\n\tif (clk_info->type == CGU_CLK_EXT) {\n\t\tclk = of_clk_get_by_name(cgu->np, clk_info->name);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: no external clock '%s' provided\\n\",\n\t\t\t       __func__, clk_info->name);\n\t\t\terr = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\terr = clk_register_clkdev(clk, clk_info->name, NULL);\n\t\tif (err) {\n\t\t\tclk_put(clk);\n\t\t\tgoto out;\n\t\t}\n\t\tcgu->clocks.clks[idx] = clk;\n\t\treturn 0;\n\t}\n\n\tif (!clk_info->type) {\n\t\tpr_err(\"%s: no clock type specified for '%s'\\n\", __func__,\n\t\t       clk_info->name);\n\t\tgoto out;\n\t}\n\n\tingenic_clk = kzalloc(sizeof(*ingenic_clk), GFP_KERNEL);\n\tif (!ingenic_clk) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tingenic_clk->hw.init = &clk_init;\n\tingenic_clk->cgu = cgu;\n\tingenic_clk->idx = idx;\n\n\tclk_init.name = clk_info->name;\n\tclk_init.flags = clk_info->flags;\n\tclk_init.parent_names = parent_names;\n\n\tcaps = clk_info->type;\n\n\tif (caps & CGU_CLK_DIV) {\n\t\tcaps &= ~CGU_CLK_DIV;\n\t} else if (!(caps & CGU_CLK_CUSTOM)) {\n\t\t \n\t\tclk_init.flags |= CLK_SET_RATE_PARENT;\n\t}\n\n\tif (caps & (CGU_CLK_MUX | CGU_CLK_CUSTOM)) {\n\t\tclk_init.num_parents = 0;\n\n\t\tif (caps & CGU_CLK_MUX)\n\t\t\tnum_possible = 1 << clk_info->mux.bits;\n\t\telse\n\t\t\tnum_possible = ARRAY_SIZE(clk_info->parents);\n\n\t\tfor (i = 0; i < num_possible; i++) {\n\t\t\tif (clk_info->parents[i] == -1)\n\t\t\t\tcontinue;\n\n\t\t\tparent = cgu->clocks.clks[clk_info->parents[i]];\n\t\t\tparent_names[clk_init.num_parents] =\n\t\t\t\t__clk_get_name(parent);\n\t\t\tclk_init.num_parents++;\n\t\t}\n\n\t\tBUG_ON(!clk_init.num_parents);\n\t\tBUG_ON(clk_init.num_parents > ARRAY_SIZE(parent_names));\n\t} else {\n\t\tBUG_ON(clk_info->parents[0] == -1);\n\t\tclk_init.num_parents = 1;\n\t\tparent = cgu->clocks.clks[clk_info->parents[0]];\n\t\tparent_names[0] = __clk_get_name(parent);\n\t}\n\n\tif (caps & CGU_CLK_CUSTOM) {\n\t\tclk_init.ops = clk_info->custom.clk_ops;\n\n\t\tcaps &= ~CGU_CLK_CUSTOM;\n\n\t\tif (caps) {\n\t\t\tpr_err(\"%s: custom clock may not be combined with type 0x%x\\n\",\n\t\t\t       __func__, caps);\n\t\t\tgoto out;\n\t\t}\n\t} else if (caps & CGU_CLK_PLL) {\n\t\tclk_init.ops = &ingenic_pll_ops;\n\n\t\tcaps &= ~CGU_CLK_PLL;\n\n\t\tif (caps) {\n\t\t\tpr_err(\"%s: PLL may not be combined with type 0x%x\\n\",\n\t\t\t       __func__, caps);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tclk_init.ops = &ingenic_clk_ops;\n\t}\n\n\t \n\tcaps &= ~(CGU_CLK_GATE | CGU_CLK_FIXDIV);\n\n\tif (caps & CGU_CLK_MUX) {\n\t\tif (!(caps & CGU_CLK_MUX_GLITCHFREE))\n\t\t\tclk_init.flags |= CLK_SET_PARENT_GATE;\n\n\t\tcaps &= ~(CGU_CLK_MUX | CGU_CLK_MUX_GLITCHFREE);\n\t}\n\n\tif (caps) {\n\t\tpr_err(\"%s: unknown clock type 0x%x\\n\", __func__, caps);\n\t\tgoto out;\n\t}\n\n\tclk = clk_register(NULL, &ingenic_clk->hw);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: failed to register clock '%s'\\n\", __func__,\n\t\t       clk_info->name);\n\t\terr = PTR_ERR(clk);\n\t\tgoto out;\n\t}\n\n\terr = clk_register_clkdev(clk, clk_info->name, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tcgu->clocks.clks[idx] = clk;\nout:\n\tif (err)\n\t\tkfree(ingenic_clk);\n\treturn err;\n}\n\nstruct ingenic_cgu *\ningenic_cgu_new(const struct ingenic_cgu_clk_info *clock_info,\n\t\tunsigned num_clocks, struct device_node *np)\n{\n\tstruct ingenic_cgu *cgu;\n\n\tcgu = kzalloc(sizeof(*cgu), GFP_KERNEL);\n\tif (!cgu)\n\t\tgoto err_out;\n\n\tcgu->base = of_iomap(np, 0);\n\tif (!cgu->base) {\n\t\tpr_err(\"%s: failed to map CGU registers\\n\", __func__);\n\t\tgoto err_out_free;\n\t}\n\n\tcgu->np = np;\n\tcgu->clock_info = clock_info;\n\tcgu->clocks.clk_num = num_clocks;\n\n\tspin_lock_init(&cgu->lock);\n\n\treturn cgu;\n\nerr_out_free:\n\tkfree(cgu);\nerr_out:\n\treturn NULL;\n}\n\nint ingenic_cgu_register_clocks(struct ingenic_cgu *cgu)\n{\n\tunsigned i;\n\tint err;\n\n\tcgu->clocks.clks = kcalloc(cgu->clocks.clk_num, sizeof(struct clk *),\n\t\t\t\t   GFP_KERNEL);\n\tif (!cgu->clocks.clks) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tfor (i = 0; i < cgu->clocks.clk_num; i++) {\n\t\terr = ingenic_register_clock(cgu, i);\n\t\tif (err)\n\t\t\tgoto err_out_unregister;\n\t}\n\n\terr = of_clk_add_provider(cgu->np, of_clk_src_onecell_get,\n\t\t\t\t  &cgu->clocks);\n\tif (err)\n\t\tgoto err_out_unregister;\n\n\treturn 0;\n\nerr_out_unregister:\n\tfor (i = 0; i < cgu->clocks.clk_num; i++) {\n\t\tif (!cgu->clocks.clks[i])\n\t\t\tcontinue;\n\t\tif (cgu->clock_info[i].type & CGU_CLK_EXT)\n\t\t\tclk_put(cgu->clocks.clks[i]);\n\t\telse\n\t\t\tclk_unregister(cgu->clocks.clks[i]);\n\t}\n\tkfree(cgu->clocks.clks);\nerr_out:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}