{
  "module_name": "tcu.c",
  "hash_id": "9cd2424b5cf784e7e8905e7fdccbe71e15f11fe524e445d8b42be508715c6fb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ingenic/tcu.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clockchips.h>\n#include <linux/mfd/ingenic-tcu.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/syscore_ops.h>\n\n#include <dt-bindings/clock/ingenic,tcu.h>\n\n \n#define TCU_CLK_COUNT\t10\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"ingenic-tcu-clk: \" fmt\n\nenum tcu_clk_parent {\n\tTCU_PARENT_PCLK,\n\tTCU_PARENT_RTC,\n\tTCU_PARENT_EXT,\n};\n\nstruct ingenic_soc_info {\n\tunsigned int num_channels;\n\tbool has_ost;\n\tbool has_tcu_clk;\n\tbool allow_missing_tcu_clk;\n};\n\nstruct ingenic_tcu_clk_info {\n\tstruct clk_init_data init_data;\n\tu8 gate_bit;\n\tu8 tcsr_reg;\n};\n\nstruct ingenic_tcu_clk {\n\tstruct clk_hw hw;\n\tunsigned int idx;\n\tstruct ingenic_tcu *tcu;\n\tconst struct ingenic_tcu_clk_info *info;\n};\n\nstruct ingenic_tcu {\n\tconst struct ingenic_soc_info *soc_info;\n\tstruct regmap *map;\n\tstruct clk *clk;\n\n\tstruct clk_hw_onecell_data *clocks;\n};\n\nstatic struct ingenic_tcu *ingenic_tcu;\n\nstatic inline struct ingenic_tcu_clk *to_tcu_clk(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct ingenic_tcu_clk, hw);\n}\n\nstatic int ingenic_tcu_enable(struct clk_hw *hw)\n{\n\tstruct ingenic_tcu_clk *tcu_clk = to_tcu_clk(hw);\n\tconst struct ingenic_tcu_clk_info *info = tcu_clk->info;\n\tstruct ingenic_tcu *tcu = tcu_clk->tcu;\n\n\tregmap_write(tcu->map, TCU_REG_TSCR, BIT(info->gate_bit));\n\n\treturn 0;\n}\n\nstatic void ingenic_tcu_disable(struct clk_hw *hw)\n{\n\tstruct ingenic_tcu_clk *tcu_clk = to_tcu_clk(hw);\n\tconst struct ingenic_tcu_clk_info *info = tcu_clk->info;\n\tstruct ingenic_tcu *tcu = tcu_clk->tcu;\n\n\tregmap_write(tcu->map, TCU_REG_TSSR, BIT(info->gate_bit));\n}\n\nstatic int ingenic_tcu_is_enabled(struct clk_hw *hw)\n{\n\tstruct ingenic_tcu_clk *tcu_clk = to_tcu_clk(hw);\n\tconst struct ingenic_tcu_clk_info *info = tcu_clk->info;\n\tunsigned int value;\n\n\tregmap_read(tcu_clk->tcu->map, TCU_REG_TSR, &value);\n\n\treturn !(value & BIT(info->gate_bit));\n}\n\nstatic bool ingenic_tcu_enable_regs(struct clk_hw *hw)\n{\n\tstruct ingenic_tcu_clk *tcu_clk = to_tcu_clk(hw);\n\tconst struct ingenic_tcu_clk_info *info = tcu_clk->info;\n\tstruct ingenic_tcu *tcu = tcu_clk->tcu;\n\tbool enabled = false;\n\n\t \n\tenabled = !!ingenic_tcu_is_enabled(hw);\n\tregmap_write(tcu->map, TCU_REG_TSCR, BIT(info->gate_bit));\n\n\treturn enabled;\n}\n\nstatic void ingenic_tcu_disable_regs(struct clk_hw *hw)\n{\n\tstruct ingenic_tcu_clk *tcu_clk = to_tcu_clk(hw);\n\tconst struct ingenic_tcu_clk_info *info = tcu_clk->info;\n\tstruct ingenic_tcu *tcu = tcu_clk->tcu;\n\n\tregmap_write(tcu->map, TCU_REG_TSSR, BIT(info->gate_bit));\n}\n\nstatic u8 ingenic_tcu_get_parent(struct clk_hw *hw)\n{\n\tstruct ingenic_tcu_clk *tcu_clk = to_tcu_clk(hw);\n\tconst struct ingenic_tcu_clk_info *info = tcu_clk->info;\n\tunsigned int val = 0;\n\tint ret;\n\n\tret = regmap_read(tcu_clk->tcu->map, info->tcsr_reg, &val);\n\tWARN_ONCE(ret < 0, \"Unable to read TCSR %d\", tcu_clk->idx);\n\n\treturn ffs(val & TCU_TCSR_PARENT_CLOCK_MASK) - 1;\n}\n\nstatic int ingenic_tcu_set_parent(struct clk_hw *hw, u8 idx)\n{\n\tstruct ingenic_tcu_clk *tcu_clk = to_tcu_clk(hw);\n\tconst struct ingenic_tcu_clk_info *info = tcu_clk->info;\n\tbool was_enabled;\n\tint ret;\n\n\twas_enabled = ingenic_tcu_enable_regs(hw);\n\n\tret = regmap_update_bits(tcu_clk->tcu->map, info->tcsr_reg,\n\t\t\t\t TCU_TCSR_PARENT_CLOCK_MASK, BIT(idx));\n\tWARN_ONCE(ret < 0, \"Unable to update TCSR %d\", tcu_clk->idx);\n\n\tif (!was_enabled)\n\t\tingenic_tcu_disable_regs(hw);\n\n\treturn 0;\n}\n\nstatic unsigned long ingenic_tcu_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct ingenic_tcu_clk *tcu_clk = to_tcu_clk(hw);\n\tconst struct ingenic_tcu_clk_info *info = tcu_clk->info;\n\tunsigned int prescale;\n\tint ret;\n\n\tret = regmap_read(tcu_clk->tcu->map, info->tcsr_reg, &prescale);\n\tWARN_ONCE(ret < 0, \"Unable to read TCSR %d\", tcu_clk->idx);\n\n\tprescale = (prescale & TCU_TCSR_PRESCALE_MASK) >> TCU_TCSR_PRESCALE_LSB;\n\n\treturn parent_rate >> (prescale * 2);\n}\n\nstatic u8 ingenic_tcu_get_prescale(unsigned long rate, unsigned long req_rate)\n{\n\tu8 prescale;\n\n\tfor (prescale = 0; prescale < 5; prescale++)\n\t\tif ((rate >> (prescale * 2)) <= req_rate)\n\t\t\treturn prescale;\n\n\treturn 5;  \n}\n\nstatic int ingenic_tcu_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tunsigned long rate = req->best_parent_rate;\n\tu8 prescale;\n\n\tif (req->rate > rate) {\n\t\treq->rate = rate;\n\t\treturn 0;\n\t}\n\n\tprescale = ingenic_tcu_get_prescale(rate, req->rate);\n\n\treq->rate = rate >> (prescale * 2);\n\treturn 0;\n}\n\nstatic int ingenic_tcu_set_rate(struct clk_hw *hw, unsigned long req_rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct ingenic_tcu_clk *tcu_clk = to_tcu_clk(hw);\n\tconst struct ingenic_tcu_clk_info *info = tcu_clk->info;\n\tu8 prescale = ingenic_tcu_get_prescale(parent_rate, req_rate);\n\tbool was_enabled;\n\tint ret;\n\n\twas_enabled = ingenic_tcu_enable_regs(hw);\n\n\tret = regmap_update_bits(tcu_clk->tcu->map, info->tcsr_reg,\n\t\t\t\t TCU_TCSR_PRESCALE_MASK,\n\t\t\t\t prescale << TCU_TCSR_PRESCALE_LSB);\n\tWARN_ONCE(ret < 0, \"Unable to update TCSR %d\", tcu_clk->idx);\n\n\tif (!was_enabled)\n\t\tingenic_tcu_disable_regs(hw);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops ingenic_tcu_clk_ops = {\n\t.get_parent\t= ingenic_tcu_get_parent,\n\t.set_parent\t= ingenic_tcu_set_parent,\n\n\t.recalc_rate\t= ingenic_tcu_recalc_rate,\n\t.determine_rate\t= ingenic_tcu_determine_rate,\n\t.set_rate\t= ingenic_tcu_set_rate,\n\n\t.enable\t\t= ingenic_tcu_enable,\n\t.disable\t= ingenic_tcu_disable,\n\t.is_enabled\t= ingenic_tcu_is_enabled,\n};\n\nstatic const char * const ingenic_tcu_timer_parents[] = {\n\t[TCU_PARENT_PCLK] = \"pclk\",\n\t[TCU_PARENT_RTC]  = \"rtc\",\n\t[TCU_PARENT_EXT]  = \"ext\",\n};\n\n#define DEF_TIMER(_name, _gate_bit, _tcsr)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.init_data = {\t\t\t\t\t\t\\\n\t\t\t.name = _name,\t\t\t\t\t\\\n\t\t\t.parent_names = ingenic_tcu_timer_parents,\t\\\n\t\t\t.num_parents = ARRAY_SIZE(ingenic_tcu_timer_parents),\\\n\t\t\t.ops = &ingenic_tcu_clk_ops,\t\t\t\\\n\t\t\t.flags = CLK_SET_RATE_UNGATE,\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.gate_bit = _gate_bit,\t\t\t\t\t\\\n\t\t.tcsr_reg = _tcsr,\t\t\t\t\t\\\n\t}\nstatic const struct ingenic_tcu_clk_info ingenic_tcu_clk_info[] = {\n\t[TCU_CLK_TIMER0] = DEF_TIMER(\"timer0\", 0, TCU_REG_TCSRc(0)),\n\t[TCU_CLK_TIMER1] = DEF_TIMER(\"timer1\", 1, TCU_REG_TCSRc(1)),\n\t[TCU_CLK_TIMER2] = DEF_TIMER(\"timer2\", 2, TCU_REG_TCSRc(2)),\n\t[TCU_CLK_TIMER3] = DEF_TIMER(\"timer3\", 3, TCU_REG_TCSRc(3)),\n\t[TCU_CLK_TIMER4] = DEF_TIMER(\"timer4\", 4, TCU_REG_TCSRc(4)),\n\t[TCU_CLK_TIMER5] = DEF_TIMER(\"timer5\", 5, TCU_REG_TCSRc(5)),\n\t[TCU_CLK_TIMER6] = DEF_TIMER(\"timer6\", 6, TCU_REG_TCSRc(6)),\n\t[TCU_CLK_TIMER7] = DEF_TIMER(\"timer7\", 7, TCU_REG_TCSRc(7)),\n};\n\nstatic const struct ingenic_tcu_clk_info ingenic_tcu_watchdog_clk_info =\n\t\t\t\t\t DEF_TIMER(\"wdt\", 16, TCU_REG_WDT_TCSR);\nstatic const struct ingenic_tcu_clk_info ingenic_tcu_ost_clk_info =\n\t\t\t\t\t DEF_TIMER(\"ost\", 15, TCU_REG_OST_TCSR);\n#undef DEF_TIMER\n\nstatic int __init ingenic_tcu_register_clock(struct ingenic_tcu *tcu,\n\t\t\tunsigned int idx, enum tcu_clk_parent parent,\n\t\t\tconst struct ingenic_tcu_clk_info *info,\n\t\t\tstruct clk_hw_onecell_data *clocks)\n{\n\tstruct ingenic_tcu_clk *tcu_clk;\n\tint err;\n\n\ttcu_clk = kzalloc(sizeof(*tcu_clk), GFP_KERNEL);\n\tif (!tcu_clk)\n\t\treturn -ENOMEM;\n\n\ttcu_clk->hw.init = &info->init_data;\n\ttcu_clk->idx = idx;\n\ttcu_clk->info = info;\n\ttcu_clk->tcu = tcu;\n\n\t \n\tingenic_tcu_enable_regs(&tcu_clk->hw);\n\tregmap_update_bits(tcu->map, info->tcsr_reg, 0xffff, BIT(parent));\n\tingenic_tcu_disable_regs(&tcu_clk->hw);\n\n\terr = clk_hw_register(NULL, &tcu_clk->hw);\n\tif (err) {\n\t\tkfree(tcu_clk);\n\t\treturn err;\n\t}\n\n\tclocks->hws[idx] = &tcu_clk->hw;\n\n\treturn 0;\n}\n\nstatic const struct ingenic_soc_info jz4740_soc_info = {\n\t.num_channels = 8,\n\t.has_ost = false,\n\t.has_tcu_clk = true,\n};\n\nstatic const struct ingenic_soc_info jz4725b_soc_info = {\n\t.num_channels = 6,\n\t.has_ost = true,\n\t.has_tcu_clk = true,\n};\n\nstatic const struct ingenic_soc_info jz4770_soc_info = {\n\t.num_channels = 8,\n\t.has_ost = true,\n\t.has_tcu_clk = false,\n};\n\nstatic const struct ingenic_soc_info x1000_soc_info = {\n\t.num_channels = 8,\n\t.has_ost = false,  \n\t.has_tcu_clk = true,\n\t.allow_missing_tcu_clk = true,\n};\n\nstatic const struct of_device_id __maybe_unused ingenic_tcu_of_match[] __initconst = {\n\t{ .compatible = \"ingenic,jz4740-tcu\", .data = &jz4740_soc_info, },\n\t{ .compatible = \"ingenic,jz4725b-tcu\", .data = &jz4725b_soc_info, },\n\t{ .compatible = \"ingenic,jz4760-tcu\", .data = &jz4770_soc_info, },\n\t{ .compatible = \"ingenic,jz4770-tcu\", .data = &jz4770_soc_info, },\n\t{ .compatible = \"ingenic,x1000-tcu\", .data = &x1000_soc_info, },\n\t{   }\n};\n\nstatic int __init ingenic_tcu_probe(struct device_node *np)\n{\n\tconst struct of_device_id *id = of_match_node(ingenic_tcu_of_match, np);\n\tstruct ingenic_tcu *tcu;\n\tstruct regmap *map;\n\tunsigned int i;\n\tint ret;\n\n\tmap = device_node_to_regmap(np);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\ttcu = kzalloc(sizeof(*tcu), GFP_KERNEL);\n\tif (!tcu)\n\t\treturn -ENOMEM;\n\n\ttcu->map = map;\n\ttcu->soc_info = id->data;\n\n\tif (tcu->soc_info->has_tcu_clk) {\n\t\ttcu->clk = of_clk_get_by_name(np, \"tcu\");\n\t\tif (IS_ERR(tcu->clk)) {\n\t\t\tret = PTR_ERR(tcu->clk);\n\n\t\t\t \n\t\t\tif (tcu->soc_info->allow_missing_tcu_clk && ret == -EINVAL) {\n\t\t\t\tpr_warn(\"TCU clock missing from device tree, please update your device tree\\n\");\n\t\t\t\ttcu->clk = NULL;\n\t\t\t} else {\n\t\t\t\tpr_crit(\"Cannot get TCU clock from device tree\\n\");\n\t\t\t\tgoto err_free_tcu;\n\t\t\t}\n\t\t} else {\n\t\t\tret = clk_prepare_enable(tcu->clk);\n\t\t\tif (ret) {\n\t\t\t\tpr_crit(\"Unable to enable TCU clock\\n\");\n\t\t\t\tgoto err_put_clk;\n\t\t\t}\n\t\t}\n\t}\n\n\ttcu->clocks = kzalloc(struct_size(tcu->clocks, hws, TCU_CLK_COUNT),\n\t\t\t      GFP_KERNEL);\n\tif (!tcu->clocks) {\n\t\tret = -ENOMEM;\n\t\tgoto err_clk_disable;\n\t}\n\n\ttcu->clocks->num = TCU_CLK_COUNT;\n\n\tfor (i = 0; i < tcu->soc_info->num_channels; i++) {\n\t\tret = ingenic_tcu_register_clock(tcu, i, TCU_PARENT_EXT,\n\t\t\t\t\t\t &ingenic_tcu_clk_info[i],\n\t\t\t\t\t\t tcu->clocks);\n\t\tif (ret) {\n\t\t\tpr_crit(\"cannot register clock %d\\n\", i);\n\t\t\tgoto err_unregister_timer_clocks;\n\t\t}\n\t}\n\n\t \n\tret = ingenic_tcu_register_clock(tcu, TCU_CLK_WDT, TCU_PARENT_RTC,\n\t\t\t\t\t &ingenic_tcu_watchdog_clk_info,\n\t\t\t\t\t tcu->clocks);\n\tif (ret) {\n\t\tpr_crit(\"cannot register watchdog clock\\n\");\n\t\tgoto err_unregister_timer_clocks;\n\t}\n\n\tif (tcu->soc_info->has_ost) {\n\t\tret = ingenic_tcu_register_clock(tcu, TCU_CLK_OST,\n\t\t\t\t\t\t TCU_PARENT_EXT,\n\t\t\t\t\t\t &ingenic_tcu_ost_clk_info,\n\t\t\t\t\t\t tcu->clocks);\n\t\tif (ret) {\n\t\t\tpr_crit(\"cannot register ost clock\\n\");\n\t\t\tgoto err_unregister_watchdog_clock;\n\t\t}\n\t}\n\n\tret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, tcu->clocks);\n\tif (ret) {\n\t\tpr_crit(\"cannot add OF clock provider\\n\");\n\t\tgoto err_unregister_ost_clock;\n\t}\n\n\tingenic_tcu = tcu;\n\n\treturn 0;\n\nerr_unregister_ost_clock:\n\tif (tcu->soc_info->has_ost)\n\t\tclk_hw_unregister(tcu->clocks->hws[i + 1]);\nerr_unregister_watchdog_clock:\n\tclk_hw_unregister(tcu->clocks->hws[i]);\nerr_unregister_timer_clocks:\n\tfor (i = 0; i < tcu->clocks->num; i++)\n\t\tif (tcu->clocks->hws[i])\n\t\t\tclk_hw_unregister(tcu->clocks->hws[i]);\n\tkfree(tcu->clocks);\nerr_clk_disable:\n\tif (tcu->clk)\n\t\tclk_disable_unprepare(tcu->clk);\nerr_put_clk:\n\tif (tcu->clk)\n\t\tclk_put(tcu->clk);\nerr_free_tcu:\n\tkfree(tcu);\n\treturn ret;\n}\n\nstatic int __maybe_unused tcu_pm_suspend(void)\n{\n\tstruct ingenic_tcu *tcu = ingenic_tcu;\n\n\tif (tcu->clk)\n\t\tclk_disable(tcu->clk);\n\n\treturn 0;\n}\n\nstatic void __maybe_unused tcu_pm_resume(void)\n{\n\tstruct ingenic_tcu *tcu = ingenic_tcu;\n\n\tif (tcu->clk)\n\t\tclk_enable(tcu->clk);\n}\n\nstatic struct syscore_ops __maybe_unused tcu_pm_ops = {\n\t.suspend = tcu_pm_suspend,\n\t.resume = tcu_pm_resume,\n};\n\nstatic void __init ingenic_tcu_init(struct device_node *np)\n{\n\tint ret = ingenic_tcu_probe(np);\n\n\tif (ret)\n\t\tpr_crit(\"Failed to initialize TCU clocks: %d\\n\", ret);\n\n\tif (IS_ENABLED(CONFIG_PM_SLEEP))\n\t\tregister_syscore_ops(&tcu_pm_ops);\n}\n\nCLK_OF_DECLARE_DRIVER(jz4740_cgu, \"ingenic,jz4740-tcu\", ingenic_tcu_init);\nCLK_OF_DECLARE_DRIVER(jz4725b_cgu, \"ingenic,jz4725b-tcu\", ingenic_tcu_init);\nCLK_OF_DECLARE_DRIVER(jz4760_cgu, \"ingenic,jz4760-tcu\", ingenic_tcu_init);\nCLK_OF_DECLARE_DRIVER(jz4770_cgu, \"ingenic,jz4770-tcu\", ingenic_tcu_init);\nCLK_OF_DECLARE_DRIVER(x1000_cgu, \"ingenic,x1000-tcu\", ingenic_tcu_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}