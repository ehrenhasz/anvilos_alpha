{
  "module_name": "clk-h32mx.c",
  "hash_id": "19219a49e03ed9e1044530cbf80037e3bb7d3fb6fc3e9aa28d3c6184b9848e98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/clk-h32mx.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n\n#include \"pmc.h\"\n\n#define H32MX_MAX_FREQ\t90000000\n\nstruct clk_sama5d4_h32mx {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n};\n\n#define to_clk_sama5d4_h32mx(hw) container_of(hw, struct clk_sama5d4_h32mx, hw)\n\nstatic unsigned long clk_sama5d4_h32mx_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_sama5d4_h32mx *h32mxclk = to_clk_sama5d4_h32mx(hw);\n\tunsigned int mckr;\n\n\tregmap_read(h32mxclk->regmap, AT91_PMC_MCKR, &mckr);\n\tif (mckr & AT91_PMC_H32MXDIV)\n\t\treturn parent_rate / 2;\n\n\tif (parent_rate > H32MX_MAX_FREQ)\n\t\tpr_warn(\"H32MX clock is too fast\\n\");\n\treturn parent_rate;\n}\n\nstatic long clk_sama5d4_h32mx_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long *parent_rate)\n{\n\tunsigned long div;\n\n\tif (rate > *parent_rate)\n\t\treturn *parent_rate;\n\tdiv = *parent_rate / 2;\n\tif (rate < div)\n\t\treturn div;\n\n\tif (rate - div < *parent_rate - rate)\n\t\treturn div;\n\n\treturn *parent_rate;\n}\n\nstatic int clk_sama5d4_h32mx_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_sama5d4_h32mx *h32mxclk = to_clk_sama5d4_h32mx(hw);\n\tu32 mckr = 0;\n\n\tif (parent_rate != rate && (parent_rate / 2) != rate)\n\t\treturn -EINVAL;\n\n\tif ((parent_rate / 2) == rate)\n\t\tmckr = AT91_PMC_H32MXDIV;\n\n\tregmap_update_bits(h32mxclk->regmap, AT91_PMC_MCKR,\n\t\t\t   AT91_PMC_H32MXDIV, mckr);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops h32mx_ops = {\n\t.recalc_rate = clk_sama5d4_h32mx_recalc_rate,\n\t.round_rate = clk_sama5d4_h32mx_round_rate,\n\t.set_rate = clk_sama5d4_h32mx_set_rate,\n};\n\nstruct clk_hw * __init\nat91_clk_register_h32mx(struct regmap *regmap, const char *name,\n\t\t\tconst char *parent_name)\n{\n\tstruct clk_sama5d4_h32mx *h32mxclk;\n\tstruct clk_init_data init;\n\tint ret;\n\n\th32mxclk = kzalloc(sizeof(*h32mxclk), GFP_KERNEL);\n\tif (!h32mxclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &h32mx_ops;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\tinit.flags = CLK_SET_RATE_GATE;\n\n\th32mxclk->hw.init = &init;\n\th32mxclk->regmap = regmap;\n\n\tret = clk_hw_register(NULL, &h32mxclk->hw);\n\tif (ret) {\n\t\tkfree(h32mxclk);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn &h32mxclk->hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}