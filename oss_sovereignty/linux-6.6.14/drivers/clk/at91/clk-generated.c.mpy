{
  "module_name": "clk-generated.c",
  "hash_id": "339ed4890d4449525aeae9c026b0abb07cb16d2795975716cdb3d66ef997be40",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/clk-generated.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/of.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include \"pmc.h\"\n\n#define GENERATED_MAX_DIV\t255\n\nstruct clk_generated {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tstruct clk_range range;\n\tspinlock_t *lock;\n\tu32 *mux_table;\n\tu32 id;\n\tu32 gckdiv;\n\tconst struct clk_pcr_layout *layout;\n\tstruct at91_clk_pms pms;\n\tu8 parent_id;\n\tint chg_pid;\n};\n\n#define to_clk_generated(hw) \\\n\tcontainer_of(hw, struct clk_generated, hw)\n\nstatic int clk_generated_set(struct clk_generated *gck, int status)\n{\n\tunsigned long flags;\n\tunsigned int enable = status ? AT91_PMC_PCR_GCKEN : 0;\n\n\tspin_lock_irqsave(gck->lock, flags);\n\tregmap_write(gck->regmap, gck->layout->offset,\n\t\t     (gck->id & gck->layout->pid_mask));\n\tregmap_update_bits(gck->regmap, gck->layout->offset,\n\t\t\t   AT91_PMC_PCR_GCKDIV_MASK | gck->layout->gckcss_mask |\n\t\t\t   gck->layout->cmd | enable,\n\t\t\t   field_prep(gck->layout->gckcss_mask, gck->parent_id) |\n\t\t\t   gck->layout->cmd |\n\t\t\t   FIELD_PREP(AT91_PMC_PCR_GCKDIV_MASK, gck->gckdiv) |\n\t\t\t   enable);\n\tspin_unlock_irqrestore(gck->lock, flags);\n\n\treturn 0;\n}\n\nstatic int clk_generated_enable(struct clk_hw *hw)\n{\n\tstruct clk_generated *gck = to_clk_generated(hw);\n\n\tpr_debug(\"GCLK: %s, gckdiv = %d, parent id = %d\\n\",\n\t\t __func__, gck->gckdiv, gck->parent_id);\n\n\tclk_generated_set(gck, 1);\n\n\treturn 0;\n}\n\nstatic void clk_generated_disable(struct clk_hw *hw)\n{\n\tstruct clk_generated *gck = to_clk_generated(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(gck->lock, flags);\n\tregmap_write(gck->regmap, gck->layout->offset,\n\t\t     (gck->id & gck->layout->pid_mask));\n\tregmap_update_bits(gck->regmap, gck->layout->offset,\n\t\t\t   gck->layout->cmd | AT91_PMC_PCR_GCKEN,\n\t\t\t   gck->layout->cmd);\n\tspin_unlock_irqrestore(gck->lock, flags);\n}\n\nstatic int clk_generated_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_generated *gck = to_clk_generated(hw);\n\tunsigned long flags;\n\tunsigned int status;\n\n\tspin_lock_irqsave(gck->lock, flags);\n\tregmap_write(gck->regmap, gck->layout->offset,\n\t\t     (gck->id & gck->layout->pid_mask));\n\tregmap_read(gck->regmap, gck->layout->offset, &status);\n\tspin_unlock_irqrestore(gck->lock, flags);\n\n\treturn !!(status & AT91_PMC_PCR_GCKEN);\n}\n\nstatic unsigned long\nclk_generated_recalc_rate(struct clk_hw *hw,\n\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_generated *gck = to_clk_generated(hw);\n\n\treturn DIV_ROUND_CLOSEST(parent_rate, gck->gckdiv + 1);\n}\n\nstatic void clk_generated_best_diff(struct clk_rate_request *req,\n\t\t\t\t    struct clk_hw *parent,\n\t\t\t\t    unsigned long parent_rate, u32 div,\n\t\t\t\t    int *best_diff, long *best_rate)\n{\n\tunsigned long tmp_rate;\n\tint tmp_diff;\n\n\tif (!div)\n\t\ttmp_rate = parent_rate;\n\telse\n\t\ttmp_rate = parent_rate / div;\n\n\tif (tmp_rate < req->min_rate || tmp_rate > req->max_rate)\n\t\treturn;\n\n\ttmp_diff = abs(req->rate - tmp_rate);\n\n\tif (*best_diff < 0 || *best_diff >= tmp_diff) {\n\t\t*best_rate = tmp_rate;\n\t\t*best_diff = tmp_diff;\n\t\treq->best_parent_rate = parent_rate;\n\t\treq->best_parent_hw = parent;\n\t}\n}\n\nstatic int clk_generated_determine_rate(struct clk_hw *hw,\n\t\t\t\t\tstruct clk_rate_request *req)\n{\n\tstruct clk_generated *gck = to_clk_generated(hw);\n\tstruct clk_hw *parent = NULL;\n\tlong best_rate = -EINVAL;\n\tunsigned long min_rate, parent_rate;\n\tint best_diff = -1;\n\tint i;\n\tu32 div;\n\n\t \n\tif (gck->range.max && req->rate > gck->range.max)\n\t\treq->rate = gck->range.max;\n\tif (gck->range.min && req->rate < gck->range.min)\n\t\treq->rate = gck->range.min;\n\n\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\n\t\tif (gck->chg_pid == i)\n\t\t\tcontinue;\n\n\t\tparent = clk_hw_get_parent_by_index(hw, i);\n\t\tif (!parent)\n\t\t\tcontinue;\n\n\t\tparent_rate = clk_hw_get_rate(parent);\n\t\tmin_rate = DIV_ROUND_CLOSEST(parent_rate, GENERATED_MAX_DIV + 1);\n\t\tif (!parent_rate ||\n\t\t    (gck->range.max && min_rate > gck->range.max))\n\t\t\tcontinue;\n\n\t\tdiv = DIV_ROUND_CLOSEST(parent_rate, req->rate);\n\t\tif (div > GENERATED_MAX_DIV + 1)\n\t\t\tdiv = GENERATED_MAX_DIV + 1;\n\n\t\tclk_generated_best_diff(req, parent, parent_rate, div,\n\t\t\t\t\t&best_diff, &best_rate);\n\n\t\tif (!best_diff)\n\t\t\tbreak;\n\t}\n\n\t \n\n\tif (gck->chg_pid < 0)\n\t\tgoto end;\n\n\tparent = clk_hw_get_parent_by_index(hw, gck->chg_pid);\n\tif (!parent)\n\t\tgoto end;\n\n\tfor (div = 1; div < GENERATED_MAX_DIV + 2; div++) {\n\t\tstruct clk_rate_request req_parent;\n\n\t\tclk_hw_forward_rate_request(hw, req, parent, &req_parent, req->rate * div);\n\t\tif (__clk_determine_rate(parent, &req_parent))\n\t\t\tcontinue;\n\t\tclk_generated_best_diff(req, parent, req_parent.rate, div,\n\t\t\t\t\t&best_diff, &best_rate);\n\n\t\tif (!best_diff)\n\t\t\tbreak;\n\t}\n\nend:\n\tpr_debug(\"GCLK: %s, best_rate = %ld, parent clk: %s @ %ld\\n\",\n\t\t __func__, best_rate,\n\t\t __clk_get_name((req->best_parent_hw)->clk),\n\t\t req->best_parent_rate);\n\n\tif (best_rate < 0 || (gck->range.max && best_rate > gck->range.max))\n\t\treturn -EINVAL;\n\n\treq->rate = best_rate;\n\treturn 0;\n}\n\n \nstatic int clk_generated_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_generated *gck = to_clk_generated(hw);\n\n\tif (index >= clk_hw_get_num_parents(hw))\n\t\treturn -EINVAL;\n\n\tif (gck->mux_table)\n\t\tgck->parent_id = clk_mux_index_to_val(gck->mux_table, 0, index);\n\telse\n\t\tgck->parent_id = index;\n\n\treturn 0;\n}\n\nstatic u8 clk_generated_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_generated *gck = to_clk_generated(hw);\n\n\treturn gck->parent_id;\n}\n\n \nstatic int clk_generated_set_rate(struct clk_hw *hw,\n\t\t\t\t  unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_generated *gck = to_clk_generated(hw);\n\tu32 div;\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\tif (gck->range.max && rate > gck->range.max)\n\t\treturn -EINVAL;\n\n\tdiv = DIV_ROUND_CLOSEST(parent_rate, rate);\n\tif (div > GENERATED_MAX_DIV + 1 || !div)\n\t\treturn -EINVAL;\n\n\tgck->gckdiv = div - 1;\n\treturn 0;\n}\n\nstatic int clk_generated_save_context(struct clk_hw *hw)\n{\n\tstruct clk_generated *gck = to_clk_generated(hw);\n\n\tgck->pms.status = clk_generated_is_enabled(&gck->hw);\n\n\treturn 0;\n}\n\nstatic void clk_generated_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_generated *gck = to_clk_generated(hw);\n\n\tif (gck->pms.status)\n\t\tclk_generated_set(gck, gck->pms.status);\n}\n\nstatic const struct clk_ops generated_ops = {\n\t.enable = clk_generated_enable,\n\t.disable = clk_generated_disable,\n\t.is_enabled = clk_generated_is_enabled,\n\t.recalc_rate = clk_generated_recalc_rate,\n\t.determine_rate = clk_generated_determine_rate,\n\t.get_parent = clk_generated_get_parent,\n\t.set_parent = clk_generated_set_parent,\n\t.set_rate = clk_generated_set_rate,\n\t.save_context = clk_generated_save_context,\n\t.restore_context = clk_generated_restore_context,\n};\n\n \nstatic void clk_generated_startup(struct clk_generated *gck)\n{\n\tu32 tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(gck->lock, flags);\n\tregmap_write(gck->regmap, gck->layout->offset,\n\t\t     (gck->id & gck->layout->pid_mask));\n\tregmap_read(gck->regmap, gck->layout->offset, &tmp);\n\tspin_unlock_irqrestore(gck->lock, flags);\n\n\tgck->parent_id = field_get(gck->layout->gckcss_mask, tmp);\n\tgck->gckdiv = FIELD_GET(AT91_PMC_PCR_GCKDIV_MASK, tmp);\n}\n\nstruct clk_hw * __init\nat91_clk_register_generated(struct regmap *regmap, spinlock_t *lock,\n\t\t\t    const struct clk_pcr_layout *layout,\n\t\t\t    const char *name, const char **parent_names,\n\t\t\t    struct clk_hw **parent_hws,\n\t\t\t    u32 *mux_table, u8 num_parents, u8 id,\n\t\t\t    const struct clk_range *range,\n\t\t\t    int chg_pid)\n{\n\tstruct clk_generated *gck;\n\tstruct clk_init_data init = {};\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tif (!(parent_names || parent_hws))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgck = kzalloc(sizeof(*gck), GFP_KERNEL);\n\tif (!gck)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &generated_ops;\n\tif (parent_hws)\n\t\tinit.parent_hws = (const struct clk_hw **)parent_hws;\n\telse\n\t\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\tinit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\n\tif (chg_pid >= 0)\n\t\tinit.flags |= CLK_SET_RATE_PARENT;\n\n\tgck->id = id;\n\tgck->hw.init = &init;\n\tgck->regmap = regmap;\n\tgck->lock = lock;\n\tgck->range = *range;\n\tgck->chg_pid = chg_pid;\n\tgck->layout = layout;\n\tgck->mux_table = mux_table;\n\n\tclk_generated_startup(gck);\n\thw = &gck->hw;\n\tret = clk_hw_register(NULL, &gck->hw);\n\tif (ret) {\n\t\tkfree(gck);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}