{
  "module_name": "pmc.c",
  "hash_id": "f9ff9234228984fb1704da3da97ddcf403869a0bdd556265a6eb2497a94ff84a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/pmc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/syscore_ops.h>\n\n#include <asm/proc-fns.h>\n\n#include \"pmc.h\"\n\n#define PMC_MAX_IDS 128\n#define PMC_MAX_PCKS 8\n\nint of_at91_get_clk_range(struct device_node *np, const char *propname,\n\t\t\t  struct clk_range *range)\n{\n\tu32 min, max;\n\tint ret;\n\n\tret = of_property_read_u32_index(np, propname, 0, &min);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_property_read_u32_index(np, propname, 1, &max);\n\tif (ret)\n\t\treturn ret;\n\n\tif (range) {\n\t\trange->min = min;\n\t\trange->max = max;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_at91_get_clk_range);\n\nstruct clk_hw *of_clk_hw_pmc_get(struct of_phandle_args *clkspec, void *data)\n{\n\tunsigned int type = clkspec->args[0];\n\tunsigned int idx = clkspec->args[1];\n\tstruct pmc_data *pmc_data = data;\n\n\tswitch (type) {\n\tcase PMC_TYPE_CORE:\n\t\tif (idx < pmc_data->ncore)\n\t\t\treturn pmc_data->chws[idx];\n\t\tbreak;\n\tcase PMC_TYPE_SYSTEM:\n\t\tif (idx < pmc_data->nsystem)\n\t\t\treturn pmc_data->shws[idx];\n\t\tbreak;\n\tcase PMC_TYPE_PERIPHERAL:\n\t\tif (idx < pmc_data->nperiph)\n\t\t\treturn pmc_data->phws[idx];\n\t\tbreak;\n\tcase PMC_TYPE_GCK:\n\t\tif (idx < pmc_data->ngck)\n\t\t\treturn pmc_data->ghws[idx];\n\t\tbreak;\n\tcase PMC_TYPE_PROGRAMMABLE:\n\t\tif (idx < pmc_data->npck)\n\t\t\treturn pmc_data->pchws[idx];\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpr_err(\"%s: invalid type (%u) or index (%u)\\n\", __func__, type, idx);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstruct pmc_data *pmc_data_allocate(unsigned int ncore, unsigned int nsystem,\n\t\t\t\t   unsigned int nperiph, unsigned int ngck,\n\t\t\t\t   unsigned int npck)\n{\n\tunsigned int num_clks = ncore + nsystem + nperiph + ngck + npck;\n\tstruct pmc_data *pmc_data;\n\n\tpmc_data = kzalloc(struct_size(pmc_data, hwtable, num_clks),\n\t\t\t   GFP_KERNEL);\n\tif (!pmc_data)\n\t\treturn NULL;\n\n\tpmc_data->ncore = ncore;\n\tpmc_data->chws = pmc_data->hwtable;\n\n\tpmc_data->nsystem = nsystem;\n\tpmc_data->shws = pmc_data->chws + ncore;\n\n\tpmc_data->nperiph = nperiph;\n\tpmc_data->phws = pmc_data->shws + nsystem;\n\n\tpmc_data->ngck = ngck;\n\tpmc_data->ghws = pmc_data->phws + nperiph;\n\n\tpmc_data->npck = npck;\n\tpmc_data->pchws = pmc_data->ghws + ngck;\n\n\treturn pmc_data;\n}\n\n#ifdef CONFIG_PM\n\n \nstatic void __iomem *at91_pmc_backup_suspend;\n\nstatic int at91_pmc_suspend(void)\n{\n\tunsigned int backup;\n\n\tif (!at91_pmc_backup_suspend)\n\t\treturn 0;\n\n\tbackup = readl_relaxed(at91_pmc_backup_suspend);\n\tif (!backup)\n\t\treturn 0;\n\n\treturn clk_save_context();\n}\n\nstatic void at91_pmc_resume(void)\n{\n\tunsigned int backup;\n\n\tif (!at91_pmc_backup_suspend)\n\t\treturn;\n\n\tbackup = readl_relaxed(at91_pmc_backup_suspend);\n\tif (!backup)\n\t\treturn;\n\n\tclk_restore_context();\n}\n\nstatic struct syscore_ops pmc_syscore_ops = {\n\t.suspend = at91_pmc_suspend,\n\t.resume = at91_pmc_resume,\n};\n\nstatic const struct of_device_id pmc_dt_ids[] = {\n\t{ .compatible = \"atmel,sama5d2-pmc\" },\n\t{ .compatible = \"microchip,sama7g5-pmc\", },\n\t{   }\n};\n\nstatic int __init pmc_register_ops(void)\n{\n\tstruct device_node *np;\n\n\tnp = of_find_matching_node(NULL, pmc_dt_ids);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tif (!of_device_is_available(np)) {\n\t\tof_node_put(np);\n\t\treturn -ENODEV;\n\t}\n\tof_node_put(np);\n\n\tnp = of_find_compatible_node(NULL, NULL, \"atmel,sama5d2-securam\");\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tif (!of_device_is_available(np)) {\n\t\tof_node_put(np);\n\t\treturn -ENODEV;\n\t}\n\tof_node_put(np);\n\n\tat91_pmc_backup_suspend = of_iomap(np, 0);\n\tif (!at91_pmc_backup_suspend) {\n\t\tpr_warn(\"%s(): unable to map securam\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tregister_syscore_ops(&pmc_syscore_ops);\n\n\treturn 0;\n}\n \npostcore_initcall(pmc_register_ops);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}