{
  "module_name": "clk-pll.c",
  "hash_id": "e6dbe4188716e29b50bdeee58babb35b43fecbf3fe4bb2dee1c738ac596a7370",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/clk-pll.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/of.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include \"pmc.h\"\n\n#define PLL_STATUS_MASK(id)\t(1 << (1 + (id)))\n#define PLL_REG(id)\t\t(AT91_CKGR_PLLAR + ((id) * 4))\n#define PLL_DIV_MASK\t\t0xff\n#define PLL_DIV_MAX\t\tPLL_DIV_MASK\n#define PLL_DIV(reg)\t\t((reg) & PLL_DIV_MASK)\n#define PLL_MUL(reg, layout)\t(((reg) >> (layout)->mul_shift) & \\\n\t\t\t\t (layout)->mul_mask)\n#define PLL_MUL_MIN\t\t2\n#define PLL_MUL_MASK(layout)\t((layout)->mul_mask)\n#define PLL_MUL_MAX(layout)\t(PLL_MUL_MASK(layout) + 1)\n#define PLL_ICPR_SHIFT(id)\t((id) * 16)\n#define PLL_ICPR_MASK(id)\t(0xffff << PLL_ICPR_SHIFT(id))\n#define PLL_MAX_COUNT\t\t0x3f\n#define PLL_COUNT_SHIFT\t\t8\n#define PLL_OUT_SHIFT\t\t14\n#define PLL_MAX_ID\t\t1\n\n#define to_clk_pll(hw) container_of(hw, struct clk_pll, hw)\n\nstruct clk_pll {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tu8 id;\n\tu8 div;\n\tu8 range;\n\tu16 mul;\n\tconst struct clk_pll_layout *layout;\n\tconst struct clk_pll_characteristics *characteristics;\n\tstruct at91_clk_pms pms;\n};\n\nstatic inline bool clk_pll_ready(struct regmap *regmap, int id)\n{\n\tunsigned int status;\n\n\tregmap_read(regmap, AT91_PMC_SR, &status);\n\n\treturn status & PLL_STATUS_MASK(id) ? 1 : 0;\n}\n\nstatic int clk_pll_prepare(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tstruct regmap *regmap = pll->regmap;\n\tconst struct clk_pll_layout *layout = pll->layout;\n\tconst struct clk_pll_characteristics *characteristics =\n\t\t\t\t\t\t\tpll->characteristics;\n\tu8 id = pll->id;\n\tu32 mask = PLL_STATUS_MASK(id);\n\tint offset = PLL_REG(id);\n\tu8 out = 0;\n\tunsigned int pllr;\n\tunsigned int status;\n\tu8 div;\n\tu16 mul;\n\n\tregmap_read(regmap, offset, &pllr);\n\tdiv = PLL_DIV(pllr);\n\tmul = PLL_MUL(pllr, layout);\n\n\tregmap_read(regmap, AT91_PMC_SR, &status);\n\tif ((status & mask) &&\n\t    (div == pll->div && mul == pll->mul))\n\t\treturn 0;\n\n\tif (characteristics->out)\n\t\tout = characteristics->out[pll->range];\n\n\tif (characteristics->icpll)\n\t\tregmap_update_bits(regmap, AT91_PMC_PLLICPR, PLL_ICPR_MASK(id),\n\t\t\tcharacteristics->icpll[pll->range] << PLL_ICPR_SHIFT(id));\n\n\tregmap_update_bits(regmap, offset, layout->pllr_mask,\n\t\t\tpll->div | (PLL_MAX_COUNT << PLL_COUNT_SHIFT) |\n\t\t\t(out << PLL_OUT_SHIFT) |\n\t\t\t((pll->mul & layout->mul_mask) << layout->mul_shift));\n\n\twhile (!clk_pll_ready(regmap, pll->id))\n\t\tcpu_relax();\n\n\treturn 0;\n}\n\nstatic int clk_pll_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\n\treturn clk_pll_ready(pll->regmap, pll->id);\n}\n\nstatic void clk_pll_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tunsigned int mask = pll->layout->pllr_mask;\n\n\tregmap_update_bits(pll->regmap, PLL_REG(pll->id), mask, ~mask);\n}\n\nstatic unsigned long clk_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\n\tif (!pll->div || !pll->mul)\n\t\treturn 0;\n\n\treturn (parent_rate / pll->div) * (pll->mul + 1);\n}\n\nstatic long clk_pll_get_best_div_mul(struct clk_pll *pll, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate,\n\t\t\t\t     u32 *div, u32 *mul,\n\t\t\t\t     u32 *index) {\n\tconst struct clk_pll_layout *layout = pll->layout;\n\tconst struct clk_pll_characteristics *characteristics =\n\t\t\t\t\t\t\tpll->characteristics;\n\tunsigned long bestremainder = ULONG_MAX;\n\tunsigned long maxdiv, mindiv, tmpdiv;\n\tlong bestrate = -ERANGE;\n\tunsigned long bestdiv;\n\tunsigned long bestmul;\n\tint i = 0;\n\n\t \n\tif (parent_rate < characteristics->input.min)\n\t\treturn -ERANGE;\n\n\t \n\tmindiv = (parent_rate * PLL_MUL_MIN) / rate;\n\tif (!mindiv)\n\t\tmindiv = 1;\n\n\tif (parent_rate > characteristics->input.max) {\n\t\ttmpdiv = DIV_ROUND_UP(parent_rate, characteristics->input.max);\n\t\tif (tmpdiv > PLL_DIV_MAX)\n\t\t\treturn -ERANGE;\n\n\t\tif (tmpdiv > mindiv)\n\t\t\tmindiv = tmpdiv;\n\t}\n\n\t \n\tmaxdiv = DIV_ROUND_UP(parent_rate * PLL_MUL_MAX(layout), rate);\n\tif (maxdiv > PLL_DIV_MAX)\n\t\tmaxdiv = PLL_DIV_MAX;\n\n\t \n\tfor (tmpdiv = mindiv; tmpdiv <= maxdiv; tmpdiv++) {\n\t\tunsigned long remainder;\n\t\tunsigned long tmprate;\n\t\tunsigned long tmpmul;\n\n\t\t \n\t\ttmpmul = DIV_ROUND_CLOSEST(rate, parent_rate / tmpdiv);\n\t\ttmprate = (parent_rate / tmpdiv) * tmpmul;\n\t\tif (tmprate > rate)\n\t\t\tremainder = tmprate - rate;\n\t\telse\n\t\t\tremainder = rate - tmprate;\n\n\t\t \n\t\tif (remainder < bestremainder) {\n\t\t\tbestremainder = remainder;\n\t\t\tbestdiv = tmpdiv;\n\t\t\tbestmul = tmpmul;\n\t\t\tbestrate = tmprate;\n\t\t}\n\n\t\t \n\t\tif (!remainder)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (bestrate < 0)\n\t\treturn bestrate;\n\n\t \n\tfor (i = 0; i < characteristics->num_output; i++) {\n\t\tif (bestrate >= characteristics->output[i].min &&\n\t\t    bestrate <= characteristics->output[i].max)\n\t\t\tbreak;\n\t}\n\n\tif (i >= characteristics->num_output)\n\t\treturn -ERANGE;\n\n\tif (div)\n\t\t*div = bestdiv;\n\tif (mul)\n\t\t*mul = bestmul - 1;\n\tif (index)\n\t\t*index = i;\n\n\treturn bestrate;\n}\n\nstatic long clk_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\tunsigned long *parent_rate)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\n\treturn clk_pll_get_best_div_mul(pll, rate, *parent_rate,\n\t\t\t\t\tNULL, NULL, NULL);\n}\n\nstatic int clk_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tlong ret;\n\tu32 div;\n\tu32 mul;\n\tu32 index;\n\n\tret = clk_pll_get_best_div_mul(pll, rate, parent_rate,\n\t\t\t\t       &div, &mul, &index);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpll->range = index;\n\tpll->div = div;\n\tpll->mul = mul;\n\n\treturn 0;\n}\n\nstatic int clk_pll_save_context(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tstruct clk_hw *parent_hw = clk_hw_get_parent(hw);\n\n\tpll->pms.parent_rate = clk_hw_get_rate(parent_hw);\n\tpll->pms.rate = clk_pll_recalc_rate(&pll->hw, pll->pms.parent_rate);\n\tpll->pms.status = clk_pll_ready(pll->regmap, PLL_REG(pll->id));\n\n\treturn 0;\n}\n\nstatic void clk_pll_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tunsigned long calc_rate;\n\tunsigned int pllr, pllr_out, pllr_count;\n\tu8 out = 0;\n\n\tif (pll->characteristics->out)\n\t\tout = pll->characteristics->out[pll->range];\n\n\tregmap_read(pll->regmap, PLL_REG(pll->id), &pllr);\n\n\tcalc_rate = (pll->pms.parent_rate / PLL_DIV(pllr)) *\n\t\t     (PLL_MUL(pllr, pll->layout) + 1);\n\tpllr_count = (pllr >> PLL_COUNT_SHIFT) & PLL_MAX_COUNT;\n\tpllr_out = (pllr >> PLL_OUT_SHIFT) & out;\n\n\tif (pll->pms.rate != calc_rate ||\n\t    pll->pms.status != clk_pll_ready(pll->regmap, PLL_REG(pll->id)) ||\n\t    pllr_count != PLL_MAX_COUNT ||\n\t    (out && pllr_out != out))\n\t\tpr_warn(\"PLLAR was not configured properly by firmware\\n\");\n}\n\nstatic const struct clk_ops pll_ops = {\n\t.prepare = clk_pll_prepare,\n\t.unprepare = clk_pll_unprepare,\n\t.is_prepared = clk_pll_is_prepared,\n\t.recalc_rate = clk_pll_recalc_rate,\n\t.round_rate = clk_pll_round_rate,\n\t.set_rate = clk_pll_set_rate,\n\t.save_context = clk_pll_save_context,\n\t.restore_context = clk_pll_restore_context,\n};\n\nstruct clk_hw * __init\nat91_clk_register_pll(struct regmap *regmap, const char *name,\n\t\t      const char *parent_name, u8 id,\n\t\t      const struct clk_pll_layout *layout,\n\t\t      const struct clk_pll_characteristics *characteristics)\n{\n\tstruct clk_pll *pll;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint offset = PLL_REG(id);\n\tunsigned int pllr;\n\tint ret;\n\n\tif (id > PLL_MAX_ID)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &pll_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = CLK_SET_RATE_GATE;\n\n\tpll->id = id;\n\tpll->hw.init = &init;\n\tpll->layout = layout;\n\tpll->characteristics = characteristics;\n\tpll->regmap = regmap;\n\tregmap_read(regmap, offset, &pllr);\n\tpll->div = PLL_DIV(pllr);\n\tpll->mul = PLL_MUL(pllr, layout);\n\n\thw = &pll->hw;\n\tret = clk_hw_register(NULL, &pll->hw);\n\tif (ret) {\n\t\tkfree(pll);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\n\nconst struct clk_pll_layout at91rm9200_pll_layout = {\n\t.pllr_mask = 0x7FFFFFF,\n\t.mul_shift = 16,\n\t.mul_mask = 0x7FF,\n};\n\nconst struct clk_pll_layout at91sam9g45_pll_layout = {\n\t.pllr_mask = 0xFFFFFF,\n\t.mul_shift = 16,\n\t.mul_mask = 0xFF,\n};\n\nconst struct clk_pll_layout at91sam9g20_pllb_layout = {\n\t.pllr_mask = 0x3FFFFF,\n\t.mul_shift = 16,\n\t.mul_mask = 0x3F,\n};\n\nconst struct clk_pll_layout sama5d3_pll_layout = {\n\t.pllr_mask = 0x1FFFFFF,\n\t.mul_shift = 18,\n\t.mul_mask = 0x7F,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}