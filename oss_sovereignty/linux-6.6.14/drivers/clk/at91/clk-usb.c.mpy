{
  "module_name": "clk-usb.c",
  "hash_id": "2eaa5fedfa4b719aae3f82cc538987cfadc2027b6a5a33192aecb7505145f04c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/clk-usb.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/of.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include \"pmc.h\"\n\n#define SAM9X5_USB_DIV_SHIFT\t8\n#define SAM9X5_USB_MAX_DIV\t0xf\n\n#define RM9200_USB_DIV_SHIFT\t28\n#define RM9200_USB_DIV_TAB_SIZE\t4\n\n#define SAM9X5_USBS_MASK\tGENMASK(0, 0)\n#define SAM9X60_USBS_MASK\tGENMASK(1, 0)\n\nstruct at91sam9x5_clk_usb {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tstruct at91_clk_pms pms;\n\tu32 usbs_mask;\n\tu8 num_parents;\n};\n\n#define to_at91sam9x5_clk_usb(hw) \\\n\tcontainer_of(hw, struct at91sam9x5_clk_usb, hw)\n\nstruct at91rm9200_clk_usb {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tu32 divisors[4];\n};\n\n#define to_at91rm9200_clk_usb(hw) \\\n\tcontainer_of(hw, struct at91rm9200_clk_usb, hw)\n\nstatic unsigned long at91sam9x5_clk_usb_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\n\tunsigned int usbr;\n\tu8 usbdiv;\n\n\tregmap_read(usb->regmap, AT91_PMC_USB, &usbr);\n\tusbdiv = (usbr & AT91_PMC_OHCIUSBDIV) >> SAM9X5_USB_DIV_SHIFT;\n\n\treturn DIV_ROUND_CLOSEST(parent_rate, (usbdiv + 1));\n}\n\nstatic int at91sam9x5_clk_usb_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t     struct clk_rate_request *req)\n{\n\tstruct clk_hw *parent;\n\tlong best_rate = -EINVAL;\n\tunsigned long tmp_rate;\n\tint best_diff = -1;\n\tint tmp_diff;\n\tint i;\n\n\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\n\t\tint div;\n\n\t\tparent = clk_hw_get_parent_by_index(hw, i);\n\t\tif (!parent)\n\t\t\tcontinue;\n\n\t\tfor (div = 1; div < SAM9X5_USB_MAX_DIV + 2; div++) {\n\t\t\tunsigned long tmp_parent_rate;\n\n\t\t\ttmp_parent_rate = req->rate * div;\n\t\t\ttmp_parent_rate = clk_hw_round_rate(parent,\n\t\t\t\t\t\t\t   tmp_parent_rate);\n\t\t\tif (!tmp_parent_rate)\n\t\t\t\tcontinue;\n\n\t\t\ttmp_rate = DIV_ROUND_CLOSEST(tmp_parent_rate, div);\n\t\t\tif (tmp_rate < req->rate)\n\t\t\t\ttmp_diff = req->rate - tmp_rate;\n\t\t\telse\n\t\t\t\ttmp_diff = tmp_rate - req->rate;\n\n\t\t\tif (best_diff < 0 || best_diff > tmp_diff) {\n\t\t\t\tbest_rate = tmp_rate;\n\t\t\t\tbest_diff = tmp_diff;\n\t\t\t\treq->best_parent_rate = tmp_parent_rate;\n\t\t\t\treq->best_parent_hw = parent;\n\t\t\t}\n\n\t\t\tif (!best_diff || tmp_rate < req->rate)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!best_diff)\n\t\t\tbreak;\n\t}\n\n\tif (best_rate < 0)\n\t\treturn best_rate;\n\n\treq->rate = best_rate;\n\treturn 0;\n}\n\nstatic int at91sam9x5_clk_usb_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\n\n\tif (index >= usb->num_parents)\n\t\treturn -EINVAL;\n\n\tregmap_update_bits(usb->regmap, AT91_PMC_USB, usb->usbs_mask, index);\n\n\treturn 0;\n}\n\nstatic u8 at91sam9x5_clk_usb_get_parent(struct clk_hw *hw)\n{\n\tstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\n\tunsigned int usbr;\n\n\tregmap_read(usb->regmap, AT91_PMC_USB, &usbr);\n\n\treturn usbr & usb->usbs_mask;\n}\n\nstatic int at91sam9x5_clk_usb_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\n\tunsigned long div;\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\tdiv = DIV_ROUND_CLOSEST(parent_rate, rate);\n\tif (div > SAM9X5_USB_MAX_DIV + 1 || !div)\n\t\treturn -EINVAL;\n\n\tregmap_update_bits(usb->regmap, AT91_PMC_USB, AT91_PMC_OHCIUSBDIV,\n\t\t\t   (div - 1) << SAM9X5_USB_DIV_SHIFT);\n\n\treturn 0;\n}\n\nstatic int at91sam9x5_usb_save_context(struct clk_hw *hw)\n{\n\tstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\n\tstruct clk_hw *parent_hw = clk_hw_get_parent(hw);\n\n\tusb->pms.parent = at91sam9x5_clk_usb_get_parent(hw);\n\tusb->pms.parent_rate = clk_hw_get_rate(parent_hw);\n\tusb->pms.rate = at91sam9x5_clk_usb_recalc_rate(hw, usb->pms.parent_rate);\n\n\treturn 0;\n}\n\nstatic void at91sam9x5_usb_restore_context(struct clk_hw *hw)\n{\n\tstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\n\tint ret;\n\n\tret = at91sam9x5_clk_usb_set_parent(hw, usb->pms.parent);\n\tif (ret)\n\t\treturn;\n\n\tat91sam9x5_clk_usb_set_rate(hw, usb->pms.rate, usb->pms.parent_rate);\n}\n\nstatic const struct clk_ops at91sam9x5_usb_ops = {\n\t.recalc_rate = at91sam9x5_clk_usb_recalc_rate,\n\t.determine_rate = at91sam9x5_clk_usb_determine_rate,\n\t.get_parent = at91sam9x5_clk_usb_get_parent,\n\t.set_parent = at91sam9x5_clk_usb_set_parent,\n\t.set_rate = at91sam9x5_clk_usb_set_rate,\n\t.save_context = at91sam9x5_usb_save_context,\n\t.restore_context = at91sam9x5_usb_restore_context,\n};\n\nstatic int at91sam9n12_clk_usb_enable(struct clk_hw *hw)\n{\n\tstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\n\n\tregmap_update_bits(usb->regmap, AT91_PMC_USB, AT91_PMC_USBS,\n\t\t\t   AT91_PMC_USBS);\n\n\treturn 0;\n}\n\nstatic void at91sam9n12_clk_usb_disable(struct clk_hw *hw)\n{\n\tstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\n\n\tregmap_update_bits(usb->regmap, AT91_PMC_USB, AT91_PMC_USBS, 0);\n}\n\nstatic int at91sam9n12_clk_usb_is_enabled(struct clk_hw *hw)\n{\n\tstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\n\tunsigned int usbr;\n\n\tregmap_read(usb->regmap, AT91_PMC_USB, &usbr);\n\n\treturn usbr & AT91_PMC_USBS;\n}\n\nstatic const struct clk_ops at91sam9n12_usb_ops = {\n\t.enable = at91sam9n12_clk_usb_enable,\n\t.disable = at91sam9n12_clk_usb_disable,\n\t.is_enabled = at91sam9n12_clk_usb_is_enabled,\n\t.recalc_rate = at91sam9x5_clk_usb_recalc_rate,\n\t.determine_rate = at91sam9x5_clk_usb_determine_rate,\n\t.set_rate = at91sam9x5_clk_usb_set_rate,\n};\n\nstatic struct clk_hw * __init\n_at91sam9x5_clk_register_usb(struct regmap *regmap, const char *name,\n\t\t\t     const char **parent_names, u8 num_parents,\n\t\t\t     u32 usbs_mask)\n{\n\tstruct at91sam9x5_clk_usb *usb;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tusb = kzalloc(sizeof(*usb), GFP_KERNEL);\n\tif (!usb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &at91sam9x5_usb_ops;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\tinit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE |\n\t\t     CLK_SET_RATE_PARENT;\n\n\tusb->hw.init = &init;\n\tusb->regmap = regmap;\n\tusb->usbs_mask = usbs_mask;\n\tusb->num_parents = num_parents;\n\n\thw = &usb->hw;\n\tret = clk_hw_register(NULL, &usb->hw);\n\tif (ret) {\n\t\tkfree(usb);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstruct clk_hw * __init\nat91sam9x5_clk_register_usb(struct regmap *regmap, const char *name,\n\t\t\t    const char **parent_names, u8 num_parents)\n{\n\treturn _at91sam9x5_clk_register_usb(regmap, name, parent_names,\n\t\t\t\t\t    num_parents, SAM9X5_USBS_MASK);\n}\n\nstruct clk_hw * __init\nsam9x60_clk_register_usb(struct regmap *regmap, const char *name,\n\t\t\t const char **parent_names, u8 num_parents)\n{\n\treturn _at91sam9x5_clk_register_usb(regmap, name, parent_names,\n\t\t\t\t\t    num_parents, SAM9X60_USBS_MASK);\n}\n\nstruct clk_hw * __init\nat91sam9n12_clk_register_usb(struct regmap *regmap, const char *name,\n\t\t\t     const char *parent_name)\n{\n\tstruct at91sam9x5_clk_usb *usb;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tusb = kzalloc(sizeof(*usb), GFP_KERNEL);\n\tif (!usb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &at91sam9n12_usb_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = CLK_SET_RATE_GATE | CLK_SET_RATE_PARENT;\n\n\tusb->hw.init = &init;\n\tusb->regmap = regmap;\n\n\thw = &usb->hw;\n\tret = clk_hw_register(NULL, &usb->hw);\n\tif (ret) {\n\t\tkfree(usb);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstatic unsigned long at91rm9200_clk_usb_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct at91rm9200_clk_usb *usb = to_at91rm9200_clk_usb(hw);\n\tunsigned int pllbr;\n\tu8 usbdiv;\n\n\tregmap_read(usb->regmap, AT91_CKGR_PLLBR, &pllbr);\n\n\tusbdiv = (pllbr & AT91_PMC_USBDIV) >> RM9200_USB_DIV_SHIFT;\n\tif (usb->divisors[usbdiv])\n\t\treturn parent_rate / usb->divisors[usbdiv];\n\n\treturn 0;\n}\n\nstatic long at91rm9200_clk_usb_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t  unsigned long *parent_rate)\n{\n\tstruct at91rm9200_clk_usb *usb = to_at91rm9200_clk_usb(hw);\n\tstruct clk_hw *parent = clk_hw_get_parent(hw);\n\tunsigned long bestrate = 0;\n\tint bestdiff = -1;\n\tunsigned long tmprate;\n\tint tmpdiff;\n\tint i = 0;\n\n\tfor (i = 0; i < RM9200_USB_DIV_TAB_SIZE; i++) {\n\t\tunsigned long tmp_parent_rate;\n\n\t\tif (!usb->divisors[i])\n\t\t\tcontinue;\n\n\t\ttmp_parent_rate = rate * usb->divisors[i];\n\t\ttmp_parent_rate = clk_hw_round_rate(parent, tmp_parent_rate);\n\t\ttmprate = DIV_ROUND_CLOSEST(tmp_parent_rate, usb->divisors[i]);\n\t\tif (tmprate < rate)\n\t\t\ttmpdiff = rate - tmprate;\n\t\telse\n\t\t\ttmpdiff = tmprate - rate;\n\n\t\tif (bestdiff < 0 || bestdiff > tmpdiff) {\n\t\t\tbestrate = tmprate;\n\t\t\tbestdiff = tmpdiff;\n\t\t\t*parent_rate = tmp_parent_rate;\n\t\t}\n\n\t\tif (!bestdiff)\n\t\t\tbreak;\n\t}\n\n\treturn bestrate;\n}\n\nstatic int at91rm9200_clk_usb_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long parent_rate)\n{\n\tint i;\n\tstruct at91rm9200_clk_usb *usb = to_at91rm9200_clk_usb(hw);\n\tunsigned long div;\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\tdiv = DIV_ROUND_CLOSEST(parent_rate, rate);\n\n\tfor (i = 0; i < RM9200_USB_DIV_TAB_SIZE; i++) {\n\t\tif (usb->divisors[i] == div) {\n\t\t\tregmap_update_bits(usb->regmap, AT91_CKGR_PLLBR,\n\t\t\t\t\t   AT91_PMC_USBDIV,\n\t\t\t\t\t   i << RM9200_USB_DIV_SHIFT);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct clk_ops at91rm9200_usb_ops = {\n\t.recalc_rate = at91rm9200_clk_usb_recalc_rate,\n\t.round_rate = at91rm9200_clk_usb_round_rate,\n\t.set_rate = at91rm9200_clk_usb_set_rate,\n};\n\nstruct clk_hw * __init\nat91rm9200_clk_register_usb(struct regmap *regmap, const char *name,\n\t\t\t    const char *parent_name, const u32 *divisors)\n{\n\tstruct at91rm9200_clk_usb *usb;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tusb = kzalloc(sizeof(*usb), GFP_KERNEL);\n\tif (!usb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &at91rm9200_usb_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\n\tusb->hw.init = &init;\n\tusb->regmap = regmap;\n\tmemcpy(usb->divisors, divisors, sizeof(usb->divisors));\n\n\thw = &usb->hw;\n\tret = clk_hw_register(NULL, &usb->hw);\n\tif (ret) {\n\t\tkfree(usb);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}