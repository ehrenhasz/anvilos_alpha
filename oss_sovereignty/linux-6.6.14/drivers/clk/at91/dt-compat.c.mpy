{
  "module_name": "dt-compat.c",
  "hash_id": "a79842f1d008055a15fe4e785b42bb57baf66c69dfe8730ab5605de079ea4092",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/dt-compat.c",
  "human_readable_source": "\n#include <linux/clk-provider.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/of.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"pmc.h\"\n\n#define MASTER_SOURCE_MAX\t4\n\n#define PERIPHERAL_AT91RM9200\t0\n#define PERIPHERAL_AT91SAM9X5\t1\n\n#define PERIPHERAL_MAX\t\t64\n\n#define PERIPHERAL_ID_MIN\t2\n\n#define PROG_SOURCE_MAX\t\t5\n#define PROG_ID_MAX\t\t7\n\n#define SYSTEM_MAX_ID\t\t31\n\n#define GCK_INDEX_DT_AUDIO_PLL\t5\n\nstatic DEFINE_SPINLOCK(mck_lock);\n\n#ifdef CONFIG_HAVE_AT91_AUDIO_PLL\nstatic void __init of_sama5d2_clk_audio_pll_frac_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *name = np->name;\n\tconst char *parent_name;\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\n\thw = at91_clk_register_audio_pll_frac(regmap, name, parent_name);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(of_sama5d2_clk_audio_pll_frac_setup,\n\t       \"atmel,sama5d2-clk-audio-pll-frac\",\n\t       of_sama5d2_clk_audio_pll_frac_setup);\n\nstatic void __init of_sama5d2_clk_audio_pll_pad_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *name = np->name;\n\tconst char *parent_name;\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\n\thw = at91_clk_register_audio_pll_pad(regmap, name, parent_name);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(of_sama5d2_clk_audio_pll_pad_setup,\n\t       \"atmel,sama5d2-clk-audio-pll-pad\",\n\t       of_sama5d2_clk_audio_pll_pad_setup);\n\nstatic void __init of_sama5d2_clk_audio_pll_pmc_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *name = np->name;\n\tconst char *parent_name;\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\n\thw = at91_clk_register_audio_pll_pmc(regmap, name, parent_name);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(of_sama5d2_clk_audio_pll_pmc_setup,\n\t       \"atmel,sama5d2-clk-audio-pll-pmc\",\n\t       of_sama5d2_clk_audio_pll_pmc_setup);\n#endif  \n\nstatic const struct clk_pcr_layout dt_pcr_layout = {\n\t.offset = 0x10c,\n\t.cmd = BIT(12),\n\t.pid_mask = GENMASK(5, 0),\n\t.div_mask = GENMASK(17, 16),\n\t.gckcss_mask = GENMASK(10, 8),\n};\n\n#ifdef CONFIG_HAVE_AT91_GENERATED_CLK\n#define GENERATED_SOURCE_MAX\t6\n\n#define GCK_ID_I2S0\t\t54\n#define GCK_ID_I2S1\t\t55\n#define GCK_ID_CLASSD\t\t59\n\nstatic void __init of_sama5d2_clk_generated_setup(struct device_node *np)\n{\n\tint num;\n\tu32 id;\n\tconst char *name;\n\tstruct clk_hw *hw;\n\tunsigned int num_parents;\n\tconst char *parent_names[GENERATED_SOURCE_MAX];\n\tstruct device_node *gcknp, *parent_np;\n\tstruct clk_range range = CLK_RANGE(0, 0);\n\tstruct regmap *regmap;\n\n\tnum_parents = of_clk_get_parent_count(np);\n\tif (num_parents == 0 || num_parents > GENERATED_SOURCE_MAX)\n\t\treturn;\n\n\tof_clk_parent_fill(np, parent_names, num_parents);\n\n\tnum = of_get_child_count(np);\n\tif (!num || num > PERIPHERAL_MAX)\n\t\treturn;\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\tfor_each_child_of_node(np, gcknp) {\n\t\tint chg_pid = INT_MIN;\n\n\t\tif (of_property_read_u32(gcknp, \"reg\", &id))\n\t\t\tcontinue;\n\n\t\tif (id < PERIPHERAL_ID_MIN || id >= PERIPHERAL_MAX)\n\t\t\tcontinue;\n\n\t\tif (of_property_read_string(np, \"clock-output-names\", &name))\n\t\t\tname = gcknp->name;\n\n\t\tof_at91_get_clk_range(gcknp, \"atmel,clk-output-range\",\n\t\t\t\t      &range);\n\n\t\tif (of_device_is_compatible(np, \"atmel,sama5d2-clk-generated\") &&\n\t\t    (id == GCK_ID_I2S0 || id == GCK_ID_I2S1 ||\n\t\t     id == GCK_ID_CLASSD))\n\t\t\tchg_pid = GCK_INDEX_DT_AUDIO_PLL;\n\n\t\thw = at91_clk_register_generated(regmap, &pmc_pcr_lock,\n\t\t\t\t\t\t &dt_pcr_layout, name,\n\t\t\t\t\t\t parent_names, NULL, NULL,\n\t\t\t\t\t\t num_parents, id, &range,\n\t\t\t\t\t\t chg_pid);\n\t\tif (IS_ERR(hw))\n\t\t\tcontinue;\n\n\t\tof_clk_add_hw_provider(gcknp, of_clk_hw_simple_get, hw);\n\t}\n}\nCLK_OF_DECLARE(of_sama5d2_clk_generated_setup, \"atmel,sama5d2-clk-generated\",\n\t       of_sama5d2_clk_generated_setup);\n#endif  \n\n#ifdef CONFIG_HAVE_AT91_H32MX\nstatic void __init of_sama5d4_clk_h32mx_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *name = np->name;\n\tconst char *parent_name;\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\n\thw = at91_clk_register_h32mx(regmap, name, parent_name);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(of_sama5d4_clk_h32mx_setup, \"atmel,sama5d4-clk-h32mx\",\n\t       of_sama5d4_clk_h32mx_setup);\n#endif  \n\n#ifdef CONFIG_HAVE_AT91_I2S_MUX_CLK\n#define\tI2S_BUS_NR\t2\n\nstatic void __init of_sama5d2_clk_i2s_mux_setup(struct device_node *np)\n{\n\tstruct regmap *regmap_sfr;\n\tu8 bus_id;\n\tconst char *parent_names[2];\n\tstruct device_node *i2s_mux_np;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tregmap_sfr = syscon_regmap_lookup_by_compatible(\"atmel,sama5d2-sfr\");\n\tif (IS_ERR(regmap_sfr))\n\t\treturn;\n\n\tfor_each_child_of_node(np, i2s_mux_np) {\n\t\tif (of_property_read_u8(i2s_mux_np, \"reg\", &bus_id))\n\t\t\tcontinue;\n\n\t\tif (bus_id > I2S_BUS_NR)\n\t\t\tcontinue;\n\n\t\tret = of_clk_parent_fill(i2s_mux_np, parent_names, 2);\n\t\tif (ret != 2)\n\t\t\tcontinue;\n\n\t\thw = at91_clk_i2s_mux_register(regmap_sfr, i2s_mux_np->name,\n\t\t\t\t\t       parent_names, 2, bus_id);\n\t\tif (IS_ERR(hw))\n\t\t\tcontinue;\n\n\t\tof_clk_add_hw_provider(i2s_mux_np, of_clk_hw_simple_get, hw);\n\t}\n}\nCLK_OF_DECLARE(sama5d2_clk_i2s_mux, \"atmel,sama5d2-clk-i2s-mux\",\n\t       of_sama5d2_clk_i2s_mux_setup);\n#endif  \n\nstatic void __init of_at91rm9200_clk_main_osc_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *name = np->name;\n\tconst char *parent_name;\n\tstruct regmap *regmap;\n\tbool bypass;\n\tstruct device_node *parent_np;\n\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\tbypass = of_property_read_bool(np, \"atmel,osc-bypass\");\n\tparent_name = of_clk_get_parent_name(np, 0);\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\thw = at91_clk_register_main_osc(regmap, name, parent_name, NULL, bypass);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(at91rm9200_clk_main_osc, \"atmel,at91rm9200-clk-main-osc\",\n\t       of_at91rm9200_clk_main_osc_setup);\n\nstatic void __init of_at91sam9x5_clk_main_rc_osc_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tu32 frequency = 0;\n\tu32 accuracy = 0;\n\tconst char *name = np->name;\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\tof_property_read_u32(np, \"clock-frequency\", &frequency);\n\tof_property_read_u32(np, \"clock-accuracy\", &accuracy);\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\thw = at91_clk_register_main_rc_osc(regmap, name, frequency, accuracy);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(at91sam9x5_clk_main_rc_osc, \"atmel,at91sam9x5-clk-main-rc-osc\",\n\t       of_at91sam9x5_clk_main_rc_osc_setup);\n\nstatic void __init of_at91rm9200_clk_main_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *parent_name;\n\tconst char *name = np->name;\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\thw = at91_clk_register_rm9200_main(regmap, name, parent_name, NULL);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(at91rm9200_clk_main, \"atmel,at91rm9200-clk-main\",\n\t       of_at91rm9200_clk_main_setup);\n\nstatic void __init of_at91sam9x5_clk_main_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *parent_names[2];\n\tunsigned int num_parents;\n\tconst char *name = np->name;\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tnum_parents = of_clk_get_parent_count(np);\n\tif (num_parents == 0 || num_parents > 2)\n\t\treturn;\n\n\tof_clk_parent_fill(np, parent_names, num_parents);\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\n\thw = at91_clk_register_sam9x5_main(regmap, name, parent_names, NULL,\n\t\t\t\t\t   num_parents);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(at91sam9x5_clk_main, \"atmel,at91sam9x5-clk-main\",\n\t       of_at91sam9x5_clk_main_setup);\n\nstatic struct clk_master_characteristics * __init\nof_at91_clk_master_get_characteristics(struct device_node *np)\n{\n\tstruct clk_master_characteristics *characteristics;\n\n\tcharacteristics = kzalloc(sizeof(*characteristics), GFP_KERNEL);\n\tif (!characteristics)\n\t\treturn NULL;\n\n\tif (of_at91_get_clk_range(np, \"atmel,clk-output-range\", &characteristics->output))\n\t\tgoto out_free_characteristics;\n\n\tof_property_read_u32_array(np, \"atmel,clk-divisors\",\n\t\t\t\t   characteristics->divisors, 4);\n\n\tcharacteristics->have_div3_pres =\n\t\tof_property_read_bool(np, \"atmel,master-clk-have-div3-pres\");\n\n\treturn characteristics;\n\nout_free_characteristics:\n\tkfree(characteristics);\n\treturn NULL;\n}\n\nstatic void __init\nof_at91_clk_master_setup(struct device_node *np,\n\t\t\t const struct clk_master_layout *layout)\n{\n\tstruct clk_hw *hw;\n\tunsigned int num_parents;\n\tconst char *parent_names[MASTER_SOURCE_MAX];\n\tconst char *name = np->name;\n\tstruct clk_master_characteristics *characteristics;\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tnum_parents = of_clk_get_parent_count(np);\n\tif (num_parents == 0 || num_parents > MASTER_SOURCE_MAX)\n\t\treturn;\n\n\tof_clk_parent_fill(np, parent_names, num_parents);\n\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\n\tcharacteristics = of_at91_clk_master_get_characteristics(np);\n\tif (!characteristics)\n\t\treturn;\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\thw = at91_clk_register_master_pres(regmap, \"masterck_pres\", num_parents,\n\t\t\t\t\t   parent_names, NULL, layout,\n\t\t\t\t\t   characteristics, &mck_lock);\n\tif (IS_ERR(hw))\n\t\tgoto out_free_characteristics;\n\n\thw = at91_clk_register_master_div(regmap, name, \"masterck_pres\", NULL,\n\t\t\t\t\t  layout, characteristics,\n\t\t\t\t\t  &mck_lock, CLK_SET_RATE_GATE, 0);\n\tif (IS_ERR(hw))\n\t\tgoto out_free_characteristics;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n\treturn;\n\nout_free_characteristics:\n\tkfree(characteristics);\n}\n\nstatic void __init of_at91rm9200_clk_master_setup(struct device_node *np)\n{\n\tof_at91_clk_master_setup(np, &at91rm9200_master_layout);\n}\nCLK_OF_DECLARE(at91rm9200_clk_master, \"atmel,at91rm9200-clk-master\",\n\t       of_at91rm9200_clk_master_setup);\n\nstatic void __init of_at91sam9x5_clk_master_setup(struct device_node *np)\n{\n\tof_at91_clk_master_setup(np, &at91sam9x5_master_layout);\n}\nCLK_OF_DECLARE(at91sam9x5_clk_master, \"atmel,at91sam9x5-clk-master\",\n\t       of_at91sam9x5_clk_master_setup);\n\nstatic void __init\nof_at91_clk_periph_setup(struct device_node *np, u8 type)\n{\n\tint num;\n\tu32 id;\n\tstruct clk_hw *hw;\n\tconst char *parent_name;\n\tconst char *name;\n\tstruct device_node *periphclknp;\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\tif (!parent_name)\n\t\treturn;\n\n\tnum = of_get_child_count(np);\n\tif (!num || num > PERIPHERAL_MAX)\n\t\treturn;\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\tfor_each_child_of_node(np, periphclknp) {\n\t\tif (of_property_read_u32(periphclknp, \"reg\", &id))\n\t\t\tcontinue;\n\n\t\tif (id >= PERIPHERAL_MAX)\n\t\t\tcontinue;\n\n\t\tif (of_property_read_string(np, \"clock-output-names\", &name))\n\t\t\tname = periphclknp->name;\n\n\t\tif (type == PERIPHERAL_AT91RM9200) {\n\t\t\thw = at91_clk_register_peripheral(regmap, name,\n\t\t\t\t\t\t\t  parent_name, NULL, id);\n\t\t} else {\n\t\t\tstruct clk_range range = CLK_RANGE(0, 0);\n\t\t\tunsigned long flags = 0;\n\n\t\t\tof_at91_get_clk_range(periphclknp,\n\t\t\t\t\t      \"atmel,clk-output-range\",\n\t\t\t\t\t      &range);\n\n\t\t\t \n\t\t\tif (!strcmp(periphclknp->name, \"mpddr_clk\"))\n\t\t\t\tflags = CLK_IS_CRITICAL;\n\n\t\t\thw = at91_clk_register_sam9x5_peripheral(regmap,\n\t\t\t\t\t\t\t\t &pmc_pcr_lock,\n\t\t\t\t\t\t\t\t &dt_pcr_layout,\n\t\t\t\t\t\t\t\t name,\n\t\t\t\t\t\t\t\t parent_name,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t id, &range,\n\t\t\t\t\t\t\t\t INT_MIN,\n\t\t\t\t\t\t\t\t flags);\n\t\t}\n\n\t\tif (IS_ERR(hw))\n\t\t\tcontinue;\n\n\t\tof_clk_add_hw_provider(periphclknp, of_clk_hw_simple_get, hw);\n\t}\n}\n\nstatic void __init of_at91rm9200_clk_periph_setup(struct device_node *np)\n{\n\tof_at91_clk_periph_setup(np, PERIPHERAL_AT91RM9200);\n}\nCLK_OF_DECLARE(at91rm9200_clk_periph, \"atmel,at91rm9200-clk-peripheral\",\n\t       of_at91rm9200_clk_periph_setup);\n\nstatic void __init of_at91sam9x5_clk_periph_setup(struct device_node *np)\n{\n\tof_at91_clk_periph_setup(np, PERIPHERAL_AT91SAM9X5);\n}\nCLK_OF_DECLARE(at91sam9x5_clk_periph, \"atmel,at91sam9x5-clk-peripheral\",\n\t       of_at91sam9x5_clk_periph_setup);\n\nstatic struct clk_pll_characteristics * __init\nof_at91_clk_pll_get_characteristics(struct device_node *np)\n{\n\tint i;\n\tint offset;\n\tu32 tmp;\n\tint num_output;\n\tu32 num_cells;\n\tstruct clk_range input;\n\tstruct clk_range *output;\n\tu8 *out = NULL;\n\tu16 *icpll = NULL;\n\tstruct clk_pll_characteristics *characteristics;\n\n\tif (of_at91_get_clk_range(np, \"atmel,clk-input-range\", &input))\n\t\treturn NULL;\n\n\tif (of_property_read_u32(np, \"#atmel,pll-clk-output-range-cells\",\n\t\t\t\t &num_cells))\n\t\treturn NULL;\n\n\tif (num_cells < 2 || num_cells > 4)\n\t\treturn NULL;\n\n\tif (!of_get_property(np, \"atmel,pll-clk-output-ranges\", &tmp))\n\t\treturn NULL;\n\tnum_output = tmp / (sizeof(u32) * num_cells);\n\n\tcharacteristics = kzalloc(sizeof(*characteristics), GFP_KERNEL);\n\tif (!characteristics)\n\t\treturn NULL;\n\n\toutput = kcalloc(num_output, sizeof(*output), GFP_KERNEL);\n\tif (!output)\n\t\tgoto out_free_characteristics;\n\n\tif (num_cells > 2) {\n\t\tout = kcalloc(num_output, sizeof(*out), GFP_KERNEL);\n\t\tif (!out)\n\t\t\tgoto out_free_output;\n\t}\n\n\tif (num_cells > 3) {\n\t\ticpll = kcalloc(num_output, sizeof(*icpll), GFP_KERNEL);\n\t\tif (!icpll)\n\t\t\tgoto out_free_output;\n\t}\n\n\tfor (i = 0; i < num_output; i++) {\n\t\toffset = i * num_cells;\n\t\tif (of_property_read_u32_index(np,\n\t\t\t\t\t       \"atmel,pll-clk-output-ranges\",\n\t\t\t\t\t       offset, &tmp))\n\t\t\tgoto out_free_output;\n\t\toutput[i].min = tmp;\n\t\tif (of_property_read_u32_index(np,\n\t\t\t\t\t       \"atmel,pll-clk-output-ranges\",\n\t\t\t\t\t       offset + 1, &tmp))\n\t\t\tgoto out_free_output;\n\t\toutput[i].max = tmp;\n\n\t\tif (num_cells == 2)\n\t\t\tcontinue;\n\n\t\tif (of_property_read_u32_index(np,\n\t\t\t\t\t       \"atmel,pll-clk-output-ranges\",\n\t\t\t\t\t       offset + 2, &tmp))\n\t\t\tgoto out_free_output;\n\t\tout[i] = tmp;\n\n\t\tif (num_cells == 3)\n\t\t\tcontinue;\n\n\t\tif (of_property_read_u32_index(np,\n\t\t\t\t\t       \"atmel,pll-clk-output-ranges\",\n\t\t\t\t\t       offset + 3, &tmp))\n\t\t\tgoto out_free_output;\n\t\ticpll[i] = tmp;\n\t}\n\n\tcharacteristics->input = input;\n\tcharacteristics->num_output = num_output;\n\tcharacteristics->output = output;\n\tcharacteristics->out = out;\n\tcharacteristics->icpll = icpll;\n\treturn characteristics;\n\nout_free_output:\n\tkfree(icpll);\n\tkfree(out);\n\tkfree(output);\nout_free_characteristics:\n\tkfree(characteristics);\n\treturn NULL;\n}\n\nstatic void __init\nof_at91_clk_pll_setup(struct device_node *np,\n\t\t      const struct clk_pll_layout *layout)\n{\n\tu32 id;\n\tstruct clk_hw *hw;\n\tstruct regmap *regmap;\n\tconst char *parent_name;\n\tconst char *name = np->name;\n\tstruct device_node *parent_np;\n\tstruct clk_pll_characteristics *characteristics;\n\n\tif (of_property_read_u32(np, \"reg\", &id))\n\t\treturn;\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\tcharacteristics = of_at91_clk_pll_get_characteristics(np);\n\tif (!characteristics)\n\t\treturn;\n\n\thw = at91_clk_register_pll(regmap, name, parent_name, id, layout,\n\t\t\t\t   characteristics);\n\tif (IS_ERR(hw))\n\t\tgoto out_free_characteristics;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n\treturn;\n\nout_free_characteristics:\n\tkfree(characteristics);\n}\n\nstatic void __init of_at91rm9200_clk_pll_setup(struct device_node *np)\n{\n\tof_at91_clk_pll_setup(np, &at91rm9200_pll_layout);\n}\nCLK_OF_DECLARE(at91rm9200_clk_pll, \"atmel,at91rm9200-clk-pll\",\n\t       of_at91rm9200_clk_pll_setup);\n\nstatic void __init of_at91sam9g45_clk_pll_setup(struct device_node *np)\n{\n\tof_at91_clk_pll_setup(np, &at91sam9g45_pll_layout);\n}\nCLK_OF_DECLARE(at91sam9g45_clk_pll, \"atmel,at91sam9g45-clk-pll\",\n\t       of_at91sam9g45_clk_pll_setup);\n\nstatic void __init of_at91sam9g20_clk_pllb_setup(struct device_node *np)\n{\n\tof_at91_clk_pll_setup(np, &at91sam9g20_pllb_layout);\n}\nCLK_OF_DECLARE(at91sam9g20_clk_pllb, \"atmel,at91sam9g20-clk-pllb\",\n\t       of_at91sam9g20_clk_pllb_setup);\n\nstatic void __init of_sama5d3_clk_pll_setup(struct device_node *np)\n{\n\tof_at91_clk_pll_setup(np, &sama5d3_pll_layout);\n}\nCLK_OF_DECLARE(sama5d3_clk_pll, \"atmel,sama5d3-clk-pll\",\n\t       of_sama5d3_clk_pll_setup);\n\nstatic void __init\nof_at91sam9x5_clk_plldiv_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *parent_name;\n\tconst char *name = np->name;\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\thw = at91_clk_register_plldiv(regmap, name, parent_name);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(at91sam9x5_clk_plldiv, \"atmel,at91sam9x5-clk-plldiv\",\n\t       of_at91sam9x5_clk_plldiv_setup);\n\nstatic void __init\nof_at91_clk_prog_setup(struct device_node *np,\n\t\t       const struct clk_programmable_layout *layout,\n\t\t       u32 *mux_table)\n{\n\tint num;\n\tu32 id;\n\tstruct clk_hw *hw;\n\tunsigned int num_parents;\n\tconst char *parent_names[PROG_SOURCE_MAX];\n\tconst char *name;\n\tstruct device_node *progclknp, *parent_np;\n\tstruct regmap *regmap;\n\n\tnum_parents = of_clk_get_parent_count(np);\n\tif (num_parents == 0 || num_parents > PROG_SOURCE_MAX)\n\t\treturn;\n\n\tof_clk_parent_fill(np, parent_names, num_parents);\n\n\tnum = of_get_child_count(np);\n\tif (!num || num > (PROG_ID_MAX + 1))\n\t\treturn;\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\tfor_each_child_of_node(np, progclknp) {\n\t\tif (of_property_read_u32(progclknp, \"reg\", &id))\n\t\t\tcontinue;\n\n\t\tif (of_property_read_string(np, \"clock-output-names\", &name))\n\t\t\tname = progclknp->name;\n\n\t\thw = at91_clk_register_programmable(regmap, name,\n\t\t\t\t\t\t    parent_names, NULL, num_parents,\n\t\t\t\t\t\t    id, layout, mux_table);\n\t\tif (IS_ERR(hw))\n\t\t\tcontinue;\n\n\t\tof_clk_add_hw_provider(progclknp, of_clk_hw_simple_get, hw);\n\t}\n}\n\nstatic void __init of_at91rm9200_clk_prog_setup(struct device_node *np)\n{\n\tof_at91_clk_prog_setup(np, &at91rm9200_programmable_layout, NULL);\n}\nCLK_OF_DECLARE(at91rm9200_clk_prog, \"atmel,at91rm9200-clk-programmable\",\n\t       of_at91rm9200_clk_prog_setup);\n\nstatic void __init of_at91sam9g45_clk_prog_setup(struct device_node *np)\n{\n\tof_at91_clk_prog_setup(np, &at91sam9g45_programmable_layout, NULL);\n}\nCLK_OF_DECLARE(at91sam9g45_clk_prog, \"atmel,at91sam9g45-clk-programmable\",\n\t       of_at91sam9g45_clk_prog_setup);\n\nstatic void __init of_at91sam9x5_clk_prog_setup(struct device_node *np)\n{\n\tof_at91_clk_prog_setup(np, &at91sam9x5_programmable_layout, NULL);\n}\nCLK_OF_DECLARE(at91sam9x5_clk_prog, \"atmel,at91sam9x5-clk-programmable\",\n\t       of_at91sam9x5_clk_prog_setup);\n\nstatic void __init of_at91sam9260_clk_slow_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *parent_names[2];\n\tunsigned int num_parents;\n\tconst char *name = np->name;\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tnum_parents = of_clk_get_parent_count(np);\n\tif (num_parents != 2)\n\t\treturn;\n\n\tof_clk_parent_fill(np, parent_names, num_parents);\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\n\thw = at91_clk_register_sam9260_slow(regmap, name, parent_names,\n\t\t\t\t\t    num_parents);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(at91sam9260_clk_slow, \"atmel,at91sam9260-clk-slow\",\n\t       of_at91sam9260_clk_slow_setup);\n\n#ifdef CONFIG_HAVE_AT91_SMD\n#define SMD_SOURCE_MAX\t\t2\n\nstatic void __init of_at91sam9x5_clk_smd_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tunsigned int num_parents;\n\tconst char *parent_names[SMD_SOURCE_MAX];\n\tconst char *name = np->name;\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tnum_parents = of_clk_get_parent_count(np);\n\tif (num_parents == 0 || num_parents > SMD_SOURCE_MAX)\n\t\treturn;\n\n\tof_clk_parent_fill(np, parent_names, num_parents);\n\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\thw = at91sam9x5_clk_register_smd(regmap, name, parent_names,\n\t\t\t\t\t num_parents);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(at91sam9x5_clk_smd, \"atmel,at91sam9x5-clk-smd\",\n\t       of_at91sam9x5_clk_smd_setup);\n#endif  \n\nstatic void __init of_at91rm9200_clk_sys_setup(struct device_node *np)\n{\n\tint num;\n\tu32 id;\n\tstruct clk_hw *hw;\n\tconst char *name;\n\tstruct device_node *sysclknp, *parent_np;\n\tconst char *parent_name;\n\tstruct regmap *regmap;\n\n\tnum = of_get_child_count(np);\n\tif (num > (SYSTEM_MAX_ID + 1))\n\t\treturn;\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\tfor_each_child_of_node(np, sysclknp) {\n\t\tunsigned long flags = 0;\n\n\t\tif (of_property_read_u32(sysclknp, \"reg\", &id))\n\t\t\tcontinue;\n\n\t\tif (of_property_read_string(np, \"clock-output-names\", &name))\n\t\t\tname = sysclknp->name;\n\n\t\tparent_name = of_clk_get_parent_name(sysclknp, 0);\n\n\t\t \n\t\tif (!strcmp(sysclknp->name, \"ddrck\"))\n\t\t\tflags = CLK_IS_CRITICAL;\n\n\t\thw = at91_clk_register_system(regmap, name, parent_name, NULL,\n\t\t\t\t\t      id, flags);\n\t\tif (IS_ERR(hw))\n\t\t\tcontinue;\n\n\t\tof_clk_add_hw_provider(sysclknp, of_clk_hw_simple_get, hw);\n\t}\n}\nCLK_OF_DECLARE(at91rm9200_clk_sys, \"atmel,at91rm9200-clk-system\",\n\t       of_at91rm9200_clk_sys_setup);\n\n#ifdef CONFIG_HAVE_AT91_USB_CLK\n#define USB_SOURCE_MAX\t\t2\n\nstatic void __init of_at91sam9x5_clk_usb_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tunsigned int num_parents;\n\tconst char *parent_names[USB_SOURCE_MAX];\n\tconst char *name = np->name;\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tnum_parents = of_clk_get_parent_count(np);\n\tif (num_parents == 0 || num_parents > USB_SOURCE_MAX)\n\t\treturn;\n\n\tof_clk_parent_fill(np, parent_names, num_parents);\n\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\thw = at91sam9x5_clk_register_usb(regmap, name, parent_names,\n\t\t\t\t\t num_parents);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(at91sam9x5_clk_usb, \"atmel,at91sam9x5-clk-usb\",\n\t       of_at91sam9x5_clk_usb_setup);\n\nstatic void __init of_at91sam9n12_clk_usb_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *parent_name;\n\tconst char *name = np->name;\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\tif (!parent_name)\n\t\treturn;\n\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\thw = at91sam9n12_clk_register_usb(regmap, name, parent_name);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(at91sam9n12_clk_usb, \"atmel,at91sam9n12-clk-usb\",\n\t       of_at91sam9n12_clk_usb_setup);\n\nstatic void __init of_at91rm9200_clk_usb_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *parent_name;\n\tconst char *name = np->name;\n\tu32 divisors[4] = {0, 0, 0, 0};\n\tstruct regmap *regmap;\n\tstruct device_node *parent_np;\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\tif (!parent_name)\n\t\treturn;\n\n\tof_property_read_u32_array(np, \"atmel,clk-divisors\", divisors, 4);\n\tif (!divisors[0])\n\t\treturn;\n\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\n\tparent_np = of_get_parent(np);\n\tregmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\thw = at91rm9200_clk_register_usb(regmap, name, parent_name, divisors);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(at91rm9200_clk_usb, \"atmel,at91rm9200-clk-usb\",\n\t       of_at91rm9200_clk_usb_setup);\n#endif  \n\n#ifdef CONFIG_HAVE_AT91_UTMI\nstatic void __init of_at91sam9x5_clk_utmi_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *parent_name;\n\tconst char *name = np->name;\n\tstruct regmap *regmap_pmc, *regmap_sfr;\n\tstruct device_node *parent_np;\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\n\tparent_np = of_get_parent(np);\n\tregmap_pmc = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap_pmc))\n\t\treturn;\n\n\t \n\tregmap_sfr = syscon_regmap_lookup_by_compatible(\"atmel,sama5d3-sfr\");\n\tif (IS_ERR(regmap_sfr)) {\n\t\tregmap_sfr = syscon_regmap_lookup_by_compatible(\"atmel,sama5d2-sfr\");\n\t\tif (IS_ERR(regmap_sfr))\n\t\t\tregmap_sfr = NULL;\n\t}\n\n\thw = at91_clk_register_utmi(regmap_pmc, regmap_sfr, name, parent_name, NULL);\n\tif (IS_ERR(hw))\n\t\treturn;\n\n\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(at91sam9x5_clk_utmi, \"atmel,at91sam9x5-clk-utmi\",\n\t       of_at91sam9x5_clk_utmi_setup);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}