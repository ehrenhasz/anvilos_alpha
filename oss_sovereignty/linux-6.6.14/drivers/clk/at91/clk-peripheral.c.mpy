{
  "module_name": "clk-peripheral.c",
  "hash_id": "1d210d970f17812da76eee4a613a32191521d5c563cf589612549092afb49d8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/clk-peripheral.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/of.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include \"pmc.h\"\n\nDEFINE_SPINLOCK(pmc_pcr_lock);\n\n#define PERIPHERAL_ID_MIN\t2\n#define PERIPHERAL_ID_MAX\t31\n#define PERIPHERAL_MASK(id)\t(1 << ((id) & PERIPHERAL_ID_MAX))\n\n#define PERIPHERAL_MAX_SHIFT\t3\n\nstruct clk_peripheral {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tu32 id;\n};\n\n#define to_clk_peripheral(hw) container_of(hw, struct clk_peripheral, hw)\n\nstruct clk_sam9x5_peripheral {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tstruct clk_range range;\n\tspinlock_t *lock;\n\tu32 id;\n\tu32 div;\n\tconst struct clk_pcr_layout *layout;\n\tstruct at91_clk_pms pms;\n\tbool auto_div;\n\tint chg_pid;\n};\n\n#define to_clk_sam9x5_peripheral(hw) \\\n\tcontainer_of(hw, struct clk_sam9x5_peripheral, hw)\n\nstatic int clk_peripheral_enable(struct clk_hw *hw)\n{\n\tstruct clk_peripheral *periph = to_clk_peripheral(hw);\n\tint offset = AT91_PMC_PCER;\n\tu32 id = periph->id;\n\n\tif (id < PERIPHERAL_ID_MIN)\n\t\treturn 0;\n\tif (id > PERIPHERAL_ID_MAX)\n\t\toffset = AT91_PMC_PCER1;\n\tregmap_write(periph->regmap, offset, PERIPHERAL_MASK(id));\n\n\treturn 0;\n}\n\nstatic void clk_peripheral_disable(struct clk_hw *hw)\n{\n\tstruct clk_peripheral *periph = to_clk_peripheral(hw);\n\tint offset = AT91_PMC_PCDR;\n\tu32 id = periph->id;\n\n\tif (id < PERIPHERAL_ID_MIN)\n\t\treturn;\n\tif (id > PERIPHERAL_ID_MAX)\n\t\toffset = AT91_PMC_PCDR1;\n\tregmap_write(periph->regmap, offset, PERIPHERAL_MASK(id));\n}\n\nstatic int clk_peripheral_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_peripheral *periph = to_clk_peripheral(hw);\n\tint offset = AT91_PMC_PCSR;\n\tunsigned int status;\n\tu32 id = periph->id;\n\n\tif (id < PERIPHERAL_ID_MIN)\n\t\treturn 1;\n\tif (id > PERIPHERAL_ID_MAX)\n\t\toffset = AT91_PMC_PCSR1;\n\tregmap_read(periph->regmap, offset, &status);\n\n\treturn status & PERIPHERAL_MASK(id) ? 1 : 0;\n}\n\nstatic const struct clk_ops peripheral_ops = {\n\t.enable = clk_peripheral_enable,\n\t.disable = clk_peripheral_disable,\n\t.is_enabled = clk_peripheral_is_enabled,\n};\n\nstruct clk_hw * __init\nat91_clk_register_peripheral(struct regmap *regmap, const char *name,\n\t\t\t     const char *parent_name, struct clk_hw *parent_hw,\n\t\t\t     u32 id)\n{\n\tstruct clk_peripheral *periph;\n\tstruct clk_init_data init = {};\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tif (!name || !(parent_name || parent_hw) || id > PERIPHERAL_ID_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tperiph = kzalloc(sizeof(*periph), GFP_KERNEL);\n\tif (!periph)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &peripheral_ops;\n\tif (parent_hw)\n\t\tinit.parent_hws = (const struct clk_hw **)&parent_hw;\n\telse\n\t\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = 0;\n\n\tperiph->id = id;\n\tperiph->hw.init = &init;\n\tperiph->regmap = regmap;\n\n\thw = &periph->hw;\n\tret = clk_hw_register(NULL, &periph->hw);\n\tif (ret) {\n\t\tkfree(periph);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstatic void clk_sam9x5_peripheral_autodiv(struct clk_sam9x5_peripheral *periph)\n{\n\tstruct clk_hw *parent;\n\tunsigned long parent_rate;\n\tint shift = 0;\n\n\tif (!periph->auto_div)\n\t\treturn;\n\n\tif (periph->range.max) {\n\t\tparent = clk_hw_get_parent_by_index(&periph->hw, 0);\n\t\tparent_rate = clk_hw_get_rate(parent);\n\t\tif (!parent_rate)\n\t\t\treturn;\n\n\t\tfor (; shift < PERIPHERAL_MAX_SHIFT; shift++) {\n\t\t\tif (parent_rate >> shift <= periph->range.max)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tperiph->auto_div = false;\n\tperiph->div = shift;\n}\n\nstatic int clk_sam9x5_peripheral_set(struct clk_sam9x5_peripheral *periph,\n\t\t\t\t     unsigned int status)\n{\n\tunsigned long flags;\n\tunsigned int enable = status ? AT91_PMC_PCR_EN : 0;\n\n\tif (periph->id < PERIPHERAL_ID_MIN)\n\t\treturn 0;\n\n\tspin_lock_irqsave(periph->lock, flags);\n\tregmap_write(periph->regmap, periph->layout->offset,\n\t\t     (periph->id & periph->layout->pid_mask));\n\tregmap_update_bits(periph->regmap, periph->layout->offset,\n\t\t\t   periph->layout->div_mask | periph->layout->cmd |\n\t\t\t   enable,\n\t\t\t   field_prep(periph->layout->div_mask, periph->div) |\n\t\t\t   periph->layout->cmd | enable);\n\tspin_unlock_irqrestore(periph->lock, flags);\n\n\treturn 0;\n}\n\nstatic int clk_sam9x5_peripheral_enable(struct clk_hw *hw)\n{\n\tstruct clk_sam9x5_peripheral *periph = to_clk_sam9x5_peripheral(hw);\n\n\treturn clk_sam9x5_peripheral_set(periph, 1);\n}\n\nstatic void clk_sam9x5_peripheral_disable(struct clk_hw *hw)\n{\n\tstruct clk_sam9x5_peripheral *periph = to_clk_sam9x5_peripheral(hw);\n\tunsigned long flags;\n\n\tif (periph->id < PERIPHERAL_ID_MIN)\n\t\treturn;\n\n\tspin_lock_irqsave(periph->lock, flags);\n\tregmap_write(periph->regmap, periph->layout->offset,\n\t\t     (periph->id & periph->layout->pid_mask));\n\tregmap_update_bits(periph->regmap, periph->layout->offset,\n\t\t\t   AT91_PMC_PCR_EN | periph->layout->cmd,\n\t\t\t   periph->layout->cmd);\n\tspin_unlock_irqrestore(periph->lock, flags);\n}\n\nstatic int clk_sam9x5_peripheral_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_sam9x5_peripheral *periph = to_clk_sam9x5_peripheral(hw);\n\tunsigned long flags;\n\tunsigned int status;\n\n\tif (periph->id < PERIPHERAL_ID_MIN)\n\t\treturn 1;\n\n\tspin_lock_irqsave(periph->lock, flags);\n\tregmap_write(periph->regmap, periph->layout->offset,\n\t\t     (periph->id & periph->layout->pid_mask));\n\tregmap_read(periph->regmap, periph->layout->offset, &status);\n\tspin_unlock_irqrestore(periph->lock, flags);\n\n\treturn !!(status & AT91_PMC_PCR_EN);\n}\n\nstatic unsigned long\nclk_sam9x5_peripheral_recalc_rate(struct clk_hw *hw,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_sam9x5_peripheral *periph = to_clk_sam9x5_peripheral(hw);\n\tunsigned long flags;\n\tunsigned int status;\n\n\tif (periph->id < PERIPHERAL_ID_MIN)\n\t\treturn parent_rate;\n\n\tspin_lock_irqsave(periph->lock, flags);\n\tregmap_write(periph->regmap, periph->layout->offset,\n\t\t     (periph->id & periph->layout->pid_mask));\n\tregmap_read(periph->regmap, periph->layout->offset, &status);\n\tspin_unlock_irqrestore(periph->lock, flags);\n\n\tif (status & AT91_PMC_PCR_EN) {\n\t\tperiph->div = field_get(periph->layout->div_mask, status);\n\t\tperiph->auto_div = false;\n\t} else {\n\t\tclk_sam9x5_peripheral_autodiv(periph);\n\t}\n\n\treturn parent_rate >> periph->div;\n}\n\nstatic void clk_sam9x5_peripheral_best_diff(struct clk_rate_request *req,\n\t\t\t\t\t    struct clk_hw *parent,\n\t\t\t\t\t    unsigned long parent_rate,\n\t\t\t\t\t    u32 shift, long *best_diff,\n\t\t\t\t\t    long *best_rate)\n{\n\tunsigned long tmp_rate = parent_rate >> shift;\n\tunsigned long tmp_diff = abs(req->rate - tmp_rate);\n\n\tif (*best_diff < 0 || *best_diff >= tmp_diff) {\n\t\t*best_rate = tmp_rate;\n\t\t*best_diff = tmp_diff;\n\t\treq->best_parent_rate = parent_rate;\n\t\treq->best_parent_hw = parent;\n\t}\n}\n\nstatic int clk_sam9x5_peripheral_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t\tstruct clk_rate_request *req)\n{\n\tstruct clk_sam9x5_peripheral *periph = to_clk_sam9x5_peripheral(hw);\n\tstruct clk_hw *parent = clk_hw_get_parent(hw);\n\tunsigned long parent_rate = clk_hw_get_rate(parent);\n\tunsigned long tmp_rate;\n\tlong best_rate = LONG_MIN;\n\tlong best_diff = LONG_MIN;\n\tu32 shift;\n\n\tif (periph->id < PERIPHERAL_ID_MIN || !periph->range.max)\n\t\treturn parent_rate;\n\n\t \n\tfor (shift = 0; shift <= PERIPHERAL_MAX_SHIFT; shift++) {\n\t\ttmp_rate = parent_rate >> shift;\n\n\t\tif (periph->range.max && tmp_rate > periph->range.max)\n\t\t\tcontinue;\n\n\t\tclk_sam9x5_peripheral_best_diff(req, parent, parent_rate,\n\t\t\t\t\t\tshift, &best_diff, &best_rate);\n\n\t\tif (!best_diff || best_rate <= req->rate)\n\t\t\tbreak;\n\t}\n\n\tif (periph->chg_pid < 0)\n\t\tgoto end;\n\n\t \n\tparent = clk_hw_get_parent_by_index(hw, periph->chg_pid);\n\tif (!parent)\n\t\tgoto end;\n\n\tfor (shift = 0; shift <= PERIPHERAL_MAX_SHIFT; shift++) {\n\t\tstruct clk_rate_request req_parent;\n\n\t\tclk_hw_forward_rate_request(hw, req, parent, &req_parent, req->rate << shift);\n\t\tif (__clk_determine_rate(parent, &req_parent))\n\t\t\tcontinue;\n\n\t\tclk_sam9x5_peripheral_best_diff(req, parent, req_parent.rate,\n\t\t\t\t\t\tshift, &best_diff, &best_rate);\n\n\t\tif (!best_diff)\n\t\t\tbreak;\n\t}\nend:\n\tif (best_rate < 0 ||\n\t    (periph->range.max && best_rate > periph->range.max))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"PCK: %s, best_rate = %ld, parent clk: %s @ %ld\\n\",\n\t\t __func__, best_rate,\n\t\t __clk_get_name((req->best_parent_hw)->clk),\n\t\t req->best_parent_rate);\n\n\treq->rate = best_rate;\n\n\treturn 0;\n}\n\nstatic long clk_sam9x5_peripheral_round_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long rate,\n\t\t\t\t\t     unsigned long *parent_rate)\n{\n\tint shift = 0;\n\tunsigned long best_rate;\n\tunsigned long best_diff;\n\tunsigned long cur_rate = *parent_rate;\n\tunsigned long cur_diff;\n\tstruct clk_sam9x5_peripheral *periph = to_clk_sam9x5_peripheral(hw);\n\n\tif (periph->id < PERIPHERAL_ID_MIN || !periph->range.max)\n\t\treturn *parent_rate;\n\n\tif (periph->range.max) {\n\t\tfor (; shift <= PERIPHERAL_MAX_SHIFT; shift++) {\n\t\t\tcur_rate = *parent_rate >> shift;\n\t\t\tif (cur_rate <= periph->range.max)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rate >= cur_rate)\n\t\treturn cur_rate;\n\n\tbest_diff = cur_rate - rate;\n\tbest_rate = cur_rate;\n\tfor (; shift <= PERIPHERAL_MAX_SHIFT; shift++) {\n\t\tcur_rate = *parent_rate >> shift;\n\t\tif (cur_rate < rate)\n\t\t\tcur_diff = rate - cur_rate;\n\t\telse\n\t\t\tcur_diff = cur_rate - rate;\n\n\t\tif (cur_diff < best_diff) {\n\t\t\tbest_diff = cur_diff;\n\t\t\tbest_rate = cur_rate;\n\t\t}\n\n\t\tif (!best_diff || cur_rate < rate)\n\t\t\tbreak;\n\t}\n\n\treturn best_rate;\n}\n\nstatic int clk_sam9x5_peripheral_set_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long rate,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tint shift;\n\tstruct clk_sam9x5_peripheral *periph = to_clk_sam9x5_peripheral(hw);\n\tif (periph->id < PERIPHERAL_ID_MIN || !periph->range.max) {\n\t\tif (parent_rate == rate)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (periph->range.max && rate > periph->range.max)\n\t\treturn -EINVAL;\n\n\tfor (shift = 0; shift <= PERIPHERAL_MAX_SHIFT; shift++) {\n\t\tif (parent_rate >> shift == rate) {\n\t\t\tperiph->auto_div = false;\n\t\t\tperiph->div = shift;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int clk_sam9x5_peripheral_save_context(struct clk_hw *hw)\n{\n\tstruct clk_sam9x5_peripheral *periph = to_clk_sam9x5_peripheral(hw);\n\n\tperiph->pms.status = clk_sam9x5_peripheral_is_enabled(hw);\n\n\treturn 0;\n}\n\nstatic void clk_sam9x5_peripheral_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_sam9x5_peripheral *periph = to_clk_sam9x5_peripheral(hw);\n\n\tif (periph->pms.status)\n\t\tclk_sam9x5_peripheral_set(periph, periph->pms.status);\n}\n\nstatic const struct clk_ops sam9x5_peripheral_ops = {\n\t.enable = clk_sam9x5_peripheral_enable,\n\t.disable = clk_sam9x5_peripheral_disable,\n\t.is_enabled = clk_sam9x5_peripheral_is_enabled,\n\t.recalc_rate = clk_sam9x5_peripheral_recalc_rate,\n\t.round_rate = clk_sam9x5_peripheral_round_rate,\n\t.set_rate = clk_sam9x5_peripheral_set_rate,\n\t.save_context = clk_sam9x5_peripheral_save_context,\n\t.restore_context = clk_sam9x5_peripheral_restore_context,\n};\n\nstatic const struct clk_ops sam9x5_peripheral_chg_ops = {\n\t.enable = clk_sam9x5_peripheral_enable,\n\t.disable = clk_sam9x5_peripheral_disable,\n\t.is_enabled = clk_sam9x5_peripheral_is_enabled,\n\t.recalc_rate = clk_sam9x5_peripheral_recalc_rate,\n\t.determine_rate = clk_sam9x5_peripheral_determine_rate,\n\t.set_rate = clk_sam9x5_peripheral_set_rate,\n\t.save_context = clk_sam9x5_peripheral_save_context,\n\t.restore_context = clk_sam9x5_peripheral_restore_context,\n};\n\nstruct clk_hw * __init\nat91_clk_register_sam9x5_peripheral(struct regmap *regmap, spinlock_t *lock,\n\t\t\t\t    const struct clk_pcr_layout *layout,\n\t\t\t\t    const char *name, const char *parent_name,\n\t\t\t\t    struct clk_hw *parent_hw,\n\t\t\t\t    u32 id, const struct clk_range *range,\n\t\t\t\t    int chg_pid, unsigned long flags)\n{\n\tstruct clk_sam9x5_peripheral *periph;\n\tstruct clk_init_data init = {};\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tif (!name || !(parent_name || parent_hw))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tperiph = kzalloc(sizeof(*periph), GFP_KERNEL);\n\tif (!periph)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tif (parent_hw)\n\t\tinit.parent_hws = (const struct clk_hw **)&parent_hw;\n\telse\n\t\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = flags;\n\tif (chg_pid < 0) {\n\t\tinit.ops = &sam9x5_peripheral_ops;\n\t} else {\n\t\tinit.flags |= CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE |\n\t\t\t      CLK_SET_RATE_PARENT;\n\t\tinit.ops = &sam9x5_peripheral_chg_ops;\n\t}\n\n\tperiph->id = id;\n\tperiph->hw.init = &init;\n\tperiph->div = 0;\n\tperiph->regmap = regmap;\n\tperiph->lock = lock;\n\tif (layout->div_mask)\n\t\tperiph->auto_div = true;\n\tperiph->layout = layout;\n\tperiph->range = *range;\n\tperiph->chg_pid = chg_pid;\n\n\thw = &periph->hw;\n\tret = clk_hw_register(NULL, &periph->hw);\n\tif (ret) {\n\t\tkfree(periph);\n\t\thw = ERR_PTR(ret);\n\t} else {\n\t\tclk_sam9x5_peripheral_autodiv(periph);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}