{
  "module_name": "sam9x60.c",
  "hash_id": "1eef0bd32990dd2be71375615eafb2551a311604348352195787af4fd7b5fdc8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/sam9x60.c",
  "human_readable_source": "\n#include <linux/clk-provider.h>\n#include <linux/mfd/syscon.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/clock/at91.h>\n\n#include \"pmc.h\"\n\nstatic DEFINE_SPINLOCK(pmc_pll_lock);\nstatic DEFINE_SPINLOCK(mck_lock);\n\nstatic const struct clk_master_characteristics mck_characteristics = {\n\t.output = { .min = 140000000, .max = 200000000 },\n\t.divisors = { 1, 2, 4, 3 },\n\t.have_div3_pres = 1,\n};\n\nstatic const struct clk_master_layout sam9x60_master_layout = {\n\t.mask = 0x373,\n\t.pres_shift = 4,\n\t.offset = 0x28,\n};\n\nstatic const struct clk_range plla_outputs[] = {\n\t{ .min = 2343750, .max = 1200000000 },\n};\n\nstatic const struct clk_pll_characteristics plla_characteristics = {\n\t.input = { .min = 12000000, .max = 48000000 },\n\t.num_output = ARRAY_SIZE(plla_outputs),\n\t.output = plla_outputs,\n};\n\nstatic const struct clk_range upll_outputs[] = {\n\t{ .min = 300000000, .max = 500000000 },\n};\n\nstatic const struct clk_pll_characteristics upll_characteristics = {\n\t.input = { .min = 12000000, .max = 48000000 },\n\t.num_output = ARRAY_SIZE(upll_outputs),\n\t.output = upll_outputs,\n\t.upll = true,\n};\n\nstatic const struct clk_pll_layout pll_frac_layout = {\n\t.mul_mask = GENMASK(31, 24),\n\t.frac_mask = GENMASK(21, 0),\n\t.mul_shift = 24,\n\t.frac_shift = 0,\n};\n\nstatic const struct clk_pll_layout pll_div_layout = {\n\t.div_mask = GENMASK(7, 0),\n\t.endiv_mask = BIT(29),\n\t.div_shift = 0,\n\t.endiv_shift = 29,\n};\n\nstatic const struct clk_programmable_layout sam9x60_programmable_layout = {\n\t.pres_mask = 0xff,\n\t.pres_shift = 8,\n\t.css_mask = 0x1f,\n\t.have_slck_mck = 0,\n\t.is_pres_direct = 1,\n};\n\nstatic const struct clk_pcr_layout sam9x60_pcr_layout = {\n\t.offset = 0x88,\n\t.cmd = BIT(31),\n\t.gckcss_mask = GENMASK(12, 8),\n\t.pid_mask = GENMASK(6, 0),\n};\n\nstatic const struct {\n\tchar *n;\n\tchar *p;\n\tunsigned long flags;\n\tu8 id;\n} sam9x60_systemck[] = {\n\t \n\t{ .n = \"ddrck\",  .p = \"masterck_div\", .id = 2, .flags = CLK_IS_CRITICAL },\n\t{ .n = \"uhpck\",  .p = \"usbck\",    .id = 6 },\n\t{ .n = \"pck0\",   .p = \"prog0\",    .id = 8 },\n\t{ .n = \"pck1\",   .p = \"prog1\",    .id = 9 },\n\t{ .n = \"qspick\", .p = \"masterck_div\", .id = 19 },\n};\n\nstatic const struct {\n\tchar *n;\n\tunsigned long flags;\n\tu8 id;\n} sam9x60_periphck[] = {\n\t{ .n = \"pioA_clk\",   .id = 2, },\n\t{ .n = \"pioB_clk\",   .id = 3, },\n\t{ .n = \"pioC_clk\",   .id = 4, },\n\t{ .n = \"flex0_clk\",  .id = 5, },\n\t{ .n = \"flex1_clk\",  .id = 6, },\n\t{ .n = \"flex2_clk\",  .id = 7, },\n\t{ .n = \"flex3_clk\",  .id = 8, },\n\t{ .n = \"flex6_clk\",  .id = 9, },\n\t{ .n = \"flex7_clk\",  .id = 10, },\n\t{ .n = \"flex8_clk\",  .id = 11, },\n\t{ .n = \"sdmmc0_clk\", .id = 12, },\n\t{ .n = \"flex4_clk\",  .id = 13, },\n\t{ .n = \"flex5_clk\",  .id = 14, },\n\t{ .n = \"flex9_clk\",  .id = 15, },\n\t{ .n = \"flex10_clk\", .id = 16, },\n\t{ .n = \"tcb0_clk\",   .id = 17, },\n\t{ .n = \"pwm_clk\",    .id = 18, },\n\t{ .n = \"adc_clk\",    .id = 19, },\n\t{ .n = \"dma0_clk\",   .id = 20, },\n\t{ .n = \"matrix_clk\", .id = 21, },\n\t{ .n = \"uhphs_clk\",  .id = 22, },\n\t{ .n = \"udphs_clk\",  .id = 23, },\n\t{ .n = \"macb0_clk\",  .id = 24, },\n\t{ .n = \"lcd_clk\",    .id = 25, },\n\t{ .n = \"sdmmc1_clk\", .id = 26, },\n\t{ .n = \"macb1_clk\",  .id = 27, },\n\t{ .n = \"ssc_clk\",    .id = 28, },\n\t{ .n = \"can0_clk\",   .id = 29, },\n\t{ .n = \"can1_clk\",   .id = 30, },\n\t{ .n = \"flex11_clk\", .id = 32, },\n\t{ .n = \"flex12_clk\", .id = 33, },\n\t{ .n = \"i2s_clk\",    .id = 34, },\n\t{ .n = \"qspi_clk\",   .id = 35, },\n\t{ .n = \"gfx2d_clk\",  .id = 36, },\n\t{ .n = \"pit64b_clk\", .id = 37, },\n\t{ .n = \"trng_clk\",   .id = 38, },\n\t{ .n = \"aes_clk\",    .id = 39, },\n\t{ .n = \"tdes_clk\",   .id = 40, },\n\t{ .n = \"sha_clk\",    .id = 41, },\n\t{ .n = \"classd_clk\", .id = 42, },\n\t{ .n = \"isi_clk\",    .id = 43, },\n\t{ .n = \"pioD_clk\",   .id = 44, },\n\t{ .n = \"tcb1_clk\",   .id = 45, },\n\t{ .n = \"dbgu_clk\",   .id = 47, },\n\t \n\t{ .n = \"mpddr_clk\",  .id = 49, .flags = CLK_IS_CRITICAL },\n};\n\nstatic const struct {\n\tchar *n;\n\tu8 id;\n\tstruct clk_range r;\n} sam9x60_gck[] = {\n\t{ .n = \"flex0_gclk\",  .id = 5, },\n\t{ .n = \"flex1_gclk\",  .id = 6, },\n\t{ .n = \"flex2_gclk\",  .id = 7, },\n\t{ .n = \"flex3_gclk\",  .id = 8, },\n\t{ .n = \"flex6_gclk\",  .id = 9, },\n\t{ .n = \"flex7_gclk\",  .id = 10, },\n\t{ .n = \"flex8_gclk\",  .id = 11, },\n\t{ .n = \"sdmmc0_gclk\", .id = 12, .r = { .min = 0, .max = 105000000 }, },\n\t{ .n = \"flex4_gclk\",  .id = 13, },\n\t{ .n = \"flex5_gclk\",  .id = 14, },\n\t{ .n = \"flex9_gclk\",  .id = 15, },\n\t{ .n = \"flex10_gclk\", .id = 16, },\n\t{ .n = \"tcb0_gclk\",   .id = 17, },\n\t{ .n = \"adc_gclk\",    .id = 19, },\n\t{ .n = \"lcd_gclk\",    .id = 25, .r = { .min = 0, .max = 140000000 }, },\n\t{ .n = \"sdmmc1_gclk\", .id = 26, .r = { .min = 0, .max = 105000000 }, },\n\t{ .n = \"flex11_gclk\", .id = 32, },\n\t{ .n = \"flex12_gclk\", .id = 33, },\n\t{ .n = \"i2s_gclk\",    .id = 34, .r = { .min = 0, .max = 105000000 }, },\n\t{ .n = \"pit64b_gclk\", .id = 37, },\n\t{ .n = \"classd_gclk\", .id = 42, .r = { .min = 0, .max = 100000000 }, },\n\t{ .n = \"tcb1_gclk\",   .id = 45, },\n\t{ .n = \"dbgu_gclk\",   .id = 47, },\n};\n\nstatic void __init sam9x60_pmc_setup(struct device_node *np)\n{\n\tstruct clk_range range = CLK_RANGE(0, 0);\n\tconst char *td_slck_name, *md_slck_name, *mainxtal_name;\n\tstruct pmc_data *sam9x60_pmc;\n\tconst char *parent_names[6];\n\tstruct clk_hw *main_osc_hw;\n\tstruct regmap *regmap;\n\tstruct clk_hw *hw;\n\tint i;\n\n\ti = of_property_match_string(np, \"clock-names\", \"td_slck\");\n\tif (i < 0)\n\t\treturn;\n\n\ttd_slck_name = of_clk_get_parent_name(np, i);\n\n\ti = of_property_match_string(np, \"clock-names\", \"md_slck\");\n\tif (i < 0)\n\t\treturn;\n\n\tmd_slck_name = of_clk_get_parent_name(np, i);\n\n\ti = of_property_match_string(np, \"clock-names\", \"main_xtal\");\n\tif (i < 0)\n\t\treturn;\n\tmainxtal_name = of_clk_get_parent_name(np, i);\n\n\tregmap = device_node_to_regmap(np);\n\tif (IS_ERR(regmap))\n\t\treturn;\n\n\tsam9x60_pmc = pmc_data_allocate(PMC_PLLACK + 1,\n\t\t\t\t\tnck(sam9x60_systemck),\n\t\t\t\t\tnck(sam9x60_periphck),\n\t\t\t\t\tnck(sam9x60_gck), 8);\n\tif (!sam9x60_pmc)\n\t\treturn;\n\n\thw = at91_clk_register_main_rc_osc(regmap, \"main_rc_osc\", 12000000,\n\t\t\t\t\t   50000000);\n\tif (IS_ERR(hw))\n\t\tgoto err_free;\n\n\thw = at91_clk_register_main_osc(regmap, \"main_osc\", mainxtal_name, NULL, 0);\n\tif (IS_ERR(hw))\n\t\tgoto err_free;\n\tmain_osc_hw = hw;\n\n\tparent_names[0] = \"main_rc_osc\";\n\tparent_names[1] = \"main_osc\";\n\thw = at91_clk_register_sam9x5_main(regmap, \"mainck\", parent_names, NULL, 2);\n\tif (IS_ERR(hw))\n\t\tgoto err_free;\n\n\tsam9x60_pmc->chws[PMC_MAIN] = hw;\n\n\thw = sam9x60_clk_register_frac_pll(regmap, &pmc_pll_lock, \"pllack_fracck\",\n\t\t\t\t\t   \"mainck\", sam9x60_pmc->chws[PMC_MAIN],\n\t\t\t\t\t   0, &plla_characteristics,\n\t\t\t\t\t   &pll_frac_layout,\n\t\t\t\t\t    \n\t\t\t\t\t   CLK_IS_CRITICAL | CLK_SET_RATE_GATE);\n\tif (IS_ERR(hw))\n\t\tgoto err_free;\n\n\thw = sam9x60_clk_register_div_pll(regmap, &pmc_pll_lock, \"pllack_divck\",\n\t\t\t\t\t  \"pllack_fracck\", NULL, 0, &plla_characteristics,\n\t\t\t\t\t  &pll_div_layout,\n\t\t\t\t\t    \n\t\t\t\t\t  CLK_IS_CRITICAL | CLK_SET_RATE_GATE, 0);\n\tif (IS_ERR(hw))\n\t\tgoto err_free;\n\n\tsam9x60_pmc->chws[PMC_PLLACK] = hw;\n\n\thw = sam9x60_clk_register_frac_pll(regmap, &pmc_pll_lock, \"upllck_fracck\",\n\t\t\t\t\t   \"main_osc\", main_osc_hw, 1,\n\t\t\t\t\t   &upll_characteristics,\n\t\t\t\t\t   &pll_frac_layout, CLK_SET_RATE_GATE);\n\tif (IS_ERR(hw))\n\t\tgoto err_free;\n\n\thw = sam9x60_clk_register_div_pll(regmap, &pmc_pll_lock, \"upllck_divck\",\n\t\t\t\t\t  \"upllck_fracck\", NULL, 1, &upll_characteristics,\n\t\t\t\t\t  &pll_div_layout,\n\t\t\t\t\t  CLK_SET_RATE_GATE |\n\t\t\t\t\t  CLK_SET_PARENT_GATE |\n\t\t\t\t\t  CLK_SET_RATE_PARENT, 0);\n\tif (IS_ERR(hw))\n\t\tgoto err_free;\n\n\tsam9x60_pmc->chws[PMC_UTMI] = hw;\n\n\tparent_names[0] = md_slck_name;\n\tparent_names[1] = \"mainck\";\n\tparent_names[2] = \"pllack_divck\";\n\thw = at91_clk_register_master_pres(regmap, \"masterck_pres\", 3,\n\t\t\t\t\t   parent_names, NULL, &sam9x60_master_layout,\n\t\t\t\t\t   &mck_characteristics, &mck_lock);\n\tif (IS_ERR(hw))\n\t\tgoto err_free;\n\n\thw = at91_clk_register_master_div(regmap, \"masterck_div\",\n\t\t\t\t\t  \"masterck_pres\", NULL, &sam9x60_master_layout,\n\t\t\t\t\t  &mck_characteristics, &mck_lock,\n\t\t\t\t\t  CLK_SET_RATE_GATE, 0);\n\tif (IS_ERR(hw))\n\t\tgoto err_free;\n\n\tsam9x60_pmc->chws[PMC_MCK] = hw;\n\n\tparent_names[0] = \"pllack_divck\";\n\tparent_names[1] = \"upllck_divck\";\n\tparent_names[2] = \"main_osc\";\n\thw = sam9x60_clk_register_usb(regmap, \"usbck\", parent_names, 3);\n\tif (IS_ERR(hw))\n\t\tgoto err_free;\n\n\tparent_names[0] = md_slck_name;\n\tparent_names[1] = td_slck_name;\n\tparent_names[2] = \"mainck\";\n\tparent_names[3] = \"masterck_div\";\n\tparent_names[4] = \"pllack_divck\";\n\tparent_names[5] = \"upllck_divck\";\n\tfor (i = 0; i < 2; i++) {\n\t\tchar name[6];\n\n\t\tsnprintf(name, sizeof(name), \"prog%d\", i);\n\n\t\thw = at91_clk_register_programmable(regmap, name,\n\t\t\t\t\t\t    parent_names, NULL, 6, i,\n\t\t\t\t\t\t    &sam9x60_programmable_layout,\n\t\t\t\t\t\t    NULL);\n\t\tif (IS_ERR(hw))\n\t\t\tgoto err_free;\n\n\t\tsam9x60_pmc->pchws[i] = hw;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(sam9x60_systemck); i++) {\n\t\thw = at91_clk_register_system(regmap, sam9x60_systemck[i].n,\n\t\t\t\t\t      sam9x60_systemck[i].p, NULL,\n\t\t\t\t\t      sam9x60_systemck[i].id,\n\t\t\t\t\t      sam9x60_systemck[i].flags);\n\t\tif (IS_ERR(hw))\n\t\t\tgoto err_free;\n\n\t\tsam9x60_pmc->shws[sam9x60_systemck[i].id] = hw;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(sam9x60_periphck); i++) {\n\t\thw = at91_clk_register_sam9x5_peripheral(regmap, &pmc_pcr_lock,\n\t\t\t\t\t\t\t &sam9x60_pcr_layout,\n\t\t\t\t\t\t\t sam9x60_periphck[i].n,\n\t\t\t\t\t\t\t \"masterck_div\", NULL,\n\t\t\t\t\t\t\t sam9x60_periphck[i].id,\n\t\t\t\t\t\t\t &range, INT_MIN,\n\t\t\t\t\t\t\t sam9x60_periphck[i].flags);\n\t\tif (IS_ERR(hw))\n\t\t\tgoto err_free;\n\n\t\tsam9x60_pmc->phws[sam9x60_periphck[i].id] = hw;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(sam9x60_gck); i++) {\n\t\thw = at91_clk_register_generated(regmap, &pmc_pcr_lock,\n\t\t\t\t\t\t &sam9x60_pcr_layout,\n\t\t\t\t\t\t sam9x60_gck[i].n,\n\t\t\t\t\t\t parent_names, NULL, NULL, 6,\n\t\t\t\t\t\t sam9x60_gck[i].id,\n\t\t\t\t\t\t &sam9x60_gck[i].r, INT_MIN);\n\t\tif (IS_ERR(hw))\n\t\t\tgoto err_free;\n\n\t\tsam9x60_pmc->ghws[sam9x60_gck[i].id] = hw;\n\t}\n\n\tof_clk_add_hw_provider(np, of_clk_hw_pmc_get, sam9x60_pmc);\n\n\treturn;\n\nerr_free:\n\tkfree(sam9x60_pmc);\n}\n \nCLK_OF_DECLARE(sam9x60_pmc, \"microchip,sam9x60-pmc\", sam9x60_pmc_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}