{
  "module_name": "clk-master.c",
  "hash_id": "b19bfa7506b38ede08931f9d9aad0368459420205e39646f6ea06555f147d88c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/clk-master.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/of.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include \"pmc.h\"\n\n#define MASTER_PRES_MASK\t0x7\n#define MASTER_PRES_MAX\t\tMASTER_PRES_MASK\n#define MASTER_DIV_SHIFT\t8\n#define MASTER_DIV_MASK\t\t0x7\n\n#define PMC_MCR_CSS_SHIFT\t(16)\n\n#define MASTER_MAX_ID\t\t4\n\n#define to_clk_master(hw) container_of(hw, struct clk_master, hw)\n\nstruct clk_master {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tspinlock_t *lock;\n\tconst struct clk_master_layout *layout;\n\tconst struct clk_master_characteristics *characteristics;\n\tstruct at91_clk_pms pms;\n\tu32 *mux_table;\n\tu32 mckr;\n\tint chg_pid;\n\tu8 id;\n\tu8 parent;\n\tu8 div;\n\tu32 safe_div;\n};\n\n \nstatic struct clk_master *master_div;\n\nstatic inline bool clk_master_ready(struct clk_master *master)\n{\n\tunsigned int bit = master->id ? AT91_PMC_MCKXRDY : AT91_PMC_MCKRDY;\n\tunsigned int status;\n\n\tregmap_read(master->regmap, AT91_PMC_SR, &status);\n\n\treturn !!(status & bit);\n}\n\nstatic int clk_master_prepare(struct clk_hw *hw)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(master->lock, flags);\n\n\twhile (!clk_master_ready(master))\n\t\tcpu_relax();\n\n\tspin_unlock_irqrestore(master->lock, flags);\n\n\treturn 0;\n}\n\nstatic int clk_master_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tunsigned long flags;\n\tbool status;\n\n\tspin_lock_irqsave(master->lock, flags);\n\tstatus = clk_master_ready(master);\n\tspin_unlock_irqrestore(master->lock, flags);\n\n\treturn status;\n}\n\nstatic unsigned long clk_master_div_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tu8 div;\n\tunsigned long flags, rate = parent_rate;\n\tstruct clk_master *master = to_clk_master(hw);\n\tconst struct clk_master_layout *layout = master->layout;\n\tconst struct clk_master_characteristics *characteristics =\n\t\t\t\t\t\tmaster->characteristics;\n\tunsigned int mckr;\n\n\tspin_lock_irqsave(master->lock, flags);\n\tregmap_read(master->regmap, master->layout->offset, &mckr);\n\tspin_unlock_irqrestore(master->lock, flags);\n\n\tmckr &= layout->mask;\n\n\tdiv = (mckr >> MASTER_DIV_SHIFT) & MASTER_DIV_MASK;\n\n\trate /= characteristics->divisors[div];\n\n\tif (rate < characteristics->output.min)\n\t\tpr_warn(\"master clk div is underclocked\");\n\telse if (rate > characteristics->output.max)\n\t\tpr_warn(\"master clk div is overclocked\");\n\n\treturn rate;\n}\n\nstatic int clk_master_div_save_context(struct clk_hw *hw)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tstruct clk_hw *parent_hw = clk_hw_get_parent(hw);\n\tunsigned long flags;\n\tunsigned int mckr, div;\n\n\tspin_lock_irqsave(master->lock, flags);\n\tregmap_read(master->regmap, master->layout->offset, &mckr);\n\tspin_unlock_irqrestore(master->lock, flags);\n\n\tmckr &= master->layout->mask;\n\tdiv = (mckr >> MASTER_DIV_SHIFT) & MASTER_DIV_MASK;\n\tdiv = master->characteristics->divisors[div];\n\n\tmaster->pms.parent_rate = clk_hw_get_rate(parent_hw);\n\tmaster->pms.rate = DIV_ROUND_CLOSEST(master->pms.parent_rate, div);\n\n\treturn 0;\n}\n\nstatic void clk_master_div_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tunsigned long flags;\n\tunsigned int mckr;\n\tu8 div;\n\n\tspin_lock_irqsave(master->lock, flags);\n\tregmap_read(master->regmap, master->layout->offset, &mckr);\n\tspin_unlock_irqrestore(master->lock, flags);\n\n\tmckr &= master->layout->mask;\n\tdiv = (mckr >> MASTER_DIV_SHIFT) & MASTER_DIV_MASK;\n\tdiv = master->characteristics->divisors[div];\n\n\tif (div != DIV_ROUND_CLOSEST(master->pms.parent_rate, master->pms.rate))\n\t\tpr_warn(\"MCKR DIV not configured properly by firmware!\\n\");\n}\n\nstatic const struct clk_ops master_div_ops = {\n\t.prepare = clk_master_prepare,\n\t.is_prepared = clk_master_is_prepared,\n\t.recalc_rate = clk_master_div_recalc_rate,\n\t.save_context = clk_master_div_save_context,\n\t.restore_context = clk_master_div_restore_context,\n};\n\n \nstatic int clk_master_div_set(struct clk_master *master,\n\t\t\t      unsigned long parent_rate, int div)\n{\n\tconst struct clk_master_characteristics *characteristics =\n\t\t\t\t\t\tmaster->characteristics;\n\tunsigned long rate = parent_rate;\n\tunsigned int max_div = 0, div_index = 0, max_div_index = 0;\n\tunsigned int i, mckr, tmp;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(characteristics->divisors); i++) {\n\t\tif (!characteristics->divisors[i])\n\t\t\tbreak;\n\n\t\tif (div == characteristics->divisors[i])\n\t\t\tdiv_index = i;\n\n\t\tif (max_div < characteristics->divisors[i]) {\n\t\t\tmax_div = characteristics->divisors[i];\n\t\t\tmax_div_index = i;\n\t\t}\n\t}\n\n\tif (div > max_div)\n\t\tdiv_index = max_div_index;\n\n\tret = regmap_read(master->regmap, master->layout->offset, &mckr);\n\tif (ret)\n\t\treturn ret;\n\n\tmckr &= master->layout->mask;\n\ttmp = (mckr >> MASTER_DIV_SHIFT) & MASTER_DIV_MASK;\n\tif (tmp == div_index)\n\t\treturn 0;\n\n\trate /= characteristics->divisors[div_index];\n\tif (rate < characteristics->output.min)\n\t\tpr_warn(\"master clk div is underclocked\");\n\telse if (rate > characteristics->output.max)\n\t\tpr_warn(\"master clk div is overclocked\");\n\n\tmckr &= ~(MASTER_DIV_MASK << MASTER_DIV_SHIFT);\n\tmckr |= (div_index << MASTER_DIV_SHIFT);\n\tret = regmap_write(master->regmap, master->layout->offset, mckr);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (!clk_master_ready(master))\n\t\tcpu_relax();\n\n\tmaster->div = characteristics->divisors[div_index];\n\n\treturn 0;\n}\n\nstatic unsigned long clk_master_div_recalc_rate_chg(struct clk_hw *hw,\n\t\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\n\treturn DIV_ROUND_CLOSEST_ULL(parent_rate, master->div);\n}\n\nstatic void clk_master_div_restore_context_chg(struct clk_hw *hw)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(master->lock, flags);\n\tret = clk_master_div_set(master, master->pms.parent_rate,\n\t\t\t\t DIV_ROUND_CLOSEST(master->pms.parent_rate,\n\t\t\t\t\t\t   master->pms.rate));\n\tspin_unlock_irqrestore(master->lock, flags);\n\tif (ret)\n\t\tpr_warn(\"Failed to restore MCK DIV clock\\n\");\n}\n\nstatic const struct clk_ops master_div_ops_chg = {\n\t.prepare = clk_master_prepare,\n\t.is_prepared = clk_master_is_prepared,\n\t.recalc_rate = clk_master_div_recalc_rate_chg,\n\t.save_context = clk_master_div_save_context,\n\t.restore_context = clk_master_div_restore_context_chg,\n};\n\nstatic int clk_master_div_notifier_fn(struct notifier_block *notifier,\n\t\t\t\t      unsigned long code, void *data)\n{\n\tconst struct clk_master_characteristics *characteristics =\n\t\t\t\t\t\tmaster_div->characteristics;\n\tstruct clk_notifier_data *cnd = data;\n\tunsigned long flags, new_parent_rate, new_rate;\n\tunsigned int mckr, div, new_div = 0;\n\tint ret, i;\n\tlong tmp_diff;\n\tlong best_diff = -1;\n\n\tspin_lock_irqsave(master_div->lock, flags);\n\tswitch (code) {\n\tcase PRE_RATE_CHANGE:\n\t\t \n\t\tret = regmap_read(master_div->regmap, master_div->layout->offset,\n\t\t\t\t  &mckr);\n\t\tif (ret) {\n\t\t\tret = NOTIFY_STOP_MASK;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tmckr &= master_div->layout->mask;\n\t\tdiv = (mckr >> MASTER_DIV_SHIFT) & MASTER_DIV_MASK;\n\n\t\t \n\t\tclk_master_div_set(master_div,\n\t\t\t\t   cnd->old_rate * characteristics->divisors[div],\n\t\t\t\t   master_div->safe_div);\n\t\tbreak;\n\n\tcase POST_RATE_CHANGE:\n\t\t \n\t\tret = regmap_read(master_div->regmap, master_div->layout->offset,\n\t\t\t\t  &mckr);\n\t\tif (ret) {\n\t\t\tret = NOTIFY_STOP_MASK;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tmckr &= master_div->layout->mask;\n\t\tdiv = (mckr >> MASTER_DIV_SHIFT) & MASTER_DIV_MASK;\n\t\tnew_parent_rate = cnd->new_rate * characteristics->divisors[div];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(characteristics->divisors); i++) {\n\t\t\tif (!characteristics->divisors[i])\n\t\t\t\tbreak;\n\n\t\t\tnew_rate = DIV_ROUND_CLOSEST_ULL(new_parent_rate,\n\t\t\t\t\t\t\t characteristics->divisors[i]);\n\n\t\t\ttmp_diff = characteristics->output.max - new_rate;\n\t\t\tif (tmp_diff < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (best_diff < 0 || best_diff > tmp_diff) {\n\t\t\t\tnew_div = characteristics->divisors[i];\n\t\t\t\tbest_diff = tmp_diff;\n\t\t\t}\n\n\t\t\tif (!tmp_diff)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!new_div) {\n\t\t\tret = NOTIFY_STOP_MASK;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t \n\t\tclk_master_div_set(master_div, new_parent_rate,\n\t\t\t\t   new_div);\n\n\t\tret = NOTIFY_OK;\n\t\tbreak;\n\n\tdefault:\n\t\tret = NOTIFY_DONE;\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock_irqrestore(master_div->lock, flags);\n\n\treturn ret;\n}\n\nstatic struct notifier_block clk_master_div_notifier = {\n\t.notifier_call = clk_master_div_notifier_fn,\n};\n\nstatic void clk_sama7g5_master_best_diff(struct clk_rate_request *req,\n\t\t\t\t\t struct clk_hw *parent,\n\t\t\t\t\t unsigned long parent_rate,\n\t\t\t\t\t long *best_rate,\n\t\t\t\t\t long *best_diff,\n\t\t\t\t\t u32 div)\n{\n\tunsigned long tmp_rate, tmp_diff;\n\n\tif (div == MASTER_PRES_MAX)\n\t\ttmp_rate = parent_rate / 3;\n\telse\n\t\ttmp_rate = parent_rate >> div;\n\n\ttmp_diff = abs(req->rate - tmp_rate);\n\n\tif (*best_diff < 0 || *best_diff >= tmp_diff) {\n\t\t*best_rate = tmp_rate;\n\t\t*best_diff = tmp_diff;\n\t\treq->best_parent_rate = parent_rate;\n\t\treq->best_parent_hw = parent;\n\t}\n}\n\nstatic unsigned long clk_master_pres_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tconst struct clk_master_characteristics *characteristics =\n\t\t\t\t\t\tmaster->characteristics;\n\tunsigned long flags;\n\tunsigned int val, pres;\n\n\tspin_lock_irqsave(master->lock, flags);\n\tregmap_read(master->regmap, master->layout->offset, &val);\n\tspin_unlock_irqrestore(master->lock, flags);\n\n\tval &= master->layout->mask;\n\tpres = (val >> master->layout->pres_shift) & MASTER_PRES_MASK;\n\tif (pres == MASTER_PRES_MAX && characteristics->have_div3_pres)\n\t\tpres = 3;\n\telse\n\t\tpres = (1 << pres);\n\n\treturn DIV_ROUND_CLOSEST_ULL(parent_rate, pres);\n}\n\nstatic u8 clk_master_pres_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tunsigned long flags;\n\tunsigned int mckr;\n\n\tspin_lock_irqsave(master->lock, flags);\n\tregmap_read(master->regmap, master->layout->offset, &mckr);\n\tspin_unlock_irqrestore(master->lock, flags);\n\n\tmckr &= master->layout->mask;\n\n\treturn mckr & AT91_PMC_CSS;\n}\n\nstatic int clk_master_pres_save_context(struct clk_hw *hw)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tstruct clk_hw *parent_hw = clk_hw_get_parent(hw);\n\tunsigned long flags;\n\tunsigned int val, pres;\n\n\tspin_lock_irqsave(master->lock, flags);\n\tregmap_read(master->regmap, master->layout->offset, &val);\n\tspin_unlock_irqrestore(master->lock, flags);\n\n\tval &= master->layout->mask;\n\tpres = (val >> master->layout->pres_shift) & MASTER_PRES_MASK;\n\tif (pres == MASTER_PRES_MAX && master->characteristics->have_div3_pres)\n\t\tpres = 3;\n\telse\n\t\tpres = (1 << pres);\n\n\tmaster->pms.parent = val & AT91_PMC_CSS;\n\tmaster->pms.parent_rate = clk_hw_get_rate(parent_hw);\n\tmaster->pms.rate = DIV_ROUND_CLOSEST_ULL(master->pms.parent_rate, pres);\n\n\treturn 0;\n}\n\nstatic void clk_master_pres_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tunsigned long flags;\n\tunsigned int val, pres;\n\n\tspin_lock_irqsave(master->lock, flags);\n\tregmap_read(master->regmap, master->layout->offset, &val);\n\tspin_unlock_irqrestore(master->lock, flags);\n\n\tval &= master->layout->mask;\n\tpres = (val >> master->layout->pres_shift) & MASTER_PRES_MASK;\n\tif (pres == MASTER_PRES_MAX && master->characteristics->have_div3_pres)\n\t\tpres = 3;\n\telse\n\t\tpres = (1 << pres);\n\n\tif (master->pms.rate !=\n\t    DIV_ROUND_CLOSEST_ULL(master->pms.parent_rate, pres) ||\n\t    (master->pms.parent != (val & AT91_PMC_CSS)))\n\t\tpr_warn(\"MCKR PRES was not configured properly by firmware!\\n\");\n}\n\nstatic const struct clk_ops master_pres_ops = {\n\t.prepare = clk_master_prepare,\n\t.is_prepared = clk_master_is_prepared,\n\t.recalc_rate = clk_master_pres_recalc_rate,\n\t.get_parent = clk_master_pres_get_parent,\n\t.save_context = clk_master_pres_save_context,\n\t.restore_context = clk_master_pres_restore_context,\n};\n\nstatic struct clk_hw * __init\nat91_clk_register_master_internal(struct regmap *regmap,\n\t\tconst char *name, int num_parents,\n\t\tconst char **parent_names,\n\t\tstruct clk_hw **parent_hws,\n\t\tconst struct clk_master_layout *layout,\n\t\tconst struct clk_master_characteristics *characteristics,\n\t\tconst struct clk_ops *ops, spinlock_t *lock, u32 flags)\n{\n\tstruct clk_master *master;\n\tstruct clk_init_data init = {};\n\tstruct clk_hw *hw;\n\tunsigned int mckr;\n\tunsigned long irqflags;\n\tint ret;\n\n\tif (!name || !num_parents || !(parent_names || parent_hws) || !lock)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmaster = kzalloc(sizeof(*master), GFP_KERNEL);\n\tif (!master)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = ops;\n\tif (parent_hws)\n\t\tinit.parent_hws = (const struct clk_hw **)parent_hws;\n\telse\n\t\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\tinit.flags = flags;\n\n\tmaster->hw.init = &init;\n\tmaster->layout = layout;\n\tmaster->characteristics = characteristics;\n\tmaster->regmap = regmap;\n\tmaster->lock = lock;\n\n\tif (ops == &master_div_ops_chg) {\n\t\tspin_lock_irqsave(master->lock, irqflags);\n\t\tregmap_read(master->regmap, master->layout->offset, &mckr);\n\t\tspin_unlock_irqrestore(master->lock, irqflags);\n\n\t\tmckr &= layout->mask;\n\t\tmckr = (mckr >> MASTER_DIV_SHIFT) & MASTER_DIV_MASK;\n\t\tmaster->div = characteristics->divisors[mckr];\n\t}\n\n\thw = &master->hw;\n\tret = clk_hw_register(NULL, &master->hw);\n\tif (ret) {\n\t\tkfree(master);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstruct clk_hw * __init\nat91_clk_register_master_pres(struct regmap *regmap,\n\t\tconst char *name, int num_parents,\n\t\tconst char **parent_names,\n\t\tstruct clk_hw **parent_hws,\n\t\tconst struct clk_master_layout *layout,\n\t\tconst struct clk_master_characteristics *characteristics,\n\t\tspinlock_t *lock)\n{\n\treturn at91_clk_register_master_internal(regmap, name, num_parents,\n\t\t\t\t\t\t parent_names, parent_hws, layout,\n\t\t\t\t\t\t characteristics,\n\t\t\t\t\t\t &master_pres_ops,\n\t\t\t\t\t\t lock, CLK_SET_RATE_GATE);\n}\n\nstruct clk_hw * __init\nat91_clk_register_master_div(struct regmap *regmap,\n\t\tconst char *name, const char *parent_name,\n\t\tstruct clk_hw *parent_hw, const struct clk_master_layout *layout,\n\t\tconst struct clk_master_characteristics *characteristics,\n\t\tspinlock_t *lock, u32 flags, u32 safe_div)\n{\n\tconst struct clk_ops *ops;\n\tstruct clk_hw *hw;\n\n\tif (flags & CLK_SET_RATE_GATE)\n\t\tops = &master_div_ops;\n\telse\n\t\tops = &master_div_ops_chg;\n\n\thw = at91_clk_register_master_internal(regmap, name, 1,\n\t\t\t\t\t       parent_name ? &parent_name : NULL,\n\t\t\t\t\t       parent_hw ? &parent_hw : NULL, layout,\n\t\t\t\t\t       characteristics, ops,\n\t\t\t\t\t       lock, flags);\n\n\tif (!IS_ERR(hw) && safe_div) {\n\t\tmaster_div = to_clk_master(hw);\n\t\tmaster_div->safe_div = safe_div;\n\t\tclk_notifier_register(hw->clk,\n\t\t\t\t      &clk_master_div_notifier);\n\t}\n\n\treturn hw;\n}\n\nstatic unsigned long\nclk_sama7g5_master_recalc_rate(struct clk_hw *hw,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\n\treturn DIV_ROUND_CLOSEST_ULL(parent_rate, (1 << master->div));\n}\n\nstatic int clk_sama7g5_master_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t     struct clk_rate_request *req)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tstruct clk_hw *parent;\n\tlong best_rate = LONG_MIN, best_diff = LONG_MIN;\n\tunsigned long parent_rate;\n\tunsigned int div, i;\n\n\t \n\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\n\t\tparent = clk_hw_get_parent_by_index(hw, i);\n\t\tif (!parent)\n\t\t\tcontinue;\n\n\t\tparent_rate = clk_hw_get_rate(parent);\n\t\tif (!parent_rate)\n\t\t\tcontinue;\n\n\t\tfor (div = 0; div < MASTER_PRES_MAX + 1; div++) {\n\t\t\tclk_sama7g5_master_best_diff(req, parent, parent_rate,\n\t\t\t\t\t\t     &best_rate, &best_diff,\n\t\t\t\t\t\t     div);\n\t\t\tif (!best_diff)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!best_diff)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (master->chg_pid < 0)\n\t\tgoto end;\n\n\tparent = clk_hw_get_parent_by_index(hw, master->chg_pid);\n\tif (!parent)\n\t\tgoto end;\n\n\tfor (div = 0; div < MASTER_PRES_MAX + 1; div++) {\n\t\tstruct clk_rate_request req_parent;\n\t\tunsigned long req_rate;\n\n\t\tif (div == MASTER_PRES_MAX)\n\t\t\treq_rate = req->rate * 3;\n\t\telse\n\t\t\treq_rate = req->rate << div;\n\n\t\tclk_hw_forward_rate_request(hw, req, parent, &req_parent, req_rate);\n\t\tif (__clk_determine_rate(parent, &req_parent))\n\t\t\tcontinue;\n\n\t\tclk_sama7g5_master_best_diff(req, parent, req_parent.rate,\n\t\t\t\t\t     &best_rate, &best_diff, div);\n\n\t\tif (!best_diff)\n\t\t\tbreak;\n\t}\n\nend:\n\tpr_debug(\"MCK: %s, best_rate = %ld, parent clk: %s @ %ld\\n\",\n\t\t __func__, best_rate,\n\t\t __clk_get_name((req->best_parent_hw)->clk),\n\t\treq->best_parent_rate);\n\n\tif (best_rate < 0)\n\t\treturn -EINVAL;\n\n\treq->rate = best_rate;\n\n\treturn 0;\n}\n\nstatic u8 clk_sama7g5_master_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tunsigned long flags;\n\tu8 index;\n\n\tspin_lock_irqsave(master->lock, flags);\n\tindex = clk_mux_val_to_index(&master->hw, master->mux_table, 0,\n\t\t\t\t     master->parent);\n\tspin_unlock_irqrestore(master->lock, flags);\n\n\treturn index;\n}\n\nstatic int clk_sama7g5_master_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tunsigned long flags;\n\n\tif (index >= clk_hw_get_num_parents(hw))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(master->lock, flags);\n\tmaster->parent = clk_mux_index_to_val(master->mux_table, 0, index);\n\tspin_unlock_irqrestore(master->lock, flags);\n\n\treturn 0;\n}\n\nstatic void clk_sama7g5_master_set(struct clk_master *master,\n\t\t\t\t   unsigned int status)\n{\n\tunsigned long flags;\n\tunsigned int val, cparent;\n\tunsigned int enable = status ? AT91_PMC_MCR_V2_EN : 0;\n\tunsigned int parent = master->parent << PMC_MCR_CSS_SHIFT;\n\tunsigned int div = master->div << MASTER_DIV_SHIFT;\n\n\tspin_lock_irqsave(master->lock, flags);\n\n\tregmap_write(master->regmap, AT91_PMC_MCR_V2,\n\t\t     AT91_PMC_MCR_V2_ID(master->id));\n\tregmap_read(master->regmap, AT91_PMC_MCR_V2, &val);\n\tregmap_update_bits(master->regmap, AT91_PMC_MCR_V2,\n\t\t\t   enable | AT91_PMC_MCR_V2_CSS | AT91_PMC_MCR_V2_DIV |\n\t\t\t   AT91_PMC_MCR_V2_CMD | AT91_PMC_MCR_V2_ID_MSK,\n\t\t\t   enable | parent | div | AT91_PMC_MCR_V2_CMD |\n\t\t\t   AT91_PMC_MCR_V2_ID(master->id));\n\n\tcparent = (val & AT91_PMC_MCR_V2_CSS) >> PMC_MCR_CSS_SHIFT;\n\n\t \n\twhile ((cparent != master->parent) && !clk_master_ready(master))\n\t\tcpu_relax();\n\n\tspin_unlock_irqrestore(master->lock, flags);\n}\n\nstatic int clk_sama7g5_master_enable(struct clk_hw *hw)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\n\tclk_sama7g5_master_set(master, 1);\n\n\treturn 0;\n}\n\nstatic void clk_sama7g5_master_disable(struct clk_hw *hw)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(master->lock, flags);\n\n\tregmap_write(master->regmap, AT91_PMC_MCR_V2, master->id);\n\tregmap_update_bits(master->regmap, AT91_PMC_MCR_V2,\n\t\t\t   AT91_PMC_MCR_V2_EN | AT91_PMC_MCR_V2_CMD |\n\t\t\t   AT91_PMC_MCR_V2_ID_MSK,\n\t\t\t   AT91_PMC_MCR_V2_CMD |\n\t\t\t   AT91_PMC_MCR_V2_ID(master->id));\n\n\tspin_unlock_irqrestore(master->lock, flags);\n}\n\nstatic int clk_sama7g5_master_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tunsigned long flags;\n\tunsigned int val;\n\n\tspin_lock_irqsave(master->lock, flags);\n\n\tregmap_write(master->regmap, AT91_PMC_MCR_V2, master->id);\n\tregmap_read(master->regmap, AT91_PMC_MCR_V2, &val);\n\n\tspin_unlock_irqrestore(master->lock, flags);\n\n\treturn !!(val & AT91_PMC_MCR_V2_EN);\n}\n\nstatic int clk_sama7g5_master_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\tunsigned long div, flags;\n\n\tdiv = DIV_ROUND_CLOSEST(parent_rate, rate);\n\tif ((div > (1 << (MASTER_PRES_MAX - 1))) || (div & (div - 1)))\n\t\treturn -EINVAL;\n\n\tif (div == 3)\n\t\tdiv = MASTER_PRES_MAX;\n\telse if (div)\n\t\tdiv = ffs(div) - 1;\n\n\tspin_lock_irqsave(master->lock, flags);\n\tmaster->div = div;\n\tspin_unlock_irqrestore(master->lock, flags);\n\n\treturn 0;\n}\n\nstatic int clk_sama7g5_master_save_context(struct clk_hw *hw)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\n\tmaster->pms.status = clk_sama7g5_master_is_enabled(hw);\n\n\treturn 0;\n}\n\nstatic void clk_sama7g5_master_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_master *master = to_clk_master(hw);\n\n\tif (master->pms.status)\n\t\tclk_sama7g5_master_set(master, master->pms.status);\n}\n\nstatic const struct clk_ops sama7g5_master_ops = {\n\t.enable = clk_sama7g5_master_enable,\n\t.disable = clk_sama7g5_master_disable,\n\t.is_enabled = clk_sama7g5_master_is_enabled,\n\t.recalc_rate = clk_sama7g5_master_recalc_rate,\n\t.determine_rate = clk_sama7g5_master_determine_rate,\n\t.set_rate = clk_sama7g5_master_set_rate,\n\t.get_parent = clk_sama7g5_master_get_parent,\n\t.set_parent = clk_sama7g5_master_set_parent,\n\t.save_context = clk_sama7g5_master_save_context,\n\t.restore_context = clk_sama7g5_master_restore_context,\n};\n\nstruct clk_hw * __init\nat91_clk_sama7g5_register_master(struct regmap *regmap,\n\t\t\t\t const char *name, int num_parents,\n\t\t\t\t const char **parent_names,\n\t\t\t\t struct clk_hw **parent_hws,\n\t\t\t\t u32 *mux_table,\n\t\t\t\t spinlock_t *lock, u8 id,\n\t\t\t\t bool critical, int chg_pid)\n{\n\tstruct clk_master *master;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tunsigned long flags;\n\tunsigned int val;\n\tint ret;\n\n\tif (!name || !num_parents || !(parent_names || parent_hws) || !mux_table ||\n\t    !lock || id > MASTER_MAX_ID)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmaster = kzalloc(sizeof(*master), GFP_KERNEL);\n\tif (!master)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &sama7g5_master_ops;\n\tif (parent_hws)\n\t\tinit.parent_hws = (const struct clk_hw **)parent_hws;\n\telse\n\t\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\tinit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\n\tif (chg_pid >= 0)\n\t\tinit.flags |= CLK_SET_RATE_PARENT;\n\tif (critical)\n\t\tinit.flags |= CLK_IS_CRITICAL;\n\n\tmaster->hw.init = &init;\n\tmaster->regmap = regmap;\n\tmaster->id = id;\n\tmaster->chg_pid = chg_pid;\n\tmaster->lock = lock;\n\tmaster->mux_table = mux_table;\n\n\tspin_lock_irqsave(master->lock, flags);\n\tregmap_write(master->regmap, AT91_PMC_MCR_V2, master->id);\n\tregmap_read(master->regmap, AT91_PMC_MCR_V2, &val);\n\tmaster->parent = (val & AT91_PMC_MCR_V2_CSS) >> PMC_MCR_CSS_SHIFT;\n\tmaster->div = (val & AT91_PMC_MCR_V2_DIV) >> MASTER_DIV_SHIFT;\n\tspin_unlock_irqrestore(master->lock, flags);\n\n\thw = &master->hw;\n\tret = clk_hw_register(NULL, &master->hw);\n\tif (ret) {\n\t\tkfree(master);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nconst struct clk_master_layout at91rm9200_master_layout = {\n\t.mask = 0x31F,\n\t.pres_shift = 2,\n\t.offset = AT91_PMC_MCKR,\n};\n\nconst struct clk_master_layout at91sam9x5_master_layout = {\n\t.mask = 0x373,\n\t.pres_shift = 4,\n\t.offset = AT91_PMC_MCKR,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}