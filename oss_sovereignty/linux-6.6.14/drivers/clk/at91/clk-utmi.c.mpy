{
  "module_name": "clk-utmi.c",
  "hash_id": "4e4c4f1cccd5c52f48f2a29aa6e86c9cecf44c81dfc62dafae7006de036c6970",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/clk-utmi.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/of.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <soc/at91/atmel-sfr.h>\n\n#include \"pmc.h\"\n\n \n#define UTMI_RATE\t480000000\n\nstruct clk_utmi {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap_pmc;\n\tstruct regmap *regmap_sfr;\n\tstruct at91_clk_pms pms;\n};\n\n#define to_clk_utmi(hw) container_of(hw, struct clk_utmi, hw)\n\nstatic inline bool clk_utmi_ready(struct regmap *regmap)\n{\n\tunsigned int status;\n\n\tregmap_read(regmap, AT91_PMC_SR, &status);\n\n\treturn status & AT91_PMC_LOCKU;\n}\n\nstatic int clk_utmi_prepare(struct clk_hw *hw)\n{\n\tstruct clk_hw *hw_parent;\n\tstruct clk_utmi *utmi = to_clk_utmi(hw);\n\tunsigned int uckr = AT91_PMC_UPLLEN | AT91_PMC_UPLLCOUNT |\n\t\t\t    AT91_PMC_BIASEN;\n\tunsigned int utmi_ref_clk_freq;\n\tunsigned long parent_rate;\n\n\t \n\thw_parent = clk_hw_get_parent(hw);\n\tparent_rate = clk_hw_get_rate(hw_parent);\n\n\tswitch (parent_rate) {\n\tcase 12000000:\n\t\tutmi_ref_clk_freq = 0;\n\t\tbreak;\n\tcase 16000000:\n\t\tutmi_ref_clk_freq = 1;\n\t\tbreak;\n\tcase 24000000:\n\t\tutmi_ref_clk_freq = 2;\n\t\tbreak;\n\t \n\tcase 48000000:\n\t\tutmi_ref_clk_freq = 3;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"UTMICK: unsupported mainck rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (utmi->regmap_sfr) {\n\t\tregmap_update_bits(utmi->regmap_sfr, AT91_SFR_UTMICKTRIM,\n\t\t\t\t   AT91_UTMICKTRIM_FREQ, utmi_ref_clk_freq);\n\t} else if (utmi_ref_clk_freq) {\n\t\tpr_err(\"UTMICK: sfr node required\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(utmi->regmap_pmc, AT91_CKGR_UCKR, uckr, uckr);\n\n\twhile (!clk_utmi_ready(utmi->regmap_pmc))\n\t\tcpu_relax();\n\n\treturn 0;\n}\n\nstatic int clk_utmi_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_utmi *utmi = to_clk_utmi(hw);\n\n\treturn clk_utmi_ready(utmi->regmap_pmc);\n}\n\nstatic void clk_utmi_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_utmi *utmi = to_clk_utmi(hw);\n\n\tregmap_update_bits(utmi->regmap_pmc, AT91_CKGR_UCKR,\n\t\t\t   AT91_PMC_UPLLEN, 0);\n}\n\nstatic unsigned long clk_utmi_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\t \n\treturn UTMI_RATE;\n}\n\nstatic int clk_utmi_save_context(struct clk_hw *hw)\n{\n\tstruct clk_utmi *utmi = to_clk_utmi(hw);\n\n\tutmi->pms.status = clk_utmi_is_prepared(hw);\n\n\treturn 0;\n}\n\nstatic void clk_utmi_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_utmi *utmi = to_clk_utmi(hw);\n\n\tif (utmi->pms.status)\n\t\tclk_utmi_prepare(hw);\n}\n\nstatic const struct clk_ops utmi_ops = {\n\t.prepare = clk_utmi_prepare,\n\t.unprepare = clk_utmi_unprepare,\n\t.is_prepared = clk_utmi_is_prepared,\n\t.recalc_rate = clk_utmi_recalc_rate,\n\t.save_context = clk_utmi_save_context,\n\t.restore_context = clk_utmi_restore_context,\n};\n\nstatic struct clk_hw * __init\nat91_clk_register_utmi_internal(struct regmap *regmap_pmc,\n\t\t\t\tstruct regmap *regmap_sfr,\n\t\t\t\tconst char *name, const char *parent_name,\n\t\t\t\tstruct clk_hw *parent_hw,\n\t\t\t\tconst struct clk_ops *ops, unsigned long flags)\n{\n\tstruct clk_utmi *utmi;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tint ret;\n\n\tif (!(parent_name || parent_hw))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tutmi = kzalloc(sizeof(*utmi), GFP_KERNEL);\n\tif (!utmi)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = ops;\n\tif (parent_hw) {\n\t\tinit.parent_hws = parent_hw ? (const struct clk_hw **)&parent_hw : NULL;\n\t\tinit.num_parents = parent_hw ? 1 : 0;\n\t} else {\n\t\tinit.parent_names = parent_name ? &parent_name : NULL;\n\t\tinit.num_parents = parent_name ? 1 : 0;\n\t}\n\tinit.flags = flags;\n\n\tutmi->hw.init = &init;\n\tutmi->regmap_pmc = regmap_pmc;\n\tutmi->regmap_sfr = regmap_sfr;\n\n\thw = &utmi->hw;\n\tret = clk_hw_register(NULL, &utmi->hw);\n\tif (ret) {\n\t\tkfree(utmi);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstruct clk_hw * __init\nat91_clk_register_utmi(struct regmap *regmap_pmc, struct regmap *regmap_sfr,\n\t\t       const char *name, const char *parent_name,\n\t\t       struct clk_hw *parent_hw)\n{\n\treturn at91_clk_register_utmi_internal(regmap_pmc, regmap_sfr, name,\n\t\t\tparent_name, parent_hw, &utmi_ops, CLK_SET_RATE_GATE);\n}\n\nstatic int clk_utmi_sama7g5_prepare(struct clk_hw *hw)\n{\n\tstruct clk_utmi *utmi = to_clk_utmi(hw);\n\tstruct clk_hw *hw_parent;\n\tunsigned long parent_rate;\n\tunsigned int val;\n\n\thw_parent = clk_hw_get_parent(hw);\n\tparent_rate = clk_hw_get_rate(hw_parent);\n\n\tswitch (parent_rate) {\n\tcase 16000000:\n\t\tval = 0;\n\t\tbreak;\n\tcase 20000000:\n\t\tval = 2;\n\t\tbreak;\n\tcase 24000000:\n\t\tval = 3;\n\t\tbreak;\n\tcase 32000000:\n\t\tval = 5;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"UTMICK: unsupported main_xtal rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(utmi->regmap_pmc, AT91_PMC_XTALF, val);\n\n\treturn 0;\n\n}\n\nstatic int clk_utmi_sama7g5_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_utmi *utmi = to_clk_utmi(hw);\n\tstruct clk_hw *hw_parent;\n\tunsigned long parent_rate;\n\tunsigned int val;\n\n\thw_parent = clk_hw_get_parent(hw);\n\tparent_rate = clk_hw_get_rate(hw_parent);\n\n\tregmap_read(utmi->regmap_pmc, AT91_PMC_XTALF, &val);\n\tswitch (val & 0x7) {\n\tcase 0:\n\t\tif (parent_rate == 16000000)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 2:\n\t\tif (parent_rate == 20000000)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 3:\n\t\tif (parent_rate == 24000000)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 5:\n\t\tif (parent_rate == 32000000)\n\t\t\treturn 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int clk_utmi_sama7g5_save_context(struct clk_hw *hw)\n{\n\tstruct clk_utmi *utmi = to_clk_utmi(hw);\n\n\tutmi->pms.status = clk_utmi_sama7g5_is_prepared(hw);\n\n\treturn 0;\n}\n\nstatic void clk_utmi_sama7g5_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_utmi *utmi = to_clk_utmi(hw);\n\n\tif (utmi->pms.status)\n\t\tclk_utmi_sama7g5_prepare(hw);\n}\n\nstatic const struct clk_ops sama7g5_utmi_ops = {\n\t.prepare = clk_utmi_sama7g5_prepare,\n\t.is_prepared = clk_utmi_sama7g5_is_prepared,\n\t.recalc_rate = clk_utmi_recalc_rate,\n\t.save_context = clk_utmi_sama7g5_save_context,\n\t.restore_context = clk_utmi_sama7g5_restore_context,\n};\n\nstruct clk_hw * __init\nat91_clk_sama7g5_register_utmi(struct regmap *regmap_pmc, const char *name,\n\t\t\t       const char *parent_name, struct clk_hw *parent_hw)\n{\n\treturn at91_clk_register_utmi_internal(regmap_pmc, NULL, name,\n\t\t\tparent_name, parent_hw, &sama7g5_utmi_ops, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}