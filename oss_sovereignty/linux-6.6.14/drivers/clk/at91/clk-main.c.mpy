{
  "module_name": "clk-main.c",
  "hash_id": "b3ca42106f65664159392a35afc0a1880f3d7e954f84608c1ea9be0c2f3dfa61",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/clk-main.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/delay.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include \"pmc.h\"\n\n#define SLOW_CLOCK_FREQ\t\t32768\n#define MAINF_DIV\t\t16\n#define MAINFRDY_TIMEOUT\t(((MAINF_DIV + 1) * USEC_PER_SEC) / \\\n\t\t\t\t SLOW_CLOCK_FREQ)\n#define MAINF_LOOP_MIN_WAIT\t(USEC_PER_SEC / SLOW_CLOCK_FREQ)\n#define MAINF_LOOP_MAX_WAIT\tMAINFRDY_TIMEOUT\n\n#define MOR_KEY_MASK\t\t(0xff << 16)\n\n#define clk_main_parent_select(s)\t(((s) & \\\n\t\t\t\t\t(AT91_PMC_MOSCEN | \\\n\t\t\t\t\tAT91_PMC_OSCBYPASS)) ? 1 : 0)\n\nstruct clk_main_osc {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tstruct at91_clk_pms pms;\n};\n\n#define to_clk_main_osc(hw) container_of(hw, struct clk_main_osc, hw)\n\nstruct clk_main_rc_osc {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tunsigned long frequency;\n\tunsigned long accuracy;\n\tstruct at91_clk_pms pms;\n};\n\n#define to_clk_main_rc_osc(hw) container_of(hw, struct clk_main_rc_osc, hw)\n\nstruct clk_rm9200_main {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n};\n\n#define to_clk_rm9200_main(hw) container_of(hw, struct clk_rm9200_main, hw)\n\nstruct clk_sam9x5_main {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tstruct at91_clk_pms pms;\n\tu8 parent;\n};\n\n#define to_clk_sam9x5_main(hw) container_of(hw, struct clk_sam9x5_main, hw)\n\nstatic inline bool clk_main_osc_ready(struct regmap *regmap)\n{\n\tunsigned int status;\n\n\tregmap_read(regmap, AT91_PMC_SR, &status);\n\n\treturn status & AT91_PMC_MOSCS;\n}\n\nstatic int clk_main_osc_prepare(struct clk_hw *hw)\n{\n\tstruct clk_main_osc *osc = to_clk_main_osc(hw);\n\tstruct regmap *regmap = osc->regmap;\n\tu32 tmp;\n\n\tregmap_read(regmap, AT91_CKGR_MOR, &tmp);\n\ttmp &= ~MOR_KEY_MASK;\n\n\tif (tmp & AT91_PMC_OSCBYPASS)\n\t\treturn 0;\n\n\tif (!(tmp & AT91_PMC_MOSCEN)) {\n\t\ttmp |= AT91_PMC_MOSCEN | AT91_PMC_KEY;\n\t\tregmap_write(regmap, AT91_CKGR_MOR, tmp);\n\t}\n\n\twhile (!clk_main_osc_ready(regmap))\n\t\tcpu_relax();\n\n\treturn 0;\n}\n\nstatic void clk_main_osc_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_main_osc *osc = to_clk_main_osc(hw);\n\tstruct regmap *regmap = osc->regmap;\n\tu32 tmp;\n\n\tregmap_read(regmap, AT91_CKGR_MOR, &tmp);\n\tif (tmp & AT91_PMC_OSCBYPASS)\n\t\treturn;\n\n\tif (!(tmp & AT91_PMC_MOSCEN))\n\t\treturn;\n\n\ttmp &= ~(AT91_PMC_KEY | AT91_PMC_MOSCEN);\n\tregmap_write(regmap, AT91_CKGR_MOR, tmp | AT91_PMC_KEY);\n}\n\nstatic int clk_main_osc_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_main_osc *osc = to_clk_main_osc(hw);\n\tstruct regmap *regmap = osc->regmap;\n\tu32 tmp, status;\n\n\tregmap_read(regmap, AT91_CKGR_MOR, &tmp);\n\tif (tmp & AT91_PMC_OSCBYPASS)\n\t\treturn 1;\n\n\tregmap_read(regmap, AT91_PMC_SR, &status);\n\n\treturn (status & AT91_PMC_MOSCS) && clk_main_parent_select(tmp);\n}\n\nstatic int clk_main_osc_save_context(struct clk_hw *hw)\n{\n\tstruct clk_main_osc *osc = to_clk_main_osc(hw);\n\n\tosc->pms.status = clk_main_osc_is_prepared(hw);\n\n\treturn 0;\n}\n\nstatic void clk_main_osc_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_main_osc *osc = to_clk_main_osc(hw);\n\n\tif (osc->pms.status)\n\t\tclk_main_osc_prepare(hw);\n}\n\nstatic const struct clk_ops main_osc_ops = {\n\t.prepare = clk_main_osc_prepare,\n\t.unprepare = clk_main_osc_unprepare,\n\t.is_prepared = clk_main_osc_is_prepared,\n\t.save_context = clk_main_osc_save_context,\n\t.restore_context = clk_main_osc_restore_context,\n};\n\nstruct clk_hw * __init\nat91_clk_register_main_osc(struct regmap *regmap,\n\t\t\t   const char *name,\n\t\t\t   const char *parent_name,\n\t\t\t   struct clk_parent_data *parent_data,\n\t\t\t   bool bypass)\n{\n\tstruct clk_main_osc *osc;\n\tstruct clk_init_data init = {};\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tif (!name || !(parent_name || parent_data))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tosc = kzalloc(sizeof(*osc), GFP_KERNEL);\n\tif (!osc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &main_osc_ops;\n\tif (parent_data)\n\t\tinit.parent_data = (const struct clk_parent_data *)parent_data;\n\telse\n\t\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = CLK_IGNORE_UNUSED;\n\n\tosc->hw.init = &init;\n\tosc->regmap = regmap;\n\n\tif (bypass)\n\t\tregmap_update_bits(regmap,\n\t\t\t\t   AT91_CKGR_MOR, MOR_KEY_MASK |\n\t\t\t\t   AT91_PMC_OSCBYPASS,\n\t\t\t\t   AT91_PMC_OSCBYPASS | AT91_PMC_KEY);\n\n\thw = &osc->hw;\n\tret = clk_hw_register(NULL, &osc->hw);\n\tif (ret) {\n\t\tkfree(osc);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstatic bool clk_main_rc_osc_ready(struct regmap *regmap)\n{\n\tunsigned int status;\n\n\tregmap_read(regmap, AT91_PMC_SR, &status);\n\n\treturn !!(status & AT91_PMC_MOSCRCS);\n}\n\nstatic int clk_main_rc_osc_prepare(struct clk_hw *hw)\n{\n\tstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\n\tstruct regmap *regmap = osc->regmap;\n\tunsigned int mor;\n\n\tregmap_read(regmap, AT91_CKGR_MOR, &mor);\n\n\tif (!(mor & AT91_PMC_MOSCRCEN))\n\t\tregmap_update_bits(regmap, AT91_CKGR_MOR,\n\t\t\t\t   MOR_KEY_MASK | AT91_PMC_MOSCRCEN,\n\t\t\t\t   AT91_PMC_MOSCRCEN | AT91_PMC_KEY);\n\n\twhile (!clk_main_rc_osc_ready(regmap))\n\t\tcpu_relax();\n\n\treturn 0;\n}\n\nstatic void clk_main_rc_osc_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\n\tstruct regmap *regmap = osc->regmap;\n\tunsigned int mor;\n\n\tregmap_read(regmap, AT91_CKGR_MOR, &mor);\n\n\tif (!(mor & AT91_PMC_MOSCRCEN))\n\t\treturn;\n\n\tregmap_update_bits(regmap, AT91_CKGR_MOR,\n\t\t\t   MOR_KEY_MASK | AT91_PMC_MOSCRCEN, AT91_PMC_KEY);\n}\n\nstatic int clk_main_rc_osc_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\n\tstruct regmap *regmap = osc->regmap;\n\tunsigned int mor, status;\n\n\tregmap_read(regmap, AT91_CKGR_MOR, &mor);\n\tregmap_read(regmap, AT91_PMC_SR, &status);\n\n\treturn (mor & AT91_PMC_MOSCRCEN) && (status & AT91_PMC_MOSCRCS);\n}\n\nstatic unsigned long clk_main_rc_osc_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\n\n\treturn osc->frequency;\n}\n\nstatic unsigned long clk_main_rc_osc_recalc_accuracy(struct clk_hw *hw,\n\t\t\t\t\t\t     unsigned long parent_acc)\n{\n\tstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\n\n\treturn osc->accuracy;\n}\n\nstatic int clk_main_rc_osc_save_context(struct clk_hw *hw)\n{\n\tstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\n\n\tosc->pms.status = clk_main_rc_osc_is_prepared(hw);\n\n\treturn 0;\n}\n\nstatic void clk_main_rc_osc_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\n\n\tif (osc->pms.status)\n\t\tclk_main_rc_osc_prepare(hw);\n}\n\nstatic const struct clk_ops main_rc_osc_ops = {\n\t.prepare = clk_main_rc_osc_prepare,\n\t.unprepare = clk_main_rc_osc_unprepare,\n\t.is_prepared = clk_main_rc_osc_is_prepared,\n\t.recalc_rate = clk_main_rc_osc_recalc_rate,\n\t.recalc_accuracy = clk_main_rc_osc_recalc_accuracy,\n\t.save_context = clk_main_rc_osc_save_context,\n\t.restore_context = clk_main_rc_osc_restore_context,\n};\n\nstruct clk_hw * __init\nat91_clk_register_main_rc_osc(struct regmap *regmap,\n\t\t\t      const char *name,\n\t\t\t      u32 frequency, u32 accuracy)\n{\n\tstruct clk_main_rc_osc *osc;\n\tstruct clk_init_data init;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tif (!name || !frequency)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tosc = kzalloc(sizeof(*osc), GFP_KERNEL);\n\tif (!osc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &main_rc_osc_ops;\n\tinit.parent_names = NULL;\n\tinit.num_parents = 0;\n\tinit.flags = CLK_IGNORE_UNUSED;\n\n\tosc->hw.init = &init;\n\tosc->regmap = regmap;\n\tosc->frequency = frequency;\n\tosc->accuracy = accuracy;\n\n\thw = &osc->hw;\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(osc);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstatic int clk_main_probe_frequency(struct regmap *regmap)\n{\n\tunsigned long prep_time, timeout;\n\tunsigned int mcfr;\n\n\ttimeout = jiffies + usecs_to_jiffies(MAINFRDY_TIMEOUT);\n\tdo {\n\t\tprep_time = jiffies;\n\t\tregmap_read(regmap, AT91_CKGR_MCFR, &mcfr);\n\t\tif (mcfr & AT91_PMC_MAINRDY)\n\t\t\treturn 0;\n\t\tif (system_state < SYSTEM_RUNNING)\n\t\t\tudelay(MAINF_LOOP_MIN_WAIT);\n\t\telse\n\t\t\tusleep_range(MAINF_LOOP_MIN_WAIT, MAINF_LOOP_MAX_WAIT);\n\t} while (time_before(prep_time, timeout));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic unsigned long clk_main_recalc_rate(struct regmap *regmap,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tunsigned int mcfr;\n\n\tif (parent_rate)\n\t\treturn parent_rate;\n\n\tpr_warn(\"Main crystal frequency not set, using approximate value\\n\");\n\tregmap_read(regmap, AT91_CKGR_MCFR, &mcfr);\n\tif (!(mcfr & AT91_PMC_MAINRDY))\n\t\treturn 0;\n\n\treturn ((mcfr & AT91_PMC_MAINF) * SLOW_CLOCK_FREQ) / MAINF_DIV;\n}\n\nstatic int clk_rm9200_main_prepare(struct clk_hw *hw)\n{\n\tstruct clk_rm9200_main *clkmain = to_clk_rm9200_main(hw);\n\n\treturn clk_main_probe_frequency(clkmain->regmap);\n}\n\nstatic int clk_rm9200_main_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_rm9200_main *clkmain = to_clk_rm9200_main(hw);\n\tunsigned int status;\n\n\tregmap_read(clkmain->regmap, AT91_CKGR_MCFR, &status);\n\n\treturn !!(status & AT91_PMC_MAINRDY);\n}\n\nstatic unsigned long clk_rm9200_main_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_rm9200_main *clkmain = to_clk_rm9200_main(hw);\n\n\treturn clk_main_recalc_rate(clkmain->regmap, parent_rate);\n}\n\nstatic const struct clk_ops rm9200_main_ops = {\n\t.prepare = clk_rm9200_main_prepare,\n\t.is_prepared = clk_rm9200_main_is_prepared,\n\t.recalc_rate = clk_rm9200_main_recalc_rate,\n};\n\nstruct clk_hw * __init\nat91_clk_register_rm9200_main(struct regmap *regmap,\n\t\t\t      const char *name,\n\t\t\t      const char *parent_name,\n\t\t\t      struct clk_hw *parent_hw)\n{\n\tstruct clk_rm9200_main *clkmain;\n\tstruct clk_init_data init = {};\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!(parent_name || parent_hw))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tclkmain = kzalloc(sizeof(*clkmain), GFP_KERNEL);\n\tif (!clkmain)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &rm9200_main_ops;\n\tif (parent_hw)\n\t\tinit.parent_hws = (const struct clk_hw **)&parent_hw;\n\telse\n\t\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = 0;\n\n\tclkmain->hw.init = &init;\n\tclkmain->regmap = regmap;\n\n\thw = &clkmain->hw;\n\tret = clk_hw_register(NULL, &clkmain->hw);\n\tif (ret) {\n\t\tkfree(clkmain);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstatic inline bool clk_sam9x5_main_ready(struct regmap *regmap)\n{\n\tunsigned int status;\n\n\tregmap_read(regmap, AT91_PMC_SR, &status);\n\n\treturn !!(status & AT91_PMC_MOSCSELS);\n}\n\nstatic int clk_sam9x5_main_prepare(struct clk_hw *hw)\n{\n\tstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\n\tstruct regmap *regmap = clkmain->regmap;\n\n\twhile (!clk_sam9x5_main_ready(regmap))\n\t\tcpu_relax();\n\n\treturn clk_main_probe_frequency(regmap);\n}\n\nstatic int clk_sam9x5_main_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\n\n\treturn clk_sam9x5_main_ready(clkmain->regmap);\n}\n\nstatic unsigned long clk_sam9x5_main_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\n\n\treturn clk_main_recalc_rate(clkmain->regmap, parent_rate);\n}\n\nstatic int clk_sam9x5_main_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\n\tstruct regmap *regmap = clkmain->regmap;\n\tunsigned int tmp;\n\n\tif (index > 1)\n\t\treturn -EINVAL;\n\n\tregmap_read(regmap, AT91_CKGR_MOR, &tmp);\n\n\tif (index && !(tmp & AT91_PMC_MOSCSEL))\n\t\ttmp = AT91_PMC_MOSCSEL;\n\telse if (!index && (tmp & AT91_PMC_MOSCSEL))\n\t\ttmp = 0;\n\telse\n\t\treturn 0;\n\n\tregmap_update_bits(regmap, AT91_CKGR_MOR,\n\t\t\t   AT91_PMC_MOSCSEL | MOR_KEY_MASK,\n\t\t\t   tmp | AT91_PMC_KEY);\n\n\twhile (!clk_sam9x5_main_ready(regmap))\n\t\tcpu_relax();\n\n\treturn 0;\n}\n\nstatic u8 clk_sam9x5_main_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\n\tunsigned int status;\n\n\tregmap_read(clkmain->regmap, AT91_CKGR_MOR, &status);\n\n\treturn clk_main_parent_select(status);\n}\n\nstatic int clk_sam9x5_main_save_context(struct clk_hw *hw)\n{\n\tstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\n\n\tclkmain->pms.status = clk_main_rc_osc_is_prepared(&clkmain->hw);\n\tclkmain->pms.parent = clk_sam9x5_main_get_parent(&clkmain->hw);\n\n\treturn 0;\n}\n\nstatic void clk_sam9x5_main_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\n\tint ret;\n\n\tret = clk_sam9x5_main_set_parent(hw, clkmain->pms.parent);\n\tif (ret)\n\t\treturn;\n\n\tif (clkmain->pms.status)\n\t\tclk_sam9x5_main_prepare(hw);\n}\n\nstatic const struct clk_ops sam9x5_main_ops = {\n\t.prepare = clk_sam9x5_main_prepare,\n\t.is_prepared = clk_sam9x5_main_is_prepared,\n\t.recalc_rate = clk_sam9x5_main_recalc_rate,\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.set_parent = clk_sam9x5_main_set_parent,\n\t.get_parent = clk_sam9x5_main_get_parent,\n\t.save_context = clk_sam9x5_main_save_context,\n\t.restore_context = clk_sam9x5_main_restore_context,\n};\n\nstruct clk_hw * __init\nat91_clk_register_sam9x5_main(struct regmap *regmap,\n\t\t\t      const char *name,\n\t\t\t      const char **parent_names,\n\t\t\t      struct clk_hw **parent_hws,\n\t\t\t      int num_parents)\n{\n\tstruct clk_sam9x5_main *clkmain;\n\tstruct clk_init_data init = {};\n\tunsigned int status;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!(parent_hws || parent_names) || !num_parents)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tclkmain = kzalloc(sizeof(*clkmain), GFP_KERNEL);\n\tif (!clkmain)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &sam9x5_main_ops;\n\tif (parent_hws)\n\t\tinit.parent_hws = (const struct clk_hw **)parent_hws;\n\telse\n\t\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\tinit.flags = CLK_SET_PARENT_GATE;\n\n\tclkmain->hw.init = &init;\n\tclkmain->regmap = regmap;\n\tregmap_read(clkmain->regmap, AT91_CKGR_MOR, &status);\n\tclkmain->parent = clk_main_parent_select(status);\n\n\thw = &clkmain->hw;\n\tret = clk_hw_register(NULL, &clkmain->hw);\n\tif (ret) {\n\t\tkfree(clkmain);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}