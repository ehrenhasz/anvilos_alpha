{
  "module_name": "clk-system.c",
  "hash_id": "04bad69ec96162a0f3fea2beca3cefe6c95fc5a2744889a3491653a7ebd1dc4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/clk-system.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/of.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include \"pmc.h\"\n\n#define SYSTEM_MAX_ID\t\t31\n\n#define SYSTEM_MAX_NAME_SZ\t32\n\n#define to_clk_system(hw) container_of(hw, struct clk_system, hw)\nstruct clk_system {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tstruct at91_clk_pms pms;\n\tu8 id;\n};\n\nstatic inline int is_pck(int id)\n{\n\treturn (id >= 8) && (id <= 15);\n}\n\nstatic inline bool clk_system_ready(struct regmap *regmap, int id)\n{\n\tunsigned int status;\n\n\tregmap_read(regmap, AT91_PMC_SR, &status);\n\n\treturn !!(status & (1 << id));\n}\n\nstatic int clk_system_prepare(struct clk_hw *hw)\n{\n\tstruct clk_system *sys = to_clk_system(hw);\n\n\tregmap_write(sys->regmap, AT91_PMC_SCER, 1 << sys->id);\n\n\tif (!is_pck(sys->id))\n\t\treturn 0;\n\n\twhile (!clk_system_ready(sys->regmap, sys->id))\n\t\tcpu_relax();\n\n\treturn 0;\n}\n\nstatic void clk_system_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_system *sys = to_clk_system(hw);\n\n\tregmap_write(sys->regmap, AT91_PMC_SCDR, 1 << sys->id);\n}\n\nstatic int clk_system_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_system *sys = to_clk_system(hw);\n\tunsigned int status;\n\n\tregmap_read(sys->regmap, AT91_PMC_SCSR, &status);\n\n\tif (!(status & (1 << sys->id)))\n\t\treturn 0;\n\n\tif (!is_pck(sys->id))\n\t\treturn 1;\n\n\tregmap_read(sys->regmap, AT91_PMC_SR, &status);\n\n\treturn !!(status & (1 << sys->id));\n}\n\nstatic int clk_system_save_context(struct clk_hw *hw)\n{\n\tstruct clk_system *sys = to_clk_system(hw);\n\n\tsys->pms.status = clk_system_is_prepared(hw);\n\n\treturn 0;\n}\n\nstatic void clk_system_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_system *sys = to_clk_system(hw);\n\n\tif (sys->pms.status)\n\t\tclk_system_prepare(&sys->hw);\n}\n\nstatic const struct clk_ops system_ops = {\n\t.prepare = clk_system_prepare,\n\t.unprepare = clk_system_unprepare,\n\t.is_prepared = clk_system_is_prepared,\n\t.save_context = clk_system_save_context,\n\t.restore_context = clk_system_restore_context,\n};\n\nstruct clk_hw * __init\nat91_clk_register_system(struct regmap *regmap, const char *name,\n\t\t\t const char *parent_name, struct clk_hw *parent_hw, u8 id,\n\t\t\t unsigned long flags)\n{\n\tstruct clk_system *sys;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tint ret;\n\n\tif (!(parent_name || parent_hw) || id > SYSTEM_MAX_ID)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsys = kzalloc(sizeof(*sys), GFP_KERNEL);\n\tif (!sys)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &system_ops;\n\tif (parent_hw)\n\t\tinit.parent_hws = (const struct clk_hw **)&parent_hw;\n\telse\n\t\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = CLK_SET_RATE_PARENT | flags;\n\n\tsys->id = id;\n\tsys->hw.init = &init;\n\tsys->regmap = regmap;\n\n\thw = &sys->hw;\n\tret = clk_hw_register(NULL, &sys->hw);\n\tif (ret) {\n\t\tkfree(sys);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}