{
  "module_name": "clk-programmable.c",
  "hash_id": "1a8cb298e5cd3586e720b756f224c910d40f0c364fad691caa9b21652354b50c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/clk-programmable.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/of.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include \"pmc.h\"\n\n#define PROG_ID_MAX\t\t7\n\n#define PROG_STATUS_MASK(id)\t(1 << ((id) + 8))\n#define PROG_PRES(layout, pckr)\t((pckr >> layout->pres_shift) & layout->pres_mask)\n#define PROG_MAX_RM9200_CSS\t3\n\nstruct clk_programmable {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tu32 *mux_table;\n\tu8 id;\n\tconst struct clk_programmable_layout *layout;\n\tstruct at91_clk_pms pms;\n};\n\n#define to_clk_programmable(hw) container_of(hw, struct clk_programmable, hw)\n\nstatic unsigned long clk_programmable_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_programmable *prog = to_clk_programmable(hw);\n\tconst struct clk_programmable_layout *layout = prog->layout;\n\tunsigned int pckr;\n\tunsigned long rate;\n\n\tregmap_read(prog->regmap, AT91_PMC_PCKR(prog->id), &pckr);\n\n\tif (layout->is_pres_direct)\n\t\trate = parent_rate / (PROG_PRES(layout, pckr) + 1);\n\telse\n\t\trate = parent_rate >> PROG_PRES(layout, pckr);\n\n\treturn rate;\n}\n\nstatic int clk_programmable_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t   struct clk_rate_request *req)\n{\n\tstruct clk_programmable *prog = to_clk_programmable(hw);\n\tconst struct clk_programmable_layout *layout = prog->layout;\n\tstruct clk_hw *parent;\n\tlong best_rate = -EINVAL;\n\tunsigned long parent_rate;\n\tunsigned long tmp_rate = 0;\n\tint shift;\n\tint i;\n\n\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\n\t\tparent = clk_hw_get_parent_by_index(hw, i);\n\t\tif (!parent)\n\t\t\tcontinue;\n\n\t\tparent_rate = clk_hw_get_rate(parent);\n\t\tif (layout->is_pres_direct) {\n\t\t\tfor (shift = 0; shift <= layout->pres_mask; shift++) {\n\t\t\t\ttmp_rate = parent_rate / (shift + 1);\n\t\t\t\tif (tmp_rate <= req->rate)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (shift = 0; shift < layout->pres_mask; shift++) {\n\t\t\t\ttmp_rate = parent_rate >> shift;\n\t\t\t\tif (tmp_rate <= req->rate)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp_rate > req->rate)\n\t\t\tcontinue;\n\n\t\tif (best_rate < 0 ||\n\t\t    (req->rate - tmp_rate) < (req->rate - best_rate)) {\n\t\t\tbest_rate = tmp_rate;\n\t\t\treq->best_parent_rate = parent_rate;\n\t\t\treq->best_parent_hw = parent;\n\t\t}\n\n\t\tif (!best_rate)\n\t\t\tbreak;\n\t}\n\n\tif (best_rate < 0)\n\t\treturn best_rate;\n\n\treq->rate = best_rate;\n\treturn 0;\n}\n\nstatic int clk_programmable_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_programmable *prog = to_clk_programmable(hw);\n\tconst struct clk_programmable_layout *layout = prog->layout;\n\tunsigned int mask = layout->css_mask;\n\tunsigned int pckr = index;\n\n\tif (layout->have_slck_mck)\n\t\tmask |= AT91_PMC_CSSMCK_MCK;\n\n\tif (prog->mux_table)\n\t\tpckr = clk_mux_index_to_val(prog->mux_table, 0, index);\n\n\tif (index > layout->css_mask) {\n\t\tif (index > PROG_MAX_RM9200_CSS && !layout->have_slck_mck)\n\t\t\treturn -EINVAL;\n\n\t\tpckr |= AT91_PMC_CSSMCK_MCK;\n\t}\n\n\tregmap_update_bits(prog->regmap, AT91_PMC_PCKR(prog->id), mask, pckr);\n\n\treturn 0;\n}\n\nstatic u8 clk_programmable_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_programmable *prog = to_clk_programmable(hw);\n\tconst struct clk_programmable_layout *layout = prog->layout;\n\tunsigned int pckr;\n\tu8 ret;\n\n\tregmap_read(prog->regmap, AT91_PMC_PCKR(prog->id), &pckr);\n\n\tret = pckr & layout->css_mask;\n\n\tif (layout->have_slck_mck && (pckr & AT91_PMC_CSSMCK_MCK) && !ret)\n\t\tret = PROG_MAX_RM9200_CSS + 1;\n\n\tif (prog->mux_table)\n\t\tret = clk_mux_val_to_index(&prog->hw, prog->mux_table, 0, ret);\n\n\treturn ret;\n}\n\nstatic int clk_programmable_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct clk_programmable *prog = to_clk_programmable(hw);\n\tconst struct clk_programmable_layout *layout = prog->layout;\n\tunsigned long div = parent_rate / rate;\n\tint shift = 0;\n\n\tif (!div)\n\t\treturn -EINVAL;\n\n\tif (layout->is_pres_direct) {\n\t\tshift = div - 1;\n\n\t\tif (shift > layout->pres_mask)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tshift = fls(div) - 1;\n\n\t\tif (div != (1 << shift))\n\t\t\treturn -EINVAL;\n\n\t\tif (shift >= layout->pres_mask)\n\t\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(prog->regmap, AT91_PMC_PCKR(prog->id),\n\t\t\t   layout->pres_mask << layout->pres_shift,\n\t\t\t   shift << layout->pres_shift);\n\n\treturn 0;\n}\n\nstatic int clk_programmable_save_context(struct clk_hw *hw)\n{\n\tstruct clk_programmable *prog = to_clk_programmable(hw);\n\tstruct clk_hw *parent_hw = clk_hw_get_parent(hw);\n\n\tprog->pms.parent = clk_programmable_get_parent(hw);\n\tprog->pms.parent_rate = clk_hw_get_rate(parent_hw);\n\tprog->pms.rate = clk_programmable_recalc_rate(hw, prog->pms.parent_rate);\n\n\treturn 0;\n}\n\nstatic void clk_programmable_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_programmable *prog = to_clk_programmable(hw);\n\tint ret;\n\n\tret = clk_programmable_set_parent(hw, prog->pms.parent);\n\tif (ret)\n\t\treturn;\n\n\tclk_programmable_set_rate(hw, prog->pms.rate, prog->pms.parent_rate);\n}\n\nstatic const struct clk_ops programmable_ops = {\n\t.recalc_rate = clk_programmable_recalc_rate,\n\t.determine_rate = clk_programmable_determine_rate,\n\t.get_parent = clk_programmable_get_parent,\n\t.set_parent = clk_programmable_set_parent,\n\t.set_rate = clk_programmable_set_rate,\n\t.save_context = clk_programmable_save_context,\n\t.restore_context = clk_programmable_restore_context,\n};\n\nstruct clk_hw * __init\nat91_clk_register_programmable(struct regmap *regmap,\n\t\t\t       const char *name, const char **parent_names,\n\t\t\t       struct clk_hw **parent_hws, u8 num_parents, u8 id,\n\t\t\t       const struct clk_programmable_layout *layout,\n\t\t\t       u32 *mux_table)\n{\n\tstruct clk_programmable *prog;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tint ret;\n\n\tif (id > PROG_ID_MAX || !(parent_names || parent_hws))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tprog = kzalloc(sizeof(*prog), GFP_KERNEL);\n\tif (!prog)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &programmable_ops;\n\tif (parent_hws)\n\t\tinit.parent_hws = (const struct clk_hw **)parent_hws;\n\telse\n\t\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\tinit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\n\n\tprog->id = id;\n\tprog->layout = layout;\n\tprog->hw.init = &init;\n\tprog->regmap = regmap;\n\tprog->mux_table = mux_table;\n\n\thw = &prog->hw;\n\tret = clk_hw_register(NULL, &prog->hw);\n\tif (ret) {\n\t\tkfree(prog);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nconst struct clk_programmable_layout at91rm9200_programmable_layout = {\n\t.pres_mask = 0x7,\n\t.pres_shift = 2,\n\t.css_mask = 0x3,\n\t.have_slck_mck = 0,\n\t.is_pres_direct = 0,\n};\n\nconst struct clk_programmable_layout at91sam9g45_programmable_layout = {\n\t.pres_mask = 0x7,\n\t.pres_shift = 2,\n\t.css_mask = 0x3,\n\t.have_slck_mck = 1,\n\t.is_pres_direct = 0,\n};\n\nconst struct clk_programmable_layout at91sam9x5_programmable_layout = {\n\t.pres_mask = 0x7,\n\t.pres_shift = 4,\n\t.css_mask = 0x7,\n\t.have_slck_mck = 0,\n\t.is_pres_direct = 0,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}