{
  "module_name": "clk-audio-pll.c",
  "hash_id": "e9d7a6e66e2c1b30828867863450884f386a2c1e1124c6c4a0f2bccf260b9269",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/clk-audio-pll.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/of.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"pmc.h\"\n\n#define AUDIO_PLL_DIV_FRAC\tBIT(22)\n#define AUDIO_PLL_ND_MAX\t(AT91_PMC_AUDIO_PLL_ND_MASK >> \\\n\t\t\t\t\tAT91_PMC_AUDIO_PLL_ND_OFFSET)\n\n#define AUDIO_PLL_QDPAD(qd, div)\t((AT91_PMC_AUDIO_PLL_QDPAD_EXTDIV(qd) & \\\n\t\t\t\t\t  AT91_PMC_AUDIO_PLL_QDPAD_EXTDIV_MASK) | \\\n\t\t\t\t\t (AT91_PMC_AUDIO_PLL_QDPAD_DIV(div) & \\\n\t\t\t\t\t  AT91_PMC_AUDIO_PLL_QDPAD_DIV_MASK))\n\n#define AUDIO_PLL_QDPMC_MAX\t\t(AT91_PMC_AUDIO_PLL_QDPMC_MASK >> \\\n\t\t\t\t\t\tAT91_PMC_AUDIO_PLL_QDPMC_OFFSET)\n\n#define AUDIO_PLL_FOUT_MIN\t620000000UL\n#define AUDIO_PLL_FOUT_MAX\t700000000UL\n\nstruct clk_audio_frac {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tu32 fracr;\n\tu8 nd;\n};\n\nstruct clk_audio_pad {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tu8 qdaudio;\n\tu8 div;\n};\n\nstruct clk_audio_pmc {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tu8 qdpmc;\n};\n\n#define to_clk_audio_frac(hw) container_of(hw, struct clk_audio_frac, hw)\n#define to_clk_audio_pad(hw) container_of(hw, struct clk_audio_pad, hw)\n#define to_clk_audio_pmc(hw) container_of(hw, struct clk_audio_pmc, hw)\n\nstatic int clk_audio_pll_frac_enable(struct clk_hw *hw)\n{\n\tstruct clk_audio_frac *frac = to_clk_audio_frac(hw);\n\n\tregmap_update_bits(frac->regmap, AT91_PMC_AUDIO_PLL0,\n\t\t\t   AT91_PMC_AUDIO_PLL_RESETN, 0);\n\tregmap_update_bits(frac->regmap, AT91_PMC_AUDIO_PLL0,\n\t\t\t   AT91_PMC_AUDIO_PLL_RESETN,\n\t\t\t   AT91_PMC_AUDIO_PLL_RESETN);\n\tregmap_update_bits(frac->regmap, AT91_PMC_AUDIO_PLL1,\n\t\t\t   AT91_PMC_AUDIO_PLL_FRACR_MASK, frac->fracr);\n\n\t \n\tregmap_update_bits(frac->regmap, AT91_PMC_AUDIO_PLL0,\n\t\t\t   AT91_PMC_AUDIO_PLL_PLLEN |\n\t\t\t   AT91_PMC_AUDIO_PLL_ND_MASK,\n\t\t\t   AT91_PMC_AUDIO_PLL_PLLEN |\n\t\t\t   AT91_PMC_AUDIO_PLL_ND(frac->nd));\n\n\treturn 0;\n}\n\nstatic int clk_audio_pll_pad_enable(struct clk_hw *hw)\n{\n\tstruct clk_audio_pad *apad_ck = to_clk_audio_pad(hw);\n\n\tregmap_update_bits(apad_ck->regmap, AT91_PMC_AUDIO_PLL1,\n\t\t\t   AT91_PMC_AUDIO_PLL_QDPAD_MASK,\n\t\t\t   AUDIO_PLL_QDPAD(apad_ck->qdaudio, apad_ck->div));\n\tregmap_update_bits(apad_ck->regmap, AT91_PMC_AUDIO_PLL0,\n\t\t\t   AT91_PMC_AUDIO_PLL_PADEN, AT91_PMC_AUDIO_PLL_PADEN);\n\n\treturn 0;\n}\n\nstatic int clk_audio_pll_pmc_enable(struct clk_hw *hw)\n{\n\tstruct clk_audio_pmc *apmc_ck = to_clk_audio_pmc(hw);\n\n\tregmap_update_bits(apmc_ck->regmap, AT91_PMC_AUDIO_PLL0,\n\t\t\t   AT91_PMC_AUDIO_PLL_PMCEN |\n\t\t\t   AT91_PMC_AUDIO_PLL_QDPMC_MASK,\n\t\t\t   AT91_PMC_AUDIO_PLL_PMCEN |\n\t\t\t   AT91_PMC_AUDIO_PLL_QDPMC(apmc_ck->qdpmc));\n\treturn 0;\n}\n\nstatic void clk_audio_pll_frac_disable(struct clk_hw *hw)\n{\n\tstruct clk_audio_frac *frac = to_clk_audio_frac(hw);\n\n\tregmap_update_bits(frac->regmap, AT91_PMC_AUDIO_PLL0,\n\t\t\t   AT91_PMC_AUDIO_PLL_PLLEN, 0);\n\t \n\tregmap_update_bits(frac->regmap, AT91_PMC_AUDIO_PLL0,\n\t\t\t   AT91_PMC_AUDIO_PLL_RESETN, 0);\n}\n\nstatic void clk_audio_pll_pad_disable(struct clk_hw *hw)\n{\n\tstruct clk_audio_pad *apad_ck = to_clk_audio_pad(hw);\n\n\tregmap_update_bits(apad_ck->regmap, AT91_PMC_AUDIO_PLL0,\n\t\t\t   AT91_PMC_AUDIO_PLL_PADEN, 0);\n}\n\nstatic void clk_audio_pll_pmc_disable(struct clk_hw *hw)\n{\n\tstruct clk_audio_pmc *apmc_ck = to_clk_audio_pmc(hw);\n\n\tregmap_update_bits(apmc_ck->regmap, AT91_PMC_AUDIO_PLL0,\n\t\t\t   AT91_PMC_AUDIO_PLL_PMCEN, 0);\n}\n\nstatic unsigned long clk_audio_pll_fout(unsigned long parent_rate,\n\t\t\t\t\tunsigned long nd, unsigned long fracr)\n{\n\tunsigned long long fr = (unsigned long long)parent_rate * fracr;\n\n\tpr_debug(\"A PLL: %s, fr = %llu\\n\", __func__, fr);\n\n\tfr = DIV_ROUND_CLOSEST_ULL(fr, AUDIO_PLL_DIV_FRAC);\n\n\tpr_debug(\"A PLL: %s, fr = %llu\\n\", __func__, fr);\n\n\treturn parent_rate * (nd + 1) + fr;\n}\n\nstatic unsigned long clk_audio_pll_frac_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_audio_frac *frac = to_clk_audio_frac(hw);\n\tunsigned long fout;\n\n\tfout = clk_audio_pll_fout(parent_rate, frac->nd, frac->fracr);\n\n\tpr_debug(\"A PLL: %s, fout = %lu (nd = %u, fracr = %lu)\\n\", __func__,\n\t\t fout, frac->nd, (unsigned long)frac->fracr);\n\n\treturn fout;\n}\n\nstatic unsigned long clk_audio_pll_pad_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct clk_audio_pad *apad_ck = to_clk_audio_pad(hw);\n\tunsigned long apad_rate = 0;\n\n\tif (apad_ck->qdaudio && apad_ck->div)\n\t\tapad_rate = parent_rate / (apad_ck->qdaudio * apad_ck->div);\n\n\tpr_debug(\"A PLL/PAD: %s, apad_rate = %lu (div = %u, qdaudio = %u)\\n\",\n\t\t __func__, apad_rate, apad_ck->div, apad_ck->qdaudio);\n\n\treturn apad_rate;\n}\n\nstatic unsigned long clk_audio_pll_pmc_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct clk_audio_pmc *apmc_ck = to_clk_audio_pmc(hw);\n\tunsigned long apmc_rate = 0;\n\n\tapmc_rate = parent_rate / (apmc_ck->qdpmc + 1);\n\n\tpr_debug(\"A PLL/PMC: %s, apmc_rate = %lu (qdpmc = %u)\\n\", __func__,\n\t\t apmc_rate, apmc_ck->qdpmc);\n\n\treturn apmc_rate;\n}\n\nstatic int clk_audio_pll_frac_compute_frac(unsigned long rate,\n\t\t\t\t\t   unsigned long parent_rate,\n\t\t\t\t\t   unsigned long *nd,\n\t\t\t\t\t   unsigned long *fracr)\n{\n\tunsigned long long tmp, rem;\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\ttmp = rate;\n\trem = do_div(tmp, parent_rate);\n\tif (!tmp || tmp >= AUDIO_PLL_ND_MAX)\n\t\treturn -EINVAL;\n\n\t*nd = tmp - 1;\n\n\ttmp = rem * AUDIO_PLL_DIV_FRAC;\n\ttmp = DIV_ROUND_CLOSEST_ULL(tmp, parent_rate);\n\tif (tmp > AT91_PMC_AUDIO_PLL_FRACR_MASK)\n\t\treturn -EINVAL;\n\n\t \n\t*fracr = (unsigned long)tmp;\n\n\treturn 0;\n}\n\nstatic int clk_audio_pll_frac_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t     struct clk_rate_request *req)\n{\n\tunsigned long fracr, nd;\n\tint ret;\n\n\tpr_debug(\"A PLL: %s, rate = %lu (parent_rate = %lu)\\n\", __func__,\n\t\t req->rate, req->best_parent_rate);\n\n\treq->rate = clamp(req->rate, AUDIO_PLL_FOUT_MIN, AUDIO_PLL_FOUT_MAX);\n\n\treq->min_rate = max(req->min_rate, AUDIO_PLL_FOUT_MIN);\n\treq->max_rate = min(req->max_rate, AUDIO_PLL_FOUT_MAX);\n\n\tret = clk_audio_pll_frac_compute_frac(req->rate, req->best_parent_rate,\n\t\t\t\t\t      &nd, &fracr);\n\tif (ret)\n\t\treturn ret;\n\n\treq->rate = clk_audio_pll_fout(req->best_parent_rate, nd, fracr);\n\n\treq->best_parent_hw = clk_hw_get_parent(hw);\n\n\tpr_debug(\"A PLL: %s, best_rate = %lu (nd = %lu, fracr = %lu)\\n\",\n\t\t __func__, req->rate, nd, fracr);\n\n\treturn 0;\n}\n\nstatic long clk_audio_pll_pad_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t unsigned long *parent_rate)\n{\n\tstruct clk_hw *pclk = clk_hw_get_parent(hw);\n\tlong best_rate = -EINVAL;\n\tunsigned long best_parent_rate;\n\tunsigned long tmp_qd;\n\tu32 div;\n\tlong tmp_rate;\n\tint tmp_diff;\n\tint best_diff = -1;\n\n\tpr_debug(\"A PLL/PAD: %s, rate = %lu (parent_rate = %lu)\\n\", __func__,\n\t\t rate, *parent_rate);\n\n\t \n\tfor (tmp_qd = 1; tmp_qd < AT91_PMC_AUDIO_PLL_QDPAD_EXTDIV_MAX; tmp_qd++)\n\t\tfor (div = 2; div <= 3; div++) {\n\t\t\tif (div == 2 && tmp_qd % 3 == 0)\n\t\t\t\tcontinue;\n\n\t\t\tbest_parent_rate = clk_hw_round_rate(pclk,\n\t\t\t\t\t\t\trate * tmp_qd * div);\n\t\t\ttmp_rate = best_parent_rate / (div * tmp_qd);\n\t\t\ttmp_diff = abs(rate - tmp_rate);\n\n\t\t\tif (best_diff < 0 || best_diff > tmp_diff) {\n\t\t\t\t*parent_rate = best_parent_rate;\n\t\t\t\tbest_rate = tmp_rate;\n\t\t\t\tbest_diff = tmp_diff;\n\t\t\t}\n\t\t}\n\n\tpr_debug(\"A PLL/PAD: %s, best_rate = %ld, best_parent_rate = %lu\\n\",\n\t\t __func__, best_rate, best_parent_rate);\n\n\treturn best_rate;\n}\n\nstatic long clk_audio_pll_pmc_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t unsigned long *parent_rate)\n{\n\tstruct clk_hw *pclk = clk_hw_get_parent(hw);\n\tlong best_rate = -EINVAL;\n\tunsigned long best_parent_rate = 0;\n\tu32 tmp_qd = 0, div;\n\tlong tmp_rate;\n\tint tmp_diff;\n\tint best_diff = -1;\n\n\tpr_debug(\"A PLL/PMC: %s, rate = %lu (parent_rate = %lu)\\n\", __func__,\n\t\t rate, *parent_rate);\n\n\tif (!rate)\n\t\treturn 0;\n\n\tbest_parent_rate = clk_round_rate(pclk->clk, 1);\n\tdiv = max(best_parent_rate / rate, 1UL);\n\tfor (; div <= AUDIO_PLL_QDPMC_MAX; div++) {\n\t\tbest_parent_rate = clk_round_rate(pclk->clk, rate * div);\n\t\ttmp_rate = best_parent_rate / div;\n\t\ttmp_diff = abs(rate - tmp_rate);\n\n\t\tif (best_diff < 0 || best_diff > tmp_diff) {\n\t\t\t*parent_rate = best_parent_rate;\n\t\t\tbest_rate = tmp_rate;\n\t\t\tbest_diff = tmp_diff;\n\t\t\ttmp_qd = div;\n\t\t\tif (!best_diff)\n\t\t\t\tbreak;\t \n\t\t}\n\t}\n\n\tpr_debug(\"A PLL/PMC: %s, best_rate = %ld, best_parent_rate = %lu (qd = %d)\\n\",\n\t\t __func__, best_rate, *parent_rate, tmp_qd - 1);\n\n\treturn best_rate;\n}\n\nstatic int clk_audio_pll_frac_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct clk_audio_frac *frac = to_clk_audio_frac(hw);\n\tunsigned long fracr, nd;\n\tint ret;\n\n\tpr_debug(\"A PLL: %s, rate = %lu (parent_rate = %lu)\\n\", __func__, rate,\n\t\t parent_rate);\n\n\tif (rate < AUDIO_PLL_FOUT_MIN || rate > AUDIO_PLL_FOUT_MAX)\n\t\treturn -EINVAL;\n\n\tret = clk_audio_pll_frac_compute_frac(rate, parent_rate, &nd, &fracr);\n\tif (ret)\n\t\treturn ret;\n\n\tfrac->nd = nd;\n\tfrac->fracr = fracr;\n\n\treturn 0;\n}\n\nstatic int clk_audio_pll_pad_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct clk_audio_pad *apad_ck = to_clk_audio_pad(hw);\n\tu8 tmp_div;\n\n\tpr_debug(\"A PLL/PAD: %s, rate = %lu (parent_rate = %lu)\\n\", __func__,\n\t\t rate, parent_rate);\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\ttmp_div = parent_rate / rate;\n\tif (tmp_div % 3 == 0) {\n\t\tapad_ck->qdaudio = tmp_div / 3;\n\t\tapad_ck->div = 3;\n\t} else {\n\t\tapad_ck->qdaudio = tmp_div / 2;\n\t\tapad_ck->div = 2;\n\t}\n\n\treturn 0;\n}\n\nstatic int clk_audio_pll_pmc_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct clk_audio_pmc *apmc_ck = to_clk_audio_pmc(hw);\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"A PLL/PMC: %s, rate = %lu (parent_rate = %lu)\\n\", __func__,\n\t\t rate, parent_rate);\n\n\tapmc_ck->qdpmc = parent_rate / rate - 1;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops audio_pll_frac_ops = {\n\t.enable = clk_audio_pll_frac_enable,\n\t.disable = clk_audio_pll_frac_disable,\n\t.recalc_rate = clk_audio_pll_frac_recalc_rate,\n\t.determine_rate = clk_audio_pll_frac_determine_rate,\n\t.set_rate = clk_audio_pll_frac_set_rate,\n};\n\nstatic const struct clk_ops audio_pll_pad_ops = {\n\t.enable = clk_audio_pll_pad_enable,\n\t.disable = clk_audio_pll_pad_disable,\n\t.recalc_rate = clk_audio_pll_pad_recalc_rate,\n\t.round_rate = clk_audio_pll_pad_round_rate,\n\t.set_rate = clk_audio_pll_pad_set_rate,\n};\n\nstatic const struct clk_ops audio_pll_pmc_ops = {\n\t.enable = clk_audio_pll_pmc_enable,\n\t.disable = clk_audio_pll_pmc_disable,\n\t.recalc_rate = clk_audio_pll_pmc_recalc_rate,\n\t.round_rate = clk_audio_pll_pmc_round_rate,\n\t.set_rate = clk_audio_pll_pmc_set_rate,\n};\n\nstruct clk_hw * __init\nat91_clk_register_audio_pll_frac(struct regmap *regmap, const char *name,\n\t\t\t\t const char *parent_name)\n{\n\tstruct clk_audio_frac *frac_ck;\n\tstruct clk_init_data init = {};\n\tint ret;\n\n\tfrac_ck = kzalloc(sizeof(*frac_ck), GFP_KERNEL);\n\tif (!frac_ck)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &audio_pll_frac_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = CLK_SET_RATE_GATE;\n\n\tfrac_ck->hw.init = &init;\n\tfrac_ck->regmap = regmap;\n\n\tret = clk_hw_register(NULL, &frac_ck->hw);\n\tif (ret) {\n\t\tkfree(frac_ck);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn &frac_ck->hw;\n}\n\nstruct clk_hw * __init\nat91_clk_register_audio_pll_pad(struct regmap *regmap, const char *name,\n\t\t\t\tconst char *parent_name)\n{\n\tstruct clk_audio_pad *apad_ck;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tapad_ck = kzalloc(sizeof(*apad_ck), GFP_KERNEL);\n\tif (!apad_ck)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &audio_pll_pad_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE |\n\t\tCLK_SET_RATE_PARENT;\n\n\tapad_ck->hw.init = &init;\n\tapad_ck->regmap = regmap;\n\n\tret = clk_hw_register(NULL, &apad_ck->hw);\n\tif (ret) {\n\t\tkfree(apad_ck);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn &apad_ck->hw;\n}\n\nstruct clk_hw * __init\nat91_clk_register_audio_pll_pmc(struct regmap *regmap, const char *name,\n\t\t\t\tconst char *parent_name)\n{\n\tstruct clk_audio_pmc *apmc_ck;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tapmc_ck = kzalloc(sizeof(*apmc_ck), GFP_KERNEL);\n\tif (!apmc_ck)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &audio_pll_pmc_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE |\n\t\tCLK_SET_RATE_PARENT;\n\n\tapmc_ck->hw.init = &init;\n\tapmc_ck->regmap = regmap;\n\n\tret = clk_hw_register(NULL, &apmc_ck->hw);\n\tif (ret) {\n\t\tkfree(apmc_ck);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn &apmc_ck->hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}