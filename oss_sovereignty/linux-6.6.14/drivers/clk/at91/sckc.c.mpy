{
  "module_name": "sckc.c",
  "hash_id": "d283669157758f142e1c7a13074c4da90cb0e24464a29ec3ff2d662df9debf41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/sckc.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/io.h>\n\n#define SLOW_CLOCK_FREQ\t\t32768\n#define SLOWCK_SW_CYCLES\t5\n#define SLOWCK_SW_TIME_USEC\t((SLOWCK_SW_CYCLES * USEC_PER_SEC) / \\\n\t\t\t\t SLOW_CLOCK_FREQ)\n\n#define\tAT91_SCKC_CR\t\t\t0x00\n\nstruct clk_slow_bits {\n\tu32 cr_rcen;\n\tu32 cr_osc32en;\n\tu32 cr_osc32byp;\n\tu32 cr_oscsel;\n};\n\nstruct clk_slow_osc {\n\tstruct clk_hw hw;\n\tvoid __iomem *sckcr;\n\tconst struct clk_slow_bits *bits;\n\tunsigned long startup_usec;\n};\n\n#define to_clk_slow_osc(hw) container_of(hw, struct clk_slow_osc, hw)\n\nstruct clk_sama5d4_slow_osc {\n\tstruct clk_hw hw;\n\tvoid __iomem *sckcr;\n\tconst struct clk_slow_bits *bits;\n\tunsigned long startup_usec;\n\tbool prepared;\n};\n\n#define to_clk_sama5d4_slow_osc(hw) container_of(hw, struct clk_sama5d4_slow_osc, hw)\n\nstruct clk_slow_rc_osc {\n\tstruct clk_hw hw;\n\tvoid __iomem *sckcr;\n\tconst struct clk_slow_bits *bits;\n\tunsigned long frequency;\n\tunsigned long accuracy;\n\tunsigned long startup_usec;\n};\n\n#define to_clk_slow_rc_osc(hw) container_of(hw, struct clk_slow_rc_osc, hw)\n\nstruct clk_sam9x5_slow {\n\tstruct clk_hw hw;\n\tvoid __iomem *sckcr;\n\tconst struct clk_slow_bits *bits;\n\tu8 parent;\n};\n\n#define to_clk_sam9x5_slow(hw) container_of(hw, struct clk_sam9x5_slow, hw)\n\nstatic int clk_slow_osc_prepare(struct clk_hw *hw)\n{\n\tstruct clk_slow_osc *osc = to_clk_slow_osc(hw);\n\tvoid __iomem *sckcr = osc->sckcr;\n\tu32 tmp = readl(sckcr);\n\n\tif (tmp & (osc->bits->cr_osc32byp | osc->bits->cr_osc32en))\n\t\treturn 0;\n\n\twritel(tmp | osc->bits->cr_osc32en, sckcr);\n\n\tif (system_state < SYSTEM_RUNNING)\n\t\tudelay(osc->startup_usec);\n\telse\n\t\tusleep_range(osc->startup_usec, osc->startup_usec + 1);\n\n\treturn 0;\n}\n\nstatic void clk_slow_osc_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_slow_osc *osc = to_clk_slow_osc(hw);\n\tvoid __iomem *sckcr = osc->sckcr;\n\tu32 tmp = readl(sckcr);\n\n\tif (tmp & osc->bits->cr_osc32byp)\n\t\treturn;\n\n\twritel(tmp & ~osc->bits->cr_osc32en, sckcr);\n}\n\nstatic int clk_slow_osc_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_slow_osc *osc = to_clk_slow_osc(hw);\n\tvoid __iomem *sckcr = osc->sckcr;\n\tu32 tmp = readl(sckcr);\n\n\tif (tmp & osc->bits->cr_osc32byp)\n\t\treturn 1;\n\n\treturn !!(tmp & osc->bits->cr_osc32en);\n}\n\nstatic const struct clk_ops slow_osc_ops = {\n\t.prepare = clk_slow_osc_prepare,\n\t.unprepare = clk_slow_osc_unprepare,\n\t.is_prepared = clk_slow_osc_is_prepared,\n};\n\nstatic struct clk_hw * __init\nat91_clk_register_slow_osc(void __iomem *sckcr,\n\t\t\t   const char *name,\n\t\t\t   const struct clk_parent_data *parent_data,\n\t\t\t   unsigned long startup,\n\t\t\t   bool bypass,\n\t\t\t   const struct clk_slow_bits *bits)\n{\n\tstruct clk_slow_osc *osc;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tint ret;\n\n\tif (!sckcr || !name || !parent_data)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tosc = kzalloc(sizeof(*osc), GFP_KERNEL);\n\tif (!osc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &slow_osc_ops;\n\tinit.parent_data = parent_data;\n\tinit.num_parents = 1;\n\tinit.flags = CLK_IGNORE_UNUSED;\n\n\tosc->hw.init = &init;\n\tosc->sckcr = sckcr;\n\tosc->startup_usec = startup;\n\tosc->bits = bits;\n\n\tif (bypass)\n\t\twritel((readl(sckcr) & ~osc->bits->cr_osc32en) |\n\t\t\t\t\tosc->bits->cr_osc32byp, sckcr);\n\n\thw = &osc->hw;\n\tret = clk_hw_register(NULL, &osc->hw);\n\tif (ret) {\n\t\tkfree(osc);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstatic void at91_clk_unregister_slow_osc(struct clk_hw *hw)\n{\n\tstruct clk_slow_osc *osc = to_clk_slow_osc(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(osc);\n}\n\nstatic unsigned long clk_slow_rc_osc_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_slow_rc_osc *osc = to_clk_slow_rc_osc(hw);\n\n\treturn osc->frequency;\n}\n\nstatic unsigned long clk_slow_rc_osc_recalc_accuracy(struct clk_hw *hw,\n\t\t\t\t\t\t     unsigned long parent_acc)\n{\n\tstruct clk_slow_rc_osc *osc = to_clk_slow_rc_osc(hw);\n\n\treturn osc->accuracy;\n}\n\nstatic int clk_slow_rc_osc_prepare(struct clk_hw *hw)\n{\n\tstruct clk_slow_rc_osc *osc = to_clk_slow_rc_osc(hw);\n\tvoid __iomem *sckcr = osc->sckcr;\n\n\twritel(readl(sckcr) | osc->bits->cr_rcen, sckcr);\n\n\tif (system_state < SYSTEM_RUNNING)\n\t\tudelay(osc->startup_usec);\n\telse\n\t\tusleep_range(osc->startup_usec, osc->startup_usec + 1);\n\n\treturn 0;\n}\n\nstatic void clk_slow_rc_osc_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_slow_rc_osc *osc = to_clk_slow_rc_osc(hw);\n\tvoid __iomem *sckcr = osc->sckcr;\n\n\twritel(readl(sckcr) & ~osc->bits->cr_rcen, sckcr);\n}\n\nstatic int clk_slow_rc_osc_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_slow_rc_osc *osc = to_clk_slow_rc_osc(hw);\n\n\treturn !!(readl(osc->sckcr) & osc->bits->cr_rcen);\n}\n\nstatic const struct clk_ops slow_rc_osc_ops = {\n\t.prepare = clk_slow_rc_osc_prepare,\n\t.unprepare = clk_slow_rc_osc_unprepare,\n\t.is_prepared = clk_slow_rc_osc_is_prepared,\n\t.recalc_rate = clk_slow_rc_osc_recalc_rate,\n\t.recalc_accuracy = clk_slow_rc_osc_recalc_accuracy,\n};\n\nstatic struct clk_hw * __init\nat91_clk_register_slow_rc_osc(void __iomem *sckcr,\n\t\t\t      const char *name,\n\t\t\t      unsigned long frequency,\n\t\t\t      unsigned long accuracy,\n\t\t\t      unsigned long startup,\n\t\t\t      const struct clk_slow_bits *bits)\n{\n\tstruct clk_slow_rc_osc *osc;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tif (!sckcr || !name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tosc = kzalloc(sizeof(*osc), GFP_KERNEL);\n\tif (!osc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &slow_rc_osc_ops;\n\tinit.parent_names = NULL;\n\tinit.num_parents = 0;\n\tinit.flags = CLK_IGNORE_UNUSED;\n\n\tosc->hw.init = &init;\n\tosc->sckcr = sckcr;\n\tosc->bits = bits;\n\tosc->frequency = frequency;\n\tosc->accuracy = accuracy;\n\tosc->startup_usec = startup;\n\n\thw = &osc->hw;\n\tret = clk_hw_register(NULL, &osc->hw);\n\tif (ret) {\n\t\tkfree(osc);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstatic void at91_clk_unregister_slow_rc_osc(struct clk_hw *hw)\n{\n\tstruct clk_slow_rc_osc *osc = to_clk_slow_rc_osc(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(osc);\n}\n\nstatic int clk_sam9x5_slow_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_sam9x5_slow *slowck = to_clk_sam9x5_slow(hw);\n\tvoid __iomem *sckcr = slowck->sckcr;\n\tu32 tmp;\n\n\tif (index > 1)\n\t\treturn -EINVAL;\n\n\ttmp = readl(sckcr);\n\n\tif ((!index && !(tmp & slowck->bits->cr_oscsel)) ||\n\t    (index && (tmp & slowck->bits->cr_oscsel)))\n\t\treturn 0;\n\n\tif (index)\n\t\ttmp |= slowck->bits->cr_oscsel;\n\telse\n\t\ttmp &= ~slowck->bits->cr_oscsel;\n\n\twritel(tmp, sckcr);\n\n\tif (system_state < SYSTEM_RUNNING)\n\t\tudelay(SLOWCK_SW_TIME_USEC);\n\telse\n\t\tusleep_range(SLOWCK_SW_TIME_USEC, SLOWCK_SW_TIME_USEC + 1);\n\n\treturn 0;\n}\n\nstatic u8 clk_sam9x5_slow_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_sam9x5_slow *slowck = to_clk_sam9x5_slow(hw);\n\n\treturn !!(readl(slowck->sckcr) & slowck->bits->cr_oscsel);\n}\n\nstatic const struct clk_ops sam9x5_slow_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.set_parent = clk_sam9x5_slow_set_parent,\n\t.get_parent = clk_sam9x5_slow_get_parent,\n};\n\nstatic struct clk_hw * __init\nat91_clk_register_sam9x5_slow(void __iomem *sckcr,\n\t\t\t      const char *name,\n\t\t\t      const struct clk_hw **parent_hws,\n\t\t\t      int num_parents,\n\t\t\t      const struct clk_slow_bits *bits)\n{\n\tstruct clk_sam9x5_slow *slowck;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tint ret;\n\n\tif (!sckcr || !name || !parent_hws || !num_parents)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tslowck = kzalloc(sizeof(*slowck), GFP_KERNEL);\n\tif (!slowck)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &sam9x5_slow_ops;\n\tinit.parent_hws = parent_hws;\n\tinit.num_parents = num_parents;\n\tinit.flags = 0;\n\n\tslowck->hw.init = &init;\n\tslowck->sckcr = sckcr;\n\tslowck->bits = bits;\n\tslowck->parent = !!(readl(sckcr) & slowck->bits->cr_oscsel);\n\n\thw = &slowck->hw;\n\tret = clk_hw_register(NULL, &slowck->hw);\n\tif (ret) {\n\t\tkfree(slowck);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstatic void at91_clk_unregister_sam9x5_slow(struct clk_hw *hw)\n{\n\tstruct clk_sam9x5_slow *slowck = to_clk_sam9x5_slow(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(slowck);\n}\n\nstatic void __init at91sam9x5_sckc_register(struct device_node *np,\n\t\t\t\t\t    unsigned int rc_osc_startup_us,\n\t\t\t\t\t    const struct clk_slow_bits *bits)\n{\n\tvoid __iomem *regbase = of_iomap(np, 0);\n\tstruct device_node *child = NULL;\n\tconst char *xtal_name;\n\tstruct clk_hw *slow_rc, *slow_osc, *slowck;\n\tstatic struct clk_parent_data parent_data = {\n\t\t.name = \"slow_xtal\",\n\t};\n\tconst struct clk_hw *parent_hws[2];\n\tbool bypass;\n\tint ret;\n\n\tif (!regbase)\n\t\treturn;\n\n\tslow_rc = at91_clk_register_slow_rc_osc(regbase, \"slow_rc_osc\",\n\t\t\t\t\t\t32768, 50000000,\n\t\t\t\t\t\trc_osc_startup_us, bits);\n\tif (IS_ERR(slow_rc))\n\t\treturn;\n\n\txtal_name = of_clk_get_parent_name(np, 0);\n\tif (!xtal_name) {\n\t\t \n\t\tchild = of_get_compatible_child(np, \"atmel,at91sam9x5-clk-slow-osc\");\n\t\tif (!child)\n\t\t\tgoto unregister_slow_rc;\n\n\t\txtal_name = of_clk_get_parent_name(child, 0);\n\t\tbypass = of_property_read_bool(child, \"atmel,osc-bypass\");\n\n\t\tchild =  of_get_compatible_child(np, \"atmel,at91sam9x5-clk-slow\");\n\t} else {\n\t\tbypass = of_property_read_bool(np, \"atmel,osc-bypass\");\n\t}\n\n\tif (!xtal_name)\n\t\tgoto unregister_slow_rc;\n\n\tparent_data.fw_name = xtal_name;\n\n\tslow_osc = at91_clk_register_slow_osc(regbase, \"slow_osc\",\n\t\t\t\t\t      &parent_data, 1200000, bypass, bits);\n\tif (IS_ERR(slow_osc))\n\t\tgoto unregister_slow_rc;\n\n\tparent_hws[0] = slow_rc;\n\tparent_hws[1] = slow_osc;\n\tslowck = at91_clk_register_sam9x5_slow(regbase, \"slowck\", parent_hws,\n\t\t\t\t\t       2, bits);\n\tif (IS_ERR(slowck))\n\t\tgoto unregister_slow_osc;\n\n\t \n\tif (child)\n\t\tret = of_clk_add_hw_provider(child, of_clk_hw_simple_get,\n\t\t\t\t\t     slowck);\n\telse\n\t\tret = of_clk_add_hw_provider(np, of_clk_hw_simple_get, slowck);\n\n\tif (WARN_ON(ret))\n\t\tgoto unregister_slowck;\n\n\treturn;\n\nunregister_slowck:\n\tat91_clk_unregister_sam9x5_slow(slowck);\nunregister_slow_osc:\n\tat91_clk_unregister_slow_osc(slow_osc);\nunregister_slow_rc:\n\tat91_clk_unregister_slow_rc_osc(slow_rc);\n}\n\nstatic const struct clk_slow_bits at91sam9x5_bits = {\n\t.cr_rcen = BIT(0),\n\t.cr_osc32en = BIT(1),\n\t.cr_osc32byp = BIT(2),\n\t.cr_oscsel = BIT(3),\n};\n\nstatic void __init of_at91sam9x5_sckc_setup(struct device_node *np)\n{\n\tat91sam9x5_sckc_register(np, 75, &at91sam9x5_bits);\n}\nCLK_OF_DECLARE(at91sam9x5_clk_sckc, \"atmel,at91sam9x5-sckc\",\n\t       of_at91sam9x5_sckc_setup);\n\nstatic void __init of_sama5d3_sckc_setup(struct device_node *np)\n{\n\tat91sam9x5_sckc_register(np, 500, &at91sam9x5_bits);\n}\nCLK_OF_DECLARE(sama5d3_clk_sckc, \"atmel,sama5d3-sckc\",\n\t       of_sama5d3_sckc_setup);\n\nstatic const struct clk_slow_bits at91sam9x60_bits = {\n\t.cr_osc32en = BIT(1),\n\t.cr_osc32byp = BIT(2),\n\t.cr_oscsel = BIT(24),\n};\n\nstatic void __init of_sam9x60_sckc_setup(struct device_node *np)\n{\n\tvoid __iomem *regbase = of_iomap(np, 0);\n\tstruct clk_hw_onecell_data *clk_data;\n\tstruct clk_hw *slow_rc, *slow_osc;\n\tconst char *xtal_name;\n\tconst struct clk_hw *parent_hws[2];\n\tstatic struct clk_parent_data parent_data = {\n\t\t.name = \"slow_xtal\",\n\t};\n\tbool bypass;\n\tint ret;\n\n\tif (!regbase)\n\t\treturn;\n\n\tslow_rc = clk_hw_register_fixed_rate_with_accuracy(NULL, \"slow_rc_osc\",\n\t\t\t\t\t\t\t   NULL, 0, 32768,\n\t\t\t\t\t\t\t   93750000);\n\tif (IS_ERR(slow_rc))\n\t\treturn;\n\n\txtal_name = of_clk_get_parent_name(np, 0);\n\tif (!xtal_name)\n\t\tgoto unregister_slow_rc;\n\n\tparent_data.fw_name = xtal_name;\n\tbypass = of_property_read_bool(np, \"atmel,osc-bypass\");\n\tslow_osc = at91_clk_register_slow_osc(regbase, \"slow_osc\",\n\t\t\t\t\t      &parent_data, 5000000, bypass,\n\t\t\t\t\t      &at91sam9x60_bits);\n\tif (IS_ERR(slow_osc))\n\t\tgoto unregister_slow_rc;\n\n\tclk_data = kzalloc(struct_size(clk_data, hws, 2), GFP_KERNEL);\n\tif (!clk_data)\n\t\tgoto unregister_slow_osc;\n\n\t \n\tclk_data->num = 2;\n\tclk_data->hws[0] = clk_hw_register_fixed_rate_parent_hw(NULL, \"md_slck\",\n\t\t\t\t\t\t\t\tslow_rc,\n\t\t\t\t\t\t\t\t0, 32768);\n\tif (IS_ERR(clk_data->hws[0]))\n\t\tgoto clk_data_free;\n\n\tparent_hws[0] = slow_rc;\n\tparent_hws[1] = slow_osc;\n\tclk_data->hws[1] = at91_clk_register_sam9x5_slow(regbase, \"td_slck\",\n\t\t\t\t\t\t\t parent_hws, 2,\n\t\t\t\t\t\t\t &at91sam9x60_bits);\n\tif (IS_ERR(clk_data->hws[1]))\n\t\tgoto unregister_md_slck;\n\n\tret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_data);\n\tif (WARN_ON(ret))\n\t\tgoto unregister_td_slck;\n\n\treturn;\n\nunregister_td_slck:\n\tat91_clk_unregister_sam9x5_slow(clk_data->hws[1]);\nunregister_md_slck:\n\tclk_hw_unregister(clk_data->hws[0]);\nclk_data_free:\n\tkfree(clk_data);\nunregister_slow_osc:\n\tat91_clk_unregister_slow_osc(slow_osc);\nunregister_slow_rc:\n\tclk_hw_unregister(slow_rc);\n}\nCLK_OF_DECLARE(sam9x60_clk_sckc, \"microchip,sam9x60-sckc\",\n\t       of_sam9x60_sckc_setup);\n\nstatic int clk_sama5d4_slow_osc_prepare(struct clk_hw *hw)\n{\n\tstruct clk_sama5d4_slow_osc *osc = to_clk_sama5d4_slow_osc(hw);\n\n\tif (osc->prepared)\n\t\treturn 0;\n\n\t \n\tif ((readl(osc->sckcr) & osc->bits->cr_oscsel)) {\n\t\tosc->prepared = true;\n\t\treturn 0;\n\t}\n\n\tif (system_state < SYSTEM_RUNNING)\n\t\tudelay(osc->startup_usec);\n\telse\n\t\tusleep_range(osc->startup_usec, osc->startup_usec + 1);\n\tosc->prepared = true;\n\n\treturn 0;\n}\n\nstatic int clk_sama5d4_slow_osc_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_sama5d4_slow_osc *osc = to_clk_sama5d4_slow_osc(hw);\n\n\treturn osc->prepared;\n}\n\nstatic const struct clk_ops sama5d4_slow_osc_ops = {\n\t.prepare = clk_sama5d4_slow_osc_prepare,\n\t.is_prepared = clk_sama5d4_slow_osc_is_prepared,\n};\n\nstatic const struct clk_slow_bits at91sama5d4_bits = {\n\t.cr_oscsel = BIT(3),\n};\n\nstatic void __init of_sama5d4_sckc_setup(struct device_node *np)\n{\n\tvoid __iomem *regbase = of_iomap(np, 0);\n\tstruct clk_hw *slow_rc, *slowck;\n\tstruct clk_sama5d4_slow_osc *osc;\n\tstruct clk_init_data init = {};\n\tconst char *xtal_name;\n\tconst struct clk_hw *parent_hws[2];\n\tstatic struct clk_parent_data parent_data = {\n\t\t.name = \"slow_xtal\",\n\t};\n\tint ret;\n\n\tif (!regbase)\n\t\treturn;\n\n\tslow_rc = clk_hw_register_fixed_rate_with_accuracy(NULL,\n\t\t\t\t\t\t\t   \"slow_rc_osc\",\n\t\t\t\t\t\t\t   NULL, 0, 32768,\n\t\t\t\t\t\t\t   250000000);\n\tif (IS_ERR(slow_rc))\n\t\treturn;\n\n\txtal_name = of_clk_get_parent_name(np, 0);\n\tif (!xtal_name)\n\t\tgoto unregister_slow_rc;\n\tparent_data.fw_name = xtal_name;\n\n\tosc = kzalloc(sizeof(*osc), GFP_KERNEL);\n\tif (!osc)\n\t\tgoto unregister_slow_rc;\n\n\tinit.name = \"slow_osc\";\n\tinit.ops = &sama5d4_slow_osc_ops;\n\tinit.parent_data = &parent_data;\n\tinit.num_parents = 1;\n\tinit.flags = CLK_IGNORE_UNUSED;\n\n\tosc->hw.init = &init;\n\tosc->sckcr = regbase;\n\tosc->startup_usec = 1200000;\n\tosc->bits = &at91sama5d4_bits;\n\n\tret = clk_hw_register(NULL, &osc->hw);\n\tif (ret)\n\t\tgoto free_slow_osc_data;\n\n\tparent_hws[0] = slow_rc;\n\tparent_hws[1] = &osc->hw;\n\tslowck = at91_clk_register_sam9x5_slow(regbase, \"slowck\",\n\t\t\t\t\t       parent_hws, 2,\n\t\t\t\t\t       &at91sama5d4_bits);\n\tif (IS_ERR(slowck))\n\t\tgoto unregister_slow_osc;\n\n\tret = of_clk_add_hw_provider(np, of_clk_hw_simple_get, slowck);\n\tif (WARN_ON(ret))\n\t\tgoto unregister_slowck;\n\n\treturn;\n\nunregister_slowck:\n\tat91_clk_unregister_sam9x5_slow(slowck);\nunregister_slow_osc:\n\tclk_hw_unregister(&osc->hw);\nfree_slow_osc_data:\n\tkfree(osc);\nunregister_slow_rc:\n\tclk_hw_unregister(slow_rc);\n}\nCLK_OF_DECLARE(sama5d4_clk_sckc, \"atmel,sama5d4-sckc\",\n\t       of_sama5d4_sckc_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}