{
  "module_name": "clk-smd.c",
  "hash_id": "804355440face08d64e4b390d2c83db5331ec019780d38e36d682f5270109999",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/clk-smd.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/of.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include \"pmc.h\"\n\n#define SMD_DIV_SHIFT\t\t8\n#define SMD_MAX_DIV\t\t0xf\n\nstruct at91sam9x5_clk_smd {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n};\n\n#define to_at91sam9x5_clk_smd(hw) \\\n\tcontainer_of(hw, struct at91sam9x5_clk_smd, hw)\n\nstatic unsigned long at91sam9x5_clk_smd_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct at91sam9x5_clk_smd *smd = to_at91sam9x5_clk_smd(hw);\n\tunsigned int smdr;\n\tu8 smddiv;\n\n\tregmap_read(smd->regmap, AT91_PMC_SMD, &smdr);\n\tsmddiv = (smdr & AT91_PMC_SMD_DIV) >> SMD_DIV_SHIFT;\n\n\treturn parent_rate / (smddiv + 1);\n}\n\nstatic int at91sam9x5_clk_smd_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t     struct clk_rate_request *req)\n{\n\tunsigned long div;\n\tunsigned long bestrate;\n\tunsigned long tmp;\n\n\tif (req->rate >= req->best_parent_rate) {\n\t\treq->rate = req->best_parent_rate;\n\t\treturn 0;\n\t}\n\n\tdiv = req->best_parent_rate / req->rate;\n\tif (div > SMD_MAX_DIV) {\n\t\treq->rate = req->best_parent_rate / (SMD_MAX_DIV + 1);\n\t\treturn 0;\n\t}\n\n\tbestrate = req->best_parent_rate / div;\n\ttmp = req->best_parent_rate / (div + 1);\n\tif (bestrate - req->rate > req->rate - tmp)\n\t\tbestrate = tmp;\n\n\treq->rate = bestrate;\n\treturn 0;\n}\n\nstatic int at91sam9x5_clk_smd_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct at91sam9x5_clk_smd *smd = to_at91sam9x5_clk_smd(hw);\n\n\tif (index > 1)\n\t\treturn -EINVAL;\n\n\tregmap_update_bits(smd->regmap, AT91_PMC_SMD, AT91_PMC_SMDS,\n\t\t\t   index ? AT91_PMC_SMDS : 0);\n\n\treturn 0;\n}\n\nstatic u8 at91sam9x5_clk_smd_get_parent(struct clk_hw *hw)\n{\n\tstruct at91sam9x5_clk_smd *smd = to_at91sam9x5_clk_smd(hw);\n\tunsigned int smdr;\n\n\tregmap_read(smd->regmap, AT91_PMC_SMD, &smdr);\n\n\treturn smdr & AT91_PMC_SMDS;\n}\n\nstatic int at91sam9x5_clk_smd_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct at91sam9x5_clk_smd *smd = to_at91sam9x5_clk_smd(hw);\n\tunsigned long div = parent_rate / rate;\n\n\tif (parent_rate % rate || div < 1 || div > (SMD_MAX_DIV + 1))\n\t\treturn -EINVAL;\n\n\tregmap_update_bits(smd->regmap, AT91_PMC_SMD, AT91_PMC_SMD_DIV,\n\t\t\t   (div - 1) << SMD_DIV_SHIFT);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops at91sam9x5_smd_ops = {\n\t.recalc_rate = at91sam9x5_clk_smd_recalc_rate,\n\t.determine_rate = at91sam9x5_clk_smd_determine_rate,\n\t.get_parent = at91sam9x5_clk_smd_get_parent,\n\t.set_parent = at91sam9x5_clk_smd_set_parent,\n\t.set_rate = at91sam9x5_clk_smd_set_rate,\n};\n\nstruct clk_hw * __init\nat91sam9x5_clk_register_smd(struct regmap *regmap, const char *name,\n\t\t\t    const char **parent_names, u8 num_parents)\n{\n\tstruct at91sam9x5_clk_smd *smd;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tsmd = kzalloc(sizeof(*smd), GFP_KERNEL);\n\tif (!smd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &at91sam9x5_smd_ops;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\tinit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\n\n\tsmd->hw.init = &init;\n\tsmd->regmap = regmap;\n\n\thw = &smd->hw;\n\tret = clk_hw_register(NULL, &smd->hw);\n\tif (ret) {\n\t\tkfree(smd);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}