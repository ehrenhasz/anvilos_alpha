{
  "module_name": "clk-sam9x60-pll.c",
  "hash_id": "5bd69f2e3e901206a2450048e16a1be539486d02f5a87fda1a14c485986bf87a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/at91/clk-sam9x60-pll.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/of.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include \"pmc.h\"\n\n#define\tPMC_PLL_CTRL0_DIV_MSK\tGENMASK(7, 0)\n#define\tPMC_PLL_CTRL1_MUL_MSK\tGENMASK(31, 24)\n#define\tPMC_PLL_CTRL1_FRACR_MSK\tGENMASK(21, 0)\n\n#define PLL_DIV_MAX\t\t(FIELD_GET(PMC_PLL_CTRL0_DIV_MSK, UINT_MAX) + 1)\n#define UPLL_DIV\t\t2\n#define PLL_MUL_MAX\t\t(FIELD_GET(PMC_PLL_CTRL1_MUL_MSK, UINT_MAX) + 1)\n\n#define FCORE_MIN\t\t(600000000)\n#define FCORE_MAX\t\t(1200000000)\n\n#define PLL_MAX_ID\t\t7\n\nstruct sam9x60_pll_core {\n\tstruct regmap *regmap;\n\tspinlock_t *lock;\n\tconst struct clk_pll_characteristics *characteristics;\n\tconst struct clk_pll_layout *layout;\n\tstruct clk_hw hw;\n\tu8 id;\n};\n\nstruct sam9x60_frac {\n\tstruct sam9x60_pll_core core;\n\tstruct at91_clk_pms pms;\n\tu32 frac;\n\tu16 mul;\n};\n\nstruct sam9x60_div {\n\tstruct sam9x60_pll_core core;\n\tstruct at91_clk_pms pms;\n\tu8 div;\n\tu8 safe_div;\n};\n\n#define to_sam9x60_pll_core(hw)\tcontainer_of(hw, struct sam9x60_pll_core, hw)\n#define to_sam9x60_frac(core)\tcontainer_of(core, struct sam9x60_frac, core)\n#define to_sam9x60_div(core)\tcontainer_of(core, struct sam9x60_div, core)\n\nstatic struct sam9x60_div *notifier_div;\n\nstatic inline bool sam9x60_pll_ready(struct regmap *regmap, int id)\n{\n\tunsigned int status;\n\n\tregmap_read(regmap, AT91_PMC_PLL_ISR0, &status);\n\n\treturn !!(status & BIT(id));\n}\n\nstatic bool sam9x60_frac_pll_ready(struct regmap *regmap, u8 id)\n{\n\treturn sam9x60_pll_ready(regmap, id);\n}\n\nstatic unsigned long sam9x60_frac_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\tstruct sam9x60_frac *frac = to_sam9x60_frac(core);\n\n\treturn parent_rate * (frac->mul + 1) +\n\t\tDIV_ROUND_CLOSEST_ULL((u64)parent_rate * frac->frac, (1 << 22));\n}\n\nstatic int sam9x60_frac_pll_set(struct sam9x60_pll_core *core)\n{\n\tstruct sam9x60_frac *frac = to_sam9x60_frac(core);\n\tstruct regmap *regmap = core->regmap;\n\tunsigned int val, cfrac, cmul;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(core->lock, flags);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT,\n\t\t\t   AT91_PMC_PLL_UPDT_ID_MSK, core->id);\n\tregmap_read(regmap, AT91_PMC_PLL_CTRL1, &val);\n\tcmul = (val & core->layout->mul_mask) >> core->layout->mul_shift;\n\tcfrac = (val & core->layout->frac_mask) >> core->layout->frac_shift;\n\n\tif (sam9x60_frac_pll_ready(regmap, core->id) &&\n\t    (cmul == frac->mul && cfrac == frac->frac))\n\t\tgoto unlock;\n\n\t \n\tif (core->characteristics->upll)\n\t\tval = AT91_PMC_PLL_ACR_DEFAULT_UPLL;\n\telse\n\t\tval = AT91_PMC_PLL_ACR_DEFAULT_PLLA;\n\tregmap_write(regmap, AT91_PMC_PLL_ACR, val);\n\n\tregmap_write(regmap, AT91_PMC_PLL_CTRL1,\n\t\t     (frac->mul << core->layout->mul_shift) |\n\t\t     (frac->frac << core->layout->frac_shift));\n\n\tif (core->characteristics->upll) {\n\t\t \n\t\tval |= AT91_PMC_PLL_ACR_UTMIBG;\n\t\tregmap_write(regmap, AT91_PMC_PLL_ACR, val);\n\n\t\tudelay(10);\n\n\t\t \n\t\tval |= AT91_PMC_PLL_ACR_UTMIVR;\n\t\tregmap_write(regmap, AT91_PMC_PLL_ACR, val);\n\n\t\tudelay(10);\n\t}\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT,\n\t\t\t   AT91_PMC_PLL_UPDT_UPDATE | AT91_PMC_PLL_UPDT_ID_MSK,\n\t\t\t   AT91_PMC_PLL_UPDT_UPDATE | core->id);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_CTRL0,\n\t\t\t   AT91_PMC_PLL_CTRL0_ENLOCK | AT91_PMC_PLL_CTRL0_ENPLL,\n\t\t\t   AT91_PMC_PLL_CTRL0_ENLOCK | AT91_PMC_PLL_CTRL0_ENPLL);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT,\n\t\t\t   AT91_PMC_PLL_UPDT_UPDATE | AT91_PMC_PLL_UPDT_ID_MSK,\n\t\t\t   AT91_PMC_PLL_UPDT_UPDATE | core->id);\n\n\twhile (!sam9x60_pll_ready(regmap, core->id))\n\t\tcpu_relax();\n\nunlock:\n\tspin_unlock_irqrestore(core->lock, flags);\n\n\treturn 0;\n}\n\nstatic int sam9x60_frac_pll_prepare(struct clk_hw *hw)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\n\treturn sam9x60_frac_pll_set(core);\n}\n\nstatic void sam9x60_frac_pll_unprepare(struct clk_hw *hw)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\tstruct regmap *regmap = core->regmap;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(core->lock, flags);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT,\n\t\t\t   AT91_PMC_PLL_UPDT_ID_MSK, core->id);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_CTRL0, AT91_PMC_PLL_CTRL0_ENPLL, 0);\n\n\tif (core->characteristics->upll)\n\t\tregmap_update_bits(regmap, AT91_PMC_PLL_ACR,\n\t\t\t\t   AT91_PMC_PLL_ACR_UTMIBG | AT91_PMC_PLL_ACR_UTMIVR, 0);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT,\n\t\t\t   AT91_PMC_PLL_UPDT_UPDATE | AT91_PMC_PLL_UPDT_ID_MSK,\n\t\t\t   AT91_PMC_PLL_UPDT_UPDATE | core->id);\n\n\tspin_unlock_irqrestore(core->lock, flags);\n}\n\nstatic int sam9x60_frac_pll_is_prepared(struct clk_hw *hw)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\n\treturn sam9x60_pll_ready(core->regmap, core->id);\n}\n\nstatic long sam9x60_frac_pll_compute_mul_frac(struct sam9x60_pll_core *core,\n\t\t\t\t\t      unsigned long rate,\n\t\t\t\t\t      unsigned long parent_rate,\n\t\t\t\t\t      bool update)\n{\n\tstruct sam9x60_frac *frac = to_sam9x60_frac(core);\n\tunsigned long tmprate, remainder;\n\tunsigned long nmul = 0;\n\tunsigned long nfrac = 0;\n\n\tif (rate < FCORE_MIN || rate > FCORE_MAX)\n\t\treturn -ERANGE;\n\n\t \n\tnmul = mult_frac(rate, 1, parent_rate);\n\ttmprate = mult_frac(parent_rate, nmul, 1);\n\tremainder = rate - tmprate;\n\n\tif (remainder) {\n\t\tnfrac = DIV_ROUND_CLOSEST_ULL((u64)remainder * (1 << 22),\n\t\t\t\t\t      parent_rate);\n\n\t\ttmprate += DIV_ROUND_CLOSEST_ULL((u64)nfrac * parent_rate,\n\t\t\t\t\t\t (1 << 22));\n\t}\n\n\t \n\tif (tmprate < FCORE_MIN || tmprate > FCORE_MAX)\n\t\treturn -ERANGE;\n\n\tif (update) {\n\t\tfrac->mul = nmul - 1;\n\t\tfrac->frac = nfrac;\n\t}\n\n\treturn tmprate;\n}\n\nstatic long sam9x60_frac_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\tunsigned long *parent_rate)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\n\treturn sam9x60_frac_pll_compute_mul_frac(core, rate, *parent_rate, false);\n}\n\nstatic int sam9x60_frac_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\n\treturn sam9x60_frac_pll_compute_mul_frac(core, rate, parent_rate, true);\n}\n\nstatic int sam9x60_frac_pll_set_rate_chg(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\tstruct sam9x60_frac *frac = to_sam9x60_frac(core);\n\tstruct regmap *regmap = core->regmap;\n\tunsigned long irqflags;\n\tunsigned int val, cfrac, cmul;\n\tlong ret;\n\n\tret = sam9x60_frac_pll_compute_mul_frac(core, rate, parent_rate, true);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tspin_lock_irqsave(core->lock, irqflags);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT, AT91_PMC_PLL_UPDT_ID_MSK,\n\t\t\t   core->id);\n\tregmap_read(regmap, AT91_PMC_PLL_CTRL1, &val);\n\tcmul = (val & core->layout->mul_mask) >> core->layout->mul_shift;\n\tcfrac = (val & core->layout->frac_mask) >> core->layout->frac_shift;\n\n\tif (cmul == frac->mul && cfrac == frac->frac)\n\t\tgoto unlock;\n\n\tregmap_write(regmap, AT91_PMC_PLL_CTRL1,\n\t\t     (frac->mul << core->layout->mul_shift) |\n\t\t     (frac->frac << core->layout->frac_shift));\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT,\n\t\t\t   AT91_PMC_PLL_UPDT_UPDATE | AT91_PMC_PLL_UPDT_ID_MSK,\n\t\t\t   AT91_PMC_PLL_UPDT_UPDATE | core->id);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_CTRL0,\n\t\t\t   AT91_PMC_PLL_CTRL0_ENLOCK | AT91_PMC_PLL_CTRL0_ENPLL,\n\t\t\t   AT91_PMC_PLL_CTRL0_ENLOCK |\n\t\t\t   AT91_PMC_PLL_CTRL0_ENPLL);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT,\n\t\t\t   AT91_PMC_PLL_UPDT_UPDATE | AT91_PMC_PLL_UPDT_ID_MSK,\n\t\t\t   AT91_PMC_PLL_UPDT_UPDATE | core->id);\n\n\twhile (!sam9x60_pll_ready(regmap, core->id))\n\t\tcpu_relax();\n\nunlock:\n\tspin_unlock_irqrestore(core->lock, irqflags);\n\n\treturn ret;\n}\n\nstatic int sam9x60_frac_pll_save_context(struct clk_hw *hw)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\tstruct sam9x60_frac *frac = to_sam9x60_frac(core);\n\n\tfrac->pms.status = sam9x60_pll_ready(core->regmap, core->id);\n\n\treturn 0;\n}\n\nstatic void sam9x60_frac_pll_restore_context(struct clk_hw *hw)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\tstruct sam9x60_frac *frac = to_sam9x60_frac(core);\n\n\tif (frac->pms.status)\n\t\tsam9x60_frac_pll_set(core);\n}\n\nstatic const struct clk_ops sam9x60_frac_pll_ops = {\n\t.prepare = sam9x60_frac_pll_prepare,\n\t.unprepare = sam9x60_frac_pll_unprepare,\n\t.is_prepared = sam9x60_frac_pll_is_prepared,\n\t.recalc_rate = sam9x60_frac_pll_recalc_rate,\n\t.round_rate = sam9x60_frac_pll_round_rate,\n\t.set_rate = sam9x60_frac_pll_set_rate,\n\t.save_context = sam9x60_frac_pll_save_context,\n\t.restore_context = sam9x60_frac_pll_restore_context,\n};\n\nstatic const struct clk_ops sam9x60_frac_pll_ops_chg = {\n\t.prepare = sam9x60_frac_pll_prepare,\n\t.unprepare = sam9x60_frac_pll_unprepare,\n\t.is_prepared = sam9x60_frac_pll_is_prepared,\n\t.recalc_rate = sam9x60_frac_pll_recalc_rate,\n\t.round_rate = sam9x60_frac_pll_round_rate,\n\t.set_rate = sam9x60_frac_pll_set_rate_chg,\n\t.save_context = sam9x60_frac_pll_save_context,\n\t.restore_context = sam9x60_frac_pll_restore_context,\n};\n\n \nstatic void sam9x60_div_pll_set_div(struct sam9x60_pll_core *core, u32 div,\n\t\t\t\t    bool enable)\n{\n\tstruct regmap *regmap = core->regmap;\n\tu32 ena_msk = enable ? core->layout->endiv_mask : 0;\n\tu32 ena_val = enable ? (1 << core->layout->endiv_shift) : 0;\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_CTRL0,\n\t\t\t   core->layout->div_mask | ena_msk,\n\t\t\t   (div << core->layout->div_shift) | ena_val);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT,\n\t\t\t   AT91_PMC_PLL_UPDT_UPDATE | AT91_PMC_PLL_UPDT_ID_MSK,\n\t\t\t   AT91_PMC_PLL_UPDT_UPDATE | core->id);\n\n\twhile (!sam9x60_pll_ready(regmap, core->id))\n\t\tcpu_relax();\n}\n\nstatic int sam9x60_div_pll_set(struct sam9x60_pll_core *core)\n{\n\tstruct sam9x60_div *div = to_sam9x60_div(core);\n\tstruct regmap *regmap = core->regmap;\n\tunsigned long flags;\n\tunsigned int val, cdiv;\n\n\tspin_lock_irqsave(core->lock, flags);\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT,\n\t\t\t   AT91_PMC_PLL_UPDT_ID_MSK, core->id);\n\tregmap_read(regmap, AT91_PMC_PLL_CTRL0, &val);\n\tcdiv = (val & core->layout->div_mask) >> core->layout->div_shift;\n\n\t \n\tif (!!(val & core->layout->endiv_mask) && cdiv == div->div)\n\t\tgoto unlock;\n\n\tsam9x60_div_pll_set_div(core, div->div, 1);\n\nunlock:\n\tspin_unlock_irqrestore(core->lock, flags);\n\n\treturn 0;\n}\n\nstatic int sam9x60_div_pll_prepare(struct clk_hw *hw)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\n\treturn sam9x60_div_pll_set(core);\n}\n\nstatic void sam9x60_div_pll_unprepare(struct clk_hw *hw)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\tstruct regmap *regmap = core->regmap;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(core->lock, flags);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT,\n\t\t\t   AT91_PMC_PLL_UPDT_ID_MSK, core->id);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_CTRL0,\n\t\t\t   core->layout->endiv_mask, 0);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT,\n\t\t\t   AT91_PMC_PLL_UPDT_UPDATE | AT91_PMC_PLL_UPDT_ID_MSK,\n\t\t\t   AT91_PMC_PLL_UPDT_UPDATE | core->id);\n\n\tspin_unlock_irqrestore(core->lock, flags);\n}\n\nstatic int sam9x60_div_pll_is_prepared(struct clk_hw *hw)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\tstruct regmap *regmap = core->regmap;\n\tunsigned long flags;\n\tunsigned int val;\n\n\tspin_lock_irqsave(core->lock, flags);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT,\n\t\t\t   AT91_PMC_PLL_UPDT_ID_MSK, core->id);\n\tregmap_read(regmap, AT91_PMC_PLL_CTRL0, &val);\n\n\tspin_unlock_irqrestore(core->lock, flags);\n\n\treturn !!(val & core->layout->endiv_mask);\n}\n\nstatic unsigned long sam9x60_div_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\tstruct sam9x60_div *div = to_sam9x60_div(core);\n\n\treturn DIV_ROUND_CLOSEST_ULL(parent_rate, (div->div + 1));\n}\n\nstatic long sam9x60_div_pll_compute_div(struct sam9x60_pll_core *core,\n\t\t\t\t\tunsigned long *parent_rate,\n\t\t\t\t\tunsigned long rate)\n{\n\tconst struct clk_pll_characteristics *characteristics =\n\t\t\t\t\t\t\tcore->characteristics;\n\tstruct clk_hw *parent = clk_hw_get_parent(&core->hw);\n\tunsigned long tmp_rate, tmp_parent_rate, tmp_diff;\n\tlong best_diff = -1, best_rate = -EINVAL;\n\tu32 divid;\n\n\tif (!rate)\n\t\treturn 0;\n\n\tif (rate < characteristics->output[0].min ||\n\t    rate > characteristics->output[0].max)\n\t\treturn -ERANGE;\n\n\tfor (divid = 1; divid < core->layout->div_mask; divid++) {\n\t\ttmp_parent_rate = clk_hw_round_rate(parent, rate * divid);\n\t\tif (!tmp_parent_rate)\n\t\t\tcontinue;\n\n\t\ttmp_rate = DIV_ROUND_CLOSEST_ULL(tmp_parent_rate, divid);\n\t\ttmp_diff = abs(rate - tmp_rate);\n\n\t\tif (best_diff < 0 || best_diff > tmp_diff) {\n\t\t\t*parent_rate = tmp_parent_rate;\n\t\t\tbest_rate = tmp_rate;\n\t\t\tbest_diff = tmp_diff;\n\t\t}\n\n\t\tif (!best_diff)\n\t\t\tbreak;\n\t}\n\n\tif (best_rate < characteristics->output[0].min ||\n\t    best_rate > characteristics->output[0].max)\n\t\treturn -ERANGE;\n\n\treturn best_rate;\n}\n\nstatic long sam9x60_div_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long *parent_rate)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\n\treturn sam9x60_div_pll_compute_div(core, parent_rate, rate);\n}\n\nstatic int sam9x60_div_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\tstruct sam9x60_div *div = to_sam9x60_div(core);\n\n\tdiv->div = DIV_ROUND_CLOSEST(parent_rate, rate) - 1;\n\n\treturn 0;\n}\n\nstatic int sam9x60_div_pll_set_rate_chg(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\tstruct sam9x60_div *div = to_sam9x60_div(core);\n\tstruct regmap *regmap = core->regmap;\n\tunsigned long irqflags;\n\tunsigned int val, cdiv;\n\n\tdiv->div = DIV_ROUND_CLOSEST(parent_rate, rate) - 1;\n\n\tspin_lock_irqsave(core->lock, irqflags);\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT, AT91_PMC_PLL_UPDT_ID_MSK,\n\t\t\t   core->id);\n\tregmap_read(regmap, AT91_PMC_PLL_CTRL0, &val);\n\tcdiv = (val & core->layout->div_mask) >> core->layout->div_shift;\n\n\t \n\tif (cdiv == div->div)\n\t\tgoto unlock;\n\n\tsam9x60_div_pll_set_div(core, div->div, 0);\n\nunlock:\n\tspin_unlock_irqrestore(core->lock, irqflags);\n\n\treturn 0;\n}\n\nstatic int sam9x60_div_pll_save_context(struct clk_hw *hw)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\tstruct sam9x60_div *div = to_sam9x60_div(core);\n\n\tdiv->pms.status = sam9x60_div_pll_is_prepared(hw);\n\n\treturn 0;\n}\n\nstatic void sam9x60_div_pll_restore_context(struct clk_hw *hw)\n{\n\tstruct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);\n\tstruct sam9x60_div *div = to_sam9x60_div(core);\n\n\tif (div->pms.status)\n\t\tsam9x60_div_pll_set(core);\n}\n\nstatic int sam9x60_div_pll_notifier_fn(struct notifier_block *notifier,\n\t\t\t\t       unsigned long code, void *data)\n{\n\tstruct sam9x60_div *div = notifier_div;\n\tstruct sam9x60_pll_core core = div->core;\n\tstruct regmap *regmap = core.regmap;\n\tunsigned long irqflags;\n\tu32 val, cdiv;\n\tint ret = NOTIFY_DONE;\n\n\tif (code != PRE_RATE_CHANGE)\n\t\treturn ret;\n\n\t \n\tdiv->div = div->safe_div;\n\n\tspin_lock_irqsave(core.lock, irqflags);\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT, AT91_PMC_PLL_UPDT_ID_MSK,\n\t\t\t   core.id);\n\tregmap_read(regmap, AT91_PMC_PLL_CTRL0, &val);\n\tcdiv = (val & core.layout->div_mask) >> core.layout->div_shift;\n\n\t \n\tif (cdiv == div->safe_div)\n\t\tgoto unlock;\n\n\tsam9x60_div_pll_set_div(&core, div->div, 0);\n\tret = NOTIFY_OK;\n\nunlock:\n\tspin_unlock_irqrestore(core.lock, irqflags);\n\n\treturn ret;\n}\n\nstatic struct notifier_block sam9x60_div_pll_notifier = {\n\t.notifier_call = sam9x60_div_pll_notifier_fn,\n};\n\nstatic const struct clk_ops sam9x60_div_pll_ops = {\n\t.prepare = sam9x60_div_pll_prepare,\n\t.unprepare = sam9x60_div_pll_unprepare,\n\t.is_prepared = sam9x60_div_pll_is_prepared,\n\t.recalc_rate = sam9x60_div_pll_recalc_rate,\n\t.round_rate = sam9x60_div_pll_round_rate,\n\t.set_rate = sam9x60_div_pll_set_rate,\n\t.save_context = sam9x60_div_pll_save_context,\n\t.restore_context = sam9x60_div_pll_restore_context,\n};\n\nstatic const struct clk_ops sam9x60_div_pll_ops_chg = {\n\t.prepare = sam9x60_div_pll_prepare,\n\t.unprepare = sam9x60_div_pll_unprepare,\n\t.is_prepared = sam9x60_div_pll_is_prepared,\n\t.recalc_rate = sam9x60_div_pll_recalc_rate,\n\t.round_rate = sam9x60_div_pll_round_rate,\n\t.set_rate = sam9x60_div_pll_set_rate_chg,\n\t.save_context = sam9x60_div_pll_save_context,\n\t.restore_context = sam9x60_div_pll_restore_context,\n};\n\nstruct clk_hw * __init\nsam9x60_clk_register_frac_pll(struct regmap *regmap, spinlock_t *lock,\n\t\t\t      const char *name, const char *parent_name,\n\t\t\t      struct clk_hw *parent_hw, u8 id,\n\t\t\t      const struct clk_pll_characteristics *characteristics,\n\t\t\t      const struct clk_pll_layout *layout, u32 flags)\n{\n\tstruct sam9x60_frac *frac;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tunsigned long parent_rate, irqflags;\n\tunsigned int val;\n\tint ret;\n\n\tif (id > PLL_MAX_ID || !lock || !parent_hw)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfrac = kzalloc(sizeof(*frac), GFP_KERNEL);\n\tif (!frac)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tif (parent_name)\n\t\tinit.parent_names = &parent_name;\n\telse\n\t\tinit.parent_hws = (const struct clk_hw **)&parent_hw;\n\tinit.num_parents = 1;\n\tif (flags & CLK_SET_RATE_GATE)\n\t\tinit.ops = &sam9x60_frac_pll_ops;\n\telse\n\t\tinit.ops = &sam9x60_frac_pll_ops_chg;\n\n\tinit.flags = flags;\n\n\tfrac->core.id = id;\n\tfrac->core.hw.init = &init;\n\tfrac->core.characteristics = characteristics;\n\tfrac->core.layout = layout;\n\tfrac->core.regmap = regmap;\n\tfrac->core.lock = lock;\n\n\tspin_lock_irqsave(frac->core.lock, irqflags);\n\tif (sam9x60_pll_ready(regmap, id)) {\n\t\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT,\n\t\t\t\t   AT91_PMC_PLL_UPDT_ID_MSK, id);\n\t\tregmap_read(regmap, AT91_PMC_PLL_CTRL1, &val);\n\t\tfrac->mul = FIELD_GET(PMC_PLL_CTRL1_MUL_MSK, val);\n\t\tfrac->frac = FIELD_GET(PMC_PLL_CTRL1_FRACR_MSK, val);\n\t} else {\n\t\t \n\t\tparent_rate = clk_hw_get_rate(parent_hw);\n\t\tif (!parent_rate) {\n\t\t\thw = ERR_PTR(-EINVAL);\n\t\t\tgoto free;\n\t\t}\n\n\t\tret = sam9x60_frac_pll_compute_mul_frac(&frac->core, FCORE_MIN,\n\t\t\t\t\t\t\tparent_rate, true);\n\t\tif (ret < 0) {\n\t\t\thw = ERR_PTR(ret);\n\t\t\tgoto free;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(frac->core.lock, irqflags);\n\n\thw = &frac->core.hw;\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(frac);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n\nfree:\n\tspin_unlock_irqrestore(frac->core.lock, irqflags);\n\tkfree(frac);\n\treturn hw;\n}\n\nstruct clk_hw * __init\nsam9x60_clk_register_div_pll(struct regmap *regmap, spinlock_t *lock,\n\t\t\t     const char *name, const char *parent_name,\n\t\t\t     struct clk_hw *parent_hw, u8 id,\n\t\t\t     const struct clk_pll_characteristics *characteristics,\n\t\t\t     const struct clk_pll_layout *layout, u32 flags,\n\t\t\t     u32 safe_div)\n{\n\tstruct sam9x60_div *div;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tunsigned long irqflags;\n\tunsigned int val;\n\tint ret;\n\n\t \n\tif (id > PLL_MAX_ID || !lock || (safe_div && notifier_div))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (safe_div >= PLL_DIV_MAX)\n\t\tsafe_div = PLL_DIV_MAX - 1;\n\n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tif (parent_hw)\n\t\tinit.parent_hws = (const struct clk_hw **)&parent_hw;\n\telse\n\t\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tif (flags & CLK_SET_RATE_GATE)\n\t\tinit.ops = &sam9x60_div_pll_ops;\n\telse\n\t\tinit.ops = &sam9x60_div_pll_ops_chg;\n\tinit.flags = flags;\n\n\tdiv->core.id = id;\n\tdiv->core.hw.init = &init;\n\tdiv->core.characteristics = characteristics;\n\tdiv->core.layout = layout;\n\tdiv->core.regmap = regmap;\n\tdiv->core.lock = lock;\n\tdiv->safe_div = safe_div;\n\n\tspin_lock_irqsave(div->core.lock, irqflags);\n\n\tregmap_update_bits(regmap, AT91_PMC_PLL_UPDT,\n\t\t\t   AT91_PMC_PLL_UPDT_ID_MSK, id);\n\tregmap_read(regmap, AT91_PMC_PLL_CTRL0, &val);\n\tdiv->div = FIELD_GET(PMC_PLL_CTRL0_DIV_MSK, val);\n\n\tspin_unlock_irqrestore(div->core.lock, irqflags);\n\n\thw = &div->core.hw;\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(div);\n\t\thw = ERR_PTR(ret);\n\t} else if (div->safe_div) {\n\t\tnotifier_div = div;\n\t\tclk_notifier_register(hw->clk, &sam9x60_div_pll_notifier);\n\t}\n\n\treturn hw;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}