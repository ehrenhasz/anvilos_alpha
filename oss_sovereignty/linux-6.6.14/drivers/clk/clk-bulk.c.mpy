{
  "module_name": "clk-bulk.c",
  "hash_id": "15d9c4d231aa3e0a602f177dc6a8d4989328bd613bca896cd44307bb3fc6906a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-bulk.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\nstatic int __must_check of_clk_bulk_get(struct device_node *np, int num_clks,\n\t\t\t\t\tstruct clk_bulk_data *clks)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tclks[i].id = NULL;\n\t\tclks[i].clk = NULL;\n\t}\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tof_property_read_string_index(np, \"clock-names\", i, &clks[i].id);\n\t\tclks[i].clk = of_clk_get(np, i);\n\t\tif (IS_ERR(clks[i].clk)) {\n\t\t\tret = PTR_ERR(clks[i].clk);\n\t\t\tpr_err(\"%pOF: Failed to get clk index: %d ret: %d\\n\",\n\t\t\t       np, i, ret);\n\t\t\tclks[i].clk = NULL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tclk_bulk_put(i, clks);\n\n\treturn ret;\n}\n\nstatic int __must_check of_clk_bulk_get_all(struct device_node *np,\n\t\t\t\t\t    struct clk_bulk_data **clks)\n{\n\tstruct clk_bulk_data *clk_bulk;\n\tint num_clks;\n\tint ret;\n\n\tnum_clks = of_clk_get_parent_count(np);\n\tif (!num_clks)\n\t\treturn 0;\n\n\tclk_bulk = kmalloc_array(num_clks, sizeof(*clk_bulk), GFP_KERNEL);\n\tif (!clk_bulk)\n\t\treturn -ENOMEM;\n\n\tret = of_clk_bulk_get(np, num_clks, clk_bulk);\n\tif (ret) {\n\t\tkfree(clk_bulk);\n\t\treturn ret;\n\t}\n\n\t*clks = clk_bulk;\n\n\treturn num_clks;\n}\n\nvoid clk_bulk_put(int num_clks, struct clk_bulk_data *clks)\n{\n\twhile (--num_clks >= 0) {\n\t\tclk_put(clks[num_clks].clk);\n\t\tclks[num_clks].clk = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(clk_bulk_put);\n\nstatic int __clk_bulk_get(struct device *dev, int num_clks,\n\t\t\t  struct clk_bulk_data *clks, bool optional)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < num_clks; i++)\n\t\tclks[i].clk = NULL;\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tclks[i].clk = clk_get(dev, clks[i].id);\n\t\tif (IS_ERR(clks[i].clk)) {\n\t\t\tret = PTR_ERR(clks[i].clk);\n\t\t\tclks[i].clk = NULL;\n\n\t\t\tif (ret == -ENOENT && optional)\n\t\t\t\tcontinue;\n\n\t\t\tdev_err_probe(dev, ret,\n\t\t\t\t      \"Failed to get clk '%s'\\n\",\n\t\t\t\t      clks[i].id);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tclk_bulk_put(i, clks);\n\n\treturn ret;\n}\n\nint __must_check clk_bulk_get(struct device *dev, int num_clks,\n\t\t\t      struct clk_bulk_data *clks)\n{\n\treturn __clk_bulk_get(dev, num_clks, clks, false);\n}\nEXPORT_SYMBOL(clk_bulk_get);\n\nint __must_check clk_bulk_get_optional(struct device *dev, int num_clks,\n\t\t\t\t       struct clk_bulk_data *clks)\n{\n\treturn __clk_bulk_get(dev, num_clks, clks, true);\n}\nEXPORT_SYMBOL_GPL(clk_bulk_get_optional);\n\nvoid clk_bulk_put_all(int num_clks, struct clk_bulk_data *clks)\n{\n\tif (IS_ERR_OR_NULL(clks))\n\t\treturn;\n\n\tclk_bulk_put(num_clks, clks);\n\n\tkfree(clks);\n}\nEXPORT_SYMBOL(clk_bulk_put_all);\n\nint __must_check clk_bulk_get_all(struct device *dev,\n\t\t\t\t  struct clk_bulk_data **clks)\n{\n\tstruct device_node *np = dev_of_node(dev);\n\n\tif (!np)\n\t\treturn 0;\n\n\treturn of_clk_bulk_get_all(np, clks);\n}\nEXPORT_SYMBOL(clk_bulk_get_all);\n\n#ifdef CONFIG_HAVE_CLK_PREPARE\n\n \nvoid clk_bulk_unprepare(int num_clks, const struct clk_bulk_data *clks)\n{\n\twhile (--num_clks >= 0)\n\t\tclk_unprepare(clks[num_clks].clk);\n}\nEXPORT_SYMBOL_GPL(clk_bulk_unprepare);\n\n \nint __must_check clk_bulk_prepare(int num_clks,\n\t\t\t\t  const struct clk_bulk_data *clks)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tret = clk_prepare(clks[i].clk);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to prepare clk '%s': %d\\n\",\n\t\t\t\tclks[i].id, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tclk_bulk_unprepare(i, clks);\n\n\treturn  ret;\n}\nEXPORT_SYMBOL_GPL(clk_bulk_prepare);\n\n#endif  \n\n \nvoid clk_bulk_disable(int num_clks, const struct clk_bulk_data *clks)\n{\n\n\twhile (--num_clks >= 0)\n\t\tclk_disable(clks[num_clks].clk);\n}\nEXPORT_SYMBOL_GPL(clk_bulk_disable);\n\n \nint __must_check clk_bulk_enable(int num_clks, const struct clk_bulk_data *clks)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tret = clk_enable(clks[i].clk);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to enable clk '%s': %d\\n\",\n\t\t\t\tclks[i].id, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tclk_bulk_disable(i, clks);\n\n\treturn  ret;\n}\nEXPORT_SYMBOL_GPL(clk_bulk_enable);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}