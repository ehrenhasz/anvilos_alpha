{
  "module_name": "clk-artpec6.c",
  "hash_id": "1f4f6a8a6cd6d0b9b00026aae2dd1775324385669409cd65b4e7876065fb86f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/axis/clk-artpec6.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <dt-bindings/clock/axis,artpec6-clkctrl.h>\n\n#define NUM_I2S_CLOCKS 2\n\nstruct artpec6_clkctrl_drvdata {\n\tstruct clk *clk_table[ARTPEC6_CLK_NUMCLOCKS];\n\tvoid __iomem *syscon_base;\n\tstruct clk_onecell_data clk_data;\n\tspinlock_t i2scfg_lock;\n};\n\nstatic struct artpec6_clkctrl_drvdata *clkdata;\n\nstatic const char *const i2s_clk_names[NUM_I2S_CLOCKS] = {\n\t\"i2s0\",\n\t\"i2s1\",\n};\n\nstatic const int i2s_clk_indexes[NUM_I2S_CLOCKS] = {\n\tARTPEC6_CLK_I2S0_CLK,\n\tARTPEC6_CLK_I2S1_CLK,\n};\n\nstatic void of_artpec6_clkctrl_setup(struct device_node *np)\n{\n\tint i;\n\tconst char *sys_refclk_name;\n\tu32 pll_mode, pll_m, pll_n;\n\tstruct clk **clks;\n\n\t \n\ti = of_property_match_string(np, \"clock-names\", \"sys_refclk\");\n\tif (i < 0)\n\t\treturn;\n\n\tsys_refclk_name = of_clk_get_parent_name(np, i);\n\n\tclkdata = kzalloc(sizeof(*clkdata), GFP_KERNEL);\n\tif (!clkdata)\n\t\treturn;\n\n\tclks = clkdata->clk_table;\n\n\tfor (i = 0; i < ARTPEC6_CLK_NUMCLOCKS; ++i)\n\t\tclks[i] = ERR_PTR(-EPROBE_DEFER);\n\n\tclkdata->syscon_base = of_iomap(np, 0);\n\tBUG_ON(clkdata->syscon_base == NULL);\n\n\t \n\tpll_mode = (readl(clkdata->syscon_base) >> 6) & 3;\n\tswitch (pll_mode) {\n\tcase 0:\t\t \n\t\tpll_m = 4;\n\t\tpll_n = 85;\n\t\tbreak;\n\tcase 1:\t\t \n\t\tpll_m = 6;\n\t\tpll_n = 112;\n\t\tbreak;\n\tcase 2:\t\t \n\t\tpll_m = 4;\n\t\tpll_n = 64;\n\t\tbreak;\n\tcase 3:\t\t \n\t\tpll_m = 8;\n\t\tpll_n = 106;\n\t\tbreak;\n\t}\n\n\tclks[ARTPEC6_CLK_CPU] =\n\t    clk_register_fixed_factor(NULL, \"cpu\", sys_refclk_name, 0, pll_n,\n\t\t\t\t      pll_m);\n\tclks[ARTPEC6_CLK_CPU_PERIPH] =\n\t    clk_register_fixed_factor(NULL, \"cpu_periph\", \"cpu\", 0, 1, 2);\n\n\t \n\tclks[ARTPEC6_CLK_UART_PCLK] =\n\t    clk_register_fixed_factor(NULL, \"uart_pclk\", \"cpu\", 0, 1, 8);\n\tclks[ARTPEC6_CLK_UART_REFCLK] =\n\t    clk_register_fixed_rate(NULL, \"uart_ref\", sys_refclk_name, 0,\n\t\t\t\t    50000000);\n\n\tclks[ARTPEC6_CLK_SPI_PCLK] =\n\t    clk_register_fixed_factor(NULL, \"spi_pclk\", \"cpu\", 0, 1, 8);\n\tclks[ARTPEC6_CLK_SPI_SSPCLK] =\n\t    clk_register_fixed_rate(NULL, \"spi_sspclk\", sys_refclk_name, 0,\n\t\t\t\t    50000000);\n\n\tclks[ARTPEC6_CLK_DBG_PCLK] =\n\t    clk_register_fixed_factor(NULL, \"dbg_pclk\", \"cpu\", 0, 1, 8);\n\n\tclkdata->clk_data.clks = clkdata->clk_table;\n\tclkdata->clk_data.clk_num = ARTPEC6_CLK_NUMCLOCKS;\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &clkdata->clk_data);\n}\n\nCLK_OF_DECLARE_DRIVER(artpec6_clkctrl, \"axis,artpec6-clkctrl\",\n\t\t      of_artpec6_clkctrl_setup);\n\nstatic int artpec6_clkctrl_probe(struct platform_device *pdev)\n{\n\tint propidx;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct clk **clks = clkdata->clk_table;\n\tconst char *sys_refclk_name;\n\tconst char *i2s_refclk_name = NULL;\n\tconst char *frac_clk_name[2] = { NULL, NULL };\n\tconst char *i2s_mux_parents[2];\n\tu32 muxreg;\n\tint i;\n\tint err = 0;\n\n\t \n\tpropidx = of_property_match_string(np, \"clock-names\", \"sys_refclk\");\n\tif (propidx < 0)\n\t\treturn -EINVAL;\n\n\tsys_refclk_name = of_clk_get_parent_name(np, propidx);\n\n\t \n\tpropidx = of_property_match_string(np, \"clock-names\", \"i2s_refclk\");\n\tif (propidx >= 0)\n\t\ti2s_refclk_name = of_clk_get_parent_name(np, propidx);\n\n\tpropidx = of_property_match_string(np, \"clock-names\", \"frac_clk0\");\n\tif (propidx >= 0)\n\t\tfrac_clk_name[0] = of_clk_get_parent_name(np, propidx);\n\tpropidx = of_property_match_string(np, \"clock-names\", \"frac_clk1\");\n\tif (propidx >= 0)\n\t\tfrac_clk_name[1] = of_clk_get_parent_name(np, propidx);\n\n\tspin_lock_init(&clkdata->i2scfg_lock);\n\n\tclks[ARTPEC6_CLK_NAND_CLKA] =\n\t    clk_register_fixed_factor(dev, \"nand_clka\", \"cpu\", 0, 1, 8);\n\tclks[ARTPEC6_CLK_NAND_CLKB] =\n\t    clk_register_fixed_rate(dev, \"nand_clkb\", sys_refclk_name, 0,\n\t\t\t\t    100000000);\n\tclks[ARTPEC6_CLK_ETH_ACLK] =\n\t    clk_register_fixed_factor(dev, \"eth_aclk\", \"cpu\", 0, 1, 4);\n\tclks[ARTPEC6_CLK_DMA_ACLK] =\n\t    clk_register_fixed_factor(dev, \"dma_aclk\", \"cpu\", 0, 1, 4);\n\tclks[ARTPEC6_CLK_PTP_REF] =\n\t    clk_register_fixed_rate(dev, \"ptp_ref\", sys_refclk_name, 0,\n\t\t\t\t    100000000);\n\tclks[ARTPEC6_CLK_SD_PCLK] =\n\t    clk_register_fixed_rate(dev, \"sd_pclk\", sys_refclk_name, 0,\n\t\t\t\t    100000000);\n\tclks[ARTPEC6_CLK_SD_IMCLK] =\n\t    clk_register_fixed_rate(dev, \"sd_imclk\", sys_refclk_name, 0,\n\t\t\t\t    100000000);\n\tclks[ARTPEC6_CLK_I2S_HST] =\n\t    clk_register_fixed_factor(dev, \"i2s_hst\", \"cpu\", 0, 1, 8);\n\n\tfor (i = 0; i < NUM_I2S_CLOCKS; ++i) {\n\t\tif (i2s_refclk_name && frac_clk_name[i]) {\n\t\t\ti2s_mux_parents[0] = frac_clk_name[i];\n\t\t\ti2s_mux_parents[1] = i2s_refclk_name;\n\n\t\t\tclks[i2s_clk_indexes[i]] =\n\t\t\t    clk_register_mux(dev, i2s_clk_names[i],\n\t\t\t\t\t     i2s_mux_parents, 2,\n\t\t\t\t\t     CLK_SET_RATE_NO_REPARENT |\n\t\t\t\t\t     CLK_SET_RATE_PARENT,\n\t\t\t\t\t     clkdata->syscon_base + 0x14, i, 1,\n\t\t\t\t\t     0, &clkdata->i2scfg_lock);\n\t\t} else if (frac_clk_name[i]) {\n\t\t\t \n\t\t\tmuxreg = readl(clkdata->syscon_base + 0x14);\n\t\t\tmuxreg &= ~BIT(i);\n\t\t\twritel(muxreg, clkdata->syscon_base + 0x14);\n\t\t\tclks[i2s_clk_indexes[i]] =\n\t\t\t    clk_register_fixed_factor(dev, i2s_clk_names[i],\n\t\t\t\t\t\t      frac_clk_name[i], 0, 1,\n\t\t\t\t\t\t      1);\n\t\t} else if (i2s_refclk_name) {\n\t\t\t \n\t\t\tmuxreg = readl(clkdata->syscon_base + 0x14);\n\t\t\tmuxreg |= BIT(i);\n\t\t\twritel(muxreg, clkdata->syscon_base + 0x14);\n\t\t\tclks[i2s_clk_indexes[i]] =\n\t\t\t    clk_register_fixed_factor(dev, i2s_clk_names[i],\n\t\t\t\t\t\t      i2s_refclk_name, 0, 1, 1);\n\t\t}\n\t}\n\n\tclks[ARTPEC6_CLK_I2C] =\n\t    clk_register_fixed_rate(dev, \"i2c\", sys_refclk_name, 0, 100000000);\n\n\tclks[ARTPEC6_CLK_SYS_TIMER] =\n\t    clk_register_fixed_rate(dev, \"timer\", sys_refclk_name, 0,\n\t\t\t\t    100000000);\n\tclks[ARTPEC6_CLK_FRACDIV_IN] =\n\t    clk_register_fixed_rate(dev, \"fracdiv_in\", sys_refclk_name, 0,\n\t\t\t\t    600000000);\n\n\tfor (i = 0; i < ARTPEC6_CLK_NUMCLOCKS; ++i) {\n\t\tif (IS_ERR(clks[i]) && PTR_ERR(clks[i]) != -EPROBE_DEFER) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to register clock at index %d err=%ld\\n\",\n\t\t\t\ti, PTR_ERR(clks[i]));\n\t\t\terr = PTR_ERR(clks[i]);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic const struct of_device_id artpec_clkctrl_of_match[] = {\n\t{ .compatible = \"axis,artpec6-clkctrl\" },\n\t{}\n};\n\nstatic struct platform_driver artpec6_clkctrl_driver = {\n\t.probe = artpec6_clkctrl_probe,\n\t.driver = {\n\t\t   .name = \"artpec6_clkctrl\",\n\t\t   .of_match_table = artpec_clkctrl_of_match,\n\t},\n};\n\nbuiltin_platform_driver(artpec6_clkctrl_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}