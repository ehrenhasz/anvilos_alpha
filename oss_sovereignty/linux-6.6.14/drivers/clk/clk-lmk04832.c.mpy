{
  "module_name": "clk-lmk04832.c",
  "hash_id": "ec62c360f70d0106ff305eabb87fd8c201870db00e91ad1c7d438ad0c7246cb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-lmk04832.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/gcd.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n\n \n#define LMK04832_REG_RST3W\t\t0x000\n#define LMK04832_BIT_RESET\t\t\tBIT(7)\n#define LMK04832_BIT_SPI_3WIRE_DIS\t\tBIT(4)\n#define LMK04832_REG_POWERDOWN\t\t0x002\n#define LMK04832_REG_ID_DEV_TYPE\t0x003\n#define LMK04832_REG_ID_PROD_MSB\t0x004\n#define LMK04832_REG_ID_PROD_LSB\t0x005\n#define LMK04832_REG_ID_MASKREV\t\t0x006\n#define LMK04832_REG_ID_VNDR_MSB\t0x00c\n#define LMK04832_REG_ID_VNDR_LSB\t0x00d\n\n \n#define LMK04832_REG_CLKOUT_CTRL0(ch)\t(0x100 + (ch >> 1) * 8)\n#define LMK04832_BIT_DCLK_DIV_LSB\t\tGENMASK(7, 0)\n#define LMK04832_REG_CLKOUT_CTRL1(ch)\t(0x101 + (ch >> 1) * 8)\n#define LMK04832_BIT_DCLKX_Y_DDLY_LSB\t\tGENMASK(7, 0)\n#define LMK04832_REG_CLKOUT_CTRL2(ch)\t(0x102 + (ch >> 1) * 8)\n#define LMK04832_BIT_CLKOUTX_Y_PD\t\tBIT(7)\n#define LMK04832_BIT_DCLKX_Y_DDLY_PD\t\tBIT(4)\n#define LMK04832_BIT_DCLKX_Y_DDLY_MSB\t\tGENMASK(3, 2)\n#define LMK04832_BIT_DCLK_DIV_MSB\t\tGENMASK(1, 0)\n#define LMK04832_REG_CLKOUT_SRC_MUX(ch)\t(0x103 + (ch % 2) + (ch >> 1) * 8)\n#define LMK04832_BIT_CLKOUT_SRC_MUX\t\tBIT(5)\n#define LMK04832_REG_CLKOUT_CTRL3(ch)\t(0x103 + (ch >> 1) * 8)\n#define LMK04832_BIT_DCLKX_Y_PD\t\t\tBIT(4)\n#define LMK04832_BIT_DCLKX_Y_DCC\t\tBIT(2)\n#define LMK04832_BIT_DCLKX_Y_HS\t\t\tBIT(0)\n#define LMK04832_REG_CLKOUT_CTRL4(ch)\t(0x104 + (ch >> 1) * 8)\n#define LMK04832_BIT_SCLK_PD\t\t\tBIT(4)\n#define LMK04832_BIT_SCLKX_Y_DIS_MODE\t\tGENMASK(3, 2)\n#define LMK04832_REG_SCLKX_Y_ADLY(ch)\t(0x105 + (ch >> 1) * 8)\n#define LMK04832_REG_SCLKX_Y_DDLY(ch)\t(0x106 + (ch >> 1) * 8)\n#define LMK04832_BIT_SCLKX_Y_DDLY\t\tGENMASK(3, 0)\n#define LMK04832_REG_CLKOUT_FMT(ch)\t(0x107 + (ch >> 1) * 8)\n#define LMK04832_BIT_CLKOUT_FMT(ch)\t\t(ch % 2 ? 0xf0 : 0x0f)\n#define LMK04832_VAL_CLKOUT_FMT_POWERDOWN\t\t0x00\n#define LMK04832_VAL_CLKOUT_FMT_LVDS\t\t\t0x01\n#define LMK04832_VAL_CLKOUT_FMT_HSDS6\t\t\t0x02\n#define LMK04832_VAL_CLKOUT_FMT_HSDS8\t\t\t0x03\n#define LMK04832_VAL_CLKOUT_FMT_LVPECL1600\t\t0x04\n#define LMK04832_VAL_CLKOUT_FMT_LVPECL2000\t\t0x05\n#define LMK04832_VAL_CLKOUT_FMT_LCPECL\t\t\t0x06\n#define LMK04832_VAL_CLKOUT_FMT_CML16\t\t\t0x07\n#define LMK04832_VAL_CLKOUT_FMT_CML24\t\t\t0x08\n#define LMK04832_VAL_CLKOUT_FMT_CML32\t\t\t0x09\n#define LMK04832_VAL_CLKOUT_FMT_CMOS_OFF_INV\t\t0x0a\n#define LMK04832_VAL_CLKOUT_FMT_CMOS_NOR_OFF\t\t0x0b\n#define LMK04832_VAL_CLKOUT_FMT_CMOS_INV_INV\t\t0x0c\n#define LMK04832_VAL_CLKOUT_FMT_CMOS_INV_NOR\t\t0x0d\n#define LMK04832_VAL_CLKOUT_FMT_CMOS_NOR_INV\t\t0x0e\n#define LMK04832_VAL_CLKOUT_FMT_CMOS_NOR_NOR\t\t0x0f\n\n \n#define LMK04832_REG_VCO_OSCOUT\t\t0x138\n#define LMK04832_BIT_VCO_MUX\t\t\tGENMASK(6, 5)\n#define LMK04832_VAL_VCO_MUX_VCO0\t\t\t0x00\n#define LMK04832_VAL_VCO_MUX_VCO1\t\t\t0x01\n#define LMK04832_VAL_VCO_MUX_EXT\t\t\t0x02\n#define LMK04832_REG_SYSREF_OUT\t\t0x139\n#define LMK04832_BIT_SYSREF_REQ_EN\t\tBIT(6)\n#define LMK04832_BIT_SYSREF_MUX\t\t\tGENMASK(1, 0)\n#define LMK04832_VAL_SYSREF_MUX_NORMAL_SYNC\t\t0x00\n#define LMK04832_VAL_SYSREF_MUX_RECLK\t\t\t0x01\n#define LMK04832_VAL_SYSREF_MUX_PULSER\t\t\t0x02\n#define LMK04832_VAL_SYSREF_MUX_CONTINUOUS\t\t0x03\n#define LMK04832_REG_SYSREF_DIV_MSB\t0x13a\n#define LMK04832_BIT_SYSREF_DIV_MSB\t\tGENMASK(4, 0)\n#define LMK04832_REG_SYSREF_DIV_LSB\t0x13b\n#define LMK04832_REG_SYSREF_DDLY_MSB\t0x13c\n#define LMK04832_BIT_SYSREF_DDLY_MSB\t\tGENMASK(4, 0)\n#define LMK04832_REG_SYSREF_DDLY_LSB\t0x13d\n#define LMK04832_REG_SYSREF_PULSE_CNT\t0x13e\n#define LMK04832_REG_FB_CTRL\t\t0x13f\n#define LMK04832_BIT_PLL2_RCLK_MUX\t\tBIT(7)\n#define LMK04832_VAL_PLL2_RCLK_MUX_OSCIN\t\t0x00\n#define LMK04832_VAL_PLL2_RCLK_MUX_CLKIN\t\t0x01\n#define LMK04832_BIT_PLL2_NCLK_MUX\t\tBIT(5)\n#define LMK04832_VAL_PLL2_NCLK_MUX_PLL2_P\t\t0x00\n#define LMK04832_VAL_PLL2_NCLK_MUX_FB_MUX\t\t0x01\n#define LMK04832_BIT_FB_MUX_EN\t\t\tBIT(0)\n#define LMK04832_REG_MAIN_PD\t\t0x140\n#define LMK04832_BIT_PLL1_PD\t\t\tBIT(7)\n#define LMK04832_BIT_VCO_LDO_PD\t\t\tBIT(6)\n#define LMK04832_BIT_VCO_PD\t\t\tBIT(5)\n#define LMK04832_BIT_OSCIN_PD\t\t\tBIT(4)\n#define LMK04832_BIT_SYSREF_GBL_PD\t\tBIT(3)\n#define LMK04832_BIT_SYSREF_PD\t\t\tBIT(2)\n#define LMK04832_BIT_SYSREF_DDLY_PD\t\tBIT(1)\n#define LMK04832_BIT_SYSREF_PLSR_PD\t\tBIT(0)\n#define LMK04832_REG_SYNC\t\t0x143\n#define LMK04832_BIT_SYNC_CLR\t\t\tBIT(7)\n#define LMK04832_BIT_SYNC_1SHOT_EN\t\tBIT(6)\n#define LMK04832_BIT_SYNC_POL\t\t\tBIT(5)\n#define LMK04832_BIT_SYNC_EN\t\t\tBIT(4)\n#define LMK04832_BIT_SYNC_MODE\t\t\tGENMASK(1, 0)\n#define LMK04832_VAL_SYNC_MODE_OFF\t\t\t0x00\n#define LMK04832_VAL_SYNC_MODE_ON\t\t\t0x01\n#define LMK04832_VAL_SYNC_MODE_PULSER_PIN\t\t0x02\n#define LMK04832_VAL_SYNC_MODE_PULSER_SPI\t\t0x03\n#define LMK04832_REG_SYNC_DIS\t\t0x144\n\n \n#define LMK04832_REG_CLKIN_SEL0\t\t0x148\n#define LMK04832_REG_CLKIN_SEL1\t\t0x149\n#define LMK04832_REG_CLKIN_RST\t\t0x14a\n#define LMK04832_BIT_SDIO_RDBK_TYPE\t\tBIT(6)\n#define LMK04832_BIT_CLKIN_SEL_MUX\t\tGENMASK(5, 3)\n#define LMK04832_VAL_CLKIN_SEL_MUX_SPI_RDBK\t\t0x06\n#define LMK04832_BIT_CLKIN_SEL_TYPE\t\tGENMASK(2, 0)\n#define LMK04832_VAL_CLKIN_SEL_TYPE_OUT\t\t\t0x03\n\n \n\n \n#define LMK04832_REG_PLL1_LD\t\t0x15f\n#define LMK04832_BIT_PLL1_LD_MUX\t\tGENMASK(7, 3)\n#define LMK04832_VAL_PLL1_LD_MUX_SPI_RDBK\t\t0x07\n#define LMK04832_BIT_PLL1_LD_TYPE\t\tGENMASK(2, 0)\n#define LMK04832_VAL_PLL1_LD_TYPE_OUT_PP\t\t0x03\n\n \n#define LMK04832_REG_PLL2_R_MSB\t\t0x160\n#define LMK04832_BIT_PLL2_R_MSB\t\t\tGENMASK(3, 0)\n#define LMK04832_REG_PLL2_R_LSB\t\t0x161\n#define LMK04832_REG_PLL2_MISC\t\t0x162\n#define LMK04832_BIT_PLL2_MISC_P\t\tGENMASK(7, 5)\n#define LMK04832_BIT_PLL2_MISC_REF_2X_EN\tBIT(0)\n#define LMK04832_REG_PLL2_N_CAL_0\t0x163\n#define LMK04832_BIT_PLL2_N_CAL_0\t\tGENMASK(1, 0)\n#define LMK04832_REG_PLL2_N_CAL_1\t0x164\n#define LMK04832_REG_PLL2_N_CAL_2\t0x165\n#define LMK04832_REG_PLL2_N_0\t\t0x166\n#define LMK04832_BIT_PLL2_N_0\t\t\tGENMASK(1, 0)\n#define LMK04832_REG_PLL2_N_1\t\t0x167\n#define LMK04832_REG_PLL2_N_2\t\t0x168\n#define LMK04832_REG_PLL2_DLD_CNT_MSB\t0x16a\n#define LMK04832_REG_PLL2_DLD_CNT_LSB\t0x16b\n#define LMK04832_REG_PLL2_LD\t\t0x16e\n#define LMK04832_BIT_PLL2_LD_MUX\t\tGENMASK(7, 3)\n#define LMK04832_VAL_PLL2_LD_MUX_PLL2_DLD\t\t0x02\n#define LMK04832_BIT_PLL2_LD_TYPE\t\tGENMASK(2, 0)\n#define LMK04832_VAL_PLL2_LD_TYPE_OUT_PP\t\t0x03\n\n \n#define LMK04832_REG_PLL2_PD\t\t0x173\n#define LMK04832_BIT_PLL2_PRE_PD\t\tBIT(6)\n#define LMK04832_BIT_PLL2_PD\t\t\tBIT(5)\n#define LMK04832_REG_PLL1R_RST\t\t0x177\n#define LMK04832_REG_CLR_PLL_LOST\t0x182\n#define LMK04832_REG_RB_PLL_LD\t\t0x183\n#define LMK04832_REG_RB_CLK_DAC_VAL_MSB\t0x184\n#define LMK04832_REG_RB_DAC_VAL_LSB\t0x185\n#define LMK04832_REG_RB_HOLDOVER\t0x188\n#define LMK04832_REG_SPI_LOCK\t\t0x555\n\nenum lmk04832_device_types {\n\tLMK04832,\n};\n\n \nstruct lmk04832_device_info {\n\tu16 pid;\n\tu8 maskrev;\n\tsize_t num_channels;\n\tunsigned int vco0_range[2];\n\tunsigned int vco1_range[2];\n};\n\nstatic const struct lmk04832_device_info lmk04832_device_info[] = {\n\t[LMK04832] = {\n\t\t.pid = 0x63d1,  \n\t\t.maskrev = 0x70,\n\t\t.num_channels = 14,\n\t\t.vco0_range = { 2440, 2580 },\n\t\t.vco1_range = { 2945, 3255 },\n\t},\n};\n\nenum lmk04832_rdbk_type {\n\tRDBK_CLKIN_SEL0,\n\tRDBK_CLKIN_SEL1,\n\tRDBK_RESET,\n\tRDBK_PLL1_LD,\n};\n\nstruct lmk_dclk {\n\tstruct lmk04832 *lmk;\n\tstruct clk_hw hw;\n\tu8 id;\n};\n\nstruct lmk_clkout {\n\tstruct lmk04832 *lmk;\n\tstruct clk_hw hw;\n\tbool sysref;\n\tu32 format;\n\tu8 id;\n};\n\n \nstruct lmk04832 {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\n\tunsigned int sync_mode;\n\tunsigned int sysref_mux;\n\tunsigned int sysref_pulse_cnt;\n\tunsigned int sysref_ddly;\n\n\tstruct clk *oscin;\n\tstruct clk_hw vco;\n\tstruct clk_hw sclk;\n\tunsigned int vco_rate;\n\n\tstruct gpio_desc *reset_gpio;\n\n\tstruct lmk_dclk *dclk;\n\tstruct lmk_clkout *clkout;\n\tstruct clk_hw_onecell_data *clk_data;\n};\n\nstatic bool lmk04832_regmap_rd_regs(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LMK04832_REG_RST3W ... LMK04832_REG_ID_MASKREV:\n\tcase LMK04832_REG_ID_VNDR_MSB:\n\tcase LMK04832_REG_ID_VNDR_LSB:\n\tcase LMK04832_REG_CLKOUT_CTRL0(0) ... LMK04832_REG_PLL2_DLD_CNT_LSB:\n\tcase LMK04832_REG_PLL2_LD:\n\tcase LMK04832_REG_PLL2_PD:\n\tcase LMK04832_REG_PLL1R_RST:\n\tcase LMK04832_REG_CLR_PLL_LOST ... LMK04832_REG_RB_DAC_VAL_LSB:\n\tcase LMK04832_REG_RB_HOLDOVER:\n\tcase LMK04832_REG_SPI_LOCK:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t};\n}\n\nstatic bool lmk04832_regmap_wr_regs(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LMK04832_REG_RST3W:\n\tcase LMK04832_REG_POWERDOWN:\n\t\treturn true;\n\tcase LMK04832_REG_ID_DEV_TYPE ... LMK04832_REG_ID_MASKREV:\n\tcase LMK04832_REG_ID_VNDR_MSB:\n\tcase LMK04832_REG_ID_VNDR_LSB:\n\t\treturn false;\n\tcase LMK04832_REG_CLKOUT_CTRL0(0) ... LMK04832_REG_PLL2_DLD_CNT_LSB:\n\tcase LMK04832_REG_PLL2_LD:\n\tcase LMK04832_REG_PLL2_PD:\n\tcase LMK04832_REG_PLL1R_RST:\n\tcase LMK04832_REG_CLR_PLL_LOST ... LMK04832_REG_RB_DAC_VAL_LSB:\n\tcase LMK04832_REG_RB_HOLDOVER:\n\tcase LMK04832_REG_SPI_LOCK:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t};\n}\n\nstatic const struct regmap_config regmap_config = {\n\t.name = \"lmk04832\",\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.use_single_read = 1,\n\t.use_single_write = 1,\n\t.read_flag_mask = 0x80,\n\t.write_flag_mask = 0x00,\n\t.readable_reg = lmk04832_regmap_rd_regs,\n\t.writeable_reg = lmk04832_regmap_wr_regs,\n\t.cache_type = REGCACHE_NONE,\n\t.max_register = LMK04832_REG_SPI_LOCK,\n};\n\nstatic int lmk04832_vco_is_enabled(struct clk_hw *hw)\n{\n\tstruct lmk04832 *lmk = container_of(hw, struct lmk04832, vco);\n\tunsigned int tmp;\n\tint ret;\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_MAIN_PD, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !(FIELD_GET(LMK04832_BIT_OSCIN_PD, tmp) |\n\t\t FIELD_GET(LMK04832_BIT_VCO_PD, tmp) |\n\t\t FIELD_GET(LMK04832_BIT_VCO_LDO_PD, tmp));\n}\n\nstatic int lmk04832_vco_prepare(struct clk_hw *hw)\n{\n\tstruct lmk04832 *lmk = container_of(hw, struct lmk04832, vco);\n\tint ret;\n\n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_PLL2_PD,\n\t\t\t\t LMK04832_BIT_PLL2_PRE_PD |\n\t\t\t\t LMK04832_BIT_PLL2_PD,\n\t\t\t\t 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(lmk->regmap, LMK04832_REG_MAIN_PD,\n\t\t\t\t  LMK04832_BIT_VCO_LDO_PD |\n\t\t\t\t  LMK04832_BIT_VCO_PD |\n\t\t\t\t  LMK04832_BIT_OSCIN_PD, 0x00);\n}\n\nstatic void lmk04832_vco_unprepare(struct clk_hw *hw)\n{\n\tstruct lmk04832 *lmk = container_of(hw, struct lmk04832, vco);\n\n\tregmap_update_bits(lmk->regmap, LMK04832_REG_PLL2_PD,\n\t\t\t   LMK04832_BIT_PLL2_PRE_PD | LMK04832_BIT_PLL2_PD,\n\t\t\t   0xff);\n\n\t \n\tregmap_update_bits(lmk->regmap, LMK04832_REG_MAIN_PD,\n\t\t\t   LMK04832_BIT_VCO_LDO_PD | LMK04832_BIT_VCO_PD, 0xff);\n}\n\nstatic unsigned long lmk04832_vco_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long prate)\n{\n\tstruct lmk04832 *lmk = container_of(hw, struct lmk04832, vco);\n\tconst unsigned int pll2_p[] = {8, 2, 2, 3, 4, 5, 6, 7};\n\tunsigned int pll2_n, p, pll2_r;\n\tunsigned int pll2_misc;\n\tunsigned long vco_rate;\n\tu8 tmp[3];\n\tint ret;\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_PLL2_MISC, &pll2_misc);\n\tif (ret)\n\t\treturn ret;\n\n\tp = FIELD_GET(LMK04832_BIT_PLL2_MISC_P, pll2_misc);\n\n\tret = regmap_bulk_read(lmk->regmap, LMK04832_REG_PLL2_N_0, &tmp, 3);\n\tif (ret)\n\t\treturn ret;\n\n\tpll2_n = FIELD_PREP(0x030000, tmp[0]) |\n\t\t FIELD_PREP(0x00ff00, tmp[1]) |\n\t\t FIELD_PREP(0x0000ff, tmp[2]);\n\n\tret = regmap_bulk_read(lmk->regmap, LMK04832_REG_PLL2_R_MSB, &tmp, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tpll2_r = FIELD_PREP(0x0f00, tmp[0]) |\n\t\t FIELD_PREP(0x00ff, tmp[1]);\n\n\tvco_rate = (prate << FIELD_GET(LMK04832_BIT_PLL2_MISC_REF_2X_EN,\n\t\t\t\t       pll2_misc)) * pll2_n * pll2_p[p] / pll2_r;\n\n\treturn vco_rate;\n}\n\n \nstatic int lmk04832_check_vco_ranges(struct lmk04832 *lmk, unsigned long rate)\n{\n\tstruct spi_device *spi = to_spi_device(lmk->dev);\n\tconst struct lmk04832_device_info *info;\n\tunsigned long mhz = rate / 1000000;\n\n\tinfo = &lmk04832_device_info[spi_get_device_id(spi)->driver_data];\n\n\tif (mhz >= info->vco0_range[0] && mhz <= info->vco0_range[1])\n\t\treturn LMK04832_VAL_VCO_MUX_VCO0;\n\n\tif (mhz >= info->vco1_range[0] && mhz <= info->vco1_range[1])\n\t\treturn LMK04832_VAL_VCO_MUX_VCO1;\n\n\tdev_err(lmk->dev, \"%lu Hz is out of VCO ranges\\n\", rate);\n\treturn -ERANGE;\n}\n\n \nstatic long lmk04832_calc_pll2_params(unsigned long prate, unsigned long rate,\n\t\t\t\t      unsigned int *n, unsigned int *p,\n\t\t\t\t      unsigned int *r)\n{\n\tunsigned int pll2_n, pll2_p, pll2_r;\n\tunsigned long num, div;\n\n\t \n\tpll2_p = 2;\n\n\tdiv = gcd(rate, prate);\n\n\tnum = DIV_ROUND_CLOSEST(rate, div);\n\tpll2_r = DIV_ROUND_CLOSEST(prate, div);\n\n\tif (num > 4) {\n\t\tpll2_n = num >> 2;\n\t} else {\n\t\tpll2_r = pll2_r << 2;\n\t\tpll2_n = num;\n\t}\n\n\tif (pll2_n < 1 || pll2_n > 0x03ffff)\n\t\treturn -EINVAL;\n\tif (pll2_r < 1 || pll2_r > 0xfff)\n\t\treturn -EINVAL;\n\n\t*n = pll2_n;\n\t*p = pll2_p;\n\t*r = pll2_r;\n\n\treturn DIV_ROUND_CLOSEST(prate * 2 * pll2_p * pll2_n, pll2_r);\n}\n\nstatic long lmk04832_vco_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *prate)\n{\n\tstruct lmk04832 *lmk = container_of(hw, struct lmk04832, vco);\n\tunsigned int n, p, r;\n\tlong vco_rate;\n\tint ret;\n\n\tret = lmk04832_check_vco_ranges(lmk, rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvco_rate = lmk04832_calc_pll2_params(*prate, rate, &n, &p, &r);\n\tif (vco_rate < 0) {\n\t\tdev_err(lmk->dev, \"PLL2 parameters out of range\\n\");\n\t\treturn vco_rate;\n\t}\n\n\tif (rate != vco_rate)\n\t\treturn -EINVAL;\n\n\treturn vco_rate;\n}\n\nstatic int lmk04832_vco_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long prate)\n{\n\tstruct lmk04832 *lmk = container_of(hw, struct lmk04832, vco);\n\tunsigned int n, p, r;\n\tlong vco_rate;\n\tint vco_mux;\n\tint ret;\n\n\tvco_mux = lmk04832_check_vco_ranges(lmk, rate);\n\tif (vco_mux < 0)\n\t\treturn vco_mux;\n\n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_VCO_OSCOUT,\n\t\t\t\t LMK04832_BIT_VCO_MUX,\n\t\t\t\t FIELD_PREP(LMK04832_BIT_VCO_MUX, vco_mux));\n\tif (ret)\n\t\treturn ret;\n\n\tvco_rate = lmk04832_calc_pll2_params(prate, rate, &n, &p, &r);\n\tif (vco_rate < 0) {\n\t\tdev_err(lmk->dev, \"failed to determine PLL2 parameters\\n\");\n\t\treturn vco_rate;\n\t}\n\n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_PLL2_R_MSB,\n\t\t\t\t LMK04832_BIT_PLL2_R_MSB,\n\t\t\t\t FIELD_GET(0x000700, r));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(lmk->regmap, LMK04832_REG_PLL2_R_LSB,\n\t\t\t   FIELD_GET(0x0000ff, r));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_PLL2_MISC,\n\t\t\t\t LMK04832_BIT_PLL2_MISC_P,\n\t\t\t\t FIELD_PREP(LMK04832_BIT_PLL2_MISC_P, p));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(lmk->regmap, LMK04832_REG_PLL2_N_0,\n\t\t\t   FIELD_GET(0x030000, n));\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(lmk->regmap, LMK04832_REG_PLL2_N_1,\n\t\t\t   FIELD_GET(0x00ff00, n));\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(lmk->regmap, LMK04832_REG_PLL2_N_2,\n\t\t\t    FIELD_GET(0x0000ff, n));\n}\n\nstatic const struct clk_ops lmk04832_vco_ops = {\n\t.is_enabled = lmk04832_vco_is_enabled,\n\t.prepare = lmk04832_vco_prepare,\n\t.unprepare = lmk04832_vco_unprepare,\n\t.recalc_rate = lmk04832_vco_recalc_rate,\n\t.round_rate = lmk04832_vco_round_rate,\n\t.set_rate = lmk04832_vco_set_rate,\n};\n\n \nstatic int lmk04832_register_vco(struct lmk04832 *lmk)\n{\n\tconst char *parent_names[1];\n\tstruct clk_init_data init;\n\tint ret;\n\n\tinit.name = \"lmk-vco\";\n\tparent_names[0] = __clk_get_name(lmk->oscin);\n\tinit.parent_names = parent_names;\n\n\tinit.ops = &lmk04832_vco_ops;\n\tinit.num_parents = 1;\n\n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_VCO_OSCOUT,\n\t\t\t\t LMK04832_BIT_VCO_MUX,\n\t\t\t\t FIELD_PREP(LMK04832_BIT_VCO_MUX,\n\t\t\t\t\t    LMK04832_VAL_VCO_MUX_VCO1));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_FB_CTRL,\n\t\t\t\t LMK04832_BIT_PLL2_RCLK_MUX |\n\t\t\t\t LMK04832_BIT_PLL2_NCLK_MUX,\n\t\t\t\t FIELD_PREP(LMK04832_BIT_PLL2_RCLK_MUX,\n\t\t\t\t\t    LMK04832_VAL_PLL2_RCLK_MUX_OSCIN)|\n\t\t\t\t FIELD_PREP(LMK04832_BIT_PLL2_NCLK_MUX,\n\t\t\t\t\t    LMK04832_VAL_PLL2_NCLK_MUX_PLL2_P));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_PLL2_MISC,\n\t\t\t\t LMK04832_BIT_PLL2_MISC_REF_2X_EN,\n\t\t\t\t LMK04832_BIT_PLL2_MISC_REF_2X_EN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(lmk->regmap, LMK04832_REG_PLL2_LD,\n\t\t\t   FIELD_PREP(LMK04832_BIT_PLL2_LD_MUX,\n\t\t\t\t      LMK04832_VAL_PLL2_LD_MUX_PLL2_DLD) |\n\t\t\t   FIELD_PREP(LMK04832_BIT_PLL2_LD_TYPE,\n\t\t\t\t      LMK04832_VAL_PLL2_LD_TYPE_OUT_PP));\n\tif (ret)\n\t\treturn ret;\n\n\tlmk->vco.init = &init;\n\treturn devm_clk_hw_register(lmk->dev, &lmk->vco);\n}\n\nstatic int lmk04832_clkout_set_ddly(struct lmk04832 *lmk, int id)\n{\n\tconst int dclk_div_adj[] = {0, 0, -2, -2, 0, 3, -1, 0};\n\tunsigned int sclkx_y_ddly = 10;\n\tunsigned int dclkx_y_ddly;\n\tunsigned int dclkx_y_div;\n\tunsigned int sysref_ddly;\n\tunsigned int dclkx_y_hs;\n\tunsigned int lsb, msb;\n\tint ret;\n\n\tret = regmap_update_bits(lmk->regmap,\n\t\t\t\t LMK04832_REG_CLKOUT_CTRL2(id),\n\t\t\t\t LMK04832_BIT_DCLKX_Y_DDLY_PD,\n\t\t\t\t FIELD_PREP(LMK04832_BIT_DCLKX_Y_DDLY_PD, 0));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_SYSREF_DDLY_LSB, &lsb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_SYSREF_DDLY_MSB, &msb);\n\tif (ret)\n\t\treturn ret;\n\n\tsysref_ddly = FIELD_GET(LMK04832_BIT_SYSREF_DDLY_MSB, msb) << 8 | lsb;\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_CLKOUT_CTRL0(id), &lsb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_CLKOUT_CTRL2(id), &msb);\n\tif (ret)\n\t\treturn ret;\n\n\tdclkx_y_div = FIELD_GET(LMK04832_BIT_DCLK_DIV_MSB, msb) << 8 | lsb;\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_CLKOUT_CTRL3(id), &lsb);\n\tif (ret)\n\t\treturn ret;\n\n\tdclkx_y_hs = FIELD_GET(LMK04832_BIT_DCLKX_Y_HS, lsb);\n\n\tdclkx_y_ddly = sysref_ddly + 1 -\n\t\tdclk_div_adj[dclkx_y_div < 6 ?  dclkx_y_div : 7] -\n\t\tdclkx_y_hs + sclkx_y_ddly;\n\n\tif (dclkx_y_ddly < 7 || dclkx_y_ddly > 0x3fff) {\n\t\tdev_err(lmk->dev, \"DCLKX_Y_DDLY out of range (%d)\\n\",\n\t\t\tdclkx_y_ddly);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_write(lmk->regmap,\n\t\t\t   LMK04832_REG_SCLKX_Y_DDLY(id),\n\t\t\t   FIELD_GET(LMK04832_BIT_SCLKX_Y_DDLY, sclkx_y_ddly));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(lmk->regmap, LMK04832_REG_CLKOUT_CTRL1(id),\n\t\t\t\tFIELD_GET(0x00ff, dclkx_y_ddly));\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(lmk->dev, \"clkout%02u: sysref_ddly=%u, dclkx_y_ddly=%u, \"\n\t\t\"dclk_div_adj=%+d, dclkx_y_hs=%u, sclkx_y_ddly=%u\\n\",\n\t\tid, sysref_ddly, dclkx_y_ddly,\n\t\tdclk_div_adj[dclkx_y_div < 6 ? dclkx_y_div : 7],\n\t\tdclkx_y_hs, sclkx_y_ddly);\n\n\treturn regmap_update_bits(lmk->regmap, LMK04832_REG_CLKOUT_CTRL2(id),\n\t\t\t\t  LMK04832_BIT_DCLKX_Y_DDLY_MSB,\n\t\t\t\t  FIELD_GET(0x0300, dclkx_y_ddly));\n}\n\n \nstatic int lmk04832_sclk_sync_sequence(struct lmk04832 *lmk)\n{\n\tint ret;\n\tint i;\n\n\t \n\t \n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_MAIN_PD,\n\t\t\t\t LMK04832_BIT_SYSREF_DDLY_PD,\n\t\t\t\t FIELD_PREP(LMK04832_BIT_SYSREF_DDLY_PD, 0));\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < lmk->clk_data->num; i += 2) {\n\t\tret = lmk04832_clkout_set_ddly(lmk, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_SYSREF_OUT,\n\t\t\t\t LMK04832_BIT_SYSREF_REQ_EN |\n\t\t\t\t LMK04832_BIT_SYSREF_MUX,\n\t\t\t\t FIELD_PREP(LMK04832_BIT_SYSREF_REQ_EN, 0) |\n\t\t\t\t FIELD_PREP(LMK04832_BIT_SYSREF_MUX,\n\t\t\t\t\t    LMK04832_VAL_SYSREF_MUX_NORMAL_SYNC));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_SYNC,\n\t\t\t\t LMK04832_BIT_SYNC_MODE,\n\t\t\t\t FIELD_PREP(LMK04832_BIT_SYNC_MODE,\n\t\t\t\t\t    LMK04832_VAL_SYNC_MODE_ON));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(lmk->regmap, LMK04832_REG_SYNC_DIS, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_SYNC,\n\t\t\t\t LMK04832_BIT_SYNC_CLR,\n\t\t\t\t FIELD_PREP(LMK04832_BIT_SYNC_CLR, 0x01));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_SYNC,\n\t\t\t\t LMK04832_BIT_SYNC_CLR,\n\t\t\t\t FIELD_PREP(LMK04832_BIT_SYNC_CLR, 0x00));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_SYNC,\n\t\t\t   LMK04832_BIT_SYNC_POL,\n\t\t\t   FIELD_PREP(LMK04832_BIT_SYNC_POL, 0x01));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_SYNC,\n\t\t\t   LMK04832_BIT_SYNC_POL,\n\t\t\t   FIELD_PREP(LMK04832_BIT_SYNC_POL, 0x00));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(lmk->regmap, LMK04832_REG_SYNC_DIS, 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_SYSREF_OUT,\n\t\t\t\t LMK04832_BIT_SYSREF_MUX,\n\t\t\t\t FIELD_PREP(LMK04832_BIT_SYSREF_MUX,\n\t\t\t\t\t    lmk->sysref_mux));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_SYNC,\n\t\t\t\t LMK04832_BIT_SYNC_MODE,\n\t\t\t\t FIELD_PREP(LMK04832_BIT_SYNC_MODE,\n\t\t\t\t\t    lmk->sync_mode));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\t \n\n\treturn ret;\n}\n\nstatic int lmk04832_sclk_is_enabled(struct clk_hw *hw)\n{\n\tstruct lmk04832 *lmk = container_of(hw, struct lmk04832, sclk);\n\tunsigned int tmp;\n\tint ret;\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_MAIN_PD, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn FIELD_GET(LMK04832_BIT_SYSREF_PD, tmp);\n}\n\nstatic int lmk04832_sclk_prepare(struct clk_hw *hw)\n{\n\tstruct lmk04832 *lmk = container_of(hw, struct lmk04832, sclk);\n\n\treturn regmap_update_bits(lmk->regmap, LMK04832_REG_MAIN_PD,\n\t\t\t\t  LMK04832_BIT_SYSREF_PD, 0x00);\n}\n\nstatic void lmk04832_sclk_unprepare(struct clk_hw *hw)\n{\n\tstruct lmk04832 *lmk = container_of(hw, struct lmk04832, sclk);\n\n\tregmap_update_bits(lmk->regmap, LMK04832_REG_MAIN_PD,\n\t\t\t   LMK04832_BIT_SYSREF_PD, LMK04832_BIT_SYSREF_PD);\n}\n\nstatic unsigned long lmk04832_sclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long prate)\n{\n\tstruct lmk04832 *lmk = container_of(hw, struct lmk04832, sclk);\n\tunsigned int sysref_div;\n\tu8 tmp[2];\n\tint ret;\n\n\tret = regmap_bulk_read(lmk->regmap, LMK04832_REG_SYSREF_DIV_MSB, &tmp, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tsysref_div = FIELD_GET(LMK04832_BIT_SYSREF_DIV_MSB, tmp[0]) << 8 |\n\t\ttmp[1];\n\n\treturn DIV_ROUND_CLOSEST(prate, sysref_div);\n}\n\nstatic long lmk04832_sclk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long *prate)\n{\n\tstruct lmk04832 *lmk = container_of(hw, struct lmk04832, sclk);\n\tunsigned long sclk_rate;\n\tunsigned int sysref_div;\n\n\tsysref_div = DIV_ROUND_CLOSEST(*prate, rate);\n\tsclk_rate = DIV_ROUND_CLOSEST(*prate, sysref_div);\n\n\tif (sysref_div < 0x07 || sysref_div > 0x1fff) {\n\t\tdev_err(lmk->dev, \"SYSREF divider out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rate != sclk_rate)\n\t\treturn -EINVAL;\n\n\treturn sclk_rate;\n}\n\nstatic int lmk04832_sclk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long prate)\n{\n\tstruct lmk04832 *lmk = container_of(hw, struct lmk04832, sclk);\n\tunsigned int sysref_div;\n\tint ret;\n\n\tsysref_div = DIV_ROUND_CLOSEST(prate, rate);\n\n\tif (sysref_div < 0x07 || sysref_div > 0x1fff) {\n\t\tdev_err(lmk->dev, \"SYSREF divider out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_write(lmk->regmap, LMK04832_REG_SYSREF_DIV_MSB,\n\t\t\t   FIELD_GET(0x1f00, sysref_div));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(lmk->regmap, LMK04832_REG_SYSREF_DIV_LSB,\n\t\t\t    FIELD_GET(0x00ff, sysref_div));\n\tif (ret)\n\t\treturn ret;\n\n\tret = lmk04832_sclk_sync_sequence(lmk);\n\tif (ret)\n\t\tdev_err(lmk->dev, \"SYNC sequence failed\\n\");\n\n\treturn ret;\n}\n\nstatic const struct clk_ops lmk04832_sclk_ops = {\n\t.is_enabled = lmk04832_sclk_is_enabled,\n\t.prepare = lmk04832_sclk_prepare,\n\t.unprepare = lmk04832_sclk_unprepare,\n\t.recalc_rate = lmk04832_sclk_recalc_rate,\n\t.round_rate = lmk04832_sclk_round_rate,\n\t.set_rate = lmk04832_sclk_set_rate,\n};\n\nstatic int lmk04832_register_sclk(struct lmk04832 *lmk)\n{\n\tconst char *parent_names[1];\n\tstruct clk_init_data init;\n\tint ret;\n\n\tinit.name = \"lmk-sclk\";\n\tparent_names[0] = clk_hw_get_name(&lmk->vco);\n\tinit.parent_names = parent_names;\n\n\tinit.ops = &lmk04832_sclk_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.num_parents = 1;\n\n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_SYSREF_OUT,\n\t\t\t\t LMK04832_BIT_SYSREF_MUX,\n\t\t\t\t FIELD_PREP(LMK04832_BIT_SYSREF_MUX,\n\t\t\t\t\t    lmk->sysref_mux));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(lmk->regmap, LMK04832_REG_SYSREF_DDLY_LSB,\n\t\t\t   FIELD_GET(0x00ff, lmk->sysref_ddly));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(lmk->regmap, LMK04832_REG_SYSREF_DDLY_MSB,\n\t\t\t   FIELD_GET(0x1f00, lmk->sysref_ddly));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(lmk->regmap, LMK04832_REG_SYSREF_PULSE_CNT,\n\t\t\t   ilog2(lmk->sysref_pulse_cnt));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(lmk->regmap, LMK04832_REG_MAIN_PD,\n\t\t\t\t LMK04832_BIT_SYSREF_DDLY_PD |\n\t\t\t\t LMK04832_BIT_SYSREF_PLSR_PD,\n\t\t\t\t FIELD_PREP(LMK04832_BIT_SYSREF_DDLY_PD, 0) |\n\t\t\t\t FIELD_PREP(LMK04832_BIT_SYSREF_PLSR_PD, 0));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(lmk->regmap, LMK04832_REG_SYNC,\n\t\t\t   FIELD_PREP(LMK04832_BIT_SYNC_POL, 0) |\n\t\t\t   FIELD_PREP(LMK04832_BIT_SYNC_EN, 1) |\n\t\t\t   FIELD_PREP(LMK04832_BIT_SYNC_MODE, lmk->sync_mode));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(lmk->regmap, LMK04832_REG_SYNC_DIS, 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tlmk->sclk.init = &init;\n\treturn devm_clk_hw_register(lmk->dev, &lmk->sclk);\n}\n\nstatic int lmk04832_dclk_is_enabled(struct clk_hw *hw)\n{\n\tstruct lmk_dclk *dclk = container_of(hw, struct lmk_dclk, hw);\n\tstruct lmk04832 *lmk = dclk->lmk;\n\tunsigned int tmp;\n\tint ret;\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_CLKOUT_CTRL3(dclk->id),\n\t\t\t  &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !FIELD_GET(LMK04832_BIT_DCLKX_Y_PD, tmp);\n}\n\nstatic int lmk04832_dclk_prepare(struct clk_hw *hw)\n{\n\tstruct lmk_dclk *dclk = container_of(hw, struct lmk_dclk, hw);\n\tstruct lmk04832 *lmk = dclk->lmk;\n\n\treturn regmap_update_bits(lmk->regmap,\n\t\t\t\t  LMK04832_REG_CLKOUT_CTRL3(dclk->id),\n\t\t\t\t  LMK04832_BIT_DCLKX_Y_PD, 0x00);\n}\n\nstatic void lmk04832_dclk_unprepare(struct clk_hw *hw)\n{\n\tstruct lmk_dclk *dclk = container_of(hw, struct lmk_dclk, hw);\n\tstruct lmk04832 *lmk = dclk->lmk;\n\n\tregmap_update_bits(lmk->regmap,\n\t\t\t   LMK04832_REG_CLKOUT_CTRL3(dclk->id),\n\t\t\t   LMK04832_BIT_DCLKX_Y_PD, 0xff);\n}\n\nstatic unsigned long lmk04832_dclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long prate)\n{\n\tstruct lmk_dclk *dclk = container_of(hw, struct lmk_dclk, hw);\n\tstruct lmk04832 *lmk = dclk->lmk;\n\tunsigned int dclk_div;\n\tunsigned int lsb, msb;\n\tunsigned long rate;\n\tint ret;\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_CLKOUT_CTRL0(dclk->id),\n\t\t\t  &lsb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_CLKOUT_CTRL2(dclk->id),\n\t\t\t  &msb);\n\tif (ret)\n\t\treturn ret;\n\n\tdclk_div = FIELD_GET(LMK04832_BIT_DCLK_DIV_MSB, msb) << 8 | lsb;\n\trate = DIV_ROUND_CLOSEST(prate, dclk_div);\n\n\treturn rate;\n}\n\nstatic long lmk04832_dclk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long *prate)\n{\n\tstruct lmk_dclk *dclk = container_of(hw, struct lmk_dclk, hw);\n\tstruct lmk04832 *lmk = dclk->lmk;\n\tunsigned long dclk_rate;\n\tunsigned int dclk_div;\n\n\tdclk_div = DIV_ROUND_CLOSEST(*prate, rate);\n\tdclk_rate = DIV_ROUND_CLOSEST(*prate, dclk_div);\n\n\tif (dclk_div < 1 || dclk_div > 0x3ff) {\n\t\tdev_err(lmk->dev, \"%s_div out of range\\n\", clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\tif (rate != dclk_rate)\n\t\treturn -EINVAL;\n\n\treturn dclk_rate;\n}\n\nstatic int lmk04832_dclk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long prate)\n{\n\tstruct lmk_dclk *dclk = container_of(hw, struct lmk_dclk, hw);\n\tstruct lmk04832 *lmk = dclk->lmk;\n\tunsigned int dclk_div;\n\tint ret;\n\n\tdclk_div = DIV_ROUND_CLOSEST(prate, rate);\n\n\tif (dclk_div > 0x3ff) {\n\t\tdev_err(lmk->dev, \"%s_div out of range\\n\", clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (dclk_div == 1) {\n\t\tret = regmap_update_bits(lmk->regmap,\n\t\t\t\t\t LMK04832_REG_CLKOUT_CTRL3(dclk->id),\n\t\t\t\t\t LMK04832_BIT_DCLKX_Y_DCC,\n\t\t\t\t\t FIELD_PREP(LMK04832_BIT_DCLKX_Y_DCC, 1));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (dclk_div == 2 || dclk_div == 3) {\n\t\tret = regmap_update_bits(lmk->regmap,\n\t\t\t\t\t LMK04832_REG_CLKOUT_CTRL2(dclk->id),\n\t\t\t\t\t LMK04832_BIT_DCLK_DIV_MSB, 0x00);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(lmk->regmap,\n\t\t\t\t   LMK04832_REG_CLKOUT_CTRL0(dclk->id), 0x04);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = regmap_write(lmk->regmap, LMK04832_REG_CLKOUT_CTRL0(dclk->id),\n\t\t\t   FIELD_GET(0x0ff, dclk_div));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(lmk->regmap,\n\t\t\t\t  LMK04832_REG_CLKOUT_CTRL2(dclk->id),\n\t\t\t\t  LMK04832_BIT_DCLK_DIV_MSB,\n\t\t\t\t  FIELD_GET(0x300, dclk_div));\n\tif (ret)\n\t\treturn ret;\n\n\tret = lmk04832_sclk_sync_sequence(lmk);\n\tif (ret)\n\t\tdev_err(lmk->dev, \"SYNC sequence failed\\n\");\n\n\treturn ret;\n}\n\nstatic const struct clk_ops lmk04832_dclk_ops = {\n\t.is_enabled = lmk04832_dclk_is_enabled,\n\t.prepare = lmk04832_dclk_prepare,\n\t.unprepare = lmk04832_dclk_unprepare,\n\t.recalc_rate = lmk04832_dclk_recalc_rate,\n\t.round_rate = lmk04832_dclk_round_rate,\n\t.set_rate = lmk04832_dclk_set_rate,\n};\n\nstatic int lmk04832_clkout_is_enabled(struct clk_hw *hw)\n{\n\tstruct lmk_clkout *clkout = container_of(hw, struct lmk_clkout, hw);\n\tstruct lmk04832 *lmk = clkout->lmk;\n\tunsigned int clkoutx_y_pd;\n\tunsigned int sclkx_y_pd;\n\tunsigned int tmp;\n\tu32 enabled;\n\tint ret;\n\tu8 fmt;\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_CLKOUT_CTRL2(clkout->id),\n\t\t\t  &clkoutx_y_pd);\n\tif (ret)\n\t\treturn ret;\n\n\tenabled = !FIELD_GET(LMK04832_BIT_CLKOUTX_Y_PD, clkoutx_y_pd);\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_CLKOUT_SRC_MUX(clkout->id),\n\t\t\t  &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (FIELD_GET(LMK04832_BIT_CLKOUT_SRC_MUX, tmp)) {\n\t\tret = regmap_read(lmk->regmap,\n\t\t\t\t  LMK04832_REG_CLKOUT_CTRL4(clkout->id),\n\t\t\t\t  &sclkx_y_pd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tenabled = enabled && !FIELD_GET(LMK04832_BIT_SCLK_PD, sclkx_y_pd);\n\t}\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_CLKOUT_FMT(clkout->id),\n\t\t\t  &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (clkout->id % 2)\n\t\tfmt = FIELD_GET(0xf0, tmp);\n\telse\n\t\tfmt = FIELD_GET(0x0f, tmp);\n\n\treturn enabled && !fmt;\n}\n\nstatic int lmk04832_clkout_prepare(struct clk_hw *hw)\n{\n\tstruct lmk_clkout *clkout = container_of(hw, struct lmk_clkout, hw);\n\tstruct lmk04832 *lmk = clkout->lmk;\n\tunsigned int tmp;\n\tint ret;\n\n\tif (clkout->format == LMK04832_VAL_CLKOUT_FMT_POWERDOWN)\n\t\tdev_err(lmk->dev, \"prepared %s but format is powerdown\\n\",\n\t\t\tclk_hw_get_name(hw));\n\n\tret = regmap_update_bits(lmk->regmap,\n\t\t\t\t LMK04832_REG_CLKOUT_CTRL2(clkout->id),\n\t\t\t\t LMK04832_BIT_CLKOUTX_Y_PD, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_CLKOUT_SRC_MUX(clkout->id),\n\t\t\t  &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (FIELD_GET(LMK04832_BIT_CLKOUT_SRC_MUX, tmp)) {\n\t\tret = regmap_update_bits(lmk->regmap,\n\t\t\t\t\t LMK04832_REG_CLKOUT_CTRL4(clkout->id),\n\t\t\t\t\t LMK04832_BIT_SCLK_PD, 0x00);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn regmap_update_bits(lmk->regmap,\n\t\t\t\t  LMK04832_REG_CLKOUT_FMT(clkout->id),\n\t\t\t\t  LMK04832_BIT_CLKOUT_FMT(clkout->id),\n\t\t\t\t  clkout->format << 4 * (clkout->id % 2));\n}\n\nstatic void lmk04832_clkout_unprepare(struct clk_hw *hw)\n{\n\tstruct lmk_clkout *clkout = container_of(hw, struct lmk_clkout, hw);\n\tstruct lmk04832 *lmk = clkout->lmk;\n\n\tregmap_update_bits(lmk->regmap, LMK04832_REG_CLKOUT_FMT(clkout->id),\n\t\t\t   LMK04832_BIT_CLKOUT_FMT(clkout->id),\n\t\t\t   0x00);\n}\n\nstatic int lmk04832_clkout_set_parent(struct clk_hw *hw, uint8_t index)\n{\n\tstruct lmk_clkout *clkout = container_of(hw, struct lmk_clkout, hw);\n\tstruct lmk04832 *lmk = clkout->lmk;\n\n\treturn regmap_update_bits(lmk->regmap,\n\t\t\t\t  LMK04832_REG_CLKOUT_SRC_MUX(clkout->id),\n\t\t\t\t  LMK04832_BIT_CLKOUT_SRC_MUX,\n\t\t\t\t  FIELD_PREP(LMK04832_BIT_CLKOUT_SRC_MUX,\n\t\t\t\t\t     index));\n}\n\nstatic uint8_t lmk04832_clkout_get_parent(struct clk_hw *hw)\n{\n\tstruct lmk_clkout *clkout = container_of(hw, struct lmk_clkout, hw);\n\tstruct lmk04832 *lmk = clkout->lmk;\n\tunsigned int tmp;\n\tint ret;\n\n\tret = regmap_read(lmk->regmap, LMK04832_REG_CLKOUT_SRC_MUX(clkout->id),\n\t\t\t  &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn FIELD_GET(LMK04832_BIT_CLKOUT_SRC_MUX, tmp);\n}\n\nstatic const struct clk_ops lmk04832_clkout_ops = {\n\t.is_enabled = lmk04832_clkout_is_enabled,\n\t.prepare = lmk04832_clkout_prepare,\n\t.unprepare = lmk04832_clkout_unprepare,\n\t.determine_rate = __clk_mux_determine_rate,\n\t.set_parent = lmk04832_clkout_set_parent,\n\t.get_parent = lmk04832_clkout_get_parent,\n};\n\nstatic int lmk04832_register_clkout(struct lmk04832 *lmk, const int num)\n{\n\tchar name[] = \"lmk-clkoutXX\";\n\tchar dclk_name[] = \"lmk-dclkXX_YY\";\n\tconst char *parent_names[2];\n\tstruct clk_init_data init;\n\tint dclk_num = num / 2;\n\tint ret;\n\n\tif (num % 2 == 0) {\n\t\tsprintf(dclk_name, \"lmk-dclk%02d_%02d\", num, num + 1);\n\t\tinit.name = dclk_name;\n\t\tparent_names[0] = clk_hw_get_name(&lmk->vco);\n\t\tinit.parent_names = parent_names;\n\t\tinit.ops = &lmk04832_dclk_ops;\n\t\tinit.flags = CLK_SET_RATE_PARENT;\n\t\tinit.num_parents = 1;\n\n\t\tlmk->dclk[dclk_num].id = num;\n\t\tlmk->dclk[dclk_num].lmk = lmk;\n\t\tlmk->dclk[dclk_num].hw.init = &init;\n\n\t\tret = devm_clk_hw_register(lmk->dev, &lmk->dclk[dclk_num].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tsprintf(dclk_name, \"lmk-dclk%02d_%02d\", num - 1, num);\n\t}\n\n\tif (of_property_read_string_index(lmk->dev->of_node,\n\t\t\t\t\t  \"clock-output-names\",\n\t\t\t\t\t  num, &init.name)) {\n\t\tsprintf(name, \"lmk-clkout%02d\", num);\n\t\tinit.name = name;\n\t}\n\n\tparent_names[0] = dclk_name;\n\tparent_names[1] = clk_hw_get_name(&lmk->sclk);\n\tinit.parent_names = parent_names;\n\tinit.ops = &lmk04832_clkout_ops;\n\tinit.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT;\n\tinit.num_parents = ARRAY_SIZE(parent_names);\n\n\tlmk->clkout[num].id = num;\n\tlmk->clkout[num].lmk = lmk;\n\tlmk->clkout[num].hw.init = &init;\n\tlmk->clk_data->hws[num] = &lmk->clkout[num].hw;\n\n\t \n\tregmap_update_bits(lmk->regmap,\n\t\t\t   LMK04832_REG_CLKOUT_SRC_MUX(num),\n\t\t\t   LMK04832_BIT_CLKOUT_SRC_MUX,\n\t\t\t   FIELD_PREP(LMK04832_BIT_CLKOUT_SRC_MUX,\n\t\t\t\t      lmk->clkout[num].sysref));\n\n\treturn devm_clk_hw_register(lmk->dev, &lmk->clkout[num].hw);\n}\n\nstatic int lmk04832_set_spi_rdbk(const struct lmk04832 *lmk, const int rdbk_pin)\n{\n\tint reg;\n\tint ret;\n\tint val = FIELD_PREP(LMK04832_BIT_CLKIN_SEL_MUX,\n\t\t\t     LMK04832_VAL_CLKIN_SEL_MUX_SPI_RDBK) |\n\t\t  FIELD_PREP(LMK04832_BIT_CLKIN_SEL_TYPE,\n\t\t\t     LMK04832_VAL_CLKIN_SEL_TYPE_OUT);\n\n\tdev_info(lmk->dev, \"setting up 4-wire mode\\n\");\n\tret = regmap_write(lmk->regmap, LMK04832_REG_RST3W,\n\t\t\t   LMK04832_BIT_SPI_3WIRE_DIS);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (rdbk_pin) {\n\tcase RDBK_CLKIN_SEL0:\n\t\treg = LMK04832_REG_CLKIN_SEL0;\n\t\tbreak;\n\tcase RDBK_CLKIN_SEL1:\n\t\treg = LMK04832_REG_CLKIN_SEL1;\n\t\tbreak;\n\tcase RDBK_RESET:\n\t\treg = LMK04832_REG_CLKIN_RST;\n\t\tbreak;\n\tcase RDBK_PLL1_LD:\n\t\treg = LMK04832_REG_PLL1_LD;\n\t\tval = FIELD_PREP(LMK04832_BIT_PLL1_LD_MUX,\n\t\t\t\t LMK04832_VAL_PLL1_LD_MUX_SPI_RDBK) |\n\t\t      FIELD_PREP(LMK04832_BIT_PLL1_LD_TYPE,\n\t\t\t\t LMK04832_VAL_PLL1_LD_TYPE_OUT_PP);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_write(lmk->regmap, reg, val);\n}\n\nstatic int lmk04832_probe(struct spi_device *spi)\n{\n\tconst struct lmk04832_device_info *info;\n\tint rdbk_pin = RDBK_CLKIN_SEL1;\n\tstruct device_node *child;\n\tstruct lmk04832 *lmk;\n\tu8 tmp[3];\n\tint ret;\n\tint i;\n\n\tinfo = &lmk04832_device_info[spi_get_device_id(spi)->driver_data];\n\n\tlmk = devm_kzalloc(&spi->dev, sizeof(struct lmk04832), GFP_KERNEL);\n\tif (!lmk)\n\t\treturn -ENOMEM;\n\n\tlmk->dev = &spi->dev;\n\n\tlmk->oscin = devm_clk_get(lmk->dev, \"oscin\");\n\tif (IS_ERR(lmk->oscin)) {\n\t\tdev_err(lmk->dev, \"failed to get oscin clock\\n\");\n\t\treturn PTR_ERR(lmk->oscin);\n\t}\n\n\tret = clk_prepare_enable(lmk->oscin);\n\tif (ret)\n\t\treturn ret;\n\n\tlmk->reset_gpio = devm_gpiod_get_optional(&spi->dev, \"reset\",\n\t\t\t\t\t\t  GPIOD_OUT_LOW);\n\n\tlmk->dclk = devm_kcalloc(lmk->dev, info->num_channels >> 1,\n\t\t\t\t sizeof(struct lmk_dclk), GFP_KERNEL);\n\tif (!lmk->dclk) {\n\t\tret = -ENOMEM;\n\t\tgoto err_disable_oscin;\n\t}\n\n\tlmk->clkout = devm_kcalloc(lmk->dev, info->num_channels,\n\t\t\t\t   sizeof(*lmk->clkout), GFP_KERNEL);\n\tif (!lmk->clkout) {\n\t\tret = -ENOMEM;\n\t\tgoto err_disable_oscin;\n\t}\n\n\tlmk->clk_data = devm_kzalloc(lmk->dev, struct_size(lmk->clk_data, hws,\n\t\t\t\t\t\t\t   info->num_channels),\n\t\t\t\t     GFP_KERNEL);\n\tif (!lmk->clk_data) {\n\t\tret = -ENOMEM;\n\t\tgoto err_disable_oscin;\n\t}\n\n\tdevice_property_read_u32(lmk->dev, \"ti,vco-hz\", &lmk->vco_rate);\n\n\tlmk->sysref_ddly = 8;\n\tdevice_property_read_u32(lmk->dev, \"ti,sysref-ddly\", &lmk->sysref_ddly);\n\n\tlmk->sysref_mux = LMK04832_VAL_SYSREF_MUX_CONTINUOUS;\n\tdevice_property_read_u32(lmk->dev, \"ti,sysref-mux\",\n\t\t\t\t &lmk->sysref_mux);\n\n\tlmk->sync_mode = LMK04832_VAL_SYNC_MODE_OFF;\n\tdevice_property_read_u32(lmk->dev, \"ti,sync-mode\",\n\t\t\t\t &lmk->sync_mode);\n\n\tlmk->sysref_pulse_cnt = 4;\n\tdevice_property_read_u32(lmk->dev, \"ti,sysref-pulse-count\",\n\t\t\t\t &lmk->sysref_pulse_cnt);\n\n\tfor_each_child_of_node(lmk->dev->of_node, child) {\n\t\tint reg;\n\n\t\tret = of_property_read_u32(child, \"reg\", &reg);\n\t\tif (ret) {\n\t\t\tdev_err(lmk->dev, \"missing reg property in child: %s\\n\",\n\t\t\t\tchild->full_name);\n\t\t\tof_node_put(child);\n\t\t\tgoto err_disable_oscin;\n\t\t}\n\n\t\tof_property_read_u32(child, \"ti,clkout-fmt\",\n\t\t\t\t     &lmk->clkout[reg].format);\n\n\t\tif (lmk->clkout[reg].format >= 0x0a && reg % 2 == 0\n\t\t    && reg != 8 && reg != 10)\n\t\t\tdev_err(lmk->dev, \"invalid format for clkout%02d\\n\",\n\t\t\t\treg);\n\n\t\tlmk->clkout[reg].sysref =\n\t\t\tof_property_read_bool(child, \"ti,clkout-sysref\");\n\t}\n\n\tlmk->regmap = devm_regmap_init_spi(spi, &regmap_config);\n\tif (IS_ERR(lmk->regmap)) {\n\t\tdev_err(lmk->dev, \"%s: regmap allocation failed: %ld\\n\",\n\n\t\t\t__func__, PTR_ERR(lmk->regmap));\n\t\tret = PTR_ERR(lmk->regmap);\n\t\tgoto err_disable_oscin;\n\t}\n\n\tregmap_write(lmk->regmap, LMK04832_REG_RST3W, LMK04832_BIT_RESET);\n\n\tif (!(spi->mode & SPI_3WIRE)) {\n\t\tdevice_property_read_u32(lmk->dev, \"ti,spi-4wire-rdbk\",\n\t\t\t\t\t &rdbk_pin);\n\t\tret = lmk04832_set_spi_rdbk(lmk, rdbk_pin);\n\t\tif (ret)\n\t\t\tgoto err_disable_oscin;\n\t}\n\n\tregmap_bulk_read(lmk->regmap, LMK04832_REG_ID_PROD_MSB, &tmp, 3);\n\tif ((tmp[0] << 8 | tmp[1]) != info->pid || tmp[2] != info->maskrev) {\n\t\tdev_err(lmk->dev, \"unsupported device type: pid 0x%04x, maskrev 0x%02x\\n\",\n\t\t\ttmp[0] << 8 | tmp[1], tmp[2]);\n\t\tret = -EINVAL;\n\t\tgoto err_disable_oscin;\n\t}\n\n\tret = lmk04832_register_vco(lmk);\n\tif (ret) {\n\t\tdev_err(lmk->dev, \"failed to init device clock path\\n\");\n\t\tgoto err_disable_oscin;\n\t}\n\n\tif (lmk->vco_rate) {\n\t\tdev_info(lmk->dev, \"setting VCO rate to %u Hz\\n\", lmk->vco_rate);\n\t\tret = clk_set_rate(lmk->vco.clk, lmk->vco_rate);\n\t\tif (ret) {\n\t\t\tdev_err(lmk->dev, \"failed to set VCO rate\\n\");\n\t\t\tgoto err_disable_oscin;\n\t\t}\n\t}\n\n\tret = lmk04832_register_sclk(lmk);\n\tif (ret) {\n\t\tdev_err(lmk->dev, \"failed to init SYNC/SYSREF clock path\\n\");\n\t\tgoto err_disable_oscin;\n\t}\n\n\tfor (i = 0; i < info->num_channels; i++) {\n\t\tret = lmk04832_register_clkout(lmk, i);\n\t\tif (ret) {\n\t\t\tdev_err(lmk->dev, \"failed to register clk %d\\n\", i);\n\t\t\tgoto err_disable_oscin;\n\t\t}\n\t}\n\n\tlmk->clk_data->num = info->num_channels;\n\tret = devm_of_clk_add_hw_provider(lmk->dev, of_clk_hw_onecell_get,\n\t\t\t\t\t  lmk->clk_data);\n\tif (ret) {\n\t\tdev_err(lmk->dev, \"failed to add provider (%d)\\n\", ret);\n\t\tgoto err_disable_oscin;\n\t}\n\n\tspi_set_drvdata(spi, lmk);\n\n\treturn 0;\n\nerr_disable_oscin:\n\tclk_disable_unprepare(lmk->oscin);\n\n\treturn ret;\n}\n\nstatic void lmk04832_remove(struct spi_device *spi)\n{\n\tstruct lmk04832 *lmk = spi_get_drvdata(spi);\n\n\tclk_disable_unprepare(lmk->oscin);\n}\n\nstatic const struct spi_device_id lmk04832_id[] = {\n\t{ \"lmk04832\", LMK04832 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, lmk04832_id);\n\nstatic const struct of_device_id lmk04832_of_id[] = {\n\t{ .compatible = \"ti,lmk04832\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, lmk04832_of_id);\n\nstatic struct spi_driver lmk04832_driver = {\n\t.driver = {\n\t\t.name\t= \"lmk04832\",\n\t\t.of_match_table = lmk04832_of_id,\n\t},\n\t.probe\t\t= lmk04832_probe,\n\t.remove\t\t= lmk04832_remove,\n\t.id_table\t= lmk04832_id,\n};\nmodule_spi_driver(lmk04832_driver);\n\nMODULE_AUTHOR(\"Liam Beguin <lvb@xiphos.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments LMK04832\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}