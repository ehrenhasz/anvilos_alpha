{
  "module_name": "clk-s2mps11.c",
  "hash_id": "feca386d2c42454949de311f333358ce78458ff42033f293d23a205ad0a4123c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-s2mps11.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/clkdev.h>\n#include <linux/regmap.h>\n#include <linux/clk-provider.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/samsung/s2mps11.h>\n#include <linux/mfd/samsung/s2mps13.h>\n#include <linux/mfd/samsung/s2mps14.h>\n#include <linux/mfd/samsung/s5m8767.h>\n#include <linux/mfd/samsung/core.h>\n\n#include <dt-bindings/clock/samsung,s2mps11.h>\n\nstruct s2mps11_clk {\n\tstruct sec_pmic_dev *iodev;\n\tstruct device_node *clk_np;\n\tstruct clk_hw hw;\n\tstruct clk *clk;\n\tstruct clk_lookup *lookup;\n\tu32 mask;\n\tunsigned int reg;\n};\n\nstatic struct s2mps11_clk *to_s2mps11_clk(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct s2mps11_clk, hw);\n}\n\nstatic int s2mps11_clk_prepare(struct clk_hw *hw)\n{\n\tstruct s2mps11_clk *s2mps11 = to_s2mps11_clk(hw);\n\n\treturn regmap_update_bits(s2mps11->iodev->regmap_pmic,\n\t\t\t\t s2mps11->reg,\n\t\t\t\t s2mps11->mask, s2mps11->mask);\n}\n\nstatic void s2mps11_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct s2mps11_clk *s2mps11 = to_s2mps11_clk(hw);\n\n\tregmap_update_bits(s2mps11->iodev->regmap_pmic, s2mps11->reg,\n\t\t\t   s2mps11->mask, ~s2mps11->mask);\n}\n\nstatic int s2mps11_clk_is_prepared(struct clk_hw *hw)\n{\n\tint ret;\n\tu32 val;\n\tstruct s2mps11_clk *s2mps11 = to_s2mps11_clk(hw);\n\n\tret = regmap_read(s2mps11->iodev->regmap_pmic,\n\t\t\t\ts2mps11->reg, &val);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\treturn val & s2mps11->mask;\n}\n\nstatic unsigned long s2mps11_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\treturn 32768;\n}\n\nstatic const struct clk_ops s2mps11_clk_ops = {\n\t.prepare\t= s2mps11_clk_prepare,\n\t.unprepare\t= s2mps11_clk_unprepare,\n\t.is_prepared\t= s2mps11_clk_is_prepared,\n\t.recalc_rate\t= s2mps11_clk_recalc_rate,\n};\n\n \nstatic struct clk_init_data s2mps11_clks_init[S2MPS11_CLKS_NUM] = {\n\t[S2MPS11_CLK_AP] = {\n\t\t.name = \"s2mps11_ap\",\n\t\t.ops = &s2mps11_clk_ops,\n\t},\n\t[S2MPS11_CLK_CP] = {\n\t\t.name = \"s2mps11_cp\",\n\t\t.ops = &s2mps11_clk_ops,\n\t},\n\t[S2MPS11_CLK_BT] = {\n\t\t.name = \"s2mps11_bt\",\n\t\t.ops = &s2mps11_clk_ops,\n\t},\n};\n\nstatic struct device_node *s2mps11_clk_parse_dt(struct platform_device *pdev,\n\t\tstruct clk_init_data *clks_init)\n{\n\tstruct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);\n\tstruct device_node *clk_np;\n\tint i;\n\n\tif (!iodev->dev->of_node)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tclk_np = of_get_child_by_name(iodev->dev->of_node, \"clocks\");\n\tif (!clk_np) {\n\t\tdev_err(&pdev->dev, \"could not find clock sub-node\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfor (i = 0; i < S2MPS11_CLKS_NUM; i++)\n\t\tof_property_read_string_index(clk_np, \"clock-output-names\", i,\n\t\t\t\t&clks_init[i].name);\n\n\treturn clk_np;\n}\n\nstatic int s2mps11_clk_probe(struct platform_device *pdev)\n{\n\tstruct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);\n\tstruct s2mps11_clk *s2mps11_clks;\n\tstruct clk_hw_onecell_data *clk_data;\n\tunsigned int s2mps11_reg;\n\tint i, ret = 0;\n\tenum sec_device_type hwid = platform_get_device_id(pdev)->driver_data;\n\n\ts2mps11_clks = devm_kcalloc(&pdev->dev, S2MPS11_CLKS_NUM,\n\t\t\t\tsizeof(*s2mps11_clks), GFP_KERNEL);\n\tif (!s2mps11_clks)\n\t\treturn -ENOMEM;\n\n\tclk_data = devm_kzalloc(&pdev->dev,\n\t\t\t\tstruct_size(clk_data, hws, S2MPS11_CLKS_NUM),\n\t\t\t\tGFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tswitch (hwid) {\n\tcase S2MPS11X:\n\t\ts2mps11_reg = S2MPS11_REG_RTC_CTRL;\n\t\tbreak;\n\tcase S2MPS13X:\n\t\ts2mps11_reg = S2MPS13_REG_RTCCTRL;\n\t\tbreak;\n\tcase S2MPS14X:\n\t\ts2mps11_reg = S2MPS14_REG_RTCCTRL;\n\t\tbreak;\n\tcase S5M8767X:\n\t\ts2mps11_reg = S5M8767_REG_CTRL1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Invalid device type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ts2mps11_clks->clk_np = s2mps11_clk_parse_dt(pdev, s2mps11_clks_init);\n\tif (IS_ERR(s2mps11_clks->clk_np))\n\t\treturn PTR_ERR(s2mps11_clks->clk_np);\n\n\tfor (i = 0; i < S2MPS11_CLKS_NUM; i++) {\n\t\tif (i == S2MPS11_CLK_CP && hwid == S2MPS14X)\n\t\t\tcontinue;  \n\t\ts2mps11_clks[i].iodev = iodev;\n\t\ts2mps11_clks[i].hw.init = &s2mps11_clks_init[i];\n\t\ts2mps11_clks[i].mask = 1 << i;\n\t\ts2mps11_clks[i].reg = s2mps11_reg;\n\n\t\ts2mps11_clks[i].clk = devm_clk_register(&pdev->dev,\n\t\t\t\t\t\t\t&s2mps11_clks[i].hw);\n\t\tif (IS_ERR(s2mps11_clks[i].clk)) {\n\t\t\tdev_err(&pdev->dev, \"Fail to register : %s\\n\",\n\t\t\t\t\t\ts2mps11_clks_init[i].name);\n\t\t\tret = PTR_ERR(s2mps11_clks[i].clk);\n\t\t\tgoto err_reg;\n\t\t}\n\n\t\ts2mps11_clks[i].lookup = clkdev_hw_create(&s2mps11_clks[i].hw,\n\t\t\t\t\ts2mps11_clks_init[i].name, NULL);\n\t\tif (!s2mps11_clks[i].lookup) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_reg;\n\t\t}\n\t\tclk_data->hws[i] = &s2mps11_clks[i].hw;\n\t}\n\n\tclk_data->num = S2MPS11_CLKS_NUM;\n\tof_clk_add_hw_provider(s2mps11_clks->clk_np, of_clk_hw_onecell_get,\n\t\t\t       clk_data);\n\n\tplatform_set_drvdata(pdev, s2mps11_clks);\n\n\treturn ret;\n\nerr_reg:\n\tof_node_put(s2mps11_clks[0].clk_np);\n\twhile (--i >= 0)\n\t\tclkdev_drop(s2mps11_clks[i].lookup);\n\n\treturn ret;\n}\n\nstatic void s2mps11_clk_remove(struct platform_device *pdev)\n{\n\tstruct s2mps11_clk *s2mps11_clks = platform_get_drvdata(pdev);\n\tint i;\n\n\tof_clk_del_provider(s2mps11_clks[0].clk_np);\n\t \n\tof_node_put(s2mps11_clks[0].clk_np);\n\n\tfor (i = 0; i < S2MPS11_CLKS_NUM; i++) {\n\t\t \n\t\tif (!s2mps11_clks[i].lookup)\n\t\t\tcontinue;\n\t\tclkdev_drop(s2mps11_clks[i].lookup);\n\t}\n}\n\nstatic const struct platform_device_id s2mps11_clk_id[] = {\n\t{ \"s2mps11-clk\", S2MPS11X},\n\t{ \"s2mps13-clk\", S2MPS13X},\n\t{ \"s2mps14-clk\", S2MPS14X},\n\t{ \"s5m8767-clk\", S5M8767X},\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, s2mps11_clk_id);\n\n#ifdef CONFIG_OF\n \nstatic const struct of_device_id s2mps11_dt_match[] __used = {\n\t{\n\t\t.compatible = \"samsung,s2mps11-clk\",\n\t\t.data = (void *)S2MPS11X,\n\t}, {\n\t\t.compatible = \"samsung,s2mps13-clk\",\n\t\t.data = (void *)S2MPS13X,\n\t}, {\n\t\t.compatible = \"samsung,s2mps14-clk\",\n\t\t.data = (void *)S2MPS14X,\n\t}, {\n\t\t.compatible = \"samsung,s5m8767-clk\",\n\t\t.data = (void *)S5M8767X,\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, s2mps11_dt_match);\n#endif\n\nstatic struct platform_driver s2mps11_clk_driver = {\n\t.driver = {\n\t\t.name  = \"s2mps11-clk\",\n\t},\n\t.probe = s2mps11_clk_probe,\n\t.remove_new = s2mps11_clk_remove,\n\t.id_table = s2mps11_clk_id,\n};\nmodule_platform_driver(s2mps11_clk_driver);\n\nMODULE_DESCRIPTION(\"S2MPS11 Clock Driver\");\nMODULE_AUTHOR(\"Yadwinder Singh Brar <yadi.brar@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}