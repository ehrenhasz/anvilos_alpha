{
  "module_name": "clk-pxa3xx.c",
  "hash_id": "a88b5adfaa3f56830848079f9989addab6592520b28ec2323a47b00eca921801",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/pxa/clk-pxa3xx.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/of.h>\n#include <linux/soc/pxa/cpu.h>\n#include <linux/soc/pxa/smemc.h>\n#include <linux/clk/pxa.h>\n\n#include <dt-bindings/clock/pxa-clock.h>\n#include \"clk-pxa.h\"\n\n#define KHz 1000\n#define MHz (1000 * 1000)\n\n#define ACCR\t\t\t(0x0000)\t \n#define ACSR\t\t\t(0x0004)\t \n#define AICSR\t\t\t(0x0008)\t \n#define CKENA\t\t\t(0x000C)\t \n#define CKENB\t\t\t(0x0010)\t \n#define CKENC\t\t\t(0x0024)\t \n#define AC97_DIV\t\t(0x0014)\t \n\n#define ACCR_XPDIS\t\t(1 << 31)\t \n#define ACCR_SPDIS\t\t(1 << 30)\t \n#define ACCR_D0CS\t\t(1 << 26)\t \n#define ACCR_PCCE\t\t(1 << 11)\t \n#define ACCR_DDR_D0CS\t\t(1 << 7)\t \n\n#define ACCR_SMCFS_MASK\t\t(0x7 << 23)\t \n#define ACCR_SFLFS_MASK\t\t(0x3 << 18)\t \n#define ACCR_XSPCLK_MASK\t(0x3 << 16)\t \n#define ACCR_HSS_MASK\t\t(0x3 << 14)\t \n#define ACCR_DMCFS_MASK\t\t(0x3 << 12)\t \n#define ACCR_XN_MASK\t\t(0x7 << 8)\t \n#define ACCR_XL_MASK\t\t(0x1f)\t\t \n\n#define ACCR_SMCFS(x)\t\t(((x) & 0x7) << 23)\n#define ACCR_SFLFS(x)\t\t(((x) & 0x3) << 18)\n#define ACCR_XSPCLK(x)\t\t(((x) & 0x3) << 16)\n#define ACCR_HSS(x)\t\t(((x) & 0x3) << 14)\n#define ACCR_DMCFS(x)\t\t(((x) & 0x3) << 12)\n#define ACCR_XN(x)\t\t(((x) & 0x7) << 8)\n#define ACCR_XL(x)\t\t((x) & 0x1f)\n\n \n#define CKEN_LCD\t1\t \n#define CKEN_USBH\t2\t \n#define CKEN_CAMERA\t3\t \n#define CKEN_NAND\t4\t \n#define CKEN_USB2\t6\t \n#define CKEN_DMC\t8\t \n#define CKEN_SMC\t9\t \n#define CKEN_ISC\t10\t \n#define CKEN_BOOT\t11\t \n#define CKEN_MMC1\t12\t \n#define CKEN_MMC2\t13\t \n#define CKEN_KEYPAD\t14\t \n#define CKEN_CIR\t15\t \n#define CKEN_USIM0\t17\t \n#define CKEN_USIM1\t18\t \n#define CKEN_TPM\t19\t \n#define CKEN_UDC\t20\t \n#define CKEN_BTUART\t21\t \n#define CKEN_FFUART\t22\t \n#define CKEN_STUART\t23\t \n#define CKEN_AC97\t24\t \n#define CKEN_TOUCH\t25\t \n#define CKEN_SSP1\t26\t \n#define CKEN_SSP2\t27\t \n#define CKEN_SSP3\t28\t \n#define CKEN_SSP4\t29\t \n#define CKEN_MSL0\t30\t \n#define CKEN_PWM0\t32\t \n#define CKEN_PWM1\t33\t \n#define CKEN_I2C\t36\t \n#define CKEN_INTC\t38\t \n#define CKEN_GPIO\t39\t \n#define CKEN_1WIRE\t40\t \n#define CKEN_HSIO2\t41\t \n#define CKEN_MINI_IM\t48\t \n#define CKEN_MINI_LCD\t49\t \n\n#define CKEN_MMC3\t5\t \n#define CKEN_MVED\t43\t \n\n \n#define CKEN_PXA300_GCU\t\t42\t \n#define CKEN_PXA320_GCU\t\t7\t \n\n\nenum {\n\tPXA_CORE_60Mhz = 0,\n\tPXA_CORE_RUN,\n\tPXA_CORE_TURBO,\n};\n\nenum {\n\tPXA_BUS_60Mhz = 0,\n\tPXA_BUS_HSS,\n};\n\n \nstatic unsigned char hss_mult[4] = { 8, 12, 16, 24 };\n\n \nstatic unsigned int smcfs_mult[8] = { 6, 0, 8, 0, 0, 16, };\nstatic const char * const get_freq_khz[] = {\n\t\"core\", \"ring_osc_60mhz\", \"run\", \"cpll\", \"system_bus\"\n};\n\nstatic void __iomem *clk_regs;\n\n \nunsigned int pxa3xx_get_clk_frequency_khz(int info)\n{\n\tstruct clk *clk;\n\tunsigned long clks[5];\n\tint i;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tclk = clk_get(NULL, get_freq_khz[i]);\n\t\tif (IS_ERR(clk)) {\n\t\t\tclks[i] = 0;\n\t\t} else {\n\t\t\tclks[i] = clk_get_rate(clk);\n\t\t\tclk_put(clk);\n\t\t}\n\t}\n\tif (info) {\n\t\tpr_info(\"RO Mode clock: %ld.%02ldMHz\\n\",\n\t\t\tclks[1] / 1000000, (clks[0] % 1000000) / 10000);\n\t\tpr_info(\"Run Mode clock: %ld.%02ldMHz\\n\",\n\t\t\tclks[2] / 1000000, (clks[1] % 1000000) / 10000);\n\t\tpr_info(\"Turbo Mode clock: %ld.%02ldMHz\\n\",\n\t\t\tclks[3] / 1000000, (clks[2] % 1000000) / 10000);\n\t\tpr_info(\"System bus clock: %ld.%02ldMHz\\n\",\n\t\t\tclks[4] / 1000000, (clks[4] % 1000000) / 10000);\n\t}\n\treturn (unsigned int)clks[0] / KHz;\n}\n\nvoid pxa3xx_clk_update_accr(u32 disable, u32 enable, u32 xclkcfg, u32 mask)\n{\n\tu32 accr = readl(clk_regs + ACCR);\n\n\taccr &= ~disable;\n\taccr |= enable;\n\n\twritel(accr, clk_regs + ACCR);\n\tif (xclkcfg)\n\t\t__asm__(\"mcr p14, 0, %0, c6, c0, 0\\n\" : : \"r\"(xclkcfg));\n\n\twhile ((readl(clk_regs + ACSR) & mask) != (accr & mask))\n\t\tcpu_relax();\n}\n\nstatic unsigned long clk_pxa3xx_ac97_get_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tunsigned long ac97_div, rate;\n\n\tac97_div = readl(clk_regs + AC97_DIV);\n\n\t \n\trate = parent_rate / 2;\n\trate /= ((ac97_div >> 12) & 0x7fff);\n\trate *= (ac97_div & 0xfff);\n\n\treturn rate;\n}\nPARENTS(clk_pxa3xx_ac97) = { \"spll_624mhz\" };\nRATE_RO_OPS(clk_pxa3xx_ac97, \"ac97\");\n\nstatic unsigned long clk_pxa3xx_smemc_get_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\tunsigned long acsr = readl(clk_regs + ACSR);\n\n\treturn (parent_rate / 48)  * smcfs_mult[(acsr >> 23) & 0x7] /\n\t\tpxa3xx_smemc_get_memclkdiv();\n\n}\nPARENTS(clk_pxa3xx_smemc) = { \"spll_624mhz\" };\nRATE_RO_OPS(clk_pxa3xx_smemc, \"smemc\");\n\nstatic bool pxa3xx_is_ring_osc_forced(void)\n{\n\tunsigned long acsr = readl(clk_regs + ACSR);\n\n\treturn acsr & ACCR_D0CS;\n}\n\nPARENTS(pxa3xx_pbus) = { \"ring_osc_60mhz\", \"spll_624mhz\" };\nPARENTS(pxa3xx_32Khz_bus) = { \"osc_32_768khz\", \"osc_32_768khz\" };\nPARENTS(pxa3xx_13MHz_bus) = { \"osc_13mhz\", \"osc_13mhz\" };\nPARENTS(pxa3xx_ac97_bus) = { \"ring_osc_60mhz\", \"ac97\" };\nPARENTS(pxa3xx_sbus) = { \"ring_osc_60mhz\", \"system_bus\" };\nPARENTS(pxa3xx_smemcbus) = { \"ring_osc_60mhz\", \"smemc\" };\n\n#define CKEN_AB(bit) ((CKEN_ ## bit > 31) ? CKENB : CKENA)\n#define PXA3XX_CKEN(dev_id, con_id, parents, mult_lp, div_lp, mult_hp,\t\\\n\t\t    div_hp, bit, is_lp, flags)\t\t\t\t\\\n\tPXA_CKEN(dev_id, con_id, bit, parents, mult_lp, div_lp,\t\t\\\n\t\t mult_hp, div_hp, is_lp,  CKEN_AB(bit),\t\t\t\\\n\t\t (CKEN_ ## bit % 32), flags)\n#define PXA3XX_PBUS_CKEN(dev_id, con_id, bit, mult_lp, div_lp,\t\t\\\n\t\t\t mult_hp, div_hp, delay)\t\t\t\\\n\tPXA3XX_CKEN(dev_id, con_id, pxa3xx_pbus_parents, mult_lp,\t\\\n\t\t    div_lp, mult_hp, div_hp, bit, pxa3xx_is_ring_osc_forced, 0)\n#define PXA3XX_CKEN_1RATE(dev_id, con_id, bit, parents)\t\t\t\\\n\tPXA_CKEN_1RATE(dev_id, con_id, bit, parents,\t\t\t\\\n\t\t       CKEN_AB(bit), (CKEN_ ## bit % 32), 0)\n\nstatic struct desc_clk_cken pxa3xx_clocks[] __initdata = {\n\tPXA3XX_PBUS_CKEN(\"pxa2xx-uart.0\", NULL, FFUART, 1, 4, 1, 42, 1),\n\tPXA3XX_PBUS_CKEN(\"pxa2xx-uart.1\", NULL, BTUART, 1, 4, 1, 42, 1),\n\tPXA3XX_PBUS_CKEN(\"pxa2xx-uart.2\", NULL, STUART, 1, 4, 1, 42, 1),\n\tPXA3XX_PBUS_CKEN(\"pxa2xx-i2c.0\", NULL, I2C, 2, 5, 1, 19, 0),\n\tPXA3XX_PBUS_CKEN(\"pxa27x-udc\", NULL, UDC, 1, 4, 1, 13, 5),\n\tPXA3XX_PBUS_CKEN(\"pxa27x-ohci\", NULL, USBH, 1, 4, 1, 13, 0),\n\tPXA3XX_PBUS_CKEN(\"pxa3xx-u2d\", NULL, USB2, 1, 4, 1, 13, 0),\n\tPXA3XX_PBUS_CKEN(\"pxa27x-pwm.0\", NULL, PWM0, 1, 6, 1, 48, 0),\n\tPXA3XX_PBUS_CKEN(\"pxa27x-pwm.1\", NULL, PWM1, 1, 6, 1, 48, 0),\n\tPXA3XX_PBUS_CKEN(\"pxa2xx-mci.0\", NULL, MMC1, 1, 4, 1, 24, 0),\n\tPXA3XX_PBUS_CKEN(\"pxa2xx-mci.1\", NULL, MMC2, 1, 4, 1, 24, 0),\n\tPXA3XX_PBUS_CKEN(\"pxa2xx-mci.2\", NULL, MMC3, 1, 4, 1, 24, 0),\n\n\tPXA3XX_CKEN_1RATE(\"pxa27x-keypad\", NULL, KEYPAD,\n\t\t\t  pxa3xx_32Khz_bus_parents),\n\tPXA3XX_CKEN_1RATE(\"pxa3xx-ssp.0\", NULL, SSP1, pxa3xx_13MHz_bus_parents),\n\tPXA3XX_CKEN_1RATE(\"pxa3xx-ssp.1\", NULL, SSP2, pxa3xx_13MHz_bus_parents),\n\tPXA3XX_CKEN_1RATE(\"pxa3xx-ssp.2\", NULL, SSP3, pxa3xx_13MHz_bus_parents),\n\tPXA3XX_CKEN_1RATE(\"pxa3xx-ssp.3\", NULL, SSP4, pxa3xx_13MHz_bus_parents),\n\n\tPXA3XX_CKEN(NULL, \"AC97CLK\", pxa3xx_ac97_bus_parents, 1, 4, 1, 1, AC97,\n\t\t    pxa3xx_is_ring_osc_forced, 0),\n\tPXA3XX_CKEN(NULL, \"CAMCLK\", pxa3xx_sbus_parents, 1, 2, 1, 1, CAMERA,\n\t\t    pxa3xx_is_ring_osc_forced, 0),\n\tPXA3XX_CKEN(\"pxa2xx-fb\", NULL, pxa3xx_sbus_parents, 1, 1, 1, 1, LCD,\n\t\t    pxa3xx_is_ring_osc_forced, 0),\n\tPXA3XX_CKEN(\"pxa2xx-pcmcia\", NULL, pxa3xx_smemcbus_parents, 1, 4,\n\t\t    1, 1, SMC, pxa3xx_is_ring_osc_forced, CLK_IGNORE_UNUSED),\n};\n\nstatic struct desc_clk_cken pxa300_310_clocks[] __initdata = {\n\n\tPXA3XX_PBUS_CKEN(\"pxa3xx-gcu\", NULL, PXA300_GCU, 1, 1, 1, 1, 0),\n\tPXA3XX_PBUS_CKEN(\"pxa3xx-nand\", NULL, NAND, 1, 2, 1, 4, 0),\n\tPXA3XX_CKEN_1RATE(\"pxa3xx-gpio\", NULL, GPIO, pxa3xx_13MHz_bus_parents),\n};\n\nstatic struct desc_clk_cken pxa320_clocks[] __initdata = {\n\tPXA3XX_PBUS_CKEN(\"pxa3xx-nand\", NULL, NAND, 1, 2, 1, 6, 0),\n\tPXA3XX_PBUS_CKEN(\"pxa3xx-gcu\", NULL, PXA320_GCU, 1, 1, 1, 1, 0),\n\tPXA3XX_CKEN_1RATE(\"pxa3xx-gpio\", NULL, GPIO, pxa3xx_13MHz_bus_parents),\n};\n\nstatic struct desc_clk_cken pxa93x_clocks[] __initdata = {\n\n\tPXA3XX_PBUS_CKEN(\"pxa3xx-gcu\", NULL, PXA300_GCU, 1, 1, 1, 1, 0),\n\tPXA3XX_PBUS_CKEN(\"pxa3xx-nand\", NULL, NAND, 1, 2, 1, 4, 0),\n\tPXA3XX_CKEN_1RATE(\"pxa93x-gpio\", NULL, GPIO, pxa3xx_13MHz_bus_parents),\n};\n\nstatic unsigned long clk_pxa3xx_system_bus_get_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tunsigned long acsr = readl(clk_regs + ACSR);\n\tunsigned int hss = (acsr >> 14) & 0x3;\n\n\tif (pxa3xx_is_ring_osc_forced())\n\t\treturn parent_rate;\n\treturn parent_rate / 48 * hss_mult[hss];\n}\n\nstatic u8 clk_pxa3xx_system_bus_get_parent(struct clk_hw *hw)\n{\n\tif (pxa3xx_is_ring_osc_forced())\n\t\treturn PXA_BUS_60Mhz;\n\telse\n\t\treturn PXA_BUS_HSS;\n}\n\nPARENTS(clk_pxa3xx_system_bus) = { \"ring_osc_60mhz\", \"spll_624mhz\" };\nMUX_RO_RATE_RO_OPS(clk_pxa3xx_system_bus, \"system_bus\");\n\nstatic unsigned long clk_pxa3xx_core_get_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\treturn parent_rate;\n}\n\nstatic u8 clk_pxa3xx_core_get_parent(struct clk_hw *hw)\n{\n\tunsigned long xclkcfg;\n\tunsigned int t;\n\n\tif (pxa3xx_is_ring_osc_forced())\n\t\treturn PXA_CORE_60Mhz;\n\n\t \n\t__asm__ __volatile__(\"mrc\\tp14, 0, %0, c6, c0, 0\" : \"=r\"(xclkcfg));\n\tt = xclkcfg & 0x1;\n\n\tif (t)\n\t\treturn PXA_CORE_TURBO;\n\treturn PXA_CORE_RUN;\n}\nPARENTS(clk_pxa3xx_core) = { \"ring_osc_60mhz\", \"run\", \"cpll\" };\nMUX_RO_RATE_RO_OPS(clk_pxa3xx_core, \"core\");\n\nstatic unsigned long clk_pxa3xx_run_get_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tunsigned long acsr = readl(clk_regs + ACSR);\n\tunsigned int xn = (acsr & ACCR_XN_MASK) >> 8;\n\tunsigned int t, xclkcfg;\n\n\t \n\t__asm__ __volatile__(\"mrc\\tp14, 0, %0, c6, c0, 0\" : \"=r\"(xclkcfg));\n\tt = xclkcfg & 0x1;\n\n\treturn t ? (parent_rate / xn) * 2 : parent_rate;\n}\nPARENTS(clk_pxa3xx_run) = { \"cpll\" };\nRATE_RO_OPS(clk_pxa3xx_run, \"run\");\n\nstatic unsigned long clk_pxa3xx_cpll_get_rate(struct clk_hw *hw,\n\tunsigned long parent_rate)\n{\n\tunsigned long acsr = readl(clk_regs + ACSR);\n\tunsigned int xn = (acsr & ACCR_XN_MASK) >> 8;\n\tunsigned int xl = acsr & ACCR_XL_MASK;\n\tunsigned int t, xclkcfg;\n\n\t \n\t__asm__ __volatile__(\"mrc\\tp14, 0, %0, c6, c0, 0\" : \"=r\"(xclkcfg));\n\tt = xclkcfg & 0x1;\n\n\tpr_info(\"RJK: parent_rate=%lu, xl=%u, xn=%u\\n\", parent_rate, xl, xn);\n\treturn t ? parent_rate * xl * xn : parent_rate * xl;\n}\nPARENTS(clk_pxa3xx_cpll) = { \"osc_13mhz\" };\nRATE_RO_OPS(clk_pxa3xx_cpll, \"cpll\");\n\nstatic void __init pxa3xx_register_core(void)\n{\n\tclk_register_clk_pxa3xx_cpll();\n\tclk_register_clk_pxa3xx_run();\n\n\tclkdev_pxa_register(CLK_CORE, \"core\", NULL,\n\t\t\t    clk_register_clk_pxa3xx_core());\n}\n\nstatic void __init pxa3xx_register_plls(void)\n{\n\tclk_register_fixed_rate(NULL, \"osc_13mhz\", NULL,\n\t\t\t\tCLK_GET_RATE_NOCACHE,\n\t\t\t\t13 * MHz);\n\tclkdev_pxa_register(CLK_OSC32k768, \"osc_32_768khz\", NULL,\n\t\t\t    clk_register_fixed_rate(NULL, \"osc_32_768khz\", NULL,\n\t\t\t\t\t\t    CLK_GET_RATE_NOCACHE,\n\t\t\t\t\t\t    32768));\n\tclk_register_fixed_rate(NULL, \"ring_osc_120mhz\", NULL,\n\t\t\t\tCLK_GET_RATE_NOCACHE,\n\t\t\t\t120 * MHz);\n\tclk_register_fixed_rate(NULL, \"clk_dummy\", NULL, 0, 0);\n\tclk_register_fixed_factor(NULL, \"spll_624mhz\", \"osc_13mhz\", 0, 48, 1);\n\tclk_register_fixed_factor(NULL, \"ring_osc_60mhz\", \"ring_osc_120mhz\",\n\t\t\t\t  0, 1, 2);\n}\n\n#define DUMMY_CLK(_con_id, _dev_id, _parent) \\\n\t{ .con_id = _con_id, .dev_id = _dev_id, .parent = _parent }\nstruct dummy_clk {\n\tconst char *con_id;\n\tconst char *dev_id;\n\tconst char *parent;\n};\nstatic struct dummy_clk dummy_clks[] __initdata = {\n\tDUMMY_CLK(NULL, \"pxa93x-gpio\", \"osc_13mhz\"),\n\tDUMMY_CLK(NULL, \"sa1100-rtc\", \"osc_32_768khz\"),\n\tDUMMY_CLK(\"UARTCLK\", \"pxa2xx-ir\", \"STUART\"),\n\tDUMMY_CLK(NULL, \"pxa3xx-pwri2c.1\", \"osc_13mhz\"),\n};\n\nstatic void __init pxa3xx_dummy_clocks_init(void)\n{\n\tstruct clk *clk;\n\tstruct dummy_clk *d;\n\tconst char *name;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dummy_clks); i++) {\n\t\td = &dummy_clks[i];\n\t\tname = d->dev_id ? d->dev_id : d->con_id;\n\t\tclk = clk_register_fixed_factor(NULL, name, d->parent, 0, 1, 1);\n\t\tclk_register_clkdev(clk, d->con_id, d->dev_id);\n\t}\n}\n\nstatic void __init pxa3xx_base_clocks_init(void __iomem *oscc_reg)\n{\n\tstruct clk *clk;\n\n\tpxa3xx_register_plls();\n\tpxa3xx_register_core();\n\tclk_register_clk_pxa3xx_system_bus();\n\tclk_register_clk_pxa3xx_ac97();\n\tclk_register_clk_pxa3xx_smemc();\n\tclk = clk_register_gate(NULL, \"CLK_POUT\",\n\t\t\t\t\"osc_13mhz\", 0, oscc_reg, 11, 0, NULL);\n\tclk_register_clkdev(clk, \"CLK_POUT\", NULL);\n\tclkdev_pxa_register(CLK_OSTIMER, \"OSTIMER0\", NULL,\n\t\t\t    clk_register_fixed_factor(NULL, \"os-timer0\",\n\t\t\t\t\t\t      \"osc_13mhz\", 0, 1, 4));\n}\n\nint __init pxa3xx_clocks_init(void __iomem *regs, void __iomem *oscc_reg)\n{\n\tint ret;\n\n\tclk_regs = regs;\n\tpxa3xx_base_clocks_init(oscc_reg);\n\tpxa3xx_dummy_clocks_init();\n\tret = clk_pxa_cken_init(pxa3xx_clocks, ARRAY_SIZE(pxa3xx_clocks), regs);\n\tif (ret)\n\t\treturn ret;\n\tif (cpu_is_pxa320())\n\t\treturn clk_pxa_cken_init(pxa320_clocks,\n\t\t\t\t\t ARRAY_SIZE(pxa320_clocks), regs);\n\tif (cpu_is_pxa300() || cpu_is_pxa310())\n\t\treturn clk_pxa_cken_init(pxa300_310_clocks,\n\t\t\t\t\t ARRAY_SIZE(pxa300_310_clocks), regs);\n\treturn clk_pxa_cken_init(pxa93x_clocks, ARRAY_SIZE(pxa93x_clocks), regs);\n}\n\nstatic void __init pxa3xx_dt_clocks_init(struct device_node *np)\n{\n\tpxa3xx_clocks_init(ioremap(0x41340000, 0x10), ioremap(0x41350000, 4));\n\tclk_pxa_dt_common_init(np);\n}\nCLK_OF_DECLARE(pxa_clks, \"marvell,pxa300-clocks\", pxa3xx_dt_clocks_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}