{
  "module_name": "clk-pxa25x.c",
  "hash_id": "a32edffbe1e1301e8aeba763e486241b8f93e053df44fd8a6c549e265465e20f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/pxa/clk-pxa25x.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/clk/pxa.h>\n#include <linux/clkdev.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/soc/pxa/smemc.h>\n#include <linux/soc/pxa/cpu.h>\n\n#include <dt-bindings/clock/pxa-clock.h>\n#include \"clk-pxa.h\"\n#include \"clk-pxa2xx.h\"\n\n#define KHz 1000\n#define MHz (1000 * 1000)\n\nenum {\n\tPXA_CORE_RUN = 0,\n\tPXA_CORE_TURBO,\n};\n\n#define PXA25x_CLKCFG(T)\t\t\t\\\n\t(CLKCFG_FCS |\t\t\t\t\\\n\t ((T) ? CLKCFG_TURBO : 0))\n#define PXA25x_CCCR(N2, M, L) (N2 << 7 | M << 5 | L)\n\n \n#define SDRAM_TREF\t64\t \n\n \nstatic void __iomem *clk_regs;\n\n \nstatic unsigned char L_clk_mult[32] = { 0, 27, 32, 36, 40, 45, 0, };\n\n \nstatic unsigned char M_clk_mult[4] = { 0, 1, 2, 4 };\n\n \n \nstatic unsigned char N2_clk_mult[8] = { 0, 0, 2, 3, 4, 0, 6, 0 };\n\nstatic const char * const get_freq_khz[] = {\n\t\"core\", \"run\", \"cpll\", \"memory\"\n};\n\nstatic u32 mdrefr_dri(unsigned int freq_khz)\n{\n\tu32 interval = freq_khz * SDRAM_TREF / pxa2xx_smemc_get_sdram_rows();\n\n\treturn interval / 32;\n}\n\n \nunsigned int pxa25x_get_clk_frequency_khz(int info)\n{\n\tstruct clk *clk;\n\tunsigned long clks[5];\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(get_freq_khz); i++) {\n\t\tclk = clk_get(NULL, get_freq_khz[i]);\n\t\tif (IS_ERR(clk)) {\n\t\t\tclks[i] = 0;\n\t\t} else {\n\t\t\tclks[i] = clk_get_rate(clk);\n\t\t\tclk_put(clk);\n\t\t}\n\t}\n\n\tif (info) {\n\t\tpr_info(\"Run Mode clock: %ld.%02ldMHz\\n\",\n\t\t\tclks[1] / 1000000, (clks[1] % 1000000) / 10000);\n\t\tpr_info(\"Turbo Mode clock: %ld.%02ldMHz\\n\",\n\t\t\tclks[2] / 1000000, (clks[2] % 1000000) / 10000);\n\t\tpr_info(\"Memory clock: %ld.%02ldMHz\\n\",\n\t\t\tclks[3] / 1000000, (clks[3] % 1000000) / 10000);\n\t}\n\n\treturn (unsigned int)clks[0] / KHz;\n}\n\nstatic unsigned long clk_pxa25x_memory_get_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tunsigned long cccr = readl(clk_regs + CCCR);\n\tunsigned int m = M_clk_mult[(cccr >> 5) & 0x03];\n\n\treturn parent_rate / m;\n}\nPARENTS(clk_pxa25x_memory) = { \"run\" };\nRATE_RO_OPS(clk_pxa25x_memory, \"memory\");\n\nPARENTS(pxa25x_pbus95) = { \"ppll_95_85mhz\", \"ppll_95_85mhz\" };\nPARENTS(pxa25x_pbus147) = { \"ppll_147_46mhz\", \"ppll_147_46mhz\" };\nPARENTS(pxa25x_osc3) = { \"osc_3_6864mhz\", \"osc_3_6864mhz\" };\n\n#define PXA25X_CKEN(dev_id, con_id, parents, mult, div,\t\t\t\\\n\t\t    bit, is_lp, flags)\t\t\t\t\t\\\n\tPXA_CKEN(dev_id, con_id, bit, parents, mult, div, mult, div,\t\\\n\t\t is_lp,  CKEN, CKEN_ ## bit, flags)\n#define PXA25X_PBUS95_CKEN(dev_id, con_id, bit, mult_hp, div_hp, delay)\t\\\n\tPXA25X_CKEN(dev_id, con_id, pxa25x_pbus95_parents, mult_hp,\t\\\n\t\t    div_hp, bit, NULL, 0)\n#define PXA25X_PBUS147_CKEN(dev_id, con_id, bit, mult_hp, div_hp, delay)\\\n\tPXA25X_CKEN(dev_id, con_id, pxa25x_pbus147_parents, mult_hp,\t\\\n\t\t    div_hp, bit, NULL, 0)\n#define PXA25X_OSC3_CKEN(dev_id, con_id, bit, mult_hp, div_hp, delay)\t\\\n\tPXA25X_CKEN(dev_id, con_id, pxa25x_osc3_parents, mult_hp,\t\\\n\t\t    div_hp, bit, NULL, 0)\n\n#define PXA25X_CKEN_1RATE(dev_id, con_id, bit, parents, delay)\t\t\\\n\tPXA_CKEN_1RATE(dev_id, con_id, bit, parents,\t\t\t\\\n\t\t       CKEN, CKEN_ ## bit, 0)\n#define PXA25X_CKEN_1RATE_AO(dev_id, con_id, bit, parents, delay)\t\\\n\tPXA_CKEN_1RATE(dev_id, con_id, bit, parents,\t\t\t\\\n\t\t       CKEN, CKEN_ ## bit, CLK_IGNORE_UNUSED)\n\nstatic struct desc_clk_cken pxa25x_clocks[] __initdata = {\n\tPXA25X_PBUS95_CKEN(\"pxa2xx-mci.0\", NULL, MMC, 1, 5, 0),\n\tPXA25X_PBUS95_CKEN(\"pxa2xx-i2c.0\", NULL, I2C, 1, 3, 0),\n\tPXA25X_PBUS95_CKEN(\"pxa2xx-ir\", \"FICPCLK\", FICP, 1, 2, 0),\n\tPXA25X_PBUS95_CKEN(\"pxa25x-udc\", NULL, USB, 1, 2, 5),\n\tPXA25X_PBUS147_CKEN(\"pxa2xx-uart.0\", NULL, FFUART, 1, 10, 1),\n\tPXA25X_PBUS147_CKEN(\"pxa2xx-uart.1\", NULL, BTUART, 1, 10, 1),\n\tPXA25X_PBUS147_CKEN(\"pxa2xx-uart.2\", NULL, STUART, 1, 10, 1),\n\tPXA25X_PBUS147_CKEN(\"pxa2xx-uart.3\", NULL, HWUART, 1, 10, 1),\n\tPXA25X_PBUS147_CKEN(\"pxa2xx-i2s\", NULL, I2S, 1, 10, 0),\n\tPXA25X_PBUS147_CKEN(NULL, \"AC97CLK\", AC97, 1, 12, 0),\n\tPXA25X_OSC3_CKEN(\"pxa25x-ssp.0\", NULL, SSP, 1, 1, 0),\n\tPXA25X_OSC3_CKEN(\"pxa25x-nssp.1\", NULL, NSSP, 1, 1, 0),\n\tPXA25X_OSC3_CKEN(\"pxa25x-nssp.2\", NULL, ASSP, 1, 1, 0),\n\tPXA25X_OSC3_CKEN(\"pxa25x-pwm.0\", NULL, PWM0, 1, 1, 0),\n\tPXA25X_OSC3_CKEN(\"pxa25x-pwm.1\", NULL, PWM1, 1, 1, 0),\n\n\tPXA25X_CKEN_1RATE(\"pxa2xx-fb\", NULL, LCD, clk_pxa25x_memory_parents, 0),\n\tPXA25X_CKEN_1RATE_AO(\"pxa2xx-pcmcia\", NULL, MEMC,\n\t\t\t     clk_pxa25x_memory_parents, 0),\n};\n\n \nstatic struct pxa2xx_freq pxa25x_freqs[] = {\n\t \n\t{ 99532800, 99500, PXA25x_CCCR(2,  1, 1),  1, PXA25x_CLKCFG(1)},\n\t{199065600, 99500, PXA25x_CCCR(4,  1, 1),  0, PXA25x_CLKCFG(1)},\n\t{298598400, 99500, PXA25x_CCCR(3,  2, 1),  0, PXA25x_CLKCFG(1)},\n\t{398131200, 99500, PXA25x_CCCR(4,  2, 1),  0, PXA25x_CLKCFG(1)},\n};\n\nstatic u8 clk_pxa25x_core_get_parent(struct clk_hw *hw)\n{\n\tunsigned long clkcfg;\n\tunsigned int t;\n\n\tasm(\"mrc\\tp14, 0, %0, c6, c0, 0\" : \"=r\" (clkcfg));\n\tt  = clkcfg & (1 << 0);\n\tif (t)\n\t\treturn PXA_CORE_TURBO;\n\treturn PXA_CORE_RUN;\n}\n\nstatic int clk_pxa25x_core_set_parent(struct clk_hw *hw, u8 index)\n{\n\tif (index > PXA_CORE_TURBO)\n\t\treturn -EINVAL;\n\n\tpxa2xx_core_turbo_switch(index == PXA_CORE_TURBO);\n\n\treturn 0;\n}\n\nstatic int clk_pxa25x_core_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t  struct clk_rate_request *req)\n{\n\treturn __clk_mux_determine_rate(hw, req);\n}\n\nPARENTS(clk_pxa25x_core) = { \"run\", \"cpll\" };\nMUX_OPS(clk_pxa25x_core, \"core\", CLK_SET_RATE_PARENT);\n\nstatic unsigned long clk_pxa25x_run_get_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tunsigned long cccr = readl(clk_regs + CCCR);\n\tunsigned int n2 = N2_clk_mult[(cccr >> 7) & 0x07];\n\n\treturn (parent_rate / n2) * 2;\n}\nPARENTS(clk_pxa25x_run) = { \"cpll\" };\nRATE_RO_OPS(clk_pxa25x_run, \"run\");\n\nstatic unsigned long clk_pxa25x_cpll_get_rate(struct clk_hw *hw,\n\tunsigned long parent_rate)\n{\n\tunsigned long clkcfg, cccr = readl(clk_regs + CCCR);\n\tunsigned int l, m, n2, t;\n\n\tasm(\"mrc\\tp14, 0, %0, c6, c0, 0\" : \"=r\" (clkcfg));\n\tt = clkcfg & (1 << 0);\n\tl  =  L_clk_mult[(cccr >> 0) & 0x1f];\n\tm = M_clk_mult[(cccr >> 5) & 0x03];\n\tn2 = N2_clk_mult[(cccr >> 7) & 0x07];\n\n\treturn m * l * n2 * parent_rate / 2;\n}\n\nstatic int clk_pxa25x_cpll_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t  struct clk_rate_request *req)\n{\n\treturn pxa2xx_determine_rate(req, pxa25x_freqs,\n\t\t\t\t     ARRAY_SIZE(pxa25x_freqs));\n}\n\nstatic int clk_pxa25x_cpll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tint i;\n\n\tpr_debug(\"%s(rate=%lu parent_rate=%lu)\\n\", __func__, rate, parent_rate);\n\tfor (i = 0; i < ARRAY_SIZE(pxa25x_freqs); i++)\n\t\tif (pxa25x_freqs[i].cpll == rate)\n\t\t\tbreak;\n\n\tif (i >= ARRAY_SIZE(pxa25x_freqs))\n\t\treturn -EINVAL;\n\n\tpxa2xx_cpll_change(&pxa25x_freqs[i], mdrefr_dri, clk_regs + CCCR);\n\n\treturn 0;\n}\nPARENTS(clk_pxa25x_cpll) = { \"osc_3_6864mhz\" };\nRATE_OPS(clk_pxa25x_cpll, \"cpll\");\n\nstatic void __init pxa25x_register_core(void)\n{\n\tclkdev_pxa_register(CLK_NONE, \"cpll\", NULL,\n\t\t\t    clk_register_clk_pxa25x_cpll());\n\tclkdev_pxa_register(CLK_NONE, \"run\", NULL,\n\t\t\t    clk_register_clk_pxa25x_run());\n\tclkdev_pxa_register(CLK_CORE, \"core\", NULL,\n\t\t\t    clk_register_clk_pxa25x_core());\n}\n\nstatic void __init pxa25x_register_plls(void)\n{\n\tclk_register_fixed_rate(NULL, \"osc_3_6864mhz\", NULL,\n\t\t\t\tCLK_GET_RATE_NOCACHE, 3686400);\n\tclkdev_pxa_register(CLK_OSC32k768, \"osc_32_768khz\", NULL,\n\t\t\t    clk_register_fixed_rate(NULL, \"osc_32_768khz\", NULL,\n\t\t\t\t\t\t    CLK_GET_RATE_NOCACHE,\n\t\t\t\t\t\t    32768));\n\tclk_register_fixed_rate(NULL, \"clk_dummy\", NULL, 0, 0);\n\tclk_register_fixed_factor(NULL, \"ppll_95_85mhz\", \"osc_3_6864mhz\",\n\t\t\t\t  0, 26, 1);\n\tclk_register_fixed_factor(NULL, \"ppll_147_46mhz\", \"osc_3_6864mhz\",\n\t\t\t\t  0, 40, 1);\n}\n\nstatic void __init pxa25x_base_clocks_init(void)\n{\n\tpxa25x_register_plls();\n\tpxa25x_register_core();\n\tclkdev_pxa_register(CLK_NONE, \"system_bus\", NULL,\n\t\t\t    clk_register_clk_pxa25x_memory());\n}\n\n#define DUMMY_CLK(_con_id, _dev_id, _parent) \\\n\t{ .con_id = _con_id, .dev_id = _dev_id, .parent = _parent }\nstruct dummy_clk {\n\tconst char *con_id;\n\tconst char *dev_id;\n\tconst char *parent;\n};\nstatic struct dummy_clk dummy_clks[] __initdata = {\n\tDUMMY_CLK(NULL, \"pxa25x-gpio\", \"osc_32_768khz\"),\n\tDUMMY_CLK(NULL, \"pxa26x-gpio\", \"osc_32_768khz\"),\n\tDUMMY_CLK(\"GPIO11_CLK\", NULL, \"osc_3_6864mhz\"),\n\tDUMMY_CLK(\"GPIO12_CLK\", NULL, \"osc_32_768khz\"),\n\tDUMMY_CLK(NULL, \"sa1100-rtc\", \"osc_32_768khz\"),\n\tDUMMY_CLK(\"OSTIMER0\", NULL, \"osc_3_6864mhz\"),\n\tDUMMY_CLK(\"UARTCLK\", \"pxa2xx-ir\", \"STUART\"),\n};\n\nstatic void __init pxa25x_dummy_clocks_init(void)\n{\n\tstruct clk *clk;\n\tstruct dummy_clk *d;\n\tconst char *name;\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dummy_clks); i++) {\n\t\td = &dummy_clks[i];\n\t\tname = d->dev_id ? d->dev_id : d->con_id;\n\t\tclk = clk_register_fixed_factor(NULL, name, d->parent, 0, 1, 1);\n\t\tclk_register_clkdev(clk, d->con_id, d->dev_id);\n\t}\n}\n\nint __init pxa25x_clocks_init(void __iomem *regs)\n{\n\tclk_regs = regs;\n\tpxa25x_base_clocks_init();\n\tpxa25x_dummy_clocks_init();\n\treturn clk_pxa_cken_init(pxa25x_clocks, ARRAY_SIZE(pxa25x_clocks), clk_regs);\n}\n\nstatic void __init pxa25x_dt_clocks_init(struct device_node *np)\n{\n\tpxa25x_clocks_init(ioremap(0x41300000ul, 0x10));\n\tclk_pxa_dt_common_init(np);\n}\nCLK_OF_DECLARE(pxa25x_clks, \"marvell,pxa250-core-clocks\",\n\t       pxa25x_dt_clocks_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}