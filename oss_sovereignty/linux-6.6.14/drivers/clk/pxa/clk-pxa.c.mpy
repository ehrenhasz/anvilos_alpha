{
  "module_name": "clk-pxa.c",
  "hash_id": "ce465607692cfa5f68e126504b6da688b287e25f80a65fd8fdbbc597fddb8773",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/pxa/clk-pxa.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/soc/pxa/smemc.h>\n\n#include <dt-bindings/clock/pxa-clock.h>\n#include \"clk-pxa.h\"\n\n#define KHz 1000\n#define MHz (1000 * 1000)\n\n#define MDREFR_K0DB4\t(1 << 29)\t \n#define MDREFR_K2FREE\t(1 << 25)\t \n#define MDREFR_K1FREE\t(1 << 24)\t \n#define MDREFR_K0FREE\t(1 << 23)\t \n#define MDREFR_SLFRSH\t(1 << 22)\t \n#define MDREFR_APD\t(1 << 20)\t \n#define MDREFR_K2DB2\t(1 << 19)\t \n#define MDREFR_K2RUN\t(1 << 18)\t \n#define MDREFR_K1DB2\t(1 << 17)\t \n#define MDREFR_K1RUN\t(1 << 16)\t \n#define MDREFR_E1PIN\t(1 << 15)\t \n#define MDREFR_K0DB2\t(1 << 14)\t \n#define MDREFR_K0RUN\t(1 << 13)\t \n#define MDREFR_E0PIN\t(1 << 12)\t \n#define MDREFR_DB2_MASK\t(MDREFR_K2DB2 | MDREFR_K1DB2)\n#define MDREFR_DRI_MASK\t0xFFF\n\nstatic DEFINE_SPINLOCK(pxa_clk_lock);\n\nstatic struct clk *pxa_clocks[CLK_MAX];\nstatic struct clk_onecell_data onecell_data = {\n\t.clks = pxa_clocks,\n\t.clk_num = CLK_MAX,\n};\n\nstruct pxa_clk {\n\tstruct clk_hw hw;\n\tstruct clk_fixed_factor lp;\n\tstruct clk_fixed_factor hp;\n\tstruct clk_gate gate;\n\tbool (*is_in_low_power)(void);\n};\n\n#define to_pxa_clk(_hw) container_of(_hw, struct pxa_clk, hw)\n\nstatic unsigned long cken_recalc_rate(struct clk_hw *hw,\n\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct pxa_clk *pclk = to_pxa_clk(hw);\n\tstruct clk_fixed_factor *fix;\n\n\tif (!pclk->is_in_low_power || pclk->is_in_low_power())\n\t\tfix = &pclk->lp;\n\telse\n\t\tfix = &pclk->hp;\n\t__clk_hw_set_clk(&fix->hw, hw);\n\treturn clk_fixed_factor_ops.recalc_rate(&fix->hw, parent_rate);\n}\n\nstatic const struct clk_ops cken_rate_ops = {\n\t.recalc_rate = cken_recalc_rate,\n};\n\nstatic u8 cken_get_parent(struct clk_hw *hw)\n{\n\tstruct pxa_clk *pclk = to_pxa_clk(hw);\n\n\tif (!pclk->is_in_low_power)\n\t\treturn 0;\n\treturn pclk->is_in_low_power() ? 0 : 1;\n}\n\nstatic const struct clk_ops cken_mux_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.get_parent = cken_get_parent,\n\t.set_parent = dummy_clk_set_parent,\n};\n\nvoid __init clkdev_pxa_register(int ckid, const char *con_id,\n\t\t\t\tconst char *dev_id, struct clk *clk)\n{\n\tif (!IS_ERR(clk) && (ckid != CLK_NONE))\n\t\tpxa_clocks[ckid] = clk;\n\tif (!IS_ERR(clk))\n\t\tclk_register_clkdev(clk, con_id, dev_id);\n}\n\nint __init clk_pxa_cken_init(const struct desc_clk_cken *clks,\n\t\t\t     int nb_clks, void __iomem *clk_regs)\n{\n\tint i;\n\tstruct pxa_clk *pxa_clk;\n\tstruct clk *clk;\n\n\tfor (i = 0; i < nb_clks; i++) {\n\t\tpxa_clk = kzalloc(sizeof(*pxa_clk), GFP_KERNEL);\n\t\tif (!pxa_clk)\n\t\t\treturn -ENOMEM;\n\t\tpxa_clk->is_in_low_power = clks[i].is_in_low_power;\n\t\tpxa_clk->lp = clks[i].lp;\n\t\tpxa_clk->hp = clks[i].hp;\n\t\tpxa_clk->gate = clks[i].gate;\n\t\tpxa_clk->gate.reg = clk_regs + clks[i].cken_reg;\n\t\tpxa_clk->gate.lock = &pxa_clk_lock;\n\t\tclk = clk_register_composite(NULL, clks[i].name,\n\t\t\t\t\t     clks[i].parent_names, 2,\n\t\t\t\t\t     &pxa_clk->hw, &cken_mux_ops,\n\t\t\t\t\t     &pxa_clk->hw, &cken_rate_ops,\n\t\t\t\t\t     &pxa_clk->gate.hw, &clk_gate_ops,\n\t\t\t\t\t     clks[i].flags);\n\t\tclkdev_pxa_register(clks[i].ckid, clks[i].con_id,\n\t\t\t\t    clks[i].dev_id, clk);\n\t}\n\treturn 0;\n}\n\nvoid __init clk_pxa_dt_common_init(struct device_node *np)\n{\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &onecell_data);\n}\n\nvoid pxa2xx_core_turbo_switch(bool on)\n{\n\tunsigned long flags;\n\tunsigned int unused, clkcfg;\n\n\tlocal_irq_save(flags);\n\n\tasm(\"mrc p14, 0, %0, c6, c0, 0\" : \"=r\" (clkcfg));\n\tclkcfg &= ~CLKCFG_TURBO & ~CLKCFG_HALFTURBO;\n\tif (on)\n\t\tclkcfg |= CLKCFG_TURBO;\n\tclkcfg |= CLKCFG_FCS;\n\n\tasm volatile(\n\t\"\tb\t2f\\n\"\n\t\"\t.align\t5\\n\"\n\t\"1:\tmcr\tp14, 0, %1, c6, c0, 0\\n\"\n\t\"\tb\t3f\\n\"\n\t\"2:\tb\t1b\\n\"\n\t\"3:\tnop\\n\"\n\t\t: \"=&r\" (unused) : \"r\" (clkcfg));\n\n\tlocal_irq_restore(flags);\n}\n\nvoid pxa2xx_cpll_change(struct pxa2xx_freq *freq,\n\t\t\tu32 (*mdrefr_dri)(unsigned int),\n\t\t\tvoid __iomem *cccr)\n{\n\tunsigned int clkcfg = freq->clkcfg;\n\tunsigned int unused, preset_mdrefr, postset_mdrefr;\n\tunsigned long flags;\n\tvoid __iomem *mdrefr = pxa_smemc_get_mdrefr();\n\n\tlocal_irq_save(flags);\n\n\t \n\tpreset_mdrefr = postset_mdrefr = readl(mdrefr);\n\tif ((preset_mdrefr & MDREFR_DRI_MASK) > mdrefr_dri(freq->membus_khz)) {\n\t\tpreset_mdrefr = (preset_mdrefr & ~MDREFR_DRI_MASK);\n\t\tpreset_mdrefr |= mdrefr_dri(freq->membus_khz);\n\t}\n\tpostset_mdrefr =\n\t\t(postset_mdrefr & ~MDREFR_DRI_MASK) |\n\t\tmdrefr_dri(freq->membus_khz);\n\n\t \n\tif (freq->div2) {\n\t\tpreset_mdrefr  |= MDREFR_DB2_MASK;\n\t\tpostset_mdrefr |= MDREFR_DB2_MASK;\n\t} else {\n\t\tpostset_mdrefr &= ~MDREFR_DB2_MASK;\n\t}\n\n\t \n\twritel(freq->cccr, cccr);\n\n\tasm volatile(\n\t\"\tldr\tr4, [%1]\\n\"\n\t\"\tb\t2f\\n\"\n\t\"\t.align\t5\\n\"\n\t\"1:\tstr\t%3, [%1]\t\t/* preset the MDREFR */\\n\"\n\t\"\tmcr\tp14, 0, %2, c6, c0, 0\t/* set CLKCFG[FCS] */\\n\"\n\t\"\tstr\t%4, [%1]\t\t/* postset the MDREFR */\\n\"\n\t\"\tb\t3f\\n\"\n\t\"2:\tb\t1b\\n\"\n\t\"3:\tnop\\n\"\n\t     : \"=&r\" (unused)\n\t     : \"r\" (mdrefr), \"r\" (clkcfg), \"r\" (preset_mdrefr),\n\t       \"r\" (postset_mdrefr)\n\t     : \"r4\", \"r5\");\n\n\tlocal_irq_restore(flags);\n}\n\nint pxa2xx_determine_rate(struct clk_rate_request *req,\n\t\t\t  struct pxa2xx_freq *freqs, int nb_freqs)\n{\n\tint i, closest_below = -1, closest_above = -1;\n\tunsigned long rate;\n\n\tfor (i = 0; i < nb_freqs; i++) {\n\t\trate = freqs[i].cpll;\n\t\tif (rate == req->rate)\n\t\t\tbreak;\n\t\tif (rate < req->min_rate)\n\t\t\tcontinue;\n\t\tif (rate > req->max_rate)\n\t\t\tcontinue;\n\t\tif (rate <= req->rate)\n\t\t\tclosest_below = i;\n\t\tif ((rate >= req->rate) && (closest_above == -1))\n\t\t\tclosest_above = i;\n\t}\n\n\treq->best_parent_hw = NULL;\n\n\tif (i < nb_freqs) {\n\t\trate = req->rate;\n\t} else if (closest_below >= 0) {\n\t\trate = freqs[closest_below].cpll;\n\t} else if (closest_above >= 0) {\n\t\trate = freqs[closest_above].cpll;\n\t} else {\n\t\tpr_debug(\"%s(rate=%lu) no match\\n\", __func__, req->rate);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"%s(rate=%lu) rate=%lu\\n\", __func__, req->rate, rate);\n\treq->rate = rate;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}