{
  "module_name": "clk-si5341.c",
  "hash_id": "1d9ccc98c7c208a134c9819bd4d5a25de9cc3912fd9c6e7fbe794ccfc384c9c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-si5341.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/gcd.h>\n#include <linux/math64.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#define SI5341_NUM_INPUTS 4\n\n#define SI5340_MAX_NUM_OUTPUTS 4\n#define SI5341_MAX_NUM_OUTPUTS 10\n#define SI5342_MAX_NUM_OUTPUTS 2\n#define SI5344_MAX_NUM_OUTPUTS 4\n#define SI5345_MAX_NUM_OUTPUTS 10\n\n#define SI5340_NUM_SYNTH 4\n#define SI5341_NUM_SYNTH 5\n#define SI5342_NUM_SYNTH 2\n#define SI5344_NUM_SYNTH 4\n#define SI5345_NUM_SYNTH 5\n\n \n#define SI5341_SYNTH_N_MIN\t10\n#define SI5341_SYNTH_N_MAX\t4095\n\n \n\n \n#define SI5341_PLL_VCO_MIN 13500000000ull\n#define SI5341_PLL_VCO_MAX 14256000000ull\n\n \nstruct clk_si5341_synth {\n\tstruct clk_hw hw;\n\tstruct clk_si5341 *data;\n\tu8 index;\n};\n#define to_clk_si5341_synth(_hw) \\\n\tcontainer_of(_hw, struct clk_si5341_synth, hw)\n\n \nstruct clk_si5341_output {\n\tstruct clk_hw hw;\n\tstruct clk_si5341 *data;\n\tstruct regulator *vddo_reg;\n\tu8 index;\n};\n#define to_clk_si5341_output(_hw) \\\n\tcontainer_of(_hw, struct clk_si5341_output, hw)\n\nstruct clk_si5341 {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tstruct i2c_client *i2c_client;\n\tstruct clk_si5341_synth synth[SI5341_NUM_SYNTH];\n\tstruct clk_si5341_output clk[SI5341_MAX_NUM_OUTPUTS];\n\tstruct clk *input_clk[SI5341_NUM_INPUTS];\n\tconst char *input_clk_name[SI5341_NUM_INPUTS];\n\tconst u16 *reg_output_offset;\n\tconst u16 *reg_rdiv_offset;\n\tu64 freq_vco;  \n\tu8 num_outputs;\n\tu8 num_synth;\n\tu16 chip_id;\n\tbool xaxb_ext_clk;\n\tbool iovdd_33;\n};\n#define to_clk_si5341(_hw)\tcontainer_of(_hw, struct clk_si5341, hw)\n\nstruct clk_si5341_output_config {\n\tu8 out_format_drv_bits;\n\tu8 out_cm_ampl_bits;\n\tu8 vdd_sel_bits;\n\tbool synth_master;\n\tbool always_on;\n};\n\n#define SI5341_PAGE\t\t0x0001\n#define SI5341_PN_BASE\t\t0x0002\n#define SI5341_DEVICE_REV\t0x0005\n#define SI5341_STATUS\t\t0x000C\n#define SI5341_LOS\t\t0x000D\n#define SI5341_STATUS_STICKY\t0x0011\n#define SI5341_LOS_STICKY\t0x0012\n#define SI5341_SOFT_RST\t\t0x001C\n#define SI5341_IN_SEL\t\t0x0021\n#define SI5341_DEVICE_READY\t0x00FE\n#define SI5341_XAXB_CFG\t\t0x090E\n#define SI5341_IO_VDD_SEL\t0x0943\n#define SI5341_IN_EN\t\t0x0949\n#define SI5341_INX_TO_PFD_EN\t0x094A\n\n \n#define SI5341_STATUS_SYSINCAL\tBIT(0)\n#define SI5341_STATUS_LOSXAXB\tBIT(1)\n#define SI5341_STATUS_LOSREF\tBIT(2)\n#define SI5341_STATUS_LOL\tBIT(3)\n\n \n#define SI5341_IN_SEL_MASK\t0x06\n#define SI5341_IN_SEL_SHIFT\t1\n#define SI5341_IN_SEL_REGCTRL\t0x01\n#define SI5341_INX_TO_PFD_SHIFT\t4\n\n \n#define SI5341_XAXB_CFG_EXTCLK_EN\tBIT(0)\n#define SI5341_XAXB_CFG_PDNB\t\tBIT(1)\n\n \n#define SI5341_IN_PDIV(x)\t(0x0208 + ((x) * 10))\n#define SI5341_IN_PSET(x)\t(0x020E + ((x) * 10))\n#define SI5341_PX_UPD\t\t0x0230\n\n \n#define SI5341_PLL_M_NUM\t0x0235\n#define SI5341_PLL_M_DEN\t0x023B\n\n \n#define SI5341_OUT_CONFIG(output)\t\\\n\t\t\t((output)->data->reg_output_offset[(output)->index])\n#define SI5341_OUT_FORMAT(output)\t(SI5341_OUT_CONFIG(output) + 1)\n#define SI5341_OUT_CM(output)\t\t(SI5341_OUT_CONFIG(output) + 2)\n#define SI5341_OUT_MUX_SEL(output)\t(SI5341_OUT_CONFIG(output) + 3)\n#define SI5341_OUT_R_REG(output)\t\\\n\t\t\t((output)->data->reg_rdiv_offset[(output)->index])\n\n#define SI5341_OUT_MUX_VDD_SEL_MASK 0x38\n\n \n#define SI5341_SYNTH_N_NUM(x)\t(0x0302 + ((x) * 11))\n#define SI5341_SYNTH_N_DEN(x)\t(0x0308 + ((x) * 11))\n#define SI5341_SYNTH_N_UPD(x)\t(0x030C + ((x) * 11))\n\n \n#define SI5341_SYNTH_N_CLK_TO_OUTX_EN\t0x0A03\n#define SI5341_SYNTH_N_PIBYP\t\t0x0A04\n#define SI5341_SYNTH_N_PDNB\t\t0x0A05\n#define SI5341_SYNTH_N_CLK_DIS\t\t0x0B4A\n\n#define SI5341_REGISTER_MAX\t0xBFF\n\n \n#define SI5341_OUT_CFG_PDN\t\tBIT(0)\n#define SI5341_OUT_CFG_OE\t\tBIT(1)\n#define SI5341_OUT_CFG_RDIV_FORCE2\tBIT(2)\n\n \nstruct si5341_reg_default {\n\tu16 address;\n\tu8 value;\n};\n\nstatic const char * const si5341_input_clock_names[] = {\n\t\"in0\", \"in1\", \"in2\", \"xtal\"\n};\n\n \n \nstatic const u16 si5341_reg_output_offset[] = {\n\t0x0108,\n\t0x010D,\n\t0x0112,\n\t0x0117,\n\t0x011C,\n\t0x0121,\n\t0x0126,\n\t0x012B,\n\t0x0130,\n\t0x013A,\n};\n\n \nstatic const u16 si5340_reg_output_offset[] = {\n\t0x0112,\n\t0x0117,\n\t0x0126,\n\t0x012B,\n};\n\n \nstatic const u16 si5341_reg_rdiv_offset[] = {\n\t0x024A,\n\t0x024D,\n\t0x0250,\n\t0x0253,\n\t0x0256,\n\t0x0259,\n\t0x025C,\n\t0x025F,\n\t0x0262,\n\t0x0268,\n};\nstatic const u16 si5340_reg_rdiv_offset[] = {\n\t0x0250,\n\t0x0253,\n\t0x025C,\n\t0x025F,\n};\n\n \nstatic const struct si5341_reg_default si5341_reg_defaults[] = {\n\t{ 0x0017, 0x3A },  \n\t{ 0x0018, 0xFF },  \n\t{ 0x0021, 0x0F },  \n\t{ 0x0022, 0x00 },  \n\t{ 0x002B, 0x02 },  \n\t{ 0x002C, 0x20 },  \n\t{ 0x002D, 0x00 },  \n\t{ 0x002E, 0x00 },\n\t{ 0x002F, 0x00 },\n\t{ 0x0030, 0x00 },\n\t{ 0x0031, 0x00 },\n\t{ 0x0032, 0x00 },\n\t{ 0x0033, 0x00 },\n\t{ 0x0034, 0x00 },\n\t{ 0x0035, 0x00 },\n\t{ 0x0036, 0x00 },\n\t{ 0x0037, 0x00 },\n\t{ 0x0038, 0x00 },  \n\t{ 0x0039, 0x00 },\n\t{ 0x003A, 0x00 },\n\t{ 0x003B, 0x00 },\n\t{ 0x003C, 0x00 },\n\t{ 0x003D, 0x00 },  \n\t{ 0x0041, 0x00 },  \n\t{ 0x0042, 0x00 },  \n\t{ 0x0043, 0x00 },  \n\t{ 0x0044, 0x00 },  \n\t{ 0x009E, 0x00 },  \n\t{ 0x0102, 0x01 },  \n\t{ 0x013F, 0x00 },  \n\t{ 0x0140, 0x00 },  \n\t{ 0x0141, 0x40 },  \n\t{ 0x0202, 0x00 },  \n\t{ 0x0203, 0x00 },\n\t{ 0x0204, 0x00 },\n\t{ 0x0205, 0x00 },\n\t{ 0x0206, 0x00 },  \n\t{ 0x0208, 0x00 },  \n\t{ 0x0209, 0x00 },\n\t{ 0x020A, 0x00 },\n\t{ 0x020B, 0x00 },\n\t{ 0x020C, 0x00 },\n\t{ 0x020D, 0x00 },\n\t{ 0x020E, 0x00 },\n\t{ 0x020F, 0x00 },\n\t{ 0x0210, 0x00 },\n\t{ 0x0211, 0x00 },\n\t{ 0x0212, 0x00 },\n\t{ 0x0213, 0x00 },\n\t{ 0x0214, 0x00 },\n\t{ 0x0215, 0x00 },\n\t{ 0x0216, 0x00 },\n\t{ 0x0217, 0x00 },\n\t{ 0x0218, 0x00 },\n\t{ 0x0219, 0x00 },\n\t{ 0x021A, 0x00 },\n\t{ 0x021B, 0x00 },\n\t{ 0x021C, 0x00 },\n\t{ 0x021D, 0x00 },\n\t{ 0x021E, 0x00 },\n\t{ 0x021F, 0x00 },\n\t{ 0x0220, 0x00 },\n\t{ 0x0221, 0x00 },\n\t{ 0x0222, 0x00 },\n\t{ 0x0223, 0x00 },\n\t{ 0x0224, 0x00 },\n\t{ 0x0225, 0x00 },\n\t{ 0x0226, 0x00 },\n\t{ 0x0227, 0x00 },\n\t{ 0x0228, 0x00 },\n\t{ 0x0229, 0x00 },\n\t{ 0x022A, 0x00 },\n\t{ 0x022B, 0x00 },\n\t{ 0x022C, 0x00 },\n\t{ 0x022D, 0x00 },\n\t{ 0x022E, 0x00 },\n\t{ 0x022F, 0x00 },  \n\t{ 0x026B, 0x00 },  \n\t{ 0x026C, 0x00 },\n\t{ 0x026D, 0x00 },\n\t{ 0x026E, 0x00 },\n\t{ 0x026F, 0x00 },\n\t{ 0x0270, 0x00 },\n\t{ 0x0271, 0x00 },\n\t{ 0x0272, 0x00 },  \n\t{ 0x0339, 0x1F },  \n\t{ 0x033B, 0x00 },  \n\t{ 0x033C, 0x00 },\n\t{ 0x033D, 0x00 },\n\t{ 0x033E, 0x00 },\n\t{ 0x033F, 0x00 },\n\t{ 0x0340, 0x00 },\n\t{ 0x0341, 0x00 },\n\t{ 0x0342, 0x00 },\n\t{ 0x0343, 0x00 },\n\t{ 0x0344, 0x00 },\n\t{ 0x0345, 0x00 },\n\t{ 0x0346, 0x00 },\n\t{ 0x0347, 0x00 },\n\t{ 0x0348, 0x00 },\n\t{ 0x0349, 0x00 },\n\t{ 0x034A, 0x00 },\n\t{ 0x034B, 0x00 },\n\t{ 0x034C, 0x00 },\n\t{ 0x034D, 0x00 },\n\t{ 0x034E, 0x00 },\n\t{ 0x034F, 0x00 },\n\t{ 0x0350, 0x00 },\n\t{ 0x0351, 0x00 },\n\t{ 0x0352, 0x00 },\n\t{ 0x0353, 0x00 },\n\t{ 0x0354, 0x00 },\n\t{ 0x0355, 0x00 },\n\t{ 0x0356, 0x00 },\n\t{ 0x0357, 0x00 },\n\t{ 0x0358, 0x00 },  \n\t{ 0x0359, 0x00 },  \n\t{ 0x035A, 0x00 },\n\t{ 0x035B, 0x00 },\n\t{ 0x035C, 0x00 },\n\t{ 0x035D, 0x00 },\n\t{ 0x035E, 0x00 },\n\t{ 0x035F, 0x00 },\n\t{ 0x0360, 0x00 },\n\t{ 0x0361, 0x00 },\n\t{ 0x0362, 0x00 },  \n\t{ 0x0802, 0x00 },  \n\t{ 0x0803, 0x00 },  \n\t{ 0x0804, 0x00 },  \n\t{ 0x090E, 0x02 },  \n\t{ 0x091C, 0x04 },  \n\t{ 0x0949, 0x00 },  \n\t{ 0x094A, 0x00 },  \n\t{ 0x0A02, 0x00 },  \n\t{ 0x0B44, 0x0F },  \n\t{ 0x0B57, 0x10 },  \n\t{ 0x0B58, 0x05 },  \n};\n\n \nstatic int si5341_decode_44_32(struct regmap *regmap, unsigned int reg,\n\tu64 *val1, u32 *val2)\n{\n\tint err;\n\tu8 r[10];\n\n\terr = regmap_bulk_read(regmap, reg, r, 10);\n\tif (err < 0)\n\t\treturn err;\n\n\t*val1 = ((u64)((r[5] & 0x0f) << 8 | r[4]) << 32) |\n\t\t (get_unaligned_le32(r));\n\t*val2 = get_unaligned_le32(&r[6]);\n\n\treturn 0;\n}\n\nstatic int si5341_encode_44_32(struct regmap *regmap, unsigned int reg,\n\tu64 n_num, u32 n_den)\n{\n\tu8 r[10];\n\n\t \n\twhile (!(n_num & BIT_ULL(43)) && !(n_den & BIT(31))) {\n\t\tn_num <<= 1;\n\t\tn_den <<= 1;\n\t}\n\n\t \n\tput_unaligned_le32(n_num, r);\n\tr[4] = (n_num >> 32) & 0xff;\n\tr[5] = (n_num >> 40) & 0x0f;\n\t \n\tput_unaligned_le32(n_den, &r[6]);\n\n\t \n\treturn regmap_bulk_write(regmap, reg, r, sizeof(r));\n}\n\n \nstatic unsigned long si5341_clk_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_si5341 *data = to_clk_si5341(hw);\n\tint err;\n\tu64 res;\n\tu64 m_num;\n\tu32 m_den;\n\tunsigned int shift;\n\n\t \n\terr = si5341_decode_44_32(data->regmap, SI5341_PLL_M_NUM,\n\t\t\t\t&m_num, &m_den);\n\tif (err < 0)\n\t\treturn 0;\n\n\tif (!m_num || !m_den)\n\t\treturn 0;\n\n\t \n\tshift = 0;\n\tres = m_num;\n\twhile (res & 0xffff00000000ULL) {\n\t\t++shift;\n\t\tres >>= 1;\n\t}\n\tres *= parent_rate;\n\tdo_div(res, (m_den >> shift));\n\n\t \n\tdata->freq_vco = res;\n\n\t \n\tdo_div(res, 1000);\n\n\treturn (unsigned long)res;\n}\n\nstatic int si5341_clk_get_selected_input(struct clk_si5341 *data)\n{\n\tint err;\n\tu32 val;\n\n\terr = regmap_read(data->regmap, SI5341_IN_SEL, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn (val & SI5341_IN_SEL_MASK) >> SI5341_IN_SEL_SHIFT;\n}\n\nstatic u8 si5341_clk_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_si5341 *data = to_clk_si5341(hw);\n\tint res = si5341_clk_get_selected_input(data);\n\n\tif (res < 0)\n\t\treturn 0;  \n\n\treturn res;\n}\n\nstatic int si5341_clk_reparent(struct clk_si5341 *data, u8 index)\n{\n\tint err;\n\tu8 val;\n\n\tval = (index << SI5341_IN_SEL_SHIFT) & SI5341_IN_SEL_MASK;\n\t \n\tval |= SI5341_IN_SEL_REGCTRL;\n\n\terr = regmap_update_bits(data->regmap,\n\t\tSI5341_IN_SEL, SI5341_IN_SEL_REGCTRL | SI5341_IN_SEL_MASK, val);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (index < 3) {\n\t\t \n\t\terr = regmap_update_bits(data->regmap,\n\t\t\t\tSI5341_IN_EN, 0x07, BIT(index));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\terr = regmap_update_bits(data->regmap, SI5341_INX_TO_PFD_EN,\n\t\t\t\t0x7 << SI5341_INX_TO_PFD_SHIFT,\n\t\t\t\tBIT(index + SI5341_INX_TO_PFD_SHIFT));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\terr = regmap_update_bits(data->regmap, SI5341_XAXB_CFG,\n\t\t\t\tSI5341_XAXB_CFG_PDNB, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\terr = regmap_write(data->regmap, SI5341_IN_PDIV(index), 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = regmap_write(data->regmap, SI5341_IN_PSET(index), 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\terr = regmap_write(data->regmap, SI5341_PX_UPD, BIT(index));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\t \n\t\terr = regmap_update_bits(data->regmap, SI5341_IN_EN, 0x07, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\terr = regmap_update_bits(data->regmap, SI5341_INX_TO_PFD_EN,\n\t\t\t\t0x7 << SI5341_INX_TO_PFD_SHIFT, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\terr = regmap_update_bits(data->regmap, SI5341_XAXB_CFG,\n\t\t\t\tSI5341_XAXB_CFG_PDNB | SI5341_XAXB_CFG_EXTCLK_EN,\n\t\t\t\tSI5341_XAXB_CFG_PDNB | (data->xaxb_ext_clk ?\n\t\t\t\t\tSI5341_XAXB_CFG_EXTCLK_EN : 0));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int si5341_clk_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_si5341 *data = to_clk_si5341(hw);\n\n\treturn si5341_clk_reparent(data, index);\n}\n\nstatic const struct clk_ops si5341_clk_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.set_parent = si5341_clk_set_parent,\n\t.get_parent = si5341_clk_get_parent,\n\t.recalc_rate = si5341_clk_recalc_rate,\n};\n\n \n\n \nstatic int si5341_synth_clk_is_on(struct clk_hw *hw)\n{\n\tstruct clk_si5341_synth *synth = to_clk_si5341_synth(hw);\n\tint err;\n\tu32 val;\n\tu8 index = synth->index;\n\n\terr = regmap_read(synth->data->regmap,\n\t\t\tSI5341_SYNTH_N_CLK_TO_OUTX_EN, &val);\n\tif (err < 0)\n\t\treturn 0;\n\n\tif (!(val & BIT(index)))\n\t\treturn 0;\n\n\terr = regmap_read(synth->data->regmap, SI5341_SYNTH_N_PDNB, &val);\n\tif (err < 0)\n\t\treturn 0;\n\n\tif (!(val & BIT(index)))\n\t\treturn 0;\n\n\t \n\terr = regmap_read(synth->data->regmap, SI5341_SYNTH_N_CLK_DIS, &val);\n\tif (err < 0)\n\t\treturn 0;\n\n\treturn !(val & BIT(index));\n}\n\nstatic void si5341_synth_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_si5341_synth *synth = to_clk_si5341_synth(hw);\n\tu8 index = synth->index;  \n\tu8 mask = BIT(index);\n\n\t \n\tregmap_update_bits(synth->data->regmap,\n\t\tSI5341_SYNTH_N_CLK_TO_OUTX_EN, mask, 0);\n\t \n\tregmap_update_bits(synth->data->regmap,\n\t\tSI5341_SYNTH_N_PDNB, mask, 0);\n\t \n\tregmap_update_bits(synth->data->regmap,\n\t\tSI5341_SYNTH_N_CLK_DIS, mask, mask);\n}\n\nstatic int si5341_synth_clk_prepare(struct clk_hw *hw)\n{\n\tstruct clk_si5341_synth *synth = to_clk_si5341_synth(hw);\n\tint err;\n\tu8 index = synth->index;\n\tu8 mask = BIT(index);\n\n\t \n\terr = regmap_update_bits(synth->data->regmap,\n\t\tSI5341_SYNTH_N_PDNB, mask, mask);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = regmap_update_bits(synth->data->regmap,\n\t\tSI5341_SYNTH_N_CLK_DIS, mask, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treturn regmap_update_bits(synth->data->regmap,\n\t\tSI5341_SYNTH_N_CLK_TO_OUTX_EN, mask, mask);\n}\n\n \nstatic unsigned long si5341_synth_clk_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_si5341_synth *synth = to_clk_si5341_synth(hw);\n\tu64 f;\n\tu64 n_num;\n\tu32 n_den;\n\tint err;\n\n\terr = si5341_decode_44_32(synth->data->regmap,\n\t\t\tSI5341_SYNTH_N_NUM(synth->index), &n_num, &n_den);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tif (!n_num || !n_den)\n\t\treturn 0;\n\n\t \n\tf = synth->data->freq_vco;\n\tf *= n_den >> 4;\n\n\t \n\t \n\tf = div64_u64(f, (n_num >> 4));\n\n\treturn f;\n}\n\nstatic long si5341_synth_clk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long *parent_rate)\n{\n\tstruct clk_si5341_synth *synth = to_clk_si5341_synth(hw);\n\tu64 f;\n\n\t \n\tf = synth->data->freq_vco;\n\tdo_div(f, SI5341_SYNTH_N_MAX);\n\tif (rate < f)\n\t\treturn f;\n\n\tf = synth->data->freq_vco;\n\tdo_div(f, SI5341_SYNTH_N_MIN);\n\tif (rate > f)\n\t\treturn f;\n\n\treturn rate;\n}\n\nstatic int si5341_synth_program(struct clk_si5341_synth *synth,\n\tu64 n_num, u32 n_den, bool is_integer)\n{\n\tint err;\n\tu8 index = synth->index;\n\n\terr = si5341_encode_44_32(synth->data->regmap,\n\t\t\tSI5341_SYNTH_N_NUM(index), n_num, n_den);\n\n\terr = regmap_update_bits(synth->data->regmap,\n\t\tSI5341_SYNTH_N_PIBYP, BIT(index), is_integer ? BIT(index) : 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn regmap_write(synth->data->regmap,\n\t\tSI5341_SYNTH_N_UPD(index), 0x01);\n}\n\n\nstatic int si5341_synth_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_si5341_synth *synth = to_clk_si5341_synth(hw);\n\tu64 n_num;\n\tu32 n_den;\n\tu32 r;\n\tu32 g;\n\tbool is_integer;\n\n\tn_num = synth->data->freq_vco;\n\n\t \n\tr = do_div(n_num, rate);\n\tis_integer = (r == 0);\n\tif (is_integer) {\n\t\t \n\t\tn_den = 1;\n\t} else {\n\t\t \n\t\tg = gcd(r, rate);\n\t\tn_den = rate / g;\n\t\tn_num *= n_den;\n\t\tn_num += r / g;\n\t}\n\n\tdev_dbg(&synth->data->i2c_client->dev,\n\t\t\t\"%s(%u): n=0x%llx d=0x%x %s\\n\", __func__,\n\t\t\t\tsynth->index, n_num, n_den,\n\t\t\t\tis_integer ? \"int\" : \"frac\");\n\n\treturn si5341_synth_program(synth, n_num, n_den, is_integer);\n}\n\nstatic const struct clk_ops si5341_synth_clk_ops = {\n\t.is_prepared = si5341_synth_clk_is_on,\n\t.prepare = si5341_synth_clk_prepare,\n\t.unprepare = si5341_synth_clk_unprepare,\n\t.recalc_rate = si5341_synth_clk_recalc_rate,\n\t.round_rate = si5341_synth_clk_round_rate,\n\t.set_rate = si5341_synth_clk_set_rate,\n};\n\nstatic int si5341_output_clk_is_on(struct clk_hw *hw)\n{\n\tstruct clk_si5341_output *output = to_clk_si5341_output(hw);\n\tint err;\n\tu32 val;\n\n\terr = regmap_read(output->data->regmap,\n\t\t\tSI5341_OUT_CONFIG(output), &val);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treturn (val & 0x03) == SI5341_OUT_CFG_OE;\n}\n\n \nstatic void si5341_output_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_si5341_output *output = to_clk_si5341_output(hw);\n\n\tregmap_update_bits(output->data->regmap,\n\t\t\tSI5341_OUT_CONFIG(output),\n\t\t\tSI5341_OUT_CFG_OE, 0);\n\tregmap_update_bits(output->data->regmap,\n\t\t\tSI5341_OUT_CONFIG(output),\n\t\t\tSI5341_OUT_CFG_PDN, SI5341_OUT_CFG_PDN);\n}\n\n \nstatic int si5341_output_clk_prepare(struct clk_hw *hw)\n{\n\tstruct clk_si5341_output *output = to_clk_si5341_output(hw);\n\tint err;\n\n\terr = regmap_update_bits(output->data->regmap,\n\t\t\tSI5341_OUT_CONFIG(output),\n\t\t\tSI5341_OUT_CFG_PDN, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn regmap_update_bits(output->data->regmap,\n\t\t\tSI5341_OUT_CONFIG(output),\n\t\t\tSI5341_OUT_CFG_OE, SI5341_OUT_CFG_OE);\n}\n\nstatic unsigned long si5341_output_clk_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_si5341_output *output = to_clk_si5341_output(hw);\n\tint err;\n\tu32 val;\n\tu32 r_divider;\n\tu8 r[3];\n\n\terr = regmap_read(output->data->regmap,\n\t\t\tSI5341_OUT_CONFIG(output), &val);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (val & SI5341_OUT_CFG_RDIV_FORCE2)\n\t\treturn parent_rate / 2;\n\n\terr = regmap_bulk_read(output->data->regmap,\n\t\t\tSI5341_OUT_R_REG(output), r, 3);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tr_divider = r[2] << 16 | r[1] << 8 | r[0];\n\n\t \n\tif (!r_divider)\n\t\treturn 0;\n\n\t \n\tr_divider += 1;\n\tr_divider <<= 1;\n\n\n\treturn parent_rate / r_divider;\n}\n\nstatic int si5341_output_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t    struct clk_rate_request *req)\n{\n\tunsigned long rate = req->rate;\n\tunsigned long r;\n\n\tif (!rate)\n\t\treturn 0;\n\n\tr = req->best_parent_rate >> 1;\n\n\t \n\tif (r && !(r % rate))\n\t\treturn 0;\n\n\tif (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) {\n\t\tif (rate > 200000000) {\n\t\t\t \n\t\t\tr = 2;\n\t\t} else {\n\t\t\t \n\t\t\tr = (400000000u / rate) & ~1;\n\t\t}\n\t\treq->best_parent_rate = r * rate;\n\t} else {\n\t\t \n\t\tr /= rate;\n\t\trate = req->best_parent_rate / (r << 1);\n\t}\n\n\treq->rate = rate;\n\treturn 0;\n}\n\nstatic int si5341_output_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_si5341_output *output = to_clk_si5341_output(hw);\n\tu32 r_div;\n\tint err;\n\tu8 r[3];\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\t \n\tr_div = (parent_rate / rate) >> 1;\n\n\tif (r_div <= 1)\n\t\tr_div = 0;\n\telse if (r_div >= BIT(24))\n\t\tr_div = BIT(24) - 1;\n\telse\n\t\t--r_div;\n\n\t \n\terr = regmap_update_bits(output->data->regmap,\n\t\t\tSI5341_OUT_CONFIG(output),\n\t\t\tSI5341_OUT_CFG_RDIV_FORCE2,\n\t\t\t(r_div == 0) ? SI5341_OUT_CFG_RDIV_FORCE2 : 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tr[0] = r_div ? (r_div & 0xff) : 1;\n\tr[1] = (r_div >> 8) & 0xff;\n\tr[2] = (r_div >> 16) & 0xff;\n\treturn regmap_bulk_write(output->data->regmap,\n\t\t\tSI5341_OUT_R_REG(output), r, 3);\n}\n\nstatic int si5341_output_reparent(struct clk_si5341_output *output, u8 index)\n{\n\treturn regmap_update_bits(output->data->regmap,\n\t\tSI5341_OUT_MUX_SEL(output), 0x07, index);\n}\n\nstatic int si5341_output_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_si5341_output *output = to_clk_si5341_output(hw);\n\n\tif (index >= output->data->num_synth)\n\t\treturn -EINVAL;\n\n\treturn si5341_output_reparent(output, index);\n}\n\nstatic u8 si5341_output_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_si5341_output *output = to_clk_si5341_output(hw);\n\tu32 val;\n\n\tregmap_read(output->data->regmap, SI5341_OUT_MUX_SEL(output), &val);\n\n\treturn val & 0x7;\n}\n\nstatic const struct clk_ops si5341_output_clk_ops = {\n\t.is_prepared = si5341_output_clk_is_on,\n\t.prepare = si5341_output_clk_prepare,\n\t.unprepare = si5341_output_clk_unprepare,\n\t.recalc_rate = si5341_output_clk_recalc_rate,\n\t.determine_rate = si5341_output_clk_determine_rate,\n\t.set_rate = si5341_output_clk_set_rate,\n\t.set_parent = si5341_output_set_parent,\n\t.get_parent = si5341_output_get_parent,\n};\n\n \nstatic int si5341_is_programmed_already(struct clk_si5341 *data)\n{\n\tint err;\n\tu8 r[4];\n\n\t \n\terr = regmap_bulk_read(data->regmap, SI5341_PLL_M_DEN,\n\t\t\tr, ARRAY_SIZE(r));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn !!get_unaligned_le32(r);\n}\n\nstatic struct clk_hw *\nof_clk_si5341_get(struct of_phandle_args *clkspec, void *_data)\n{\n\tstruct clk_si5341 *data = _data;\n\tunsigned int idx = clkspec->args[1];\n\tunsigned int group = clkspec->args[0];\n\n\tswitch (group) {\n\tcase 0:\n\t\tif (idx >= data->num_outputs) {\n\t\t\tdev_err(&data->i2c_client->dev,\n\t\t\t\t\"invalid output index %u\\n\", idx);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\treturn &data->clk[idx].hw;\n\tcase 1:\n\t\tif (idx >= data->num_synth) {\n\t\t\tdev_err(&data->i2c_client->dev,\n\t\t\t\t\"invalid synthesizer index %u\\n\", idx);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\treturn &data->synth[idx].hw;\n\tcase 2:\n\t\tif (idx > 0) {\n\t\t\tdev_err(&data->i2c_client->dev,\n\t\t\t\t\"invalid PLL index %u\\n\", idx);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\treturn &data->hw;\n\tdefault:\n\t\tdev_err(&data->i2c_client->dev, \"invalid group %u\\n\", group);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n}\n\nstatic int si5341_probe_chip_id(struct clk_si5341 *data)\n{\n\tint err;\n\tu8 reg[4];\n\tu16 model;\n\n\terr = regmap_bulk_read(data->regmap, SI5341_PN_BASE, reg,\n\t\t\t\tARRAY_SIZE(reg));\n\tif (err < 0) {\n\t\tdev_err(&data->i2c_client->dev, \"Failed to read chip ID\\n\");\n\t\treturn err;\n\t}\n\n\tmodel = get_unaligned_le16(reg);\n\n\tdev_info(&data->i2c_client->dev, \"Chip: %x Grade: %u Rev: %u\\n\",\n\t\t model, reg[2], reg[3]);\n\n\tswitch (model) {\n\tcase 0x5340:\n\t\tdata->num_outputs = SI5340_MAX_NUM_OUTPUTS;\n\t\tdata->num_synth = SI5340_NUM_SYNTH;\n\t\tdata->reg_output_offset = si5340_reg_output_offset;\n\t\tdata->reg_rdiv_offset = si5340_reg_rdiv_offset;\n\t\tbreak;\n\tcase 0x5341:\n\t\tdata->num_outputs = SI5341_MAX_NUM_OUTPUTS;\n\t\tdata->num_synth = SI5341_NUM_SYNTH;\n\t\tdata->reg_output_offset = si5341_reg_output_offset;\n\t\tdata->reg_rdiv_offset = si5341_reg_rdiv_offset;\n\t\tbreak;\n\tcase 0x5342:\n\t\tdata->num_outputs = SI5342_MAX_NUM_OUTPUTS;\n\t\tdata->num_synth = SI5342_NUM_SYNTH;\n\t\tdata->reg_output_offset = si5340_reg_output_offset;\n\t\tdata->reg_rdiv_offset = si5340_reg_rdiv_offset;\n\t\tbreak;\n\tcase 0x5344:\n\t\tdata->num_outputs = SI5344_MAX_NUM_OUTPUTS;\n\t\tdata->num_synth = SI5344_NUM_SYNTH;\n\t\tdata->reg_output_offset = si5340_reg_output_offset;\n\t\tdata->reg_rdiv_offset = si5340_reg_rdiv_offset;\n\t\tbreak;\n\tcase 0x5345:\n\t\tdata->num_outputs = SI5345_MAX_NUM_OUTPUTS;\n\t\tdata->num_synth = SI5345_NUM_SYNTH;\n\t\tdata->reg_output_offset = si5341_reg_output_offset;\n\t\tdata->reg_rdiv_offset = si5341_reg_rdiv_offset;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&data->i2c_client->dev, \"Model '%x' not supported\\n\",\n\t\t\tmodel);\n\t\treturn -EINVAL;\n\t}\n\n\tdata->chip_id = model;\n\n\treturn 0;\n}\n\n \nstatic int si5341_read_settings(struct clk_si5341 *data)\n{\n\tint err;\n\tu8 i;\n\tu8 r[10];\n\n\terr = regmap_bulk_read(data->regmap, SI5341_PLL_M_NUM, r, 10);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = regmap_bulk_read(data->regmap,\n\t\t\t\tSI5341_SYNTH_N_CLK_TO_OUTX_EN, r, 3);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = regmap_bulk_read(data->regmap,\n\t\t\t\tSI5341_SYNTH_N_CLK_DIS, r, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < data->num_synth; ++i) {\n\t\terr = regmap_bulk_read(data->regmap,\n\t\t\t\t\tSI5341_SYNTH_N_NUM(i), r, 10);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < data->num_outputs; ++i) {\n\t\terr = regmap_bulk_read(data->regmap,\n\t\t\t\t\tdata->reg_output_offset[i], r, 4);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = regmap_bulk_read(data->regmap,\n\t\t\t\t\tdata->reg_rdiv_offset[i], r, 3);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int si5341_write_multiple(struct clk_si5341 *data,\n\tconst struct si5341_reg_default *values, unsigned int num_values)\n{\n\tunsigned int i;\n\tint res;\n\n\tfor (i = 0; i < num_values; ++i) {\n\t\tres = regmap_write(data->regmap,\n\t\t\tvalues[i].address, values[i].value);\n\t\tif (res < 0) {\n\t\t\tdev_err(&data->i2c_client->dev,\n\t\t\t\t\"Failed to write %#x:%#x\\n\",\n\t\t\t\tvalues[i].address, values[i].value);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct si5341_reg_default si5341_preamble[] = {\n\t{ 0x0B25, 0x00 },\n\t{ 0x0502, 0x01 },\n\t{ 0x0505, 0x03 },\n\t{ 0x0957, 0x17 },\n\t{ 0x0B4E, 0x1A },\n};\n\nstatic const struct si5341_reg_default si5345_preamble[] = {\n\t{ 0x0B25, 0x00 },\n\t{ 0x0540, 0x01 },\n};\n\nstatic int si5341_send_preamble(struct clk_si5341 *data)\n{\n\tint res;\n\tu32 revision;\n\n\t \n\tres = regmap_read(data->regmap, SI5341_DEVICE_REV, &revision);\n\tif (res < 0)\n\t\treturn res;\n\n\t \n\tres = regmap_write(data->regmap, 0xB24, revision < 2 ? 0xD8 : 0xC0);\n\tif (res < 0)\n\t\treturn res;\n\n\t \n\tif (data->chip_id > 0x5341)\n\t\tres = si5341_write_multiple(data,\n\t\t\tsi5345_preamble, ARRAY_SIZE(si5345_preamble));\n\telse\n\t\tres = si5341_write_multiple(data,\n\t\t\tsi5341_preamble, ARRAY_SIZE(si5341_preamble));\n\tif (res < 0)\n\t\treturn res;\n\n\t \n\tmsleep(300);\n\n\treturn 0;\n}\n\n \nstatic int si5341_finalize_defaults(struct clk_si5341 *data)\n{\n\tint res;\n\tu32 revision;\n\n\tres = regmap_write(data->regmap, SI5341_IO_VDD_SEL,\n\t\t\t   data->iovdd_33 ? 1 : 0);\n\tif (res < 0)\n\t\treturn res;\n\n\tres = regmap_read(data->regmap, SI5341_DEVICE_REV, &revision);\n\tif (res < 0)\n\t\treturn res;\n\n\tdev_dbg(&data->i2c_client->dev, \"%s rev=%u\\n\", __func__, revision);\n\n\tres = regmap_write(data->regmap, SI5341_SOFT_RST, 0x01);\n\tif (res < 0)\n\t\treturn res;\n\n\t \n\tif (data->chip_id > 0x5341) {\n\t\tres = regmap_write(data->regmap, 0x540, 0x0);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t}\n\n\t \n\tres = regmap_write(data->regmap, 0xB24, revision < 2 ? 0xDB : 0xC3);\n\tif (res < 0)\n\t\treturn res;\n\tres = regmap_write(data->regmap, 0x0B25, 0x02);\n\tif (res < 0)\n\t\treturn res;\n\n\treturn 0;\n}\n\n\nstatic const struct regmap_range si5341_regmap_volatile_range[] = {\n\tregmap_reg_range(0x000C, 0x0012),  \n\tregmap_reg_range(0x001C, 0x001E),  \n\tregmap_reg_range(0x00E2, 0x00FE),  \n\t \n\tregmap_reg_range(SI5341_PX_UPD, SI5341_PX_UPD),\n\tregmap_reg_range(SI5341_SYNTH_N_UPD(0), SI5341_SYNTH_N_UPD(0)),\n\tregmap_reg_range(SI5341_SYNTH_N_UPD(1), SI5341_SYNTH_N_UPD(1)),\n\tregmap_reg_range(SI5341_SYNTH_N_UPD(2), SI5341_SYNTH_N_UPD(2)),\n\tregmap_reg_range(SI5341_SYNTH_N_UPD(3), SI5341_SYNTH_N_UPD(3)),\n\tregmap_reg_range(SI5341_SYNTH_N_UPD(4), SI5341_SYNTH_N_UPD(4)),\n};\n\nstatic const struct regmap_access_table si5341_regmap_volatile = {\n\t.yes_ranges = si5341_regmap_volatile_range,\n\t.n_yes_ranges = ARRAY_SIZE(si5341_regmap_volatile_range),\n};\n\n \nstatic const struct regmap_range_cfg si5341_regmap_ranges[] = {\n\t{\n\t\t.range_min = 0,\n\t\t.range_max = SI5341_REGISTER_MAX,\n\t\t.selector_reg = SI5341_PAGE,\n\t\t.selector_mask = 0xff,\n\t\t.selector_shift = 0,\n\t\t.window_start = 0,\n\t\t.window_len = 256,\n\t},\n};\n\nstatic int si5341_wait_device_ready(struct i2c_client *client)\n{\n\tint count;\n\n\t \n\tfor (count = 0; count < 15; ++count) {\n\t\ts32 result = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t      SI5341_DEVICE_READY);\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\tif (result == 0x0F)\n\t\t\treturn 0;\n\t\tmsleep(20);\n\t}\n\tdev_err(&client->dev, \"timeout waiting for DEVICE_READY\\n\");\n\treturn -EIO;\n}\n\nstatic const struct regmap_config si5341_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.ranges = si5341_regmap_ranges,\n\t.num_ranges = ARRAY_SIZE(si5341_regmap_ranges),\n\t.max_register = SI5341_REGISTER_MAX,\n\t.volatile_table = &si5341_regmap_volatile,\n};\n\nstatic int si5341_dt_parse_dt(struct clk_si5341 *data,\n\t\t\t      struct clk_si5341_output_config *config)\n{\n\tstruct device_node *child;\n\tstruct device_node *np = data->i2c_client->dev.of_node;\n\tu32 num;\n\tu32 val;\n\n\tmemset(config, 0, sizeof(struct clk_si5341_output_config) *\n\t\t\t\tSI5341_MAX_NUM_OUTPUTS);\n\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_property_read_u32(child, \"reg\", &num)) {\n\t\t\tdev_err(&data->i2c_client->dev, \"missing reg property of %s\\n\",\n\t\t\t\tchild->name);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tif (num >= SI5341_MAX_NUM_OUTPUTS) {\n\t\t\tdev_err(&data->i2c_client->dev, \"invalid clkout %d\\n\", num);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tif (!of_property_read_u32(child, \"silabs,format\", &val)) {\n\t\t\t \n\t\t\tswitch (val) {\n\t\t\tcase 1:  \n\t\t\t\tconfig[num].out_cm_ampl_bits = 0x33;\n\t\t\t\tbreak;\n\t\t\tcase 2:  \n\t\t\t\tconfig[num].out_cm_ampl_bits = 0x13;\n\t\t\t\tbreak;\n\t\t\tcase 4:  \n\t\t\t\tconfig[num].out_cm_ampl_bits = 0x33;\n\t\t\t\t \n\t\t\t\tconfig[num].out_format_drv_bits |= 0xc0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(&data->i2c_client->dev,\n\t\t\t\t\t\"invalid silabs,format %u for %u\\n\",\n\t\t\t\t\tval, num);\n\t\t\t\tgoto put_child;\n\t\t\t}\n\t\t\tconfig[num].out_format_drv_bits &= ~0x07;\n\t\t\tconfig[num].out_format_drv_bits |= val & 0x07;\n\t\t\t \n\t\t\tconfig[num].out_format_drv_bits |= 0x08;\n\t\t}\n\n\t\tif (!of_property_read_u32(child, \"silabs,common-mode\", &val)) {\n\t\t\tif (val > 0xf) {\n\t\t\t\tdev_err(&data->i2c_client->dev,\n\t\t\t\t\t\"invalid silabs,common-mode %u\\n\",\n\t\t\t\t\tval);\n\t\t\t\tgoto put_child;\n\t\t\t}\n\t\t\tconfig[num].out_cm_ampl_bits &= 0xf0;\n\t\t\tconfig[num].out_cm_ampl_bits |= val & 0x0f;\n\t\t}\n\n\t\tif (!of_property_read_u32(child, \"silabs,amplitude\", &val)) {\n\t\t\tif (val > 0xf) {\n\t\t\t\tdev_err(&data->i2c_client->dev,\n\t\t\t\t\t\"invalid silabs,amplitude %u\\n\",\n\t\t\t\t\tval);\n\t\t\t\tgoto put_child;\n\t\t\t}\n\t\t\tconfig[num].out_cm_ampl_bits &= 0x0f;\n\t\t\tconfig[num].out_cm_ampl_bits |= (val << 4) & 0xf0;\n\t\t}\n\n\t\tif (of_property_read_bool(child, \"silabs,disable-high\"))\n\t\t\tconfig[num].out_format_drv_bits |= 0x10;\n\n\t\tconfig[num].synth_master =\n\t\t\tof_property_read_bool(child, \"silabs,synth-master\");\n\n\t\tconfig[num].always_on =\n\t\t\tof_property_read_bool(child, \"always-on\");\n\n\t\tconfig[num].vdd_sel_bits = 0x08;\n\t\tif (data->clk[num].vddo_reg) {\n\t\t\tint vdd = regulator_get_voltage(data->clk[num].vddo_reg);\n\n\t\t\tswitch (vdd) {\n\t\t\tcase 3300000:\n\t\t\t\tconfig[num].vdd_sel_bits |= 0 << 4;\n\t\t\t\tbreak;\n\t\t\tcase 1800000:\n\t\t\t\tconfig[num].vdd_sel_bits |= 1 << 4;\n\t\t\t\tbreak;\n\t\t\tcase 2500000:\n\t\t\t\tconfig[num].vdd_sel_bits |= 2 << 4;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(&data->i2c_client->dev,\n\t\t\t\t\t\"unsupported vddo voltage %d for %s\\n\",\n\t\t\t\t\tvdd, child->name);\n\t\t\t\tgoto put_child;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdev_warn(&data->i2c_client->dev,\n\t\t\t\t\"no regulator set, defaulting vdd_sel to 2.5V for %s\\n\",\n\t\t\t\tchild->name);\n\t\t\tconfig[num].vdd_sel_bits |= 2 << 4;\n\t\t}\n\t}\n\n\treturn 0;\n\nput_child:\n\tof_node_put(child);\n\treturn -EINVAL;\n}\n\n \nstatic int si5341_initialize_pll(struct clk_si5341 *data)\n{\n\tstruct device_node *np = data->i2c_client->dev.of_node;\n\tu32 m_num = 0;\n\tu32 m_den = 0;\n\tint sel;\n\n\tif (of_property_read_u32(np, \"silabs,pll-m-num\", &m_num)) {\n\t\tdev_err(&data->i2c_client->dev,\n\t\t\t\"PLL configuration requires silabs,pll-m-num\\n\");\n\t}\n\tif (of_property_read_u32(np, \"silabs,pll-m-den\", &m_den)) {\n\t\tdev_err(&data->i2c_client->dev,\n\t\t\t\"PLL configuration requires silabs,pll-m-den\\n\");\n\t}\n\n\tif (!m_num || !m_den) {\n\t\tdev_err(&data->i2c_client->dev,\n\t\t\t\"PLL configuration invalid, assume 14GHz\\n\");\n\t\tsel = si5341_clk_get_selected_input(data);\n\t\tif (sel < 0)\n\t\t\treturn sel;\n\n\t\tm_den = clk_get_rate(data->input_clk[sel]) / 10;\n\t\tm_num = 1400000000;\n\t}\n\n\treturn si5341_encode_44_32(data->regmap,\n\t\t\tSI5341_PLL_M_NUM, m_num, m_den);\n}\n\nstatic int si5341_clk_select_active_input(struct clk_si5341 *data)\n{\n\tint res;\n\tint err;\n\tint i;\n\n\tres = si5341_clk_get_selected_input(data);\n\tif (res < 0)\n\t\treturn res;\n\n\t \n\tif (!data->input_clk[res]) {\n\t\tdev_dbg(&data->i2c_client->dev,\n\t\t\t\"Input %d not connected, rerouting\\n\", res);\n\t\tres = -ENODEV;\n\t\tfor (i = 0; i < SI5341_NUM_INPUTS; ++i) {\n\t\t\tif (data->input_clk[i]) {\n\t\t\t\tres = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (res < 0) {\n\t\t\tdev_err(&data->i2c_client->dev,\n\t\t\t\t\"No clock input available\\n\");\n\t\t\treturn res;\n\t\t}\n\t}\n\n\t \n\terr = si5341_clk_reparent(data, res);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = clk_prepare_enable(data->input_clk[res]);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn res;\n}\n\nstatic ssize_t input_present_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct clk_si5341 *data = dev_get_drvdata(dev);\n\tu32 status;\n\tint res = regmap_read(data->regmap, SI5341_STATUS, &status);\n\n\tif (res < 0)\n\t\treturn res;\n\tres = !(status & SI5341_STATUS_LOSREF);\n\treturn sysfs_emit(buf, \"%d\\n\", res);\n}\nstatic DEVICE_ATTR_RO(input_present);\n\nstatic ssize_t input_present_sticky_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct clk_si5341 *data = dev_get_drvdata(dev);\n\tu32 status;\n\tint res = regmap_read(data->regmap, SI5341_STATUS_STICKY, &status);\n\n\tif (res < 0)\n\t\treturn res;\n\tres = !(status & SI5341_STATUS_LOSREF);\n\treturn sysfs_emit(buf, \"%d\\n\", res);\n}\nstatic DEVICE_ATTR_RO(input_present_sticky);\n\nstatic ssize_t pll_locked_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct clk_si5341 *data = dev_get_drvdata(dev);\n\tu32 status;\n\tint res = regmap_read(data->regmap, SI5341_STATUS, &status);\n\n\tif (res < 0)\n\t\treturn res;\n\tres = !(status & SI5341_STATUS_LOL);\n\treturn sysfs_emit(buf, \"%d\\n\", res);\n}\nstatic DEVICE_ATTR_RO(pll_locked);\n\nstatic ssize_t pll_locked_sticky_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct clk_si5341 *data = dev_get_drvdata(dev);\n\tu32 status;\n\tint res = regmap_read(data->regmap, SI5341_STATUS_STICKY, &status);\n\n\tif (res < 0)\n\t\treturn res;\n\tres = !(status & SI5341_STATUS_LOL);\n\treturn sysfs_emit(buf, \"%d\\n\", res);\n}\nstatic DEVICE_ATTR_RO(pll_locked_sticky);\n\nstatic ssize_t clear_sticky_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct clk_si5341 *data = dev_get_drvdata(dev);\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val))\n\t\treturn -EINVAL;\n\tif (val) {\n\t\tint res = regmap_write(data->regmap, SI5341_STATUS_STICKY, 0);\n\n\t\tif (res < 0)\n\t\t\treturn res;\n\t}\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(clear_sticky);\n\nstatic const struct attribute *si5341_attributes[] = {\n\t&dev_attr_input_present.attr,\n\t&dev_attr_input_present_sticky.attr,\n\t&dev_attr_pll_locked.attr,\n\t&dev_attr_pll_locked_sticky.attr,\n\t&dev_attr_clear_sticky.attr,\n\tNULL\n};\n\nstatic int si5341_probe(struct i2c_client *client)\n{\n\tstruct clk_si5341 *data;\n\tstruct clk_init_data init;\n\tstruct clk *input;\n\tconst char *root_clock_name;\n\tconst char *synth_clock_names[SI5341_NUM_SYNTH] = { NULL };\n\tint err;\n\tunsigned int i;\n\tstruct clk_si5341_output_config config[SI5341_MAX_NUM_OUTPUTS];\n\tbool initialization_required;\n\tu32 status;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->i2c_client = client;\n\n\t \n\terr = si5341_wait_device_ready(client);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < SI5341_NUM_INPUTS; ++i) {\n\t\tinput = devm_clk_get(&client->dev, si5341_input_clock_names[i]);\n\t\tif (IS_ERR(input)) {\n\t\t\tif (PTR_ERR(input) == -EPROBE_DEFER)\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t\tdata->input_clk_name[i] = si5341_input_clock_names[i];\n\t\t} else {\n\t\t\tdata->input_clk[i] = input;\n\t\t\tdata->input_clk_name[i] = __clk_get_name(input);\n\t\t}\n\t}\n\n\tfor (i = 0; i < SI5341_MAX_NUM_OUTPUTS; ++i) {\n\t\tchar reg_name[10];\n\n\t\tsnprintf(reg_name, sizeof(reg_name), \"vddo%d\", i);\n\t\tdata->clk[i].vddo_reg = devm_regulator_get_optional(\n\t\t\t&client->dev, reg_name);\n\t\tif (IS_ERR(data->clk[i].vddo_reg)) {\n\t\t\terr = PTR_ERR(data->clk[i].vddo_reg);\n\t\t\tdata->clk[i].vddo_reg = NULL;\n\t\t\tif (err == -ENODEV)\n\t\t\t\tcontinue;\n\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\terr = regulator_enable(data->clk[i].vddo_reg);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"failed to enable %s regulator: %d\\n\",\n\t\t\t\t\treg_name, err);\n\t\t\t\tdata->clk[i].vddo_reg = NULL;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\n\terr = si5341_dt_parse_dt(data, config);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (of_property_read_string(client->dev.of_node, \"clock-output-names\",\n\t\t\t&init.name))\n\t\tinit.name = client->dev.of_node->name;\n\troot_clock_name = init.name;\n\n\tdata->regmap = devm_regmap_init_i2c(client, &si5341_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\terr = PTR_ERR(data->regmap);\n\t\tgoto cleanup;\n\t}\n\n\ti2c_set_clientdata(client, data);\n\n\terr = si5341_probe_chip_id(data);\n\tif (err < 0)\n\t\tgoto cleanup;\n\n\tif (of_property_read_bool(client->dev.of_node, \"silabs,reprogram\")) {\n\t\tinitialization_required = true;\n\t} else {\n\t\terr = si5341_is_programmed_already(data);\n\t\tif (err < 0)\n\t\t\tgoto cleanup;\n\n\t\tinitialization_required = !err;\n\t}\n\tdata->xaxb_ext_clk = of_property_read_bool(client->dev.of_node,\n\t\t\t\t\t\t   \"silabs,xaxb-ext-clk\");\n\tdata->iovdd_33 = of_property_read_bool(client->dev.of_node,\n\t\t\t\t\t       \"silabs,iovdd-33\");\n\n\tif (initialization_required) {\n\t\t \n\t\terr = si5341_read_settings(data);\n\t\tif (err < 0)\n\t\t\tgoto cleanup;\n\n\t\terr = si5341_send_preamble(data);\n\t\tif (err < 0)\n\t\t\tgoto cleanup;\n\n\t\t \n\t\tregcache_cache_only(data->regmap, true);\n\n\t\t \n\t\terr = si5341_write_multiple(data, si5341_reg_defaults,\n\t\t\t\t\tARRAY_SIZE(si5341_reg_defaults));\n\t\tif (err < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t \n\terr = si5341_clk_select_active_input(data);\n\tif (err < 0)\n\t\tgoto cleanup;\n\n\tif (initialization_required) {\n\t\t \n\t\terr = si5341_initialize_pll(data);\n\t\tif (err < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t \n\tinit.parent_names = data->input_clk_name;\n\tinit.num_parents = SI5341_NUM_INPUTS;\n\tinit.ops = &si5341_clk_ops;\n\tinit.flags = 0;\n\tdata->hw.init = &init;\n\n\terr = devm_clk_hw_register(&client->dev, &data->hw);\n\tif (err) {\n\t\tdev_err(&client->dev, \"clock registration failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tinit.num_parents = 1;\n\tinit.parent_names = &root_clock_name;\n\tinit.ops = &si5341_synth_clk_ops;\n\tfor (i = 0; i < data->num_synth; ++i) {\n\t\tsynth_clock_names[i] = devm_kasprintf(&client->dev, GFP_KERNEL,\n\t\t\t\t\"%s.N%u\", client->dev.of_node->name, i);\n\t\tif (!synth_clock_names[i]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_clk_names;\n\t\t}\n\t\tinit.name = synth_clock_names[i];\n\t\tdata->synth[i].index = i;\n\t\tdata->synth[i].data = data;\n\t\tdata->synth[i].hw.init = &init;\n\t\terr = devm_clk_hw_register(&client->dev, &data->synth[i].hw);\n\t\tif (err) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"synth N%u registration failed\\n\", i);\n\t\t\tgoto free_clk_names;\n\t\t}\n\t}\n\n\tinit.num_parents = data->num_synth;\n\tinit.parent_names = synth_clock_names;\n\tinit.ops = &si5341_output_clk_ops;\n\tfor (i = 0; i < data->num_outputs; ++i) {\n\t\tinit.name = kasprintf(GFP_KERNEL, \"%s.%d\",\n\t\t\tclient->dev.of_node->name, i);\n\t\tif (!init.name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_clk_names;\n\t\t}\n\t\tinit.flags = config[i].synth_master ? CLK_SET_RATE_PARENT : 0;\n\t\tdata->clk[i].index = i;\n\t\tdata->clk[i].data = data;\n\t\tdata->clk[i].hw.init = &init;\n\t\tif (config[i].out_format_drv_bits & 0x07) {\n\t\t\tregmap_write(data->regmap,\n\t\t\t\tSI5341_OUT_FORMAT(&data->clk[i]),\n\t\t\t\tconfig[i].out_format_drv_bits);\n\t\t\tregmap_write(data->regmap,\n\t\t\t\tSI5341_OUT_CM(&data->clk[i]),\n\t\t\t\tconfig[i].out_cm_ampl_bits);\n\t\t\tregmap_update_bits(data->regmap,\n\t\t\t\tSI5341_OUT_MUX_SEL(&data->clk[i]),\n\t\t\t\tSI5341_OUT_MUX_VDD_SEL_MASK,\n\t\t\t\tconfig[i].vdd_sel_bits);\n\t\t}\n\t\terr = devm_clk_hw_register(&client->dev, &data->clk[i].hw);\n\t\tkfree(init.name);  \n\t\tif (err) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"output %u registration failed\\n\", i);\n\t\t\tgoto free_clk_names;\n\t\t}\n\t\tif (config[i].always_on)\n\t\t\tclk_prepare(data->clk[i].hw.clk);\n\t}\n\n\terr = devm_of_clk_add_hw_provider(&client->dev, of_clk_si5341_get,\n\t\t\tdata);\n\tif (err) {\n\t\tdev_err(&client->dev, \"unable to add clk provider\\n\");\n\t\tgoto free_clk_names;\n\t}\n\n\tif (initialization_required) {\n\t\t \n\t\tregcache_cache_only(data->regmap, false);\n\t\terr = regcache_sync(data->regmap);\n\t\tif (err < 0)\n\t\t\tgoto free_clk_names;\n\n\t\terr = si5341_finalize_defaults(data);\n\t\tif (err < 0)\n\t\t\tgoto free_clk_names;\n\t}\n\n\t \n\terr = regmap_read_poll_timeout(data->regmap, SI5341_STATUS, status,\n\t\t!(status & (SI5341_STATUS_LOSREF | SI5341_STATUS_LOL)),\n\t       10000, 250000);\n\tif (err) {\n\t\tdev_err(&client->dev, \"Error waiting for input clock or PLL lock\\n\");\n\t\tgoto free_clk_names;\n\t}\n\n\t \n\terr = regmap_write(data->regmap, SI5341_STATUS_STICKY, 0);\n\tif (err) {\n\t\tdev_err(&client->dev, \"unable to clear sticky status\\n\");\n\t\tgoto free_clk_names;\n\t}\n\n\terr = sysfs_create_files(&client->dev.kobj, si5341_attributes);\n\tif (err)\n\t\tdev_err(&client->dev, \"unable to create sysfs files\\n\");\n\nfree_clk_names:\n\t \n\tfor (i = 0; i < data->num_synth; ++i)\n\t\t devm_kfree(&client->dev, (void *)synth_clock_names[i]);\n\ncleanup:\n\tif (err) {\n\t\tfor (i = 0; i < SI5341_MAX_NUM_OUTPUTS; ++i) {\n\t\t\tif (data->clk[i].vddo_reg)\n\t\t\t\tregulator_disable(data->clk[i].vddo_reg);\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic void si5341_remove(struct i2c_client *client)\n{\n\tstruct clk_si5341 *data = i2c_get_clientdata(client);\n\tint i;\n\n\tsysfs_remove_files(&client->dev.kobj, si5341_attributes);\n\n\tfor (i = 0; i < SI5341_MAX_NUM_OUTPUTS; ++i) {\n\t\tif (data->clk[i].vddo_reg)\n\t\t\tregulator_disable(data->clk[i].vddo_reg);\n\t}\n}\n\nstatic const struct i2c_device_id si5341_id[] = {\n\t{ \"si5340\", 0 },\n\t{ \"si5341\", 1 },\n\t{ \"si5342\", 2 },\n\t{ \"si5344\", 4 },\n\t{ \"si5345\", 5 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, si5341_id);\n\nstatic const struct of_device_id clk_si5341_of_match[] = {\n\t{ .compatible = \"silabs,si5340\" },\n\t{ .compatible = \"silabs,si5341\" },\n\t{ .compatible = \"silabs,si5342\" },\n\t{ .compatible = \"silabs,si5344\" },\n\t{ .compatible = \"silabs,si5345\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, clk_si5341_of_match);\n\nstatic struct i2c_driver si5341_driver = {\n\t.driver = {\n\t\t.name = \"si5341\",\n\t\t.of_match_table = clk_si5341_of_match,\n\t},\n\t.probe\t\t= si5341_probe,\n\t.remove\t\t= si5341_remove,\n\t.id_table\t= si5341_id,\n};\nmodule_i2c_driver(si5341_driver);\n\nMODULE_AUTHOR(\"Mike Looijmans <mike.looijmans@topic.nl>\");\nMODULE_DESCRIPTION(\"Si5341 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}