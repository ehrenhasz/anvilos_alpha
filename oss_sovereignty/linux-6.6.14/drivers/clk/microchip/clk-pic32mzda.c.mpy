{
  "module_name": "clk-pic32mzda.c",
  "hash_id": "090ee59a96fd9c054b1c56bcd4aa4b8494ba2fae3459fbe3f1206b3890710804",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/microchip/clk-pic32mzda.c",
  "human_readable_source": "\n \n#include <dt-bindings/clock/microchip,pic32-clock.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <asm/traps.h>\n\n#include \"clk-core.h\"\n\n \n#define OSC_FRCDIV_MASK\t\t0x07\n#define OSC_FRCDIV_SHIFT\t24\n\n \n#define PLL_ICLK_MASK\t\t0x01\n#define PLL_ICLK_SHIFT\t\t7\n\n#define DECLARE_PERIPHERAL_CLOCK(__clk_name, __reg, __flags)\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.ctrl_reg = (__reg),\t\t\t\t\\\n\t\t.init_data = {\t\t\t\t\t\\\n\t\t\t.name = (__clk_name),\t\t\t\\\n\t\t\t.parent_names = (const char *[]) {\t\\\n\t\t\t\t\"sys_clk\"\t\t\t\\\n\t\t\t},\t\t\t\t\t\\\n\t\t\t.num_parents = 1,\t\t\t\\\n\t\t\t.ops = &pic32_pbclk_ops,\t\t\\\n\t\t\t.flags = (__flags),\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t}\n\n#define DECLARE_REFO_CLOCK(__clkid, __reg)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.ctrl_reg = (__reg),\t\t\t\t\t\\\n\t\t.init_data = {\t\t\t\t\t\t\\\n\t\t\t.name = \"refo\" #__clkid \"_clk\",\t\t\t\\\n\t\t\t.parent_names = (const char *[]) {\t\t\\\n\t\t\t\t\"sys_clk\", \"pb1_clk\", \"posc_clk\",\t\\\n\t\t\t\t\"frc_clk\", \"lprc_clk\", \"sosc_clk\",\t\\\n\t\t\t\t\"sys_pll\", \"refi\" #__clkid \"_clk\",\t\\\n\t\t\t\t\"bfrc_clk\",\t\t\t\t\\\n\t\t\t},\t\t\t\t\t\t\\\n\t\t\t.num_parents = 9,\t\t\t\t\\\n\t\t\t.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE,\\\n\t\t\t.ops = &pic32_roclk_ops,\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.parent_map = (const u32[]) {\t\t\t\t\\\n\t\t\t0, 1, 2, 3, 4, 5, 7, 8, 9\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\nstatic const struct pic32_ref_osc_data ref_clks[] = {\n\tDECLARE_REFO_CLOCK(1, 0x80),\n\tDECLARE_REFO_CLOCK(2, 0xa0),\n\tDECLARE_REFO_CLOCK(3, 0xc0),\n\tDECLARE_REFO_CLOCK(4, 0xe0),\n\tDECLARE_REFO_CLOCK(5, 0x100),\n};\n\nstatic const struct pic32_periph_clk_data periph_clocks[] = {\n\tDECLARE_PERIPHERAL_CLOCK(\"pb1_clk\", 0x140, 0),\n\tDECLARE_PERIPHERAL_CLOCK(\"pb2_clk\", 0x150, CLK_IGNORE_UNUSED),\n\tDECLARE_PERIPHERAL_CLOCK(\"pb3_clk\", 0x160, 0),\n\tDECLARE_PERIPHERAL_CLOCK(\"pb4_clk\", 0x170, 0),\n\tDECLARE_PERIPHERAL_CLOCK(\"pb5_clk\", 0x180, 0),\n\tDECLARE_PERIPHERAL_CLOCK(\"pb6_clk\", 0x190, 0),\n\tDECLARE_PERIPHERAL_CLOCK(\"cpu_clk\", 0x1a0, CLK_IGNORE_UNUSED),\n};\n\nstatic const struct pic32_sys_clk_data sys_mux_clk = {\n\t.slew_reg = 0x1c0,\n\t.slew_div = 2,  \n\t.init_data = {\n\t\t.name = \"sys_clk\",\n\t\t.parent_names = (const char *[]) {\n\t\t\t\"frcdiv_clk\", \"sys_pll\", \"posc_clk\",\n\t\t\t\"sosc_clk\", \"lprc_clk\", \"frcdiv_clk\",\n\t\t},\n\t\t.num_parents = 6,\n\t\t.ops = &pic32_sclk_ops,\n\t},\n\t.parent_map = (const u32[]) {\n\t\t0, 1, 2, 4, 5, 7,\n\t},\n};\n\nstatic const struct pic32_sys_pll_data sys_pll = {\n\t.ctrl_reg = 0x020,\n\t.status_reg = 0x1d0,\n\t.lock_mask = BIT(7),\n\t.init_data = {\n\t\t.name = \"sys_pll\",\n\t\t.parent_names = (const char *[]) {\n\t\t\t\"spll_mux_clk\"\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &pic32_spll_ops,\n\t},\n};\n\nstatic const struct pic32_sec_osc_data sosc_clk = {\n\t.status_reg = 0x1d0,\n\t.enable_mask = BIT(1),\n\t.status_mask = BIT(4),\n\t.fixed_rate = 32768,\n\t.init_data = {\n\t\t.name = \"sosc_clk\",\n\t\t.parent_names = NULL,\n\t\t.ops = &pic32_sosc_ops,\n\t},\n};\n\nstatic int pic32mzda_critical_clks[] = {\n\tPB2CLK, PB7CLK\n};\n\n \nstruct pic32mzda_clk_data {\n\tstruct clk *clks[MAXCLKS];\n\tstruct pic32_clk_common core;\n\tstruct clk_onecell_data onecell_data;\n\tstruct notifier_block failsafe_notifier;\n};\n\nstatic int pic32_fscm_nmi(struct notifier_block *nb,\n\t\t\t  unsigned long action, void *data)\n{\n\tstruct pic32mzda_clk_data *cd;\n\n\tcd  = container_of(nb, struct pic32mzda_clk_data, failsafe_notifier);\n\n\t \n\tif (readl(cd->core.iobase) & BIT(2))\n\t\tpr_alert(\"pic32-clk: FSCM detected clk failure.\\n\");\n\n\t \n\n\treturn NOTIFY_OK;\n}\n\nstatic int pic32mzda_clk_probe(struct platform_device *pdev)\n{\n\tconst char *const pll_mux_parents[] = {\"posc_clk\", \"frc_clk\"};\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct pic32mzda_clk_data *cd;\n\tstruct pic32_clk_common *core;\n\tstruct clk *pll_mux_clk, *clk;\n\tstruct clk **clks;\n\tint nr_clks, i, ret;\n\n\tcd = devm_kzalloc(&pdev->dev, sizeof(*cd), GFP_KERNEL);\n\tif (!cd)\n\t\treturn -ENOMEM;\n\n\tcore = &cd->core;\n\tcore->iobase = of_io_request_and_map(np, 0, of_node_full_name(np));\n\tif (IS_ERR(core->iobase)) {\n\t\tdev_err(&pdev->dev, \"pic32-clk: failed to map registers\\n\");\n\t\treturn PTR_ERR(core->iobase);\n\t}\n\n\tspin_lock_init(&core->reg_lock);\n\tcore->dev = &pdev->dev;\n\tclks = &cd->clks[0];\n\n\t \n\tclks[POSCCLK] = clk_register_fixed_rate(&pdev->dev, \"posc_clk\", NULL,\n\t\t\t\t\t\t0, 24000000);\n\tclks[FRCCLK] =  clk_register_fixed_rate(&pdev->dev, \"frc_clk\", NULL,\n\t\t\t\t\t\t0, 8000000);\n\tclks[BFRCCLK] = clk_register_fixed_rate(&pdev->dev, \"bfrc_clk\", NULL,\n\t\t\t\t\t\t0, 8000000);\n\tclks[LPRCCLK] = clk_register_fixed_rate(&pdev->dev, \"lprc_clk\", NULL,\n\t\t\t\t\t\t0, 32000);\n\tclks[UPLLCLK] = clk_register_fixed_rate(&pdev->dev, \"usbphy_clk\", NULL,\n\t\t\t\t\t\t0, 24000000);\n\t \n\tif (of_property_read_bool(np, \"microchip,pic32mzda-sosc\")) {\n\t\tpr_info(\"pic32-clk: dt requests SOSC.\\n\");\n\t\tclks[SOSCCLK] = pic32_sosc_clk_register(&sosc_clk, core);\n\t}\n\t \n\tclks[FRCDIVCLK] = clk_register_divider(&pdev->dev, \"frcdiv_clk\",\n\t\t\t\t\t       \"frc_clk\", 0,\n\t\t\t\t\t       core->iobase,\n\t\t\t\t\t       OSC_FRCDIV_SHIFT,\n\t\t\t\t\t       OSC_FRCDIV_MASK,\n\t\t\t\t\t       CLK_DIVIDER_POWER_OF_TWO,\n\t\t\t\t\t       &core->reg_lock);\n\t \n\tpll_mux_clk = clk_register_mux(&pdev->dev, \"spll_mux_clk\",\n\t\t\t\t       pll_mux_parents, 2, 0,\n\t\t\t\t       core->iobase + 0x020,\n\t\t\t\t       PLL_ICLK_SHIFT, 1, 0, &core->reg_lock);\n\tif (IS_ERR(pll_mux_clk))\n\t\tpr_err(\"spll_mux_clk: clk register failed\\n\");\n\n\t \n\tclks[PLLCLK] = pic32_spll_clk_register(&sys_pll, core);\n\t \n\tclks[SCLK] = pic32_sys_clk_register(&sys_mux_clk, core);\n\t \n\tfor (nr_clks = PB1CLK, i = 0; nr_clks <= PB7CLK; i++, nr_clks++)\n\t\tclks[nr_clks] = pic32_periph_clk_register(&periph_clocks[i],\n\t\t\t\t\t\t\t  core);\n\t \n\tfor (nr_clks = REF1CLK, i = 0; nr_clks <= REF5CLK; i++, nr_clks++)\n\t\tclks[nr_clks] = pic32_refo_clk_register(&ref_clks[i], core);\n\n\t \n\tfor (i = 0; i < MAXCLKS; i++) {\n\t\tif (IS_ERR(clks[i]))\n\t\t\tcontinue;\n\t\tclk_register_clkdev(clks[i], NULL, __clk_get_name(clks[i]));\n\t}\n\n\t \n\tcd->onecell_data.clks = clks;\n\tcd->onecell_data.clk_num = MAXCLKS;\n\tret = of_clk_add_provider(np, of_clk_src_onecell_get,\n\t\t\t\t  &cd->onecell_data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pic32mzda_critical_clks); i++) {\n\t\tclk = clks[pic32mzda_critical_clks[i]];\n\t\tif (clk_prepare_enable(clk))\n\t\t\tdev_err(&pdev->dev, \"clk_prepare_enable(%s) failed\\n\",\n\t\t\t\t__clk_get_name(clk));\n\t}\n\n\t \n\tcd->failsafe_notifier.notifier_call = pic32_fscm_nmi;\n\treturn register_nmi_notifier(&cd->failsafe_notifier);\n}\n\nstatic const struct of_device_id pic32mzda_clk_match_table[] = {\n\t{ .compatible = \"microchip,pic32mzda-clk\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pic32mzda_clk_match_table);\n\nstatic struct platform_driver pic32mzda_clk_driver = {\n\t.probe\t\t= pic32mzda_clk_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"clk-pic32mzda\",\n\t\t.of_match_table = pic32mzda_clk_match_table,\n\t},\n};\n\nstatic int __init microchip_pic32mzda_clk_init(void)\n{\n\treturn platform_driver_register(&pic32mzda_clk_driver);\n}\ncore_initcall(microchip_pic32mzda_clk_init);\n\nMODULE_DESCRIPTION(\"Microchip PIC32MZDA Clock Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:clk-pic32mzda\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}