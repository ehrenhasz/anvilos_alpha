{
  "module_name": "clk-core.c",
  "hash_id": "86fcf9d7863317e4c04a90cefcda7c80953f081d09fdce64bb369571cb76ce8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/microchip/clk-core.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <asm/mach-pic32/pic32.h>\n#include <asm/traps.h>\n\n#include \"clk-core.h\"\n\n \n#define OSC_CUR_MASK\t\t0x07\n#define OSC_CUR_SHIFT\t\t12\n#define OSC_NEW_MASK\t\t0x07\n#define OSC_NEW_SHIFT\t\t8\n#define OSC_SWEN\t\tBIT(0)\n\n \n#define PLL_RANGE_MASK\t\t0x07\n#define PLL_RANGE_SHIFT\t\t0\n#define PLL_ICLK_MASK\t\t0x01\n#define PLL_ICLK_SHIFT\t\t7\n#define PLL_IDIV_MASK\t\t0x07\n#define PLL_IDIV_SHIFT\t\t8\n#define PLL_ODIV_MASK\t\t0x07\n#define PLL_ODIV_SHIFT\t\t24\n#define PLL_MULT_MASK\t\t0x7F\n#define PLL_MULT_SHIFT\t\t16\n#define PLL_MULT_MAX\t\t128\n#define PLL_ODIV_MIN\t\t1\n#define PLL_ODIV_MAX\t\t5\n\n \n#define PB_DIV_MASK\t\t0x7f\n#define PB_DIV_SHIFT\t\t0\n#define PB_DIV_READY\t\tBIT(11)\n#define PB_DIV_ENABLE\t\tBIT(15)\n#define PB_DIV_MAX\t\t128\n#define PB_DIV_MIN\t\t0\n\n \n#define REFO_SEL_MASK\t\t0x0f\n#define REFO_SEL_SHIFT\t\t0\n#define REFO_ACTIVE\t\tBIT(8)\n#define REFO_DIVSW_EN\t\tBIT(9)\n#define REFO_OE\t\t\tBIT(12)\n#define REFO_ON\t\t\tBIT(15)\n#define REFO_DIV_SHIFT\t\t16\n#define REFO_DIV_MASK\t\t0x7fff\n\n \n#define REFO_TRIM_REG\t\t0x10\n#define REFO_TRIM_MASK\t\t0x1ff\n#define REFO_TRIM_SHIFT\t\t23\n#define REFO_TRIM_MAX\t\t511\n\n \n#define SLEW_BUSY\t\tBIT(0)\n#define SLEW_DOWNEN\t\tBIT(1)\n#define SLEW_UPEN\t\tBIT(2)\n#define SLEW_DIV\t\t0x07\n#define SLEW_DIV_SHIFT\t\t8\n#define SLEW_SYSDIV\t\t0x0f\n#define SLEW_SYSDIV_SHIFT\t20\n\n \n#define LOCK_TIMEOUT_US         USEC_PER_MSEC\n\n \nstatic struct clk_hw *pic32_sclk_hw;\n\n \n#define cpu_nop5()\t\t\t\\\ndo {\t\t\t\t\t\\\n\t__asm__ __volatile__(\"nop\");\t\\\n\t__asm__ __volatile__(\"nop\");\t\\\n\t__asm__ __volatile__(\"nop\");\t\\\n\t__asm__ __volatile__(\"nop\");\t\\\n\t__asm__ __volatile__(\"nop\");\t\\\n} while (0)\n\n \nstruct pic32_periph_clk {\n\tstruct clk_hw hw;\n\tvoid __iomem *ctrl_reg;\n\tstruct pic32_clk_common *core;\n};\n\n#define clkhw_to_pbclk(_hw)\tcontainer_of(_hw, struct pic32_periph_clk, hw)\n\nstatic int pbclk_is_enabled(struct clk_hw *hw)\n{\n\tstruct pic32_periph_clk *pb = clkhw_to_pbclk(hw);\n\n\treturn readl(pb->ctrl_reg) & PB_DIV_ENABLE;\n}\n\nstatic int pbclk_enable(struct clk_hw *hw)\n{\n\tstruct pic32_periph_clk *pb = clkhw_to_pbclk(hw);\n\n\twritel(PB_DIV_ENABLE, PIC32_SET(pb->ctrl_reg));\n\treturn 0;\n}\n\nstatic void pbclk_disable(struct clk_hw *hw)\n{\n\tstruct pic32_periph_clk *pb = clkhw_to_pbclk(hw);\n\n\twritel(PB_DIV_ENABLE, PIC32_CLR(pb->ctrl_reg));\n}\n\nstatic unsigned long calc_best_divided_rate(unsigned long rate,\n\t\t\t\t\t    unsigned long parent_rate,\n\t\t\t\t\t    u32 divider_max,\n\t\t\t\t\t    u32 divider_min)\n{\n\tunsigned long divided_rate, divided_rate_down, best_rate;\n\tunsigned long div, div_up;\n\n\t \n\tdiv = parent_rate / rate;\n\tdiv = clamp_val(div, divider_min, divider_max);\n\tdiv_up = clamp_val(div + 1, divider_min, divider_max);\n\n\tdivided_rate = parent_rate / div;\n\tdivided_rate_down = parent_rate / div_up;\n\tif (abs(rate - divided_rate_down) < abs(rate - divided_rate))\n\t\tbest_rate = divided_rate_down;\n\telse\n\t\tbest_rate = divided_rate;\n\n\treturn best_rate;\n}\n\nstatic inline u32 pbclk_read_pbdiv(struct pic32_periph_clk *pb)\n{\n\treturn ((readl(pb->ctrl_reg) >> PB_DIV_SHIFT) & PB_DIV_MASK) + 1;\n}\n\nstatic unsigned long pbclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct pic32_periph_clk *pb = clkhw_to_pbclk(hw);\n\n\treturn parent_rate / pbclk_read_pbdiv(pb);\n}\n\nstatic long pbclk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t     unsigned long *parent_rate)\n{\n\treturn calc_best_divided_rate(rate, *parent_rate,\n\t\t\t\t      PB_DIV_MAX, PB_DIV_MIN);\n}\n\nstatic int pbclk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t  unsigned long parent_rate)\n{\n\tstruct pic32_periph_clk *pb = clkhw_to_pbclk(hw);\n\tunsigned long flags;\n\tu32 v, div;\n\tint err;\n\n\t \n\terr = readl_poll_timeout(pb->ctrl_reg, v, v & PB_DIV_READY,\n\t\t\t\t 1, LOCK_TIMEOUT_US);\n\tif (err)\n\t\treturn err;\n\n\t \n\tdiv = DIV_ROUND_CLOSEST(parent_rate, rate);\n\n\tspin_lock_irqsave(&pb->core->reg_lock, flags);\n\n\t \n\tv = readl(pb->ctrl_reg);\n\tv &= ~PB_DIV_MASK;\n\tv |= (div - 1);\n\n\tpic32_syskey_unlock();\n\n\twritel(v, pb->ctrl_reg);\n\n\tspin_unlock_irqrestore(&pb->core->reg_lock, flags);\n\n\t \n\terr = readl_poll_timeout(pb->ctrl_reg, v, v & PB_DIV_READY,\n\t\t\t\t 1, LOCK_TIMEOUT_US);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn (pbclk_read_pbdiv(pb) == div) ? 0 : -EBUSY;\n}\n\nconst struct clk_ops pic32_pbclk_ops = {\n\t.enable\t\t= pbclk_enable,\n\t.disable\t= pbclk_disable,\n\t.is_enabled\t= pbclk_is_enabled,\n\t.recalc_rate\t= pbclk_recalc_rate,\n\t.round_rate\t= pbclk_round_rate,\n\t.set_rate\t= pbclk_set_rate,\n};\n\nstruct clk *pic32_periph_clk_register(const struct pic32_periph_clk_data *desc,\n\t\t\t\t      struct pic32_clk_common *core)\n{\n\tstruct pic32_periph_clk *pbclk;\n\tstruct clk *clk;\n\n\tpbclk = devm_kzalloc(core->dev, sizeof(*pbclk), GFP_KERNEL);\n\tif (!pbclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpbclk->hw.init = &desc->init_data;\n\tpbclk->core = core;\n\tpbclk->ctrl_reg = desc->ctrl_reg + core->iobase;\n\n\tclk = devm_clk_register(core->dev, &pbclk->hw);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(core->dev, \"%s: clk_register() failed\\n\", __func__);\n\t\tdevm_kfree(core->dev, pbclk);\n\t}\n\n\treturn clk;\n}\n\n \nstruct pic32_ref_osc {\n\tstruct clk_hw hw;\n\tvoid __iomem *ctrl_reg;\n\tconst u32 *parent_map;\n\tstruct pic32_clk_common *core;\n};\n\n#define clkhw_to_refosc(_hw)\tcontainer_of(_hw, struct pic32_ref_osc, hw)\n\nstatic int roclk_is_enabled(struct clk_hw *hw)\n{\n\tstruct pic32_ref_osc *refo = clkhw_to_refosc(hw);\n\n\treturn readl(refo->ctrl_reg) & REFO_ON;\n}\n\nstatic int roclk_enable(struct clk_hw *hw)\n{\n\tstruct pic32_ref_osc *refo = clkhw_to_refosc(hw);\n\n\twritel(REFO_ON | REFO_OE, PIC32_SET(refo->ctrl_reg));\n\treturn 0;\n}\n\nstatic void roclk_disable(struct clk_hw *hw)\n{\n\tstruct pic32_ref_osc *refo = clkhw_to_refosc(hw);\n\n\twritel(REFO_ON | REFO_OE, PIC32_CLR(refo->ctrl_reg));\n}\n\nstatic int roclk_init(struct clk_hw *hw)\n{\n\t \n\troclk_disable(hw);\n\n\treturn 0;\n}\n\nstatic u8 roclk_get_parent(struct clk_hw *hw)\n{\n\tstruct pic32_ref_osc *refo = clkhw_to_refosc(hw);\n\tu32 v, i;\n\n\tv = (readl(refo->ctrl_reg) >> REFO_SEL_SHIFT) & REFO_SEL_MASK;\n\n\tif (!refo->parent_map)\n\t\treturn v;\n\n\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++)\n\t\tif (refo->parent_map[i] == v)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic unsigned long roclk_calc_rate(unsigned long parent_rate,\n\t\t\t\t     u32 rodiv, u32 rotrim)\n{\n\tu64 rate64;\n\n\t \n\tif (rotrim) {\n\t\trodiv = (rodiv << 9) + rotrim;\n\t\trate64 = parent_rate;\n\t\trate64 <<= 8;\n\t\tdo_div(rate64, rodiv);\n\t} else if (rodiv) {\n\t\trate64 = parent_rate / (rodiv << 1);\n\t} else {\n\t\trate64 = parent_rate;\n\t}\n\treturn rate64;\n}\n\nstatic void roclk_calc_div_trim(unsigned long rate,\n\t\t\t\tunsigned long parent_rate,\n\t\t\t\tu32 *rodiv_p, u32 *rotrim_p)\n{\n\tu32 div, rotrim, rodiv;\n\tu64 frac;\n\n\t \n\tif (parent_rate <= rate) {\n\t\tdiv = 0;\n\t\tfrac = 0;\n\t\trodiv = 0;\n\t\trotrim = 0;\n\t} else {\n\t\tdiv = parent_rate / (rate << 1);\n\t\tfrac = parent_rate;\n\t\tfrac <<= 8;\n\t\tdo_div(frac, rate);\n\t\tfrac -= (u64)(div << 9);\n\n\t\trodiv = (div > REFO_DIV_MASK) ? REFO_DIV_MASK : div;\n\t\trotrim = (frac >= REFO_TRIM_MAX) ? REFO_TRIM_MAX : frac;\n\t}\n\n\tif (rodiv_p)\n\t\t*rodiv_p = rodiv;\n\n\tif (rotrim_p)\n\t\t*rotrim_p = rotrim;\n}\n\nstatic unsigned long roclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct pic32_ref_osc *refo = clkhw_to_refosc(hw);\n\tu32 v, rodiv, rotrim;\n\n\t \n\tv = readl(refo->ctrl_reg);\n\trodiv = (v >> REFO_DIV_SHIFT) & REFO_DIV_MASK;\n\n\t \n\tv = readl(refo->ctrl_reg + REFO_TRIM_REG);\n\trotrim = (v >> REFO_TRIM_SHIFT) & REFO_TRIM_MASK;\n\n\treturn roclk_calc_rate(parent_rate, rodiv, rotrim);\n}\n\nstatic long roclk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t     unsigned long *parent_rate)\n{\n\tu32 rotrim, rodiv;\n\n\t \n\troclk_calc_div_trim(rate, *parent_rate, &rodiv, &rotrim);\n\n\t \n\treturn roclk_calc_rate(*parent_rate, rodiv, rotrim);\n}\n\nstatic int roclk_determine_rate(struct clk_hw *hw,\n\t\t\t\tstruct clk_rate_request *req)\n{\n\tstruct clk_hw *parent_clk, *best_parent_clk = NULL;\n\tunsigned int i, delta, best_delta = -1;\n\tunsigned long parent_rate, best_parent_rate = 0;\n\tunsigned long best = 0, nearest_rate;\n\n\t \n\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\n\t\t \n\t\tparent_clk = clk_hw_get_parent_by_index(hw, i);\n\t\tif (!parent_clk)\n\t\t\tcontinue;\n\n\t\t \n\t\tparent_rate = clk_hw_get_rate(parent_clk);\n\t\tif (req->rate > parent_rate)\n\t\t\tcontinue;\n\n\t\tnearest_rate = roclk_round_rate(hw, req->rate, &parent_rate);\n\t\tdelta = abs(nearest_rate - req->rate);\n\t\tif ((nearest_rate >= req->rate) && (delta < best_delta)) {\n\t\t\tbest_parent_clk = parent_clk;\n\t\t\tbest_parent_rate = parent_rate;\n\t\t\tbest = nearest_rate;\n\t\t\tbest_delta = delta;\n\n\t\t\tif (delta == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!best_parent_clk) {\n\t\tpr_err(\"%s:%s, no parent found for rate %lu.\\n\",\n\t\t       __func__, clk_hw_get_name(hw), req->rate);\n\t\treturn clk_hw_get_rate(hw);\n\t}\n\n\tpr_debug(\"%s,rate %lu, best_parent(%s, %lu), best %lu, delta %d\\n\",\n\t\t clk_hw_get_name(hw), req->rate,\n\t\t clk_hw_get_name(best_parent_clk), best_parent_rate,\n\t\t best, best_delta);\n\n\tif (req->best_parent_rate)\n\t\treq->best_parent_rate = best_parent_rate;\n\n\tif (req->best_parent_hw)\n\t\treq->best_parent_hw = best_parent_clk;\n\n\treturn best;\n}\n\nstatic int roclk_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct pic32_ref_osc *refo = clkhw_to_refosc(hw);\n\tunsigned long flags;\n\tu32 v;\n\tint err;\n\n\tif (refo->parent_map)\n\t\tindex = refo->parent_map[index];\n\n\t \n\terr = readl_poll_timeout(refo->ctrl_reg, v, !(v & REFO_ACTIVE),\n\t\t\t\t 1, LOCK_TIMEOUT_US);\n\tif (err) {\n\t\tpr_err(\"%s: poll failed, clk active\\n\", clk_hw_get_name(hw));\n\t\treturn err;\n\t}\n\n\tspin_lock_irqsave(&refo->core->reg_lock, flags);\n\n\tpic32_syskey_unlock();\n\n\t \n\tv = readl(refo->ctrl_reg);\n\tv &= ~(REFO_SEL_MASK << REFO_SEL_SHIFT);\n\tv |= index << REFO_SEL_SHIFT;\n\n\twritel(v, refo->ctrl_reg);\n\n\tspin_unlock_irqrestore(&refo->core->reg_lock, flags);\n\n\treturn 0;\n}\n\nstatic int roclk_set_rate_and_parent(struct clk_hw *hw,\n\t\t\t\t     unsigned long rate,\n\t\t\t\t     unsigned long parent_rate,\n\t\t\t\t     u8 index)\n{\n\tstruct pic32_ref_osc *refo = clkhw_to_refosc(hw);\n\tunsigned long flags;\n\tu32 trim, rodiv, v;\n\tint err;\n\n\t \n\troclk_calc_div_trim(rate, parent_rate, &rodiv, &trim);\n\n\tpr_debug(\"parent_rate = %lu, rate = %lu, div = %d, trim = %d\\n\",\n\t\t parent_rate, rate, rodiv, trim);\n\n\t \n\terr = readl_poll_timeout(refo->ctrl_reg, v,\n\t\t\t\t !(v & (REFO_ACTIVE | REFO_DIVSW_EN)),\n\t\t\t\t 1, LOCK_TIMEOUT_US);\n\tif (err) {\n\t\tpr_err(\"%s: poll timedout, clock is still active\\n\", __func__);\n\t\treturn err;\n\t}\n\n\tspin_lock_irqsave(&refo->core->reg_lock, flags);\n\tv = readl(refo->ctrl_reg);\n\n\tpic32_syskey_unlock();\n\n\t \n\tif (refo->parent_map)\n\t\tindex = refo->parent_map[index];\n\n\tv &= ~(REFO_SEL_MASK << REFO_SEL_SHIFT);\n\tv |= index << REFO_SEL_SHIFT;\n\n\t \n\tv &= ~(REFO_DIV_MASK << REFO_DIV_SHIFT);\n\tv |= rodiv << REFO_DIV_SHIFT;\n\twritel(v, refo->ctrl_reg);\n\n\t \n\tv = readl(refo->ctrl_reg + REFO_TRIM_REG);\n\tv &= ~(REFO_TRIM_MASK << REFO_TRIM_SHIFT);\n\tv |= trim << REFO_TRIM_SHIFT;\n\twritel(v, refo->ctrl_reg + REFO_TRIM_REG);\n\n\t \n\twritel(REFO_ON | REFO_DIVSW_EN, PIC32_SET(refo->ctrl_reg));\n\n\t \n\terr = readl_poll_timeout_atomic(refo->ctrl_reg, v, !(v & REFO_DIVSW_EN),\n\t\t\t\t\t1, LOCK_TIMEOUT_US);\n\t \n\twritel(REFO_ON, PIC32_CLR(refo->ctrl_reg));\n\n\tspin_unlock_irqrestore(&refo->core->reg_lock, flags);\n\n\treturn err;\n}\n\nstatic int roclk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t  unsigned long parent_rate)\n{\n\tu8 index = roclk_get_parent(hw);\n\n\treturn roclk_set_rate_and_parent(hw, rate, parent_rate, index);\n}\n\nconst struct clk_ops pic32_roclk_ops = {\n\t.enable\t\t\t= roclk_enable,\n\t.disable\t\t= roclk_disable,\n\t.is_enabled\t\t= roclk_is_enabled,\n\t.get_parent\t\t= roclk_get_parent,\n\t.set_parent\t\t= roclk_set_parent,\n\t.determine_rate\t\t= roclk_determine_rate,\n\t.recalc_rate\t\t= roclk_recalc_rate,\n\t.set_rate_and_parent\t= roclk_set_rate_and_parent,\n\t.set_rate\t\t= roclk_set_rate,\n\t.init\t\t\t= roclk_init,\n};\n\nstruct clk *pic32_refo_clk_register(const struct pic32_ref_osc_data *data,\n\t\t\t\t    struct pic32_clk_common *core)\n{\n\tstruct pic32_ref_osc *refo;\n\tstruct clk *clk;\n\n\trefo = devm_kzalloc(core->dev, sizeof(*refo), GFP_KERNEL);\n\tif (!refo)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trefo->core = core;\n\trefo->hw.init = &data->init_data;\n\trefo->ctrl_reg = data->ctrl_reg + core->iobase;\n\trefo->parent_map = data->parent_map;\n\n\tclk = devm_clk_register(core->dev, &refo->hw);\n\tif (IS_ERR(clk))\n\t\tdev_err(core->dev, \"%s: clk_register() failed\\n\", __func__);\n\n\treturn clk;\n}\n\nstruct pic32_sys_pll {\n\tstruct clk_hw hw;\n\tvoid __iomem *ctrl_reg;\n\tvoid __iomem *status_reg;\n\tu32 lock_mask;\n\tu32 idiv;  \n\tstruct pic32_clk_common *core;\n};\n\n#define clkhw_to_spll(_hw)\tcontainer_of(_hw, struct pic32_sys_pll, hw)\n\nstatic inline u32 spll_odiv_to_divider(u32 odiv)\n{\n\todiv = clamp_val(odiv, PLL_ODIV_MIN, PLL_ODIV_MAX);\n\n\treturn 1 << odiv;\n}\n\nstatic unsigned long spll_calc_mult_div(struct pic32_sys_pll *pll,\n\t\t\t\t\tunsigned long rate,\n\t\t\t\t\tunsigned long parent_rate,\n\t\t\t\t\tu32 *mult_p, u32 *odiv_p)\n{\n\tu32 mul, div, best_mul = 1, best_div = 1;\n\tunsigned long new_rate, best_rate = rate;\n\tunsigned int best_delta = -1, delta, match_found = 0;\n\tu64 rate64;\n\n\tparent_rate /= pll->idiv;\n\n\tfor (mul = 1; mul <= PLL_MULT_MAX; mul++) {\n\t\tfor (div = PLL_ODIV_MIN; div <= PLL_ODIV_MAX; div++) {\n\t\t\trate64 = parent_rate;\n\t\t\trate64 *= mul;\n\t\t\tdo_div(rate64, 1 << div);\n\t\t\tnew_rate = rate64;\n\t\t\tdelta = abs(rate - new_rate);\n\t\t\tif ((new_rate >= rate) && (delta < best_delta)) {\n\t\t\t\tbest_delta = delta;\n\t\t\t\tbest_rate = new_rate;\n\t\t\t\tbest_mul = mul;\n\t\t\t\tbest_div = div;\n\t\t\t\tmatch_found = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!match_found) {\n\t\tpr_warn(\"spll: no match found\\n\");\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"rate %lu, par_rate %lu/mult %u, div %u, best_rate %lu\\n\",\n\t\t rate, parent_rate, best_mul, best_div, best_rate);\n\n\tif (mult_p)\n\t\t*mult_p = best_mul - 1;\n\n\tif (odiv_p)\n\t\t*odiv_p = best_div;\n\n\treturn best_rate;\n}\n\nstatic unsigned long spll_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct pic32_sys_pll *pll = clkhw_to_spll(hw);\n\tunsigned long pll_in_rate;\n\tu32 mult, odiv, div, v;\n\tu64 rate64;\n\n\tv = readl(pll->ctrl_reg);\n\todiv = ((v >> PLL_ODIV_SHIFT) & PLL_ODIV_MASK);\n\tmult = ((v >> PLL_MULT_SHIFT) & PLL_MULT_MASK) + 1;\n\tdiv = spll_odiv_to_divider(odiv);\n\n\t \n\tpll_in_rate = parent_rate / pll->idiv;\n\trate64 = pll_in_rate;\n\trate64 *= mult;\n\tdo_div(rate64, div);\n\n\treturn rate64;\n}\n\nstatic long spll_clk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *parent_rate)\n{\n\tstruct pic32_sys_pll *pll = clkhw_to_spll(hw);\n\n\treturn spll_calc_mult_div(pll, rate, *parent_rate, NULL, NULL);\n}\n\nstatic int spll_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t     unsigned long parent_rate)\n{\n\tstruct pic32_sys_pll *pll = clkhw_to_spll(hw);\n\tunsigned long ret, flags;\n\tu32 mult, odiv, v;\n\tint err;\n\n\tret = spll_calc_mult_div(pll, rate, parent_rate, &mult, &odiv);\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\t \n\n\t \n\tif (unlikely(clk_hw_get_parent(pic32_sclk_hw) == hw)) {\n\t\tpr_err(\"%s: failed, clk in-use\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tspin_lock_irqsave(&pll->core->reg_lock, flags);\n\n\t \n\tv = readl(pll->ctrl_reg);\n\tv &= ~(PLL_MULT_MASK << PLL_MULT_SHIFT);\n\tv &= ~(PLL_ODIV_MASK << PLL_ODIV_SHIFT);\n\tv |= (mult << PLL_MULT_SHIFT) | (odiv << PLL_ODIV_SHIFT);\n\n\t \n\tpic32_syskey_unlock();\n\n\twritel(v, pll->ctrl_reg);\n\tcpu_relax();\n\n\t \n\tcpu_nop5();\n\tcpu_nop5();\n\n\t \n\terr = readl_poll_timeout_atomic(pll->status_reg, v,\n\t\t\t\t\tv & pll->lock_mask, 1, 100);\n\tspin_unlock_irqrestore(&pll->core->reg_lock, flags);\n\n\treturn err;\n}\n\n \nconst struct clk_ops pic32_spll_ops = {\n\t.recalc_rate\t= spll_clk_recalc_rate,\n\t.round_rate\t= spll_clk_round_rate,\n\t.set_rate\t= spll_clk_set_rate,\n};\n\nstruct clk *pic32_spll_clk_register(const struct pic32_sys_pll_data *data,\n\t\t\t\t    struct pic32_clk_common *core)\n{\n\tstruct pic32_sys_pll *spll;\n\tstruct clk *clk;\n\n\tspll = devm_kzalloc(core->dev, sizeof(*spll), GFP_KERNEL);\n\tif (!spll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspll->core = core;\n\tspll->hw.init = &data->init_data;\n\tspll->ctrl_reg = data->ctrl_reg + core->iobase;\n\tspll->status_reg = data->status_reg + core->iobase;\n\tspll->lock_mask = data->lock_mask;\n\n\t \n\tspll->idiv = (readl(spll->ctrl_reg) >> PLL_IDIV_SHIFT) & PLL_IDIV_MASK;\n\tspll->idiv += 1;\n\n\tclk = devm_clk_register(core->dev, &spll->hw);\n\tif (IS_ERR(clk))\n\t\tdev_err(core->dev, \"sys_pll: clk_register() failed\\n\");\n\n\treturn clk;\n}\n\n \n\nstruct pic32_sys_clk {\n\tstruct clk_hw hw;\n\tvoid __iomem *mux_reg;\n\tvoid __iomem *slew_reg;\n\tu32 slew_div;\n\tconst u32 *parent_map;\n\tstruct pic32_clk_common *core;\n};\n\n#define clkhw_to_sys_clk(_hw)\tcontainer_of(_hw, struct pic32_sys_clk, hw)\n\nstatic unsigned long sclk_get_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct pic32_sys_clk *sclk = clkhw_to_sys_clk(hw);\n\tu32 div;\n\n\tdiv = (readl(sclk->slew_reg) >> SLEW_SYSDIV_SHIFT) & SLEW_SYSDIV;\n\tdiv += 1;  \n\n\treturn parent_rate / div;\n}\n\nstatic long sclk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long *parent_rate)\n{\n\treturn calc_best_divided_rate(rate, *parent_rate, SLEW_SYSDIV, 1);\n}\n\nstatic int sclk_set_rate(struct clk_hw *hw,\n\t\t\t unsigned long rate, unsigned long parent_rate)\n{\n\tstruct pic32_sys_clk *sclk = clkhw_to_sys_clk(hw);\n\tunsigned long flags;\n\tu32 v, div;\n\tint err;\n\n\tdiv = parent_rate / rate;\n\n\tspin_lock_irqsave(&sclk->core->reg_lock, flags);\n\n\t \n\tv = readl(sclk->slew_reg);\n\tv &= ~(SLEW_SYSDIV << SLEW_SYSDIV_SHIFT);\n\tv |= (div - 1) << SLEW_SYSDIV_SHIFT;\n\n\tpic32_syskey_unlock();\n\n\twritel(v, sclk->slew_reg);\n\n\t \n\terr = readl_poll_timeout_atomic(sclk->slew_reg, v,\n\t\t\t\t\t!(v & SLEW_BUSY), 1, LOCK_TIMEOUT_US);\n\n\tspin_unlock_irqrestore(&sclk->core->reg_lock, flags);\n\n\treturn err;\n}\n\nstatic u8 sclk_get_parent(struct clk_hw *hw)\n{\n\tstruct pic32_sys_clk *sclk = clkhw_to_sys_clk(hw);\n\tu32 i, v;\n\n\tv = (readl(sclk->mux_reg) >> OSC_CUR_SHIFT) & OSC_CUR_MASK;\n\n\tif (!sclk->parent_map)\n\t\treturn v;\n\n\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++)\n\t\tif (sclk->parent_map[i] == v)\n\t\t\treturn i;\n\treturn -EINVAL;\n}\n\nstatic int sclk_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct pic32_sys_clk *sclk = clkhw_to_sys_clk(hw);\n\tunsigned long flags;\n\tu32 nosc, cosc, v;\n\tint err;\n\n\tspin_lock_irqsave(&sclk->core->reg_lock, flags);\n\n\t \n\tnosc = sclk->parent_map ? sclk->parent_map[index] : index;\n\n\t \n\tv = readl(sclk->mux_reg);\n\tv &= ~(OSC_NEW_MASK << OSC_NEW_SHIFT);\n\tv |= nosc << OSC_NEW_SHIFT;\n\n\tpic32_syskey_unlock();\n\n\twritel(v, sclk->mux_reg);\n\n\t \n\twritel(OSC_SWEN, PIC32_SET(sclk->mux_reg));\n\tcpu_relax();\n\n\t \n\tcpu_nop5();\n\n\t \n\terr = readl_poll_timeout_atomic(sclk->slew_reg, v,\n\t\t\t\t\t!(v & OSC_SWEN), 1, LOCK_TIMEOUT_US);\n\n\tspin_unlock_irqrestore(&sclk->core->reg_lock, flags);\n\n\t \n\tcosc = (readl(sclk->mux_reg) >> OSC_CUR_SHIFT) & OSC_CUR_MASK;\n\tif (cosc != nosc) {\n\t\tpr_err(\"%s: err, failed to set_parent() to %d, current %d\\n\",\n\t\t       clk_hw_get_name(hw), nosc, cosc);\n\t\terr = -EBUSY;\n\t}\n\n\treturn err;\n}\n\nstatic int sclk_init(struct clk_hw *hw)\n{\n\tstruct pic32_sys_clk *sclk = clkhw_to_sys_clk(hw);\n\tunsigned long flags;\n\tu32 v;\n\n\t \n\tpic32_sclk_hw = hw;\n\n\t \n\tif (sclk->slew_div) {\n\t\tspin_lock_irqsave(&sclk->core->reg_lock, flags);\n\t\tv = readl(sclk->slew_reg);\n\t\tv &= ~(SLEW_DIV << SLEW_DIV_SHIFT);\n\t\tv |= sclk->slew_div << SLEW_DIV_SHIFT;\n\t\tv |= SLEW_DOWNEN | SLEW_UPEN;\n\t\twritel(v, sclk->slew_reg);\n\t\tspin_unlock_irqrestore(&sclk->core->reg_lock, flags);\n\t}\n\n\treturn 0;\n}\n\n \nconst struct clk_ops pic32_sclk_ops = {\n\t.get_parent\t= sclk_get_parent,\n\t.set_parent\t= sclk_set_parent,\n\t.round_rate\t= sclk_round_rate,\n\t.set_rate\t= sclk_set_rate,\n\t.recalc_rate\t= sclk_get_rate,\n\t.init\t\t= sclk_init,\n\t.determine_rate = __clk_mux_determine_rate,\n};\n\n \nconst struct clk_ops pic32_sclk_no_div_ops = {\n\t.get_parent\t= sclk_get_parent,\n\t.set_parent\t= sclk_set_parent,\n\t.init\t\t= sclk_init,\n\t.determine_rate = __clk_mux_determine_rate,\n};\n\nstruct clk *pic32_sys_clk_register(const struct pic32_sys_clk_data *data,\n\t\t\t\t   struct pic32_clk_common *core)\n{\n\tstruct pic32_sys_clk *sclk;\n\tstruct clk *clk;\n\n\tsclk = devm_kzalloc(core->dev, sizeof(*sclk), GFP_KERNEL);\n\tif (!sclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsclk->core = core;\n\tsclk->hw.init = &data->init_data;\n\tsclk->mux_reg = data->mux_reg + core->iobase;\n\tsclk->slew_reg = data->slew_reg + core->iobase;\n\tsclk->slew_div = data->slew_div;\n\tsclk->parent_map = data->parent_map;\n\n\tclk = devm_clk_register(core->dev, &sclk->hw);\n\tif (IS_ERR(clk))\n\t\tdev_err(core->dev, \"%s: clk register failed\\n\", __func__);\n\n\treturn clk;\n}\n\n \nstruct pic32_sec_osc {\n\tstruct clk_hw hw;\n\tvoid __iomem *enable_reg;\n\tvoid __iomem *status_reg;\n\tu32 enable_mask;\n\tu32 status_mask;\n\tunsigned long fixed_rate;\n\tstruct pic32_clk_common *core;\n};\n\n#define clkhw_to_sosc(_hw)\tcontainer_of(_hw, struct pic32_sec_osc, hw)\nstatic int sosc_clk_enable(struct clk_hw *hw)\n{\n\tstruct pic32_sec_osc *sosc = clkhw_to_sosc(hw);\n\tu32 v;\n\n\t \n\tpic32_syskey_unlock();\n\twritel(sosc->enable_mask, PIC32_SET(sosc->enable_reg));\n\n\t \n\treturn readl_poll_timeout_atomic(sosc->status_reg, v,\n\t\t\t\t\t v & sosc->status_mask, 1, 100);\n}\n\nstatic void sosc_clk_disable(struct clk_hw *hw)\n{\n\tstruct pic32_sec_osc *sosc = clkhw_to_sosc(hw);\n\n\tpic32_syskey_unlock();\n\twritel(sosc->enable_mask, PIC32_CLR(sosc->enable_reg));\n}\n\nstatic int sosc_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct pic32_sec_osc *sosc = clkhw_to_sosc(hw);\n\tu32 enabled, ready;\n\n\t \n\tenabled = readl(sosc->enable_reg) & sosc->enable_mask;\n\tready = readl(sosc->status_reg) & sosc->status_mask;\n\n\treturn enabled && ready;\n}\n\nstatic unsigned long sosc_clk_calc_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\treturn clkhw_to_sosc(hw)->fixed_rate;\n}\n\nconst struct clk_ops pic32_sosc_ops = {\n\t.enable = sosc_clk_enable,\n\t.disable = sosc_clk_disable,\n\t.is_enabled = sosc_clk_is_enabled,\n\t.recalc_rate = sosc_clk_calc_rate,\n};\n\nstruct clk *pic32_sosc_clk_register(const struct pic32_sec_osc_data *data,\n\t\t\t\t    struct pic32_clk_common *core)\n{\n\tstruct pic32_sec_osc *sosc;\n\n\tsosc = devm_kzalloc(core->dev, sizeof(*sosc), GFP_KERNEL);\n\tif (!sosc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsosc->core = core;\n\tsosc->hw.init = &data->init_data;\n\tsosc->fixed_rate = data->fixed_rate;\n\tsosc->enable_mask = data->enable_mask;\n\tsosc->status_mask = data->status_mask;\n\tsosc->enable_reg = data->enable_reg + core->iobase;\n\tsosc->status_reg = data->status_reg + core->iobase;\n\n\treturn devm_clk_register(core->dev, &sosc->hw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}