{
  "module_name": "clk-mpfs-ccc.c",
  "hash_id": "d42305cfb81717c79d2f8d87097f42f43df6593ade67ab959accf320126b08e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/microchip/clk-mpfs-ccc.c",
  "human_readable_source": "\n \n#include \"asm-generic/errno-base.h\"\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <dt-bindings/clock/microchip,mpfs-clock.h>\n\n \n#define MPFS_CCC_PLL_CR\t\t\t0x04u\n#define MPFS_CCC_REF_CR\t\t\t0x08u\n#define MPFS_CCC_SSCG_2_CR\t\t0x2Cu\n#define MPFS_CCC_POSTDIV01_CR\t\t0x10u\n#define MPFS_CCC_POSTDIV23_CR\t\t0x14u\n\n#define MPFS_CCC_FBDIV_SHIFT\t\t0x00u\n#define MPFS_CCC_FBDIV_WIDTH\t\t0x0Cu\n#define MPFS_CCC_POSTDIV0_SHIFT\t\t0x08u\n#define MPFS_CCC_POSTDIV1_SHIFT\t\t0x18u\n#define MPFS_CCC_POSTDIV2_SHIFT\t\tMPFS_CCC_POSTDIV0_SHIFT\n#define MPFS_CCC_POSTDIV3_SHIFT\t\tMPFS_CCC_POSTDIV1_SHIFT\n#define MPFS_CCC_POSTDIV_WIDTH\t\t0x06u\n#define MPFS_CCC_REFCLK_SEL\t\tBIT(6)\n#define MPFS_CCC_REFDIV_SHIFT\t\t0x08u\n#define MPFS_CCC_REFDIV_WIDTH\t\t0x06u\n\n#define MPFS_CCC_FIXED_DIV\t\t4\n#define MPFS_CCC_OUTPUTS_PER_PLL\t4\n#define MPFS_CCC_REFS_PER_PLL\t\t2\n\nstruct mpfs_ccc_data {\n\tvoid __iomem **pll_base;\n\tstruct device *dev;\n\tstruct clk_hw_onecell_data hw_data;\n};\n\nstruct mpfs_ccc_pll_hw_clock {\n\tvoid __iomem *base;\n\tconst char *name;\n\tconst struct clk_parent_data *parents;\n\tunsigned int id;\n\tu32 reg_offset;\n\tu32 shift;\n\tu32 width;\n\tu32 flags;\n\tstruct clk_hw hw;\n\tstruct clk_init_data init;\n};\n\n#define to_mpfs_ccc_clk(_hw) container_of(_hw, struct mpfs_ccc_pll_hw_clock, hw)\n\n \nstatic DEFINE_SPINLOCK(mpfs_ccc_lock);\n\nstatic const struct clk_parent_data mpfs_ccc_pll0_refs[] = {\n\t{ .fw_name = \"pll0_ref0\" },\n\t{ .fw_name = \"pll0_ref1\" },\n};\n\nstatic const struct clk_parent_data mpfs_ccc_pll1_refs[] = {\n\t{ .fw_name = \"pll1_ref0\" },\n\t{ .fw_name = \"pll1_ref1\" },\n};\n\nstatic unsigned long mpfs_ccc_pll_recalc_rate(struct clk_hw *hw, unsigned long prate)\n{\n\tstruct mpfs_ccc_pll_hw_clock *ccc_hw = to_mpfs_ccc_clk(hw);\n\tvoid __iomem *mult_addr = ccc_hw->base + ccc_hw->reg_offset;\n\tvoid __iomem *ref_div_addr = ccc_hw->base + MPFS_CCC_REF_CR;\n\tu32 mult, ref_div;\n\n\tmult = readl_relaxed(mult_addr) >> MPFS_CCC_FBDIV_SHIFT;\n\tmult &= clk_div_mask(MPFS_CCC_FBDIV_WIDTH);\n\tref_div = readl_relaxed(ref_div_addr) >> MPFS_CCC_REFDIV_SHIFT;\n\tref_div &= clk_div_mask(MPFS_CCC_REFDIV_WIDTH);\n\n\treturn prate * mult / (ref_div * MPFS_CCC_FIXED_DIV);\n}\n\nstatic u8 mpfs_ccc_pll_get_parent(struct clk_hw *hw)\n{\n\tstruct mpfs_ccc_pll_hw_clock *ccc_hw = to_mpfs_ccc_clk(hw);\n\tvoid __iomem *pll_cr_addr = ccc_hw->base + MPFS_CCC_PLL_CR;\n\n\treturn !!(readl_relaxed(pll_cr_addr) & MPFS_CCC_REFCLK_SEL);\n}\n\nstatic const struct clk_ops mpfs_ccc_pll_ops = {\n\t.recalc_rate = mpfs_ccc_pll_recalc_rate,\n\t.get_parent = mpfs_ccc_pll_get_parent,\n};\n\n#define CLK_CCC_PLL(_id, _parents, _shift, _width, _flags, _offset) {\t\\\n\t.id = _id,\t\t\t\t\t\t\t\\\n\t.shift = _shift,\t\t\t\t\t\t\\\n\t.width = _width,\t\t\t\t\t\t\\\n\t.reg_offset = _offset,\t\t\t\t\t\t\\\n\t.flags = _flags,\t\t\t\t\t\t\\\n\t.parents = _parents,\t\t\t\t\t\t\\\n}\n\nstatic struct mpfs_ccc_pll_hw_clock mpfs_ccc_pll_clks[] = {\n\tCLK_CCC_PLL(CLK_CCC_PLL0, mpfs_ccc_pll0_refs, MPFS_CCC_FBDIV_SHIFT,\n\t\t    MPFS_CCC_FBDIV_WIDTH, 0, MPFS_CCC_SSCG_2_CR),\n\tCLK_CCC_PLL(CLK_CCC_PLL1, mpfs_ccc_pll1_refs, MPFS_CCC_FBDIV_SHIFT,\n\t\t    MPFS_CCC_FBDIV_WIDTH, 0, MPFS_CCC_SSCG_2_CR),\n};\n\nstruct mpfs_ccc_out_hw_clock {\n\tstruct clk_divider divider;\n\tstruct clk_init_data init;\n\tunsigned int id;\n\tu32 reg_offset;\n};\n\n#define CLK_CCC_OUT(_id, _shift, _width, _flags, _offset) {\t\\\n\t.id = _id,\t\t\t\t\t\t\\\n\t.divider.shift = _shift,\t\t\t\t\\\n\t.divider.width = _width,\t\t\t\t\\\n\t.reg_offset = _offset,\t\t\t\t\t\\\n\t.divider.flags = _flags,\t\t\t\t\\\n\t.divider.lock = &mpfs_ccc_lock,\t\t\t\t\\\n}\n\nstatic struct mpfs_ccc_out_hw_clock mpfs_ccc_pll0out_clks[] = {\n\tCLK_CCC_OUT(CLK_CCC_PLL0_OUT0, MPFS_CCC_POSTDIV0_SHIFT, MPFS_CCC_POSTDIV_WIDTH,\n\t\t    CLK_DIVIDER_ONE_BASED, MPFS_CCC_POSTDIV01_CR),\n\tCLK_CCC_OUT(CLK_CCC_PLL0_OUT1, MPFS_CCC_POSTDIV1_SHIFT, MPFS_CCC_POSTDIV_WIDTH,\n\t\t    CLK_DIVIDER_ONE_BASED, MPFS_CCC_POSTDIV01_CR),\n\tCLK_CCC_OUT(CLK_CCC_PLL0_OUT2, MPFS_CCC_POSTDIV2_SHIFT, MPFS_CCC_POSTDIV_WIDTH,\n\t\t    CLK_DIVIDER_ONE_BASED, MPFS_CCC_POSTDIV23_CR),\n\tCLK_CCC_OUT(CLK_CCC_PLL0_OUT3, MPFS_CCC_POSTDIV3_SHIFT, MPFS_CCC_POSTDIV_WIDTH,\n\t\t    CLK_DIVIDER_ONE_BASED, MPFS_CCC_POSTDIV23_CR),\n};\n\nstatic struct mpfs_ccc_out_hw_clock mpfs_ccc_pll1out_clks[] = {\n\tCLK_CCC_OUT(CLK_CCC_PLL1_OUT0, MPFS_CCC_POSTDIV0_SHIFT, MPFS_CCC_POSTDIV_WIDTH,\n\t\t    CLK_DIVIDER_ONE_BASED, MPFS_CCC_POSTDIV01_CR),\n\tCLK_CCC_OUT(CLK_CCC_PLL1_OUT1, MPFS_CCC_POSTDIV1_SHIFT, MPFS_CCC_POSTDIV_WIDTH,\n\t\t    CLK_DIVIDER_ONE_BASED, MPFS_CCC_POSTDIV01_CR),\n\tCLK_CCC_OUT(CLK_CCC_PLL1_OUT2, MPFS_CCC_POSTDIV2_SHIFT, MPFS_CCC_POSTDIV_WIDTH,\n\t\t    CLK_DIVIDER_ONE_BASED, MPFS_CCC_POSTDIV23_CR),\n\tCLK_CCC_OUT(CLK_CCC_PLL1_OUT3, MPFS_CCC_POSTDIV3_SHIFT, MPFS_CCC_POSTDIV_WIDTH,\n\t\t    CLK_DIVIDER_ONE_BASED, MPFS_CCC_POSTDIV23_CR),\n};\n\nstatic struct mpfs_ccc_out_hw_clock *mpfs_ccc_pllout_clks[] = {\n\tmpfs_ccc_pll0out_clks, mpfs_ccc_pll1out_clks\n};\n\nstatic int mpfs_ccc_register_outputs(struct device *dev, struct mpfs_ccc_out_hw_clock *out_hws,\n\t\t\t\t     unsigned int num_clks, struct mpfs_ccc_data *data,\n\t\t\t\t     struct mpfs_ccc_pll_hw_clock *parent)\n{\n\tint ret;\n\n\tfor (unsigned int i = 0; i < num_clks; i++) {\n\t\tstruct mpfs_ccc_out_hw_clock *out_hw = &out_hws[i];\n\t\tchar *name = devm_kasprintf(dev, GFP_KERNEL, \"%s_out%u\", parent->name, i);\n\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\n\t\tout_hw->divider.hw.init = CLK_HW_INIT_HW(name, &parent->hw, &clk_divider_ops, 0);\n\t\tout_hw->divider.reg = data->pll_base[i / MPFS_CCC_OUTPUTS_PER_PLL] +\n\t\t\tout_hw->reg_offset;\n\n\t\tret = devm_clk_hw_register(dev, &out_hw->divider.hw);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"failed to register clock id: %d\\n\",\n\t\t\t\t\t     out_hw->id);\n\n\t\tdata->hw_data.hws[out_hw->id] = &out_hw->divider.hw;\n\t}\n\n\treturn 0;\n}\n\n#define CLK_HW_INIT_PARENTS_DATA_FIXED_SIZE(_name, _parents, _ops, _flags)\t\\\n\t(&(struct clk_init_data) {\t\t\t\t\t\t\\\n\t\t.flags\t\t= _flags,\t\t\t\t\t\\\n\t\t.name\t\t= _name,\t\t\t\t\t\\\n\t\t.parent_data\t= _parents,\t\t\t\t\t\\\n\t\t.num_parents\t= MPFS_CCC_REFS_PER_PLL,\t\t\t\\\n\t\t.ops\t\t= _ops,\t\t\t\t\t\t\\\n\t})\n\nstatic int mpfs_ccc_register_plls(struct device *dev, struct mpfs_ccc_pll_hw_clock *pll_hws,\n\t\t\t\t  unsigned int num_clks, struct mpfs_ccc_data *data)\n{\n\tint ret;\n\n\tfor (unsigned int i = 0; i < num_clks; i++) {\n\t\tstruct mpfs_ccc_pll_hw_clock *pll_hw = &pll_hws[i];\n\n\t\tpll_hw->name = devm_kasprintf(dev, GFP_KERNEL, \"ccc%s_pll%u\",\n\t\t\t\t\t      strchrnul(dev->of_node->full_name, '@'), i);\n\t\tif (!pll_hw->name)\n\t\t\treturn -ENOMEM;\n\n\t\tpll_hw->base = data->pll_base[i];\n\t\tpll_hw->hw.init = CLK_HW_INIT_PARENTS_DATA_FIXED_SIZE(pll_hw->name,\n\t\t\t\t\t\t\t\t      pll_hw->parents,\n\t\t\t\t\t\t\t\t      &mpfs_ccc_pll_ops, 0);\n\n\t\tret = devm_clk_hw_register(dev, &pll_hw->hw);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"failed to register ccc id: %d\\n\",\n\t\t\t\t\t     pll_hw->id);\n\n\t\tdata->hw_data.hws[pll_hw->id] = &pll_hw->hw;\n\n\t\tret = mpfs_ccc_register_outputs(dev, mpfs_ccc_pllout_clks[i],\n\t\t\t\t\t\tMPFS_CCC_OUTPUTS_PER_PLL, data, pll_hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mpfs_ccc_probe(struct platform_device *pdev)\n{\n\tstruct mpfs_ccc_data *clk_data;\n\tvoid __iomem *pll_base[ARRAY_SIZE(mpfs_ccc_pll_clks)];\n\tunsigned int num_clks;\n\tint ret;\n\n\tnum_clks = ARRAY_SIZE(mpfs_ccc_pll_clks) + ARRAY_SIZE(mpfs_ccc_pll0out_clks) +\n\t\t   ARRAY_SIZE(mpfs_ccc_pll1out_clks);\n\n\tclk_data = devm_kzalloc(&pdev->dev, struct_size(clk_data, hw_data.hws, num_clks),\n\t\t\t\tGFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tpll_base[0] = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pll_base[0]))\n\t\treturn PTR_ERR(pll_base[0]);\n\n\tpll_base[1] = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(pll_base[1]))\n\t\treturn PTR_ERR(pll_base[1]);\n\n\tclk_data->pll_base = pll_base;\n\tclk_data->hw_data.num = num_clks;\n\tclk_data->dev = &pdev->dev;\n\n\tret = mpfs_ccc_register_plls(clk_data->dev, mpfs_ccc_pll_clks,\n\t\t\t\t     ARRAY_SIZE(mpfs_ccc_pll_clks), clk_data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_of_clk_add_hw_provider(clk_data->dev, of_clk_hw_onecell_get,\n\t\t\t\t\t   &clk_data->hw_data);\n}\n\nstatic const struct of_device_id mpfs_ccc_of_match_table[] = {\n\t{ .compatible = \"microchip,mpfs-ccc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mpfs_ccc_of_match_table);\n\nstatic struct platform_driver mpfs_ccc_driver = {\n\t.probe = mpfs_ccc_probe,\n\t.driver\t= {\n\t\t.name = \"microchip-mpfs-ccc\",\n\t\t.of_match_table = mpfs_ccc_of_match_table,\n\t},\n};\n\nstatic int __init clk_ccc_init(void)\n{\n\treturn platform_driver_register(&mpfs_ccc_driver);\n}\ncore_initcall(clk_ccc_init);\n\nstatic void __exit clk_ccc_exit(void)\n{\n\tplatform_driver_unregister(&mpfs_ccc_driver);\n}\nmodule_exit(clk_ccc_exit);\n\nMODULE_DESCRIPTION(\"Microchip PolarFire SoC Clock Conditioning Circuitry Driver\");\nMODULE_AUTHOR(\"Conor Dooley <conor.dooley@microchip.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}