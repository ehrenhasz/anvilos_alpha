{
  "module_name": "clk-mpfs.c",
  "hash_id": "39bc2842f13f4bb7e0769413269624552099783d0a8429abd8c4cf5ad4d1489f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/microchip/clk-mpfs.c",
  "human_readable_source": "\n \n#include <linux/auxiliary_bus.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <dt-bindings/clock/microchip,mpfs-clock.h>\n#include <soc/microchip/mpfs.h>\n\n \n#define REG_MSSPLL_REF_CR\t0x08u\n#define REG_MSSPLL_POSTDIV_CR\t0x10u\n#define REG_MSSPLL_SSCG_2_CR\t0x2Cu\n#define REG_CLOCK_CONFIG_CR\t0x08u\n#define REG_RTC_CLOCK_CR\t0x0Cu\n#define REG_SUBBLK_CLOCK_CR\t0x84u\n#define REG_SUBBLK_RESET_CR\t0x88u\n\n#define MSSPLL_FBDIV_SHIFT\t0x00u\n#define MSSPLL_FBDIV_WIDTH\t0x0Cu\n#define MSSPLL_REFDIV_SHIFT\t0x08u\n#define MSSPLL_REFDIV_WIDTH\t0x06u\n#define MSSPLL_POSTDIV_SHIFT\t0x08u\n#define MSSPLL_POSTDIV_WIDTH\t0x07u\n#define MSSPLL_FIXED_DIV\t4u\n\nstruct mpfs_clock_data {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tvoid __iomem *msspll_base;\n\tstruct clk_hw_onecell_data hw_data;\n};\n\nstruct mpfs_msspll_hw_clock {\n\tvoid __iomem *base;\n\tunsigned int id;\n\tu32 reg_offset;\n\tu32 shift;\n\tu32 width;\n\tu32 flags;\n\tstruct clk_hw hw;\n\tstruct clk_init_data init;\n};\n\n#define to_mpfs_msspll_clk(_hw) container_of(_hw, struct mpfs_msspll_hw_clock, hw)\n\nstruct mpfs_cfg_hw_clock {\n\tstruct clk_divider cfg;\n\tstruct clk_init_data init;\n\tunsigned int id;\n\tu32 reg_offset;\n};\n\nstruct mpfs_periph_hw_clock {\n\tstruct clk_gate periph;\n\tunsigned int id;\n};\n\n \nstatic DEFINE_SPINLOCK(mpfs_clk_lock);\n\nstatic const struct clk_parent_data mpfs_ext_ref[] = {\n\t{ .index = 0 },\n};\n\nstatic const struct clk_div_table mpfs_div_cpu_axi_table[] = {\n\t{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },\n\t{ 0, 0 }\n};\n\nstatic const struct clk_div_table mpfs_div_ahb_table[] = {\n\t{ 1, 2 }, { 2, 4}, { 3, 8 },\n\t{ 0, 0 }\n};\n\n \nstatic const struct clk_div_table mpfs_div_rtcref_table[] = {\n\t{ 100, 100 }, { 125, 125 },\n\t{ 0, 0 }\n};\n\nstatic unsigned long mpfs_clk_msspll_recalc_rate(struct clk_hw *hw, unsigned long prate)\n{\n\tstruct mpfs_msspll_hw_clock *msspll_hw = to_mpfs_msspll_clk(hw);\n\tvoid __iomem *mult_addr = msspll_hw->base + msspll_hw->reg_offset;\n\tvoid __iomem *ref_div_addr = msspll_hw->base + REG_MSSPLL_REF_CR;\n\tvoid __iomem *postdiv_addr = msspll_hw->base + REG_MSSPLL_POSTDIV_CR;\n\tu32 mult, ref_div, postdiv;\n\n\tmult = readl_relaxed(mult_addr) >> MSSPLL_FBDIV_SHIFT;\n\tmult &= clk_div_mask(MSSPLL_FBDIV_WIDTH);\n\tref_div = readl_relaxed(ref_div_addr) >> MSSPLL_REFDIV_SHIFT;\n\tref_div &= clk_div_mask(MSSPLL_REFDIV_WIDTH);\n\tpostdiv = readl_relaxed(postdiv_addr) >> MSSPLL_POSTDIV_SHIFT;\n\tpostdiv &= clk_div_mask(MSSPLL_POSTDIV_WIDTH);\n\n\treturn prate * mult / (ref_div * MSSPLL_FIXED_DIV * postdiv);\n}\n\nstatic long mpfs_clk_msspll_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *prate)\n{\n\tstruct mpfs_msspll_hw_clock *msspll_hw = to_mpfs_msspll_clk(hw);\n\tvoid __iomem *mult_addr = msspll_hw->base + msspll_hw->reg_offset;\n\tvoid __iomem *ref_div_addr = msspll_hw->base + REG_MSSPLL_REF_CR;\n\tu32 mult, ref_div;\n\tunsigned long rate_before_ctrl;\n\n\tmult = readl_relaxed(mult_addr) >> MSSPLL_FBDIV_SHIFT;\n\tmult &= clk_div_mask(MSSPLL_FBDIV_WIDTH);\n\tref_div = readl_relaxed(ref_div_addr) >> MSSPLL_REFDIV_SHIFT;\n\tref_div &= clk_div_mask(MSSPLL_REFDIV_WIDTH);\n\n\trate_before_ctrl = rate * (ref_div * MSSPLL_FIXED_DIV) / mult;\n\n\treturn divider_round_rate(hw, rate_before_ctrl, prate, NULL, MSSPLL_POSTDIV_WIDTH,\n\t\t\t\t  msspll_hw->flags);\n}\n\nstatic int mpfs_clk_msspll_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long prate)\n{\n\tstruct mpfs_msspll_hw_clock *msspll_hw = to_mpfs_msspll_clk(hw);\n\tvoid __iomem *mult_addr = msspll_hw->base + msspll_hw->reg_offset;\n\tvoid __iomem *ref_div_addr = msspll_hw->base + REG_MSSPLL_REF_CR;\n\tvoid __iomem *postdiv_addr = msspll_hw->base + REG_MSSPLL_POSTDIV_CR;\n\tu32 mult, ref_div, postdiv;\n\tint divider_setting;\n\tunsigned long rate_before_ctrl, flags;\n\n\tmult = readl_relaxed(mult_addr) >> MSSPLL_FBDIV_SHIFT;\n\tmult &= clk_div_mask(MSSPLL_FBDIV_WIDTH);\n\tref_div = readl_relaxed(ref_div_addr) >> MSSPLL_REFDIV_SHIFT;\n\tref_div &= clk_div_mask(MSSPLL_REFDIV_WIDTH);\n\n\trate_before_ctrl = rate * (ref_div * MSSPLL_FIXED_DIV) / mult;\n\tdivider_setting = divider_get_val(rate_before_ctrl, prate, NULL, MSSPLL_POSTDIV_WIDTH,\n\t\t\t\t\t  msspll_hw->flags);\n\n\tif (divider_setting < 0)\n\t\treturn divider_setting;\n\n\tspin_lock_irqsave(&mpfs_clk_lock, flags);\n\n\tpostdiv = readl_relaxed(postdiv_addr);\n\tpostdiv &= ~(clk_div_mask(MSSPLL_POSTDIV_WIDTH) << MSSPLL_POSTDIV_SHIFT);\n\twritel_relaxed(postdiv, postdiv_addr);\n\n\tspin_unlock_irqrestore(&mpfs_clk_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops mpfs_clk_msspll_ops = {\n\t.recalc_rate = mpfs_clk_msspll_recalc_rate,\n\t.round_rate = mpfs_clk_msspll_round_rate,\n\t.set_rate = mpfs_clk_msspll_set_rate,\n};\n\n#define CLK_PLL(_id, _name, _parent, _shift, _width, _flags, _offset) {\t\t\t\\\n\t.id = _id,\t\t\t\t\t\t\t\t\t\\\n\t.shift = _shift,\t\t\t\t\t\t\t\t\\\n\t.width = _width,\t\t\t\t\t\t\t\t\\\n\t.reg_offset = _offset,\t\t\t\t\t\t\t\t\\\n\t.flags = _flags,\t\t\t\t\t\t\t\t\\\n\t.hw.init = CLK_HW_INIT_PARENTS_DATA(_name, _parent, &mpfs_clk_msspll_ops, 0),\t\\\n}\n\nstatic struct mpfs_msspll_hw_clock mpfs_msspll_clks[] = {\n\tCLK_PLL(CLK_MSSPLL, \"clk_msspll\", mpfs_ext_ref, MSSPLL_FBDIV_SHIFT,\n\t\tMSSPLL_FBDIV_WIDTH, 0, REG_MSSPLL_SSCG_2_CR),\n};\n\nstatic int mpfs_clk_register_mssplls(struct device *dev, struct mpfs_msspll_hw_clock *msspll_hws,\n\t\t\t\t     unsigned int num_clks, struct mpfs_clock_data *data)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tstruct mpfs_msspll_hw_clock *msspll_hw = &msspll_hws[i];\n\n\t\tmsspll_hw->base = data->msspll_base;\n\t\tret = devm_clk_hw_register(dev, &msspll_hw->hw);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"failed to register msspll id: %d\\n\",\n\t\t\t\t\t     CLK_MSSPLL);\n\n\t\tdata->hw_data.hws[msspll_hw->id] = &msspll_hw->hw;\n\t}\n\n\treturn 0;\n}\n\n \n\n#define CLK_CFG(_id, _name, _parent, _shift, _width, _table, _flags, _offset) {\t\t\\\n\t.id = _id,\t\t\t\t\t\t\t\t\t\\\n\t.cfg.shift = _shift,\t\t\t\t\t\t\t\t\\\n\t.cfg.width = _width,\t\t\t\t\t\t\t\t\\\n\t.cfg.table = _table,\t\t\t\t\t\t\t\t\\\n\t.reg_offset = _offset,\t\t\t\t\t\t\t\t\\\n\t.cfg.flags = _flags,\t\t\t\t\t\t\t\t\\\n\t.cfg.hw.init = CLK_HW_INIT(_name, _parent, &clk_divider_ops, 0),\t\t\\\n\t.cfg.lock = &mpfs_clk_lock,\t\t\t\t\t\t\t\\\n}\n\n#define CLK_CPU_OFFSET\t\t0u\n#define CLK_AXI_OFFSET\t\t1u\n#define CLK_AHB_OFFSET\t\t2u\n#define CLK_RTCREF_OFFSET\t3u\n\nstatic struct mpfs_cfg_hw_clock mpfs_cfg_clks[] = {\n\tCLK_CFG(CLK_CPU, \"clk_cpu\", \"clk_msspll\", 0, 2, mpfs_div_cpu_axi_table, 0,\n\t\tREG_CLOCK_CONFIG_CR),\n\tCLK_CFG(CLK_AXI, \"clk_axi\", \"clk_msspll\", 2, 2, mpfs_div_cpu_axi_table, 0,\n\t\tREG_CLOCK_CONFIG_CR),\n\tCLK_CFG(CLK_AHB, \"clk_ahb\", \"clk_msspll\", 4, 2, mpfs_div_ahb_table, 0,\n\t\tREG_CLOCK_CONFIG_CR),\n\t{\n\t\t.id = CLK_RTCREF,\n\t\t.cfg.shift = 0,\n\t\t.cfg.width = 12,\n\t\t.cfg.table = mpfs_div_rtcref_table,\n\t\t.reg_offset = REG_RTC_CLOCK_CR,\n\t\t.cfg.flags = CLK_DIVIDER_ONE_BASED,\n\t\t.cfg.hw.init =\n\t\t\tCLK_HW_INIT_PARENTS_DATA(\"clk_rtcref\", mpfs_ext_ref, &clk_divider_ops, 0),\n\t}\n};\n\nstatic int mpfs_clk_register_cfgs(struct device *dev, struct mpfs_cfg_hw_clock *cfg_hws,\n\t\t\t\t  unsigned int num_clks, struct mpfs_clock_data *data)\n{\n\tunsigned int i, id;\n\tint ret;\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tstruct mpfs_cfg_hw_clock *cfg_hw = &cfg_hws[i];\n\n\t\tcfg_hw->cfg.reg = data->base + cfg_hw->reg_offset;\n\t\tret = devm_clk_hw_register(dev, &cfg_hw->cfg.hw);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"failed to register clock id: %d\\n\",\n\t\t\t\t\t     cfg_hw->id);\n\n\t\tid = cfg_hw->id;\n\t\tdata->hw_data.hws[id] = &cfg_hw->cfg.hw;\n\t}\n\n\treturn 0;\n}\n\n \n\n#define CLK_PERIPH(_id, _name, _parent, _shift, _flags) {\t\t\t\\\n\t.id = _id,\t\t\t\t\t\t\t\t\\\n\t.periph.bit_idx = _shift,\t\t\t\t\t\t\\\n\t.periph.hw.init = CLK_HW_INIT_HW(_name, _parent, &clk_gate_ops,\t\t\\\n\t\t\t\t  _flags),\t\t\t\t\t\\\n\t.periph.lock = &mpfs_clk_lock,\t\t\t\t\t\t\\\n}\n\n#define PARENT_CLK(PARENT) (&mpfs_cfg_clks[CLK_##PARENT##_OFFSET].cfg.hw)\n\n \n\nstatic struct mpfs_periph_hw_clock mpfs_periph_clks[] = {\n\tCLK_PERIPH(CLK_ENVM, \"clk_periph_envm\", PARENT_CLK(AHB), 0, CLK_IS_CRITICAL),\n\tCLK_PERIPH(CLK_MAC0, \"clk_periph_mac0\", PARENT_CLK(AHB), 1, 0),\n\tCLK_PERIPH(CLK_MAC1, \"clk_periph_mac1\", PARENT_CLK(AHB), 2, 0),\n\tCLK_PERIPH(CLK_MMC, \"clk_periph_mmc\", PARENT_CLK(AHB), 3, 0),\n\tCLK_PERIPH(CLK_TIMER, \"clk_periph_timer\", PARENT_CLK(RTCREF), 4, 0),\n\tCLK_PERIPH(CLK_MMUART0, \"clk_periph_mmuart0\", PARENT_CLK(AHB), 5, CLK_IS_CRITICAL),\n\tCLK_PERIPH(CLK_MMUART1, \"clk_periph_mmuart1\", PARENT_CLK(AHB), 6, 0),\n\tCLK_PERIPH(CLK_MMUART2, \"clk_periph_mmuart2\", PARENT_CLK(AHB), 7, 0),\n\tCLK_PERIPH(CLK_MMUART3, \"clk_periph_mmuart3\", PARENT_CLK(AHB), 8, 0),\n\tCLK_PERIPH(CLK_MMUART4, \"clk_periph_mmuart4\", PARENT_CLK(AHB), 9, 0),\n\tCLK_PERIPH(CLK_SPI0, \"clk_periph_spi0\", PARENT_CLK(AHB), 10, 0),\n\tCLK_PERIPH(CLK_SPI1, \"clk_periph_spi1\", PARENT_CLK(AHB), 11, 0),\n\tCLK_PERIPH(CLK_I2C0, \"clk_periph_i2c0\", PARENT_CLK(AHB), 12, 0),\n\tCLK_PERIPH(CLK_I2C1, \"clk_periph_i2c1\", PARENT_CLK(AHB), 13, 0),\n\tCLK_PERIPH(CLK_CAN0, \"clk_periph_can0\", PARENT_CLK(AHB), 14, 0),\n\tCLK_PERIPH(CLK_CAN1, \"clk_periph_can1\", PARENT_CLK(AHB), 15, 0),\n\tCLK_PERIPH(CLK_USB, \"clk_periph_usb\", PARENT_CLK(AHB), 16, 0),\n\tCLK_PERIPH(CLK_RTC, \"clk_periph_rtc\", PARENT_CLK(AHB), 18, CLK_IS_CRITICAL),\n\tCLK_PERIPH(CLK_QSPI, \"clk_periph_qspi\", PARENT_CLK(AHB), 19, 0),\n\tCLK_PERIPH(CLK_GPIO0, \"clk_periph_gpio0\", PARENT_CLK(AHB), 20, 0),\n\tCLK_PERIPH(CLK_GPIO1, \"clk_periph_gpio1\", PARENT_CLK(AHB), 21, 0),\n\tCLK_PERIPH(CLK_GPIO2, \"clk_periph_gpio2\", PARENT_CLK(AHB), 22, 0),\n\tCLK_PERIPH(CLK_DDRC, \"clk_periph_ddrc\", PARENT_CLK(AHB), 23, CLK_IS_CRITICAL),\n\tCLK_PERIPH(CLK_FIC0, \"clk_periph_fic0\", PARENT_CLK(AXI), 24, CLK_IS_CRITICAL),\n\tCLK_PERIPH(CLK_FIC1, \"clk_periph_fic1\", PARENT_CLK(AXI), 25, CLK_IS_CRITICAL),\n\tCLK_PERIPH(CLK_FIC2, \"clk_periph_fic2\", PARENT_CLK(AXI), 26, CLK_IS_CRITICAL),\n\tCLK_PERIPH(CLK_FIC3, \"clk_periph_fic3\", PARENT_CLK(AXI), 27, CLK_IS_CRITICAL),\n\tCLK_PERIPH(CLK_ATHENA, \"clk_periph_athena\", PARENT_CLK(AXI), 28, CLK_IS_CRITICAL),\n\tCLK_PERIPH(CLK_CFM, \"clk_periph_cfm\", PARENT_CLK(AHB), 29, 0),\n};\n\nstatic int mpfs_clk_register_periphs(struct device *dev, struct mpfs_periph_hw_clock *periph_hws,\n\t\t\t\t     int num_clks, struct mpfs_clock_data *data)\n{\n\tunsigned int i, id;\n\tint ret;\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tstruct mpfs_periph_hw_clock *periph_hw = &periph_hws[i];\n\n\t\tperiph_hw->periph.reg = data->base + REG_SUBBLK_CLOCK_CR;\n\t\tret = devm_clk_hw_register(dev, &periph_hw->periph.hw);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"failed to register clock id: %d\\n\",\n\t\t\t\t\t     periph_hw->id);\n\n\t\tid = periph_hws[i].id;\n\t\tdata->hw_data.hws[id] = &periph_hw->periph.hw;\n\t}\n\n\treturn 0;\n}\n\n \n\n#if IS_ENABLED(CONFIG_RESET_CONTROLLER)\n\nu32 mpfs_reset_read(struct device *dev)\n{\n\tstruct mpfs_clock_data *clock_data = dev_get_drvdata(dev->parent);\n\n\treturn readl_relaxed(clock_data->base + REG_SUBBLK_RESET_CR);\n}\nEXPORT_SYMBOL_NS_GPL(mpfs_reset_read, MCHP_CLK_MPFS);\n\nvoid mpfs_reset_write(struct device *dev, u32 val)\n{\n\tstruct mpfs_clock_data *clock_data = dev_get_drvdata(dev->parent);\n\n\twritel_relaxed(val, clock_data->base + REG_SUBBLK_RESET_CR);\n}\nEXPORT_SYMBOL_NS_GPL(mpfs_reset_write, MCHP_CLK_MPFS);\n\nstatic void mpfs_reset_unregister_adev(void *_adev)\n{\n\tstruct auxiliary_device *adev = _adev;\n\n\tauxiliary_device_delete(adev);\n\tauxiliary_device_uninit(adev);\n}\n\nstatic void mpfs_reset_adev_release(struct device *dev)\n{\n\tstruct auxiliary_device *adev = to_auxiliary_dev(dev);\n\n\tkfree(adev);\n}\n\nstatic struct auxiliary_device *mpfs_reset_adev_alloc(struct mpfs_clock_data *clk_data)\n{\n\tstruct auxiliary_device *adev;\n\tint ret;\n\n\tadev = kzalloc(sizeof(*adev), GFP_KERNEL);\n\tif (!adev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tadev->name = \"reset-mpfs\";\n\tadev->dev.parent = clk_data->dev;\n\tadev->dev.release = mpfs_reset_adev_release;\n\tadev->id = 666u;\n\n\tret = auxiliary_device_init(adev);\n\tif (ret) {\n\t\tkfree(adev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn adev;\n}\n\nstatic int mpfs_reset_controller_register(struct mpfs_clock_data *clk_data)\n{\n\tstruct auxiliary_device *adev;\n\tint ret;\n\n\tadev = mpfs_reset_adev_alloc(clk_data);\n\tif (IS_ERR(adev))\n\t\treturn PTR_ERR(adev);\n\n\tret = auxiliary_device_add(adev);\n\tif (ret) {\n\t\tauxiliary_device_uninit(adev);\n\t\treturn ret;\n\t}\n\n\treturn devm_add_action_or_reset(clk_data->dev, mpfs_reset_unregister_adev, adev);\n}\n\n#else  \n\nstatic int mpfs_reset_controller_register(struct mpfs_clock_data *clk_data)\n{\n\treturn 0;\n}\n\n#endif  \n\nstatic int mpfs_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mpfs_clock_data *clk_data;\n\tunsigned int num_clks;\n\tint ret;\n\n\t \n\tnum_clks = ARRAY_SIZE(mpfs_msspll_clks) + ARRAY_SIZE(mpfs_cfg_clks)\n\t\t   + ARRAY_SIZE(mpfs_periph_clks) + 1;\n\n\tclk_data = devm_kzalloc(dev, struct_size(clk_data, hw_data.hws, num_clks), GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tclk_data->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(clk_data->base))\n\t\treturn PTR_ERR(clk_data->base);\n\n\tclk_data->msspll_base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(clk_data->msspll_base))\n\t\treturn PTR_ERR(clk_data->msspll_base);\n\n\tclk_data->hw_data.num = num_clks;\n\tclk_data->dev = dev;\n\tdev_set_drvdata(dev, clk_data);\n\n\tret = mpfs_clk_register_mssplls(dev, mpfs_msspll_clks, ARRAY_SIZE(mpfs_msspll_clks),\n\t\t\t\t\tclk_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mpfs_clk_register_cfgs(dev, mpfs_cfg_clks, ARRAY_SIZE(mpfs_cfg_clks), clk_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mpfs_clk_register_periphs(dev, mpfs_periph_clks, ARRAY_SIZE(mpfs_periph_clks),\n\t\t\t\t\tclk_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, &clk_data->hw_data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mpfs_reset_controller_register(clk_data);\n}\n\nstatic const struct of_device_id mpfs_clk_of_match_table[] = {\n\t{ .compatible = \"microchip,mpfs-clkcfg\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mpfs_clk_of_match_table);\n\nstatic struct platform_driver mpfs_clk_driver = {\n\t.probe = mpfs_clk_probe,\n\t.driver\t= {\n\t\t.name = \"microchip-mpfs-clkcfg\",\n\t\t.of_match_table = mpfs_clk_of_match_table,\n\t},\n};\n\nstatic int __init clk_mpfs_init(void)\n{\n\treturn platform_driver_register(&mpfs_clk_driver);\n}\ncore_initcall(clk_mpfs_init);\n\nstatic void __exit clk_mpfs_exit(void)\n{\n\tplatform_driver_unregister(&mpfs_clk_driver);\n}\nmodule_exit(clk_mpfs_exit);\n\nMODULE_DESCRIPTION(\"Microchip PolarFire SoC Clock Driver\");\nMODULE_AUTHOR(\"Padmarao Begari <padmarao.begari@microchip.com>\");\nMODULE_AUTHOR(\"Daire McNamara <daire.mcnamara@microchip.com>\");\nMODULE_AUTHOR(\"Conor Dooley <conor.dooley@microchip.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}