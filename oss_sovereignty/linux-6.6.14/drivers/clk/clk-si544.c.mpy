{
  "module_name": "clk-si544.c",
  "hash_id": "5db086a2980be895e7b63e5d993b8a77fb7c1c386491aee69ef7f4b66fd628cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-si544.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n \n#define SI544_REG_CONTROL\t7\n#define SI544_REG_OE_STATE\t17\n#define SI544_REG_HS_DIV\t23\n#define SI544_REG_LS_HS_DIV\t24\n#define SI544_REG_FBDIV0\t26\n#define SI544_REG_FBDIV8\t27\n#define SI544_REG_FBDIV16\t28\n#define SI544_REG_FBDIV24\t29\n#define SI544_REG_FBDIV32\t30\n#define SI544_REG_FBDIV40\t31\n#define SI544_REG_FCAL_OVR\t69\n#define SI544_REG_ADPLL_DELTA_M0\t231\n#define SI544_REG_ADPLL_DELTA_M8\t232\n#define SI544_REG_ADPLL_DELTA_M16\t233\n#define SI544_REG_PAGE_SELECT\t255\n\n \n#define SI544_CONTROL_RESET\tBIT(7)\n#define SI544_CONTROL_MS_ICAL2\tBIT(3)\n\n#define SI544_OE_STATE_ODC_OE\tBIT(0)\n\n \n#define SI544_MIN_FREQ\t    200000U\n\n \n#define FXO\t\t  55050000U\n\n \n#define FVCO_MIN       10800000000ULL\n\n#define HS_DIV_MAX\t2046\n#define HS_DIV_MAX_ODD\t33\n\n \n#define MIN_HSDIV_FREQ\t(FVCO_MIN / HS_DIV_MAX)\n\n \n#define DELTA_M_MAX\t8161512\n#define DELTA_M_FRAC_NUM\t19\n#define DELTA_M_FRAC_DEN\t20000\n\nenum si544_speed_grade {\n\tsi544a,\n\tsi544b,\n\tsi544c,\n};\n\nstruct clk_si544 {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tstruct i2c_client *i2c_client;\n\tenum si544_speed_grade speed_grade;\n};\n#define to_clk_si544(_hw)\tcontainer_of(_hw, struct clk_si544, hw)\n\n \nstruct clk_si544_muldiv {\n\tu32 fb_div_frac;\n\tu16 fb_div_int;\n\tu16 hs_div;\n\tu8 ls_div_bits;\n\ts32 delta_m;\n};\n\n \nstatic int si544_enable_output(struct clk_si544 *data, bool enable)\n{\n\treturn regmap_update_bits(data->regmap, SI544_REG_OE_STATE,\n\t\tSI544_OE_STATE_ODC_OE, enable ? SI544_OE_STATE_ODC_OE : 0);\n}\n\nstatic int si544_prepare(struct clk_hw *hw)\n{\n\tstruct clk_si544 *data = to_clk_si544(hw);\n\n\treturn si544_enable_output(data, true);\n}\n\nstatic void si544_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_si544 *data = to_clk_si544(hw);\n\n\tsi544_enable_output(data, false);\n}\n\nstatic int si544_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_si544 *data = to_clk_si544(hw);\n\tunsigned int val;\n\tint err;\n\n\terr = regmap_read(data->regmap, SI544_REG_OE_STATE, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn !!(val & SI544_OE_STATE_ODC_OE);\n}\n\n \nstatic int si544_get_muldiv(struct clk_si544 *data,\n\tstruct clk_si544_muldiv *settings)\n{\n\tint err;\n\tu8 reg[6];\n\n\terr = regmap_bulk_read(data->regmap, SI544_REG_HS_DIV, reg, 2);\n\tif (err)\n\t\treturn err;\n\n\tsettings->ls_div_bits = (reg[1] >> 4) & 0x07;\n\tsettings->hs_div = (reg[1] & 0x07) << 8 | reg[0];\n\n\terr = regmap_bulk_read(data->regmap, SI544_REG_FBDIV0, reg, 6);\n\tif (err)\n\t\treturn err;\n\n\tsettings->fb_div_int = reg[4] | (reg[5] & 0x07) << 8;\n\tsettings->fb_div_frac = reg[0] | reg[1] << 8 | reg[2] << 16 |\n\t\t\t\treg[3] << 24;\n\n\terr = regmap_bulk_read(data->regmap, SI544_REG_ADPLL_DELTA_M0, reg, 3);\n\tif (err)\n\t\treturn err;\n\n\t \n\tsettings->delta_m = reg[0] << 8 | reg[1] << 16 | reg[2] << 24;\n\tsettings->delta_m >>= 8;\n\n\treturn 0;\n}\n\nstatic int si544_set_delta_m(struct clk_si544 *data, s32 delta_m)\n{\n\tu8 reg[3];\n\n\treg[0] = delta_m;\n\treg[1] = delta_m >> 8;\n\treg[2] = delta_m >> 16;\n\n\treturn regmap_bulk_write(data->regmap, SI544_REG_ADPLL_DELTA_M0,\n\t\t\t\t reg, 3);\n}\n\nstatic int si544_set_muldiv(struct clk_si544 *data,\n\tstruct clk_si544_muldiv *settings)\n{\n\tint err;\n\tu8 reg[6];\n\n\treg[0] = settings->hs_div;\n\treg[1] = settings->hs_div >> 8 | settings->ls_div_bits << 4;\n\n\terr = regmap_bulk_write(data->regmap, SI544_REG_HS_DIV, reg, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\treg[0] = settings->fb_div_frac;\n\treg[1] = settings->fb_div_frac >> 8;\n\treg[2] = settings->fb_div_frac >> 16;\n\treg[3] = settings->fb_div_frac >> 24;\n\treg[4] = settings->fb_div_int;\n\treg[5] = settings->fb_div_int >> 8;\n\n\t \n\treturn regmap_bulk_write(data->regmap, SI544_REG_FBDIV0, reg, 6);\n}\n\nstatic bool is_valid_frequency(const struct clk_si544 *data,\n\tunsigned long frequency)\n{\n\tunsigned long max_freq = 0;\n\n\tif (frequency < SI544_MIN_FREQ)\n\t\treturn false;\n\n\tswitch (data->speed_grade) {\n\tcase si544a:\n\t\tmax_freq = 1500000000;\n\t\tbreak;\n\tcase si544b:\n\t\tmax_freq = 800000000;\n\t\tbreak;\n\tcase si544c:\n\t\tmax_freq = 350000000;\n\t\tbreak;\n\t}\n\n\treturn frequency <= max_freq;\n}\n\n \nstatic int si544_calc_muldiv(struct clk_si544_muldiv *settings,\n\tunsigned long frequency)\n{\n\tu64 vco;\n\tu32 ls_freq;\n\tu32 tmp;\n\tu8 res;\n\n\t \n\tls_freq = frequency;\n\tsettings->ls_div_bits = 0;\n\n\tif (frequency >= MIN_HSDIV_FREQ) {\n\t\tsettings->ls_div_bits = 0;\n\t} else {\n\t\tres = 1;\n\t\ttmp = 2 * HS_DIV_MAX;\n\t\twhile (tmp <= (HS_DIV_MAX * 32)) {\n\t\t\tif (((u64)frequency * tmp) >= FVCO_MIN)\n\t\t\t\tbreak;\n\t\t\t++res;\n\t\t\ttmp <<= 1;\n\t\t}\n\t\tsettings->ls_div_bits = res;\n\t\tls_freq = frequency << res;\n\t}\n\n\t \n\tvco = FVCO_MIN + ls_freq - 1;\n\tdo_div(vco, ls_freq);\n\tsettings->hs_div = vco;\n\n\t \n\tif ((settings->hs_div & 1) &&\n\t    (settings->hs_div > HS_DIV_MAX_ODD || settings->ls_div_bits))\n\t\t++settings->hs_div;\n\n\t \n\tvco = (u64)ls_freq * settings->hs_div;\n\n\t \n\ttmp = do_div(vco, FXO);\n\tsettings->fb_div_int = vco;\n\n\t \n\tvco = (u64)tmp << 32;\n\tvco += FXO / 2;  \n\tdo_div(vco, FXO);\n\tsettings->fb_div_frac = vco;\n\n\t \n\tsettings->delta_m = 0;\n\n\treturn 0;\n}\n\n \nstatic unsigned long si544_calc_center_rate(\n\t\tconst struct clk_si544_muldiv *settings)\n{\n\tu32 d = settings->hs_div * BIT(settings->ls_div_bits);\n\tu64 vco;\n\n\t \n\tvco = (u64)settings->fb_div_frac * FXO;\n\tvco += (FXO / 2);\n\tvco >>= 32;\n\n\t \n\tvco += (u64)settings->fb_div_int * FXO;\n\n\t \n\tdo_div(vco, d);\n\n\treturn vco;\n}\n\nstatic unsigned long si544_calc_rate(const struct clk_si544_muldiv *settings)\n{\n\tunsigned long rate = si544_calc_center_rate(settings);\n\ts64 delta = (s64)rate * (DELTA_M_FRAC_NUM * settings->delta_m);\n\n\t \n\tif (settings->delta_m < 0)\n\t\tdelta -= ((s64)DELTA_M_MAX * DELTA_M_FRAC_DEN) / 2;\n\telse\n\t\tdelta += ((s64)DELTA_M_MAX * DELTA_M_FRAC_DEN) / 2;\n\tdelta = div64_s64(delta, ((s64)DELTA_M_MAX * DELTA_M_FRAC_DEN));\n\n\treturn rate + delta;\n}\n\nstatic unsigned long si544_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_si544 *data = to_clk_si544(hw);\n\tstruct clk_si544_muldiv settings;\n\tint err;\n\n\terr = si544_get_muldiv(data, &settings);\n\tif (err)\n\t\treturn 0;\n\n\treturn si544_calc_rate(&settings);\n}\n\nstatic long si544_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long *parent_rate)\n{\n\tstruct clk_si544 *data = to_clk_si544(hw);\n\n\tif (!is_valid_frequency(data, rate))\n\t\treturn -EINVAL;\n\n\t \n\treturn rate;\n}\n\n \nstatic unsigned long si544_max_delta(unsigned long rate)\n{\n\tu64 num = rate;\n\n\tnum *= DELTA_M_FRAC_NUM;\n\tdo_div(num, DELTA_M_FRAC_DEN);\n\n\treturn num;\n}\n\nstatic s32 si544_calc_delta(s32 delta, s32 max_delta)\n{\n\ts64 n = (s64)delta * DELTA_M_MAX;\n\n\treturn div_s64(n, max_delta);\n}\n\nstatic int si544_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_si544 *data = to_clk_si544(hw);\n\tstruct clk_si544_muldiv settings;\n\tunsigned long center;\n\tlong max_delta;\n\tlong delta;\n\tunsigned int old_oe_state;\n\tint err;\n\n\tif (!is_valid_frequency(data, rate))\n\t\treturn -EINVAL;\n\n\t \n\terr = si544_get_muldiv(data, &settings);\n\tif (err)\n\t\treturn err;\n\n\tcenter = si544_calc_center_rate(&settings);\n\tmax_delta = si544_max_delta(center);\n\tdelta = rate - center;\n\n\tif (abs(delta) <= max_delta)\n\t\treturn si544_set_delta_m(data,\n\t\t\t\t\t si544_calc_delta(delta, max_delta));\n\n\t \n\terr = si544_calc_muldiv(&settings, rate);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_read(data->regmap, SI544_REG_OE_STATE, &old_oe_state);\n\tif (err)\n\t\treturn err;\n\n\tsi544_enable_output(data, false);\n\n\t \n\terr = regmap_write(data->regmap, SI544_REG_FCAL_OVR, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = si544_set_delta_m(data, settings.delta_m);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = si544_set_muldiv(data, &settings);\n\tif (err < 0)\n\t\treturn err;  \n\n\t \n\terr = regmap_write(data->regmap, SI544_REG_CONTROL,\n\t\t\t   SI544_CONTROL_MS_ICAL2);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tusleep_range(10000, 12000);\n\n\tif (old_oe_state & SI544_OE_STATE_ODC_OE)\n\t\tsi544_enable_output(data, true);\n\n\treturn err;\n}\n\nstatic const struct clk_ops si544_clk_ops = {\n\t.prepare = si544_prepare,\n\t.unprepare = si544_unprepare,\n\t.is_prepared = si544_is_prepared,\n\t.recalc_rate = si544_recalc_rate,\n\t.round_rate = si544_round_rate,\n\t.set_rate = si544_set_rate,\n};\n\nstatic bool si544_regmap_is_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SI544_REG_CONTROL:\n\tcase SI544_REG_FCAL_OVR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config si544_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = SI544_REG_PAGE_SELECT,\n\t.volatile_reg = si544_regmap_is_volatile,\n};\n\nstatic const struct i2c_device_id si544_id[] = {\n\t{ \"si544a\", si544a },\n\t{ \"si544b\", si544b },\n\t{ \"si544c\", si544c },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, si544_id);\n\nstatic int si544_probe(struct i2c_client *client)\n{\n\tstruct clk_si544 *data;\n\tstruct clk_init_data init;\n\tconst struct i2c_device_id *id = i2c_match_id(si544_id, client);\n\tint err;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinit.ops = &si544_clk_ops;\n\tinit.flags = 0;\n\tinit.num_parents = 0;\n\tdata->hw.init = &init;\n\tdata->i2c_client = client;\n\tdata->speed_grade = id->driver_data;\n\n\tif (of_property_read_string(client->dev.of_node, \"clock-output-names\",\n\t\t\t&init.name))\n\t\tinit.name = client->dev.of_node->name;\n\n\tdata->regmap = devm_regmap_init_i2c(client, &si544_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\ti2c_set_clientdata(client, data);\n\n\t \n\terr = regmap_write(data->regmap, SI544_REG_PAGE_SELECT, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = devm_clk_hw_register(&client->dev, &data->hw);\n\tif (err) {\n\t\tdev_err(&client->dev, \"clock registration failed\\n\");\n\t\treturn err;\n\t}\n\terr = devm_of_clk_add_hw_provider(&client->dev, of_clk_hw_simple_get,\n\t\t\t\t\t  &data->hw);\n\tif (err) {\n\t\tdev_err(&client->dev, \"unable to add clk provider\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id clk_si544_of_match[] = {\n\t{ .compatible = \"silabs,si544a\" },\n\t{ .compatible = \"silabs,si544b\" },\n\t{ .compatible = \"silabs,si544c\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, clk_si544_of_match);\n\nstatic struct i2c_driver si544_driver = {\n\t.driver = {\n\t\t.name = \"si544\",\n\t\t.of_match_table = clk_si544_of_match,\n\t},\n\t.probe\t\t= si544_probe,\n\t.id_table\t= si544_id,\n};\nmodule_i2c_driver(si544_driver);\n\nMODULE_AUTHOR(\"Mike Looijmans <mike.looijmans@topic.nl>\");\nMODULE_DESCRIPTION(\"Si544 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}