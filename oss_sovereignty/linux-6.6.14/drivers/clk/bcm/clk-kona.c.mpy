{
  "module_name": "clk-kona.c",
  "hash_id": "1480acd3aa34c762d1c4c3a984c42d1fe4058c7eed147c01ed1e069355570895",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/bcm/clk-kona.c",
  "human_readable_source": "\n \n\n#include \"clk-kona.h\"\n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/clk-provider.h>\n\n \n#define CCU_POLICY_COUNT\t4\n\n#define CCU_ACCESS_PASSWORD      0xA5A500\n#define CLK_GATE_DELAY_LOOP      2000\n\n \n\n \nstatic inline u32 bitfield_mask(u32 shift, u32 width)\n{\n\treturn ((1 << width) - 1) << shift;\n}\n\n \nstatic inline u32 bitfield_extract(u32 reg_val, u32 shift, u32 width)\n{\n\treturn (reg_val & bitfield_mask(shift, width)) >> shift;\n}\n\n \nstatic inline u32 bitfield_replace(u32 reg_val, u32 shift, u32 width, u32 val)\n{\n\tu32 mask = bitfield_mask(shift, width);\n\n\treturn (reg_val & ~mask) | (val << shift);\n}\n\n \n\n \nstatic inline u64 scaled_div_value(struct bcm_clk_div *div, u32 reg_div)\n{\n\treturn (u64)reg_div + ((u64)1 << div->u.s.frac_width);\n}\n\n \nu64 scaled_div_build(struct bcm_clk_div *div, u32 div_value, u32 billionths)\n{\n\tu64 combined;\n\n\tBUG_ON(!div_value);\n\tBUG_ON(billionths >= BILLION);\n\n\tcombined = (u64)div_value * BILLION + billionths;\n\tcombined <<= div->u.s.frac_width;\n\n\treturn DIV_ROUND_CLOSEST_ULL(combined, BILLION);\n}\n\n \nstatic inline u64\nscaled_div_min(struct bcm_clk_div *div)\n{\n\tif (divider_is_fixed(div))\n\t\treturn (u64)div->u.fixed;\n\n\treturn scaled_div_value(div, 0);\n}\n\n \nu64 scaled_div_max(struct bcm_clk_div *div)\n{\n\tu32 reg_div;\n\n\tif (divider_is_fixed(div))\n\t\treturn (u64)div->u.fixed;\n\n\treg_div = ((u32)1 << div->u.s.width) - 1;\n\n\treturn scaled_div_value(div, reg_div);\n}\n\n \nstatic inline u32\ndivider(struct bcm_clk_div *div, u64 scaled_div)\n{\n\tBUG_ON(scaled_div < scaled_div_min(div));\n\tBUG_ON(scaled_div > scaled_div_max(div));\n\n\treturn (u32)(scaled_div - ((u64)1 << div->u.s.frac_width));\n}\n\n \nstatic inline u64\nscale_rate(struct bcm_clk_div *div, u32 rate)\n{\n\tif (divider_is_fixed(div))\n\t\treturn (u64)rate;\n\n\treturn (u64)rate << div->u.s.frac_width;\n}\n\n \n\n \nstatic inline u32 __ccu_read(struct ccu_data *ccu, u32 reg_offset)\n{\n\treturn readl(ccu->base + reg_offset);\n}\n\n \nstatic inline void\n__ccu_write(struct ccu_data *ccu, u32 reg_offset, u32 reg_val)\n{\n\twritel(reg_val, ccu->base + reg_offset);\n}\n\nstatic inline unsigned long ccu_lock(struct ccu_data *ccu)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ccu->lock, flags);\n\n\treturn flags;\n}\nstatic inline void ccu_unlock(struct ccu_data *ccu, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&ccu->lock, flags);\n}\n\n \nstatic inline void __ccu_write_enable(struct ccu_data *ccu)\n{\n\tif (ccu->write_enabled) {\n\t\tpr_err(\"%s: access already enabled for %s\\n\", __func__,\n\t\t\tccu->name);\n\t\treturn;\n\t}\n\tccu->write_enabled = true;\n\t__ccu_write(ccu, 0, CCU_ACCESS_PASSWORD | 1);\n}\n\nstatic inline void __ccu_write_disable(struct ccu_data *ccu)\n{\n\tif (!ccu->write_enabled) {\n\t\tpr_err(\"%s: access wasn't enabled for %s\\n\", __func__,\n\t\t\tccu->name);\n\t\treturn;\n\t}\n\n\t__ccu_write(ccu, 0, CCU_ACCESS_PASSWORD);\n\tccu->write_enabled = false;\n}\n\n \nstatic inline bool\n__ccu_wait_bit(struct ccu_data *ccu, u32 reg_offset, u32 bit, bool want)\n{\n\tunsigned int tries;\n\tu32 bit_mask = 1 << bit;\n\n\tfor (tries = 0; tries < CLK_GATE_DELAY_LOOP; tries++) {\n\t\tu32 val;\n\t\tbool bit_val;\n\n\t\tval = __ccu_read(ccu, reg_offset);\n\t\tbit_val = (val & bit_mask) != 0;\n\t\tif (bit_val == want)\n\t\t\treturn true;\n\t\tudelay(1);\n\t}\n\tpr_warn(\"%s: %s/0x%04x bit %u was never %s\\n\", __func__,\n\t\tccu->name, reg_offset, bit, want ? \"set\" : \"clear\");\n\n\treturn false;\n}\n\n \n\nstatic bool __ccu_policy_engine_start(struct ccu_data *ccu, bool sync)\n{\n\tstruct bcm_policy_ctl *control = &ccu->policy.control;\n\tu32 offset;\n\tu32 go_bit;\n\tu32 mask;\n\tbool ret;\n\n\t \n\tif (!policy_ctl_exists(control))\n\t\treturn true;\n\n\toffset = control->offset;\n\tgo_bit = control->go_bit;\n\n\t \n\tret = __ccu_wait_bit(ccu, offset, go_bit, false);\n\tif (!ret) {\n\t\tpr_err(\"%s: ccu %s policy engine wouldn't go idle\\n\",\n\t\t\t__func__, ccu->name);\n\t\treturn false;\n\t}\n\n\t \n\tmask = (u32)1 << go_bit;\n\tif (sync)\n\t\tmask |= 1 << control->atl_bit;\n\telse\n\t\tmask |= 1 << control->ac_bit;\n\t__ccu_write(ccu, offset, mask);\n\n\t \n\tret = __ccu_wait_bit(ccu, offset, go_bit, false);\n\tif (!ret)\n\t\tpr_err(\"%s: ccu %s policy engine never started\\n\",\n\t\t\t__func__, ccu->name);\n\n\treturn ret;\n}\n\nstatic bool __ccu_policy_engine_stop(struct ccu_data *ccu)\n{\n\tstruct bcm_lvm_en *enable = &ccu->policy.enable;\n\tu32 offset;\n\tu32 enable_bit;\n\tbool ret;\n\n\t \n\tif (!policy_lvm_en_exists(enable))\n\t\treturn true;\n\n\t \n\toffset = enable->offset;\n\tenable_bit = enable->bit;\n\tret = __ccu_wait_bit(ccu, offset, enable_bit, false);\n\tif (!ret) {\n\t\tpr_err(\"%s: ccu %s policy engine already stopped\\n\",\n\t\t\t__func__, ccu->name);\n\t\treturn false;\n\t}\n\n\t \n\t__ccu_write(ccu, offset, (u32)1 << enable_bit);\n\n\t \n\tret = __ccu_wait_bit(ccu, offset, enable_bit, false);\n\tif (!ret)\n\t\tpr_err(\"%s: ccu %s policy engine never stopped\\n\",\n\t\t\t__func__, ccu->name);\n\n\treturn ret;\n}\n\n \nstatic bool policy_init(struct ccu_data *ccu, struct bcm_clk_policy *policy)\n{\n\tu32 offset;\n\tu32 mask;\n\tint i;\n\tbool ret;\n\n\tif (!policy_exists(policy))\n\t\treturn true;\n\n\t \n\tif (!__ccu_policy_engine_stop(ccu)) {\n\t\tpr_err(\"%s: unable to stop CCU %s policy engine\\n\",\n\t\t\t__func__, ccu->name);\n\t\treturn false;\n\t}\n\n\t \n\toffset = policy->offset;\n\tmask = (u32)1 << policy->bit;\n\tfor (i = 0; i < CCU_POLICY_COUNT; i++) {\n\t\tu32 reg_val;\n\n\t\treg_val = __ccu_read(ccu, offset);\n\t\treg_val |= mask;\n\t\t__ccu_write(ccu, offset, reg_val);\n\t\toffset += sizeof(u32);\n\t}\n\n\t \n\tret = __ccu_policy_engine_start(ccu, true);\n\tif (!ret)\n\t\tpr_err(\"%s: unable to restart CCU %s policy engine\\n\",\n\t\t\t__func__, ccu->name);\n\n\treturn ret;\n}\n\n \n\n \nstatic bool\n__is_clk_gate_enabled(struct ccu_data *ccu, struct bcm_clk_gate *gate)\n{\n\tu32 bit_mask;\n\tu32 reg_val;\n\n\t \n\tif (!gate_exists(gate))\n\t\treturn true;\n\n\tbit_mask = 1 << gate->status_bit;\n\treg_val = __ccu_read(ccu, gate->offset);\n\n\treturn (reg_val & bit_mask) != 0;\n}\n\n \nstatic bool\nis_clk_gate_enabled(struct ccu_data *ccu, struct bcm_clk_gate *gate)\n{\n\tlong flags;\n\tbool ret;\n\n\t \n\tif (!gate_exists(gate))\n\t\treturn true;\n\n\tflags = ccu_lock(ccu);\n\tret = __is_clk_gate_enabled(ccu, gate);\n\tccu_unlock(ccu, flags);\n\n\treturn ret;\n}\n\n \nstatic bool\n__gate_commit(struct ccu_data *ccu, struct bcm_clk_gate *gate)\n{\n\tu32 reg_val;\n\tu32 mask;\n\tbool enabled = false;\n\n\tBUG_ON(!gate_exists(gate));\n\tif (!gate_is_sw_controllable(gate))\n\t\treturn true;\t\t \n\n\treg_val = __ccu_read(ccu, gate->offset);\n\n\t \n\tif (gate_is_hw_controllable(gate)) {\n\t\tmask = (u32)1 << gate->hw_sw_sel_bit;\n\t\tif (gate_is_sw_managed(gate))\n\t\t\treg_val |= mask;\n\t\telse\n\t\t\treg_val &= ~mask;\n\t}\n\n\t \n\tmask = (u32)1 << gate->en_bit;\n\tif (gate_is_sw_managed(gate) && (enabled = gate_is_enabled(gate)) &&\n\t\t\t!gate_is_no_disable(gate))\n\t\treg_val |= mask;\n\telse\n\t\treg_val &= ~mask;\n\n\t__ccu_write(ccu, gate->offset, reg_val);\n\n\t \n\tif (!gate_is_sw_managed(gate))\n\t\treturn true;\n\n\t \n\treturn __ccu_wait_bit(ccu, gate->offset, gate->status_bit, enabled);\n}\n\n \nstatic bool gate_init(struct ccu_data *ccu, struct bcm_clk_gate *gate)\n{\n\tif (!gate_exists(gate))\n\t\treturn true;\n\treturn __gate_commit(ccu, gate);\n}\n\n \nstatic bool\n__clk_gate(struct ccu_data *ccu, struct bcm_clk_gate *gate, bool enable)\n{\n\tbool ret;\n\n\tif (!gate_exists(gate) || !gate_is_sw_managed(gate))\n\t\treturn true;\t \n\n\tif (!enable && gate_is_no_disable(gate)) {\n\t\tpr_warn(\"%s: invalid gate disable request (ignoring)\\n\",\n\t\t\t__func__);\n\t\treturn true;\n\t}\n\n\tif (enable == gate_is_enabled(gate))\n\t\treturn true;\t \n\n\tgate_flip_enabled(gate);\n\tret = __gate_commit(ccu, gate);\n\tif (!ret)\n\t\tgate_flip_enabled(gate);\t \n\n\treturn ret;\n}\n\n \nstatic int clk_gate(struct ccu_data *ccu, const char *name,\n\t\t\tstruct bcm_clk_gate *gate, bool enable)\n{\n\tunsigned long flags;\n\tbool success;\n\n\t \n\tif (!gate_exists(gate) || !gate_is_sw_managed(gate))\n\t\treturn 0;\n\tif (!enable && gate_is_no_disable(gate))\n\t\treturn 0;\n\n\tflags = ccu_lock(ccu);\n\t__ccu_write_enable(ccu);\n\n\tsuccess = __clk_gate(ccu, gate, enable);\n\n\t__ccu_write_disable(ccu);\n\tccu_unlock(ccu, flags);\n\n\tif (success)\n\t\treturn 0;\n\n\tpr_err(\"%s: failed to %s gate for %s\\n\", __func__,\n\t\tenable ? \"enable\" : \"disable\", name);\n\n\treturn -EIO;\n}\n\n \n\n \nstatic bool hyst_init(struct ccu_data *ccu, struct bcm_clk_hyst *hyst)\n{\n\tu32 offset;\n\tu32 reg_val;\n\tu32 mask;\n\n\tif (!hyst_exists(hyst))\n\t\treturn true;\n\n\toffset = hyst->offset;\n\tmask = (u32)1 << hyst->en_bit;\n\tmask |= (u32)1 << hyst->val_bit;\n\n\treg_val = __ccu_read(ccu, offset);\n\treg_val |= mask;\n\t__ccu_write(ccu, offset, reg_val);\n\n\treturn true;\n}\n\n \n\n \nstatic bool __clk_trigger(struct ccu_data *ccu, struct bcm_clk_trig *trig)\n{\n\t \n\t__ccu_write(ccu, trig->offset, 1 << trig->bit);\n\n\treturn __ccu_wait_bit(ccu, trig->offset, trig->bit, false);\n}\n\n \n\n \nstatic u64 divider_read_scaled(struct ccu_data *ccu, struct bcm_clk_div *div)\n{\n\tunsigned long flags;\n\tu32 reg_val;\n\tu32 reg_div;\n\n\tif (divider_is_fixed(div))\n\t\treturn (u64)div->u.fixed;\n\n\tflags = ccu_lock(ccu);\n\treg_val = __ccu_read(ccu, div->u.s.offset);\n\tccu_unlock(ccu, flags);\n\n\t \n\treg_div = bitfield_extract(reg_val, div->u.s.shift, div->u.s.width);\n\n\t \n\treturn scaled_div_value(div, reg_div);\n}\n\n \nstatic int __div_commit(struct ccu_data *ccu, struct bcm_clk_gate *gate,\n\t\t\tstruct bcm_clk_div *div, struct bcm_clk_trig *trig)\n{\n\tbool enabled;\n\tu32 reg_div;\n\tu32 reg_val;\n\tint ret = 0;\n\n\tBUG_ON(divider_is_fixed(div));\n\n\t \n\tif (div->u.s.scaled_div == BAD_SCALED_DIV_VALUE) {\n\t\treg_val = __ccu_read(ccu, div->u.s.offset);\n\t\treg_div = bitfield_extract(reg_val, div->u.s.shift,\n\t\t\t\t\t\tdiv->u.s.width);\n\t\tdiv->u.s.scaled_div = scaled_div_value(div, reg_div);\n\n\t\treturn 0;\n\t}\n\n\t \n\treg_div = divider(div, div->u.s.scaled_div);\n\n\t \n\tenabled = __is_clk_gate_enabled(ccu, gate);\n\tif (!enabled && !__clk_gate(ccu, gate, true)) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\t \n\treg_val = __ccu_read(ccu, div->u.s.offset);\n\treg_val = bitfield_replace(reg_val, div->u.s.shift, div->u.s.width,\n\t\t\t\t\treg_div);\n\t__ccu_write(ccu, div->u.s.offset, reg_val);\n\n\t \n\tif (!__clk_trigger(ccu, trig))\n\t\tret = -EIO;\n\n\t \n\tif (!enabled && !__clk_gate(ccu, gate, false))\n\t\tret = ret ? ret : -ENXIO;\t \nout:\n\treturn ret;\n}\n\n \nstatic bool div_init(struct ccu_data *ccu, struct bcm_clk_gate *gate,\n\t\t\tstruct bcm_clk_div *div, struct bcm_clk_trig *trig)\n{\n\tif (!divider_exists(div) || divider_is_fixed(div))\n\t\treturn true;\n\treturn !__div_commit(ccu, gate, div, trig);\n}\n\nstatic int divider_write(struct ccu_data *ccu, struct bcm_clk_gate *gate,\n\t\t\tstruct bcm_clk_div *div, struct bcm_clk_trig *trig,\n\t\t\tu64 scaled_div)\n{\n\tunsigned long flags;\n\tu64 previous;\n\tint ret;\n\n\tBUG_ON(divider_is_fixed(div));\n\n\tprevious = div->u.s.scaled_div;\n\tif (previous == scaled_div)\n\t\treturn 0;\t \n\n\tdiv->u.s.scaled_div = scaled_div;\n\n\tflags = ccu_lock(ccu);\n\t__ccu_write_enable(ccu);\n\n\tret = __div_commit(ccu, gate, div, trig);\n\n\t__ccu_write_disable(ccu);\n\tccu_unlock(ccu, flags);\n\n\tif (ret)\n\t\tdiv->u.s.scaled_div = previous;\t\t \n\n\treturn ret;\n\n}\n\n \n\n \nstatic unsigned long clk_recalc_rate(struct ccu_data *ccu,\n\t\t\tstruct bcm_clk_div *div, struct bcm_clk_div *pre_div,\n\t\t\tunsigned long parent_rate)\n{\n\tu64 scaled_parent_rate;\n\tu64 scaled_div;\n\tu64 result;\n\n\tif (!divider_exists(div))\n\t\treturn parent_rate;\n\n\tif (parent_rate > (unsigned long)LONG_MAX)\n\t\treturn 0;\t \n\n\t \n\tif (pre_div && divider_exists(pre_div)) {\n\t\tu64 scaled_rate;\n\n\t\tscaled_rate = scale_rate(pre_div, parent_rate);\n\t\tscaled_rate = scale_rate(div, scaled_rate);\n\t\tscaled_div = divider_read_scaled(ccu, pre_div);\n\t\tscaled_parent_rate = DIV_ROUND_CLOSEST_ULL(scaled_rate,\n\t\t\t\t\t\t\tscaled_div);\n\t} else  {\n\t\tscaled_parent_rate = scale_rate(div, parent_rate);\n\t}\n\n\t \n\tscaled_div = divider_read_scaled(ccu, div);\n\tresult = DIV_ROUND_CLOSEST_ULL(scaled_parent_rate, scaled_div);\n\n\treturn (unsigned long)result;\n}\n\n \nstatic long round_rate(struct ccu_data *ccu, struct bcm_clk_div *div,\n\t\t\t\tstruct bcm_clk_div *pre_div,\n\t\t\t\tunsigned long rate, unsigned long parent_rate,\n\t\t\t\tu64 *scaled_div)\n{\n\tu64 scaled_parent_rate;\n\tu64 min_scaled_div;\n\tu64 max_scaled_div;\n\tu64 best_scaled_div;\n\tu64 result;\n\n\tBUG_ON(!divider_exists(div));\n\tBUG_ON(!rate);\n\tBUG_ON(parent_rate > (u64)LONG_MAX);\n\n\t \n\tif (divider_exists(pre_div)) {\n\t\tu64 scaled_rate;\n\t\tu64 scaled_pre_div;\n\n\t\tscaled_rate = scale_rate(pre_div, parent_rate);\n\t\tscaled_rate = scale_rate(div, scaled_rate);\n\t\tscaled_pre_div = divider_read_scaled(ccu, pre_div);\n\t\tscaled_parent_rate = DIV_ROUND_CLOSEST_ULL(scaled_rate,\n\t\t\t\t\t\t\tscaled_pre_div);\n\t} else {\n\t\tscaled_parent_rate = scale_rate(div, parent_rate);\n\t}\n\n\t \n\tif (!divider_is_fixed(div)) {\n\t\tbest_scaled_div = DIV_ROUND_CLOSEST_ULL(scaled_parent_rate,\n\t\t\t\t\t\t\trate);\n\t\tmin_scaled_div = scaled_div_min(div);\n\t\tmax_scaled_div = scaled_div_max(div);\n\t\tif (best_scaled_div > max_scaled_div)\n\t\t\tbest_scaled_div = max_scaled_div;\n\t\telse if (best_scaled_div < min_scaled_div)\n\t\t\tbest_scaled_div = min_scaled_div;\n\t} else {\n\t\tbest_scaled_div = divider_read_scaled(ccu, div);\n\t}\n\n\t \n\tresult = DIV_ROUND_CLOSEST_ULL(scaled_parent_rate, best_scaled_div);\n\n\tif (scaled_div)\n\t\t*scaled_div = best_scaled_div;\n\n\treturn (long)result;\n}\n\n \n\n \nstatic u8 parent_index(struct bcm_clk_sel *sel, u8 parent_sel)\n{\n\tu8 i;\n\n\tBUG_ON(sel->parent_count > (u32)U8_MAX);\n\tfor (i = 0; i < sel->parent_count; i++)\n\t\tif (sel->parent_sel[i] == parent_sel)\n\t\t\treturn i;\n\treturn BAD_CLK_INDEX;\n}\n\n \nstatic u8 selector_read_index(struct ccu_data *ccu, struct bcm_clk_sel *sel)\n{\n\tunsigned long flags;\n\tu32 reg_val;\n\tu32 parent_sel;\n\tu8 index;\n\n\t \n\tif (!selector_exists(sel))\n\t\treturn 0;\n\n\t \n\tflags = ccu_lock(ccu);\n\treg_val = __ccu_read(ccu, sel->offset);\n\tccu_unlock(ccu, flags);\n\n\tparent_sel = bitfield_extract(reg_val, sel->shift, sel->width);\n\n\t \n\tindex = parent_index(sel, parent_sel);\n\tif (index == BAD_CLK_INDEX)\n\t\tpr_err(\"%s: out-of-range parent selector %u (%s 0x%04x)\\n\",\n\t\t\t__func__, parent_sel, ccu->name, sel->offset);\n\n\treturn index;\n}\n\n \nstatic int\n__sel_commit(struct ccu_data *ccu, struct bcm_clk_gate *gate,\n\t\t\tstruct bcm_clk_sel *sel, struct bcm_clk_trig *trig)\n{\n\tu32 parent_sel;\n\tu32 reg_val;\n\tbool enabled;\n\tint ret = 0;\n\n\tBUG_ON(!selector_exists(sel));\n\n\t \n\tif (sel->clk_index == BAD_CLK_INDEX) {\n\t\tu8 index;\n\n\t\treg_val = __ccu_read(ccu, sel->offset);\n\t\tparent_sel = bitfield_extract(reg_val, sel->shift, sel->width);\n\t\tindex = parent_index(sel, parent_sel);\n\t\tif (index == BAD_CLK_INDEX)\n\t\t\treturn -EINVAL;\n\t\tsel->clk_index = index;\n\n\t\treturn 0;\n\t}\n\n\tBUG_ON((u32)sel->clk_index >= sel->parent_count);\n\tparent_sel = sel->parent_sel[sel->clk_index];\n\n\t \n\tenabled = __is_clk_gate_enabled(ccu, gate);\n\tif (!enabled && !__clk_gate(ccu, gate, true))\n\t\treturn -ENXIO;\n\n\t \n\treg_val = __ccu_read(ccu, sel->offset);\n\treg_val = bitfield_replace(reg_val, sel->shift, sel->width, parent_sel);\n\t__ccu_write(ccu, sel->offset, reg_val);\n\n\t \n\tif (!__clk_trigger(ccu, trig))\n\t\tret = -EIO;\n\n\t \n\tif (!enabled && !__clk_gate(ccu, gate, false))\n\t\tret = ret ? ret : -ENXIO;\t \n\n\treturn ret;\n}\n\n \nstatic bool sel_init(struct ccu_data *ccu, struct bcm_clk_gate *gate,\n\t\t\tstruct bcm_clk_sel *sel, struct bcm_clk_trig *trig)\n{\n\tif (!selector_exists(sel))\n\t\treturn true;\n\treturn !__sel_commit(ccu, gate, sel, trig);\n}\n\n \nstatic int selector_write(struct ccu_data *ccu, struct bcm_clk_gate *gate,\n\t\t\tstruct bcm_clk_sel *sel, struct bcm_clk_trig *trig,\n\t\t\tu8 index)\n{\n\tunsigned long flags;\n\tu8 previous;\n\tint ret;\n\n\tprevious = sel->clk_index;\n\tif (previous == index)\n\t\treturn 0;\t \n\n\tsel->clk_index = index;\n\n\tflags = ccu_lock(ccu);\n\t__ccu_write_enable(ccu);\n\n\tret = __sel_commit(ccu, gate, sel, trig);\n\n\t__ccu_write_disable(ccu);\n\tccu_unlock(ccu, flags);\n\n\tif (ret)\n\t\tsel->clk_index = previous;\t \n\n\treturn ret;\n}\n\n \n\nstatic int kona_peri_clk_enable(struct clk_hw *hw)\n{\n\tstruct kona_clk *bcm_clk = to_kona_clk(hw);\n\tstruct bcm_clk_gate *gate = &bcm_clk->u.peri->gate;\n\n\treturn clk_gate(bcm_clk->ccu, bcm_clk->init_data.name, gate, true);\n}\n\nstatic void kona_peri_clk_disable(struct clk_hw *hw)\n{\n\tstruct kona_clk *bcm_clk = to_kona_clk(hw);\n\tstruct bcm_clk_gate *gate = &bcm_clk->u.peri->gate;\n\n\t(void)clk_gate(bcm_clk->ccu, bcm_clk->init_data.name, gate, false);\n}\n\nstatic int kona_peri_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct kona_clk *bcm_clk = to_kona_clk(hw);\n\tstruct bcm_clk_gate *gate = &bcm_clk->u.peri->gate;\n\n\treturn is_clk_gate_enabled(bcm_clk->ccu, gate) ? 1 : 0;\n}\n\nstatic unsigned long kona_peri_clk_recalc_rate(struct clk_hw *hw,\n\t\t\tunsigned long parent_rate)\n{\n\tstruct kona_clk *bcm_clk = to_kona_clk(hw);\n\tstruct peri_clk_data *data = bcm_clk->u.peri;\n\n\treturn clk_recalc_rate(bcm_clk->ccu, &data->div, &data->pre_div,\n\t\t\t\tparent_rate);\n}\n\nstatic long kona_peri_clk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\tunsigned long *parent_rate)\n{\n\tstruct kona_clk *bcm_clk = to_kona_clk(hw);\n\tstruct bcm_clk_div *div = &bcm_clk->u.peri->div;\n\n\tif (!divider_exists(div))\n\t\treturn clk_hw_get_rate(hw);\n\n\t \n\treturn round_rate(bcm_clk->ccu, div, &bcm_clk->u.peri->pre_div,\n\t\t\t\trate ? rate : 1, *parent_rate, NULL);\n}\n\nstatic int kona_peri_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t\tstruct clk_rate_request *req)\n{\n\tstruct kona_clk *bcm_clk = to_kona_clk(hw);\n\tstruct clk_hw *current_parent;\n\tunsigned long parent_rate;\n\tunsigned long best_delta;\n\tunsigned long best_rate;\n\tu32 parent_count;\n\tlong rate;\n\tu32 which;\n\n\t \n\tWARN_ON_ONCE(bcm_clk->init_data.flags & CLK_SET_RATE_NO_REPARENT);\n\tparent_count = (u32)bcm_clk->init_data.num_parents;\n\tif (parent_count < 2) {\n\t\trate = kona_peri_clk_round_rate(hw, req->rate,\n\t\t\t\t\t\t&req->best_parent_rate);\n\t\tif (rate < 0)\n\t\t\treturn rate;\n\n\t\treq->rate = rate;\n\t\treturn 0;\n\t}\n\n\t \n\tcurrent_parent = clk_hw_get_parent(hw);\n\tparent_rate = clk_hw_get_rate(current_parent);\n\tbest_rate = kona_peri_clk_round_rate(hw, req->rate, &parent_rate);\n\tbest_delta = abs(best_rate - req->rate);\n\n\t \n\tfor (which = 0; which < parent_count; which++) {\n\t\tstruct clk_hw *parent = clk_hw_get_parent_by_index(hw, which);\n\t\tunsigned long delta;\n\t\tunsigned long other_rate;\n\n\t\tBUG_ON(!parent);\n\t\tif (parent == current_parent)\n\t\t\tcontinue;\n\n\t\t \n\t\tparent_rate = clk_hw_get_rate(parent);\n\t\tother_rate = kona_peri_clk_round_rate(hw, req->rate,\n\t\t\t\t\t\t      &parent_rate);\n\t\tdelta = abs(other_rate - req->rate);\n\t\tif (delta < best_delta) {\n\t\t\tbest_delta = delta;\n\t\t\tbest_rate = other_rate;\n\t\t\treq->best_parent_hw = parent;\n\t\t\treq->best_parent_rate = parent_rate;\n\t\t}\n\t}\n\n\treq->rate = best_rate;\n\treturn 0;\n}\n\nstatic int kona_peri_clk_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct kona_clk *bcm_clk = to_kona_clk(hw);\n\tstruct peri_clk_data *data = bcm_clk->u.peri;\n\tstruct bcm_clk_sel *sel = &data->sel;\n\tstruct bcm_clk_trig *trig;\n\tint ret;\n\n\tBUG_ON(index >= sel->parent_count);\n\n\t \n\tif (!selector_exists(sel))\n\t\treturn 0;\n\n\t \n\ttrig = trigger_exists(&data->pre_trig) ? &data->pre_trig\n\t\t\t\t\t       : &data->trig;\n\n\tret = selector_write(bcm_clk->ccu, &data->gate, sel, trig, index);\n\tif (ret == -ENXIO) {\n\t\tpr_err(\"%s: gating failure for %s\\n\", __func__,\n\t\t\tbcm_clk->init_data.name);\n\t\tret = -EIO;\t \n\t} else if (ret == -EIO) {\n\t\tpr_err(\"%s: %strigger failed for %s\\n\", __func__,\n\t\t\ttrig == &data->pre_trig ? \"pre-\" : \"\",\n\t\t\tbcm_clk->init_data.name);\n\t}\n\n\treturn ret;\n}\n\nstatic u8 kona_peri_clk_get_parent(struct clk_hw *hw)\n{\n\tstruct kona_clk *bcm_clk = to_kona_clk(hw);\n\tstruct peri_clk_data *data = bcm_clk->u.peri;\n\tu8 index;\n\n\tindex = selector_read_index(bcm_clk->ccu, &data->sel);\n\n\t \n\treturn index == BAD_CLK_INDEX ? 0 : index;\n}\n\nstatic int kona_peri_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\tunsigned long parent_rate)\n{\n\tstruct kona_clk *bcm_clk = to_kona_clk(hw);\n\tstruct peri_clk_data *data = bcm_clk->u.peri;\n\tstruct bcm_clk_div *div = &data->div;\n\tu64 scaled_div = 0;\n\tint ret;\n\n\tif (parent_rate > (unsigned long)LONG_MAX)\n\t\treturn -EINVAL;\n\n\tif (rate == clk_hw_get_rate(hw))\n\t\treturn 0;\n\n\tif (!divider_exists(div))\n\t\treturn rate == parent_rate ? 0 : -EINVAL;\n\n\t \n\tif (divider_is_fixed(&data->div))\n\t\treturn rate == parent_rate ? 0 : -EINVAL;\n\n\t \n\t(void)round_rate(bcm_clk->ccu, div, &data->pre_div,\n\t\t\t\trate ? rate : 1, parent_rate, &scaled_div);\n\n\t \n\tret = divider_write(bcm_clk->ccu, &data->gate, &data->div,\n\t\t\t\t&data->trig, scaled_div);\n\tif (ret == -ENXIO) {\n\t\tpr_err(\"%s: gating failure for %s\\n\", __func__,\n\t\t\tbcm_clk->init_data.name);\n\t\tret = -EIO;\t \n\t} else if (ret == -EIO) {\n\t\tpr_err(\"%s: trigger failed for %s\\n\", __func__,\n\t\t\tbcm_clk->init_data.name);\n\t}\n\n\treturn ret;\n}\n\nstruct clk_ops kona_peri_clk_ops = {\n\t.enable = kona_peri_clk_enable,\n\t.disable = kona_peri_clk_disable,\n\t.is_enabled = kona_peri_clk_is_enabled,\n\t.recalc_rate = kona_peri_clk_recalc_rate,\n\t.determine_rate = kona_peri_clk_determine_rate,\n\t.set_parent = kona_peri_clk_set_parent,\n\t.get_parent = kona_peri_clk_get_parent,\n\t.set_rate = kona_peri_clk_set_rate,\n};\n\n \nstatic bool __peri_clk_init(struct kona_clk *bcm_clk)\n{\n\tstruct ccu_data *ccu = bcm_clk->ccu;\n\tstruct peri_clk_data *peri = bcm_clk->u.peri;\n\tconst char *name = bcm_clk->init_data.name;\n\tstruct bcm_clk_trig *trig;\n\n\tBUG_ON(bcm_clk->type != bcm_clk_peri);\n\n\tif (!policy_init(ccu, &peri->policy)) {\n\t\tpr_err(\"%s: error initializing policy for %s\\n\",\n\t\t\t__func__, name);\n\t\treturn false;\n\t}\n\tif (!gate_init(ccu, &peri->gate)) {\n\t\tpr_err(\"%s: error initializing gate for %s\\n\", __func__, name);\n\t\treturn false;\n\t}\n\tif (!hyst_init(ccu, &peri->hyst)) {\n\t\tpr_err(\"%s: error initializing hyst for %s\\n\", __func__, name);\n\t\treturn false;\n\t}\n\tif (!div_init(ccu, &peri->gate, &peri->div, &peri->trig)) {\n\t\tpr_err(\"%s: error initializing divider for %s\\n\", __func__,\n\t\t\tname);\n\t\treturn false;\n\t}\n\n\t \n\ttrig = trigger_exists(&peri->pre_trig) ? &peri->pre_trig\n\t\t\t\t\t       : &peri->trig;\n\n\tif (!div_init(ccu, &peri->gate, &peri->pre_div, trig)) {\n\t\tpr_err(\"%s: error initializing pre-divider for %s\\n\", __func__,\n\t\t\tname);\n\t\treturn false;\n\t}\n\n\tif (!sel_init(ccu, &peri->gate, &peri->sel, trig)) {\n\t\tpr_err(\"%s: error initializing selector for %s\\n\", __func__,\n\t\t\tname);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool __kona_clk_init(struct kona_clk *bcm_clk)\n{\n\tswitch (bcm_clk->type) {\n\tcase bcm_clk_peri:\n\t\treturn __peri_clk_init(bcm_clk);\n\tdefault:\n\t\tBUG();\n\t}\n\treturn false;\n}\n\n \nbool __init kona_ccu_init(struct ccu_data *ccu)\n{\n\tunsigned long flags;\n\tunsigned int which;\n\tstruct kona_clk *kona_clks = ccu->kona_clks;\n\tbool success = true;\n\n\tflags = ccu_lock(ccu);\n\t__ccu_write_enable(ccu);\n\n\tfor (which = 0; which < ccu->clk_num; which++) {\n\t\tstruct kona_clk *bcm_clk = &kona_clks[which];\n\n\t\tif (!bcm_clk->ccu)\n\t\t\tcontinue;\n\n\t\tsuccess &= __kona_clk_init(bcm_clk);\n\t}\n\n\t__ccu_write_disable(ccu);\n\tccu_unlock(ccu, flags);\n\treturn success;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}