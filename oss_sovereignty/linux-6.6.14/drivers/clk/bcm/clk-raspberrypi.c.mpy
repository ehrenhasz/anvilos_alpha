{
  "module_name": "clk-raspberrypi.c",
  "hash_id": "d23802dd9db369b6398fdb604c951a324deee27d744c09c69077519270f24148",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/bcm/clk-raspberrypi.c",
  "human_readable_source": "\n \n\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include <soc/bcm2835/raspberrypi-firmware.h>\n\nstatic char *rpi_firmware_clk_names[] = {\n\t[RPI_FIRMWARE_EMMC_CLK_ID]\t= \"emmc\",\n\t[RPI_FIRMWARE_UART_CLK_ID]\t= \"uart\",\n\t[RPI_FIRMWARE_ARM_CLK_ID]\t= \"arm\",\n\t[RPI_FIRMWARE_CORE_CLK_ID]\t= \"core\",\n\t[RPI_FIRMWARE_V3D_CLK_ID]\t= \"v3d\",\n\t[RPI_FIRMWARE_H264_CLK_ID]\t= \"h264\",\n\t[RPI_FIRMWARE_ISP_CLK_ID]\t= \"isp\",\n\t[RPI_FIRMWARE_SDRAM_CLK_ID]\t= \"sdram\",\n\t[RPI_FIRMWARE_PIXEL_CLK_ID]\t= \"pixel\",\n\t[RPI_FIRMWARE_PWM_CLK_ID]\t= \"pwm\",\n\t[RPI_FIRMWARE_HEVC_CLK_ID]\t= \"hevc\",\n\t[RPI_FIRMWARE_EMMC2_CLK_ID]\t= \"emmc2\",\n\t[RPI_FIRMWARE_M2MC_CLK_ID]\t= \"m2mc\",\n\t[RPI_FIRMWARE_PIXEL_BVB_CLK_ID]\t= \"pixel-bvb\",\n\t[RPI_FIRMWARE_VEC_CLK_ID]\t= \"vec\",\n};\n\n#define RPI_FIRMWARE_STATE_ENABLE_BIT\tBIT(0)\n#define RPI_FIRMWARE_STATE_WAIT_BIT\tBIT(1)\n\nstruct raspberrypi_clk_variant;\n\nstruct raspberrypi_clk {\n\tstruct device *dev;\n\tstruct rpi_firmware *firmware;\n\tstruct platform_device *cpufreq;\n};\n\nstruct raspberrypi_clk_data {\n\tstruct clk_hw hw;\n\n\tunsigned int id;\n\tstruct raspberrypi_clk_variant *variant;\n\n\tstruct raspberrypi_clk *rpi;\n};\n\nstruct raspberrypi_clk_variant {\n\tbool\t\texport;\n\tchar\t\t*clkdev;\n\tunsigned long\tmin_rate;\n\tbool\t\tminimize;\n};\n\nstatic struct raspberrypi_clk_variant\nraspberrypi_clk_variants[RPI_FIRMWARE_NUM_CLK_ID] = {\n\t[RPI_FIRMWARE_ARM_CLK_ID] = {\n\t\t.export = true,\n\t\t.clkdev = \"cpu0\",\n\t},\n\t[RPI_FIRMWARE_CORE_CLK_ID] = {\n\t\t.export = true,\n\n\t\t \n\t\t.minimize = true,\n\t},\n\t[RPI_FIRMWARE_M2MC_CLK_ID] = {\n\t\t.export = true,\n\n\t\t \n\t\t.min_rate = 120000000,\n\n\t\t \n\t\t.minimize = true,\n\t},\n\t[RPI_FIRMWARE_V3D_CLK_ID] = {\n\t\t.export = true,\n\t},\n\t[RPI_FIRMWARE_PIXEL_CLK_ID] = {\n\t\t.export = true,\n\t},\n\t[RPI_FIRMWARE_HEVC_CLK_ID] = {\n\t\t.export = true,\n\t},\n\t[RPI_FIRMWARE_PIXEL_BVB_CLK_ID] = {\n\t\t.export = true,\n\t},\n\t[RPI_FIRMWARE_VEC_CLK_ID] = {\n\t\t.export = true,\n\t},\n};\n\n \nstruct raspberrypi_firmware_prop {\n\t__le32 id;\n\t__le32 val;\n\t__le32 disable_turbo;\n} __packed;\n\nstatic int raspberrypi_clock_property(struct rpi_firmware *firmware,\n\t\t\t\t      const struct raspberrypi_clk_data *data,\n\t\t\t\t      u32 tag, u32 *val)\n{\n\tstruct raspberrypi_firmware_prop msg = {\n\t\t.id = cpu_to_le32(data->id),\n\t\t.val = cpu_to_le32(*val),\n\t\t.disable_turbo = cpu_to_le32(1),\n\t};\n\tint ret;\n\n\tret = rpi_firmware_property(firmware, tag, &msg, sizeof(msg));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = le32_to_cpu(msg.val);\n\n\treturn 0;\n}\n\nstatic int raspberrypi_fw_is_prepared(struct clk_hw *hw)\n{\n\tstruct raspberrypi_clk_data *data =\n\t\tcontainer_of(hw, struct raspberrypi_clk_data, hw);\n\tstruct raspberrypi_clk *rpi = data->rpi;\n\tu32 val = 0;\n\tint ret;\n\n\tret = raspberrypi_clock_property(rpi->firmware, data,\n\t\t\t\t\t RPI_FIRMWARE_GET_CLOCK_STATE, &val);\n\tif (ret)\n\t\treturn 0;\n\n\treturn !!(val & RPI_FIRMWARE_STATE_ENABLE_BIT);\n}\n\n\nstatic unsigned long raspberrypi_fw_get_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct raspberrypi_clk_data *data =\n\t\tcontainer_of(hw, struct raspberrypi_clk_data, hw);\n\tstruct raspberrypi_clk *rpi = data->rpi;\n\tu32 val = 0;\n\tint ret;\n\n\tret = raspberrypi_clock_property(rpi->firmware, data,\n\t\t\t\t\t RPI_FIRMWARE_GET_CLOCK_RATE, &val);\n\tif (ret)\n\t\treturn 0;\n\n\treturn val;\n}\n\nstatic int raspberrypi_fw_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct raspberrypi_clk_data *data =\n\t\tcontainer_of(hw, struct raspberrypi_clk_data, hw);\n\tstruct raspberrypi_clk *rpi = data->rpi;\n\tu32 _rate = rate;\n\tint ret;\n\n\tret = raspberrypi_clock_property(rpi->firmware, data,\n\t\t\t\t\t RPI_FIRMWARE_SET_CLOCK_RATE, &_rate);\n\tif (ret)\n\t\tdev_err_ratelimited(rpi->dev, \"Failed to change %s frequency: %d\\n\",\n\t\t\t\t    clk_hw_get_name(hw), ret);\n\n\treturn ret;\n}\n\nstatic int raspberrypi_fw_dumb_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t      struct clk_rate_request *req)\n{\n\tstruct raspberrypi_clk_data *data =\n\t\tcontainer_of(hw, struct raspberrypi_clk_data, hw);\n\tstruct raspberrypi_clk_variant *variant = data->variant;\n\n\t \n\n\treq->rate = clamp(req->rate, req->min_rate, req->max_rate);\n\n\t \n\tif (variant->minimize && req->min_rate > 0)\n\t\treq->rate = req->min_rate;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops raspberrypi_firmware_clk_ops = {\n\t.is_prepared\t= raspberrypi_fw_is_prepared,\n\t.recalc_rate\t= raspberrypi_fw_get_rate,\n\t.determine_rate\t= raspberrypi_fw_dumb_determine_rate,\n\t.set_rate\t= raspberrypi_fw_set_rate,\n};\n\nstatic struct clk_hw *raspberrypi_clk_register(struct raspberrypi_clk *rpi,\n\t\t\t\t\t       unsigned int parent,\n\t\t\t\t\t       unsigned int id,\n\t\t\t\t\t       struct raspberrypi_clk_variant *variant)\n{\n\tstruct raspberrypi_clk_data *data;\n\tstruct clk_init_data init = {};\n\tu32 min_rate, max_rate;\n\tint ret;\n\n\tdata = devm_kzalloc(rpi->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\tdata->rpi = rpi;\n\tdata->id = id;\n\tdata->variant = variant;\n\n\tinit.name = devm_kasprintf(rpi->dev, GFP_KERNEL,\n\t\t\t\t   \"fw-clk-%s\",\n\t\t\t\t   rpi_firmware_clk_names[id]);\n\tinit.ops = &raspberrypi_firmware_clk_ops;\n\tinit.flags = CLK_GET_RATE_NOCACHE;\n\n\tdata->hw.init = &init;\n\n\tret = raspberrypi_clock_property(rpi->firmware, data,\n\t\t\t\t\t RPI_FIRMWARE_GET_MIN_CLOCK_RATE,\n\t\t\t\t\t &min_rate);\n\tif (ret) {\n\t\tdev_err(rpi->dev, \"Failed to get clock %d min freq: %d\\n\",\n\t\t\tid, ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = raspberrypi_clock_property(rpi->firmware, data,\n\t\t\t\t\t RPI_FIRMWARE_GET_MAX_CLOCK_RATE,\n\t\t\t\t\t &max_rate);\n\tif (ret) {\n\t\tdev_err(rpi->dev, \"Failed to get clock %d max freq: %d\\n\",\n\t\t\tid, ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = devm_clk_hw_register(rpi->dev, &data->hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tclk_hw_set_rate_range(&data->hw, min_rate, max_rate);\n\n\tif (variant->clkdev) {\n\t\tret = devm_clk_hw_register_clkdev(rpi->dev, &data->hw,\n\t\t\t\t\t\t  NULL, variant->clkdev);\n\t\tif (ret) {\n\t\t\tdev_err(rpi->dev, \"Failed to initialize clkdev\\n\");\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\tif (variant->min_rate) {\n\t\tunsigned long rate;\n\n\t\tclk_hw_set_rate_range(&data->hw, variant->min_rate, max_rate);\n\n\t\trate = raspberrypi_fw_get_rate(&data->hw, 0);\n\t\tif (rate < variant->min_rate) {\n\t\t\tret = raspberrypi_fw_set_rate(&data->hw, variant->min_rate, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn &data->hw;\n}\n\nstruct rpi_firmware_get_clocks_response {\n\tu32 parent;\n\tu32 id;\n};\n\nstatic int raspberrypi_discover_clocks(struct raspberrypi_clk *rpi,\n\t\t\t\t       struct clk_hw_onecell_data *data)\n{\n\tstruct rpi_firmware_get_clocks_response *clks;\n\tint ret;\n\n\t \n\tclks = devm_kcalloc(rpi->dev,\n\t\t\t    RPI_FIRMWARE_NUM_CLK_ID + 1, sizeof(*clks),\n\t\t\t    GFP_KERNEL);\n\tif (!clks)\n\t\treturn -ENOMEM;\n\n\tret = rpi_firmware_property(rpi->firmware, RPI_FIRMWARE_GET_CLOCKS,\n\t\t\t\t    clks,\n\t\t\t\t    sizeof(*clks) * RPI_FIRMWARE_NUM_CLK_ID);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (clks->id) {\n\t\tstruct raspberrypi_clk_variant *variant;\n\n\t\tif (clks->id >= RPI_FIRMWARE_NUM_CLK_ID) {\n\t\t\tdev_err(rpi->dev, \"Unknown clock id: %u (max: %u)\\n\",\n\t\t\t\t\t   clks->id, RPI_FIRMWARE_NUM_CLK_ID - 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvariant = &raspberrypi_clk_variants[clks->id];\n\t\tif (variant->export) {\n\t\t\tstruct clk_hw *hw;\n\n\t\t\thw = raspberrypi_clk_register(rpi, clks->parent,\n\t\t\t\t\t\t      clks->id, variant);\n\t\t\tif (IS_ERR(hw))\n\t\t\t\treturn PTR_ERR(hw);\n\n\t\t\tdata->hws[clks->id] = hw;\n\t\t\tdata->num = clks->id + 1;\n\t\t}\n\n\t\tclks++;\n\t}\n\n\treturn 0;\n}\n\nstatic int raspberrypi_clk_probe(struct platform_device *pdev)\n{\n\tstruct clk_hw_onecell_data *clk_data;\n\tstruct device_node *firmware_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct rpi_firmware *firmware;\n\tstruct raspberrypi_clk *rpi;\n\tint ret;\n\n\t \n\tif (dev->of_node)\n\t\tfirmware_node = of_get_parent(dev->of_node);\n\telse\n\t\tfirmware_node = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t\t\t\"raspberrypi,bcm2835-firmware\");\n\tif (!firmware_node) {\n\t\tdev_err(dev, \"Missing firmware node\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tfirmware = devm_rpi_firmware_get(&pdev->dev, firmware_node);\n\tof_node_put(firmware_node);\n\tif (!firmware)\n\t\treturn -EPROBE_DEFER;\n\n\trpi = devm_kzalloc(dev, sizeof(*rpi), GFP_KERNEL);\n\tif (!rpi)\n\t\treturn -ENOMEM;\n\n\trpi->dev = dev;\n\trpi->firmware = firmware;\n\tplatform_set_drvdata(pdev, rpi);\n\n\tclk_data = devm_kzalloc(dev, struct_size(clk_data, hws,\n\t\t\t\t\t\t RPI_FIRMWARE_NUM_CLK_ID),\n\t\t\t\tGFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tret = raspberrypi_discover_clocks(rpi, clk_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get,\n\t\t\t\t\t  clk_data);\n\tif (ret)\n\t\treturn ret;\n\n\trpi->cpufreq = platform_device_register_data(dev, \"raspberrypi-cpufreq\",\n\t\t\t\t\t\t     -1, NULL, 0);\n\n\treturn 0;\n}\n\nstatic void raspberrypi_clk_remove(struct platform_device *pdev)\n{\n\tstruct raspberrypi_clk *rpi = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister(rpi->cpufreq);\n}\n\nstatic const struct of_device_id raspberrypi_clk_match[] = {\n\t{ .compatible = \"raspberrypi,firmware-clocks\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, raspberrypi_clk_match);\n\nstatic struct platform_driver raspberrypi_clk_driver = {\n\t.driver = {\n\t\t.name = \"raspberrypi-clk\",\n\t\t.of_match_table = raspberrypi_clk_match,\n\t},\n\t.probe          = raspberrypi_clk_probe,\n\t.remove_new\t= raspberrypi_clk_remove,\n};\nmodule_platform_driver(raspberrypi_clk_driver);\n\nMODULE_AUTHOR(\"Nicolas Saenz Julienne <nsaenzjulienne@suse.de>\");\nMODULE_DESCRIPTION(\"Raspberry Pi firmware clock driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:raspberrypi-clk\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}