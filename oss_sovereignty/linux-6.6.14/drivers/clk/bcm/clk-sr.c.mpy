{
  "module_name": "clk-sr.c",
  "hash_id": "933bfde4e3804c7eee88d43745d16e44eb4b68ef54949b23482be0bf58bbb2d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/bcm/clk-sr.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/clk-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <dt-bindings/clock/bcm-sr.h>\n#include \"clk-iproc.h\"\n\n#define REG_VAL(o, s, w) { .offset = o, .shift = s, .width = w, }\n\n#define AON_VAL(o, pw, ps, is) { .offset = o, .pwr_width = pw, \\\n\t.pwr_shift = ps, .iso_shift = is }\n\n#define SW_CTRL_VAL(o, s) { .offset = o, .shift = s, }\n\n#define RESET_VAL(o, rs, prs) { .offset = o, .reset_shift = rs, \\\n\t.p_reset_shift = prs }\n\n#define DF_VAL(o, kis, kiw, kps, kpw, kas, kaw) { .offset = o, \\\n\t.ki_shift = kis, .ki_width = kiw, .kp_shift = kps, .kp_width = kpw, \\\n\t.ka_shift = kas, .ka_width = kaw }\n\n#define VCO_CTRL_VAL(uo, lo) { .u_offset = uo, .l_offset = lo }\n\n#define ENABLE_VAL(o, es, hs, bs) { .offset = o, .enable_shift = es, \\\n\t.hold_shift = hs, .bypass_shift = bs }\n\n\nstatic const struct iproc_pll_ctrl sr_genpll0 = {\n\t.flags = IPROC_CLK_AON | IPROC_CLK_PLL_HAS_NDIV_FRAC |\n\t\tIPROC_CLK_PLL_NEEDS_SW_CFG,\n\t.aon = AON_VAL(0x0, 5, 1, 0),\n\t.reset = RESET_VAL(0x0, 12, 11),\n\t.dig_filter = DF_VAL(0x0, 4, 3, 0, 4, 7, 3),\n\t.sw_ctrl = SW_CTRL_VAL(0x10, 31),\n\t.ndiv_int = REG_VAL(0x10, 20, 10),\n\t.ndiv_frac = REG_VAL(0x10, 0, 20),\n\t.pdiv = REG_VAL(0x14, 0, 4),\n\t.status = REG_VAL(0x30, 12, 1),\n};\n\nstatic const struct iproc_clk_ctrl sr_genpll0_clk[] = {\n\t[BCM_SR_GENPLL0_125M_CLK] = {\n\t\t.channel = BCM_SR_GENPLL0_125M_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 6, 0, 12),\n\t\t.mdiv = REG_VAL(0x18, 0, 9),\n\t},\n\t[BCM_SR_GENPLL0_SCR_CLK] = {\n\t\t.channel = BCM_SR_GENPLL0_SCR_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 7, 1, 13),\n\t\t.mdiv = REG_VAL(0x18, 10, 9),\n\t},\n\t[BCM_SR_GENPLL0_250M_CLK] = {\n\t\t.channel = BCM_SR_GENPLL0_250M_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 8, 2, 14),\n\t\t.mdiv = REG_VAL(0x18, 20, 9),\n\t},\n\t[BCM_SR_GENPLL0_PCIE_AXI_CLK] = {\n\t\t.channel = BCM_SR_GENPLL0_PCIE_AXI_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 9, 3, 15),\n\t\t.mdiv = REG_VAL(0x1c, 0, 9),\n\t},\n\t[BCM_SR_GENPLL0_PAXC_AXI_X2_CLK] = {\n\t\t.channel = BCM_SR_GENPLL0_PAXC_AXI_X2_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 10, 4, 16),\n\t\t.mdiv = REG_VAL(0x1c, 10, 9),\n\t},\n\t[BCM_SR_GENPLL0_PAXC_AXI_CLK] = {\n\t\t.channel = BCM_SR_GENPLL0_PAXC_AXI_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 11, 5, 17),\n\t\t.mdiv = REG_VAL(0x1c, 20, 9),\n\t},\n};\n\nstatic int sr_genpll0_clk_init(struct platform_device *pdev)\n{\n\tiproc_pll_clk_setup(pdev->dev.of_node,\n\t\t\t    &sr_genpll0, NULL, 0, sr_genpll0_clk,\n\t\t\t    ARRAY_SIZE(sr_genpll0_clk));\n\treturn 0;\n}\n\nstatic const struct iproc_pll_ctrl sr_genpll2 = {\n\t.flags = IPROC_CLK_AON | IPROC_CLK_PLL_HAS_NDIV_FRAC |\n\t\tIPROC_CLK_PLL_NEEDS_SW_CFG,\n\t.aon = AON_VAL(0x0, 1, 13, 12),\n\t.reset = RESET_VAL(0x0, 12, 11),\n\t.dig_filter = DF_VAL(0x0, 4, 3, 0, 4, 7, 3),\n\t.sw_ctrl = SW_CTRL_VAL(0x10, 31),\n\t.ndiv_int = REG_VAL(0x10, 20, 10),\n\t.ndiv_frac = REG_VAL(0x10, 0, 20),\n\t.pdiv = REG_VAL(0x14, 0, 4),\n\t.status = REG_VAL(0x30, 12, 1),\n};\n\nstatic const struct iproc_clk_ctrl sr_genpll2_clk[] = {\n\t[BCM_SR_GENPLL2_NIC_CLK] = {\n\t\t.channel = BCM_SR_GENPLL2_NIC_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 6, 0, 12),\n\t\t.mdiv = REG_VAL(0x18, 0, 9),\n\t},\n\t[BCM_SR_GENPLL2_TS_500_CLK] = {\n\t\t.channel = BCM_SR_GENPLL2_TS_500_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 7, 1, 13),\n\t\t.mdiv = REG_VAL(0x18, 10, 9),\n\t},\n\t[BCM_SR_GENPLL2_125_NITRO_CLK] = {\n\t\t.channel = BCM_SR_GENPLL2_125_NITRO_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 8, 2, 14),\n\t\t.mdiv = REG_VAL(0x18, 20, 9),\n\t},\n\t[BCM_SR_GENPLL2_CHIMP_CLK] = {\n\t\t.channel = BCM_SR_GENPLL2_CHIMP_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 9, 3, 15),\n\t\t.mdiv = REG_VAL(0x1c, 0, 9),\n\t},\n\t[BCM_SR_GENPLL2_NIC_FLASH_CLK] = {\n\t\t.channel = BCM_SR_GENPLL2_NIC_FLASH_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 10, 4, 16),\n\t\t.mdiv = REG_VAL(0x1c, 10, 9),\n\t},\n\t[BCM_SR_GENPLL2_FS4_CLK] = {\n\t\t.channel = BCM_SR_GENPLL2_FS4_CLK,\n\t\t.enable = ENABLE_VAL(0x4, 11, 5, 17),\n\t\t.mdiv = REG_VAL(0x1c, 20, 9),\n\t},\n};\n\nstatic int sr_genpll2_clk_init(struct platform_device *pdev)\n{\n\tiproc_pll_clk_setup(pdev->dev.of_node,\n\t\t\t    &sr_genpll2, NULL, 0, sr_genpll2_clk,\n\t\t\t    ARRAY_SIZE(sr_genpll2_clk));\n\treturn 0;\n}\n\nstatic const struct iproc_pll_ctrl sr_genpll3 = {\n\t.flags = IPROC_CLK_AON | IPROC_CLK_PLL_HAS_NDIV_FRAC |\n\t\tIPROC_CLK_PLL_NEEDS_SW_CFG,\n\t.aon = AON_VAL(0x0, 1, 19, 18),\n\t.reset = RESET_VAL(0x0, 12, 11),\n\t.dig_filter = DF_VAL(0x0, 4, 3, 0, 4, 7, 3),\n\t.sw_ctrl = SW_CTRL_VAL(0x10, 31),\n\t.ndiv_int = REG_VAL(0x10, 20, 10),\n\t.ndiv_frac = REG_VAL(0x10, 0, 20),\n\t.pdiv = REG_VAL(0x14, 0, 4),\n\t.status = REG_VAL(0x30, 12, 1),\n};\n\nstatic const struct iproc_clk_ctrl sr_genpll3_clk[] = {\n\t[BCM_SR_GENPLL3_HSLS_CLK] = {\n\t\t.channel = BCM_SR_GENPLL3_HSLS_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 6, 0, 12),\n\t\t.mdiv = REG_VAL(0x18, 0, 9),\n\t},\n\t[BCM_SR_GENPLL3_SDIO_CLK] = {\n\t\t.channel = BCM_SR_GENPLL3_SDIO_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 7, 1, 13),\n\t\t.mdiv = REG_VAL(0x18, 10, 9),\n\t},\n};\n\nstatic void sr_genpll3_clk_init(struct device_node *node)\n{\n\tiproc_pll_clk_setup(node, &sr_genpll3, NULL, 0, sr_genpll3_clk,\n\t\t\t    ARRAY_SIZE(sr_genpll3_clk));\n}\nCLK_OF_DECLARE(sr_genpll3_clk, \"brcm,sr-genpll3\", sr_genpll3_clk_init);\n\nstatic const struct iproc_pll_ctrl sr_genpll4 = {\n\t.flags = IPROC_CLK_AON | IPROC_CLK_PLL_HAS_NDIV_FRAC |\n\t\tIPROC_CLK_PLL_NEEDS_SW_CFG,\n\t.aon = AON_VAL(0x0, 1, 25, 24),\n\t.reset = RESET_VAL(0x0, 12, 11),\n\t.dig_filter = DF_VAL(0x0, 4, 3, 0, 4, 7, 3),\n\t.sw_ctrl = SW_CTRL_VAL(0x10, 31),\n\t.ndiv_int = REG_VAL(0x10, 20, 10),\n\t.ndiv_frac = REG_VAL(0x10, 0, 20),\n\t.pdiv = REG_VAL(0x14, 0, 4),\n\t.status = REG_VAL(0x30, 12, 1),\n};\n\nstatic const struct iproc_clk_ctrl sr_genpll4_clk[] = {\n\t[BCM_SR_GENPLL4_CCN_CLK] = {\n\t\t.channel = BCM_SR_GENPLL4_CCN_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 6, 0, 12),\n\t\t.mdiv = REG_VAL(0x18, 0, 9),\n\t},\n\t[BCM_SR_GENPLL4_TPIU_PLL_CLK] = {\n\t\t.channel = BCM_SR_GENPLL4_TPIU_PLL_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 7, 1, 13),\n\t\t.mdiv = REG_VAL(0x18, 10, 9),\n\t},\n\t[BCM_SR_GENPLL4_NOC_CLK] = {\n\t\t.channel = BCM_SR_GENPLL4_NOC_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 8, 2, 14),\n\t\t.mdiv = REG_VAL(0x18, 20, 9),\n\t},\n\t[BCM_SR_GENPLL4_CHCLK_FS4_CLK] = {\n\t\t.channel = BCM_SR_GENPLL4_CHCLK_FS4_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 9, 3, 15),\n\t\t.mdiv = REG_VAL(0x1c, 0, 9),\n\t},\n\t[BCM_SR_GENPLL4_BRIDGE_FSCPU_CLK] = {\n\t\t.channel = BCM_SR_GENPLL4_BRIDGE_FSCPU_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x4, 10, 4, 16),\n\t\t.mdiv = REG_VAL(0x1c, 10, 9),\n\t},\n};\n\nstatic int sr_genpll4_clk_init(struct platform_device *pdev)\n{\n\tiproc_pll_clk_setup(pdev->dev.of_node,\n\t\t\t    &sr_genpll4, NULL, 0, sr_genpll4_clk,\n\t\t\t    ARRAY_SIZE(sr_genpll4_clk));\n\treturn 0;\n}\n\nstatic const struct iproc_pll_ctrl sr_genpll5 = {\n\t.flags = IPROC_CLK_AON | IPROC_CLK_PLL_HAS_NDIV_FRAC |\n\t\tIPROC_CLK_PLL_NEEDS_SW_CFG,\n\t.aon = AON_VAL(0x0, 1, 1, 0),\n\t.reset = RESET_VAL(0x0, 12, 11),\n\t.dig_filter = DF_VAL(0x0, 4, 3, 0, 4, 7, 3),\n\t.sw_ctrl = SW_CTRL_VAL(0x10, 31),\n\t.ndiv_int = REG_VAL(0x10, 20, 10),\n\t.ndiv_frac = REG_VAL(0x10, 0, 20),\n\t.pdiv = REG_VAL(0x14, 0, 4),\n\t.status = REG_VAL(0x30, 12, 1),\n};\n\nstatic const struct iproc_clk_ctrl sr_genpll5_clk[] = {\n\t[BCM_SR_GENPLL5_FS4_HF_CLK] = {\n\t\t.channel = BCM_SR_GENPLL5_FS4_HF_CLK,\n\t\t.enable = ENABLE_VAL(0x4, 6, 0, 12),\n\t\t.mdiv = REG_VAL(0x18, 0, 9),\n\t},\n\t[BCM_SR_GENPLL5_CRYPTO_AE_CLK] = {\n\t\t.channel = BCM_SR_GENPLL5_CRYPTO_AE_CLK,\n\t\t.enable = ENABLE_VAL(0x4, 7, 1, 12),\n\t\t.mdiv = REG_VAL(0x18, 10, 9),\n\t},\n\t[BCM_SR_GENPLL5_RAID_AE_CLK] = {\n\t\t.channel = BCM_SR_GENPLL5_RAID_AE_CLK,\n\t\t.enable = ENABLE_VAL(0x4, 8, 2, 14),\n\t\t.mdiv = REG_VAL(0x18, 20, 9),\n\t},\n};\n\nstatic int sr_genpll5_clk_init(struct platform_device *pdev)\n{\n\tiproc_pll_clk_setup(pdev->dev.of_node,\n\t\t\t    &sr_genpll5, NULL, 0, sr_genpll5_clk,\n\t\t\t    ARRAY_SIZE(sr_genpll5_clk));\n\treturn 0;\n}\n\nstatic const struct iproc_pll_ctrl sr_lcpll0 = {\n\t.flags = IPROC_CLK_AON | IPROC_CLK_PLL_NEEDS_SW_CFG,\n\t.aon = AON_VAL(0x0, 2, 19, 18),\n\t.reset = RESET_VAL(0x0, 31, 30),\n\t.sw_ctrl = SW_CTRL_VAL(0x4, 31),\n\t.ndiv_int = REG_VAL(0x4, 16, 10),\n\t.pdiv = REG_VAL(0x4, 26, 4),\n\t.status = REG_VAL(0x38, 12, 1),\n};\n\nstatic const struct iproc_clk_ctrl sr_lcpll0_clk[] = {\n\t[BCM_SR_LCPLL0_SATA_REFP_CLK] = {\n\t\t.channel = BCM_SR_LCPLL0_SATA_REFP_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x0, 7, 1, 13),\n\t\t.mdiv = REG_VAL(0x14, 0, 9),\n\t},\n\t[BCM_SR_LCPLL0_SATA_REFN_CLK] = {\n\t\t.channel = BCM_SR_LCPLL0_SATA_REFN_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x0, 8, 2, 14),\n\t\t.mdiv = REG_VAL(0x14, 10, 9),\n\t},\n\t[BCM_SR_LCPLL0_SATA_350_CLK] = {\n\t\t.channel = BCM_SR_LCPLL0_SATA_350_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x0, 9, 3, 15),\n\t\t.mdiv = REG_VAL(0x14, 20, 9),\n\t},\n\t[BCM_SR_LCPLL0_SATA_500_CLK] = {\n\t\t.channel = BCM_SR_LCPLL0_SATA_500_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x0, 10, 4, 16),\n\t\t.mdiv = REG_VAL(0x18, 0, 9),\n\t},\n};\n\nstatic int sr_lcpll0_clk_init(struct platform_device *pdev)\n{\n\tiproc_pll_clk_setup(pdev->dev.of_node,\n\t\t\t    &sr_lcpll0, NULL, 0, sr_lcpll0_clk,\n\t\t\t    ARRAY_SIZE(sr_lcpll0_clk));\n\treturn 0;\n}\n\nstatic const struct iproc_pll_ctrl sr_lcpll1 = {\n\t.flags = IPROC_CLK_AON | IPROC_CLK_PLL_NEEDS_SW_CFG,\n\t.aon = AON_VAL(0x0, 2, 22, 21),\n\t.reset = RESET_VAL(0x0, 31, 30),\n\t.sw_ctrl = SW_CTRL_VAL(0x4, 31),\n\t.ndiv_int = REG_VAL(0x4, 16, 10),\n\t.pdiv = REG_VAL(0x4, 26, 4),\n\t.status = REG_VAL(0x38, 12, 1),\n};\n\nstatic const struct iproc_clk_ctrl sr_lcpll1_clk[] = {\n\t[BCM_SR_LCPLL1_WAN_CLK] = {\n\t\t.channel = BCM_SR_LCPLL1_WAN_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x0, 7, 1, 13),\n\t\t.mdiv = REG_VAL(0x14, 0, 9),\n\t},\n\t[BCM_SR_LCPLL1_USB_REF_CLK] = {\n\t\t.channel = BCM_SR_LCPLL1_USB_REF_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x0, 8, 2, 14),\n\t\t.mdiv = REG_VAL(0x14, 10, 9),\n\t},\n\t[BCM_SR_LCPLL1_CRMU_TS_CLK] = {\n\t\t.channel = BCM_SR_LCPLL1_CRMU_TS_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x0, 9, 3, 15),\n\t\t.mdiv = REG_VAL(0x14, 20, 9),\n\t},\n};\n\nstatic int sr_lcpll1_clk_init(struct platform_device *pdev)\n{\n\tiproc_pll_clk_setup(pdev->dev.of_node,\n\t\t\t    &sr_lcpll1, NULL, 0, sr_lcpll1_clk,\n\t\t\t    ARRAY_SIZE(sr_lcpll1_clk));\n\treturn 0;\n}\n\nstatic const struct iproc_pll_ctrl sr_lcpll_pcie = {\n\t.flags = IPROC_CLK_AON | IPROC_CLK_PLL_NEEDS_SW_CFG,\n\t.aon = AON_VAL(0x0, 2, 25, 24),\n\t.reset = RESET_VAL(0x0, 31, 30),\n\t.sw_ctrl = SW_CTRL_VAL(0x4, 31),\n\t.ndiv_int = REG_VAL(0x4, 16, 10),\n\t.pdiv = REG_VAL(0x4, 26, 4),\n\t.status = REG_VAL(0x38, 12, 1),\n};\n\nstatic const struct iproc_clk_ctrl sr_lcpll_pcie_clk[] = {\n\t[BCM_SR_LCPLL_PCIE_PHY_REF_CLK] = {\n\t\t.channel = BCM_SR_LCPLL_PCIE_PHY_REF_CLK,\n\t\t.flags = IPROC_CLK_AON,\n\t\t.enable = ENABLE_VAL(0x0, 7, 1, 13),\n\t\t.mdiv = REG_VAL(0x14, 0, 9),\n\t},\n};\n\nstatic int sr_lcpll_pcie_clk_init(struct platform_device *pdev)\n{\n\tiproc_pll_clk_setup(pdev->dev.of_node,\n\t\t\t    &sr_lcpll_pcie, NULL, 0, sr_lcpll_pcie_clk,\n\t\t\t    ARRAY_SIZE(sr_lcpll_pcie_clk));\n\treturn 0;\n}\n\nstatic const struct of_device_id sr_clk_dt_ids[] = {\n\t{ .compatible = \"brcm,sr-genpll0\", .data = sr_genpll0_clk_init },\n\t{ .compatible = \"brcm,sr-genpll2\", .data = sr_genpll2_clk_init },\n\t{ .compatible = \"brcm,sr-genpll4\", .data = sr_genpll4_clk_init },\n\t{ .compatible = \"brcm,sr-genpll5\", .data = sr_genpll5_clk_init },\n\t{ .compatible = \"brcm,sr-lcpll0\", .data = sr_lcpll0_clk_init },\n\t{ .compatible = \"brcm,sr-lcpll1\", .data = sr_lcpll1_clk_init },\n\t{ .compatible = \"brcm,sr-lcpll-pcie\", .data = sr_lcpll_pcie_clk_init },\n\t{   }\n};\n\nstatic int sr_clk_probe(struct platform_device *pdev)\n{\n\tint (*probe_func)(struct platform_device *);\n\n\tprobe_func = of_device_get_match_data(&pdev->dev);\n\tif (!probe_func)\n\t\treturn -ENODEV;\n\n\treturn probe_func(pdev);\n}\n\nstatic struct platform_driver sr_clk_driver = {\n\t.driver = {\n\t\t.name = \"sr-clk\",\n\t\t.of_match_table = sr_clk_dt_ids,\n\t},\n\t.probe = sr_clk_probe,\n};\nbuiltin_platform_driver(sr_clk_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}