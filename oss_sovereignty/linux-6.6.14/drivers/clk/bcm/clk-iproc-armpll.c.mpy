{
  "module_name": "clk-iproc-armpll.c",
  "hash_id": "9bf1a3bb2196800f863dccf281dd31ca9cfcef5b3f9d07430578c250d2b0eca8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/bcm/clk-iproc-armpll.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/clkdev.h>\n#include <linux/of_address.h>\n\n#include \"clk-iproc.h\"\n\n#define IPROC_CLK_MAX_FREQ_POLICY                    0x3\n#define IPROC_CLK_POLICY_FREQ_OFFSET                 0x008\n#define IPROC_CLK_POLICY_FREQ_POLICY_FREQ_SHIFT      8\n#define IPROC_CLK_POLICY_FREQ_POLICY_FREQ_MASK       0x7\n\n#define IPROC_CLK_PLLARMA_OFFSET                     0xc00\n#define IPROC_CLK_PLLARMA_LOCK_SHIFT                 28\n#define IPROC_CLK_PLLARMA_PDIV_SHIFT                 24\n#define IPROC_CLK_PLLARMA_PDIV_MASK                  0xf\n#define IPROC_CLK_PLLARMA_NDIV_INT_SHIFT             8\n#define IPROC_CLK_PLLARMA_NDIV_INT_MASK              0x3ff\n\n#define IPROC_CLK_PLLARMB_OFFSET                     0xc04\n#define IPROC_CLK_PLLARMB_NDIV_FRAC_MASK             0xfffff\n\n#define IPROC_CLK_PLLARMC_OFFSET                     0xc08\n#define IPROC_CLK_PLLARMC_BYPCLK_EN_SHIFT            8\n#define IPROC_CLK_PLLARMC_MDIV_MASK                  0xff\n\n#define IPROC_CLK_PLLARMCTL5_OFFSET                  0xc20\n#define IPROC_CLK_PLLARMCTL5_H_MDIV_MASK             0xff\n\n#define IPROC_CLK_PLLARM_OFFSET_OFFSET               0xc24\n#define IPROC_CLK_PLLARM_SW_CTL_SHIFT                29\n#define IPROC_CLK_PLLARM_NDIV_INT_OFFSET_SHIFT       20\n#define IPROC_CLK_PLLARM_NDIV_INT_OFFSET_MASK        0xff\n#define IPROC_CLK_PLLARM_NDIV_FRAC_OFFSET_MASK       0xfffff\n\n#define IPROC_CLK_ARM_DIV_OFFSET                     0xe00\n#define IPROC_CLK_ARM_DIV_PLL_SELECT_OVERRIDE_SHIFT  4\n#define IPROC_CLK_ARM_DIV_ARM_PLL_SELECT_MASK        0xf\n\n#define IPROC_CLK_POLICY_DBG_OFFSET                  0xec0\n#define IPROC_CLK_POLICY_DBG_ACT_FREQ_SHIFT          12\n#define IPROC_CLK_POLICY_DBG_ACT_FREQ_MASK           0x7\n\nenum iproc_arm_pll_fid {\n\tARM_PLL_FID_CRYSTAL_CLK   = 0,\n\tARM_PLL_FID_SYS_CLK       = 2,\n\tARM_PLL_FID_CH0_SLOW_CLK  = 6,\n\tARM_PLL_FID_CH1_FAST_CLK  = 7\n};\n\nstruct iproc_arm_pll {\n\tstruct clk_hw hw;\n\tvoid __iomem *base;\n\tunsigned long rate;\n};\n\n#define to_iproc_arm_pll(hw) container_of(hw, struct iproc_arm_pll, hw)\n\nstatic unsigned int __get_fid(struct iproc_arm_pll *pll)\n{\n\tu32 val;\n\tunsigned int policy, fid, active_fid;\n\n\tval = readl(pll->base + IPROC_CLK_ARM_DIV_OFFSET);\n\tif (val & (1 << IPROC_CLK_ARM_DIV_PLL_SELECT_OVERRIDE_SHIFT))\n\t\tpolicy = val & IPROC_CLK_ARM_DIV_ARM_PLL_SELECT_MASK;\n\telse\n\t\tpolicy = 0;\n\n\t \n\tBUG_ON(policy > IPROC_CLK_MAX_FREQ_POLICY);\n\n\tval = readl(pll->base + IPROC_CLK_POLICY_FREQ_OFFSET);\n\tfid = (val >> (IPROC_CLK_POLICY_FREQ_POLICY_FREQ_SHIFT * policy)) &\n\t\tIPROC_CLK_POLICY_FREQ_POLICY_FREQ_MASK;\n\n\tval = readl(pll->base + IPROC_CLK_POLICY_DBG_OFFSET);\n\tactive_fid = IPROC_CLK_POLICY_DBG_ACT_FREQ_MASK &\n\t\t(val >> IPROC_CLK_POLICY_DBG_ACT_FREQ_SHIFT);\n\tif (fid != active_fid) {\n\t\tpr_debug(\"%s: fid override %u->%u\\n\", __func__,\tfid,\n\t\t\t\tactive_fid);\n\t\tfid = active_fid;\n\t}\n\n\tpr_debug(\"%s: active fid: %u\\n\", __func__, fid);\n\n\treturn fid;\n}\n\n \nstatic int __get_mdiv(struct iproc_arm_pll *pll)\n{\n\tunsigned int fid;\n\tint mdiv;\n\tu32 val;\n\n\tfid = __get_fid(pll);\n\n\tswitch (fid) {\n\tcase ARM_PLL_FID_CRYSTAL_CLK:\n\tcase ARM_PLL_FID_SYS_CLK:\n\t\tmdiv = 1;\n\t\tbreak;\n\n\tcase ARM_PLL_FID_CH0_SLOW_CLK:\n\t\tval = readl(pll->base + IPROC_CLK_PLLARMC_OFFSET);\n\t\tmdiv = val & IPROC_CLK_PLLARMC_MDIV_MASK;\n\t\tif (mdiv == 0)\n\t\t\tmdiv = 256;\n\t\tbreak;\n\n\tcase ARM_PLL_FID_CH1_FAST_CLK:\n\t\tval = readl(pll->base +\tIPROC_CLK_PLLARMCTL5_OFFSET);\n\t\tmdiv = val & IPROC_CLK_PLLARMCTL5_H_MDIV_MASK;\n\t\tif (mdiv == 0)\n\t\t\tmdiv = 256;\n\t\tbreak;\n\n\tdefault:\n\t\tmdiv = -EFAULT;\n\t}\n\n\treturn mdiv;\n}\n\nstatic unsigned int __get_ndiv(struct iproc_arm_pll *pll)\n{\n\tu32 val;\n\tunsigned int ndiv_int, ndiv_frac, ndiv;\n\n\tval = readl(pll->base + IPROC_CLK_PLLARM_OFFSET_OFFSET);\n\tif (val & (1 << IPROC_CLK_PLLARM_SW_CTL_SHIFT)) {\n\t\t \n\t\tndiv_int = (val >> IPROC_CLK_PLLARM_NDIV_INT_OFFSET_SHIFT) &\n\t\t\tIPROC_CLK_PLLARM_NDIV_INT_OFFSET_MASK;\n\t\tif (ndiv_int == 0)\n\t\t\tndiv_int = 256;\n\n\t\tndiv_frac = val & IPROC_CLK_PLLARM_NDIV_FRAC_OFFSET_MASK;\n\t} else {\n\t\t \n\t\tval = readl(pll->base + IPROC_CLK_PLLARMA_OFFSET);\n\t\tndiv_int = (val >> IPROC_CLK_PLLARMA_NDIV_INT_SHIFT) &\n\t\t\tIPROC_CLK_PLLARMA_NDIV_INT_MASK;\n\t\tif (ndiv_int == 0)\n\t\t\tndiv_int = 1024;\n\n\t\tval = readl(pll->base + IPROC_CLK_PLLARMB_OFFSET);\n\t\tndiv_frac = val & IPROC_CLK_PLLARMB_NDIV_FRAC_MASK;\n\t}\n\n\tndiv = (ndiv_int << 20) | ndiv_frac;\n\n\treturn ndiv;\n}\n\n \nstatic unsigned long iproc_arm_pll_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct iproc_arm_pll *pll = to_iproc_arm_pll(hw);\n\tu32 val;\n\tint mdiv;\n\tu64 ndiv;\n\tunsigned int pdiv;\n\n\t \n\tval = readl(pll->base + IPROC_CLK_PLLARMC_OFFSET);\n\tif (val & (1 << IPROC_CLK_PLLARMC_BYPCLK_EN_SHIFT)) {\n\t\tpll->rate = parent_rate;\n\t\treturn pll->rate;\n\t}\n\n\t \n\tval = readl(pll->base + IPROC_CLK_PLLARMA_OFFSET);\n\tif (!(val & (1 << IPROC_CLK_PLLARMA_LOCK_SHIFT))) {\n\t\tpll->rate = 0;\n\t\treturn 0;\n\t}\n\n\tpdiv = (val >> IPROC_CLK_PLLARMA_PDIV_SHIFT) &\n\t\tIPROC_CLK_PLLARMA_PDIV_MASK;\n\tif (pdiv == 0)\n\t\tpdiv = 16;\n\n\tndiv = __get_ndiv(pll);\n\tmdiv = __get_mdiv(pll);\n\tif (mdiv <= 0) {\n\t\tpll->rate = 0;\n\t\treturn 0;\n\t}\n\tpll->rate = (ndiv * parent_rate) >> 20;\n\tpll->rate = (pll->rate / pdiv) / mdiv;\n\n\tpr_debug(\"%s: ARM PLL rate: %lu. parent rate: %lu\\n\", __func__,\n\t\t pll->rate, parent_rate);\n\tpr_debug(\"%s: ndiv_int: %u, pdiv: %u, mdiv: %d\\n\", __func__,\n\t\t (unsigned int)(ndiv >> 20), pdiv, mdiv);\n\n\treturn pll->rate;\n}\n\nstatic const struct clk_ops iproc_arm_pll_ops = {\n\t.recalc_rate = iproc_arm_pll_recalc_rate,\n};\n\nvoid __init iproc_armpll_setup(struct device_node *node)\n{\n\tint ret;\n\tstruct iproc_arm_pll *pll;\n\tstruct clk_init_data init;\n\tconst char *parent_name;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (WARN_ON(!pll))\n\t\treturn;\n\n\tpll->base = of_iomap(node, 0);\n\tif (WARN_ON(!pll->base))\n\t\tgoto err_free_pll;\n\n\tinit.name = node->name;\n\tinit.ops = &iproc_arm_pll_ops;\n\tinit.flags = 0;\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\tpll->hw.init = &init;\n\n\tret = clk_hw_register(NULL, &pll->hw);\n\tif (WARN_ON(ret))\n\t\tgoto err_iounmap;\n\n\tret = of_clk_add_hw_provider(node, of_clk_hw_simple_get, &pll->hw);\n\tif (WARN_ON(ret))\n\t\tgoto err_clk_unregister;\n\n\treturn;\n\nerr_clk_unregister:\n\tclk_hw_unregister(&pll->hw);\nerr_iounmap:\n\tiounmap(pll->base);\nerr_free_pll:\n\tkfree(pll);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}