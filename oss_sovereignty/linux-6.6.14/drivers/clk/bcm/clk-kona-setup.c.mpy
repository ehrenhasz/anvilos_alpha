{
  "module_name": "clk-kona-setup.c",
  "hash_id": "35ffebf4b2caa5345571271c78a93acc482f77f985550f6de5733e4a544c616e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/bcm/clk-kona-setup.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/of_address.h>\n\n#include \"clk-kona.h\"\n\n \n#define selector_clear_exists(sel)\t((sel)->width = 0)\n#define trigger_clear_exists(trig)\tFLAG_CLEAR(trig, TRIG, EXISTS)\n\n \n\nstatic bool ccu_data_offsets_valid(struct ccu_data *ccu)\n{\n\tstruct ccu_policy *ccu_policy = &ccu->policy;\n\tu32 limit;\n\n\tlimit = ccu->range - sizeof(u32);\n\tlimit = round_down(limit, sizeof(u32));\n\tif (ccu_policy_exists(ccu_policy)) {\n\t\tif (ccu_policy->enable.offset > limit) {\n\t\t\tpr_err(\"%s: bad policy enable offset for %s \"\n\t\t\t\t\t\"(%u > %u)\\n\", __func__,\n\t\t\t\tccu->name, ccu_policy->enable.offset, limit);\n\t\t\treturn false;\n\t\t}\n\t\tif (ccu_policy->control.offset > limit) {\n\t\t\tpr_err(\"%s: bad policy control offset for %s \"\n\t\t\t\t\t\"(%u > %u)\\n\", __func__,\n\t\t\t\tccu->name, ccu_policy->control.offset, limit);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool clk_requires_trigger(struct kona_clk *bcm_clk)\n{\n\tstruct peri_clk_data *peri = bcm_clk->u.peri;\n\tstruct bcm_clk_sel *sel;\n\tstruct bcm_clk_div *div;\n\n\tif (bcm_clk->type != bcm_clk_peri)\n\t\treturn false;\n\n\tsel = &peri->sel;\n\tif (sel->parent_count && selector_exists(sel))\n\t\treturn true;\n\n\tdiv = &peri->div;\n\tif (!divider_exists(div))\n\t\treturn false;\n\n\t \n\tif (!divider_is_fixed(div))\n\t\treturn true;\n\n\tdiv = &peri->pre_div;\n\n\treturn divider_exists(div) && !divider_is_fixed(div);\n}\n\nstatic bool peri_clk_data_offsets_valid(struct kona_clk *bcm_clk)\n{\n\tstruct peri_clk_data *peri;\n\tstruct bcm_clk_policy *policy;\n\tstruct bcm_clk_gate *gate;\n\tstruct bcm_clk_hyst *hyst;\n\tstruct bcm_clk_div *div;\n\tstruct bcm_clk_sel *sel;\n\tstruct bcm_clk_trig *trig;\n\tconst char *name;\n\tu32 range;\n\tu32 limit;\n\n\tBUG_ON(bcm_clk->type != bcm_clk_peri);\n\tperi = bcm_clk->u.peri;\n\tname = bcm_clk->init_data.name;\n\trange = bcm_clk->ccu->range;\n\n\tlimit = range - sizeof(u32);\n\tlimit = round_down(limit, sizeof(u32));\n\n\tpolicy = &peri->policy;\n\tif (policy_exists(policy)) {\n\t\tif (policy->offset > limit) {\n\t\t\tpr_err(\"%s: bad policy offset for %s (%u > %u)\\n\",\n\t\t\t\t__func__, name, policy->offset, limit);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tgate = &peri->gate;\n\thyst = &peri->hyst;\n\tif (gate_exists(gate)) {\n\t\tif (gate->offset > limit) {\n\t\t\tpr_err(\"%s: bad gate offset for %s (%u > %u)\\n\",\n\t\t\t\t__func__, name, gate->offset, limit);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (hyst_exists(hyst)) {\n\t\t\tif (hyst->offset > limit) {\n\t\t\t\tpr_err(\"%s: bad hysteresis offset for %s \"\n\t\t\t\t\t\"(%u > %u)\\n\", __func__,\n\t\t\t\t\tname, hyst->offset, limit);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else if (hyst_exists(hyst)) {\n\t\tpr_err(\"%s: hysteresis but no gate for %s\\n\", __func__, name);\n\t\treturn false;\n\t}\n\n\tdiv = &peri->div;\n\tif (divider_exists(div)) {\n\t\tif (div->u.s.offset > limit) {\n\t\t\tpr_err(\"%s: bad divider offset for %s (%u > %u)\\n\",\n\t\t\t\t__func__, name, div->u.s.offset, limit);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdiv = &peri->pre_div;\n\tif (divider_exists(div)) {\n\t\tif (div->u.s.offset > limit) {\n\t\t\tpr_err(\"%s: bad pre-divider offset for %s \"\n\t\t\t\t\t\"(%u > %u)\\n\",\n\t\t\t\t__func__, name, div->u.s.offset, limit);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tsel = &peri->sel;\n\tif (selector_exists(sel)) {\n\t\tif (sel->offset > limit) {\n\t\t\tpr_err(\"%s: bad selector offset for %s (%u > %u)\\n\",\n\t\t\t\t__func__, name, sel->offset, limit);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\ttrig = &peri->trig;\n\tif (trigger_exists(trig)) {\n\t\tif (trig->offset > limit) {\n\t\t\tpr_err(\"%s: bad trigger offset for %s (%u > %u)\\n\",\n\t\t\t\t__func__, name, trig->offset, limit);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\ttrig = &peri->pre_trig;\n\tif (trigger_exists(trig)) {\n\t\tif (trig->offset > limit) {\n\t\t\tpr_err(\"%s: bad pre-trigger offset for %s (%u > %u)\\n\",\n\t\t\t\t__func__, name, trig->offset, limit);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic bool bit_posn_valid(u32 bit_posn, const char *field_name,\n\t\t\tconst char *clock_name)\n{\n\tu32 limit = BITS_PER_BYTE * sizeof(u32) - 1;\n\n\tif (bit_posn > limit) {\n\t\tpr_err(\"%s: bad %s bit for %s (%u > %u)\\n\", __func__,\n\t\t\tfield_name, clock_name, bit_posn, limit);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic bool bitfield_valid(u32 shift, u32 width, const char *field_name,\n\t\t\tconst char *clock_name)\n{\n\tu32 limit = BITS_PER_BYTE * sizeof(u32);\n\n\tif (!width) {\n\t\tpr_err(\"%s: bad %s field width 0 for %s\\n\", __func__,\n\t\t\tfield_name, clock_name);\n\t\treturn false;\n\t}\n\tif (shift + width > limit) {\n\t\tpr_err(\"%s: bad %s for %s (%u + %u > %u)\\n\", __func__,\n\t\t\tfield_name, clock_name, shift, width, limit);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool\nccu_policy_valid(struct ccu_policy *ccu_policy, const char *ccu_name)\n{\n\tstruct bcm_lvm_en *enable = &ccu_policy->enable;\n\tstruct bcm_policy_ctl *control;\n\n\tif (!bit_posn_valid(enable->bit, \"policy enable\", ccu_name))\n\t\treturn false;\n\n\tcontrol = &ccu_policy->control;\n\tif (!bit_posn_valid(control->go_bit, \"policy control GO\", ccu_name))\n\t\treturn false;\n\n\tif (!bit_posn_valid(control->atl_bit, \"policy control ATL\", ccu_name))\n\t\treturn false;\n\n\tif (!bit_posn_valid(control->ac_bit, \"policy control AC\", ccu_name))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool policy_valid(struct bcm_clk_policy *policy, const char *clock_name)\n{\n\tif (!bit_posn_valid(policy->bit, \"policy\", clock_name))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool gate_valid(struct bcm_clk_gate *gate, const char *field_name,\n\t\t\tconst char *clock_name)\n{\n\tif (!bit_posn_valid(gate->status_bit, \"gate status\", clock_name))\n\t\treturn false;\n\n\tif (gate_is_sw_controllable(gate)) {\n\t\tif (!bit_posn_valid(gate->en_bit, \"gate enable\", clock_name))\n\t\t\treturn false;\n\n\t\tif (gate_is_hw_controllable(gate)) {\n\t\t\tif (!bit_posn_valid(gate->hw_sw_sel_bit,\n\t\t\t\t\t\t\"gate hw/sw select\",\n\t\t\t\t\t\tclock_name))\n\t\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tBUG_ON(!gate_is_hw_controllable(gate));\n\t}\n\n\treturn true;\n}\n\nstatic bool hyst_valid(struct bcm_clk_hyst *hyst, const char *clock_name)\n{\n\tif (!bit_posn_valid(hyst->en_bit, \"hysteresis enable\", clock_name))\n\t\treturn false;\n\n\tif (!bit_posn_valid(hyst->val_bit, \"hysteresis value\", clock_name))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool sel_valid(struct bcm_clk_sel *sel, const char *field_name,\n\t\t\tconst char *clock_name)\n{\n\tif (!bitfield_valid(sel->shift, sel->width, field_name, clock_name))\n\t\treturn false;\n\n\tif (sel->parent_count) {\n\t\tu32 max_sel;\n\t\tu32 limit;\n\n\t\t \n\t\tmax_sel = sel->parent_sel[sel->parent_count - 1];\n\t\tlimit = (1 << sel->width) - 1;\n\t\tif (max_sel > limit) {\n\t\t\tpr_err(\"%s: bad selector for %s \"\n\t\t\t\t\t\"(%u needs > %u bits)\\n\",\n\t\t\t\t__func__, clock_name, max_sel,\n\t\t\t\tsel->width);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tpr_warn(\"%s: ignoring selector for %s (no parents)\\n\",\n\t\t\t__func__, clock_name);\n\t\tselector_clear_exists(sel);\n\t\tkfree(sel->parent_sel);\n\t\tsel->parent_sel = NULL;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool div_valid(struct bcm_clk_div *div, const char *field_name,\n\t\t\tconst char *clock_name)\n{\n\tif (divider_is_fixed(div)) {\n\t\t \n\t\tif (div->u.fixed == 0) {\n\t\t\tpr_err(\"%s: bad %s fixed value 0 for %s\\n\", __func__,\n\t\t\t\tfield_name, clock_name);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tif (!bitfield_valid(div->u.s.shift, div->u.s.width,\n\t\t\t\tfield_name, clock_name))\n\t\treturn false;\n\n\tif (divider_has_fraction(div))\n\t\tif (div->u.s.frac_width > div->u.s.width) {\n\t\t\tpr_warn(\"%s: bad %s fraction width for %s (%u > %u)\\n\",\n\t\t\t\t__func__, field_name, clock_name,\n\t\t\t\tdiv->u.s.frac_width, div->u.s.width);\n\t\t\treturn false;\n\t\t}\n\n\treturn true;\n}\n\n \nstatic bool kona_dividers_valid(struct kona_clk *bcm_clk)\n{\n\tstruct peri_clk_data *peri = bcm_clk->u.peri;\n\tstruct bcm_clk_div *div;\n\tstruct bcm_clk_div *pre_div;\n\tu32 limit;\n\n\tBUG_ON(bcm_clk->type != bcm_clk_peri);\n\n\tif (!divider_exists(&peri->div) || !divider_exists(&peri->pre_div))\n\t\treturn true;\n\n\tdiv = &peri->div;\n\tpre_div = &peri->pre_div;\n\tif (divider_is_fixed(div) || divider_is_fixed(pre_div))\n\t\treturn true;\n\n\tlimit = BITS_PER_BYTE * sizeof(u32);\n\n\treturn div->u.s.frac_width + pre_div->u.s.frac_width <= limit;\n}\n\n\n \nstatic bool trig_valid(struct bcm_clk_trig *trig, const char *field_name,\n\t\t\tconst char *clock_name)\n{\n\treturn bit_posn_valid(trig->bit, field_name, clock_name);\n}\n\n \nstatic bool\nperi_clk_data_valid(struct kona_clk *bcm_clk)\n{\n\tstruct peri_clk_data *peri;\n\tstruct bcm_clk_policy *policy;\n\tstruct bcm_clk_gate *gate;\n\tstruct bcm_clk_hyst *hyst;\n\tstruct bcm_clk_sel *sel;\n\tstruct bcm_clk_div *div;\n\tstruct bcm_clk_div *pre_div;\n\tstruct bcm_clk_trig *trig;\n\tconst char *name;\n\n\tBUG_ON(bcm_clk->type != bcm_clk_peri);\n\n\t \n\tif (!peri_clk_data_offsets_valid(bcm_clk))\n\t\treturn false;\n\n\tperi = bcm_clk->u.peri;\n\tname = bcm_clk->init_data.name;\n\n\tpolicy = &peri->policy;\n\tif (policy_exists(policy) && !policy_valid(policy, name))\n\t\treturn false;\n\n\tgate = &peri->gate;\n\tif (gate_exists(gate) && !gate_valid(gate, \"gate\", name))\n\t\treturn false;\n\n\thyst = &peri->hyst;\n\tif (hyst_exists(hyst) && !hyst_valid(hyst, name))\n\t\treturn false;\n\n\tsel = &peri->sel;\n\tif (selector_exists(sel)) {\n\t\tif (!sel_valid(sel, \"selector\", name))\n\t\t\treturn false;\n\n\t} else if (sel->parent_count > 1) {\n\t\tpr_err(\"%s: multiple parents but no selector for %s\\n\",\n\t\t\t__func__, name);\n\n\t\treturn false;\n\t}\n\n\tdiv = &peri->div;\n\tpre_div = &peri->pre_div;\n\tif (divider_exists(div)) {\n\t\tif (!div_valid(div, \"divider\", name))\n\t\t\treturn false;\n\n\t\tif (divider_exists(pre_div))\n\t\t\tif (!div_valid(pre_div, \"pre-divider\", name))\n\t\t\t\treturn false;\n\t} else if (divider_exists(pre_div)) {\n\t\tpr_err(\"%s: pre-divider but no divider for %s\\n\", __func__,\n\t\t\tname);\n\t\treturn false;\n\t}\n\n\ttrig = &peri->trig;\n\tif (trigger_exists(trig)) {\n\t\tif (!trig_valid(trig, \"trigger\", name))\n\t\t\treturn false;\n\n\t\tif (trigger_exists(&peri->pre_trig)) {\n\t\t\tif (!trig_valid(trig, \"pre-trigger\", name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (!clk_requires_trigger(bcm_clk)) {\n\t\t\tpr_warn(\"%s: ignoring trigger for %s (not needed)\\n\",\n\t\t\t\t__func__, name);\n\t\t\ttrigger_clear_exists(trig);\n\t\t}\n\t} else if (trigger_exists(&peri->pre_trig)) {\n\t\tpr_err(\"%s: pre-trigger but no trigger for %s\\n\", __func__,\n\t\t\tname);\n\t\treturn false;\n\t} else if (clk_requires_trigger(bcm_clk)) {\n\t\tpr_err(\"%s: required trigger missing for %s\\n\", __func__,\n\t\t\tname);\n\t\treturn false;\n\t}\n\n\treturn kona_dividers_valid(bcm_clk);\n}\n\nstatic bool kona_clk_valid(struct kona_clk *bcm_clk)\n{\n\tswitch (bcm_clk->type) {\n\tcase bcm_clk_peri:\n\t\tif (!peri_clk_data_valid(bcm_clk))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unrecognized clock type (%d)\\n\", __func__,\n\t\t\t(int)bcm_clk->type);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic u32 *parent_process(const char *clocks[],\n\t\t\tu32 *count, const char ***names)\n{\n\tstatic const char **parent_names;\n\tstatic u32 *parent_sel;\n\tconst char **clock;\n\tu32 parent_count;\n\tu32 bad_count = 0;\n\tu32 orig_count;\n\tu32 i;\n\tu32 j;\n\n\t*count = 0;\t \n\t*names = NULL;\n\tif (!clocks)\n\t\treturn NULL;\n\n\t \n\tfor (clock = clocks; *clock; clock++)\n\t\tif (*clock == BAD_CLK_NAME)\n\t\t\tbad_count++;\n\torig_count = (u32)(clock - clocks);\n\tparent_count = orig_count - bad_count;\n\n\t \n\tif (!parent_count)\n\t\treturn NULL;\n\n\t \n\tif (parent_count > PARENT_COUNT_MAX) {\n\t\tpr_err(\"%s: too many parents (%u > %u)\\n\", __func__,\n\t\t\tparent_count, PARENT_COUNT_MAX);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tparent_names = kmalloc_array(parent_count, sizeof(*parent_names),\n\t\t\t       GFP_KERNEL);\n\tif (!parent_names)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tparent_sel = kmalloc_array(parent_count, sizeof(*parent_sel),\n\t\t\t\t   GFP_KERNEL);\n\tif (!parent_sel) {\n\t\tkfree(parent_names);\n\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\tfor (i = 0, j = 0; i < orig_count; i++) {\n\t\tif (clocks[i] != BAD_CLK_NAME) {\n\t\t\tparent_names[j] = clocks[i];\n\t\t\tparent_sel[j] = i;\n\t\t\tj++;\n\t\t}\n\t}\n\t*names = parent_names;\n\t*count = parent_count;\n\n\treturn parent_sel;\n}\n\nstatic int\nclk_sel_setup(const char **clocks, struct bcm_clk_sel *sel,\n\t\tstruct clk_init_data *init_data)\n{\n\tconst char **parent_names = NULL;\n\tu32 parent_count = 0;\n\tu32 *parent_sel;\n\n\t \n\tparent_sel = parent_process(clocks, &parent_count, &parent_names);\n\tif (IS_ERR(parent_sel)) {\n\t\tint ret = PTR_ERR(parent_sel);\n\n\t\tpr_err(\"%s: error processing parent clocks for %s (%d)\\n\",\n\t\t\t__func__, init_data->name, ret);\n\n\t\treturn ret;\n\t}\n\n\tinit_data->parent_names = parent_names;\n\tinit_data->num_parents = parent_count;\n\n\tsel->parent_count = parent_count;\n\tsel->parent_sel = parent_sel;\n\n\treturn 0;\n}\n\nstatic void clk_sel_teardown(struct bcm_clk_sel *sel,\n\t\tstruct clk_init_data *init_data)\n{\n\tkfree(sel->parent_sel);\n\tsel->parent_sel = NULL;\n\tsel->parent_count = 0;\n\n\tinit_data->num_parents = 0;\n\tkfree(init_data->parent_names);\n\tinit_data->parent_names = NULL;\n}\n\nstatic void peri_clk_teardown(struct peri_clk_data *data,\n\t\t\t\tstruct clk_init_data *init_data)\n{\n\tclk_sel_teardown(&data->sel, init_data);\n}\n\n \nstatic int\nperi_clk_setup(struct peri_clk_data *data, struct clk_init_data *init_data)\n{\n\tinit_data->flags = CLK_IGNORE_UNUSED;\n\n\treturn clk_sel_setup(data->clocks, &data->sel, init_data);\n}\n\nstatic void bcm_clk_teardown(struct kona_clk *bcm_clk)\n{\n\tswitch (bcm_clk->type) {\n\tcase bcm_clk_peri:\n\t\tperi_clk_teardown(bcm_clk->u.data, &bcm_clk->init_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tbcm_clk->u.data = NULL;\n\tbcm_clk->type = bcm_clk_none;\n}\n\nstatic void kona_clk_teardown(struct clk_hw *hw)\n{\n\tstruct kona_clk *bcm_clk;\n\n\tif (!hw)\n\t\treturn;\n\n\tclk_hw_unregister(hw);\n\n\tbcm_clk = to_kona_clk(hw);\n\tbcm_clk_teardown(bcm_clk);\n}\n\nstatic int kona_clk_setup(struct kona_clk *bcm_clk)\n{\n\tint ret;\n\tstruct clk_init_data *init_data = &bcm_clk->init_data;\n\n\tswitch (bcm_clk->type) {\n\tcase bcm_clk_peri:\n\t\tret = peri_clk_setup(bcm_clk->u.data, init_data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: clock type %d invalid for %s\\n\", __func__,\n\t\t\t(int)bcm_clk->type, init_data->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!kona_clk_valid(bcm_clk)) {\n\t\tpr_err(\"%s: clock data invalid for %s\\n\", __func__,\n\t\t\tinit_data->name);\n\t\tret = -EINVAL;\n\t\tgoto out_teardown;\n\t}\n\n\tbcm_clk->hw.init = init_data;\n\tret = clk_hw_register(NULL, &bcm_clk->hw);\n\tif (ret) {\n\t\tpr_err(\"%s: error registering clock %s (%d)\\n\", __func__,\n\t\t\tinit_data->name, ret);\n\t\tgoto out_teardown;\n\t}\n\n\treturn 0;\nout_teardown:\n\tbcm_clk_teardown(bcm_clk);\n\n\treturn ret;\n}\n\nstatic void ccu_clks_teardown(struct ccu_data *ccu)\n{\n\tu32 i;\n\n\tfor (i = 0; i < ccu->clk_num; i++)\n\t\tkona_clk_teardown(&ccu->kona_clks[i].hw);\n}\n\nstatic void kona_ccu_teardown(struct ccu_data *ccu)\n{\n\tif (!ccu->base)\n\t\treturn;\n\n\tof_clk_del_provider(ccu->node);\t \n\tccu_clks_teardown(ccu);\n\tof_node_put(ccu->node);\n\tccu->node = NULL;\n\tiounmap(ccu->base);\n\tccu->base = NULL;\n}\n\nstatic bool ccu_data_valid(struct ccu_data *ccu)\n{\n\tstruct ccu_policy *ccu_policy;\n\n\tif (!ccu_data_offsets_valid(ccu))\n\t\treturn false;\n\n\tccu_policy = &ccu->policy;\n\tif (ccu_policy_exists(ccu_policy))\n\t\tif (!ccu_policy_valid(ccu_policy, ccu->name))\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct clk_hw *\nof_clk_kona_onecell_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct ccu_data *ccu = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= ccu->clk_num) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &ccu->kona_clks[idx].hw;\n}\n\n \nvoid __init kona_dt_ccu_setup(struct ccu_data *ccu,\n\t\t\tstruct device_node *node)\n{\n\tstruct resource res = { 0 };\n\tresource_size_t range;\n\tunsigned int i;\n\tint ret;\n\n\tret = of_address_to_resource(node, 0, &res);\n\tif (ret) {\n\t\tpr_err(\"%s: no valid CCU registers found for %pOFn\\n\", __func__,\n\t\t\tnode);\n\t\tgoto out_err;\n\t}\n\n\trange = resource_size(&res);\n\tif (range > (resource_size_t)U32_MAX) {\n\t\tpr_err(\"%s: address range too large for %pOFn\\n\", __func__,\n\t\t\tnode);\n\t\tgoto out_err;\n\t}\n\n\tccu->range = (u32)range;\n\n\tif (!ccu_data_valid(ccu)) {\n\t\tpr_err(\"%s: ccu data not valid for %pOFn\\n\", __func__, node);\n\t\tgoto out_err;\n\t}\n\n\tccu->base = ioremap(res.start, ccu->range);\n\tif (!ccu->base) {\n\t\tpr_err(\"%s: unable to map CCU registers for %pOFn\\n\", __func__,\n\t\t\tnode);\n\t\tgoto out_err;\n\t}\n\tccu->node = of_node_get(node);\n\n\t \n\tfor (i = 0; i < ccu->clk_num; i++) {\n\t\tif (!ccu->kona_clks[i].ccu)\n\t\t\tcontinue;\n\t\tkona_clk_setup(&ccu->kona_clks[i]);\n\t}\n\n\tret = of_clk_add_hw_provider(node, of_clk_kona_onecell_get, ccu);\n\tif (ret) {\n\t\tpr_err(\"%s: error adding ccu %pOFn as provider (%d)\\n\", __func__,\n\t\t\t\tnode, ret);\n\t\tgoto out_err;\n\t}\n\n\tif (!kona_ccu_init(ccu))\n\t\tpr_err(\"Broadcom %pOFn initialization had errors\\n\", node);\n\n\treturn;\nout_err:\n\tkona_ccu_teardown(ccu);\n\tpr_err(\"Broadcom %pOFn setup aborted\\n\", node);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}