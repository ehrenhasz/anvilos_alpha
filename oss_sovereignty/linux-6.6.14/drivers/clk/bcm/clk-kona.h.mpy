{
  "module_name": "clk-kona.h",
  "hash_id": "3f416ecbc1e08445683328ea437221588b6e1e409748bc78f14b3837274805db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/bcm/clk-kona.h",
  "human_readable_source": " \n \n\n#ifndef _CLK_KONA_H\n#define _CLK_KONA_H\n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/clk-provider.h>\n\n#define\tBILLION\t\t1000000000\n\n \n#define PARENT_COUNT_MAX\t((u32)U8_MAX)\n\n#define BAD_CLK_INDEX\t\tU8_MAX\t \n#define BAD_CLK_NAME\t\t((const char *)-1)\n\n#define BAD_SCALED_DIV_VALUE\tU64_MAX\n\n \n#define FLAG(type, flag)\t\tBCM_CLK_ ## type ## _FLAGS_ ## flag\n#define FLAG_SET(obj, type, flag)\t((obj)->flags |= FLAG(type, flag))\n#define FLAG_CLEAR(obj, type, flag)\t((obj)->flags &= ~(FLAG(type, flag)))\n#define FLAG_FLIP(obj, type, flag)\t((obj)->flags ^= FLAG(type, flag))\n#define FLAG_TEST(obj, type, flag)\t(!!((obj)->flags & FLAG(type, flag)))\n\n \n\n#define ccu_policy_exists(ccu_policy)\t((ccu_policy)->enable.offset != 0)\n\n \n\n#define policy_exists(policy)\t\t((policy)->offset != 0)\n\n#define gate_exists(gate)\t\tFLAG_TEST(gate, GATE, EXISTS)\n#define gate_is_enabled(gate)\t\tFLAG_TEST(gate, GATE, ENABLED)\n#define gate_is_hw_controllable(gate)\tFLAG_TEST(gate, GATE, HW)\n#define gate_is_sw_controllable(gate)\tFLAG_TEST(gate, GATE, SW)\n#define gate_is_sw_managed(gate)\tFLAG_TEST(gate, GATE, SW_MANAGED)\n#define gate_is_no_disable(gate)\tFLAG_TEST(gate, GATE, NO_DISABLE)\n\n#define gate_flip_enabled(gate)\t\tFLAG_FLIP(gate, GATE, ENABLED)\n\n#define hyst_exists(hyst)\t\t((hyst)->offset != 0)\n\n#define divider_exists(div)\t\tFLAG_TEST(div, DIV, EXISTS)\n#define divider_is_fixed(div)\t\tFLAG_TEST(div, DIV, FIXED)\n#define divider_has_fraction(div)\t(!divider_is_fixed(div) && \\\n\t\t\t\t\t\t(div)->u.s.frac_width > 0)\n\n#define selector_exists(sel)\t\t((sel)->width != 0)\n#define trigger_exists(trig)\t\tFLAG_TEST(trig, TRIG, EXISTS)\n\n#define policy_lvm_en_exists(enable)\t((enable)->offset != 0)\n#define policy_ctl_exists(control)\t((control)->offset != 0)\n\n \nenum bcm_clk_type {\n\tbcm_clk_none,\t\t \n\tbcm_clk_bus,\n\tbcm_clk_core,\n\tbcm_clk_peri\n};\n\n \nstruct bcm_clk_policy {\n\tu32 offset;\t\t \n\tu32 bit;\t\t \n};\n\n \n\n#define POLICY(_offset, _bit)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.offset = (_offset),\t\t\t\t\t\\\n\t\t.bit = (_bit),\t\t\t\t\t\t\\\n\t}\n\n \nstruct bcm_clk_gate {\n\tu32 offset;\t\t \n\tu32 status_bit;\t\t \n\tu32 en_bit;\t\t \n\tu32 hw_sw_sel_bit;\t \n\tu32 flags;\t\t \n};\n\n \n#define BCM_CLK_GATE_FLAGS_EXISTS\t((u32)1 << 0)\t \n#define BCM_CLK_GATE_FLAGS_HW\t\t((u32)1 << 1)\t \n#define BCM_CLK_GATE_FLAGS_SW\t\t((u32)1 << 2)\t \n#define BCM_CLK_GATE_FLAGS_NO_DISABLE\t((u32)1 << 3)\t \n#define BCM_CLK_GATE_FLAGS_SW_MANAGED\t((u32)1 << 4)\t \n#define BCM_CLK_GATE_FLAGS_ENABLED\t((u32)1 << 5)\t \n\n \n\n \n#define HW_SW_GATE(_offset, _status_bit, _en_bit, _hw_sw_sel_bit)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.offset = (_offset),\t\t\t\t\t\\\n\t\t.status_bit = (_status_bit),\t\t\t\t\\\n\t\t.en_bit = (_en_bit),\t\t\t\t\t\\\n\t\t.hw_sw_sel_bit = (_hw_sw_sel_bit),\t\t\t\\\n\t\t.flags = FLAG(GATE, HW)|FLAG(GATE, SW)|\t\t\t\\\n\t\t\tFLAG(GATE, SW_MANAGED)|FLAG(GATE, ENABLED)|\t\\\n\t\t\tFLAG(GATE, EXISTS),\t\t\t\t\\\n\t}\n\n \n#define HW_SW_GATE_AUTO(_offset, _status_bit, _en_bit, _hw_sw_sel_bit)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.offset = (_offset),\t\t\t\t\t\\\n\t\t.status_bit = (_status_bit),\t\t\t\t\\\n\t\t.en_bit = (_en_bit),\t\t\t\t\t\\\n\t\t.hw_sw_sel_bit = (_hw_sw_sel_bit),\t\t\t\\\n\t\t.flags = FLAG(GATE, HW)|FLAG(GATE, SW)|\t\t\t\\\n\t\t\tFLAG(GATE, EXISTS),\t\t\t\t\\\n\t}\n\n \n#define HW_ENABLE_GATE(_offset, _status_bit, _en_bit, _hw_sw_sel_bit)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.offset = (_offset),\t\t\t\t\t\\\n\t\t.status_bit = (_status_bit),\t\t\t\t\\\n\t\t.en_bit = (_en_bit),\t\t\t\t\t\\\n\t\t.hw_sw_sel_bit = (_hw_sw_sel_bit),\t\t\t\\\n\t\t.flags = FLAG(GATE, HW)|FLAG(GATE, SW)|\t\t\t\\\n\t\t\tFLAG(GATE, NO_DISABLE)|FLAG(GATE, EXISTS),\t\\\n\t}\n\n \n#define SW_ONLY_GATE(_offset, _status_bit, _en_bit)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.offset = (_offset),\t\t\t\t\t\\\n\t\t.status_bit = (_status_bit),\t\t\t\t\\\n\t\t.en_bit = (_en_bit),\t\t\t\t\t\\\n\t\t.flags = FLAG(GATE, SW)|FLAG(GATE, SW_MANAGED)|\t\t\\\n\t\t\tFLAG(GATE, ENABLED)|FLAG(GATE, EXISTS),\t\t\\\n\t}\n\n \n#define HW_ONLY_GATE(_offset, _status_bit)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.offset = (_offset),\t\t\t\t\t\\\n\t\t.status_bit = (_status_bit),\t\t\t\t\\\n\t\t.flags = FLAG(GATE, HW)|FLAG(GATE, EXISTS),\t\t\\\n\t}\n\n \nstruct bcm_clk_hyst {\n\tu32 offset;\t\t \n\tu32 en_bit;\t\t \n\tu32 val_bit;\t\t \n};\n\n \n\n#define HYST(_offset, _en_bit, _val_bit)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.offset = (_offset),\t\t\t\t\t\\\n\t\t.en_bit = (_en_bit),\t\t\t\t\t\\\n\t\t.val_bit = (_val_bit),\t\t\t\t\t\\\n\t}\n\n \nstruct bcm_clk_div {\n\tunion {\n\t\tstruct {\t \n\t\t\tu32 offset;\t \n\t\t\tu32 shift;\t \n\t\t\tu32 width;\t \n\t\t\tu32 frac_width;\t \n\n\t\t\tu64 scaled_div;\t \n\t\t} s;\n\t\tu32 fixed;\t \n\t} u;\n\tu32 flags;\t\t \n};\n\n \n#define BCM_CLK_DIV_FLAGS_EXISTS\t((u32)1 << 0)\t \n#define BCM_CLK_DIV_FLAGS_FIXED\t\t((u32)1 << 1)\t \n\n \n\n \n#define FIXED_DIVIDER(_value)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.u.fixed = (_value),\t\t\t\t\t\\\n\t\t.flags = FLAG(DIV, EXISTS)|FLAG(DIV, FIXED),\t\t\\\n\t}\n\n \n#define DIVIDER(_offset, _shift, _width)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.u.s.offset = (_offset),\t\t\t\t\\\n\t\t.u.s.shift = (_shift),\t\t\t\t\t\\\n\t\t.u.s.width = (_width),\t\t\t\t\t\\\n\t\t.u.s.scaled_div = BAD_SCALED_DIV_VALUE,\t\t\t\\\n\t\t.flags = FLAG(DIV, EXISTS),\t\t\t\t\\\n\t}\n\n \n#define FRAC_DIVIDER(_offset, _shift, _width, _frac_width)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.u.s.offset = (_offset),\t\t\t\t\\\n\t\t.u.s.shift = (_shift),\t\t\t\t\t\\\n\t\t.u.s.width = (_width),\t\t\t\t\t\\\n\t\t.u.s.frac_width = (_frac_width),\t\t\t\\\n\t\t.u.s.scaled_div = BAD_SCALED_DIV_VALUE,\t\t\t\\\n\t\t.flags = FLAG(DIV, EXISTS),\t\t\t\t\\\n\t}\n\n \nstruct bcm_clk_sel {\n\tu32 offset;\t\t \n\tu32 shift;\t\t \n\tu32 width;\t\t \n\n\tu32 parent_count;\t \n\tu32 *parent_sel;\t \n\tu8 clk_index;\t\t \n};\n\n \n#define SELECTOR(_offset, _shift, _width)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.offset = (_offset),\t\t\t\t\t\\\n\t\t.shift = (_shift),\t\t\t\t\t\\\n\t\t.width = (_width),\t\t\t\t\t\\\n\t\t.clk_index = BAD_CLK_INDEX,\t\t\t\t\\\n\t}\n\n \nstruct bcm_clk_trig {\n\tu32 offset;\t\t \n\tu32 bit;\t\t \n\tu32 flags;\t\t \n};\n\n \n#define BCM_CLK_TRIG_FLAGS_EXISTS\t((u32)1 << 0)\t \n\n \n#define TRIGGER(_offset, _bit)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.offset = (_offset),\t\t\t\t\t\\\n\t\t.bit = (_bit),\t\t\t\t\t\t\\\n\t\t.flags = FLAG(TRIG, EXISTS),\t\t\t\t\\\n\t}\n\nstruct peri_clk_data {\n\tstruct bcm_clk_policy policy;\n\tstruct bcm_clk_gate gate;\n\tstruct bcm_clk_hyst hyst;\n\tstruct bcm_clk_trig pre_trig;\n\tstruct bcm_clk_div pre_div;\n\tstruct bcm_clk_trig trig;\n\tstruct bcm_clk_div div;\n\tstruct bcm_clk_sel sel;\n\tconst char *clocks[];\t \n};\n#define CLOCKS(...)\t{ __VA_ARGS__, NULL, }\n#define NO_CLOCKS\t{ NULL, }\t \n\nstruct kona_clk {\n\tstruct clk_hw hw;\n\tstruct clk_init_data init_data;\t \n\tstruct ccu_data *ccu;\t \n\tenum bcm_clk_type type;\n\tunion {\n\t\tvoid *data;\n\t\tstruct peri_clk_data *peri;\n\t} u;\n};\n#define to_kona_clk(_hw) \\\n\tcontainer_of(_hw, struct kona_clk, hw)\n\n \n#define KONA_CLK(_ccu_name, _clk_name, _type)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.init_data\t= {\t\t\t\t\t\\\n\t\t\t.name = #_clk_name,\t\t\t\t\\\n\t\t\t.ops = &kona_ ## _type ## _clk_ops,\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.ccu\t\t= &_ccu_name ## _ccu_data,\t\t\\\n\t\t.type\t\t= bcm_clk_ ## _type,\t\t\t\\\n\t\t.u.data\t\t= &_clk_name ## _data,\t\t\t\\\n\t}\n#define LAST_KONA_CLK\t{ .type = bcm_clk_none }\n\n \nstruct bcm_lvm_en {\n\tu32 offset;\t\t \n\tu32 bit;\t\t \n};\n\n \n#define CCU_LVM_EN(_offset, _bit)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.offset = (_offset),\t\t\t\t\t\\\n\t\t.bit = (_bit),\t\t\t\t\t\t\\\n\t}\n\nstruct bcm_policy_ctl {\n\tu32 offset;\t\t \n\tu32 go_bit;\n\tu32 atl_bit;\t\t \n\tu32 ac_bit;\n};\n\n \n#define CCU_POLICY_CTL(_offset, _go_bit, _ac_bit, _atl_bit)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.offset = (_offset),\t\t\t\t\t\\\n\t\t.go_bit = (_go_bit),\t\t\t\t\t\\\n\t\t.ac_bit = (_ac_bit),\t\t\t\t\t\\\n\t\t.atl_bit = (_atl_bit),\t\t\t\t\t\\\n\t}\n\nstruct ccu_policy {\n\tstruct bcm_lvm_en enable;\n\tstruct bcm_policy_ctl control;\n};\n\n \nstruct ccu_data {\n\tvoid __iomem *base;\t \n\tspinlock_t lock;\t \n\tbool write_enabled;\t \n\tstruct ccu_policy policy;\n\tstruct device_node *node;\n\tsize_t clk_num;\n\tconst char *name;\n\tu32 range;\t\t \n\tstruct kona_clk kona_clks[];\t \n};\n\n \n#define KONA_CCU_COMMON(_prefix, _name, _ccuname)\t\t\t    \\\n\t.name\t\t= #_name \"_ccu\",\t\t\t\t    \\\n\t.lock\t\t= __SPIN_LOCK_UNLOCKED(_name ## _ccu_data.lock),    \\\n\t.clk_num\t= _prefix ## _ ## _ccuname ## _CCU_CLOCK_COUNT\n\n \n\nextern struct clk_ops kona_peri_clk_ops;\n\n \n\nextern u64 scaled_div_max(struct bcm_clk_div *div);\nextern u64 scaled_div_build(struct bcm_clk_div *div, u32 div_value,\n\t\t\t\tu32 billionths);\n\nextern void __init kona_dt_ccu_setup(struct ccu_data *ccu,\n\t\t\t\tstruct device_node *node);\nextern bool __init kona_ccu_init(struct ccu_data *ccu);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}