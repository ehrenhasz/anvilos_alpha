{
  "module_name": "clk-iproc-pll.c",
  "hash_id": "9e200000c59b7b47818a4948c14f3330f86a5f9eba6a1091bd91fe43f555de30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/bcm/clk-iproc-pll.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/clkdev.h>\n#include <linux/of_address.h>\n#include <linux/delay.h>\n\n#include \"clk-iproc.h\"\n\n#define PLL_VCO_HIGH_SHIFT 19\n#define PLL_VCO_LOW_SHIFT  30\n\n \n#define PLL_USER_MODE 7\n\n \n#define LOCK_DELAY 100\n\n \n#define NUM_FREQ_BANDS 8\n\n#define NUM_KP_BANDS 3\nenum kp_band {\n\tKP_BAND_MID = 0,\n\tKP_BAND_HIGH,\n\tKP_BAND_HIGH_HIGH\n};\n\nstatic const unsigned int kp_table[NUM_KP_BANDS][NUM_FREQ_BANDS] = {\n\t{ 5, 6, 6, 7, 7, 8, 9, 10 },\n\t{ 4, 4, 5, 5, 6, 7, 8, 9  },\n\t{ 4, 5, 5, 6, 7, 8, 9, 10 },\n};\n\nstatic const unsigned long ref_freq_table[NUM_FREQ_BANDS][2] = {\n\t{ 10000000,  12500000  },\n\t{ 12500000,  15000000  },\n\t{ 15000000,  20000000  },\n\t{ 20000000,  25000000  },\n\t{ 25000000,  50000000  },\n\t{ 50000000,  75000000  },\n\t{ 75000000,  100000000 },\n\t{ 100000000, 125000000 },\n};\n\nenum vco_freq_range {\n\tVCO_LOW       = 700000000U,\n\tVCO_MID       = 1200000000U,\n\tVCO_HIGH      = 2200000000U,\n\tVCO_HIGH_HIGH = 3100000000U,\n\tVCO_MAX       = 4000000000U,\n};\n\nstruct iproc_pll {\n\tvoid __iomem *status_base;\n\tvoid __iomem *control_base;\n\tvoid __iomem *pwr_base;\n\tvoid __iomem *asiu_base;\n\n\tconst struct iproc_pll_ctrl *ctrl;\n\tconst struct iproc_pll_vco_param *vco_param;\n\tunsigned int num_vco_entries;\n};\n\nstruct iproc_clk {\n\tstruct clk_hw hw;\n\tstruct iproc_pll *pll;\n\tconst struct iproc_clk_ctrl *ctrl;\n};\n\n#define to_iproc_clk(hw) container_of(hw, struct iproc_clk, hw)\n\nstatic int pll_calc_param(unsigned long target_rate,\n\t\t\tunsigned long parent_rate,\n\t\t\tstruct iproc_pll_vco_param *vco_out)\n{\n\tu64 ndiv_int, ndiv_frac, residual;\n\n\tndiv_int = target_rate / parent_rate;\n\n\tif (!ndiv_int || (ndiv_int > 255))\n\t\treturn -EINVAL;\n\n\tresidual = target_rate - (ndiv_int * parent_rate);\n\tresidual <<= 20;\n\n\t \n\tresidual += (parent_rate / 2);\n\tndiv_frac = div64_u64((u64)residual, (u64)parent_rate);\n\n\tvco_out->ndiv_int = ndiv_int;\n\tvco_out->ndiv_frac = ndiv_frac;\n\tvco_out->pdiv = 1;\n\n\tvco_out->rate = vco_out->ndiv_int * parent_rate;\n\tresidual = (u64)vco_out->ndiv_frac * (u64)parent_rate;\n\tresidual >>= 20;\n\tvco_out->rate += residual;\n\n\treturn 0;\n}\n\n \nstatic int pll_get_rate_index(struct iproc_pll *pll, unsigned int target_rate)\n{\n\tint i;\n\n\tfor (i = 0; i < pll->num_vco_entries; i++)\n\t\tif (target_rate == pll->vco_param[i].rate)\n\t\t\tbreak;\n\n\tif (i >= pll->num_vco_entries)\n\t\treturn -EINVAL;\n\n\treturn i;\n}\n\nstatic int get_kp(unsigned long ref_freq, enum kp_band kp_index)\n{\n\tint i;\n\n\tif (ref_freq < ref_freq_table[0][0])\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < NUM_FREQ_BANDS; i++) {\n\t\tif (ref_freq >= ref_freq_table[i][0] &&\n\t\t    ref_freq < ref_freq_table[i][1])\n\t\t\treturn kp_table[kp_index][i];\n\t}\n\treturn -EINVAL;\n}\n\nstatic int pll_wait_for_lock(struct iproc_pll *pll)\n{\n\tint i;\n\tconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\n\n\tfor (i = 0; i < LOCK_DELAY; i++) {\n\t\tu32 val = readl(pll->status_base + ctrl->status.offset);\n\n\t\tif (val & (1 << ctrl->status.shift))\n\t\t\treturn 0;\n\t\tudelay(10);\n\t}\n\n\treturn -EIO;\n}\n\nstatic void iproc_pll_write(const struct iproc_pll *pll, void __iomem *base,\n\t\t\t    const u32 offset, u32 val)\n{\n\tconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\n\n\twritel(val, base + offset);\n\n\tif (unlikely(ctrl->flags & IPROC_CLK_NEEDS_READ_BACK &&\n\t\t     (base == pll->status_base || base == pll->control_base)))\n\t\tval = readl(base + offset);\n}\n\nstatic void __pll_disable(struct iproc_pll *pll)\n{\n\tconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\n\tu32 val;\n\n\tif (ctrl->flags & IPROC_CLK_PLL_ASIU) {\n\t\tval = readl(pll->asiu_base + ctrl->asiu.offset);\n\t\tval &= ~(1 << ctrl->asiu.en_shift);\n\t\tiproc_pll_write(pll, pll->asiu_base, ctrl->asiu.offset, val);\n\t}\n\n\tif (ctrl->flags & IPROC_CLK_EMBED_PWRCTRL) {\n\t\tval = readl(pll->control_base + ctrl->aon.offset);\n\t\tval |= bit_mask(ctrl->aon.pwr_width) << ctrl->aon.pwr_shift;\n\t\tiproc_pll_write(pll, pll->control_base, ctrl->aon.offset, val);\n\t}\n\n\tif (pll->pwr_base) {\n\t\t \n\t\tval = readl(pll->pwr_base + ctrl->aon.offset);\n\t\tval |= 1 << ctrl->aon.iso_shift;\n\t\tiproc_pll_write(pll, pll->pwr_base, ctrl->aon.offset, val);\n\n\t\t \n\t\tval &= ~(bit_mask(ctrl->aon.pwr_width) << ctrl->aon.pwr_shift);\n\t\tiproc_pll_write(pll, pll->pwr_base, ctrl->aon.offset, val);\n\t}\n}\n\nstatic int __pll_enable(struct iproc_pll *pll)\n{\n\tconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\n\tu32 val;\n\n\tif (ctrl->flags & IPROC_CLK_EMBED_PWRCTRL) {\n\t\tval = readl(pll->control_base + ctrl->aon.offset);\n\t\tval &= ~(bit_mask(ctrl->aon.pwr_width) << ctrl->aon.pwr_shift);\n\t\tiproc_pll_write(pll, pll->control_base, ctrl->aon.offset, val);\n\t}\n\n\tif (pll->pwr_base) {\n\t\t \n\t\tval = readl(pll->pwr_base + ctrl->aon.offset);\n\t\tval |= bit_mask(ctrl->aon.pwr_width) << ctrl->aon.pwr_shift;\n\t\tval &= ~(1 << ctrl->aon.iso_shift);\n\t\tiproc_pll_write(pll, pll->pwr_base, ctrl->aon.offset, val);\n\t}\n\n\t \n\tif (ctrl->flags & IPROC_CLK_PLL_ASIU) {\n\t\tval = readl(pll->asiu_base + ctrl->asiu.offset);\n\t\tval |= (1 << ctrl->asiu.en_shift);\n\t\tiproc_pll_write(pll, pll->asiu_base, ctrl->asiu.offset, val);\n\t}\n\n\treturn 0;\n}\n\nstatic void __pll_put_in_reset(struct iproc_pll *pll)\n{\n\tu32 val;\n\tconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\n\tconst struct iproc_pll_reset_ctrl *reset = &ctrl->reset;\n\n\tval = readl(pll->control_base + reset->offset);\n\tif (ctrl->flags & IPROC_CLK_PLL_RESET_ACTIVE_LOW)\n\t\tval |= BIT(reset->reset_shift) | BIT(reset->p_reset_shift);\n\telse\n\t\tval &= ~(BIT(reset->reset_shift) | BIT(reset->p_reset_shift));\n\tiproc_pll_write(pll, pll->control_base, reset->offset, val);\n}\n\nstatic void __pll_bring_out_reset(struct iproc_pll *pll, unsigned int kp,\n\t\t\t\t  unsigned int ka, unsigned int ki)\n{\n\tu32 val;\n\tconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\n\tconst struct iproc_pll_reset_ctrl *reset = &ctrl->reset;\n\tconst struct iproc_pll_dig_filter_ctrl *dig_filter = &ctrl->dig_filter;\n\n\tval = readl(pll->control_base + dig_filter->offset);\n\tval &= ~(bit_mask(dig_filter->ki_width) << dig_filter->ki_shift |\n\t\tbit_mask(dig_filter->kp_width) << dig_filter->kp_shift |\n\t\tbit_mask(dig_filter->ka_width) << dig_filter->ka_shift);\n\tval |= ki << dig_filter->ki_shift | kp << dig_filter->kp_shift |\n\t       ka << dig_filter->ka_shift;\n\tiproc_pll_write(pll, pll->control_base, dig_filter->offset, val);\n\n\tval = readl(pll->control_base + reset->offset);\n\tif (ctrl->flags & IPROC_CLK_PLL_RESET_ACTIVE_LOW)\n\t\tval &= ~(BIT(reset->reset_shift) | BIT(reset->p_reset_shift));\n\telse\n\t\tval |= BIT(reset->reset_shift) | BIT(reset->p_reset_shift);\n\tiproc_pll_write(pll, pll->control_base, reset->offset, val);\n}\n\n \nstatic bool pll_fractional_change_only(struct iproc_pll *pll,\n\t\t\t\t       struct iproc_pll_vco_param *vco)\n{\n\tconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\n\tu32 val;\n\tu32 ndiv_int;\n\tunsigned int pdiv;\n\n\t \n\tval = readl(pll->status_base + ctrl->status.offset);\n\tif ((val & (1 << ctrl->status.shift)) == 0)\n\t\treturn false;\n\n\tval = readl(pll->control_base + ctrl->ndiv_int.offset);\n\tndiv_int = (val >> ctrl->ndiv_int.shift) &\n\t\tbit_mask(ctrl->ndiv_int.width);\n\n\tif (ndiv_int != vco->ndiv_int)\n\t\treturn false;\n\n\tval = readl(pll->control_base + ctrl->pdiv.offset);\n\tpdiv = (val >> ctrl->pdiv.shift) & bit_mask(ctrl->pdiv.width);\n\n\tif (pdiv != vco->pdiv)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int pll_set_rate(struct iproc_clk *clk, struct iproc_pll_vco_param *vco,\n\t\t\tunsigned long parent_rate)\n{\n\tstruct iproc_pll *pll = clk->pll;\n\tconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\n\tint ka = 0, ki, kp, ret;\n\tunsigned long rate = vco->rate;\n\tu32 val;\n\tenum kp_band kp_index;\n\tunsigned long ref_freq;\n\tconst char *clk_name = clk_hw_get_name(&clk->hw);\n\n\t \n\tif (vco->pdiv == 0)\n\t\tref_freq = parent_rate * 2;\n\telse\n\t\tref_freq = parent_rate / vco->pdiv;\n\n\t \n\tif (rate >= VCO_LOW && rate < VCO_HIGH) {\n\t\tki = 4;\n\t\tkp_index = KP_BAND_MID;\n\t} else if (rate >= VCO_HIGH && rate < VCO_HIGH_HIGH) {\n\t\tki = 3;\n\t\tkp_index = KP_BAND_HIGH;\n\t} else if (rate >= VCO_HIGH_HIGH && rate < VCO_MAX) {\n\t\tki = 3;\n\t\tkp_index = KP_BAND_HIGH_HIGH;\n\t} else {\n\t\tpr_err(\"%s: pll: %s has invalid rate: %lu\\n\", __func__,\n\t\t\t\tclk_name, rate);\n\t\treturn -EINVAL;\n\t}\n\n\tkp = get_kp(ref_freq, kp_index);\n\tif (kp < 0) {\n\t\tpr_err(\"%s: pll: %s has invalid kp\\n\", __func__, clk_name);\n\t\treturn kp;\n\t}\n\n\tret = __pll_enable(pll);\n\tif (ret) {\n\t\tpr_err(\"%s: pll: %s fails to enable\\n\", __func__, clk_name);\n\t\treturn ret;\n\t}\n\n\tif (pll_fractional_change_only(clk->pll, vco)) {\n\t\t \n\t\tif (ctrl->flags & IPROC_CLK_PLL_HAS_NDIV_FRAC) {\n\t\t\tval = readl(pll->control_base + ctrl->ndiv_frac.offset);\n\t\t\tval &= ~(bit_mask(ctrl->ndiv_frac.width) <<\n\t\t\t\t ctrl->ndiv_frac.shift);\n\t\t\tval |= vco->ndiv_frac << ctrl->ndiv_frac.shift;\n\t\t\tiproc_pll_write(pll, pll->control_base,\n\t\t\t\t\tctrl->ndiv_frac.offset, val);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\t__pll_put_in_reset(pll);\n\n\t \n\tif (ctrl->flags & IPROC_CLK_PLL_USER_MODE_ON) {\n\t\tval = readl(pll->control_base + ctrl->macro_mode.offset);\n\t\tval &= ~(bit_mask(ctrl->macro_mode.width) <<\n\t\t\tctrl->macro_mode.shift);\n\t\tval |= PLL_USER_MODE << ctrl->macro_mode.shift;\n\t\tiproc_pll_write(pll, pll->control_base,\n\t\t\tctrl->macro_mode.offset, val);\n\t}\n\n\tiproc_pll_write(pll, pll->control_base, ctrl->vco_ctrl.u_offset, 0);\n\n\tval = readl(pll->control_base + ctrl->vco_ctrl.l_offset);\n\n\tif (rate >= VCO_LOW && rate < VCO_MID)\n\t\tval |= (1 << PLL_VCO_LOW_SHIFT);\n\n\tif (rate < VCO_HIGH)\n\t\tval &= ~(1 << PLL_VCO_HIGH_SHIFT);\n\telse\n\t\tval |= (1 << PLL_VCO_HIGH_SHIFT);\n\n\tiproc_pll_write(pll, pll->control_base, ctrl->vco_ctrl.l_offset, val);\n\n\t \n\tval = readl(pll->control_base + ctrl->ndiv_int.offset);\n\tval &= ~(bit_mask(ctrl->ndiv_int.width) << ctrl->ndiv_int.shift);\n\tval |= vco->ndiv_int << ctrl->ndiv_int.shift;\n\tiproc_pll_write(pll, pll->control_base, ctrl->ndiv_int.offset, val);\n\n\t \n\tif (ctrl->flags & IPROC_CLK_PLL_HAS_NDIV_FRAC) {\n\t\tval = readl(pll->control_base + ctrl->ndiv_frac.offset);\n\t\tval &= ~(bit_mask(ctrl->ndiv_frac.width) <<\n\t\t\t ctrl->ndiv_frac.shift);\n\t\tval |= vco->ndiv_frac << ctrl->ndiv_frac.shift;\n\t\tiproc_pll_write(pll, pll->control_base, ctrl->ndiv_frac.offset,\n\t\t\t\tval);\n\t}\n\n\t \n\tval = readl(pll->control_base + ctrl->pdiv.offset);\n\tval &= ~(bit_mask(ctrl->pdiv.width) << ctrl->pdiv.shift);\n\tval |= vco->pdiv << ctrl->pdiv.shift;\n\tiproc_pll_write(pll, pll->control_base, ctrl->pdiv.offset, val);\n\n\t__pll_bring_out_reset(pll, kp, ka, ki);\n\n\tret = pll_wait_for_lock(pll);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: pll: %s failed to lock\\n\", __func__, clk_name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int iproc_pll_enable(struct clk_hw *hw)\n{\n\tstruct iproc_clk *clk = to_iproc_clk(hw);\n\tstruct iproc_pll *pll = clk->pll;\n\n\treturn __pll_enable(pll);\n}\n\nstatic void iproc_pll_disable(struct clk_hw *hw)\n{\n\tstruct iproc_clk *clk = to_iproc_clk(hw);\n\tstruct iproc_pll *pll = clk->pll;\n\tconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\n\n\tif (ctrl->flags & IPROC_CLK_AON)\n\t\treturn;\n\n\t__pll_disable(pll);\n}\n\nstatic unsigned long iproc_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct iproc_clk *clk = to_iproc_clk(hw);\n\tstruct iproc_pll *pll = clk->pll;\n\tconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\n\tu32 val;\n\tu64 ndiv, ndiv_int, ndiv_frac;\n\tunsigned int pdiv;\n\tunsigned long rate;\n\n\tif (parent_rate == 0)\n\t\treturn 0;\n\n\t \n\tval = readl(pll->status_base + ctrl->status.offset);\n\tif ((val & (1 << ctrl->status.shift)) == 0)\n\t\treturn 0;\n\n\t \n\tval = readl(pll->control_base + ctrl->ndiv_int.offset);\n\tndiv_int = (val >> ctrl->ndiv_int.shift) &\n\t\tbit_mask(ctrl->ndiv_int.width);\n\tndiv = ndiv_int << 20;\n\n\tif (ctrl->flags & IPROC_CLK_PLL_HAS_NDIV_FRAC) {\n\t\tval = readl(pll->control_base + ctrl->ndiv_frac.offset);\n\t\tndiv_frac = (val >> ctrl->ndiv_frac.shift) &\n\t\t\tbit_mask(ctrl->ndiv_frac.width);\n\t\tndiv += ndiv_frac;\n\t}\n\n\tval = readl(pll->control_base + ctrl->pdiv.offset);\n\tpdiv = (val >> ctrl->pdiv.shift) & bit_mask(ctrl->pdiv.width);\n\n\trate = (ndiv * parent_rate) >> 20;\n\n\tif (pdiv == 0)\n\t\trate *= 2;\n\telse\n\t\trate /= pdiv;\n\n\treturn rate;\n}\n\nstatic int iproc_pll_determine_rate(struct clk_hw *hw,\n\t\tstruct clk_rate_request *req)\n{\n\tunsigned int  i;\n\tstruct iproc_clk *clk = to_iproc_clk(hw);\n\tstruct iproc_pll *pll = clk->pll;\n\tconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\n\tunsigned long  diff, best_diff;\n\tunsigned int  best_idx = 0;\n\tint ret;\n\n\tif (req->rate == 0 || req->best_parent_rate == 0)\n\t\treturn -EINVAL;\n\n\tif (ctrl->flags & IPROC_CLK_PLL_CALC_PARAM) {\n\t\tstruct iproc_pll_vco_param vco_param;\n\n\t\tret = pll_calc_param(req->rate, req->best_parent_rate,\n\t\t\t\t\t&vco_param);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treq->rate = vco_param.rate;\n\t\treturn 0;\n\t}\n\n\tif (!pll->vco_param)\n\t\treturn -EINVAL;\n\n\tbest_diff = ULONG_MAX;\n\tfor (i = 0; i < pll->num_vco_entries; i++) {\n\t\tdiff = abs(req->rate - pll->vco_param[i].rate);\n\t\tif (diff <= best_diff) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_idx = i;\n\t\t}\n\t\t \n\t\tif (diff == 0)\n\t\t\tbreak;\n\t}\n\n\treq->rate = pll->vco_param[best_idx].rate;\n\n\treturn 0;\n}\n\nstatic int iproc_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct iproc_clk *clk = to_iproc_clk(hw);\n\tstruct iproc_pll *pll = clk->pll;\n\tconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\n\tstruct iproc_pll_vco_param vco_param;\n\tint rate_index, ret;\n\n\tif (ctrl->flags & IPROC_CLK_PLL_CALC_PARAM) {\n\t\tret = pll_calc_param(rate, parent_rate, &vco_param);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\trate_index = pll_get_rate_index(pll, rate);\n\t\tif (rate_index < 0)\n\t\t\treturn rate_index;\n\n\t\tvco_param = pll->vco_param[rate_index];\n\t}\n\n\tret = pll_set_rate(clk, &vco_param, parent_rate);\n\treturn ret;\n}\n\nstatic const struct clk_ops iproc_pll_ops = {\n\t.enable = iproc_pll_enable,\n\t.disable = iproc_pll_disable,\n\t.recalc_rate = iproc_pll_recalc_rate,\n\t.determine_rate = iproc_pll_determine_rate,\n\t.set_rate = iproc_pll_set_rate,\n};\n\nstatic int iproc_clk_enable(struct clk_hw *hw)\n{\n\tstruct iproc_clk *clk = to_iproc_clk(hw);\n\tconst struct iproc_clk_ctrl *ctrl = clk->ctrl;\n\tstruct iproc_pll *pll = clk->pll;\n\tu32 val;\n\n\t \n\tval = readl(pll->control_base + ctrl->enable.offset);\n\tval &= ~(1 << ctrl->enable.enable_shift);\n\tiproc_pll_write(pll, pll->control_base, ctrl->enable.offset, val);\n\n\t \n\tval = readl(pll->control_base + ctrl->enable.offset);\n\tval &= ~(1 << ctrl->enable.hold_shift);\n\tiproc_pll_write(pll, pll->control_base, ctrl->enable.offset, val);\n\n\treturn 0;\n}\n\nstatic void iproc_clk_disable(struct clk_hw *hw)\n{\n\tstruct iproc_clk *clk = to_iproc_clk(hw);\n\tconst struct iproc_clk_ctrl *ctrl = clk->ctrl;\n\tstruct iproc_pll *pll = clk->pll;\n\tu32 val;\n\n\tif (ctrl->flags & IPROC_CLK_AON)\n\t\treturn;\n\n\tval = readl(pll->control_base + ctrl->enable.offset);\n\tval |= 1 << ctrl->enable.enable_shift;\n\tiproc_pll_write(pll, pll->control_base, ctrl->enable.offset, val);\n}\n\nstatic unsigned long iproc_clk_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct iproc_clk *clk = to_iproc_clk(hw);\n\tconst struct iproc_clk_ctrl *ctrl = clk->ctrl;\n\tstruct iproc_pll *pll = clk->pll;\n\tu32 val;\n\tunsigned int mdiv;\n\tunsigned long rate;\n\n\tif (parent_rate == 0)\n\t\treturn 0;\n\n\tval = readl(pll->control_base + ctrl->mdiv.offset);\n\tmdiv = (val >> ctrl->mdiv.shift) & bit_mask(ctrl->mdiv.width);\n\tif (mdiv == 0)\n\t\tmdiv = 256;\n\n\tif (ctrl->flags & IPROC_CLK_MCLK_DIV_BY_2)\n\t\trate = parent_rate / (mdiv * 2);\n\telse\n\t\trate = parent_rate / mdiv;\n\n\treturn rate;\n}\n\nstatic int iproc_clk_determine_rate(struct clk_hw *hw,\n\t\tstruct clk_rate_request *req)\n{\n\tunsigned int bestdiv;\n\n\tif (req->rate == 0)\n\t\treturn -EINVAL;\n\tif (req->rate == req->best_parent_rate)\n\t\treturn 0;\n\n\tbestdiv = DIV_ROUND_CLOSEST(req->best_parent_rate, req->rate);\n\tif (bestdiv < 2)\n\t\treq->rate = req->best_parent_rate;\n\n\tif (bestdiv > 256)\n\t\tbestdiv = 256;\n\n\treq->rate = req->best_parent_rate / bestdiv;\n\n\treturn 0;\n}\n\nstatic int iproc_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct iproc_clk *clk = to_iproc_clk(hw);\n\tconst struct iproc_clk_ctrl *ctrl = clk->ctrl;\n\tstruct iproc_pll *pll = clk->pll;\n\tu32 val;\n\tunsigned int div;\n\n\tif (rate == 0 || parent_rate == 0)\n\t\treturn -EINVAL;\n\n\tdiv = DIV_ROUND_CLOSEST(parent_rate, rate);\n\tif (ctrl->flags & IPROC_CLK_MCLK_DIV_BY_2)\n\t\tdiv /=  2;\n\n\tif (div > 256)\n\t\treturn -EINVAL;\n\n\tval = readl(pll->control_base + ctrl->mdiv.offset);\n\tif (div == 256) {\n\t\tval &= ~(bit_mask(ctrl->mdiv.width) << ctrl->mdiv.shift);\n\t} else {\n\t\tval &= ~(bit_mask(ctrl->mdiv.width) << ctrl->mdiv.shift);\n\t\tval |= div << ctrl->mdiv.shift;\n\t}\n\tiproc_pll_write(pll, pll->control_base, ctrl->mdiv.offset, val);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops iproc_clk_ops = {\n\t.enable = iproc_clk_enable,\n\t.disable = iproc_clk_disable,\n\t.recalc_rate = iproc_clk_recalc_rate,\n\t.determine_rate = iproc_clk_determine_rate,\n\t.set_rate = iproc_clk_set_rate,\n};\n\n \nstatic void iproc_pll_sw_cfg(struct iproc_pll *pll)\n{\n\tconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\n\n\tif (ctrl->flags & IPROC_CLK_PLL_NEEDS_SW_CFG) {\n\t\tu32 val;\n\n\t\tval = readl(pll->control_base + ctrl->sw_ctrl.offset);\n\t\tval |= BIT(ctrl->sw_ctrl.shift);\n\t\tiproc_pll_write(pll, pll->control_base, ctrl->sw_ctrl.offset,\n\t\t\t\tval);\n\t}\n}\n\nvoid iproc_pll_clk_setup(struct device_node *node,\n\t\t\t const struct iproc_pll_ctrl *pll_ctrl,\n\t\t\t const struct iproc_pll_vco_param *vco,\n\t\t\t unsigned int num_vco_entries,\n\t\t\t const struct iproc_clk_ctrl *clk_ctrl,\n\t\t\t unsigned int num_clks)\n{\n\tint i, ret;\n\tstruct iproc_pll *pll;\n\tstruct iproc_clk *iclk;\n\tstruct clk_init_data init;\n\tconst char *parent_name;\n\tstruct iproc_clk *iclk_array;\n\tstruct clk_hw_onecell_data *clk_data;\n\tconst char *clk_name;\n\n\tif (WARN_ON(!pll_ctrl) || WARN_ON(!clk_ctrl))\n\t\treturn;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (WARN_ON(!pll))\n\t\treturn;\n\n\tclk_data = kzalloc(struct_size(clk_data, hws, num_clks), GFP_KERNEL);\n\tif (WARN_ON(!clk_data))\n\t\tgoto err_clk_data;\n\tclk_data->num = num_clks;\n\n\ticlk_array = kcalloc(num_clks, sizeof(struct iproc_clk), GFP_KERNEL);\n\tif (WARN_ON(!iclk_array))\n\t\tgoto err_clks;\n\n\tpll->control_base = of_iomap(node, 0);\n\tif (WARN_ON(!pll->control_base))\n\t\tgoto err_pll_iomap;\n\n\t \n\tpll->pwr_base = of_iomap(node, 1);\n\n\t \n\tif (pll_ctrl->flags & IPROC_CLK_PLL_ASIU) {\n\t\tpll->asiu_base = of_iomap(node, 2);\n\t\tif (WARN_ON(!pll->asiu_base))\n\t\t\tgoto err_asiu_iomap;\n\t}\n\n\tif (pll_ctrl->flags & IPROC_CLK_PLL_SPLIT_STAT_CTRL) {\n\t\t \n\t\tpll->status_base = of_iomap(node, 2);\n\t\tif (!pll->status_base)\n\t\t\tgoto err_status_iomap;\n\t} else\n\t\tpll->status_base = pll->control_base;\n\n\t \n\tpll->ctrl = pll_ctrl;\n\n\ticlk = &iclk_array[0];\n\ticlk->pll = pll;\n\n\tret = of_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t    0, &clk_name);\n\tif (WARN_ON(ret))\n\t\tgoto err_pll_register;\n\n\tinit.name = clk_name;\n\tinit.ops = &iproc_pll_ops;\n\tinit.flags = 0;\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\ticlk->hw.init = &init;\n\n\tif (vco) {\n\t\tpll->num_vco_entries = num_vco_entries;\n\t\tpll->vco_param = vco;\n\t}\n\n\tiproc_pll_sw_cfg(pll);\n\n\tret = clk_hw_register(NULL, &iclk->hw);\n\tif (WARN_ON(ret))\n\t\tgoto err_pll_register;\n\n\tclk_data->hws[0] = &iclk->hw;\n\tparent_name = clk_name;\n\n\t \n\tfor (i = 1; i < num_clks; i++) {\n\t\tmemset(&init, 0, sizeof(init));\n\n\t\tret = of_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t\t    i, &clk_name);\n\t\tif (WARN_ON(ret))\n\t\t\tgoto err_clk_register;\n\n\t\ticlk = &iclk_array[i];\n\t\ticlk->pll = pll;\n\t\ticlk->ctrl = &clk_ctrl[i];\n\n\t\tinit.name = clk_name;\n\t\tinit.ops = &iproc_clk_ops;\n\t\tinit.flags = 0;\n\t\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\t\tinit.num_parents = (parent_name ? 1 : 0);\n\t\ticlk->hw.init = &init;\n\n\t\tret = clk_hw_register(NULL, &iclk->hw);\n\t\tif (WARN_ON(ret))\n\t\t\tgoto err_clk_register;\n\n\t\tclk_data->hws[i] = &iclk->hw;\n\t}\n\n\tret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, clk_data);\n\tif (WARN_ON(ret))\n\t\tgoto err_clk_register;\n\n\treturn;\n\nerr_clk_register:\n\twhile (--i >= 0)\n\t\tclk_hw_unregister(clk_data->hws[i]);\n\nerr_pll_register:\n\tif (pll->status_base != pll->control_base)\n\t\tiounmap(pll->status_base);\n\nerr_status_iomap:\n\tif (pll->asiu_base)\n\t\tiounmap(pll->asiu_base);\n\nerr_asiu_iomap:\n\tif (pll->pwr_base)\n\t\tiounmap(pll->pwr_base);\n\n\tiounmap(pll->control_base);\n\nerr_pll_iomap:\n\tkfree(iclk_array);\n\nerr_clks:\n\tkfree(clk_data);\n\nerr_clk_data:\n\tkfree(pll);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}