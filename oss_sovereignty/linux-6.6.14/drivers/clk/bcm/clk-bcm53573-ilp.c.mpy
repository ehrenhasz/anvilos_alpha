{
  "module_name": "clk-bcm53573-ilp.c",
  "hash_id": "c0d53f39eb33b4e82a334fdb2c9ead0166100f03eb3dd3f657bf6fa059e5f4a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/bcm/clk-bcm53573-ilp.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define PMU_XTAL_FREQ_RATIO\t\t\t0x66c\n#define  XTAL_ALP_PER_4ILP\t\t\t0x00001fff\n#define  XTAL_CTL_EN\t\t\t\t0x80000000\n#define PMU_SLOW_CLK_PERIOD\t\t\t0x6dc\n\nstruct bcm53573_ilp {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n};\n\nstatic int bcm53573_ilp_enable(struct clk_hw *hw)\n{\n\tstruct bcm53573_ilp *ilp = container_of(hw, struct bcm53573_ilp, hw);\n\n\tregmap_write(ilp->regmap, PMU_SLOW_CLK_PERIOD, 0x10199);\n\tregmap_write(ilp->regmap, 0x674, 0x10000);\n\n\treturn 0;\n}\n\nstatic void bcm53573_ilp_disable(struct clk_hw *hw)\n{\n\tstruct bcm53573_ilp *ilp = container_of(hw, struct bcm53573_ilp, hw);\n\n\tregmap_write(ilp->regmap, PMU_SLOW_CLK_PERIOD, 0);\n\tregmap_write(ilp->regmap, 0x674, 0);\n}\n\nstatic unsigned long bcm53573_ilp_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct bcm53573_ilp *ilp = container_of(hw, struct bcm53573_ilp, hw);\n\tstruct regmap *regmap = ilp->regmap;\n\tu32 last_val, cur_val;\n\tint sum = 0, num = 0, loop_num = 0;\n\tint avg;\n\n\t \n\tregmap_write(regmap, PMU_XTAL_FREQ_RATIO, XTAL_CTL_EN);\n\n\t \n\tregmap_read(regmap, PMU_XTAL_FREQ_RATIO, &last_val);\n\tlast_val &= XTAL_ALP_PER_4ILP;\n\n\t \n\twhile (num < 20) {\n\t\tregmap_read(regmap, PMU_XTAL_FREQ_RATIO, &cur_val);\n\t\tcur_val &= XTAL_ALP_PER_4ILP;\n\n\t\tif (cur_val != last_val) {\n\t\t\t \n\t\t\tsum += cur_val;\n\t\t\tnum++;\n\t\t\tloop_num = 0;\n\t\t\tlast_val = cur_val;\n\t\t} else if (++loop_num > 5000) {\n\t\t\t \n\t\t\tsum += cur_val;\n\t\t\tnum++;\n\t\t\tbreak;\n\t\t}\n\n\t\tcpu_relax();\n\t}\n\n\t \n\tregmap_write(regmap, PMU_XTAL_FREQ_RATIO, 0x0);\n\n\tavg = sum / num;\n\n\treturn parent_rate * 4 / avg;\n}\n\nstatic const struct clk_ops bcm53573_ilp_clk_ops = {\n\t.enable = bcm53573_ilp_enable,\n\t.disable = bcm53573_ilp_disable,\n\t.recalc_rate = bcm53573_ilp_recalc_rate,\n};\n\nstatic void bcm53573_ilp_init(struct device_node *np)\n{\n\tstruct bcm53573_ilp *ilp;\n\tstruct clk_init_data init = { };\n\tconst char *parent_name;\n\tint err;\n\n\tilp = kzalloc(sizeof(*ilp), GFP_KERNEL);\n\tif (!ilp)\n\t\treturn;\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\tif (!parent_name) {\n\t\terr = -ENOENT;\n\t\tgoto err_free_ilp;\n\t}\n\n\tilp->regmap = syscon_node_to_regmap(of_get_parent(np));\n\tif (IS_ERR(ilp->regmap)) {\n\t\terr = PTR_ERR(ilp->regmap);\n\t\tgoto err_free_ilp;\n\t}\n\n\tinit.name = np->name;\n\tinit.ops = &bcm53573_ilp_clk_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tilp->hw.init = &init;\n\terr = clk_hw_register(NULL, &ilp->hw);\n\tif (err)\n\t\tgoto err_free_ilp;\n\n\terr = of_clk_add_hw_provider(np, of_clk_hw_simple_get, &ilp->hw);\n\tif (err)\n\t\tgoto err_clk_hw_unregister;\n\n\treturn;\n\nerr_clk_hw_unregister:\n\tclk_hw_unregister(&ilp->hw);\nerr_free_ilp:\n\tkfree(ilp);\n\tpr_err(\"Failed to init ILP clock: %d\\n\", err);\n}\n\n \nCLK_OF_DECLARE(bcm53573_ilp_clk, \"brcm,bcm53573-ilp\", bcm53573_ilp_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}