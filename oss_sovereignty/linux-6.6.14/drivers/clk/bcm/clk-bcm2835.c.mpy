{
  "module_name": "clk-bcm2835.c",
  "hash_id": "ff8560466e245e5f452c3275b3b82316db190ca35ddb47ab616656a0ce4b256f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/bcm/clk-bcm2835.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <dt-bindings/clock/bcm2835.h>\n\n#define CM_PASSWORD\t\t0x5a000000\n\n#define CM_GNRICCTL\t\t0x000\n#define CM_GNRICDIV\t\t0x004\n# define CM_DIV_FRAC_BITS\t12\n# define CM_DIV_FRAC_MASK\tGENMASK(CM_DIV_FRAC_BITS - 1, 0)\n\n#define CM_VPUCTL\t\t0x008\n#define CM_VPUDIV\t\t0x00c\n#define CM_SYSCTL\t\t0x010\n#define CM_SYSDIV\t\t0x014\n#define CM_PERIACTL\t\t0x018\n#define CM_PERIADIV\t\t0x01c\n#define CM_PERIICTL\t\t0x020\n#define CM_PERIIDIV\t\t0x024\n#define CM_H264CTL\t\t0x028\n#define CM_H264DIV\t\t0x02c\n#define CM_ISPCTL\t\t0x030\n#define CM_ISPDIV\t\t0x034\n#define CM_V3DCTL\t\t0x038\n#define CM_V3DDIV\t\t0x03c\n#define CM_CAM0CTL\t\t0x040\n#define CM_CAM0DIV\t\t0x044\n#define CM_CAM1CTL\t\t0x048\n#define CM_CAM1DIV\t\t0x04c\n#define CM_CCP2CTL\t\t0x050\n#define CM_CCP2DIV\t\t0x054\n#define CM_DSI0ECTL\t\t0x058\n#define CM_DSI0EDIV\t\t0x05c\n#define CM_DSI0PCTL\t\t0x060\n#define CM_DSI0PDIV\t\t0x064\n#define CM_DPICTL\t\t0x068\n#define CM_DPIDIV\t\t0x06c\n#define CM_GP0CTL\t\t0x070\n#define CM_GP0DIV\t\t0x074\n#define CM_GP1CTL\t\t0x078\n#define CM_GP1DIV\t\t0x07c\n#define CM_GP2CTL\t\t0x080\n#define CM_GP2DIV\t\t0x084\n#define CM_HSMCTL\t\t0x088\n#define CM_HSMDIV\t\t0x08c\n#define CM_OTPCTL\t\t0x090\n#define CM_OTPDIV\t\t0x094\n#define CM_PCMCTL\t\t0x098\n#define CM_PCMDIV\t\t0x09c\n#define CM_PWMCTL\t\t0x0a0\n#define CM_PWMDIV\t\t0x0a4\n#define CM_SLIMCTL\t\t0x0a8\n#define CM_SLIMDIV\t\t0x0ac\n#define CM_SMICTL\t\t0x0b0\n#define CM_SMIDIV\t\t0x0b4\n \n#define CM_TCNTCTL\t\t0x0c0\n# define CM_TCNT_SRC1_SHIFT\t\t12\n#define CM_TCNTCNT\t\t0x0c4\n#define CM_TECCTL\t\t0x0c8\n#define CM_TECDIV\t\t0x0cc\n#define CM_TD0CTL\t\t0x0d0\n#define CM_TD0DIV\t\t0x0d4\n#define CM_TD1CTL\t\t0x0d8\n#define CM_TD1DIV\t\t0x0dc\n#define CM_TSENSCTL\t\t0x0e0\n#define CM_TSENSDIV\t\t0x0e4\n#define CM_TIMERCTL\t\t0x0e8\n#define CM_TIMERDIV\t\t0x0ec\n#define CM_UARTCTL\t\t0x0f0\n#define CM_UARTDIV\t\t0x0f4\n#define CM_VECCTL\t\t0x0f8\n#define CM_VECDIV\t\t0x0fc\n#define CM_PULSECTL\t\t0x190\n#define CM_PULSEDIV\t\t0x194\n#define CM_SDCCTL\t\t0x1a8\n#define CM_SDCDIV\t\t0x1ac\n#define CM_ARMCTL\t\t0x1b0\n#define CM_AVEOCTL\t\t0x1b8\n#define CM_AVEODIV\t\t0x1bc\n#define CM_EMMCCTL\t\t0x1c0\n#define CM_EMMCDIV\t\t0x1c4\n#define CM_EMMC2CTL\t\t0x1d0\n#define CM_EMMC2DIV\t\t0x1d4\n\n \n# define CM_ENABLE\t\t\tBIT(4)\n# define CM_KILL\t\t\tBIT(5)\n# define CM_GATE_BIT\t\t\t6\n# define CM_GATE\t\t\tBIT(CM_GATE_BIT)\n# define CM_BUSY\t\t\tBIT(7)\n# define CM_BUSYD\t\t\tBIT(8)\n# define CM_FRAC\t\t\tBIT(9)\n# define CM_SRC_SHIFT\t\t\t0\n# define CM_SRC_BITS\t\t\t4\n# define CM_SRC_MASK\t\t\t0xf\n# define CM_SRC_GND\t\t\t0\n# define CM_SRC_OSC\t\t\t1\n# define CM_SRC_TESTDEBUG0\t\t2\n# define CM_SRC_TESTDEBUG1\t\t3\n# define CM_SRC_PLLA_CORE\t\t4\n# define CM_SRC_PLLA_PER\t\t4\n# define CM_SRC_PLLC_CORE0\t\t5\n# define CM_SRC_PLLC_PER\t\t5\n# define CM_SRC_PLLC_CORE1\t\t8\n# define CM_SRC_PLLD_CORE\t\t6\n# define CM_SRC_PLLD_PER\t\t6\n# define CM_SRC_PLLH_AUX\t\t7\n# define CM_SRC_PLLC_CORE1\t\t8\n# define CM_SRC_PLLC_CORE2\t\t9\n\n#define CM_OSCCOUNT\t\t0x100\n\n#define CM_PLLA\t\t\t0x104\n# define CM_PLL_ANARST\t\t\tBIT(8)\n# define CM_PLLA_HOLDPER\t\tBIT(7)\n# define CM_PLLA_LOADPER\t\tBIT(6)\n# define CM_PLLA_HOLDCORE\t\tBIT(5)\n# define CM_PLLA_LOADCORE\t\tBIT(4)\n# define CM_PLLA_HOLDCCP2\t\tBIT(3)\n# define CM_PLLA_LOADCCP2\t\tBIT(2)\n# define CM_PLLA_HOLDDSI0\t\tBIT(1)\n# define CM_PLLA_LOADDSI0\t\tBIT(0)\n\n#define CM_PLLC\t\t\t0x108\n# define CM_PLLC_HOLDPER\t\tBIT(7)\n# define CM_PLLC_LOADPER\t\tBIT(6)\n# define CM_PLLC_HOLDCORE2\t\tBIT(5)\n# define CM_PLLC_LOADCORE2\t\tBIT(4)\n# define CM_PLLC_HOLDCORE1\t\tBIT(3)\n# define CM_PLLC_LOADCORE1\t\tBIT(2)\n# define CM_PLLC_HOLDCORE0\t\tBIT(1)\n# define CM_PLLC_LOADCORE0\t\tBIT(0)\n\n#define CM_PLLD\t\t\t0x10c\n# define CM_PLLD_HOLDPER\t\tBIT(7)\n# define CM_PLLD_LOADPER\t\tBIT(6)\n# define CM_PLLD_HOLDCORE\t\tBIT(5)\n# define CM_PLLD_LOADCORE\t\tBIT(4)\n# define CM_PLLD_HOLDDSI1\t\tBIT(3)\n# define CM_PLLD_LOADDSI1\t\tBIT(2)\n# define CM_PLLD_HOLDDSI0\t\tBIT(1)\n# define CM_PLLD_LOADDSI0\t\tBIT(0)\n\n#define CM_PLLH\t\t\t0x110\n# define CM_PLLH_LOADRCAL\t\tBIT(2)\n# define CM_PLLH_LOADAUX\t\tBIT(1)\n# define CM_PLLH_LOADPIX\t\tBIT(0)\n\n#define CM_LOCK\t\t\t0x114\n# define CM_LOCK_FLOCKH\t\t\tBIT(12)\n# define CM_LOCK_FLOCKD\t\t\tBIT(11)\n# define CM_LOCK_FLOCKC\t\t\tBIT(10)\n# define CM_LOCK_FLOCKB\t\t\tBIT(9)\n# define CM_LOCK_FLOCKA\t\t\tBIT(8)\n\n#define CM_EVENT\t\t0x118\n#define CM_DSI1ECTL\t\t0x158\n#define CM_DSI1EDIV\t\t0x15c\n#define CM_DSI1PCTL\t\t0x160\n#define CM_DSI1PDIV\t\t0x164\n#define CM_DFTCTL\t\t0x168\n#define CM_DFTDIV\t\t0x16c\n\n#define CM_PLLB\t\t\t0x170\n# define CM_PLLB_HOLDARM\t\tBIT(1)\n# define CM_PLLB_LOADARM\t\tBIT(0)\n\n#define A2W_PLLA_CTRL\t\t0x1100\n#define A2W_PLLC_CTRL\t\t0x1120\n#define A2W_PLLD_CTRL\t\t0x1140\n#define A2W_PLLH_CTRL\t\t0x1160\n#define A2W_PLLB_CTRL\t\t0x11e0\n# define A2W_PLL_CTRL_PRST_DISABLE\tBIT(17)\n# define A2W_PLL_CTRL_PWRDN\t\tBIT(16)\n# define A2W_PLL_CTRL_PDIV_MASK\t\t0x000007000\n# define A2W_PLL_CTRL_PDIV_SHIFT\t12\n# define A2W_PLL_CTRL_NDIV_MASK\t\t0x0000003ff\n# define A2W_PLL_CTRL_NDIV_SHIFT\t0\n\n#define A2W_PLLA_ANA0\t\t0x1010\n#define A2W_PLLC_ANA0\t\t0x1030\n#define A2W_PLLD_ANA0\t\t0x1050\n#define A2W_PLLH_ANA0\t\t0x1070\n#define A2W_PLLB_ANA0\t\t0x10f0\n\n#define A2W_PLL_KA_SHIFT\t7\n#define A2W_PLL_KA_MASK\t\tGENMASK(9, 7)\n#define A2W_PLL_KI_SHIFT\t19\n#define A2W_PLL_KI_MASK\t\tGENMASK(21, 19)\n#define A2W_PLL_KP_SHIFT\t15\n#define A2W_PLL_KP_MASK\t\tGENMASK(18, 15)\n\n#define A2W_PLLH_KA_SHIFT\t19\n#define A2W_PLLH_KA_MASK\tGENMASK(21, 19)\n#define A2W_PLLH_KI_LOW_SHIFT\t22\n#define A2W_PLLH_KI_LOW_MASK\tGENMASK(23, 22)\n#define A2W_PLLH_KI_HIGH_SHIFT\t0\n#define A2W_PLLH_KI_HIGH_MASK\tGENMASK(0, 0)\n#define A2W_PLLH_KP_SHIFT\t1\n#define A2W_PLLH_KP_MASK\tGENMASK(4, 1)\n\n#define A2W_XOSC_CTRL\t\t0x1190\n# define A2W_XOSC_CTRL_PLLB_ENABLE\tBIT(7)\n# define A2W_XOSC_CTRL_PLLA_ENABLE\tBIT(6)\n# define A2W_XOSC_CTRL_PLLD_ENABLE\tBIT(5)\n# define A2W_XOSC_CTRL_DDR_ENABLE\tBIT(4)\n# define A2W_XOSC_CTRL_CPR1_ENABLE\tBIT(3)\n# define A2W_XOSC_CTRL_USB_ENABLE\tBIT(2)\n# define A2W_XOSC_CTRL_HDMI_ENABLE\tBIT(1)\n# define A2W_XOSC_CTRL_PLLC_ENABLE\tBIT(0)\n\n#define A2W_PLLA_FRAC\t\t0x1200\n#define A2W_PLLC_FRAC\t\t0x1220\n#define A2W_PLLD_FRAC\t\t0x1240\n#define A2W_PLLH_FRAC\t\t0x1260\n#define A2W_PLLB_FRAC\t\t0x12e0\n# define A2W_PLL_FRAC_MASK\t\t((1 << A2W_PLL_FRAC_BITS) - 1)\n# define A2W_PLL_FRAC_BITS\t\t20\n\n#define A2W_PLL_CHANNEL_DISABLE\t\tBIT(8)\n#define A2W_PLL_DIV_BITS\t\t8\n#define A2W_PLL_DIV_SHIFT\t\t0\n\n#define A2W_PLLA_DSI0\t\t0x1300\n#define A2W_PLLA_CORE\t\t0x1400\n#define A2W_PLLA_PER\t\t0x1500\n#define A2W_PLLA_CCP2\t\t0x1600\n\n#define A2W_PLLC_CORE2\t\t0x1320\n#define A2W_PLLC_CORE1\t\t0x1420\n#define A2W_PLLC_PER\t\t0x1520\n#define A2W_PLLC_CORE0\t\t0x1620\n\n#define A2W_PLLD_DSI0\t\t0x1340\n#define A2W_PLLD_CORE\t\t0x1440\n#define A2W_PLLD_PER\t\t0x1540\n#define A2W_PLLD_DSI1\t\t0x1640\n\n#define A2W_PLLH_AUX\t\t0x1360\n#define A2W_PLLH_RCAL\t\t0x1460\n#define A2W_PLLH_PIX\t\t0x1560\n#define A2W_PLLH_STS\t\t0x1660\n\n#define A2W_PLLH_CTRLR\t\t0x1960\n#define A2W_PLLH_FRACR\t\t0x1a60\n#define A2W_PLLH_AUXR\t\t0x1b60\n#define A2W_PLLH_RCALR\t\t0x1c60\n#define A2W_PLLH_PIXR\t\t0x1d60\n#define A2W_PLLH_STSR\t\t0x1e60\n\n#define A2W_PLLB_ARM\t\t0x13e0\n#define A2W_PLLB_SP0\t\t0x14e0\n#define A2W_PLLB_SP1\t\t0x15e0\n#define A2W_PLLB_SP2\t\t0x16e0\n\n#define LOCK_TIMEOUT_NS\t\t100000000\n#define BCM2835_MAX_FB_RATE\t1750000000u\n\n#define SOC_BCM2835\t\tBIT(0)\n#define SOC_BCM2711\t\tBIT(1)\n#define SOC_ALL\t\t\t(SOC_BCM2835 | SOC_BCM2711)\n\n \nstatic const char *const cprman_parent_names[] = {\n\t\"xosc\",\n\t\"dsi0_byte\",\n\t\"dsi0_ddr2\",\n\t\"dsi0_ddr\",\n\t\"dsi1_byte\",\n\t\"dsi1_ddr2\",\n\t\"dsi1_ddr\",\n};\n\nstruct bcm2835_cprman {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tspinlock_t regs_lock;  \n\tunsigned int soc;\n\n\t \n\tconst char *real_parent_names[ARRAY_SIZE(cprman_parent_names)];\n\n\t \n\tstruct clk_hw_onecell_data onecell;\n};\n\nstruct cprman_plat_data {\n\tunsigned int soc;\n};\n\nstatic inline void cprman_write(struct bcm2835_cprman *cprman, u32 reg, u32 val)\n{\n\twritel(CM_PASSWORD | val, cprman->regs + reg);\n}\n\nstatic inline u32 cprman_read(struct bcm2835_cprman *cprman, u32 reg)\n{\n\treturn readl(cprman->regs + reg);\n}\n\n \nstatic unsigned long bcm2835_measure_tcnt_mux(struct bcm2835_cprman *cprman,\n\t\t\t\t\t      u32 tcnt_mux)\n{\n\tu32 osccount = 19200;  \n\tu32 count;\n\tktime_t timeout;\n\n\tspin_lock(&cprman->regs_lock);\n\n\tcprman_write(cprman, CM_TCNTCTL, CM_KILL);\n\n\tcprman_write(cprman, CM_TCNTCTL,\n\t\t     (tcnt_mux & CM_SRC_MASK) |\n\t\t     (tcnt_mux >> CM_SRC_BITS) << CM_TCNT_SRC1_SHIFT);\n\n\tcprman_write(cprman, CM_OSCCOUNT, osccount);\n\n\t \n\tmdelay(1);\n\n\t \n\ttimeout = ktime_add_ns(ktime_get(), LOCK_TIMEOUT_NS);\n\twhile (cprman_read(cprman, CM_OSCCOUNT)) {\n\t\tif (ktime_after(ktime_get(), timeout)) {\n\t\t\tdev_err(cprman->dev, \"timeout waiting for OSCCOUNT\\n\");\n\t\t\tcount = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t \n\ttimeout = ktime_add_ns(ktime_get(), LOCK_TIMEOUT_NS);\n\twhile (cprman_read(cprman, CM_TCNTCTL) & CM_BUSY) {\n\t\tif (ktime_after(ktime_get(), timeout)) {\n\t\t\tdev_err(cprman->dev, \"timeout waiting for !BUSY\\n\");\n\t\t\tcount = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\tcount = cprman_read(cprman, CM_TCNTCNT);\n\n\tcprman_write(cprman, CM_TCNTCTL, 0);\n\nout:\n\tspin_unlock(&cprman->regs_lock);\n\n\treturn count * 1000;\n}\n\nstatic void bcm2835_debugfs_regset(struct bcm2835_cprman *cprman, u32 base,\n\t\t\t\t   const struct debugfs_reg32 *regs,\n\t\t\t\t   size_t nregs, struct dentry *dentry)\n{\n\tstruct debugfs_regset32 *regset;\n\n\tregset = devm_kzalloc(cprman->dev, sizeof(*regset), GFP_KERNEL);\n\tif (!regset)\n\t\treturn;\n\n\tregset->regs = regs;\n\tregset->nregs = nregs;\n\tregset->base = cprman->regs + base;\n\n\tdebugfs_create_regset32(\"regdump\", S_IRUGO, dentry, regset);\n}\n\nstruct bcm2835_pll_data {\n\tconst char *name;\n\tu32 cm_ctrl_reg;\n\tu32 a2w_ctrl_reg;\n\tu32 frac_reg;\n\tu32 ana_reg_base;\n\tu32 reference_enable_mask;\n\t \n\tu32 lock_mask;\n\tu32 flags;\n\n\tconst struct bcm2835_pll_ana_bits *ana;\n\n\tunsigned long min_rate;\n\tunsigned long max_rate;\n\t \n\tunsigned long max_fb_rate;\n};\n\nstruct bcm2835_pll_ana_bits {\n\tu32 mask0;\n\tu32 set0;\n\tu32 mask1;\n\tu32 set1;\n\tu32 mask3;\n\tu32 set3;\n\tu32 fb_prediv_mask;\n};\n\nstatic const struct bcm2835_pll_ana_bits bcm2835_ana_default = {\n\t.mask0 = 0,\n\t.set0 = 0,\n\t.mask1 = A2W_PLL_KI_MASK | A2W_PLL_KP_MASK,\n\t.set1 = (2 << A2W_PLL_KI_SHIFT) | (8 << A2W_PLL_KP_SHIFT),\n\t.mask3 = A2W_PLL_KA_MASK,\n\t.set3 = (2 << A2W_PLL_KA_SHIFT),\n\t.fb_prediv_mask = BIT(14),\n};\n\nstatic const struct bcm2835_pll_ana_bits bcm2835_ana_pllh = {\n\t.mask0 = A2W_PLLH_KA_MASK | A2W_PLLH_KI_LOW_MASK,\n\t.set0 = (2 << A2W_PLLH_KA_SHIFT) | (2 << A2W_PLLH_KI_LOW_SHIFT),\n\t.mask1 = A2W_PLLH_KI_HIGH_MASK | A2W_PLLH_KP_MASK,\n\t.set1 = (6 << A2W_PLLH_KP_SHIFT),\n\t.mask3 = 0,\n\t.set3 = 0,\n\t.fb_prediv_mask = BIT(11),\n};\n\nstruct bcm2835_pll_divider_data {\n\tconst char *name;\n\tconst char *source_pll;\n\n\tu32 cm_reg;\n\tu32 a2w_reg;\n\n\tu32 load_mask;\n\tu32 hold_mask;\n\tu32 fixed_divider;\n\tu32 flags;\n};\n\nstruct bcm2835_clock_data {\n\tconst char *name;\n\n\tconst char *const *parents;\n\tint num_mux_parents;\n\n\t \n\tunsigned int set_rate_parent;\n\n\tu32 ctl_reg;\n\tu32 div_reg;\n\n\t \n\tu32 int_bits;\n\t \n\tu32 frac_bits;\n\n\tu32 flags;\n\n\tbool is_vpu_clock;\n\tbool is_mash_clock;\n\tbool low_jitter;\n\n\tu32 tcnt_mux;\n\n\tbool round_up;\n};\n\nstruct bcm2835_gate_data {\n\tconst char *name;\n\tconst char *parent;\n\n\tu32 ctl_reg;\n};\n\nstruct bcm2835_pll {\n\tstruct clk_hw hw;\n\tstruct bcm2835_cprman *cprman;\n\tconst struct bcm2835_pll_data *data;\n};\n\nstatic int bcm2835_pll_is_on(struct clk_hw *hw)\n{\n\tstruct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);\n\tstruct bcm2835_cprman *cprman = pll->cprman;\n\tconst struct bcm2835_pll_data *data = pll->data;\n\n\treturn cprman_read(cprman, data->a2w_ctrl_reg) &\n\t\tA2W_PLL_CTRL_PRST_DISABLE;\n}\n\nstatic u32 bcm2835_pll_get_prediv_mask(struct bcm2835_cprman *cprman,\n\t\t\t\t       const struct bcm2835_pll_data *data)\n{\n\t \n\tif (cprman->soc & SOC_BCM2711)\n\t\treturn 0;\n\n\treturn data->ana->fb_prediv_mask;\n}\n\nstatic void bcm2835_pll_choose_ndiv_and_fdiv(unsigned long rate,\n\t\t\t\t\t     unsigned long parent_rate,\n\t\t\t\t\t     u32 *ndiv, u32 *fdiv)\n{\n\tu64 div;\n\n\tdiv = (u64)rate << A2W_PLL_FRAC_BITS;\n\tdo_div(div, parent_rate);\n\n\t*ndiv = div >> A2W_PLL_FRAC_BITS;\n\t*fdiv = div & ((1 << A2W_PLL_FRAC_BITS) - 1);\n}\n\nstatic long bcm2835_pll_rate_from_divisors(unsigned long parent_rate,\n\t\t\t\t\t   u32 ndiv, u32 fdiv, u32 pdiv)\n{\n\tu64 rate;\n\n\tif (pdiv == 0)\n\t\treturn 0;\n\n\trate = (u64)parent_rate * ((ndiv << A2W_PLL_FRAC_BITS) + fdiv);\n\tdo_div(rate, pdiv);\n\treturn rate >> A2W_PLL_FRAC_BITS;\n}\n\nstatic long bcm2835_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long *parent_rate)\n{\n\tstruct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);\n\tconst struct bcm2835_pll_data *data = pll->data;\n\tu32 ndiv, fdiv;\n\n\trate = clamp(rate, data->min_rate, data->max_rate);\n\n\tbcm2835_pll_choose_ndiv_and_fdiv(rate, *parent_rate, &ndiv, &fdiv);\n\n\treturn bcm2835_pll_rate_from_divisors(*parent_rate, ndiv, fdiv, 1);\n}\n\nstatic unsigned long bcm2835_pll_get_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);\n\tstruct bcm2835_cprman *cprman = pll->cprman;\n\tconst struct bcm2835_pll_data *data = pll->data;\n\tu32 a2wctrl = cprman_read(cprman, data->a2w_ctrl_reg);\n\tu32 ndiv, pdiv, fdiv;\n\tbool using_prediv;\n\n\tif (parent_rate == 0)\n\t\treturn 0;\n\n\tfdiv = cprman_read(cprman, data->frac_reg) & A2W_PLL_FRAC_MASK;\n\tndiv = (a2wctrl & A2W_PLL_CTRL_NDIV_MASK) >> A2W_PLL_CTRL_NDIV_SHIFT;\n\tpdiv = (a2wctrl & A2W_PLL_CTRL_PDIV_MASK) >> A2W_PLL_CTRL_PDIV_SHIFT;\n\tusing_prediv = cprman_read(cprman, data->ana_reg_base + 4) &\n\t\t       bcm2835_pll_get_prediv_mask(cprman, data);\n\n\tif (using_prediv) {\n\t\tndiv *= 2;\n\t\tfdiv *= 2;\n\t}\n\n\treturn bcm2835_pll_rate_from_divisors(parent_rate, ndiv, fdiv, pdiv);\n}\n\nstatic void bcm2835_pll_off(struct clk_hw *hw)\n{\n\tstruct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);\n\tstruct bcm2835_cprman *cprman = pll->cprman;\n\tconst struct bcm2835_pll_data *data = pll->data;\n\n\tspin_lock(&cprman->regs_lock);\n\tcprman_write(cprman, data->cm_ctrl_reg, CM_PLL_ANARST);\n\tcprman_write(cprman, data->a2w_ctrl_reg,\n\t\t     cprman_read(cprman, data->a2w_ctrl_reg) |\n\t\t     A2W_PLL_CTRL_PWRDN);\n\tspin_unlock(&cprman->regs_lock);\n}\n\nstatic int bcm2835_pll_on(struct clk_hw *hw)\n{\n\tstruct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);\n\tstruct bcm2835_cprman *cprman = pll->cprman;\n\tconst struct bcm2835_pll_data *data = pll->data;\n\tktime_t timeout;\n\n\tcprman_write(cprman, data->a2w_ctrl_reg,\n\t\t     cprman_read(cprman, data->a2w_ctrl_reg) &\n\t\t     ~A2W_PLL_CTRL_PWRDN);\n\n\t \n\tspin_lock(&cprman->regs_lock);\n\tcprman_write(cprman, data->cm_ctrl_reg,\n\t\t     cprman_read(cprman, data->cm_ctrl_reg) & ~CM_PLL_ANARST);\n\tspin_unlock(&cprman->regs_lock);\n\n\t \n\ttimeout = ktime_add_ns(ktime_get(), LOCK_TIMEOUT_NS);\n\twhile (!(cprman_read(cprman, CM_LOCK) & data->lock_mask)) {\n\t\tif (ktime_after(ktime_get(), timeout)) {\n\t\t\tdev_err(cprman->dev, \"%s: couldn't lock PLL\\n\",\n\t\t\t\tclk_hw_get_name(hw));\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tcpu_relax();\n\t}\n\n\tcprman_write(cprman, data->a2w_ctrl_reg,\n\t\t     cprman_read(cprman, data->a2w_ctrl_reg) |\n\t\t     A2W_PLL_CTRL_PRST_DISABLE);\n\n\treturn 0;\n}\n\nstatic void\nbcm2835_pll_write_ana(struct bcm2835_cprman *cprman, u32 ana_reg_base, u32 *ana)\n{\n\tint i;\n\n\t \n\tfor (i = 3; i >= 0; i--)\n\t\tcprman_write(cprman, ana_reg_base + i * 4, ana[i]);\n}\n\nstatic int bcm2835_pll_set_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long rate, unsigned long parent_rate)\n{\n\tstruct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);\n\tstruct bcm2835_cprman *cprman = pll->cprman;\n\tconst struct bcm2835_pll_data *data = pll->data;\n\tu32 prediv_mask = bcm2835_pll_get_prediv_mask(cprman, data);\n\tbool was_using_prediv, use_fb_prediv, do_ana_setup_first;\n\tu32 ndiv, fdiv, a2w_ctl;\n\tu32 ana[4];\n\tint i;\n\n\tif (rate > data->max_fb_rate) {\n\t\tuse_fb_prediv = true;\n\t\trate /= 2;\n\t} else {\n\t\tuse_fb_prediv = false;\n\t}\n\n\tbcm2835_pll_choose_ndiv_and_fdiv(rate, parent_rate, &ndiv, &fdiv);\n\n\tfor (i = 3; i >= 0; i--)\n\t\tana[i] = cprman_read(cprman, data->ana_reg_base + i * 4);\n\n\twas_using_prediv = ana[1] & prediv_mask;\n\n\tana[0] &= ~data->ana->mask0;\n\tana[0] |= data->ana->set0;\n\tana[1] &= ~data->ana->mask1;\n\tana[1] |= data->ana->set1;\n\tana[3] &= ~data->ana->mask3;\n\tana[3] |= data->ana->set3;\n\n\tif (was_using_prediv && !use_fb_prediv) {\n\t\tana[1] &= ~prediv_mask;\n\t\tdo_ana_setup_first = true;\n\t} else if (!was_using_prediv && use_fb_prediv) {\n\t\tana[1] |= prediv_mask;\n\t\tdo_ana_setup_first = false;\n\t} else {\n\t\tdo_ana_setup_first = true;\n\t}\n\n\t \n\tspin_lock(&cprman->regs_lock);\n\tcprman_write(cprman, A2W_XOSC_CTRL,\n\t\t     cprman_read(cprman, A2W_XOSC_CTRL) |\n\t\t     data->reference_enable_mask);\n\tspin_unlock(&cprman->regs_lock);\n\n\tif (do_ana_setup_first)\n\t\tbcm2835_pll_write_ana(cprman, data->ana_reg_base, ana);\n\n\t \n\tcprman_write(cprman, data->frac_reg, fdiv);\n\n\ta2w_ctl = cprman_read(cprman, data->a2w_ctrl_reg);\n\ta2w_ctl &= ~A2W_PLL_CTRL_NDIV_MASK;\n\ta2w_ctl |= ndiv << A2W_PLL_CTRL_NDIV_SHIFT;\n\ta2w_ctl &= ~A2W_PLL_CTRL_PDIV_MASK;\n\ta2w_ctl |= 1 << A2W_PLL_CTRL_PDIV_SHIFT;\n\tcprman_write(cprman, data->a2w_ctrl_reg, a2w_ctl);\n\n\tif (!do_ana_setup_first)\n\t\tbcm2835_pll_write_ana(cprman, data->ana_reg_base, ana);\n\n\treturn 0;\n}\n\nstatic void bcm2835_pll_debug_init(struct clk_hw *hw,\n\t\t\t\t  struct dentry *dentry)\n{\n\tstruct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);\n\tstruct bcm2835_cprman *cprman = pll->cprman;\n\tconst struct bcm2835_pll_data *data = pll->data;\n\tstruct debugfs_reg32 *regs;\n\n\tregs = devm_kcalloc(cprman->dev, 7, sizeof(*regs), GFP_KERNEL);\n\tif (!regs)\n\t\treturn;\n\n\tregs[0].name = \"cm_ctrl\";\n\tregs[0].offset = data->cm_ctrl_reg;\n\tregs[1].name = \"a2w_ctrl\";\n\tregs[1].offset = data->a2w_ctrl_reg;\n\tregs[2].name = \"frac\";\n\tregs[2].offset = data->frac_reg;\n\tregs[3].name = \"ana0\";\n\tregs[3].offset = data->ana_reg_base + 0 * 4;\n\tregs[4].name = \"ana1\";\n\tregs[4].offset = data->ana_reg_base + 1 * 4;\n\tregs[5].name = \"ana2\";\n\tregs[5].offset = data->ana_reg_base + 2 * 4;\n\tregs[6].name = \"ana3\";\n\tregs[6].offset = data->ana_reg_base + 3 * 4;\n\n\tbcm2835_debugfs_regset(cprman, 0, regs, 7, dentry);\n}\n\nstatic const struct clk_ops bcm2835_pll_clk_ops = {\n\t.is_prepared = bcm2835_pll_is_on,\n\t.prepare = bcm2835_pll_on,\n\t.unprepare = bcm2835_pll_off,\n\t.recalc_rate = bcm2835_pll_get_rate,\n\t.set_rate = bcm2835_pll_set_rate,\n\t.round_rate = bcm2835_pll_round_rate,\n\t.debug_init = bcm2835_pll_debug_init,\n};\n\nstruct bcm2835_pll_divider {\n\tstruct clk_divider div;\n\tstruct bcm2835_cprman *cprman;\n\tconst struct bcm2835_pll_divider_data *data;\n};\n\nstatic struct bcm2835_pll_divider *\nbcm2835_pll_divider_from_hw(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct bcm2835_pll_divider, div.hw);\n}\n\nstatic int bcm2835_pll_divider_is_on(struct clk_hw *hw)\n{\n\tstruct bcm2835_pll_divider *divider = bcm2835_pll_divider_from_hw(hw);\n\tstruct bcm2835_cprman *cprman = divider->cprman;\n\tconst struct bcm2835_pll_divider_data *data = divider->data;\n\n\treturn !(cprman_read(cprman, data->a2w_reg) & A2W_PLL_CHANNEL_DISABLE);\n}\n\nstatic int bcm2835_pll_divider_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t      struct clk_rate_request *req)\n{\n\treturn clk_divider_ops.determine_rate(hw, req);\n}\n\nstatic unsigned long bcm2835_pll_divider_get_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\treturn clk_divider_ops.recalc_rate(hw, parent_rate);\n}\n\nstatic void bcm2835_pll_divider_off(struct clk_hw *hw)\n{\n\tstruct bcm2835_pll_divider *divider = bcm2835_pll_divider_from_hw(hw);\n\tstruct bcm2835_cprman *cprman = divider->cprman;\n\tconst struct bcm2835_pll_divider_data *data = divider->data;\n\n\tspin_lock(&cprman->regs_lock);\n\tcprman_write(cprman, data->cm_reg,\n\t\t     (cprman_read(cprman, data->cm_reg) &\n\t\t      ~data->load_mask) | data->hold_mask);\n\tcprman_write(cprman, data->a2w_reg,\n\t\t     cprman_read(cprman, data->a2w_reg) |\n\t\t     A2W_PLL_CHANNEL_DISABLE);\n\tspin_unlock(&cprman->regs_lock);\n}\n\nstatic int bcm2835_pll_divider_on(struct clk_hw *hw)\n{\n\tstruct bcm2835_pll_divider *divider = bcm2835_pll_divider_from_hw(hw);\n\tstruct bcm2835_cprman *cprman = divider->cprman;\n\tconst struct bcm2835_pll_divider_data *data = divider->data;\n\n\tspin_lock(&cprman->regs_lock);\n\tcprman_write(cprman, data->a2w_reg,\n\t\t     cprman_read(cprman, data->a2w_reg) &\n\t\t     ~A2W_PLL_CHANNEL_DISABLE);\n\n\tcprman_write(cprman, data->cm_reg,\n\t\t     cprman_read(cprman, data->cm_reg) & ~data->hold_mask);\n\tspin_unlock(&cprman->regs_lock);\n\n\treturn 0;\n}\n\nstatic int bcm2835_pll_divider_set_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long rate,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct bcm2835_pll_divider *divider = bcm2835_pll_divider_from_hw(hw);\n\tstruct bcm2835_cprman *cprman = divider->cprman;\n\tconst struct bcm2835_pll_divider_data *data = divider->data;\n\tu32 cm, div, max_div = 1 << A2W_PLL_DIV_BITS;\n\n\tdiv = DIV_ROUND_UP_ULL(parent_rate, rate);\n\n\tdiv = min(div, max_div);\n\tif (div == max_div)\n\t\tdiv = 0;\n\n\tcprman_write(cprman, data->a2w_reg, div);\n\tcm = cprman_read(cprman, data->cm_reg);\n\tcprman_write(cprman, data->cm_reg, cm | data->load_mask);\n\tcprman_write(cprman, data->cm_reg, cm & ~data->load_mask);\n\n\treturn 0;\n}\n\nstatic void bcm2835_pll_divider_debug_init(struct clk_hw *hw,\n\t\t\t\t\t   struct dentry *dentry)\n{\n\tstruct bcm2835_pll_divider *divider = bcm2835_pll_divider_from_hw(hw);\n\tstruct bcm2835_cprman *cprman = divider->cprman;\n\tconst struct bcm2835_pll_divider_data *data = divider->data;\n\tstruct debugfs_reg32 *regs;\n\n\tregs = devm_kcalloc(cprman->dev, 7, sizeof(*regs), GFP_KERNEL);\n\tif (!regs)\n\t\treturn;\n\n\tregs[0].name = \"cm\";\n\tregs[0].offset = data->cm_reg;\n\tregs[1].name = \"a2w\";\n\tregs[1].offset = data->a2w_reg;\n\n\tbcm2835_debugfs_regset(cprman, 0, regs, 2, dentry);\n}\n\nstatic const struct clk_ops bcm2835_pll_divider_clk_ops = {\n\t.is_prepared = bcm2835_pll_divider_is_on,\n\t.prepare = bcm2835_pll_divider_on,\n\t.unprepare = bcm2835_pll_divider_off,\n\t.recalc_rate = bcm2835_pll_divider_get_rate,\n\t.set_rate = bcm2835_pll_divider_set_rate,\n\t.determine_rate = bcm2835_pll_divider_determine_rate,\n\t.debug_init = bcm2835_pll_divider_debug_init,\n};\n\n \nstruct bcm2835_clock {\n\tstruct clk_hw hw;\n\tstruct bcm2835_cprman *cprman;\n\tconst struct bcm2835_clock_data *data;\n};\n\nstatic struct bcm2835_clock *bcm2835_clock_from_hw(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct bcm2835_clock, hw);\n}\n\nstatic int bcm2835_clock_is_on(struct clk_hw *hw)\n{\n\tstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\n\tstruct bcm2835_cprman *cprman = clock->cprman;\n\tconst struct bcm2835_clock_data *data = clock->data;\n\n\treturn (cprman_read(cprman, data->ctl_reg) & CM_ENABLE) != 0;\n}\n\nstatic u32 bcm2835_clock_choose_div(struct clk_hw *hw,\n\t\t\t\t    unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\n\tconst struct bcm2835_clock_data *data = clock->data;\n\tu32 unused_frac_mask =\n\t\tGENMASK(CM_DIV_FRAC_BITS - data->frac_bits, 0) >> 1;\n\tu64 temp = (u64)parent_rate << CM_DIV_FRAC_BITS;\n\tu32 div, mindiv, maxdiv;\n\n\tdo_div(temp, rate);\n\tdiv = temp;\n\tdiv &= ~unused_frac_mask;\n\n\t \n\tif (data->is_mash_clock) {\n\t\t \n\t\tmindiv = 2 << CM_DIV_FRAC_BITS;\n\t\t \n\t\tmaxdiv = (BIT(data->int_bits) - 1) << CM_DIV_FRAC_BITS;\n\t} else {\n\t\t \n\t\tmindiv = 1 << CM_DIV_FRAC_BITS;\n\t\t \n\t\tmaxdiv = GENMASK(data->int_bits + CM_DIV_FRAC_BITS - 1,\n\t\t\t\t CM_DIV_FRAC_BITS - data->frac_bits);\n\t}\n\n\t \n\tdiv = max_t(u32, div, mindiv);\n\tdiv = min_t(u32, div, maxdiv);\n\n\treturn div;\n}\n\nstatic unsigned long bcm2835_clock_rate_from_divisor(struct bcm2835_clock *clock,\n\t\t\t\t\t\t     unsigned long parent_rate,\n\t\t\t\t\t\t     u32 div)\n{\n\tconst struct bcm2835_clock_data *data = clock->data;\n\tu64 temp;\n\n\tif (data->int_bits == 0 && data->frac_bits == 0)\n\t\treturn parent_rate;\n\n\t \n\tdiv >>= CM_DIV_FRAC_BITS - data->frac_bits;\n\tdiv &= (1 << (data->int_bits + data->frac_bits)) - 1;\n\n\tif (div == 0)\n\t\treturn 0;\n\n\ttemp = (u64)parent_rate << data->frac_bits;\n\n\tdo_div(temp, div);\n\n\treturn temp;\n}\n\nstatic unsigned long bcm2835_round_rate(unsigned long rate)\n{\n\tunsigned long scaler;\n\tunsigned long limit;\n\n\tlimit = rate / 100000;\n\n\tscaler = 1;\n\twhile (scaler < limit)\n\t\tscaler *= 10;\n\n\t \n\tif ((rate + scaler - 1) / scaler % 1000 == 0)\n\t\trate = roundup(rate, scaler);\n\n\treturn rate;\n}\n\nstatic unsigned long bcm2835_clock_get_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\n\tstruct bcm2835_cprman *cprman = clock->cprman;\n\tconst struct bcm2835_clock_data *data = clock->data;\n\tunsigned long rate;\n\tu32 div;\n\n\tif (data->int_bits == 0 && data->frac_bits == 0)\n\t\treturn parent_rate;\n\n\tdiv = cprman_read(cprman, data->div_reg);\n\n\trate = bcm2835_clock_rate_from_divisor(clock, parent_rate, div);\n\n\tif (data->round_up)\n\t\trate = bcm2835_round_rate(rate);\n\n\treturn rate;\n}\n\nstatic void bcm2835_clock_wait_busy(struct bcm2835_clock *clock)\n{\n\tstruct bcm2835_cprman *cprman = clock->cprman;\n\tconst struct bcm2835_clock_data *data = clock->data;\n\tktime_t timeout = ktime_add_ns(ktime_get(), LOCK_TIMEOUT_NS);\n\n\twhile (cprman_read(cprman, data->ctl_reg) & CM_BUSY) {\n\t\tif (ktime_after(ktime_get(), timeout)) {\n\t\t\tdev_err(cprman->dev, \"%s: couldn't lock PLL\\n\",\n\t\t\t\tclk_hw_get_name(&clock->hw));\n\t\t\treturn;\n\t\t}\n\t\tcpu_relax();\n\t}\n}\n\nstatic void bcm2835_clock_off(struct clk_hw *hw)\n{\n\tstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\n\tstruct bcm2835_cprman *cprman = clock->cprman;\n\tconst struct bcm2835_clock_data *data = clock->data;\n\n\tspin_lock(&cprman->regs_lock);\n\tcprman_write(cprman, data->ctl_reg,\n\t\t     cprman_read(cprman, data->ctl_reg) & ~CM_ENABLE);\n\tspin_unlock(&cprman->regs_lock);\n\n\t \n\tbcm2835_clock_wait_busy(clock);\n}\n\nstatic int bcm2835_clock_on(struct clk_hw *hw)\n{\n\tstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\n\tstruct bcm2835_cprman *cprman = clock->cprman;\n\tconst struct bcm2835_clock_data *data = clock->data;\n\n\tspin_lock(&cprman->regs_lock);\n\tcprman_write(cprman, data->ctl_reg,\n\t\t     cprman_read(cprman, data->ctl_reg) |\n\t\t     CM_ENABLE |\n\t\t     CM_GATE);\n\tspin_unlock(&cprman->regs_lock);\n\n\t \n\tif (data->tcnt_mux && false) {\n\t\tdev_info(cprman->dev,\n\t\t\t \"clk %s: rate %ld, measure %ld\\n\",\n\t\t\t data->name,\n\t\t\t clk_hw_get_rate(hw),\n\t\t\t bcm2835_measure_tcnt_mux(cprman, data->tcnt_mux));\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm2835_clock_set_rate(struct clk_hw *hw,\n\t\t\t\t  unsigned long rate, unsigned long parent_rate)\n{\n\tstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\n\tstruct bcm2835_cprman *cprman = clock->cprman;\n\tconst struct bcm2835_clock_data *data = clock->data;\n\tu32 div = bcm2835_clock_choose_div(hw, rate, parent_rate);\n\tu32 ctl;\n\n\tspin_lock(&cprman->regs_lock);\n\n\t \n\tctl = cprman_read(cprman, data->ctl_reg) & ~CM_FRAC;\n\tctl |= (div & CM_DIV_FRAC_MASK) ? CM_FRAC : 0;\n\tcprman_write(cprman, data->ctl_reg, ctl);\n\n\tcprman_write(cprman, data->div_reg, div);\n\n\tspin_unlock(&cprman->regs_lock);\n\n\treturn 0;\n}\n\nstatic bool\nbcm2835_clk_is_pllc(struct clk_hw *hw)\n{\n\tif (!hw)\n\t\treturn false;\n\n\treturn strncmp(clk_hw_get_name(hw), \"pllc\", 4) == 0;\n}\n\nstatic unsigned long bcm2835_clock_choose_div_and_prate(struct clk_hw *hw,\n\t\t\t\t\t\t\tint parent_idx,\n\t\t\t\t\t\t\tunsigned long rate,\n\t\t\t\t\t\t\tu32 *div,\n\t\t\t\t\t\t\tunsigned long *prate,\n\t\t\t\t\t\t\tunsigned long *avgrate)\n{\n\tstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\n\tstruct bcm2835_cprman *cprman = clock->cprman;\n\tconst struct bcm2835_clock_data *data = clock->data;\n\tunsigned long best_rate = 0;\n\tu32 curdiv, mindiv, maxdiv;\n\tstruct clk_hw *parent;\n\n\tparent = clk_hw_get_parent_by_index(hw, parent_idx);\n\n\tif (!(BIT(parent_idx) & data->set_rate_parent)) {\n\t\t*prate = clk_hw_get_rate(parent);\n\t\t*div = bcm2835_clock_choose_div(hw, rate, *prate);\n\n\t\t*avgrate = bcm2835_clock_rate_from_divisor(clock, *prate, *div);\n\n\t\tif (data->low_jitter && (*div & CM_DIV_FRAC_MASK)) {\n\t\t\tunsigned long high, low;\n\t\t\tu32 int_div = *div & ~CM_DIV_FRAC_MASK;\n\n\t\t\thigh = bcm2835_clock_rate_from_divisor(clock, *prate,\n\t\t\t\t\t\t\t       int_div);\n\t\t\tint_div += CM_DIV_FRAC_MASK + 1;\n\t\t\tlow = bcm2835_clock_rate_from_divisor(clock, *prate,\n\t\t\t\t\t\t\t      int_div);\n\n\t\t\t \n\t\t\treturn *avgrate - max(*avgrate - low, high - *avgrate);\n\t\t}\n\t\treturn *avgrate;\n\t}\n\n\tif (data->frac_bits)\n\t\tdev_warn(cprman->dev,\n\t\t\t\"frac bits are not used when propagating rate change\");\n\n\t \n\tmindiv = data->is_mash_clock ? 2 : 1;\n\tmaxdiv = BIT(data->int_bits) - 1;\n\n\t \n\tfor (curdiv = mindiv; curdiv <= maxdiv; curdiv++) {\n\t\tunsigned long tmp_rate;\n\n\t\ttmp_rate = clk_hw_round_rate(parent, rate * curdiv);\n\t\ttmp_rate /= curdiv;\n\t\tif (curdiv == mindiv ||\n\t\t    (tmp_rate > best_rate && tmp_rate <= rate))\n\t\t\tbest_rate = tmp_rate;\n\n\t\tif (best_rate == rate)\n\t\t\tbreak;\n\t}\n\n\t*div = curdiv << CM_DIV_FRAC_BITS;\n\t*prate = curdiv * best_rate;\n\t*avgrate = best_rate;\n\n\treturn best_rate;\n}\n\nstatic int bcm2835_clock_determine_rate(struct clk_hw *hw,\n\t\t\t\t\tstruct clk_rate_request *req)\n{\n\tstruct clk_hw *parent, *best_parent = NULL;\n\tbool current_parent_is_pllc;\n\tunsigned long rate, best_rate = 0;\n\tunsigned long prate, best_prate = 0;\n\tunsigned long avgrate, best_avgrate = 0;\n\tsize_t i;\n\tu32 div;\n\n\tcurrent_parent_is_pllc = bcm2835_clk_is_pllc(clk_hw_get_parent(hw));\n\n\t \n\tfor (i = 0; i < clk_hw_get_num_parents(hw); ++i) {\n\t\tparent = clk_hw_get_parent_by_index(hw, i);\n\t\tif (!parent)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (bcm2835_clk_is_pllc(parent) && !current_parent_is_pllc)\n\t\t\tcontinue;\n\n\t\trate = bcm2835_clock_choose_div_and_prate(hw, i, req->rate,\n\t\t\t\t\t\t\t  &div, &prate,\n\t\t\t\t\t\t\t  &avgrate);\n\t\tif (abs(req->rate - rate) < abs(req->rate - best_rate)) {\n\t\t\tbest_parent = parent;\n\t\t\tbest_prate = prate;\n\t\t\tbest_rate = rate;\n\t\t\tbest_avgrate = avgrate;\n\t\t}\n\t}\n\n\tif (!best_parent)\n\t\treturn -EINVAL;\n\n\treq->best_parent_hw = best_parent;\n\treq->best_parent_rate = best_prate;\n\n\treq->rate = best_avgrate;\n\n\treturn 0;\n}\n\nstatic int bcm2835_clock_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\n\tstruct bcm2835_cprman *cprman = clock->cprman;\n\tconst struct bcm2835_clock_data *data = clock->data;\n\tu8 src = (index << CM_SRC_SHIFT) & CM_SRC_MASK;\n\n\tcprman_write(cprman, data->ctl_reg, src);\n\treturn 0;\n}\n\nstatic u8 bcm2835_clock_get_parent(struct clk_hw *hw)\n{\n\tstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\n\tstruct bcm2835_cprman *cprman = clock->cprman;\n\tconst struct bcm2835_clock_data *data = clock->data;\n\tu32 src = cprman_read(cprman, data->ctl_reg);\n\n\treturn (src & CM_SRC_MASK) >> CM_SRC_SHIFT;\n}\n\nstatic const struct debugfs_reg32 bcm2835_debugfs_clock_reg32[] = {\n\t{\n\t\t.name = \"ctl\",\n\t\t.offset = 0,\n\t},\n\t{\n\t\t.name = \"div\",\n\t\t.offset = 4,\n\t},\n};\n\nstatic void bcm2835_clock_debug_init(struct clk_hw *hw,\n\t\t\t\t    struct dentry *dentry)\n{\n\tstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\n\tstruct bcm2835_cprman *cprman = clock->cprman;\n\tconst struct bcm2835_clock_data *data = clock->data;\n\n\tbcm2835_debugfs_regset(cprman, data->ctl_reg,\n\t\tbcm2835_debugfs_clock_reg32,\n\t\tARRAY_SIZE(bcm2835_debugfs_clock_reg32),\n\t\tdentry);\n}\n\nstatic const struct clk_ops bcm2835_clock_clk_ops = {\n\t.is_prepared = bcm2835_clock_is_on,\n\t.prepare = bcm2835_clock_on,\n\t.unprepare = bcm2835_clock_off,\n\t.recalc_rate = bcm2835_clock_get_rate,\n\t.set_rate = bcm2835_clock_set_rate,\n\t.determine_rate = bcm2835_clock_determine_rate,\n\t.set_parent = bcm2835_clock_set_parent,\n\t.get_parent = bcm2835_clock_get_parent,\n\t.debug_init = bcm2835_clock_debug_init,\n};\n\nstatic int bcm2835_vpu_clock_is_on(struct clk_hw *hw)\n{\n\treturn true;\n}\n\n \nstatic const struct clk_ops bcm2835_vpu_clock_clk_ops = {\n\t.is_prepared = bcm2835_vpu_clock_is_on,\n\t.recalc_rate = bcm2835_clock_get_rate,\n\t.set_rate = bcm2835_clock_set_rate,\n\t.determine_rate = bcm2835_clock_determine_rate,\n\t.set_parent = bcm2835_clock_set_parent,\n\t.get_parent = bcm2835_clock_get_parent,\n\t.debug_init = bcm2835_clock_debug_init,\n};\n\nstatic struct clk_hw *bcm2835_register_pll(struct bcm2835_cprman *cprman,\n\t\t\t\t\t   const void *data)\n{\n\tconst struct bcm2835_pll_data *pll_data = data;\n\tstruct bcm2835_pll *pll;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tmemset(&init, 0, sizeof(init));\n\n\t \n\tinit.parent_names = &cprman->real_parent_names[0];\n\tinit.num_parents = 1;\n\tinit.name = pll_data->name;\n\tinit.ops = &bcm2835_pll_clk_ops;\n\tinit.flags = pll_data->flags | CLK_IGNORE_UNUSED;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn NULL;\n\n\tpll->cprman = cprman;\n\tpll->data = pll_data;\n\tpll->hw.init = &init;\n\n\tret = devm_clk_hw_register(cprman->dev, &pll->hw);\n\tif (ret) {\n\t\tkfree(pll);\n\t\treturn NULL;\n\t}\n\treturn &pll->hw;\n}\n\nstatic struct clk_hw *\nbcm2835_register_pll_divider(struct bcm2835_cprman *cprman,\n\t\t\t     const void *data)\n{\n\tconst struct bcm2835_pll_divider_data *divider_data = data;\n\tstruct bcm2835_pll_divider *divider;\n\tstruct clk_init_data init;\n\tconst char *divider_name;\n\tint ret;\n\n\tif (divider_data->fixed_divider != 1) {\n\t\tdivider_name = devm_kasprintf(cprman->dev, GFP_KERNEL,\n\t\t\t\t\t      \"%s_prediv\", divider_data->name);\n\t\tif (!divider_name)\n\t\t\treturn NULL;\n\t} else {\n\t\tdivider_name = divider_data->name;\n\t}\n\n\tmemset(&init, 0, sizeof(init));\n\n\tinit.parent_names = &divider_data->source_pll;\n\tinit.num_parents = 1;\n\tinit.name = divider_name;\n\tinit.ops = &bcm2835_pll_divider_clk_ops;\n\tinit.flags = divider_data->flags | CLK_IGNORE_UNUSED;\n\n\tdivider = devm_kzalloc(cprman->dev, sizeof(*divider), GFP_KERNEL);\n\tif (!divider)\n\t\treturn NULL;\n\n\tdivider->div.reg = cprman->regs + divider_data->a2w_reg;\n\tdivider->div.shift = A2W_PLL_DIV_SHIFT;\n\tdivider->div.width = A2W_PLL_DIV_BITS;\n\tdivider->div.flags = CLK_DIVIDER_MAX_AT_ZERO;\n\tdivider->div.lock = &cprman->regs_lock;\n\tdivider->div.hw.init = &init;\n\tdivider->div.table = NULL;\n\n\tdivider->cprman = cprman;\n\tdivider->data = divider_data;\n\n\tret = devm_clk_hw_register(cprman->dev, &divider->div.hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t \n\tif (divider_data->fixed_divider != 1) {\n\t\treturn clk_hw_register_fixed_factor(cprman->dev,\n\t\t\t\t\t\t    divider_data->name,\n\t\t\t\t\t\t    divider_name,\n\t\t\t\t\t\t    CLK_SET_RATE_PARENT,\n\t\t\t\t\t\t    1,\n\t\t\t\t\t\t    divider_data->fixed_divider);\n\t}\n\n\treturn &divider->div.hw;\n}\n\nstatic struct clk_hw *bcm2835_register_clock(struct bcm2835_cprman *cprman,\n\t\t\t\t\t     const void *data)\n{\n\tconst struct bcm2835_clock_data *clock_data = data;\n\tstruct bcm2835_clock *clock;\n\tstruct clk_init_data init;\n\tconst char *parents[1 << CM_SRC_BITS];\n\tsize_t i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < clock_data->num_mux_parents; i++) {\n\t\tparents[i] = clock_data->parents[i];\n\n\t\tret = match_string(cprman_parent_names,\n\t\t\t\t   ARRAY_SIZE(cprman_parent_names),\n\t\t\t\t   parents[i]);\n\t\tif (ret >= 0)\n\t\t\tparents[i] = cprman->real_parent_names[ret];\n\t}\n\n\tmemset(&init, 0, sizeof(init));\n\tinit.parent_names = parents;\n\tinit.num_parents = clock_data->num_mux_parents;\n\tinit.name = clock_data->name;\n\tinit.flags = clock_data->flags | CLK_IGNORE_UNUSED;\n\n\t \n\tif (clock_data->set_rate_parent)\n\t\tinit.flags |= CLK_SET_RATE_PARENT;\n\n\tif (clock_data->is_vpu_clock) {\n\t\tinit.ops = &bcm2835_vpu_clock_clk_ops;\n\t} else {\n\t\tinit.ops = &bcm2835_clock_clk_ops;\n\t\tinit.flags |= CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\n\n\t\t \n\t\tif (!(cprman_read(cprman, clock_data->ctl_reg) & CM_ENABLE))\n\t\t\tinit.flags &= ~CLK_IS_CRITICAL;\n\t}\n\n\tclock = devm_kzalloc(cprman->dev, sizeof(*clock), GFP_KERNEL);\n\tif (!clock)\n\t\treturn NULL;\n\n\tclock->cprman = cprman;\n\tclock->data = clock_data;\n\tclock->hw.init = &init;\n\n\tret = devm_clk_hw_register(cprman->dev, &clock->hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\treturn &clock->hw;\n}\n\nstatic struct clk_hw *bcm2835_register_gate(struct bcm2835_cprman *cprman,\n\t\t\t\t\t    const void *data)\n{\n\tconst struct bcm2835_gate_data *gate_data = data;\n\n\treturn clk_hw_register_gate(cprman->dev, gate_data->name,\n\t\t\t\t    gate_data->parent,\n\t\t\t\t    CLK_IGNORE_UNUSED | CLK_SET_RATE_GATE,\n\t\t\t\t    cprman->regs + gate_data->ctl_reg,\n\t\t\t\t    CM_GATE_BIT, 0, &cprman->regs_lock);\n}\n\nstruct bcm2835_clk_desc {\n\tstruct clk_hw *(*clk_register)(struct bcm2835_cprman *cprman,\n\t\t\t\t       const void *data);\n\tunsigned int supported;\n\tconst void *data;\n};\n\n \n#define _REGISTER(f, s, ...) { .clk_register = f, \\\n\t\t\t       .supported = s,\t\t\t\t\\\n\t\t\t       .data = __VA_ARGS__ }\n#define REGISTER_PLL(s, ...)\t_REGISTER(&bcm2835_register_pll,\t\\\n\t\t\t\t\t  s,\t\t\t\t\\\n\t\t\t\t\t  &(struct bcm2835_pll_data)\t\\\n\t\t\t\t\t  {__VA_ARGS__})\n#define REGISTER_PLL_DIV(s, ...) _REGISTER(&bcm2835_register_pll_divider, \\\n\t\t\t\t\t   s,\t\t\t\t  \\\n\t\t\t\t\t   &(struct bcm2835_pll_divider_data) \\\n\t\t\t\t\t   {__VA_ARGS__})\n#define REGISTER_CLK(s, ...)\t_REGISTER(&bcm2835_register_clock,\t\\\n\t\t\t\t\t  s,\t\t\t\t\\\n\t\t\t\t\t  &(struct bcm2835_clock_data)\t\\\n\t\t\t\t\t  {__VA_ARGS__})\n#define REGISTER_GATE(s, ...)\t_REGISTER(&bcm2835_register_gate,\t\\\n\t\t\t\t\t  s,\t\t\t\t\\\n\t\t\t\t\t  &(struct bcm2835_gate_data)\t\\\n\t\t\t\t\t  {__VA_ARGS__})\n\n \n\n \nstatic const char *const bcm2835_clock_osc_parents[] = {\n\t\"gnd\",\n\t\"xosc\",\n\t\"testdebug0\",\n\t\"testdebug1\"\n};\n\n#define REGISTER_OSC_CLK(s, ...)\tREGISTER_CLK(\t\t\t\\\n\ts,\t\t\t\t\t\t\t\t\\\n\t.num_mux_parents = ARRAY_SIZE(bcm2835_clock_osc_parents),\t\\\n\t.parents = bcm2835_clock_osc_parents,\t\t\t\t\\\n\t__VA_ARGS__)\n\n \nstatic const char *const bcm2835_clock_per_parents[] = {\n\t\"gnd\",\n\t\"xosc\",\n\t\"testdebug0\",\n\t\"testdebug1\",\n\t\"plla_per\",\n\t\"pllc_per\",\n\t\"plld_per\",\n\t\"pllh_aux\",\n};\n\n#define REGISTER_PER_CLK(s, ...)\tREGISTER_CLK(\t\t\t\\\n\ts,\t\t\t\t\t\t\t\t\\\n\t.num_mux_parents = ARRAY_SIZE(bcm2835_clock_per_parents),\t\\\n\t.parents = bcm2835_clock_per_parents,\t\t\t\t\\\n\t__VA_ARGS__)\n\n \nstatic const char *const bcm2835_pcm_per_parents[] = {\n\t\"-\",\n\t\"xosc\",\n\t\"-\",\n\t\"-\",\n\t\"-\",\n\t\"-\",\n\t\"plld_per\",\n\t\"-\",\n};\n\n#define REGISTER_PCM_CLK(s, ...)\tREGISTER_CLK(\t\t\t\\\n\ts,\t\t\t\t\t\t\t\t\\\n\t.num_mux_parents = ARRAY_SIZE(bcm2835_pcm_per_parents),\t\t\\\n\t.parents = bcm2835_pcm_per_parents,\t\t\t\t\\\n\t__VA_ARGS__)\n\n \nstatic const char *const bcm2835_clock_vpu_parents[] = {\n\t\"gnd\",\n\t\"xosc\",\n\t\"testdebug0\",\n\t\"testdebug1\",\n\t\"plla_core\",\n\t\"pllc_core0\",\n\t\"plld_core\",\n\t\"pllh_aux\",\n\t\"pllc_core1\",\n\t\"pllc_core2\",\n};\n\n#define REGISTER_VPU_CLK(s, ...)\tREGISTER_CLK(\t\t\t\\\n\ts,\t\t\t\t\t\t\t\t\\\n\t.num_mux_parents = ARRAY_SIZE(bcm2835_clock_vpu_parents),\t\\\n\t.parents = bcm2835_clock_vpu_parents,\t\t\t\t\\\n\t__VA_ARGS__)\n\n \nstatic const char *const bcm2835_clock_dsi0_parents[] = {\n\t\"gnd\",\n\t\"xosc\",\n\t\"testdebug0\",\n\t\"testdebug1\",\n\t\"dsi0_ddr\",\n\t\"dsi0_ddr_inv\",\n\t\"dsi0_ddr2\",\n\t\"dsi0_ddr2_inv\",\n\t\"dsi0_byte\",\n\t\"dsi0_byte_inv\",\n};\n\nstatic const char *const bcm2835_clock_dsi1_parents[] = {\n\t\"gnd\",\n\t\"xosc\",\n\t\"testdebug0\",\n\t\"testdebug1\",\n\t\"dsi1_ddr\",\n\t\"dsi1_ddr_inv\",\n\t\"dsi1_ddr2\",\n\t\"dsi1_ddr2_inv\",\n\t\"dsi1_byte\",\n\t\"dsi1_byte_inv\",\n};\n\n#define REGISTER_DSI0_CLK(s, ...)\tREGISTER_CLK(\t\t\t\\\n\ts,\t\t\t\t\t\t\t\t\\\n\t.num_mux_parents = ARRAY_SIZE(bcm2835_clock_dsi0_parents),\t\\\n\t.parents = bcm2835_clock_dsi0_parents,\t\t\t\t\\\n\t__VA_ARGS__)\n\n#define REGISTER_DSI1_CLK(s, ...)\tREGISTER_CLK(\t\t\t\\\n\ts,\t\t\t\t\t\t\t\t\\\n\t.num_mux_parents = ARRAY_SIZE(bcm2835_clock_dsi1_parents),\t\\\n\t.parents = bcm2835_clock_dsi1_parents,\t\t\t\t\\\n\t__VA_ARGS__)\n\n \nstatic const struct bcm2835_clk_desc clk_desc_array[] = {\n\t \n\n\t \n\t[BCM2835_PLLA]\t\t= REGISTER_PLL(\n\t\tSOC_ALL,\n\t\t.name = \"plla\",\n\t\t.cm_ctrl_reg = CM_PLLA,\n\t\t.a2w_ctrl_reg = A2W_PLLA_CTRL,\n\t\t.frac_reg = A2W_PLLA_FRAC,\n\t\t.ana_reg_base = A2W_PLLA_ANA0,\n\t\t.reference_enable_mask = A2W_XOSC_CTRL_PLLA_ENABLE,\n\t\t.lock_mask = CM_LOCK_FLOCKA,\n\n\t\t.ana = &bcm2835_ana_default,\n\n\t\t.min_rate = 600000000u,\n\t\t.max_rate = 2400000000u,\n\t\t.max_fb_rate = BCM2835_MAX_FB_RATE),\n\t[BCM2835_PLLA_CORE]\t= REGISTER_PLL_DIV(\n\t\tSOC_ALL,\n\t\t.name = \"plla_core\",\n\t\t.source_pll = \"plla\",\n\t\t.cm_reg = CM_PLLA,\n\t\t.a2w_reg = A2W_PLLA_CORE,\n\t\t.load_mask = CM_PLLA_LOADCORE,\n\t\t.hold_mask = CM_PLLA_HOLDCORE,\n\t\t.fixed_divider = 1,\n\t\t.flags = CLK_SET_RATE_PARENT),\n\t[BCM2835_PLLA_PER]\t= REGISTER_PLL_DIV(\n\t\tSOC_ALL,\n\t\t.name = \"plla_per\",\n\t\t.source_pll = \"plla\",\n\t\t.cm_reg = CM_PLLA,\n\t\t.a2w_reg = A2W_PLLA_PER,\n\t\t.load_mask = CM_PLLA_LOADPER,\n\t\t.hold_mask = CM_PLLA_HOLDPER,\n\t\t.fixed_divider = 1,\n\t\t.flags = CLK_SET_RATE_PARENT),\n\t[BCM2835_PLLA_DSI0]\t= REGISTER_PLL_DIV(\n\t\tSOC_ALL,\n\t\t.name = \"plla_dsi0\",\n\t\t.source_pll = \"plla\",\n\t\t.cm_reg = CM_PLLA,\n\t\t.a2w_reg = A2W_PLLA_DSI0,\n\t\t.load_mask = CM_PLLA_LOADDSI0,\n\t\t.hold_mask = CM_PLLA_HOLDDSI0,\n\t\t.fixed_divider = 1),\n\t[BCM2835_PLLA_CCP2]\t= REGISTER_PLL_DIV(\n\t\tSOC_ALL,\n\t\t.name = \"plla_ccp2\",\n\t\t.source_pll = \"plla\",\n\t\t.cm_reg = CM_PLLA,\n\t\t.a2w_reg = A2W_PLLA_CCP2,\n\t\t.load_mask = CM_PLLA_LOADCCP2,\n\t\t.hold_mask = CM_PLLA_HOLDCCP2,\n\t\t.fixed_divider = 1,\n\t\t.flags = CLK_SET_RATE_PARENT),\n\n\t \n\t[BCM2835_PLLB]\t\t= REGISTER_PLL(\n\t\tSOC_ALL,\n\t\t.name = \"pllb\",\n\t\t.cm_ctrl_reg = CM_PLLB,\n\t\t.a2w_ctrl_reg = A2W_PLLB_CTRL,\n\t\t.frac_reg = A2W_PLLB_FRAC,\n\t\t.ana_reg_base = A2W_PLLB_ANA0,\n\t\t.reference_enable_mask = A2W_XOSC_CTRL_PLLB_ENABLE,\n\t\t.lock_mask = CM_LOCK_FLOCKB,\n\n\t\t.ana = &bcm2835_ana_default,\n\n\t\t.min_rate = 600000000u,\n\t\t.max_rate = 3000000000u,\n\t\t.max_fb_rate = BCM2835_MAX_FB_RATE,\n\t\t.flags = CLK_GET_RATE_NOCACHE),\n\t[BCM2835_PLLB_ARM]\t= REGISTER_PLL_DIV(\n\t\tSOC_ALL,\n\t\t.name = \"pllb_arm\",\n\t\t.source_pll = \"pllb\",\n\t\t.cm_reg = CM_PLLB,\n\t\t.a2w_reg = A2W_PLLB_ARM,\n\t\t.load_mask = CM_PLLB_LOADARM,\n\t\t.hold_mask = CM_PLLB_HOLDARM,\n\t\t.fixed_divider = 1,\n\t\t.flags = CLK_SET_RATE_PARENT | CLK_GET_RATE_NOCACHE),\n\n\t \n\t[BCM2835_PLLC]\t\t= REGISTER_PLL(\n\t\tSOC_ALL,\n\t\t.name = \"pllc\",\n\t\t.cm_ctrl_reg = CM_PLLC,\n\t\t.a2w_ctrl_reg = A2W_PLLC_CTRL,\n\t\t.frac_reg = A2W_PLLC_FRAC,\n\t\t.ana_reg_base = A2W_PLLC_ANA0,\n\t\t.reference_enable_mask = A2W_XOSC_CTRL_PLLC_ENABLE,\n\t\t.lock_mask = CM_LOCK_FLOCKC,\n\n\t\t.ana = &bcm2835_ana_default,\n\n\t\t.min_rate = 600000000u,\n\t\t.max_rate = 3000000000u,\n\t\t.max_fb_rate = BCM2835_MAX_FB_RATE),\n\t[BCM2835_PLLC_CORE0]\t= REGISTER_PLL_DIV(\n\t\tSOC_ALL,\n\t\t.name = \"pllc_core0\",\n\t\t.source_pll = \"pllc\",\n\t\t.cm_reg = CM_PLLC,\n\t\t.a2w_reg = A2W_PLLC_CORE0,\n\t\t.load_mask = CM_PLLC_LOADCORE0,\n\t\t.hold_mask = CM_PLLC_HOLDCORE0,\n\t\t.fixed_divider = 1,\n\t\t.flags = CLK_SET_RATE_PARENT),\n\t[BCM2835_PLLC_CORE1]\t= REGISTER_PLL_DIV(\n\t\tSOC_ALL,\n\t\t.name = \"pllc_core1\",\n\t\t.source_pll = \"pllc\",\n\t\t.cm_reg = CM_PLLC,\n\t\t.a2w_reg = A2W_PLLC_CORE1,\n\t\t.load_mask = CM_PLLC_LOADCORE1,\n\t\t.hold_mask = CM_PLLC_HOLDCORE1,\n\t\t.fixed_divider = 1,\n\t\t.flags = CLK_SET_RATE_PARENT),\n\t[BCM2835_PLLC_CORE2]\t= REGISTER_PLL_DIV(\n\t\tSOC_ALL,\n\t\t.name = \"pllc_core2\",\n\t\t.source_pll = \"pllc\",\n\t\t.cm_reg = CM_PLLC,\n\t\t.a2w_reg = A2W_PLLC_CORE2,\n\t\t.load_mask = CM_PLLC_LOADCORE2,\n\t\t.hold_mask = CM_PLLC_HOLDCORE2,\n\t\t.fixed_divider = 1,\n\t\t.flags = CLK_SET_RATE_PARENT),\n\t[BCM2835_PLLC_PER]\t= REGISTER_PLL_DIV(\n\t\tSOC_ALL,\n\t\t.name = \"pllc_per\",\n\t\t.source_pll = \"pllc\",\n\t\t.cm_reg = CM_PLLC,\n\t\t.a2w_reg = A2W_PLLC_PER,\n\t\t.load_mask = CM_PLLC_LOADPER,\n\t\t.hold_mask = CM_PLLC_HOLDPER,\n\t\t.fixed_divider = 1,\n\t\t.flags = CLK_IS_CRITICAL | CLK_SET_RATE_PARENT),\n\n\t \n\t[BCM2835_PLLD]\t\t= REGISTER_PLL(\n\t\tSOC_ALL,\n\t\t.name = \"plld\",\n\t\t.cm_ctrl_reg = CM_PLLD,\n\t\t.a2w_ctrl_reg = A2W_PLLD_CTRL,\n\t\t.frac_reg = A2W_PLLD_FRAC,\n\t\t.ana_reg_base = A2W_PLLD_ANA0,\n\t\t.reference_enable_mask = A2W_XOSC_CTRL_DDR_ENABLE,\n\t\t.lock_mask = CM_LOCK_FLOCKD,\n\n\t\t.ana = &bcm2835_ana_default,\n\n\t\t.min_rate = 600000000u,\n\t\t.max_rate = 2400000000u,\n\t\t.max_fb_rate = BCM2835_MAX_FB_RATE),\n\t[BCM2835_PLLD_CORE]\t= REGISTER_PLL_DIV(\n\t\tSOC_ALL,\n\t\t.name = \"plld_core\",\n\t\t.source_pll = \"plld\",\n\t\t.cm_reg = CM_PLLD,\n\t\t.a2w_reg = A2W_PLLD_CORE,\n\t\t.load_mask = CM_PLLD_LOADCORE,\n\t\t.hold_mask = CM_PLLD_HOLDCORE,\n\t\t.fixed_divider = 1,\n\t\t.flags = CLK_SET_RATE_PARENT),\n\t \n\t[BCM2835_PLLD_PER]\t= REGISTER_PLL_DIV(\n\t\tSOC_ALL,\n\t\t.name = \"plld_per\",\n\t\t.source_pll = \"plld\",\n\t\t.cm_reg = CM_PLLD,\n\t\t.a2w_reg = A2W_PLLD_PER,\n\t\t.load_mask = CM_PLLD_LOADPER,\n\t\t.hold_mask = CM_PLLD_HOLDPER,\n\t\t.fixed_divider = 1,\n\t\t.flags = CLK_IS_CRITICAL | CLK_SET_RATE_PARENT),\n\t[BCM2835_PLLD_DSI0]\t= REGISTER_PLL_DIV(\n\t\tSOC_ALL,\n\t\t.name = \"plld_dsi0\",\n\t\t.source_pll = \"plld\",\n\t\t.cm_reg = CM_PLLD,\n\t\t.a2w_reg = A2W_PLLD_DSI0,\n\t\t.load_mask = CM_PLLD_LOADDSI0,\n\t\t.hold_mask = CM_PLLD_HOLDDSI0,\n\t\t.fixed_divider = 1),\n\t[BCM2835_PLLD_DSI1]\t= REGISTER_PLL_DIV(\n\t\tSOC_ALL,\n\t\t.name = \"plld_dsi1\",\n\t\t.source_pll = \"plld\",\n\t\t.cm_reg = CM_PLLD,\n\t\t.a2w_reg = A2W_PLLD_DSI1,\n\t\t.load_mask = CM_PLLD_LOADDSI1,\n\t\t.hold_mask = CM_PLLD_HOLDDSI1,\n\t\t.fixed_divider = 1),\n\n\t \n\t[BCM2835_PLLH]\t\t= REGISTER_PLL(\n\t\tSOC_BCM2835,\n\t\t\"pllh\",\n\t\t.cm_ctrl_reg = CM_PLLH,\n\t\t.a2w_ctrl_reg = A2W_PLLH_CTRL,\n\t\t.frac_reg = A2W_PLLH_FRAC,\n\t\t.ana_reg_base = A2W_PLLH_ANA0,\n\t\t.reference_enable_mask = A2W_XOSC_CTRL_PLLC_ENABLE,\n\t\t.lock_mask = CM_LOCK_FLOCKH,\n\n\t\t.ana = &bcm2835_ana_pllh,\n\n\t\t.min_rate = 600000000u,\n\t\t.max_rate = 3000000000u,\n\t\t.max_fb_rate = BCM2835_MAX_FB_RATE),\n\t[BCM2835_PLLH_RCAL]\t= REGISTER_PLL_DIV(\n\t\tSOC_BCM2835,\n\t\t.name = \"pllh_rcal\",\n\t\t.source_pll = \"pllh\",\n\t\t.cm_reg = CM_PLLH,\n\t\t.a2w_reg = A2W_PLLH_RCAL,\n\t\t.load_mask = CM_PLLH_LOADRCAL,\n\t\t.hold_mask = 0,\n\t\t.fixed_divider = 10,\n\t\t.flags = CLK_SET_RATE_PARENT),\n\t[BCM2835_PLLH_AUX]\t= REGISTER_PLL_DIV(\n\t\tSOC_BCM2835,\n\t\t.name = \"pllh_aux\",\n\t\t.source_pll = \"pllh\",\n\t\t.cm_reg = CM_PLLH,\n\t\t.a2w_reg = A2W_PLLH_AUX,\n\t\t.load_mask = CM_PLLH_LOADAUX,\n\t\t.hold_mask = 0,\n\t\t.fixed_divider = 1,\n\t\t.flags = CLK_SET_RATE_PARENT),\n\t[BCM2835_PLLH_PIX]\t= REGISTER_PLL_DIV(\n\t\tSOC_BCM2835,\n\t\t.name = \"pllh_pix\",\n\t\t.source_pll = \"pllh\",\n\t\t.cm_reg = CM_PLLH,\n\t\t.a2w_reg = A2W_PLLH_PIX,\n\t\t.load_mask = CM_PLLH_LOADPIX,\n\t\t.hold_mask = 0,\n\t\t.fixed_divider = 10,\n\t\t.flags = CLK_SET_RATE_PARENT),\n\n\t \n\n\t \n\n\t \n\t[BCM2835_CLOCK_OTP]\t= REGISTER_OSC_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"otp\",\n\t\t.ctl_reg = CM_OTPCTL,\n\t\t.div_reg = CM_OTPDIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 0,\n\t\t.tcnt_mux = 6),\n\t \n\t[BCM2835_CLOCK_TIMER]\t= REGISTER_OSC_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"timer\",\n\t\t.ctl_reg = CM_TIMERCTL,\n\t\t.div_reg = CM_TIMERDIV,\n\t\t.int_bits = 6,\n\t\t.frac_bits = 12),\n\t \n\t[BCM2835_CLOCK_TSENS]\t= REGISTER_OSC_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"tsens\",\n\t\t.ctl_reg = CM_TSENSCTL,\n\t\t.div_reg = CM_TSENSDIV,\n\t\t.int_bits = 5,\n\t\t.frac_bits = 0),\n\t[BCM2835_CLOCK_TEC]\t= REGISTER_OSC_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"tec\",\n\t\t.ctl_reg = CM_TECCTL,\n\t\t.div_reg = CM_TECDIV,\n\t\t.int_bits = 6,\n\t\t.frac_bits = 0),\n\n\t \n\t[BCM2835_CLOCK_H264]\t= REGISTER_VPU_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"h264\",\n\t\t.ctl_reg = CM_H264CTL,\n\t\t.div_reg = CM_H264DIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 8,\n\t\t.tcnt_mux = 1),\n\t[BCM2835_CLOCK_ISP]\t= REGISTER_VPU_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"isp\",\n\t\t.ctl_reg = CM_ISPCTL,\n\t\t.div_reg = CM_ISPDIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 8,\n\t\t.tcnt_mux = 2),\n\n\t \n\t[BCM2835_CLOCK_SDRAM]\t= REGISTER_VPU_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"sdram\",\n\t\t.ctl_reg = CM_SDCCTL,\n\t\t.div_reg = CM_SDCDIV,\n\t\t.int_bits = 6,\n\t\t.frac_bits = 0,\n\t\t.tcnt_mux = 3),\n\t[BCM2835_CLOCK_V3D]\t= REGISTER_VPU_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"v3d\",\n\t\t.ctl_reg = CM_V3DCTL,\n\t\t.div_reg = CM_V3DDIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 8,\n\t\t.tcnt_mux = 4),\n\t \n\t[BCM2835_CLOCK_VPU]\t= REGISTER_VPU_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"vpu\",\n\t\t.ctl_reg = CM_VPUCTL,\n\t\t.div_reg = CM_VPUDIV,\n\t\t.int_bits = 12,\n\t\t.frac_bits = 8,\n\t\t.flags = CLK_IS_CRITICAL,\n\t\t.is_vpu_clock = true,\n\t\t.tcnt_mux = 5),\n\n\t \n\t[BCM2835_CLOCK_AVEO]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"aveo\",\n\t\t.ctl_reg = CM_AVEOCTL,\n\t\t.div_reg = CM_AVEODIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 0,\n\t\t.tcnt_mux = 38),\n\t[BCM2835_CLOCK_CAM0]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"cam0\",\n\t\t.ctl_reg = CM_CAM0CTL,\n\t\t.div_reg = CM_CAM0DIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 8,\n\t\t.tcnt_mux = 14),\n\t[BCM2835_CLOCK_CAM1]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"cam1\",\n\t\t.ctl_reg = CM_CAM1CTL,\n\t\t.div_reg = CM_CAM1DIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 8,\n\t\t.tcnt_mux = 15),\n\t[BCM2835_CLOCK_DFT]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"dft\",\n\t\t.ctl_reg = CM_DFTCTL,\n\t\t.div_reg = CM_DFTDIV,\n\t\t.int_bits = 5,\n\t\t.frac_bits = 0),\n\t[BCM2835_CLOCK_DPI]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"dpi\",\n\t\t.ctl_reg = CM_DPICTL,\n\t\t.div_reg = CM_DPIDIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 8,\n\t\t.tcnt_mux = 17),\n\n\t \n\t[BCM2835_CLOCK_EMMC]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"emmc\",\n\t\t.ctl_reg = CM_EMMCCTL,\n\t\t.div_reg = CM_EMMCDIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 8,\n\t\t.tcnt_mux = 39),\n\n\t \n\t[BCM2711_CLOCK_EMMC2]\t= REGISTER_PER_CLK(\n\t\tSOC_BCM2711,\n\t\t.name = \"emmc2\",\n\t\t.ctl_reg = CM_EMMC2CTL,\n\t\t.div_reg = CM_EMMC2DIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 8,\n\t\t.tcnt_mux = 42),\n\n\t \n\t[BCM2835_CLOCK_GP0]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"gp0\",\n\t\t.ctl_reg = CM_GP0CTL,\n\t\t.div_reg = CM_GP0DIV,\n\t\t.int_bits = 12,\n\t\t.frac_bits = 12,\n\t\t.is_mash_clock = true,\n\t\t.tcnt_mux = 20),\n\t[BCM2835_CLOCK_GP1]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"gp1\",\n\t\t.ctl_reg = CM_GP1CTL,\n\t\t.div_reg = CM_GP1DIV,\n\t\t.int_bits = 12,\n\t\t.frac_bits = 12,\n\t\t.flags = CLK_IS_CRITICAL,\n\t\t.is_mash_clock = true,\n\t\t.tcnt_mux = 21),\n\t[BCM2835_CLOCK_GP2]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"gp2\",\n\t\t.ctl_reg = CM_GP2CTL,\n\t\t.div_reg = CM_GP2DIV,\n\t\t.int_bits = 12,\n\t\t.frac_bits = 12,\n\t\t.flags = CLK_IS_CRITICAL),\n\n\t \n\t[BCM2835_CLOCK_HSM]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"hsm\",\n\t\t.ctl_reg = CM_HSMCTL,\n\t\t.div_reg = CM_HSMDIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 8,\n\t\t.tcnt_mux = 22),\n\t[BCM2835_CLOCK_PCM]\t= REGISTER_PCM_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"pcm\",\n\t\t.ctl_reg = CM_PCMCTL,\n\t\t.div_reg = CM_PCMDIV,\n\t\t.int_bits = 12,\n\t\t.frac_bits = 12,\n\t\t.is_mash_clock = true,\n\t\t.low_jitter = true,\n\t\t.tcnt_mux = 23),\n\t[BCM2835_CLOCK_PWM]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"pwm\",\n\t\t.ctl_reg = CM_PWMCTL,\n\t\t.div_reg = CM_PWMDIV,\n\t\t.int_bits = 12,\n\t\t.frac_bits = 12,\n\t\t.is_mash_clock = true,\n\t\t.tcnt_mux = 24),\n\t[BCM2835_CLOCK_SLIM]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"slim\",\n\t\t.ctl_reg = CM_SLIMCTL,\n\t\t.div_reg = CM_SLIMDIV,\n\t\t.int_bits = 12,\n\t\t.frac_bits = 12,\n\t\t.is_mash_clock = true,\n\t\t.tcnt_mux = 25),\n\t[BCM2835_CLOCK_SMI]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"smi\",\n\t\t.ctl_reg = CM_SMICTL,\n\t\t.div_reg = CM_SMIDIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 8,\n\t\t.tcnt_mux = 27),\n\t[BCM2835_CLOCK_UART]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"uart\",\n\t\t.ctl_reg = CM_UARTCTL,\n\t\t.div_reg = CM_UARTDIV,\n\t\t.int_bits = 10,\n\t\t.frac_bits = 12,\n\t\t.tcnt_mux = 28,\n\t\t.round_up = true),\n\n\t \n\t[BCM2835_CLOCK_VEC]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"vec\",\n\t\t.ctl_reg = CM_VECCTL,\n\t\t.div_reg = CM_VECDIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 0,\n\t\t \n\t\t.set_rate_parent = BIT(7),\n\t\t.tcnt_mux = 29),\n\n\t \n\t[BCM2835_CLOCK_DSI0E]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"dsi0e\",\n\t\t.ctl_reg = CM_DSI0ECTL,\n\t\t.div_reg = CM_DSI0EDIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 8,\n\t\t.tcnt_mux = 18),\n\t[BCM2835_CLOCK_DSI1E]\t= REGISTER_PER_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"dsi1e\",\n\t\t.ctl_reg = CM_DSI1ECTL,\n\t\t.div_reg = CM_DSI1EDIV,\n\t\t.int_bits = 4,\n\t\t.frac_bits = 8,\n\t\t.tcnt_mux = 19),\n\t[BCM2835_CLOCK_DSI0P]\t= REGISTER_DSI0_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"dsi0p\",\n\t\t.ctl_reg = CM_DSI0PCTL,\n\t\t.div_reg = CM_DSI0PDIV,\n\t\t.int_bits = 0,\n\t\t.frac_bits = 0,\n\t\t.tcnt_mux = 12),\n\t[BCM2835_CLOCK_DSI1P]\t= REGISTER_DSI1_CLK(\n\t\tSOC_ALL,\n\t\t.name = \"dsi1p\",\n\t\t.ctl_reg = CM_DSI1PCTL,\n\t\t.div_reg = CM_DSI1PDIV,\n\t\t.int_bits = 0,\n\t\t.frac_bits = 0,\n\t\t.tcnt_mux = 13),\n\n\t \n\n\t \n\t[BCM2835_CLOCK_PERI_IMAGE] = REGISTER_GATE(\n\t\tSOC_ALL,\n\t\t.name = \"peri_image\",\n\t\t.parent = \"vpu\",\n\t\t.ctl_reg = CM_PERIICTL),\n};\n\n \nstatic int bcm2835_mark_sdc_parent_critical(struct clk *sdc)\n{\n\tstruct clk *parent = clk_get_parent(sdc);\n\n\tif (IS_ERR(parent))\n\t\treturn PTR_ERR(parent);\n\n\treturn clk_prepare_enable(parent);\n}\n\nstatic int bcm2835_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct clk_hw **hws;\n\tstruct bcm2835_cprman *cprman;\n\tconst struct bcm2835_clk_desc *desc;\n\tconst size_t asize = ARRAY_SIZE(clk_desc_array);\n\tconst struct cprman_plat_data *pdata;\n\tsize_t i;\n\tint ret;\n\n\tpdata = of_device_get_match_data(&pdev->dev);\n\tif (!pdata)\n\t\treturn -ENODEV;\n\n\tcprman = devm_kzalloc(dev,\n\t\t\t      struct_size(cprman, onecell.hws, asize),\n\t\t\t      GFP_KERNEL);\n\tif (!cprman)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&cprman->regs_lock);\n\tcprman->dev = dev;\n\tcprman->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(cprman->regs))\n\t\treturn PTR_ERR(cprman->regs);\n\n\tmemcpy(cprman->real_parent_names, cprman_parent_names,\n\t       sizeof(cprman_parent_names));\n\tof_clk_parent_fill(dev->of_node, cprman->real_parent_names,\n\t\t\t   ARRAY_SIZE(cprman_parent_names));\n\n\t \n\tif (!cprman->real_parent_names[0])\n\t\treturn -ENODEV;\n\n\tplatform_set_drvdata(pdev, cprman);\n\n\tcprman->onecell.num = asize;\n\tcprman->soc = pdata->soc;\n\thws = cprman->onecell.hws;\n\n\tfor (i = 0; i < asize; i++) {\n\t\tdesc = &clk_desc_array[i];\n\t\tif (desc->clk_register && desc->data &&\n\t\t    (desc->supported & pdata->soc)) {\n\t\t\thws[i] = desc->clk_register(cprman, desc->data);\n\t\t}\n\t}\n\n\tret = bcm2835_mark_sdc_parent_critical(hws[BCM2835_CLOCK_SDRAM]->clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn of_clk_add_hw_provider(dev->of_node, of_clk_hw_onecell_get,\n\t\t\t\t      &cprman->onecell);\n}\n\nstatic const struct cprman_plat_data cprman_bcm2835_plat_data = {\n\t.soc = SOC_BCM2835,\n};\n\nstatic const struct cprman_plat_data cprman_bcm2711_plat_data = {\n\t.soc = SOC_BCM2711,\n};\n\nstatic const struct of_device_id bcm2835_clk_of_match[] = {\n\t{ .compatible = \"brcm,bcm2835-cprman\", .data = &cprman_bcm2835_plat_data },\n\t{ .compatible = \"brcm,bcm2711-cprman\", .data = &cprman_bcm2711_plat_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, bcm2835_clk_of_match);\n\nstatic struct platform_driver bcm2835_clk_driver = {\n\t.driver = {\n\t\t.name = \"bcm2835-clk\",\n\t\t.of_match_table = bcm2835_clk_of_match,\n\t},\n\t.probe          = bcm2835_clk_probe,\n};\n\nbuiltin_platform_driver(bcm2835_clk_driver);\n\nMODULE_AUTHOR(\"Eric Anholt <eric@anholt.net>\");\nMODULE_DESCRIPTION(\"BCM2835 clock driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}