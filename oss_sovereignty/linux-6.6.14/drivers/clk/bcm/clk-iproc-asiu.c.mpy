{
  "module_name": "clk-iproc-asiu.c",
  "hash_id": "dba6544f3b44a6320d69f11a989ea0f3f13ae949ab10b22a9671a868623e88f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/bcm/clk-iproc-asiu.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/clkdev.h>\n#include <linux/of_address.h>\n#include <linux/delay.h>\n\n#include \"clk-iproc.h\"\n\nstruct iproc_asiu;\n\nstruct iproc_asiu_clk {\n\tstruct clk_hw hw;\n\tconst char *name;\n\tstruct iproc_asiu *asiu;\n\tunsigned long rate;\n\tstruct iproc_asiu_div div;\n\tstruct iproc_asiu_gate gate;\n};\n\nstruct iproc_asiu {\n\tvoid __iomem *div_base;\n\tvoid __iomem *gate_base;\n\n\tstruct clk_hw_onecell_data *clk_data;\n\tstruct iproc_asiu_clk *clks;\n};\n\n#define to_asiu_clk(hw) container_of(hw, struct iproc_asiu_clk, hw)\n\nstatic int iproc_asiu_clk_enable(struct clk_hw *hw)\n{\n\tstruct iproc_asiu_clk *clk = to_asiu_clk(hw);\n\tstruct iproc_asiu *asiu = clk->asiu;\n\tu32 val;\n\n\t \n\tif (clk->gate.offset == IPROC_CLK_INVALID_OFFSET)\n\t\treturn 0;\n\n\tval = readl(asiu->gate_base + clk->gate.offset);\n\tval |= (1 << clk->gate.en_shift);\n\twritel(val, asiu->gate_base + clk->gate.offset);\n\n\treturn 0;\n}\n\nstatic void iproc_asiu_clk_disable(struct clk_hw *hw)\n{\n\tstruct iproc_asiu_clk *clk = to_asiu_clk(hw);\n\tstruct iproc_asiu *asiu = clk->asiu;\n\tu32 val;\n\n\t \n\tif (clk->gate.offset == IPROC_CLK_INVALID_OFFSET)\n\t\treturn;\n\n\tval = readl(asiu->gate_base + clk->gate.offset);\n\tval &= ~(1 << clk->gate.en_shift);\n\twritel(val, asiu->gate_base + clk->gate.offset);\n}\n\nstatic unsigned long iproc_asiu_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct iproc_asiu_clk *clk = to_asiu_clk(hw);\n\tstruct iproc_asiu *asiu = clk->asiu;\n\tu32 val;\n\tunsigned int div_h, div_l;\n\n\tif (parent_rate == 0) {\n\t\tclk->rate = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tval = readl(asiu->div_base + clk->div.offset);\n\tif ((val & (1 << clk->div.en_shift)) == 0) {\n\t\tclk->rate = parent_rate;\n\t\treturn parent_rate;\n\t}\n\n\t \n\tdiv_h = (val >> clk->div.high_shift) & bit_mask(clk->div.high_width);\n\tdiv_h++;\n\tdiv_l = (val >> clk->div.low_shift) & bit_mask(clk->div.low_width);\n\tdiv_l++;\n\n\tclk->rate = parent_rate / (div_h + div_l);\n\tpr_debug(\"%s: rate: %lu. parent rate: %lu div_h: %u div_l: %u\\n\",\n\t\t __func__, clk->rate, parent_rate, div_h, div_l);\n\n\treturn clk->rate;\n}\n\nstatic long iproc_asiu_clk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long *parent_rate)\n{\n\tunsigned int div;\n\n\tif (rate == 0 || *parent_rate == 0)\n\t\treturn -EINVAL;\n\n\tif (rate == *parent_rate)\n\t\treturn *parent_rate;\n\n\tdiv = DIV_ROUND_CLOSEST(*parent_rate, rate);\n\tif (div < 2)\n\t\treturn *parent_rate;\n\n\treturn *parent_rate / div;\n}\n\nstatic int iproc_asiu_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct iproc_asiu_clk *clk = to_asiu_clk(hw);\n\tstruct iproc_asiu *asiu = clk->asiu;\n\tunsigned int div, div_h, div_l;\n\tu32 val;\n\n\tif (rate == 0 || parent_rate == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (rate == parent_rate) {\n\t\tval = readl(asiu->div_base + clk->div.offset);\n\t\tval &= ~(1 << clk->div.en_shift);\n\t\twritel(val, asiu->div_base + clk->div.offset);\n\t\treturn 0;\n\t}\n\n\tdiv = DIV_ROUND_CLOSEST(parent_rate, rate);\n\tif (div < 2)\n\t\treturn -EINVAL;\n\n\tdiv_h = div_l = div >> 1;\n\tdiv_h--;\n\tdiv_l--;\n\n\tval = readl(asiu->div_base + clk->div.offset);\n\tval |= 1 << clk->div.en_shift;\n\tif (div_h) {\n\t\tval &= ~(bit_mask(clk->div.high_width)\n\t\t\t << clk->div.high_shift);\n\t\tval |= div_h << clk->div.high_shift;\n\t} else {\n\t\tval &= ~(bit_mask(clk->div.high_width)\n\t\t\t << clk->div.high_shift);\n\t}\n\tif (div_l) {\n\t\tval &= ~(bit_mask(clk->div.low_width) << clk->div.low_shift);\n\t\tval |= div_l << clk->div.low_shift;\n\t} else {\n\t\tval &= ~(bit_mask(clk->div.low_width) << clk->div.low_shift);\n\t}\n\twritel(val, asiu->div_base + clk->div.offset);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops iproc_asiu_ops = {\n\t.enable = iproc_asiu_clk_enable,\n\t.disable = iproc_asiu_clk_disable,\n\t.recalc_rate = iproc_asiu_clk_recalc_rate,\n\t.round_rate = iproc_asiu_clk_round_rate,\n\t.set_rate = iproc_asiu_clk_set_rate,\n};\n\nvoid __init iproc_asiu_setup(struct device_node *node,\n\t\t\t     const struct iproc_asiu_div *div,\n\t\t\t     const struct iproc_asiu_gate *gate,\n\t\t\t     unsigned int num_clks)\n{\n\tint i, ret;\n\tstruct iproc_asiu *asiu;\n\n\tif (WARN_ON(!gate || !div))\n\t\treturn;\n\n\tasiu = kzalloc(sizeof(*asiu), GFP_KERNEL);\n\tif (WARN_ON(!asiu))\n\t\treturn;\n\n\tasiu->clk_data = kzalloc(struct_size(asiu->clk_data, hws, num_clks),\n\t\t\t\t GFP_KERNEL);\n\tif (WARN_ON(!asiu->clk_data))\n\t\tgoto err_clks;\n\tasiu->clk_data->num = num_clks;\n\n\tasiu->clks = kcalloc(num_clks, sizeof(*asiu->clks), GFP_KERNEL);\n\tif (WARN_ON(!asiu->clks))\n\t\tgoto err_asiu_clks;\n\n\tasiu->div_base = of_iomap(node, 0);\n\tif (WARN_ON(!asiu->div_base))\n\t\tgoto err_iomap_div;\n\n\tasiu->gate_base = of_iomap(node, 1);\n\tif (WARN_ON(!asiu->gate_base))\n\t\tgoto err_iomap_gate;\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tstruct clk_init_data init;\n\t\tconst char *parent_name;\n\t\tstruct iproc_asiu_clk *asiu_clk;\n\t\tconst char *clk_name;\n\n\t\tret = of_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t\t    i, &clk_name);\n\t\tif (WARN_ON(ret))\n\t\t\tgoto err_clk_register;\n\n\t\tasiu_clk = &asiu->clks[i];\n\t\tasiu_clk->name = clk_name;\n\t\tasiu_clk->asiu = asiu;\n\t\tasiu_clk->div = div[i];\n\t\tasiu_clk->gate = gate[i];\n\t\tinit.name = clk_name;\n\t\tinit.ops = &iproc_asiu_ops;\n\t\tinit.flags = 0;\n\t\tparent_name = of_clk_get_parent_name(node, 0);\n\t\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\t\tinit.num_parents = (parent_name ? 1 : 0);\n\t\tasiu_clk->hw.init = &init;\n\n\t\tret = clk_hw_register(NULL, &asiu_clk->hw);\n\t\tif (WARN_ON(ret))\n\t\t\tgoto err_clk_register;\n\t\tasiu->clk_data->hws[i] = &asiu_clk->hw;\n\t}\n\n\tret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get,\n\t\t\t\t     asiu->clk_data);\n\tif (WARN_ON(ret))\n\t\tgoto err_clk_register;\n\n\treturn;\n\nerr_clk_register:\n\twhile (--i >= 0)\n\t\tclk_hw_unregister(asiu->clk_data->hws[i]);\n\tiounmap(asiu->gate_base);\n\nerr_iomap_gate:\n\tiounmap(asiu->div_base);\n\nerr_iomap_div:\n\tkfree(asiu->clks);\n\nerr_asiu_clks:\n\tkfree(asiu->clk_data);\n\nerr_clks:\n\tkfree(asiu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}