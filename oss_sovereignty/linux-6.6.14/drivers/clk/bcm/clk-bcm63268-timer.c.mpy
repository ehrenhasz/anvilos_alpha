{
  "module_name": "clk-bcm63268-timer.c",
  "hash_id": "4116a720008e09a42df6d13bf8f45861c96a3a38b9beaf26f9d194cb64def270",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/bcm/clk-bcm63268-timer.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/container_of.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/spinlock.h>\n\n#include <dt-bindings/clock/bcm63268-clock.h>\n\n#define BCM63268_TIMER_RESET_SLEEP_MIN_US\t10000\n#define BCM63268_TIMER_RESET_SLEEP_MAX_US\t20000\n\nstruct bcm63268_tclkrst_hw {\n\tvoid __iomem *regs;\n\tspinlock_t lock;\n\n\tstruct reset_controller_dev rcdev;\n\tstruct clk_hw_onecell_data data;\n};\n\nstruct bcm63268_tclk_table_entry {\n\tconst char * const name;\n\tu8 bit;\n};\n\nstatic const struct bcm63268_tclk_table_entry bcm63268_timer_clocks[] = {\n\t{\n\t\t.name = \"ephy1\",\n\t\t.bit = BCM63268_TCLK_EPHY1,\n\t}, {\n\t\t.name = \"ephy2\",\n\t\t.bit = BCM63268_TCLK_EPHY2,\n\t}, {\n\t\t.name = \"ephy3\",\n\t\t.bit = BCM63268_TCLK_EPHY3,\n\t}, {\n\t\t.name = \"gphy1\",\n\t\t.bit = BCM63268_TCLK_GPHY1,\n\t}, {\n\t\t.name = \"dsl\",\n\t\t.bit = BCM63268_TCLK_DSL,\n\t}, {\n\t\t.name = \"wakeon_ephy\",\n\t\t.bit = BCM63268_TCLK_WAKEON_EPHY,\n\t}, {\n\t\t.name = \"wakeon_dsl\",\n\t\t.bit = BCM63268_TCLK_WAKEON_DSL,\n\t}, {\n\t\t.name = \"fap1_pll\",\n\t\t.bit = BCM63268_TCLK_FAP1,\n\t}, {\n\t\t.name = \"fap2_pll\",\n\t\t.bit = BCM63268_TCLK_FAP2,\n\t}, {\n\t\t.name = \"uto_50\",\n\t\t.bit = BCM63268_TCLK_UTO_50,\n\t}, {\n\t\t.name = \"uto_extin\",\n\t\t.bit = BCM63268_TCLK_UTO_EXTIN,\n\t}, {\n\t\t.name = \"usb_ref\",\n\t\t.bit = BCM63268_TCLK_USB_REF,\n\t}, {\n\t\t \n\t}\n};\n\nstatic inline struct bcm63268_tclkrst_hw *\nto_bcm63268_timer_reset(struct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct bcm63268_tclkrst_hw, rcdev);\n}\n\nstatic int bcm63268_timer_reset_update(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id, bool assert)\n{\n\tstruct bcm63268_tclkrst_hw *reset = to_bcm63268_timer_reset(rcdev);\n\tunsigned long flags;\n\tuint32_t val;\n\n\tspin_lock_irqsave(&reset->lock, flags);\n\tval = __raw_readl(reset->regs);\n\tif (assert)\n\t\tval &= ~BIT(id);\n\telse\n\t\tval |= BIT(id);\n\t__raw_writel(val, reset->regs);\n\tspin_unlock_irqrestore(&reset->lock, flags);\n\n\treturn 0;\n}\n\nstatic int bcm63268_timer_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\treturn bcm63268_timer_reset_update(rcdev, id, true);\n}\n\nstatic int bcm63268_timer_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t  unsigned long id)\n{\n\treturn bcm63268_timer_reset_update(rcdev, id, false);\n}\n\nstatic int bcm63268_timer_reset_reset(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\tbcm63268_timer_reset_update(rcdev, id, true);\n\tusleep_range(BCM63268_TIMER_RESET_SLEEP_MIN_US,\n\t\t     BCM63268_TIMER_RESET_SLEEP_MAX_US);\n\n\tbcm63268_timer_reset_update(rcdev, id, false);\n\t \n\tusleep_range(BCM63268_TIMER_RESET_SLEEP_MIN_US,\n\t\t     BCM63268_TIMER_RESET_SLEEP_MAX_US);\n\n\treturn 0;\n}\n\nstatic int bcm63268_timer_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\tstruct bcm63268_tclkrst_hw *reset = to_bcm63268_timer_reset(rcdev);\n\n\treturn !(__raw_readl(reset->regs) & BIT(id));\n}\n\nstatic const struct reset_control_ops bcm63268_timer_reset_ops = {\n\t.assert = bcm63268_timer_reset_assert,\n\t.deassert = bcm63268_timer_reset_deassert,\n\t.reset = bcm63268_timer_reset_reset,\n\t.status = bcm63268_timer_reset_status,\n};\n\nstatic int bcm63268_tclk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct bcm63268_tclk_table_entry *entry;\n\tstruct bcm63268_tclkrst_hw *hw;\n\tstruct clk_hw *clk;\n\tu8 maxbit = 0;\n\tint i, ret;\n\n\tfor (entry = bcm63268_timer_clocks; entry->name; entry++)\n\t\tmaxbit = max(maxbit, entry->bit);\n\tmaxbit++;\n\n\thw = devm_kzalloc(&pdev->dev, struct_size(hw, data.hws, maxbit),\n\t\t\t  GFP_KERNEL);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, hw);\n\n\tspin_lock_init(&hw->lock);\n\n\thw->data.num = maxbit;\n\tfor (i = 0; i < maxbit; i++)\n\t\thw->data.hws[i] = ERR_PTR(-ENODEV);\n\n\thw->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hw->regs))\n\t\treturn PTR_ERR(hw->regs);\n\n\tfor (entry = bcm63268_timer_clocks; entry->name; entry++) {\n\t\tclk = devm_clk_hw_register_gate(dev, entry->name, NULL, 0,\n\t\t\t\t\t\thw->regs, entry->bit,\n\t\t\t\t\t\tCLK_GATE_BIG_ENDIAN,\n\t\t\t\t\t\t&hw->lock);\n\t\tif (IS_ERR(clk))\n\t\t\treturn PTR_ERR(clk);\n\n\t\thw->data.hws[entry->bit] = clk;\n\t}\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get,\n\t\t\t\t\t  &hw->data);\n\tif (ret)\n\t\treturn ret;\n\n\thw->rcdev.of_node = dev->of_node;\n\thw->rcdev.ops = &bcm63268_timer_reset_ops;\n\n\tret = devm_reset_controller_register(dev, &hw->rcdev);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to register reset controller\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm63268_tclk_dt_ids[] = {\n\t{ .compatible = \"brcm,bcm63268-timer-clocks\" },\n\t{   }\n};\n\nstatic struct platform_driver bcm63268_tclk = {\n\t.probe = bcm63268_tclk_probe,\n\t.driver = {\n\t\t.name = \"bcm63268-timer-clock\",\n\t\t.of_match_table = bcm63268_tclk_dt_ids,\n\t},\n};\nbuiltin_platform_driver(bcm63268_tclk);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}