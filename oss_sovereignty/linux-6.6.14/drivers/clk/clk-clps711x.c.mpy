{
  "module_name": "clk-clps711x.c",
  "hash_id": "cf45df2622814d4d1a7d76cb4ddb9c149e7b78d00bf36f116443a4bed8fb7f17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-clps711x.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/mfd/syscon/clps711x.h>\n\n#include <dt-bindings/clock/clps711x-clock.h>\n\n#define CLPS711X_SYSCON1\t(0x0100)\n#define CLPS711X_SYSCON2\t(0x1100)\n#define CLPS711X_SYSFLG2\t(CLPS711X_SYSCON2 + SYSFLG_OFFSET)\n#define CLPS711X_PLLR\t\t(0xa5a8)\n\n#define CLPS711X_EXT_FREQ\t(13000000)\n#define CLPS711X_OSC_FREQ\t(3686400)\n\nstatic const struct clk_div_table spi_div_table[] = {\n\t{ .val = 0, .div = 32, },\n\t{ .val = 1, .div = 8, },\n\t{ .val = 2, .div = 2, },\n\t{ .val = 3, .div = 1, },\n\t{   }\n};\n\nstatic const struct clk_div_table timer_div_table[] = {\n\t{ .val = 0, .div = 256, },\n\t{ .val = 1, .div = 1, },\n\t{   }\n};\n\nstruct clps711x_clk {\n\tspinlock_t\t\t\tlock;\n\tstruct clk_hw_onecell_data\tclk_data;\n};\n\nstatic void __init clps711x_clk_init_dt(struct device_node *np)\n{\n\tu32 tmp, f_cpu, f_pll, f_bus, f_tim, f_pwm, f_spi, fref = 0;\n\tstruct clps711x_clk *clps711x_clk;\n\tvoid __iomem *base;\n\n\tWARN_ON(of_property_read_u32(np, \"startup-frequency\", &fref));\n\n\tbase = of_iomap(np, 0);\n\tBUG_ON(!base);\n\n\tclps711x_clk = kzalloc(struct_size(clps711x_clk, clk_data.hws,\n\t\t\t\t\t   CLPS711X_CLK_MAX),\n\t\t\t       GFP_KERNEL);\n\tBUG_ON(!clps711x_clk);\n\n\tspin_lock_init(&clps711x_clk->lock);\n\n\t \n\ttmp = readl(base + CLPS711X_PLLR) >> 24;\n\tif (((tmp >= 10) && (tmp <= 50)) || !fref)\n\t\tf_pll = DIV_ROUND_UP(CLPS711X_OSC_FREQ * tmp, 2);\n\telse\n\t\tf_pll = fref;\n\n\ttmp = readl(base + CLPS711X_SYSFLG2);\n\tif (tmp & SYSFLG2_CKMODE) {\n\t\tf_cpu = CLPS711X_EXT_FREQ;\n\t\tf_bus = CLPS711X_EXT_FREQ;\n\t\tf_spi = DIV_ROUND_CLOSEST(CLPS711X_EXT_FREQ, 96);\n\t\tf_pll = 0;\n\t\tf_pwm = DIV_ROUND_CLOSEST(CLPS711X_EXT_FREQ, 128);\n\t} else {\n\t\tf_cpu = f_pll;\n\t\tif (f_cpu > 36864000)\n\t\t\tf_bus = DIV_ROUND_UP(f_cpu, 2);\n\t\telse\n\t\t\tf_bus = 36864000 / 2;\n\t\tf_spi = DIV_ROUND_CLOSEST(f_cpu, 576);\n\t\tf_pwm = DIV_ROUND_CLOSEST(f_cpu, 768);\n\t}\n\n\tif (tmp & SYSFLG2_CKMODE) {\n\t\tif (readl(base + CLPS711X_SYSCON2) & SYSCON2_OSTB)\n\t\t\tf_tim = DIV_ROUND_CLOSEST(CLPS711X_EXT_FREQ, 26);\n\t\telse\n\t\t\tf_tim = DIV_ROUND_CLOSEST(CLPS711X_EXT_FREQ, 24);\n\t} else\n\t\tf_tim = DIV_ROUND_CLOSEST(f_cpu, 144);\n\n\ttmp = readl(base + CLPS711X_SYSCON1);\n\t \n\ttmp &= ~(SYSCON1_TC1M | SYSCON1_TC1S);\n\t \n\ttmp |= SYSCON1_TC2M | SYSCON1_TC2S;\n\twritel(tmp, base + CLPS711X_SYSCON1);\n\n\tclps711x_clk->clk_data.hws[CLPS711X_CLK_DUMMY] =\n\t\tclk_hw_register_fixed_rate(NULL, \"dummy\", NULL, 0, 0);\n\tclps711x_clk->clk_data.hws[CLPS711X_CLK_CPU] =\n\t\tclk_hw_register_fixed_rate(NULL, \"cpu\", NULL, 0, f_cpu);\n\tclps711x_clk->clk_data.hws[CLPS711X_CLK_BUS] =\n\t\tclk_hw_register_fixed_rate(NULL, \"bus\", NULL, 0, f_bus);\n\tclps711x_clk->clk_data.hws[CLPS711X_CLK_PLL] =\n\t\tclk_hw_register_fixed_rate(NULL, \"pll\", NULL, 0, f_pll);\n\tclps711x_clk->clk_data.hws[CLPS711X_CLK_TIMERREF] =\n\t\tclk_hw_register_fixed_rate(NULL, \"timer_ref\", NULL, 0, f_tim);\n\tclps711x_clk->clk_data.hws[CLPS711X_CLK_TIMER1] =\n\t\tclk_hw_register_divider_table(NULL, \"timer1\", \"timer_ref\", 0,\n\t\t\t\t\t   base + CLPS711X_SYSCON1, 5, 1, 0,\n\t\t\t\t\t   timer_div_table, &clps711x_clk->lock);\n\tclps711x_clk->clk_data.hws[CLPS711X_CLK_TIMER2] =\n\t\tclk_hw_register_divider_table(NULL, \"timer2\", \"timer_ref\", 0,\n\t\t\t\t\t   base + CLPS711X_SYSCON1, 7, 1, 0,\n\t\t\t\t\t   timer_div_table, &clps711x_clk->lock);\n\tclps711x_clk->clk_data.hws[CLPS711X_CLK_PWM] =\n\t\tclk_hw_register_fixed_rate(NULL, \"pwm\", NULL, 0, f_pwm);\n\tclps711x_clk->clk_data.hws[CLPS711X_CLK_SPIREF] =\n\t\tclk_hw_register_fixed_rate(NULL, \"spi_ref\", NULL, 0, f_spi);\n\tclps711x_clk->clk_data.hws[CLPS711X_CLK_SPI] =\n\t\tclk_hw_register_divider_table(NULL, \"spi\", \"spi_ref\", 0,\n\t\t\t\t\t   base + CLPS711X_SYSCON1, 16, 2, 0,\n\t\t\t\t\t   spi_div_table, &clps711x_clk->lock);\n\tclps711x_clk->clk_data.hws[CLPS711X_CLK_UART] =\n\t\tclk_hw_register_fixed_factor(NULL, \"uart\", \"bus\", 0, 1, 10);\n\tclps711x_clk->clk_data.hws[CLPS711X_CLK_TICK] =\n\t\tclk_hw_register_fixed_rate(NULL, \"tick\", NULL, 0, 64);\n\tfor (tmp = 0; tmp < CLPS711X_CLK_MAX; tmp++)\n\t\tif (IS_ERR(clps711x_clk->clk_data.hws[tmp]))\n\t\t\tpr_err(\"clk %i: register failed with %ld\\n\",\n\t\t\t       tmp, PTR_ERR(clps711x_clk->clk_data.hws[tmp]));\n\n\tclps711x_clk->clk_data.num = CLPS711X_CLK_MAX;\n\tof_clk_add_hw_provider(np, of_clk_hw_onecell_get,\n\t\t\t       &clps711x_clk->clk_data);\n}\nCLK_OF_DECLARE(clps711x, \"cirrus,ep7209-clk\", clps711x_clk_init_dt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}