{
  "module_name": "clk-sp7021.c",
  "hash_id": "9791b65336ff69ffe2f458553ea1d55718007911ad34e05a39bf92a88e937663",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-sp7021.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/clk-provider.h>\n#include <linux/of.h>\n#include <linux/bitfield.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n\n#include <dt-bindings/clock/sunplus,sp7021-clkc.h>\n\n \n#define DIV_TV\t\t33\n#define DIV_A\t\t34\n\n \nenum {\n\tSEL_FRA,\n\tSDM_MOD,\n\tPH_SEL,\n\tNFRA,\n\tDIVR,\n\tDIVN,\n\tDIVM,\n\tP_MAX\n};\n\n#define MASK_SEL_FRA\tGENMASK(1, 1)\n#define MASK_SDM_MOD\tGENMASK(2, 2)\n#define MASK_PH_SEL\tGENMASK(4, 4)\n#define MASK_NFRA\tGENMASK(12, 6)\n#define MASK_DIVR\tGENMASK(8, 7)\n#define MASK_DIVN\tGENMASK(7, 0)\n#define MASK_DIVM\tGENMASK(14, 8)\n\n \n#define HWM_FIELD_PREP(mask, value)\t\t\\\n({\t\t\t\t\t\t\\\n\tu64 _m = mask;\t\t\t\t\\\n\t(_m << 16) | FIELD_PREP(_m, value);\t\\\n})\n\nstruct sp_pll {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n\tspinlock_t lock;\t \n\tint div_shift;\n\tint div_width;\n\tint pd_bit;\t\t \n\tint bp_bit;\t\t \n\tunsigned long brate;\t \n\tu32 p[P_MAX];\t\t \n};\n\n#define to_sp_pll(_hw)\tcontainer_of(_hw, struct sp_pll, hw)\n\nstruct sp_clk_gate_info {\n\tu16\treg;\t\t \n\tu16\text_parent;\t \n};\n\nstatic const struct sp_clk_gate_info sp_clk_gates[] = {\n\t{ 0x02 },\n\t{ 0x05 },\n\t{ 0x06 },\n\t{ 0x07 },\n\t{ 0x09 },\n\t{ 0x0b, 1 },\n\t{ 0x0f, 1 },\n\t{ 0x14 },\n\t{ 0x15 },\n\t{ 0x16 },\n\t{ 0x17 },\n\t{ 0x18, 1 },\n\t{ 0x19, 1 },\n\t{ 0x1a, 1 },\n\t{ 0x1b, 1 },\n\t{ 0x1c, 1 },\n\t{ 0x1d, 1 },\n\t{ 0x1e },\n\t{ 0x1f, 1 },\n\t{ 0x20 },\n\t{ 0x21 },\n\t{ 0x22 },\n\t{ 0x23 },\n\t{ 0x24 },\n\t{ 0x25 },\n\t{ 0x26 },\n\t{ 0x2a },\n\t{ 0x2b },\n\t{ 0x2d },\n\t{ 0x2e },\n\t{ 0x30 },\n\t{ 0x31 },\n\t{ 0x32 },\n\t{ 0x33 },\n\t{ 0x3d },\n\t{ 0x3e },\n\t{ 0x3f },\n\t{ 0x42 },\n\t{ 0x44 },\n\t{ 0x4b },\n\t{ 0x4c },\n\t{ 0x4d },\n\t{ 0x4e },\n\t{ 0x4f },\n\t{ 0x50 },\n\t{ 0x55 },\n\t{ 0x60 },\n\t{ 0x61 },\n\t{ 0x6a },\n\t{ 0x73 },\n\t{ 0x86 },\n\t{ 0x8a },\n\t{ 0x8b },\n\t{ 0x8d },\n\t{ 0x8e },\n\t{ 0x8f },\n\t{ 0x90 },\n\t{ 0x92 },\n\t{ 0x93 },\n\t{ 0x95 },\n\t{ 0x96 },\n\t{ 0x97 },\n\t{ 0x98 },\n\t{ 0x99 },\n};\n\n#define _M\t\t1000000UL\n#define F_27M\t\t(27 * _M)\n\n \n\n \n#define FVCO_MIN\t(100 * _M)\n#define FVCO_MAX\t(200 * _M)\n\n#define F_MIN\t\t(FVCO_MIN / 8)\n#define F_MAX\t\t(FVCO_MAX)\n\nstatic long plltv_integer_div(struct sp_pll *clk, unsigned long freq)\n{\n\t \n\tstatic const u32 m_table[] = {\n\t\t1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32\n\t};\n\tu32 m, n, r;\n\tunsigned long fvco, nf;\n\tlong ret;\n\n\tfreq = clamp(freq, F_MIN, F_MAX);\n\n\t \n\tfor (r = 0; r <= 3; r++) {\n\t\tfvco = freq << r;\n\t\tif (fvco <= FVCO_MAX)\n\t\t\tbreak;\n\t}\n\n\t \n\tfor (m = 0; m < ARRAY_SIZE(m_table); m++) {\n\t\tnf = fvco * m_table[m];\n\t\tn = nf / F_27M;\n\t\tif ((n * F_27M) == nf)\n\t\t\tbreak;\n\t}\n\tif (m >= ARRAY_SIZE(m_table)) {\n\t\tret = -EINVAL;\n\t\tgoto err_not_found;\n\t}\n\n\t \n\tclk->p[SEL_FRA] = 0;\n\tclk->p[DIVR]    = r;\n\tclk->p[DIVN]    = n;\n\tclk->p[DIVM]    = m_table[m];\n\n\treturn freq;\n\nerr_not_found:\n\tpr_err(\"%s: %s freq:%lu not found a valid setting\\n\",\n\t       __func__, clk_hw_get_name(&clk->hw), freq);\n\n\treturn ret;\n}\n\n \nstatic const u32 pt[][5] = {\n\t \n\t{\n\t\t1,\t\t\t \n\t\t5,\t\t\t \n\t\t1,\t\t\t \n\t\tF_27M,\t\t\t \n\t\t1,\t\t\t \n\t},\n\t \n\t{\n\t\t10,\t\t\t \n\t\t54,\t\t\t \n\t\t2,\t\t\t \n\t\tF_27M / 10,\t\t \n\t\t5,\t\t\t \n\t},\n};\n\nstatic const u32 sdm_mod_vals[] = { 91, 55 };\n\nstatic long plltv_fractional_div(struct sp_pll *clk, unsigned long freq)\n{\n\tu32 m, r;\n\tu32 nint, nfra;\n\tu32 df_quotient_min = 210000000;\n\tu32 df_remainder_min = 0;\n\tunsigned long fvco, nf, f, fout = 0;\n\tint sdm, ph;\n\n\tfreq = clamp(freq, F_MIN, F_MAX);\n\n\t \n\tfor (r = 0; r <= 3; r++) {\n\t\tfvco = freq << r;\n\t\tif (fvco <= FVCO_MAX)\n\t\t\tbreak;\n\t}\n\tf = F_27M >> r;\n\n\t \n\tfor (ph = ARRAY_SIZE(pt) - 1; ph >= 0; ph--) {\n\t\tconst u32 *pp = pt[ph];\n\n\t\t \n\t\tfor (sdm = 0; sdm < ARRAY_SIZE(sdm_mod_vals); sdm++) {\n\t\t\tu32 mod = sdm_mod_vals[sdm];\n\n\t\t\t \n\t\t\tfor (m = 1; m <= 32; m++) {\n\t\t\t\tu32 df;  \n\t\t\t\tu32 df_quotient, df_remainder;\n\n\t\t\t\tnf = fvco * m;\n\t\t\t\tnint = nf / pp[3];\n\n\t\t\t\tif (nint < pp[1])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (nint > pp[1])\n\t\t\t\t\tbreak;\n\n\t\t\t\tnfra = (((nf % pp[3]) * mod * pp[4]) + (F_27M / 2)) / F_27M;\n\t\t\t\tif (nfra) {\n\t\t\t\t\tu32 df0 = f * (nint + pp[2]) / pp[0];\n\t\t\t\t\tu32 df1 = f * (mod - nfra) / mod / pp[4];\n\n\t\t\t\t\tdf = df0 - df1;\n\t\t\t\t} else {\n\t\t\t\t\tdf = f * (nint) / pp[0];\n\t\t\t\t}\n\n\t\t\t\tdf_quotient  = df / m;\n\t\t\t\tdf_remainder = ((df % m) * 1000) / m;\n\n\t\t\t\tif (freq > df_quotient) {\n\t\t\t\t\tdf_quotient  = freq - df_quotient - 1;\n\t\t\t\t\tdf_remainder = 1000 - df_remainder;\n\t\t\t\t} else {\n\t\t\t\t\tdf_quotient = df_quotient - freq;\n\t\t\t\t}\n\n\t\t\t\tif (df_quotient_min > df_quotient ||\n\t\t\t\t    (df_quotient_min == df_quotient &&\n\t\t\t\t    df_remainder_min > df_remainder)) {\n\t\t\t\t\t \n\t\t\t\t\tclk->p[SEL_FRA] = 1;\n\t\t\t\t\tclk->p[SDM_MOD] = sdm;\n\t\t\t\t\tclk->p[PH_SEL]  = ph;\n\t\t\t\t\tclk->p[NFRA]    = nfra;\n\t\t\t\t\tclk->p[DIVR]    = r;\n\t\t\t\t\tclk->p[DIVM]    = m;\n\n\t\t\t\t\tfout = df / m;\n\t\t\t\t\tdf_quotient_min = df_quotient;\n\t\t\t\t\tdf_remainder_min = df_remainder;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!fout) {\n\t\tpr_err(\"%s: %s freq:%lu not found a valid setting\\n\",\n\t\t       __func__, clk_hw_get_name(&clk->hw), freq);\n\t\treturn -EINVAL;\n\t}\n\n\treturn fout;\n}\n\nstatic long plltv_div(struct sp_pll *clk, unsigned long freq)\n{\n\tif (freq % 100)\n\t\treturn plltv_fractional_div(clk, freq);\n\n\treturn plltv_integer_div(clk, freq);\n}\n\nstatic int plltv_set_rate(struct sp_pll *clk)\n{\n\tunsigned long flags;\n\tu32 r0, r1, r2;\n\n\tr0  = BIT(clk->bp_bit + 16);\n\tr0 |= HWM_FIELD_PREP(MASK_SEL_FRA, clk->p[SEL_FRA]);\n\tr0 |= HWM_FIELD_PREP(MASK_SDM_MOD, clk->p[SDM_MOD]);\n\tr0 |= HWM_FIELD_PREP(MASK_PH_SEL, clk->p[PH_SEL]);\n\tr0 |= HWM_FIELD_PREP(MASK_NFRA, clk->p[NFRA]);\n\n\tr1  = HWM_FIELD_PREP(MASK_DIVR, clk->p[DIVR]);\n\n\tr2  = HWM_FIELD_PREP(MASK_DIVN, clk->p[DIVN] - 1);\n\tr2 |= HWM_FIELD_PREP(MASK_DIVM, clk->p[DIVM] - 1);\n\n\tspin_lock_irqsave(&clk->lock, flags);\n\twritel(r0, clk->reg);\n\twritel(r1, clk->reg + 4);\n\twritel(r2, clk->reg + 8);\n\tspin_unlock_irqrestore(&clk->lock, flags);\n\n\treturn 0;\n}\n\n \n\n \nstatic const struct {\n\tu32 rate;\n\tu32 regs[5];\n} pa[] = {\n\t{\n\t\t.rate = 135475200,\n\t\t.regs = {\n\t\t\t0x4801,\n\t\t\t0x02df,\n\t\t\t0x248f,\n\t\t\t0x0211,\n\t\t\t0x33e9\n\t\t}\n\t},\n\t{\n\t\t.rate = 147456000,\n\t\t.regs = {\n\t\t\t0x4801,\n\t\t\t0x1adf,\n\t\t\t0x2490,\n\t\t\t0x0349,\n\t\t\t0x33e9\n\t\t}\n\t},\n\t{\n\t\t.rate = 196608000,\n\t\t.regs = {\n\t\t\t0x4801,\n\t\t\t0x42ef,\n\t\t\t0x2495,\n\t\t\t0x01c6,\n\t\t\t0x33e9\n\t\t}\n\t},\n};\n\nstatic int plla_set_rate(struct sp_pll *clk)\n{\n\tconst u32 *pp = pa[clk->p[0]].regs;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&clk->lock, flags);\n\tfor (i = 0; i < ARRAY_SIZE(pa->regs); i++)\n\t\twritel(0xffff0000 | pp[i], clk->reg + (i * 4));\n\tspin_unlock_irqrestore(&clk->lock, flags);\n\n\treturn 0;\n}\n\nstatic long plla_round_rate(struct sp_pll *clk, unsigned long rate)\n{\n\tint i = ARRAY_SIZE(pa);\n\n\twhile (--i) {\n\t\tif (rate >= pa[i].rate)\n\t\t\tbreak;\n\t}\n\tclk->p[0] = i;\n\n\treturn pa[i].rate;\n}\n\n \n\nstatic long sp_pll_calc_div(struct sp_pll *clk, unsigned long rate)\n{\n\tu32 fbdiv;\n\tu32 max = 1 << clk->div_width;\n\n\tfbdiv = DIV_ROUND_CLOSEST(rate, clk->brate);\n\tif (fbdiv > max)\n\t\tfbdiv = max;\n\n\treturn fbdiv;\n}\n\nstatic long sp_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long *prate)\n{\n\tstruct sp_pll *clk = to_sp_pll(hw);\n\tlong ret;\n\n\tif (rate == *prate) {\n\t\tret = *prate;  \n\t} else if (clk->div_width == DIV_A) {\n\t\tret = plla_round_rate(clk, rate);\n\t} else if (clk->div_width == DIV_TV) {\n\t\tret = plltv_div(clk, rate);\n\t\tif (ret < 0)\n\t\t\tret = *prate;\n\t} else {\n\t\tret = sp_pll_calc_div(clk, rate) * clk->brate;\n\t}\n\n\treturn ret;\n}\n\nstatic unsigned long sp_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long prate)\n{\n\tstruct sp_pll *clk = to_sp_pll(hw);\n\tu32 reg = readl(clk->reg);\n\tunsigned long ret;\n\n\tif (reg & BIT(clk->bp_bit)) {\n\t\tret = prate;  \n\t} else if (clk->div_width == DIV_A) {\n\t\tret = pa[clk->p[0]].rate;\n\t} else if (clk->div_width == DIV_TV) {\n\t\tu32 m, r, reg2;\n\n\t\tr = FIELD_GET(MASK_DIVR, readl(clk->reg + 4));\n\t\treg2 = readl(clk->reg + 8);\n\t\tm = FIELD_GET(MASK_DIVM, reg2) + 1;\n\n\t\tif (reg & MASK_SEL_FRA) {\n\t\t\t \n\t\t\tu32 sdm  = FIELD_GET(MASK_SDM_MOD, reg);\n\t\t\tu32 ph   = FIELD_GET(MASK_PH_SEL, reg);\n\t\t\tu32 nfra = FIELD_GET(MASK_NFRA, reg);\n\t\t\tconst u32 *pp = pt[ph];\n\t\t\tunsigned long r0, r1;\n\n\t\t\tret = prate >> r;\n\t\t\tr0  = ret * (pp[1] + pp[2]) / pp[0];\n\t\t\tr1  = ret * (sdm_mod_vals[sdm] - nfra) / sdm_mod_vals[sdm] / pp[4];\n\t\t\tret = (r0 - r1) / m;\n\t\t} else {\n\t\t\t \n\t\t\tu32 n = FIELD_GET(MASK_DIVN, reg2) + 1;\n\n\t\t\tret = (prate / m * n) >> r;\n\t\t}\n\t} else {\n\t\tu32 fbdiv = ((reg >> clk->div_shift) & ((1 << clk->div_width) - 1)) + 1;\n\n\t\tret = clk->brate * fbdiv;\n\t}\n\n\treturn ret;\n}\n\nstatic int sp_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t   unsigned long prate)\n{\n\tstruct sp_pll *clk = to_sp_pll(hw);\n\tunsigned long flags;\n\tu32 reg;\n\n\treg = BIT(clk->bp_bit + 16);  \n\n\tif (rate == prate) {\n\t\treg |= BIT(clk->bp_bit);  \n\t} else if (clk->div_width == DIV_A) {\n\t\treturn plla_set_rate(clk);\n\t} else if (clk->div_width == DIV_TV) {\n\t\treturn plltv_set_rate(clk);\n\t} else if (clk->div_width) {\n\t\tu32 fbdiv = sp_pll_calc_div(clk, rate);\n\t\tu32 mask = GENMASK(clk->div_shift + clk->div_width - 1, clk->div_shift);\n\n\t\treg |= mask << 16;\n\t\treg |= ((fbdiv - 1) << clk->div_shift) & mask;\n\t}\n\n\tspin_lock_irqsave(&clk->lock, flags);\n\twritel(reg, clk->reg);\n\tspin_unlock_irqrestore(&clk->lock, flags);\n\n\treturn 0;\n}\n\nstatic int sp_pll_enable(struct clk_hw *hw)\n{\n\tstruct sp_pll *clk = to_sp_pll(hw);\n\n\twritel(BIT(clk->pd_bit + 16) | BIT(clk->pd_bit), clk->reg);\n\n\treturn 0;\n}\n\nstatic void sp_pll_disable(struct clk_hw *hw)\n{\n\tstruct sp_pll *clk = to_sp_pll(hw);\n\n\twritel(BIT(clk->pd_bit + 16), clk->reg);\n}\n\nstatic int sp_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct sp_pll *clk = to_sp_pll(hw);\n\n\treturn readl(clk->reg) & BIT(clk->pd_bit);\n}\n\nstatic const struct clk_ops sp_pll_ops = {\n\t.enable = sp_pll_enable,\n\t.disable = sp_pll_disable,\n\t.is_enabled = sp_pll_is_enabled,\n\t.round_rate = sp_pll_round_rate,\n\t.recalc_rate = sp_pll_recalc_rate,\n\t.set_rate = sp_pll_set_rate\n};\n\nstatic const struct clk_ops sp_pll_sub_ops = {\n\t.enable = sp_pll_enable,\n\t.disable = sp_pll_disable,\n\t.is_enabled = sp_pll_is_enabled,\n\t.recalc_rate = sp_pll_recalc_rate,\n};\n\nstatic struct clk_hw *sp_pll_register(struct device *dev, const char *name,\n\t\t\t\t      const struct clk_parent_data *parent_data,\n\t\t\t\t      void __iomem *reg, int pd_bit, int bp_bit,\n\t\t\t\t      unsigned long brate, int shift, int width,\n\t\t\t\t      unsigned long flags)\n{\n\tstruct sp_pll *pll;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data initd = {\n\t\t.name = name,\n\t\t.parent_data = parent_data,\n\t\t.ops = (bp_bit >= 0) ? &sp_pll_ops : &sp_pll_sub_ops,\n\t\t.num_parents = 1,\n\t\t.flags = flags,\n\t};\n\tint ret;\n\n\tpll = devm_kzalloc(dev, sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpll->hw.init = &initd;\n\tpll->reg = reg;\n\tpll->pd_bit = pd_bit;\n\tpll->bp_bit = bp_bit;\n\tpll->brate = brate;\n\tpll->div_shift = shift;\n\tpll->div_width = width;\n\tspin_lock_init(&pll->lock);\n\n\thw = &pll->hw;\n\tret = devm_clk_hw_register(dev, hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn hw;\n}\n\n#define PLLA_CTL\t(pll_base + 0x1c)\n#define PLLE_CTL\t(pll_base + 0x30)\n#define PLLF_CTL\t(pll_base + 0x34)\n#define PLLTV_CTL\t(pll_base + 0x38)\n\nstatic int sp7021_clk_probe(struct platform_device *pdev)\n{\n\tstatic const u32 sp_clken[] = {\n\t\t0x67ef, 0x03ff, 0xff03, 0xfff0, 0x0004,  \n\t\t0x0000, 0x8000, 0xffff, 0x0040, 0x0000,  \n\t};\n\tstatic struct clk_parent_data pd_ext, pd_sys, pd_e;\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *clk_base, *pll_base, *sys_base;\n\tstruct clk_hw_onecell_data *clk_data;\n\tstruct clk_hw **hws;\n\tint i;\n\n\tclk_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(clk_base))\n\t\treturn PTR_ERR(clk_base);\n\tpll_base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(pll_base))\n\t\treturn PTR_ERR(pll_base);\n\tsys_base = devm_platform_ioremap_resource(pdev, 2);\n\tif (IS_ERR(sys_base))\n\t\treturn PTR_ERR(sys_base);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(sp_clken); i++)\n\t\twritel((sp_clken[i] << 16) | sp_clken[i], clk_base + i * 4);\n\n\tclk_data = devm_kzalloc(dev, struct_size(clk_data, hws, CLK_MAX),\n\t\t\t\tGFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\tclk_data->num = CLK_MAX;\n\n\thws = clk_data->hws;\n\tpd_ext.index = 0;\n\n\t \n\thws[PLL_A] = sp_pll_register(dev, \"plla\", &pd_ext, PLLA_CTL,\n\t\t\t\t     11, 12, 27000000, 0, DIV_A, 0);\n\tif (IS_ERR(hws[PLL_A]))\n\t\treturn PTR_ERR(hws[PLL_A]);\n\n\thws[PLL_E] = sp_pll_register(dev, \"plle\", &pd_ext, PLLE_CTL,\n\t\t\t\t     6, 2, 50000000, 0, 0, 0);\n\tif (IS_ERR(hws[PLL_E]))\n\t\treturn PTR_ERR(hws[PLL_E]);\n\tpd_e.hw = hws[PLL_E];\n\thws[PLL_E_2P5] = sp_pll_register(dev, \"plle_2p5\", &pd_e, PLLE_CTL,\n\t\t\t\t\t 13, -1, 2500000, 0, 0, 0);\n\tif (IS_ERR(hws[PLL_E_2P5]))\n\t\treturn PTR_ERR(hws[PLL_E_2P5]);\n\thws[PLL_E_25] = sp_pll_register(dev, \"plle_25\", &pd_e, PLLE_CTL,\n\t\t\t\t\t12, -1, 25000000, 0, 0, 0);\n\tif (IS_ERR(hws[PLL_E_25]))\n\t\treturn PTR_ERR(hws[PLL_E_25]);\n\thws[PLL_E_112P5] = sp_pll_register(dev, \"plle_112p5\", &pd_e, PLLE_CTL,\n\t\t\t\t\t   11, -1, 112500000, 0, 0, 0);\n\tif (IS_ERR(hws[PLL_E_112P5]))\n\t\treturn PTR_ERR(hws[PLL_E_112P5]);\n\n\thws[PLL_F] = sp_pll_register(dev, \"pllf\", &pd_ext, PLLF_CTL,\n\t\t\t\t     0, 10, 13500000, 1, 4, 0);\n\tif (IS_ERR(hws[PLL_F]))\n\t\treturn PTR_ERR(hws[PLL_F]);\n\n\thws[PLL_TV] = sp_pll_register(dev, \"plltv\", &pd_ext, PLLTV_CTL,\n\t\t\t\t      0, 15, 27000000, 0, DIV_TV, 0);\n\tif (IS_ERR(hws[PLL_TV]))\n\t\treturn PTR_ERR(hws[PLL_TV]);\n\thws[PLL_TV_A] = devm_clk_hw_register_divider(dev, \"plltv_a\", \"plltv\", 0,\n\t\t\t\t\t\t     PLLTV_CTL + 4, 5, 1,\n\t\t\t\t\t\t     CLK_DIVIDER_POWER_OF_TWO,\n\t\t\t\t\t\t     &to_sp_pll(hws[PLL_TV])->lock);\n\tif (IS_ERR(hws[PLL_TV_A]))\n\t\treturn PTR_ERR(hws[PLL_TV_A]);\n\n\t \n\thws[PLL_SYS] = sp_pll_register(dev, \"pllsys\", &pd_ext, sys_base,\n\t\t\t\t       10, 9, 13500000, 0, 4, CLK_IS_CRITICAL);\n\tif (IS_ERR(hws[PLL_SYS]))\n\t\treturn PTR_ERR(hws[PLL_SYS]);\n\tpd_sys.hw = hws[PLL_SYS];\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(sp_clk_gates); i++) {\n\t\tchar name[10];\n\t\tu32 j = sp_clk_gates[i].reg;\n\t\tstruct clk_parent_data *pd = sp_clk_gates[i].ext_parent ? &pd_ext : &pd_sys;\n\n\t\tsprintf(name, \"%02d_0x%02x\", i, j);\n\t\thws[i] = devm_clk_hw_register_gate_parent_data(dev, name, pd, 0,\n\t\t\t\t\t\t\t       clk_base + (j >> 4) * 4,\n\t\t\t\t\t\t\t       j & 0x0f,\n\t\t\t\t\t\t\t       CLK_GATE_HIWORD_MASK,\n\t\t\t\t\t\t\t       NULL);\n\t\tif (IS_ERR(hws[i]))\n\t\t\treturn PTR_ERR(hws[i]);\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);\n}\n\nstatic const struct of_device_id sp7021_clk_dt_ids[] = {\n\t{ .compatible = \"sunplus,sp7021-clkc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sp7021_clk_dt_ids);\n\nstatic struct platform_driver sp7021_clk_driver = {\n\t.probe  = sp7021_clk_probe,\n\t.driver = {\n\t\t.name = \"sp7021-clk\",\n\t\t.of_match_table = sp7021_clk_dt_ids,\n\t},\n};\nmodule_platform_driver(sp7021_clk_driver);\n\nMODULE_AUTHOR(\"Sunplus Technology\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Clock driver for Sunplus SP7021 SoC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}