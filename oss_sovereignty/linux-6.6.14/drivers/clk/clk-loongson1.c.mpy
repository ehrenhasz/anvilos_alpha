{
  "module_name": "clk-loongson1.c",
  "hash_id": "606ba275a0effff24b6398347a565af473f331221daaac55ec3d45db90bce43a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-loongson1.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk-provider.h>\n#include <linux/container_of.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/printk.h>\n\n#include <dt-bindings/clock/loongson,ls1x-clk.h>\n\n \n#define CLK_PLL_FREQ\t\t0x0\n#define CLK_PLL_DIV\t\t0x4\n\nstatic DEFINE_SPINLOCK(ls1x_clk_div_lock);\n\nstruct ls1x_clk_pll_data {\n\tu32 fixed;\n\tu8 shift;\n\tu8 int_shift;\n\tu8 int_width;\n\tu8 frac_shift;\n\tu8 frac_width;\n};\n\nstruct ls1x_clk_div_data {\n\tu8 shift;\n\tu8 width;\n\tunsigned long flags;\n\tconst struct clk_div_table *table;\n\tu8 bypass_shift;\n\tu8 bypass_inv;\n\tspinlock_t *lock;\t \n};\n\nstruct ls1x_clk {\n\tvoid __iomem *reg;\n\tunsigned int offset;\n\tstruct clk_hw hw;\n\tconst void *data;\n};\n\n#define to_ls1x_clk(_hw) container_of(_hw, struct ls1x_clk, hw)\n\nstatic inline unsigned long ls1x_pll_rate_part(unsigned int val,\n\t\t\t\t\t       unsigned int shift,\n\t\t\t\t\t       unsigned int width)\n{\n\treturn (val & GENMASK(shift + width, shift)) >> shift;\n}\n\nstatic unsigned long ls1x_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct ls1x_clk *ls1x_clk = to_ls1x_clk(hw);\n\tconst struct ls1x_clk_pll_data *d = ls1x_clk->data;\n\tu32 val, rate;\n\n\tval = readl(ls1x_clk->reg);\n\trate = d->fixed;\n\trate += ls1x_pll_rate_part(val, d->int_shift, d->int_width);\n\tif (d->frac_width)\n\t\trate += ls1x_pll_rate_part(val, d->frac_shift, d->frac_width);\n\trate *= parent_rate;\n\trate >>= d->shift;\n\n\treturn rate;\n}\n\nstatic const struct clk_ops ls1x_pll_clk_ops = {\n\t.recalc_rate = ls1x_pll_recalc_rate,\n};\n\nstatic unsigned long ls1x_divider_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct ls1x_clk *ls1x_clk = to_ls1x_clk(hw);\n\tconst struct ls1x_clk_div_data *d = ls1x_clk->data;\n\tunsigned int val;\n\n\tval = readl(ls1x_clk->reg) >> d->shift;\n\tval &= clk_div_mask(d->width);\n\n\treturn divider_recalc_rate(hw, parent_rate, val, d->table,\n\t\t\t\t   d->flags, d->width);\n}\n\nstatic long ls1x_divider_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *prate)\n{\n\tstruct ls1x_clk *ls1x_clk = to_ls1x_clk(hw);\n\tconst struct ls1x_clk_div_data *d = ls1x_clk->data;\n\n\treturn divider_round_rate(hw, rate, prate, d->table,\n\t\t\t\t  d->width, d->flags);\n}\n\nstatic int ls1x_divider_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long parent_rate)\n{\n\tstruct ls1x_clk *ls1x_clk = to_ls1x_clk(hw);\n\tconst struct ls1x_clk_div_data *d = ls1x_clk->data;\n\tint val, div_val;\n\tunsigned long flags = 0;\n\n\tdiv_val = divider_get_val(rate, parent_rate, d->table,\n\t\t\t\t  d->width, d->flags);\n\tif (div_val < 0)\n\t\treturn div_val;\n\n\tspin_lock_irqsave(d->lock, flags);\n\n\t \n\tval = readl(ls1x_clk->reg);\n\tif (d->bypass_inv)\n\t\tval &= ~BIT(d->bypass_shift);\n\telse\n\t\tval |= BIT(d->bypass_shift);\n\twritel(val, ls1x_clk->reg);\n\n\tval = readl(ls1x_clk->reg);\n\tval &= ~(clk_div_mask(d->width) << d->shift);\n\tval |= (u32)div_val << d->shift;\n\twritel(val, ls1x_clk->reg);\n\n\t \n\tval = readl(ls1x_clk->reg);\n\tif (d->bypass_inv)\n\t\tval |= BIT(d->bypass_shift);\n\telse\n\t\tval &= ~BIT(d->bypass_shift);\n\twritel(val, ls1x_clk->reg);\n\n\tspin_unlock_irqrestore(d->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops ls1x_clk_divider_ops = {\n\t.recalc_rate = ls1x_divider_recalc_rate,\n\t.round_rate = ls1x_divider_round_rate,\n\t.set_rate = ls1x_divider_set_rate,\n};\n\n#define LS1X_CLK_PLL(_name, _offset, _fixed, _shift,\t\t\t\\\n\t\t     f_shift, f_width, i_shift, i_width)\t\t\\\nstruct ls1x_clk _name = {\t\t\t\t\t\t\\\n\t.offset = (_offset),\t\t\t\t\t\t\\\n\t.data = &(const struct ls1x_clk_pll_data) {\t\t\t\\\n\t\t.fixed = (_fixed),\t\t\t\t\t\\\n\t\t.shift = (_shift),\t\t\t\t\t\\\n\t\t.int_shift = (i_shift),\t\t\t\t\t\\\n\t\t.int_width = (i_width),\t\t\t\t\t\\\n\t\t.frac_shift = (f_shift),\t\t\t\t\\\n\t\t.frac_width = (f_width),\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.hw.init = &(const struct clk_init_data) {\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\t\\\n\t\t.ops = &ls1x_pll_clk_ops,\t\t\t\t\\\n\t\t.parent_data = &(const struct clk_parent_data) {\t\\\n\t\t\t.fw_name = \"xtal\",\t\t\t\t\\\n\t\t\t.name = \"xtal\",\t\t\t\t\t\\\n\t\t\t.index = -1,\t\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.num_parents = 1,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\n#define LS1X_CLK_DIV(_name, _pname, _offset, _shift, _width,\t\t\\\n\t\t     _table, _bypass_shift, _bypass_inv, _flags)\t\\\nstruct ls1x_clk _name = {\t\t\t\t\t\t\\\n\t.offset = (_offset),\t\t\t\t\t\t\\\n\t.data = &(const struct ls1x_clk_div_data){\t\t\t\\\n\t\t.shift = (_shift),\t\t\t\t\t\\\n\t\t.width = (_width),\t\t\t\t\t\\\n\t\t.table = (_table),\t\t\t\t\t\\\n\t\t.flags = (_flags),\t\t\t\t\t\\\n\t\t.bypass_shift = (_bypass_shift),\t\t\t\\\n\t\t.bypass_inv = (_bypass_inv),\t\t\t\t\\\n\t\t.lock = &ls1x_clk_div_lock,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.hw.init = &(const struct clk_init_data) {\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\t\\\n\t\t.ops = &ls1x_clk_divider_ops,\t\t\t\t\\\n\t\t.parent_hws = (const struct clk_hw *[]) { _pname },\t\\\n\t\t.num_parents = 1,\t\t\t\t\t\\\n\t\t.flags = CLK_GET_RATE_NOCACHE,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nstatic LS1X_CLK_PLL(ls1b_clk_pll, CLK_PLL_FREQ, 12, 1, 0, 5, 0, 0);\nstatic LS1X_CLK_DIV(ls1b_clk_cpu, &ls1b_clk_pll.hw, CLK_PLL_DIV,\n\t\t    20, 4, NULL, 8, 0,\n\t\t    CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ROUND_CLOSEST);\nstatic LS1X_CLK_DIV(ls1b_clk_dc, &ls1b_clk_pll.hw, CLK_PLL_DIV,\n\t\t    26, 4, NULL, 12, 0, CLK_DIVIDER_ONE_BASED);\nstatic LS1X_CLK_DIV(ls1b_clk_ahb, &ls1b_clk_pll.hw, CLK_PLL_DIV,\n\t\t    14, 4, NULL, 10, 0, CLK_DIVIDER_ONE_BASED);\nstatic CLK_FIXED_FACTOR(ls1b_clk_apb, \"ls1b_clk_apb\", \"ls1b_clk_ahb\", 2, 1,\n\t\t\tCLK_SET_RATE_PARENT);\n\nstatic struct clk_hw_onecell_data ls1b_clk_hw_data = {\n\t.hws = {\n\t\t[LS1X_CLKID_PLL] = &ls1b_clk_pll.hw,\n\t\t[LS1X_CLKID_CPU] = &ls1b_clk_cpu.hw,\n\t\t[LS1X_CLKID_DC] = &ls1b_clk_dc.hw,\n\t\t[LS1X_CLKID_AHB] = &ls1b_clk_ahb.hw,\n\t\t[LS1X_CLKID_APB] = &ls1b_clk_apb.hw,\n\t},\n\t.num = CLK_NR_CLKS,\n};\n\nstatic const struct clk_div_table ls1c_ahb_div_table[] = {\n\t[0] = { .val = 0, .div = 2 },\n\t[1] = { .val = 1, .div = 4 },\n\t[2] = { .val = 2, .div = 3 },\n\t[3] = { .val = 3, .div = 3 },\n\t[4] = {   }\n};\n\nstatic LS1X_CLK_PLL(ls1c_clk_pll, CLK_PLL_FREQ, 0, 2, 8, 8, 16, 8);\nstatic LS1X_CLK_DIV(ls1c_clk_cpu, &ls1c_clk_pll.hw, CLK_PLL_DIV,\n\t\t    8, 7, NULL, 0, 1,\n\t\t    CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ROUND_CLOSEST);\nstatic LS1X_CLK_DIV(ls1c_clk_dc, &ls1c_clk_pll.hw, CLK_PLL_DIV,\n\t\t    24, 7, NULL, 4, 1, CLK_DIVIDER_ONE_BASED);\nstatic LS1X_CLK_DIV(ls1c_clk_ahb, &ls1c_clk_cpu.hw, CLK_PLL_FREQ,\n\t\t    0, 2, ls1c_ahb_div_table, 0, 0, CLK_DIVIDER_ALLOW_ZERO);\nstatic CLK_FIXED_FACTOR(ls1c_clk_apb, \"ls1c_clk_apb\", \"ls1c_clk_ahb\", 1, 1,\n\t\t\tCLK_SET_RATE_PARENT);\n\nstatic struct clk_hw_onecell_data ls1c_clk_hw_data = {\n\t.hws = {\n\t\t[LS1X_CLKID_PLL] = &ls1c_clk_pll.hw,\n\t\t[LS1X_CLKID_CPU] = &ls1c_clk_cpu.hw,\n\t\t[LS1X_CLKID_DC] = &ls1c_clk_dc.hw,\n\t\t[LS1X_CLKID_AHB] = &ls1c_clk_ahb.hw,\n\t\t[LS1X_CLKID_APB] = &ls1c_clk_apb.hw,\n\t},\n\t.num = CLK_NR_CLKS,\n};\n\nstatic void __init ls1x_clk_init(struct device_node *np,\n\t\t\t\t struct clk_hw_onecell_data *hw_data)\n{\n\tstruct ls1x_clk *ls1x_clk;\n\tvoid __iomem *reg;\n\tint i, ret;\n\n\treg = of_iomap(np, 0);\n\tif (!reg) {\n\t\tpr_err(\"Unable to map base for %pOF\\n\", np);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < hw_data->num; i++) {\n\t\t \n\t\tif (!hw_data->hws[i])\n\t\t\tcontinue;\n\n\t\tif (i != LS1X_CLKID_APB) {\n\t\t\tls1x_clk = to_ls1x_clk(hw_data->hws[i]);\n\t\t\tls1x_clk->reg = reg + ls1x_clk->offset;\n\t\t}\n\n\t\tret = of_clk_hw_register(np, hw_data->hws[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, hw_data);\n\tif (!ret)\n\t\treturn;\n\nerr:\n\tpr_err(\"Failed to register %pOF\\n\", np);\n\n\twhile (--i >= 0)\n\t\tclk_hw_unregister(hw_data->hws[i]);\n\n\tiounmap(reg);\n}\n\nstatic void __init ls1b_clk_init(struct device_node *np)\n{\n\treturn ls1x_clk_init(np, &ls1b_clk_hw_data);\n}\n\nstatic void __init ls1c_clk_init(struct device_node *np)\n{\n\treturn ls1x_clk_init(np, &ls1c_clk_hw_data);\n}\n\nCLK_OF_DECLARE(ls1b_clk, \"loongson,ls1b-clk\", ls1b_clk_init);\nCLK_OF_DECLARE(ls1c_clk, \"loongson,ls1c-clk\", ls1c_clk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}