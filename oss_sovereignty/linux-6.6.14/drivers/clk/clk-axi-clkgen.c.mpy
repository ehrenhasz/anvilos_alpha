{
  "module_name": "clk-axi-clkgen.c",
  "hash_id": "0ec16021c170cfadf0b70085feb3ab0cb62504882393282912087125b22336fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-axi-clkgen.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/err.h>\n\n#define AXI_CLKGEN_V2_REG_RESET\t\t0x40\n#define AXI_CLKGEN_V2_REG_CLKSEL\t0x44\n#define AXI_CLKGEN_V2_REG_DRP_CNTRL\t0x70\n#define AXI_CLKGEN_V2_REG_DRP_STATUS\t0x74\n\n#define AXI_CLKGEN_V2_RESET_MMCM_ENABLE\tBIT(1)\n#define AXI_CLKGEN_V2_RESET_ENABLE\tBIT(0)\n\n#define AXI_CLKGEN_V2_DRP_CNTRL_SEL\tBIT(29)\n#define AXI_CLKGEN_V2_DRP_CNTRL_READ\tBIT(28)\n\n#define AXI_CLKGEN_V2_DRP_STATUS_BUSY\tBIT(16)\n\n#define MMCM_REG_CLKOUT5_2\t0x07\n#define MMCM_REG_CLKOUT0_1\t0x08\n#define MMCM_REG_CLKOUT0_2\t0x09\n#define MMCM_REG_CLKOUT6_2\t0x13\n#define MMCM_REG_CLK_FB1\t0x14\n#define MMCM_REG_CLK_FB2\t0x15\n#define MMCM_REG_CLK_DIV\t0x16\n#define MMCM_REG_LOCK1\t\t0x18\n#define MMCM_REG_LOCK2\t\t0x19\n#define MMCM_REG_LOCK3\t\t0x1a\n#define MMCM_REG_POWER\t\t0x28\n#define MMCM_REG_FILTER1\t0x4e\n#define MMCM_REG_FILTER2\t0x4f\n\n#define MMCM_CLKOUT_NOCOUNT\tBIT(6)\n\n#define MMCM_CLK_DIV_DIVIDE\tBIT(11)\n#define MMCM_CLK_DIV_NOCOUNT\tBIT(12)\n\nstruct axi_clkgen_limits {\n\tunsigned int fpfd_min;\n\tunsigned int fpfd_max;\n\tunsigned int fvco_min;\n\tunsigned int fvco_max;\n};\n\nstruct axi_clkgen {\n\tvoid __iomem *base;\n\tstruct clk_hw clk_hw;\n\tstruct axi_clkgen_limits limits;\n};\n\nstatic uint32_t axi_clkgen_lookup_filter(unsigned int m)\n{\n\tswitch (m) {\n\tcase 0:\n\t\treturn 0x01001990;\n\tcase 1:\n\t\treturn 0x01001190;\n\tcase 2:\n\t\treturn 0x01009890;\n\tcase 3:\n\t\treturn 0x01001890;\n\tcase 4:\n\t\treturn 0x01008890;\n\tcase 5 ... 8:\n\t\treturn 0x01009090;\n\tcase 9 ... 11:\n\t\treturn 0x01000890;\n\tcase 12:\n\t\treturn 0x08009090;\n\tcase 13 ... 22:\n\t\treturn 0x01001090;\n\tcase 23 ... 36:\n\t\treturn 0x01008090;\n\tcase 37 ... 46:\n\t\treturn 0x08001090;\n\tdefault:\n\t\treturn 0x08008090;\n\t}\n}\n\nstatic const uint32_t axi_clkgen_lock_table[] = {\n\t0x060603e8, 0x060603e8, 0x080803e8, 0x0b0b03e8,\n\t0x0e0e03e8, 0x111103e8, 0x131303e8, 0x161603e8,\n\t0x191903e8, 0x1c1c03e8, 0x1f1f0384, 0x1f1f0339,\n\t0x1f1f02ee, 0x1f1f02bc, 0x1f1f028a, 0x1f1f0271,\n\t0x1f1f023f, 0x1f1f0226, 0x1f1f020d, 0x1f1f01f4,\n\t0x1f1f01db, 0x1f1f01c2, 0x1f1f01a9, 0x1f1f0190,\n\t0x1f1f0190, 0x1f1f0177, 0x1f1f015e, 0x1f1f015e,\n\t0x1f1f0145, 0x1f1f0145, 0x1f1f012c, 0x1f1f012c,\n\t0x1f1f012c, 0x1f1f0113, 0x1f1f0113, 0x1f1f0113,\n};\n\nstatic uint32_t axi_clkgen_lookup_lock(unsigned int m)\n{\n\tif (m < ARRAY_SIZE(axi_clkgen_lock_table))\n\t\treturn axi_clkgen_lock_table[m];\n\treturn 0x1f1f00fa;\n}\n\nstatic const struct axi_clkgen_limits axi_clkgen_zynqmp_default_limits = {\n\t.fpfd_min = 10000,\n\t.fpfd_max = 450000,\n\t.fvco_min = 800000,\n\t.fvco_max = 1600000,\n};\n\nstatic const struct axi_clkgen_limits axi_clkgen_zynq_default_limits = {\n\t.fpfd_min = 10000,\n\t.fpfd_max = 300000,\n\t.fvco_min = 600000,\n\t.fvco_max = 1200000,\n};\n\nstatic void axi_clkgen_calc_params(const struct axi_clkgen_limits *limits,\n\tunsigned long fin, unsigned long fout,\n\tunsigned int *best_d, unsigned int *best_m, unsigned int *best_dout)\n{\n\tunsigned long d, d_min, d_max, _d_min, _d_max;\n\tunsigned long m, m_min, m_max;\n\tunsigned long f, dout, best_f, fvco;\n\tunsigned long fract_shift = 0;\n\tunsigned long fvco_min_fract, fvco_max_fract;\n\n\tfin /= 1000;\n\tfout /= 1000;\n\n\tbest_f = ULONG_MAX;\n\t*best_d = 0;\n\t*best_m = 0;\n\t*best_dout = 0;\n\n\td_min = max_t(unsigned long, DIV_ROUND_UP(fin, limits->fpfd_max), 1);\n\td_max = min_t(unsigned long, fin / limits->fpfd_min, 80);\n\nagain:\n\tfvco_min_fract = limits->fvco_min << fract_shift;\n\tfvco_max_fract = limits->fvco_max << fract_shift;\n\n\tm_min = max_t(unsigned long, DIV_ROUND_UP(fvco_min_fract, fin) * d_min, 1);\n\tm_max = min_t(unsigned long, fvco_max_fract * d_max / fin, 64 << fract_shift);\n\n\tfor (m = m_min; m <= m_max; m++) {\n\t\t_d_min = max(d_min, DIV_ROUND_UP(fin * m, fvco_max_fract));\n\t\t_d_max = min(d_max, fin * m / fvco_min_fract);\n\n\t\tfor (d = _d_min; d <= _d_max; d++) {\n\t\t\tfvco = fin * m / d;\n\n\t\t\tdout = DIV_ROUND_CLOSEST(fvco, fout);\n\t\t\tdout = clamp_t(unsigned long, dout, 1, 128 << fract_shift);\n\t\t\tf = fvco / dout;\n\t\t\tif (abs(f - fout) < abs(best_f - fout)) {\n\t\t\t\tbest_f = f;\n\t\t\t\t*best_d = d;\n\t\t\t\t*best_m = m << (3 - fract_shift);\n\t\t\t\t*best_dout = dout << (3 - fract_shift);\n\t\t\t\tif (best_f == fout)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (fract_shift == 0) {\n\t\tfract_shift = 3;\n\t\tgoto again;\n\t}\n}\n\nstruct axi_clkgen_div_params {\n\tunsigned int low;\n\tunsigned int high;\n\tunsigned int edge;\n\tunsigned int nocount;\n\tunsigned int frac_en;\n\tunsigned int frac;\n\tunsigned int frac_wf_f;\n\tunsigned int frac_wf_r;\n\tunsigned int frac_phase;\n};\n\nstatic void axi_clkgen_calc_clk_params(unsigned int divider,\n\tunsigned int frac_divider, struct axi_clkgen_div_params *params)\n{\n\n\tmemset(params, 0x0, sizeof(*params));\n\n\tif (divider == 1) {\n\t\tparams->nocount = 1;\n\t\treturn;\n\t}\n\n\tif (frac_divider == 0) {\n\t\tparams->high = divider / 2;\n\t\tparams->edge = divider % 2;\n\t\tparams->low = divider - params->high;\n\t} else {\n\t\tparams->frac_en = 1;\n\t\tparams->frac = frac_divider;\n\n\t\tparams->high = divider / 2;\n\t\tparams->edge = divider % 2;\n\t\tparams->low = params->high;\n\n\t\tif (params->edge == 0) {\n\t\t\tparams->high--;\n\t\t\tparams->frac_wf_r = 1;\n\t\t}\n\n\t\tif (params->edge == 0 || frac_divider == 1)\n\t\t\tparams->low--;\n\t\tif (((params->edge == 0) ^ (frac_divider == 1)) ||\n\t\t\t(divider == 2 && frac_divider == 1))\n\t\t\tparams->frac_wf_f = 1;\n\n\t\tparams->frac_phase = params->edge * 4 + frac_divider / 2;\n\t}\n}\n\nstatic void axi_clkgen_write(struct axi_clkgen *axi_clkgen,\n\tunsigned int reg, unsigned int val)\n{\n\twritel(val, axi_clkgen->base + reg);\n}\n\nstatic void axi_clkgen_read(struct axi_clkgen *axi_clkgen,\n\tunsigned int reg, unsigned int *val)\n{\n\t*val = readl(axi_clkgen->base + reg);\n}\n\nstatic int axi_clkgen_wait_non_busy(struct axi_clkgen *axi_clkgen)\n{\n\tunsigned int timeout = 10000;\n\tunsigned int val;\n\n\tdo {\n\t\taxi_clkgen_read(axi_clkgen, AXI_CLKGEN_V2_REG_DRP_STATUS, &val);\n\t} while ((val & AXI_CLKGEN_V2_DRP_STATUS_BUSY) && --timeout);\n\n\tif (val & AXI_CLKGEN_V2_DRP_STATUS_BUSY)\n\t\treturn -EIO;\n\n\treturn val & 0xffff;\n}\n\nstatic int axi_clkgen_mmcm_read(struct axi_clkgen *axi_clkgen,\n\tunsigned int reg, unsigned int *val)\n{\n\tunsigned int reg_val;\n\tint ret;\n\n\tret = axi_clkgen_wait_non_busy(axi_clkgen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treg_val = AXI_CLKGEN_V2_DRP_CNTRL_SEL | AXI_CLKGEN_V2_DRP_CNTRL_READ;\n\treg_val |= (reg << 16);\n\n\taxi_clkgen_write(axi_clkgen, AXI_CLKGEN_V2_REG_DRP_CNTRL, reg_val);\n\n\tret = axi_clkgen_wait_non_busy(axi_clkgen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\n\treturn 0;\n}\n\nstatic int axi_clkgen_mmcm_write(struct axi_clkgen *axi_clkgen,\n\tunsigned int reg, unsigned int val, unsigned int mask)\n{\n\tunsigned int reg_val = 0;\n\tint ret;\n\n\tret = axi_clkgen_wait_non_busy(axi_clkgen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (mask != 0xffff) {\n\t\taxi_clkgen_mmcm_read(axi_clkgen, reg, &reg_val);\n\t\treg_val &= ~mask;\n\t}\n\n\treg_val |= AXI_CLKGEN_V2_DRP_CNTRL_SEL | (reg << 16) | (val & mask);\n\n\taxi_clkgen_write(axi_clkgen, AXI_CLKGEN_V2_REG_DRP_CNTRL, reg_val);\n\n\treturn 0;\n}\n\nstatic void axi_clkgen_mmcm_enable(struct axi_clkgen *axi_clkgen,\n\tbool enable)\n{\n\tunsigned int val = AXI_CLKGEN_V2_RESET_ENABLE;\n\n\tif (enable)\n\t\tval |= AXI_CLKGEN_V2_RESET_MMCM_ENABLE;\n\n\taxi_clkgen_write(axi_clkgen, AXI_CLKGEN_V2_REG_RESET, val);\n}\n\nstatic struct axi_clkgen *clk_hw_to_axi_clkgen(struct clk_hw *clk_hw)\n{\n\treturn container_of(clk_hw, struct axi_clkgen, clk_hw);\n}\n\nstatic void axi_clkgen_set_div(struct axi_clkgen *axi_clkgen,\n\tunsigned int reg1, unsigned int reg2, unsigned int reg3,\n\tstruct axi_clkgen_div_params *params)\n{\n\taxi_clkgen_mmcm_write(axi_clkgen, reg1,\n\t\t(params->high << 6) | params->low, 0xefff);\n\taxi_clkgen_mmcm_write(axi_clkgen, reg2,\n\t\t(params->frac << 12) | (params->frac_en << 11) |\n\t\t(params->frac_wf_r << 10) | (params->edge << 7) |\n\t\t(params->nocount << 6), 0x7fff);\n\tif (reg3 != 0) {\n\t\taxi_clkgen_mmcm_write(axi_clkgen, reg3,\n\t\t\t(params->frac_phase << 11) | (params->frac_wf_f << 10), 0x3c00);\n\t}\n}\n\nstatic int axi_clkgen_set_rate(struct clk_hw *clk_hw,\n\tunsigned long rate, unsigned long parent_rate)\n{\n\tstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\n\tconst struct axi_clkgen_limits *limits = &axi_clkgen->limits;\n\tunsigned int d, m, dout;\n\tstruct axi_clkgen_div_params params;\n\tuint32_t power = 0;\n\tuint32_t filter;\n\tuint32_t lock;\n\n\tif (parent_rate == 0 || rate == 0)\n\t\treturn -EINVAL;\n\n\taxi_clkgen_calc_params(limits, parent_rate, rate, &d, &m, &dout);\n\n\tif (d == 0 || dout == 0 || m == 0)\n\t\treturn -EINVAL;\n\n\tif ((dout & 0x7) != 0 || (m & 0x7) != 0)\n\t\tpower |= 0x9800;\n\n\taxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_POWER, power, 0x9800);\n\n\tfilter = axi_clkgen_lookup_filter(m - 1);\n\tlock = axi_clkgen_lookup_lock(m - 1);\n\n\taxi_clkgen_calc_clk_params(dout >> 3, dout & 0x7, &params);\n\taxi_clkgen_set_div(axi_clkgen,  MMCM_REG_CLKOUT0_1, MMCM_REG_CLKOUT0_2,\n\t\tMMCM_REG_CLKOUT5_2, &params);\n\n\taxi_clkgen_calc_clk_params(d, 0, &params);\n\taxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_CLK_DIV,\n\t\t(params.edge << 13) | (params.nocount << 12) |\n\t\t(params.high << 6) | params.low, 0x3fff);\n\n\taxi_clkgen_calc_clk_params(m >> 3, m & 0x7, &params);\n\taxi_clkgen_set_div(axi_clkgen,  MMCM_REG_CLK_FB1, MMCM_REG_CLK_FB2,\n\t\tMMCM_REG_CLKOUT6_2, &params);\n\n\taxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_LOCK1, lock & 0x3ff, 0x3ff);\n\taxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_LOCK2,\n\t\t(((lock >> 16) & 0x1f) << 10) | 0x1, 0x7fff);\n\taxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_LOCK3,\n\t\t(((lock >> 24) & 0x1f) << 10) | 0x3e9, 0x7fff);\n\taxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_FILTER1, filter >> 16, 0x9900);\n\taxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_FILTER2, filter, 0x9900);\n\n\treturn 0;\n}\n\nstatic int axi_clkgen_determine_rate(struct clk_hw *hw,\n\t\t\t\t     struct clk_rate_request *req)\n{\n\tstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(hw);\n\tconst struct axi_clkgen_limits *limits = &axi_clkgen->limits;\n\tunsigned int d, m, dout;\n\tunsigned long long tmp;\n\n\taxi_clkgen_calc_params(limits, req->best_parent_rate, req->rate,\n\t\t\t       &d, &m, &dout);\n\n\tif (d == 0 || dout == 0 || m == 0)\n\t\treturn -EINVAL;\n\n\ttmp = (unsigned long long)req->best_parent_rate * m;\n\ttmp = DIV_ROUND_CLOSEST_ULL(tmp, dout * d);\n\n\treq->rate = min_t(unsigned long long, tmp, LONG_MAX);\n\treturn 0;\n}\n\nstatic unsigned int axi_clkgen_get_div(struct axi_clkgen *axi_clkgen,\n\tunsigned int reg1, unsigned int reg2)\n{\n\tunsigned int val1, val2;\n\tunsigned int div;\n\n\taxi_clkgen_mmcm_read(axi_clkgen, reg2, &val2);\n\tif (val2 & MMCM_CLKOUT_NOCOUNT)\n\t\treturn 8;\n\n\taxi_clkgen_mmcm_read(axi_clkgen, reg1, &val1);\n\n\tdiv = (val1 & 0x3f) + ((val1 >> 6) & 0x3f);\n\tdiv <<= 3;\n\n\tif (val2 & MMCM_CLK_DIV_DIVIDE) {\n\t\tif ((val2 & BIT(7)) && (val2 & 0x7000) != 0x1000)\n\t\t\tdiv += 8;\n\t\telse\n\t\t\tdiv += 16;\n\n\t\tdiv += (val2 >> 12) & 0x7;\n\t}\n\n\treturn div;\n}\n\nstatic unsigned long axi_clkgen_recalc_rate(struct clk_hw *clk_hw,\n\tunsigned long parent_rate)\n{\n\tstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\n\tunsigned int d, m, dout;\n\tunsigned long long tmp;\n\tunsigned int val;\n\n\tdout = axi_clkgen_get_div(axi_clkgen, MMCM_REG_CLKOUT0_1,\n\t\tMMCM_REG_CLKOUT0_2);\n\tm = axi_clkgen_get_div(axi_clkgen, MMCM_REG_CLK_FB1,\n\t\tMMCM_REG_CLK_FB2);\n\n\taxi_clkgen_mmcm_read(axi_clkgen, MMCM_REG_CLK_DIV, &val);\n\tif (val & MMCM_CLK_DIV_NOCOUNT)\n\t\td = 1;\n\telse\n\t\td = (val & 0x3f) + ((val >> 6) & 0x3f);\n\n\tif (d == 0 || dout == 0)\n\t\treturn 0;\n\n\ttmp = (unsigned long long)parent_rate * m;\n\ttmp = DIV_ROUND_CLOSEST_ULL(tmp, dout * d);\n\n\treturn min_t(unsigned long long, tmp, ULONG_MAX);\n}\n\nstatic int axi_clkgen_enable(struct clk_hw *clk_hw)\n{\n\tstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\n\n\taxi_clkgen_mmcm_enable(axi_clkgen, true);\n\n\treturn 0;\n}\n\nstatic void axi_clkgen_disable(struct clk_hw *clk_hw)\n{\n\tstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\n\n\taxi_clkgen_mmcm_enable(axi_clkgen, false);\n}\n\nstatic int axi_clkgen_set_parent(struct clk_hw *clk_hw, u8 index)\n{\n\tstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\n\n\taxi_clkgen_write(axi_clkgen, AXI_CLKGEN_V2_REG_CLKSEL, index);\n\n\treturn 0;\n}\n\nstatic u8 axi_clkgen_get_parent(struct clk_hw *clk_hw)\n{\n\tstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\n\tunsigned int parent;\n\n\taxi_clkgen_read(axi_clkgen, AXI_CLKGEN_V2_REG_CLKSEL, &parent);\n\n\treturn parent;\n}\n\nstatic const struct clk_ops axi_clkgen_ops = {\n\t.recalc_rate = axi_clkgen_recalc_rate,\n\t.determine_rate = axi_clkgen_determine_rate,\n\t.set_rate = axi_clkgen_set_rate,\n\t.enable = axi_clkgen_enable,\n\t.disable = axi_clkgen_disable,\n\t.set_parent = axi_clkgen_set_parent,\n\t.get_parent = axi_clkgen_get_parent,\n};\n\nstatic int axi_clkgen_probe(struct platform_device *pdev)\n{\n\tconst struct axi_clkgen_limits *dflt_limits;\n\tstruct axi_clkgen *axi_clkgen;\n\tstruct clk_init_data init;\n\tconst char *parent_names[2];\n\tconst char *clk_name;\n\tunsigned int i;\n\tint ret;\n\n\tdflt_limits = device_get_match_data(&pdev->dev);\n\tif (!dflt_limits)\n\t\treturn -ENODEV;\n\n\taxi_clkgen = devm_kzalloc(&pdev->dev, sizeof(*axi_clkgen), GFP_KERNEL);\n\tif (!axi_clkgen)\n\t\treturn -ENOMEM;\n\n\taxi_clkgen->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(axi_clkgen->base))\n\t\treturn PTR_ERR(axi_clkgen->base);\n\n\tinit.num_parents = of_clk_get_parent_count(pdev->dev.of_node);\n\tif (init.num_parents < 1 || init.num_parents > 2)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < init.num_parents; i++) {\n\t\tparent_names[i] = of_clk_get_parent_name(pdev->dev.of_node, i);\n\t\tif (!parent_names[i])\n\t\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&axi_clkgen->limits, dflt_limits, sizeof(axi_clkgen->limits));\n\n\tclk_name = pdev->dev.of_node->name;\n\tof_property_read_string(pdev->dev.of_node, \"clock-output-names\",\n\t\t&clk_name);\n\n\tinit.name = clk_name;\n\tinit.ops = &axi_clkgen_ops;\n\tinit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\n\tinit.parent_names = parent_names;\n\n\taxi_clkgen_mmcm_enable(axi_clkgen, false);\n\n\taxi_clkgen->clk_hw.init = &init;\n\tret = devm_clk_hw_register(&pdev->dev, &axi_clkgen->clk_hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, of_clk_hw_simple_get,\n\t\t\t\t\t   &axi_clkgen->clk_hw);\n}\n\nstatic const struct of_device_id axi_clkgen_ids[] = {\n\t{\n\t\t.compatible = \"adi,zynqmp-axi-clkgen-2.00.a\",\n\t\t.data = &axi_clkgen_zynqmp_default_limits,\n\t},\n\t{\n\t\t.compatible = \"adi,axi-clkgen-2.00.a\",\n\t\t.data = &axi_clkgen_zynq_default_limits,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, axi_clkgen_ids);\n\nstatic struct platform_driver axi_clkgen_driver = {\n\t.driver = {\n\t\t.name = \"adi-axi-clkgen\",\n\t\t.of_match_table = axi_clkgen_ids,\n\t},\n\t.probe = axi_clkgen_probe,\n};\nmodule_platform_driver(axi_clkgen_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Driver for the Analog Devices' AXI clkgen pcore clock generator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}