{
  "module_name": "turingcc-qcs404.c",
  "hash_id": "46ecd6bccb9fbcb298f367fc723e96eefee5cecb3ca3a71b5582a9a4718dcc49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/turingcc-qcs404.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/clock/qcom,turingcc-qcs404.h>\n\n#include \"clk-regmap.h\"\n#include \"clk-branch.h\"\n#include \"common.h\"\n#include \"reset.h\"\n\nstatic struct clk_branch turing_wrapper_aon_cbcr = {\n\t.halt_reg = 0x5098,\n\t.halt_check = BRANCH_HALT,\n\t.clkr = {\n\t\t.enable_reg = 0x5098,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data) {\n\t\t\t.name = \"turing_wrapper_aon_clk\",\n\t\t\t.ops = &clk_branch2_aon_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch turing_q6ss_ahbm_aon_cbcr = {\n\t.halt_reg = 0x9000,\n\t.halt_check = BRANCH_HALT,\n\t.clkr = {\n\t\t.enable_reg = 0x9000,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data) {\n\t\t\t.name = \"turing_q6ss_ahbm_aon_cbcr\",\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch turing_q6ss_q6_axim_clk = {\n\t.halt_reg = 0xb000,\n\t.halt_check = BRANCH_HALT,\n\t.clkr = {\n\t\t.enable_reg = 0xb000,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data) {\n\t\t\t.name = \"turing_q6ss_q6_axim_clk\",\n\t\t\t.ops = &clk_branch2_aon_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch turing_q6ss_ahbs_aon_cbcr = {\n\t.halt_reg = 0x10000,\n\t.halt_check = BRANCH_HALT,\n\t.clkr = {\n\t\t.enable_reg = 0x10000,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data) {\n\t\t\t.name = \"turing_q6ss_ahbs_aon_clk\",\n\t\t\t.ops = &clk_branch2_aon_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch turing_wrapper_qos_ahbs_aon_cbcr = {\n\t.halt_reg = 0x11014,\n\t.halt_check = BRANCH_HALT,\n\t.clkr = {\n\t\t.enable_reg = 0x11014,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data) {\n\t\t\t.name = \"turing_wrapper_qos_ahbs_aon_clk\",\n\t\t\t.ops = &clk_branch2_aon_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_regmap *turingcc_clocks[] = {\n\t[TURING_WRAPPER_AON_CLK] = &turing_wrapper_aon_cbcr.clkr,\n\t[TURING_Q6SS_AHBM_AON_CLK] = &turing_q6ss_ahbm_aon_cbcr.clkr,\n\t[TURING_Q6SS_Q6_AXIM_CLK] = &turing_q6ss_q6_axim_clk.clkr,\n\t[TURING_Q6SS_AHBS_AON_CLK] = &turing_q6ss_ahbs_aon_cbcr.clkr,\n\t[TURING_WRAPPER_QOS_AHBS_AON_CLK] = &turing_wrapper_qos_ahbs_aon_cbcr.clkr,\n};\n\nstatic const struct regmap_config turingcc_regmap_config = {\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n\t.max_register\t= 0x23004,\n\t.fast_io\t= true,\n};\n\nstatic const struct qcom_cc_desc turingcc_desc = {\n\t.config = &turingcc_regmap_config,\n\t.clks = turingcc_clocks,\n\t.num_clks = ARRAY_SIZE(turingcc_clocks),\n};\n\nstatic int turingcc_probe(struct platform_device *pdev)\n{\n\tint ret;\n\n\tret = devm_pm_runtime_enable(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_pm_clk_create(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_clk_add(&pdev->dev, NULL);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to acquire iface clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_cc_probe(pdev, &turingcc_desc);\n\tif (ret < 0)\n\t\tgoto err_put_rpm;\n\n\tpm_runtime_put(&pdev->dev);\n\n\treturn 0;\n\nerr_put_rpm:\n\tpm_runtime_put_sync(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops turingcc_pm_ops = {\n\tSET_RUNTIME_PM_OPS(pm_clk_suspend, pm_clk_resume, NULL)\n};\n\nstatic const struct of_device_id turingcc_match_table[] = {\n\t{ .compatible = \"qcom,qcs404-turingcc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, turingcc_match_table);\n\nstatic struct platform_driver turingcc_driver = {\n\t.probe\t\t= turingcc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"qcs404-turingcc\",\n\t\t.of_match_table = turingcc_match_table,\n\t\t.pm = &turingcc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(turingcc_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm QCS404 Turing Clock Controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}