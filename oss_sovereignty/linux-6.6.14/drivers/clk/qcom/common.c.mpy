{
  "module_name": "common.c",
  "hash_id": "6742ebd81d9a5558e6ce482a615d746ca73c72c8b4aea4f88ae276eae1fb49f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/common.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/platform_device.h>\n#include <linux/clk-provider.h>\n#include <linux/reset-controller.h>\n#include <linux/of.h>\n\n#include \"common.h\"\n#include \"clk-rcg.h\"\n#include \"clk-regmap.h\"\n#include \"reset.h\"\n#include \"gdsc.h\"\n\nstruct qcom_cc {\n\tstruct qcom_reset_controller reset;\n\tstruct clk_regmap **rclks;\n\tsize_t num_rclks;\n};\n\nconst\nstruct freq_tbl *qcom_find_freq(const struct freq_tbl *f, unsigned long rate)\n{\n\tif (!f)\n\t\treturn NULL;\n\n\tif (!f->freq)\n\t\treturn f;\n\n\tfor (; f->freq; f++)\n\t\tif (rate <= f->freq)\n\t\t\treturn f;\n\n\t \n\treturn f - 1;\n}\nEXPORT_SYMBOL_GPL(qcom_find_freq);\n\nconst struct freq_tbl *qcom_find_freq_floor(const struct freq_tbl *f,\n\t\t\t\t\t    unsigned long rate)\n{\n\tconst struct freq_tbl *best = NULL;\n\n\tfor ( ; f->freq; f++) {\n\t\tif (rate >= f->freq)\n\t\t\tbest = f;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn best;\n}\nEXPORT_SYMBOL_GPL(qcom_find_freq_floor);\n\nint qcom_find_src_index(struct clk_hw *hw, const struct parent_map *map, u8 src)\n{\n\tint i, num_parents = clk_hw_get_num_parents(hw);\n\n\tfor (i = 0; i < num_parents; i++)\n\t\tif (src == map[i].src)\n\t\t\treturn i;\n\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(qcom_find_src_index);\n\nint qcom_find_cfg_index(struct clk_hw *hw, const struct parent_map *map, u8 cfg)\n{\n\tint i, num_parents = clk_hw_get_num_parents(hw);\n\n\tfor (i = 0; i < num_parents; i++)\n\t\tif (cfg == map[i].cfg)\n\t\t\treturn i;\n\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(qcom_find_cfg_index);\n\nstruct regmap *\nqcom_cc_map(struct platform_device *pdev, const struct qcom_cc_desc *desc)\n{\n\tvoid __iomem *base;\n\tstruct device *dev = &pdev->dev;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn ERR_CAST(base);\n\n\treturn devm_regmap_init_mmio(dev, base, desc->config);\n}\nEXPORT_SYMBOL_GPL(qcom_cc_map);\n\nvoid\nqcom_pll_set_fsm_mode(struct regmap *map, u32 reg, u8 bias_count, u8 lock_count)\n{\n\tu32 val;\n\tu32 mask;\n\n\t \n\tregmap_update_bits(map, reg, PLL_VOTE_FSM_RESET, 0);\n\n\t \n\tval = bias_count << PLL_BIAS_COUNT_SHIFT |\n\t\tlock_count << PLL_LOCK_COUNT_SHIFT;\n\tmask = PLL_BIAS_COUNT_MASK << PLL_BIAS_COUNT_SHIFT;\n\tmask |= PLL_LOCK_COUNT_MASK << PLL_LOCK_COUNT_SHIFT;\n\tregmap_update_bits(map, reg, mask, val);\n\n\t \n\tregmap_update_bits(map, reg, PLL_VOTE_FSM_ENA, PLL_VOTE_FSM_ENA);\n}\nEXPORT_SYMBOL_GPL(qcom_pll_set_fsm_mode);\n\nstatic void qcom_cc_gdsc_unregister(void *data)\n{\n\tgdsc_unregister(data);\n}\n\n \nstatic int _qcom_cc_register_board_clk(struct device *dev, const char *path,\n\t\t\t\t       const char *name, unsigned long rate,\n\t\t\t\t       bool add_factor)\n{\n\tstruct device_node *node = NULL;\n\tstruct device_node *clocks_node;\n\tstruct clk_fixed_factor *factor;\n\tstruct clk_fixed_rate *fixed;\n\tstruct clk_init_data init_data = { };\n\tint ret;\n\n\tclocks_node = of_find_node_by_path(\"/clocks\");\n\tif (clocks_node) {\n\t\tnode = of_get_child_by_name(clocks_node, path);\n\t\tof_node_put(clocks_node);\n\t}\n\n\tif (!node) {\n\t\tfixed = devm_kzalloc(dev, sizeof(*fixed), GFP_KERNEL);\n\t\tif (!fixed)\n\t\t\treturn -EINVAL;\n\n\t\tfixed->fixed_rate = rate;\n\t\tfixed->hw.init = &init_data;\n\n\t\tinit_data.name = path;\n\t\tinit_data.ops = &clk_fixed_rate_ops;\n\n\t\tret = devm_clk_hw_register(dev, &fixed->hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tof_node_put(node);\n\n\tif (add_factor) {\n\t\tfactor = devm_kzalloc(dev, sizeof(*factor), GFP_KERNEL);\n\t\tif (!factor)\n\t\t\treturn -EINVAL;\n\n\t\tfactor->mult = factor->div = 1;\n\t\tfactor->hw.init = &init_data;\n\n\t\tinit_data.name = name;\n\t\tinit_data.parent_names = &path;\n\t\tinit_data.num_parents = 1;\n\t\tinit_data.flags = 0;\n\t\tinit_data.ops = &clk_fixed_factor_ops;\n\n\t\tret = devm_clk_hw_register(dev, &factor->hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint qcom_cc_register_board_clk(struct device *dev, const char *path,\n\t\t\t       const char *name, unsigned long rate)\n{\n\tbool add_factor = true;\n\n\t \n\n\treturn _qcom_cc_register_board_clk(dev, path, name, rate, add_factor);\n}\nEXPORT_SYMBOL_GPL(qcom_cc_register_board_clk);\n\nint qcom_cc_register_sleep_clk(struct device *dev)\n{\n\treturn _qcom_cc_register_board_clk(dev, \"sleep_clk\", \"sleep_clk_src\",\n\t\t\t\t\t   32768, true);\n}\nEXPORT_SYMBOL_GPL(qcom_cc_register_sleep_clk);\n\n \nstatic void qcom_cc_drop_protected(struct device *dev, struct qcom_cc *cc)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct property *prop;\n\tconst __be32 *p;\n\tu32 i;\n\n\tof_property_for_each_u32(np, \"protected-clocks\", prop, p, i) {\n\t\tif (i >= cc->num_rclks)\n\t\t\tcontinue;\n\n\t\tcc->rclks[i] = NULL;\n\t}\n}\n\nstatic struct clk_hw *qcom_cc_clk_hw_get(struct of_phandle_args *clkspec,\n\t\t\t\t\t void *data)\n{\n\tstruct qcom_cc *cc = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= cc->num_rclks) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn cc->rclks[idx] ? &cc->rclks[idx]->hw : NULL;\n}\n\nint qcom_cc_really_probe(struct platform_device *pdev,\n\t\t\t const struct qcom_cc_desc *desc, struct regmap *regmap)\n{\n\tint i, ret;\n\tstruct device *dev = &pdev->dev;\n\tstruct qcom_reset_controller *reset;\n\tstruct qcom_cc *cc;\n\tstruct gdsc_desc *scd;\n\tsize_t num_clks = desc->num_clks;\n\tstruct clk_regmap **rclks = desc->clks;\n\tsize_t num_clk_hws = desc->num_clk_hws;\n\tstruct clk_hw **clk_hws = desc->clk_hws;\n\n\tcc = devm_kzalloc(dev, sizeof(*cc), GFP_KERNEL);\n\tif (!cc)\n\t\treturn -ENOMEM;\n\n\treset = &cc->reset;\n\treset->rcdev.of_node = dev->of_node;\n\treset->rcdev.ops = &qcom_reset_ops;\n\treset->rcdev.owner = dev->driver->owner;\n\treset->rcdev.nr_resets = desc->num_resets;\n\treset->regmap = regmap;\n\treset->reset_map = desc->resets;\n\n\tret = devm_reset_controller_register(dev, &reset->rcdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (desc->gdscs && desc->num_gdscs) {\n\t\tscd = devm_kzalloc(dev, sizeof(*scd), GFP_KERNEL);\n\t\tif (!scd)\n\t\t\treturn -ENOMEM;\n\t\tscd->dev = dev;\n\t\tscd->scs = desc->gdscs;\n\t\tscd->num = desc->num_gdscs;\n\t\tret = gdsc_register(scd, &reset->rcdev, regmap);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = devm_add_action_or_reset(dev, qcom_cc_gdsc_unregister,\n\t\t\t\t\t       scd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcc->rclks = rclks;\n\tcc->num_rclks = num_clks;\n\n\tqcom_cc_drop_protected(dev, cc);\n\n\tfor (i = 0; i < num_clk_hws; i++) {\n\t\tret = devm_clk_hw_register(dev, clk_hws[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tif (!rclks[i])\n\t\t\tcontinue;\n\n\t\tret = devm_clk_register_regmap(dev, rclks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_of_clk_add_hw_provider(dev, qcom_cc_clk_hw_get, cc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qcom_cc_really_probe);\n\nint qcom_cc_probe(struct platform_device *pdev, const struct qcom_cc_desc *desc)\n{\n\tstruct regmap *regmap;\n\n\tregmap = qcom_cc_map(pdev, desc);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn qcom_cc_really_probe(pdev, desc, regmap);\n}\nEXPORT_SYMBOL_GPL(qcom_cc_probe);\n\nint qcom_cc_probe_by_index(struct platform_device *pdev, int index,\n\t\t\t   const struct qcom_cc_desc *desc)\n{\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\n\tbase = devm_platform_ioremap_resource(pdev, index);\n\tif (IS_ERR(base))\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_mmio(&pdev->dev, base, desc->config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn qcom_cc_really_probe(pdev, desc, regmap);\n}\nEXPORT_SYMBOL_GPL(qcom_cc_probe_by_index);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}