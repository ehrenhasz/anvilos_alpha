{
  "module_name": "apss-ipq-pll.c",
  "hash_id": "c1cd01a971e88e3f38085d4dc24f659b19a92deca7d43bcad3323401cac7e561",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/apss-ipq-pll.c",
  "human_readable_source": "\n\n#include <linux/clk-provider.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include \"clk-alpha-pll.h\"\n\n \nstatic const u8 ipq_pll_offsets[][PLL_OFF_MAX_REGS] = {\n\t[CLK_ALPHA_PLL_TYPE_HUAYRA] =  {\n\t\t[PLL_OFF_L_VAL] = 0x08,\n\t\t[PLL_OFF_ALPHA_VAL] = 0x10,\n\t\t[PLL_OFF_USER_CTL] = 0x18,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x20,\n\t\t[PLL_OFF_CONFIG_CTL_U] = 0x24,\n\t\t[PLL_OFF_STATUS] = 0x28,\n\t\t[PLL_OFF_TEST_CTL] = 0x30,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x34,\n\t},\n\t[CLK_ALPHA_PLL_TYPE_STROMER_PLUS] = {\n\t\t[PLL_OFF_L_VAL] = 0x08,\n\t\t[PLL_OFF_ALPHA_VAL] = 0x10,\n\t\t[PLL_OFF_ALPHA_VAL_U] = 0x14,\n\t\t[PLL_OFF_USER_CTL] = 0x18,\n\t\t[PLL_OFF_USER_CTL_U] = 0x1c,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x20,\n\t\t[PLL_OFF_STATUS] = 0x28,\n\t\t[PLL_OFF_TEST_CTL] = 0x30,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x34,\n\t},\n};\n\nstatic struct clk_alpha_pll ipq_pll_huayra = {\n\t.offset = 0x0,\n\t.regs = ipq_pll_offsets[CLK_ALPHA_PLL_TYPE_HUAYRA],\n\t.flags = SUPPORTS_DYNAMIC_UPDATE,\n\t.clkr = {\n\t\t.enable_reg = 0x0,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"a53pll\",\n\t\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t\t.fw_name = \"xo\",\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_alpha_pll_huayra_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_alpha_pll ipq_pll_stromer_plus = {\n\t.offset = 0x0,\n\t.regs = ipq_pll_offsets[CLK_ALPHA_PLL_TYPE_STROMER_PLUS],\n\t.flags = SUPPORTS_DYNAMIC_UPDATE,\n\t.clkr = {\n\t\t.enable_reg = 0x0,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"a53pll\",\n\t\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t\t.fw_name = \"xo\",\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_alpha_pll_stromer_plus_ops,\n\t\t},\n\t},\n};\n\nstatic const struct alpha_pll_config ipq5332_pll_config = {\n\t.l = 0x2d,\n\t.config_ctl_val = 0x4001075b,\n\t.config_ctl_hi_val = 0x304,\n\t.main_output_mask = BIT(0),\n\t.aux_output_mask = BIT(1),\n\t.early_output_mask = BIT(3),\n\t.alpha_en_mask = BIT(24),\n\t.status_val = 0x3,\n\t.status_mask = GENMASK(10, 8),\n\t.lock_det = BIT(2),\n\t.test_ctl_hi_val = 0x00400003,\n};\n\nstatic const struct alpha_pll_config ipq6018_pll_config = {\n\t.l = 0x37,\n\t.config_ctl_val = 0x240d4828,\n\t.config_ctl_hi_val = 0x6,\n\t.early_output_mask = BIT(3),\n\t.aux2_output_mask = BIT(2),\n\t.aux_output_mask = BIT(1),\n\t.main_output_mask = BIT(0),\n\t.test_ctl_val = 0x1c0000C0,\n\t.test_ctl_hi_val = 0x4000,\n};\n\nstatic const struct alpha_pll_config ipq8074_pll_config = {\n\t.l = 0x48,\n\t.config_ctl_val = 0x200d4828,\n\t.config_ctl_hi_val = 0x6,\n\t.early_output_mask = BIT(3),\n\t.aux2_output_mask = BIT(2),\n\t.aux_output_mask = BIT(1),\n\t.main_output_mask = BIT(0),\n\t.test_ctl_val = 0x1c000000,\n\t.test_ctl_hi_val = 0x4000,\n};\n\nstatic const struct alpha_pll_config ipq9574_pll_config = {\n\t.l = 0x3b,\n\t.config_ctl_val = 0x200d4828,\n\t.config_ctl_hi_val = 0x6,\n\t.early_output_mask = BIT(3),\n\t.aux2_output_mask = BIT(2),\n\t.aux_output_mask = BIT(1),\n\t.main_output_mask = BIT(0),\n\t.test_ctl_val = 0x0,\n\t.test_ctl_hi_val = 0x4000,\n};\n\nstruct apss_pll_data {\n\tint pll_type;\n\tstruct clk_alpha_pll *pll;\n\tconst struct alpha_pll_config *pll_config;\n};\n\nstatic struct apss_pll_data ipq5332_pll_data = {\n\t.pll_type = CLK_ALPHA_PLL_TYPE_STROMER_PLUS,\n\t.pll = &ipq_pll_stromer_plus,\n\t.pll_config = &ipq5332_pll_config,\n};\n\nstatic struct apss_pll_data ipq8074_pll_data = {\n\t.pll_type = CLK_ALPHA_PLL_TYPE_HUAYRA,\n\t.pll = &ipq_pll_huayra,\n\t.pll_config = &ipq8074_pll_config,\n};\n\nstatic struct apss_pll_data ipq6018_pll_data = {\n\t.pll_type = CLK_ALPHA_PLL_TYPE_HUAYRA,\n\t.pll = &ipq_pll_huayra,\n\t.pll_config = &ipq6018_pll_config,\n};\n\nstatic struct apss_pll_data ipq9574_pll_data = {\n\t.pll_type = CLK_ALPHA_PLL_TYPE_HUAYRA,\n\t.pll = &ipq_pll_huayra,\n\t.pll_config = &ipq9574_pll_config,\n};\n\nstatic const struct regmap_config ipq_pll_regmap_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= 0x40,\n\t.fast_io\t\t= true,\n};\n\nstatic int apss_ipq_pll_probe(struct platform_device *pdev)\n{\n\tconst struct apss_pll_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tint ret;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio(dev, base, &ipq_pll_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\tif (data->pll_type == CLK_ALPHA_PLL_TYPE_HUAYRA)\n\t\tclk_alpha_pll_configure(data->pll, regmap, data->pll_config);\n\telse if (data->pll_type == CLK_ALPHA_PLL_TYPE_STROMER_PLUS)\n\t\tclk_stromer_pll_configure(data->pll, regmap, data->pll_config);\n\n\tret = devm_clk_register_regmap(dev, &data->pll->clkr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,\n\t\t\t\t\t   &data->pll->clkr.hw);\n}\n\nstatic const struct of_device_id apss_ipq_pll_match_table[] = {\n\t{ .compatible = \"qcom,ipq5332-a53pll\", .data = &ipq5332_pll_data },\n\t{ .compatible = \"qcom,ipq6018-a53pll\", .data = &ipq6018_pll_data },\n\t{ .compatible = \"qcom,ipq8074-a53pll\", .data = &ipq8074_pll_data },\n\t{ .compatible = \"qcom,ipq9574-a73pll\", .data = &ipq9574_pll_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, apss_ipq_pll_match_table);\n\nstatic struct platform_driver apss_ipq_pll_driver = {\n\t.probe = apss_ipq_pll_probe,\n\t.driver = {\n\t\t.name = \"qcom-ipq-apss-pll\",\n\t\t.of_match_table = apss_ipq_pll_match_table,\n\t},\n};\nmodule_platform_driver(apss_ipq_pll_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm technology Inc APSS ALPHA PLL Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}