{
  "module_name": "apcs-sdx55.c",
  "hash_id": "50411a983057fda467ed62fb1bbb8c92b37639755ce7b9a11160d7b318280f96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/apcs-sdx55.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/cpu.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"clk-regmap.h\"\n#include \"clk-regmap-mux-div.h\"\n\nstatic const u32 apcs_mux_clk_parent_map[] = { 0, 1, 5 };\n\nstatic const struct clk_parent_data pdata[] = {\n\t{ .fw_name = \"ref\" },\n\t{ .fw_name = \"aux\" },\n\t{ .fw_name = \"pll\" },\n};\n\n \nstatic int a7cc_notifier_cb(struct notifier_block *nb, unsigned long event,\n\t\t\t    void *data)\n{\n\tint ret = 0;\n\tstruct clk_regmap_mux_div *md = container_of(nb,\n\t\t\t\t\t\t     struct clk_regmap_mux_div,\n\t\t\t\t\t\t     clk_nb);\n\tif (event == PRE_RATE_CHANGE)\n\t\t \n\t\tret = mux_div_set_src_div(md, 1, 2);\n\n\treturn notifier_from_errno(ret);\n}\n\nstatic int qcom_apcs_sdx55_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device *parent = dev->parent;\n\tstruct device *cpu_dev;\n\tstruct clk_regmap_mux_div *a7cc;\n\tstruct regmap *regmap;\n\tstruct clk_init_data init = { };\n\tint ret;\n\n\tregmap = dev_get_regmap(parent, NULL);\n\tif (!regmap) {\n\t\tdev_err(dev, \"Failed to get parent regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ta7cc = devm_kzalloc(dev, sizeof(*a7cc), GFP_KERNEL);\n\tif (!a7cc)\n\t\treturn -ENOMEM;\n\n\tinit.name = \"a7mux\";\n\tinit.parent_data = pdata;\n\tinit.num_parents = ARRAY_SIZE(pdata);\n\tinit.ops = &clk_regmap_mux_div_ops;\n\n\ta7cc->clkr.hw.init = &init;\n\ta7cc->clkr.regmap = regmap;\n\ta7cc->reg_offset = 0x8;\n\ta7cc->hid_width = 5;\n\ta7cc->hid_shift = 0;\n\ta7cc->src_width = 3;\n\ta7cc->src_shift = 8;\n\ta7cc->parent_map = apcs_mux_clk_parent_map;\n\n\ta7cc->pclk = devm_clk_get(parent, \"pll\");\n\tif (IS_ERR(a7cc->pclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(a7cc->pclk),\n\t\t\t\t     \"Failed to get PLL clk\\n\");\n\n\ta7cc->clk_nb.notifier_call = a7cc_notifier_cb;\n\tret = clk_notifier_register(a7cc->pclk, &a7cc->clk_nb);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to register clock notifier\\n\");\n\n\tret = devm_clk_register_regmap(dev, &a7cc->clkr);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"Failed to register regmap clock\\n\");\n\t\tgoto err;\n\t}\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,\n\t\t\t\t\t  &a7cc->clkr.hw);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"Failed to add clock provider\\n\");\n\t\tgoto err;\n\t}\n\n\tplatform_set_drvdata(pdev, a7cc);\n\n\t \n\tcpu_dev = get_cpu_device(0);\n\tdev_pm_domain_attach(cpu_dev, true);\n\n\treturn 0;\n\nerr:\n\tclk_notifier_unregister(a7cc->pclk, &a7cc->clk_nb);\n\treturn ret;\n}\n\nstatic void qcom_apcs_sdx55_clk_remove(struct platform_device *pdev)\n{\n\tstruct device *cpu_dev = get_cpu_device(0);\n\tstruct clk_regmap_mux_div *a7cc = platform_get_drvdata(pdev);\n\n\tclk_notifier_unregister(a7cc->pclk, &a7cc->clk_nb);\n\tdev_pm_domain_detach(cpu_dev, true);\n}\n\nstatic struct platform_driver qcom_apcs_sdx55_clk_driver = {\n\t.probe = qcom_apcs_sdx55_clk_probe,\n\t.remove_new = qcom_apcs_sdx55_clk_remove,\n\t.driver = {\n\t\t.name = \"qcom-sdx55-acps-clk\",\n\t},\n};\nmodule_platform_driver(qcom_apcs_sdx55_clk_driver);\n\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Qualcomm SDX55 APCS clock driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}