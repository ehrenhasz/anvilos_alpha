{
  "module_name": "lpass-gfm-sm8250.c",
  "hash_id": "aaa1cd451b12ecc053522f519313e0ae66d78fd23062d62d527b5ece2699e633",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/lpass-gfm-sm8250.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <dt-bindings/clock/qcom,sm8250-lpass-audiocc.h>\n#include <dt-bindings/clock/qcom,sm8250-lpass-aoncc.h>\n\nstruct lpass_gfm {\n\tstruct device *dev;\n\tvoid __iomem *base;\n};\n\nstruct clk_gfm {\n\tunsigned int mux_reg;\n\tunsigned int mux_mask;\n\tstruct clk_hw\thw;\n\tstruct lpass_gfm *priv;\n\tvoid __iomem *gfm_mux;\n};\n\n#define to_clk_gfm(_hw) container_of(_hw, struct clk_gfm, hw)\n\nstatic u8 clk_gfm_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_gfm *clk = to_clk_gfm(hw);\n\n\treturn readl(clk->gfm_mux) & clk->mux_mask;\n}\n\nstatic int clk_gfm_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_gfm *clk = to_clk_gfm(hw);\n\tunsigned int val;\n\n\tval = readl(clk->gfm_mux);\n\n\tif (index)\n\t\tval |= clk->mux_mask;\n\telse\n\t\tval &= ~clk->mux_mask;\n\n\n\twritel(val, clk->gfm_mux);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_gfm_ops = {\n\t.get_parent = clk_gfm_get_parent,\n\t.set_parent = clk_gfm_set_parent,\n\t.determine_rate = __clk_mux_determine_rate,\n};\n\nstatic struct clk_gfm lpass_gfm_va_mclk = {\n\t.mux_reg = 0x20000,\n\t.mux_mask = BIT(0),\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"VA_MCLK\",\n\t\t.ops = &clk_gfm_ops,\n\t\t.flags = CLK_SET_RATE_PARENT | CLK_OPS_PARENT_ENABLE,\n\t\t.num_parents = 2,\n\t\t.parent_data = (const struct clk_parent_data[]){\n\t\t\t{\n\t\t\t\t.index = 0,\n\t\t\t\t.fw_name = \"LPASS_CLK_ID_TX_CORE_MCLK\",\n\t\t\t}, {\n\t\t\t\t.index = 1,\n\t\t\t\t.fw_name = \"LPASS_CLK_ID_VA_CORE_MCLK\",\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic struct clk_gfm lpass_gfm_tx_npl = {\n\t.mux_reg = 0x20000,\n\t.mux_mask = BIT(0),\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"TX_NPL\",\n\t\t.ops = &clk_gfm_ops,\n\t\t.flags = CLK_SET_RATE_PARENT | CLK_OPS_PARENT_ENABLE,\n\t\t.parent_data = (const struct clk_parent_data[]){\n\t\t\t{\n\t\t\t\t.index = 0,\n\t\t\t\t.fw_name = \"LPASS_CLK_ID_TX_CORE_NPL_MCLK\",\n\t\t\t}, {\n\t\t\t\t.index = 1,\n\t\t\t\t.fw_name = \"LPASS_CLK_ID_VA_CORE_2X_MCLK\",\n\t\t\t},\n\t\t},\n\t\t.num_parents = 2,\n\t},\n};\n\nstatic struct clk_gfm lpass_gfm_wsa_mclk = {\n\t.mux_reg = 0x220d8,\n\t.mux_mask = BIT(0),\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"WSA_MCLK\",\n\t\t.ops = &clk_gfm_ops,\n\t\t.flags = CLK_SET_RATE_PARENT | CLK_OPS_PARENT_ENABLE,\n\t\t.parent_data = (const struct clk_parent_data[]){\n\t\t\t{\n\t\t\t\t.index = 0,\n\t\t\t\t.fw_name = \"LPASS_CLK_ID_TX_CORE_MCLK\",\n\t\t\t}, {\n\t\t\t\t.index = 1,\n\t\t\t\t.fw_name = \"LPASS_CLK_ID_WSA_CORE_MCLK\",\n\t\t\t},\n\t\t},\n\t\t.num_parents = 2,\n\t},\n};\n\nstatic struct clk_gfm lpass_gfm_wsa_npl = {\n\t.mux_reg = 0x220d8,\n\t.mux_mask = BIT(0),\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"WSA_NPL\",\n\t\t.ops = &clk_gfm_ops,\n\t\t.flags = CLK_SET_RATE_PARENT | CLK_OPS_PARENT_ENABLE,\n\t\t.parent_data = (const struct clk_parent_data[]){\n\t\t\t{\n\t\t\t\t.index = 0,\n\t\t\t\t.fw_name = \"LPASS_CLK_ID_TX_CORE_NPL_MCLK\",\n\t\t\t}, {\n\t\t\t\t.index = 1,\n\t\t\t\t.fw_name = \"LPASS_CLK_ID_WSA_CORE_NPL_MCLK\",\n\t\t\t},\n\t\t},\n\t\t.num_parents = 2,\n\t},\n};\n\nstatic struct clk_gfm lpass_gfm_rx_mclk_mclk2 = {\n\t.mux_reg = 0x240d8,\n\t.mux_mask = BIT(0),\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"RX_MCLK_MCLK2\",\n\t\t.ops = &clk_gfm_ops,\n\t\t.flags = CLK_SET_RATE_PARENT | CLK_OPS_PARENT_ENABLE,\n\t\t.parent_data = (const struct clk_parent_data[]){\n\t\t\t{\n\t\t\t\t.index = 0,\n\t\t\t\t.fw_name = \"LPASS_CLK_ID_TX_CORE_MCLK\",\n\t\t\t}, {\n\t\t\t\t.index = 1,\n\t\t\t\t.fw_name = \"LPASS_CLK_ID_RX_CORE_MCLK\",\n\t\t\t},\n\t\t},\n\t\t.num_parents = 2,\n\t},\n};\n\nstatic struct clk_gfm lpass_gfm_rx_npl = {\n\t.mux_reg = 0x240d8,\n\t.mux_mask = BIT(0),\n\t.hw.init = &(struct clk_init_data) {\n\t\t.name = \"RX_NPL\",\n\t\t.ops = &clk_gfm_ops,\n\t\t.flags = CLK_SET_RATE_PARENT | CLK_OPS_PARENT_ENABLE,\n\t\t.parent_data = (const struct clk_parent_data[]){\n\t\t\t{\n\t\t\t\t.index = 0,\n\t\t\t\t.fw_name = \"LPASS_CLK_ID_TX_CORE_NPL_MCLK\",\n\t\t\t}, {\n\t\t\t\t.index = 1,\n\t\t\t\t.fw_name = \"LPASS_CLK_ID_RX_CORE_NPL_MCLK\",\n\t\t\t},\n\t\t},\n\t\t.num_parents = 2,\n\t},\n};\n\nstatic struct clk_gfm *aoncc_gfm_clks[] = {\n\t[LPASS_CDC_VA_MCLK]\t\t= &lpass_gfm_va_mclk,\n\t[LPASS_CDC_TX_NPL]\t\t= &lpass_gfm_tx_npl,\n};\n\nstatic struct clk_hw_onecell_data aoncc_hw_onecell_data = {\n\t.hws = {\n\t\t[LPASS_CDC_VA_MCLK]\t= &lpass_gfm_va_mclk.hw,\n\t\t[LPASS_CDC_TX_NPL]\t= &lpass_gfm_tx_npl.hw,\n\t},\n\t.num = ARRAY_SIZE(aoncc_gfm_clks),\n};\n\nstatic struct clk_gfm *audiocc_gfm_clks[] = {\n\t[LPASS_CDC_WSA_NPL]\t\t= &lpass_gfm_wsa_npl,\n\t[LPASS_CDC_WSA_MCLK]\t\t= &lpass_gfm_wsa_mclk,\n\t[LPASS_CDC_RX_NPL]\t\t= &lpass_gfm_rx_npl,\n\t[LPASS_CDC_RX_MCLK_MCLK2]\t= &lpass_gfm_rx_mclk_mclk2,\n};\n\nstatic struct clk_hw_onecell_data audiocc_hw_onecell_data = {\n\t.hws = {\n\t\t[LPASS_CDC_WSA_NPL]\t= &lpass_gfm_wsa_npl.hw,\n\t\t[LPASS_CDC_WSA_MCLK]\t= &lpass_gfm_wsa_mclk.hw,\n\t\t[LPASS_CDC_RX_NPL]\t= &lpass_gfm_rx_npl.hw,\n\t\t[LPASS_CDC_RX_MCLK_MCLK2] = &lpass_gfm_rx_mclk_mclk2.hw,\n\t},\n\t.num = ARRAY_SIZE(audiocc_gfm_clks),\n};\n\nstruct lpass_gfm_data {\n\tstruct clk_hw_onecell_data *onecell_data;\n\tstruct clk_gfm **gfm_clks;\n};\n\nstatic struct lpass_gfm_data audiocc_data = {\n\t.onecell_data = &audiocc_hw_onecell_data,\n\t.gfm_clks = audiocc_gfm_clks,\n};\n\nstatic struct lpass_gfm_data aoncc_data = {\n\t.onecell_data = &aoncc_hw_onecell_data,\n\t.gfm_clks = aoncc_gfm_clks,\n};\n\nstatic int lpass_gfm_clk_driver_probe(struct platform_device *pdev)\n{\n\tconst struct lpass_gfm_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct clk_gfm *gfm;\n\tstruct lpass_gfm *cc;\n\tint err, i;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tcc = devm_kzalloc(dev, sizeof(*cc), GFP_KERNEL);\n\tif (!cc)\n\t\treturn -ENOMEM;\n\n\tcc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(cc->base))\n\t\treturn PTR_ERR(cc->base);\n\n\terr = devm_pm_runtime_enable(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_pm_clk_create(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = of_pm_clk_add_clks(dev);\n\tif (err < 0) {\n\t\tdev_dbg(dev, \"Failed to get lpass core voting clocks\\n\");\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < data->onecell_data->num; i++) {\n\t\tif (!data->gfm_clks[i])\n\t\t\tcontinue;\n\n\t\tgfm = data->gfm_clks[i];\n\t\tgfm->priv = cc;\n\t\tgfm->gfm_mux = cc->base;\n\t\tgfm->gfm_mux = gfm->gfm_mux + data->gfm_clks[i]->mux_reg;\n\n\t\terr = devm_clk_hw_register(dev, &data->gfm_clks[i]->hw);\n\t\tif (err)\n\t\t\treturn err;\n\n\t}\n\n\terr = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get,\n\t\t\t\t\t  data->onecell_data);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id lpass_gfm_clk_match_table[] = {\n\t{\n\t\t.compatible = \"qcom,sm8250-lpass-aoncc\",\n\t\t.data = &aoncc_data,\n\t},\n\t{\n\t\t.compatible = \"qcom,sm8250-lpass-audiocc\",\n\t\t.data = &audiocc_data,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lpass_gfm_clk_match_table);\n\nstatic const struct dev_pm_ops lpass_gfm_pm_ops = {\n\tSET_RUNTIME_PM_OPS(pm_clk_suspend, pm_clk_resume, NULL)\n};\n\nstatic struct platform_driver lpass_gfm_clk_driver = {\n\t.probe\t\t= lpass_gfm_clk_driver_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"lpass-gfm-clk\",\n\t\t.of_match_table = lpass_gfm_clk_match_table,\n\t\t.pm = &lpass_gfm_pm_ops,\n\t},\n};\nmodule_platform_driver(lpass_gfm_clk_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}