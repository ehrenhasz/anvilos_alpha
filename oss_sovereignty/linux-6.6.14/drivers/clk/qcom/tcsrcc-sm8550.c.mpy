{
  "module_name": "tcsrcc-sm8550.c",
  "hash_id": "4f27487dc7135149ffd4b94d525b6e9a948f1cac4f47fefa8afb8fca2bc83fd1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/tcsrcc-sm8550.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/clock/qcom,sm8550-tcsr.h>\n\n#include \"clk-alpha-pll.h\"\n#include \"clk-branch.h\"\n#include \"clk-pll.h\"\n#include \"clk-rcg.h\"\n#include \"clk-regmap.h\"\n#include \"clk-regmap-divider.h\"\n#include \"clk-regmap-mux.h\"\n#include \"common.h\"\n#include \"reset.h\"\n\nenum {\n\tDT_BI_TCXO_PAD,\n};\n\nstatic struct clk_branch tcsr_pcie_0_clkref_en = {\n\t.halt_reg = 0x15100,\n\t.halt_check = BRANCH_HALT_SKIP,\n\t.clkr = {\n\t\t.enable_reg = 0x15100,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"tcsr_pcie_0_clkref_en\",\n\t\t\t.parent_data = &(const struct clk_parent_data){\n\t\t\t\t.index = DT_BI_TCXO_PAD,\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch tcsr_pcie_1_clkref_en = {\n\t.halt_reg = 0x15114,\n\t.halt_check = BRANCH_HALT_SKIP,\n\t.clkr = {\n\t\t.enable_reg = 0x15114,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"tcsr_pcie_1_clkref_en\",\n\t\t\t.parent_data = &(const struct clk_parent_data){\n\t\t\t\t.index = DT_BI_TCXO_PAD,\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch tcsr_ufs_clkref_en = {\n\t.halt_reg = 0x15110,\n\t.halt_check = BRANCH_HALT_SKIP,\n\t.clkr = {\n\t\t.enable_reg = 0x15110,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"tcsr_ufs_clkref_en\",\n\t\t\t.parent_data = &(const struct clk_parent_data){\n\t\t\t\t.index = DT_BI_TCXO_PAD,\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch tcsr_ufs_pad_clkref_en = {\n\t.halt_reg = 0x15104,\n\t.halt_check = BRANCH_HALT_SKIP,\n\t.clkr = {\n\t\t.enable_reg = 0x15104,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"tcsr_ufs_pad_clkref_en\",\n\t\t\t.parent_data = &(const struct clk_parent_data){\n\t\t\t\t.index = DT_BI_TCXO_PAD,\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch tcsr_usb2_clkref_en = {\n\t.halt_reg = 0x15118,\n\t.halt_check = BRANCH_HALT_SKIP,\n\t.clkr = {\n\t\t.enable_reg = 0x15118,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"tcsr_usb2_clkref_en\",\n\t\t\t.parent_data = &(const struct clk_parent_data){\n\t\t\t\t.index = DT_BI_TCXO_PAD,\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch tcsr_usb3_clkref_en = {\n\t.halt_reg = 0x15108,\n\t.halt_check = BRANCH_HALT_SKIP,\n\t.clkr = {\n\t\t.enable_reg = 0x15108,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"tcsr_usb3_clkref_en\",\n\t\t\t.parent_data = &(const struct clk_parent_data){\n\t\t\t\t.index = DT_BI_TCXO_PAD,\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_regmap *tcsr_cc_sm8550_clocks[] = {\n\t[TCSR_PCIE_0_CLKREF_EN] = &tcsr_pcie_0_clkref_en.clkr,\n\t[TCSR_PCIE_1_CLKREF_EN] = &tcsr_pcie_1_clkref_en.clkr,\n\t[TCSR_UFS_CLKREF_EN] = &tcsr_ufs_clkref_en.clkr,\n\t[TCSR_UFS_PAD_CLKREF_EN] = &tcsr_ufs_pad_clkref_en.clkr,\n\t[TCSR_USB2_CLKREF_EN] = &tcsr_usb2_clkref_en.clkr,\n\t[TCSR_USB3_CLKREF_EN] = &tcsr_usb3_clkref_en.clkr,\n};\n\nstatic const struct regmap_config tcsr_cc_sm8550_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = 0x2f000,\n\t.fast_io = true,\n};\n\nstatic const struct qcom_cc_desc tcsr_cc_sm8550_desc = {\n\t.config = &tcsr_cc_sm8550_regmap_config,\n\t.clks = tcsr_cc_sm8550_clocks,\n\t.num_clks = ARRAY_SIZE(tcsr_cc_sm8550_clocks),\n};\n\nstatic const struct of_device_id tcsr_cc_sm8550_match_table[] = {\n\t{ .compatible = \"qcom,sm8550-tcsr\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tcsr_cc_sm8550_match_table);\n\nstatic int tcsr_cc_sm8550_probe(struct platform_device *pdev)\n{\n\tstruct regmap *regmap;\n\n\tregmap = qcom_cc_map(pdev, &tcsr_cc_sm8550_desc);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn qcom_cc_really_probe(pdev, &tcsr_cc_sm8550_desc, regmap);\n}\n\nstatic struct platform_driver tcsr_cc_sm8550_driver = {\n\t.probe = tcsr_cc_sm8550_probe,\n\t.driver = {\n\t\t.name = \"tcsr_cc-sm8550\",\n\t\t.of_match_table = tcsr_cc_sm8550_match_table,\n\t},\n};\n\nstatic int __init tcsr_cc_sm8550_init(void)\n{\n\treturn platform_driver_register(&tcsr_cc_sm8550_driver);\n}\nsubsys_initcall(tcsr_cc_sm8550_init);\n\nstatic void __exit tcsr_cc_sm8550_exit(void)\n{\n\tplatform_driver_unregister(&tcsr_cc_sm8550_driver);\n}\nmodule_exit(tcsr_cc_sm8550_exit);\n\nMODULE_DESCRIPTION(\"QTI TCSRCC SM8550 Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}