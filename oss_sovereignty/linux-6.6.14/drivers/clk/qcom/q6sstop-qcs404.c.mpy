{
  "module_name": "q6sstop-qcs404.c",
  "hash_id": "df256d3c00dc4c68c5cb7ca9d0bf695b8deba390925384e885d9a325a09a9db9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/q6sstop-qcs404.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/clock/qcom,q6sstopcc-qcs404.h>\n\n#include \"clk-regmap.h\"\n#include \"clk-branch.h\"\n#include \"common.h\"\n#include \"reset.h\"\n\nstatic struct clk_branch lcc_ahbfabric_cbc_clk = {\n\t.halt_reg = 0x1b004,\n\t.halt_check = BRANCH_HALT,\n\t.clkr = {\n\t\t.enable_reg = 0x1b004,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"lcc_ahbfabric_cbc_clk\",\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch lcc_q6ss_ahbs_cbc_clk = {\n\t.halt_reg = 0x22000,\n\t.halt_check = BRANCH_VOTED,\n\t.clkr = {\n\t\t.enable_reg = 0x22000,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"lcc_q6ss_ahbs_cbc_clk\",\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch lcc_q6ss_tcm_slave_cbc_clk = {\n\t.halt_reg = 0x1c000,\n\t.halt_check = BRANCH_VOTED,\n\t.clkr = {\n\t\t.enable_reg = 0x1c000,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"lcc_q6ss_tcm_slave_cbc_clk\",\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch lcc_q6ss_ahbm_cbc_clk = {\n\t.halt_reg = 0x22004,\n\t.halt_check = BRANCH_VOTED,\n\t.clkr = {\n\t\t.enable_reg = 0x22004,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"lcc_q6ss_ahbm_cbc_clk\",\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch lcc_q6ss_axim_cbc_clk = {\n\t.halt_reg = 0x1c004,\n\t.halt_check = BRANCH_VOTED,\n\t.clkr = {\n\t\t.enable_reg = 0x1c004,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"lcc_q6ss_axim_cbc_clk\",\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch lcc_q6ss_bcr_sleep_clk = {\n\t.halt_reg = 0x6004,\n\t.halt_check = BRANCH_VOTED,\n\t.clkr = {\n\t\t.enable_reg = 0x6004,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"lcc_q6ss_bcr_sleep_clk\",\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\n \nstatic struct clk_branch tcsr_lcc_csr_cbcr_clk = {\n\t.halt_reg = 0x8008,\n\t.halt_check = BRANCH_VOTED,\n\t.clkr = {\n\t\t.enable_reg = 0x8008,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"tcsr_lcc_csr_cbcr_clk\",\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct regmap_config q6sstop_regmap_config = {\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n\t.fast_io\t= true,\n};\n\nstatic struct clk_regmap *q6sstop_qcs404_clocks[] = {\n\t[LCC_AHBFABRIC_CBC_CLK] = &lcc_ahbfabric_cbc_clk.clkr,\n\t[LCC_Q6SS_AHBS_CBC_CLK] = &lcc_q6ss_ahbs_cbc_clk.clkr,\n\t[LCC_Q6SS_TCM_SLAVE_CBC_CLK] = &lcc_q6ss_tcm_slave_cbc_clk.clkr,\n\t[LCC_Q6SS_AHBM_CBC_CLK] = &lcc_q6ss_ahbm_cbc_clk.clkr,\n\t[LCC_Q6SS_AXIM_CBC_CLK] = &lcc_q6ss_axim_cbc_clk.clkr,\n\t[LCC_Q6SS_BCR_SLEEP_CLK] = &lcc_q6ss_bcr_sleep_clk.clkr,\n};\n\nstatic const struct qcom_reset_map q6sstop_qcs404_resets[] = {\n\t[Q6SSTOP_BCR_RESET] = { 0x6000 },\n};\n\nstatic const struct qcom_cc_desc q6sstop_qcs404_desc = {\n\t.config = &q6sstop_regmap_config,\n\t.clks = q6sstop_qcs404_clocks,\n\t.num_clks = ARRAY_SIZE(q6sstop_qcs404_clocks),\n\t.resets = q6sstop_qcs404_resets,\n\t.num_resets = ARRAY_SIZE(q6sstop_qcs404_resets),\n};\n\nstatic struct clk_regmap *tcsr_qcs404_clocks[] = {\n\t[TCSR_Q6SS_LCC_CBCR_CLK] = &tcsr_lcc_csr_cbcr_clk.clkr,\n};\n\nstatic const struct qcom_cc_desc tcsr_qcs404_desc = {\n\t.config = &q6sstop_regmap_config,\n\t.clks = tcsr_qcs404_clocks,\n\t.num_clks = ARRAY_SIZE(tcsr_qcs404_clocks),\n};\n\nstatic const struct of_device_id q6sstopcc_qcs404_match_table[] = {\n\t{ .compatible = \"qcom,qcs404-q6sstopcc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, q6sstopcc_qcs404_match_table);\n\nstatic int q6sstopcc_qcs404_probe(struct platform_device *pdev)\n{\n\tconst struct qcom_cc_desc *desc;\n\tint ret;\n\n\tret = devm_pm_runtime_enable(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_pm_clk_create(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_clk_add(&pdev->dev, NULL);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to acquire iface clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tq6sstop_regmap_config.name = \"q6sstop_tcsr\";\n\tdesc = &tcsr_qcs404_desc;\n\n\tret = qcom_cc_probe_by_index(pdev, 1, desc);\n\tif (ret)\n\t\tgoto err_put_rpm;\n\n\tq6sstop_regmap_config.name = \"q6sstop_cc\";\n\tdesc = &q6sstop_qcs404_desc;\n\n\tret = qcom_cc_probe_by_index(pdev, 0, desc);\n\tif (ret)\n\t\tgoto err_put_rpm;\n\n\tpm_runtime_put(&pdev->dev);\n\n\treturn 0;\n\nerr_put_rpm:\n\tpm_runtime_put_sync(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops q6sstopcc_pm_ops = {\n\tSET_RUNTIME_PM_OPS(pm_clk_suspend, pm_clk_resume, NULL)\n};\n\nstatic struct platform_driver q6sstopcc_qcs404_driver = {\n\t.probe\t\t= q6sstopcc_qcs404_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"qcs404-q6sstopcc\",\n\t\t.of_match_table = q6sstopcc_qcs404_match_table,\n\t\t.pm = &q6sstopcc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(q6sstopcc_qcs404_driver);\n\nMODULE_DESCRIPTION(\"QTI QCS404 Q6SSTOP Clock Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}