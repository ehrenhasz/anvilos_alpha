{
  "module_name": "apcs-msm8916.c",
  "hash_id": "4d0fa3c331a033fd516a7068a00c9be7b1f75359fe93576cbc6d190de4a7f1f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/apcs-msm8916.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include \"clk-regmap.h\"\n#include \"clk-regmap-mux-div.h\"\n\nstatic const u32 gpll0_a53cc_map[] = { 4, 5 };\n\nstatic const struct clk_parent_data pdata[] = {\n\t{ .fw_name = \"aux\", .name = \"gpll0_vote\", },\n\t{ .fw_name = \"pll\", .name = \"a53pll\", },\n};\n\n \nstatic int a53cc_notifier_cb(struct notifier_block *nb, unsigned long event,\n\t\t\t     void *data)\n{\n\tint ret = 0;\n\tstruct clk_regmap_mux_div *md = container_of(nb,\n\t\t\t\t\t\t     struct clk_regmap_mux_div,\n\t\t\t\t\t\t     clk_nb);\n\tif (event == PRE_RATE_CHANGE)\n\t\t \n\t\tret = mux_div_set_src_div(md, 4, 3);\n\n\treturn notifier_from_errno(ret);\n}\n\nstatic int qcom_apcs_msm8916_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device *parent = dev->parent;\n\tstruct device_node *np = parent->of_node;\n\tstruct clk_regmap_mux_div *a53cc;\n\tstruct regmap *regmap;\n\tstruct clk_init_data init = { };\n\tint ret = -ENODEV;\n\n\tregmap = dev_get_regmap(parent, NULL);\n\tif (!regmap) {\n\t\tdev_err(dev, \"failed to get regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ta53cc = devm_kzalloc(dev, sizeof(*a53cc), GFP_KERNEL);\n\tif (!a53cc)\n\t\treturn -ENOMEM;\n\n\t \n\tinit.name = devm_kasprintf(dev, GFP_KERNEL, \"a53mux%s\",\n\t\t\t\t   strchrnul(np->full_name, '@'));\n\tif (!init.name)\n\t\treturn -ENOMEM;\n\n\tinit.parent_data = pdata;\n\tinit.num_parents = ARRAY_SIZE(pdata);\n\tinit.ops = &clk_regmap_mux_div_ops;\n\tinit.flags = CLK_IS_CRITICAL | CLK_SET_RATE_PARENT;\n\n\ta53cc->clkr.hw.init = &init;\n\ta53cc->clkr.regmap = regmap;\n\ta53cc->reg_offset = 0x50;\n\ta53cc->hid_width = 5;\n\ta53cc->hid_shift = 0;\n\ta53cc->src_width = 3;\n\ta53cc->src_shift = 8;\n\ta53cc->parent_map = gpll0_a53cc_map;\n\n\ta53cc->pclk = devm_clk_get(parent, NULL);\n\tif (IS_ERR(a53cc->pclk)) {\n\t\tret = PTR_ERR(a53cc->pclk);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"failed to get clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ta53cc->clk_nb.notifier_call = a53cc_notifier_cb;\n\tret = clk_notifier_register(a53cc->pclk, &a53cc->clk_nb);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register clock notifier: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_clk_register_regmap(dev, &a53cc->clkr);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register regmap clock: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,\n\t\t\t\t\t  &a53cc->clkr.hw);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add clock provider: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tplatform_set_drvdata(pdev, a53cc);\n\n\treturn 0;\n\nerr:\n\tclk_notifier_unregister(a53cc->pclk, &a53cc->clk_nb);\n\treturn ret;\n}\n\nstatic void qcom_apcs_msm8916_clk_remove(struct platform_device *pdev)\n{\n\tstruct clk_regmap_mux_div *a53cc = platform_get_drvdata(pdev);\n\n\tclk_notifier_unregister(a53cc->pclk, &a53cc->clk_nb);\n}\n\nstatic struct platform_driver qcom_apcs_msm8916_clk_driver = {\n\t.probe = qcom_apcs_msm8916_clk_probe,\n\t.remove_new = qcom_apcs_msm8916_clk_remove,\n\t.driver = {\n\t\t.name = \"qcom-apcs-msm8916-clk\",\n\t},\n};\nmodule_platform_driver(qcom_apcs_msm8916_clk_driver);\n\nMODULE_AUTHOR(\"Georgi Djakov <georgi.djakov@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Qualcomm MSM8916 APCS clock driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}