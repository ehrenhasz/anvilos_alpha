{
  "module_name": "clk-spmi-pmic-div.c",
  "hash_id": "05dfeba0091c100763e2c5be7ea13317e333dfaec31245919f950211e3c8da9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/clk-spmi-pmic-div.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define REG_DIV_CTL1\t\t\t0x43\n#define DIV_CTL1_DIV_FACTOR_MASK\tGENMASK(2, 0)\n\n#define REG_EN_CTL\t\t\t0x46\n#define REG_EN_MASK\t\t\tBIT(7)\n\nstruct clkdiv {\n\tstruct regmap\t\t*regmap;\n\tu16\t\t\tbase;\n\tspinlock_t\t\tlock;\n\n\tstruct clk_hw\t\thw;\n\tunsigned int\t\tcxo_period_ns;\n};\n\nstatic inline struct clkdiv *to_clkdiv(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct clkdiv, hw);\n}\n\nstatic inline unsigned int div_factor_to_div(unsigned int div_factor)\n{\n\tif (!div_factor)\n\t\tdiv_factor = 1;\n\n\treturn 1 << (div_factor - 1);\n}\n\nstatic inline unsigned int div_to_div_factor(unsigned int div)\n{\n\treturn min(ilog2(div) + 1, 7);\n}\n\nstatic bool is_spmi_pmic_clkdiv_enabled(struct clkdiv *clkdiv)\n{\n\tunsigned int val = 0;\n\n\tregmap_read(clkdiv->regmap, clkdiv->base + REG_EN_CTL, &val);\n\n\treturn val & REG_EN_MASK;\n}\n\nstatic int\n__spmi_pmic_clkdiv_set_enable_state(struct clkdiv *clkdiv, bool enable,\n\t\t\t\t    unsigned int div_factor)\n{\n\tint ret;\n\tunsigned int ns = clkdiv->cxo_period_ns;\n\tunsigned int div = div_factor_to_div(div_factor);\n\n\tret = regmap_update_bits(clkdiv->regmap, clkdiv->base + REG_EN_CTL,\n\t\t\t\t REG_EN_MASK, enable ? REG_EN_MASK : 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (enable)\n\t\tndelay((2 + 3 * div) * ns);\n\telse\n\t\tndelay(3 * div * ns);\n\n\treturn 0;\n}\n\nstatic int spmi_pmic_clkdiv_set_enable_state(struct clkdiv *clkdiv, bool enable)\n{\n\tunsigned int div_factor;\n\n\tregmap_read(clkdiv->regmap, clkdiv->base + REG_DIV_CTL1, &div_factor);\n\tdiv_factor &= DIV_CTL1_DIV_FACTOR_MASK;\n\n\treturn __spmi_pmic_clkdiv_set_enable_state(clkdiv, enable, div_factor);\n}\n\nstatic int clk_spmi_pmic_div_enable(struct clk_hw *hw)\n{\n\tstruct clkdiv *clkdiv = to_clkdiv(hw);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&clkdiv->lock, flags);\n\tret = spmi_pmic_clkdiv_set_enable_state(clkdiv, true);\n\tspin_unlock_irqrestore(&clkdiv->lock, flags);\n\n\treturn ret;\n}\n\nstatic void clk_spmi_pmic_div_disable(struct clk_hw *hw)\n{\n\tstruct clkdiv *clkdiv = to_clkdiv(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&clkdiv->lock, flags);\n\tspmi_pmic_clkdiv_set_enable_state(clkdiv, false);\n\tspin_unlock_irqrestore(&clkdiv->lock, flags);\n}\n\nstatic long clk_spmi_pmic_div_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t unsigned long *parent_rate)\n{\n\tunsigned int div, div_factor;\n\n\tdiv = DIV_ROUND_UP(*parent_rate, rate);\n\tdiv_factor = div_to_div_factor(div);\n\tdiv = div_factor_to_div(div_factor);\n\n\treturn *parent_rate / div;\n}\n\nstatic unsigned long\nclk_spmi_pmic_div_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct clkdiv *clkdiv = to_clkdiv(hw);\n\tunsigned int div_factor;\n\n\tregmap_read(clkdiv->regmap, clkdiv->base + REG_DIV_CTL1, &div_factor);\n\tdiv_factor &= DIV_CTL1_DIV_FACTOR_MASK;\n\n\treturn parent_rate / div_factor_to_div(div_factor);\n}\n\nstatic int clk_spmi_pmic_div_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct clkdiv *clkdiv = to_clkdiv(hw);\n\tunsigned int div_factor = div_to_div_factor(parent_rate / rate);\n\tunsigned long flags;\n\tbool enabled;\n\tint ret;\n\n\tspin_lock_irqsave(&clkdiv->lock, flags);\n\tenabled = is_spmi_pmic_clkdiv_enabled(clkdiv);\n\tif (enabled) {\n\t\tret = spmi_pmic_clkdiv_set_enable_state(clkdiv, false);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tret = regmap_update_bits(clkdiv->regmap, clkdiv->base + REG_DIV_CTL1,\n\t\t\t\t DIV_CTL1_DIV_FACTOR_MASK, div_factor);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (enabled)\n\t\tret = __spmi_pmic_clkdiv_set_enable_state(clkdiv, true,\n\t\t\t\t\t\t\t  div_factor);\n\nunlock:\n\tspin_unlock_irqrestore(&clkdiv->lock, flags);\n\n\treturn ret;\n}\n\nstatic const struct clk_ops clk_spmi_pmic_div_ops = {\n\t.enable = clk_spmi_pmic_div_enable,\n\t.disable = clk_spmi_pmic_div_disable,\n\t.set_rate = clk_spmi_pmic_div_set_rate,\n\t.recalc_rate = clk_spmi_pmic_div_recalc_rate,\n\t.round_rate = clk_spmi_pmic_div_round_rate,\n};\n\nstruct spmi_pmic_div_clk_cc {\n\tint\t\tnclks;\n\tstruct clkdiv\tclks[] __counted_by(nclks);\n};\n\nstatic struct clk_hw *\nspmi_pmic_div_clk_hw_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct spmi_pmic_div_clk_cc *cc = data;\n\tint idx = clkspec->args[0] - 1;  \n\n\tif (idx < 0 || idx >= cc->nclks) {\n\t\tpr_err(\"%s: index value %u is invalid; allowed range [1, %d]\\n\",\n\t\t       __func__, clkspec->args[0], cc->nclks);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &cc->clks[idx].hw;\n}\n\nstatic int spmi_pmic_clkdiv_probe(struct platform_device *pdev)\n{\n\tstruct spmi_pmic_div_clk_cc *cc;\n\tstruct clk_init_data init = {};\n\tstruct clkdiv *clkdiv;\n\tstruct clk *cxo;\n\tstruct regmap *regmap;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *of_node = dev->of_node;\n\tstruct clk_parent_data parent_data = { .index = 0, };\n\tint nclks, i, ret, cxo_hz;\n\tchar name[20];\n\tu32 start;\n\n\tret = of_property_read_u32(of_node, \"reg\", &start);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"reg property reading failed\\n\");\n\t\treturn ret;\n\t}\n\n\tregmap = dev_get_regmap(dev->parent, NULL);\n\tif (!regmap) {\n\t\tdev_err(dev, \"Couldn't get parent's regmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32(of_node, \"qcom,num-clkdivs\", &nclks);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"qcom,num-clkdivs property reading failed, ret=%d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (!nclks)\n\t\treturn -EINVAL;\n\n\tcc = devm_kzalloc(dev, struct_size(cc, clks, nclks), GFP_KERNEL);\n\tif (!cc)\n\t\treturn -ENOMEM;\n\tcc->nclks = nclks;\n\n\tcxo = clk_get(dev, \"xo\");\n\tif (IS_ERR(cxo)) {\n\t\tret = PTR_ERR(cxo);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"failed to get xo clock\\n\");\n\t\treturn ret;\n\t}\n\tcxo_hz = clk_get_rate(cxo);\n\tclk_put(cxo);\n\n\tinit.name = name;\n\tinit.parent_data = &parent_data;\n\tinit.num_parents = 1;\n\tinit.ops = &clk_spmi_pmic_div_ops;\n\n\tfor (i = 0, clkdiv = cc->clks; i < nclks; i++) {\n\t\tsnprintf(name, sizeof(name), \"div_clk%d\", i + 1);\n\n\t\tspin_lock_init(&clkdiv[i].lock);\n\t\tclkdiv[i].base = start + i * 0x100;\n\t\tclkdiv[i].regmap = regmap;\n\t\tclkdiv[i].cxo_period_ns = NSEC_PER_SEC / cxo_hz;\n\t\tclkdiv[i].hw.init = &init;\n\n\t\tret = devm_clk_hw_register(dev, &clkdiv[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, spmi_pmic_div_clk_hw_get, cc);\n}\n\nstatic const struct of_device_id spmi_pmic_clkdiv_match_table[] = {\n\t{ .compatible = \"qcom,spmi-clkdiv\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, spmi_pmic_clkdiv_match_table);\n\nstatic struct platform_driver spmi_pmic_clkdiv_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"qcom,spmi-pmic-clkdiv\",\n\t\t.of_match_table = spmi_pmic_clkdiv_match_table,\n\t},\n\t.probe\t\t= spmi_pmic_clkdiv_probe,\n};\nmodule_platform_driver(spmi_pmic_clkdiv_driver);\n\nMODULE_DESCRIPTION(\"QCOM SPMI PMIC clkdiv driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}