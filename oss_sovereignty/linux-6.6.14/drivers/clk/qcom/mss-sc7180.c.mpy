{
  "module_name": "mss-sc7180.c",
  "hash_id": "8dcdf8f88f1267b47b76a1a5ac1c6cc99ee595d8c2f9052937012776d6190764",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/mss-sc7180.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/clock/qcom,mss-sc7180.h>\n\n#include \"clk-regmap.h\"\n#include \"clk-branch.h\"\n#include \"common.h\"\n\nstatic struct clk_branch mss_axi_nav_clk = {\n\t.halt_reg = 0x20bc,\n\t.halt_check = BRANCH_HALT,\n\t.clkr = {\n\t\t.enable_reg = 0x20bc,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"mss_axi_nav_clk\",\n\t\t\t.parent_data = &(const struct clk_parent_data){\n\t\t\t\t.fw_name = \"gcc_mss_nav_axi\",\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch mss_axi_crypto_clk = {\n\t.halt_reg = 0x20cc,\n\t.halt_check = BRANCH_HALT,\n\t.clkr = {\n\t\t.enable_reg = 0x20cc,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"mss_axi_crypto_clk\",\n\t\t\t.parent_data = &(const struct clk_parent_data){\n\t\t\t\t.fw_name = \"gcc_mss_mfab_axis\",\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic const struct regmap_config mss_regmap_config = {\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n\t.fast_io\t= true,\n\t.max_register\t= 0x41aa0cc,\n};\n\nstatic struct clk_regmap *mss_sc7180_clocks[] = {\n\t[MSS_AXI_CRYPTO_CLK] = &mss_axi_crypto_clk.clkr,\n\t[MSS_AXI_NAV_CLK] = &mss_axi_nav_clk.clkr,\n};\n\nstatic const struct qcom_cc_desc mss_sc7180_desc = {\n\t.config = &mss_regmap_config,\n\t.clks = mss_sc7180_clocks,\n\t.num_clks = ARRAY_SIZE(mss_sc7180_clocks),\n};\n\nstatic int mss_sc7180_probe(struct platform_device *pdev)\n{\n\tint ret;\n\n\tret = devm_pm_runtime_enable(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_pm_clk_create(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_clk_add(&pdev->dev, \"cfg_ahb\");\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to acquire iface clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_cc_probe(pdev, &mss_sc7180_desc);\n\tif (ret < 0)\n\t\tgoto err_put_rpm;\n\n\tpm_runtime_put(&pdev->dev);\n\n\treturn 0;\n\nerr_put_rpm:\n\tpm_runtime_put_sync(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops mss_sc7180_pm_ops = {\n\tSET_RUNTIME_PM_OPS(pm_clk_suspend, pm_clk_resume, NULL)\n};\n\nstatic const struct of_device_id mss_sc7180_match_table[] = {\n\t{ .compatible = \"qcom,sc7180-mss\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mss_sc7180_match_table);\n\nstatic struct platform_driver mss_sc7180_driver = {\n\t.probe\t\t= mss_sc7180_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"sc7180-mss\",\n\t\t.of_match_table = mss_sc7180_match_table,\n\t\t.pm = &mss_sc7180_pm_ops,\n\t},\n};\n\nstatic int __init mss_sc7180_init(void)\n{\n\treturn platform_driver_register(&mss_sc7180_driver);\n}\nsubsys_initcall(mss_sc7180_init);\n\nstatic void __exit mss_sc7180_exit(void)\n{\n\tplatform_driver_unregister(&mss_sc7180_driver);\n}\nmodule_exit(mss_sc7180_exit);\n\nMODULE_DESCRIPTION(\"QTI MSS SC7180 Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}