{
  "module_name": "clk-alpha-pll.c",
  "hash_id": "7af1a372a94bff475126561b49ca24c38ceec4bd07016c9ec6aee77b40c0ab89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/clk-alpha-pll.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/clk-provider.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n\n#include \"clk-alpha-pll.h\"\n#include \"common.h\"\n\n#define PLL_MODE(p)\t\t((p)->offset + 0x0)\n# define PLL_OUTCTRL\t\tBIT(0)\n# define PLL_BYPASSNL\t\tBIT(1)\n# define PLL_RESET_N\t\tBIT(2)\n# define PLL_OFFLINE_REQ\tBIT(7)\n# define PLL_LOCK_COUNT_SHIFT\t8\n# define PLL_LOCK_COUNT_MASK\t0x3f\n# define PLL_BIAS_COUNT_SHIFT\t14\n# define PLL_BIAS_COUNT_MASK\t0x3f\n# define PLL_VOTE_FSM_ENA\tBIT(20)\n# define PLL_FSM_ENA\t\tBIT(20)\n# define PLL_VOTE_FSM_RESET\tBIT(21)\n# define PLL_UPDATE\t\tBIT(22)\n# define PLL_UPDATE_BYPASS\tBIT(23)\n# define PLL_FSM_LEGACY_MODE\tBIT(24)\n# define PLL_OFFLINE_ACK\tBIT(28)\n# define ALPHA_PLL_ACK_LATCH\tBIT(29)\n# define PLL_ACTIVE_FLAG\tBIT(30)\n# define PLL_LOCK_DET\t\tBIT(31)\n\n#define PLL_L_VAL(p)\t\t((p)->offset + (p)->regs[PLL_OFF_L_VAL])\n#define PLL_CAL_L_VAL(p)\t((p)->offset + (p)->regs[PLL_OFF_CAL_L_VAL])\n#define PLL_ALPHA_VAL(p)\t((p)->offset + (p)->regs[PLL_OFF_ALPHA_VAL])\n#define PLL_ALPHA_VAL_U(p)\t((p)->offset + (p)->regs[PLL_OFF_ALPHA_VAL_U])\n\n#define PLL_USER_CTL(p)\t\t((p)->offset + (p)->regs[PLL_OFF_USER_CTL])\n# define PLL_POST_DIV_SHIFT\t8\n# define PLL_POST_DIV_MASK(p)\tGENMASK((p)->width, 0)\n# define PLL_ALPHA_EN\t\tBIT(24)\n# define PLL_ALPHA_MODE\t\tBIT(25)\n# define PLL_VCO_SHIFT\t\t20\n# define PLL_VCO_MASK\t\t0x3\n\n#define PLL_USER_CTL_U(p)\t((p)->offset + (p)->regs[PLL_OFF_USER_CTL_U])\n#define PLL_USER_CTL_U1(p)\t((p)->offset + (p)->regs[PLL_OFF_USER_CTL_U1])\n\n#define PLL_CONFIG_CTL(p)\t((p)->offset + (p)->regs[PLL_OFF_CONFIG_CTL])\n#define PLL_CONFIG_CTL_U(p)\t((p)->offset + (p)->regs[PLL_OFF_CONFIG_CTL_U])\n#define PLL_CONFIG_CTL_U1(p)\t((p)->offset + (p)->regs[PLL_OFF_CONFIG_CTL_U1])\n#define PLL_TEST_CTL(p)\t\t((p)->offset + (p)->regs[PLL_OFF_TEST_CTL])\n#define PLL_TEST_CTL_U(p)\t((p)->offset + (p)->regs[PLL_OFF_TEST_CTL_U])\n#define PLL_TEST_CTL_U1(p)     ((p)->offset + (p)->regs[PLL_OFF_TEST_CTL_U1])\n#define PLL_TEST_CTL_U2(p)     ((p)->offset + (p)->regs[PLL_OFF_TEST_CTL_U2])\n#define PLL_STATUS(p)\t\t((p)->offset + (p)->regs[PLL_OFF_STATUS])\n#define PLL_OPMODE(p)\t\t((p)->offset + (p)->regs[PLL_OFF_OPMODE])\n#define PLL_FRAC(p)\t\t((p)->offset + (p)->regs[PLL_OFF_FRAC])\n\nconst u8 clk_alpha_pll_regs[][PLL_OFF_MAX_REGS] = {\n\t[CLK_ALPHA_PLL_TYPE_DEFAULT] =  {\n\t\t[PLL_OFF_L_VAL] = 0x04,\n\t\t[PLL_OFF_ALPHA_VAL] = 0x08,\n\t\t[PLL_OFF_ALPHA_VAL_U] = 0x0c,\n\t\t[PLL_OFF_USER_CTL] = 0x10,\n\t\t[PLL_OFF_USER_CTL_U] = 0x14,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x18,\n\t\t[PLL_OFF_TEST_CTL] = 0x1c,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x20,\n\t\t[PLL_OFF_STATUS] = 0x24,\n\t},\n\t[CLK_ALPHA_PLL_TYPE_HUAYRA] =  {\n\t\t[PLL_OFF_L_VAL] = 0x04,\n\t\t[PLL_OFF_ALPHA_VAL] = 0x08,\n\t\t[PLL_OFF_USER_CTL] = 0x10,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x14,\n\t\t[PLL_OFF_CONFIG_CTL_U] = 0x18,\n\t\t[PLL_OFF_TEST_CTL] = 0x1c,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x20,\n\t\t[PLL_OFF_STATUS] = 0x24,\n\t},\n\t[CLK_ALPHA_PLL_TYPE_BRAMMO] =  {\n\t\t[PLL_OFF_L_VAL] = 0x04,\n\t\t[PLL_OFF_ALPHA_VAL] = 0x08,\n\t\t[PLL_OFF_ALPHA_VAL_U] = 0x0c,\n\t\t[PLL_OFF_USER_CTL] = 0x10,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x18,\n\t\t[PLL_OFF_TEST_CTL] = 0x1c,\n\t\t[PLL_OFF_STATUS] = 0x24,\n\t},\n\t[CLK_ALPHA_PLL_TYPE_FABIA] =  {\n\t\t[PLL_OFF_L_VAL] = 0x04,\n\t\t[PLL_OFF_USER_CTL] = 0x0c,\n\t\t[PLL_OFF_USER_CTL_U] = 0x10,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x14,\n\t\t[PLL_OFF_CONFIG_CTL_U] = 0x18,\n\t\t[PLL_OFF_TEST_CTL] = 0x1c,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x20,\n\t\t[PLL_OFF_STATUS] = 0x24,\n\t\t[PLL_OFF_OPMODE] = 0x2c,\n\t\t[PLL_OFF_FRAC] = 0x38,\n\t},\n\t[CLK_ALPHA_PLL_TYPE_TRION] = {\n\t\t[PLL_OFF_L_VAL] = 0x04,\n\t\t[PLL_OFF_CAL_L_VAL] = 0x08,\n\t\t[PLL_OFF_USER_CTL] = 0x0c,\n\t\t[PLL_OFF_USER_CTL_U] = 0x10,\n\t\t[PLL_OFF_USER_CTL_U1] = 0x14,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x18,\n\t\t[PLL_OFF_CONFIG_CTL_U] = 0x1c,\n\t\t[PLL_OFF_CONFIG_CTL_U1] = 0x20,\n\t\t[PLL_OFF_TEST_CTL] = 0x24,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x28,\n\t\t[PLL_OFF_TEST_CTL_U1] = 0x2c,\n\t\t[PLL_OFF_STATUS] = 0x30,\n\t\t[PLL_OFF_OPMODE] = 0x38,\n\t\t[PLL_OFF_ALPHA_VAL] = 0x40,\n\t},\n\t[CLK_ALPHA_PLL_TYPE_AGERA] =  {\n\t\t[PLL_OFF_L_VAL] = 0x04,\n\t\t[PLL_OFF_ALPHA_VAL] = 0x08,\n\t\t[PLL_OFF_USER_CTL] = 0x0c,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x10,\n\t\t[PLL_OFF_CONFIG_CTL_U] = 0x14,\n\t\t[PLL_OFF_TEST_CTL] = 0x18,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x1c,\n\t\t[PLL_OFF_STATUS] = 0x2c,\n\t},\n\t[CLK_ALPHA_PLL_TYPE_ZONDA] =  {\n\t\t[PLL_OFF_L_VAL] = 0x04,\n\t\t[PLL_OFF_ALPHA_VAL] = 0x08,\n\t\t[PLL_OFF_USER_CTL] = 0x0c,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x10,\n\t\t[PLL_OFF_CONFIG_CTL_U] = 0x14,\n\t\t[PLL_OFF_CONFIG_CTL_U1] = 0x18,\n\t\t[PLL_OFF_TEST_CTL] = 0x1c,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x20,\n\t\t[PLL_OFF_TEST_CTL_U1] = 0x24,\n\t\t[PLL_OFF_OPMODE] = 0x28,\n\t\t[PLL_OFF_STATUS] = 0x38,\n\t},\n\t[CLK_ALPHA_PLL_TYPE_LUCID_EVO] = {\n\t\t[PLL_OFF_OPMODE] = 0x04,\n\t\t[PLL_OFF_STATUS] = 0x0c,\n\t\t[PLL_OFF_L_VAL] = 0x10,\n\t\t[PLL_OFF_ALPHA_VAL] = 0x14,\n\t\t[PLL_OFF_USER_CTL] = 0x18,\n\t\t[PLL_OFF_USER_CTL_U] = 0x1c,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x20,\n\t\t[PLL_OFF_CONFIG_CTL_U] = 0x24,\n\t\t[PLL_OFF_CONFIG_CTL_U1] = 0x28,\n\t\t[PLL_OFF_TEST_CTL] = 0x2c,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x30,\n\t\t[PLL_OFF_TEST_CTL_U1] = 0x34,\n\t},\n\t[CLK_ALPHA_PLL_TYPE_LUCID_OLE] = {\n\t\t[PLL_OFF_OPMODE] = 0x04,\n\t\t[PLL_OFF_STATE] = 0x08,\n\t\t[PLL_OFF_STATUS] = 0x0c,\n\t\t[PLL_OFF_L_VAL] = 0x10,\n\t\t[PLL_OFF_ALPHA_VAL] = 0x14,\n\t\t[PLL_OFF_USER_CTL] = 0x18,\n\t\t[PLL_OFF_USER_CTL_U] = 0x1c,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x20,\n\t\t[PLL_OFF_CONFIG_CTL_U] = 0x24,\n\t\t[PLL_OFF_CONFIG_CTL_U1] = 0x28,\n\t\t[PLL_OFF_TEST_CTL] = 0x2c,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x30,\n\t\t[PLL_OFF_TEST_CTL_U1] = 0x34,\n\t\t[PLL_OFF_TEST_CTL_U2] = 0x38,\n\t},\n\t[CLK_ALPHA_PLL_TYPE_RIVIAN_EVO] = {\n\t\t[PLL_OFF_OPMODE] = 0x04,\n\t\t[PLL_OFF_STATUS] = 0x0c,\n\t\t[PLL_OFF_L_VAL] = 0x10,\n\t\t[PLL_OFF_USER_CTL] = 0x14,\n\t\t[PLL_OFF_USER_CTL_U] = 0x18,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x1c,\n\t\t[PLL_OFF_CONFIG_CTL_U] = 0x20,\n\t\t[PLL_OFF_CONFIG_CTL_U1] = 0x24,\n\t\t[PLL_OFF_TEST_CTL] = 0x28,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x2c,\n\t},\n\t[CLK_ALPHA_PLL_TYPE_DEFAULT_EVO] =  {\n\t\t[PLL_OFF_L_VAL] = 0x04,\n\t\t[PLL_OFF_ALPHA_VAL] = 0x08,\n\t\t[PLL_OFF_ALPHA_VAL_U] = 0x0c,\n\t\t[PLL_OFF_TEST_CTL] = 0x10,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x14,\n\t\t[PLL_OFF_USER_CTL] = 0x18,\n\t\t[PLL_OFF_USER_CTL_U] = 0x1c,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x20,\n\t\t[PLL_OFF_STATUS] = 0x24,\n\t},\n\t[CLK_ALPHA_PLL_TYPE_BRAMMO_EVO] =  {\n\t\t[PLL_OFF_L_VAL] = 0x04,\n\t\t[PLL_OFF_ALPHA_VAL] = 0x08,\n\t\t[PLL_OFF_ALPHA_VAL_U] = 0x0c,\n\t\t[PLL_OFF_TEST_CTL] = 0x10,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x14,\n\t\t[PLL_OFF_USER_CTL] = 0x18,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x1C,\n\t\t[PLL_OFF_STATUS] = 0x20,\n\t},\n\t[CLK_ALPHA_PLL_TYPE_STROMER] = {\n\t\t[PLL_OFF_L_VAL] = 0x08,\n\t\t[PLL_OFF_ALPHA_VAL] = 0x10,\n\t\t[PLL_OFF_ALPHA_VAL_U] = 0x14,\n\t\t[PLL_OFF_USER_CTL] = 0x18,\n\t\t[PLL_OFF_USER_CTL_U] = 0x1c,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x20,\n\t\t[PLL_OFF_CONFIG_CTL_U] = 0xff,\n\t\t[PLL_OFF_TEST_CTL] = 0x30,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x34,\n\t\t[PLL_OFF_STATUS] = 0x28,\n\t},\n\t[CLK_ALPHA_PLL_TYPE_STROMER_PLUS] =  {\n\t\t[PLL_OFF_L_VAL] = 0x04,\n\t\t[PLL_OFF_USER_CTL] = 0x08,\n\t\t[PLL_OFF_USER_CTL_U] = 0x0c,\n\t\t[PLL_OFF_CONFIG_CTL] = 0x10,\n\t\t[PLL_OFF_TEST_CTL] = 0x14,\n\t\t[PLL_OFF_TEST_CTL_U] = 0x18,\n\t\t[PLL_OFF_STATUS] = 0x1c,\n\t\t[PLL_OFF_ALPHA_VAL] = 0x24,\n\t\t[PLL_OFF_ALPHA_VAL_U] = 0x28,\n\t},\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_regs);\n\n \n#define ALPHA_REG_BITWIDTH\t40\n#define ALPHA_REG_16BIT_WIDTH\t16\n#define ALPHA_BITWIDTH\t\t32U\n#define ALPHA_SHIFT(w)\t\tmin(w, ALPHA_BITWIDTH)\n\n#define\tALPHA_PLL_STATUS_REG_SHIFT\t8\n\n#define PLL_HUAYRA_M_WIDTH\t\t8\n#define PLL_HUAYRA_M_SHIFT\t\t8\n#define PLL_HUAYRA_M_MASK\t\t0xff\n#define PLL_HUAYRA_N_SHIFT\t\t0\n#define PLL_HUAYRA_N_MASK\t\t0xff\n#define PLL_HUAYRA_ALPHA_WIDTH\t\t16\n\n#define PLL_STANDBY\t\t0x0\n#define PLL_RUN\t\t\t0x1\n#define PLL_OUT_MASK\t\t0x7\n#define PLL_RATE_MARGIN\t\t500\n\n \n#define TRION_PLL_CAL_VAL\t0x44\n#define TRION_PCAL_DONE\t\tBIT(26)\n\n \n#define LUCID_PCAL_DONE\t\tBIT(27)\n\n \n#define LUCID_5LPE_PCAL_DONE\t\tBIT(11)\n#define LUCID_5LPE_ALPHA_PLL_ACK_LATCH\tBIT(13)\n#define LUCID_5LPE_PLL_LATCH_INPUT\tBIT(14)\n#define LUCID_5LPE_ENABLE_VOTE_RUN\tBIT(21)\n\n \n#define LUCID_EVO_PCAL_NOT_DONE\t\tBIT(8)\n#define LUCID_EVO_ENABLE_VOTE_RUN       BIT(25)\n#define LUCID_EVO_PLL_L_VAL_MASK        GENMASK(15, 0)\n#define LUCID_EVO_PLL_CAL_L_VAL_SHIFT\t16\n\n \n#define ZONDA_PLL_OUT_MASK\t0xf\n#define ZONDA_STAY_IN_CFA\tBIT(16)\n#define ZONDA_PLL_FREQ_LOCK_DET\tBIT(29)\n\n#define pll_alpha_width(p)\t\t\t\t\t\\\n\t\t((PLL_ALPHA_VAL_U(p) - PLL_ALPHA_VAL(p) == 4) ?\t\\\n\t\t\t\t ALPHA_REG_BITWIDTH : ALPHA_REG_16BIT_WIDTH)\n\n#define pll_has_64bit_config(p)\t((PLL_CONFIG_CTL_U(p) - PLL_CONFIG_CTL(p)) == 4)\n\n#define to_clk_alpha_pll(_hw) container_of(to_clk_regmap(_hw), \\\n\t\t\t\t\t   struct clk_alpha_pll, clkr)\n\n#define to_clk_alpha_pll_postdiv(_hw) container_of(to_clk_regmap(_hw), \\\n\t\t\t\t\t   struct clk_alpha_pll_postdiv, clkr)\n\nstatic int wait_for_pll(struct clk_alpha_pll *pll, u32 mask, bool inverse,\n\t\t\tconst char *action)\n{\n\tu32 val;\n\tint count;\n\tint ret;\n\tconst char *name = clk_hw_get_name(&pll->clkr.hw);\n\n\tret = regmap_read(pll->clkr.regmap, PLL_MODE(pll), &val);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (count = 200; count > 0; count--) {\n\t\tret = regmap_read(pll->clkr.regmap, PLL_MODE(pll), &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (inverse && !(val & mask))\n\t\t\treturn 0;\n\t\telse if ((val & mask) == mask)\n\t\t\treturn 0;\n\n\t\tudelay(1);\n\t}\n\n\tWARN(1, \"%s failed to %s!\\n\", name, action);\n\treturn -ETIMEDOUT;\n}\n\n#define wait_for_pll_enable_active(pll) \\\n\twait_for_pll(pll, PLL_ACTIVE_FLAG, 0, \"enable\")\n\n#define wait_for_pll_enable_lock(pll) \\\n\twait_for_pll(pll, PLL_LOCK_DET, 0, \"enable\")\n\n#define wait_for_zonda_pll_freq_lock(pll) \\\n\twait_for_pll(pll, ZONDA_PLL_FREQ_LOCK_DET, 0, \"freq enable\")\n\n#define wait_for_pll_disable(pll) \\\n\twait_for_pll(pll, PLL_ACTIVE_FLAG, 1, \"disable\")\n\n#define wait_for_pll_offline(pll) \\\n\twait_for_pll(pll, PLL_OFFLINE_ACK, 0, \"offline\")\n\n#define wait_for_pll_update(pll) \\\n\twait_for_pll(pll, PLL_UPDATE, 1, \"update\")\n\n#define wait_for_pll_update_ack_set(pll) \\\n\twait_for_pll(pll, ALPHA_PLL_ACK_LATCH, 0, \"update_ack_set\")\n\n#define wait_for_pll_update_ack_clear(pll) \\\n\twait_for_pll(pll, ALPHA_PLL_ACK_LATCH, 1, \"update_ack_clear\")\n\nstatic void clk_alpha_pll_write_config(struct regmap *regmap, unsigned int reg,\n\t\t\t\t\tunsigned int val)\n{\n\tif (val)\n\t\tregmap_write(regmap, reg, val);\n}\n\nvoid clk_alpha_pll_configure(struct clk_alpha_pll *pll, struct regmap *regmap,\n\t\t\t     const struct alpha_pll_config *config)\n{\n\tu32 val, mask;\n\n\tregmap_write(regmap, PLL_L_VAL(pll), config->l);\n\tregmap_write(regmap, PLL_ALPHA_VAL(pll), config->alpha);\n\tregmap_write(regmap, PLL_CONFIG_CTL(pll), config->config_ctl_val);\n\n\tif (pll_has_64bit_config(pll))\n\t\tregmap_write(regmap, PLL_CONFIG_CTL_U(pll),\n\t\t\t     config->config_ctl_hi_val);\n\n\tif (pll_alpha_width(pll) > 32)\n\t\tregmap_write(regmap, PLL_ALPHA_VAL_U(pll), config->alpha_hi);\n\n\tval = config->main_output_mask;\n\tval |= config->aux_output_mask;\n\tval |= config->aux2_output_mask;\n\tval |= config->early_output_mask;\n\tval |= config->pre_div_val;\n\tval |= config->post_div_val;\n\tval |= config->vco_val;\n\tval |= config->alpha_en_mask;\n\tval |= config->alpha_mode_mask;\n\n\tmask = config->main_output_mask;\n\tmask |= config->aux_output_mask;\n\tmask |= config->aux2_output_mask;\n\tmask |= config->early_output_mask;\n\tmask |= config->pre_div_mask;\n\tmask |= config->post_div_mask;\n\tmask |= config->vco_mask;\n\n\tregmap_update_bits(regmap, PLL_USER_CTL(pll), mask, val);\n\n\tif (config->test_ctl_mask)\n\t\tregmap_update_bits(regmap, PLL_TEST_CTL(pll),\n\t\t\t\t   config->test_ctl_mask,\n\t\t\t\t   config->test_ctl_val);\n\telse\n\t\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL(pll),\n\t\t\t\t\t   config->test_ctl_val);\n\n\tif (config->test_ctl_hi_mask)\n\t\tregmap_update_bits(regmap, PLL_TEST_CTL_U(pll),\n\t\t\t\t   config->test_ctl_hi_mask,\n\t\t\t\t   config->test_ctl_hi_val);\n\telse\n\t\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL_U(pll),\n\t\t\t\t\t   config->test_ctl_hi_val);\n\n\tif (pll->flags & SUPPORTS_FSM_MODE)\n\t\tqcom_pll_set_fsm_mode(regmap, PLL_MODE(pll), 6, 0);\n}\nEXPORT_SYMBOL_GPL(clk_alpha_pll_configure);\n\nstatic int clk_alpha_pll_hwfsm_enable(struct clk_hw *hw)\n{\n\tint ret;\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 val;\n\n\tret = regmap_read(pll->clkr.regmap, PLL_MODE(pll), &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval |= PLL_FSM_ENA;\n\n\tif (pll->flags & SUPPORTS_OFFLINE_REQ)\n\t\tval &= ~PLL_OFFLINE_REQ;\n\n\tret = regmap_write(pll->clkr.regmap, PLL_MODE(pll), val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmb();\n\n\treturn wait_for_pll_enable_active(pll);\n}\n\nstatic void clk_alpha_pll_hwfsm_disable(struct clk_hw *hw)\n{\n\tint ret;\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 val;\n\n\tret = regmap_read(pll->clkr.regmap, PLL_MODE(pll), &val);\n\tif (ret)\n\t\treturn;\n\n\tif (pll->flags & SUPPORTS_OFFLINE_REQ) {\n\t\tret = regmap_update_bits(pll->clkr.regmap, PLL_MODE(pll),\n\t\t\t\t\t PLL_OFFLINE_REQ, PLL_OFFLINE_REQ);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tret = wait_for_pll_offline(pll);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\t \n\tret = regmap_update_bits(pll->clkr.regmap, PLL_MODE(pll),\n\t\t\t\t PLL_FSM_ENA, 0);\n\tif (ret)\n\t\treturn;\n\n\twait_for_pll_disable(pll);\n}\n\nstatic int pll_is_enabled(struct clk_hw *hw, u32 mask)\n{\n\tint ret;\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 val;\n\n\tret = regmap_read(pll->clkr.regmap, PLL_MODE(pll), &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(val & mask);\n}\n\nstatic int clk_alpha_pll_hwfsm_is_enabled(struct clk_hw *hw)\n{\n\treturn pll_is_enabled(hw, PLL_ACTIVE_FLAG);\n}\n\nstatic int clk_alpha_pll_is_enabled(struct clk_hw *hw)\n{\n\treturn pll_is_enabled(hw, PLL_LOCK_DET);\n}\n\nstatic int clk_alpha_pll_enable(struct clk_hw *hw)\n{\n\tint ret;\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 val, mask;\n\n\tmask = PLL_OUTCTRL | PLL_RESET_N | PLL_BYPASSNL;\n\tret = regmap_read(pll->clkr.regmap, PLL_MODE(pll), &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (val & PLL_VOTE_FSM_ENA) {\n\t\tret = clk_enable_regmap(hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn wait_for_pll_enable_active(pll);\n\t}\n\n\t \n\tif ((val & mask) == mask)\n\t\treturn 0;\n\n\tret = regmap_update_bits(pll->clkr.regmap, PLL_MODE(pll),\n\t\t\t\t PLL_BYPASSNL, PLL_BYPASSNL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmb();\n\tudelay(5);\n\n\tret = regmap_update_bits(pll->clkr.regmap, PLL_MODE(pll),\n\t\t\t\t PLL_RESET_N, PLL_RESET_N);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_for_pll_enable_lock(pll);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(pll->clkr.regmap, PLL_MODE(pll),\n\t\t\t\t PLL_OUTCTRL, PLL_OUTCTRL);\n\n\t \n\tmb();\n\treturn ret;\n}\n\nstatic void clk_alpha_pll_disable(struct clk_hw *hw)\n{\n\tint ret;\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 val, mask;\n\n\tret = regmap_read(pll->clkr.regmap, PLL_MODE(pll), &val);\n\tif (ret)\n\t\treturn;\n\n\t \n\tif (val & PLL_VOTE_FSM_ENA) {\n\t\tclk_disable_regmap(hw);\n\t\treturn;\n\t}\n\n\tmask = PLL_OUTCTRL;\n\tregmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), mask, 0);\n\n\t \n\tmb();\n\tudelay(1);\n\n\tmask = PLL_RESET_N | PLL_BYPASSNL;\n\tregmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), mask, 0);\n}\n\nstatic unsigned long\nalpha_pll_calc_rate(u64 prate, u32 l, u32 a, u32 alpha_width)\n{\n\treturn (prate * l) + ((prate * a) >> ALPHA_SHIFT(alpha_width));\n}\n\nstatic unsigned long\nalpha_pll_round_rate(unsigned long rate, unsigned long prate, u32 *l, u64 *a,\n\t\t     u32 alpha_width)\n{\n\tu64 remainder;\n\tu64 quotient;\n\n\tquotient = rate;\n\tremainder = do_div(quotient, prate);\n\t*l = quotient;\n\n\tif (!remainder) {\n\t\t*a = 0;\n\t\treturn rate;\n\t}\n\n\t \n\tquotient = remainder << ALPHA_SHIFT(alpha_width);\n\n\tremainder = do_div(quotient, prate);\n\n\tif (remainder)\n\t\tquotient++;\n\n\t*a = quotient;\n\treturn alpha_pll_calc_rate(prate, *l, *a, alpha_width);\n}\n\nstatic const struct pll_vco *\nalpha_pll_find_vco(const struct clk_alpha_pll *pll, unsigned long rate)\n{\n\tconst struct pll_vco *v = pll->vco_table;\n\tconst struct pll_vco *end = v + pll->num_vco;\n\n\tfor (; v < end; v++)\n\t\tif (rate >= v->min_freq && rate <= v->max_freq)\n\t\t\treturn v;\n\n\treturn NULL;\n}\n\nstatic unsigned long\nclk_alpha_pll_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tu32 l, low, high, ctl;\n\tu64 a = 0, prate = parent_rate;\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 alpha_width = pll_alpha_width(pll);\n\n\tregmap_read(pll->clkr.regmap, PLL_L_VAL(pll), &l);\n\n\tregmap_read(pll->clkr.regmap, PLL_USER_CTL(pll), &ctl);\n\tif (ctl & PLL_ALPHA_EN) {\n\t\tregmap_read(pll->clkr.regmap, PLL_ALPHA_VAL(pll), &low);\n\t\tif (alpha_width > 32) {\n\t\t\tregmap_read(pll->clkr.regmap, PLL_ALPHA_VAL_U(pll),\n\t\t\t\t    &high);\n\t\t\ta = (u64)high << 32 | low;\n\t\t} else {\n\t\t\ta = low & GENMASK(alpha_width - 1, 0);\n\t\t}\n\n\t\tif (alpha_width > ALPHA_BITWIDTH)\n\t\t\ta >>= alpha_width - ALPHA_BITWIDTH;\n\t}\n\n\treturn alpha_pll_calc_rate(prate, l, a, alpha_width);\n}\n\n\nstatic int __clk_alpha_pll_update_latch(struct clk_alpha_pll *pll)\n{\n\tint ret;\n\tu32 mode;\n\n\tregmap_read(pll->clkr.regmap, PLL_MODE(pll), &mode);\n\n\t \n\tregmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), PLL_UPDATE,\n\t\t\t   PLL_UPDATE);\n\n\t \n\tudelay(1);\n\n\t \n\tif (mode & PLL_UPDATE_BYPASS) {\n\t\tret = wait_for_pll_update_ack_set(pll);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tregmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), PLL_UPDATE, 0);\n\t} else {\n\t\tret = wait_for_pll_update(pll);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = wait_for_pll_update_ack_clear(pll);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tudelay(10);\n\n\treturn 0;\n}\n\nstatic int clk_alpha_pll_update_latch(struct clk_alpha_pll *pll,\n\t\t\t\t      int (*is_enabled)(struct clk_hw *))\n{\n\tif (!is_enabled(&pll->clkr.hw) ||\n\t    !(pll->flags & SUPPORTS_DYNAMIC_UPDATE))\n\t\treturn 0;\n\n\treturn __clk_alpha_pll_update_latch(pll);\n}\n\nstatic int __clk_alpha_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long prate,\n\t\t\t\t    int (*is_enabled)(struct clk_hw *))\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tconst struct pll_vco *vco;\n\tu32 l, alpha_width = pll_alpha_width(pll);\n\tu64 a;\n\n\trate = alpha_pll_round_rate(rate, prate, &l, &a, alpha_width);\n\tvco = alpha_pll_find_vco(pll, rate);\n\tif (pll->vco_table && !vco) {\n\t\tpr_err(\"%s: alpha pll not in a valid vco range\\n\",\n\t\t       clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(pll->clkr.regmap, PLL_L_VAL(pll), l);\n\n\tif (alpha_width > ALPHA_BITWIDTH)\n\t\ta <<= alpha_width - ALPHA_BITWIDTH;\n\n\tif (alpha_width > 32)\n\t\tregmap_write(pll->clkr.regmap, PLL_ALPHA_VAL_U(pll), a >> 32);\n\n\tregmap_write(pll->clkr.regmap, PLL_ALPHA_VAL(pll), a);\n\n\tif (vco) {\n\t\tregmap_update_bits(pll->clkr.regmap, PLL_USER_CTL(pll),\n\t\t\t\t   PLL_VCO_MASK << PLL_VCO_SHIFT,\n\t\t\t\t   vco->val << PLL_VCO_SHIFT);\n\t}\n\n\tregmap_update_bits(pll->clkr.regmap, PLL_USER_CTL(pll),\n\t\t\t   PLL_ALPHA_EN, PLL_ALPHA_EN);\n\n\treturn clk_alpha_pll_update_latch(pll, is_enabled);\n}\n\nstatic int clk_alpha_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long prate)\n{\n\treturn __clk_alpha_pll_set_rate(hw, rate, prate,\n\t\t\t\t\tclk_alpha_pll_is_enabled);\n}\n\nstatic int clk_alpha_pll_hwfsm_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\tunsigned long prate)\n{\n\treturn __clk_alpha_pll_set_rate(hw, rate, prate,\n\t\t\t\t\tclk_alpha_pll_hwfsm_is_enabled);\n}\n\nstatic long clk_alpha_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long *prate)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 l, alpha_width = pll_alpha_width(pll);\n\tu64 a;\n\tunsigned long min_freq, max_freq;\n\n\trate = alpha_pll_round_rate(rate, *prate, &l, &a, alpha_width);\n\tif (!pll->vco_table || alpha_pll_find_vco(pll, rate))\n\t\treturn rate;\n\n\tmin_freq = pll->vco_table[0].min_freq;\n\tmax_freq = pll->vco_table[pll->num_vco - 1].max_freq;\n\n\treturn clamp(rate, min_freq, max_freq);\n}\n\nstatic unsigned long\nalpha_huayra_pll_calc_rate(u64 prate, u32 l, u32 a)\n{\n\t \n\tif (a >= BIT(PLL_HUAYRA_ALPHA_WIDTH - 1))\n\t\tl -= 1;\n\n\treturn (prate * l) + (prate * a >> PLL_HUAYRA_ALPHA_WIDTH);\n}\n\nstatic unsigned long\nalpha_huayra_pll_round_rate(unsigned long rate, unsigned long prate,\n\t\t\t    u32 *l, u32 *a)\n{\n\tu64 remainder;\n\tu64 quotient;\n\n\tquotient = rate;\n\tremainder = do_div(quotient, prate);\n\t*l = quotient;\n\n\tif (!remainder) {\n\t\t*a = 0;\n\t\treturn rate;\n\t}\n\n\tquotient = remainder << PLL_HUAYRA_ALPHA_WIDTH;\n\tremainder = do_div(quotient, prate);\n\n\tif (remainder)\n\t\tquotient++;\n\n\t \n\tif (quotient >= BIT(PLL_HUAYRA_ALPHA_WIDTH - 1))\n\t\t*l += 1;\n\n\t*a = quotient;\n\treturn alpha_huayra_pll_calc_rate(prate, *l, *a);\n}\n\nstatic unsigned long\nalpha_pll_huayra_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tu64 rate = parent_rate, tmp;\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 l, alpha = 0, ctl, alpha_m, alpha_n;\n\n\tregmap_read(pll->clkr.regmap, PLL_L_VAL(pll), &l);\n\tregmap_read(pll->clkr.regmap, PLL_USER_CTL(pll), &ctl);\n\n\tif (ctl & PLL_ALPHA_EN) {\n\t\tregmap_read(pll->clkr.regmap, PLL_ALPHA_VAL(pll), &alpha);\n\t\t \n\t\tif (!(ctl & PLL_ALPHA_MODE))\n\t\t\treturn alpha_huayra_pll_calc_rate(rate, l, alpha);\n\n\t\talpha_m = alpha >> PLL_HUAYRA_M_SHIFT & PLL_HUAYRA_M_MASK;\n\t\talpha_n = alpha >> PLL_HUAYRA_N_SHIFT & PLL_HUAYRA_N_MASK;\n\n\t\trate *= l;\n\t\ttmp = parent_rate;\n\t\tif (alpha_m >= BIT(PLL_HUAYRA_M_WIDTH - 1)) {\n\t\t\talpha_m = BIT(PLL_HUAYRA_M_WIDTH) - alpha_m;\n\t\t\ttmp *= alpha_m;\n\t\t\tdo_div(tmp, alpha_n);\n\t\t\trate -= tmp;\n\t\t} else {\n\t\t\ttmp *= alpha_m;\n\t\t\tdo_div(tmp, alpha_n);\n\t\t\trate += tmp;\n\t\t}\n\n\t\treturn rate;\n\t}\n\n\treturn alpha_huayra_pll_calc_rate(rate, l, alpha);\n}\n\nstatic int alpha_pll_huayra_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long prate)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 l, a, ctl, cur_alpha = 0;\n\n\trate = alpha_huayra_pll_round_rate(rate, prate, &l, &a);\n\n\tregmap_read(pll->clkr.regmap, PLL_USER_CTL(pll), &ctl);\n\n\tif (ctl & PLL_ALPHA_EN)\n\t\tregmap_read(pll->clkr.regmap, PLL_ALPHA_VAL(pll), &cur_alpha);\n\n\t \n\tif (clk_alpha_pll_is_enabled(hw)) {\n\t\tif (cur_alpha != a) {\n\t\t\tpr_err(\"%s: clock needs to be gated\\n\",\n\t\t\t       clk_hw_get_name(hw));\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tregmap_write(pll->clkr.regmap, PLL_L_VAL(pll), l);\n\t\t \n\t\tmb();\n\t\treturn wait_for_pll_enable_lock(pll);\n\t}\n\n\tregmap_write(pll->clkr.regmap, PLL_L_VAL(pll), l);\n\tregmap_write(pll->clkr.regmap, PLL_ALPHA_VAL(pll), a);\n\n\tif (a == 0)\n\t\tregmap_update_bits(pll->clkr.regmap, PLL_USER_CTL(pll),\n\t\t\t\t   PLL_ALPHA_EN, 0x0);\n\telse\n\t\tregmap_update_bits(pll->clkr.regmap, PLL_USER_CTL(pll),\n\t\t\t\t   PLL_ALPHA_EN | PLL_ALPHA_MODE, PLL_ALPHA_EN);\n\n\treturn 0;\n}\n\nstatic long alpha_pll_huayra_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\tunsigned long *prate)\n{\n\tu32 l, a;\n\n\treturn alpha_huayra_pll_round_rate(rate, *prate, &l, &a);\n}\n\nstatic int trion_pll_is_enabled(struct clk_alpha_pll *pll,\n\t\t\t\tstruct regmap *regmap)\n{\n\tu32 mode_val, opmode_val;\n\tint ret;\n\n\tret = regmap_read(regmap, PLL_MODE(pll), &mode_val);\n\tret |= regmap_read(regmap, PLL_OPMODE(pll), &opmode_val);\n\tif (ret)\n\t\treturn 0;\n\n\treturn ((opmode_val & PLL_RUN) && (mode_val & PLL_OUTCTRL));\n}\n\nstatic int clk_trion_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\n\treturn trion_pll_is_enabled(pll, pll->clkr.regmap);\n}\n\nstatic int clk_trion_pll_enable(struct clk_hw *hw)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tstruct regmap *regmap = pll->clkr.regmap;\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(regmap, PLL_MODE(pll), &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (val & PLL_VOTE_FSM_ENA) {\n\t\tret = clk_enable_regmap(hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn wait_for_pll_enable_active(pll);\n\t}\n\n\t \n\tregmap_write(regmap, PLL_OPMODE(pll), PLL_RUN);\n\n\tret = wait_for_pll_enable_lock(pll);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(regmap, PLL_USER_CTL(pll),\n\t\t\t\t PLL_OUT_MASK, PLL_OUT_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(regmap, PLL_MODE(pll),\n\t\t\t\t PLL_OUTCTRL, PLL_OUTCTRL);\n}\n\nstatic void clk_trion_pll_disable(struct clk_hw *hw)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tstruct regmap *regmap = pll->clkr.regmap;\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(regmap, PLL_MODE(pll), &val);\n\tif (ret)\n\t\treturn;\n\n\t \n\tif (val & PLL_VOTE_FSM_ENA) {\n\t\tclk_disable_regmap(hw);\n\t\treturn;\n\t}\n\n\t \n\tret = regmap_update_bits(regmap, PLL_MODE(pll), PLL_OUTCTRL, 0);\n\tif (ret)\n\t\treturn;\n\n\t \n\tret = regmap_update_bits(regmap, PLL_USER_CTL(pll),\n\t\t\t\t PLL_OUT_MASK, 0);\n\tif (ret)\n\t\treturn;\n\n\t \n\tregmap_write(regmap, PLL_OPMODE(pll), PLL_STANDBY);\n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_RESET_N, PLL_RESET_N);\n}\n\nstatic unsigned long\nclk_trion_pll_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 l, frac, alpha_width = pll_alpha_width(pll);\n\n\tregmap_read(pll->clkr.regmap, PLL_L_VAL(pll), &l);\n\tregmap_read(pll->clkr.regmap, PLL_ALPHA_VAL(pll), &frac);\n\n\treturn alpha_pll_calc_rate(parent_rate, l, frac, alpha_width);\n}\n\nconst struct clk_ops clk_alpha_pll_fixed_ops = {\n\t.enable = clk_alpha_pll_enable,\n\t.disable = clk_alpha_pll_disable,\n\t.is_enabled = clk_alpha_pll_is_enabled,\n\t.recalc_rate = clk_alpha_pll_recalc_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_fixed_ops);\n\nconst struct clk_ops clk_alpha_pll_ops = {\n\t.enable = clk_alpha_pll_enable,\n\t.disable = clk_alpha_pll_disable,\n\t.is_enabled = clk_alpha_pll_is_enabled,\n\t.recalc_rate = clk_alpha_pll_recalc_rate,\n\t.round_rate = clk_alpha_pll_round_rate,\n\t.set_rate = clk_alpha_pll_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_ops);\n\nconst struct clk_ops clk_alpha_pll_huayra_ops = {\n\t.enable = clk_alpha_pll_enable,\n\t.disable = clk_alpha_pll_disable,\n\t.is_enabled = clk_alpha_pll_is_enabled,\n\t.recalc_rate = alpha_pll_huayra_recalc_rate,\n\t.round_rate = alpha_pll_huayra_round_rate,\n\t.set_rate = alpha_pll_huayra_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_huayra_ops);\n\nconst struct clk_ops clk_alpha_pll_hwfsm_ops = {\n\t.enable = clk_alpha_pll_hwfsm_enable,\n\t.disable = clk_alpha_pll_hwfsm_disable,\n\t.is_enabled = clk_alpha_pll_hwfsm_is_enabled,\n\t.recalc_rate = clk_alpha_pll_recalc_rate,\n\t.round_rate = clk_alpha_pll_round_rate,\n\t.set_rate = clk_alpha_pll_hwfsm_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_hwfsm_ops);\n\nconst struct clk_ops clk_alpha_pll_fixed_trion_ops = {\n\t.enable = clk_trion_pll_enable,\n\t.disable = clk_trion_pll_disable,\n\t.is_enabled = clk_trion_pll_is_enabled,\n\t.recalc_rate = clk_trion_pll_recalc_rate,\n\t.round_rate = clk_alpha_pll_round_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_fixed_trion_ops);\n\nstatic unsigned long\nclk_alpha_pll_postdiv_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\n\tu32 ctl;\n\n\tregmap_read(pll->clkr.regmap, PLL_USER_CTL(pll), &ctl);\n\n\tctl >>= PLL_POST_DIV_SHIFT;\n\tctl &= PLL_POST_DIV_MASK(pll);\n\n\treturn parent_rate >> fls(ctl);\n}\n\nstatic const struct clk_div_table clk_alpha_div_table[] = {\n\t{ 0x0, 1 },\n\t{ 0x1, 2 },\n\t{ 0x3, 4 },\n\t{ 0x7, 8 },\n\t{ 0xf, 16 },\n\t{ }\n};\n\nstatic const struct clk_div_table clk_alpha_2bit_div_table[] = {\n\t{ 0x0, 1 },\n\t{ 0x1, 2 },\n\t{ 0x3, 4 },\n\t{ }\n};\n\nstatic long\nclk_alpha_pll_postdiv_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long *prate)\n{\n\tstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\n\tconst struct clk_div_table *table;\n\n\tif (pll->width == 2)\n\t\ttable = clk_alpha_2bit_div_table;\n\telse\n\t\ttable = clk_alpha_div_table;\n\n\treturn divider_round_rate(hw, rate, prate, table,\n\t\t\t\t  pll->width, CLK_DIVIDER_POWER_OF_TWO);\n}\n\nstatic long\nclk_alpha_pll_postdiv_round_ro_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *prate)\n{\n\tstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\n\tu32 ctl, div;\n\n\tregmap_read(pll->clkr.regmap, PLL_USER_CTL(pll), &ctl);\n\n\tctl >>= PLL_POST_DIV_SHIFT;\n\tctl &= BIT(pll->width) - 1;\n\tdiv = 1 << fls(ctl);\n\n\tif (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)\n\t\t*prate = clk_hw_round_rate(clk_hw_get_parent(hw), div * rate);\n\n\treturn DIV_ROUND_UP_ULL((u64)*prate, div);\n}\n\nstatic int clk_alpha_pll_postdiv_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\n\tint div;\n\n\t \n\tdiv = DIV_ROUND_UP_ULL(parent_rate, rate) - 1;\n\n\treturn regmap_update_bits(pll->clkr.regmap, PLL_USER_CTL(pll),\n\t\t\t\t  PLL_POST_DIV_MASK(pll) << PLL_POST_DIV_SHIFT,\n\t\t\t\t  div << PLL_POST_DIV_SHIFT);\n}\n\nconst struct clk_ops clk_alpha_pll_postdiv_ops = {\n\t.recalc_rate = clk_alpha_pll_postdiv_recalc_rate,\n\t.round_rate = clk_alpha_pll_postdiv_round_rate,\n\t.set_rate = clk_alpha_pll_postdiv_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_postdiv_ops);\n\nconst struct clk_ops clk_alpha_pll_postdiv_ro_ops = {\n\t.round_rate = clk_alpha_pll_postdiv_round_ro_rate,\n\t.recalc_rate = clk_alpha_pll_postdiv_recalc_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_postdiv_ro_ops);\n\nvoid clk_fabia_pll_configure(struct clk_alpha_pll *pll, struct regmap *regmap,\n\t\t\t     const struct alpha_pll_config *config)\n{\n\tu32 val, mask;\n\n\tclk_alpha_pll_write_config(regmap, PLL_L_VAL(pll), config->l);\n\tclk_alpha_pll_write_config(regmap, PLL_FRAC(pll), config->alpha);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL(pll),\n\t\t\t\t\t\tconfig->config_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL_U(pll),\n\t\t\t\t\t\tconfig->config_ctl_hi_val);\n\tclk_alpha_pll_write_config(regmap, PLL_USER_CTL(pll),\n\t\t\t\t\t\tconfig->user_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_USER_CTL_U(pll),\n\t\t\t\t\t\tconfig->user_ctl_hi_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL(pll),\n\t\t\t\t\t\tconfig->test_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL_U(pll),\n\t\t\t\t\t\tconfig->test_ctl_hi_val);\n\n\tif (config->post_div_mask) {\n\t\tmask = config->post_div_mask;\n\t\tval = config->post_div_val;\n\t\tregmap_update_bits(regmap, PLL_USER_CTL(pll), mask, val);\n\t}\n\n\tif (pll->flags & SUPPORTS_FSM_LEGACY_MODE)\n\t\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_FSM_LEGACY_MODE,\n\t\t\t\t\t\t\tPLL_FSM_LEGACY_MODE);\n\n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_UPDATE_BYPASS,\n\t\t\t\t\t\t\tPLL_UPDATE_BYPASS);\n\n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_RESET_N, PLL_RESET_N);\n}\nEXPORT_SYMBOL_GPL(clk_fabia_pll_configure);\n\nstatic int alpha_pll_fabia_enable(struct clk_hw *hw)\n{\n\tint ret;\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 val, opmode_val;\n\tstruct regmap *regmap = pll->clkr.regmap;\n\n\tret = regmap_read(regmap, PLL_MODE(pll), &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (val & PLL_VOTE_FSM_ENA) {\n\t\tret = clk_enable_regmap(hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn wait_for_pll_enable_active(pll);\n\t}\n\n\tret = regmap_read(regmap, PLL_OPMODE(pll), &opmode_val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif ((opmode_val & PLL_RUN) && (val & PLL_OUTCTRL))\n\t\treturn 0;\n\n\tret = regmap_update_bits(regmap, PLL_MODE(pll), PLL_OUTCTRL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(regmap, PLL_OPMODE(pll), PLL_STANDBY);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, PLL_MODE(pll), PLL_RESET_N,\n\t\t\t\t PLL_RESET_N);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(regmap, PLL_OPMODE(pll), PLL_RUN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_for_pll_enable_lock(pll);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, PLL_USER_CTL(pll),\n\t\t\t\t PLL_OUT_MASK, PLL_OUT_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(regmap, PLL_MODE(pll), PLL_OUTCTRL,\n\t\t\t\t PLL_OUTCTRL);\n}\n\nstatic void alpha_pll_fabia_disable(struct clk_hw *hw)\n{\n\tint ret;\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 val;\n\tstruct regmap *regmap = pll->clkr.regmap;\n\n\tret = regmap_read(regmap, PLL_MODE(pll), &val);\n\tif (ret)\n\t\treturn;\n\n\t \n\tif (val & PLL_FSM_ENA) {\n\t\tclk_disable_regmap(hw);\n\t\treturn;\n\t}\n\n\tret = regmap_update_bits(regmap, PLL_MODE(pll), PLL_OUTCTRL, 0);\n\tif (ret)\n\t\treturn;\n\n\t \n\tret = regmap_update_bits(regmap, PLL_USER_CTL(pll), PLL_OUT_MASK, 0);\n\tif (ret)\n\t\treturn;\n\n\t \n\tregmap_write(regmap, PLL_OPMODE(pll), PLL_STANDBY);\n}\n\nstatic unsigned long alpha_pll_fabia_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 l, frac, alpha_width = pll_alpha_width(pll);\n\n\tregmap_read(pll->clkr.regmap, PLL_L_VAL(pll), &l);\n\tregmap_read(pll->clkr.regmap, PLL_FRAC(pll), &frac);\n\n\treturn alpha_pll_calc_rate(parent_rate, l, frac, alpha_width);\n}\n\n \nstatic int alpha_pll_check_rate_margin(struct clk_hw *hw,\n\t\t\tunsigned long rrate, unsigned long rate)\n{\n\tunsigned long rate_margin = rate + PLL_RATE_MARGIN;\n\n\tif (rrate > rate_margin || rrate < rate) {\n\t\tpr_err(\"%s: Rounded rate %lu not within range [%lu, %lu)\\n\",\n\t\t       clk_hw_get_name(hw), rrate, rate, rate_margin);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int alpha_pll_fabia_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t\tunsigned long prate)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 l, alpha_width = pll_alpha_width(pll);\n\tunsigned long rrate;\n\tint ret;\n\tu64 a;\n\n\trrate = alpha_pll_round_rate(rate, prate, &l, &a, alpha_width);\n\n\tret = alpha_pll_check_rate_margin(hw, rrate, rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregmap_write(pll->clkr.regmap, PLL_L_VAL(pll), l);\n\tregmap_write(pll->clkr.regmap, PLL_FRAC(pll), a);\n\n\treturn __clk_alpha_pll_update_latch(pll);\n}\n\nstatic int alpha_pll_fabia_prepare(struct clk_hw *hw)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tconst struct pll_vco *vco;\n\tstruct clk_hw *parent_hw;\n\tunsigned long cal_freq, rrate;\n\tu32 cal_l, val, alpha_width = pll_alpha_width(pll);\n\tconst char *name = clk_hw_get_name(hw);\n\tu64 a;\n\tint ret;\n\n\t \n\tret = regmap_read(pll->clkr.regmap, PLL_MODE(pll), &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (val & PLL_RESET_N)\n\t\treturn 0;\n\n\tvco = alpha_pll_find_vco(pll, clk_hw_get_rate(hw));\n\tif (!vco) {\n\t\tpr_err(\"%s: alpha pll not in a valid vco range\\n\", name);\n\t\treturn -EINVAL;\n\t}\n\n\tcal_freq = DIV_ROUND_CLOSEST((pll->vco_table[0].min_freq +\n\t\t\t\tpll->vco_table[0].max_freq) * 54, 100);\n\n\tparent_hw = clk_hw_get_parent(hw);\n\tif (!parent_hw)\n\t\treturn -EINVAL;\n\n\trrate = alpha_pll_round_rate(cal_freq, clk_hw_get_rate(parent_hw),\n\t\t\t\t\t&cal_l, &a, alpha_width);\n\n\tret = alpha_pll_check_rate_margin(hw, rrate, cal_freq);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tregmap_write(pll->clkr.regmap, PLL_CAL_L_VAL(pll), cal_l);\n\n\t \n\tret = clk_alpha_pll_enable(hw);\n\tif (ret) {\n\t\tpr_err(\"%s: alpha pll calibration failed\\n\", name);\n\t\treturn ret;\n\t}\n\n\tclk_alpha_pll_disable(hw);\n\n\treturn 0;\n}\n\nconst struct clk_ops clk_alpha_pll_fabia_ops = {\n\t.prepare = alpha_pll_fabia_prepare,\n\t.enable = alpha_pll_fabia_enable,\n\t.disable = alpha_pll_fabia_disable,\n\t.is_enabled = clk_alpha_pll_is_enabled,\n\t.set_rate = alpha_pll_fabia_set_rate,\n\t.recalc_rate = alpha_pll_fabia_recalc_rate,\n\t.round_rate = clk_alpha_pll_round_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_fabia_ops);\n\nconst struct clk_ops clk_alpha_pll_fixed_fabia_ops = {\n\t.enable = alpha_pll_fabia_enable,\n\t.disable = alpha_pll_fabia_disable,\n\t.is_enabled = clk_alpha_pll_is_enabled,\n\t.recalc_rate = alpha_pll_fabia_recalc_rate,\n\t.round_rate = clk_alpha_pll_round_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_fixed_fabia_ops);\n\nstatic unsigned long clk_alpha_pll_postdiv_fabia_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\n\tu32 i, div = 1, val;\n\tint ret;\n\n\tret = regmap_read(pll->clkr.regmap, PLL_USER_CTL(pll), &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval >>= pll->post_div_shift;\n\tval &= BIT(pll->width) - 1;\n\n\tfor (i = 0; i < pll->num_post_div; i++) {\n\t\tif (pll->post_div_table[i].val == val) {\n\t\t\tdiv = pll->post_div_table[i].div;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (parent_rate / div);\n}\n\nstatic unsigned long\nclk_trion_pll_postdiv_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\n\tstruct regmap *regmap = pll->clkr.regmap;\n\tu32 i, div = 1, val;\n\n\tregmap_read(regmap, PLL_USER_CTL(pll), &val);\n\n\tval >>= pll->post_div_shift;\n\tval &= PLL_POST_DIV_MASK(pll);\n\n\tfor (i = 0; i < pll->num_post_div; i++) {\n\t\tif (pll->post_div_table[i].val == val) {\n\t\t\tdiv = pll->post_div_table[i].div;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (parent_rate / div);\n}\n\nstatic long\nclk_trion_pll_postdiv_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long *prate)\n{\n\tstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\n\n\treturn divider_round_rate(hw, rate, prate, pll->post_div_table,\n\t\t\t\t  pll->width, CLK_DIVIDER_ROUND_CLOSEST);\n};\n\nstatic int\nclk_trion_pll_postdiv_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\n\tstruct regmap *regmap = pll->clkr.regmap;\n\tint i, val = 0, div;\n\n\tdiv = DIV_ROUND_UP_ULL(parent_rate, rate);\n\tfor (i = 0; i < pll->num_post_div; i++) {\n\t\tif (pll->post_div_table[i].div == div) {\n\t\t\tval = pll->post_div_table[i].val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn regmap_update_bits(regmap, PLL_USER_CTL(pll),\n\t\t\t\t  PLL_POST_DIV_MASK(pll) << PLL_POST_DIV_SHIFT,\n\t\t\t\t  val << PLL_POST_DIV_SHIFT);\n}\n\nconst struct clk_ops clk_alpha_pll_postdiv_trion_ops = {\n\t.recalc_rate = clk_trion_pll_postdiv_recalc_rate,\n\t.round_rate = clk_trion_pll_postdiv_round_rate,\n\t.set_rate = clk_trion_pll_postdiv_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_postdiv_trion_ops);\n\nstatic long clk_alpha_pll_postdiv_fabia_round_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long rate, unsigned long *prate)\n{\n\tstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\n\n\treturn divider_round_rate(hw, rate, prate, pll->post_div_table,\n\t\t\t\tpll->width, CLK_DIVIDER_ROUND_CLOSEST);\n}\n\nstatic int clk_alpha_pll_postdiv_fabia_set_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long rate, unsigned long parent_rate)\n{\n\tstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\n\tint i, val = 0, div, ret;\n\n\t \n\tret = regmap_read(pll->clkr.regmap, PLL_MODE(pll), &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & PLL_VOTE_FSM_ENA)\n\t\treturn 0;\n\n\tdiv = DIV_ROUND_UP_ULL(parent_rate, rate);\n\tfor (i = 0; i < pll->num_post_div; i++) {\n\t\tif (pll->post_div_table[i].div == div) {\n\t\t\tval = pll->post_div_table[i].val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn regmap_update_bits(pll->clkr.regmap, PLL_USER_CTL(pll),\n\t\t\t\t(BIT(pll->width) - 1) << pll->post_div_shift,\n\t\t\t\tval << pll->post_div_shift);\n}\n\nconst struct clk_ops clk_alpha_pll_postdiv_fabia_ops = {\n\t.recalc_rate = clk_alpha_pll_postdiv_fabia_recalc_rate,\n\t.round_rate = clk_alpha_pll_postdiv_fabia_round_rate,\n\t.set_rate = clk_alpha_pll_postdiv_fabia_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_postdiv_fabia_ops);\n\n \nvoid clk_trion_pll_configure(struct clk_alpha_pll *pll, struct regmap *regmap,\n\t\t\t     const struct alpha_pll_config *config)\n{\n\t \n\tif (trion_pll_is_enabled(pll, regmap)) {\n\t\tpr_debug(\"Trion PLL is already enabled, skipping configuration\\n\");\n\t\treturn;\n\t}\n\n\tclk_alpha_pll_write_config(regmap, PLL_L_VAL(pll), config->l);\n\tregmap_write(regmap, PLL_CAL_L_VAL(pll), TRION_PLL_CAL_VAL);\n\tclk_alpha_pll_write_config(regmap, PLL_ALPHA_VAL(pll), config->alpha);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL(pll),\n\t\t\t\t     config->config_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL_U(pll),\n\t\t\t\t     config->config_ctl_hi_val);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL_U1(pll),\n\t\t\t\t     config->config_ctl_hi1_val);\n\tclk_alpha_pll_write_config(regmap, PLL_USER_CTL(pll),\n\t\t\t\t\tconfig->user_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_USER_CTL_U(pll),\n\t\t\t\t\tconfig->user_ctl_hi_val);\n\tclk_alpha_pll_write_config(regmap, PLL_USER_CTL_U1(pll),\n\t\t\t\t\tconfig->user_ctl_hi1_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL(pll),\n\t\t\t\t\tconfig->test_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL_U(pll),\n\t\t\t\t\tconfig->test_ctl_hi_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL_U1(pll),\n\t\t\t\t\tconfig->test_ctl_hi1_val);\n\n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_UPDATE_BYPASS,\n\t\t\t   PLL_UPDATE_BYPASS);\n\n\t \n\tregmap_update_bits(regmap, PLL_MODE(pll),  PLL_OUTCTRL, 0);\n\n\t \n\tregmap_write(regmap, PLL_OPMODE(pll), PLL_STANDBY);\n\n\t \n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_RESET_N, PLL_RESET_N);\n}\nEXPORT_SYMBOL_GPL(clk_trion_pll_configure);\n\n \nstatic int __alpha_pll_trion_prepare(struct clk_hw *hw, u32 pcal_done)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 val;\n\tint ret;\n\n\t \n\tregmap_read(pll->clkr.regmap, PLL_STATUS(pll), &val);\n\tif (val & pcal_done)\n\t\treturn 0;\n\n\t \n\tret = clk_trion_pll_enable(hw);\n\tif (!ret)\n\t\tclk_trion_pll_disable(hw);\n\n\treturn ret;\n}\n\nstatic int alpha_pll_trion_prepare(struct clk_hw *hw)\n{\n\treturn __alpha_pll_trion_prepare(hw, TRION_PCAL_DONE);\n}\n\nstatic int alpha_pll_lucid_prepare(struct clk_hw *hw)\n{\n\treturn __alpha_pll_trion_prepare(hw, LUCID_PCAL_DONE);\n}\n\nstatic int __alpha_pll_trion_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long prate, u32 latch_bit, u32 latch_ack)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tunsigned long rrate;\n\tu32 val, l, alpha_width = pll_alpha_width(pll);\n\tu64 a;\n\tint ret;\n\n\trrate = alpha_pll_round_rate(rate, prate, &l, &a, alpha_width);\n\n\tret = alpha_pll_check_rate_margin(hw, rrate, rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregmap_write(pll->clkr.regmap, PLL_L_VAL(pll), l);\n\tregmap_write(pll->clkr.regmap, PLL_ALPHA_VAL(pll), a);\n\n\t \n\tret = regmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), latch_bit, latch_bit);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tudelay(1);\n\tregmap_read(pll->clkr.regmap, PLL_MODE(pll), &val);\n\tif (!(val & latch_ack)) {\n\t\tpr_err(\"Lucid PLL latch failed. Output may be unstable!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), latch_bit, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (clk_hw_is_enabled(hw)) {\n\t\tret = wait_for_pll_enable_lock(pll);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tudelay(100);\n\treturn 0;\n}\n\nstatic int alpha_pll_trion_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long prate)\n{\n\treturn __alpha_pll_trion_set_rate(hw, rate, prate, PLL_UPDATE, ALPHA_PLL_ACK_LATCH);\n}\n\nconst struct clk_ops clk_alpha_pll_trion_ops = {\n\t.prepare = alpha_pll_trion_prepare,\n\t.enable = clk_trion_pll_enable,\n\t.disable = clk_trion_pll_disable,\n\t.is_enabled = clk_trion_pll_is_enabled,\n\t.recalc_rate = clk_trion_pll_recalc_rate,\n\t.round_rate = clk_alpha_pll_round_rate,\n\t.set_rate = alpha_pll_trion_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_trion_ops);\n\nconst struct clk_ops clk_alpha_pll_lucid_ops = {\n\t.prepare = alpha_pll_lucid_prepare,\n\t.enable = clk_trion_pll_enable,\n\t.disable = clk_trion_pll_disable,\n\t.is_enabled = clk_trion_pll_is_enabled,\n\t.recalc_rate = clk_trion_pll_recalc_rate,\n\t.round_rate = clk_alpha_pll_round_rate,\n\t.set_rate = alpha_pll_trion_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_lucid_ops);\n\nconst struct clk_ops clk_alpha_pll_postdiv_lucid_ops = {\n\t.recalc_rate = clk_alpha_pll_postdiv_fabia_recalc_rate,\n\t.round_rate = clk_alpha_pll_postdiv_fabia_round_rate,\n\t.set_rate = clk_alpha_pll_postdiv_fabia_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_postdiv_lucid_ops);\n\nvoid clk_agera_pll_configure(struct clk_alpha_pll *pll, struct regmap *regmap,\n\t\t\tconst struct alpha_pll_config *config)\n{\n\tclk_alpha_pll_write_config(regmap, PLL_L_VAL(pll), config->l);\n\tclk_alpha_pll_write_config(regmap, PLL_ALPHA_VAL(pll), config->alpha);\n\tclk_alpha_pll_write_config(regmap, PLL_USER_CTL(pll),\n\t\t\t\t\t\t\tconfig->user_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL(pll),\n\t\t\t\t\t\tconfig->config_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL_U(pll),\n\t\t\t\t\t\tconfig->config_ctl_hi_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL(pll),\n\t\t\t\t\t\tconfig->test_ctl_val);\n\tclk_alpha_pll_write_config(regmap,  PLL_TEST_CTL_U(pll),\n\t\t\t\t\t\tconfig->test_ctl_hi_val);\n}\nEXPORT_SYMBOL_GPL(clk_agera_pll_configure);\n\nstatic int clk_alpha_pll_agera_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t\t\tunsigned long prate)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 l, alpha_width = pll_alpha_width(pll);\n\tint ret;\n\tunsigned long rrate;\n\tu64 a;\n\n\trrate = alpha_pll_round_rate(rate, prate, &l, &a, alpha_width);\n\tret = alpha_pll_check_rate_margin(hw, rrate, rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tregmap_write(pll->clkr.regmap, PLL_L_VAL(pll), l);\n\tregmap_write(pll->clkr.regmap, PLL_ALPHA_VAL(pll), a);\n\n\tif (clk_hw_is_enabled(hw))\n\t\treturn wait_for_pll_enable_lock(pll);\n\n\treturn 0;\n}\n\nconst struct clk_ops clk_alpha_pll_agera_ops = {\n\t.enable = clk_alpha_pll_enable,\n\t.disable = clk_alpha_pll_disable,\n\t.is_enabled = clk_alpha_pll_is_enabled,\n\t.recalc_rate = alpha_pll_fabia_recalc_rate,\n\t.round_rate = clk_alpha_pll_round_rate,\n\t.set_rate = clk_alpha_pll_agera_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_agera_ops);\n\nstatic int alpha_pll_lucid_5lpe_enable(struct clk_hw *hw)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(pll->clkr.regmap, PLL_USER_CTL(pll), &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (val & LUCID_5LPE_ENABLE_VOTE_RUN) {\n\t\tret = clk_enable_regmap(hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn wait_for_pll_enable_lock(pll);\n\t}\n\n\t \n\tret = trion_pll_is_enabled(pll, pll->clkr.regmap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), PLL_RESET_N, PLL_RESET_N);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_write(pll->clkr.regmap, PLL_OPMODE(pll), PLL_RUN);\n\n\tret = wait_for_pll_enable_lock(pll);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(pll->clkr.regmap, PLL_USER_CTL(pll), PLL_OUT_MASK, PLL_OUT_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), PLL_OUTCTRL, PLL_OUTCTRL);\n}\n\nstatic void alpha_pll_lucid_5lpe_disable(struct clk_hw *hw)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(pll->clkr.regmap, PLL_USER_CTL(pll), &val);\n\tif (ret)\n\t\treturn;\n\n\t \n\tif (val & LUCID_5LPE_ENABLE_VOTE_RUN) {\n\t\tclk_disable_regmap(hw);\n\t\treturn;\n\t}\n\n\t \n\tret = regmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), PLL_OUTCTRL, 0);\n\tif (ret)\n\t\treturn;\n\n\t \n\tret = regmap_update_bits(pll->clkr.regmap, PLL_USER_CTL(pll), PLL_OUT_MASK, 0);\n\tif (ret)\n\t\treturn;\n\n\t \n\tregmap_write(pll->clkr.regmap, PLL_OPMODE(pll), PLL_STANDBY);\n}\n\n \nstatic int alpha_pll_lucid_5lpe_prepare(struct clk_hw *hw)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tstruct clk_hw *p;\n\tu32 val = 0;\n\tint ret;\n\n\t \n\tregmap_read(pll->clkr.regmap, PLL_MODE(pll), &val);\n\tif (val & LUCID_5LPE_PCAL_DONE)\n\t\treturn 0;\n\n\tp = clk_hw_get_parent(hw);\n\tif (!p)\n\t\treturn -EINVAL;\n\n\tret = alpha_pll_lucid_5lpe_enable(hw);\n\tif (ret)\n\t\treturn ret;\n\n\talpha_pll_lucid_5lpe_disable(hw);\n\n\treturn 0;\n}\n\nstatic int alpha_pll_lucid_5lpe_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t unsigned long prate)\n{\n\treturn __alpha_pll_trion_set_rate(hw, rate, prate,\n\t\t\t\t\t  LUCID_5LPE_PLL_LATCH_INPUT,\n\t\t\t\t\t  LUCID_5LPE_ALPHA_PLL_ACK_LATCH);\n}\n\nstatic int __clk_lucid_pll_postdiv_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t    unsigned long parent_rate,\n\t\t\t\t\t    unsigned long enable_vote_run)\n{\n\tstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\n\tstruct regmap *regmap = pll->clkr.regmap;\n\tint i, val, div, ret;\n\tu32 mask;\n\n\t \n\tret = regmap_read(regmap, PLL_USER_CTL(pll), &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & enable_vote_run)\n\t\treturn 0;\n\n\tif (!pll->post_div_table) {\n\t\tpr_err(\"Missing the post_div_table for the %s PLL\\n\",\n\t\t       clk_hw_get_name(&pll->clkr.hw));\n\t\treturn -EINVAL;\n\t}\n\n\tdiv = DIV_ROUND_UP_ULL((u64)parent_rate, rate);\n\tfor (i = 0; i < pll->num_post_div; i++) {\n\t\tif (pll->post_div_table[i].div == div) {\n\t\t\tval = pll->post_div_table[i].val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmask = GENMASK(pll->width + pll->post_div_shift - 1, pll->post_div_shift);\n\treturn regmap_update_bits(pll->clkr.regmap, PLL_USER_CTL(pll),\n\t\t\t\t  mask, val << pll->post_div_shift);\n}\n\nstatic int clk_lucid_5lpe_pll_postdiv_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\treturn __clk_lucid_pll_postdiv_set_rate(hw, rate, parent_rate, LUCID_5LPE_ENABLE_VOTE_RUN);\n}\n\nconst struct clk_ops clk_alpha_pll_lucid_5lpe_ops = {\n\t.prepare = alpha_pll_lucid_5lpe_prepare,\n\t.enable = alpha_pll_lucid_5lpe_enable,\n\t.disable = alpha_pll_lucid_5lpe_disable,\n\t.is_enabled = clk_trion_pll_is_enabled,\n\t.recalc_rate = clk_trion_pll_recalc_rate,\n\t.round_rate = clk_alpha_pll_round_rate,\n\t.set_rate = alpha_pll_lucid_5lpe_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_lucid_5lpe_ops);\n\nconst struct clk_ops clk_alpha_pll_fixed_lucid_5lpe_ops = {\n\t.enable = alpha_pll_lucid_5lpe_enable,\n\t.disable = alpha_pll_lucid_5lpe_disable,\n\t.is_enabled = clk_trion_pll_is_enabled,\n\t.recalc_rate = clk_trion_pll_recalc_rate,\n\t.round_rate = clk_alpha_pll_round_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_fixed_lucid_5lpe_ops);\n\nconst struct clk_ops clk_alpha_pll_postdiv_lucid_5lpe_ops = {\n\t.recalc_rate = clk_alpha_pll_postdiv_fabia_recalc_rate,\n\t.round_rate = clk_alpha_pll_postdiv_fabia_round_rate,\n\t.set_rate = clk_lucid_5lpe_pll_postdiv_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_postdiv_lucid_5lpe_ops);\n\nvoid clk_zonda_pll_configure(struct clk_alpha_pll *pll, struct regmap *regmap,\n\t\t\t     const struct alpha_pll_config *config)\n{\n\tclk_alpha_pll_write_config(regmap, PLL_L_VAL(pll), config->l);\n\tclk_alpha_pll_write_config(regmap, PLL_ALPHA_VAL(pll), config->alpha);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL(pll), config->config_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL_U(pll), config->config_ctl_hi_val);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL_U1(pll), config->config_ctl_hi1_val);\n\tclk_alpha_pll_write_config(regmap, PLL_USER_CTL(pll), config->user_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_USER_CTL_U(pll), config->user_ctl_hi_val);\n\tclk_alpha_pll_write_config(regmap, PLL_USER_CTL_U1(pll), config->user_ctl_hi1_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL(pll), config->test_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL_U(pll), config->test_ctl_hi_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL_U1(pll), config->test_ctl_hi1_val);\n\n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_BYPASSNL, 0);\n\n\t \n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_OUTCTRL, 0);\n\n\t \n\tregmap_write(regmap, PLL_OPMODE(pll), PLL_STANDBY);\n\n\t \n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_RESET_N, PLL_RESET_N);\n}\nEXPORT_SYMBOL_GPL(clk_zonda_pll_configure);\n\nstatic int clk_zonda_pll_enable(struct clk_hw *hw)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tstruct regmap *regmap = pll->clkr.regmap;\n\tu32 val;\n\tint ret;\n\n\tregmap_read(regmap, PLL_MODE(pll), &val);\n\n\t \n\tif (val & PLL_VOTE_FSM_ENA) {\n\t\tret = clk_enable_regmap(hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn wait_for_pll_enable_active(pll);\n\t}\n\n\t \n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_BYPASSNL, PLL_BYPASSNL);\n\n\t \n\tudelay(1);\n\n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_RESET_N, PLL_RESET_N);\n\n\t \n\tregmap_write(regmap, PLL_OPMODE(pll), PLL_RUN);\n\n\tregmap_read(regmap, PLL_TEST_CTL(pll), &val);\n\n\t \n\tif (val & ZONDA_STAY_IN_CFA)\n\t\tret = wait_for_zonda_pll_freq_lock(pll);\n\telse\n\t\tret = wait_for_pll_enable_lock(pll);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_update_bits(regmap, PLL_USER_CTL(pll), ZONDA_PLL_OUT_MASK, ZONDA_PLL_OUT_MASK);\n\n\t \n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_OUTCTRL, PLL_OUTCTRL);\n\n\treturn 0;\n}\n\nstatic void clk_zonda_pll_disable(struct clk_hw *hw)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tstruct regmap *regmap = pll->clkr.regmap;\n\tu32 val;\n\n\tregmap_read(regmap, PLL_MODE(pll), &val);\n\n\t \n\tif (val & PLL_VOTE_FSM_ENA) {\n\t\tclk_disable_regmap(hw);\n\t\treturn;\n\t}\n\n\t \n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_OUTCTRL, 0);\n\n\t \n\tregmap_update_bits(regmap, PLL_USER_CTL(pll), ZONDA_PLL_OUT_MASK, 0);\n\n\t \n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_RESET_N | PLL_BYPASSNL, 0);\n\n\t \n\tregmap_write(regmap, PLL_OPMODE(pll), 0x0);\n}\n\nstatic int clk_zonda_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long prate)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tunsigned long rrate;\n\tu32 test_ctl_val;\n\tu32 l, alpha_width = pll_alpha_width(pll);\n\tu64 a;\n\tint ret;\n\n\trrate = alpha_pll_round_rate(rate, prate, &l, &a, alpha_width);\n\n\tret = alpha_pll_check_rate_margin(hw, rrate, rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregmap_write(pll->clkr.regmap, PLL_ALPHA_VAL(pll), a);\n\tregmap_write(pll->clkr.regmap, PLL_L_VAL(pll), l);\n\n\t \n\tudelay(5);\n\n\t \n\tregmap_read(pll->clkr.regmap, PLL_TEST_CTL(pll), &test_ctl_val);\n\n\t \n\tif (test_ctl_val & ZONDA_STAY_IN_CFA)\n\t\tret = wait_for_zonda_pll_freq_lock(pll);\n\telse\n\t\tret = wait_for_pll_enable_lock(pll);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tudelay(100);\n\treturn 0;\n}\n\nconst struct clk_ops clk_alpha_pll_zonda_ops = {\n\t.enable = clk_zonda_pll_enable,\n\t.disable = clk_zonda_pll_disable,\n\t.is_enabled = clk_trion_pll_is_enabled,\n\t.recalc_rate = clk_trion_pll_recalc_rate,\n\t.round_rate = clk_alpha_pll_round_rate,\n\t.set_rate = clk_zonda_pll_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_zonda_ops);\n\nvoid clk_lucid_evo_pll_configure(struct clk_alpha_pll *pll, struct regmap *regmap,\n\t\t\t\t const struct alpha_pll_config *config)\n{\n\tu32 lval = config->l;\n\n\tlval |= TRION_PLL_CAL_VAL << LUCID_EVO_PLL_CAL_L_VAL_SHIFT;\n\tclk_alpha_pll_write_config(regmap, PLL_L_VAL(pll), lval);\n\tclk_alpha_pll_write_config(regmap, PLL_ALPHA_VAL(pll), config->alpha);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL(pll), config->config_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL_U(pll), config->config_ctl_hi_val);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL_U1(pll), config->config_ctl_hi1_val);\n\tclk_alpha_pll_write_config(regmap, PLL_USER_CTL(pll), config->user_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_USER_CTL_U(pll), config->user_ctl_hi_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL(pll), config->test_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL_U(pll), config->test_ctl_hi_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL_U1(pll), config->test_ctl_hi1_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL_U2(pll), config->test_ctl_hi2_val);\n\n\t \n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_OUTCTRL, 0);\n\n\t \n\tregmap_write(regmap, PLL_OPMODE(pll), PLL_STANDBY);\n\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_RESET_N, PLL_RESET_N);\n}\nEXPORT_SYMBOL_GPL(clk_lucid_evo_pll_configure);\n\nstatic int alpha_pll_lucid_evo_enable(struct clk_hw *hw)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tstruct regmap *regmap = pll->clkr.regmap;\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(regmap, PLL_USER_CTL(pll), &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (val & LUCID_EVO_ENABLE_VOTE_RUN) {\n\t\tret = clk_enable_regmap(hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn wait_for_pll_enable_lock(pll);\n\t}\n\n\t \n\tret = trion_pll_is_enabled(pll, regmap);\n\tif (ret < 0) {\n\t\treturn ret;\n\t} else if (ret) {\n\t\tpr_warn(\"%s PLL is already enabled\\n\", clk_hw_get_name(&pll->clkr.hw));\n\t\treturn 0;\n\t}\n\n\tret = regmap_update_bits(regmap, PLL_MODE(pll), PLL_RESET_N, PLL_RESET_N);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_write(regmap, PLL_OPMODE(pll), PLL_RUN);\n\n\tret = wait_for_pll_enable_lock(pll);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(regmap, PLL_USER_CTL(pll), PLL_OUT_MASK, PLL_OUT_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(regmap, PLL_MODE(pll), PLL_OUTCTRL, PLL_OUTCTRL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmb();\n\treturn ret;\n}\n\nstatic void _alpha_pll_lucid_evo_disable(struct clk_hw *hw, bool reset)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tstruct regmap *regmap = pll->clkr.regmap;\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(regmap, PLL_USER_CTL(pll), &val);\n\tif (ret)\n\t\treturn;\n\n\t \n\tif (val & LUCID_EVO_ENABLE_VOTE_RUN) {\n\t\tclk_disable_regmap(hw);\n\t\treturn;\n\t}\n\n\t \n\tret = regmap_update_bits(regmap, PLL_MODE(pll), PLL_OUTCTRL, 0);\n\tif (ret)\n\t\treturn;\n\n\t \n\tret = regmap_update_bits(regmap, PLL_USER_CTL(pll), PLL_OUT_MASK, 0);\n\tif (ret)\n\t\treturn;\n\n\t \n\tregmap_write(regmap, PLL_OPMODE(pll), PLL_STANDBY);\n\n\tif (reset)\n\t\tregmap_update_bits(regmap, PLL_MODE(pll), PLL_RESET_N, 0);\n}\n\nstatic int _alpha_pll_lucid_evo_prepare(struct clk_hw *hw, bool reset)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tstruct clk_hw *p;\n\tu32 val = 0;\n\tint ret;\n\n\t \n\tregmap_read(pll->clkr.regmap, PLL_MODE(pll), &val);\n\tif (!(val & LUCID_EVO_PCAL_NOT_DONE))\n\t\treturn 0;\n\n\tp = clk_hw_get_parent(hw);\n\tif (!p)\n\t\treturn -EINVAL;\n\n\tret = alpha_pll_lucid_evo_enable(hw);\n\tif (ret)\n\t\treturn ret;\n\n\t_alpha_pll_lucid_evo_disable(hw, reset);\n\n\treturn 0;\n}\n\nstatic void alpha_pll_lucid_evo_disable(struct clk_hw *hw)\n{\n\t_alpha_pll_lucid_evo_disable(hw, false);\n}\n\nstatic int alpha_pll_lucid_evo_prepare(struct clk_hw *hw)\n{\n\treturn _alpha_pll_lucid_evo_prepare(hw, false);\n}\n\nstatic void alpha_pll_reset_lucid_evo_disable(struct clk_hw *hw)\n{\n\t_alpha_pll_lucid_evo_disable(hw, true);\n}\n\nstatic int alpha_pll_reset_lucid_evo_prepare(struct clk_hw *hw)\n{\n\treturn _alpha_pll_lucid_evo_prepare(hw, true);\n}\n\nstatic unsigned long alpha_pll_lucid_evo_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tstruct regmap *regmap = pll->clkr.regmap;\n\tu32 l, frac;\n\n\tregmap_read(regmap, PLL_L_VAL(pll), &l);\n\tl &= LUCID_EVO_PLL_L_VAL_MASK;\n\tregmap_read(regmap, PLL_ALPHA_VAL(pll), &frac);\n\n\treturn alpha_pll_calc_rate(parent_rate, l, frac, pll_alpha_width(pll));\n}\n\nstatic int clk_lucid_evo_pll_postdiv_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\treturn __clk_lucid_pll_postdiv_set_rate(hw, rate, parent_rate, LUCID_EVO_ENABLE_VOTE_RUN);\n}\n\nconst struct clk_ops clk_alpha_pll_fixed_lucid_evo_ops = {\n\t.enable = alpha_pll_lucid_evo_enable,\n\t.disable = alpha_pll_lucid_evo_disable,\n\t.is_enabled = clk_trion_pll_is_enabled,\n\t.recalc_rate = alpha_pll_lucid_evo_recalc_rate,\n\t.round_rate = clk_alpha_pll_round_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_fixed_lucid_evo_ops);\n\nconst struct clk_ops clk_alpha_pll_postdiv_lucid_evo_ops = {\n\t.recalc_rate = clk_alpha_pll_postdiv_fabia_recalc_rate,\n\t.round_rate = clk_alpha_pll_postdiv_fabia_round_rate,\n\t.set_rate = clk_lucid_evo_pll_postdiv_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_postdiv_lucid_evo_ops);\n\nconst struct clk_ops clk_alpha_pll_lucid_evo_ops = {\n\t.prepare = alpha_pll_lucid_evo_prepare,\n\t.enable = alpha_pll_lucid_evo_enable,\n\t.disable = alpha_pll_lucid_evo_disable,\n\t.is_enabled = clk_trion_pll_is_enabled,\n\t.recalc_rate = alpha_pll_lucid_evo_recalc_rate,\n\t.round_rate = clk_alpha_pll_round_rate,\n\t.set_rate = alpha_pll_lucid_5lpe_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_lucid_evo_ops);\n\nconst struct clk_ops clk_alpha_pll_reset_lucid_evo_ops = {\n\t.prepare = alpha_pll_reset_lucid_evo_prepare,\n\t.enable = alpha_pll_lucid_evo_enable,\n\t.disable = alpha_pll_reset_lucid_evo_disable,\n\t.is_enabled = clk_trion_pll_is_enabled,\n\t.recalc_rate = alpha_pll_lucid_evo_recalc_rate,\n\t.round_rate = clk_alpha_pll_round_rate,\n\t.set_rate = alpha_pll_lucid_5lpe_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_reset_lucid_evo_ops);\n\nvoid clk_rivian_evo_pll_configure(struct clk_alpha_pll *pll, struct regmap *regmap,\n\t\t\t\t  const struct alpha_pll_config *config)\n{\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL(pll), config->config_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL_U(pll), config->config_ctl_hi_val);\n\tclk_alpha_pll_write_config(regmap, PLL_CONFIG_CTL_U1(pll), config->config_ctl_hi1_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL(pll), config->test_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_TEST_CTL_U(pll), config->test_ctl_hi_val);\n\tclk_alpha_pll_write_config(regmap, PLL_L_VAL(pll), config->l);\n\tclk_alpha_pll_write_config(regmap, PLL_USER_CTL(pll), config->user_ctl_val);\n\tclk_alpha_pll_write_config(regmap, PLL_USER_CTL_U(pll), config->user_ctl_hi_val);\n\n\tregmap_write(regmap, PLL_OPMODE(pll), PLL_STANDBY);\n\n\tregmap_update_bits(regmap, PLL_MODE(pll),\n\t\t\t   PLL_RESET_N | PLL_BYPASSNL | PLL_OUTCTRL,\n\t\t\t   PLL_RESET_N | PLL_BYPASSNL);\n}\nEXPORT_SYMBOL_GPL(clk_rivian_evo_pll_configure);\n\nstatic unsigned long clk_rivian_evo_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 l;\n\n\tregmap_read(pll->clkr.regmap, PLL_L_VAL(pll), &l);\n\n\treturn parent_rate * l;\n}\n\nstatic long clk_rivian_evo_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t  unsigned long *prate)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tunsigned long min_freq, max_freq;\n\tu32 l;\n\tu64 a;\n\n\trate = alpha_pll_round_rate(rate, *prate, &l, &a, 0);\n\tif (!pll->vco_table || alpha_pll_find_vco(pll, rate))\n\t\treturn rate;\n\n\tmin_freq = pll->vco_table[0].min_freq;\n\tmax_freq = pll->vco_table[pll->num_vco - 1].max_freq;\n\n\treturn clamp(rate, min_freq, max_freq);\n}\n\nconst struct clk_ops clk_alpha_pll_rivian_evo_ops = {\n\t.enable = alpha_pll_lucid_5lpe_enable,\n\t.disable = alpha_pll_lucid_5lpe_disable,\n\t.is_enabled = clk_trion_pll_is_enabled,\n\t.recalc_rate = clk_rivian_evo_pll_recalc_rate,\n\t.round_rate = clk_rivian_evo_pll_round_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_rivian_evo_ops);\n\nvoid clk_stromer_pll_configure(struct clk_alpha_pll *pll, struct regmap *regmap,\n\t\t\t       const struct alpha_pll_config *config)\n{\n\tu32 val, val_u, mask, mask_u;\n\n\tregmap_write(regmap, PLL_L_VAL(pll), config->l);\n\tregmap_write(regmap, PLL_ALPHA_VAL(pll), config->alpha);\n\tregmap_write(regmap, PLL_CONFIG_CTL(pll), config->config_ctl_val);\n\n\tif (pll_has_64bit_config(pll))\n\t\tregmap_write(regmap, PLL_CONFIG_CTL_U(pll),\n\t\t\t     config->config_ctl_hi_val);\n\n\tif (pll_alpha_width(pll) > 32)\n\t\tregmap_write(regmap, PLL_ALPHA_VAL_U(pll), config->alpha_hi);\n\n\tval = config->main_output_mask;\n\tval |= config->aux_output_mask;\n\tval |= config->aux2_output_mask;\n\tval |= config->early_output_mask;\n\tval |= config->pre_div_val;\n\tval |= config->post_div_val;\n\tval |= config->vco_val;\n\tval |= config->alpha_en_mask;\n\tval |= config->alpha_mode_mask;\n\n\tmask = config->main_output_mask;\n\tmask |= config->aux_output_mask;\n\tmask |= config->aux2_output_mask;\n\tmask |= config->early_output_mask;\n\tmask |= config->pre_div_mask;\n\tmask |= config->post_div_mask;\n\tmask |= config->vco_mask;\n\tmask |= config->alpha_en_mask;\n\tmask |= config->alpha_mode_mask;\n\n\tregmap_update_bits(regmap, PLL_USER_CTL(pll), mask, val);\n\n\t \n\tval_u = config->status_val << ALPHA_PLL_STATUS_REG_SHIFT;\n\tval_u |= config->lock_det;\n\n\tmask_u = config->status_mask;\n\tmask_u |= config->lock_det;\n\n\tregmap_update_bits(regmap, PLL_USER_CTL_U(pll), mask_u, val_u);\n\tregmap_write(regmap, PLL_TEST_CTL(pll), config->test_ctl_val);\n\tregmap_write(regmap, PLL_TEST_CTL_U(pll), config->test_ctl_hi_val);\n\n\tif (pll->flags & SUPPORTS_FSM_MODE)\n\t\tqcom_pll_set_fsm_mode(regmap, PLL_MODE(pll), 6, 0);\n}\nEXPORT_SYMBOL_GPL(clk_stromer_pll_configure);\n\nstatic int clk_alpha_pll_stromer_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t\tstruct clk_rate_request *req)\n{\n\tu32 l;\n\tu64 a;\n\n\treq->rate = alpha_pll_round_rate(req->rate, req->best_parent_rate,\n\t\t\t\t\t &l, &a, ALPHA_REG_BITWIDTH);\n\n\treturn 0;\n}\n\nstatic int clk_alpha_pll_stromer_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t  unsigned long prate)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tint ret;\n\tu32 l;\n\tu64 a;\n\n\trate = alpha_pll_round_rate(rate, prate, &l, &a, ALPHA_REG_BITWIDTH);\n\n\tregmap_write(pll->clkr.regmap, PLL_L_VAL(pll), l);\n\tregmap_write(pll->clkr.regmap, PLL_ALPHA_VAL(pll), a);\n\tregmap_write(pll->clkr.regmap, PLL_ALPHA_VAL_U(pll),\n\t\t     a >> ALPHA_BITWIDTH);\n\n\tregmap_update_bits(pll->clkr.regmap, PLL_USER_CTL(pll),\n\t\t\t   PLL_ALPHA_EN, PLL_ALPHA_EN);\n\n\tif (!clk_hw_is_enabled(hw))\n\t\treturn 0;\n\n\t \n\tregmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), PLL_UPDATE,\n\t\t\t   PLL_UPDATE);\n\n\tret = wait_for_pll_update(pll);\n\tif (ret)\n\t\treturn ret;\n\n\treturn wait_for_pll_enable_lock(pll);\n}\n\nconst struct clk_ops clk_alpha_pll_stromer_ops = {\n\t.enable = clk_alpha_pll_enable,\n\t.disable = clk_alpha_pll_disable,\n\t.is_enabled = clk_alpha_pll_is_enabled,\n\t.recalc_rate = clk_alpha_pll_recalc_rate,\n\t.determine_rate = clk_alpha_pll_stromer_determine_rate,\n\t.set_rate = clk_alpha_pll_stromer_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_stromer_ops);\n\nstatic int clk_alpha_pll_stromer_plus_set_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long rate,\n\t\t\t\t\t       unsigned long prate)\n{\n\tstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\n\tu32 l, alpha_width = pll_alpha_width(pll);\n\tint ret, pll_mode;\n\tu64 a;\n\n\trate = alpha_pll_round_rate(rate, prate, &l, &a, alpha_width);\n\n\tret = regmap_read(pll->clkr.regmap, PLL_MODE(pll), &pll_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_write(pll->clkr.regmap, PLL_MODE(pll), 0);\n\n\t \n\tudelay(1);\n\n\tregmap_write(pll->clkr.regmap, PLL_L_VAL(pll), l);\n\n\tif (alpha_width > ALPHA_BITWIDTH)\n\t\ta <<= alpha_width - ALPHA_BITWIDTH;\n\n\tregmap_write(pll->clkr.regmap, PLL_ALPHA_VAL(pll), a);\n\tregmap_write(pll->clkr.regmap, PLL_ALPHA_VAL_U(pll),\n\t\t\t\t\ta >> ALPHA_BITWIDTH);\n\n\tregmap_write(pll->clkr.regmap, PLL_MODE(pll), PLL_BYPASSNL);\n\n\t \n\tudelay(5);\n\tregmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), PLL_RESET_N,\n\t\t\t   PLL_RESET_N);\n\n\t \n\tusleep_range(50, 60);\n\n\tret = wait_for_pll_enable_lock(pll);\n\tif (ret) {\n\t\tpr_err(\"Wait for PLL enable lock failed [%s] %d\\n\",\n\t\t       clk_hw_get_name(hw), ret);\n\t\treturn ret;\n\t}\n\n\tif (pll_mode & PLL_OUTCTRL)\n\t\tregmap_update_bits(pll->clkr.regmap, PLL_MODE(pll), PLL_OUTCTRL,\n\t\t\t\t   PLL_OUTCTRL);\n\n\treturn 0;\n}\n\nconst struct clk_ops clk_alpha_pll_stromer_plus_ops = {\n\t.prepare = clk_alpha_pll_enable,\n\t.unprepare = clk_alpha_pll_disable,\n\t.is_enabled = clk_alpha_pll_is_enabled,\n\t.recalc_rate = clk_alpha_pll_recalc_rate,\n\t.determine_rate = clk_alpha_pll_stromer_determine_rate,\n\t.set_rate = clk_alpha_pll_stromer_plus_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_alpha_pll_stromer_plus_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}