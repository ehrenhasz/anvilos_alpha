{
  "module_name": "lcc-msm8960.c",
  "hash_id": "5674462630a2cb45f4457c64d5b46f84308ca387b3780c5e50b22feffd16c9b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/lcc-msm8960.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/clk-provider.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/clock/qcom,lcc-msm8960.h>\n\n#include \"common.h\"\n#include \"clk-regmap.h\"\n#include \"clk-pll.h\"\n#include \"clk-rcg.h\"\n#include \"clk-branch.h\"\n#include \"clk-regmap-divider.h\"\n#include \"clk-regmap-mux.h\"\n\nstatic struct clk_parent_data pxo_parent_data = {\n\t.fw_name = \"pxo\", .name = \"pxo_board\",\n};\n\nstatic struct clk_pll pll4 = {\n\t.l_reg = 0x4,\n\t.m_reg = 0x8,\n\t.n_reg = 0xc,\n\t.config_reg = 0x14,\n\t.mode_reg = 0x0,\n\t.status_reg = 0x18,\n\t.status_bit = 16,\n\t.clkr.hw.init = &(struct clk_init_data){\n\t\t.name = \"pll4\",\n\t\t.parent_data = &pxo_parent_data,\n\t\t.num_parents = 1,\n\t\t.ops = &clk_pll_ops,\n\t},\n};\n\nenum {\n\tP_PXO,\n\tP_PLL4,\n};\n\nstatic const struct parent_map lcc_pxo_pll4_map[] = {\n\t{ P_PXO, 0 },\n\t{ P_PLL4, 2 }\n};\n\nstatic struct clk_parent_data lcc_pxo_pll4[] = {\n\t{ .fw_name = \"pxo\", .name = \"pxo_board\" },\n\t{ .fw_name = \"pll4_vote\", .name = \"pll4_vote\" },\n};\n\nstatic struct freq_tbl clk_tbl_aif_osr_492[] = {\n\t{   512000, P_PLL4, 4, 1, 240 },\n\t{   768000, P_PLL4, 4, 1, 160 },\n\t{  1024000, P_PLL4, 4, 1, 120 },\n\t{  1536000, P_PLL4, 4, 1,  80 },\n\t{  2048000, P_PLL4, 4, 1,  60 },\n\t{  3072000, P_PLL4, 4, 1,  40 },\n\t{  4096000, P_PLL4, 4, 1,  30 },\n\t{  6144000, P_PLL4, 4, 1,  20 },\n\t{  8192000, P_PLL4, 4, 1,  15 },\n\t{ 12288000, P_PLL4, 4, 1,  10 },\n\t{ 24576000, P_PLL4, 4, 1,   5 },\n\t{ 27000000, P_PXO,  1, 0,   0 },\n\t{ }\n};\n\nstatic struct freq_tbl clk_tbl_aif_osr_393[] = {\n\t{   512000, P_PLL4, 4, 1, 192 },\n\t{   768000, P_PLL4, 4, 1, 128 },\n\t{  1024000, P_PLL4, 4, 1,  96 },\n\t{  1536000, P_PLL4, 4, 1,  64 },\n\t{  2048000, P_PLL4, 4, 1,  48 },\n\t{  3072000, P_PLL4, 4, 1,  32 },\n\t{  4096000, P_PLL4, 4, 1,  24 },\n\t{  6144000, P_PLL4, 4, 1,  16 },\n\t{  8192000, P_PLL4, 4, 1,  12 },\n\t{ 12288000, P_PLL4, 4, 1,   8 },\n\t{ 24576000, P_PLL4, 4, 1,   4 },\n\t{ 27000000, P_PXO,  1, 0,   0 },\n\t{ }\n};\n\n#define CLK_AIF_OSR_SRC(prefix, _ns, _md)\t\t\t\\\nstatic struct clk_rcg prefix##_osr_src = {\t\t\t\\\n\t.ns_reg = _ns,\t\t\t\t\t\t\\\n\t.md_reg = _md,\t\t\t\t\t\t\\\n\t.mn = {\t\t\t\t\t\t\t\\\n\t\t.mnctr_en_bit = 8,\t\t\t\t\\\n\t\t.mnctr_reset_bit = 7,\t\t\t\t\\\n\t\t.mnctr_mode_shift = 5,\t\t\t\t\\\n\t\t.n_val_shift = 24,\t\t\t\t\\\n\t\t.m_val_shift = 8,\t\t\t\t\\\n\t\t.width = 8,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.p = {\t\t\t\t\t\t\t\\\n\t\t.pre_div_shift = 3,\t\t\t\t\\\n\t\t.pre_div_width = 2,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.s = {\t\t\t\t\t\t\t\\\n\t\t.src_sel_shift = 0,\t\t\t\t\\\n\t\t.parent_map = lcc_pxo_pll4_map,\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.freq_tbl = clk_tbl_aif_osr_393,\t\t\t\\\n\t.clkr = {\t\t\t\t\t\t\\\n\t\t.enable_reg = _ns,\t\t\t\t\\\n\t\t.enable_mask = BIT(9),\t\t\t\t\\\n\t\t.hw.init = &(struct clk_init_data){\t\t\\\n\t\t\t.name = #prefix \"_osr_src\",\t\t\\\n\t\t\t.parent_data = lcc_pxo_pll4,\t\t\\\n\t\t\t.num_parents = ARRAY_SIZE(lcc_pxo_pll4), \\\n\t\t\t.ops = &clk_rcg_ops,\t\t\t\\\n\t\t\t.flags = CLK_SET_RATE_GATE,\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n};\t\t\t\t\t\t\t\t\\\n\n#define CLK_AIF_OSR_CLK(prefix, _ns, hr, en_bit)\t\t\\\nstatic struct clk_branch prefix##_osr_clk = {\t\t\t\\\n\t.halt_reg = hr,\t\t\t\t\t\t\\\n\t.halt_bit = 1,\t\t\t\t\t\t\\\n\t.halt_check = BRANCH_HALT_ENABLE,\t\t\t\\\n\t.clkr = {\t\t\t\t\t\t\\\n\t\t.enable_reg = _ns,\t\t\t\t\\\n\t\t.enable_mask = BIT(en_bit),\t\t\t\\\n\t\t.hw.init = &(struct clk_init_data){\t\t\\\n\t\t\t.name = #prefix \"_osr_clk\",\t\t\\\n\t\t\t.parent_hws = (const struct clk_hw*[]){\t\\\n\t\t\t\t&prefix##_osr_src.clkr.hw,\t\\\n\t\t\t},\t\t\t\t\t\\\n\t\t\t.num_parents = 1,\t\t\t\\\n\t\t\t.ops = &clk_branch_ops,\t\t\t\\\n\t\t\t.flags = CLK_SET_RATE_PARENT,\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n};\t\t\t\t\t\t\t\t\\\n\n#define CLK_AIF_OSR_DIV_CLK(prefix, _ns, _width)\t\t\\\nstatic struct clk_regmap_div prefix##_div_clk = {\t\t\\\n\t.reg = _ns,\t\t\t\t\t\t\\\n\t.shift = 10,\t\t\t\t\t\t\\\n\t.width = _width,\t\t\t\t\t\\\n\t.clkr = {\t\t\t\t\t\t\\\n\t\t.hw.init = &(struct clk_init_data){\t\t\\\n\t\t\t.name = #prefix \"_div_clk\",\t\t\\\n\t\t\t.parent_hws = (const struct clk_hw*[]){\t\\\n\t\t\t\t&prefix##_osr_src.clkr.hw,\t\\\n\t\t\t},\t\t\t\t\t\\\n\t\t\t.num_parents = 1,\t\t\t\\\n\t\t\t.ops = &clk_regmap_div_ops,\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n};\t\t\t\t\t\t\t\t\\\n\n#define CLK_AIF_OSR_BIT_DIV_CLK(prefix, _ns, hr, en_bit)\t\\\nstatic struct clk_branch prefix##_bit_div_clk = {\t\t\\\n\t.halt_reg = hr,\t\t\t\t\t\t\\\n\t.halt_bit = 0,\t\t\t\t\t\t\\\n\t.halt_check = BRANCH_HALT_ENABLE,\t\t\t\\\n\t.clkr = {\t\t\t\t\t\t\\\n\t\t.enable_reg = _ns,\t\t\t\t\\\n\t\t.enable_mask = BIT(en_bit),\t\t\t\\\n\t\t.hw.init = &(struct clk_init_data){\t\t\\\n\t\t\t.name = #prefix \"_bit_div_clk\",\t\t\\\n\t\t\t.parent_hws = (const struct clk_hw*[]){\t\\\n\t\t\t\t&prefix##_div_clk.clkr.hw,\t\\\n\t\t\t},\t\t\t\t\t\\\n\t\t\t.num_parents = 1,\t\t\t\\\n\t\t\t.ops = &clk_branch_ops,\t\t\t\\\n\t\t\t.flags = CLK_SET_RATE_PARENT,\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n};\t\t\t\t\t\t\t\t\\\n\n#define CLK_AIF_OSR_BIT_CLK(prefix, _ns, _shift)\t\t\\\nstatic struct clk_regmap_mux prefix##_bit_clk = {\t\t\\\n\t.reg = _ns,\t\t\t\t\t\t\\\n\t.shift = _shift,\t\t\t\t\t\\\n\t.width = 1,\t\t\t\t\t\t\\\n\t.clkr = {\t\t\t\t\t\t\\\n\t\t.hw.init = &(struct clk_init_data){\t\t\\\n\t\t\t.name = #prefix \"_bit_clk\",\t\t\\\n\t\t\t.parent_data = (const struct clk_parent_data[]){ \\\n\t\t\t\t{ .hw = &prefix##_bit_div_clk.clkr.hw, }, \\\n\t\t\t\t{ .fw_name = #prefix \"_codec_clk\", \\\n\t\t\t\t  .name = #prefix \"_codec_clk\", }, \\\n\t\t\t},\t\t\t\t\t\\\n\t\t\t.num_parents = 2,\t\t\t\\\n\t\t\t.ops = &clk_regmap_mux_closest_ops,\t\\\n\t\t\t.flags = CLK_SET_RATE_PARENT,\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n};\n\nCLK_AIF_OSR_SRC(mi2s, 0x48, 0x4c)\nCLK_AIF_OSR_CLK(mi2s, 0x48, 0x50, 17)\nCLK_AIF_OSR_DIV_CLK(mi2s, 0x48, 4)\nCLK_AIF_OSR_BIT_DIV_CLK(mi2s, 0x48, 0x50, 15)\nCLK_AIF_OSR_BIT_CLK(mi2s, 0x48, 14)\n\n#define CLK_AIF_OSR_DIV(prefix, _ns, _md, hr)\t\t\t\\\n\tCLK_AIF_OSR_SRC(prefix, _ns, _md)\t\t\t\\\n\tCLK_AIF_OSR_CLK(prefix, _ns, hr, 21)\t\t\t\\\n\tCLK_AIF_OSR_DIV_CLK(prefix, _ns, 8)\t\t\t\\\n\tCLK_AIF_OSR_BIT_DIV_CLK(prefix, _ns, hr, 19)\t\t\\\n\tCLK_AIF_OSR_BIT_CLK(prefix, _ns, 18)\n\nCLK_AIF_OSR_DIV(codec_i2s_mic, 0x60, 0x64, 0x68);\nCLK_AIF_OSR_DIV(spare_i2s_mic, 0x78, 0x7c, 0x80);\nCLK_AIF_OSR_DIV(codec_i2s_spkr, 0x6c, 0x70, 0x74);\nCLK_AIF_OSR_DIV(spare_i2s_spkr, 0x84, 0x88, 0x8c);\n\nstatic struct freq_tbl clk_tbl_pcm_492[] = {\n\t{   256000, P_PLL4, 4, 1, 480 },\n\t{   512000, P_PLL4, 4, 1, 240 },\n\t{   768000, P_PLL4, 4, 1, 160 },\n\t{  1024000, P_PLL4, 4, 1, 120 },\n\t{  1536000, P_PLL4, 4, 1,  80 },\n\t{  2048000, P_PLL4, 4, 1,  60 },\n\t{  3072000, P_PLL4, 4, 1,  40 },\n\t{  4096000, P_PLL4, 4, 1,  30 },\n\t{  6144000, P_PLL4, 4, 1,  20 },\n\t{  8192000, P_PLL4, 4, 1,  15 },\n\t{ 12288000, P_PLL4, 4, 1,  10 },\n\t{ 24576000, P_PLL4, 4, 1,   5 },\n\t{ 27000000, P_PXO,  1, 0,   0 },\n\t{ }\n};\n\nstatic struct freq_tbl clk_tbl_pcm_393[] = {\n\t{   256000, P_PLL4, 4, 1, 384 },\n\t{   512000, P_PLL4, 4, 1, 192 },\n\t{   768000, P_PLL4, 4, 1, 128 },\n\t{  1024000, P_PLL4, 4, 1,  96 },\n\t{  1536000, P_PLL4, 4, 1,  64 },\n\t{  2048000, P_PLL4, 4, 1,  48 },\n\t{  3072000, P_PLL4, 4, 1,  32 },\n\t{  4096000, P_PLL4, 4, 1,  24 },\n\t{  6144000, P_PLL4, 4, 1,  16 },\n\t{  8192000, P_PLL4, 4, 1,  12 },\n\t{ 12288000, P_PLL4, 4, 1,   8 },\n\t{ 24576000, P_PLL4, 4, 1,   4 },\n\t{ 27000000, P_PXO,  1, 0,   0 },\n\t{ }\n};\n\nstatic struct clk_rcg pcm_src = {\n\t.ns_reg = 0x54,\n\t.md_reg = 0x58,\n\t.mn = {\n\t\t.mnctr_en_bit = 8,\n\t\t.mnctr_reset_bit = 7,\n\t\t.mnctr_mode_shift = 5,\n\t\t.n_val_shift = 16,\n\t\t.m_val_shift = 16,\n\t\t.width = 16,\n\t},\n\t.p = {\n\t\t.pre_div_shift = 3,\n\t\t.pre_div_width = 2,\n\t},\n\t.s = {\n\t\t.src_sel_shift = 0,\n\t\t.parent_map = lcc_pxo_pll4_map,\n\t},\n\t.freq_tbl = clk_tbl_pcm_393,\n\t.clkr = {\n\t\t.enable_reg = 0x54,\n\t\t.enable_mask = BIT(9),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"pcm_src\",\n\t\t\t.parent_data = lcc_pxo_pll4,\n\t\t\t.num_parents = ARRAY_SIZE(lcc_pxo_pll4),\n\t\t\t.ops = &clk_rcg_ops,\n\t\t\t.flags = CLK_SET_RATE_GATE,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch pcm_clk_out = {\n\t.halt_reg = 0x5c,\n\t.halt_bit = 0,\n\t.halt_check = BRANCH_HALT_ENABLE,\n\t.clkr = {\n\t\t.enable_reg = 0x54,\n\t\t.enable_mask = BIT(11),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"pcm_clk_out\",\n\t\t\t.parent_hws = (const struct clk_hw*[]){\n\t\t\t\t&pcm_src.clkr.hw\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch_ops,\n\t\t\t.flags = CLK_SET_RATE_PARENT,\n\t\t},\n\t},\n};\n\nstatic struct clk_regmap_mux pcm_clk = {\n\t.reg = 0x54,\n\t.shift = 10,\n\t.width = 1,\n\t.clkr = {\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"pcm_clk\",\n\t\t\t.parent_data = (const struct clk_parent_data[]){\n\t\t\t\t{ .hw = &pcm_clk_out.clkr.hw },\n\t\t\t\t{ .fw_name = \"pcm_codec_clk\", .name = \"pcm_codec_clk\" },\n\t\t\t},\n\t\t\t.num_parents = 2,\n\t\t\t.ops = &clk_regmap_mux_closest_ops,\n\t\t\t.flags = CLK_SET_RATE_PARENT,\n\t\t},\n\t},\n};\n\nstatic struct clk_rcg slimbus_src = {\n\t.ns_reg = 0xcc,\n\t.md_reg = 0xd0,\n\t.mn = {\n\t\t.mnctr_en_bit = 8,\n\t\t.mnctr_reset_bit = 7,\n\t\t.mnctr_mode_shift = 5,\n\t\t.n_val_shift = 24,\n\t\t.m_val_shift = 8,\n\t\t.width = 8,\n\t},\n\t.p = {\n\t\t.pre_div_shift = 3,\n\t\t.pre_div_width = 2,\n\t},\n\t.s = {\n\t\t.src_sel_shift = 0,\n\t\t.parent_map = lcc_pxo_pll4_map,\n\t},\n\t.freq_tbl = clk_tbl_aif_osr_393,\n\t.clkr = {\n\t\t.enable_reg = 0xcc,\n\t\t.enable_mask = BIT(9),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"slimbus_src\",\n\t\t\t.parent_data = lcc_pxo_pll4,\n\t\t\t.num_parents = ARRAY_SIZE(lcc_pxo_pll4),\n\t\t\t.ops = &clk_rcg_ops,\n\t\t\t.flags = CLK_SET_RATE_GATE,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch audio_slimbus_clk = {\n\t.halt_reg = 0xd4,\n\t.halt_bit = 0,\n\t.halt_check = BRANCH_HALT_ENABLE,\n\t.clkr = {\n\t\t.enable_reg = 0xcc,\n\t\t.enable_mask = BIT(10),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"audio_slimbus_clk\",\n\t\t\t.parent_hws = (const struct clk_hw*[]){\n\t\t\t\t&slimbus_src.clkr.hw,\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch_ops,\n\t\t\t.flags = CLK_SET_RATE_PARENT,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch sps_slimbus_clk = {\n\t.halt_reg = 0xd4,\n\t.halt_bit = 1,\n\t.halt_check = BRANCH_HALT_ENABLE,\n\t.clkr = {\n\t\t.enable_reg = 0xcc,\n\t\t.enable_mask = BIT(12),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"sps_slimbus_clk\",\n\t\t\t.parent_hws = (const struct clk_hw*[]){\n\t\t\t\t&slimbus_src.clkr.hw,\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch_ops,\n\t\t\t.flags = CLK_SET_RATE_PARENT,\n\t\t},\n\t},\n};\n\nstatic struct clk_regmap *lcc_msm8960_clks[] = {\n\t[PLL4] = &pll4.clkr,\n\t[MI2S_OSR_SRC] = &mi2s_osr_src.clkr,\n\t[MI2S_OSR_CLK] = &mi2s_osr_clk.clkr,\n\t[MI2S_DIV_CLK] = &mi2s_div_clk.clkr,\n\t[MI2S_BIT_DIV_CLK] = &mi2s_bit_div_clk.clkr,\n\t[MI2S_BIT_CLK] = &mi2s_bit_clk.clkr,\n\t[PCM_SRC] = &pcm_src.clkr,\n\t[PCM_CLK_OUT] = &pcm_clk_out.clkr,\n\t[PCM_CLK] = &pcm_clk.clkr,\n\t[SLIMBUS_SRC] = &slimbus_src.clkr,\n\t[AUDIO_SLIMBUS_CLK] = &audio_slimbus_clk.clkr,\n\t[SPS_SLIMBUS_CLK] = &sps_slimbus_clk.clkr,\n\t[CODEC_I2S_MIC_OSR_SRC] = &codec_i2s_mic_osr_src.clkr,\n\t[CODEC_I2S_MIC_OSR_CLK] = &codec_i2s_mic_osr_clk.clkr,\n\t[CODEC_I2S_MIC_DIV_CLK] = &codec_i2s_mic_div_clk.clkr,\n\t[CODEC_I2S_MIC_BIT_DIV_CLK] = &codec_i2s_mic_bit_div_clk.clkr,\n\t[CODEC_I2S_MIC_BIT_CLK] = &codec_i2s_mic_bit_clk.clkr,\n\t[SPARE_I2S_MIC_OSR_SRC] = &spare_i2s_mic_osr_src.clkr,\n\t[SPARE_I2S_MIC_OSR_CLK] = &spare_i2s_mic_osr_clk.clkr,\n\t[SPARE_I2S_MIC_DIV_CLK] = &spare_i2s_mic_div_clk.clkr,\n\t[SPARE_I2S_MIC_BIT_DIV_CLK] = &spare_i2s_mic_bit_div_clk.clkr,\n\t[SPARE_I2S_MIC_BIT_CLK] = &spare_i2s_mic_bit_clk.clkr,\n\t[CODEC_I2S_SPKR_OSR_SRC] = &codec_i2s_spkr_osr_src.clkr,\n\t[CODEC_I2S_SPKR_OSR_CLK] = &codec_i2s_spkr_osr_clk.clkr,\n\t[CODEC_I2S_SPKR_DIV_CLK] = &codec_i2s_spkr_div_clk.clkr,\n\t[CODEC_I2S_SPKR_BIT_DIV_CLK] = &codec_i2s_spkr_bit_div_clk.clkr,\n\t[CODEC_I2S_SPKR_BIT_CLK] = &codec_i2s_spkr_bit_clk.clkr,\n\t[SPARE_I2S_SPKR_OSR_SRC] = &spare_i2s_spkr_osr_src.clkr,\n\t[SPARE_I2S_SPKR_OSR_CLK] = &spare_i2s_spkr_osr_clk.clkr,\n\t[SPARE_I2S_SPKR_DIV_CLK] = &spare_i2s_spkr_div_clk.clkr,\n\t[SPARE_I2S_SPKR_BIT_DIV_CLK] = &spare_i2s_spkr_bit_div_clk.clkr,\n\t[SPARE_I2S_SPKR_BIT_CLK] = &spare_i2s_spkr_bit_clk.clkr,\n};\n\nstatic const struct regmap_config lcc_msm8960_regmap_config = {\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n\t.max_register\t= 0xfc,\n\t.fast_io\t= true,\n};\n\nstatic const struct qcom_cc_desc lcc_msm8960_desc = {\n\t.config = &lcc_msm8960_regmap_config,\n\t.clks = lcc_msm8960_clks,\n\t.num_clks = ARRAY_SIZE(lcc_msm8960_clks),\n};\n\nstatic const struct of_device_id lcc_msm8960_match_table[] = {\n\t{ .compatible = \"qcom,lcc-msm8960\" },\n\t{ .compatible = \"qcom,lcc-apq8064\" },\n\t{ .compatible = \"qcom,lcc-mdm9615\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lcc_msm8960_match_table);\n\nstatic int lcc_msm8960_probe(struct platform_device *pdev)\n{\n\tu32 val;\n\tstruct regmap *regmap;\n\n\t \n\tif (of_device_is_compatible(pdev->dev.of_node, \"qcom,lcc-mdm9615\")) {\n\t\tpxo_parent_data.fw_name = \"cxo\";\n\t\tpxo_parent_data.name = \"cxo_board\";\n\t\tlcc_pxo_pll4[0].fw_name = \"cxo\";\n\t\tlcc_pxo_pll4[0].name = \"cxo_board\";\n\t}\n\n\tregmap = qcom_cc_map(pdev, &lcc_msm8960_desc);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\t \n\tregmap_read(regmap, 0x4, &val);\n\tif (val == 0x12) {\n\t\tslimbus_src.freq_tbl = clk_tbl_aif_osr_492;\n\t\tmi2s_osr_src.freq_tbl = clk_tbl_aif_osr_492;\n\t\tcodec_i2s_mic_osr_src.freq_tbl = clk_tbl_aif_osr_492;\n\t\tspare_i2s_mic_osr_src.freq_tbl = clk_tbl_aif_osr_492;\n\t\tcodec_i2s_spkr_osr_src.freq_tbl = clk_tbl_aif_osr_492;\n\t\tspare_i2s_spkr_osr_src.freq_tbl = clk_tbl_aif_osr_492;\n\t\tpcm_src.freq_tbl = clk_tbl_pcm_492;\n\t}\n\t \n\tregmap_write(regmap, 0xc4, 0x1);\n\n\treturn qcom_cc_really_probe(pdev, &lcc_msm8960_desc, regmap);\n}\n\nstatic struct platform_driver lcc_msm8960_driver = {\n\t.probe\t\t= lcc_msm8960_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"lcc-msm8960\",\n\t\t.of_match_table = lcc_msm8960_match_table,\n\t},\n};\nmodule_platform_driver(lcc_msm8960_driver);\n\nMODULE_DESCRIPTION(\"QCOM LCC MSM8960 Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:lcc-msm8960\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}