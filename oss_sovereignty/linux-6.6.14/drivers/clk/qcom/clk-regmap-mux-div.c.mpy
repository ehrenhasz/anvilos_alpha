{
  "module_name": "clk-regmap-mux-div.c",
  "hash_id": "150561b83a90980e52e5e5cb427971d181d7ae52339a975f651649a254eb9850",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/clk-regmap-mux-div.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/regmap.h>\n\n#include \"clk-regmap-mux-div.h\"\n\n#define CMD_RCGR\t\t\t0x0\n#define CMD_RCGR_UPDATE\t\t\tBIT(0)\n#define CMD_RCGR_DIRTY_CFG\t\tBIT(4)\n#define CMD_RCGR_ROOT_OFF\t\tBIT(31)\n#define CFG_RCGR\t\t\t0x4\n\n#define to_clk_regmap_mux_div(_hw) \\\n\tcontainer_of(to_clk_regmap(_hw), struct clk_regmap_mux_div, clkr)\n\nint mux_div_set_src_div(struct clk_regmap_mux_div *md, u32 src, u32 div)\n{\n\tint ret, count;\n\tu32 val, mask;\n\tconst char *name = clk_hw_get_name(&md->clkr.hw);\n\n\tval = (div << md->hid_shift) | (src << md->src_shift);\n\tmask = ((BIT(md->hid_width) - 1) << md->hid_shift) |\n\t       ((BIT(md->src_width) - 1) << md->src_shift);\n\n\tret = regmap_update_bits(md->clkr.regmap, CFG_RCGR + md->reg_offset,\n\t\t\t\t mask, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(md->clkr.regmap, CMD_RCGR + md->reg_offset,\n\t\t\t\t CMD_RCGR_UPDATE, CMD_RCGR_UPDATE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (count = 500; count > 0; count--) {\n\t\tret = regmap_read(md->clkr.regmap, CMD_RCGR + md->reg_offset,\n\t\t\t\t  &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (!(val & CMD_RCGR_UPDATE))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\tpr_err(\"%s: RCG did not update its configuration\", name);\n\treturn -EBUSY;\n}\nEXPORT_SYMBOL_GPL(mux_div_set_src_div);\n\nstatic void mux_div_get_src_div(struct clk_regmap_mux_div *md, u32 *src,\n\t\t\t\tu32 *div)\n{\n\tu32 val, d, s;\n\tconst char *name = clk_hw_get_name(&md->clkr.hw);\n\n\tregmap_read(md->clkr.regmap, CMD_RCGR + md->reg_offset, &val);\n\n\tif (val & CMD_RCGR_DIRTY_CFG) {\n\t\tpr_err(\"%s: RCG configuration is pending\\n\", name);\n\t\treturn;\n\t}\n\n\tregmap_read(md->clkr.regmap, CFG_RCGR + md->reg_offset, &val);\n\ts = (val >> md->src_shift);\n\ts &= BIT(md->src_width) - 1;\n\t*src = s;\n\n\td = (val >> md->hid_shift);\n\td &= BIT(md->hid_width) - 1;\n\t*div = d;\n}\n\nstatic inline bool is_better_rate(unsigned long req, unsigned long best,\n\t\t\t\t  unsigned long new)\n{\n\treturn (req <= new && new < best) || (best < req && best < new);\n}\n\nstatic int mux_div_determine_rate(struct clk_hw *hw,\n\t\t\t\t  struct clk_rate_request *req)\n{\n\tstruct clk_regmap_mux_div *md = to_clk_regmap_mux_div(hw);\n\tunsigned int i, div, max_div;\n\tunsigned long actual_rate, best_rate = 0;\n\tunsigned long req_rate = req->rate;\n\n\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\n\t\tstruct clk_hw *parent = clk_hw_get_parent_by_index(hw, i);\n\t\tunsigned long parent_rate = clk_hw_get_rate(parent);\n\n\t\tmax_div = BIT(md->hid_width) - 1;\n\t\tfor (div = 1; div < max_div; div++) {\n\t\t\tparent_rate = mult_frac(req_rate, div, 2);\n\t\t\tparent_rate = clk_hw_round_rate(parent, parent_rate);\n\t\t\tactual_rate = mult_frac(parent_rate, 2, div);\n\n\t\t\tif (is_better_rate(req_rate, best_rate, actual_rate)) {\n\t\t\t\tbest_rate = actual_rate;\n\t\t\t\treq->rate = best_rate;\n\t\t\t\treq->best_parent_rate = parent_rate;\n\t\t\t\treq->best_parent_hw = parent;\n\t\t\t}\n\n\t\t\tif (actual_rate < req_rate || best_rate <= req_rate)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!best_rate)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __mux_div_set_rate_and_parent(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t unsigned long prate, u32 src)\n{\n\tstruct clk_regmap_mux_div *md = to_clk_regmap_mux_div(hw);\n\tint ret;\n\tu32 div, max_div, best_src = 0, best_div = 0;\n\tunsigned int i;\n\tunsigned long actual_rate, best_rate = 0;\n\n\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\n\t\tstruct clk_hw *parent = clk_hw_get_parent_by_index(hw, i);\n\t\tunsigned long parent_rate = clk_hw_get_rate(parent);\n\n\t\tmax_div = BIT(md->hid_width) - 1;\n\t\tfor (div = 1; div < max_div; div++) {\n\t\t\tparent_rate = mult_frac(rate, div, 2);\n\t\t\tparent_rate = clk_hw_round_rate(parent, parent_rate);\n\t\t\tactual_rate = mult_frac(parent_rate, 2, div);\n\n\t\t\tif (is_better_rate(rate, best_rate, actual_rate)) {\n\t\t\t\tbest_rate = actual_rate;\n\t\t\t\tbest_src = md->parent_map[i];\n\t\t\t\tbest_div = div - 1;\n\t\t\t}\n\n\t\t\tif (actual_rate < rate || best_rate <= rate)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = mux_div_set_src_div(md, best_src, best_div);\n\tif (!ret) {\n\t\tmd->div = best_div;\n\t\tmd->src = best_src;\n\t}\n\n\treturn ret;\n}\n\nstatic u8 mux_div_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_regmap_mux_div *md = to_clk_regmap_mux_div(hw);\n\tconst char *name = clk_hw_get_name(hw);\n\tu32 i, div, src = 0;\n\n\tmux_div_get_src_div(md, &src, &div);\n\n\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++)\n\t\tif (src == md->parent_map[i])\n\t\t\treturn i;\n\n\tpr_err(\"%s: Can't find parent with src %d\\n\", name, src);\n\treturn 0;\n}\n\nstatic int mux_div_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_regmap_mux_div *md = to_clk_regmap_mux_div(hw);\n\n\treturn mux_div_set_src_div(md, md->parent_map[index], md->div);\n}\n\nstatic int mux_div_set_rate(struct clk_hw *hw,\n\t\t\t    unsigned long rate, unsigned long prate)\n{\n\tstruct clk_regmap_mux_div *md = to_clk_regmap_mux_div(hw);\n\n\treturn __mux_div_set_rate_and_parent(hw, rate, prate, md->src);\n}\n\nstatic int mux_div_set_rate_and_parent(struct clk_hw *hw,  unsigned long rate,\n\t\t\t\t       unsigned long prate, u8 index)\n{\n\tstruct clk_regmap_mux_div *md = to_clk_regmap_mux_div(hw);\n\n\treturn __mux_div_set_rate_and_parent(hw, rate, prate,\n\t\t\t\t\t     md->parent_map[index]);\n}\n\nstatic unsigned long mux_div_recalc_rate(struct clk_hw *hw, unsigned long prate)\n{\n\tstruct clk_regmap_mux_div *md = to_clk_regmap_mux_div(hw);\n\tu32 div, src;\n\tint i, num_parents = clk_hw_get_num_parents(hw);\n\tconst char *name = clk_hw_get_name(hw);\n\n\tmux_div_get_src_div(md, &src, &div);\n\tfor (i = 0; i < num_parents; i++)\n\t\tif (src == md->parent_map[i]) {\n\t\t\tstruct clk_hw *p = clk_hw_get_parent_by_index(hw, i);\n\t\t\tunsigned long parent_rate = clk_hw_get_rate(p);\n\n\t\t\treturn mult_frac(parent_rate, 2, div + 1);\n\t\t}\n\n\tpr_err(\"%s: Can't find parent %d\\n\", name, src);\n\treturn 0;\n}\n\nconst struct clk_ops clk_regmap_mux_div_ops = {\n\t.get_parent = mux_div_get_parent,\n\t.set_parent = mux_div_set_parent,\n\t.set_rate = mux_div_set_rate,\n\t.set_rate_and_parent = mux_div_set_rate_and_parent,\n\t.determine_rate = mux_div_determine_rate,\n\t.recalc_rate = mux_div_recalc_rate,\n};\nEXPORT_SYMBOL_GPL(clk_regmap_mux_div_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}