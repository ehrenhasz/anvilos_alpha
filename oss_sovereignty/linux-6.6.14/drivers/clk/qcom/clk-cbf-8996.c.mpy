{
  "module_name": "clk-cbf-8996.c",
  "hash_id": "960ce7a1ac5d44d36ac0a12e2a43abd356947fae7741300220ba1a848b6e656c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/clk-cbf-8996.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/interconnect-clk.h>\n#include <linux/interconnect-provider.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/interconnect/qcom,msm8996-cbf.h>\n\n#include \"clk-alpha-pll.h\"\n#include \"clk-regmap.h\"\n\n \nenum {\n\tDT_XO,\n\tDT_APCS_AUX,\n};\n\nenum {\n\tCBF_XO_INDEX,\n\tCBF_PLL_INDEX,\n\tCBF_DIV_INDEX,\n\tCBF_APCS_AUX_INDEX,\n};\n\n#define DIV_THRESHOLD\t\t600000000\n\n#define CBF_MUX_OFFSET\t\t0x18\n#define CBF_MUX_PARENT_MASK\t\tGENMASK(1, 0)\n#define CBF_MUX_AUTO_CLK_SEL_ALWAYS_ON_MASK GENMASK(5, 4)\n#define CBF_MUX_AUTO_CLK_SEL_ALWAYS_ON_GPLL0_SEL \\\n\tFIELD_PREP(CBF_MUX_AUTO_CLK_SEL_ALWAYS_ON_MASK, 0x03)\n#define CBF_MUX_AUTO_CLK_SEL_BIT\tBIT(6)\n\n#define CBF_PLL_OFFSET 0xf000\n\nstatic const u8 cbf_pll_regs[PLL_OFF_MAX_REGS] = {\n\t[PLL_OFF_L_VAL] = 0x08,\n\t[PLL_OFF_ALPHA_VAL] = 0x10,\n\t[PLL_OFF_USER_CTL] = 0x18,\n\t[PLL_OFF_CONFIG_CTL] = 0x20,\n\t[PLL_OFF_CONFIG_CTL_U] = 0x24,\n\t[PLL_OFF_TEST_CTL] = 0x30,\n\t[PLL_OFF_TEST_CTL_U] = 0x34,\n\t[PLL_OFF_STATUS] = 0x28,\n};\n\nstatic struct alpha_pll_config cbfpll_config = {\n\t.l = 72,\n\t.config_ctl_val = 0x200d4828,\n\t.config_ctl_hi_val = 0x006,\n\t.test_ctl_val = 0x1c000000,\n\t.test_ctl_hi_val = 0x00004000,\n\t.pre_div_mask = BIT(12),\n\t.post_div_mask = 0x3 << 8,\n\t.post_div_val = 0x1 << 8,\n\t.main_output_mask = BIT(0),\n\t.early_output_mask = BIT(3),\n};\n\nstatic struct clk_alpha_pll cbf_pll = {\n\t.offset = CBF_PLL_OFFSET,\n\t.regs = cbf_pll_regs,\n\t.flags = SUPPORTS_DYNAMIC_UPDATE | SUPPORTS_FSM_MODE,\n\t.clkr.hw.init = &(struct clk_init_data){\n\t\t.name = \"cbf_pll\",\n\t\t.parent_data = (const struct clk_parent_data[]) {\n\t\t\t{ .index = DT_XO, },\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &clk_alpha_pll_hwfsm_ops,\n\t},\n};\n\nstatic struct clk_fixed_factor cbf_pll_postdiv = {\n\t.mult = 1,\n\t.div = 2,\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"cbf_pll_postdiv\",\n\t\t.parent_hws = (const struct clk_hw*[]){\n\t\t\t&cbf_pll.clkr.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &clk_fixed_factor_ops,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic const struct clk_parent_data cbf_mux_parent_data[] = {\n\t{ .index = DT_XO },\n\t{ .hw = &cbf_pll.clkr.hw },\n\t{ .hw = &cbf_pll_postdiv.hw },\n\t{ .index = DT_APCS_AUX },\n};\n\nstruct clk_cbf_8996_mux {\n\tu32 reg;\n\tstruct notifier_block nb;\n\tstruct clk_regmap clkr;\n};\n\nstatic struct clk_cbf_8996_mux *to_clk_cbf_8996_mux(struct clk_regmap *clkr)\n{\n\treturn container_of(clkr, struct clk_cbf_8996_mux, clkr);\n}\n\nstatic int cbf_clk_notifier_cb(struct notifier_block *nb, unsigned long event,\n\t\t\t       void *data);\n\nstatic u8 clk_cbf_8996_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clkr = to_clk_regmap(hw);\n\tstruct clk_cbf_8996_mux *mux = to_clk_cbf_8996_mux(clkr);\n\tu32 val;\n\n\tregmap_read(clkr->regmap, mux->reg, &val);\n\n\treturn FIELD_GET(CBF_MUX_PARENT_MASK, val);\n}\n\nstatic int clk_cbf_8996_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_regmap *clkr = to_clk_regmap(hw);\n\tstruct clk_cbf_8996_mux *mux = to_clk_cbf_8996_mux(clkr);\n\tu32 val;\n\n\tval = FIELD_PREP(CBF_MUX_PARENT_MASK, index);\n\n\treturn regmap_update_bits(clkr->regmap, mux->reg, CBF_MUX_PARENT_MASK, val);\n}\n\nstatic int clk_cbf_8996_mux_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t   struct clk_rate_request *req)\n{\n\tstruct clk_hw *parent;\n\n\tif (req->rate < (DIV_THRESHOLD / cbf_pll_postdiv.div))\n\t\treturn -EINVAL;\n\n\tif (req->rate < DIV_THRESHOLD)\n\t\tparent = clk_hw_get_parent_by_index(hw, CBF_DIV_INDEX);\n\telse\n\t\tparent = clk_hw_get_parent_by_index(hw, CBF_PLL_INDEX);\n\n\tif (!parent)\n\t\treturn -EINVAL;\n\n\treq->best_parent_rate = clk_hw_round_rate(parent, req->rate);\n\treq->best_parent_hw = parent;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_cbf_8996_mux_ops = {\n\t.set_parent = clk_cbf_8996_mux_set_parent,\n\t.get_parent = clk_cbf_8996_mux_get_parent,\n\t.determine_rate = clk_cbf_8996_mux_determine_rate,\n};\n\nstatic struct clk_cbf_8996_mux cbf_mux = {\n\t.reg = CBF_MUX_OFFSET,\n\t.nb.notifier_call = cbf_clk_notifier_cb,\n\t.clkr.hw.init = &(struct clk_init_data) {\n\t\t.name = \"cbf_mux\",\n\t\t.parent_data = cbf_mux_parent_data,\n\t\t.num_parents = ARRAY_SIZE(cbf_mux_parent_data),\n\t\t.ops = &clk_cbf_8996_mux_ops,\n\t\t \n\t\t.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,\n\t},\n};\n\nstatic int cbf_clk_notifier_cb(struct notifier_block *nb, unsigned long event,\n\t\t\t       void *data)\n{\n\tstruct clk_notifier_data *cnd = data;\n\n\tswitch (event) {\n\tcase PRE_RATE_CHANGE:\n\t\t \n\t\tif (cnd->old_rate > DIV_THRESHOLD &&\n\t\t    cnd->new_rate < DIV_THRESHOLD)\n\t\t\tclk_cbf_8996_mux_set_parent(&cbf_mux.clkr.hw, CBF_DIV_INDEX);\n\t\tbreak;\n\tcase ABORT_RATE_CHANGE:\n\t\t \n\t\tif (cnd->new_rate < DIV_THRESHOLD &&\n\t\t    cnd->old_rate > DIV_THRESHOLD)\n\t\t\tclk_cbf_8996_mux_set_parent(&cbf_mux.clkr.hw, CBF_PLL_INDEX);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn notifier_from_errno(0);\n};\n\nstatic struct clk_hw *cbf_msm8996_hw_clks[] = {\n\t&cbf_pll_postdiv.hw,\n};\n\nstatic struct clk_regmap *cbf_msm8996_clks[] = {\n\t&cbf_pll.clkr,\n\t&cbf_mux.clkr,\n};\n\nstatic const struct regmap_config cbf_msm8996_regmap_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= 0x10000,\n\t.fast_io\t\t= true,\n\t.val_format_endian\t= REGMAP_ENDIAN_LITTLE,\n};\n\n#ifdef CONFIG_INTERCONNECT\n\n \n#define CBF_MASTER_NODE 2000\n\nstatic int qcom_msm8996_cbf_icc_register(struct platform_device *pdev, struct clk_hw *cbf_hw)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct clk *clk = devm_clk_hw_get_clk(dev, cbf_hw, \"cbf\");\n\tconst struct icc_clk_data data[] = {\n\t\t{ .clk = clk, .name = \"cbf\", },\n\t};\n\tstruct icc_provider *provider;\n\n\tprovider = icc_clk_register(dev, CBF_MASTER_NODE, ARRAY_SIZE(data), data);\n\tif (IS_ERR(provider))\n\t\treturn PTR_ERR(provider);\n\n\tplatform_set_drvdata(pdev, provider);\n\n\treturn 0;\n}\n\nstatic int qcom_msm8996_cbf_icc_remove(struct platform_device *pdev)\n{\n\tstruct icc_provider *provider = platform_get_drvdata(pdev);\n\n\ticc_clk_unregister(provider);\n\n\treturn 0;\n}\n#define qcom_msm8996_cbf_icc_sync_state icc_sync_state\n#else\nstatic int qcom_msm8996_cbf_icc_register(struct platform_device *pdev,  struct clk_hw *cbf_hw)\n{\n\tdev_warn(&pdev->dev, \"CONFIG_INTERCONNECT is disabled, CBF clock is fixed\\n\");\n\n\treturn 0;\n}\n#define qcom_msm8996_cbf_icc_remove(pdev) (0)\n#define qcom_msm8996_cbf_icc_sync_state NULL\n#endif\n\nstatic int qcom_msm8996_cbf_probe(struct platform_device *pdev)\n{\n\tvoid __iomem *base;\n\tstruct regmap *regmap;\n\tstruct device *dev = &pdev->dev;\n\tint i, ret;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio(dev, base, &cbf_msm8996_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\t \n\tregmap_write(regmap, CBF_MUX_OFFSET, 0x3);\n\n\t \n\tudelay(5);\n\n\t \n\tregmap_update_bits(regmap, CBF_MUX_OFFSET,\n\t\t\t   CBF_MUX_AUTO_CLK_SEL_ALWAYS_ON_MASK,\n\t\t\t   CBF_MUX_AUTO_CLK_SEL_ALWAYS_ON_GPLL0_SEL);\n\n\tclk_alpha_pll_configure(&cbf_pll, regmap, &cbfpll_config);\n\n\t \n\tudelay(50);\n\n\t \n\tregmap_update_bits(regmap, CBF_MUX_OFFSET,\n\t\t\t   CBF_MUX_AUTO_CLK_SEL_BIT,\n\t\t\t   CBF_MUX_AUTO_CLK_SEL_BIT);\n\n\t \n\tudelay(5);\n\n\t \n\tregmap_update_bits(regmap, CBF_MUX_OFFSET, CBF_MUX_PARENT_MASK, 0x1);\n\n\tif (of_device_is_compatible(dev->of_node, \"qcom,msm8996pro-cbf\")) {\n\t\tcbfpll_config.post_div_val = 0x3 << 8;\n\t\tcbf_pll_postdiv.div = 4;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(cbf_msm8996_hw_clks); i++) {\n\t\tret = devm_clk_hw_register(dev, cbf_msm8996_hw_clks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(cbf_msm8996_clks); i++) {\n\t\tret = devm_clk_register_regmap(dev, cbf_msm8996_clks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_clk_notifier_register(dev, cbf_mux.clkr.hw.clk, &cbf_mux.nb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get, &cbf_mux.clkr.hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn qcom_msm8996_cbf_icc_register(pdev, &cbf_mux.clkr.hw);\n}\n\nstatic int qcom_msm8996_cbf_remove(struct platform_device *pdev)\n{\n\treturn qcom_msm8996_cbf_icc_remove(pdev);\n}\n\nstatic const struct of_device_id qcom_msm8996_cbf_match_table[] = {\n\t{ .compatible = \"qcom,msm8996-cbf\" },\n\t{ .compatible = \"qcom,msm8996pro-cbf\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, qcom_msm8996_cbf_match_table);\n\nstatic struct platform_driver qcom_msm8996_cbf_driver = {\n\t.probe = qcom_msm8996_cbf_probe,\n\t.remove = qcom_msm8996_cbf_remove,\n\t.driver = {\n\t\t.name = \"qcom-msm8996-cbf\",\n\t\t.of_match_table = qcom_msm8996_cbf_match_table,\n\t\t.sync_state = qcom_msm8996_cbf_icc_sync_state,\n\t},\n};\n\n \nstatic int __init qcom_msm8996_cbf_init(void)\n{\n\treturn platform_driver_register(&qcom_msm8996_cbf_driver);\n}\npostcore_initcall(qcom_msm8996_cbf_init);\n\nstatic void __exit qcom_msm8996_cbf_exit(void)\n{\n\tplatform_driver_unregister(&qcom_msm8996_cbf_driver);\n}\nmodule_exit(qcom_msm8996_cbf_exit);\n\nMODULE_DESCRIPTION(\"QCOM MSM8996 CPU Bus Fabric Clock Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}