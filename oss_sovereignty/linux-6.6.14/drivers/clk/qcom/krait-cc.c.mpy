{
  "module_name": "krait-cc.c",
  "hash_id": "59412fa94aa8ec729a89c664cc50abf10461945b0d3d9fcdcddebb333031900a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/krait-cc.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n\n#include \"clk-krait.h\"\n\nenum {\n\tcpu0_mux = 0,\n\tcpu1_mux,\n\tcpu2_mux,\n\tcpu3_mux,\n\tl2_mux,\n\n\tclks_max,\n};\n\nstatic unsigned int sec_mux_map[] = {\n\t2,\n\t0,\n};\n\nstatic unsigned int pri_mux_map[] = {\n\t1,\n\t2,\n\t0,\n};\n\n \nstatic int krait_notifier_cb(struct notifier_block *nb,\n\t\t\t     unsigned long event,\n\t\t\t     void *data)\n{\n\tint ret = 0;\n\tstruct krait_mux_clk *mux = container_of(nb, struct krait_mux_clk,\n\t\t\t\t\t\t clk_nb);\n\t \n\tif (event == PRE_RATE_CHANGE) {\n\t\tmux->old_index = krait_mux_clk_ops.get_parent(&mux->hw);\n\t\tret = krait_mux_clk_ops.set_parent(&mux->hw, mux->safe_sel);\n\t\tmux->reparent = false;\n\t \n\t} else if (event == POST_RATE_CHANGE) {\n\t\tif (!mux->reparent)\n\t\t\tret = krait_mux_clk_ops.set_parent(&mux->hw,\n\t\t\t\t\t\t\t   mux->old_index);\n\t}\n\n\treturn notifier_from_errno(ret);\n}\n\nstatic int krait_notifier_register(struct device *dev, struct clk *clk,\n\t\t\t\t   struct krait_mux_clk *mux)\n{\n\tint ret = 0;\n\n\tmux->clk_nb.notifier_call = krait_notifier_cb;\n\tret = devm_clk_notifier_register(dev, clk, &mux->clk_nb);\n\tif (ret)\n\t\tdev_err(dev, \"failed to register clock notifier: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic struct clk_hw *\nkrait_add_div(struct device *dev, int id, const char *s, unsigned int offset)\n{\n\tstruct krait_div2_clk *div;\n\tstatic struct clk_parent_data p_data[1];\n\tstruct clk_init_data init = {\n\t\t.num_parents = ARRAY_SIZE(p_data),\n\t\t.ops = &krait_div2_clk_ops,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t};\n\tstruct clk_hw *clk;\n\tchar *parent_name;\n\tint cpu, ret;\n\n\tdiv = devm_kzalloc(dev, sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdiv->width = 2;\n\tdiv->shift = 6;\n\tdiv->lpl = id >= 0;\n\tdiv->offset = offset;\n\tdiv->hw.init = &init;\n\n\tinit.name = kasprintf(GFP_KERNEL, \"hfpll%s_div\", s);\n\tif (!init.name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.parent_data = p_data;\n\tparent_name = kasprintf(GFP_KERNEL, \"hfpll%s\", s);\n\tif (!parent_name) {\n\t\tclk = ERR_PTR(-ENOMEM);\n\t\tgoto err_parent_name;\n\t}\n\n\tp_data[0].fw_name = parent_name;\n\tp_data[0].name = parent_name;\n\n\tret = devm_clk_hw_register(dev, &div->hw);\n\tif (ret) {\n\t\tclk = ERR_PTR(ret);\n\t\tgoto err_clk;\n\t}\n\n\tclk = &div->hw;\n\n\t \n\tif (id < 0)\n\t\tfor_each_online_cpu(cpu)\n\t\t\tclk_prepare_enable(div->hw.clk);\n\telse\n\t\tclk_prepare_enable(div->hw.clk);\n\nerr_clk:\n\tkfree(parent_name);\nerr_parent_name:\n\tkfree(init.name);\n\n\treturn clk;\n}\n\nstatic struct clk_hw *\nkrait_add_sec_mux(struct device *dev, int id, const char *s,\n\t\t  unsigned int offset, bool unique_aux)\n{\n\tint cpu, ret;\n\tstruct krait_mux_clk *mux;\n\tstatic struct clk_parent_data sec_mux_list[2] = {\n\t\t{ .name = \"qsb\", .fw_name = \"qsb\" },\n\t\t{},\n\t};\n\tstruct clk_init_data init = {\n\t\t.parent_data = sec_mux_list,\n\t\t.num_parents = ARRAY_SIZE(sec_mux_list),\n\t\t.ops = &krait_mux_clk_ops,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t};\n\tstruct clk_hw *clk;\n\tchar *parent_name;\n\n\tmux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmux->offset = offset;\n\tmux->lpl = id >= 0;\n\tmux->mask = 0x3;\n\tmux->shift = 2;\n\tmux->parent_map = sec_mux_map;\n\tmux->hw.init = &init;\n\tmux->safe_sel = 0;\n\n\t \n\tif (of_machine_is_compatible(\"qcom,ipq8064\") ||\n\t    of_machine_is_compatible(\"qcom,apq8064\"))\n\t\tmux->disable_sec_src_gating = true;\n\n\tinit.name = kasprintf(GFP_KERNEL, \"krait%s_sec_mux\", s);\n\tif (!init.name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unique_aux) {\n\t\tparent_name = kasprintf(GFP_KERNEL, \"acpu%s_aux\", s);\n\t\tif (!parent_name) {\n\t\t\tclk = ERR_PTR(-ENOMEM);\n\t\t\tgoto err_aux;\n\t\t}\n\t\tsec_mux_list[1].fw_name = parent_name;\n\t\tsec_mux_list[1].name = parent_name;\n\t} else {\n\t\tsec_mux_list[1].name = \"apu_aux\";\n\t}\n\n\tret = devm_clk_hw_register(dev, &mux->hw);\n\tif (ret) {\n\t\tclk = ERR_PTR(ret);\n\t\tgoto err_clk;\n\t}\n\n\tclk = &mux->hw;\n\n\tret = krait_notifier_register(dev, mux->hw.clk, mux);\n\tif (ret) {\n\t\tclk = ERR_PTR(ret);\n\t\tgoto err_clk;\n\t}\n\n\t \n\tif (id < 0)\n\t\tfor_each_online_cpu(cpu)\n\t\t\tclk_prepare_enable(mux->hw.clk);\n\telse\n\t\tclk_prepare_enable(mux->hw.clk);\n\nerr_clk:\n\tif (unique_aux)\n\t\tkfree(parent_name);\nerr_aux:\n\tkfree(init.name);\n\treturn clk;\n}\n\nstatic struct clk_hw *\nkrait_add_pri_mux(struct device *dev, struct clk_hw *hfpll_div, struct clk_hw *sec_mux,\n\t\t  int id, const char *s, unsigned int offset)\n{\n\tint ret;\n\tstruct krait_mux_clk *mux;\n\tstatic struct clk_parent_data p_data[3];\n\tstruct clk_init_data init = {\n\t\t.parent_data = p_data,\n\t\t.num_parents = ARRAY_SIZE(p_data),\n\t\t.ops = &krait_mux_clk_ops,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t};\n\tstruct clk_hw *clk;\n\tchar *hfpll_name;\n\n\tmux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmux->mask = 0x3;\n\tmux->shift = 0;\n\tmux->offset = offset;\n\tmux->lpl = id >= 0;\n\tmux->parent_map = pri_mux_map;\n\tmux->hw.init = &init;\n\tmux->safe_sel = 2;\n\n\tinit.name = kasprintf(GFP_KERNEL, \"krait%s_pri_mux\", s);\n\tif (!init.name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thfpll_name = kasprintf(GFP_KERNEL, \"hfpll%s\", s);\n\tif (!hfpll_name) {\n\t\tclk = ERR_PTR(-ENOMEM);\n\t\tgoto err_hfpll;\n\t}\n\n\tp_data[0].fw_name = hfpll_name;\n\tp_data[0].name = hfpll_name;\n\n\tp_data[1].hw = hfpll_div;\n\tp_data[2].hw = sec_mux;\n\n\tret = devm_clk_hw_register(dev, &mux->hw);\n\tif (ret) {\n\t\tclk = ERR_PTR(ret);\n\t\tgoto err_clk;\n\t}\n\n\tclk = &mux->hw;\n\n\tret = krait_notifier_register(dev, mux->hw.clk, mux);\n\tif (ret)\n\t\tclk = ERR_PTR(ret);\n\nerr_clk:\n\tkfree(hfpll_name);\nerr_hfpll:\n\tkfree(init.name);\n\treturn clk;\n}\n\n \nstatic struct clk_hw *krait_add_clks(struct device *dev, int id, bool unique_aux)\n{\n\tstruct clk_hw *hfpll_div, *sec_mux, *pri_mux;\n\tunsigned int offset;\n\tvoid *p = NULL;\n\tconst char *s;\n\n\tif (id >= 0) {\n\t\toffset = 0x4501 + (0x1000 * id);\n\t\ts = p = kasprintf(GFP_KERNEL, \"%d\", id);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t} else {\n\t\toffset = 0x500;\n\t\ts = \"_l2\";\n\t}\n\n\thfpll_div = krait_add_div(dev, id, s, offset);\n\tif (IS_ERR(hfpll_div)) {\n\t\tpri_mux = hfpll_div;\n\t\tgoto err;\n\t}\n\n\tsec_mux = krait_add_sec_mux(dev, id, s, offset, unique_aux);\n\tif (IS_ERR(sec_mux)) {\n\t\tpri_mux = sec_mux;\n\t\tgoto err;\n\t}\n\n\tpri_mux = krait_add_pri_mux(dev, hfpll_div, sec_mux, id, s, offset);\n\nerr:\n\tkfree(p);\n\treturn pri_mux;\n}\n\nstatic struct clk *krait_of_get(struct of_phandle_args *clkspec, void *data)\n{\n\tunsigned int idx = clkspec->args[0];\n\tstruct clk **clks = data;\n\n\tif (idx >= clks_max) {\n\t\tpr_err(\"%s: invalid clock index %d\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn clks[idx] ? : ERR_PTR(-ENODEV);\n}\n\nstatic const struct of_device_id krait_cc_match_table[] = {\n\t{ .compatible = \"qcom,krait-cc-v1\", (void *)1UL },\n\t{ .compatible = \"qcom,krait-cc-v2\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, krait_cc_match_table);\n\nstatic int krait_cc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *id;\n\tunsigned long cur_rate, aux_rate;\n\tint cpu;\n\tstruct clk_hw *mux, *l2_pri_mux;\n\tstruct clk *clk, **clks;\n\n\tid = of_match_device(krait_cc_match_table, dev);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\t \n\tclk = clk_register_fixed_rate(dev, \"qsb\", NULL, 0, 1);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tif (!id->data) {\n\t\tclk = clk_register_fixed_factor(dev, \"acpu_aux\",\n\t\t\t\t\t\t\"gpll0_vote\", 0, 1, 2);\n\t\tif (IS_ERR(clk))\n\t\t\treturn PTR_ERR(clk);\n\t}\n\n\t \n\tclks = devm_kcalloc(dev, clks_max, sizeof(*clks), GFP_KERNEL);\n\tif (!clks)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tmux = krait_add_clks(dev, cpu, id->data);\n\t\tif (IS_ERR(mux))\n\t\t\treturn PTR_ERR(mux);\n\t\tclks[cpu] = mux->clk;\n\t}\n\n\tl2_pri_mux = krait_add_clks(dev, -1, id->data);\n\tif (IS_ERR(l2_pri_mux))\n\t\treturn PTR_ERR(l2_pri_mux);\n\tclks[l2_mux] = l2_pri_mux->clk;\n\n\t \n\tfor_each_online_cpu(cpu) {\n\t\tclk_prepare_enable(clks[l2_mux]);\n\t\tWARN(clk_prepare_enable(clks[cpu]),\n\t\t     \"Unable to turn on CPU%d clock\", cpu);\n\t}\n\n\t \n\tcur_rate = clk_get_rate(clks[l2_mux]);\n\taux_rate = 384000000;\n\tif (cur_rate < aux_rate) {\n\t\tpr_info(\"L2 @ Undefined rate. Forcing new rate.\\n\");\n\t\tcur_rate = aux_rate;\n\t}\n\tclk_set_rate(clks[l2_mux], aux_rate);\n\tclk_set_rate(clks[l2_mux], 2);\n\tclk_set_rate(clks[l2_mux], cur_rate);\n\tpr_info(\"L2 @ %lu KHz\\n\", clk_get_rate(clks[l2_mux]) / 1000);\n\tfor_each_possible_cpu(cpu) {\n\t\tclk = clks[cpu];\n\t\tcur_rate = clk_get_rate(clk);\n\t\tif (cur_rate < aux_rate) {\n\t\t\tpr_info(\"CPU%d @ Undefined rate. Forcing new rate.\\n\", cpu);\n\t\t\tcur_rate = aux_rate;\n\t\t}\n\n\t\tclk_set_rate(clk, aux_rate);\n\t\tclk_set_rate(clk, 2);\n\t\tclk_set_rate(clk, cur_rate);\n\t\tpr_info(\"CPU%d @ %lu KHz\\n\", cpu, clk_get_rate(clk) / 1000);\n\t}\n\n\tof_clk_add_provider(dev->of_node, krait_of_get, clks);\n\n\treturn 0;\n}\n\nstatic struct platform_driver krait_cc_driver = {\n\t.probe = krait_cc_probe,\n\t.driver = {\n\t\t.name = \"krait-cc\",\n\t\t.of_match_table = krait_cc_match_table,\n\t},\n};\nmodule_platform_driver(krait_cc_driver);\n\nMODULE_DESCRIPTION(\"Krait CPU Clock Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:krait-cc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}