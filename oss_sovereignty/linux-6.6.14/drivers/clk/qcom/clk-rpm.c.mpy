{
  "module_name": "clk-rpm.c",
  "hash_id": "ac5a9cf5e1123360ffbba270d2d1547072dc6aad89243739cb4bf3e059f1063f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/clk-rpm.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/mfd/qcom_rpm.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <dt-bindings/mfd/qcom-rpm.h>\n#include <dt-bindings/clock/qcom,rpmcc.h>\n\n#define QCOM_RPM_MISC_CLK_TYPE\t\t\t\t0x306b6c63\n#define QCOM_RPM_SCALING_ENABLE_ID\t\t\t0x2\n#define QCOM_RPM_XO_MODE_ON\t\t\t\t0x2\n\nstatic const struct clk_parent_data gcc_pxo[] = {\n\t{ .fw_name = \"pxo\", .name = \"pxo_board\" },\n};\n\nstatic const struct clk_parent_data gcc_cxo[] = {\n\t{ .fw_name = \"cxo\", .name = \"cxo_board\" },\n};\n\n#define DEFINE_CLK_RPM(_name, r_id)\t\t\t\t\t      \\\n\tstatic struct clk_rpm clk_rpm_##_name##_a_clk;\t\t\t      \\\n\tstatic struct clk_rpm clk_rpm_##_name##_clk = {\t\t\t      \\\n\t\t.rpm_clk_id = (r_id),\t\t\t\t\t      \\\n\t\t.peer = &clk_rpm_##_name##_a_clk,\t\t\t      \\\n\t\t.rate = INT_MAX,\t\t\t\t\t      \\\n\t\t.hw.init = &(struct clk_init_data){\t\t\t      \\\n\t\t\t.ops = &clk_rpm_ops,\t\t\t\t      \\\n\t\t\t.name = #_name \"_clk\",\t\t\t\t      \\\n\t\t\t.parent_data = gcc_pxo,\t\t\t\t      \\\n\t\t\t.num_parents = ARRAY_SIZE(gcc_pxo),\t\t      \\\n\t\t},\t\t\t\t\t\t\t      \\\n\t};\t\t\t\t\t\t\t\t      \\\n\tstatic struct clk_rpm clk_rpm_##_name##_a_clk = {\t\t      \\\n\t\t.rpm_clk_id = (r_id),\t\t\t\t\t      \\\n\t\t.peer = &clk_rpm_##_name##_clk,\t\t\t\t      \\\n\t\t.active_only = true,\t\t\t\t\t      \\\n\t\t.rate = INT_MAX,\t\t\t\t\t      \\\n\t\t.hw.init = &(struct clk_init_data){\t\t\t      \\\n\t\t\t.ops = &clk_rpm_ops,\t\t\t\t      \\\n\t\t\t.name = #_name \"_a_clk\",\t\t\t      \\\n\t\t\t.parent_data = gcc_pxo,\t\t\t\t      \\\n\t\t\t.num_parents = ARRAY_SIZE(gcc_pxo),\t\t      \\\n\t\t},\t\t\t\t\t\t\t      \\\n\t}\n\n#define DEFINE_CLK_RPM_XO_BUFFER(_name, offset)\t\t\t\t      \\\n\tstatic struct clk_rpm clk_rpm_##_name##_clk = {\t\t\t      \\\n\t\t.rpm_clk_id = QCOM_RPM_CXO_BUFFERS,\t\t\t      \\\n\t\t.xo_offset = (offset),\t\t\t\t\t      \\\n\t\t.hw.init = &(struct clk_init_data){\t\t\t      \\\n\t\t\t.ops = &clk_rpm_xo_ops,\t\t\t\t      \\\n\t\t\t.name = #_name \"_clk\",\t\t\t\t      \\\n\t\t\t.parent_data = gcc_cxo,\t\t\t\t      \\\n\t\t\t.num_parents = ARRAY_SIZE(gcc_cxo),\t\t      \\\n\t\t},\t\t\t\t\t\t\t      \\\n\t}\n\n#define DEFINE_CLK_RPM_FIXED(_name, r_id, r)\t\t\t\t      \\\n\tstatic struct clk_rpm clk_rpm_##_name##_clk = {\t\t\t      \\\n\t\t.rpm_clk_id = (r_id),\t\t\t\t\t      \\\n\t\t.rate = (r),\t\t\t\t\t\t      \\\n\t\t.hw.init = &(struct clk_init_data){\t\t\t      \\\n\t\t\t.ops = &clk_rpm_fixed_ops,\t\t\t      \\\n\t\t\t.name = #_name \"_clk\",\t\t\t\t      \\\n\t\t\t.parent_data = gcc_pxo,\t\t\t\t      \\\n\t\t\t.num_parents = ARRAY_SIZE(gcc_pxo),\t\t      \\\n\t\t},\t\t\t\t\t\t\t      \\\n\t}\n\n#define to_clk_rpm(_hw) container_of(_hw, struct clk_rpm, hw)\n\nstruct rpm_cc;\n\nstruct clk_rpm {\n\tconst int rpm_clk_id;\n\tconst int xo_offset;\n\tconst bool active_only;\n\tunsigned long rate;\n\tbool enabled;\n\tbool branch;\n\tstruct clk_rpm *peer;\n\tstruct clk_hw hw;\n\tstruct qcom_rpm *rpm;\n\tstruct rpm_cc *rpm_cc;\n};\n\nstruct rpm_cc {\n\tstruct qcom_rpm *rpm;\n\tstruct clk_rpm **clks;\n\tsize_t num_clks;\n\tu32 xo_buffer_value;\n\tstruct mutex xo_lock;\n};\n\nstruct rpm_clk_desc {\n\tstruct clk_rpm **clks;\n\tsize_t num_clks;\n};\n\nstatic DEFINE_MUTEX(rpm_clk_lock);\n\nstatic int clk_rpm_handoff(struct clk_rpm *r)\n{\n\tint ret;\n\tu32 value = INT_MAX;\n\n\t \n\tif (r->rpm_clk_id == QCOM_RPM_PLL_4 ||\n\t\tr->rpm_clk_id == QCOM_RPM_CXO_BUFFERS)\n\t\treturn 0;\n\n\tret = qcom_rpm_write(r->rpm, QCOM_RPM_ACTIVE_STATE,\n\t\t\t     r->rpm_clk_id, &value, 1);\n\tif (ret)\n\t\treturn ret;\n\tret = qcom_rpm_write(r->rpm, QCOM_RPM_SLEEP_STATE,\n\t\t\t     r->rpm_clk_id, &value, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int clk_rpm_set_rate_active(struct clk_rpm *r, unsigned long rate)\n{\n\tu32 value = DIV_ROUND_UP(rate, 1000);  \n\n\treturn qcom_rpm_write(r->rpm, QCOM_RPM_ACTIVE_STATE,\n\t\t\t      r->rpm_clk_id, &value, 1);\n}\n\nstatic int clk_rpm_set_rate_sleep(struct clk_rpm *r, unsigned long rate)\n{\n\tu32 value = DIV_ROUND_UP(rate, 1000);  \n\n\treturn qcom_rpm_write(r->rpm, QCOM_RPM_SLEEP_STATE,\n\t\t\t      r->rpm_clk_id, &value, 1);\n}\n\nstatic void to_active_sleep(struct clk_rpm *r, unsigned long rate,\n\t\t\t    unsigned long *active, unsigned long *sleep)\n{\n\t*active = rate;\n\n\t \n\tif (r->active_only)\n\t\t*sleep = 0;\n\telse\n\t\t*sleep = *active;\n}\n\nstatic int clk_rpm_prepare(struct clk_hw *hw)\n{\n\tstruct clk_rpm *r = to_clk_rpm(hw);\n\tstruct clk_rpm *peer = r->peer;\n\tunsigned long this_rate = 0, this_sleep_rate = 0;\n\tunsigned long peer_rate = 0, peer_sleep_rate = 0;\n\tunsigned long active_rate, sleep_rate;\n\tint ret = 0;\n\n\tmutex_lock(&rpm_clk_lock);\n\n\t \n\tif (!r->rate)\n\t\tgoto out;\n\n\tto_active_sleep(r, r->rate, &this_rate, &this_sleep_rate);\n\n\t \n\tif (peer->enabled)\n\t\tto_active_sleep(peer, peer->rate,\n\t\t\t\t&peer_rate, &peer_sleep_rate);\n\n\tactive_rate = max(this_rate, peer_rate);\n\n\tif (r->branch)\n\t\tactive_rate = !!active_rate;\n\n\tret = clk_rpm_set_rate_active(r, active_rate);\n\tif (ret)\n\t\tgoto out;\n\n\tsleep_rate = max(this_sleep_rate, peer_sleep_rate);\n\tif (r->branch)\n\t\tsleep_rate = !!sleep_rate;\n\n\tret = clk_rpm_set_rate_sleep(r, sleep_rate);\n\tif (ret)\n\t\t \n\t\tret = clk_rpm_set_rate_active(r, peer_rate);\n\nout:\n\tif (!ret)\n\t\tr->enabled = true;\n\n\tmutex_unlock(&rpm_clk_lock);\n\n\treturn ret;\n}\n\nstatic void clk_rpm_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_rpm *r = to_clk_rpm(hw);\n\tstruct clk_rpm *peer = r->peer;\n\tunsigned long peer_rate = 0, peer_sleep_rate = 0;\n\tunsigned long active_rate, sleep_rate;\n\tint ret;\n\n\tmutex_lock(&rpm_clk_lock);\n\n\tif (!r->rate)\n\t\tgoto out;\n\n\t \n\tif (peer->enabled)\n\t\tto_active_sleep(peer, peer->rate, &peer_rate,\n\t\t\t\t&peer_sleep_rate);\n\n\tactive_rate = r->branch ? !!peer_rate : peer_rate;\n\tret = clk_rpm_set_rate_active(r, active_rate);\n\tif (ret)\n\t\tgoto out;\n\n\tsleep_rate = r->branch ? !!peer_sleep_rate : peer_sleep_rate;\n\tret = clk_rpm_set_rate_sleep(r, sleep_rate);\n\tif (ret)\n\t\tgoto out;\n\n\tr->enabled = false;\n\nout:\n\tmutex_unlock(&rpm_clk_lock);\n}\n\nstatic int clk_rpm_xo_prepare(struct clk_hw *hw)\n{\n\tstruct clk_rpm *r = to_clk_rpm(hw);\n\tstruct rpm_cc *rcc = r->rpm_cc;\n\tint ret, clk_id = r->rpm_clk_id;\n\tu32 value;\n\n\tmutex_lock(&rcc->xo_lock);\n\n\tvalue = rcc->xo_buffer_value | (QCOM_RPM_XO_MODE_ON << r->xo_offset);\n\tret = qcom_rpm_write(r->rpm, QCOM_RPM_ACTIVE_STATE, clk_id, &value, 1);\n\tif (!ret) {\n\t\tr->enabled = true;\n\t\trcc->xo_buffer_value = value;\n\t}\n\n\tmutex_unlock(&rcc->xo_lock);\n\n\treturn ret;\n}\n\nstatic void clk_rpm_xo_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_rpm *r = to_clk_rpm(hw);\n\tstruct rpm_cc *rcc = r->rpm_cc;\n\tint ret, clk_id = r->rpm_clk_id;\n\tu32 value;\n\n\tmutex_lock(&rcc->xo_lock);\n\n\tvalue = rcc->xo_buffer_value & ~(QCOM_RPM_XO_MODE_ON << r->xo_offset);\n\tret = qcom_rpm_write(r->rpm, QCOM_RPM_ACTIVE_STATE, clk_id, &value, 1);\n\tif (!ret) {\n\t\tr->enabled = false;\n\t\trcc->xo_buffer_value = value;\n\t}\n\n\tmutex_unlock(&rcc->xo_lock);\n}\n\nstatic int clk_rpm_fixed_prepare(struct clk_hw *hw)\n{\n\tstruct clk_rpm *r = to_clk_rpm(hw);\n\tu32 value = 1;\n\tint ret;\n\n\tret = qcom_rpm_write(r->rpm, QCOM_RPM_ACTIVE_STATE,\n\t\t\t     r->rpm_clk_id, &value, 1);\n\tif (!ret)\n\t\tr->enabled = true;\n\n\treturn ret;\n}\n\nstatic void clk_rpm_fixed_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_rpm *r = to_clk_rpm(hw);\n\tu32 value = 0;\n\tint ret;\n\n\tret = qcom_rpm_write(r->rpm, QCOM_RPM_ACTIVE_STATE,\n\t\t\t     r->rpm_clk_id, &value, 1);\n\tif (!ret)\n\t\tr->enabled = false;\n}\n\nstatic int clk_rpm_set_rate(struct clk_hw *hw,\n\t\t\t    unsigned long rate, unsigned long parent_rate)\n{\n\tstruct clk_rpm *r = to_clk_rpm(hw);\n\tstruct clk_rpm *peer = r->peer;\n\tunsigned long active_rate, sleep_rate;\n\tunsigned long this_rate = 0, this_sleep_rate = 0;\n\tunsigned long peer_rate = 0, peer_sleep_rate = 0;\n\tint ret = 0;\n\n\tmutex_lock(&rpm_clk_lock);\n\n\tif (!r->enabled)\n\t\tgoto out;\n\n\tto_active_sleep(r, rate, &this_rate, &this_sleep_rate);\n\n\t \n\tif (peer->enabled)\n\t\tto_active_sleep(peer, peer->rate,\n\t\t\t\t&peer_rate, &peer_sleep_rate);\n\n\tactive_rate = max(this_rate, peer_rate);\n\tret = clk_rpm_set_rate_active(r, active_rate);\n\tif (ret)\n\t\tgoto out;\n\n\tsleep_rate = max(this_sleep_rate, peer_sleep_rate);\n\tret = clk_rpm_set_rate_sleep(r, sleep_rate);\n\tif (ret)\n\t\tgoto out;\n\n\tr->rate = rate;\n\nout:\n\tmutex_unlock(&rpm_clk_lock);\n\n\treturn ret;\n}\n\nstatic long clk_rpm_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\t \n\treturn rate;\n}\n\nstatic unsigned long clk_rpm_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_rpm *r = to_clk_rpm(hw);\n\n\t \n\treturn r->rate;\n}\n\nstatic const struct clk_ops clk_rpm_xo_ops = {\n\t.prepare\t= clk_rpm_xo_prepare,\n\t.unprepare\t= clk_rpm_xo_unprepare,\n};\n\nstatic const struct clk_ops clk_rpm_fixed_ops = {\n\t.prepare\t= clk_rpm_fixed_prepare,\n\t.unprepare\t= clk_rpm_fixed_unprepare,\n\t.round_rate\t= clk_rpm_round_rate,\n\t.recalc_rate\t= clk_rpm_recalc_rate,\n};\n\nstatic const struct clk_ops clk_rpm_ops = {\n\t.prepare\t= clk_rpm_prepare,\n\t.unprepare\t= clk_rpm_unprepare,\n\t.set_rate\t= clk_rpm_set_rate,\n\t.round_rate\t= clk_rpm_round_rate,\n\t.recalc_rate\t= clk_rpm_recalc_rate,\n};\n\nDEFINE_CLK_RPM(afab, QCOM_RPM_APPS_FABRIC_CLK);\nDEFINE_CLK_RPM(sfab, QCOM_RPM_SYS_FABRIC_CLK);\nDEFINE_CLK_RPM(mmfab, QCOM_RPM_MM_FABRIC_CLK);\nDEFINE_CLK_RPM(daytona, QCOM_RPM_DAYTONA_FABRIC_CLK);\nDEFINE_CLK_RPM(sfpb, QCOM_RPM_SFPB_CLK);\nDEFINE_CLK_RPM(cfpb, QCOM_RPM_CFPB_CLK);\nDEFINE_CLK_RPM(mmfpb, QCOM_RPM_MMFPB_CLK);\nDEFINE_CLK_RPM(smi, QCOM_RPM_SMI_CLK);\nDEFINE_CLK_RPM(ebi1, QCOM_RPM_EBI1_CLK);\n\nDEFINE_CLK_RPM(qdss, QCOM_RPM_QDSS_CLK);\nDEFINE_CLK_RPM(nss_fabric_0, QCOM_RPM_NSS_FABRIC_0_CLK);\nDEFINE_CLK_RPM(nss_fabric_1, QCOM_RPM_NSS_FABRIC_1_CLK);\n\nDEFINE_CLK_RPM_FIXED(pll4, QCOM_RPM_PLL_4, 540672000);\n\nDEFINE_CLK_RPM_XO_BUFFER(xo_d0, 0);\nDEFINE_CLK_RPM_XO_BUFFER(xo_d1, 8);\nDEFINE_CLK_RPM_XO_BUFFER(xo_a0, 16);\nDEFINE_CLK_RPM_XO_BUFFER(xo_a1, 24);\nDEFINE_CLK_RPM_XO_BUFFER(xo_a2, 28);\n\nstatic struct clk_rpm *msm8660_clks[] = {\n\t[RPM_APPS_FABRIC_CLK] = &clk_rpm_afab_clk,\n\t[RPM_APPS_FABRIC_A_CLK] = &clk_rpm_afab_a_clk,\n\t[RPM_SYS_FABRIC_CLK] = &clk_rpm_sfab_clk,\n\t[RPM_SYS_FABRIC_A_CLK] = &clk_rpm_sfab_a_clk,\n\t[RPM_MM_FABRIC_CLK] = &clk_rpm_mmfab_clk,\n\t[RPM_MM_FABRIC_A_CLK] = &clk_rpm_mmfab_a_clk,\n\t[RPM_DAYTONA_FABRIC_CLK] = &clk_rpm_daytona_clk,\n\t[RPM_DAYTONA_FABRIC_A_CLK] = &clk_rpm_daytona_a_clk,\n\t[RPM_SFPB_CLK] = &clk_rpm_sfpb_clk,\n\t[RPM_SFPB_A_CLK] = &clk_rpm_sfpb_a_clk,\n\t[RPM_CFPB_CLK] = &clk_rpm_cfpb_clk,\n\t[RPM_CFPB_A_CLK] = &clk_rpm_cfpb_a_clk,\n\t[RPM_MMFPB_CLK] = &clk_rpm_mmfpb_clk,\n\t[RPM_MMFPB_A_CLK] = &clk_rpm_mmfpb_a_clk,\n\t[RPM_SMI_CLK] = &clk_rpm_smi_clk,\n\t[RPM_SMI_A_CLK] = &clk_rpm_smi_a_clk,\n\t[RPM_EBI1_CLK] = &clk_rpm_ebi1_clk,\n\t[RPM_EBI1_A_CLK] = &clk_rpm_ebi1_a_clk,\n\t[RPM_PLL4_CLK] = &clk_rpm_pll4_clk,\n};\n\nstatic const struct rpm_clk_desc rpm_clk_msm8660 = {\n\t.clks = msm8660_clks,\n\t.num_clks = ARRAY_SIZE(msm8660_clks),\n};\n\nstatic struct clk_rpm *apq8064_clks[] = {\n\t[RPM_APPS_FABRIC_CLK] = &clk_rpm_afab_clk,\n\t[RPM_APPS_FABRIC_A_CLK] = &clk_rpm_afab_a_clk,\n\t[RPM_CFPB_CLK] = &clk_rpm_cfpb_clk,\n\t[RPM_CFPB_A_CLK] = &clk_rpm_cfpb_a_clk,\n\t[RPM_DAYTONA_FABRIC_CLK] = &clk_rpm_daytona_clk,\n\t[RPM_DAYTONA_FABRIC_A_CLK] = &clk_rpm_daytona_a_clk,\n\t[RPM_EBI1_CLK] = &clk_rpm_ebi1_clk,\n\t[RPM_EBI1_A_CLK] = &clk_rpm_ebi1_a_clk,\n\t[RPM_MM_FABRIC_CLK] = &clk_rpm_mmfab_clk,\n\t[RPM_MM_FABRIC_A_CLK] = &clk_rpm_mmfab_a_clk,\n\t[RPM_MMFPB_CLK] = &clk_rpm_mmfpb_clk,\n\t[RPM_MMFPB_A_CLK] = &clk_rpm_mmfpb_a_clk,\n\t[RPM_SYS_FABRIC_CLK] = &clk_rpm_sfab_clk,\n\t[RPM_SYS_FABRIC_A_CLK] = &clk_rpm_sfab_a_clk,\n\t[RPM_SFPB_CLK] = &clk_rpm_sfpb_clk,\n\t[RPM_SFPB_A_CLK] = &clk_rpm_sfpb_a_clk,\n\t[RPM_QDSS_CLK] = &clk_rpm_qdss_clk,\n\t[RPM_QDSS_A_CLK] = &clk_rpm_qdss_a_clk,\n\t[RPM_XO_D0] = &clk_rpm_xo_d0_clk,\n\t[RPM_XO_D1] = &clk_rpm_xo_d1_clk,\n\t[RPM_XO_A0] = &clk_rpm_xo_a0_clk,\n\t[RPM_XO_A1] = &clk_rpm_xo_a1_clk,\n\t[RPM_XO_A2] = &clk_rpm_xo_a2_clk,\n};\n\nstatic const struct rpm_clk_desc rpm_clk_apq8064 = {\n\t.clks = apq8064_clks,\n\t.num_clks = ARRAY_SIZE(apq8064_clks),\n};\n\nstatic struct clk_rpm *ipq806x_clks[] = {\n\t[RPM_APPS_FABRIC_CLK] = &clk_rpm_afab_clk,\n\t[RPM_APPS_FABRIC_A_CLK] = &clk_rpm_afab_a_clk,\n\t[RPM_CFPB_CLK] = &clk_rpm_cfpb_clk,\n\t[RPM_CFPB_A_CLK] = &clk_rpm_cfpb_a_clk,\n\t[RPM_DAYTONA_FABRIC_CLK] = &clk_rpm_daytona_clk,\n\t[RPM_DAYTONA_FABRIC_A_CLK] = &clk_rpm_daytona_a_clk,\n\t[RPM_EBI1_CLK] = &clk_rpm_ebi1_clk,\n\t[RPM_EBI1_A_CLK] = &clk_rpm_ebi1_a_clk,\n\t[RPM_SYS_FABRIC_CLK] = &clk_rpm_sfab_clk,\n\t[RPM_SYS_FABRIC_A_CLK] = &clk_rpm_sfab_a_clk,\n\t[RPM_SFPB_CLK] = &clk_rpm_sfpb_clk,\n\t[RPM_SFPB_A_CLK] = &clk_rpm_sfpb_a_clk,\n\t[RPM_NSS_FABRIC_0_CLK] = &clk_rpm_nss_fabric_0_clk,\n\t[RPM_NSS_FABRIC_0_A_CLK] = &clk_rpm_nss_fabric_0_a_clk,\n\t[RPM_NSS_FABRIC_1_CLK] = &clk_rpm_nss_fabric_1_clk,\n\t[RPM_NSS_FABRIC_1_A_CLK] = &clk_rpm_nss_fabric_1_a_clk,\n};\n\nstatic const struct rpm_clk_desc rpm_clk_ipq806x = {\n\t.clks = ipq806x_clks,\n\t.num_clks = ARRAY_SIZE(ipq806x_clks),\n};\n\nstatic const struct of_device_id rpm_clk_match_table[] = {\n\t{ .compatible = \"qcom,rpmcc-msm8660\", .data = &rpm_clk_msm8660 },\n\t{ .compatible = \"qcom,rpmcc-apq8060\", .data = &rpm_clk_msm8660 },\n\t{ .compatible = \"qcom,rpmcc-apq8064\", .data = &rpm_clk_apq8064 },\n\t{ .compatible = \"qcom,rpmcc-ipq806x\", .data = &rpm_clk_ipq806x },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rpm_clk_match_table);\n\nstatic struct clk_hw *qcom_rpm_clk_hw_get(struct of_phandle_args *clkspec,\n\t\t\t\t\t  void *data)\n{\n\tstruct rpm_cc *rcc = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= rcc->num_clks) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn rcc->clks[idx] ? &rcc->clks[idx]->hw : ERR_PTR(-ENOENT);\n}\n\nstatic int rpm_clk_probe(struct platform_device *pdev)\n{\n\tstruct rpm_cc *rcc;\n\tint ret;\n\tsize_t num_clks, i;\n\tstruct qcom_rpm *rpm;\n\tstruct clk_rpm **rpm_clks;\n\tconst struct rpm_clk_desc *desc;\n\n\trpm = dev_get_drvdata(pdev->dev.parent);\n\tif (!rpm) {\n\t\tdev_err(&pdev->dev, \"Unable to retrieve handle to RPM\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdesc = of_device_get_match_data(&pdev->dev);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\trpm_clks = desc->clks;\n\tnum_clks = desc->num_clks;\n\n\trcc = devm_kzalloc(&pdev->dev, sizeof(*rcc), GFP_KERNEL);\n\tif (!rcc)\n\t\treturn -ENOMEM;\n\n\trcc->clks = rpm_clks;\n\trcc->num_clks = num_clks;\n\tmutex_init(&rcc->xo_lock);\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tif (!rpm_clks[i])\n\t\t\tcontinue;\n\n\t\trpm_clks[i]->rpm = rpm;\n\t\trpm_clks[i]->rpm_cc = rcc;\n\n\t\tret = clk_rpm_handoff(rpm_clks[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tif (!rpm_clks[i])\n\t\t\tcontinue;\n\n\t\tret = devm_clk_hw_register(&pdev->dev, &rpm_clks[i]->hw);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = devm_of_clk_add_hw_provider(&pdev->dev, qcom_rpm_clk_hw_get,\n\t\t\t\t\t  rcc);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_err(&pdev->dev, \"Error registering RPM Clock driver (%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic struct platform_driver rpm_clk_driver = {\n\t.driver = {\n\t\t.name = \"qcom-clk-rpm\",\n\t\t.of_match_table = rpm_clk_match_table,\n\t},\n\t.probe = rpm_clk_probe,\n};\n\nstatic int __init rpm_clk_init(void)\n{\n\treturn platform_driver_register(&rpm_clk_driver);\n}\ncore_initcall(rpm_clk_init);\n\nstatic void __exit rpm_clk_exit(void)\n{\n\tplatform_driver_unregister(&rpm_clk_driver);\n}\nmodule_exit(rpm_clk_exit);\n\nMODULE_DESCRIPTION(\"Qualcomm RPM Clock Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:qcom-clk-rpm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}