{
  "module_name": "lcc-ipq806x.c",
  "hash_id": "54d6bd4c1a8da7060fff91e4bab49805a9efabd044cfe552bb2f59d12a8a8a62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/lcc-ipq806x.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/clk-provider.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/clock/qcom,lcc-ipq806x.h>\n\n#include \"common.h\"\n#include \"clk-regmap.h\"\n#include \"clk-pll.h\"\n#include \"clk-rcg.h\"\n#include \"clk-branch.h\"\n#include \"clk-regmap-divider.h\"\n#include \"clk-regmap-mux.h\"\n#include \"reset.h\"\n\nstatic struct clk_pll pll4 = {\n\t.l_reg = 0x4,\n\t.m_reg = 0x8,\n\t.n_reg = 0xc,\n\t.config_reg = 0x14,\n\t.mode_reg = 0x0,\n\t.status_reg = 0x18,\n\t.status_bit = 16,\n\t.clkr.hw.init = &(struct clk_init_data){\n\t\t.name = \"pll4\",\n\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t.fw_name = \"pxo\", .name = \"pxo_board\",\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &clk_pll_ops,\n\t},\n};\n\nstatic const struct pll_config pll4_config = {\n\t.l = 0xf,\n\t.m = 0x91,\n\t.n = 0xc7,\n\t.vco_val = 0x0,\n\t.vco_mask = BIT(17) | BIT(16),\n\t.pre_div_val = 0x0,\n\t.pre_div_mask = BIT(19),\n\t.post_div_val = 0x0,\n\t.post_div_mask = BIT(21) | BIT(20),\n\t.mn_ena_mask = BIT(22),\n\t.main_output_mask = BIT(23),\n};\n\nenum {\n\tP_PXO,\n\tP_PLL4,\n};\n\nstatic const struct parent_map lcc_pxo_pll4_map[] = {\n\t{ P_PXO, 0 },\n\t{ P_PLL4, 2 }\n};\n\nstatic const struct clk_parent_data lcc_pxo_pll4[] = {\n\t{ .fw_name = \"pxo\", .name = \"pxo_board\" },\n\t{ .fw_name = \"pll4_vote\", .name = \"pll4_vote\" },\n};\n\nstatic struct freq_tbl clk_tbl_aif_mi2s[] = {\n\t{  1024000, P_PLL4, 4,  1,  96 },\n\t{  1411200, P_PLL4, 4,  2, 139 },\n\t{  1536000, P_PLL4, 4,  1,  64 },\n\t{  2048000, P_PLL4, 4,  1,  48 },\n\t{  2116800, P_PLL4, 4,  2,  93 },\n\t{  2304000, P_PLL4, 4,  2,  85 },\n\t{  2822400, P_PLL4, 4,  6, 209 },\n\t{  3072000, P_PLL4, 4,  1,  32 },\n\t{  3175200, P_PLL4, 4,  1,  31 },\n\t{  4096000, P_PLL4, 4,  1,  24 },\n\t{  4233600, P_PLL4, 4,  9, 209 },\n\t{  4608000, P_PLL4, 4,  3,  64 },\n\t{  5644800, P_PLL4, 4, 12, 209 },\n\t{  6144000, P_PLL4, 4,  1,  16 },\n\t{  6350400, P_PLL4, 4,  2,  31 },\n\t{  8192000, P_PLL4, 4,  1,  12 },\n\t{  8467200, P_PLL4, 4, 18, 209 },\n\t{  9216000, P_PLL4, 4,  3,  32 },\n\t{ 11289600, P_PLL4, 4, 24, 209 },\n\t{ 12288000, P_PLL4, 4,  1,   8 },\n\t{ 12700800, P_PLL4, 4, 27, 209 },\n\t{ 13824000, P_PLL4, 4,  9,  64 },\n\t{ 16384000, P_PLL4, 4,  1,   6 },\n\t{ 16934400, P_PLL4, 4, 41, 238 },\n\t{ 18432000, P_PLL4, 4,  3,  16 },\n\t{ 22579200, P_PLL4, 2, 24, 209 },\n\t{ 24576000, P_PLL4, 4,  1,   4 },\n\t{ 27648000, P_PLL4, 4,  9,  32 },\n\t{ 33868800, P_PLL4, 4, 41, 119 },\n\t{ 36864000, P_PLL4, 4,  3,   8 },\n\t{ 45158400, P_PLL4, 1, 24, 209 },\n\t{ 49152000, P_PLL4, 4,  1,   2 },\n\t{ 50803200, P_PLL4, 1, 27, 209 },\n\t{ }\n};\n\nstatic struct clk_rcg mi2s_osr_src = {\n\t.ns_reg = 0x48,\n\t.md_reg = 0x4c,\n\t.mn = {\n\t\t.mnctr_en_bit = 8,\n\t\t.mnctr_reset_bit = 7,\n\t\t.mnctr_mode_shift = 5,\n\t\t.n_val_shift = 24,\n\t\t.m_val_shift = 8,\n\t\t.width = 8,\n\t},\n\t.p = {\n\t\t.pre_div_shift = 3,\n\t\t.pre_div_width = 2,\n\t},\n\t.s = {\n\t\t.src_sel_shift = 0,\n\t\t.parent_map = lcc_pxo_pll4_map,\n\t},\n\t.freq_tbl = clk_tbl_aif_mi2s,\n\t.clkr = {\n\t\t.enable_reg = 0x48,\n\t\t.enable_mask = BIT(9),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"mi2s_osr_src\",\n\t\t\t.parent_data = lcc_pxo_pll4,\n\t\t\t.num_parents = ARRAY_SIZE(lcc_pxo_pll4),\n\t\t\t.ops = &clk_rcg_ops,\n\t\t\t.flags = CLK_SET_RATE_GATE,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch mi2s_osr_clk = {\n\t.halt_reg = 0x50,\n\t.halt_bit = 1,\n\t.halt_check = BRANCH_HALT_ENABLE,\n\t.clkr = {\n\t\t.enable_reg = 0x48,\n\t\t.enable_mask = BIT(17),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"mi2s_osr_clk\",\n\t\t\t.parent_hws = (const struct clk_hw*[]) {\n\t\t\t\t&mi2s_osr_src.clkr.hw,\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch_ops,\n\t\t\t.flags = CLK_SET_RATE_PARENT,\n\t\t},\n\t},\n};\n\nstatic struct clk_regmap_div mi2s_div_clk = {\n\t.reg = 0x48,\n\t.shift = 10,\n\t.width = 4,\n\t.clkr = {\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"mi2s_div_clk\",\n\t\t\t.parent_hws = (const struct clk_hw*[]) {\n\t\t\t\t&mi2s_osr_src.clkr.hw,\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_regmap_div_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch mi2s_bit_div_clk = {\n\t.halt_reg = 0x50,\n\t.halt_bit = 0,\n\t.halt_check = BRANCH_HALT_ENABLE,\n\t.clkr = {\n\t\t.enable_reg = 0x48,\n\t\t.enable_mask = BIT(15),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"mi2s_bit_div_clk\",\n\t\t\t.parent_hws = (const struct clk_hw*[]) {\n\t\t\t\t&mi2s_div_clk.clkr.hw,\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch_ops,\n\t\t\t.flags = CLK_SET_RATE_PARENT,\n\t\t},\n\t},\n};\n\nstatic const struct clk_parent_data lcc_mi2s_bit_div_codec_clk[] = {\n\t{ .hw = &mi2s_bit_div_clk.clkr.hw, },\n\t{ .fw_name = \"mi2s_codec\", .name = \"mi2s_codec_clk\" },\n};\n\nstatic struct clk_regmap_mux mi2s_bit_clk = {\n\t.reg = 0x48,\n\t.shift = 14,\n\t.width = 1,\n\t.clkr = {\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"mi2s_bit_clk\",\n\t\t\t.parent_data = lcc_mi2s_bit_div_codec_clk,\n\t\t\t.num_parents = ARRAY_SIZE(lcc_mi2s_bit_div_codec_clk),\n\t\t\t.ops = &clk_regmap_mux_closest_ops,\n\t\t\t.flags = CLK_SET_RATE_PARENT,\n\t\t},\n\t},\n};\n\nstatic struct freq_tbl clk_tbl_pcm[] = {\n\t{   64000, P_PLL4, 4, 1, 1536 },\n\t{  128000, P_PLL4, 4, 1,  768 },\n\t{  256000, P_PLL4, 4, 1,  384 },\n\t{  512000, P_PLL4, 4, 1,  192 },\n\t{ 1024000, P_PLL4, 4, 1,   96 },\n\t{ 2048000, P_PLL4, 4, 1,   48 },\n\t{ },\n};\n\nstatic struct clk_rcg pcm_src = {\n\t.ns_reg = 0x54,\n\t.md_reg = 0x58,\n\t.mn = {\n\t\t.mnctr_en_bit = 8,\n\t\t.mnctr_reset_bit = 7,\n\t\t.mnctr_mode_shift = 5,\n\t\t.n_val_shift = 16,\n\t\t.m_val_shift = 16,\n\t\t.width = 16,\n\t},\n\t.p = {\n\t\t.pre_div_shift = 3,\n\t\t.pre_div_width = 2,\n\t},\n\t.s = {\n\t\t.src_sel_shift = 0,\n\t\t.parent_map = lcc_pxo_pll4_map,\n\t},\n\t.freq_tbl = clk_tbl_pcm,\n\t.clkr = {\n\t\t.enable_reg = 0x54,\n\t\t.enable_mask = BIT(9),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"pcm_src\",\n\t\t\t.parent_data = lcc_pxo_pll4,\n\t\t\t.num_parents = ARRAY_SIZE(lcc_pxo_pll4),\n\t\t\t.ops = &clk_rcg_ops,\n\t\t\t.flags = CLK_SET_RATE_GATE,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch pcm_clk_out = {\n\t.halt_reg = 0x5c,\n\t.halt_bit = 0,\n\t.halt_check = BRANCH_HALT_ENABLE,\n\t.clkr = {\n\t\t.enable_reg = 0x54,\n\t\t.enable_mask = BIT(11),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"pcm_clk_out\",\n\t\t\t.parent_hws = (const struct clk_hw*[]) {\n\t\t\t\t&pcm_src.clkr.hw,\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch_ops,\n\t\t\t.flags = CLK_SET_RATE_PARENT,\n\t\t},\n\t},\n};\n\nstatic const struct clk_parent_data lcc_pcm_clk_out_codec_clk[] = {\n\t{ .hw = &pcm_clk_out.clkr.hw, },\n\t{ .fw_name = \"pcm_codec_clk\", .name = \"pcm_codec_clk\" },\n};\n\nstatic struct clk_regmap_mux pcm_clk = {\n\t.reg = 0x54,\n\t.shift = 10,\n\t.width = 1,\n\t.clkr = {\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"pcm_clk\",\n\t\t\t.parent_data = lcc_pcm_clk_out_codec_clk,\n\t\t\t.num_parents = ARRAY_SIZE(lcc_pcm_clk_out_codec_clk),\n\t\t\t.ops = &clk_regmap_mux_closest_ops,\n\t\t\t.flags = CLK_SET_RATE_PARENT,\n\t\t},\n\t},\n};\n\nstatic struct freq_tbl clk_tbl_aif_osr[] = {\n\t{  2822400, P_PLL4, 1, 147, 20480 },\n\t{  4096000, P_PLL4, 1,   1,    96 },\n\t{  5644800, P_PLL4, 1, 147, 10240 },\n\t{  6144000, P_PLL4, 1,   1,    64 },\n\t{ 11289600, P_PLL4, 1, 147,  5120 },\n\t{ 12288000, P_PLL4, 1,   1,    32 },\n\t{ 22579200, P_PLL4, 1, 147,  2560 },\n\t{ 24576000, P_PLL4, 1,   1,    16 },\n\t{ },\n};\n\nstatic struct clk_rcg spdif_src = {\n\t.ns_reg = 0xcc,\n\t.md_reg = 0xd0,\n\t.mn = {\n\t\t.mnctr_en_bit = 8,\n\t\t.mnctr_reset_bit = 7,\n\t\t.mnctr_mode_shift = 5,\n\t\t.n_val_shift = 16,\n\t\t.m_val_shift = 16,\n\t\t.width = 8,\n\t},\n\t.p = {\n\t\t.pre_div_shift = 3,\n\t\t.pre_div_width = 2,\n\t},\n\t.s = {\n\t\t.src_sel_shift = 0,\n\t\t.parent_map = lcc_pxo_pll4_map,\n\t},\n\t.freq_tbl = clk_tbl_aif_osr,\n\t.clkr = {\n\t\t.enable_reg = 0xcc,\n\t\t.enable_mask = BIT(9),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"spdif_src\",\n\t\t\t.parent_data = lcc_pxo_pll4,\n\t\t\t.num_parents = ARRAY_SIZE(lcc_pxo_pll4),\n\t\t\t.ops = &clk_rcg_ops,\n\t\t\t.flags = CLK_SET_RATE_GATE,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch spdif_clk = {\n\t.halt_reg = 0xd4,\n\t.halt_bit = 1,\n\t.halt_check = BRANCH_HALT_ENABLE,\n\t.clkr = {\n\t\t.enable_reg = 0xcc,\n\t\t.enable_mask = BIT(12),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"spdif_clk\",\n\t\t\t.parent_hws = (const struct clk_hw*[]) {\n\t\t\t\t&spdif_src.clkr.hw,\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.ops = &clk_branch_ops,\n\t\t\t.flags = CLK_SET_RATE_PARENT,\n\t\t},\n\t},\n};\n\nstatic struct freq_tbl clk_tbl_ahbix[] = {\n\t{ 131072000, P_PLL4, 1, 1, 3 },\n\t{ },\n};\n\nstatic struct clk_rcg ahbix_clk = {\n\t.ns_reg = 0x38,\n\t.md_reg = 0x3c,\n\t.mn = {\n\t\t.mnctr_en_bit = 8,\n\t\t.mnctr_reset_bit = 7,\n\t\t.mnctr_mode_shift = 5,\n\t\t.n_val_shift = 24,\n\t\t.m_val_shift = 8,\n\t\t.width = 8,\n\t},\n\t.p = {\n\t\t.pre_div_shift = 3,\n\t\t.pre_div_width = 2,\n\t},\n\t.s = {\n\t\t.src_sel_shift = 0,\n\t\t.parent_map = lcc_pxo_pll4_map,\n\t},\n\t.freq_tbl = clk_tbl_ahbix,\n\t.clkr = {\n\t\t.enable_reg = 0x38,\n\t\t.enable_mask = BIT(11),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"ahbix\",\n\t\t\t.parent_data = lcc_pxo_pll4,\n\t\t\t.num_parents = ARRAY_SIZE(lcc_pxo_pll4),\n\t\t\t.ops = &clk_rcg_lcc_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_regmap *lcc_ipq806x_clks[] = {\n\t[PLL4] = &pll4.clkr,\n\t[MI2S_OSR_SRC] = &mi2s_osr_src.clkr,\n\t[MI2S_OSR_CLK] = &mi2s_osr_clk.clkr,\n\t[MI2S_DIV_CLK] = &mi2s_div_clk.clkr,\n\t[MI2S_BIT_DIV_CLK] = &mi2s_bit_div_clk.clkr,\n\t[MI2S_BIT_CLK] = &mi2s_bit_clk.clkr,\n\t[PCM_SRC] = &pcm_src.clkr,\n\t[PCM_CLK_OUT] = &pcm_clk_out.clkr,\n\t[PCM_CLK] = &pcm_clk.clkr,\n\t[SPDIF_SRC] = &spdif_src.clkr,\n\t[SPDIF_CLK] = &spdif_clk.clkr,\n\t[AHBIX_CLK] = &ahbix_clk.clkr,\n};\n\nstatic const struct qcom_reset_map lcc_ipq806x_resets[] = {\n\t[LCC_PCM_RESET] = { 0x54, 13 },\n};\n\nstatic const struct regmap_config lcc_ipq806x_regmap_config = {\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n\t.max_register\t= 0xfc,\n\t.fast_io\t= true,\n};\n\nstatic const struct qcom_cc_desc lcc_ipq806x_desc = {\n\t.config = &lcc_ipq806x_regmap_config,\n\t.clks = lcc_ipq806x_clks,\n\t.num_clks = ARRAY_SIZE(lcc_ipq806x_clks),\n\t.resets = lcc_ipq806x_resets,\n\t.num_resets = ARRAY_SIZE(lcc_ipq806x_resets),\n};\n\nstatic const struct of_device_id lcc_ipq806x_match_table[] = {\n\t{ .compatible = \"qcom,lcc-ipq8064\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lcc_ipq806x_match_table);\n\nstatic int lcc_ipq806x_probe(struct platform_device *pdev)\n{\n\tu32 val;\n\tstruct regmap *regmap;\n\n\tregmap = qcom_cc_map(pdev, &lcc_ipq806x_desc);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\t \n\tregmap_read(regmap, 0x0, &val);\n\tif (!val)\n\t\tclk_pll_configure_sr(&pll4, regmap, &pll4_config, true);\n\t \n\tregmap_write(regmap, 0xc4, 0x1);\n\n\treturn qcom_cc_really_probe(pdev, &lcc_ipq806x_desc, regmap);\n}\n\nstatic struct platform_driver lcc_ipq806x_driver = {\n\t.probe\t\t= lcc_ipq806x_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"lcc-ipq806x\",\n\t\t.of_match_table = lcc_ipq806x_match_table,\n\t},\n};\nmodule_platform_driver(lcc_ipq806x_driver);\n\nMODULE_DESCRIPTION(\"QCOM LCC IPQ806x Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:lcc-ipq806x\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}