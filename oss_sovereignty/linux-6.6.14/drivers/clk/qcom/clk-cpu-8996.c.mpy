{
  "module_name": "clk-cpu-8996.c",
  "hash_id": "cd4f24e8c3b51c3c44778c8f6e649b75360b105c444f73a3b969e3911151d5a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/clk-cpu-8996.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <soc/qcom/kryo-l2-accessors.h>\n\n#include <asm/cputype.h>\n\n#include \"clk-alpha-pll.h\"\n#include \"clk-regmap.h\"\n#include \"clk-regmap-mux.h\"\n\nenum _pmux_input {\n\tSMUX_INDEX = 0,\n\tPLL_INDEX,\n\tACD_INDEX,\n\tALT_INDEX,\n\tNUM_OF_PMUX_INPUTS\n};\n\n#define DIV_2_THRESHOLD\t\t600000000\n#define PWRCL_REG_OFFSET 0x0\n#define PERFCL_REG_OFFSET 0x80000\n#define MUX_OFFSET\t0x40\n#define CLK_CTL_OFFSET 0x44\n#define CLK_CTL_AUTO_CLK_SEL BIT(8)\n#define ALT_PLL_OFFSET\t0x100\n#define SSSCTL_OFFSET 0x160\n#define PSCTL_OFFSET 0x164\n\n#define PMUX_MASK\t0x3\n#define MUX_AUTO_CLK_SEL_ALWAYS_ON_MASK GENMASK(5, 4)\n#define MUX_AUTO_CLK_SEL_ALWAYS_ON_GPLL0_SEL \\\n\tFIELD_PREP(MUX_AUTO_CLK_SEL_ALWAYS_ON_MASK, 0x03)\n\nstatic const u8 prim_pll_regs[PLL_OFF_MAX_REGS] = {\n\t[PLL_OFF_L_VAL] = 0x04,\n\t[PLL_OFF_ALPHA_VAL] = 0x08,\n\t[PLL_OFF_USER_CTL] = 0x10,\n\t[PLL_OFF_CONFIG_CTL] = 0x18,\n\t[PLL_OFF_CONFIG_CTL_U] = 0x1c,\n\t[PLL_OFF_TEST_CTL] = 0x20,\n\t[PLL_OFF_TEST_CTL_U] = 0x24,\n\t[PLL_OFF_STATUS] = 0x28,\n};\n\nstatic const u8 alt_pll_regs[PLL_OFF_MAX_REGS] = {\n\t[PLL_OFF_L_VAL] = 0x04,\n\t[PLL_OFF_ALPHA_VAL] = 0x08,\n\t[PLL_OFF_USER_CTL] = 0x10,\n\t[PLL_OFF_CONFIG_CTL] = 0x18,\n\t[PLL_OFF_TEST_CTL] = 0x20,\n\t[PLL_OFF_STATUS] = 0x28,\n};\n\n \n\nstatic const struct alpha_pll_config hfpll_config = {\n\t.l = 54,\n\t.config_ctl_val = 0x200d4828,\n\t.config_ctl_hi_val = 0x006,\n\t.test_ctl_val = 0x1c000000,\n\t.test_ctl_hi_val = 0x00004000,\n\t.pre_div_mask = BIT(12),\n\t.post_div_mask = 0x3 << 8,\n\t.post_div_val = 0x1 << 8,\n\t.main_output_mask = BIT(0),\n\t.early_output_mask = BIT(3),\n};\n\nstatic const struct clk_parent_data pll_parent[] = {\n\t{ .fw_name = \"xo\" },\n};\n\nstatic struct clk_alpha_pll pwrcl_pll = {\n\t.offset = PWRCL_REG_OFFSET,\n\t.regs = prim_pll_regs,\n\t.flags = SUPPORTS_DYNAMIC_UPDATE | SUPPORTS_FSM_MODE,\n\t.clkr.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwrcl_pll\",\n\t\t.parent_data = pll_parent,\n\t\t.num_parents = ARRAY_SIZE(pll_parent),\n\t\t.ops = &clk_alpha_pll_hwfsm_ops,\n\t},\n};\n\nstatic struct clk_alpha_pll perfcl_pll = {\n\t.offset = PERFCL_REG_OFFSET,\n\t.regs = prim_pll_regs,\n\t.flags = SUPPORTS_DYNAMIC_UPDATE | SUPPORTS_FSM_MODE,\n\t.clkr.hw.init = &(struct clk_init_data){\n\t\t.name = \"perfcl_pll\",\n\t\t.parent_data = pll_parent,\n\t\t.num_parents = ARRAY_SIZE(pll_parent),\n\t\t.ops = &clk_alpha_pll_hwfsm_ops,\n\t},\n};\n\nstatic struct clk_fixed_factor pwrcl_pll_postdiv = {\n\t.mult = 1,\n\t.div = 2,\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwrcl_pll_postdiv\",\n\t\t.parent_data = &(const struct clk_parent_data){\n\t\t\t.hw = &pwrcl_pll.clkr.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &clk_fixed_factor_ops,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_fixed_factor perfcl_pll_postdiv = {\n\t.mult = 1,\n\t.div = 2,\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"perfcl_pll_postdiv\",\n\t\t.parent_data = &(const struct clk_parent_data){\n\t\t\t.hw = &perfcl_pll.clkr.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &clk_fixed_factor_ops,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_fixed_factor perfcl_pll_acd = {\n\t.mult = 1,\n\t.div = 1,\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"perfcl_pll_acd\",\n\t\t.parent_data = &(const struct clk_parent_data){\n\t\t\t.hw = &perfcl_pll.clkr.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &clk_fixed_factor_ops,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_fixed_factor pwrcl_pll_acd = {\n\t.mult = 1,\n\t.div = 1,\n\t.hw.init = &(struct clk_init_data){\n\t\t.name = \"pwrcl_pll_acd\",\n\t\t.parent_data = &(const struct clk_parent_data){\n\t\t\t.hw = &pwrcl_pll.clkr.hw\n\t\t},\n\t\t.num_parents = 1,\n\t\t.ops = &clk_fixed_factor_ops,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic const struct pll_vco alt_pll_vco_modes[] = {\n\tVCO(3,  250000000,  500000000),\n\tVCO(2,  500000000,  750000000),\n\tVCO(1,  750000000, 1000000000),\n\tVCO(0, 1000000000, 2150400000),\n};\n\nstatic const struct alpha_pll_config altpll_config = {\n\t.l = 16,\n\t.vco_val = 0x3 << 20,\n\t.vco_mask = 0x3 << 20,\n\t.config_ctl_val = 0x4001051b,\n\t.post_div_mask = 0x3 << 8,\n\t.post_div_val = 0x1 << 8,\n\t.main_output_mask = BIT(0),\n\t.early_output_mask = BIT(3),\n};\n\nstatic struct clk_alpha_pll pwrcl_alt_pll = {\n\t.offset = PWRCL_REG_OFFSET + ALT_PLL_OFFSET,\n\t.regs = alt_pll_regs,\n\t.vco_table = alt_pll_vco_modes,\n\t.num_vco = ARRAY_SIZE(alt_pll_vco_modes),\n\t.flags = SUPPORTS_OFFLINE_REQ | SUPPORTS_FSM_MODE,\n\t.clkr.hw.init = &(struct clk_init_data) {\n\t\t.name = \"pwrcl_alt_pll\",\n\t\t.parent_data = pll_parent,\n\t\t.num_parents = ARRAY_SIZE(pll_parent),\n\t\t.ops = &clk_alpha_pll_hwfsm_ops,\n\t},\n};\n\nstatic struct clk_alpha_pll perfcl_alt_pll = {\n\t.offset = PERFCL_REG_OFFSET + ALT_PLL_OFFSET,\n\t.regs = alt_pll_regs,\n\t.vco_table = alt_pll_vco_modes,\n\t.num_vco = ARRAY_SIZE(alt_pll_vco_modes),\n\t.flags = SUPPORTS_OFFLINE_REQ | SUPPORTS_FSM_MODE,\n\t.clkr.hw.init = &(struct clk_init_data) {\n\t\t.name = \"perfcl_alt_pll\",\n\t\t.parent_data = pll_parent,\n\t\t.num_parents = ARRAY_SIZE(pll_parent),\n\t\t.ops = &clk_alpha_pll_hwfsm_ops,\n\t},\n};\n\nstruct clk_cpu_8996_pmux {\n\tu32\treg;\n\tstruct notifier_block nb;\n\tstruct clk_regmap clkr;\n};\n\nstatic int cpu_clk_notifier_cb(struct notifier_block *nb, unsigned long event,\n\t\t\t       void *data);\n\n#define to_clk_cpu_8996_pmux_nb(_nb) \\\n\tcontainer_of(_nb, struct clk_cpu_8996_pmux, nb)\n\nstatic inline struct clk_cpu_8996_pmux *to_clk_cpu_8996_pmux_hw(struct clk_hw *hw)\n{\n\treturn container_of(to_clk_regmap(hw), struct clk_cpu_8996_pmux, clkr);\n}\n\nstatic u8 clk_cpu_8996_pmux_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_regmap *clkr = to_clk_regmap(hw);\n\tstruct clk_cpu_8996_pmux *cpuclk = to_clk_cpu_8996_pmux_hw(hw);\n\tu32 val;\n\n\tregmap_read(clkr->regmap, cpuclk->reg, &val);\n\n\treturn FIELD_GET(PMUX_MASK, val);\n}\n\nstatic int clk_cpu_8996_pmux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_regmap *clkr = to_clk_regmap(hw);\n\tstruct clk_cpu_8996_pmux *cpuclk = to_clk_cpu_8996_pmux_hw(hw);\n\tu32 val;\n\n\tval = FIELD_PREP(PMUX_MASK, index);\n\n\treturn regmap_update_bits(clkr->regmap, cpuclk->reg, PMUX_MASK, val);\n}\n\nstatic int clk_cpu_8996_pmux_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t   struct clk_rate_request *req)\n{\n\tstruct clk_hw *parent;\n\n\tif (req->rate < (DIV_2_THRESHOLD / 2))\n\t\treturn -EINVAL;\n\n\tif (req->rate < DIV_2_THRESHOLD)\n\t\tparent = clk_hw_get_parent_by_index(hw, SMUX_INDEX);\n\telse\n\t\tparent = clk_hw_get_parent_by_index(hw, ACD_INDEX);\n\tif (!parent)\n\t\treturn -EINVAL;\n\n\treq->best_parent_rate = clk_hw_round_rate(parent, req->rate);\n\treq->best_parent_hw = parent;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_cpu_8996_pmux_ops = {\n\t.set_parent = clk_cpu_8996_pmux_set_parent,\n\t.get_parent = clk_cpu_8996_pmux_get_parent,\n\t.determine_rate = clk_cpu_8996_pmux_determine_rate,\n};\n\nstatic const struct parent_map smux_parent_map[] = {\n\t{ .cfg = 0, },  \n\t{ .cfg = 1, },  \n\t{ .cfg = 3, },  \n};\n\nstatic const struct clk_parent_data pwrcl_smux_parents[] = {\n\t{ .fw_name = \"xo\" },\n\t{ .hw = &pwrcl_pll_postdiv.hw },\n\t{ .fw_name = \"sys_apcs_aux\" },\n};\n\nstatic const struct clk_parent_data perfcl_smux_parents[] = {\n\t{ .fw_name = \"xo\" },\n\t{ .hw = &perfcl_pll_postdiv.hw },\n\t{ .fw_name = \"sys_apcs_aux\" },\n};\n\nstatic struct clk_regmap_mux pwrcl_smux = {\n\t.reg = PWRCL_REG_OFFSET + MUX_OFFSET,\n\t.shift = 2,\n\t.width = 2,\n\t.parent_map = smux_parent_map,\n\t.clkr.hw.init = &(struct clk_init_data) {\n\t\t.name = \"pwrcl_smux\",\n\t\t.parent_data = pwrcl_smux_parents,\n\t\t.num_parents = ARRAY_SIZE(pwrcl_smux_parents),\n\t\t.ops = &clk_regmap_mux_closest_ops,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic struct clk_regmap_mux perfcl_smux = {\n\t.reg = PERFCL_REG_OFFSET + MUX_OFFSET,\n\t.shift = 2,\n\t.width = 2,\n\t.parent_map = smux_parent_map,\n\t.clkr.hw.init = &(struct clk_init_data) {\n\t\t.name = \"perfcl_smux\",\n\t\t.parent_data = perfcl_smux_parents,\n\t\t.num_parents = ARRAY_SIZE(perfcl_smux_parents),\n\t\t.ops = &clk_regmap_mux_closest_ops,\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t},\n};\n\nstatic const struct clk_hw *pwrcl_pmux_parents[] = {\n\t[SMUX_INDEX] = &pwrcl_smux.clkr.hw,\n\t[PLL_INDEX] = &pwrcl_pll.clkr.hw,\n\t[ACD_INDEX] = &pwrcl_pll_acd.hw,\n\t[ALT_INDEX] = &pwrcl_alt_pll.clkr.hw,\n};\n\nstatic const struct clk_hw *perfcl_pmux_parents[] = {\n\t[SMUX_INDEX] = &perfcl_smux.clkr.hw,\n\t[PLL_INDEX] = &perfcl_pll.clkr.hw,\n\t[ACD_INDEX] = &perfcl_pll_acd.hw,\n\t[ALT_INDEX] = &perfcl_alt_pll.clkr.hw,\n};\n\nstatic struct clk_cpu_8996_pmux pwrcl_pmux = {\n\t.reg = PWRCL_REG_OFFSET + MUX_OFFSET,\n\t.nb.notifier_call = cpu_clk_notifier_cb,\n\t.clkr.hw.init = &(struct clk_init_data) {\n\t\t.name = \"pwrcl_pmux\",\n\t\t.parent_hws = pwrcl_pmux_parents,\n\t\t.num_parents = ARRAY_SIZE(pwrcl_pmux_parents),\n\t\t.ops = &clk_cpu_8996_pmux_ops,\n\t\t \n\t\t.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,\n\t},\n};\n\nstatic struct clk_cpu_8996_pmux perfcl_pmux = {\n\t.reg = PERFCL_REG_OFFSET + MUX_OFFSET,\n\t.nb.notifier_call = cpu_clk_notifier_cb,\n\t.clkr.hw.init = &(struct clk_init_data) {\n\t\t.name = \"perfcl_pmux\",\n\t\t.parent_hws = perfcl_pmux_parents,\n\t\t.num_parents = ARRAY_SIZE(perfcl_pmux_parents),\n\t\t.ops = &clk_cpu_8996_pmux_ops,\n\t\t \n\t\t.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,\n\t},\n};\n\nstatic const struct regmap_config cpu_msm8996_regmap_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= 0x80210,\n\t.fast_io\t\t= true,\n\t.val_format_endian\t= REGMAP_ENDIAN_LITTLE,\n};\n\nstatic struct clk_hw *cpu_msm8996_hw_clks[] = {\n\t&pwrcl_pll_postdiv.hw,\n\t&perfcl_pll_postdiv.hw,\n\t&pwrcl_pll_acd.hw,\n\t&perfcl_pll_acd.hw,\n};\n\nstatic struct clk_regmap *cpu_msm8996_clks[] = {\n\t&pwrcl_pll.clkr,\n\t&perfcl_pll.clkr,\n\t&pwrcl_alt_pll.clkr,\n\t&perfcl_alt_pll.clkr,\n\t&pwrcl_smux.clkr,\n\t&perfcl_smux.clkr,\n\t&pwrcl_pmux.clkr,\n\t&perfcl_pmux.clkr,\n};\n\nstatic void qcom_cpu_clk_msm8996_acd_init(struct regmap *regmap);\n\nstatic int qcom_cpu_clk_msm8996_register_clks(struct device *dev,\n\t\t\t\t\t      struct regmap *regmap)\n{\n\tint i, ret;\n\n\t \n\tregmap_write(regmap, PERFCL_REG_OFFSET + MUX_OFFSET, 0xc);\n\tregmap_write(regmap, PWRCL_REG_OFFSET + MUX_OFFSET, 0xc);\n\n\t \n\tudelay(5);\n\n\t \n\tregmap_update_bits(regmap, PWRCL_REG_OFFSET + MUX_OFFSET,\n\t\t\t   MUX_AUTO_CLK_SEL_ALWAYS_ON_MASK,\n\t\t\t   MUX_AUTO_CLK_SEL_ALWAYS_ON_GPLL0_SEL);\n\tregmap_update_bits(regmap, PERFCL_REG_OFFSET + MUX_OFFSET,\n\t\t\t   MUX_AUTO_CLK_SEL_ALWAYS_ON_MASK,\n\t\t\t   MUX_AUTO_CLK_SEL_ALWAYS_ON_GPLL0_SEL);\n\n\tclk_alpha_pll_configure(&pwrcl_pll, regmap, &hfpll_config);\n\tclk_alpha_pll_configure(&perfcl_pll, regmap, &hfpll_config);\n\tclk_alpha_pll_configure(&pwrcl_alt_pll, regmap, &altpll_config);\n\tclk_alpha_pll_configure(&perfcl_alt_pll, regmap, &altpll_config);\n\n\t \n\tudelay(50);\n\n\t \n\tregmap_update_bits(regmap, PWRCL_REG_OFFSET + CLK_CTL_OFFSET,\n\t\t\t   CLK_CTL_AUTO_CLK_SEL, CLK_CTL_AUTO_CLK_SEL);\n\tregmap_update_bits(regmap, PERFCL_REG_OFFSET + CLK_CTL_OFFSET,\n\t\t\t   CLK_CTL_AUTO_CLK_SEL, CLK_CTL_AUTO_CLK_SEL);\n\n\t \n\tudelay(5);\n\n\tqcom_cpu_clk_msm8996_acd_init(regmap);\n\n\t \n\tregmap_write(regmap, PWRCL_REG_OFFSET + PSCTL_OFFSET, 0x00030005);\n\tregmap_write(regmap, PERFCL_REG_OFFSET + PSCTL_OFFSET, 0x00030005);\n\n\t \n\tregmap_write(regmap, PWRCL_REG_OFFSET + MUX_OFFSET, 0x32);\n\tregmap_write(regmap, PERFCL_REG_OFFSET + MUX_OFFSET, 0x32);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_msm8996_hw_clks); i++) {\n\t\tret = devm_clk_hw_register(dev, cpu_msm8996_hw_clks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_msm8996_clks); i++) {\n\t\tret = devm_clk_register_regmap(dev, cpu_msm8996_clks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tclk_prepare_enable(pwrcl_alt_pll.clkr.hw.clk);\n\tclk_prepare_enable(perfcl_alt_pll.clkr.hw.clk);\n\n\tdevm_clk_notifier_register(dev, pwrcl_pmux.clkr.hw.clk, &pwrcl_pmux.nb);\n\tdevm_clk_notifier_register(dev, perfcl_pmux.clkr.hw.clk, &perfcl_pmux.nb);\n\n\treturn ret;\n}\n\n#define CPU_CLUSTER_AFFINITY_MASK 0xf00\n#define PWRCL_AFFINITY_MASK 0x000\n#define PERFCL_AFFINITY_MASK 0x100\n\n#define L2ACDCR_REG 0x580ULL\n#define L2ACDTD_REG 0x581ULL\n#define L2ACDDVMRC_REG 0x584ULL\n#define L2ACDSSCR_REG 0x589ULL\n\nstatic DEFINE_SPINLOCK(qcom_clk_acd_lock);\n\nstatic void qcom_cpu_clk_msm8996_acd_init(struct regmap *regmap)\n{\n\tu64 hwid;\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qcom_clk_acd_lock, flags);\n\n\tval = kryo_l2_get_indirect_reg(L2ACDTD_REG);\n\tif (val == 0x00006a11)\n\t\tgoto out;\n\n\tkryo_l2_set_indirect_reg(L2ACDTD_REG, 0x00006a11);\n\tkryo_l2_set_indirect_reg(L2ACDDVMRC_REG, 0x000e0f0f);\n\tkryo_l2_set_indirect_reg(L2ACDSSCR_REG, 0x00000601);\n\n\tkryo_l2_set_indirect_reg(L2ACDCR_REG, 0x002c5ffd);\n\n\thwid = read_cpuid_mpidr();\n\tif ((hwid & CPU_CLUSTER_AFFINITY_MASK) == PWRCL_AFFINITY_MASK)\n\t\tregmap_write(regmap, PWRCL_REG_OFFSET + SSSCTL_OFFSET, 0xf);\n\telse\n\t\tregmap_write(regmap, PERFCL_REG_OFFSET + SSSCTL_OFFSET, 0xf);\n\nout:\n\tspin_unlock_irqrestore(&qcom_clk_acd_lock, flags);\n}\n\nstatic int cpu_clk_notifier_cb(struct notifier_block *nb, unsigned long event,\n\t\t\t       void *data)\n{\n\tstruct clk_cpu_8996_pmux *cpuclk = to_clk_cpu_8996_pmux_nb(nb);\n\tstruct clk_notifier_data *cnd = data;\n\n\tswitch (event) {\n\tcase PRE_RATE_CHANGE:\n\t\tqcom_cpu_clk_msm8996_acd_init(cpuclk->clkr.regmap);\n\n\t\t \n\t\tif (cnd->new_rate < DIV_2_THRESHOLD &&\n\t\t    cnd->old_rate > DIV_2_THRESHOLD)\n\t\t\tclk_cpu_8996_pmux_set_parent(&cpuclk->clkr.hw, SMUX_INDEX);\n\n\t\tbreak;\n\tcase ABORT_RATE_CHANGE:\n\t\t \n\t\tif (cnd->new_rate < DIV_2_THRESHOLD &&\n\t\t    cnd->old_rate > DIV_2_THRESHOLD)\n\t\t\tclk_cpu_8996_pmux_set_parent(&cpuclk->clkr.hw, ACD_INDEX);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n};\n\nstatic int qcom_cpu_clk_msm8996_driver_probe(struct platform_device *pdev)\n{\n\tstatic void __iomem *base;\n\tstruct regmap *regmap;\n\tstruct clk_hw_onecell_data *data;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, struct_size(data, hws, 2), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->num = 2;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio(dev, base, &cpu_msm8996_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tret = qcom_cpu_clk_msm8996_register_clks(dev, regmap);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->hws[0] = &pwrcl_pmux.clkr.hw;\n\tdata->hws[1] = &perfcl_pmux.clkr.hw;\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, data);\n}\n\nstatic const struct of_device_id qcom_cpu_clk_msm8996_match_table[] = {\n\t{ .compatible = \"qcom,msm8996-apcc\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qcom_cpu_clk_msm8996_match_table);\n\nstatic struct platform_driver qcom_cpu_clk_msm8996_driver = {\n\t.probe = qcom_cpu_clk_msm8996_driver_probe,\n\t.driver = {\n\t\t.name = \"qcom-msm8996-apcc\",\n\t\t.of_match_table = qcom_cpu_clk_msm8996_match_table,\n\t},\n};\nmodule_platform_driver(qcom_cpu_clk_msm8996_driver);\n\nMODULE_DESCRIPTION(\"QCOM MSM8996 CPU Clock Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}