{
  "module_name": "gdsc.c",
  "hash_id": "e5db4a31b5a5e1f6ff543bd7e65108920d6c58858a16149ad5c8ab801dad4cd2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/gdsc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/pm_domain.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include \"gdsc.h\"\n\n#define PWR_ON_MASK\t\tBIT(31)\n#define EN_REST_WAIT_MASK\tGENMASK_ULL(23, 20)\n#define EN_FEW_WAIT_MASK\tGENMASK_ULL(19, 16)\n#define CLK_DIS_WAIT_MASK\tGENMASK_ULL(15, 12)\n#define SW_OVERRIDE_MASK\tBIT(2)\n#define HW_CONTROL_MASK\t\tBIT(1)\n#define SW_COLLAPSE_MASK\tBIT(0)\n#define GMEM_CLAMP_IO_MASK\tBIT(0)\n#define GMEM_RESET_MASK\t\tBIT(4)\n\n \n#define GDSC_POWER_UP_COMPLETE\t\tBIT(16)\n#define GDSC_POWER_DOWN_COMPLETE\tBIT(15)\n#define GDSC_RETAIN_FF_ENABLE\t\tBIT(11)\n#define CFG_GDSCR_OFFSET\t\t0x4\n\n \n#define EN_REST_WAIT_VAL\t0x2\n#define EN_FEW_WAIT_VAL\t\t0x8\n#define CLK_DIS_WAIT_VAL\t0x2\n\n \n#define EN_REST_WAIT_SHIFT\t20\n#define EN_FEW_WAIT_SHIFT\t16\n#define CLK_DIS_WAIT_SHIFT\t12\n\n#define RETAIN_MEM\t\tBIT(14)\n#define RETAIN_PERIPH\t\tBIT(13)\n\n#define STATUS_POLL_TIMEOUT_US\t1500\n#define TIMEOUT_US\t\t500\n\n#define domain_to_gdsc(domain) container_of(domain, struct gdsc, pd)\n\nenum gdsc_status {\n\tGDSC_OFF,\n\tGDSC_ON\n};\n\n \nstatic int gdsc_check_status(struct gdsc *sc, enum gdsc_status status)\n{\n\tunsigned int reg;\n\tu32 val;\n\tint ret;\n\n\tif (sc->flags & POLL_CFG_GDSCR)\n\t\treg = sc->gdscr + CFG_GDSCR_OFFSET;\n\telse if (sc->gds_hw_ctrl)\n\t\treg = sc->gds_hw_ctrl;\n\telse\n\t\treg = sc->gdscr;\n\n\tret = regmap_read(sc->regmap, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sc->flags & POLL_CFG_GDSCR) {\n\t\tswitch (status) {\n\t\tcase GDSC_ON:\n\t\t\treturn !!(val & GDSC_POWER_UP_COMPLETE);\n\t\tcase GDSC_OFF:\n\t\t\treturn !!(val & GDSC_POWER_DOWN_COMPLETE);\n\t\t}\n\t}\n\n\tswitch (status) {\n\tcase GDSC_ON:\n\t\treturn !!(val & PWR_ON_MASK);\n\tcase GDSC_OFF:\n\t\treturn !(val & PWR_ON_MASK);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int gdsc_hwctrl(struct gdsc *sc, bool en)\n{\n\tu32 val = en ? HW_CONTROL_MASK : 0;\n\n\treturn regmap_update_bits(sc->regmap, sc->gdscr, HW_CONTROL_MASK, val);\n}\n\nstatic int gdsc_poll_status(struct gdsc *sc, enum gdsc_status status)\n{\n\tktime_t start;\n\n\tstart = ktime_get();\n\tdo {\n\t\tif (gdsc_check_status(sc, status))\n\t\t\treturn 0;\n\t} while (ktime_us_delta(ktime_get(), start) < STATUS_POLL_TIMEOUT_US);\n\n\tif (gdsc_check_status(sc, status))\n\t\treturn 0;\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int gdsc_update_collapse_bit(struct gdsc *sc, bool val)\n{\n\tu32 reg, mask;\n\tint ret;\n\n\tif (sc->collapse_mask) {\n\t\treg = sc->collapse_ctrl;\n\t\tmask = sc->collapse_mask;\n\t} else {\n\t\treg = sc->gdscr;\n\t\tmask = SW_COLLAPSE_MASK;\n\t}\n\n\tret = regmap_update_bits(sc->regmap, reg, mask, val ? mask : 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int gdsc_toggle_logic(struct gdsc *sc, enum gdsc_status status,\n\t\tbool wait)\n{\n\tint ret;\n\n\tif (status == GDSC_ON && sc->rsupply) {\n\t\tret = regulator_enable(sc->rsupply);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = gdsc_update_collapse_bit(sc, status == GDSC_OFF);\n\n\t \n\tif ((sc->flags & VOTABLE) && status == GDSC_OFF && !wait) {\n\t\t \n\t\tudelay(TIMEOUT_US);\n\t\treturn 0;\n\t}\n\n\tif (sc->gds_hw_ctrl) {\n\t\t \n\t\tudelay(1);\n\t}\n\n\tret = gdsc_poll_status(sc, status);\n\tWARN(ret, \"%s status stuck at 'o%s'\", sc->pd.name, status ? \"ff\" : \"n\");\n\n\tif (!ret && status == GDSC_OFF && sc->rsupply) {\n\t\tret = regulator_disable(sc->rsupply);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic inline int gdsc_deassert_reset(struct gdsc *sc)\n{\n\tint i;\n\n\tfor (i = 0; i < sc->reset_count; i++)\n\t\tsc->rcdev->ops->deassert(sc->rcdev, sc->resets[i]);\n\treturn 0;\n}\n\nstatic inline int gdsc_assert_reset(struct gdsc *sc)\n{\n\tint i;\n\n\tfor (i = 0; i < sc->reset_count; i++)\n\t\tsc->rcdev->ops->assert(sc->rcdev, sc->resets[i]);\n\treturn 0;\n}\n\nstatic inline void gdsc_force_mem_on(struct gdsc *sc)\n{\n\tint i;\n\tu32 mask = RETAIN_MEM;\n\n\tif (!(sc->flags & NO_RET_PERIPH))\n\t\tmask |= RETAIN_PERIPH;\n\n\tfor (i = 0; i < sc->cxc_count; i++)\n\t\tregmap_update_bits(sc->regmap, sc->cxcs[i], mask, mask);\n}\n\nstatic inline void gdsc_clear_mem_on(struct gdsc *sc)\n{\n\tint i;\n\tu32 mask = RETAIN_MEM;\n\n\tif (!(sc->flags & NO_RET_PERIPH))\n\t\tmask |= RETAIN_PERIPH;\n\n\tfor (i = 0; i < sc->cxc_count; i++)\n\t\tregmap_update_bits(sc->regmap, sc->cxcs[i], mask, 0);\n}\n\nstatic inline void gdsc_deassert_clamp_io(struct gdsc *sc)\n{\n\tregmap_update_bits(sc->regmap, sc->clamp_io_ctrl,\n\t\t\t   GMEM_CLAMP_IO_MASK, 0);\n}\n\nstatic inline void gdsc_assert_clamp_io(struct gdsc *sc)\n{\n\tregmap_update_bits(sc->regmap, sc->clamp_io_ctrl,\n\t\t\t   GMEM_CLAMP_IO_MASK, 1);\n}\n\nstatic inline void gdsc_assert_reset_aon(struct gdsc *sc)\n{\n\tregmap_update_bits(sc->regmap, sc->clamp_io_ctrl,\n\t\t\t   GMEM_RESET_MASK, 1);\n\tudelay(1);\n\tregmap_update_bits(sc->regmap, sc->clamp_io_ctrl,\n\t\t\t   GMEM_RESET_MASK, 0);\n}\n\nstatic void gdsc_retain_ff_on(struct gdsc *sc)\n{\n\tu32 mask = GDSC_RETAIN_FF_ENABLE;\n\n\tregmap_update_bits(sc->regmap, sc->gdscr, mask, mask);\n}\n\nstatic int gdsc_enable(struct generic_pm_domain *domain)\n{\n\tstruct gdsc *sc = domain_to_gdsc(domain);\n\tint ret;\n\n\tif (sc->pwrsts == PWRSTS_ON)\n\t\treturn gdsc_deassert_reset(sc);\n\n\tif (sc->flags & SW_RESET) {\n\t\tgdsc_assert_reset(sc);\n\t\tudelay(1);\n\t\tgdsc_deassert_reset(sc);\n\t}\n\n\tif (sc->flags & CLAMP_IO) {\n\t\tif (sc->flags & AON_RESET)\n\t\t\tgdsc_assert_reset_aon(sc);\n\t\tgdsc_deassert_clamp_io(sc);\n\t}\n\n\tret = gdsc_toggle_logic(sc, GDSC_ON, false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sc->pwrsts & PWRSTS_OFF)\n\t\tgdsc_force_mem_on(sc);\n\n\t \n\tudelay(1);\n\n\t \n\tif (sc->flags & HW_CTRL) {\n\t\tret = gdsc_hwctrl(sc, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tudelay(1);\n\t}\n\n\tif (sc->flags & RETAIN_FF_ENABLE)\n\t\tgdsc_retain_ff_on(sc);\n\n\treturn 0;\n}\n\nstatic int gdsc_disable(struct generic_pm_domain *domain)\n{\n\tstruct gdsc *sc = domain_to_gdsc(domain);\n\tint ret;\n\n\tif (sc->pwrsts == PWRSTS_ON)\n\t\treturn gdsc_assert_reset(sc);\n\n\t \n\tif (sc->flags & HW_CTRL) {\n\t\tret = gdsc_hwctrl(sc, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tudelay(1);\n\n\t\tret = gdsc_poll_status(sc, GDSC_ON);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (sc->pwrsts & PWRSTS_OFF)\n\t\tgdsc_clear_mem_on(sc);\n\n\t \n\tif (sc->pwrsts == PWRSTS_RET_ON)\n\t\treturn 0;\n\n\tret = gdsc_toggle_logic(sc, GDSC_OFF, domain->synced_poweroff);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sc->flags & CLAMP_IO)\n\t\tgdsc_assert_clamp_io(sc);\n\n\treturn 0;\n}\n\nstatic int gdsc_init(struct gdsc *sc)\n{\n\tu32 mask, val;\n\tint on, ret;\n\n\t \n\tmask = HW_CONTROL_MASK | SW_OVERRIDE_MASK |\n\t       EN_REST_WAIT_MASK | EN_FEW_WAIT_MASK | CLK_DIS_WAIT_MASK;\n\n\tif (!sc->en_rest_wait_val)\n\t\tsc->en_rest_wait_val = EN_REST_WAIT_VAL;\n\tif (!sc->en_few_wait_val)\n\t\tsc->en_few_wait_val = EN_FEW_WAIT_VAL;\n\tif (!sc->clk_dis_wait_val)\n\t\tsc->clk_dis_wait_val = CLK_DIS_WAIT_VAL;\n\n\tval = sc->en_rest_wait_val << EN_REST_WAIT_SHIFT |\n\t\tsc->en_few_wait_val << EN_FEW_WAIT_SHIFT |\n\t\tsc->clk_dis_wait_val << CLK_DIS_WAIT_SHIFT;\n\n\tret = regmap_update_bits(sc->regmap, sc->gdscr, mask, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (sc->pwrsts == PWRSTS_ON) {\n\t\tret = gdsc_toggle_logic(sc, GDSC_ON, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\ton = gdsc_check_status(sc, GDSC_ON);\n\tif (on < 0)\n\t\treturn on;\n\n\tif (on) {\n\t\t \n\t\tif (sc->rsupply) {\n\t\t\tret = regulator_enable(sc->rsupply);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (sc->flags & VOTABLE) {\n\t\t\tret = gdsc_update_collapse_bit(sc, false);\n\t\t\tif (ret)\n\t\t\t\tgoto err_disable_supply;\n\t\t}\n\n\t\t \n\t\tif (sc->flags & HW_CTRL) {\n\t\t\tret = gdsc_hwctrl(sc, true);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_disable_supply;\n\t\t}\n\n\t\t \n\t\tif (sc->flags & RETAIN_FF_ENABLE)\n\t\t\tgdsc_retain_ff_on(sc);\n\t} else if (sc->flags & ALWAYS_ON) {\n\t\t \n\t\tgdsc_enable(&sc->pd);\n\t\ton = true;\n\t}\n\n\tif (on || (sc->pwrsts & PWRSTS_RET))\n\t\tgdsc_force_mem_on(sc);\n\telse\n\t\tgdsc_clear_mem_on(sc);\n\n\tif (sc->flags & ALWAYS_ON)\n\t\tsc->pd.flags |= GENPD_FLAG_ALWAYS_ON;\n\tif (!sc->pd.power_off)\n\t\tsc->pd.power_off = gdsc_disable;\n\tif (!sc->pd.power_on)\n\t\tsc->pd.power_on = gdsc_enable;\n\n\tret = pm_genpd_init(&sc->pd, NULL, !on);\n\tif (ret)\n\t\tgoto err_disable_supply;\n\n\treturn 0;\n\nerr_disable_supply:\n\tif (on && sc->rsupply)\n\t\tregulator_disable(sc->rsupply);\n\n\treturn ret;\n}\n\nint gdsc_register(struct gdsc_desc *desc,\n\t\t  struct reset_controller_dev *rcdev, struct regmap *regmap)\n{\n\tint i, ret;\n\tstruct genpd_onecell_data *data;\n\tstruct device *dev = desc->dev;\n\tstruct gdsc **scs = desc->scs;\n\tsize_t num = desc->num;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->domains = devm_kcalloc(dev, num, sizeof(*data->domains),\n\t\t\t\t     GFP_KERNEL);\n\tif (!data->domains)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (!scs[i] || !scs[i]->supply)\n\t\t\tcontinue;\n\n\t\tscs[i]->rsupply = devm_regulator_get(dev, scs[i]->supply);\n\t\tif (IS_ERR(scs[i]->rsupply))\n\t\t\treturn PTR_ERR(scs[i]->rsupply);\n\t}\n\n\tdata->num_domains = num;\n\tfor (i = 0; i < num; i++) {\n\t\tif (!scs[i])\n\t\t\tcontinue;\n\t\tscs[i]->regmap = regmap;\n\t\tscs[i]->rcdev = rcdev;\n\t\tret = gdsc_init(scs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdata->domains[i] = &scs[i]->pd;\n\t}\n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tif (!scs[i])\n\t\t\tcontinue;\n\t\tif (scs[i]->parent)\n\t\t\tpm_genpd_add_subdomain(scs[i]->parent, &scs[i]->pd);\n\t\telse if (!IS_ERR_OR_NULL(dev->pm_domain))\n\t\t\tpm_genpd_add_subdomain(pd_to_genpd(dev->pm_domain), &scs[i]->pd);\n\t}\n\n\treturn of_genpd_add_provider_onecell(dev->of_node, data);\n}\n\nvoid gdsc_unregister(struct gdsc_desc *desc)\n{\n\tint i;\n\tstruct device *dev = desc->dev;\n\tstruct gdsc **scs = desc->scs;\n\tsize_t num = desc->num;\n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tif (!scs[i])\n\t\t\tcontinue;\n\t\tif (scs[i]->parent)\n\t\t\tpm_genpd_remove_subdomain(scs[i]->parent, &scs[i]->pd);\n\t\telse if (!IS_ERR_OR_NULL(dev->pm_domain))\n\t\t\tpm_genpd_remove_subdomain(pd_to_genpd(dev->pm_domain), &scs[i]->pd);\n\t}\n\tof_genpd_del_provider(dev->of_node);\n}\n\n \nint gdsc_gx_do_nothing_enable(struct generic_pm_domain *domain)\n{\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gdsc_gx_do_nothing_enable);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}