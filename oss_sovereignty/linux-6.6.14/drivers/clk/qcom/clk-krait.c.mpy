{
  "module_name": "clk-krait.c",
  "hash_id": "f86016bca2cab26253c8656d076c456074aa64102b0cd637b5510cbbc417c090",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/clk-krait.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/clk-provider.h>\n#include <linux/spinlock.h>\n\n#include <asm/krait-l2-accessors.h>\n\n#include \"clk-krait.h\"\n\n \nstatic DEFINE_SPINLOCK(krait_clock_reg_lock);\n\n#define LPL_SHIFT\t8\n#define SECCLKAGD\tBIT(4)\n\nstatic void __krait_mux_set_sel(struct krait_mux_clk *mux, int sel)\n{\n\tunsigned long flags;\n\tu32 regval;\n\n\tspin_lock_irqsave(&krait_clock_reg_lock, flags);\n\n\tregval = krait_get_l2_indirect_reg(mux->offset);\n\n\t \n\tif (mux->disable_sec_src_gating) {\n\t\tregval |= SECCLKAGD;\n\t\tkrait_set_l2_indirect_reg(mux->offset, regval);\n\t}\n\n\tregval &= ~(mux->mask << mux->shift);\n\tregval |= (sel & mux->mask) << mux->shift;\n\tif (mux->lpl) {\n\t\tregval &= ~(mux->mask << (mux->shift + LPL_SHIFT));\n\t\tregval |= (sel & mux->mask) << (mux->shift + LPL_SHIFT);\n\t}\n\tkrait_set_l2_indirect_reg(mux->offset, regval);\n\n\t \n\tif (mux->disable_sec_src_gating) {\n\t\tregval &= ~SECCLKAGD;\n\t\tkrait_set_l2_indirect_reg(mux->offset, regval);\n\t}\n\n\t \n\tmb();\n\tudelay(1);\n\n\t \n\tspin_unlock_irqrestore(&krait_clock_reg_lock, flags);\n}\n\nstatic int krait_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct krait_mux_clk *mux = to_krait_mux_clk(hw);\n\tu32 sel;\n\n\tsel = clk_mux_index_to_val(mux->parent_map, 0, index);\n\tmux->en_mask = sel;\n\t \n\tif (__clk_is_enabled(hw->clk))\n\t\t__krait_mux_set_sel(mux, sel);\n\n\tmux->reparent = true;\n\n\treturn 0;\n}\n\nstatic u8 krait_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct krait_mux_clk *mux = to_krait_mux_clk(hw);\n\tu32 sel;\n\n\tsel = krait_get_l2_indirect_reg(mux->offset);\n\tsel >>= mux->shift;\n\tsel &= mux->mask;\n\tmux->en_mask = sel;\n\n\treturn clk_mux_val_to_index(hw, mux->parent_map, 0, sel);\n}\n\nconst struct clk_ops krait_mux_clk_ops = {\n\t.set_parent = krait_mux_set_parent,\n\t.get_parent = krait_mux_get_parent,\n\t.determine_rate = __clk_mux_determine_rate_closest,\n};\nEXPORT_SYMBOL_GPL(krait_mux_clk_ops);\n\n \nstatic int krait_div2_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)\n{\n\treq->best_parent_rate = clk_hw_round_rate(clk_hw_get_parent(hw), req->rate * 2);\n\treq->rate = DIV_ROUND_UP(req->best_parent_rate, 2);\n\treturn 0;\n}\n\nstatic int krait_div2_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct krait_div2_clk *d = to_krait_div2_clk(hw);\n\tunsigned long flags;\n\tu32 val;\n\tu32 mask = BIT(d->width) - 1;\n\n\tif (d->lpl)\n\t\tmask = mask << (d->shift + LPL_SHIFT) | mask << d->shift;\n\telse\n\t\tmask <<= d->shift;\n\n\tspin_lock_irqsave(&krait_clock_reg_lock, flags);\n\tval = krait_get_l2_indirect_reg(d->offset);\n\tval &= ~mask;\n\tkrait_set_l2_indirect_reg(d->offset, val);\n\tspin_unlock_irqrestore(&krait_clock_reg_lock, flags);\n\n\treturn 0;\n}\n\nstatic unsigned long\nkrait_div2_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct krait_div2_clk *d = to_krait_div2_clk(hw);\n\tu32 mask = BIT(d->width) - 1;\n\tu32 div;\n\n\tdiv = krait_get_l2_indirect_reg(d->offset);\n\tdiv >>= d->shift;\n\tdiv &= mask;\n\tdiv = (div + 1) * 2;\n\n\treturn DIV_ROUND_UP(parent_rate, div);\n}\n\nconst struct clk_ops krait_div2_clk_ops = {\n\t.determine_rate = krait_div2_determine_rate,\n\t.set_rate = krait_div2_set_rate,\n\t.recalc_rate = krait_div2_recalc_rate,\n};\nEXPORT_SYMBOL_GPL(krait_div2_clk_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}