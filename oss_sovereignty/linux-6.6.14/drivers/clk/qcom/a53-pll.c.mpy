{
  "module_name": "a53-pll.c",
  "hash_id": "78ff71dffe83a1f3a02c5bff203ec0c4a614acfffffb5d39db2c314a88847c31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/a53-pll.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/regmap.h>\n#include <linux/module.h>\n\n#include \"clk-pll.h\"\n#include \"clk-regmap.h\"\n\nstatic const struct pll_freq_tbl a53pll_freq[] = {\n\t{  998400000, 52, 0x0, 0x1, 0 },\n\t{ 1094400000, 57, 0x0, 0x1, 0 },\n\t{ 1152000000, 62, 0x0, 0x1, 0 },\n\t{ 1209600000, 63, 0x0, 0x1, 0 },\n\t{ 1248000000, 65, 0x0, 0x1, 0 },\n\t{ 1363200000, 71, 0x0, 0x1, 0 },\n\t{ 1401600000, 73, 0x0, 0x1, 0 },\n\t{ }\n};\n\nstatic const struct regmap_config a53pll_regmap_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= 0x40,\n\t.fast_io\t\t= true,\n};\n\nstatic struct pll_freq_tbl *qcom_a53pll_get_freq_tbl(struct device *dev)\n{\n\tstruct pll_freq_tbl *freq_tbl;\n\tunsigned long xo_freq;\n\tunsigned long freq;\n\tstruct clk *xo_clk;\n\tint count;\n\tint ret;\n\tint i;\n\n\txo_clk = devm_clk_get(dev, \"xo\");\n\tif (IS_ERR(xo_clk))\n\t\treturn NULL;\n\n\txo_freq = clk_get_rate(xo_clk);\n\n\tret = devm_pm_opp_of_add_table(dev);\n\tif (ret)\n\t\treturn NULL;\n\n\tcount = dev_pm_opp_get_opp_count(dev);\n\tif (count <= 0)\n\t\treturn NULL;\n\n\tfreq_tbl = devm_kcalloc(dev, count + 1, sizeof(*freq_tbl), GFP_KERNEL);\n\tif (!freq_tbl)\n\t\treturn NULL;\n\n\tfor (i = 0, freq = 0; i < count; i++, freq++) {\n\t\tstruct dev_pm_opp *opp;\n\n\t\topp = dev_pm_opp_find_freq_ceil(dev, &freq);\n\t\tif (IS_ERR(opp))\n\t\t\treturn NULL;\n\n\t\t \n\t\tif (freq % xo_freq)\n\t\t\tcontinue;\n\n\t\tfreq_tbl[i].freq = freq;\n\t\tfreq_tbl[i].l = freq / xo_freq;\n\t\tfreq_tbl[i].n = 1;\n\n\t\tdev_pm_opp_put(opp);\n\t}\n\n\treturn freq_tbl;\n}\n\nstatic int qcom_a53pll_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct regmap *regmap;\n\tstruct clk_pll *pll;\n\tvoid __iomem *base;\n\tstruct clk_init_data init = { };\n\tint ret;\n\n\tpll = devm_kzalloc(dev, sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio(dev, base, &a53pll_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tpll->l_reg = 0x04;\n\tpll->m_reg = 0x08;\n\tpll->n_reg = 0x0c;\n\tpll->config_reg = 0x14;\n\tpll->mode_reg = 0x00;\n\tpll->status_reg = 0x1c;\n\tpll->status_bit = 16;\n\n\tpll->freq_tbl = qcom_a53pll_get_freq_tbl(dev);\n\tif (!pll->freq_tbl) {\n\t\t \n\t\tpll->freq_tbl = a53pll_freq;\n\t}\n\n\t \n\tinit.name = devm_kasprintf(dev, GFP_KERNEL, \"a53pll%s\",\n\t\t\t\t   strchrnul(np->full_name, '@'));\n\tif (!init.name)\n\t\treturn -ENOMEM;\n\n\tinit.parent_data = &(const struct clk_parent_data){\n\t\t.fw_name = \"xo\", .name = \"xo_board\",\n\t};\n\tinit.num_parents = 1;\n\tinit.ops = &clk_pll_sr2_ops;\n\tpll->clkr.hw.init = &init;\n\n\tret = devm_clk_register_regmap(dev, &pll->clkr);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register regmap clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,\n\t\t\t\t\t  &pll->clkr.hw);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add clock provider: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qcom_a53pll_match_table[] = {\n\t{ .compatible = \"qcom,msm8916-a53pll\" },\n\t{ .compatible = \"qcom,msm8939-a53pll\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qcom_a53pll_match_table);\n\nstatic struct platform_driver qcom_a53pll_driver = {\n\t.probe = qcom_a53pll_probe,\n\t.driver = {\n\t\t.name = \"qcom-a53pll\",\n\t\t.of_match_table = qcom_a53pll_match_table,\n\t},\n};\nmodule_platform_driver(qcom_a53pll_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm A53 PLL Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}