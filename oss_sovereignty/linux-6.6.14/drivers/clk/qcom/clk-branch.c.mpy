{
  "module_name": "clk-branch.c",
  "hash_id": "0f58a943fe561579bff19fe4e39e5766ce4518b63b81fb7b2d8ac1e6e9c26454",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/clk-branch.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/clk-provider.h>\n#include <linux/regmap.h>\n\n#include \"clk-branch.h\"\n\nstatic bool clk_branch_in_hwcg_mode(const struct clk_branch *br)\n{\n\tu32 val;\n\n\tif (!br->hwcg_reg)\n\t\treturn false;\n\n\tregmap_read(br->clkr.regmap, br->hwcg_reg, &val);\n\n\treturn !!(val & BIT(br->hwcg_bit));\n}\n\nstatic bool clk_branch_check_halt(const struct clk_branch *br, bool enabling)\n{\n\tbool invert = (br->halt_check == BRANCH_HALT_ENABLE);\n\tu32 val;\n\n\tregmap_read(br->clkr.regmap, br->halt_reg, &val);\n\n\tval &= BIT(br->halt_bit);\n\tif (invert)\n\t\tval = !val;\n\n\treturn !!val == !enabling;\n}\n\nstatic bool clk_branch2_check_halt(const struct clk_branch *br, bool enabling)\n{\n\tu32 val;\n\tu32 mask;\n\tbool invert = (br->halt_check == BRANCH_HALT_ENABLE);\n\n\tmask = CBCR_NOC_FSM_STATUS;\n\tmask |= CBCR_CLK_OFF;\n\n\tregmap_read(br->clkr.regmap, br->halt_reg, &val);\n\n\tif (enabling) {\n\t\tval &= mask;\n\t\treturn (val & CBCR_CLK_OFF) == (invert ? CBCR_CLK_OFF : 0) ||\n\t\t\tFIELD_GET(CBCR_NOC_FSM_STATUS, val) == FSM_STATUS_ON;\n\t}\n\treturn (val & CBCR_CLK_OFF) == (invert ? 0 : CBCR_CLK_OFF);\n}\n\nstatic int clk_branch_wait(const struct clk_branch *br, bool enabling,\n\t\tbool (check_halt)(const struct clk_branch *, bool))\n{\n\tbool voted = br->halt_check & BRANCH_VOTED;\n\tconst char *name = clk_hw_get_name(&br->clkr.hw);\n\n\t \n\tif (br->halt_check == BRANCH_HALT_SKIP || clk_branch_in_hwcg_mode(br))\n\t\treturn 0;\n\n\tif (br->halt_check == BRANCH_HALT_DELAY || (!enabling && voted)) {\n\t\tudelay(10);\n\t} else if (br->halt_check == BRANCH_HALT_ENABLE ||\n\t\t   br->halt_check == BRANCH_HALT ||\n\t\t   (enabling && voted)) {\n\t\tint count = 200;\n\n\t\twhile (count-- > 0) {\n\t\t\tif (check_halt(br, enabling))\n\t\t\t\treturn 0;\n\t\t\tudelay(1);\n\t\t}\n\t\tWARN(1, \"%s status stuck at 'o%s'\", name,\n\t\t\t\tenabling ? \"ff\" : \"n\");\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int clk_branch_toggle(struct clk_hw *hw, bool en,\n\t\tbool (check_halt)(const struct clk_branch *, bool))\n{\n\tstruct clk_branch *br = to_clk_branch(hw);\n\tint ret;\n\n\tif (en) {\n\t\tret = clk_enable_regmap(hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tclk_disable_regmap(hw);\n\t}\n\n\treturn clk_branch_wait(br, en, check_halt);\n}\n\nstatic int clk_branch_enable(struct clk_hw *hw)\n{\n\treturn clk_branch_toggle(hw, true, clk_branch_check_halt);\n}\n\nstatic void clk_branch_disable(struct clk_hw *hw)\n{\n\tclk_branch_toggle(hw, false, clk_branch_check_halt);\n}\n\nconst struct clk_ops clk_branch_ops = {\n\t.enable = clk_branch_enable,\n\t.disable = clk_branch_disable,\n\t.is_enabled = clk_is_enabled_regmap,\n};\nEXPORT_SYMBOL_GPL(clk_branch_ops);\n\nstatic int clk_branch2_enable(struct clk_hw *hw)\n{\n\treturn clk_branch_toggle(hw, true, clk_branch2_check_halt);\n}\n\nstatic void clk_branch2_disable(struct clk_hw *hw)\n{\n\tclk_branch_toggle(hw, false, clk_branch2_check_halt);\n}\n\nconst struct clk_ops clk_branch2_ops = {\n\t.enable = clk_branch2_enable,\n\t.disable = clk_branch2_disable,\n\t.is_enabled = clk_is_enabled_regmap,\n};\nEXPORT_SYMBOL_GPL(clk_branch2_ops);\n\nconst struct clk_ops clk_branch2_aon_ops = {\n\t.enable = clk_branch2_enable,\n\t.is_enabled = clk_is_enabled_regmap,\n};\nEXPORT_SYMBOL_GPL(clk_branch2_aon_ops);\n\nconst struct clk_ops clk_branch_simple_ops = {\n\t.enable = clk_enable_regmap,\n\t.disable = clk_disable_regmap,\n\t.is_enabled = clk_is_enabled_regmap,\n};\nEXPORT_SYMBOL_GPL(clk_branch_simple_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}