{
  "module_name": "clk-rcg.c",
  "hash_id": "d11d7c8b86d86ad167178a2b840f3e1e9e384eae2b74343ea645e9e2daa8dac5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/clk-rcg.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/clk-provider.h>\n#include <linux/regmap.h>\n\n#include <asm/div64.h>\n\n#include \"clk-rcg.h\"\n#include \"common.h\"\n\nstatic u32 ns_to_src(struct src_sel *s, u32 ns)\n{\n\tns >>= s->src_sel_shift;\n\tns &= SRC_SEL_MASK;\n\treturn ns;\n}\n\nstatic u32 src_to_ns(struct src_sel *s, u8 src, u32 ns)\n{\n\tu32 mask;\n\n\tmask = SRC_SEL_MASK;\n\tmask <<= s->src_sel_shift;\n\tns &= ~mask;\n\n\tns |= src << s->src_sel_shift;\n\treturn ns;\n}\n\nstatic u8 clk_rcg_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\tint num_parents = clk_hw_get_num_parents(hw);\n\tu32 ns;\n\tint i, ret;\n\n\tret = regmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\n\tif (ret)\n\t\tgoto err;\n\tns = ns_to_src(&rcg->s, ns);\n\tfor (i = 0; i < num_parents; i++)\n\t\tif (ns == rcg->s.parent_map[i].cfg)\n\t\t\treturn i;\n\nerr:\n\tpr_debug(\"%s: Clock %s has invalid parent, using default.\\n\",\n\t\t __func__, clk_hw_get_name(hw));\n\treturn 0;\n}\n\nstatic int reg_to_bank(struct clk_dyn_rcg *rcg, u32 bank)\n{\n\tbank &= BIT(rcg->mux_sel_bit);\n\treturn !!bank;\n}\n\nstatic u8 clk_dyn_rcg_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\n\tint num_parents = clk_hw_get_num_parents(hw);\n\tu32 ns, reg;\n\tint bank;\n\tint i, ret;\n\tstruct src_sel *s;\n\n\tret = regmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\n\tif (ret)\n\t\tgoto err;\n\tbank = reg_to_bank(rcg, reg);\n\ts = &rcg->s[bank];\n\n\tret = regmap_read(rcg->clkr.regmap, rcg->ns_reg[bank], &ns);\n\tif (ret)\n\t\tgoto err;\n\tns = ns_to_src(s, ns);\n\n\tfor (i = 0; i < num_parents; i++)\n\t\tif (ns == s->parent_map[i].cfg)\n\t\t\treturn i;\n\nerr:\n\tpr_debug(\"%s: Clock %s has invalid parent, using default.\\n\",\n\t\t __func__, clk_hw_get_name(hw));\n\treturn 0;\n}\n\nstatic int clk_rcg_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\tu32 ns;\n\n\tregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\n\tns = src_to_ns(&rcg->s, rcg->s.parent_map[index].cfg, ns);\n\tregmap_write(rcg->clkr.regmap, rcg->ns_reg, ns);\n\n\treturn 0;\n}\n\nstatic u32 md_to_m(struct mn *mn, u32 md)\n{\n\tmd >>= mn->m_val_shift;\n\tmd &= BIT(mn->width) - 1;\n\treturn md;\n}\n\nstatic u32 ns_to_pre_div(struct pre_div *p, u32 ns)\n{\n\tns >>= p->pre_div_shift;\n\tns &= BIT(p->pre_div_width) - 1;\n\treturn ns;\n}\n\nstatic u32 pre_div_to_ns(struct pre_div *p, u8 pre_div, u32 ns)\n{\n\tu32 mask;\n\n\tmask = BIT(p->pre_div_width) - 1;\n\tmask <<= p->pre_div_shift;\n\tns &= ~mask;\n\n\tns |= pre_div << p->pre_div_shift;\n\treturn ns;\n}\n\nstatic u32 mn_to_md(struct mn *mn, u32 m, u32 n, u32 md)\n{\n\tu32 mask, mask_w;\n\n\tmask_w = BIT(mn->width) - 1;\n\tmask = (mask_w << mn->m_val_shift) | mask_w;\n\tmd &= ~mask;\n\n\tif (n) {\n\t\tm <<= mn->m_val_shift;\n\t\tmd |= m;\n\t\tmd |= ~n & mask_w;\n\t}\n\n\treturn md;\n}\n\nstatic u32 ns_m_to_n(struct mn *mn, u32 ns, u32 m)\n{\n\tns = ~ns >> mn->n_val_shift;\n\tns &= BIT(mn->width) - 1;\n\treturn ns + m;\n}\n\nstatic u32 reg_to_mnctr_mode(struct mn *mn, u32 val)\n{\n\tval >>= mn->mnctr_mode_shift;\n\tval &= MNCTR_MODE_MASK;\n\treturn val;\n}\n\nstatic u32 mn_to_ns(struct mn *mn, u32 m, u32 n, u32 ns)\n{\n\tu32 mask;\n\n\tmask = BIT(mn->width) - 1;\n\tmask <<= mn->n_val_shift;\n\tns &= ~mask;\n\n\tif (n) {\n\t\tn = n - m;\n\t\tn = ~n;\n\t\tn &= BIT(mn->width) - 1;\n\t\tn <<= mn->n_val_shift;\n\t\tns |= n;\n\t}\n\n\treturn ns;\n}\n\nstatic u32 mn_to_reg(struct mn *mn, u32 m, u32 n, u32 val)\n{\n\tu32 mask;\n\n\tmask = MNCTR_MODE_MASK << mn->mnctr_mode_shift;\n\tmask |= BIT(mn->mnctr_en_bit);\n\tval &= ~mask;\n\n\tif (n) {\n\t\tval |= BIT(mn->mnctr_en_bit);\n\t\tval |= MNCTR_MODE_DUAL << mn->mnctr_mode_shift;\n\t}\n\n\treturn val;\n}\n\nstatic int configure_bank(struct clk_dyn_rcg *rcg, const struct freq_tbl *f)\n{\n\tu32 ns, md, reg;\n\tint bank, new_bank, ret, index;\n\tstruct mn *mn;\n\tstruct pre_div *p;\n\tstruct src_sel *s;\n\tbool enabled;\n\tu32 md_reg, ns_reg;\n\tbool banked_mn = !!rcg->mn[1].width;\n\tbool banked_p = !!rcg->p[1].pre_div_width;\n\tstruct clk_hw *hw = &rcg->clkr.hw;\n\n\tenabled = __clk_is_enabled(hw->clk);\n\n\tret = regmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\n\tif (ret)\n\t\treturn ret;\n\tbank = reg_to_bank(rcg, reg);\n\tnew_bank = enabled ? !bank : bank;\n\n\tns_reg = rcg->ns_reg[new_bank];\n\tret = regmap_read(rcg->clkr.regmap, ns_reg, &ns);\n\tif (ret)\n\t\treturn ret;\n\n\tif (banked_mn) {\n\t\tmn = &rcg->mn[new_bank];\n\t\tmd_reg = rcg->md_reg[new_bank];\n\n\t\tns |= BIT(mn->mnctr_reset_bit);\n\t\tret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_read(rcg->clkr.regmap, md_reg, &md);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmd = mn_to_md(mn, f->m, f->n, md);\n\t\tret = regmap_write(rcg->clkr.regmap, md_reg, md);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tns = mn_to_ns(mn, f->m, f->n, ns);\n\t\tret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (rcg->ns_reg[0] != rcg->ns_reg[1]) {\n\t\t\tns = mn_to_reg(mn, f->m, f->n, ns);\n\t\t\tret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\treg = mn_to_reg(mn, f->m, f->n, reg);\n\t\t\tret = regmap_write(rcg->clkr.regmap, rcg->bank_reg,\n\t\t\t\t\t   reg);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tns &= ~BIT(mn->mnctr_reset_bit);\n\t\tret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (banked_p) {\n\t\tp = &rcg->p[new_bank];\n\t\tns = pre_div_to_ns(p, f->pre_div - 1, ns);\n\t}\n\n\ts = &rcg->s[new_bank];\n\tindex = qcom_find_src_index(hw, s->parent_map, f->src);\n\tif (index < 0)\n\t\treturn index;\n\tns = src_to_ns(s, s->parent_map[index].cfg, ns);\n\tret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\n\tif (ret)\n\t\treturn ret;\n\n\tif (enabled) {\n\t\tret = regmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treg ^= BIT(rcg->mux_sel_bit);\n\t\tret = regmap_write(rcg->clkr.regmap, rcg->bank_reg, reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int clk_dyn_rcg_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\n\tu32 ns, md, reg;\n\tint bank;\n\tstruct freq_tbl f = { 0 };\n\tbool banked_mn = !!rcg->mn[1].width;\n\tbool banked_p = !!rcg->p[1].pre_div_width;\n\n\tregmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\n\tbank = reg_to_bank(rcg, reg);\n\n\tregmap_read(rcg->clkr.regmap, rcg->ns_reg[bank], &ns);\n\n\tif (banked_mn) {\n\t\tregmap_read(rcg->clkr.regmap, rcg->md_reg[bank], &md);\n\t\tf.m = md_to_m(&rcg->mn[bank], md);\n\t\tf.n = ns_m_to_n(&rcg->mn[bank], ns, f.m);\n\t}\n\n\tif (banked_p)\n\t\tf.pre_div = ns_to_pre_div(&rcg->p[bank], ns) + 1;\n\n\tf.src = qcom_find_src_index(hw, rcg->s[bank].parent_map, index);\n\treturn configure_bank(rcg, &f);\n}\n\n \nstatic unsigned long\ncalc_rate(unsigned long rate, u32 m, u32 n, u32 mode, u32 pre_div)\n{\n\tif (pre_div)\n\t\trate /= pre_div + 1;\n\n\tif (mode) {\n\t\tu64 tmp = rate;\n\t\ttmp *= m;\n\t\tdo_div(tmp, n);\n\t\trate = tmp;\n\t}\n\n\treturn rate;\n}\n\nstatic unsigned long\nclk_rcg_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\tu32 pre_div, m = 0, n = 0, ns, md, mode = 0;\n\tstruct mn *mn = &rcg->mn;\n\n\tregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\n\tpre_div = ns_to_pre_div(&rcg->p, ns);\n\n\tif (rcg->mn.width) {\n\t\tregmap_read(rcg->clkr.regmap, rcg->md_reg, &md);\n\t\tm = md_to_m(mn, md);\n\t\tn = ns_m_to_n(mn, ns, m);\n\t\t \n\t\tif (rcg->clkr.enable_reg != rcg->ns_reg)\n\t\t\tregmap_read(rcg->clkr.regmap, rcg->clkr.enable_reg, &mode);\n\t\telse\n\t\t\tmode = ns;\n\t\tmode = reg_to_mnctr_mode(mn, mode);\n\t}\n\n\treturn calc_rate(parent_rate, m, n, mode, pre_div);\n}\n\nstatic unsigned long\nclk_dyn_rcg_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\n\tu32 m, n, pre_div, ns, md, mode, reg;\n\tint bank;\n\tstruct mn *mn;\n\tbool banked_p = !!rcg->p[1].pre_div_width;\n\tbool banked_mn = !!rcg->mn[1].width;\n\n\tregmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\n\tbank = reg_to_bank(rcg, reg);\n\n\tregmap_read(rcg->clkr.regmap, rcg->ns_reg[bank], &ns);\n\tm = n = pre_div = mode = 0;\n\n\tif (banked_mn) {\n\t\tmn = &rcg->mn[bank];\n\t\tregmap_read(rcg->clkr.regmap, rcg->md_reg[bank], &md);\n\t\tm = md_to_m(mn, md);\n\t\tn = ns_m_to_n(mn, ns, m);\n\t\t \n\t\tif (rcg->ns_reg[0] != rcg->ns_reg[1])\n\t\t\treg = ns;\n\t\tmode = reg_to_mnctr_mode(mn, reg);\n\t}\n\n\tif (banked_p)\n\t\tpre_div = ns_to_pre_div(&rcg->p[bank], ns);\n\n\treturn calc_rate(parent_rate, m, n, mode, pre_div);\n}\n\nstatic int _freq_tbl_determine_rate(struct clk_hw *hw, const struct freq_tbl *f,\n\t\tstruct clk_rate_request *req,\n\t\tconst struct parent_map *parent_map)\n{\n\tunsigned long clk_flags, rate = req->rate;\n\tstruct clk_hw *p;\n\tint index;\n\n\tf = qcom_find_freq(f, rate);\n\tif (!f)\n\t\treturn -EINVAL;\n\n\tindex = qcom_find_src_index(hw, parent_map, f->src);\n\tif (index < 0)\n\t\treturn index;\n\n\tclk_flags = clk_hw_get_flags(hw);\n\tp = clk_hw_get_parent_by_index(hw, index);\n\tif (clk_flags & CLK_SET_RATE_PARENT) {\n\t\trate = rate * f->pre_div;\n\t\tif (f->n) {\n\t\t\tu64 tmp = rate;\n\t\t\ttmp = tmp * f->n;\n\t\t\tdo_div(tmp, f->m);\n\t\t\trate = tmp;\n\t\t}\n\t} else {\n\t\trate =  clk_hw_get_rate(p);\n\t}\n\treq->best_parent_hw = p;\n\treq->best_parent_rate = rate;\n\treq->rate = f->freq;\n\n\treturn 0;\n}\n\nstatic int clk_rcg_determine_rate(struct clk_hw *hw,\n\t\t\t\t  struct clk_rate_request *req)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\n\treturn _freq_tbl_determine_rate(hw, rcg->freq_tbl, req,\n\t\t\t\t\trcg->s.parent_map);\n}\n\nstatic int clk_dyn_rcg_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\n\tu32 reg;\n\tint bank;\n\tstruct src_sel *s;\n\n\tregmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\n\tbank = reg_to_bank(rcg, reg);\n\ts = &rcg->s[bank];\n\n\treturn _freq_tbl_determine_rate(hw, rcg->freq_tbl, req, s->parent_map);\n}\n\nstatic int clk_rcg_bypass_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t struct clk_rate_request *req)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\tconst struct freq_tbl *f = rcg->freq_tbl;\n\tstruct clk_hw *p;\n\tint index = qcom_find_src_index(hw, rcg->s.parent_map, f->src);\n\n\treq->best_parent_hw = p = clk_hw_get_parent_by_index(hw, index);\n\treq->best_parent_rate = clk_hw_round_rate(p, req->rate);\n\treq->rate = req->best_parent_rate;\n\n\treturn 0;\n}\n\nstatic int __clk_rcg_set_rate(struct clk_rcg *rcg, const struct freq_tbl *f)\n{\n\tu32 ns, md, ctl;\n\tstruct mn *mn = &rcg->mn;\n\tu32 mask = 0;\n\tunsigned int reset_reg;\n\n\tif (rcg->mn.reset_in_cc)\n\t\treset_reg = rcg->clkr.enable_reg;\n\telse\n\t\treset_reg = rcg->ns_reg;\n\n\tif (rcg->mn.width) {\n\t\tmask = BIT(mn->mnctr_reset_bit);\n\t\tregmap_update_bits(rcg->clkr.regmap, reset_reg, mask, mask);\n\n\t\tregmap_read(rcg->clkr.regmap, rcg->md_reg, &md);\n\t\tmd = mn_to_md(mn, f->m, f->n, md);\n\t\tregmap_write(rcg->clkr.regmap, rcg->md_reg, md);\n\n\t\tregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\n\t\t \n\t\tif (rcg->clkr.enable_reg != rcg->ns_reg) {\n\t\t\tregmap_read(rcg->clkr.regmap, rcg->clkr.enable_reg, &ctl);\n\t\t\tctl = mn_to_reg(mn, f->m, f->n, ctl);\n\t\t\tregmap_write(rcg->clkr.regmap, rcg->clkr.enable_reg, ctl);\n\t\t} else {\n\t\t\tns = mn_to_reg(mn, f->m, f->n, ns);\n\t\t}\n\t\tns = mn_to_ns(mn, f->m, f->n, ns);\n\t} else {\n\t\tregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\n\t}\n\n\tns = pre_div_to_ns(&rcg->p, f->pre_div - 1, ns);\n\tregmap_write(rcg->clkr.regmap, rcg->ns_reg, ns);\n\n\tregmap_update_bits(rcg->clkr.regmap, reset_reg, mask, 0);\n\n\treturn 0;\n}\n\nstatic int clk_rcg_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\tconst struct freq_tbl *f;\n\n\tf = qcom_find_freq(rcg->freq_tbl, rate);\n\tif (!f)\n\t\treturn -EINVAL;\n\n\treturn __clk_rcg_set_rate(rcg, f);\n}\n\nstatic int clk_rcg_set_floor_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\tconst struct freq_tbl *f;\n\n\tf = qcom_find_freq_floor(rcg->freq_tbl, rate);\n\tif (!f)\n\t\treturn -EINVAL;\n\n\treturn __clk_rcg_set_rate(rcg, f);\n}\n\nstatic int clk_rcg_bypass_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\n\treturn __clk_rcg_set_rate(rcg, rcg->freq_tbl);\n}\n\nstatic int clk_rcg_bypass2_determine_rate(struct clk_hw *hw,\n\t\t\t\tstruct clk_rate_request *req)\n{\n\tstruct clk_hw *p;\n\n\tp = req->best_parent_hw;\n\treq->best_parent_rate = clk_hw_round_rate(p, req->rate);\n\treq->rate = req->best_parent_rate;\n\n\treturn 0;\n}\n\nstatic int clk_rcg_bypass2_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\tstruct freq_tbl f = { 0 };\n\tu32 ns, src;\n\tint i, ret, num_parents = clk_hw_get_num_parents(hw);\n\n\tret = regmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\n\tif (ret)\n\t\treturn ret;\n\n\tsrc = ns_to_src(&rcg->s, ns);\n\tf.pre_div = ns_to_pre_div(&rcg->p, ns) + 1;\n\n\tfor (i = 0; i < num_parents; i++) {\n\t\tif (src == rcg->s.parent_map[i].cfg) {\n\t\t\tf.src = rcg->s.parent_map[i].src;\n\t\t\treturn __clk_rcg_set_rate(rcg, &f);\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int clk_rcg_bypass2_set_rate_and_parent(struct clk_hw *hw,\n\t\tunsigned long rate, unsigned long parent_rate, u8 index)\n{\n\t \n\treturn clk_rcg_bypass2_set_rate(hw, rate, parent_rate);\n}\n\nstruct frac_entry {\n\tint num;\n\tint den;\n};\n\nstatic const struct frac_entry pixel_table[] = {\n\t{ 1, 2 },\n\t{ 1, 3 },\n\t{ 3, 16 },\n\t{ }\n};\n\nstatic int clk_rcg_pixel_determine_rate(struct clk_hw *hw,\n\t\tstruct clk_rate_request *req)\n{\n\tint delta = 100000;\n\tconst struct frac_entry *frac = pixel_table;\n\tunsigned long request, src_rate;\n\n\tfor (; frac->num; frac++) {\n\t\trequest = (req->rate * frac->den) / frac->num;\n\n\t\tsrc_rate = clk_hw_round_rate(req->best_parent_hw, request);\n\n\t\tif ((src_rate < (request - delta)) ||\n\t\t\t(src_rate > (request + delta)))\n\t\t\tcontinue;\n\n\t\treq->best_parent_rate = src_rate;\n\t\treq->rate = (src_rate * frac->num) / frac->den;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int clk_rcg_pixel_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\tint delta = 100000;\n\tconst struct frac_entry *frac = pixel_table;\n\tunsigned long request;\n\tstruct freq_tbl f = { 0 };\n\tu32 ns, src;\n\tint i, ret, num_parents = clk_hw_get_num_parents(hw);\n\n\tret = regmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\n\tif (ret)\n\t\treturn ret;\n\n\tsrc = ns_to_src(&rcg->s, ns);\n\n\tfor (i = 0; i < num_parents; i++) {\n\t\tif (src == rcg->s.parent_map[i].cfg) {\n\t\t\tf.src = rcg->s.parent_map[i].src;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tf.pre_div = 1;\n\n\t \n\tfor (; frac->num; frac++) {\n\t\trequest = (rate * frac->den) / frac->num;\n\n\t\tif ((parent_rate < (request - delta)) ||\n\t\t\t(parent_rate > (request + delta)))\n\t\t\tcontinue;\n\n\t\tf.m = frac->num;\n\t\tf.n = frac->den;\n\n\t\treturn __clk_rcg_set_rate(rcg, &f);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int clk_rcg_pixel_set_rate_and_parent(struct clk_hw *hw,\n\t\tunsigned long rate, unsigned long parent_rate, u8 index)\n{\n\treturn clk_rcg_pixel_set_rate(hw, rate, parent_rate);\n}\n\nstatic int clk_rcg_esc_determine_rate(struct clk_hw *hw,\n\t\tstruct clk_rate_request *req)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\tint pre_div_max = BIT(rcg->p.pre_div_width);\n\tint div;\n\tunsigned long src_rate;\n\n\tif (req->rate == 0)\n\t\treturn -EINVAL;\n\n\tsrc_rate = clk_hw_get_rate(req->best_parent_hw);\n\n\tdiv = src_rate / req->rate;\n\n\tif (div >= 1 && div <= pre_div_max) {\n\t\treq->best_parent_rate = src_rate;\n\t\treq->rate = src_rate / div;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int clk_rcg_esc_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\tstruct freq_tbl f = { 0 };\n\tint pre_div_max = BIT(rcg->p.pre_div_width);\n\tint div;\n\tu32 ns;\n\tint i, ret, num_parents = clk_hw_get_num_parents(hw);\n\n\tif (rate == 0)\n\t\treturn -EINVAL;\n\n\tret = regmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\n\tif (ret)\n\t\treturn ret;\n\n\tns = ns_to_src(&rcg->s, ns);\n\n\tfor (i = 0; i < num_parents; i++) {\n\t\tif (ns == rcg->s.parent_map[i].cfg) {\n\t\t\tf.src = rcg->s.parent_map[i].src;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdiv = parent_rate / rate;\n\n\tif (div >= 1 && div <= pre_div_max) {\n\t\tf.pre_div = div;\n\t\treturn __clk_rcg_set_rate(rcg, &f);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int clk_rcg_esc_set_rate_and_parent(struct clk_hw *hw,\n\t\tunsigned long rate, unsigned long parent_rate, u8 index)\n{\n\treturn clk_rcg_esc_set_rate(hw, rate, parent_rate);\n}\n\n \nstatic int clk_rcg_lcc_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\tconst struct freq_tbl *f;\n\tint ret;\n\tu32 gfm = BIT(10);\n\n\tf = qcom_find_freq(rcg->freq_tbl, rate);\n\tif (!f)\n\t\treturn -EINVAL;\n\n\t \n\tregmap_update_bits(rcg->clkr.regmap, rcg->ns_reg, gfm, 0);\n\tret = __clk_rcg_set_rate(rcg, f);\n\t \n\tif (__clk_is_enabled(hw->clk))\n\t\tregmap_update_bits(rcg->clkr.regmap, rcg->ns_reg, gfm, gfm);\n\n\treturn ret;\n}\n\nstatic int clk_rcg_lcc_enable(struct clk_hw *hw)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\tu32 gfm = BIT(10);\n\n\t \n\treturn regmap_update_bits(rcg->clkr.regmap, rcg->ns_reg, gfm, gfm);\n}\n\nstatic void clk_rcg_lcc_disable(struct clk_hw *hw)\n{\n\tstruct clk_rcg *rcg = to_clk_rcg(hw);\n\tu32 gfm = BIT(10);\n\n\t \n\tregmap_update_bits(rcg->clkr.regmap, rcg->ns_reg, gfm, 0);\n}\n\nstatic int __clk_dyn_rcg_set_rate(struct clk_hw *hw, unsigned long rate)\n{\n\tstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\n\tconst struct freq_tbl *f;\n\n\tf = qcom_find_freq(rcg->freq_tbl, rate);\n\tif (!f)\n\t\treturn -EINVAL;\n\n\treturn configure_bank(rcg, f);\n}\n\nstatic int clk_dyn_rcg_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\treturn __clk_dyn_rcg_set_rate(hw, rate);\n}\n\nstatic int clk_dyn_rcg_set_rate_and_parent(struct clk_hw *hw,\n\t\tunsigned long rate, unsigned long parent_rate, u8 index)\n{\n\treturn __clk_dyn_rcg_set_rate(hw, rate);\n}\n\nconst struct clk_ops clk_rcg_ops = {\n\t.enable = clk_enable_regmap,\n\t.disable = clk_disable_regmap,\n\t.get_parent = clk_rcg_get_parent,\n\t.set_parent = clk_rcg_set_parent,\n\t.recalc_rate = clk_rcg_recalc_rate,\n\t.determine_rate = clk_rcg_determine_rate,\n\t.set_rate = clk_rcg_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_rcg_ops);\n\nconst struct clk_ops clk_rcg_floor_ops = {\n\t.enable = clk_enable_regmap,\n\t.disable = clk_disable_regmap,\n\t.get_parent = clk_rcg_get_parent,\n\t.set_parent = clk_rcg_set_parent,\n\t.recalc_rate = clk_rcg_recalc_rate,\n\t.determine_rate = clk_rcg_determine_rate,\n\t.set_rate = clk_rcg_set_floor_rate,\n};\nEXPORT_SYMBOL_GPL(clk_rcg_floor_ops);\n\nconst struct clk_ops clk_rcg_bypass_ops = {\n\t.enable = clk_enable_regmap,\n\t.disable = clk_disable_regmap,\n\t.get_parent = clk_rcg_get_parent,\n\t.set_parent = clk_rcg_set_parent,\n\t.recalc_rate = clk_rcg_recalc_rate,\n\t.determine_rate = clk_rcg_bypass_determine_rate,\n\t.set_rate = clk_rcg_bypass_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_rcg_bypass_ops);\n\nconst struct clk_ops clk_rcg_bypass2_ops = {\n\t.enable = clk_enable_regmap,\n\t.disable = clk_disable_regmap,\n\t.get_parent = clk_rcg_get_parent,\n\t.set_parent = clk_rcg_set_parent,\n\t.recalc_rate = clk_rcg_recalc_rate,\n\t.determine_rate = clk_rcg_bypass2_determine_rate,\n\t.set_rate = clk_rcg_bypass2_set_rate,\n\t.set_rate_and_parent = clk_rcg_bypass2_set_rate_and_parent,\n};\nEXPORT_SYMBOL_GPL(clk_rcg_bypass2_ops);\n\nconst struct clk_ops clk_rcg_pixel_ops = {\n\t.enable = clk_enable_regmap,\n\t.disable = clk_disable_regmap,\n\t.get_parent = clk_rcg_get_parent,\n\t.set_parent = clk_rcg_set_parent,\n\t.recalc_rate = clk_rcg_recalc_rate,\n\t.determine_rate = clk_rcg_pixel_determine_rate,\n\t.set_rate = clk_rcg_pixel_set_rate,\n\t.set_rate_and_parent = clk_rcg_pixel_set_rate_and_parent,\n};\nEXPORT_SYMBOL_GPL(clk_rcg_pixel_ops);\n\nconst struct clk_ops clk_rcg_esc_ops = {\n\t.enable = clk_enable_regmap,\n\t.disable = clk_disable_regmap,\n\t.get_parent = clk_rcg_get_parent,\n\t.set_parent = clk_rcg_set_parent,\n\t.recalc_rate = clk_rcg_recalc_rate,\n\t.determine_rate = clk_rcg_esc_determine_rate,\n\t.set_rate = clk_rcg_esc_set_rate,\n\t.set_rate_and_parent = clk_rcg_esc_set_rate_and_parent,\n};\nEXPORT_SYMBOL_GPL(clk_rcg_esc_ops);\n\nconst struct clk_ops clk_rcg_lcc_ops = {\n\t.enable = clk_rcg_lcc_enable,\n\t.disable = clk_rcg_lcc_disable,\n\t.get_parent = clk_rcg_get_parent,\n\t.set_parent = clk_rcg_set_parent,\n\t.recalc_rate = clk_rcg_recalc_rate,\n\t.determine_rate = clk_rcg_determine_rate,\n\t.set_rate = clk_rcg_lcc_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_rcg_lcc_ops);\n\nconst struct clk_ops clk_dyn_rcg_ops = {\n\t.enable = clk_enable_regmap,\n\t.is_enabled = clk_is_enabled_regmap,\n\t.disable = clk_disable_regmap,\n\t.get_parent = clk_dyn_rcg_get_parent,\n\t.set_parent = clk_dyn_rcg_set_parent,\n\t.recalc_rate = clk_dyn_rcg_recalc_rate,\n\t.determine_rate = clk_dyn_rcg_determine_rate,\n\t.set_rate = clk_dyn_rcg_set_rate,\n\t.set_rate_and_parent = clk_dyn_rcg_set_rate_and_parent,\n};\nEXPORT_SYMBOL_GPL(clk_dyn_rcg_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}