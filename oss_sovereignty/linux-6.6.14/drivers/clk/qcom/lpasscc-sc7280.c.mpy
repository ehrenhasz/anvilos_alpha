{
  "module_name": "lpasscc-sc7280.c",
  "hash_id": "f1c686ed1ef79b3cade4eabff6d7ffb9c1ea57b6be28fab01a22c0783a5cebf1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/lpasscc-sc7280.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/platform_device.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/clock/qcom,lpass-sc7280.h>\n\n#include \"clk-regmap.h\"\n#include \"clk-branch.h\"\n#include \"common.h\"\n\nstatic struct clk_branch lpass_top_cc_lpi_q6_axim_hs_clk = {\n\t.halt_reg = 0x0,\n\t.halt_check = BRANCH_HALT,\n\t.clkr = {\n\t\t.enable_reg = 0x0,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"lpass_top_cc_lpi_q6_axim_hs_clk\",\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch lpass_qdsp6ss_core_clk = {\n\t.halt_reg = 0x20,\n\t \n\t.halt_check = BRANCH_HALT_SKIP,\n\t.clkr = {\n\t\t.enable_reg = 0x20,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"lpass_qdsp6ss_core_clk\",\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch lpass_qdsp6ss_xo_clk = {\n\t.halt_reg = 0x38,\n\t \n\t.halt_check = BRANCH_HALT_SKIP,\n\t.clkr = {\n\t\t.enable_reg = 0x38,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"lpass_qdsp6ss_xo_clk\",\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct clk_branch lpass_qdsp6ss_sleep_clk = {\n\t.halt_reg = 0x3c,\n\t \n\t.halt_check = BRANCH_HALT_SKIP,\n\t.clkr = {\n\t\t.enable_reg = 0x3c,\n\t\t.enable_mask = BIT(0),\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"lpass_qdsp6ss_sleep_clk\",\n\t\t\t.ops = &clk_branch2_ops,\n\t\t},\n\t},\n};\n\nstatic struct regmap_config lpass_regmap_config = {\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n\t.fast_io\t= true,\n};\n\nstatic struct clk_regmap *lpass_cc_top_sc7280_clocks[] = {\n\t[LPASS_TOP_CC_LPI_Q6_AXIM_HS_CLK] =\n\t\t\t\t&lpass_top_cc_lpi_q6_axim_hs_clk.clkr,\n};\n\nstatic const struct qcom_cc_desc lpass_cc_top_sc7280_desc = {\n\t.config = &lpass_regmap_config,\n\t.clks = lpass_cc_top_sc7280_clocks,\n\t.num_clks = ARRAY_SIZE(lpass_cc_top_sc7280_clocks),\n};\n\nstatic struct clk_regmap *lpass_qdsp6ss_sc7280_clocks[] = {\n\t[LPASS_QDSP6SS_XO_CLK] = &lpass_qdsp6ss_xo_clk.clkr,\n\t[LPASS_QDSP6SS_SLEEP_CLK] = &lpass_qdsp6ss_sleep_clk.clkr,\n\t[LPASS_QDSP6SS_CORE_CLK] = &lpass_qdsp6ss_core_clk.clkr,\n};\n\nstatic const struct qcom_cc_desc lpass_qdsp6ss_sc7280_desc = {\n\t.config = &lpass_regmap_config,\n\t.clks = lpass_qdsp6ss_sc7280_clocks,\n\t.num_clks = ARRAY_SIZE(lpass_qdsp6ss_sc7280_clocks),\n};\n\nstatic int lpass_cc_sc7280_probe(struct platform_device *pdev)\n{\n\tconst struct qcom_cc_desc *desc;\n\tint ret;\n\n\tret = devm_pm_runtime_enable(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_clk_create(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_clk_add(&pdev->dev, \"iface\");\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to acquire iface clock\\n\");\n\t\tgoto err_destroy_pm_clk;\n\t}\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret)\n\t\tgoto err_destroy_pm_clk;\n\n\tif (!of_property_read_bool(pdev->dev.of_node, \"qcom,adsp-pil-mode\")) {\n\t\tlpass_regmap_config.name = \"qdsp6ss\";\n\t\tlpass_regmap_config.max_register = 0x3f;\n\t\tdesc = &lpass_qdsp6ss_sc7280_desc;\n\n\t\tret = qcom_cc_probe_by_index(pdev, 0, desc);\n\t\tif (ret)\n\t\t\tgoto err_put_rpm;\n\t}\n\n\tlpass_regmap_config.name = \"top_cc\";\n\tlpass_regmap_config.max_register = 0x4;\n\tdesc = &lpass_cc_top_sc7280_desc;\n\n\tret = qcom_cc_probe_by_index(pdev, 1, desc);\n\tif (ret)\n\t\tgoto err_put_rpm;\n\n\tpm_runtime_put(&pdev->dev);\n\n\treturn 0;\n\nerr_put_rpm:\n\tpm_runtime_put_sync(&pdev->dev);\nerr_destroy_pm_clk:\n\tpm_clk_destroy(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id lpass_cc_sc7280_match_table[] = {\n\t{ .compatible = \"qcom,sc7280-lpasscc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lpass_cc_sc7280_match_table);\n\nstatic struct platform_driver lpass_cc_sc7280_driver = {\n\t.probe\t\t= lpass_cc_sc7280_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"sc7280-lpasscc\",\n\t\t.of_match_table = lpass_cc_sc7280_match_table,\n\t},\n};\n\nstatic int __init lpass_cc_sc7280_init(void)\n{\n\treturn platform_driver_register(&lpass_cc_sc7280_driver);\n}\nsubsys_initcall(lpass_cc_sc7280_init);\n\nstatic void __exit lpass_cc_sc7280_exit(void)\n{\n\tplatform_driver_unregister(&lpass_cc_sc7280_driver);\n}\nmodule_exit(lpass_cc_sc7280_exit);\n\nMODULE_DESCRIPTION(\"QTI LPASS_CC SC7280 Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}