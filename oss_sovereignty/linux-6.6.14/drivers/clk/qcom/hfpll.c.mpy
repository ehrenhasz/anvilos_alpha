{
  "module_name": "hfpll.c",
  "hash_id": "d82e647b277da0a32c1a3c2fff1e800c16ed27f176f9d4e679058429130f8e60",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/hfpll.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/regmap.h>\n\n#include \"clk-regmap.h\"\n#include \"clk-hfpll.h\"\n\nstatic const struct hfpll_data hdata = {\n\t.mode_reg = 0x00,\n\t.l_reg = 0x04,\n\t.m_reg = 0x08,\n\t.n_reg = 0x0c,\n\t.user_reg = 0x10,\n\t.config_reg = 0x14,\n\t.config_val = 0x430405d,\n\t.status_reg = 0x1c,\n\t.lock_bit = 16,\n\n\t.user_val = 0x8,\n\t.user_vco_mask = 0x100000,\n\t.low_vco_max_rate = 1248000000,\n\t.min_rate = 537600000UL,\n\t.max_rate = 2900000000UL,\n};\n\nstatic const struct of_device_id qcom_hfpll_match_table[] = {\n\t{ .compatible = \"qcom,hfpll\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qcom_hfpll_match_table);\n\nstatic const struct regmap_config hfpll_regmap_config = {\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n\t.max_register\t= 0x30,\n\t.fast_io\t= true,\n};\n\nstatic int qcom_hfpll_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *base;\n\tstruct regmap *regmap;\n\tstruct clk_hfpll *h;\n\tstruct clk_init_data init = {\n\t\t.num_parents = 1,\n\t\t.ops = &clk_ops_hfpll,\n\t\t \n\t\t.flags = CLK_IGNORE_UNUSED,\n\t};\n\tint ret;\n\tstruct clk_parent_data pdata = { .index = 0 };\n\n\th = devm_kzalloc(dev, sizeof(*h), GFP_KERNEL);\n\tif (!h)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio(&pdev->dev, base, &hfpll_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tif (of_property_read_string_index(dev->of_node, \"clock-output-names\",\n\t\t\t\t\t  0, &init.name))\n\t\treturn -ENODEV;\n\n\tinit.parent_data = &pdata;\n\n\th->d = &hdata;\n\th->clkr.hw.init = &init;\n\tspin_lock_init(&h->lock);\n\n\tret = devm_clk_register_regmap(dev, &h->clkr);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register regmap clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,\n\t\t\t\t\t   &h->clkr.hw);\n}\n\nstatic struct platform_driver qcom_hfpll_driver = {\n\t.probe\t\t= qcom_hfpll_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"qcom-hfpll\",\n\t\t.of_match_table = qcom_hfpll_match_table,\n\t},\n};\nmodule_platform_driver(qcom_hfpll_driver);\n\nMODULE_DESCRIPTION(\"QCOM HFPLL Clock Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:qcom-hfpll\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}