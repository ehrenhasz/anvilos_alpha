{
  "module_name": "clk-hfpll.c",
  "hash_id": "5e8ab27a58133a8118310b71648d5d02bde110219b35f62d56fe4f42d707862f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/clk-hfpll.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/clk-provider.h>\n#include <linux/spinlock.h>\n\n#include \"clk-regmap.h\"\n#include \"clk-hfpll.h\"\n\n#define PLL_OUTCTRL\tBIT(0)\n#define PLL_BYPASSNL\tBIT(1)\n#define PLL_RESET_N\tBIT(2)\n\n \nstatic void __clk_hfpll_init_once(struct clk_hw *hw)\n{\n\tstruct clk_hfpll *h = to_clk_hfpll(hw);\n\tstruct hfpll_data const *hd = h->d;\n\tstruct regmap *regmap = h->clkr.regmap;\n\n\tif (likely(h->init_done))\n\t\treturn;\n\n\t \n\tif (hd->config_val)\n\t\tregmap_write(regmap, hd->config_reg, hd->config_val);\n\tregmap_write(regmap, hd->m_reg, 0);\n\tregmap_write(regmap, hd->n_reg, 1);\n\n\tif (hd->user_reg) {\n\t\tu32 regval = hd->user_val;\n\t\tunsigned long rate;\n\n\t\trate = clk_hw_get_rate(hw);\n\n\t\t \n\t\tif (hd->user_vco_mask && rate > hd->low_vco_max_rate)\n\t\t\tregval |= hd->user_vco_mask;\n\t\tregmap_write(regmap, hd->user_reg, regval);\n\t}\n\n\tif (hd->droop_reg)\n\t\tregmap_write(regmap, hd->droop_reg, hd->droop_val);\n\n\th->init_done = true;\n}\n\nstatic void __clk_hfpll_enable(struct clk_hw *hw)\n{\n\tstruct clk_hfpll *h = to_clk_hfpll(hw);\n\tstruct hfpll_data const *hd = h->d;\n\tstruct regmap *regmap = h->clkr.regmap;\n\tu32 val;\n\n\t__clk_hfpll_init_once(hw);\n\n\t \n\tregmap_update_bits(regmap, hd->mode_reg, PLL_BYPASSNL, PLL_BYPASSNL);\n\n\t \n\tudelay(10);\n\n\t \n\tregmap_update_bits(regmap, hd->mode_reg, PLL_RESET_N, PLL_RESET_N);\n\n\t \n\tif (hd->status_reg)\n\t\t \n\t\tregmap_read_poll_timeout(regmap, hd->status_reg, val,\n\t\t\t\t\t !(val & BIT(hd->lock_bit)), 0,\n\t\t\t\t\t 100 * USEC_PER_MSEC);\n\telse\n\t\tudelay(60);\n\n\t \n\tregmap_update_bits(regmap, hd->mode_reg, PLL_OUTCTRL, PLL_OUTCTRL);\n}\n\n \nstatic int clk_hfpll_enable(struct clk_hw *hw)\n{\n\tunsigned long flags;\n\tstruct clk_hfpll *h = to_clk_hfpll(hw);\n\tstruct hfpll_data const *hd = h->d;\n\tstruct regmap *regmap = h->clkr.regmap;\n\tu32 mode;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\tregmap_read(regmap, hd->mode_reg, &mode);\n\tif (!(mode & (PLL_BYPASSNL | PLL_RESET_N | PLL_OUTCTRL)))\n\t\t__clk_hfpll_enable(hw);\n\tspin_unlock_irqrestore(&h->lock, flags);\n\n\treturn 0;\n}\n\nstatic void __clk_hfpll_disable(struct clk_hfpll *h)\n{\n\tstruct hfpll_data const *hd = h->d;\n\tstruct regmap *regmap = h->clkr.regmap;\n\n\t \n\tregmap_update_bits(regmap, hd->mode_reg,\n\t\t\t   PLL_BYPASSNL | PLL_RESET_N | PLL_OUTCTRL, 0);\n}\n\nstatic void clk_hfpll_disable(struct clk_hw *hw)\n{\n\tstruct clk_hfpll *h = to_clk_hfpll(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\t__clk_hfpll_disable(h);\n\tspin_unlock_irqrestore(&h->lock, flags);\n}\n\nstatic int clk_hfpll_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)\n{\n\tstruct clk_hfpll *h = to_clk_hfpll(hw);\n\tstruct hfpll_data const *hd = h->d;\n\tunsigned long rrate;\n\n\treq->rate = clamp(req->rate, hd->min_rate, hd->max_rate);\n\n\trrate = DIV_ROUND_UP(req->rate, req->best_parent_rate) * req->best_parent_rate;\n\tif (rrate > hd->max_rate)\n\t\trrate -= req->best_parent_rate;\n\n\treq->rate = rrate;\n\treturn 0;\n}\n\n \nstatic int clk_hfpll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct clk_hfpll *h = to_clk_hfpll(hw);\n\tstruct hfpll_data const *hd = h->d;\n\tstruct regmap *regmap = h->clkr.regmap;\n\tunsigned long flags;\n\tu32 l_val, val;\n\tbool enabled;\n\n\tl_val = rate / parent_rate;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\n\tenabled = __clk_is_enabled(hw->clk);\n\tif (enabled)\n\t\t__clk_hfpll_disable(h);\n\n\t \n\tif (hd->user_reg && hd->user_vco_mask) {\n\t\tregmap_read(regmap, hd->user_reg, &val);\n\t\tif (rate <= hd->low_vco_max_rate)\n\t\t\tval &= ~hd->user_vco_mask;\n\t\telse\n\t\t\tval |= hd->user_vco_mask;\n\t\tregmap_write(regmap, hd->user_reg, val);\n\t}\n\n\tregmap_write(regmap, hd->l_reg, l_val);\n\n\tif (enabled)\n\t\t__clk_hfpll_enable(hw);\n\n\tspin_unlock_irqrestore(&h->lock, flags);\n\n\treturn 0;\n}\n\nstatic unsigned long clk_hfpll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct clk_hfpll *h = to_clk_hfpll(hw);\n\tstruct hfpll_data const *hd = h->d;\n\tstruct regmap *regmap = h->clkr.regmap;\n\tu32 l_val;\n\n\tregmap_read(regmap, hd->l_reg, &l_val);\n\n\treturn l_val * parent_rate;\n}\n\nstatic int clk_hfpll_init(struct clk_hw *hw)\n{\n\tstruct clk_hfpll *h = to_clk_hfpll(hw);\n\tstruct hfpll_data const *hd = h->d;\n\tstruct regmap *regmap = h->clkr.regmap;\n\tu32 mode, status;\n\n\tregmap_read(regmap, hd->mode_reg, &mode);\n\tif (mode != (PLL_BYPASSNL | PLL_RESET_N | PLL_OUTCTRL)) {\n\t\t__clk_hfpll_init_once(hw);\n\t\treturn 0;\n\t}\n\n\tif (hd->status_reg) {\n\t\tregmap_read(regmap, hd->status_reg, &status);\n\t\tif (!(status & BIT(hd->lock_bit))) {\n\t\t\tWARN(1, \"HFPLL %s is ON, but not locked!\\n\",\n\t\t\t     __clk_get_name(hw->clk));\n\t\t\tclk_hfpll_disable(hw);\n\t\t\t__clk_hfpll_init_once(hw);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hfpll_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_hfpll *h = to_clk_hfpll(hw);\n\tstruct hfpll_data const *hd = h->d;\n\tstruct regmap *regmap = h->clkr.regmap;\n\tu32 mode;\n\n\tregmap_read(regmap, hd->mode_reg, &mode);\n\tmode &= 0x7;\n\treturn mode == (PLL_BYPASSNL | PLL_RESET_N | PLL_OUTCTRL);\n}\n\nconst struct clk_ops clk_ops_hfpll = {\n\t.enable = clk_hfpll_enable,\n\t.disable = clk_hfpll_disable,\n\t.is_enabled = hfpll_is_enabled,\n\t.determine_rate = clk_hfpll_determine_rate,\n\t.set_rate = clk_hfpll_set_rate,\n\t.recalc_rate = clk_hfpll_recalc_rate,\n\t.init = clk_hfpll_init,\n};\nEXPORT_SYMBOL_GPL(clk_ops_hfpll);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}