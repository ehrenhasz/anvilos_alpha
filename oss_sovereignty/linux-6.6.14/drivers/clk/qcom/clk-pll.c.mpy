{
  "module_name": "clk-pll.c",
  "hash_id": "e3c103141ac34634b2a905bf19dc5b293cd2fe93dc5a56988906eecbd443ae49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/qcom/clk-pll.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/clk-provider.h>\n#include <linux/regmap.h>\n\n#include <asm/div64.h>\n\n#include \"clk-pll.h\"\n#include \"common.h\"\n\n#define PLL_OUTCTRL\t\tBIT(0)\n#define PLL_BYPASSNL\t\tBIT(1)\n#define PLL_RESET_N\t\tBIT(2)\n\nstatic int clk_pll_enable(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tint ret;\n\tu32 mask, val;\n\n\tmask = PLL_OUTCTRL | PLL_RESET_N | PLL_BYPASSNL;\n\tret = regmap_read(pll->clkr.regmap, pll->mode_reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif ((val & mask) == mask || val & PLL_VOTE_FSM_ENA)\n\t\treturn 0;\n\n\t \n\tret = regmap_update_bits(pll->clkr.regmap, pll->mode_reg, PLL_BYPASSNL,\n\t\t\t\t PLL_BYPASSNL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tudelay(10);\n\n\t \n\tret = regmap_update_bits(pll->clkr.regmap, pll->mode_reg, PLL_RESET_N,\n\t\t\t\t PLL_RESET_N);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tudelay(50);\n\n\t \n\treturn regmap_update_bits(pll->clkr.regmap, pll->mode_reg, PLL_OUTCTRL,\n\t\t\t\t PLL_OUTCTRL);\n}\n\nstatic void clk_pll_disable(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tu32 mask;\n\tu32 val;\n\n\tregmap_read(pll->clkr.regmap, pll->mode_reg, &val);\n\t \n\tif (val & PLL_VOTE_FSM_ENA)\n\t\treturn;\n\tmask = PLL_OUTCTRL | PLL_RESET_N | PLL_BYPASSNL;\n\tregmap_update_bits(pll->clkr.regmap, pll->mode_reg, mask, 0);\n}\n\nstatic unsigned long\nclk_pll_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tu32 l, m, n, config;\n\tunsigned long rate;\n\tu64 tmp;\n\n\tregmap_read(pll->clkr.regmap, pll->l_reg, &l);\n\tregmap_read(pll->clkr.regmap, pll->m_reg, &m);\n\tregmap_read(pll->clkr.regmap, pll->n_reg, &n);\n\n\tl &= 0x3ff;\n\tm &= 0x7ffff;\n\tn &= 0x7ffff;\n\n\trate = parent_rate * l;\n\tif (n) {\n\t\ttmp = parent_rate;\n\t\ttmp *= m;\n\t\tdo_div(tmp, n);\n\t\trate += tmp;\n\t}\n\tif (pll->post_div_width) {\n\t\tregmap_read(pll->clkr.regmap, pll->config_reg, &config);\n\t\tconfig >>= pll->post_div_shift;\n\t\tconfig &= BIT(pll->post_div_width) - 1;\n\t\trate /= config + 1;\n\t}\n\n\treturn rate;\n}\n\nstatic const\nstruct pll_freq_tbl *find_freq(const struct pll_freq_tbl *f, unsigned long rate)\n{\n\tif (!f)\n\t\treturn NULL;\n\n\tfor (; f->freq; f++)\n\t\tif (rate <= f->freq)\n\t\t\treturn f;\n\n\treturn NULL;\n}\n\nstatic int\nclk_pll_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tconst struct pll_freq_tbl *f;\n\n\tf = find_freq(pll->freq_tbl, req->rate);\n\tif (!f)\n\t\treq->rate = clk_pll_recalc_rate(hw, req->best_parent_rate);\n\telse\n\t\treq->rate = f->freq;\n\n\treturn 0;\n}\n\nstatic int\nclk_pll_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long p_rate)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tconst struct pll_freq_tbl *f;\n\tbool enabled;\n\tu32 mode;\n\tu32 enable_mask = PLL_OUTCTRL | PLL_BYPASSNL | PLL_RESET_N;\n\n\tf = find_freq(pll->freq_tbl, rate);\n\tif (!f)\n\t\treturn -EINVAL;\n\n\tregmap_read(pll->clkr.regmap, pll->mode_reg, &mode);\n\tenabled = (mode & enable_mask) == enable_mask;\n\n\tif (enabled)\n\t\tclk_pll_disable(hw);\n\n\tregmap_update_bits(pll->clkr.regmap, pll->l_reg, 0x3ff, f->l);\n\tregmap_update_bits(pll->clkr.regmap, pll->m_reg, 0x7ffff, f->m);\n\tregmap_update_bits(pll->clkr.regmap, pll->n_reg, 0x7ffff, f->n);\n\tregmap_write(pll->clkr.regmap, pll->config_reg, f->ibits);\n\n\tif (enabled)\n\t\tclk_pll_enable(hw);\n\n\treturn 0;\n}\n\nconst struct clk_ops clk_pll_ops = {\n\t.enable = clk_pll_enable,\n\t.disable = clk_pll_disable,\n\t.recalc_rate = clk_pll_recalc_rate,\n\t.determine_rate = clk_pll_determine_rate,\n\t.set_rate = clk_pll_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_pll_ops);\n\nstatic int wait_for_pll(struct clk_pll *pll)\n{\n\tu32 val;\n\tint count;\n\tint ret;\n\tconst char *name = clk_hw_get_name(&pll->clkr.hw);\n\n\t \n\tfor (count = 200; count > 0; count--) {\n\t\tret = regmap_read(pll->clkr.regmap, pll->status_reg, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (val & BIT(pll->status_bit))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\tWARN(1, \"%s didn't enable after voting for it!\\n\", name);\n\treturn -ETIMEDOUT;\n}\n\nstatic int clk_pll_vote_enable(struct clk_hw *hw)\n{\n\tint ret;\n\tstruct clk_pll *p = to_clk_pll(clk_hw_get_parent(hw));\n\n\tret = clk_enable_regmap(hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn wait_for_pll(p);\n}\n\nconst struct clk_ops clk_pll_vote_ops = {\n\t.enable = clk_pll_vote_enable,\n\t.disable = clk_disable_regmap,\n};\nEXPORT_SYMBOL_GPL(clk_pll_vote_ops);\n\nstatic void clk_pll_configure(struct clk_pll *pll, struct regmap *regmap,\n\tconst struct pll_config *config)\n{\n\tu32 val;\n\tu32 mask;\n\n\tregmap_write(regmap, pll->l_reg, config->l);\n\tregmap_write(regmap, pll->m_reg, config->m);\n\tregmap_write(regmap, pll->n_reg, config->n);\n\n\tval = config->vco_val;\n\tval |= config->pre_div_val;\n\tval |= config->post_div_val;\n\tval |= config->mn_ena_mask;\n\tval |= config->main_output_mask;\n\tval |= config->aux_output_mask;\n\n\tmask = config->vco_mask;\n\tmask |= config->pre_div_mask;\n\tmask |= config->post_div_mask;\n\tmask |= config->mn_ena_mask;\n\tmask |= config->main_output_mask;\n\tmask |= config->aux_output_mask;\n\n\tregmap_update_bits(regmap, pll->config_reg, mask, val);\n}\n\nvoid clk_pll_configure_sr(struct clk_pll *pll, struct regmap *regmap,\n\t\tconst struct pll_config *config, bool fsm_mode)\n{\n\tclk_pll_configure(pll, regmap, config);\n\tif (fsm_mode)\n\t\tqcom_pll_set_fsm_mode(regmap, pll->mode_reg, 1, 8);\n}\nEXPORT_SYMBOL_GPL(clk_pll_configure_sr);\n\nvoid clk_pll_configure_sr_hpm_lp(struct clk_pll *pll, struct regmap *regmap,\n\t\tconst struct pll_config *config, bool fsm_mode)\n{\n\tclk_pll_configure(pll, regmap, config);\n\tif (fsm_mode)\n\t\tqcom_pll_set_fsm_mode(regmap, pll->mode_reg, 1, 0);\n}\nEXPORT_SYMBOL_GPL(clk_pll_configure_sr_hpm_lp);\n\nstatic int clk_pll_sr2_enable(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tint ret;\n\tu32 mode;\n\n\tret = regmap_read(pll->clkr.regmap, pll->mode_reg, &mode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(pll->clkr.regmap, pll->mode_reg, PLL_BYPASSNL,\n\t\t\t\t PLL_BYPASSNL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tudelay(10);\n\n\t \n\tret = regmap_update_bits(pll->clkr.regmap, pll->mode_reg, PLL_RESET_N,\n\t\t\t\t PLL_RESET_N);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_for_pll(pll);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(pll->clkr.regmap, pll->mode_reg, PLL_OUTCTRL,\n\t\t\t\t PLL_OUTCTRL);\n}\n\nstatic int\nclk_pll_sr2_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long prate)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tconst struct pll_freq_tbl *f;\n\tbool enabled;\n\tu32 mode;\n\tu32 enable_mask = PLL_OUTCTRL | PLL_BYPASSNL | PLL_RESET_N;\n\n\tf = find_freq(pll->freq_tbl, rate);\n\tif (!f)\n\t\treturn -EINVAL;\n\n\tregmap_read(pll->clkr.regmap, pll->mode_reg, &mode);\n\tenabled = (mode & enable_mask) == enable_mask;\n\n\tif (enabled)\n\t\tclk_pll_disable(hw);\n\n\tregmap_update_bits(pll->clkr.regmap, pll->l_reg, 0x3ff, f->l);\n\tregmap_update_bits(pll->clkr.regmap, pll->m_reg, 0x7ffff, f->m);\n\tregmap_update_bits(pll->clkr.regmap, pll->n_reg, 0x7ffff, f->n);\n\n\tif (enabled)\n\t\tclk_pll_sr2_enable(hw);\n\n\treturn 0;\n}\n\nconst struct clk_ops clk_pll_sr2_ops = {\n\t.enable = clk_pll_sr2_enable,\n\t.disable = clk_pll_disable,\n\t.set_rate = clk_pll_sr2_set_rate,\n\t.recalc_rate = clk_pll_recalc_rate,\n\t.determine_rate = clk_pll_determine_rate,\n};\nEXPORT_SYMBOL_GPL(clk_pll_sr2_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}