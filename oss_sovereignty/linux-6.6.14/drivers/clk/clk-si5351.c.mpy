{
  "module_name": "clk-si5351.c",
  "hash_id": "b791d48d5b9267b5188fe9f6e8ab0b7144c9d317ec61709c206242b3cdeedd9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-si5351.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/rational.h>\n#include <linux/i2c.h>\n#include <linux/of.h>\n#include <linux/platform_data/si5351.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <asm/div64.h>\n\n#include \"clk-si5351.h\"\n\nstruct si5351_driver_data;\n\nstruct si5351_parameters {\n\tunsigned long\tp1;\n\tunsigned long\tp2;\n\tunsigned long\tp3;\n\tint\t\tvalid;\n};\n\nstruct si5351_hw_data {\n\tstruct clk_hw\t\t\thw;\n\tstruct si5351_driver_data\t*drvdata;\n\tstruct si5351_parameters\tparams;\n\tunsigned char\t\t\tnum;\n};\n\nstruct si5351_driver_data {\n\tenum si5351_variant\tvariant;\n\tstruct i2c_client\t*client;\n\tstruct regmap\t\t*regmap;\n\n\tstruct clk\t\t*pxtal;\n\tconst char\t\t*pxtal_name;\n\tstruct clk_hw\t\txtal;\n\tstruct clk\t\t*pclkin;\n\tconst char\t\t*pclkin_name;\n\tstruct clk_hw\t\tclkin;\n\n\tstruct si5351_hw_data\tpll[2];\n\tstruct si5351_hw_data\t*msynth;\n\tstruct si5351_hw_data\t*clkout;\n\tsize_t\t\t\tnum_clkout;\n};\n\nstatic const char * const si5351_input_names[] = {\n\t\"xtal\", \"clkin\"\n};\nstatic const char * const si5351_pll_names[] = {\n\t\"si5351_plla\", \"si5351_pllb\", \"si5351_vxco\"\n};\nstatic const char * const si5351_msynth_names[] = {\n\t\"ms0\", \"ms1\", \"ms2\", \"ms3\", \"ms4\", \"ms5\", \"ms6\", \"ms7\"\n};\nstatic const char * const si5351_clkout_names[] = {\n\t\"clk0\", \"clk1\", \"clk2\", \"clk3\", \"clk4\", \"clk5\", \"clk6\", \"clk7\"\n};\n\n \nstatic inline u8 si5351_reg_read(struct si5351_driver_data *drvdata, u8 reg)\n{\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(drvdata->regmap, reg, &val);\n\tif (ret) {\n\t\tdev_err(&drvdata->client->dev,\n\t\t\t\"unable to read from reg%02x\\n\", reg);\n\t\treturn 0;\n\t}\n\n\treturn (u8)val;\n}\n\nstatic inline int si5351_bulk_read(struct si5351_driver_data *drvdata,\n\t\t\t\t   u8 reg, u8 count, u8 *buf)\n{\n\treturn regmap_bulk_read(drvdata->regmap, reg, buf, count);\n}\n\nstatic inline int si5351_reg_write(struct si5351_driver_data *drvdata,\n\t\t\t\t   u8 reg, u8 val)\n{\n\treturn regmap_write(drvdata->regmap, reg, val);\n}\n\nstatic inline int si5351_bulk_write(struct si5351_driver_data *drvdata,\n\t\t\t\t    u8 reg, u8 count, const u8 *buf)\n{\n\treturn regmap_raw_write(drvdata->regmap, reg, buf, count);\n}\n\nstatic inline int si5351_set_bits(struct si5351_driver_data *drvdata,\n\t\t\t\t  u8 reg, u8 mask, u8 val)\n{\n\treturn regmap_update_bits(drvdata->regmap, reg, mask, val);\n}\n\nstatic inline u8 si5351_msynth_params_address(int num)\n{\n\tif (num > 5)\n\t\treturn SI5351_CLK6_PARAMETERS + (num - 6);\n\treturn SI5351_CLK0_PARAMETERS + (SI5351_PARAMETERS_LENGTH * num);\n}\n\nstatic void si5351_read_parameters(struct si5351_driver_data *drvdata,\n\t\t\t\t   u8 reg, struct si5351_parameters *params)\n{\n\tu8 buf[SI5351_PARAMETERS_LENGTH];\n\n\tswitch (reg) {\n\tcase SI5351_CLK6_PARAMETERS:\n\tcase SI5351_CLK7_PARAMETERS:\n\t\tbuf[0] = si5351_reg_read(drvdata, reg);\n\t\tparams->p1 = buf[0];\n\t\tparams->p2 = 0;\n\t\tparams->p3 = 1;\n\t\tbreak;\n\tdefault:\n\t\tsi5351_bulk_read(drvdata, reg, SI5351_PARAMETERS_LENGTH, buf);\n\t\tparams->p1 = ((buf[2] & 0x03) << 16) | (buf[3] << 8) | buf[4];\n\t\tparams->p2 = ((buf[5] & 0x0f) << 16) | (buf[6] << 8) | buf[7];\n\t\tparams->p3 = ((buf[5] & 0xf0) << 12) | (buf[0] << 8) | buf[1];\n\t}\n\tparams->valid = 1;\n}\n\nstatic void si5351_write_parameters(struct si5351_driver_data *drvdata,\n\t\t\t\t    u8 reg, struct si5351_parameters *params)\n{\n\tu8 buf[SI5351_PARAMETERS_LENGTH];\n\n\tswitch (reg) {\n\tcase SI5351_CLK6_PARAMETERS:\n\tcase SI5351_CLK7_PARAMETERS:\n\t\tbuf[0] = params->p1 & 0xff;\n\t\tsi5351_reg_write(drvdata, reg, buf[0]);\n\t\tbreak;\n\tdefault:\n\t\tbuf[0] = ((params->p3 & 0x0ff00) >> 8) & 0xff;\n\t\tbuf[1] = params->p3 & 0xff;\n\t\t \n\t\tbuf[2] = si5351_reg_read(drvdata, reg + 2) & ~0x03;\n\t\tbuf[2] |= ((params->p1 & 0x30000) >> 16) & 0x03;\n\t\tbuf[3] = ((params->p1 & 0x0ff00) >> 8) & 0xff;\n\t\tbuf[4] = params->p1 & 0xff;\n\t\tbuf[5] = ((params->p3 & 0xf0000) >> 12) |\n\t\t\t((params->p2 & 0xf0000) >> 16);\n\t\tbuf[6] = ((params->p2 & 0x0ff00) >> 8) & 0xff;\n\t\tbuf[7] = params->p2 & 0xff;\n\t\tsi5351_bulk_write(drvdata, reg, SI5351_PARAMETERS_LENGTH, buf);\n\t}\n}\n\nstatic bool si5351_regmap_is_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SI5351_DEVICE_STATUS:\n\tcase SI5351_INTERRUPT_STATUS:\n\tcase SI5351_PLL_RESET:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool si5351_regmap_is_writeable(struct device *dev, unsigned int reg)\n{\n\t \n\tif (reg >= 4 && reg <= 8)\n\t\treturn false;\n\tif (reg >= 10 && reg <= 14)\n\t\treturn false;\n\tif (reg >= 173 && reg <= 176)\n\t\treturn false;\n\tif (reg >= 178 && reg <= 182)\n\t\treturn false;\n\t \n\tif (reg == SI5351_DEVICE_STATUS)\n\t\treturn false;\n\treturn true;\n}\n\nstatic const struct regmap_config si5351_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = 187,\n\t.writeable_reg = si5351_regmap_is_writeable,\n\t.volatile_reg = si5351_regmap_is_volatile,\n};\n\n \nstatic int si5351_xtal_prepare(struct clk_hw *hw)\n{\n\tstruct si5351_driver_data *drvdata =\n\t\tcontainer_of(hw, struct si5351_driver_data, xtal);\n\tsi5351_set_bits(drvdata, SI5351_FANOUT_ENABLE,\n\t\t\tSI5351_XTAL_ENABLE, SI5351_XTAL_ENABLE);\n\treturn 0;\n}\n\nstatic void si5351_xtal_unprepare(struct clk_hw *hw)\n{\n\tstruct si5351_driver_data *drvdata =\n\t\tcontainer_of(hw, struct si5351_driver_data, xtal);\n\tsi5351_set_bits(drvdata, SI5351_FANOUT_ENABLE,\n\t\t\tSI5351_XTAL_ENABLE, 0);\n}\n\nstatic const struct clk_ops si5351_xtal_ops = {\n\t.prepare = si5351_xtal_prepare,\n\t.unprepare = si5351_xtal_unprepare,\n};\n\n \nstatic int si5351_clkin_prepare(struct clk_hw *hw)\n{\n\tstruct si5351_driver_data *drvdata =\n\t\tcontainer_of(hw, struct si5351_driver_data, clkin);\n\tsi5351_set_bits(drvdata, SI5351_FANOUT_ENABLE,\n\t\t\tSI5351_CLKIN_ENABLE, SI5351_CLKIN_ENABLE);\n\treturn 0;\n}\n\nstatic void si5351_clkin_unprepare(struct clk_hw *hw)\n{\n\tstruct si5351_driver_data *drvdata =\n\t\tcontainer_of(hw, struct si5351_driver_data, clkin);\n\tsi5351_set_bits(drvdata, SI5351_FANOUT_ENABLE,\n\t\t\tSI5351_CLKIN_ENABLE, 0);\n}\n\n \nstatic unsigned long si5351_clkin_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct si5351_driver_data *drvdata =\n\t\tcontainer_of(hw, struct si5351_driver_data, clkin);\n\tunsigned long rate;\n\tunsigned char idiv;\n\n\trate = parent_rate;\n\tif (parent_rate > 160000000) {\n\t\tidiv = SI5351_CLKIN_DIV_8;\n\t\trate /= 8;\n\t} else if (parent_rate > 80000000) {\n\t\tidiv = SI5351_CLKIN_DIV_4;\n\t\trate /= 4;\n\t} else if (parent_rate > 40000000) {\n\t\tidiv = SI5351_CLKIN_DIV_2;\n\t\trate /= 2;\n\t} else {\n\t\tidiv = SI5351_CLKIN_DIV_1;\n\t}\n\n\tsi5351_set_bits(drvdata, SI5351_PLL_INPUT_SOURCE,\n\t\t\tSI5351_CLKIN_DIV_MASK, idiv);\n\n\tdev_dbg(&drvdata->client->dev, \"%s - clkin div = %d, rate = %lu\\n\",\n\t\t__func__, (1 << (idiv >> 6)), rate);\n\n\treturn rate;\n}\n\nstatic const struct clk_ops si5351_clkin_ops = {\n\t.prepare = si5351_clkin_prepare,\n\t.unprepare = si5351_clkin_unprepare,\n\t.recalc_rate = si5351_clkin_recalc_rate,\n};\n\n \n\nstatic int si5351_vxco_prepare(struct clk_hw *hw)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\n\tdev_warn(&hwdata->drvdata->client->dev, \"VXCO currently unsupported\\n\");\n\n\treturn 0;\n}\n\nstatic void si5351_vxco_unprepare(struct clk_hw *hw)\n{\n}\n\nstatic unsigned long si5351_vxco_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\treturn 0;\n}\n\nstatic int si5351_vxco_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent)\n{\n\treturn 0;\n}\n\nstatic const struct clk_ops si5351_vxco_ops = {\n\t.prepare = si5351_vxco_prepare,\n\t.unprepare = si5351_vxco_unprepare,\n\t.recalc_rate = si5351_vxco_recalc_rate,\n\t.set_rate = si5351_vxco_set_rate,\n};\n\n \nstatic int _si5351_pll_reparent(struct si5351_driver_data *drvdata,\n\t\t\t\tint num, enum si5351_pll_src parent)\n{\n\tu8 mask = (num == 0) ? SI5351_PLLA_SOURCE : SI5351_PLLB_SOURCE;\n\n\tif (parent == SI5351_PLL_SRC_DEFAULT)\n\t\treturn 0;\n\n\tif (num > 2)\n\t\treturn -EINVAL;\n\n\tif (drvdata->variant != SI5351_VARIANT_C &&\n\t    parent != SI5351_PLL_SRC_XTAL)\n\t\treturn -EINVAL;\n\n\tsi5351_set_bits(drvdata, SI5351_PLL_INPUT_SOURCE, mask,\n\t\t\t(parent == SI5351_PLL_SRC_XTAL) ? 0 : mask);\n\treturn 0;\n}\n\nstatic unsigned char si5351_pll_get_parent(struct clk_hw *hw)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\tu8 mask = (hwdata->num == 0) ? SI5351_PLLA_SOURCE : SI5351_PLLB_SOURCE;\n\tu8 val;\n\n\tval = si5351_reg_read(hwdata->drvdata, SI5351_PLL_INPUT_SOURCE);\n\n\treturn (val & mask) ? 1 : 0;\n}\n\nstatic int si5351_pll_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\n\tif (hwdata->drvdata->variant != SI5351_VARIANT_C &&\n\t    index > 0)\n\t\treturn -EPERM;\n\n\tif (index > 1)\n\t\treturn -EINVAL;\n\n\treturn _si5351_pll_reparent(hwdata->drvdata, hwdata->num,\n\t\t\t     (index == 0) ? SI5351_PLL_SRC_XTAL :\n\t\t\t     SI5351_PLL_SRC_CLKIN);\n}\n\nstatic unsigned long si5351_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\tu8 reg = (hwdata->num == 0) ? SI5351_PLLA_PARAMETERS :\n\t\tSI5351_PLLB_PARAMETERS;\n\tunsigned long long rate;\n\n\tif (!hwdata->params.valid)\n\t\tsi5351_read_parameters(hwdata->drvdata, reg, &hwdata->params);\n\n\tif (hwdata->params.p3 == 0)\n\t\treturn parent_rate;\n\n\t \n\trate  = hwdata->params.p1 * hwdata->params.p3;\n\trate += 512 * hwdata->params.p3;\n\trate += hwdata->params.p2;\n\trate *= parent_rate;\n\tdo_div(rate, 128 * hwdata->params.p3);\n\n\tdev_dbg(&hwdata->drvdata->client->dev,\n\t\t\"%s - %s: p1 = %lu, p2 = %lu, p3 = %lu, parent_rate = %lu, rate = %lu\\n\",\n\t\t__func__, clk_hw_get_name(hw),\n\t\thwdata->params.p1, hwdata->params.p2, hwdata->params.p3,\n\t\tparent_rate, (unsigned long)rate);\n\n\treturn (unsigned long)rate;\n}\n\nstatic int si5351_pll_determine_rate(struct clk_hw *hw,\n\t\t\t\t     struct clk_rate_request *req)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\tunsigned long rate = req->rate;\n\tunsigned long rfrac, denom, a, b, c;\n\tunsigned long long lltmp;\n\n\tif (rate < SI5351_PLL_VCO_MIN)\n\t\trate = SI5351_PLL_VCO_MIN;\n\tif (rate > SI5351_PLL_VCO_MAX)\n\t\trate = SI5351_PLL_VCO_MAX;\n\n\t \n\ta = rate / req->best_parent_rate;\n\n\tif (a < SI5351_PLL_A_MIN)\n\t\trate = req->best_parent_rate * SI5351_PLL_A_MIN;\n\tif (a > SI5351_PLL_A_MAX)\n\t\trate = req->best_parent_rate * SI5351_PLL_A_MAX;\n\n\t \n\tdenom = 1000 * 1000;\n\tlltmp = rate % (req->best_parent_rate);\n\tlltmp *= denom;\n\tdo_div(lltmp, req->best_parent_rate);\n\trfrac = (unsigned long)lltmp;\n\n\tb = 0;\n\tc = 1;\n\tif (rfrac)\n\t\trational_best_approximation(rfrac, denom,\n\t\t\t\t    SI5351_PLL_B_MAX, SI5351_PLL_C_MAX, &b, &c);\n\n\t \n\thwdata->params.p3  = c;\n\thwdata->params.p2  = (128 * b) % c;\n\thwdata->params.p1  = 128 * a;\n\thwdata->params.p1 += (128 * b / c);\n\thwdata->params.p1 -= 512;\n\n\t \n\tlltmp  = req->best_parent_rate;\n\tlltmp *= b;\n\tdo_div(lltmp, c);\n\n\trate  = (unsigned long)lltmp;\n\trate += req->best_parent_rate * a;\n\n\tdev_dbg(&hwdata->drvdata->client->dev,\n\t\t\"%s - %s: a = %lu, b = %lu, c = %lu, parent_rate = %lu, rate = %lu\\n\",\n\t\t__func__, clk_hw_get_name(hw), a, b, c,\n\t\treq->best_parent_rate, rate);\n\n\treq->rate = rate;\n\treturn 0;\n}\n\nstatic int si5351_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\tu8 reg = (hwdata->num == 0) ? SI5351_PLLA_PARAMETERS :\n\t\tSI5351_PLLB_PARAMETERS;\n\n\t \n\tsi5351_write_parameters(hwdata->drvdata, reg, &hwdata->params);\n\n\t \n\tsi5351_set_bits(hwdata->drvdata, SI5351_CLK6_CTRL + hwdata->num,\n\t\tSI5351_CLK_INTEGER_MODE,\n\t\t(hwdata->params.p2 == 0) ? SI5351_CLK_INTEGER_MODE : 0);\n\n\t \n\tsi5351_reg_write(hwdata->drvdata, SI5351_PLL_RESET,\n\t\t\t hwdata->num == 0 ? SI5351_PLL_RESET_A :\n\t\t\t\t\t    SI5351_PLL_RESET_B);\n\n\tdev_dbg(&hwdata->drvdata->client->dev,\n\t\t\"%s - %s: p1 = %lu, p2 = %lu, p3 = %lu, parent_rate = %lu, rate = %lu\\n\",\n\t\t__func__, clk_hw_get_name(hw),\n\t\thwdata->params.p1, hwdata->params.p2, hwdata->params.p3,\n\t\tparent_rate, rate);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops si5351_pll_ops = {\n\t.set_parent = si5351_pll_set_parent,\n\t.get_parent = si5351_pll_get_parent,\n\t.recalc_rate = si5351_pll_recalc_rate,\n\t.determine_rate = si5351_pll_determine_rate,\n\t.set_rate = si5351_pll_set_rate,\n};\n\n \nstatic int _si5351_msynth_reparent(struct si5351_driver_data *drvdata,\n\t\t\t\t   int num, enum si5351_multisynth_src parent)\n{\n\tif (parent == SI5351_MULTISYNTH_SRC_DEFAULT)\n\t\treturn 0;\n\n\tif (num > 8)\n\t\treturn -EINVAL;\n\n\tsi5351_set_bits(drvdata, SI5351_CLK0_CTRL + num, SI5351_CLK_PLL_SELECT,\n\t\t\t(parent == SI5351_MULTISYNTH_SRC_VCO0) ? 0 :\n\t\t\tSI5351_CLK_PLL_SELECT);\n\treturn 0;\n}\n\nstatic unsigned char si5351_msynth_get_parent(struct clk_hw *hw)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\tu8 val;\n\n\tval = si5351_reg_read(hwdata->drvdata, SI5351_CLK0_CTRL + hwdata->num);\n\n\treturn (val & SI5351_CLK_PLL_SELECT) ? 1 : 0;\n}\n\nstatic int si5351_msynth_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\n\treturn _si5351_msynth_reparent(hwdata->drvdata, hwdata->num,\n\t\t\t       (index == 0) ? SI5351_MULTISYNTH_SRC_VCO0 :\n\t\t\t       SI5351_MULTISYNTH_SRC_VCO1);\n}\n\nstatic unsigned long si5351_msynth_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\tu8 reg = si5351_msynth_params_address(hwdata->num);\n\tunsigned long long rate;\n\tunsigned long m;\n\n\tif (!hwdata->params.valid)\n\t\tsi5351_read_parameters(hwdata->drvdata, reg, &hwdata->params);\n\n\t \n\trate = parent_rate;\n\tif (hwdata->num > 5) {\n\t\tm = hwdata->params.p1;\n\t} else if (hwdata->params.p3 == 0) {\n\t\treturn parent_rate;\n\t} else if ((si5351_reg_read(hwdata->drvdata, reg + 2) &\n\t\t    SI5351_OUTPUT_CLK_DIVBY4) == SI5351_OUTPUT_CLK_DIVBY4) {\n\t\tm = 4;\n\t} else {\n\t\trate *= 128 * hwdata->params.p3;\n\t\tm = hwdata->params.p1 * hwdata->params.p3;\n\t\tm += hwdata->params.p2;\n\t\tm += 512 * hwdata->params.p3;\n\t}\n\n\tif (m == 0)\n\t\treturn 0;\n\tdo_div(rate, m);\n\n\tdev_dbg(&hwdata->drvdata->client->dev,\n\t\t\"%s - %s: p1 = %lu, p2 = %lu, p3 = %lu, m = %lu, parent_rate = %lu, rate = %lu\\n\",\n\t\t__func__, clk_hw_get_name(hw),\n\t\thwdata->params.p1, hwdata->params.p2, hwdata->params.p3,\n\t\tm, parent_rate, (unsigned long)rate);\n\n\treturn (unsigned long)rate;\n}\n\nstatic int si5351_msynth_determine_rate(struct clk_hw *hw,\n\t\t\t\t\tstruct clk_rate_request *req)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\tunsigned long rate = req->rate;\n\tunsigned long long lltmp;\n\tunsigned long a, b, c;\n\tint divby4;\n\n\t \n\tif (hwdata->num >= 6 && rate > SI5351_MULTISYNTH67_MAX_FREQ)\n\t\trate = SI5351_MULTISYNTH67_MAX_FREQ;\n\n\t \n\tif (rate > SI5351_MULTISYNTH_MAX_FREQ)\n\t\trate = SI5351_MULTISYNTH_MAX_FREQ;\n\tif (rate < SI5351_MULTISYNTH_MIN_FREQ)\n\t\trate = SI5351_MULTISYNTH_MIN_FREQ;\n\n\tdivby4 = 0;\n\tif (rate > SI5351_MULTISYNTH_DIVBY4_FREQ)\n\t\tdivby4 = 1;\n\n\t \n\tif (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) {\n\t\t \n\t\tif (divby4 == 0) {\n\t\t\tlltmp = SI5351_PLL_VCO_MAX;\n\t\t\tdo_div(lltmp, rate);\n\t\t\ta = (unsigned long)lltmp;\n\t\t} else\n\t\t\ta = 4;\n\n\t\tb = 0;\n\t\tc = 1;\n\n\t\treq->best_parent_rate = a * rate;\n\t} else if (hwdata->num >= 6) {\n\t\t \n\t\ta = DIV_ROUND_CLOSEST(req->best_parent_rate, rate);\n\t\tif (a < SI5351_MULTISYNTH_A_MIN)\n\t\t\ta = SI5351_MULTISYNTH_A_MIN;\n\t\tif (a > SI5351_MULTISYNTH67_A_MAX)\n\t\t\ta = SI5351_MULTISYNTH67_A_MAX;\n\n\t\tb = 0;\n\t\tc = 1;\n\t} else {\n\t\tunsigned long rfrac, denom;\n\n\t\t \n\t\tif (divby4) {\n\t\t\trate = SI5351_MULTISYNTH_DIVBY4_FREQ;\n\t\t\tdivby4 = 0;\n\t\t}\n\n\t\t \n\t\ta = req->best_parent_rate / rate;\n\t\tif (a < SI5351_MULTISYNTH_A_MIN)\n\t\t\ta = SI5351_MULTISYNTH_A_MIN;\n\t\tif (a > SI5351_MULTISYNTH_A_MAX)\n\t\t\ta = SI5351_MULTISYNTH_A_MAX;\n\n\t\t \n\t\tdenom = 1000 * 1000;\n\t\tlltmp = req->best_parent_rate % rate;\n\t\tlltmp *= denom;\n\t\tdo_div(lltmp, rate);\n\t\trfrac = (unsigned long)lltmp;\n\n\t\tb = 0;\n\t\tc = 1;\n\t\tif (rfrac)\n\t\t\trational_best_approximation(rfrac, denom,\n\t\t\t    SI5351_MULTISYNTH_B_MAX, SI5351_MULTISYNTH_C_MAX,\n\t\t\t    &b, &c);\n\t}\n\n\t \n\tlltmp  = req->best_parent_rate;\n\tlltmp *= c;\n\tdo_div(lltmp, a * c + b);\n\trate  = (unsigned long)lltmp;\n\n\t \n\tif (divby4) {\n\t\thwdata->params.p3 = 1;\n\t\thwdata->params.p2 = 0;\n\t\thwdata->params.p1 = 0;\n\t} else if (hwdata->num >= 6) {\n\t\thwdata->params.p3 = 0;\n\t\thwdata->params.p2 = 0;\n\t\thwdata->params.p1 = a;\n\t} else {\n\t\thwdata->params.p3  = c;\n\t\thwdata->params.p2  = (128 * b) % c;\n\t\thwdata->params.p1  = 128 * a;\n\t\thwdata->params.p1 += (128 * b / c);\n\t\thwdata->params.p1 -= 512;\n\t}\n\n\tdev_dbg(&hwdata->drvdata->client->dev,\n\t\t\"%s - %s: a = %lu, b = %lu, c = %lu, divby4 = %d, parent_rate = %lu, rate = %lu\\n\",\n\t\t__func__, clk_hw_get_name(hw), a, b, c, divby4,\n\t\treq->best_parent_rate, rate);\n\n\treq->rate = rate;\n\n\treturn 0;\n}\n\nstatic int si5351_msynth_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\tu8 reg = si5351_msynth_params_address(hwdata->num);\n\tint divby4 = 0;\n\n\t \n\tsi5351_write_parameters(hwdata->drvdata, reg, &hwdata->params);\n\n\tif (rate > SI5351_MULTISYNTH_DIVBY4_FREQ)\n\t\tdivby4 = 1;\n\n\t \n\tif (hwdata->num < 6) {\n\t\tsi5351_set_bits(hwdata->drvdata, reg + 2,\n\t\t\t\tSI5351_OUTPUT_CLK_DIVBY4,\n\t\t\t\t(divby4) ? SI5351_OUTPUT_CLK_DIVBY4 : 0);\n\t\tsi5351_set_bits(hwdata->drvdata, SI5351_CLK0_CTRL + hwdata->num,\n\t\t\tSI5351_CLK_INTEGER_MODE,\n\t\t\t(hwdata->params.p2 == 0) ? SI5351_CLK_INTEGER_MODE : 0);\n\t}\n\n\tdev_dbg(&hwdata->drvdata->client->dev,\n\t\t\"%s - %s: p1 = %lu, p2 = %lu, p3 = %lu, divby4 = %d, parent_rate = %lu, rate = %lu\\n\",\n\t\t__func__, clk_hw_get_name(hw),\n\t\thwdata->params.p1, hwdata->params.p2, hwdata->params.p3,\n\t\tdivby4, parent_rate, rate);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops si5351_msynth_ops = {\n\t.set_parent = si5351_msynth_set_parent,\n\t.get_parent = si5351_msynth_get_parent,\n\t.recalc_rate = si5351_msynth_recalc_rate,\n\t.determine_rate = si5351_msynth_determine_rate,\n\t.set_rate = si5351_msynth_set_rate,\n};\n\n \nstatic int _si5351_clkout_reparent(struct si5351_driver_data *drvdata,\n\t\t\t\t   int num, enum si5351_clkout_src parent)\n{\n\tu8 val;\n\n\tif (num > 8)\n\t\treturn -EINVAL;\n\n\tswitch (parent) {\n\tcase SI5351_CLKOUT_SRC_MSYNTH_N:\n\t\tval = SI5351_CLK_INPUT_MULTISYNTH_N;\n\t\tbreak;\n\tcase SI5351_CLKOUT_SRC_MSYNTH_0_4:\n\t\t \n\t\tif (num == 0 || num == 4)\n\t\t\tval = SI5351_CLK_INPUT_MULTISYNTH_N;\n\t\telse\n\t\t\tval = SI5351_CLK_INPUT_MULTISYNTH_0_4;\n\t\tbreak;\n\tcase SI5351_CLKOUT_SRC_XTAL:\n\t\tval = SI5351_CLK_INPUT_XTAL;\n\t\tbreak;\n\tcase SI5351_CLKOUT_SRC_CLKIN:\n\t\tif (drvdata->variant != SI5351_VARIANT_C)\n\t\t\treturn -EINVAL;\n\n\t\tval = SI5351_CLK_INPUT_CLKIN;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tsi5351_set_bits(drvdata, SI5351_CLK0_CTRL + num,\n\t\t\tSI5351_CLK_INPUT_MASK, val);\n\treturn 0;\n}\n\nstatic int _si5351_clkout_set_drive_strength(\n\tstruct si5351_driver_data *drvdata, int num,\n\tenum si5351_drive_strength drive)\n{\n\tu8 mask;\n\n\tif (num > 8)\n\t\treturn -EINVAL;\n\n\tswitch (drive) {\n\tcase SI5351_DRIVE_2MA:\n\t\tmask = SI5351_CLK_DRIVE_STRENGTH_2MA;\n\t\tbreak;\n\tcase SI5351_DRIVE_4MA:\n\t\tmask = SI5351_CLK_DRIVE_STRENGTH_4MA;\n\t\tbreak;\n\tcase SI5351_DRIVE_6MA:\n\t\tmask = SI5351_CLK_DRIVE_STRENGTH_6MA;\n\t\tbreak;\n\tcase SI5351_DRIVE_8MA:\n\t\tmask = SI5351_CLK_DRIVE_STRENGTH_8MA;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tsi5351_set_bits(drvdata, SI5351_CLK0_CTRL + num,\n\t\t\tSI5351_CLK_DRIVE_STRENGTH_MASK, mask);\n\treturn 0;\n}\n\nstatic int _si5351_clkout_set_disable_state(\n\tstruct si5351_driver_data *drvdata, int num,\n\tenum si5351_disable_state state)\n{\n\tu8 reg = (num < 4) ? SI5351_CLK3_0_DISABLE_STATE :\n\t\tSI5351_CLK7_4_DISABLE_STATE;\n\tu8 shift = (num < 4) ? (2 * num) : (2 * (num-4));\n\tu8 mask = SI5351_CLK_DISABLE_STATE_MASK << shift;\n\tu8 val;\n\n\tif (num > 8)\n\t\treturn -EINVAL;\n\n\tswitch (state) {\n\tcase SI5351_DISABLE_LOW:\n\t\tval = SI5351_CLK_DISABLE_STATE_LOW;\n\t\tbreak;\n\tcase SI5351_DISABLE_HIGH:\n\t\tval = SI5351_CLK_DISABLE_STATE_HIGH;\n\t\tbreak;\n\tcase SI5351_DISABLE_FLOATING:\n\t\tval = SI5351_CLK_DISABLE_STATE_FLOAT;\n\t\tbreak;\n\tcase SI5351_DISABLE_NEVER:\n\t\tval = SI5351_CLK_DISABLE_STATE_NEVER;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tsi5351_set_bits(drvdata, reg, mask, val << shift);\n\n\treturn 0;\n}\n\nstatic void _si5351_clkout_reset_pll(struct si5351_driver_data *drvdata, int num)\n{\n\tu8 val = si5351_reg_read(drvdata, SI5351_CLK0_CTRL + num);\n\tu8 mask = val & SI5351_CLK_PLL_SELECT ? SI5351_PLL_RESET_B :\n\t\t\t\t\t\t       SI5351_PLL_RESET_A;\n\tunsigned int v;\n\tint err;\n\n\tswitch (val & SI5351_CLK_INPUT_MASK) {\n\tcase SI5351_CLK_INPUT_XTAL:\n\tcase SI5351_CLK_INPUT_CLKIN:\n\t\treturn;   \n\t}\n\n\tsi5351_reg_write(drvdata, SI5351_PLL_RESET, mask);\n\n\terr = regmap_read_poll_timeout(drvdata->regmap, SI5351_PLL_RESET, v,\n\t\t\t\t !(v & mask), 0, 20000);\n\tif (err < 0)\n\t\tdev_err(&drvdata->client->dev, \"Reset bit didn't clear\\n\");\n\n\tdev_dbg(&drvdata->client->dev, \"%s - %s: pll = %d\\n\",\n\t\t__func__, clk_hw_get_name(&drvdata->clkout[num].hw),\n\t\t(val & SI5351_CLK_PLL_SELECT) ? 1 : 0);\n}\n\nstatic int si5351_clkout_prepare(struct clk_hw *hw)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\tstruct si5351_platform_data *pdata =\n\t\thwdata->drvdata->client->dev.platform_data;\n\n\tsi5351_set_bits(hwdata->drvdata, SI5351_CLK0_CTRL + hwdata->num,\n\t\t\tSI5351_CLK_POWERDOWN, 0);\n\n\t \n\tif (pdata->clkout[hwdata->num].pll_reset)\n\t\t_si5351_clkout_reset_pll(hwdata->drvdata, hwdata->num);\n\n\tsi5351_set_bits(hwdata->drvdata, SI5351_OUTPUT_ENABLE_CTRL,\n\t\t\t(1 << hwdata->num), 0);\n\treturn 0;\n}\n\nstatic void si5351_clkout_unprepare(struct clk_hw *hw)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\n\tsi5351_set_bits(hwdata->drvdata, SI5351_CLK0_CTRL + hwdata->num,\n\t\t\tSI5351_CLK_POWERDOWN, SI5351_CLK_POWERDOWN);\n\tsi5351_set_bits(hwdata->drvdata, SI5351_OUTPUT_ENABLE_CTRL,\n\t\t\t(1 << hwdata->num), (1 << hwdata->num));\n}\n\nstatic u8 si5351_clkout_get_parent(struct clk_hw *hw)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\tint index = 0;\n\tunsigned char val;\n\n\tval = si5351_reg_read(hwdata->drvdata, SI5351_CLK0_CTRL + hwdata->num);\n\tswitch (val & SI5351_CLK_INPUT_MASK) {\n\tcase SI5351_CLK_INPUT_MULTISYNTH_N:\n\t\tindex = 0;\n\t\tbreak;\n\tcase SI5351_CLK_INPUT_MULTISYNTH_0_4:\n\t\tindex = 1;\n\t\tbreak;\n\tcase SI5351_CLK_INPUT_XTAL:\n\t\tindex = 2;\n\t\tbreak;\n\tcase SI5351_CLK_INPUT_CLKIN:\n\t\tindex = 3;\n\t\tbreak;\n\t}\n\n\treturn index;\n}\n\nstatic int si5351_clkout_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\tenum si5351_clkout_src parent = SI5351_CLKOUT_SRC_DEFAULT;\n\n\tswitch (index) {\n\tcase 0:\n\t\tparent = SI5351_CLKOUT_SRC_MSYNTH_N;\n\t\tbreak;\n\tcase 1:\n\t\tparent = SI5351_CLKOUT_SRC_MSYNTH_0_4;\n\t\tbreak;\n\tcase 2:\n\t\tparent = SI5351_CLKOUT_SRC_XTAL;\n\t\tbreak;\n\tcase 3:\n\t\tparent = SI5351_CLKOUT_SRC_CLKIN;\n\t\tbreak;\n\t}\n\n\treturn _si5351_clkout_reparent(hwdata->drvdata, hwdata->num, parent);\n}\n\nstatic unsigned long si5351_clkout_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\tunsigned char reg;\n\tunsigned char rdiv;\n\n\tif (hwdata->num <= 5)\n\t\treg = si5351_msynth_params_address(hwdata->num) + 2;\n\telse\n\t\treg = SI5351_CLK6_7_OUTPUT_DIVIDER;\n\n\trdiv = si5351_reg_read(hwdata->drvdata, reg);\n\tif (hwdata->num == 6) {\n\t\trdiv &= SI5351_OUTPUT_CLK6_DIV_MASK;\n\t} else {\n\t\trdiv &= SI5351_OUTPUT_CLK_DIV_MASK;\n\t\trdiv >>= SI5351_OUTPUT_CLK_DIV_SHIFT;\n\t}\n\n\treturn parent_rate >> rdiv;\n}\n\nstatic int si5351_clkout_determine_rate(struct clk_hw *hw,\n\t\t\t\t\tstruct clk_rate_request *req)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\tunsigned long rate = req->rate;\n\tunsigned char rdiv;\n\n\t \n\tif (hwdata->num >= 6 && rate > SI5351_CLKOUT67_MAX_FREQ)\n\t\trate = SI5351_CLKOUT67_MAX_FREQ;\n\n\t \n\tif (rate > SI5351_CLKOUT_MAX_FREQ)\n\t\trate = SI5351_CLKOUT_MAX_FREQ;\n\tif (rate < SI5351_CLKOUT_MIN_FREQ)\n\t\trate = SI5351_CLKOUT_MIN_FREQ;\n\n\t \n\tif (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) {\n\t\t \n\t\trdiv = SI5351_OUTPUT_CLK_DIV_1;\n\t\twhile (rate < SI5351_MULTISYNTH_MIN_FREQ &&\n\t\t       rdiv < SI5351_OUTPUT_CLK_DIV_128) {\n\t\t\trdiv += 1;\n\t\t\trate *= 2;\n\t\t}\n\t\treq->best_parent_rate = rate;\n\t} else {\n\t\tunsigned long new_rate, new_err, err;\n\n\t\t \n\t\trdiv = SI5351_OUTPUT_CLK_DIV_1;\n\t\tnew_rate = req->best_parent_rate;\n\t\terr = abs(new_rate - rate);\n\t\tdo {\n\t\t\tnew_rate >>= 1;\n\t\t\tnew_err = abs(new_rate - rate);\n\t\t\tif (new_err > err || rdiv == SI5351_OUTPUT_CLK_DIV_128)\n\t\t\t\tbreak;\n\t\t\trdiv++;\n\t\t\terr = new_err;\n\t\t} while (1);\n\t}\n\trate = req->best_parent_rate >> rdiv;\n\n\tdev_dbg(&hwdata->drvdata->client->dev,\n\t\t\"%s - %s: rdiv = %u, parent_rate = %lu, rate = %lu\\n\",\n\t\t__func__, clk_hw_get_name(hw), (1 << rdiv),\n\t\treq->best_parent_rate, rate);\n\n\treq->rate = rate;\n\treturn 0;\n}\n\nstatic int si5351_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct si5351_hw_data *hwdata =\n\t\tcontainer_of(hw, struct si5351_hw_data, hw);\n\tunsigned long new_rate, new_err, err;\n\tunsigned char rdiv;\n\n\t \n\trdiv = SI5351_OUTPUT_CLK_DIV_1;\n\tnew_rate = parent_rate;\n\terr = abs(new_rate - rate);\n\tdo {\n\t\tnew_rate >>= 1;\n\t\tnew_err = abs(new_rate - rate);\n\t\tif (new_err > err || rdiv == SI5351_OUTPUT_CLK_DIV_128)\n\t\t\tbreak;\n\t\trdiv++;\n\t\terr = new_err;\n\t} while (1);\n\n\t \n\tswitch (hwdata->num) {\n\tcase 6:\n\t\tsi5351_set_bits(hwdata->drvdata, SI5351_CLK6_7_OUTPUT_DIVIDER,\n\t\t\t\tSI5351_OUTPUT_CLK6_DIV_MASK, rdiv);\n\t\tbreak;\n\tcase 7:\n\t\tsi5351_set_bits(hwdata->drvdata, SI5351_CLK6_7_OUTPUT_DIVIDER,\n\t\t\t\tSI5351_OUTPUT_CLK_DIV_MASK,\n\t\t\t\trdiv << SI5351_OUTPUT_CLK_DIV_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tsi5351_set_bits(hwdata->drvdata,\n\t\t\t\tsi5351_msynth_params_address(hwdata->num) + 2,\n\t\t\t\tSI5351_OUTPUT_CLK_DIV_MASK,\n\t\t\t\trdiv << SI5351_OUTPUT_CLK_DIV_SHIFT);\n\t}\n\n\t \n\tsi5351_set_bits(hwdata->drvdata, SI5351_CLK0_CTRL + hwdata->num,\n\t\t\tSI5351_CLK_POWERDOWN, 0);\n\n\tdev_dbg(&hwdata->drvdata->client->dev,\n\t\t\"%s - %s: rdiv = %u, parent_rate = %lu, rate = %lu\\n\",\n\t\t__func__, clk_hw_get_name(hw), (1 << rdiv),\n\t\tparent_rate, rate);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops si5351_clkout_ops = {\n\t.prepare = si5351_clkout_prepare,\n\t.unprepare = si5351_clkout_unprepare,\n\t.set_parent = si5351_clkout_set_parent,\n\t.get_parent = si5351_clkout_get_parent,\n\t.recalc_rate = si5351_clkout_recalc_rate,\n\t.determine_rate = si5351_clkout_determine_rate,\n\t.set_rate = si5351_clkout_set_rate,\n};\n\n \n#ifdef CONFIG_OF\nstatic const struct of_device_id si5351_dt_ids[] = {\n\t{ .compatible = \"silabs,si5351a\", .data = (void *)SI5351_VARIANT_A, },\n\t{ .compatible = \"silabs,si5351a-msop\",\n\t\t\t\t\t .data = (void *)SI5351_VARIANT_A3, },\n\t{ .compatible = \"silabs,si5351b\", .data = (void *)SI5351_VARIANT_B, },\n\t{ .compatible = \"silabs,si5351c\", .data = (void *)SI5351_VARIANT_C, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, si5351_dt_ids);\n\nstatic int si5351_dt_parse(struct i2c_client *client,\n\t\t\t   enum si5351_variant variant)\n{\n\tstruct device_node *child, *np = client->dev.of_node;\n\tstruct si5351_platform_data *pdata;\n\tstruct property *prop;\n\tconst __be32 *p;\n\tint num = 0;\n\tu32 val;\n\n\tif (np == NULL)\n\t\treturn 0;\n\n\tpdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\t \n\tof_property_for_each_u32(np, \"silabs,pll-source\", prop, p, num) {\n\t\tif (num >= 2) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"invalid pll %d on pll-source prop\\n\", num);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tp = of_prop_next_u32(prop, p, &val);\n\t\tif (!p) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"missing pll-source for pll %d\\n\", num);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\tpdata->pll_src[num] = SI5351_PLL_SRC_XTAL;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (variant != SI5351_VARIANT_C) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"invalid parent %d for pll %d\\n\",\n\t\t\t\t\tval, num);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tpdata->pll_src[num] = SI5351_PLL_SRC_CLKIN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&client->dev,\n\t\t\t\t \"invalid parent %d for pll %d\\n\", val, num);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tfor_each_child_of_node(np, child) {\n\t\tif (of_property_read_u32(child, \"reg\", &num)) {\n\t\t\tdev_err(&client->dev, \"missing reg property of %pOFn\\n\",\n\t\t\t\tchild);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tif (num >= 8 ||\n\t\t    (variant == SI5351_VARIANT_A3 && num >= 3)) {\n\t\t\tdev_err(&client->dev, \"invalid clkout %d\\n\", num);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tif (!of_property_read_u32(child, \"silabs,multisynth-source\",\n\t\t\t\t\t  &val)) {\n\t\t\tswitch (val) {\n\t\t\tcase 0:\n\t\t\t\tpdata->clkout[num].multisynth_src =\n\t\t\t\t\tSI5351_MULTISYNTH_SRC_VCO0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tpdata->clkout[num].multisynth_src =\n\t\t\t\t\tSI5351_MULTISYNTH_SRC_VCO1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"invalid parent %d for multisynth %d\\n\",\n\t\t\t\t\tval, num);\n\t\t\t\tgoto put_child;\n\t\t\t}\n\t\t}\n\n\t\tif (!of_property_read_u32(child, \"silabs,clock-source\", &val)) {\n\t\t\tswitch (val) {\n\t\t\tcase 0:\n\t\t\t\tpdata->clkout[num].clkout_src =\n\t\t\t\t\tSI5351_CLKOUT_SRC_MSYNTH_N;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tpdata->clkout[num].clkout_src =\n\t\t\t\t\tSI5351_CLKOUT_SRC_MSYNTH_0_4;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tpdata->clkout[num].clkout_src =\n\t\t\t\t\tSI5351_CLKOUT_SRC_XTAL;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (variant != SI5351_VARIANT_C) {\n\t\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\t\"invalid parent %d for clkout %d\\n\",\n\t\t\t\t\t\tval, num);\n\t\t\t\t\tgoto put_child;\n\t\t\t\t}\n\t\t\t\tpdata->clkout[num].clkout_src =\n\t\t\t\t\tSI5351_CLKOUT_SRC_CLKIN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"invalid parent %d for clkout %d\\n\",\n\t\t\t\t\tval, num);\n\t\t\t\tgoto put_child;\n\t\t\t}\n\t\t}\n\n\t\tif (!of_property_read_u32(child, \"silabs,drive-strength\",\n\t\t\t\t\t  &val)) {\n\t\t\tswitch (val) {\n\t\t\tcase SI5351_DRIVE_2MA:\n\t\t\tcase SI5351_DRIVE_4MA:\n\t\t\tcase SI5351_DRIVE_6MA:\n\t\t\tcase SI5351_DRIVE_8MA:\n\t\t\t\tpdata->clkout[num].drive = val;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"invalid drive strength %d for clkout %d\\n\",\n\t\t\t\t\tval, num);\n\t\t\t\tgoto put_child;\n\t\t\t}\n\t\t}\n\n\t\tif (!of_property_read_u32(child, \"silabs,disable-state\",\n\t\t\t\t\t  &val)) {\n\t\t\tswitch (val) {\n\t\t\tcase 0:\n\t\t\t\tpdata->clkout[num].disable_state =\n\t\t\t\t\tSI5351_DISABLE_LOW;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tpdata->clkout[num].disable_state =\n\t\t\t\t\tSI5351_DISABLE_HIGH;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tpdata->clkout[num].disable_state =\n\t\t\t\t\tSI5351_DISABLE_FLOATING;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tpdata->clkout[num].disable_state =\n\t\t\t\t\tSI5351_DISABLE_NEVER;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"invalid disable state %d for clkout %d\\n\",\n\t\t\t\t\tval, num);\n\t\t\t\tgoto put_child;\n\t\t\t}\n\t\t}\n\n\t\tif (!of_property_read_u32(child, \"clock-frequency\", &val))\n\t\t\tpdata->clkout[num].rate = val;\n\n\t\tpdata->clkout[num].pll_master =\n\t\t\tof_property_read_bool(child, \"silabs,pll-master\");\n\n\t\tpdata->clkout[num].pll_reset =\n\t\t\tof_property_read_bool(child, \"silabs,pll-reset\");\n\t}\n\tclient->dev.platform_data = pdata;\n\n\treturn 0;\nput_child:\n\tof_node_put(child);\n\treturn -EINVAL;\n}\n\nstatic struct clk_hw *\nsi53351_of_clk_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct si5351_driver_data *drvdata = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= drvdata->num_clkout) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &drvdata->clkout[idx].hw;\n}\n#else\nstatic int si5351_dt_parse(struct i2c_client *client, enum si5351_variant variant)\n{\n\treturn 0;\n}\n\nstatic struct clk_hw *\nsi53351_of_clk_get(struct of_phandle_args *clkspec, void *data)\n{\n\treturn NULL;\n}\n#endif  \n\nstatic const struct i2c_device_id si5351_i2c_ids[] = {\n\t{ \"si5351a\", SI5351_VARIANT_A },\n\t{ \"si5351a-msop\", SI5351_VARIANT_A3 },\n\t{ \"si5351b\", SI5351_VARIANT_B },\n\t{ \"si5351c\", SI5351_VARIANT_C },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, si5351_i2c_ids);\n\nstatic int si5351_i2c_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_match_id(si5351_i2c_ids, client);\n\tenum si5351_variant variant = (enum si5351_variant)id->driver_data;\n\tstruct si5351_platform_data *pdata;\n\tstruct si5351_driver_data *drvdata;\n\tstruct clk_init_data init;\n\tconst char *parent_names[4];\n\tu8 num_parents, num_clocks;\n\tint ret, n;\n\n\tret = si5351_dt_parse(client, variant);\n\tif (ret)\n\t\treturn ret;\n\n\tpdata = client->dev.platform_data;\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tdrvdata = devm_kzalloc(&client->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, drvdata);\n\tdrvdata->client = client;\n\tdrvdata->variant = variant;\n\tdrvdata->pxtal = devm_clk_get(&client->dev, \"xtal\");\n\tdrvdata->pclkin = devm_clk_get(&client->dev, \"clkin\");\n\n\tif (PTR_ERR(drvdata->pxtal) == -EPROBE_DEFER ||\n\t    PTR_ERR(drvdata->pclkin) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tif (IS_ERR(drvdata->pxtal) &&\n\t    (drvdata->variant != SI5351_VARIANT_C || IS_ERR(drvdata->pclkin))) {\n\t\tdev_err(&client->dev, \"missing parent clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdrvdata->regmap = devm_regmap_init_i2c(client, &si5351_regmap_config);\n\tif (IS_ERR(drvdata->regmap)) {\n\t\tdev_err(&client->dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(drvdata->regmap);\n\t}\n\n\t \n\tsi5351_reg_write(drvdata, SI5351_INTERRUPT_MASK, 0xf0);\n\t \n\tif (drvdata->variant != SI5351_VARIANT_C)\n\t\tsi5351_set_bits(drvdata, SI5351_PLL_INPUT_SOURCE,\n\t\t\t\tSI5351_PLLA_SOURCE | SI5351_PLLB_SOURCE, 0);\n\n\t \n\tfor (n = 0; n < 2; n++) {\n\t\tret = _si5351_pll_reparent(drvdata, n, pdata->pll_src[n]);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to reparent pll %d to %d\\n\",\n\t\t\t\tn, pdata->pll_src[n]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (n = 0; n < 8; n++) {\n\t\tret = _si5351_msynth_reparent(drvdata, n,\n\t\t\t\t\t      pdata->clkout[n].multisynth_src);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to reparent multisynth %d to %d\\n\",\n\t\t\t\tn, pdata->clkout[n].multisynth_src);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = _si5351_clkout_reparent(drvdata, n,\n\t\t\t\t\t      pdata->clkout[n].clkout_src);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to reparent clkout %d to %d\\n\",\n\t\t\t\tn, pdata->clkout[n].clkout_src);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = _si5351_clkout_set_drive_strength(drvdata, n,\n\t\t\t\t\t\t\tpdata->clkout[n].drive);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed set drive strength of clkout%d to %d\\n\",\n\t\t\t\tn, pdata->clkout[n].drive);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = _si5351_clkout_set_disable_state(drvdata, n,\n\t\t\t\t\t\tpdata->clkout[n].disable_state);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed set disable state of clkout%d to %d\\n\",\n\t\t\t\tn, pdata->clkout[n].disable_state);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tmemset(&init, 0, sizeof(init));\n\tinit.name = si5351_input_names[0];\n\tinit.ops = &si5351_xtal_ops;\n\tinit.flags = 0;\n\tif (!IS_ERR(drvdata->pxtal)) {\n\t\tdrvdata->pxtal_name = __clk_get_name(drvdata->pxtal);\n\t\tinit.parent_names = &drvdata->pxtal_name;\n\t\tinit.num_parents = 1;\n\t}\n\tdrvdata->xtal.init = &init;\n\tret = devm_clk_hw_register(&client->dev, &drvdata->xtal);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"unable to register %s\\n\", init.name);\n\t\treturn ret;\n\t}\n\n\t \n\tif (drvdata->variant == SI5351_VARIANT_C) {\n\t\tmemset(&init, 0, sizeof(init));\n\t\tinit.name = si5351_input_names[1];\n\t\tinit.ops = &si5351_clkin_ops;\n\t\tif (!IS_ERR(drvdata->pclkin)) {\n\t\t\tdrvdata->pclkin_name = __clk_get_name(drvdata->pclkin);\n\t\t\tinit.parent_names = &drvdata->pclkin_name;\n\t\t\tinit.num_parents = 1;\n\t\t}\n\t\tdrvdata->clkin.init = &init;\n\t\tret = devm_clk_hw_register(&client->dev, &drvdata->clkin);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"unable to register %s\\n\",\n\t\t\t\tinit.name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tnum_parents = (drvdata->variant == SI5351_VARIANT_C) ? 2 : 1;\n\tparent_names[0] = si5351_input_names[0];\n\tparent_names[1] = si5351_input_names[1];\n\n\t \n\tdrvdata->pll[0].num = 0;\n\tdrvdata->pll[0].drvdata = drvdata;\n\tdrvdata->pll[0].hw.init = &init;\n\tmemset(&init, 0, sizeof(init));\n\tinit.name = si5351_pll_names[0];\n\tinit.ops = &si5351_pll_ops;\n\tinit.flags = 0;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\tret = devm_clk_hw_register(&client->dev, &drvdata->pll[0].hw);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"unable to register %s\\n\", init.name);\n\t\treturn ret;\n\t}\n\n\t \n\tdrvdata->pll[1].num = 1;\n\tdrvdata->pll[1].drvdata = drvdata;\n\tdrvdata->pll[1].hw.init = &init;\n\tmemset(&init, 0, sizeof(init));\n\tif (drvdata->variant == SI5351_VARIANT_B) {\n\t\tinit.name = si5351_pll_names[2];\n\t\tinit.ops = &si5351_vxco_ops;\n\t\tinit.flags = 0;\n\t\tinit.parent_names = NULL;\n\t\tinit.num_parents = 0;\n\t} else {\n\t\tinit.name = si5351_pll_names[1];\n\t\tinit.ops = &si5351_pll_ops;\n\t\tinit.flags = 0;\n\t\tinit.parent_names = parent_names;\n\t\tinit.num_parents = num_parents;\n\t}\n\tret = devm_clk_hw_register(&client->dev, &drvdata->pll[1].hw);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"unable to register %s\\n\", init.name);\n\t\treturn ret;\n\t}\n\n\t \n\tnum_clocks = (drvdata->variant == SI5351_VARIANT_A3) ? 3 : 8;\n\tparent_names[0] = si5351_pll_names[0];\n\tif (drvdata->variant == SI5351_VARIANT_B)\n\t\tparent_names[1] = si5351_pll_names[2];\n\telse\n\t\tparent_names[1] = si5351_pll_names[1];\n\n\tdrvdata->msynth = devm_kcalloc(&client->dev, num_clocks,\n\t\t\t\t       sizeof(*drvdata->msynth), GFP_KERNEL);\n\tdrvdata->clkout = devm_kcalloc(&client->dev, num_clocks,\n\t\t\t\t       sizeof(*drvdata->clkout), GFP_KERNEL);\n\tdrvdata->num_clkout = num_clocks;\n\n\tif (WARN_ON(!drvdata->msynth || !drvdata->clkout)) {\n\t\tret = -ENOMEM;\n\t\treturn ret;\n\t}\n\n\tfor (n = 0; n < num_clocks; n++) {\n\t\tdrvdata->msynth[n].num = n;\n\t\tdrvdata->msynth[n].drvdata = drvdata;\n\t\tdrvdata->msynth[n].hw.init = &init;\n\t\tmemset(&init, 0, sizeof(init));\n\t\tinit.name = si5351_msynth_names[n];\n\t\tinit.ops = &si5351_msynth_ops;\n\t\tinit.flags = 0;\n\t\tif (pdata->clkout[n].pll_master)\n\t\t\tinit.flags |= CLK_SET_RATE_PARENT;\n\t\tinit.parent_names = parent_names;\n\t\tinit.num_parents = 2;\n\t\tret = devm_clk_hw_register(&client->dev,\n\t\t\t\t\t   &drvdata->msynth[n].hw);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"unable to register %s\\n\",\n\t\t\t\tinit.name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tnum_parents = (drvdata->variant == SI5351_VARIANT_C) ? 4 : 3;\n\tparent_names[2] = si5351_input_names[0];\n\tparent_names[3] = si5351_input_names[1];\n\tfor (n = 0; n < num_clocks; n++) {\n\t\tparent_names[0] = si5351_msynth_names[n];\n\t\tparent_names[1] = (n < 4) ? si5351_msynth_names[0] :\n\t\t\tsi5351_msynth_names[4];\n\n\t\tdrvdata->clkout[n].num = n;\n\t\tdrvdata->clkout[n].drvdata = drvdata;\n\t\tdrvdata->clkout[n].hw.init = &init;\n\t\tmemset(&init, 0, sizeof(init));\n\t\tinit.name = si5351_clkout_names[n];\n\t\tinit.ops = &si5351_clkout_ops;\n\t\tinit.flags = 0;\n\t\tif (pdata->clkout[n].clkout_src == SI5351_CLKOUT_SRC_MSYNTH_N)\n\t\t\tinit.flags |= CLK_SET_RATE_PARENT;\n\t\tinit.parent_names = parent_names;\n\t\tinit.num_parents = num_parents;\n\t\tret = devm_clk_hw_register(&client->dev,\n\t\t\t\t\t   &drvdata->clkout[n].hw);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"unable to register %s\\n\",\n\t\t\t\tinit.name);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (pdata->clkout[n].rate != 0) {\n\t\t\tint ret;\n\t\t\tret = clk_set_rate(drvdata->clkout[n].hw.clk,\n\t\t\t\t\t   pdata->clkout[n].rate);\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(&client->dev, \"Cannot set rate : %d\\n\",\n\t\t\t\t\tret);\n\t\t\t}\n\t\t}\n\t}\n\n\tret = devm_of_clk_add_hw_provider(&client->dev, si53351_of_clk_get,\n\t\t\t\t\t  drvdata);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"unable to add clk provider\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct i2c_driver si5351_driver = {\n\t.driver = {\n\t\t.name = \"si5351\",\n\t\t.of_match_table = of_match_ptr(si5351_dt_ids),\n\t},\n\t.probe = si5351_i2c_probe,\n\t.id_table = si5351_i2c_ids,\n};\nmodule_i2c_driver(si5351_driver);\n\nMODULE_AUTHOR(\"Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com\");\nMODULE_DESCRIPTION(\"Silicon Labs Si5351A/B/C clock generator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}