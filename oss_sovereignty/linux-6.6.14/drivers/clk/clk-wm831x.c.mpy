{
  "module_name": "clk-wm831x.c",
  "hash_id": "c90c929e1e3c3b0cfac1ff86b6743491a101ab8019c3bdf62047ee1a9b33979a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-wm831x.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/wm831x/core.h>\n\nstruct wm831x_clk {\n\tstruct wm831x *wm831x;\n\tstruct clk_hw xtal_hw;\n\tstruct clk_hw fll_hw;\n\tstruct clk_hw clkout_hw;\n\tbool xtal_ena;\n};\n\nstatic int wm831x_xtal_is_prepared(struct clk_hw *hw)\n{\n\tstruct wm831x_clk *clkdata = container_of(hw, struct wm831x_clk,\n\t\t\t\t\t\t  xtal_hw);\n\n\treturn clkdata->xtal_ena;\n}\n\nstatic unsigned long wm831x_xtal_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct wm831x_clk *clkdata = container_of(hw, struct wm831x_clk,\n\t\t\t\t\t\t  xtal_hw);\n\n\tif (clkdata->xtal_ena)\n\t\treturn 32768;\n\telse\n\t\treturn 0;\n}\n\nstatic const struct clk_ops wm831x_xtal_ops = {\n\t.is_prepared = wm831x_xtal_is_prepared,\n\t.recalc_rate = wm831x_xtal_recalc_rate,\n};\n\nstatic const struct clk_init_data wm831x_xtal_init = {\n\t.name = \"xtal\",\n\t.ops = &wm831x_xtal_ops,\n};\n\nstatic const unsigned long wm831x_fll_auto_rates[] = {\n\t 2048000,\n\t11289600,\n\t12000000,\n\t12288000,\n\t19200000,\n\t22579600,\n\t24000000,\n\t24576000,\n};\n\nstatic int wm831x_fll_is_prepared(struct clk_hw *hw)\n{\n\tstruct wm831x_clk *clkdata = container_of(hw, struct wm831x_clk,\n\t\t\t\t\t\t  fll_hw);\n\tstruct wm831x *wm831x = clkdata->wm831x;\n\tint ret;\n\n\tret = wm831x_reg_read(wm831x, WM831X_FLL_CONTROL_1);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev, \"Unable to read FLL_CONTROL_1: %d\\n\",\n\t\t\tret);\n\t\treturn true;\n\t}\n\n\treturn (ret & WM831X_FLL_ENA) != 0;\n}\n\nstatic int wm831x_fll_prepare(struct clk_hw *hw)\n{\n\tstruct wm831x_clk *clkdata = container_of(hw, struct wm831x_clk,\n\t\t\t\t\t\t  fll_hw);\n\tstruct wm831x *wm831x = clkdata->wm831x;\n\tint ret;\n\n\tret = wm831x_set_bits(wm831x, WM831X_FLL_CONTROL_1,\n\t\t\t      WM831X_FLL_ENA, WM831X_FLL_ENA);\n\tif (ret != 0)\n\t\tdev_crit(wm831x->dev, \"Failed to enable FLL: %d\\n\", ret);\n\n\t \n\tusleep_range(2000, 3000);\n\n\treturn ret;\n}\n\nstatic void wm831x_fll_unprepare(struct clk_hw *hw)\n{\n\tstruct wm831x_clk *clkdata = container_of(hw, struct wm831x_clk,\n\t\t\t\t\t\t  fll_hw);\n\tstruct wm831x *wm831x = clkdata->wm831x;\n\tint ret;\n\n\tret = wm831x_set_bits(wm831x, WM831X_FLL_CONTROL_1, WM831X_FLL_ENA, 0);\n\tif (ret != 0)\n\t\tdev_crit(wm831x->dev, \"Failed to disable FLL: %d\\n\", ret);\n}\n\nstatic unsigned long wm831x_fll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct wm831x_clk *clkdata = container_of(hw, struct wm831x_clk,\n\t\t\t\t\t\t  fll_hw);\n\tstruct wm831x *wm831x = clkdata->wm831x;\n\tint ret;\n\n\tret = wm831x_reg_read(wm831x, WM831X_CLOCK_CONTROL_2);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev, \"Unable to read CLOCK_CONTROL_2: %d\\n\",\n\t\t\tret);\n\t\treturn 0;\n\t}\n\n\tif (ret & WM831X_FLL_AUTO)\n\t\treturn wm831x_fll_auto_rates[ret & WM831X_FLL_AUTO_FREQ_MASK];\n\n\tdev_err(wm831x->dev, \"FLL only supported in AUTO mode\\n\");\n\n\treturn 0;\n}\n\nstatic long wm831x_fll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long *unused)\n{\n\tint best = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm831x_fll_auto_rates); i++)\n\t\tif (abs(wm831x_fll_auto_rates[i] - rate) <\n\t\t    abs(wm831x_fll_auto_rates[best] - rate))\n\t\t\tbest = i;\n\n\treturn wm831x_fll_auto_rates[best];\n}\n\nstatic int wm831x_fll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct wm831x_clk *clkdata = container_of(hw, struct wm831x_clk,\n\t\t\t\t\t\t  fll_hw);\n\tstruct wm831x *wm831x = clkdata->wm831x;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm831x_fll_auto_rates); i++)\n\t\tif (wm831x_fll_auto_rates[i] == rate)\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(wm831x_fll_auto_rates))\n\t\treturn -EINVAL;\n\n\tif (wm831x_fll_is_prepared(hw))\n\t\treturn -EPERM;\n\n\treturn wm831x_set_bits(wm831x, WM831X_CLOCK_CONTROL_2,\n\t\t\t       WM831X_FLL_AUTO_FREQ_MASK, i);\n}\n\nstatic const char *wm831x_fll_parents[] = {\n\t\"xtal\",\n\t\"clkin\",\n};\n\nstatic u8 wm831x_fll_get_parent(struct clk_hw *hw)\n{\n\tstruct wm831x_clk *clkdata = container_of(hw, struct wm831x_clk,\n\t\t\t\t\t\t  fll_hw);\n\tstruct wm831x *wm831x = clkdata->wm831x;\n\tint ret;\n\n\t \n\tret = wm831x_reg_read(wm831x, WM831X_CLOCK_CONTROL_2);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev, \"Unable to read CLOCK_CONTROL_2: %d\\n\",\n\t\t\tret);\n\t\treturn 0;\n\t}\n\n\tif (ret & WM831X_FLL_AUTO)\n\t\treturn 0;\n\n\tret = wm831x_reg_read(wm831x, WM831X_FLL_CONTROL_5);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev, \"Unable to read FLL_CONTROL_5: %d\\n\",\n\t\t\tret);\n\t\treturn 0;\n\t}\n\n\tswitch (ret & WM831X_FLL_CLK_SRC_MASK) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\treturn 1;\n\tdefault:\n\t\tdev_err(wm831x->dev, \"Unsupported FLL clock source %d\\n\",\n\t\t\tret & WM831X_FLL_CLK_SRC_MASK);\n\t\treturn 0;\n\t}\n}\n\nstatic const struct clk_ops wm831x_fll_ops = {\n\t.is_prepared = wm831x_fll_is_prepared,\n\t.prepare = wm831x_fll_prepare,\n\t.unprepare = wm831x_fll_unprepare,\n\t.round_rate = wm831x_fll_round_rate,\n\t.recalc_rate = wm831x_fll_recalc_rate,\n\t.set_rate = wm831x_fll_set_rate,\n\t.get_parent = wm831x_fll_get_parent,\n};\n\nstatic const struct clk_init_data wm831x_fll_init = {\n\t.name = \"fll\",\n\t.ops = &wm831x_fll_ops,\n\t.parent_names = wm831x_fll_parents,\n\t.num_parents = ARRAY_SIZE(wm831x_fll_parents),\n\t.flags = CLK_SET_RATE_GATE,\n};\n\nstatic int wm831x_clkout_is_prepared(struct clk_hw *hw)\n{\n\tstruct wm831x_clk *clkdata = container_of(hw, struct wm831x_clk,\n\t\t\t\t\t\t  clkout_hw);\n\tstruct wm831x *wm831x = clkdata->wm831x;\n\tint ret;\n\n\tret = wm831x_reg_read(wm831x, WM831X_CLOCK_CONTROL_1);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev, \"Unable to read CLOCK_CONTROL_1: %d\\n\",\n\t\t\tret);\n\t\treturn false;\n\t}\n\n\treturn (ret & WM831X_CLKOUT_ENA) != 0;\n}\n\nstatic int wm831x_clkout_prepare(struct clk_hw *hw)\n{\n\tstruct wm831x_clk *clkdata = container_of(hw, struct wm831x_clk,\n\t\t\t\t\t\t  clkout_hw);\n\tstruct wm831x *wm831x = clkdata->wm831x;\n\tint ret;\n\n\tret = wm831x_reg_unlock(wm831x);\n\tif (ret != 0) {\n\t\tdev_crit(wm831x->dev, \"Failed to lock registers: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = wm831x_set_bits(wm831x, WM831X_CLOCK_CONTROL_1,\n\t\t\t      WM831X_CLKOUT_ENA, WM831X_CLKOUT_ENA);\n\tif (ret != 0)\n\t\tdev_crit(wm831x->dev, \"Failed to enable CLKOUT: %d\\n\", ret);\n\n\twm831x_reg_lock(wm831x);\n\n\treturn ret;\n}\n\nstatic void wm831x_clkout_unprepare(struct clk_hw *hw)\n{\n\tstruct wm831x_clk *clkdata = container_of(hw, struct wm831x_clk,\n\t\t\t\t\t\t  clkout_hw);\n\tstruct wm831x *wm831x = clkdata->wm831x;\n\tint ret;\n\n\tret = wm831x_reg_unlock(wm831x);\n\tif (ret != 0) {\n\t\tdev_crit(wm831x->dev, \"Failed to lock registers: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = wm831x_set_bits(wm831x, WM831X_CLOCK_CONTROL_1,\n\t\t\t      WM831X_CLKOUT_ENA, 0);\n\tif (ret != 0)\n\t\tdev_crit(wm831x->dev, \"Failed to disable CLKOUT: %d\\n\", ret);\n\n\twm831x_reg_lock(wm831x);\n}\n\nstatic const char *wm831x_clkout_parents[] = {\n\t\"fll\",\n\t\"xtal\",\n};\n\nstatic u8 wm831x_clkout_get_parent(struct clk_hw *hw)\n{\n\tstruct wm831x_clk *clkdata = container_of(hw, struct wm831x_clk,\n\t\t\t\t\t\t  clkout_hw);\n\tstruct wm831x *wm831x = clkdata->wm831x;\n\tint ret;\n\n\tret = wm831x_reg_read(wm831x, WM831X_CLOCK_CONTROL_1);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev, \"Unable to read CLOCK_CONTROL_1: %d\\n\",\n\t\t\tret);\n\t\treturn 0;\n\t}\n\n\tif (ret & WM831X_CLKOUT_SRC)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int wm831x_clkout_set_parent(struct clk_hw *hw, u8 parent)\n{\n\tstruct wm831x_clk *clkdata = container_of(hw, struct wm831x_clk,\n\t\t\t\t\t\t  clkout_hw);\n\tstruct wm831x *wm831x = clkdata->wm831x;\n\n\treturn wm831x_set_bits(wm831x, WM831X_CLOCK_CONTROL_1,\n\t\t\t       WM831X_CLKOUT_SRC,\n\t\t\t       parent << WM831X_CLKOUT_SRC_SHIFT);\n}\n\nstatic const struct clk_ops wm831x_clkout_ops = {\n\t.is_prepared = wm831x_clkout_is_prepared,\n\t.prepare = wm831x_clkout_prepare,\n\t.unprepare = wm831x_clkout_unprepare,\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.get_parent = wm831x_clkout_get_parent,\n\t.set_parent = wm831x_clkout_set_parent,\n};\n\nstatic const struct clk_init_data wm831x_clkout_init = {\n\t.name = \"clkout\",\n\t.ops = &wm831x_clkout_ops,\n\t.parent_names = wm831x_clkout_parents,\n\t.num_parents = ARRAY_SIZE(wm831x_clkout_parents),\n\t.flags = CLK_SET_RATE_PARENT,\n};\n\nstatic int wm831x_clk_probe(struct platform_device *pdev)\n{\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_clk *clkdata;\n\tint ret;\n\n\tclkdata = devm_kzalloc(&pdev->dev, sizeof(*clkdata), GFP_KERNEL);\n\tif (!clkdata)\n\t\treturn -ENOMEM;\n\n\tclkdata->wm831x = wm831x;\n\n\t \n\tret = wm831x_reg_read(wm831x, WM831X_CLOCK_CONTROL_2);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev, \"Unable to read CLOCK_CONTROL_2: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tclkdata->xtal_ena = ret & WM831X_XTAL_ENA;\n\n\tclkdata->xtal_hw.init = &wm831x_xtal_init;\n\tret = devm_clk_hw_register(&pdev->dev, &clkdata->xtal_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tclkdata->fll_hw.init = &wm831x_fll_init;\n\tret = devm_clk_hw_register(&pdev->dev, &clkdata->fll_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tclkdata->clkout_hw.init = &wm831x_clkout_init;\n\tret = devm_clk_hw_register(&pdev->dev, &clkdata->clkout_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, clkdata);\n\n\treturn 0;\n}\n\nstatic struct platform_driver wm831x_clk_driver = {\n\t.probe = wm831x_clk_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"wm831x-clk\",\n\t},\n};\n\nmodule_platform_driver(wm831x_clk_driver);\n\n \nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"WM831x clock driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm831x-clk\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}