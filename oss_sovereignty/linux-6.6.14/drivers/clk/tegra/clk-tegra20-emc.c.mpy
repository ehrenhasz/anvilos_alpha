{
  "module_name": "clk-tegra20-emc.c",
  "hash_id": "b2e981d6387e19170d8d2f953fe75f50f0be297897802913ca6ccb14eb51cfb2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-tegra20-emc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"tegra-emc-clk: \" fmt\n\n#include <linux/bits.h>\n#include <linux/clk-provider.h>\n#include <linux/clk/tegra.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\n#define CLK_SOURCE_EMC_2X_CLK_DIVISOR_MASK\tGENMASK(7, 0)\n#define CLK_SOURCE_EMC_2X_CLK_SRC_MASK\t\tGENMASK(31, 30)\n#define CLK_SOURCE_EMC_2X_CLK_SRC_SHIFT\t\t30\n\n#define MC_EMC_SAME_FREQ\tBIT(16)\n#define USE_PLLM_UD\t\tBIT(29)\n\n#define EMC_SRC_PLL_M\t\t0\n#define EMC_SRC_PLL_C\t\t1\n#define EMC_SRC_PLL_P\t\t2\n#define EMC_SRC_CLK_M\t\t3\n\nstatic const char * const emc_parent_clk_names[] = {\n\t\"pll_m\", \"pll_c\", \"pll_p\", \"clk_m\",\n};\n\nstruct tegra_clk_emc {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n\tbool mc_same_freq;\n\tbool want_low_jitter;\n\n\ttegra20_clk_emc_round_cb *round_cb;\n\tvoid *cb_arg;\n};\n\nstatic inline struct tegra_clk_emc *to_tegra_clk_emc(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct tegra_clk_emc, hw);\n}\n\nstatic unsigned long emc_recalc_rate(struct clk_hw *hw,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct tegra_clk_emc *emc = to_tegra_clk_emc(hw);\n\tu32 val, div;\n\n\tval = readl_relaxed(emc->reg);\n\tdiv = val & CLK_SOURCE_EMC_2X_CLK_DIVISOR_MASK;\n\n\treturn DIV_ROUND_UP(parent_rate * 2, div + 2);\n}\n\nstatic u8 emc_get_parent(struct clk_hw *hw)\n{\n\tstruct tegra_clk_emc *emc = to_tegra_clk_emc(hw);\n\n\treturn readl_relaxed(emc->reg) >> CLK_SOURCE_EMC_2X_CLK_SRC_SHIFT;\n}\n\nstatic int emc_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct tegra_clk_emc *emc = to_tegra_clk_emc(hw);\n\tu32 val, div;\n\n\tval = readl_relaxed(emc->reg);\n\tval &= ~CLK_SOURCE_EMC_2X_CLK_SRC_MASK;\n\tval |= index << CLK_SOURCE_EMC_2X_CLK_SRC_SHIFT;\n\n\tdiv = val & CLK_SOURCE_EMC_2X_CLK_DIVISOR_MASK;\n\n\tif (index == EMC_SRC_PLL_M && div == 0 && emc->want_low_jitter)\n\t\tval |= USE_PLLM_UD;\n\telse\n\t\tval &= ~USE_PLLM_UD;\n\n\tif (emc->mc_same_freq)\n\t\tval |= MC_EMC_SAME_FREQ;\n\telse\n\t\tval &= ~MC_EMC_SAME_FREQ;\n\n\twritel_relaxed(val, emc->reg);\n\n\tfence_udelay(1, emc->reg);\n\n\treturn 0;\n}\n\nstatic int emc_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\tunsigned long parent_rate)\n{\n\tstruct tegra_clk_emc *emc = to_tegra_clk_emc(hw);\n\tunsigned int index;\n\tu32 val, div;\n\n\tdiv = div_frac_get(rate, parent_rate, 8, 1, 0);\n\n\tval = readl_relaxed(emc->reg);\n\tval &= ~CLK_SOURCE_EMC_2X_CLK_DIVISOR_MASK;\n\tval |= div;\n\n\tindex = val >> CLK_SOURCE_EMC_2X_CLK_SRC_SHIFT;\n\n\tif (index == EMC_SRC_PLL_M && div == 0 && emc->want_low_jitter)\n\t\tval |= USE_PLLM_UD;\n\telse\n\t\tval &= ~USE_PLLM_UD;\n\n\tif (emc->mc_same_freq)\n\t\tval |= MC_EMC_SAME_FREQ;\n\telse\n\t\tval &= ~MC_EMC_SAME_FREQ;\n\n\twritel_relaxed(val, emc->reg);\n\n\tfence_udelay(1, emc->reg);\n\n\treturn 0;\n}\n\nstatic int emc_set_rate_and_parent(struct clk_hw *hw,\n\t\t\t\t   unsigned long rate,\n\t\t\t\t   unsigned long parent_rate,\n\t\t\t\t   u8 index)\n{\n\tstruct tegra_clk_emc *emc = to_tegra_clk_emc(hw);\n\tu32 val, div;\n\n\tdiv = div_frac_get(rate, parent_rate, 8, 1, 0);\n\n\tval = readl_relaxed(emc->reg);\n\n\tval &= ~CLK_SOURCE_EMC_2X_CLK_SRC_MASK;\n\tval |= index << CLK_SOURCE_EMC_2X_CLK_SRC_SHIFT;\n\n\tval &= ~CLK_SOURCE_EMC_2X_CLK_DIVISOR_MASK;\n\tval |= div;\n\n\tif (index == EMC_SRC_PLL_M && div == 0 && emc->want_low_jitter)\n\t\tval |= USE_PLLM_UD;\n\telse\n\t\tval &= ~USE_PLLM_UD;\n\n\tif (emc->mc_same_freq)\n\t\tval |= MC_EMC_SAME_FREQ;\n\telse\n\t\tval &= ~MC_EMC_SAME_FREQ;\n\n\twritel_relaxed(val, emc->reg);\n\n\tfence_udelay(1, emc->reg);\n\n\treturn 0;\n}\n\nstatic int emc_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)\n{\n\tstruct tegra_clk_emc *emc = to_tegra_clk_emc(hw);\n\tstruct clk_hw *parent_hw;\n\tunsigned long divided_rate;\n\tunsigned long parent_rate;\n\tunsigned int i;\n\tlong emc_rate;\n\tint div;\n\n\temc_rate = emc->round_cb(req->rate, req->min_rate, req->max_rate,\n\t\t\t\t emc->cb_arg);\n\tif (emc_rate < 0)\n\t\treturn emc_rate;\n\n\tfor (i = 0; i < ARRAY_SIZE(emc_parent_clk_names); i++) {\n\t\tparent_hw = clk_hw_get_parent_by_index(hw, i);\n\n\t\tif (req->best_parent_hw == parent_hw)\n\t\t\tparent_rate = req->best_parent_rate;\n\t\telse\n\t\t\tparent_rate = clk_hw_get_rate(parent_hw);\n\n\t\tif (emc_rate > parent_rate)\n\t\t\tcontinue;\n\n\t\tdiv = div_frac_get(emc_rate, parent_rate, 8, 1, 0);\n\t\tdivided_rate = DIV_ROUND_UP(parent_rate * 2, div + 2);\n\n\t\tif (divided_rate != emc_rate)\n\t\t\tcontinue;\n\n\t\treq->best_parent_rate = parent_rate;\n\t\treq->best_parent_hw = parent_hw;\n\t\treq->rate = emc_rate;\n\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(emc_parent_clk_names)) {\n\t\tpr_err_once(\"can't find parent for rate %lu emc_rate %lu\\n\",\n\t\t\t    req->rate, emc_rate);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct clk_ops tegra_clk_emc_ops = {\n\t.recalc_rate = emc_recalc_rate,\n\t.get_parent = emc_get_parent,\n\t.set_parent = emc_set_parent,\n\t.set_rate = emc_set_rate,\n\t.set_rate_and_parent = emc_set_rate_and_parent,\n\t.determine_rate = emc_determine_rate,\n};\n\nvoid tegra20_clk_set_emc_round_callback(tegra20_clk_emc_round_cb *round_cb,\n\t\t\t\t\tvoid *cb_arg)\n{\n\tstruct clk *clk = __clk_lookup(\"emc\");\n\tstruct tegra_clk_emc *emc;\n\tstruct clk_hw *hw;\n\n\tif (clk) {\n\t\thw = __clk_get_hw(clk);\n\t\temc = to_tegra_clk_emc(hw);\n\n\t\temc->round_cb = round_cb;\n\t\temc->cb_arg = cb_arg;\n\t}\n}\nEXPORT_SYMBOL_GPL(tegra20_clk_set_emc_round_callback);\n\nbool tegra20_clk_emc_driver_available(struct clk_hw *emc_hw)\n{\n\treturn to_tegra_clk_emc(emc_hw)->round_cb != NULL;\n}\n\nstruct clk *tegra20_clk_register_emc(void __iomem *ioaddr, bool low_jitter)\n{\n\tstruct tegra_clk_emc *emc;\n\tstruct clk_init_data init;\n\tstruct clk *clk;\n\n\temc = kzalloc(sizeof(*emc), GFP_KERNEL);\n\tif (!emc)\n\t\treturn NULL;\n\n\t \n\tinit.name = \"emc\";\n\tinit.ops = &tegra_clk_emc_ops;\n\tinit.flags = CLK_IS_CRITICAL;\n\tinit.parent_names = emc_parent_clk_names;\n\tinit.num_parents = ARRAY_SIZE(emc_parent_clk_names);\n\n\temc->reg = ioaddr;\n\temc->hw.init = &init;\n\temc->want_low_jitter = low_jitter;\n\n\tclk = clk_register(NULL, &emc->hw);\n\tif (IS_ERR(clk)) {\n\t\tkfree(emc);\n\t\treturn NULL;\n\t}\n\n\treturn clk;\n}\n\nint tegra20_clk_prepare_emc_mc_same_freq(struct clk *emc_clk, bool same)\n{\n\tstruct tegra_clk_emc *emc;\n\tstruct clk_hw *hw;\n\n\tif (!emc_clk)\n\t\treturn -EINVAL;\n\n\thw = __clk_get_hw(emc_clk);\n\temc = to_tegra_clk_emc(hw);\n\temc->mc_same_freq = same;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra20_clk_prepare_emc_mc_same_freq);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}