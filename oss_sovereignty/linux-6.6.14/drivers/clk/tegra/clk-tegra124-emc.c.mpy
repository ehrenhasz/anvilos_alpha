{
  "module_name": "clk-tegra124-emc.c",
  "hash_id": "944b9afd888b24164988d53db6a631f81ebd727d95ecbc216d30f11916785bd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-tegra124-emc.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/clk/tegra.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/sort.h>\n#include <linux/string.h>\n\n#include <soc/tegra/fuse.h>\n\n#include \"clk.h\"\n\n#define CLK_SOURCE_EMC 0x19c\n\n#define CLK_SOURCE_EMC_EMC_2X_CLK_DIVISOR_SHIFT 0\n#define CLK_SOURCE_EMC_EMC_2X_CLK_DIVISOR_MASK 0xff\n#define CLK_SOURCE_EMC_EMC_2X_CLK_DIVISOR(x) (((x) & CLK_SOURCE_EMC_EMC_2X_CLK_DIVISOR_MASK) << \\\n\t\t\t\t\t      CLK_SOURCE_EMC_EMC_2X_CLK_DIVISOR_SHIFT)\n\n#define CLK_SOURCE_EMC_EMC_2X_CLK_SRC_SHIFT 29\n#define CLK_SOURCE_EMC_EMC_2X_CLK_SRC_MASK 0x7\n#define CLK_SOURCE_EMC_EMC_2X_CLK_SRC(x) (((x) & CLK_SOURCE_EMC_EMC_2X_CLK_SRC_MASK) << \\\n\t\t\t\t\t  CLK_SOURCE_EMC_EMC_2X_CLK_SRC_SHIFT)\n\nstatic const char * const emc_parent_clk_names[] = {\n\t\"pll_m\", \"pll_c\", \"pll_p\", \"clk_m\", \"pll_m_ud\",\n\t\"pll_c2\", \"pll_c3\", \"pll_c_ud\"\n};\n\n \n\n#define EMC_SRC_PLL_M 0\n#define EMC_SRC_PLL_C 1\n#define EMC_SRC_PLL_P 2\n#define EMC_SRC_CLK_M 3\n#define EMC_SRC_PLL_C2 4\n#define EMC_SRC_PLL_C3 5\n\nstatic const char emc_parent_clk_sources[] = {\n\tEMC_SRC_PLL_M, EMC_SRC_PLL_C, EMC_SRC_PLL_P, EMC_SRC_CLK_M,\n\tEMC_SRC_PLL_M, EMC_SRC_PLL_C2, EMC_SRC_PLL_C3, EMC_SRC_PLL_C\n};\n\nstruct emc_timing {\n\tunsigned long rate, parent_rate;\n\tu8 parent_index;\n\tstruct clk *parent;\n\tu32 ram_code;\n};\n\nstruct tegra_clk_emc {\n\tstruct clk_hw hw;\n\tvoid __iomem *clk_regs;\n\tstruct clk *prev_parent;\n\tbool changing_timing;\n\n\tstruct device_node *emc_node;\n\tstruct tegra_emc *emc;\n\n\tint num_timings;\n\tstruct emc_timing *timings;\n\tspinlock_t *lock;\n\n\ttegra124_emc_prepare_timing_change_cb *prepare_timing_change;\n\ttegra124_emc_complete_timing_change_cb *complete_timing_change;\n};\n\n \n\nstatic unsigned long emc_recalc_rate(struct clk_hw *hw,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct tegra_clk_emc *tegra;\n\tu32 val, div;\n\n\ttegra = container_of(hw, struct tegra_clk_emc, hw);\n\n\t \n\tparent_rate = clk_hw_get_rate(clk_hw_get_parent(hw));\n\n\tval = readl(tegra->clk_regs + CLK_SOURCE_EMC);\n\tdiv = val & CLK_SOURCE_EMC_EMC_2X_CLK_DIVISOR_MASK;\n\n\treturn parent_rate / (div + 2) * 2;\n}\n\n \nstatic int emc_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)\n{\n\tstruct tegra_clk_emc *tegra;\n\tu8 ram_code = tegra_read_ram_code();\n\tstruct emc_timing *timing = NULL;\n\tint i, k, t;\n\n\ttegra = container_of(hw, struct tegra_clk_emc, hw);\n\n\tfor (k = 0; k < tegra->num_timings; k++) {\n\t\tif (tegra->timings[k].ram_code == ram_code)\n\t\t\tbreak;\n\t}\n\n\tfor (t = k; t < tegra->num_timings; t++) {\n\t\tif (tegra->timings[t].ram_code != ram_code)\n\t\t\tbreak;\n\t}\n\n\tfor (i = k; i < t; i++) {\n\t\ttiming = tegra->timings + i;\n\n\t\tif (timing->rate < req->rate && i != t - 1)\n\t\t\tcontinue;\n\n\t\tif (timing->rate > req->max_rate) {\n\t\t\ti = max(i, k + 1);\n\t\t\treq->rate = tegra->timings[i - 1].rate;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (timing->rate < req->min_rate)\n\t\t\tcontinue;\n\n\t\treq->rate = timing->rate;\n\t\treturn 0;\n\t}\n\n\tif (timing) {\n\t\treq->rate = timing->rate;\n\t\treturn 0;\n\t}\n\n\treq->rate = clk_hw_get_rate(hw);\n\treturn 0;\n}\n\nstatic u8 emc_get_parent(struct clk_hw *hw)\n{\n\tstruct tegra_clk_emc *tegra;\n\tu32 val;\n\n\ttegra = container_of(hw, struct tegra_clk_emc, hw);\n\n\tval = readl(tegra->clk_regs + CLK_SOURCE_EMC);\n\n\treturn (val >> CLK_SOURCE_EMC_EMC_2X_CLK_SRC_SHIFT)\n\t\t& CLK_SOURCE_EMC_EMC_2X_CLK_SRC_MASK;\n}\n\nstatic struct tegra_emc *emc_ensure_emc_driver(struct tegra_clk_emc *tegra)\n{\n\tstruct platform_device *pdev;\n\n\tif (tegra->emc)\n\t\treturn tegra->emc;\n\n\tif (!tegra->prepare_timing_change || !tegra->complete_timing_change)\n\t\treturn NULL;\n\n\tif (!tegra->emc_node)\n\t\treturn NULL;\n\n\tpdev = of_find_device_by_node(tegra->emc_node);\n\tif (!pdev) {\n\t\tpr_err(\"%s: could not get external memory controller\\n\",\n\t\t       __func__);\n\t\treturn NULL;\n\t}\n\n\tof_node_put(tegra->emc_node);\n\ttegra->emc_node = NULL;\n\n\ttegra->emc = platform_get_drvdata(pdev);\n\tif (!tegra->emc) {\n\t\tput_device(&pdev->dev);\n\t\tpr_err(\"%s: cannot find EMC driver\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\treturn tegra->emc;\n}\n\nstatic int emc_set_timing(struct tegra_clk_emc *tegra,\n\t\t\t  struct emc_timing *timing)\n{\n\tint err;\n\tu8 div;\n\tu32 car_value;\n\tunsigned long flags = 0;\n\tstruct tegra_emc *emc = emc_ensure_emc_driver(tegra);\n\n\tif (!emc)\n\t\treturn -ENOENT;\n\n\tpr_debug(\"going to rate %ld prate %ld p %s\\n\", timing->rate,\n\t\t timing->parent_rate, __clk_get_name(timing->parent));\n\n\tif (emc_get_parent(&tegra->hw) == timing->parent_index &&\n\t    clk_get_rate(timing->parent) != timing->parent_rate) {\n\t\tWARN_ONCE(1, \"parent %s rate mismatch %lu %lu\\n\",\n\t\t\t  __clk_get_name(timing->parent),\n\t\t\t  clk_get_rate(timing->parent),\n\t\t\t  timing->parent_rate);\n\t\treturn -EINVAL;\n\t}\n\n\ttegra->changing_timing = true;\n\n\terr = clk_set_rate(timing->parent, timing->parent_rate);\n\tif (err) {\n\t\tpr_err(\"cannot change parent %s rate to %ld: %d\\n\",\n\t\t       __clk_get_name(timing->parent), timing->parent_rate,\n\t\t       err);\n\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(timing->parent);\n\tif (err) {\n\t\tpr_err(\"cannot enable parent clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tdiv = timing->parent_rate / (timing->rate / 2) - 2;\n\n\terr = tegra->prepare_timing_change(emc, timing->rate);\n\tif (err) {\n\t\tclk_disable_unprepare(timing->parent);\n\t\treturn err;\n\t}\n\n\tspin_lock_irqsave(tegra->lock, flags);\n\n\tcar_value = readl(tegra->clk_regs + CLK_SOURCE_EMC);\n\n\tcar_value &= ~CLK_SOURCE_EMC_EMC_2X_CLK_SRC(~0);\n\tcar_value |= CLK_SOURCE_EMC_EMC_2X_CLK_SRC(timing->parent_index);\n\n\tcar_value &= ~CLK_SOURCE_EMC_EMC_2X_CLK_DIVISOR(~0);\n\tcar_value |= CLK_SOURCE_EMC_EMC_2X_CLK_DIVISOR(div);\n\n\twritel(car_value, tegra->clk_regs + CLK_SOURCE_EMC);\n\n\tspin_unlock_irqrestore(tegra->lock, flags);\n\n\ttegra->complete_timing_change(emc, timing->rate);\n\n\tclk_hw_reparent(&tegra->hw, __clk_get_hw(timing->parent));\n\tclk_disable_unprepare(tegra->prev_parent);\n\n\ttegra->prev_parent = timing->parent;\n\ttegra->changing_timing = false;\n\n\treturn 0;\n}\n\n \nstatic struct emc_timing *get_backup_timing(struct tegra_clk_emc *tegra,\n\t\t\t\t\t    int timing_index)\n{\n\tint i;\n\tu32 ram_code = tegra_read_ram_code();\n\tstruct emc_timing *timing;\n\n\tfor (i = timing_index+1; i < tegra->num_timings; i++) {\n\t\ttiming = tegra->timings + i;\n\t\tif (timing->ram_code != ram_code)\n\t\t\tbreak;\n\n\t\tif (emc_parent_clk_sources[timing->parent_index] !=\n\t\t    emc_parent_clk_sources[\n\t\t      tegra->timings[timing_index].parent_index])\n\t\t\treturn timing;\n\t}\n\n\tfor (i = timing_index-1; i >= 0; --i) {\n\t\ttiming = tegra->timings + i;\n\t\tif (timing->ram_code != ram_code)\n\t\t\tbreak;\n\n\t\tif (emc_parent_clk_sources[timing->parent_index] !=\n\t\t    emc_parent_clk_sources[\n\t\t      tegra->timings[timing_index].parent_index])\n\t\t\treturn timing;\n\t}\n\n\treturn NULL;\n}\n\nstatic int emc_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\tunsigned long parent_rate)\n{\n\tstruct tegra_clk_emc *tegra;\n\tstruct emc_timing *timing = NULL;\n\tint i, err;\n\tu32 ram_code = tegra_read_ram_code();\n\n\ttegra = container_of(hw, struct tegra_clk_emc, hw);\n\n\tif (clk_hw_get_rate(hw) == rate)\n\t\treturn 0;\n\n\t \n\tif (tegra->changing_timing)\n\t\treturn 0;\n\n\tfor (i = 0; i < tegra->num_timings; i++) {\n\t\tif (tegra->timings[i].rate == rate &&\n\t\t    tegra->timings[i].ram_code == ram_code) {\n\t\t\ttiming = tegra->timings + i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!timing) {\n\t\tpr_err(\"cannot switch to rate %ld without emc table\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tif (emc_parent_clk_sources[emc_get_parent(hw)] ==\n\t    emc_parent_clk_sources[timing->parent_index] &&\n\t    clk_get_rate(timing->parent) != timing->parent_rate) {\n\t\t \n\n\t\tstruct emc_timing *backup_timing;\n\n\t\tbackup_timing = get_backup_timing(tegra, i);\n\t\tif (!backup_timing) {\n\t\t\tpr_err(\"cannot find backup timing\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpr_debug(\"using %ld as backup rate when going to %ld\\n\",\n\t\t\t backup_timing->rate, rate);\n\n\t\terr = emc_set_timing(tegra, backup_timing);\n\t\tif (err) {\n\t\t\tpr_err(\"cannot set backup timing: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn emc_set_timing(tegra, timing);\n}\n\n \n\nstatic int load_one_timing_from_dt(struct tegra_clk_emc *tegra,\n\t\t\t\t   struct emc_timing *timing,\n\t\t\t\t   struct device_node *node)\n{\n\tint err, i;\n\tu32 tmp;\n\n\terr = of_property_read_u32(node, \"clock-frequency\", &tmp);\n\tif (err) {\n\t\tpr_err(\"timing %pOF: failed to read rate\\n\", node);\n\t\treturn err;\n\t}\n\n\ttiming->rate = tmp;\n\n\terr = of_property_read_u32(node, \"nvidia,parent-clock-frequency\", &tmp);\n\tif (err) {\n\t\tpr_err(\"timing %pOF: failed to read parent rate\\n\", node);\n\t\treturn err;\n\t}\n\n\ttiming->parent_rate = tmp;\n\n\ttiming->parent = of_clk_get_by_name(node, \"emc-parent\");\n\tif (IS_ERR(timing->parent)) {\n\t\tpr_err(\"timing %pOF: failed to get parent clock\\n\", node);\n\t\treturn PTR_ERR(timing->parent);\n\t}\n\n\ttiming->parent_index = 0xff;\n\ti = match_string(emc_parent_clk_names, ARRAY_SIZE(emc_parent_clk_names),\n\t\t\t __clk_get_name(timing->parent));\n\tif (i < 0) {\n\t\tpr_err(\"timing %pOF: %s is not a valid parent\\n\",\n\t\t       node, __clk_get_name(timing->parent));\n\t\tclk_put(timing->parent);\n\t\treturn -EINVAL;\n\t}\n\n\ttiming->parent_index = i;\n\treturn 0;\n}\n\nstatic int cmp_timings(const void *_a, const void *_b)\n{\n\tconst struct emc_timing *a = _a;\n\tconst struct emc_timing *b = _b;\n\n\tif (a->rate < b->rate)\n\t\treturn -1;\n\telse if (a->rate == b->rate)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic int load_timings_from_dt(struct tegra_clk_emc *tegra,\n\t\t\t\tstruct device_node *node,\n\t\t\t\tu32 ram_code)\n{\n\tstruct emc_timing *timings_ptr;\n\tstruct device_node *child;\n\tint child_count = of_get_child_count(node);\n\tint i = 0, err;\n\tsize_t size;\n\n\tsize = (tegra->num_timings + child_count) * sizeof(struct emc_timing);\n\n\ttegra->timings = krealloc(tegra->timings, size, GFP_KERNEL);\n\tif (!tegra->timings)\n\t\treturn -ENOMEM;\n\n\ttimings_ptr = tegra->timings + tegra->num_timings;\n\ttegra->num_timings += child_count;\n\n\tfor_each_child_of_node(node, child) {\n\t\tstruct emc_timing *timing = timings_ptr + (i++);\n\n\t\terr = load_one_timing_from_dt(tegra, timing, child);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\tkfree(tegra->timings);\n\t\t\treturn err;\n\t\t}\n\n\t\ttiming->ram_code = ram_code;\n\t}\n\n\tsort(timings_ptr, child_count, sizeof(struct emc_timing),\n\t     cmp_timings, NULL);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops tegra_clk_emc_ops = {\n\t.recalc_rate = emc_recalc_rate,\n\t.determine_rate = emc_determine_rate,\n\t.set_rate = emc_set_rate,\n\t.get_parent = emc_get_parent,\n};\n\nstruct clk *tegra124_clk_register_emc(void __iomem *base, struct device_node *np,\n\t\t\t\t      spinlock_t *lock)\n{\n\tstruct tegra_clk_emc *tegra;\n\tstruct clk_init_data init;\n\tstruct device_node *node;\n\tu32 node_ram_code;\n\tstruct clk *clk;\n\tint err;\n\n\ttegra = kcalloc(1, sizeof(*tegra), GFP_KERNEL);\n\tif (!tegra)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttegra->clk_regs = base;\n\ttegra->lock = lock;\n\n\ttegra->num_timings = 0;\n\n\tfor_each_child_of_node(np, node) {\n\t\terr = of_property_read_u32(node, \"nvidia,ram-code\",\n\t\t\t\t\t   &node_ram_code);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\t \n\t\terr = load_timings_from_dt(tegra, node, node_ram_code);\n\t\tif (err) {\n\t\t\tof_node_put(node);\n\t\t\tkfree(tegra);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tif (tegra->num_timings == 0)\n\t\tpr_warn(\"%s: no memory timings registered\\n\", __func__);\n\n\ttegra->emc_node = of_parse_phandle(np,\n\t\t\t\"nvidia,external-memory-controller\", 0);\n\tif (!tegra->emc_node)\n\t\tpr_warn(\"%s: couldn't find node for EMC driver\\n\", __func__);\n\n\tinit.name = \"emc\";\n\tinit.ops = &tegra_clk_emc_ops;\n\tinit.flags = CLK_IS_CRITICAL;\n\tinit.parent_names = emc_parent_clk_names;\n\tinit.num_parents = ARRAY_SIZE(emc_parent_clk_names);\n\n\ttegra->hw.init = &init;\n\n\tclk = clk_register(NULL, &tegra->hw);\n\tif (IS_ERR(clk))\n\t\treturn clk;\n\n\ttegra->prev_parent = clk_hw_get_parent_by_index(\n\t\t&tegra->hw, emc_get_parent(&tegra->hw))->clk;\n\ttegra->changing_timing = false;\n\n\t \n\tclk_register_clkdev(clk, \"emc\", \"tegra-clk-debug\");\n\n\treturn clk;\n};\n\nvoid tegra124_clk_set_emc_callbacks(tegra124_emc_prepare_timing_change_cb *prep_cb,\n\t\t\t\t    tegra124_emc_complete_timing_change_cb *complete_cb)\n{\n\tstruct clk *clk = __clk_lookup(\"emc\");\n\tstruct tegra_clk_emc *tegra;\n\tstruct clk_hw *hw;\n\n\tif (clk) {\n\t\thw = __clk_get_hw(clk);\n\t\ttegra = container_of(hw, struct tegra_clk_emc, hw);\n\n\t\ttegra->prepare_timing_change = prep_cb;\n\t\ttegra->complete_timing_change = complete_cb;\n\t}\n}\nEXPORT_SYMBOL_GPL(tegra124_clk_set_emc_callbacks);\n\nbool tegra124_clk_emc_driver_available(struct clk_hw *hw)\n{\n\tstruct tegra_clk_emc *tegra = container_of(hw, struct tegra_clk_emc, hw);\n\n\treturn tegra->prepare_timing_change && tegra->complete_timing_change;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}