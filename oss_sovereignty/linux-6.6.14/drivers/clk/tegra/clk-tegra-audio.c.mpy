{
  "module_name": "clk-tegra-audio.c",
  "hash_id": "444cafd11a6d7a5dd16aa7369d7abef219c97ab68afdf87c334498e2d2471df2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-tegra-audio.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/clk-provider.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/clk/tegra.h>\n\n#include \"clk.h\"\n#include \"clk-id.h\"\n\n#define AUDIO_SYNC_CLK_I2S0 0x4a0\n#define AUDIO_SYNC_CLK_I2S1 0x4a4\n#define AUDIO_SYNC_CLK_I2S2 0x4a8\n#define AUDIO_SYNC_CLK_I2S3 0x4ac\n#define AUDIO_SYNC_CLK_I2S4 0x4b0\n#define AUDIO_SYNC_CLK_SPDIF 0x4b4\n#define AUDIO_SYNC_CLK_DMIC1 0x560\n#define AUDIO_SYNC_CLK_DMIC2 0x564\n#define AUDIO_SYNC_CLK_DMIC3 0x6b8\n\n#define AUDIO_SYNC_DOUBLER 0x49c\n\n#define PLLA_OUT 0xb4\n\nstruct tegra_sync_source_initdata {\n\tchar\t\t*name;\n\tunsigned long\trate;\n\tunsigned long\tmax_rate;\n\tint\t\tclk_id;\n};\n\n#define SYNC(_name) \\\n\t{\\\n\t\t.name\t\t= #_name,\\\n\t\t.clk_id\t\t= tegra_clk_ ## _name,\\\n\t}\n\nstruct tegra_audio_clk_initdata {\n\tchar\t\t*gate_name;\n\tchar\t\t*mux_name;\n\tu32\t\toffset;\n\tint\t\tgate_clk_id;\n\tint\t\tmux_clk_id;\n};\n\n#define AUDIO(_name, _offset) \\\n\t{\\\n\t\t.gate_name\t= #_name,\\\n\t\t.mux_name\t= #_name\"_mux\",\\\n\t\t.offset\t\t= _offset,\\\n\t\t.gate_clk_id\t= tegra_clk_ ## _name,\\\n\t\t.mux_clk_id\t= tegra_clk_ ## _name ## _mux,\\\n\t}\n\nstruct tegra_audio2x_clk_initdata {\n\tchar\t\t*parent;\n\tchar\t\t*gate_name;\n\tchar\t\t*name_2x;\n\tchar\t\t*div_name;\n\tint\t\tclk_id;\n\tint\t\tclk_num;\n\tu8\t\tdiv_offset;\n};\n\n#define AUDIO2X(_name, _num, _offset) \\\n\t{\\\n\t\t.parent\t\t= #_name,\\\n\t\t.gate_name\t= #_name\"_2x\",\\\n\t\t.name_2x\t= #_name\"_doubler\",\\\n\t\t.div_name\t= #_name\"_div\",\\\n\t\t.clk_id\t\t= tegra_clk_ ## _name ## _2x,\\\n\t\t.clk_num\t= _num,\\\n\t\t.div_offset\t= _offset,\\\n\t}\n\nstatic DEFINE_SPINLOCK(clk_doubler_lock);\n\nstatic const char * const mux_audio_sync_clk[] = { \"spdif_in_sync\",\n\t\"i2s0_sync\", \"i2s1_sync\", \"i2s2_sync\", \"i2s3_sync\", \"i2s4_sync\",\n\t\"pll_a_out0\", \"vimclk_sync\",\n};\n\nstatic const char * const mux_dmic_sync_clk[] = { \"unused\", \"i2s0_sync\",\n\t\"i2s1_sync\", \"i2s2_sync\", \"i2s3_sync\", \"i2s4_sync\", \"pll_a_out0\",\n\t\"vimclk_sync\",\n};\n\nstatic struct tegra_sync_source_initdata sync_source_clks[] __initdata = {\n\tSYNC(spdif_in_sync),\n\tSYNC(i2s0_sync),\n\tSYNC(i2s1_sync),\n\tSYNC(i2s2_sync),\n\tSYNC(i2s3_sync),\n\tSYNC(i2s4_sync),\n\tSYNC(vimclk_sync),\n};\n\nstatic struct tegra_audio_clk_initdata audio_clks[] = {\n\tAUDIO(audio0, AUDIO_SYNC_CLK_I2S0),\n\tAUDIO(audio1, AUDIO_SYNC_CLK_I2S1),\n\tAUDIO(audio2, AUDIO_SYNC_CLK_I2S2),\n\tAUDIO(audio3, AUDIO_SYNC_CLK_I2S3),\n\tAUDIO(audio4, AUDIO_SYNC_CLK_I2S4),\n\tAUDIO(spdif, AUDIO_SYNC_CLK_SPDIF),\n};\n\nstatic struct tegra_audio_clk_initdata dmic_clks[] = {\n\tAUDIO(dmic1_sync_clk, AUDIO_SYNC_CLK_DMIC1),\n\tAUDIO(dmic2_sync_clk, AUDIO_SYNC_CLK_DMIC2),\n\tAUDIO(dmic3_sync_clk, AUDIO_SYNC_CLK_DMIC3),\n};\n\nstatic struct tegra_audio2x_clk_initdata audio2x_clks[] = {\n\tAUDIO2X(audio0, 113, 24),\n\tAUDIO2X(audio1, 114, 25),\n\tAUDIO2X(audio2, 115, 26),\n\tAUDIO2X(audio3, 116, 27),\n\tAUDIO2X(audio4, 117, 28),\n\tAUDIO2X(spdif, 118, 29),\n};\n\nstatic void __init tegra_audio_sync_clk_init(void __iomem *clk_base,\n\t\t\t\t      struct tegra_clk *tegra_clks,\n\t\t\t\t      struct tegra_audio_clk_initdata *sync,\n\t\t\t\t      int num_sync_clks,\n\t\t\t\t      const char * const *mux_names,\n\t\t\t\t      int num_mux_inputs)\n{\n\tstruct clk *clk;\n\tstruct clk **dt_clk;\n\tstruct tegra_audio_clk_initdata *data;\n\tint i;\n\n\tfor (i = 0, data = sync; i < num_sync_clks; i++, data++) {\n\t\tdt_clk = tegra_lookup_dt_id(data->mux_clk_id, tegra_clks);\n\t\tif (!dt_clk)\n\t\t\tcontinue;\n\n\t\tclk = clk_register_mux(NULL, data->mux_name, mux_names,\n\t\t\t\t\tnum_mux_inputs,\n\t\t\t\t\tCLK_SET_RATE_NO_REPARENT,\n\t\t\t\t\tclk_base + data->offset, 0, 3, 0,\n\t\t\t\t\tNULL);\n\t\t*dt_clk = clk;\n\n\t\tdt_clk = tegra_lookup_dt_id(data->gate_clk_id, tegra_clks);\n\t\tif (!dt_clk)\n\t\t\tcontinue;\n\n\t\tclk = clk_register_gate(NULL, data->gate_name, data->mux_name,\n\t\t\t\t\t0, clk_base + data->offset, 4,\n\t\t\t\t\tCLK_GATE_SET_TO_DISABLE, NULL);\n\t\t*dt_clk = clk;\n\t}\n}\n\nvoid __init tegra_audio_clk_init(void __iomem *clk_base,\n\t\t\tvoid __iomem *pmc_base, struct tegra_clk *tegra_clks,\n\t\t\tstruct tegra_audio_clk_info *audio_info,\n\t\t\tunsigned int num_plls, unsigned long sync_max_rate)\n{\n\tstruct clk *clk;\n\tstruct clk **dt_clk;\n\tint i;\n\n\tif (!audio_info || num_plls < 1) {\n\t\tpr_err(\"No audio data passed to tegra_audio_clk_init\\n\");\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < num_plls; i++) {\n\t\tstruct tegra_audio_clk_info *info = &audio_info[i];\n\n\t\tdt_clk = tegra_lookup_dt_id(info->clk_id, tegra_clks);\n\t\tif (dt_clk) {\n\t\t\tclk = tegra_clk_register_pll(info->name, info->parent,\n\t\t\t\t\tclk_base, pmc_base, 0, info->pll_params,\n\t\t\t\t\tNULL);\n\t\t\t*dt_clk = clk;\n\t\t}\n\t}\n\n\t \n\tdt_clk = tegra_lookup_dt_id(tegra_clk_pll_a_out0, tegra_clks);\n\tif (dt_clk) {\n\t\tclk = tegra_clk_register_divider(\"pll_a_out0_div\", \"pll_a\",\n\t\t\t\tclk_base + PLLA_OUT, 0, TEGRA_DIVIDER_ROUND_UP,\n\t\t\t\t8, 8, 1, NULL);\n\t\tclk = tegra_clk_register_pll_out(\"pll_a_out0\", \"pll_a_out0_div\",\n\t\t\t\tclk_base + PLLA_OUT, 1, 0, CLK_IGNORE_UNUSED |\n\t\t\t\tCLK_SET_RATE_PARENT, 0, NULL);\n\t\t*dt_clk = clk;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(sync_source_clks); i++) {\n\t\tstruct tegra_sync_source_initdata *data;\n\n\t\tdata = &sync_source_clks[i];\n\n\t\tdt_clk = tegra_lookup_dt_id(data->clk_id, tegra_clks);\n\t\tif (!dt_clk)\n\t\t\tcontinue;\n\n\t\tclk = tegra_clk_register_sync_source(data->name, sync_max_rate);\n\t\t*dt_clk = clk;\n\t}\n\n\ttegra_audio_sync_clk_init(clk_base, tegra_clks, audio_clks,\n\t\t\t\t  ARRAY_SIZE(audio_clks), mux_audio_sync_clk,\n\t\t\t\t  ARRAY_SIZE(mux_audio_sync_clk));\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dmic_clks); i++)\n\t\twritel_relaxed(1, clk_base + dmic_clks[i].offset);\n\n\ttegra_audio_sync_clk_init(clk_base, tegra_clks, dmic_clks,\n\t\t\t\t  ARRAY_SIZE(dmic_clks), mux_dmic_sync_clk,\n\t\t\t\t  ARRAY_SIZE(mux_dmic_sync_clk));\n\n\tfor (i = 0; i < ARRAY_SIZE(audio2x_clks); i++) {\n\t\tstruct tegra_audio2x_clk_initdata *data;\n\n\t\tdata = &audio2x_clks[i];\n\t\tdt_clk = tegra_lookup_dt_id(data->clk_id, tegra_clks);\n\t\tif (!dt_clk)\n\t\t\tcontinue;\n\n\t\tclk = clk_register_fixed_factor(NULL, data->name_2x,\n\t\t\t\tdata->parent, CLK_SET_RATE_PARENT, 2, 1);\n\t\tclk = tegra_clk_register_divider(data->div_name,\n\t\t\t\tdata->name_2x, clk_base + AUDIO_SYNC_DOUBLER,\n\t\t\t\t0, 0, data->div_offset, 1, 0,\n\t\t\t\t&clk_doubler_lock);\n\t\tclk = tegra_clk_register_periph_gate(data->gate_name,\n\t\t\t\tdata->div_name, TEGRA_PERIPH_NO_RESET,\n\t\t\t\tclk_base, CLK_SET_RATE_PARENT, data->clk_num,\n\t\t\t\tperiph_clk_enb_refcnt);\n\t\t*dt_clk = clk;\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}