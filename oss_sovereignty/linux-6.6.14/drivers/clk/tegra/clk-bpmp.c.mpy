{
  "module_name": "clk-bpmp.c",
  "hash_id": "fb6c835345b3d71655989685818719d7eb5df45bf86f1a1e7d0836a11b9cd9f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-bpmp.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/seq_buf.h>\n#include <linux/slab.h>\n\n#include <soc/tegra/bpmp.h>\n#include <soc/tegra/bpmp-abi.h>\n\n#define TEGRA_BPMP_DUMP_CLOCK_INFO\t0\n\n#define TEGRA_BPMP_CLK_HAS_MUX\t\tBIT(0)\n#define TEGRA_BPMP_CLK_HAS_SET_RATE\tBIT(1)\n#define TEGRA_BPMP_CLK_IS_ROOT\t\tBIT(2)\n\nstruct tegra_bpmp_clk_info {\n\tunsigned int id;\n\tchar name[MRQ_CLK_NAME_MAXLEN];\n\tunsigned int parents[MRQ_CLK_MAX_PARENTS];\n\tunsigned int num_parents;\n\tunsigned long flags;\n};\n\nstruct tegra_bpmp_clk {\n\tstruct clk_hw hw;\n\n\tstruct tegra_bpmp *bpmp;\n\tunsigned int id;\n\n\tunsigned int num_parents;\n\tunsigned int *parents;\n};\n\nstatic inline struct tegra_bpmp_clk *to_tegra_bpmp_clk(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct tegra_bpmp_clk, hw);\n}\n\nstruct tegra_bpmp_clk_message {\n\tunsigned int cmd;\n\tunsigned int id;\n\n\tstruct {\n\t\tconst void *data;\n\t\tsize_t size;\n\t} tx;\n\n\tstruct {\n\t\tvoid *data;\n\t\tsize_t size;\n\t\tint ret;\n\t} rx;\n};\n\nstatic int tegra_bpmp_clk_transfer(struct tegra_bpmp *bpmp,\n\t\t\t\t   const struct tegra_bpmp_clk_message *clk)\n{\n\tstruct mrq_clk_request request;\n\tstruct tegra_bpmp_message msg;\n\tvoid *req = &request;\n\tint err;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.cmd_and_id = (clk->cmd << 24) | clk->id;\n\n\t \n\tmemcpy(req + 4, clk->tx.data, clk->tx.size);\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_CLK;\n\tmsg.tx.data = &request;\n\tmsg.tx.size = sizeof(request);\n\tmsg.rx.data = clk->rx.data;\n\tmsg.rx.size = clk->rx.size;\n\n\terr = tegra_bpmp_transfer(bpmp, &msg);\n\tif (err < 0)\n\t\treturn err;\n\telse if (msg.rx.ret < 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int tegra_bpmp_clk_prepare(struct clk_hw *hw)\n{\n\tstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\n\tstruct tegra_bpmp_clk_message msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.cmd = CMD_CLK_ENABLE;\n\tmsg.id = clk->id;\n\n\treturn tegra_bpmp_clk_transfer(clk->bpmp, &msg);\n}\n\nstatic void tegra_bpmp_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\n\tstruct tegra_bpmp_clk_message msg;\n\tint err;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.cmd = CMD_CLK_DISABLE;\n\tmsg.id = clk->id;\n\n\terr = tegra_bpmp_clk_transfer(clk->bpmp, &msg);\n\tif (err < 0)\n\t\tdev_err(clk->bpmp->dev, \"failed to disable clock %s: %d\\n\",\n\t\t\tclk_hw_get_name(hw), err);\n}\n\nstatic int tegra_bpmp_clk_is_prepared(struct clk_hw *hw)\n{\n\tstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\n\tstruct cmd_clk_is_enabled_response response;\n\tstruct tegra_bpmp_clk_message msg;\n\tint err;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.cmd = CMD_CLK_IS_ENABLED;\n\tmsg.id = clk->id;\n\tmsg.rx.data = &response;\n\tmsg.rx.size = sizeof(response);\n\n\terr = tegra_bpmp_clk_transfer(clk->bpmp, &msg);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn response.state;\n}\n\nstatic unsigned long tegra_bpmp_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\n\tstruct cmd_clk_get_rate_response response;\n\tstruct cmd_clk_get_rate_request request;\n\tstruct tegra_bpmp_clk_message msg;\n\tint err;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.cmd = CMD_CLK_GET_RATE;\n\tmsg.id = clk->id;\n\tmsg.tx.data = &request;\n\tmsg.tx.size = sizeof(request);\n\tmsg.rx.data = &response;\n\tmsg.rx.size = sizeof(response);\n\n\terr = tegra_bpmp_clk_transfer(clk->bpmp, &msg);\n\tif (err < 0)\n\t\treturn 0;\n\n\treturn response.rate;\n}\n\nstatic int tegra_bpmp_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t struct clk_rate_request *rate_req)\n{\n\tstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\n\tstruct cmd_clk_round_rate_response response;\n\tstruct cmd_clk_round_rate_request request;\n\tstruct tegra_bpmp_clk_message msg;\n\tunsigned long rate;\n\tint err;\n\n\trate = min(max(rate_req->rate, rate_req->min_rate), rate_req->max_rate);\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.rate = min_t(u64, rate, S64_MAX);\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.cmd = CMD_CLK_ROUND_RATE;\n\tmsg.id = clk->id;\n\tmsg.tx.data = &request;\n\tmsg.tx.size = sizeof(request);\n\tmsg.rx.data = &response;\n\tmsg.rx.size = sizeof(response);\n\n\terr = tegra_bpmp_clk_transfer(clk->bpmp, &msg);\n\tif (err < 0)\n\t\treturn err;\n\n\trate_req->rate = (unsigned long)response.rate;\n\n\treturn 0;\n}\n\nstatic int tegra_bpmp_clk_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\n\tstruct cmd_clk_set_parent_response response;\n\tstruct cmd_clk_set_parent_request request;\n\tstruct tegra_bpmp_clk_message msg;\n\tint err;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.parent_id = clk->parents[index];\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.cmd = CMD_CLK_SET_PARENT;\n\tmsg.id = clk->id;\n\tmsg.tx.data = &request;\n\tmsg.tx.size = sizeof(request);\n\tmsg.rx.data = &response;\n\tmsg.rx.size = sizeof(response);\n\n\terr = tegra_bpmp_clk_transfer(clk->bpmp, &msg);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\n\treturn 0;\n}\n\nstatic u8 tegra_bpmp_clk_get_parent(struct clk_hw *hw)\n{\n\tstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\n\tstruct cmd_clk_get_parent_response response;\n\tstruct tegra_bpmp_clk_message msg;\n\tunsigned int i;\n\tint err;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.cmd = CMD_CLK_GET_PARENT;\n\tmsg.id = clk->id;\n\tmsg.rx.data = &response;\n\tmsg.rx.size = sizeof(response);\n\n\terr = tegra_bpmp_clk_transfer(clk->bpmp, &msg);\n\tif (err < 0) {\n\t\tdev_err(clk->bpmp->dev, \"failed to get parent for %s: %d\\n\",\n\t\t\tclk_hw_get_name(hw), err);\n\t\treturn U8_MAX;\n\t}\n\n\tfor (i = 0; i < clk->num_parents; i++)\n\t\tif (clk->parents[i] == response.parent_id)\n\t\t\treturn i;\n\n\treturn U8_MAX;\n}\n\nstatic int tegra_bpmp_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\n\tstruct cmd_clk_set_rate_response response;\n\tstruct cmd_clk_set_rate_request request;\n\tstruct tegra_bpmp_clk_message msg;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.rate = min_t(u64, rate, S64_MAX);\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.cmd = CMD_CLK_SET_RATE;\n\tmsg.id = clk->id;\n\tmsg.tx.data = &request;\n\tmsg.tx.size = sizeof(request);\n\tmsg.rx.data = &response;\n\tmsg.rx.size = sizeof(response);\n\n\treturn tegra_bpmp_clk_transfer(clk->bpmp, &msg);\n}\n\nstatic const struct clk_ops tegra_bpmp_clk_gate_ops = {\n\t.prepare = tegra_bpmp_clk_prepare,\n\t.unprepare = tegra_bpmp_clk_unprepare,\n\t.is_prepared = tegra_bpmp_clk_is_prepared,\n\t.recalc_rate = tegra_bpmp_clk_recalc_rate,\n};\n\nstatic const struct clk_ops tegra_bpmp_clk_mux_ops = {\n\t.prepare = tegra_bpmp_clk_prepare,\n\t.unprepare = tegra_bpmp_clk_unprepare,\n\t.is_prepared = tegra_bpmp_clk_is_prepared,\n\t.recalc_rate = tegra_bpmp_clk_recalc_rate,\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.set_parent = tegra_bpmp_clk_set_parent,\n\t.get_parent = tegra_bpmp_clk_get_parent,\n};\n\nstatic const struct clk_ops tegra_bpmp_clk_rate_ops = {\n\t.prepare = tegra_bpmp_clk_prepare,\n\t.unprepare = tegra_bpmp_clk_unprepare,\n\t.is_prepared = tegra_bpmp_clk_is_prepared,\n\t.recalc_rate = tegra_bpmp_clk_recalc_rate,\n\t.determine_rate = tegra_bpmp_clk_determine_rate,\n\t.set_rate = tegra_bpmp_clk_set_rate,\n};\n\nstatic const struct clk_ops tegra_bpmp_clk_mux_rate_ops = {\n\t.prepare = tegra_bpmp_clk_prepare,\n\t.unprepare = tegra_bpmp_clk_unprepare,\n\t.is_prepared = tegra_bpmp_clk_is_prepared,\n\t.recalc_rate = tegra_bpmp_clk_recalc_rate,\n\t.determine_rate = tegra_bpmp_clk_determine_rate,\n\t.set_parent = tegra_bpmp_clk_set_parent,\n\t.get_parent = tegra_bpmp_clk_get_parent,\n\t.set_rate = tegra_bpmp_clk_set_rate,\n};\n\nstatic const struct clk_ops tegra_bpmp_clk_mux_read_only_ops = {\n\t.get_parent = tegra_bpmp_clk_get_parent,\n\t.recalc_rate = tegra_bpmp_clk_recalc_rate,\n};\n\nstatic const struct clk_ops tegra_bpmp_clk_read_only_ops = {\n\t.recalc_rate = tegra_bpmp_clk_recalc_rate,\n};\n\nstatic const struct clk_ops tegra_bpmp_clk_gate_mux_read_only_ops = {\n\t.prepare = tegra_bpmp_clk_prepare,\n\t.unprepare = tegra_bpmp_clk_unprepare,\n\t.is_prepared = tegra_bpmp_clk_is_prepared,\n\t.recalc_rate = tegra_bpmp_clk_recalc_rate,\n\t.get_parent = tegra_bpmp_clk_get_parent,\n};\n\nstatic int tegra_bpmp_clk_get_max_id(struct tegra_bpmp *bpmp)\n{\n\tstruct cmd_clk_get_max_clk_id_response response;\n\tstruct tegra_bpmp_clk_message msg;\n\tint err;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.cmd = CMD_CLK_GET_MAX_CLK_ID;\n\tmsg.rx.data = &response;\n\tmsg.rx.size = sizeof(response);\n\n\terr = tegra_bpmp_clk_transfer(bpmp, &msg);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (response.max_id > INT_MAX)\n\t\treturn -E2BIG;\n\n\treturn response.max_id;\n}\n\nstatic int tegra_bpmp_clk_get_info(struct tegra_bpmp *bpmp, unsigned int id,\n\t\t\t\t   struct tegra_bpmp_clk_info *info)\n{\n\tstruct cmd_clk_get_all_info_response response;\n\tstruct tegra_bpmp_clk_message msg;\n\tunsigned int i;\n\tint err;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.cmd = CMD_CLK_GET_ALL_INFO;\n\tmsg.id = id;\n\tmsg.rx.data = &response;\n\tmsg.rx.size = sizeof(response);\n\n\terr = tegra_bpmp_clk_transfer(bpmp, &msg);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrscpy(info->name, response.name, MRQ_CLK_NAME_MAXLEN);\n\tinfo->num_parents = response.num_parents;\n\n\tfor (i = 0; i < info->num_parents; i++)\n\t\tinfo->parents[i] = response.parents[i];\n\n\tinfo->flags = response.flags;\n\n\treturn 0;\n}\n\nstatic void tegra_bpmp_clk_info_dump(struct tegra_bpmp *bpmp,\n\t\t\t\t     const char *level,\n\t\t\t\t     const struct tegra_bpmp_clk_info *info)\n{\n\tconst char *prefix = \"\";\n\tstruct seq_buf buf;\n\tunsigned int i;\n\tchar flags[64];\n\n\tseq_buf_init(&buf, flags, sizeof(flags));\n\n\tif (info->flags)\n\t\tseq_buf_printf(&buf, \"(\");\n\n\tif (info->flags & TEGRA_BPMP_CLK_HAS_MUX) {\n\t\tseq_buf_printf(&buf, \"%smux\", prefix);\n\t\tprefix = \", \";\n\t}\n\n\tif ((info->flags & TEGRA_BPMP_CLK_HAS_SET_RATE) == 0) {\n\t\tseq_buf_printf(&buf, \"%sfixed\", prefix);\n\t\tprefix = \", \";\n\t}\n\n\tif (info->flags & TEGRA_BPMP_CLK_IS_ROOT) {\n\t\tseq_buf_printf(&buf, \"%sroot\", prefix);\n\t\tprefix = \", \";\n\t}\n\n\tif (info->flags)\n\t\tseq_buf_printf(&buf, \")\");\n\n\tdev_printk(level, bpmp->dev, \"%03u: %s\\n\", info->id, info->name);\n\tdev_printk(level, bpmp->dev, \"  flags: %lx %s\\n\", info->flags, flags);\n\tdev_printk(level, bpmp->dev, \"  parents: %u\\n\", info->num_parents);\n\n\tfor (i = 0; i < info->num_parents; i++)\n\t\tdev_printk(level, bpmp->dev, \"    %03u\\n\", info->parents[i]);\n}\n\nstatic int tegra_bpmp_probe_clocks(struct tegra_bpmp *bpmp,\n\t\t\t\t   struct tegra_bpmp_clk_info **clocksp)\n{\n\tstruct tegra_bpmp_clk_info *clocks;\n\tunsigned int max_id, id, count = 0;\n\tunsigned int holes = 0;\n\tint err;\n\n\terr = tegra_bpmp_clk_get_max_id(bpmp);\n\tif (err < 0)\n\t\treturn err;\n\n\tmax_id = err;\n\n\tdev_dbg(bpmp->dev, \"maximum clock ID: %u\\n\", max_id);\n\n\tclocks = kcalloc(max_id + 1, sizeof(*clocks), GFP_KERNEL);\n\tif (!clocks)\n\t\treturn -ENOMEM;\n\n\tfor (id = 0; id <= max_id; id++) {\n\t\tstruct tegra_bpmp_clk_info *info = &clocks[count];\n\n\t\terr = tegra_bpmp_clk_get_info(bpmp, id, info);\n\t\tif (err < 0)\n\t\t\tcontinue;\n\n\t\tif (info->num_parents >= U8_MAX) {\n\t\t\tdev_err(bpmp->dev,\n\t\t\t\t\"clock %u has too many parents (%u, max: %u)\\n\",\n\t\t\t\tid, info->num_parents, U8_MAX);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (info->name[0] == '\\0') {\n\t\t\tholes++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinfo->id = id;\n\t\tcount++;\n\n\t\tif (TEGRA_BPMP_DUMP_CLOCK_INFO)\n\t\t\ttegra_bpmp_clk_info_dump(bpmp, KERN_DEBUG, info);\n\t}\n\n\tdev_dbg(bpmp->dev, \"holes: %u\\n\", holes);\n\t*clocksp = clocks;\n\n\treturn count;\n}\n\nstatic unsigned int\ntegra_bpmp_clk_id_to_index(const struct tegra_bpmp_clk_info *clocks,\n\t\t\t   unsigned int num_clocks, unsigned int id)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num_clocks; i++)\n\t\tif (clocks[i].id == id)\n\t\t\treturn i;\n\n\treturn UINT_MAX;\n}\n\nstatic const struct tegra_bpmp_clk_info *\ntegra_bpmp_clk_find(const struct tegra_bpmp_clk_info *clocks,\n\t\t    unsigned int num_clocks, unsigned int id)\n{\n\tunsigned int i;\n\n\ti = tegra_bpmp_clk_id_to_index(clocks, num_clocks, id);\n\n\tif (i < num_clocks)\n\t\treturn &clocks[i];\n\n\treturn NULL;\n}\n\nstatic struct tegra_bpmp_clk *\ntegra_bpmp_clk_register(struct tegra_bpmp *bpmp,\n\t\t\tconst struct tegra_bpmp_clk_info *info,\n\t\t\tconst struct tegra_bpmp_clk_info *clocks,\n\t\t\tunsigned int num_clocks)\n{\n\tstruct tegra_bpmp_clk *clk;\n\tstruct clk_init_data init;\n\tconst char **parents;\n\tunsigned int i;\n\tint err;\n\n\tclk = devm_kzalloc(bpmp->dev, sizeof(*clk), GFP_KERNEL);\n\tif (!clk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk->id = info->id;\n\tclk->bpmp = bpmp;\n\n\tclk->parents = devm_kcalloc(bpmp->dev, info->num_parents,\n\t\t\t\t    sizeof(*clk->parents), GFP_KERNEL);\n\tif (!clk->parents)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk->num_parents = info->num_parents;\n\n\t \n\tmemset(&init, 0, sizeof(init));\n\tinit.name = info->name;\n\tclk->hw.init = &init;\n\tif (info->flags & BPMP_CLK_STATE_CHANGE_DENIED) {\n\t\tif ((info->flags & BPMP_CLK_RATE_PARENT_CHANGE_DENIED) == 0) {\n\t\t\tdev_WARN(bpmp->dev,\n\t\t\t\t\"Firmware bug! Inconsistent permission bits for clock %s. State and parent/rate changes disabled.\",\n\t\t\t\t init.name);\n\t\t}\n\t\tif (info->flags & TEGRA_BPMP_CLK_HAS_MUX)\n\t\t\tinit.ops = &tegra_bpmp_clk_mux_read_only_ops;\n\t\telse\n\t\t\tinit.ops = &tegra_bpmp_clk_read_only_ops;\n\t} else if (info->flags & BPMP_CLK_RATE_PARENT_CHANGE_DENIED) {\n\t\tif (info->flags & TEGRA_BPMP_CLK_HAS_MUX)\n\t\t\tinit.ops = &tegra_bpmp_clk_gate_mux_read_only_ops;\n\t\telse\n\t\t\tinit.ops = &tegra_bpmp_clk_gate_ops;\n\t} else if (info->flags & TEGRA_BPMP_CLK_HAS_MUX) {\n\t\tif (info->flags & TEGRA_BPMP_CLK_HAS_SET_RATE)\n\t\t\tinit.ops = &tegra_bpmp_clk_mux_rate_ops;\n\t\telse\n\t\t\tinit.ops = &tegra_bpmp_clk_mux_ops;\n\t} else {\n\t\tif (info->flags & TEGRA_BPMP_CLK_HAS_SET_RATE)\n\t\t\tinit.ops = &tegra_bpmp_clk_rate_ops;\n\t\telse\n\t\t\tinit.ops = &tegra_bpmp_clk_gate_ops;\n\t}\n\n\tinit.num_parents = info->num_parents;\n\n\tparents = kcalloc(info->num_parents, sizeof(*parents), GFP_KERNEL);\n\tif (!parents)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < info->num_parents; i++) {\n\t\tconst struct tegra_bpmp_clk_info *parent;\n\n\t\t \n\t\tclk->parents[i] = info->parents[i];\n\n\t\tparent = tegra_bpmp_clk_find(clocks, num_clocks,\n\t\t\t\t\t     info->parents[i]);\n\t\tif (!parent) {\n\t\t\tdev_err(bpmp->dev, \"no parent %u found for %u\\n\",\n\t\t\t\tinfo->parents[i], info->id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tparents[i] = parent->name;\n\t}\n\n\tinit.parent_names = parents;\n\n\terr = devm_clk_hw_register(bpmp->dev, &clk->hw);\n\n\tkfree(parents);\n\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\treturn clk;\n}\n\nstatic void tegra_bpmp_register_clocks_one(struct tegra_bpmp *bpmp,\n\t\t\t\t\t   struct tegra_bpmp_clk_info *infos,\n\t\t\t\t\t   unsigned int i,\n\t\t\t\t\t   unsigned int count)\n{\n\tunsigned int j;\n\tstruct tegra_bpmp_clk_info *info;\n\tstruct tegra_bpmp_clk *clk;\n\n\tif (bpmp->clocks[i]) {\n\t\t \n\t\treturn;\n\t}\n\n\tinfo = &infos[i];\n\tfor (j = 0; j < info->num_parents; ++j) {\n\t\tunsigned int p_id = info->parents[j];\n\t\tunsigned int p_i = tegra_bpmp_clk_id_to_index(infos, count,\n\t\t\t\t\t\t\t      p_id);\n\t\tif (p_i < count)\n\t\t\ttegra_bpmp_register_clocks_one(bpmp, infos, p_i, count);\n\t}\n\n\tclk = tegra_bpmp_clk_register(bpmp, info, infos, count);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(bpmp->dev,\n\t\t\t\"failed to register clock %u (%s): %ld\\n\",\n\t\t\tinfo->id, info->name, PTR_ERR(clk));\n\t\t \n\t}\n\n\tbpmp->clocks[i] = clk;\n}\n\nstatic int tegra_bpmp_register_clocks(struct tegra_bpmp *bpmp,\n\t\t\t\t      struct tegra_bpmp_clk_info *infos,\n\t\t\t\t      unsigned int count)\n{\n\tunsigned int i;\n\n\tbpmp->num_clocks = count;\n\n\tbpmp->clocks = devm_kcalloc(bpmp->dev, count, sizeof(struct tegra_bpmp_clk), GFP_KERNEL);\n\tif (!bpmp->clocks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count; i++) {\n\t\ttegra_bpmp_register_clocks_one(bpmp, infos, i, count);\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_bpmp_unregister_clocks(struct tegra_bpmp *bpmp)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < bpmp->num_clocks; i++)\n\t\tclk_hw_unregister(&bpmp->clocks[i]->hw);\n}\n\nstatic struct clk_hw *tegra_bpmp_clk_of_xlate(struct of_phandle_args *clkspec,\n\t\t\t\t\t      void *data)\n{\n\tunsigned int id = clkspec->args[0], i;\n\tstruct tegra_bpmp *bpmp = data;\n\n\tfor (i = 0; i < bpmp->num_clocks; i++) {\n\t\tstruct tegra_bpmp_clk *clk = bpmp->clocks[i];\n\n\t\tif (!clk)\n\t\t\tcontinue;\n\n\t\tif (clk->id == id)\n\t\t\treturn &clk->hw;\n\t}\n\n\treturn NULL;\n}\n\nint tegra_bpmp_init_clocks(struct tegra_bpmp *bpmp)\n{\n\tstruct tegra_bpmp_clk_info *clocks;\n\tunsigned int count;\n\tint err;\n\n\terr = tegra_bpmp_probe_clocks(bpmp, &clocks);\n\tif (err < 0)\n\t\treturn err;\n\n\tcount = err;\n\n\tdev_dbg(bpmp->dev, \"%u clocks probed\\n\", count);\n\n\terr = tegra_bpmp_register_clocks(bpmp, clocks, count);\n\tif (err < 0)\n\t\tgoto free;\n\n\terr = of_clk_add_hw_provider(bpmp->dev->of_node,\n\t\t\t\t     tegra_bpmp_clk_of_xlate,\n\t\t\t\t     bpmp);\n\tif (err < 0) {\n\t\ttegra_bpmp_unregister_clocks(bpmp);\n\t\tgoto free;\n\t}\n\nfree:\n\tkfree(clocks);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}