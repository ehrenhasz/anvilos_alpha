{
  "module_name": "clk-periph.c",
  "hash_id": "4c9ee38e4dacbdc4e197fabe3a95325005462cd5b0a747f0b25bfbd9f4b43324",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-periph.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\n#include \"clk.h\"\n\nstatic u8 clk_periph_get_parent(struct clk_hw *hw)\n{\n\tstruct tegra_clk_periph *periph = to_clk_periph(hw);\n\tconst struct clk_ops *mux_ops = periph->mux_ops;\n\tstruct clk_hw *mux_hw = &periph->mux.hw;\n\n\t__clk_hw_set_clk(mux_hw, hw);\n\n\treturn mux_ops->get_parent(mux_hw);\n}\n\nstatic int clk_periph_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct tegra_clk_periph *periph = to_clk_periph(hw);\n\tconst struct clk_ops *mux_ops = periph->mux_ops;\n\tstruct clk_hw *mux_hw = &periph->mux.hw;\n\n\t__clk_hw_set_clk(mux_hw, hw);\n\n\treturn mux_ops->set_parent(mux_hw, index);\n}\n\nstatic unsigned long clk_periph_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct tegra_clk_periph *periph = to_clk_periph(hw);\n\tconst struct clk_ops *div_ops = periph->div_ops;\n\tstruct clk_hw *div_hw = &periph->divider.hw;\n\n\t__clk_hw_set_clk(div_hw, hw);\n\n\treturn div_ops->recalc_rate(div_hw, parent_rate);\n}\n\nstatic int clk_periph_determine_rate(struct clk_hw *hw,\n\t\t\t\t     struct clk_rate_request *req)\n{\n\tstruct tegra_clk_periph *periph = to_clk_periph(hw);\n\tconst struct clk_ops *div_ops = periph->div_ops;\n\tstruct clk_hw *div_hw = &periph->divider.hw;\n\tunsigned long rate;\n\n\t__clk_hw_set_clk(div_hw, hw);\n\n\trate = div_ops->round_rate(div_hw, req->rate, &req->best_parent_rate);\n\tif (rate < 0)\n\t\treturn rate;\n\n\treq->rate = rate;\n\treturn 0;\n}\n\nstatic int clk_periph_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct tegra_clk_periph *periph = to_clk_periph(hw);\n\tconst struct clk_ops *div_ops = periph->div_ops;\n\tstruct clk_hw *div_hw = &periph->divider.hw;\n\n\t__clk_hw_set_clk(div_hw, hw);\n\n\treturn div_ops->set_rate(div_hw, rate, parent_rate);\n}\n\nstatic int clk_periph_is_enabled(struct clk_hw *hw)\n{\n\tstruct tegra_clk_periph *periph = to_clk_periph(hw);\n\tconst struct clk_ops *gate_ops = periph->gate_ops;\n\tstruct clk_hw *gate_hw = &periph->gate.hw;\n\n\t__clk_hw_set_clk(gate_hw, hw);\n\n\treturn gate_ops->is_enabled(gate_hw);\n}\n\nstatic int clk_periph_enable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_periph *periph = to_clk_periph(hw);\n\tconst struct clk_ops *gate_ops = periph->gate_ops;\n\tstruct clk_hw *gate_hw = &periph->gate.hw;\n\n\t__clk_hw_set_clk(gate_hw, hw);\n\n\treturn gate_ops->enable(gate_hw);\n}\n\nstatic void clk_periph_disable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_periph *periph = to_clk_periph(hw);\n\tconst struct clk_ops *gate_ops = periph->gate_ops;\n\tstruct clk_hw *gate_hw = &periph->gate.hw;\n\n\tgate_ops->disable(gate_hw);\n}\n\nstatic void clk_periph_disable_unused(struct clk_hw *hw)\n{\n\tstruct tegra_clk_periph *periph = to_clk_periph(hw);\n\tconst struct clk_ops *gate_ops = periph->gate_ops;\n\tstruct clk_hw *gate_hw = &periph->gate.hw;\n\n\tgate_ops->disable_unused(gate_hw);\n}\n\nstatic void clk_periph_restore_context(struct clk_hw *hw)\n{\n\tstruct tegra_clk_periph *periph = to_clk_periph(hw);\n\tconst struct clk_ops *div_ops = periph->div_ops;\n\tstruct clk_hw *div_hw = &periph->divider.hw;\n\tint parent_id;\n\n\tparent_id = clk_hw_get_parent_index(hw);\n\tif (WARN_ON(parent_id < 0))\n\t\treturn;\n\n\tif (!(periph->gate.flags & TEGRA_PERIPH_NO_DIV))\n\t\tdiv_ops->restore_context(div_hw);\n\n\tclk_periph_set_parent(hw, parent_id);\n}\n\nconst struct clk_ops tegra_clk_periph_ops = {\n\t.get_parent = clk_periph_get_parent,\n\t.set_parent = clk_periph_set_parent,\n\t.recalc_rate = clk_periph_recalc_rate,\n\t.determine_rate = clk_periph_determine_rate,\n\t.set_rate = clk_periph_set_rate,\n\t.is_enabled = clk_periph_is_enabled,\n\t.enable = clk_periph_enable,\n\t.disable = clk_periph_disable,\n\t.disable_unused = clk_periph_disable_unused,\n\t.restore_context = clk_periph_restore_context,\n};\n\nstatic const struct clk_ops tegra_clk_periph_nodiv_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.get_parent = clk_periph_get_parent,\n\t.set_parent = clk_periph_set_parent,\n\t.is_enabled = clk_periph_is_enabled,\n\t.enable = clk_periph_enable,\n\t.disable = clk_periph_disable,\n\t.disable_unused = clk_periph_disable_unused,\n\t.restore_context = clk_periph_restore_context,\n};\n\nstatic const struct clk_ops tegra_clk_periph_no_gate_ops = {\n\t.get_parent = clk_periph_get_parent,\n\t.set_parent = clk_periph_set_parent,\n\t.recalc_rate = clk_periph_recalc_rate,\n\t.determine_rate = clk_periph_determine_rate,\n\t.set_rate = clk_periph_set_rate,\n\t.restore_context = clk_periph_restore_context,\n};\n\nstatic struct clk *_tegra_clk_register_periph(const char *name,\n\t\t\tconst char * const *parent_names, int num_parents,\n\t\t\tstruct tegra_clk_periph *periph,\n\t\t\tvoid __iomem *clk_base, u32 offset,\n\t\t\tunsigned long flags)\n{\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\tconst struct tegra_clk_periph_regs *bank;\n\tbool div = !(periph->gate.flags & TEGRA_PERIPH_NO_DIV);\n\n\tif (periph->gate.flags & TEGRA_PERIPH_NO_DIV) {\n\t\tflags |= CLK_SET_RATE_PARENT;\n\t\tinit.ops = &tegra_clk_periph_nodiv_ops;\n\t} else if (periph->gate.flags & TEGRA_PERIPH_NO_GATE)\n\t\tinit.ops = &tegra_clk_periph_no_gate_ops;\n\telse\n\t\tinit.ops = &tegra_clk_periph_ops;\n\n\tinit.name = name;\n\tinit.flags = flags;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\n\tbank = get_reg_bank(periph->gate.clk_num);\n\tif (!bank)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tperiph->hw.init = &init;\n\tperiph->magic = TEGRA_CLK_PERIPH_MAGIC;\n\tperiph->mux.reg = clk_base + offset;\n\tperiph->divider.reg = div ? (clk_base + offset) : NULL;\n\tperiph->gate.clk_base = clk_base;\n\tperiph->gate.regs = bank;\n\tperiph->gate.enable_refcnt = periph_clk_enb_refcnt;\n\n\tclk = clk_register(NULL, &periph->hw);\n\tif (IS_ERR(clk))\n\t\treturn clk;\n\n\tperiph->mux.hw.clk = clk;\n\tperiph->divider.hw.clk = div ? clk : NULL;\n\tperiph->gate.hw.clk = clk;\n\n\treturn clk;\n}\n\nstruct clk *tegra_clk_register_periph(const char *name,\n\t\tconst char * const *parent_names, int num_parents,\n\t\tstruct tegra_clk_periph *periph, void __iomem *clk_base,\n\t\tu32 offset, unsigned long flags)\n{\n\treturn _tegra_clk_register_periph(name, parent_names, num_parents,\n\t\t\tperiph, clk_base, offset, flags);\n}\n\nstruct clk *tegra_clk_register_periph_nodiv(const char *name,\n\t\tconst char * const *parent_names, int num_parents,\n\t\tstruct tegra_clk_periph *periph, void __iomem *clk_base,\n\t\tu32 offset)\n{\n\tperiph->gate.flags |= TEGRA_PERIPH_NO_DIV;\n\treturn _tegra_clk_register_periph(name, parent_names, num_parents,\n\t\t\tperiph, clk_base, offset, CLK_SET_RATE_PARENT);\n}\n\nstruct clk *tegra_clk_register_periph_data(void __iomem *clk_base,\n\t\t\t\t\t   struct tegra_periph_init_data *init)\n{\n\treturn _tegra_clk_register_periph(init->name, init->p.parent_names,\n\t\t\t\t\t  init->num_parents, &init->periph,\n\t\t\t\t\t  clk_base, init->offset, init->flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}