{
  "module_name": "clk-tegra-super-cclk.c",
  "hash_id": "0466619e4ae5b5da078bc9d046b5743c3a6b0262c1ee89e8b3ebda7b9844a930",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-tegra-super-cclk.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"clk.h\"\n\n#define PLLP_INDEX\t\t4\n#define PLLX_INDEX\t\t8\n\n#define SUPER_CDIV_ENB\t\tBIT(31)\n\n#define TSENSOR_SLOWDOWN\tBIT(23)\n\nstatic struct tegra_clk_super_mux *cclk_super;\nstatic bool cclk_on_pllx;\n\nstatic u8 cclk_super_get_parent(struct clk_hw *hw)\n{\n\treturn tegra_clk_super_ops.get_parent(hw);\n}\n\nstatic int cclk_super_set_parent(struct clk_hw *hw, u8 index)\n{\n\treturn tegra_clk_super_ops.set_parent(hw, index);\n}\n\nstatic int cclk_super_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\treturn tegra_clk_super_ops.set_rate(hw, rate, parent_rate);\n}\n\nstatic unsigned long cclk_super_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct tegra_clk_super_mux *super = to_clk_super_mux(hw);\n\tu32 val = readl_relaxed(super->reg);\n\tunsigned int div2;\n\n\t \n\tif (val & TSENSOR_SLOWDOWN)\n\t\tdiv2 = 1;\n\telse\n\t\tdiv2 = 0;\n\n\tif (cclk_super_get_parent(hw) == PLLX_INDEX)\n\t\treturn parent_rate >> div2;\n\n\treturn tegra_clk_super_ops.recalc_rate(hw, parent_rate) >> div2;\n}\n\nstatic int cclk_super_determine_rate(struct clk_hw *hw,\n\t\t\t\t     struct clk_rate_request *req)\n{\n\tstruct clk_hw *pllp_hw = clk_hw_get_parent_by_index(hw, PLLP_INDEX);\n\tstruct clk_hw *pllx_hw = clk_hw_get_parent_by_index(hw, PLLX_INDEX);\n\tstruct tegra_clk_super_mux *super = to_clk_super_mux(hw);\n\tunsigned long pllp_rate;\n\tlong rate = req->rate;\n\n\tif (WARN_ON_ONCE(!pllp_hw || !pllx_hw))\n\t\treturn -EINVAL;\n\n\t \n\tpllp_rate = clk_hw_get_rate(pllp_hw);\n\n\tif (rate <= pllp_rate) {\n\t\tif (super->flags & TEGRA20_SUPER_CLK)\n\t\t\trate = pllp_rate;\n\t\telse {\n\t\t\tstruct clk_rate_request parent = {\n\t\t\t\t.rate = req->rate,\n\t\t\t\t.best_parent_rate = pllp_rate,\n\t\t\t};\n\n\t\t\tclk_hw_get_rate_range(hw, &parent.min_rate,\n\t\t\t\t\t      &parent.max_rate);\n\t\t\ttegra_clk_super_ops.determine_rate(hw, &parent);\n\t\t\tpllp_rate = parent.best_parent_rate;\n\t\t\trate = parent.rate;\n\t\t}\n\n\t\treq->best_parent_rate = pllp_rate;\n\t\treq->best_parent_hw = pllp_hw;\n\t\treq->rate = rate;\n\t} else {\n\t\trate = clk_hw_round_rate(pllx_hw, rate);\n\t\treq->best_parent_rate = rate;\n\t\treq->best_parent_hw = pllx_hw;\n\t\treq->rate = rate;\n\t}\n\n\tif (WARN_ON_ONCE(rate <= 0))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops tegra_cclk_super_ops = {\n\t.get_parent = cclk_super_get_parent,\n\t.set_parent = cclk_super_set_parent,\n\t.set_rate = cclk_super_set_rate,\n\t.recalc_rate = cclk_super_recalc_rate,\n\t.determine_rate = cclk_super_determine_rate,\n};\n\nstatic const struct clk_ops tegra_cclk_super_mux_ops = {\n\t.get_parent = cclk_super_get_parent,\n\t.set_parent = cclk_super_set_parent,\n\t.determine_rate = cclk_super_determine_rate,\n};\n\nstruct clk *tegra_clk_register_super_cclk(const char *name,\n\t\tconst char * const *parent_names, u8 num_parents,\n\t\tunsigned long flags, void __iomem *reg, u8 clk_super_flags,\n\t\tspinlock_t *lock)\n{\n\tstruct tegra_clk_super_mux *super;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\tu32 val;\n\n\tif (WARN_ON(cclk_super))\n\t\treturn ERR_PTR(-EBUSY);\n\n\tsuper = kzalloc(sizeof(*super), GFP_KERNEL);\n\tif (!super)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.flags = flags;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\n\tsuper->reg = reg;\n\tsuper->lock = lock;\n\tsuper->width = 4;\n\tsuper->flags = clk_super_flags;\n\tsuper->hw.init = &init;\n\n\tif (super->flags & TEGRA20_SUPER_CLK) {\n\t\tinit.ops = &tegra_cclk_super_mux_ops;\n\t} else {\n\t\tinit.ops = &tegra_cclk_super_ops;\n\n\t\tsuper->frac_div.reg = reg + 4;\n\t\tsuper->frac_div.shift = 16;\n\t\tsuper->frac_div.width = 8;\n\t\tsuper->frac_div.frac_width = 1;\n\t\tsuper->frac_div.lock = lock;\n\t\tsuper->div_ops = &tegra_clk_frac_div_ops;\n\t}\n\n\t \n\tval = readl_relaxed(reg + 4);\n\tval &= ~SUPER_CDIV_ENB;\n\twritel_relaxed(val, reg + 4);\n\n\tclk = clk_register(NULL, &super->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(super);\n\telse\n\t\tcclk_super = super;\n\n\treturn clk;\n}\n\nint tegra_cclk_pre_pllx_rate_change(void)\n{\n\tif (IS_ERR_OR_NULL(cclk_super))\n\t\treturn -EINVAL;\n\n\tif (cclk_super_get_parent(&cclk_super->hw) == PLLX_INDEX)\n\t\tcclk_on_pllx = true;\n\telse\n\t\tcclk_on_pllx = false;\n\n\t \n\tif (cclk_on_pllx)\n\t\tcclk_super_set_parent(&cclk_super->hw, PLLP_INDEX);\n\n\treturn 0;\n}\n\nvoid tegra_cclk_post_pllx_rate_change(void)\n{\n\tif (cclk_on_pllx)\n\t\tcclk_super_set_parent(&cclk_super->hw, PLLX_INDEX);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}