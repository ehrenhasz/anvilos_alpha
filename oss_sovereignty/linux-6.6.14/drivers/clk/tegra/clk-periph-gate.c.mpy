{
  "module_name": "clk-periph-gate.c",
  "hash_id": "98fa7b1dfde0480a6fac46e55a2b675421865252353e959e436c3a2966b6e174",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-periph-gate.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n\n#include <soc/tegra/fuse.h>\n\n#include \"clk.h\"\n\nstatic DEFINE_SPINLOCK(periph_ref_lock);\n\n \n#define read_enb(gate) \\\n\treadl_relaxed(gate->clk_base + (gate->regs->enb_reg))\n#define write_enb_set(val, gate) \\\n\twritel_relaxed(val, gate->clk_base + (gate->regs->enb_set_reg))\n#define write_enb_clr(val, gate) \\\n\twritel_relaxed(val, gate->clk_base + (gate->regs->enb_clr_reg))\n\n#define read_rst(gate) \\\n\treadl_relaxed(gate->clk_base + (gate->regs->rst_reg))\n#define write_rst_clr(val, gate) \\\n\twritel_relaxed(val, gate->clk_base + (gate->regs->rst_clr_reg))\n\n#define periph_clk_to_bit(gate) (1 << (gate->clk_num % 32))\n\n#define LVL2_CLK_GATE_OVRE 0x554\n\n \nstatic int clk_periph_is_enabled(struct clk_hw *hw)\n{\n\tstruct tegra_clk_periph_gate *gate = to_clk_periph_gate(hw);\n\tint state = 1;\n\n\tif (!(read_enb(gate) & periph_clk_to_bit(gate)))\n\t\tstate = 0;\n\n\tif (!(gate->flags & TEGRA_PERIPH_NO_RESET))\n\t\tif (read_rst(gate) & periph_clk_to_bit(gate))\n\t\t\tstate = 0;\n\n\treturn state;\n}\n\nstatic void clk_periph_enable_locked(struct clk_hw *hw)\n{\n\tstruct tegra_clk_periph_gate *gate = to_clk_periph_gate(hw);\n\n\twrite_enb_set(periph_clk_to_bit(gate), gate);\n\tudelay(2);\n\n\tif (gate->flags & TEGRA_PERIPH_WAR_1005168) {\n\t\twritel_relaxed(0, gate->clk_base + LVL2_CLK_GATE_OVRE);\n\t\twritel_relaxed(BIT(22), gate->clk_base + LVL2_CLK_GATE_OVRE);\n\t\tudelay(1);\n\t\twritel_relaxed(0, gate->clk_base + LVL2_CLK_GATE_OVRE);\n\t}\n}\n\nstatic void clk_periph_disable_locked(struct clk_hw *hw)\n{\n\tstruct tegra_clk_periph_gate *gate = to_clk_periph_gate(hw);\n\n\t \n\tif (gate->flags & TEGRA_PERIPH_ON_APB)\n\t\ttegra_read_chipid();\n\n\twrite_enb_clr(periph_clk_to_bit(gate), gate);\n}\n\nstatic int clk_periph_enable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_periph_gate *gate = to_clk_periph_gate(hw);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&periph_ref_lock, flags);\n\n\tif (!gate->enable_refcnt[gate->clk_num]++)\n\t\tclk_periph_enable_locked(hw);\n\n\tspin_unlock_irqrestore(&periph_ref_lock, flags);\n\n\treturn 0;\n}\n\nstatic void clk_periph_disable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_periph_gate *gate = to_clk_periph_gate(hw);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&periph_ref_lock, flags);\n\n\tWARN_ON(!gate->enable_refcnt[gate->clk_num]);\n\n\tif (--gate->enable_refcnt[gate->clk_num] == 0)\n\t\tclk_periph_disable_locked(hw);\n\n\tspin_unlock_irqrestore(&periph_ref_lock, flags);\n}\n\nstatic void clk_periph_disable_unused(struct clk_hw *hw)\n{\n\tstruct tegra_clk_periph_gate *gate = to_clk_periph_gate(hw);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&periph_ref_lock, flags);\n\n\t \n\tif (!gate->enable_refcnt[gate->clk_num])\n\t\tclk_periph_disable_locked(hw);\n\n\tspin_unlock_irqrestore(&periph_ref_lock, flags);\n}\n\nconst struct clk_ops tegra_clk_periph_gate_ops = {\n\t.is_enabled = clk_periph_is_enabled,\n\t.enable = clk_periph_enable,\n\t.disable = clk_periph_disable,\n\t.disable_unused = clk_periph_disable_unused,\n};\n\nstruct clk *tegra_clk_register_periph_gate(const char *name,\n\t\tconst char *parent_name, u8 gate_flags, void __iomem *clk_base,\n\t\tunsigned long flags, int clk_num, int *enable_refcnt)\n{\n\tstruct tegra_clk_periph_gate *gate;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\tconst struct tegra_clk_periph_regs *pregs;\n\n\tpregs = get_reg_bank(clk_num);\n\tif (!pregs)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate) {\n\t\tpr_err(\"%s: could not allocate periph gate clk\\n\", __func__);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinit.name = name;\n\tinit.flags = flags;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\tinit.ops = &tegra_clk_periph_gate_ops;\n\n\tgate->magic = TEGRA_CLK_PERIPH_GATE_MAGIC;\n\tgate->clk_base = clk_base;\n\tgate->clk_num = clk_num;\n\tgate->flags = gate_flags;\n\tgate->enable_refcnt = enable_refcnt;\n\tgate->regs = pregs;\n\n\t \n\tgate->hw.init = &init;\n\n\tclk = clk_register(NULL, &gate->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(gate);\n\n\treturn clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}