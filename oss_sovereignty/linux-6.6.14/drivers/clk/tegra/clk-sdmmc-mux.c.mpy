{
  "module_name": "clk-sdmmc-mux.c",
  "hash_id": "93f43a584c4f409210de2af357c373f7b73d9422bf1427efb066f9429da07cb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-sdmmc-mux.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/types.h>\n\n#include \"clk.h\"\n\n#define DIV_MASK GENMASK(7, 0)\n#define MUX_SHIFT 29\n#define MUX_MASK GENMASK(MUX_SHIFT + 2, MUX_SHIFT)\n#define SDMMC_MUL 2\n\n#define get_max_div(d) DIV_MASK\n#define get_div_field(val) ((val) & DIV_MASK)\n#define get_mux_field(val) (((val) & MUX_MASK) >> MUX_SHIFT)\n\nstatic const char * const mux_sdmmc_parents[] = {\n\t\"pll_p\", \"pll_c4_out2\", \"pll_c4_out0\", \"pll_c4_out1\", \"clk_m\"\n};\n\nstatic const u8 mux_lj_idx[] = {\n\t[0] = 0, [1] = 1, [2] = 2, [3] = 5, [4] = 6\n};\n\nstatic const u8 mux_non_lj_idx[] = {\n\t[0] = 0, [1] = 3, [2] = 7, [3] = 4, [4] = 6\n};\n\nstatic u8 clk_sdmmc_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct tegra_sdmmc_mux *sdmmc_mux = to_clk_sdmmc_mux(hw);\n\tint num_parents, i;\n\tu32 src, val;\n\tconst u8 *mux_idx;\n\n\tnum_parents = clk_hw_get_num_parents(hw);\n\n\tval = readl_relaxed(sdmmc_mux->reg);\n\tsrc = get_mux_field(val);\n\tif (get_div_field(val))\n\t\tmux_idx = mux_non_lj_idx;\n\telse\n\t\tmux_idx = mux_lj_idx;\n\n\tfor (i = 0; i < num_parents; i++) {\n\t\tif (mux_idx[i] == src)\n\t\t\treturn i;\n\t}\n\n\tWARN(1, \"Unknown parent selector %d\\n\", src);\n\n\treturn 0;\n}\n\nstatic int clk_sdmmc_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct tegra_sdmmc_mux *sdmmc_mux = to_clk_sdmmc_mux(hw);\n\tu32 val;\n\n\n\tval = readl_relaxed(sdmmc_mux->reg);\n\tif (get_div_field(val))\n\t\tindex = mux_non_lj_idx[index];\n\telse\n\t\tindex = mux_lj_idx[index];\n\n\tval &= ~MUX_MASK;\n\tval |= index << MUX_SHIFT;\n\n\twritel(val, sdmmc_mux->reg);\n\n\treturn 0;\n}\n\nstatic unsigned long clk_sdmmc_mux_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct tegra_sdmmc_mux *sdmmc_mux = to_clk_sdmmc_mux(hw);\n\tu32 val;\n\tint div;\n\tu64 rate = parent_rate;\n\n\tval = readl_relaxed(sdmmc_mux->reg);\n\tdiv = get_div_field(val);\n\n\tdiv += SDMMC_MUL;\n\n\trate *= SDMMC_MUL;\n\trate += div - 1;\n\tdo_div(rate, div);\n\n\treturn rate;\n}\n\nstatic int clk_sdmmc_mux_determine_rate(struct clk_hw *hw,\n\t\t\t\t\tstruct clk_rate_request *req)\n{\n\tstruct tegra_sdmmc_mux *sdmmc_mux = to_clk_sdmmc_mux(hw);\n\tint div;\n\tunsigned long output_rate = req->best_parent_rate;\n\n\treq->rate = max(req->rate, req->min_rate);\n\treq->rate = min(req->rate, req->max_rate);\n\n\tif (!req->rate)\n\t\treturn output_rate;\n\n\tdiv = div_frac_get(req->rate, output_rate, 8, 1, sdmmc_mux->div_flags);\n\tif (div < 0)\n\t\tdiv = 0;\n\n\tif (sdmmc_mux->div_flags & TEGRA_DIVIDER_ROUND_UP)\n\t\treq->rate =  DIV_ROUND_UP(output_rate * SDMMC_MUL,\n\t\t\t\t\t  div + SDMMC_MUL);\n\telse\n\t\treq->rate =  output_rate * SDMMC_MUL / (div + SDMMC_MUL);\n\n\treturn 0;\n}\n\nstatic int clk_sdmmc_mux_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct tegra_sdmmc_mux *sdmmc_mux = to_clk_sdmmc_mux(hw);\n\tint div;\n\tunsigned long flags = 0;\n\tu32 val;\n\tu8 src;\n\n\tdiv = div_frac_get(rate, parent_rate, 8, 1, sdmmc_mux->div_flags);\n\tif (div < 0)\n\t\treturn div;\n\n\tif (sdmmc_mux->lock)\n\t\tspin_lock_irqsave(sdmmc_mux->lock, flags);\n\n\tsrc = clk_sdmmc_mux_get_parent(hw);\n\tif (div)\n\t\tsrc = mux_non_lj_idx[src];\n\telse\n\t\tsrc = mux_lj_idx[src];\n\n\tval = src << MUX_SHIFT;\n\tval |= div;\n\twritel(val, sdmmc_mux->reg);\n\tfence_udelay(2, sdmmc_mux->reg);\n\n\tif (sdmmc_mux->lock)\n\t\tspin_unlock_irqrestore(sdmmc_mux->lock, flags);\n\n\treturn 0;\n}\n\nstatic int clk_sdmmc_mux_is_enabled(struct clk_hw *hw)\n{\n\tstruct tegra_sdmmc_mux *sdmmc_mux = to_clk_sdmmc_mux(hw);\n\tconst struct clk_ops *gate_ops = sdmmc_mux->gate_ops;\n\tstruct clk_hw *gate_hw = &sdmmc_mux->gate.hw;\n\n\t__clk_hw_set_clk(gate_hw, hw);\n\n\treturn gate_ops->is_enabled(gate_hw);\n}\n\nstatic int clk_sdmmc_mux_enable(struct clk_hw *hw)\n{\n\tstruct tegra_sdmmc_mux *sdmmc_mux = to_clk_sdmmc_mux(hw);\n\tconst struct clk_ops *gate_ops = sdmmc_mux->gate_ops;\n\tstruct clk_hw *gate_hw = &sdmmc_mux->gate.hw;\n\n\t__clk_hw_set_clk(gate_hw, hw);\n\n\treturn gate_ops->enable(gate_hw);\n}\n\nstatic void clk_sdmmc_mux_disable(struct clk_hw *hw)\n{\n\tstruct tegra_sdmmc_mux *sdmmc_mux = to_clk_sdmmc_mux(hw);\n\tconst struct clk_ops *gate_ops = sdmmc_mux->gate_ops;\n\tstruct clk_hw *gate_hw = &sdmmc_mux->gate.hw;\n\n\tgate_ops->disable(gate_hw);\n}\n\nstatic void clk_sdmmc_mux_disable_unused(struct clk_hw *hw)\n{\n\tstruct tegra_sdmmc_mux *sdmmc_mux = to_clk_sdmmc_mux(hw);\n\tconst struct clk_ops *gate_ops = sdmmc_mux->gate_ops;\n\tstruct clk_hw *gate_hw = &sdmmc_mux->gate.hw;\n\n\tgate_ops->disable_unused(gate_hw);\n}\n\nstatic void clk_sdmmc_mux_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_hw *parent = clk_hw_get_parent(hw);\n\tunsigned long parent_rate = clk_hw_get_rate(parent);\n\tunsigned long rate = clk_hw_get_rate(hw);\n\tint parent_id;\n\n\tparent_id = clk_hw_get_parent_index(hw);\n\tif (WARN_ON(parent_id < 0))\n\t\treturn;\n\n\tclk_sdmmc_mux_set_parent(hw, parent_id);\n\tclk_sdmmc_mux_set_rate(hw, rate, parent_rate);\n}\n\nstatic const struct clk_ops tegra_clk_sdmmc_mux_ops = {\n\t.get_parent = clk_sdmmc_mux_get_parent,\n\t.set_parent = clk_sdmmc_mux_set_parent,\n\t.determine_rate = clk_sdmmc_mux_determine_rate,\n\t.recalc_rate = clk_sdmmc_mux_recalc_rate,\n\t.set_rate = clk_sdmmc_mux_set_rate,\n\t.is_enabled = clk_sdmmc_mux_is_enabled,\n\t.enable = clk_sdmmc_mux_enable,\n\t.disable = clk_sdmmc_mux_disable,\n\t.disable_unused = clk_sdmmc_mux_disable_unused,\n\t.restore_context = clk_sdmmc_mux_restore_context,\n};\n\nstruct clk *tegra_clk_register_sdmmc_mux_div(const char *name,\n\tvoid __iomem *clk_base, u32 offset, u32 clk_num, u8 div_flags,\n\tunsigned long flags, void *lock)\n{\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\tconst struct tegra_clk_periph_regs *bank;\n\tstruct tegra_sdmmc_mux *sdmmc_mux;\n\n\tinit.ops = &tegra_clk_sdmmc_mux_ops;\n\tinit.name = name;\n\tinit.flags = flags;\n\tinit.parent_names = mux_sdmmc_parents;\n\tinit.num_parents = ARRAY_SIZE(mux_sdmmc_parents);\n\n\tbank = get_reg_bank(clk_num);\n\tif (!bank)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsdmmc_mux = kzalloc(sizeof(*sdmmc_mux), GFP_KERNEL);\n\tif (!sdmmc_mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tsdmmc_mux->hw.init = &init;\n\tsdmmc_mux->reg = clk_base + offset;\n\tsdmmc_mux->lock = lock;\n\tsdmmc_mux->gate.clk_base = clk_base;\n\tsdmmc_mux->gate.regs = bank;\n\tsdmmc_mux->gate.enable_refcnt = periph_clk_enb_refcnt;\n\tsdmmc_mux->gate.clk_num = clk_num;\n\tsdmmc_mux->gate.flags = TEGRA_PERIPH_ON_APB;\n\tsdmmc_mux->div_flags = div_flags;\n\tsdmmc_mux->gate_ops = &tegra_clk_periph_gate_ops;\n\n\tclk = clk_register(NULL, &sdmmc_mux->hw);\n\tif (IS_ERR(clk)) {\n\t\tkfree(sdmmc_mux);\n\t\treturn clk;\n\t}\n\n\tsdmmc_mux->gate.hw.clk = clk;\n\n\treturn clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}