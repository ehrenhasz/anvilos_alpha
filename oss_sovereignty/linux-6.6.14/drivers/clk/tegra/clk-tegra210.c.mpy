{
  "module_name": "clk-tegra210.c",
  "hash_id": "d6b2758680b561cb716480f2850184105fba669c83484ef3d47be435617cbf29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-tegra210.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/syscore_ops.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/clk/tegra.h>\n#include <dt-bindings/clock/tegra210-car.h>\n#include <dt-bindings/reset/tegra210-car.h>\n#include <linux/sizes.h>\n#include <soc/tegra/pmc.h>\n\n#include \"clk.h\"\n#include \"clk-id.h\"\n\n \n#define TEGRA210_CAR_BANK_COUNT\t\t\t7\n\n#define CLK_SOURCE_CSITE 0x1d4\n#define CLK_SOURCE_EMC 0x19c\n#define CLK_SOURCE_SOR1 0x410\n#define CLK_SOURCE_SOR0 0x414\n#define CLK_SOURCE_LA 0x1f8\n#define CLK_SOURCE_SDMMC2 0x154\n#define CLK_SOURCE_SDMMC4 0x164\n#define CLK_SOURCE_EMC_DLL 0x664\n\n#define PLLC_BASE 0x80\n#define PLLC_OUT 0x84\n#define PLLC_MISC0 0x88\n#define PLLC_MISC1 0x8c\n#define PLLC_MISC2 0x5d0\n#define PLLC_MISC3 0x5d4\n\n#define PLLC2_BASE 0x4e8\n#define PLLC2_MISC0 0x4ec\n#define PLLC2_MISC1 0x4f0\n#define PLLC2_MISC2 0x4f4\n#define PLLC2_MISC3 0x4f8\n\n#define PLLC3_BASE 0x4fc\n#define PLLC3_MISC0 0x500\n#define PLLC3_MISC1 0x504\n#define PLLC3_MISC2 0x508\n#define PLLC3_MISC3 0x50c\n\n#define PLLM_BASE 0x90\n#define PLLM_MISC1 0x98\n#define PLLM_MISC2 0x9c\n#define PLLP_BASE 0xa0\n#define PLLP_MISC0 0xac\n#define PLLP_MISC1 0x680\n#define PLLA_BASE 0xb0\n#define PLLA_MISC0 0xbc\n#define PLLA_MISC1 0xb8\n#define PLLA_MISC2 0x5d8\n#define PLLD_BASE 0xd0\n#define PLLD_MISC0 0xdc\n#define PLLD_MISC1 0xd8\n#define PLLU_BASE 0xc0\n#define PLLU_OUTA 0xc4\n#define PLLU_MISC0 0xcc\n#define PLLU_MISC1 0xc8\n#define PLLX_BASE 0xe0\n#define PLLX_MISC0 0xe4\n#define PLLX_MISC1 0x510\n#define PLLX_MISC2 0x514\n#define PLLX_MISC3 0x518\n#define PLLX_MISC4 0x5f0\n#define PLLX_MISC5 0x5f4\n#define PLLE_BASE 0xe8\n#define PLLE_MISC0 0xec\n#define PLLD2_BASE 0x4b8\n#define PLLD2_MISC0 0x4bc\n#define PLLD2_MISC1 0x570\n#define PLLD2_MISC2 0x574\n#define PLLD2_MISC3 0x578\n#define PLLE_AUX 0x48c\n#define PLLRE_BASE 0x4c4\n#define PLLRE_MISC0 0x4c8\n#define PLLRE_OUT1 0x4cc\n#define PLLDP_BASE 0x590\n#define PLLDP_MISC 0x594\n\n#define PLLC4_BASE 0x5a4\n#define PLLC4_MISC0 0x5a8\n#define PLLC4_OUT 0x5e4\n#define PLLMB_BASE 0x5e8\n#define PLLMB_MISC1 0x5ec\n#define PLLA1_BASE 0x6a4\n#define PLLA1_MISC0 0x6a8\n#define PLLA1_MISC1 0x6ac\n#define PLLA1_MISC2 0x6b0\n#define PLLA1_MISC3 0x6b4\n\n#define PLLU_IDDQ_BIT 31\n#define PLLCX_IDDQ_BIT 27\n#define PLLRE_IDDQ_BIT 24\n#define PLLA_IDDQ_BIT 25\n#define PLLD_IDDQ_BIT 20\n#define PLLSS_IDDQ_BIT 18\n#define PLLM_IDDQ_BIT 5\n#define PLLMB_IDDQ_BIT 17\n#define PLLXP_IDDQ_BIT 3\n\n#define PLLCX_RESET_BIT 30\n\n#define PLL_BASE_LOCK BIT(27)\n#define PLLCX_BASE_LOCK BIT(26)\n#define PLLE_MISC_LOCK BIT(11)\n#define PLLRE_MISC_LOCK BIT(27)\n\n#define PLL_MISC_LOCK_ENABLE 18\n#define PLLC_MISC_LOCK_ENABLE 24\n#define PLLDU_MISC_LOCK_ENABLE 22\n#define PLLU_MISC_LOCK_ENABLE 29\n#define PLLE_MISC_LOCK_ENABLE 9\n#define PLLRE_MISC_LOCK_ENABLE 30\n#define PLLSS_MISC_LOCK_ENABLE 30\n#define PLLP_MISC_LOCK_ENABLE 18\n#define PLLM_MISC_LOCK_ENABLE 4\n#define PLLMB_MISC_LOCK_ENABLE 16\n#define PLLA_MISC_LOCK_ENABLE 28\n#define PLLU_MISC_LOCK_ENABLE 29\n#define PLLD_MISC_LOCK_ENABLE 18\n\n#define PLLA_SDM_DIN_MASK 0xffff\n#define PLLA_SDM_EN_MASK BIT(26)\n\n#define PLLD_SDM_EN_MASK BIT(16)\n\n#define PLLD2_SDM_EN_MASK BIT(31)\n#define PLLD2_SSC_EN_MASK 0\n\n#define PLLDP_SS_CFG\t0x598\n#define PLLDP_SDM_EN_MASK BIT(31)\n#define PLLDP_SSC_EN_MASK BIT(30)\n#define PLLDP_SS_CTRL1\t0x59c\n#define PLLDP_SS_CTRL2\t0x5a0\n\n#define PMC_PLLM_WB0_OVERRIDE 0x1dc\n#define PMC_PLLM_WB0_OVERRIDE_2 0x2b0\n\n#define UTMIP_PLL_CFG2 0x488\n#define UTMIP_PLL_CFG2_STABLE_COUNT(x) (((x) & 0xfff) << 6)\n#define UTMIP_PLL_CFG2_ACTIVE_DLY_COUNT(x) (((x) & 0x3f) << 18)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_A_POWERDOWN BIT(0)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_A_POWERUP BIT(1)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_B_POWERDOWN BIT(2)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_B_POWERUP BIT(3)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_C_POWERDOWN BIT(4)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_C_POWERUP BIT(5)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_D_POWERDOWN BIT(24)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_D_POWERUP BIT(25)\n\n#define UTMIP_PLL_CFG1 0x484\n#define UTMIP_PLL_CFG1_ENABLE_DLY_COUNT(x) (((x) & 0x1f) << 27)\n#define UTMIP_PLL_CFG1_XTAL_FREQ_COUNT(x) (((x) & 0xfff) << 0)\n#define UTMIP_PLL_CFG1_FORCE_PLLU_POWERUP BIT(17)\n#define UTMIP_PLL_CFG1_FORCE_PLLU_POWERDOWN BIT(16)\n#define UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERUP BIT(15)\n#define UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERDOWN BIT(14)\n#define UTMIP_PLL_CFG1_FORCE_PLL_ACTIVE_POWERDOWN BIT(12)\n\n#define SATA_PLL_CFG0\t\t\t\t0x490\n#define SATA_PLL_CFG0_PADPLL_RESET_SWCTL\tBIT(0)\n#define SATA_PLL_CFG0_PADPLL_USE_LOCKDET\tBIT(2)\n#define SATA_PLL_CFG0_SATA_SEQ_IN_SWCTL\t\tBIT(4)\n#define SATA_PLL_CFG0_SATA_SEQ_RESET_INPUT_VALUE\tBIT(5)\n#define SATA_PLL_CFG0_SATA_SEQ_LANE_PD_INPUT_VALUE\tBIT(6)\n#define SATA_PLL_CFG0_SATA_SEQ_PADPLL_PD_INPUT_VALUE\tBIT(7)\n\n#define SATA_PLL_CFG0_PADPLL_SLEEP_IDDQ\t\tBIT(13)\n#define SATA_PLL_CFG0_SEQ_ENABLE\t\tBIT(24)\n\n#define XUSBIO_PLL_CFG0\t\t\t\t0x51c\n#define XUSBIO_PLL_CFG0_PADPLL_RESET_SWCTL\tBIT(0)\n#define XUSBIO_PLL_CFG0_CLK_ENABLE_SWCTL\tBIT(2)\n#define XUSBIO_PLL_CFG0_PADPLL_USE_LOCKDET\tBIT(6)\n#define XUSBIO_PLL_CFG0_PADPLL_SLEEP_IDDQ\tBIT(13)\n#define XUSBIO_PLL_CFG0_SEQ_ENABLE\t\tBIT(24)\n\n#define UTMIPLL_HW_PWRDN_CFG0\t\t\t0x52c\n#define UTMIPLL_HW_PWRDN_CFG0_UTMIPLL_LOCK\tBIT(31)\n#define UTMIPLL_HW_PWRDN_CFG0_SEQ_START_STATE\tBIT(25)\n#define UTMIPLL_HW_PWRDN_CFG0_SEQ_ENABLE\tBIT(24)\n#define UTMIPLL_HW_PWRDN_CFG0_IDDQ_PD_INCLUDE\tBIT(7)\n#define UTMIPLL_HW_PWRDN_CFG0_USE_LOCKDET\tBIT(6)\n#define UTMIPLL_HW_PWRDN_CFG0_SEQ_RESET_INPUT_VALUE\tBIT(5)\n#define UTMIPLL_HW_PWRDN_CFG0_SEQ_IN_SWCTL\tBIT(4)\n#define UTMIPLL_HW_PWRDN_CFG0_CLK_ENABLE_SWCTL\tBIT(2)\n#define UTMIPLL_HW_PWRDN_CFG0_IDDQ_OVERRIDE\tBIT(1)\n#define UTMIPLL_HW_PWRDN_CFG0_IDDQ_SWCTL\tBIT(0)\n\n#define PLLU_HW_PWRDN_CFG0\t\t\t0x530\n#define PLLU_HW_PWRDN_CFG0_IDDQ_PD_INCLUDE\tBIT(28)\n#define PLLU_HW_PWRDN_CFG0_SEQ_ENABLE\t\tBIT(24)\n#define PLLU_HW_PWRDN_CFG0_USE_SWITCH_DETECT\tBIT(7)\n#define PLLU_HW_PWRDN_CFG0_USE_LOCKDET\t\tBIT(6)\n#define PLLU_HW_PWRDN_CFG0_CLK_ENABLE_SWCTL\tBIT(2)\n#define PLLU_HW_PWRDN_CFG0_CLK_SWITCH_SWCTL\tBIT(0)\n\n#define XUSB_PLL_CFG0\t\t\t\t0x534\n#define XUSB_PLL_CFG0_UTMIPLL_LOCK_DLY\t\t0x3ff\n#define XUSB_PLL_CFG0_PLLU_LOCK_DLY_MASK\t(0x3ff << 14)\n\n#define SPARE_REG0 0x55c\n#define CLK_M_DIVISOR_SHIFT 2\n#define CLK_M_DIVISOR_MASK 0x3\n\n#define CLK_MASK_ARM\t0x44\n#define MISC_CLK_ENB\t0x48\n\n#define RST_DFLL_DVCO 0x2f4\n#define DVFS_DFLL_RESET_SHIFT 0\n\n#define CLK_RST_CONTROLLER_CLK_OUT_ENB_X_SET\t0x284\n#define CLK_RST_CONTROLLER_CLK_OUT_ENB_X_CLR\t0x288\n#define CLK_OUT_ENB_X_CLK_ENB_EMC_DLL\t\tBIT(14)\n\n#define CLK_RST_CONTROLLER_RST_DEV_Y_SET 0x2a8\n#define CLK_RST_CONTROLLER_RST_DEV_Y_CLR 0x2ac\n#define CPU_SOFTRST_CTRL 0x380\n\n#define LVL2_CLK_GATE_OVRA 0xf8\n#define LVL2_CLK_GATE_OVRC 0x3a0\n#define LVL2_CLK_GATE_OVRD 0x3a4\n#define LVL2_CLK_GATE_OVRE 0x554\n\n \n#define TEGRA210_I2S_BASE  0x1000\n#define TEGRA210_I2S_SIZE  0x100\n#define TEGRA210_I2S_CTRLS 5\n#define TEGRA210_I2S_CG    0x88\n#define TEGRA210_I2S_CTRL  0xa0\n\n \n#define DC_CMD_DISPLAY_COMMAND 0xc8\n#define DC_COM_DSC_TOP_CTL 0xcf8\n\n \n#define NV_PVIC_THI_SLCG_OVERRIDE_LOW 0x8c\n\n \n#define TEGRA210_AHUB_BASE  0x702d0000\n#define TEGRA210_DISPA_BASE 0x54200000\n#define TEGRA210_VIC_BASE  0x54340000\n\n \n#define PLL_SDM_COEFF BIT(13)\n#define sdin_din_to_data(din)\t((u16)((din) ? : 0xFFFFU))\n#define sdin_data_to_din(dat)\t(((dat) == 0xFFFFU) ? 0 : (s16)dat)\n \n#define sdin_get_n_eff(cfg)\t((cfg)->n * PLL_SDM_COEFF + ((cfg)->sdm_data ? \\\n\t\t(PLL_SDM_COEFF/2 + sdin_data_to_din((cfg)->sdm_data)) : 0))\n\n \n#define CLK_RST_CONTROLLER_CPU_CMPLX_STATUS\t0x470\n\n#ifdef CONFIG_PM_SLEEP\nstatic struct cpu_clk_suspend_context {\n\tu32 clk_csite_src;\n} tegra210_cpu_clk_sctx;\n#endif\n\nstruct tegra210_domain_mbist_war {\n\tvoid (*handle_lvl2_ovr)(struct tegra210_domain_mbist_war *mbist);\n\tconst u32 lvl2_offset;\n\tconst u32 lvl2_mask;\n\tconst unsigned int num_clks;\n\tconst unsigned int *clk_init_data;\n\tstruct clk_bulk_data *clks;\n};\n\nstatic struct clk **clks;\n\nstatic void __iomem *clk_base;\nstatic void __iomem *pmc_base;\nstatic void __iomem *ahub_base;\nstatic void __iomem *dispa_base;\nstatic void __iomem *vic_base;\n\nstatic unsigned long osc_freq;\nstatic unsigned long pll_ref_freq;\n\nstatic DEFINE_SPINLOCK(pll_d_lock);\nstatic DEFINE_SPINLOCK(pll_e_lock);\nstatic DEFINE_SPINLOCK(pll_re_lock);\nstatic DEFINE_SPINLOCK(pll_u_lock);\nstatic DEFINE_SPINLOCK(sor0_lock);\nstatic DEFINE_SPINLOCK(sor1_lock);\nstatic DEFINE_SPINLOCK(emc_lock);\nstatic DEFINE_MUTEX(lvl2_ovr_lock);\n\n \nstatic unsigned long tegra210_input_freq[] = {\n\t[5] = 38400000,\n\t[8] = 12000000,\n};\n\n#define PLL_ENABLE\t\t\t(1 << 30)\n\n#define PLLCX_MISC1_IDDQ\t\t(1 << 27)\n#define PLLCX_MISC0_RESET\t\t(1 << 30)\n\n#define PLLCX_MISC0_DEFAULT_VALUE\t0x40080000\n#define PLLCX_MISC0_WRITE_MASK\t\t0x400ffffb\n#define PLLCX_MISC1_DEFAULT_VALUE\t0x08000000\n#define PLLCX_MISC1_WRITE_MASK\t\t0x08003cff\n#define PLLCX_MISC2_DEFAULT_VALUE\t0x1f720f05\n#define PLLCX_MISC2_WRITE_MASK\t\t0xffffff17\n#define PLLCX_MISC3_DEFAULT_VALUE\t0x000000c4\n#define PLLCX_MISC3_WRITE_MASK\t\t0x00ffffff\n\n \n#define PLLA_BASE_IDDQ\t\t\t(1 << 25)\n#define PLLA_BASE_LOCK\t\t\t(1 << 27)\n\n#define PLLA_MISC0_LOCK_ENABLE\t\t(1 << 28)\n#define PLLA_MISC0_LOCK_OVERRIDE\t(1 << 27)\n\n#define PLLA_MISC2_EN_SDM\t\t(1 << 26)\n#define PLLA_MISC2_EN_DYNRAMP\t\t(1 << 25)\n\n#define PLLA_MISC0_DEFAULT_VALUE\t0x12000020\n#define PLLA_MISC0_WRITE_MASK\t\t0x7fffffff\n#define PLLA_MISC2_DEFAULT_VALUE\t0x0\n#define PLLA_MISC2_WRITE_MASK\t\t0x06ffffff\n\n \n#define PLLD_BASE_CSI_CLKSOURCE\t\t(1 << 23)\n\n#define PLLD_MISC0_EN_SDM\t\t(1 << 16)\n#define PLLD_MISC0_LOCK_OVERRIDE\t(1 << 17)\n#define PLLD_MISC0_LOCK_ENABLE\t\t(1 << 18)\n#define PLLD_MISC0_IDDQ\t\t\t(1 << 20)\n#define PLLD_MISC0_DSI_CLKENABLE\t(1 << 21)\n\n#define PLLD_MISC0_DEFAULT_VALUE\t0x00140000\n#define PLLD_MISC0_WRITE_MASK\t\t0x3ff7ffff\n#define PLLD_MISC1_DEFAULT_VALUE\t0x20\n#define PLLD_MISC1_WRITE_MASK\t\t0x00ffffff\n\n \n#define PLLDSS_BASE_LOCK\t\t(1 << 27)\n#define PLLDSS_BASE_LOCK_OVERRIDE\t(1 << 24)\n#define PLLDSS_BASE_IDDQ\t\t(1 << 18)\n#define PLLDSS_BASE_REF_SEL_SHIFT\t25\n#define PLLDSS_BASE_REF_SEL_MASK\t(0x3 << PLLDSS_BASE_REF_SEL_SHIFT)\n\n#define PLLDSS_MISC0_LOCK_ENABLE\t(1 << 30)\n\n#define PLLDSS_MISC1_CFG_EN_SDM\t\t(1 << 31)\n#define PLLDSS_MISC1_CFG_EN_SSC\t\t(1 << 30)\n\n#define PLLD2_MISC0_DEFAULT_VALUE\t0x40000020\n#define PLLD2_MISC1_CFG_DEFAULT_VALUE\t0x10000000\n#define PLLD2_MISC2_CTRL1_DEFAULT_VALUE\t0x0\n#define PLLD2_MISC3_CTRL2_DEFAULT_VALUE\t0x0\n\n#define PLLDP_MISC0_DEFAULT_VALUE\t0x40000020\n#define PLLDP_MISC1_CFG_DEFAULT_VALUE\t0xc0000000\n#define PLLDP_MISC2_CTRL1_DEFAULT_VALUE\t0xf400f0da\n#define PLLDP_MISC3_CTRL2_DEFAULT_VALUE\t0x2004f400\n\n#define PLLDSS_MISC0_WRITE_MASK\t\t0x47ffffff\n#define PLLDSS_MISC1_CFG_WRITE_MASK\t0xf8000000\n#define PLLDSS_MISC2_CTRL1_WRITE_MASK\t0xffffffff\n#define PLLDSS_MISC3_CTRL2_WRITE_MASK\t0xffffffff\n\n#define PLLC4_MISC0_DEFAULT_VALUE\t0x40000000\n\n \n#define PLLRE_MISC0_LOCK_ENABLE\t\t(1 << 30)\n#define PLLRE_MISC0_LOCK_OVERRIDE\t(1 << 29)\n#define PLLRE_MISC0_LOCK\t\t(1 << 27)\n#define PLLRE_MISC0_IDDQ\t\t(1 << 24)\n\n#define PLLRE_BASE_DEFAULT_VALUE\t0x0\n#define PLLRE_MISC0_DEFAULT_VALUE\t0x41000000\n\n#define PLLRE_BASE_DEFAULT_MASK\t\t0x1c000000\n#define PLLRE_MISC0_WRITE_MASK\t\t0x67ffffff\n\n \n#define PLLE_MISC_IDDQ_SW_CTRL\t\t(1 << 14)\n#define PLLE_AUX_USE_LOCKDET\t\t(1 << 3)\n#define PLLE_AUX_SS_SEQ_INCLUDE\t\t(1 << 31)\n#define PLLE_AUX_ENABLE_SWCTL\t\t(1 << 4)\n#define PLLE_AUX_SS_SWCTL\t\t(1 << 6)\n#define PLLE_AUX_SEQ_ENABLE\t\t(1 << 24)\n\n \n#define PLLX_USE_DYN_RAMP\t\t1\n#define PLLX_BASE_LOCK\t\t\t(1 << 27)\n\n#define PLLX_MISC0_FO_G_DISABLE\t\t(0x1 << 28)\n#define PLLX_MISC0_LOCK_ENABLE\t\t(0x1 << 18)\n\n#define PLLX_MISC2_DYNRAMP_STEPB_SHIFT\t24\n#define PLLX_MISC2_DYNRAMP_STEPB_MASK\t(0xFF << PLLX_MISC2_DYNRAMP_STEPB_SHIFT)\n#define PLLX_MISC2_DYNRAMP_STEPA_SHIFT\t16\n#define PLLX_MISC2_DYNRAMP_STEPA_MASK\t(0xFF << PLLX_MISC2_DYNRAMP_STEPA_SHIFT)\n#define PLLX_MISC2_NDIV_NEW_SHIFT\t8\n#define PLLX_MISC2_NDIV_NEW_MASK\t(0xFF << PLLX_MISC2_NDIV_NEW_SHIFT)\n#define PLLX_MISC2_LOCK_OVERRIDE\t(0x1 << 4)\n#define PLLX_MISC2_DYNRAMP_DONE\t\t(0x1 << 2)\n#define PLLX_MISC2_EN_DYNRAMP\t\t(0x1 << 0)\n\n#define PLLX_MISC3_IDDQ\t\t\t(0x1 << 3)\n\n#define PLLX_MISC0_DEFAULT_VALUE\tPLLX_MISC0_LOCK_ENABLE\n#define PLLX_MISC0_WRITE_MASK\t\t0x10c40000\n#define PLLX_MISC1_DEFAULT_VALUE\t0x20\n#define PLLX_MISC1_WRITE_MASK\t\t0x00ffffff\n#define PLLX_MISC2_DEFAULT_VALUE\t0x0\n#define PLLX_MISC2_WRITE_MASK\t\t0xffffff11\n#define PLLX_MISC3_DEFAULT_VALUE\tPLLX_MISC3_IDDQ\n#define PLLX_MISC3_WRITE_MASK\t\t0x01ff0f0f\n#define PLLX_MISC4_DEFAULT_VALUE\t0x0\n#define PLLX_MISC4_WRITE_MASK\t\t0x8000ffff\n#define PLLX_MISC5_DEFAULT_VALUE\t0x0\n#define PLLX_MISC5_WRITE_MASK\t\t0x0000ffff\n\n#define PLLX_HW_CTRL_CFG\t\t0x548\n#define PLLX_HW_CTRL_CFG_SWCTRL\t\t(0x1 << 0)\n\n \n#define PLLMB_BASE_LOCK\t\t\t(1 << 27)\n\n#define PLLMB_MISC1_LOCK_OVERRIDE\t(1 << 18)\n#define PLLMB_MISC1_IDDQ\t\t(1 << 17)\n#define PLLMB_MISC1_LOCK_ENABLE\t\t(1 << 16)\n\n#define PLLMB_MISC1_DEFAULT_VALUE\t0x00030000\n#define PLLMB_MISC1_WRITE_MASK\t\t0x0007ffff\n\n \n#define PLLP_BASE_OVERRIDE\t\t(1 << 28)\n#define PLLP_BASE_LOCK\t\t\t(1 << 27)\n\n#define PLLP_MISC0_LOCK_ENABLE\t\t(1 << 18)\n#define PLLP_MISC0_LOCK_OVERRIDE\t(1 << 17)\n#define PLLP_MISC0_IDDQ\t\t\t(1 << 3)\n\n#define PLLP_MISC1_HSIO_EN_SHIFT\t29\n#define PLLP_MISC1_HSIO_EN\t\t(1 << PLLP_MISC1_HSIO_EN_SHIFT)\n#define PLLP_MISC1_XUSB_EN_SHIFT\t28\n#define PLLP_MISC1_XUSB_EN\t\t(1 << PLLP_MISC1_XUSB_EN_SHIFT)\n\n#define PLLP_MISC0_DEFAULT_VALUE\t0x00040008\n#define PLLP_MISC1_DEFAULT_VALUE\t0x0\n\n#define PLLP_MISC0_WRITE_MASK\t\t0xdc6000f\n#define PLLP_MISC1_WRITE_MASK\t\t0x70ffffff\n\n \n#define PLLU_BASE_LOCK\t\t\t(1 << 27)\n#define PLLU_BASE_OVERRIDE\t\t(1 << 24)\n#define PLLU_BASE_CLKENABLE_USB\t\t(1 << 21)\n#define PLLU_BASE_CLKENABLE_HSIC\t(1 << 22)\n#define PLLU_BASE_CLKENABLE_ICUSB\t(1 << 23)\n#define PLLU_BASE_CLKENABLE_48M\t\t(1 << 25)\n#define PLLU_BASE_CLKENABLE_ALL\t\t(PLLU_BASE_CLKENABLE_USB |\\\n\t\t\t\t\t PLLU_BASE_CLKENABLE_HSIC |\\\n\t\t\t\t\t PLLU_BASE_CLKENABLE_ICUSB |\\\n\t\t\t\t\t PLLU_BASE_CLKENABLE_48M)\n\n#define PLLU_MISC0_IDDQ\t\t\t(1 << 31)\n#define PLLU_MISC0_LOCK_ENABLE\t\t(1 << 29)\n#define PLLU_MISC1_LOCK_OVERRIDE\t(1 << 0)\n\n#define PLLU_MISC0_DEFAULT_VALUE\t0xa0000000\n#define PLLU_MISC1_DEFAULT_VALUE\t0x0\n\n#define PLLU_MISC0_WRITE_MASK\t\t0xbfffffff\n#define PLLU_MISC1_WRITE_MASK\t\t0x00000007\n\nbool tegra210_plle_hw_sequence_is_enabled(void)\n{\n\tu32 value;\n\n\tvalue = readl_relaxed(clk_base + PLLE_AUX);\n\tif (value & PLLE_AUX_SEQ_ENABLE)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(tegra210_plle_hw_sequence_is_enabled);\n\nint tegra210_plle_hw_sequence_start(void)\n{\n\tu32 value;\n\n\tif (tegra210_plle_hw_sequence_is_enabled())\n\t\treturn 0;\n\n\t \n\tvalue = readl_relaxed(clk_base + PLLE_MISC0);\n\tif (!(value & PLLE_MISC_LOCK))\n\t\treturn -EIO;\n\n\tvalue &= ~PLLE_MISC_IDDQ_SW_CTRL;\n\twritel_relaxed(value, clk_base + PLLE_MISC0);\n\n\tvalue = readl_relaxed(clk_base + PLLE_AUX);\n\tvalue |= (PLLE_AUX_USE_LOCKDET | PLLE_AUX_SS_SEQ_INCLUDE);\n\tvalue &= ~(PLLE_AUX_ENABLE_SWCTL | PLLE_AUX_SS_SWCTL);\n\twritel_relaxed(value, clk_base + PLLE_AUX);\n\n\tfence_udelay(1, clk_base);\n\n\tvalue |= PLLE_AUX_SEQ_ENABLE;\n\twritel_relaxed(value, clk_base + PLLE_AUX);\n\n\tfence_udelay(1, clk_base);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra210_plle_hw_sequence_start);\n\nvoid tegra210_xusb_pll_hw_control_enable(void)\n{\n\tu32 val;\n\n\tval = readl_relaxed(clk_base + XUSBIO_PLL_CFG0);\n\tval &= ~(XUSBIO_PLL_CFG0_CLK_ENABLE_SWCTL |\n\t\t XUSBIO_PLL_CFG0_PADPLL_RESET_SWCTL);\n\tval |= XUSBIO_PLL_CFG0_PADPLL_USE_LOCKDET |\n\t       XUSBIO_PLL_CFG0_PADPLL_SLEEP_IDDQ;\n\twritel_relaxed(val, clk_base + XUSBIO_PLL_CFG0);\n}\nEXPORT_SYMBOL_GPL(tegra210_xusb_pll_hw_control_enable);\n\nvoid tegra210_xusb_pll_hw_sequence_start(void)\n{\n\tu32 val;\n\n\tval = readl_relaxed(clk_base + XUSBIO_PLL_CFG0);\n\tval |= XUSBIO_PLL_CFG0_SEQ_ENABLE;\n\twritel_relaxed(val, clk_base + XUSBIO_PLL_CFG0);\n}\nEXPORT_SYMBOL_GPL(tegra210_xusb_pll_hw_sequence_start);\n\nvoid tegra210_sata_pll_hw_control_enable(void)\n{\n\tu32 val;\n\n\tval = readl_relaxed(clk_base + SATA_PLL_CFG0);\n\tval &= ~SATA_PLL_CFG0_PADPLL_RESET_SWCTL;\n\tval |= SATA_PLL_CFG0_PADPLL_USE_LOCKDET |\n\t       SATA_PLL_CFG0_PADPLL_SLEEP_IDDQ;\n\twritel_relaxed(val, clk_base + SATA_PLL_CFG0);\n}\nEXPORT_SYMBOL_GPL(tegra210_sata_pll_hw_control_enable);\n\nvoid tegra210_sata_pll_hw_sequence_start(void)\n{\n\tu32 val;\n\n\tval = readl_relaxed(clk_base + SATA_PLL_CFG0);\n\tval |= SATA_PLL_CFG0_SEQ_ENABLE;\n\twritel_relaxed(val, clk_base + SATA_PLL_CFG0);\n}\nEXPORT_SYMBOL_GPL(tegra210_sata_pll_hw_sequence_start);\n\nvoid tegra210_set_sata_pll_seq_sw(bool state)\n{\n\tu32 val;\n\n\tval = readl_relaxed(clk_base + SATA_PLL_CFG0);\n\tif (state) {\n\t\tval |= SATA_PLL_CFG0_SATA_SEQ_IN_SWCTL;\n\t\tval |= SATA_PLL_CFG0_SATA_SEQ_RESET_INPUT_VALUE;\n\t\tval |= SATA_PLL_CFG0_SATA_SEQ_LANE_PD_INPUT_VALUE;\n\t\tval |= SATA_PLL_CFG0_SATA_SEQ_PADPLL_PD_INPUT_VALUE;\n\t} else {\n\t\tval &= ~SATA_PLL_CFG0_SATA_SEQ_IN_SWCTL;\n\t\tval &= ~SATA_PLL_CFG0_SATA_SEQ_RESET_INPUT_VALUE;\n\t\tval &= ~SATA_PLL_CFG0_SATA_SEQ_LANE_PD_INPUT_VALUE;\n\t\tval &= ~SATA_PLL_CFG0_SATA_SEQ_PADPLL_PD_INPUT_VALUE;\n\t}\n\twritel_relaxed(val, clk_base + SATA_PLL_CFG0);\n}\nEXPORT_SYMBOL_GPL(tegra210_set_sata_pll_seq_sw);\n\nvoid tegra210_clk_emc_dll_enable(bool flag)\n{\n\tu32 offset = flag ? CLK_RST_CONTROLLER_CLK_OUT_ENB_X_SET :\n\t\t     CLK_RST_CONTROLLER_CLK_OUT_ENB_X_CLR;\n\n\twritel_relaxed(CLK_OUT_ENB_X_CLK_ENB_EMC_DLL, clk_base + offset);\n}\nEXPORT_SYMBOL_GPL(tegra210_clk_emc_dll_enable);\n\nvoid tegra210_clk_emc_dll_update_setting(u32 emc_dll_src_value)\n{\n\twritel_relaxed(emc_dll_src_value, clk_base + CLK_SOURCE_EMC_DLL);\n}\nEXPORT_SYMBOL_GPL(tegra210_clk_emc_dll_update_setting);\n\nvoid tegra210_clk_emc_update_setting(u32 emc_src_value)\n{\n\twritel_relaxed(emc_src_value, clk_base + CLK_SOURCE_EMC);\n}\nEXPORT_SYMBOL_GPL(tegra210_clk_emc_update_setting);\n\nstatic void tegra210_generic_mbist_war(struct tegra210_domain_mbist_war *mbist)\n{\n\tu32 val;\n\n\tval = readl_relaxed(clk_base + mbist->lvl2_offset);\n\twritel_relaxed(val | mbist->lvl2_mask, clk_base + mbist->lvl2_offset);\n\tfence_udelay(1, clk_base);\n\twritel_relaxed(val, clk_base + mbist->lvl2_offset);\n\tfence_udelay(1, clk_base);\n}\n\nstatic void tegra210_venc_mbist_war(struct tegra210_domain_mbist_war *mbist)\n{\n\tu32 csi_src, ovra, ovre;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&pll_d_lock, flags);\n\n\tcsi_src = readl_relaxed(clk_base + PLLD_BASE);\n\twritel_relaxed(csi_src | PLLD_BASE_CSI_CLKSOURCE, clk_base + PLLD_BASE);\n\tfence_udelay(1, clk_base);\n\n\tovra = readl_relaxed(clk_base + LVL2_CLK_GATE_OVRA);\n\twritel_relaxed(ovra | BIT(15), clk_base + LVL2_CLK_GATE_OVRA);\n\tovre = readl_relaxed(clk_base + LVL2_CLK_GATE_OVRE);\n\twritel_relaxed(ovre | BIT(3), clk_base + LVL2_CLK_GATE_OVRE);\n\tfence_udelay(1, clk_base);\n\n\twritel_relaxed(ovra, clk_base + LVL2_CLK_GATE_OVRA);\n\twritel_relaxed(ovre, clk_base + LVL2_CLK_GATE_OVRE);\n\twritel_relaxed(csi_src, clk_base + PLLD_BASE);\n\tfence_udelay(1, clk_base);\n\n\tspin_unlock_irqrestore(&pll_d_lock, flags);\n}\n\nstatic void tegra210_disp_mbist_war(struct tegra210_domain_mbist_war *mbist)\n{\n\tu32 ovra, dsc_top_ctrl;\n\n\tovra = readl_relaxed(clk_base + LVL2_CLK_GATE_OVRA);\n\twritel_relaxed(ovra | BIT(1), clk_base + LVL2_CLK_GATE_OVRA);\n\tfence_udelay(1, clk_base);\n\n\tdsc_top_ctrl = readl_relaxed(dispa_base + DC_COM_DSC_TOP_CTL);\n\twritel_relaxed(dsc_top_ctrl | BIT(2), dispa_base + DC_COM_DSC_TOP_CTL);\n\treadl_relaxed(dispa_base + DC_CMD_DISPLAY_COMMAND);\n\twritel_relaxed(dsc_top_ctrl, dispa_base + DC_COM_DSC_TOP_CTL);\n\treadl_relaxed(dispa_base + DC_CMD_DISPLAY_COMMAND);\n\n\twritel_relaxed(ovra, clk_base + LVL2_CLK_GATE_OVRA);\n\tfence_udelay(1, clk_base);\n}\n\nstatic void tegra210_vic_mbist_war(struct tegra210_domain_mbist_war *mbist)\n{\n\tu32 ovre, val;\n\n\tovre = readl_relaxed(clk_base + LVL2_CLK_GATE_OVRE);\n\twritel_relaxed(ovre | BIT(5), clk_base + LVL2_CLK_GATE_OVRE);\n\tfence_udelay(1, clk_base);\n\n\tval = readl_relaxed(vic_base + NV_PVIC_THI_SLCG_OVERRIDE_LOW);\n\twritel_relaxed(val | BIT(0) | GENMASK(7, 2) | BIT(24),\n\t\t\tvic_base + NV_PVIC_THI_SLCG_OVERRIDE_LOW);\n\tfence_udelay(1, vic_base + NV_PVIC_THI_SLCG_OVERRIDE_LOW);\n\n\twritel_relaxed(val, vic_base + NV_PVIC_THI_SLCG_OVERRIDE_LOW);\n\treadl(vic_base + NV_PVIC_THI_SLCG_OVERRIDE_LOW);\n\n\twritel_relaxed(ovre, clk_base + LVL2_CLK_GATE_OVRE);\n\tfence_udelay(1, clk_base);\n}\n\nstatic void tegra210_ape_mbist_war(struct tegra210_domain_mbist_war *mbist)\n{\n\tvoid __iomem *i2s_base;\n\tunsigned int i;\n\tu32 ovrc, ovre;\n\n\tovrc = readl_relaxed(clk_base + LVL2_CLK_GATE_OVRC);\n\tovre = readl_relaxed(clk_base + LVL2_CLK_GATE_OVRE);\n\twritel_relaxed(ovrc | BIT(1), clk_base + LVL2_CLK_GATE_OVRC);\n\twritel_relaxed(ovre | BIT(10) | BIT(11),\n\t\t\tclk_base + LVL2_CLK_GATE_OVRE);\n\tfence_udelay(1, clk_base);\n\n\ti2s_base = ahub_base + TEGRA210_I2S_BASE;\n\n\tfor (i = 0; i < TEGRA210_I2S_CTRLS; i++) {\n\t\tu32 i2s_ctrl;\n\n\t\ti2s_ctrl = readl_relaxed(i2s_base + TEGRA210_I2S_CTRL);\n\t\twritel_relaxed(i2s_ctrl | BIT(10),\n\t\t\t\ti2s_base + TEGRA210_I2S_CTRL);\n\t\twritel_relaxed(0, i2s_base + TEGRA210_I2S_CG);\n\t\treadl(i2s_base + TEGRA210_I2S_CG);\n\t\twritel_relaxed(1, i2s_base + TEGRA210_I2S_CG);\n\t\twritel_relaxed(i2s_ctrl, i2s_base + TEGRA210_I2S_CTRL);\n\t\treadl(i2s_base + TEGRA210_I2S_CTRL);\n\n\t\ti2s_base += TEGRA210_I2S_SIZE;\n\t}\n\n\twritel_relaxed(ovrc, clk_base + LVL2_CLK_GATE_OVRC);\n\twritel_relaxed(ovre, clk_base + LVL2_CLK_GATE_OVRE);\n\tfence_udelay(1, clk_base);\n}\n\nstatic inline void _pll_misc_chk_default(void __iomem *base,\n\t\t\t\t\tstruct tegra_clk_pll_params *params,\n\t\t\t\t\tu8 misc_num, u32 default_val, u32 mask)\n{\n\tu32 boot_val = readl_relaxed(base + params->ext_misc_reg[misc_num]);\n\n\tboot_val &= mask;\n\tdefault_val &= mask;\n\tif (boot_val != default_val) {\n\t\tpr_warn(\"boot misc%d 0x%x: expected 0x%x\\n\",\n\t\t\tmisc_num, boot_val, default_val);\n\t\tpr_warn(\" (comparison mask = 0x%x)\\n\", mask);\n\t\tparams->defaults_set = false;\n\t}\n}\n\n \nstatic void pllcx_check_defaults(struct tegra_clk_pll_params *params)\n{\n\tu32 default_val;\n\n\tdefault_val = PLLCX_MISC0_DEFAULT_VALUE & (~PLLCX_MISC0_RESET);\n\t_pll_misc_chk_default(clk_base, params, 0, default_val,\n\t\t\tPLLCX_MISC0_WRITE_MASK);\n\n\tdefault_val = PLLCX_MISC1_DEFAULT_VALUE & (~PLLCX_MISC1_IDDQ);\n\t_pll_misc_chk_default(clk_base, params, 1, default_val,\n\t\t\tPLLCX_MISC1_WRITE_MASK);\n\n\tdefault_val = PLLCX_MISC2_DEFAULT_VALUE;\n\t_pll_misc_chk_default(clk_base, params, 2, default_val,\n\t\t\tPLLCX_MISC2_WRITE_MASK);\n\n\tdefault_val = PLLCX_MISC3_DEFAULT_VALUE;\n\t_pll_misc_chk_default(clk_base, params, 3, default_val,\n\t\t\tPLLCX_MISC3_WRITE_MASK);\n}\n\nstatic void tegra210_pllcx_set_defaults(const char *name,\n\t\t\t\t\tstruct tegra_clk_pll *pllcx)\n{\n\tpllcx->params->defaults_set = true;\n\n\tif (readl_relaxed(clk_base + pllcx->params->base_reg) & PLL_ENABLE) {\n\t\t \n\t\tpllcx_check_defaults(pllcx->params);\n\t\tif (!pllcx->params->defaults_set)\n\t\t\tpr_warn(\"%s already enabled. Postponing set full defaults\\n\",\n\t\t\t\tname);\n\t\treturn;\n\t}\n\n\t \n\twritel_relaxed(PLLCX_MISC0_DEFAULT_VALUE,\n\t\t\tclk_base + pllcx->params->ext_misc_reg[0]);\n\twritel_relaxed(PLLCX_MISC1_DEFAULT_VALUE,\n\t\t\tclk_base + pllcx->params->ext_misc_reg[1]);\n\twritel_relaxed(PLLCX_MISC2_DEFAULT_VALUE,\n\t\t\tclk_base + pllcx->params->ext_misc_reg[2]);\n\twritel_relaxed(PLLCX_MISC3_DEFAULT_VALUE,\n\t\t\tclk_base + pllcx->params->ext_misc_reg[3]);\n\tudelay(1);\n}\n\nstatic void _pllc_set_defaults(struct tegra_clk_pll *pllcx)\n{\n\ttegra210_pllcx_set_defaults(\"PLL_C\", pllcx);\n}\n\nstatic void _pllc2_set_defaults(struct tegra_clk_pll *pllcx)\n{\n\ttegra210_pllcx_set_defaults(\"PLL_C2\", pllcx);\n}\n\nstatic void _pllc3_set_defaults(struct tegra_clk_pll *pllcx)\n{\n\ttegra210_pllcx_set_defaults(\"PLL_C3\", pllcx);\n}\n\nstatic void _plla1_set_defaults(struct tegra_clk_pll *pllcx)\n{\n\ttegra210_pllcx_set_defaults(\"PLL_A1\", pllcx);\n}\n\n \nstatic void tegra210_plla_set_defaults(struct tegra_clk_pll *plla)\n{\n\tu32 mask;\n\tu32 val = readl_relaxed(clk_base + plla->params->base_reg);\n\n\tplla->params->defaults_set = true;\n\n\tif (val & PLL_ENABLE) {\n\t\t \n\t\tif (val & PLLA_BASE_IDDQ) {\n\t\t\tpr_warn(\"PLL_A boot enabled with IDDQ set\\n\");\n\t\t\tplla->params->defaults_set = false;\n\t\t}\n\n\t\tpr_warn(\"PLL_A already enabled. Postponing set full defaults\\n\");\n\n\t\tval = PLLA_MISC0_DEFAULT_VALUE;\t \n\t\tmask = PLLA_MISC0_LOCK_ENABLE | PLLA_MISC0_LOCK_OVERRIDE;\n\t\t_pll_misc_chk_default(clk_base, plla->params, 0, val,\n\t\t\t\t~mask & PLLA_MISC0_WRITE_MASK);\n\n\t\tval = PLLA_MISC2_DEFAULT_VALUE;  \n\t\t_pll_misc_chk_default(clk_base, plla->params, 2, val,\n\t\t\t\tPLLA_MISC2_EN_DYNRAMP);\n\n\t\t \n\t\tval = readl_relaxed(clk_base + plla->params->ext_misc_reg[0]);\n\t\tval &= ~mask;\n\t\tval |= PLLA_MISC0_DEFAULT_VALUE & mask;\n\t\twritel_relaxed(val, clk_base + plla->params->ext_misc_reg[0]);\n\t\tudelay(1);\n\n\t\treturn;\n\t}\n\n\t \n\tval |= PLLA_BASE_IDDQ;\n\twritel_relaxed(val, clk_base + plla->params->base_reg);\n\twritel_relaxed(PLLA_MISC0_DEFAULT_VALUE,\n\t\t\tclk_base + plla->params->ext_misc_reg[0]);\n\twritel_relaxed(PLLA_MISC2_DEFAULT_VALUE,\n\t\t\tclk_base + plla->params->ext_misc_reg[2]);\n\tudelay(1);\n}\n\n \nstatic void tegra210_plld_set_defaults(struct tegra_clk_pll *plld)\n{\n\tu32 val;\n\tu32 mask = 0xffff;\n\n\tplld->params->defaults_set = true;\n\n\tif (readl_relaxed(clk_base + plld->params->base_reg) &\n\t\t\tPLL_ENABLE) {\n\n\t\t \n\t\tval = PLLD_MISC1_DEFAULT_VALUE;\n\t\t_pll_misc_chk_default(clk_base, plld->params, 1,\n\t\t\t\tval, PLLD_MISC1_WRITE_MASK);\n\n\t\t \n\t\tval = PLLD_MISC0_DEFAULT_VALUE & (~PLLD_MISC0_IDDQ);\n\t\tmask |= PLLD_MISC0_DSI_CLKENABLE | PLLD_MISC0_LOCK_ENABLE |\n\t\t\tPLLD_MISC0_LOCK_OVERRIDE | PLLD_MISC0_EN_SDM;\n\t\t_pll_misc_chk_default(clk_base, plld->params, 0, val,\n\t\t\t\t~mask & PLLD_MISC0_WRITE_MASK);\n\n\t\tif (!plld->params->defaults_set)\n\t\t\tpr_warn(\"PLL_D already enabled. Postponing set full defaults\\n\");\n\n\t\t \n\t\tmask = PLLD_MISC0_LOCK_ENABLE | PLLD_MISC0_LOCK_OVERRIDE;\n\t\tval = readl_relaxed(clk_base + plld->params->ext_misc_reg[0]);\n\t\tval &= ~mask;\n\t\tval |= PLLD_MISC0_DEFAULT_VALUE & mask;\n\t\twritel_relaxed(val, clk_base + plld->params->ext_misc_reg[0]);\n\t\tudelay(1);\n\n\t\treturn;\n\t}\n\n\tval = readl_relaxed(clk_base + plld->params->ext_misc_reg[0]);\n\tval &= PLLD_MISC0_DSI_CLKENABLE;\n\tval |= PLLD_MISC0_DEFAULT_VALUE;\n\t \n\twritel_relaxed(val, clk_base + plld->params->ext_misc_reg[0]);\n\twritel_relaxed(PLLD_MISC1_DEFAULT_VALUE, clk_base +\n\t\t\tplld->params->ext_misc_reg[1]);\n\tudelay(1);\n}\n\n \nstatic void plldss_defaults(const char *pll_name, struct tegra_clk_pll *plldss,\n\t\tu32 misc0_val, u32 misc1_val, u32 misc2_val, u32 misc3_val)\n{\n\tu32 default_val;\n\tu32 val = readl_relaxed(clk_base + plldss->params->base_reg);\n\n\tplldss->params->defaults_set = true;\n\n\tif (val & PLL_ENABLE) {\n\n\t\t \n\t\tif (val & PLLDSS_BASE_IDDQ) {\n\t\t\tpr_warn(\"plldss boot enabled with IDDQ set\\n\");\n\t\t\tplldss->params->defaults_set = false;\n\t\t}\n\n\t\t \n\t\tdefault_val = misc0_val;\n\t\t_pll_misc_chk_default(clk_base, plldss->params, 0, default_val,\n\t\t\t\t     PLLDSS_MISC0_WRITE_MASK &\n\t\t\t\t     (~PLLDSS_MISC0_LOCK_ENABLE));\n\n\t\t \n\t\tif (plldss->params->ssc_ctrl_en_mask) {\n\t\t\tdefault_val = misc1_val;\n\t\t\t_pll_misc_chk_default(clk_base, plldss->params, 1,\n\t\t\t\tdefault_val, PLLDSS_MISC1_CFG_WRITE_MASK);\n\t\t\tdefault_val = misc2_val;\n\t\t\t_pll_misc_chk_default(clk_base, plldss->params, 2,\n\t\t\t\tdefault_val, PLLDSS_MISC2_CTRL1_WRITE_MASK);\n\t\t\tdefault_val = misc3_val;\n\t\t\t_pll_misc_chk_default(clk_base, plldss->params, 3,\n\t\t\t\tdefault_val, PLLDSS_MISC3_CTRL2_WRITE_MASK);\n\t\t} else if (plldss->params->ext_misc_reg[1]) {\n\t\t\tdefault_val = misc1_val;\n\t\t\t_pll_misc_chk_default(clk_base, plldss->params, 1,\n\t\t\t\tdefault_val, PLLDSS_MISC1_CFG_WRITE_MASK &\n\t\t\t\t(~PLLDSS_MISC1_CFG_EN_SDM));\n\t\t}\n\n\t\tif (!plldss->params->defaults_set)\n\t\t\tpr_warn(\"%s already enabled. Postponing set full defaults\\n\",\n\t\t\t\t pll_name);\n\n\t\t \n\t\tif (val & PLLDSS_BASE_LOCK_OVERRIDE) {\n\t\t\tval &= ~PLLDSS_BASE_LOCK_OVERRIDE;\n\t\t\twritel_relaxed(val, clk_base +\n\t\t\t\t\tplldss->params->base_reg);\n\t\t}\n\n\t\tval = readl_relaxed(clk_base + plldss->params->ext_misc_reg[0]);\n\t\tval &= ~PLLDSS_MISC0_LOCK_ENABLE;\n\t\tval |= misc0_val & PLLDSS_MISC0_LOCK_ENABLE;\n\t\twritel_relaxed(val, clk_base + plldss->params->ext_misc_reg[0]);\n\t\tudelay(1);\n\n\t\treturn;\n\t}\n\n\t \n\tval |= PLLDSS_BASE_IDDQ;\n\tval &= ~PLLDSS_BASE_LOCK_OVERRIDE;\n\twritel_relaxed(val, clk_base + plldss->params->base_reg);\n\n\t \n\tif (!plldss->params->ext_misc_reg[1]) {\n\t\twritel_relaxed(misc0_val, clk_base +\n\t\t\t\tplldss->params->ext_misc_reg[0]);\n\t\tudelay(1);\n\t\treturn;\n\t}\n\n\twritel_relaxed(misc0_val, clk_base +\n\t\t\tplldss->params->ext_misc_reg[0]);\n\t \n\twritel_relaxed(misc1_val & (~PLLDSS_MISC1_CFG_EN_SSC),\n\t\t\tclk_base + plldss->params->ext_misc_reg[1]);\n\twritel_relaxed(misc2_val, clk_base + plldss->params->ext_misc_reg[2]);\n\twritel_relaxed(misc3_val, clk_base + plldss->params->ext_misc_reg[3]);\n\tudelay(1);\n}\n\nstatic void tegra210_plld2_set_defaults(struct tegra_clk_pll *plld2)\n{\n\tplldss_defaults(\"PLL_D2\", plld2, PLLD2_MISC0_DEFAULT_VALUE,\n\t\t\tPLLD2_MISC1_CFG_DEFAULT_VALUE,\n\t\t\tPLLD2_MISC2_CTRL1_DEFAULT_VALUE,\n\t\t\tPLLD2_MISC3_CTRL2_DEFAULT_VALUE);\n}\n\nstatic void tegra210_plldp_set_defaults(struct tegra_clk_pll *plldp)\n{\n\tplldss_defaults(\"PLL_DP\", plldp, PLLDP_MISC0_DEFAULT_VALUE,\n\t\t\tPLLDP_MISC1_CFG_DEFAULT_VALUE,\n\t\t\tPLLDP_MISC2_CTRL1_DEFAULT_VALUE,\n\t\t\tPLLDP_MISC3_CTRL2_DEFAULT_VALUE);\n}\n\n \nstatic void tegra210_pllc4_set_defaults(struct tegra_clk_pll *pllc4)\n{\n\tplldss_defaults(\"PLL_C4\", pllc4, PLLC4_MISC0_DEFAULT_VALUE, 0, 0, 0);\n}\n\n \nstatic void tegra210_pllre_set_defaults(struct tegra_clk_pll *pllre)\n{\n\tu32 mask;\n\tu32 val = readl_relaxed(clk_base + pllre->params->base_reg);\n\n\tpllre->params->defaults_set = true;\n\n\tif (val & PLL_ENABLE) {\n\t\t \n\t\tval &= PLLRE_BASE_DEFAULT_MASK;\n\t\tif (val != PLLRE_BASE_DEFAULT_VALUE) {\n\t\t\tpr_warn(\"pllre boot base 0x%x : expected 0x%x\\n\",\n\t\t\t\tval, PLLRE_BASE_DEFAULT_VALUE);\n\t\t\tpr_warn(\"(comparison mask = 0x%x)\\n\",\n\t\t\t\tPLLRE_BASE_DEFAULT_MASK);\n\t\t\tpllre->params->defaults_set = false;\n\t\t}\n\n\t\t \n\t\tval = PLLRE_MISC0_DEFAULT_VALUE & (~PLLRE_MISC0_IDDQ);\n\t\tmask = PLLRE_MISC0_LOCK_ENABLE | PLLRE_MISC0_LOCK_OVERRIDE;\n\t\t_pll_misc_chk_default(clk_base, pllre->params, 0, val,\n\t\t\t\t~mask & PLLRE_MISC0_WRITE_MASK);\n\n\t\t \n\t\tval = readl_relaxed(clk_base + pllre->params->ext_misc_reg[0]);\n\t\tif (val & PLLRE_MISC0_IDDQ)\n\t\t\tpr_warn(\"unexpected IDDQ bit set for enabled clock\\n\");\n\n\t\t \n\t\tval &= ~mask;\n\t\tval |= PLLRE_MISC0_DEFAULT_VALUE & mask;\n\t\twritel_relaxed(val, clk_base + pllre->params->ext_misc_reg[0]);\n\t\tudelay(1);\n\n\t\tif (!pllre->params->defaults_set)\n\t\t\tpr_warn(\"PLL_RE already enabled. Postponing set full defaults\\n\");\n\n\t\treturn;\n\t}\n\n\t \n\tval &= ~PLLRE_BASE_DEFAULT_MASK;\n\tval |= PLLRE_BASE_DEFAULT_VALUE & PLLRE_BASE_DEFAULT_MASK;\n\twritel_relaxed(val, clk_base + pllre->params->base_reg);\n\twritel_relaxed(PLLRE_MISC0_DEFAULT_VALUE,\n\t\t\tclk_base + pllre->params->ext_misc_reg[0]);\n\tudelay(1);\n}\n\nstatic void pllx_get_dyn_steps(struct clk_hw *hw, u32 *step_a, u32 *step_b)\n{\n\tunsigned long input_rate;\n\n\t \n\tif (!IS_ERR_OR_NULL(hw->clk))\n\t\tinput_rate = clk_hw_get_rate(clk_hw_get_parent(hw));\n\telse\n\t\tinput_rate = 38400000;\n\n\tinput_rate /= tegra_pll_get_fixed_mdiv(hw, input_rate);\n\n\tswitch (input_rate) {\n\tcase 12000000:\n\tcase 12800000:\n\tcase 13000000:\n\t\t*step_a = 0x2B;\n\t\t*step_b = 0x0B;\n\t\treturn;\n\tcase 19200000:\n\t\t*step_a = 0x12;\n\t\t*step_b = 0x08;\n\t\treturn;\n\tcase 38400000:\n\t\t*step_a = 0x04;\n\t\t*step_b = 0x05;\n\t\treturn;\n\tdefault:\n\t\tpr_err(\"%s: Unexpected reference rate %lu\\n\",\n\t\t\t__func__, input_rate);\n\t\tBUG();\n\t}\n}\n\nstatic void pllx_check_defaults(struct tegra_clk_pll *pll)\n{\n\tu32 default_val;\n\n\tdefault_val = PLLX_MISC0_DEFAULT_VALUE;\n\t \n\t_pll_misc_chk_default(clk_base, pll->params, 0, default_val,\n\t\t\tPLLX_MISC0_WRITE_MASK & (~PLLX_MISC0_LOCK_ENABLE));\n\n\tdefault_val = PLLX_MISC1_DEFAULT_VALUE;\n\t_pll_misc_chk_default(clk_base, pll->params, 1, default_val,\n\t\t\tPLLX_MISC1_WRITE_MASK);\n\n\t \n\tdefault_val = PLLX_MISC2_DEFAULT_VALUE;\n\t_pll_misc_chk_default(clk_base, pll->params, 2,\n\t\t\tdefault_val, PLLX_MISC2_EN_DYNRAMP);\n\n\tdefault_val = PLLX_MISC3_DEFAULT_VALUE & (~PLLX_MISC3_IDDQ);\n\t_pll_misc_chk_default(clk_base, pll->params, 3, default_val,\n\t\t\tPLLX_MISC3_WRITE_MASK);\n\n\tdefault_val = PLLX_MISC4_DEFAULT_VALUE;\n\t_pll_misc_chk_default(clk_base, pll->params, 4, default_val,\n\t\t\tPLLX_MISC4_WRITE_MASK);\n\n\tdefault_val = PLLX_MISC5_DEFAULT_VALUE;\n\t_pll_misc_chk_default(clk_base, pll->params, 5, default_val,\n\t\t\tPLLX_MISC5_WRITE_MASK);\n}\n\nstatic void tegra210_pllx_set_defaults(struct tegra_clk_pll *pllx)\n{\n\tu32 val;\n\tu32 step_a, step_b;\n\n\tpllx->params->defaults_set = true;\n\n\t \n\tpllx_get_dyn_steps(&pllx->hw, &step_a, &step_b);\n\tval = PLLX_MISC2_DEFAULT_VALUE & (~PLLX_MISC2_DYNRAMP_STEPA_MASK) &\n\t\t(~PLLX_MISC2_DYNRAMP_STEPB_MASK);\n\tval |= step_a << PLLX_MISC2_DYNRAMP_STEPA_SHIFT;\n\tval |= step_b << PLLX_MISC2_DYNRAMP_STEPB_SHIFT;\n\n\tif (readl_relaxed(clk_base + pllx->params->base_reg) & PLL_ENABLE) {\n\n\t\t \n\t\tpllx_check_defaults(pllx);\n\n\t\tif (!pllx->params->defaults_set)\n\t\t\tpr_warn(\"PLL_X already enabled. Postponing set full defaults\\n\");\n\t\t \n\t\twritel_relaxed(val, clk_base + pllx->params->ext_misc_reg[2]);\n\n\t\t \n\t\tval = readl_relaxed(clk_base + pllx->params->ext_misc_reg[0]);\n\t\tval &= ~PLLX_MISC0_LOCK_ENABLE;\n\t\tval |= PLLX_MISC0_DEFAULT_VALUE & PLLX_MISC0_LOCK_ENABLE;\n\t\twritel_relaxed(val, clk_base + pllx->params->ext_misc_reg[0]);\n\t\tudelay(1);\n\n\t\treturn;\n\t}\n\n\t \n\twritel_relaxed(PLLX_MISC0_DEFAULT_VALUE, clk_base +\n\t\t\tpllx->params->ext_misc_reg[0]);\n\n\t \n\twritel_relaxed(PLLX_MISC1_DEFAULT_VALUE, clk_base +\n\t\t\tpllx->params->ext_misc_reg[1]);\n\n\t \n\twritel_relaxed(val, clk_base + pllx->params->ext_misc_reg[2]);\n\n\t \n\twritel_relaxed(PLLX_MISC3_DEFAULT_VALUE, clk_base +\n\t\t\tpllx->params->ext_misc_reg[3]);\n\n\t \n\twritel_relaxed(PLLX_MISC4_DEFAULT_VALUE, clk_base +\n\t\t\tpllx->params->ext_misc_reg[4]);\n\twritel_relaxed(PLLX_MISC5_DEFAULT_VALUE, clk_base +\n\t\t\tpllx->params->ext_misc_reg[5]);\n\tudelay(1);\n}\n\n \nstatic void tegra210_pllmb_set_defaults(struct tegra_clk_pll *pllmb)\n{\n\tu32 mask, val = readl_relaxed(clk_base + pllmb->params->base_reg);\n\n\tpllmb->params->defaults_set = true;\n\n\tif (val & PLL_ENABLE) {\n\n\t\t \n\t\tval = PLLMB_MISC1_DEFAULT_VALUE & (~PLLMB_MISC1_IDDQ);\n\t\tmask = PLLMB_MISC1_LOCK_ENABLE | PLLMB_MISC1_LOCK_OVERRIDE;\n\t\t_pll_misc_chk_default(clk_base, pllmb->params, 0, val,\n\t\t\t\t~mask & PLLMB_MISC1_WRITE_MASK);\n\n\t\tif (!pllmb->params->defaults_set)\n\t\t\tpr_warn(\"PLL_MB already enabled. Postponing set full defaults\\n\");\n\t\t \n\t\tval = readl_relaxed(clk_base + pllmb->params->ext_misc_reg[0]);\n\t\tval &= ~mask;\n\t\tval |= PLLMB_MISC1_DEFAULT_VALUE & mask;\n\t\twritel_relaxed(val, clk_base + pllmb->params->ext_misc_reg[0]);\n\t\tudelay(1);\n\n\t\treturn;\n\t}\n\n\t \n\twritel_relaxed(PLLMB_MISC1_DEFAULT_VALUE,\n\t\t\tclk_base + pllmb->params->ext_misc_reg[0]);\n\tudelay(1);\n}\n\n \nstatic void pllp_check_defaults(struct tegra_clk_pll *pll, bool enabled)\n{\n\tu32 val, mask;\n\n\t \n\tval = PLLP_MISC0_DEFAULT_VALUE & (~PLLP_MISC0_IDDQ);\n\tmask = PLLP_MISC0_LOCK_ENABLE | PLLP_MISC0_LOCK_OVERRIDE;\n\tif (!enabled)\n\t\tmask |= PLLP_MISC0_IDDQ;\n\t_pll_misc_chk_default(clk_base, pll->params, 0, val,\n\t\t\t~mask & PLLP_MISC0_WRITE_MASK);\n\n\t \n\tval = PLLP_MISC1_DEFAULT_VALUE;\n\tmask = PLLP_MISC1_HSIO_EN | PLLP_MISC1_XUSB_EN;\n\t_pll_misc_chk_default(clk_base, pll->params, 1, val,\n\t\t\t~mask & PLLP_MISC1_WRITE_MASK);\n}\n\nstatic void tegra210_pllp_set_defaults(struct tegra_clk_pll *pllp)\n{\n\tu32 mask;\n\tu32 val = readl_relaxed(clk_base + pllp->params->base_reg);\n\n\tpllp->params->defaults_set = true;\n\n\tif (val & PLL_ENABLE) {\n\n\t\t \n\t\tpllp_check_defaults(pllp, true);\n\t\tif (!pllp->params->defaults_set)\n\t\t\tpr_warn(\"PLL_P already enabled. Postponing set full defaults\\n\");\n\n\t\t \n\t\tval = readl_relaxed(clk_base + pllp->params->ext_misc_reg[0]);\n\t\tmask = PLLP_MISC0_LOCK_ENABLE | PLLP_MISC0_LOCK_OVERRIDE;\n\t\tval &= ~mask;\n\t\tval |= PLLP_MISC0_DEFAULT_VALUE & mask;\n\t\twritel_relaxed(val, clk_base + pllp->params->ext_misc_reg[0]);\n\t\tudelay(1);\n\n\t\treturn;\n\t}\n\n\t \n\twritel_relaxed(PLLP_MISC0_DEFAULT_VALUE,\n\t\t\tclk_base + pllp->params->ext_misc_reg[0]);\n\n\t \n\tval = readl_relaxed(clk_base + pllp->params->ext_misc_reg[1]);\n\tmask = PLLP_MISC1_HSIO_EN | PLLP_MISC1_XUSB_EN;\n\tval &= mask;\n\tval |= ~mask & PLLP_MISC1_DEFAULT_VALUE;\n\twritel_relaxed(val, clk_base + pllp->params->ext_misc_reg[1]);\n\tudelay(1);\n}\n\n \nstatic void pllu_check_defaults(struct tegra_clk_pll_params *params,\n\t\t\t\tbool hw_control)\n{\n\tu32 val, mask;\n\n\t \n\tval = PLLU_MISC0_DEFAULT_VALUE & (~PLLU_MISC0_IDDQ);\n\tmask = PLLU_MISC0_LOCK_ENABLE | (hw_control ? PLLU_MISC0_IDDQ : 0);\n\t_pll_misc_chk_default(clk_base, params, 0, val,\n\t\t\t~mask & PLLU_MISC0_WRITE_MASK);\n\n\tval = PLLU_MISC1_DEFAULT_VALUE;\n\tmask = PLLU_MISC1_LOCK_OVERRIDE;\n\t_pll_misc_chk_default(clk_base, params, 1, val,\n\t\t\t~mask & PLLU_MISC1_WRITE_MASK);\n}\n\nstatic void tegra210_pllu_set_defaults(struct tegra_clk_pll_params *pllu)\n{\n\tu32 val = readl_relaxed(clk_base + pllu->base_reg);\n\n\tpllu->defaults_set = true;\n\n\tif (val & PLL_ENABLE) {\n\n\t\t \n\t\tpllu_check_defaults(pllu, false);\n\t\tif (!pllu->defaults_set)\n\t\t\tpr_warn(\"PLL_U already enabled. Postponing set full defaults\\n\");\n\n\t\t \n\t\tval = readl_relaxed(clk_base + pllu->ext_misc_reg[0]);\n\t\tval &= ~PLLU_MISC0_LOCK_ENABLE;\n\t\tval |= PLLU_MISC0_DEFAULT_VALUE & PLLU_MISC0_LOCK_ENABLE;\n\t\twritel_relaxed(val, clk_base + pllu->ext_misc_reg[0]);\n\n\t\tval = readl_relaxed(clk_base + pllu->ext_misc_reg[1]);\n\t\tval &= ~PLLU_MISC1_LOCK_OVERRIDE;\n\t\tval |= PLLU_MISC1_DEFAULT_VALUE & PLLU_MISC1_LOCK_OVERRIDE;\n\t\twritel_relaxed(val, clk_base + pllu->ext_misc_reg[1]);\n\t\tudelay(1);\n\n\t\treturn;\n\t}\n\n\t \n\twritel_relaxed(PLLU_MISC0_DEFAULT_VALUE,\n\t\t\tclk_base + pllu->ext_misc_reg[0]);\n\twritel_relaxed(PLLU_MISC1_DEFAULT_VALUE,\n\t\t\tclk_base + pllu->ext_misc_reg[1]);\n\tudelay(1);\n}\n\n#define mask(w) ((1 << (w)) - 1)\n#define divm_mask(p) mask(p->params->div_nmp->divm_width)\n#define divn_mask(p) mask(p->params->div_nmp->divn_width)\n#define divp_mask(p) (p->params->flags & TEGRA_PLLU ? PLLU_POST_DIVP_MASK :\\\n\t\t      mask(p->params->div_nmp->divp_width))\n\n#define divm_shift(p) ((p)->params->div_nmp->divm_shift)\n#define divn_shift(p) ((p)->params->div_nmp->divn_shift)\n#define divp_shift(p) ((p)->params->div_nmp->divp_shift)\n\n#define divm_mask_shifted(p) (divm_mask(p) << divm_shift(p))\n#define divn_mask_shifted(p) (divn_mask(p) << divn_shift(p))\n#define divp_mask_shifted(p) (divp_mask(p) << divp_shift(p))\n\n#define PLL_LOCKDET_DELAY 2\t \nstatic int tegra210_wait_for_mask(struct tegra_clk_pll *pll,\n\t\t\t\t  u32 reg, u32 mask)\n{\n\tint i;\n\tu32 val = 0;\n\n\tfor (i = 0; i < pll->params->lock_delay / PLL_LOCKDET_DELAY + 1; i++) {\n\t\tudelay(PLL_LOCKDET_DELAY);\n\t\tval = readl_relaxed(clk_base + reg);\n\t\tif ((val & mask) == mask) {\n\t\t\tudelay(PLL_LOCKDET_DELAY);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int tegra210_pllx_dyn_ramp(struct tegra_clk_pll *pllx,\n\t\tstruct tegra_clk_pll_freq_table *cfg)\n{\n\tu32 val, base, ndiv_new_mask;\n\n\tndiv_new_mask = (divn_mask(pllx) >> pllx->params->div_nmp->divn_shift)\n\t\t\t << PLLX_MISC2_NDIV_NEW_SHIFT;\n\n\tval = readl_relaxed(clk_base + pllx->params->ext_misc_reg[2]);\n\tval &= (~ndiv_new_mask);\n\tval |= cfg->n << PLLX_MISC2_NDIV_NEW_SHIFT;\n\twritel_relaxed(val, clk_base + pllx->params->ext_misc_reg[2]);\n\tudelay(1);\n\n\tval = readl_relaxed(clk_base + pllx->params->ext_misc_reg[2]);\n\tval |= PLLX_MISC2_EN_DYNRAMP;\n\twritel_relaxed(val, clk_base + pllx->params->ext_misc_reg[2]);\n\tudelay(1);\n\n\ttegra210_wait_for_mask(pllx, pllx->params->ext_misc_reg[2],\n\t\t\t       PLLX_MISC2_DYNRAMP_DONE);\n\n\tbase = readl_relaxed(clk_base + pllx->params->base_reg) &\n\t\t(~divn_mask_shifted(pllx));\n\tbase |= cfg->n << pllx->params->div_nmp->divn_shift;\n\twritel_relaxed(base, clk_base + pllx->params->base_reg);\n\tudelay(1);\n\n\tval &= ~PLLX_MISC2_EN_DYNRAMP;\n\twritel_relaxed(val, clk_base + pllx->params->ext_misc_reg[2]);\n\tudelay(1);\n\n\tpr_debug(\"%s: dynamic ramp to m = %u n = %u p = %u, Fout = %lu kHz\\n\",\n\t\t __clk_get_name(pllx->hw.clk), cfg->m, cfg->n, cfg->p,\n\t\t cfg->input_rate / cfg->m * cfg->n /\n\t\t pllx->params->pdiv_tohw[cfg->p].pdiv / 1000);\n\n\treturn 0;\n}\n\n \nstatic int tegra210_pll_fixed_mdiv_cfg(struct clk_hw *hw,\n\t\t\t       struct tegra_clk_pll_freq_table *cfg,\n\t\t\t       unsigned long rate, unsigned long input_rate)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tstruct tegra_clk_pll_params *params = pll->params;\n\tint p;\n\tunsigned long cf, p_rate;\n\tu32 pdiv;\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\tif (!(params->flags & TEGRA_PLL_VCO_OUT)) {\n\t\tp = DIV_ROUND_UP(params->vco_min, rate);\n\t\tp = params->round_p_to_pdiv(p, &pdiv);\n\t} else {\n\t\tp = rate >= params->vco_min ? 1 : -EINVAL;\n\t}\n\n\tif (p < 0)\n\t\treturn -EINVAL;\n\n\tcfg->m = tegra_pll_get_fixed_mdiv(hw, input_rate);\n\tcfg->p = p;\n\n\t \n\tcfg->p = tegra_pll_p_div_to_hw(pll, cfg->p);\n\n\tp_rate = rate * p;\n\tif (p_rate > params->vco_max)\n\t\tp_rate = params->vco_max;\n\tcf = input_rate / cfg->m;\n\tcfg->n = p_rate / cf;\n\n\tcfg->sdm_data = 0;\n\tcfg->output_rate = input_rate;\n\tif (params->sdm_ctrl_reg) {\n\t\tunsigned long rem = p_rate - cf * cfg->n;\n\t\t \n\t\tif (rem || params->ssc_ctrl_reg) {\n\t\t\tu64 s = rem * PLL_SDM_COEFF;\n\n\t\t\tdo_div(s, cf);\n\t\t\ts -= PLL_SDM_COEFF / 2;\n\t\t\tcfg->sdm_data = sdin_din_to_data(s);\n\t\t}\n\t\tcfg->output_rate *= sdin_get_n_eff(cfg);\n\t\tcfg->output_rate /= p * cfg->m * PLL_SDM_COEFF;\n\t} else {\n\t\tcfg->output_rate *= cfg->n;\n\t\tcfg->output_rate /= p * cfg->m;\n\t}\n\n\tcfg->input_rate = input_rate;\n\n\treturn 0;\n}\n\n \nstatic void tegra210_clk_pll_set_gain(struct tegra_clk_pll_freq_table *cfg)\n{\n\tcfg->n = sdin_get_n_eff(cfg);\n\tcfg->m *= PLL_SDM_COEFF;\n}\n\nstatic unsigned long\ntegra210_clk_adjust_vco_min(struct tegra_clk_pll_params *params,\n\t\t\t    unsigned long parent_rate)\n{\n\tunsigned long vco_min = params->vco_min;\n\n\tparams->vco_min += DIV_ROUND_UP(parent_rate, PLL_SDM_COEFF);\n\tvco_min = min(vco_min, params->vco_min);\n\n\treturn vco_min;\n}\n\nstatic struct div_nmp pllx_nmp = {\n\t.divm_shift = 0,\n\t.divm_width = 8,\n\t.divn_shift = 8,\n\t.divn_width = 8,\n\t.divp_shift = 20,\n\t.divp_width = 5,\n};\n \n#define PLL_QLIN_PDIV_MAX\t16\nstatic const struct pdiv_map pll_qlin_pdiv_to_hw[] = {\n\t{ .pdiv =  1, .hw_val =  0 },\n\t{ .pdiv =  2, .hw_val =  1 },\n\t{ .pdiv =  3, .hw_val =  2 },\n\t{ .pdiv =  4, .hw_val =  3 },\n\t{ .pdiv =  5, .hw_val =  4 },\n\t{ .pdiv =  6, .hw_val =  5 },\n\t{ .pdiv =  8, .hw_val =  6 },\n\t{ .pdiv =  9, .hw_val =  7 },\n\t{ .pdiv = 10, .hw_val =  8 },\n\t{ .pdiv = 12, .hw_val =  9 },\n\t{ .pdiv = 15, .hw_val = 10 },\n\t{ .pdiv = 16, .hw_val = 11 },\n\t{ .pdiv = 18, .hw_val = 12 },\n\t{ .pdiv = 20, .hw_val = 13 },\n\t{ .pdiv = 24, .hw_val = 14 },\n\t{ .pdiv = 30, .hw_val = 15 },\n\t{ .pdiv = 32, .hw_val = 16 },\n};\n\nstatic u32 pll_qlin_p_to_pdiv(u32 p, u32 *pdiv)\n{\n\tint i;\n\n\tif (p) {\n\t\tfor (i = 0; i <= PLL_QLIN_PDIV_MAX; i++) {\n\t\t\tif (p <= pll_qlin_pdiv_to_hw[i].pdiv) {\n\t\t\t\tif (pdiv)\n\t\t\t\t\t*pdiv = i;\n\t\t\t\treturn pll_qlin_pdiv_to_hw[i].pdiv;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n#define PLL_EXPO_PDIV_MAX\t7\nstatic const struct pdiv_map pll_expo_pdiv_to_hw[] = {\n\t{ .pdiv =   1, .hw_val = 0 },\n\t{ .pdiv =   2, .hw_val = 1 },\n\t{ .pdiv =   4, .hw_val = 2 },\n\t{ .pdiv =   8, .hw_val = 3 },\n\t{ .pdiv =  16, .hw_val = 4 },\n\t{ .pdiv =  32, .hw_val = 5 },\n\t{ .pdiv =  64, .hw_val = 6 },\n\t{ .pdiv = 128, .hw_val = 7 },\n};\n\nstatic u32 pll_expo_p_to_pdiv(u32 p, u32 *pdiv)\n{\n\tif (p) {\n\t\tu32 i = fls(p);\n\n\t\tif (i == ffs(p))\n\t\t\ti--;\n\n\t\tif (i <= PLL_EXPO_PDIV_MAX) {\n\t\t\tif (pdiv)\n\t\t\t\t*pdiv = i;\n\t\t\treturn 1 << i;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic struct tegra_clk_pll_freq_table pll_x_freq_table[] = {\n\t \n\t{ 12000000, 1000000000, 166, 1, 2, 0 },  \n\t{ 13000000, 1000000000, 153, 1, 2, 0 },  \n\t{ 38400000, 1000000000, 156, 3, 2, 0 },  \n\t{        0,          0,   0, 0, 0, 0 },\n};\n\nstatic struct tegra_clk_pll_params pll_x_params = {\n\t.input_min = 12000000,\n\t.input_max = 800000000,\n\t.cf_min = 12000000,\n\t.cf_max = 38400000,\n\t.vco_min = 1350000000,\n\t.vco_max = 3000000000UL,\n\t.base_reg = PLLX_BASE,\n\t.misc_reg = PLLX_MISC0,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_enable_bit_idx = PLL_MISC_LOCK_ENABLE,\n\t.lock_delay = 300,\n\t.ext_misc_reg[0] = PLLX_MISC0,\n\t.ext_misc_reg[1] = PLLX_MISC1,\n\t.ext_misc_reg[2] = PLLX_MISC2,\n\t.ext_misc_reg[3] = PLLX_MISC3,\n\t.ext_misc_reg[4] = PLLX_MISC4,\n\t.ext_misc_reg[5] = PLLX_MISC5,\n\t.iddq_reg = PLLX_MISC3,\n\t.iddq_bit_idx = PLLXP_IDDQ_BIT,\n\t.max_p = PLL_QLIN_PDIV_MAX,\n\t.mdiv_default = 2,\n\t.dyn_ramp_reg = PLLX_MISC2,\n\t.stepa_shift = 16,\n\t.stepb_shift = 24,\n\t.round_p_to_pdiv = pll_qlin_p_to_pdiv,\n\t.pdiv_tohw = pll_qlin_pdiv_to_hw,\n\t.div_nmp = &pllx_nmp,\n\t.freq_table = pll_x_freq_table,\n\t.flags = TEGRA_PLL_USE_LOCK | TEGRA_PLL_HAS_LOCK_ENABLE,\n\t.dyn_ramp = tegra210_pllx_dyn_ramp,\n\t.set_defaults = tegra210_pllx_set_defaults,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n};\n\nstatic struct div_nmp pllc_nmp = {\n\t.divm_shift = 0,\n\t.divm_width = 8,\n\t.divn_shift = 10,\n\t.divn_width = 8,\n\t.divp_shift = 20,\n\t.divp_width = 5,\n};\n\nstatic struct tegra_clk_pll_freq_table pll_cx_freq_table[] = {\n\t{ 12000000, 510000000, 85, 1, 2, 0 },\n\t{ 13000000, 510000000, 78, 1, 2, 0 },  \n\t{ 38400000, 510000000, 79, 3, 2, 0 },  \n\t{        0,         0,  0, 0, 0, 0 },\n};\n\nstatic struct tegra_clk_pll_params pll_c_params = {\n\t.input_min = 12000000,\n\t.input_max = 700000000,\n\t.cf_min = 12000000,\n\t.cf_max = 50000000,\n\t.vco_min = 600000000,\n\t.vco_max = 1200000000,\n\t.base_reg = PLLC_BASE,\n\t.misc_reg = PLLC_MISC0,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_delay = 300,\n\t.iddq_reg = PLLC_MISC1,\n\t.iddq_bit_idx = PLLCX_IDDQ_BIT,\n\t.reset_reg = PLLC_MISC0,\n\t.reset_bit_idx = PLLCX_RESET_BIT,\n\t.max_p = PLL_QLIN_PDIV_MAX,\n\t.ext_misc_reg[0] = PLLC_MISC0,\n\t.ext_misc_reg[1] = PLLC_MISC1,\n\t.ext_misc_reg[2] = PLLC_MISC2,\n\t.ext_misc_reg[3] = PLLC_MISC3,\n\t.round_p_to_pdiv = pll_qlin_p_to_pdiv,\n\t.pdiv_tohw = pll_qlin_pdiv_to_hw,\n\t.mdiv_default = 3,\n\t.div_nmp = &pllc_nmp,\n\t.freq_table = pll_cx_freq_table,\n\t.flags = TEGRA_PLL_USE_LOCK,\n\t.set_defaults = _pllc_set_defaults,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n};\n\nstatic struct div_nmp pllcx_nmp = {\n\t.divm_shift = 0,\n\t.divm_width = 8,\n\t.divn_shift = 10,\n\t.divn_width = 8,\n\t.divp_shift = 20,\n\t.divp_width = 5,\n};\n\nstatic struct tegra_clk_pll_params pll_c2_params = {\n\t.input_min = 12000000,\n\t.input_max = 700000000,\n\t.cf_min = 12000000,\n\t.cf_max = 50000000,\n\t.vco_min = 600000000,\n\t.vco_max = 1200000000,\n\t.base_reg = PLLC2_BASE,\n\t.misc_reg = PLLC2_MISC0,\n\t.iddq_reg = PLLC2_MISC1,\n\t.iddq_bit_idx = PLLCX_IDDQ_BIT,\n\t.reset_reg = PLLC2_MISC0,\n\t.reset_bit_idx = PLLCX_RESET_BIT,\n\t.lock_mask = PLLCX_BASE_LOCK,\n\t.lock_delay = 300,\n\t.round_p_to_pdiv = pll_qlin_p_to_pdiv,\n\t.pdiv_tohw = pll_qlin_pdiv_to_hw,\n\t.mdiv_default = 3,\n\t.div_nmp = &pllcx_nmp,\n\t.max_p = PLL_QLIN_PDIV_MAX,\n\t.ext_misc_reg[0] = PLLC2_MISC0,\n\t.ext_misc_reg[1] = PLLC2_MISC1,\n\t.ext_misc_reg[2] = PLLC2_MISC2,\n\t.ext_misc_reg[3] = PLLC2_MISC3,\n\t.freq_table = pll_cx_freq_table,\n\t.flags = TEGRA_PLL_USE_LOCK,\n\t.set_defaults = _pllc2_set_defaults,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n};\n\nstatic struct tegra_clk_pll_params pll_c3_params = {\n\t.input_min = 12000000,\n\t.input_max = 700000000,\n\t.cf_min = 12000000,\n\t.cf_max = 50000000,\n\t.vco_min = 600000000,\n\t.vco_max = 1200000000,\n\t.base_reg = PLLC3_BASE,\n\t.misc_reg = PLLC3_MISC0,\n\t.lock_mask = PLLCX_BASE_LOCK,\n\t.lock_delay = 300,\n\t.iddq_reg = PLLC3_MISC1,\n\t.iddq_bit_idx = PLLCX_IDDQ_BIT,\n\t.reset_reg = PLLC3_MISC0,\n\t.reset_bit_idx = PLLCX_RESET_BIT,\n\t.round_p_to_pdiv = pll_qlin_p_to_pdiv,\n\t.pdiv_tohw = pll_qlin_pdiv_to_hw,\n\t.mdiv_default = 3,\n\t.div_nmp = &pllcx_nmp,\n\t.max_p = PLL_QLIN_PDIV_MAX,\n\t.ext_misc_reg[0] = PLLC3_MISC0,\n\t.ext_misc_reg[1] = PLLC3_MISC1,\n\t.ext_misc_reg[2] = PLLC3_MISC2,\n\t.ext_misc_reg[3] = PLLC3_MISC3,\n\t.freq_table = pll_cx_freq_table,\n\t.flags = TEGRA_PLL_USE_LOCK,\n\t.set_defaults = _pllc3_set_defaults,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n};\n\nstatic struct div_nmp pllss_nmp = {\n\t.divm_shift = 0,\n\t.divm_width = 8,\n\t.divn_shift = 8,\n\t.divn_width = 8,\n\t.divp_shift = 19,\n\t.divp_width = 5,\n};\n\nstatic struct tegra_clk_pll_freq_table pll_c4_vco_freq_table[] = {\n\t{ 12000000, 600000000, 50, 1, 1, 0 },\n\t{ 13000000, 600000000, 46, 1, 1, 0 },  \n\t{ 38400000, 600000000, 62, 4, 1, 0 },  \n\t{        0,         0,  0, 0, 0, 0 },\n};\n\nstatic const struct clk_div_table pll_vco_post_div_table[] = {\n\t{ .val =  0, .div =  1 },\n\t{ .val =  1, .div =  2 },\n\t{ .val =  2, .div =  3 },\n\t{ .val =  3, .div =  4 },\n\t{ .val =  4, .div =  5 },\n\t{ .val =  5, .div =  6 },\n\t{ .val =  6, .div =  8 },\n\t{ .val =  7, .div = 10 },\n\t{ .val =  8, .div = 12 },\n\t{ .val =  9, .div = 16 },\n\t{ .val = 10, .div = 12 },\n\t{ .val = 11, .div = 16 },\n\t{ .val = 12, .div = 20 },\n\t{ .val = 13, .div = 24 },\n\t{ .val = 14, .div = 32 },\n\t{ .val =  0, .div =  0 },\n};\n\nstatic struct tegra_clk_pll_params pll_c4_vco_params = {\n\t.input_min = 9600000,\n\t.input_max = 800000000,\n\t.cf_min = 9600000,\n\t.cf_max = 19200000,\n\t.vco_min = 500000000,\n\t.vco_max = 1080000000,\n\t.base_reg = PLLC4_BASE,\n\t.misc_reg = PLLC4_MISC0,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_delay = 300,\n\t.max_p = PLL_QLIN_PDIV_MAX,\n\t.ext_misc_reg[0] = PLLC4_MISC0,\n\t.iddq_reg = PLLC4_BASE,\n\t.iddq_bit_idx = PLLSS_IDDQ_BIT,\n\t.round_p_to_pdiv = pll_qlin_p_to_pdiv,\n\t.pdiv_tohw = pll_qlin_pdiv_to_hw,\n\t.mdiv_default = 3,\n\t.div_nmp = &pllss_nmp,\n\t.freq_table = pll_c4_vco_freq_table,\n\t.set_defaults = tegra210_pllc4_set_defaults,\n\t.flags = TEGRA_PLL_USE_LOCK | TEGRA_PLL_VCO_OUT,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n};\n\nstatic struct tegra_clk_pll_freq_table pll_m_freq_table[] = {\n\t{ 12000000,  800000000,  66, 1, 1, 0 },  \n\t{ 13000000,  800000000,  61, 1, 1, 0 },  \n\t{ 38400000,  297600000,  93, 4, 3, 0 },\n\t{ 38400000,  400000000, 125, 4, 3, 0 },\n\t{ 38400000,  532800000, 111, 4, 2, 0 },\n\t{ 38400000,  665600000, 104, 3, 2, 0 },\n\t{ 38400000,  800000000, 125, 3, 2, 0 },\n\t{ 38400000,  931200000,  97, 4, 1, 0 },\n\t{ 38400000, 1065600000, 111, 4, 1, 0 },\n\t{ 38400000, 1200000000, 125, 4, 1, 0 },\n\t{ 38400000, 1331200000, 104, 3, 1, 0 },\n\t{ 38400000, 1459200000,  76, 2, 1, 0 },\n\t{ 38400000, 1600000000, 125, 3, 1, 0 },\n\t{        0,          0,   0, 0, 0, 0 },\n};\n\nstatic struct div_nmp pllm_nmp = {\n\t.divm_shift = 0,\n\t.divm_width = 8,\n\t.override_divm_shift = 0,\n\t.divn_shift = 8,\n\t.divn_width = 8,\n\t.override_divn_shift = 8,\n\t.divp_shift = 20,\n\t.divp_width = 5,\n\t.override_divp_shift = 27,\n};\n\nstatic struct tegra_clk_pll_params pll_m_params = {\n\t.input_min = 9600000,\n\t.input_max = 500000000,\n\t.cf_min = 9600000,\n\t.cf_max = 19200000,\n\t.vco_min = 800000000,\n\t.vco_max = 1866000000,\n\t.base_reg = PLLM_BASE,\n\t.misc_reg = PLLM_MISC2,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_enable_bit_idx = PLLM_MISC_LOCK_ENABLE,\n\t.lock_delay = 300,\n\t.iddq_reg = PLLM_MISC2,\n\t.iddq_bit_idx = PLLM_IDDQ_BIT,\n\t.max_p = PLL_QLIN_PDIV_MAX,\n\t.ext_misc_reg[0] = PLLM_MISC2,\n\t.ext_misc_reg[1] = PLLM_MISC1,\n\t.round_p_to_pdiv = pll_qlin_p_to_pdiv,\n\t.pdiv_tohw = pll_qlin_pdiv_to_hw,\n\t.div_nmp = &pllm_nmp,\n\t.pmc_divnm_reg = PMC_PLLM_WB0_OVERRIDE,\n\t.pmc_divp_reg = PMC_PLLM_WB0_OVERRIDE_2,\n\t.freq_table = pll_m_freq_table,\n\t.flags = TEGRA_PLL_USE_LOCK | TEGRA_PLL_HAS_LOCK_ENABLE,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n};\n\nstatic struct tegra_clk_pll_params pll_mb_params = {\n\t.input_min = 9600000,\n\t.input_max = 500000000,\n\t.cf_min = 9600000,\n\t.cf_max = 19200000,\n\t.vco_min = 800000000,\n\t.vco_max = 1866000000,\n\t.base_reg = PLLMB_BASE,\n\t.misc_reg = PLLMB_MISC1,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_delay = 300,\n\t.iddq_reg = PLLMB_MISC1,\n\t.iddq_bit_idx = PLLMB_IDDQ_BIT,\n\t.max_p = PLL_QLIN_PDIV_MAX,\n\t.ext_misc_reg[0] = PLLMB_MISC1,\n\t.round_p_to_pdiv = pll_qlin_p_to_pdiv,\n\t.pdiv_tohw = pll_qlin_pdiv_to_hw,\n\t.div_nmp = &pllm_nmp,\n\t.freq_table = pll_m_freq_table,\n\t.flags = TEGRA_PLL_USE_LOCK,\n\t.set_defaults = tegra210_pllmb_set_defaults,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n};\n\n\nstatic struct tegra_clk_pll_freq_table pll_e_freq_table[] = {\n\t \n\t{ 672000000, 100000000, 125, 42, 0, 13 },\n\t{ 624000000, 100000000, 125, 39, 0, 13 },\n\t{ 336000000, 100000000, 125, 21, 0, 13 },\n\t{ 312000000, 100000000, 200, 26, 0, 14 },\n\t{  38400000, 100000000, 125,  2, 0, 14 },\n\t{  12000000, 100000000, 200,  1, 0, 14 },\n\t{         0,         0,   0,  0, 0,  0 },\n};\n\nstatic struct div_nmp plle_nmp = {\n\t.divm_shift = 0,\n\t.divm_width = 8,\n\t.divn_shift = 8,\n\t.divn_width = 8,\n\t.divp_shift = 24,\n\t.divp_width = 5,\n};\n\nstatic struct tegra_clk_pll_params pll_e_params = {\n\t.input_min = 12000000,\n\t.input_max = 800000000,\n\t.cf_min = 12000000,\n\t.cf_max = 38400000,\n\t.vco_min = 1600000000,\n\t.vco_max = 2500000000U,\n\t.base_reg = PLLE_BASE,\n\t.misc_reg = PLLE_MISC0,\n\t.aux_reg = PLLE_AUX,\n\t.lock_mask = PLLE_MISC_LOCK,\n\t.lock_enable_bit_idx = PLLE_MISC_LOCK_ENABLE,\n\t.lock_delay = 300,\n\t.div_nmp = &plle_nmp,\n\t.freq_table = pll_e_freq_table,\n\t.flags = TEGRA_PLL_FIXED | TEGRA_PLL_LOCK_MISC | TEGRA_PLL_USE_LOCK |\n\t\t TEGRA_PLL_HAS_LOCK_ENABLE,\n\t.fixed_rate = 100000000,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n};\n\nstatic struct tegra_clk_pll_freq_table pll_re_vco_freq_table[] = {\n\t{ 12000000, 672000000, 56, 1, 1, 0 },\n\t{ 13000000, 672000000, 51, 1, 1, 0 },  \n\t{ 38400000, 672000000, 70, 4, 1, 0 },\n\t{        0,         0,  0, 0, 0, 0 },\n};\n\nstatic struct div_nmp pllre_nmp = {\n\t.divm_shift = 0,\n\t.divm_width = 8,\n\t.divn_shift = 8,\n\t.divn_width = 8,\n\t.divp_shift = 16,\n\t.divp_width = 5,\n};\n\nstatic struct tegra_clk_pll_params pll_re_vco_params = {\n\t.input_min = 9600000,\n\t.input_max = 800000000,\n\t.cf_min = 9600000,\n\t.cf_max = 19200000,\n\t.vco_min = 350000000,\n\t.vco_max = 700000000,\n\t.base_reg = PLLRE_BASE,\n\t.misc_reg = PLLRE_MISC0,\n\t.lock_mask = PLLRE_MISC_LOCK,\n\t.lock_delay = 300,\n\t.max_p = PLL_QLIN_PDIV_MAX,\n\t.ext_misc_reg[0] = PLLRE_MISC0,\n\t.iddq_reg = PLLRE_MISC0,\n\t.iddq_bit_idx = PLLRE_IDDQ_BIT,\n\t.round_p_to_pdiv = pll_qlin_p_to_pdiv,\n\t.pdiv_tohw = pll_qlin_pdiv_to_hw,\n\t.div_nmp = &pllre_nmp,\n\t.freq_table = pll_re_vco_freq_table,\n\t.flags = TEGRA_PLL_USE_LOCK | TEGRA_PLL_LOCK_MISC | TEGRA_PLL_VCO_OUT,\n\t.set_defaults = tegra210_pllre_set_defaults,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n};\n\nstatic struct div_nmp pllp_nmp = {\n\t.divm_shift = 0,\n\t.divm_width = 8,\n\t.divn_shift = 10,\n\t.divn_width = 8,\n\t.divp_shift = 20,\n\t.divp_width = 5,\n};\n\nstatic struct tegra_clk_pll_freq_table pll_p_freq_table[] = {\n\t{ 12000000, 408000000, 34, 1, 1, 0 },\n\t{ 38400000, 408000000, 85, 8, 1, 0 },  \n\t{        0,         0,  0, 0, 0, 0 },\n};\n\nstatic struct tegra_clk_pll_params pll_p_params = {\n\t.input_min = 9600000,\n\t.input_max = 800000000,\n\t.cf_min = 9600000,\n\t.cf_max = 19200000,\n\t.vco_min = 350000000,\n\t.vco_max = 700000000,\n\t.base_reg = PLLP_BASE,\n\t.misc_reg = PLLP_MISC0,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_delay = 300,\n\t.iddq_reg = PLLP_MISC0,\n\t.iddq_bit_idx = PLLXP_IDDQ_BIT,\n\t.ext_misc_reg[0] = PLLP_MISC0,\n\t.ext_misc_reg[1] = PLLP_MISC1,\n\t.div_nmp = &pllp_nmp,\n\t.freq_table = pll_p_freq_table,\n\t.fixed_rate = 408000000,\n\t.flags = TEGRA_PLL_FIXED | TEGRA_PLL_USE_LOCK | TEGRA_PLL_VCO_OUT,\n\t.set_defaults = tegra210_pllp_set_defaults,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n};\n\nstatic struct tegra_clk_pll_params pll_a1_params = {\n\t.input_min = 12000000,\n\t.input_max = 700000000,\n\t.cf_min = 12000000,\n\t.cf_max = 50000000,\n\t.vco_min = 600000000,\n\t.vco_max = 1200000000,\n\t.base_reg = PLLA1_BASE,\n\t.misc_reg = PLLA1_MISC0,\n\t.lock_mask = PLLCX_BASE_LOCK,\n\t.lock_delay = 300,\n\t.iddq_reg = PLLA1_MISC1,\n\t.iddq_bit_idx = PLLCX_IDDQ_BIT,\n\t.reset_reg = PLLA1_MISC0,\n\t.reset_bit_idx = PLLCX_RESET_BIT,\n\t.round_p_to_pdiv = pll_qlin_p_to_pdiv,\n\t.pdiv_tohw = pll_qlin_pdiv_to_hw,\n\t.div_nmp = &pllc_nmp,\n\t.ext_misc_reg[0] = PLLA1_MISC0,\n\t.ext_misc_reg[1] = PLLA1_MISC1,\n\t.ext_misc_reg[2] = PLLA1_MISC2,\n\t.ext_misc_reg[3] = PLLA1_MISC3,\n\t.freq_table = pll_cx_freq_table,\n\t.flags = TEGRA_PLL_USE_LOCK,\n\t.set_defaults = _plla1_set_defaults,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n};\n\nstatic struct div_nmp plla_nmp = {\n\t.divm_shift = 0,\n\t.divm_width = 8,\n\t.divn_shift = 8,\n\t.divn_width = 8,\n\t.divp_shift = 20,\n\t.divp_width = 5,\n};\n\nstatic struct tegra_clk_pll_freq_table pll_a_freq_table[] = {\n\t{ 12000000, 282240000, 47, 1, 2, 1, 0xf148 },  \n\t{ 12000000, 368640000, 61, 1, 2, 1, 0xfe15 },  \n\t{ 12000000, 240000000, 60, 1, 3, 1,      0 },\n\t{ 13000000, 282240000, 43, 1, 2, 1, 0xfd7d },  \n\t{ 13000000, 368640000, 56, 1, 2, 1, 0x06d8 },  \n\t{ 13000000, 240000000, 55, 1, 3, 1,      0 },  \n\t{ 38400000, 282240000, 44, 3, 2, 1, 0xf333 },  \n\t{ 38400000, 368640000, 57, 3, 2, 1, 0x0333 },  \n\t{ 38400000, 240000000, 75, 3, 3, 1,      0 },\n\t{        0,         0,  0, 0, 0, 0,      0 },\n};\n\nstatic struct tegra_clk_pll_params pll_a_params = {\n\t.input_min = 12000000,\n\t.input_max = 800000000,\n\t.cf_min = 12000000,\n\t.cf_max = 19200000,\n\t.vco_min = 500000000,\n\t.vco_max = 1000000000,\n\t.base_reg = PLLA_BASE,\n\t.misc_reg = PLLA_MISC0,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_delay = 300,\n\t.round_p_to_pdiv = pll_qlin_p_to_pdiv,\n\t.pdiv_tohw = pll_qlin_pdiv_to_hw,\n\t.iddq_reg = PLLA_BASE,\n\t.iddq_bit_idx = PLLA_IDDQ_BIT,\n\t.div_nmp = &plla_nmp,\n\t.sdm_din_reg = PLLA_MISC1,\n\t.sdm_din_mask = PLLA_SDM_DIN_MASK,\n\t.sdm_ctrl_reg = PLLA_MISC2,\n\t.sdm_ctrl_en_mask = PLLA_SDM_EN_MASK,\n\t.ext_misc_reg[0] = PLLA_MISC0,\n\t.ext_misc_reg[1] = PLLA_MISC1,\n\t.ext_misc_reg[2] = PLLA_MISC2,\n\t.freq_table = pll_a_freq_table,\n\t.flags = TEGRA_PLL_USE_LOCK | TEGRA_MDIV_NEW,\n\t.set_defaults = tegra210_plla_set_defaults,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n\t.set_gain = tegra210_clk_pll_set_gain,\n\t.adjust_vco = tegra210_clk_adjust_vco_min,\n};\n\nstatic struct div_nmp plld_nmp = {\n\t.divm_shift = 0,\n\t.divm_width = 8,\n\t.divn_shift = 11,\n\t.divn_width = 8,\n\t.divp_shift = 20,\n\t.divp_width = 3,\n};\n\nstatic struct tegra_clk_pll_freq_table pll_d_freq_table[] = {\n\t{ 12000000, 594000000, 99, 1, 2, 0,      0 },\n\t{ 13000000, 594000000, 91, 1, 2, 0, 0xfc4f },  \n\t{ 38400000, 594000000, 30, 1, 2, 0, 0x0e00 },\n\t{        0,         0,  0, 0, 0, 0,      0 },\n};\n\nstatic struct tegra_clk_pll_params pll_d_params = {\n\t.input_min = 12000000,\n\t.input_max = 800000000,\n\t.cf_min = 12000000,\n\t.cf_max = 38400000,\n\t.vco_min = 750000000,\n\t.vco_max = 1500000000,\n\t.base_reg = PLLD_BASE,\n\t.misc_reg = PLLD_MISC0,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_delay = 1000,\n\t.iddq_reg = PLLD_MISC0,\n\t.iddq_bit_idx = PLLD_IDDQ_BIT,\n\t.round_p_to_pdiv = pll_expo_p_to_pdiv,\n\t.pdiv_tohw = pll_expo_pdiv_to_hw,\n\t.div_nmp = &plld_nmp,\n\t.sdm_din_reg = PLLD_MISC0,\n\t.sdm_din_mask = PLLA_SDM_DIN_MASK,\n\t.sdm_ctrl_reg = PLLD_MISC0,\n\t.sdm_ctrl_en_mask = PLLD_SDM_EN_MASK,\n\t.ext_misc_reg[0] = PLLD_MISC0,\n\t.ext_misc_reg[1] = PLLD_MISC1,\n\t.freq_table = pll_d_freq_table,\n\t.flags = TEGRA_PLL_USE_LOCK,\n\t.mdiv_default = 1,\n\t.set_defaults = tegra210_plld_set_defaults,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n\t.set_gain = tegra210_clk_pll_set_gain,\n\t.adjust_vco = tegra210_clk_adjust_vco_min,\n};\n\nstatic struct tegra_clk_pll_freq_table tegra210_pll_d2_freq_table[] = {\n\t{ 12000000, 594000000, 99, 1, 2, 0, 0xf000 },\n\t{ 13000000, 594000000, 91, 1, 2, 0, 0xfc4f },  \n\t{ 38400000, 594000000, 30, 1, 2, 0, 0x0e00 },\n\t{        0,         0,  0, 0, 0, 0,      0 },\n};\n\n \nstatic struct tegra_clk_pll_params pll_d2_params = {\n\t.input_min = 12000000,\n\t.input_max = 800000000,\n\t.cf_min = 12000000,\n\t.cf_max = 38400000,\n\t.vco_min = 750000000,\n\t.vco_max = 1500000000,\n\t.base_reg = PLLD2_BASE,\n\t.misc_reg = PLLD2_MISC0,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_delay = 300,\n\t.iddq_reg = PLLD2_BASE,\n\t.iddq_bit_idx = PLLSS_IDDQ_BIT,\n\t.sdm_din_reg = PLLD2_MISC3,\n\t.sdm_din_mask = PLLA_SDM_DIN_MASK,\n\t.sdm_ctrl_reg = PLLD2_MISC1,\n\t.sdm_ctrl_en_mask = PLLD2_SDM_EN_MASK,\n\t \n\t.ssc_ctrl_reg = 0,\n\t.ssc_ctrl_en_mask = 0,\n\t.round_p_to_pdiv = pll_qlin_p_to_pdiv,\n\t.pdiv_tohw = pll_qlin_pdiv_to_hw,\n\t.div_nmp = &pllss_nmp,\n\t.ext_misc_reg[0] = PLLD2_MISC0,\n\t.ext_misc_reg[1] = PLLD2_MISC1,\n\t.ext_misc_reg[2] = PLLD2_MISC2,\n\t.ext_misc_reg[3] = PLLD2_MISC3,\n\t.max_p = PLL_QLIN_PDIV_MAX,\n\t.mdiv_default = 1,\n\t.freq_table = tegra210_pll_d2_freq_table,\n\t.set_defaults = tegra210_plld2_set_defaults,\n\t.flags = TEGRA_PLL_USE_LOCK,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n\t.set_gain = tegra210_clk_pll_set_gain,\n\t.adjust_vco = tegra210_clk_adjust_vco_min,\n};\n\nstatic struct tegra_clk_pll_freq_table pll_dp_freq_table[] = {\n\t{ 12000000, 270000000, 90, 1, 4, 0, 0xf000 },\n\t{ 13000000, 270000000, 83, 1, 4, 0, 0xf000 },  \n\t{ 38400000, 270000000, 28, 1, 4, 0, 0xf400 },\n\t{        0,         0,  0, 0, 0, 0,      0 },\n};\n\nstatic struct tegra_clk_pll_params pll_dp_params = {\n\t.input_min = 12000000,\n\t.input_max = 800000000,\n\t.cf_min = 12000000,\n\t.cf_max = 38400000,\n\t.vco_min = 750000000,\n\t.vco_max = 1500000000,\n\t.base_reg = PLLDP_BASE,\n\t.misc_reg = PLLDP_MISC,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_delay = 300,\n\t.iddq_reg = PLLDP_BASE,\n\t.iddq_bit_idx = PLLSS_IDDQ_BIT,\n\t.sdm_din_reg = PLLDP_SS_CTRL2,\n\t.sdm_din_mask = PLLA_SDM_DIN_MASK,\n\t.sdm_ctrl_reg = PLLDP_SS_CFG,\n\t.sdm_ctrl_en_mask = PLLDP_SDM_EN_MASK,\n\t.ssc_ctrl_reg = PLLDP_SS_CFG,\n\t.ssc_ctrl_en_mask = PLLDP_SSC_EN_MASK,\n\t.round_p_to_pdiv = pll_qlin_p_to_pdiv,\n\t.pdiv_tohw = pll_qlin_pdiv_to_hw,\n\t.div_nmp = &pllss_nmp,\n\t.ext_misc_reg[0] = PLLDP_MISC,\n\t.ext_misc_reg[1] = PLLDP_SS_CFG,\n\t.ext_misc_reg[2] = PLLDP_SS_CTRL1,\n\t.ext_misc_reg[3] = PLLDP_SS_CTRL2,\n\t.max_p = PLL_QLIN_PDIV_MAX,\n\t.mdiv_default = 1,\n\t.freq_table = pll_dp_freq_table,\n\t.set_defaults = tegra210_plldp_set_defaults,\n\t.flags = TEGRA_PLL_USE_LOCK,\n\t.calc_rate = tegra210_pll_fixed_mdiv_cfg,\n\t.set_gain = tegra210_clk_pll_set_gain,\n\t.adjust_vco = tegra210_clk_adjust_vco_min,\n};\n\nstatic struct div_nmp pllu_nmp = {\n\t.divm_shift = 0,\n\t.divm_width = 8,\n\t.divn_shift = 8,\n\t.divn_width = 8,\n\t.divp_shift = 16,\n\t.divp_width = 5,\n};\n\nstatic struct tegra_clk_pll_freq_table pll_u_freq_table[] = {\n\t{ 12000000, 480000000, 40, 1, 1, 0 },\n\t{ 13000000, 480000000, 36, 1, 1, 0 },  \n\t{ 38400000, 480000000, 25, 2, 1, 0 },\n\t{        0,         0,  0, 0, 0, 0 },\n};\n\nstatic struct tegra_clk_pll_params pll_u_vco_params = {\n\t.input_min = 9600000,\n\t.input_max = 800000000,\n\t.cf_min = 9600000,\n\t.cf_max = 19200000,\n\t.vco_min = 350000000,\n\t.vco_max = 700000000,\n\t.base_reg = PLLU_BASE,\n\t.misc_reg = PLLU_MISC0,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_delay = 1000,\n\t.iddq_reg = PLLU_MISC0,\n\t.iddq_bit_idx = PLLU_IDDQ_BIT,\n\t.ext_misc_reg[0] = PLLU_MISC0,\n\t.ext_misc_reg[1] = PLLU_MISC1,\n\t.round_p_to_pdiv = pll_qlin_p_to_pdiv,\n\t.pdiv_tohw = pll_qlin_pdiv_to_hw,\n\t.div_nmp = &pllu_nmp,\n\t.freq_table = pll_u_freq_table,\n\t.flags = TEGRA_PLLU | TEGRA_PLL_USE_LOCK | TEGRA_PLL_VCO_OUT,\n};\n\nstruct utmi_clk_param {\n\t \n\tu32 osc_frequency;\n\t \n\tu8 enable_delay_count;\n\t \n\tu16 stable_count;\n\t \n\tu8 active_delay_count;\n\t \n\tu16 xtal_freq_count;\n};\n\nstatic const struct utmi_clk_param utmi_parameters[] = {\n\t{\n\t\t.osc_frequency = 38400000, .enable_delay_count = 0x0,\n\t\t.stable_count = 0x0, .active_delay_count = 0x6,\n\t\t.xtal_freq_count = 0x80\n\t}, {\n\t\t.osc_frequency = 13000000, .enable_delay_count = 0x02,\n\t\t.stable_count = 0x33, .active_delay_count = 0x05,\n\t\t.xtal_freq_count = 0x7f\n\t}, {\n\t\t.osc_frequency = 19200000, .enable_delay_count = 0x03,\n\t\t.stable_count = 0x4b, .active_delay_count = 0x06,\n\t\t.xtal_freq_count = 0xbb\n\t}, {\n\t\t.osc_frequency = 12000000, .enable_delay_count = 0x02,\n\t\t.stable_count = 0x2f, .active_delay_count = 0x08,\n\t\t.xtal_freq_count = 0x76\n\t}, {\n\t\t.osc_frequency = 26000000, .enable_delay_count = 0x04,\n\t\t.stable_count = 0x66, .active_delay_count = 0x09,\n\t\t.xtal_freq_count = 0xfe\n\t}, {\n\t\t.osc_frequency = 16800000, .enable_delay_count = 0x03,\n\t\t.stable_count = 0x41, .active_delay_count = 0x0a,\n\t\t.xtal_freq_count = 0xa4\n\t},\n};\n\nstatic struct tegra_clk tegra210_clks[tegra_clk_max] __initdata = {\n\t[tegra_clk_ispb] = { .dt_id = TEGRA210_CLK_ISPB, .present = true },\n\t[tegra_clk_rtc] = { .dt_id = TEGRA210_CLK_RTC, .present = true },\n\t[tegra_clk_timer] = { .dt_id = TEGRA210_CLK_TIMER, .present = true },\n\t[tegra_clk_uarta_8] = { .dt_id = TEGRA210_CLK_UARTA, .present = true },\n\t[tegra_clk_i2s1] = { .dt_id = TEGRA210_CLK_I2S1, .present = true },\n\t[tegra_clk_i2c1] = { .dt_id = TEGRA210_CLK_I2C1, .present = true },\n\t[tegra_clk_sdmmc1_9] = { .dt_id = TEGRA210_CLK_SDMMC1, .present = true },\n\t[tegra_clk_pwm] = { .dt_id = TEGRA210_CLK_PWM, .present = true },\n\t[tegra_clk_i2s2] = { .dt_id = TEGRA210_CLK_I2S2, .present = true },\n\t[tegra_clk_usbd] = { .dt_id = TEGRA210_CLK_USBD, .present = true },\n\t[tegra_clk_isp_9] = { .dt_id = TEGRA210_CLK_ISP, .present = true },\n\t[tegra_clk_disp2_8] = { .dt_id = TEGRA210_CLK_DISP2, .present = true },\n\t[tegra_clk_disp1_8] = { .dt_id = TEGRA210_CLK_DISP1, .present = true },\n\t[tegra_clk_host1x_9] = { .dt_id = TEGRA210_CLK_HOST1X, .present = true },\n\t[tegra_clk_i2s0] = { .dt_id = TEGRA210_CLK_I2S0, .present = true },\n\t[tegra_clk_apbdma] = { .dt_id = TEGRA210_CLK_APBDMA, .present = true },\n\t[tegra_clk_kfuse] = { .dt_id = TEGRA210_CLK_KFUSE, .present = true },\n\t[tegra_clk_sbc1_9] = { .dt_id = TEGRA210_CLK_SBC1, .present = true },\n\t[tegra_clk_sbc2_9] = { .dt_id = TEGRA210_CLK_SBC2, .present = true },\n\t[tegra_clk_sbc3_9] = { .dt_id = TEGRA210_CLK_SBC3, .present = true },\n\t[tegra_clk_i2c5] = { .dt_id = TEGRA210_CLK_I2C5, .present = true },\n\t[tegra_clk_csi] = { .dt_id = TEGRA210_CLK_CSI, .present = true },\n\t[tegra_clk_i2c2] = { .dt_id = TEGRA210_CLK_I2C2, .present = true },\n\t[tegra_clk_uartc_8] = { .dt_id = TEGRA210_CLK_UARTC, .present = true },\n\t[tegra_clk_mipi_cal] = { .dt_id = TEGRA210_CLK_MIPI_CAL, .present = true },\n\t[tegra_clk_usb2] = { .dt_id = TEGRA210_CLK_USB2, .present = true },\n\t[tegra_clk_bsev] = { .dt_id = TEGRA210_CLK_BSEV, .present = true },\n\t[tegra_clk_uartd_8] = { .dt_id = TEGRA210_CLK_UARTD, .present = true },\n\t[tegra_clk_i2c3] = { .dt_id = TEGRA210_CLK_I2C3, .present = true },\n\t[tegra_clk_sbc4_9] = { .dt_id = TEGRA210_CLK_SBC4, .present = true },\n\t[tegra_clk_sdmmc3_9] = { .dt_id = TEGRA210_CLK_SDMMC3, .present = true },\n\t[tegra_clk_pcie] = { .dt_id = TEGRA210_CLK_PCIE, .present = true },\n\t[tegra_clk_owr_8] = { .dt_id = TEGRA210_CLK_OWR, .present = true },\n\t[tegra_clk_afi] = { .dt_id = TEGRA210_CLK_AFI, .present = true },\n\t[tegra_clk_csite_8] = { .dt_id = TEGRA210_CLK_CSITE, .present = true },\n\t[tegra_clk_soc_therm_8] = { .dt_id = TEGRA210_CLK_SOC_THERM, .present = true },\n\t[tegra_clk_dtv] = { .dt_id = TEGRA210_CLK_DTV, .present = true },\n\t[tegra_clk_i2cslow] = { .dt_id = TEGRA210_CLK_I2CSLOW, .present = true },\n\t[tegra_clk_tsec_8] = { .dt_id = TEGRA210_CLK_TSEC, .present = true },\n\t[tegra_clk_xusb_host] = { .dt_id = TEGRA210_CLK_XUSB_HOST, .present = true },\n\t[tegra_clk_csus] = { .dt_id = TEGRA210_CLK_CSUS, .present = true },\n\t[tegra_clk_mselect] = { .dt_id = TEGRA210_CLK_MSELECT, .present = true },\n\t[tegra_clk_tsensor] = { .dt_id = TEGRA210_CLK_TSENSOR, .present = true },\n\t[tegra_clk_i2s3] = { .dt_id = TEGRA210_CLK_I2S3, .present = true },\n\t[tegra_clk_i2s4] = { .dt_id = TEGRA210_CLK_I2S4, .present = true },\n\t[tegra_clk_i2c4] = { .dt_id = TEGRA210_CLK_I2C4, .present = true },\n\t[tegra_clk_d_audio] = { .dt_id = TEGRA210_CLK_D_AUDIO, .present = true },\n\t[tegra_clk_hda2codec_2x_8] = { .dt_id = TEGRA210_CLK_HDA2CODEC_2X, .present = true },\n\t[tegra_clk_spdif_2x] = { .dt_id = TEGRA210_CLK_SPDIF_2X, .present = true },\n\t[tegra_clk_actmon] = { .dt_id = TEGRA210_CLK_ACTMON, .present = true },\n\t[tegra_clk_extern1] = { .dt_id = TEGRA210_CLK_EXTERN1, .present = true },\n\t[tegra_clk_extern2] = { .dt_id = TEGRA210_CLK_EXTERN2, .present = true },\n\t[tegra_clk_extern3] = { .dt_id = TEGRA210_CLK_EXTERN3, .present = true },\n\t[tegra_clk_sata_oob_8] = { .dt_id = TEGRA210_CLK_SATA_OOB, .present = true },\n\t[tegra_clk_sata_8] = { .dt_id = TEGRA210_CLK_SATA, .present = true },\n\t[tegra_clk_hda_8] = { .dt_id = TEGRA210_CLK_HDA, .present = true },\n\t[tegra_clk_hda2hdmi] = { .dt_id = TEGRA210_CLK_HDA2HDMI, .present = true },\n\t[tegra_clk_cilab] = { .dt_id = TEGRA210_CLK_CILAB, .present = true },\n\t[tegra_clk_cilcd] = { .dt_id = TEGRA210_CLK_CILCD, .present = true },\n\t[tegra_clk_cile] = { .dt_id = TEGRA210_CLK_CILE, .present = true },\n\t[tegra_clk_dsialp] = { .dt_id = TEGRA210_CLK_DSIALP, .present = true },\n\t[tegra_clk_dsiblp] = { .dt_id = TEGRA210_CLK_DSIBLP, .present = true },\n\t[tegra_clk_entropy_8] = { .dt_id = TEGRA210_CLK_ENTROPY, .present = true },\n\t[tegra_clk_xusb_ss] = { .dt_id = TEGRA210_CLK_XUSB_SS, .present = true },\n\t[tegra_clk_i2c6] = { .dt_id = TEGRA210_CLK_I2C6, .present = true },\n\t[tegra_clk_vim2_clk] = { .dt_id = TEGRA210_CLK_VIM2_CLK, .present = true },\n\t[tegra_clk_clk72Mhz_8] = { .dt_id = TEGRA210_CLK_CLK72MHZ, .present = true },\n\t[tegra_clk_vic03_8] = { .dt_id = TEGRA210_CLK_VIC03, .present = true },\n\t[tegra_clk_dpaux] = { .dt_id = TEGRA210_CLK_DPAUX, .present = true },\n\t[tegra_clk_dpaux1] = { .dt_id = TEGRA210_CLK_DPAUX1, .present = true },\n\t[tegra_clk_sor0] = { .dt_id = TEGRA210_CLK_SOR0, .present = true },\n\t[tegra_clk_sor0_out] = { .dt_id = TEGRA210_CLK_SOR0_OUT, .present = true },\n\t[tegra_clk_sor1] = { .dt_id = TEGRA210_CLK_SOR1, .present = true },\n\t[tegra_clk_sor1_out] = { .dt_id = TEGRA210_CLK_SOR1_OUT, .present = true },\n\t[tegra_clk_gpu] = { .dt_id = TEGRA210_CLK_GPU, .present = true },\n\t[tegra_clk_pll_g_ref] = { .dt_id = TEGRA210_CLK_PLL_G_REF, .present = true, },\n\t[tegra_clk_uartb_8] = { .dt_id = TEGRA210_CLK_UARTB, .present = true },\n\t[tegra_clk_spdif_in_8] = { .dt_id = TEGRA210_CLK_SPDIF_IN, .present = true },\n\t[tegra_clk_spdif_out] = { .dt_id = TEGRA210_CLK_SPDIF_OUT, .present = true },\n\t[tegra_clk_vi_10] = { .dt_id = TEGRA210_CLK_VI, .present = true },\n\t[tegra_clk_vi_sensor_8] = { .dt_id = TEGRA210_CLK_VI_SENSOR, .present = true },\n\t[tegra_clk_fuse] = { .dt_id = TEGRA210_CLK_FUSE, .present = true },\n\t[tegra_clk_fuse_burn] = { .dt_id = TEGRA210_CLK_FUSE_BURN, .present = true },\n\t[tegra_clk_clk_32k] = { .dt_id = TEGRA210_CLK_CLK_32K, .present = true },\n\t[tegra_clk_clk_m] = { .dt_id = TEGRA210_CLK_CLK_M, .present = true },\n\t[tegra_clk_osc] = { .dt_id = TEGRA210_CLK_OSC, .present = true },\n\t[tegra_clk_osc_div2] = { .dt_id = TEGRA210_CLK_OSC_DIV2, .present = true },\n\t[tegra_clk_osc_div4] = { .dt_id = TEGRA210_CLK_OSC_DIV4, .present = true },\n\t[tegra_clk_pll_ref] = { .dt_id = TEGRA210_CLK_PLL_REF, .present = true },\n\t[tegra_clk_pll_c] = { .dt_id = TEGRA210_CLK_PLL_C, .present = true },\n\t[tegra_clk_pll_c_out1] = { .dt_id = TEGRA210_CLK_PLL_C_OUT1, .present = true },\n\t[tegra_clk_pll_c2] = { .dt_id = TEGRA210_CLK_PLL_C2, .present = true },\n\t[tegra_clk_pll_c3] = { .dt_id = TEGRA210_CLK_PLL_C3, .present = true },\n\t[tegra_clk_pll_m] = { .dt_id = TEGRA210_CLK_PLL_M, .present = true },\n\t[tegra_clk_pll_p] = { .dt_id = TEGRA210_CLK_PLL_P, .present = true },\n\t[tegra_clk_pll_p_out1] = { .dt_id = TEGRA210_CLK_PLL_P_OUT1, .present = true },\n\t[tegra_clk_pll_p_out3] = { .dt_id = TEGRA210_CLK_PLL_P_OUT3, .present = true },\n\t[tegra_clk_pll_p_out4_cpu] = { .dt_id = TEGRA210_CLK_PLL_P_OUT4, .present = true },\n\t[tegra_clk_pll_p_out_hsio] = { .dt_id = TEGRA210_CLK_PLL_P_OUT_HSIO, .present = true },\n\t[tegra_clk_pll_p_out_xusb] = { .dt_id = TEGRA210_CLK_PLL_P_OUT_XUSB, .present = true },\n\t[tegra_clk_pll_p_out_cpu] = { .dt_id = TEGRA210_CLK_PLL_P_OUT_CPU, .present = true },\n\t[tegra_clk_pll_p_out_adsp] = { .dt_id = TEGRA210_CLK_PLL_P_OUT_ADSP, .present = true },\n\t[tegra_clk_pll_a] = { .dt_id = TEGRA210_CLK_PLL_A, .present = true },\n\t[tegra_clk_pll_a_out0] = { .dt_id = TEGRA210_CLK_PLL_A_OUT0, .present = true },\n\t[tegra_clk_pll_d] = { .dt_id = TEGRA210_CLK_PLL_D, .present = true },\n\t[tegra_clk_pll_d_out0] = { .dt_id = TEGRA210_CLK_PLL_D_OUT0, .present = true },\n\t[tegra_clk_pll_d2] = { .dt_id = TEGRA210_CLK_PLL_D2, .present = true },\n\t[tegra_clk_pll_d2_out0] = { .dt_id = TEGRA210_CLK_PLL_D2_OUT0, .present = true },\n\t[tegra_clk_pll_u] = { .dt_id = TEGRA210_CLK_PLL_U, .present = true },\n\t[tegra_clk_pll_u_out] = { .dt_id = TEGRA210_CLK_PLL_U_OUT, .present = true },\n\t[tegra_clk_pll_u_out1] = { .dt_id = TEGRA210_CLK_PLL_U_OUT1, .present = true },\n\t[tegra_clk_pll_u_out2] = { .dt_id = TEGRA210_CLK_PLL_U_OUT2, .present = true },\n\t[tegra_clk_pll_u_480m] = { .dt_id = TEGRA210_CLK_PLL_U_480M, .present = true },\n\t[tegra_clk_pll_u_60m] = { .dt_id = TEGRA210_CLK_PLL_U_60M, .present = true },\n\t[tegra_clk_pll_u_48m] = { .dt_id = TEGRA210_CLK_PLL_U_48M, .present = true },\n\t[tegra_clk_pll_x] = { .dt_id = TEGRA210_CLK_PLL_X, .present = true },\n\t[tegra_clk_pll_x_out0] = { .dt_id = TEGRA210_CLK_PLL_X_OUT0, .present = true },\n\t[tegra_clk_pll_re_vco] = { .dt_id = TEGRA210_CLK_PLL_RE_VCO, .present = true },\n\t[tegra_clk_pll_re_out] = { .dt_id = TEGRA210_CLK_PLL_RE_OUT, .present = true },\n\t[tegra_clk_spdif_in_sync] = { .dt_id = TEGRA210_CLK_SPDIF_IN_SYNC, .present = true },\n\t[tegra_clk_i2s0_sync] = { .dt_id = TEGRA210_CLK_I2S0_SYNC, .present = true },\n\t[tegra_clk_i2s1_sync] = { .dt_id = TEGRA210_CLK_I2S1_SYNC, .present = true },\n\t[tegra_clk_i2s2_sync] = { .dt_id = TEGRA210_CLK_I2S2_SYNC, .present = true },\n\t[tegra_clk_i2s3_sync] = { .dt_id = TEGRA210_CLK_I2S3_SYNC, .present = true },\n\t[tegra_clk_i2s4_sync] = { .dt_id = TEGRA210_CLK_I2S4_SYNC, .present = true },\n\t[tegra_clk_vimclk_sync] = { .dt_id = TEGRA210_CLK_VIMCLK_SYNC, .present = true },\n\t[tegra_clk_audio0] = { .dt_id = TEGRA210_CLK_AUDIO0, .present = true },\n\t[tegra_clk_audio1] = { .dt_id = TEGRA210_CLK_AUDIO1, .present = true },\n\t[tegra_clk_audio2] = { .dt_id = TEGRA210_CLK_AUDIO2, .present = true },\n\t[tegra_clk_audio3] = { .dt_id = TEGRA210_CLK_AUDIO3, .present = true },\n\t[tegra_clk_audio4] = { .dt_id = TEGRA210_CLK_AUDIO4, .present = true },\n\t[tegra_clk_spdif] = { .dt_id = TEGRA210_CLK_SPDIF, .present = true },\n\t[tegra_clk_xusb_gate] = { .dt_id = TEGRA210_CLK_XUSB_GATE, .present = true },\n\t[tegra_clk_xusb_host_src_8] = { .dt_id = TEGRA210_CLK_XUSB_HOST_SRC, .present = true },\n\t[tegra_clk_xusb_falcon_src_8] = { .dt_id = TEGRA210_CLK_XUSB_FALCON_SRC, .present = true },\n\t[tegra_clk_xusb_fs_src] = { .dt_id = TEGRA210_CLK_XUSB_FS_SRC, .present = true },\n\t[tegra_clk_xusb_ss_src_8] = { .dt_id = TEGRA210_CLK_XUSB_SS_SRC, .present = true },\n\t[tegra_clk_xusb_ss_div2] = { .dt_id = TEGRA210_CLK_XUSB_SS_DIV2, .present = true },\n\t[tegra_clk_xusb_dev_src_8] = { .dt_id = TEGRA210_CLK_XUSB_DEV_SRC, .present = true },\n\t[tegra_clk_xusb_dev] = { .dt_id = TEGRA210_CLK_XUSB_DEV, .present = true },\n\t[tegra_clk_xusb_hs_src_4] = { .dt_id = TEGRA210_CLK_XUSB_HS_SRC, .present = true },\n\t[tegra_clk_xusb_ssp_src] = { .dt_id = TEGRA210_CLK_XUSB_SSP_SRC, .present = true },\n\t[tegra_clk_usb2_hsic_trk] = { .dt_id = TEGRA210_CLK_USB2_HSIC_TRK, .present = true },\n\t[tegra_clk_hsic_trk] = { .dt_id = TEGRA210_CLK_HSIC_TRK, .present = true },\n\t[tegra_clk_usb2_trk] = { .dt_id = TEGRA210_CLK_USB2_TRK, .present = true },\n\t[tegra_clk_sclk] = { .dt_id = TEGRA210_CLK_SCLK, .present = true },\n\t[tegra_clk_sclk_mux] = { .dt_id = TEGRA210_CLK_SCLK_MUX, .present = true },\n\t[tegra_clk_hclk] = { .dt_id = TEGRA210_CLK_HCLK, .present = true },\n\t[tegra_clk_pclk] = { .dt_id = TEGRA210_CLK_PCLK, .present = true },\n\t[tegra_clk_cclk_g] = { .dt_id = TEGRA210_CLK_CCLK_G, .present = true },\n\t[tegra_clk_cclk_lp] = { .dt_id = TEGRA210_CLK_CCLK_LP, .present = true },\n\t[tegra_clk_dfll_ref] = { .dt_id = TEGRA210_CLK_DFLL_REF, .present = true },\n\t[tegra_clk_dfll_soc] = { .dt_id = TEGRA210_CLK_DFLL_SOC, .present = true },\n\t[tegra_clk_vi_sensor2_8] = { .dt_id = TEGRA210_CLK_VI_SENSOR2, .present = true },\n\t[tegra_clk_pll_p_out5] = { .dt_id = TEGRA210_CLK_PLL_P_OUT5, .present = true },\n\t[tegra_clk_pll_c4] = { .dt_id = TEGRA210_CLK_PLL_C4, .present = true },\n\t[tegra_clk_pll_dp] = { .dt_id = TEGRA210_CLK_PLL_DP, .present = true },\n\t[tegra_clk_audio0_mux] = { .dt_id = TEGRA210_CLK_AUDIO0_MUX, .present = true },\n\t[tegra_clk_audio1_mux] = { .dt_id = TEGRA210_CLK_AUDIO1_MUX, .present = true },\n\t[tegra_clk_audio2_mux] = { .dt_id = TEGRA210_CLK_AUDIO2_MUX, .present = true },\n\t[tegra_clk_audio3_mux] = { .dt_id = TEGRA210_CLK_AUDIO3_MUX, .present = true },\n\t[tegra_clk_audio4_mux] = { .dt_id = TEGRA210_CLK_AUDIO4_MUX, .present = true },\n\t[tegra_clk_spdif_mux] = { .dt_id = TEGRA210_CLK_SPDIF_MUX, .present = true },\n\t[tegra_clk_maud] = { .dt_id = TEGRA210_CLK_MAUD, .present = true },\n\t[tegra_clk_mipibif] = { .dt_id = TEGRA210_CLK_MIPIBIF, .present = true },\n\t[tegra_clk_qspi] = { .dt_id = TEGRA210_CLK_QSPI, .present = true },\n\t[tegra_clk_sdmmc_legacy] = { .dt_id = TEGRA210_CLK_SDMMC_LEGACY, .present = true },\n\t[tegra_clk_tsecb] = { .dt_id = TEGRA210_CLK_TSECB, .present = true },\n\t[tegra_clk_uartape] = { .dt_id = TEGRA210_CLK_UARTAPE, .present = true },\n\t[tegra_clk_vi_i2c] = { .dt_id = TEGRA210_CLK_VI_I2C, .present = true },\n\t[tegra_clk_ape] = { .dt_id = TEGRA210_CLK_APE, .present = true },\n\t[tegra_clk_dbgapb] = { .dt_id = TEGRA210_CLK_DBGAPB, .present = true },\n\t[tegra_clk_nvdec] = { .dt_id = TEGRA210_CLK_NVDEC, .present = true },\n\t[tegra_clk_nvenc] = { .dt_id = TEGRA210_CLK_NVENC, .present = true },\n\t[tegra_clk_nvjpg] = { .dt_id = TEGRA210_CLK_NVJPG, .present = true },\n\t[tegra_clk_pll_c4_out0] = { .dt_id = TEGRA210_CLK_PLL_C4_OUT0, .present = true },\n\t[tegra_clk_pll_c4_out1] = { .dt_id = TEGRA210_CLK_PLL_C4_OUT1, .present = true },\n\t[tegra_clk_pll_c4_out2] = { .dt_id = TEGRA210_CLK_PLL_C4_OUT2, .present = true },\n\t[tegra_clk_pll_c4_out3] = { .dt_id = TEGRA210_CLK_PLL_C4_OUT3, .present = true },\n\t[tegra_clk_apb2ape] = { .dt_id = TEGRA210_CLK_APB2APE, .present = true },\n\t[tegra_clk_pll_a1] = { .dt_id = TEGRA210_CLK_PLL_A1, .present = true },\n\t[tegra_clk_ispa] = { .dt_id = TEGRA210_CLK_ISPA, .present = true },\n\t[tegra_clk_cec] = { .dt_id = TEGRA210_CLK_CEC, .present = true },\n\t[tegra_clk_dmic1] = { .dt_id = TEGRA210_CLK_DMIC1, .present = true },\n\t[tegra_clk_dmic2] = { .dt_id = TEGRA210_CLK_DMIC2, .present = true },\n\t[tegra_clk_dmic3] = { .dt_id = TEGRA210_CLK_DMIC3, .present = true },\n\t[tegra_clk_dmic1_sync_clk] = { .dt_id = TEGRA210_CLK_DMIC1_SYNC_CLK, .present = true },\n\t[tegra_clk_dmic2_sync_clk] = { .dt_id = TEGRA210_CLK_DMIC2_SYNC_CLK, .present = true },\n\t[tegra_clk_dmic3_sync_clk] = { .dt_id = TEGRA210_CLK_DMIC3_SYNC_CLK, .present = true },\n\t[tegra_clk_dmic1_sync_clk_mux] = { .dt_id = TEGRA210_CLK_DMIC1_SYNC_CLK_MUX, .present = true },\n\t[tegra_clk_dmic2_sync_clk_mux] = { .dt_id = TEGRA210_CLK_DMIC2_SYNC_CLK_MUX, .present = true },\n\t[tegra_clk_dmic3_sync_clk_mux] = { .dt_id = TEGRA210_CLK_DMIC3_SYNC_CLK_MUX, .present = true },\n\t[tegra_clk_dp2] = { .dt_id = TEGRA210_CLK_DP2, .present = true },\n\t[tegra_clk_iqc1] = { .dt_id = TEGRA210_CLK_IQC1, .present = true },\n\t[tegra_clk_iqc2] = { .dt_id = TEGRA210_CLK_IQC2, .present = true },\n\t[tegra_clk_pll_a_out_adsp] = { .dt_id = TEGRA210_CLK_PLL_A_OUT_ADSP, .present = true },\n\t[tegra_clk_pll_a_out0_out_adsp] = { .dt_id = TEGRA210_CLK_PLL_A_OUT0_OUT_ADSP, .present = true },\n\t[tegra_clk_adsp] = { .dt_id = TEGRA210_CLK_ADSP, .present = true },\n\t[tegra_clk_adsp_neon] = { .dt_id = TEGRA210_CLK_ADSP_NEON, .present = true },\n};\n\nstatic struct tegra_devclk devclks[] __initdata = {\n\t{ .con_id = \"clk_m\", .dt_id = TEGRA210_CLK_CLK_M },\n\t{ .con_id = \"pll_ref\", .dt_id = TEGRA210_CLK_PLL_REF },\n\t{ .con_id = \"clk_32k\", .dt_id = TEGRA210_CLK_CLK_32K },\n\t{ .con_id = \"osc\", .dt_id = TEGRA210_CLK_OSC },\n\t{ .con_id = \"osc_div2\", .dt_id = TEGRA210_CLK_OSC_DIV2 },\n\t{ .con_id = \"osc_div4\", .dt_id = TEGRA210_CLK_OSC_DIV4 },\n\t{ .con_id = \"pll_c\", .dt_id = TEGRA210_CLK_PLL_C },\n\t{ .con_id = \"pll_c_out1\", .dt_id = TEGRA210_CLK_PLL_C_OUT1 },\n\t{ .con_id = \"pll_c2\", .dt_id = TEGRA210_CLK_PLL_C2 },\n\t{ .con_id = \"pll_c3\", .dt_id = TEGRA210_CLK_PLL_C3 },\n\t{ .con_id = \"pll_p\", .dt_id = TEGRA210_CLK_PLL_P },\n\t{ .con_id = \"pll_p_out1\", .dt_id = TEGRA210_CLK_PLL_P_OUT1 },\n\t{ .con_id = \"pll_p_out2\", .dt_id = TEGRA210_CLK_PLL_P_OUT2 },\n\t{ .con_id = \"pll_p_out3\", .dt_id = TEGRA210_CLK_PLL_P_OUT3 },\n\t{ .con_id = \"pll_p_out4\", .dt_id = TEGRA210_CLK_PLL_P_OUT4 },\n\t{ .con_id = \"pll_m\", .dt_id = TEGRA210_CLK_PLL_M },\n\t{ .con_id = \"pll_x\", .dt_id = TEGRA210_CLK_PLL_X },\n\t{ .con_id = \"pll_x_out0\", .dt_id = TEGRA210_CLK_PLL_X_OUT0 },\n\t{ .con_id = \"pll_u\", .dt_id = TEGRA210_CLK_PLL_U },\n\t{ .con_id = \"pll_u_out\", .dt_id = TEGRA210_CLK_PLL_U_OUT },\n\t{ .con_id = \"pll_u_out1\", .dt_id = TEGRA210_CLK_PLL_U_OUT1 },\n\t{ .con_id = \"pll_u_out2\", .dt_id = TEGRA210_CLK_PLL_U_OUT2 },\n\t{ .con_id = \"pll_u_480M\", .dt_id = TEGRA210_CLK_PLL_U_480M },\n\t{ .con_id = \"pll_u_60M\", .dt_id = TEGRA210_CLK_PLL_U_60M },\n\t{ .con_id = \"pll_u_48M\", .dt_id = TEGRA210_CLK_PLL_U_48M },\n\t{ .con_id = \"pll_d\", .dt_id = TEGRA210_CLK_PLL_D },\n\t{ .con_id = \"pll_d_out0\", .dt_id = TEGRA210_CLK_PLL_D_OUT0 },\n\t{ .con_id = \"pll_d2\", .dt_id = TEGRA210_CLK_PLL_D2 },\n\t{ .con_id = \"pll_d2_out0\", .dt_id = TEGRA210_CLK_PLL_D2_OUT0 },\n\t{ .con_id = \"pll_a\", .dt_id = TEGRA210_CLK_PLL_A },\n\t{ .con_id = \"pll_a_out0\", .dt_id = TEGRA210_CLK_PLL_A_OUT0 },\n\t{ .con_id = \"pll_re_vco\", .dt_id = TEGRA210_CLK_PLL_RE_VCO },\n\t{ .con_id = \"pll_re_out\", .dt_id = TEGRA210_CLK_PLL_RE_OUT },\n\t{ .con_id = \"spdif_in_sync\", .dt_id = TEGRA210_CLK_SPDIF_IN_SYNC },\n\t{ .con_id = \"i2s0_sync\", .dt_id = TEGRA210_CLK_I2S0_SYNC },\n\t{ .con_id = \"i2s1_sync\", .dt_id = TEGRA210_CLK_I2S1_SYNC },\n\t{ .con_id = \"i2s2_sync\", .dt_id = TEGRA210_CLK_I2S2_SYNC },\n\t{ .con_id = \"i2s3_sync\", .dt_id = TEGRA210_CLK_I2S3_SYNC },\n\t{ .con_id = \"i2s4_sync\", .dt_id = TEGRA210_CLK_I2S4_SYNC },\n\t{ .con_id = \"vimclk_sync\", .dt_id = TEGRA210_CLK_VIMCLK_SYNC },\n\t{ .con_id = \"audio0\", .dt_id = TEGRA210_CLK_AUDIO0 },\n\t{ .con_id = \"audio1\", .dt_id = TEGRA210_CLK_AUDIO1 },\n\t{ .con_id = \"audio2\", .dt_id = TEGRA210_CLK_AUDIO2 },\n\t{ .con_id = \"audio3\", .dt_id = TEGRA210_CLK_AUDIO3 },\n\t{ .con_id = \"audio4\", .dt_id = TEGRA210_CLK_AUDIO4 },\n\t{ .con_id = \"spdif\", .dt_id = TEGRA210_CLK_SPDIF },\n\t{ .con_id = \"spdif_2x\", .dt_id = TEGRA210_CLK_SPDIF_2X },\n\t{ .con_id = \"extern1\", .dt_id = TEGRA210_CLK_EXTERN1 },\n\t{ .con_id = \"extern2\", .dt_id = TEGRA210_CLK_EXTERN2 },\n\t{ .con_id = \"extern3\", .dt_id = TEGRA210_CLK_EXTERN3 },\n\t{ .con_id = \"cclk_g\", .dt_id = TEGRA210_CLK_CCLK_G },\n\t{ .con_id = \"cclk_lp\", .dt_id = TEGRA210_CLK_CCLK_LP },\n\t{ .con_id = \"sclk\", .dt_id = TEGRA210_CLK_SCLK },\n\t{ .con_id = \"hclk\", .dt_id = TEGRA210_CLK_HCLK },\n\t{ .con_id = \"pclk\", .dt_id = TEGRA210_CLK_PCLK },\n\t{ .con_id = \"fuse\", .dt_id = TEGRA210_CLK_FUSE },\n\t{ .dev_id = \"rtc-tegra\", .dt_id = TEGRA210_CLK_RTC },\n\t{ .dev_id = \"timer\", .dt_id = TEGRA210_CLK_TIMER },\n\t{ .con_id = \"pll_c4_out0\", .dt_id = TEGRA210_CLK_PLL_C4_OUT0 },\n\t{ .con_id = \"pll_c4_out1\", .dt_id = TEGRA210_CLK_PLL_C4_OUT1 },\n\t{ .con_id = \"pll_c4_out2\", .dt_id = TEGRA210_CLK_PLL_C4_OUT2 },\n\t{ .con_id = \"pll_c4_out3\", .dt_id = TEGRA210_CLK_PLL_C4_OUT3 },\n\t{ .con_id = \"dpaux\", .dt_id = TEGRA210_CLK_DPAUX },\n};\n\nstatic struct tegra_audio_clk_info tegra210_audio_plls[] = {\n\t{ \"pll_a\", &pll_a_params, tegra_clk_pll_a, \"pll_ref\" },\n\t{ \"pll_a1\", &pll_a1_params, tegra_clk_pll_a1, \"pll_ref\" },\n};\n\nstatic const char * const aclk_parents[] = {\n\t\"pll_a1\", \"pll_c\", \"pll_p\", \"pll_a_out0\", \"pll_c2\", \"pll_c3\",\n\t\"clk_m\"\n};\n\nstatic const unsigned int nvjpg_slcg_clkids[] = { TEGRA210_CLK_NVDEC };\nstatic const unsigned int nvdec_slcg_clkids[] = { TEGRA210_CLK_NVJPG };\nstatic const unsigned int sor_slcg_clkids[] = { TEGRA210_CLK_HDA2CODEC_2X,\n\tTEGRA210_CLK_HDA2HDMI, TEGRA210_CLK_DISP1, TEGRA210_CLK_DISP2 };\nstatic const unsigned int disp_slcg_clkids[] = { TEGRA210_CLK_LA,\n\tTEGRA210_CLK_HOST1X};\nstatic const unsigned int xusba_slcg_clkids[] = { TEGRA210_CLK_XUSB_HOST,\n\tTEGRA210_CLK_XUSB_DEV };\nstatic const unsigned int xusbb_slcg_clkids[] = { TEGRA210_CLK_XUSB_HOST,\n\tTEGRA210_CLK_XUSB_SS };\nstatic const unsigned int xusbc_slcg_clkids[] = { TEGRA210_CLK_XUSB_DEV,\n\tTEGRA210_CLK_XUSB_SS };\nstatic const unsigned int venc_slcg_clkids[] = { TEGRA210_CLK_HOST1X,\n\tTEGRA210_CLK_PLL_D };\nstatic const unsigned int ape_slcg_clkids[] = { TEGRA210_CLK_ACLK,\n\tTEGRA210_CLK_I2S0, TEGRA210_CLK_I2S1, TEGRA210_CLK_I2S2,\n\tTEGRA210_CLK_I2S3, TEGRA210_CLK_I2S4, TEGRA210_CLK_SPDIF_OUT,\n\tTEGRA210_CLK_D_AUDIO };\nstatic const unsigned int vic_slcg_clkids[] = { TEGRA210_CLK_HOST1X };\n\nstatic struct tegra210_domain_mbist_war tegra210_pg_mbist_war[] = {\n\t[TEGRA_POWERGATE_VENC] = {\n\t\t.handle_lvl2_ovr = tegra210_venc_mbist_war,\n\t\t.num_clks = ARRAY_SIZE(venc_slcg_clkids),\n\t\t.clk_init_data = venc_slcg_clkids,\n\t},\n\t[TEGRA_POWERGATE_SATA] = {\n\t\t.handle_lvl2_ovr = tegra210_generic_mbist_war,\n\t\t.lvl2_offset = LVL2_CLK_GATE_OVRC,\n\t\t.lvl2_mask = BIT(0) | BIT(17) | BIT(19),\n\t},\n\t[TEGRA_POWERGATE_MPE] = {\n\t\t.handle_lvl2_ovr = tegra210_generic_mbist_war,\n\t\t.lvl2_offset = LVL2_CLK_GATE_OVRE,\n\t\t.lvl2_mask = BIT(29),\n\t},\n\t[TEGRA_POWERGATE_SOR] = {\n\t\t.handle_lvl2_ovr = tegra210_generic_mbist_war,\n\t\t.num_clks = ARRAY_SIZE(sor_slcg_clkids),\n\t\t.clk_init_data = sor_slcg_clkids,\n\t\t.lvl2_offset = LVL2_CLK_GATE_OVRA,\n\t\t.lvl2_mask = BIT(1) | BIT(2),\n\t},\n\t[TEGRA_POWERGATE_DIS] = {\n\t\t.handle_lvl2_ovr = tegra210_disp_mbist_war,\n\t\t.num_clks = ARRAY_SIZE(disp_slcg_clkids),\n\t\t.clk_init_data = disp_slcg_clkids,\n\t},\n\t[TEGRA_POWERGATE_DISB] = {\n\t\t.num_clks = ARRAY_SIZE(disp_slcg_clkids),\n\t\t.clk_init_data = disp_slcg_clkids,\n\t\t.handle_lvl2_ovr = tegra210_generic_mbist_war,\n\t\t.lvl2_offset = LVL2_CLK_GATE_OVRA,\n\t\t.lvl2_mask = BIT(2),\n\t},\n\t[TEGRA_POWERGATE_XUSBA] = {\n\t\t.num_clks = ARRAY_SIZE(xusba_slcg_clkids),\n\t\t.clk_init_data = xusba_slcg_clkids,\n\t\t.handle_lvl2_ovr = tegra210_generic_mbist_war,\n\t\t.lvl2_offset = LVL2_CLK_GATE_OVRC,\n\t\t.lvl2_mask = BIT(30) | BIT(31),\n\t},\n\t[TEGRA_POWERGATE_XUSBB] = {\n\t\t.num_clks = ARRAY_SIZE(xusbb_slcg_clkids),\n\t\t.clk_init_data = xusbb_slcg_clkids,\n\t\t.handle_lvl2_ovr = tegra210_generic_mbist_war,\n\t\t.lvl2_offset = LVL2_CLK_GATE_OVRC,\n\t\t.lvl2_mask = BIT(30) | BIT(31),\n\t},\n\t[TEGRA_POWERGATE_XUSBC] = {\n\t\t.num_clks = ARRAY_SIZE(xusbc_slcg_clkids),\n\t\t.clk_init_data = xusbc_slcg_clkids,\n\t\t.handle_lvl2_ovr = tegra210_generic_mbist_war,\n\t\t.lvl2_offset = LVL2_CLK_GATE_OVRC,\n\t\t.lvl2_mask = BIT(30) | BIT(31),\n\t},\n\t[TEGRA_POWERGATE_VIC] = {\n\t\t.num_clks = ARRAY_SIZE(vic_slcg_clkids),\n\t\t.clk_init_data = vic_slcg_clkids,\n\t\t.handle_lvl2_ovr = tegra210_vic_mbist_war,\n\t},\n\t[TEGRA_POWERGATE_NVDEC] = {\n\t\t.num_clks = ARRAY_SIZE(nvdec_slcg_clkids),\n\t\t.clk_init_data = nvdec_slcg_clkids,\n\t\t.handle_lvl2_ovr = tegra210_generic_mbist_war,\n\t\t.lvl2_offset = LVL2_CLK_GATE_OVRE,\n\t\t.lvl2_mask = BIT(9) | BIT(31),\n\t},\n\t[TEGRA_POWERGATE_NVJPG] = {\n\t\t.num_clks = ARRAY_SIZE(nvjpg_slcg_clkids),\n\t\t.clk_init_data = nvjpg_slcg_clkids,\n\t\t.handle_lvl2_ovr = tegra210_generic_mbist_war,\n\t\t.lvl2_offset = LVL2_CLK_GATE_OVRE,\n\t\t.lvl2_mask = BIT(9) | BIT(31),\n\t},\n\t[TEGRA_POWERGATE_AUD] = {\n\t\t.num_clks = ARRAY_SIZE(ape_slcg_clkids),\n\t\t.clk_init_data = ape_slcg_clkids,\n\t\t.handle_lvl2_ovr = tegra210_ape_mbist_war,\n\t},\n\t[TEGRA_POWERGATE_VE2] = {\n\t\t.handle_lvl2_ovr = tegra210_generic_mbist_war,\n\t\t.lvl2_offset = LVL2_CLK_GATE_OVRD,\n\t\t.lvl2_mask = BIT(22),\n\t},\n};\n\nint tegra210_clk_handle_mbist_war(unsigned int id)\n{\n\tint err;\n\tstruct tegra210_domain_mbist_war *mbist_war;\n\n\tif (id >= ARRAY_SIZE(tegra210_pg_mbist_war)) {\n\t\tWARN(1, \"unknown domain id in MBIST WAR handler\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmbist_war = &tegra210_pg_mbist_war[id];\n\tif (!mbist_war->handle_lvl2_ovr)\n\t\treturn 0;\n\n\tif (mbist_war->num_clks && !mbist_war->clks)\n\t\treturn -ENODEV;\n\n\terr = clk_bulk_prepare_enable(mbist_war->num_clks, mbist_war->clks);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&lvl2_ovr_lock);\n\n\tmbist_war->handle_lvl2_ovr(mbist_war);\n\n\tmutex_unlock(&lvl2_ovr_lock);\n\n\tclk_bulk_disable_unprepare(mbist_war->num_clks, mbist_war->clks);\n\n\treturn 0;\n}\n\nvoid tegra210_put_utmipll_in_iddq(void)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(clk_base + UTMIPLL_HW_PWRDN_CFG0);\n\n\tif (reg & UTMIPLL_HW_PWRDN_CFG0_UTMIPLL_LOCK) {\n\t\tpr_err(\"trying to assert IDDQ while UTMIPLL is locked\\n\");\n\t\treturn;\n\t}\n\n\treg |= UTMIPLL_HW_PWRDN_CFG0_IDDQ_OVERRIDE;\n\twritel_relaxed(reg, clk_base + UTMIPLL_HW_PWRDN_CFG0);\n}\nEXPORT_SYMBOL_GPL(tegra210_put_utmipll_in_iddq);\n\nvoid tegra210_put_utmipll_out_iddq(void)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(clk_base + UTMIPLL_HW_PWRDN_CFG0);\n\treg &= ~UTMIPLL_HW_PWRDN_CFG0_IDDQ_OVERRIDE;\n\twritel_relaxed(reg, clk_base + UTMIPLL_HW_PWRDN_CFG0);\n}\nEXPORT_SYMBOL_GPL(tegra210_put_utmipll_out_iddq);\n\nstatic void tegra210_utmi_param_configure(void)\n{\n\tu32 reg;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(utmi_parameters); i++) {\n\t\tif (osc_freq == utmi_parameters[i].osc_frequency)\n\t\t\tbreak;\n\t}\n\n\tif (i >= ARRAY_SIZE(utmi_parameters)) {\n\t\tpr_err(\"%s: Unexpected oscillator freq %lu\\n\", __func__,\n\t\t\tosc_freq);\n\t\treturn;\n\t}\n\n\treg = readl_relaxed(clk_base + UTMIPLL_HW_PWRDN_CFG0);\n\treg &= ~UTMIPLL_HW_PWRDN_CFG0_IDDQ_OVERRIDE;\n\twritel_relaxed(reg, clk_base + UTMIPLL_HW_PWRDN_CFG0);\n\n\tudelay(10);\n\n\treg = readl_relaxed(clk_base + UTMIP_PLL_CFG2);\n\n\t \n\t \n\treg &= ~UTMIP_PLL_CFG2_STABLE_COUNT(~0);\n\treg |= UTMIP_PLL_CFG2_STABLE_COUNT(utmi_parameters[i].stable_count);\n\n\treg &= ~UTMIP_PLL_CFG2_ACTIVE_DLY_COUNT(~0);\n\treg |=\n\tUTMIP_PLL_CFG2_ACTIVE_DLY_COUNT(utmi_parameters[i].active_delay_count);\n\twritel_relaxed(reg, clk_base + UTMIP_PLL_CFG2);\n\n\t \n\treg = readl_relaxed(clk_base + UTMIP_PLL_CFG1);\n\n\treg &= ~UTMIP_PLL_CFG1_ENABLE_DLY_COUNT(~0);\n\treg |=\n\tUTMIP_PLL_CFG1_ENABLE_DLY_COUNT(utmi_parameters[i].enable_delay_count);\n\n\treg &= ~UTMIP_PLL_CFG1_XTAL_FREQ_COUNT(~0);\n\treg |=\n\tUTMIP_PLL_CFG1_XTAL_FREQ_COUNT(utmi_parameters[i].xtal_freq_count);\n\n\treg |= UTMIP_PLL_CFG1_FORCE_PLLU_POWERDOWN;\n\twritel_relaxed(reg, clk_base + UTMIP_PLL_CFG1);\n\n\t \n\treg = readl_relaxed(clk_base + UTMIP_PLL_CFG1);\n\treg &= ~UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERDOWN;\n\treg |= UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERUP;\n\twritel_relaxed(reg, clk_base + UTMIP_PLL_CFG1);\n\n\tudelay(20);\n\n\t \n\treg = readl_relaxed(clk_base + UTMIP_PLL_CFG2);\n\treg |= UTMIP_PLL_CFG2_FORCE_PD_SAMP_A_POWERUP;\n\treg |= UTMIP_PLL_CFG2_FORCE_PD_SAMP_B_POWERUP;\n\treg |= UTMIP_PLL_CFG2_FORCE_PD_SAMP_D_POWERUP;\n\treg &= ~UTMIP_PLL_CFG2_FORCE_PD_SAMP_A_POWERDOWN;\n\treg &= ~UTMIP_PLL_CFG2_FORCE_PD_SAMP_B_POWERDOWN;\n\treg &= ~UTMIP_PLL_CFG2_FORCE_PD_SAMP_D_POWERDOWN;\n\twritel_relaxed(reg, clk_base + UTMIP_PLL_CFG2);\n\n\t \n\treg = readl_relaxed(clk_base + UTMIP_PLL_CFG1);\n\treg &= ~UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERDOWN;\n\treg &= ~UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERUP;\n\twritel_relaxed(reg, clk_base + UTMIP_PLL_CFG1);\n\n\treg = readl_relaxed(clk_base + UTMIPLL_HW_PWRDN_CFG0);\n\treg |= UTMIPLL_HW_PWRDN_CFG0_USE_LOCKDET;\n\treg &= ~UTMIPLL_HW_PWRDN_CFG0_CLK_ENABLE_SWCTL;\n\twritel_relaxed(reg, clk_base + UTMIPLL_HW_PWRDN_CFG0);\n\n\tudelay(1);\n\n\treg = readl_relaxed(clk_base + XUSB_PLL_CFG0);\n\treg &= ~XUSB_PLL_CFG0_UTMIPLL_LOCK_DLY;\n\twritel_relaxed(reg, clk_base + XUSB_PLL_CFG0);\n\n\tudelay(1);\n\n\t \n\treg = readl_relaxed(clk_base + UTMIPLL_HW_PWRDN_CFG0);\n\treg |= UTMIPLL_HW_PWRDN_CFG0_SEQ_ENABLE;\n\twritel_relaxed(reg, clk_base + UTMIPLL_HW_PWRDN_CFG0);\n}\n\nstatic int tegra210_enable_pllu(void)\n{\n\tstruct tegra_clk_pll_freq_table *fentry;\n\tstruct tegra_clk_pll pllu;\n\tu32 reg;\n\tint ret;\n\n\tfor (fentry = pll_u_freq_table; fentry->input_rate; fentry++) {\n\t\tif (fentry->input_rate == pll_ref_freq)\n\t\t\tbreak;\n\t}\n\n\tif (!fentry->input_rate) {\n\t\tpr_err(\"Unknown PLL_U reference frequency %lu\\n\", pll_ref_freq);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpllu.params = &pll_u_vco_params;\n\treg = readl_relaxed(clk_base + pllu.params->ext_misc_reg[0]);\n\treg &= ~BIT(pllu.params->iddq_bit_idx);\n\twritel_relaxed(reg, clk_base + pllu.params->ext_misc_reg[0]);\n\tfence_udelay(5, clk_base);\n\n\treg = readl_relaxed(clk_base + PLLU_BASE);\n\treg &= ~GENMASK(20, 0);\n\treg |= fentry->m;\n\treg |= fentry->n << 8;\n\treg |= fentry->p << 16;\n\twritel(reg, clk_base + PLLU_BASE);\n\tfence_udelay(1, clk_base);\n\treg |= PLL_ENABLE;\n\twritel(reg, clk_base + PLLU_BASE);\n\n\t \n\tret = tegra210_wait_for_mask(&pllu, PLLU_BASE, PLL_BASE_LOCK);\n\tif (ret) {\n\t\tpr_err(\"Timed out waiting for PLL_U to lock\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra210_init_pllu(void)\n{\n\tu32 reg;\n\tint err;\n\n\ttegra210_pllu_set_defaults(&pll_u_vco_params);\n\t \n\treg = readl_relaxed(clk_base + PLLU_BASE);\n\tif (reg & PLLU_BASE_OVERRIDE) {\n\t\tif (!(reg & PLL_ENABLE)) {\n\t\t\terr = tegra210_enable_pllu();\n\t\t\tif (err < 0) {\n\t\t\t\tWARN_ON(1);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\t \n\t\treg = readl_relaxed(clk_base + PLLU_BASE);\n\t\treg &= ~PLLU_BASE_OVERRIDE;\n\t\twritel(reg, clk_base + PLLU_BASE);\n\n\t\treg = readl_relaxed(clk_base + PLLU_HW_PWRDN_CFG0);\n\t\treg |= PLLU_HW_PWRDN_CFG0_IDDQ_PD_INCLUDE |\n\t\t       PLLU_HW_PWRDN_CFG0_USE_SWITCH_DETECT |\n\t\t       PLLU_HW_PWRDN_CFG0_USE_LOCKDET;\n\t\treg &= ~(PLLU_HW_PWRDN_CFG0_CLK_ENABLE_SWCTL |\n\t\t\tPLLU_HW_PWRDN_CFG0_CLK_SWITCH_SWCTL);\n\t\twritel_relaxed(reg, clk_base + PLLU_HW_PWRDN_CFG0);\n\n\t\treg = readl_relaxed(clk_base + XUSB_PLL_CFG0);\n\t\treg &= ~XUSB_PLL_CFG0_PLLU_LOCK_DLY_MASK;\n\t\twritel_relaxed(reg, clk_base + XUSB_PLL_CFG0);\n\t\tfence_udelay(1, clk_base);\n\n\t\treg = readl_relaxed(clk_base + PLLU_HW_PWRDN_CFG0);\n\t\treg |= PLLU_HW_PWRDN_CFG0_SEQ_ENABLE;\n\t\twritel_relaxed(reg, clk_base + PLLU_HW_PWRDN_CFG0);\n\t\tfence_udelay(1, clk_base);\n\n\t\treg = readl_relaxed(clk_base + PLLU_BASE);\n\t\treg &= ~PLLU_BASE_CLKENABLE_USB;\n\t\twritel_relaxed(reg, clk_base + PLLU_BASE);\n\t}\n\n\t \n\treg = readl_relaxed(clk_base + UTMIPLL_HW_PWRDN_CFG0);\n\tif (!(reg & UTMIPLL_HW_PWRDN_CFG0_SEQ_ENABLE))\n\t\ttegra210_utmi_param_configure();\n\n\treturn 0;\n}\n\n \n\nstatic const char * const sor0_parents[] = {\n\t\"pll_d_out0\",\n};\n\nstatic const char * const sor0_out_parents[] = {\n\t\"sor_safe\", \"sor0_pad_clkout\",\n};\n\nstatic const char * const sor1_parents[] = {\n\t\"pll_p\", \"pll_d_out0\", \"pll_d2_out0\", \"clk_m\",\n};\n\nstatic u32 sor1_parents_idx[] = { 0, 2, 5, 6 };\n\nstatic const struct clk_div_table mc_div_table_tegra210[] = {\n\t{ .val = 0, .div = 2 },\n\t{ .val = 1, .div = 4 },\n\t{ .val = 2, .div = 1 },\n\t{ .val = 3, .div = 2 },\n\t{ .val = 0, .div = 0 },\n};\n\nstatic void tegra210_clk_register_mc(const char *name,\n\t\t\t\t     const char *parent_name)\n{\n\tstruct clk *clk;\n\n\tclk = clk_register_divider_table(NULL, name, parent_name,\n\t\t\t\t\t CLK_IS_CRITICAL,\n\t\t\t\t\t clk_base + CLK_SOURCE_EMC,\n\t\t\t\t\t 15, 2, CLK_DIVIDER_READ_ONLY,\n\t\t\t\t\t mc_div_table_tegra210, &emc_lock);\n\tclks[TEGRA210_CLK_MC] = clk;\n}\n\nstatic const char * const sor1_out_parents[] = {\n\t \n\t\"sor_safe\", \"sor1_pad_clkout\", \"sor1_out\", \"sor1_pad_clkout\",\n};\n\nstatic struct tegra_periph_init_data tegra210_periph[] = {\n\t \n\tTEGRA_INIT_DATA_TABLE(\"sor0\", NULL, NULL, sor0_parents,\n\t\t\t      CLK_SOURCE_SOR0, 29, 0x0, 0, 0, 0, 0,\n\t\t\t      0, 182, 0, tegra_clk_sor0, NULL, 0,\n\t\t\t      &sor0_lock),\n\tTEGRA_INIT_DATA_TABLE(\"sor0_out\", NULL, NULL, sor0_out_parents,\n\t\t\t      CLK_SOURCE_SOR0, 14, 0x1, 0, 0, 0, 0,\n\t\t\t      0, 0, TEGRA_PERIPH_NO_GATE, tegra_clk_sor0_out,\n\t\t\t      NULL, 0, &sor0_lock),\n\tTEGRA_INIT_DATA_TABLE(\"sor1\", NULL, NULL, sor1_parents,\n\t\t\t      CLK_SOURCE_SOR1, 29, 0x7, 0, 0, 8, 1,\n\t\t\t      TEGRA_DIVIDER_ROUND_UP, 183, 0,\n\t\t\t      tegra_clk_sor1, sor1_parents_idx, 0,\n\t\t\t      &sor1_lock),\n\tTEGRA_INIT_DATA_TABLE(\"sor1_out\", NULL, NULL, sor1_out_parents,\n\t\t\t      CLK_SOURCE_SOR1, 14, 0x3, 0, 0, 0, 0,\n\t\t\t      0, 0, TEGRA_PERIPH_NO_GATE,\n\t\t\t      tegra_clk_sor1_out, NULL, 0, &sor1_lock),\n};\n\nstatic const char * const la_parents[] = {\n\t\"pll_p\", \"pll_c2\", \"pll_c\", \"pll_c3\", \"pll_re_out1\", \"pll_a1\", \"clk_m\", \"pll_c4_out0\"\n};\n\nstatic struct tegra_clk_periph tegra210_la =\n\tTEGRA_CLK_PERIPH(29, 7, 9, 0, 8, 1, TEGRA_DIVIDER_ROUND_UP, 76, 0, NULL, NULL);\n\nstatic __init void tegra210_periph_clk_init(struct device_node *np,\n\t\t\t\t\t    void __iomem *clk_base,\n\t\t\t\t\t    void __iomem *pmc_base)\n{\n\tstruct clk *clk;\n\tunsigned int i;\n\n\t \n\tclk = clk_register_fixed_factor(NULL, \"xusb_ss_div2\", \"xusb_ss_src\", 0,\n\t\t\t\t\t1, 2);\n\tclks[TEGRA210_CLK_XUSB_SS_DIV2] = clk;\n\n\tclk = tegra_clk_register_periph_fixed(\"sor_safe\", \"pll_p\", 0, clk_base,\n\t\t\t\t\t      1, 17, 222);\n\tclks[TEGRA210_CLK_SOR_SAFE] = clk;\n\n\tclk = tegra_clk_register_periph_fixed(\"dpaux\", \"sor_safe\", 0, clk_base,\n\t\t\t\t\t      1, 17, 181);\n\tclks[TEGRA210_CLK_DPAUX] = clk;\n\n\tclk = tegra_clk_register_periph_fixed(\"dpaux1\", \"sor_safe\", 0, clk_base,\n\t\t\t\t\t      1, 17, 207);\n\tclks[TEGRA210_CLK_DPAUX1] = clk;\n\n\t \n\tclk = clk_register_gate(NULL, \"pll_d_dsi_out\", \"pll_d_out0\", 0,\n\t\t\t\tclk_base + PLLD_MISC0, 21, 0, &pll_d_lock);\n\tclks[TEGRA210_CLK_PLL_D_DSI_OUT] = clk;\n\n\t \n\tclk = tegra_clk_register_periph_gate(\"dsia\", \"pll_d_dsi_out\", 0,\n\t\t\t\t\t     clk_base, 0, 48,\n\t\t\t\t\t     periph_clk_enb_refcnt);\n\tclks[TEGRA210_CLK_DSIA] = clk;\n\n\t \n\tclk = tegra_clk_register_periph_gate(\"dsib\", \"pll_d_dsi_out\", 0,\n\t\t\t\t\t     clk_base, 0, 82,\n\t\t\t\t\t     periph_clk_enb_refcnt);\n\tclks[TEGRA210_CLK_DSIB] = clk;\n\n\t \n\tclk = clk_register_gate(NULL, \"csi_tpg\", \"pll_d\",\n\t\t\t\tCLK_SET_RATE_PARENT, clk_base + PLLD_BASE,\n\t\t\t\t23, 0, &pll_d_lock);\n\tclk_register_clkdev(clk, \"csi_tpg\", NULL);\n\tclks[TEGRA210_CLK_CSI_TPG] = clk;\n\n\t \n\tclk = tegra_clk_register_periph(\"la\", la_parents,\n\t\t\tARRAY_SIZE(la_parents), &tegra210_la, clk_base,\n\t\t\tCLK_SOURCE_LA, 0);\n\tclks[TEGRA210_CLK_LA] = clk;\n\n\t \n\tclk = clk_register_gate(NULL, \"cml0\", \"pll_e\", 0, clk_base + PLLE_AUX,\n\t\t\t\t0, 0, &pll_e_lock);\n\tclk_register_clkdev(clk, \"cml0\", NULL);\n\tclks[TEGRA210_CLK_CML0] = clk;\n\n\t \n\tclk = clk_register_gate(NULL, \"cml1\", \"pll_e\", 0, clk_base + PLLE_AUX,\n\t\t\t\t1, 0, &pll_e_lock);\n\tclk_register_clkdev(clk, \"cml1\", NULL);\n\tclks[TEGRA210_CLK_CML1] = clk;\n\n\tclk = tegra_clk_register_super_clk(\"aclk\", aclk_parents,\n\t\t\t\tARRAY_SIZE(aclk_parents), 0, clk_base + 0x6e0,\n\t\t\t\t0, NULL);\n\tclks[TEGRA210_CLK_ACLK] = clk;\n\n\tclk = tegra_clk_register_sdmmc_mux_div(\"sdmmc2\", clk_base,\n\t\t\t\t\t    CLK_SOURCE_SDMMC2, 9,\n\t\t\t\t\t    TEGRA_DIVIDER_ROUND_UP, 0, NULL);\n\tclks[TEGRA210_CLK_SDMMC2] = clk;\n\n\tclk = tegra_clk_register_sdmmc_mux_div(\"sdmmc4\", clk_base,\n\t\t\t\t\t    CLK_SOURCE_SDMMC4, 15,\n\t\t\t\t\t    TEGRA_DIVIDER_ROUND_UP, 0, NULL);\n\tclks[TEGRA210_CLK_SDMMC4] = clk;\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra210_periph); i++) {\n\t\tstruct tegra_periph_init_data *init = &tegra210_periph[i];\n\t\tstruct clk **clkp;\n\n\t\tclkp = tegra_lookup_dt_id(init->clk_id, tegra210_clks);\n\t\tif (!clkp) {\n\t\t\tpr_warn(\"clock %u not found\\n\", init->clk_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tclk = tegra_clk_register_periph_data(clk_base, init);\n\t\t*clkp = clk;\n\t}\n\n\ttegra_periph_clk_init(clk_base, pmc_base, tegra210_clks, &pll_p_params);\n\n\t \n\tclk = tegra210_clk_register_emc(np, clk_base);\n\tclks[TEGRA210_CLK_EMC] = clk;\n\n\t \n\ttegra210_clk_register_mc(\"mc\", \"emc\");\n}\n\nstatic void __init tegra210_pll_init(void __iomem *clk_base,\n\t\t\t\t     void __iomem *pmc)\n{\n\tstruct clk *clk;\n\n\t \n\tclk = tegra_clk_register_pllc_tegra210(\"pll_c\", \"pll_ref\", clk_base,\n\t\t\tpmc, 0, &pll_c_params, NULL);\n\tif (!WARN_ON(IS_ERR(clk)))\n\t\tclk_register_clkdev(clk, \"pll_c\", NULL);\n\tclks[TEGRA210_CLK_PLL_C] = clk;\n\n\t \n\tclk = tegra_clk_register_divider(\"pll_c_out1_div\", \"pll_c\",\n\t\t\tclk_base + PLLC_OUT, 0, TEGRA_DIVIDER_ROUND_UP,\n\t\t\t8, 8, 1, NULL);\n\tclk = tegra_clk_register_pll_out(\"pll_c_out1\", \"pll_c_out1_div\",\n\t\t\t\tclk_base + PLLC_OUT, 1, 0,\n\t\t\t\tCLK_SET_RATE_PARENT, 0, NULL);\n\tclk_register_clkdev(clk, \"pll_c_out1\", NULL);\n\tclks[TEGRA210_CLK_PLL_C_OUT1] = clk;\n\n\t \n\tclk = clk_register_fixed_factor(NULL, \"pll_c_ud\", \"pll_c\",\n\t\t\t\t\tCLK_SET_RATE_PARENT, 1, 1);\n\tclk_register_clkdev(clk, \"pll_c_ud\", NULL);\n\tclks[TEGRA210_CLK_PLL_C_UD] = clk;\n\n\t \n\tclk = tegra_clk_register_pllc_tegra210(\"pll_c2\", \"pll_ref\", clk_base,\n\t\t\t     pmc, 0, &pll_c2_params, NULL);\n\tclk_register_clkdev(clk, \"pll_c2\", NULL);\n\tclks[TEGRA210_CLK_PLL_C2] = clk;\n\n\t \n\tclk = tegra_clk_register_pllc_tegra210(\"pll_c3\", \"pll_ref\", clk_base,\n\t\t\t     pmc, 0, &pll_c3_params, NULL);\n\tclk_register_clkdev(clk, \"pll_c3\", NULL);\n\tclks[TEGRA210_CLK_PLL_C3] = clk;\n\n\t \n\tclk = tegra_clk_register_pllm(\"pll_m\", \"osc\", clk_base, pmc,\n\t\t\t     CLK_SET_RATE_GATE, &pll_m_params, NULL);\n\tclk_register_clkdev(clk, \"pll_m\", NULL);\n\tclks[TEGRA210_CLK_PLL_M] = clk;\n\n\t \n\tclk = tegra_clk_register_pllmb(\"pll_mb\", \"osc\", clk_base, pmc,\n\t\t\t     CLK_SET_RATE_GATE, &pll_mb_params, NULL);\n\tclk_register_clkdev(clk, \"pll_mb\", NULL);\n\tclks[TEGRA210_CLK_PLL_MB] = clk;\n\n\t \n\tclk = clk_register_fixed_factor(NULL, \"pll_m_ud\", \"pll_m\",\n\t\t\t\t\tCLK_SET_RATE_PARENT, 1, 1);\n\tclk_register_clkdev(clk, \"pll_m_ud\", NULL);\n\tclks[TEGRA210_CLK_PLL_M_UD] = clk;\n\n\t \n\tclk = clk_register_fixed_factor(NULL, \"pll_mb_ud\", \"pll_mb\",\n\t\t\t\t\tCLK_SET_RATE_PARENT, 1, 1);\n\tclk_register_clkdev(clk, \"pll_mb_ud\", NULL);\n\tclks[TEGRA210_CLK_PLL_MB_UD] = clk;\n\n\t \n\tclk = clk_register_fixed_factor(NULL, \"pll_p_ud\", \"pll_p\",\n\t\t\t\t\t0, 1, 1);\n\tclks[TEGRA210_CLK_PLL_P_UD] = clk;\n\n\t \n\tif (!tegra210_init_pllu()) {\n\t\tclk = clk_register_fixed_rate(NULL, \"pll_u_vco\", \"pll_ref\", 0,\n\t\t\t\t\t      480*1000*1000);\n\t\tclk_register_clkdev(clk, \"pll_u_vco\", NULL);\n\t\tclks[TEGRA210_CLK_PLL_U] = clk;\n\t}\n\n\t \n\tclk = clk_register_divider_table(NULL, \"pll_u_out\", \"pll_u_vco\", 0,\n\t\t\t\t\t clk_base + PLLU_BASE, 16, 4, 0,\n\t\t\t\t\t pll_vco_post_div_table, NULL);\n\tclk_register_clkdev(clk, \"pll_u_out\", NULL);\n\tclks[TEGRA210_CLK_PLL_U_OUT] = clk;\n\n\t \n\tclk = tegra_clk_register_divider(\"pll_u_out1_div\", \"pll_u_out\",\n\t\t\t\tclk_base + PLLU_OUTA, 0,\n\t\t\t\tTEGRA_DIVIDER_ROUND_UP,\n\t\t\t\t8, 8, 1, &pll_u_lock);\n\tclk = tegra_clk_register_pll_out(\"pll_u_out1\", \"pll_u_out1_div\",\n\t\t\t\tclk_base + PLLU_OUTA, 1, 0,\n\t\t\t\tCLK_SET_RATE_PARENT, 0, &pll_u_lock);\n\tclk_register_clkdev(clk, \"pll_u_out1\", NULL);\n\tclks[TEGRA210_CLK_PLL_U_OUT1] = clk;\n\n\t \n\tclk = tegra_clk_register_divider(\"pll_u_out2_div\", \"pll_u_out\",\n\t\t\t\tclk_base + PLLU_OUTA, 0,\n\t\t\t\tTEGRA_DIVIDER_ROUND_UP,\n\t\t\t\t24, 8, 1, &pll_u_lock);\n\tclk = tegra_clk_register_pll_out(\"pll_u_out2\", \"pll_u_out2_div\",\n\t\t\t\tclk_base + PLLU_OUTA, 17, 16,\n\t\t\t\tCLK_SET_RATE_PARENT, 0, &pll_u_lock);\n\tclk_register_clkdev(clk, \"pll_u_out2\", NULL);\n\tclks[TEGRA210_CLK_PLL_U_OUT2] = clk;\n\n\t \n\tclk = clk_register_gate(NULL, \"pll_u_480M\", \"pll_u_vco\",\n\t\t\t\tCLK_SET_RATE_PARENT, clk_base + PLLU_BASE,\n\t\t\t\t22, 0, &pll_u_lock);\n\tclk_register_clkdev(clk, \"pll_u_480M\", NULL);\n\tclks[TEGRA210_CLK_PLL_U_480M] = clk;\n\n\t \n\tclk = clk_register_gate(NULL, \"pll_u_60M\", \"pll_u_out2\",\n\t\t\t\tCLK_SET_RATE_PARENT, clk_base + PLLU_BASE,\n\t\t\t\t23, 0, &pll_u_lock);\n\tclk_register_clkdev(clk, \"pll_u_60M\", NULL);\n\tclks[TEGRA210_CLK_PLL_U_60M] = clk;\n\n\t \n\tclk = clk_register_gate(NULL, \"pll_u_48M\", \"pll_u_out1\",\n\t\t\t\tCLK_SET_RATE_PARENT, clk_base + PLLU_BASE,\n\t\t\t\t25, 0, &pll_u_lock);\n\tclk_register_clkdev(clk, \"pll_u_48M\", NULL);\n\tclks[TEGRA210_CLK_PLL_U_48M] = clk;\n\n\t \n\tclk = tegra_clk_register_pll(\"pll_d\", \"pll_ref\", clk_base, pmc, 0,\n\t\t\t    &pll_d_params, &pll_d_lock);\n\tclk_register_clkdev(clk, \"pll_d\", NULL);\n\tclks[TEGRA210_CLK_PLL_D] = clk;\n\n\t \n\tclk = clk_register_fixed_factor(NULL, \"pll_d_out0\", \"pll_d\",\n\t\t\t\t\tCLK_SET_RATE_PARENT, 1, 2);\n\tclk_register_clkdev(clk, \"pll_d_out0\", NULL);\n\tclks[TEGRA210_CLK_PLL_D_OUT0] = clk;\n\n\t \n\tclk = tegra_clk_register_pllre_tegra210(\"pll_re_vco\", \"pll_ref\",\n\t\t\t\t\t\tclk_base, pmc, 0,\n\t\t\t\t\t\t&pll_re_vco_params,\n\t\t\t\t\t\t&pll_re_lock, pll_ref_freq);\n\tclk_register_clkdev(clk, \"pll_re_vco\", NULL);\n\tclks[TEGRA210_CLK_PLL_RE_VCO] = clk;\n\n\tclk = clk_register_divider_table(NULL, \"pll_re_out\", \"pll_re_vco\", 0,\n\t\t\t\t\t clk_base + PLLRE_BASE, 16, 5, 0,\n\t\t\t\t\t pll_vco_post_div_table, &pll_re_lock);\n\tclk_register_clkdev(clk, \"pll_re_out\", NULL);\n\tclks[TEGRA210_CLK_PLL_RE_OUT] = clk;\n\n\tclk = tegra_clk_register_divider(\"pll_re_out1_div\", \"pll_re_vco\",\n\t\t\t\t\t clk_base + PLLRE_OUT1, 0,\n\t\t\t\t\t TEGRA_DIVIDER_ROUND_UP,\n\t\t\t\t\t 8, 8, 1, NULL);\n\tclk = tegra_clk_register_pll_out(\"pll_re_out1\", \"pll_re_out1_div\",\n\t\t\t\t\t clk_base + PLLRE_OUT1, 1, 0,\n\t\t\t\t\t CLK_SET_RATE_PARENT, 0, NULL);\n\tclks[TEGRA210_CLK_PLL_RE_OUT1] = clk;\n\n\t \n\tclk = tegra_clk_register_plle_tegra210(\"pll_e\", \"pll_ref\",\n\t\t\t\t      clk_base, 0, &pll_e_params, NULL);\n\tclk_register_clkdev(clk, \"pll_e\", NULL);\n\tclks[TEGRA210_CLK_PLL_E] = clk;\n\n\t \n\tclk = tegra_clk_register_pllre(\"pll_c4_vco\", \"pll_ref\", clk_base, pmc,\n\t\t\t     0, &pll_c4_vco_params, NULL, pll_ref_freq);\n\tclk_register_clkdev(clk, \"pll_c4_vco\", NULL);\n\tclks[TEGRA210_CLK_PLL_C4] = clk;\n\n\t \n\tclk = clk_register_divider_table(NULL, \"pll_c4_out0\", \"pll_c4_vco\", 0,\n\t\t\t\t\t clk_base + PLLC4_BASE, 19, 4, 0,\n\t\t\t\t\t pll_vco_post_div_table, NULL);\n\tclk_register_clkdev(clk, \"pll_c4_out0\", NULL);\n\tclks[TEGRA210_CLK_PLL_C4_OUT0] = clk;\n\n\t \n\tclk = clk_register_fixed_factor(NULL, \"pll_c4_out1\", \"pll_c4_vco\",\n\t\t\t\t\tCLK_SET_RATE_PARENT, 1, 3);\n\tclk_register_clkdev(clk, \"pll_c4_out1\", NULL);\n\tclks[TEGRA210_CLK_PLL_C4_OUT1] = clk;\n\n\t \n\tclk = clk_register_fixed_factor(NULL, \"pll_c4_out2\", \"pll_c4_vco\",\n\t\t\t\t\tCLK_SET_RATE_PARENT, 1, 5);\n\tclk_register_clkdev(clk, \"pll_c4_out2\", NULL);\n\tclks[TEGRA210_CLK_PLL_C4_OUT2] = clk;\n\n\t \n\tclk = tegra_clk_register_divider(\"pll_c4_out3_div\", \"pll_c4_out0\",\n\t\t\tclk_base + PLLC4_OUT, 0, TEGRA_DIVIDER_ROUND_UP,\n\t\t\t8, 8, 1, NULL);\n\tclk = tegra_clk_register_pll_out(\"pll_c4_out3\", \"pll_c4_out3_div\",\n\t\t\t\tclk_base + PLLC4_OUT, 1, 0,\n\t\t\t\tCLK_SET_RATE_PARENT, 0, NULL);\n\tclk_register_clkdev(clk, \"pll_c4_out3\", NULL);\n\tclks[TEGRA210_CLK_PLL_C4_OUT3] = clk;\n\n\t \n\tclk = tegra_clk_register_pllss_tegra210(\"pll_dp\", \"pll_ref\", clk_base,\n\t\t\t\t\t0, &pll_dp_params, NULL);\n\tclk_register_clkdev(clk, \"pll_dp\", NULL);\n\tclks[TEGRA210_CLK_PLL_DP] = clk;\n\n\t \n\tclk = tegra_clk_register_pllss_tegra210(\"pll_d2\", \"pll_ref\", clk_base,\n\t\t\t\t\t0, &pll_d2_params, NULL);\n\tclk_register_clkdev(clk, \"pll_d2\", NULL);\n\tclks[TEGRA210_CLK_PLL_D2] = clk;\n\n\t \n\tclk = clk_register_fixed_factor(NULL, \"pll_d2_out0\", \"pll_d2\",\n\t\t\t\t\tCLK_SET_RATE_PARENT, 1, 1);\n\tclk_register_clkdev(clk, \"pll_d2_out0\", NULL);\n\tclks[TEGRA210_CLK_PLL_D2_OUT0] = clk;\n\n\t \n\tclk = clk_register_fixed_factor(NULL, \"pll_p_out2\", \"pll_p\",\n\t\t\t\t\tCLK_SET_RATE_PARENT, 1, 2);\n\tclk_register_clkdev(clk, \"pll_p_out2\", NULL);\n\tclks[TEGRA210_CLK_PLL_P_OUT2] = clk;\n\n}\n\n \nstatic void tegra210_wait_cpu_in_reset(u32 cpu)\n{\n\tunsigned int reg;\n\n\tdo {\n\t\treg = readl(clk_base + CLK_RST_CONTROLLER_CPU_CMPLX_STATUS);\n\t\tcpu_relax();\n\t} while (!(reg & (1 << cpu)));   \n}\n\nstatic void tegra210_disable_cpu_clock(u32 cpu)\n{\n\t \n}\n\n#ifdef CONFIG_PM_SLEEP\n#define car_readl(_base, _off) readl_relaxed(clk_base + (_base) + ((_off) * 4))\n#define car_writel(_val, _base, _off) \\\n\t\twritel_relaxed(_val, clk_base + (_base) + ((_off) * 4))\n\nstatic u32 spare_reg_ctx, misc_clk_enb_ctx, clk_msk_arm_ctx;\nstatic u32 cpu_softrst_ctx[3];\n\nstatic int tegra210_clk_suspend(void)\n{\n\tunsigned int i;\n\n\tclk_save_context();\n\n\t \n\tspare_reg_ctx = readl_relaxed(clk_base + SPARE_REG0);\n\tmisc_clk_enb_ctx = readl_relaxed(clk_base + MISC_CLK_ENB);\n\tclk_msk_arm_ctx = readl_relaxed(clk_base + CLK_MASK_ARM);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_softrst_ctx); i++)\n\t\tcpu_softrst_ctx[i] = car_readl(CPU_SOFTRST_CTRL, i);\n\n\ttegra_clk_periph_suspend();\n\treturn 0;\n}\n\nstatic void tegra210_clk_resume(void)\n{\n\tunsigned int i;\n\n\ttegra_clk_osc_resume(clk_base);\n\n\t \n\twritel_relaxed(spare_reg_ctx, clk_base + SPARE_REG0);\n\twritel_relaxed(misc_clk_enb_ctx, clk_base + MISC_CLK_ENB);\n\twritel_relaxed(clk_msk_arm_ctx, clk_base + CLK_MASK_ARM);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_softrst_ctx); i++)\n\t\tcar_writel(cpu_softrst_ctx[i], CPU_SOFTRST_CTRL, i);\n\n\t \n\twritel_relaxed(TEGRA210_CLK_ENB_VLD_MSK_L, clk_base + CLK_OUT_ENB_L);\n\twritel_relaxed(TEGRA210_CLK_ENB_VLD_MSK_H, clk_base + CLK_OUT_ENB_H);\n\twritel_relaxed(TEGRA210_CLK_ENB_VLD_MSK_U, clk_base + CLK_OUT_ENB_U);\n\twritel_relaxed(TEGRA210_CLK_ENB_VLD_MSK_V, clk_base + CLK_OUT_ENB_V);\n\twritel_relaxed(TEGRA210_CLK_ENB_VLD_MSK_W, clk_base + CLK_OUT_ENB_W);\n\twritel_relaxed(TEGRA210_CLK_ENB_VLD_MSK_X, clk_base + CLK_OUT_ENB_X);\n\twritel_relaxed(TEGRA210_CLK_ENB_VLD_MSK_Y, clk_base + CLK_OUT_ENB_Y);\n\n\t \n\tfence_udelay(2, clk_base);\n\n\t \n\ttegra210_init_pllu();\n\tclk_restore_context();\n\n\t \n\ttegra_clk_periph_resume();\n}\n\nstatic void tegra210_cpu_clock_suspend(void)\n{\n\t \n\ttegra210_cpu_clk_sctx.clk_csite_src =\n\t\t\t\treadl(clk_base + CLK_SOURCE_CSITE);\n\twritel(3 << 30, clk_base + CLK_SOURCE_CSITE);\n}\n\nstatic void tegra210_cpu_clock_resume(void)\n{\n\twritel(tegra210_cpu_clk_sctx.clk_csite_src,\n\t\t\t\tclk_base + CLK_SOURCE_CSITE);\n}\n#endif\n\nstatic struct syscore_ops tegra_clk_syscore_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.suspend = tegra210_clk_suspend,\n\t.resume = tegra210_clk_resume,\n#endif\n};\n\nstatic struct tegra_cpu_car_ops tegra210_cpu_car_ops = {\n\t.wait_for_reset\t= tegra210_wait_cpu_in_reset,\n\t.disable_clock\t= tegra210_disable_cpu_clock,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= tegra210_cpu_clock_suspend,\n\t.resume\t\t= tegra210_cpu_clock_resume,\n#endif\n};\n\nstatic const struct of_device_id pmc_match[] __initconst = {\n\t{ .compatible = \"nvidia,tegra210-pmc\" },\n\t{ },\n};\n\nstatic struct tegra_clk_init_table init_table[] __initdata = {\n\t{ TEGRA210_CLK_UARTA, TEGRA210_CLK_PLL_P, 408000000, 0 },\n\t{ TEGRA210_CLK_UARTB, TEGRA210_CLK_PLL_P, 408000000, 0 },\n\t{ TEGRA210_CLK_UARTC, TEGRA210_CLK_PLL_P, 408000000, 0 },\n\t{ TEGRA210_CLK_UARTD, TEGRA210_CLK_PLL_P, 408000000, 0 },\n\t{ TEGRA210_CLK_PLL_A, TEGRA210_CLK_CLK_MAX, 564480000, 0 },\n\t{ TEGRA210_CLK_PLL_A_OUT0, TEGRA210_CLK_CLK_MAX, 11289600, 0 },\n\t{ TEGRA210_CLK_I2S0, TEGRA210_CLK_PLL_A_OUT0, 11289600, 0 },\n\t{ TEGRA210_CLK_I2S1, TEGRA210_CLK_PLL_A_OUT0, 11289600, 0 },\n\t{ TEGRA210_CLK_I2S2, TEGRA210_CLK_PLL_A_OUT0, 11289600, 0 },\n\t{ TEGRA210_CLK_I2S3, TEGRA210_CLK_PLL_A_OUT0, 11289600, 0 },\n\t{ TEGRA210_CLK_I2S4, TEGRA210_CLK_PLL_A_OUT0, 11289600, 0 },\n\t{ TEGRA210_CLK_HOST1X, TEGRA210_CLK_PLL_P, 136000000, 1 },\n\t{ TEGRA210_CLK_SCLK_MUX, TEGRA210_CLK_PLL_P, 0, 1 },\n\t{ TEGRA210_CLK_SCLK, TEGRA210_CLK_CLK_MAX, 102000000, 0 },\n\t{ TEGRA210_CLK_DFLL_SOC, TEGRA210_CLK_PLL_P, 51000000, 1 },\n\t{ TEGRA210_CLK_DFLL_REF, TEGRA210_CLK_PLL_P, 51000000, 1 },\n\t{ TEGRA210_CLK_SBC4, TEGRA210_CLK_PLL_P, 12000000, 1 },\n\t{ TEGRA210_CLK_PLL_U_OUT1, TEGRA210_CLK_CLK_MAX, 48000000, 1 },\n\t{ TEGRA210_CLK_XUSB_GATE, TEGRA210_CLK_CLK_MAX, 0, 1 },\n\t{ TEGRA210_CLK_XUSB_SS_SRC, TEGRA210_CLK_PLL_U_480M, 120000000, 0 },\n\t{ TEGRA210_CLK_XUSB_FS_SRC, TEGRA210_CLK_PLL_U_48M, 48000000, 0 },\n\t{ TEGRA210_CLK_XUSB_HS_SRC, TEGRA210_CLK_XUSB_SS_SRC, 120000000, 0 },\n\t{ TEGRA210_CLK_XUSB_SSP_SRC, TEGRA210_CLK_XUSB_SS_SRC, 120000000, 0 },\n\t{ TEGRA210_CLK_XUSB_FALCON_SRC, TEGRA210_CLK_PLL_P_OUT_XUSB, 204000000, 0 },\n\t{ TEGRA210_CLK_XUSB_HOST_SRC, TEGRA210_CLK_PLL_P_OUT_XUSB, 102000000, 0 },\n\t{ TEGRA210_CLK_XUSB_DEV_SRC, TEGRA210_CLK_PLL_P_OUT_XUSB, 102000000, 0 },\n\t{ TEGRA210_CLK_SATA, TEGRA210_CLK_PLL_P, 104000000, 0 },\n\t{ TEGRA210_CLK_SATA_OOB, TEGRA210_CLK_PLL_P, 204000000, 0 },\n\t{ TEGRA210_CLK_MSELECT, TEGRA210_CLK_CLK_MAX, 0, 1 },\n\t{ TEGRA210_CLK_CSITE, TEGRA210_CLK_CLK_MAX, 0, 1 },\n\t \n\t{ TEGRA210_CLK_DBGAPB, TEGRA210_CLK_CLK_MAX, 0, 1 },\n\t{ TEGRA210_CLK_TSENSOR, TEGRA210_CLK_CLK_M, 400000, 0 },\n\t{ TEGRA210_CLK_I2C1, TEGRA210_CLK_PLL_P, 0, 0 },\n\t{ TEGRA210_CLK_I2C2, TEGRA210_CLK_PLL_P, 0, 0 },\n\t{ TEGRA210_CLK_I2C3, TEGRA210_CLK_PLL_P, 0, 0 },\n\t{ TEGRA210_CLK_I2C4, TEGRA210_CLK_PLL_P, 0, 0 },\n\t{ TEGRA210_CLK_I2C5, TEGRA210_CLK_PLL_P, 0, 0 },\n\t{ TEGRA210_CLK_I2C6, TEGRA210_CLK_PLL_P, 0, 0 },\n\t{ TEGRA210_CLK_PLL_DP, TEGRA210_CLK_CLK_MAX, 270000000, 0 },\n\t{ TEGRA210_CLK_SOC_THERM, TEGRA210_CLK_PLL_P, 51000000, 0 },\n\t{ TEGRA210_CLK_CCLK_G, TEGRA210_CLK_CLK_MAX, 0, 1 },\n\t{ TEGRA210_CLK_PLL_U_OUT2, TEGRA210_CLK_CLK_MAX, 60000000, 1 },\n\t{ TEGRA210_CLK_SPDIF_IN_SYNC, TEGRA210_CLK_CLK_MAX, 24576000, 0 },\n\t{ TEGRA210_CLK_I2S0_SYNC, TEGRA210_CLK_CLK_MAX, 24576000, 0 },\n\t{ TEGRA210_CLK_I2S1_SYNC, TEGRA210_CLK_CLK_MAX, 24576000, 0 },\n\t{ TEGRA210_CLK_I2S2_SYNC, TEGRA210_CLK_CLK_MAX, 24576000, 0 },\n\t{ TEGRA210_CLK_I2S3_SYNC, TEGRA210_CLK_CLK_MAX, 24576000, 0 },\n\t{ TEGRA210_CLK_I2S4_SYNC, TEGRA210_CLK_CLK_MAX, 24576000, 0 },\n\t{ TEGRA210_CLK_VIMCLK_SYNC, TEGRA210_CLK_CLK_MAX, 24576000, 0 },\n\t{ TEGRA210_CLK_HDA, TEGRA210_CLK_PLL_P, 51000000, 0 },\n\t{ TEGRA210_CLK_HDA2CODEC_2X, TEGRA210_CLK_PLL_P, 48000000, 0 },\n\t{ TEGRA210_CLK_PWM, TEGRA210_CLK_PLL_P, 48000000, 0 },\n\t \n\t{ TEGRA210_CLK_CLK_MAX, TEGRA210_CLK_CLK_MAX, 0, 0 },\n};\n\n \nstatic void __init tegra210_clock_apply_init_table(void)\n{\n\ttegra_init_from_table(init_table, clks, TEGRA210_CLK_CLK_MAX);\n}\n\n \nstatic void tegra210_car_barrier(void)\n{\n\treadl_relaxed(clk_base + RST_DFLL_DVCO);\n}\n\n \nstatic void tegra210_clock_assert_dfll_dvco_reset(void)\n{\n\tu32 v;\n\n\tv = readl_relaxed(clk_base + RST_DFLL_DVCO);\n\tv |= (1 << DVFS_DFLL_RESET_SHIFT);\n\twritel_relaxed(v, clk_base + RST_DFLL_DVCO);\n\ttegra210_car_barrier();\n}\n\n \nstatic void tegra210_clock_deassert_dfll_dvco_reset(void)\n{\n\tu32 v;\n\n\tv = readl_relaxed(clk_base + RST_DFLL_DVCO);\n\tv &= ~(1 << DVFS_DFLL_RESET_SHIFT);\n\twritel_relaxed(v, clk_base + RST_DFLL_DVCO);\n\ttegra210_car_barrier();\n}\n\nstatic int tegra210_reset_assert(unsigned long id)\n{\n\tif (id == TEGRA210_RST_DFLL_DVCO)\n\t\ttegra210_clock_assert_dfll_dvco_reset();\n\telse if (id == TEGRA210_RST_ADSP)\n\t\twritel(GENMASK(26, 21) | BIT(7),\n\t\t\tclk_base + CLK_RST_CONTROLLER_RST_DEV_Y_SET);\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int tegra210_reset_deassert(unsigned long id)\n{\n\tif (id == TEGRA210_RST_DFLL_DVCO)\n\t\ttegra210_clock_deassert_dfll_dvco_reset();\n\telse if (id == TEGRA210_RST_ADSP) {\n\t\twritel(BIT(21), clk_base + CLK_RST_CONTROLLER_RST_DEV_Y_CLR);\n\t\t \n\t\tudelay(5);\n\t\twritel(GENMASK(26, 22) | BIT(7),\n\t\t\tclk_base + CLK_RST_CONTROLLER_RST_DEV_Y_CLR);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void tegra210_mbist_clk_init(void)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra210_pg_mbist_war); i++) {\n\t\tunsigned int num_clks = tegra210_pg_mbist_war[i].num_clks;\n\t\tstruct clk_bulk_data *clk_data;\n\n\t\tif (!num_clks)\n\t\t\tcontinue;\n\n\t\tclk_data = kmalloc_array(num_clks, sizeof(*clk_data),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (WARN_ON(!clk_data))\n\t\t\treturn;\n\n\t\ttegra210_pg_mbist_war[i].clks = clk_data;\n\t\tfor (j = 0; j < num_clks; j++) {\n\t\t\tint clk_id = tegra210_pg_mbist_war[i].clk_init_data[j];\n\t\t\tstruct clk *clk = clks[clk_id];\n\n\t\t\tif (WARN(IS_ERR(clk), \"clk_id: %d\\n\", clk_id)) {\n\t\t\t\tkfree(clk_data);\n\t\t\t\ttegra210_pg_mbist_war[i].clks = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tclk_data[j].clk = clk;\n\t\t}\n\t}\n}\n\n \nstatic void __init tegra210_clock_init(struct device_node *np)\n{\n\tstruct device_node *node;\n\tu32 value, clk_m_div;\n\n\tclk_base = of_iomap(np, 0);\n\tif (!clk_base) {\n\t\tpr_err(\"ioremap tegra210 CAR failed\\n\");\n\t\treturn;\n\t}\n\n\tnode = of_find_matching_node(NULL, pmc_match);\n\tif (!node) {\n\t\tpr_err(\"Failed to find pmc node\\n\");\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tpmc_base = of_iomap(node, 0);\n\tof_node_put(node);\n\tif (!pmc_base) {\n\t\tpr_err(\"Can't map pmc registers\\n\");\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tahub_base = ioremap(TEGRA210_AHUB_BASE, SZ_64K);\n\tif (!ahub_base) {\n\t\tpr_err(\"ioremap tegra210 APE failed\\n\");\n\t\treturn;\n\t}\n\n\tdispa_base = ioremap(TEGRA210_DISPA_BASE, SZ_256K);\n\tif (!dispa_base) {\n\t\tpr_err(\"ioremap tegra210 DISPA failed\\n\");\n\t\treturn;\n\t}\n\n\tvic_base = ioremap(TEGRA210_VIC_BASE, SZ_256K);\n\tif (!vic_base) {\n\t\tpr_err(\"ioremap tegra210 VIC failed\\n\");\n\t\treturn;\n\t}\n\n\tclks = tegra_clk_init(clk_base, TEGRA210_CLK_CLK_MAX,\n\t\t\t      TEGRA210_CAR_BANK_COUNT);\n\tif (!clks)\n\t\treturn;\n\n\tvalue = readl(clk_base + SPARE_REG0) >> CLK_M_DIVISOR_SHIFT;\n\tclk_m_div = (value & CLK_M_DIVISOR_MASK) + 1;\n\n\tif (tegra_osc_clk_init(clk_base, tegra210_clks, tegra210_input_freq,\n\t\t\t       ARRAY_SIZE(tegra210_input_freq), clk_m_div,\n\t\t\t       &osc_freq, &pll_ref_freq) < 0)\n\t\treturn;\n\n\ttegra_fixed_clk_init(tegra210_clks);\n\ttegra210_pll_init(clk_base, pmc_base);\n\ttegra210_periph_clk_init(np, clk_base, pmc_base);\n\ttegra_audio_clk_init(clk_base, pmc_base, tegra210_clks,\n\t\t\t     tegra210_audio_plls,\n\t\t\t     ARRAY_SIZE(tegra210_audio_plls), 24576000);\n\n\t \n\tvalue = readl(clk_base + PLLD_BASE);\n\tvalue &= ~BIT(25);\n\twritel(value, clk_base + PLLD_BASE);\n\n\ttegra_clk_apply_init_table = tegra210_clock_apply_init_table;\n\n\ttegra_super_clk_gen5_init(clk_base, pmc_base, tegra210_clks,\n\t\t\t\t  &pll_x_params);\n\ttegra_init_special_resets(2, tegra210_reset_assert,\n\t\t\t\t  tegra210_reset_deassert);\n\n\ttegra_add_of_provider(np, of_clk_src_onecell_get);\n\ttegra_register_devclks(devclks, ARRAY_SIZE(devclks));\n\n\ttegra210_mbist_clk_init();\n\n\ttegra_cpu_car_ops = &tegra210_cpu_car_ops;\n\n\tregister_syscore_ops(&tegra_clk_syscore_ops);\n}\nCLK_OF_DECLARE(tegra210, \"nvidia,tegra210-car\", tegra210_clock_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}