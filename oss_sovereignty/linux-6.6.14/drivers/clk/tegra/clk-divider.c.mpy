{
  "module_name": "clk-divider.c",
  "hash_id": "e2b21b92e58b182a4fd4d01f29c08c2ae25c5f59e0b2fb16618f4822339b4018",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-divider.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/clk-provider.h>\n\n#include \"clk.h\"\n\n#define pll_out_override(p) (BIT((p->shift - 6)))\n#define div_mask(d) ((1 << (d->width)) - 1)\n#define get_mul(d) (1 << d->frac_width)\n#define get_max_div(d) div_mask(d)\n\n#define PERIPH_CLK_UART_DIV_ENB BIT(24)\n\nstatic int get_div(struct tegra_clk_frac_div *divider, unsigned long rate,\n\t\t   unsigned long parent_rate)\n{\n\tint div;\n\n\tdiv = div_frac_get(rate, parent_rate, divider->width,\n\t\t\t   divider->frac_width, divider->flags);\n\n\tif (div < 0)\n\t\treturn 0;\n\n\treturn div;\n}\n\nstatic unsigned long clk_frac_div_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct tegra_clk_frac_div *divider = to_clk_frac_div(hw);\n\tu32 reg;\n\tint div, mul;\n\tu64 rate = parent_rate;\n\n\treg = readl_relaxed(divider->reg);\n\n\tif ((divider->flags & TEGRA_DIVIDER_UART) &&\n\t    !(reg & PERIPH_CLK_UART_DIV_ENB))\n\t\treturn rate;\n\n\tdiv = (reg >> divider->shift) & div_mask(divider);\n\n\tmul = get_mul(divider);\n\tdiv += mul;\n\n\trate *= mul;\n\trate += div - 1;\n\tdo_div(rate, div);\n\n\treturn rate;\n}\n\nstatic long clk_frac_div_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long *prate)\n{\n\tstruct tegra_clk_frac_div *divider = to_clk_frac_div(hw);\n\tint div, mul;\n\tunsigned long output_rate = *prate;\n\n\tif (!rate)\n\t\treturn output_rate;\n\n\tdiv = get_div(divider, rate, output_rate);\n\tif (div < 0)\n\t\treturn *prate;\n\n\tmul = get_mul(divider);\n\n\treturn DIV_ROUND_UP(output_rate * mul, div + mul);\n}\n\nstatic int clk_frac_div_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct tegra_clk_frac_div *divider = to_clk_frac_div(hw);\n\tint div;\n\tunsigned long flags = 0;\n\tu32 val;\n\n\tdiv = get_div(divider, rate, parent_rate);\n\tif (div < 0)\n\t\treturn div;\n\n\tif (divider->lock)\n\t\tspin_lock_irqsave(divider->lock, flags);\n\n\tval = readl_relaxed(divider->reg);\n\tval &= ~(div_mask(divider) << divider->shift);\n\tval |= div << divider->shift;\n\n\tif (divider->flags & TEGRA_DIVIDER_UART) {\n\t\tif (div)\n\t\t\tval |= PERIPH_CLK_UART_DIV_ENB;\n\t\telse\n\t\t\tval &= ~PERIPH_CLK_UART_DIV_ENB;\n\t}\n\n\tif (divider->flags & TEGRA_DIVIDER_FIXED)\n\t\tval |= pll_out_override(divider);\n\n\twritel_relaxed(val, divider->reg);\n\n\tif (divider->lock)\n\t\tspin_unlock_irqrestore(divider->lock, flags);\n\n\treturn 0;\n}\n\nstatic void clk_divider_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_hw *parent = clk_hw_get_parent(hw);\n\tunsigned long parent_rate = clk_hw_get_rate(parent);\n\tunsigned long rate = clk_hw_get_rate(hw);\n\n\tif (clk_frac_div_set_rate(hw, rate, parent_rate) < 0)\n\t\tWARN_ON(1);\n}\n\nconst struct clk_ops tegra_clk_frac_div_ops = {\n\t.recalc_rate = clk_frac_div_recalc_rate,\n\t.set_rate = clk_frac_div_set_rate,\n\t.round_rate = clk_frac_div_round_rate,\n\t.restore_context = clk_divider_restore_context,\n};\n\nstruct clk *tegra_clk_register_divider(const char *name,\n\t\tconst char *parent_name, void __iomem *reg,\n\t\tunsigned long flags, u8 clk_divider_flags, u8 shift, u8 width,\n\t\tu8 frac_width, spinlock_t *lock)\n{\n\tstruct tegra_clk_frac_div *divider;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\tdivider = kzalloc(sizeof(*divider), GFP_KERNEL);\n\tif (!divider) {\n\t\tpr_err(\"%s: could not allocate fractional divider clk\\n\",\n\t\t       __func__);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinit.name = name;\n\tinit.ops = &tegra_clk_frac_div_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\n\tdivider->reg = reg;\n\tdivider->shift = shift;\n\tdivider->width = width;\n\tdivider->frac_width = frac_width;\n\tdivider->lock = lock;\n\tdivider->flags = clk_divider_flags;\n\n\t \n\tdivider->hw.init = &init;\n\n\tclk = clk_register(NULL, &divider->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(divider);\n\n\treturn clk;\n}\n\nstatic const struct clk_div_table mc_div_table[] = {\n\t{ .val = 0, .div = 2 },\n\t{ .val = 1, .div = 1 },\n\t{ .val = 0, .div = 0 },\n};\n\nstruct clk *tegra_clk_register_mc(const char *name, const char *parent_name,\n\t\t\t\t  void __iomem *reg, spinlock_t *lock)\n{\n\treturn clk_register_divider_table(NULL, name, parent_name,\n\t\t\t\t\t  CLK_IS_CRITICAL,\n\t\t\t\t\t  reg, 16, 1, CLK_DIVIDER_READ_ONLY,\n\t\t\t\t\t  mc_div_table, lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}