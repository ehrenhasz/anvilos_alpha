{
  "module_name": "clk-super.c",
  "hash_id": "30d0cc1c6d7a9dc81e51b19dc91a32bba511e64d1159a2eac1de803ea94d823e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-super.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/clk-provider.h>\n\n#include \"clk.h\"\n\n#define SUPER_STATE_IDLE 0\n#define SUPER_STATE_RUN 1\n#define SUPER_STATE_IRQ 2\n#define SUPER_STATE_FIQ 3\n\n#define SUPER_STATE_SHIFT 28\n#define SUPER_STATE_MASK ((BIT(SUPER_STATE_IDLE) | BIT(SUPER_STATE_RUN) | \\\n\t\t\t   BIT(SUPER_STATE_IRQ) | BIT(SUPER_STATE_FIQ))\t\\\n\t\t\t  << SUPER_STATE_SHIFT)\n\n#define SUPER_LP_DIV2_BYPASS (1 << 16)\n\n#define super_state(s) (BIT(s) << SUPER_STATE_SHIFT)\n#define super_state_to_src_shift(m, s) ((m->width * s))\n#define super_state_to_src_mask(m) (((1 << m->width) - 1))\n\n#define CCLK_SRC_PLLP_OUT0 4\n#define CCLK_SRC_PLLP_OUT4 5\n\nstatic u8 clk_super_get_parent(struct clk_hw *hw)\n{\n\tstruct tegra_clk_super_mux *mux = to_clk_super_mux(hw);\n\tu32 val, state;\n\tu8 source, shift;\n\n\tval = readl_relaxed(mux->reg);\n\n\tstate = val & SUPER_STATE_MASK;\n\n\tBUG_ON((state != super_state(SUPER_STATE_RUN)) &&\n\t       (state != super_state(SUPER_STATE_IDLE)));\n\tshift = (state == super_state(SUPER_STATE_IDLE)) ?\n\t\tsuper_state_to_src_shift(mux, SUPER_STATE_IDLE) :\n\t\tsuper_state_to_src_shift(mux, SUPER_STATE_RUN);\n\n\tsource = (val >> shift) & super_state_to_src_mask(mux);\n\n\t \n\tif ((mux->flags & TEGRA_DIVIDER_2) && !(val & SUPER_LP_DIV2_BYPASS) &&\n\t    (source == mux->pllx_index))\n\t\tsource = mux->div2_index;\n\n\treturn source;\n}\n\nstatic int clk_super_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct tegra_clk_super_mux *mux = to_clk_super_mux(hw);\n\tu32 val, state;\n\tint err = 0;\n\tu8 parent_index, shift;\n\tunsigned long flags = 0;\n\n\tif (mux->lock)\n\t\tspin_lock_irqsave(mux->lock, flags);\n\n\tval = readl_relaxed(mux->reg);\n\tstate = val & SUPER_STATE_MASK;\n\tBUG_ON((state != super_state(SUPER_STATE_RUN)) &&\n\t       (state != super_state(SUPER_STATE_IDLE)));\n\tshift = (state == super_state(SUPER_STATE_IDLE)) ?\n\t\tsuper_state_to_src_shift(mux, SUPER_STATE_IDLE) :\n\t\tsuper_state_to_src_shift(mux, SUPER_STATE_RUN);\n\n\t \n\tif ((mux->flags & TEGRA_DIVIDER_2) && ((index == mux->div2_index) ||\n\t\t\t\t\t       (index == mux->pllx_index))) {\n\t\tparent_index = clk_super_get_parent(hw);\n\t\tif ((parent_index == mux->div2_index) ||\n\t\t    (parent_index == mux->pllx_index)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tval ^= SUPER_LP_DIV2_BYPASS;\n\t\twritel_relaxed(val, mux->reg);\n\t\tudelay(2);\n\n\t\tif (index == mux->div2_index)\n\t\t\tindex = mux->pllx_index;\n\t}\n\n\t \n\tif ((mux->flags & TEGRA210_CPU_CLK) &&\n\t    (index == CCLK_SRC_PLLP_OUT0 || index == CCLK_SRC_PLLP_OUT4))\n\t\ttegra_clk_set_pllp_out_cpu(true);\n\n\tval &= ~((super_state_to_src_mask(mux)) << shift);\n\tval |= (index & (super_state_to_src_mask(mux))) << shift;\n\n\twritel_relaxed(val, mux->reg);\n\tudelay(2);\n\n\t \n\tif ((mux->flags & TEGRA210_CPU_CLK) &&\n\t    index != CCLK_SRC_PLLP_OUT0 && index != CCLK_SRC_PLLP_OUT4)\n\t\ttegra_clk_set_pllp_out_cpu(false);\n\nout:\n\tif (mux->lock)\n\t\tspin_unlock_irqrestore(mux->lock, flags);\n\n\treturn err;\n}\n\nstatic void clk_super_mux_restore_context(struct clk_hw *hw)\n{\n\tint parent_id;\n\n\tparent_id = clk_hw_get_parent_index(hw);\n\tif (WARN_ON(parent_id < 0))\n\t\treturn;\n\n\tclk_super_set_parent(hw, parent_id);\n}\n\nstatic const struct clk_ops tegra_clk_super_mux_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.get_parent = clk_super_get_parent,\n\t.set_parent = clk_super_set_parent,\n\t.restore_context = clk_super_mux_restore_context,\n};\n\nstatic int clk_super_determine_rate(struct clk_hw *hw,\n\t\t\t\t    struct clk_rate_request *req)\n{\n\tstruct tegra_clk_super_mux *super = to_clk_super_mux(hw);\n\tstruct clk_hw *div_hw = &super->frac_div.hw;\n\tunsigned long rate;\n\n\t__clk_hw_set_clk(div_hw, hw);\n\n\trate = super->div_ops->round_rate(div_hw, req->rate,\n\t\t\t\t\t  &req->best_parent_rate);\n\tif (rate < 0)\n\t\treturn rate;\n\n\treq->rate = rate;\n\treturn 0;\n}\n\nstatic unsigned long clk_super_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct tegra_clk_super_mux *super = to_clk_super_mux(hw);\n\tstruct clk_hw *div_hw = &super->frac_div.hw;\n\n\t__clk_hw_set_clk(div_hw, hw);\n\n\treturn super->div_ops->recalc_rate(div_hw, parent_rate);\n}\n\nstatic int clk_super_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct tegra_clk_super_mux *super = to_clk_super_mux(hw);\n\tstruct clk_hw *div_hw = &super->frac_div.hw;\n\n\t__clk_hw_set_clk(div_hw, hw);\n\n\treturn super->div_ops->set_rate(div_hw, rate, parent_rate);\n}\n\nstatic void clk_super_restore_context(struct clk_hw *hw)\n{\n\tstruct tegra_clk_super_mux *super = to_clk_super_mux(hw);\n\tstruct clk_hw *div_hw = &super->frac_div.hw;\n\tint parent_id;\n\n\tparent_id = clk_hw_get_parent_index(hw);\n\tif (WARN_ON(parent_id < 0))\n\t\treturn;\n\n\tsuper->div_ops->restore_context(div_hw);\n\tclk_super_set_parent(hw, parent_id);\n}\n\nconst struct clk_ops tegra_clk_super_ops = {\n\t.get_parent = clk_super_get_parent,\n\t.set_parent = clk_super_set_parent,\n\t.set_rate = clk_super_set_rate,\n\t.determine_rate = clk_super_determine_rate,\n\t.recalc_rate = clk_super_recalc_rate,\n\t.restore_context = clk_super_restore_context,\n};\n\nstruct clk *tegra_clk_register_super_mux(const char *name,\n\t\tconst char **parent_names, u8 num_parents,\n\t\tunsigned long flags, void __iomem *reg, u8 clk_super_flags,\n\t\tu8 width, u8 pllx_index, u8 div2_index, spinlock_t *lock)\n{\n\tstruct tegra_clk_super_mux *super;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\tsuper = kzalloc(sizeof(*super), GFP_KERNEL);\n\tif (!super)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &tegra_clk_super_mux_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\n\tsuper->reg = reg;\n\tsuper->pllx_index = pllx_index;\n\tsuper->div2_index = div2_index;\n\tsuper->lock = lock;\n\tsuper->width = width;\n\tsuper->flags = clk_super_flags;\n\n\t \n\tsuper->hw.init = &init;\n\n\tclk = tegra_clk_dev_register(&super->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(super);\n\n\treturn clk;\n}\n\nstruct clk *tegra_clk_register_super_clk(const char *name,\n\t\tconst char * const *parent_names, u8 num_parents,\n\t\tunsigned long flags, void __iomem *reg, u8 clk_super_flags,\n\t\tspinlock_t *lock)\n{\n\tstruct tegra_clk_super_mux *super;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\tsuper = kzalloc(sizeof(*super), GFP_KERNEL);\n\tif (!super)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &tegra_clk_super_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\n\tsuper->reg = reg;\n\tsuper->lock = lock;\n\tsuper->width = 4;\n\tsuper->flags = clk_super_flags;\n\tsuper->frac_div.reg = reg + 4;\n\tsuper->frac_div.shift = 16;\n\tsuper->frac_div.width = 8;\n\tsuper->frac_div.frac_width = 1;\n\tsuper->frac_div.lock = lock;\n\tsuper->div_ops = &tegra_clk_frac_div_ops;\n\n\t \n\tsuper->hw.init = &init;\n\n\tclk = clk_register(NULL, &super->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(super);\n\n\treturn clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}