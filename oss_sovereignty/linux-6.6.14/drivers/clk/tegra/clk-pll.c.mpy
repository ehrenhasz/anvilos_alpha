{
  "module_name": "clk-pll.c",
  "hash_id": "ee541057f588ec13b33870ced97a00c852c02165755b981dd0c90ffd44419a52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-pll.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n\n#include \"clk.h\"\n\n#define PLL_BASE_BYPASS BIT(31)\n#define PLL_BASE_ENABLE BIT(30)\n#define PLL_BASE_REF_ENABLE BIT(29)\n#define PLL_BASE_OVERRIDE BIT(28)\n\n#define PLL_BASE_DIVP_SHIFT 20\n#define PLL_BASE_DIVP_WIDTH 3\n#define PLL_BASE_DIVN_SHIFT 8\n#define PLL_BASE_DIVN_WIDTH 10\n#define PLL_BASE_DIVM_SHIFT 0\n#define PLL_BASE_DIVM_WIDTH 5\n#define PLLU_POST_DIVP_MASK 0x1\n\n#define PLL_MISC_DCCON_SHIFT 20\n#define PLL_MISC_CPCON_SHIFT 8\n#define PLL_MISC_CPCON_WIDTH 4\n#define PLL_MISC_CPCON_MASK ((1 << PLL_MISC_CPCON_WIDTH) - 1)\n#define PLL_MISC_LFCON_SHIFT 4\n#define PLL_MISC_LFCON_WIDTH 4\n#define PLL_MISC_LFCON_MASK ((1 << PLL_MISC_LFCON_WIDTH) - 1)\n#define PLL_MISC_VCOCON_SHIFT 0\n#define PLL_MISC_VCOCON_WIDTH 4\n#define PLL_MISC_VCOCON_MASK ((1 << PLL_MISC_VCOCON_WIDTH) - 1)\n\n#define OUT_OF_TABLE_CPCON 8\n\n#define PMC_PLLP_WB0_OVERRIDE 0xf8\n#define PMC_PLLP_WB0_OVERRIDE_PLLM_ENABLE BIT(12)\n#define PMC_PLLP_WB0_OVERRIDE_PLLM_OVERRIDE BIT(11)\n\n#define PLL_POST_LOCK_DELAY 50\n\n#define PLLDU_LFCON_SET_DIVN 600\n\n#define PLLE_BASE_DIVCML_SHIFT 24\n#define PLLE_BASE_DIVCML_MASK 0xf\n#define PLLE_BASE_DIVP_SHIFT 16\n#define PLLE_BASE_DIVP_WIDTH 6\n#define PLLE_BASE_DIVN_SHIFT 8\n#define PLLE_BASE_DIVN_WIDTH 8\n#define PLLE_BASE_DIVM_SHIFT 0\n#define PLLE_BASE_DIVM_WIDTH 8\n#define PLLE_BASE_ENABLE BIT(31)\n\n#define PLLE_MISC_SETUP_BASE_SHIFT 16\n#define PLLE_MISC_SETUP_BASE_MASK (0xffff << PLLE_MISC_SETUP_BASE_SHIFT)\n#define PLLE_MISC_LOCK_ENABLE BIT(9)\n#define PLLE_MISC_READY BIT(15)\n#define PLLE_MISC_SETUP_EX_SHIFT 2\n#define PLLE_MISC_SETUP_EX_MASK (3 << PLLE_MISC_SETUP_EX_SHIFT)\n#define PLLE_MISC_SETUP_MASK (PLLE_MISC_SETUP_BASE_MASK |\t\\\n\t\t\t      PLLE_MISC_SETUP_EX_MASK)\n#define PLLE_MISC_SETUP_VALUE (7 << PLLE_MISC_SETUP_BASE_SHIFT)\n\n#define PLLE_SS_CTRL 0x68\n#define PLLE_SS_CNTL_BYPASS_SS BIT(10)\n#define PLLE_SS_CNTL_INTERP_RESET BIT(11)\n#define PLLE_SS_CNTL_SSC_BYP BIT(12)\n#define PLLE_SS_CNTL_CENTER BIT(14)\n#define PLLE_SS_CNTL_INVERT BIT(15)\n#define PLLE_SS_DISABLE (PLLE_SS_CNTL_BYPASS_SS | PLLE_SS_CNTL_INTERP_RESET |\\\n\t\t\t\tPLLE_SS_CNTL_SSC_BYP)\n#define PLLE_SS_MAX_MASK 0x1ff\n#define PLLE_SS_MAX_VAL_TEGRA114 0x25\n#define PLLE_SS_MAX_VAL_TEGRA210 0x21\n#define PLLE_SS_INC_MASK (0xff << 16)\n#define PLLE_SS_INC_VAL (0x1 << 16)\n#define PLLE_SS_INCINTRV_MASK (0x3f << 24)\n#define PLLE_SS_INCINTRV_VAL_TEGRA114 (0x20 << 24)\n#define PLLE_SS_INCINTRV_VAL_TEGRA210 (0x23 << 24)\n#define PLLE_SS_COEFFICIENTS_MASK \\\n\t(PLLE_SS_MAX_MASK | PLLE_SS_INC_MASK | PLLE_SS_INCINTRV_MASK)\n#define PLLE_SS_COEFFICIENTS_VAL_TEGRA114 \\\n\t(PLLE_SS_MAX_VAL_TEGRA114 | PLLE_SS_INC_VAL |\\\n\t PLLE_SS_INCINTRV_VAL_TEGRA114)\n#define PLLE_SS_COEFFICIENTS_VAL_TEGRA210 \\\n\t(PLLE_SS_MAX_VAL_TEGRA210 | PLLE_SS_INC_VAL |\\\n\t PLLE_SS_INCINTRV_VAL_TEGRA210)\n\n#define PLLE_AUX_PLLP_SEL\tBIT(2)\n#define PLLE_AUX_USE_LOCKDET\tBIT(3)\n#define PLLE_AUX_ENABLE_SWCTL\tBIT(4)\n#define PLLE_AUX_SS_SWCTL\tBIT(6)\n#define PLLE_AUX_SEQ_ENABLE\tBIT(24)\n#define PLLE_AUX_SEQ_START_STATE BIT(25)\n#define PLLE_AUX_PLLRE_SEL\tBIT(28)\n#define PLLE_AUX_SS_SEQ_INCLUDE\tBIT(31)\n\n#define XUSBIO_PLL_CFG0\t\t0x51c\n#define XUSBIO_PLL_CFG0_PADPLL_RESET_SWCTL\tBIT(0)\n#define XUSBIO_PLL_CFG0_CLK_ENABLE_SWCTL\tBIT(2)\n#define XUSBIO_PLL_CFG0_PADPLL_USE_LOCKDET\tBIT(6)\n#define XUSBIO_PLL_CFG0_SEQ_ENABLE\t\tBIT(24)\n#define XUSBIO_PLL_CFG0_SEQ_START_STATE\t\tBIT(25)\n\n#define SATA_PLL_CFG0\t\t0x490\n#define SATA_PLL_CFG0_PADPLL_RESET_SWCTL\tBIT(0)\n#define SATA_PLL_CFG0_PADPLL_USE_LOCKDET\tBIT(2)\n#define SATA_PLL_CFG0_SEQ_ENABLE\t\tBIT(24)\n#define SATA_PLL_CFG0_SEQ_START_STATE\t\tBIT(25)\n\n#define PLLE_MISC_PLLE_PTS\tBIT(8)\n#define PLLE_MISC_IDDQ_SW_VALUE\tBIT(13)\n#define PLLE_MISC_IDDQ_SW_CTRL\tBIT(14)\n#define PLLE_MISC_VREG_BG_CTRL_SHIFT\t4\n#define PLLE_MISC_VREG_BG_CTRL_MASK\t(3 << PLLE_MISC_VREG_BG_CTRL_SHIFT)\n#define PLLE_MISC_VREG_CTRL_SHIFT\t2\n#define PLLE_MISC_VREG_CTRL_MASK\t(2 << PLLE_MISC_VREG_CTRL_SHIFT)\n\n#define PLLCX_MISC_STROBE\tBIT(31)\n#define PLLCX_MISC_RESET\tBIT(30)\n#define PLLCX_MISC_SDM_DIV_SHIFT 28\n#define PLLCX_MISC_SDM_DIV_MASK (0x3 << PLLCX_MISC_SDM_DIV_SHIFT)\n#define PLLCX_MISC_FILT_DIV_SHIFT 26\n#define PLLCX_MISC_FILT_DIV_MASK (0x3 << PLLCX_MISC_FILT_DIV_SHIFT)\n#define PLLCX_MISC_ALPHA_SHIFT 18\n#define PLLCX_MISC_DIV_LOW_RANGE \\\n\t\t((0x1 << PLLCX_MISC_SDM_DIV_SHIFT) | \\\n\t\t(0x1 << PLLCX_MISC_FILT_DIV_SHIFT))\n#define PLLCX_MISC_DIV_HIGH_RANGE \\\n\t\t((0x2 << PLLCX_MISC_SDM_DIV_SHIFT) | \\\n\t\t(0x2 << PLLCX_MISC_FILT_DIV_SHIFT))\n#define PLLCX_MISC_COEF_LOW_RANGE \\\n\t\t((0x14 << PLLCX_MISC_KA_SHIFT) | (0x38 << PLLCX_MISC_KB_SHIFT))\n#define PLLCX_MISC_KA_SHIFT 2\n#define PLLCX_MISC_KB_SHIFT 9\n#define PLLCX_MISC_DEFAULT (PLLCX_MISC_COEF_LOW_RANGE | \\\n\t\t\t    (0x19 << PLLCX_MISC_ALPHA_SHIFT) | \\\n\t\t\t    PLLCX_MISC_DIV_LOW_RANGE | \\\n\t\t\t    PLLCX_MISC_RESET)\n#define PLLCX_MISC1_DEFAULT 0x000d2308\n#define PLLCX_MISC2_DEFAULT 0x30211200\n#define PLLCX_MISC3_DEFAULT 0x200\n\n#define PMC_SATA_PWRGT 0x1ac\n#define PMC_SATA_PWRGT_PLLE_IDDQ_VALUE BIT(5)\n#define PMC_SATA_PWRGT_PLLE_IDDQ_SWCTL BIT(4)\n\n#define PLLSS_MISC_KCP\t\t0\n#define PLLSS_MISC_KVCO\t\t0\n#define PLLSS_MISC_SETUP\t0\n#define PLLSS_EN_SDM\t\t0\n#define PLLSS_EN_SSC\t\t0\n#define PLLSS_EN_DITHER2\t0\n#define PLLSS_EN_DITHER\t\t1\n#define PLLSS_SDM_RESET\t\t0\n#define PLLSS_CLAMP\t\t0\n#define PLLSS_SDM_SSC_MAX\t0\n#define PLLSS_SDM_SSC_MIN\t0\n#define PLLSS_SDM_SSC_STEP\t0\n#define PLLSS_SDM_DIN\t\t0\n#define PLLSS_MISC_DEFAULT ((PLLSS_MISC_KCP << 25) | \\\n\t\t\t    (PLLSS_MISC_KVCO << 24) | \\\n\t\t\t    PLLSS_MISC_SETUP)\n#define PLLSS_CFG_DEFAULT ((PLLSS_EN_SDM << 31) | \\\n\t\t\t   (PLLSS_EN_SSC << 30) | \\\n\t\t\t   (PLLSS_EN_DITHER2 << 29) | \\\n\t\t\t   (PLLSS_EN_DITHER << 28) | \\\n\t\t\t   (PLLSS_SDM_RESET) << 27 | \\\n\t\t\t   (PLLSS_CLAMP << 22))\n#define PLLSS_CTRL1_DEFAULT \\\n\t\t\t((PLLSS_SDM_SSC_MAX << 16) | PLLSS_SDM_SSC_MIN)\n#define PLLSS_CTRL2_DEFAULT \\\n\t\t\t((PLLSS_SDM_SSC_STEP << 16) | PLLSS_SDM_DIN)\n#define PLLSS_LOCK_OVERRIDE\tBIT(24)\n#define PLLSS_REF_SRC_SEL_SHIFT\t25\n#define PLLSS_REF_SRC_SEL_MASK\t(3 << PLLSS_REF_SRC_SEL_SHIFT)\n\n#define UTMIP_PLL_CFG1 0x484\n#define UTMIP_PLL_CFG1_XTAL_FREQ_COUNT(x) (((x) & 0xfff) << 0)\n#define UTMIP_PLL_CFG1_ENABLE_DLY_COUNT(x) (((x) & 0x1f) << 27)\n#define UTMIP_PLL_CFG1_FORCE_PLL_ACTIVE_POWERDOWN BIT(12)\n#define UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERDOWN BIT(14)\n#define UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERUP BIT(15)\n#define UTMIP_PLL_CFG1_FORCE_PLLU_POWERDOWN BIT(16)\n#define UTMIP_PLL_CFG1_FORCE_PLLU_POWERUP BIT(17)\n\n#define UTMIP_PLL_CFG2 0x488\n#define UTMIP_PLL_CFG2_STABLE_COUNT(x) (((x) & 0xfff) << 6)\n#define UTMIP_PLL_CFG2_ACTIVE_DLY_COUNT(x) (((x) & 0x3f) << 18)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_A_POWERDOWN BIT(0)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_A_POWERUP BIT(1)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_B_POWERDOWN BIT(2)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_B_POWERUP BIT(3)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_C_POWERDOWN BIT(4)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_C_POWERUP BIT(5)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_D_POWERDOWN BIT(24)\n#define UTMIP_PLL_CFG2_FORCE_PD_SAMP_D_POWERUP BIT(25)\n#define UTMIP_PLL_CFG2_PHY_XTAL_CLOCKEN BIT(30)\n\n#define UTMIPLL_HW_PWRDN_CFG0 0x52c\n#define UTMIPLL_HW_PWRDN_CFG0_IDDQ_SWCTL BIT(0)\n#define UTMIPLL_HW_PWRDN_CFG0_IDDQ_OVERRIDE BIT(1)\n#define UTMIPLL_HW_PWRDN_CFG0_CLK_ENABLE_SWCTL BIT(2)\n#define UTMIPLL_HW_PWRDN_CFG0_SEQ_IN_SWCTL BIT(4)\n#define UTMIPLL_HW_PWRDN_CFG0_SEQ_RESET_INPUT_VALUE BIT(5)\n#define UTMIPLL_HW_PWRDN_CFG0_USE_LOCKDET BIT(6)\n#define UTMIPLL_HW_PWRDN_CFG0_SEQ_ENABLE BIT(24)\n#define UTMIPLL_HW_PWRDN_CFG0_SEQ_START_STATE BIT(25)\n\n#define PLLU_HW_PWRDN_CFG0 0x530\n#define PLLU_HW_PWRDN_CFG0_CLK_SWITCH_SWCTL BIT(0)\n#define PLLU_HW_PWRDN_CFG0_CLK_ENABLE_SWCTL BIT(2)\n#define PLLU_HW_PWRDN_CFG0_USE_LOCKDET BIT(6)\n#define PLLU_HW_PWRDN_CFG0_USE_SWITCH_DETECT BIT(7)\n#define PLLU_HW_PWRDN_CFG0_SEQ_ENABLE BIT(24)\n#define PLLU_HW_PWRDN_CFG0_IDDQ_PD_INCLUDE BIT(28)\n\n#define XUSB_PLL_CFG0 0x534\n#define XUSB_PLL_CFG0_UTMIPLL_LOCK_DLY 0x3ff\n#define XUSB_PLL_CFG0_PLLU_LOCK_DLY (0x3ff << 14)\n\n#define PLLU_BASE_CLKENABLE_USB BIT(21)\n#define PLLU_BASE_OVERRIDE BIT(24)\n\n#define pll_readl(offset, p) readl_relaxed(p->clk_base + offset)\n#define pll_readl_base(p) pll_readl(p->params->base_reg, p)\n#define pll_readl_misc(p) pll_readl(p->params->misc_reg, p)\n#define pll_override_readl(offset, p) readl_relaxed(p->pmc + offset)\n#define pll_readl_sdm_din(p) pll_readl(p->params->sdm_din_reg, p)\n#define pll_readl_sdm_ctrl(p) pll_readl(p->params->sdm_ctrl_reg, p)\n\n#define pll_writel(val, offset, p) writel_relaxed(val, p->clk_base + offset)\n#define pll_writel_base(val, p) pll_writel(val, p->params->base_reg, p)\n#define pll_writel_misc(val, p) pll_writel(val, p->params->misc_reg, p)\n#define pll_override_writel(val, offset, p) writel(val, p->pmc + offset)\n#define pll_writel_sdm_din(val, p) pll_writel(val, p->params->sdm_din_reg, p)\n#define pll_writel_sdm_ctrl(val, p) pll_writel(val, p->params->sdm_ctrl_reg, p)\n\n#define mask(w) ((1 << (w)) - 1)\n#define divm_mask(p) mask(p->params->div_nmp->divm_width)\n#define divn_mask(p) mask(p->params->div_nmp->divn_width)\n#define divp_mask(p) (p->params->flags & TEGRA_PLLU ? PLLU_POST_DIVP_MASK :\\\n\t\t      mask(p->params->div_nmp->divp_width))\n#define sdm_din_mask(p) p->params->sdm_din_mask\n#define sdm_en_mask(p) p->params->sdm_ctrl_en_mask\n\n#define divm_shift(p) (p)->params->div_nmp->divm_shift\n#define divn_shift(p) (p)->params->div_nmp->divn_shift\n#define divp_shift(p) (p)->params->div_nmp->divp_shift\n\n#define divm_mask_shifted(p) (divm_mask(p) << divm_shift(p))\n#define divn_mask_shifted(p) (divn_mask(p) << divn_shift(p))\n#define divp_mask_shifted(p) (divp_mask(p) << divp_shift(p))\n\n#define divm_max(p) (divm_mask(p))\n#define divn_max(p) (divn_mask(p))\n#define divp_max(p) (1 << (divp_mask(p)))\n\n#define sdin_din_to_data(din)\t((u16)((din) ? : 0xFFFFU))\n#define sdin_data_to_din(dat)\t(((dat) == 0xFFFFU) ? 0 : (s16)dat)\n\nstatic struct div_nmp default_nmp = {\n\t.divn_shift = PLL_BASE_DIVN_SHIFT,\n\t.divn_width = PLL_BASE_DIVN_WIDTH,\n\t.divm_shift = PLL_BASE_DIVM_SHIFT,\n\t.divm_width = PLL_BASE_DIVM_WIDTH,\n\t.divp_shift = PLL_BASE_DIVP_SHIFT,\n\t.divp_width = PLL_BASE_DIVP_WIDTH,\n};\n\nstatic void clk_pll_enable_lock(struct tegra_clk_pll *pll)\n{\n\tu32 val;\n\n\tif (!(pll->params->flags & TEGRA_PLL_USE_LOCK))\n\t\treturn;\n\n\tif (!(pll->params->flags & TEGRA_PLL_HAS_LOCK_ENABLE))\n\t\treturn;\n\n\tval = pll_readl_misc(pll);\n\tval |= BIT(pll->params->lock_enable_bit_idx);\n\tpll_writel_misc(val, pll);\n}\n\nstatic int clk_pll_wait_for_lock(struct tegra_clk_pll *pll)\n{\n\tint i;\n\tu32 val, lock_mask;\n\tvoid __iomem *lock_addr;\n\n\tif (!(pll->params->flags & TEGRA_PLL_USE_LOCK)) {\n\t\tudelay(pll->params->lock_delay);\n\t\treturn 0;\n\t}\n\n\tlock_addr = pll->clk_base;\n\tif (pll->params->flags & TEGRA_PLL_LOCK_MISC)\n\t\tlock_addr += pll->params->misc_reg;\n\telse\n\t\tlock_addr += pll->params->base_reg;\n\n\tlock_mask = pll->params->lock_mask;\n\n\tfor (i = 0; i < pll->params->lock_delay; i++) {\n\t\tval = readl_relaxed(lock_addr);\n\t\tif ((val & lock_mask) == lock_mask) {\n\t\t\tudelay(PLL_POST_LOCK_DELAY);\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(2);  \n\t}\n\n\tpr_err(\"%s: Timed out waiting for pll %s lock\\n\", __func__,\n\t       clk_hw_get_name(&pll->hw));\n\n\treturn -1;\n}\n\nint tegra_pll_wait_for_lock(struct tegra_clk_pll *pll)\n{\n\treturn clk_pll_wait_for_lock(pll);\n}\n\nstatic bool pllm_clk_is_gated_by_pmc(struct tegra_clk_pll *pll)\n{\n\tu32 val = readl_relaxed(pll->pmc + PMC_PLLP_WB0_OVERRIDE);\n\n\treturn (val & PMC_PLLP_WB0_OVERRIDE_PLLM_OVERRIDE) &&\n\t      !(val & PMC_PLLP_WB0_OVERRIDE_PLLM_ENABLE);\n}\n\nstatic int clk_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tu32 val;\n\n\t \n\tif ((pll->params->flags & TEGRA_PLLM) && pllm_clk_is_gated_by_pmc(pll))\n\t\treturn 0;\n\n\tval = pll_readl_base(pll);\n\n\treturn val & PLL_BASE_ENABLE ? 1 : 0;\n}\n\nstatic void _clk_pll_enable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tu32 val;\n\n\tif (pll->params->iddq_reg) {\n\t\tval = pll_readl(pll->params->iddq_reg, pll);\n\t\tval &= ~BIT(pll->params->iddq_bit_idx);\n\t\tpll_writel(val, pll->params->iddq_reg, pll);\n\t\tudelay(5);\n\t}\n\n\tif (pll->params->reset_reg) {\n\t\tval = pll_readl(pll->params->reset_reg, pll);\n\t\tval &= ~BIT(pll->params->reset_bit_idx);\n\t\tpll_writel(val, pll->params->reset_reg, pll);\n\t}\n\n\tclk_pll_enable_lock(pll);\n\n\tval = pll_readl_base(pll);\n\tif (pll->params->flags & TEGRA_PLL_BYPASS)\n\t\tval &= ~PLL_BASE_BYPASS;\n\tval |= PLL_BASE_ENABLE;\n\tpll_writel_base(val, pll);\n\n\tif (pll->params->flags & TEGRA_PLLM) {\n\t\tval = readl_relaxed(pll->pmc + PMC_PLLP_WB0_OVERRIDE);\n\t\tval |= PMC_PLLP_WB0_OVERRIDE_PLLM_ENABLE;\n\t\twritel_relaxed(val, pll->pmc + PMC_PLLP_WB0_OVERRIDE);\n\t}\n}\n\nstatic void _clk_pll_disable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tu32 val;\n\n\tval = pll_readl_base(pll);\n\tif (pll->params->flags & TEGRA_PLL_BYPASS)\n\t\tval &= ~PLL_BASE_BYPASS;\n\tval &= ~PLL_BASE_ENABLE;\n\tpll_writel_base(val, pll);\n\n\tif (pll->params->flags & TEGRA_PLLM) {\n\t\tval = readl_relaxed(pll->pmc + PMC_PLLP_WB0_OVERRIDE);\n\t\tval &= ~PMC_PLLP_WB0_OVERRIDE_PLLM_ENABLE;\n\t\twritel_relaxed(val, pll->pmc + PMC_PLLP_WB0_OVERRIDE);\n\t}\n\n\tif (pll->params->reset_reg) {\n\t\tval = pll_readl(pll->params->reset_reg, pll);\n\t\tval |= BIT(pll->params->reset_bit_idx);\n\t\tpll_writel(val, pll->params->reset_reg, pll);\n\t}\n\n\tif (pll->params->iddq_reg) {\n\t\tval = pll_readl(pll->params->iddq_reg, pll);\n\t\tval |= BIT(pll->params->iddq_bit_idx);\n\t\tpll_writel(val, pll->params->iddq_reg, pll);\n\t\tudelay(2);\n\t}\n}\n\nstatic void pll_clk_start_ss(struct tegra_clk_pll *pll)\n{\n\tif (pll->params->defaults_set && pll->params->ssc_ctrl_reg) {\n\t\tu32 val = pll_readl(pll->params->ssc_ctrl_reg, pll);\n\n\t\tval |= pll->params->ssc_ctrl_en_mask;\n\t\tpll_writel(val, pll->params->ssc_ctrl_reg, pll);\n\t}\n}\n\nstatic void pll_clk_stop_ss(struct tegra_clk_pll *pll)\n{\n\tif (pll->params->defaults_set && pll->params->ssc_ctrl_reg) {\n\t\tu32 val = pll_readl(pll->params->ssc_ctrl_reg, pll);\n\n\t\tval &= ~pll->params->ssc_ctrl_en_mask;\n\t\tpll_writel(val, pll->params->ssc_ctrl_reg, pll);\n\t}\n}\n\nstatic int clk_pll_enable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (clk_pll_is_enabled(hw))\n\t\treturn 0;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\t_clk_pll_enable(hw);\n\n\tret = clk_pll_wait_for_lock(pll);\n\n\tpll_clk_start_ss(pll);\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\treturn ret;\n}\n\nstatic void clk_pll_disable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tunsigned long flags = 0;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\tpll_clk_stop_ss(pll);\n\n\t_clk_pll_disable(hw);\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n}\n\nstatic int _p_div_to_hw(struct clk_hw *hw, u8 p_div)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tconst struct pdiv_map *p_tohw = pll->params->pdiv_tohw;\n\n\tif (p_tohw) {\n\t\twhile (p_tohw->pdiv) {\n\t\t\tif (p_div <= p_tohw->pdiv)\n\t\t\t\treturn p_tohw->hw_val;\n\t\t\tp_tohw++;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\treturn -EINVAL;\n}\n\nint tegra_pll_p_div_to_hw(struct tegra_clk_pll *pll, u8 p_div)\n{\n\treturn _p_div_to_hw(&pll->hw, p_div);\n}\n\nstatic int _hw_to_p_div(struct clk_hw *hw, u8 p_div_hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tconst struct pdiv_map *p_tohw = pll->params->pdiv_tohw;\n\n\tif (p_tohw) {\n\t\twhile (p_tohw->pdiv) {\n\t\t\tif (p_div_hw == p_tohw->hw_val)\n\t\t\t\treturn p_tohw->pdiv;\n\t\t\tp_tohw++;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\treturn 1 << p_div_hw;\n}\n\nstatic int _get_table_rate(struct clk_hw *hw,\n\t\t\t   struct tegra_clk_pll_freq_table *cfg,\n\t\t\t   unsigned long rate, unsigned long parent_rate)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tstruct tegra_clk_pll_freq_table *sel;\n\tint p;\n\n\tfor (sel = pll->params->freq_table; sel->input_rate != 0; sel++)\n\t\tif (sel->input_rate == parent_rate &&\n\t\t    sel->output_rate == rate)\n\t\t\tbreak;\n\n\tif (sel->input_rate == 0)\n\t\treturn -EINVAL;\n\n\tif (pll->params->pdiv_tohw) {\n\t\tp = _p_div_to_hw(hw, sel->p);\n\t\tif (p < 0)\n\t\t\treturn p;\n\t} else {\n\t\tp = ilog2(sel->p);\n\t}\n\n\tcfg->input_rate = sel->input_rate;\n\tcfg->output_rate = sel->output_rate;\n\tcfg->m = sel->m;\n\tcfg->n = sel->n;\n\tcfg->p = p;\n\tcfg->cpcon = sel->cpcon;\n\tcfg->sdm_data = sel->sdm_data;\n\n\treturn 0;\n}\n\nstatic int _calc_rate(struct clk_hw *hw, struct tegra_clk_pll_freq_table *cfg,\n\t\t      unsigned long rate, unsigned long parent_rate)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tunsigned long cfreq;\n\tu32 p_div = 0;\n\tint ret;\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\tswitch (parent_rate) {\n\tcase 12000000:\n\tcase 26000000:\n\t\tcfreq = (rate <= 1000000 * 1000) ? 1000000 : 2000000;\n\t\tbreak;\n\tcase 13000000:\n\t\tcfreq = (rate <= 1000000 * 1000) ? 1000000 : 2600000;\n\t\tbreak;\n\tcase 16800000:\n\tcase 19200000:\n\t\tcfreq = (rate <= 1200000 * 1000) ? 1200000 : 2400000;\n\t\tbreak;\n\tcase 9600000:\n\tcase 28800000:\n\t\t \n\t\tcfreq = parent_rate / (parent_rate / 1000000);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s Unexpected reference rate %lu\\n\",\n\t\t       __func__, parent_rate);\n\t\tBUG();\n\t}\n\n\t \n\tfor (cfg->output_rate = rate; cfg->output_rate < 200 * cfreq;\n\t     cfg->output_rate <<= 1)\n\t\tp_div++;\n\n\tcfg->m = parent_rate / cfreq;\n\tcfg->n = cfg->output_rate / cfreq;\n\tcfg->cpcon = OUT_OF_TABLE_CPCON;\n\n\tif (cfg->m == 0 || cfg->m > divm_max(pll) ||\n\t    cfg->n > divn_max(pll) || (1 << p_div) > divp_max(pll) ||\n\t    cfg->output_rate > pll->params->vco_max) {\n\t\treturn -EINVAL;\n\t}\n\n\tcfg->output_rate = cfg->n * DIV_ROUND_UP(parent_rate, cfg->m);\n\tcfg->output_rate >>= p_div;\n\n\tif (pll->params->pdiv_tohw) {\n\t\tret = _p_div_to_hw(hw, 1 << p_div);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\tcfg->p = ret;\n\t} else\n\t\tcfg->p = p_div;\n\n\treturn 0;\n}\n\n \nstatic void clk_pll_set_sdm_data(struct clk_hw *hw,\n\t\t\t\t struct tegra_clk_pll_freq_table *cfg)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tu32 val;\n\tbool enabled;\n\n\tif (!pll->params->sdm_din_reg)\n\t\treturn;\n\n\tif (cfg->sdm_data) {\n\t\tval = pll_readl_sdm_din(pll) & (~sdm_din_mask(pll));\n\t\tval |= sdin_data_to_din(cfg->sdm_data) & sdm_din_mask(pll);\n\t\tpll_writel_sdm_din(val, pll);\n\t}\n\n\tval = pll_readl_sdm_ctrl(pll);\n\tenabled = (val & sdm_en_mask(pll));\n\n\tif (cfg->sdm_data == 0 && enabled)\n\t\tval &= ~pll->params->sdm_ctrl_en_mask;\n\n\tif (cfg->sdm_data != 0 && !enabled)\n\t\tval |= pll->params->sdm_ctrl_en_mask;\n\n\tpll_writel_sdm_ctrl(val, pll);\n}\n\nstatic void _update_pll_mnp(struct tegra_clk_pll *pll,\n\t\t\t    struct tegra_clk_pll_freq_table *cfg)\n{\n\tu32 val;\n\tstruct tegra_clk_pll_params *params = pll->params;\n\tstruct div_nmp *div_nmp = params->div_nmp;\n\n\tif ((params->flags & (TEGRA_PLLM | TEGRA_PLLMB)) &&\n\t\t(pll_override_readl(PMC_PLLP_WB0_OVERRIDE, pll) &\n\t\t\tPMC_PLLP_WB0_OVERRIDE_PLLM_OVERRIDE)) {\n\t\tval = pll_override_readl(params->pmc_divp_reg, pll);\n\t\tval &= ~(divp_mask(pll) << div_nmp->override_divp_shift);\n\t\tval |= cfg->p << div_nmp->override_divp_shift;\n\t\tpll_override_writel(val, params->pmc_divp_reg, pll);\n\n\t\tval = pll_override_readl(params->pmc_divnm_reg, pll);\n\t\tval &= ~((divm_mask(pll) << div_nmp->override_divm_shift) |\n\t\t\t(divn_mask(pll) << div_nmp->override_divn_shift));\n\t\tval |= (cfg->m << div_nmp->override_divm_shift) |\n\t\t\t(cfg->n << div_nmp->override_divn_shift);\n\t\tpll_override_writel(val, params->pmc_divnm_reg, pll);\n\t} else {\n\t\tval = pll_readl_base(pll);\n\n\t\tval &= ~(divm_mask_shifted(pll) | divn_mask_shifted(pll) |\n\t\t\t divp_mask_shifted(pll));\n\n\t\tval |= (cfg->m << divm_shift(pll)) |\n\t\t       (cfg->n << divn_shift(pll)) |\n\t\t       (cfg->p << divp_shift(pll));\n\n\t\tpll_writel_base(val, pll);\n\n\t\tclk_pll_set_sdm_data(&pll->hw, cfg);\n\t}\n}\n\nstatic void _get_pll_mnp(struct tegra_clk_pll *pll,\n\t\t\t struct tegra_clk_pll_freq_table *cfg)\n{\n\tu32 val;\n\tstruct tegra_clk_pll_params *params = pll->params;\n\tstruct div_nmp *div_nmp = params->div_nmp;\n\n\t*cfg = (struct tegra_clk_pll_freq_table) { };\n\n\tif ((params->flags & (TEGRA_PLLM | TEGRA_PLLMB)) &&\n\t\t(pll_override_readl(PMC_PLLP_WB0_OVERRIDE, pll) &\n\t\t\tPMC_PLLP_WB0_OVERRIDE_PLLM_OVERRIDE)) {\n\t\tval = pll_override_readl(params->pmc_divp_reg, pll);\n\t\tcfg->p = (val >> div_nmp->override_divp_shift) & divp_mask(pll);\n\n\t\tval = pll_override_readl(params->pmc_divnm_reg, pll);\n\t\tcfg->m = (val >> div_nmp->override_divm_shift) & divm_mask(pll);\n\t\tcfg->n = (val >> div_nmp->override_divn_shift) & divn_mask(pll);\n\t}  else {\n\t\tval = pll_readl_base(pll);\n\n\t\tcfg->m = (val >> div_nmp->divm_shift) & divm_mask(pll);\n\t\tcfg->n = (val >> div_nmp->divn_shift) & divn_mask(pll);\n\t\tcfg->p = (val >> div_nmp->divp_shift) & divp_mask(pll);\n\n\t\tif (pll->params->sdm_din_reg) {\n\t\t\tif (sdm_en_mask(pll) & pll_readl_sdm_ctrl(pll)) {\n\t\t\t\tval = pll_readl_sdm_din(pll);\n\t\t\t\tval &= sdm_din_mask(pll);\n\t\t\t\tcfg->sdm_data = sdin_din_to_data(val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void _update_pll_cpcon(struct tegra_clk_pll *pll,\n\t\t\t      struct tegra_clk_pll_freq_table *cfg,\n\t\t\t      unsigned long rate)\n{\n\tu32 val;\n\n\tval = pll_readl_misc(pll);\n\n\tval &= ~(PLL_MISC_CPCON_MASK << PLL_MISC_CPCON_SHIFT);\n\tval |= cfg->cpcon << PLL_MISC_CPCON_SHIFT;\n\n\tif (pll->params->flags & TEGRA_PLL_SET_LFCON) {\n\t\tval &= ~(PLL_MISC_LFCON_MASK << PLL_MISC_LFCON_SHIFT);\n\t\tif (cfg->n >= PLLDU_LFCON_SET_DIVN)\n\t\t\tval |= 1 << PLL_MISC_LFCON_SHIFT;\n\t} else if (pll->params->flags & TEGRA_PLL_SET_DCCON) {\n\t\tval &= ~(1 << PLL_MISC_DCCON_SHIFT);\n\t\tif (rate >= (pll->params->vco_max >> 1))\n\t\t\tval |= 1 << PLL_MISC_DCCON_SHIFT;\n\t}\n\n\tpll_writel_misc(val, pll);\n}\n\nstatic int _program_pll(struct clk_hw *hw, struct tegra_clk_pll_freq_table *cfg,\n\t\t\tunsigned long rate)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tstruct tegra_clk_pll_freq_table old_cfg;\n\tint state, ret = 0;\n\n\tstate = clk_pll_is_enabled(hw);\n\n\tif (state && pll->params->pre_rate_change) {\n\t\tret = pll->params->pre_rate_change();\n\t\tif (WARN_ON(ret))\n\t\t\treturn ret;\n\t}\n\n\t_get_pll_mnp(pll, &old_cfg);\n\n\tif (state && pll->params->defaults_set && pll->params->dyn_ramp &&\n\t\t\t(cfg->m == old_cfg.m) && (cfg->p == old_cfg.p)) {\n\t\tret = pll->params->dyn_ramp(pll, cfg);\n\t\tif (!ret)\n\t\t\tgoto done;\n\t}\n\n\tif (state) {\n\t\tpll_clk_stop_ss(pll);\n\t\t_clk_pll_disable(hw);\n\t}\n\n\tif (!pll->params->defaults_set && pll->params->set_defaults)\n\t\tpll->params->set_defaults(pll);\n\n\t_update_pll_mnp(pll, cfg);\n\n\tif (pll->params->flags & TEGRA_PLL_HAS_CPCON)\n\t\t_update_pll_cpcon(pll, cfg, rate);\n\n\tif (state) {\n\t\t_clk_pll_enable(hw);\n\t\tret = clk_pll_wait_for_lock(pll);\n\t\tpll_clk_start_ss(pll);\n\t}\n\ndone:\n\tif (state && pll->params->post_rate_change)\n\t\tpll->params->post_rate_change();\n\n\treturn ret;\n}\n\nstatic int clk_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\tunsigned long parent_rate)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tstruct tegra_clk_pll_freq_table cfg, old_cfg;\n\tunsigned long flags = 0;\n\tint ret = 0;\n\n\tif (pll->params->flags & TEGRA_PLL_FIXED) {\n\t\tif (rate != pll->params->fixed_rate) {\n\t\t\tpr_err(\"%s: Can not change %s fixed rate %lu to %lu\\n\",\n\t\t\t\t__func__, clk_hw_get_name(hw),\n\t\t\t\tpll->params->fixed_rate, rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (_get_table_rate(hw, &cfg, rate, parent_rate) &&\n\t    pll->params->calc_rate(hw, &cfg, rate, parent_rate)) {\n\t\tpr_err(\"%s: Failed to set %s rate %lu\\n\", __func__,\n\t\t       clk_hw_get_name(hw), rate);\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\t_get_pll_mnp(pll, &old_cfg);\n\tif (pll->params->flags & TEGRA_PLL_VCO_OUT)\n\t\tcfg.p = old_cfg.p;\n\n\tif (old_cfg.m != cfg.m || old_cfg.n != cfg.n || old_cfg.p != cfg.p ||\n\t\told_cfg.sdm_data != cfg.sdm_data)\n\t\tret = _program_pll(hw, &cfg, rate);\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\treturn ret;\n}\n\nstatic long clk_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\tunsigned long *prate)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tstruct tegra_clk_pll_freq_table cfg;\n\n\tif (pll->params->flags & TEGRA_PLL_FIXED) {\n\t\t \n\t\tif (pll->params->flags & (TEGRA_PLLM | TEGRA_PLLMB))\n\t\t\treturn clk_hw_get_rate(hw);\n\t\treturn pll->params->fixed_rate;\n\t}\n\n\tif (_get_table_rate(hw, &cfg, rate, *prate) &&\n\t    pll->params->calc_rate(hw, &cfg, rate, *prate))\n\t\treturn -EINVAL;\n\n\treturn cfg.output_rate;\n}\n\nstatic unsigned long clk_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tstruct tegra_clk_pll_freq_table cfg;\n\tu32 val;\n\tu64 rate = parent_rate;\n\tint pdiv;\n\n\tval = pll_readl_base(pll);\n\n\tif ((pll->params->flags & TEGRA_PLL_BYPASS) && (val & PLL_BASE_BYPASS))\n\t\treturn parent_rate;\n\n\tif ((pll->params->flags & TEGRA_PLL_FIXED) &&\n\t    !(pll->params->flags & (TEGRA_PLLM | TEGRA_PLLMB)) &&\n\t\t\t!(val & PLL_BASE_OVERRIDE)) {\n\t\tstruct tegra_clk_pll_freq_table sel;\n\t\tif (_get_table_rate(hw, &sel, pll->params->fixed_rate,\n\t\t\t\t\tparent_rate)) {\n\t\t\tpr_err(\"Clock %s has unknown fixed frequency\\n\",\n\t\t\t       clk_hw_get_name(hw));\n\t\t\tBUG();\n\t\t}\n\t\treturn pll->params->fixed_rate;\n\t}\n\n\t_get_pll_mnp(pll, &cfg);\n\n\tif (pll->params->flags & TEGRA_PLL_VCO_OUT) {\n\t\tpdiv = 1;\n\t} else {\n\t\tpdiv = _hw_to_p_div(hw, cfg.p);\n\t\tif (pdiv < 0) {\n\t\t\tWARN(1, \"Clock %s has invalid pdiv value : 0x%x\\n\",\n\t\t\t     clk_hw_get_name(hw), cfg.p);\n\t\t\tpdiv = 1;\n\t\t}\n\t}\n\n\tif (pll->params->set_gain)\n\t\tpll->params->set_gain(&cfg);\n\n\tcfg.m *= pdiv;\n\n\trate *= cfg.n;\n\tdo_div(rate, cfg.m);\n\n\treturn rate;\n}\n\nstatic int clk_plle_training(struct tegra_clk_pll *pll)\n{\n\tu32 val;\n\tunsigned long timeout;\n\n\tif (!pll->pmc)\n\t\treturn -ENOSYS;\n\n\t \n\tval = readl(pll->pmc + PMC_SATA_PWRGT);\n\tval |= PMC_SATA_PWRGT_PLLE_IDDQ_VALUE;\n\twritel(val, pll->pmc + PMC_SATA_PWRGT);\n\n\tval = readl(pll->pmc + PMC_SATA_PWRGT);\n\tval |= PMC_SATA_PWRGT_PLLE_IDDQ_SWCTL;\n\twritel(val, pll->pmc + PMC_SATA_PWRGT);\n\n\tval = readl(pll->pmc + PMC_SATA_PWRGT);\n\tval &= ~PMC_SATA_PWRGT_PLLE_IDDQ_VALUE;\n\twritel(val, pll->pmc + PMC_SATA_PWRGT);\n\n\tval = pll_readl_misc(pll);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\twhile (1) {\n\t\tval = pll_readl_misc(pll);\n\t\tif (val & PLLE_MISC_READY)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tpr_err(\"%s: timeout waiting for PLLE\\n\", __func__);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tudelay(300);\n\t}\n\n\treturn 0;\n}\n\nstatic int clk_plle_enable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tstruct tegra_clk_pll_freq_table sel;\n\tunsigned long input_rate;\n\tu32 val;\n\tint err;\n\n\tif (clk_pll_is_enabled(hw))\n\t\treturn 0;\n\n\tinput_rate = clk_hw_get_rate(clk_hw_get_parent(hw));\n\n\tif (_get_table_rate(hw, &sel, pll->params->fixed_rate, input_rate))\n\t\treturn -EINVAL;\n\n\tclk_pll_disable(hw);\n\n\tval = pll_readl_misc(pll);\n\tval &= ~(PLLE_MISC_LOCK_ENABLE | PLLE_MISC_SETUP_MASK);\n\tpll_writel_misc(val, pll);\n\n\tval = pll_readl_misc(pll);\n\tif (!(val & PLLE_MISC_READY)) {\n\t\terr = clk_plle_training(pll);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (pll->params->flags & TEGRA_PLLE_CONFIGURE) {\n\t\t \n\t\tval = pll_readl_base(pll);\n\t\tval &= ~(divp_mask_shifted(pll) | divn_mask_shifted(pll) |\n\t\t\t divm_mask_shifted(pll));\n\t\tval &= ~(PLLE_BASE_DIVCML_MASK << PLLE_BASE_DIVCML_SHIFT);\n\t\tval |= sel.m << divm_shift(pll);\n\t\tval |= sel.n << divn_shift(pll);\n\t\tval |= sel.p << divp_shift(pll);\n\t\tval |= sel.cpcon << PLLE_BASE_DIVCML_SHIFT;\n\t\tpll_writel_base(val, pll);\n\t}\n\n\tval = pll_readl_misc(pll);\n\tval |= PLLE_MISC_SETUP_VALUE;\n\tval |= PLLE_MISC_LOCK_ENABLE;\n\tpll_writel_misc(val, pll);\n\n\tval = readl(pll->clk_base + PLLE_SS_CTRL);\n\tval &= ~PLLE_SS_COEFFICIENTS_MASK;\n\tval |= PLLE_SS_DISABLE;\n\twritel(val, pll->clk_base + PLLE_SS_CTRL);\n\n\tval = pll_readl_base(pll);\n\tval |= (PLL_BASE_BYPASS | PLL_BASE_ENABLE);\n\tpll_writel_base(val, pll);\n\n\tclk_pll_wait_for_lock(pll);\n\n\treturn 0;\n}\n\nstatic unsigned long clk_plle_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tu32 val = pll_readl_base(pll);\n\tu32 divn = 0, divm = 0, divp = 0;\n\tu64 rate = parent_rate;\n\n\tdivp = (val >> pll->params->div_nmp->divp_shift) & (divp_mask(pll));\n\tdivn = (val >> pll->params->div_nmp->divn_shift) & (divn_mask(pll));\n\tdivm = (val >> pll->params->div_nmp->divm_shift) & (divm_mask(pll));\n\tdivm *= divp;\n\n\trate *= divn;\n\tdo_div(rate, divm);\n\treturn rate;\n}\n\nstatic void tegra_clk_pll_restore_context(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tstruct clk_hw *parent = clk_hw_get_parent(hw);\n\tunsigned long parent_rate = clk_hw_get_rate(parent);\n\tunsigned long rate = clk_hw_get_rate(hw);\n\n\tif (clk_pll_is_enabled(hw))\n\t\treturn;\n\n\tif (pll->params->set_defaults)\n\t\tpll->params->set_defaults(pll);\n\n\tclk_pll_set_rate(hw, rate, parent_rate);\n\n\tif (!__clk_get_enable_count(hw->clk))\n\t\tclk_pll_disable(hw);\n\telse\n\t\tclk_pll_enable(hw);\n}\n\nconst struct clk_ops tegra_clk_pll_ops = {\n\t.is_enabled = clk_pll_is_enabled,\n\t.enable = clk_pll_enable,\n\t.disable = clk_pll_disable,\n\t.recalc_rate = clk_pll_recalc_rate,\n\t.round_rate = clk_pll_round_rate,\n\t.set_rate = clk_pll_set_rate,\n\t.restore_context = tegra_clk_pll_restore_context,\n};\n\nconst struct clk_ops tegra_clk_plle_ops = {\n\t.recalc_rate = clk_plle_recalc_rate,\n\t.is_enabled = clk_pll_is_enabled,\n\t.disable = clk_pll_disable,\n\t.enable = clk_plle_enable,\n};\n\n \nstruct utmi_clk_param {\n\t \n\tu32 osc_frequency;\n\t \n\tu8 enable_delay_count;\n\t \n\tu8 stable_count;\n\t \n\tu8 active_delay_count;\n\t \n\tu8 xtal_freq_count;\n};\n\nstatic const struct utmi_clk_param utmi_parameters[] = {\n\t{\n\t\t.osc_frequency = 13000000, .enable_delay_count = 0x02,\n\t\t.stable_count = 0x33, .active_delay_count = 0x05,\n\t\t.xtal_freq_count = 0x7f\n\t}, {\n\t\t.osc_frequency = 19200000, .enable_delay_count = 0x03,\n\t\t.stable_count = 0x4b, .active_delay_count = 0x06,\n\t\t.xtal_freq_count = 0xbb\n\t}, {\n\t\t.osc_frequency = 12000000, .enable_delay_count = 0x02,\n\t\t.stable_count = 0x2f, .active_delay_count = 0x04,\n\t\t.xtal_freq_count = 0x76\n\t}, {\n\t\t.osc_frequency = 26000000, .enable_delay_count = 0x04,\n\t\t.stable_count = 0x66, .active_delay_count = 0x09,\n\t\t.xtal_freq_count = 0xfe\n\t}, {\n\t\t.osc_frequency = 16800000, .enable_delay_count = 0x03,\n\t\t.stable_count = 0x41, .active_delay_count = 0x0a,\n\t\t.xtal_freq_count = 0xa4\n\t}, {\n\t\t.osc_frequency = 38400000, .enable_delay_count = 0x0,\n\t\t.stable_count = 0x0, .active_delay_count = 0x6,\n\t\t.xtal_freq_count = 0x80\n\t},\n};\n\nstatic int clk_pllu_enable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tstruct clk_hw *pll_ref = clk_hw_get_parent(hw);\n\tstruct clk_hw *osc = clk_hw_get_parent(pll_ref);\n\tconst struct utmi_clk_param *params = NULL;\n\tunsigned long flags = 0, input_rate;\n\tunsigned int i;\n\tint ret = 0;\n\tu32 value;\n\n\tif (!osc) {\n\t\tpr_err(\"%s: failed to get OSC clock\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tinput_rate = clk_hw_get_rate(osc);\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\tif (!clk_pll_is_enabled(hw))\n\t\t_clk_pll_enable(hw);\n\n\tret = clk_pll_wait_for_lock(pll);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(utmi_parameters); i++) {\n\t\tif (input_rate == utmi_parameters[i].osc_frequency) {\n\t\t\tparams = &utmi_parameters[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!params) {\n\t\tpr_err(\"%s: unexpected input rate %lu Hz\\n\", __func__,\n\t\t       input_rate);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tvalue = pll_readl_base(pll);\n\tvalue &= ~PLLU_BASE_OVERRIDE;\n\tpll_writel_base(value, pll);\n\n\tvalue = readl_relaxed(pll->clk_base + UTMIP_PLL_CFG2);\n\t \n\tvalue &= ~UTMIP_PLL_CFG2_STABLE_COUNT(~0);\n\tvalue |= UTMIP_PLL_CFG2_STABLE_COUNT(params->stable_count);\n\tvalue &= ~UTMIP_PLL_CFG2_ACTIVE_DLY_COUNT(~0);\n\tvalue |= UTMIP_PLL_CFG2_ACTIVE_DLY_COUNT(params->active_delay_count);\n\t \n\tvalue &= ~UTMIP_PLL_CFG2_FORCE_PD_SAMP_A_POWERDOWN;\n\tvalue &= ~UTMIP_PLL_CFG2_FORCE_PD_SAMP_B_POWERDOWN;\n\tvalue &= ~UTMIP_PLL_CFG2_FORCE_PD_SAMP_C_POWERDOWN;\n\twritel_relaxed(value, pll->clk_base + UTMIP_PLL_CFG2);\n\n\tvalue = readl_relaxed(pll->clk_base + UTMIP_PLL_CFG1);\n\t \n\tvalue &= ~UTMIP_PLL_CFG1_ENABLE_DLY_COUNT(~0);\n\tvalue |= UTMIP_PLL_CFG1_ENABLE_DLY_COUNT(params->enable_delay_count);\n\tvalue &= ~UTMIP_PLL_CFG1_XTAL_FREQ_COUNT(~0);\n\tvalue |= UTMIP_PLL_CFG1_XTAL_FREQ_COUNT(params->xtal_freq_count);\n\t \n\tvalue &= ~UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERDOWN;\n\tvalue &= ~UTMIP_PLL_CFG1_FORCE_PLL_ACTIVE_POWERDOWN;\n\tvalue &= ~UTMIP_PLL_CFG1_FORCE_PLLU_POWERDOWN;\n\twritel_relaxed(value, pll->clk_base + UTMIP_PLL_CFG1);\n\nout:\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\treturn ret;\n}\n\nstatic const struct clk_ops tegra_clk_pllu_ops = {\n\t.is_enabled = clk_pll_is_enabled,\n\t.enable = clk_pllu_enable,\n\t.disable = clk_pll_disable,\n\t.recalc_rate = clk_pll_recalc_rate,\n\t.round_rate = clk_pll_round_rate,\n\t.set_rate = clk_pll_set_rate,\n};\n\nstatic int _pll_fixed_mdiv(struct tegra_clk_pll_params *pll_params,\n\t\t\t   unsigned long parent_rate)\n{\n\tu16 mdiv = parent_rate / pll_params->cf_min;\n\n\tif (pll_params->flags & TEGRA_MDIV_NEW)\n\t\treturn (!pll_params->mdiv_default ? mdiv :\n\t\t\tmin(mdiv, pll_params->mdiv_default));\n\n\tif (pll_params->mdiv_default)\n\t\treturn pll_params->mdiv_default;\n\n\tif (parent_rate > pll_params->cf_max)\n\t\treturn 2;\n\telse\n\t\treturn 1;\n}\n\nstatic int _calc_dynamic_ramp_rate(struct clk_hw *hw,\n\t\t\t\tstruct tegra_clk_pll_freq_table *cfg,\n\t\t\t\tunsigned long rate, unsigned long parent_rate)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tunsigned int p;\n\tint p_div;\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\tp = DIV_ROUND_UP(pll->params->vco_min, rate);\n\tcfg->m = _pll_fixed_mdiv(pll->params, parent_rate);\n\tcfg->output_rate = rate * p;\n\tcfg->n = cfg->output_rate * cfg->m / parent_rate;\n\tcfg->input_rate = parent_rate;\n\n\tp_div = _p_div_to_hw(hw, p);\n\tif (p_div < 0)\n\t\treturn p_div;\n\n\tcfg->p = p_div;\n\n\tif (cfg->n > divn_max(pll) || cfg->output_rate > pll->params->vco_max)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n#if defined(CONFIG_ARCH_TEGRA_114_SOC) || \\\n\tdefined(CONFIG_ARCH_TEGRA_124_SOC) || \\\n\tdefined(CONFIG_ARCH_TEGRA_132_SOC) || \\\n\tdefined(CONFIG_ARCH_TEGRA_210_SOC)\n\nu16 tegra_pll_get_fixed_mdiv(struct clk_hw *hw, unsigned long input_rate)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\n\treturn (u16)_pll_fixed_mdiv(pll->params, input_rate);\n}\n\nstatic unsigned long _clip_vco_min(unsigned long vco_min,\n\t\t\t\t   unsigned long parent_rate)\n{\n\treturn DIV_ROUND_UP(vco_min, parent_rate) * parent_rate;\n}\n\nstatic int _setup_dynamic_ramp(struct tegra_clk_pll_params *pll_params,\n\t\t\t       void __iomem *clk_base,\n\t\t\t       unsigned long parent_rate)\n{\n\tu32 val;\n\tu32 step_a, step_b;\n\n\tswitch (parent_rate) {\n\tcase 12000000:\n\tcase 13000000:\n\tcase 26000000:\n\t\tstep_a = 0x2B;\n\t\tstep_b = 0x0B;\n\t\tbreak;\n\tcase 16800000:\n\t\tstep_a = 0x1A;\n\t\tstep_b = 0x09;\n\t\tbreak;\n\tcase 19200000:\n\t\tstep_a = 0x12;\n\t\tstep_b = 0x08;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: Unexpected reference rate %lu\\n\",\n\t\t\t__func__, parent_rate);\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tval = step_a << pll_params->stepa_shift;\n\tval |= step_b << pll_params->stepb_shift;\n\twritel_relaxed(val, clk_base + pll_params->dyn_ramp_reg);\n\n\treturn 0;\n}\n\nstatic int _pll_ramp_calc_pll(struct clk_hw *hw,\n\t\t\t      struct tegra_clk_pll_freq_table *cfg,\n\t\t\t      unsigned long rate, unsigned long parent_rate)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tint err = 0;\n\n\terr = _get_table_rate(hw, cfg, rate, parent_rate);\n\tif (err < 0)\n\t\terr = _calc_dynamic_ramp_rate(hw, cfg, rate, parent_rate);\n\telse {\n\t\tif (cfg->m != _pll_fixed_mdiv(pll->params, parent_rate)) {\n\t\t\tWARN_ON(1);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (cfg->p >  pll->params->max_p)\n\t\terr = -EINVAL;\n\nout:\n\treturn err;\n}\n\nstatic int clk_pllxc_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tstruct tegra_clk_pll_freq_table cfg, old_cfg;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tret = _pll_ramp_calc_pll(hw, &cfg, rate, parent_rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\t_get_pll_mnp(pll, &old_cfg);\n\tif (pll->params->flags & TEGRA_PLL_VCO_OUT)\n\t\tcfg.p = old_cfg.p;\n\n\tif (old_cfg.m != cfg.m || old_cfg.n != cfg.n || old_cfg.p != cfg.p)\n\t\tret = _program_pll(hw, &cfg, rate);\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\treturn ret;\n}\n\nstatic long clk_pll_ramp_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *prate)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tstruct tegra_clk_pll_freq_table cfg;\n\tint ret, p_div;\n\tu64 output_rate = *prate;\n\n\tret = _pll_ramp_calc_pll(hw, &cfg, rate, *prate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tp_div = _hw_to_p_div(hw, cfg.p);\n\tif (p_div < 0)\n\t\treturn p_div;\n\n\tif (pll->params->set_gain)\n\t\tpll->params->set_gain(&cfg);\n\n\toutput_rate *= cfg.n;\n\tdo_div(output_rate, cfg.m * p_div);\n\n\treturn output_rate;\n}\n\nstatic void _pllcx_strobe(struct tegra_clk_pll *pll)\n{\n\tu32 val;\n\n\tval = pll_readl_misc(pll);\n\tval |= PLLCX_MISC_STROBE;\n\tpll_writel_misc(val, pll);\n\tudelay(2);\n\n\tval &= ~PLLCX_MISC_STROBE;\n\tpll_writel_misc(val, pll);\n}\n\nstatic int clk_pllc_enable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tu32 val;\n\tint ret;\n\tunsigned long flags = 0;\n\n\tif (clk_pll_is_enabled(hw))\n\t\treturn 0;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\t_clk_pll_enable(hw);\n\tudelay(2);\n\n\tval = pll_readl_misc(pll);\n\tval &= ~PLLCX_MISC_RESET;\n\tpll_writel_misc(val, pll);\n\tudelay(2);\n\n\t_pllcx_strobe(pll);\n\n\tret = clk_pll_wait_for_lock(pll);\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\treturn ret;\n}\n\nstatic void _clk_pllc_disable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tu32 val;\n\n\t_clk_pll_disable(hw);\n\n\tval = pll_readl_misc(pll);\n\tval |= PLLCX_MISC_RESET;\n\tpll_writel_misc(val, pll);\n\tudelay(2);\n}\n\nstatic void clk_pllc_disable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tunsigned long flags = 0;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\t_clk_pllc_disable(hw);\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n}\n\nstatic int _pllcx_update_dynamic_coef(struct tegra_clk_pll *pll,\n\t\t\t\t\tunsigned long input_rate, u32 n)\n{\n\tu32 val, n_threshold;\n\n\tswitch (input_rate) {\n\tcase 12000000:\n\t\tn_threshold = 70;\n\t\tbreak;\n\tcase 13000000:\n\tcase 26000000:\n\t\tn_threshold = 71;\n\t\tbreak;\n\tcase 16800000:\n\t\tn_threshold = 55;\n\t\tbreak;\n\tcase 19200000:\n\t\tn_threshold = 48;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: Unexpected reference rate %lu\\n\",\n\t\t\t__func__, input_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tval = pll_readl_misc(pll);\n\tval &= ~(PLLCX_MISC_SDM_DIV_MASK | PLLCX_MISC_FILT_DIV_MASK);\n\tval |= n <= n_threshold ?\n\t\tPLLCX_MISC_DIV_LOW_RANGE : PLLCX_MISC_DIV_HIGH_RANGE;\n\tpll_writel_misc(val, pll);\n\n\treturn 0;\n}\n\nstatic int clk_pllc_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct tegra_clk_pll_freq_table cfg, old_cfg;\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tunsigned long flags = 0;\n\tint state, ret = 0;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\tret = _pll_ramp_calc_pll(hw, &cfg, rate, parent_rate);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t_get_pll_mnp(pll, &old_cfg);\n\n\tif (cfg.m != old_cfg.m) {\n\t\tWARN_ON(1);\n\t\tgoto out;\n\t}\n\n\tif (old_cfg.n == cfg.n && old_cfg.p == cfg.p)\n\t\tgoto out;\n\n\tstate = clk_pll_is_enabled(hw);\n\tif (state)\n\t\t_clk_pllc_disable(hw);\n\n\tret = _pllcx_update_dynamic_coef(pll, parent_rate, cfg.n);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t_update_pll_mnp(pll, &cfg);\n\n\tif (state)\n\t\tret = clk_pllc_enable(hw);\n\nout:\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\treturn ret;\n}\n\nstatic long _pllre_calc_rate(struct tegra_clk_pll *pll,\n\t\t\t     struct tegra_clk_pll_freq_table *cfg,\n\t\t\t     unsigned long rate, unsigned long parent_rate)\n{\n\tu16 m, n;\n\tu64 output_rate = parent_rate;\n\n\tm = _pll_fixed_mdiv(pll->params, parent_rate);\n\tn = rate * m / parent_rate;\n\n\toutput_rate *= n;\n\tdo_div(output_rate, m);\n\n\tif (cfg) {\n\t\tcfg->m = m;\n\t\tcfg->n = n;\n\t}\n\n\treturn output_rate;\n}\n\nstatic int clk_pllre_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct tegra_clk_pll_freq_table cfg, old_cfg;\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tunsigned long flags = 0;\n\tint state, ret = 0;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\t_pllre_calc_rate(pll, &cfg, rate, parent_rate);\n\t_get_pll_mnp(pll, &old_cfg);\n\tcfg.p = old_cfg.p;\n\n\tif (cfg.m != old_cfg.m || cfg.n != old_cfg.n) {\n\t\tstate = clk_pll_is_enabled(hw);\n\t\tif (state)\n\t\t\t_clk_pll_disable(hw);\n\n\t\t_update_pll_mnp(pll, &cfg);\n\n\t\tif (state) {\n\t\t\t_clk_pll_enable(hw);\n\t\t\tret = clk_pll_wait_for_lock(pll);\n\t\t}\n\t}\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\treturn ret;\n}\n\nstatic unsigned long clk_pllre_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct tegra_clk_pll_freq_table cfg;\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tu64 rate = parent_rate;\n\n\t_get_pll_mnp(pll, &cfg);\n\n\trate *= cfg.n;\n\tdo_div(rate, cfg.m);\n\n\treturn rate;\n}\n\nstatic long clk_pllre_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long *prate)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\n\treturn _pllre_calc_rate(pll, NULL, rate, *prate);\n}\n\nstatic int clk_plle_tegra114_enable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tstruct tegra_clk_pll_freq_table sel;\n\tu32 val;\n\tint ret;\n\tunsigned long flags = 0;\n\tunsigned long input_rate;\n\n\tinput_rate = clk_hw_get_rate(clk_hw_get_parent(hw));\n\n\tif (_get_table_rate(hw, &sel, pll->params->fixed_rate, input_rate))\n\t\treturn -EINVAL;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\tval = pll_readl_base(pll);\n\tval &= ~BIT(29);  \n\tpll_writel_base(val, pll);\n\n\tval = pll_readl(pll->params->aux_reg, pll);\n\tval |= PLLE_AUX_ENABLE_SWCTL;\n\tval &= ~PLLE_AUX_SEQ_ENABLE;\n\tpll_writel(val, pll->params->aux_reg, pll);\n\tudelay(1);\n\n\tval = pll_readl_misc(pll);\n\tval |= PLLE_MISC_LOCK_ENABLE;\n\tval |= PLLE_MISC_IDDQ_SW_CTRL;\n\tval &= ~PLLE_MISC_IDDQ_SW_VALUE;\n\tval |= PLLE_MISC_PLLE_PTS;\n\tval &= ~(PLLE_MISC_VREG_BG_CTRL_MASK | PLLE_MISC_VREG_CTRL_MASK);\n\tpll_writel_misc(val, pll);\n\tudelay(5);\n\n\tval = pll_readl(PLLE_SS_CTRL, pll);\n\tval |= PLLE_SS_DISABLE;\n\tpll_writel(val, PLLE_SS_CTRL, pll);\n\n\tval = pll_readl_base(pll);\n\tval &= ~(divp_mask_shifted(pll) | divn_mask_shifted(pll) |\n\t\t divm_mask_shifted(pll));\n\tval &= ~(PLLE_BASE_DIVCML_MASK << PLLE_BASE_DIVCML_SHIFT);\n\tval |= sel.m << divm_shift(pll);\n\tval |= sel.n << divn_shift(pll);\n\tval |= sel.cpcon << PLLE_BASE_DIVCML_SHIFT;\n\tpll_writel_base(val, pll);\n\tudelay(1);\n\n\t_clk_pll_enable(hw);\n\tret = clk_pll_wait_for_lock(pll);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tval = pll_readl(PLLE_SS_CTRL, pll);\n\tval &= ~(PLLE_SS_CNTL_CENTER | PLLE_SS_CNTL_INVERT);\n\tval &= ~PLLE_SS_COEFFICIENTS_MASK;\n\tval |= PLLE_SS_COEFFICIENTS_VAL_TEGRA114;\n\tpll_writel(val, PLLE_SS_CTRL, pll);\n\tval &= ~(PLLE_SS_CNTL_SSC_BYP | PLLE_SS_CNTL_BYPASS_SS);\n\tpll_writel(val, PLLE_SS_CTRL, pll);\n\tudelay(1);\n\tval &= ~PLLE_SS_CNTL_INTERP_RESET;\n\tpll_writel(val, PLLE_SS_CTRL, pll);\n\tudelay(1);\n\n\t \n\tval = pll_readl_misc(pll);\n\tval &= ~PLLE_MISC_IDDQ_SW_CTRL;\n\tpll_writel_misc(val, pll);\n\n\tval = pll_readl(pll->params->aux_reg, pll);\n\tval |= (PLLE_AUX_USE_LOCKDET | PLLE_AUX_SEQ_START_STATE);\n\tval &= ~(PLLE_AUX_ENABLE_SWCTL | PLLE_AUX_SS_SWCTL);\n\tpll_writel(val, pll->params->aux_reg, pll);\n\tudelay(1);\n\tval |= PLLE_AUX_SEQ_ENABLE;\n\tpll_writel(val, pll->params->aux_reg, pll);\n\n\tval = pll_readl(XUSBIO_PLL_CFG0, pll);\n\tval |= (XUSBIO_PLL_CFG0_PADPLL_USE_LOCKDET |\n\t\tXUSBIO_PLL_CFG0_SEQ_START_STATE);\n\tval &= ~(XUSBIO_PLL_CFG0_CLK_ENABLE_SWCTL |\n\t\t XUSBIO_PLL_CFG0_PADPLL_RESET_SWCTL);\n\tpll_writel(val, XUSBIO_PLL_CFG0, pll);\n\tudelay(1);\n\tval |= XUSBIO_PLL_CFG0_SEQ_ENABLE;\n\tpll_writel(val, XUSBIO_PLL_CFG0, pll);\n\n\t \n\tval = pll_readl(SATA_PLL_CFG0, pll);\n\tval &= ~SATA_PLL_CFG0_PADPLL_RESET_SWCTL;\n\tval |= SATA_PLL_CFG0_PADPLL_USE_LOCKDET;\n\tval |= SATA_PLL_CFG0_SEQ_START_STATE;\n\tpll_writel(val, SATA_PLL_CFG0, pll);\n\n\tudelay(1);\n\n\tval = pll_readl(SATA_PLL_CFG0, pll);\n\tval |= SATA_PLL_CFG0_SEQ_ENABLE;\n\tpll_writel(val, SATA_PLL_CFG0, pll);\n\nout:\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\treturn ret;\n}\n\nstatic void clk_plle_tegra114_disable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tunsigned long flags = 0;\n\tu32 val;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\t_clk_pll_disable(hw);\n\n\tval = pll_readl_misc(pll);\n\tval |= PLLE_MISC_IDDQ_SW_CTRL | PLLE_MISC_IDDQ_SW_VALUE;\n\tpll_writel_misc(val, pll);\n\tudelay(1);\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n}\n\nstatic int clk_pllu_tegra114_enable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tconst struct utmi_clk_param *params = NULL;\n\tstruct clk *osc = __clk_lookup(\"osc\");\n\tunsigned long flags = 0, input_rate;\n\tunsigned int i;\n\tint ret = 0;\n\tu32 value;\n\n\tif (!osc) {\n\t\tpr_err(\"%s: failed to get OSC clock\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tinput_rate = clk_hw_get_rate(__clk_get_hw(osc));\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\tif (!clk_pll_is_enabled(hw))\n\t\t_clk_pll_enable(hw);\n\n\tret = clk_pll_wait_for_lock(pll);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(utmi_parameters); i++) {\n\t\tif (input_rate == utmi_parameters[i].osc_frequency) {\n\t\t\tparams = &utmi_parameters[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!params) {\n\t\tpr_err(\"%s: unexpected input rate %lu Hz\\n\", __func__,\n\t\t       input_rate);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tvalue = pll_readl_base(pll);\n\tvalue &= ~PLLU_BASE_OVERRIDE;\n\tpll_writel_base(value, pll);\n\n\tvalue = readl_relaxed(pll->clk_base + UTMIP_PLL_CFG2);\n\t \n\tvalue &= ~UTMIP_PLL_CFG2_STABLE_COUNT(~0);\n\tvalue |= UTMIP_PLL_CFG2_STABLE_COUNT(params->stable_count);\n\tvalue &= ~UTMIP_PLL_CFG2_ACTIVE_DLY_COUNT(~0);\n\tvalue |= UTMIP_PLL_CFG2_ACTIVE_DLY_COUNT(params->active_delay_count);\n\t \n\tvalue &= ~UTMIP_PLL_CFG2_FORCE_PD_SAMP_A_POWERDOWN;\n\tvalue &= ~UTMIP_PLL_CFG2_FORCE_PD_SAMP_B_POWERDOWN;\n\tvalue &= ~UTMIP_PLL_CFG2_FORCE_PD_SAMP_C_POWERDOWN;\n\twritel_relaxed(value, pll->clk_base + UTMIP_PLL_CFG2);\n\n\tvalue = readl_relaxed(pll->clk_base + UTMIP_PLL_CFG1);\n\t \n\tvalue &= ~UTMIP_PLL_CFG1_ENABLE_DLY_COUNT(~0);\n\tvalue |= UTMIP_PLL_CFG1_ENABLE_DLY_COUNT(params->enable_delay_count);\n\tvalue &= ~UTMIP_PLL_CFG1_XTAL_FREQ_COUNT(~0);\n\tvalue |= UTMIP_PLL_CFG1_XTAL_FREQ_COUNT(params->xtal_freq_count);\n\t \n\tvalue &= ~UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERDOWN;\n\tvalue &= ~UTMIP_PLL_CFG1_FORCE_PLL_ACTIVE_POWERDOWN;\n\tvalue &= ~UTMIP_PLL_CFG1_FORCE_PLLU_POWERUP;\n\tvalue &= ~UTMIP_PLL_CFG1_FORCE_PLLU_POWERDOWN;\n\twritel_relaxed(value, pll->clk_base + UTMIP_PLL_CFG1);\n\n\t \n\tvalue = readl_relaxed(pll->clk_base + UTMIPLL_HW_PWRDN_CFG0);\n\tvalue |= UTMIPLL_HW_PWRDN_CFG0_USE_LOCKDET;\n\tvalue &= ~UTMIPLL_HW_PWRDN_CFG0_CLK_ENABLE_SWCTL;\n\tvalue |= UTMIPLL_HW_PWRDN_CFG0_SEQ_START_STATE;\n\twritel_relaxed(value, pll->clk_base + UTMIPLL_HW_PWRDN_CFG0);\n\n\tvalue = readl_relaxed(pll->clk_base + UTMIP_PLL_CFG1);\n\tvalue &= ~UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERUP;\n\tvalue &= ~UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERDOWN;\n\twritel_relaxed(value, pll->clk_base + UTMIP_PLL_CFG1);\n\n\tudelay(1);\n\n\t \n\tvalue = readl_relaxed(pll->clk_base + UTMIPLL_HW_PWRDN_CFG0);\n\tvalue |= UTMIPLL_HW_PWRDN_CFG0_IDDQ_SWCTL;\n\tvalue &= ~UTMIPLL_HW_PWRDN_CFG0_IDDQ_OVERRIDE;\n\twritel_relaxed(value, pll->clk_base + UTMIPLL_HW_PWRDN_CFG0);\n\n\tudelay(1);\n\n\t \n\tvalue = readl_relaxed(pll->clk_base + UTMIPLL_HW_PWRDN_CFG0);\n\tvalue |= UTMIPLL_HW_PWRDN_CFG0_SEQ_ENABLE;\n\twritel_relaxed(value, pll->clk_base + UTMIPLL_HW_PWRDN_CFG0);\n\nout:\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\treturn ret;\n}\n\nstatic void _clk_plle_tegra_init_parent(struct tegra_clk_pll *pll)\n{\n\tu32 val, val_aux;\n\n\t \n\tval = pll_readl_base(pll);\n\tval_aux = pll_readl(pll->params->aux_reg, pll);\n\n\tif (val & PLL_BASE_ENABLE) {\n\t\tif ((val_aux & PLLE_AUX_PLLRE_SEL) ||\n\t\t    (val_aux & PLLE_AUX_PLLP_SEL))\n\t\t\tWARN(1, \"pll_e enabled with unsupported parent %s\\n\",\n\t\t\t     (val_aux & PLLE_AUX_PLLP_SEL) ? \"pllp_out0\" :\n\t\t\t     \"pll_re_vco\");\n\t} else {\n\t\tval_aux &= ~(PLLE_AUX_PLLRE_SEL | PLLE_AUX_PLLP_SEL);\n\t\tpll_writel(val_aux, pll->params->aux_reg, pll);\n\t\tfence_udelay(1, pll->clk_base);\n\t}\n}\n#endif\n\nstatic struct tegra_clk_pll *_tegra_init_pll(void __iomem *clk_base,\n\t\tvoid __iomem *pmc, struct tegra_clk_pll_params *pll_params,\n\t\tspinlock_t *lock)\n{\n\tstruct tegra_clk_pll *pll;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpll->clk_base = clk_base;\n\tpll->pmc = pmc;\n\n\tpll->params = pll_params;\n\tpll->lock = lock;\n\n\tif (!pll_params->div_nmp)\n\t\tpll_params->div_nmp = &default_nmp;\n\n\treturn pll;\n}\n\nstatic struct clk *_tegra_clk_register_pll(struct tegra_clk_pll *pll,\n\t\tconst char *name, const char *parent_name, unsigned long flags,\n\t\tconst struct clk_ops *ops)\n{\n\tstruct clk_init_data init;\n\n\tinit.name = name;\n\tinit.ops = ops;\n\tinit.flags = flags;\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\n\t \n\tif (!pll->params->calc_rate) {\n\t\tif (pll->params->flags & TEGRA_PLLM)\n\t\t\tpll->params->calc_rate = _calc_dynamic_ramp_rate;\n\t\telse\n\t\t\tpll->params->calc_rate = _calc_rate;\n\t}\n\n\tif (pll->params->set_defaults)\n\t\tpll->params->set_defaults(pll);\n\n\t \n\tpll->hw.init = &init;\n\n\treturn tegra_clk_dev_register(&pll->hw);\n}\n\nstruct clk *tegra_clk_register_pll(const char *name, const char *parent_name,\n\t\tvoid __iomem *clk_base, void __iomem *pmc,\n\t\tunsigned long flags, struct tegra_clk_pll_params *pll_params,\n\t\tspinlock_t *lock)\n{\n\tstruct tegra_clk_pll *pll;\n\tstruct clk *clk;\n\n\tpll_params->flags |= TEGRA_PLL_BYPASS;\n\n\tpll = _tegra_init_pll(clk_base, pmc, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t      &tegra_clk_pll_ops);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\nstatic struct div_nmp pll_e_nmp = {\n\t.divn_shift = PLLE_BASE_DIVN_SHIFT,\n\t.divn_width = PLLE_BASE_DIVN_WIDTH,\n\t.divm_shift = PLLE_BASE_DIVM_SHIFT,\n\t.divm_width = PLLE_BASE_DIVM_WIDTH,\n\t.divp_shift = PLLE_BASE_DIVP_SHIFT,\n\t.divp_width = PLLE_BASE_DIVP_WIDTH,\n};\n\nstruct clk *tegra_clk_register_plle(const char *name, const char *parent_name,\n\t\tvoid __iomem *clk_base, void __iomem *pmc,\n\t\tunsigned long flags, struct tegra_clk_pll_params *pll_params,\n\t\tspinlock_t *lock)\n{\n\tstruct tegra_clk_pll *pll;\n\tstruct clk *clk;\n\n\tpll_params->flags |= TEGRA_PLL_BYPASS;\n\n\tif (!pll_params->div_nmp)\n\t\tpll_params->div_nmp = &pll_e_nmp;\n\n\tpll = _tegra_init_pll(clk_base, pmc, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t      &tegra_clk_plle_ops);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\nstruct clk *tegra_clk_register_pllu(const char *name, const char *parent_name,\n\t\tvoid __iomem *clk_base, unsigned long flags,\n\t\tstruct tegra_clk_pll_params *pll_params, spinlock_t *lock)\n{\n\tstruct tegra_clk_pll *pll;\n\tstruct clk *clk;\n\n\tpll_params->flags |= TEGRA_PLLU;\n\n\tpll = _tegra_init_pll(clk_base, NULL, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t      &tegra_clk_pllu_ops);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\n#if defined(CONFIG_ARCH_TEGRA_114_SOC) || \\\n\tdefined(CONFIG_ARCH_TEGRA_124_SOC) || \\\n\tdefined(CONFIG_ARCH_TEGRA_132_SOC) || \\\n\tdefined(CONFIG_ARCH_TEGRA_210_SOC)\nstatic const struct clk_ops tegra_clk_pllxc_ops = {\n\t.is_enabled = clk_pll_is_enabled,\n\t.enable = clk_pll_enable,\n\t.disable = clk_pll_disable,\n\t.recalc_rate = clk_pll_recalc_rate,\n\t.round_rate = clk_pll_ramp_round_rate,\n\t.set_rate = clk_pllxc_set_rate,\n};\n\nstatic const struct clk_ops tegra_clk_pllc_ops = {\n\t.is_enabled = clk_pll_is_enabled,\n\t.enable = clk_pllc_enable,\n\t.disable = clk_pllc_disable,\n\t.recalc_rate = clk_pll_recalc_rate,\n\t.round_rate = clk_pll_ramp_round_rate,\n\t.set_rate = clk_pllc_set_rate,\n};\n\nstatic const struct clk_ops tegra_clk_pllre_ops = {\n\t.is_enabled = clk_pll_is_enabled,\n\t.enable = clk_pll_enable,\n\t.disable = clk_pll_disable,\n\t.recalc_rate = clk_pllre_recalc_rate,\n\t.round_rate = clk_pllre_round_rate,\n\t.set_rate = clk_pllre_set_rate,\n};\n\nstatic const struct clk_ops tegra_clk_plle_tegra114_ops = {\n\t.is_enabled =  clk_pll_is_enabled,\n\t.enable = clk_plle_tegra114_enable,\n\t.disable = clk_plle_tegra114_disable,\n\t.recalc_rate = clk_pll_recalc_rate,\n};\n\nstatic const struct clk_ops tegra_clk_pllu_tegra114_ops = {\n\t.is_enabled =  clk_pll_is_enabled,\n\t.enable = clk_pllu_tegra114_enable,\n\t.disable = clk_pll_disable,\n\t.recalc_rate = clk_pll_recalc_rate,\n};\n\nstruct clk *tegra_clk_register_pllxc(const char *name, const char *parent_name,\n\t\t\t  void __iomem *clk_base, void __iomem *pmc,\n\t\t\t  unsigned long flags,\n\t\t\t  struct tegra_clk_pll_params *pll_params,\n\t\t\t  spinlock_t *lock)\n{\n\tstruct tegra_clk_pll *pll;\n\tstruct clk *clk, *parent;\n\tunsigned long parent_rate;\n\tu32 val, val_iddq;\n\n\tparent = __clk_lookup(parent_name);\n\tif (!parent) {\n\t\tWARN(1, \"parent clk %s of %s must be registered first\\n\",\n\t\t\tparent_name, name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!pll_params->pdiv_tohw)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tparent_rate = clk_get_rate(parent);\n\n\tpll_params->vco_min = _clip_vco_min(pll_params->vco_min, parent_rate);\n\n\tif (pll_params->adjust_vco)\n\t\tpll_params->vco_min = pll_params->adjust_vco(pll_params,\n\t\t\t\t\t\t\t     parent_rate);\n\n\t \n\tif (!pll_params->set_defaults) {\n\t\tint err;\n\n\t\terr = _setup_dynamic_ramp(pll_params, clk_base, parent_rate);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\tval = readl_relaxed(clk_base + pll_params->base_reg);\n\t\tval_iddq = readl_relaxed(clk_base + pll_params->iddq_reg);\n\n\t\tif (val & PLL_BASE_ENABLE)\n\t\t\tWARN_ON(val_iddq & BIT(pll_params->iddq_bit_idx));\n\t\telse {\n\t\t\tval_iddq |= BIT(pll_params->iddq_bit_idx);\n\t\t\twritel_relaxed(val_iddq,\n\t\t\t\t       clk_base + pll_params->iddq_reg);\n\t\t}\n\t}\n\n\tpll = _tegra_init_pll(clk_base, pmc, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t      &tegra_clk_pllxc_ops);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\nstruct clk *tegra_clk_register_pllre(const char *name, const char *parent_name,\n\t\t\t  void __iomem *clk_base, void __iomem *pmc,\n\t\t\t  unsigned long flags,\n\t\t\t  struct tegra_clk_pll_params *pll_params,\n\t\t\t  spinlock_t *lock, unsigned long parent_rate)\n{\n\tu32 val;\n\tstruct tegra_clk_pll *pll;\n\tstruct clk *clk;\n\n\tpll_params->vco_min = _clip_vco_min(pll_params->vco_min, parent_rate);\n\n\tif (pll_params->adjust_vco)\n\t\tpll_params->vco_min = pll_params->adjust_vco(pll_params,\n\t\t\t\t\t\t\t     parent_rate);\n\n\tpll = _tegra_init_pll(clk_base, pmc, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\t \n\n\tval = pll_readl_base(pll);\n\tif (val & PLL_BASE_ENABLE)\n\t\tWARN_ON(readl_relaxed(clk_base + pll_params->iddq_reg) &\n\t\t\t\tBIT(pll_params->iddq_bit_idx));\n\telse {\n\t\tint m;\n\n\t\tm = _pll_fixed_mdiv(pll_params, parent_rate);\n\t\tval = m << divm_shift(pll);\n\t\tval |= (pll_params->vco_min / parent_rate) << divn_shift(pll);\n\t\tpll_writel_base(val, pll);\n\t}\n\n\t \n\n\tval = pll_readl_misc(pll);\n\tval &= ~BIT(29);\n\tpll_writel_misc(val, pll);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t      &tegra_clk_pllre_ops);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\nstruct clk *tegra_clk_register_pllm(const char *name, const char *parent_name,\n\t\t\t  void __iomem *clk_base, void __iomem *pmc,\n\t\t\t  unsigned long flags,\n\t\t\t  struct tegra_clk_pll_params *pll_params,\n\t\t\t  spinlock_t *lock)\n{\n\tstruct tegra_clk_pll *pll;\n\tstruct clk *clk, *parent;\n\tunsigned long parent_rate;\n\n\tif (!pll_params->pdiv_tohw)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tparent = __clk_lookup(parent_name);\n\tif (!parent) {\n\t\tWARN(1, \"parent clk %s of %s must be registered first\\n\",\n\t\t\tparent_name, name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tparent_rate = clk_get_rate(parent);\n\n\tpll_params->vco_min = _clip_vco_min(pll_params->vco_min, parent_rate);\n\n\tif (pll_params->adjust_vco)\n\t\tpll_params->vco_min = pll_params->adjust_vco(pll_params,\n\t\t\t\t\t\t\t     parent_rate);\n\n\tpll_params->flags |= TEGRA_PLL_BYPASS;\n\tpll_params->flags |= TEGRA_PLLM;\n\tpll = _tegra_init_pll(clk_base, pmc, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t      &tegra_clk_pll_ops);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\nstruct clk *tegra_clk_register_pllc(const char *name, const char *parent_name,\n\t\t\t  void __iomem *clk_base, void __iomem *pmc,\n\t\t\t  unsigned long flags,\n\t\t\t  struct tegra_clk_pll_params *pll_params,\n\t\t\t  spinlock_t *lock)\n{\n\tstruct clk *parent, *clk;\n\tconst struct pdiv_map *p_tohw = pll_params->pdiv_tohw;\n\tstruct tegra_clk_pll *pll;\n\tstruct tegra_clk_pll_freq_table cfg;\n\tunsigned long parent_rate;\n\n\tif (!p_tohw)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tparent = __clk_lookup(parent_name);\n\tif (!parent) {\n\t\tWARN(1, \"parent clk %s of %s must be registered first\\n\",\n\t\t\tparent_name, name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tparent_rate = clk_get_rate(parent);\n\n\tpll_params->vco_min = _clip_vco_min(pll_params->vco_min, parent_rate);\n\n\tpll_params->flags |= TEGRA_PLL_BYPASS;\n\tpll = _tegra_init_pll(clk_base, pmc, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\t \n\n\tcfg.m = _pll_fixed_mdiv(pll_params, parent_rate);\n\tcfg.n = cfg.m * pll_params->vco_min / parent_rate;\n\n\twhile (p_tohw->pdiv) {\n\t\tif (p_tohw->pdiv == 2) {\n\t\t\tcfg.p = p_tohw->hw_val;\n\t\t\tbreak;\n\t\t}\n\t\tp_tohw++;\n\t}\n\n\tif (!p_tohw->pdiv) {\n\t\tWARN_ON(1);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpll_writel_base(0, pll);\n\t_update_pll_mnp(pll, &cfg);\n\n\tpll_writel_misc(PLLCX_MISC_DEFAULT, pll);\n\tpll_writel(PLLCX_MISC1_DEFAULT, pll_params->ext_misc_reg[0], pll);\n\tpll_writel(PLLCX_MISC2_DEFAULT, pll_params->ext_misc_reg[1], pll);\n\tpll_writel(PLLCX_MISC3_DEFAULT, pll_params->ext_misc_reg[2], pll);\n\n\t_pllcx_update_dynamic_coef(pll, parent_rate, cfg.n);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t      &tegra_clk_pllc_ops);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\nstruct clk *tegra_clk_register_plle_tegra114(const char *name,\n\t\t\t\tconst char *parent_name,\n\t\t\t\tvoid __iomem *clk_base, unsigned long flags,\n\t\t\t\tstruct tegra_clk_pll_params *pll_params,\n\t\t\t\tspinlock_t *lock)\n{\n\tstruct tegra_clk_pll *pll;\n\tstruct clk *clk;\n\n\tpll = _tegra_init_pll(clk_base, NULL, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\t_clk_plle_tegra_init_parent(pll);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t      &tegra_clk_plle_tegra114_ops);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\nstruct clk *\ntegra_clk_register_pllu_tegra114(const char *name, const char *parent_name,\n\t\t\t\t void __iomem *clk_base, unsigned long flags,\n\t\t\t\t struct tegra_clk_pll_params *pll_params,\n\t\t\t\t spinlock_t *lock)\n{\n\tstruct tegra_clk_pll *pll;\n\tstruct clk *clk;\n\n\tpll_params->flags |= TEGRA_PLLU;\n\n\tpll = _tegra_init_pll(clk_base, NULL, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t      &tegra_clk_pllu_tegra114_ops);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n#endif\n\n#if defined(CONFIG_ARCH_TEGRA_124_SOC) || defined(CONFIG_ARCH_TEGRA_132_SOC) || defined(CONFIG_ARCH_TEGRA_210_SOC)\nstatic const struct clk_ops tegra_clk_pllss_ops = {\n\t.is_enabled = clk_pll_is_enabled,\n\t.enable = clk_pll_enable,\n\t.disable = clk_pll_disable,\n\t.recalc_rate = clk_pll_recalc_rate,\n\t.round_rate = clk_pll_ramp_round_rate,\n\t.set_rate = clk_pllxc_set_rate,\n\t.restore_context = tegra_clk_pll_restore_context,\n};\n\nstruct clk *tegra_clk_register_pllss(const char *name, const char *parent_name,\n\t\t\t\tvoid __iomem *clk_base, unsigned long flags,\n\t\t\t\tstruct tegra_clk_pll_params *pll_params,\n\t\t\t\tspinlock_t *lock)\n{\n\tstruct tegra_clk_pll *pll;\n\tstruct clk *clk, *parent;\n\tstruct tegra_clk_pll_freq_table cfg;\n\tunsigned long parent_rate;\n\tu32 val, val_iddq;\n\tint i;\n\n\tif (!pll_params->div_nmp)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tparent = __clk_lookup(parent_name);\n\tif (!parent) {\n\t\tWARN(1, \"parent clk %s of %s must be registered first\\n\",\n\t\t\tparent_name, name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpll = _tegra_init_pll(clk_base, NULL, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\tval = pll_readl_base(pll);\n\tval &= ~PLLSS_REF_SRC_SEL_MASK;\n\tpll_writel_base(val, pll);\n\n\tparent_rate = clk_get_rate(parent);\n\n\tpll_params->vco_min = _clip_vco_min(pll_params->vco_min, parent_rate);\n\n\t \n\n\tcfg.m = _pll_fixed_mdiv(pll_params, parent_rate);\n\tcfg.n = cfg.m * pll_params->vco_min / parent_rate;\n\n\tfor (i = 0; pll_params->pdiv_tohw[i].pdiv; i++)\n\t\t;\n\tif (!i) {\n\t\tkfree(pll);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tcfg.p = pll_params->pdiv_tohw[i-1].hw_val;\n\n\t_update_pll_mnp(pll, &cfg);\n\n\tpll_writel_misc(PLLSS_MISC_DEFAULT, pll);\n\tpll_writel(PLLSS_CFG_DEFAULT, pll_params->ext_misc_reg[0], pll);\n\tpll_writel(PLLSS_CTRL1_DEFAULT, pll_params->ext_misc_reg[1], pll);\n\tpll_writel(PLLSS_CTRL1_DEFAULT, pll_params->ext_misc_reg[2], pll);\n\n\tval = pll_readl_base(pll);\n\tval_iddq = readl_relaxed(clk_base + pll_params->iddq_reg);\n\tif (val & PLL_BASE_ENABLE) {\n\t\tif (val_iddq & BIT(pll_params->iddq_bit_idx)) {\n\t\t\tWARN(1, \"%s is on but IDDQ set\\n\", name);\n\t\t\tkfree(pll);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else {\n\t\tval_iddq |= BIT(pll_params->iddq_bit_idx);\n\t\twritel_relaxed(val_iddq, clk_base + pll_params->iddq_reg);\n\t}\n\n\tval &= ~PLLSS_LOCK_OVERRIDE;\n\tpll_writel_base(val, pll);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t\t&tegra_clk_pllss_ops);\n\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n#endif\n\n#if defined(CONFIG_ARCH_TEGRA_210_SOC)\nstruct clk *tegra_clk_register_pllre_tegra210(const char *name,\n\t\t\t  const char *parent_name, void __iomem *clk_base,\n\t\t\t  void __iomem *pmc, unsigned long flags,\n\t\t\t  struct tegra_clk_pll_params *pll_params,\n\t\t\t  spinlock_t *lock, unsigned long parent_rate)\n{\n\tstruct tegra_clk_pll *pll;\n\tstruct clk *clk;\n\n\tpll_params->vco_min = _clip_vco_min(pll_params->vco_min, parent_rate);\n\n\tif (pll_params->adjust_vco)\n\t\tpll_params->vco_min = pll_params->adjust_vco(pll_params,\n\t\t\t\t\t\t\t     parent_rate);\n\n\tpll = _tegra_init_pll(clk_base, pmc, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t      &tegra_clk_pll_ops);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\nstatic int clk_plle_tegra210_is_enabled(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tu32 val;\n\n\tval = pll_readl_base(pll);\n\n\treturn val & PLLE_BASE_ENABLE ? 1 : 0;\n}\n\nstatic int clk_plle_tegra210_enable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tstruct tegra_clk_pll_freq_table sel;\n\tu32 val;\n\tint ret = 0;\n\tunsigned long flags = 0;\n\tunsigned long input_rate;\n\n\tif (clk_plle_tegra210_is_enabled(hw))\n\t\treturn 0;\n\n\tinput_rate = clk_hw_get_rate(clk_hw_get_parent(hw));\n\n\tif (_get_table_rate(hw, &sel, pll->params->fixed_rate, input_rate))\n\t\treturn -EINVAL;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\tval = pll_readl(pll->params->aux_reg, pll);\n\tif (val & PLLE_AUX_SEQ_ENABLE)\n\t\tgoto out;\n\n\tval = pll_readl_base(pll);\n\tval &= ~BIT(30);  \n\tpll_writel_base(val, pll);\n\n\tval = pll_readl_misc(pll);\n\tval |= PLLE_MISC_LOCK_ENABLE;\n\tval |= PLLE_MISC_IDDQ_SW_CTRL;\n\tval &= ~PLLE_MISC_IDDQ_SW_VALUE;\n\tval |= PLLE_MISC_PLLE_PTS;\n\tval &= ~(PLLE_MISC_VREG_BG_CTRL_MASK | PLLE_MISC_VREG_CTRL_MASK);\n\tpll_writel_misc(val, pll);\n\tudelay(5);\n\n\tval = pll_readl(PLLE_SS_CTRL, pll);\n\tval |= PLLE_SS_DISABLE;\n\tpll_writel(val, PLLE_SS_CTRL, pll);\n\n\tval = pll_readl_base(pll);\n\tval &= ~(divp_mask_shifted(pll) | divn_mask_shifted(pll) |\n\t\t divm_mask_shifted(pll));\n\tval &= ~(PLLE_BASE_DIVCML_MASK << PLLE_BASE_DIVCML_SHIFT);\n\tval |= sel.m << divm_shift(pll);\n\tval |= sel.n << divn_shift(pll);\n\tval |= sel.cpcon << PLLE_BASE_DIVCML_SHIFT;\n\tpll_writel_base(val, pll);\n\tudelay(1);\n\n\tval = pll_readl_base(pll);\n\tval |= PLLE_BASE_ENABLE;\n\tpll_writel_base(val, pll);\n\n\tret = clk_pll_wait_for_lock(pll);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tval = pll_readl(PLLE_SS_CTRL, pll);\n\tval &= ~(PLLE_SS_CNTL_CENTER | PLLE_SS_CNTL_INVERT);\n\tval &= ~PLLE_SS_COEFFICIENTS_MASK;\n\tval |= PLLE_SS_COEFFICIENTS_VAL_TEGRA210;\n\tpll_writel(val, PLLE_SS_CTRL, pll);\n\tval &= ~(PLLE_SS_CNTL_SSC_BYP | PLLE_SS_CNTL_BYPASS_SS);\n\tpll_writel(val, PLLE_SS_CTRL, pll);\n\tudelay(1);\n\tval &= ~PLLE_SS_CNTL_INTERP_RESET;\n\tpll_writel(val, PLLE_SS_CTRL, pll);\n\tudelay(1);\n\nout:\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\treturn ret;\n}\n\nstatic void clk_plle_tegra210_disable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\tunsigned long flags = 0;\n\tu32 val;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\t \n\tval = pll_readl(pll->params->aux_reg, pll);\n\tif (val & PLLE_AUX_SEQ_ENABLE)\n\t\tgoto out;\n\n\tval = pll_readl_base(pll);\n\tval &= ~PLLE_BASE_ENABLE;\n\tpll_writel_base(val, pll);\n\n\tval = pll_readl(pll->params->aux_reg, pll);\n\tval |= PLLE_AUX_ENABLE_SWCTL | PLLE_AUX_SS_SWCTL;\n\tpll_writel(val, pll->params->aux_reg, pll);\n\n\tval = pll_readl_misc(pll);\n\tval |= PLLE_MISC_IDDQ_SW_CTRL | PLLE_MISC_IDDQ_SW_VALUE;\n\tpll_writel_misc(val, pll);\n\tudelay(1);\n\nout:\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n}\n\nstatic void tegra_clk_plle_t210_restore_context(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll *pll = to_clk_pll(hw);\n\n\t_clk_plle_tegra_init_parent(pll);\n}\n\nstatic const struct clk_ops tegra_clk_plle_tegra210_ops = {\n\t.is_enabled =  clk_plle_tegra210_is_enabled,\n\t.enable = clk_plle_tegra210_enable,\n\t.disable = clk_plle_tegra210_disable,\n\t.recalc_rate = clk_pll_recalc_rate,\n\t.restore_context = tegra_clk_plle_t210_restore_context,\n};\n\nstruct clk *tegra_clk_register_plle_tegra210(const char *name,\n\t\t\t\tconst char *parent_name,\n\t\t\t\tvoid __iomem *clk_base, unsigned long flags,\n\t\t\t\tstruct tegra_clk_pll_params *pll_params,\n\t\t\t\tspinlock_t *lock)\n{\n\tstruct tegra_clk_pll *pll;\n\tstruct clk *clk;\n\n\tpll = _tegra_init_pll(clk_base, NULL, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\t_clk_plle_tegra_init_parent(pll);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t      &tegra_clk_plle_tegra210_ops);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\nstruct clk *tegra_clk_register_pllc_tegra210(const char *name,\n\t\t\tconst char *parent_name, void __iomem *clk_base,\n\t\t\tvoid __iomem *pmc, unsigned long flags,\n\t\t\tstruct tegra_clk_pll_params *pll_params,\n\t\t\tspinlock_t *lock)\n{\n\tstruct clk *parent, *clk;\n\tconst struct pdiv_map *p_tohw = pll_params->pdiv_tohw;\n\tstruct tegra_clk_pll *pll;\n\tunsigned long parent_rate;\n\n\tif (!p_tohw)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tparent = __clk_lookup(parent_name);\n\tif (!parent) {\n\t\tWARN(1, \"parent clk %s of %s must be registered first\\n\",\n\t\t\tname, parent_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tparent_rate = clk_get_rate(parent);\n\n\tpll_params->vco_min = _clip_vco_min(pll_params->vco_min, parent_rate);\n\n\tif (pll_params->adjust_vco)\n\t\tpll_params->vco_min = pll_params->adjust_vco(pll_params,\n\t\t\t\t\t\t\t     parent_rate);\n\n\tpll_params->flags |= TEGRA_PLL_BYPASS;\n\tpll = _tegra_init_pll(clk_base, pmc, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t      &tegra_clk_pll_ops);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\nstruct clk *tegra_clk_register_pllss_tegra210(const char *name,\n\t\t\t\tconst char *parent_name, void __iomem *clk_base,\n\t\t\t\tunsigned long flags,\n\t\t\t\tstruct tegra_clk_pll_params *pll_params,\n\t\t\t\tspinlock_t *lock)\n{\n\tstruct tegra_clk_pll *pll;\n\tstruct clk *clk, *parent;\n\tunsigned long parent_rate;\n\tu32 val;\n\n\tif (!pll_params->div_nmp)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tparent = __clk_lookup(parent_name);\n\tif (!parent) {\n\t\tWARN(1, \"parent clk %s of %s must be registered first\\n\",\n\t\t\tname, parent_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tval = readl_relaxed(clk_base + pll_params->base_reg);\n\tif (val & PLLSS_REF_SRC_SEL_MASK) {\n\t\tWARN(1, \"not supported reference clock for %s\\n\", name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tparent_rate = clk_get_rate(parent);\n\n\tpll_params->vco_min = _clip_vco_min(pll_params->vco_min, parent_rate);\n\n\tif (pll_params->adjust_vco)\n\t\tpll_params->vco_min = pll_params->adjust_vco(pll_params,\n\t\t\t\t\t\t\t     parent_rate);\n\n\tpll_params->flags |= TEGRA_PLL_BYPASS;\n\tpll = _tegra_init_pll(clk_base, NULL, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t\t&tegra_clk_pll_ops);\n\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\nstruct clk *tegra_clk_register_pllmb(const char *name, const char *parent_name,\n\t\t\t  void __iomem *clk_base, void __iomem *pmc,\n\t\t\t  unsigned long flags,\n\t\t\t  struct tegra_clk_pll_params *pll_params,\n\t\t\t  spinlock_t *lock)\n{\n\tstruct tegra_clk_pll *pll;\n\tstruct clk *clk, *parent;\n\tunsigned long parent_rate;\n\n\tif (!pll_params->pdiv_tohw)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tparent = __clk_lookup(parent_name);\n\tif (!parent) {\n\t\tWARN(1, \"parent clk %s of %s must be registered first\\n\",\n\t\t\tparent_name, name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tparent_rate = clk_get_rate(parent);\n\n\tpll_params->vco_min = _clip_vco_min(pll_params->vco_min, parent_rate);\n\n\tif (pll_params->adjust_vco)\n\t\tpll_params->vco_min = pll_params->adjust_vco(pll_params,\n\t\t\t\t\t\t\t     parent_rate);\n\n\tpll_params->flags |= TEGRA_PLL_BYPASS;\n\tpll_params->flags |= TEGRA_PLLMB;\n\tpll = _tegra_init_pll(clk_base, pmc, pll_params, lock);\n\tif (IS_ERR(pll))\n\t\treturn ERR_CAST(pll);\n\n\tclk = _tegra_clk_register_pll(pll, name, parent_name, flags,\n\t\t\t\t      &tegra_clk_pll_ops);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}