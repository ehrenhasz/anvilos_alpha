{
  "module_name": "clk-pll-out.c",
  "hash_id": "71d39123cd38ebc7a1b772635c555fd4454bd56896c70e984dc02798b9fb03b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-pll-out.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/clk-provider.h>\n\n#include \"clk.h\"\n\n#define pll_out_enb(p) (BIT(p->enb_bit_idx))\n#define pll_out_rst(p) (BIT(p->rst_bit_idx))\n\nstatic int clk_pll_out_is_enabled(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll_out *pll_out = to_clk_pll_out(hw);\n\tu32 val = readl_relaxed(pll_out->reg);\n\tint state;\n\n\tstate = (val & pll_out_enb(pll_out)) ? 1 : 0;\n\tif (!(val & (pll_out_rst(pll_out))))\n\t\tstate = 0;\n\treturn state;\n}\n\nstatic int clk_pll_out_enable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll_out *pll_out = to_clk_pll_out(hw);\n\tunsigned long flags = 0;\n\tu32 val;\n\n\tif (pll_out->lock)\n\t\tspin_lock_irqsave(pll_out->lock, flags);\n\n\tval = readl_relaxed(pll_out->reg);\n\n\tval |= (pll_out_enb(pll_out) | pll_out_rst(pll_out));\n\n\twritel_relaxed(val, pll_out->reg);\n\tudelay(2);\n\n\tif (pll_out->lock)\n\t\tspin_unlock_irqrestore(pll_out->lock, flags);\n\n\treturn 0;\n}\n\nstatic void clk_pll_out_disable(struct clk_hw *hw)\n{\n\tstruct tegra_clk_pll_out *pll_out = to_clk_pll_out(hw);\n\tunsigned long flags = 0;\n\tu32 val;\n\n\tif (pll_out->lock)\n\t\tspin_lock_irqsave(pll_out->lock, flags);\n\n\tval = readl_relaxed(pll_out->reg);\n\n\tval &= ~(pll_out_enb(pll_out) | pll_out_rst(pll_out));\n\n\twritel_relaxed(val, pll_out->reg);\n\tudelay(2);\n\n\tif (pll_out->lock)\n\t\tspin_unlock_irqrestore(pll_out->lock, flags);\n}\n\nstatic void tegra_clk_pll_out_restore_context(struct clk_hw *hw)\n{\n\tif (!__clk_get_enable_count(hw->clk))\n\t\tclk_pll_out_disable(hw);\n\telse\n\t\tclk_pll_out_enable(hw);\n}\n\nconst struct clk_ops tegra_clk_pll_out_ops = {\n\t.is_enabled = clk_pll_out_is_enabled,\n\t.enable = clk_pll_out_enable,\n\t.disable = clk_pll_out_disable,\n\t.restore_context = tegra_clk_pll_out_restore_context,\n};\n\nstruct clk *tegra_clk_register_pll_out(const char *name,\n\t\tconst char *parent_name, void __iomem *reg, u8 enb_bit_idx,\n\t\tu8 rst_bit_idx, unsigned long flags, u8 pll_out_flags,\n\t\tspinlock_t *lock)\n{\n\tstruct tegra_clk_pll_out *pll_out;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\tpll_out = kzalloc(sizeof(*pll_out), GFP_KERNEL);\n\tif (!pll_out)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &tegra_clk_pll_out_ops;\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\tinit.flags = flags;\n\n\tpll_out->reg = reg;\n\tpll_out->enb_bit_idx = enb_bit_idx;\n\tpll_out->rst_bit_idx = rst_bit_idx;\n\tpll_out->flags = pll_out_flags;\n\tpll_out->lock = lock;\n\n\t \n\tpll_out->hw.init = &init;\n\n\tclk = clk_register(NULL, &pll_out->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(pll_out);\n\n\treturn clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}