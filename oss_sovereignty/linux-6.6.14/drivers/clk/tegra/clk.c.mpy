{
  "module_name": "clk.c",
  "hash_id": "e8aa702871b0cfa27f786b51339ed4fcd77268433ab4a7ed169b462e32e6ed4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk.c",
  "human_readable_source": "\n \n\n#include <linux/clkdev.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/clk/tegra.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset-controller.h>\n#include <linux/string_helpers.h>\n\n#include <soc/tegra/fuse.h>\n\n#include \"clk.h\"\n\n \nstatic struct device_node *tegra_car_np;\nstatic struct tegra_cpu_car_ops dummy_car_ops;\nstruct tegra_cpu_car_ops *tegra_cpu_car_ops = &dummy_car_ops;\n\nint *periph_clk_enb_refcnt;\nstatic int periph_banks;\nstatic u32 *periph_state_ctx;\nstatic struct clk **clks;\nstatic int clk_num;\nstatic struct clk_onecell_data clk_data;\n\n \nstatic int (*special_reset_assert)(unsigned long);\nstatic int (*special_reset_deassert)(unsigned long);\nstatic unsigned int num_special_reset;\n\nstatic const struct tegra_clk_periph_regs periph_regs[] = {\n\t[0] = {\n\t\t.enb_reg = CLK_OUT_ENB_L,\n\t\t.enb_set_reg = CLK_OUT_ENB_SET_L,\n\t\t.enb_clr_reg = CLK_OUT_ENB_CLR_L,\n\t\t.rst_reg = RST_DEVICES_L,\n\t\t.rst_set_reg = RST_DEVICES_SET_L,\n\t\t.rst_clr_reg = RST_DEVICES_CLR_L,\n\t},\n\t[1] = {\n\t\t.enb_reg = CLK_OUT_ENB_H,\n\t\t.enb_set_reg = CLK_OUT_ENB_SET_H,\n\t\t.enb_clr_reg = CLK_OUT_ENB_CLR_H,\n\t\t.rst_reg = RST_DEVICES_H,\n\t\t.rst_set_reg = RST_DEVICES_SET_H,\n\t\t.rst_clr_reg = RST_DEVICES_CLR_H,\n\t},\n\t[2] = {\n\t\t.enb_reg = CLK_OUT_ENB_U,\n\t\t.enb_set_reg = CLK_OUT_ENB_SET_U,\n\t\t.enb_clr_reg = CLK_OUT_ENB_CLR_U,\n\t\t.rst_reg = RST_DEVICES_U,\n\t\t.rst_set_reg = RST_DEVICES_SET_U,\n\t\t.rst_clr_reg = RST_DEVICES_CLR_U,\n\t},\n\t[3] = {\n\t\t.enb_reg = CLK_OUT_ENB_V,\n\t\t.enb_set_reg = CLK_OUT_ENB_SET_V,\n\t\t.enb_clr_reg = CLK_OUT_ENB_CLR_V,\n\t\t.rst_reg = RST_DEVICES_V,\n\t\t.rst_set_reg = RST_DEVICES_SET_V,\n\t\t.rst_clr_reg = RST_DEVICES_CLR_V,\n\t},\n\t[4] = {\n\t\t.enb_reg = CLK_OUT_ENB_W,\n\t\t.enb_set_reg = CLK_OUT_ENB_SET_W,\n\t\t.enb_clr_reg = CLK_OUT_ENB_CLR_W,\n\t\t.rst_reg = RST_DEVICES_W,\n\t\t.rst_set_reg = RST_DEVICES_SET_W,\n\t\t.rst_clr_reg = RST_DEVICES_CLR_W,\n\t},\n\t[5] = {\n\t\t.enb_reg = CLK_OUT_ENB_X,\n\t\t.enb_set_reg = CLK_OUT_ENB_SET_X,\n\t\t.enb_clr_reg = CLK_OUT_ENB_CLR_X,\n\t\t.rst_reg = RST_DEVICES_X,\n\t\t.rst_set_reg = RST_DEVICES_SET_X,\n\t\t.rst_clr_reg = RST_DEVICES_CLR_X,\n\t},\n\t[6] = {\n\t\t.enb_reg = CLK_OUT_ENB_Y,\n\t\t.enb_set_reg = CLK_OUT_ENB_SET_Y,\n\t\t.enb_clr_reg = CLK_OUT_ENB_CLR_Y,\n\t\t.rst_reg = RST_DEVICES_Y,\n\t\t.rst_set_reg = RST_DEVICES_SET_Y,\n\t\t.rst_clr_reg = RST_DEVICES_CLR_Y,\n\t},\n};\n\nstatic void __iomem *clk_base;\n\nstatic int tegra_clk_rst_assert(struct reset_controller_dev *rcdev,\n\t\tunsigned long id)\n{\n\t \n\ttegra_read_chipid();\n\n\tif (id < periph_banks * 32) {\n\t\twritel_relaxed(BIT(id % 32),\n\t\t\t       clk_base + periph_regs[id / 32].rst_set_reg);\n\t\treturn 0;\n\t} else if (id < periph_banks * 32 + num_special_reset) {\n\t\treturn special_reset_assert(id);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int tegra_clk_rst_deassert(struct reset_controller_dev *rcdev,\n\t\tunsigned long id)\n{\n\tif (id < periph_banks * 32) {\n\t\twritel_relaxed(BIT(id % 32),\n\t\t\t       clk_base + periph_regs[id / 32].rst_clr_reg);\n\t\treturn 0;\n\t} else if (id < periph_banks * 32 + num_special_reset) {\n\t\treturn special_reset_deassert(id);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int tegra_clk_rst_reset(struct reset_controller_dev *rcdev,\n\t\tunsigned long id)\n{\n\tint err;\n\n\terr = tegra_clk_rst_assert(rcdev, id);\n\tif (err)\n\t\treturn err;\n\n\tudelay(1);\n\n\treturn tegra_clk_rst_deassert(rcdev, id);\n}\n\nconst struct tegra_clk_periph_regs *get_reg_bank(int clkid)\n{\n\tint reg_bank = clkid / 32;\n\n\tif (reg_bank < periph_banks)\n\t\treturn &periph_regs[reg_bank];\n\telse {\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n}\n\nvoid tegra_clk_set_pllp_out_cpu(bool enable)\n{\n\tu32 val;\n\n\tval = readl_relaxed(clk_base + CLK_OUT_ENB_Y);\n\tif (enable)\n\t\tval |= CLK_ENB_PLLP_OUT_CPU;\n\telse\n\t\tval &= ~CLK_ENB_PLLP_OUT_CPU;\n\n\twritel_relaxed(val, clk_base + CLK_OUT_ENB_Y);\n}\n\nvoid tegra_clk_periph_suspend(void)\n{\n\tunsigned int i, idx;\n\n\tidx = 0;\n\tfor (i = 0; i < periph_banks; i++, idx++)\n\t\tperiph_state_ctx[idx] =\n\t\t\treadl_relaxed(clk_base + periph_regs[i].enb_reg);\n\n\tfor (i = 0; i < periph_banks; i++, idx++)\n\t\tperiph_state_ctx[idx] =\n\t\t\treadl_relaxed(clk_base + periph_regs[i].rst_reg);\n}\n\nvoid tegra_clk_periph_resume(void)\n{\n\tunsigned int i, idx;\n\n\tidx = 0;\n\tfor (i = 0; i < periph_banks; i++, idx++)\n\t\twritel_relaxed(periph_state_ctx[idx],\n\t\t\t       clk_base + periph_regs[i].enb_reg);\n\t \n\tfence_udelay(5, clk_base);\n\n\tfor (i = 0; i < periph_banks; i++, idx++)\n\t\twritel_relaxed(periph_state_ctx[idx],\n\t\t\t       clk_base + periph_regs[i].rst_reg);\n\n\tfence_udelay(2, clk_base);\n}\n\nstatic int tegra_clk_periph_ctx_init(int banks)\n{\n\tperiph_state_ctx = kcalloc(2 * banks, sizeof(*periph_state_ctx),\n\t\t\t\t   GFP_KERNEL);\n\tif (!periph_state_ctx)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstruct clk ** __init tegra_clk_init(void __iomem *regs, int num, int banks)\n{\n\tclk_base = regs;\n\n\tif (WARN_ON(banks > ARRAY_SIZE(periph_regs)))\n\t\treturn NULL;\n\n\tperiph_clk_enb_refcnt = kcalloc(32 * banks,\n\t\t\t\t\tsizeof(*periph_clk_enb_refcnt),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!periph_clk_enb_refcnt)\n\t\treturn NULL;\n\n\tperiph_banks = banks;\n\n\tclks = kcalloc(num, sizeof(struct clk *), GFP_KERNEL);\n\tif (!clks) {\n\t\tkfree(periph_clk_enb_refcnt);\n\t\treturn NULL;\n\t}\n\n\tclk_num = num;\n\n\tif (IS_ENABLED(CONFIG_PM_SLEEP)) {\n\t\tif (tegra_clk_periph_ctx_init(banks)) {\n\t\t\tkfree(periph_clk_enb_refcnt);\n\t\t\tkfree(clks);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn clks;\n}\n\nvoid __init tegra_init_dup_clks(struct tegra_clk_duplicate *dup_list,\n\t\t\t\tstruct clk *clks[], int clk_max)\n{\n\tstruct clk *clk;\n\n\tfor (; dup_list->clk_id < clk_max; dup_list++) {\n\t\tclk = clks[dup_list->clk_id];\n\t\tdup_list->lookup.clk = clk;\n\t\tclkdev_add(&dup_list->lookup);\n\t}\n}\n\nvoid tegra_init_from_table(struct tegra_clk_init_table *tbl,\n\t\t\t   struct clk *clks[], int clk_max)\n{\n\tstruct clk *clk;\n\n\tfor (; tbl->clk_id < clk_max; tbl++) {\n\t\tclk = clks[tbl->clk_id];\n\t\tif (IS_ERR_OR_NULL(clk)) {\n\t\t\tpr_err(\"%s: invalid entry %ld in clks array for id %d\\n\",\n\t\t\t       __func__, PTR_ERR(clk), tbl->clk_id);\n\t\t\tWARN_ON(1);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tbl->parent_id < clk_max) {\n\t\t\tstruct clk *parent = clks[tbl->parent_id];\n\t\t\tif (clk_set_parent(clk, parent)) {\n\t\t\t\tpr_err(\"%s: Failed to set parent %s of %s\\n\",\n\t\t\t\t       __func__, __clk_get_name(parent),\n\t\t\t\t       __clk_get_name(clk));\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\n\t\tif (tbl->rate)\n\t\t\tif (clk_set_rate(clk, tbl->rate)) {\n\t\t\t\tpr_err(\"%s: Failed to set rate %lu of %s\\n\",\n\t\t\t\t       __func__, tbl->rate,\n\t\t\t\t       __clk_get_name(clk));\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\n\t\tif (tbl->state)\n\t\t\tif (clk_prepare_enable(clk)) {\n\t\t\t\tpr_err(\"%s: Failed to enable %s\\n\", __func__,\n\t\t\t\t       __clk_get_name(clk));\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t}\n}\n\nstatic const struct reset_control_ops rst_ops = {\n\t.assert = tegra_clk_rst_assert,\n\t.deassert = tegra_clk_rst_deassert,\n\t.reset = tegra_clk_rst_reset,\n};\n\nstatic struct reset_controller_dev rst_ctlr = {\n\t.ops = &rst_ops,\n\t.owner = THIS_MODULE,\n\t.of_reset_n_cells = 1,\n};\n\nvoid __init tegra_add_of_provider(struct device_node *np,\n\t\t\t\t  void *clk_src_onecell_get)\n{\n\tint i;\n\n\ttegra_car_np = np;\n\n\tfor (i = 0; i < clk_num; i++) {\n\t\tif (IS_ERR(clks[i])) {\n\t\t\tpr_err\n\t\t\t    (\"Tegra clk %d: register failed with %ld\\n\",\n\t\t\t     i, PTR_ERR(clks[i]));\n\t\t}\n\t\tif (!clks[i])\n\t\t\tclks[i] = ERR_PTR(-EINVAL);\n\t}\n\n\tclk_data.clks = clks;\n\tclk_data.clk_num = clk_num;\n\tof_clk_add_provider(np, clk_src_onecell_get, &clk_data);\n\n\trst_ctlr.of_node = np;\n\trst_ctlr.nr_resets = periph_banks * 32 + num_special_reset;\n\treset_controller_register(&rst_ctlr);\n}\n\nvoid __init tegra_init_special_resets(unsigned int num,\n\t\t\t\t      int (*assert)(unsigned long),\n\t\t\t\t      int (*deassert)(unsigned long))\n{\n\tnum_special_reset = num;\n\tspecial_reset_assert = assert;\n\tspecial_reset_deassert = deassert;\n}\n\nvoid tegra_register_devclks(struct tegra_devclk *dev_clks, int num)\n{\n\tint i;\n\n\tfor (i = 0; i < num; i++, dev_clks++)\n\t\tclk_register_clkdev(clks[dev_clks->dt_id], dev_clks->con_id,\n\t\t\t\tdev_clks->dev_id);\n\n\tfor (i = 0; i < clk_num; i++) {\n\t\tif (!IS_ERR_OR_NULL(clks[i]))\n\t\t\tclk_register_clkdev(clks[i], __clk_get_name(clks[i]),\n\t\t\t\t\"tegra-clk-debug\");\n\t}\n}\n\nstruct clk ** __init tegra_lookup_dt_id(int clk_id,\n\t\t\t\t\tstruct tegra_clk *tegra_clk)\n{\n\tif (tegra_clk[clk_id].present)\n\t\treturn &clks[tegra_clk[clk_id].dt_id];\n\telse\n\t\treturn NULL;\n}\n\nstatic struct device_node *tegra_clk_get_of_node(struct clk_hw *hw)\n{\n\tstruct device_node *np;\n\tchar *node_name;\n\n\tnode_name = kstrdup_and_replace(hw->init->name, '_', '-', GFP_KERNEL);\n\tif (!node_name)\n\t\treturn NULL;\n\n\tfor_each_child_of_node(tegra_car_np, np) {\n\t\tif (!strcmp(np->name, node_name))\n\t\t\tbreak;\n\t}\n\n\tkfree(node_name);\n\n\treturn np;\n}\n\nstruct clk *tegra_clk_dev_register(struct clk_hw *hw)\n{\n\tstruct platform_device *pdev, *parent;\n\tconst char *dev_name = NULL;\n\tstruct device *dev = NULL;\n\tstruct device_node *np;\n\n\tnp = tegra_clk_get_of_node(hw);\n\n\tif (!of_device_is_available(np))\n\t\tgoto put_node;\n\n\tdev_name = kasprintf(GFP_KERNEL, \"tegra_clk_%s\", hw->init->name);\n\tif (!dev_name)\n\t\tgoto put_node;\n\n\tparent = of_find_device_by_node(tegra_car_np);\n\tif (parent) {\n\t\tpdev = of_platform_device_create(np, dev_name, &parent->dev);\n\t\tput_device(&parent->dev);\n\n\t\tif (!pdev) {\n\t\t\tpr_err(\"%s: failed to create device for %pOF\\n\",\n\t\t\t       __func__, np);\n\t\t\tgoto free_name;\n\t\t}\n\n\t\tdev = &pdev->dev;\n\t\tpm_runtime_enable(dev);\n\t} else {\n\t\tWARN(1, \"failed to find device for %pOF\\n\", tegra_car_np);\n\t}\n\nfree_name:\n\tkfree(dev_name);\nput_node:\n\tof_node_put(np);\n\n\treturn clk_register(dev, hw);\n}\n\ntegra_clk_apply_init_table_func tegra_clk_apply_init_table;\n\nstatic int __init tegra_clocks_apply_init_table(void)\n{\n\tif (!tegra_clk_apply_init_table)\n\t\treturn 0;\n\n\ttegra_clk_apply_init_table();\n\n\treturn 0;\n}\narch_initcall(tegra_clocks_apply_init_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}