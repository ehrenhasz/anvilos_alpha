{
  "module_name": "clk-dfll.c",
  "hash_id": "6d50142aab9032f9125df2a4b11d54c8f27724c473e436f0d3fee18b761df091",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-dfll.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_opp.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/seq_file.h>\n\n#include \"clk-dfll.h\"\n#include \"cvb.h\"\n\n \n\n \n#define DFLL_CTRL\t\t\t0x00\n#define DFLL_CTRL_MODE_MASK\t\t0x03\n\n \n#define DFLL_CONFIG\t\t\t0x04\n#define DFLL_CONFIG_DIV_MASK\t\t0xff\n#define DFLL_CONFIG_DIV_PRESCALE\t32\n\n \n#define DFLL_PARAMS\t\t\t0x08\n#define DFLL_PARAMS_CG_SCALE\t\t(0x1 << 24)\n#define DFLL_PARAMS_FORCE_MODE_SHIFT\t22\n#define DFLL_PARAMS_FORCE_MODE_MASK\t(0x3 << DFLL_PARAMS_FORCE_MODE_SHIFT)\n#define DFLL_PARAMS_CF_PARAM_SHIFT\t16\n#define DFLL_PARAMS_CF_PARAM_MASK\t(0x3f << DFLL_PARAMS_CF_PARAM_SHIFT)\n#define DFLL_PARAMS_CI_PARAM_SHIFT\t8\n#define DFLL_PARAMS_CI_PARAM_MASK\t(0x7 << DFLL_PARAMS_CI_PARAM_SHIFT)\n#define DFLL_PARAMS_CG_PARAM_SHIFT\t0\n#define DFLL_PARAMS_CG_PARAM_MASK\t(0xff << DFLL_PARAMS_CG_PARAM_SHIFT)\n\n \n#define DFLL_TUNE0\t\t\t0x0c\n\n \n#define DFLL_TUNE1\t\t\t0x10\n\n \n#define DFLL_FREQ_REQ\t\t\t0x14\n#define DFLL_FREQ_REQ_FORCE_ENABLE\t(0x1 << 28)\n#define DFLL_FREQ_REQ_FORCE_SHIFT\t16\n#define DFLL_FREQ_REQ_FORCE_MASK\t(0xfff << DFLL_FREQ_REQ_FORCE_SHIFT)\n#define FORCE_MAX\t\t\t2047\n#define FORCE_MIN\t\t\t-2048\n#define DFLL_FREQ_REQ_SCALE_SHIFT\t8\n#define DFLL_FREQ_REQ_SCALE_MASK\t(0xff << DFLL_FREQ_REQ_SCALE_SHIFT)\n#define DFLL_FREQ_REQ_SCALE_MAX\t\t256\n#define DFLL_FREQ_REQ_FREQ_VALID\t(0x1 << 7)\n#define DFLL_FREQ_REQ_MULT_SHIFT\t0\n#define DFLL_FREQ_REG_MULT_MASK\t\t(0x7f << DFLL_FREQ_REQ_MULT_SHIFT)\n#define FREQ_MAX\t\t\t127\n\n \n#define DFLL_DROOP_CTRL\t\t\t0x1c\n\n \n \n#define DFLL_OUTPUT_CFG\t\t\t0x20\n#define DFLL_OUTPUT_CFG_I2C_ENABLE\t(0x1 << 30)\n#define OUT_MASK\t\t\t0x3f\n#define DFLL_OUTPUT_CFG_SAFE_SHIFT\t24\n#define DFLL_OUTPUT_CFG_SAFE_MASK\t\\\n\t\t(OUT_MASK << DFLL_OUTPUT_CFG_SAFE_SHIFT)\n#define DFLL_OUTPUT_CFG_MAX_SHIFT\t16\n#define DFLL_OUTPUT_CFG_MAX_MASK\t\\\n\t\t(OUT_MASK << DFLL_OUTPUT_CFG_MAX_SHIFT)\n#define DFLL_OUTPUT_CFG_MIN_SHIFT\t8\n#define DFLL_OUTPUT_CFG_MIN_MASK\t\\\n\t\t(OUT_MASK << DFLL_OUTPUT_CFG_MIN_SHIFT)\n#define DFLL_OUTPUT_CFG_PWM_DELTA\t(0x1 << 7)\n#define DFLL_OUTPUT_CFG_PWM_ENABLE\t(0x1 << 6)\n#define DFLL_OUTPUT_CFG_PWM_DIV_SHIFT\t0\n#define DFLL_OUTPUT_CFG_PWM_DIV_MASK\t\\\n\t\t(OUT_MASK << DFLL_OUTPUT_CFG_PWM_DIV_SHIFT)\n\n \n#define DFLL_OUTPUT_FORCE\t\t0x24\n#define DFLL_OUTPUT_FORCE_ENABLE\t(0x1 << 6)\n#define DFLL_OUTPUT_FORCE_VALUE_SHIFT\t0\n#define DFLL_OUTPUT_FORCE_VALUE_MASK\t\\\n\t\t(OUT_MASK << DFLL_OUTPUT_FORCE_VALUE_SHIFT)\n\n \n#define DFLL_MONITOR_CTRL\t\t0x28\n#define DFLL_MONITOR_CTRL_FREQ\t\t6\n\n \n#define DFLL_MONITOR_DATA\t\t0x2c\n#define DFLL_MONITOR_DATA_NEW_MASK\t(0x1 << 16)\n#define DFLL_MONITOR_DATA_VAL_SHIFT\t0\n#define DFLL_MONITOR_DATA_VAL_MASK\t(0xFFFF << DFLL_MONITOR_DATA_VAL_SHIFT)\n\n \n\n \n#define DFLL_I2C_CFG\t\t\t0x40\n#define DFLL_I2C_CFG_ARB_ENABLE\t\t(0x1 << 20)\n#define DFLL_I2C_CFG_HS_CODE_SHIFT\t16\n#define DFLL_I2C_CFG_HS_CODE_MASK\t(0x7 << DFLL_I2C_CFG_HS_CODE_SHIFT)\n#define DFLL_I2C_CFG_PACKET_ENABLE\t(0x1 << 15)\n#define DFLL_I2C_CFG_SIZE_SHIFT\t\t12\n#define DFLL_I2C_CFG_SIZE_MASK\t\t(0x7 << DFLL_I2C_CFG_SIZE_SHIFT)\n#define DFLL_I2C_CFG_SLAVE_ADDR_10\t(0x1 << 10)\n#define DFLL_I2C_CFG_SLAVE_ADDR_SHIFT_7BIT\t1\n#define DFLL_I2C_CFG_SLAVE_ADDR_SHIFT_10BIT\t0\n\n \n#define DFLL_I2C_VDD_REG_ADDR\t\t0x44\n\n \n#define DFLL_I2C_STS\t\t\t0x48\n#define DFLL_I2C_STS_I2C_LAST_SHIFT\t1\n#define DFLL_I2C_STS_I2C_REQ_PENDING\t0x1\n\n \n#define DFLL_INTR_STS\t\t\t0x5c\n\n \n#define DFLL_INTR_EN\t\t\t0x60\n#define DFLL_INTR_MIN_MASK\t\t0x1\n#define DFLL_INTR_MAX_MASK\t\t0x2\n\n \n\n \n#define DFLL_I2C_CLK_DIVISOR\t\t0x6c\n#define DFLL_I2C_CLK_DIVISOR_MASK\t0xffff\n#define DFLL_I2C_CLK_DIVISOR_FS_SHIFT\t16\n#define DFLL_I2C_CLK_DIVISOR_HS_SHIFT\t0\n#define DFLL_I2C_CLK_DIVISOR_PREDIV\t8\n#define DFLL_I2C_CLK_DIVISOR_HSMODE_PREDIV\t12\n\n \n\n \n#define MAX_DFLL_VOLTAGES\t\t33\n\n \n#define REF_CLK_CYC_PER_DVCO_SAMPLE\t4\n\n \n#define REF_CLOCK_RATE\t\t\t51000000UL\n\n#define DVCO_RATE_TO_MULT(rate, ref_rate)\t((rate) / ((ref_rate) / 2))\n#define MULT_TO_DVCO_RATE(mult, ref_rate)\t((mult) * ((ref_rate) / 2))\n\n \nenum dfll_ctrl_mode {\n\tDFLL_UNINITIALIZED = 0,\n\tDFLL_DISABLED = 1,\n\tDFLL_OPEN_LOOP = 2,\n\tDFLL_CLOSED_LOOP = 3,\n};\n\n \nenum dfll_tune_range {\n\tDFLL_TUNE_UNINITIALIZED = 0,\n\tDFLL_TUNE_LOW = 1,\n};\n\n\nenum tegra_dfll_pmu_if {\n\tTEGRA_DFLL_PMU_I2C = 0,\n\tTEGRA_DFLL_PMU_PWM = 1,\n};\n\n \nstruct dfll_rate_req {\n\tunsigned long rate;\n\tunsigned long dvco_target_rate;\n\tint lut_index;\n\tu8 mult_bits;\n\tu8 scale_bits;\n};\n\nstruct tegra_dfll {\n\tstruct device\t\t\t*dev;\n\tstruct tegra_dfll_soc_data\t*soc;\n\n\tvoid __iomem\t\t\t*base;\n\tvoid __iomem\t\t\t*i2c_base;\n\tvoid __iomem\t\t\t*i2c_controller_base;\n\tvoid __iomem\t\t\t*lut_base;\n\n\tstruct regulator\t\t*vdd_reg;\n\tstruct clk\t\t\t*soc_clk;\n\tstruct clk\t\t\t*ref_clk;\n\tstruct clk\t\t\t*i2c_clk;\n\tstruct clk\t\t\t*dfll_clk;\n\tstruct reset_control\t\t*dfll_rst;\n\tstruct reset_control\t\t*dvco_rst;\n\tunsigned long\t\t\tref_rate;\n\tunsigned long\t\t\ti2c_clk_rate;\n\tunsigned long\t\t\tdvco_rate_min;\n\n\tenum dfll_ctrl_mode\t\tmode;\n\tenum dfll_tune_range\t\ttune_range;\n\tstruct dentry\t\t\t*debugfs_dir;\n\tstruct clk_hw\t\t\tdfll_clk_hw;\n\tconst char\t\t\t*output_clock_name;\n\tstruct dfll_rate_req\t\tlast_req;\n\tunsigned long\t\t\tlast_unrounded_rate;\n\n\t \n\tu32\t\t\t\tdroop_ctrl;\n\tu32\t\t\t\tsample_rate;\n\tu32\t\t\t\tforce_mode;\n\tu32\t\t\t\tcf;\n\tu32\t\t\t\tci;\n\tu32\t\t\t\tcg;\n\tbool\t\t\t\tcg_scale;\n\n\t \n\tu32\t\t\t\ti2c_fs_rate;\n\tu32\t\t\t\ti2c_reg;\n\tu32\t\t\t\ti2c_slave_addr;\n\n\t \n\tunsigned\t\t\tlut[MAX_DFLL_VOLTAGES];\n\tunsigned long\t\t\tlut_uv[MAX_DFLL_VOLTAGES];\n\tint\t\t\t\tlut_size;\n\tu8\t\t\t\tlut_bottom, lut_min, lut_max, lut_safe;\n\n\t \n\tenum tegra_dfll_pmu_if\t\tpmu_if;\n\tunsigned long\t\t\tpwm_rate;\n\tstruct pinctrl\t\t\t*pwm_pin;\n\tstruct pinctrl_state\t\t*pwm_enable_state;\n\tstruct pinctrl_state\t\t*pwm_disable_state;\n\tu32\t\t\t\treg_init_uV;\n};\n\n#define clk_hw_to_dfll(_hw) container_of(_hw, struct tegra_dfll, dfll_clk_hw)\n\n \nstatic const char * const mode_name[] = {\n\t[DFLL_UNINITIALIZED] = \"uninitialized\",\n\t[DFLL_DISABLED] = \"disabled\",\n\t[DFLL_OPEN_LOOP] = \"open_loop\",\n\t[DFLL_CLOSED_LOOP] = \"closed_loop\",\n};\n\n \n\nstatic inline u32 dfll_readl(struct tegra_dfll *td, u32 offs)\n{\n\treturn __raw_readl(td->base + offs);\n}\n\nstatic inline void dfll_writel(struct tegra_dfll *td, u32 val, u32 offs)\n{\n\tWARN_ON(offs >= DFLL_I2C_CFG);\n\t__raw_writel(val, td->base + offs);\n}\n\nstatic inline void dfll_wmb(struct tegra_dfll *td)\n{\n\tdfll_readl(td, DFLL_CTRL);\n}\n\n \n\nstatic inline u32 dfll_i2c_readl(struct tegra_dfll *td, u32 offs)\n{\n\treturn __raw_readl(td->i2c_base + offs);\n}\n\nstatic inline void dfll_i2c_writel(struct tegra_dfll *td, u32 val, u32 offs)\n{\n\t__raw_writel(val, td->i2c_base + offs);\n}\n\nstatic inline void dfll_i2c_wmb(struct tegra_dfll *td)\n{\n\tdfll_i2c_readl(td, DFLL_I2C_CFG);\n}\n\n \nstatic bool dfll_is_running(struct tegra_dfll *td)\n{\n\treturn td->mode >= DFLL_OPEN_LOOP;\n}\n\n \n\n \nint tegra_dfll_runtime_resume(struct device *dev)\n{\n\tstruct tegra_dfll *td = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_enable(td->ref_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"could not enable ref clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_enable(td->soc_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"could not enable register clock: %d\\n\", ret);\n\t\tclk_disable(td->ref_clk);\n\t\treturn ret;\n\t}\n\n\tret = clk_enable(td->i2c_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"could not enable i2c clock: %d\\n\", ret);\n\t\tclk_disable(td->soc_clk);\n\t\tclk_disable(td->ref_clk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tegra_dfll_runtime_resume);\n\n \nint tegra_dfll_runtime_suspend(struct device *dev)\n{\n\tstruct tegra_dfll *td = dev_get_drvdata(dev);\n\n\tclk_disable(td->ref_clk);\n\tclk_disable(td->soc_clk);\n\tclk_disable(td->i2c_clk);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tegra_dfll_runtime_suspend);\n\n \n\n \nstatic void dfll_tune_low(struct tegra_dfll *td)\n{\n\ttd->tune_range = DFLL_TUNE_LOW;\n\n\tdfll_writel(td, td->soc->cvb->cpu_dfll_data.tune0_low, DFLL_TUNE0);\n\tdfll_writel(td, td->soc->cvb->cpu_dfll_data.tune1, DFLL_TUNE1);\n\tdfll_wmb(td);\n\n\tif (td->soc->set_clock_trimmers_low)\n\t\ttd->soc->set_clock_trimmers_low();\n}\n\n \n\n \nstatic unsigned long dfll_scale_dvco_rate(int scale_bits,\n\t\t\t\t\t  unsigned long dvco_rate)\n{\n\treturn (u64)dvco_rate * (scale_bits + 1) / DFLL_FREQ_REQ_SCALE_MAX;\n}\n\n \n\n \nstatic void dfll_set_mode(struct tegra_dfll *td,\n\t\t\t  enum dfll_ctrl_mode mode)\n{\n\ttd->mode = mode;\n\tdfll_writel(td, mode - 1, DFLL_CTRL);\n\tdfll_wmb(td);\n}\n\n \n\nstatic unsigned long get_dvco_rate_below(struct tegra_dfll *td, u8 out_min)\n{\n\tstruct dev_pm_opp *opp;\n\tunsigned long rate, prev_rate;\n\tunsigned long uv, min_uv;\n\n\tmin_uv = td->lut_uv[out_min];\n\tfor (rate = 0, prev_rate = 0; ; rate++) {\n\t\topp = dev_pm_opp_find_freq_ceil(td->soc->dev, &rate);\n\t\tif (IS_ERR(opp))\n\t\t\tbreak;\n\n\t\tuv = dev_pm_opp_get_voltage(opp);\n\t\tdev_pm_opp_put(opp);\n\n\t\tif (uv && uv > min_uv)\n\t\t\treturn prev_rate;\n\n\t\tprev_rate = rate;\n\t}\n\n\treturn prev_rate;\n}\n\n \n\n \nstatic int dfll_i2c_set_output_enabled(struct tegra_dfll *td, bool enable)\n{\n\tu32 val;\n\n\tval = dfll_i2c_readl(td, DFLL_OUTPUT_CFG);\n\n\tif (enable)\n\t\tval |= DFLL_OUTPUT_CFG_I2C_ENABLE;\n\telse\n\t\tval &= ~DFLL_OUTPUT_CFG_I2C_ENABLE;\n\n\tdfll_i2c_writel(td, val, DFLL_OUTPUT_CFG);\n\tdfll_i2c_wmb(td);\n\n\treturn 0;\n}\n\n\n \n\n \nstatic int dfll_pwm_set_output_enabled(struct tegra_dfll *td, bool enable)\n{\n\tint ret;\n\tu32 val, div;\n\n\tif (enable) {\n\t\tret = pinctrl_select_state(td->pwm_pin, td->pwm_enable_state);\n\t\tif (ret < 0) {\n\t\t\tdev_err(td->dev, \"setting enable state failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = dfll_readl(td, DFLL_OUTPUT_CFG);\n\t\tval &= ~DFLL_OUTPUT_CFG_PWM_DIV_MASK;\n\t\tdiv = DIV_ROUND_UP(td->ref_rate, td->pwm_rate);\n\t\tval |= (div << DFLL_OUTPUT_CFG_PWM_DIV_SHIFT)\n\t\t\t\t& DFLL_OUTPUT_CFG_PWM_DIV_MASK;\n\t\tdfll_writel(td, val, DFLL_OUTPUT_CFG);\n\t\tdfll_wmb(td);\n\n\t\tval |= DFLL_OUTPUT_CFG_PWM_ENABLE;\n\t\tdfll_writel(td, val, DFLL_OUTPUT_CFG);\n\t\tdfll_wmb(td);\n\t} else {\n\t\tret = pinctrl_select_state(td->pwm_pin, td->pwm_disable_state);\n\t\tif (ret < 0)\n\t\t\tdev_warn(td->dev, \"setting disable state failed\\n\");\n\n\t\tval = dfll_readl(td, DFLL_OUTPUT_CFG);\n\t\tval &= ~DFLL_OUTPUT_CFG_PWM_ENABLE;\n\t\tdfll_writel(td, val, DFLL_OUTPUT_CFG);\n\t\tdfll_wmb(td);\n\t}\n\n\treturn 0;\n}\n\n \nstatic u32 dfll_set_force_output_value(struct tegra_dfll *td, u8 out_val)\n{\n\tu32 val = dfll_readl(td, DFLL_OUTPUT_FORCE);\n\n\tval = (val & DFLL_OUTPUT_FORCE_ENABLE) | (out_val & OUT_MASK);\n\tdfll_writel(td, val, DFLL_OUTPUT_FORCE);\n\tdfll_wmb(td);\n\n\treturn dfll_readl(td, DFLL_OUTPUT_FORCE);\n}\n\n \nstatic void dfll_set_force_output_enabled(struct tegra_dfll *td, bool enable)\n{\n\tu32 val = dfll_readl(td, DFLL_OUTPUT_FORCE);\n\n\tif (enable)\n\t\tval |= DFLL_OUTPUT_FORCE_ENABLE;\n\telse\n\t\tval &= ~DFLL_OUTPUT_FORCE_ENABLE;\n\n\tdfll_writel(td, val, DFLL_OUTPUT_FORCE);\n\tdfll_wmb(td);\n}\n\n \nstatic int dfll_force_output(struct tegra_dfll *td, unsigned int out_sel)\n{\n\tu32 val;\n\n\tif (out_sel > OUT_MASK)\n\t\treturn -EINVAL;\n\n\tval = dfll_set_force_output_value(td, out_sel);\n\tif ((td->mode < DFLL_CLOSED_LOOP) &&\n\t    !(val & DFLL_OUTPUT_FORCE_ENABLE)) {\n\t\tdfll_set_force_output_enabled(td, true);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void dfll_load_i2c_lut(struct tegra_dfll *td)\n{\n\tint i, lut_index;\n\tu32 val;\n\n\tfor (i = 0; i < MAX_DFLL_VOLTAGES; i++) {\n\t\tif (i < td->lut_min)\n\t\t\tlut_index = td->lut_min;\n\t\telse if (i > td->lut_max)\n\t\t\tlut_index = td->lut_max;\n\t\telse\n\t\t\tlut_index = i;\n\n\t\tval = regulator_list_hardware_vsel(td->vdd_reg,\n\t\t\t\t\t\t     td->lut[lut_index]);\n\t\t__raw_writel(val, td->lut_base + i * 4);\n\t}\n\n\tdfll_i2c_wmb(td);\n}\n\n \nstatic void dfll_init_i2c_if(struct tegra_dfll *td)\n{\n\tu32 val;\n\n\tif (td->i2c_slave_addr > 0x7f) {\n\t\tval = td->i2c_slave_addr << DFLL_I2C_CFG_SLAVE_ADDR_SHIFT_10BIT;\n\t\tval |= DFLL_I2C_CFG_SLAVE_ADDR_10;\n\t} else {\n\t\tval = td->i2c_slave_addr << DFLL_I2C_CFG_SLAVE_ADDR_SHIFT_7BIT;\n\t}\n\tval |= DFLL_I2C_CFG_SIZE_MASK;\n\tval |= DFLL_I2C_CFG_ARB_ENABLE;\n\tdfll_i2c_writel(td, val, DFLL_I2C_CFG);\n\n\tdfll_i2c_writel(td, td->i2c_reg, DFLL_I2C_VDD_REG_ADDR);\n\n\tval = DIV_ROUND_UP(td->i2c_clk_rate, td->i2c_fs_rate * 8);\n\tBUG_ON(!val || (val > DFLL_I2C_CLK_DIVISOR_MASK));\n\tval = (val - 1) << DFLL_I2C_CLK_DIVISOR_FS_SHIFT;\n\n\t \n\tval |= 1 << DFLL_I2C_CLK_DIVISOR_HS_SHIFT;\n\t__raw_writel(val, td->i2c_controller_base + DFLL_I2C_CLK_DIVISOR);\n\tdfll_i2c_wmb(td);\n}\n\n \nstatic void dfll_init_out_if(struct tegra_dfll *td)\n{\n\tu32 val;\n\n\ttd->lut_min = td->lut_bottom;\n\ttd->lut_max = td->lut_size - 1;\n\ttd->lut_safe = td->lut_min + (td->lut_min < td->lut_max ? 1 : 0);\n\n\t \n\tdfll_writel(td, 0, DFLL_OUTPUT_CFG);\n\tdfll_wmb(td);\n\n\tval = (td->lut_safe << DFLL_OUTPUT_CFG_SAFE_SHIFT) |\n\t      (td->lut_max << DFLL_OUTPUT_CFG_MAX_SHIFT) |\n\t      (td->lut_min << DFLL_OUTPUT_CFG_MIN_SHIFT);\n\tdfll_writel(td, val, DFLL_OUTPUT_CFG);\n\tdfll_wmb(td);\n\n\tdfll_writel(td, 0, DFLL_OUTPUT_FORCE);\n\tdfll_i2c_writel(td, 0, DFLL_INTR_EN);\n\tdfll_i2c_writel(td, DFLL_INTR_MAX_MASK | DFLL_INTR_MIN_MASK,\n\t\t\tDFLL_INTR_STS);\n\n\tif (td->pmu_if == TEGRA_DFLL_PMU_PWM) {\n\t\tu32 vinit = td->reg_init_uV;\n\t\tint vstep = td->soc->alignment.step_uv;\n\t\tunsigned long vmin = td->lut_uv[0];\n\n\t\t \n\t\tif ((vinit >= vmin) && vstep) {\n\t\t\tunsigned int vsel;\n\n\t\t\tvsel = DIV_ROUND_UP((vinit - vmin), vstep);\n\t\t\tdfll_force_output(td, vsel);\n\t\t}\n\t} else {\n\t\tdfll_load_i2c_lut(td);\n\t\tdfll_init_i2c_if(td);\n\t}\n}\n\n \n\n \nstatic int find_lut_index_for_rate(struct tegra_dfll *td, unsigned long rate)\n{\n\tstruct dev_pm_opp *opp;\n\tint i, align_step;\n\n\topp = dev_pm_opp_find_freq_ceil(td->soc->dev, &rate);\n\tif (IS_ERR(opp))\n\t\treturn PTR_ERR(opp);\n\n\talign_step = dev_pm_opp_get_voltage(opp) / td->soc->alignment.step_uv;\n\tdev_pm_opp_put(opp);\n\n\tfor (i = td->lut_bottom; i < td->lut_size; i++) {\n\t\tif ((td->lut_uv[i] / td->soc->alignment.step_uv) >= align_step)\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic int dfll_calculate_rate_request(struct tegra_dfll *td,\n\t\t\t\t       struct dfll_rate_req *req,\n\t\t\t\t       unsigned long rate)\n{\n\tu32 val;\n\n\t \n\treq->scale_bits = DFLL_FREQ_REQ_SCALE_MAX - 1;\n\tif (rate < td->dvco_rate_min) {\n\t\tint scale;\n\n\t\tscale = DIV_ROUND_CLOSEST(rate / 1000 * DFLL_FREQ_REQ_SCALE_MAX,\n\t\t\t\t\t  td->dvco_rate_min / 1000);\n\t\tif (!scale) {\n\t\t\tdev_err(td->dev, \"%s: Rate %lu is too low\\n\",\n\t\t\t\t__func__, rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treq->scale_bits = scale - 1;\n\t\trate = td->dvco_rate_min;\n\t}\n\n\t \n\tval = DVCO_RATE_TO_MULT(rate, td->ref_rate);\n\tif (val > FREQ_MAX) {\n\t\tdev_err(td->dev, \"%s: Rate %lu is above dfll range\\n\",\n\t\t\t__func__, rate);\n\t\treturn -EINVAL;\n\t}\n\treq->mult_bits = val;\n\treq->dvco_target_rate = MULT_TO_DVCO_RATE(req->mult_bits, td->ref_rate);\n\treq->rate = dfll_scale_dvco_rate(req->scale_bits,\n\t\t\t\t\t req->dvco_target_rate);\n\treq->lut_index = find_lut_index_for_rate(td, req->dvco_target_rate);\n\tif (req->lut_index < 0)\n\t\treturn req->lut_index;\n\n\treturn 0;\n}\n\n \nstatic void dfll_set_frequency_request(struct tegra_dfll *td,\n\t\t\t\t       struct dfll_rate_req *req)\n{\n\tu32 val = 0;\n\tint force_val;\n\tint coef = 128;  ;\n\n\tforce_val = (req->lut_index - td->lut_safe) * coef / td->cg;\n\tforce_val = clamp(force_val, FORCE_MIN, FORCE_MAX);\n\n\tval |= req->mult_bits << DFLL_FREQ_REQ_MULT_SHIFT;\n\tval |= req->scale_bits << DFLL_FREQ_REQ_SCALE_SHIFT;\n\tval |= ((u32)force_val << DFLL_FREQ_REQ_FORCE_SHIFT) &\n\t\tDFLL_FREQ_REQ_FORCE_MASK;\n\tval |= DFLL_FREQ_REQ_FREQ_VALID | DFLL_FREQ_REQ_FORCE_ENABLE;\n\n\tdfll_writel(td, val, DFLL_FREQ_REQ);\n\tdfll_wmb(td);\n}\n\n \nstatic int dfll_request_rate(struct tegra_dfll *td, unsigned long rate)\n{\n\tint ret;\n\tstruct dfll_rate_req req;\n\n\tif (td->mode == DFLL_UNINITIALIZED) {\n\t\tdev_err(td->dev, \"%s: Cannot set DFLL rate in %s mode\\n\",\n\t\t\t__func__, mode_name[td->mode]);\n\t\treturn -EPERM;\n\t}\n\n\tret = dfll_calculate_rate_request(td, &req, rate);\n\tif (ret)\n\t\treturn ret;\n\n\ttd->last_unrounded_rate = rate;\n\ttd->last_req = req;\n\n\tif (td->mode == DFLL_CLOSED_LOOP)\n\t\tdfll_set_frequency_request(td, &td->last_req);\n\n\treturn 0;\n}\n\n \n\n \nstatic int dfll_disable(struct tegra_dfll *td)\n{\n\tif (td->mode != DFLL_OPEN_LOOP) {\n\t\tdev_err(td->dev, \"cannot disable DFLL in %s mode\\n\",\n\t\t\tmode_name[td->mode]);\n\t\treturn -EINVAL;\n\t}\n\n\tdfll_set_mode(td, DFLL_DISABLED);\n\tpm_runtime_put_sync(td->dev);\n\n\treturn 0;\n}\n\n \nstatic int dfll_enable(struct tegra_dfll *td)\n{\n\tif (td->mode != DFLL_DISABLED) {\n\t\tdev_err(td->dev, \"cannot enable DFLL in %s mode\\n\",\n\t\t\tmode_name[td->mode]);\n\t\treturn -EPERM;\n\t}\n\n\tpm_runtime_get_sync(td->dev);\n\tdfll_set_mode(td, DFLL_OPEN_LOOP);\n\n\treturn 0;\n}\n\n \nstatic void dfll_set_open_loop_config(struct tegra_dfll *td)\n{\n\tu32 val;\n\n\t \n\tif (td->tune_range != DFLL_TUNE_LOW)\n\t\tdfll_tune_low(td);\n\n\tval = dfll_readl(td, DFLL_FREQ_REQ);\n\tval |= DFLL_FREQ_REQ_SCALE_MASK;\n\tval &= ~DFLL_FREQ_REQ_FORCE_ENABLE;\n\tdfll_writel(td, val, DFLL_FREQ_REQ);\n\tdfll_wmb(td);\n}\n\n \nstatic int dfll_lock(struct tegra_dfll *td)\n{\n\tstruct dfll_rate_req *req = &td->last_req;\n\n\tswitch (td->mode) {\n\tcase DFLL_CLOSED_LOOP:\n\t\treturn 0;\n\n\tcase DFLL_OPEN_LOOP:\n\t\tif (req->rate == 0) {\n\t\t\tdev_err(td->dev, \"%s: Cannot lock DFLL at rate 0\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (td->pmu_if == TEGRA_DFLL_PMU_PWM)\n\t\t\tdfll_pwm_set_output_enabled(td, true);\n\t\telse\n\t\t\tdfll_i2c_set_output_enabled(td, true);\n\n\t\tdfll_set_mode(td, DFLL_CLOSED_LOOP);\n\t\tdfll_set_frequency_request(td, req);\n\t\tdfll_set_force_output_enabled(td, false);\n\t\treturn 0;\n\n\tdefault:\n\t\tBUG_ON(td->mode > DFLL_CLOSED_LOOP);\n\t\tdev_err(td->dev, \"%s: Cannot lock DFLL in %s mode\\n\",\n\t\t\t__func__, mode_name[td->mode]);\n\t\treturn -EPERM;\n\t}\n}\n\n \nstatic int dfll_unlock(struct tegra_dfll *td)\n{\n\tswitch (td->mode) {\n\tcase DFLL_CLOSED_LOOP:\n\t\tdfll_set_open_loop_config(td);\n\t\tdfll_set_mode(td, DFLL_OPEN_LOOP);\n\t\tif (td->pmu_if == TEGRA_DFLL_PMU_PWM)\n\t\t\tdfll_pwm_set_output_enabled(td, false);\n\t\telse\n\t\t\tdfll_i2c_set_output_enabled(td, false);\n\t\treturn 0;\n\n\tcase DFLL_OPEN_LOOP:\n\t\treturn 0;\n\n\tdefault:\n\t\tBUG_ON(td->mode > DFLL_CLOSED_LOOP);\n\t\tdev_err(td->dev, \"%s: Cannot unlock DFLL in %s mode\\n\",\n\t\t\t__func__, mode_name[td->mode]);\n\t\treturn -EPERM;\n\t}\n}\n\n \n\nstatic int dfll_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct tegra_dfll *td = clk_hw_to_dfll(hw);\n\n\treturn dfll_is_running(td);\n}\n\nstatic int dfll_clk_enable(struct clk_hw *hw)\n{\n\tstruct tegra_dfll *td = clk_hw_to_dfll(hw);\n\tint ret;\n\n\tret = dfll_enable(td);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dfll_lock(td);\n\tif (ret)\n\t\tdfll_disable(td);\n\n\treturn ret;\n}\n\nstatic void dfll_clk_disable(struct clk_hw *hw)\n{\n\tstruct tegra_dfll *td = clk_hw_to_dfll(hw);\n\tint ret;\n\n\tret = dfll_unlock(td);\n\tif (!ret)\n\t\tdfll_disable(td);\n}\n\nstatic unsigned long dfll_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct tegra_dfll *td = clk_hw_to_dfll(hw);\n\n\treturn td->last_unrounded_rate;\n}\n\n \nstatic int dfll_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t   struct clk_rate_request *clk_req)\n{\n\tstruct tegra_dfll *td = clk_hw_to_dfll(hw);\n\tstruct dfll_rate_req req;\n\tint ret;\n\n\tret = dfll_calculate_rate_request(td, &req, clk_req->rate);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\treturn 0;\n}\n\nstatic int dfll_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t     unsigned long parent_rate)\n{\n\tstruct tegra_dfll *td = clk_hw_to_dfll(hw);\n\n\treturn dfll_request_rate(td, rate);\n}\n\nstatic const struct clk_ops dfll_clk_ops = {\n\t.is_enabled\t= dfll_clk_is_enabled,\n\t.enable\t\t= dfll_clk_enable,\n\t.disable\t= dfll_clk_disable,\n\t.recalc_rate\t= dfll_clk_recalc_rate,\n\t.determine_rate\t= dfll_clk_determine_rate,\n\t.set_rate\t= dfll_clk_set_rate,\n};\n\nstatic struct clk_init_data dfll_clk_init_data = {\n\t.ops\t\t= &dfll_clk_ops,\n\t.num_parents\t= 0,\n};\n\n \nstatic int dfll_register_clk(struct tegra_dfll *td)\n{\n\tint ret;\n\n\tdfll_clk_init_data.name = td->output_clock_name;\n\ttd->dfll_clk_hw.init = &dfll_clk_init_data;\n\n\ttd->dfll_clk = clk_register(td->dev, &td->dfll_clk_hw);\n\tif (IS_ERR(td->dfll_clk)) {\n\t\tdev_err(td->dev, \"DFLL clock registration error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_clk_add_provider(td->dev->of_node, of_clk_src_simple_get,\n\t\t\t\t  td->dfll_clk);\n\tif (ret) {\n\t\tdev_err(td->dev, \"of_clk_add_provider() failed\\n\");\n\n\t\tclk_unregister(td->dfll_clk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void dfll_unregister_clk(struct tegra_dfll *td)\n{\n\tof_clk_del_provider(td->dev->of_node);\n\tclk_unregister(td->dfll_clk);\n\ttd->dfll_clk = NULL;\n}\n\n \n\n#ifdef CONFIG_DEBUG_FS\n \n\n \nstatic u64 dfll_calc_monitored_rate(u32 monitor_data,\n\t\t\t\t    unsigned long ref_rate)\n{\n\treturn monitor_data * (ref_rate / REF_CLK_CYC_PER_DVCO_SAMPLE);\n}\n\n \nstatic u64 dfll_read_monitor_rate(struct tegra_dfll *td)\n{\n\tu32 v, s;\n\tu64 pre_scaler_rate, post_scaler_rate;\n\n\tif (!dfll_is_running(td))\n\t\treturn 0;\n\n\tv = dfll_readl(td, DFLL_MONITOR_DATA);\n\tv = (v & DFLL_MONITOR_DATA_VAL_MASK) >> DFLL_MONITOR_DATA_VAL_SHIFT;\n\tpre_scaler_rate = dfll_calc_monitored_rate(v, td->ref_rate);\n\n\ts = dfll_readl(td, DFLL_FREQ_REQ);\n\ts = (s & DFLL_FREQ_REQ_SCALE_MASK) >> DFLL_FREQ_REQ_SCALE_SHIFT;\n\tpost_scaler_rate = dfll_scale_dvco_rate(s, pre_scaler_rate);\n\n\treturn post_scaler_rate;\n}\n\nstatic int attr_enable_get(void *data, u64 *val)\n{\n\tstruct tegra_dfll *td = data;\n\n\t*val = dfll_is_running(td);\n\n\treturn 0;\n}\nstatic int attr_enable_set(void *data, u64 val)\n{\n\tstruct tegra_dfll *td = data;\n\n\treturn val ? dfll_enable(td) : dfll_disable(td);\n}\nDEFINE_DEBUGFS_ATTRIBUTE(enable_fops, attr_enable_get, attr_enable_set,\n\t\t\t \"%llu\\n\");\n\nstatic int attr_lock_get(void *data, u64 *val)\n{\n\tstruct tegra_dfll *td = data;\n\n\t*val = (td->mode == DFLL_CLOSED_LOOP);\n\n\treturn 0;\n}\nstatic int attr_lock_set(void *data, u64 val)\n{\n\tstruct tegra_dfll *td = data;\n\n\treturn val ? dfll_lock(td) :  dfll_unlock(td);\n}\nDEFINE_DEBUGFS_ATTRIBUTE(lock_fops, attr_lock_get, attr_lock_set, \"%llu\\n\");\n\nstatic int attr_rate_get(void *data, u64 *val)\n{\n\tstruct tegra_dfll *td = data;\n\n\t*val = dfll_read_monitor_rate(td);\n\n\treturn 0;\n}\n\nstatic int attr_rate_set(void *data, u64 val)\n{\n\tstruct tegra_dfll *td = data;\n\n\treturn dfll_request_rate(td, val);\n}\nDEFINE_DEBUGFS_ATTRIBUTE(rate_fops, attr_rate_get, attr_rate_set, \"%llu\\n\");\n\nstatic int attr_registers_show(struct seq_file *s, void *data)\n{\n\tu32 val, offs;\n\tstruct tegra_dfll *td = s->private;\n\n\tseq_puts(s, \"CONTROL REGISTERS:\\n\");\n\tfor (offs = 0; offs <= DFLL_MONITOR_DATA; offs += 4) {\n\t\tif (offs == DFLL_OUTPUT_CFG)\n\t\t\tval = dfll_i2c_readl(td, offs);\n\t\telse\n\t\t\tval = dfll_readl(td, offs);\n\t\tseq_printf(s, \"[0x%02x] = 0x%08x\\n\", offs, val);\n\t}\n\n\tseq_puts(s, \"\\nI2C and INTR REGISTERS:\\n\");\n\tfor (offs = DFLL_I2C_CFG; offs <= DFLL_I2C_STS; offs += 4)\n\t\tseq_printf(s, \"[0x%02x] = 0x%08x\\n\", offs,\n\t\t\t   dfll_i2c_readl(td, offs));\n\tfor (offs = DFLL_INTR_STS; offs <= DFLL_INTR_EN; offs += 4)\n\t\tseq_printf(s, \"[0x%02x] = 0x%08x\\n\", offs,\n\t\t\t   dfll_i2c_readl(td, offs));\n\n\tif (td->pmu_if == TEGRA_DFLL_PMU_I2C) {\n\t\tseq_puts(s, \"\\nINTEGRATED I2C CONTROLLER REGISTERS:\\n\");\n\t\toffs = DFLL_I2C_CLK_DIVISOR;\n\t\tseq_printf(s, \"[0x%02x] = 0x%08x\\n\", offs,\n\t\t\t   __raw_readl(td->i2c_controller_base + offs));\n\n\t\tseq_puts(s, \"\\nLUT:\\n\");\n\t\tfor (offs = 0; offs <  4 * MAX_DFLL_VOLTAGES; offs += 4)\n\t\t\tseq_printf(s, \"[0x%02x] = 0x%08x\\n\", offs,\n\t\t\t\t   __raw_readl(td->lut_base + offs));\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(attr_registers);\n\nstatic void dfll_debug_init(struct tegra_dfll *td)\n{\n\tstruct dentry *root;\n\n\tif (!td || (td->mode == DFLL_UNINITIALIZED))\n\t\treturn;\n\n\troot = debugfs_create_dir(\"tegra_dfll_fcpu\", NULL);\n\ttd->debugfs_dir = root;\n\n\tdebugfs_create_file_unsafe(\"enable\", 0644, root, td,\n\t\t\t\t   &enable_fops);\n\tdebugfs_create_file_unsafe(\"lock\", 0444, root, td, &lock_fops);\n\tdebugfs_create_file_unsafe(\"rate\", 0444, root, td, &rate_fops);\n\tdebugfs_create_file(\"registers\", 0444, root, td, &attr_registers_fops);\n}\n\n#else\nstatic inline void dfll_debug_init(struct tegra_dfll *td) { }\n#endif  \n\n \n\n \nstatic void dfll_set_default_params(struct tegra_dfll *td)\n{\n\tu32 val;\n\n\tval = DIV_ROUND_UP(td->ref_rate, td->sample_rate * 32);\n\tBUG_ON(val > DFLL_CONFIG_DIV_MASK);\n\tdfll_writel(td, val, DFLL_CONFIG);\n\n\tval = (td->force_mode << DFLL_PARAMS_FORCE_MODE_SHIFT) |\n\t\t(td->cf << DFLL_PARAMS_CF_PARAM_SHIFT) |\n\t\t(td->ci << DFLL_PARAMS_CI_PARAM_SHIFT) |\n\t\t(td->cg << DFLL_PARAMS_CG_PARAM_SHIFT) |\n\t\t(td->cg_scale ? DFLL_PARAMS_CG_SCALE : 0);\n\tdfll_writel(td, val, DFLL_PARAMS);\n\n\tdfll_tune_low(td);\n\tdfll_writel(td, td->droop_ctrl, DFLL_DROOP_CTRL);\n\tdfll_writel(td, DFLL_MONITOR_CTRL_FREQ, DFLL_MONITOR_CTRL);\n}\n\n \nstatic int dfll_init_clks(struct tegra_dfll *td)\n{\n\ttd->ref_clk = devm_clk_get(td->dev, \"ref\");\n\tif (IS_ERR(td->ref_clk)) {\n\t\tdev_err(td->dev, \"missing ref clock\\n\");\n\t\treturn PTR_ERR(td->ref_clk);\n\t}\n\n\ttd->soc_clk = devm_clk_get(td->dev, \"soc\");\n\tif (IS_ERR(td->soc_clk)) {\n\t\tdev_err(td->dev, \"missing soc clock\\n\");\n\t\treturn PTR_ERR(td->soc_clk);\n\t}\n\n\ttd->i2c_clk = devm_clk_get(td->dev, \"i2c\");\n\tif (IS_ERR(td->i2c_clk)) {\n\t\tdev_err(td->dev, \"missing i2c clock\\n\");\n\t\treturn PTR_ERR(td->i2c_clk);\n\t}\n\ttd->i2c_clk_rate = clk_get_rate(td->i2c_clk);\n\n\treturn 0;\n}\n\n \nstatic int dfll_init(struct tegra_dfll *td)\n{\n\tint ret;\n\n\ttd->ref_rate = clk_get_rate(td->ref_clk);\n\tif (td->ref_rate != REF_CLOCK_RATE) {\n\t\tdev_err(td->dev, \"unexpected ref clk rate %lu, expecting %lu\",\n\t\t\ttd->ref_rate, REF_CLOCK_RATE);\n\t\treturn -EINVAL;\n\t}\n\n\treset_control_deassert(td->dfll_rst);\n\treset_control_deassert(td->dvco_rst);\n\n\tret = clk_prepare(td->ref_clk);\n\tif (ret) {\n\t\tdev_err(td->dev, \"failed to prepare ref_clk\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare(td->soc_clk);\n\tif (ret) {\n\t\tdev_err(td->dev, \"failed to prepare soc_clk\\n\");\n\t\tgoto di_err1;\n\t}\n\n\tret = clk_prepare(td->i2c_clk);\n\tif (ret) {\n\t\tdev_err(td->dev, \"failed to prepare i2c_clk\\n\");\n\t\tgoto di_err2;\n\t}\n\n\ttd->last_unrounded_rate = 0;\n\n\tpm_runtime_enable(td->dev);\n\tpm_runtime_get_sync(td->dev);\n\n\tdfll_set_mode(td, DFLL_DISABLED);\n\tdfll_set_default_params(td);\n\n\tif (td->soc->init_clock_trimmers)\n\t\ttd->soc->init_clock_trimmers();\n\n\tdfll_set_open_loop_config(td);\n\n\tdfll_init_out_if(td);\n\n\tpm_runtime_put_sync(td->dev);\n\n\treturn 0;\n\ndi_err2:\n\tclk_unprepare(td->soc_clk);\ndi_err1:\n\tclk_unprepare(td->ref_clk);\n\n\treset_control_assert(td->dvco_rst);\n\treset_control_assert(td->dfll_rst);\n\n\treturn ret;\n}\n\n \nint tegra_dfll_suspend(struct device *dev)\n{\n\tstruct tegra_dfll *td = dev_get_drvdata(dev);\n\n\tif (dfll_is_running(td)) {\n\t\tdev_err(td->dev, \"DFLL still enabled while suspending\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treset_control_assert(td->dvco_rst);\n\treset_control_assert(td->dfll_rst);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tegra_dfll_suspend);\n\n \nint tegra_dfll_resume(struct device *dev)\n{\n\tstruct tegra_dfll *td = dev_get_drvdata(dev);\n\n\treset_control_deassert(td->dfll_rst);\n\treset_control_deassert(td->dvco_rst);\n\n\tpm_runtime_get_sync(td->dev);\n\n\tdfll_set_mode(td, DFLL_DISABLED);\n\tdfll_set_default_params(td);\n\n\tif (td->soc->init_clock_trimmers)\n\t\ttd->soc->init_clock_trimmers();\n\n\tdfll_set_open_loop_config(td);\n\n\tdfll_init_out_if(td);\n\n\tpm_runtime_put_sync(td->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tegra_dfll_resume);\n\n \n\n \nstatic int find_vdd_map_entry_exact(struct tegra_dfll *td, int uV)\n{\n\tint i, n_voltages, reg_uV,reg_volt_id, align_step;\n\n\tif (WARN_ON(td->pmu_if == TEGRA_DFLL_PMU_PWM))\n\t\treturn -EINVAL;\n\n\talign_step = uV / td->soc->alignment.step_uv;\n\tn_voltages = regulator_count_voltages(td->vdd_reg);\n\tfor (i = 0; i < n_voltages; i++) {\n\t\treg_uV = regulator_list_voltage(td->vdd_reg, i);\n\t\tif (reg_uV < 0)\n\t\t\tbreak;\n\n\t\treg_volt_id = reg_uV / td->soc->alignment.step_uv;\n\n\t\tif (align_step == reg_volt_id)\n\t\t\treturn i;\n\t}\n\n\tdev_err(td->dev, \"no voltage map entry for %d uV\\n\", uV);\n\treturn -EINVAL;\n}\n\n \nstatic int find_vdd_map_entry_min(struct tegra_dfll *td, int uV)\n{\n\tint i, n_voltages, reg_uV, reg_volt_id, align_step;\n\n\tif (WARN_ON(td->pmu_if == TEGRA_DFLL_PMU_PWM))\n\t\treturn -EINVAL;\n\n\talign_step = uV / td->soc->alignment.step_uv;\n\tn_voltages = regulator_count_voltages(td->vdd_reg);\n\tfor (i = 0; i < n_voltages; i++) {\n\t\treg_uV = regulator_list_voltage(td->vdd_reg, i);\n\t\tif (reg_uV < 0)\n\t\t\tbreak;\n\n\t\treg_volt_id = reg_uV / td->soc->alignment.step_uv;\n\n\t\tif (align_step <= reg_volt_id)\n\t\t\treturn i;\n\t}\n\n\tdev_err(td->dev, \"no voltage map entry rounding to %d uV\\n\", uV);\n\treturn -EINVAL;\n}\n\n \nstatic int dfll_build_pwm_lut(struct tegra_dfll *td, unsigned long v_max)\n{\n\tint i;\n\tunsigned long rate, reg_volt;\n\tu8 lut_bottom = MAX_DFLL_VOLTAGES;\n\tint v_min = td->soc->cvb->min_millivolts * 1000;\n\n\tfor (i = 0; i < MAX_DFLL_VOLTAGES; i++) {\n\t\treg_volt = td->lut_uv[i];\n\n\t\t \n\t\treg_volt = (reg_volt / 1000) * 1000;\n\t\tif (reg_volt > v_max)\n\t\t\tbreak;\n\n\t\ttd->lut[i] = i;\n\t\tif ((lut_bottom == MAX_DFLL_VOLTAGES) && (reg_volt >= v_min))\n\t\t\tlut_bottom = i;\n\t}\n\n\t \n\ttd->lut_size = i;\n\tif ((lut_bottom == MAX_DFLL_VOLTAGES) ||\n\t    (lut_bottom + 1 >= td->lut_size)) {\n\t\tdev_err(td->dev, \"no voltage above DFLL minimum %d mV\\n\",\n\t\t\ttd->soc->cvb->min_millivolts);\n\t\treturn -EINVAL;\n\t}\n\ttd->lut_bottom = lut_bottom;\n\n\t \n\trate = get_dvco_rate_below(td, td->lut_bottom);\n\tif (!rate) {\n\t\tdev_err(td->dev, \"no opp below DFLL minimum voltage %d mV\\n\",\n\t\t\ttd->soc->cvb->min_millivolts);\n\t\treturn -EINVAL;\n\t}\n\ttd->dvco_rate_min = rate;\n\n\treturn 0;\n}\n\n \nstatic int dfll_build_i2c_lut(struct tegra_dfll *td, unsigned long v_max)\n{\n\tunsigned long rate, v, v_opp;\n\tint ret = -EINVAL;\n\tint j, selector, lut;\n\n\tv = td->soc->cvb->min_millivolts * 1000;\n\tlut = find_vdd_map_entry_exact(td, v);\n\tif (lut < 0)\n\t\tgoto out;\n\ttd->lut[0] = lut;\n\ttd->lut_bottom = 0;\n\n\tfor (j = 1, rate = 0; ; rate++) {\n\t\tstruct dev_pm_opp *opp;\n\n\t\topp = dev_pm_opp_find_freq_ceil(td->soc->dev, &rate);\n\t\tif (IS_ERR(opp))\n\t\t\tbreak;\n\t\tv_opp = dev_pm_opp_get_voltage(opp);\n\n\t\tif (v_opp <= td->soc->cvb->min_millivolts * 1000)\n\t\t\ttd->dvco_rate_min = dev_pm_opp_get_freq(opp);\n\n\t\tdev_pm_opp_put(opp);\n\n\t\tfor (;;) {\n\t\t\tv += max(1UL, (v_max - v) / (MAX_DFLL_VOLTAGES - j));\n\t\t\tif (v >= v_opp)\n\t\t\t\tbreak;\n\n\t\t\tselector = find_vdd_map_entry_min(td, v);\n\t\t\tif (selector < 0)\n\t\t\t\tgoto out;\n\t\t\tif (selector != td->lut[j - 1])\n\t\t\t\ttd->lut[j++] = selector;\n\t\t}\n\n\t\tv = (j == MAX_DFLL_VOLTAGES - 1) ? v_max : v_opp;\n\t\tselector = find_vdd_map_entry_exact(td, v);\n\t\tif (selector < 0)\n\t\t\tgoto out;\n\t\tif (selector != td->lut[j - 1])\n\t\t\ttd->lut[j++] = selector;\n\n\t\tif (v >= v_max)\n\t\t\tbreak;\n\t}\n\ttd->lut_size = j;\n\n\tif (!td->dvco_rate_min)\n\t\tdev_err(td->dev, \"no opp above DFLL minimum voltage %d mV\\n\",\n\t\t\ttd->soc->cvb->min_millivolts);\n\telse {\n\t\tret = 0;\n\t\tfor (j = 0; j < td->lut_size; j++)\n\t\t\ttd->lut_uv[j] =\n\t\t\t\tregulator_list_voltage(td->vdd_reg,\n\t\t\t\t\t\t       td->lut[j]);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int dfll_build_lut(struct tegra_dfll *td)\n{\n\tunsigned long rate, v_max;\n\tstruct dev_pm_opp *opp;\n\n\trate = ULONG_MAX;\n\topp = dev_pm_opp_find_freq_floor(td->soc->dev, &rate);\n\tif (IS_ERR(opp)) {\n\t\tdev_err(td->dev, \"couldn't get vmax opp, empty opp table?\\n\");\n\t\treturn -EINVAL;\n\t}\n\tv_max = dev_pm_opp_get_voltage(opp);\n\tdev_pm_opp_put(opp);\n\n\tif (td->pmu_if == TEGRA_DFLL_PMU_PWM)\n\t\treturn dfll_build_pwm_lut(td, v_max);\n\telse\n\t\treturn dfll_build_i2c_lut(td, v_max);\n}\n\n \nstatic bool read_dt_param(struct tegra_dfll *td, const char *param, u32 *dest)\n{\n\tint err = of_property_read_u32(td->dev->of_node, param, dest);\n\n\tif (err < 0) {\n\t\tdev_err(td->dev, \"failed to read DT parameter %s: %d\\n\",\n\t\t\tparam, err);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic int dfll_fetch_i2c_params(struct tegra_dfll *td)\n{\n\tstruct regmap *regmap;\n\tstruct device *i2c_dev;\n\tstruct i2c_client *i2c_client;\n\tint vsel_reg, vsel_mask;\n\tint ret;\n\n\tif (!read_dt_param(td, \"nvidia,i2c-fs-rate\", &td->i2c_fs_rate))\n\t\treturn -EINVAL;\n\n\tregmap = regulator_get_regmap(td->vdd_reg);\n\ti2c_dev = regmap_get_device(regmap);\n\ti2c_client = to_i2c_client(i2c_dev);\n\n\ttd->i2c_slave_addr = i2c_client->addr;\n\n\tret = regulator_get_hardware_vsel_register(td->vdd_reg,\n\t\t\t\t\t\t   &vsel_reg,\n\t\t\t\t\t\t   &vsel_mask);\n\tif (ret < 0) {\n\t\tdev_err(td->dev,\n\t\t\t\"regulator unsuitable for DFLL I2C operation\\n\");\n\t\treturn -EINVAL;\n\t}\n\ttd->i2c_reg = vsel_reg;\n\n\treturn 0;\n}\n\nstatic int dfll_fetch_pwm_params(struct tegra_dfll *td)\n{\n\tint ret, i;\n\tu32 pwm_period;\n\n\tif (!td->soc->alignment.step_uv || !td->soc->alignment.offset_uv) {\n\t\tdev_err(td->dev,\n\t\t\t\"Missing step or alignment info for PWM regulator\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_DFLL_VOLTAGES; i++)\n\t\ttd->lut_uv[i] = td->soc->alignment.offset_uv +\n\t\t\t\ti * td->soc->alignment.step_uv;\n\n\tret = read_dt_param(td, \"nvidia,pwm-tristate-microvolts\",\n\t\t\t    &td->reg_init_uV);\n\tif (!ret) {\n\t\tdev_err(td->dev, \"couldn't get initialized voltage\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = read_dt_param(td, \"nvidia,pwm-period-nanoseconds\", &pwm_period);\n\tif (!ret) {\n\t\tdev_err(td->dev, \"couldn't get PWM period\\n\");\n\t\treturn -EINVAL;\n\t}\n\ttd->pwm_rate = (NSEC_PER_SEC / pwm_period) * (MAX_DFLL_VOLTAGES - 1);\n\n\ttd->pwm_pin = devm_pinctrl_get(td->dev);\n\tif (IS_ERR(td->pwm_pin)) {\n\t\tdev_err(td->dev, \"DT: missing pinctrl device\\n\");\n\t\treturn PTR_ERR(td->pwm_pin);\n\t}\n\n\ttd->pwm_enable_state = pinctrl_lookup_state(td->pwm_pin,\n\t\t\t\t\t\t    \"dvfs_pwm_enable\");\n\tif (IS_ERR(td->pwm_enable_state)) {\n\t\tdev_err(td->dev, \"DT: missing pwm enabled state\\n\");\n\t\treturn PTR_ERR(td->pwm_enable_state);\n\t}\n\n\ttd->pwm_disable_state = pinctrl_lookup_state(td->pwm_pin,\n\t\t\t\t\t\t     \"dvfs_pwm_disable\");\n\tif (IS_ERR(td->pwm_disable_state)) {\n\t\tdev_err(td->dev, \"DT: missing pwm disabled state\\n\");\n\t\treturn PTR_ERR(td->pwm_disable_state);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dfll_fetch_common_params(struct tegra_dfll *td)\n{\n\tbool ok = true;\n\n\tok &= read_dt_param(td, \"nvidia,droop-ctrl\", &td->droop_ctrl);\n\tok &= read_dt_param(td, \"nvidia,sample-rate\", &td->sample_rate);\n\tok &= read_dt_param(td, \"nvidia,force-mode\", &td->force_mode);\n\tok &= read_dt_param(td, \"nvidia,cf\", &td->cf);\n\tok &= read_dt_param(td, \"nvidia,ci\", &td->ci);\n\tok &= read_dt_param(td, \"nvidia,cg\", &td->cg);\n\ttd->cg_scale = of_property_read_bool(td->dev->of_node,\n\t\t\t\t\t     \"nvidia,cg-scale\");\n\n\tif (of_property_read_string(td->dev->of_node, \"clock-output-names\",\n\t\t\t\t    &td->output_clock_name)) {\n\t\tdev_err(td->dev, \"missing clock-output-names property\\n\");\n\t\tok = false;\n\t}\n\n\treturn ok ? 0 : -EINVAL;\n}\n\n \n\n \nint tegra_dfll_register(struct platform_device *pdev,\n\t\t\tstruct tegra_dfll_soc_data *soc)\n{\n\tstruct resource *mem;\n\tstruct tegra_dfll *td;\n\tint ret;\n\n\tif (!soc) {\n\t\tdev_err(&pdev->dev, \"no tegra_dfll_soc_data provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttd = devm_kzalloc(&pdev->dev, sizeof(*td), GFP_KERNEL);\n\tif (!td)\n\t\treturn -ENOMEM;\n\ttd->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, td);\n\n\ttd->soc = soc;\n\n\ttd->dfll_rst = devm_reset_control_get_optional(td->dev, \"dfll\");\n\tif (IS_ERR(td->dfll_rst)) {\n\t\tdev_err(td->dev, \"couldn't get dfll reset\\n\");\n\t\treturn PTR_ERR(td->dfll_rst);\n\t}\n\n\ttd->dvco_rst = devm_reset_control_get(td->dev, \"dvco\");\n\tif (IS_ERR(td->dvco_rst)) {\n\t\tdev_err(td->dev, \"couldn't get dvco reset\\n\");\n\t\treturn PTR_ERR(td->dvco_rst);\n\t}\n\n\tret = dfll_fetch_common_params(td);\n\tif (ret) {\n\t\tdev_err(td->dev, \"couldn't parse device tree parameters\\n\");\n\t\treturn ret;\n\t}\n\n\tif (of_property_read_bool(td->dev->of_node, \"nvidia,pwm-to-pmic\")) {\n\t\ttd->pmu_if = TEGRA_DFLL_PMU_PWM;\n\t\tret = dfll_fetch_pwm_params(td);\n\t} else  {\n\t\ttd->vdd_reg = devm_regulator_get(td->dev, \"vdd-cpu\");\n\t\tif (IS_ERR(td->vdd_reg)) {\n\t\t\tdev_err(td->dev, \"couldn't get vdd_cpu regulator\\n\");\n\t\t\treturn PTR_ERR(td->vdd_reg);\n\t\t}\n\t\ttd->pmu_if = TEGRA_DFLL_PMU_I2C;\n\t\tret = dfll_fetch_i2c_params(td);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tret = dfll_build_lut(td);\n\tif (ret) {\n\t\tdev_err(td->dev, \"couldn't build LUT\\n\");\n\t\treturn ret;\n\t}\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!mem) {\n\t\tdev_err(td->dev, \"no control register resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttd->base = devm_ioremap(td->dev, mem->start, resource_size(mem));\n\tif (!td->base) {\n\t\tdev_err(td->dev, \"couldn't ioremap DFLL control registers\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!mem) {\n\t\tdev_err(td->dev, \"no i2c_base resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttd->i2c_base = devm_ioremap(td->dev, mem->start, resource_size(mem));\n\tif (!td->i2c_base) {\n\t\tdev_err(td->dev, \"couldn't ioremap i2c_base resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 2);\n\tif (!mem) {\n\t\tdev_err(td->dev, \"no i2c_controller_base resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttd->i2c_controller_base = devm_ioremap(td->dev, mem->start,\n\t\t\t\t\t       resource_size(mem));\n\tif (!td->i2c_controller_base) {\n\t\tdev_err(td->dev,\n\t\t\t\"couldn't ioremap i2c_controller_base resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 3);\n\tif (!mem) {\n\t\tdev_err(td->dev, \"no lut_base resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttd->lut_base = devm_ioremap(td->dev, mem->start, resource_size(mem));\n\tif (!td->lut_base) {\n\t\tdev_err(td->dev,\n\t\t\t\"couldn't ioremap lut_base resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = dfll_init_clks(td);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"DFLL clock init error\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = dfll_init(td);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dfll_register_clk(td);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"DFLL clk registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdfll_debug_init(td);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tegra_dfll_register);\n\n \nstruct tegra_dfll_soc_data *tegra_dfll_unregister(struct platform_device *pdev)\n{\n\tstruct tegra_dfll *td = platform_get_drvdata(pdev);\n\n\t \n\tif (td->mode != DFLL_DISABLED) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"must disable DFLL before removing driver\\n\");\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tdebugfs_remove_recursive(td->debugfs_dir);\n\n\tdfll_unregister_clk(td);\n\tpm_runtime_disable(&pdev->dev);\n\n\tclk_unprepare(td->ref_clk);\n\tclk_unprepare(td->soc_clk);\n\tclk_unprepare(td->i2c_clk);\n\n\treset_control_assert(td->dvco_rst);\n\treset_control_assert(td->dfll_rst);\n\n\treturn td->soc;\n}\nEXPORT_SYMBOL(tegra_dfll_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}