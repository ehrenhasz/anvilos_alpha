{
  "module_name": "clk-tegra210-emc.c",
  "hash_id": "683e2b3cb8e3f061c4e67c0058c2a421e63a678bf5a403ca818baddd572cb3e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-tegra210-emc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clk/tegra.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\n#define CLK_SOURCE_EMC 0x19c\n#define  CLK_SOURCE_EMC_2X_CLK_SRC GENMASK(31, 29)\n#define  CLK_SOURCE_EMC_MC_EMC_SAME_FREQ BIT(16)\n#define  CLK_SOURCE_EMC_2X_CLK_DIVISOR GENMASK(7, 0)\n\n#define CLK_SRC_PLLM 0\n#define CLK_SRC_PLLC 1\n#define CLK_SRC_PLLP 2\n#define CLK_SRC_CLK_M 3\n#define CLK_SRC_PLLM_UD 4\n#define CLK_SRC_PLLMB_UD 5\n#define CLK_SRC_PLLMB 6\n#define CLK_SRC_PLLP_UD 7\n\nstruct tegra210_clk_emc {\n\tstruct clk_hw hw;\n\tvoid __iomem *regs;\n\n\tstruct tegra210_clk_emc_provider *provider;\n\n\tstruct clk *parents[8];\n};\n\nstatic inline struct tegra210_clk_emc *\nto_tegra210_clk_emc(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct tegra210_clk_emc, hw);\n}\n\nstatic const char *tegra210_clk_emc_parents[] = {\n\t\"pll_m\", \"pll_c\", \"pll_p\", \"clk_m\", \"pll_m_ud\", \"pll_mb_ud\",\n\t\"pll_mb\", \"pll_p_ud\",\n};\n\nstatic u8 tegra210_clk_emc_get_parent(struct clk_hw *hw)\n{\n\tstruct tegra210_clk_emc *emc = to_tegra210_clk_emc(hw);\n\tu32 value;\n\tu8 src;\n\n\tvalue = readl_relaxed(emc->regs + CLK_SOURCE_EMC);\n\tsrc = FIELD_GET(CLK_SOURCE_EMC_2X_CLK_SRC, value);\n\n\treturn src;\n}\n\nstatic unsigned long tegra210_clk_emc_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct tegra210_clk_emc *emc = to_tegra210_clk_emc(hw);\n\tu32 value, div;\n\n\t \n\tparent_rate = clk_hw_get_rate(clk_hw_get_parent(hw));\n\n\tvalue = readl_relaxed(emc->regs + CLK_SOURCE_EMC);\n\n\tdiv = FIELD_GET(CLK_SOURCE_EMC_2X_CLK_DIVISOR, value);\n\tdiv += 2;\n\n\treturn DIV_ROUND_UP(parent_rate * 2, div);\n}\n\nstatic long tegra210_clk_emc_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\tunsigned long *prate)\n{\n\tstruct tegra210_clk_emc *emc = to_tegra210_clk_emc(hw);\n\tstruct tegra210_clk_emc_provider *provider = emc->provider;\n\tunsigned int i;\n\n\tif (!provider || !provider->configs || provider->num_configs == 0)\n\t\treturn clk_hw_get_rate(hw);\n\n\tfor (i = 0; i < provider->num_configs; i++) {\n\t\tif (provider->configs[i].rate >= rate)\n\t\t\treturn provider->configs[i].rate;\n\t}\n\n\treturn provider->configs[i - 1].rate;\n}\n\nstatic struct clk *tegra210_clk_emc_find_parent(struct tegra210_clk_emc *emc,\n\t\t\t\t\t\tu8 index)\n{\n\tstruct clk_hw *parent = clk_hw_get_parent_by_index(&emc->hw, index);\n\tconst char *name = clk_hw_get_name(parent);\n\n\t \n\n\treturn __clk_lookup(name);\n}\n\nstatic int tegra210_clk_emc_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct tegra210_clk_emc *emc = to_tegra210_clk_emc(hw);\n\tstruct tegra210_clk_emc_provider *provider = emc->provider;\n\tstruct tegra210_clk_emc_config *config;\n\tstruct device *dev = provider->dev;\n\tstruct clk_hw *old, *new, *parent;\n\tu8 old_idx, new_idx, index;\n\tstruct clk *clk;\n\tunsigned int i;\n\tint err;\n\n\tif (!provider->configs || provider->num_configs == 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < provider->num_configs; i++) {\n\t\tif (provider->configs[i].rate >= rate) {\n\t\t\tconfig = &provider->configs[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == provider->num_configs)\n\t\tconfig = &provider->configs[i - 1];\n\n\told_idx = tegra210_clk_emc_get_parent(hw);\n\tnew_idx = FIELD_GET(CLK_SOURCE_EMC_2X_CLK_SRC, config->value);\n\n\told = clk_hw_get_parent_by_index(hw, old_idx);\n\tnew = clk_hw_get_parent_by_index(hw, new_idx);\n\n\t \n\tif (config->parent_rate != clk_hw_get_rate(old)) {\n\t\t \n\t\tif (new_idx == old_idx) {\n\t\t\t \n\t\t\tswitch (new_idx) {\n\t\t\tcase CLK_SRC_PLLM:\n\t\t\t\tnew_idx = CLK_SRC_PLLMB;\n\t\t\t\tbreak;\n\n\t\t\tcase CLK_SRC_PLLM_UD:\n\t\t\t\tnew_idx = CLK_SRC_PLLMB_UD;\n\t\t\t\tbreak;\n\n\t\t\tcase CLK_SRC_PLLMB_UD:\n\t\t\t\tnew_idx = CLK_SRC_PLLM_UD;\n\t\t\t\tbreak;\n\n\t\t\tcase CLK_SRC_PLLMB:\n\t\t\t\tnew_idx = CLK_SRC_PLLM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (WARN_ON(new_idx == old_idx))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnew = clk_hw_get_parent_by_index(hw, new_idx);\n\t\t}\n\n\t\tindex = new_idx;\n\t\tparent = new;\n\t} else {\n\t\tindex = old_idx;\n\t\tparent = old;\n\t}\n\n\tclk = tegra210_clk_emc_find_parent(emc, index);\n\tif (IS_ERR(clk)) {\n\t\terr = PTR_ERR(clk);\n\t\tdev_err(dev, \"failed to get parent clock for index %u: %d\\n\",\n\t\t\tindex, err);\n\t\treturn err;\n\t}\n\n\t \n\tif (clk_get_rate(clk) != config->parent_rate) {\n\t\terr = clk_set_rate(clk, config->parent_rate);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"failed to set rate %lu Hz for %pC: %d\\n\",\n\t\t\t\tconfig->parent_rate, clk, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (parent != old) {\n\t\terr = clk_prepare_enable(clk);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"failed to enable parent clock %pC: %d\\n\",\n\t\t\t\tclk, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tconfig->value &= ~CLK_SOURCE_EMC_2X_CLK_SRC;\n\tconfig->value |= FIELD_PREP(CLK_SOURCE_EMC_2X_CLK_SRC, index);\n\n\t \n\terr = provider->set_rate(dev, config);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to set EMC rate to %lu Hz: %d\\n\", rate,\n\t\t\terr);\n\n\t\t \n\t\tif (parent != old)\n\t\t\tclk_disable_unprepare(clk);\n\n\t\treturn err;\n\t}\n\n\t \n\tif (parent != old) {\n\t\tclk = tegra210_clk_emc_find_parent(emc, old_idx);\n\t\tif (IS_ERR(clk)) {\n\t\t\terr = PTR_ERR(clk);\n\t\t\tdev_err(dev,\n\t\t\t\t\"failed to get parent clock for index %u: %d\\n\",\n\t\t\t\told_idx, err);\n\t\t\treturn err;\n\t\t}\n\n\t\tclk_hw_reparent(hw, parent);\n\t\tclk_disable_unprepare(clk);\n\t}\n\n\treturn err;\n}\n\nstatic const struct clk_ops tegra210_clk_emc_ops = {\n\t.get_parent = tegra210_clk_emc_get_parent,\n\t.recalc_rate = tegra210_clk_emc_recalc_rate,\n\t.round_rate = tegra210_clk_emc_round_rate,\n\t.set_rate = tegra210_clk_emc_set_rate,\n};\n\nstruct clk *tegra210_clk_register_emc(struct device_node *np,\n\t\t\t\t      void __iomem *regs)\n{\n\tstruct tegra210_clk_emc *emc;\n\tstruct clk_init_data init;\n\tstruct clk *clk;\n\n\temc = kzalloc(sizeof(*emc), GFP_KERNEL);\n\tif (!emc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\temc->regs = regs;\n\n\tinit.name = \"emc\";\n\tinit.ops = &tegra210_clk_emc_ops;\n\tinit.flags = CLK_IS_CRITICAL | CLK_GET_RATE_NOCACHE;\n\tinit.parent_names = tegra210_clk_emc_parents;\n\tinit.num_parents = ARRAY_SIZE(tegra210_clk_emc_parents);\n\temc->hw.init = &init;\n\n\tclk = clk_register(NULL, &emc->hw);\n\tif (IS_ERR(clk)) {\n\t\tkfree(emc);\n\t\treturn clk;\n\t}\n\n\treturn clk;\n}\n\nint tegra210_clk_emc_attach(struct clk *clk,\n\t\t\t    struct tegra210_clk_emc_provider *provider)\n{\n\tstruct clk_hw *hw = __clk_get_hw(clk);\n\tstruct tegra210_clk_emc *emc = to_tegra210_clk_emc(hw);\n\tstruct device *dev = provider->dev;\n\tunsigned int i;\n\tint err;\n\n\tif (!try_module_get(provider->owner))\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < provider->num_configs; i++) {\n\t\tstruct tegra210_clk_emc_config *config = &provider->configs[i];\n\t\tstruct clk_hw *parent;\n\t\tbool same_freq;\n\t\tu8 div, src;\n\n\t\tdiv = FIELD_GET(CLK_SOURCE_EMC_2X_CLK_DIVISOR, config->value);\n\t\tsrc = FIELD_GET(CLK_SOURCE_EMC_2X_CLK_SRC, config->value);\n\n\t\t \n\t\tif (div & 0x1) {\n\t\t\tdev_err(dev, \"invalid odd divider %u for rate %lu Hz\\n\",\n\t\t\t\tdiv, config->rate);\n\t\t\terr = -EINVAL;\n\t\t\tgoto put;\n\t\t}\n\n\t\tsame_freq = config->value & CLK_SOURCE_EMC_MC_EMC_SAME_FREQ;\n\n\t\tif (same_freq != config->same_freq) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"ambiguous EMC to MC ratio for rate %lu Hz\\n\",\n\t\t\t\tconfig->rate);\n\t\t\terr = -EINVAL;\n\t\t\tgoto put;\n\t\t}\n\n\t\tparent = clk_hw_get_parent_by_index(hw, src);\n\t\tconfig->parent = src;\n\n\t\tif (src == CLK_SRC_PLLM || src == CLK_SRC_PLLM_UD) {\n\t\t\tconfig->parent_rate = config->rate * (1 + div / 2);\n\t\t} else {\n\t\t\tunsigned long rate = config->rate * (1 + div / 2);\n\n\t\t\tconfig->parent_rate = clk_hw_get_rate(parent);\n\n\t\t\tif (config->parent_rate != rate) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"rate %lu Hz does not match input\\n\",\n\t\t\t\t\tconfig->rate);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto put;\n\t\t\t}\n\t\t}\n\t}\n\n\temc->provider = provider;\n\n\treturn 0;\n\nput:\n\tmodule_put(provider->owner);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(tegra210_clk_emc_attach);\n\nvoid tegra210_clk_emc_detach(struct clk *clk)\n{\n\tstruct tegra210_clk_emc *emc = to_tegra210_clk_emc(__clk_get_hw(clk));\n\n\tmodule_put(emc->provider->owner);\n\temc->provider = NULL;\n}\nEXPORT_SYMBOL_GPL(tegra210_clk_emc_detach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}