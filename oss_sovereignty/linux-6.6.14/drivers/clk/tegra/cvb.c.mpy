{
  "module_name": "cvb.c",
  "hash_id": "2322b53b72b5a5b811a7b82d69a682d642887de78ee55b0cb73f97c0b844518f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/cvb.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/pm_opp.h>\n\n#include \"cvb.h\"\n\n \nstatic inline int get_cvb_voltage(int speedo, int s_scale,\n\t\t\t\t  const struct cvb_coefficients *cvb)\n{\n\tint mv;\n\n\t \n\tmv = DIV_ROUND_CLOSEST(cvb->c2 * speedo, s_scale);\n\tmv = DIV_ROUND_CLOSEST((mv + cvb->c1) * speedo, s_scale) + cvb->c0;\n\treturn mv;\n}\n\nstatic int round_cvb_voltage(int mv, int v_scale,\n\t\t\t     const struct rail_alignment *align)\n{\n\t \n\tint uv;\n\tint step = (align->step_uv ? : 1000) * v_scale;\n\tint offset = align->offset_uv * v_scale;\n\n\tuv = max(mv * 1000, offset) - offset;\n\tuv = DIV_ROUND_UP(uv, step) * align->step_uv + align->offset_uv;\n\treturn uv / 1000;\n}\n\nenum {\n\tDOWN,\n\tUP\n};\n\nstatic int round_voltage(int mv, const struct rail_alignment *align, int up)\n{\n\tif (align->step_uv) {\n\t\tint uv;\n\n\t\tuv = max(mv * 1000, align->offset_uv) - align->offset_uv;\n\t\tuv = (uv + (up ? align->step_uv - 1 : 0)) / align->step_uv;\n\t\treturn (uv * align->step_uv + align->offset_uv) / 1000;\n\t}\n\treturn mv;\n}\n\nstatic int build_opp_table(struct device *dev, const struct cvb_table *table,\n\t\t\t   struct rail_alignment *align,\n\t\t\t   int speedo_value, unsigned long max_freq)\n{\n\tint i, ret, dfll_mv, min_mv, max_mv;\n\n\tmin_mv = round_voltage(table->min_millivolts, align, UP);\n\tmax_mv = round_voltage(table->max_millivolts, align, DOWN);\n\n\tfor (i = 0; i < MAX_DVFS_FREQS; i++) {\n\t\tconst struct cvb_table_freq_entry *entry = &table->entries[i];\n\n\t\tif (!entry->freq || (entry->freq > max_freq))\n\t\t\tbreak;\n\n\t\tdfll_mv = get_cvb_voltage(speedo_value, table->speedo_scale,\n\t\t\t\t\t  &entry->coefficients);\n\t\tdfll_mv = round_cvb_voltage(dfll_mv, table->voltage_scale,\n\t\t\t\t\t    align);\n\t\tdfll_mv = clamp(dfll_mv, min_mv, max_mv);\n\n\t\tret = dev_pm_opp_add(dev, entry->freq, dfll_mv * 1000);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nconst struct cvb_table *\ntegra_cvb_add_opp_table(struct device *dev, const struct cvb_table *tables,\n\t\t\tsize_t count, struct rail_alignment *align,\n\t\t\tint process_id, int speedo_id, int speedo_value,\n\t\t\tunsigned long max_freq)\n{\n\tsize_t i;\n\tint ret;\n\n\tfor (i = 0; i < count; i++) {\n\t\tconst struct cvb_table *table = &tables[i];\n\n\t\tif (table->speedo_id != -1 && table->speedo_id != speedo_id)\n\t\t\tcontinue;\n\n\t\tif (table->process_id != -1 && table->process_id != process_id)\n\t\t\tcontinue;\n\n\t\tret = build_opp_table(dev, table, align, speedo_value,\n\t\t\t\t      max_freq);\n\t\treturn ret ? ERR_PTR(ret) : table;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nvoid tegra_cvb_remove_opp_table(struct device *dev,\n\t\t\t\tconst struct cvb_table *table,\n\t\t\t\tunsigned long max_freq)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < MAX_DVFS_FREQS; i++) {\n\t\tconst struct cvb_table_freq_entry *entry = &table->entries[i];\n\n\t\tif (!entry->freq || (entry->freq > max_freq))\n\t\t\tbreak;\n\n\t\tdev_pm_opp_remove(dev, entry->freq);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}