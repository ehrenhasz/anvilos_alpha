{
  "module_name": "clk-tegra20.c",
  "hash_id": "f0a0ba4ead893ee0c48be56930e55bb0ae309f28aca8a0cb66b749e2f643d5aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/tegra/clk-tegra20.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/clk/tegra.h>\n#include <linux/delay.h>\n#include <dt-bindings/clock/tegra20-car.h>\n\n#include \"clk.h\"\n#include \"clk-id.h\"\n\n#define MISC_CLK_ENB 0x48\n\n#define OSC_CTRL 0x50\n#define OSC_CTRL_OSC_FREQ_MASK (3u<<30)\n#define OSC_CTRL_OSC_FREQ_13MHZ (0u<<30)\n#define OSC_CTRL_OSC_FREQ_19_2MHZ (1u<<30)\n#define OSC_CTRL_OSC_FREQ_12MHZ (2u<<30)\n#define OSC_CTRL_OSC_FREQ_26MHZ (3u<<30)\n#define OSC_CTRL_MASK (0x3f2u | OSC_CTRL_OSC_FREQ_MASK)\n\n#define OSC_CTRL_PLL_REF_DIV_MASK\t(3u<<28)\n#define OSC_CTRL_PLL_REF_DIV_1\t\t(0u<<28)\n#define OSC_CTRL_PLL_REF_DIV_2\t\t(1u<<28)\n#define OSC_CTRL_PLL_REF_DIV_4\t\t(2u<<28)\n\n#define OSC_FREQ_DET 0x58\n#define OSC_FREQ_DET_TRIG (1u<<31)\n\n#define OSC_FREQ_DET_STATUS 0x5c\n#define OSC_FREQ_DET_BUSYu (1<<31)\n#define OSC_FREQ_DET_CNT_MASK 0xFFFFu\n\n#define TEGRA20_CLK_PERIPH_BANKS\t3\n\n#define PLLS_BASE 0xf0\n#define PLLS_MISC 0xf4\n#define PLLC_BASE 0x80\n#define PLLC_MISC 0x8c\n#define PLLM_BASE 0x90\n#define PLLM_MISC 0x9c\n#define PLLP_BASE 0xa0\n#define PLLP_MISC 0xac\n#define PLLA_BASE 0xb0\n#define PLLA_MISC 0xbc\n#define PLLU_BASE 0xc0\n#define PLLU_MISC 0xcc\n#define PLLD_BASE 0xd0\n#define PLLD_MISC 0xdc\n#define PLLX_BASE 0xe0\n#define PLLX_MISC 0xe4\n#define PLLE_BASE 0xe8\n#define PLLE_MISC 0xec\n\n#define PLL_BASE_LOCK BIT(27)\n#define PLLE_MISC_LOCK BIT(11)\n\n#define PLL_MISC_LOCK_ENABLE 18\n#define PLLDU_MISC_LOCK_ENABLE 22\n#define PLLE_MISC_LOCK_ENABLE 9\n\n#define PLLC_OUT 0x84\n#define PLLM_OUT 0x94\n#define PLLP_OUTA 0xa4\n#define PLLP_OUTB 0xa8\n#define PLLA_OUT 0xb4\n\n#define CCLK_BURST_POLICY 0x20\n#define SUPER_CCLK_DIVIDER 0x24\n#define SCLK_BURST_POLICY 0x28\n#define SUPER_SCLK_DIVIDER 0x2c\n#define CLK_SYSTEM_RATE 0x30\n\n#define CCLK_BURST_POLICY_SHIFT\t28\n#define CCLK_RUN_POLICY_SHIFT\t4\n#define CCLK_IDLE_POLICY_SHIFT\t0\n#define CCLK_IDLE_POLICY\t1\n#define CCLK_RUN_POLICY\t\t2\n#define CCLK_BURST_POLICY_PLLX\t8\n\n#define CLK_SOURCE_I2S1 0x100\n#define CLK_SOURCE_I2S2 0x104\n#define CLK_SOURCE_PWM 0x110\n#define CLK_SOURCE_SPI 0x114\n#define CLK_SOURCE_XIO 0x120\n#define CLK_SOURCE_TWC 0x12c\n#define CLK_SOURCE_IDE 0x144\n#define CLK_SOURCE_HDMI 0x18c\n#define CLK_SOURCE_DISP1 0x138\n#define CLK_SOURCE_DISP2 0x13c\n#define CLK_SOURCE_CSITE 0x1d4\n#define CLK_SOURCE_I2C1 0x124\n#define CLK_SOURCE_I2C2 0x198\n#define CLK_SOURCE_I2C3 0x1b8\n#define CLK_SOURCE_DVC 0x128\n#define CLK_SOURCE_UARTA 0x178\n#define CLK_SOURCE_UARTB 0x17c\n#define CLK_SOURCE_UARTC 0x1a0\n#define CLK_SOURCE_UARTD 0x1c0\n#define CLK_SOURCE_UARTE 0x1c4\n#define CLK_SOURCE_EMC 0x19c\n\n#define AUDIO_SYNC_CLK 0x38\n\n \n#define TEGRA_CLK_RST_CONTROLLER_CLK_CPU_CMPLX\t\t0x4c\n#define TEGRA_CLK_RST_CONTROLLER_RST_CPU_CMPLX_SET\t0x340\n#define TEGRA_CLK_RST_CONTROLLER_RST_CPU_CMPLX_CLR\t0x344\n\n#define CPU_CLOCK(cpu)\t(0x1 << (8 + cpu))\n#define CPU_RESET(cpu)\t(0x1111ul << (cpu))\n\n#ifdef CONFIG_PM_SLEEP\nstatic struct cpu_clk_suspend_context {\n\tu32 pllx_misc;\n\tu32 pllx_base;\n\n\tu32 cpu_burst;\n\tu32 clk_csite_src;\n\tu32 cclk_divider;\n} tegra20_cpu_clk_sctx;\n#endif\n\nstatic void __iomem *clk_base;\nstatic void __iomem *pmc_base;\n\n#define TEGRA_INIT_DATA_MUX(_name, _parents, _offset,\t\\\n\t\t\t    _clk_num, _gate_flags, _clk_id)\t\\\n\tTEGRA_INIT_DATA(_name, NULL, NULL, _parents, _offset,\t\\\n\t\t\t30, 2, 0, 0, 8, 1, TEGRA_DIVIDER_ROUND_UP,\t\\\n\t\t\t_clk_num, \\\n\t\t\t_gate_flags, _clk_id)\n\n#define TEGRA_INIT_DATA_DIV16(_name, _parents, _offset, \\\n\t\t\t      _clk_num, _gate_flags, _clk_id)\t\\\n\tTEGRA_INIT_DATA(_name, NULL, NULL, _parents, _offset,\t\\\n\t\t\t30, 2, 0, 0, 16, 0, TEGRA_DIVIDER_ROUND_UP, \\\n\t\t\t_clk_num, _gate_flags,\t\\\n\t\t\t_clk_id)\n\n#define TEGRA_INIT_DATA_NODIV(_name, _parents, _offset, \\\n\t\t\t      _mux_shift, _mux_width, _clk_num, \\\n\t\t\t      _gate_flags, _clk_id)\t\t\t\\\n\tTEGRA_INIT_DATA(_name, NULL, NULL, _parents, _offset,\t\\\n\t\t\t_mux_shift, _mux_width, 0, 0, 0, 0, 0, \\\n\t\t\t_clk_num, _gate_flags,\t\\\n\t\t\t_clk_id)\n\nstatic struct clk **clks;\n\nstatic struct tegra_clk_pll_freq_table pll_c_freq_table[] = {\n\t{ 12000000, 600000000, 600, 12, 1, 8 },\n\t{ 13000000, 600000000, 600, 13, 1, 8 },\n\t{ 19200000, 600000000, 500, 16, 1, 6 },\n\t{ 26000000, 600000000, 600, 26, 1, 8 },\n\t{        0,         0,   0,  0, 0, 0 },\n};\n\nstatic struct tegra_clk_pll_freq_table pll_m_freq_table[] = {\n\t{ 12000000, 666000000, 666, 12, 1, 8 },\n\t{ 13000000, 666000000, 666, 13, 1, 8 },\n\t{ 19200000, 666000000, 555, 16, 1, 8 },\n\t{ 26000000, 666000000, 666, 26, 1, 8 },\n\t{ 12000000, 600000000, 600, 12, 1, 8 },\n\t{ 13000000, 600000000, 600, 13, 1, 8 },\n\t{ 19200000, 600000000, 375, 12, 1, 6 },\n\t{ 26000000, 600000000, 600, 26, 1, 8 },\n\t{        0,         0,   0,  0, 0, 0 },\n};\n\nstatic struct tegra_clk_pll_freq_table pll_p_freq_table[] = {\n\t{ 12000000, 216000000, 432, 12, 2, 8 },\n\t{ 13000000, 216000000, 432, 13, 2, 8 },\n\t{ 19200000, 216000000,  90,  4, 2, 1 },\n\t{ 26000000, 216000000, 432, 26, 2, 8 },\n\t{ 12000000, 432000000, 432, 12, 1, 8 },\n\t{ 13000000, 432000000, 432, 13, 1, 8 },\n\t{ 19200000, 432000000,  90,  4, 1, 1 },\n\t{ 26000000, 432000000, 432, 26, 1, 8 },\n\t{        0,         0,   0,  0, 0, 0 },\n};\n\nstatic struct tegra_clk_pll_freq_table pll_a_freq_table[] = {\n\t{ 28800000, 56448000, 49, 25, 1, 1 },\n\t{ 28800000, 73728000, 64, 25, 1, 1 },\n\t{ 28800000, 24000000,  5,  6, 1, 1 },\n\t{        0,        0,  0,  0, 0, 0 },\n};\n\nstatic struct tegra_clk_pll_freq_table pll_d_freq_table[] = {\n\t{ 12000000,  216000000,  216, 12, 1,  4 },\n\t{ 13000000,  216000000,  216, 13, 1,  4 },\n\t{ 19200000,  216000000,  135, 12, 1,  3 },\n\t{ 26000000,  216000000,  216, 26, 1,  4 },\n\t{ 12000000,  594000000,  594, 12, 1,  8 },\n\t{ 13000000,  594000000,  594, 13, 1,  8 },\n\t{ 19200000,  594000000,  495, 16, 1,  8 },\n\t{ 26000000,  594000000,  594, 26, 1,  8 },\n\t{ 12000000, 1000000000, 1000, 12, 1, 12 },\n\t{ 13000000, 1000000000, 1000, 13, 1, 12 },\n\t{ 19200000, 1000000000,  625, 12, 1,  8 },\n\t{ 26000000, 1000000000, 1000, 26, 1, 12 },\n\t{        0,          0,    0,  0, 0,  0 },\n};\n\nstatic struct tegra_clk_pll_freq_table pll_u_freq_table[] = {\n\t{ 12000000, 480000000, 960, 12, 1, 0 },\n\t{ 13000000, 480000000, 960, 13, 1, 0 },\n\t{ 19200000, 480000000, 200,  4, 1, 0 },\n\t{ 26000000, 480000000, 960, 26, 1, 0 },\n\t{        0,         0,   0,  0, 0, 0 },\n};\n\nstatic struct tegra_clk_pll_freq_table pll_x_freq_table[] = {\n\t \n\t{ 12000000, 1000000000, 1000, 12, 1, 12 },\n\t{ 13000000, 1000000000, 1000, 13, 1, 12 },\n\t{ 19200000, 1000000000,  625, 12, 1,  8 },\n\t{ 26000000, 1000000000, 1000, 26, 1, 12 },\n\t \n\t{ 12000000,  912000000,  912, 12, 1, 12 },\n\t{ 13000000,  912000000,  912, 13, 1, 12 },\n\t{ 19200000,  912000000,  760, 16, 1,  8 },\n\t{ 26000000,  912000000,  912, 26, 1, 12 },\n\t \n\t{ 12000000,  816000000,  816, 12, 1, 12 },\n\t{ 13000000,  816000000,  816, 13, 1, 12 },\n\t{ 19200000,  816000000,  680, 16, 1,  8 },\n\t{ 26000000,  816000000,  816, 26, 1, 12 },\n\t \n\t{ 12000000,  760000000,  760, 12, 1, 12 },\n\t{ 13000000,  760000000,  760, 13, 1, 12 },\n\t{ 19200000,  760000000,  950, 24, 1,  8 },\n\t{ 26000000,  760000000,  760, 26, 1, 12 },\n\t \n\t{ 12000000,  750000000,  750, 12, 1, 12 },\n\t{ 13000000,  750000000,  750, 13, 1, 12 },\n\t{ 19200000,  750000000,  625, 16, 1,  8 },\n\t{ 26000000,  750000000,  750, 26, 1, 12 },\n\t \n\t{ 12000000,  608000000,  608, 12, 1, 12 },\n\t{ 13000000,  608000000,  608, 13, 1, 12 },\n\t{ 19200000,  608000000,  380, 12, 1,  8 },\n\t{ 26000000,  608000000,  608, 26, 1, 12 },\n\t \n\t{ 12000000,  456000000,  456, 12, 1, 12 },\n\t{ 13000000,  456000000,  456, 13, 1, 12 },\n\t{ 19200000,  456000000,  380, 16, 1,  8 },\n\t{ 26000000,  456000000,  456, 26, 1, 12 },\n\t \n\t{ 12000000,  312000000,  312, 12, 1, 12 },\n\t{ 13000000,  312000000,  312, 13, 1, 12 },\n\t{ 19200000,  312000000,  260, 16, 1,  8 },\n\t{ 26000000,  312000000,  312, 26, 1, 12 },\n\t{        0,          0,    0,  0, 0,  0 },\n};\n\nstatic const struct pdiv_map plle_p[] = {\n\t{ .pdiv = 1, .hw_val = 1 },\n\t{ .pdiv = 0, .hw_val = 0 },\n};\n\nstatic struct tegra_clk_pll_freq_table pll_e_freq_table[] = {\n\t{ 12000000, 100000000, 200, 24, 1, 0 },\n\t{        0,         0,   0,  0, 0, 0 },\n};\n\n \nstatic struct tegra_clk_pll_params pll_c_params = {\n\t.input_min = 2000000,\n\t.input_max = 31000000,\n\t.cf_min = 1000000,\n\t.cf_max = 6000000,\n\t.vco_min = 20000000,\n\t.vco_max = 1400000000,\n\t.base_reg = PLLC_BASE,\n\t.misc_reg = PLLC_MISC,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_enable_bit_idx = PLL_MISC_LOCK_ENABLE,\n\t.lock_delay = 300,\n\t.freq_table = pll_c_freq_table,\n\t.flags = TEGRA_PLL_HAS_CPCON | TEGRA_PLL_HAS_LOCK_ENABLE,\n};\n\nstatic struct tegra_clk_pll_params pll_m_params = {\n\t.input_min = 2000000,\n\t.input_max = 31000000,\n\t.cf_min = 1000000,\n\t.cf_max = 6000000,\n\t.vco_min = 20000000,\n\t.vco_max = 1200000000,\n\t.base_reg = PLLM_BASE,\n\t.misc_reg = PLLM_MISC,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_enable_bit_idx = PLL_MISC_LOCK_ENABLE,\n\t.lock_delay = 300,\n\t.freq_table = pll_m_freq_table,\n\t.flags = TEGRA_PLL_HAS_CPCON | TEGRA_PLL_HAS_LOCK_ENABLE,\n};\n\nstatic struct tegra_clk_pll_params pll_p_params = {\n\t.input_min = 2000000,\n\t.input_max = 31000000,\n\t.cf_min = 1000000,\n\t.cf_max = 6000000,\n\t.vco_min = 20000000,\n\t.vco_max = 1400000000,\n\t.base_reg = PLLP_BASE,\n\t.misc_reg = PLLP_MISC,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_enable_bit_idx = PLL_MISC_LOCK_ENABLE,\n\t.lock_delay = 300,\n\t.freq_table = pll_p_freq_table,\n\t.flags = TEGRA_PLL_FIXED | TEGRA_PLL_HAS_CPCON |\n\t\t TEGRA_PLL_HAS_LOCK_ENABLE,\n\t.fixed_rate =  216000000,\n};\n\nstatic struct tegra_clk_pll_params pll_a_params = {\n\t.input_min = 2000000,\n\t.input_max = 31000000,\n\t.cf_min = 1000000,\n\t.cf_max = 6000000,\n\t.vco_min = 20000000,\n\t.vco_max = 1400000000,\n\t.base_reg = PLLA_BASE,\n\t.misc_reg = PLLA_MISC,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_enable_bit_idx = PLL_MISC_LOCK_ENABLE,\n\t.lock_delay = 300,\n\t.freq_table = pll_a_freq_table,\n\t.flags = TEGRA_PLL_HAS_CPCON | TEGRA_PLL_HAS_LOCK_ENABLE,\n};\n\nstatic struct tegra_clk_pll_params pll_d_params = {\n\t.input_min = 2000000,\n\t.input_max = 40000000,\n\t.cf_min = 1000000,\n\t.cf_max = 6000000,\n\t.vco_min = 40000000,\n\t.vco_max = 1000000000,\n\t.base_reg = PLLD_BASE,\n\t.misc_reg = PLLD_MISC,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_enable_bit_idx = PLLDU_MISC_LOCK_ENABLE,\n\t.lock_delay = 1000,\n\t.freq_table = pll_d_freq_table,\n\t.flags = TEGRA_PLL_HAS_CPCON | TEGRA_PLL_HAS_LOCK_ENABLE,\n};\n\nstatic const struct pdiv_map pllu_p[] = {\n\t{ .pdiv = 1, .hw_val = 1 },\n\t{ .pdiv = 2, .hw_val = 0 },\n\t{ .pdiv = 0, .hw_val = 0 },\n};\n\nstatic struct tegra_clk_pll_params pll_u_params = {\n\t.input_min = 2000000,\n\t.input_max = 40000000,\n\t.cf_min = 1000000,\n\t.cf_max = 6000000,\n\t.vco_min = 48000000,\n\t.vco_max = 960000000,\n\t.base_reg = PLLU_BASE,\n\t.misc_reg = PLLU_MISC,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_enable_bit_idx = PLLDU_MISC_LOCK_ENABLE,\n\t.lock_delay = 1000,\n\t.pdiv_tohw = pllu_p,\n\t.freq_table = pll_u_freq_table,\n\t.flags = TEGRA_PLLU | TEGRA_PLL_HAS_CPCON | TEGRA_PLL_HAS_LOCK_ENABLE,\n};\n\nstatic struct tegra_clk_pll_params pll_x_params = {\n\t.input_min = 2000000,\n\t.input_max = 31000000,\n\t.cf_min = 1000000,\n\t.cf_max = 6000000,\n\t.vco_min = 20000000,\n\t.vco_max = 1200000000,\n\t.base_reg = PLLX_BASE,\n\t.misc_reg = PLLX_MISC,\n\t.lock_mask = PLL_BASE_LOCK,\n\t.lock_enable_bit_idx = PLL_MISC_LOCK_ENABLE,\n\t.lock_delay = 300,\n\t.freq_table = pll_x_freq_table,\n\t.flags = TEGRA_PLL_HAS_CPCON | TEGRA_PLL_HAS_LOCK_ENABLE,\n\t.pre_rate_change = tegra_cclk_pre_pllx_rate_change,\n\t.post_rate_change = tegra_cclk_post_pllx_rate_change,\n};\n\nstatic struct tegra_clk_pll_params pll_e_params = {\n\t.input_min = 12000000,\n\t.input_max = 12000000,\n\t.cf_min = 0,\n\t.cf_max = 0,\n\t.vco_min = 0,\n\t.vco_max = 0,\n\t.base_reg = PLLE_BASE,\n\t.misc_reg = PLLE_MISC,\n\t.lock_mask = PLLE_MISC_LOCK,\n\t.lock_enable_bit_idx = PLLE_MISC_LOCK_ENABLE,\n\t.lock_delay = 0,\n\t.pdiv_tohw = plle_p,\n\t.freq_table = pll_e_freq_table,\n\t.flags = TEGRA_PLL_FIXED | TEGRA_PLL_LOCK_MISC |\n\t\t TEGRA_PLL_HAS_LOCK_ENABLE,\n\t.fixed_rate = 100000000,\n};\n\nstatic struct tegra_devclk devclks[] = {\n\t{ .con_id = \"pll_c\", .dt_id = TEGRA20_CLK_PLL_C },\n\t{ .con_id = \"pll_c_out1\", .dt_id = TEGRA20_CLK_PLL_C_OUT1 },\n\t{ .con_id = \"pll_p\", .dt_id = TEGRA20_CLK_PLL_P },\n\t{ .con_id = \"pll_p_out1\", .dt_id = TEGRA20_CLK_PLL_P_OUT1 },\n\t{ .con_id = \"pll_p_out2\", .dt_id = TEGRA20_CLK_PLL_P_OUT2 },\n\t{ .con_id = \"pll_p_out3\", .dt_id = TEGRA20_CLK_PLL_P_OUT3 },\n\t{ .con_id = \"pll_p_out4\", .dt_id = TEGRA20_CLK_PLL_P_OUT4 },\n\t{ .con_id = \"pll_m\", .dt_id = TEGRA20_CLK_PLL_M },\n\t{ .con_id = \"pll_m_out1\", .dt_id = TEGRA20_CLK_PLL_M_OUT1 },\n\t{ .con_id = \"pll_x\", .dt_id = TEGRA20_CLK_PLL_X },\n\t{ .con_id = \"pll_u\", .dt_id = TEGRA20_CLK_PLL_U },\n\t{ .con_id = \"pll_d\", .dt_id = TEGRA20_CLK_PLL_D },\n\t{ .con_id = \"pll_d_out0\", .dt_id = TEGRA20_CLK_PLL_D_OUT0 },\n\t{ .con_id = \"pll_a\", .dt_id = TEGRA20_CLK_PLL_A },\n\t{ .con_id = \"pll_a_out0\", .dt_id = TEGRA20_CLK_PLL_A_OUT0 },\n\t{ .con_id = \"pll_e\", .dt_id = TEGRA20_CLK_PLL_E },\n\t{ .con_id = \"cclk\", .dt_id = TEGRA20_CLK_CCLK },\n\t{ .con_id = \"sclk\", .dt_id = TEGRA20_CLK_SCLK },\n\t{ .con_id = \"hclk\", .dt_id = TEGRA20_CLK_HCLK },\n\t{ .con_id = \"pclk\", .dt_id = TEGRA20_CLK_PCLK },\n\t{ .con_id = \"fuse\", .dt_id = TEGRA20_CLK_FUSE },\n\t{ .con_id = \"twd\", .dt_id = TEGRA20_CLK_TWD },\n\t{ .con_id = \"audio\", .dt_id = TEGRA20_CLK_AUDIO },\n\t{ .con_id = \"audio_2x\", .dt_id = TEGRA20_CLK_AUDIO_2X },\n\t{ .dev_id = \"tegra20-ac97\", .dt_id = TEGRA20_CLK_AC97 },\n\t{ .dev_id = \"tegra-apbdma\", .dt_id = TEGRA20_CLK_APBDMA },\n\t{ .dev_id = \"rtc-tegra\", .dt_id = TEGRA20_CLK_RTC },\n\t{ .dev_id = \"timer\", .dt_id = TEGRA20_CLK_TIMER },\n\t{ .dev_id = \"tegra-kbc\", .dt_id = TEGRA20_CLK_KBC },\n\t{ .con_id = \"csus\", .dev_id =  \"tegra_camera\", .dt_id = TEGRA20_CLK_CSUS },\n\t{ .con_id = \"vcp\", .dev_id = \"tegra-avp\", .dt_id = TEGRA20_CLK_VCP },\n\t{ .con_id = \"bsea\", .dev_id = \"tegra-avp\", .dt_id = TEGRA20_CLK_BSEA },\n\t{ .con_id = \"bsev\", .dev_id = \"tegra-aes\", .dt_id = TEGRA20_CLK_BSEV },\n\t{ .con_id = \"emc\", .dt_id = TEGRA20_CLK_EMC },\n\t{ .dev_id = \"fsl-tegra-udc\", .dt_id = TEGRA20_CLK_USBD },\n\t{ .dev_id = \"tegra-ehci.1\", .dt_id = TEGRA20_CLK_USB2 },\n\t{ .dev_id = \"tegra-ehci.2\", .dt_id = TEGRA20_CLK_USB3 },\n\t{ .dev_id = \"dsi\", .dt_id = TEGRA20_CLK_DSI },\n\t{ .con_id = \"csi\", .dev_id = \"tegra_camera\", .dt_id = TEGRA20_CLK_CSI },\n\t{ .con_id = \"isp\", .dev_id = \"tegra_camera\", .dt_id = TEGRA20_CLK_ISP },\n\t{ .con_id = \"pex\", .dt_id = TEGRA20_CLK_PEX },\n\t{ .con_id = \"afi\", .dt_id = TEGRA20_CLK_AFI },\n\t{ .con_id = \"cdev1\", .dt_id = TEGRA20_CLK_CDEV1 },\n\t{ .con_id = \"cdev2\", .dt_id = TEGRA20_CLK_CDEV2 },\n\t{ .con_id = \"clk_32k\", .dt_id = TEGRA20_CLK_CLK_32K },\n\t{ .con_id = \"clk_m\", .dt_id = TEGRA20_CLK_CLK_M },\n\t{ .con_id = \"pll_ref\", .dt_id = TEGRA20_CLK_PLL_REF },\n\t{ .dev_id = \"tegra20-i2s.0\", .dt_id = TEGRA20_CLK_I2S1 },\n\t{ .dev_id = \"tegra20-i2s.1\", .dt_id = TEGRA20_CLK_I2S2 },\n\t{ .con_id = \"spdif_out\", .dev_id = \"tegra20-spdif\", .dt_id = TEGRA20_CLK_SPDIF_OUT },\n\t{ .con_id = \"spdif_in\", .dev_id = \"tegra20-spdif\", .dt_id = TEGRA20_CLK_SPDIF_IN },\n\t{ .dev_id = \"spi_tegra.0\", .dt_id = TEGRA20_CLK_SBC1 },\n\t{ .dev_id = \"spi_tegra.1\", .dt_id = TEGRA20_CLK_SBC2 },\n\t{ .dev_id = \"spi_tegra.2\", .dt_id = TEGRA20_CLK_SBC3 },\n\t{ .dev_id = \"spi_tegra.3\", .dt_id = TEGRA20_CLK_SBC4 },\n\t{ .dev_id = \"spi\", .dt_id = TEGRA20_CLK_SPI },\n\t{ .dev_id = \"xio\", .dt_id = TEGRA20_CLK_XIO },\n\t{ .dev_id = \"twc\", .dt_id = TEGRA20_CLK_TWC },\n\t{ .dev_id = \"ide\", .dt_id = TEGRA20_CLK_IDE },\n\t{ .dev_id = \"tegra_nand\", .dt_id = TEGRA20_CLK_NDFLASH },\n\t{ .dev_id = \"vfir\", .dt_id = TEGRA20_CLK_VFIR },\n\t{ .dev_id = \"csite\", .dt_id = TEGRA20_CLK_CSITE },\n\t{ .dev_id = \"la\", .dt_id = TEGRA20_CLK_LA },\n\t{ .dev_id = \"tegra_w1\", .dt_id = TEGRA20_CLK_OWR },\n\t{ .dev_id = \"mipi\", .dt_id = TEGRA20_CLK_MIPI },\n\t{ .dev_id = \"vde\", .dt_id = TEGRA20_CLK_VDE },\n\t{ .con_id = \"vi\", .dev_id =  \"tegra_camera\", .dt_id = TEGRA20_CLK_VI },\n\t{ .dev_id = \"epp\", .dt_id = TEGRA20_CLK_EPP },\n\t{ .dev_id = \"mpe\", .dt_id = TEGRA20_CLK_MPE },\n\t{ .dev_id = \"host1x\", .dt_id = TEGRA20_CLK_HOST1X },\n\t{ .dev_id = \"3d\", .dt_id = TEGRA20_CLK_GR3D },\n\t{ .dev_id = \"2d\", .dt_id = TEGRA20_CLK_GR2D },\n\t{ .dev_id = \"tegra-nor\", .dt_id = TEGRA20_CLK_NOR },\n\t{ .dev_id = \"sdhci-tegra.0\", .dt_id = TEGRA20_CLK_SDMMC1 },\n\t{ .dev_id = \"sdhci-tegra.1\", .dt_id = TEGRA20_CLK_SDMMC2 },\n\t{ .dev_id = \"sdhci-tegra.2\", .dt_id = TEGRA20_CLK_SDMMC3 },\n\t{ .dev_id = \"sdhci-tegra.3\", .dt_id = TEGRA20_CLK_SDMMC4 },\n\t{ .dev_id = \"cve\", .dt_id = TEGRA20_CLK_CVE },\n\t{ .dev_id = \"tvo\", .dt_id = TEGRA20_CLK_TVO },\n\t{ .dev_id = \"tvdac\", .dt_id = TEGRA20_CLK_TVDAC },\n\t{ .con_id = \"vi_sensor\", .dev_id = \"tegra_camera\", .dt_id = TEGRA20_CLK_VI_SENSOR },\n\t{ .dev_id = \"hdmi\", .dt_id = TEGRA20_CLK_HDMI },\n\t{ .con_id = \"div-clk\", .dev_id = \"tegra-i2c.0\", .dt_id = TEGRA20_CLK_I2C1 },\n\t{ .con_id = \"div-clk\", .dev_id = \"tegra-i2c.1\", .dt_id = TEGRA20_CLK_I2C2 },\n\t{ .con_id = \"div-clk\", .dev_id = \"tegra-i2c.2\", .dt_id = TEGRA20_CLK_I2C3 },\n\t{ .con_id = \"div-clk\", .dev_id = \"tegra-i2c.3\", .dt_id = TEGRA20_CLK_DVC },\n\t{ .dev_id = \"tegra-pwm\", .dt_id = TEGRA20_CLK_PWM },\n\t{ .dev_id = \"tegra_uart.0\", .dt_id = TEGRA20_CLK_UARTA },\n\t{ .dev_id = \"tegra_uart.1\", .dt_id = TEGRA20_CLK_UARTB },\n\t{ .dev_id = \"tegra_uart.2\", .dt_id = TEGRA20_CLK_UARTC },\n\t{ .dev_id = \"tegra_uart.3\", .dt_id = TEGRA20_CLK_UARTD },\n\t{ .dev_id = \"tegra_uart.4\", .dt_id = TEGRA20_CLK_UARTE },\n\t{ .dev_id = \"tegradc.0\", .dt_id = TEGRA20_CLK_DISP1 },\n\t{ .dev_id = \"tegradc.1\", .dt_id = TEGRA20_CLK_DISP2 },\n};\n\nstatic struct tegra_clk tegra20_clks[tegra_clk_max] __initdata = {\n\t[tegra_clk_ahbdma] = { .dt_id = TEGRA20_CLK_AHBDMA, .present = true },\n\t[tegra_clk_apbdma] = { .dt_id = TEGRA20_CLK_APBDMA, .present = true },\n\t[tegra_clk_spdif_out] = { .dt_id = TEGRA20_CLK_SPDIF_OUT, .present = true },\n\t[tegra_clk_spdif_in] = { .dt_id = TEGRA20_CLK_SPDIF_IN, .present = true },\n\t[tegra_clk_sdmmc1] = { .dt_id = TEGRA20_CLK_SDMMC1, .present = true },\n\t[tegra_clk_sdmmc2] = { .dt_id = TEGRA20_CLK_SDMMC2, .present = true },\n\t[tegra_clk_sdmmc3] = { .dt_id = TEGRA20_CLK_SDMMC3, .present = true },\n\t[tegra_clk_sdmmc4] = { .dt_id = TEGRA20_CLK_SDMMC4, .present = true },\n\t[tegra_clk_la] = { .dt_id = TEGRA20_CLK_LA, .present = true },\n\t[tegra_clk_csite] = { .dt_id = TEGRA20_CLK_CSITE, .present = true },\n\t[tegra_clk_vfir] = { .dt_id = TEGRA20_CLK_VFIR, .present = true },\n\t[tegra_clk_mipi] = { .dt_id = TEGRA20_CLK_MIPI, .present = true },\n\t[tegra_clk_nor] = { .dt_id = TEGRA20_CLK_NOR, .present = true },\n\t[tegra_clk_rtc] = { .dt_id = TEGRA20_CLK_RTC, .present = true },\n\t[tegra_clk_timer] = { .dt_id = TEGRA20_CLK_TIMER, .present = true },\n\t[tegra_clk_kbc] = { .dt_id = TEGRA20_CLK_KBC, .present = true },\n\t[tegra_clk_csus] = { .dt_id = TEGRA20_CLK_CSUS, .present = true },\n\t[tegra_clk_vcp] = { .dt_id = TEGRA20_CLK_VCP, .present = true },\n\t[tegra_clk_bsea] = { .dt_id = TEGRA20_CLK_BSEA, .present = true },\n\t[tegra_clk_bsev] = { .dt_id = TEGRA20_CLK_BSEV, .present = true },\n\t[tegra_clk_usbd] = { .dt_id = TEGRA20_CLK_USBD, .present = true },\n\t[tegra_clk_usb2] = { .dt_id = TEGRA20_CLK_USB2, .present = true },\n\t[tegra_clk_usb3] = { .dt_id = TEGRA20_CLK_USB3, .present = true },\n\t[tegra_clk_csi] = { .dt_id = TEGRA20_CLK_CSI, .present = true },\n\t[tegra_clk_isp] = { .dt_id = TEGRA20_CLK_ISP, .present = true },\n\t[tegra_clk_clk_32k] = { .dt_id = TEGRA20_CLK_CLK_32K, .present = true },\n\t[tegra_clk_hclk] = { .dt_id = TEGRA20_CLK_HCLK, .present = true },\n\t[tegra_clk_pclk] = { .dt_id = TEGRA20_CLK_PCLK, .present = true },\n\t[tegra_clk_pll_p_out1] = { .dt_id = TEGRA20_CLK_PLL_P_OUT1, .present = true },\n\t[tegra_clk_pll_p_out2] = { .dt_id = TEGRA20_CLK_PLL_P_OUT2, .present = true },\n\t[tegra_clk_pll_p_out3] = { .dt_id = TEGRA20_CLK_PLL_P_OUT3, .present = true },\n\t[tegra_clk_pll_p_out4] = { .dt_id = TEGRA20_CLK_PLL_P_OUT4, .present = true },\n\t[tegra_clk_pll_p] = { .dt_id = TEGRA20_CLK_PLL_P, .present = true },\n\t[tegra_clk_owr] = { .dt_id = TEGRA20_CLK_OWR, .present = true },\n\t[tegra_clk_sbc1] = { .dt_id = TEGRA20_CLK_SBC1, .present = true },\n\t[tegra_clk_sbc2] = { .dt_id = TEGRA20_CLK_SBC2, .present = true },\n\t[tegra_clk_sbc3] = { .dt_id = TEGRA20_CLK_SBC3, .present = true },\n\t[tegra_clk_sbc4] = { .dt_id = TEGRA20_CLK_SBC4, .present = true },\n\t[tegra_clk_vde] = { .dt_id = TEGRA20_CLK_VDE, .present = true },\n\t[tegra_clk_vi] = { .dt_id = TEGRA20_CLK_VI, .present = true },\n\t[tegra_clk_epp] = { .dt_id = TEGRA20_CLK_EPP, .present = true },\n\t[tegra_clk_mpe] = { .dt_id = TEGRA20_CLK_MPE, .present = true },\n\t[tegra_clk_host1x] = { .dt_id = TEGRA20_CLK_HOST1X, .present = true },\n\t[tegra_clk_gr2d] = { .dt_id = TEGRA20_CLK_GR2D, .present = true },\n\t[tegra_clk_gr3d] = { .dt_id = TEGRA20_CLK_GR3D, .present = true },\n\t[tegra_clk_ndflash] = { .dt_id = TEGRA20_CLK_NDFLASH, .present = true },\n\t[tegra_clk_cve] = { .dt_id = TEGRA20_CLK_CVE, .present = true },\n\t[tegra_clk_tvo] = { .dt_id = TEGRA20_CLK_TVO, .present = true },\n\t[tegra_clk_tvdac] = { .dt_id = TEGRA20_CLK_TVDAC, .present = true },\n\t[tegra_clk_vi_sensor] = { .dt_id = TEGRA20_CLK_VI_SENSOR, .present = true },\n\t[tegra_clk_afi] = { .dt_id = TEGRA20_CLK_AFI, .present = true },\n\t[tegra_clk_fuse] = { .dt_id = TEGRA20_CLK_FUSE, .present = true },\n\t[tegra_clk_kfuse] = { .dt_id = TEGRA20_CLK_KFUSE, .present = true },\n};\n\nstatic unsigned long tegra20_clk_measure_input_freq(void)\n{\n\tu32 osc_ctrl = readl_relaxed(clk_base + OSC_CTRL);\n\tu32 auto_clk_control = osc_ctrl & OSC_CTRL_OSC_FREQ_MASK;\n\tu32 pll_ref_div = osc_ctrl & OSC_CTRL_PLL_REF_DIV_MASK;\n\tunsigned long input_freq;\n\n\tswitch (auto_clk_control) {\n\tcase OSC_CTRL_OSC_FREQ_12MHZ:\n\t\tBUG_ON(pll_ref_div != OSC_CTRL_PLL_REF_DIV_1);\n\t\tinput_freq = 12000000;\n\t\tbreak;\n\tcase OSC_CTRL_OSC_FREQ_13MHZ:\n\t\tBUG_ON(pll_ref_div != OSC_CTRL_PLL_REF_DIV_1);\n\t\tinput_freq = 13000000;\n\t\tbreak;\n\tcase OSC_CTRL_OSC_FREQ_19_2MHZ:\n\t\tBUG_ON(pll_ref_div != OSC_CTRL_PLL_REF_DIV_1);\n\t\tinput_freq = 19200000;\n\t\tbreak;\n\tcase OSC_CTRL_OSC_FREQ_26MHZ:\n\t\tBUG_ON(pll_ref_div != OSC_CTRL_PLL_REF_DIV_1);\n\t\tinput_freq = 26000000;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unexpected clock autodetect value %d\",\n\t\t       auto_clk_control);\n\t\tBUG();\n\t\treturn 0;\n\t}\n\n\treturn input_freq;\n}\n\nstatic unsigned int tegra20_get_pll_ref_div(void)\n{\n\tu32 pll_ref_div = readl_relaxed(clk_base + OSC_CTRL) &\n\t\tOSC_CTRL_PLL_REF_DIV_MASK;\n\n\tswitch (pll_ref_div) {\n\tcase OSC_CTRL_PLL_REF_DIV_1:\n\t\treturn 1;\n\tcase OSC_CTRL_PLL_REF_DIV_2:\n\t\treturn 2;\n\tcase OSC_CTRL_PLL_REF_DIV_4:\n\t\treturn 4;\n\tdefault:\n\t\tpr_err(\"Invalid pll ref divider %d\\n\", pll_ref_div);\n\t\tBUG();\n\t}\n\treturn 0;\n}\n\nstatic void tegra20_pll_init(void)\n{\n\tstruct clk *clk;\n\n\t \n\tclk = tegra_clk_register_pll(\"pll_c\", \"pll_ref\", clk_base, NULL, 0,\n\t\t\t    &pll_c_params, NULL);\n\tclks[TEGRA20_CLK_PLL_C] = clk;\n\n\t \n\tclk = tegra_clk_register_divider(\"pll_c_out1_div\", \"pll_c\",\n\t\t\t\tclk_base + PLLC_OUT, 0, TEGRA_DIVIDER_ROUND_UP,\n\t\t\t\t8, 8, 1, NULL);\n\tclk = tegra_clk_register_pll_out(\"pll_c_out1\", \"pll_c_out1_div\",\n\t\t\t\tclk_base + PLLC_OUT, 1, 0, CLK_SET_RATE_PARENT,\n\t\t\t\t0, NULL);\n\tclks[TEGRA20_CLK_PLL_C_OUT1] = clk;\n\n\t \n\tclk = tegra_clk_register_pll(\"pll_m\", \"pll_ref\", clk_base, NULL,\n\t\t\t    CLK_SET_RATE_GATE, &pll_m_params, NULL);\n\tclks[TEGRA20_CLK_PLL_M] = clk;\n\n\t \n\tclk = tegra_clk_register_divider(\"pll_m_out1_div\", \"pll_m\",\n\t\t\t\tclk_base + PLLM_OUT, 0, TEGRA_DIVIDER_ROUND_UP,\n\t\t\t\t8, 8, 1, NULL);\n\tclk = tegra_clk_register_pll_out(\"pll_m_out1\", \"pll_m_out1_div\",\n\t\t\t\tclk_base + PLLM_OUT, 1, 0,\n\t\t\t\tCLK_SET_RATE_PARENT, 0, NULL);\n\tclks[TEGRA20_CLK_PLL_M_OUT1] = clk;\n\n\t \n\tclk = tegra_clk_register_pll(\"pll_x\", \"pll_ref\", clk_base, NULL, 0,\n\t\t\t    &pll_x_params, NULL);\n\tclks[TEGRA20_CLK_PLL_X] = clk;\n\n\t \n\tclk = tegra_clk_register_pll(\"pll_u\", \"pll_ref\", clk_base, NULL, 0,\n\t\t\t    &pll_u_params, NULL);\n\tclks[TEGRA20_CLK_PLL_U] = clk;\n\n\t \n\tclk = tegra_clk_register_pll(\"pll_d\", \"pll_ref\", clk_base, NULL, 0,\n\t\t\t    &pll_d_params, NULL);\n\tclks[TEGRA20_CLK_PLL_D] = clk;\n\n\t \n\tclk = clk_register_fixed_factor(NULL, \"pll_d_out0\", \"pll_d\",\n\t\t\t\t\tCLK_SET_RATE_PARENT, 1, 2);\n\tclks[TEGRA20_CLK_PLL_D_OUT0] = clk;\n\n\t \n\tclk = tegra_clk_register_pll(\"pll_a\", \"pll_p_out1\", clk_base, NULL, 0,\n\t\t\t    &pll_a_params, NULL);\n\tclks[TEGRA20_CLK_PLL_A] = clk;\n\n\t \n\tclk = tegra_clk_register_divider(\"pll_a_out0_div\", \"pll_a\",\n\t\t\t\tclk_base + PLLA_OUT, 0, TEGRA_DIVIDER_ROUND_UP,\n\t\t\t\t8, 8, 1, NULL);\n\tclk = tegra_clk_register_pll_out(\"pll_a_out0\", \"pll_a_out0_div\",\n\t\t\t\tclk_base + PLLA_OUT, 1, 0, CLK_IGNORE_UNUSED |\n\t\t\t\tCLK_SET_RATE_PARENT, 0, NULL);\n\tclks[TEGRA20_CLK_PLL_A_OUT0] = clk;\n\n\t \n\tclk = tegra_clk_register_plle(\"pll_e\", \"pll_ref\", clk_base, pmc_base,\n\t\t\t     0, &pll_e_params, NULL);\n\tclks[TEGRA20_CLK_PLL_E] = clk;\n}\n\nstatic const char *cclk_parents[] = { \"clk_m\", \"pll_c\", \"clk_32k\", \"pll_m\",\n\t\t\t\t      \"pll_p\", \"pll_p_out4\",\n\t\t\t\t      \"pll_p_out3\", \"clk_d\", \"pll_x\" };\nstatic const char *sclk_parents[] = { \"clk_m\", \"pll_c_out1\", \"pll_p_out4\",\n\t\t\t\t      \"pll_p_out3\", \"pll_p_out2\", \"clk_d\",\n\t\t\t\t      \"clk_32k\", \"pll_m_out1\" };\n\nstatic void tegra20_super_clk_init(void)\n{\n\tstruct clk *clk;\n\n\t \n\tclk = tegra_clk_register_super_cclk(\"cclk\", cclk_parents,\n\t\t\t      ARRAY_SIZE(cclk_parents), CLK_SET_RATE_PARENT,\n\t\t\t      clk_base + CCLK_BURST_POLICY, TEGRA20_SUPER_CLK,\n\t\t\t      NULL);\n\tclks[TEGRA20_CLK_CCLK] = clk;\n\n\t \n\tclk = clk_register_fixed_factor(NULL, \"twd\", \"cclk\", 0, 1, 4);\n\tclks[TEGRA20_CLK_TWD] = clk;\n}\n\nstatic const char *audio_parents[] = { \"spdif_in\", \"i2s1\", \"i2s2\", \"unused\",\n\t\t\t\t       \"pll_a_out0\", \"unused\", \"unused\",\n\t\t\t\t       \"unused\" };\n\nstatic void __init tegra20_audio_clk_init(void)\n{\n\tstruct clk *clk;\n\n\t \n\tclk = clk_register_mux(NULL, \"audio_mux\", audio_parents,\n\t\t\t\tARRAY_SIZE(audio_parents),\n\t\t\t\tCLK_SET_RATE_NO_REPARENT,\n\t\t\t\tclk_base + AUDIO_SYNC_CLK, 0, 3, 0, NULL);\n\tclk = clk_register_gate(NULL, \"audio\", \"audio_mux\", 0,\n\t\t\t\tclk_base + AUDIO_SYNC_CLK, 4,\n\t\t\t\tCLK_GATE_SET_TO_DISABLE, NULL);\n\tclks[TEGRA20_CLK_AUDIO] = clk;\n\n\t \n\tclk = clk_register_fixed_factor(NULL, \"audio_doubler\", \"audio\",\n\t\t\t\t\tCLK_SET_RATE_PARENT, 2, 1);\n\tclk = tegra_clk_register_periph_gate(\"audio_2x\", \"audio_doubler\",\n\t\t\t\t    TEGRA_PERIPH_NO_RESET, clk_base,\n\t\t\t\t    CLK_SET_RATE_PARENT, 89,\n\t\t\t\t    periph_clk_enb_refcnt);\n\tclks[TEGRA20_CLK_AUDIO_2X] = clk;\n}\n\nstatic const char *i2s1_parents[] = { \"pll_a_out0\", \"audio_2x\", \"pll_p\",\n\t\t\t\t      \"clk_m\" };\nstatic const char *i2s2_parents[] = { \"pll_a_out0\", \"audio_2x\", \"pll_p\",\n\t\t\t\t      \"clk_m\" };\nstatic const char *pwm_parents[] = { \"pll_p\", \"pll_c\", \"audio\", \"clk_m\",\n\t\t\t\t     \"clk_32k\" };\nstatic const char *mux_pllpcm_clkm[] = { \"pll_p\", \"pll_c\", \"pll_m\", \"clk_m\" };\nstatic const char *mux_pllpdc_clkm[] = { \"pll_p\", \"pll_d_out0\", \"pll_c\",\n\t\t\t\t\t \"clk_m\" };\n\nstatic struct tegra_periph_init_data tegra_periph_clk_list[] = {\n\tTEGRA_INIT_DATA_MUX(\"i2s1\", i2s1_parents,     CLK_SOURCE_I2S1,   11, TEGRA_PERIPH_ON_APB, TEGRA20_CLK_I2S1),\n\tTEGRA_INIT_DATA_MUX(\"i2s2\", i2s2_parents,     CLK_SOURCE_I2S2,   18, TEGRA_PERIPH_ON_APB, TEGRA20_CLK_I2S2),\n\tTEGRA_INIT_DATA_MUX(\"spi\",   mux_pllpcm_clkm,   CLK_SOURCE_SPI,   43, TEGRA_PERIPH_ON_APB, TEGRA20_CLK_SPI),\n\tTEGRA_INIT_DATA_MUX(\"xio\",   mux_pllpcm_clkm,   CLK_SOURCE_XIO,   45, 0, TEGRA20_CLK_XIO),\n\tTEGRA_INIT_DATA_MUX(\"twc\",   mux_pllpcm_clkm,   CLK_SOURCE_TWC,   16, TEGRA_PERIPH_ON_APB, TEGRA20_CLK_TWC),\n\tTEGRA_INIT_DATA_MUX(\"ide\",   mux_pllpcm_clkm,   CLK_SOURCE_XIO,   25, 0, TEGRA20_CLK_IDE),\n\tTEGRA_INIT_DATA_DIV16(\"dvc\", mux_pllpcm_clkm,   CLK_SOURCE_DVC,   47, TEGRA_PERIPH_ON_APB, TEGRA20_CLK_DVC),\n\tTEGRA_INIT_DATA_DIV16(\"i2c1\", mux_pllpcm_clkm,   CLK_SOURCE_I2C1,   12, TEGRA_PERIPH_ON_APB, TEGRA20_CLK_I2C1),\n\tTEGRA_INIT_DATA_DIV16(\"i2c2\", mux_pllpcm_clkm,   CLK_SOURCE_I2C2,   54, TEGRA_PERIPH_ON_APB, TEGRA20_CLK_I2C2),\n\tTEGRA_INIT_DATA_DIV16(\"i2c3\", mux_pllpcm_clkm,   CLK_SOURCE_I2C3,   67, TEGRA_PERIPH_ON_APB, TEGRA20_CLK_I2C3),\n\tTEGRA_INIT_DATA_MUX(\"hdmi\", mux_pllpdc_clkm,   CLK_SOURCE_HDMI,   51, 0, TEGRA20_CLK_HDMI),\n\tTEGRA_INIT_DATA(\"pwm\", NULL, NULL, pwm_parents,     CLK_SOURCE_PWM,   28, 3, 0, 0, 8, 1, 0, 17, TEGRA_PERIPH_ON_APB, TEGRA20_CLK_PWM),\n};\n\nstatic struct tegra_periph_init_data tegra_periph_nodiv_clk_list[] = {\n\tTEGRA_INIT_DATA_NODIV(\"uarta\",\tmux_pllpcm_clkm, CLK_SOURCE_UARTA, 30, 2, 6,   TEGRA_PERIPH_ON_APB, TEGRA20_CLK_UARTA),\n\tTEGRA_INIT_DATA_NODIV(\"uartb\",\tmux_pllpcm_clkm, CLK_SOURCE_UARTB, 30, 2, 7,   TEGRA_PERIPH_ON_APB, TEGRA20_CLK_UARTB),\n\tTEGRA_INIT_DATA_NODIV(\"uartc\",\tmux_pllpcm_clkm, CLK_SOURCE_UARTC, 30, 2, 55,  TEGRA_PERIPH_ON_APB, TEGRA20_CLK_UARTC),\n\tTEGRA_INIT_DATA_NODIV(\"uartd\",\tmux_pllpcm_clkm, CLK_SOURCE_UARTD, 30, 2, 65,  TEGRA_PERIPH_ON_APB, TEGRA20_CLK_UARTD),\n\tTEGRA_INIT_DATA_NODIV(\"uarte\",\tmux_pllpcm_clkm, CLK_SOURCE_UARTE, 30, 2, 66,  TEGRA_PERIPH_ON_APB, TEGRA20_CLK_UARTE),\n\tTEGRA_INIT_DATA_NODIV(\"disp1\",\tmux_pllpdc_clkm, CLK_SOURCE_DISP1, 30, 2, 27,  0, TEGRA20_CLK_DISP1),\n\tTEGRA_INIT_DATA_NODIV(\"disp2\",\tmux_pllpdc_clkm, CLK_SOURCE_DISP2, 30, 2, 26,  0, TEGRA20_CLK_DISP2),\n};\n\nstatic void __init tegra20_periph_clk_init(void)\n{\n\tstruct tegra_periph_init_data *data;\n\tstruct clk *clk;\n\tunsigned int i;\n\n\t \n\tclk = tegra_clk_register_periph_gate(\"ac97\", \"pll_a_out0\",\n\t\t\t\t    TEGRA_PERIPH_ON_APB,\n\t\t\t\t    clk_base, 0, 3, periph_clk_enb_refcnt);\n\tclks[TEGRA20_CLK_AC97] = clk;\n\n\t \n\tclk = tegra20_clk_register_emc(clk_base + CLK_SOURCE_EMC, false);\n\n\tclks[TEGRA20_CLK_EMC] = clk;\n\n\tclk = tegra_clk_register_mc(\"mc\", \"emc\", clk_base + CLK_SOURCE_EMC,\n\t\t\t\t    NULL);\n\tclks[TEGRA20_CLK_MC] = clk;\n\n\t \n\tclk = tegra_clk_register_periph_gate(\"dsi\", \"pll_d\", 0, clk_base, 0,\n\t\t\t\t    48, periph_clk_enb_refcnt);\n\tclk_register_clkdev(clk, NULL, \"dsi\");\n\tclks[TEGRA20_CLK_DSI] = clk;\n\n\t \n\tclk = tegra_clk_register_periph_gate(\"pex\", \"clk_m\", 0, clk_base, 0, 70,\n\t\t\t\t    periph_clk_enb_refcnt);\n\tclks[TEGRA20_CLK_PEX] = clk;\n\n\t \n\tclk_register_divider(NULL, \"dev1_osc_div\", \"clk_m\",\n\t\t\t     0, clk_base + MISC_CLK_ENB, 22, 2,\n\t\t\t     CLK_DIVIDER_POWER_OF_TWO | CLK_DIVIDER_READ_ONLY,\n\t\t\t     NULL);\n\n\t \n\tclk_register_divider(NULL, \"dev2_osc_div\", \"clk_m\",\n\t\t\t     0, clk_base + MISC_CLK_ENB, 20, 2,\n\t\t\t     CLK_DIVIDER_POWER_OF_TWO | CLK_DIVIDER_READ_ONLY,\n\t\t\t     NULL);\n\n\t \n\tclk = tegra_clk_register_periph_gate(\"cdev1\", \"cdev1_mux\", 0,\n\t\t\t\t    clk_base, 0, 94, periph_clk_enb_refcnt);\n\tclks[TEGRA20_CLK_CDEV1] = clk;\n\n\t \n\tclk = tegra_clk_register_periph_gate(\"cdev2\", \"cdev2_mux\", 0,\n\t\t\t\t    clk_base, 0, 93, periph_clk_enb_refcnt);\n\tclks[TEGRA20_CLK_CDEV2] = clk;\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra_periph_clk_list); i++) {\n\t\tdata = &tegra_periph_clk_list[i];\n\t\tclk = tegra_clk_register_periph_data(clk_base, data);\n\t\tclks[data->clk_id] = clk;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra_periph_nodiv_clk_list); i++) {\n\t\tdata = &tegra_periph_nodiv_clk_list[i];\n\t\tclk = tegra_clk_register_periph_nodiv(data->name,\n\t\t\t\t\tdata->p.parent_names,\n\t\t\t\t\tdata->num_parents, &data->periph,\n\t\t\t\t\tclk_base, data->offset);\n\t\tclks[data->clk_id] = clk;\n\t}\n\n\ttegra_periph_clk_init(clk_base, pmc_base, tegra20_clks, &pll_p_params);\n}\n\nstatic void __init tegra20_osc_clk_init(void)\n{\n\tstruct clk *clk;\n\tunsigned long input_freq;\n\tunsigned int pll_ref_div;\n\n\tinput_freq = tegra20_clk_measure_input_freq();\n\n\t \n\tclk = clk_register_fixed_rate(NULL, \"clk_m\", NULL, CLK_IGNORE_UNUSED,\n\t\t\t\t      input_freq);\n\tclks[TEGRA20_CLK_CLK_M] = clk;\n\n\t \n\tpll_ref_div = tegra20_get_pll_ref_div();\n\tclk = clk_register_fixed_factor(NULL, \"pll_ref\", \"clk_m\",\n\t\t\t\t\tCLK_SET_RATE_PARENT, 1, pll_ref_div);\n\tclks[TEGRA20_CLK_PLL_REF] = clk;\n}\n\n \nstatic void tegra20_wait_cpu_in_reset(u32 cpu)\n{\n\tunsigned int reg;\n\n\tdo {\n\t\treg = readl(clk_base +\n\t\t\t    TEGRA_CLK_RST_CONTROLLER_RST_CPU_CMPLX_SET);\n\t\tcpu_relax();\n\t} while (!(reg & (1 << cpu)));\t \n\n\treturn;\n}\n\nstatic void tegra20_put_cpu_in_reset(u32 cpu)\n{\n\twritel(CPU_RESET(cpu),\n\t       clk_base + TEGRA_CLK_RST_CONTROLLER_RST_CPU_CMPLX_SET);\n\tdmb();\n}\n\nstatic void tegra20_cpu_out_of_reset(u32 cpu)\n{\n\twritel(CPU_RESET(cpu),\n\t       clk_base + TEGRA_CLK_RST_CONTROLLER_RST_CPU_CMPLX_CLR);\n\twmb();\n}\n\nstatic void tegra20_enable_cpu_clock(u32 cpu)\n{\n\tunsigned int reg;\n\n\treg = readl(clk_base + TEGRA_CLK_RST_CONTROLLER_CLK_CPU_CMPLX);\n\twritel(reg & ~CPU_CLOCK(cpu),\n\t       clk_base + TEGRA_CLK_RST_CONTROLLER_CLK_CPU_CMPLX);\n\tbarrier();\n\treg = readl(clk_base + TEGRA_CLK_RST_CONTROLLER_CLK_CPU_CMPLX);\n}\n\nstatic void tegra20_disable_cpu_clock(u32 cpu)\n{\n\tunsigned int reg;\n\n\treg = readl(clk_base + TEGRA_CLK_RST_CONTROLLER_CLK_CPU_CMPLX);\n\twritel(reg | CPU_CLOCK(cpu),\n\t       clk_base + TEGRA_CLK_RST_CONTROLLER_CLK_CPU_CMPLX);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic bool tegra20_cpu_rail_off_ready(void)\n{\n\tunsigned int cpu_rst_status;\n\n\tcpu_rst_status = readl(clk_base +\n\t\t\t       TEGRA_CLK_RST_CONTROLLER_RST_CPU_CMPLX_SET);\n\n\treturn !!(cpu_rst_status & 0x2);\n}\n\nstatic void tegra20_cpu_clock_suspend(void)\n{\n\t \n\ttegra20_cpu_clk_sctx.clk_csite_src =\n\t\t\t\treadl(clk_base + CLK_SOURCE_CSITE);\n\twritel(3<<30, clk_base + CLK_SOURCE_CSITE);\n\n\ttegra20_cpu_clk_sctx.cpu_burst =\n\t\t\t\treadl(clk_base + CCLK_BURST_POLICY);\n\ttegra20_cpu_clk_sctx.pllx_base =\n\t\t\t\treadl(clk_base + PLLX_BASE);\n\ttegra20_cpu_clk_sctx.pllx_misc =\n\t\t\t\treadl(clk_base + PLLX_MISC);\n\ttegra20_cpu_clk_sctx.cclk_divider =\n\t\t\t\treadl(clk_base + SUPER_CCLK_DIVIDER);\n}\n\nstatic void tegra20_cpu_clock_resume(void)\n{\n\tunsigned int reg, policy;\n\tu32 misc, base;\n\n\t \n\treg = readl(clk_base + CCLK_BURST_POLICY);\n\tpolicy = (reg >> CCLK_BURST_POLICY_SHIFT) & 0xF;\n\n\tif (policy == CCLK_IDLE_POLICY)\n\t\treg = (reg >> CCLK_IDLE_POLICY_SHIFT) & 0xF;\n\telse if (policy == CCLK_RUN_POLICY)\n\t\treg = (reg >> CCLK_RUN_POLICY_SHIFT) & 0xF;\n\telse\n\t\tBUG();\n\n\tif (reg != CCLK_BURST_POLICY_PLLX) {\n\t\tmisc = readl_relaxed(clk_base + PLLX_MISC);\n\t\tbase = readl_relaxed(clk_base + PLLX_BASE);\n\n\t\tif (misc != tegra20_cpu_clk_sctx.pllx_misc ||\n\t\t    base != tegra20_cpu_clk_sctx.pllx_base) {\n\t\t\t \n\t\t\twritel(tegra20_cpu_clk_sctx.pllx_misc,\n\t\t\t\t\t\tclk_base + PLLX_MISC);\n\t\t\twritel(tegra20_cpu_clk_sctx.pllx_base,\n\t\t\t\t\t\tclk_base + PLLX_BASE);\n\n\t\t\t \n\t\t\tif (tegra20_cpu_clk_sctx.pllx_base & (1 << 30))\n\t\t\t\tudelay(300);\n\t\t}\n\t}\n\n\t \n\twritel(tegra20_cpu_clk_sctx.cclk_divider,\n\t\t\t\t\tclk_base + SUPER_CCLK_DIVIDER);\n\twritel(tegra20_cpu_clk_sctx.cpu_burst,\n\t\t\t\t\tclk_base + CCLK_BURST_POLICY);\n\n\twritel(tegra20_cpu_clk_sctx.clk_csite_src,\n\t\t\t\t\tclk_base + CLK_SOURCE_CSITE);\n}\n#endif\n\nstatic struct tegra_cpu_car_ops tegra20_cpu_car_ops = {\n\t.wait_for_reset\t= tegra20_wait_cpu_in_reset,\n\t.put_in_reset\t= tegra20_put_cpu_in_reset,\n\t.out_of_reset\t= tegra20_cpu_out_of_reset,\n\t.enable_clock\t= tegra20_enable_cpu_clock,\n\t.disable_clock\t= tegra20_disable_cpu_clock,\n#ifdef CONFIG_PM_SLEEP\n\t.rail_off_ready = tegra20_cpu_rail_off_ready,\n\t.suspend\t= tegra20_cpu_clock_suspend,\n\t.resume\t\t= tegra20_cpu_clock_resume,\n#endif\n};\n\nstatic struct tegra_clk_init_table init_table[] = {\n\t{ TEGRA20_CLK_PLL_P, TEGRA20_CLK_CLK_MAX, 216000000, 1 },\n\t{ TEGRA20_CLK_PLL_P_OUT1, TEGRA20_CLK_CLK_MAX, 28800000, 1 },\n\t{ TEGRA20_CLK_PLL_P_OUT2, TEGRA20_CLK_CLK_MAX, 48000000, 1 },\n\t{ TEGRA20_CLK_PLL_P_OUT3, TEGRA20_CLK_CLK_MAX, 72000000, 1 },\n\t{ TEGRA20_CLK_PLL_P_OUT4, TEGRA20_CLK_CLK_MAX, 24000000, 1 },\n\t{ TEGRA20_CLK_PLL_C, TEGRA20_CLK_CLK_MAX, 600000000, 0 },\n\t{ TEGRA20_CLK_PLL_C_OUT1, TEGRA20_CLK_CLK_MAX, 120000000, 0 },\n\t{ TEGRA20_CLK_SCLK, TEGRA20_CLK_PLL_C_OUT1, 120000000, 0 },\n\t{ TEGRA20_CLK_HCLK, TEGRA20_CLK_CLK_MAX, 120000000, 0 },\n\t{ TEGRA20_CLK_PCLK, TEGRA20_CLK_CLK_MAX, 60000000, 0 },\n\t{ TEGRA20_CLK_CSITE, TEGRA20_CLK_CLK_MAX, 0, 1 },\n\t{ TEGRA20_CLK_CCLK, TEGRA20_CLK_CLK_MAX, 0, 1 },\n\t{ TEGRA20_CLK_UARTA, TEGRA20_CLK_PLL_P, 0, 0 },\n\t{ TEGRA20_CLK_UARTB, TEGRA20_CLK_PLL_P, 0, 0 },\n\t{ TEGRA20_CLK_UARTC, TEGRA20_CLK_PLL_P, 0, 0 },\n\t{ TEGRA20_CLK_UARTD, TEGRA20_CLK_PLL_P, 0, 0 },\n\t{ TEGRA20_CLK_UARTE, TEGRA20_CLK_PLL_P, 0, 0 },\n\t{ TEGRA20_CLK_PLL_A, TEGRA20_CLK_CLK_MAX, 56448000, 0 },\n\t{ TEGRA20_CLK_PLL_A_OUT0, TEGRA20_CLK_CLK_MAX, 11289600, 0 },\n\t{ TEGRA20_CLK_I2S1, TEGRA20_CLK_PLL_A_OUT0, 11289600, 0 },\n\t{ TEGRA20_CLK_I2S2, TEGRA20_CLK_PLL_A_OUT0, 11289600, 0 },\n\t{ TEGRA20_CLK_SDMMC1, TEGRA20_CLK_PLL_P, 48000000, 0 },\n\t{ TEGRA20_CLK_SDMMC3, TEGRA20_CLK_PLL_P, 48000000, 0 },\n\t{ TEGRA20_CLK_SDMMC4, TEGRA20_CLK_PLL_P, 48000000, 0 },\n\t{ TEGRA20_CLK_SPI, TEGRA20_CLK_PLL_P, 20000000, 0 },\n\t{ TEGRA20_CLK_SBC1, TEGRA20_CLK_PLL_P, 100000000, 0 },\n\t{ TEGRA20_CLK_SBC2, TEGRA20_CLK_PLL_P, 100000000, 0 },\n\t{ TEGRA20_CLK_SBC3, TEGRA20_CLK_PLL_P, 100000000, 0 },\n\t{ TEGRA20_CLK_SBC4, TEGRA20_CLK_PLL_P, 100000000, 0 },\n\t{ TEGRA20_CLK_HOST1X, TEGRA20_CLK_PLL_C, 150000000, 0 },\n\t{ TEGRA20_CLK_GR2D, TEGRA20_CLK_PLL_C, 300000000, 0 },\n\t{ TEGRA20_CLK_GR3D, TEGRA20_CLK_PLL_C, 300000000, 0 },\n\t{ TEGRA20_CLK_VDE, TEGRA20_CLK_PLL_C, 300000000, 0 },\n\t{ TEGRA20_CLK_PWM, TEGRA20_CLK_PLL_P, 48000000, 0 },\n\t \n\t{ TEGRA20_CLK_CLK_MAX, TEGRA20_CLK_CLK_MAX, 0, 0 },\n};\n\n \nstatic struct tegra_clk_duplicate tegra_clk_duplicates[] = {\n\tTEGRA_CLK_DUPLICATE(TEGRA20_CLK_USBD,    \"utmip-pad\",     NULL),\n\tTEGRA_CLK_DUPLICATE(TEGRA20_CLK_USBD,    \"tegra-ehci.0\",  NULL),\n\tTEGRA_CLK_DUPLICATE(TEGRA20_CLK_USBD,    \"tegra-otg\",     NULL),\n\tTEGRA_CLK_DUPLICATE(TEGRA20_CLK_CCLK,    NULL,           \"cpu\"),\n\t \n\tTEGRA_CLK_DUPLICATE(TEGRA20_CLK_CLK_MAX, NULL,            NULL),\n};\n\nstatic const struct of_device_id pmc_match[] __initconst = {\n\t{ .compatible = \"nvidia,tegra20-pmc\" },\n\t{ },\n};\n\nstatic bool tegra20_car_initialized;\n\nstatic struct clk *tegra20_clk_src_onecell_get(struct of_phandle_args *clkspec,\n\t\t\t\t\t       void *data)\n{\n\tstruct clk_hw *parent_hw;\n\tstruct clk_hw *hw;\n\tstruct clk *clk;\n\n\t \n\tif (clkspec->args[0] != TEGRA20_CLK_RTC &&\n\t    clkspec->args[0] != TEGRA20_CLK_TWD &&\n\t    clkspec->args[0] != TEGRA20_CLK_TIMER &&\n\t    !tegra20_car_initialized)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tclk = of_clk_src_onecell_get(clkspec, data);\n\tif (IS_ERR(clk))\n\t\treturn clk;\n\n\thw = __clk_get_hw(clk);\n\n\t \n\tif (clkspec->args[0] == TEGRA20_CLK_CDEV1 ||\n\t    clkspec->args[0] == TEGRA20_CLK_CDEV2) {\n\t\tparent_hw = clk_hw_get_parent(hw);\n\t\tif (!parent_hw)\n\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tif (clkspec->args[0] == TEGRA20_CLK_EMC) {\n\t\tif (!tegra20_clk_emc_driver_available(hw))\n\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\treturn clk;\n}\n\nstatic void __init tegra20_clock_init(struct device_node *np)\n{\n\tstruct device_node *node;\n\n\tclk_base = of_iomap(np, 0);\n\tif (!clk_base) {\n\t\tpr_err(\"Can't map CAR registers\\n\");\n\t\tBUG();\n\t}\n\n\tnode = of_find_matching_node(NULL, pmc_match);\n\tif (!node) {\n\t\tpr_err(\"Failed to find pmc node\\n\");\n\t\tBUG();\n\t}\n\n\tpmc_base = of_iomap(node, 0);\n\tof_node_put(node);\n\tif (!pmc_base) {\n\t\tpr_err(\"Can't map pmc registers\\n\");\n\t\tBUG();\n\t}\n\n\tclks = tegra_clk_init(clk_base, TEGRA20_CLK_CLK_MAX,\n\t\t\t\tTEGRA20_CLK_PERIPH_BANKS);\n\tif (!clks)\n\t\treturn;\n\n\ttegra20_osc_clk_init();\n\ttegra_fixed_clk_init(tegra20_clks);\n\ttegra20_pll_init();\n\ttegra20_super_clk_init();\n\ttegra_super_clk_gen4_init(clk_base, pmc_base, tegra20_clks, NULL);\n\ttegra20_periph_clk_init();\n\ttegra20_audio_clk_init();\n\n\ttegra_init_dup_clks(tegra_clk_duplicates, clks, TEGRA20_CLK_CLK_MAX);\n\n\ttegra_add_of_provider(np, tegra20_clk_src_onecell_get);\n\n\ttegra_cpu_car_ops = &tegra20_cpu_car_ops;\n}\nCLK_OF_DECLARE_DRIVER(tegra20, \"nvidia,tegra20-car\", tegra20_clock_init);\n\n \nstatic int tegra20_car_probe(struct platform_device *pdev)\n{\n\tstruct clk *clk;\n\n\tclk = tegra_clk_register_super_mux(\"sclk\", sclk_parents,\n\t\t\t      ARRAY_SIZE(sclk_parents),\n\t\t\t      CLK_SET_RATE_PARENT | CLK_IS_CRITICAL,\n\t\t\t      clk_base + SCLK_BURST_POLICY, 0, 4, 0, 0, NULL);\n\tclks[TEGRA20_CLK_SCLK] = clk;\n\n\ttegra_register_devclks(devclks, ARRAY_SIZE(devclks));\n\ttegra_init_from_table(init_table, clks, TEGRA20_CLK_CLK_MAX);\n\ttegra20_car_initialized = true;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tegra20_car_match[] = {\n\t{ .compatible = \"nvidia,tegra20-car\" },\n\t{ }\n};\n\nstatic struct platform_driver tegra20_car_driver = {\n\t.driver = {\n\t\t.name = \"tegra20-car\",\n\t\t.of_match_table = tegra20_car_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = tegra20_car_probe,\n};\nbuiltin_platform_driver(tegra20_car_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}