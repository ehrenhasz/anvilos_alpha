{
  "module_name": "clk-si570.c",
  "hash_id": "77d0188ad639e2cc447e91dd86c654dd38a6c063d01233f164a6f73619143608",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-si570.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n \n#define SI570_REG_HS_N1\t\t7\n#define SI570_REG_N1_RFREQ0\t8\n#define SI570_REG_RFREQ1\t9\n#define SI570_REG_RFREQ2\t10\n#define SI570_REG_RFREQ3\t11\n#define SI570_REG_RFREQ4\t12\n#define SI570_REG_CONTROL\t135\n#define SI570_REG_FREEZE_DCO\t137\n#define SI570_DIV_OFFSET_7PPM\t6\n\n#define HS_DIV_SHIFT\t\t5\n#define HS_DIV_MASK\t\t0xe0\n#define HS_DIV_OFFSET\t\t4\n#define N1_6_2_MASK\t\t0x1f\n#define N1_1_0_MASK\t\t0xc0\n#define RFREQ_37_32_MASK\t0x3f\n\n#define SI570_MIN_FREQ\t\t10000000L\n#define SI570_MAX_FREQ\t\t1417500000L\n#define SI598_MAX_FREQ\t\t525000000L\n\n#define FDCO_MIN\t\t4850000000LL\n#define FDCO_MAX\t\t5670000000LL\n\n#define SI570_CNTRL_RECALL\t(1 << 0)\n#define SI570_CNTRL_FREEZE_M\t(1 << 5)\n#define SI570_CNTRL_NEWFREQ\t(1 << 6)\n\n#define SI570_FREEZE_DCO\t(1 << 4)\n\n \nstruct clk_si570 {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tunsigned int div_offset;\n\tu64 max_freq;\n\tu64 fxtal;\n\tunsigned int n1;\n\tunsigned int hs_div;\n\tu64 rfreq;\n\tu64 frequency;\n\tstruct i2c_client *i2c_client;\n};\n#define to_clk_si570(_hw)\tcontainer_of(_hw, struct clk_si570, hw)\n\nenum clk_si570_variant {\n\tsi57x,\n\tsi59x\n};\n\n \nstatic int si570_get_divs(struct clk_si570 *data, u64 *rfreq,\n\t\tunsigned int *n1, unsigned int *hs_div)\n{\n\tint err;\n\tu8 reg[6];\n\tu64 tmp;\n\n\terr = regmap_bulk_read(data->regmap, SI570_REG_HS_N1 + data->div_offset,\n\t\t\treg, ARRAY_SIZE(reg));\n\tif (err)\n\t\treturn err;\n\n\t*hs_div = ((reg[0] & HS_DIV_MASK) >> HS_DIV_SHIFT) + HS_DIV_OFFSET;\n\t*n1 = ((reg[0] & N1_6_2_MASK) << 2) + ((reg[1] & N1_1_0_MASK) >> 6) + 1;\n\t \n\tif (*n1 > 1)\n\t\t*n1 &= ~1;\n\n\ttmp = reg[1] & RFREQ_37_32_MASK;\n\ttmp = (tmp << 8) + reg[2];\n\ttmp = (tmp << 8) + reg[3];\n\ttmp = (tmp << 8) + reg[4];\n\ttmp = (tmp << 8) + reg[5];\n\t*rfreq = tmp;\n\n\treturn 0;\n}\n\n \nstatic int si570_get_defaults(struct clk_si570 *data, u64 fout,\n\t\t\t      bool skip_recall)\n{\n\tint err;\n\tu64 fdco;\n\n\tif (!skip_recall)\n\t\tregmap_write(data->regmap, SI570_REG_CONTROL,\n\t\t\t     SI570_CNTRL_RECALL);\n\n\terr = si570_get_divs(data, &data->rfreq, &data->n1, &data->hs_div);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfdco = fout * data->n1 * data->hs_div;\n\tif (fdco >= (1LL << 36))\n\t\tdata->fxtal = div64_u64(fdco << 24, data->rfreq >> 4);\n\telse\n\t\tdata->fxtal = div64_u64(fdco << 28, data->rfreq);\n\n\tdata->frequency = fout;\n\n\treturn 0;\n}\n\n \nstatic int si570_update_rfreq(struct clk_si570 *data)\n{\n\tu8 reg[5];\n\n\treg[0] = ((data->n1 - 1) << 6) |\n\t\t((data->rfreq >> 32) & RFREQ_37_32_MASK);\n\treg[1] = (data->rfreq >> 24) & 0xff;\n\treg[2] = (data->rfreq >> 16) & 0xff;\n\treg[3] = (data->rfreq >> 8) & 0xff;\n\treg[4] = data->rfreq & 0xff;\n\n\treturn regmap_bulk_write(data->regmap, SI570_REG_N1_RFREQ0 +\n\t\t\tdata->div_offset, reg, ARRAY_SIZE(reg));\n}\n\n \nstatic int si570_calc_divs(unsigned long frequency, struct clk_si570 *data,\n\t\tu64 *out_rfreq, unsigned int *out_n1, unsigned int *out_hs_div)\n{\n\tint i;\n\tunsigned int n1, hs_div;\n\tu64 fdco, best_fdco = ULLONG_MAX;\n\tstatic const uint8_t si570_hs_div_values[] = { 11, 9, 7, 6, 5, 4 };\n\n\tfor (i = 0; i < ARRAY_SIZE(si570_hs_div_values); i++) {\n\t\ths_div = si570_hs_div_values[i];\n\t\t \n\t\tn1 = div_u64(div_u64(FDCO_MIN, hs_div), frequency);\n\t\tif (!n1 || (n1 & 1))\n\t\t\tn1++;\n\t\twhile (n1 <= 128) {\n\t\t\tfdco = (u64)frequency * (u64)hs_div * (u64)n1;\n\t\t\tif (fdco > FDCO_MAX)\n\t\t\t\tbreak;\n\t\t\tif (fdco >= FDCO_MIN && fdco < best_fdco) {\n\t\t\t\t*out_n1 = n1;\n\t\t\t\t*out_hs_div = hs_div;\n\t\t\t\t*out_rfreq = div64_u64(fdco << 28, data->fxtal);\n\t\t\t\tbest_fdco = fdco;\n\t\t\t}\n\t\t\tn1 += (n1 == 1 ? 1 : 2);\n\t\t}\n\t}\n\n\tif (best_fdco == ULLONG_MAX)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic unsigned long si570_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tint err;\n\tu64 rfreq, rate;\n\tunsigned int n1, hs_div;\n\tstruct clk_si570 *data = to_clk_si570(hw);\n\n\terr = si570_get_divs(data, &rfreq, &n1, &hs_div);\n\tif (err) {\n\t\tdev_err(&data->i2c_client->dev, \"unable to recalc rate\\n\");\n\t\treturn data->frequency;\n\t}\n\n\trfreq = div_u64(rfreq, hs_div * n1);\n\trate = (data->fxtal * rfreq) >> 28;\n\n\treturn rate;\n}\n\nstatic long si570_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long *parent_rate)\n{\n\tint err;\n\tu64 rfreq;\n\tunsigned int n1, hs_div;\n\tstruct clk_si570 *data = to_clk_si570(hw);\n\n\tif (!rate)\n\t\treturn 0;\n\n\tif (div64_u64(abs(rate - data->frequency) * 10000LL,\n\t\t\t\tdata->frequency) < 35) {\n\t\trfreq = div64_u64((data->rfreq * rate) +\n\t\t\t\tdiv64_u64(data->frequency, 2), data->frequency);\n\t\tn1 = data->n1;\n\t\ths_div = data->hs_div;\n\n\t} else {\n\t\terr = si570_calc_divs(rate, data, &rfreq, &n1, &hs_div);\n\t\tif (err) {\n\t\t\tdev_err(&data->i2c_client->dev,\n\t\t\t\t\t\"unable to round rate\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn rate;\n}\n\n \nstatic int si570_set_frequency(struct clk_si570 *data, unsigned long frequency)\n{\n\tint err;\n\n\terr = si570_calc_divs(frequency, data, &data->rfreq, &data->n1,\n\t\t\t&data->hs_div);\n\tif (err)\n\t\treturn err;\n\n\t \n\tregmap_write(data->regmap, SI570_REG_FREEZE_DCO, SI570_FREEZE_DCO);\n\tregmap_write(data->regmap, SI570_REG_HS_N1 + data->div_offset,\n\t\t\t((data->hs_div - HS_DIV_OFFSET) << HS_DIV_SHIFT) |\n\t\t\t(((data->n1 - 1) >> 2) & N1_6_2_MASK));\n\tsi570_update_rfreq(data);\n\tregmap_write(data->regmap, SI570_REG_FREEZE_DCO, 0);\n\tregmap_write(data->regmap, SI570_REG_CONTROL, SI570_CNTRL_NEWFREQ);\n\n\t \n\tusleep_range(10000, 12000);\n\n\treturn 0;\n}\n\n \nstatic int si570_set_frequency_small(struct clk_si570 *data,\n\t\t\t\t     unsigned long frequency)\n{\n\t \n\tdata->rfreq = div64_u64((data->rfreq * frequency) +\n\t\t\tdiv_u64(data->frequency, 2), data->frequency);\n\tregmap_write(data->regmap, SI570_REG_CONTROL, SI570_CNTRL_FREEZE_M);\n\tsi570_update_rfreq(data);\n\tregmap_write(data->regmap, SI570_REG_CONTROL, 0);\n\n\t \n\tusleep_range(100, 200);\n\n\treturn 0;\n}\n\nstatic int si570_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_si570 *data = to_clk_si570(hw);\n\tstruct i2c_client *client = data->i2c_client;\n\tint err;\n\n\tif (rate < SI570_MIN_FREQ || rate > data->max_freq) {\n\t\tdev_err(&client->dev,\n\t\t\t\"requested frequency %lu Hz is out of range\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tif (div64_u64(abs(rate - data->frequency) * 10000LL,\n\t\t\t\tdata->frequency) < 35)\n\t\terr = si570_set_frequency_small(data, rate);\n\telse\n\t\terr = si570_set_frequency(data, rate);\n\n\tif (err)\n\t\treturn err;\n\n\tdata->frequency = rate;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops si570_clk_ops = {\n\t.recalc_rate = si570_recalc_rate,\n\t.round_rate = si570_round_rate,\n\t.set_rate = si570_set_rate,\n};\n\nstatic bool si570_regmap_is_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SI570_REG_CONTROL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool si570_regmap_is_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SI570_REG_HS_N1 ... (SI570_REG_RFREQ4 + SI570_DIV_OFFSET_7PPM):\n\tcase SI570_REG_CONTROL:\n\tcase SI570_REG_FREEZE_DCO:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config si570_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = 137,\n\t.writeable_reg = si570_regmap_is_writeable,\n\t.volatile_reg = si570_regmap_is_volatile,\n};\n\nstatic const struct i2c_device_id si570_id[] = {\n\t{ \"si570\", si57x },\n\t{ \"si571\", si57x },\n\t{ \"si598\", si59x },\n\t{ \"si599\", si59x },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, si570_id);\n\nstatic int si570_probe(struct i2c_client *client)\n{\n\tstruct clk_si570 *data;\n\tstruct clk_init_data init;\n\tconst struct i2c_device_id *id = i2c_match_id(si570_id, client);\n\tu32 initial_fout, factory_fout, stability;\n\tbool skip_recall;\n\tint err;\n\tenum clk_si570_variant variant = id->driver_data;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinit.ops = &si570_clk_ops;\n\tinit.flags = 0;\n\tinit.num_parents = 0;\n\tdata->hw.init = &init;\n\tdata->i2c_client = client;\n\n\tif (variant == si57x) {\n\t\terr = of_property_read_u32(client->dev.of_node,\n\t\t\t\t\"temperature-stability\", &stability);\n\t\tif (err) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t  \"'temperature-stability' property missing\\n\");\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\tif (stability == 7)\n\t\t\tdata->div_offset = SI570_DIV_OFFSET_7PPM;\n\n\t\tdata->max_freq = SI570_MAX_FREQ;\n\t} else {\n\t\tdata->max_freq = SI598_MAX_FREQ;\n\t}\n\n\tif (of_property_read_string(client->dev.of_node, \"clock-output-names\",\n\t\t\t&init.name))\n\t\tinit.name = client->dev.of_node->name;\n\n\terr = of_property_read_u32(client->dev.of_node, \"factory-fout\",\n\t\t\t&factory_fout);\n\tif (err) {\n\t\tdev_err(&client->dev, \"'factory-fout' property missing\\n\");\n\t\treturn err;\n\t}\n\n\tskip_recall = of_property_read_bool(client->dev.of_node,\n\t\t\t\t\t    \"silabs,skip-recall\");\n\n\tdata->regmap = devm_regmap_init_i2c(client, &si570_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(&client->dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(data->regmap);\n\t}\n\n\ti2c_set_clientdata(client, data);\n\terr = si570_get_defaults(data, factory_fout, skip_recall);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_clk_hw_register(&client->dev, &data->hw);\n\tif (err) {\n\t\tdev_err(&client->dev, \"clock registration failed\\n\");\n\t\treturn err;\n\t}\n\terr = devm_of_clk_add_hw_provider(&client->dev, of_clk_hw_simple_get,\n\t\t\t\t\t  &data->hw);\n\tif (err) {\n\t\tdev_err(&client->dev, \"unable to add clk provider\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (!of_property_read_u32(client->dev.of_node, \"clock-frequency\",\n\t\t\t\t&initial_fout)) {\n\t\terr = clk_set_rate(data->hw.clk, initial_fout);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tdev_info(&client->dev, \"registered, current frequency %llu Hz\\n\",\n\t\t\tdata->frequency);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id clk_si570_of_match[] = {\n\t{ .compatible = \"silabs,si570\" },\n\t{ .compatible = \"silabs,si571\" },\n\t{ .compatible = \"silabs,si598\" },\n\t{ .compatible = \"silabs,si599\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, clk_si570_of_match);\n\nstatic struct i2c_driver si570_driver = {\n\t.driver = {\n\t\t.name = \"si570\",\n\t\t.of_match_table = clk_si570_of_match,\n\t},\n\t.probe\t\t= si570_probe,\n\t.id_table\t= si570_id,\n};\nmodule_i2c_driver(si570_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck <guenter.roeck@ericsson.com>\");\nMODULE_AUTHOR(\"Soeren Brinkmann <soren.brinkmann@xilinx.com>\");\nMODULE_DESCRIPTION(\"Si570 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}