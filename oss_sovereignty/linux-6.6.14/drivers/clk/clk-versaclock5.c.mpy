{
  "module_name": "clk-versaclock5.c",
  "hash_id": "93198c97fec3688ea2e88b9d2873ced863af34404572a37638ac8e9d7bb64abe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-versaclock5.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/clock/versaclock.h>\n\n \n#define VC5_OTP_CONTROL\t\t\t\t0x00\n\n \n#define VC5_RSVD_DEVICE_ID\t\t\t0x01\n#define VC5_RSVD_ADC_GAIN_7_0\t\t\t0x02\n#define VC5_RSVD_ADC_GAIN_15_8\t\t\t0x03\n#define VC5_RSVD_ADC_OFFSET_7_0\t\t\t0x04\n#define VC5_RSVD_ADC_OFFSET_15_8\t\t0x05\n#define VC5_RSVD_TEMPY\t\t\t\t0x06\n#define VC5_RSVD_OFFSET_TBIN\t\t\t0x07\n#define VC5_RSVD_GAIN\t\t\t\t0x08\n#define VC5_RSVD_TEST_NP\t\t\t0x09\n#define VC5_RSVD_UNUSED\t\t\t\t0x0a\n#define VC5_RSVD_BANDGAP_TRIM_UP\t\t0x0b\n#define VC5_RSVD_BANDGAP_TRIM_DN\t\t0x0c\n#define VC5_RSVD_CLK_R_12_CLK_AMP_4\t\t0x0d\n#define VC5_RSVD_CLK_R_34_CLK_AMP_4\t\t0x0e\n#define VC5_RSVD_CLK_AMP_123\t\t\t0x0f\n\n \n#define VC5_PRIM_SRC_SHDN\t\t\t0x10\n#define VC5_PRIM_SRC_SHDN_EN_XTAL\t\tBIT(7)\n#define VC5_PRIM_SRC_SHDN_EN_CLKIN\t\tBIT(6)\n#define VC5_PRIM_SRC_SHDN_EN_DOUBLE_XTAL_FREQ\tBIT(3)\n#define VC5_PRIM_SRC_SHDN_SP\t\t\tBIT(1)\n#define VC5_PRIM_SRC_SHDN_EN_GBL_SHDN\t\tBIT(0)\n\n#define VC5_VCO_BAND\t\t\t\t0x11\n#define VC5_XTAL_X1_LOAD_CAP\t\t\t0x12\n#define VC5_XTAL_X2_LOAD_CAP\t\t\t0x13\n#define VC5_REF_DIVIDER\t\t\t\t0x15\n#define VC5_REF_DIVIDER_SEL_PREDIV2\t\tBIT(7)\n#define VC5_REF_DIVIDER_REF_DIV(n)\t\t((n) & 0x3f)\n\n#define VC5_VCO_CTRL_AND_PREDIV\t\t\t0x16\n#define VC5_VCO_CTRL_AND_PREDIV_BYPASS_PREDIV\tBIT(7)\n\n#define VC5_FEEDBACK_INT_DIV\t\t\t0x17\n#define VC5_FEEDBACK_INT_DIV_BITS\t\t0x18\n#define VC5_FEEDBACK_FRAC_DIV(n)\t\t(0x19 + (n))\n#define VC5_RC_CONTROL0\t\t\t\t0x1e\n#define VC5_RC_CONTROL1\t\t\t\t0x1f\n\n \n#define VC5_RESERVED_X0(idx)\t\t(0x20 + ((idx) * 0x10))\n#define VC5_RESERVED_X0_BYPASS_SYNC\tBIT(7)  \n\n \n#define VC5_OUT_DIV_CONTROL(idx)\t(0x21 + ((idx) * 0x10))\n#define VC5_OUT_DIV_CONTROL_RESET\tBIT(7)\n#define VC5_OUT_DIV_CONTROL_SELB_NORM\tBIT(3)\n#define VC5_OUT_DIV_CONTROL_SEL_EXT\tBIT(2)\n#define VC5_OUT_DIV_CONTROL_INT_MODE\tBIT(1)\n#define VC5_OUT_DIV_CONTROL_EN_FOD\tBIT(0)\n\n#define VC5_OUT_DIV_FRAC(idx, n)\t(0x22 + ((idx) * 0x10) + (n))\n#define VC5_OUT_DIV_FRAC4_OD_SCEE\tBIT(1)\n\n#define VC5_OUT_DIV_STEP_SPREAD(idx, n)\t(0x26 + ((idx) * 0x10) + (n))\n#define VC5_OUT_DIV_SPREAD_MOD(idx, n)\t(0x29 + ((idx) * 0x10) + (n))\n#define VC5_OUT_DIV_SKEW_INT(idx, n)\t(0x2b + ((idx) * 0x10) + (n))\n#define VC5_OUT_DIV_INT(idx, n)\t\t(0x2d + ((idx) * 0x10) + (n))\n#define VC5_OUT_DIV_SKEW_FRAC(idx)\t(0x2f + ((idx) * 0x10))\n\n \n#define VC5_CLK_OUTPUT_CFG(idx, n)\t(0x60 + ((idx) * 0x2) + (n))\n#define VC5_CLK_OUTPUT_CFG0_CFG_SHIFT\t5\n#define VC5_CLK_OUTPUT_CFG0_CFG_MASK GENMASK(7, VC5_CLK_OUTPUT_CFG0_CFG_SHIFT)\n\n#define VC5_CLK_OUTPUT_CFG0_CFG_LVPECL\t(VC5_LVPECL)\n#define VC5_CLK_OUTPUT_CFG0_CFG_CMOS\t\t(VC5_CMOS)\n#define VC5_CLK_OUTPUT_CFG0_CFG_HCSL33\t(VC5_HCSL33)\n#define VC5_CLK_OUTPUT_CFG0_CFG_LVDS\t\t(VC5_LVDS)\n#define VC5_CLK_OUTPUT_CFG0_CFG_CMOS2\t\t(VC5_CMOS2)\n#define VC5_CLK_OUTPUT_CFG0_CFG_CMOSD\t\t(VC5_CMOSD)\n#define VC5_CLK_OUTPUT_CFG0_CFG_HCSL25\t(VC5_HCSL25)\n\n#define VC5_CLK_OUTPUT_CFG0_PWR_SHIFT\t3\n#define VC5_CLK_OUTPUT_CFG0_PWR_MASK GENMASK(4, VC5_CLK_OUTPUT_CFG0_PWR_SHIFT)\n#define VC5_CLK_OUTPUT_CFG0_PWR_18\t(0<<VC5_CLK_OUTPUT_CFG0_PWR_SHIFT)\n#define VC5_CLK_OUTPUT_CFG0_PWR_25\t(2<<VC5_CLK_OUTPUT_CFG0_PWR_SHIFT)\n#define VC5_CLK_OUTPUT_CFG0_PWR_33\t(3<<VC5_CLK_OUTPUT_CFG0_PWR_SHIFT)\n#define VC5_CLK_OUTPUT_CFG0_SLEW_SHIFT\t0\n#define VC5_CLK_OUTPUT_CFG0_SLEW_MASK GENMASK(1, VC5_CLK_OUTPUT_CFG0_SLEW_SHIFT)\n#define VC5_CLK_OUTPUT_CFG0_SLEW_80\t(0<<VC5_CLK_OUTPUT_CFG0_SLEW_SHIFT)\n#define VC5_CLK_OUTPUT_CFG0_SLEW_85\t(1<<VC5_CLK_OUTPUT_CFG0_SLEW_SHIFT)\n#define VC5_CLK_OUTPUT_CFG0_SLEW_90\t(2<<VC5_CLK_OUTPUT_CFG0_SLEW_SHIFT)\n#define VC5_CLK_OUTPUT_CFG0_SLEW_100\t(3<<VC5_CLK_OUTPUT_CFG0_SLEW_SHIFT)\n#define VC5_CLK_OUTPUT_CFG1_EN_CLKBUF\tBIT(0)\n\n#define VC5_CLK_OE_SHDN\t\t\t\t0x68\n#define VC5_CLK_OS_SHDN\t\t\t\t0x69\n\n#define VC5_GLOBAL_REGISTER\t\t\t0x76\n#define VC5_GLOBAL_REGISTER_GLOBAL_RESET\tBIT(5)\n\n \n#define VC5_PLL_VCO_MIN\t\t\t\t2500000000UL\n\n \n#define VC5_MUX_IN_XIN\t\tBIT(0)\n#define VC5_MUX_IN_CLKIN\tBIT(1)\n\n \n#define VC5_MAX_CLK_OUT_NUM\t5\n\n \n#define VC5_MAX_FOD_NUM\t4\n\n \n \n#define VC5_HAS_INTERNAL_XTAL\tBIT(0)\n \n#define VC5_HAS_PFD_FREQ_DBL\tBIT(1)\n \n#define VC5_HAS_BYPASS_SYNC_BIT\tBIT(2)\n\n \nenum vc5_model {\n\tIDT_VC5_5P49V5923,\n\tIDT_VC5_5P49V5925,\n\tIDT_VC5_5P49V5933,\n\tIDT_VC5_5P49V5935,\n\tIDT_VC6_5P49V60,\n\tIDT_VC6_5P49V6901,\n\tIDT_VC6_5P49V6965,\n\tIDT_VC6_5P49V6975,\n};\n\n \nstruct vc5_chip_info {\n\tconst enum vc5_model\tmodel;\n\tconst unsigned int\tclk_fod_cnt;\n\tconst unsigned int\tclk_out_cnt;\n\tconst u32\t\tflags;\n\tconst unsigned long\tvco_max;\n};\n\nstruct vc5_driver_data;\n\nstruct vc5_hw_data {\n\tstruct clk_hw\t\thw;\n\tstruct vc5_driver_data\t*vc5;\n\tu32\t\t\tdiv_int;\n\tu32\t\t\tdiv_frc;\n\tunsigned int\t\tnum;\n};\n\nstruct vc5_out_data {\n\tstruct clk_hw\t\thw;\n\tstruct vc5_driver_data\t*vc5;\n\tunsigned int\t\tnum;\n\tunsigned int\t\tclk_output_cfg0;\n\tunsigned int\t\tclk_output_cfg0_mask;\n};\n\nstruct vc5_driver_data {\n\tstruct i2c_client\t*client;\n\tstruct regmap\t\t*regmap;\n\tconst struct vc5_chip_info\t*chip_info;\n\n\tstruct clk\t\t*pin_xin;\n\tstruct clk\t\t*pin_clkin;\n\tunsigned char\t\tclk_mux_ins;\n\tstruct clk_hw\t\tclk_mux;\n\tstruct clk_hw\t\tclk_mul;\n\tstruct clk_hw\t\tclk_pfd;\n\tstruct vc5_hw_data\tclk_pll;\n\tstruct vc5_hw_data\tclk_fod[VC5_MAX_FOD_NUM];\n\tstruct vc5_out_data\tclk_out[VC5_MAX_CLK_OUT_NUM];\n};\n\n \nstatic bool vc5_regmap_is_writeable(struct device *dev, unsigned int reg)\n{\n\t \n\tif (reg <= 0xf)\n\t\treturn false;\n\n\t \n\tif (reg == 0x14 || reg == 0x1c || reg == 0x1d)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic const struct regmap_config vc5_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = 0x76,\n\t.writeable_reg = vc5_regmap_is_writeable,\n};\n\n \nstatic unsigned char vc5_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct vc5_driver_data *vc5 =\n\t\tcontainer_of(hw, struct vc5_driver_data, clk_mux);\n\tconst u8 mask = VC5_PRIM_SRC_SHDN_EN_XTAL | VC5_PRIM_SRC_SHDN_EN_CLKIN;\n\tunsigned int src;\n\tint ret;\n\n\tret = regmap_read(vc5->regmap, VC5_PRIM_SRC_SHDN, &src);\n\tif (ret)\n\t\treturn 0;\n\n\tsrc &= mask;\n\n\tif (src == VC5_PRIM_SRC_SHDN_EN_XTAL)\n\t\treturn 0;\n\n\tif (src == VC5_PRIM_SRC_SHDN_EN_CLKIN)\n\t\treturn 1;\n\n\tdev_warn(&vc5->client->dev,\n\t\t \"Invalid clock input configuration (%02x)\\n\", src);\n\treturn 0;\n}\n\nstatic int vc5_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct vc5_driver_data *vc5 =\n\t\tcontainer_of(hw, struct vc5_driver_data, clk_mux);\n\tconst u8 mask = VC5_PRIM_SRC_SHDN_EN_XTAL | VC5_PRIM_SRC_SHDN_EN_CLKIN;\n\tu8 src;\n\n\tif ((index > 1) || !vc5->clk_mux_ins)\n\t\treturn -EINVAL;\n\n\tif (vc5->clk_mux_ins == (VC5_MUX_IN_CLKIN | VC5_MUX_IN_XIN)) {\n\t\tif (index == 0)\n\t\t\tsrc = VC5_PRIM_SRC_SHDN_EN_XTAL;\n\t\tif (index == 1)\n\t\t\tsrc = VC5_PRIM_SRC_SHDN_EN_CLKIN;\n\t} else {\n\t\tif (index != 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (vc5->clk_mux_ins == VC5_MUX_IN_XIN)\n\t\t\tsrc = VC5_PRIM_SRC_SHDN_EN_XTAL;\n\t\telse if (vc5->clk_mux_ins == VC5_MUX_IN_CLKIN)\n\t\t\tsrc = VC5_PRIM_SRC_SHDN_EN_CLKIN;\n\t\telse  \n\t\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(vc5->regmap, VC5_PRIM_SRC_SHDN, mask, src);\n}\n\nstatic const struct clk_ops vc5_mux_ops = {\n\t.determine_rate\t= clk_hw_determine_rate_no_reparent,\n\t.set_parent\t= vc5_mux_set_parent,\n\t.get_parent\t= vc5_mux_get_parent,\n};\n\nstatic unsigned long vc5_dbl_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct vc5_driver_data *vc5 =\n\t\tcontainer_of(hw, struct vc5_driver_data, clk_mul);\n\tunsigned int premul;\n\tint ret;\n\n\tret = regmap_read(vc5->regmap, VC5_PRIM_SRC_SHDN, &premul);\n\tif (ret)\n\t\treturn 0;\n\n\tif (premul & VC5_PRIM_SRC_SHDN_EN_DOUBLE_XTAL_FREQ)\n\t\tparent_rate *= 2;\n\n\treturn parent_rate;\n}\n\nstatic long vc5_dbl_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\tif ((*parent_rate == rate) || ((*parent_rate * 2) == rate))\n\t\treturn rate;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic int vc5_dbl_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct vc5_driver_data *vc5 =\n\t\tcontainer_of(hw, struct vc5_driver_data, clk_mul);\n\tu32 mask;\n\n\tif ((parent_rate * 2) == rate)\n\t\tmask = VC5_PRIM_SRC_SHDN_EN_DOUBLE_XTAL_FREQ;\n\telse\n\t\tmask = 0;\n\n\treturn regmap_update_bits(vc5->regmap, VC5_PRIM_SRC_SHDN,\n\t\t\t\t  VC5_PRIM_SRC_SHDN_EN_DOUBLE_XTAL_FREQ,\n\t\t\t\t  mask);\n}\n\nstatic const struct clk_ops vc5_dbl_ops = {\n\t.recalc_rate\t= vc5_dbl_recalc_rate,\n\t.round_rate\t= vc5_dbl_round_rate,\n\t.set_rate\t= vc5_dbl_set_rate,\n};\n\nstatic unsigned long vc5_pfd_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct vc5_driver_data *vc5 =\n\t\tcontainer_of(hw, struct vc5_driver_data, clk_pfd);\n\tunsigned int prediv, div;\n\tint ret;\n\n\tret = regmap_read(vc5->regmap, VC5_VCO_CTRL_AND_PREDIV, &prediv);\n\tif (ret)\n\t\treturn 0;\n\n\t \n\tif (prediv & VC5_VCO_CTRL_AND_PREDIV_BYPASS_PREDIV)\n\t\treturn parent_rate;\n\n\tret = regmap_read(vc5->regmap, VC5_REF_DIVIDER, &div);\n\tif (ret)\n\t\treturn 0;\n\n\t \n\tif (div & VC5_REF_DIVIDER_SEL_PREDIV2)\n\t\treturn parent_rate / 2;\n\telse\n\t\treturn parent_rate / VC5_REF_DIVIDER_REF_DIV(div);\n}\n\nstatic long vc5_pfd_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\tunsigned long idiv;\n\n\t \n\tif (rate > 50000000)\n\t\treturn -EINVAL;\n\n\t \n\tif (*parent_rate <= 50000000)\n\t\treturn *parent_rate;\n\n\tidiv = DIV_ROUND_UP(*parent_rate, rate);\n\tif (idiv > 127)\n\t\treturn -EINVAL;\n\n\treturn *parent_rate / idiv;\n}\n\nstatic int vc5_pfd_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct vc5_driver_data *vc5 =\n\t\tcontainer_of(hw, struct vc5_driver_data, clk_pfd);\n\tunsigned long idiv;\n\tint ret;\n\tu8 div;\n\n\t \n\tif (parent_rate <= 50000000) {\n\t\tret = regmap_set_bits(vc5->regmap, VC5_VCO_CTRL_AND_PREDIV,\n\t\t\t\t      VC5_VCO_CTRL_AND_PREDIV_BYPASS_PREDIV);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn regmap_update_bits(vc5->regmap, VC5_REF_DIVIDER, 0xff, 0x00);\n\t}\n\n\tidiv = DIV_ROUND_UP(parent_rate, rate);\n\n\t \n\tif (idiv == 2)\n\t\tdiv = VC5_REF_DIVIDER_SEL_PREDIV2;\n\telse\n\t\tdiv = VC5_REF_DIVIDER_REF_DIV(idiv);\n\n\tret = regmap_update_bits(vc5->regmap, VC5_REF_DIVIDER, 0xff, div);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_clear_bits(vc5->regmap, VC5_VCO_CTRL_AND_PREDIV,\n\t\t\t\t VC5_VCO_CTRL_AND_PREDIV_BYPASS_PREDIV);\n}\n\nstatic const struct clk_ops vc5_pfd_ops = {\n\t.recalc_rate\t= vc5_pfd_recalc_rate,\n\t.round_rate\t= vc5_pfd_round_rate,\n\t.set_rate\t= vc5_pfd_set_rate,\n};\n\n \nstatic unsigned long vc5_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct vc5_hw_data *hwdata = container_of(hw, struct vc5_hw_data, hw);\n\tstruct vc5_driver_data *vc5 = hwdata->vc5;\n\tu32 div_int, div_frc;\n\tu8 fb[5];\n\n\tregmap_bulk_read(vc5->regmap, VC5_FEEDBACK_INT_DIV, fb, 5);\n\n\tdiv_int = (fb[0] << 4) | (fb[1] >> 4);\n\tdiv_frc = (fb[2] << 16) | (fb[3] << 8) | fb[4];\n\n\t \n\treturn (parent_rate * div_int) + ((parent_rate * div_frc) >> 24);\n}\n\nstatic long vc5_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\tstruct vc5_hw_data *hwdata = container_of(hw, struct vc5_hw_data, hw);\n\tstruct vc5_driver_data *vc5 = hwdata->vc5;\n\tu32 div_int;\n\tu64 div_frc;\n\n\trate = clamp(rate, VC5_PLL_VCO_MIN, vc5->chip_info->vco_max);\n\n\t \n\tdiv_int = rate / *parent_rate;\n\tif (div_int > 0xfff)\n\t\trate = *parent_rate * 0xfff;\n\n\t \n\tdiv_frc = rate % *parent_rate;\n\tdiv_frc *= BIT(24) - 1;\n\tdo_div(div_frc, *parent_rate);\n\n\thwdata->div_int = div_int;\n\thwdata->div_frc = (u32)div_frc;\n\n\treturn (*parent_rate * div_int) + ((*parent_rate * div_frc) >> 24);\n}\n\nstatic int vc5_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct vc5_hw_data *hwdata = container_of(hw, struct vc5_hw_data, hw);\n\tstruct vc5_driver_data *vc5 = hwdata->vc5;\n\tu8 fb[5];\n\n\tfb[0] = hwdata->div_int >> 4;\n\tfb[1] = hwdata->div_int << 4;\n\tfb[2] = hwdata->div_frc >> 16;\n\tfb[3] = hwdata->div_frc >> 8;\n\tfb[4] = hwdata->div_frc;\n\n\treturn regmap_bulk_write(vc5->regmap, VC5_FEEDBACK_INT_DIV, fb, 5);\n}\n\nstatic const struct clk_ops vc5_pll_ops = {\n\t.recalc_rate\t= vc5_pll_recalc_rate,\n\t.round_rate\t= vc5_pll_round_rate,\n\t.set_rate\t= vc5_pll_set_rate,\n};\n\nstatic unsigned long vc5_fod_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct vc5_hw_data *hwdata = container_of(hw, struct vc5_hw_data, hw);\n\tstruct vc5_driver_data *vc5 = hwdata->vc5;\n\t \n\tu32 f_in = parent_rate / 2;\n\tu32 div_int, div_frc;\n\tu8 od_int[2];\n\tu8 od_frc[4];\n\n\tregmap_bulk_read(vc5->regmap, VC5_OUT_DIV_INT(hwdata->num, 0),\n\t\t\t od_int, 2);\n\tregmap_bulk_read(vc5->regmap, VC5_OUT_DIV_FRAC(hwdata->num, 0),\n\t\t\t od_frc, 4);\n\n\tdiv_int = (od_int[0] << 4) | (od_int[1] >> 4);\n\tdiv_frc = (od_frc[0] << 22) | (od_frc[1] << 14) |\n\t\t  (od_frc[2] << 6) | (od_frc[3] >> 2);\n\n\t \n\tif (div_int == 0 && div_frc == 0)\n\t\treturn 0;\n\n\t \n\treturn div64_u64((u64)f_in << 24ULL, ((u64)div_int << 24ULL) + div_frc);\n}\n\nstatic long vc5_fod_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\tstruct vc5_hw_data *hwdata = container_of(hw, struct vc5_hw_data, hw);\n\t \n\tu32 f_in = *parent_rate / 2;\n\tu32 div_int;\n\tu64 div_frc;\n\n\t \n\tdiv_int = f_in / rate;\n\t \n\tif (div_int > 0xffe) {\n\t\tdiv_int = 0xffe;\n\t\trate = f_in / div_int;\n\t}\n\n\t \n\tdiv_frc = f_in % rate;\n\tdiv_frc <<= 24;\n\tdo_div(div_frc, rate);\n\n\thwdata->div_int = div_int;\n\thwdata->div_frc = (u32)div_frc;\n\n\treturn div64_u64((u64)f_in << 24ULL, ((u64)div_int << 24ULL) + div_frc);\n}\n\nstatic int vc5_fod_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct vc5_hw_data *hwdata = container_of(hw, struct vc5_hw_data, hw);\n\tstruct vc5_driver_data *vc5 = hwdata->vc5;\n\tu8 data[14] = {\n\t\thwdata->div_frc >> 22, hwdata->div_frc >> 14,\n\t\thwdata->div_frc >> 6, hwdata->div_frc << 2,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0,\n\t\thwdata->div_int >> 4, hwdata->div_int << 4,\n\t\t0\n\t};\n\tint ret;\n\n\tret = regmap_bulk_write(vc5->regmap, VC5_OUT_DIV_FRAC(hwdata->num, 0),\n\t\t\t\tdata, 14);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_clear_bits(vc5->regmap, VC5_GLOBAL_REGISTER,\n\t\t\t\tVC5_GLOBAL_REGISTER_GLOBAL_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_set_bits(vc5->regmap, VC5_GLOBAL_REGISTER,\n\t\t\t       VC5_GLOBAL_REGISTER_GLOBAL_RESET);\n}\n\nstatic const struct clk_ops vc5_fod_ops = {\n\t.recalc_rate\t= vc5_fod_recalc_rate,\n\t.round_rate\t= vc5_fod_round_rate,\n\t.set_rate\t= vc5_fod_set_rate,\n};\n\nstatic int vc5_clk_out_prepare(struct clk_hw *hw)\n{\n\tstruct vc5_out_data *hwdata = container_of(hw, struct vc5_out_data, hw);\n\tstruct vc5_driver_data *vc5 = hwdata->vc5;\n\tconst u8 mask = VC5_OUT_DIV_CONTROL_SELB_NORM |\n\t\t\tVC5_OUT_DIV_CONTROL_SEL_EXT |\n\t\t\tVC5_OUT_DIV_CONTROL_EN_FOD;\n\tunsigned int src;\n\tint ret;\n\n\t \n\tif (vc5->chip_info->flags & VC5_HAS_BYPASS_SYNC_BIT) {\n\t\tret = regmap_set_bits(vc5->regmap,\n\t\t\t\t      VC5_RESERVED_X0(hwdata->num),\n\t\t\t\t      VC5_RESERVED_X0_BYPASS_SYNC);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_read(vc5->regmap, VC5_OUT_DIV_CONTROL(hwdata->num), &src);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((src & mask) == 0) {\n\t\tsrc = VC5_OUT_DIV_CONTROL_RESET | VC5_OUT_DIV_CONTROL_EN_FOD;\n\t\tret = regmap_update_bits(vc5->regmap,\n\t\t\t\t\t VC5_OUT_DIV_CONTROL(hwdata->num),\n\t\t\t\t\t mask | VC5_OUT_DIV_CONTROL_RESET, src);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_set_bits(vc5->regmap, VC5_CLK_OUTPUT_CFG(hwdata->num, 1),\n\t\t\t      VC5_CLK_OUTPUT_CFG1_EN_CLKBUF);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hwdata->clk_output_cfg0_mask) {\n\t\tdev_dbg(&vc5->client->dev, \"Update output %d mask 0x%0X val 0x%0X\\n\",\n\t\t\thwdata->num, hwdata->clk_output_cfg0_mask,\n\t\t\thwdata->clk_output_cfg0);\n\n\t\tret = regmap_update_bits(vc5->regmap,\n\t\t\t\t\t VC5_CLK_OUTPUT_CFG(hwdata->num, 0),\n\t\t\t\t\t hwdata->clk_output_cfg0_mask,\n\t\t\t\t\t hwdata->clk_output_cfg0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void vc5_clk_out_unprepare(struct clk_hw *hw)\n{\n\tstruct vc5_out_data *hwdata = container_of(hw, struct vc5_out_data, hw);\n\tstruct vc5_driver_data *vc5 = hwdata->vc5;\n\n\t \n\tregmap_clear_bits(vc5->regmap, VC5_CLK_OUTPUT_CFG(hwdata->num, 1),\n\t\t\t  VC5_CLK_OUTPUT_CFG1_EN_CLKBUF);\n}\n\nstatic unsigned char vc5_clk_out_get_parent(struct clk_hw *hw)\n{\n\tstruct vc5_out_data *hwdata = container_of(hw, struct vc5_out_data, hw);\n\tstruct vc5_driver_data *vc5 = hwdata->vc5;\n\tconst u8 mask = VC5_OUT_DIV_CONTROL_SELB_NORM |\n\t\t\tVC5_OUT_DIV_CONTROL_SEL_EXT |\n\t\t\tVC5_OUT_DIV_CONTROL_EN_FOD;\n\tconst u8 fodclkmask = VC5_OUT_DIV_CONTROL_SELB_NORM |\n\t\t\t      VC5_OUT_DIV_CONTROL_EN_FOD;\n\tconst u8 extclk = VC5_OUT_DIV_CONTROL_SELB_NORM |\n\t\t\t  VC5_OUT_DIV_CONTROL_SEL_EXT;\n\tunsigned int src;\n\tint ret;\n\n\tret = regmap_read(vc5->regmap, VC5_OUT_DIV_CONTROL(hwdata->num), &src);\n\tif (ret)\n\t\treturn 0;\n\n\tsrc &= mask;\n\n\tif (src == 0)\t \n\t\treturn 0;\n\n\tif ((src & fodclkmask) == VC5_OUT_DIV_CONTROL_EN_FOD)\n\t\treturn 0;\n\n\tif (src == extclk)\n\t\treturn 1;\n\n\tdev_warn(&vc5->client->dev,\n\t\t \"Invalid clock output configuration (%02x)\\n\", src);\n\treturn 0;\n}\n\nstatic int vc5_clk_out_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct vc5_out_data *hwdata = container_of(hw, struct vc5_out_data, hw);\n\tstruct vc5_driver_data *vc5 = hwdata->vc5;\n\tconst u8 mask = VC5_OUT_DIV_CONTROL_RESET |\n\t\t\tVC5_OUT_DIV_CONTROL_SELB_NORM |\n\t\t\tVC5_OUT_DIV_CONTROL_SEL_EXT |\n\t\t\tVC5_OUT_DIV_CONTROL_EN_FOD;\n\tconst u8 extclk = VC5_OUT_DIV_CONTROL_SELB_NORM |\n\t\t\t  VC5_OUT_DIV_CONTROL_SEL_EXT;\n\tu8 src = VC5_OUT_DIV_CONTROL_RESET;\n\n\tif (index == 0)\n\t\tsrc |= VC5_OUT_DIV_CONTROL_EN_FOD;\n\telse\n\t\tsrc |= extclk;\n\n\treturn regmap_update_bits(vc5->regmap, VC5_OUT_DIV_CONTROL(hwdata->num),\n\t\t\t\t  mask, src);\n}\n\nstatic const struct clk_ops vc5_clk_out_ops = {\n\t.prepare\t= vc5_clk_out_prepare,\n\t.unprepare\t= vc5_clk_out_unprepare,\n\t.determine_rate\t= clk_hw_determine_rate_no_reparent,\n\t.set_parent\t= vc5_clk_out_set_parent,\n\t.get_parent\t= vc5_clk_out_get_parent,\n};\n\nstatic struct clk_hw *vc5_of_clk_get(struct of_phandle_args *clkspec,\n\t\t\t\t     void *data)\n{\n\tstruct vc5_driver_data *vc5 = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= vc5->chip_info->clk_out_cnt)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn &vc5->clk_out[idx].hw;\n}\n\nstatic int vc5_map_index_to_output(const enum vc5_model model,\n\t\t\t\t   const unsigned int n)\n{\n\tswitch (model) {\n\tcase IDT_VC5_5P49V5933:\n\t\treturn (n == 0) ? 0 : 3;\n\tcase IDT_VC5_5P49V5923:\n\tcase IDT_VC5_5P49V5925:\n\tcase IDT_VC5_5P49V5935:\n\tcase IDT_VC6_5P49V6901:\n\tcase IDT_VC6_5P49V6965:\n\tcase IDT_VC6_5P49V6975:\n\tdefault:\n\t\treturn n;\n\t}\n}\n\nstatic int vc5_update_mode(struct device_node *np_output,\n\t\t\t   struct vc5_out_data *clk_out)\n{\n\tu32 value;\n\n\tif (!of_property_read_u32(np_output, \"idt,mode\", &value)) {\n\t\tclk_out->clk_output_cfg0_mask |= VC5_CLK_OUTPUT_CFG0_CFG_MASK;\n\t\tswitch (value) {\n\t\tcase VC5_CLK_OUTPUT_CFG0_CFG_LVPECL:\n\t\tcase VC5_CLK_OUTPUT_CFG0_CFG_CMOS:\n\t\tcase VC5_CLK_OUTPUT_CFG0_CFG_HCSL33:\n\t\tcase VC5_CLK_OUTPUT_CFG0_CFG_LVDS:\n\t\tcase VC5_CLK_OUTPUT_CFG0_CFG_CMOS2:\n\t\tcase VC5_CLK_OUTPUT_CFG0_CFG_CMOSD:\n\t\tcase VC5_CLK_OUTPUT_CFG0_CFG_HCSL25:\n\t\t\tclk_out->clk_output_cfg0 |=\n\t\t\t    value << VC5_CLK_OUTPUT_CFG0_CFG_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int vc5_update_power(struct device_node *np_output,\n\t\t\t    struct vc5_out_data *clk_out)\n{\n\tu32 value;\n\n\tif (!of_property_read_u32(np_output, \"idt,voltage-microvolt\",\n\t\t\t\t  &value)) {\n\t\tclk_out->clk_output_cfg0_mask |= VC5_CLK_OUTPUT_CFG0_PWR_MASK;\n\t\tswitch (value) {\n\t\tcase 1800000:\n\t\t\tclk_out->clk_output_cfg0 |= VC5_CLK_OUTPUT_CFG0_PWR_18;\n\t\t\tbreak;\n\t\tcase 2500000:\n\t\t\tclk_out->clk_output_cfg0 |= VC5_CLK_OUTPUT_CFG0_PWR_25;\n\t\t\tbreak;\n\t\tcase 3300000:\n\t\t\tclk_out->clk_output_cfg0 |= VC5_CLK_OUTPUT_CFG0_PWR_33;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int vc5_map_cap_value(u32 femtofarads)\n{\n\tint mapped_value;\n\n\t \n\tif (femtofarads < 9000 || femtofarads > 22760)\n\t\treturn -EINVAL;\n\n\t \n\tmapped_value = DIV_ROUND_CLOSEST(femtofarads - 9000, 430);\n\n\t \n\tif (mapped_value > 31)\n\t\tmapped_value = 0x3f;\n\telse\n\t\tmapped_value <<= 1;\n\n\treturn mapped_value;\n}\nstatic int vc5_update_cap_load(struct device_node *node, struct vc5_driver_data *vc5)\n{\n\tu32 value;\n\tint mapped_value;\n\tint ret;\n\n\tif (of_property_read_u32(node, \"idt,xtal-load-femtofarads\", &value))\n\t\treturn 0;\n\n\tmapped_value = vc5_map_cap_value(value);\n\tif (mapped_value < 0)\n\t\treturn mapped_value;\n\n\t \n\tret = regmap_update_bits(vc5->regmap, VC5_XTAL_X1_LOAD_CAP, ~0x03,\n\t\t\t\t mapped_value << 2);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(vc5->regmap, VC5_XTAL_X2_LOAD_CAP, ~0x03,\n\t\t\t\t  mapped_value << 2);\n}\n\nstatic int vc5_update_slew(struct device_node *np_output,\n\t\t\t   struct vc5_out_data *clk_out)\n{\n\tu32 value;\n\n\tif (!of_property_read_u32(np_output, \"idt,slew-percent\", &value)) {\n\t\tclk_out->clk_output_cfg0_mask |= VC5_CLK_OUTPUT_CFG0_SLEW_MASK;\n\t\tswitch (value) {\n\t\tcase 80:\n\t\t\tclk_out->clk_output_cfg0 |= VC5_CLK_OUTPUT_CFG0_SLEW_80;\n\t\t\tbreak;\n\t\tcase 85:\n\t\t\tclk_out->clk_output_cfg0 |= VC5_CLK_OUTPUT_CFG0_SLEW_85;\n\t\t\tbreak;\n\t\tcase 90:\n\t\t\tclk_out->clk_output_cfg0 |= VC5_CLK_OUTPUT_CFG0_SLEW_90;\n\t\t\tbreak;\n\t\tcase 100:\n\t\t\tclk_out->clk_output_cfg0 |=\n\t\t\t    VC5_CLK_OUTPUT_CFG0_SLEW_100;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int vc5_get_output_config(struct i2c_client *client,\n\t\t\t\t struct vc5_out_data *clk_out)\n{\n\tstruct device_node *np_output;\n\tchar *child_name;\n\tint ret = 0;\n\n\tchild_name = kasprintf(GFP_KERNEL, \"OUT%d\", clk_out->num + 1);\n\tif (!child_name)\n\t\treturn -ENOMEM;\n\n\tnp_output = of_get_child_by_name(client->dev.of_node, child_name);\n\tkfree(child_name);\n\tif (!np_output)\n\t\treturn 0;\n\n\tret = vc5_update_mode(np_output, clk_out);\n\tif (ret)\n\t\tgoto output_error;\n\n\tret = vc5_update_power(np_output, clk_out);\n\tif (ret)\n\t\tgoto output_error;\n\n\tret = vc5_update_slew(np_output, clk_out);\n\noutput_error:\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Invalid clock output configuration OUT%d\\n\",\n\t\t\tclk_out->num + 1);\n\t}\n\n\tof_node_put(np_output);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id clk_vc5_of_match[];\n\nstatic int vc5_probe(struct i2c_client *client)\n{\n\tunsigned int oe, sd, src_mask = 0, src_val = 0;\n\tstruct vc5_driver_data *vc5;\n\tstruct clk_init_data init;\n\tconst char *parent_names[2];\n\tunsigned int n, idx = 0;\n\tint ret;\n\n\tvc5 = devm_kzalloc(&client->dev, sizeof(*vc5), GFP_KERNEL);\n\tif (!vc5)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, vc5);\n\tvc5->client = client;\n\tvc5->chip_info = i2c_get_match_data(client);\n\n\tvc5->pin_xin = devm_clk_get(&client->dev, \"xin\");\n\tif (PTR_ERR(vc5->pin_xin) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tvc5->pin_clkin = devm_clk_get(&client->dev, \"clkin\");\n\tif (PTR_ERR(vc5->pin_clkin) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tvc5->regmap = devm_regmap_init_i2c(client, &vc5_regmap_config);\n\tif (IS_ERR(vc5->regmap))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(vc5->regmap),\n\t\t\t\t     \"failed to allocate register map\\n\");\n\n\tret = of_property_read_u32(client->dev.of_node, \"idt,shutdown\", &sd);\n\tif (!ret) {\n\t\tsrc_mask |= VC5_PRIM_SRC_SHDN_EN_GBL_SHDN;\n\t\tif (sd)\n\t\t\tsrc_val |= VC5_PRIM_SRC_SHDN_EN_GBL_SHDN;\n\t} else if (ret != -EINVAL) {\n\t\treturn dev_err_probe(&client->dev, ret,\n\t\t\t\t     \"could not read idt,shutdown\\n\");\n\t}\n\n\tret = of_property_read_u32(client->dev.of_node,\n\t\t\t\t   \"idt,output-enable-active\", &oe);\n\tif (!ret) {\n\t\tsrc_mask |= VC5_PRIM_SRC_SHDN_SP;\n\t\tif (oe)\n\t\t\tsrc_val |= VC5_PRIM_SRC_SHDN_SP;\n\t} else if (ret != -EINVAL) {\n\t\treturn dev_err_probe(&client->dev, ret,\n\t\t\t\t     \"could not read idt,output-enable-active\\n\");\n\t}\n\n\tret = regmap_update_bits(vc5->regmap, VC5_PRIM_SRC_SHDN, src_mask,\n\t\t\t\t src_val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmemset(&init, 0, sizeof(init));\n\n\tif (!IS_ERR(vc5->pin_xin)) {\n\t\tvc5->clk_mux_ins |= VC5_MUX_IN_XIN;\n\t\tparent_names[init.num_parents++] = __clk_get_name(vc5->pin_xin);\n\t} else if (vc5->chip_info->flags & VC5_HAS_INTERNAL_XTAL) {\n\t\tvc5->pin_xin = clk_register_fixed_rate(&client->dev,\n\t\t\t\t\t\t       \"internal-xtal\", NULL,\n\t\t\t\t\t\t       0, 25000000);\n\t\tif (IS_ERR(vc5->pin_xin))\n\t\t\treturn PTR_ERR(vc5->pin_xin);\n\t\tvc5->clk_mux_ins |= VC5_MUX_IN_XIN;\n\t\tparent_names[init.num_parents++] = __clk_get_name(vc5->pin_xin);\n\t}\n\n\tif (!IS_ERR(vc5->pin_clkin)) {\n\t\tvc5->clk_mux_ins |= VC5_MUX_IN_CLKIN;\n\t\tparent_names[init.num_parents++] =\n\t\t    __clk_get_name(vc5->pin_clkin);\n\t}\n\n\tif (!init.num_parents)\n\t\treturn dev_err_probe(&client->dev, -EINVAL,\n\t\t\t\t     \"no input clock specified!\\n\");\n\n\t \n\tif (!(vc5->chip_info->flags & VC5_HAS_INTERNAL_XTAL)) {\n\t\tret = vc5_update_cap_load(client->dev.of_node, vc5);\n\t\tif (ret)\n\t\t\tgoto err_clk_register;\n\t}\n\n\tinit.name = kasprintf(GFP_KERNEL, \"%pOFn.mux\", client->dev.of_node);\n\tif (!init.name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_clk;\n\t}\n\n\tinit.ops = &vc5_mux_ops;\n\tinit.flags = 0;\n\tinit.parent_names = parent_names;\n\tvc5->clk_mux.init = &init;\n\tret = devm_clk_hw_register(&client->dev, &vc5->clk_mux);\n\tif (ret)\n\t\tgoto err_clk_register;\n\tkfree(init.name);\t \n\n\tif (vc5->chip_info->flags & VC5_HAS_PFD_FREQ_DBL) {\n\t\t \n\t\tmemset(&init, 0, sizeof(init));\n\t\tinit.name = kasprintf(GFP_KERNEL, \"%pOFn.dbl\",\n\t\t\t\t      client->dev.of_node);\n\t\tif (!init.name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_clk;\n\t\t}\n\t\tinit.ops = &vc5_dbl_ops;\n\t\tinit.flags = CLK_SET_RATE_PARENT;\n\t\tinit.parent_names = parent_names;\n\t\tparent_names[0] = clk_hw_get_name(&vc5->clk_mux);\n\t\tinit.num_parents = 1;\n\t\tvc5->clk_mul.init = &init;\n\t\tret = devm_clk_hw_register(&client->dev, &vc5->clk_mul);\n\t\tif (ret)\n\t\t\tgoto err_clk_register;\n\t\tkfree(init.name);  \n\t}\n\n\t \n\tmemset(&init, 0, sizeof(init));\n\tinit.name = kasprintf(GFP_KERNEL, \"%pOFn.pfd\", client->dev.of_node);\n\tif (!init.name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_clk;\n\t}\n\tinit.ops = &vc5_pfd_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = parent_names;\n\tif (vc5->chip_info->flags & VC5_HAS_PFD_FREQ_DBL)\n\t\tparent_names[0] = clk_hw_get_name(&vc5->clk_mul);\n\telse\n\t\tparent_names[0] = clk_hw_get_name(&vc5->clk_mux);\n\tinit.num_parents = 1;\n\tvc5->clk_pfd.init = &init;\n\tret = devm_clk_hw_register(&client->dev, &vc5->clk_pfd);\n\tif (ret)\n\t\tgoto err_clk_register;\n\tkfree(init.name);\t \n\n\t \n\tmemset(&init, 0, sizeof(init));\n\tinit.name = kasprintf(GFP_KERNEL, \"%pOFn.pll\", client->dev.of_node);\n\tif (!init.name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_clk;\n\t}\n\tinit.ops = &vc5_pll_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = parent_names;\n\tparent_names[0] = clk_hw_get_name(&vc5->clk_pfd);\n\tinit.num_parents = 1;\n\tvc5->clk_pll.num = 0;\n\tvc5->clk_pll.vc5 = vc5;\n\tvc5->clk_pll.hw.init = &init;\n\tret = devm_clk_hw_register(&client->dev, &vc5->clk_pll.hw);\n\tif (ret)\n\t\tgoto err_clk_register;\n\tkfree(init.name);  \n\n\t \n\tfor (n = 0; n < vc5->chip_info->clk_fod_cnt; n++) {\n\t\tidx = vc5_map_index_to_output(vc5->chip_info->model, n);\n\t\tmemset(&init, 0, sizeof(init));\n\t\tinit.name = kasprintf(GFP_KERNEL, \"%pOFn.fod%d\",\n\t\t\t\t      client->dev.of_node, idx);\n\t\tif (!init.name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_clk;\n\t\t}\n\t\tinit.ops = &vc5_fod_ops;\n\t\tinit.flags = CLK_SET_RATE_PARENT;\n\t\tinit.parent_names = parent_names;\n\t\tparent_names[0] = clk_hw_get_name(&vc5->clk_pll.hw);\n\t\tinit.num_parents = 1;\n\t\tvc5->clk_fod[n].num = idx;\n\t\tvc5->clk_fod[n].vc5 = vc5;\n\t\tvc5->clk_fod[n].hw.init = &init;\n\t\tret = devm_clk_hw_register(&client->dev, &vc5->clk_fod[n].hw);\n\t\tif (ret)\n\t\t\tgoto err_clk_register;\n\t\tkfree(init.name);  \n\t}\n\n\t \n\tmemset(&init, 0, sizeof(init));\n\tinit.name = kasprintf(GFP_KERNEL, \"%pOFn.out0_sel_i2cb\",\n\t\t\t      client->dev.of_node);\n\tif (!init.name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_clk;\n\t}\n\tinit.ops = &vc5_clk_out_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = parent_names;\n\tparent_names[0] = clk_hw_get_name(&vc5->clk_mux);\n\tinit.num_parents = 1;\n\tvc5->clk_out[0].num = idx;\n\tvc5->clk_out[0].vc5 = vc5;\n\tvc5->clk_out[0].hw.init = &init;\n\tret = devm_clk_hw_register(&client->dev, &vc5->clk_out[0].hw);\n\tif (ret)\n\t\tgoto err_clk_register;\n\tkfree(init.name);  \n\n\t \n\tfor (n = 1; n < vc5->chip_info->clk_out_cnt; n++) {\n\t\tidx = vc5_map_index_to_output(vc5->chip_info->model, n - 1);\n\t\tparent_names[0] = clk_hw_get_name(&vc5->clk_fod[idx].hw);\n\t\tif (n == 1)\n\t\t\tparent_names[1] = clk_hw_get_name(&vc5->clk_mux);\n\t\telse\n\t\t\tparent_names[1] =\n\t\t\t    clk_hw_get_name(&vc5->clk_out[n - 1].hw);\n\n\t\tmemset(&init, 0, sizeof(init));\n\t\tinit.name = kasprintf(GFP_KERNEL, \"%pOFn.out%d\",\n\t\t\t\t      client->dev.of_node, idx + 1);\n\t\tif (!init.name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_clk;\n\t\t}\n\t\tinit.ops = &vc5_clk_out_ops;\n\t\tinit.flags = CLK_SET_RATE_PARENT;\n\t\tinit.parent_names = parent_names;\n\t\tinit.num_parents = 2;\n\t\tvc5->clk_out[n].num = idx;\n\t\tvc5->clk_out[n].vc5 = vc5;\n\t\tvc5->clk_out[n].hw.init = &init;\n\t\tret = devm_clk_hw_register(&client->dev, &vc5->clk_out[n].hw);\n\t\tif (ret)\n\t\t\tgoto err_clk_register;\n\t\tkfree(init.name);  \n\n\t\t \n\t\tret = vc5_get_output_config(client, &vc5->clk_out[n]);\n\t\tif (ret)\n\t\t\tgoto err_clk;\n\t}\n\n\tret = of_clk_add_hw_provider(client->dev.of_node, vc5_of_clk_get, vc5);\n\tif (ret) {\n\t\tdev_err_probe(&client->dev, ret,\n\t\t\t      \"unable to add clk provider\\n\");\n\t\tgoto err_clk;\n\t}\n\n\treturn 0;\n\nerr_clk_register:\n\tdev_err_probe(&client->dev, ret,\n\t\t      \"unable to register %s\\n\", init.name);\n\tkfree(init.name);  \nerr_clk:\n\tif (vc5->chip_info->flags & VC5_HAS_INTERNAL_XTAL)\n\t\tclk_unregister_fixed_rate(vc5->pin_xin);\n\treturn ret;\n}\n\nstatic void vc5_remove(struct i2c_client *client)\n{\n\tstruct vc5_driver_data *vc5 = i2c_get_clientdata(client);\n\n\tof_clk_del_provider(client->dev.of_node);\n\n\tif (vc5->chip_info->flags & VC5_HAS_INTERNAL_XTAL)\n\t\tclk_unregister_fixed_rate(vc5->pin_xin);\n}\n\nstatic int __maybe_unused vc5_suspend(struct device *dev)\n{\n\tstruct vc5_driver_data *vc5 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(vc5->regmap, true);\n\tregcache_mark_dirty(vc5->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused vc5_resume(struct device *dev)\n{\n\tstruct vc5_driver_data *vc5 = dev_get_drvdata(dev);\n\tint ret;\n\n\tregcache_cache_only(vc5->regmap, false);\n\tret = regcache_sync(vc5->regmap);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to restore register map: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct vc5_chip_info idt_5p49v5923_info = {\n\t.model = IDT_VC5_5P49V5923,\n\t.clk_fod_cnt = 2,\n\t.clk_out_cnt = 3,\n\t.flags = 0,\n\t.vco_max = 3000000000UL,\n};\n\nstatic const struct vc5_chip_info idt_5p49v5925_info = {\n\t.model = IDT_VC5_5P49V5925,\n\t.clk_fod_cnt = 4,\n\t.clk_out_cnt = 5,\n\t.flags = 0,\n\t.vco_max = 3000000000UL,\n};\n\nstatic const struct vc5_chip_info idt_5p49v5933_info = {\n\t.model = IDT_VC5_5P49V5933,\n\t.clk_fod_cnt = 2,\n\t.clk_out_cnt = 3,\n\t.flags = VC5_HAS_INTERNAL_XTAL,\n\t.vco_max = 3000000000UL,\n};\n\nstatic const struct vc5_chip_info idt_5p49v5935_info = {\n\t.model = IDT_VC5_5P49V5935,\n\t.clk_fod_cnt = 4,\n\t.clk_out_cnt = 5,\n\t.flags = VC5_HAS_INTERNAL_XTAL,\n\t.vco_max = 3000000000UL,\n};\n\nstatic const struct vc5_chip_info idt_5p49v60_info = {\n\t.model = IDT_VC6_5P49V60,\n\t.clk_fod_cnt = 4,\n\t.clk_out_cnt = 5,\n\t.flags = VC5_HAS_PFD_FREQ_DBL | VC5_HAS_BYPASS_SYNC_BIT,\n\t.vco_max = 2700000000UL,\n};\n\nstatic const struct vc5_chip_info idt_5p49v6901_info = {\n\t.model = IDT_VC6_5P49V6901,\n\t.clk_fod_cnt = 4,\n\t.clk_out_cnt = 5,\n\t.flags = VC5_HAS_PFD_FREQ_DBL | VC5_HAS_BYPASS_SYNC_BIT,\n\t.vco_max = 3000000000UL,\n};\n\nstatic const struct vc5_chip_info idt_5p49v6965_info = {\n\t.model = IDT_VC6_5P49V6965,\n\t.clk_fod_cnt = 4,\n\t.clk_out_cnt = 5,\n\t.flags = VC5_HAS_BYPASS_SYNC_BIT,\n\t.vco_max = 3000000000UL,\n};\n\nstatic const struct vc5_chip_info idt_5p49v6975_info = {\n\t.model = IDT_VC6_5P49V6975,\n\t.clk_fod_cnt = 4,\n\t.clk_out_cnt = 5,\n\t.flags = VC5_HAS_BYPASS_SYNC_BIT | VC5_HAS_INTERNAL_XTAL,\n\t.vco_max = 3000000000UL,\n};\n\nstatic const struct i2c_device_id vc5_id[] = {\n\t{ \"5p49v5923\", .driver_data = (kernel_ulong_t)&idt_5p49v5923_info },\n\t{ \"5p49v5925\", .driver_data = (kernel_ulong_t)&idt_5p49v5925_info },\n\t{ \"5p49v5933\", .driver_data = (kernel_ulong_t)&idt_5p49v5933_info },\n\t{ \"5p49v5935\", .driver_data = (kernel_ulong_t)&idt_5p49v5935_info },\n\t{ \"5p49v60\", .driver_data = (kernel_ulong_t)&idt_5p49v60_info },\n\t{ \"5p49v6901\", .driver_data = (kernel_ulong_t)&idt_5p49v6901_info },\n\t{ \"5p49v6965\", .driver_data = (kernel_ulong_t)&idt_5p49v6965_info },\n\t{ \"5p49v6975\", .driver_data = (kernel_ulong_t)&idt_5p49v6975_info },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, vc5_id);\n\nstatic const struct of_device_id clk_vc5_of_match[] = {\n\t{ .compatible = \"idt,5p49v5923\", .data = &idt_5p49v5923_info },\n\t{ .compatible = \"idt,5p49v5925\", .data = &idt_5p49v5925_info },\n\t{ .compatible = \"idt,5p49v5933\", .data = &idt_5p49v5933_info },\n\t{ .compatible = \"idt,5p49v5935\", .data = &idt_5p49v5935_info },\n\t{ .compatible = \"idt,5p49v60\", .data = &idt_5p49v60_info },\n\t{ .compatible = \"idt,5p49v6901\", .data = &idt_5p49v6901_info },\n\t{ .compatible = \"idt,5p49v6965\", .data = &idt_5p49v6965_info },\n\t{ .compatible = \"idt,5p49v6975\", .data = &idt_5p49v6975_info },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, clk_vc5_of_match);\n\nstatic SIMPLE_DEV_PM_OPS(vc5_pm_ops, vc5_suspend, vc5_resume);\n\nstatic struct i2c_driver vc5_driver = {\n\t.driver = {\n\t\t.name = \"vc5\",\n\t\t.pm\t= &vc5_pm_ops,\n\t\t.of_match_table = clk_vc5_of_match,\n\t},\n\t.probe\t\t= vc5_probe,\n\t.remove\t\t= vc5_remove,\n\t.id_table\t= vc5_id,\n};\nmodule_i2c_driver(vc5_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marek.vasut@gmail.com>\");\nMODULE_DESCRIPTION(\"IDT VersaClock 5 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}