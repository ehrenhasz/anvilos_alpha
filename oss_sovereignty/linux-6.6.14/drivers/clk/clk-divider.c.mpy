{
  "module_name": "clk-divider.c",
  "hash_id": "30fc3fa0a434cec129b56195357bf998ec911615a395f8be5952460eccdefef3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-divider.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/log2.h>\n\n \n\nstatic inline u32 clk_div_readl(struct clk_divider *divider)\n{\n\tif (divider->flags & CLK_DIVIDER_BIG_ENDIAN)\n\t\treturn ioread32be(divider->reg);\n\n\treturn readl(divider->reg);\n}\n\nstatic inline void clk_div_writel(struct clk_divider *divider, u32 val)\n{\n\tif (divider->flags & CLK_DIVIDER_BIG_ENDIAN)\n\t\tiowrite32be(val, divider->reg);\n\telse\n\t\twritel(val, divider->reg);\n}\n\nstatic unsigned int _get_table_maxdiv(const struct clk_div_table *table,\n\t\t\t\t      u8 width)\n{\n\tunsigned int maxdiv = 0, mask = clk_div_mask(width);\n\tconst struct clk_div_table *clkt;\n\n\tfor (clkt = table; clkt->div; clkt++)\n\t\tif (clkt->div > maxdiv && clkt->val <= mask)\n\t\t\tmaxdiv = clkt->div;\n\treturn maxdiv;\n}\n\nstatic unsigned int _get_table_mindiv(const struct clk_div_table *table)\n{\n\tunsigned int mindiv = UINT_MAX;\n\tconst struct clk_div_table *clkt;\n\n\tfor (clkt = table; clkt->div; clkt++)\n\t\tif (clkt->div < mindiv)\n\t\t\tmindiv = clkt->div;\n\treturn mindiv;\n}\n\nstatic unsigned int _get_maxdiv(const struct clk_div_table *table, u8 width,\n\t\t\t\tunsigned long flags)\n{\n\tif (flags & CLK_DIVIDER_ONE_BASED)\n\t\treturn clk_div_mask(width);\n\tif (flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\treturn 1 << clk_div_mask(width);\n\tif (table)\n\t\treturn _get_table_maxdiv(table, width);\n\treturn clk_div_mask(width) + 1;\n}\n\nstatic unsigned int _get_table_div(const struct clk_div_table *table,\n\t\t\t\t\t\t\tunsigned int val)\n{\n\tconst struct clk_div_table *clkt;\n\n\tfor (clkt = table; clkt->div; clkt++)\n\t\tif (clkt->val == val)\n\t\t\treturn clkt->div;\n\treturn 0;\n}\n\nstatic unsigned int _get_div(const struct clk_div_table *table,\n\t\t\t     unsigned int val, unsigned long flags, u8 width)\n{\n\tif (flags & CLK_DIVIDER_ONE_BASED)\n\t\treturn val;\n\tif (flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\treturn 1 << val;\n\tif (flags & CLK_DIVIDER_MAX_AT_ZERO)\n\t\treturn val ? val : clk_div_mask(width) + 1;\n\tif (table)\n\t\treturn _get_table_div(table, val);\n\treturn val + 1;\n}\n\nstatic unsigned int _get_table_val(const struct clk_div_table *table,\n\t\t\t\t\t\t\tunsigned int div)\n{\n\tconst struct clk_div_table *clkt;\n\n\tfor (clkt = table; clkt->div; clkt++)\n\t\tif (clkt->div == div)\n\t\t\treturn clkt->val;\n\treturn 0;\n}\n\nstatic unsigned int _get_val(const struct clk_div_table *table,\n\t\t\t     unsigned int div, unsigned long flags, u8 width)\n{\n\tif (flags & CLK_DIVIDER_ONE_BASED)\n\t\treturn div;\n\tif (flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\treturn __ffs(div);\n\tif (flags & CLK_DIVIDER_MAX_AT_ZERO)\n\t\treturn (div == clk_div_mask(width) + 1) ? 0 : div;\n\tif (table)\n\t\treturn  _get_table_val(table, div);\n\treturn div - 1;\n}\n\nunsigned long divider_recalc_rate(struct clk_hw *hw, unsigned long parent_rate,\n\t\t\t\t  unsigned int val,\n\t\t\t\t  const struct clk_div_table *table,\n\t\t\t\t  unsigned long flags, unsigned long width)\n{\n\tunsigned int div;\n\n\tdiv = _get_div(table, val, flags, width);\n\tif (!div) {\n\t\tWARN(!(flags & CLK_DIVIDER_ALLOW_ZERO),\n\t\t\t\"%s: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set\\n\",\n\t\t\tclk_hw_get_name(hw));\n\t\treturn parent_rate;\n\t}\n\n\treturn DIV_ROUND_UP_ULL((u64)parent_rate, div);\n}\nEXPORT_SYMBOL_GPL(divider_recalc_rate);\n\nstatic unsigned long clk_divider_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\tunsigned int val;\n\n\tval = clk_div_readl(divider) >> divider->shift;\n\tval &= clk_div_mask(divider->width);\n\n\treturn divider_recalc_rate(hw, parent_rate, val, divider->table,\n\t\t\t\t   divider->flags, divider->width);\n}\n\nstatic bool _is_valid_table_div(const struct clk_div_table *table,\n\t\t\t\t\t\t\t unsigned int div)\n{\n\tconst struct clk_div_table *clkt;\n\n\tfor (clkt = table; clkt->div; clkt++)\n\t\tif (clkt->div == div)\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic bool _is_valid_div(const struct clk_div_table *table, unsigned int div,\n\t\t\t  unsigned long flags)\n{\n\tif (flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\treturn is_power_of_2(div);\n\tif (table)\n\t\treturn _is_valid_table_div(table, div);\n\treturn true;\n}\n\nstatic int _round_up_table(const struct clk_div_table *table, int div)\n{\n\tconst struct clk_div_table *clkt;\n\tint up = INT_MAX;\n\n\tfor (clkt = table; clkt->div; clkt++) {\n\t\tif (clkt->div == div)\n\t\t\treturn clkt->div;\n\t\telse if (clkt->div < div)\n\t\t\tcontinue;\n\n\t\tif ((clkt->div - div) < (up - div))\n\t\t\tup = clkt->div;\n\t}\n\n\treturn up;\n}\n\nstatic int _round_down_table(const struct clk_div_table *table, int div)\n{\n\tconst struct clk_div_table *clkt;\n\tint down = _get_table_mindiv(table);\n\n\tfor (clkt = table; clkt->div; clkt++) {\n\t\tif (clkt->div == div)\n\t\t\treturn clkt->div;\n\t\telse if (clkt->div > div)\n\t\t\tcontinue;\n\n\t\tif ((div - clkt->div) < (div - down))\n\t\t\tdown = clkt->div;\n\t}\n\n\treturn down;\n}\n\nstatic int _div_round_up(const struct clk_div_table *table,\n\t\t\t unsigned long parent_rate, unsigned long rate,\n\t\t\t unsigned long flags)\n{\n\tint div = DIV_ROUND_UP_ULL((u64)parent_rate, rate);\n\n\tif (flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\tdiv = __roundup_pow_of_two(div);\n\tif (table)\n\t\tdiv = _round_up_table(table, div);\n\n\treturn div;\n}\n\nstatic int _div_round_closest(const struct clk_div_table *table,\n\t\t\t      unsigned long parent_rate, unsigned long rate,\n\t\t\t      unsigned long flags)\n{\n\tint up, down;\n\tunsigned long up_rate, down_rate;\n\n\tup = DIV_ROUND_UP_ULL((u64)parent_rate, rate);\n\tdown = parent_rate / rate;\n\n\tif (flags & CLK_DIVIDER_POWER_OF_TWO) {\n\t\tup = __roundup_pow_of_two(up);\n\t\tdown = __rounddown_pow_of_two(down);\n\t} else if (table) {\n\t\tup = _round_up_table(table, up);\n\t\tdown = _round_down_table(table, down);\n\t}\n\n\tup_rate = DIV_ROUND_UP_ULL((u64)parent_rate, up);\n\tdown_rate = DIV_ROUND_UP_ULL((u64)parent_rate, down);\n\n\treturn (rate - up_rate) <= (down_rate - rate) ? up : down;\n}\n\nstatic int _div_round(const struct clk_div_table *table,\n\t\t      unsigned long parent_rate, unsigned long rate,\n\t\t      unsigned long flags)\n{\n\tif (flags & CLK_DIVIDER_ROUND_CLOSEST)\n\t\treturn _div_round_closest(table, parent_rate, rate, flags);\n\n\treturn _div_round_up(table, parent_rate, rate, flags);\n}\n\nstatic bool _is_best_div(unsigned long rate, unsigned long now,\n\t\t\t unsigned long best, unsigned long flags)\n{\n\tif (flags & CLK_DIVIDER_ROUND_CLOSEST)\n\t\treturn abs(rate - now) < abs(rate - best);\n\n\treturn now <= rate && now > best;\n}\n\nstatic int _next_div(const struct clk_div_table *table, int div,\n\t\t     unsigned long flags)\n{\n\tdiv++;\n\n\tif (flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\treturn __roundup_pow_of_two(div);\n\tif (table)\n\t\treturn _round_up_table(table, div);\n\n\treturn div;\n}\n\nstatic int clk_divider_bestdiv(struct clk_hw *hw, struct clk_hw *parent,\n\t\t\t       unsigned long rate,\n\t\t\t       unsigned long *best_parent_rate,\n\t\t\t       const struct clk_div_table *table, u8 width,\n\t\t\t       unsigned long flags)\n{\n\tint i, bestdiv = 0;\n\tunsigned long parent_rate, best = 0, now, maxdiv;\n\tunsigned long parent_rate_saved = *best_parent_rate;\n\n\tif (!rate)\n\t\trate = 1;\n\n\tmaxdiv = _get_maxdiv(table, width, flags);\n\n\tif (!(clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)) {\n\t\tparent_rate = *best_parent_rate;\n\t\tbestdiv = _div_round(table, parent_rate, rate, flags);\n\t\tbestdiv = bestdiv == 0 ? 1 : bestdiv;\n\t\tbestdiv = bestdiv > maxdiv ? maxdiv : bestdiv;\n\t\treturn bestdiv;\n\t}\n\n\t \n\tmaxdiv = min(ULONG_MAX / rate, maxdiv);\n\n\tfor (i = _next_div(table, 0, flags); i <= maxdiv;\n\t\t\t\t\t     i = _next_div(table, i, flags)) {\n\t\tif (rate * i == parent_rate_saved) {\n\t\t\t \n\t\t\t*best_parent_rate = parent_rate_saved;\n\t\t\treturn i;\n\t\t}\n\t\tparent_rate = clk_hw_round_rate(parent, rate * i);\n\t\tnow = DIV_ROUND_UP_ULL((u64)parent_rate, i);\n\t\tif (_is_best_div(rate, now, best, flags)) {\n\t\t\tbestdiv = i;\n\t\t\tbest = now;\n\t\t\t*best_parent_rate = parent_rate;\n\t\t}\n\t}\n\n\tif (!bestdiv) {\n\t\tbestdiv = _get_maxdiv(table, width, flags);\n\t\t*best_parent_rate = clk_hw_round_rate(parent, 1);\n\t}\n\n\treturn bestdiv;\n}\n\nint divider_determine_rate(struct clk_hw *hw, struct clk_rate_request *req,\n\t\t\t   const struct clk_div_table *table, u8 width,\n\t\t\t   unsigned long flags)\n{\n\tint div;\n\n\tdiv = clk_divider_bestdiv(hw, req->best_parent_hw, req->rate,\n\t\t\t\t  &req->best_parent_rate, table, width, flags);\n\n\treq->rate = DIV_ROUND_UP_ULL((u64)req->best_parent_rate, div);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(divider_determine_rate);\n\nint divider_ro_determine_rate(struct clk_hw *hw, struct clk_rate_request *req,\n\t\t\t      const struct clk_div_table *table, u8 width,\n\t\t\t      unsigned long flags, unsigned int val)\n{\n\tint div;\n\n\tdiv = _get_div(table, val, flags, width);\n\n\t \n\tif (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) {\n\t\tif (!req->best_parent_hw)\n\t\t\treturn -EINVAL;\n\n\t\treq->best_parent_rate = clk_hw_round_rate(req->best_parent_hw,\n\t\t\t\t\t\t\t  req->rate * div);\n\t}\n\n\treq->rate = DIV_ROUND_UP_ULL((u64)req->best_parent_rate, div);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(divider_ro_determine_rate);\n\nlong divider_round_rate_parent(struct clk_hw *hw, struct clk_hw *parent,\n\t\t\t       unsigned long rate, unsigned long *prate,\n\t\t\t       const struct clk_div_table *table,\n\t\t\t       u8 width, unsigned long flags)\n{\n\tstruct clk_rate_request req;\n\tint ret;\n\n\tclk_hw_init_rate_request(hw, &req, rate);\n\treq.best_parent_rate = *prate;\n\treq.best_parent_hw = parent;\n\n\tret = divider_determine_rate(hw, &req, table, width, flags);\n\tif (ret)\n\t\treturn ret;\n\n\t*prate = req.best_parent_rate;\n\n\treturn req.rate;\n}\nEXPORT_SYMBOL_GPL(divider_round_rate_parent);\n\nlong divider_ro_round_rate_parent(struct clk_hw *hw, struct clk_hw *parent,\n\t\t\t\t  unsigned long rate, unsigned long *prate,\n\t\t\t\t  const struct clk_div_table *table, u8 width,\n\t\t\t\t  unsigned long flags, unsigned int val)\n{\n\tstruct clk_rate_request req;\n\tint ret;\n\n\tclk_hw_init_rate_request(hw, &req, rate);\n\treq.best_parent_rate = *prate;\n\treq.best_parent_hw = parent;\n\n\tret = divider_ro_determine_rate(hw, &req, table, width, flags, val);\n\tif (ret)\n\t\treturn ret;\n\n\t*prate = req.best_parent_rate;\n\n\treturn req.rate;\n}\nEXPORT_SYMBOL_GPL(divider_ro_round_rate_parent);\n\nstatic long clk_divider_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *prate)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\n\t \n\tif (divider->flags & CLK_DIVIDER_READ_ONLY) {\n\t\tu32 val;\n\n\t\tval = clk_div_readl(divider) >> divider->shift;\n\t\tval &= clk_div_mask(divider->width);\n\n\t\treturn divider_ro_round_rate(hw, rate, prate, divider->table,\n\t\t\t\t\t     divider->width, divider->flags,\n\t\t\t\t\t     val);\n\t}\n\n\treturn divider_round_rate(hw, rate, prate, divider->table,\n\t\t\t\t  divider->width, divider->flags);\n}\n\nstatic int clk_divider_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\n\t \n\tif (divider->flags & CLK_DIVIDER_READ_ONLY) {\n\t\tu32 val;\n\n\t\tval = clk_div_readl(divider) >> divider->shift;\n\t\tval &= clk_div_mask(divider->width);\n\n\t\treturn divider_ro_determine_rate(hw, req, divider->table,\n\t\t\t\t\t\t divider->width,\n\t\t\t\t\t\t divider->flags, val);\n\t}\n\n\treturn divider_determine_rate(hw, req, divider->table, divider->width,\n\t\t\t\t      divider->flags);\n}\n\nint divider_get_val(unsigned long rate, unsigned long parent_rate,\n\t\t    const struct clk_div_table *table, u8 width,\n\t\t    unsigned long flags)\n{\n\tunsigned int div, value;\n\n\tdiv = DIV_ROUND_UP_ULL((u64)parent_rate, rate);\n\n\tif (!_is_valid_div(table, div, flags))\n\t\treturn -EINVAL;\n\n\tvalue = _get_val(table, div, flags, width);\n\n\treturn min_t(unsigned int, value, clk_div_mask(width));\n}\nEXPORT_SYMBOL_GPL(divider_get_val);\n\nstatic int clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\tint value;\n\tunsigned long flags = 0;\n\tu32 val;\n\n\tvalue = divider_get_val(rate, parent_rate, divider->table,\n\t\t\t\tdivider->width, divider->flags);\n\tif (value < 0)\n\t\treturn value;\n\n\tif (divider->lock)\n\t\tspin_lock_irqsave(divider->lock, flags);\n\telse\n\t\t__acquire(divider->lock);\n\n\tif (divider->flags & CLK_DIVIDER_HIWORD_MASK) {\n\t\tval = clk_div_mask(divider->width) << (divider->shift + 16);\n\t} else {\n\t\tval = clk_div_readl(divider);\n\t\tval &= ~(clk_div_mask(divider->width) << divider->shift);\n\t}\n\tval |= (u32)value << divider->shift;\n\tclk_div_writel(divider, val);\n\n\tif (divider->lock)\n\t\tspin_unlock_irqrestore(divider->lock, flags);\n\telse\n\t\t__release(divider->lock);\n\n\treturn 0;\n}\n\nconst struct clk_ops clk_divider_ops = {\n\t.recalc_rate = clk_divider_recalc_rate,\n\t.round_rate = clk_divider_round_rate,\n\t.determine_rate = clk_divider_determine_rate,\n\t.set_rate = clk_divider_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_divider_ops);\n\nconst struct clk_ops clk_divider_ro_ops = {\n\t.recalc_rate = clk_divider_recalc_rate,\n\t.round_rate = clk_divider_round_rate,\n\t.determine_rate = clk_divider_determine_rate,\n};\nEXPORT_SYMBOL_GPL(clk_divider_ro_ops);\n\nstruct clk_hw *__clk_hw_register_divider(struct device *dev,\n\t\tstruct device_node *np, const char *name,\n\t\tconst char *parent_name, const struct clk_hw *parent_hw,\n\t\tconst struct clk_parent_data *parent_data, unsigned long flags,\n\t\tvoid __iomem *reg, u8 shift, u8 width, u8 clk_divider_flags,\n\t\tconst struct clk_div_table *table, spinlock_t *lock)\n{\n\tstruct clk_divider *div;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tint ret;\n\n\tif (clk_divider_flags & CLK_DIVIDER_HIWORD_MASK) {\n\t\tif (width + shift > 16) {\n\t\t\tpr_warn(\"divider value exceeds LOWORD field\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\t \n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tif (clk_divider_flags & CLK_DIVIDER_READ_ONLY)\n\t\tinit.ops = &clk_divider_ro_ops;\n\telse\n\t\tinit.ops = &clk_divider_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.parent_hws = parent_hw ? &parent_hw : NULL;\n\tinit.parent_data = parent_data;\n\tif (parent_name || parent_hw || parent_data)\n\t\tinit.num_parents = 1;\n\telse\n\t\tinit.num_parents = 0;\n\n\t \n\tdiv->reg = reg;\n\tdiv->shift = shift;\n\tdiv->width = width;\n\tdiv->flags = clk_divider_flags;\n\tdiv->lock = lock;\n\tdiv->hw.init = &init;\n\tdiv->table = table;\n\n\t \n\thw = &div->hw;\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\tkfree(div);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(__clk_hw_register_divider);\n\n \nstruct clk *clk_register_divider_table(struct device *dev, const char *name,\n\t\tconst char *parent_name, unsigned long flags,\n\t\tvoid __iomem *reg, u8 shift, u8 width,\n\t\tu8 clk_divider_flags, const struct clk_div_table *table,\n\t\tspinlock_t *lock)\n{\n\tstruct clk_hw *hw;\n\n\thw =  __clk_hw_register_divider(dev, NULL, name, parent_name, NULL,\n\t\t\tNULL, flags, reg, shift, width, clk_divider_flags,\n\t\t\ttable, lock);\n\tif (IS_ERR(hw))\n\t\treturn ERR_CAST(hw);\n\treturn hw->clk;\n}\nEXPORT_SYMBOL_GPL(clk_register_divider_table);\n\nvoid clk_unregister_divider(struct clk *clk)\n{\n\tstruct clk_divider *div;\n\tstruct clk_hw *hw;\n\n\thw = __clk_get_hw(clk);\n\tif (!hw)\n\t\treturn;\n\n\tdiv = to_clk_divider(hw);\n\n\tclk_unregister(clk);\n\tkfree(div);\n}\nEXPORT_SYMBOL_GPL(clk_unregister_divider);\n\n \nvoid clk_hw_unregister_divider(struct clk_hw *hw)\n{\n\tstruct clk_divider *div;\n\n\tdiv = to_clk_divider(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(div);\n}\nEXPORT_SYMBOL_GPL(clk_hw_unregister_divider);\n\nstatic void devm_clk_hw_release_divider(struct device *dev, void *res)\n{\n\tclk_hw_unregister_divider(*(struct clk_hw **)res);\n}\n\nstruct clk_hw *__devm_clk_hw_register_divider(struct device *dev,\n\t\tstruct device_node *np, const char *name,\n\t\tconst char *parent_name, const struct clk_hw *parent_hw,\n\t\tconst struct clk_parent_data *parent_data, unsigned long flags,\n\t\tvoid __iomem *reg, u8 shift, u8 width, u8 clk_divider_flags,\n\t\tconst struct clk_div_table *table, spinlock_t *lock)\n{\n\tstruct clk_hw **ptr, *hw;\n\n\tptr = devres_alloc(devm_clk_hw_release_divider, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thw = __clk_hw_register_divider(dev, np, name, parent_name, parent_hw,\n\t\t\t\t       parent_data, flags, reg, shift, width,\n\t\t\t\t       clk_divider_flags, table, lock);\n\n\tif (!IS_ERR(hw)) {\n\t\t*ptr = hw;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(__devm_clk_hw_register_divider);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}