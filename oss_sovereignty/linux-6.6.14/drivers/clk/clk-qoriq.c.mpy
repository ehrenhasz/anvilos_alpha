{
  "module_name": "clk-qoriq.c",
  "hash_id": "bfa6a91e12970b2623570e672f5d84252e264ee4fa0427acc601006555821431",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-qoriq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <dt-bindings/clock/fsl,qoriq-clockgen.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/fsl/guts.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define PLL_DIV1\t0\n#define PLL_DIV2\t1\n#define PLL_DIV3\t2\n#define PLL_DIV4\t3\n\n#define PLATFORM_PLL\t0\n#define CGA_PLL1\t1\n#define CGA_PLL2\t2\n#define CGA_PLL3\t3\n#define CGA_PLL4\t4\t \n#define CGB_PLL1\t4\n#define CGB_PLL2\t5\n#define MAX_PLL_DIV\t32\n\nstruct clockgen_pll_div {\n\tstruct clk *clk;\n\tchar name[32];\n};\n\nstruct clockgen_pll {\n\tstruct clockgen_pll_div div[MAX_PLL_DIV];\n};\n\n#define CLKSEL_VALID\t1\n#define CLKSEL_80PCT\t2\t \n\nstruct clockgen_sourceinfo {\n\tu32 flags;\t \n\tint pll;\t \n\tint div;\t \n};\n\n#define NUM_MUX_PARENTS\t16\n\nstruct clockgen_muxinfo {\n\tstruct clockgen_sourceinfo clksel[NUM_MUX_PARENTS];\n};\n\n#define NUM_HWACCEL\t5\n#define NUM_CMUX\t8\n\nstruct clockgen;\n\n \n#define CG_CMUX_GE_PLAT\t\t1\n\n#define CG_PLL_8BIT\t\t2\t \n#define CG_VER3\t\t\t4\t \n#define CG_LITTLE_ENDIAN\t8\n\nstruct clockgen_chipinfo {\n\tconst char *compat, *guts_compat;\n\tconst struct clockgen_muxinfo *cmux_groups[2];\n\tconst struct clockgen_muxinfo *hwaccel[NUM_HWACCEL];\n\tvoid (*init_periph)(struct clockgen *cg);\n\tint cmux_to_group[NUM_CMUX + 1];  \n\tu32 pll_mask;\t \n\tu32 flags;\t \n};\n\nstruct clockgen {\n\tstruct device_node *node;\n\tvoid __iomem *regs;\n\tstruct clockgen_chipinfo info;  \n\tstruct clk *sysclk, *coreclk;\n\tstruct clockgen_pll pll[6];\n\tstruct clk *cmux[NUM_CMUX];\n\tstruct clk *hwaccel[NUM_HWACCEL];\n\tstruct clk *fman[2];\n\tstruct ccsr_guts __iomem *guts;\n};\n\nstatic struct clockgen clockgen;\nstatic bool add_cpufreq_dev __initdata;\n\nstatic void cg_out(struct clockgen *cg, u32 val, u32 __iomem *reg)\n{\n\tif (cg->info.flags & CG_LITTLE_ENDIAN)\n\t\tiowrite32(val, reg);\n\telse\n\t\tiowrite32be(val, reg);\n}\n\nstatic u32 cg_in(struct clockgen *cg, u32 __iomem *reg)\n{\n\tu32 val;\n\n\tif (cg->info.flags & CG_LITTLE_ENDIAN)\n\t\tval = ioread32(reg);\n\telse\n\t\tval = ioread32be(reg);\n\n\treturn val;\n}\n\nstatic const struct clockgen_muxinfo p2041_cmux_grp1 = {\n\t{\n\t\t[0] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t[1] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t[4] = { CLKSEL_VALID, CGA_PLL2, PLL_DIV1 },\n\t}\n};\n\nstatic const struct clockgen_muxinfo p2041_cmux_grp2 = {\n\t{\n\t\t[0] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t[4] = { CLKSEL_VALID, CGA_PLL2, PLL_DIV1 },\n\t\t[5] = { CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t}\n};\n\nstatic const struct clockgen_muxinfo p5020_cmux_grp1 = {\n\t{\n\t\t[0] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t[1] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t[4] = { CLKSEL_VALID | CLKSEL_80PCT, CGA_PLL2, PLL_DIV1 },\n\t}\n};\n\nstatic const struct clockgen_muxinfo p5020_cmux_grp2 = {\n\t{\n\t\t[0] = { CLKSEL_VALID | CLKSEL_80PCT, CGA_PLL1, PLL_DIV1 },\n\t\t[4] = { CLKSEL_VALID, CGA_PLL2, PLL_DIV1 },\n\t\t[5] = { CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t}\n};\n\nstatic const struct clockgen_muxinfo p5040_cmux_grp1 = {\n\t{\n\t\t[0] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t[1] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t[4] = { CLKSEL_VALID | CLKSEL_80PCT, CGA_PLL2, PLL_DIV1 },\n\t\t[5] = { CLKSEL_VALID | CLKSEL_80PCT, CGA_PLL2, PLL_DIV2 },\n\t}\n};\n\nstatic const struct clockgen_muxinfo p5040_cmux_grp2 = {\n\t{\n\t\t[0] = { CLKSEL_VALID | CLKSEL_80PCT, CGA_PLL1, PLL_DIV1 },\n\t\t[1] = { CLKSEL_VALID | CLKSEL_80PCT, CGA_PLL1, PLL_DIV2 },\n\t\t[4] = { CLKSEL_VALID, CGA_PLL2, PLL_DIV1 },\n\t\t[5] = { CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t}\n};\n\nstatic const struct clockgen_muxinfo p4080_cmux_grp1 = {\n\t{\n\t\t[0] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t[1] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t[4] = { CLKSEL_VALID, CGA_PLL2, PLL_DIV1 },\n\t\t[5] = { CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t[8] = { CLKSEL_VALID | CLKSEL_80PCT, CGA_PLL3, PLL_DIV1 },\n\t}\n};\n\nstatic const struct clockgen_muxinfo p4080_cmux_grp2 = {\n\t{\n\t\t[0] = { CLKSEL_VALID | CLKSEL_80PCT, CGA_PLL1, PLL_DIV1 },\n\t\t[8] = { CLKSEL_VALID, CGA_PLL3, PLL_DIV1 },\n\t\t[9] = { CLKSEL_VALID, CGA_PLL3, PLL_DIV2 },\n\t\t[12] = { CLKSEL_VALID, CGA_PLL4, PLL_DIV1 },\n\t\t[13] = { CLKSEL_VALID, CGA_PLL4, PLL_DIV2 },\n\t}\n};\n\nstatic const struct clockgen_muxinfo t1023_cmux = {\n\t{\n\t\t[0] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t[1] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t}\n};\n\nstatic const struct clockgen_muxinfo t1040_cmux = {\n\t{\n\t\t[0] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t[1] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t[4] = { CLKSEL_VALID, CGA_PLL2, PLL_DIV1 },\n\t\t[5] = { CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t}\n};\n\n\nstatic const struct clockgen_muxinfo clockgen2_cmux_cga = {\n\t{\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV4 },\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV4 },\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL3, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL3, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL3, PLL_DIV4 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo clockgen2_cmux_cga12 = {\n\t{\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV4 },\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV4 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo clockgen2_cmux_cgb = {\n\t{\n\t\t{ CLKSEL_VALID, CGB_PLL1, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGB_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGB_PLL1, PLL_DIV4 },\n\t\t{},\n\t\t{ CLKSEL_VALID, CGB_PLL2, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGB_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGB_PLL2, PLL_DIV4 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo ls1021a_cmux = {\n\t{\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV4 },\n\t}\n};\n\nstatic const struct clockgen_muxinfo ls1028a_hwa1 = {\n\t{\n\t\t{ CLKSEL_VALID, PLATFORM_PLL, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV3 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV4 },\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV3 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo ls1028a_hwa2 = {\n\t{\n\t\t{ CLKSEL_VALID, PLATFORM_PLL, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV3 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV4 },\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV3 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo ls1028a_hwa3 = {\n\t{\n\t\t{ CLKSEL_VALID, PLATFORM_PLL, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV3 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV4 },\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV3 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo ls1028a_hwa4 = {\n\t{\n\t\t{ CLKSEL_VALID, PLATFORM_PLL, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV3 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV4 },\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV3 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo ls1043a_hwa1 = {\n\t{\n\t\t{},\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV3 },\n\t\t{},\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV3 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo ls1043a_hwa2 = {\n\t{\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV1 },\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV3 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo ls1046a_hwa1 = {\n\t{\n\t\t{},\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV3 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV4 },\n\t\t{ CLKSEL_VALID, PLATFORM_PLL, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV3 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo ls1046a_hwa2 = {\n\t{\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV3 },\n\t\t{},\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo ls1088a_hwa1 = {\n\t{\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV3 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV4 },\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV3 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo ls1088a_hwa2 = {\n\t{\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV3 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV4 },\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV3 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo ls1012a_cmux = {\n\t{\n\t\t[0] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t{},\n\t\t[2] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t}\n};\n\nstatic const struct clockgen_muxinfo t1023_hwa1 = {\n\t{\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV3 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo t1023_hwa2 = {\n\t{\n\t\t[6] = { CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo t2080_hwa1 = {\n\t{\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV3 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV4 },\n\t\t{ CLKSEL_VALID, PLATFORM_PLL, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV3 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo t2080_hwa2 = {\n\t{\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV3 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV4 },\n\t\t{ CLKSEL_VALID, PLATFORM_PLL, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV3 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo t4240_hwa1 = {\n\t{\n\t\t{ CLKSEL_VALID, PLATFORM_PLL, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV1 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV3 },\n\t\t{ CLKSEL_VALID, CGA_PLL1, PLL_DIV4 },\n\t\t{},\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV2 },\n\t\t{ CLKSEL_VALID, CGA_PLL2, PLL_DIV3 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo t4240_hwa4 = {\n\t{\n\t\t[2] = { CLKSEL_VALID, CGB_PLL1, PLL_DIV2 },\n\t\t[3] = { CLKSEL_VALID, CGB_PLL1, PLL_DIV3 },\n\t\t[4] = { CLKSEL_VALID, CGB_PLL1, PLL_DIV4 },\n\t\t[5] = { CLKSEL_VALID, PLATFORM_PLL, PLL_DIV1 },\n\t\t[6] = { CLKSEL_VALID, CGB_PLL2, PLL_DIV2 },\n\t},\n};\n\nstatic const struct clockgen_muxinfo t4240_hwa5 = {\n\t{\n\t\t[2] = { CLKSEL_VALID, CGB_PLL2, PLL_DIV2 },\n\t\t[3] = { CLKSEL_VALID, CGB_PLL2, PLL_DIV3 },\n\t\t[4] = { CLKSEL_VALID, CGB_PLL2, PLL_DIV4 },\n\t\t[5] = { CLKSEL_VALID, PLATFORM_PLL, PLL_DIV1 },\n\t\t[6] = { CLKSEL_VALID, CGB_PLL1, PLL_DIV2 },\n\t\t[7] = { CLKSEL_VALID, CGB_PLL1, PLL_DIV3 },\n\t},\n};\n\n#define RCWSR7_FM1_CLK_SEL\t0x40000000\n#define RCWSR7_FM2_CLK_SEL\t0x20000000\n#define RCWSR7_HWA_ASYNC_DIV\t0x04000000\n\nstatic void __init p2041_init_periph(struct clockgen *cg)\n{\n\tu32 reg;\n\n\treg = ioread32be(&cg->guts->rcwsr[7]);\n\n\tif (reg & RCWSR7_FM1_CLK_SEL)\n\t\tcg->fman[0] = cg->pll[CGA_PLL2].div[PLL_DIV2].clk;\n\telse\n\t\tcg->fman[0] = cg->pll[PLATFORM_PLL].div[PLL_DIV2].clk;\n}\n\nstatic void __init p4080_init_periph(struct clockgen *cg)\n{\n\tu32 reg;\n\n\treg = ioread32be(&cg->guts->rcwsr[7]);\n\n\tif (reg & RCWSR7_FM1_CLK_SEL)\n\t\tcg->fman[0] = cg->pll[CGA_PLL3].div[PLL_DIV2].clk;\n\telse\n\t\tcg->fman[0] = cg->pll[PLATFORM_PLL].div[PLL_DIV2].clk;\n\n\tif (reg & RCWSR7_FM2_CLK_SEL)\n\t\tcg->fman[1] = cg->pll[CGA_PLL3].div[PLL_DIV2].clk;\n\telse\n\t\tcg->fman[1] = cg->pll[PLATFORM_PLL].div[PLL_DIV2].clk;\n}\n\nstatic void __init p5020_init_periph(struct clockgen *cg)\n{\n\tu32 reg;\n\tint div = PLL_DIV2;\n\n\treg = ioread32be(&cg->guts->rcwsr[7]);\n\tif (reg & RCWSR7_HWA_ASYNC_DIV)\n\t\tdiv = PLL_DIV4;\n\n\tif (reg & RCWSR7_FM1_CLK_SEL)\n\t\tcg->fman[0] = cg->pll[CGA_PLL2].div[div].clk;\n\telse\n\t\tcg->fman[0] = cg->pll[PLATFORM_PLL].div[PLL_DIV2].clk;\n}\n\nstatic void __init p5040_init_periph(struct clockgen *cg)\n{\n\tu32 reg;\n\tint div = PLL_DIV2;\n\n\treg = ioread32be(&cg->guts->rcwsr[7]);\n\tif (reg & RCWSR7_HWA_ASYNC_DIV)\n\t\tdiv = PLL_DIV4;\n\n\tif (reg & RCWSR7_FM1_CLK_SEL)\n\t\tcg->fman[0] = cg->pll[CGA_PLL3].div[div].clk;\n\telse\n\t\tcg->fman[0] = cg->pll[PLATFORM_PLL].div[PLL_DIV2].clk;\n\n\tif (reg & RCWSR7_FM2_CLK_SEL)\n\t\tcg->fman[1] = cg->pll[CGA_PLL3].div[div].clk;\n\telse\n\t\tcg->fman[1] = cg->pll[PLATFORM_PLL].div[PLL_DIV2].clk;\n}\n\nstatic void __init t1023_init_periph(struct clockgen *cg)\n{\n\tcg->fman[0] = cg->hwaccel[1];\n}\n\nstatic void __init t1040_init_periph(struct clockgen *cg)\n{\n\tcg->fman[0] = cg->pll[PLATFORM_PLL].div[PLL_DIV1].clk;\n}\n\nstatic void __init t2080_init_periph(struct clockgen *cg)\n{\n\tcg->fman[0] = cg->hwaccel[0];\n}\n\nstatic void __init t4240_init_periph(struct clockgen *cg)\n{\n\tcg->fman[0] = cg->hwaccel[3];\n\tcg->fman[1] = cg->hwaccel[4];\n}\n\nstatic const struct clockgen_chipinfo chipinfo[] = {\n\t{\n\t\t.compat = \"fsl,b4420-clockgen\",\n\t\t.guts_compat = \"fsl,b4860-device-config\",\n\t\t.init_periph = t2080_init_periph,\n\t\t.cmux_groups = {\n\t\t\t&clockgen2_cmux_cga12, &clockgen2_cmux_cgb\n\t\t},\n\t\t.hwaccel = {\n\t\t\t&t2080_hwa1\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, 1, 1, 1, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2) | BIT(CGA_PLL3) |\n\t\t\t    BIT(CGB_PLL1) | BIT(CGB_PLL2),\n\t\t.flags = CG_PLL_8BIT,\n\t},\n\t{\n\t\t.compat = \"fsl,b4860-clockgen\",\n\t\t.guts_compat = \"fsl,b4860-device-config\",\n\t\t.init_periph = t2080_init_periph,\n\t\t.cmux_groups = {\n\t\t\t&clockgen2_cmux_cga12, &clockgen2_cmux_cgb\n\t\t},\n\t\t.hwaccel = {\n\t\t\t&t2080_hwa1\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, 1, 1, 1, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2) | BIT(CGA_PLL3) |\n\t\t\t    BIT(CGB_PLL1) | BIT(CGB_PLL2),\n\t\t.flags = CG_PLL_8BIT,\n\t},\n\t{\n\t\t.compat = \"fsl,ls1021a-clockgen\",\n\t\t.cmux_groups = {\n\t\t\t&ls1021a_cmux\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2),\n\t},\n\t{\n\t\t.compat = \"fsl,ls1028a-clockgen\",\n\t\t.cmux_groups = {\n\t\t\t&clockgen2_cmux_cga12\n\t\t},\n\t\t.hwaccel = {\n\t\t\t&ls1028a_hwa1, &ls1028a_hwa2,\n\t\t\t&ls1028a_hwa3, &ls1028a_hwa4\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, 0, 0, 0, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2),\n\t\t.flags = CG_VER3 | CG_LITTLE_ENDIAN,\n\t},\n\t{\n\t\t.compat = \"fsl,ls1043a-clockgen\",\n\t\t.init_periph = t2080_init_periph,\n\t\t.cmux_groups = {\n\t\t\t&t1040_cmux\n\t\t},\n\t\t.hwaccel = {\n\t\t\t&ls1043a_hwa1, &ls1043a_hwa2\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2),\n\t\t.flags = CG_PLL_8BIT,\n\t},\n\t{\n\t\t.compat = \"fsl,ls1046a-clockgen\",\n\t\t.init_periph = t2080_init_periph,\n\t\t.cmux_groups = {\n\t\t\t&t1040_cmux\n\t\t},\n\t\t.hwaccel = {\n\t\t\t&ls1046a_hwa1, &ls1046a_hwa2\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2),\n\t\t.flags = CG_PLL_8BIT,\n\t},\n\t{\n\t\t.compat = \"fsl,ls1088a-clockgen\",\n\t\t.cmux_groups = {\n\t\t\t&clockgen2_cmux_cga12\n\t\t},\n\t\t.hwaccel = {\n\t\t\t&ls1088a_hwa1, &ls1088a_hwa2\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, 0, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2),\n\t\t.flags = CG_VER3 | CG_LITTLE_ENDIAN,\n\t},\n\t{\n\t\t.compat = \"fsl,ls1012a-clockgen\",\n\t\t.cmux_groups = {\n\t\t\t&ls1012a_cmux\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) | BIT(CGA_PLL1),\n\t},\n\t{\n\t\t.compat = \"fsl,ls2080a-clockgen\",\n\t\t.cmux_groups = {\n\t\t\t&clockgen2_cmux_cga12, &clockgen2_cmux_cgb\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, 0, 1, 1, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2) |\n\t\t\t    BIT(CGB_PLL1) | BIT(CGB_PLL2),\n\t\t.flags = CG_VER3 | CG_LITTLE_ENDIAN,\n\t},\n\t{\n\t\t.compat = \"fsl,lx2160a-clockgen\",\n\t\t.cmux_groups = {\n\t\t\t&clockgen2_cmux_cga12, &clockgen2_cmux_cgb\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, 0, 0, 0, 1, 1, 1, 1, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2) |\n\t\t\t    BIT(CGB_PLL1) | BIT(CGB_PLL2),\n\t\t.flags = CG_VER3 | CG_LITTLE_ENDIAN,\n\t},\n\t{\n\t\t.compat = \"fsl,p2041-clockgen\",\n\t\t.guts_compat = \"fsl,qoriq-device-config-1.0\",\n\t\t.init_periph = p2041_init_periph,\n\t\t.cmux_groups = {\n\t\t\t&p2041_cmux_grp1, &p2041_cmux_grp2\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, 0, 1, 1, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2),\n\t},\n\t{\n\t\t.compat = \"fsl,p3041-clockgen\",\n\t\t.guts_compat = \"fsl,qoriq-device-config-1.0\",\n\t\t.init_periph = p2041_init_periph,\n\t\t.cmux_groups = {\n\t\t\t&p2041_cmux_grp1, &p2041_cmux_grp2\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, 0, 1, 1, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2),\n\t},\n\t{\n\t\t.compat = \"fsl,p4080-clockgen\",\n\t\t.guts_compat = \"fsl,qoriq-device-config-1.0\",\n\t\t.init_periph = p4080_init_periph,\n\t\t.cmux_groups = {\n\t\t\t&p4080_cmux_grp1, &p4080_cmux_grp2\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, 0, 0, 0, 1, 1, 1, 1, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2) |\n\t\t\t    BIT(CGA_PLL3) | BIT(CGA_PLL4),\n\t},\n\t{\n\t\t.compat = \"fsl,p5020-clockgen\",\n\t\t.guts_compat = \"fsl,qoriq-device-config-1.0\",\n\t\t.init_periph = p5020_init_periph,\n\t\t.cmux_groups = {\n\t\t\t&p5020_cmux_grp1, &p5020_cmux_grp2\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, 1, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2),\n\t},\n\t{\n\t\t.compat = \"fsl,p5040-clockgen\",\n\t\t.guts_compat = \"fsl,p5040-device-config\",\n\t\t.init_periph = p5040_init_periph,\n\t\t.cmux_groups = {\n\t\t\t&p5040_cmux_grp1, &p5040_cmux_grp2\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, 0, 1, 1, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2) | BIT(CGA_PLL3),\n\t},\n\t{\n\t\t.compat = \"fsl,t1023-clockgen\",\n\t\t.guts_compat = \"fsl,t1023-device-config\",\n\t\t.init_periph = t1023_init_periph,\n\t\t.cmux_groups = {\n\t\t\t&t1023_cmux\n\t\t},\n\t\t.hwaccel = {\n\t\t\t&t1023_hwa1, &t1023_hwa2\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, 0, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) | BIT(CGA_PLL1),\n\t\t.flags = CG_PLL_8BIT,\n\t},\n\t{\n\t\t.compat = \"fsl,t1040-clockgen\",\n\t\t.guts_compat = \"fsl,t1040-device-config\",\n\t\t.init_periph = t1040_init_periph,\n\t\t.cmux_groups = {\n\t\t\t&t1040_cmux\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, 0, 0, 0, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2),\n\t\t.flags = CG_PLL_8BIT,\n\t},\n\t{\n\t\t.compat = \"fsl,t2080-clockgen\",\n\t\t.guts_compat = \"fsl,t2080-device-config\",\n\t\t.init_periph = t2080_init_periph,\n\t\t.cmux_groups = {\n\t\t\t&clockgen2_cmux_cga12\n\t\t},\n\t\t.hwaccel = {\n\t\t\t&t2080_hwa1, &t2080_hwa2\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2),\n\t\t.flags = CG_PLL_8BIT,\n\t},\n\t{\n\t\t.compat = \"fsl,t4240-clockgen\",\n\t\t.guts_compat = \"fsl,t4240-device-config\",\n\t\t.init_periph = t4240_init_periph,\n\t\t.cmux_groups = {\n\t\t\t&clockgen2_cmux_cga, &clockgen2_cmux_cgb\n\t\t},\n\t\t.hwaccel = {\n\t\t\t&t4240_hwa1, NULL, NULL, &t4240_hwa4, &t4240_hwa5\n\t\t},\n\t\t.cmux_to_group = {\n\t\t\t0, 0, 1, -1\n\t\t},\n\t\t.pll_mask = BIT(PLATFORM_PLL) |\n\t\t\t    BIT(CGA_PLL1) | BIT(CGA_PLL2) | BIT(CGA_PLL3) |\n\t\t\t    BIT(CGB_PLL1) | BIT(CGB_PLL2),\n\t\t.flags = CG_PLL_8BIT,\n\t},\n\t{},\n};\n\nstruct mux_hwclock {\n\tstruct clk_hw hw;\n\tstruct clockgen *cg;\n\tconst struct clockgen_muxinfo *info;\n\tu32 __iomem *reg;\n\tu8 parent_to_clksel[NUM_MUX_PARENTS];\n\ts8 clksel_to_parent[NUM_MUX_PARENTS];\n\tint num_parents;\n};\n\n#define to_mux_hwclock(p)\tcontainer_of(p, struct mux_hwclock, hw)\n#define CLKSEL_MASK\t\t0x78000000\n#define\tCLKSEL_SHIFT\t\t27\n\nstatic int mux_set_parent(struct clk_hw *hw, u8 idx)\n{\n\tstruct mux_hwclock *hwc = to_mux_hwclock(hw);\n\tu32 clksel;\n\n\tif (idx >= hwc->num_parents)\n\t\treturn -EINVAL;\n\n\tclksel = hwc->parent_to_clksel[idx];\n\tcg_out(hwc->cg, (clksel << CLKSEL_SHIFT) & CLKSEL_MASK, hwc->reg);\n\n\treturn 0;\n}\n\nstatic u8 mux_get_parent(struct clk_hw *hw)\n{\n\tstruct mux_hwclock *hwc = to_mux_hwclock(hw);\n\tu32 clksel;\n\ts8 ret;\n\n\tclksel = (cg_in(hwc->cg, hwc->reg) & CLKSEL_MASK) >> CLKSEL_SHIFT;\n\n\tret = hwc->clksel_to_parent[clksel];\n\tif (ret < 0) {\n\t\tpr_err(\"%s: mux at %p has bad clksel\\n\", __func__, hwc->reg);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct clk_ops cmux_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.get_parent = mux_get_parent,\n\t.set_parent = mux_set_parent,\n};\n\n \nstatic const struct clk_ops hwaccel_ops = {\n\t.get_parent = mux_get_parent,\n};\n\nstatic const struct clockgen_pll_div *get_pll_div(struct clockgen *cg,\n\t\t\t\t\t\t  struct mux_hwclock *hwc,\n\t\t\t\t\t\t  int idx)\n{\n\tint pll, div;\n\n\tif (!(hwc->info->clksel[idx].flags & CLKSEL_VALID))\n\t\treturn NULL;\n\n\tpll = hwc->info->clksel[idx].pll;\n\tdiv = hwc->info->clksel[idx].div;\n\n\treturn &cg->pll[pll].div[div];\n}\n\nstatic struct clk * __init create_mux_common(struct clockgen *cg,\n\t\t\t\t\t     struct mux_hwclock *hwc,\n\t\t\t\t\t     const struct clk_ops *ops,\n\t\t\t\t\t     unsigned long min_rate,\n\t\t\t\t\t     unsigned long max_rate,\n\t\t\t\t\t     unsigned long pct80_rate,\n\t\t\t\t\t     const char *fmt, int idx)\n{\n\tstruct clk_init_data init = {};\n\tstruct clk *clk;\n\tconst struct clockgen_pll_div *div;\n\tconst char *parent_names[NUM_MUX_PARENTS];\n\tchar name[32];\n\tint i, j;\n\n\tsnprintf(name, sizeof(name), fmt, idx);\n\n\tfor (i = 0, j = 0; i < NUM_MUX_PARENTS; i++) {\n\t\tunsigned long rate;\n\n\t\thwc->clksel_to_parent[i] = -1;\n\n\t\tdiv = get_pll_div(cg, hwc, i);\n\t\tif (!div)\n\t\t\tcontinue;\n\n\t\trate = clk_get_rate(div->clk);\n\n\t\tif (hwc->info->clksel[i].flags & CLKSEL_80PCT &&\n\t\t    rate > pct80_rate)\n\t\t\tcontinue;\n\t\tif (rate < min_rate)\n\t\t\tcontinue;\n\t\tif (rate > max_rate)\n\t\t\tcontinue;\n\n\t\tparent_names[j] = div->name;\n\t\thwc->parent_to_clksel[j] = i;\n\t\thwc->clksel_to_parent[i] = j;\n\t\tj++;\n\t}\n\n\tinit.name = name;\n\tinit.ops = ops;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = hwc->num_parents = j;\n\tinit.flags = 0;\n\thwc->hw.init = &init;\n\thwc->cg = cg;\n\n\tclk = clk_register(NULL, &hwc->hw);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: Couldn't register %s: %ld\\n\", __func__, name,\n\t\t       PTR_ERR(clk));\n\t\tkfree(hwc);\n\t\treturn NULL;\n\t}\n\n\treturn clk;\n}\n\nstatic struct clk * __init create_one_cmux(struct clockgen *cg, int idx)\n{\n\tstruct mux_hwclock *hwc;\n\tconst struct clockgen_pll_div *div;\n\tunsigned long plat_rate, min_rate;\n\tu64 max_rate, pct80_rate;\n\tu32 clksel;\n\n\thwc = kzalloc(sizeof(*hwc), GFP_KERNEL);\n\tif (!hwc)\n\t\treturn NULL;\n\n\tif (cg->info.flags & CG_VER3)\n\t\thwc->reg = cg->regs + 0x70000 + 0x20 * idx;\n\telse\n\t\thwc->reg = cg->regs + 0x20 * idx;\n\n\thwc->info = cg->info.cmux_groups[cg->info.cmux_to_group[idx]];\n\n\t \n\tclksel = (cg_in(cg, hwc->reg) & CLKSEL_MASK) >> CLKSEL_SHIFT;\n\tdiv = get_pll_div(cg, hwc, clksel);\n\tif (!div) {\n\t\tkfree(hwc);\n\t\treturn NULL;\n\t}\n\n\tmax_rate = clk_get_rate(div->clk);\n\tpct80_rate = max_rate * 8;\n\tdo_div(pct80_rate, 10);\n\n\tplat_rate = clk_get_rate(cg->pll[PLATFORM_PLL].div[PLL_DIV1].clk);\n\n\tif (cg->info.flags & CG_CMUX_GE_PLAT)\n\t\tmin_rate = plat_rate;\n\telse\n\t\tmin_rate = plat_rate / 2;\n\n\treturn create_mux_common(cg, hwc, &cmux_ops, min_rate, max_rate,\n\t\t\t\t pct80_rate, \"cg-cmux%d\", idx);\n}\n\nstatic struct clk * __init create_one_hwaccel(struct clockgen *cg, int idx)\n{\n\tstruct mux_hwclock *hwc;\n\n\thwc = kzalloc(sizeof(*hwc), GFP_KERNEL);\n\tif (!hwc)\n\t\treturn NULL;\n\n\thwc->reg = cg->regs + 0x20 * idx + 0x10;\n\thwc->info = cg->info.hwaccel[idx];\n\n\treturn create_mux_common(cg, hwc, &hwaccel_ops, 0, ULONG_MAX, 0,\n\t\t\t\t \"cg-hwaccel%d\", idx);\n}\n\nstatic void __init create_muxes(struct clockgen *cg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cg->cmux); i++) {\n\t\tif (cg->info.cmux_to_group[i] < 0)\n\t\t\tbreak;\n\t\tif (cg->info.cmux_to_group[i] >=\n\t\t    ARRAY_SIZE(cg->info.cmux_groups)) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcg->cmux[i] = create_one_cmux(cg, i);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(cg->hwaccel); i++) {\n\t\tif (!cg->info.hwaccel[i])\n\t\t\tcontinue;\n\n\t\tcg->hwaccel[i] = create_one_hwaccel(cg, i);\n\t}\n}\n\nstatic void __init _clockgen_init(struct device_node *np, bool legacy);\n\n \nstatic void __init legacy_init_clockgen(struct device_node *np)\n{\n\tif (!clockgen.node) {\n\t\tstruct device_node *parent_np;\n\n\t\tparent_np = of_get_parent(np);\n\t\t_clockgen_init(parent_np, true);\n\t\tof_node_put(parent_np);\n\t}\n}\n\n \nstatic void __init core_mux_init(struct device_node *np)\n{\n\tstruct clk *clk;\n\tstruct resource res;\n\tint idx, rc;\n\n\tlegacy_init_clockgen(np);\n\n\tif (of_address_to_resource(np, 0, &res))\n\t\treturn;\n\n\tidx = (res.start & 0xf0) >> 5;\n\tclk = clockgen.cmux[idx];\n\n\trc = of_clk_add_provider(np, of_clk_src_simple_get, clk);\n\tif (rc) {\n\t\tpr_err(\"%s: Couldn't register clk provider for node %pOFn: %d\\n\",\n\t\t       __func__, np, rc);\n\t\treturn;\n\t}\n}\n\nstatic struct clk __init\n*sysclk_from_fixed(struct device_node *node, const char *name)\n{\n\tu32 rate;\n\n\tif (of_property_read_u32(node, \"clock-frequency\", &rate))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn clk_register_fixed_rate(NULL, name, NULL, 0, rate);\n}\n\nstatic struct clk __init *input_clock(const char *name, struct clk *clk)\n{\n\tconst char *input_name;\n\n\t \n\tinput_name = __clk_get_name(clk);\n\tclk = clk_register_fixed_factor(NULL, name, input_name,\n\t\t\t\t\t0, 1, 1);\n\tif (IS_ERR(clk))\n\t\tpr_err(\"%s: Couldn't register %s: %ld\\n\", __func__, name,\n\t\t       PTR_ERR(clk));\n\n\treturn clk;\n}\n\nstatic struct clk __init *input_clock_by_name(const char *name,\n\t\t\t\t\t      const char *dtname)\n{\n\tstruct clk *clk;\n\n\tclk = of_clk_get_by_name(clockgen.node, dtname);\n\tif (IS_ERR(clk))\n\t\treturn clk;\n\n\treturn input_clock(name, clk);\n}\n\nstatic struct clk __init *input_clock_by_index(const char *name, int idx)\n{\n\tstruct clk *clk;\n\n\tclk = of_clk_get(clockgen.node, 0);\n\tif (IS_ERR(clk))\n\t\treturn clk;\n\n\treturn input_clock(name, clk);\n}\n\nstatic struct clk * __init create_sysclk(const char *name)\n{\n\tstruct device_node *sysclk;\n\tstruct clk *clk;\n\n\tclk = sysclk_from_fixed(clockgen.node, name);\n\tif (!IS_ERR(clk))\n\t\treturn clk;\n\n\tclk = input_clock_by_name(name, \"sysclk\");\n\tif (!IS_ERR(clk))\n\t\treturn clk;\n\n\tclk = input_clock_by_index(name, 0);\n\tif (!IS_ERR(clk))\n\t\treturn clk;\n\n\tsysclk = of_get_child_by_name(clockgen.node, \"sysclk\");\n\tif (sysclk) {\n\t\tclk = sysclk_from_fixed(sysclk, name);\n\t\tof_node_put(sysclk);\n\t\tif (!IS_ERR(clk))\n\t\t\treturn clk;\n\t}\n\n\tpr_err(\"%s: No input sysclk\\n\", __func__);\n\treturn NULL;\n}\n\nstatic struct clk * __init create_coreclk(const char *name)\n{\n\tstruct clk *clk;\n\n\tclk = input_clock_by_name(name, \"coreclk\");\n\tif (!IS_ERR(clk))\n\t\treturn clk;\n\n\t \n\tif (WARN_ON(PTR_ERR(clk) == -EPROBE_DEFER))\n\t\treturn clk;\n\n\treturn NULL;\n}\n\n \nstatic void __init sysclk_init(struct device_node *node)\n{\n\tstruct clk *clk;\n\n\tlegacy_init_clockgen(node);\n\n\tclk = clockgen.sysclk;\n\tif (clk)\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n}\n\n#define PLL_KILL BIT(31)\n\nstatic void __init create_one_pll(struct clockgen *cg, int idx)\n{\n\tu32 __iomem *reg;\n\tu32 mult;\n\tstruct clockgen_pll *pll = &cg->pll[idx];\n\tconst char *input = \"cg-sysclk\";\n\tint i;\n\n\tif (!(cg->info.pll_mask & (1 << idx)))\n\t\treturn;\n\n\tif (cg->coreclk && idx != PLATFORM_PLL) {\n\t\tif (IS_ERR(cg->coreclk))\n\t\t\treturn;\n\n\t\tinput = \"cg-coreclk\";\n\t}\n\n\tif (cg->info.flags & CG_VER3) {\n\t\tswitch (idx) {\n\t\tcase PLATFORM_PLL:\n\t\t\treg = cg->regs + 0x60080;\n\t\t\tbreak;\n\t\tcase CGA_PLL1:\n\t\t\treg = cg->regs + 0x80;\n\t\t\tbreak;\n\t\tcase CGA_PLL2:\n\t\t\treg = cg->regs + 0xa0;\n\t\t\tbreak;\n\t\tcase CGB_PLL1:\n\t\t\treg = cg->regs + 0x10080;\n\t\t\tbreak;\n\t\tcase CGB_PLL2:\n\t\t\treg = cg->regs + 0x100a0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ONCE(1, \"index %d\\n\", idx);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (idx == PLATFORM_PLL)\n\t\t\treg = cg->regs + 0xc00;\n\t\telse\n\t\t\treg = cg->regs + 0x800 + 0x20 * (idx - 1);\n\t}\n\n\t \n\tmult = cg_in(cg, reg);\n\n\t \n\tif (mult & PLL_KILL) {\n\t\tpr_debug(\"%s(): pll %p disabled\\n\", __func__, reg);\n\t\treturn;\n\t}\n\n\tif ((cg->info.flags & CG_VER3) ||\n\t    ((cg->info.flags & CG_PLL_8BIT) && idx != PLATFORM_PLL))\n\t\tmult = (mult & GENMASK(8, 1)) >> 1;\n\telse\n\t\tmult = (mult & GENMASK(6, 1)) >> 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(pll->div); i++) {\n\t\tstruct clk *clk;\n\t\tint ret;\n\n\t\t \n\t\tif (idx != PLATFORM_PLL && i >= 4)\n\t\t\tbreak;\n\n\t\tsnprintf(pll->div[i].name, sizeof(pll->div[i].name),\n\t\t\t \"cg-pll%d-div%d\", idx, i + 1);\n\n\t\tclk = clk_register_fixed_factor(NULL,\n\t\t\t\tpll->div[i].name, input, 0, mult, i + 1);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: %s: register failed %ld\\n\",\n\t\t\t       __func__, pll->div[i].name, PTR_ERR(clk));\n\t\t\tcontinue;\n\t\t}\n\n\t\tpll->div[i].clk = clk;\n\t\tret = clk_register_clkdev(clk, pll->div[i].name, NULL);\n\t\tif (ret != 0)\n\t\t\tpr_err(\"%s: %s: register to lookup table failed %d\\n\",\n\t\t\t       __func__, pll->div[i].name, ret);\n\n\t}\n}\n\nstatic void __init create_plls(struct clockgen *cg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cg->pll); i++)\n\t\tcreate_one_pll(cg, i);\n}\n\nstatic void __init legacy_pll_init(struct device_node *np, int idx)\n{\n\tstruct clockgen_pll *pll;\n\tstruct clk_onecell_data *onecell_data;\n\tstruct clk **subclks;\n\tint count, rc;\n\n\tlegacy_init_clockgen(np);\n\n\tpll = &clockgen.pll[idx];\n\tcount = of_property_count_strings(np, \"clock-output-names\");\n\n\tBUILD_BUG_ON(ARRAY_SIZE(pll->div) < 4);\n\tsubclks = kcalloc(4, sizeof(struct clk *), GFP_KERNEL);\n\tif (!subclks)\n\t\treturn;\n\n\tonecell_data = kmalloc(sizeof(*onecell_data), GFP_KERNEL);\n\tif (!onecell_data)\n\t\tgoto err_clks;\n\n\tif (count <= 3) {\n\t\tsubclks[0] = pll->div[0].clk;\n\t\tsubclks[1] = pll->div[1].clk;\n\t\tsubclks[2] = pll->div[3].clk;\n\t} else {\n\t\tsubclks[0] = pll->div[0].clk;\n\t\tsubclks[1] = pll->div[1].clk;\n\t\tsubclks[2] = pll->div[2].clk;\n\t\tsubclks[3] = pll->div[3].clk;\n\t}\n\n\tonecell_data->clks = subclks;\n\tonecell_data->clk_num = count;\n\n\trc = of_clk_add_provider(np, of_clk_src_onecell_get, onecell_data);\n\tif (rc) {\n\t\tpr_err(\"%s: Couldn't register clk provider for node %pOFn: %d\\n\",\n\t\t       __func__, np, rc);\n\t\tgoto err_cell;\n\t}\n\n\treturn;\nerr_cell:\n\tkfree(onecell_data);\nerr_clks:\n\tkfree(subclks);\n}\n\n \nstatic void __init pltfrm_pll_init(struct device_node *np)\n{\n\tlegacy_pll_init(np, PLATFORM_PLL);\n}\n\n \nstatic void __init core_pll_init(struct device_node *np)\n{\n\tstruct resource res;\n\tint idx;\n\n\tif (of_address_to_resource(np, 0, &res))\n\t\treturn;\n\n\tif ((res.start & 0xfff) == 0xc00) {\n\t\t \n\t\tpltfrm_pll_init(np);\n\t} else {\n\t\tidx = (res.start & 0xf0) >> 5;\n\t\tlegacy_pll_init(np, CGA_PLL1 + idx);\n\t}\n}\n\nstatic struct clk *clockgen_clk_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct clockgen *cg = data;\n\tstruct clk *clk;\n\tstruct clockgen_pll *pll;\n\tu32 type, idx;\n\n\tif (clkspec->args_count < 2) {\n\t\tpr_err(\"%s: insufficient phandle args\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\ttype = clkspec->args[0];\n\tidx = clkspec->args[1];\n\n\tswitch (type) {\n\tcase QORIQ_CLK_SYSCLK:\n\t\tif (idx != 0)\n\t\t\tgoto bad_args;\n\t\tclk = cg->sysclk;\n\t\tbreak;\n\tcase QORIQ_CLK_CMUX:\n\t\tif (idx >= ARRAY_SIZE(cg->cmux))\n\t\t\tgoto bad_args;\n\t\tclk = cg->cmux[idx];\n\t\tbreak;\n\tcase QORIQ_CLK_HWACCEL:\n\t\tif (idx >= ARRAY_SIZE(cg->hwaccel))\n\t\t\tgoto bad_args;\n\t\tclk = cg->hwaccel[idx];\n\t\tbreak;\n\tcase QORIQ_CLK_FMAN:\n\t\tif (idx >= ARRAY_SIZE(cg->fman))\n\t\t\tgoto bad_args;\n\t\tclk = cg->fman[idx];\n\t\tbreak;\n\tcase QORIQ_CLK_PLATFORM_PLL:\n\t\tpll = &cg->pll[PLATFORM_PLL];\n\t\tif (idx >= ARRAY_SIZE(pll->div))\n\t\t\tgoto bad_args;\n\t\tclk = pll->div[idx].clk;\n\t\tbreak;\n\tcase QORIQ_CLK_CORECLK:\n\t\tif (idx != 0)\n\t\t\tgoto bad_args;\n\t\tclk = cg->coreclk;\n\t\tif (IS_ERR(clk))\n\t\t\tclk = NULL;\n\t\tbreak;\n\tdefault:\n\t\tgoto bad_args;\n\t}\n\n\tif (!clk)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn clk;\n\nbad_args:\n\tpr_err(\"%s: Bad phandle args %u %u\\n\", __func__, type, idx);\n\treturn ERR_PTR(-EINVAL);\n}\n\n#ifdef CONFIG_PPC\n#include <asm/mpc85xx.h>\n\nstatic const u32 a4510_svrs[] __initconst = {\n\t(SVR_P2040 << 8) | 0x10,\t \n\t(SVR_P2040 << 8) | 0x11,\t \n\t(SVR_P2041 << 8) | 0x10,\t \n\t(SVR_P2041 << 8) | 0x11,\t \n\t(SVR_P3041 << 8) | 0x10,\t \n\t(SVR_P3041 << 8) | 0x11,\t \n\t(SVR_P4040 << 8) | 0x20,\t \n\t(SVR_P4080 << 8) | 0x20,\t \n\t(SVR_P5010 << 8) | 0x10,\t \n\t(SVR_P5010 << 8) | 0x20,\t \n\t(SVR_P5020 << 8) | 0x10,\t \n\t(SVR_P5021 << 8) | 0x10,\t \n\t(SVR_P5040 << 8) | 0x10,\t \n};\n\n#define SVR_SECURITY\t0x80000\t \n\nstatic bool __init has_erratum_a4510(void)\n{\n\tu32 svr = mfspr(SPRN_SVR);\n\tint i;\n\n\tsvr &= ~SVR_SECURITY;\n\n\tfor (i = 0; i < ARRAY_SIZE(a4510_svrs); i++) {\n\t\tif (svr == a4510_svrs[i])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n#else\nstatic bool __init has_erratum_a4510(void)\n{\n\treturn false;\n}\n#endif\n\nstatic void __init _clockgen_init(struct device_node *np, bool legacy)\n{\n\tint i, ret;\n\tbool is_old_ls1021a = false;\n\n\t \n\tif (clockgen.node)\n\t\treturn;\n\n\tclockgen.node = np;\n\tclockgen.regs = of_iomap(np, 0);\n\tif (!clockgen.regs &&\n\t    of_device_is_compatible(of_root, \"fsl,ls1021a\")) {\n\t\t \n\t\tclockgen.regs = ioremap(0x1ee1000, 0x1000);\n\t\tis_old_ls1021a = true;\n\t}\n\tif (!clockgen.regs) {\n\t\tpr_err(\"%s(): %pOFn: of_iomap() failed\\n\", __func__, np);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(chipinfo); i++) {\n\t\tif (of_device_is_compatible(np, chipinfo[i].compat))\n\t\t\tbreak;\n\t\tif (is_old_ls1021a &&\n\t\t    !strcmp(chipinfo[i].compat, \"fsl,ls1021a-clockgen\"))\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(chipinfo)) {\n\t\tpr_err(\"%s: unknown clockgen node %pOF\\n\", __func__, np);\n\t\tgoto err;\n\t}\n\tclockgen.info = chipinfo[i];\n\n\tif (clockgen.info.guts_compat) {\n\t\tstruct device_node *guts;\n\n\t\tguts = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t       clockgen.info.guts_compat);\n\t\tif (guts) {\n\t\t\tclockgen.guts = of_iomap(guts, 0);\n\t\t\tif (!clockgen.guts) {\n\t\t\t\tpr_err(\"%s: Couldn't map %pOF regs\\n\", __func__,\n\t\t\t\t       guts);\n\t\t\t}\n\t\t\tof_node_put(guts);\n\t\t}\n\n\t}\n\n\tif (has_erratum_a4510())\n\t\tclockgen.info.flags |= CG_CMUX_GE_PLAT;\n\n\tclockgen.sysclk = create_sysclk(\"cg-sysclk\");\n\tclockgen.coreclk = create_coreclk(\"cg-coreclk\");\n\tcreate_plls(&clockgen);\n\tcreate_muxes(&clockgen);\n\n\tif (clockgen.info.init_periph)\n\t\tclockgen.info.init_periph(&clockgen);\n\n\tret = of_clk_add_provider(np, clockgen_clk_get, &clockgen);\n\tif (ret) {\n\t\tpr_err(\"%s: Couldn't register clk provider for node %pOFn: %d\\n\",\n\t\t       __func__, np, ret);\n\t}\n\n\t \n\tadd_cpufreq_dev = !legacy;\n\n\treturn;\nerr:\n\tiounmap(clockgen.regs);\n\tclockgen.regs = NULL;\n}\n\nstatic void __init clockgen_init(struct device_node *np)\n{\n\t_clockgen_init(np, false);\n}\n\nstatic int __init clockgen_cpufreq_init(void)\n{\n\tstruct platform_device *pdev;\n\n\tif (add_cpufreq_dev) {\n\t\tpdev = platform_device_register_simple(\"qoriq-cpufreq\", -1,\n\t\t\t\tNULL, 0);\n\t\tif (IS_ERR(pdev))\n\t\t\tpr_err(\"Couldn't register qoriq-cpufreq err=%ld\\n\",\n\t\t\t\tPTR_ERR(pdev));\n\t}\n\treturn 0;\n}\ndevice_initcall(clockgen_cpufreq_init);\n\nCLK_OF_DECLARE(qoriq_clockgen_1, \"fsl,qoriq-clockgen-1.0\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_2, \"fsl,qoriq-clockgen-2.0\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_b4420, \"fsl,b4420-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_b4860, \"fsl,b4860-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_ls1012a, \"fsl,ls1012a-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_ls1021a, \"fsl,ls1021a-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_ls1028a, \"fsl,ls1028a-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_ls1043a, \"fsl,ls1043a-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_ls1046a, \"fsl,ls1046a-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_ls1088a, \"fsl,ls1088a-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_ls2080a, \"fsl,ls2080a-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_lx2160a, \"fsl,lx2160a-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_p2041, \"fsl,p2041-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_p3041, \"fsl,p3041-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_p4080, \"fsl,p4080-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_p5020, \"fsl,p5020-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_p5040, \"fsl,p5040-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_t1023, \"fsl,t1023-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_t1040, \"fsl,t1040-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_t2080, \"fsl,t2080-clockgen\", clockgen_init);\nCLK_OF_DECLARE(qoriq_clockgen_t4240, \"fsl,t4240-clockgen\", clockgen_init);\n\n \nCLK_OF_DECLARE(qoriq_sysclk_1, \"fsl,qoriq-sysclk-1.0\", sysclk_init);\nCLK_OF_DECLARE(qoriq_sysclk_2, \"fsl,qoriq-sysclk-2.0\", sysclk_init);\nCLK_OF_DECLARE(qoriq_core_pll_1, \"fsl,qoriq-core-pll-1.0\", core_pll_init);\nCLK_OF_DECLARE(qoriq_core_pll_2, \"fsl,qoriq-core-pll-2.0\", core_pll_init);\nCLK_OF_DECLARE(qoriq_core_mux_1, \"fsl,qoriq-core-mux-1.0\", core_mux_init);\nCLK_OF_DECLARE(qoriq_core_mux_2, \"fsl,qoriq-core-mux-2.0\", core_mux_init);\nCLK_OF_DECLARE(qoriq_pltfrm_pll_1, \"fsl,qoriq-platform-pll-1.0\", pltfrm_pll_init);\nCLK_OF_DECLARE(qoriq_pltfrm_pll_2, \"fsl,qoriq-platform-pll-2.0\", pltfrm_pll_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}