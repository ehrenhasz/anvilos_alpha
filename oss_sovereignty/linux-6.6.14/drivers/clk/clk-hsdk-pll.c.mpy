{
  "module_name": "clk-hsdk-pll.c",
  "hash_id": "1e4f0bd71063d12c29402231d0ce09fcc6bf2b5e589672de7ada83eabbca24c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-hsdk-pll.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define CGU_PLL_CTRL\t0x000  \n#define CGU_PLL_STATUS\t0x004  \n#define CGU_PLL_FMEAS\t0x008  \n#define CGU_PLL_MON\t0x00C  \n\n#define CGU_PLL_CTRL_ODIV_SHIFT\t\t2\n#define CGU_PLL_CTRL_IDIV_SHIFT\t\t4\n#define CGU_PLL_CTRL_FBDIV_SHIFT\t9\n#define CGU_PLL_CTRL_BAND_SHIFT\t\t20\n\n#define CGU_PLL_CTRL_ODIV_MASK\t\tGENMASK(3, CGU_PLL_CTRL_ODIV_SHIFT)\n#define CGU_PLL_CTRL_IDIV_MASK\t\tGENMASK(8, CGU_PLL_CTRL_IDIV_SHIFT)\n#define CGU_PLL_CTRL_FBDIV_MASK\t\tGENMASK(15, CGU_PLL_CTRL_FBDIV_SHIFT)\n\n#define CGU_PLL_CTRL_PD\t\t\tBIT(0)\n#define CGU_PLL_CTRL_BYPASS\t\tBIT(1)\n\n#define CGU_PLL_STATUS_LOCK\t\tBIT(0)\n#define CGU_PLL_STATUS_ERR\t\tBIT(1)\n\n#define HSDK_PLL_MAX_LOCK_TIME\t\t100  \n\n#define CGU_PLL_SOURCE_MAX\t\t1\n\n#define CORE_IF_CLK_THRESHOLD_HZ\t500000000\n#define CREG_CORE_IF_CLK_DIV_1\t\t0x0\n#define CREG_CORE_IF_CLK_DIV_2\t\t0x1\n\nstruct hsdk_pll_cfg {\n\tu32 rate;\n\tu32 idiv;\n\tu32 fbdiv;\n\tu32 odiv;\n\tu32 band;\n\tu32 bypass;\n};\n\nstatic const struct hsdk_pll_cfg asdt_pll_cfg[] = {\n\t{ 100000000,  0, 11, 3, 0, 0 },\n\t{ 133000000,  0, 15, 3, 0, 0 },\n\t{ 200000000,  1, 47, 3, 0, 0 },\n\t{ 233000000,  1, 27, 2, 0, 0 },\n\t{ 300000000,  1, 35, 2, 0, 0 },\n\t{ 333000000,  1, 39, 2, 0, 0 },\n\t{ 400000000,  1, 47, 2, 0, 0 },\n\t{ 500000000,  0, 14, 1, 0, 0 },\n\t{ 600000000,  0, 17, 1, 0, 0 },\n\t{ 700000000,  0, 20, 1, 0, 0 },\n\t{ 800000000,  0, 23, 1, 0, 0 },\n\t{ 900000000,  1, 26, 0, 0, 0 },\n\t{ 1000000000, 1, 29, 0, 0, 0 },\n\t{ 1100000000, 1, 32, 0, 0, 0 },\n\t{ 1200000000, 1, 35, 0, 0, 0 },\n\t{ 1300000000, 1, 38, 0, 0, 0 },\n\t{ 1400000000, 1, 41, 0, 0, 0 },\n\t{ 1500000000, 1, 44, 0, 0, 0 },\n\t{ 1600000000, 1, 47, 0, 0, 0 },\n\t{}\n};\n\nstatic const struct hsdk_pll_cfg hdmi_pll_cfg[] = {\n\t{ 27000000,   0, 0,  0, 0, 1 },\n\t{ 148500000,  0, 21, 3, 0, 0 },\n\t{ 297000000,  0, 21, 2, 0, 0 },\n\t{ 540000000,  0, 19, 1, 0, 0 },\n\t{ 594000000,  0, 21, 1, 0, 0 },\n\t{}\n};\n\nstruct hsdk_pll_clk {\n\tstruct clk_hw hw;\n\tvoid __iomem *regs;\n\tvoid __iomem *spec_regs;\n\tconst struct hsdk_pll_devdata *pll_devdata;\n\tstruct device *dev;\n};\n\nstruct hsdk_pll_devdata {\n\tconst struct hsdk_pll_cfg *pll_cfg;\n\tint (*update_rate)(struct hsdk_pll_clk *clk, unsigned long rate,\n\t\t\t   const struct hsdk_pll_cfg *cfg);\n};\n\nstatic int hsdk_pll_core_update_rate(struct hsdk_pll_clk *, unsigned long,\n\t\t\t\t     const struct hsdk_pll_cfg *);\nstatic int hsdk_pll_comm_update_rate(struct hsdk_pll_clk *, unsigned long,\n\t\t\t\t     const struct hsdk_pll_cfg *);\n\nstatic const struct hsdk_pll_devdata core_pll_devdata = {\n\t.pll_cfg = asdt_pll_cfg,\n\t.update_rate = hsdk_pll_core_update_rate,\n};\n\nstatic const struct hsdk_pll_devdata sdt_pll_devdata = {\n\t.pll_cfg = asdt_pll_cfg,\n\t.update_rate = hsdk_pll_comm_update_rate,\n};\n\nstatic const struct hsdk_pll_devdata hdmi_pll_devdata = {\n\t.pll_cfg = hdmi_pll_cfg,\n\t.update_rate = hsdk_pll_comm_update_rate,\n};\n\nstatic inline void hsdk_pll_write(struct hsdk_pll_clk *clk, u32 reg, u32 val)\n{\n\tiowrite32(val, clk->regs + reg);\n}\n\nstatic inline u32 hsdk_pll_read(struct hsdk_pll_clk *clk, u32 reg)\n{\n\treturn ioread32(clk->regs + reg);\n}\n\nstatic inline void hsdk_pll_set_cfg(struct hsdk_pll_clk *clk,\n\t\t\t\t    const struct hsdk_pll_cfg *cfg)\n{\n\tu32 val = 0;\n\n\tif (cfg->bypass) {\n\t\tval = hsdk_pll_read(clk, CGU_PLL_CTRL);\n\t\tval |= CGU_PLL_CTRL_BYPASS;\n\t} else {\n\t\t \n\t\tval |= cfg->idiv << CGU_PLL_CTRL_IDIV_SHIFT;\n\t\tval |= cfg->fbdiv << CGU_PLL_CTRL_FBDIV_SHIFT;\n\t\tval |= cfg->odiv << CGU_PLL_CTRL_ODIV_SHIFT;\n\t\tval |= cfg->band << CGU_PLL_CTRL_BAND_SHIFT;\n\t}\n\n\tdev_dbg(clk->dev, \"write configuration: %#x\\n\", val);\n\n\thsdk_pll_write(clk, CGU_PLL_CTRL, val);\n}\n\nstatic inline bool hsdk_pll_is_locked(struct hsdk_pll_clk *clk)\n{\n\treturn !!(hsdk_pll_read(clk, CGU_PLL_STATUS) & CGU_PLL_STATUS_LOCK);\n}\n\nstatic inline bool hsdk_pll_is_err(struct hsdk_pll_clk *clk)\n{\n\treturn !!(hsdk_pll_read(clk, CGU_PLL_STATUS) & CGU_PLL_STATUS_ERR);\n}\n\nstatic inline struct hsdk_pll_clk *to_hsdk_pll_clk(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct hsdk_pll_clk, hw);\n}\n\nstatic unsigned long hsdk_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tu32 val;\n\tu64 rate;\n\tu32 idiv, fbdiv, odiv;\n\tstruct hsdk_pll_clk *clk = to_hsdk_pll_clk(hw);\n\n\tval = hsdk_pll_read(clk, CGU_PLL_CTRL);\n\n\tdev_dbg(clk->dev, \"current configuration: %#x\\n\", val);\n\n\t \n\tif (val & CGU_PLL_CTRL_BYPASS)\n\t\treturn parent_rate;\n\n\t \n\tif (val & CGU_PLL_CTRL_PD)\n\t\treturn 0;\n\n\t \n\tidiv = 1 + ((val & CGU_PLL_CTRL_IDIV_MASK) >> CGU_PLL_CTRL_IDIV_SHIFT);\n\t \n\tfbdiv = 2 * (1 + ((val & CGU_PLL_CTRL_FBDIV_MASK) >> CGU_PLL_CTRL_FBDIV_SHIFT));\n\t \n\todiv = 1 << ((val & CGU_PLL_CTRL_ODIV_MASK) >> CGU_PLL_CTRL_ODIV_SHIFT);\n\n\trate = (u64)parent_rate * fbdiv;\n\tdo_div(rate, idiv * odiv);\n\n\treturn rate;\n}\n\nstatic long hsdk_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *prate)\n{\n\tint i;\n\tunsigned long best_rate;\n\tstruct hsdk_pll_clk *clk = to_hsdk_pll_clk(hw);\n\tconst struct hsdk_pll_cfg *pll_cfg = clk->pll_devdata->pll_cfg;\n\n\tif (pll_cfg[0].rate == 0)\n\t\treturn -EINVAL;\n\n\tbest_rate = pll_cfg[0].rate;\n\n\tfor (i = 1; pll_cfg[i].rate != 0; i++) {\n\t\tif (abs(rate - pll_cfg[i].rate) < abs(rate - best_rate))\n\t\t\tbest_rate = pll_cfg[i].rate;\n\t}\n\n\tdev_dbg(clk->dev, \"chosen best rate: %lu\\n\", best_rate);\n\n\treturn best_rate;\n}\n\nstatic int hsdk_pll_comm_update_rate(struct hsdk_pll_clk *clk,\n\t\t\t\t     unsigned long rate,\n\t\t\t\t     const struct hsdk_pll_cfg *cfg)\n{\n\thsdk_pll_set_cfg(clk, cfg);\n\n\t \n\tudelay(HSDK_PLL_MAX_LOCK_TIME);\n\tif (!hsdk_pll_is_locked(clk))\n\t\treturn -ETIMEDOUT;\n\n\tif (hsdk_pll_is_err(clk))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int hsdk_pll_core_update_rate(struct hsdk_pll_clk *clk,\n\t\t\t\t     unsigned long rate,\n\t\t\t\t     const struct hsdk_pll_cfg *cfg)\n{\n\t \n\tif (rate > CORE_IF_CLK_THRESHOLD_HZ)\n\t\tiowrite32(CREG_CORE_IF_CLK_DIV_2, clk->spec_regs);\n\n\thsdk_pll_set_cfg(clk, cfg);\n\n\t \n\tudelay(HSDK_PLL_MAX_LOCK_TIME);\n\tif (!hsdk_pll_is_locked(clk))\n\t\treturn -ETIMEDOUT;\n\n\tif (hsdk_pll_is_err(clk))\n\t\treturn -EINVAL;\n\n\t \n\tif (rate <= CORE_IF_CLK_THRESHOLD_HZ)\n\t\tiowrite32(CREG_CORE_IF_CLK_DIV_1, clk->spec_regs);\n\n\treturn 0;\n}\n\nstatic int hsdk_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t     unsigned long parent_rate)\n{\n\tint i;\n\tstruct hsdk_pll_clk *clk = to_hsdk_pll_clk(hw);\n\tconst struct hsdk_pll_cfg *pll_cfg = clk->pll_devdata->pll_cfg;\n\n\tfor (i = 0; pll_cfg[i].rate != 0; i++) {\n\t\tif (pll_cfg[i].rate == rate) {\n\t\t\treturn clk->pll_devdata->update_rate(clk, rate,\n\t\t\t\t\t\t\t     &pll_cfg[i]);\n\t\t}\n\t}\n\n\tdev_err(clk->dev, \"invalid rate=%ld, parent_rate=%ld\\n\", rate,\n\t\t\tparent_rate);\n\n\treturn -EINVAL;\n}\n\nstatic const struct clk_ops hsdk_pll_ops = {\n\t.recalc_rate = hsdk_pll_recalc_rate,\n\t.round_rate = hsdk_pll_round_rate,\n\t.set_rate = hsdk_pll_set_rate,\n};\n\nstatic int hsdk_pll_clk_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tconst char *parent_name;\n\tunsigned int num_parents;\n\tstruct hsdk_pll_clk *pll_clk;\n\tstruct clk_init_data init = { };\n\tstruct device *dev = &pdev->dev;\n\n\tpll_clk = devm_kzalloc(dev, sizeof(*pll_clk), GFP_KERNEL);\n\tif (!pll_clk)\n\t\treturn -ENOMEM;\n\n\tpll_clk->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pll_clk->regs))\n\t\treturn PTR_ERR(pll_clk->regs);\n\n\tinit.name = dev->of_node->name;\n\tinit.ops = &hsdk_pll_ops;\n\tparent_name = of_clk_get_parent_name(dev->of_node, 0);\n\tinit.parent_names = &parent_name;\n\tnum_parents = of_clk_get_parent_count(dev->of_node);\n\tif (num_parents == 0 || num_parents > CGU_PLL_SOURCE_MAX) {\n\t\tdev_err(dev, \"wrong clock parents number: %u\\n\", num_parents);\n\t\treturn -EINVAL;\n\t}\n\tinit.num_parents = num_parents;\n\n\tpll_clk->hw.init = &init;\n\tpll_clk->dev = dev;\n\tpll_clk->pll_devdata = of_device_get_match_data(dev);\n\n\tif (!pll_clk->pll_devdata) {\n\t\tdev_err(dev, \"No OF match data provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = devm_clk_hw_register(dev, &pll_clk->hw);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register %s clock\\n\", init.name);\n\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,\n\t\t\t\t\t   &pll_clk->hw);\n}\n\nstatic void __init of_hsdk_pll_clk_setup(struct device_node *node)\n{\n\tint ret;\n\tconst char *parent_name;\n\tunsigned int num_parents;\n\tstruct hsdk_pll_clk *pll_clk;\n\tstruct clk_init_data init = { };\n\n\tpll_clk = kzalloc(sizeof(*pll_clk), GFP_KERNEL);\n\tif (!pll_clk)\n\t\treturn;\n\n\tpll_clk->regs = of_iomap(node, 0);\n\tif (!pll_clk->regs) {\n\t\tpr_err(\"failed to map pll registers\\n\");\n\t\tgoto err_free_pll_clk;\n\t}\n\n\tpll_clk->spec_regs = of_iomap(node, 1);\n\tif (!pll_clk->spec_regs) {\n\t\tpr_err(\"failed to map pll registers\\n\");\n\t\tgoto err_unmap_comm_regs;\n\t}\n\n\tinit.name = node->name;\n\tinit.ops = &hsdk_pll_ops;\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tinit.parent_names = &parent_name;\n\tnum_parents = of_clk_get_parent_count(node);\n\tif (num_parents > CGU_PLL_SOURCE_MAX) {\n\t\tpr_err(\"too much clock parents: %u\\n\", num_parents);\n\t\tgoto err_unmap_spec_regs;\n\t}\n\tinit.num_parents = num_parents;\n\n\tpll_clk->hw.init = &init;\n\tpll_clk->pll_devdata = &core_pll_devdata;\n\n\tret = clk_hw_register(NULL, &pll_clk->hw);\n\tif (ret) {\n\t\tpr_err(\"failed to register %pOFn clock\\n\", node);\n\t\tgoto err_unmap_spec_regs;\n\t}\n\n\tret = of_clk_add_hw_provider(node, of_clk_hw_simple_get, &pll_clk->hw);\n\tif (ret) {\n\t\tpr_err(\"failed to add hw provider for %pOFn clock\\n\", node);\n\t\tgoto err_unmap_spec_regs;\n\t}\n\n\treturn;\n\nerr_unmap_spec_regs:\n\tiounmap(pll_clk->spec_regs);\nerr_unmap_comm_regs:\n\tiounmap(pll_clk->regs);\nerr_free_pll_clk:\n\tkfree(pll_clk);\n}\n\n \nCLK_OF_DECLARE(hsdk_pll_clock, \"snps,hsdk-core-pll-clock\",\nof_hsdk_pll_clk_setup);\n\nstatic const struct of_device_id hsdk_pll_clk_id[] = {\n\t{ .compatible = \"snps,hsdk-gp-pll-clock\", .data = &sdt_pll_devdata},\n\t{ .compatible = \"snps,hsdk-hdmi-pll-clock\", .data = &hdmi_pll_devdata},\n\t{ }\n};\n\nstatic struct platform_driver hsdk_pll_clk_driver = {\n\t.driver = {\n\t\t.name = \"hsdk-gp-pll-clock\",\n\t\t.of_match_table = hsdk_pll_clk_id,\n\t},\n\t.probe = hsdk_pll_clk_probe,\n};\nbuiltin_platform_driver(hsdk_pll_clk_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}