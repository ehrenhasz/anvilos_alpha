{
  "module_name": "reset-stm32.c",
  "hash_id": "09a23343b19580055a40f1cb027c5916a7afe73ebe1c4d8d8ef38b938a0227a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/stm32/reset-stm32.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include \"clk-stm32-core.h\"\n\n#define STM32_RESET_ID_MASK GENMASK(15, 0)\n\nstruct stm32_reset_data {\n\t \n\tspinlock_t\t\t\tlock;\n\tstruct reset_controller_dev\trcdev;\n\tvoid __iomem\t\t\t*membase;\n\tu32\t\t\t\tclear_offset;\n};\n\nstatic inline struct stm32_reset_data *\nto_stm32_reset_data(struct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct stm32_reset_data, rcdev);\n}\n\nstatic int stm32_reset_update(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id, bool assert)\n{\n\tstruct stm32_reset_data *data = to_stm32_reset_data(rcdev);\n\tint reg_width = sizeof(u32);\n\tint bank = id / (reg_width * BITS_PER_BYTE);\n\tint offset = id % (reg_width * BITS_PER_BYTE);\n\n\tif (data->clear_offset) {\n\t\tvoid __iomem *addr;\n\n\t\taddr = data->membase + (bank * reg_width);\n\t\tif (!assert)\n\t\t\taddr += data->clear_offset;\n\n\t\twritel(BIT(offset), addr);\n\n\t} else {\n\t\tunsigned long flags;\n\t\tu32 reg;\n\n\t\tspin_lock_irqsave(&data->lock, flags);\n\n\t\treg = readl(data->membase + (bank * reg_width));\n\n\t\tif (assert)\n\t\t\treg |= BIT(offset);\n\t\telse\n\t\t\treg &= ~BIT(offset);\n\n\t\twritel(reg, data->membase + (bank * reg_width));\n\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\treturn stm32_reset_update(rcdev, id, true);\n}\n\nstatic int stm32_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\treturn stm32_reset_update(rcdev, id, false);\n}\n\nstatic int stm32_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct stm32_reset_data *data = to_stm32_reset_data(rcdev);\n\tint reg_width = sizeof(u32);\n\tint bank = id / (reg_width * BITS_PER_BYTE);\n\tint offset = id % (reg_width * BITS_PER_BYTE);\n\tu32 reg;\n\n\treg = readl(data->membase + (bank * reg_width));\n\n\treturn !!(reg & BIT(offset));\n}\n\nstatic const struct reset_control_ops stm32_reset_ops = {\n\t.assert\t\t= stm32_reset_assert,\n\t.deassert\t= stm32_reset_deassert,\n\t.status\t\t= stm32_reset_status,\n};\n\nint stm32_rcc_reset_init(struct device *dev, const struct of_device_id *match,\n\t\t\t void __iomem *base)\n{\n\tconst struct stm32_rcc_match_data *data = match->data;\n\tstruct stm32_reset_data *reset_data = NULL;\n\n\tdata = match->data;\n\n\treset_data = kzalloc(sizeof(*reset_data), GFP_KERNEL);\n\tif (!reset_data)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&reset_data->lock);\n\treset_data->membase = base;\n\treset_data->rcdev.owner = THIS_MODULE;\n\treset_data->rcdev.ops = &stm32_reset_ops;\n\treset_data->rcdev.of_node = dev_of_node(dev);\n\treset_data->rcdev.nr_resets = STM32_RESET_ID_MASK;\n\treset_data->clear_offset = data->clear_offset;\n\n\treturn reset_controller_register(&reset_data->rcdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}