{
  "module_name": "clk-stm32-core.c",
  "hash_id": "a39401c83549bcb8590d226ab83cae772266fb75c661d4fcc2d314970543fee2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/stm32/clk-stm32-core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include \"clk-stm32-core.h\"\n#include \"reset-stm32.h\"\n\nstatic DEFINE_SPINLOCK(rlock);\n\nstatic int stm32_rcc_clock_init(struct device *dev,\n\t\t\t\tconst struct of_device_id *match,\n\t\t\t\tvoid __iomem *base)\n{\n\tconst struct stm32_rcc_match_data *data = match->data;\n\tstruct clk_hw_onecell_data *clk_data = data->hw_clks;\n\tstruct device_node *np = dev_of_node(dev);\n\tstruct clk_hw **hws;\n\tint n, max_binding;\n\n\tmax_binding =  data->maxbinding;\n\n\tclk_data = devm_kzalloc(dev, struct_size(clk_data, hws, max_binding), GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tclk_data->num = max_binding;\n\n\thws = clk_data->hws;\n\n\tfor (n = 0; n < max_binding; n++)\n\t\thws[n] = ERR_PTR(-ENOENT);\n\n\tfor (n = 0; n < data->num_clocks; n++) {\n\t\tconst struct clock_config *cfg_clock = &data->tab_clocks[n];\n\t\tstruct clk_hw *hw = ERR_PTR(-ENOENT);\n\n\t\tif (data->check_security &&\n\t\t    data->check_security(base, cfg_clock))\n\t\t\tcontinue;\n\n\t\tif (cfg_clock->func)\n\t\t\thw = (*cfg_clock->func)(dev, data, base, &rlock,\n\t\t\t\t\t\tcfg_clock);\n\n\t\tif (IS_ERR(hw)) {\n\t\t\tdev_err(dev, \"Can't register clk %d: %ld\\n\", n,\n\t\t\t\tPTR_ERR(hw));\n\t\t\treturn PTR_ERR(hw);\n\t\t}\n\n\t\tif (cfg_clock->id != NO_ID)\n\t\t\thws[cfg_clock->id] = hw;\n\t}\n\n\treturn of_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_data);\n}\n\nint stm32_rcc_init(struct device *dev, const struct of_device_id *match_data,\n\t\t   void __iomem *base)\n{\n\tconst struct of_device_id *match;\n\tint err;\n\n\tmatch = of_match_node(match_data, dev_of_node(dev));\n\tif (!match) {\n\t\tdev_err(dev, \"match data not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\terr = stm32_rcc_reset_init(dev, match, base);\n\tif (err) {\n\t\tpr_err(\"stm32 reset failed to initialize\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = stm32_rcc_clock_init(dev, match, base);\n\tif (err) {\n\t\tpr_err(\"stm32 clock failed to initialize\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 stm32_mux_get_parent(void __iomem *base,\n\t\t\t       struct clk_stm32_clock_data *data,\n\t\t\t       u16 mux_id)\n{\n\tconst struct stm32_mux_cfg *mux = &data->muxes[mux_id];\n\tu32 mask = BIT(mux->width) - 1;\n\tu32 val;\n\n\tval = readl(base + mux->offset) >> mux->shift;\n\tval &= mask;\n\n\treturn val;\n}\n\nstatic int stm32_mux_set_parent(void __iomem *base,\n\t\t\t\tstruct clk_stm32_clock_data *data,\n\t\t\t\tu16 mux_id, u8 index)\n{\n\tconst struct stm32_mux_cfg *mux = &data->muxes[mux_id];\n\n\tu32 mask = BIT(mux->width) - 1;\n\tu32 reg = readl(base + mux->offset);\n\tu32 val = index << mux->shift;\n\n\treg &= ~(mask << mux->shift);\n\treg |= val;\n\n\twritel(reg, base + mux->offset);\n\n\treturn 0;\n}\n\nstatic void stm32_gate_endisable(void __iomem *base,\n\t\t\t\t struct clk_stm32_clock_data *data,\n\t\t\t\t u16 gate_id, int enable)\n{\n\tconst struct stm32_gate_cfg *gate = &data->gates[gate_id];\n\tvoid __iomem *addr = base + gate->offset;\n\n\tif (enable) {\n\t\tif (data->gate_cpt[gate_id]++ > 0)\n\t\t\treturn;\n\n\t\tif (gate->set_clr != 0)\n\t\t\twritel(BIT(gate->bit_idx), addr);\n\t\telse\n\t\t\twritel(readl(addr) | BIT(gate->bit_idx), addr);\n\t} else {\n\t\tif (--data->gate_cpt[gate_id] > 0)\n\t\t\treturn;\n\n\t\tif (gate->set_clr != 0)\n\t\t\twritel(BIT(gate->bit_idx), addr + gate->set_clr);\n\t\telse\n\t\t\twritel(readl(addr) & ~BIT(gate->bit_idx), addr);\n\t}\n}\n\nstatic void stm32_gate_disable_unused(void __iomem *base,\n\t\t\t\t      struct clk_stm32_clock_data *data,\n\t\t\t\t      u16 gate_id)\n{\n\tconst struct stm32_gate_cfg *gate = &data->gates[gate_id];\n\tvoid __iomem *addr = base + gate->offset;\n\n\tif (data->gate_cpt[gate_id] > 0)\n\t\treturn;\n\n\tif (gate->set_clr != 0)\n\t\twritel(BIT(gate->bit_idx), addr + gate->set_clr);\n\telse\n\t\twritel(readl(addr) & ~BIT(gate->bit_idx), addr);\n}\n\nstatic int stm32_gate_is_enabled(void __iomem *base,\n\t\t\t\t struct clk_stm32_clock_data *data,\n\t\t\t\t u16 gate_id)\n{\n\tconst struct stm32_gate_cfg *gate = &data->gates[gate_id];\n\n\treturn (readl(base + gate->offset) & BIT(gate->bit_idx)) != 0;\n}\n\nstatic unsigned int _get_table_div(const struct clk_div_table *table,\n\t\t\t\t   unsigned int val)\n{\n\tconst struct clk_div_table *clkt;\n\n\tfor (clkt = table; clkt->div; clkt++)\n\t\tif (clkt->val == val)\n\t\t\treturn clkt->div;\n\treturn 0;\n}\n\nstatic unsigned int _get_div(const struct clk_div_table *table,\n\t\t\t     unsigned int val, unsigned long flags, u8 width)\n{\n\tif (flags & CLK_DIVIDER_ONE_BASED)\n\t\treturn val;\n\tif (flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\treturn 1 << val;\n\tif (table)\n\t\treturn _get_table_div(table, val);\n\treturn val + 1;\n}\n\nstatic unsigned long stm32_divider_get_rate(void __iomem *base,\n\t\t\t\t\t    struct clk_stm32_clock_data *data,\n\t\t\t\t\t    u16 div_id,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tconst struct stm32_div_cfg *divider = &data->dividers[div_id];\n\tunsigned int val;\n\tunsigned int div;\n\n\tval =  readl(base + divider->offset) >> divider->shift;\n\tval &= clk_div_mask(divider->width);\n\tdiv = _get_div(divider->table, val, divider->flags, divider->width);\n\n\tif (!div) {\n\t\tWARN(!(divider->flags & CLK_DIVIDER_ALLOW_ZERO),\n\t\t     \"%d: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set\\n\",\n\t\t     div_id);\n\t\treturn parent_rate;\n\t}\n\n\treturn DIV_ROUND_UP_ULL((u64)parent_rate, div);\n}\n\nstatic int stm32_divider_set_rate(void __iomem *base,\n\t\t\t\t  struct clk_stm32_clock_data *data,\n\t\t\t\t  u16 div_id, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tconst struct stm32_div_cfg *divider = &data->dividers[div_id];\n\tint value;\n\tu32 val;\n\n\tvalue = divider_get_val(rate, parent_rate, divider->table,\n\t\t\t\tdivider->width, divider->flags);\n\tif (value < 0)\n\t\treturn value;\n\n\tif (divider->flags & CLK_DIVIDER_HIWORD_MASK) {\n\t\tval = clk_div_mask(divider->width) << (divider->shift + 16);\n\t} else {\n\t\tval = readl(base + divider->offset);\n\t\tval &= ~(clk_div_mask(divider->width) << divider->shift);\n\t}\n\n\tval |= (u32)value << divider->shift;\n\n\twritel(val, base + divider->offset);\n\n\treturn 0;\n}\n\nstatic u8 clk_stm32_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_stm32_mux *mux = to_clk_stm32_mux(hw);\n\n\treturn stm32_mux_get_parent(mux->base, mux->clock_data, mux->mux_id);\n}\n\nstatic int clk_stm32_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_stm32_mux *mux = to_clk_stm32_mux(hw);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(mux->lock, flags);\n\n\tstm32_mux_set_parent(mux->base, mux->clock_data, mux->mux_id, index);\n\n\tspin_unlock_irqrestore(mux->lock, flags);\n\n\treturn 0;\n}\n\nconst struct clk_ops clk_stm32_mux_ops = {\n\t.determine_rate\t= __clk_mux_determine_rate,\n\t.get_parent\t= clk_stm32_mux_get_parent,\n\t.set_parent\t= clk_stm32_mux_set_parent,\n};\n\nstatic void clk_stm32_gate_endisable(struct clk_hw *hw, int enable)\n{\n\tstruct clk_stm32_gate *gate = to_clk_stm32_gate(hw);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tstm32_gate_endisable(gate->base, gate->clock_data, gate->gate_id, enable);\n\n\tspin_unlock_irqrestore(gate->lock, flags);\n}\n\nstatic int clk_stm32_gate_enable(struct clk_hw *hw)\n{\n\tclk_stm32_gate_endisable(hw, 1);\n\n\treturn 0;\n}\n\nstatic void clk_stm32_gate_disable(struct clk_hw *hw)\n{\n\tclk_stm32_gate_endisable(hw, 0);\n}\n\nstatic int clk_stm32_gate_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_stm32_gate *gate = to_clk_stm32_gate(hw);\n\n\treturn stm32_gate_is_enabled(gate->base, gate->clock_data, gate->gate_id);\n}\n\nstatic void clk_stm32_gate_disable_unused(struct clk_hw *hw)\n{\n\tstruct clk_stm32_gate *gate = to_clk_stm32_gate(hw);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tstm32_gate_disable_unused(gate->base, gate->clock_data, gate->gate_id);\n\n\tspin_unlock_irqrestore(gate->lock, flags);\n}\n\nconst struct clk_ops clk_stm32_gate_ops = {\n\t.enable\t\t= clk_stm32_gate_enable,\n\t.disable\t= clk_stm32_gate_disable,\n\t.is_enabled\t= clk_stm32_gate_is_enabled,\n\t.disable_unused\t= clk_stm32_gate_disable_unused,\n};\n\nstatic int clk_stm32_divider_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct clk_stm32_div *div = to_clk_stm32_divider(hw);\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (div->div_id == NO_STM32_DIV)\n\t\treturn rate;\n\n\tspin_lock_irqsave(div->lock, flags);\n\n\tret = stm32_divider_set_rate(div->base, div->clock_data, div->div_id, rate, parent_rate);\n\n\tspin_unlock_irqrestore(div->lock, flags);\n\n\treturn ret;\n}\n\nstatic long clk_stm32_divider_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t unsigned long *prate)\n{\n\tstruct clk_stm32_div *div = to_clk_stm32_divider(hw);\n\tconst struct stm32_div_cfg *divider;\n\n\tif (div->div_id == NO_STM32_DIV)\n\t\treturn rate;\n\n\tdivider = &div->clock_data->dividers[div->div_id];\n\n\t \n\tif (divider->flags & CLK_DIVIDER_READ_ONLY) {\n\t\tu32 val;\n\n\t\tval =  readl(div->base + divider->offset) >> divider->shift;\n\t\tval &= clk_div_mask(divider->width);\n\n\t\treturn divider_ro_round_rate(hw, rate, prate, divider->table,\n\t\t\t\tdivider->width, divider->flags,\n\t\t\t\tval);\n\t}\n\n\treturn divider_round_rate_parent(hw, clk_hw_get_parent(hw),\n\t\t\t\t\t rate, prate, divider->table,\n\t\t\t\t\t divider->width, divider->flags);\n}\n\nstatic unsigned long clk_stm32_divider_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct clk_stm32_div *div = to_clk_stm32_divider(hw);\n\n\tif (div->div_id == NO_STM32_DIV)\n\t\treturn parent_rate;\n\n\treturn stm32_divider_get_rate(div->base, div->clock_data, div->div_id, parent_rate);\n}\n\nconst struct clk_ops clk_stm32_divider_ops = {\n\t.recalc_rate\t= clk_stm32_divider_recalc_rate,\n\t.round_rate\t= clk_stm32_divider_round_rate,\n\t.set_rate\t= clk_stm32_divider_set_rate,\n};\n\nstatic int clk_stm32_composite_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_stm32_composite *composite = to_clk_stm32_composite(hw);\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (composite->div_id == NO_STM32_DIV)\n\t\treturn rate;\n\n\tspin_lock_irqsave(composite->lock, flags);\n\n\tret = stm32_divider_set_rate(composite->base, composite->clock_data,\n\t\t\t\t     composite->div_id, rate, parent_rate);\n\n\tspin_unlock_irqrestore(composite->lock, flags);\n\n\treturn ret;\n}\n\nstatic unsigned long clk_stm32_composite_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct clk_stm32_composite *composite = to_clk_stm32_composite(hw);\n\n\tif (composite->div_id == NO_STM32_DIV)\n\t\treturn parent_rate;\n\n\treturn stm32_divider_get_rate(composite->base, composite->clock_data,\n\t\t\t\t      composite->div_id, parent_rate);\n}\n\nstatic int clk_stm32_composite_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t      struct clk_rate_request *req)\n{\n\tstruct clk_stm32_composite *composite = to_clk_stm32_composite(hw);\n\tconst struct stm32_div_cfg *divider;\n\tlong rate;\n\n\tif (composite->div_id == NO_STM32_DIV)\n\t\treturn 0;\n\n\tdivider = &composite->clock_data->dividers[composite->div_id];\n\n\t \n\tif (divider->flags & CLK_DIVIDER_READ_ONLY) {\n\t\tu32 val;\n\n\t\tval =  readl(composite->base + divider->offset) >> divider->shift;\n\t\tval &= clk_div_mask(divider->width);\n\n\t\trate = divider_ro_round_rate(hw, req->rate, &req->best_parent_rate,\n\t\t\t\t\t     divider->table, divider->width, divider->flags,\n\t\t\t\t\t     val);\n\t\tif (rate < 0)\n\t\t\treturn rate;\n\n\t\treq->rate = rate;\n\t\treturn 0;\n\t}\n\n\trate = divider_round_rate_parent(hw, clk_hw_get_parent(hw),\n\t\t\t\t\t req->rate, &req->best_parent_rate,\n\t\t\t\t\t divider->table, divider->width, divider->flags);\n\tif (rate < 0)\n\t\treturn rate;\n\n\treq->rate = rate;\n\treturn 0;\n}\n\nstatic u8 clk_stm32_composite_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_stm32_composite *composite = to_clk_stm32_composite(hw);\n\n\treturn stm32_mux_get_parent(composite->base, composite->clock_data, composite->mux_id);\n}\n\nstatic int clk_stm32_composite_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_stm32_composite *composite = to_clk_stm32_composite(hw);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(composite->lock, flags);\n\n\tstm32_mux_set_parent(composite->base, composite->clock_data, composite->mux_id, index);\n\n\tspin_unlock_irqrestore(composite->lock, flags);\n\n\tif (composite->clock_data->is_multi_mux) {\n\t\tstruct clk_hw *other_mux_hw = composite->clock_data->is_multi_mux(hw);\n\n\t\tif (other_mux_hw) {\n\t\t\tstruct clk_hw *hwp = clk_hw_get_parent_by_index(hw, index);\n\n\t\t\tclk_hw_reparent(other_mux_hw, hwp);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int clk_stm32_composite_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_stm32_composite *composite = to_clk_stm32_composite(hw);\n\n\tif (composite->gate_id == NO_STM32_GATE)\n\t\treturn (__clk_get_enable_count(hw->clk) > 0);\n\n\treturn stm32_gate_is_enabled(composite->base, composite->clock_data, composite->gate_id);\n}\n\n#define MUX_SAFE_POSITION 0\n\nstatic int clk_stm32_has_safe_mux(struct clk_hw *hw)\n{\n\tstruct clk_stm32_composite *composite = to_clk_stm32_composite(hw);\n\tconst struct stm32_mux_cfg *mux = &composite->clock_data->muxes[composite->mux_id];\n\n\treturn !!(mux->flags & MUX_SAFE);\n}\n\nstatic void clk_stm32_set_safe_position_mux(struct clk_hw *hw)\n{\n\tstruct clk_stm32_composite *composite = to_clk_stm32_composite(hw);\n\n\tif (!clk_stm32_composite_is_enabled(hw)) {\n\t\tunsigned long flags = 0;\n\n\t\tif (composite->clock_data->is_multi_mux) {\n\t\t\tstruct clk_hw *other_mux_hw = NULL;\n\n\t\t\tother_mux_hw = composite->clock_data->is_multi_mux(hw);\n\n\t\t\tif (!other_mux_hw || clk_stm32_composite_is_enabled(other_mux_hw))\n\t\t\t\treturn;\n\t\t}\n\n\t\tspin_lock_irqsave(composite->lock, flags);\n\n\t\tstm32_mux_set_parent(composite->base, composite->clock_data,\n\t\t\t\t     composite->mux_id, MUX_SAFE_POSITION);\n\n\t\tspin_unlock_irqrestore(composite->lock, flags);\n\t}\n}\n\nstatic void clk_stm32_safe_restore_position_mux(struct clk_hw *hw)\n{\n\tstruct clk_stm32_composite *composite = to_clk_stm32_composite(hw);\n\tint sel = clk_hw_get_parent_index(hw);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(composite->lock, flags);\n\n\tstm32_mux_set_parent(composite->base, composite->clock_data, composite->mux_id, sel);\n\n\tspin_unlock_irqrestore(composite->lock, flags);\n}\n\nstatic void clk_stm32_composite_gate_endisable(struct clk_hw *hw, int enable)\n{\n\tstruct clk_stm32_composite *composite = to_clk_stm32_composite(hw);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(composite->lock, flags);\n\n\tstm32_gate_endisable(composite->base, composite->clock_data, composite->gate_id, enable);\n\n\tspin_unlock_irqrestore(composite->lock, flags);\n}\n\nstatic int clk_stm32_composite_gate_enable(struct clk_hw *hw)\n{\n\tstruct clk_stm32_composite *composite = to_clk_stm32_composite(hw);\n\n\tif (composite->gate_id == NO_STM32_GATE)\n\t\treturn 0;\n\n\tclk_stm32_composite_gate_endisable(hw, 1);\n\n\tif (composite->mux_id != NO_STM32_MUX && clk_stm32_has_safe_mux(hw))\n\t\tclk_stm32_safe_restore_position_mux(hw);\n\n\treturn 0;\n}\n\nstatic void clk_stm32_composite_gate_disable(struct clk_hw *hw)\n{\n\tstruct clk_stm32_composite *composite = to_clk_stm32_composite(hw);\n\n\tif (composite->gate_id == NO_STM32_GATE)\n\t\treturn;\n\n\tclk_stm32_composite_gate_endisable(hw, 0);\n\n\tif (composite->mux_id != NO_STM32_MUX && clk_stm32_has_safe_mux(hw))\n\t\tclk_stm32_set_safe_position_mux(hw);\n}\n\nstatic void clk_stm32_composite_disable_unused(struct clk_hw *hw)\n{\n\tstruct clk_stm32_composite *composite = to_clk_stm32_composite(hw);\n\tunsigned long flags = 0;\n\n\tif (composite->gate_id == NO_STM32_GATE)\n\t\treturn;\n\n\tspin_lock_irqsave(composite->lock, flags);\n\n\tstm32_gate_disable_unused(composite->base, composite->clock_data, composite->gate_id);\n\n\tspin_unlock_irqrestore(composite->lock, flags);\n}\n\nconst struct clk_ops clk_stm32_composite_ops = {\n\t.set_rate\t= clk_stm32_composite_set_rate,\n\t.recalc_rate\t= clk_stm32_composite_recalc_rate,\n\t.determine_rate\t= clk_stm32_composite_determine_rate,\n\t.get_parent\t= clk_stm32_composite_get_parent,\n\t.set_parent\t= clk_stm32_composite_set_parent,\n\t.enable\t\t= clk_stm32_composite_gate_enable,\n\t.disable\t= clk_stm32_composite_gate_disable,\n\t.is_enabled\t= clk_stm32_composite_is_enabled,\n\t.disable_unused\t= clk_stm32_composite_disable_unused,\n};\n\nstruct clk_hw *clk_stm32_mux_register(struct device *dev,\n\t\t\t\t      const struct stm32_rcc_match_data *data,\n\t\t\t\t      void __iomem *base,\n\t\t\t\t      spinlock_t *lock,\n\t\t\t\t      const struct clock_config *cfg)\n{\n\tstruct clk_stm32_mux *mux = cfg->clock_cfg;\n\tstruct clk_hw *hw = &mux->hw;\n\tint err;\n\n\tmux->base = base;\n\tmux->lock = lock;\n\tmux->clock_data = data->clock_data;\n\n\terr = clk_hw_register(dev, hw);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn hw;\n}\n\nstruct clk_hw *clk_stm32_gate_register(struct device *dev,\n\t\t\t\t       const struct stm32_rcc_match_data *data,\n\t\t\t\t       void __iomem *base,\n\t\t\t\t       spinlock_t *lock,\n\t\t\t\t       const struct clock_config *cfg)\n{\n\tstruct clk_stm32_gate *gate = cfg->clock_cfg;\n\tstruct clk_hw *hw = &gate->hw;\n\tint err;\n\n\tgate->base = base;\n\tgate->lock = lock;\n\tgate->clock_data = data->clock_data;\n\n\terr = clk_hw_register(dev, hw);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn hw;\n}\n\nstruct clk_hw *clk_stm32_div_register(struct device *dev,\n\t\t\t\t      const struct stm32_rcc_match_data *data,\n\t\t\t\t      void __iomem *base,\n\t\t\t\t      spinlock_t *lock,\n\t\t\t\t      const struct clock_config *cfg)\n{\n\tstruct clk_stm32_div *div = cfg->clock_cfg;\n\tstruct clk_hw *hw = &div->hw;\n\tint err;\n\n\tdiv->base = base;\n\tdiv->lock = lock;\n\tdiv->clock_data = data->clock_data;\n\n\terr = clk_hw_register(dev, hw);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn hw;\n}\n\nstruct clk_hw *clk_stm32_composite_register(struct device *dev,\n\t\t\t\t\t    const struct stm32_rcc_match_data *data,\n\t\t\t\t\t    void __iomem *base,\n\t\t\t\t\t    spinlock_t *lock,\n\t\t\t\t\t    const struct clock_config *cfg)\n{\n\tstruct clk_stm32_composite *composite = cfg->clock_cfg;\n\tstruct clk_hw *hw = &composite->hw;\n\tint err;\n\n\tcomposite->base = base;\n\tcomposite->lock = lock;\n\tcomposite->clock_data = data->clock_data;\n\n\terr = clk_hw_register(dev, hw);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}