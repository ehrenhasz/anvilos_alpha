{
  "module_name": "reset.c",
  "hash_id": "1a1f8e4611f5b27d641634ba5eb6b263742e06e1ca5755394e5d544a79e59d95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/visconti/reset.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"reset.h\"\n\nstatic inline struct visconti_reset *to_visconti_reset(struct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct visconti_reset, rcdev);\n}\n\nstatic int visconti_reset_assert(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tstruct visconti_reset *reset = to_visconti_reset(rcdev);\n\tconst struct visconti_reset_data *data = &reset->resets[id];\n\tu32 rst = BIT(data->rs_idx);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(reset->lock, flags);\n\tret = regmap_update_bits(reset->regmap, data->rson_offset, rst, rst);\n\tspin_unlock_irqrestore(reset->lock, flags);\n\n\treturn ret;\n}\n\nstatic int visconti_reset_deassert(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tstruct visconti_reset *reset = to_visconti_reset(rcdev);\n\tconst struct visconti_reset_data *data = &reset->resets[id];\n\tu32 rst = BIT(data->rs_idx);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(reset->lock, flags);\n\tret = regmap_update_bits(reset->regmap, data->rsoff_offset, rst, rst);\n\tspin_unlock_irqrestore(reset->lock, flags);\n\n\treturn ret;\n}\n\nstatic int visconti_reset_reset(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tvisconti_reset_assert(rcdev, id);\n\tudelay(1);\n\tvisconti_reset_deassert(rcdev, id);\n\n\treturn 0;\n}\n\nstatic int visconti_reset_status(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tstruct visconti_reset *reset = to_visconti_reset(rcdev);\n\tconst struct visconti_reset_data *data = &reset->resets[id];\n\tunsigned long flags;\n\tu32 reg;\n\tint ret;\n\n\tspin_lock_irqsave(reset->lock, flags);\n\tret = regmap_read(reset->regmap, data->rson_offset, &reg);\n\tspin_unlock_irqrestore(reset->lock, flags);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !(reg & data->rs_idx);\n}\n\nconst struct reset_control_ops visconti_reset_ops = {\n\t.assert\t\t= visconti_reset_assert,\n\t.deassert\t= visconti_reset_deassert,\n\t.reset\t\t= visconti_reset_reset,\n\t.status\t\t= visconti_reset_status,\n};\n\nint visconti_register_reset_controller(struct device *dev,\n\t\t\t\t       struct regmap *regmap,\n\t\t\t\t       const struct visconti_reset_data *resets,\n\t\t\t\t       unsigned int num_resets,\n\t\t\t\t       const struct reset_control_ops *reset_ops,\n\t\t\t\t       spinlock_t *lock)\n{\n\tstruct visconti_reset *reset;\n\n\treset = devm_kzalloc(dev, sizeof(*reset), GFP_KERNEL);\n\tif (!reset)\n\t\treturn -ENOMEM;\n\n\treset->regmap = regmap;\n\treset->resets = resets;\n\treset->rcdev.ops = reset_ops;\n\treset->rcdev.nr_resets = num_resets;\n\treset->rcdev.of_node = dev->of_node;\n\treset->lock = lock;\n\n\treturn devm_reset_controller_register(dev, &reset->rcdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}