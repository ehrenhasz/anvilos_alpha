{
  "module_name": "pll.c",
  "hash_id": "428881c37bca4d90419169f54cb39b67843ce67ba583809248d58fccc5ee9fcf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/visconti/pll.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n#include \"pll.h\"\n\nstruct visconti_pll {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*pll_base;\n\tspinlock_t\t*lock;\n\tunsigned long flags;\n\tconst struct visconti_pll_rate_table *rate_table;\n\tsize_t rate_count;\n\tstruct visconti_pll_provider *ctx;\n};\n\n#define PLL_CONF_REG\t\t0x0000\n#define PLL_CTRL_REG\t\t0x0004\n#define PLL_FRACMODE_REG\t0x0010\n#define PLL_INTIN_REG\t\t0x0014\n#define PLL_FRACIN_REG\t\t0x0018\n#define PLL_REFDIV_REG\t\t0x001c\n#define PLL_POSTDIV_REG\t\t0x0020\n\n#define PLL_CONFIG_SEL\t\tBIT(0)\n#define PLL_PLLEN\t\tBIT(4)\n#define PLL_BYPASS\t\tBIT(16)\n#define PLL_INTIN_MASK\t\tGENMASK(11, 0)\n#define PLL_FRACIN_MASK\t\tGENMASK(23, 0)\n#define PLL_REFDIV_MASK\t\tGENMASK(5, 0)\n#define PLL_POSTDIV_MASK\tGENMASK(2, 0)\n\n#define PLL0_FRACMODE_DACEN\tBIT(4)\n#define PLL0_FRACMODE_DSMEN\tBIT(0)\n\n#define PLL_CREATE_FRACMODE(table) (table->dacen << 4 | table->dsmen)\n#define PLL_CREATE_OSTDIV(table) (table->postdiv2 << 4 | table->postdiv1)\n\nstatic inline struct visconti_pll *to_visconti_pll(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct visconti_pll, hw);\n}\n\nstatic void visconti_pll_get_params(struct visconti_pll *pll,\n\t\t\t\t    struct visconti_pll_rate_table *rate_table)\n{\n\tu32 postdiv, val;\n\n\tval = readl(pll->pll_base + PLL_FRACMODE_REG);\n\n\trate_table->dacen = FIELD_GET(PLL0_FRACMODE_DACEN, val);\n\trate_table->dsmen = FIELD_GET(PLL0_FRACMODE_DSMEN, val);\n\n\trate_table->fracin = readl(pll->pll_base + PLL_FRACIN_REG) & PLL_FRACIN_MASK;\n\trate_table->intin = readl(pll->pll_base + PLL_INTIN_REG) & PLL_INTIN_MASK;\n\trate_table->refdiv = readl(pll->pll_base + PLL_REFDIV_REG) & PLL_REFDIV_MASK;\n\n\tpostdiv = readl(pll->pll_base + PLL_POSTDIV_REG);\n\trate_table->postdiv1 = postdiv & PLL_POSTDIV_MASK;\n\trate_table->postdiv2 = (postdiv >> 4) & PLL_POSTDIV_MASK;\n}\n\nstatic const struct visconti_pll_rate_table *visconti_get_pll_settings(struct visconti_pll *pll,\n\t\t\t\t\t\t\t\t       unsigned long rate)\n{\n\tconst struct visconti_pll_rate_table *rate_table = pll->rate_table;\n\tint i;\n\n\tfor (i = 0; i < pll->rate_count; i++)\n\t\tif (rate == rate_table[i].rate)\n\t\t\treturn &rate_table[i];\n\n\treturn NULL;\n}\n\nstatic unsigned long visconti_get_pll_rate_from_data(struct visconti_pll *pll,\n\t\t\t\t\t\t     const struct visconti_pll_rate_table *rate)\n{\n\tconst struct visconti_pll_rate_table *rate_table = pll->rate_table;\n\tint i;\n\n\tfor (i = 0; i < pll->rate_count; i++)\n\t\tif (memcmp(&rate_table[i].dacen, &rate->dacen,\n\t\t\tsizeof(*rate) - sizeof(unsigned long)) == 0)\n\t\t\treturn rate_table[i].rate;\n\n\t \n\treturn rate_table[0].rate;\n}\n\nstatic long visconti_pll_round_rate(struct clk_hw *hw,\n\t\t\t\t    unsigned long rate, unsigned long *prate)\n{\n\tstruct visconti_pll *pll = to_visconti_pll(hw);\n\tconst struct visconti_pll_rate_table *rate_table = pll->rate_table;\n\tint i;\n\n\t \n\tfor (i = 0; i < pll->rate_count; i++)\n\t\tif (rate >= rate_table[i].rate)\n\t\t\treturn rate_table[i].rate;\n\n\t \n\treturn rate_table[i - 1].rate;\n}\n\nstatic unsigned long visconti_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct visconti_pll *pll = to_visconti_pll(hw);\n\tstruct visconti_pll_rate_table rate_table;\n\n\tmemset(&rate_table, 0, sizeof(rate_table));\n\tvisconti_pll_get_params(pll, &rate_table);\n\n\treturn visconti_get_pll_rate_from_data(pll, &rate_table);\n}\n\nstatic int visconti_pll_set_params(struct visconti_pll *pll,\n\t\t\t\t   const struct visconti_pll_rate_table *rate_table)\n{\n\twritel(PLL_CREATE_FRACMODE(rate_table), pll->pll_base + PLL_FRACMODE_REG);\n\twritel(PLL_CREATE_OSTDIV(rate_table), pll->pll_base + PLL_POSTDIV_REG);\n\twritel(rate_table->intin, pll->pll_base + PLL_INTIN_REG);\n\twritel(rate_table->fracin, pll->pll_base + PLL_FRACIN_REG);\n\twritel(rate_table->refdiv, pll->pll_base + PLL_REFDIV_REG);\n\n\treturn 0;\n}\n\nstatic int visconti_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct visconti_pll *pll = to_visconti_pll(hw);\n\tconst struct visconti_pll_rate_table *rate_table;\n\n\trate_table = visconti_get_pll_settings(pll, rate);\n\tif (!rate_table)\n\t\treturn -EINVAL;\n\n\treturn visconti_pll_set_params(pll, rate_table);\n}\n\nstatic int visconti_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct visconti_pll *pll = to_visconti_pll(hw);\n\tu32 reg;\n\n\treg = readl(pll->pll_base + PLL_CTRL_REG);\n\n\treturn (reg & PLL_PLLEN);\n}\n\nstatic int visconti_pll_enable(struct clk_hw *hw)\n{\n\tstruct visconti_pll *pll = to_visconti_pll(hw);\n\tconst struct visconti_pll_rate_table *rate_table = pll->rate_table;\n\tunsigned long flags;\n\tu32 reg;\n\n\tif (visconti_pll_is_enabled(hw))\n\t\treturn 0;\n\n\tspin_lock_irqsave(pll->lock, flags);\n\n\twritel(PLL_CONFIG_SEL, pll->pll_base + PLL_CONF_REG);\n\n\treg = readl(pll->pll_base + PLL_CTRL_REG);\n\treg |= PLL_BYPASS;\n\twritel(reg, pll->pll_base + PLL_CTRL_REG);\n\n\tvisconti_pll_set_params(pll, &rate_table[0]);\n\n\treg = readl(pll->pll_base + PLL_CTRL_REG);\n\treg &= ~PLL_PLLEN;\n\twritel(reg, pll->pll_base + PLL_CTRL_REG);\n\n\tudelay(1);\n\n\treg = readl(pll->pll_base + PLL_CTRL_REG);\n\treg |= PLL_PLLEN;\n\twritel(reg, pll->pll_base + PLL_CTRL_REG);\n\n\tudelay(40);\n\n\treg = readl(pll->pll_base + PLL_CTRL_REG);\n\treg &= ~PLL_BYPASS;\n\twritel(reg, pll->pll_base + PLL_CTRL_REG);\n\n\tspin_unlock_irqrestore(pll->lock, flags);\n\n\treturn 0;\n}\n\nstatic void visconti_pll_disable(struct clk_hw *hw)\n{\n\tstruct visconti_pll *pll = to_visconti_pll(hw);\n\tunsigned long flags;\n\tu32 reg;\n\n\tif (!visconti_pll_is_enabled(hw))\n\t\treturn;\n\n\tspin_lock_irqsave(pll->lock, flags);\n\n\twritel(PLL_CONFIG_SEL, pll->pll_base + PLL_CONF_REG);\n\n\treg = readl(pll->pll_base + PLL_CTRL_REG);\n\treg |= PLL_BYPASS;\n\twritel(reg, pll->pll_base + PLL_CTRL_REG);\n\n\treg = readl(pll->pll_base + PLL_CTRL_REG);\n\treg &= ~PLL_PLLEN;\n\twritel(reg, pll->pll_base + PLL_CTRL_REG);\n\n\tspin_unlock_irqrestore(pll->lock, flags);\n}\n\nstatic const struct clk_ops visconti_pll_ops = {\n\t.enable = visconti_pll_enable,\n\t.disable = visconti_pll_disable,\n\t.is_enabled = visconti_pll_is_enabled,\n\t.round_rate = visconti_pll_round_rate,\n\t.recalc_rate = visconti_pll_recalc_rate,\n\t.set_rate = visconti_pll_set_rate,\n};\n\nstatic struct clk_hw *visconti_register_pll(struct visconti_pll_provider *ctx,\n\t\t\t\t\t    const char *name,\n\t\t\t\t\t    const char *parent_name,\n\t\t\t\t\t    int offset,\n\t\t\t\t\t    const struct visconti_pll_rate_table *rate_table,\n\t\t\t\t\t    spinlock_t *lock)\n{\n\tstruct clk_init_data init;\n\tstruct visconti_pll *pll;\n\tstruct clk_hw *pll_hw_clk;\n\tsize_t len;\n\tint ret;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.flags = CLK_IGNORE_UNUSED;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tfor (len = 0; rate_table[len].rate != 0; )\n\t\tlen++;\n\tpll->rate_count = len;\n\tpll->rate_table = kmemdup(rate_table,\n\t\t\t\t  pll->rate_count * sizeof(struct visconti_pll_rate_table),\n\t\t\t\t  GFP_KERNEL);\n\tWARN(!pll->rate_table, \"%s: could not allocate rate table for %s\\n\", __func__, name);\n\n\tinit.ops = &visconti_pll_ops;\n\tpll->hw.init = &init;\n\tpll->pll_base = ctx->reg_base + offset;\n\tpll->lock = lock;\n\tpll->ctx = ctx;\n\n\tpll_hw_clk = &pll->hw;\n\tret = clk_hw_register(NULL, &pll->hw);\n\tif (ret) {\n\t\tpr_err(\"failed to register pll clock %s : %d\\n\", name, ret);\n\t\tkfree(pll->rate_table);\n\t\tkfree(pll);\n\t\tpll_hw_clk = ERR_PTR(ret);\n\t}\n\n\treturn pll_hw_clk;\n}\n\nstatic void visconti_pll_add_lookup(struct visconti_pll_provider *ctx,\n\t\t\t\t    struct clk_hw *hw_clk,\n\t\t\t\t    unsigned int id)\n{\n\tif (id)\n\t\tctx->clk_data.hws[id] = hw_clk;\n}\n\nvoid __init visconti_register_plls(struct visconti_pll_provider *ctx,\n\t\t\t\t   const struct visconti_pll_info *list,\n\t\t\t\t   unsigned int nr_plls,\n\t\t\t\t   spinlock_t *lock)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < nr_plls; idx++, list++) {\n\t\tstruct clk_hw *clk;\n\n\t\tclk = visconti_register_pll(ctx,\n\t\t\t\t\t    list->name,\n\t\t\t\t\t    list->parent,\n\t\t\t\t\t    list->base_reg,\n\t\t\t\t\t    list->rate_table,\n\t\t\t\t\t    lock);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"failed to register clock %s\\n\", list->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvisconti_pll_add_lookup(ctx, clk, list->id);\n\t}\n}\n\nstruct visconti_pll_provider * __init visconti_init_pll(struct device_node *np,\n\t\t\t\t\t\t\tvoid __iomem *base,\n\t\t\t\t\t\t\tunsigned long nr_plls)\n{\n\tstruct visconti_pll_provider *ctx;\n\tint i;\n\n\tctx = kzalloc(struct_size(ctx, clk_data.hws, nr_plls), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < nr_plls; ++i)\n\t\tctx->clk_data.hws[i] = ERR_PTR(-ENOENT);\n\n\tctx->node = np;\n\tctx->reg_base = base;\n\tctx->clk_data.num = nr_plls;\n\n\treturn ctx;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}