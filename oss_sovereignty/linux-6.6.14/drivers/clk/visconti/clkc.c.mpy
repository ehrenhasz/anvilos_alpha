{
  "module_name": "clkc.c",
  "hash_id": "e72e7fc59fb010d23808209cce56dec30adf065db9f486d0ba07bfc01ba140a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/visconti/clkc.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include \"clkc.h\"\n\nstatic inline struct visconti_clk_gate *to_visconti_clk_gate(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct visconti_clk_gate, hw);\n}\n\nstatic int visconti_gate_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct visconti_clk_gate *gate = to_visconti_clk_gate(hw);\n\tu32 clk = BIT(gate->ck_idx);\n\tu32 val;\n\n\tregmap_read(gate->regmap, gate->ckon_offset, &val);\n\treturn (val & clk) ? 1 : 0;\n}\n\nstatic void visconti_gate_clk_disable(struct clk_hw *hw)\n{\n\tstruct visconti_clk_gate *gate = to_visconti_clk_gate(hw);\n\tu32 clk = BIT(gate->ck_idx);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tif (!visconti_gate_clk_is_enabled(hw)) {\n\t\tspin_unlock_irqrestore(gate->lock, flags);\n\t\treturn;\n\t}\n\n\tregmap_update_bits(gate->regmap, gate->ckoff_offset, clk, clk);\n\tspin_unlock_irqrestore(gate->lock, flags);\n}\n\nstatic int visconti_gate_clk_enable(struct clk_hw *hw)\n{\n\tstruct visconti_clk_gate *gate = to_visconti_clk_gate(hw);\n\tu32 clk = BIT(gate->ck_idx);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(gate->lock, flags);\n\tregmap_update_bits(gate->regmap, gate->ckon_offset, clk, clk);\n\tspin_unlock_irqrestore(gate->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops visconti_clk_gate_ops = {\n\t.enable = visconti_gate_clk_enable,\n\t.disable = visconti_gate_clk_disable,\n\t.is_enabled = visconti_gate_clk_is_enabled,\n};\n\nstatic struct clk_hw *visconti_clk_register_gate(struct device *dev,\n\t\t\t\t\t\t const char *name,\n\t\t\t\t\t\t const char *parent_name,\n\t\t\t\t\t\t struct regmap *regmap,\n\t\t\t\t\t\t const struct visconti_clk_gate_table *clks,\n\t\t\t\t\t\t u32\trson_offset,\n\t\t\t\t\t\t u32\trsoff_offset,\n\t\t\t\t\t\t u8\trs_idx,\n\t\t\t\t\t\t spinlock_t *lock)\n{\n\tstruct visconti_clk_gate *gate;\n\tstruct clk_parent_data *pdata;\n\tstruct clk_init_data init;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdata->name = pdata->fw_name = parent_name;\n\n\tgate = devm_kzalloc(dev, sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &visconti_clk_gate_ops;\n\tinit.flags = clks->flags;\n\tinit.parent_data = pdata;\n\tinit.num_parents = 1;\n\n\tgate->regmap = regmap;\n\tgate->ckon_offset = clks->ckon_offset;\n\tgate->ckoff_offset = clks->ckoff_offset;\n\tgate->ck_idx = clks->ck_idx;\n\tgate->rson_offset = rson_offset;\n\tgate->rsoff_offset = rsoff_offset;\n\tgate->rs_idx = rs_idx;\n\tgate->lock = lock;\n\tgate->hw.init = &init;\n\n\thw = &gate->hw;\n\tret = devm_clk_hw_register(dev, hw);\n\tif (ret)\n\t\thw = ERR_PTR(ret);\n\n\treturn hw;\n}\n\nint visconti_clk_register_gates(struct visconti_clk_provider *ctx,\n\t\t\t\tconst struct visconti_clk_gate_table *clks,\n\t\t\t\tint num_gate,\n\t\t\t\tconst struct visconti_reset_data *reset,\n\t\t\t\tspinlock_t *lock)\n{\n\tstruct device *dev = ctx->dev;\n\tint i;\n\n\tfor (i = 0; i < num_gate; i++) {\n\t\tconst char *parent_div_name = clks[i].parent_data[0].name;\n\t\tstruct clk_parent_data *pdata;\n\t\tu32 rson_offset, rsoff_offset;\n\t\tstruct clk_hw *gate_clk;\n\t\tstruct clk_hw *div_clk;\n\t\tchar *dev_name;\n\t\tu8 rs_idx;\n\n\t\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tdev_name = devm_kasprintf(dev, GFP_KERNEL, \"%s_div\", clks[i].name);\n\t\tif (!dev_name)\n\t\t\treturn -ENOMEM;\n\n\t\tif (clks[i].rs_id != NO_RESET) {\n\t\t\trson_offset = reset[clks[i].rs_id].rson_offset;\n\t\t\trsoff_offset = reset[clks[i].rs_id].rsoff_offset;\n\t\t\trs_idx = reset[clks[i].rs_id].rs_idx;\n\t\t} else {\n\t\t\trson_offset = rsoff_offset = rs_idx = -1;\n\t\t}\n\n\t\tdiv_clk = devm_clk_hw_register_fixed_factor(dev,\n\t\t\t\t\t\t\t    dev_name,\n\t\t\t\t\t\t\t    parent_div_name,\n\t\t\t\t\t\t\t    0, 1,\n\t\t\t\t\t\t\t    clks[i].div);\n\t\tif (IS_ERR(div_clk))\n\t\t\treturn PTR_ERR(div_clk);\n\n\t\tgate_clk = visconti_clk_register_gate(dev,\n\t\t\t\t\t\t      clks[i].name,\n\t\t\t\t\t\t      dev_name,\n\t\t\t\t\t\t      ctx->regmap,\n\t\t\t\t\t\t      &clks[i],\n\t\t\t\t\t\t      rson_offset,\n\t\t\t\t\t\t      rsoff_offset,\n\t\t\t\t\t\t      rs_idx,\n\t\t\t\t\t\t      lock);\n\t\tif (IS_ERR(gate_clk)) {\n\t\t\tdev_err(dev, \"%s: failed to register clock %s\\n\",\n\t\t\t\t__func__, clks[i].name);\n\t\t\treturn PTR_ERR(gate_clk);\n\t\t}\n\n\t\tctx->clk_data.hws[clks[i].id] = gate_clk;\n\t}\n\n\treturn 0;\n}\n\nstruct visconti_clk_provider *visconti_init_clk(struct device *dev,\n\t\t\t\t\t\tstruct regmap *regmap,\n\t\t\t\t\t\tunsigned long nr_clks)\n{\n\tstruct visconti_clk_provider *ctx;\n\tint i;\n\n\tctx = devm_kzalloc(dev, struct_size(ctx, clk_data.hws, nr_clks), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < nr_clks; ++i)\n\t\tctx->clk_data.hws[i] = ERR_PTR(-ENOENT);\n\tctx->clk_data.num = nr_clks;\n\n\tctx->dev = dev;\n\tctx->regmap = regmap;\n\n\treturn ctx;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}