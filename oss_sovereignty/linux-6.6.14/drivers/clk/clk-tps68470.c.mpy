{
  "module_name": "clk-tps68470.c",
  "hash_id": "1d6860c1d1aeebf840e2d04fd36137f1b808834ef971e1ac8be6b97f90261eaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-tps68470.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/kernel.h>\n#include <linux/mfd/tps68470.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/tps68470.h>\n#include <linux/regmap.h>\n\n#define TPS68470_CLK_NAME \"tps68470-clk\"\n\n#define to_tps68470_clkdata(clkd) \\\n\tcontainer_of(clkd, struct tps68470_clkdata, clkout_hw)\n\nstatic struct tps68470_clkout_freqs {\n\tunsigned long freq;\n\tunsigned int xtaldiv;\n\tunsigned int plldiv;\n\tunsigned int postdiv;\n\tunsigned int buckdiv;\n\tunsigned int boostdiv;\n} clk_freqs[] = {\n \n\t{ 19200000, 170, 32, 1, 2, 3 },\n\t{ 20000000, 170, 40, 1, 3, 4 },\n\t{ 24000000, 170, 80, 1, 4, 8 },\n};\n\nstruct tps68470_clkdata {\n\tstruct clk_hw clkout_hw;\n\tstruct regmap *regmap;\n\tunsigned long rate;\n};\n\nstatic int tps68470_clk_is_prepared(struct clk_hw *hw)\n{\n\tstruct tps68470_clkdata *clkdata = to_tps68470_clkdata(hw);\n\tint val;\n\n\tif (regmap_read(clkdata->regmap, TPS68470_REG_PLLCTL, &val))\n\t\treturn 0;\n\n\treturn val & TPS68470_PLL_EN_MASK;\n}\n\nstatic int tps68470_clk_prepare(struct clk_hw *hw)\n{\n\tstruct tps68470_clkdata *clkdata = to_tps68470_clkdata(hw);\n\n\tregmap_write(clkdata->regmap, TPS68470_REG_CLKCFG1,\n\t\t\t   (TPS68470_PLL_OUTPUT_ENABLE << TPS68470_OUTPUT_A_SHIFT) |\n\t\t\t   (TPS68470_PLL_OUTPUT_ENABLE << TPS68470_OUTPUT_B_SHIFT));\n\n\tregmap_update_bits(clkdata->regmap, TPS68470_REG_PLLCTL,\n\t\t\t   TPS68470_PLL_EN_MASK, TPS68470_PLL_EN_MASK);\n\n\t \n\tusleep_range(4000, 5000);\n\n\treturn 0;\n}\n\nstatic void tps68470_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct tps68470_clkdata *clkdata = to_tps68470_clkdata(hw);\n\n\t \n\tregmap_update_bits(clkdata->regmap, TPS68470_REG_PLLCTL, TPS68470_PLL_EN_MASK, 0);\n\n\t \n\tregmap_write(clkdata->regmap, TPS68470_REG_CLKCFG1, 0);\n}\n\nstatic unsigned long tps68470_clk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct tps68470_clkdata *clkdata = to_tps68470_clkdata(hw);\n\n\treturn clkdata->rate;\n}\n\n \nstatic unsigned int tps68470_clk_cfg_lookup(unsigned long rate)\n{\n\tlong diff, best_diff = LONG_MAX;\n\tunsigned int i, best_idx = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(clk_freqs); i++) {\n\t\tdiff = clk_freqs[i].freq - rate;\n\t\tif (diff == 0)\n\t\t\treturn i;\n\n\t\tdiff = abs(diff);\n\t\tif (diff < best_diff) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_idx = i;\n\t\t}\n\t}\n\n\treturn best_idx;\n}\n\nstatic long tps68470_clk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *parent_rate)\n{\n\tunsigned int idx = tps68470_clk_cfg_lookup(rate);\n\n\treturn clk_freqs[idx].freq;\n}\n\nstatic int tps68470_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long parent_rate)\n{\n\tstruct tps68470_clkdata *clkdata = to_tps68470_clkdata(hw);\n\tunsigned int idx = tps68470_clk_cfg_lookup(rate);\n\n\tif (rate != clk_freqs[idx].freq)\n\t\treturn -EINVAL;\n\n\tregmap_write(clkdata->regmap, TPS68470_REG_BOOSTDIV, clk_freqs[idx].boostdiv);\n\tregmap_write(clkdata->regmap, TPS68470_REG_BUCKDIV, clk_freqs[idx].buckdiv);\n\tregmap_write(clkdata->regmap, TPS68470_REG_PLLSWR, TPS68470_PLLSWR_DEFAULT);\n\tregmap_write(clkdata->regmap, TPS68470_REG_XTALDIV, clk_freqs[idx].xtaldiv);\n\tregmap_write(clkdata->regmap, TPS68470_REG_PLLDIV, clk_freqs[idx].plldiv);\n\tregmap_write(clkdata->regmap, TPS68470_REG_POSTDIV, clk_freqs[idx].postdiv);\n\tregmap_write(clkdata->regmap, TPS68470_REG_POSTDIV2, clk_freqs[idx].postdiv);\n\tregmap_write(clkdata->regmap, TPS68470_REG_CLKCFG2, TPS68470_CLKCFG2_DRV_STR_2MA);\n\n\tregmap_write(clkdata->regmap, TPS68470_REG_PLLCTL,\n\t\t     TPS68470_OSC_EXT_CAP_DEFAULT << TPS68470_OSC_EXT_CAP_SHIFT |\n\t\t     TPS68470_CLK_SRC_XTAL << TPS68470_CLK_SRC_SHIFT);\n\n\tclkdata->rate = rate;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops tps68470_clk_ops = {\n\t.is_prepared = tps68470_clk_is_prepared,\n\t.prepare = tps68470_clk_prepare,\n\t.unprepare = tps68470_clk_unprepare,\n\t.recalc_rate = tps68470_clk_recalc_rate,\n\t.round_rate = tps68470_clk_round_rate,\n\t.set_rate = tps68470_clk_set_rate,\n};\n\nstatic int tps68470_clk_probe(struct platform_device *pdev)\n{\n\tstruct tps68470_clk_platform_data *pdata = pdev->dev.platform_data;\n\tstruct clk_init_data tps68470_clk_initdata = {\n\t\t.name = TPS68470_CLK_NAME,\n\t\t.ops = &tps68470_clk_ops,\n\t\t \n\t\t.flags = CLK_SET_RATE_GATE,\n\t};\n\tstruct tps68470_clkdata *tps68470_clkdata;\n\tstruct tps68470_clk_consumer *consumer;\n\tint ret;\n\tint i;\n\n\ttps68470_clkdata = devm_kzalloc(&pdev->dev, sizeof(*tps68470_clkdata),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!tps68470_clkdata)\n\t\treturn -ENOMEM;\n\n\ttps68470_clkdata->regmap = dev_get_drvdata(pdev->dev.parent);\n\ttps68470_clkdata->clkout_hw.init = &tps68470_clk_initdata;\n\n\t \n\ttps68470_clk_set_rate(&tps68470_clkdata->clkout_hw, clk_freqs[0].freq, 0);\n\n\tret = devm_clk_hw_register(&pdev->dev, &tps68470_clkdata->clkout_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_clk_hw_register_clkdev(&pdev->dev, &tps68470_clkdata->clkout_hw,\n\t\t\t\t\t  TPS68470_CLK_NAME, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pdata) {\n\t\tfor (i = 0; i < pdata->n_consumers; i++) {\n\t\t\tconsumer = &pdata->consumers[i];\n\t\t\tret = devm_clk_hw_register_clkdev(&pdev->dev,\n\t\t\t\t\t\t\t  &tps68470_clkdata->clkout_hw,\n\t\t\t\t\t\t\t  consumer->consumer_con_id,\n\t\t\t\t\t\t\t  consumer->consumer_dev_name);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic struct platform_driver tps68470_clk_driver = {\n\t.driver = {\n\t\t.name = TPS68470_CLK_NAME,\n\t},\n\t.probe = tps68470_clk_probe,\n};\n\n \nstatic int __init tps68470_clk_init(void)\n{\n\treturn platform_driver_register(&tps68470_clk_driver);\n}\nsubsys_initcall(tps68470_clk_init);\n\nstatic void __exit tps68470_clk_exit(void)\n{\n\tplatform_driver_unregister(&tps68470_clk_driver);\n}\nmodule_exit(tps68470_clk_exit);\n\nMODULE_ALIAS(\"platform:tps68470-clk\");\nMODULE_DESCRIPTION(\"clock driver for TPS68470 pmic\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}