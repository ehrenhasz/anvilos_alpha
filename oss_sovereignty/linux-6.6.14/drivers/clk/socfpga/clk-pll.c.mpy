{
  "module_name": "clk-pll.c",
  "hash_id": "a1c56c544af48a3db127eef11ccb929a25df039c21c12d53ab54bc9d3038b99f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/socfpga/clk-pll.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n#include \"clk.h\"\n\n \n#define MAINPLL_BYPASS\t\t(1<<0)\n#define SDRAMPLL_BYPASS\t\t(1<<1)\n#define SDRAMPLL_SRC_BYPASS\t(1<<2)\n#define PERPLL_BYPASS\t\t(1<<3)\n#define PERPLL_SRC_BYPASS\t(1<<4)\n\n#define SOCFPGA_PLL_BG_PWRDWN\t\t0\n#define SOCFPGA_PLL_EXT_ENA\t\t1\n#define SOCFPGA_PLL_PWR_DOWN\t\t2\n#define SOCFPGA_PLL_DIVF_MASK\t\t0x0000FFF8\n#define SOCFPGA_PLL_DIVF_SHIFT\t\t3\n#define SOCFPGA_PLL_DIVQ_MASK\t\t0x003F0000\n#define SOCFPGA_PLL_DIVQ_SHIFT\t\t16\n\n#define CLK_MGR_PLL_CLK_SRC_SHIFT\t22\n#define CLK_MGR_PLL_CLK_SRC_MASK\t0x3\n\n#define to_socfpga_clk(p) container_of(p, struct socfpga_pll, hw.hw)\n\nvoid __iomem *clk_mgr_base_addr;\n\nstatic unsigned long clk_pll_recalc_rate(struct clk_hw *hwclk,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct socfpga_pll *socfpgaclk = to_socfpga_clk(hwclk);\n\tunsigned long divf, divq, reg;\n\tunsigned long long vco_freq;\n\tunsigned long bypass;\n\n\treg = readl(socfpgaclk->hw.reg);\n\tbypass = readl(clk_mgr_base_addr + CLKMGR_BYPASS);\n\tif (bypass & MAINPLL_BYPASS)\n\t\treturn parent_rate;\n\n\tdivf = (reg & SOCFPGA_PLL_DIVF_MASK) >> SOCFPGA_PLL_DIVF_SHIFT;\n\tdivq = (reg & SOCFPGA_PLL_DIVQ_MASK) >> SOCFPGA_PLL_DIVQ_SHIFT;\n\tvco_freq = (unsigned long long)parent_rate * (divf + 1);\n\tdo_div(vco_freq, (1 + divq));\n\treturn (unsigned long)vco_freq;\n}\n\nstatic u8 clk_pll_get_parent(struct clk_hw *hwclk)\n{\n\tu32 pll_src;\n\tstruct socfpga_pll *socfpgaclk = to_socfpga_clk(hwclk);\n\n\tpll_src = readl(socfpgaclk->hw.reg);\n\treturn (pll_src >> CLK_MGR_PLL_CLK_SRC_SHIFT) &\n\t\t\tCLK_MGR_PLL_CLK_SRC_MASK;\n}\n\nstatic const struct clk_ops clk_pll_ops = {\n\t.recalc_rate = clk_pll_recalc_rate,\n\t.get_parent = clk_pll_get_parent,\n};\n\nstatic void __init __socfpga_pll_init(struct device_node *node,\n\t\t\t\t      const struct clk_ops *ops)\n{\n\tu32 reg;\n\tstruct clk_hw *hw_clk;\n\tstruct socfpga_pll *pll_clk;\n\tconst char *clk_name = node->name;\n\tconst char *parent_name[SOCFPGA_MAX_PARENTS];\n\tstruct clk_init_data init;\n\tstruct device_node *clkmgr_np;\n\tint rc;\n\n\tof_property_read_u32(node, \"reg\", &reg);\n\n\tpll_clk = kzalloc(sizeof(*pll_clk), GFP_KERNEL);\n\tif (WARN_ON(!pll_clk))\n\t\treturn;\n\n\tclkmgr_np = of_find_compatible_node(NULL, NULL, \"altr,clk-mgr\");\n\tclk_mgr_base_addr = of_iomap(clkmgr_np, 0);\n\tof_node_put(clkmgr_np);\n\tBUG_ON(!clk_mgr_base_addr);\n\tpll_clk->hw.reg = clk_mgr_base_addr + reg;\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\n\tinit.name = clk_name;\n\tinit.ops = ops;\n\tinit.flags = 0;\n\n\tinit.num_parents = of_clk_parent_fill(node, parent_name, SOCFPGA_MAX_PARENTS);\n\tinit.parent_names = parent_name;\n\tpll_clk->hw.hw.init = &init;\n\n\tpll_clk->hw.bit_idx = SOCFPGA_PLL_EXT_ENA;\n\n\thw_clk = &pll_clk->hw.hw;\n\n\trc = clk_hw_register(NULL, hw_clk);\n\tif (rc) {\n\t\tpr_err(\"Could not register clock:%s\\n\", clk_name);\n\t\tgoto err_clk_hw_register;\n\t}\n\n\trc = of_clk_add_hw_provider(node, of_clk_hw_simple_get, hw_clk);\n\tif (rc) {\n\t\tpr_err(\"Could not register clock provider for node:%s\\n\",\n\t\t       clk_name);\n\t\tgoto err_of_clk_add_hw_provider;\n\t}\n\n\treturn;\n\nerr_of_clk_add_hw_provider:\n\tclk_hw_unregister(hw_clk);\nerr_clk_hw_register:\n\tkfree(pll_clk);\n}\n\nvoid __init socfpga_pll_init(struct device_node *node)\n{\n\t__socfpga_pll_init(node, &clk_pll_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}