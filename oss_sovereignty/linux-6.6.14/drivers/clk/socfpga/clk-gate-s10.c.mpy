{
  "module_name": "clk-gate-s10.c",
  "hash_id": "df99b6a1bbc4586a46c4648b28d9d76b53de12b25064229b520489c588eacf84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/socfpga/clk-gate-s10.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include \"stratix10-clk.h\"\n#include \"clk.h\"\n\n#define SOCFPGA_CS_PDBG_CLK\t\"cs_pdbg_clk\"\n#define to_socfpga_gate_clk(p) container_of(p, struct socfpga_gate_clk, hw.hw)\n\n#define SOCFPGA_EMAC0_CLK\t\t\"emac0_clk\"\n#define SOCFPGA_EMAC1_CLK\t\t\"emac1_clk\"\n#define SOCFPGA_EMAC2_CLK\t\t\"emac2_clk\"\n#define AGILEX_BYPASS_OFFSET\t\t0xC\n#define STRATIX10_BYPASS_OFFSET\t\t0x2C\n#define BOOTCLK_BYPASS\t\t\t2\n\nstatic unsigned long socfpga_gate_clk_recalc_rate(struct clk_hw *hwclk,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct socfpga_gate_clk *socfpgaclk = to_socfpga_gate_clk(hwclk);\n\tu32 div = 1, val;\n\n\tif (socfpgaclk->fixed_div) {\n\t\tdiv = socfpgaclk->fixed_div;\n\t} else if (socfpgaclk->div_reg) {\n\t\tval = readl(socfpgaclk->div_reg) >> socfpgaclk->shift;\n\t\tval &= GENMASK(socfpgaclk->width - 1, 0);\n\t\tdiv = (1 << val);\n\t}\n\treturn parent_rate / div;\n}\n\nstatic unsigned long socfpga_dbg_clk_recalc_rate(struct clk_hw *hwclk,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct socfpga_gate_clk *socfpgaclk = to_socfpga_gate_clk(hwclk);\n\tu32 div, val;\n\n\tval = readl(socfpgaclk->div_reg) >> socfpgaclk->shift;\n\tval &= GENMASK(socfpgaclk->width - 1, 0);\n\tdiv = (1 << val);\n\tdiv = div ? 4 : 1;\n\n\treturn parent_rate / div;\n}\n\nstatic u8 socfpga_gate_get_parent(struct clk_hw *hwclk)\n{\n\tstruct socfpga_gate_clk *socfpgaclk = to_socfpga_gate_clk(hwclk);\n\tu32 mask, second_bypass;\n\tu8 parent = 0;\n\tconst char *name = clk_hw_get_name(hwclk);\n\n\tif (socfpgaclk->bypass_reg) {\n\t\tmask = (0x1 << socfpgaclk->bypass_shift);\n\t\tparent = ((readl(socfpgaclk->bypass_reg) & mask) >>\n\t\t\t  socfpgaclk->bypass_shift);\n\t}\n\n\tif (streq(name, SOCFPGA_EMAC0_CLK) ||\n\t    streq(name, SOCFPGA_EMAC1_CLK) ||\n\t    streq(name, SOCFPGA_EMAC2_CLK)) {\n\t\tsecond_bypass = readl(socfpgaclk->bypass_reg -\n\t\t\t\t      STRATIX10_BYPASS_OFFSET);\n\t\t \n\t\tif (second_bypass & 0x1)\n\t\t\tif (parent == 0)  \n\t\t\t\tparent = BOOTCLK_BYPASS;\n\n\t\tif (second_bypass & 0x2)\n\t\t\tif (parent == 1)  \n\t\t\t\tparent = BOOTCLK_BYPASS;\n\t}\n\treturn parent;\n}\n\nstatic u8 socfpga_agilex_gate_get_parent(struct clk_hw *hwclk)\n{\n\tstruct socfpga_gate_clk *socfpgaclk = to_socfpga_gate_clk(hwclk);\n\tu32 mask, second_bypass;\n\tu8 parent = 0;\n\tconst char *name = clk_hw_get_name(hwclk);\n\n\tif (socfpgaclk->bypass_reg) {\n\t\tmask = (0x1 << socfpgaclk->bypass_shift);\n\t\tparent = ((readl(socfpgaclk->bypass_reg) & mask) >>\n\t\t\t  socfpgaclk->bypass_shift);\n\t}\n\n\tif (streq(name, SOCFPGA_EMAC0_CLK) ||\n\t    streq(name, SOCFPGA_EMAC1_CLK) ||\n\t    streq(name, SOCFPGA_EMAC2_CLK)) {\n\t\tsecond_bypass = readl(socfpgaclk->bypass_reg -\n\t\t\t\t      AGILEX_BYPASS_OFFSET);\n\t\t \n\t\tif (second_bypass & 0x1)\n\t\t\tif (parent == 0)  \n\t\t\t\tparent = BOOTCLK_BYPASS;\n\n\t\tif (second_bypass & 0x2)\n\t\t\tif (parent == 1)  \n\t\t\t\tparent = BOOTCLK_BYPASS;\n\t}\n\n\treturn parent;\n}\n\nstatic struct clk_ops gateclk_ops = {\n\t.recalc_rate = socfpga_gate_clk_recalc_rate,\n\t.get_parent = socfpga_gate_get_parent,\n};\n\nstatic const struct clk_ops agilex_gateclk_ops = {\n\t.recalc_rate = socfpga_gate_clk_recalc_rate,\n\t.get_parent = socfpga_agilex_gate_get_parent,\n};\n\nstatic const struct clk_ops dbgclk_ops = {\n\t.recalc_rate = socfpga_dbg_clk_recalc_rate,\n\t.get_parent = socfpga_gate_get_parent,\n};\n\nstruct clk_hw *s10_register_gate(const struct stratix10_gate_clock *clks, void __iomem *regbase)\n{\n\tstruct clk_hw *hw_clk;\n\tstruct socfpga_gate_clk *socfpga_clk;\n\tstruct clk_init_data init;\n\tconst char *parent_name = clks->parent_name;\n\tint ret;\n\n\tsocfpga_clk = kzalloc(sizeof(*socfpga_clk), GFP_KERNEL);\n\tif (!socfpga_clk)\n\t\treturn NULL;\n\n\tsocfpga_clk->hw.reg = regbase + clks->gate_reg;\n\tsocfpga_clk->hw.bit_idx = clks->gate_idx;\n\n\tgateclk_ops.enable = clk_gate_ops.enable;\n\tgateclk_ops.disable = clk_gate_ops.disable;\n\n\tsocfpga_clk->fixed_div = clks->fixed_div;\n\n\tif (clks->div_reg)\n\t\tsocfpga_clk->div_reg = regbase + clks->div_reg;\n\telse\n\t\tsocfpga_clk->div_reg = NULL;\n\n\tsocfpga_clk->width = clks->div_width;\n\tsocfpga_clk->shift = clks->div_offset;\n\n\tif (clks->bypass_reg)\n\t\tsocfpga_clk->bypass_reg = regbase + clks->bypass_reg;\n\telse\n\t\tsocfpga_clk->bypass_reg = NULL;\n\tsocfpga_clk->bypass_shift = clks->bypass_shift;\n\n\tif (streq(clks->name, \"cs_pdbg_clk\"))\n\t\tinit.ops = &dbgclk_ops;\n\telse\n\t\tinit.ops = &gateclk_ops;\n\n\tinit.name = clks->name;\n\tinit.flags = clks->flags;\n\n\tinit.num_parents = clks->num_parents;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tif (init.parent_names == NULL)\n\t\tinit.parent_data = clks->parent_data;\n\tsocfpga_clk->hw.hw.init = &init;\n\n\thw_clk = &socfpga_clk->hw.hw;\n\n\tret = clk_hw_register(NULL, &socfpga_clk->hw.hw);\n\tif (ret) {\n\t\tkfree(socfpga_clk);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn hw_clk;\n}\n\nstruct clk_hw *agilex_register_gate(const struct stratix10_gate_clock *clks, void __iomem *regbase)\n{\n\tstruct clk_hw *hw_clk;\n\tstruct socfpga_gate_clk *socfpga_clk;\n\tstruct clk_init_data init;\n\tconst char *parent_name = clks->parent_name;\n\tint ret;\n\n\tsocfpga_clk = kzalloc(sizeof(*socfpga_clk), GFP_KERNEL);\n\tif (!socfpga_clk)\n\t\treturn NULL;\n\n\tsocfpga_clk->hw.reg = regbase + clks->gate_reg;\n\tsocfpga_clk->hw.bit_idx = clks->gate_idx;\n\n\tgateclk_ops.enable = clk_gate_ops.enable;\n\tgateclk_ops.disable = clk_gate_ops.disable;\n\n\tsocfpga_clk->fixed_div = clks->fixed_div;\n\n\tif (clks->div_reg)\n\t\tsocfpga_clk->div_reg = regbase + clks->div_reg;\n\telse\n\t\tsocfpga_clk->div_reg = NULL;\n\n\tsocfpga_clk->width = clks->div_width;\n\tsocfpga_clk->shift = clks->div_offset;\n\n\tif (clks->bypass_reg)\n\t\tsocfpga_clk->bypass_reg = regbase + clks->bypass_reg;\n\telse\n\t\tsocfpga_clk->bypass_reg = NULL;\n\tsocfpga_clk->bypass_shift = clks->bypass_shift;\n\n\tif (streq(clks->name, \"cs_pdbg_clk\"))\n\t\tinit.ops = &dbgclk_ops;\n\telse\n\t\tinit.ops = &agilex_gateclk_ops;\n\n\tinit.name = clks->name;\n\tinit.flags = clks->flags;\n\n\tinit.num_parents = clks->num_parents;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tif (init.parent_names == NULL)\n\t\tinit.parent_data = clks->parent_data;\n\tsocfpga_clk->hw.hw.init = &init;\n\n\thw_clk = &socfpga_clk->hw.hw;\n\n\tret = clk_hw_register(NULL, &socfpga_clk->hw.hw);\n\tif (ret) {\n\t\tkfree(socfpga_clk);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn hw_clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}