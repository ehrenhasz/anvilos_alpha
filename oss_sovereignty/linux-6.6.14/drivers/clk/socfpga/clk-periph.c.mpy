{
  "module_name": "clk-periph.c",
  "hash_id": "11ea7b67b04d604661c85b19f5905f51414dc6384afe013e1892dd2f4ef5777b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/socfpga/clk-periph.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n#include \"clk.h\"\n\n#define to_socfpga_periph_clk(p) container_of(p, struct socfpga_periph_clk, hw.hw)\n\nstatic unsigned long clk_periclk_recalc_rate(struct clk_hw *hwclk,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct socfpga_periph_clk *socfpgaclk = to_socfpga_periph_clk(hwclk);\n\tu32 div, val;\n\n\tif (socfpgaclk->fixed_div) {\n\t\tdiv = socfpgaclk->fixed_div;\n\t} else {\n\t\tif (socfpgaclk->div_reg) {\n\t\t\tval = readl(socfpgaclk->div_reg) >> socfpgaclk->shift;\n\t\t\tval &= GENMASK(socfpgaclk->width - 1, 0);\n\t\t\tparent_rate /= (val + 1);\n\t\t}\n\t\tdiv = ((readl(socfpgaclk->hw.reg) & 0x1ff) + 1);\n\t}\n\n\treturn parent_rate / div;\n}\n\nstatic u8 clk_periclk_get_parent(struct clk_hw *hwclk)\n{\n\tu32 clk_src;\n\n\tclk_src = readl(clk_mgr_base_addr + CLKMGR_DBCTRL);\n\treturn clk_src & 0x1;\n}\n\nstatic const struct clk_ops periclk_ops = {\n\t.recalc_rate = clk_periclk_recalc_rate,\n\t.get_parent = clk_periclk_get_parent,\n};\n\nstatic void __init __socfpga_periph_init(struct device_node *node,\n\t\t\t\t\t const struct clk_ops *ops)\n{\n\tu32 reg;\n\tstruct clk_hw *hw_clk;\n\tstruct socfpga_periph_clk *periph_clk;\n\tconst char *clk_name = node->name;\n\tconst char *parent_name[SOCFPGA_MAX_PARENTS];\n\tstruct clk_init_data init;\n\tint rc;\n\tu32 fixed_div;\n\tu32 div_reg[3];\n\n\tof_property_read_u32(node, \"reg\", &reg);\n\n\tperiph_clk = kzalloc(sizeof(*periph_clk), GFP_KERNEL);\n\tif (WARN_ON(!periph_clk))\n\t\treturn;\n\n\tperiph_clk->hw.reg = clk_mgr_base_addr + reg;\n\n\trc = of_property_read_u32_array(node, \"div-reg\", div_reg, 3);\n\tif (!rc) {\n\t\tperiph_clk->div_reg = clk_mgr_base_addr + div_reg[0];\n\t\tperiph_clk->shift = div_reg[1];\n\t\tperiph_clk->width = div_reg[2];\n\t} else {\n\t\tperiph_clk->div_reg = NULL;\n\t}\n\n\trc = of_property_read_u32(node, \"fixed-divider\", &fixed_div);\n\tif (rc)\n\t\tperiph_clk->fixed_div = 0;\n\telse\n\t\tperiph_clk->fixed_div = fixed_div;\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\n\tinit.name = clk_name;\n\tinit.ops = ops;\n\tinit.flags = 0;\n\n\tinit.num_parents = of_clk_parent_fill(node, parent_name,\n\t\t\t\t\t      SOCFPGA_MAX_PARENTS);\n\tinit.parent_names = parent_name;\n\n\tperiph_clk->hw.hw.init = &init;\n\thw_clk = &periph_clk->hw.hw;\n\n\trc = clk_hw_register(NULL, hw_clk);\n\tif (rc) {\n\t\tpr_err(\"Could not register clock:%s\\n\", clk_name);\n\t\tgoto err_clk_hw_register;\n\t}\n\n\trc = of_clk_add_hw_provider(node, of_clk_hw_simple_get, hw_clk);\n\tif (rc) {\n\t\tpr_err(\"Could not register clock provider for node:%s\\n\",\n\t\t       clk_name);\n\t\tgoto err_of_clk_add_hw_provider;\n\t}\n\n\treturn;\n\nerr_of_clk_add_hw_provider:\n\tclk_hw_unregister(hw_clk);\nerr_clk_hw_register:\n\tkfree(periph_clk);\n}\n\nvoid __init socfpga_periph_init(struct device_node *node)\n{\n\t__socfpga_periph_init(node, &periclk_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}