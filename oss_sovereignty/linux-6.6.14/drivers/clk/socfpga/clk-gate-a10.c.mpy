{
  "module_name": "clk-gate-a10.c",
  "hash_id": "0d20a9070db3eb9c29c451600145331a26a443cd7d02f4495ba31d784f6a9faf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/socfpga/clk-gate-a10.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#include \"clk.h\"\n\n#define streq(a, b) (strcmp((a), (b)) == 0)\n\n#define to_socfpga_gate_clk(p) container_of(p, struct socfpga_gate_clk, hw.hw)\n\n \n#define SYSMGR_SDMMCGRP_CTRL_OFFSET\t0x28\n\nstatic unsigned long socfpga_gate_clk_recalc_rate(struct clk_hw *hwclk,\n\tunsigned long parent_rate)\n{\n\tstruct socfpga_gate_clk *socfpgaclk = to_socfpga_gate_clk(hwclk);\n\tu32 div = 1, val;\n\n\tif (socfpgaclk->fixed_div)\n\t\tdiv = socfpgaclk->fixed_div;\n\telse if (socfpgaclk->div_reg) {\n\t\tval = readl(socfpgaclk->div_reg) >> socfpgaclk->shift;\n\t\tval &= GENMASK(socfpgaclk->width - 1, 0);\n\t\tdiv = (1 << val);\n\t}\n\n\treturn parent_rate / div;\n}\n\nstatic struct clk_ops gateclk_ops = {\n\t.recalc_rate = socfpga_gate_clk_recalc_rate,\n};\n\nstatic void __init __socfpga_gate_init(struct device_node *node,\n\t\t\t\t       const struct clk_ops *ops)\n{\n\tu32 clk_gate[2];\n\tu32 div_reg[3];\n\tu32 fixed_div;\n\tstruct clk_hw *hw_clk;\n\tstruct socfpga_gate_clk *socfpga_clk;\n\tconst char *clk_name = node->name;\n\tconst char *parent_name[SOCFPGA_MAX_PARENTS];\n\tstruct clk_init_data init;\n\tint rc;\n\n\tsocfpga_clk = kzalloc(sizeof(*socfpga_clk), GFP_KERNEL);\n\tif (WARN_ON(!socfpga_clk))\n\t\treturn;\n\n\trc = of_property_read_u32_array(node, \"clk-gate\", clk_gate, 2);\n\tif (rc)\n\t\tclk_gate[0] = 0;\n\n\tif (clk_gate[0]) {\n\t\tsocfpga_clk->hw.reg = clk_mgr_a10_base_addr + clk_gate[0];\n\t\tsocfpga_clk->hw.bit_idx = clk_gate[1];\n\n\t\tgateclk_ops.enable = clk_gate_ops.enable;\n\t\tgateclk_ops.disable = clk_gate_ops.disable;\n\t}\n\n\trc = of_property_read_u32(node, \"fixed-divider\", &fixed_div);\n\tif (rc)\n\t\tsocfpga_clk->fixed_div = 0;\n\telse\n\t\tsocfpga_clk->fixed_div = fixed_div;\n\n\trc = of_property_read_u32_array(node, \"div-reg\", div_reg, 3);\n\tif (!rc) {\n\t\tsocfpga_clk->div_reg = clk_mgr_a10_base_addr + div_reg[0];\n\t\tsocfpga_clk->shift = div_reg[1];\n\t\tsocfpga_clk->width = div_reg[2];\n\t} else {\n\t\tsocfpga_clk->div_reg = NULL;\n\t}\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\n\tinit.name = clk_name;\n\tinit.ops = ops;\n\tinit.flags = 0;\n\n\tinit.num_parents = of_clk_parent_fill(node, parent_name, SOCFPGA_MAX_PARENTS);\n\tinit.parent_names = parent_name;\n\tsocfpga_clk->hw.hw.init = &init;\n\thw_clk = &socfpga_clk->hw.hw;\n\n\trc = clk_hw_register(NULL, hw_clk);\n\tif (rc) {\n\t\tpr_err(\"Could not register clock:%s\\n\", clk_name);\n\t\tgoto err_clk_hw_register;\n\t}\n\n\trc = of_clk_add_hw_provider(node, of_clk_hw_simple_get, hw_clk);\n\tif (rc) {\n\t\tpr_err(\"Could not register clock provider for node:%s\\n\",\n\t\t       clk_name);\n\t\tgoto err_of_clk_add_hw_provider;\n\t}\n\n\treturn;\n\nerr_of_clk_add_hw_provider:\n\tclk_hw_unregister(hw_clk);\nerr_clk_hw_register:\n\tkfree(socfpga_clk);\n}\n\nvoid __init socfpga_a10_gate_init(struct device_node *node)\n{\n\t__socfpga_gate_init(node, &gateclk_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}