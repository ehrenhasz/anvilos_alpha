{
  "module_name": "clk-pll-a10.c",
  "hash_id": "b694c3d8738e307b34835a774ff21bf1654f204e6a9bfb6ee263c4ffdd4d644e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/socfpga/clk-pll-a10.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n#include \"clk.h\"\n\n \n#define CLK_MGR_PLL_CLK_SRC_SHIFT\t8\n#define CLK_MGR_PLL_CLK_SRC_MASK\t0x3\n\n \n#define SOCFPGA_PLL_BG_PWRDWN\t\t0\n#define SOCFPGA_PLL_PWR_DOWN\t\t1\n#define SOCFPGA_PLL_EXT_ENA\t\t2\n#define SOCFPGA_PLL_DIVF_MASK\t\t0x00001FFF\n#define SOCFPGA_PLL_DIVF_SHIFT\t0\n#define SOCFPGA_PLL_DIVQ_MASK\t\t0x003F0000\n#define SOCFPGA_PLL_DIVQ_SHIFT\t16\n#define SOCFGPA_MAX_PARENTS\t5\n\n#define SOCFPGA_MAIN_PLL_CLK\t\t\"main_pll\"\n#define SOCFPGA_PERIP_PLL_CLK\t\t\"periph_pll\"\n\n#define to_socfpga_clk(p) container_of(p, struct socfpga_pll, hw.hw)\n\nvoid __iomem *clk_mgr_a10_base_addr;\n\nstatic unsigned long clk_pll_recalc_rate(struct clk_hw *hwclk,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct socfpga_pll *socfpgaclk = to_socfpga_clk(hwclk);\n\tunsigned long divf, divq, reg;\n\tunsigned long long vco_freq;\n\n\t \n\treg = readl(socfpgaclk->hw.reg + 0x4);\n\tdivf = (reg & SOCFPGA_PLL_DIVF_MASK) >> SOCFPGA_PLL_DIVF_SHIFT;\n\tdivq = (reg & SOCFPGA_PLL_DIVQ_MASK) >> SOCFPGA_PLL_DIVQ_SHIFT;\n\tvco_freq = (unsigned long long)parent_rate * (divf + 1);\n\tdo_div(vco_freq, (1 + divq));\n\treturn (unsigned long)vco_freq;\n}\n\nstatic u8 clk_pll_get_parent(struct clk_hw *hwclk)\n{\n\tstruct socfpga_pll *socfpgaclk = to_socfpga_clk(hwclk);\n\tu32 pll_src;\n\n\tpll_src = readl(socfpgaclk->hw.reg);\n\n\treturn (pll_src >> CLK_MGR_PLL_CLK_SRC_SHIFT) &\n\t\tCLK_MGR_PLL_CLK_SRC_MASK;\n}\n\nstatic const struct clk_ops clk_pll_ops = {\n\t.recalc_rate = clk_pll_recalc_rate,\n\t.get_parent = clk_pll_get_parent,\n};\n\nstatic void __init __socfpga_pll_init(struct device_node *node,\n\t\t\t\t      const struct clk_ops *ops)\n{\n\tu32 reg;\n\tstruct clk_hw *hw_clk;\n\tstruct socfpga_pll *pll_clk;\n\tconst char *clk_name = node->name;\n\tconst char *parent_name[SOCFGPA_MAX_PARENTS];\n\tstruct clk_init_data init;\n\tstruct device_node *clkmgr_np;\n\tint rc;\n\tint i = 0;\n\n\tof_property_read_u32(node, \"reg\", &reg);\n\n\tpll_clk = kzalloc(sizeof(*pll_clk), GFP_KERNEL);\n\tif (WARN_ON(!pll_clk))\n\t\treturn;\n\n\tclkmgr_np = of_find_compatible_node(NULL, NULL, \"altr,clk-mgr\");\n\tclk_mgr_a10_base_addr = of_iomap(clkmgr_np, 0);\n\tof_node_put(clkmgr_np);\n\tBUG_ON(!clk_mgr_a10_base_addr);\n\tpll_clk->hw.reg = clk_mgr_a10_base_addr + reg;\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\n\tinit.name = clk_name;\n\tinit.ops = ops;\n\tinit.flags = 0;\n\n\twhile (i < SOCFGPA_MAX_PARENTS && (parent_name[i] =\n\t\t\tof_clk_get_parent_name(node, i)) != NULL)\n\t\ti++;\n\tinit.num_parents = i;\n\tinit.parent_names = parent_name;\n\tpll_clk->hw.hw.init = &init;\n\n\tpll_clk->hw.bit_idx = SOCFPGA_PLL_EXT_ENA;\n\thw_clk = &pll_clk->hw.hw;\n\n\trc = clk_hw_register(NULL, hw_clk);\n\tif (rc) {\n\t\tpr_err(\"Could not register clock:%s\\n\", clk_name);\n\t\tgoto err_clk_hw_register;\n\t}\n\n\trc = of_clk_add_hw_provider(node, of_clk_hw_simple_get, hw_clk);\n\tif (rc) {\n\t\tpr_err(\"Could not register clock provider for node:%s\\n\",\n\t\t       clk_name);\n\t\tgoto err_of_clk_add_hw_provider;\n\t}\n\n\treturn;\n\nerr_of_clk_add_hw_provider:\n\tclk_hw_unregister(hw_clk);\nerr_clk_hw_register:\n\tkfree(pll_clk);\n}\n\nvoid __init socfpga_a10_pll_init(struct device_node *node)\n{\n\t__socfpga_pll_init(node, &clk_pll_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}