{
  "module_name": "clk-scmi.c",
  "hash_id": "7719d82393151e2aa71c331b389739cef86327dfaf45c37090f504bf82118ec9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-scmi.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/scmi_protocol.h>\n#include <asm/div64.h>\n\nstatic const struct scmi_clk_proto_ops *scmi_proto_clk_ops;\n\nstruct scmi_clk {\n\tu32 id;\n\tstruct clk_hw hw;\n\tconst struct scmi_clock_info *info;\n\tconst struct scmi_protocol_handle *ph;\n};\n\n#define to_scmi_clk(clk) container_of(clk, struct scmi_clk, hw)\n\nstatic unsigned long scmi_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tint ret;\n\tu64 rate;\n\tstruct scmi_clk *clk = to_scmi_clk(hw);\n\n\tret = scmi_proto_clk_ops->rate_get(clk->ph, clk->id, &rate);\n\tif (ret)\n\t\treturn 0;\n\treturn rate;\n}\n\nstatic long scmi_clk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *parent_rate)\n{\n\tu64 fmin, fmax, ftmp;\n\tstruct scmi_clk *clk = to_scmi_clk(hw);\n\n\t \n\tif (clk->info->rate_discrete)\n\t\treturn rate;\n\n\tfmin = clk->info->range.min_rate;\n\tfmax = clk->info->range.max_rate;\n\tif (rate <= fmin)\n\t\treturn fmin;\n\telse if (rate >= fmax)\n\t\treturn fmax;\n\n\tftmp = rate - fmin;\n\tftmp += clk->info->range.step_size - 1;  \n\tdo_div(ftmp, clk->info->range.step_size);\n\n\treturn ftmp * clk->info->range.step_size + fmin;\n}\n\nstatic int scmi_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t     unsigned long parent_rate)\n{\n\tstruct scmi_clk *clk = to_scmi_clk(hw);\n\n\treturn scmi_proto_clk_ops->rate_set(clk->ph, clk->id, rate);\n}\n\nstatic int scmi_clk_enable(struct clk_hw *hw)\n{\n\tstruct scmi_clk *clk = to_scmi_clk(hw);\n\n\treturn scmi_proto_clk_ops->enable(clk->ph, clk->id);\n}\n\nstatic void scmi_clk_disable(struct clk_hw *hw)\n{\n\tstruct scmi_clk *clk = to_scmi_clk(hw);\n\n\tscmi_proto_clk_ops->disable(clk->ph, clk->id);\n}\n\nstatic int scmi_clk_atomic_enable(struct clk_hw *hw)\n{\n\tstruct scmi_clk *clk = to_scmi_clk(hw);\n\n\treturn scmi_proto_clk_ops->enable_atomic(clk->ph, clk->id);\n}\n\nstatic void scmi_clk_atomic_disable(struct clk_hw *hw)\n{\n\tstruct scmi_clk *clk = to_scmi_clk(hw);\n\n\tscmi_proto_clk_ops->disable_atomic(clk->ph, clk->id);\n}\n\n \nstatic const struct clk_ops scmi_clk_ops = {\n\t.recalc_rate = scmi_clk_recalc_rate,\n\t.round_rate = scmi_clk_round_rate,\n\t.set_rate = scmi_clk_set_rate,\n\t.prepare = scmi_clk_enable,\n\t.unprepare = scmi_clk_disable,\n};\n\nstatic const struct clk_ops scmi_atomic_clk_ops = {\n\t.recalc_rate = scmi_clk_recalc_rate,\n\t.round_rate = scmi_clk_round_rate,\n\t.set_rate = scmi_clk_set_rate,\n\t.enable = scmi_clk_atomic_enable,\n\t.disable = scmi_clk_atomic_disable,\n};\n\nstatic int scmi_clk_ops_init(struct device *dev, struct scmi_clk *sclk,\n\t\t\t     const struct clk_ops *scmi_ops)\n{\n\tint ret;\n\tunsigned long min_rate, max_rate;\n\n\tstruct clk_init_data init = {\n\t\t.flags = CLK_GET_RATE_NOCACHE,\n\t\t.num_parents = 0,\n\t\t.ops = scmi_ops,\n\t\t.name = sclk->info->name,\n\t};\n\n\tsclk->hw.init = &init;\n\tret = devm_clk_hw_register(dev, &sclk->hw);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sclk->info->rate_discrete) {\n\t\tint num_rates = sclk->info->list.num_rates;\n\n\t\tif (num_rates <= 0)\n\t\t\treturn -EINVAL;\n\n\t\tmin_rate = sclk->info->list.rates[0];\n\t\tmax_rate = sclk->info->list.rates[num_rates - 1];\n\t} else {\n\t\tmin_rate = sclk->info->range.min_rate;\n\t\tmax_rate = sclk->info->range.max_rate;\n\t}\n\n\tclk_hw_set_rate_range(&sclk->hw, min_rate, max_rate);\n\treturn ret;\n}\n\nstatic int scmi_clocks_probe(struct scmi_device *sdev)\n{\n\tint idx, count, err;\n\tunsigned int atomic_threshold;\n\tbool is_atomic;\n\tstruct clk_hw **hws;\n\tstruct clk_hw_onecell_data *clk_data;\n\tstruct device *dev = &sdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst struct scmi_handle *handle = sdev->handle;\n\tstruct scmi_protocol_handle *ph;\n\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tscmi_proto_clk_ops =\n\t\thandle->devm_protocol_get(sdev, SCMI_PROTOCOL_CLOCK, &ph);\n\tif (IS_ERR(scmi_proto_clk_ops))\n\t\treturn PTR_ERR(scmi_proto_clk_ops);\n\n\tcount = scmi_proto_clk_ops->count_get(ph);\n\tif (count < 0) {\n\t\tdev_err(dev, \"%pOFn: invalid clock output count\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tclk_data = devm_kzalloc(dev, struct_size(clk_data, hws, count),\n\t\t\t\tGFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tclk_data->num = count;\n\thws = clk_data->hws;\n\n\tis_atomic = handle->is_transport_atomic(handle, &atomic_threshold);\n\n\tfor (idx = 0; idx < count; idx++) {\n\t\tstruct scmi_clk *sclk;\n\t\tconst struct clk_ops *scmi_ops;\n\n\t\tsclk = devm_kzalloc(dev, sizeof(*sclk), GFP_KERNEL);\n\t\tif (!sclk)\n\t\t\treturn -ENOMEM;\n\n\t\tsclk->info = scmi_proto_clk_ops->info_get(ph, idx);\n\t\tif (!sclk->info) {\n\t\t\tdev_dbg(dev, \"invalid clock info for idx %d\\n\", idx);\n\t\t\tdevm_kfree(dev, sclk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsclk->id = idx;\n\t\tsclk->ph = ph;\n\n\t\t \n\t\tif (is_atomic &&\n\t\t    sclk->info->enable_latency <= atomic_threshold)\n\t\t\tscmi_ops = &scmi_atomic_clk_ops;\n\t\telse\n\t\t\tscmi_ops = &scmi_clk_ops;\n\n\t\terr = scmi_clk_ops_init(dev, sclk, scmi_ops);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to register clock %d\\n\", idx);\n\t\t\tdevm_kfree(dev, sclk);\n\t\t\thws[idx] = NULL;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"Registered clock:%s%s\\n\",\n\t\t\t\tsclk->info->name,\n\t\t\t\tscmi_ops == &scmi_atomic_clk_ops ?\n\t\t\t\t\" (atomic ops)\" : \"\");\n\t\t\thws[idx] = &sclk->hw;\n\t\t}\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get,\n\t\t\t\t\t   clk_data);\n}\n\nstatic const struct scmi_device_id scmi_id_table[] = {\n\t{ SCMI_PROTOCOL_CLOCK, \"clocks\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(scmi, scmi_id_table);\n\nstatic struct scmi_driver scmi_clocks_driver = {\n\t.name = \"scmi-clocks\",\n\t.probe = scmi_clocks_probe,\n\t.id_table = scmi_id_table,\n};\nmodule_scmi_driver(scmi_clocks_driver);\n\nMODULE_AUTHOR(\"Sudeep Holla <sudeep.holla@arm.com>\");\nMODULE_DESCRIPTION(\"ARM SCMI clock driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}