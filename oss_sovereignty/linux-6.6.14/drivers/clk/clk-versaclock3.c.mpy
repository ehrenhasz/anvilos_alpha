{
  "module_name": "clk-versaclock3.c",
  "hash_id": "c05c1be89e24c69122dc5456903366b8d135a2868f8a5bcc681022ffe29f40ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-versaclock3.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/i2c.h>\n#include <linux/limits.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n#define NUM_CONFIG_REGISTERS\t\t37\n\n#define VC3_GENERAL_CTR\t\t\t0x0\n#define VC3_GENERAL_CTR_DIV1_SRC_SEL\tBIT(3)\n#define VC3_GENERAL_CTR_PLL3_REFIN_SEL\tBIT(2)\n\n#define VC3_PLL3_M_DIVIDER\t\t0x3\n#define VC3_PLL3_M_DIV1\t\t\tBIT(7)\n#define VC3_PLL3_M_DIV2\t\t\tBIT(6)\n#define VC3_PLL3_M_DIV(n)\t\t((n) & GENMASK(5, 0))\n\n#define VC3_PLL3_N_DIVIDER\t\t0x4\n#define VC3_PLL3_LOOP_FILTER_N_DIV_MSB\t0x5\n\n#define VC3_PLL3_CHARGE_PUMP_CTRL\t0x6\n#define VC3_PLL3_CHARGE_PUMP_CTRL_OUTDIV3_SRC_SEL\tBIT(7)\n\n#define VC3_PLL1_CTRL_OUTDIV5\t\t0x7\n#define VC3_PLL1_CTRL_OUTDIV5_PLL1_MDIV_DOUBLER\t\tBIT(7)\n\n#define VC3_PLL1_M_DIVIDER\t\t0x8\n#define VC3_PLL1_M_DIV1\t\t\tBIT(7)\n#define VC3_PLL1_M_DIV2\t\t\tBIT(6)\n#define VC3_PLL1_M_DIV(n)\t\t((n) & GENMASK(5, 0))\n\n#define VC3_PLL1_VCO_N_DIVIDER\t\t0x9\n#define VC3_PLL1_LOOP_FILTER_N_DIV_MSB\t0x0a\n\n#define VC3_OUT_DIV1_DIV2_CTRL\t\t0xf\n\n#define VC3_PLL2_FB_INT_DIV_MSB\t\t0x10\n#define VC3_PLL2_FB_INT_DIV_LSB\t\t0x11\n#define VC3_PLL2_FB_FRC_DIV_MSB\t\t0x12\n#define VC3_PLL2_FB_FRC_DIV_LSB\t\t0x13\n\n#define VC3_PLL2_M_DIVIDER\t\t0x1a\n#define VC3_PLL2_MDIV_DOUBLER\t\tBIT(7)\n#define VC3_PLL2_M_DIV1\t\t\tBIT(6)\n#define VC3_PLL2_M_DIV2\t\t\tBIT(5)\n#define VC3_PLL2_M_DIV(n)\t\t((n) & GENMASK(4, 0))\n\n#define VC3_OUT_DIV3_DIV4_CTRL\t\t0x1b\n\n#define VC3_PLL_OP_CTRL\t\t\t0x1c\n#define VC3_PLL_OP_CTRL_PLL2_REFIN_SEL\t6\n\n#define VC3_OUTPUT_CTR\t\t\t0x1d\n#define VC3_OUTPUT_CTR_DIV4_SRC_SEL\tBIT(3)\n\n#define VC3_SE2_CTRL_REG0\t\t0x1f\n#define VC3_SE2_CTRL_REG0_SE2_CLK_SEL\tBIT(6)\n\n#define VC3_SE3_DIFF1_CTRL_REG\t\t0x21\n#define VC3_SE3_DIFF1_CTRL_REG_SE3_CLK_SEL\tBIT(6)\n\n#define VC3_DIFF1_CTRL_REG\t\t0x22\n#define VC3_DIFF1_CTRL_REG_DIFF1_CLK_SEL\tBIT(7)\n\n#define VC3_DIFF2_CTRL_REG\t\t0x23\n#define VC3_DIFF2_CTRL_REG_DIFF2_CLK_SEL\tBIT(7)\n\n#define VC3_SE1_DIV4_CTRL\t\t0x24\n#define VC3_SE1_DIV4_CTRL_SE1_CLK_SEL\tBIT(3)\n\n#define VC3_PLL1_VCO_MIN\t\t300000000UL\n#define VC3_PLL1_VCO_MAX\t\t600000000UL\n\n#define VC3_PLL2_VCO_MIN\t\t400000000UL\n#define VC3_PLL2_VCO_MAX\t\t1200000000UL\n\n#define VC3_PLL3_VCO_MIN\t\t300000000UL\n#define VC3_PLL3_VCO_MAX\t\t800000000UL\n\n#define VC3_2_POW_16\t\t\t(U16_MAX + 1)\n#define VC3_DIV_MASK(width)\t\t((1 << (width)) - 1)\n\nenum vc3_pfd_mux {\n\tVC3_PFD2_MUX,\n\tVC3_PFD3_MUX,\n};\n\nenum vc3_pfd {\n\tVC3_PFD1,\n\tVC3_PFD2,\n\tVC3_PFD3,\n};\n\nenum vc3_pll {\n\tVC3_PLL1,\n\tVC3_PLL2,\n\tVC3_PLL3,\n};\n\nenum vc3_div_mux {\n\tVC3_DIV1_MUX,\n\tVC3_DIV3_MUX,\n\tVC3_DIV4_MUX,\n};\n\nenum vc3_div {\n\tVC3_DIV1,\n\tVC3_DIV2,\n\tVC3_DIV3,\n\tVC3_DIV4,\n\tVC3_DIV5,\n};\n\nenum vc3_clk {\n\tVC3_REF,\n\tVC3_SE1,\n\tVC3_SE2,\n\tVC3_SE3,\n\tVC3_DIFF1,\n\tVC3_DIFF2,\n};\n\nenum vc3_clk_mux {\n\tVC3_SE1_MUX = VC3_SE1 - 1,\n\tVC3_SE2_MUX = VC3_SE2 - 1,\n\tVC3_SE3_MUX = VC3_SE3 - 1,\n\tVC3_DIFF1_MUX = VC3_DIFF1 - 1,\n\tVC3_DIFF2_MUX = VC3_DIFF2 - 1,\n};\n\nstruct vc3_clk_data {\n\tu8 offs;\n\tu8 bitmsk;\n};\n\nstruct vc3_pfd_data {\n\tu8 num;\n\tu8 offs;\n\tu8 mdiv1_bitmsk;\n\tu8 mdiv2_bitmsk;\n};\n\nstruct vc3_pll_data {\n\tu8 num;\n\tu8 int_div_msb_offs;\n\tu8 int_div_lsb_offs;\n\tunsigned long vco_min;\n\tunsigned long vco_max;\n};\n\nstruct vc3_div_data {\n\tu8 offs;\n\tconst struct clk_div_table *table;\n\tu8 shift;\n\tu8 width;\n\tu8 flags;\n};\n\nstruct vc3_hw_data {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tconst void *data;\n\n\tu32 div_int;\n\tu32 div_frc;\n};\n\nstatic const struct clk_div_table div1_divs[] = {\n\t{ .val = 0, .div = 1, }, { .val = 1, .div = 4, },\n\t{ .val = 2, .div = 5, }, { .val = 3, .div = 6, },\n\t{ .val = 4, .div = 2, }, { .val = 5, .div = 8, },\n\t{ .val = 6, .div = 10, }, { .val = 7, .div = 12, },\n\t{ .val = 8, .div = 4, }, { .val = 9, .div = 16, },\n\t{ .val = 10, .div = 20, }, { .val = 11, .div = 24, },\n\t{ .val = 12, .div = 8, }, { .val = 13, .div = 32, },\n\t{ .val = 14, .div = 40, }, { .val = 15, .div = 48, },\n\t{}\n};\n\nstatic const struct clk_div_table div245_divs[] = {\n\t{ .val = 0, .div = 1, }, { .val = 1, .div = 3, },\n\t{ .val = 2, .div = 5, }, { .val = 3, .div = 10, },\n\t{ .val = 4, .div = 2, }, { .val = 5, .div = 6, },\n\t{ .val = 6, .div = 10, }, { .val = 7, .div = 20, },\n\t{ .val = 8, .div = 4, }, { .val = 9, .div = 12, },\n\t{ .val = 10, .div = 20, }, { .val = 11, .div = 40, },\n\t{ .val = 12, .div = 5, }, { .val = 13, .div = 15, },\n\t{ .val = 14, .div = 25, }, { .val = 15, .div = 50, },\n\t{}\n};\n\nstatic const struct clk_div_table div3_divs[] = {\n\t{ .val = 0, .div = 1, }, { .val = 1, .div = 3, },\n\t{ .val = 2, .div = 5, }, { .val = 3, .div = 10, },\n\t{ .val = 4, .div = 2, }, { .val = 5, .div = 6, },\n\t{ .val = 6, .div = 10, }, { .val = 7, .div = 20, },\n\t{ .val = 8, .div = 4, }, { .val = 9, .div = 12, },\n\t{ .val = 10, .div = 20, }, { .val = 11, .div = 40, },\n\t{ .val = 12, .div = 8, }, { .val = 13, .div = 24, },\n\t{ .val = 14, .div = 40, }, { .val = 15, .div = 80, },\n\t{}\n};\n\nstatic struct clk_hw *clk_out[6];\n\nstatic unsigned char vc3_pfd_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_clk_data *pfd_mux = vc3->data;\n\tu32 src;\n\n\tregmap_read(vc3->regmap, pfd_mux->offs, &src);\n\n\treturn !!(src & pfd_mux->bitmsk);\n}\n\nstatic int vc3_pfd_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_clk_data *pfd_mux = vc3->data;\n\n\tregmap_update_bits(vc3->regmap, pfd_mux->offs, pfd_mux->bitmsk,\n\t\t\t   index ? pfd_mux->bitmsk : 0);\n\treturn 0;\n}\n\nstatic const struct clk_ops vc3_pfd_mux_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.set_parent = vc3_pfd_mux_set_parent,\n\t.get_parent = vc3_pfd_mux_get_parent,\n};\n\nstatic unsigned long vc3_pfd_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_pfd_data *pfd = vc3->data;\n\tunsigned int prediv, premul;\n\tunsigned long rate;\n\tu8 mdiv;\n\n\tregmap_read(vc3->regmap, pfd->offs, &prediv);\n\tif (pfd->num == VC3_PFD1) {\n\t\t \n\t\tif (prediv & pfd->mdiv1_bitmsk) {\n\t\t\t \n\t\t\tregmap_read(vc3->regmap, VC3_PLL1_CTRL_OUTDIV5, &premul);\n\t\t\tif (premul & VC3_PLL1_CTRL_OUTDIV5_PLL1_MDIV_DOUBLER)\n\t\t\t\tparent_rate *= 2;\n\t\t\treturn parent_rate;\n\t\t}\n\t\tmdiv = VC3_PLL1_M_DIV(prediv);\n\t} else if (pfd->num == VC3_PFD2) {\n\t\t \n\t\tif (prediv & pfd->mdiv1_bitmsk) {\n\t\t\tregmap_read(vc3->regmap, VC3_PLL2_M_DIVIDER, &premul);\n\t\t\t \n\t\t\tif (premul & VC3_PLL2_MDIV_DOUBLER)\n\t\t\t\tparent_rate *= 2;\n\t\t\treturn parent_rate;\n\t\t}\n\n\t\tmdiv = VC3_PLL2_M_DIV(prediv);\n\t} else {\n\t\t \n\t\tif (prediv & pfd->mdiv1_bitmsk)\n\t\t\treturn parent_rate;\n\n\t\tmdiv = VC3_PLL3_M_DIV(prediv);\n\t}\n\n\tif (prediv & pfd->mdiv2_bitmsk)\n\t\trate = parent_rate / 2;\n\telse\n\t\trate = parent_rate / mdiv;\n\n\treturn rate;\n}\n\nstatic long vc3_pfd_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_pfd_data *pfd = vc3->data;\n\tunsigned long idiv;\n\n\t \n\tif (rate > 50000000)\n\t\treturn -EINVAL;\n\n\t \n\tif (*parent_rate <= 50000000)\n\t\treturn *parent_rate;\n\n\tidiv = DIV_ROUND_UP(*parent_rate, rate);\n\tif (pfd->num == VC3_PFD1 || pfd->num == VC3_PFD3) {\n\t\tif (idiv > 63)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (idiv > 31)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn *parent_rate / idiv;\n}\n\nstatic int vc3_pfd_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_pfd_data *pfd = vc3->data;\n\tunsigned long idiv;\n\tu8 div;\n\n\t \n\tif (parent_rate <= 50000000) {\n\t\tregmap_update_bits(vc3->regmap, pfd->offs, pfd->mdiv1_bitmsk,\n\t\t\t\t   pfd->mdiv1_bitmsk);\n\t\tregmap_update_bits(vc3->regmap, pfd->offs, pfd->mdiv2_bitmsk, 0);\n\t\treturn 0;\n\t}\n\n\tidiv = DIV_ROUND_UP(parent_rate, rate);\n\t \n\tif (idiv == 2) {\n\t\tregmap_update_bits(vc3->regmap, pfd->offs, pfd->mdiv2_bitmsk,\n\t\t\t\t   pfd->mdiv2_bitmsk);\n\t\tregmap_update_bits(vc3->regmap, pfd->offs, pfd->mdiv1_bitmsk, 0);\n\t} else {\n\t\tif (pfd->num == VC3_PFD1)\n\t\t\tdiv = VC3_PLL1_M_DIV(idiv);\n\t\telse if (pfd->num == VC3_PFD2)\n\t\t\tdiv = VC3_PLL2_M_DIV(idiv);\n\t\telse\n\t\t\tdiv = VC3_PLL3_M_DIV(idiv);\n\n\t\tregmap_write(vc3->regmap, pfd->offs, div);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct clk_ops vc3_pfd_ops = {\n\t.recalc_rate = vc3_pfd_recalc_rate,\n\t.round_rate = vc3_pfd_round_rate,\n\t.set_rate = vc3_pfd_set_rate,\n};\n\nstatic unsigned long vc3_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_pll_data *pll = vc3->data;\n\tu32 div_int, div_frc, val;\n\tunsigned long rate;\n\n\tregmap_read(vc3->regmap, pll->int_div_msb_offs, &val);\n\tdiv_int = (val & GENMASK(2, 0)) << 8;\n\tregmap_read(vc3->regmap, pll->int_div_lsb_offs, &val);\n\tdiv_int |= val;\n\n\tif (pll->num == VC3_PLL2) {\n\t\tregmap_read(vc3->regmap, VC3_PLL2_FB_FRC_DIV_MSB, &val);\n\t\tdiv_frc = val << 8;\n\t\tregmap_read(vc3->regmap, VC3_PLL2_FB_FRC_DIV_LSB, &val);\n\t\tdiv_frc |= val;\n\t\trate = (parent_rate *\n\t\t\t(div_int * VC3_2_POW_16 + div_frc) / VC3_2_POW_16);\n\t} else {\n\t\trate = parent_rate * div_int;\n\t}\n\n\treturn rate;\n}\n\nstatic long vc3_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_pll_data *pll = vc3->data;\n\tu64 div_frc;\n\n\tif (rate < pll->vco_min)\n\t\trate = pll->vco_min;\n\tif (rate > pll->vco_max)\n\t\trate = pll->vco_max;\n\n\tvc3->div_int = rate / *parent_rate;\n\n\tif (pll->num == VC3_PLL2) {\n\t\tif (vc3->div_int > 0x7ff)\n\t\t\trate = *parent_rate * 0x7ff;\n\n\t\t \n\t\tdiv_frc = rate % *parent_rate;\n\t\tdiv_frc *= BIT(16) - 1;\n\n\t\tvc3->div_frc = min_t(u64, div64_ul(div_frc, *parent_rate), U16_MAX);\n\t\trate = (*parent_rate *\n\t\t\t(vc3->div_int * VC3_2_POW_16 + vc3->div_frc) / VC3_2_POW_16);\n\t} else {\n\t\trate = *parent_rate * vc3->div_int;\n\t}\n\n\treturn rate;\n}\n\nstatic int vc3_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_pll_data *pll = vc3->data;\n\tu32 val;\n\n\tregmap_read(vc3->regmap, pll->int_div_msb_offs, &val);\n\tval = (val & 0xf8) | ((vc3->div_int >> 8) & 0x7);\n\tregmap_write(vc3->regmap, pll->int_div_msb_offs, val);\n\tregmap_write(vc3->regmap, pll->int_div_lsb_offs, vc3->div_int & 0xff);\n\n\tif (pll->num == VC3_PLL2) {\n\t\tregmap_write(vc3->regmap, VC3_PLL2_FB_FRC_DIV_MSB,\n\t\t\t     vc3->div_frc >> 8);\n\t\tregmap_write(vc3->regmap, VC3_PLL2_FB_FRC_DIV_LSB,\n\t\t\t     vc3->div_frc & 0xff);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct clk_ops vc3_pll_ops = {\n\t.recalc_rate = vc3_pll_recalc_rate,\n\t.round_rate = vc3_pll_round_rate,\n\t.set_rate = vc3_pll_set_rate,\n};\n\nstatic unsigned char vc3_div_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_clk_data *div_mux = vc3->data;\n\tu32 src;\n\n\tregmap_read(vc3->regmap, div_mux->offs, &src);\n\n\treturn !!(src & div_mux->bitmsk);\n}\n\nstatic int vc3_div_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_clk_data *div_mux = vc3->data;\n\n\tregmap_update_bits(vc3->regmap, div_mux->offs, div_mux->bitmsk,\n\t\t\t   index ? div_mux->bitmsk : 0);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops vc3_div_mux_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.set_parent = vc3_div_mux_set_parent,\n\t.get_parent = vc3_div_mux_get_parent,\n};\n\nstatic unsigned int vc3_get_div(const struct clk_div_table *table,\n\t\t\t\tunsigned int val, unsigned long flag)\n{\n\tconst struct clk_div_table *clkt;\n\n\tfor (clkt = table; clkt->div; clkt++)\n\t\tif (clkt->val == val)\n\t\t\treturn clkt->div;\n\n\treturn 0;\n}\n\nstatic unsigned long vc3_div_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_div_data *div_data = vc3->data;\n\tunsigned int val;\n\n\tregmap_read(vc3->regmap, div_data->offs, &val);\n\tval >>= div_data->shift;\n\tval &= VC3_DIV_MASK(div_data->width);\n\n\treturn divider_recalc_rate(hw, parent_rate, val, div_data->table,\n\t\t\t\t   div_data->flags, div_data->width);\n}\n\nstatic long vc3_div_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_div_data *div_data = vc3->data;\n\tunsigned int bestdiv;\n\n\t \n\tif (div_data->flags & CLK_DIVIDER_READ_ONLY) {\n\t\tregmap_read(vc3->regmap, div_data->offs, &bestdiv);\n\t\tbestdiv >>= div_data->shift;\n\t\tbestdiv &= VC3_DIV_MASK(div_data->width);\n\t\tbestdiv = vc3_get_div(div_data->table, bestdiv, div_data->flags);\n\t\treturn DIV_ROUND_UP(*parent_rate, bestdiv);\n\t}\n\n\treturn divider_round_rate(hw, rate, parent_rate, div_data->table,\n\t\t\t\t  div_data->width, div_data->flags);\n}\n\nstatic int vc3_div_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_div_data *div_data = vc3->data;\n\tunsigned int value;\n\n\tvalue = divider_get_val(rate, parent_rate, div_data->table,\n\t\t\t\tdiv_data->width, div_data->flags);\n\tregmap_update_bits(vc3->regmap, div_data->offs,\n\t\t\t   VC3_DIV_MASK(div_data->width) << div_data->shift,\n\t\t\t   value << div_data->shift);\n\treturn 0;\n}\n\nstatic const struct clk_ops vc3_div_ops = {\n\t.recalc_rate = vc3_div_recalc_rate,\n\t.round_rate = vc3_div_round_rate,\n\t.set_rate = vc3_div_set_rate,\n};\n\nstatic int vc3_clk_mux_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tint ret;\n\tint frc;\n\n\tret = clk_mux_determine_rate_flags(hw, req, CLK_SET_RATE_PARENT);\n\tif (ret) {\n\t\t \n\t\tif (req->best_parent_rate >= req->rate) {\n\t\t\tfrc = DIV_ROUND_CLOSEST_ULL(req->best_parent_rate,\n\t\t\t\t\t\t    req->rate);\n\t\t\treq->rate *= frc;\n\t\t\treturn clk_mux_determine_rate_flags(hw, req,\n\t\t\t\t\t\t\t    CLK_SET_RATE_PARENT);\n\t\t}\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic unsigned char vc3_clk_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_clk_data *clk_mux = vc3->data;\n\tu32 val;\n\n\tregmap_read(vc3->regmap, clk_mux->offs, &val);\n\n\treturn !!(val & clk_mux->bitmsk);\n}\n\nstatic int vc3_clk_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct vc3_hw_data *vc3 = container_of(hw, struct vc3_hw_data, hw);\n\tconst struct vc3_clk_data *clk_mux = vc3->data;\n\n\tregmap_update_bits(vc3->regmap, clk_mux->offs,\n\t\t\t   clk_mux->bitmsk, index ? clk_mux->bitmsk : 0);\n\treturn 0;\n}\n\nstatic const struct clk_ops vc3_clk_mux_ops = {\n\t.determine_rate = vc3_clk_mux_determine_rate,\n\t.set_parent = vc3_clk_mux_set_parent,\n\t.get_parent = vc3_clk_mux_get_parent,\n};\n\nstatic bool vc3_regmap_is_writeable(struct device *dev, unsigned int reg)\n{\n\treturn true;\n}\n\nstatic const struct regmap_config vc3_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = 0x24,\n\t.writeable_reg = vc3_regmap_is_writeable,\n};\n\nstatic struct vc3_hw_data clk_div[5];\n\nstatic const struct clk_parent_data pfd_mux_parent_data[] = {\n\t{ .index = 0, },\n\t{ .hw = &clk_div[VC3_DIV2].hw }\n};\n\nstatic struct vc3_hw_data clk_pfd_mux[] = {\n\t[VC3_PFD2_MUX] = {\n\t\t.data = &(struct vc3_clk_data) {\n\t\t\t.offs = VC3_PLL_OP_CTRL,\n\t\t\t.bitmsk = BIT(VC3_PLL_OP_CTRL_PLL2_REFIN_SEL)\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"pfd2_mux\",\n\t\t\t.ops = &vc3_pfd_mux_ops,\n\t\t\t.parent_data = pfd_mux_parent_data,\n\t\t\t.num_parents = 2,\n\t\t\t.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT\n\t\t}\n\t},\n\t[VC3_PFD3_MUX] = {\n\t\t.data = &(struct vc3_clk_data) {\n\t\t\t.offs = VC3_GENERAL_CTR,\n\t\t\t.bitmsk = BIT(VC3_GENERAL_CTR_PLL3_REFIN_SEL)\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"pfd3_mux\",\n\t\t\t.ops = &vc3_pfd_mux_ops,\n\t\t\t.parent_data = pfd_mux_parent_data,\n\t\t\t.num_parents = 2,\n\t\t\t.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT\n\t\t}\n\t}\n};\n\nstatic struct vc3_hw_data clk_pfd[] = {\n\t[VC3_PFD1] = {\n\t\t.data = &(struct vc3_pfd_data) {\n\t\t\t.num = VC3_PFD1,\n\t\t\t.offs = VC3_PLL1_M_DIVIDER,\n\t\t\t.mdiv1_bitmsk = VC3_PLL1_M_DIV1,\n\t\t\t.mdiv2_bitmsk = VC3_PLL1_M_DIV2\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"pfd1\",\n\t\t\t.ops = &vc3_pfd_ops,\n\t\t\t.parent_data = &(const struct clk_parent_data) {\n\t\t\t\t.index = 0\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t},\n\t[VC3_PFD2] = {\n\t\t.data = &(struct vc3_pfd_data) {\n\t\t\t.num = VC3_PFD2,\n\t\t\t.offs = VC3_PLL2_M_DIVIDER,\n\t\t\t.mdiv1_bitmsk = VC3_PLL2_M_DIV1,\n\t\t\t.mdiv2_bitmsk = VC3_PLL2_M_DIV2\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"pfd2\",\n\t\t\t.ops = &vc3_pfd_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_pfd_mux[VC3_PFD2_MUX].hw\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t},\n\t[VC3_PFD3] = {\n\t\t.data = &(struct vc3_pfd_data) {\n\t\t\t.num = VC3_PFD3,\n\t\t\t.offs = VC3_PLL3_M_DIVIDER,\n\t\t\t.mdiv1_bitmsk = VC3_PLL3_M_DIV1,\n\t\t\t.mdiv2_bitmsk = VC3_PLL3_M_DIV2\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"pfd3\",\n\t\t\t.ops = &vc3_pfd_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_pfd_mux[VC3_PFD3_MUX].hw\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t}\n};\n\nstatic struct vc3_hw_data clk_pll[] = {\n\t[VC3_PLL1] = {\n\t\t.data = &(struct vc3_pll_data) {\n\t\t\t.num = VC3_PLL1,\n\t\t\t.int_div_msb_offs = VC3_PLL1_LOOP_FILTER_N_DIV_MSB,\n\t\t\t.int_div_lsb_offs = VC3_PLL1_VCO_N_DIVIDER,\n\t\t\t.vco_min = VC3_PLL1_VCO_MIN,\n\t\t\t.vco_max = VC3_PLL1_VCO_MAX\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"pll1\",\n\t\t\t.ops = &vc3_pll_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_pfd[VC3_PFD1].hw\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t},\n\t[VC3_PLL2] = {\n\t\t.data = &(struct vc3_pll_data) {\n\t\t\t.num = VC3_PLL2,\n\t\t\t.int_div_msb_offs = VC3_PLL2_FB_INT_DIV_MSB,\n\t\t\t.int_div_lsb_offs = VC3_PLL2_FB_INT_DIV_LSB,\n\t\t\t.vco_min = VC3_PLL2_VCO_MIN,\n\t\t\t.vco_max = VC3_PLL2_VCO_MAX\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"pll2\",\n\t\t\t.ops = &vc3_pll_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_pfd[VC3_PFD2].hw\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t},\n\t[VC3_PLL3] = {\n\t\t.data = &(struct vc3_pll_data) {\n\t\t\t.num = VC3_PLL3,\n\t\t\t.int_div_msb_offs = VC3_PLL3_LOOP_FILTER_N_DIV_MSB,\n\t\t\t.int_div_lsb_offs = VC3_PLL3_N_DIVIDER,\n\t\t\t.vco_min = VC3_PLL3_VCO_MIN,\n\t\t\t.vco_max = VC3_PLL3_VCO_MAX\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"pll3\",\n\t\t\t.ops = &vc3_pll_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_pfd[VC3_PFD3].hw\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t}\n};\n\nstatic const struct clk_parent_data div_mux_parent_data[][2] = {\n\t[VC3_DIV1_MUX] = {\n\t\t{ .hw = &clk_pll[VC3_PLL1].hw },\n\t\t{ .index = 0 }\n\t},\n\t[VC3_DIV3_MUX] = {\n\t\t{ .hw = &clk_pll[VC3_PLL2].hw },\n\t\t{ .hw = &clk_pll[VC3_PLL3].hw }\n\t},\n\t[VC3_DIV4_MUX] = {\n\t\t{ .hw = &clk_pll[VC3_PLL2].hw },\n\t\t{ .index = 0 }\n\t}\n};\n\nstatic struct vc3_hw_data clk_div_mux[] = {\n\t[VC3_DIV1_MUX] = {\n\t\t.data = &(struct vc3_clk_data) {\n\t\t\t.offs = VC3_GENERAL_CTR,\n\t\t\t.bitmsk = VC3_GENERAL_CTR_DIV1_SRC_SEL\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"div1_mux\",\n\t\t\t.ops = &vc3_div_mux_ops,\n\t\t\t.parent_data = div_mux_parent_data[VC3_DIV1_MUX],\n\t\t\t.num_parents = 2,\n\t\t\t.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT\n\t\t}\n\t},\n\t[VC3_DIV3_MUX] = {\n\t\t.data = &(struct vc3_clk_data) {\n\t\t\t.offs = VC3_PLL3_CHARGE_PUMP_CTRL,\n\t\t\t.bitmsk = VC3_PLL3_CHARGE_PUMP_CTRL_OUTDIV3_SRC_SEL\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"div3_mux\",\n\t\t\t.ops = &vc3_div_mux_ops,\n\t\t\t.parent_data = div_mux_parent_data[VC3_DIV3_MUX],\n\t\t\t.num_parents = 2,\n\t\t\t.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT\n\t\t}\n\t},\n\t[VC3_DIV4_MUX] = {\n\t\t.data = &(struct vc3_clk_data) {\n\t\t\t.offs = VC3_OUTPUT_CTR,\n\t\t\t.bitmsk = VC3_OUTPUT_CTR_DIV4_SRC_SEL\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"div4_mux\",\n\t\t\t.ops = &vc3_div_mux_ops,\n\t\t\t.parent_data = div_mux_parent_data[VC3_DIV4_MUX],\n\t\t\t.num_parents = 2,\n\t\t\t.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT\n\t\t}\n\t}\n};\n\nstatic struct vc3_hw_data clk_div[] = {\n\t[VC3_DIV1] = {\n\t\t.data = &(struct vc3_div_data) {\n\t\t\t.offs = VC3_OUT_DIV1_DIV2_CTRL,\n\t\t\t.table = div1_divs,\n\t\t\t.shift = 4,\n\t\t\t.width = 4,\n\t\t\t.flags = CLK_DIVIDER_READ_ONLY\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"div1\",\n\t\t\t.ops = &vc3_div_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_div_mux[VC3_DIV1_MUX].hw\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t},\n\t[VC3_DIV2] = {\n\t\t.data = &(struct vc3_div_data) {\n\t\t\t.offs = VC3_OUT_DIV1_DIV2_CTRL,\n\t\t\t.table = div245_divs,\n\t\t\t.shift = 0,\n\t\t\t.width = 4,\n\t\t\t.flags = CLK_DIVIDER_READ_ONLY\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"div2\",\n\t\t\t.ops = &vc3_div_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_pll[VC3_PLL1].hw\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t},\n\t[VC3_DIV3] = {\n\t\t.data = &(struct vc3_div_data) {\n\t\t\t.offs = VC3_OUT_DIV3_DIV4_CTRL,\n\t\t\t.table = div3_divs,\n\t\t\t.shift = 4,\n\t\t\t.width = 4,\n\t\t\t.flags = CLK_DIVIDER_READ_ONLY\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"div3\",\n\t\t\t.ops = &vc3_div_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_div_mux[VC3_DIV3_MUX].hw\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t},\n\t[VC3_DIV4] = {\n\t\t.data = &(struct vc3_div_data) {\n\t\t\t.offs = VC3_OUT_DIV3_DIV4_CTRL,\n\t\t\t.table = div245_divs,\n\t\t\t.shift = 0,\n\t\t\t.width = 4,\n\t\t\t.flags = CLK_DIVIDER_READ_ONLY\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"div4\",\n\t\t\t.ops = &vc3_div_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_div_mux[VC3_DIV4_MUX].hw\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t},\n\t[VC3_DIV5] = {\n\t\t.data = &(struct vc3_div_data) {\n\t\t\t.offs = VC3_PLL1_CTRL_OUTDIV5,\n\t\t\t.table = div245_divs,\n\t\t\t.shift = 0,\n\t\t\t.width = 4,\n\t\t\t.flags = CLK_DIVIDER_READ_ONLY\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"div5\",\n\t\t\t.ops = &vc3_div_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_pll[VC3_PLL3].hw\n\t\t\t},\n\t\t\t.num_parents = 1,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t}\n};\n\nstatic struct vc3_hw_data clk_mux[] = {\n\t[VC3_SE1_MUX] = {\n\t\t.data = &(struct vc3_clk_data) {\n\t\t\t.offs = VC3_SE1_DIV4_CTRL,\n\t\t\t.bitmsk = VC3_SE1_DIV4_CTRL_SE1_CLK_SEL\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"se1_mux\",\n\t\t\t.ops = &vc3_clk_mux_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_div[VC3_DIV5].hw,\n\t\t\t\t&clk_div[VC3_DIV4].hw\n\t\t\t},\n\t\t\t.num_parents = 2,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t},\n\t[VC3_SE2_MUX] = {\n\t\t.data = &(struct vc3_clk_data) {\n\t\t\t.offs = VC3_SE2_CTRL_REG0,\n\t\t\t.bitmsk = VC3_SE2_CTRL_REG0_SE2_CLK_SEL\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"se2_mux\",\n\t\t\t.ops = &vc3_clk_mux_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_div[VC3_DIV5].hw,\n\t\t\t\t&clk_div[VC3_DIV4].hw\n\t\t\t},\n\t\t\t.num_parents = 2,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t},\n\t[VC3_SE3_MUX] = {\n\t\t.data = &(struct vc3_clk_data) {\n\t\t\t.offs = VC3_SE3_DIFF1_CTRL_REG,\n\t\t\t.bitmsk = VC3_SE3_DIFF1_CTRL_REG_SE3_CLK_SEL\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"se3_mux\",\n\t\t\t.ops = &vc3_clk_mux_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_div[VC3_DIV2].hw,\n\t\t\t\t&clk_div[VC3_DIV4].hw\n\t\t\t},\n\t\t\t.num_parents = 2,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t},\n\t[VC3_DIFF1_MUX] = {\n\t\t.data = &(struct vc3_clk_data) {\n\t\t\t.offs = VC3_DIFF1_CTRL_REG,\n\t\t\t.bitmsk = VC3_DIFF1_CTRL_REG_DIFF1_CLK_SEL\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"diff1_mux\",\n\t\t\t.ops = &vc3_clk_mux_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_div[VC3_DIV1].hw,\n\t\t\t\t&clk_div[VC3_DIV3].hw\n\t\t\t},\n\t\t\t.num_parents = 2,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t},\n\t[VC3_DIFF2_MUX] = {\n\t\t.data = &(struct vc3_clk_data) {\n\t\t\t.offs = VC3_DIFF2_CTRL_REG,\n\t\t\t.bitmsk = VC3_DIFF2_CTRL_REG_DIFF2_CLK_SEL\n\t\t},\n\t\t.hw.init = &(struct clk_init_data){\n\t\t\t.name = \"diff2_mux\",\n\t\t\t.ops = &vc3_clk_mux_ops,\n\t\t\t.parent_hws = (const struct clk_hw *[]) {\n\t\t\t\t&clk_div[VC3_DIV1].hw,\n\t\t\t\t&clk_div[VC3_DIV3].hw\n\t\t\t},\n\t\t\t.num_parents = 2,\n\t\t\t.flags = CLK_SET_RATE_PARENT\n\t\t}\n\t}\n};\n\nstatic struct clk_hw *vc3_of_clk_get(struct of_phandle_args *clkspec,\n\t\t\t\t     void *data)\n{\n\tunsigned int idx = clkspec->args[0];\n\tstruct clk_hw **clkout_hw = data;\n\n\tif (idx >= ARRAY_SIZE(clk_out)) {\n\t\tpr_err(\"invalid clk index %u for provider %pOF\\n\", idx, clkspec->np);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn clkout_hw[idx];\n}\n\nstatic int vc3_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tu8 settings[NUM_CONFIG_REGISTERS];\n\tstruct regmap *regmap;\n\tconst char *name;\n\tint ret, i;\n\n\tregmap = devm_regmap_init_i2c(client, &vc3_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap),\n\t\t\t\t     \"failed to allocate register map\\n\");\n\n\tret = of_property_read_u8_array(dev->of_node, \"renesas,settings\",\n\t\t\t\t\tsettings, ARRAY_SIZE(settings));\n\tif (!ret) {\n\t\t \n\t\tfor  (i = 0; i < NUM_CONFIG_REGISTERS; i++) {\n\t\t\tret = regmap_write(regmap, i, settings[i]);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"error writing to chip (%i)\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t} else if (ret == -EOVERFLOW) {\n\t\tdev_err(&client->dev, \"EOVERFLOW reg settings. ARRAY_SIZE: %zu\\n\",\n\t\t\tARRAY_SIZE(settings));\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(clk_pfd_mux); i++) {\n\t\tclk_pfd_mux[i].regmap = regmap;\n\t\tret = devm_clk_hw_register(dev, &clk_pfd_mux[i].hw);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"%s failed\\n\",\n\t\t\t\t\t     clk_pfd_mux[i].hw.init->name);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(clk_pfd); i++) {\n\t\tclk_pfd[i].regmap = regmap;\n\t\tret = devm_clk_hw_register(dev, &clk_pfd[i].hw);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"%s failed\\n\",\n\t\t\t\t\t     clk_pfd[i].hw.init->name);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(clk_pll); i++) {\n\t\tclk_pll[i].regmap = regmap;\n\t\tret = devm_clk_hw_register(dev, &clk_pll[i].hw);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"%s failed\\n\",\n\t\t\t\t\t     clk_pll[i].hw.init->name);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(clk_div_mux); i++) {\n\t\tclk_div_mux[i].regmap = regmap;\n\t\tret = devm_clk_hw_register(dev, &clk_div_mux[i].hw);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"%s failed\\n\",\n\t\t\t\t\t     clk_div_mux[i].hw.init->name);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(clk_div); i++) {\n\t\tclk_div[i].regmap = regmap;\n\t\tret = devm_clk_hw_register(dev, &clk_div[i].hw);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"%s failed\\n\",\n\t\t\t\t\t     clk_div[i].hw.init->name);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(clk_mux); i++) {\n\t\tclk_mux[i].regmap = regmap;\n\t\tret = devm_clk_hw_register(dev, &clk_mux[i].hw);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"%s failed\\n\",\n\t\t\t\t\t     clk_mux[i].hw.init->name);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(clk_out); i++) {\n\t\tswitch (i) {\n\t\tcase VC3_DIFF2:\n\t\t\tname = \"diff2\";\n\t\t\tbreak;\n\t\tcase VC3_DIFF1:\n\t\t\tname = \"diff1\";\n\t\t\tbreak;\n\t\tcase VC3_SE3:\n\t\t\tname = \"se3\";\n\t\t\tbreak;\n\t\tcase VC3_SE2:\n\t\t\tname = \"se2\";\n\t\t\tbreak;\n\t\tcase VC3_SE1:\n\t\t\tname = \"se1\";\n\t\t\tbreak;\n\t\tcase VC3_REF:\n\t\t\tname = \"ref\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn dev_err_probe(dev, -EINVAL, \"invalid clk output %d\\n\", i);\n\t\t}\n\n\t\tif (i == VC3_REF)\n\t\t\tclk_out[i] = devm_clk_hw_register_fixed_factor_index(dev,\n\t\t\t\tname, 0, CLK_SET_RATE_PARENT, 1, 1);\n\t\telse\n\t\t\tclk_out[i] = devm_clk_hw_register_fixed_factor_parent_hw(dev,\n\t\t\t\tname, &clk_mux[i - 1].hw, CLK_SET_RATE_PARENT, 1, 1);\n\n\t\tif (IS_ERR(clk_out[i]))\n\t\t\treturn PTR_ERR(clk_out[i]);\n\t}\n\n\tret = devm_of_clk_add_hw_provider(dev, vc3_of_clk_get, clk_out);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"unable to add clk provider\\n\");\n\n\treturn ret;\n}\n\nstatic const struct of_device_id dev_ids[] = {\n\t{ .compatible = \"renesas,5p35023\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, dev_ids);\n\nstatic struct i2c_driver vc3_driver = {\n\t.driver = {\n\t\t.name = \"vc3\",\n\t\t.of_match_table = of_match_ptr(dev_ids),\n\t},\n\t.probe = vc3_probe,\n};\nmodule_i2c_driver(vc3_driver);\n\nMODULE_AUTHOR(\"Biju Das <biju.das.jz@bp.renesas.com>\");\nMODULE_DESCRIPTION(\"Renesas VersaClock 3 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}