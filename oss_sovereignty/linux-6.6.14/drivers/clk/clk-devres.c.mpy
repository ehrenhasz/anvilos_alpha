{
  "module_name": "clk-devres.c",
  "hash_id": "fbc75853312f2826ca9b85d42e0191cd3f6244d3357d16a6f56339bec5f00d79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-devres.c",
  "human_readable_source": "\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n\nstruct devm_clk_state {\n\tstruct clk *clk;\n\tvoid (*exit)(struct clk *clk);\n};\n\nstatic void devm_clk_release(struct device *dev, void *res)\n{\n\tstruct devm_clk_state *state = res;\n\n\tif (state->exit)\n\t\tstate->exit(state->clk);\n\n\tclk_put(state->clk);\n}\n\nstatic struct clk *__devm_clk_get(struct device *dev, const char *id,\n\t\t\t\t  struct clk *(*get)(struct device *dev, const char *id),\n\t\t\t\t  int (*init)(struct clk *clk),\n\t\t\t\t  void (*exit)(struct clk *clk))\n{\n\tstruct devm_clk_state *state;\n\tstruct clk *clk;\n\tint ret;\n\n\tstate = devres_alloc(devm_clk_release, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk = get(dev, id);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tgoto err_clk_get;\n\t}\n\n\tif (init) {\n\t\tret = init(clk);\n\t\tif (ret)\n\t\t\tgoto err_clk_init;\n\t}\n\n\tstate->clk = clk;\n\tstate->exit = exit;\n\n\tdevres_add(dev, state);\n\n\treturn clk;\n\nerr_clk_init:\n\n\tclk_put(clk);\nerr_clk_get:\n\n\tdevres_free(state);\n\treturn ERR_PTR(ret);\n}\n\nstruct clk *devm_clk_get(struct device *dev, const char *id)\n{\n\treturn __devm_clk_get(dev, id, clk_get, NULL, NULL);\n}\nEXPORT_SYMBOL(devm_clk_get);\n\nstruct clk *devm_clk_get_prepared(struct device *dev, const char *id)\n{\n\treturn __devm_clk_get(dev, id, clk_get, clk_prepare, clk_unprepare);\n}\nEXPORT_SYMBOL_GPL(devm_clk_get_prepared);\n\nstruct clk *devm_clk_get_enabled(struct device *dev, const char *id)\n{\n\treturn __devm_clk_get(dev, id, clk_get,\n\t\t\t      clk_prepare_enable, clk_disable_unprepare);\n}\nEXPORT_SYMBOL_GPL(devm_clk_get_enabled);\n\nstruct clk *devm_clk_get_optional(struct device *dev, const char *id)\n{\n\treturn __devm_clk_get(dev, id, clk_get_optional, NULL, NULL);\n}\nEXPORT_SYMBOL(devm_clk_get_optional);\n\nstruct clk *devm_clk_get_optional_prepared(struct device *dev, const char *id)\n{\n\treturn __devm_clk_get(dev, id, clk_get_optional,\n\t\t\t      clk_prepare, clk_unprepare);\n}\nEXPORT_SYMBOL_GPL(devm_clk_get_optional_prepared);\n\nstruct clk *devm_clk_get_optional_enabled(struct device *dev, const char *id)\n{\n\treturn __devm_clk_get(dev, id, clk_get_optional,\n\t\t\t      clk_prepare_enable, clk_disable_unprepare);\n}\nEXPORT_SYMBOL_GPL(devm_clk_get_optional_enabled);\n\nstruct clk_bulk_devres {\n\tstruct clk_bulk_data *clks;\n\tint num_clks;\n};\n\nstatic void devm_clk_bulk_release(struct device *dev, void *res)\n{\n\tstruct clk_bulk_devres *devres = res;\n\n\tclk_bulk_put(devres->num_clks, devres->clks);\n}\n\nstatic int __devm_clk_bulk_get(struct device *dev, int num_clks,\n\t\t\t       struct clk_bulk_data *clks, bool optional)\n{\n\tstruct clk_bulk_devres *devres;\n\tint ret;\n\n\tdevres = devres_alloc(devm_clk_bulk_release,\n\t\t\t      sizeof(*devres), GFP_KERNEL);\n\tif (!devres)\n\t\treturn -ENOMEM;\n\n\tif (optional)\n\t\tret = clk_bulk_get_optional(dev, num_clks, clks);\n\telse\n\t\tret = clk_bulk_get(dev, num_clks, clks);\n\tif (!ret) {\n\t\tdevres->clks = clks;\n\t\tdevres->num_clks = num_clks;\n\t\tdevres_add(dev, devres);\n\t} else {\n\t\tdevres_free(devres);\n\t}\n\n\treturn ret;\n}\n\nint __must_check devm_clk_bulk_get(struct device *dev, int num_clks,\n\t\t      struct clk_bulk_data *clks)\n{\n\treturn __devm_clk_bulk_get(dev, num_clks, clks, false);\n}\nEXPORT_SYMBOL_GPL(devm_clk_bulk_get);\n\nint __must_check devm_clk_bulk_get_optional(struct device *dev, int num_clks,\n\t\t      struct clk_bulk_data *clks)\n{\n\treturn __devm_clk_bulk_get(dev, num_clks, clks, true);\n}\nEXPORT_SYMBOL_GPL(devm_clk_bulk_get_optional);\n\nstatic void devm_clk_bulk_release_all(struct device *dev, void *res)\n{\n\tstruct clk_bulk_devres *devres = res;\n\n\tclk_bulk_put_all(devres->num_clks, devres->clks);\n}\n\nint __must_check devm_clk_bulk_get_all(struct device *dev,\n\t\t\t\t       struct clk_bulk_data **clks)\n{\n\tstruct clk_bulk_devres *devres;\n\tint ret;\n\n\tdevres = devres_alloc(devm_clk_bulk_release_all,\n\t\t\t      sizeof(*devres), GFP_KERNEL);\n\tif (!devres)\n\t\treturn -ENOMEM;\n\n\tret = clk_bulk_get_all(dev, &devres->clks);\n\tif (ret > 0) {\n\t\t*clks = devres->clks;\n\t\tdevres->num_clks = ret;\n\t\tdevres_add(dev, devres);\n\t} else {\n\t\tdevres_free(devres);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_clk_bulk_get_all);\n\nstatic int devm_clk_match(struct device *dev, void *res, void *data)\n{\n\tstruct clk **c = res;\n\tif (!c || !*c) {\n\t\tWARN_ON(!c || !*c);\n\t\treturn 0;\n\t}\n\treturn *c == data;\n}\n\nvoid devm_clk_put(struct device *dev, struct clk *clk)\n{\n\tint ret;\n\n\tret = devres_release(dev, devm_clk_release, devm_clk_match, clk);\n\n\tWARN_ON(ret);\n}\nEXPORT_SYMBOL(devm_clk_put);\n\nstruct clk *devm_get_clk_from_child(struct device *dev,\n\t\t\t\t    struct device_node *np, const char *con_id)\n{\n\tstruct devm_clk_state *state;\n\tstruct clk *clk;\n\n\tstate = devres_alloc(devm_clk_release, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk = of_clk_get_by_name(np, con_id);\n\tif (!IS_ERR(clk)) {\n\t\tstate->clk = clk;\n\t\tdevres_add(dev, state);\n\t} else {\n\t\tdevres_free(state);\n\t}\n\n\treturn clk;\n}\nEXPORT_SYMBOL(devm_get_clk_from_child);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}