{
  "module_name": "clk-scpi.c",
  "hash_id": "ca0e24c8a9cc7bc8704f76418df82bcb7c42c7f9f8d9fd083e4a14dd8e20f434",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-scpi.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/scpi_protocol.h>\n\nstruct scpi_clk {\n\tu32 id;\n\tstruct clk_hw hw;\n\tstruct scpi_dvfs_info *info;\n\tstruct scpi_ops *scpi_ops;\n};\n\n#define to_scpi_clk(clk) container_of(clk, struct scpi_clk, hw)\n\nstatic struct platform_device *cpufreq_dev;\n\nstatic unsigned long scpi_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct scpi_clk *clk = to_scpi_clk(hw);\n\n\treturn clk->scpi_ops->clk_get_val(clk->id);\n}\n\nstatic long scpi_clk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *parent_rate)\n{\n\t \n\treturn rate;\n}\n\nstatic int scpi_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t     unsigned long parent_rate)\n{\n\tstruct scpi_clk *clk = to_scpi_clk(hw);\n\n\treturn clk->scpi_ops->clk_set_val(clk->id, rate);\n}\n\nstatic const struct clk_ops scpi_clk_ops = {\n\t.recalc_rate = scpi_clk_recalc_rate,\n\t.round_rate = scpi_clk_round_rate,\n\t.set_rate = scpi_clk_set_rate,\n};\n\n \nstatic long __scpi_dvfs_round_rate(struct scpi_clk *clk, unsigned long rate)\n{\n\tint idx;\n\tunsigned long fmin = 0, fmax = ~0, ftmp;\n\tconst struct scpi_opp *opp = clk->info->opps;\n\n\tfor (idx = 0; idx < clk->info->count; idx++, opp++) {\n\t\tftmp = opp->freq;\n\t\tif (ftmp >= rate) {\n\t\t\tif (ftmp <= fmax)\n\t\t\t\tfmax = ftmp;\n\t\t\tbreak;\n\t\t} else if (ftmp >= fmin) {\n\t\t\tfmin = ftmp;\n\t\t}\n\t}\n\treturn fmax != ~0 ? fmax : fmin;\n}\n\nstatic unsigned long scpi_dvfs_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct scpi_clk *clk = to_scpi_clk(hw);\n\tint idx = clk->scpi_ops->dvfs_get_idx(clk->id);\n\tconst struct scpi_opp *opp;\n\n\tif (idx < 0)\n\t\treturn 0;\n\n\topp = clk->info->opps + idx;\n\treturn opp->freq;\n}\n\nstatic long scpi_dvfs_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long *parent_rate)\n{\n\tstruct scpi_clk *clk = to_scpi_clk(hw);\n\n\treturn __scpi_dvfs_round_rate(clk, rate);\n}\n\nstatic int __scpi_find_dvfs_index(struct scpi_clk *clk, unsigned long rate)\n{\n\tint idx, max_opp = clk->info->count;\n\tconst struct scpi_opp *opp = clk->info->opps;\n\n\tfor (idx = 0; idx < max_opp; idx++, opp++)\n\t\tif (opp->freq == rate)\n\t\t\treturn idx;\n\treturn -EINVAL;\n}\n\nstatic int scpi_dvfs_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct scpi_clk *clk = to_scpi_clk(hw);\n\tint ret = __scpi_find_dvfs_index(clk, rate);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn clk->scpi_ops->dvfs_set_idx(clk->id, (u8)ret);\n}\n\nstatic const struct clk_ops scpi_dvfs_ops = {\n\t.recalc_rate = scpi_dvfs_recalc_rate,\n\t.round_rate = scpi_dvfs_round_rate,\n\t.set_rate = scpi_dvfs_set_rate,\n};\n\nstatic const struct of_device_id scpi_clk_match[] __maybe_unused = {\n\t{ .compatible = \"arm,scpi-dvfs-clocks\", .data = &scpi_dvfs_ops, },\n\t{ .compatible = \"arm,scpi-variable-clocks\", .data = &scpi_clk_ops, },\n\t{}\n};\n\nstatic int\nscpi_clk_ops_init(struct device *dev, const struct of_device_id *match,\n\t\t  struct scpi_clk *sclk, const char *name)\n{\n\tstruct clk_init_data init;\n\tunsigned long min = 0, max = 0;\n\tint ret;\n\n\tinit.name = name;\n\tinit.flags = 0;\n\tinit.num_parents = 0;\n\tinit.ops = match->data;\n\tsclk->hw.init = &init;\n\tsclk->scpi_ops = get_scpi_ops();\n\n\tif (init.ops == &scpi_dvfs_ops) {\n\t\tsclk->info = sclk->scpi_ops->dvfs_get_info(sclk->id);\n\t\tif (IS_ERR(sclk->info))\n\t\t\treturn PTR_ERR(sclk->info);\n\t} else if (init.ops == &scpi_clk_ops) {\n\t\tif (sclk->scpi_ops->clk_get_range(sclk->id, &min, &max) || !max)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tret = devm_clk_hw_register(dev, &sclk->hw);\n\tif (!ret && max)\n\t\tclk_hw_set_rate_range(&sclk->hw, min, max);\n\treturn ret;\n}\n\nstruct scpi_clk_data {\n\tstruct scpi_clk **clk;\n\tunsigned int clk_num;\n};\n\nstatic struct clk_hw *\nscpi_of_clk_src_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct scpi_clk *sclk;\n\tstruct scpi_clk_data *clk_data = data;\n\tunsigned int idx = clkspec->args[0], count;\n\n\tfor (count = 0; count < clk_data->clk_num; count++) {\n\t\tsclk = clk_data->clk[count];\n\t\tif (idx == sclk->id)\n\t\t\treturn &sclk->hw;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int scpi_clk_add(struct device *dev, struct device_node *np,\n\t\t\tconst struct of_device_id *match)\n{\n\tint idx, count, err;\n\tstruct scpi_clk_data *clk_data;\n\n\tcount = of_property_count_strings(np, \"clock-output-names\");\n\tif (count < 0) {\n\t\tdev_err(dev, \"%pOFn: invalid clock output count\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tclk_data = devm_kmalloc(dev, sizeof(*clk_data), GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tclk_data->clk_num = count;\n\tclk_data->clk = devm_kcalloc(dev, count, sizeof(*clk_data->clk),\n\t\t\t\t     GFP_KERNEL);\n\tif (!clk_data->clk)\n\t\treturn -ENOMEM;\n\n\tfor (idx = 0; idx < count; idx++) {\n\t\tstruct scpi_clk *sclk;\n\t\tconst char *name;\n\t\tu32 val;\n\n\t\tsclk = devm_kzalloc(dev, sizeof(*sclk), GFP_KERNEL);\n\t\tif (!sclk)\n\t\t\treturn -ENOMEM;\n\n\t\tif (of_property_read_string_index(np, \"clock-output-names\",\n\t\t\t\t\t\t  idx, &name)) {\n\t\t\tdev_err(dev, \"invalid clock name @ %pOFn\\n\", np);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (of_property_read_u32_index(np, \"clock-indices\",\n\t\t\t\t\t       idx, &val)) {\n\t\t\tdev_err(dev, \"invalid clock index @ %pOFn\\n\", np);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsclk->id = val;\n\n\t\terr = scpi_clk_ops_init(dev, match, sclk, name);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to register clock '%s'\\n\", name);\n\t\t\treturn err;\n\t\t}\n\n\t\tdev_dbg(dev, \"Registered clock '%s'\\n\", name);\n\t\tclk_data->clk[idx] = sclk;\n\t}\n\n\treturn of_clk_add_hw_provider(np, scpi_of_clk_src_get, clk_data);\n}\n\nstatic void scpi_clocks_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *child, *np = dev->of_node;\n\n\tif (cpufreq_dev) {\n\t\tplatform_device_unregister(cpufreq_dev);\n\t\tcpufreq_dev = NULL;\n\t}\n\n\tfor_each_available_child_of_node(np, child)\n\t\tof_clk_del_provider(np);\n}\n\nstatic int scpi_clocks_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *child, *np = dev->of_node;\n\tconst struct of_device_id *match;\n\n\tif (!get_scpi_ops())\n\t\treturn -ENXIO;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tmatch = of_match_node(scpi_clk_match, child);\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tret = scpi_clk_add(dev, child, match);\n\t\tif (ret) {\n\t\t\tscpi_clocks_remove(pdev);\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (match->data != &scpi_dvfs_ops)\n\t\t\tcontinue;\n\t\t \n\t\tcpufreq_dev = platform_device_register_simple(\"scpi-cpufreq\",\n\t\t\t\t\t\t\t      -1, NULL, 0);\n\t\tif (IS_ERR(cpufreq_dev))\n\t\t\tpr_warn(\"unable to register cpufreq device\");\n\t}\n\treturn 0;\n}\n\nstatic const struct of_device_id scpi_clocks_ids[] = {\n\t{ .compatible = \"arm,scpi-clocks\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, scpi_clocks_ids);\n\nstatic struct platform_driver scpi_clocks_driver = {\n\t.driver\t= {\n\t\t.name = \"scpi_clocks\",\n\t\t.of_match_table = scpi_clocks_ids,\n\t},\n\t.probe = scpi_clocks_probe,\n\t.remove_new = scpi_clocks_remove,\n};\nmodule_platform_driver(scpi_clocks_driver);\n\nMODULE_AUTHOR(\"Sudeep Holla <sudeep.holla@arm.com>\");\nMODULE_DESCRIPTION(\"ARM SCPI clock driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}