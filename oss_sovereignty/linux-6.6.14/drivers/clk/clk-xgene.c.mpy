{
  "module_name": "clk-xgene.c",
  "hash_id": "0703be0263838b36d85f58185ff5f241cc871645aceee70abd1e470286d3b29d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-xgene.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/of_address.h>\n\n \n#define N_DIV_RD(src)\t\t\t((src) & 0x000001ff)\n#define SC_N_DIV_RD(src)\t\t((src) & 0x0000007f)\n#define SC_OUTDIV2(src)\t\t\t(((src) & 0x00000100) >> 8)\n\n \n#define CLKR_RD(src)\t\t\t(((src) & 0x07000000)>>24)\n#define CLKOD_RD(src)\t\t\t(((src) & 0x00300000)>>20)\n#define REGSPEC_RESET_F1_MASK\t\t0x00010000\n#define CLKF_RD(src)\t\t\t(((src) & 0x000001ff))\n\n#define XGENE_CLK_DRIVER_VER\t\t\"0.1\"\n\nstatic DEFINE_SPINLOCK(clk_lock);\n\nstatic inline u32 xgene_clk_read(void __iomem *csr)\n{\n\treturn readl_relaxed(csr);\n}\n\nstatic inline void xgene_clk_write(u32 data, void __iomem *csr)\n{\n\twritel_relaxed(data, csr);\n}\n\n \nenum xgene_pll_type {\n\tPLL_TYPE_PCP = 0,\n\tPLL_TYPE_SOC = 1,\n};\n\nstruct xgene_clk_pll {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*reg;\n\tspinlock_t\t*lock;\n\tu32\t\tpll_offset;\n\tenum xgene_pll_type\ttype;\n\tint\t\tversion;\n};\n\n#define to_xgene_clk_pll(_hw) container_of(_hw, struct xgene_clk_pll, hw)\n\nstatic int xgene_clk_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct xgene_clk_pll *pllclk = to_xgene_clk_pll(hw);\n\tu32 data;\n\n\tdata = xgene_clk_read(pllclk->reg + pllclk->pll_offset);\n\tpr_debug(\"%s pll %s\\n\", clk_hw_get_name(hw),\n\t\tdata & REGSPEC_RESET_F1_MASK ? \"disabled\" : \"enabled\");\n\n\treturn data & REGSPEC_RESET_F1_MASK ? 0 : 1;\n}\n\nstatic unsigned long xgene_clk_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct xgene_clk_pll *pllclk = to_xgene_clk_pll(hw);\n\tunsigned long fref;\n\tunsigned long fvco;\n\tu32 pll;\n\tu32 nref;\n\tu32 nout;\n\tu32 nfb;\n\n\tpll = xgene_clk_read(pllclk->reg + pllclk->pll_offset);\n\n\tif (pllclk->version <= 1) {\n\t\tif (pllclk->type == PLL_TYPE_PCP) {\n\t\t\t \n\t\t\tnout = 2;\n\t\t\tfvco = parent_rate * (N_DIV_RD(pll) + 4);\n\t\t} else {\n\t\t\t \n\t\t\tnref = CLKR_RD(pll) + 1;\n\t\t\tnout = CLKOD_RD(pll) + 1;\n\t\t\tnfb = CLKF_RD(pll);\n\t\t\tfref = parent_rate / nref;\n\t\t\tfvco = fref * nfb;\n\t\t}\n\t} else {\n\t\t \n\t\tnout = SC_OUTDIV2(pll) ? 2 : 3;\n\t\tfvco = parent_rate * SC_N_DIV_RD(pll);\n\t}\n\tpr_debug(\"%s pll recalc rate %ld parent %ld version %d\\n\",\n\t\t clk_hw_get_name(hw), fvco / nout, parent_rate,\n\t\t pllclk->version);\n\n\treturn fvco / nout;\n}\n\nstatic const struct clk_ops xgene_clk_pll_ops = {\n\t.is_enabled = xgene_clk_pll_is_enabled,\n\t.recalc_rate = xgene_clk_pll_recalc_rate,\n};\n\nstatic struct clk *xgene_register_clk_pll(struct device *dev,\n\tconst char *name, const char *parent_name,\n\tunsigned long flags, void __iomem *reg, u32 pll_offset,\n\tu32 type, spinlock_t *lock, int version)\n{\n\tstruct xgene_clk_pll *apmclk;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\t \n\tapmclk = kzalloc(sizeof(*apmclk), GFP_KERNEL);\n\tif (!apmclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &xgene_clk_pll_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\n\tapmclk->version = version;\n\tapmclk->reg = reg;\n\tapmclk->lock = lock;\n\tapmclk->pll_offset = pll_offset;\n\tapmclk->type = type;\n\tapmclk->hw.init = &init;\n\n\t \n\tclk = clk_register(dev, &apmclk->hw);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: could not register clk %s\\n\", __func__, name);\n\t\tkfree(apmclk);\n\t\treturn NULL;\n\t}\n\treturn clk;\n}\n\nstatic int xgene_pllclk_version(struct device_node *np)\n{\n\tif (of_device_is_compatible(np, \"apm,xgene-socpll-clock\"))\n\t\treturn 1;\n\tif (of_device_is_compatible(np, \"apm,xgene-pcppll-clock\"))\n\t\treturn 1;\n\treturn 2;\n}\n\nstatic void xgene_pllclk_init(struct device_node *np, enum xgene_pll_type pll_type)\n{\n\tconst char *clk_name = np->full_name;\n\tstruct clk *clk;\n\tvoid __iomem *reg;\n\tint version = xgene_pllclk_version(np);\n\n\treg = of_iomap(np, 0);\n\tif (!reg) {\n\t\tpr_err(\"Unable to map CSR register for %pOF\\n\", np);\n\t\treturn;\n\t}\n\tof_property_read_string(np, \"clock-output-names\", &clk_name);\n\tclk = xgene_register_clk_pll(NULL,\n\t\t\tclk_name, of_clk_get_parent_name(np, 0),\n\t\t\t0, reg, 0, pll_type, &clk_lock,\n\t\t\tversion);\n\tif (!IS_ERR(clk)) {\n\t\tof_clk_add_provider(np, of_clk_src_simple_get, clk);\n\t\tclk_register_clkdev(clk, clk_name, NULL);\n\t\tpr_debug(\"Add %s clock PLL\\n\", clk_name);\n\t}\n}\n\nstatic void xgene_socpllclk_init(struct device_node *np)\n{\n\txgene_pllclk_init(np, PLL_TYPE_SOC);\n}\n\nstatic void xgene_pcppllclk_init(struct device_node *np)\n{\n\txgene_pllclk_init(np, PLL_TYPE_PCP);\n}\n\n \nstruct xgene_clk_pmd {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*reg;\n\tu8\t\tshift;\n\tu32\t\tmask;\n\tu64\t\tdenom;\n\tu32\t\tflags;\n\tspinlock_t\t*lock;\n};\n\n#define to_xgene_clk_pmd(_hw) container_of(_hw, struct xgene_clk_pmd, hw)\n\n#define XGENE_CLK_PMD_SCALE_INVERTED\tBIT(0)\n#define XGENE_CLK_PMD_SHIFT\t\t8\n#define XGENE_CLK_PMD_WIDTH\t\t3\n\nstatic unsigned long xgene_clk_pmd_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct xgene_clk_pmd *fd = to_xgene_clk_pmd(hw);\n\tunsigned long flags = 0;\n\tu64 ret, scale;\n\tu32 val;\n\n\tif (fd->lock)\n\t\tspin_lock_irqsave(fd->lock, flags);\n\telse\n\t\t__acquire(fd->lock);\n\n\tval = readl(fd->reg);\n\n\tif (fd->lock)\n\t\tspin_unlock_irqrestore(fd->lock, flags);\n\telse\n\t\t__release(fd->lock);\n\n\tret = (u64)parent_rate;\n\n\tscale = (val & fd->mask) >> fd->shift;\n\tif (fd->flags & XGENE_CLK_PMD_SCALE_INVERTED)\n\t\tscale = fd->denom - scale;\n\telse\n\t\tscale++;\n\n\t \n\tdo_div(ret, fd->denom);\n\tret *= scale;\n\tif (ret == 0)\n\t\tret = (u64)parent_rate;\n\n\treturn ret;\n}\n\nstatic long xgene_clk_pmd_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long *parent_rate)\n{\n\tstruct xgene_clk_pmd *fd = to_xgene_clk_pmd(hw);\n\tu64 ret, scale;\n\n\tif (!rate || rate >= *parent_rate)\n\t\treturn *parent_rate;\n\n\t \n\tret = rate * fd->denom;\n\tscale = DIV_ROUND_UP_ULL(ret, *parent_rate);\n\n\tret = (u64)*parent_rate * scale;\n\tdo_div(ret, fd->denom);\n\n\treturn ret;\n}\n\nstatic int xgene_clk_pmd_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct xgene_clk_pmd *fd = to_xgene_clk_pmd(hw);\n\tunsigned long flags = 0;\n\tu64 scale, ret;\n\tu32 val;\n\n\t \n\tret = rate * fd->denom;\n\tscale = DIV_ROUND_UP_ULL(ret, (u64)parent_rate);\n\n\t \n\tif (fd->flags & XGENE_CLK_PMD_SCALE_INVERTED)\n\t\tscale = fd->denom - scale;\n\telse\n\t\tscale--;\n\n\tif (fd->lock)\n\t\tspin_lock_irqsave(fd->lock, flags);\n\telse\n\t\t__acquire(fd->lock);\n\n\tval = readl(fd->reg);\n\tval &= ~fd->mask;\n\tval |= (scale << fd->shift);\n\twritel(val, fd->reg);\n\n\tif (fd->lock)\n\t\tspin_unlock_irqrestore(fd->lock, flags);\n\telse\n\t\t__release(fd->lock);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops xgene_clk_pmd_ops = {\n\t.recalc_rate = xgene_clk_pmd_recalc_rate,\n\t.round_rate = xgene_clk_pmd_round_rate,\n\t.set_rate = xgene_clk_pmd_set_rate,\n};\n\nstatic struct clk *\nxgene_register_clk_pmd(struct device *dev,\n\t\t       const char *name, const char *parent_name,\n\t\t       unsigned long flags, void __iomem *reg, u8 shift,\n\t\t       u8 width, u64 denom, u32 clk_flags, spinlock_t *lock)\n{\n\tstruct xgene_clk_pmd *fd;\n\tstruct clk_init_data init;\n\tstruct clk *clk;\n\n\tfd = kzalloc(sizeof(*fd), GFP_KERNEL);\n\tif (!fd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &xgene_clk_pmd_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\n\tfd->reg = reg;\n\tfd->shift = shift;\n\tfd->mask = (BIT(width) - 1) << shift;\n\tfd->denom = denom;\n\tfd->flags = clk_flags;\n\tfd->lock = lock;\n\tfd->hw.init = &init;\n\n\tclk = clk_register(dev, &fd->hw);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: could not register clk %s\\n\", __func__, name);\n\t\tkfree(fd);\n\t\treturn NULL;\n\t}\n\n\treturn clk;\n}\n\nstatic void xgene_pmdclk_init(struct device_node *np)\n{\n\tconst char *clk_name = np->full_name;\n\tvoid __iomem *csr_reg;\n\tstruct resource res;\n\tstruct clk *clk;\n\tu64 denom;\n\tu32 flags = 0;\n\tint rc;\n\n\t \n\tif (!of_device_is_available(np))\n\t\treturn;\n\n\t \n\trc = of_address_to_resource(np, 0, &res);\n\tif (rc != 0) {\n\t\tpr_err(\"no DTS register for %pOF\\n\", np);\n\t\treturn;\n\t}\n\tcsr_reg = of_iomap(np, 0);\n\tif (!csr_reg) {\n\t\tpr_err(\"Unable to map resource for %pOF\\n\", np);\n\t\treturn;\n\t}\n\tof_property_read_string(np, \"clock-output-names\", &clk_name);\n\n\tdenom = BIT(XGENE_CLK_PMD_WIDTH);\n\tflags |= XGENE_CLK_PMD_SCALE_INVERTED;\n\n\tclk = xgene_register_clk_pmd(NULL, clk_name,\n\t\t\t\t     of_clk_get_parent_name(np, 0), 0,\n\t\t\t\t     csr_reg, XGENE_CLK_PMD_SHIFT,\n\t\t\t\t     XGENE_CLK_PMD_WIDTH, denom,\n\t\t\t\t     flags, &clk_lock);\n\tif (!IS_ERR(clk)) {\n\t\tof_clk_add_provider(np, of_clk_src_simple_get, clk);\n\t\tclk_register_clkdev(clk, clk_name, NULL);\n\t\tpr_debug(\"Add %s clock\\n\", clk_name);\n\t} else {\n\t\tif (csr_reg)\n\t\t\tiounmap(csr_reg);\n\t}\n}\n\n \nstruct xgene_dev_parameters {\n\tvoid __iomem *csr_reg;\t\t \n\tu32 reg_clk_offset;\t\t \n\tu32 reg_clk_mask;\t\t \n\tu32 reg_csr_offset;\t\t \n\tu32 reg_csr_mask;\t\t \n\tvoid __iomem *divider_reg;\t \n\tu32 reg_divider_offset;\t\t \n\tu32 reg_divider_shift;\t\t \n\tu32 reg_divider_width;\t\t \n};\n\nstruct xgene_clk {\n\tstruct clk_hw\thw;\n\tspinlock_t\t*lock;\n\tstruct xgene_dev_parameters\tparam;\n};\n\n#define to_xgene_clk(_hw) container_of(_hw, struct xgene_clk, hw)\n\nstatic int xgene_clk_enable(struct clk_hw *hw)\n{\n\tstruct xgene_clk *pclk = to_xgene_clk(hw);\n\tunsigned long flags = 0;\n\tu32 data;\n\n\tif (pclk->lock)\n\t\tspin_lock_irqsave(pclk->lock, flags);\n\n\tif (pclk->param.csr_reg) {\n\t\tpr_debug(\"%s clock enabled\\n\", clk_hw_get_name(hw));\n\t\t \n\t\tdata = xgene_clk_read(pclk->param.csr_reg +\n\t\t\t\t\tpclk->param.reg_clk_offset);\n\t\tdata |= pclk->param.reg_clk_mask;\n\t\txgene_clk_write(data, pclk->param.csr_reg +\n\t\t\t\t\tpclk->param.reg_clk_offset);\n\t\tpr_debug(\"%s clk offset 0x%08X mask 0x%08X value 0x%08X\\n\",\n\t\t\tclk_hw_get_name(hw),\n\t\t\tpclk->param.reg_clk_offset, pclk->param.reg_clk_mask,\n\t\t\tdata);\n\n\t\t \n\t\tdata = xgene_clk_read(pclk->param.csr_reg +\n\t\t\t\t\tpclk->param.reg_csr_offset);\n\t\tdata &= ~pclk->param.reg_csr_mask;\n\t\txgene_clk_write(data, pclk->param.csr_reg +\n\t\t\t\t\tpclk->param.reg_csr_offset);\n\t\tpr_debug(\"%s csr offset 0x%08X mask 0x%08X value 0x%08X\\n\",\n\t\t\tclk_hw_get_name(hw),\n\t\t\tpclk->param.reg_csr_offset, pclk->param.reg_csr_mask,\n\t\t\tdata);\n\t}\n\n\tif (pclk->lock)\n\t\tspin_unlock_irqrestore(pclk->lock, flags);\n\n\treturn 0;\n}\n\nstatic void xgene_clk_disable(struct clk_hw *hw)\n{\n\tstruct xgene_clk *pclk = to_xgene_clk(hw);\n\tunsigned long flags = 0;\n\tu32 data;\n\n\tif (pclk->lock)\n\t\tspin_lock_irqsave(pclk->lock, flags);\n\n\tif (pclk->param.csr_reg) {\n\t\tpr_debug(\"%s clock disabled\\n\", clk_hw_get_name(hw));\n\t\t \n\t\tdata = xgene_clk_read(pclk->param.csr_reg +\n\t\t\t\t\tpclk->param.reg_csr_offset);\n\t\tdata |= pclk->param.reg_csr_mask;\n\t\txgene_clk_write(data, pclk->param.csr_reg +\n\t\t\t\t\tpclk->param.reg_csr_offset);\n\n\t\t \n\t\tdata = xgene_clk_read(pclk->param.csr_reg +\n\t\t\t\t\tpclk->param.reg_clk_offset);\n\t\tdata &= ~pclk->param.reg_clk_mask;\n\t\txgene_clk_write(data, pclk->param.csr_reg +\n\t\t\t\t\tpclk->param.reg_clk_offset);\n\t}\n\n\tif (pclk->lock)\n\t\tspin_unlock_irqrestore(pclk->lock, flags);\n}\n\nstatic int xgene_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct xgene_clk *pclk = to_xgene_clk(hw);\n\tu32 data = 0;\n\n\tif (pclk->param.csr_reg) {\n\t\tpr_debug(\"%s clock checking\\n\", clk_hw_get_name(hw));\n\t\tdata = xgene_clk_read(pclk->param.csr_reg +\n\t\t\t\t\tpclk->param.reg_clk_offset);\n\t\tpr_debug(\"%s clock is %s\\n\", clk_hw_get_name(hw),\n\t\t\tdata & pclk->param.reg_clk_mask ? \"enabled\" :\n\t\t\t\t\t\t\t\"disabled\");\n\t} else {\n\t\treturn 1;\n\t}\n\n\treturn data & pclk->param.reg_clk_mask ? 1 : 0;\n}\n\nstatic unsigned long xgene_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct xgene_clk *pclk = to_xgene_clk(hw);\n\tu32 data;\n\n\tif (pclk->param.divider_reg) {\n\t\tdata = xgene_clk_read(pclk->param.divider_reg +\n\t\t\t\t\tpclk->param.reg_divider_offset);\n\t\tdata >>= pclk->param.reg_divider_shift;\n\t\tdata &= (1 << pclk->param.reg_divider_width) - 1;\n\n\t\tpr_debug(\"%s clock recalc rate %ld parent %ld\\n\",\n\t\t\tclk_hw_get_name(hw),\n\t\t\tparent_rate / data, parent_rate);\n\n\t\treturn parent_rate / data;\n\t} else {\n\t\tpr_debug(\"%s clock recalc rate %ld parent %ld\\n\",\n\t\t\tclk_hw_get_name(hw), parent_rate, parent_rate);\n\t\treturn parent_rate;\n\t}\n}\n\nstatic int xgene_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct xgene_clk *pclk = to_xgene_clk(hw);\n\tunsigned long flags = 0;\n\tu32 data;\n\tu32 divider;\n\tu32 divider_save;\n\n\tif (pclk->lock)\n\t\tspin_lock_irqsave(pclk->lock, flags);\n\n\tif (pclk->param.divider_reg) {\n\t\t \n\t\tif (rate > parent_rate)\n\t\t\trate = parent_rate;\n\t\tdivider_save = divider = parent_rate / rate;  \n\t\tdivider &= (1 << pclk->param.reg_divider_width) - 1;\n\t\tdivider <<= pclk->param.reg_divider_shift;\n\n\t\t \n\t\tdata = xgene_clk_read(pclk->param.divider_reg +\n\t\t\t\tpclk->param.reg_divider_offset);\n\t\tdata &= ~(((1 << pclk->param.reg_divider_width) - 1)\n\t\t\t\t<< pclk->param.reg_divider_shift);\n\t\tdata |= divider;\n\t\txgene_clk_write(data, pclk->param.divider_reg +\n\t\t\t\t\tpclk->param.reg_divider_offset);\n\t\tpr_debug(\"%s clock set rate %ld\\n\", clk_hw_get_name(hw),\n\t\t\tparent_rate / divider_save);\n\t} else {\n\t\tdivider_save = 1;\n\t}\n\n\tif (pclk->lock)\n\t\tspin_unlock_irqrestore(pclk->lock, flags);\n\n\treturn parent_rate / divider_save;\n}\n\nstatic long xgene_clk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *prate)\n{\n\tstruct xgene_clk *pclk = to_xgene_clk(hw);\n\tunsigned long parent_rate = *prate;\n\tu32 divider;\n\n\tif (pclk->param.divider_reg) {\n\t\t \n\t\tif (rate > parent_rate)\n\t\t\trate = parent_rate;\n\t\tdivider = parent_rate / rate;    \n\t} else {\n\t\tdivider = 1;\n\t}\n\n\treturn parent_rate / divider;\n}\n\nstatic const struct clk_ops xgene_clk_ops = {\n\t.enable = xgene_clk_enable,\n\t.disable = xgene_clk_disable,\n\t.is_enabled = xgene_clk_is_enabled,\n\t.recalc_rate = xgene_clk_recalc_rate,\n\t.set_rate = xgene_clk_set_rate,\n\t.round_rate = xgene_clk_round_rate,\n};\n\nstatic struct clk *xgene_register_clk(struct device *dev,\n\t\tconst char *name, const char *parent_name,\n\t\tstruct xgene_dev_parameters *parameters, spinlock_t *lock)\n{\n\tstruct xgene_clk *apmclk;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\tint rc;\n\n\t \n\tapmclk = kzalloc(sizeof(*apmclk), GFP_KERNEL);\n\tif (!apmclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &xgene_clk_ops;\n\tinit.flags = 0;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\n\tapmclk->lock = lock;\n\tapmclk->hw.init = &init;\n\tapmclk->param = *parameters;\n\n\t \n\tclk = clk_register(dev, &apmclk->hw);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: could not register clk %s\\n\", __func__, name);\n\t\tkfree(apmclk);\n\t\treturn clk;\n\t}\n\n\t \n\trc = clk_register_clkdev(clk, name, NULL);\n\tif (rc != 0) {\n\t\tpr_err(\"%s: could not register lookup clk %s\\n\",\n\t\t\t__func__, name);\n\t}\n\treturn clk;\n}\n\nstatic void __init xgene_devclk_init(struct device_node *np)\n{\n\tconst char *clk_name = np->full_name;\n\tstruct clk *clk;\n\tstruct resource res;\n\tint rc;\n\tstruct xgene_dev_parameters parameters;\n\tint i;\n\n\t \n        if (!of_device_is_available(np))\n                return;\n\n\t \n\tparameters.csr_reg = NULL;\n\tparameters.divider_reg = NULL;\n\tfor (i = 0; i < 2; i++) {\n\t\tvoid __iomem *map_res;\n\t\trc = of_address_to_resource(np, i, &res);\n\t\tif (rc != 0) {\n\t\t\tif (i == 0) {\n\t\t\t\tpr_err(\"no DTS register for %pOF\\n\", np);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmap_res = of_iomap(np, i);\n\t\tif (!map_res) {\n\t\t\tpr_err(\"Unable to map resource %d for %pOF\\n\", i, np);\n\t\t\tgoto err;\n\t\t}\n\t\tif (strcmp(res.name, \"div-reg\") == 0)\n\t\t\tparameters.divider_reg = map_res;\n\t\telse  \n\t\t\tparameters.csr_reg = map_res;\n\t}\n\tif (of_property_read_u32(np, \"csr-offset\", &parameters.reg_csr_offset))\n\t\tparameters.reg_csr_offset = 0;\n\tif (of_property_read_u32(np, \"csr-mask\", &parameters.reg_csr_mask))\n\t\tparameters.reg_csr_mask = 0xF;\n\tif (of_property_read_u32(np, \"enable-offset\",\n\t\t\t\t&parameters.reg_clk_offset))\n\t\tparameters.reg_clk_offset = 0x8;\n\tif (of_property_read_u32(np, \"enable-mask\", &parameters.reg_clk_mask))\n\t\tparameters.reg_clk_mask = 0xF;\n\tif (of_property_read_u32(np, \"divider-offset\",\n\t\t\t\t&parameters.reg_divider_offset))\n\t\tparameters.reg_divider_offset = 0;\n\tif (of_property_read_u32(np, \"divider-width\",\n\t\t\t\t&parameters.reg_divider_width))\n\t\tparameters.reg_divider_width = 0;\n\tif (of_property_read_u32(np, \"divider-shift\",\n\t\t\t\t&parameters.reg_divider_shift))\n\t\tparameters.reg_divider_shift = 0;\n\tof_property_read_string(np, \"clock-output-names\", &clk_name);\n\n\tclk = xgene_register_clk(NULL, clk_name,\n\t\tof_clk_get_parent_name(np, 0), &parameters, &clk_lock);\n\tif (IS_ERR(clk))\n\t\tgoto err;\n\tpr_debug(\"Add %s clock\\n\", clk_name);\n\trc = of_clk_add_provider(np, of_clk_src_simple_get, clk);\n\tif (rc != 0)\n\t\tpr_err(\"%s: could register provider clk %pOF\\n\", __func__, np);\n\n\treturn;\n\nerr:\n\tif (parameters.csr_reg)\n\t\tiounmap(parameters.csr_reg);\n\tif (parameters.divider_reg)\n\t\tiounmap(parameters.divider_reg);\n}\n\nCLK_OF_DECLARE(xgene_socpll_clock, \"apm,xgene-socpll-clock\", xgene_socpllclk_init);\nCLK_OF_DECLARE(xgene_pcppll_clock, \"apm,xgene-pcppll-clock\", xgene_pcppllclk_init);\nCLK_OF_DECLARE(xgene_pmd_clock, \"apm,xgene-pmd-clock\", xgene_pmdclk_init);\nCLK_OF_DECLARE(xgene_socpll_v2_clock, \"apm,xgene-socpll-v2-clock\",\n\t       xgene_socpllclk_init);\nCLK_OF_DECLARE(xgene_pcppll_v2_clock, \"apm,xgene-pcppll-v2-clock\",\n\t       xgene_pcppllclk_init);\nCLK_OF_DECLARE(xgene_dev_clock, \"apm,xgene-device-clock\", xgene_devclk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}