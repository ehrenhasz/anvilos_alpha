{
  "module_name": "clk-fixed-factor.c",
  "hash_id": "7310a5617e9cf8f718b7be745df44cf520c290d69c2b7628c483d919ba0e5d95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-fixed-factor.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n \n\nstatic unsigned long clk_factor_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_fixed_factor *fix = to_clk_fixed_factor(hw);\n\tunsigned long long int rate;\n\n\trate = (unsigned long long int)parent_rate * fix->mult;\n\tdo_div(rate, fix->div);\n\treturn (unsigned long)rate;\n}\n\nstatic long clk_factor_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *prate)\n{\n\tstruct clk_fixed_factor *fix = to_clk_fixed_factor(hw);\n\n\tif (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) {\n\t\tunsigned long best_parent;\n\n\t\tbest_parent = (rate / fix->mult) * fix->div;\n\t\t*prate = clk_hw_round_rate(clk_hw_get_parent(hw), best_parent);\n\t}\n\n\treturn (*prate / fix->div) * fix->mult;\n}\n\nstatic int clk_factor_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\t \n\n\treturn 0;\n}\n\nconst struct clk_ops clk_fixed_factor_ops = {\n\t.round_rate = clk_factor_round_rate,\n\t.set_rate = clk_factor_set_rate,\n\t.recalc_rate = clk_factor_recalc_rate,\n};\nEXPORT_SYMBOL_GPL(clk_fixed_factor_ops);\n\nstatic void devm_clk_hw_register_fixed_factor_release(struct device *dev, void *res)\n{\n\tstruct clk_fixed_factor *fix = res;\n\n\t \n\tclk_hw_unregister(&fix->hw);\n}\n\nstatic struct clk_hw *\n__clk_hw_register_fixed_factor(struct device *dev, struct device_node *np,\n\t\tconst char *name, const char *parent_name,\n\t\tconst struct clk_hw *parent_hw, int index,\n\t\tunsigned long flags, unsigned int mult, unsigned int div,\n\t\tbool devm)\n{\n\tstruct clk_fixed_factor *fix;\n\tstruct clk_init_data init = { };\n\tstruct clk_parent_data pdata = { .index = index };\n\tstruct clk_hw *hw;\n\tint ret;\n\n\t \n\tif (devm && !dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (devm)\n\t\tfix = devres_alloc(devm_clk_hw_register_fixed_factor_release,\n\t\t\t\tsizeof(*fix), GFP_KERNEL);\n\telse\n\t\tfix = kmalloc(sizeof(*fix), GFP_KERNEL);\n\tif (!fix)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tfix->mult = mult;\n\tfix->div = div;\n\tfix->hw.init = &init;\n\n\tinit.name = name;\n\tinit.ops = &clk_fixed_factor_ops;\n\tinit.flags = flags;\n\tif (parent_name)\n\t\tinit.parent_names = &parent_name;\n\telse if (parent_hw)\n\t\tinit.parent_hws = &parent_hw;\n\telse\n\t\tinit.parent_data = &pdata;\n\tinit.num_parents = 1;\n\n\thw = &fix->hw;\n\tif (dev)\n\t\tret = clk_hw_register(dev, hw);\n\telse\n\t\tret = of_clk_hw_register(np, hw);\n\tif (ret) {\n\t\tif (devm)\n\t\t\tdevres_free(fix);\n\t\telse\n\t\t\tkfree(fix);\n\t\thw = ERR_PTR(ret);\n\t} else if (devm)\n\t\tdevres_add(dev, fix);\n\n\treturn hw;\n}\n\n \nstruct clk_hw *devm_clk_hw_register_fixed_factor_index(struct device *dev,\n\t\tconst char *name, unsigned int index, unsigned long flags,\n\t\tunsigned int mult, unsigned int div)\n{\n\treturn __clk_hw_register_fixed_factor(dev, NULL, name, NULL, NULL, index,\n\t\t\t\t\t      flags, mult, div, true);\n}\nEXPORT_SYMBOL_GPL(devm_clk_hw_register_fixed_factor_index);\n\n \nstruct clk_hw *devm_clk_hw_register_fixed_factor_parent_hw(struct device *dev,\n\t\tconst char *name, const struct clk_hw *parent_hw,\n\t\tunsigned long flags, unsigned int mult, unsigned int div)\n{\n\treturn __clk_hw_register_fixed_factor(dev, NULL, name, NULL, parent_hw,\n\t\t\t\t\t      -1, flags, mult, div, true);\n}\nEXPORT_SYMBOL_GPL(devm_clk_hw_register_fixed_factor_parent_hw);\n\nstruct clk_hw *clk_hw_register_fixed_factor_parent_hw(struct device *dev,\n\t\tconst char *name, const struct clk_hw *parent_hw,\n\t\tunsigned long flags, unsigned int mult, unsigned int div)\n{\n\treturn __clk_hw_register_fixed_factor(dev, NULL, name, NULL,\n\t\t\t\t\t      parent_hw, -1, flags, mult, div,\n\t\t\t\t\t      false);\n}\nEXPORT_SYMBOL_GPL(clk_hw_register_fixed_factor_parent_hw);\n\nstruct clk_hw *clk_hw_register_fixed_factor(struct device *dev,\n\t\tconst char *name, const char *parent_name, unsigned long flags,\n\t\tunsigned int mult, unsigned int div)\n{\n\treturn __clk_hw_register_fixed_factor(dev, NULL, name, parent_name, NULL, -1,\n\t\t\t\t\t      flags, mult, div, false);\n}\nEXPORT_SYMBOL_GPL(clk_hw_register_fixed_factor);\n\nstruct clk *clk_register_fixed_factor(struct device *dev, const char *name,\n\t\tconst char *parent_name, unsigned long flags,\n\t\tunsigned int mult, unsigned int div)\n{\n\tstruct clk_hw *hw;\n\n\thw = clk_hw_register_fixed_factor(dev, name, parent_name, flags, mult,\n\t\t\t\t\t  div);\n\tif (IS_ERR(hw))\n\t\treturn ERR_CAST(hw);\n\treturn hw->clk;\n}\nEXPORT_SYMBOL_GPL(clk_register_fixed_factor);\n\nvoid clk_unregister_fixed_factor(struct clk *clk)\n{\n\tstruct clk_hw *hw;\n\n\thw = __clk_get_hw(clk);\n\tif (!hw)\n\t\treturn;\n\n\tclk_unregister(clk);\n\tkfree(to_clk_fixed_factor(hw));\n}\nEXPORT_SYMBOL_GPL(clk_unregister_fixed_factor);\n\nvoid clk_hw_unregister_fixed_factor(struct clk_hw *hw)\n{\n\tstruct clk_fixed_factor *fix;\n\n\tfix = to_clk_fixed_factor(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(fix);\n}\nEXPORT_SYMBOL_GPL(clk_hw_unregister_fixed_factor);\n\nstruct clk_hw *devm_clk_hw_register_fixed_factor(struct device *dev,\n\t\tconst char *name, const char *parent_name, unsigned long flags,\n\t\tunsigned int mult, unsigned int div)\n{\n\treturn __clk_hw_register_fixed_factor(dev, NULL, name, parent_name, NULL, -1,\n\t\t\tflags, mult, div, true);\n}\nEXPORT_SYMBOL_GPL(devm_clk_hw_register_fixed_factor);\n\n#ifdef CONFIG_OF\nstatic struct clk_hw *_of_fixed_factor_clk_setup(struct device_node *node)\n{\n\tstruct clk_hw *hw;\n\tconst char *clk_name = node->name;\n\tu32 div, mult;\n\tint ret;\n\n\tif (of_property_read_u32(node, \"clock-div\", &div)) {\n\t\tpr_err(\"%s Fixed factor clock <%pOFn> must have a clock-div property\\n\",\n\t\t\t__func__, node);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tif (of_property_read_u32(node, \"clock-mult\", &mult)) {\n\t\tpr_err(\"%s Fixed factor clock <%pOFn> must have a clock-mult property\\n\",\n\t\t\t__func__, node);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\n\thw = __clk_hw_register_fixed_factor(NULL, node, clk_name, NULL, NULL, 0,\n\t\t\t\t\t    0, mult, div, false);\n\tif (IS_ERR(hw)) {\n\t\t \n\t\tof_node_clear_flag(node, OF_POPULATED);\n\t\treturn ERR_CAST(hw);\n\t}\n\n\tret = of_clk_add_hw_provider(node, of_clk_hw_simple_get, hw);\n\tif (ret) {\n\t\tclk_hw_unregister_fixed_factor(hw);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\n \nvoid __init of_fixed_factor_clk_setup(struct device_node *node)\n{\n\t_of_fixed_factor_clk_setup(node);\n}\nCLK_OF_DECLARE(fixed_factor_clk, \"fixed-factor-clock\",\n\t\tof_fixed_factor_clk_setup);\n\nstatic void of_fixed_factor_clk_remove(struct platform_device *pdev)\n{\n\tstruct clk_hw *clk = platform_get_drvdata(pdev);\n\n\tof_clk_del_provider(pdev->dev.of_node);\n\tclk_hw_unregister_fixed_factor(clk);\n}\n\nstatic int of_fixed_factor_clk_probe(struct platform_device *pdev)\n{\n\tstruct clk_hw *clk;\n\n\t \n\tclk = _of_fixed_factor_clk_setup(pdev->dev.of_node);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tplatform_set_drvdata(pdev, clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_fixed_factor_clk_ids[] = {\n\t{ .compatible = \"fixed-factor-clock\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, of_fixed_factor_clk_ids);\n\nstatic struct platform_driver of_fixed_factor_clk_driver = {\n\t.driver = {\n\t\t.name = \"of_fixed_factor_clk\",\n\t\t.of_match_table = of_fixed_factor_clk_ids,\n\t},\n\t.probe = of_fixed_factor_clk_probe,\n\t.remove_new = of_fixed_factor_clk_remove,\n};\nbuiltin_platform_driver(of_fixed_factor_clk_driver);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}