{
  "module_name": "clk-rk808.c",
  "hash_id": "79bf7e7da21345cc2205bf03290572f56f781e607f4d6520914a185d32871a04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-rk808.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/rk808.h>\n\nstruct rk808_clkout {\n\tstruct regmap\t\t*regmap;\n\tstruct clk_hw\t\tclkout1_hw;\n\tstruct clk_hw\t\tclkout2_hw;\n};\n\nstatic unsigned long rk808_clkout_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\treturn 32768;\n}\n\nstatic int rk808_clkout2_enable(struct clk_hw *hw, bool enable)\n{\n\tstruct rk808_clkout *rk808_clkout = container_of(hw,\n\t\t\t\t\t\t\t struct rk808_clkout,\n\t\t\t\t\t\t\t clkout2_hw);\n\n\treturn regmap_update_bits(rk808_clkout->regmap, RK808_CLK32OUT_REG,\n\t\t\t\t  CLK32KOUT2_EN, enable ? CLK32KOUT2_EN : 0);\n}\n\nstatic int rk808_clkout2_prepare(struct clk_hw *hw)\n{\n\treturn rk808_clkout2_enable(hw, true);\n}\n\nstatic void rk808_clkout2_unprepare(struct clk_hw *hw)\n{\n\trk808_clkout2_enable(hw, false);\n}\n\nstatic int rk808_clkout2_is_prepared(struct clk_hw *hw)\n{\n\tstruct rk808_clkout *rk808_clkout = container_of(hw,\n\t\t\t\t\t\t\t struct rk808_clkout,\n\t\t\t\t\t\t\t clkout2_hw);\n\tuint32_t val;\n\n\tint ret = regmap_read(rk808_clkout->regmap, RK808_CLK32OUT_REG, &val);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (val & CLK32KOUT2_EN) ? 1 : 0;\n}\n\nstatic const struct clk_ops rk808_clkout1_ops = {\n\t.recalc_rate = rk808_clkout_recalc_rate,\n};\n\nstatic const struct clk_ops rk808_clkout2_ops = {\n\t.prepare = rk808_clkout2_prepare,\n\t.unprepare = rk808_clkout2_unprepare,\n\t.is_prepared = rk808_clkout2_is_prepared,\n\t.recalc_rate = rk808_clkout_recalc_rate,\n};\n\nstatic struct clk_hw *\nof_clk_rk808_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct rk808_clkout *rk808_clkout = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= 2) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn idx ? &rk808_clkout->clkout2_hw : &rk808_clkout->clkout1_hw;\n}\n\nstatic int rk817_clkout2_enable(struct clk_hw *hw, bool enable)\n{\n\tstruct rk808_clkout *rk808_clkout = container_of(hw,\n\t\t\t\t\t\t\t struct rk808_clkout,\n\t\t\t\t\t\t\t clkout2_hw);\n\n\treturn regmap_update_bits(rk808_clkout->regmap, RK817_SYS_CFG(1),\n\t\t\t\t  RK817_CLK32KOUT2_EN,\n\t\t\t\t  enable ? RK817_CLK32KOUT2_EN : 0);\n}\n\nstatic int rk817_clkout2_prepare(struct clk_hw *hw)\n{\n\treturn rk817_clkout2_enable(hw, true);\n}\n\nstatic void rk817_clkout2_unprepare(struct clk_hw *hw)\n{\n\trk817_clkout2_enable(hw, false);\n}\n\nstatic int rk817_clkout2_is_prepared(struct clk_hw *hw)\n{\n\tstruct rk808_clkout *rk808_clkout = container_of(hw,\n\t\t\t\t\t\t\t struct rk808_clkout,\n\t\t\t\t\t\t\t clkout2_hw);\n\tunsigned int val;\n\n\tint ret = regmap_read(rk808_clkout->regmap, RK817_SYS_CFG(1), &val);\n\n\tif (ret < 0)\n\t\treturn 0;\n\n\treturn (val & RK817_CLK32KOUT2_EN) ? 1 : 0;\n}\n\nstatic const struct clk_ops rk817_clkout2_ops = {\n\t.prepare = rk817_clkout2_prepare,\n\t.unprepare = rk817_clkout2_unprepare,\n\t.is_prepared = rk817_clkout2_is_prepared,\n\t.recalc_rate = rk808_clkout_recalc_rate,\n};\n\nstatic const struct clk_ops *rkpmic_get_ops(long variant)\n{\n\tswitch (variant) {\n\tcase RK809_ID:\n\tcase RK817_ID:\n\t\treturn &rk817_clkout2_ops;\n\t \n\tdefault:\n\t\treturn &rk808_clkout2_ops;\n\t}\n}\n\nstatic int rk808_clkout_probe(struct platform_device *pdev)\n{\n\tstruct rk808 *rk808 = dev_get_drvdata(pdev->dev.parent);\n\tstruct device *dev = &pdev->dev;\n\tstruct clk_init_data init = {};\n\tstruct rk808_clkout *rk808_clkout;\n\tint ret;\n\n\tdev->of_node = pdev->dev.parent->of_node;\n\n\trk808_clkout = devm_kzalloc(dev,\n\t\t\t\t    sizeof(*rk808_clkout), GFP_KERNEL);\n\tif (!rk808_clkout)\n\t\treturn -ENOMEM;\n\n\trk808_clkout->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!rk808_clkout->regmap)\n\t\treturn -ENODEV;\n\n\tinit.parent_names = NULL;\n\tinit.num_parents = 0;\n\tinit.name = \"rk808-clkout1\";\n\tinit.ops = &rk808_clkout1_ops;\n\trk808_clkout->clkout1_hw.init = &init;\n\n\t \n\tof_property_read_string_index(dev->of_node, \"clock-output-names\",\n\t\t\t\t      0, &init.name);\n\n\tret = devm_clk_hw_register(dev, &rk808_clkout->clkout1_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tinit.name = \"rk808-clkout2\";\n\tinit.ops = rkpmic_get_ops(rk808->variant);\n\trk808_clkout->clkout2_hw.init = &init;\n\n\t \n\tof_property_read_string_index(dev->of_node, \"clock-output-names\",\n\t\t\t\t      1, &init.name);\n\n\tret = devm_clk_hw_register(dev, &rk808_clkout->clkout2_hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, of_clk_rk808_get,\n\t\t\t\t\t   rk808_clkout);\n}\n\nstatic struct platform_driver rk808_clkout_driver = {\n\t.probe = rk808_clkout_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"rk808-clkout\",\n\t},\n};\n\nmodule_platform_driver(rk808_clkout_driver);\n\nMODULE_DESCRIPTION(\"Clkout driver for the rk808 series PMICs\");\nMODULE_AUTHOR(\"Chris Zhong <zyw@rock-chips.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:rk808-clkout\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}