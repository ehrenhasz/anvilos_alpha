{
  "module_name": "clk-emev2.c",
  "hash_id": "b44117402babc53762155279d484b61da5addb344a24c61a43dcf72ff51f44cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/renesas/clk-emev2.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n \n#define USIAU0_RSTCTRL 0x094\n#define USIBU1_RSTCTRL 0x0ac\n#define USIBU2_RSTCTRL 0x0b0\n#define USIBU3_RSTCTRL 0x0b4\n#define IIC0_RSTCTRL 0x0dc\n#define IIC1_RSTCTRL 0x0e0\n#define STI_RSTCTRL 0x124\n#define STI_CLKSEL 0x688\n\nstatic DEFINE_SPINLOCK(lock);\n\n \nstatic void __iomem *smu_base;\n\nstatic void __init emev2_smu_write(unsigned long value, int offs)\n{\n\tBUG_ON(!smu_base || (offs >= PAGE_SIZE));\n\twritel_relaxed(value, smu_base + offs);\n}\n\nstatic const struct of_device_id smu_id[] __initconst = {\n\t{ .compatible = \"renesas,emev2-smu\", },\n\t{},\n};\n\nstatic void __init emev2_smu_init(void)\n{\n\tstruct device_node *np;\n\n\tnp = of_find_matching_node(NULL, smu_id);\n\tBUG_ON(!np);\n\tsmu_base = of_iomap(np, 0);\n\tBUG_ON(!smu_base);\n\tof_node_put(np);\n\n\t \n\temev2_smu_write(0, STI_CLKSEL);\n\temev2_smu_write(1, STI_RSTCTRL);\n\n\t \n\temev2_smu_write(2, USIAU0_RSTCTRL);\n\temev2_smu_write(2, USIBU1_RSTCTRL);\n\temev2_smu_write(2, USIBU2_RSTCTRL);\n\temev2_smu_write(2, USIBU3_RSTCTRL);\n\n\t \n\temev2_smu_write(1, IIC0_RSTCTRL);\n\temev2_smu_write(1, IIC1_RSTCTRL);\n}\n\nstatic void __init emev2_smu_clkdiv_init(struct device_node *np)\n{\n\tu32 reg[2];\n\tstruct clk *clk;\n\tconst char *parent_name = of_clk_get_parent_name(np, 0);\n\tif (WARN_ON(of_property_read_u32_array(np, \"reg\", reg, 2)))\n\t\treturn;\n\tif (!smu_base)\n\t\temev2_smu_init();\n\tclk = clk_register_divider(NULL, np->name, parent_name, 0,\n\t\t\t\t   smu_base + reg[0], reg[1], 8, 0, &lock);\n\tof_clk_add_provider(np, of_clk_src_simple_get, clk);\n\tpr_debug(\"## %s %pOFn %p\\n\", __func__, np, clk);\n}\nCLK_OF_DECLARE(emev2_smu_clkdiv, \"renesas,emev2-smu-clkdiv\",\n\t\temev2_smu_clkdiv_init);\n\nstatic void __init emev2_smu_gclk_init(struct device_node *np)\n{\n\tu32 reg[2];\n\tstruct clk *clk;\n\tconst char *parent_name = of_clk_get_parent_name(np, 0);\n\tif (WARN_ON(of_property_read_u32_array(np, \"reg\", reg, 2)))\n\t\treturn;\n\tif (!smu_base)\n\t\temev2_smu_init();\n\tclk = clk_register_gate(NULL, np->name, parent_name, 0,\n\t\t\t\tsmu_base + reg[0], reg[1], 0, &lock);\n\tof_clk_add_provider(np, of_clk_src_simple_get, clk);\n\tpr_debug(\"## %s %pOFn %p\\n\", __func__, np, clk);\n}\nCLK_OF_DECLARE(emev2_smu_gclk, \"renesas,emev2-smu-gclk\", emev2_smu_gclk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}