{
  "module_name": "rzg2l-cpg.c",
  "hash_id": "ee20a8138432b352186300e121f4cd0d81f81fcebb82147b4b1b0c69b960dace",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/renesas/rzg2l-cpg.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clk/renesas.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/iopoll.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_domain.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include <linux/units.h>\n\n#include <dt-bindings/clock/renesas-cpg-mssr.h>\n\n#include \"rzg2l-cpg.h\"\n\n#ifdef DEBUG\n#define WARN_DEBUG(x)\tWARN_ON(x)\n#else\n#define WARN_DEBUG(x)\tdo { } while (0)\n#endif\n\n#define GET_SHIFT(val)\t\t((val >> 12) & 0xff)\n#define GET_WIDTH(val)\t\t((val >> 8) & 0xf)\n\n#define KDIV(val)\t\t((s16)FIELD_GET(GENMASK(31, 16), val))\n#define MDIV(val)\t\tFIELD_GET(GENMASK(15, 6), val)\n#define PDIV(val)\t\tFIELD_GET(GENMASK(5, 0), val)\n#define SDIV(val)\t\tFIELD_GET(GENMASK(2, 0), val)\n\n#define CLK_ON_R(reg)\t\t(reg)\n#define CLK_MON_R(reg)\t\t(0x180 + (reg))\n#define CLK_RST_R(reg)\t\t(reg)\n#define CLK_MRST_R(reg)\t\t(0x180 + (reg))\n\n#define GET_REG_OFFSET(val)\t\t((val >> 20) & 0xfff)\n#define GET_REG_SAMPLL_CLK1(val)\t((val >> 22) & 0xfff)\n#define GET_REG_SAMPLL_CLK2(val)\t((val >> 12) & 0xfff)\n\n#define MAX_VCLK_FREQ\t\t(148500000)\n\nstruct sd_hw_data {\n\tstruct clk_hw hw;\n\tu32 conf;\n\tstruct rzg2l_cpg_priv *priv;\n};\n\n#define to_sd_hw_data(_hw)\tcontainer_of(_hw, struct sd_hw_data, hw)\n\nstruct rzg2l_pll5_param {\n\tu32 pl5_fracin;\n\tu8 pl5_refdiv;\n\tu8 pl5_intin;\n\tu8 pl5_postdiv1;\n\tu8 pl5_postdiv2;\n\tu8 pl5_spread;\n};\n\nstruct rzg2l_pll5_mux_dsi_div_param {\n\tu8 clksrc;\n\tu8 dsi_div_a;\n\tu8 dsi_div_b;\n};\n\n \nstruct rzg2l_cpg_priv {\n\tstruct reset_controller_dev rcdev;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tspinlock_t rmw_lock;\n\n\tstruct clk **clks;\n\tunsigned int num_core_clks;\n\tunsigned int num_mod_clks;\n\tunsigned int num_resets;\n\tunsigned int last_dt_core_clk;\n\n\tconst struct rzg2l_cpg_info *info;\n\n\tstruct generic_pm_domain genpd;\n\n\tstruct rzg2l_pll5_mux_dsi_div_param mux_dsi_div_params;\n};\n\nstatic void rzg2l_cpg_del_clk_provider(void *data)\n{\n\tof_clk_del_provider(data);\n}\n\nstatic struct clk * __init\nrzg2l_cpg_div_clk_register(const struct cpg_core_clk *core,\n\t\t\t   struct clk **clks,\n\t\t\t   void __iomem *base,\n\t\t\t   struct rzg2l_cpg_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\tconst struct clk *parent;\n\tconst char *parent_name;\n\tstruct clk_hw *clk_hw;\n\n\tparent = clks[core->parent & 0xffff];\n\tif (IS_ERR(parent))\n\t\treturn ERR_CAST(parent);\n\n\tparent_name = __clk_get_name(parent);\n\n\tif (core->dtable)\n\t\tclk_hw = clk_hw_register_divider_table(dev, core->name,\n\t\t\t\t\t\t       parent_name, 0,\n\t\t\t\t\t\t       base + GET_REG_OFFSET(core->conf),\n\t\t\t\t\t\t       GET_SHIFT(core->conf),\n\t\t\t\t\t\t       GET_WIDTH(core->conf),\n\t\t\t\t\t\t       core->flag,\n\t\t\t\t\t\t       core->dtable,\n\t\t\t\t\t\t       &priv->rmw_lock);\n\telse\n\t\tclk_hw = clk_hw_register_divider(dev, core->name,\n\t\t\t\t\t\t parent_name, 0,\n\t\t\t\t\t\t base + GET_REG_OFFSET(core->conf),\n\t\t\t\t\t\t GET_SHIFT(core->conf),\n\t\t\t\t\t\t GET_WIDTH(core->conf),\n\t\t\t\t\t\t core->flag, &priv->rmw_lock);\n\n\tif (IS_ERR(clk_hw))\n\t\treturn ERR_CAST(clk_hw);\n\n\treturn clk_hw->clk;\n}\n\nstatic struct clk * __init\nrzg2l_cpg_mux_clk_register(const struct cpg_core_clk *core,\n\t\t\t   void __iomem *base,\n\t\t\t   struct rzg2l_cpg_priv *priv)\n{\n\tconst struct clk_hw *clk_hw;\n\n\tclk_hw = devm_clk_hw_register_mux(priv->dev, core->name,\n\t\t\t\t\t  core->parent_names, core->num_parents,\n\t\t\t\t\t  core->flag,\n\t\t\t\t\t  base + GET_REG_OFFSET(core->conf),\n\t\t\t\t\t  GET_SHIFT(core->conf),\n\t\t\t\t\t  GET_WIDTH(core->conf),\n\t\t\t\t\t  core->mux_flags, &priv->rmw_lock);\n\tif (IS_ERR(clk_hw))\n\t\treturn ERR_CAST(clk_hw);\n\n\treturn clk_hw->clk;\n}\n\nstatic int rzg2l_cpg_sd_clk_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct sd_hw_data *hwdata = to_sd_hw_data(hw);\n\tstruct rzg2l_cpg_priv *priv = hwdata->priv;\n\tu32 off = GET_REG_OFFSET(hwdata->conf);\n\tu32 shift = GET_SHIFT(hwdata->conf);\n\tconst u32 clk_src_266 = 2;\n\tu32 msk, val, bitmask;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tbitmask = (GENMASK(GET_WIDTH(hwdata->conf) - 1, 0) << shift) << 16;\n\tmsk = off ? CPG_CLKSTATUS_SELSDHI1_STS : CPG_CLKSTATUS_SELSDHI0_STS;\n\tspin_lock_irqsave(&priv->rmw_lock, flags);\n\tif (index != clk_src_266) {\n\t\twritel(bitmask | ((clk_src_266 + 1) << shift), priv->base + off);\n\n\t\tret = readl_poll_timeout_atomic(priv->base + CPG_CLKSTATUS, val,\n\t\t\t\t\t\t!(val & msk), 10,\n\t\t\t\t\t\tCPG_SDHI_CLK_SWITCH_STATUS_TIMEOUT_US);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\twritel(bitmask | ((index + 1) << shift), priv->base + off);\n\n\tret = readl_poll_timeout_atomic(priv->base + CPG_CLKSTATUS, val,\n\t\t\t\t\t!(val & msk), 10,\n\t\t\t\t\tCPG_SDHI_CLK_SWITCH_STATUS_TIMEOUT_US);\nunlock:\n\tspin_unlock_irqrestore(&priv->rmw_lock, flags);\n\n\tif (ret)\n\t\tdev_err(priv->dev, \"failed to switch clk source\\n\");\n\n\treturn ret;\n}\n\nstatic u8 rzg2l_cpg_sd_clk_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct sd_hw_data *hwdata = to_sd_hw_data(hw);\n\tstruct rzg2l_cpg_priv *priv = hwdata->priv;\n\tu32 val = readl(priv->base + GET_REG_OFFSET(hwdata->conf));\n\n\tval >>= GET_SHIFT(hwdata->conf);\n\tval &= GENMASK(GET_WIDTH(hwdata->conf) - 1, 0);\n\n\treturn val ? val - 1 : 0;\n}\n\nstatic const struct clk_ops rzg2l_cpg_sd_clk_mux_ops = {\n\t.determine_rate = __clk_mux_determine_rate_closest,\n\t.set_parent\t= rzg2l_cpg_sd_clk_mux_set_parent,\n\t.get_parent\t= rzg2l_cpg_sd_clk_mux_get_parent,\n};\n\nstatic struct clk * __init\nrzg2l_cpg_sd_mux_clk_register(const struct cpg_core_clk *core,\n\t\t\t      void __iomem *base,\n\t\t\t      struct rzg2l_cpg_priv *priv)\n{\n\tstruct sd_hw_data *clk_hw_data;\n\tstruct clk_init_data init;\n\tstruct clk_hw *clk_hw;\n\tint ret;\n\n\tclk_hw_data = devm_kzalloc(priv->dev, sizeof(*clk_hw_data), GFP_KERNEL);\n\tif (!clk_hw_data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk_hw_data->priv = priv;\n\tclk_hw_data->conf = core->conf;\n\n\tinit.name = GET_SHIFT(core->conf) ? \"sd1\" : \"sd0\";\n\tinit.ops = &rzg2l_cpg_sd_clk_mux_ops;\n\tinit.flags = 0;\n\tinit.num_parents = core->num_parents;\n\tinit.parent_names = core->parent_names;\n\n\tclk_hw = &clk_hw_data->hw;\n\tclk_hw->init = &init;\n\n\tret = devm_clk_hw_register(priv->dev, clk_hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn clk_hw->clk;\n}\n\nstatic unsigned long\nrzg2l_cpg_get_foutpostdiv_rate(struct rzg2l_pll5_param *params,\n\t\t\t       unsigned long rate)\n{\n\tunsigned long foutpostdiv_rate;\n\n\tparams->pl5_intin = rate / MEGA;\n\tparams->pl5_fracin = div_u64(((u64)rate % MEGA) << 24, MEGA);\n\tparams->pl5_refdiv = 2;\n\tparams->pl5_postdiv1 = 1;\n\tparams->pl5_postdiv2 = 1;\n\tparams->pl5_spread = 0x16;\n\n\tfoutpostdiv_rate =\n\t\tEXTAL_FREQ_IN_MEGA_HZ * MEGA / params->pl5_refdiv *\n\t\t((((params->pl5_intin << 24) + params->pl5_fracin)) >> 24) /\n\t\t(params->pl5_postdiv1 * params->pl5_postdiv2);\n\n\treturn foutpostdiv_rate;\n}\n\nstruct dsi_div_hw_data {\n\tstruct clk_hw hw;\n\tu32 conf;\n\tunsigned long rate;\n\tstruct rzg2l_cpg_priv *priv;\n};\n\n#define to_dsi_div_hw_data(_hw)\tcontainer_of(_hw, struct dsi_div_hw_data, hw)\n\nstatic unsigned long rzg2l_cpg_dsi_div_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct dsi_div_hw_data *dsi_div = to_dsi_div_hw_data(hw);\n\tunsigned long rate = dsi_div->rate;\n\n\tif (!rate)\n\t\trate = parent_rate;\n\n\treturn rate;\n}\n\nstatic unsigned long rzg2l_cpg_get_vclk_parent_rate(struct clk_hw *hw,\n\t\t\t\t\t\t    unsigned long rate)\n{\n\tstruct dsi_div_hw_data *dsi_div = to_dsi_div_hw_data(hw);\n\tstruct rzg2l_cpg_priv *priv = dsi_div->priv;\n\tstruct rzg2l_pll5_param params;\n\tunsigned long parent_rate;\n\n\tparent_rate = rzg2l_cpg_get_foutpostdiv_rate(&params, rate);\n\n\tif (priv->mux_dsi_div_params.clksrc)\n\t\tparent_rate /= 2;\n\n\treturn parent_rate;\n}\n\nstatic int rzg2l_cpg_dsi_div_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t    struct clk_rate_request *req)\n{\n\tif (req->rate > MAX_VCLK_FREQ)\n\t\treq->rate = MAX_VCLK_FREQ;\n\n\treq->best_parent_rate = rzg2l_cpg_get_vclk_parent_rate(hw, req->rate);\n\n\treturn 0;\n}\n\nstatic int rzg2l_cpg_dsi_div_set_rate(struct clk_hw *hw,\n\t\t\t\t      unsigned long rate,\n\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct dsi_div_hw_data *dsi_div = to_dsi_div_hw_data(hw);\n\tstruct rzg2l_cpg_priv *priv = dsi_div->priv;\n\n\t \n\n\tif (!rate || rate > MAX_VCLK_FREQ)\n\t\treturn -EINVAL;\n\n\tdsi_div->rate = rate;\n\twritel(CPG_PL5_SDIV_DIV_DSI_A_WEN | CPG_PL5_SDIV_DIV_DSI_B_WEN |\n\t       (priv->mux_dsi_div_params.dsi_div_a << 0) |\n\t       (priv->mux_dsi_div_params.dsi_div_b << 8),\n\t       priv->base + CPG_PL5_SDIV);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops rzg2l_cpg_dsi_div_ops = {\n\t.recalc_rate = rzg2l_cpg_dsi_div_recalc_rate,\n\t.determine_rate = rzg2l_cpg_dsi_div_determine_rate,\n\t.set_rate = rzg2l_cpg_dsi_div_set_rate,\n};\n\nstatic struct clk * __init\nrzg2l_cpg_dsi_div_clk_register(const struct cpg_core_clk *core,\n\t\t\t       struct clk **clks,\n\t\t\t       struct rzg2l_cpg_priv *priv)\n{\n\tstruct dsi_div_hw_data *clk_hw_data;\n\tconst struct clk *parent;\n\tconst char *parent_name;\n\tstruct clk_init_data init;\n\tstruct clk_hw *clk_hw;\n\tint ret;\n\n\tparent = clks[core->parent & 0xffff];\n\tif (IS_ERR(parent))\n\t\treturn ERR_CAST(parent);\n\n\tclk_hw_data = devm_kzalloc(priv->dev, sizeof(*clk_hw_data), GFP_KERNEL);\n\tif (!clk_hw_data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk_hw_data->priv = priv;\n\n\tparent_name = __clk_get_name(parent);\n\tinit.name = core->name;\n\tinit.ops = &rzg2l_cpg_dsi_div_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tclk_hw = &clk_hw_data->hw;\n\tclk_hw->init = &init;\n\n\tret = devm_clk_hw_register(priv->dev, clk_hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn clk_hw->clk;\n}\n\nstruct pll5_mux_hw_data {\n\tstruct clk_hw hw;\n\tu32 conf;\n\tunsigned long rate;\n\tstruct rzg2l_cpg_priv *priv;\n};\n\n#define to_pll5_mux_hw_data(_hw)\tcontainer_of(_hw, struct pll5_mux_hw_data, hw)\n\nstatic int rzg2l_cpg_pll5_4_clk_mux_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t\t   struct clk_rate_request *req)\n{\n\tstruct clk_hw *parent;\n\tstruct pll5_mux_hw_data *hwdata = to_pll5_mux_hw_data(hw);\n\tstruct rzg2l_cpg_priv *priv = hwdata->priv;\n\n\tparent = clk_hw_get_parent_by_index(hw, priv->mux_dsi_div_params.clksrc);\n\treq->best_parent_hw = parent;\n\treq->best_parent_rate = req->rate;\n\n\treturn 0;\n}\n\nstatic int rzg2l_cpg_pll5_4_clk_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct pll5_mux_hw_data *hwdata = to_pll5_mux_hw_data(hw);\n\tstruct rzg2l_cpg_priv *priv = hwdata->priv;\n\n\t \n\n\twritel(CPG_OTHERFUNC1_REG_RES0_ON_WEN | index,\n\t       priv->base + CPG_OTHERFUNC1_REG);\n\n\treturn 0;\n}\n\nstatic u8 rzg2l_cpg_pll5_4_clk_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct pll5_mux_hw_data *hwdata = to_pll5_mux_hw_data(hw);\n\tstruct rzg2l_cpg_priv *priv = hwdata->priv;\n\n\treturn readl(priv->base + GET_REG_OFFSET(hwdata->conf));\n}\n\nstatic const struct clk_ops rzg2l_cpg_pll5_4_clk_mux_ops = {\n\t.determine_rate = rzg2l_cpg_pll5_4_clk_mux_determine_rate,\n\t.set_parent\t= rzg2l_cpg_pll5_4_clk_mux_set_parent,\n\t.get_parent\t= rzg2l_cpg_pll5_4_clk_mux_get_parent,\n};\n\nstatic struct clk * __init\nrzg2l_cpg_pll5_4_mux_clk_register(const struct cpg_core_clk *core,\n\t\t\t\t  struct rzg2l_cpg_priv *priv)\n{\n\tstruct pll5_mux_hw_data *clk_hw_data;\n\tstruct clk_init_data init;\n\tstruct clk_hw *clk_hw;\n\tint ret;\n\n\tclk_hw_data = devm_kzalloc(priv->dev, sizeof(*clk_hw_data), GFP_KERNEL);\n\tif (!clk_hw_data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk_hw_data->priv = priv;\n\tclk_hw_data->conf = core->conf;\n\n\tinit.name = core->name;\n\tinit.ops = &rzg2l_cpg_pll5_4_clk_mux_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.num_parents = core->num_parents;\n\tinit.parent_names = core->parent_names;\n\n\tclk_hw = &clk_hw_data->hw;\n\tclk_hw->init = &init;\n\n\tret = devm_clk_hw_register(priv->dev, clk_hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn clk_hw->clk;\n}\n\nstruct sipll5 {\n\tstruct clk_hw hw;\n\tu32 conf;\n\tunsigned long foutpostdiv_rate;\n\tstruct rzg2l_cpg_priv *priv;\n};\n\n#define to_sipll5(_hw)\tcontainer_of(_hw, struct sipll5, hw)\n\nstatic unsigned long rzg2l_cpg_get_vclk_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long rate)\n{\n\tstruct sipll5 *sipll5 = to_sipll5(hw);\n\tstruct rzg2l_cpg_priv *priv = sipll5->priv;\n\tunsigned long vclk;\n\n\tvclk = rate / ((1 << priv->mux_dsi_div_params.dsi_div_a) *\n\t\t       (priv->mux_dsi_div_params.dsi_div_b + 1));\n\n\tif (priv->mux_dsi_div_params.clksrc)\n\t\tvclk /= 2;\n\n\treturn vclk;\n}\n\nstatic unsigned long rzg2l_cpg_sipll5_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct sipll5 *sipll5 = to_sipll5(hw);\n\tunsigned long pll5_rate = sipll5->foutpostdiv_rate;\n\n\tif (!pll5_rate)\n\t\tpll5_rate = parent_rate;\n\n\treturn pll5_rate;\n}\n\nstatic long rzg2l_cpg_sipll5_round_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long rate,\n\t\t\t\t\tunsigned long *parent_rate)\n{\n\treturn rate;\n}\n\nstatic int rzg2l_cpg_sipll5_set_rate(struct clk_hw *hw,\n\t\t\t\t     unsigned long rate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct sipll5 *sipll5 = to_sipll5(hw);\n\tstruct rzg2l_cpg_priv *priv = sipll5->priv;\n\tstruct rzg2l_pll5_param params;\n\tunsigned long vclk_rate;\n\tint ret;\n\tu32 val;\n\n\t \n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\tvclk_rate = rzg2l_cpg_get_vclk_rate(hw, rate);\n\tsipll5->foutpostdiv_rate =\n\t\trzg2l_cpg_get_foutpostdiv_rate(&params, vclk_rate);\n\n\t \n\twritel(CPG_SIPLL5_STBY_RESETB_WEN, priv->base + CPG_SIPLL5_STBY);\n\tret = readl_poll_timeout(priv->base + CPG_SIPLL5_MON, val,\n\t\t\t\t !(val & CPG_SIPLL5_MON_PLL5_LOCK), 100, 250000);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to release pll5 lock\");\n\t\treturn ret;\n\t}\n\n\t \n\twritel((params.pl5_postdiv1 << 0) | (params.pl5_postdiv2 << 4) |\n\t       (params.pl5_refdiv << 8), priv->base + CPG_SIPLL5_CLK1);\n\n\t \n\twritel((params.pl5_fracin << 8), priv->base + CPG_SIPLL5_CLK3);\n\n\t \n\twritel(CPG_SIPLL5_CLK4_RESV_LSB | (params.pl5_intin << 16),\n\t       priv->base + CPG_SIPLL5_CLK4);\n\n\t \n\twritel(params.pl5_spread, priv->base + CPG_SIPLL5_CLK5);\n\n\t \n\twritel(CPG_SIPLL5_STBY_DOWNSPREAD_WEN | CPG_SIPLL5_STBY_SSCG_EN_WEN |\n\t       CPG_SIPLL5_STBY_RESETB_WEN | CPG_SIPLL5_STBY_RESETB,\n\t       priv->base + CPG_SIPLL5_STBY);\n\n\t \n\tret = readl_poll_timeout(priv->base + CPG_SIPLL5_MON, val,\n\t\t\t\t (val & CPG_SIPLL5_MON_PLL5_LOCK), 100, 250000);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to lock pll5\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct clk_ops rzg2l_cpg_sipll5_ops = {\n\t.recalc_rate = rzg2l_cpg_sipll5_recalc_rate,\n\t.round_rate = rzg2l_cpg_sipll5_round_rate,\n\t.set_rate = rzg2l_cpg_sipll5_set_rate,\n};\n\nstatic struct clk * __init\nrzg2l_cpg_sipll5_register(const struct cpg_core_clk *core,\n\t\t\t  struct clk **clks,\n\t\t\t  struct rzg2l_cpg_priv *priv)\n{\n\tconst struct clk *parent;\n\tstruct clk_init_data init;\n\tconst char *parent_name;\n\tstruct sipll5 *sipll5;\n\tstruct clk_hw *clk_hw;\n\tint ret;\n\n\tparent = clks[core->parent & 0xffff];\n\tif (IS_ERR(parent))\n\t\treturn ERR_CAST(parent);\n\n\tsipll5 = devm_kzalloc(priv->dev, sizeof(*sipll5), GFP_KERNEL);\n\tif (!sipll5)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = core->name;\n\tparent_name = __clk_get_name(parent);\n\tinit.ops = &rzg2l_cpg_sipll5_ops;\n\tinit.flags = 0;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tsipll5->hw.init = &init;\n\tsipll5->conf = core->conf;\n\tsipll5->priv = priv;\n\n\twritel(CPG_SIPLL5_STBY_SSCG_EN_WEN | CPG_SIPLL5_STBY_RESETB_WEN |\n\t       CPG_SIPLL5_STBY_RESETB, priv->base + CPG_SIPLL5_STBY);\n\n\tclk_hw = &sipll5->hw;\n\tclk_hw->init = &init;\n\n\tret = devm_clk_hw_register(priv->dev, clk_hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tpriv->mux_dsi_div_params.clksrc = 1;  \n\tpriv->mux_dsi_div_params.dsi_div_a = 1;  \n\tpriv->mux_dsi_div_params.dsi_div_b = 2;  \n\n\treturn clk_hw->clk;\n}\n\nstruct pll_clk {\n\tstruct clk_hw hw;\n\tunsigned int conf;\n\tunsigned int type;\n\tvoid __iomem *base;\n\tstruct rzg2l_cpg_priv *priv;\n};\n\n#define to_pll(_hw)\tcontainer_of(_hw, struct pll_clk, hw)\n\nstatic unsigned long rzg2l_cpg_pll_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct pll_clk *pll_clk = to_pll(hw);\n\tstruct rzg2l_cpg_priv *priv = pll_clk->priv;\n\tunsigned int val1, val2;\n\tu64 rate;\n\n\tif (pll_clk->type != CLK_TYPE_SAM_PLL)\n\t\treturn parent_rate;\n\n\tval1 = readl(priv->base + GET_REG_SAMPLL_CLK1(pll_clk->conf));\n\tval2 = readl(priv->base + GET_REG_SAMPLL_CLK2(pll_clk->conf));\n\n\trate = mul_u64_u32_shr(parent_rate, (MDIV(val1) << 16) + KDIV(val1),\n\t\t\t       16 + SDIV(val2));\n\n\treturn DIV_ROUND_CLOSEST_ULL(rate, PDIV(val1));\n}\n\nstatic const struct clk_ops rzg2l_cpg_pll_ops = {\n\t.recalc_rate = rzg2l_cpg_pll_clk_recalc_rate,\n};\n\nstatic struct clk * __init\nrzg2l_cpg_pll_clk_register(const struct cpg_core_clk *core,\n\t\t\t   struct clk **clks,\n\t\t\t   void __iomem *base,\n\t\t\t   struct rzg2l_cpg_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\tconst struct clk *parent;\n\tstruct clk_init_data init;\n\tconst char *parent_name;\n\tstruct pll_clk *pll_clk;\n\n\tparent = clks[core->parent & 0xffff];\n\tif (IS_ERR(parent))\n\t\treturn ERR_CAST(parent);\n\n\tpll_clk = devm_kzalloc(dev, sizeof(*pll_clk), GFP_KERNEL);\n\tif (!pll_clk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tparent_name = __clk_get_name(parent);\n\tinit.name = core->name;\n\tinit.ops = &rzg2l_cpg_pll_ops;\n\tinit.flags = 0;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tpll_clk->hw.init = &init;\n\tpll_clk->conf = core->conf;\n\tpll_clk->base = base;\n\tpll_clk->priv = priv;\n\tpll_clk->type = core->type;\n\n\treturn clk_register(NULL, &pll_clk->hw);\n}\n\nstatic struct clk\n*rzg2l_cpg_clk_src_twocell_get(struct of_phandle_args *clkspec,\n\t\t\t       void *data)\n{\n\tunsigned int clkidx = clkspec->args[1];\n\tstruct rzg2l_cpg_priv *priv = data;\n\tstruct device *dev = priv->dev;\n\tconst char *type;\n\tstruct clk *clk;\n\n\tswitch (clkspec->args[0]) {\n\tcase CPG_CORE:\n\t\ttype = \"core\";\n\t\tif (clkidx > priv->last_dt_core_clk) {\n\t\t\tdev_err(dev, \"Invalid %s clock index %u\\n\", type, clkidx);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tclk = priv->clks[clkidx];\n\t\tbreak;\n\n\tcase CPG_MOD:\n\t\ttype = \"module\";\n\t\tif (clkidx >= priv->num_mod_clks) {\n\t\t\tdev_err(dev, \"Invalid %s clock index %u\\n\", type,\n\t\t\t\tclkidx);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tclk = priv->clks[priv->num_core_clks + clkidx];\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid CPG clock type %u\\n\", clkspec->args[0]);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (IS_ERR(clk))\n\t\tdev_err(dev, \"Cannot get %s clock %u: %ld\", type, clkidx,\n\t\t\tPTR_ERR(clk));\n\telse\n\t\tdev_dbg(dev, \"clock (%u, %u) is %pC at %lu Hz\\n\",\n\t\t\tclkspec->args[0], clkspec->args[1], clk,\n\t\t\tclk_get_rate(clk));\n\treturn clk;\n}\n\nstatic void __init\nrzg2l_cpg_register_core_clk(const struct cpg_core_clk *core,\n\t\t\t    const struct rzg2l_cpg_info *info,\n\t\t\t    struct rzg2l_cpg_priv *priv)\n{\n\tstruct clk *clk = ERR_PTR(-EOPNOTSUPP), *parent;\n\tstruct device *dev = priv->dev;\n\tunsigned int id = core->id, div = core->div;\n\tconst char *parent_name;\n\n\tWARN_DEBUG(id >= priv->num_core_clks);\n\tWARN_DEBUG(PTR_ERR(priv->clks[id]) != -ENOENT);\n\n\tif (!core->name) {\n\t\t \n\t\treturn;\n\t}\n\n\tswitch (core->type) {\n\tcase CLK_TYPE_IN:\n\t\tclk = of_clk_get_by_name(priv->dev->of_node, core->name);\n\t\tbreak;\n\tcase CLK_TYPE_FF:\n\t\tWARN_DEBUG(core->parent >= priv->num_core_clks);\n\t\tparent = priv->clks[core->parent];\n\t\tif (IS_ERR(parent)) {\n\t\t\tclk = parent;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tparent_name = __clk_get_name(parent);\n\t\tclk = clk_register_fixed_factor(NULL, core->name,\n\t\t\t\t\t\tparent_name, CLK_SET_RATE_PARENT,\n\t\t\t\t\t\tcore->mult, div);\n\t\tbreak;\n\tcase CLK_TYPE_SAM_PLL:\n\t\tclk = rzg2l_cpg_pll_clk_register(core, priv->clks,\n\t\t\t\t\t\t priv->base, priv);\n\t\tbreak;\n\tcase CLK_TYPE_SIPLL5:\n\t\tclk = rzg2l_cpg_sipll5_register(core, priv->clks, priv);\n\t\tbreak;\n\tcase CLK_TYPE_DIV:\n\t\tclk = rzg2l_cpg_div_clk_register(core, priv->clks,\n\t\t\t\t\t\t priv->base, priv);\n\t\tbreak;\n\tcase CLK_TYPE_MUX:\n\t\tclk = rzg2l_cpg_mux_clk_register(core, priv->base, priv);\n\t\tbreak;\n\tcase CLK_TYPE_SD_MUX:\n\t\tclk = rzg2l_cpg_sd_mux_clk_register(core, priv->base, priv);\n\t\tbreak;\n\tcase CLK_TYPE_PLL5_4_MUX:\n\t\tclk = rzg2l_cpg_pll5_4_mux_clk_register(core, priv);\n\t\tbreak;\n\tcase CLK_TYPE_DSI_DIV:\n\t\tclk = rzg2l_cpg_dsi_div_clk_register(core, priv->clks, priv);\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\n\tif (IS_ERR_OR_NULL(clk))\n\t\tgoto fail;\n\n\tdev_dbg(dev, \"Core clock %pC at %lu Hz\\n\", clk, clk_get_rate(clk));\n\tpriv->clks[id] = clk;\n\treturn;\n\nfail:\n\tdev_err(dev, \"Failed to register %s clock %s: %ld\\n\", \"core\",\n\t\tcore->name, PTR_ERR(clk));\n}\n\n \nstruct mstp_clock {\n\tstruct clk_hw hw;\n\tu16 off;\n\tu8 bit;\n\tbool enabled;\n\tstruct rzg2l_cpg_priv *priv;\n\tstruct mstp_clock *sibling;\n};\n\n#define to_mod_clock(_hw) container_of(_hw, struct mstp_clock, hw)\n\nstatic int rzg2l_mod_clock_endisable(struct clk_hw *hw, bool enable)\n{\n\tstruct mstp_clock *clock = to_mod_clock(hw);\n\tstruct rzg2l_cpg_priv *priv = clock->priv;\n\tunsigned int reg = clock->off;\n\tstruct device *dev = priv->dev;\n\tunsigned long flags;\n\tu32 bitmask = BIT(clock->bit);\n\tu32 value;\n\tint error;\n\n\tif (!clock->off) {\n\t\tdev_dbg(dev, \"%pC does not support ON/OFF\\n\",  hw->clk);\n\t\treturn 0;\n\t}\n\n\tdev_dbg(dev, \"CLK_ON %u/%pC %s\\n\", CLK_ON_R(reg), hw->clk,\n\t\tenable ? \"ON\" : \"OFF\");\n\tspin_lock_irqsave(&priv->rmw_lock, flags);\n\n\tif (enable)\n\t\tvalue = (bitmask << 16) | bitmask;\n\telse\n\t\tvalue = bitmask << 16;\n\twritel(value, priv->base + CLK_ON_R(reg));\n\n\tspin_unlock_irqrestore(&priv->rmw_lock, flags);\n\n\tif (!enable)\n\t\treturn 0;\n\n\tif (!priv->info->has_clk_mon_regs)\n\t\treturn 0;\n\n\terror = readl_poll_timeout_atomic(priv->base + CLK_MON_R(reg), value,\n\t\t\t\t\t  value & bitmask, 0, 10);\n\tif (error)\n\t\tdev_err(dev, \"Failed to enable CLK_ON %p\\n\",\n\t\t\tpriv->base + CLK_ON_R(reg));\n\n\treturn error;\n}\n\nstatic int rzg2l_mod_clock_enable(struct clk_hw *hw)\n{\n\tstruct mstp_clock *clock = to_mod_clock(hw);\n\n\tif (clock->sibling) {\n\t\tstruct rzg2l_cpg_priv *priv = clock->priv;\n\t\tunsigned long flags;\n\t\tbool enabled;\n\n\t\tspin_lock_irqsave(&priv->rmw_lock, flags);\n\t\tenabled = clock->sibling->enabled;\n\t\tclock->enabled = true;\n\t\tspin_unlock_irqrestore(&priv->rmw_lock, flags);\n\t\tif (enabled)\n\t\t\treturn 0;\n\t}\n\n\treturn rzg2l_mod_clock_endisable(hw, true);\n}\n\nstatic void rzg2l_mod_clock_disable(struct clk_hw *hw)\n{\n\tstruct mstp_clock *clock = to_mod_clock(hw);\n\n\tif (clock->sibling) {\n\t\tstruct rzg2l_cpg_priv *priv = clock->priv;\n\t\tunsigned long flags;\n\t\tbool enabled;\n\n\t\tspin_lock_irqsave(&priv->rmw_lock, flags);\n\t\tenabled = clock->sibling->enabled;\n\t\tclock->enabled = false;\n\t\tspin_unlock_irqrestore(&priv->rmw_lock, flags);\n\t\tif (enabled)\n\t\t\treturn;\n\t}\n\n\trzg2l_mod_clock_endisable(hw, false);\n}\n\nstatic int rzg2l_mod_clock_is_enabled(struct clk_hw *hw)\n{\n\tstruct mstp_clock *clock = to_mod_clock(hw);\n\tstruct rzg2l_cpg_priv *priv = clock->priv;\n\tu32 bitmask = BIT(clock->bit);\n\tu32 value;\n\n\tif (!clock->off) {\n\t\tdev_dbg(priv->dev, \"%pC does not support ON/OFF\\n\",  hw->clk);\n\t\treturn 1;\n\t}\n\n\tif (clock->sibling)\n\t\treturn clock->enabled;\n\n\tif (priv->info->has_clk_mon_regs)\n\t\tvalue = readl(priv->base + CLK_MON_R(clock->off));\n\telse\n\t\tvalue = readl(priv->base + clock->off);\n\n\treturn value & bitmask;\n}\n\nstatic const struct clk_ops rzg2l_mod_clock_ops = {\n\t.enable = rzg2l_mod_clock_enable,\n\t.disable = rzg2l_mod_clock_disable,\n\t.is_enabled = rzg2l_mod_clock_is_enabled,\n};\n\nstatic struct mstp_clock\n*rzg2l_mod_clock_get_sibling(struct mstp_clock *clock,\n\t\t\t     struct rzg2l_cpg_priv *priv)\n{\n\tstruct clk_hw *hw;\n\tunsigned int i;\n\n\tfor (i = 0; i < priv->num_mod_clks; i++) {\n\t\tstruct mstp_clock *clk;\n\n\t\tif (priv->clks[priv->num_core_clks + i] == ERR_PTR(-ENOENT))\n\t\t\tcontinue;\n\n\t\thw = __clk_get_hw(priv->clks[priv->num_core_clks + i]);\n\t\tclk = to_mod_clock(hw);\n\t\tif (clock->off == clk->off && clock->bit == clk->bit)\n\t\t\treturn clk;\n\t}\n\n\treturn NULL;\n}\n\nstatic void __init\nrzg2l_cpg_register_mod_clk(const struct rzg2l_mod_clk *mod,\n\t\t\t   const struct rzg2l_cpg_info *info,\n\t\t\t   struct rzg2l_cpg_priv *priv)\n{\n\tstruct mstp_clock *clock = NULL;\n\tstruct device *dev = priv->dev;\n\tunsigned int id = mod->id;\n\tstruct clk_init_data init;\n\tstruct clk *parent, *clk;\n\tconst char *parent_name;\n\tunsigned int i;\n\n\tWARN_DEBUG(id < priv->num_core_clks);\n\tWARN_DEBUG(id >= priv->num_core_clks + priv->num_mod_clks);\n\tWARN_DEBUG(mod->parent >= priv->num_core_clks + priv->num_mod_clks);\n\tWARN_DEBUG(PTR_ERR(priv->clks[id]) != -ENOENT);\n\n\tif (!mod->name) {\n\t\t \n\t\treturn;\n\t}\n\n\tparent = priv->clks[mod->parent];\n\tif (IS_ERR(parent)) {\n\t\tclk = parent;\n\t\tgoto fail;\n\t}\n\n\tclock = devm_kzalloc(dev, sizeof(*clock), GFP_KERNEL);\n\tif (!clock) {\n\t\tclk = ERR_PTR(-ENOMEM);\n\t\tgoto fail;\n\t}\n\n\tinit.name = mod->name;\n\tinit.ops = &rzg2l_mod_clock_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tfor (i = 0; i < info->num_crit_mod_clks; i++)\n\t\tif (id == info->crit_mod_clks[i]) {\n\t\t\tdev_dbg(dev, \"CPG %s setting CLK_IS_CRITICAL\\n\",\n\t\t\t\tmod->name);\n\t\t\tinit.flags |= CLK_IS_CRITICAL;\n\t\t\tbreak;\n\t\t}\n\n\tparent_name = __clk_get_name(parent);\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tclock->off = mod->off;\n\tclock->bit = mod->bit;\n\tclock->priv = priv;\n\tclock->hw.init = &init;\n\n\tclk = clk_register(NULL, &clock->hw);\n\tif (IS_ERR(clk))\n\t\tgoto fail;\n\n\tdev_dbg(dev, \"Module clock %pC at %lu Hz\\n\", clk, clk_get_rate(clk));\n\tpriv->clks[id] = clk;\n\n\tif (mod->is_coupled) {\n\t\tstruct mstp_clock *sibling;\n\n\t\tclock->enabled = rzg2l_mod_clock_is_enabled(&clock->hw);\n\t\tsibling = rzg2l_mod_clock_get_sibling(clock, priv);\n\t\tif (sibling) {\n\t\t\tclock->sibling = sibling;\n\t\t\tsibling->sibling = clock;\n\t\t}\n\t}\n\n\treturn;\n\nfail:\n\tdev_err(dev, \"Failed to register %s clock %s: %ld\\n\", \"module\",\n\t\tmod->name, PTR_ERR(clk));\n}\n\n#define rcdev_to_priv(x)\tcontainer_of(x, struct rzg2l_cpg_priv, rcdev)\n\nstatic int rzg2l_cpg_assert(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long id)\n{\n\tstruct rzg2l_cpg_priv *priv = rcdev_to_priv(rcdev);\n\tconst struct rzg2l_cpg_info *info = priv->info;\n\tunsigned int reg = info->resets[id].off;\n\tu32 mask = BIT(info->resets[id].bit);\n\ts8 monbit = info->resets[id].monbit;\n\tu32 value = mask << 16;\n\n\tdev_dbg(rcdev->dev, \"assert id:%ld offset:0x%x\\n\", id, CLK_RST_R(reg));\n\n\twritel(value, priv->base + CLK_RST_R(reg));\n\n\tif (info->has_clk_mon_regs) {\n\t\treg = CLK_MRST_R(reg);\n\t} else if (monbit >= 0) {\n\t\treg = CPG_RST_MON;\n\t\tmask = BIT(monbit);\n\t} else {\n\t\t \n\t\tudelay(35);\n\t\treturn 0;\n\t}\n\n\treturn readl_poll_timeout_atomic(priv->base + reg, value,\n\t\t\t\t\t value & mask, 10, 200);\n}\n\nstatic int rzg2l_cpg_deassert(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct rzg2l_cpg_priv *priv = rcdev_to_priv(rcdev);\n\tconst struct rzg2l_cpg_info *info = priv->info;\n\tunsigned int reg = info->resets[id].off;\n\tu32 mask = BIT(info->resets[id].bit);\n\ts8 monbit = info->resets[id].monbit;\n\tu32 value = (mask << 16) | mask;\n\n\tdev_dbg(rcdev->dev, \"deassert id:%ld offset:0x%x\\n\", id,\n\t\tCLK_RST_R(reg));\n\n\twritel(value, priv->base + CLK_RST_R(reg));\n\n\tif (info->has_clk_mon_regs) {\n\t\treg = CLK_MRST_R(reg);\n\t} else if (monbit >= 0) {\n\t\treg = CPG_RST_MON;\n\t\tmask = BIT(monbit);\n\t} else {\n\t\t \n\t\tudelay(35);\n\t\treturn 0;\n\t}\n\n\treturn readl_poll_timeout_atomic(priv->base + reg, value,\n\t\t\t\t\t !(value & mask), 10, 200);\n}\n\nstatic int rzg2l_cpg_reset(struct reset_controller_dev *rcdev,\n\t\t\t   unsigned long id)\n{\n\tint ret;\n\n\tret = rzg2l_cpg_assert(rcdev, id);\n\tif (ret)\n\t\treturn ret;\n\n\treturn rzg2l_cpg_deassert(rcdev, id);\n}\n\nstatic int rzg2l_cpg_status(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long id)\n{\n\tstruct rzg2l_cpg_priv *priv = rcdev_to_priv(rcdev);\n\tconst struct rzg2l_cpg_info *info = priv->info;\n\ts8 monbit = info->resets[id].monbit;\n\tunsigned int reg;\n\tu32 bitmask;\n\n\tif (info->has_clk_mon_regs) {\n\t\treg = CLK_MRST_R(info->resets[id].off);\n\t\tbitmask = BIT(info->resets[id].bit);\n\t} else if (monbit >= 0) {\n\t\treg = CPG_RST_MON;\n\t\tbitmask = BIT(monbit);\n\t} else {\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn !!(readl(priv->base + reg) & bitmask);\n}\n\nstatic const struct reset_control_ops rzg2l_cpg_reset_ops = {\n\t.reset = rzg2l_cpg_reset,\n\t.assert = rzg2l_cpg_assert,\n\t.deassert = rzg2l_cpg_deassert,\n\t.status = rzg2l_cpg_status,\n};\n\nstatic int rzg2l_cpg_reset_xlate(struct reset_controller_dev *rcdev,\n\t\t\t\t const struct of_phandle_args *reset_spec)\n{\n\tstruct rzg2l_cpg_priv *priv = rcdev_to_priv(rcdev);\n\tconst struct rzg2l_cpg_info *info = priv->info;\n\tunsigned int id = reset_spec->args[0];\n\n\tif (id >= rcdev->nr_resets || !info->resets[id].off) {\n\t\tdev_err(rcdev->dev, \"Invalid reset index %u\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn id;\n}\n\nstatic int rzg2l_cpg_reset_controller_register(struct rzg2l_cpg_priv *priv)\n{\n\tpriv->rcdev.ops = &rzg2l_cpg_reset_ops;\n\tpriv->rcdev.of_node = priv->dev->of_node;\n\tpriv->rcdev.dev = priv->dev;\n\tpriv->rcdev.of_reset_n_cells = 1;\n\tpriv->rcdev.of_xlate = rzg2l_cpg_reset_xlate;\n\tpriv->rcdev.nr_resets = priv->num_resets;\n\n\treturn devm_reset_controller_register(priv->dev, &priv->rcdev);\n}\n\nstatic bool rzg2l_cpg_is_pm_clk(struct rzg2l_cpg_priv *priv,\n\t\t\t\tconst struct of_phandle_args *clkspec)\n{\n\tconst struct rzg2l_cpg_info *info = priv->info;\n\tunsigned int id;\n\tunsigned int i;\n\n\tif (clkspec->args_count != 2)\n\t\treturn false;\n\n\tif (clkspec->args[0] != CPG_MOD)\n\t\treturn false;\n\n\tid = clkspec->args[1] + info->num_total_core_clks;\n\tfor (i = 0; i < info->num_no_pm_mod_clks; i++) {\n\t\tif (info->no_pm_mod_clks[i] == id)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int rzg2l_cpg_attach_dev(struct generic_pm_domain *domain, struct device *dev)\n{\n\tstruct rzg2l_cpg_priv *priv = container_of(domain, struct rzg2l_cpg_priv, genpd);\n\tstruct device_node *np = dev->of_node;\n\tstruct of_phandle_args clkspec;\n\tbool once = true;\n\tstruct clk *clk;\n\tint error;\n\tint i = 0;\n\n\twhile (!of_parse_phandle_with_args(np, \"clocks\", \"#clock-cells\", i,\n\t\t\t\t\t   &clkspec)) {\n\t\tif (rzg2l_cpg_is_pm_clk(priv, &clkspec)) {\n\t\t\tif (once) {\n\t\t\t\tonce = false;\n\t\t\t\terror = pm_clk_create(dev);\n\t\t\t\tif (error) {\n\t\t\t\t\tof_node_put(clkspec.np);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tclk = of_clk_get_from_provider(&clkspec);\n\t\t\tof_node_put(clkspec.np);\n\t\t\tif (IS_ERR(clk)) {\n\t\t\t\terror = PTR_ERR(clk);\n\t\t\t\tgoto fail_destroy;\n\t\t\t}\n\n\t\t\terror = pm_clk_add_clk(dev, clk);\n\t\t\tif (error) {\n\t\t\t\tdev_err(dev, \"pm_clk_add_clk failed %d\\n\",\n\t\t\t\t\terror);\n\t\t\t\tgoto fail_put;\n\t\t\t}\n\t\t} else {\n\t\t\tof_node_put(clkspec.np);\n\t\t}\n\t\ti++;\n\t}\n\n\treturn 0;\n\nfail_put:\n\tclk_put(clk);\n\nfail_destroy:\n\tpm_clk_destroy(dev);\nerr:\n\treturn error;\n}\n\nstatic void rzg2l_cpg_detach_dev(struct generic_pm_domain *unused, struct device *dev)\n{\n\tif (!pm_clk_no_clocks(dev))\n\t\tpm_clk_destroy(dev);\n}\n\nstatic void rzg2l_cpg_genpd_remove(void *data)\n{\n\tpm_genpd_remove(data);\n}\n\nstatic int __init rzg2l_cpg_add_clk_domain(struct rzg2l_cpg_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct generic_pm_domain *genpd = &priv->genpd;\n\tint ret;\n\n\tgenpd->name = np->name;\n\tgenpd->flags = GENPD_FLAG_PM_CLK | GENPD_FLAG_ALWAYS_ON |\n\t\t       GENPD_FLAG_ACTIVE_WAKEUP;\n\tgenpd->attach_dev = rzg2l_cpg_attach_dev;\n\tgenpd->detach_dev = rzg2l_cpg_detach_dev;\n\tret = pm_genpd_init(genpd, &pm_domain_always_on_gov, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, rzg2l_cpg_genpd_remove, genpd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn of_genpd_add_provider_simple(np, genpd);\n}\n\nstatic int __init rzg2l_cpg_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst struct rzg2l_cpg_info *info;\n\tstruct rzg2l_cpg_priv *priv;\n\tunsigned int nclks, i;\n\tstruct clk **clks;\n\tint error;\n\n\tinfo = of_device_get_match_data(dev);\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->info = info;\n\tspin_lock_init(&priv->rmw_lock);\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tnclks = info->num_total_core_clks + info->num_hw_mod_clks;\n\tclks = devm_kmalloc_array(dev, nclks, sizeof(*clks), GFP_KERNEL);\n\tif (!clks)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, priv);\n\tpriv->clks = clks;\n\tpriv->num_core_clks = info->num_total_core_clks;\n\tpriv->num_mod_clks = info->num_hw_mod_clks;\n\tpriv->num_resets = info->num_resets;\n\tpriv->last_dt_core_clk = info->last_dt_core_clk;\n\n\tfor (i = 0; i < nclks; i++)\n\t\tclks[i] = ERR_PTR(-ENOENT);\n\n\tfor (i = 0; i < info->num_core_clks; i++)\n\t\trzg2l_cpg_register_core_clk(&info->core_clks[i], info, priv);\n\n\tfor (i = 0; i < info->num_mod_clks; i++)\n\t\trzg2l_cpg_register_mod_clk(&info->mod_clks[i], info, priv);\n\n\terror = of_clk_add_provider(np, rzg2l_cpg_clk_src_twocell_get, priv);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_add_action_or_reset(dev, rzg2l_cpg_del_clk_provider, np);\n\tif (error)\n\t\treturn error;\n\n\terror = rzg2l_cpg_add_clk_domain(priv);\n\tif (error)\n\t\treturn error;\n\n\terror = rzg2l_cpg_reset_controller_register(priv);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rzg2l_cpg_match[] = {\n#ifdef CONFIG_CLK_R9A07G043\n\t{\n\t\t.compatible = \"renesas,r9a07g043-cpg\",\n\t\t.data = &r9a07g043_cpg_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R9A07G044\n\t{\n\t\t.compatible = \"renesas,r9a07g044-cpg\",\n\t\t.data = &r9a07g044_cpg_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R9A07G054\n\t{\n\t\t.compatible = \"renesas,r9a07g054-cpg\",\n\t\t.data = &r9a07g054_cpg_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R9A09G011\n\t{\n\t\t.compatible = \"renesas,r9a09g011-cpg\",\n\t\t.data = &r9a09g011_cpg_info,\n\t},\n#endif\n\t{   }\n};\n\nstatic struct platform_driver rzg2l_cpg_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rzg2l-cpg\",\n\t\t.of_match_table = rzg2l_cpg_match,\n\t},\n};\n\nstatic int __init rzg2l_cpg_init(void)\n{\n\treturn platform_driver_probe(&rzg2l_cpg_driver, rzg2l_cpg_probe);\n}\n\nsubsys_initcall(rzg2l_cpg_init);\n\nMODULE_DESCRIPTION(\"Renesas RZ/G2L CPG Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}