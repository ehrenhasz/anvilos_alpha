{
  "module_name": "clk-rz.c",
  "hash_id": "846f67f7178ccf83f8d578d7c89433d9c9cfe4be59a0e7786e3d3bf9454d045a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/renesas/clk-rz.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk/renesas.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n\n#define CPG_FRQCR\t0x10\n#define CPG_FRQCR2\t0x14\n\n#define PPR0\t\t0xFCFE3200\n#define PIBC0\t\t0xFCFE7000\n\n#define MD_CLK(x)\t((x >> 2) & 1)\t \n\n \n\nstatic u16 __init rz_cpg_read_mode_pins(void)\n{\n\tvoid __iomem *ppr0, *pibc0;\n\tu16 modes;\n\n\tppr0 = ioremap(PPR0, 2);\n\tpibc0 = ioremap(PIBC0, 2);\n\tBUG_ON(!ppr0 || !pibc0);\n\tiowrite16(4, pibc0);\t \n\tmodes = ioread16(ppr0);\n\tiounmap(ppr0);\n\tiounmap(pibc0);\n\n\treturn modes;\n}\n\nstatic struct clk * __init\nrz_cpg_register_clock(struct device_node *np, void __iomem *base,\n\t\t      const char *name)\n{\n\tu32 val;\n\tunsigned mult;\n\tstatic const unsigned frqcr_tab[4] = { 3, 2, 0, 1 };\n\n\tif (strcmp(name, \"pll\") == 0) {\n\t\tunsigned int cpg_mode = MD_CLK(rz_cpg_read_mode_pins());\n\t\tconst char *parent_name = of_clk_get_parent_name(np, cpg_mode);\n\n\t\tmult = cpg_mode ? (32 / 4) : 30;\n\n\t\treturn clk_register_fixed_factor(NULL, name, parent_name, 0, mult, 1);\n\t}\n\n\t \n\tif (!base)\n\t\treturn ERR_PTR(-ENXIO);\n\n\t \n\tif (strcmp(name, \"i\") == 0)\n\t\tval = (readl(base + CPG_FRQCR) >> 8) & 3;\n\telse if (strcmp(name, \"g\") == 0)\n\t\tval = readl(base + CPG_FRQCR2) & 3;\n\telse\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmult = frqcr_tab[val];\n\treturn clk_register_fixed_factor(NULL, name, \"pll\", 0, mult, 3);\n}\n\nstatic void __init rz_cpg_clocks_init(struct device_node *np)\n{\n\tstruct clk_onecell_data *data;\n\tstruct clk **clks;\n\tvoid __iomem *base;\n\tunsigned i;\n\tint num_clks;\n\n\tnum_clks = of_property_count_strings(np, \"clock-output-names\");\n\tif (WARN(num_clks <= 0, \"can't count CPG clocks\\n\"))\n\t\treturn;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tclks = kcalloc(num_clks, sizeof(*clks), GFP_KERNEL);\n\tBUG_ON(!data || !clks);\n\n\tdata->clks = clks;\n\tdata->clk_num = num_clks;\n\n\tbase = of_iomap(np, 0);\n\n\tfor (i = 0; i < num_clks; ++i) {\n\t\tconst char *name;\n\t\tstruct clk *clk;\n\n\t\tof_property_read_string_index(np, \"clock-output-names\", i, &name);\n\n\t\tclk = rz_cpg_register_clock(np, base, name);\n\t\tif (IS_ERR(clk))\n\t\t\tpr_err(\"%s: failed to register %pOFn %s clock (%ld)\\n\",\n\t\t\t       __func__, np, name, PTR_ERR(clk));\n\t\telse\n\t\t\tdata->clks[i] = clk;\n\t}\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, data);\n\n\tcpg_mstp_add_clk_domain(np);\n}\nCLK_OF_DECLARE(rz_cpg_clks, \"renesas,rz-cpg-clocks\", rz_cpg_clocks_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}