{
  "module_name": "renesas-cpg-mssr.c",
  "hash_id": "0cd0c6619f274951535bc9ae843476ece8fd34b3820834c99aa73f9bcc929efa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/renesas/renesas-cpg-mssr.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clk/renesas.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_domain.h>\n#include <linux/psci.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/clock/renesas-cpg-mssr.h>\n\n#include \"renesas-cpg-mssr.h\"\n#include \"clk-div6.h\"\n\n#ifdef DEBUG\n#define WARN_DEBUG(x)\tWARN_ON(x)\n#else\n#define WARN_DEBUG(x)\tdo { } while (0)\n#endif\n\n\n \n\n \n\nstatic const u16 mstpsr[] = {\n\t0x030, 0x038, 0x040, 0x048, 0x04C, 0x03C, 0x1C0, 0x1C4,\n\t0x9A0, 0x9A4, 0x9A8, 0x9AC,\n};\n\nstatic const u16 mstpsr_for_gen4[] = {\n\t0x2E00, 0x2E04, 0x2E08, 0x2E0C, 0x2E10, 0x2E14, 0x2E18, 0x2E1C,\n\t0x2E20, 0x2E24, 0x2E28, 0x2E2C, 0x2E30, 0x2E34, 0x2E38, 0x2E3C,\n\t0x2E40, 0x2E44, 0x2E48, 0x2E4C, 0x2E50, 0x2E54, 0x2E58, 0x2E5C,\n\t0x2E60, 0x2E64, 0x2E68, 0x2E6C, 0x2E70, 0x2E74,\n};\n\n \n\nstatic const u16 smstpcr[] = {\n\t0x130, 0x134, 0x138, 0x13C, 0x140, 0x144, 0x148, 0x14C,\n\t0x990, 0x994, 0x998, 0x99C,\n};\n\nstatic const u16 mstpcr_for_gen4[] = {\n\t0x2D00, 0x2D04, 0x2D08, 0x2D0C, 0x2D10, 0x2D14, 0x2D18, 0x2D1C,\n\t0x2D20, 0x2D24, 0x2D28, 0x2D2C, 0x2D30, 0x2D34, 0x2D38, 0x2D3C,\n\t0x2D40, 0x2D44, 0x2D48, 0x2D4C, 0x2D50, 0x2D54, 0x2D58, 0x2D5C,\n\t0x2D60, 0x2D64, 0x2D68, 0x2D6C, 0x2D70, 0x2D74,\n};\n\n \n\nstatic const u16 stbcr[] = {\n\t0xFFFF , 0x010, 0x014, 0x410, 0x414, 0x418, 0x41C, 0x420,\n\t0x424, 0x428, 0x42C,\n};\n\n \n\nstatic const u16 srcr[] = {\n\t0x0A0, 0x0A8, 0x0B0, 0x0B8, 0x0BC, 0x0C4, 0x1C8, 0x1CC,\n\t0x920, 0x924, 0x928, 0x92C,\n};\n\nstatic const u16 srcr_for_gen4[] = {\n\t0x2C00, 0x2C04, 0x2C08, 0x2C0C, 0x2C10, 0x2C14, 0x2C18, 0x2C1C,\n\t0x2C20, 0x2C24, 0x2C28, 0x2C2C, 0x2C30, 0x2C34, 0x2C38, 0x2C3C,\n\t0x2C40, 0x2C44, 0x2C48, 0x2C4C, 0x2C50, 0x2C54, 0x2C58, 0x2C5C,\n\t0x2C60, 0x2C64, 0x2C68, 0x2C6C, 0x2C70, 0x2C74,\n};\n\n \n\nstatic const u16 srstclr[] = {\n\t0x940, 0x944, 0x948, 0x94C, 0x950, 0x954, 0x958, 0x95C,\n\t0x960, 0x964, 0x968, 0x96C,\n};\n\nstatic const u16 srstclr_for_gen4[] = {\n\t0x2C80, 0x2C84, 0x2C88, 0x2C8C, 0x2C90, 0x2C94, 0x2C98, 0x2C9C,\n\t0x2CA0, 0x2CA4, 0x2CA8, 0x2CAC, 0x2CB0, 0x2CB4, 0x2CB8, 0x2CBC,\n\t0x2CC0, 0x2CC4, 0x2CC8, 0x2CCC, 0x2CD0, 0x2CD4, 0x2CD8, 0x2CDC,\n\t0x2CE0, 0x2CE4, 0x2CE8, 0x2CEC, 0x2CF0, 0x2CF4,\n};\n\n \nstruct cpg_mssr_priv {\n#ifdef CONFIG_RESET_CONTROLLER\n\tstruct reset_controller_dev rcdev;\n#endif\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tenum clk_reg_layout reg_layout;\n\tspinlock_t rmw_lock;\n\tstruct device_node *np;\n\n\tunsigned int num_core_clks;\n\tunsigned int num_mod_clks;\n\tunsigned int last_dt_core_clk;\n\n\tstruct raw_notifier_head notifiers;\n\tconst u16 *status_regs;\n\tconst u16 *control_regs;\n\tconst u16 *reset_regs;\n\tconst u16 *reset_clear_regs;\n\tstruct {\n\t\tu32 mask;\n\t\tu32 val;\n\t} smstpcr_saved[ARRAY_SIZE(mstpsr_for_gen4)];\n\n\tstruct clk *clks[];\n};\n\nstatic struct cpg_mssr_priv *cpg_mssr_priv;\n\n \nstruct mstp_clock {\n\tstruct clk_hw hw;\n\tu32 index;\n\tstruct cpg_mssr_priv *priv;\n};\n\n#define to_mstp_clock(_hw) container_of(_hw, struct mstp_clock, hw)\n\nstatic int cpg_mstp_clock_endisable(struct clk_hw *hw, bool enable)\n{\n\tstruct mstp_clock *clock = to_mstp_clock(hw);\n\tstruct cpg_mssr_priv *priv = clock->priv;\n\tunsigned int reg = clock->index / 32;\n\tunsigned int bit = clock->index % 32;\n\tstruct device *dev = priv->dev;\n\tu32 bitmask = BIT(bit);\n\tunsigned long flags;\n\tu32 value;\n\tint error;\n\n\tdev_dbg(dev, \"MSTP %u%02u/%pC %s\\n\", reg, bit, hw->clk,\n\t\tenable ? \"ON\" : \"OFF\");\n\tspin_lock_irqsave(&priv->rmw_lock, flags);\n\n\tif (priv->reg_layout == CLK_REG_LAYOUT_RZ_A) {\n\t\tvalue = readb(priv->base + priv->control_regs[reg]);\n\t\tif (enable)\n\t\t\tvalue &= ~bitmask;\n\t\telse\n\t\t\tvalue |= bitmask;\n\t\twriteb(value, priv->base + priv->control_regs[reg]);\n\n\t\t \n\t\treadb(priv->base + priv->control_regs[reg]);\n\t\tbarrier_data(priv->base + priv->control_regs[reg]);\n\t} else {\n\t\tvalue = readl(priv->base + priv->control_regs[reg]);\n\t\tif (enable)\n\t\t\tvalue &= ~bitmask;\n\t\telse\n\t\t\tvalue |= bitmask;\n\t\twritel(value, priv->base + priv->control_regs[reg]);\n\t}\n\n\tspin_unlock_irqrestore(&priv->rmw_lock, flags);\n\n\tif (!enable || priv->reg_layout == CLK_REG_LAYOUT_RZ_A)\n\t\treturn 0;\n\n\terror = readl_poll_timeout_atomic(priv->base + priv->status_regs[reg],\n\t\t\t\t\t  value, !(value & bitmask), 0, 10);\n\tif (error)\n\t\tdev_err(dev, \"Failed to enable SMSTP %p[%d]\\n\",\n\t\t\tpriv->base + priv->control_regs[reg], bit);\n\n\treturn error;\n}\n\nstatic int cpg_mstp_clock_enable(struct clk_hw *hw)\n{\n\treturn cpg_mstp_clock_endisable(hw, true);\n}\n\nstatic void cpg_mstp_clock_disable(struct clk_hw *hw)\n{\n\tcpg_mstp_clock_endisable(hw, false);\n}\n\nstatic int cpg_mstp_clock_is_enabled(struct clk_hw *hw)\n{\n\tstruct mstp_clock *clock = to_mstp_clock(hw);\n\tstruct cpg_mssr_priv *priv = clock->priv;\n\tu32 value;\n\n\tif (priv->reg_layout == CLK_REG_LAYOUT_RZ_A)\n\t\tvalue = readb(priv->base + priv->control_regs[clock->index / 32]);\n\telse\n\t\tvalue = readl(priv->base + priv->status_regs[clock->index / 32]);\n\n\treturn !(value & BIT(clock->index % 32));\n}\n\nstatic const struct clk_ops cpg_mstp_clock_ops = {\n\t.enable = cpg_mstp_clock_enable,\n\t.disable = cpg_mstp_clock_disable,\n\t.is_enabled = cpg_mstp_clock_is_enabled,\n};\n\nstatic\nstruct clk *cpg_mssr_clk_src_twocell_get(struct of_phandle_args *clkspec,\n\t\t\t\t\t void *data)\n{\n\tunsigned int clkidx = clkspec->args[1];\n\tstruct cpg_mssr_priv *priv = data;\n\tstruct device *dev = priv->dev;\n\tunsigned int idx;\n\tconst char *type;\n\tstruct clk *clk;\n\tint range_check;\n\n\tswitch (clkspec->args[0]) {\n\tcase CPG_CORE:\n\t\ttype = \"core\";\n\t\tif (clkidx > priv->last_dt_core_clk) {\n\t\t\tdev_err(dev, \"Invalid %s clock index %u\\n\", type,\n\t\t\t       clkidx);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tclk = priv->clks[clkidx];\n\t\tbreak;\n\n\tcase CPG_MOD:\n\t\ttype = \"module\";\n\t\tif (priv->reg_layout == CLK_REG_LAYOUT_RZ_A) {\n\t\t\tidx = MOD_CLK_PACK_10(clkidx);\n\t\t\trange_check = 7 - (clkidx % 10);\n\t\t} else {\n\t\t\tidx = MOD_CLK_PACK(clkidx);\n\t\t\trange_check = 31 - (clkidx % 100);\n\t\t}\n\t\tif (range_check < 0 || idx >= priv->num_mod_clks) {\n\t\t\tdev_err(dev, \"Invalid %s clock index %u\\n\", type,\n\t\t\t\tclkidx);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tclk = priv->clks[priv->num_core_clks + idx];\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid CPG clock type %u\\n\", clkspec->args[0]);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (IS_ERR(clk))\n\t\tdev_err(dev, \"Cannot get %s clock %u: %ld\", type, clkidx,\n\t\t       PTR_ERR(clk));\n\telse\n\t\tdev_dbg(dev, \"clock (%u, %u) is %pC at %lu Hz\\n\",\n\t\t\tclkspec->args[0], clkspec->args[1], clk,\n\t\t\tclk_get_rate(clk));\n\treturn clk;\n}\n\nstatic void __init cpg_mssr_register_core_clk(const struct cpg_core_clk *core,\n\t\t\t\t\t      const struct cpg_mssr_info *info,\n\t\t\t\t\t      struct cpg_mssr_priv *priv)\n{\n\tstruct clk *clk = ERR_PTR(-ENOTSUPP), *parent;\n\tstruct device *dev = priv->dev;\n\tunsigned int id = core->id, div = core->div;\n\tconst char *parent_name;\n\n\tWARN_DEBUG(id >= priv->num_core_clks);\n\tWARN_DEBUG(PTR_ERR(priv->clks[id]) != -ENOENT);\n\n\tif (!core->name) {\n\t\t \n\t\treturn;\n\t}\n\n\tswitch (core->type) {\n\tcase CLK_TYPE_IN:\n\t\tclk = of_clk_get_by_name(priv->np, core->name);\n\t\tbreak;\n\n\tcase CLK_TYPE_FF:\n\tcase CLK_TYPE_DIV6P1:\n\tcase CLK_TYPE_DIV6_RO:\n\t\tWARN_DEBUG(core->parent >= priv->num_core_clks);\n\t\tparent = priv->clks[core->parent];\n\t\tif (IS_ERR(parent)) {\n\t\t\tclk = parent;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tparent_name = __clk_get_name(parent);\n\n\t\tif (core->type == CLK_TYPE_DIV6_RO)\n\t\t\t \n\t\t\tdiv *= (readl(priv->base + core->offset) & 0x3f) + 1;\n\n\t\tif (core->type == CLK_TYPE_DIV6P1) {\n\t\t\tclk = cpg_div6_register(core->name, 1, &parent_name,\n\t\t\t\t\t\tpriv->base + core->offset,\n\t\t\t\t\t\t&priv->notifiers);\n\t\t} else {\n\t\t\tclk = clk_register_fixed_factor(NULL, core->name,\n\t\t\t\t\t\t\tparent_name, 0,\n\t\t\t\t\t\t\tcore->mult, div);\n\t\t}\n\t\tbreak;\n\n\tcase CLK_TYPE_FR:\n\t\tclk = clk_register_fixed_rate(NULL, core->name, NULL, 0,\n\t\t\t\t\t      core->mult);\n\t\tbreak;\n\n\tdefault:\n\t\tif (info->cpg_clk_register)\n\t\t\tclk = info->cpg_clk_register(dev, core, info,\n\t\t\t\t\t\t     priv->clks, priv->base,\n\t\t\t\t\t\t     &priv->notifiers);\n\t\telse\n\t\t\tdev_err(dev, \"%s has unsupported core clock type %u\\n\",\n\t\t\t\tcore->name, core->type);\n\t\tbreak;\n\t}\n\n\tif (IS_ERR_OR_NULL(clk))\n\t\tgoto fail;\n\n\tdev_dbg(dev, \"Core clock %pC at %lu Hz\\n\", clk, clk_get_rate(clk));\n\tpriv->clks[id] = clk;\n\treturn;\n\nfail:\n\tdev_err(dev, \"Failed to register %s clock %s: %ld\\n\", \"core\",\n\t\tcore->name, PTR_ERR(clk));\n}\n\nstatic void __init cpg_mssr_register_mod_clk(const struct mssr_mod_clk *mod,\n\t\t\t\t\t     const struct cpg_mssr_info *info,\n\t\t\t\t\t     struct cpg_mssr_priv *priv)\n{\n\tstruct mstp_clock *clock = NULL;\n\tstruct device *dev = priv->dev;\n\tunsigned int id = mod->id;\n\tstruct clk_init_data init = {};\n\tstruct clk *parent, *clk;\n\tconst char *parent_name;\n\tunsigned int i;\n\n\tWARN_DEBUG(id < priv->num_core_clks);\n\tWARN_DEBUG(id >= priv->num_core_clks + priv->num_mod_clks);\n\tWARN_DEBUG(mod->parent >= priv->num_core_clks + priv->num_mod_clks);\n\tWARN_DEBUG(PTR_ERR(priv->clks[id]) != -ENOENT);\n\n\tif (!mod->name) {\n\t\t \n\t\treturn;\n\t}\n\n\tparent = priv->clks[mod->parent];\n\tif (IS_ERR(parent)) {\n\t\tclk = parent;\n\t\tgoto fail;\n\t}\n\n\tclock = kzalloc(sizeof(*clock), GFP_KERNEL);\n\tif (!clock) {\n\t\tclk = ERR_PTR(-ENOMEM);\n\t\tgoto fail;\n\t}\n\n\tinit.name = mod->name;\n\tinit.ops = &cpg_mstp_clock_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tparent_name = __clk_get_name(parent);\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tclock->index = id - priv->num_core_clks;\n\tclock->priv = priv;\n\tclock->hw.init = &init;\n\n\tfor (i = 0; i < info->num_crit_mod_clks; i++)\n\t\tif (id == info->crit_mod_clks[i] &&\n\t\t    cpg_mstp_clock_is_enabled(&clock->hw)) {\n\t\t\tdev_dbg(dev, \"MSTP %s setting CLK_IS_CRITICAL\\n\",\n\t\t\t\tmod->name);\n\t\t\tinit.flags |= CLK_IS_CRITICAL;\n\t\t\tbreak;\n\t\t}\n\n\tclk = clk_register(NULL, &clock->hw);\n\tif (IS_ERR(clk))\n\t\tgoto fail;\n\n\tdev_dbg(dev, \"Module clock %pC at %lu Hz\\n\", clk, clk_get_rate(clk));\n\tpriv->clks[id] = clk;\n\tpriv->smstpcr_saved[clock->index / 32].mask |= BIT(clock->index % 32);\n\treturn;\n\nfail:\n\tdev_err(dev, \"Failed to register %s clock %s: %ld\\n\", \"module\",\n\t\tmod->name, PTR_ERR(clk));\n\tkfree(clock);\n}\n\nstruct cpg_mssr_clk_domain {\n\tstruct generic_pm_domain genpd;\n\tunsigned int num_core_pm_clks;\n\tunsigned int core_pm_clks[];\n};\n\nstatic struct cpg_mssr_clk_domain *cpg_mssr_clk_domain;\n\nstatic bool cpg_mssr_is_pm_clk(const struct of_phandle_args *clkspec,\n\t\t\t       struct cpg_mssr_clk_domain *pd)\n{\n\tunsigned int i;\n\n\tif (clkspec->np != pd->genpd.dev.of_node || clkspec->args_count != 2)\n\t\treturn false;\n\n\tswitch (clkspec->args[0]) {\n\tcase CPG_CORE:\n\t\tfor (i = 0; i < pd->num_core_pm_clks; i++)\n\t\t\tif (clkspec->args[1] == pd->core_pm_clks[i])\n\t\t\t\treturn true;\n\t\treturn false;\n\n\tcase CPG_MOD:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nint cpg_mssr_attach_dev(struct generic_pm_domain *unused, struct device *dev)\n{\n\tstruct cpg_mssr_clk_domain *pd = cpg_mssr_clk_domain;\n\tstruct device_node *np = dev->of_node;\n\tstruct of_phandle_args clkspec;\n\tstruct clk *clk;\n\tint i = 0;\n\tint error;\n\n\tif (!pd) {\n\t\tdev_dbg(dev, \"CPG/MSSR clock domain not yet available\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\twhile (!of_parse_phandle_with_args(np, \"clocks\", \"#clock-cells\", i,\n\t\t\t\t\t   &clkspec)) {\n\t\tif (cpg_mssr_is_pm_clk(&clkspec, pd))\n\t\t\tgoto found;\n\n\t\tof_node_put(clkspec.np);\n\t\ti++;\n\t}\n\n\treturn 0;\n\nfound:\n\tclk = of_clk_get_from_provider(&clkspec);\n\tof_node_put(clkspec.np);\n\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\terror = pm_clk_create(dev);\n\tif (error)\n\t\tgoto fail_put;\n\n\terror = pm_clk_add_clk(dev, clk);\n\tif (error)\n\t\tgoto fail_destroy;\n\n\treturn 0;\n\nfail_destroy:\n\tpm_clk_destroy(dev);\nfail_put:\n\tclk_put(clk);\n\treturn error;\n}\n\nvoid cpg_mssr_detach_dev(struct generic_pm_domain *unused, struct device *dev)\n{\n\tif (!pm_clk_no_clocks(dev))\n\t\tpm_clk_destroy(dev);\n}\n\nstatic void cpg_mssr_genpd_remove(void *data)\n{\n\tpm_genpd_remove(data);\n}\n\nstatic int __init cpg_mssr_add_clk_domain(struct device *dev,\n\t\t\t\t\t  const unsigned int *core_pm_clks,\n\t\t\t\t\t  unsigned int num_core_pm_clks)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct generic_pm_domain *genpd;\n\tstruct cpg_mssr_clk_domain *pd;\n\tsize_t pm_size = num_core_pm_clks * sizeof(core_pm_clks[0]);\n\tint ret;\n\n\tpd = devm_kzalloc(dev, sizeof(*pd) + pm_size, GFP_KERNEL);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\tpd->num_core_pm_clks = num_core_pm_clks;\n\tmemcpy(pd->core_pm_clks, core_pm_clks, pm_size);\n\n\tgenpd = &pd->genpd;\n\tgenpd->name = np->name;\n\tgenpd->flags = GENPD_FLAG_PM_CLK | GENPD_FLAG_ALWAYS_ON |\n\t\t       GENPD_FLAG_ACTIVE_WAKEUP;\n\tgenpd->attach_dev = cpg_mssr_attach_dev;\n\tgenpd->detach_dev = cpg_mssr_detach_dev;\n\tret = pm_genpd_init(genpd, &pm_domain_always_on_gov, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, cpg_mssr_genpd_remove, genpd);\n\tif (ret)\n\t\treturn ret;\n\n\tcpg_mssr_clk_domain = pd;\n\n\treturn of_genpd_add_provider_simple(np, genpd);\n}\n\n#ifdef CONFIG_RESET_CONTROLLER\n\n#define rcdev_to_priv(x)\tcontainer_of(x, struct cpg_mssr_priv, rcdev)\n\nstatic int cpg_mssr_reset(struct reset_controller_dev *rcdev,\n\t\t\t  unsigned long id)\n{\n\tstruct cpg_mssr_priv *priv = rcdev_to_priv(rcdev);\n\tunsigned int reg = id / 32;\n\tunsigned int bit = id % 32;\n\tu32 bitmask = BIT(bit);\n\n\tdev_dbg(priv->dev, \"reset %u%02u\\n\", reg, bit);\n\n\t \n\twritel(bitmask, priv->base + priv->reset_regs[reg]);\n\n\t \n\tudelay(35);\n\n\t \n\twritel(bitmask, priv->base + priv->reset_clear_regs[reg]);\n\n\treturn 0;\n}\n\nstatic int cpg_mssr_assert(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tstruct cpg_mssr_priv *priv = rcdev_to_priv(rcdev);\n\tunsigned int reg = id / 32;\n\tunsigned int bit = id % 32;\n\tu32 bitmask = BIT(bit);\n\n\tdev_dbg(priv->dev, \"assert %u%02u\\n\", reg, bit);\n\n\twritel(bitmask, priv->base + priv->reset_regs[reg]);\n\treturn 0;\n}\n\nstatic int cpg_mssr_deassert(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned long id)\n{\n\tstruct cpg_mssr_priv *priv = rcdev_to_priv(rcdev);\n\tunsigned int reg = id / 32;\n\tunsigned int bit = id % 32;\n\tu32 bitmask = BIT(bit);\n\n\tdev_dbg(priv->dev, \"deassert %u%02u\\n\", reg, bit);\n\n\twritel(bitmask, priv->base + priv->reset_clear_regs[reg]);\n\treturn 0;\n}\n\nstatic int cpg_mssr_status(struct reset_controller_dev *rcdev,\n\t\t\t   unsigned long id)\n{\n\tstruct cpg_mssr_priv *priv = rcdev_to_priv(rcdev);\n\tunsigned int reg = id / 32;\n\tunsigned int bit = id % 32;\n\tu32 bitmask = BIT(bit);\n\n\treturn !!(readl(priv->base + priv->reset_regs[reg]) & bitmask);\n}\n\nstatic const struct reset_control_ops cpg_mssr_reset_ops = {\n\t.reset = cpg_mssr_reset,\n\t.assert = cpg_mssr_assert,\n\t.deassert = cpg_mssr_deassert,\n\t.status = cpg_mssr_status,\n};\n\nstatic int cpg_mssr_reset_xlate(struct reset_controller_dev *rcdev,\n\t\t\t\tconst struct of_phandle_args *reset_spec)\n{\n\tstruct cpg_mssr_priv *priv = rcdev_to_priv(rcdev);\n\tunsigned int unpacked = reset_spec->args[0];\n\tunsigned int idx = MOD_CLK_PACK(unpacked);\n\n\tif (unpacked % 100 > 31 || idx >= rcdev->nr_resets) {\n\t\tdev_err(priv->dev, \"Invalid reset index %u\\n\", unpacked);\n\t\treturn -EINVAL;\n\t}\n\n\treturn idx;\n}\n\nstatic int cpg_mssr_reset_controller_register(struct cpg_mssr_priv *priv)\n{\n\tpriv->rcdev.ops = &cpg_mssr_reset_ops;\n\tpriv->rcdev.of_node = priv->dev->of_node;\n\tpriv->rcdev.of_reset_n_cells = 1;\n\tpriv->rcdev.of_xlate = cpg_mssr_reset_xlate;\n\tpriv->rcdev.nr_resets = priv->num_mod_clks;\n\treturn devm_reset_controller_register(priv->dev, &priv->rcdev);\n}\n\n#else  \nstatic inline int cpg_mssr_reset_controller_register(struct cpg_mssr_priv *priv)\n{\n\treturn 0;\n}\n#endif  \n\n\nstatic const struct of_device_id cpg_mssr_match[] = {\n#ifdef CONFIG_CLK_R7S9210\n\t{\n\t\t.compatible = \"renesas,r7s9210-cpg-mssr\",\n\t\t.data = &r7s9210_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A7742\n\t{\n\t\t.compatible = \"renesas,r8a7742-cpg-mssr\",\n\t\t.data = &r8a7742_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A7743\n\t{\n\t\t.compatible = \"renesas,r8a7743-cpg-mssr\",\n\t\t.data = &r8a7743_cpg_mssr_info,\n\t},\n\t \n\t{\n\t\t.compatible = \"renesas,r8a7744-cpg-mssr\",\n\t\t.data = &r8a7743_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A7745\n\t{\n\t\t.compatible = \"renesas,r8a7745-cpg-mssr\",\n\t\t.data = &r8a7745_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A77470\n\t{\n\t\t.compatible = \"renesas,r8a77470-cpg-mssr\",\n\t\t.data = &r8a77470_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A774A1\n\t{\n\t\t.compatible = \"renesas,r8a774a1-cpg-mssr\",\n\t\t.data = &r8a774a1_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A774B1\n\t{\n\t\t.compatible = \"renesas,r8a774b1-cpg-mssr\",\n\t\t.data = &r8a774b1_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A774C0\n\t{\n\t\t.compatible = \"renesas,r8a774c0-cpg-mssr\",\n\t\t.data = &r8a774c0_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A774E1\n\t{\n\t\t.compatible = \"renesas,r8a774e1-cpg-mssr\",\n\t\t.data = &r8a774e1_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A7790\n\t{\n\t\t.compatible = \"renesas,r8a7790-cpg-mssr\",\n\t\t.data = &r8a7790_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A7791\n\t{\n\t\t.compatible = \"renesas,r8a7791-cpg-mssr\",\n\t\t.data = &r8a7791_cpg_mssr_info,\n\t},\n\t \n\t{\n\t\t.compatible = \"renesas,r8a7793-cpg-mssr\",\n\t\t.data = &r8a7791_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A7792\n\t{\n\t\t.compatible = \"renesas,r8a7792-cpg-mssr\",\n\t\t.data = &r8a7792_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A7794\n\t{\n\t\t.compatible = \"renesas,r8a7794-cpg-mssr\",\n\t\t.data = &r8a7794_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A7795\n\t{\n\t\t.compatible = \"renesas,r8a7795-cpg-mssr\",\n\t\t.data = &r8a7795_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A77960\n\t{\n\t\t.compatible = \"renesas,r8a7796-cpg-mssr\",\n\t\t.data = &r8a7796_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A77961\n\t{\n\t\t.compatible = \"renesas,r8a77961-cpg-mssr\",\n\t\t.data = &r8a7796_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A77965\n\t{\n\t\t.compatible = \"renesas,r8a77965-cpg-mssr\",\n\t\t.data = &r8a77965_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A77970\n\t{\n\t\t.compatible = \"renesas,r8a77970-cpg-mssr\",\n\t\t.data = &r8a77970_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A77980\n\t{\n\t\t.compatible = \"renesas,r8a77980-cpg-mssr\",\n\t\t.data = &r8a77980_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A77990\n\t{\n\t\t.compatible = \"renesas,r8a77990-cpg-mssr\",\n\t\t.data = &r8a77990_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A77995\n\t{\n\t\t.compatible = \"renesas,r8a77995-cpg-mssr\",\n\t\t.data = &r8a77995_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A779A0\n\t{\n\t\t.compatible = \"renesas,r8a779a0-cpg-mssr\",\n\t\t.data = &r8a779a0_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A779F0\n\t{\n\t\t.compatible = \"renesas,r8a779f0-cpg-mssr\",\n\t\t.data = &r8a779f0_cpg_mssr_info,\n\t},\n#endif\n#ifdef CONFIG_CLK_R8A779G0\n\t{\n\t\t.compatible = \"renesas,r8a779g0-cpg-mssr\",\n\t\t.data = &r8a779g0_cpg_mssr_info,\n\t},\n#endif\n\t{   }\n};\n\nstatic void cpg_mssr_del_clk_provider(void *data)\n{\n\tof_clk_del_provider(data);\n}\n\n#if defined(CONFIG_PM_SLEEP) && defined(CONFIG_ARM_PSCI_FW)\nstatic int cpg_mssr_suspend_noirq(struct device *dev)\n{\n\tstruct cpg_mssr_priv *priv = dev_get_drvdata(dev);\n\tunsigned int reg;\n\n\t \n\tif (!psci_ops.cpu_suspend)\n\t\treturn 0;\n\n\t \n\tfor (reg = 0; reg < ARRAY_SIZE(priv->smstpcr_saved); reg++) {\n\t\tif (priv->smstpcr_saved[reg].mask)\n\t\t\tpriv->smstpcr_saved[reg].val =\n\t\t\t\tpriv->reg_layout == CLK_REG_LAYOUT_RZ_A ?\n\t\t\t\treadb(priv->base + priv->control_regs[reg]) :\n\t\t\t\treadl(priv->base + priv->control_regs[reg]);\n\t}\n\n\t \n\traw_notifier_call_chain(&priv->notifiers, PM_EVENT_SUSPEND, NULL);\n\n\treturn 0;\n}\n\nstatic int cpg_mssr_resume_noirq(struct device *dev)\n{\n\tstruct cpg_mssr_priv *priv = dev_get_drvdata(dev);\n\tunsigned int reg;\n\tu32 mask, oldval, newval;\n\tint error;\n\n\t \n\tif (!psci_ops.cpu_suspend)\n\t\treturn 0;\n\n\t \n\traw_notifier_call_chain(&priv->notifiers, PM_EVENT_RESUME, NULL);\n\n\t \n\tfor (reg = 0; reg < ARRAY_SIZE(priv->smstpcr_saved); reg++) {\n\t\tmask = priv->smstpcr_saved[reg].mask;\n\t\tif (!mask)\n\t\t\tcontinue;\n\n\t\tif (priv->reg_layout == CLK_REG_LAYOUT_RZ_A)\n\t\t\toldval = readb(priv->base + priv->control_regs[reg]);\n\t\telse\n\t\t\toldval = readl(priv->base + priv->control_regs[reg]);\n\t\tnewval = oldval & ~mask;\n\t\tnewval |= priv->smstpcr_saved[reg].val & mask;\n\t\tif (newval == oldval)\n\t\t\tcontinue;\n\n\t\tif (priv->reg_layout == CLK_REG_LAYOUT_RZ_A) {\n\t\t\twriteb(newval, priv->base + priv->control_regs[reg]);\n\t\t\t \n\t\t\treadb(priv->base + priv->control_regs[reg]);\n\t\t\tbarrier_data(priv->base + priv->control_regs[reg]);\n\t\t\tcontinue;\n\t\t} else\n\t\t\twritel(newval, priv->base + priv->control_regs[reg]);\n\n\t\t \n\t\tmask &= ~priv->smstpcr_saved[reg].val;\n\t\tif (!mask)\n\t\t\tcontinue;\n\n\t\terror = readl_poll_timeout_atomic(priv->base + priv->status_regs[reg],\n\t\t\t\t\t\toldval, !(oldval & mask), 0, 10);\n\t\tif (error)\n\t\t\tdev_warn(dev, \"Failed to enable SMSTP%u[0x%x]\\n\", reg,\n\t\t\t\t oldval & mask);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cpg_mssr_pm = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(cpg_mssr_suspend_noirq,\n\t\t\t\t      cpg_mssr_resume_noirq)\n};\n#define DEV_PM_OPS\t&cpg_mssr_pm\n#else\n#define DEV_PM_OPS\tNULL\n#endif  \n\nstatic int __init cpg_mssr_common_init(struct device *dev,\n\t\t\t\t       struct device_node *np,\n\t\t\t\t       const struct cpg_mssr_info *info)\n{\n\tstruct cpg_mssr_priv *priv;\n\tunsigned int nclks, i;\n\tint error;\n\n\tif (info->init) {\n\t\terror = info->init(dev);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tnclks = info->num_total_core_clks + info->num_hw_mod_clks;\n\tpriv = kzalloc(struct_size(priv, clks, nclks), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->np = np;\n\tpriv->dev = dev;\n\tspin_lock_init(&priv->rmw_lock);\n\n\tpriv->base = of_iomap(np, 0);\n\tif (!priv->base) {\n\t\terror = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tpriv->num_core_clks = info->num_total_core_clks;\n\tpriv->num_mod_clks = info->num_hw_mod_clks;\n\tpriv->last_dt_core_clk = info->last_dt_core_clk;\n\tRAW_INIT_NOTIFIER_HEAD(&priv->notifiers);\n\tpriv->reg_layout = info->reg_layout;\n\tif (priv->reg_layout == CLK_REG_LAYOUT_RCAR_GEN2_AND_GEN3) {\n\t\tpriv->status_regs = mstpsr;\n\t\tpriv->control_regs = smstpcr;\n\t\tpriv->reset_regs = srcr;\n\t\tpriv->reset_clear_regs = srstclr;\n\t} else if (priv->reg_layout == CLK_REG_LAYOUT_RZ_A) {\n\t\tpriv->control_regs = stbcr;\n\t} else if (priv->reg_layout == CLK_REG_LAYOUT_RCAR_GEN4) {\n\t\tpriv->status_regs = mstpsr_for_gen4;\n\t\tpriv->control_regs = mstpcr_for_gen4;\n\t\tpriv->reset_regs = srcr_for_gen4;\n\t\tpriv->reset_clear_regs = srstclr_for_gen4;\n\t} else {\n\t\terror = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tfor (i = 0; i < nclks; i++)\n\t\tpriv->clks[i] = ERR_PTR(-ENOENT);\n\n\terror = of_clk_add_provider(np, cpg_mssr_clk_src_twocell_get, priv);\n\tif (error)\n\t\tgoto out_err;\n\n\tcpg_mssr_priv = priv;\n\n\treturn 0;\n\nout_err:\n\tif (priv->base)\n\t\tiounmap(priv->base);\n\tkfree(priv);\n\n\treturn error;\n}\n\nvoid __init cpg_mssr_early_init(struct device_node *np,\n\t\t\t\tconst struct cpg_mssr_info *info)\n{\n\tint error;\n\tint i;\n\n\terror = cpg_mssr_common_init(NULL, np, info);\n\tif (error)\n\t\treturn;\n\n\tfor (i = 0; i < info->num_early_core_clks; i++)\n\t\tcpg_mssr_register_core_clk(&info->early_core_clks[i], info,\n\t\t\t\t\t   cpg_mssr_priv);\n\n\tfor (i = 0; i < info->num_early_mod_clks; i++)\n\t\tcpg_mssr_register_mod_clk(&info->early_mod_clks[i], info,\n\t\t\t\t\t  cpg_mssr_priv);\n\n}\n\nstatic int __init cpg_mssr_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst struct cpg_mssr_info *info;\n\tstruct cpg_mssr_priv *priv;\n\tunsigned int i;\n\tint error;\n\n\tinfo = of_device_get_match_data(dev);\n\n\tif (!cpg_mssr_priv) {\n\t\terror = cpg_mssr_common_init(dev, dev->of_node, info);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tpriv = cpg_mssr_priv;\n\tpriv->dev = dev;\n\tdev_set_drvdata(dev, priv);\n\n\tfor (i = 0; i < info->num_core_clks; i++)\n\t\tcpg_mssr_register_core_clk(&info->core_clks[i], info, priv);\n\n\tfor (i = 0; i < info->num_mod_clks; i++)\n\t\tcpg_mssr_register_mod_clk(&info->mod_clks[i], info, priv);\n\n\terror = devm_add_action_or_reset(dev,\n\t\t\t\t\t cpg_mssr_del_clk_provider,\n\t\t\t\t\t np);\n\tif (error)\n\t\treturn error;\n\n\terror = cpg_mssr_add_clk_domain(dev, info->core_pm_clks,\n\t\t\t\t\tinfo->num_core_pm_clks);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (priv->reg_layout == CLK_REG_LAYOUT_RZ_A)\n\t\treturn 0;\n\n\terror = cpg_mssr_reset_controller_register(priv);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic struct platform_driver cpg_mssr_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"renesas-cpg-mssr\",\n\t\t.of_match_table = cpg_mssr_match,\n\t\t.pm = DEV_PM_OPS,\n\t},\n};\n\nstatic int __init cpg_mssr_init(void)\n{\n\treturn platform_driver_probe(&cpg_mssr_driver, cpg_mssr_probe);\n}\n\nsubsys_initcall(cpg_mssr_init);\n\nvoid __init mssr_mod_nullify(struct mssr_mod_clk *mod_clks,\n\t\t\t     unsigned int num_mod_clks,\n\t\t\t     const unsigned int *clks, unsigned int n)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0, j = 0; i < num_mod_clks && j < n; i++)\n\t\tif (mod_clks[i].id == clks[j]) {\n\t\t\tmod_clks[i].name = NULL;\n\t\t\tj++;\n\t\t}\n}\n\nMODULE_DESCRIPTION(\"Renesas CPG/MSSR Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}