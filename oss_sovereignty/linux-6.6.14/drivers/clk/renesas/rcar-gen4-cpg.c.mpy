{
  "module_name": "rcar-gen4-cpg.c",
  "hash_id": "f1aa3267299b9f83ff957ce67c722dd0122f3d75352a029d2fba1c0ac3e6ae42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/renesas/rcar-gen4-cpg.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/slab.h>\n\n#include \"renesas-cpg-mssr.h\"\n#include \"rcar-gen4-cpg.h\"\n#include \"rcar-cpg-lib.h\"\n\nstatic const struct rcar_gen4_cpg_pll_config *cpg_pll_config __initdata;\nstatic unsigned int cpg_clk_extalr __initdata;\nstatic u32 cpg_mode __initdata;\n\n#define CPG_PLLECR\t\t0x0820\t \n\n#define CPG_PLLECR_PLLST(n)\tBIT(8 + ((n) < 3 ? (n) - 1 : \\\n\t\t\t\t\t (n) > 3 ? (n) + 1 : n))  \n\n#define CPG_PLL1CR0\t\t0x830\t \n#define CPG_PLL1CR1\t\t0x8b0\n#define CPG_PLL2CR0\t\t0x834\n#define CPG_PLL2CR1\t\t0x8b8\n#define CPG_PLL3CR0\t\t0x83c\n#define CPG_PLL3CR1\t\t0x8c0\n#define CPG_PLL4CR0\t\t0x844\n#define CPG_PLL4CR1\t\t0x8c8\n#define CPG_PLL6CR0\t\t0x84c\n#define CPG_PLL6CR1\t\t0x8d8\n\n#define CPG_PLLxCR0_KICK\tBIT(31)\n#define CPG_PLLxCR0_NI\t\tGENMASK(27, 20)\t \n#define CPG_PLLxCR0_SSMODE\tGENMASK(18, 16)\t \n#define CPG_PLLxCR0_SSMODE_FM\tBIT(18)\t \n#define CPG_PLLxCR0_SSMODE_DITH\tBIT(17)  \n#define CPG_PLLxCR0_SSMODE_CENT\tBIT(16)\t \n#define CPG_PLLxCR0_SSFREQ\tGENMASK(14, 8)\t \n#define CPG_PLLxCR0_SSDEPT\tGENMASK(6, 0)\t \n\n#define SSMODE_FM\t\tBIT(2)\t \n#define SSMODE_DITHER\t\tBIT(1)\t \n#define SSMODE_CENTER\t\tBIT(0)\t \n\n \nstruct cpg_pll_clk {\n\tstruct clk_hw hw;\n\tvoid __iomem *pllcr0_reg;\n\tvoid __iomem *pllecr_reg;\n\tu32 pllecr_pllst_mask;\n};\n\n#define to_pll_clk(_hw)   container_of(_hw, struct cpg_pll_clk, hw)\n\nstatic unsigned long cpg_pll_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct cpg_pll_clk *pll_clk = to_pll_clk(hw);\n\tunsigned int mult;\n\n\tmult = FIELD_GET(CPG_PLLxCR0_NI, readl(pll_clk->pllcr0_reg)) + 1;\n\n\treturn parent_rate * mult * 2;\n}\n\nstatic int cpg_pll_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tunsigned int min_mult, max_mult, mult;\n\tunsigned long prate;\n\n\tprate = req->best_parent_rate * 2;\n\tmin_mult = max(div64_ul(req->min_rate, prate), 1ULL);\n\tmax_mult = min(div64_ul(req->max_rate, prate), 256ULL);\n\tif (max_mult < min_mult)\n\t\treturn -EINVAL;\n\n\tmult = DIV_ROUND_CLOSEST_ULL(req->rate, prate);\n\tmult = clamp(mult, min_mult, max_mult);\n\n\treq->rate = prate * mult;\n\treturn 0;\n}\n\nstatic int cpg_pll_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct cpg_pll_clk *pll_clk = to_pll_clk(hw);\n\tunsigned int mult;\n\tu32 val;\n\n\tmult = DIV_ROUND_CLOSEST_ULL(rate, parent_rate * 2);\n\tmult = clamp(mult, 1U, 256U);\n\n\tif (readl(pll_clk->pllcr0_reg) & CPG_PLLxCR0_KICK)\n\t\treturn -EBUSY;\n\n\tcpg_reg_modify(pll_clk->pllcr0_reg, CPG_PLLxCR0_NI,\n\t\t       FIELD_PREP(CPG_PLLxCR0_NI, mult - 1));\n\n\t \n\tcpg_reg_modify(pll_clk->pllcr0_reg, 0, CPG_PLLxCR0_KICK);\n\n\t \n\treturn readl_poll_timeout(pll_clk->pllecr_reg, val,\n\t\t\t\t  val & pll_clk->pllecr_pllst_mask, 0, 1000);\n}\n\nstatic const struct clk_ops cpg_pll_clk_ops = {\n\t.recalc_rate = cpg_pll_clk_recalc_rate,\n\t.determine_rate = cpg_pll_clk_determine_rate,\n\t.set_rate = cpg_pll_clk_set_rate,\n};\n\nstatic struct clk * __init cpg_pll_clk_register(const char *name,\n\t\t\t\t\t\tconst char *parent_name,\n\t\t\t\t\t\tvoid __iomem *base,\n\t\t\t\t\t\tunsigned int cr0_offset,\n\t\t\t\t\t\tunsigned int cr1_offset,\n\t\t\t\t\t\tunsigned int index)\n\n{\n\tstruct cpg_pll_clk *pll_clk;\n\tstruct clk_init_data init = {};\n\tstruct clk *clk;\n\n\tpll_clk = kzalloc(sizeof(*pll_clk), GFP_KERNEL);\n\tif (!pll_clk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &cpg_pll_clk_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tpll_clk->hw.init = &init;\n\tpll_clk->pllcr0_reg = base + cr0_offset;\n\tpll_clk->pllecr_reg = base + CPG_PLLECR;\n\tpll_clk->pllecr_pllst_mask = CPG_PLLECR_PLLST(index);\n\n\t \n\twritel(0, base + cr1_offset);\n\tcpg_reg_modify(pll_clk->pllcr0_reg, CPG_PLLxCR0_SSMODE, 0);\n\n\tclk = clk_register(NULL, &pll_clk->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(pll_clk);\n\n\treturn clk;\n}\n \n#define CPG_FRQCRB\t\t\t0x00000804\n#define CPG_FRQCRB_KICK\t\t\tBIT(31)\n#define CPG_FRQCRC\t\t\t0x00000808\n\nstruct cpg_z_clk {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n\tvoid __iomem *kick_reg;\n\tunsigned long max_rate;\t\t \n\tunsigned int fixed_div;\n\tu32 mask;\n};\n\n#define to_z_clk(_hw)\tcontainer_of(_hw, struct cpg_z_clk, hw)\n\nstatic unsigned long cpg_z_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct cpg_z_clk *zclk = to_z_clk(hw);\n\tunsigned int mult;\n\tu32 val;\n\n\tval = readl(zclk->reg) & zclk->mask;\n\tmult = 32 - (val >> __ffs(zclk->mask));\n\n\treturn DIV_ROUND_CLOSEST_ULL((u64)parent_rate * mult,\n\t\t\t\t     32 * zclk->fixed_div);\n}\n\nstatic int cpg_z_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t    struct clk_rate_request *req)\n{\n\tstruct cpg_z_clk *zclk = to_z_clk(hw);\n\tunsigned int min_mult, max_mult, mult;\n\tunsigned long rate, prate;\n\n\trate = min(req->rate, req->max_rate);\n\tif (rate <= zclk->max_rate) {\n\t\t \n\t\tprate = zclk->max_rate;\n\t} else {\n\t\t \n\t\tprate = rate;\n\t}\n\treq->best_parent_rate = clk_hw_round_rate(clk_hw_get_parent(hw),\n\t\t\t\t\t\t  prate * zclk->fixed_div);\n\n\tprate = req->best_parent_rate / zclk->fixed_div;\n\tmin_mult = max(div64_ul(req->min_rate * 32ULL, prate), 1ULL);\n\tmax_mult = min(div64_ul(req->max_rate * 32ULL, prate), 32ULL);\n\tif (max_mult < min_mult)\n\t\treturn -EINVAL;\n\n\tmult = DIV_ROUND_CLOSEST_ULL(rate * 32ULL, prate);\n\tmult = clamp(mult, min_mult, max_mult);\n\n\treq->rate = DIV_ROUND_CLOSEST_ULL((u64)prate * mult, 32);\n\treturn 0;\n}\n\nstatic int cpg_z_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct cpg_z_clk *zclk = to_z_clk(hw);\n\tunsigned int mult;\n\tunsigned int i;\n\n\tmult = DIV64_U64_ROUND_CLOSEST(rate * 32ULL * zclk->fixed_div,\n\t\t\t\t       parent_rate);\n\tmult = clamp(mult, 1U, 32U);\n\n\tif (readl(zclk->kick_reg) & CPG_FRQCRB_KICK)\n\t\treturn -EBUSY;\n\n\tcpg_reg_modify(zclk->reg, zclk->mask, (32 - mult) << __ffs(zclk->mask));\n\n\t \n\tcpg_reg_modify(zclk->kick_reg, 0, CPG_FRQCRB_KICK);\n\n\t \n\tfor (i = 1000; i; i--) {\n\t\tif (!(readl(zclk->kick_reg) & CPG_FRQCRB_KICK))\n\t\t\treturn 0;\n\n\t\tcpu_relax();\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic const struct clk_ops cpg_z_clk_ops = {\n\t.recalc_rate = cpg_z_clk_recalc_rate,\n\t.determine_rate = cpg_z_clk_determine_rate,\n\t.set_rate = cpg_z_clk_set_rate,\n};\n\nstatic struct clk * __init cpg_z_clk_register(const char *name,\n\t\t\t\t\t      const char *parent_name,\n\t\t\t\t\t      void __iomem *reg,\n\t\t\t\t\t      unsigned int div,\n\t\t\t\t\t      unsigned int offset)\n{\n\tstruct clk_init_data init = {};\n\tstruct cpg_z_clk *zclk;\n\tstruct clk *clk;\n\n\tzclk = kzalloc(sizeof(*zclk), GFP_KERNEL);\n\tif (!zclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &cpg_z_clk_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tzclk->reg = reg + CPG_FRQCRC;\n\tzclk->kick_reg = reg + CPG_FRQCRB;\n\tzclk->hw.init = &init;\n\tzclk->mask = GENMASK(offset + 4, offset);\n\tzclk->fixed_div = div;  \n\n\tclk = clk_register(NULL, &zclk->hw);\n\tif (IS_ERR(clk)) {\n\t\tkfree(zclk);\n\t\treturn clk;\n\t}\n\n\tzclk->max_rate = clk_hw_get_rate(clk_hw_get_parent(&zclk->hw)) /\n\t\t\t zclk->fixed_div;\n\treturn clk;\n}\n\n \nstatic const struct clk_div_table cpg_rpcsrc_div_table[] = {\n\t{ 0, 4 }, { 1, 6 }, { 2, 5 }, { 3, 6 }, { 0, 0 },\n};\n\nstruct clk * __init rcar_gen4_cpg_clk_register(struct device *dev,\n\tconst struct cpg_core_clk *core, const struct cpg_mssr_info *info,\n\tstruct clk **clks, void __iomem *base,\n\tstruct raw_notifier_head *notifiers)\n{\n\tconst struct clk *parent;\n\tunsigned int mult = 1;\n\tunsigned int div = 1;\n\tu32 value;\n\n\tparent = clks[core->parent & 0xffff];\t \n\tif (IS_ERR(parent))\n\t\treturn ERR_CAST(parent);\n\n\tswitch (core->type) {\n\tcase CLK_TYPE_GEN4_MAIN:\n\t\tdiv = cpg_pll_config->extal_div;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN4_PLL1:\n\t\tmult = cpg_pll_config->pll1_mult;\n\t\tdiv = cpg_pll_config->pll1_div;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN4_PLL2_VAR:\n\t\t \n\t\treturn cpg_pll_clk_register(core->name, __clk_get_name(parent),\n\t\t\t\t\t    base, CPG_PLL2CR0, CPG_PLL2CR1, 2);\n\n\tcase CLK_TYPE_GEN4_PLL2:\n\t\tmult = cpg_pll_config->pll2_mult;\n\t\tdiv = cpg_pll_config->pll2_div;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN4_PLL3:\n\t\tmult = cpg_pll_config->pll3_mult;\n\t\tdiv = cpg_pll_config->pll3_div;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN4_PLL4:\n\t\tmult = cpg_pll_config->pll4_mult;\n\t\tdiv = cpg_pll_config->pll4_div;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN4_PLL5:\n\t\tmult = cpg_pll_config->pll5_mult;\n\t\tdiv = cpg_pll_config->pll5_div;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN4_PLL6:\n\t\tmult = cpg_pll_config->pll6_mult;\n\t\tdiv = cpg_pll_config->pll6_div;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN4_PLL2X_3X:\n\t\tvalue = readl(base + core->offset);\n\t\tmult = (((value >> 24) & 0x7f) + 1) * 2;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN4_Z:\n\t\treturn cpg_z_clk_register(core->name, __clk_get_name(parent),\n\t\t\t\t\t  base, core->div, core->offset);\n\n\tcase CLK_TYPE_GEN4_SDSRC:\n\t\tdiv = ((readl(base + SD0CKCR1) >> 29) & 0x03) + 4;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN4_SDH:\n\t\treturn cpg_sdh_clk_register(core->name, base + core->offset,\n\t\t\t\t\t   __clk_get_name(parent), notifiers);\n\n\tcase CLK_TYPE_GEN4_SD:\n\t\treturn cpg_sd_clk_register(core->name, base + core->offset,\n\t\t\t\t\t   __clk_get_name(parent));\n\n\tcase CLK_TYPE_GEN4_MDSEL:\n\t\t \n\t\tif (cpg_mode & BIT(core->offset)) {\n\t\t\tdiv = core->div & 0xffff;\n\t\t} else {\n\t\t\tparent = clks[core->parent >> 16];\n\t\t\tif (IS_ERR(parent))\n\t\t\t\treturn ERR_CAST(parent);\n\t\t\tdiv = core->div >> 16;\n\t\t}\n\t\tmult = 1;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN4_OSC:\n\t\t \n\t\tdiv = cpg_pll_config->osc_prediv * core->div;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN4_RPCSRC:\n\t\treturn clk_register_divider_table(NULL, core->name,\n\t\t\t\t\t\t  __clk_get_name(parent), 0,\n\t\t\t\t\t\t  base + CPG_RPCCKCR, 3, 2, 0,\n\t\t\t\t\t\t  cpg_rpcsrc_div_table,\n\t\t\t\t\t\t  &cpg_lock);\n\n\tcase CLK_TYPE_GEN4_RPC:\n\t\treturn cpg_rpc_clk_register(core->name, base + CPG_RPCCKCR,\n\t\t\t\t\t    __clk_get_name(parent), notifiers);\n\n\tcase CLK_TYPE_GEN4_RPCD2:\n\t\treturn cpg_rpcd2_clk_register(core->name, base + CPG_RPCCKCR,\n\t\t\t\t\t      __clk_get_name(parent));\n\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn clk_register_fixed_factor(NULL, core->name,\n\t\t\t\t\t __clk_get_name(parent), 0, mult, div);\n}\n\nint __init rcar_gen4_cpg_init(const struct rcar_gen4_cpg_pll_config *config,\n\t\t\t      unsigned int clk_extalr, u32 mode)\n{\n\tcpg_pll_config = config;\n\tcpg_clk_extalr = clk_extalr;\n\tcpg_mode = mode;\n\n\tspin_lock_init(&cpg_lock);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}