{
  "module_name": "rcar-gen3-cpg.c",
  "hash_id": "1c9e5b5905de0baf95bb149b348c022aa74796d42c7ee3fbe9f134102e3e1c25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/renesas/rcar-gen3-cpg.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/sys_soc.h>\n\n#include \"renesas-cpg-mssr.h\"\n#include \"rcar-cpg-lib.h\"\n#include \"rcar-gen3-cpg.h\"\n\n#define CPG_PLLECR\t\t0x00d0\t \n\n#define CPG_PLLECR_PLLST(n)\tBIT(8 + (n))\t \n\n#define CPG_PLL0CR\t\t0x00d8\t \n#define CPG_PLL2CR\t\t0x002c\n#define CPG_PLL4CR\t\t0x01f4\n\n#define CPG_PLLnCR_STC_MASK\tGENMASK(30, 24)\t \n\n#define CPG_RCKCR_CKSEL\tBIT(15)\t \n\n \nstruct cpg_pll_clk {\n\tstruct clk_hw hw;\n\tvoid __iomem *pllcr_reg;\n\tvoid __iomem *pllecr_reg;\n\tunsigned int fixed_mult;\n\tu32 pllecr_pllst_mask;\n};\n\n#define to_pll_clk(_hw)   container_of(_hw, struct cpg_pll_clk, hw)\n\nstatic unsigned long cpg_pll_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct cpg_pll_clk *pll_clk = to_pll_clk(hw);\n\tunsigned int mult;\n\tu32 val;\n\n\tval = readl(pll_clk->pllcr_reg) & CPG_PLLnCR_STC_MASK;\n\tmult = (val >> __ffs(CPG_PLLnCR_STC_MASK)) + 1;\n\n\treturn parent_rate * mult * pll_clk->fixed_mult;\n}\n\nstatic int cpg_pll_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tstruct cpg_pll_clk *pll_clk = to_pll_clk(hw);\n\tunsigned int min_mult, max_mult, mult;\n\tunsigned long prate;\n\n\tprate = req->best_parent_rate * pll_clk->fixed_mult;\n\tmin_mult = max(div64_ul(req->min_rate, prate), 1ULL);\n\tmax_mult = min(div64_ul(req->max_rate, prate), 128ULL);\n\tif (max_mult < min_mult)\n\t\treturn -EINVAL;\n\n\tmult = DIV_ROUND_CLOSEST_ULL(req->rate, prate);\n\tmult = clamp(mult, min_mult, max_mult);\n\n\treq->rate = prate * mult;\n\treturn 0;\n}\n\nstatic int cpg_pll_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct cpg_pll_clk *pll_clk = to_pll_clk(hw);\n\tunsigned int mult, i;\n\tu32 val;\n\n\tmult = DIV_ROUND_CLOSEST_ULL(rate, parent_rate * pll_clk->fixed_mult);\n\tmult = clamp(mult, 1U, 128U);\n\n\tval = readl(pll_clk->pllcr_reg);\n\tval &= ~CPG_PLLnCR_STC_MASK;\n\tval |= (mult - 1) << __ffs(CPG_PLLnCR_STC_MASK);\n\twritel(val, pll_clk->pllcr_reg);\n\n\tfor (i = 1000; i; i--) {\n\t\tif (readl(pll_clk->pllecr_reg) & pll_clk->pllecr_pllst_mask)\n\t\t\treturn 0;\n\n\t\tcpu_relax();\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic const struct clk_ops cpg_pll_clk_ops = {\n\t.recalc_rate = cpg_pll_clk_recalc_rate,\n\t.determine_rate = cpg_pll_clk_determine_rate,\n\t.set_rate = cpg_pll_clk_set_rate,\n};\n\nstatic struct clk * __init cpg_pll_clk_register(const char *name,\n\t\t\t\t\t\tconst char *parent_name,\n\t\t\t\t\t\tvoid __iomem *base,\n\t\t\t\t\t\tunsigned int mult,\n\t\t\t\t\t\tunsigned int offset,\n\t\t\t\t\t\tunsigned int index)\n\n{\n\tstruct cpg_pll_clk *pll_clk;\n\tstruct clk_init_data init = {};\n\tstruct clk *clk;\n\n\tpll_clk = kzalloc(sizeof(*pll_clk), GFP_KERNEL);\n\tif (!pll_clk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &cpg_pll_clk_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tpll_clk->hw.init = &init;\n\tpll_clk->pllcr_reg = base + offset;\n\tpll_clk->pllecr_reg = base + CPG_PLLECR;\n\tpll_clk->fixed_mult = mult;\t \n\tpll_clk->pllecr_pllst_mask = CPG_PLLECR_PLLST(index);\n\n\tclk = clk_register(NULL, &pll_clk->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(pll_clk);\n\n\treturn clk;\n}\n\n \n#define CPG_FRQCRB\t\t\t0x00000004\n#define CPG_FRQCRB_KICK\t\t\tBIT(31)\n#define CPG_FRQCRC\t\t\t0x000000e0\n\nstruct cpg_z_clk {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n\tvoid __iomem *kick_reg;\n\tunsigned long max_rate;\t\t \n\tunsigned int fixed_div;\n\tu32 mask;\n};\n\n#define to_z_clk(_hw)\tcontainer_of(_hw, struct cpg_z_clk, hw)\n\nstatic unsigned long cpg_z_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct cpg_z_clk *zclk = to_z_clk(hw);\n\tunsigned int mult;\n\tu32 val;\n\n\tval = readl(zclk->reg) & zclk->mask;\n\tmult = 32 - (val >> __ffs(zclk->mask));\n\n\treturn DIV_ROUND_CLOSEST_ULL((u64)parent_rate * mult,\n\t\t\t\t     32 * zclk->fixed_div);\n}\n\nstatic int cpg_z_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t    struct clk_rate_request *req)\n{\n\tstruct cpg_z_clk *zclk = to_z_clk(hw);\n\tunsigned int min_mult, max_mult, mult;\n\tunsigned long rate, prate;\n\n\trate = min(req->rate, req->max_rate);\n\tif (rate <= zclk->max_rate) {\n\t\t \n\t\tprate = zclk->max_rate;\n\t} else {\n\t\t \n\t\tprate = rate;\n\t}\n\treq->best_parent_rate = clk_hw_round_rate(clk_hw_get_parent(hw),\n\t\t\t\t\t\t  prate * zclk->fixed_div);\n\n\tprate = req->best_parent_rate / zclk->fixed_div;\n\tmin_mult = max(div64_ul(req->min_rate * 32ULL, prate), 1ULL);\n\tmax_mult = min(div64_ul(req->max_rate * 32ULL, prate), 32ULL);\n\tif (max_mult < min_mult)\n\t\treturn -EINVAL;\n\n\tmult = DIV_ROUND_CLOSEST_ULL(rate * 32ULL, prate);\n\tmult = clamp(mult, min_mult, max_mult);\n\n\treq->rate = DIV_ROUND_CLOSEST_ULL((u64)prate * mult, 32);\n\treturn 0;\n}\n\nstatic int cpg_z_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct cpg_z_clk *zclk = to_z_clk(hw);\n\tunsigned int mult;\n\tunsigned int i;\n\n\tmult = DIV64_U64_ROUND_CLOSEST(rate * 32ULL * zclk->fixed_div,\n\t\t\t\t       parent_rate);\n\tmult = clamp(mult, 1U, 32U);\n\n\tif (readl(zclk->kick_reg) & CPG_FRQCRB_KICK)\n\t\treturn -EBUSY;\n\n\tcpg_reg_modify(zclk->reg, zclk->mask, (32 - mult) << __ffs(zclk->mask));\n\n\t \n\tcpg_reg_modify(zclk->kick_reg, 0, CPG_FRQCRB_KICK);\n\n\t \n\tfor (i = 1000; i; i--) {\n\t\tif (!(readl(zclk->kick_reg) & CPG_FRQCRB_KICK))\n\t\t\treturn 0;\n\n\t\tcpu_relax();\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic const struct clk_ops cpg_z_clk_ops = {\n\t.recalc_rate = cpg_z_clk_recalc_rate,\n\t.determine_rate = cpg_z_clk_determine_rate,\n\t.set_rate = cpg_z_clk_set_rate,\n};\n\nstatic struct clk * __init __cpg_z_clk_register(const char *name,\n\t\t\t\t\t      const char *parent_name,\n\t\t\t\t\t      void __iomem *reg,\n\t\t\t\t\t      unsigned int div,\n\t\t\t\t\t      unsigned int offset,\n\t\t\t\t\t      unsigned int fcr,\n\t\t\t\t\t      unsigned int flags)\n{\n\tstruct clk_init_data init = {};\n\tstruct cpg_z_clk *zclk;\n\tstruct clk *clk;\n\n\tzclk = kzalloc(sizeof(*zclk), GFP_KERNEL);\n\tif (!zclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &cpg_z_clk_ops;\n\tinit.flags = flags;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tzclk->reg = reg + fcr;\n\tzclk->kick_reg = reg + CPG_FRQCRB;\n\tzclk->hw.init = &init;\n\tzclk->mask = GENMASK(offset + 4, offset);\n\tzclk->fixed_div = div;  \n\n\tclk = clk_register(NULL, &zclk->hw);\n\tif (IS_ERR(clk)) {\n\t\tkfree(zclk);\n\t\treturn clk;\n\t}\n\n\tzclk->max_rate = clk_hw_get_rate(clk_hw_get_parent(&zclk->hw)) /\n\t\t\t zclk->fixed_div;\n\treturn clk;\n}\n\nstatic struct clk * __init cpg_z_clk_register(const char *name,\n\t\t\t\t\t      const char *parent_name,\n\t\t\t\t\t      void __iomem *reg,\n\t\t\t\t\t      unsigned int div,\n\t\t\t\t\t      unsigned int offset)\n{\n\treturn __cpg_z_clk_register(name, parent_name, reg, div, offset,\n\t\t\t\t    CPG_FRQCRC, CLK_SET_RATE_PARENT);\n}\n\nstatic struct clk * __init cpg_zg_clk_register(const char *name,\n\t\t\t\t\t       const char *parent_name,\n\t\t\t\t\t       void __iomem *reg,\n\t\t\t\t\t       unsigned int div,\n\t\t\t\t\t       unsigned int offset)\n{\n\treturn __cpg_z_clk_register(name, parent_name, reg, div, offset,\n\t\t\t\t    CPG_FRQCRB, 0);\n\n}\n\nstatic const struct clk_div_table cpg_rpcsrc_div_table[] = {\n\t{ 2, 5 }, { 3, 6 }, { 0, 0 },\n};\n\nstatic const struct rcar_gen3_cpg_pll_config *cpg_pll_config __initdata;\nstatic unsigned int cpg_clk_extalr __initdata;\nstatic u32 cpg_mode __initdata;\nstatic u32 cpg_quirks __initdata;\n\n#define RCKCR_CKSEL\tBIT(1)\t\t \n\n\nstatic const struct soc_device_attribute cpg_quirks_match[] __initconst = {\n\t{\n\t\t.soc_id = \"r8a7796\", .revision = \"ES1.0\",\n\t\t.data = (void *)(RCKCR_CKSEL),\n\t},\n\t{   }\n};\n\nstruct clk * __init rcar_gen3_cpg_clk_register(struct device *dev,\n\tconst struct cpg_core_clk *core, const struct cpg_mssr_info *info,\n\tstruct clk **clks, void __iomem *base,\n\tstruct raw_notifier_head *notifiers)\n{\n\tconst struct clk *parent;\n\tunsigned int mult = 1;\n\tunsigned int div = 1;\n\tu32 value;\n\n\tparent = clks[core->parent & 0xffff];\t \n\tif (IS_ERR(parent))\n\t\treturn ERR_CAST(parent);\n\n\tswitch (core->type) {\n\tcase CLK_TYPE_GEN3_MAIN:\n\t\tdiv = cpg_pll_config->extal_div;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN3_PLL0:\n\t\t \n\t\treturn cpg_pll_clk_register(core->name, __clk_get_name(parent),\n\t\t\t\t\t    base, 2, CPG_PLL0CR, 0);\n\n\tcase CLK_TYPE_GEN3_PLL1:\n\t\tmult = cpg_pll_config->pll1_mult;\n\t\tdiv = cpg_pll_config->pll1_div;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN3_PLL2:\n\t\t \n\t\treturn cpg_pll_clk_register(core->name, __clk_get_name(parent),\n\t\t\t\t\t    base, 2, CPG_PLL2CR, 2);\n\n\tcase CLK_TYPE_GEN3_PLL3:\n\t\tmult = cpg_pll_config->pll3_mult;\n\t\tdiv = cpg_pll_config->pll3_div;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN3_PLL4:\n\t\t \n\t\tvalue = readl(base + CPG_PLL4CR);\n\t\tmult = (((value >> 24) & 0x7f) + 1) * 2;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN3_SDH:\n\t\treturn cpg_sdh_clk_register(core->name, base + core->offset,\n\t\t\t\t\t   __clk_get_name(parent), notifiers);\n\n\tcase CLK_TYPE_GEN3_SD:\n\t\treturn cpg_sd_clk_register(core->name, base + core->offset,\n\t\t\t\t\t   __clk_get_name(parent));\n\n\tcase CLK_TYPE_GEN3_R:\n\t\tif (cpg_quirks & RCKCR_CKSEL) {\n\t\t\tstruct cpg_simple_notifier *csn;\n\n\t\t\tcsn = kzalloc(sizeof(*csn), GFP_KERNEL);\n\t\t\tif (!csn)\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\t\tcsn->reg = base + CPG_RCKCR;\n\n\t\t\t \n\t\t\tvalue = readl(csn->reg) & 0x3f;\n\n\t\t\tif (clk_get_rate(clks[cpg_clk_extalr])) {\n\t\t\t\tparent = clks[cpg_clk_extalr];\n\t\t\t\tvalue |= CPG_RCKCR_CKSEL;\n\t\t\t}\n\n\t\t\twritel(value, csn->reg);\n\t\t\tcpg_simple_notifier_register(notifiers, csn);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (cpg_mode & BIT(28))\n\t\t\tparent = clks[cpg_clk_extalr];\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN3_MDSEL:\n\t\t \n\t\tif (cpg_mode & BIT(core->offset)) {\n\t\t\tdiv = core->div & 0xffff;\n\t\t} else {\n\t\t\tparent = clks[core->parent >> 16];\n\t\t\tif (IS_ERR(parent))\n\t\t\t\treturn ERR_CAST(parent);\n\t\t\tdiv = core->div >> 16;\n\t\t}\n\t\tmult = 1;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN3_Z:\n\t\treturn cpg_z_clk_register(core->name, __clk_get_name(parent),\n\t\t\t\t\t  base, core->div, core->offset);\n\n\tcase CLK_TYPE_GEN3_ZG:\n\t\treturn cpg_zg_clk_register(core->name, __clk_get_name(parent),\n\t\t\t\t\t   base, core->div, core->offset);\n\n\tcase CLK_TYPE_GEN3_OSC:\n\t\t \n\t\tdiv = cpg_pll_config->osc_prediv * core->div;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN3_RCKSEL:\n\t\t \n\t\tif (readl(base + CPG_RCKCR) & CPG_RCKCR_CKSEL) {\n\t\t\tdiv = core->div & 0xffff;\n\t\t} else {\n\t\t\tparent = clks[core->parent >> 16];\n\t\t\tif (IS_ERR(parent))\n\t\t\t\treturn ERR_CAST(parent);\n\t\t\tdiv = core->div >> 16;\n\t\t}\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN3_RPCSRC:\n\t\treturn clk_register_divider_table(NULL, core->name,\n\t\t\t\t\t\t  __clk_get_name(parent), 0,\n\t\t\t\t\t\t  base + CPG_RPCCKCR, 3, 2, 0,\n\t\t\t\t\t\t  cpg_rpcsrc_div_table,\n\t\t\t\t\t\t  &cpg_lock);\n\n\tcase CLK_TYPE_GEN3_E3_RPCSRC:\n\t\t \n\t\tvalue = (readl(base + CPG_RPCCKCR) & GENMASK(4, 3)) >> 3;\n\n\t\tswitch (value) {\n\t\tcase 0:\n\t\t\tdiv = 5;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdiv = 3;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tparent = clks[core->parent >> 16];\n\t\t\tif (IS_ERR(parent))\n\t\t\t\treturn ERR_CAST(parent);\n\t\t\tdiv = core->div;\n\t\t\tbreak;\n\t\tcase 3:\n\t\tdefault:\n\t\t\tdiv = 2;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN3_RPC:\n\t\treturn cpg_rpc_clk_register(core->name, base + CPG_RPCCKCR,\n\t\t\t\t\t    __clk_get_name(parent), notifiers);\n\n\tcase CLK_TYPE_GEN3_RPCD2:\n\t\treturn cpg_rpcd2_clk_register(core->name, base + CPG_RPCCKCR,\n\t\t\t\t\t      __clk_get_name(parent));\n\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn clk_register_fixed_factor(NULL, core->name,\n\t\t\t\t\t __clk_get_name(parent), 0, mult, div);\n}\n\nint __init rcar_gen3_cpg_init(const struct rcar_gen3_cpg_pll_config *config,\n\t\t\t      unsigned int clk_extalr, u32 mode)\n{\n\tconst struct soc_device_attribute *attr;\n\n\tcpg_pll_config = config;\n\tcpg_clk_extalr = clk_extalr;\n\tcpg_mode = mode;\n\tattr = soc_device_match(cpg_quirks_match);\n\tif (attr)\n\t\tcpg_quirks = (uintptr_t)attr->data;\n\tpr_debug(\"%s: mode = 0x%x quirks = 0x%x\\n\", __func__, mode, cpg_quirks);\n\n\tspin_lock_init(&cpg_lock);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}