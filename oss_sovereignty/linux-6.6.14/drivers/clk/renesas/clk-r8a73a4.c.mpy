{
  "module_name": "clk-r8a73a4.c",
  "hash_id": "b8f41c567af01f16f6d0aa4eb5051fad5f79530401938a7c550a9b6f88d43a6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/renesas/clk-r8a73a4.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk/renesas.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/spinlock.h>\n\nstruct r8a73a4_cpg {\n\tstruct clk_onecell_data data;\n\tspinlock_t lock;\n};\n\n#define CPG_CKSCR\t0xc0\n#define CPG_FRQCRA\t0x00\n#define CPG_FRQCRB\t0x04\n#define CPG_FRQCRC\t0xe0\n#define CPG_PLL0CR\t0xd8\n#define CPG_PLL1CR\t0x28\n#define CPG_PLL2CR\t0x2c\n#define CPG_PLL2HCR\t0xe4\n#define CPG_PLL2SCR\t0xf4\n\n#define CLK_ENABLE_ON_INIT BIT(0)\n\nstruct div4_clk {\n\tconst char *name;\n\tunsigned int reg;\n\tunsigned int shift;\n};\n\nstatic struct div4_clk div4_clks[] = {\n\t{ \"i\",\tCPG_FRQCRA, 20 },\n\t{ \"m3\", CPG_FRQCRA, 12 },\n\t{ \"b\",\tCPG_FRQCRA,  8 },\n\t{ \"m1\", CPG_FRQCRA,  4 },\n\t{ \"m2\", CPG_FRQCRA,  0 },\n\t{ \"zx\", CPG_FRQCRB, 12 },\n\t{ \"zs\", CPG_FRQCRB,  8 },\n\t{ \"hp\", CPG_FRQCRB,  4 },\n\t{ NULL, 0, 0 },\n};\n\nstatic const struct clk_div_table div4_div_table[] = {\n\t{ 0, 2 }, { 1, 3 }, { 2, 4 }, { 3, 6 }, { 4, 8 }, { 5, 12 },\n\t{ 6, 16 }, { 7, 18 }, { 8, 24 }, { 10, 36 }, { 11, 48 },\n\t{ 12, 10 }, { 0, 0 }\n};\n\nstatic struct clk * __init\nr8a73a4_cpg_register_clock(struct device_node *np, struct r8a73a4_cpg *cpg,\n\t\t\t   void __iomem *base, const char *name)\n{\n\tconst struct clk_div_table *table = NULL;\n\tconst char *parent_name;\n\tunsigned int shift, reg;\n\tunsigned int mult = 1;\n\tunsigned int div = 1;\n\n\n\tif (!strcmp(name, \"main\")) {\n\t\tu32 ckscr = readl(base + CPG_CKSCR);\n\n\t\tswitch ((ckscr >> 28) & 3) {\n\t\tcase 0:\t \n\t\t\tparent_name = of_clk_get_parent_name(np, 0);\n\t\t\tbreak;\n\t\tcase 1:\t \n\t\t\tparent_name = of_clk_get_parent_name(np, 0);\n\t\t\tdiv = 2;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tparent_name = of_clk_get_parent_name(np, 1);\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tparent_name = of_clk_get_parent_name(np, 1);\n\t\t\tdiv = 2;\n\t\t\tbreak;\n\t\t}\n\t} else if (!strcmp(name, \"pll0\")) {\n\t\t \n\t\tu32 value = readl(base + CPG_PLL0CR);\n\n\t\tparent_name = \"main\";\n\t\tmult = ((value >> 24) & 0x7f) + 1;\n\t\tif (value & BIT(20))\n\t\t\tdiv = 2;\n\t} else if (!strcmp(name, \"pll1\")) {\n\t\tu32 value = readl(base + CPG_PLL1CR);\n\n\t\tparent_name = \"main\";\n\t\t \n\t\tmult = ((value >> 24) & 0x7f) + 1;\n\t\tif (value & BIT(7))\n\t\t\tdiv = 2;\n\t} else if (!strncmp(name, \"pll2\", 4)) {\n\t\tu32 value, cr;\n\n\t\tswitch (name[4]) {\n\t\tcase 0:\n\t\t\tcr = CPG_PLL2CR;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tcr = CPG_PLL2SCR;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tcr = CPG_PLL2HCR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tvalue = readl(base + cr);\n\t\tswitch ((value >> 5) & 7) {\n\t\tcase 0:\n\t\t\tparent_name = \"main\";\n\t\t\tdiv = 2;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tparent_name = \"extal2\";\n\t\t\tdiv = 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tparent_name = \"extal2\";\n\t\t\tdiv = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tparent_name = \"main\";\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tparent_name = \"extal2\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"%s: unexpected parent of %s\\n\", __func__,\n\t\t\t\tname);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\t \n\t\tmult = ((value >> 24) & 0x7f) + 1;\n\t} else if (!strcmp(name, \"z\") || !strcmp(name, \"z2\")) {\n\t\tu32 shift = 8;\n\n\t\tparent_name = \"pll0\";\n\t\tif (name[1] == '2') {\n\t\t\tdiv = 2;\n\t\t\tshift = 0;\n\t\t}\n\t\tdiv *= 32;\n\t\tmult = 0x20 - ((readl(base + CPG_FRQCRC) >> shift) & 0x1f);\n\t} else {\n\t\tstruct div4_clk *c;\n\n\t\tfor (c = div4_clks; c->name; c++) {\n\t\t\tif (!strcmp(name, c->name))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!c->name)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tparent_name = \"pll1\";\n\t\ttable = div4_div_table;\n\t\treg = c->reg;\n\t\tshift = c->shift;\n\t}\n\n\tif (!table) {\n\t\treturn clk_register_fixed_factor(NULL, name, parent_name, 0,\n\t\t\t\t\t\t mult, div);\n\t} else {\n\t\treturn clk_register_divider_table(NULL, name, parent_name, 0,\n\t\t\t\t\t\t  base + reg, shift, 4, 0,\n\t\t\t\t\t\t  table, &cpg->lock);\n\t}\n}\n\nstatic void __init r8a73a4_cpg_clocks_init(struct device_node *np)\n{\n\tstruct r8a73a4_cpg *cpg;\n\tvoid __iomem *base;\n\tstruct clk **clks;\n\tunsigned int i;\n\tint num_clks;\n\n\tnum_clks = of_property_count_strings(np, \"clock-output-names\");\n\tif (num_clks < 0) {\n\t\tpr_err(\"%s: failed to count clocks\\n\", __func__);\n\t\treturn;\n\t}\n\n\tcpg = kzalloc(sizeof(*cpg), GFP_KERNEL);\n\tclks = kcalloc(num_clks, sizeof(*clks), GFP_KERNEL);\n\tif (cpg == NULL || clks == NULL) {\n\t\t \n\t\treturn;\n\t}\n\n\tspin_lock_init(&cpg->lock);\n\n\tcpg->data.clks = clks;\n\tcpg->data.clk_num = num_clks;\n\n\tbase = of_iomap(np, 0);\n\tif (WARN_ON(base == NULL))\n\t\treturn;\n\n\tfor (i = 0; i < num_clks; ++i) {\n\t\tconst char *name;\n\t\tstruct clk *clk;\n\n\t\tof_property_read_string_index(np, \"clock-output-names\", i,\n\t\t\t\t\t      &name);\n\n\t\tclk = r8a73a4_cpg_register_clock(np, cpg, base, name);\n\t\tif (IS_ERR(clk))\n\t\t\tpr_err(\"%s: failed to register %pOFn %s clock (%ld)\\n\",\n\t\t\t       __func__, np, name, PTR_ERR(clk));\n\t\telse\n\t\t\tcpg->data.clks[i] = clk;\n\t}\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &cpg->data);\n}\nCLK_OF_DECLARE(r8a73a4_cpg_clks, \"renesas,r8a73a4-cpg-clocks\",\n\t       r8a73a4_cpg_clocks_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}