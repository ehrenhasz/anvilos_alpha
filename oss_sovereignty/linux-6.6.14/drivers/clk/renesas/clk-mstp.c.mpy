{
  "module_name": "clk-mstp.c",
  "hash_id": "403208648e6c59b09b21fbe04b4e6c5ae8d2652c25c17c2b47b230ef2403f270",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/renesas/clk-mstp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/renesas.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_domain.h>\n#include <linux/spinlock.h>\n\n \n\n#define MSTP_MAX_CLOCKS\t\t32\n\n \nstruct mstp_clock_group {\n\tstruct clk_onecell_data data;\n\tvoid __iomem *smstpcr;\n\tvoid __iomem *mstpsr;\n\tspinlock_t lock;\n\tbool width_8bit;\n\tstruct clk *clks[];\n};\n\n \nstruct mstp_clock {\n\tstruct clk_hw hw;\n\tu32 bit_index;\n\tstruct mstp_clock_group *group;\n};\n\n#define to_mstp_clock(_hw) container_of(_hw, struct mstp_clock, hw)\n\nstatic inline u32 cpg_mstp_read(struct mstp_clock_group *group,\n\t\t\t\tu32 __iomem *reg)\n{\n\treturn group->width_8bit ? readb(reg) : readl(reg);\n}\n\nstatic inline void cpg_mstp_write(struct mstp_clock_group *group, u32 val,\n\t\t\t\t  u32 __iomem *reg)\n{\n\tgroup->width_8bit ? writeb(val, reg) : writel(val, reg);\n}\n\nstatic int cpg_mstp_clock_endisable(struct clk_hw *hw, bool enable)\n{\n\tstruct mstp_clock *clock = to_mstp_clock(hw);\n\tstruct mstp_clock_group *group = clock->group;\n\tu32 bitmask = BIT(clock->bit_index);\n\tunsigned long flags;\n\tu32 value;\n\tint ret;\n\n\tspin_lock_irqsave(&group->lock, flags);\n\n\tvalue = cpg_mstp_read(group, group->smstpcr);\n\tif (enable)\n\t\tvalue &= ~bitmask;\n\telse\n\t\tvalue |= bitmask;\n\tcpg_mstp_write(group, value, group->smstpcr);\n\n\tif (!group->mstpsr) {\n\t\t \n\t\tcpg_mstp_read(group, group->smstpcr);\n\t\tbarrier_data(group->smstpcr);\n\t}\n\n\tspin_unlock_irqrestore(&group->lock, flags);\n\n\tif (!enable || !group->mstpsr)\n\t\treturn 0;\n\n\t \n\tret = readl_poll_timeout_atomic(group->mstpsr, value,\n\t\t\t\t\t!(value & bitmask), 0, 10);\n\tif (ret)\n\t\tpr_err(\"%s: failed to enable %p[%d]\\n\", __func__,\n\t\t       group->smstpcr, clock->bit_index);\n\n\treturn ret;\n}\n\nstatic int cpg_mstp_clock_enable(struct clk_hw *hw)\n{\n\treturn cpg_mstp_clock_endisable(hw, true);\n}\n\nstatic void cpg_mstp_clock_disable(struct clk_hw *hw)\n{\n\tcpg_mstp_clock_endisable(hw, false);\n}\n\nstatic int cpg_mstp_clock_is_enabled(struct clk_hw *hw)\n{\n\tstruct mstp_clock *clock = to_mstp_clock(hw);\n\tstruct mstp_clock_group *group = clock->group;\n\tu32 value;\n\n\tif (group->mstpsr)\n\t\tvalue = cpg_mstp_read(group, group->mstpsr);\n\telse\n\t\tvalue = cpg_mstp_read(group, group->smstpcr);\n\n\treturn !(value & BIT(clock->bit_index));\n}\n\nstatic const struct clk_ops cpg_mstp_clock_ops = {\n\t.enable = cpg_mstp_clock_enable,\n\t.disable = cpg_mstp_clock_disable,\n\t.is_enabled = cpg_mstp_clock_is_enabled,\n};\n\nstatic struct clk * __init cpg_mstp_clock_register(const char *name,\n\tconst char *parent_name, unsigned int index,\n\tstruct mstp_clock_group *group)\n{\n\tstruct clk_init_data init = {};\n\tstruct mstp_clock *clock;\n\tstruct clk *clk;\n\n\tclock = kzalloc(sizeof(*clock), GFP_KERNEL);\n\tif (!clock)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &cpg_mstp_clock_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\t \n\tif (!strcmp(name, \"intc-sys\")) {\n\t\tpr_debug(\"MSTP %s setting CLK_IS_CRITICAL\\n\", name);\n\t\tinit.flags |= CLK_IS_CRITICAL;\n\t}\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tclock->bit_index = index;\n\tclock->group = group;\n\tclock->hw.init = &init;\n\n\tclk = clk_register(NULL, &clock->hw);\n\n\tif (IS_ERR(clk))\n\t\tkfree(clock);\n\n\treturn clk;\n}\n\nstatic void __init cpg_mstp_clocks_init(struct device_node *np)\n{\n\tstruct mstp_clock_group *group;\n\tconst char *idxname;\n\tstruct clk **clks;\n\tunsigned int i;\n\n\tgroup = kzalloc(struct_size(group, clks, MSTP_MAX_CLOCKS), GFP_KERNEL);\n\tif (!group)\n\t\treturn;\n\n\tclks = group->clks;\n\tspin_lock_init(&group->lock);\n\tgroup->data.clks = clks;\n\n\tgroup->smstpcr = of_iomap(np, 0);\n\tgroup->mstpsr = of_iomap(np, 1);\n\n\tif (group->smstpcr == NULL) {\n\t\tpr_err(\"%s: failed to remap SMSTPCR\\n\", __func__);\n\t\tkfree(group);\n\t\treturn;\n\t}\n\n\tif (of_device_is_compatible(np, \"renesas,r7s72100-mstp-clocks\"))\n\t\tgroup->width_8bit = true;\n\n\tfor (i = 0; i < MSTP_MAX_CLOCKS; ++i)\n\t\tclks[i] = ERR_PTR(-ENOENT);\n\n\tif (of_find_property(np, \"clock-indices\", &i))\n\t\tidxname = \"clock-indices\";\n\telse\n\t\tidxname = \"renesas,clock-indices\";\n\n\tfor (i = 0; i < MSTP_MAX_CLOCKS; ++i) {\n\t\tconst char *parent_name;\n\t\tconst char *name;\n\t\tu32 clkidx;\n\t\tint ret;\n\n\t\t \n\t\tret = of_property_read_string_index(np, \"clock-output-names\",\n\t\t\t\t\t\t    i, &name);\n\t\tif (ret < 0 || strlen(name) == 0)\n\t\t\tcontinue;\n\n\t\tparent_name = of_clk_get_parent_name(np, i);\n\t\tret = of_property_read_u32_index(np, idxname, i, &clkidx);\n\t\tif (parent_name == NULL || ret < 0)\n\t\t\tbreak;\n\n\t\tif (clkidx >= MSTP_MAX_CLOCKS) {\n\t\t\tpr_err(\"%s: invalid clock %pOFn %s index %u\\n\",\n\t\t\t       __func__, np, name, clkidx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tclks[clkidx] = cpg_mstp_clock_register(name, parent_name,\n\t\t\t\t\t\t       clkidx, group);\n\t\tif (!IS_ERR(clks[clkidx])) {\n\t\t\tgroup->data.clk_num = max(group->data.clk_num,\n\t\t\t\t\t\t  clkidx + 1);\n\t\t\t \n\t\t\tclk_register_clkdev(clks[clkidx], name, NULL);\n\t\t} else {\n\t\t\tpr_err(\"%s: failed to register %pOFn %s clock (%ld)\\n\",\n\t\t\t       __func__, np, name, PTR_ERR(clks[clkidx]));\n\t\t}\n\t}\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &group->data);\n}\nCLK_OF_DECLARE(cpg_mstp_clks, \"renesas,cpg-mstp-clocks\", cpg_mstp_clocks_init);\n\nint cpg_mstp_attach_dev(struct generic_pm_domain *unused, struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct of_phandle_args clkspec;\n\tstruct clk *clk;\n\tint i = 0;\n\tint error;\n\n\twhile (!of_parse_phandle_with_args(np, \"clocks\", \"#clock-cells\", i,\n\t\t\t\t\t   &clkspec)) {\n\t\tif (of_device_is_compatible(clkspec.np,\n\t\t\t\t\t    \"renesas,cpg-mstp-clocks\"))\n\t\t\tgoto found;\n\n\t\t \n\t\tif (of_node_name_eq(clkspec.np, \"zb_clk\"))\n\t\t\tgoto found;\n\n\t\tof_node_put(clkspec.np);\n\t\ti++;\n\t}\n\n\treturn 0;\n\nfound:\n\tclk = of_clk_get_from_provider(&clkspec);\n\tof_node_put(clkspec.np);\n\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\terror = pm_clk_create(dev);\n\tif (error)\n\t\tgoto fail_put;\n\n\terror = pm_clk_add_clk(dev, clk);\n\tif (error)\n\t\tgoto fail_destroy;\n\n\treturn 0;\n\nfail_destroy:\n\tpm_clk_destroy(dev);\nfail_put:\n\tclk_put(clk);\n\treturn error;\n}\n\nvoid cpg_mstp_detach_dev(struct generic_pm_domain *unused, struct device *dev)\n{\n\tif (!pm_clk_no_clocks(dev))\n\t\tpm_clk_destroy(dev);\n}\n\nvoid __init cpg_mstp_add_clk_domain(struct device_node *np)\n{\n\tstruct generic_pm_domain *pd;\n\tu32 ncells;\n\n\tif (of_property_read_u32(np, \"#power-domain-cells\", &ncells)) {\n\t\tpr_warn(\"%pOF lacks #power-domain-cells\\n\", np);\n\t\treturn;\n\t}\n\n\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn;\n\n\tpd->name = np->name;\n\tpd->flags = GENPD_FLAG_PM_CLK | GENPD_FLAG_ALWAYS_ON |\n\t\t    GENPD_FLAG_ACTIVE_WAKEUP;\n\tpd->attach_dev = cpg_mstp_attach_dev;\n\tpd->detach_dev = cpg_mstp_detach_dev;\n\tpm_genpd_init(pd, &pm_domain_always_on_gov, false);\n\n\tof_genpd_add_provider_simple(np, pd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}