{
  "module_name": "clk-sh73a0.c",
  "hash_id": "6c0df1c35194f8fc0d4b4a0ad8b2bf1acba7f0fce1aa60040dbb0ac442960cdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/renesas/clk-sh73a0.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk/renesas.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\nstruct sh73a0_cpg {\n\tstruct clk_onecell_data data;\n\tspinlock_t lock;\n};\n\n#define CPG_FRQCRA\t0x00\n#define CPG_FRQCRB\t0x04\n#define CPG_SD0CKCR\t0x74\n#define CPG_SD1CKCR\t0x78\n#define CPG_SD2CKCR\t0x7c\n#define CPG_PLLECR\t0xd0\n#define CPG_PLL0CR\t0xd8\n#define CPG_PLL1CR\t0x28\n#define CPG_PLL2CR\t0x2c\n#define CPG_PLL3CR\t0xdc\n#define CPG_CKSCR\t0xc0\n#define CPG_DSI0PHYCR\t0x6c\n#define CPG_DSI1PHYCR\t0x70\n\n#define CLK_ENABLE_ON_INIT BIT(0)\n\nstruct div4_clk {\n\tconst char *name;\n\tconst char *parent;\n\tunsigned int reg;\n\tunsigned int shift;\n};\n\nstatic const struct div4_clk div4_clks[] = {\n\t{ \"zg\", \"pll0\", CPG_FRQCRA, 16 },\n\t{ \"m3\", \"pll1\", CPG_FRQCRA, 12 },\n\t{ \"b\",  \"pll1\", CPG_FRQCRA,  8 },\n\t{ \"m1\", \"pll1\", CPG_FRQCRA,  4 },\n\t{ \"m2\", \"pll1\", CPG_FRQCRA,  0 },\n\t{ \"zx\", \"pll1\", CPG_FRQCRB, 12 },\n\t{ \"hp\", \"pll1\", CPG_FRQCRB,  4 },\n\t{ NULL, NULL, 0, 0 },\n};\n\nstatic const struct clk_div_table div4_div_table[] = {\n\t{ 0, 2 }, { 1, 3 }, { 2, 4 }, { 3, 6 }, { 4, 8 }, { 5, 12 },\n\t{ 6, 16 }, { 7, 18 }, { 8, 24 }, { 10, 36 }, { 11, 48 },\n\t{ 12, 7 }, { 0, 0 }\n};\n\nstatic const struct clk_div_table z_div_table[] = {\n\t \n\t{ 0, 1 }, { 1, 1 }, { 2, 1 }, { 3, 1 }, { 4, 1 }, { 5, 1 },\n\t{ 6, 1 }, { 7, 1 }, { 8, 1 }, { 9, 1 }, { 10, 1 }, { 11, 1 },\n\t{ 12, 1 }, { 13, 1 }, { 14, 1 }, { 15, 1 },\n\t \n\t{ 16, 2 }, { 17, 3 }, { 18, 4 }, { 19, 6 }, { 20, 8 }, { 21, 12 },\n\t{ 22, 16 }, { 24, 24 }, { 27, 48 }, { 0, 0 }\n};\n\nstatic struct clk * __init\nsh73a0_cpg_register_clock(struct device_node *np, struct sh73a0_cpg *cpg,\n\t\t\t  void __iomem *base, const char *name)\n{\n\tconst struct clk_div_table *table = NULL;\n\tunsigned int shift, reg, width;\n\tconst char *parent_name = NULL;\n\tunsigned int mult = 1;\n\tunsigned int div = 1;\n\n\tif (!strcmp(name, \"main\")) {\n\t\t \n\t\tu32 parent_idx = (readl(base + CPG_CKSCR) >> 28) & 3;\n\n\t\tparent_name = of_clk_get_parent_name(np, parent_idx >> 1);\n\t\tdiv = (parent_idx & 1) + 1;\n\t} else if (!strncmp(name, \"pll\", 3)) {\n\t\tvoid __iomem *enable_reg = base;\n\t\tu32 enable_bit = name[3] - '0';\n\n\t\tparent_name = \"main\";\n\t\tswitch (enable_bit) {\n\t\tcase 0:\n\t\t\tenable_reg += CPG_PLL0CR;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tenable_reg += CPG_PLL1CR;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tenable_reg += CPG_PLL2CR;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tenable_reg += CPG_PLL3CR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tif (readl(base + CPG_PLLECR) & BIT(enable_bit)) {\n\t\t\tmult = ((readl(enable_reg) >> 24) & 0x3f) + 1;\n\t\t\t \n\t\t\tif (enable_bit == 1 || enable_bit == 2)\n\t\t\t\tif (readl(enable_reg) & BIT(20))\n\t\t\t\t\tmult *= 2;\n\t\t}\n\t} else if (!strcmp(name, \"dsi0phy\") || !strcmp(name, \"dsi1phy\")) {\n\t\tu32 phy_no = name[3] - '0';\n\t\tvoid __iomem *dsi_reg = base +\n\t\t\t(phy_no ? CPG_DSI1PHYCR : CPG_DSI0PHYCR);\n\n\t\tparent_name = phy_no ? \"dsi1pck\" : \"dsi0pck\";\n\t\tmult = readl(dsi_reg);\n\t\tif (!(mult & 0x8000))\n\t\t\tmult = 1;\n\t\telse\n\t\t\tmult = (mult & 0x3f) + 1;\n\t} else if (!strcmp(name, \"z\")) {\n\t\tparent_name = \"pll0\";\n\t\ttable = z_div_table;\n\t\treg = CPG_FRQCRB;\n\t\tshift = 24;\n\t\twidth = 5;\n\t} else {\n\t\tconst struct div4_clk *c;\n\n\t\tfor (c = div4_clks; c->name; c++) {\n\t\t\tif (!strcmp(name, c->name)) {\n\t\t\t\tparent_name = c->parent;\n\t\t\t\ttable = div4_div_table;\n\t\t\t\treg = c->reg;\n\t\t\t\tshift = c->shift;\n\t\t\t\twidth = 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!c->name)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!table) {\n\t\treturn clk_register_fixed_factor(NULL, name, parent_name, 0,\n\t\t\t\t\t\t mult, div);\n\t} else {\n\t\treturn clk_register_divider_table(NULL, name, parent_name, 0,\n\t\t\t\t\t\t  base + reg, shift, width, 0,\n\t\t\t\t\t\t  table, &cpg->lock);\n\t}\n}\n\nstatic void __init sh73a0_cpg_clocks_init(struct device_node *np)\n{\n\tstruct sh73a0_cpg *cpg;\n\tvoid __iomem *base;\n\tstruct clk **clks;\n\tunsigned int i;\n\tint num_clks;\n\n\tnum_clks = of_property_count_strings(np, \"clock-output-names\");\n\tif (num_clks < 0) {\n\t\tpr_err(\"%s: failed to count clocks\\n\", __func__);\n\t\treturn;\n\t}\n\n\tcpg = kzalloc(sizeof(*cpg), GFP_KERNEL);\n\tclks = kcalloc(num_clks, sizeof(*clks), GFP_KERNEL);\n\tif (cpg == NULL || clks == NULL) {\n\t\t \n\t\treturn;\n\t}\n\n\tspin_lock_init(&cpg->lock);\n\n\tcpg->data.clks = clks;\n\tcpg->data.clk_num = num_clks;\n\n\tbase = of_iomap(np, 0);\n\tif (WARN_ON(base == NULL))\n\t\treturn;\n\n\t \n\twritel(0x108, base + CPG_SD0CKCR);\n\twritel(0x108, base + CPG_SD1CKCR);\n\twritel(0x108, base + CPG_SD2CKCR);\n\n\tfor (i = 0; i < num_clks; ++i) {\n\t\tconst char *name;\n\t\tstruct clk *clk;\n\n\t\tof_property_read_string_index(np, \"clock-output-names\", i,\n\t\t\t\t\t      &name);\n\n\t\tclk = sh73a0_cpg_register_clock(np, cpg, base, name);\n\t\tif (IS_ERR(clk))\n\t\t\tpr_err(\"%s: failed to register %pOFn %s clock (%ld)\\n\",\n\t\t\t       __func__, np, name, PTR_ERR(clk));\n\t\telse\n\t\t\tcpg->data.clks[i] = clk;\n\t}\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &cpg->data);\n}\nCLK_OF_DECLARE(sh73a0_cpg_clks, \"renesas,sh73a0-cpg-clocks\",\n\t       sh73a0_cpg_clocks_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}