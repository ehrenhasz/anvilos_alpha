{
  "module_name": "clk-r8a7740.c",
  "hash_id": "eeaed3b7fffa1c16152c028ef214ebf1adab5db45688065f6863675cca536ebd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/renesas/clk-r8a7740.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk/renesas.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/spinlock.h>\n\nstruct r8a7740_cpg {\n\tstruct clk_onecell_data data;\n\tspinlock_t lock;\n};\n\n#define CPG_FRQCRA\t0x00\n#define CPG_FRQCRB\t0x04\n#define CPG_PLLC2CR\t0x2c\n#define CPG_USBCKCR\t0x8c\n#define CPG_FRQCRC\t0xe0\n\n#define CLK_ENABLE_ON_INIT BIT(0)\n\nstruct div4_clk {\n\tconst char *name;\n\tunsigned int reg;\n\tunsigned int shift;\n\tint flags;\n};\n\nstatic struct div4_clk div4_clks[] = {\n\t{ \"i\", CPG_FRQCRA, 20, CLK_ENABLE_ON_INIT },\n\t{ \"zg\", CPG_FRQCRA, 16, CLK_ENABLE_ON_INIT },\n\t{ \"b\", CPG_FRQCRA,  8, CLK_ENABLE_ON_INIT },\n\t{ \"m1\", CPG_FRQCRA,  4, CLK_ENABLE_ON_INIT },\n\t{ \"hp\", CPG_FRQCRB,  4, 0 },\n\t{ \"hpp\", CPG_FRQCRC, 20, 0 },\n\t{ \"usbp\", CPG_FRQCRC, 16, 0 },\n\t{ \"s\", CPG_FRQCRC, 12, 0 },\n\t{ \"zb\", CPG_FRQCRC,  8, 0 },\n\t{ \"m3\", CPG_FRQCRC,  4, 0 },\n\t{ \"cp\", CPG_FRQCRC,  0, 0 },\n\t{ NULL, 0, 0, 0 },\n};\n\nstatic const struct clk_div_table div4_div_table[] = {\n\t{ 0, 2 }, { 1, 3 }, { 2, 4 }, { 3, 6 }, { 4, 8 }, { 5, 12 },\n\t{ 6, 16 }, { 7, 18 }, { 8, 24 }, { 9, 32 }, { 10, 36 }, { 11, 48 },\n\t{ 13, 72 }, { 14, 96 }, { 0, 0 }\n};\n\nstatic u32 cpg_mode __initdata;\n\nstatic struct clk * __init\nr8a7740_cpg_register_clock(struct device_node *np, struct r8a7740_cpg *cpg,\n\t\t\t   void __iomem *base, const char *name)\n{\n\tconst struct clk_div_table *table = NULL;\n\tconst char *parent_name;\n\tunsigned int shift, reg;\n\tunsigned int mult = 1;\n\tunsigned int div = 1;\n\n\tif (!strcmp(name, \"r\")) {\n\t\tswitch (cpg_mode & (BIT(2) | BIT(1))) {\n\t\tcase BIT(1) | BIT(2):\n\t\t\t \n\t\t\tparent_name = of_clk_get_parent_name(np, 0);\n\t\t\tdiv = 2048;\n\t\t\tbreak;\n\t\tcase BIT(2):\n\t\t\t \n\t\t\tparent_name = of_clk_get_parent_name(np, 0);\n\t\t\tdiv = 1024;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tparent_name = of_clk_get_parent_name(np, 2);\n\t\t\tbreak;\n\t\t}\n\t} else if (!strcmp(name, \"system\")) {\n\t\tparent_name = of_clk_get_parent_name(np, 0);\n\t\tif (cpg_mode & BIT(1))\n\t\t\tdiv = 2;\n\t} else if (!strcmp(name, \"pllc0\")) {\n\t\t \n\t\tu32 value = readl(base + CPG_FRQCRC);\n\t\tparent_name = \"system\";\n\t\tmult = ((value >> 24) & 0x7f) + 1;\n\t} else if (!strcmp(name, \"pllc1\")) {\n\t\tu32 value = readl(base + CPG_FRQCRA);\n\t\tparent_name = \"system\";\n\t\tmult = ((value >> 24) & 0x7f) + 1;\n\t\tdiv = 2;\n\t} else if (!strcmp(name, \"pllc2\")) {\n\t\tu32 value = readl(base + CPG_PLLC2CR);\n\t\tparent_name = \"system\";\n\t\tmult = ((value >> 24) & 0x3f) + 1;\n\t} else if (!strcmp(name, \"usb24s\")) {\n\t\tu32 value = readl(base + CPG_USBCKCR);\n\t\tif (value & BIT(7))\n\t\t\t \n\t\t\tparent_name = of_clk_get_parent_name(np, 1);\n\t\telse\n\t\t\tparent_name = \"system\";\n\t\tif (!(value & BIT(6)))\n\t\t\tdiv = 2;\n\t} else {\n\t\tstruct div4_clk *c;\n\t\tfor (c = div4_clks; c->name; c++) {\n\t\t\tif (!strcmp(name, c->name)) {\n\t\t\t\tparent_name = \"pllc1\";\n\t\t\t\ttable = div4_div_table;\n\t\t\t\treg = c->reg;\n\t\t\t\tshift = c->shift;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!c->name)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!table) {\n\t\treturn clk_register_fixed_factor(NULL, name, parent_name, 0,\n\t\t\t\t\t\t mult, div);\n\t} else {\n\t\treturn clk_register_divider_table(NULL, name, parent_name, 0,\n\t\t\t\t\t\t  base + reg, shift, 4, 0,\n\t\t\t\t\t\t  table, &cpg->lock);\n\t}\n}\n\nstatic void __init r8a7740_cpg_clocks_init(struct device_node *np)\n{\n\tstruct r8a7740_cpg *cpg;\n\tvoid __iomem *base;\n\tstruct clk **clks;\n\tunsigned int i;\n\tint num_clks;\n\n\tif (of_property_read_u32(np, \"renesas,mode\", &cpg_mode))\n\t\tpr_warn(\"%s: missing renesas,mode property\\n\", __func__);\n\n\tnum_clks = of_property_count_strings(np, \"clock-output-names\");\n\tif (num_clks < 0) {\n\t\tpr_err(\"%s: failed to count clocks\\n\", __func__);\n\t\treturn;\n\t}\n\n\tcpg = kzalloc(sizeof(*cpg), GFP_KERNEL);\n\tclks = kcalloc(num_clks, sizeof(*clks), GFP_KERNEL);\n\tif (cpg == NULL || clks == NULL) {\n\t\t \n\t\treturn;\n\t}\n\n\tspin_lock_init(&cpg->lock);\n\n\tcpg->data.clks = clks;\n\tcpg->data.clk_num = num_clks;\n\n\tbase = of_iomap(np, 0);\n\tif (WARN_ON(base == NULL))\n\t\treturn;\n\n\tfor (i = 0; i < num_clks; ++i) {\n\t\tconst char *name;\n\t\tstruct clk *clk;\n\n\t\tof_property_read_string_index(np, \"clock-output-names\", i,\n\t\t\t\t\t      &name);\n\n\t\tclk = r8a7740_cpg_register_clock(np, cpg, base, name);\n\t\tif (IS_ERR(clk))\n\t\t\tpr_err(\"%s: failed to register %pOFn %s clock (%ld)\\n\",\n\t\t\t       __func__, np, name, PTR_ERR(clk));\n\t\telse\n\t\t\tcpg->data.clks[i] = clk;\n\t}\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &cpg->data);\n}\nCLK_OF_DECLARE(r8a7740_cpg_clks, \"renesas,r8a7740-cpg-clocks\",\n\t       r8a7740_cpg_clocks_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}