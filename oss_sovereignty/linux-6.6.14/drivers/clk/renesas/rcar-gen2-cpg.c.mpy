{
  "module_name": "rcar-gen2-cpg.c",
  "hash_id": "bdc99cfa1c667f660ce50403548c10ed9334790dca2733f06685b19f4945c78a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/renesas/rcar-gen2-cpg.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/sys_soc.h>\n\n#include \"renesas-cpg-mssr.h\"\n#include \"rcar-gen2-cpg.h\"\n\n#define CPG_FRQCRB\t\t0x0004\n#define CPG_FRQCRB_KICK\t\tBIT(31)\n#define CPG_SDCKCR\t\t0x0074\n#define CPG_PLL0CR\t\t0x00d8\n#define CPG_PLL0CR_STC_SHIFT\t24\n#define CPG_PLL0CR_STC_MASK\t(0x7f << CPG_PLL0CR_STC_SHIFT)\n#define CPG_FRQCRC\t\t0x00e0\n#define CPG_FRQCRC_ZFC_SHIFT\t8\n#define CPG_FRQCRC_ZFC_MASK\t(0x1f << CPG_FRQCRC_ZFC_SHIFT)\n#define CPG_ADSPCKCR\t\t0x025c\n#define CPG_RCANCKCR\t\t0x0270\n\nstatic spinlock_t cpg_lock;\n\n \n\nstruct cpg_z_clk {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n\tvoid __iomem *kick_reg;\n};\n\n#define to_z_clk(_hw)\tcontainer_of(_hw, struct cpg_z_clk, hw)\n\nstatic unsigned long cpg_z_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct cpg_z_clk *zclk = to_z_clk(hw);\n\tunsigned int mult;\n\tunsigned int val;\n\n\tval = (readl(zclk->reg) & CPG_FRQCRC_ZFC_MASK) >> CPG_FRQCRC_ZFC_SHIFT;\n\tmult = 32 - val;\n\n\treturn div_u64((u64)parent_rate * mult, 32);\n}\n\nstatic int cpg_z_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t    struct clk_rate_request *req)\n{\n\tunsigned long prate = req->best_parent_rate;\n\tunsigned int min_mult, max_mult, mult;\n\n\tmin_mult = max(div64_ul(req->min_rate * 32ULL, prate), 1ULL);\n\tmax_mult = min(div64_ul(req->max_rate * 32ULL, prate), 32ULL);\n\tif (max_mult < min_mult)\n\t\treturn -EINVAL;\n\n\tmult = div64_ul(req->rate * 32ULL, prate);\n\tmult = clamp(mult, min_mult, max_mult);\n\n\treq->rate = div_u64((u64)prate * mult, 32);\n\treturn 0;\n}\n\nstatic int cpg_z_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct cpg_z_clk *zclk = to_z_clk(hw);\n\tunsigned int mult;\n\tu32 val, kick;\n\tunsigned int i;\n\n\tmult = div64_ul(rate * 32ULL, parent_rate);\n\tmult = clamp(mult, 1U, 32U);\n\n\tif (readl(zclk->kick_reg) & CPG_FRQCRB_KICK)\n\t\treturn -EBUSY;\n\n\tval = readl(zclk->reg);\n\tval &= ~CPG_FRQCRC_ZFC_MASK;\n\tval |= (32 - mult) << CPG_FRQCRC_ZFC_SHIFT;\n\twritel(val, zclk->reg);\n\n\t \n\tkick = readl(zclk->kick_reg);\n\tkick |= CPG_FRQCRB_KICK;\n\twritel(kick, zclk->kick_reg);\n\n\t \n\tfor (i = 1000; i; i--) {\n\t\tif (!(readl(zclk->kick_reg) & CPG_FRQCRB_KICK))\n\t\t\treturn 0;\n\n\t\tcpu_relax();\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic const struct clk_ops cpg_z_clk_ops = {\n\t.recalc_rate = cpg_z_clk_recalc_rate,\n\t.determine_rate = cpg_z_clk_determine_rate,\n\t.set_rate = cpg_z_clk_set_rate,\n};\n\nstatic struct clk * __init cpg_z_clk_register(const char *name,\n\t\t\t\t\t      const char *parent_name,\n\t\t\t\t\t      void __iomem *base)\n{\n\tstruct clk_init_data init = {};\n\tstruct cpg_z_clk *zclk;\n\tstruct clk *clk;\n\n\tzclk = kzalloc(sizeof(*zclk), GFP_KERNEL);\n\tif (!zclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &cpg_z_clk_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tzclk->reg = base + CPG_FRQCRC;\n\tzclk->kick_reg = base + CPG_FRQCRB;\n\tzclk->hw.init = &init;\n\n\tclk = clk_register(NULL, &zclk->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(zclk);\n\n\treturn clk;\n}\n\nstatic struct clk * __init cpg_rcan_clk_register(const char *name,\n\t\t\t\t\t\t const char *parent_name,\n\t\t\t\t\t\t void __iomem *base)\n{\n\tstruct clk_fixed_factor *fixed;\n\tstruct clk_gate *gate;\n\tstruct clk *clk;\n\n\tfixed = kzalloc(sizeof(*fixed), GFP_KERNEL);\n\tif (!fixed)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfixed->mult = 1;\n\tfixed->div = 6;\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate) {\n\t\tkfree(fixed);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tgate->reg = base + CPG_RCANCKCR;\n\tgate->bit_idx = 8;\n\tgate->flags = CLK_GATE_SET_TO_DISABLE;\n\tgate->lock = &cpg_lock;\n\n\tclk = clk_register_composite(NULL, name, &parent_name, 1, NULL, NULL,\n\t\t\t\t     &fixed->hw, &clk_fixed_factor_ops,\n\t\t\t\t     &gate->hw, &clk_gate_ops, 0);\n\tif (IS_ERR(clk)) {\n\t\tkfree(gate);\n\t\tkfree(fixed);\n\t}\n\n\treturn clk;\n}\n\n \nstatic const struct clk_div_table cpg_adsp_div_table[] = {\n\t{  1,  3 }, {  2,  4 }, {  3,  6 }, {  4,  8 },\n\t{  5, 12 }, {  6, 16 }, {  7, 18 }, {  8, 24 },\n\t{ 10, 36 }, { 11, 48 }, {  0,  0 },\n};\n\nstatic struct clk * __init cpg_adsp_clk_register(const char *name,\n\t\t\t\t\t\t const char *parent_name,\n\t\t\t\t\t\t void __iomem *base)\n{\n\tstruct clk_divider *div;\n\tstruct clk_gate *gate;\n\tstruct clk *clk;\n\n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdiv->reg = base + CPG_ADSPCKCR;\n\tdiv->width = 4;\n\tdiv->table = cpg_adsp_div_table;\n\tdiv->lock = &cpg_lock;\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate) {\n\t\tkfree(div);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tgate->reg = base + CPG_ADSPCKCR;\n\tgate->bit_idx = 8;\n\tgate->flags = CLK_GATE_SET_TO_DISABLE;\n\tgate->lock = &cpg_lock;\n\n\tclk = clk_register_composite(NULL, name, &parent_name, 1, NULL, NULL,\n\t\t\t\t     &div->hw, &clk_divider_ops,\n\t\t\t\t     &gate->hw, &clk_gate_ops, 0);\n\tif (IS_ERR(clk)) {\n\t\tkfree(gate);\n\t\tkfree(div);\n\t}\n\n\treturn clk;\n}\n\n \nstatic const struct clk_div_table cpg_sdh_div_table[] = {\n\t{  0,  2 }, {  1,  3 }, {  2,  4 }, {  3,  6 },\n\t{  4,  8 }, {  5, 12 }, {  6, 16 }, {  7, 18 },\n\t{  8, 24 }, { 10, 36 }, { 11, 48 }, {  0,  0 },\n};\n\nstatic const struct clk_div_table cpg_sd01_div_table[] = {\n\t{  4,  8 }, {  5, 12 }, {  6, 16 }, {  7, 18 },\n\t{  8, 24 }, { 10, 36 }, { 11, 48 }, { 12, 10 },\n\t{  0,  0 },\n};\n\nstatic const struct rcar_gen2_cpg_pll_config *cpg_pll_config __initdata;\nstatic unsigned int cpg_pll0_div __initdata;\nstatic u32 cpg_mode __initdata;\nstatic u32 cpg_quirks __initdata;\n\n#define SD_SKIP_FIRST\tBIT(0)\t\t \n\nstatic const struct soc_device_attribute cpg_quirks_match[] __initconst = {\n\t{\n\t\t.soc_id = \"r8a77470\",\n\t\t.data = (void *)SD_SKIP_FIRST,\n\t},\n\t{   }\n};\n\nstruct clk * __init rcar_gen2_cpg_clk_register(struct device *dev,\n\tconst struct cpg_core_clk *core, const struct cpg_mssr_info *info,\n\tstruct clk **clks, void __iomem *base,\n\tstruct raw_notifier_head *notifiers)\n{\n\tconst struct clk_div_table *table = NULL;\n\tconst struct clk *parent;\n\tconst char *parent_name;\n\tunsigned int mult = 1;\n\tunsigned int div = 1;\n\tunsigned int shift;\n\n\tparent = clks[core->parent];\n\tif (IS_ERR(parent))\n\t\treturn ERR_CAST(parent);\n\n\tparent_name = __clk_get_name(parent);\n\n\tswitch (core->type) {\n\t \n\tcase CLK_TYPE_GEN2_MAIN:\n\t\tdiv = cpg_pll_config->extal_div;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN2_PLL0:\n\t\t \n\t\tmult = cpg_pll_config->pll0_mult;\n\t\tdiv  = cpg_pll0_div;\n\t\tif (!mult) {\n\t\t\tu32 pll0cr = readl(base + CPG_PLL0CR);\n\n\t\t\tmult = (((pll0cr & CPG_PLL0CR_STC_MASK) >>\n\t\t\t\t CPG_PLL0CR_STC_SHIFT) + 1) * 2;\n\t\t}\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN2_PLL1:\n\t\tmult = cpg_pll_config->pll1_mult / 2;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN2_PLL3:\n\t\tmult = cpg_pll_config->pll3_mult;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN2_Z:\n\t\treturn cpg_z_clk_register(core->name, parent_name, base);\n\n\tcase CLK_TYPE_GEN2_LB:\n\t\tdiv = cpg_mode & BIT(18) ? 36 : 24;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN2_ADSP:\n\t\treturn cpg_adsp_clk_register(core->name, parent_name, base);\n\n\tcase CLK_TYPE_GEN2_SDH:\n\t\ttable = cpg_sdh_div_table;\n\t\tshift = 8;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN2_SD0:\n\t\ttable = cpg_sd01_div_table;\n\t\tif (cpg_quirks & SD_SKIP_FIRST)\n\t\t\ttable++;\n\n\t\tshift = 4;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN2_SD1:\n\t\ttable = cpg_sd01_div_table;\n\t\tif (cpg_quirks & SD_SKIP_FIRST)\n\t\t\ttable++;\n\n\t\tshift = 0;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN2_QSPI:\n\t\tdiv = (cpg_mode & (BIT(3) | BIT(2) | BIT(1))) == BIT(2) ?\n\t\t      8 : 10;\n\t\tbreak;\n\n\tcase CLK_TYPE_GEN2_RCAN:\n\t\treturn cpg_rcan_clk_register(core->name, parent_name, base);\n\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!table)\n\t\treturn clk_register_fixed_factor(NULL, core->name, parent_name,\n\t\t\t\t\t\t 0, mult, div);\n\telse\n\t\treturn clk_register_divider_table(NULL, core->name,\n\t\t\t\t\t\t  parent_name, 0,\n\t\t\t\t\t\t  base + CPG_SDCKCR, shift, 4,\n\t\t\t\t\t\t  0, table, &cpg_lock);\n}\n\nint __init rcar_gen2_cpg_init(const struct rcar_gen2_cpg_pll_config *config,\n\t\t\t      unsigned int pll0_div, u32 mode)\n{\n\tconst struct soc_device_attribute *attr;\n\n\tcpg_pll_config = config;\n\tcpg_pll0_div = pll0_div;\n\tcpg_mode = mode;\n\tattr = soc_device_match(cpg_quirks_match);\n\tif (attr)\n\t\tcpg_quirks = (uintptr_t)attr->data;\n\tpr_debug(\"%s: mode = 0x%x quirks = 0x%x\\n\", __func__, mode, cpg_quirks);\n\n\tspin_lock_init(&cpg_lock);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}