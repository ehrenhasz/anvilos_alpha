{
  "module_name": "rcar-usb2-clock-sel.c",
  "hash_id": "6fe03679389298c0f0d038ab5d515139a441186218ab20395dc23a45ad910f93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/renesas/rcar-usb2-clock-sel.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#define USB20_CLKSET0\t\t0x00\n#define CLKSET0_INTCLK_EN\tBIT(11)\n#define CLKSET0_PRIVATE\t\tBIT(0)\n#define CLKSET0_EXTAL_ONLY\t(CLKSET0_INTCLK_EN | CLKSET0_PRIVATE)\n\nstatic const struct clk_bulk_data rcar_usb2_clocks[] = {\n\t{ .id = \"ehci_ohci\", },\n\t{ .id = \"hs-usb-if\", },\n};\n\nstruct usb2_clock_sel_priv {\n\tvoid __iomem *base;\n\tstruct clk_hw hw;\n\tstruct clk_bulk_data clks[ARRAY_SIZE(rcar_usb2_clocks)];\n\tstruct reset_control *rsts;\n\tbool extal;\n\tbool xtal;\n};\n#define to_priv(_hw)\tcontainer_of(_hw, struct usb2_clock_sel_priv, hw)\n\nstatic void usb2_clock_sel_enable_extal_only(struct usb2_clock_sel_priv *priv)\n{\n\tu16 val = readw(priv->base + USB20_CLKSET0);\n\n\tpr_debug(\"%s: enter %d %d %x\\n\", __func__,\n\t\t priv->extal, priv->xtal, val);\n\n\tif (priv->extal && !priv->xtal && val != CLKSET0_EXTAL_ONLY)\n\t\twritew(CLKSET0_EXTAL_ONLY, priv->base + USB20_CLKSET0);\n}\n\nstatic void usb2_clock_sel_disable_extal_only(struct usb2_clock_sel_priv *priv)\n{\n\tif (priv->extal && !priv->xtal)\n\t\twritew(CLKSET0_PRIVATE, priv->base + USB20_CLKSET0);\n}\n\nstatic int usb2_clock_sel_enable(struct clk_hw *hw)\n{\n\tstruct usb2_clock_sel_priv *priv = to_priv(hw);\n\tint ret;\n\n\tret = reset_control_deassert(priv->rsts);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_bulk_prepare_enable(ARRAY_SIZE(priv->clks), priv->clks);\n\tif (ret) {\n\t\treset_control_assert(priv->rsts);\n\t\treturn ret;\n\t}\n\n\tusb2_clock_sel_enable_extal_only(priv);\n\n\treturn 0;\n}\n\nstatic void usb2_clock_sel_disable(struct clk_hw *hw)\n{\n\tstruct usb2_clock_sel_priv *priv = to_priv(hw);\n\n\tusb2_clock_sel_disable_extal_only(priv);\n\n\tclk_bulk_disable_unprepare(ARRAY_SIZE(priv->clks), priv->clks);\n\treset_control_assert(priv->rsts);\n}\n\n \nstatic const struct clk_ops usb2_clock_sel_clock_ops = {\n\t.enable = usb2_clock_sel_enable,\n\t.disable = usb2_clock_sel_disable,\n};\n\nstatic const struct of_device_id rcar_usb2_clock_sel_match[] = {\n\t{ .compatible = \"renesas,rcar-gen3-usb2-clock-sel\" },\n\t{ }\n};\n\nstatic int rcar_usb2_clock_sel_suspend(struct device *dev)\n{\n\tstruct usb2_clock_sel_priv *priv = dev_get_drvdata(dev);\n\n\tusb2_clock_sel_disable_extal_only(priv);\n\tpm_runtime_put(dev);\n\n\treturn 0;\n}\n\nstatic int rcar_usb2_clock_sel_resume(struct device *dev)\n{\n\tstruct usb2_clock_sel_priv *priv = dev_get_drvdata(dev);\n\n\tpm_runtime_get_sync(dev);\n\tusb2_clock_sel_enable_extal_only(priv);\n\n\treturn 0;\n}\n\nstatic void rcar_usb2_clock_sel_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tof_clk_del_provider(dev->of_node);\n\tpm_runtime_put(dev);\n\tpm_runtime_disable(dev);\n}\n\nstatic int rcar_usb2_clock_sel_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct usb2_clock_sel_priv *priv;\n\tstruct clk *clk;\n\tstruct clk_init_data init = {};\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tmemcpy(priv->clks, rcar_usb2_clocks, sizeof(priv->clks));\n\tret = devm_clk_bulk_get(dev, ARRAY_SIZE(priv->clks), priv->clks);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->rsts = devm_reset_control_array_get_shared(dev);\n\tif (IS_ERR(priv->rsts))\n\t\treturn PTR_ERR(priv->rsts);\n\n\tclk = devm_clk_get(dev, \"usb_extal\");\n\tif (!IS_ERR(clk) && !clk_prepare_enable(clk)) {\n\t\tpriv->extal = !!clk_get_rate(clk);\n\t\tclk_disable_unprepare(clk);\n\t}\n\tclk = devm_clk_get(dev, \"usb_xtal\");\n\tif (!IS_ERR(clk) && !clk_prepare_enable(clk)) {\n\t\tpriv->xtal = !!clk_get_rate(clk);\n\t\tclk_disable_unprepare(clk);\n\t}\n\n\tif (!priv->extal && !priv->xtal) {\n\t\tdev_err(dev, \"This driver needs usb_extal or usb_xtal\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\tplatform_set_drvdata(pdev, priv);\n\tdev_set_drvdata(dev, priv);\n\n\tinit.name = \"rcar_usb2_clock_sel\";\n\tinit.ops = &usb2_clock_sel_clock_ops;\n\tpriv->hw.init = &init;\n\n\tret = devm_clk_hw_register(dev, &priv->hw);\n\tif (ret)\n\t\tgoto pm_put;\n\n\tret = of_clk_add_hw_provider(np, of_clk_hw_simple_get, &priv->hw);\n\tif (ret)\n\t\tgoto pm_put;\n\n\treturn 0;\n\npm_put:\n\tpm_runtime_put(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops rcar_usb2_clock_sel_pm_ops = {\n\t.suspend\t= rcar_usb2_clock_sel_suspend,\n\t.resume\t\t= rcar_usb2_clock_sel_resume,\n};\n\nstatic struct platform_driver rcar_usb2_clock_sel_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rcar-usb2-clock-sel\",\n\t\t.of_match_table = rcar_usb2_clock_sel_match,\n\t\t.pm\t= &rcar_usb2_clock_sel_pm_ops,\n\t},\n\t.probe\t\t= rcar_usb2_clock_sel_probe,\n\t.remove_new\t= rcar_usb2_clock_sel_remove,\n};\nbuiltin_platform_driver(rcar_usb2_clock_sel_driver);\n\nMODULE_DESCRIPTION(\"Renesas R-Car USB2 clock selector Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}