{
  "module_name": "r9a06g032-clocks.c",
  "hash_id": "afeee08c427dfa6c8036f7a2530f11fed2f46376efe57c0fd2b7b6e029d0fc9f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/renesas/r9a06g032-clocks.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_domain.h>\n#include <linux/slab.h>\n#include <linux/soc/renesas/r9a06g032-sysctrl.h>\n#include <linux/spinlock.h>\n#include <dt-bindings/clock/r9a06g032-sysctrl.h>\n\n#define R9A06G032_SYSCTRL_USB    0x00\n#define R9A06G032_SYSCTRL_USB_H2MODE  (1<<1)\n#define R9A06G032_SYSCTRL_DMAMUX 0xA0\n\n \nstruct regbit {\n\tu16 bit:5;\n\tu16 reg:11;\n};\n\n#define RB(_reg, _bit) ((struct regbit) { \\\n\t.reg = (_reg) / 4, \\\n\t.bit = (_bit) \\\n})\n\n \nstruct r9a06g032_gate {\n\tstruct regbit gate, reset, ready, midle;\n\t \n\t ;\n};\n\nenum gate_type {\n\tK_GATE = 0,\t \n\tK_FFC,\t\t \n\tK_DIV,\t\t \n\tK_BITSEL,\t \n\tK_DUALGATE\t \n};\n\n \nstruct r9a06g032_clkdesc {\n\tconst char *name;\n\tuint32_t managed:1;\n\tenum gate_type type:3;\n\tuint32_t index:8;\n\tuint32_t source:8;  \n\tunion {\n\t\t \n\t\tstruct r9a06g032_gate gate;\n\t\t \n\t\tstruct {\n\t\t\tunsigned int div_min:10, div_max:10, reg:10;\n\t\t\tu16 div_table[4];\n\t\t};\n\t\t \n\t\tstruct {\n\t\t\tu16 div, mul;\n\t\t};\n\t\t \n\t\tstruct {\n\t\t\tuint16_t group:1;\n\t\t\tstruct regbit sel, g1, r1, g2, r2;\n\t\t} dual;\n\t};\n};\n\n \n#define I_GATE(_clk, _rst, _rdy, _midle, _scon, _mirack, _mistat) { \\\n\t.gate = _clk, \\\n\t.reset = _rst, \\\n\t.ready = _rdy, \\\n\t.midle = _midle, \\\n\t  \\\n\t  \\\n\t  \\\n}\n#define D_GATE(_idx, _n, _src, ...) { \\\n\t.type = K_GATE, \\\n\t.index = R9A06G032_##_idx, \\\n\t.source = 1 + R9A06G032_##_src, \\\n\t.name = _n, \\\n\t.gate = I_GATE(__VA_ARGS__) \\\n}\n#define D_MODULE(_idx, _n, _src, ...) { \\\n\t.type = K_GATE, \\\n\t.index = R9A06G032_##_idx, \\\n\t.source = 1 + R9A06G032_##_src, \\\n\t.name = _n, \\\n\t.managed = 1, \\\n\t.gate = I_GATE(__VA_ARGS__) \\\n}\n#define D_ROOT(_idx, _n, _mul, _div) { \\\n\t.type = K_FFC, \\\n\t.index = R9A06G032_##_idx, \\\n\t.name = _n, \\\n\t.div = _div, \\\n\t.mul = _mul \\\n}\n#define D_FFC(_idx, _n, _src, _div) { \\\n\t.type = K_FFC, \\\n\t.index = R9A06G032_##_idx, \\\n\t.source = 1 + R9A06G032_##_src, \\\n\t.name = _n, \\\n\t.div = _div, \\\n\t.mul = 1 \\\n}\n#define D_DIV(_idx, _n, _src, _reg, _min, _max, ...) { \\\n\t.type = K_DIV, \\\n\t.index = R9A06G032_##_idx, \\\n\t.source = 1 + R9A06G032_##_src, \\\n\t.name = _n, \\\n\t.reg = _reg, \\\n\t.div_min = _min, \\\n\t.div_max = _max, \\\n\t.div_table = { __VA_ARGS__ } \\\n}\n#define D_UGATE(_idx, _n, _src, _g, _g1, _r1, _g2, _r2) { \\\n\t.type = K_DUALGATE, \\\n\t.index = R9A06G032_##_idx, \\\n\t.source = 1 + R9A06G032_##_src, \\\n\t.name = _n, \\\n\t.dual = { \\\n\t\t.group = _g, \\\n\t\t.g1 = _g1, \\\n\t\t.r1 = _r1, \\\n\t\t.g2 = _g2, \\\n\t\t.r2 = _r2 \\\n\t}, \\\n}\n\n \n#define R9A06G032_CLKOUT\t\t0\n#define R9A06G032_CLKOUT_D10\t\t2\n#define R9A06G032_CLKOUT_D16\t\t3\n#define R9A06G032_CLKOUT_D160\t\t4\n#define R9A06G032_CLKOUT_D1OR2\t\t5\n#define R9A06G032_CLKOUT_D20\t\t6\n#define R9A06G032_CLKOUT_D40\t\t7\n#define R9A06G032_CLKOUT_D5\t\t8\n#define R9A06G032_CLKOUT_D8\t\t9\n#define R9A06G032_DIV_ADC\t\t10\n#define R9A06G032_DIV_I2C\t\t11\n#define R9A06G032_DIV_NAND\t\t12\n#define R9A06G032_DIV_P1_PG\t\t13\n#define R9A06G032_DIV_P2_PG\t\t14\n#define R9A06G032_DIV_P3_PG\t\t15\n#define R9A06G032_DIV_P4_PG\t\t16\n#define R9A06G032_DIV_P5_PG\t\t17\n#define R9A06G032_DIV_P6_PG\t\t18\n#define R9A06G032_DIV_QSPI0\t\t19\n#define R9A06G032_DIV_QSPI1\t\t20\n#define R9A06G032_DIV_REF_SYNC\t\t21\n#define R9A06G032_DIV_SDIO0\t\t22\n#define R9A06G032_DIV_SDIO1\t\t23\n#define R9A06G032_DIV_SWITCH\t\t24\n#define R9A06G032_DIV_UART\t\t25\n#define R9A06G032_DIV_MOTOR\t\t64\n#define R9A06G032_CLK_DDRPHY_PLLCLK_D4\t78\n#define R9A06G032_CLK_ECAT100_D4\t79\n#define R9A06G032_CLK_HSR100_D2\t\t80\n#define R9A06G032_CLK_REF_SYNC_D4\t81\n#define R9A06G032_CLK_REF_SYNC_D8\t82\n#define R9A06G032_CLK_SERCOS100_D2\t83\n#define R9A06G032_DIV_CA7\t\t84\n\n#define R9A06G032_UART_GROUP_012\t154\n#define R9A06G032_UART_GROUP_34567\t155\n\n#define R9A06G032_CLOCK_COUNT\t\t(R9A06G032_UART_GROUP_34567 + 1)\n\nstatic const struct r9a06g032_clkdesc r9a06g032_clocks[] = {\n\tD_ROOT(CLKOUT, \"clkout\", 25, 1),\n\tD_ROOT(CLK_PLL_USB, \"clk_pll_usb\", 12, 10),\n\tD_FFC(CLKOUT_D10, \"clkout_d10\", CLKOUT, 10),\n\tD_FFC(CLKOUT_D16, \"clkout_d16\", CLKOUT, 16),\n\tD_FFC(CLKOUT_D160, \"clkout_d160\", CLKOUT, 160),\n\tD_DIV(CLKOUT_D1OR2, \"clkout_d1or2\", CLKOUT, 0, 1, 2),\n\tD_FFC(CLKOUT_D20, \"clkout_d20\", CLKOUT, 20),\n\tD_FFC(CLKOUT_D40, \"clkout_d40\", CLKOUT, 40),\n\tD_FFC(CLKOUT_D5, \"clkout_d5\", CLKOUT, 5),\n\tD_FFC(CLKOUT_D8, \"clkout_d8\", CLKOUT, 8),\n\tD_DIV(DIV_ADC, \"div_adc\", CLKOUT, 77, 50, 250),\n\tD_DIV(DIV_I2C, \"div_i2c\", CLKOUT, 78, 12, 16),\n\tD_DIV(DIV_NAND, \"div_nand\", CLKOUT, 82, 12, 32),\n\tD_DIV(DIV_P1_PG, \"div_p1_pg\", CLKOUT, 68, 12, 200),\n\tD_DIV(DIV_P2_PG, \"div_p2_pg\", CLKOUT, 62, 12, 128),\n\tD_DIV(DIV_P3_PG, \"div_p3_pg\", CLKOUT, 64, 8, 128),\n\tD_DIV(DIV_P4_PG, \"div_p4_pg\", CLKOUT, 66, 8, 128),\n\tD_DIV(DIV_P5_PG, \"div_p5_pg\", CLKOUT, 71, 10, 40),\n\tD_DIV(DIV_P6_PG, \"div_p6_pg\", CLKOUT, 18, 12, 64),\n\tD_DIV(DIV_QSPI0, \"div_qspi0\", CLKOUT, 73, 3, 7),\n\tD_DIV(DIV_QSPI1, \"div_qspi1\", CLKOUT, 25, 3, 7),\n\tD_DIV(DIV_REF_SYNC, \"div_ref_sync\", CLKOUT, 56, 2, 16, 2, 4, 8, 16),\n\tD_DIV(DIV_SDIO0, \"div_sdio0\", CLKOUT, 74, 20, 128),\n\tD_DIV(DIV_SDIO1, \"div_sdio1\", CLKOUT, 75, 20, 128),\n\tD_DIV(DIV_SWITCH, \"div_switch\", CLKOUT, 37, 5, 40),\n\tD_DIV(DIV_UART, \"div_uart\", CLKOUT, 79, 12, 128),\n\tD_GATE(CLK_25_PG4, \"clk_25_pg4\", CLKOUT_D40, RB(0xe8, 9),\n\t       RB(0xe8, 10), RB(0xe8, 11), RB(0x00, 0),\n\t       RB(0x15c, 3), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_25_PG5, \"clk_25_pg5\", CLKOUT_D40, RB(0xe8, 12),\n\t       RB(0xe8, 13), RB(0xe8, 14), RB(0x00, 0),\n\t       RB(0x15c, 4), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_25_PG6, \"clk_25_pg6\", CLKOUT_D40, RB(0xe8, 15),\n\t       RB(0xe8, 16), RB(0xe8, 17), RB(0x00, 0),\n\t       RB(0x15c, 5), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_25_PG7, \"clk_25_pg7\", CLKOUT_D40, RB(0xe8, 18),\n\t       RB(0xe8, 19), RB(0xe8, 20), RB(0x00, 0),\n\t       RB(0x15c, 6), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_25_PG8, \"clk_25_pg8\", CLKOUT_D40, RB(0xe8, 21),\n\t       RB(0xe8, 22), RB(0xe8, 23), RB(0x00, 0),\n\t       RB(0x15c, 7), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_ADC, \"clk_adc\", DIV_ADC, RB(0x3c, 10),\n\t       RB(0x3c, 11), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_ECAT100, \"clk_ecat100\", CLKOUT_D10, RB(0x80, 5),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_HSR100, \"clk_hsr100\", CLKOUT_D10, RB(0x90, 3),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_I2C0, \"clk_i2c0\", DIV_I2C, RB(0x3c, 6),\n\t       RB(0x3c, 7), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_I2C1, \"clk_i2c1\", DIV_I2C, RB(0x3c, 8),\n\t       RB(0x3c, 9), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_MII_REF, \"clk_mii_ref\", CLKOUT_D40, RB(0x68, 2),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_NAND, \"clk_nand\", DIV_NAND, RB(0x50, 4),\n\t       RB(0x50, 5), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_NOUSBP2_PG6, \"clk_nousbp2_pg6\", DIV_P2_PG, RB(0xec, 20),\n\t       RB(0xec, 21), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_P1_PG2, \"clk_p1_pg2\", DIV_P1_PG, RB(0x10c, 2),\n\t       RB(0x10c, 3), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_P1_PG3, \"clk_p1_pg3\", DIV_P1_PG, RB(0x10c, 4),\n\t       RB(0x10c, 5), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_P1_PG4, \"clk_p1_pg4\", DIV_P1_PG, RB(0x10c, 6),\n\t       RB(0x10c, 7), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_P4_PG3, \"clk_p4_pg3\", DIV_P4_PG, RB(0x104, 4),\n\t       RB(0x104, 5), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_P4_PG4, \"clk_p4_pg4\", DIV_P4_PG, RB(0x104, 6),\n\t       RB(0x104, 7), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_P6_PG1, \"clk_p6_pg1\", DIV_P6_PG, RB(0x114, 0),\n\t       RB(0x114, 1), RB(0x114, 2), RB(0x00, 0),\n\t       RB(0x16c, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_P6_PG2, \"clk_p6_pg2\", DIV_P6_PG, RB(0x114, 3),\n\t       RB(0x114, 4), RB(0x114, 5), RB(0x00, 0),\n\t       RB(0x16c, 1), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_P6_PG3, \"clk_p6_pg3\", DIV_P6_PG, RB(0x114, 6),\n\t       RB(0x114, 7), RB(0x114, 8), RB(0x00, 0),\n\t       RB(0x16c, 2), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_P6_PG4, \"clk_p6_pg4\", DIV_P6_PG, RB(0x114, 9),\n\t       RB(0x114, 10), RB(0x114, 11), RB(0x00, 0),\n\t       RB(0x16c, 3), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(CLK_PCI_USB, \"clk_pci_usb\", CLKOUT_D40, RB(0x1c, 6),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_QSPI0, \"clk_qspi0\", DIV_QSPI0, RB(0x54, 4),\n\t       RB(0x54, 5), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_QSPI1, \"clk_qspi1\", DIV_QSPI1, RB(0x90, 4),\n\t       RB(0x90, 5), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_RGMII_REF, \"clk_rgmii_ref\", CLKOUT_D8, RB(0x68, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_RMII_REF, \"clk_rmii_ref\", CLKOUT_D20, RB(0x68, 1),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_SDIO0, \"clk_sdio0\", DIV_SDIO0, RB(0x0c, 4),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_SDIO1, \"clk_sdio1\", DIV_SDIO1, RB(0xc8, 4),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_SERCOS100, \"clk_sercos100\", CLKOUT_D10, RB(0x84, 5),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_SLCD, \"clk_slcd\", DIV_P1_PG, RB(0x10c, 0),\n\t       RB(0x10c, 1), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_SPI0, \"clk_spi0\", DIV_P3_PG, RB(0xfc, 0),\n\t       RB(0xfc, 1), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_SPI1, \"clk_spi1\", DIV_P3_PG, RB(0xfc, 2),\n\t       RB(0xfc, 3), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_SPI2, \"clk_spi2\", DIV_P3_PG, RB(0xfc, 4),\n\t       RB(0xfc, 5), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_SPI3, \"clk_spi3\", DIV_P3_PG, RB(0xfc, 6),\n\t       RB(0xfc, 7), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_SPI4, \"clk_spi4\", DIV_P4_PG, RB(0x104, 0),\n\t       RB(0x104, 1), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_SPI5, \"clk_spi5\", DIV_P4_PG, RB(0x104, 2),\n\t       RB(0x104, 3), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_SWITCH, \"clk_switch\", DIV_SWITCH, RB(0x130, 2),\n\t       RB(0x130, 3), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_DIV(DIV_MOTOR, \"div_motor\", CLKOUT_D5, 84, 2, 8),\n\tD_MODULE(HCLK_ECAT125, \"hclk_ecat125\", CLKOUT_D8, RB(0x80, 0),\n\t\t RB(0x80, 1), RB(0x00, 0), RB(0x80, 2),\n\t\t RB(0x00, 0), RB(0x88, 0), RB(0x88, 1)),\n\tD_MODULE(HCLK_PINCONFIG, \"hclk_pinconfig\", CLKOUT_D40, RB(0xe8, 0),\n\t\t RB(0xe8, 1), RB(0xe8, 2), RB(0x00, 0),\n\t\t RB(0x15c, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_SERCOS, \"hclk_sercos\", CLKOUT_D10, RB(0x84, 0),\n\t\t RB(0x84, 2), RB(0x00, 0), RB(0x84, 1),\n\t\t RB(0x00, 0), RB(0x8c, 0), RB(0x8c, 1)),\n\tD_MODULE(HCLK_SGPIO2, \"hclk_sgpio2\", DIV_P5_PG, RB(0x118, 3),\n\t\t RB(0x118, 4), RB(0x118, 5), RB(0x00, 0),\n\t\t RB(0x168, 1), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_SGPIO3, \"hclk_sgpio3\", DIV_P5_PG, RB(0x118, 6),\n\t\t RB(0x118, 7), RB(0x118, 8), RB(0x00, 0),\n\t\t RB(0x168, 2), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_SGPIO4, \"hclk_sgpio4\", DIV_P5_PG, RB(0x118, 9),\n\t\t RB(0x118, 10), RB(0x118, 11), RB(0x00, 0),\n\t\t RB(0x168, 3), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_TIMER0, \"hclk_timer0\", CLKOUT_D40, RB(0xe8, 3),\n\t\t RB(0xe8, 4), RB(0xe8, 5), RB(0x00, 0),\n\t\t RB(0x15c, 1), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_TIMER1, \"hclk_timer1\", CLKOUT_D40, RB(0xe8, 6),\n\t\t RB(0xe8, 7), RB(0xe8, 8), RB(0x00, 0),\n\t\t RB(0x15c, 2), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_USBF, \"hclk_usbf\", CLKOUT_D8, RB(0x1c, 3),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x1c, 4),\n\t\t RB(0x00, 0), RB(0x20, 2), RB(0x20, 3)),\n\tD_MODULE(HCLK_USBH, \"hclk_usbh\", CLKOUT_D8, RB(0x1c, 0),\n\t\t RB(0x1c, 1), RB(0x00, 0), RB(0x1c, 2),\n\t\t RB(0x00, 0), RB(0x20, 0), RB(0x20, 1)),\n\tD_MODULE(HCLK_USBPM, \"hclk_usbpm\", CLKOUT_D8, RB(0x1c, 5),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_48_PG_F, \"clk_48_pg_f\", CLK_48, RB(0xf0, 12),\n\t       RB(0xf0, 13), RB(0x00, 0), RB(0xf0, 14),\n\t       RB(0x00, 0), RB(0x160, 4), RB(0x160, 5)),\n\tD_GATE(CLK_48_PG4, \"clk_48_pg4\", CLK_48, RB(0xf0, 9),\n\t       RB(0xf0, 10), RB(0xf0, 11), RB(0x00, 0),\n\t       RB(0x160, 3), RB(0x00, 0), RB(0x00, 0)),\n\tD_FFC(CLK_DDRPHY_PLLCLK_D4, \"clk_ddrphy_pllclk_d4\", CLK_DDRPHY_PLLCLK, 4),\n\tD_FFC(CLK_ECAT100_D4, \"clk_ecat100_d4\", CLK_ECAT100, 4),\n\tD_FFC(CLK_HSR100_D2, \"clk_hsr100_d2\", CLK_HSR100, 2),\n\tD_FFC(CLK_REF_SYNC_D4, \"clk_ref_sync_d4\", CLK_REF_SYNC, 4),\n\tD_FFC(CLK_REF_SYNC_D8, \"clk_ref_sync_d8\", CLK_REF_SYNC, 8),\n\tD_FFC(CLK_SERCOS100_D2, \"clk_sercos100_d2\", CLK_SERCOS100, 2),\n\tD_DIV(DIV_CA7, \"div_ca7\", CLK_REF_SYNC, 57, 1, 4, 1, 2, 4),\n\tD_MODULE(HCLK_CAN0, \"hclk_can0\", CLK_48, RB(0xf0, 3),\n\t\t RB(0xf0, 4), RB(0xf0, 5), RB(0x00, 0),\n\t\t RB(0x160, 1), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_CAN1, \"hclk_can1\", CLK_48, RB(0xf0, 6),\n\t\t RB(0xf0, 7), RB(0xf0, 8), RB(0x00, 0),\n\t\t RB(0x160, 2), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_DELTASIGMA, \"hclk_deltasigma\", DIV_MOTOR, RB(0x3c, 15),\n\t\t RB(0x3c, 16), RB(0x3c, 17), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_PWMPTO, \"hclk_pwmpto\", DIV_MOTOR, RB(0x3c, 12),\n\t\t RB(0x3c, 13), RB(0x3c, 14), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_RSV, \"hclk_rsv\", CLK_48, RB(0xf0, 0),\n\t\t RB(0xf0, 1), RB(0xf0, 2), RB(0x00, 0),\n\t\t RB(0x160, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_SGPIO0, \"hclk_sgpio0\", DIV_MOTOR, RB(0x3c, 0),\n\t\t RB(0x3c, 1), RB(0x3c, 2), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_SGPIO1, \"hclk_sgpio1\", DIV_MOTOR, RB(0x3c, 3),\n\t\t RB(0x3c, 4), RB(0x3c, 5), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_DIV(RTOS_MDC, \"rtos_mdc\", CLK_REF_SYNC, 100, 80, 640, 80, 160, 320, 640),\n\tD_GATE(CLK_CM3, \"clk_cm3\", CLK_REF_SYNC_D4, RB(0x174, 0),\n\t       RB(0x174, 1), RB(0x00, 0), RB(0x174, 2),\n\t       RB(0x00, 0), RB(0x178, 0), RB(0x178, 1)),\n\tD_GATE(CLK_DDRC, \"clk_ddrc\", CLK_DDRPHY_PLLCLK_D4, RB(0x64, 3),\n\t       RB(0x64, 4), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_ECAT25, \"clk_ecat25\", CLK_ECAT100_D4, RB(0x80, 3),\n\t       RB(0x80, 4), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_HSR50, \"clk_hsr50\", CLK_HSR100_D2, RB(0x90, 4),\n\t       RB(0x90, 5), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_HW_RTOS, \"clk_hw_rtos\", CLK_REF_SYNC_D4, RB(0x18c, 0),\n\t       RB(0x18c, 1), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_GATE(CLK_SERCOS50, \"clk_sercos50\", CLK_SERCOS100_D2, RB(0x84, 4),\n\t       RB(0x84, 3), RB(0x00, 0), RB(0x00, 0),\n\t       RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_ADC, \"hclk_adc\", CLK_REF_SYNC_D8, RB(0x34, 15),\n\t\t RB(0x34, 16), RB(0x34, 17), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_CM3, \"hclk_cm3\", CLK_REF_SYNC_D4, RB(0x184, 0),\n\t\t RB(0x184, 1), RB(0x184, 2), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_CRYPTO_EIP150, \"hclk_crypto_eip150\", CLK_REF_SYNC_D4, RB(0x24, 3),\n\t\t RB(0x24, 4), RB(0x24, 5), RB(0x00, 0),\n\t\t RB(0x28, 2), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_CRYPTO_EIP93, \"hclk_crypto_eip93\", CLK_REF_SYNC_D4, RB(0x24, 0),\n\t\t RB(0x24, 1), RB(0x00, 0), RB(0x24, 2),\n\t\t RB(0x00, 0), RB(0x28, 0), RB(0x28, 1)),\n\tD_MODULE(HCLK_DDRC, \"hclk_ddrc\", CLK_REF_SYNC_D4, RB(0x64, 0),\n\t\t RB(0x64, 2), RB(0x00, 0), RB(0x64, 1),\n\t\t RB(0x00, 0), RB(0x74, 0), RB(0x74, 1)),\n\tD_MODULE(HCLK_DMA0, \"hclk_dma0\", CLK_REF_SYNC_D4, RB(0x4c, 0),\n\t\t RB(0x4c, 1), RB(0x4c, 2), RB(0x4c, 3),\n\t\t RB(0x58, 0), RB(0x58, 1), RB(0x58, 2)),\n\tD_MODULE(HCLK_DMA1, \"hclk_dma1\", CLK_REF_SYNC_D4, RB(0x4c, 4),\n\t\t RB(0x4c, 5), RB(0x4c, 6), RB(0x4c, 7),\n\t\t RB(0x58, 3), RB(0x58, 4), RB(0x58, 5)),\n\tD_MODULE(HCLK_GMAC0, \"hclk_gmac0\", CLK_REF_SYNC_D4, RB(0x6c, 0),\n\t\t RB(0x6c, 1), RB(0x6c, 2), RB(0x6c, 3),\n\t\t RB(0x78, 0), RB(0x78, 1), RB(0x78, 2)),\n\tD_MODULE(HCLK_GMAC1, \"hclk_gmac1\", CLK_REF_SYNC_D4, RB(0x70, 0),\n\t\t RB(0x70, 1), RB(0x70, 2), RB(0x70, 3),\n\t\t RB(0x7c, 0), RB(0x7c, 1), RB(0x7c, 2)),\n\tD_MODULE(HCLK_GPIO0, \"hclk_gpio0\", CLK_REF_SYNC_D4, RB(0x40, 18),\n\t\t RB(0x40, 19), RB(0x40, 20), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_GPIO1, \"hclk_gpio1\", CLK_REF_SYNC_D4, RB(0x40, 21),\n\t\t RB(0x40, 22), RB(0x40, 23), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_GPIO2, \"hclk_gpio2\", CLK_REF_SYNC_D4, RB(0x44, 9),\n\t\t RB(0x44, 10), RB(0x44, 11), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_HSR, \"hclk_hsr\", CLK_HSR100_D2, RB(0x90, 0),\n\t\t RB(0x90, 2), RB(0x00, 0), RB(0x90, 1),\n\t\t RB(0x00, 0), RB(0x98, 0), RB(0x98, 1)),\n\tD_MODULE(HCLK_I2C0, \"hclk_i2c0\", CLK_REF_SYNC_D8, RB(0x34, 9),\n\t\t RB(0x34, 10), RB(0x34, 11), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_I2C1, \"hclk_i2c1\", CLK_REF_SYNC_D8, RB(0x34, 12),\n\t\t RB(0x34, 13), RB(0x34, 14), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_LCD, \"hclk_lcd\", CLK_REF_SYNC_D4, RB(0xf4, 0),\n\t\t RB(0xf4, 1), RB(0xf4, 2), RB(0x00, 0),\n\t\t RB(0x164, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_MSEBI_M, \"hclk_msebi_m\", CLK_REF_SYNC_D4, RB(0x2c, 4),\n\t\t RB(0x2c, 5), RB(0x2c, 6), RB(0x00, 0),\n\t\t RB(0x30, 3), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_MSEBI_S, \"hclk_msebi_s\", CLK_REF_SYNC_D4, RB(0x2c, 0),\n\t\t RB(0x2c, 1), RB(0x2c, 2), RB(0x2c, 3),\n\t\t RB(0x30, 0), RB(0x30, 1), RB(0x30, 2)),\n\tD_MODULE(HCLK_NAND, \"hclk_nand\", CLK_REF_SYNC_D4, RB(0x50, 0),\n\t\t RB(0x50, 1), RB(0x50, 2), RB(0x50, 3),\n\t\t RB(0x5c, 0), RB(0x5c, 1), RB(0x5c, 2)),\n\tD_MODULE(HCLK_PG_I, \"hclk_pg_i\", CLK_REF_SYNC_D4, RB(0xf4, 12),\n\t\t RB(0xf4, 13), RB(0x00, 0), RB(0xf4, 14),\n\t\t RB(0x00, 0), RB(0x164, 4), RB(0x164, 5)),\n\tD_MODULE(HCLK_PG19, \"hclk_pg19\", CLK_REF_SYNC_D4, RB(0x44, 12),\n\t\t RB(0x44, 13), RB(0x44, 14), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_PG20, \"hclk_pg20\", CLK_REF_SYNC_D4, RB(0x44, 15),\n\t\t RB(0x44, 16), RB(0x44, 17), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_PG3, \"hclk_pg3\", CLK_REF_SYNC_D4, RB(0xf4, 6),\n\t\t RB(0xf4, 7), RB(0xf4, 8), RB(0x00, 0),\n\t\t RB(0x164, 2), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_PG4, \"hclk_pg4\", CLK_REF_SYNC_D4, RB(0xf4, 9),\n\t\t RB(0xf4, 10), RB(0xf4, 11), RB(0x00, 0),\n\t\t RB(0x164, 3), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_QSPI0, \"hclk_qspi0\", CLK_REF_SYNC_D4, RB(0x54, 0),\n\t\t RB(0x54, 1), RB(0x54, 2), RB(0x54, 3),\n\t\t RB(0x60, 0), RB(0x60, 1), RB(0x60, 2)),\n\tD_MODULE(HCLK_QSPI1, \"hclk_qspi1\", CLK_REF_SYNC_D4, RB(0x90, 0),\n\t\t RB(0x90, 1), RB(0x90, 2), RB(0x90, 3),\n\t\t RB(0x98, 0), RB(0x98, 1), RB(0x98, 2)),\n\tD_MODULE(HCLK_ROM, \"hclk_rom\", CLK_REF_SYNC_D4, RB(0x154, 0),\n\t\t RB(0x154, 1), RB(0x154, 2), RB(0x00, 0),\n\t\t RB(0x170, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_RTC, \"hclk_rtc\", CLK_REF_SYNC_D8, RB(0x140, 0),\n\t\t RB(0x140, 3), RB(0x00, 0), RB(0x140, 2),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_SDIO0, \"hclk_sdio0\", CLK_REF_SYNC_D4, RB(0x0c, 0),\n\t\t RB(0x0c, 1), RB(0x0c, 2), RB(0x0c, 3),\n\t\t RB(0x10, 0), RB(0x10, 1), RB(0x10, 2)),\n\tD_MODULE(HCLK_SDIO1, \"hclk_sdio1\", CLK_REF_SYNC_D4, RB(0xc8, 0),\n\t\t RB(0xc8, 1), RB(0xc8, 2), RB(0xc8, 3),\n\t\t RB(0xcc, 0), RB(0xcc, 1), RB(0xcc, 2)),\n\tD_MODULE(HCLK_SEMAP, \"hclk_semap\", CLK_REF_SYNC_D4, RB(0xf4, 3),\n\t\t RB(0xf4, 4), RB(0xf4, 5), RB(0x00, 0),\n\t\t RB(0x164, 1), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_SPI0, \"hclk_spi0\", CLK_REF_SYNC_D4, RB(0x40, 0),\n\t\t RB(0x40, 1), RB(0x40, 2), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_SPI1, \"hclk_spi1\", CLK_REF_SYNC_D4, RB(0x40, 3),\n\t\t RB(0x40, 4), RB(0x40, 5), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_SPI2, \"hclk_spi2\", CLK_REF_SYNC_D4, RB(0x40, 6),\n\t\t RB(0x40, 7), RB(0x40, 8), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_SPI3, \"hclk_spi3\", CLK_REF_SYNC_D4, RB(0x40, 9),\n\t\t RB(0x40, 10), RB(0x40, 11), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_SPI4, \"hclk_spi4\", CLK_REF_SYNC_D4, RB(0x40, 12),\n\t\t RB(0x40, 13), RB(0x40, 14), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_SPI5, \"hclk_spi5\", CLK_REF_SYNC_D4, RB(0x40, 15),\n\t\t RB(0x40, 16), RB(0x40, 17), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_SWITCH, \"hclk_switch\", CLK_REF_SYNC_D4, RB(0x130, 0),\n\t\t RB(0x00, 0), RB(0x130, 1), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_SWITCH_RG, \"hclk_switch_rg\", CLK_REF_SYNC_D4, RB(0x188, 0),\n\t\t RB(0x188, 1), RB(0x188, 2), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_UART0, \"hclk_uart0\", CLK_REF_SYNC_D8, RB(0x34, 0),\n\t\t RB(0x34, 1), RB(0x34, 2), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_UART1, \"hclk_uart1\", CLK_REF_SYNC_D8, RB(0x34, 3),\n\t\t RB(0x34, 4), RB(0x34, 5), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_UART2, \"hclk_uart2\", CLK_REF_SYNC_D8, RB(0x34, 6),\n\t\t RB(0x34, 7), RB(0x34, 8), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_UART3, \"hclk_uart3\", CLK_REF_SYNC_D4, RB(0x40, 24),\n\t\t RB(0x40, 25), RB(0x40, 26), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_UART4, \"hclk_uart4\", CLK_REF_SYNC_D4, RB(0x40, 27),\n\t\t RB(0x40, 28), RB(0x40, 29), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_UART5, \"hclk_uart5\", CLK_REF_SYNC_D4, RB(0x44, 0),\n\t\t RB(0x44, 1), RB(0x44, 2), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_UART6, \"hclk_uart6\", CLK_REF_SYNC_D4, RB(0x44, 3),\n\t\t RB(0x44, 4), RB(0x44, 5), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\tD_MODULE(HCLK_UART7, \"hclk_uart7\", CLK_REF_SYNC_D4, RB(0x44, 6),\n\t\t RB(0x44, 7), RB(0x44, 8), RB(0x00, 0),\n\t\t RB(0x00, 0), RB(0x00, 0), RB(0x00, 0)),\n\t \n\t{\n\t\t.index = R9A06G032_UART_GROUP_012,\n\t\t.name = \"uart_group_012\",\n\t\t.type = K_BITSEL,\n\t\t.source = 1 + R9A06G032_DIV_UART,\n\t\t \n\t\t.dual.sel = RB(0x34, 30),\n\t\t.dual.group = 0,\n\t},\n\t{\n\t\t.index = R9A06G032_UART_GROUP_34567,\n\t\t.name = \"uart_group_34567\",\n\t\t.type = K_BITSEL,\n\t\t.source = 1 + R9A06G032_DIV_P2_PG,\n\t\t \n\t\t.dual.sel = RB(0xec, 24),\n\t\t.dual.group = 1,\n\t},\n\tD_UGATE(CLK_UART0, \"clk_uart0\", UART_GROUP_012, 0,\n\t\tRB(0x34, 18), RB(0x34, 19), RB(0x34, 20), RB(0x34, 21)),\n\tD_UGATE(CLK_UART1, \"clk_uart1\", UART_GROUP_012, 0,\n\t\tRB(0x34, 22), RB(0x34, 23), RB(0x34, 24), RB(0x34, 25)),\n\tD_UGATE(CLK_UART2, \"clk_uart2\", UART_GROUP_012, 0,\n\t\tRB(0x34, 26), RB(0x34, 27), RB(0x34, 28), RB(0x34, 29)),\n\tD_UGATE(CLK_UART3, \"clk_uart3\", UART_GROUP_34567, 1,\n\t\tRB(0xec, 0), RB(0xec, 1), RB(0xec, 2), RB(0xec, 3)),\n\tD_UGATE(CLK_UART4, \"clk_uart4\", UART_GROUP_34567, 1,\n\t\tRB(0xec, 4), RB(0xec, 5), RB(0xec, 6), RB(0xec, 7)),\n\tD_UGATE(CLK_UART5, \"clk_uart5\", UART_GROUP_34567, 1,\n\t\tRB(0xec, 8), RB(0xec, 9), RB(0xec, 10), RB(0xec, 11)),\n\tD_UGATE(CLK_UART6, \"clk_uart6\", UART_GROUP_34567, 1,\n\t\tRB(0xec, 12), RB(0xec, 13), RB(0xec, 14), RB(0xec, 15)),\n\tD_UGATE(CLK_UART7, \"clk_uart7\", UART_GROUP_34567, 1,\n\t\tRB(0xec, 16), RB(0xec, 17), RB(0xec, 18), RB(0xec, 19)),\n};\n\nstruct r9a06g032_priv {\n\tstruct clk_onecell_data data;\n\tspinlock_t lock;  \n\tvoid __iomem *reg;\n};\n\nstatic struct r9a06g032_priv *sysctrl_priv;\n\n \nint r9a06g032_sysctrl_set_dmamux(u32 mask, u32 val)\n{\n\tunsigned long flags;\n\tu32 dmamux;\n\n\tif (!sysctrl_priv)\n\t\treturn -EPROBE_DEFER;\n\n\tspin_lock_irqsave(&sysctrl_priv->lock, flags);\n\n\tdmamux = readl(sysctrl_priv->reg + R9A06G032_SYSCTRL_DMAMUX);\n\tdmamux &= ~mask;\n\tdmamux |= val & mask;\n\twritel(dmamux, sysctrl_priv->reg + R9A06G032_SYSCTRL_DMAMUX);\n\n\tspin_unlock_irqrestore(&sysctrl_priv->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(r9a06g032_sysctrl_set_dmamux);\n\nstatic void clk_rdesc_set(struct r9a06g032_priv *clocks,\n\t\t\t  struct regbit rb, unsigned int on)\n{\n\tu32 __iomem *reg = clocks->reg + (rb.reg * 4);\n\tu32 val;\n\n\tif (!rb.reg && !rb.bit)\n\t\treturn;\n\n\tval = readl(reg);\n\tval = (val & ~BIT(rb.bit)) | ((!!on) << rb.bit);\n\twritel(val, reg);\n}\n\nstatic int clk_rdesc_get(struct r9a06g032_priv *clocks, struct regbit rb)\n{\n\tu32 __iomem *reg = clocks->reg + (rb.reg * 4);\n\tu32 val = readl(reg);\n\n\treturn !!(val & BIT(rb.bit));\n}\n\n \nstruct r9a06g032_clk_gate {\n\tstruct clk_hw hw;\n\tstruct r9a06g032_priv *clocks;\n\tu16 index;\n\n\tstruct r9a06g032_gate gate;\n};\n\n#define to_r9a06g032_gate(_hw) container_of(_hw, struct r9a06g032_clk_gate, hw)\n\nstatic int create_add_module_clock(struct of_phandle_args *clkspec,\n\t\t\t\t   struct device *dev)\n{\n\tstruct clk *clk;\n\tint error;\n\n\tclk = of_clk_get_from_provider(clkspec);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\terror = pm_clk_create(dev);\n\tif (error) {\n\t\tclk_put(clk);\n\t\treturn error;\n\t}\n\n\terror = pm_clk_add_clk(dev, clk);\n\tif (error) {\n\t\tpm_clk_destroy(dev);\n\t\tclk_put(clk);\n\t}\n\n\treturn error;\n}\n\nstatic int r9a06g032_attach_dev(struct generic_pm_domain *pd,\n\t\t\t\tstruct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct of_phandle_args clkspec;\n\tint i = 0;\n\tint error;\n\tint index;\n\n\twhile (!of_parse_phandle_with_args(np, \"clocks\", \"#clock-cells\", i++,\n\t\t\t\t\t   &clkspec)) {\n\t\tif (clkspec.np != pd->dev.of_node)\n\t\t\tcontinue;\n\n\t\tindex = clkspec.args[0];\n\t\tif (index < R9A06G032_CLOCK_COUNT &&\n\t\t    r9a06g032_clocks[index].managed) {\n\t\t\terror = create_add_module_clock(&clkspec, dev);\n\t\t\tof_node_put(clkspec.np);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void r9a06g032_detach_dev(struct generic_pm_domain *unused, struct device *dev)\n{\n\tif (!pm_clk_no_clocks(dev))\n\t\tpm_clk_destroy(dev);\n}\n\nstatic int r9a06g032_add_clk_domain(struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct generic_pm_domain *pd;\n\n\tpd = devm_kzalloc(dev, sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\tpd->name = np->name;\n\tpd->flags = GENPD_FLAG_PM_CLK | GENPD_FLAG_ALWAYS_ON |\n\t\t    GENPD_FLAG_ACTIVE_WAKEUP;\n\tpd->attach_dev = r9a06g032_attach_dev;\n\tpd->detach_dev = r9a06g032_detach_dev;\n\tpm_genpd_init(pd, &pm_domain_always_on_gov, false);\n\n\tof_genpd_add_provider_simple(np, pd);\n\treturn 0;\n}\n\nstatic void\nr9a06g032_clk_gate_set(struct r9a06g032_priv *clocks,\n\t\t       struct r9a06g032_gate *g, int on)\n{\n\tunsigned long flags;\n\n\tWARN_ON(!g->gate.reg && !g->gate.bit);\n\n\tspin_lock_irqsave(&clocks->lock, flags);\n\tclk_rdesc_set(clocks, g->gate, on);\n\t \n\tclk_rdesc_set(clocks, g->reset, 1);\n\tspin_unlock_irqrestore(&clocks->lock, flags);\n\n\t \n\tudelay(5);\n\n\t \n\tspin_lock_irqsave(&clocks->lock, flags);\n\tclk_rdesc_set(clocks, g->ready, on);\n\t \n\tclk_rdesc_set(clocks, g->midle, !on);\n\tspin_unlock_irqrestore(&clocks->lock, flags);\n\n\t \n}\n\nstatic int r9a06g032_clk_gate_enable(struct clk_hw *hw)\n{\n\tstruct r9a06g032_clk_gate *g = to_r9a06g032_gate(hw);\n\n\tr9a06g032_clk_gate_set(g->clocks, &g->gate, 1);\n\treturn 0;\n}\n\nstatic void r9a06g032_clk_gate_disable(struct clk_hw *hw)\n{\n\tstruct r9a06g032_clk_gate *g = to_r9a06g032_gate(hw);\n\n\tr9a06g032_clk_gate_set(g->clocks, &g->gate, 0);\n}\n\nstatic int r9a06g032_clk_gate_is_enabled(struct clk_hw *hw)\n{\n\tstruct r9a06g032_clk_gate *g = to_r9a06g032_gate(hw);\n\n\t \n\tif (g->gate.reset.reg && !clk_rdesc_get(g->clocks, g->gate.reset))\n\t\treturn 0;\n\n\treturn clk_rdesc_get(g->clocks, g->gate.gate);\n}\n\nstatic const struct clk_ops r9a06g032_clk_gate_ops = {\n\t.enable = r9a06g032_clk_gate_enable,\n\t.disable = r9a06g032_clk_gate_disable,\n\t.is_enabled = r9a06g032_clk_gate_is_enabled,\n};\n\nstatic struct clk *\nr9a06g032_register_gate(struct r9a06g032_priv *clocks,\n\t\t\tconst char *parent_name,\n\t\t\tconst struct r9a06g032_clkdesc *desc)\n{\n\tstruct clk *clk;\n\tstruct r9a06g032_clk_gate *g;\n\tstruct clk_init_data init = {};\n\n\tg = kzalloc(sizeof(*g), GFP_KERNEL);\n\tif (!g)\n\t\treturn NULL;\n\n\tinit.name = desc->name;\n\tinit.ops = &r9a06g032_clk_gate_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\n\tg->clocks = clocks;\n\tg->index = desc->index;\n\tg->gate = desc->gate;\n\tg->hw.init = &init;\n\n\t \n\tif (r9a06g032_clk_gate_is_enabled(&g->hw)) {\n\t\tinit.flags |= CLK_IS_CRITICAL;\n\t\tpr_debug(\"%s was enabled, making read-only\\n\", desc->name);\n\t}\n\n\tclk = clk_register(NULL, &g->hw);\n\tif (IS_ERR(clk)) {\n\t\tkfree(g);\n\t\treturn NULL;\n\t}\n\treturn clk;\n}\n\nstruct r9a06g032_clk_div {\n\tstruct clk_hw hw;\n\tstruct r9a06g032_priv *clocks;\n\tu16 index;\n\tu16 reg;\n\tu16 min, max;\n\tu8 table_size;\n\tu16 table[8];\t \n};\n\n#define to_r9a06g032_div(_hw) \\\n\t\tcontainer_of(_hw, struct r9a06g032_clk_div, hw)\n\nstatic unsigned long\nr9a06g032_div_recalc_rate(struct clk_hw *hw,\n\t\t\t  unsigned long parent_rate)\n{\n\tstruct r9a06g032_clk_div *clk = to_r9a06g032_div(hw);\n\tu32 __iomem *reg = clk->clocks->reg + (4 * clk->reg);\n\tu32 div = readl(reg);\n\n\tif (div < clk->min)\n\t\tdiv = clk->min;\n\telse if (div > clk->max)\n\t\tdiv = clk->max;\n\treturn DIV_ROUND_UP(parent_rate, div);\n}\n\n \nstatic long\nr9a06g032_div_clamp_div(struct r9a06g032_clk_div *clk,\n\t\t\tunsigned long rate, unsigned long prate)\n{\n\t \n\tu32 div = DIV_ROUND_UP(prate, rate + 1);\n\tint i;\n\n\tif (div <= clk->min)\n\t\treturn clk->min;\n\tif (div >= clk->max)\n\t\treturn clk->max;\n\n\tfor (i = 0; clk->table_size && i < clk->table_size - 1; i++) {\n\t\tif (div >= clk->table[i] && div <= clk->table[i + 1]) {\n\t\t\tunsigned long m = rate -\n\t\t\t\tDIV_ROUND_UP(prate, clk->table[i]);\n\t\t\tunsigned long p =\n\t\t\t\tDIV_ROUND_UP(prate, clk->table[i + 1]) -\n\t\t\t\trate;\n\t\t\t \n\t\t\tdiv = p >= m ? clk->table[i] : clk->table[i + 1];\n\t\t\treturn div;\n\t\t}\n\t}\n\treturn div;\n}\n\nstatic int\nr9a06g032_div_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)\n{\n\tstruct r9a06g032_clk_div *clk = to_r9a06g032_div(hw);\n\tu32 div = DIV_ROUND_UP(req->best_parent_rate, req->rate);\n\n\tpr_devel(\"%s %pC %ld (prate %ld) (wanted div %u)\\n\", __func__,\n\t\t hw->clk, req->rate, req->best_parent_rate, div);\n\tpr_devel(\"   min %d (%ld) max %d (%ld)\\n\",\n\t\t clk->min, DIV_ROUND_UP(req->best_parent_rate, clk->min),\n\t\t clk->max, DIV_ROUND_UP(req->best_parent_rate, clk->max));\n\n\tdiv = r9a06g032_div_clamp_div(clk, req->rate, req->best_parent_rate);\n\t \n\tif (clk->index == R9A06G032_DIV_UART ||\n\t    clk->index == R9A06G032_DIV_P2_PG) {\n\t\tpr_devel(\"%s div uart hack!\\n\", __func__);\n\t\treq->rate = clk_get_rate(hw->clk);\n\t\treturn 0;\n\t}\n\treq->rate = DIV_ROUND_UP(req->best_parent_rate, div);\n\tpr_devel(\"%s %pC %ld / %u = %ld\\n\", __func__, hw->clk,\n\t\t req->best_parent_rate, div, req->rate);\n\treturn 0;\n}\n\nstatic int\nr9a06g032_div_set_rate(struct clk_hw *hw,\n\t\t       unsigned long rate, unsigned long parent_rate)\n{\n\tstruct r9a06g032_clk_div *clk = to_r9a06g032_div(hw);\n\t \n\tu32 div = DIV_ROUND_UP(parent_rate, rate + 1);\n\tu32 __iomem *reg = clk->clocks->reg + (4 * clk->reg);\n\n\tpr_devel(\"%s %pC rate %ld parent %ld div %d\\n\", __func__, hw->clk,\n\t\t rate, parent_rate, div);\n\n\t \n\twritel(div | BIT(31), reg);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops r9a06g032_clk_div_ops = {\n\t.recalc_rate = r9a06g032_div_recalc_rate,\n\t.determine_rate = r9a06g032_div_determine_rate,\n\t.set_rate = r9a06g032_div_set_rate,\n};\n\nstatic struct clk *\nr9a06g032_register_div(struct r9a06g032_priv *clocks,\n\t\t       const char *parent_name,\n\t\t       const struct r9a06g032_clkdesc *desc)\n{\n\tstruct r9a06g032_clk_div *div;\n\tstruct clk *clk;\n\tstruct clk_init_data init = {};\n\tunsigned int i;\n\n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn NULL;\n\n\tinit.name = desc->name;\n\tinit.ops = &r9a06g032_clk_div_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\n\tdiv->clocks = clocks;\n\tdiv->index = desc->index;\n\tdiv->reg = desc->reg;\n\tdiv->hw.init = &init;\n\tdiv->min = desc->div_min;\n\tdiv->max = desc->div_max;\n\t \n\tfor (i = 0; i < ARRAY_SIZE(div->table) &&\n\t     i < ARRAY_SIZE(desc->div_table) && desc->div_table[i]; i++) {\n\t\tdiv->table[div->table_size++] = desc->div_table[i];\n\t}\n\n\tclk = clk_register(NULL, &div->hw);\n\tif (IS_ERR(clk)) {\n\t\tkfree(div);\n\t\treturn NULL;\n\t}\n\treturn clk;\n}\n\n \nstruct r9a06g032_clk_bitsel {\n\tstruct clk_hw\thw;\n\tstruct r9a06g032_priv *clocks;\n\tu16 index;\n\tstruct regbit selector;\t\t \n};\n\n#define to_clk_bitselect(_hw) \\\n\t\tcontainer_of(_hw, struct r9a06g032_clk_bitsel, hw)\n\nstatic u8 r9a06g032_clk_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct r9a06g032_clk_bitsel *set = to_clk_bitselect(hw);\n\n\treturn clk_rdesc_get(set->clocks, set->selector);\n}\n\nstatic int r9a06g032_clk_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct r9a06g032_clk_bitsel *set = to_clk_bitselect(hw);\n\n\t \n\tclk_rdesc_set(set->clocks, set->selector, !!index);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_bitselect_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.get_parent = r9a06g032_clk_mux_get_parent,\n\t.set_parent = r9a06g032_clk_mux_set_parent,\n};\n\nstatic struct clk *\nr9a06g032_register_bitsel(struct r9a06g032_priv *clocks,\n\t\t\t  const char *parent_name,\n\t\t\t  const struct r9a06g032_clkdesc *desc)\n{\n\tstruct clk *clk;\n\tstruct r9a06g032_clk_bitsel *g;\n\tstruct clk_init_data init = {};\n\tconst char *names[2];\n\n\t \n\tg = kzalloc(sizeof(*g), GFP_KERNEL);\n\tif (!g)\n\t\treturn NULL;\n\n\tnames[0] = parent_name;\n\tnames[1] = \"clk_pll_usb\";\n\n\tinit.name = desc->name;\n\tinit.ops = &clk_bitselect_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = names;\n\tinit.num_parents = 2;\n\n\tg->clocks = clocks;\n\tg->index = desc->index;\n\tg->selector = desc->dual.sel;\n\tg->hw.init = &init;\n\n\tclk = clk_register(NULL, &g->hw);\n\tif (IS_ERR(clk)) {\n\t\tkfree(g);\n\t\treturn NULL;\n\t}\n\treturn clk;\n}\n\nstruct r9a06g032_clk_dualgate {\n\tstruct clk_hw\thw;\n\tstruct r9a06g032_priv *clocks;\n\tu16 index;\n\tstruct regbit selector;\t\t \n\tstruct r9a06g032_gate gate[2];\n};\n\n#define to_clk_dualgate(_hw) \\\n\t\tcontainer_of(_hw, struct r9a06g032_clk_dualgate, hw)\n\nstatic int\nr9a06g032_clk_dualgate_setenable(struct r9a06g032_clk_dualgate *g, int enable)\n{\n\tu8 sel_bit = clk_rdesc_get(g->clocks, g->selector);\n\n\t \n\tr9a06g032_clk_gate_set(g->clocks, &g->gate[!sel_bit], 0);\n\tr9a06g032_clk_gate_set(g->clocks, &g->gate[sel_bit], enable);\n\n\treturn 0;\n}\n\nstatic int r9a06g032_clk_dualgate_enable(struct clk_hw *hw)\n{\n\tstruct r9a06g032_clk_dualgate *gate = to_clk_dualgate(hw);\n\n\tr9a06g032_clk_dualgate_setenable(gate, 1);\n\n\treturn 0;\n}\n\nstatic void r9a06g032_clk_dualgate_disable(struct clk_hw *hw)\n{\n\tstruct r9a06g032_clk_dualgate *gate = to_clk_dualgate(hw);\n\n\tr9a06g032_clk_dualgate_setenable(gate, 0);\n}\n\nstatic int r9a06g032_clk_dualgate_is_enabled(struct clk_hw *hw)\n{\n\tstruct r9a06g032_clk_dualgate *g = to_clk_dualgate(hw);\n\tu8 sel_bit = clk_rdesc_get(g->clocks, g->selector);\n\n\treturn clk_rdesc_get(g->clocks, g->gate[sel_bit].gate);\n}\n\nstatic const struct clk_ops r9a06g032_clk_dualgate_ops = {\n\t.enable = r9a06g032_clk_dualgate_enable,\n\t.disable = r9a06g032_clk_dualgate_disable,\n\t.is_enabled = r9a06g032_clk_dualgate_is_enabled,\n};\n\nstatic struct clk *\nr9a06g032_register_dualgate(struct r9a06g032_priv *clocks,\n\t\t\t    const char *parent_name,\n\t\t\t    const struct r9a06g032_clkdesc *desc,\n\t\t\t    struct regbit sel)\n{\n\tstruct r9a06g032_clk_dualgate *g;\n\tstruct clk *clk;\n\tstruct clk_init_data init = {};\n\n\t \n\tg = kzalloc(sizeof(*g), GFP_KERNEL);\n\tif (!g)\n\t\treturn NULL;\n\tg->clocks = clocks;\n\tg->index = desc->index;\n\tg->selector = sel;\n\tg->gate[0].gate = desc->dual.g1;\n\tg->gate[0].reset = desc->dual.r1;\n\tg->gate[1].gate = desc->dual.g2;\n\tg->gate[1].reset = desc->dual.r2;\n\n\tinit.name = desc->name;\n\tinit.ops = &r9a06g032_clk_dualgate_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tg->hw.init = &init;\n\t \n\tif (r9a06g032_clk_dualgate_is_enabled(&g->hw)) {\n\t\tinit.flags |= CLK_IS_CRITICAL;\n\t\tpr_debug(\"%s was enabled, making read-only\\n\", desc->name);\n\t}\n\n\tclk = clk_register(NULL, &g->hw);\n\tif (IS_ERR(clk)) {\n\t\tkfree(g);\n\t\treturn NULL;\n\t}\n\treturn clk;\n}\n\nstatic void r9a06g032_clocks_del_clk_provider(void *data)\n{\n\tof_clk_del_provider(data);\n}\n\nstatic void __init r9a06g032_init_h2mode(struct r9a06g032_priv *clocks)\n{\n\tstruct device_node *usbf_np = NULL;\n\tu32 usb;\n\n\twhile ((usbf_np = of_find_compatible_node(usbf_np, NULL,\n\t\t\t\t\t\t  \"renesas,rzn1-usbf\"))) {\n\t\tif (of_device_is_available(usbf_np))\n\t\t\tbreak;\n\t}\n\n\tusb = readl(clocks->reg + R9A06G032_SYSCTRL_USB);\n\tif (usbf_np) {\n\t\t \n\t\tusb &= ~R9A06G032_SYSCTRL_USB_H2MODE;\n\t\tof_node_put(usbf_np);\n\t} else {\n\t\t \n\t\tusb |= R9A06G032_SYSCTRL_USB_H2MODE;\n\t}\n\twritel(usb, clocks->reg + R9A06G032_SYSCTRL_USB);\n}\n\nstatic int __init r9a06g032_clocks_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct r9a06g032_priv *clocks;\n\tstruct clk **clks;\n\tstruct clk *mclk;\n\tunsigned int i;\n\tstruct regbit uart_group_sel[2];\n\tint error;\n\n\tclocks = devm_kzalloc(dev, sizeof(*clocks), GFP_KERNEL);\n\tclks = devm_kcalloc(dev, R9A06G032_CLOCK_COUNT, sizeof(struct clk *),\n\t\t\t    GFP_KERNEL);\n\tif (!clocks || !clks)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&clocks->lock);\n\n\tclocks->data.clks = clks;\n\tclocks->data.clk_num = R9A06G032_CLOCK_COUNT;\n\n\tmclk = devm_clk_get(dev, \"mclk\");\n\tif (IS_ERR(mclk))\n\t\treturn PTR_ERR(mclk);\n\n\tclocks->reg = of_iomap(np, 0);\n\tif (WARN_ON(!clocks->reg))\n\t\treturn -ENOMEM;\n\n\tr9a06g032_init_h2mode(clocks);\n\n\tfor (i = 0; i < ARRAY_SIZE(r9a06g032_clocks); ++i) {\n\t\tconst struct r9a06g032_clkdesc *d = &r9a06g032_clocks[i];\n\t\tconst char *parent_name = d->source ?\n\t\t\t__clk_get_name(clocks->data.clks[d->source - 1]) :\n\t\t\t__clk_get_name(mclk);\n\t\tstruct clk *clk = NULL;\n\n\t\tswitch (d->type) {\n\t\tcase K_FFC:\n\t\t\tclk = clk_register_fixed_factor(NULL, d->name,\n\t\t\t\t\t\t\tparent_name, 0,\n\t\t\t\t\t\t\td->mul, d->div);\n\t\t\tbreak;\n\t\tcase K_GATE:\n\t\t\tclk = r9a06g032_register_gate(clocks, parent_name, d);\n\t\t\tbreak;\n\t\tcase K_DIV:\n\t\t\tclk = r9a06g032_register_div(clocks, parent_name, d);\n\t\t\tbreak;\n\t\tcase K_BITSEL:\n\t\t\t \n\t\t\tuart_group_sel[d->dual.group] = d->dual.sel;\n\t\t\tclk = r9a06g032_register_bitsel(clocks, parent_name, d);\n\t\t\tbreak;\n\t\tcase K_DUALGATE:\n\t\t\tclk = r9a06g032_register_dualgate(clocks, parent_name,\n\t\t\t\t\t\t\t  d,\n\t\t\t\t\t\t\t  uart_group_sel[d->dual.group]);\n\t\t\tbreak;\n\t\t}\n\t\tclocks->data.clks[d->index] = clk;\n\t}\n\terror = of_clk_add_provider(np, of_clk_src_onecell_get, &clocks->data);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_add_action_or_reset(dev,\n\t\t\t\t\tr9a06g032_clocks_del_clk_provider, np);\n\tif (error)\n\t\treturn error;\n\n\terror = r9a06g032_add_clk_domain(dev);\n\tif (error)\n\t\treturn error;\n\n\tsysctrl_priv = clocks;\n\n\terror = of_platform_populate(np, NULL, NULL, dev);\n\tif (error)\n\t\tdev_err(dev, \"Failed to populate children (%d)\\n\", error);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id r9a06g032_match[] = {\n\t{ .compatible = \"renesas,r9a06g032-sysctrl\" },\n\t{ }\n};\n\nstatic struct platform_driver r9a06g032_clock_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"renesas,r9a06g032-sysctrl\",\n\t\t.of_match_table = r9a06g032_match,\n\t},\n};\n\nstatic int __init r9a06g032_clocks_init(void)\n{\n\treturn platform_driver_probe(&r9a06g032_clock_driver,\n\t\t\tr9a06g032_clocks_probe);\n}\n\nsubsys_initcall(r9a06g032_clocks_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}