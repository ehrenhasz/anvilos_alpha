{
  "module_name": "clk-div6.c",
  "hash_id": "685e53b0c38d4e491fcb72c159dcf7e99ca774f894a0bf23fcd3a9418b1906b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/renesas/clk-div6.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/notifier.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n\n#include \"clk-div6.h\"\n\n#define CPG_DIV6_CKSTP\t\tBIT(8)\n#define CPG_DIV6_DIV(d)\t\t((d) & 0x3f)\n#define CPG_DIV6_DIV_MASK\t0x3f\n\n \nstruct div6_clock {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n\tunsigned int div;\n\tu32 src_mask;\n\tstruct notifier_block nb;\n\tu8 parents[];\n};\n\n#define to_div6_clock(_hw) container_of(_hw, struct div6_clock, hw)\n\nstatic int cpg_div6_clock_enable(struct clk_hw *hw)\n{\n\tstruct div6_clock *clock = to_div6_clock(hw);\n\tu32 val;\n\n\tval = (readl(clock->reg) & ~(CPG_DIV6_DIV_MASK | CPG_DIV6_CKSTP))\n\t    | CPG_DIV6_DIV(clock->div - 1);\n\twritel(val, clock->reg);\n\n\treturn 0;\n}\n\nstatic void cpg_div6_clock_disable(struct clk_hw *hw)\n{\n\tstruct div6_clock *clock = to_div6_clock(hw);\n\tu32 val;\n\n\tval = readl(clock->reg);\n\tval |= CPG_DIV6_CKSTP;\n\t \n\tif (!(val & CPG_DIV6_DIV_MASK))\n\t\tval |= CPG_DIV6_DIV_MASK;\n\twritel(val, clock->reg);\n}\n\nstatic int cpg_div6_clock_is_enabled(struct clk_hw *hw)\n{\n\tstruct div6_clock *clock = to_div6_clock(hw);\n\n\treturn !(readl(clock->reg) & CPG_DIV6_CKSTP);\n}\n\nstatic unsigned long cpg_div6_clock_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct div6_clock *clock = to_div6_clock(hw);\n\n\treturn parent_rate / clock->div;\n}\n\nstatic unsigned int cpg_div6_clock_calc_div(unsigned long rate,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tunsigned int div;\n\n\tif (!rate)\n\t\trate = 1;\n\n\tdiv = DIV_ROUND_CLOSEST(parent_rate, rate);\n\treturn clamp(div, 1U, 64U);\n}\n\nstatic int cpg_div6_clock_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t struct clk_rate_request *req)\n{\n\tunsigned long prate, calc_rate, diff, best_rate, best_prate;\n\tunsigned int num_parents = clk_hw_get_num_parents(hw);\n\tstruct clk_hw *parent, *best_parent = NULL;\n\tunsigned int i, min_div, max_div, div;\n\tunsigned long min_diff = ULONG_MAX;\n\n\tfor (i = 0; i < num_parents; i++) {\n\t\tparent = clk_hw_get_parent_by_index(hw, i);\n\t\tif (!parent)\n\t\t\tcontinue;\n\n\t\tprate = clk_hw_get_rate(parent);\n\t\tif (!prate)\n\t\t\tcontinue;\n\n\t\tmin_div = max(DIV_ROUND_UP(prate, req->max_rate), 1UL);\n\t\tmax_div = req->min_rate ? min(prate / req->min_rate, 64UL) : 64;\n\t\tif (max_div < min_div)\n\t\t\tcontinue;\n\n\t\tdiv = cpg_div6_clock_calc_div(req->rate, prate);\n\t\tdiv = clamp(div, min_div, max_div);\n\t\tcalc_rate = prate / div;\n\t\tdiff = calc_rate > req->rate ? calc_rate - req->rate\n\t\t\t\t\t     : req->rate - calc_rate;\n\t\tif (diff < min_diff) {\n\t\t\tbest_rate = calc_rate;\n\t\t\tbest_parent = parent;\n\t\t\tbest_prate = prate;\n\t\t\tmin_diff = diff;\n\t\t}\n\t}\n\n\tif (!best_parent)\n\t\treturn -EINVAL;\n\n\treq->best_parent_rate = best_prate;\n\treq->best_parent_hw = best_parent;\n\treq->rate = best_rate;\n\treturn 0;\n}\n\nstatic int cpg_div6_clock_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct div6_clock *clock = to_div6_clock(hw);\n\tunsigned int div = cpg_div6_clock_calc_div(rate, parent_rate);\n\tu32 val;\n\n\tclock->div = div;\n\n\tval = readl(clock->reg) & ~CPG_DIV6_DIV_MASK;\n\t \n\tif (!(val & CPG_DIV6_CKSTP))\n\t\twritel(val | CPG_DIV6_DIV(clock->div - 1), clock->reg);\n\n\treturn 0;\n}\n\nstatic u8 cpg_div6_clock_get_parent(struct clk_hw *hw)\n{\n\tstruct div6_clock *clock = to_div6_clock(hw);\n\tunsigned int i;\n\tu8 hw_index;\n\n\tif (clock->src_mask == 0)\n\t\treturn 0;\n\n\thw_index = (readl(clock->reg) & clock->src_mask) >>\n\t\t   __ffs(clock->src_mask);\n\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\n\t\tif (clock->parents[i] == hw_index)\n\t\t\treturn i;\n\t}\n\n\tpr_err(\"%s: %s DIV6 clock set to invalid parent %u\\n\",\n\t       __func__, clk_hw_get_name(hw), hw_index);\n\treturn 0;\n}\n\nstatic int cpg_div6_clock_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct div6_clock *clock = to_div6_clock(hw);\n\tu32 src;\n\n\tif (index >= clk_hw_get_num_parents(hw))\n\t\treturn -EINVAL;\n\n\tsrc = clock->parents[index] << __ffs(clock->src_mask);\n\twritel((readl(clock->reg) & ~clock->src_mask) | src, clock->reg);\n\treturn 0;\n}\n\nstatic const struct clk_ops cpg_div6_clock_ops = {\n\t.enable = cpg_div6_clock_enable,\n\t.disable = cpg_div6_clock_disable,\n\t.is_enabled = cpg_div6_clock_is_enabled,\n\t.get_parent = cpg_div6_clock_get_parent,\n\t.set_parent = cpg_div6_clock_set_parent,\n\t.recalc_rate = cpg_div6_clock_recalc_rate,\n\t.determine_rate = cpg_div6_clock_determine_rate,\n\t.set_rate = cpg_div6_clock_set_rate,\n};\n\nstatic int cpg_div6_clock_notifier_call(struct notifier_block *nb,\n\t\t\t\t\tunsigned long action, void *data)\n{\n\tstruct div6_clock *clock = container_of(nb, struct div6_clock, nb);\n\n\tswitch (action) {\n\tcase PM_EVENT_RESUME:\n\t\t \n\t\tif (__clk_get_enable_count(clock->hw.clk))\n\t\t\tcpg_div6_clock_enable(&clock->hw);\n\t\telse\n\t\t\tcpg_div6_clock_disable(&clock->hw);\n\t\treturn NOTIFY_OK;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \nstruct clk * __init cpg_div6_register(const char *name,\n\t\t\t\t      unsigned int num_parents,\n\t\t\t\t      const char **parent_names,\n\t\t\t\t      void __iomem *reg,\n\t\t\t\t      struct raw_notifier_head *notifiers)\n{\n\tunsigned int valid_parents;\n\tstruct clk_init_data init = {};\n\tstruct div6_clock *clock;\n\tstruct clk *clk;\n\tunsigned int i;\n\n\tclock = kzalloc(struct_size(clock, parents, num_parents), GFP_KERNEL);\n\tif (!clock)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclock->reg = reg;\n\n\t \n\tclock->div = (readl(clock->reg) & CPG_DIV6_DIV_MASK) + 1;\n\n\tswitch (num_parents) {\n\tcase 1:\n\t\t \n\t\tclock->src_mask = 0;\n\t\tbreak;\n\tcase 4:\n\t\t \n\t\tclock->src_mask = GENMASK(7, 6);\n\t\tbreak;\n\tcase 8:\n\t\t \n\t\tclock->src_mask = GENMASK(14, 12);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: invalid number of parents for DIV6 clock %s\\n\",\n\t\t       __func__, name);\n\t\tclk = ERR_PTR(-EINVAL);\n\t\tgoto free_clock;\n\t}\n\n\t \n\tfor (i = 0, valid_parents = 0; i < num_parents; i++) {\n\t\tif (parent_names[i]) {\n\t\t\tparent_names[valid_parents] = parent_names[i];\n\t\t\tclock->parents[valid_parents] = i;\n\t\t\tvalid_parents++;\n\t\t}\n\t}\n\n\t \n\tinit.name = name;\n\tinit.ops = &cpg_div6_clock_ops;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = valid_parents;\n\n\tclock->hw.init = &init;\n\n\tclk = clk_register(NULL, &clock->hw);\n\tif (IS_ERR(clk))\n\t\tgoto free_clock;\n\n\tif (notifiers) {\n\t\tclock->nb.notifier_call = cpg_div6_clock_notifier_call;\n\t\traw_notifier_chain_register(notifiers, &clock->nb);\n\t}\n\n\treturn clk;\n\nfree_clock:\n\tkfree(clock);\n\treturn clk;\n}\n\nstatic void __init cpg_div6_clock_init(struct device_node *np)\n{\n\tunsigned int num_parents;\n\tconst char **parent_names;\n\tconst char *clk_name = np->name;\n\tvoid __iomem *reg;\n\tstruct clk *clk;\n\tunsigned int i;\n\n\tnum_parents = of_clk_get_parent_count(np);\n\tif (num_parents < 1) {\n\t\tpr_err(\"%s: no parent found for %pOFn DIV6 clock\\n\",\n\t\t       __func__, np);\n\t\treturn;\n\t}\n\n\tparent_names = kmalloc_array(num_parents, sizeof(*parent_names),\n\t\t\t\tGFP_KERNEL);\n\tif (!parent_names)\n\t\treturn;\n\n\treg = of_iomap(np, 0);\n\tif (reg == NULL) {\n\t\tpr_err(\"%s: failed to map %pOFn DIV6 clock register\\n\",\n\t\t       __func__, np);\n\t\tgoto error;\n\t}\n\n\t \n\tof_property_read_string(np, \"clock-output-names\", &clk_name);\n\n\tfor (i = 0; i < num_parents; i++)\n\t\tparent_names[i] = of_clk_get_parent_name(np, i);\n\n\tclk = cpg_div6_register(clk_name, num_parents, parent_names, reg, NULL);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: failed to register %pOFn DIV6 clock (%ld)\\n\",\n\t\t       __func__, np, PTR_ERR(clk));\n\t\tgoto error;\n\t}\n\n\tof_clk_add_provider(np, of_clk_src_simple_get, clk);\n\n\tkfree(parent_names);\n\treturn;\n\nerror:\n\tif (reg)\n\t\tiounmap(reg);\n\tkfree(parent_names);\n}\nCLK_OF_DECLARE(cpg_div6_clk, \"renesas,cpg-div6-clock\", cpg_div6_clock_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}