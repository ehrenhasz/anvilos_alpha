{
  "module_name": "reset.c",
  "hash_id": "57646ac188a9c6a9b2bac858e39b0e83dca6cdc39d24b8e563e2505c48d628f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/hisilicon/reset.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include \"reset.h\"\n\n#define\tHISI_RESET_BIT_MASK\t0x1f\n#define\tHISI_RESET_OFFSET_SHIFT\t8\n#define\tHISI_RESET_OFFSET_MASK\t0xffff00\n\nstruct hisi_reset_controller {\n\tspinlock_t\tlock;\n\tvoid __iomem\t*membase;\n\tstruct reset_controller_dev\trcdev;\n};\n\n\n#define to_hisi_reset_controller(rcdev)  \\\n\tcontainer_of(rcdev, struct hisi_reset_controller, rcdev)\n\nstatic int hisi_reset_of_xlate(struct reset_controller_dev *rcdev,\n\t\t\tconst struct of_phandle_args *reset_spec)\n{\n\tu32 offset;\n\tu8 bit;\n\n\toffset = (reset_spec->args[0] << HISI_RESET_OFFSET_SHIFT)\n\t\t& HISI_RESET_OFFSET_MASK;\n\tbit = reset_spec->args[1] & HISI_RESET_BIT_MASK;\n\n\treturn (offset | bit);\n}\n\nstatic int hisi_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct hisi_reset_controller *rstc = to_hisi_reset_controller(rcdev);\n\tunsigned long flags;\n\tu32 offset, reg;\n\tu8 bit;\n\n\toffset = (id & HISI_RESET_OFFSET_MASK) >> HISI_RESET_OFFSET_SHIFT;\n\tbit = id & HISI_RESET_BIT_MASK;\n\n\tspin_lock_irqsave(&rstc->lock, flags);\n\n\treg = readl(rstc->membase + offset);\n\twritel(reg | BIT(bit), rstc->membase + offset);\n\n\tspin_unlock_irqrestore(&rstc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int hisi_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\tstruct hisi_reset_controller *rstc = to_hisi_reset_controller(rcdev);\n\tunsigned long flags;\n\tu32 offset, reg;\n\tu8 bit;\n\n\toffset = (id & HISI_RESET_OFFSET_MASK) >> HISI_RESET_OFFSET_SHIFT;\n\tbit = id & HISI_RESET_BIT_MASK;\n\n\tspin_lock_irqsave(&rstc->lock, flags);\n\n\treg = readl(rstc->membase + offset);\n\twritel(reg & ~BIT(bit), rstc->membase + offset);\n\n\tspin_unlock_irqrestore(&rstc->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct reset_control_ops hisi_reset_ops = {\n\t.assert\t\t= hisi_reset_assert,\n\t.deassert\t= hisi_reset_deassert,\n};\n\nstruct hisi_reset_controller *hisi_reset_init(struct platform_device *pdev)\n{\n\tstruct hisi_reset_controller *rstc;\n\n\trstc = devm_kmalloc(&pdev->dev, sizeof(*rstc), GFP_KERNEL);\n\tif (!rstc)\n\t\treturn NULL;\n\n\trstc->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rstc->membase))\n\t\treturn NULL;\n\n\tspin_lock_init(&rstc->lock);\n\trstc->rcdev.owner = THIS_MODULE;\n\trstc->rcdev.ops = &hisi_reset_ops;\n\trstc->rcdev.of_node = pdev->dev.of_node;\n\trstc->rcdev.of_reset_n_cells = 2;\n\trstc->rcdev.of_xlate = hisi_reset_of_xlate;\n\treset_controller_register(&rstc->rcdev);\n\n\treturn rstc;\n}\nEXPORT_SYMBOL_GPL(hisi_reset_init);\n\nvoid hisi_reset_exit(struct hisi_reset_controller *rstc)\n{\n\treset_controller_unregister(&rstc->rcdev);\n}\nEXPORT_SYMBOL_GPL(hisi_reset_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}