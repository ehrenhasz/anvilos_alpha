{
  "module_name": "clk-hisi-phase.c",
  "hash_id": "e519100e774727319742c8d5c9ef1c1bec6d9300471bacc87b9677303c50f658",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/hisilicon/clk-hisi-phase.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\nstruct clk_hisi_phase {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*reg;\n\tu32\t\t*phase_degrees;\n\tu32\t\t*phase_regvals;\n\tu8\t\tphase_num;\n\tu32\t\tmask;\n\tu8\t\tshift;\n\tu8\t\tflags;\n\tspinlock_t\t*lock;\n};\n\n#define to_clk_hisi_phase(_hw) container_of(_hw, struct clk_hisi_phase, hw)\n\nstatic int hisi_phase_regval_to_degrees(struct clk_hisi_phase *phase,\n\t\t\t\t\tu32 regval)\n{\n\tint i;\n\n\tfor (i = 0; i < phase->phase_num; i++)\n\t\tif (phase->phase_regvals[i] == regval)\n\t\t\treturn phase->phase_degrees[i];\n\n\treturn -EINVAL;\n}\n\nstatic int hisi_clk_get_phase(struct clk_hw *hw)\n{\n\tstruct clk_hisi_phase *phase = to_clk_hisi_phase(hw);\n\tu32 regval;\n\n\tregval = readl(phase->reg);\n\tregval = (regval & phase->mask) >> phase->shift;\n\n\treturn hisi_phase_regval_to_degrees(phase, regval);\n}\n\nstatic int hisi_phase_degrees_to_regval(struct clk_hisi_phase *phase,\n\t\t\t\t\tint degrees)\n{\n\tint i;\n\n\tfor (i = 0; i < phase->phase_num; i++)\n\t\tif (phase->phase_degrees[i] == degrees)\n\t\t\treturn phase->phase_regvals[i];\n\n\treturn -EINVAL;\n}\n\nstatic int hisi_clk_set_phase(struct clk_hw *hw, int degrees)\n{\n\tstruct clk_hisi_phase *phase = to_clk_hisi_phase(hw);\n\tunsigned long flags = 0;\n\tint regval;\n\tu32 val;\n\n\tregval = hisi_phase_degrees_to_regval(phase, degrees);\n\tif (regval < 0)\n\t\treturn regval;\n\n\tspin_lock_irqsave(phase->lock, flags);\n\n\tval = readl(phase->reg);\n\tval &= ~phase->mask;\n\tval |= regval << phase->shift;\n\twritel(val, phase->reg);\n\n\tspin_unlock_irqrestore(phase->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_phase_ops = {\n\t.get_phase = hisi_clk_get_phase,\n\t.set_phase = hisi_clk_set_phase,\n};\n\nstruct clk *clk_register_hisi_phase(struct device *dev,\n\t\tconst struct hisi_phase_clock *clks,\n\t\tvoid __iomem *base, spinlock_t *lock)\n{\n\tstruct clk_hisi_phase *phase;\n\tstruct clk_init_data init;\n\n\tphase = devm_kzalloc(dev, sizeof(struct clk_hisi_phase), GFP_KERNEL);\n\tif (!phase)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = clks->name;\n\tinit.ops = &clk_phase_ops;\n\tinit.flags = clks->flags;\n\tinit.parent_names = clks->parent_names ? &clks->parent_names : NULL;\n\tinit.num_parents = clks->parent_names ? 1 : 0;\n\n\tphase->reg = base + clks->offset;\n\tphase->shift = clks->shift;\n\tphase->mask = (BIT(clks->width) - 1) << clks->shift;\n\tphase->lock = lock;\n\tphase->phase_degrees = clks->phase_degrees;\n\tphase->phase_regvals = clks->phase_regvals;\n\tphase->phase_num = clks->phase_num;\n\tphase->hw.init = &init;\n\n\treturn devm_clk_register(dev, &phase->hw);\n}\nEXPORT_SYMBOL_GPL(clk_register_hisi_phase);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}