{
  "module_name": "clkgate-separated.c",
  "hash_id": "dbf96507d26478d015d5492f457b8b49d69412e649f4f962d2c91bb6b16013a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/hisilicon/clkgate-separated.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\n \n#define CLKGATE_SEPERATED_ENABLE\t\t0x0\n#define CLKGATE_SEPERATED_DISABLE\t\t0x4\n#define CLKGATE_SEPERATED_STATUS\t\t0x8\n\nstruct clkgate_separated {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*enable;\t \n\tu8\t\tbit_idx;\t \n\tu8\t\tflags;\n\tspinlock_t\t*lock;\n};\n\nstatic int clkgate_separated_enable(struct clk_hw *hw)\n{\n\tstruct clkgate_separated *sclk;\n\tunsigned long flags = 0;\n\tu32 reg;\n\n\tsclk = container_of(hw, struct clkgate_separated, hw);\n\tif (sclk->lock)\n\t\tspin_lock_irqsave(sclk->lock, flags);\n\treg = BIT(sclk->bit_idx);\n\twritel_relaxed(reg, sclk->enable);\n\treadl_relaxed(sclk->enable + CLKGATE_SEPERATED_STATUS);\n\tif (sclk->lock)\n\t\tspin_unlock_irqrestore(sclk->lock, flags);\n\treturn 0;\n}\n\nstatic void clkgate_separated_disable(struct clk_hw *hw)\n{\n\tstruct clkgate_separated *sclk;\n\tunsigned long flags = 0;\n\tu32 reg;\n\n\tsclk = container_of(hw, struct clkgate_separated, hw);\n\tif (sclk->lock)\n\t\tspin_lock_irqsave(sclk->lock, flags);\n\treg = BIT(sclk->bit_idx);\n\twritel_relaxed(reg, sclk->enable + CLKGATE_SEPERATED_DISABLE);\n\treadl_relaxed(sclk->enable + CLKGATE_SEPERATED_STATUS);\n\tif (sclk->lock)\n\t\tspin_unlock_irqrestore(sclk->lock, flags);\n}\n\nstatic int clkgate_separated_is_enabled(struct clk_hw *hw)\n{\n\tstruct clkgate_separated *sclk;\n\tu32 reg;\n\n\tsclk = container_of(hw, struct clkgate_separated, hw);\n\treg = readl_relaxed(sclk->enable + CLKGATE_SEPERATED_STATUS);\n\treg &= BIT(sclk->bit_idx);\n\n\treturn reg ? 1 : 0;\n}\n\nstatic const struct clk_ops clkgate_separated_ops = {\n\t.enable\t\t= clkgate_separated_enable,\n\t.disable\t= clkgate_separated_disable,\n\t.is_enabled\t= clkgate_separated_is_enabled,\n};\n\nstruct clk *hisi_register_clkgate_sep(struct device *dev, const char *name,\n\t\t\t\t      const char *parent_name,\n\t\t\t\t      unsigned long flags,\n\t\t\t\t      void __iomem *reg, u8 bit_idx,\n\t\t\t\t      u8 clk_gate_flags, spinlock_t *lock)\n{\n\tstruct clkgate_separated *sclk;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\tsclk = kzalloc(sizeof(*sclk), GFP_KERNEL);\n\tif (!sclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &clkgate_separated_ops;\n\tinit.flags = flags;\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\n\tsclk->enable = reg + CLKGATE_SEPERATED_ENABLE;\n\tsclk->bit_idx = bit_idx;\n\tsclk->flags = clk_gate_flags;\n\tsclk->hw.init = &init;\n\tsclk->lock = lock;\n\n\tclk = clk_register(dev, &sclk->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(sclk);\n\treturn clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}