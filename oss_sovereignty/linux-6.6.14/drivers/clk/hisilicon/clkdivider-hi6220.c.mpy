{
  "module_name": "clkdivider-hi6220.c",
  "hash_id": "f7eba2dfedb151a85af29edfc3b80d82ffbe5ac4b608554e8b7109c51585257c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/hisilicon/clkdivider-hi6220.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/spinlock.h>\n\n#include \"clk.h\"\n\n#define div_mask(width)\t((1 << (width)) - 1)\n\n \nstruct hi6220_clk_divider {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*reg;\n\tu8\t\tshift;\n\tu8\t\twidth;\n\tu32\t\tmask;\n\tconst struct clk_div_table *table;\n\tspinlock_t\t*lock;\n};\n\n#define to_hi6220_clk_divider(_hw)\t\\\n\tcontainer_of(_hw, struct hi6220_clk_divider, hw)\n\nstatic unsigned long hi6220_clkdiv_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tunsigned int val;\n\tstruct hi6220_clk_divider *dclk = to_hi6220_clk_divider(hw);\n\n\tval = readl_relaxed(dclk->reg) >> dclk->shift;\n\tval &= div_mask(dclk->width);\n\n\treturn divider_recalc_rate(hw, parent_rate, val, dclk->table,\n\t\t\t\t   CLK_DIVIDER_ROUND_CLOSEST, dclk->width);\n}\n\nstatic long hi6220_clkdiv_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\tunsigned long *prate)\n{\n\tstruct hi6220_clk_divider *dclk = to_hi6220_clk_divider(hw);\n\n\treturn divider_round_rate(hw, rate, prate, dclk->table,\n\t\t\t\t  dclk->width, CLK_DIVIDER_ROUND_CLOSEST);\n}\n\nstatic int hi6220_clkdiv_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tint value;\n\tunsigned long flags = 0;\n\tu32 data;\n\tstruct hi6220_clk_divider *dclk = to_hi6220_clk_divider(hw);\n\n\tvalue = divider_get_val(rate, parent_rate, dclk->table,\n\t\t\t\tdclk->width, CLK_DIVIDER_ROUND_CLOSEST);\n\n\tif (dclk->lock)\n\t\tspin_lock_irqsave(dclk->lock, flags);\n\n\tdata = readl_relaxed(dclk->reg);\n\tdata &= ~(div_mask(dclk->width) << dclk->shift);\n\tdata |= value << dclk->shift;\n\tdata |= dclk->mask;\n\n\twritel_relaxed(data, dclk->reg);\n\n\tif (dclk->lock)\n\t\tspin_unlock_irqrestore(dclk->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops hi6220_clkdiv_ops = {\n\t.recalc_rate = hi6220_clkdiv_recalc_rate,\n\t.round_rate = hi6220_clkdiv_round_rate,\n\t.set_rate = hi6220_clkdiv_set_rate,\n};\n\nstruct clk *hi6220_register_clkdiv(struct device *dev, const char *name,\n\tconst char *parent_name, unsigned long flags, void __iomem *reg,\n\tu8 shift, u8 width, u32 mask_bit, spinlock_t *lock)\n{\n\tstruct hi6220_clk_divider *div;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\tstruct clk_div_table *table;\n\tu32 max_div, min_div;\n\tint i;\n\n\t \n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tmax_div = div_mask(width) + 1;\n\tmin_div = 1;\n\n\ttable = kcalloc(max_div + 1, sizeof(*table), GFP_KERNEL);\n\tif (!table) {\n\t\tkfree(div);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfor (i = 0; i < max_div; i++) {\n\t\ttable[i].div = min_div + i;\n\t\ttable[i].val = table[i].div - 1;\n\t}\n\n\tinit.name = name;\n\tinit.ops = &hi6220_clkdiv_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\n\t \n\tdiv->reg = reg;\n\tdiv->shift = shift;\n\tdiv->width = width;\n\tdiv->mask = mask_bit ? BIT(mask_bit) : 0;\n\tdiv->lock = lock;\n\tdiv->hw.init = &init;\n\tdiv->table = table;\n\n\t \n\tclk = clk_register(dev, &div->hw);\n\tif (IS_ERR(clk)) {\n\t\tkfree(table);\n\t\tkfree(div);\n\t}\n\n\treturn clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}