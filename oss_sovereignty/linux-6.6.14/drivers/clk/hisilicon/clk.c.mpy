{
  "module_name": "clk.c",
  "hash_id": "f64df887e32d0aea36e4ca3f58816bd01906d6e47a65ca971fe544d27404d3a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/hisilicon/clk.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\nstatic DEFINE_SPINLOCK(hisi_clk_lock);\n\nstruct hisi_clock_data *hisi_clk_alloc(struct platform_device *pdev,\n\t\t\t\t\t\tint nr_clks)\n{\n\tstruct hisi_clock_data *clk_data;\n\tstruct resource *res;\n\tstruct clk **clk_table;\n\n\tclk_data = devm_kmalloc(&pdev->dev, sizeof(*clk_data), GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn NULL;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn NULL;\n\tclk_data->base = devm_ioremap(&pdev->dev,\n\t\t\t\tres->start, resource_size(res));\n\tif (!clk_data->base)\n\t\treturn NULL;\n\n\tclk_table = devm_kmalloc_array(&pdev->dev, nr_clks,\n\t\t\t\t       sizeof(*clk_table),\n\t\t\t\t       GFP_KERNEL);\n\tif (!clk_table)\n\t\treturn NULL;\n\n\tclk_data->clk_data.clks = clk_table;\n\tclk_data->clk_data.clk_num = nr_clks;\n\n\treturn clk_data;\n}\nEXPORT_SYMBOL_GPL(hisi_clk_alloc);\n\nstruct hisi_clock_data *hisi_clk_init(struct device_node *np,\n\t\t\t\t\t     int nr_clks)\n{\n\tstruct hisi_clock_data *clk_data;\n\tstruct clk **clk_table;\n\tvoid __iomem *base;\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tpr_err(\"%s: failed to map clock registers\\n\", __func__);\n\t\tgoto err;\n\t}\n\n\tclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\n\tif (!clk_data)\n\t\tgoto err;\n\n\tclk_data->base = base;\n\tclk_table = kcalloc(nr_clks, sizeof(*clk_table), GFP_KERNEL);\n\tif (!clk_table)\n\t\tgoto err_data;\n\n\tclk_data->clk_data.clks = clk_table;\n\tclk_data->clk_data.clk_num = nr_clks;\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &clk_data->clk_data);\n\treturn clk_data;\nerr_data:\n\tkfree(clk_data);\nerr:\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(hisi_clk_init);\n\nint hisi_clk_register_fixed_rate(const struct hisi_fixed_rate_clock *clks,\n\t\t\t\t\t int nums, struct hisi_clock_data *data)\n{\n\tstruct clk *clk;\n\tint i;\n\n\tfor (i = 0; i < nums; i++) {\n\t\tclk = clk_register_fixed_rate(NULL, clks[i].name,\n\t\t\t\t\t      clks[i].parent_name,\n\t\t\t\t\t      clks[i].flags,\n\t\t\t\t\t      clks[i].fixed_rate);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tgoto err;\n\t\t}\n\t\tdata->clk_data.clks[clks[i].id] = clk;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (i--)\n\t\tclk_unregister_fixed_rate(data->clk_data.clks[clks[i].id]);\n\n\treturn PTR_ERR(clk);\n}\nEXPORT_SYMBOL_GPL(hisi_clk_register_fixed_rate);\n\nint hisi_clk_register_fixed_factor(const struct hisi_fixed_factor_clock *clks,\n\t\t\t\t\t   int nums,\n\t\t\t\t\t   struct hisi_clock_data *data)\n{\n\tstruct clk *clk;\n\tint i;\n\n\tfor (i = 0; i < nums; i++) {\n\t\tclk = clk_register_fixed_factor(NULL, clks[i].name,\n\t\t\t\t\t\tclks[i].parent_name,\n\t\t\t\t\t\tclks[i].flags, clks[i].mult,\n\t\t\t\t\t\tclks[i].div);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tgoto err;\n\t\t}\n\t\tdata->clk_data.clks[clks[i].id] = clk;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (i--)\n\t\tclk_unregister_fixed_factor(data->clk_data.clks[clks[i].id]);\n\n\treturn PTR_ERR(clk);\n}\nEXPORT_SYMBOL_GPL(hisi_clk_register_fixed_factor);\n\nint hisi_clk_register_mux(const struct hisi_mux_clock *clks,\n\t\t\t\t  int nums, struct hisi_clock_data *data)\n{\n\tstruct clk *clk;\n\tvoid __iomem *base = data->base;\n\tint i;\n\n\tfor (i = 0; i < nums; i++) {\n\t\tu32 mask = BIT(clks[i].width) - 1;\n\n\t\tclk = clk_register_mux_table(NULL, clks[i].name,\n\t\t\t\t\tclks[i].parent_names,\n\t\t\t\t\tclks[i].num_parents, clks[i].flags,\n\t\t\t\t\tbase + clks[i].offset, clks[i].shift,\n\t\t\t\t\tmask, clks[i].mux_flags,\n\t\t\t\t\tclks[i].table, &hisi_clk_lock);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (clks[i].alias)\n\t\t\tclk_register_clkdev(clk, clks[i].alias, NULL);\n\n\t\tdata->clk_data.clks[clks[i].id] = clk;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (i--)\n\t\tclk_unregister_mux(data->clk_data.clks[clks[i].id]);\n\n\treturn PTR_ERR(clk);\n}\nEXPORT_SYMBOL_GPL(hisi_clk_register_mux);\n\nint hisi_clk_register_phase(struct device *dev,\n\t\t\t    const struct hisi_phase_clock *clks,\n\t\t\t    int nums, struct hisi_clock_data *data)\n{\n\tvoid __iomem *base = data->base;\n\tstruct clk *clk;\n\tint i;\n\n\tfor (i = 0; i < nums; i++) {\n\t\tclk = clk_register_hisi_phase(dev, &clks[i], base,\n\t\t\t\t\t      &hisi_clk_lock);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\", __func__,\n\t\t\t       clks[i].name);\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\n\t\tdata->clk_data.clks[clks[i].id] = clk;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hisi_clk_register_phase);\n\nint hisi_clk_register_divider(const struct hisi_divider_clock *clks,\n\t\t\t\t      int nums, struct hisi_clock_data *data)\n{\n\tstruct clk *clk;\n\tvoid __iomem *base = data->base;\n\tint i;\n\n\tfor (i = 0; i < nums; i++) {\n\t\tclk = clk_register_divider_table(NULL, clks[i].name,\n\t\t\t\t\t\t clks[i].parent_name,\n\t\t\t\t\t\t clks[i].flags,\n\t\t\t\t\t\t base + clks[i].offset,\n\t\t\t\t\t\t clks[i].shift, clks[i].width,\n\t\t\t\t\t\t clks[i].div_flags,\n\t\t\t\t\t\t clks[i].table,\n\t\t\t\t\t\t &hisi_clk_lock);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (clks[i].alias)\n\t\t\tclk_register_clkdev(clk, clks[i].alias, NULL);\n\n\t\tdata->clk_data.clks[clks[i].id] = clk;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (i--)\n\t\tclk_unregister_divider(data->clk_data.clks[clks[i].id]);\n\n\treturn PTR_ERR(clk);\n}\nEXPORT_SYMBOL_GPL(hisi_clk_register_divider);\n\nint hisi_clk_register_gate(const struct hisi_gate_clock *clks,\n\t\t\t\t       int nums, struct hisi_clock_data *data)\n{\n\tstruct clk *clk;\n\tvoid __iomem *base = data->base;\n\tint i;\n\n\tfor (i = 0; i < nums; i++) {\n\t\tclk = clk_register_gate(NULL, clks[i].name,\n\t\t\t\t\t\tclks[i].parent_name,\n\t\t\t\t\t\tclks[i].flags,\n\t\t\t\t\t\tbase + clks[i].offset,\n\t\t\t\t\t\tclks[i].bit_idx,\n\t\t\t\t\t\tclks[i].gate_flags,\n\t\t\t\t\t\t&hisi_clk_lock);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (clks[i].alias)\n\t\t\tclk_register_clkdev(clk, clks[i].alias, NULL);\n\n\t\tdata->clk_data.clks[clks[i].id] = clk;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (i--)\n\t\tclk_unregister_gate(data->clk_data.clks[clks[i].id]);\n\n\treturn PTR_ERR(clk);\n}\nEXPORT_SYMBOL_GPL(hisi_clk_register_gate);\n\nvoid hisi_clk_register_gate_sep(const struct hisi_gate_clock *clks,\n\t\t\t\t       int nums, struct hisi_clock_data *data)\n{\n\tstruct clk *clk;\n\tvoid __iomem *base = data->base;\n\tint i;\n\n\tfor (i = 0; i < nums; i++) {\n\t\tclk = hisi_register_clkgate_sep(NULL, clks[i].name,\n\t\t\t\t\t\tclks[i].parent_name,\n\t\t\t\t\t\tclks[i].flags,\n\t\t\t\t\t\tbase + clks[i].offset,\n\t\t\t\t\t\tclks[i].bit_idx,\n\t\t\t\t\t\tclks[i].gate_flags,\n\t\t\t\t\t\t&hisi_clk_lock);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (clks[i].alias)\n\t\t\tclk_register_clkdev(clk, clks[i].alias, NULL);\n\n\t\tdata->clk_data.clks[clks[i].id] = clk;\n\t}\n}\nEXPORT_SYMBOL_GPL(hisi_clk_register_gate_sep);\n\nvoid __init hi6220_clk_register_divider(const struct hi6220_divider_clock *clks,\n\t\t\t\t\tint nums, struct hisi_clock_data *data)\n{\n\tstruct clk *clk;\n\tvoid __iomem *base = data->base;\n\tint i;\n\n\tfor (i = 0; i < nums; i++) {\n\t\tclk = hi6220_register_clkdiv(NULL, clks[i].name,\n\t\t\t\t\t\tclks[i].parent_name,\n\t\t\t\t\t\tclks[i].flags,\n\t\t\t\t\t\tbase + clks[i].offset,\n\t\t\t\t\t\tclks[i].shift,\n\t\t\t\t\t\tclks[i].width,\n\t\t\t\t\t\tclks[i].mask_bit,\n\t\t\t\t\t\t&hisi_clk_lock);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (clks[i].alias)\n\t\t\tclk_register_clkdev(clk, clks[i].alias, NULL);\n\n\t\tdata->clk_data.clks[clks[i].id] = clk;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}