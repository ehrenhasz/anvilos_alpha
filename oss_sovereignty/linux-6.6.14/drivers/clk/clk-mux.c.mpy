{
  "module_name": "clk-mux.c",
  "hash_id": "5bd7e2d5f275fdec043e14441dc2a607344c9794f55faaa4367791b7c33c7b4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-mux.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n\n \n\nstatic inline u32 clk_mux_readl(struct clk_mux *mux)\n{\n\tif (mux->flags & CLK_MUX_BIG_ENDIAN)\n\t\treturn ioread32be(mux->reg);\n\n\treturn readl(mux->reg);\n}\n\nstatic inline void clk_mux_writel(struct clk_mux *mux, u32 val)\n{\n\tif (mux->flags & CLK_MUX_BIG_ENDIAN)\n\t\tiowrite32be(val, mux->reg);\n\telse\n\t\twritel(val, mux->reg);\n}\n\nint clk_mux_val_to_index(struct clk_hw *hw, const u32 *table, unsigned int flags,\n\t\t\t unsigned int val)\n{\n\tint num_parents = clk_hw_get_num_parents(hw);\n\n\tif (table) {\n\t\tint i;\n\n\t\tfor (i = 0; i < num_parents; i++)\n\t\t\tif (table[i] == val)\n\t\t\t\treturn i;\n\t\treturn -EINVAL;\n\t}\n\n\tif (val && (flags & CLK_MUX_INDEX_BIT))\n\t\tval = ffs(val) - 1;\n\n\tif (val && (flags & CLK_MUX_INDEX_ONE))\n\t\tval--;\n\n\tif (val >= num_parents)\n\t\treturn -EINVAL;\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(clk_mux_val_to_index);\n\nunsigned int clk_mux_index_to_val(const u32 *table, unsigned int flags, u8 index)\n{\n\tunsigned int val = index;\n\n\tif (table) {\n\t\tval = table[index];\n\t} else {\n\t\tif (flags & CLK_MUX_INDEX_BIT)\n\t\t\tval = 1 << index;\n\n\t\tif (flags & CLK_MUX_INDEX_ONE)\n\t\t\tval++;\n\t}\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(clk_mux_index_to_val);\n\nstatic u8 clk_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_mux *mux = to_clk_mux(hw);\n\tu32 val;\n\n\tval = clk_mux_readl(mux) >> mux->shift;\n\tval &= mux->mask;\n\n\treturn clk_mux_val_to_index(hw, mux->table, mux->flags, val);\n}\n\nstatic int clk_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_mux *mux = to_clk_mux(hw);\n\tu32 val = clk_mux_index_to_val(mux->table, mux->flags, index);\n\tunsigned long flags = 0;\n\tu32 reg;\n\n\tif (mux->lock)\n\t\tspin_lock_irqsave(mux->lock, flags);\n\telse\n\t\t__acquire(mux->lock);\n\n\tif (mux->flags & CLK_MUX_HIWORD_MASK) {\n\t\treg = mux->mask << (mux->shift + 16);\n\t} else {\n\t\treg = clk_mux_readl(mux);\n\t\treg &= ~(mux->mask << mux->shift);\n\t}\n\tval = val << mux->shift;\n\treg |= val;\n\tclk_mux_writel(mux, reg);\n\n\tif (mux->lock)\n\t\tspin_unlock_irqrestore(mux->lock, flags);\n\telse\n\t\t__release(mux->lock);\n\n\treturn 0;\n}\n\nstatic int clk_mux_determine_rate(struct clk_hw *hw,\n\t\t\t\t  struct clk_rate_request *req)\n{\n\tstruct clk_mux *mux = to_clk_mux(hw);\n\n\treturn clk_mux_determine_rate_flags(hw, req, mux->flags);\n}\n\nconst struct clk_ops clk_mux_ops = {\n\t.get_parent = clk_mux_get_parent,\n\t.set_parent = clk_mux_set_parent,\n\t.determine_rate = clk_mux_determine_rate,\n};\nEXPORT_SYMBOL_GPL(clk_mux_ops);\n\nconst struct clk_ops clk_mux_ro_ops = {\n\t.get_parent = clk_mux_get_parent,\n};\nEXPORT_SYMBOL_GPL(clk_mux_ro_ops);\n\nstruct clk_hw *__clk_hw_register_mux(struct device *dev, struct device_node *np,\n\t\tconst char *name, u8 num_parents,\n\t\tconst char * const *parent_names,\n\t\tconst struct clk_hw **parent_hws,\n\t\tconst struct clk_parent_data *parent_data,\n\t\tunsigned long flags, void __iomem *reg, u8 shift, u32 mask,\n\t\tu8 clk_mux_flags, const u32 *table, spinlock_t *lock)\n{\n\tstruct clk_mux *mux;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tint ret = -EINVAL;\n\n\tif (clk_mux_flags & CLK_MUX_HIWORD_MASK) {\n\t\tu8 width = fls(mask) - ffs(mask) + 1;\n\n\t\tif (width + shift > 16) {\n\t\t\tpr_err(\"mux value exceeds LOWORD field\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\t \n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tif (clk_mux_flags & CLK_MUX_READ_ONLY)\n\t\tinit.ops = &clk_mux_ro_ops;\n\telse\n\t\tinit.ops = &clk_mux_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_names;\n\tinit.parent_data = parent_data;\n\tinit.parent_hws = parent_hws;\n\tinit.num_parents = num_parents;\n\n\t \n\tmux->reg = reg;\n\tmux->shift = shift;\n\tmux->mask = mask;\n\tmux->flags = clk_mux_flags;\n\tmux->lock = lock;\n\tmux->table = table;\n\tmux->hw.init = &init;\n\n\thw = &mux->hw;\n\tif (dev || !np)\n\t\tret = clk_hw_register(dev, hw);\n\telse if (np)\n\t\tret = of_clk_hw_register(np, hw);\n\tif (ret) {\n\t\tkfree(mux);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(__clk_hw_register_mux);\n\nstatic void devm_clk_hw_release_mux(struct device *dev, void *res)\n{\n\tclk_hw_unregister_mux(*(struct clk_hw **)res);\n}\n\nstruct clk_hw *__devm_clk_hw_register_mux(struct device *dev, struct device_node *np,\n\t\tconst char *name, u8 num_parents,\n\t\tconst char * const *parent_names,\n\t\tconst struct clk_hw **parent_hws,\n\t\tconst struct clk_parent_data *parent_data,\n\t\tunsigned long flags, void __iomem *reg, u8 shift, u32 mask,\n\t\tu8 clk_mux_flags, const u32 *table, spinlock_t *lock)\n{\n\tstruct clk_hw **ptr, *hw;\n\n\tptr = devres_alloc(devm_clk_hw_release_mux, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thw = __clk_hw_register_mux(dev, np, name, num_parents, parent_names, parent_hws,\n\t\t\t\t       parent_data, flags, reg, shift, mask,\n\t\t\t\t       clk_mux_flags, table, lock);\n\n\tif (!IS_ERR(hw)) {\n\t\t*ptr = hw;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(__devm_clk_hw_register_mux);\n\nstruct clk *clk_register_mux_table(struct device *dev, const char *name,\n\t\tconst char * const *parent_names, u8 num_parents,\n\t\tunsigned long flags, void __iomem *reg, u8 shift, u32 mask,\n\t\tu8 clk_mux_flags, const u32 *table, spinlock_t *lock)\n{\n\tstruct clk_hw *hw;\n\n\thw = clk_hw_register_mux_table(dev, name, parent_names,\n\t\t\t\t       num_parents, flags, reg, shift, mask,\n\t\t\t\t       clk_mux_flags, table, lock);\n\tif (IS_ERR(hw))\n\t\treturn ERR_CAST(hw);\n\treturn hw->clk;\n}\nEXPORT_SYMBOL_GPL(clk_register_mux_table);\n\nvoid clk_unregister_mux(struct clk *clk)\n{\n\tstruct clk_mux *mux;\n\tstruct clk_hw *hw;\n\n\thw = __clk_get_hw(clk);\n\tif (!hw)\n\t\treturn;\n\n\tmux = to_clk_mux(hw);\n\n\tclk_unregister(clk);\n\tkfree(mux);\n}\nEXPORT_SYMBOL_GPL(clk_unregister_mux);\n\nvoid clk_hw_unregister_mux(struct clk_hw *hw)\n{\n\tstruct clk_mux *mux;\n\n\tmux = to_clk_mux(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(mux);\n}\nEXPORT_SYMBOL_GPL(clk_hw_unregister_mux);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}