{
  "module_name": "clk-gpio.c",
  "hash_id": "dc0a6ac2ccad85ceaf0816f659b407c17bebe6365ae3c43a03b7b9fbd7c86351",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/gpio/consumer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n \n\n \nstruct clk_gpio {\n\tstruct clk_hw\thw;\n\tstruct gpio_desc *gpiod;\n};\n\n#define to_clk_gpio(_hw) container_of(_hw, struct clk_gpio, hw)\n\nstatic int clk_gpio_gate_enable(struct clk_hw *hw)\n{\n\tstruct clk_gpio *clk = to_clk_gpio(hw);\n\n\tgpiod_set_value(clk->gpiod, 1);\n\n\treturn 0;\n}\n\nstatic void clk_gpio_gate_disable(struct clk_hw *hw)\n{\n\tstruct clk_gpio *clk = to_clk_gpio(hw);\n\n\tgpiod_set_value(clk->gpiod, 0);\n}\n\nstatic int clk_gpio_gate_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_gpio *clk = to_clk_gpio(hw);\n\n\treturn gpiod_get_value(clk->gpiod);\n}\n\nstatic const struct clk_ops clk_gpio_gate_ops = {\n\t.enable = clk_gpio_gate_enable,\n\t.disable = clk_gpio_gate_disable,\n\t.is_enabled = clk_gpio_gate_is_enabled,\n};\n\nstatic int clk_sleeping_gpio_gate_prepare(struct clk_hw *hw)\n{\n\tstruct clk_gpio *clk = to_clk_gpio(hw);\n\n\tgpiod_set_value_cansleep(clk->gpiod, 1);\n\n\treturn 0;\n}\n\nstatic void clk_sleeping_gpio_gate_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_gpio *clk = to_clk_gpio(hw);\n\n\tgpiod_set_value_cansleep(clk->gpiod, 0);\n}\n\nstatic int clk_sleeping_gpio_gate_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_gpio *clk = to_clk_gpio(hw);\n\n\treturn gpiod_get_value_cansleep(clk->gpiod);\n}\n\nstatic const struct clk_ops clk_sleeping_gpio_gate_ops = {\n\t.prepare = clk_sleeping_gpio_gate_prepare,\n\t.unprepare = clk_sleeping_gpio_gate_unprepare,\n\t.is_prepared = clk_sleeping_gpio_gate_is_prepared,\n};\n\n \n\nstatic u8 clk_gpio_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_gpio *clk = to_clk_gpio(hw);\n\n\treturn gpiod_get_value_cansleep(clk->gpiod);\n}\n\nstatic int clk_gpio_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_gpio *clk = to_clk_gpio(hw);\n\n\tgpiod_set_value_cansleep(clk->gpiod, index);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_gpio_mux_ops = {\n\t.get_parent = clk_gpio_mux_get_parent,\n\t.set_parent = clk_gpio_mux_set_parent,\n\t.determine_rate = __clk_mux_determine_rate,\n};\n\nstatic struct clk_hw *clk_register_gpio(struct device *dev, u8 num_parents,\n\t\t\t\t\tstruct gpio_desc *gpiod,\n\t\t\t\t\tconst struct clk_ops *clk_gpio_ops)\n{\n\tstruct clk_gpio *clk_gpio;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init = {};\n\tint err;\n\tconst struct clk_parent_data gpio_parent_data[] = {\n\t\t{ .index = 0 },\n\t\t{ .index = 1 },\n\t};\n\n\tclk_gpio = devm_kzalloc(dev, sizeof(*clk_gpio),\tGFP_KERNEL);\n\tif (!clk_gpio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = dev->of_node->name;\n\tinit.ops = clk_gpio_ops;\n\tinit.parent_data = gpio_parent_data;\n\tinit.num_parents = num_parents;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\n\tclk_gpio->gpiod = gpiod;\n\tclk_gpio->hw.init = &init;\n\n\thw = &clk_gpio->hw;\n\terr = devm_clk_hw_register(dev, hw);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn hw;\n}\n\nstatic struct clk_hw *clk_hw_register_gpio_gate(struct device *dev,\n\t\t\t\t\t\tint num_parents,\n\t\t\t\t\t\tstruct gpio_desc *gpiod)\n{\n\tconst struct clk_ops *ops;\n\n\tif (gpiod_cansleep(gpiod))\n\t\tops = &clk_sleeping_gpio_gate_ops;\n\telse\n\t\tops = &clk_gpio_gate_ops;\n\n\treturn clk_register_gpio(dev, num_parents, gpiod, ops);\n}\n\nstatic struct clk_hw *clk_hw_register_gpio_mux(struct device *dev,\n\t\t\t\t\t       struct gpio_desc *gpiod)\n{\n\treturn clk_register_gpio(dev, 2, gpiod, &clk_gpio_mux_ops);\n}\n\nstatic int gpio_clk_driver_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tconst char *gpio_name;\n\tunsigned int num_parents;\n\tstruct gpio_desc *gpiod;\n\tstruct clk_hw *hw;\n\tbool is_mux;\n\tint ret;\n\n\tis_mux = of_device_is_compatible(node, \"gpio-mux-clock\");\n\n\tnum_parents = of_clk_get_parent_count(node);\n\tif (is_mux && num_parents != 2) {\n\t\tdev_err(dev, \"mux-clock must have 2 parents\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_name = is_mux ? \"select\" : \"enable\";\n\tgpiod = devm_gpiod_get(dev, gpio_name, GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiod)) {\n\t\tret = PTR_ERR(gpiod);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tpr_debug(\"%pOFn: %s: GPIOs not yet available, retry later\\n\",\n\t\t\t\t\tnode, __func__);\n\t\telse\n\t\t\tpr_err(\"%pOFn: %s: Can't get '%s' named GPIO property\\n\",\n\t\t\t\t\tnode, __func__,\n\t\t\t\t\tgpio_name);\n\t\treturn ret;\n\t}\n\n\tif (is_mux)\n\t\thw = clk_hw_register_gpio_mux(dev, gpiod);\n\telse\n\t\thw = clk_hw_register_gpio_gate(dev, num_parents, gpiod);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get, hw);\n}\n\nstatic const struct of_device_id gpio_clk_match_table[] = {\n\t{ .compatible = \"gpio-mux-clock\" },\n\t{ .compatible = \"gpio-gate-clock\" },\n\t{ }\n};\n\nstatic struct platform_driver gpio_clk_driver = {\n\t.probe\t\t= gpio_clk_driver_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"gpio-clk\",\n\t\t.of_match_table = gpio_clk_match_table,\n\t},\n};\nbuiltin_platform_driver(gpio_clk_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}