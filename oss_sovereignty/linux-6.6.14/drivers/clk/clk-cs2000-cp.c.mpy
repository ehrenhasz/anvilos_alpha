{
  "module_name": "clk-cs2000-cp.c",
  "hash_id": "d005f39e40967b89f188e8ebcecc5b3d5ab6f9ddc71165a6133ab4d73d4f08f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-cs2000-cp.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/i2c.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n#define CH_MAX 4\n#define RATIO_REG_SIZE 4\n\n#define DEVICE_ID\t0x1\n#define DEVICE_CTRL\t0x2\n#define DEVICE_CFG1\t0x3\n#define DEVICE_CFG2\t0x4\n#define GLOBAL_CFG\t0x5\n#define Ratio_Add(x, nth)\t(6 + (x * 4) + (nth))\n#define Ratio_Val(x, nth)\t((x >> (24 - (8 * nth))) & 0xFF)\n#define Val_Ratio(x, nth)\t((x & 0xFF) << (24 - (8 * nth)))\n#define FUNC_CFG1\t0x16\n#define FUNC_CFG2\t0x17\n\n \n#define REVISION_MASK\t(0x7)\n#define REVISION_B2_B3\t(0x4)\n#define REVISION_C1\t(0x6)\n\n \n#define PLL_UNLOCK\t(1 << 7)\n#define AUXOUTDIS\t(1 << 1)\n#define CLKOUTDIS\t(1 << 0)\n\n \n#define RSEL(x)\t\t(((x) & 0x3) << 3)\n#define RSEL_MASK\tRSEL(0x3)\n#define AUXOUTSRC(x)\t(((x) & 0x3) << 1)\n#define AUXOUTSRC_MASK\tAUXOUTSRC(0x3)\n#define ENDEV1\t\t(0x1)\n\n \n#define AUTORMOD\t(1 << 3)\n#define LOCKCLK(x)\t(((x) & 0x3) << 1)\n#define LOCKCLK_MASK\tLOCKCLK(0x3)\n#define FRACNSRC_MASK\t(1 << 0)\n#define FRACNSRC_STATIC\t\t(0 << 0)\n#define FRACNSRC_DYNAMIC\t(1 << 0)\n\n \n#define FREEZE\t\t(1 << 7)\n#define ENDEV2\t\t(0x1)\n\n \n#define CLKSKIPEN\t(1 << 7)\n#define REFCLKDIV(x)\t(((x) & 0x3) << 3)\n#define REFCLKDIV_MASK\tREFCLKDIV(0x3)\n\n \n#define LFRATIO_MASK\t(1 << 3)\n#define LFRATIO_20_12\t(0 << 3)\n#define LFRATIO_12_20\t(1 << 3)\n\n#define CH_SIZE_ERR(ch)\t\t((ch < 0) || (ch >= CH_MAX))\n#define hw_to_priv(_hw)\t\tcontainer_of(_hw, struct cs2000_priv, hw)\n#define priv_to_client(priv)\t(priv->client)\n#define priv_to_dev(priv)\t(&(priv_to_client(priv)->dev))\n\n#define CLK_IN\t0\n#define REF_CLK\t1\n#define CLK_MAX 2\n\nstatic bool cs2000_readable_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg > 0;\n}\n\nstatic bool cs2000_writeable_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg != DEVICE_ID;\n}\n\nstatic bool cs2000_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg == DEVICE_CTRL;\n}\n\nstatic const struct regmap_config cs2000_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= FUNC_CFG2,\n\t.readable_reg\t= cs2000_readable_reg,\n\t.writeable_reg\t= cs2000_writeable_reg,\n\t.volatile_reg\t= cs2000_volatile_reg,\n};\n\nstruct cs2000_priv {\n\tstruct clk_hw hw;\n\tstruct i2c_client *client;\n\tstruct clk *clk_in;\n\tstruct clk *ref_clk;\n\tstruct regmap *regmap;\n\n\tbool dynamic_mode;\n\tbool lf_ratio;\n\tbool clk_skip;\n\n\t \n\tunsigned long saved_rate;\n\tunsigned long saved_parent_rate;\n};\n\nstatic const struct of_device_id cs2000_of_match[] = {\n\t{ .compatible = \"cirrus,cs2000-cp\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cs2000_of_match);\n\nstatic const struct i2c_device_id cs2000_id[] = {\n\t{ \"cs2000-cp\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, cs2000_id);\n\nstatic int cs2000_enable_dev_config(struct cs2000_priv *priv, bool enable)\n{\n\tint ret;\n\n\tret = regmap_update_bits(priv->regmap, DEVICE_CFG1, ENDEV1,\n\t\t\t\t enable ? ENDEV1 : 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(priv->regmap, GLOBAL_CFG,  ENDEV2,\n\t\t\t\t enable ? ENDEV2 : 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(priv->regmap, FUNC_CFG1, CLKSKIPEN,\n\t\t\t\t (enable && priv->clk_skip) ? CLKSKIPEN : 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int cs2000_ref_clk_bound_rate(struct cs2000_priv *priv,\n\t\t\t\t     u32 rate_in)\n{\n\tu32 val;\n\n\tif (rate_in >= 32000000 && rate_in < 56000000)\n\t\tval = 0x0;\n\telse if (rate_in >= 16000000 && rate_in < 28000000)\n\t\tval = 0x1;\n\telse if (rate_in >= 8000000 && rate_in < 14000000)\n\t\tval = 0x2;\n\telse\n\t\treturn -EINVAL;\n\n\treturn regmap_update_bits(priv->regmap, FUNC_CFG1,\n\t\t\t\t  REFCLKDIV_MASK,\n\t\t\t\t  REFCLKDIV(val));\n}\n\nstatic int cs2000_wait_pll_lock(struct cs2000_priv *priv)\n{\n\tstruct device *dev = priv_to_dev(priv);\n\tunsigned int i, val;\n\tint ret;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tret = regmap_read(priv->regmap, DEVICE_CTRL, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!(val & PLL_UNLOCK))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\tdev_err(dev, \"pll lock failed\\n\");\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int cs2000_clk_out_enable(struct cs2000_priv *priv, bool enable)\n{\n\t \n\treturn regmap_update_bits(priv->regmap, DEVICE_CTRL,\n\t\t\t\t  (AUXOUTDIS | CLKOUTDIS),\n\t\t\t\t  enable ? 0 :\n\t\t\t\t  (AUXOUTDIS | CLKOUTDIS));\n}\n\nstatic u32 cs2000_rate_to_ratio(u32 rate_in, u32 rate_out, bool lf_ratio)\n{\n\tu64 ratio;\n\tu32 multiplier = lf_ratio ? 12 : 20;\n\n\t \n\tratio = (u64)rate_out << multiplier;\n\tdo_div(ratio, rate_in);\n\n\treturn ratio;\n}\n\nstatic unsigned long cs2000_ratio_to_rate(u32 ratio, u32 rate_in, bool lf_ratio)\n{\n\tu64 rate_out;\n\tu32 multiplier = lf_ratio ? 12 : 20;\n\n\t \n\n\trate_out = (u64)ratio * rate_in;\n\treturn rate_out >> multiplier;\n}\n\nstatic int cs2000_ratio_set(struct cs2000_priv *priv,\n\t\t\t    int ch, u32 rate_in, u32 rate_out)\n{\n\tu32 val;\n\tunsigned int i;\n\tint ret;\n\n\tif (CH_SIZE_ERR(ch))\n\t\treturn -EINVAL;\n\n\tval = cs2000_rate_to_ratio(rate_in, rate_out, priv->lf_ratio);\n\tfor (i = 0; i < RATIO_REG_SIZE; i++) {\n\t\tret = regmap_write(priv->regmap,\n\t\t\t\t   Ratio_Add(ch, i),\n\t\t\t\t   Ratio_Val(val, i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 cs2000_ratio_get(struct cs2000_priv *priv, int ch)\n{\n\tunsigned int tmp, i;\n\tu32 val;\n\tint ret;\n\n\tval = 0;\n\tfor (i = 0; i < RATIO_REG_SIZE; i++) {\n\t\tret = regmap_read(priv->regmap, Ratio_Add(ch, i), &tmp);\n\t\tif (ret < 0)\n\t\t\treturn 0;\n\n\t\tval |= Val_Ratio(tmp, i);\n\t}\n\n\treturn val;\n}\n\nstatic int cs2000_ratio_select(struct cs2000_priv *priv, int ch)\n{\n\tint ret;\n\tu8 fracnsrc;\n\n\tif (CH_SIZE_ERR(ch))\n\t\treturn -EINVAL;\n\n\tret = regmap_update_bits(priv->regmap, DEVICE_CFG1, RSEL_MASK, RSEL(ch));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfracnsrc = priv->dynamic_mode ? FRACNSRC_DYNAMIC : FRACNSRC_STATIC;\n\n\tret = regmap_update_bits(priv->regmap, DEVICE_CFG2,\n\t\t\t\t AUTORMOD | LOCKCLK_MASK | FRACNSRC_MASK,\n\t\t\t\t LOCKCLK(ch) | fracnsrc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic unsigned long cs2000_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct cs2000_priv *priv = hw_to_priv(hw);\n\tint ch = 0;  \n\tu32 ratio;\n\n\tratio = cs2000_ratio_get(priv, ch);\n\n\treturn cs2000_ratio_to_rate(ratio, parent_rate, priv->lf_ratio);\n}\n\nstatic long cs2000_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long *parent_rate)\n{\n\tstruct cs2000_priv *priv = hw_to_priv(hw);\n\tu32 ratio;\n\n\tratio = cs2000_rate_to_ratio(*parent_rate, rate, priv->lf_ratio);\n\n\treturn cs2000_ratio_to_rate(ratio, *parent_rate, priv->lf_ratio);\n}\n\nstatic int cs2000_select_ratio_mode(struct cs2000_priv *priv,\n\t\t\t\t    unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\t \n\tpriv->lf_ratio = priv->dynamic_mode && ((rate / parent_rate) > 4096);\n\n\treturn regmap_update_bits(priv->regmap, FUNC_CFG2, LFRATIO_MASK,\n\t\t\t\t  priv->lf_ratio ? LFRATIO_20_12 : LFRATIO_12_20);\n}\n\nstatic int __cs2000_set_rate(struct cs2000_priv *priv, int ch,\n\t\t\t     unsigned long rate, unsigned long parent_rate)\n\n{\n\tint ret;\n\n\tret = regmap_update_bits(priv->regmap, GLOBAL_CFG, FREEZE, FREEZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = cs2000_select_ratio_mode(priv, rate, parent_rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = cs2000_ratio_set(priv, ch, parent_rate, rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = cs2000_ratio_select(priv, ch);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(priv->regmap, GLOBAL_CFG, FREEZE, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->saved_rate\t= rate;\n\tpriv->saved_parent_rate\t= parent_rate;\n\n\treturn 0;\n}\n\nstatic int cs2000_set_rate(struct clk_hw *hw,\n\t\t\t   unsigned long rate, unsigned long parent_rate)\n{\n\tstruct cs2000_priv *priv = hw_to_priv(hw);\n\tint ch = 0;  \n\n\treturn __cs2000_set_rate(priv, ch, rate, parent_rate);\n}\n\nstatic int cs2000_set_saved_rate(struct cs2000_priv *priv)\n{\n\tint ch = 0;  \n\n\treturn __cs2000_set_rate(priv, ch,\n\t\t\t\t priv->saved_rate,\n\t\t\t\t priv->saved_parent_rate);\n}\n\nstatic int cs2000_enable(struct clk_hw *hw)\n{\n\tstruct cs2000_priv *priv = hw_to_priv(hw);\n\tint ret;\n\n\tret = cs2000_enable_dev_config(priv, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = cs2000_clk_out_enable(priv, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = cs2000_wait_pll_lock(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic void cs2000_disable(struct clk_hw *hw)\n{\n\tstruct cs2000_priv *priv = hw_to_priv(hw);\n\n\tcs2000_enable_dev_config(priv, false);\n\n\tcs2000_clk_out_enable(priv, false);\n}\n\nstatic u8 cs2000_get_parent(struct clk_hw *hw)\n{\n\tstruct cs2000_priv *priv = hw_to_priv(hw);\n\n\t \n\treturn priv->dynamic_mode ? CLK_IN : REF_CLK;\n}\n\nstatic const struct clk_ops cs2000_ops = {\n\t.get_parent\t= cs2000_get_parent,\n\t.recalc_rate\t= cs2000_recalc_rate,\n\t.round_rate\t= cs2000_round_rate,\n\t.set_rate\t= cs2000_set_rate,\n\t.prepare\t= cs2000_enable,\n\t.unprepare\t= cs2000_disable,\n};\n\nstatic int cs2000_clk_get(struct cs2000_priv *priv)\n{\n\tstruct device *dev = priv_to_dev(priv);\n\tstruct clk *clk_in, *ref_clk;\n\n\tclk_in = devm_clk_get(dev, \"clk_in\");\n\t \n\tif (IS_ERR(clk_in))\n\t\treturn -EPROBE_DEFER;\n\n\tref_clk = devm_clk_get(dev, \"ref_clk\");\n\t \n\tif (IS_ERR(ref_clk))\n\t\treturn -EPROBE_DEFER;\n\n\tpriv->clk_in\t= clk_in;\n\tpriv->ref_clk\t= ref_clk;\n\n\treturn 0;\n}\n\nstatic int cs2000_clk_register(struct cs2000_priv *priv)\n{\n\tstruct device *dev = priv_to_dev(priv);\n\tstruct device_node *np = dev->of_node;\n\tstruct clk_init_data init;\n\tconst char *name = np->name;\n\tstatic const char *parent_names[CLK_MAX];\n\tu32 aux_out = 0;\n\tint ref_clk_rate;\n\tint ch = 0;  \n\tint ret;\n\n\tof_property_read_string(np, \"clock-output-names\", &name);\n\n\tpriv->dynamic_mode = of_property_read_bool(np, \"cirrus,dynamic-mode\");\n\tdev_info(dev, \"operating in %s mode\\n\",\n\t\t priv->dynamic_mode ? \"dynamic\" : \"static\");\n\n\tof_property_read_u32(np, \"cirrus,aux-output-source\", &aux_out);\n\tret = regmap_update_bits(priv->regmap, DEVICE_CFG1,\n\t\t\t\t AUXOUTSRC_MASK, AUXOUTSRC(aux_out));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->clk_skip = of_property_read_bool(np, \"cirrus,clock-skip\");\n\n\tref_clk_rate = clk_get_rate(priv->ref_clk);\n\tret = cs2000_ref_clk_bound_rate(priv, ref_clk_rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (priv->dynamic_mode) {\n\t\t \n\t\tpriv->lf_ratio = true;\n\t} else {\n\t\t \n\t\tret = __cs2000_set_rate(priv, ch, ref_clk_rate, ref_clk_rate);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tparent_names[CLK_IN]\t= __clk_get_name(priv->clk_in);\n\tparent_names[REF_CLK]\t= __clk_get_name(priv->ref_clk);\n\n\tinit.name\t\t= name;\n\tinit.ops\t\t= &cs2000_ops;\n\tinit.flags\t\t= CLK_SET_RATE_GATE;\n\tinit.parent_names\t= parent_names;\n\tinit.num_parents\t= ARRAY_SIZE(parent_names);\n\n\tpriv->hw.init = &init;\n\n\tret = clk_hw_register(dev, &priv->hw);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_clk_add_hw_provider(np, of_clk_hw_simple_get, &priv->hw);\n\tif (ret < 0) {\n\t\tclk_hw_unregister(&priv->hw);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs2000_version_print(struct cs2000_priv *priv)\n{\n\tstruct device *dev = priv_to_dev(priv);\n\tconst char *revision;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, DEVICE_ID, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (val >> 3)\n\t\treturn -EIO;\n\n\tswitch (val & REVISION_MASK) {\n\tcase REVISION_B2_B3:\n\t\trevision = \"B2 / B3\";\n\t\tbreak;\n\tcase REVISION_C1:\n\t\trevision = \"C1\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\tdev_info(dev, \"revision - %s\\n\", revision);\n\n\treturn 0;\n}\n\nstatic void cs2000_remove(struct i2c_client *client)\n{\n\tstruct cs2000_priv *priv = i2c_get_clientdata(client);\n\tstruct device *dev = priv_to_dev(priv);\n\tstruct device_node *np = dev->of_node;\n\n\tof_clk_del_provider(np);\n\n\tclk_hw_unregister(&priv->hw);\n}\n\nstatic int cs2000_probe(struct i2c_client *client)\n{\n\tstruct cs2000_priv *priv;\n\tstruct device *dev = &client->dev;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->client = client;\n\ti2c_set_clientdata(client, priv);\n\n\tpriv->regmap = devm_regmap_init_i2c(client, &cs2000_regmap_config);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tret = cs2000_clk_get(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = cs2000_clk_register(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = cs2000_version_print(priv);\n\tif (ret < 0)\n\t\tgoto probe_err;\n\n\treturn 0;\n\nprobe_err:\n\tcs2000_remove(client);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused cs2000_resume(struct device *dev)\n{\n\tstruct cs2000_priv *priv = dev_get_drvdata(dev);\n\n\treturn cs2000_set_saved_rate(priv);\n}\n\nstatic const struct dev_pm_ops cs2000_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(NULL, cs2000_resume)\n};\n\nstatic struct i2c_driver cs2000_driver = {\n\t.driver = {\n\t\t.name = \"cs2000-cp\",\n\t\t.pm\t= &cs2000_pm_ops,\n\t\t.of_match_table = cs2000_of_match,\n\t},\n\t.probe\t\t= cs2000_probe,\n\t.remove\t\t= cs2000_remove,\n\t.id_table\t= cs2000_id,\n};\n\nmodule_i2c_driver(cs2000_driver);\n\nMODULE_DESCRIPTION(\"CS2000-CP driver\");\nMODULE_AUTHOR(\"Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}