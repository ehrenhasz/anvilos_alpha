{
  "module_name": "clkc.c",
  "hash_id": "150af7f92d1294a68a5ad0c011547185267afa41a50b08d87abccdc4c0966354",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/zynqmp/clkc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include \"clk-zynqmp.h\"\n\n#define MAX_PARENT\t\t\t100\n#define MAX_NODES\t\t\t6\n#define MAX_NAME_LEN\t\t\t50\n\n \n#define PARENT_CLK_SELF\t\t\t0\n#define PARENT_CLK_NODE1\t\t1\n#define PARENT_CLK_NODE2\t\t2\n#define PARENT_CLK_NODE3\t\t3\n#define PARENT_CLK_NODE4\t\t4\n#define PARENT_CLK_EXTERNAL\t\t5\n\n#define END_OF_CLK_NAME\t\t\t\"END_OF_CLK\"\n#define END_OF_TOPOLOGY_NODE\t\t1\n#define END_OF_PARENTS\t\t\t1\n#define RESERVED_CLK_NAME\t\t\"\"\n\n#define CLK_GET_NAME_RESP_LEN\t\t16\n#define CLK_GET_TOPOLOGY_RESP_WORDS\t3\n#define CLK_GET_PARENTS_RESP_WORDS\t3\n#define CLK_GET_ATTR_RESP_WORDS\t\t1\n\nenum clk_type {\n\tCLK_TYPE_OUTPUT,\n\tCLK_TYPE_EXTERNAL,\n};\n\n \nstruct clock_parent {\n\tchar name[MAX_NAME_LEN];\n\tint id;\n\tu32 flag;\n};\n\n \nstruct zynqmp_clock {\n\tchar clk_name[MAX_NAME_LEN];\n\tu32 valid;\n\tenum clk_type type;\n\tstruct clock_topology node[MAX_NODES];\n\tu32 num_nodes;\n\tstruct clock_parent parent[MAX_PARENT];\n\tu32 num_parents;\n\tu32 clk_id;\n};\n\nstruct name_resp {\n\tchar name[CLK_GET_NAME_RESP_LEN];\n};\n\nstruct topology_resp {\n#define CLK_TOPOLOGY_TYPE\t\tGENMASK(3, 0)\n#define CLK_TOPOLOGY_CUSTOM_TYPE_FLAGS\tGENMASK(7, 4)\n#define CLK_TOPOLOGY_FLAGS\t\tGENMASK(23, 8)\n#define CLK_TOPOLOGY_TYPE_FLAGS\t\tGENMASK(31, 24)\n\tu32 topology[CLK_GET_TOPOLOGY_RESP_WORDS];\n};\n\nstruct parents_resp {\n#define NA_PARENT\t\t\t0xFFFFFFFF\n#define DUMMY_PARENT\t\t\t0xFFFFFFFE\n#define CLK_PARENTS_ID\t\t\tGENMASK(15, 0)\n#define CLK_PARENTS_FLAGS\t\tGENMASK(31, 16)\n\tu32 parents[CLK_GET_PARENTS_RESP_WORDS];\n};\n\nstruct attr_resp {\n#define CLK_ATTR_VALID\t\t\tBIT(0)\n#define CLK_ATTR_TYPE\t\t\tBIT(2)\n#define CLK_ATTR_NODE_INDEX\t\tGENMASK(13, 0)\n#define CLK_ATTR_NODE_TYPE\t\tGENMASK(19, 14)\n#define CLK_ATTR_NODE_SUBCLASS\t\tGENMASK(25, 20)\n#define CLK_ATTR_NODE_CLASS\t\tGENMASK(31, 26)\n\tu32 attr[CLK_GET_ATTR_RESP_WORDS];\n};\n\nstatic const char clk_type_postfix[][10] = {\n\t[TYPE_INVALID] = \"\",\n\t[TYPE_MUX] = \"_mux\",\n\t[TYPE_GATE] = \"\",\n\t[TYPE_DIV1] = \"_div1\",\n\t[TYPE_DIV2] = \"_div2\",\n\t[TYPE_FIXEDFACTOR] = \"_ff\",\n\t[TYPE_PLL] = \"\"\n};\n\nstatic struct clk_hw *(* const clk_topology[]) (const char *name, u32 clk_id,\n\t\t\t\t\tconst char * const *parents,\n\t\t\t\t\tu8 num_parents,\n\t\t\t\t\tconst struct clock_topology *nodes)\n\t\t\t\t\t= {\n\t[TYPE_INVALID] = NULL,\n\t[TYPE_MUX] = zynqmp_clk_register_mux,\n\t[TYPE_PLL] = zynqmp_clk_register_pll,\n\t[TYPE_FIXEDFACTOR] = zynqmp_clk_register_fixed_factor,\n\t[TYPE_DIV1] = zynqmp_clk_register_divider,\n\t[TYPE_DIV2] = zynqmp_clk_register_divider,\n\t[TYPE_GATE] = zynqmp_clk_register_gate\n};\n\nstatic struct zynqmp_clock *clock;\nstatic struct clk_hw_onecell_data *zynqmp_data;\nstatic unsigned int clock_max_idx;\n\n \nstatic inline int zynqmp_is_valid_clock(u32 clk_id)\n{\n\tif (clk_id >= clock_max_idx)\n\t\treturn -ENODEV;\n\n\treturn clock[clk_id].valid;\n}\n\n \nstatic int zynqmp_get_clock_name(u32 clk_id, char *clk_name)\n{\n\tint ret;\n\n\tret = zynqmp_is_valid_clock(clk_id);\n\tif (ret == 1) {\n\t\tstrscpy(clk_name, clock[clk_id].clk_name, MAX_NAME_LEN);\n\t\treturn 0;\n\t}\n\n\treturn ret == 0 ? -EINVAL : ret;\n}\n\n \nstatic int zynqmp_get_clock_type(u32 clk_id, u32 *type)\n{\n\tint ret;\n\n\tret = zynqmp_is_valid_clock(clk_id);\n\tif (ret == 1) {\n\t\t*type = clock[clk_id].type;\n\t\treturn 0;\n\t}\n\n\treturn ret == 0 ? -EINVAL : ret;\n}\n\n \nstatic int zynqmp_pm_clock_get_num_clocks(u32 *nclocks)\n{\n\tstruct zynqmp_pm_query_data qdata = {0};\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tqdata.qid = PM_QID_CLOCK_GET_NUM_CLOCKS;\n\n\tret = zynqmp_pm_query_data(qdata, ret_payload);\n\t*nclocks = ret_payload[1];\n\n\treturn ret;\n}\n\n \nstatic int zynqmp_pm_clock_get_name(u32 clock_id,\n\t\t\t\t    struct name_resp *response)\n{\n\tstruct zynqmp_pm_query_data qdata = {0};\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tqdata.qid = PM_QID_CLOCK_GET_NAME;\n\tqdata.arg1 = clock_id;\n\n\tret = zynqmp_pm_query_data(qdata, ret_payload);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(response, ret_payload, sizeof(*response));\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_pm_clock_get_topology(u32 clock_id, u32 index,\n\t\t\t\t\tstruct topology_resp *response)\n{\n\tstruct zynqmp_pm_query_data qdata = {0};\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tqdata.qid = PM_QID_CLOCK_GET_TOPOLOGY;\n\tqdata.arg1 = clock_id;\n\tqdata.arg2 = index;\n\n\tret = zynqmp_pm_query_data(qdata, ret_payload);\n\tmemcpy(response, &ret_payload[1], sizeof(*response));\n\n\treturn ret;\n}\n\nunsigned long zynqmp_clk_map_common_ccf_flags(const u32 zynqmp_flag)\n{\n\tunsigned long ccf_flag = 0;\n\n\tif (zynqmp_flag & ZYNQMP_CLK_SET_RATE_GATE)\n\t\tccf_flag |= CLK_SET_RATE_GATE;\n\tif (zynqmp_flag & ZYNQMP_CLK_SET_PARENT_GATE)\n\t\tccf_flag |= CLK_SET_PARENT_GATE;\n\tif (zynqmp_flag & ZYNQMP_CLK_SET_RATE_PARENT)\n\t\tccf_flag |= CLK_SET_RATE_PARENT;\n\tif (zynqmp_flag & ZYNQMP_CLK_IGNORE_UNUSED)\n\t\tccf_flag |= CLK_IGNORE_UNUSED;\n\tif (zynqmp_flag & ZYNQMP_CLK_SET_RATE_NO_REPARENT)\n\t\tccf_flag |= CLK_SET_RATE_NO_REPARENT;\n\tif (zynqmp_flag & ZYNQMP_CLK_IS_CRITICAL)\n\t\tccf_flag |= CLK_IS_CRITICAL;\n\n\treturn ccf_flag;\n}\n\n \nstruct clk_hw *zynqmp_clk_register_fixed_factor(const char *name, u32 clk_id,\n\t\t\t\t\tconst char * const *parents,\n\t\t\t\t\tu8 num_parents,\n\t\t\t\t\tconst struct clock_topology *nodes)\n{\n\tu32 mult, div;\n\tstruct clk_hw *hw;\n\tstruct zynqmp_pm_query_data qdata = {0};\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\tunsigned long flag;\n\n\tqdata.qid = PM_QID_CLOCK_GET_FIXEDFACTOR_PARAMS;\n\tqdata.arg1 = clk_id;\n\n\tret = zynqmp_pm_query_data(qdata, ret_payload);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tmult = ret_payload[1];\n\tdiv = ret_payload[2];\n\n\tflag = zynqmp_clk_map_common_ccf_flags(nodes->flag);\n\n\thw = clk_hw_register_fixed_factor(NULL, name,\n\t\t\t\t\t  parents[0],\n\t\t\t\t\t  flag, mult,\n\t\t\t\t\t  div);\n\n\treturn hw;\n}\n\n \nstatic int zynqmp_pm_clock_get_parents(u32 clock_id, u32 index,\n\t\t\t\t       struct parents_resp *response)\n{\n\tstruct zynqmp_pm_query_data qdata = {0};\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tqdata.qid = PM_QID_CLOCK_GET_PARENTS;\n\tqdata.arg1 = clock_id;\n\tqdata.arg2 = index;\n\n\tret = zynqmp_pm_query_data(qdata, ret_payload);\n\tmemcpy(response, &ret_payload[1], sizeof(*response));\n\n\treturn ret;\n}\n\n \nstatic int zynqmp_pm_clock_get_attributes(u32 clock_id,\n\t\t\t\t\t  struct attr_resp *response)\n{\n\tstruct zynqmp_pm_query_data qdata = {0};\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tqdata.qid = PM_QID_CLOCK_GET_ATTRIBUTES;\n\tqdata.arg1 = clock_id;\n\n\tret = zynqmp_pm_query_data(qdata, ret_payload);\n\tmemcpy(response, &ret_payload[1], sizeof(*response));\n\n\treturn ret;\n}\n\n \nstatic int __zynqmp_clock_get_topology(struct clock_topology *topology,\n\t\t\t\t       struct topology_resp *response,\n\t\t\t\t       u32 *nnodes)\n{\n\tint i;\n\tu32 type;\n\n\tfor (i = 0; i < ARRAY_SIZE(response->topology); i++) {\n\t\ttype = FIELD_GET(CLK_TOPOLOGY_TYPE, response->topology[i]);\n\t\tif (type == TYPE_INVALID)\n\t\t\treturn END_OF_TOPOLOGY_NODE;\n\t\ttopology[*nnodes].type = type;\n\t\ttopology[*nnodes].flag = FIELD_GET(CLK_TOPOLOGY_FLAGS,\n\t\t\t\t\t\t   response->topology[i]);\n\t\ttopology[*nnodes].type_flag =\n\t\t\t\tFIELD_GET(CLK_TOPOLOGY_TYPE_FLAGS,\n\t\t\t\t\t  response->topology[i]);\n\t\ttopology[*nnodes].custom_type_flag =\n\t\t\tFIELD_GET(CLK_TOPOLOGY_CUSTOM_TYPE_FLAGS,\n\t\t\t\t  response->topology[i]);\n\t\t(*nnodes)++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_clock_get_topology(u32 clk_id,\n\t\t\t\t     struct clock_topology *topology,\n\t\t\t\t     u32 *num_nodes)\n{\n\tint j, ret;\n\tstruct topology_resp response = { };\n\n\t*num_nodes = 0;\n\tfor (j = 0; j <= MAX_NODES; j += ARRAY_SIZE(response.topology)) {\n\t\tret = zynqmp_pm_clock_get_topology(clock[clk_id].clk_id, j,\n\t\t\t\t\t\t   &response);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = __zynqmp_clock_get_topology(topology, &response,\n\t\t\t\t\t\t  num_nodes);\n\t\tif (ret == END_OF_TOPOLOGY_NODE)\n\t\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __zynqmp_clock_get_parents(struct clock_parent *parents,\n\t\t\t\t      struct parents_resp *response,\n\t\t\t\t      u32 *nparent)\n{\n\tint i;\n\tstruct clock_parent *parent;\n\n\tfor (i = 0; i < ARRAY_SIZE(response->parents); i++) {\n\t\tif (response->parents[i] == NA_PARENT)\n\t\t\treturn END_OF_PARENTS;\n\n\t\tparent = &parents[i];\n\t\tparent->id = FIELD_GET(CLK_PARENTS_ID, response->parents[i]);\n\t\tif (response->parents[i] == DUMMY_PARENT) {\n\t\t\tstrcpy(parent->name, \"dummy_name\");\n\t\t\tparent->flag = 0;\n\t\t} else {\n\t\t\tparent->flag = FIELD_GET(CLK_PARENTS_FLAGS,\n\t\t\t\t\t\t response->parents[i]);\n\t\t\tif (zynqmp_get_clock_name(parent->id, parent->name))\n\t\t\t\tcontinue;\n\t\t}\n\t\t*nparent += 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_clock_get_parents(u32 clk_id, struct clock_parent *parents,\n\t\t\t\t    u32 *num_parents)\n{\n\tint j = 0, ret;\n\tstruct parents_resp response = { };\n\n\t*num_parents = 0;\n\tdo {\n\t\t \n\t\tret = zynqmp_pm_clock_get_parents(clock[clk_id].clk_id, j,\n\t\t\t\t\t\t  &response);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = __zynqmp_clock_get_parents(&parents[j], &response,\n\t\t\t\t\t\t num_parents);\n\t\tif (ret == END_OF_PARENTS)\n\t\t\treturn 0;\n\t\tj += ARRAY_SIZE(response.parents);\n\t} while (*num_parents <= MAX_PARENT);\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_get_parent_list(struct device_node *np, u32 clk_id,\n\t\t\t\t  const char **parent_list, u32 *num_parents)\n{\n\tint i = 0, ret;\n\tu32 total_parents = clock[clk_id].num_parents;\n\tstruct clock_topology *clk_nodes;\n\tstruct clock_parent *parents;\n\n\tclk_nodes = clock[clk_id].node;\n\tparents = clock[clk_id].parent;\n\n\tfor (i = 0; i < total_parents; i++) {\n\t\tif (!parents[i].flag) {\n\t\t\tparent_list[i] = parents[i].name;\n\t\t} else if (parents[i].flag == PARENT_CLK_EXTERNAL) {\n\t\t\tret = of_property_match_string(np, \"clock-names\",\n\t\t\t\t\t\t       parents[i].name);\n\t\t\tif (ret < 0)\n\t\t\t\tstrcpy(parents[i].name, \"dummy_name\");\n\t\t\tparent_list[i] = parents[i].name;\n\t\t} else {\n\t\t\tstrcat(parents[i].name,\n\t\t\t       clk_type_postfix[clk_nodes[parents[i].flag - 1].\n\t\t\t       type]);\n\t\t\tparent_list[i] = parents[i].name;\n\t\t}\n\t}\n\n\t*num_parents = total_parents;\n\treturn 0;\n}\n\n \nstatic struct clk_hw *zynqmp_register_clk_topology(int clk_id, char *clk_name,\n\t\t\t\t\t\t   int num_parents,\n\t\t\t\t\t\t   const char **parent_names)\n{\n\tint j;\n\tu32 num_nodes, clk_dev_id;\n\tchar *clk_out[MAX_NODES];\n\tstruct clock_topology *nodes;\n\tstruct clk_hw *hw = NULL;\n\n\tnodes = clock[clk_id].node;\n\tnum_nodes = clock[clk_id].num_nodes;\n\tclk_dev_id = clock[clk_id].clk_id;\n\n\tfor (j = 0; j < num_nodes; j++) {\n\t\t \n\t\tif (j != (num_nodes - 1)) {\n\t\t\tclk_out[j] = kasprintf(GFP_KERNEL, \"%s%s\", clk_name,\n\t\t\t\t\t    clk_type_postfix[nodes[j].type]);\n\t\t} else {\n\t\t\tclk_out[j] = kasprintf(GFP_KERNEL, \"%s\", clk_name);\n\t\t}\n\n\t\tif (!clk_topology[nodes[j].type])\n\t\t\tcontinue;\n\n\t\thw = (*clk_topology[nodes[j].type])(clk_out[j], clk_dev_id,\n\t\t\t\t\t\t    parent_names,\n\t\t\t\t\t\t    num_parents,\n\t\t\t\t\t\t    &nodes[j]);\n\t\tif (IS_ERR(hw))\n\t\t\tpr_warn_once(\"%s() 0x%x: %s register fail with %ld\\n\",\n\t\t\t\t     __func__,  clk_dev_id, clk_name,\n\t\t\t\t     PTR_ERR(hw));\n\n\t\tparent_names[0] = clk_out[j];\n\t}\n\n\tfor (j = 0; j < num_nodes; j++)\n\t\tkfree(clk_out[j]);\n\n\treturn hw;\n}\n\n \nstatic int zynqmp_register_clocks(struct device_node *np)\n{\n\tint ret;\n\tu32 i, total_parents = 0, type = 0;\n\tconst char *parent_names[MAX_PARENT];\n\n\tfor (i = 0; i < clock_max_idx; i++) {\n\t\tchar clk_name[MAX_NAME_LEN];\n\n\t\t \n\t\tif (zynqmp_get_clock_name(i, clk_name))\n\t\t\tcontinue;\n\n\t\t \n\t\tret = zynqmp_get_clock_type(i, &type);\n\t\tif (ret || type != CLK_TYPE_OUTPUT)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (zynqmp_get_parent_list(np, i, parent_names,\n\t\t\t\t\t   &total_parents)) {\n\t\t\tWARN_ONCE(1, \"No parents found for %s\\n\",\n\t\t\t\t  clock[i].clk_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tzynqmp_data->hws[i] =\n\t\t\tzynqmp_register_clk_topology(i, clk_name,\n\t\t\t\t\t\t     total_parents,\n\t\t\t\t\t\t     parent_names);\n\t}\n\n\tfor (i = 0; i < clock_max_idx; i++) {\n\t\tif (IS_ERR(zynqmp_data->hws[i])) {\n\t\t\tpr_err(\"Zynq Ultrascale+ MPSoC clk %s: register failed with %ld\\n\",\n\t\t\t       clock[i].clk_name, PTR_ERR(zynqmp_data->hws[i]));\n\t\t\tWARN_ON(1);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void zynqmp_get_clock_info(void)\n{\n\tint i, ret;\n\tu32 type = 0;\n\tu32 nodetype, subclass, class;\n\tstruct attr_resp attr;\n\tstruct name_resp name;\n\n\tfor (i = 0; i < clock_max_idx; i++) {\n\t\tret = zynqmp_pm_clock_get_attributes(i, &attr);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tclock[i].valid = FIELD_GET(CLK_ATTR_VALID, attr.attr[0]);\n\t\t \n\t\tret = zynqmp_is_valid_clock(i);\n\t\tif (ret != CLK_ATTR_VALID)\n\t\t\tcontinue;\n\n\t\tclock[i].type = FIELD_GET(CLK_ATTR_TYPE, attr.attr[0]) ?\n\t\t\tCLK_TYPE_EXTERNAL : CLK_TYPE_OUTPUT;\n\n\t\tnodetype = FIELD_GET(CLK_ATTR_NODE_TYPE, attr.attr[0]);\n\t\tsubclass = FIELD_GET(CLK_ATTR_NODE_SUBCLASS, attr.attr[0]);\n\t\tclass = FIELD_GET(CLK_ATTR_NODE_CLASS, attr.attr[0]);\n\n\t\tclock[i].clk_id = FIELD_PREP(CLK_ATTR_NODE_CLASS, class) |\n\t\t\t\t  FIELD_PREP(CLK_ATTR_NODE_SUBCLASS, subclass) |\n\t\t\t\t  FIELD_PREP(CLK_ATTR_NODE_TYPE, nodetype) |\n\t\t\t\t  FIELD_PREP(CLK_ATTR_NODE_INDEX, i);\n\n\t\tzynqmp_pm_clock_get_name(clock[i].clk_id, &name);\n\n\t\t \n\t\tname.name[sizeof(name.name) - 1] = '\\0';\n\n\t\tif (!strcmp(name.name, RESERVED_CLK_NAME))\n\t\t\tcontinue;\n\t\tstrscpy(clock[i].clk_name, name.name, MAX_NAME_LEN);\n\t}\n\n\t \n\tfor (i = 0; i < clock_max_idx; i++) {\n\t\tret = zynqmp_get_clock_type(i, &type);\n\t\tif (ret || type != CLK_TYPE_OUTPUT)\n\t\t\tcontinue;\n\n\t\tret = zynqmp_clock_get_topology(i, clock[i].node,\n\t\t\t\t\t\t&clock[i].num_nodes);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tret = zynqmp_clock_get_parents(i, clock[i].parent,\n\t\t\t\t\t       &clock[i].num_parents);\n\t\tif (ret)\n\t\t\tcontinue;\n\t}\n}\n\n \nstatic int zynqmp_clk_setup(struct device_node *np)\n{\n\tint ret;\n\n\tret = zynqmp_pm_clock_get_num_clocks(&clock_max_idx);\n\tif (ret)\n\t\treturn ret;\n\n\tzynqmp_data = kzalloc(struct_size(zynqmp_data, hws, clock_max_idx),\n\t\t\t      GFP_KERNEL);\n\tif (!zynqmp_data)\n\t\treturn -ENOMEM;\n\n\tclock = kcalloc(clock_max_idx, sizeof(*clock), GFP_KERNEL);\n\tif (!clock) {\n\t\tkfree(zynqmp_data);\n\t\treturn -ENOMEM;\n\t}\n\n\tzynqmp_get_clock_info();\n\tzynqmp_register_clocks(np);\n\n\tzynqmp_data->num = clock_max_idx;\n\treturn of_clk_add_hw_provider(np, of_clk_hw_onecell_get, zynqmp_data);\n}\n\nstatic int zynqmp_clock_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct device *dev = &pdev->dev;\n\n\tret = zynqmp_clk_setup(dev->of_node);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id zynqmp_clock_of_match[] = {\n\t{.compatible = \"xlnx,zynqmp-clk\"},\n\t{.compatible = \"xlnx,versal-clk\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, zynqmp_clock_of_match);\n\nstatic struct platform_driver zynqmp_clock_driver = {\n\t.driver = {\n\t\t.name = \"zynqmp_clock\",\n\t\t.of_match_table = zynqmp_clock_of_match,\n\t},\n\t.probe = zynqmp_clock_probe,\n};\nmodule_platform_driver(zynqmp_clock_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}