{
  "module_name": "clk-mux-zynqmp.c",
  "hash_id": "efd402d12c29e86ed1165c55a335c97bff8879561f1f1b230e0aeaeb1dc5ddd1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/zynqmp/clk-mux-zynqmp.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include \"clk-zynqmp.h\"\n\n \n\n \nstruct zynqmp_clk_mux {\n\tstruct clk_hw hw;\n\tu8 flags;\n\tu32 clk_id;\n};\n\n#define to_zynqmp_clk_mux(_hw) container_of(_hw, struct zynqmp_clk_mux, hw)\n\n \nstatic u8 zynqmp_clk_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct zynqmp_clk_mux *mux = to_zynqmp_clk_mux(hw);\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 clk_id = mux->clk_id;\n\tu32 val;\n\tint ret;\n\n\tret = zynqmp_pm_clock_getparent(clk_id, &val);\n\n\tif (ret) {\n\t\tpr_debug(\"%s() getparent failed for clock: %s, ret = %d\\n\",\n\t\t\t __func__, clk_name, ret);\n\t\t \n\t\treturn clk_hw_get_num_parents(hw);\n\t}\n\n\treturn val;\n}\n\n \nstatic int zynqmp_clk_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct zynqmp_clk_mux *mux = to_zynqmp_clk_mux(hw);\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 clk_id = mux->clk_id;\n\tint ret;\n\n\tret = zynqmp_pm_clock_setparent(clk_id, index);\n\n\tif (ret)\n\t\tpr_debug(\"%s() set parent failed for clock: %s, ret = %d\\n\",\n\t\t\t __func__, clk_name, ret);\n\n\treturn ret;\n}\n\nstatic const struct clk_ops zynqmp_clk_mux_ops = {\n\t.get_parent = zynqmp_clk_mux_get_parent,\n\t.set_parent = zynqmp_clk_mux_set_parent,\n\t.determine_rate = __clk_mux_determine_rate_closest,\n};\n\nstatic const struct clk_ops zynqmp_clk_mux_ro_ops = {\n\t.get_parent = zynqmp_clk_mux_get_parent,\n};\n\nstatic inline unsigned long zynqmp_clk_map_mux_ccf_flags(\n\t\t\t\t       const u32 zynqmp_type_flag)\n{\n\tunsigned long ccf_flag = 0;\n\n\tif (zynqmp_type_flag & ZYNQMP_CLK_MUX_INDEX_ONE)\n\t\tccf_flag |= CLK_MUX_INDEX_ONE;\n\tif (zynqmp_type_flag & ZYNQMP_CLK_MUX_INDEX_BIT)\n\t\tccf_flag |= CLK_MUX_INDEX_BIT;\n\tif (zynqmp_type_flag & ZYNQMP_CLK_MUX_HIWORD_MASK)\n\t\tccf_flag |= CLK_MUX_HIWORD_MASK;\n\tif (zynqmp_type_flag & ZYNQMP_CLK_MUX_READ_ONLY)\n\t\tccf_flag |= CLK_MUX_READ_ONLY;\n\tif (zynqmp_type_flag & ZYNQMP_CLK_MUX_ROUND_CLOSEST)\n\t\tccf_flag |= CLK_MUX_ROUND_CLOSEST;\n\tif (zynqmp_type_flag & ZYNQMP_CLK_MUX_BIG_ENDIAN)\n\t\tccf_flag |= CLK_MUX_BIG_ENDIAN;\n\n\treturn ccf_flag;\n}\n\n \nstruct clk_hw *zynqmp_clk_register_mux(const char *name, u32 clk_id,\n\t\t\t\t       const char * const *parents,\n\t\t\t\t       u8 num_parents,\n\t\t\t\t       const struct clock_topology *nodes)\n{\n\tstruct zynqmp_clk_mux *mux;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tif (nodes->type_flag & CLK_MUX_READ_ONLY)\n\t\tinit.ops = &zynqmp_clk_mux_ro_ops;\n\telse\n\t\tinit.ops = &zynqmp_clk_mux_ops;\n\n\tinit.flags = zynqmp_clk_map_common_ccf_flags(nodes->flag);\n\n\tinit.parent_names = parents;\n\tinit.num_parents = num_parents;\n\tmux->flags = zynqmp_clk_map_mux_ccf_flags(nodes->type_flag);\n\tmux->hw.init = &init;\n\tmux->clk_id = clk_id;\n\n\thw = &mux->hw;\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(mux);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}