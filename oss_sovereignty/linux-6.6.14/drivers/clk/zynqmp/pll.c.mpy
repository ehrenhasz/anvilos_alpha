{
  "module_name": "pll.c",
  "hash_id": "bfb93eabfd7e9223384a5f1247963b81a813df97196043fda231d3db21f190ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/zynqmp/pll.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include \"clk-zynqmp.h\"\n\n \nstruct zynqmp_pll {\n\tstruct clk_hw hw;\n\tu32 clk_id;\n\tbool set_pll_mode;\n};\n\n#define to_zynqmp_pll(_hw)\tcontainer_of(_hw, struct zynqmp_pll, hw)\n\n#define PLL_FBDIV_MIN\t25\n#define PLL_FBDIV_MAX\t125\n\n#define PS_PLL_VCO_MIN 1500000000\n#define PS_PLL_VCO_MAX 3000000000UL\n\nenum pll_mode {\n\tPLL_MODE_INT = 0,\n\tPLL_MODE_FRAC = 1,\n\tPLL_MODE_ERROR = 2,\n};\n\n#define FRAC_OFFSET 0x8\n#define PLLFCFG_FRAC_EN\tBIT(31)\n#define FRAC_DIV  BIT(16)   \n\n \nstatic inline enum pll_mode zynqmp_pll_get_mode(struct clk_hw *hw)\n{\n\tstruct zynqmp_pll *clk = to_zynqmp_pll(hw);\n\tu32 clk_id = clk->clk_id;\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tret = zynqmp_pm_get_pll_frac_mode(clk_id, ret_payload);\n\tif (ret) {\n\t\tpr_debug(\"%s() PLL get frac mode failed for %s, ret = %d\\n\",\n\t\t\t __func__, clk_name, ret);\n\t\treturn PLL_MODE_ERROR;\n\t}\n\n\treturn ret_payload[1];\n}\n\n \nstatic inline void zynqmp_pll_set_mode(struct clk_hw *hw, bool on)\n{\n\tstruct zynqmp_pll *clk = to_zynqmp_pll(hw);\n\tu32 clk_id = clk->clk_id;\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tint ret;\n\tu32 mode;\n\n\tif (on)\n\t\tmode = PLL_MODE_FRAC;\n\telse\n\t\tmode = PLL_MODE_INT;\n\n\tret = zynqmp_pm_set_pll_frac_mode(clk_id, mode);\n\tif (ret)\n\t\tpr_debug(\"%s() PLL set frac mode failed for %s, ret = %d\\n\",\n\t\t\t __func__, clk_name, ret);\n\telse\n\t\tclk->set_pll_mode = true;\n}\n\n \nstatic long zynqmp_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long *prate)\n{\n\tu32 fbdiv;\n\tu32 mult, div;\n\n\t \n\tif (rate > PS_PLL_VCO_MAX) {\n\t\tdiv = DIV_ROUND_UP(rate, PS_PLL_VCO_MAX);\n\t\trate = rate / div;\n\t}\n\tif (rate < PS_PLL_VCO_MIN) {\n\t\tmult = DIV_ROUND_UP(PS_PLL_VCO_MIN, rate);\n\t\trate = rate * mult;\n\t}\n\n\tfbdiv = DIV_ROUND_CLOSEST(rate, *prate);\n\tif (fbdiv < PLL_FBDIV_MIN || fbdiv > PLL_FBDIV_MAX) {\n\t\tfbdiv = clamp_t(u32, fbdiv, PLL_FBDIV_MIN, PLL_FBDIV_MAX);\n\t\trate = *prate * fbdiv;\n\t}\n\n\treturn rate;\n}\n\n \nstatic unsigned long zynqmp_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct zynqmp_pll *clk = to_zynqmp_pll(hw);\n\tu32 clk_id = clk->clk_id;\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 fbdiv, data;\n\tunsigned long rate, frac;\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\tenum pll_mode mode;\n\n\tret = zynqmp_pm_clock_getdivider(clk_id, &fbdiv);\n\tif (ret) {\n\t\tpr_debug(\"%s() get divider failed for %s, ret = %d\\n\",\n\t\t\t __func__, clk_name, ret);\n\t\treturn 0ul;\n\t}\n\n\tmode = zynqmp_pll_get_mode(hw);\n\tif (mode == PLL_MODE_ERROR)\n\t\treturn 0ul;\n\n\trate =  parent_rate * fbdiv;\n\tif (mode == PLL_MODE_FRAC) {\n\t\tzynqmp_pm_get_pll_frac_data(clk_id, ret_payload);\n\t\tdata = ret_payload[1];\n\t\tfrac = (parent_rate * data) / FRAC_DIV;\n\t\trate = rate + frac;\n\t}\n\n\treturn rate;\n}\n\n \nstatic int zynqmp_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct zynqmp_pll *clk = to_zynqmp_pll(hw);\n\tu32 clk_id = clk->clk_id;\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 fbdiv;\n\tlong rate_div, frac, m, f;\n\tint ret;\n\n\trate_div = (rate * FRAC_DIV) / parent_rate;\n\tf = rate_div % FRAC_DIV;\n\tzynqmp_pll_set_mode(hw, !!f);\n\n\tif (f) {\n\t\tm = rate_div / FRAC_DIV;\n\t\tm = clamp_t(u32, m, (PLL_FBDIV_MIN), (PLL_FBDIV_MAX));\n\t\trate = parent_rate * m;\n\t\tfrac = (parent_rate * f) / FRAC_DIV;\n\n\t\tret = zynqmp_pm_clock_setdivider(clk_id, m);\n\t\tif (ret == -EUSERS)\n\t\t\tWARN(1, \"More than allowed devices are using the %s, which is forbidden\\n\",\n\t\t\t     clk_name);\n\t\telse if (ret)\n\t\t\tpr_debug(\"%s() set divider failed for %s, ret = %d\\n\",\n\t\t\t\t __func__, clk_name, ret);\n\t\tzynqmp_pm_set_pll_frac_data(clk_id, f);\n\n\t\treturn rate + frac;\n\t}\n\n\tfbdiv = DIV_ROUND_CLOSEST(rate, parent_rate);\n\tfbdiv = clamp_t(u32, fbdiv, PLL_FBDIV_MIN, PLL_FBDIV_MAX);\n\tret = zynqmp_pm_clock_setdivider(clk_id, fbdiv);\n\tif (ret)\n\t\tpr_debug(\"%s() set divider failed for %s, ret = %d\\n\",\n\t\t\t __func__, clk_name, ret);\n\n\treturn parent_rate * fbdiv;\n}\n\n \nstatic int zynqmp_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct zynqmp_pll *clk = to_zynqmp_pll(hw);\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 clk_id = clk->clk_id;\n\tunsigned int state;\n\tint ret;\n\n\tret = zynqmp_pm_clock_getstate(clk_id, &state);\n\tif (ret) {\n\t\tpr_debug(\"%s() clock get state failed for %s, ret = %d\\n\",\n\t\t\t __func__, clk_name, ret);\n\t\treturn -EIO;\n\t}\n\n\treturn state ? 1 : 0;\n}\n\n \nstatic int zynqmp_pll_enable(struct clk_hw *hw)\n{\n\tstruct zynqmp_pll *clk = to_zynqmp_pll(hw);\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 clk_id = clk->clk_id;\n\tint ret;\n\n\t \n\tif (zynqmp_pll_is_enabled(hw) && (!clk->set_pll_mode))\n\t\treturn 0;\n\n\tclk->set_pll_mode = false;\n\n\tret = zynqmp_pm_clock_enable(clk_id);\n\tif (ret)\n\t\tpr_debug(\"%s() clock enable failed for %s, ret = %d\\n\",\n\t\t\t __func__, clk_name, ret);\n\n\treturn ret;\n}\n\n \nstatic void zynqmp_pll_disable(struct clk_hw *hw)\n{\n\tstruct zynqmp_pll *clk = to_zynqmp_pll(hw);\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 clk_id = clk->clk_id;\n\tint ret;\n\n\tif (!zynqmp_pll_is_enabled(hw))\n\t\treturn;\n\n\tret = zynqmp_pm_clock_disable(clk_id);\n\tif (ret)\n\t\tpr_debug(\"%s() clock disable failed for %s, ret = %d\\n\",\n\t\t\t __func__, clk_name, ret);\n}\n\nstatic const struct clk_ops zynqmp_pll_ops = {\n\t.enable = zynqmp_pll_enable,\n\t.disable = zynqmp_pll_disable,\n\t.is_enabled = zynqmp_pll_is_enabled,\n\t.round_rate = zynqmp_pll_round_rate,\n\t.recalc_rate = zynqmp_pll_recalc_rate,\n\t.set_rate = zynqmp_pll_set_rate,\n};\n\n \nstruct clk_hw *zynqmp_clk_register_pll(const char *name, u32 clk_id,\n\t\t\t\t       const char * const *parents,\n\t\t\t\t       u8 num_parents,\n\t\t\t\t       const struct clock_topology *nodes)\n{\n\tstruct zynqmp_pll *pll;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tinit.name = name;\n\tinit.ops = &zynqmp_pll_ops;\n\n\tinit.flags = zynqmp_clk_map_common_ccf_flags(nodes->flag);\n\n\tinit.parent_names = parents;\n\tinit.num_parents = 1;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpll->hw.init = &init;\n\tpll->clk_id = clk_id;\n\n\thw = &pll->hw;\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(pll);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}