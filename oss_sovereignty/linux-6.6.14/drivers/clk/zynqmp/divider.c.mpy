{
  "module_name": "divider.c",
  "hash_id": "af8ced0bf8f854161091b78942e275a3c3f3aa66e1a47eaec4219a21d89f1ba5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/zynqmp/divider.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include \"clk-zynqmp.h\"\n\n \n\n#define to_zynqmp_clk_divider(_hw)\t\t\\\n\tcontainer_of(_hw, struct zynqmp_clk_divider, hw)\n\n#define CLK_FRAC\t\tBIT(13)  \n#define CUSTOM_FLAG_CLK_FRAC\tBIT(0)  \n\n \nstruct zynqmp_clk_divider {\n\tstruct clk_hw hw;\n\tu8 flags;\n\tbool is_frac;\n\tu32 clk_id;\n\tu32 div_type;\n\tu16 max_div;\n};\n\nstatic inline int zynqmp_divider_get_val(unsigned long parent_rate,\n\t\t\t\t\t unsigned long rate, u16 flags)\n{\n\tint up, down;\n\tunsigned long up_rate, down_rate;\n\n\tif (flags & CLK_DIVIDER_POWER_OF_TWO) {\n\t\tup = DIV_ROUND_UP_ULL((u64)parent_rate, rate);\n\t\tdown = DIV_ROUND_DOWN_ULL((u64)parent_rate, rate);\n\n\t\tup = __roundup_pow_of_two(up);\n\t\tdown = __rounddown_pow_of_two(down);\n\n\t\tup_rate = DIV_ROUND_UP_ULL((u64)parent_rate, up);\n\t\tdown_rate = DIV_ROUND_UP_ULL((u64)parent_rate, down);\n\n\t\treturn (rate - up_rate) <= (down_rate - rate) ? up : down;\n\n\t} else {\n\t\treturn DIV_ROUND_CLOSEST(parent_rate, rate);\n\t}\n}\n\n \nstatic unsigned long zynqmp_clk_divider_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct zynqmp_clk_divider *divider = to_zynqmp_clk_divider(hw);\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 clk_id = divider->clk_id;\n\tu32 div_type = divider->div_type;\n\tu32 div, value;\n\tint ret;\n\n\tret = zynqmp_pm_clock_getdivider(clk_id, &div);\n\n\tif (ret)\n\t\tpr_debug(\"%s() get divider failed for %s, ret = %d\\n\",\n\t\t\t __func__, clk_name, ret);\n\n\tif (div_type == TYPE_DIV1)\n\t\tvalue = div & 0xFFFF;\n\telse\n\t\tvalue = div >> 16;\n\n\tif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\tvalue = 1 << value;\n\n\tif (!value) {\n\t\tWARN(!(divider->flags & CLK_DIVIDER_ALLOW_ZERO),\n\t\t     \"%s: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set\\n\",\n\t\t     clk_name);\n\t\treturn parent_rate;\n\t}\n\n\treturn DIV_ROUND_UP_ULL(parent_rate, value);\n}\n\n \nstatic long zynqmp_clk_divider_round_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long rate,\n\t\t\t\t\t  unsigned long *prate)\n{\n\tstruct zynqmp_clk_divider *divider = to_zynqmp_clk_divider(hw);\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 clk_id = divider->clk_id;\n\tu32 div_type = divider->div_type;\n\tu32 bestdiv;\n\tint ret;\n\tu8 width;\n\n\t \n\tif (divider->flags & CLK_DIVIDER_READ_ONLY) {\n\t\tret = zynqmp_pm_clock_getdivider(clk_id, &bestdiv);\n\n\t\tif (ret)\n\t\t\tpr_debug(\"%s() get divider failed for %s, ret = %d\\n\",\n\t\t\t\t __func__, clk_name, ret);\n\t\tif (div_type == TYPE_DIV1)\n\t\t\tbestdiv = bestdiv & 0xFFFF;\n\t\telse\n\t\t\tbestdiv  = bestdiv >> 16;\n\n\t\tif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\t\tbestdiv = 1 << bestdiv;\n\n\t\treturn DIV_ROUND_UP_ULL((u64)*prate, bestdiv);\n\t}\n\n\twidth = fls(divider->max_div);\n\n\trate = divider_round_rate(hw, rate, prate, NULL, width, divider->flags);\n\n\tif (divider->is_frac && (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) && (rate % *prate))\n\t\t*prate = rate;\n\n\treturn rate;\n}\n\n \nstatic int zynqmp_clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct zynqmp_clk_divider *divider = to_zynqmp_clk_divider(hw);\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 clk_id = divider->clk_id;\n\tu32 div_type = divider->div_type;\n\tu32 value, div;\n\tint ret;\n\n\tvalue = zynqmp_divider_get_val(parent_rate, rate, divider->flags);\n\tif (div_type == TYPE_DIV1) {\n\t\tdiv = value & 0xFFFF;\n\t\tdiv |= 0xffff << 16;\n\t} else {\n\t\tdiv = 0xffff;\n\t\tdiv |= value << 16;\n\t}\n\n\tif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\tdiv = __ffs(div);\n\n\tret = zynqmp_pm_clock_setdivider(clk_id, div);\n\n\tif (ret)\n\t\tpr_debug(\"%s() set divider failed for %s, ret = %d\\n\",\n\t\t\t __func__, clk_name, ret);\n\n\treturn ret;\n}\n\nstatic const struct clk_ops zynqmp_clk_divider_ops = {\n\t.recalc_rate = zynqmp_clk_divider_recalc_rate,\n\t.round_rate = zynqmp_clk_divider_round_rate,\n\t.set_rate = zynqmp_clk_divider_set_rate,\n};\n\nstatic const struct clk_ops zynqmp_clk_divider_ro_ops = {\n\t.recalc_rate = zynqmp_clk_divider_recalc_rate,\n\t.round_rate = zynqmp_clk_divider_round_rate,\n};\n\n \nstatic u32 zynqmp_clk_get_max_divisor(u32 clk_id, u32 type)\n{\n\tstruct zynqmp_pm_query_data qdata = {0};\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tqdata.qid = PM_QID_CLOCK_GET_MAX_DIVISOR;\n\tqdata.arg1 = clk_id;\n\tqdata.arg2 = type;\n\tret = zynqmp_pm_query_data(qdata, ret_payload);\n\t \n\tif (ret)\n\t\treturn U16_MAX;\n\n\treturn ret_payload[1];\n}\n\nstatic inline unsigned long zynqmp_clk_map_divider_ccf_flags(\n\t\t\t\t\t       const u32 zynqmp_type_flag)\n{\n\tunsigned long ccf_flag = 0;\n\n\tif (zynqmp_type_flag & ZYNQMP_CLK_DIVIDER_ONE_BASED)\n\t\tccf_flag |= CLK_DIVIDER_ONE_BASED;\n\tif (zynqmp_type_flag & ZYNQMP_CLK_DIVIDER_POWER_OF_TWO)\n\t\tccf_flag |= CLK_DIVIDER_POWER_OF_TWO;\n\tif (zynqmp_type_flag & ZYNQMP_CLK_DIVIDER_ALLOW_ZERO)\n\t\tccf_flag |= CLK_DIVIDER_ALLOW_ZERO;\n\tif (zynqmp_type_flag & ZYNQMP_CLK_DIVIDER_POWER_OF_TWO)\n\t\tccf_flag |= CLK_DIVIDER_HIWORD_MASK;\n\tif (zynqmp_type_flag & ZYNQMP_CLK_DIVIDER_ROUND_CLOSEST)\n\t\tccf_flag |= CLK_DIVIDER_ROUND_CLOSEST;\n\tif (zynqmp_type_flag & ZYNQMP_CLK_DIVIDER_READ_ONLY)\n\t\tccf_flag |= CLK_DIVIDER_READ_ONLY;\n\tif (zynqmp_type_flag & ZYNQMP_CLK_DIVIDER_MAX_AT_ZERO)\n\t\tccf_flag |= CLK_DIVIDER_MAX_AT_ZERO;\n\n\treturn ccf_flag;\n}\n\n \nstruct clk_hw *zynqmp_clk_register_divider(const char *name,\n\t\t\t\t\t   u32 clk_id,\n\t\t\t\t\t   const char * const *parents,\n\t\t\t\t\t   u8 num_parents,\n\t\t\t\t\t   const struct clock_topology *nodes)\n{\n\tstruct zynqmp_clk_divider *div;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\t \n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tif (nodes->type_flag & CLK_DIVIDER_READ_ONLY)\n\t\tinit.ops = &zynqmp_clk_divider_ro_ops;\n\telse\n\t\tinit.ops = &zynqmp_clk_divider_ops;\n\n\tinit.flags = zynqmp_clk_map_common_ccf_flags(nodes->flag);\n\n\tinit.parent_names = parents;\n\tinit.num_parents = 1;\n\n\t \n\tdiv->is_frac = !!((nodes->flag & CLK_FRAC) |\n\t\t\t  (nodes->custom_type_flag & CUSTOM_FLAG_CLK_FRAC));\n\tdiv->flags = zynqmp_clk_map_divider_ccf_flags(nodes->type_flag);\n\tdiv->hw.init = &init;\n\tdiv->clk_id = clk_id;\n\tdiv->div_type = nodes->type;\n\n\t \n\tdiv->max_div = zynqmp_clk_get_max_divisor(clk_id, nodes->type);\n\n\thw = &div->hw;\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(div);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}