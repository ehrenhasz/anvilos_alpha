{
  "module_name": "clk-msc313-mpll.c",
  "hash_id": "4921b8197e59d279cb96c426bc8ab2782a78fcc745ff2cd14a3a8247aa1ec52c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mstar/clk-msc313-mpll.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/of_address.h>\n#include <linux/clk-provider.h>\n#include <linux/regmap.h>\n\n#define REG_CONFIG1\t0x8\n#define REG_CONFIG2\t0xc\n\nstatic const struct regmap_config msc313_mpll_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\t.reg_stride = 4,\n};\n\nstatic const struct reg_field config1_loop_div_first = REG_FIELD(REG_CONFIG1, 8, 9);\nstatic const struct reg_field config1_input_div_first = REG_FIELD(REG_CONFIG1, 4, 5);\nstatic const struct reg_field config2_output_div_first = REG_FIELD(REG_CONFIG2, 12, 13);\nstatic const struct reg_field config2_loop_div_second = REG_FIELD(REG_CONFIG2, 0, 7);\n\nstatic const unsigned int output_dividers[] = {\n\t2, 3, 4, 5, 6, 7, 10\n};\n\n#define NUMOUTPUTS (ARRAY_SIZE(output_dividers) + 1)\n\nstruct msc313_mpll {\n\tstruct clk_hw clk_hw;\n\tstruct regmap_field *input_div;\n\tstruct regmap_field *loop_div_first;\n\tstruct regmap_field *loop_div_second;\n\tstruct regmap_field *output_div;\n\tstruct clk_hw_onecell_data *clk_data;\n};\n\n#define to_mpll(_hw) container_of(_hw, struct msc313_mpll, clk_hw)\n\nstatic unsigned long msc313_mpll_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct msc313_mpll *mpll = to_mpll(hw);\n\tunsigned int input_div, output_div, loop_first, loop_second;\n\tunsigned long output_rate;\n\n\tregmap_field_read(mpll->input_div, &input_div);\n\tregmap_field_read(mpll->output_div, &output_div);\n\tregmap_field_read(mpll->loop_div_first, &loop_first);\n\tregmap_field_read(mpll->loop_div_second, &loop_second);\n\n\toutput_rate = parent_rate / (1 << input_div);\n\toutput_rate *= (1 << loop_first) * max(loop_second, 1U);\n\toutput_rate /= max(output_div, 1U);\n\n\treturn output_rate;\n}\n\nstatic const struct clk_ops msc313_mpll_ops = {\n\t.recalc_rate = msc313_mpll_recalc_rate,\n};\n\nstatic const struct clk_parent_data mpll_parent = {\n\t.index\t= 0,\n};\n\nstatic int msc313_mpll_probe(struct platform_device *pdev)\n{\n\tvoid __iomem *base;\n\tstruct msc313_mpll *mpll;\n\tstruct clk_init_data clk_init = { };\n\tstruct device *dev = &pdev->dev;\n\tstruct regmap *regmap;\n\tchar *outputname;\n\tstruct clk_hw *divhw;\n\tint ret, i;\n\n\tmpll = devm_kzalloc(dev, sizeof(*mpll), GFP_KERNEL);\n\tif (!mpll)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio(dev, base, &msc313_mpll_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tmpll->input_div = devm_regmap_field_alloc(dev, regmap, config1_input_div_first);\n\tif (IS_ERR(mpll->input_div))\n\t\treturn PTR_ERR(mpll->input_div);\n\tmpll->output_div = devm_regmap_field_alloc(dev, regmap, config2_output_div_first);\n\tif (IS_ERR(mpll->output_div))\n\t\treturn PTR_ERR(mpll->output_div);\n\tmpll->loop_div_first = devm_regmap_field_alloc(dev, regmap, config1_loop_div_first);\n\tif (IS_ERR(mpll->loop_div_first))\n\t\treturn PTR_ERR(mpll->loop_div_first);\n\tmpll->loop_div_second = devm_regmap_field_alloc(dev, regmap, config2_loop_div_second);\n\tif (IS_ERR(mpll->loop_div_second))\n\t\treturn PTR_ERR(mpll->loop_div_second);\n\n\tmpll->clk_data = devm_kzalloc(dev, struct_size(mpll->clk_data, hws,\n\t\t\tARRAY_SIZE(output_dividers)), GFP_KERNEL);\n\tif (!mpll->clk_data)\n\t\treturn -ENOMEM;\n\n\tclk_init.name = dev_name(dev);\n\tclk_init.ops = &msc313_mpll_ops;\n\tclk_init.parent_data = &mpll_parent;\n\tclk_init.num_parents = 1;\n\tmpll->clk_hw.init = &clk_init;\n\n\tret = devm_clk_hw_register(dev, &mpll->clk_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tmpll->clk_data->num = NUMOUTPUTS;\n\tmpll->clk_data->hws[0] = &mpll->clk_hw;\n\n\tfor (i = 0; i < ARRAY_SIZE(output_dividers); i++) {\n\t\toutputname = devm_kasprintf(dev, GFP_KERNEL, \"%s_div_%u\",\n\t\t\t\tclk_init.name, output_dividers[i]);\n\t\tif (!outputname)\n\t\t\treturn -ENOMEM;\n\t\tdivhw = devm_clk_hw_register_fixed_factor(dev, outputname,\n\t\t\t\tclk_init.name, 0, 1, output_dividers[i]);\n\t\tif (IS_ERR(divhw))\n\t\t\treturn PTR_ERR(divhw);\n\t\tmpll->clk_data->hws[i + 1] = divhw;\n\t}\n\n\tplatform_set_drvdata(pdev, mpll);\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, of_clk_hw_onecell_get,\n\t\t\tmpll->clk_data);\n}\n\nstatic const struct of_device_id msc313_mpll_of_match[] = {\n\t{ .compatible = \"mstar,msc313-mpll\", },\n\t{}\n};\n\nstatic struct platform_driver msc313_mpll_driver = {\n\t.driver = {\n\t\t.name = \"mstar-msc313-mpll\",\n\t\t.of_match_table = msc313_mpll_of_match,\n\t},\n\t.probe = msc313_mpll_probe,\n};\nbuiltin_platform_driver(msc313_mpll_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}