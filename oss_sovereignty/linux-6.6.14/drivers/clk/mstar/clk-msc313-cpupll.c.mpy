{
  "module_name": "clk-msc313-cpupll.c",
  "hash_id": "1cb8c275ad284e7df8db1ef9f9cea5d22773e27410e8cc7ec29555295953ebb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mstar/clk-msc313-cpupll.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n\n \n\n#define REG_LPF_LOW_L\t\t0x140\n#define REG_LPF_LOW_H\t\t0x144\n#define REG_LPF_HIGH_BOTTOM\t0x148\n#define REG_LPF_HIGH_TOP\t0x14c\n#define REG_LPF_TOGGLE\t\t0x150\n#define REG_LPF_MYSTERYTWO\t0x154\n#define REG_LPF_UPDATE_COUNT\t0x15c\n#define REG_LPF_MYSTERYONE\t0x160\n#define REG_LPF_TRANSITIONCTRL\t0x164\n#define REG_LPF_LOCK\t\t0x174\n#define REG_CURRENT\t\t0x180\n\n#define LPF_LOCK_TIMEOUT\t100000000\n\n#define MULTIPLIER_1\t\t16\n#define MULTIPLIER_2\t\t524288\n#define MULTIPLIER\t\t(MULTIPLIER_1 * MULTIPLIER_2)\n\nstruct msc313_cpupll {\n\tvoid __iomem *base;\n\tstruct clk_hw clk_hw;\n};\n\n#define to_cpupll(_hw) container_of(_hw, struct msc313_cpupll, clk_hw)\n\nstatic u32 msc313_cpupll_reg_read32(struct msc313_cpupll *cpupll, unsigned int reg)\n{\n\tu32 value;\n\n\tvalue = ioread16(cpupll->base + reg + 4) << 16;\n\tvalue |= ioread16(cpupll->base + reg);\n\n\treturn value;\n}\n\nstatic void msc313_cpupll_reg_write32(struct msc313_cpupll *cpupll, unsigned int reg, u32 value)\n{\n\tu16 l = value & 0xffff, h = (value >> 16) & 0xffff;\n\n\tiowrite16(l, cpupll->base + reg);\n\tiowrite16(h, cpupll->base + reg + 4);\n}\n\nstatic void msc313_cpupll_setfreq(struct msc313_cpupll *cpupll, u32 regvalue)\n{\n\tktime_t timeout;\n\n\tmsc313_cpupll_reg_write32(cpupll, REG_LPF_HIGH_BOTTOM, regvalue);\n\n\tiowrite16(0x1, cpupll->base + REG_LPF_MYSTERYONE);\n\tiowrite16(0x6, cpupll->base + REG_LPF_MYSTERYTWO);\n\tiowrite16(0x8, cpupll->base + REG_LPF_UPDATE_COUNT);\n\tiowrite16(BIT(12), cpupll->base + REG_LPF_TRANSITIONCTRL);\n\n\tiowrite16(0, cpupll->base + REG_LPF_TOGGLE);\n\tiowrite16(1, cpupll->base + REG_LPF_TOGGLE);\n\n\ttimeout = ktime_add_ns(ktime_get(), LPF_LOCK_TIMEOUT);\n\twhile (!(ioread16(cpupll->base + REG_LPF_LOCK))) {\n\t\tif (ktime_after(ktime_get(), timeout)) {\n\t\t\tpr_err(\"timeout waiting for LPF_LOCK\\n\");\n\t\t\treturn;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\tiowrite16(0, cpupll->base + REG_LPF_TOGGLE);\n\n\tmsc313_cpupll_reg_write32(cpupll, REG_LPF_LOW_L, regvalue);\n}\n\nstatic unsigned long msc313_cpupll_frequencyforreg(u32 reg, unsigned long parent_rate)\n{\n\tunsigned long long prescaled = ((unsigned long long)parent_rate) * MULTIPLIER;\n\n\tif (prescaled == 0 || reg == 0)\n\t\treturn 0;\n\treturn DIV_ROUND_DOWN_ULL(prescaled, reg);\n}\n\nstatic u32 msc313_cpupll_regforfrequecy(unsigned long rate, unsigned long parent_rate)\n{\n\tunsigned long long prescaled = ((unsigned long long)parent_rate) * MULTIPLIER;\n\n\tif (prescaled == 0 || rate == 0)\n\t\treturn 0;\n\treturn DIV_ROUND_UP_ULL(prescaled, rate);\n}\n\nstatic unsigned long msc313_cpupll_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct msc313_cpupll *cpupll = to_cpupll(hw);\n\n\treturn msc313_cpupll_frequencyforreg(msc313_cpupll_reg_read32(cpupll, REG_LPF_LOW_L),\n\t\t\t\t\t     parent_rate);\n}\n\nstatic long msc313_cpupll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long *parent_rate)\n{\n\tu32 reg = msc313_cpupll_regforfrequecy(rate, *parent_rate);\n\tlong rounded = msc313_cpupll_frequencyforreg(reg, *parent_rate);\n\n\t \n\tfor (; rounded >= rate && reg > 0; reg--)\n\t\trounded = msc313_cpupll_frequencyforreg(reg, *parent_rate);\n\n\treturn rounded;\n}\n\nstatic int msc313_cpupll_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate)\n{\n\tstruct msc313_cpupll *cpupll = to_cpupll(hw);\n\tu32 reg = msc313_cpupll_regforfrequecy(rate, parent_rate);\n\n\tmsc313_cpupll_setfreq(cpupll, reg);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops msc313_cpupll_ops = {\n\t.recalc_rate\t= msc313_cpupll_recalc_rate,\n\t.round_rate\t= msc313_cpupll_round_rate,\n\t.set_rate\t= msc313_cpupll_set_rate,\n};\n\nstatic const struct of_device_id msc313_cpupll_of_match[] = {\n\t{ .compatible = \"mstar,msc313-cpupll\" },\n\t{}\n};\n\nstatic int msc313_cpupll_probe(struct platform_device *pdev)\n{\n\tstruct clk_init_data clk_init = {};\n\tstruct clk_parent_data cpupll_parent = { .index\t= 0 };\n\tstruct device *dev = &pdev->dev;\n\tstruct msc313_cpupll *cpupll;\n\tint ret;\n\n\tcpupll = devm_kzalloc(&pdev->dev, sizeof(*cpupll), GFP_KERNEL);\n\tif (!cpupll)\n\t\treturn -ENOMEM;\n\n\tcpupll->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(cpupll->base))\n\t\treturn PTR_ERR(cpupll->base);\n\n\t \n\tmsc313_cpupll_reg_write32(cpupll, REG_LPF_LOW_L,\n\t\t\t\t  msc313_cpupll_reg_read32(cpupll, REG_CURRENT));\n\n\tclk_init.name = dev_name(dev);\n\tclk_init.ops = &msc313_cpupll_ops;\n\tclk_init.parent_data = &cpupll_parent;\n\tclk_init.num_parents = 1;\n\tcpupll->clk_hw.init = &clk_init;\n\n\tret = devm_clk_hw_register(dev, &cpupll->clk_hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, of_clk_hw_simple_get, &cpupll->clk_hw);\n}\n\nstatic struct platform_driver msc313_cpupll_driver = {\n\t.driver = {\n\t\t.name = \"mstar-msc313-cpupll\",\n\t\t.of_match_table = msc313_cpupll_of_match,\n\t},\n\t.probe = msc313_cpupll_probe,\n};\nbuiltin_platform_driver(msc313_cpupll_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}