{
  "module_name": "abx500-clk.c",
  "hash_id": "4ec840ff3e76235b30ef13de93f7e6723e45c9281397be5e8f963b27f0c35d97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ux500/abx500-clk.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/abx500/ab8500.h>\n#include <linux/mfd/abx500/ab8500-sysctrl.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <dt-bindings/clock/ste-ab8500.h>\n#include \"clk.h\"\n\n#define AB8500_NUM_CLKS 6\n\nstatic struct clk *ab8500_clks[AB8500_NUM_CLKS];\nstatic struct clk_onecell_data ab8500_clk_data;\n\n \nstatic int ab8500_reg_clks(struct device *dev)\n{\n\tint ret;\n\tstruct clk *clk;\n\tstruct device_node *np = dev->of_node;\n\tconst char *intclk_parents[] = {\"ab8500_sysclk\", \"ulpclk\"};\n\tu16 intclk_reg_sel[] = {0 , AB8500_SYSULPCLKCTRL1};\n\tu8 intclk_reg_mask[] = {0 , AB8500_SYSULPCLKCTRL1_SYSULPCLKINTSEL_MASK};\n\tu8 intclk_reg_bits[] = {\n\t\t0 ,\n\t\t(1 << AB8500_SYSULPCLKCTRL1_SYSULPCLKINTSEL_SHIFT)\n\t};\n\n\t \n\tret = ab8500_sysctrl_set(AB8500_SWATCTRL, AB8500_SWATCTRL_SWATENABLE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tclk = clk_reg_sysctrl_gate(dev , \"ab8500_sysclk2\", \"ab8500_sysclk\",\n\t\tAB8500_SYSULPCLKCTRL1, AB8500_SYSULPCLKCTRL1_SYSCLKBUF2REQ,\n\t\tAB8500_SYSULPCLKCTRL1_SYSCLKBUF2REQ, 0, 0);\n\tab8500_clks[AB8500_SYSCLK_BUF2] = clk;\n\n\t \n\tclk = clk_reg_sysctrl_gate(dev , \"ab8500_sysclk3\", \"ab8500_sysclk\",\n\t\tAB8500_SYSULPCLKCTRL1, AB8500_SYSULPCLKCTRL1_SYSCLKBUF3REQ,\n\t\tAB8500_SYSULPCLKCTRL1_SYSCLKBUF3REQ, 0, 0);\n\tab8500_clks[AB8500_SYSCLK_BUF3] = clk;\n\n\t \n\tclk = clk_reg_sysctrl_gate(dev , \"ab8500_sysclk4\", \"ab8500_sysclk\",\n\t\tAB8500_SYSULPCLKCTRL1, AB8500_SYSULPCLKCTRL1_SYSCLKBUF4REQ,\n\t\tAB8500_SYSULPCLKCTRL1_SYSCLKBUF4REQ, 0, 0);\n\tab8500_clks[AB8500_SYSCLK_BUF4] = clk;\n\n\t \n\tclk = clk_reg_sysctrl_gate_fixed_rate(dev, \"ulpclk\", NULL,\n\t\tAB8500_SYSULPCLKCTRL1, AB8500_SYSULPCLKCTRL1_ULPCLKREQ,\n\t\tAB8500_SYSULPCLKCTRL1_ULPCLKREQ,\n\t\t38400000, 9000, 0);\n\tab8500_clks[AB8500_SYSCLK_ULP] = clk;\n\n\t \n\tclk = clk_reg_sysctrl_set_parent(dev , \"intclk\", intclk_parents, 2,\n\t\tintclk_reg_sel, intclk_reg_mask, intclk_reg_bits, 0);\n\tab8500_clks[AB8500_SYSCLK_INT] = clk;\n\n\t \n\tclk = clk_reg_sysctrl_gate(dev , \"audioclk\", \"intclk\",\n\t\tAB8500_SYSULPCLKCTRL1, AB8500_SYSULPCLKCTRL1_AUDIOCLKENA,\n\t\tAB8500_SYSULPCLKCTRL1_AUDIOCLKENA, 0, 0);\n\tab8500_clks[AB8500_SYSCLK_AUDIO] = clk;\n\n\tab8500_clk_data.clks = ab8500_clks;\n\tab8500_clk_data.clk_num = ARRAY_SIZE(ab8500_clks);\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &ab8500_clk_data);\n\n\tdev_info(dev, \"registered clocks for ab850x\\n\");\n\n\treturn 0;\n}\n\nstatic int abx500_clk_probe(struct platform_device *pdev)\n{\n\tstruct ab8500 *parent = dev_get_drvdata(pdev->dev.parent);\n\tint ret;\n\n\tif (is_ab8500(parent) || is_ab8505(parent)) {\n\t\tret = ab8500_reg_clks(&pdev->dev);\n\t} else {\n\t\tdev_err(&pdev->dev, \"non supported plf id\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct of_device_id abx500_clk_match[] = {\n\t{ .compatible = \"stericsson,ab8500-clk\", },\n\t{}\n};\n\nstatic struct platform_driver abx500_clk_driver = {\n\t.driver = {\n\t\t.name = \"abx500-clk\",\n\t\t.of_match_table = abx500_clk_match,\n\t},\n\t.probe\t= abx500_clk_probe,\n};\n\nstatic int __init abx500_clk_init(void)\n{\n\treturn platform_driver_register(&abx500_clk_driver);\n}\narch_initcall(abx500_clk_init);\n\nMODULE_AUTHOR(\"Ulf Hansson <ulf.hansson@linaro.org\");\nMODULE_DESCRIPTION(\"ABX500 clk driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}