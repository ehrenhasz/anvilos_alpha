{
  "module_name": "clk-sysctrl.c",
  "hash_id": "effea7e41d46f502dc4042c855f09bbb76449c8c42b57eff49e9201683ee3c46",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ux500/clk-sysctrl.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/mfd/abx500/ab8500-sysctrl.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include \"clk.h\"\n\n#define SYSCTRL_MAX_NUM_PARENTS 4\n\n#define to_clk_sysctrl(_hw) container_of(_hw, struct clk_sysctrl, hw)\n\nstruct clk_sysctrl {\n\tstruct clk_hw hw;\n\tstruct device *dev;\n\tu8 parent_index;\n\tu16 reg_sel[SYSCTRL_MAX_NUM_PARENTS];\n\tu8 reg_mask[SYSCTRL_MAX_NUM_PARENTS];\n\tu8 reg_bits[SYSCTRL_MAX_NUM_PARENTS];\n\tunsigned long rate;\n\tunsigned long enable_delay_us;\n};\n\n \n\nstatic int clk_sysctrl_prepare(struct clk_hw *hw)\n{\n\tint ret;\n\tstruct clk_sysctrl *clk = to_clk_sysctrl(hw);\n\n\tret = ab8500_sysctrl_write(clk->reg_sel[0], clk->reg_mask[0],\n\t\t\t\tclk->reg_bits[0]);\n\n\tif (!ret && clk->enable_delay_us)\n\t\tusleep_range(clk->enable_delay_us, clk->enable_delay_us +\n\t\t\t     (clk->enable_delay_us >> 2));\n\n\treturn ret;\n}\n\nstatic void clk_sysctrl_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_sysctrl *clk = to_clk_sysctrl(hw);\n\tif (ab8500_sysctrl_clear(clk->reg_sel[0], clk->reg_mask[0]))\n\t\tdev_err(clk->dev, \"clk_sysctrl: %s fail to clear %s.\\n\",\n\t\t\t__func__, clk_hw_get_name(hw));\n}\n\nstatic unsigned long clk_sysctrl_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_sysctrl *clk = to_clk_sysctrl(hw);\n\treturn clk->rate;\n}\n\nstatic int clk_sysctrl_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_sysctrl *clk = to_clk_sysctrl(hw);\n\tu8 old_index = clk->parent_index;\n\tint ret = 0;\n\n\tif (clk->reg_sel[old_index]) {\n\t\tret = ab8500_sysctrl_clear(clk->reg_sel[old_index],\n\t\t\t\t\tclk->reg_mask[old_index]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (clk->reg_sel[index]) {\n\t\tret = ab8500_sysctrl_write(clk->reg_sel[index],\n\t\t\t\t\tclk->reg_mask[index],\n\t\t\t\t\tclk->reg_bits[index]);\n\t\tif (ret) {\n\t\t\tif (clk->reg_sel[old_index])\n\t\t\t\tab8500_sysctrl_write(clk->reg_sel[old_index],\n\t\t\t\t\t\tclk->reg_mask[old_index],\n\t\t\t\t\t\tclk->reg_bits[old_index]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tclk->parent_index = index;\n\n\treturn ret;\n}\n\nstatic u8 clk_sysctrl_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_sysctrl *clk = to_clk_sysctrl(hw);\n\treturn clk->parent_index;\n}\n\nstatic const struct clk_ops clk_sysctrl_gate_ops = {\n\t.prepare = clk_sysctrl_prepare,\n\t.unprepare = clk_sysctrl_unprepare,\n};\n\nstatic const struct clk_ops clk_sysctrl_gate_fixed_rate_ops = {\n\t.prepare = clk_sysctrl_prepare,\n\t.unprepare = clk_sysctrl_unprepare,\n\t.recalc_rate = clk_sysctrl_recalc_rate,\n};\n\nstatic const struct clk_ops clk_sysctrl_set_parent_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.set_parent = clk_sysctrl_set_parent,\n\t.get_parent = clk_sysctrl_get_parent,\n};\n\nstatic struct clk *clk_reg_sysctrl(struct device *dev,\n\t\t\t\tconst char *name,\n\t\t\t\tconst char **parent_names,\n\t\t\t\tu8 num_parents,\n\t\t\t\tu16 *reg_sel,\n\t\t\t\tu8 *reg_mask,\n\t\t\t\tu8 *reg_bits,\n\t\t\t\tunsigned long rate,\n\t\t\t\tunsigned long enable_delay_us,\n\t\t\t\tunsigned long flags,\n\t\t\t\tconst struct clk_ops *clk_sysctrl_ops)\n{\n\tstruct clk_sysctrl *clk;\n\tstruct clk_init_data clk_sysctrl_init;\n\tstruct clk *clk_reg;\n\tint i;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!name || (num_parents > SYSCTRL_MAX_NUM_PARENTS)) {\n\t\tdev_err(dev, \"clk_sysctrl: invalid arguments passed\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tclk = devm_kzalloc(dev, sizeof(*clk), GFP_KERNEL);\n\tif (!clk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tclk->reg_sel[0] = reg_sel[0];\n\tclk->reg_bits[0] = reg_bits[0];\n\tclk->reg_mask[0] = reg_mask[0];\n\n\t \n\tfor (i = 1; i < num_parents; i++) {\n\t\tclk->reg_sel[i] = reg_sel[i];\n\t\tclk->reg_bits[i] = reg_bits[i];\n\t\tclk->reg_mask[i] = reg_mask[i];\n\t}\n\n\tclk->parent_index = 0;\n\tclk->rate = rate;\n\tclk->enable_delay_us = enable_delay_us;\n\tclk->dev = dev;\n\n\tclk_sysctrl_init.name = name;\n\tclk_sysctrl_init.ops = clk_sysctrl_ops;\n\tclk_sysctrl_init.flags = flags;\n\tclk_sysctrl_init.parent_names = parent_names;\n\tclk_sysctrl_init.num_parents = num_parents;\n\tclk->hw.init = &clk_sysctrl_init;\n\n\tclk_reg = devm_clk_register(clk->dev, &clk->hw);\n\tif (IS_ERR(clk_reg))\n\t\tdev_err(dev, \"clk_sysctrl: clk_register failed\\n\");\n\n\treturn clk_reg;\n}\n\nstruct clk *clk_reg_sysctrl_gate(struct device *dev,\n\t\t\t\tconst char *name,\n\t\t\t\tconst char *parent_name,\n\t\t\t\tu16 reg_sel,\n\t\t\t\tu8 reg_mask,\n\t\t\t\tu8 reg_bits,\n\t\t\t\tunsigned long enable_delay_us,\n\t\t\t\tunsigned long flags)\n{\n\tconst char **parent_names = (parent_name ? &parent_name : NULL);\n\tu8 num_parents = (parent_name ? 1 : 0);\n\n\treturn clk_reg_sysctrl(dev, name, parent_names, num_parents,\n\t\t\t&reg_sel, &reg_mask, &reg_bits, 0, enable_delay_us,\n\t\t\tflags, &clk_sysctrl_gate_ops);\n}\n\nstruct clk *clk_reg_sysctrl_gate_fixed_rate(struct device *dev,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tconst char *parent_name,\n\t\t\t\t\tu16 reg_sel,\n\t\t\t\t\tu8 reg_mask,\n\t\t\t\t\tu8 reg_bits,\n\t\t\t\t\tunsigned long rate,\n\t\t\t\t\tunsigned long enable_delay_us,\n\t\t\t\t\tunsigned long flags)\n{\n\tconst char **parent_names = (parent_name ? &parent_name : NULL);\n\tu8 num_parents = (parent_name ? 1 : 0);\n\n\treturn clk_reg_sysctrl(dev, name, parent_names, num_parents,\n\t\t\t&reg_sel, &reg_mask, &reg_bits,\n\t\t\trate, enable_delay_us, flags,\n\t\t\t&clk_sysctrl_gate_fixed_rate_ops);\n}\n\nstruct clk *clk_reg_sysctrl_set_parent(struct device *dev,\n\t\t\t\tconst char *name,\n\t\t\t\tconst char **parent_names,\n\t\t\t\tu8 num_parents,\n\t\t\t\tu16 *reg_sel,\n\t\t\t\tu8 *reg_mask,\n\t\t\t\tu8 *reg_bits,\n\t\t\t\tunsigned long flags)\n{\n\treturn clk_reg_sysctrl(dev, name, parent_names, num_parents,\n\t\t\treg_sel, reg_mask, reg_bits, 0, 0, flags,\n\t\t\t&clk_sysctrl_set_parent_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}