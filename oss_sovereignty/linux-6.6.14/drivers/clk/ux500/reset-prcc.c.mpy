{
  "module_name": "reset-prcc.c",
  "hash_id": "289bccf6a14612dd6cedeb264d99791935041d09e26b8ceef38c029b57eff4fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ux500/reset-prcc.c",
  "human_readable_source": "\n \n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/types.h>\n#include <linux/reset-controller.h>\n#include <linux/bits.h>\n#include <linux/delay.h>\n\n#include \"prcc.h\"\n#include \"reset-prcc.h\"\n\n#define to_u8500_prcc_reset(p) container_of((p), struct u8500_prcc_reset, rcdev)\n\n \n#define PRCC_RESET_LINE(prcc_num, bit) \\\n\t(((prcc_num) * PRCC_PERIPHS_PER_CLUSTER) + (bit))\n\n \n#define PRCC_K_SOFTRST_SET\t\t0x018\n#define PRCC_K_SOFTRST_CLEAR\t\t0x01c\n#define PRCC_K_RST_STATUS\t\t0x020\n\nstatic int prcc_num_to_index(unsigned int num)\n{\n\tswitch (num) {\n\tcase 1:\n\t\treturn CLKRST1_INDEX;\n\tcase 2:\n\t\treturn CLKRST2_INDEX;\n\tcase 3:\n\t\treturn CLKRST3_INDEX;\n\tcase 5:\n\t\treturn CLKRST5_INDEX;\n\tcase 6:\n\t\treturn CLKRST6_INDEX;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void __iomem *u8500_prcc_reset_base(struct u8500_prcc_reset *ur,\n\t\t\t\t\t   unsigned long id)\n{\n\tunsigned int prcc_num, index;\n\n\tprcc_num = id / PRCC_PERIPHS_PER_CLUSTER;\n\tindex = prcc_num_to_index(prcc_num);\n\n\tif (index >= ARRAY_SIZE(ur->base))\n\t\treturn NULL;\n\n\treturn ur->base[index];\n}\n\nstatic int u8500_prcc_reset(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long id)\n{\n\tstruct u8500_prcc_reset *ur = to_u8500_prcc_reset(rcdev);\n\tvoid __iomem *base = u8500_prcc_reset_base(ur, id);\n\tunsigned int bit = id % PRCC_PERIPHS_PER_CLUSTER;\n\n\tpr_debug(\"PRCC cycle reset id %lu, bit %u\\n\", id, bit);\n\n\t \n\twritel(BIT(bit), base + PRCC_K_SOFTRST_CLEAR);\n\tudelay(1);\n\twritel(BIT(bit), base + PRCC_K_SOFTRST_SET);\n\tudelay(1);\n\n\treturn 0;\n}\n\nstatic int u8500_prcc_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t\t   unsigned long id)\n{\n\tstruct u8500_prcc_reset *ur = to_u8500_prcc_reset(rcdev);\n\tvoid __iomem *base = u8500_prcc_reset_base(ur, id);\n\tunsigned int bit = id % PRCC_PERIPHS_PER_CLUSTER;\n\n\tpr_debug(\"PRCC assert reset id %lu, bit %u\\n\", id, bit);\n\twritel(BIT(bit), base + PRCC_K_SOFTRST_CLEAR);\n\n\treturn 0;\n}\n\nstatic int u8500_prcc_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t     unsigned long id)\n{\n\tstruct u8500_prcc_reset *ur = to_u8500_prcc_reset(rcdev);\n\tvoid __iomem *base = u8500_prcc_reset_base(ur, id);\n\tunsigned int bit = id % PRCC_PERIPHS_PER_CLUSTER;\n\n\tpr_debug(\"PRCC deassert reset id %lu, bit %u\\n\", id, bit);\n\twritel(BIT(bit), base + PRCC_K_SOFTRST_SET);\n\n\treturn 0;\n}\n\nstatic int u8500_prcc_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t\t   unsigned long id)\n{\n\tstruct u8500_prcc_reset *ur = to_u8500_prcc_reset(rcdev);\n\tvoid __iomem *base = u8500_prcc_reset_base(ur, id);\n\tunsigned int bit = id % PRCC_PERIPHS_PER_CLUSTER;\n\tu32 val;\n\n\tpr_debug(\"PRCC check status on reset line id %lu, bit %u\\n\", id, bit);\n\tval = readl(base + PRCC_K_RST_STATUS);\n\n\t \n\treturn !(val & BIT(bit));\n}\n\nstatic const struct reset_control_ops u8500_prcc_reset_ops = {\n\t.reset = u8500_prcc_reset,\n\t.assert = u8500_prcc_reset_assert,\n\t.deassert = u8500_prcc_reset_deassert,\n\t.status = u8500_prcc_reset_status,\n};\n\nstatic int u8500_prcc_reset_xlate(struct reset_controller_dev *rcdev,\n\t\t\t\t  const struct of_phandle_args *reset_spec)\n{\n\tunsigned int prcc_num, bit;\n\n\tif (reset_spec->args_count != 2)\n\t\treturn -EINVAL;\n\n\tprcc_num = reset_spec->args[0];\n\tbit = reset_spec->args[1];\n\n\tif (prcc_num != 1 && prcc_num != 2 && prcc_num != 3 &&\n\t    prcc_num != 5 && prcc_num != 6) {\n\t\tpr_err(\"%s: invalid PRCC %d\\n\", __func__, prcc_num);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"located reset line %d at PRCC %d bit %d\\n\",\n\t\t PRCC_RESET_LINE(prcc_num, bit), prcc_num, bit);\n\n\treturn PRCC_RESET_LINE(prcc_num, bit);\n}\n\nvoid u8500_prcc_reset_init(struct device_node *np, struct u8500_prcc_reset *ur)\n{\n\tstruct reset_controller_dev *rcdev = &ur->rcdev;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < CLKRST_MAX; i++) {\n\t\tur->base[i] = ioremap(ur->phy_base[i], SZ_4K);\n\t\tif (!ur->base[i])\n\t\t\tpr_err(\"PRCC failed to remap for reset base %d (%08x)\\n\",\n\t\t\t       i, ur->phy_base[i]);\n\t}\n\n\trcdev->owner = THIS_MODULE;\n\trcdev->ops = &u8500_prcc_reset_ops;\n\trcdev->of_node = np;\n\trcdev->of_reset_n_cells = 2;\n\trcdev->of_xlate = u8500_prcc_reset_xlate;\n\n\tret = reset_controller_register(rcdev);\n\tif (ret)\n\t\tpr_err(\"PRCC failed to register reset controller\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}