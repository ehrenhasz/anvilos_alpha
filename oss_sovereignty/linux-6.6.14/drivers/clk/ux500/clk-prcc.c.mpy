{
  "module_name": "clk-prcc.c",
  "hash_id": "e9c5392c1243346167590bae51e7fcf893b0c53af20c303ae5bf971d28a4bddf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ux500/clk-prcc.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/types.h>\n\n#include \"clk.h\"\n\n#define PRCC_PCKEN\t\t\t0x000\n#define PRCC_PCKDIS\t\t\t0x004\n#define PRCC_KCKEN\t\t\t0x008\n#define PRCC_KCKDIS\t\t\t0x00C\n#define PRCC_PCKSR\t\t\t0x010\n#define PRCC_KCKSR\t\t\t0x014\n\n#define to_clk_prcc(_hw) container_of(_hw, struct clk_prcc, hw)\n\nstruct clk_prcc {\n\tstruct clk_hw hw;\n\tvoid __iomem *base;\n\tu32 cg_sel;\n\tint is_enabled;\n};\n\n \n\nstatic int clk_prcc_pclk_enable(struct clk_hw *hw)\n{\n\tstruct clk_prcc *clk = to_clk_prcc(hw);\n\n\twritel(clk->cg_sel, (clk->base + PRCC_PCKEN));\n\twhile (!(readl(clk->base + PRCC_PCKSR) & clk->cg_sel))\n\t\tcpu_relax();\n\n\tclk->is_enabled = 1;\n\treturn 0;\n}\n\nstatic void clk_prcc_pclk_disable(struct clk_hw *hw)\n{\n\tstruct clk_prcc *clk = to_clk_prcc(hw);\n\n\twritel(clk->cg_sel, (clk->base + PRCC_PCKDIS));\n\tclk->is_enabled = 0;\n}\n\nstatic int clk_prcc_kclk_enable(struct clk_hw *hw)\n{\n\tstruct clk_prcc *clk = to_clk_prcc(hw);\n\n\twritel(clk->cg_sel, (clk->base + PRCC_KCKEN));\n\twhile (!(readl(clk->base + PRCC_KCKSR) & clk->cg_sel))\n\t\tcpu_relax();\n\n\tclk->is_enabled = 1;\n\treturn 0;\n}\n\nstatic void clk_prcc_kclk_disable(struct clk_hw *hw)\n{\n\tstruct clk_prcc *clk = to_clk_prcc(hw);\n\n\twritel(clk->cg_sel, (clk->base + PRCC_KCKDIS));\n\tclk->is_enabled = 0;\n}\n\nstatic int clk_prcc_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_prcc *clk = to_clk_prcc(hw);\n\treturn clk->is_enabled;\n}\n\nstatic const struct clk_ops clk_prcc_pclk_ops = {\n\t.enable = clk_prcc_pclk_enable,\n\t.disable = clk_prcc_pclk_disable,\n\t.is_enabled = clk_prcc_is_enabled,\n};\n\nstatic const struct clk_ops clk_prcc_kclk_ops = {\n\t.enable = clk_prcc_kclk_enable,\n\t.disable = clk_prcc_kclk_disable,\n\t.is_enabled = clk_prcc_is_enabled,\n};\n\nstatic struct clk *clk_reg_prcc(const char *name,\n\t\t\t\tconst char *parent_name,\n\t\t\t\tresource_size_t phy_base,\n\t\t\t\tu32 cg_sel,\n\t\t\t\tunsigned long flags,\n\t\t\t\tconst struct clk_ops *clk_prcc_ops)\n{\n\tstruct clk_prcc *clk;\n\tstruct clk_init_data clk_prcc_init;\n\tstruct clk *clk_reg;\n\n\tif (!name) {\n\t\tpr_err(\"clk_prcc: %s invalid arguments passed\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tclk = kzalloc(sizeof(*clk), GFP_KERNEL);\n\tif (!clk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk->base = ioremap(phy_base, SZ_4K);\n\tif (!clk->base)\n\t\tgoto free_clk;\n\n\tclk->cg_sel = cg_sel;\n\tclk->is_enabled = 1;\n\n\tclk_prcc_init.name = name;\n\tclk_prcc_init.ops = clk_prcc_ops;\n\tclk_prcc_init.flags = flags;\n\tclk_prcc_init.parent_names = (parent_name ? &parent_name : NULL);\n\tclk_prcc_init.num_parents = (parent_name ? 1 : 0);\n\tclk->hw.init = &clk_prcc_init;\n\n\tclk_reg = clk_register(NULL, &clk->hw);\n\tif (IS_ERR_OR_NULL(clk_reg))\n\t\tgoto unmap_clk;\n\n\treturn clk_reg;\n\nunmap_clk:\n\tiounmap(clk->base);\nfree_clk:\n\tkfree(clk);\n\tpr_err(\"clk_prcc: %s failed to register clk\\n\", __func__);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstruct clk *clk_reg_prcc_pclk(const char *name,\n\t\t\t      const char *parent_name,\n\t\t\t      resource_size_t phy_base,\n\t\t\t      u32 cg_sel,\n\t\t\t      unsigned long flags)\n{\n\treturn clk_reg_prcc(name, parent_name, phy_base, cg_sel, flags,\n\t\t\t&clk_prcc_pclk_ops);\n}\n\nstruct clk *clk_reg_prcc_kclk(const char *name,\n\t\t\t      const char *parent_name,\n\t\t\t      resource_size_t phy_base,\n\t\t\t      u32 cg_sel,\n\t\t\t      unsigned long flags)\n{\n\treturn clk_reg_prcc(name, parent_name, phy_base, cg_sel, flags,\n\t\t\t&clk_prcc_kclk_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}