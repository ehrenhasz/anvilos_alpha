{
  "module_name": "clk-cdce706.c",
  "hash_id": "7a8281b34ed09d8d40d27689c58a4bdc86bfa59a2447e22b91a098bccf49e8cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-cdce706.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/rational.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define CDCE706_CLKIN_CLOCK\t\t10\n#define CDCE706_CLKIN_SOURCE\t\t11\n#define CDCE706_PLL_M_LOW(pll)\t\t(1 + 3 * (pll))\n#define CDCE706_PLL_N_LOW(pll)\t\t(2 + 3 * (pll))\n#define CDCE706_PLL_HI(pll)\t\t(3 + 3 * (pll))\n#define CDCE706_PLL_MUX\t\t\t3\n#define CDCE706_PLL_FVCO\t\t6\n#define CDCE706_DIVIDER(div)\t\t(13 + (div))\n#define CDCE706_CLKOUT(out)\t\t(19 + (out))\n\n#define CDCE706_CLKIN_CLOCK_MASK\t0x10\n#define CDCE706_CLKIN_SOURCE_SHIFT\t6\n#define CDCE706_CLKIN_SOURCE_MASK\t0xc0\n#define CDCE706_CLKIN_SOURCE_LVCMOS\t0x40\n\n#define CDCE706_PLL_MUX_MASK(pll)\t(0x80 >> (pll))\n#define CDCE706_PLL_LOW_M_MASK\t\t0xff\n#define CDCE706_PLL_LOW_N_MASK\t\t0xff\n#define CDCE706_PLL_HI_M_MASK\t\t0x1\n#define CDCE706_PLL_HI_N_MASK\t\t0x1e\n#define CDCE706_PLL_HI_N_SHIFT\t\t1\n#define CDCE706_PLL_M_MAX\t\t0x1ff\n#define CDCE706_PLL_N_MAX\t\t0xfff\n#define CDCE706_PLL_FVCO_MASK(pll)\t(0x80 >> (pll))\n#define CDCE706_PLL_FREQ_MIN\t\t 80000000\n#define CDCE706_PLL_FREQ_MAX\t\t300000000\n#define CDCE706_PLL_FREQ_HI\t\t180000000\n\n#define CDCE706_DIVIDER_PLL(div)\t(9 + (div) - ((div) > 2) - ((div) > 4))\n#define CDCE706_DIVIDER_PLL_SHIFT(div)\t((div) < 2 ? 5 : 3 * ((div) & 1))\n#define CDCE706_DIVIDER_PLL_MASK(div)\t(0x7 << CDCE706_DIVIDER_PLL_SHIFT(div))\n#define CDCE706_DIVIDER_DIVIDER_MASK\t0x7f\n#define CDCE706_DIVIDER_DIVIDER_MAX\t0x7f\n\n#define CDCE706_CLKOUT_DIVIDER_MASK\t0x7\n#define CDCE706_CLKOUT_ENABLE_MASK\t0x8\n\nstatic const struct regmap_config cdce706_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.val_format_endian = REGMAP_ENDIAN_NATIVE,\n};\n\n#define to_hw_data(phw) (container_of((phw), struct cdce706_hw_data, hw))\n\nstruct cdce706_hw_data {\n\tstruct cdce706_dev_data *dev_data;\n\tunsigned idx;\n\tunsigned parent;\n\tstruct clk_hw hw;\n\tunsigned div;\n\tunsigned mul;\n\tunsigned mux;\n};\n\nstruct cdce706_dev_data {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct clk *clkin_clk[2];\n\tconst char *clkin_name[2];\n\tstruct cdce706_hw_data clkin[1];\n\tstruct cdce706_hw_data pll[3];\n\tstruct cdce706_hw_data divider[6];\n\tstruct cdce706_hw_data clkout[6];\n};\n\nstatic const char * const cdce706_source_name[] = {\n\t\"clk_in0\", \"clk_in1\",\n};\n\nstatic const char * const cdce706_clkin_name[] = {\n\t\"clk_in\",\n};\n\nstatic const char * const cdce706_pll_name[] = {\n\t\"pll1\", \"pll2\", \"pll3\",\n};\n\nstatic const char * const cdce706_divider_parent_name[] = {\n\t\"clk_in\", \"pll1\", \"pll2\", \"pll2\", \"pll3\",\n};\n\nstatic const char *cdce706_divider_name[] = {\n\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\",\n};\n\nstatic const char * const cdce706_clkout_name[] = {\n\t\"clk_out0\", \"clk_out1\", \"clk_out2\", \"clk_out3\", \"clk_out4\", \"clk_out5\",\n};\n\nstatic int cdce706_reg_read(struct cdce706_dev_data *dev_data, unsigned reg,\n\t\t\t    unsigned *val)\n{\n\tint rc = regmap_read(dev_data->regmap, reg | 0x80, val);\n\n\tif (rc < 0)\n\t\tdev_err(&dev_data->client->dev, \"error reading reg %u\", reg);\n\treturn rc;\n}\n\nstatic int cdce706_reg_write(struct cdce706_dev_data *dev_data, unsigned reg,\n\t\t\t     unsigned val)\n{\n\tint rc = regmap_write(dev_data->regmap, reg | 0x80, val);\n\n\tif (rc < 0)\n\t\tdev_err(&dev_data->client->dev, \"error writing reg %u\", reg);\n\treturn rc;\n}\n\nstatic int cdce706_reg_update(struct cdce706_dev_data *dev_data, unsigned reg,\n\t\t\t      unsigned mask, unsigned val)\n{\n\tint rc = regmap_update_bits(dev_data->regmap, reg | 0x80, mask, val);\n\n\tif (rc < 0)\n\t\tdev_err(&dev_data->client->dev, \"error updating reg %u\", reg);\n\treturn rc;\n}\n\nstatic int cdce706_clkin_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct cdce706_hw_data *hwd = to_hw_data(hw);\n\n\thwd->parent = index;\n\treturn 0;\n}\n\nstatic u8 cdce706_clkin_get_parent(struct clk_hw *hw)\n{\n\tstruct cdce706_hw_data *hwd = to_hw_data(hw);\n\n\treturn hwd->parent;\n}\n\nstatic const struct clk_ops cdce706_clkin_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.set_parent = cdce706_clkin_set_parent,\n\t.get_parent = cdce706_clkin_get_parent,\n};\n\nstatic unsigned long cdce706_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct cdce706_hw_data *hwd = to_hw_data(hw);\n\n\tdev_dbg(&hwd->dev_data->client->dev,\n\t\t\"%s, pll: %d, mux: %d, mul: %u, div: %u\\n\",\n\t\t__func__, hwd->idx, hwd->mux, hwd->mul, hwd->div);\n\n\tif (!hwd->mux) {\n\t\tif (hwd->div && hwd->mul) {\n\t\t\tu64 res = (u64)parent_rate * hwd->mul;\n\n\t\t\tdo_div(res, hwd->div);\n\t\t\treturn res;\n\t\t}\n\t} else {\n\t\tif (hwd->div)\n\t\t\treturn parent_rate / hwd->div;\n\t}\n\treturn 0;\n}\n\nstatic long cdce706_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long *parent_rate)\n{\n\tstruct cdce706_hw_data *hwd = to_hw_data(hw);\n\tunsigned long mul, div;\n\tu64 res;\n\n\tdev_dbg(&hwd->dev_data->client->dev,\n\t\t\"%s, rate: %lu, parent_rate: %lu\\n\",\n\t\t__func__, rate, *parent_rate);\n\n\trational_best_approximation(rate, *parent_rate,\n\t\t\t\t    CDCE706_PLL_N_MAX, CDCE706_PLL_M_MAX,\n\t\t\t\t    &mul, &div);\n\thwd->mul = mul;\n\thwd->div = div;\n\n\tdev_dbg(&hwd->dev_data->client->dev,\n\t\t\"%s, pll: %d, mul: %lu, div: %lu\\n\",\n\t\t__func__, hwd->idx, mul, div);\n\n\tres = (u64)*parent_rate * hwd->mul;\n\tdo_div(res, hwd->div);\n\treturn res;\n}\n\nstatic int cdce706_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct cdce706_hw_data *hwd = to_hw_data(hw);\n\tunsigned long mul = hwd->mul, div = hwd->div;\n\tint err;\n\n\tdev_dbg(&hwd->dev_data->client->dev,\n\t\t\"%s, pll: %d, mul: %lu, div: %lu\\n\",\n\t\t__func__, hwd->idx, mul, div);\n\n\terr = cdce706_reg_update(hwd->dev_data,\n\t\t\t\t CDCE706_PLL_HI(hwd->idx),\n\t\t\t\t CDCE706_PLL_HI_M_MASK | CDCE706_PLL_HI_N_MASK,\n\t\t\t\t ((div >> 8) & CDCE706_PLL_HI_M_MASK) |\n\t\t\t\t ((mul >> (8 - CDCE706_PLL_HI_N_SHIFT)) &\n\t\t\t\t  CDCE706_PLL_HI_N_MASK));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = cdce706_reg_write(hwd->dev_data,\n\t\t\t\tCDCE706_PLL_M_LOW(hwd->idx),\n\t\t\t\tdiv & CDCE706_PLL_LOW_M_MASK);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = cdce706_reg_write(hwd->dev_data,\n\t\t\t\tCDCE706_PLL_N_LOW(hwd->idx),\n\t\t\t\tmul & CDCE706_PLL_LOW_N_MASK);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = cdce706_reg_update(hwd->dev_data,\n\t\t\t\t CDCE706_PLL_FVCO,\n\t\t\t\t CDCE706_PLL_FVCO_MASK(hwd->idx),\n\t\t\t\t rate > CDCE706_PLL_FREQ_HI ?\n\t\t\t\t CDCE706_PLL_FVCO_MASK(hwd->idx) : 0);\n\treturn err;\n}\n\nstatic const struct clk_ops cdce706_pll_ops = {\n\t.recalc_rate = cdce706_pll_recalc_rate,\n\t.round_rate = cdce706_pll_round_rate,\n\t.set_rate = cdce706_pll_set_rate,\n};\n\nstatic int cdce706_divider_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct cdce706_hw_data *hwd = to_hw_data(hw);\n\n\tif (hwd->parent == index)\n\t\treturn 0;\n\thwd->parent = index;\n\treturn cdce706_reg_update(hwd->dev_data,\n\t\t\t\t  CDCE706_DIVIDER_PLL(hwd->idx),\n\t\t\t\t  CDCE706_DIVIDER_PLL_MASK(hwd->idx),\n\t\t\t\t  index << CDCE706_DIVIDER_PLL_SHIFT(hwd->idx));\n}\n\nstatic u8 cdce706_divider_get_parent(struct clk_hw *hw)\n{\n\tstruct cdce706_hw_data *hwd = to_hw_data(hw);\n\n\treturn hwd->parent;\n}\n\nstatic unsigned long cdce706_divider_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct cdce706_hw_data *hwd = to_hw_data(hw);\n\n\tdev_dbg(&hwd->dev_data->client->dev,\n\t\t\"%s, divider: %d, div: %u\\n\",\n\t\t__func__, hwd->idx, hwd->div);\n\tif (hwd->div)\n\t\treturn parent_rate / hwd->div;\n\treturn 0;\n}\n\nstatic int cdce706_divider_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t  struct clk_rate_request *req)\n{\n\tstruct cdce706_hw_data *hwd = to_hw_data(hw);\n\tstruct cdce706_dev_data *cdce = hwd->dev_data;\n\tunsigned long rate = req->rate;\n\tunsigned long mul, div;\n\n\tdev_dbg(&hwd->dev_data->client->dev,\n\t\t\"%s, rate: %lu, parent_rate: %lu\\n\",\n\t\t__func__, rate, req->best_parent_rate);\n\n\trational_best_approximation(rate, req->best_parent_rate,\n\t\t\t\t    1, CDCE706_DIVIDER_DIVIDER_MAX,\n\t\t\t\t    &mul, &div);\n\tif (!mul)\n\t\tdiv = CDCE706_DIVIDER_DIVIDER_MAX;\n\n\tif (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) {\n\t\tunsigned long best_diff = rate;\n\t\tunsigned long best_div = 0;\n\t\tstruct clk *gp_clk = cdce->clkin_clk[cdce->clkin[0].parent];\n\t\tunsigned long gp_rate = gp_clk ? clk_get_rate(gp_clk) : 0;\n\n\t\tfor (div = CDCE706_PLL_FREQ_MIN / rate; best_diff &&\n\t\t     div <= CDCE706_PLL_FREQ_MAX / rate; ++div) {\n\t\t\tunsigned long n, m;\n\t\t\tunsigned long diff;\n\t\t\tunsigned long div_rate;\n\t\t\tu64 div_rate64;\n\n\t\t\tif (rate * div < CDCE706_PLL_FREQ_MIN)\n\t\t\t\tcontinue;\n\n\t\t\trational_best_approximation(rate * div, gp_rate,\n\t\t\t\t\t\t    CDCE706_PLL_N_MAX,\n\t\t\t\t\t\t    CDCE706_PLL_M_MAX,\n\t\t\t\t\t\t    &n, &m);\n\t\t\tdiv_rate64 = (u64)gp_rate * n;\n\t\t\tdo_div(div_rate64, m);\n\t\t\tdo_div(div_rate64, div);\n\t\t\tdiv_rate = div_rate64;\n\t\t\tdiff = max(div_rate, rate) - min(div_rate, rate);\n\n\t\t\tif (diff < best_diff) {\n\t\t\t\tbest_diff = diff;\n\t\t\t\tbest_div = div;\n\t\t\t\tdev_dbg(&hwd->dev_data->client->dev,\n\t\t\t\t\t\"%s, %lu * %lu / %lu / %lu = %lu\\n\",\n\t\t\t\t\t__func__, gp_rate, n, m, div, div_rate);\n\t\t\t}\n\t\t}\n\n\t\tdiv = best_div;\n\n\t\tdev_dbg(&hwd->dev_data->client->dev,\n\t\t\t\"%s, altering parent rate: %lu -> %lu\\n\",\n\t\t\t__func__, req->best_parent_rate, rate * div);\n\t\treq->best_parent_rate = rate * div;\n\t}\n\thwd->div = div;\n\n\tdev_dbg(&hwd->dev_data->client->dev,\n\t\t\"%s, divider: %d, div: %lu\\n\",\n\t\t__func__, hwd->idx, div);\n\n\treq->rate = req->best_parent_rate / div;\n\treturn 0;\n}\n\nstatic int cdce706_divider_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct cdce706_hw_data *hwd = to_hw_data(hw);\n\n\tdev_dbg(&hwd->dev_data->client->dev,\n\t\t\"%s, divider: %d, div: %u\\n\",\n\t\t__func__, hwd->idx, hwd->div);\n\n\treturn cdce706_reg_update(hwd->dev_data,\n\t\t\t\t  CDCE706_DIVIDER(hwd->idx),\n\t\t\t\t  CDCE706_DIVIDER_DIVIDER_MASK,\n\t\t\t\t  hwd->div);\n}\n\nstatic const struct clk_ops cdce706_divider_ops = {\n\t.set_parent = cdce706_divider_set_parent,\n\t.get_parent = cdce706_divider_get_parent,\n\t.recalc_rate = cdce706_divider_recalc_rate,\n\t.determine_rate = cdce706_divider_determine_rate,\n\t.set_rate = cdce706_divider_set_rate,\n};\n\nstatic int cdce706_clkout_prepare(struct clk_hw *hw)\n{\n\tstruct cdce706_hw_data *hwd = to_hw_data(hw);\n\n\treturn cdce706_reg_update(hwd->dev_data, CDCE706_CLKOUT(hwd->idx),\n\t\t\t\t  CDCE706_CLKOUT_ENABLE_MASK,\n\t\t\t\t  CDCE706_CLKOUT_ENABLE_MASK);\n}\n\nstatic void cdce706_clkout_unprepare(struct clk_hw *hw)\n{\n\tstruct cdce706_hw_data *hwd = to_hw_data(hw);\n\n\tcdce706_reg_update(hwd->dev_data, CDCE706_CLKOUT(hwd->idx),\n\t\t\t   CDCE706_CLKOUT_ENABLE_MASK, 0);\n}\n\nstatic int cdce706_clkout_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct cdce706_hw_data *hwd = to_hw_data(hw);\n\n\tif (hwd->parent == index)\n\t\treturn 0;\n\thwd->parent = index;\n\treturn cdce706_reg_update(hwd->dev_data,\n\t\t\t\t  CDCE706_CLKOUT(hwd->idx),\n\t\t\t\t  CDCE706_CLKOUT_ENABLE_MASK, index);\n}\n\nstatic u8 cdce706_clkout_get_parent(struct clk_hw *hw)\n{\n\tstruct cdce706_hw_data *hwd = to_hw_data(hw);\n\n\treturn hwd->parent;\n}\n\nstatic unsigned long cdce706_clkout_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\treturn parent_rate;\n}\n\nstatic int cdce706_clkout_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t struct clk_rate_request *req)\n{\n\treq->best_parent_rate = req->rate;\n\n\treturn 0;\n}\n\nstatic int cdce706_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\treturn 0;\n}\n\nstatic const struct clk_ops cdce706_clkout_ops = {\n\t.prepare = cdce706_clkout_prepare,\n\t.unprepare = cdce706_clkout_unprepare,\n\t.set_parent = cdce706_clkout_set_parent,\n\t.get_parent = cdce706_clkout_get_parent,\n\t.recalc_rate = cdce706_clkout_recalc_rate,\n\t.determine_rate = cdce706_clkout_determine_rate,\n\t.set_rate = cdce706_clkout_set_rate,\n};\n\nstatic int cdce706_register_hw(struct cdce706_dev_data *cdce,\n\t\t\t       struct cdce706_hw_data *hw, unsigned num_hw,\n\t\t\t       const char * const *clk_names,\n\t\t\t       struct clk_init_data *init)\n{\n\tunsigned i;\n\tint ret;\n\n\tfor (i = 0; i < num_hw; ++i, ++hw) {\n\t\tinit->name = clk_names[i];\n\t\thw->dev_data = cdce;\n\t\thw->idx = i;\n\t\thw->hw.init = init;\n\t\tret = devm_clk_hw_register(&cdce->client->dev,\n\t\t\t\t\t    &hw->hw);\n\t\tif (ret) {\n\t\t\tdev_err(&cdce->client->dev, \"Failed to register %s\\n\",\n\t\t\t\tclk_names[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int cdce706_register_clkin(struct cdce706_dev_data *cdce)\n{\n\tstruct clk_init_data init = {\n\t\t.ops = &cdce706_clkin_ops,\n\t\t.parent_names = cdce->clkin_name,\n\t\t.num_parents = ARRAY_SIZE(cdce->clkin_name),\n\t};\n\tunsigned i;\n\tint ret;\n\tunsigned clock, source;\n\n\tfor (i = 0; i < ARRAY_SIZE(cdce->clkin_name); ++i) {\n\t\tstruct clk *parent = devm_clk_get(&cdce->client->dev,\n\t\t\t\t\t\t  cdce706_source_name[i]);\n\n\t\tif (IS_ERR(parent)) {\n\t\t\tcdce->clkin_name[i] = cdce706_source_name[i];\n\t\t} else {\n\t\t\tcdce->clkin_name[i] = __clk_get_name(parent);\n\t\t\tcdce->clkin_clk[i] = parent;\n\t\t}\n\t}\n\n\tret = cdce706_reg_read(cdce, CDCE706_CLKIN_SOURCE, &source);\n\tif (ret < 0)\n\t\treturn ret;\n\tif ((source & CDCE706_CLKIN_SOURCE_MASK) ==\n\t    CDCE706_CLKIN_SOURCE_LVCMOS) {\n\t\tret = cdce706_reg_read(cdce, CDCE706_CLKIN_CLOCK, &clock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcdce->clkin[0].parent = !!(clock & CDCE706_CLKIN_CLOCK_MASK);\n\t}\n\n\tret = cdce706_register_hw(cdce, cdce->clkin,\n\t\t\t\t  ARRAY_SIZE(cdce->clkin),\n\t\t\t\t  cdce706_clkin_name, &init);\n\treturn ret;\n}\n\nstatic int cdce706_register_plls(struct cdce706_dev_data *cdce)\n{\n\tstruct clk_init_data init = {\n\t\t.ops = &cdce706_pll_ops,\n\t\t.parent_names = cdce706_clkin_name,\n\t\t.num_parents = ARRAY_SIZE(cdce706_clkin_name),\n\t};\n\tunsigned i;\n\tint ret;\n\tunsigned mux;\n\n\tret = cdce706_reg_read(cdce, CDCE706_PLL_MUX, &mux);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(cdce->pll); ++i) {\n\t\tunsigned m, n, v;\n\n\t\tret = cdce706_reg_read(cdce, CDCE706_PLL_M_LOW(i), &m);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = cdce706_reg_read(cdce, CDCE706_PLL_N_LOW(i), &n);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = cdce706_reg_read(cdce, CDCE706_PLL_HI(i), &v);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcdce->pll[i].div = m | ((v & CDCE706_PLL_HI_M_MASK) << 8);\n\t\tcdce->pll[i].mul = n | ((v & CDCE706_PLL_HI_N_MASK) <<\n\t\t\t\t\t(8 - CDCE706_PLL_HI_N_SHIFT));\n\t\tcdce->pll[i].mux = mux & CDCE706_PLL_MUX_MASK(i);\n\t\tdev_dbg(&cdce->client->dev,\n\t\t\t\"%s: i: %u, div: %u, mul: %u, mux: %d\\n\", __func__, i,\n\t\t\tcdce->pll[i].div, cdce->pll[i].mul, cdce->pll[i].mux);\n\t}\n\n\tret = cdce706_register_hw(cdce, cdce->pll,\n\t\t\t\t  ARRAY_SIZE(cdce->pll),\n\t\t\t\t  cdce706_pll_name, &init);\n\treturn ret;\n}\n\nstatic int cdce706_register_dividers(struct cdce706_dev_data *cdce)\n{\n\tstruct clk_init_data init = {\n\t\t.ops = &cdce706_divider_ops,\n\t\t.parent_names = cdce706_divider_parent_name,\n\t\t.num_parents = ARRAY_SIZE(cdce706_divider_parent_name),\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t};\n\tunsigned i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(cdce->divider); ++i) {\n\t\tunsigned val;\n\n\t\tret = cdce706_reg_read(cdce, CDCE706_DIVIDER_PLL(i), &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcdce->divider[i].parent =\n\t\t\t(val & CDCE706_DIVIDER_PLL_MASK(i)) >>\n\t\t\tCDCE706_DIVIDER_PLL_SHIFT(i);\n\n\t\tret = cdce706_reg_read(cdce, CDCE706_DIVIDER(i), &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcdce->divider[i].div = val & CDCE706_DIVIDER_DIVIDER_MASK;\n\t\tdev_dbg(&cdce->client->dev,\n\t\t\t\"%s: i: %u, parent: %u, div: %u\\n\", __func__, i,\n\t\t\tcdce->divider[i].parent, cdce->divider[i].div);\n\t}\n\n\tret = cdce706_register_hw(cdce, cdce->divider,\n\t\t\t\t  ARRAY_SIZE(cdce->divider),\n\t\t\t\t  cdce706_divider_name, &init);\n\treturn ret;\n}\n\nstatic int cdce706_register_clkouts(struct cdce706_dev_data *cdce)\n{\n\tstruct clk_init_data init = {\n\t\t.ops = &cdce706_clkout_ops,\n\t\t.parent_names = cdce706_divider_name,\n\t\t.num_parents = ARRAY_SIZE(cdce706_divider_name),\n\t\t.flags = CLK_SET_RATE_PARENT,\n\t};\n\tunsigned i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(cdce->clkout); ++i) {\n\t\tunsigned val;\n\n\t\tret = cdce706_reg_read(cdce, CDCE706_CLKOUT(i), &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcdce->clkout[i].parent = val & CDCE706_CLKOUT_DIVIDER_MASK;\n\t\tdev_dbg(&cdce->client->dev,\n\t\t\t\"%s: i: %u, parent: %u\\n\", __func__, i,\n\t\t\tcdce->clkout[i].parent);\n\t}\n\n\treturn cdce706_register_hw(cdce, cdce->clkout,\n\t\t\t\t   ARRAY_SIZE(cdce->clkout),\n\t\t\t\t   cdce706_clkout_name, &init);\n}\n\nstatic struct clk_hw *\nof_clk_cdce_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct cdce706_dev_data *cdce = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= ARRAY_SIZE(cdce->clkout)) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &cdce->clkout[idx].hw;\n}\n\nstatic int cdce706_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct cdce706_dev_data *cdce;\n\tint ret;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tcdce = devm_kzalloc(&client->dev, sizeof(*cdce), GFP_KERNEL);\n\tif (!cdce)\n\t\treturn -ENOMEM;\n\n\tcdce->client = client;\n\tcdce->regmap = devm_regmap_init_i2c(client, &cdce706_regmap_config);\n\tif (IS_ERR(cdce->regmap)) {\n\t\tdev_err(&client->dev, \"Failed to initialize regmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ti2c_set_clientdata(client, cdce);\n\n\tret = cdce706_register_clkin(cdce);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = cdce706_register_plls(cdce);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = cdce706_register_dividers(cdce);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = cdce706_register_clkouts(cdce);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn devm_of_clk_add_hw_provider(&client->dev, of_clk_cdce_get,\n\t\t\t\t\t   cdce);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id cdce706_dt_match[] = {\n\t{ .compatible = \"ti,cdce706\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, cdce706_dt_match);\n#endif\n\nstatic const struct i2c_device_id cdce706_id[] = {\n\t{ \"cdce706\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, cdce706_id);\n\nstatic struct i2c_driver cdce706_i2c_driver = {\n\t.driver\t= {\n\t\t.name\t= \"cdce706\",\n\t\t.of_match_table = of_match_ptr(cdce706_dt_match),\n\t},\n\t.probe\t\t= cdce706_probe,\n\t.id_table\t= cdce706_id,\n};\nmodule_i2c_driver(cdce706_i2c_driver);\n\nMODULE_AUTHOR(\"Max Filippov <jcmvbkbc@gmail.com>\");\nMODULE_DESCRIPTION(\"TI CDCE 706 clock synthesizer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}