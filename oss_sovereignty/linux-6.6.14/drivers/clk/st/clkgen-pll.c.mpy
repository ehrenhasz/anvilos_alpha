{
  "module_name": "clkgen-pll.c",
  "hash_id": "f5511a8a939f2d0d50e8b1f1306bde0594ffc15fa02eb948e4f773f4a817ccb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/st/clkgen-pll.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/of_address.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/iopoll.h>\n\n#include \"clkgen.h\"\n\nstatic DEFINE_SPINLOCK(clkgena_c32_odf_lock);\nDEFINE_SPINLOCK(clkgen_a9_lock);\n\n \n#define C32_NDIV_MASK (0xff)\n#define C32_IDF_MASK (0x7)\n#define C32_ODF_MASK (0x3f)\n#define C32_LDF_MASK (0x7f)\n#define C32_CP_MASK (0x1f)\n\n#define C32_MAX_ODFS (4)\n\n \n#define C28_NDIV_MASK (0xff)\n#define C28_IDF_MASK (0x7)\n#define C28_ODF_MASK (0x3f)\n\nstruct clkgen_pll_data {\n\tstruct clkgen_field pdn_status;\n\tstruct clkgen_field pdn_ctrl;\n\tstruct clkgen_field locked_status;\n\tstruct clkgen_field mdiv;\n\tstruct clkgen_field ndiv;\n\tstruct clkgen_field pdiv;\n\tstruct clkgen_field idf;\n\tstruct clkgen_field ldf;\n\tstruct clkgen_field cp;\n\tunsigned int num_odfs;\n\tstruct clkgen_field odf[C32_MAX_ODFS];\n\tstruct clkgen_field odf_gate[C32_MAX_ODFS];\n\tbool switch2pll_en;\n\tstruct clkgen_field switch2pll;\n\tspinlock_t *lock;\n\tconst struct clk_ops *ops;\n};\n\nstruct clkgen_clk_out {\n\tconst char *name;\n\tunsigned long flags;\n};\n\nstruct clkgen_pll_data_clks {\n\tstruct clkgen_pll_data *data;\n\tconst struct clkgen_clk_out *outputs;\n};\n\n\nstatic const struct clk_ops stm_pll3200c32_ops;\nstatic const struct clk_ops stm_pll3200c32_a9_ops;\nstatic const struct clk_ops stm_pll4600c28_ops;\n\nstatic const struct clkgen_pll_data st_pll3200c32_cx_0 = {\n\t \n\t.pdn_status\t= CLKGEN_FIELD(0x2a0,\t0x1,\t\t\t8),\n\t.pdn_ctrl\t= CLKGEN_FIELD(0x2a0,\t0x1,\t\t\t8),\n\t.locked_status\t= CLKGEN_FIELD(0x2a0,\t0x1,\t\t\t24),\n\t.ndiv\t\t= CLKGEN_FIELD(0x2a4,\tC32_NDIV_MASK,\t\t16),\n\t.idf\t\t= CLKGEN_FIELD(0x2a4,\tC32_IDF_MASK,\t\t0x0),\n\t.num_odfs = 1,\n\t.odf\t\t= { CLKGEN_FIELD(0x2b4, C32_ODF_MASK,\t\t0) },\n\t.odf_gate\t= { CLKGEN_FIELD(0x2b4, 0x1,\t\t\t6) },\n\t.ops\t\t= &stm_pll3200c32_ops,\n};\n\nstatic const struct clkgen_pll_data_clks st_pll3200c32_cx_0_legacy_data = {\n\t.data\t= (struct clkgen_pll_data *)&st_pll3200c32_cx_0,\n};\n\nstatic const struct clkgen_clk_out st_pll3200c32_ax_0_clks[] = {\n\t{ .name = \"clk-s-a0-pll-odf-0\", },\n};\n\nstatic const struct clkgen_pll_data_clks st_pll3200c32_a0_data = {\n\t.data\t\t= (struct clkgen_pll_data *)&st_pll3200c32_cx_0,\n\t.outputs\t= st_pll3200c32_ax_0_clks,\n};\n\nstatic const struct clkgen_clk_out st_pll3200c32_cx_0_clks[] = {\n\t{ .name = \"clk-s-c0-pll0-odf-0\", },\n};\n\nstatic const struct clkgen_pll_data_clks st_pll3200c32_c0_data = {\n\t.data\t\t= (struct clkgen_pll_data *)&st_pll3200c32_cx_0,\n\t.outputs\t= st_pll3200c32_cx_0_clks,\n};\n\nstatic const struct clkgen_pll_data st_pll3200c32_cx_1 = {\n\t \n\t.pdn_status\t= CLKGEN_FIELD(0x2c8,\t0x1,\t\t\t8),\n\t.pdn_ctrl\t= CLKGEN_FIELD(0x2c8,\t0x1,\t\t\t8),\n\t.locked_status\t= CLKGEN_FIELD(0x2c8,\t0x1,\t\t\t24),\n\t.ndiv\t\t= CLKGEN_FIELD(0x2cc,\tC32_NDIV_MASK,\t\t16),\n\t.idf\t\t= CLKGEN_FIELD(0x2cc,\tC32_IDF_MASK,\t\t0x0),\n\t.num_odfs = 1,\n\t.odf\t\t= { CLKGEN_FIELD(0x2dc, C32_ODF_MASK,\t\t0) },\n\t.odf_gate\t= { CLKGEN_FIELD(0x2dc, 0x1,\t\t\t6) },\n\t.ops\t\t= &stm_pll3200c32_ops,\n};\n\nstatic const struct clkgen_pll_data_clks st_pll3200c32_cx_1_legacy_data = {\n\t.data\t= (struct clkgen_pll_data *)&st_pll3200c32_cx_1,\n};\n\nstatic const struct clkgen_clk_out st_pll3200c32_cx_1_clks[] = {\n\t{ .name = \"clk-s-c0-pll1-odf-0\", },\n};\n\nstatic const struct clkgen_pll_data_clks st_pll3200c32_c1_data = {\n\t.data\t\t= (struct clkgen_pll_data *)&st_pll3200c32_cx_1,\n\t.outputs\t= st_pll3200c32_cx_1_clks,\n};\n\nstatic const struct clkgen_pll_data st_pll3200c32_407_a9 = {\n\t \n\t.pdn_status\t= CLKGEN_FIELD(0x1a8,\t0x1,\t\t\t0),\n\t.pdn_ctrl\t= CLKGEN_FIELD(0x1a8,\t0x1,\t\t\t0),\n\t.locked_status\t= CLKGEN_FIELD(0x87c,\t0x1,\t\t\t0),\n\t.ndiv\t\t= CLKGEN_FIELD(0x1b0,\tC32_NDIV_MASK,\t\t0),\n\t.idf\t\t= CLKGEN_FIELD(0x1a8,\tC32_IDF_MASK,\t\t25),\n\t.num_odfs = 1,\n\t.odf\t\t= { CLKGEN_FIELD(0x1b0, C32_ODF_MASK,\t\t8) },\n\t.odf_gate\t= { CLKGEN_FIELD(0x1ac, 0x1,\t\t\t28) },\n\t.switch2pll_en\t= true,\n\t.cp\t\t= CLKGEN_FIELD(0x1a8,\tC32_CP_MASK,\t\t1),\n\t.switch2pll\t= CLKGEN_FIELD(0x1a4,\t0x1,\t\t\t1),\n\t.lock = &clkgen_a9_lock,\n\t.ops\t\t= &stm_pll3200c32_a9_ops,\n};\n\nstatic const struct clkgen_clk_out st_pll3200c32_407_a9_clks[] = {\n\t{ .name = \"clockgen-a9-pll-odf\", },\n};\n\nstatic const struct clkgen_pll_data_clks st_pll3200c32_407_a9_data = {\n\t.data\t\t= (struct clkgen_pll_data *)&st_pll3200c32_407_a9,\n\t.outputs\t= st_pll3200c32_407_a9_clks,\n};\n\nstatic struct clkgen_pll_data st_pll4600c28_418_a9 = {\n\t \n\t.pdn_status\t= CLKGEN_FIELD(0x1a8,\t0x1,\t\t\t0),\n\t.pdn_ctrl\t= CLKGEN_FIELD(0x1a8,\t0x1,\t\t\t0),\n\t.locked_status\t= CLKGEN_FIELD(0x87c,\t0x1,\t\t\t0),\n\t.ndiv\t\t= CLKGEN_FIELD(0x1b0,\tC28_NDIV_MASK,\t\t0),\n\t.idf\t\t= CLKGEN_FIELD(0x1a8,\tC28_IDF_MASK,\t\t25),\n\t.num_odfs = 1,\n\t.odf\t\t= { CLKGEN_FIELD(0x1b0, C28_ODF_MASK,\t\t8) },\n\t.odf_gate\t= { CLKGEN_FIELD(0x1ac, 0x1,\t\t\t28) },\n\t.switch2pll_en\t= true,\n\t.switch2pll\t= CLKGEN_FIELD(0x1a4,\t0x1,\t\t\t1),\n\t.lock\t\t= &clkgen_a9_lock,\n\t.ops\t\t= &stm_pll4600c28_ops,\n};\n\nstatic const struct clkgen_clk_out st_pll4600c28_418_a9_clks[] = {\n\t{ .name = \"clockgen-a9-pll-odf\", },\n};\n\nstatic const struct clkgen_pll_data_clks st_pll4600c28_418_a9_data = {\n\t.data\t\t= (struct clkgen_pll_data *)&st_pll4600c28_418_a9,\n\t.outputs\t= st_pll4600c28_418_a9_clks,\n};\n\n \n\n \nstruct clkgen_pll {\n\tstruct clk_hw\t\thw;\n\tstruct clkgen_pll_data\t*data;\n\tvoid __iomem\t\t*regs_base;\n\tspinlock_t\t*lock;\n\n\tu32 ndiv;\n\tu32 idf;\n\tu32 cp;\n};\n\n#define to_clkgen_pll(_hw) container_of(_hw, struct clkgen_pll, hw)\n\nstruct stm_pll {\n\tunsigned long mdiv;\n\tunsigned long ndiv;\n\tunsigned long pdiv;\n\tunsigned long odf;\n\tunsigned long idf;\n\tunsigned long ldf;\n\tunsigned long cp;\n};\n\nstatic int clkgen_pll_is_locked(struct clk_hw *hw)\n{\n\tstruct clkgen_pll *pll = to_clkgen_pll(hw);\n\tu32 locked = CLKGEN_READ(pll, locked_status);\n\n\treturn !!locked;\n}\n\nstatic int clkgen_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct clkgen_pll *pll = to_clkgen_pll(hw);\n\tu32 poweroff = CLKGEN_READ(pll, pdn_status);\n\treturn !poweroff;\n}\n\nstatic int __clkgen_pll_enable(struct clk_hw *hw)\n{\n\tstruct clkgen_pll *pll = to_clkgen_pll(hw);\n\tvoid __iomem *base =  pll->regs_base;\n\tstruct clkgen_field *field = &pll->data->locked_status;\n\tint ret = 0;\n\tu32 reg;\n\n\tif (clkgen_pll_is_enabled(hw))\n\t\treturn 0;\n\n\tCLKGEN_WRITE(pll, pdn_ctrl, 0);\n\n\tret = readl_relaxed_poll_timeout(base + field->offset, reg,\n\t\t\t!!((reg >> field->shift) & field->mask),  0, 10000);\n\n\tif (!ret) {\n\t\tif (pll->data->switch2pll_en)\n\t\t\tCLKGEN_WRITE(pll, switch2pll, 0);\n\n\t\tpr_debug(\"%s:%s enabled\\n\", __clk_get_name(hw->clk), __func__);\n\t}\n\n\treturn ret;\n}\n\nstatic int clkgen_pll_enable(struct clk_hw *hw)\n{\n\tstruct clkgen_pll *pll = to_clkgen_pll(hw);\n\tunsigned long flags = 0;\n\tint ret = 0;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\tret = __clkgen_pll_enable(hw);\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\treturn ret;\n}\n\nstatic void __clkgen_pll_disable(struct clk_hw *hw)\n{\n\tstruct clkgen_pll *pll = to_clkgen_pll(hw);\n\n\tif (!clkgen_pll_is_enabled(hw))\n\t\treturn;\n\n\tif (pll->data->switch2pll_en)\n\t\tCLKGEN_WRITE(pll, switch2pll, 1);\n\n\tCLKGEN_WRITE(pll, pdn_ctrl, 1);\n\n\tpr_debug(\"%s:%s disabled\\n\", __clk_get_name(hw->clk), __func__);\n}\n\nstatic void clkgen_pll_disable(struct clk_hw *hw)\n{\n\tstruct clkgen_pll *pll = to_clkgen_pll(hw);\n\tunsigned long flags = 0;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\t__clkgen_pll_disable(hw);\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n}\n\nstatic int clk_pll3200c32_get_params(unsigned long input, unsigned long output,\n\t\t\t  struct stm_pll *pll)\n{\n\tunsigned long i, n;\n\tunsigned long deviation = ~0;\n\tunsigned long new_freq;\n\tlong new_deviation;\n\t \n\tstatic const unsigned char cp_table[] = {\n\t\t48, 56, 64, 72, 80, 88, 96, 104, 112, 120,\n\t\t128, 136, 144, 152, 160, 168, 176, 184, 192\n\t};\n\n\t \n\tif (output < 800000000 || output > 1600000000)\n\t\treturn -EINVAL;\n\n\tinput /= 1000;\n\toutput /= 1000;\n\n\tfor (i = 1; i <= 7 && deviation; i++) {\n\t\tn = i * output / (2 * input);\n\n\t\t \n\t\tif (n < 8)\n\t\t\tcontinue;\n\t\tif (n > 200)\n\t\t\tbreak;\n\n\t\tnew_freq = (input * 2 * n) / i;\n\n\t\tnew_deviation = abs(new_freq - output);\n\n\t\tif (!new_deviation || new_deviation < deviation) {\n\t\t\tpll->idf  = i;\n\t\t\tpll->ndiv = n;\n\t\t\tdeviation = new_deviation;\n\t\t}\n\t}\n\n\tif (deviation == ~0)  \n\t\treturn -EINVAL;\n\n\t \n\tfor (pll->cp = 6; pll->ndiv > cp_table[pll->cp-6]; (pll->cp)++)\n\t\t;\n\n\treturn 0;\n}\n\nstatic int clk_pll3200c32_get_rate(unsigned long input, struct stm_pll *pll,\n\t\t\tunsigned long *rate)\n{\n\tif (!pll->idf)\n\t\tpll->idf = 1;\n\n\t*rate = ((2 * (input / 1000) * pll->ndiv) / pll->idf) * 1000;\n\n\treturn 0;\n}\n\nstatic unsigned long recalc_stm_pll3200c32(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clkgen_pll *pll = to_clkgen_pll(hw);\n\tunsigned long ndiv, idf;\n\tunsigned long rate = 0;\n\n\tif (!clkgen_pll_is_enabled(hw) || !clkgen_pll_is_locked(hw))\n\t\treturn 0;\n\n\tndiv = CLKGEN_READ(pll, ndiv);\n\tidf = CLKGEN_READ(pll, idf);\n\n\tif (idf)\n\t\t \n\t\trate = ((2 * (parent_rate/1000) * ndiv) / idf) * 1000;\n\n\tpr_debug(\"%s:%s rate %lu\\n\", clk_hw_get_name(hw), __func__, rate);\n\n\treturn rate;\n}\n\nstatic long round_rate_stm_pll3200c32(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long *prate)\n{\n\tstruct stm_pll params;\n\n\tif (!clk_pll3200c32_get_params(*prate, rate, &params))\n\t\tclk_pll3200c32_get_rate(*prate, &params, &rate);\n\telse {\n\t\tpr_debug(\"%s: %s rate %ld Invalid\\n\", __func__,\n\t\t\t __clk_get_name(hw->clk), rate);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"%s: %s new rate %ld [ndiv=%u] [idf=%u]\\n\",\n\t\t __func__, __clk_get_name(hw->clk),\n\t\t rate, (unsigned int)params.ndiv,\n\t\t (unsigned int)params.idf);\n\n\treturn rate;\n}\n\nstatic int set_rate_stm_pll3200c32(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clkgen_pll *pll = to_clkgen_pll(hw);\n\tstruct stm_pll params;\n\tlong hwrate = 0;\n\tunsigned long flags = 0;\n\n\tif (!rate || !parent_rate)\n\t\treturn -EINVAL;\n\n\tif (!clk_pll3200c32_get_params(parent_rate, rate, &params))\n\t\tclk_pll3200c32_get_rate(parent_rate, &params, &hwrate);\n\n\tpr_debug(\"%s: %s new rate %ld [ndiv=0x%x] [idf=0x%x]\\n\",\n\t\t __func__, __clk_get_name(hw->clk),\n\t\t hwrate, (unsigned int)params.ndiv,\n\t\t (unsigned int)params.idf);\n\n\tif (!hwrate)\n\t\treturn -EINVAL;\n\n\tpll->ndiv = params.ndiv;\n\tpll->idf = params.idf;\n\tpll->cp = params.cp;\n\n\t__clkgen_pll_disable(hw);\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\tCLKGEN_WRITE(pll, ndiv, pll->ndiv);\n\tCLKGEN_WRITE(pll, idf, pll->idf);\n\tCLKGEN_WRITE(pll, cp, pll->cp);\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\t__clkgen_pll_enable(hw);\n\n\treturn 0;\n}\n\n \n\nstatic int clk_pll4600c28_get_params(unsigned long input, unsigned long output,\n\t\t\t  struct stm_pll *pll)\n{\n\n\tunsigned long i, infin, n;\n\tunsigned long deviation = ~0;\n\tunsigned long new_freq, new_deviation;\n\n\t \n\tif (output < 19000000 || output > 3000000000u)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 1; i <= 7 && deviation; i++) {\n\t\t \n\t\tinfin = input / i;\n\t\tif (infin < 4000000 || infin > 50000000)\n\t\t\tcontinue;\t \n\n\t\tn = output / (infin * 2);\n\t\tif (n < 8 || n > 246)\n\t\t\tcontinue;\t \n\t\tif (n < 246)\n\t\t\tn++;\t \n\n\t\tfor (; n >= 8 && deviation; n--) {\n\t\t\tnew_freq = infin * 2 * n;\n\t\t\tif (new_freq < output)\n\t\t\t\tbreak;\t \n\n\t\t\tnew_deviation = new_freq - output;\n\t\t\tif (!new_deviation || new_deviation < deviation) {\n\t\t\t\tpll->idf  = i;\n\t\t\t\tpll->ndiv = n;\n\t\t\t\tdeviation = new_deviation;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (deviation == ~0)  \n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int clk_pll4600c28_get_rate(unsigned long input, struct stm_pll *pll,\n\t\t\tunsigned long *rate)\n{\n\tif (!pll->idf)\n\t\tpll->idf = 1;\n\n\t*rate = (input / pll->idf) * 2 * pll->ndiv;\n\n\treturn 0;\n}\n\nstatic unsigned long recalc_stm_pll4600c28(struct clk_hw *hw,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct clkgen_pll *pll = to_clkgen_pll(hw);\n\tstruct stm_pll params;\n\tunsigned long rate;\n\n\tif (!clkgen_pll_is_enabled(hw) || !clkgen_pll_is_locked(hw))\n\t\treturn 0;\n\n\tparams.ndiv = CLKGEN_READ(pll, ndiv);\n\tparams.idf = CLKGEN_READ(pll, idf);\n\n\tclk_pll4600c28_get_rate(parent_rate, &params, &rate);\n\n\tpr_debug(\"%s:%s rate %lu\\n\", __clk_get_name(hw->clk), __func__, rate);\n\n\treturn rate;\n}\n\nstatic long round_rate_stm_pll4600c28(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long *prate)\n{\n\tstruct stm_pll params;\n\n\tif (!clk_pll4600c28_get_params(*prate, rate, &params)) {\n\t\tclk_pll4600c28_get_rate(*prate, &params, &rate);\n\t} else {\n\t\tpr_debug(\"%s: %s rate %ld Invalid\\n\", __func__,\n\t\t\t __clk_get_name(hw->clk), rate);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"%s: %s new rate %ld [ndiv=%u] [idf=%u]\\n\",\n\t\t __func__, __clk_get_name(hw->clk),\n\t\t rate, (unsigned int)params.ndiv,\n\t\t (unsigned int)params.idf);\n\n\treturn rate;\n}\n\nstatic int set_rate_stm_pll4600c28(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct clkgen_pll *pll = to_clkgen_pll(hw);\n\tstruct stm_pll params;\n\tlong hwrate;\n\tunsigned long flags = 0;\n\n\tif (!rate || !parent_rate)\n\t\treturn -EINVAL;\n\n\tif (!clk_pll4600c28_get_params(parent_rate, rate, &params)) {\n\t\tclk_pll4600c28_get_rate(parent_rate, &params, &hwrate);\n\t} else {\n\t\tpr_debug(\"%s: %s rate %ld Invalid\\n\", __func__,\n\t\t\t __clk_get_name(hw->clk), rate);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"%s: %s new rate %ld [ndiv=0x%x] [idf=0x%x]\\n\",\n\t\t __func__, __clk_get_name(hw->clk),\n\t\t hwrate, (unsigned int)params.ndiv,\n\t\t (unsigned int)params.idf);\n\n\tif (!hwrate)\n\t\treturn -EINVAL;\n\n\tpll->ndiv = params.ndiv;\n\tpll->idf = params.idf;\n\n\t__clkgen_pll_disable(hw);\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\tCLKGEN_WRITE(pll, ndiv, pll->ndiv);\n\tCLKGEN_WRITE(pll, idf, pll->idf);\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\t__clkgen_pll_enable(hw);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops stm_pll3200c32_ops = {\n\t.enable\t\t= clkgen_pll_enable,\n\t.disable\t= clkgen_pll_disable,\n\t.is_enabled\t= clkgen_pll_is_enabled,\n\t.recalc_rate\t= recalc_stm_pll3200c32,\n};\n\nstatic const struct clk_ops stm_pll3200c32_a9_ops = {\n\t.enable\t\t= clkgen_pll_enable,\n\t.disable\t= clkgen_pll_disable,\n\t.is_enabled\t= clkgen_pll_is_enabled,\n\t.recalc_rate\t= recalc_stm_pll3200c32,\n\t.round_rate\t= round_rate_stm_pll3200c32,\n\t.set_rate\t= set_rate_stm_pll3200c32,\n};\n\nstatic const struct clk_ops stm_pll4600c28_ops = {\n\t.enable\t\t= clkgen_pll_enable,\n\t.disable\t= clkgen_pll_disable,\n\t.is_enabled\t= clkgen_pll_is_enabled,\n\t.recalc_rate\t= recalc_stm_pll4600c28,\n\t.round_rate\t= round_rate_stm_pll4600c28,\n\t.set_rate\t= set_rate_stm_pll4600c28,\n};\n\nstatic struct clk * __init clkgen_pll_register(const char *parent_name,\n\t\t\t\tstruct clkgen_pll_data\t*pll_data,\n\t\t\t\tvoid __iomem *reg, unsigned long pll_flags,\n\t\t\t\tconst char *clk_name, spinlock_t *lock)\n{\n\tstruct clkgen_pll *pll;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = clk_name;\n\tinit.ops = pll_data->ops;\n\n\tinit.flags = pll_flags | CLK_GET_RATE_NOCACHE;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents  = 1;\n\n\tpll->data = pll_data;\n\tpll->regs_base = reg;\n\tpll->hw.init = &init;\n\tpll->lock = lock;\n\n\tclk = clk_register(NULL, &pll->hw);\n\tif (IS_ERR(clk)) {\n\t\tkfree(pll);\n\t\treturn clk;\n\t}\n\n\tpr_debug(\"%s: parent %s rate %lu\\n\",\n\t\t\t__clk_get_name(clk),\n\t\t\t__clk_get_name(clk_get_parent(clk)),\n\t\t\tclk_get_rate(clk));\n\n\treturn clk;\n}\n\nstatic void __iomem * __init clkgen_get_register_base(\n\t\t\t\tstruct device_node *np)\n{\n\tstruct device_node *pnode;\n\tvoid __iomem *reg = NULL;\n\n\tpnode = of_get_parent(np);\n\tif (!pnode)\n\t\treturn NULL;\n\n\treg = of_iomap(pnode, 0);\n\n\tof_node_put(pnode);\n\treturn reg;\n}\n\nstatic struct clk * __init clkgen_odf_register(const char *parent_name,\n\t\t\t\t\t       void __iomem *reg,\n\t\t\t\t\t       struct clkgen_pll_data *pll_data,\n\t\t\t\t\t       unsigned long pll_flags, int odf,\n\t\t\t\t\t       spinlock_t *odf_lock,\n\t\t\t\t\t       const char *odf_name)\n{\n\tstruct clk *clk;\n\tunsigned long flags;\n\tstruct clk_gate *gate;\n\tstruct clk_divider *div;\n\n\tflags = pll_flags | CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT;\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgate->flags = CLK_GATE_SET_TO_DISABLE;\n\tgate->reg = reg + pll_data->odf_gate[odf].offset;\n\tgate->bit_idx = pll_data->odf_gate[odf].shift;\n\tgate->lock = odf_lock;\n\n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div) {\n\t\tkfree(gate);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdiv->flags = CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO;\n\tdiv->reg = reg + pll_data->odf[odf].offset;\n\tdiv->shift = pll_data->odf[odf].shift;\n\tdiv->width = fls(pll_data->odf[odf].mask);\n\tdiv->lock = odf_lock;\n\n\tclk = clk_register_composite(NULL, odf_name, &parent_name, 1,\n\t\t\t\t     NULL, NULL,\n\t\t\t\t     &div->hw, &clk_divider_ops,\n\t\t\t\t     &gate->hw, &clk_gate_ops,\n\t\t\t\t     flags);\n\tif (IS_ERR(clk))\n\t\treturn clk;\n\n\tpr_debug(\"%s: parent %s rate %lu\\n\",\n\t\t\t__clk_get_name(clk),\n\t\t\t__clk_get_name(clk_get_parent(clk)),\n\t\t\tclk_get_rate(clk));\n\treturn clk;\n}\n\n\nstatic void __init clkgen_c32_pll_setup(struct device_node *np,\n\t\tstruct clkgen_pll_data_clks *datac)\n{\n\tstruct clk *clk;\n\tconst char *parent_name, *pll_name;\n\tvoid __iomem *pll_base;\n\tint num_odfs, odf;\n\tstruct clk_onecell_data *clk_data;\n\tunsigned long pll_flags = 0;\n\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\tif (!parent_name)\n\t\treturn;\n\n\tpll_base = clkgen_get_register_base(np);\n\tif (!pll_base)\n\t\treturn;\n\n\tof_clk_detect_critical(np, 0, &pll_flags);\n\n\tclk = clkgen_pll_register(parent_name, datac->data, pll_base, pll_flags,\n\t\t\t\t  np->name, datac->data->lock);\n\tif (IS_ERR(clk))\n\t\treturn;\n\n\tpll_name = __clk_get_name(clk);\n\n\tnum_odfs = datac->data->num_odfs;\n\n\tclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn;\n\n\tclk_data->clk_num = num_odfs;\n\tclk_data->clks = kcalloc(clk_data->clk_num, sizeof(struct clk *),\n\t\t\t\t GFP_KERNEL);\n\n\tif (!clk_data->clks)\n\t\tgoto err;\n\n\tfor (odf = 0; odf < num_odfs; odf++) {\n\t\tstruct clk *clk;\n\t\tconst char *clk_name;\n\t\tunsigned long odf_flags = 0;\n\n\t\tif (datac->outputs) {\n\t\t\tclk_name = datac->outputs[odf].name;\n\t\t\todf_flags = datac->outputs[odf].flags;\n\t\t} else {\n\t\t\tif (of_property_read_string_index(np,\n\t\t\t\t\t\t\t  \"clock-output-names\",\n\t\t\t\t\t\t\t  odf, &clk_name))\n\t\t\t\treturn;\n\n\t\t\tof_clk_detect_critical(np, odf, &odf_flags);\n\t\t}\n\n\t\tclk = clkgen_odf_register(pll_name, pll_base, datac->data,\n\t\t\t\todf_flags, odf, &clkgena_c32_odf_lock,\n\t\t\t\tclk_name);\n\t\tif (IS_ERR(clk))\n\t\t\tgoto err;\n\n\t\tclk_data->clks[odf] = clk;\n\t}\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, clk_data);\n\treturn;\n\nerr:\n\tkfree(pll_name);\n\tkfree(clk_data->clks);\n\tkfree(clk_data);\n}\nstatic void __init clkgen_c32_pll0_setup(struct device_node *np)\n{\n\tclkgen_c32_pll_setup(np,\n\t\t(struct clkgen_pll_data_clks *) &st_pll3200c32_cx_0_legacy_data);\n}\nCLK_OF_DECLARE(c32_pll0, \"st,clkgen-pll0\", clkgen_c32_pll0_setup);\n\nstatic void __init clkgen_c32_pll0_a0_setup(struct device_node *np)\n{\n\tclkgen_c32_pll_setup(np,\n\t\t(struct clkgen_pll_data_clks *) &st_pll3200c32_a0_data);\n}\nCLK_OF_DECLARE(c32_pll0_a0, \"st,clkgen-pll0-a0\", clkgen_c32_pll0_a0_setup);\n\nstatic void __init clkgen_c32_pll0_c0_setup(struct device_node *np)\n{\n\tclkgen_c32_pll_setup(np,\n\t\t(struct clkgen_pll_data_clks *) &st_pll3200c32_c0_data);\n}\nCLK_OF_DECLARE(c32_pll0_c0, \"st,clkgen-pll0-c0\", clkgen_c32_pll0_c0_setup);\n\nstatic void __init clkgen_c32_pll1_setup(struct device_node *np)\n{\n\tclkgen_c32_pll_setup(np,\n\t\t(struct clkgen_pll_data_clks *) &st_pll3200c32_cx_1_legacy_data);\n}\nCLK_OF_DECLARE(c32_pll1, \"st,clkgen-pll1\", clkgen_c32_pll1_setup);\n\nstatic void __init clkgen_c32_pll1_c0_setup(struct device_node *np)\n{\n\tclkgen_c32_pll_setup(np,\n\t\t(struct clkgen_pll_data_clks *) &st_pll3200c32_c1_data);\n}\nCLK_OF_DECLARE(c32_pll1_c0, \"st,clkgen-pll1-c0\", clkgen_c32_pll1_c0_setup);\n\nstatic void __init clkgen_c32_plla9_setup(struct device_node *np)\n{\n\tclkgen_c32_pll_setup(np,\n\t\t(struct clkgen_pll_data_clks *) &st_pll3200c32_407_a9_data);\n}\nCLK_OF_DECLARE(c32_plla9, \"st,stih407-clkgen-plla9\", clkgen_c32_plla9_setup);\n\nstatic void __init clkgen_c28_plla9_setup(struct device_node *np)\n{\n\tclkgen_c32_pll_setup(np,\n\t\t(struct clkgen_pll_data_clks *) &st_pll4600c28_418_a9_data);\n}\nCLK_OF_DECLARE(c28_plla9, \"st,stih418-clkgen-plla9\", clkgen_c28_plla9_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}