{
  "module_name": "clkgen-fsyn.c",
  "hash_id": "5c0c50e9accbcb152462964bba0c5157e3bcd73aa02e38268f7e65d73c31d5fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/st/clkgen-fsyn.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/of_address.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n\n#include \"clkgen.h\"\n\n \n#define QUADFS_NDIV_THRESHOLD 30000000\n\n#define PLL_BW_GOODREF   (0L)\n#define PLL_BW_VBADREF   (1L)\n#define PLL_BW_BADREF    (2L)\n#define PLL_BW_VGOODREF  (3L)\n\n#define QUADFS_MAX_CHAN 4\n\nstruct stm_fs {\n\tunsigned long ndiv;\n\tunsigned long mdiv;\n\tunsigned long pe;\n\tunsigned long sdiv;\n\tunsigned long nsdiv;\n};\n\nstruct clkgen_quadfs_data {\n\tbool reset_present;\n\tbool bwfilter_present;\n\tbool lockstatus_present;\n\tbool powerup_polarity;\n\tbool standby_polarity;\n\tbool nsdiv_present;\n\tbool nrst_present;\n\tstruct clkgen_field ndiv;\n\tstruct clkgen_field ref_bw;\n\tstruct clkgen_field nreset;\n\tstruct clkgen_field npda;\n\tstruct clkgen_field lock_status;\n\n\tstruct clkgen_field nrst[QUADFS_MAX_CHAN];\n\tstruct clkgen_field nsb[QUADFS_MAX_CHAN];\n\tstruct clkgen_field en[QUADFS_MAX_CHAN];\n\tstruct clkgen_field mdiv[QUADFS_MAX_CHAN];\n\tstruct clkgen_field pe[QUADFS_MAX_CHAN];\n\tstruct clkgen_field sdiv[QUADFS_MAX_CHAN];\n\tstruct clkgen_field nsdiv[QUADFS_MAX_CHAN];\n\n\tconst struct clk_ops *pll_ops;\n\tint  (*get_params)(unsigned long, unsigned long, struct stm_fs *);\n\tint  (*get_rate)(unsigned long , const struct stm_fs *,\n\t\t\tunsigned long *);\n};\n\nstruct clkgen_clk_out {\n\tconst char *name;\n\tunsigned long flags;\n};\n\nstruct clkgen_quadfs_data_clks {\n\tstruct clkgen_quadfs_data *data;\n\tconst struct clkgen_clk_out *outputs;\n};\n\nstatic const struct clk_ops st_quadfs_pll_c32_ops;\n\nstatic int clk_fs660c32_dig_get_params(unsigned long input,\n\t\tunsigned long output, struct stm_fs *fs);\nstatic int clk_fs660c32_dig_get_rate(unsigned long, const struct stm_fs *,\n\t\tunsigned long *);\n\nstatic const struct clkgen_quadfs_data st_fs660c32_C = {\n\t.nrst_present = true,\n\t.nrst\t= { CLKGEN_FIELD(0x2f0, 0x1, 0),\n\t\t    CLKGEN_FIELD(0x2f0, 0x1, 1),\n\t\t    CLKGEN_FIELD(0x2f0, 0x1, 2),\n\t\t    CLKGEN_FIELD(0x2f0, 0x1, 3) },\n\t.npda\t= CLKGEN_FIELD(0x2f0, 0x1, 12),\n\t.nsb\t= { CLKGEN_FIELD(0x2f0, 0x1, 8),\n\t\t    CLKGEN_FIELD(0x2f0, 0x1, 9),\n\t\t    CLKGEN_FIELD(0x2f0, 0x1, 10),\n\t\t    CLKGEN_FIELD(0x2f0, 0x1, 11) },\n\t.nsdiv_present = true,\n\t.nsdiv\t= { CLKGEN_FIELD(0x304, 0x1, 24),\n\t\t    CLKGEN_FIELD(0x308, 0x1, 24),\n\t\t    CLKGEN_FIELD(0x30c, 0x1, 24),\n\t\t    CLKGEN_FIELD(0x310, 0x1, 24) },\n\t.mdiv\t= { CLKGEN_FIELD(0x304, 0x1f, 15),\n\t\t    CLKGEN_FIELD(0x308, 0x1f, 15),\n\t\t    CLKGEN_FIELD(0x30c, 0x1f, 15),\n\t\t    CLKGEN_FIELD(0x310, 0x1f, 15) },\n\t.en\t= { CLKGEN_FIELD(0x2fc, 0x1, 0),\n\t\t    CLKGEN_FIELD(0x2fc, 0x1, 1),\n\t\t    CLKGEN_FIELD(0x2fc, 0x1, 2),\n\t\t    CLKGEN_FIELD(0x2fc, 0x1, 3) },\n\t.ndiv\t= CLKGEN_FIELD(0x2f4, 0x7, 16),\n\t.pe\t= { CLKGEN_FIELD(0x304, 0x7fff, 0),\n\t\t    CLKGEN_FIELD(0x308, 0x7fff, 0),\n\t\t    CLKGEN_FIELD(0x30c, 0x7fff, 0),\n\t\t    CLKGEN_FIELD(0x310, 0x7fff, 0) },\n\t.sdiv\t= { CLKGEN_FIELD(0x304, 0xf, 20),\n\t\t    CLKGEN_FIELD(0x308, 0xf, 20),\n\t\t    CLKGEN_FIELD(0x30c, 0xf, 20),\n\t\t    CLKGEN_FIELD(0x310, 0xf, 20) },\n\t.lockstatus_present = true,\n\t.lock_status = CLKGEN_FIELD(0x2f0, 0x1, 24),\n\t.powerup_polarity = 1,\n\t.standby_polarity = 1,\n\t.pll_ops\t= &st_quadfs_pll_c32_ops,\n\t.get_params\t= clk_fs660c32_dig_get_params,\n\t.get_rate\t= clk_fs660c32_dig_get_rate,\n};\n\nstatic const struct clkgen_clk_out st_fs660c32_C_clks[] = {\n\t{ .name = \"clk-s-c0-fs0-ch0\",\t},\n\t{ .name = \"clk-s-c0-fs0-ch1\",\t},\n\t{ .name = \"clk-s-c0-fs0-ch2\",\t},\n\t{ .name = \"clk-s-c0-fs0-ch3\",\t},\n};\n\nstatic const struct clkgen_quadfs_data_clks st_fs660c32_C_data = {\n\t.data\t= (struct clkgen_quadfs_data *)&st_fs660c32_C,\n\t.outputs\t= st_fs660c32_C_clks,\n};\n\nstatic const struct clkgen_quadfs_data st_fs660c32_D = {\n\t.nrst_present = true,\n\t.nrst\t= { CLKGEN_FIELD(0x2a0, 0x1, 0),\n\t\t    CLKGEN_FIELD(0x2a0, 0x1, 1),\n\t\t    CLKGEN_FIELD(0x2a0, 0x1, 2),\n\t\t    CLKGEN_FIELD(0x2a0, 0x1, 3) },\n\t.ndiv\t= CLKGEN_FIELD(0x2a4, 0x7, 16),\n\t.pe\t= { CLKGEN_FIELD(0x2b4, 0x7fff, 0),\n\t\t    CLKGEN_FIELD(0x2b8, 0x7fff, 0),\n\t\t    CLKGEN_FIELD(0x2bc, 0x7fff, 0),\n\t\t    CLKGEN_FIELD(0x2c0, 0x7fff, 0) },\n\t.sdiv\t= { CLKGEN_FIELD(0x2b4, 0xf, 20),\n\t\t    CLKGEN_FIELD(0x2b8, 0xf, 20),\n\t\t    CLKGEN_FIELD(0x2bc, 0xf, 20),\n\t\t    CLKGEN_FIELD(0x2c0, 0xf, 20) },\n\t.npda\t= CLKGEN_FIELD(0x2a0, 0x1, 12),\n\t.nsb\t= { CLKGEN_FIELD(0x2a0, 0x1, 8),\n\t\t    CLKGEN_FIELD(0x2a0, 0x1, 9),\n\t\t    CLKGEN_FIELD(0x2a0, 0x1, 10),\n\t\t    CLKGEN_FIELD(0x2a0, 0x1, 11) },\n\t.nsdiv_present = true,\n\t.nsdiv\t= { CLKGEN_FIELD(0x2b4, 0x1, 24),\n\t\t    CLKGEN_FIELD(0x2b8, 0x1, 24),\n\t\t    CLKGEN_FIELD(0x2bc, 0x1, 24),\n\t\t    CLKGEN_FIELD(0x2c0, 0x1, 24) },\n\t.mdiv\t= { CLKGEN_FIELD(0x2b4, 0x1f, 15),\n\t\t    CLKGEN_FIELD(0x2b8, 0x1f, 15),\n\t\t    CLKGEN_FIELD(0x2bc, 0x1f, 15),\n\t\t    CLKGEN_FIELD(0x2c0, 0x1f, 15) },\n\t.en\t= { CLKGEN_FIELD(0x2ac, 0x1, 0),\n\t\t    CLKGEN_FIELD(0x2ac, 0x1, 1),\n\t\t    CLKGEN_FIELD(0x2ac, 0x1, 2),\n\t\t    CLKGEN_FIELD(0x2ac, 0x1, 3) },\n\t.lockstatus_present = true,\n\t.lock_status = CLKGEN_FIELD(0x2A0, 0x1, 24),\n\t.powerup_polarity = 1,\n\t.standby_polarity = 1,\n\t.pll_ops\t= &st_quadfs_pll_c32_ops,\n\t.get_params\t= clk_fs660c32_dig_get_params,\n\t.get_rate\t= clk_fs660c32_dig_get_rate,};\n\nstatic const struct clkgen_quadfs_data_clks st_fs660c32_D_data = {\n\t.data\t= (struct clkgen_quadfs_data *)&st_fs660c32_D,\n};\n\nstatic const struct clkgen_clk_out st_fs660c32_D0_clks[] = {\n\t{ .name = \"clk-s-d0-fs0-ch0\",\t},\n\t{ .name = \"clk-s-d0-fs0-ch1\",\t},\n\t{ .name = \"clk-s-d0-fs0-ch2\",\t},\n\t{ .name = \"clk-s-d0-fs0-ch3\",\t},\n};\n\nstatic const struct clkgen_quadfs_data_clks st_fs660c32_D0_data = {\n\t.data\t= (struct clkgen_quadfs_data *)&st_fs660c32_D,\n\t.outputs\t= st_fs660c32_D0_clks,\n};\n\nstatic const struct clkgen_clk_out st_fs660c32_D2_clks[] = {\n\t{ .name = \"clk-s-d2-fs0-ch0\",\t},\n\t{ .name = \"clk-s-d2-fs0-ch1\",\t},\n\t{ .name = \"clk-s-d2-fs0-ch2\",\t},\n\t{ .name = \"clk-s-d2-fs0-ch3\",\t},\n};\n\nstatic const struct clkgen_quadfs_data_clks st_fs660c32_D2_data = {\n\t.data\t= (struct clkgen_quadfs_data *)&st_fs660c32_D,\n\t.outputs\t= st_fs660c32_D2_clks,\n};\n\nstatic const struct clkgen_clk_out st_fs660c32_D3_clks[] = {\n\t{ .name = \"clk-s-d3-fs0-ch0\",\t},\n\t{ .name = \"clk-s-d3-fs0-ch1\",\t},\n\t{ .name = \"clk-s-d3-fs0-ch2\",\t},\n\t{ .name = \"clk-s-d3-fs0-ch3\",\t},\n};\n\nstatic const struct clkgen_quadfs_data_clks st_fs660c32_D3_data = {\n\t.data\t= (struct clkgen_quadfs_data *)&st_fs660c32_D,\n\t.outputs\t= st_fs660c32_D3_clks,\n};\n\n \n\n \nstruct st_clk_quadfs_pll {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*regs_base;\n\tspinlock_t\t*lock;\n\tstruct clkgen_quadfs_data *data;\n\tu32 ndiv;\n};\n\n#define to_quadfs_pll(_hw) container_of(_hw, struct st_clk_quadfs_pll, hw)\n\nstatic int quadfs_pll_enable(struct clk_hw *hw)\n{\n\tstruct st_clk_quadfs_pll *pll = to_quadfs_pll(hw);\n\tunsigned long flags = 0, timeout = jiffies + msecs_to_jiffies(10);\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\t \n\tif (pll->data->reset_present)\n\t\tCLKGEN_WRITE(pll, nreset, 1);\n\n\t \n\tif (pll->data->bwfilter_present)\n\t\tCLKGEN_WRITE(pll, ref_bw, PLL_BW_GOODREF);\n\n\n\tCLKGEN_WRITE(pll, ndiv, pll->ndiv);\n\n\t \n\tCLKGEN_WRITE(pll, npda, !pll->data->powerup_polarity);\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\tif (pll->data->lockstatus_present)\n\t\twhile (!CLKGEN_READ(pll, lock_status)) {\n\t\t\tif (time_after(jiffies, timeout))\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\tcpu_relax();\n\t\t}\n\n\treturn 0;\n}\n\nstatic void quadfs_pll_disable(struct clk_hw *hw)\n{\n\tstruct st_clk_quadfs_pll *pll = to_quadfs_pll(hw);\n\tunsigned long flags = 0;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\t \n\tCLKGEN_WRITE(pll, npda, pll->data->powerup_polarity);\n\n\tif (pll->data->reset_present)\n\t\tCLKGEN_WRITE(pll, nreset, 0);\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n}\n\nstatic int quadfs_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct st_clk_quadfs_pll *pll = to_quadfs_pll(hw);\n\tu32 npda = CLKGEN_READ(pll, npda);\n\n\treturn pll->data->powerup_polarity ? !npda : !!npda;\n}\n\nstatic int clk_fs660c32_vco_get_rate(unsigned long input, struct stm_fs *fs,\n\t\t\t   unsigned long *rate)\n{\n\tunsigned long nd = fs->ndiv + 16;  \n\n\t*rate = input * nd;\n\n\treturn 0;\n}\n\nstatic unsigned long quadfs_pll_fs660c32_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct st_clk_quadfs_pll *pll = to_quadfs_pll(hw);\n\tunsigned long rate = 0;\n\tstruct stm_fs params;\n\n\tparams.ndiv = CLKGEN_READ(pll, ndiv);\n\tif (clk_fs660c32_vco_get_rate(parent_rate, &params, &rate))\n\t\tpr_err(\"%s:%s error calculating rate\\n\",\n\t\t       clk_hw_get_name(hw), __func__);\n\n\tpll->ndiv = params.ndiv;\n\n\treturn rate;\n}\n\nstatic int clk_fs660c32_vco_get_params(unsigned long input,\n\t\t\t\tunsigned long output, struct stm_fs *fs)\n{\n \n\tunsigned long pdiv = 1, n;\n\n\t \n\tif (output < 384000000 || output > 660000000)\n\t\treturn -EINVAL;\n\n\tif (input > 40000000)\n\t\t \n\t\treturn -EINVAL;\n\n\tinput /= 1000;\n\toutput /= 1000;\n\n\tn = output * pdiv / input;\n\tif (n < 16)\n\t\tn = 16;\n\tfs->ndiv = n - 16;  \n\n\treturn 0;\n}\n\nstatic long quadfs_pll_fs660c32_round_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long rate,\n\t\t\t\t\t   unsigned long *prate)\n{\n\tstruct stm_fs params;\n\n\tif (clk_fs660c32_vco_get_params(*prate, rate, &params))\n\t\treturn rate;\n\n\tclk_fs660c32_vco_get_rate(*prate, &params, &rate);\n\n\tpr_debug(\"%s: %s new rate %ld [ndiv=%u]\\n\",\n\t\t __func__, clk_hw_get_name(hw),\n\t\t rate, (unsigned int)params.ndiv);\n\n\treturn rate;\n}\n\nstatic int quadfs_pll_fs660c32_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct st_clk_quadfs_pll *pll = to_quadfs_pll(hw);\n\tstruct stm_fs params;\n\tlong hwrate = 0;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (!rate || !parent_rate)\n\t\treturn -EINVAL;\n\n\tret = clk_fs660c32_vco_get_params(parent_rate, rate, &params);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_fs660c32_vco_get_rate(parent_rate, &params, &hwrate);\n\n\tpr_debug(\"%s: %s new rate %ld [ndiv=0x%x]\\n\",\n\t\t __func__, clk_hw_get_name(hw),\n\t\t hwrate, (unsigned int)params.ndiv);\n\n\tif (!hwrate)\n\t\treturn -EINVAL;\n\n\tpll->ndiv = params.ndiv;\n\n\tif (pll->lock)\n\t\tspin_lock_irqsave(pll->lock, flags);\n\n\tCLKGEN_WRITE(pll, ndiv, pll->ndiv);\n\n\tif (pll->lock)\n\t\tspin_unlock_irqrestore(pll->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops st_quadfs_pll_c32_ops = {\n\t.enable\t\t= quadfs_pll_enable,\n\t.disable\t= quadfs_pll_disable,\n\t.is_enabled\t= quadfs_pll_is_enabled,\n\t.recalc_rate\t= quadfs_pll_fs660c32_recalc_rate,\n\t.round_rate\t= quadfs_pll_fs660c32_round_rate,\n\t.set_rate\t= quadfs_pll_fs660c32_set_rate,\n};\n\nstatic struct clk * __init st_clk_register_quadfs_pll(\n\t\tconst char *name, const char *parent_name,\n\t\tstruct clkgen_quadfs_data *quadfs, void __iomem *reg,\n\t\tspinlock_t *lock)\n{\n\tstruct st_clk_quadfs_pll *pll;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\t \n\tif (WARN_ON(!name || !parent_name))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = quadfs->pll_ops;\n\tinit.flags = CLK_GET_RATE_NOCACHE;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tpll->data = quadfs;\n\tpll->regs_base = reg;\n\tpll->lock = lock;\n\tpll->hw.init = &init;\n\n\tclk = clk_register(NULL, &pll->hw);\n\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\n \n\n \nstruct st_clk_quadfs_fsynth {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*regs_base;\n\tspinlock_t\t*lock;\n\tstruct clkgen_quadfs_data *data;\n\n\tu32 chan;\n\t \n\tu32 md;\n\tu32 pe;\n\tu32 sdiv;\n\tu32 nsdiv;\n};\n\n#define to_quadfs_fsynth(_hw) \\\n\tcontainer_of(_hw, struct st_clk_quadfs_fsynth, hw)\n\nstatic void quadfs_fsynth_program_enable(struct st_clk_quadfs_fsynth *fs)\n{\n\t \n\tCLKGEN_WRITE(fs, en[fs->chan], 1);\n\tCLKGEN_WRITE(fs, en[fs->chan], 0);\n}\n\nstatic void quadfs_fsynth_program_rate(struct st_clk_quadfs_fsynth *fs)\n{\n\tunsigned long flags = 0;\n\n\t \n\tCLKGEN_WRITE(fs, en[fs->chan], 0);\n\n\tCLKGEN_WRITE(fs, mdiv[fs->chan], fs->md);\n\tCLKGEN_WRITE(fs, pe[fs->chan], fs->pe);\n\tCLKGEN_WRITE(fs, sdiv[fs->chan], fs->sdiv);\n\n\tif (fs->lock)\n\t\tspin_lock_irqsave(fs->lock, flags);\n\n\tif (fs->data->nsdiv_present)\n\t\tCLKGEN_WRITE(fs, nsdiv[fs->chan], fs->nsdiv);\n\n\tif (fs->lock)\n\t\tspin_unlock_irqrestore(fs->lock, flags);\n}\n\nstatic int quadfs_fsynth_enable(struct clk_hw *hw)\n{\n\tstruct st_clk_quadfs_fsynth *fs = to_quadfs_fsynth(hw);\n\tunsigned long flags = 0;\n\n\tpr_debug(\"%s: %s\\n\", __func__, clk_hw_get_name(hw));\n\n\tquadfs_fsynth_program_rate(fs);\n\n\tif (fs->lock)\n\t\tspin_lock_irqsave(fs->lock, flags);\n\n\tCLKGEN_WRITE(fs, nsb[fs->chan], !fs->data->standby_polarity);\n\n\tif (fs->data->nrst_present)\n\t\tCLKGEN_WRITE(fs, nrst[fs->chan], 0);\n\n\tif (fs->lock)\n\t\tspin_unlock_irqrestore(fs->lock, flags);\n\n\tquadfs_fsynth_program_enable(fs);\n\n\treturn 0;\n}\n\nstatic void quadfs_fsynth_disable(struct clk_hw *hw)\n{\n\tstruct st_clk_quadfs_fsynth *fs = to_quadfs_fsynth(hw);\n\tunsigned long flags = 0;\n\n\tpr_debug(\"%s: %s\\n\", __func__, clk_hw_get_name(hw));\n\n\tif (fs->lock)\n\t\tspin_lock_irqsave(fs->lock, flags);\n\n\tCLKGEN_WRITE(fs, nsb[fs->chan], fs->data->standby_polarity);\n\n\tif (fs->lock)\n\t\tspin_unlock_irqrestore(fs->lock, flags);\n}\n\nstatic int quadfs_fsynth_is_enabled(struct clk_hw *hw)\n{\n\tstruct st_clk_quadfs_fsynth *fs = to_quadfs_fsynth(hw);\n\tu32 nsb = CLKGEN_READ(fs, nsb[fs->chan]);\n\n\tpr_debug(\"%s: %s enable bit = 0x%x\\n\",\n\t\t __func__, clk_hw_get_name(hw), nsb);\n\n\treturn fs->data->standby_polarity ? !nsb : !!nsb;\n}\n\n#define P20\t\t(uint64_t)(1 << 20)\n\nstatic int clk_fs660c32_dig_get_rate(unsigned long input,\n\t\t\t\tconst struct stm_fs *fs, unsigned long *rate)\n{\n\tunsigned long s = (1 << fs->sdiv);\n\tunsigned long ns;\n\tuint64_t res;\n\n\t \n\tns = (fs->nsdiv == 1) ? 1 : 3;\n\n\tres = (P20 * (32 + fs->mdiv) + 32 * fs->pe) * s * ns;\n\t*rate = (unsigned long)div64_u64(input * P20 * 32, res);\n\n\treturn 0;\n}\n\n\nstatic int clk_fs660c32_get_pe(int m, int si, unsigned long *deviation,\n\t\tsigned long input, unsigned long output, uint64_t *p,\n\t\tstruct stm_fs *fs)\n{\n\tunsigned long new_freq, new_deviation;\n\tstruct stm_fs fs_tmp;\n\tuint64_t val;\n\n\tval = (uint64_t)output << si;\n\n\t*p = (uint64_t)input * P20 - (32LL  + (uint64_t)m) * val * (P20 / 32LL);\n\n\t*p = div64_u64(*p, val);\n\n\tif (*p > 32767LL)\n\t\treturn 1;\n\n\tfs_tmp.mdiv = (unsigned long) m;\n\tfs_tmp.pe = (unsigned long)*p;\n\tfs_tmp.sdiv = si;\n\tfs_tmp.nsdiv = 1;\n\n\tclk_fs660c32_dig_get_rate(input, &fs_tmp, &new_freq);\n\n\tnew_deviation = abs(output - new_freq);\n\n\tif (new_deviation < *deviation) {\n\t\tfs->mdiv = m;\n\t\tfs->pe = (unsigned long)*p;\n\t\tfs->sdiv = si;\n\t\tfs->nsdiv = 1;\n\t\t*deviation = new_deviation;\n\t}\n\treturn 0;\n}\n\nstatic int clk_fs660c32_dig_get_params(unsigned long input,\n\t\tunsigned long output, struct stm_fs *fs)\n{\n\tint si;\t \n\tint m;  \n\tunsigned long new_freq, new_deviation;\n\t \n\tunsigned long deviation = ~0;\n\tuint64_t p, p1, p2;\t \n\tint r1, r2;\n\n\tstruct stm_fs fs_tmp;\n\n\tfor (si = 0; (si <= 8) && deviation; si++) {\n\n\t\t \n\t\tr1 = clk_fs660c32_get_pe(0, si, &deviation,\n\t\t\t\tinput, output, &p1, fs);\n\t\tr2 = clk_fs660c32_get_pe(31, si, &deviation,\n\t\t\t\tinput, output, &p2, fs);\n\n\t\t \n\t\tif (r1 && r2 && (p1 > p2))\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (m = 1; (m < 31) && deviation; m++)\n\t\t\tclk_fs660c32_get_pe(m, si, &deviation,\n\t\t\t\t\tinput, output, &p, fs);\n\n\t}\n\n\tif (deviation == ~0)  \n\t\treturn -1;\n\n\t \n\tif (deviation) {\n\t\tfs_tmp.mdiv = fs->mdiv;\n\t\tfs_tmp.sdiv = fs->sdiv;\n\t\tfs_tmp.nsdiv = fs->nsdiv;\n\n\t\tif (fs->pe > 2)\n\t\t\tp2 = fs->pe - 2;\n\t\telse\n\t\t\tp2 = 0;\n\n\t\tfor (; p2 < 32768ll && (p2 <= (fs->pe + 2)); p2++) {\n\t\t\tfs_tmp.pe = (unsigned long)p2;\n\n\t\t\tclk_fs660c32_dig_get_rate(input, &fs_tmp, &new_freq);\n\n\t\t\tnew_deviation = abs(output - new_freq);\n\n\t\t\t \n\t\t\tif (new_deviation < deviation) {\n\t\t\t\tfs->pe = (unsigned long)p2;\n\t\t\t\tdeviation = new_deviation;\n\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int quadfs_fsynt_get_hw_value_for_recalc(struct st_clk_quadfs_fsynth *fs,\n\t\tstruct stm_fs *params)\n{\n\t \n\tparams->mdiv\t= CLKGEN_READ(fs, mdiv[fs->chan]);\n\tparams->pe\t= CLKGEN_READ(fs, pe[fs->chan]);\n\tparams->sdiv\t= CLKGEN_READ(fs, sdiv[fs->chan]);\n\n\tif (fs->data->nsdiv_present)\n\t\tparams->nsdiv = CLKGEN_READ(fs, nsdiv[fs->chan]);\n\telse\n\t\tparams->nsdiv = 1;\n\n\t \n\tif (!params->mdiv && !params->pe && !params->sdiv)\n\t\treturn 1;\n\n\tfs->md = params->mdiv;\n\tfs->pe = params->pe;\n\tfs->sdiv = params->sdiv;\n\tfs->nsdiv = params->nsdiv;\n\n\treturn 0;\n}\n\nstatic long quadfs_find_best_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\tunsigned long prate, struct stm_fs *params)\n{\n\tstruct st_clk_quadfs_fsynth *fs = to_quadfs_fsynth(hw);\n\tint (*clk_fs_get_rate)(unsigned long ,\n\t\t\t\tconst struct stm_fs *, unsigned long *);\n\tint (*clk_fs_get_params)(unsigned long, unsigned long, struct stm_fs *);\n\tunsigned long rate = 0;\n\n\tclk_fs_get_rate = fs->data->get_rate;\n\tclk_fs_get_params = fs->data->get_params;\n\n\tif (!clk_fs_get_params(prate, drate, params))\n\t\tclk_fs_get_rate(prate, params, &rate);\n\n\treturn rate;\n}\n\nstatic unsigned long quadfs_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct st_clk_quadfs_fsynth *fs = to_quadfs_fsynth(hw);\n\tunsigned long rate = 0;\n\tstruct stm_fs params;\n\tint (*clk_fs_get_rate)(unsigned long ,\n\t\t\t\tconst struct stm_fs *, unsigned long *);\n\n\tclk_fs_get_rate = fs->data->get_rate;\n\n\tif (quadfs_fsynt_get_hw_value_for_recalc(fs, &params))\n\t\treturn 0;\n\n\tif (clk_fs_get_rate(parent_rate, &params, &rate)) {\n\t\tpr_err(\"%s:%s error calculating rate\\n\",\n\t\t       clk_hw_get_name(hw), __func__);\n\t}\n\n\tpr_debug(\"%s:%s rate %lu\\n\", clk_hw_get_name(hw), __func__, rate);\n\n\treturn rate;\n}\n\nstatic long quadfs_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long *prate)\n{\n\tstruct stm_fs params;\n\n\trate = quadfs_find_best_rate(hw, rate, *prate, &params);\n\n\tpr_debug(\"%s: %s new rate %ld [sdiv=0x%x,md=0x%x,pe=0x%x,nsdiv3=%u]\\n\",\n\t\t __func__, clk_hw_get_name(hw),\n\t\t rate, (unsigned int)params.sdiv, (unsigned int)params.mdiv,\n\t\t\t (unsigned int)params.pe, (unsigned int)params.nsdiv);\n\n\treturn rate;\n}\n\n\nstatic void quadfs_program_and_enable(struct st_clk_quadfs_fsynth *fs,\n\t\tstruct stm_fs *params)\n{\n\tfs->md = params->mdiv;\n\tfs->pe = params->pe;\n\tfs->sdiv = params->sdiv;\n\tfs->nsdiv = params->nsdiv;\n\n\t \n\tquadfs_fsynth_program_rate(fs);\n\tquadfs_fsynth_program_enable(fs);\n}\n\nstatic int quadfs_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct st_clk_quadfs_fsynth *fs = to_quadfs_fsynth(hw);\n\tstruct stm_fs params;\n\tlong hwrate;\n\n\tif (!rate || !parent_rate)\n\t\treturn -EINVAL;\n\n\tmemset(&params, 0, sizeof(struct stm_fs));\n\n\thwrate = quadfs_find_best_rate(hw, rate, parent_rate, &params);\n\tif (!hwrate)\n\t\treturn -EINVAL;\n\n\tquadfs_program_and_enable(fs, &params);\n\n\treturn 0;\n}\n\n\n\nstatic const struct clk_ops st_quadfs_ops = {\n\t.enable\t\t= quadfs_fsynth_enable,\n\t.disable\t= quadfs_fsynth_disable,\n\t.is_enabled\t= quadfs_fsynth_is_enabled,\n\t.round_rate\t= quadfs_round_rate,\n\t.set_rate\t= quadfs_set_rate,\n\t.recalc_rate\t= quadfs_recalc_rate,\n};\n\nstatic struct clk * __init st_clk_register_quadfs_fsynth(\n\t\tconst char *name, const char *parent_name,\n\t\tstruct clkgen_quadfs_data *quadfs, void __iomem *reg, u32 chan,\n\t\tunsigned long flags, spinlock_t *lock)\n{\n\tstruct st_clk_quadfs_fsynth *fs;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\t \n\tif (WARN_ON(!name || !parent_name))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfs = kzalloc(sizeof(*fs), GFP_KERNEL);\n\tif (!fs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &st_quadfs_ops;\n\tinit.flags = flags | CLK_GET_RATE_NOCACHE;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tfs->data = quadfs;\n\tfs->regs_base = reg;\n\tfs->chan = chan;\n\tfs->lock = lock;\n\tfs->hw.init = &init;\n\n\tclk = clk_register(NULL, &fs->hw);\n\n\tif (IS_ERR(clk))\n\t\tkfree(fs);\n\n\treturn clk;\n}\n\nstatic void __init st_of_create_quadfs_fsynths(\n\t\tstruct device_node *np, const char *pll_name,\n\t\tstruct clkgen_quadfs_data_clks *quadfs, void __iomem *reg,\n\t\tspinlock_t *lock)\n{\n\tstruct clk_onecell_data *clk_data;\n\tint fschan;\n\n\tclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn;\n\n\tclk_data->clk_num = QUADFS_MAX_CHAN;\n\tclk_data->clks = kcalloc(QUADFS_MAX_CHAN, sizeof(struct clk *),\n\t\t\t\t GFP_KERNEL);\n\n\tif (!clk_data->clks) {\n\t\tkfree(clk_data);\n\t\treturn;\n\t}\n\n\tfor (fschan = 0; fschan < QUADFS_MAX_CHAN; fschan++) {\n\t\tstruct clk *clk;\n\t\tconst char *clk_name;\n\t\tunsigned long flags = 0;\n\n\t\tif (quadfs->outputs) {\n\t\t\tclk_name = quadfs->outputs[fschan].name;\n\t\t\tflags = quadfs->outputs[fschan].flags;\n\t\t} else {\n\t\t\tif (of_property_read_string_index(np,\n\t\t\t\t\t\t\t\"clock-output-names\",\n\t\t\t\t\t\t\tfschan, &clk_name))\n\t\t\t\tbreak;\n\t\t\tof_clk_detect_critical(np, fschan, &flags);\n\t\t}\n\n\t\t \n\t\tif (*clk_name == '\\0')\n\t\t\tcontinue;\n\n\t\tclk = st_clk_register_quadfs_fsynth(clk_name, pll_name,\n\t\t\t\t\t\t    quadfs->data, reg, fschan,\n\t\t\t\t\t\t    flags, lock);\n\n\t\t \n\t\tif (!IS_ERR(clk)) {\n\t\t\tclk_data->clks[fschan] = clk;\n\t\t\tpr_debug(\"%s: parent %s rate %u\\n\",\n\t\t\t\t__clk_get_name(clk),\n\t\t\t\t__clk_get_name(clk_get_parent(clk)),\n\t\t\t\t(unsigned int)clk_get_rate(clk));\n\t\t}\n\t}\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, clk_data);\n}\n\nstatic void __init st_of_quadfs_setup(struct device_node *np,\n\t\tstruct clkgen_quadfs_data_clks *datac)\n{\n\tstruct clk *clk;\n\tconst char *pll_name, *clk_parent_name;\n\tvoid __iomem *reg;\n\tspinlock_t *lock;\n\tstruct device_node *parent_np;\n\n\t \n\treg = of_iomap(np, 0);\n\tif (!reg) {\n\t\tparent_np = of_get_parent(np);\n\t\treg = of_iomap(parent_np, 0);\n\t\tof_node_put(parent_np);\n\t\tif (!reg) {\n\t\t\tpr_err(\"%s: Failed to get base address\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclk_parent_name = of_clk_get_parent_name(np, 0);\n\tif (!clk_parent_name)\n\t\treturn;\n\n\tpll_name = kasprintf(GFP_KERNEL, \"%pOFn.pll\", np);\n\tif (!pll_name)\n\t\treturn;\n\n\tlock = kzalloc(sizeof(*lock), GFP_KERNEL);\n\tif (!lock)\n\t\tgoto err_exit;\n\n\tspin_lock_init(lock);\n\n\tclk = st_clk_register_quadfs_pll(pll_name, clk_parent_name, datac->data,\n\t\t\treg, lock);\n\tif (IS_ERR(clk)) {\n\t\tkfree(lock);\n\t\tgoto err_exit;\n\t} else\n\t\tpr_debug(\"%s: parent %s rate %u\\n\",\n\t\t\t__clk_get_name(clk),\n\t\t\t__clk_get_name(clk_get_parent(clk)),\n\t\t\t(unsigned int)clk_get_rate(clk));\n\n\tst_of_create_quadfs_fsynths(np, pll_name, datac, reg, lock);\n\nerr_exit:\n\tkfree(pll_name);  \n}\n\nstatic void __init st_of_quadfs660C_setup(struct device_node *np)\n{\n\tst_of_quadfs_setup(np,\n\t\t(struct clkgen_quadfs_data_clks *) &st_fs660c32_C_data);\n}\nCLK_OF_DECLARE(quadfs660C, \"st,quadfs-pll\", st_of_quadfs660C_setup);\n\nstatic void __init st_of_quadfs660D_setup(struct device_node *np)\n{\n\tst_of_quadfs_setup(np,\n\t\t(struct clkgen_quadfs_data_clks *) &st_fs660c32_D_data);\n}\nCLK_OF_DECLARE(quadfs660D, \"st,quadfs\", st_of_quadfs660D_setup);\n\nstatic void __init st_of_quadfs660D0_setup(struct device_node *np)\n{\n\tst_of_quadfs_setup(np,\n\t\t(struct clkgen_quadfs_data_clks *) &st_fs660c32_D0_data);\n}\nCLK_OF_DECLARE(quadfs660D0, \"st,quadfs-d0\", st_of_quadfs660D0_setup);\n\nstatic void __init st_of_quadfs660D2_setup(struct device_node *np)\n{\n\tst_of_quadfs_setup(np,\n\t\t(struct clkgen_quadfs_data_clks *) &st_fs660c32_D2_data);\n}\nCLK_OF_DECLARE(quadfs660D2, \"st,quadfs-d2\", st_of_quadfs660D2_setup);\n\nstatic void __init st_of_quadfs660D3_setup(struct device_node *np)\n{\n\tst_of_quadfs_setup(np,\n\t\t(struct clkgen_quadfs_data_clks *) &st_fs660c32_D3_data);\n}\nCLK_OF_DECLARE(quadfs660D3, \"st,quadfs-d3\", st_of_quadfs660D3_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}