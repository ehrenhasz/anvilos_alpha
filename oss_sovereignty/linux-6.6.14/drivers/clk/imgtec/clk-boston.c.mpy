{
  "module_name": "clk-boston.c",
  "hash_id": "91fb949dc67372fb397b3da4c28024d468a66b19c3c3baee48ba1d1746b0374a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imgtec/clk-boston.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"clk-boston: \" fmt\n\n#include <linux/clk-provider.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/mfd/syscon.h>\n\n#include <dt-bindings/clock/boston-clock.h>\n\n#define BOSTON_PLAT_MMCMDIV\t\t0x30\n# define BOSTON_PLAT_MMCMDIV_CLK0DIV\t(0xff << 0)\n# define BOSTON_PLAT_MMCMDIV_INPUT\t(0xff << 8)\n# define BOSTON_PLAT_MMCMDIV_MUL\t(0xff << 16)\n# define BOSTON_PLAT_MMCMDIV_CLK1DIV\t(0xff << 24)\n\n#define BOSTON_CLK_COUNT 3\n\nstatic u32 ext_field(u32 val, u32 mask)\n{\n\treturn (val & mask) >> (ffs(mask) - 1);\n}\n\nstatic void __init clk_boston_setup(struct device_node *np)\n{\n\tunsigned long in_freq, cpu_freq, sys_freq;\n\tuint mmcmdiv, mul, cpu_div, sys_div;\n\tstruct clk_hw_onecell_data *onecell;\n\tstruct regmap *regmap;\n\tstruct clk_hw *hw;\n\tint err;\n\n\tregmap = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(regmap)) {\n\t\tpr_err(\"failed to find regmap\\n\");\n\t\treturn;\n\t}\n\n\terr = regmap_read(regmap, BOSTON_PLAT_MMCMDIV, &mmcmdiv);\n\tif (err) {\n\t\tpr_err(\"failed to read mmcm_div register: %d\\n\", err);\n\t\treturn;\n\t}\n\n\tin_freq = ext_field(mmcmdiv, BOSTON_PLAT_MMCMDIV_INPUT) * 1000000;\n\tmul = ext_field(mmcmdiv, BOSTON_PLAT_MMCMDIV_MUL);\n\n\tsys_div = ext_field(mmcmdiv, BOSTON_PLAT_MMCMDIV_CLK0DIV);\n\tsys_freq = mult_frac(in_freq, mul, sys_div);\n\n\tcpu_div = ext_field(mmcmdiv, BOSTON_PLAT_MMCMDIV_CLK1DIV);\n\tcpu_freq = mult_frac(in_freq, mul, cpu_div);\n\n\tonecell = kzalloc(struct_size(onecell, hws, BOSTON_CLK_COUNT),\n\t\t\t  GFP_KERNEL);\n\tif (!onecell)\n\t\treturn;\n\n\tonecell->num = BOSTON_CLK_COUNT;\n\n\thw = clk_hw_register_fixed_rate(NULL, \"input\", NULL, 0, in_freq);\n\tif (IS_ERR(hw)) {\n\t\tpr_err(\"failed to register input clock: %ld\\n\", PTR_ERR(hw));\n\t\tgoto fail_input;\n\t}\n\tonecell->hws[BOSTON_CLK_INPUT] = hw;\n\n\thw = clk_hw_register_fixed_rate(NULL, \"sys\", \"input\", 0, sys_freq);\n\tif (IS_ERR(hw)) {\n\t\tpr_err(\"failed to register sys clock: %ld\\n\", PTR_ERR(hw));\n\t\tgoto fail_sys;\n\t}\n\tonecell->hws[BOSTON_CLK_SYS] = hw;\n\n\thw = clk_hw_register_fixed_rate(NULL, \"cpu\", \"input\", 0, cpu_freq);\n\tif (IS_ERR(hw)) {\n\t\tpr_err(\"failed to register cpu clock: %ld\\n\", PTR_ERR(hw));\n\t\tgoto fail_cpu;\n\t}\n\tonecell->hws[BOSTON_CLK_CPU] = hw;\n\n\terr = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, onecell);\n\tif (err) {\n\t\tpr_err(\"failed to add DT provider: %d\\n\", err);\n\t\tgoto fail_clk_add;\n\t}\n\n\treturn;\n\nfail_clk_add:\n\tclk_hw_unregister_fixed_rate(onecell->hws[BOSTON_CLK_CPU]);\nfail_cpu:\n\tclk_hw_unregister_fixed_rate(onecell->hws[BOSTON_CLK_SYS]);\nfail_sys:\n\tclk_hw_unregister_fixed_rate(onecell->hws[BOSTON_CLK_INPUT]);\nfail_input:\n\tkfree(onecell);\n}\n\n \nCLK_OF_DECLARE(clk_boston, \"img,boston-clock\", clk_boston_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}