{
  "module_name": "clk-nomadik.c",
  "hash_id": "0a3252a5ef29fe12742184b1fc947d0137a86df4ca8cc38b5f81c634fff5598c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-nomadik.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"Nomadik SRC clocks: \" fmt\n\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/clk-provider.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n#include <linux/reboot.h>\n\n \n\n#define SRC_CR\t\t\t0x00U\n#define SRC_CR_T0_ENSEL\t\tBIT(15)\n#define SRC_CR_T1_ENSEL\t\tBIT(17)\n#define SRC_CR_T2_ENSEL\t\tBIT(19)\n#define SRC_CR_T3_ENSEL\t\tBIT(21)\n#define SRC_CR_T4_ENSEL\t\tBIT(23)\n#define SRC_CR_T5_ENSEL\t\tBIT(25)\n#define SRC_CR_T6_ENSEL\t\tBIT(27)\n#define SRC_CR_T7_ENSEL\t\tBIT(29)\n#define SRC_XTALCR\t\t0x0CU\n#define SRC_XTALCR_XTALTIMEN\tBIT(20)\n#define SRC_XTALCR_SXTALDIS\tBIT(19)\n#define SRC_XTALCR_MXTALSTAT\tBIT(2)\n#define SRC_XTALCR_MXTALEN\tBIT(1)\n#define SRC_XTALCR_MXTALOVER\tBIT(0)\n#define SRC_PLLCR\t\t0x10U\n#define SRC_PLLCR_PLLTIMEN\tBIT(29)\n#define SRC_PLLCR_PLL2EN\tBIT(28)\n#define SRC_PLLCR_PLL1STAT\tBIT(2)\n#define SRC_PLLCR_PLL1EN\tBIT(1)\n#define SRC_PLLCR_PLL1OVER\tBIT(0)\n#define SRC_PLLFR\t\t0x14U\n#define SRC_PCKEN0\t\t0x24U\n#define SRC_PCKDIS0\t\t0x28U\n#define SRC_PCKENSR0\t\t0x2CU\n#define SRC_PCKSR0\t\t0x30U\n#define SRC_PCKEN1\t\t0x34U\n#define SRC_PCKDIS1\t\t0x38U\n#define SRC_PCKENSR1\t\t0x3CU\n#define SRC_PCKSR1\t\t0x40U\n\n \nstatic DEFINE_SPINLOCK(src_lock);\n \nstatic void __iomem *src_base;\n\nstatic int nomadik_clk_reboot_handler(struct notifier_block *this,\n\t\t\t\tunsigned long code,\n\t\t\t\tvoid *unused)\n{\n\tu32 val;\n\n\t \n\tval = readl(src_base + SRC_XTALCR);\n\tval &= ~SRC_XTALCR_MXTALOVER;\n\tval |= SRC_XTALCR_MXTALEN;\n\tpr_crit(\"force-enabling MXTALO\\n\");\n\twritel(val, src_base + SRC_XTALCR);\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block nomadik_clk_reboot_notifier = {\n\t.notifier_call = nomadik_clk_reboot_handler,\n};\n\nstatic const struct of_device_id nomadik_src_match[] __initconst = {\n\t{ .compatible = \"stericsson,nomadik-src\" },\n\t{   }\n};\n\nstatic void __init nomadik_src_init(void)\n{\n\tstruct device_node *np;\n\tu32 val;\n\n\tnp = of_find_matching_node(NULL, nomadik_src_match);\n\tif (!np) {\n\t\tpr_crit(\"no matching node for SRC, aborting clock init\\n\");\n\t\treturn;\n\t}\n\tsrc_base = of_iomap(np, 0);\n\tif (!src_base) {\n\t\tpr_err(\"%s: must have src parent node with REGS (%pOFn)\\n\",\n\t\t       __func__, np);\n\t\tgoto out_put;\n\t}\n\n\t \n\tval = readl(src_base + SRC_CR);\n\tval |= SRC_CR_T0_ENSEL;\n\tval |= SRC_CR_T1_ENSEL;\n\tval |= SRC_CR_T2_ENSEL;\n\tval |= SRC_CR_T3_ENSEL;\n\tval |= SRC_CR_T4_ENSEL;\n\tval |= SRC_CR_T5_ENSEL;\n\tval |= SRC_CR_T6_ENSEL;\n\tval |= SRC_CR_T7_ENSEL;\n\twritel(val, src_base + SRC_CR);\n\n\tval = readl(src_base + SRC_XTALCR);\n\tpr_info(\"SXTALO is %s\\n\",\n\t\t(val & SRC_XTALCR_SXTALDIS) ? \"disabled\" : \"enabled\");\n\tpr_info(\"MXTAL is %s\\n\",\n\t\t(val & SRC_XTALCR_MXTALSTAT) ? \"enabled\" : \"disabled\");\n\tif (of_property_read_bool(np, \"disable-sxtalo\")) {\n\t\t \n\t\tval |= SRC_XTALCR_SXTALDIS;\n\t\tpr_info(\"disabling SXTALO\\n\");\n\t}\n\tif (of_property_read_bool(np, \"disable-mxtalo\")) {\n\t\t \n\t\tval |= SRC_XTALCR_MXTALOVER;\n\t\tval &= ~SRC_XTALCR_MXTALEN;\n\t\tpr_info(\"disabling MXTALO\\n\");\n\t}\n\twritel(val, src_base + SRC_XTALCR);\n\tregister_reboot_notifier(&nomadik_clk_reboot_notifier);\n\nout_put:\n\tof_node_put(np);\n}\n\n \nstruct clk_pll {\n\tstruct clk_hw hw;\n\tint id;\n};\n\n \nstruct clk_src {\n\tstruct clk_hw hw;\n\tint id;\n\tbool group1;\n\tu32 clkbit;\n};\n\n#define to_pll(_hw) container_of(_hw, struct clk_pll, hw)\n#define to_src(_hw) container_of(_hw, struct clk_src, hw)\n\nstatic int pll_clk_enable(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_pll(hw);\n\tu32 val;\n\n\tspin_lock(&src_lock);\n\tval = readl(src_base + SRC_PLLCR);\n\tif (pll->id == 1) {\n\t\tif (val & SRC_PLLCR_PLL1OVER) {\n\t\t\tval |= SRC_PLLCR_PLL1EN;\n\t\t\twritel(val, src_base + SRC_PLLCR);\n\t\t}\n\t} else if (pll->id == 2) {\n\t\tval |= SRC_PLLCR_PLL2EN;\n\t\twritel(val, src_base + SRC_PLLCR);\n\t}\n\tspin_unlock(&src_lock);\n\treturn 0;\n}\n\nstatic void pll_clk_disable(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_pll(hw);\n\tu32 val;\n\n\tspin_lock(&src_lock);\n\tval = readl(src_base + SRC_PLLCR);\n\tif (pll->id == 1) {\n\t\tif (val & SRC_PLLCR_PLL1OVER) {\n\t\t\tval &= ~SRC_PLLCR_PLL1EN;\n\t\t\twritel(val, src_base + SRC_PLLCR);\n\t\t}\n\t} else if (pll->id == 2) {\n\t\tval &= ~SRC_PLLCR_PLL2EN;\n\t\twritel(val, src_base + SRC_PLLCR);\n\t}\n\tspin_unlock(&src_lock);\n}\n\nstatic int pll_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_pll(hw);\n\tu32 val;\n\n\tval = readl(src_base + SRC_PLLCR);\n\tif (pll->id == 1) {\n\t\tif (val & SRC_PLLCR_PLL1OVER)\n\t\t\treturn !!(val & SRC_PLLCR_PLL1EN);\n\t} else if (pll->id == 2) {\n\t\treturn !!(val & SRC_PLLCR_PLL2EN);\n\t}\n\treturn 1;\n}\n\nstatic unsigned long pll_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_pll *pll = to_pll(hw);\n\tu32 val;\n\n\tval = readl(src_base + SRC_PLLFR);\n\n\tif (pll->id == 1) {\n\t\tu8 mul;\n\t\tu8 div;\n\n\t\tmul = (val >> 8) & 0x3FU;\n\t\tmul += 2;\n\t\tdiv = val & 0x07U;\n\t\treturn (parent_rate * mul) >> div;\n\t}\n\n\tif (pll->id == 2) {\n\t\tu8 mul;\n\n\t\tmul = (val >> 24) & 0x3FU;\n\t\tmul += 2;\n\t\treturn (parent_rate * mul);\n\t}\n\n\t \n\treturn 0;\n}\n\n\nstatic const struct clk_ops pll_clk_ops = {\n\t.enable = pll_clk_enable,\n\t.disable = pll_clk_disable,\n\t.is_enabled = pll_clk_is_enabled,\n\t.recalc_rate = pll_clk_recalc_rate,\n};\n\nstatic struct clk_hw * __init\npll_clk_register(struct device *dev, const char *name,\n\t\t const char *parent_name, u32 id)\n{\n\tint ret;\n\tstruct clk_pll *pll;\n\tstruct clk_init_data init;\n\n\tif (id != 1 && id != 2) {\n\t\tpr_err(\"%s: the Nomadik has only PLL 1 & 2\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &pll_clk_ops;\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\tpll->hw.init = &init;\n\tpll->id = id;\n\n\tpr_debug(\"register PLL1 clock \\\"%s\\\"\\n\", name);\n\n\tret = clk_hw_register(dev, &pll->hw);\n\tif (ret) {\n\t\tkfree(pll);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn &pll->hw;\n}\n\n \n\nstatic int src_clk_enable(struct clk_hw *hw)\n{\n\tstruct clk_src *sclk = to_src(hw);\n\tu32 enreg = sclk->group1 ? SRC_PCKEN1 : SRC_PCKEN0;\n\tu32 sreg = sclk->group1 ? SRC_PCKSR1 : SRC_PCKSR0;\n\n\twritel(sclk->clkbit, src_base + enreg);\n\t \n\twhile (!(readl(src_base + sreg) & sclk->clkbit))\n\t\tcpu_relax();\n\treturn 0;\n}\n\nstatic void src_clk_disable(struct clk_hw *hw)\n{\n\tstruct clk_src *sclk = to_src(hw);\n\tu32 disreg = sclk->group1 ? SRC_PCKDIS1 : SRC_PCKDIS0;\n\tu32 sreg = sclk->group1 ? SRC_PCKSR1 : SRC_PCKSR0;\n\n\twritel(sclk->clkbit, src_base + disreg);\n\t \n\twhile (readl(src_base + sreg) & sclk->clkbit)\n\t\tcpu_relax();\n}\n\nstatic int src_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_src *sclk = to_src(hw);\n\tu32 sreg = sclk->group1 ? SRC_PCKSR1 : SRC_PCKSR0;\n\tu32 val = readl(src_base + sreg);\n\n\treturn !!(val & sclk->clkbit);\n}\n\nstatic unsigned long\nsrc_clk_recalc_rate(struct clk_hw *hw,\n\t\t    unsigned long parent_rate)\n{\n\treturn parent_rate;\n}\n\nstatic const struct clk_ops src_clk_ops = {\n\t.enable = src_clk_enable,\n\t.disable = src_clk_disable,\n\t.is_enabled = src_clk_is_enabled,\n\t.recalc_rate = src_clk_recalc_rate,\n};\n\nstatic struct clk_hw * __init\nsrc_clk_register(struct device *dev, const char *name,\n\t\t const char *parent_name, u8 id)\n{\n\tint ret;\n\tstruct clk_src *sclk;\n\tstruct clk_init_data init;\n\n\tsclk = kzalloc(sizeof(*sclk), GFP_KERNEL);\n\tif (!sclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &src_clk_ops;\n\t \n\tif (id == 2)\n\t\tinit.flags = CLK_IGNORE_UNUSED;\n\telse\n\t\tinit.flags = 0;\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\tsclk->hw.init = &init;\n\tsclk->id = id;\n\tsclk->group1 = (id > 31);\n\tsclk->clkbit = BIT(id & 0x1f);\n\n\tpr_debug(\"register clock \\\"%s\\\" ID: %d group: %d bits: %08x\\n\",\n\t\t name, id, sclk->group1, sclk->clkbit);\n\n\tret = clk_hw_register(dev, &sclk->hw);\n\tif (ret) {\n\t\tkfree(sclk);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn &sclk->hw;\n}\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic u32 src_pcksr0_boot;\nstatic u32 src_pcksr1_boot;\n\nstatic const char * const src_clk_names[] = {\n\t\"HCLKDMA0  \",\n\t\"HCLKSMC   \",\n\t\"HCLKSDRAM \",\n\t\"HCLKDMA1  \",\n\t\"HCLKCLCD  \",\n\t\"PCLKIRDA  \",\n\t\"PCLKSSP   \",\n\t\"PCLKUART0 \",\n\t\"PCLKSDI   \",\n\t\"PCLKI2C0  \",\n\t\"PCLKI2C1  \",\n\t\"PCLKUART1 \",\n\t\"PCLMSP0   \",\n\t\"HCLKUSB   \",\n\t\"HCLKDIF   \",\n\t\"HCLKSAA   \",\n\t\"HCLKSVA   \",\n\t\"PCLKHSI   \",\n\t\"PCLKXTI   \",\n\t\"PCLKUART2 \",\n\t\"PCLKMSP1  \",\n\t\"PCLKMSP2  \",\n\t\"PCLKOWM   \",\n\t\"HCLKHPI   \",\n\t\"PCLKSKE   \",\n\t\"PCLKHSEM  \",\n\t\"HCLK3D    \",\n\t\"HCLKHASH  \",\n\t\"HCLKCRYP  \",\n\t\"PCLKMSHC  \",\n\t\"HCLKUSBM  \",\n\t\"HCLKRNG   \",\n\t\"RESERVED  \",\n\t\"RESERVED  \",\n\t\"RESERVED  \",\n\t\"RESERVED  \",\n\t\"CLDCLK    \",\n\t\"IRDACLK   \",\n\t\"SSPICLK   \",\n\t\"UART0CLK  \",\n\t\"SDICLK    \",\n\t\"I2C0CLK   \",\n\t\"I2C1CLK   \",\n\t\"UART1CLK  \",\n\t\"MSPCLK0   \",\n\t\"USBCLK    \",\n\t\"DIFCLK    \",\n\t\"IPI2CCLK  \",\n\t\"IPBMCCLK  \",\n\t\"HSICLKRX  \",\n\t\"HSICLKTX  \",\n\t\"UART2CLK  \",\n\t\"MSPCLK1   \",\n\t\"MSPCLK2   \",\n\t\"OWMCLK    \",\n\t\"RESERVED  \",\n\t\"SKECLK    \",\n\t\"RESERVED  \",\n\t\"3DCLK     \",\n\t\"PCLKMSP3  \",\n\t\"MSPCLK3   \",\n\t\"MSHCCLK   \",\n\t\"USBMCLK   \",\n\t\"RNGCCLK   \",\n};\n\nstatic int nomadik_src_clk_debugfs_show(struct seq_file *s, void *what)\n{\n\tint i;\n\tu32 src_pcksr0 = readl(src_base + SRC_PCKSR0);\n\tu32 src_pcksr1 = readl(src_base + SRC_PCKSR1);\n\tu32 src_pckensr0 = readl(src_base + SRC_PCKENSR0);\n\tu32 src_pckensr1 = readl(src_base + SRC_PCKENSR1);\n\n\tseq_puts(s, \"Clock:      Boot:   Now:    Request: ASKED:\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(src_clk_names); i++) {\n\t\tu32 pcksrb = (i < 0x20) ? src_pcksr0_boot : src_pcksr1_boot;\n\t\tu32 pcksr = (i < 0x20) ? src_pcksr0 : src_pcksr1;\n\t\tu32 pckreq = (i < 0x20) ? src_pckensr0 : src_pckensr1;\n\t\tu32 mask = BIT(i & 0x1f);\n\n\t\tseq_printf(s, \"%s  %s     %s     %s\\n\",\n\t\t\t   src_clk_names[i],\n\t\t\t   (pcksrb & mask) ? \"on \" : \"off\",\n\t\t\t   (pcksr & mask) ? \"on \" : \"off\",\n\t\t\t   (pckreq & mask) ? \"on \" : \"off\");\n\t}\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(nomadik_src_clk_debugfs);\n\nstatic int __init nomadik_src_clk_init_debugfs(void)\n{\n\t \n\tif (!src_base)\n\t\treturn -ENODEV;\n\tsrc_pcksr0_boot = readl(src_base + SRC_PCKSR0);\n\tsrc_pcksr1_boot = readl(src_base + SRC_PCKSR1);\n\tdebugfs_create_file(\"nomadik-src-clk\", S_IFREG | S_IRUGO,\n\t\t\t    NULL, NULL, &nomadik_src_clk_debugfs_fops);\n\treturn 0;\n}\ndevice_initcall(nomadik_src_clk_init_debugfs);\n\n#endif\n\nstatic void __init of_nomadik_pll_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *clk_name = np->name;\n\tconst char *parent_name;\n\tu32 pll_id;\n\n\tif (!src_base)\n\t\tnomadik_src_init();\n\n\tif (of_property_read_u32(np, \"pll-id\", &pll_id)) {\n\t\tpr_err(\"%s: PLL \\\"%s\\\" missing pll-id property\\n\",\n\t\t\t__func__, clk_name);\n\t\treturn;\n\t}\n\tparent_name = of_clk_get_parent_name(np, 0);\n\thw = pll_clk_register(NULL, clk_name, parent_name, pll_id);\n\tif (!IS_ERR(hw))\n\t\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(nomadik_pll_clk,\n\t\"st,nomadik-pll-clock\", of_nomadik_pll_setup);\n\nstatic void __init of_nomadik_hclk_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *clk_name = np->name;\n\tconst char *parent_name;\n\n\tif (!src_base)\n\t\tnomadik_src_init();\n\n\tparent_name = of_clk_get_parent_name(np, 0);\n\t \n\thw = clk_hw_register_divider(NULL, clk_name, parent_name,\n\t\t\t   0, src_base + SRC_CR,\n\t\t\t   13, 2,\n\t\t\t   CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\n\t\t\t   &src_lock);\n\tif (!IS_ERR(hw))\n\t\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(nomadik_hclk_clk,\n\t\"st,nomadik-hclk-clock\", of_nomadik_hclk_setup);\n\nstatic void __init of_nomadik_src_clk_setup(struct device_node *np)\n{\n\tstruct clk_hw *hw;\n\tconst char *clk_name = np->name;\n\tconst char *parent_name;\n\tu32 clk_id;\n\n\tif (!src_base)\n\t\tnomadik_src_init();\n\n\tif (of_property_read_u32(np, \"clock-id\", &clk_id)) {\n\t\tpr_err(\"%s: SRC clock \\\"%s\\\" missing clock-id property\\n\",\n\t\t\t__func__, clk_name);\n\t\treturn;\n\t}\n\tparent_name = of_clk_get_parent_name(np, 0);\n\thw = src_clk_register(NULL, clk_name, parent_name, clk_id);\n\tif (!IS_ERR(hw))\n\t\tof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\n}\nCLK_OF_DECLARE(nomadik_src_clk,\n\t\"st,nomadik-src-clock\", of_nomadik_src_clk_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}