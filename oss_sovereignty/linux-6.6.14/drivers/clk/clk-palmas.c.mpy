{
  "module_name": "clk-palmas.c",
  "hash_id": "c6d09e05e5fbcac873c85a5b83154ef1087c827d59723751003d254f67130239",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-palmas.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/mfd/palmas.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define PALMAS_CLOCK_DT_EXT_CONTROL_ENABLE1\t1\n#define PALMAS_CLOCK_DT_EXT_CONTROL_ENABLE2\t2\n#define PALMAS_CLOCK_DT_EXT_CONTROL_NSLEEP\t3\n\nstruct palmas_clk32k_desc {\n\tconst char *clk_name;\n\tunsigned int control_reg;\n\tunsigned int enable_mask;\n\tunsigned int sleep_mask;\n\tunsigned int sleep_reqstr_id;\n\tint delay;\n};\n\nstruct palmas_clock_info {\n\tstruct device *dev;\n\tstruct clk_hw hw;\n\tstruct palmas *palmas;\n\tconst struct palmas_clk32k_desc *clk_desc;\n\tint ext_control_pin;\n};\n\nstatic inline struct palmas_clock_info *to_palmas_clks_info(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct palmas_clock_info, hw);\n}\n\nstatic unsigned long palmas_clks_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\treturn 32768;\n}\n\nstatic int palmas_clks_prepare(struct clk_hw *hw)\n{\n\tstruct palmas_clock_info *cinfo = to_palmas_clks_info(hw);\n\tint ret;\n\n\tret = palmas_update_bits(cinfo->palmas, PALMAS_RESOURCE_BASE,\n\t\t\t\t cinfo->clk_desc->control_reg,\n\t\t\t\t cinfo->clk_desc->enable_mask,\n\t\t\t\t cinfo->clk_desc->enable_mask);\n\tif (ret < 0)\n\t\tdev_err(cinfo->dev, \"Reg 0x%02x update failed, %d\\n\",\n\t\t\tcinfo->clk_desc->control_reg, ret);\n\telse if (cinfo->clk_desc->delay)\n\t\tudelay(cinfo->clk_desc->delay);\n\n\treturn ret;\n}\n\nstatic void palmas_clks_unprepare(struct clk_hw *hw)\n{\n\tstruct palmas_clock_info *cinfo = to_palmas_clks_info(hw);\n\tint ret;\n\n\t \n\tif (cinfo->ext_control_pin)\n\t\treturn;\n\n\tret = palmas_update_bits(cinfo->palmas, PALMAS_RESOURCE_BASE,\n\t\t\t\t cinfo->clk_desc->control_reg,\n\t\t\t\t cinfo->clk_desc->enable_mask, 0);\n\tif (ret < 0)\n\t\tdev_err(cinfo->dev, \"Reg 0x%02x update failed, %d\\n\",\n\t\t\tcinfo->clk_desc->control_reg, ret);\n}\n\nstatic int palmas_clks_is_prepared(struct clk_hw *hw)\n{\n\tstruct palmas_clock_info *cinfo = to_palmas_clks_info(hw);\n\tint ret;\n\tu32 val;\n\n\tif (cinfo->ext_control_pin)\n\t\treturn 1;\n\n\tret = palmas_read(cinfo->palmas, PALMAS_RESOURCE_BASE,\n\t\t\t  cinfo->clk_desc->control_reg, &val);\n\tif (ret < 0) {\n\t\tdev_err(cinfo->dev, \"Reg 0x%02x read failed, %d\\n\",\n\t\t\tcinfo->clk_desc->control_reg, ret);\n\t\treturn ret;\n\t}\n\treturn !!(val & cinfo->clk_desc->enable_mask);\n}\n\nstatic const struct clk_ops palmas_clks_ops = {\n\t.prepare\t= palmas_clks_prepare,\n\t.unprepare\t= palmas_clks_unprepare,\n\t.is_prepared\t= palmas_clks_is_prepared,\n\t.recalc_rate\t= palmas_clks_recalc_rate,\n};\n\nstruct palmas_clks_of_match_data {\n\tstruct clk_init_data init;\n\tconst struct palmas_clk32k_desc desc;\n};\n\nstatic const struct palmas_clks_of_match_data palmas_of_clk32kg = {\n\t.init = {\n\t\t.name = \"clk32kg\",\n\t\t.ops = &palmas_clks_ops,\n\t\t.flags = CLK_IGNORE_UNUSED,\n\t},\n\t.desc = {\n\t\t.clk_name = \"clk32kg\",\n\t\t.control_reg = PALMAS_CLK32KG_CTRL,\n\t\t.enable_mask = PALMAS_CLK32KG_CTRL_MODE_ACTIVE,\n\t\t.sleep_mask = PALMAS_CLK32KG_CTRL_MODE_SLEEP,\n\t\t.sleep_reqstr_id = PALMAS_EXTERNAL_REQSTR_ID_CLK32KG,\n\t\t.delay = 200,\n\t},\n};\n\nstatic const struct palmas_clks_of_match_data palmas_of_clk32kgaudio = {\n\t.init = {\n\t\t.name = \"clk32kgaudio\",\n\t\t.ops = &palmas_clks_ops,\n\t\t.flags = CLK_IGNORE_UNUSED,\n\t},\n\t.desc = {\n\t\t.clk_name = \"clk32kgaudio\",\n\t\t.control_reg = PALMAS_CLK32KGAUDIO_CTRL,\n\t\t.enable_mask = PALMAS_CLK32KG_CTRL_MODE_ACTIVE,\n\t\t.sleep_mask = PALMAS_CLK32KG_CTRL_MODE_SLEEP,\n\t\t.sleep_reqstr_id = PALMAS_EXTERNAL_REQSTR_ID_CLK32KGAUDIO,\n\t\t.delay = 200,\n\t},\n};\n\nstatic const struct of_device_id palmas_clks_of_match[] = {\n\t{\n\t\t.compatible = \"ti,palmas-clk32kg\",\n\t\t.data = &palmas_of_clk32kg,\n\t},\n\t{\n\t\t.compatible = \"ti,palmas-clk32kgaudio\",\n\t\t.data = &palmas_of_clk32kgaudio,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, palmas_clks_of_match);\n\nstatic void palmas_clks_get_clk_data(struct platform_device *pdev,\n\t\t\t\t     struct palmas_clock_info *cinfo)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tunsigned int prop;\n\tint ret;\n\n\tret = of_property_read_u32(node, \"ti,external-sleep-control\",\n\t\t\t\t   &prop);\n\tif (ret)\n\t\treturn;\n\n\tswitch (prop) {\n\tcase PALMAS_CLOCK_DT_EXT_CONTROL_ENABLE1:\n\t\tprop = PALMAS_EXT_CONTROL_ENABLE1;\n\t\tbreak;\n\tcase PALMAS_CLOCK_DT_EXT_CONTROL_ENABLE2:\n\t\tprop = PALMAS_EXT_CONTROL_ENABLE2;\n\t\tbreak;\n\tcase PALMAS_CLOCK_DT_EXT_CONTROL_NSLEEP:\n\t\tprop = PALMAS_EXT_CONTROL_NSLEEP;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&pdev->dev, \"%pOFn: Invalid ext control option: %u\\n\",\n\t\t\t node, prop);\n\t\tprop = 0;\n\t\tbreak;\n\t}\n\tcinfo->ext_control_pin = prop;\n}\n\nstatic int palmas_clks_init_configure(struct palmas_clock_info *cinfo)\n{\n\tint ret;\n\n\tret = palmas_update_bits(cinfo->palmas, PALMAS_RESOURCE_BASE,\n\t\t\t\t cinfo->clk_desc->control_reg,\n\t\t\t\t cinfo->clk_desc->sleep_mask, 0);\n\tif (ret < 0) {\n\t\tdev_err(cinfo->dev, \"Reg 0x%02x update failed, %d\\n\",\n\t\t\tcinfo->clk_desc->control_reg, ret);\n\t\treturn ret;\n\t}\n\n\tif (cinfo->ext_control_pin) {\n\t\tret = clk_prepare(cinfo->hw.clk);\n\t\tif (ret < 0) {\n\t\t\tdev_err(cinfo->dev, \"Clock prep failed, %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = palmas_ext_control_req_config(cinfo->palmas,\n\t\t\t\t\tcinfo->clk_desc->sleep_reqstr_id,\n\t\t\t\t\tcinfo->ext_control_pin, true);\n\t\tif (ret < 0) {\n\t\t\tdev_err(cinfo->dev, \"Ext config for %s failed, %d\\n\",\n\t\t\t\tcinfo->clk_desc->clk_name, ret);\n\t\t\tclk_unprepare(cinfo->hw.clk);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\nstatic int palmas_clks_probe(struct platform_device *pdev)\n{\n\tstruct palmas *palmas = dev_get_drvdata(pdev->dev.parent);\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst struct palmas_clks_of_match_data *match_data;\n\tstruct palmas_clock_info *cinfo;\n\tint ret;\n\n\tmatch_data = of_device_get_match_data(&pdev->dev);\n\tif (!match_data)\n\t\treturn 1;\n\n\tcinfo = devm_kzalloc(&pdev->dev, sizeof(*cinfo), GFP_KERNEL);\n\tif (!cinfo)\n\t\treturn -ENOMEM;\n\n\tpalmas_clks_get_clk_data(pdev, cinfo);\n\tplatform_set_drvdata(pdev, cinfo);\n\n\tcinfo->dev = &pdev->dev;\n\tcinfo->palmas = palmas;\n\n\tcinfo->clk_desc = &match_data->desc;\n\tcinfo->hw.init = &match_data->init;\n\tret = devm_clk_hw_register(&pdev->dev, &cinfo->hw);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Fail to register clock %s, %d\\n\",\n\t\t\tmatch_data->desc.clk_name, ret);\n\t\treturn ret;\n\t}\n\n\tret = palmas_clks_init_configure(cinfo);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Clock config failed, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = of_clk_add_hw_provider(node, of_clk_hw_simple_get, &cinfo->hw);\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"Fail to add clock driver, %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void palmas_clks_remove(struct platform_device *pdev)\n{\n\tof_clk_del_provider(pdev->dev.of_node);\n}\n\nstatic struct platform_driver palmas_clks_driver = {\n\t.driver = {\n\t\t.name = \"palmas-clk\",\n\t\t.of_match_table = palmas_clks_of_match,\n\t},\n\t.probe = palmas_clks_probe,\n\t.remove_new = palmas_clks_remove,\n};\n\nmodule_platform_driver(palmas_clks_driver);\n\nMODULE_DESCRIPTION(\"Clock driver for Palmas Series Devices\");\nMODULE_ALIAS(\"platform:palmas-clk\");\nMODULE_AUTHOR(\"Peter Ujfalusi <peter.ujfalusi@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}