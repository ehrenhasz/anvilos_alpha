{
  "module_name": "clk-of-pxa168.c",
  "hash_id": "43bdbb0ddbdf01262425ca782c09179737795fc140f6d79897b4c3fc7ec68e21",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mmp/clk-of-pxa168.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/of_address.h>\n\n#include <dt-bindings/clock/marvell,pxa168.h>\n\n#include \"clk.h\"\n#include \"reset.h\"\n\n#define APBC_UART0\t0x0\n#define APBC_UART1\t0x4\n#define APBC_GPIO\t0x8\n#define APBC_PWM0\t0xc\n#define APBC_PWM1\t0x10\n#define APBC_PWM2\t0x14\n#define APBC_PWM3\t0x18\n#define APBC_RTC\t0x28\n#define APBC_TWSI0\t0x2c\n#define APBC_KPC\t0x30\n#define APBC_TIMER\t0x34\n#define APBC_AIB\t0x3c\n#define APBC_SW_JTAG\t0x40\n#define APBC_ONEWIRE\t0x48\n#define APBC_TWSI1\t0x6c\n#define APBC_UART2\t0x70\n#define APBC_AC97\t0x84\n#define APBC_SSP0\t0x81c\n#define APBC_SSP1\t0x820\n#define APBC_SSP2\t0x84c\n#define APBC_SSP3\t0x858\n#define APBC_SSP4\t0x85c\n#define APMU_DISP0\t0x4c\n#define APMU_CCIC0\t0x50\n#define APMU_SDH0\t0x54\n#define APMU_SDH1\t0x58\n#define APMU_USB\t0x5c\n#define APMU_DFC\t0x60\n#define APMU_DMA\t0x64\n#define APMU_BUS\t0x6c\n#define APMU_GC\t\t0xcc\n#define APMU_SMC\t0xd4\n#define APMU_XD\t\t0xdc\n#define APMU_SDH2\t0xe0\n#define APMU_SDH3\t0xe4\n#define APMU_CF\t\t0xf0\n#define APMU_MSP\t0xf4\n#define APMU_CMU\t0xf8\n#define APMU_FE\t\t0xfc\n#define APMU_PCIE\t0x100\n#define APMU_EPD\t0x104\n#define MPMU_UART_PLL\t0x14\n\n#define NR_CLKS\t\t200\n\nstruct pxa168_clk_unit {\n\tstruct mmp_clk_unit unit;\n\tvoid __iomem *mpmu_base;\n\tvoid __iomem *apmu_base;\n\tvoid __iomem *apbc_base;\n};\n\nstatic struct mmp_param_fixed_rate_clk fixed_rate_clks[] = {\n\t{PXA168_CLK_CLK32, \"clk32\", NULL, 0, 32768},\n\t{PXA168_CLK_VCTCXO, \"vctcxo\", NULL, 0, 26000000},\n\t{PXA168_CLK_PLL1, \"pll1\", NULL, 0, 624000000},\n\t{PXA168_CLK_USB_PLL, \"usb_pll\", NULL, 0, 480000000},\n};\n\nstatic struct mmp_param_fixed_factor_clk fixed_factor_clks[] = {\n\t{PXA168_CLK_PLL1_2, \"pll1_2\", \"pll1\", 1, 2, 0},\n\t{PXA168_CLK_PLL1_4, \"pll1_4\", \"pll1_2\", 1, 2, 0},\n\t{PXA168_CLK_PLL1_8, \"pll1_8\", \"pll1_4\", 1, 2, 0},\n\t{PXA168_CLK_PLL1_16, \"pll1_16\", \"pll1_8\", 1, 2, 0},\n\t{PXA168_CLK_PLL1_6, \"pll1_6\", \"pll1_2\", 1, 3, 0},\n\t{PXA168_CLK_PLL1_12, \"pll1_12\", \"pll1_6\", 1, 2, 0},\n\t{PXA168_CLK_PLL1_24, \"pll1_24\", \"pll1_12\", 1, 2, 0},\n\t{PXA168_CLK_PLL1_48, \"pll1_48\", \"pll1_24\", 1, 2, 0},\n\t{PXA168_CLK_PLL1_96, \"pll1_96\", \"pll1_48\", 1, 2, 0},\n\t{PXA168_CLK_PLL1_192, \"pll1_192\", \"pll1_96\", 1, 2, 0},\n\t{PXA168_CLK_PLL1_13, \"pll1_13\", \"pll1\", 1, 13, 0},\n\t{PXA168_CLK_PLL1_13_1_5, \"pll1_13_1_5\", \"pll1_13\", 1, 5, 0},\n\t{PXA168_CLK_PLL1_2_1_5, \"pll1_2_1_5\", \"pll1_2\", 1, 5, 0},\n\t{PXA168_CLK_PLL1_3_16, \"pll1_3_16\", \"pll1\", 3, 16, 0},\n\t{PXA168_CLK_PLL1_2_1_10, \"pll1_2_1_10\", \"pll1_2\", 1, 10, 0},\n\t{PXA168_CLK_PLL1_2_3_16, \"pll1_2_3_16\", \"pll1_2\", 3, 16, 0},\n\t{PXA168_CLK_CLK32_2, \"clk32_2\", \"clk32\", 1, 2, 0},\n};\n\nstatic struct mmp_clk_factor_masks uart_factor_masks = {\n\t.factor = 2,\n\t.num_mask = 0x1fff,\n\t.den_mask = 0x1fff,\n\t.num_shift = 16,\n\t.den_shift = 0,\n};\n\nstatic struct mmp_clk_factor_tbl uart_factor_tbl[] = {\n\t{.num = 8125, .den = 1536},\t \n};\n\nstatic void pxa168_pll_init(struct pxa168_clk_unit *pxa_unit)\n{\n\tstruct clk *clk;\n\tstruct mmp_clk_unit *unit = &pxa_unit->unit;\n\n\tmmp_register_fixed_rate_clks(unit, fixed_rate_clks,\n\t\t\t\t\tARRAY_SIZE(fixed_rate_clks));\n\n\tmmp_register_fixed_factor_clks(unit, fixed_factor_clks,\n\t\t\t\t\tARRAY_SIZE(fixed_factor_clks));\n\n\tclk = mmp_clk_register_factor(\"uart_pll\", \"pll1_4\",\n\t\t\t\tCLK_SET_RATE_PARENT,\n\t\t\t\tpxa_unit->mpmu_base + MPMU_UART_PLL,\n\t\t\t\t&uart_factor_masks, uart_factor_tbl,\n\t\t\t\tARRAY_SIZE(uart_factor_tbl), NULL);\n\tmmp_clk_add(unit, PXA168_CLK_UART_PLL, clk);\n}\n\nstatic DEFINE_SPINLOCK(twsi0_lock);\nstatic DEFINE_SPINLOCK(twsi1_lock);\nstatic const char * const twsi_parent_names[] = {\"pll1_2_1_10\", \"pll1_2_1_5\"};\n\nstatic DEFINE_SPINLOCK(kpc_lock);\nstatic const char * const kpc_parent_names[] = {\"clk32\", \"clk32_2\", \"pll1_24\"};\n\nstatic DEFINE_SPINLOCK(pwm0_lock);\nstatic DEFINE_SPINLOCK(pwm1_lock);\nstatic DEFINE_SPINLOCK(pwm2_lock);\nstatic DEFINE_SPINLOCK(pwm3_lock);\nstatic const char * const pwm_parent_names[] = {\"pll1_48\", \"clk32\"};\n\nstatic DEFINE_SPINLOCK(uart0_lock);\nstatic DEFINE_SPINLOCK(uart1_lock);\nstatic DEFINE_SPINLOCK(uart2_lock);\nstatic const char * const uart_parent_names[] = {\"pll1_2_3_16\", \"uart_pll\"};\n\nstatic DEFINE_SPINLOCK(ssp0_lock);\nstatic DEFINE_SPINLOCK(ssp1_lock);\nstatic DEFINE_SPINLOCK(ssp2_lock);\nstatic DEFINE_SPINLOCK(ssp3_lock);\nstatic DEFINE_SPINLOCK(ssp4_lock);\nstatic const char * const ssp_parent_names[] = {\"pll1_96\", \"pll1_48\", \"pll1_24\", \"pll1_12\"};\n\nstatic DEFINE_SPINLOCK(timer_lock);\nstatic const char * const timer_parent_names[] = {\"pll1_48\", \"clk32\", \"pll1_96\", \"pll1_192\"};\n\nstatic DEFINE_SPINLOCK(reset_lock);\n\nstatic struct mmp_param_mux_clk apbc_mux_clks[] = {\n\t{0, \"twsi0_mux\", twsi_parent_names, ARRAY_SIZE(twsi_parent_names), CLK_SET_RATE_PARENT, APBC_TWSI0, 4, 3, 0, &twsi0_lock},\n\t{0, \"twsi1_mux\", twsi_parent_names, ARRAY_SIZE(twsi_parent_names), CLK_SET_RATE_PARENT, APBC_TWSI1, 4, 3, 0, &twsi1_lock},\n\t{0, \"kpc_mux\", kpc_parent_names, ARRAY_SIZE(kpc_parent_names), CLK_SET_RATE_PARENT, APBC_KPC, 4, 3, 0, &kpc_lock},\n\t{0, \"pwm0_mux\", pwm_parent_names, ARRAY_SIZE(pwm_parent_names), CLK_SET_RATE_PARENT, APBC_PWM0, 4, 3, 0, &pwm0_lock},\n\t{0, \"pwm1_mux\", pwm_parent_names, ARRAY_SIZE(pwm_parent_names), CLK_SET_RATE_PARENT, APBC_PWM1, 4, 3, 0, &pwm1_lock},\n\t{0, \"pwm2_mux\", pwm_parent_names, ARRAY_SIZE(pwm_parent_names), CLK_SET_RATE_PARENT, APBC_PWM2, 4, 3, 0, &pwm2_lock},\n\t{0, \"pwm3_mux\", pwm_parent_names, ARRAY_SIZE(pwm_parent_names), CLK_SET_RATE_PARENT, APBC_PWM3, 4, 3, 0, &pwm3_lock},\n\t{0, \"uart0_mux\", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, APBC_UART0, 4, 3, 0, &uart0_lock},\n\t{0, \"uart1_mux\", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, APBC_UART1, 4, 3, 0, &uart1_lock},\n\t{0, \"uart2_mux\", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, APBC_UART2, 4, 3, 0, &uart2_lock},\n\t{0, \"ssp0_mux\", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), CLK_SET_RATE_PARENT, APBC_SSP0, 4, 3, 0, &ssp0_lock},\n\t{0, \"ssp1_mux\", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), CLK_SET_RATE_PARENT, APBC_SSP1, 4, 3, 0, &ssp1_lock},\n\t{0, \"ssp2_mux\", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), CLK_SET_RATE_PARENT, APBC_SSP2, 4, 3, 0, &ssp2_lock},\n\t{0, \"ssp3_mux\", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), CLK_SET_RATE_PARENT, APBC_SSP3, 4, 3, 0, &ssp3_lock},\n\t{0, \"ssp4_mux\", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), CLK_SET_RATE_PARENT, APBC_SSP4, 4, 3, 0, &ssp4_lock},\n\t{0, \"timer_mux\", timer_parent_names, ARRAY_SIZE(timer_parent_names), CLK_SET_RATE_PARENT, APBC_TIMER, 4, 3, 0, &timer_lock},\n};\n\nstatic struct mmp_param_gate_clk apbc_gate_clks[] = {\n\t{PXA168_CLK_TWSI0, \"twsi0_clk\", \"twsi0_mux\", CLK_SET_RATE_PARENT, APBC_TWSI0, 0x3, 0x3, 0x0, 0, &twsi0_lock},\n\t{PXA168_CLK_TWSI1, \"twsi1_clk\", \"twsi1_mux\", CLK_SET_RATE_PARENT, APBC_TWSI1, 0x3, 0x3, 0x0, 0, &twsi1_lock},\n\t{PXA168_CLK_GPIO, \"gpio_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, APBC_GPIO, 0x1, 0x1, 0x0, 0, &reset_lock},\n\t{PXA168_CLK_KPC, \"kpc_clk\", \"kpc_mux\", CLK_SET_RATE_PARENT, APBC_KPC, 0x3, 0x3, 0x0, MMP_CLK_GATE_NEED_DELAY, &kpc_lock},\n\t{PXA168_CLK_RTC, \"rtc_clk\", \"clk32\", CLK_SET_RATE_PARENT, APBC_RTC, 0x83, 0x83, 0x0, MMP_CLK_GATE_NEED_DELAY, NULL},\n\t{PXA168_CLK_PWM0, \"pwm0_clk\", \"pwm0_mux\", CLK_SET_RATE_PARENT, APBC_PWM0, 0x3, 0x3, 0x0, 0, &pwm0_lock},\n\t{PXA168_CLK_PWM1, \"pwm1_clk\", \"pwm1_mux\", CLK_SET_RATE_PARENT, APBC_PWM1, 0x3, 0x3, 0x0, 0, &pwm1_lock},\n\t{PXA168_CLK_PWM2, \"pwm2_clk\", \"pwm2_mux\", CLK_SET_RATE_PARENT, APBC_PWM2, 0x3, 0x3, 0x0, 0, &pwm2_lock},\n\t{PXA168_CLK_PWM3, \"pwm3_clk\", \"pwm3_mux\", CLK_SET_RATE_PARENT, APBC_PWM3, 0x3, 0x3, 0x0, 0, &pwm3_lock},\n\t{PXA168_CLK_UART0, \"uart0_clk\", \"uart0_mux\", CLK_SET_RATE_PARENT, APBC_UART0, 0x3, 0x3, 0x0, 0, &uart0_lock},\n\t{PXA168_CLK_UART1, \"uart1_clk\", \"uart1_mux\", CLK_SET_RATE_PARENT, APBC_UART1, 0x3, 0x3, 0x0, 0, &uart1_lock},\n\t{PXA168_CLK_UART2, \"uart2_clk\", \"uart2_mux\", CLK_SET_RATE_PARENT, APBC_UART2, 0x3, 0x3, 0x0, 0, &uart2_lock},\n\t{PXA168_CLK_SSP0, \"ssp0_clk\", \"ssp0_mux\", CLK_SET_RATE_PARENT, APBC_SSP0, 0x3, 0x3, 0x0, 0, &ssp0_lock},\n\t{PXA168_CLK_SSP1, \"ssp1_clk\", \"ssp1_mux\", CLK_SET_RATE_PARENT, APBC_SSP1, 0x3, 0x3, 0x0, 0, &ssp1_lock},\n\t{PXA168_CLK_SSP2, \"ssp2_clk\", \"ssp2_mux\", CLK_SET_RATE_PARENT, APBC_SSP2, 0x3, 0x3, 0x0, 0, &ssp2_lock},\n\t{PXA168_CLK_SSP3, \"ssp3_clk\", \"ssp3_mux\", CLK_SET_RATE_PARENT, APBC_SSP3, 0x3, 0x3, 0x0, 0, &ssp3_lock},\n\t{PXA168_CLK_SSP4, \"ssp4_clk\", \"ssp4_mux\", CLK_SET_RATE_PARENT, APBC_SSP4, 0x3, 0x3, 0x0, 0, &ssp4_lock},\n\t{PXA168_CLK_TIMER, \"timer_clk\", \"timer_mux\", CLK_SET_RATE_PARENT, APBC_TIMER, 0x3, 0x3, 0x0, 0, &timer_lock},\n};\n\nstatic void pxa168_apb_periph_clk_init(struct pxa168_clk_unit *pxa_unit)\n{\n\tstruct mmp_clk_unit *unit = &pxa_unit->unit;\n\n\tmmp_register_mux_clks(unit, apbc_mux_clks, pxa_unit->apbc_base,\n\t\t\t\tARRAY_SIZE(apbc_mux_clks));\n\n\tmmp_register_gate_clks(unit, apbc_gate_clks, pxa_unit->apbc_base,\n\t\t\t\tARRAY_SIZE(apbc_gate_clks));\n\n}\n\nstatic DEFINE_SPINLOCK(dfc_lock);\nstatic const char * const dfc_parent_names[] = {\"pll1_4\", \"pll1_8\"};\n\nstatic DEFINE_SPINLOCK(sdh0_lock);\nstatic DEFINE_SPINLOCK(sdh1_lock);\nstatic DEFINE_SPINLOCK(sdh2_lock);\nstatic DEFINE_SPINLOCK(sdh3_lock);\nstatic const char * const sdh_parent_names[] = {\"pll1_13\", \"pll1_12\", \"pll1_8\"};\n\nstatic DEFINE_SPINLOCK(usb_lock);\n\nstatic DEFINE_SPINLOCK(disp0_lock);\nstatic const char * const disp_parent_names[] = {\"pll1\", \"pll1_2\"};\n\nstatic DEFINE_SPINLOCK(ccic0_lock);\nstatic const char * const ccic_parent_names[] = {\"pll1_4\", \"pll1_8\"};\nstatic const char * const ccic_phy_parent_names[] = {\"pll1_6\", \"pll1_12\"};\n\nstatic struct mmp_param_mux_clk apmu_mux_clks[] = {\n\t{0, \"dfc_mux\", dfc_parent_names, ARRAY_SIZE(dfc_parent_names), CLK_SET_RATE_PARENT, APMU_DFC, 6, 1, 0, &dfc_lock},\n\t{0, \"sdh0_mux\", sdh_parent_names, ARRAY_SIZE(sdh_parent_names), CLK_SET_RATE_PARENT, APMU_SDH0, 6, 2, 0, &sdh0_lock},\n\t{0, \"sdh1_mux\", sdh_parent_names, ARRAY_SIZE(sdh_parent_names), CLK_SET_RATE_PARENT, APMU_SDH1, 6, 2, 0, &sdh1_lock},\n\t{0, \"sdh2_mux\", sdh_parent_names, ARRAY_SIZE(sdh_parent_names), CLK_SET_RATE_PARENT, APMU_SDH2, 6, 2, 0, &sdh2_lock},\n\t{0, \"sdh3_mux\", sdh_parent_names, ARRAY_SIZE(sdh_parent_names), CLK_SET_RATE_PARENT, APMU_SDH3, 6, 2, 0, &sdh3_lock},\n\t{0, \"disp0_mux\", disp_parent_names, ARRAY_SIZE(disp_parent_names), CLK_SET_RATE_PARENT, APMU_DISP0, 6, 1, 0, &disp0_lock},\n\t{0, \"ccic0_mux\", ccic_parent_names, ARRAY_SIZE(ccic_parent_names), CLK_SET_RATE_PARENT, APMU_CCIC0, 6, 1, 0, &ccic0_lock},\n\t{0, \"ccic0_phy_mux\", ccic_phy_parent_names, ARRAY_SIZE(ccic_phy_parent_names), CLK_SET_RATE_PARENT, APMU_CCIC0, 7, 1, 0, &ccic0_lock},\n};\n\nstatic struct mmp_param_div_clk apmu_div_clks[] = {\n\t{0, \"ccic0_sphy_div\", \"ccic0_mux\", CLK_SET_RATE_PARENT, APMU_CCIC0, 10, 5, 0, &ccic0_lock},\n};\n\nstatic struct mmp_param_gate_clk apmu_gate_clks[] = {\n\t{PXA168_CLK_DFC, \"dfc_clk\", \"dfc_mux\", CLK_SET_RATE_PARENT, APMU_DFC, 0x19b, 0x19b, 0x0, 0, &dfc_lock},\n\t{PXA168_CLK_USB, \"usb_clk\", \"usb_pll\", 0, APMU_USB, 0x9, 0x9, 0x0, 0, &usb_lock},\n\t{PXA168_CLK_SPH, \"sph_clk\", \"usb_pll\", 0, APMU_USB, 0x12, 0x12, 0x0, 0, &usb_lock},\n\t{PXA168_CLK_SDH0, \"sdh0_clk\", \"sdh0_mux\", CLK_SET_RATE_PARENT, APMU_SDH0, 0x12, 0x12, 0x0, 0, &sdh0_lock},\n\t{PXA168_CLK_SDH1, \"sdh1_clk\", \"sdh1_mux\", CLK_SET_RATE_PARENT, APMU_SDH1, 0x12, 0x12, 0x0, 0, &sdh1_lock},\n\t{PXA168_CLK_SDH2, \"sdh2_clk\", \"sdh2_mux\", CLK_SET_RATE_PARENT, APMU_SDH2, 0x12, 0x12, 0x0, 0, &sdh2_lock},\n\t{PXA168_CLK_SDH3, \"sdh3_clk\", \"sdh3_mux\", CLK_SET_RATE_PARENT, APMU_SDH3, 0x12, 0x12, 0x0, 0, &sdh3_lock},\n\t \n\t{PXA168_CLK_SDH01_AXI, \"sdh01_axi_clk\", NULL, CLK_SET_RATE_PARENT, APMU_SDH0, 0x9, 0x9, 0x0, 0, &sdh0_lock},\n\t{PXA168_CLK_SDH23_AXI, \"sdh23_axi_clk\", NULL, CLK_SET_RATE_PARENT, APMU_SDH2, 0x9, 0x9, 0x0, 0, &sdh2_lock},\n\t{PXA168_CLK_DISP0, \"disp0_clk\", \"disp0_mux\", CLK_SET_RATE_PARENT, APMU_DISP0, 0x1b, 0x1b, 0x0, 0, &disp0_lock},\n\t{PXA168_CLK_CCIC0, \"ccic0_clk\", \"ccic0_mux\", CLK_SET_RATE_PARENT, APMU_CCIC0, 0x1b, 0x1b, 0x0, 0, &ccic0_lock},\n\t{PXA168_CLK_CCIC0_PHY, \"ccic0_phy_clk\", \"ccic0_phy_mux\", CLK_SET_RATE_PARENT, APMU_CCIC0, 0x24, 0x24, 0x0, 0, &ccic0_lock},\n\t{PXA168_CLK_CCIC0_SPHY, \"ccic0_sphy_clk\", \"ccic0_sphy_div\", CLK_SET_RATE_PARENT, APMU_CCIC0, 0x300, 0x300, 0x0, 0, &ccic0_lock},\n};\n\nstatic void pxa168_axi_periph_clk_init(struct pxa168_clk_unit *pxa_unit)\n{\n\tstruct mmp_clk_unit *unit = &pxa_unit->unit;\n\n\tmmp_register_mux_clks(unit, apmu_mux_clks, pxa_unit->apmu_base,\n\t\t\t\tARRAY_SIZE(apmu_mux_clks));\n\n\tmmp_register_div_clks(unit, apmu_div_clks, pxa_unit->apmu_base,\n\t\t\t\tARRAY_SIZE(apmu_div_clks));\n\n\tmmp_register_gate_clks(unit, apmu_gate_clks, pxa_unit->apmu_base,\n\t\t\t\tARRAY_SIZE(apmu_gate_clks));\n}\n\nstatic void pxa168_clk_reset_init(struct device_node *np,\n\t\t\t\tstruct pxa168_clk_unit *pxa_unit)\n{\n\tstruct mmp_clk_reset_cell *cells;\n\tint i, nr_resets;\n\n\tnr_resets = ARRAY_SIZE(apbc_gate_clks);\n\tcells = kcalloc(nr_resets, sizeof(*cells), GFP_KERNEL);\n\tif (!cells)\n\t\treturn;\n\n\tfor (i = 0; i < nr_resets; i++) {\n\t\tcells[i].clk_id = apbc_gate_clks[i].id;\n\t\tcells[i].reg = pxa_unit->apbc_base + apbc_gate_clks[i].offset;\n\t\tcells[i].flags = 0;\n\t\tcells[i].lock = apbc_gate_clks[i].lock;\n\t\tcells[i].bits = 0x4;\n\t}\n\n\tmmp_clk_reset_register(np, cells, nr_resets);\n}\n\nstatic void __init pxa168_clk_init(struct device_node *np)\n{\n\tstruct pxa168_clk_unit *pxa_unit;\n\n\tpxa_unit = kzalloc(sizeof(*pxa_unit), GFP_KERNEL);\n\tif (!pxa_unit)\n\t\treturn;\n\n\tpxa_unit->mpmu_base = of_iomap(np, 0);\n\tif (!pxa_unit->mpmu_base) {\n\t\tpr_err(\"failed to map mpmu registers\\n\");\n\t\treturn;\n\t}\n\n\tpxa_unit->apmu_base = of_iomap(np, 1);\n\tif (!pxa_unit->apmu_base) {\n\t\tpr_err(\"failed to map apmu registers\\n\");\n\t\treturn;\n\t}\n\n\tpxa_unit->apbc_base = of_iomap(np, 2);\n\tif (!pxa_unit->apbc_base) {\n\t\tpr_err(\"failed to map apbc registers\\n\");\n\t\treturn;\n\t}\n\n\tmmp_clk_init(np, &pxa_unit->unit, NR_CLKS);\n\n\tpxa168_pll_init(pxa_unit);\n\n\tpxa168_apb_periph_clk_init(pxa_unit);\n\n\tpxa168_axi_periph_clk_init(pxa_unit);\n\n\tpxa168_clk_reset_init(np, pxa_unit);\n}\n\nCLK_OF_DECLARE(pxa168_clk, \"marvell,pxa168-clock\", pxa168_clk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}