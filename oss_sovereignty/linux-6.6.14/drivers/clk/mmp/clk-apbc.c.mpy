{
  "module_name": "clk-apbc.c",
  "hash_id": "eb734426eba8ac528bbfe6568654ce80799f44e4bacc516db2a9772657ecbc61",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mmp/clk-apbc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\n \n#define APBC_APBCLK\t(1 << 0)   \n#define APBC_FNCLK\t(1 << 1)   \n#define APBC_RST\t(1 << 2)   \n#define APBC_POWER\t(1 << 7)   \n\n#define to_clk_apbc(hw) container_of(hw, struct clk_apbc, hw)\nstruct clk_apbc {\n\tstruct clk_hw\t\thw;\n\tvoid __iomem\t\t*base;\n\tunsigned int\t\tdelay;\n\tunsigned int\t\tflags;\n\tspinlock_t\t\t*lock;\n};\n\nstatic int clk_apbc_prepare(struct clk_hw *hw)\n{\n\tstruct clk_apbc *apbc = to_clk_apbc(hw);\n\tunsigned int data;\n\tunsigned long flags = 0;\n\n\t \n\tif (apbc->lock)\n\t\tspin_lock_irqsave(apbc->lock, flags);\n\n\tdata = readl_relaxed(apbc->base);\n\tif (apbc->flags & APBC_POWER_CTRL)\n\t\tdata |= APBC_POWER;\n\tdata |= APBC_FNCLK;\n\twritel_relaxed(data, apbc->base);\n\n\tif (apbc->lock)\n\t\tspin_unlock_irqrestore(apbc->lock, flags);\n\n\tudelay(apbc->delay);\n\n\tif (apbc->lock)\n\t\tspin_lock_irqsave(apbc->lock, flags);\n\n\tdata = readl_relaxed(apbc->base);\n\tdata |= APBC_APBCLK;\n\twritel_relaxed(data, apbc->base);\n\n\tif (apbc->lock)\n\t\tspin_unlock_irqrestore(apbc->lock, flags);\n\n\tudelay(apbc->delay);\n\n\tif (!(apbc->flags & APBC_NO_BUS_CTRL)) {\n\t\tif (apbc->lock)\n\t\t\tspin_lock_irqsave(apbc->lock, flags);\n\n\t\tdata = readl_relaxed(apbc->base);\n\t\tdata &= ~APBC_RST;\n\t\twritel_relaxed(data, apbc->base);\n\n\t\tif (apbc->lock)\n\t\t\tspin_unlock_irqrestore(apbc->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic void clk_apbc_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_apbc *apbc = to_clk_apbc(hw);\n\tunsigned long data;\n\tunsigned long flags = 0;\n\n\tif (apbc->lock)\n\t\tspin_lock_irqsave(apbc->lock, flags);\n\n\tdata = readl_relaxed(apbc->base);\n\tif (apbc->flags & APBC_POWER_CTRL)\n\t\tdata &= ~APBC_POWER;\n\tdata &= ~APBC_FNCLK;\n\twritel_relaxed(data, apbc->base);\n\n\tif (apbc->lock)\n\t\tspin_unlock_irqrestore(apbc->lock, flags);\n\n\tudelay(10);\n\n\tif (apbc->lock)\n\t\tspin_lock_irqsave(apbc->lock, flags);\n\n\tdata = readl_relaxed(apbc->base);\n\tdata &= ~APBC_APBCLK;\n\twritel_relaxed(data, apbc->base);\n\n\tif (apbc->lock)\n\t\tspin_unlock_irqrestore(apbc->lock, flags);\n}\n\nstatic const struct clk_ops clk_apbc_ops = {\n\t.prepare = clk_apbc_prepare,\n\t.unprepare = clk_apbc_unprepare,\n};\n\nstruct clk *mmp_clk_register_apbc(const char *name, const char *parent_name,\n\t\tvoid __iomem *base, unsigned int delay,\n\t\tunsigned int apbc_flags, spinlock_t *lock)\n{\n\tstruct clk_apbc *apbc;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\tapbc = kzalloc(sizeof(*apbc), GFP_KERNEL);\n\tif (!apbc)\n\t\treturn NULL;\n\n\tinit.name = name;\n\tinit.ops = &clk_apbc_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\n\tapbc->base = base;\n\tapbc->delay = delay;\n\tapbc->flags = apbc_flags;\n\tapbc->lock = lock;\n\tapbc->hw.init = &init;\n\n\tclk = clk_register(NULL, &apbc->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(apbc);\n\n\treturn clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}