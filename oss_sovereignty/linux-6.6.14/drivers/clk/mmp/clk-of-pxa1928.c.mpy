{
  "module_name": "clk-of-pxa1928.c",
  "hash_id": "8dcff05559a2cad59eed0804e17fcc836994568d1b8e2fdd250714cb5d802b5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mmp/clk-of-pxa1928.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <dt-bindings/clock/marvell,pxa1928.h>\n\n#include \"clk.h\"\n#include \"reset.h\"\n\n#define MPMU_UART_PLL\t0x14\n\n#define APBC_NR_CLKS\t48\n#define APMU_NR_CLKS\t96\n\nstruct pxa1928_clk_unit {\n\tstruct mmp_clk_unit unit;\n\tvoid __iomem *mpmu_base;\n\tvoid __iomem *apmu_base;\n\tvoid __iomem *apbc_base;\n\tvoid __iomem *apbcp_base;\n};\n\nstatic struct mmp_param_fixed_rate_clk fixed_rate_clks[] = {\n\t{0, \"clk32\", NULL, 0, 32768},\n\t{0, \"vctcxo\", NULL, 0, 26000000},\n\t{0, \"pll1_624\", NULL, 0, 624000000},\n\t{0, \"pll5p\", NULL, 0, 832000000},\n\t{0, \"pll5\", NULL, 0, 1248000000},\n\t{0, \"usb_pll\", NULL, 0, 480000000},\n};\n\nstatic struct mmp_param_fixed_factor_clk fixed_factor_clks[] = {\n\t{0, \"pll1_d2\", \"pll1_624\", 1, 2, 0},\n\t{0, \"pll1_d9\", \"pll1_624\", 1, 9, 0},\n\t{0, \"pll1_d12\", \"pll1_624\", 1, 12, 0},\n\t{0, \"pll1_d16\", \"pll1_624\", 1, 16, 0},\n\t{0, \"pll1_d20\", \"pll1_624\", 1, 20, 0},\n\t{0, \"pll1_416\", \"pll1_624\", 2, 3, 0},\n\t{0, \"vctcxo_d2\", \"vctcxo\", 1, 2, 0},\n\t{0, \"vctcxo_d4\", \"vctcxo\", 1, 4, 0},\n};\n\nstatic struct mmp_clk_factor_masks uart_factor_masks = {\n\t.factor = 2,\n\t.num_mask = 0x1fff,\n\t.den_mask = 0x1fff,\n\t.num_shift = 16,\n\t.den_shift = 0,\n};\n\nstatic struct mmp_clk_factor_tbl uart_factor_tbl[] = {\n\t{.num = 832, .den = 234},\t \n\t{.num = 1, .den = 1},\t\t \n};\n\nstatic void pxa1928_pll_init(struct pxa1928_clk_unit *pxa_unit)\n{\n\tstruct mmp_clk_unit *unit = &pxa_unit->unit;\n\n\tmmp_register_fixed_rate_clks(unit, fixed_rate_clks,\n\t\t\t\t\tARRAY_SIZE(fixed_rate_clks));\n\n\tmmp_register_fixed_factor_clks(unit, fixed_factor_clks,\n\t\t\t\t\tARRAY_SIZE(fixed_factor_clks));\n\n\tmmp_clk_register_factor(\"uart_pll\", \"pll1_416\",\n\t\t\t\tCLK_SET_RATE_PARENT,\n\t\t\t\tpxa_unit->mpmu_base + MPMU_UART_PLL,\n\t\t\t\t&uart_factor_masks, uart_factor_tbl,\n\t\t\t\tARRAY_SIZE(uart_factor_tbl), NULL);\n}\n\nstatic DEFINE_SPINLOCK(uart0_lock);\nstatic DEFINE_SPINLOCK(uart1_lock);\nstatic DEFINE_SPINLOCK(uart2_lock);\nstatic DEFINE_SPINLOCK(uart3_lock);\nstatic const char *uart_parent_names[] = {\"uart_pll\", \"vctcxo\"};\n\nstatic DEFINE_SPINLOCK(ssp0_lock);\nstatic DEFINE_SPINLOCK(ssp1_lock);\nstatic const char *ssp_parent_names[] = {\"vctcxo_d4\", \"vctcxo_d2\", \"vctcxo\", \"pll1_d12\"};\n\nstatic DEFINE_SPINLOCK(reset_lock);\n\nstatic struct mmp_param_mux_clk apbc_mux_clks[] = {\n\t{0, \"uart0_mux\", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, PXA1928_CLK_UART0 * 4, 4, 3, 0, &uart0_lock},\n\t{0, \"uart1_mux\", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, PXA1928_CLK_UART1 * 4, 4, 3, 0, &uart1_lock},\n\t{0, \"uart2_mux\", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, PXA1928_CLK_UART2 * 4, 4, 3, 0, &uart2_lock},\n\t{0, \"uart3_mux\", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, PXA1928_CLK_UART3 * 4, 4, 3, 0, &uart3_lock},\n\t{0, \"ssp0_mux\", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), CLK_SET_RATE_PARENT, PXA1928_CLK_SSP0 * 4, 4, 3, 0, &ssp0_lock},\n\t{0, \"ssp1_mux\", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), CLK_SET_RATE_PARENT, PXA1928_CLK_SSP1 * 4, 4, 3, 0, &ssp1_lock},\n};\n\nstatic struct mmp_param_gate_clk apbc_gate_clks[] = {\n\t{PXA1928_CLK_TWSI0, \"twsi0_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, PXA1928_CLK_TWSI0 * 4, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA1928_CLK_TWSI1, \"twsi1_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, PXA1928_CLK_TWSI1 * 4, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA1928_CLK_TWSI2, \"twsi2_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, PXA1928_CLK_TWSI2 * 4, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA1928_CLK_TWSI3, \"twsi3_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, PXA1928_CLK_TWSI3 * 4, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA1928_CLK_TWSI4, \"twsi4_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, PXA1928_CLK_TWSI4 * 4, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA1928_CLK_TWSI5, \"twsi5_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, PXA1928_CLK_TWSI5 * 4, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA1928_CLK_GPIO, \"gpio_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, PXA1928_CLK_GPIO * 4, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA1928_CLK_KPC, \"kpc_clk\", \"clk32\", CLK_SET_RATE_PARENT, PXA1928_CLK_KPC * 4, 0x3, 0x3, 0x0, MMP_CLK_GATE_NEED_DELAY, NULL},\n\t{PXA1928_CLK_RTC, \"rtc_clk\", \"clk32\", CLK_SET_RATE_PARENT, PXA1928_CLK_RTC * 4, 0x83, 0x83, 0x0, MMP_CLK_GATE_NEED_DELAY, NULL},\n\t{PXA1928_CLK_PWM0, \"pwm0_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, PXA1928_CLK_PWM0 * 4, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA1928_CLK_PWM1, \"pwm1_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, PXA1928_CLK_PWM1 * 4, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA1928_CLK_PWM2, \"pwm2_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, PXA1928_CLK_PWM2 * 4, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA1928_CLK_PWM3, \"pwm3_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, PXA1928_CLK_PWM3 * 4, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t \n\t{PXA1928_CLK_UART0, \"uart0_clk\", \"uart0_mux\", CLK_SET_RATE_PARENT, PXA1928_CLK_UART0 * 4, 0x3, 0x3, 0x0, 0, &uart0_lock},\n\t{PXA1928_CLK_UART1, \"uart1_clk\", \"uart1_mux\", CLK_SET_RATE_PARENT, PXA1928_CLK_UART1 * 4, 0x3, 0x3, 0x0, 0, &uart1_lock},\n\t{PXA1928_CLK_UART2, \"uart2_clk\", \"uart2_mux\", CLK_SET_RATE_PARENT, PXA1928_CLK_UART2 * 4, 0x3, 0x3, 0x0, 0, &uart2_lock},\n\t{PXA1928_CLK_UART3, \"uart3_clk\", \"uart3_mux\", CLK_SET_RATE_PARENT, PXA1928_CLK_UART3 * 4, 0x3, 0x3, 0x0, 0, &uart3_lock},\n\t{PXA1928_CLK_SSP0, \"ssp0_clk\", \"ssp0_mux\", CLK_SET_RATE_PARENT, PXA1928_CLK_SSP0 * 4, 0x3, 0x3, 0x0, 0, &ssp0_lock},\n\t{PXA1928_CLK_SSP1, \"ssp1_clk\", \"ssp1_mux\", CLK_SET_RATE_PARENT, PXA1928_CLK_SSP1 * 4, 0x3, 0x3, 0x0, 0, &ssp1_lock},\n};\n\nstatic void pxa1928_apb_periph_clk_init(struct pxa1928_clk_unit *pxa_unit)\n{\n\tstruct mmp_clk_unit *unit = &pxa_unit->unit;\n\n\tmmp_register_mux_clks(unit, apbc_mux_clks, pxa_unit->apbc_base,\n\t\t\t\tARRAY_SIZE(apbc_mux_clks));\n\n\tmmp_register_gate_clks(unit, apbc_gate_clks, pxa_unit->apbc_base,\n\t\t\t\tARRAY_SIZE(apbc_gate_clks));\n}\n\nstatic DEFINE_SPINLOCK(sdh0_lock);\nstatic DEFINE_SPINLOCK(sdh1_lock);\nstatic DEFINE_SPINLOCK(sdh2_lock);\nstatic DEFINE_SPINLOCK(sdh3_lock);\nstatic DEFINE_SPINLOCK(sdh4_lock);\nstatic const char *sdh_parent_names[] = {\"pll1_624\", \"pll5p\", \"pll5\", \"pll1_416\"};\n\nstatic DEFINE_SPINLOCK(usb_lock);\n\nstatic struct mmp_param_mux_clk apmu_mux_clks[] = {\n\t{0, \"sdh_mux\", sdh_parent_names, ARRAY_SIZE(sdh_parent_names), CLK_SET_RATE_PARENT, PXA1928_CLK_SDH0 * 4, 8, 2, 0, &sdh0_lock},\n};\n\nstatic struct mmp_param_div_clk apmu_div_clks[] = {\n\t{0, \"sdh_div\", \"sdh_mux\", 0, PXA1928_CLK_SDH0 * 4, 10, 4, CLK_DIVIDER_ONE_BASED, &sdh0_lock},\n};\n\nstatic struct mmp_param_gate_clk apmu_gate_clks[] = {\n\t{PXA1928_CLK_USB, \"usb_clk\", \"usb_pll\", 0, PXA1928_CLK_USB * 4, 0x9, 0x9, 0x0, 0, &usb_lock},\n\t{PXA1928_CLK_HSIC, \"hsic_clk\", \"usb_pll\", 0, PXA1928_CLK_HSIC * 4, 0x9, 0x9, 0x0, 0, &usb_lock},\n\t \n\t{PXA1928_CLK_SDH0, \"sdh0_clk\", \"sdh_div\", CLK_SET_RATE_PARENT, PXA1928_CLK_SDH0 * 4, 0x1b, 0x1b, 0x0, 0, &sdh0_lock},\n\t{PXA1928_CLK_SDH1, \"sdh1_clk\", \"sdh_div\", CLK_SET_RATE_PARENT, PXA1928_CLK_SDH1 * 4, 0x1b, 0x1b, 0x0, 0, &sdh1_lock},\n\t{PXA1928_CLK_SDH2, \"sdh2_clk\", \"sdh_div\", CLK_SET_RATE_PARENT, PXA1928_CLK_SDH2 * 4, 0x1b, 0x1b, 0x0, 0, &sdh2_lock},\n\t{PXA1928_CLK_SDH3, \"sdh3_clk\", \"sdh_div\", CLK_SET_RATE_PARENT, PXA1928_CLK_SDH3 * 4, 0x1b, 0x1b, 0x0, 0, &sdh3_lock},\n\t{PXA1928_CLK_SDH4, \"sdh4_clk\", \"sdh_div\", CLK_SET_RATE_PARENT, PXA1928_CLK_SDH4 * 4, 0x1b, 0x1b, 0x0, 0, &sdh4_lock},\n};\n\nstatic void pxa1928_axi_periph_clk_init(struct pxa1928_clk_unit *pxa_unit)\n{\n\tstruct mmp_clk_unit *unit = &pxa_unit->unit;\n\n\tmmp_register_mux_clks(unit, apmu_mux_clks, pxa_unit->apmu_base,\n\t\t\t\tARRAY_SIZE(apmu_mux_clks));\n\n\tmmp_register_div_clks(unit, apmu_div_clks, pxa_unit->apmu_base,\n\t\t\t\tARRAY_SIZE(apmu_div_clks));\n\n\tmmp_register_gate_clks(unit, apmu_gate_clks, pxa_unit->apmu_base,\n\t\t\t\tARRAY_SIZE(apmu_gate_clks));\n}\n\nstatic void pxa1928_clk_reset_init(struct device_node *np,\n\t\t\t\tstruct pxa1928_clk_unit *pxa_unit)\n{\n\tstruct mmp_clk_reset_cell *cells;\n\tint i, base, nr_resets;\n\n\tnr_resets = ARRAY_SIZE(apbc_gate_clks);\n\tcells = kcalloc(nr_resets, sizeof(*cells), GFP_KERNEL);\n\tif (!cells)\n\t\treturn;\n\n\tbase = 0;\n\tfor (i = 0; i < nr_resets; i++) {\n\t\tcells[base + i].clk_id = apbc_gate_clks[i].id;\n\t\tcells[base + i].reg =\n\t\t\tpxa_unit->apbc_base + apbc_gate_clks[i].offset;\n\t\tcells[base + i].flags = 0;\n\t\tcells[base + i].lock = apbc_gate_clks[i].lock;\n\t\tcells[base + i].bits = 0x4;\n\t}\n\n\tmmp_clk_reset_register(np, cells, nr_resets);\n}\n\nstatic void __init pxa1928_mpmu_clk_init(struct device_node *np)\n{\n\tstruct pxa1928_clk_unit *pxa_unit;\n\n\tpxa_unit = kzalloc(sizeof(*pxa_unit), GFP_KERNEL);\n\tif (!pxa_unit)\n\t\treturn;\n\n\tpxa_unit->mpmu_base = of_iomap(np, 0);\n\tif (!pxa_unit->mpmu_base) {\n\t\tpr_err(\"failed to map mpmu registers\\n\");\n\t\tkfree(pxa_unit);\n\t\treturn;\n\t}\n\n\tpxa1928_pll_init(pxa_unit);\n}\nCLK_OF_DECLARE(pxa1928_mpmu_clk, \"marvell,pxa1928-mpmu\", pxa1928_mpmu_clk_init);\n\nstatic void __init pxa1928_apmu_clk_init(struct device_node *np)\n{\n\tstruct pxa1928_clk_unit *pxa_unit;\n\n\tpxa_unit = kzalloc(sizeof(*pxa_unit), GFP_KERNEL);\n\tif (!pxa_unit)\n\t\treturn;\n\n\tpxa_unit->apmu_base = of_iomap(np, 0);\n\tif (!pxa_unit->apmu_base) {\n\t\tpr_err(\"failed to map apmu registers\\n\");\n\t\tkfree(pxa_unit);\n\t\treturn;\n\t}\n\n\tmmp_clk_init(np, &pxa_unit->unit, APMU_NR_CLKS);\n\n\tpxa1928_axi_periph_clk_init(pxa_unit);\n}\nCLK_OF_DECLARE(pxa1928_apmu_clk, \"marvell,pxa1928-apmu\", pxa1928_apmu_clk_init);\n\nstatic void __init pxa1928_apbc_clk_init(struct device_node *np)\n{\n\tstruct pxa1928_clk_unit *pxa_unit;\n\n\tpxa_unit = kzalloc(sizeof(*pxa_unit), GFP_KERNEL);\n\tif (!pxa_unit)\n\t\treturn;\n\n\tpxa_unit->apbc_base = of_iomap(np, 0);\n\tif (!pxa_unit->apbc_base) {\n\t\tpr_err(\"failed to map apbc registers\\n\");\n\t\tkfree(pxa_unit);\n\t\treturn;\n\t}\n\n\tmmp_clk_init(np, &pxa_unit->unit, APBC_NR_CLKS);\n\n\tpxa1928_apb_periph_clk_init(pxa_unit);\n\tpxa1928_clk_reset_init(np, pxa_unit);\n}\nCLK_OF_DECLARE(pxa1928_apbc_clk, \"marvell,pxa1928-apbc\", pxa1928_apbc_clk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}