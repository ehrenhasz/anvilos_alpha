{
  "module_name": "clk-frac.c",
  "hash_id": "1cd91eb1cabf945c366e30ba0b09a44f8e6c7c12963fcc9890dd5114913ae527",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mmp/clk-frac.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n\n#include \"clk.h\"\n \n\n#define to_clk_factor(hw) container_of(hw, struct mmp_clk_factor, hw)\n\nstatic long clk_factor_round_rate(struct clk_hw *hw, unsigned long drate,\n\t\tunsigned long *prate)\n{\n\tstruct mmp_clk_factor *factor = to_clk_factor(hw);\n\tu64 rate = 0, prev_rate;\n\tint i;\n\n\tfor (i = 0; i < factor->ftbl_cnt; i++) {\n\t\tprev_rate = rate;\n\t\trate = *prate;\n\t\trate *= factor->ftbl[i].den;\n\t\tdo_div(rate, factor->ftbl[i].num * factor->masks->factor);\n\n\t\tif (rate > drate)\n\t\t\tbreak;\n\t}\n\tif ((i == 0) || (i == factor->ftbl_cnt)) {\n\t\treturn rate;\n\t} else {\n\t\tif ((drate - prev_rate) > (rate - drate))\n\t\t\treturn rate;\n\t\telse\n\t\t\treturn prev_rate;\n\t}\n}\n\nstatic unsigned long clk_factor_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct mmp_clk_factor *factor = to_clk_factor(hw);\n\tstruct mmp_clk_factor_masks *masks = factor->masks;\n\tunsigned int val, num, den;\n\tu64 rate;\n\n\tval = readl_relaxed(factor->base);\n\n\t \n\tnum = (val >> masks->num_shift) & masks->num_mask;\n\n\t \n\tden = (val >> masks->den_shift) & masks->den_mask;\n\n\tif (!den)\n\t\treturn 0;\n\n\trate = parent_rate;\n\trate *= den;\n\tdo_div(rate, num * factor->masks->factor);\n\n\treturn rate;\n}\n\n \nstatic int clk_factor_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\tunsigned long prate)\n{\n\tstruct mmp_clk_factor *factor = to_clk_factor(hw);\n\tstruct mmp_clk_factor_masks *masks = factor->masks;\n\tint i;\n\tunsigned long val;\n\tunsigned long flags = 0;\n\tu64 rate = 0;\n\n\tfor (i = 0; i < factor->ftbl_cnt; i++) {\n\t\trate = prate;\n\t\trate *= factor->ftbl[i].den;\n\t\tdo_div(rate, factor->ftbl[i].num * factor->masks->factor);\n\n\t\tif (rate > drate)\n\t\t\tbreak;\n\t}\n\tif (i > 0)\n\t\ti--;\n\n\tif (factor->lock)\n\t\tspin_lock_irqsave(factor->lock, flags);\n\n\tval = readl_relaxed(factor->base);\n\n\tval &= ~(masks->num_mask << masks->num_shift);\n\tval |= (factor->ftbl[i].num & masks->num_mask) << masks->num_shift;\n\n\tval &= ~(masks->den_mask << masks->den_shift);\n\tval |= (factor->ftbl[i].den & masks->den_mask) << masks->den_shift;\n\n\twritel_relaxed(val, factor->base);\n\n\tif (factor->lock)\n\t\tspin_unlock_irqrestore(factor->lock, flags);\n\n\treturn 0;\n}\n\nstatic int clk_factor_init(struct clk_hw *hw)\n{\n\tstruct mmp_clk_factor *factor = to_clk_factor(hw);\n\tstruct mmp_clk_factor_masks *masks = factor->masks;\n\tu32 val, num, den;\n\tint i;\n\tunsigned long flags = 0;\n\n\tif (factor->lock)\n\t\tspin_lock_irqsave(factor->lock, flags);\n\n\tval = readl(factor->base);\n\n\t \n\tnum = (val >> masks->num_shift) & masks->num_mask;\n\n\t \n\tden = (val >> masks->den_shift) & masks->den_mask;\n\n\tfor (i = 0; i < factor->ftbl_cnt; i++)\n\t\tif (den == factor->ftbl[i].den && num == factor->ftbl[i].num)\n\t\t\tbreak;\n\n\tif (i >= factor->ftbl_cnt) {\n\t\tval &= ~(masks->num_mask << masks->num_shift);\n\t\tval |= (factor->ftbl[0].num & masks->num_mask) <<\n\t\t\tmasks->num_shift;\n\n\t\tval &= ~(masks->den_mask << masks->den_shift);\n\t\tval |= (factor->ftbl[0].den & masks->den_mask) <<\n\t\t\tmasks->den_shift;\n\t}\n\n\tif (!(val & masks->enable_mask) || i >= factor->ftbl_cnt) {\n\t\tval |= masks->enable_mask;\n\t\twritel(val, factor->base);\n\t}\n\n\tif (factor->lock)\n\t\tspin_unlock_irqrestore(factor->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_factor_ops = {\n\t.recalc_rate = clk_factor_recalc_rate,\n\t.round_rate = clk_factor_round_rate,\n\t.set_rate = clk_factor_set_rate,\n\t.init = clk_factor_init,\n};\n\nstruct clk *mmp_clk_register_factor(const char *name, const char *parent_name,\n\t\tunsigned long flags, void __iomem *base,\n\t\tstruct mmp_clk_factor_masks *masks,\n\t\tstruct mmp_clk_factor_tbl *ftbl,\n\t\tunsigned int ftbl_cnt, spinlock_t *lock)\n{\n\tstruct mmp_clk_factor *factor;\n\tstruct clk_init_data init;\n\tstruct clk *clk;\n\n\tif (!masks) {\n\t\tpr_err(\"%s: must pass a clk_factor_mask\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfactor = kzalloc(sizeof(*factor), GFP_KERNEL);\n\tif (!factor)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tfactor->base = base;\n\tfactor->masks = masks;\n\tfactor->ftbl = ftbl;\n\tfactor->ftbl_cnt = ftbl_cnt;\n\tfactor->hw.init = &init;\n\tfactor->lock = lock;\n\n\tinit.name = name;\n\tinit.ops = &clk_factor_ops;\n\tinit.flags = flags;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tclk = clk_register(NULL, &factor->hw);\n\tif (IS_ERR_OR_NULL(clk))\n\t\tkfree(factor);\n\n\treturn clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}