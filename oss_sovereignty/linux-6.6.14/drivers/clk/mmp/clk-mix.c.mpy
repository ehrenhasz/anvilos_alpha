{
  "module_name": "clk-mix.c",
  "hash_id": "9c0cab7d3f4f5df94b14da444550d015289c92d62378f674f75c33cac0229e4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mmp/clk-mix.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n\n#include \"clk.h\"\n\n \n\n#define to_clk_mix(hw)\tcontainer_of(hw, struct mmp_clk_mix, hw)\n\nstatic unsigned int _get_maxdiv(struct mmp_clk_mix *mix)\n{\n\tunsigned int div_mask = (1 << mix->reg_info.width_div) - 1;\n\tunsigned int maxdiv = 0;\n\tstruct clk_div_table *clkt;\n\n\tif (mix->div_flags & CLK_DIVIDER_ONE_BASED)\n\t\treturn div_mask;\n\tif (mix->div_flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\treturn 1 << div_mask;\n\tif (mix->div_table) {\n\t\tfor (clkt = mix->div_table; clkt->div; clkt++)\n\t\t\tif (clkt->div > maxdiv)\n\t\t\t\tmaxdiv = clkt->div;\n\t\treturn maxdiv;\n\t}\n\treturn div_mask + 1;\n}\n\nstatic unsigned int _get_div(struct mmp_clk_mix *mix, unsigned int val)\n{\n\tstruct clk_div_table *clkt;\n\n\tif (mix->div_flags & CLK_DIVIDER_ONE_BASED)\n\t\treturn val;\n\tif (mix->div_flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\treturn 1 << val;\n\tif (mix->div_table) {\n\t\tfor (clkt = mix->div_table; clkt->div; clkt++)\n\t\t\tif (clkt->val == val)\n\t\t\t\treturn clkt->div;\n\t\tif (clkt->div == 0)\n\t\t\treturn 0;\n\t}\n\treturn val + 1;\n}\n\nstatic unsigned int _get_mux(struct mmp_clk_mix *mix, unsigned int val)\n{\n\tint num_parents = clk_hw_get_num_parents(&mix->hw);\n\tint i;\n\n\tif (mix->mux_flags & CLK_MUX_INDEX_BIT)\n\t\treturn ffs(val) - 1;\n\tif (mix->mux_flags & CLK_MUX_INDEX_ONE)\n\t\treturn val - 1;\n\tif (mix->mux_table) {\n\t\tfor (i = 0; i < num_parents; i++)\n\t\t\tif (mix->mux_table[i] == val)\n\t\t\t\treturn i;\n\t\tif (i == num_parents)\n\t\t\treturn 0;\n\t}\n\n\treturn val;\n}\nstatic unsigned int _get_div_val(struct mmp_clk_mix *mix, unsigned int div)\n{\n\tstruct clk_div_table *clkt;\n\n\tif (mix->div_flags & CLK_DIVIDER_ONE_BASED)\n\t\treturn div;\n\tif (mix->div_flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\treturn __ffs(div);\n\tif (mix->div_table) {\n\t\tfor (clkt = mix->div_table; clkt->div; clkt++)\n\t\t\tif (clkt->div == div)\n\t\t\t\treturn clkt->val;\n\t\tif (clkt->div == 0)\n\t\t\treturn 0;\n\t}\n\n\treturn div - 1;\n}\n\nstatic unsigned int _get_mux_val(struct mmp_clk_mix *mix, unsigned int mux)\n{\n\tif (mix->mux_table)\n\t\treturn mix->mux_table[mux];\n\n\treturn mux;\n}\n\nstatic void _filter_clk_table(struct mmp_clk_mix *mix,\n\t\t\t\tstruct mmp_clk_mix_clk_table *table,\n\t\t\t\tunsigned int table_size)\n{\n\tint i;\n\tstruct mmp_clk_mix_clk_table *item;\n\tstruct clk_hw *parent, *hw;\n\tunsigned long parent_rate;\n\n\thw = &mix->hw;\n\n\tfor (i = 0; i < table_size; i++) {\n\t\titem = &table[i];\n\t\tparent = clk_hw_get_parent_by_index(hw, item->parent_index);\n\t\tparent_rate = clk_hw_get_rate(parent);\n\t\tif (parent_rate % item->rate) {\n\t\t\titem->valid = 0;\n\t\t} else {\n\t\t\titem->divisor = parent_rate / item->rate;\n\t\t\titem->valid = 1;\n\t\t}\n\t}\n}\n\nstatic int _set_rate(struct mmp_clk_mix *mix, u32 mux_val, u32 div_val,\n\t\t\tunsigned int change_mux, unsigned int change_div)\n{\n\tstruct mmp_clk_mix_reg_info *ri = &mix->reg_info;\n\tu8 width, shift;\n\tu32 mux_div, fc_req;\n\tint ret, timeout = 50;\n\tunsigned long flags = 0;\n\n\tif (!change_mux && !change_div)\n\t\treturn -EINVAL;\n\n\tif (mix->lock)\n\t\tspin_lock_irqsave(mix->lock, flags);\n\n\tif (mix->type == MMP_CLK_MIX_TYPE_V1\n\t\t|| mix->type == MMP_CLK_MIX_TYPE_V2)\n\t\tmux_div = readl(ri->reg_clk_ctrl);\n\telse\n\t\tmux_div = readl(ri->reg_clk_sel);\n\n\tif (change_div) {\n\t\twidth = ri->width_div;\n\t\tshift = ri->shift_div;\n\t\tmux_div &= ~MMP_CLK_BITS_MASK(width, shift);\n\t\tmux_div |= MMP_CLK_BITS_SET_VAL(div_val, width, shift);\n\t}\n\n\tif (change_mux) {\n\t\twidth = ri->width_mux;\n\t\tshift = ri->shift_mux;\n\t\tmux_div &= ~MMP_CLK_BITS_MASK(width, shift);\n\t\tmux_div |= MMP_CLK_BITS_SET_VAL(mux_val, width, shift);\n\t}\n\n\tif (mix->type == MMP_CLK_MIX_TYPE_V1) {\n\t\twritel(mux_div, ri->reg_clk_ctrl);\n\t} else if (mix->type == MMP_CLK_MIX_TYPE_V2) {\n\t\tmux_div |= (1 << ri->bit_fc);\n\t\twritel(mux_div, ri->reg_clk_ctrl);\n\n\t\tdo {\n\t\t\tfc_req = readl(ri->reg_clk_ctrl);\n\t\t\ttimeout--;\n\t\t\tif (!(fc_req & (1 << ri->bit_fc)))\n\t\t\t\tbreak;\n\t\t} while (timeout);\n\n\t\tif (timeout == 0) {\n\t\t\tpr_err(\"%s:%s cannot do frequency change\\n\",\n\t\t\t\t__func__, clk_hw_get_name(&mix->hw));\n\t\t\tret = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tfc_req = readl(ri->reg_clk_ctrl);\n\t\tfc_req |= 1 << ri->bit_fc;\n\t\twritel(fc_req, ri->reg_clk_ctrl);\n\t\twritel(mux_div, ri->reg_clk_sel);\n\t\tfc_req &= ~(1 << ri->bit_fc);\n\t}\n\n\tret = 0;\nerror:\n\tif (mix->lock)\n\t\tspin_unlock_irqrestore(mix->lock, flags);\n\n\treturn ret;\n}\n\nstatic int mmp_clk_mix_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tstruct mmp_clk_mix *mix = to_clk_mix(hw);\n\tstruct mmp_clk_mix_clk_table *item;\n\tstruct clk_hw *parent, *parent_best;\n\tunsigned long parent_rate, mix_rate, mix_rate_best, parent_rate_best;\n\tunsigned long gap, gap_best;\n\tu32 div_val_max;\n\tunsigned int div;\n\tint i, j;\n\n\n\tmix_rate_best = 0;\n\tparent_rate_best = 0;\n\tgap_best = ULONG_MAX;\n\tparent_best = NULL;\n\n\tif (mix->table) {\n\t\tfor (i = 0; i < mix->table_size; i++) {\n\t\t\titem = &mix->table[i];\n\t\t\tif (item->valid == 0)\n\t\t\t\tcontinue;\n\t\t\tparent = clk_hw_get_parent_by_index(hw,\n\t\t\t\t\t\t\titem->parent_index);\n\t\t\tparent_rate = clk_hw_get_rate(parent);\n\t\t\tmix_rate = parent_rate / item->divisor;\n\t\t\tgap = abs(mix_rate - req->rate);\n\t\t\tif (!parent_best || gap < gap_best) {\n\t\t\t\tparent_best = parent;\n\t\t\t\tparent_rate_best = parent_rate;\n\t\t\t\tmix_rate_best = mix_rate;\n\t\t\t\tgap_best = gap;\n\t\t\t\tif (gap_best == 0)\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\n\t\t\tparent = clk_hw_get_parent_by_index(hw, i);\n\t\t\tparent_rate = clk_hw_get_rate(parent);\n\t\t\tdiv_val_max = _get_maxdiv(mix);\n\t\t\tfor (j = 0; j < div_val_max; j++) {\n\t\t\t\tdiv = _get_div(mix, j);\n\t\t\t\tmix_rate = parent_rate / div;\n\t\t\t\tgap = abs(mix_rate - req->rate);\n\t\t\t\tif (!parent_best || gap < gap_best) {\n\t\t\t\t\tparent_best = parent;\n\t\t\t\t\tparent_rate_best = parent_rate;\n\t\t\t\t\tmix_rate_best = mix_rate;\n\t\t\t\t\tgap_best = gap;\n\t\t\t\t\tif (gap_best == 0)\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nfound:\n\tif (!parent_best)\n\t\treturn -EINVAL;\n\n\treq->best_parent_rate = parent_rate_best;\n\treq->best_parent_hw = parent_best;\n\treq->rate = mix_rate_best;\n\n\treturn 0;\n}\n\nstatic int mmp_clk_mix_set_rate_and_parent(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long rate,\n\t\t\t\t\t\tunsigned long parent_rate,\n\t\t\t\t\t\tu8 index)\n{\n\tstruct mmp_clk_mix *mix = to_clk_mix(hw);\n\tunsigned int div;\n\tu32 div_val, mux_val;\n\n\tdiv = parent_rate / rate;\n\tdiv_val = _get_div_val(mix, div);\n\tmux_val = _get_mux_val(mix, index);\n\n\treturn _set_rate(mix, mux_val, div_val, 1, 1);\n}\n\nstatic u8 mmp_clk_mix_get_parent(struct clk_hw *hw)\n{\n\tstruct mmp_clk_mix *mix = to_clk_mix(hw);\n\tstruct mmp_clk_mix_reg_info *ri = &mix->reg_info;\n\tunsigned long flags = 0;\n\tu32 mux_div = 0;\n\tu8 width, shift;\n\tu32 mux_val;\n\n\tif (mix->lock)\n\t\tspin_lock_irqsave(mix->lock, flags);\n\n\tif (mix->type == MMP_CLK_MIX_TYPE_V1\n\t\t|| mix->type == MMP_CLK_MIX_TYPE_V2)\n\t\tmux_div = readl(ri->reg_clk_ctrl);\n\telse\n\t\tmux_div = readl(ri->reg_clk_sel);\n\n\tif (mix->lock)\n\t\tspin_unlock_irqrestore(mix->lock, flags);\n\n\twidth = mix->reg_info.width_mux;\n\tshift = mix->reg_info.shift_mux;\n\n\tmux_val = MMP_CLK_BITS_GET_VAL(mux_div, width, shift);\n\n\treturn _get_mux(mix, mux_val);\n}\n\nstatic unsigned long mmp_clk_mix_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct mmp_clk_mix *mix = to_clk_mix(hw);\n\tstruct mmp_clk_mix_reg_info *ri = &mix->reg_info;\n\tunsigned long flags = 0;\n\tu32 mux_div = 0;\n\tu8 width, shift;\n\tunsigned int div;\n\n\tif (mix->lock)\n\t\tspin_lock_irqsave(mix->lock, flags);\n\n\tif (mix->type == MMP_CLK_MIX_TYPE_V1\n\t\t|| mix->type == MMP_CLK_MIX_TYPE_V2)\n\t\tmux_div = readl(ri->reg_clk_ctrl);\n\telse\n\t\tmux_div = readl(ri->reg_clk_sel);\n\n\tif (mix->lock)\n\t\tspin_unlock_irqrestore(mix->lock, flags);\n\n\twidth = mix->reg_info.width_div;\n\tshift = mix->reg_info.shift_div;\n\n\tdiv = _get_div(mix, MMP_CLK_BITS_GET_VAL(mux_div, width, shift));\n\n\treturn parent_rate / div;\n}\n\nstatic int mmp_clk_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct mmp_clk_mix *mix = to_clk_mix(hw);\n\tstruct mmp_clk_mix_clk_table *item;\n\tint i;\n\tu32 div_val, mux_val;\n\n\tif (mix->table) {\n\t\tfor (i = 0; i < mix->table_size; i++) {\n\t\t\titem = &mix->table[i];\n\t\t\tif (item->valid == 0)\n\t\t\t\tcontinue;\n\t\t\tif (item->parent_index == index)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < mix->table_size) {\n\t\t\tdiv_val = _get_div_val(mix, item->divisor);\n\t\t\tmux_val = _get_mux_val(mix, item->parent_index);\n\t\t} else\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tmux_val = _get_mux_val(mix, index);\n\t\tdiv_val = 0;\n\t}\n\n\treturn _set_rate(mix, mux_val, div_val, 1, div_val ? 1 : 0);\n}\n\nstatic int mmp_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long best_parent_rate)\n{\n\tstruct mmp_clk_mix *mix = to_clk_mix(hw);\n\tstruct mmp_clk_mix_clk_table *item;\n\tunsigned long parent_rate;\n\tunsigned int best_divisor;\n\tstruct clk_hw *parent;\n\tint i;\n\n\tbest_divisor = best_parent_rate / rate;\n\n\tif (mix->table) {\n\t\tfor (i = 0; i < mix->table_size; i++) {\n\t\t\titem = &mix->table[i];\n\t\t\tif (item->valid == 0)\n\t\t\t\tcontinue;\n\t\t\tparent = clk_hw_get_parent_by_index(hw,\n\t\t\t\t\t\t\titem->parent_index);\n\t\t\tparent_rate = clk_hw_get_rate(parent);\n\t\t\tif (parent_rate == best_parent_rate\n\t\t\t\t&& item->divisor == best_divisor)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < mix->table_size)\n\t\t\treturn _set_rate(mix,\n\t\t\t\t\t_get_mux_val(mix, item->parent_index),\n\t\t\t\t\t_get_div_val(mix, item->divisor),\n\t\t\t\t\t1, 1);\n\t\telse\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\n\t\t\tparent = clk_hw_get_parent_by_index(hw, i);\n\t\t\tparent_rate = clk_hw_get_rate(parent);\n\t\t\tif (parent_rate == best_parent_rate)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < clk_hw_get_num_parents(hw))\n\t\t\treturn _set_rate(mix, _get_mux_val(mix, i),\n\t\t\t\t\t_get_div_val(mix, best_divisor), 1, 1);\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mmp_clk_mix_init(struct clk_hw *hw)\n{\n\tstruct mmp_clk_mix *mix = to_clk_mix(hw);\n\n\tif (mix->table)\n\t\t_filter_clk_table(mix, mix->table, mix->table_size);\n\n\treturn 0;\n}\n\nconst struct clk_ops mmp_clk_mix_ops = {\n\t.determine_rate = mmp_clk_mix_determine_rate,\n\t.set_rate_and_parent = mmp_clk_mix_set_rate_and_parent,\n\t.set_rate = mmp_clk_set_rate,\n\t.set_parent = mmp_clk_set_parent,\n\t.get_parent = mmp_clk_mix_get_parent,\n\t.recalc_rate = mmp_clk_mix_recalc_rate,\n\t.init = mmp_clk_mix_init,\n};\n\nstruct clk *mmp_clk_register_mix(struct device *dev,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tconst char * const *parent_names,\n\t\t\t\t\tu8 num_parents,\n\t\t\t\t\tunsigned long flags,\n\t\t\t\t\tstruct mmp_clk_mix_config *config,\n\t\t\t\t\tspinlock_t *lock)\n{\n\tstruct mmp_clk_mix *mix;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\tsize_t table_bytes;\n\n\tmix = kzalloc(sizeof(*mix), GFP_KERNEL);\n\tif (!mix)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.flags = flags | CLK_GET_RATE_NOCACHE;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\tinit.ops = &mmp_clk_mix_ops;\n\n\tmemcpy(&mix->reg_info, &config->reg_info, sizeof(config->reg_info));\n\tif (config->table) {\n\t\ttable_bytes = sizeof(*config->table) * config->table_size;\n\t\tmix->table = kmemdup(config->table, table_bytes, GFP_KERNEL);\n\t\tif (!mix->table)\n\t\t\tgoto free_mix;\n\n\t\tmix->table_size = config->table_size;\n\t}\n\n\tif (config->mux_table) {\n\t\ttable_bytes = sizeof(u32) * num_parents;\n\t\tmix->mux_table = kmemdup(config->mux_table, table_bytes,\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!mix->mux_table) {\n\t\t\tkfree(mix->table);\n\t\t\tgoto free_mix;\n\t\t}\n\t}\n\n\tmix->div_flags = config->div_flags;\n\tmix->mux_flags = config->mux_flags;\n\tmix->lock = lock;\n\tmix->hw.init = &init;\n\n\tif (config->reg_info.bit_fc >= 32)\n\t\tmix->type = MMP_CLK_MIX_TYPE_V1;\n\telse if (config->reg_info.reg_clk_sel)\n\t\tmix->type = MMP_CLK_MIX_TYPE_V3;\n\telse\n\t\tmix->type = MMP_CLK_MIX_TYPE_V2;\n\tclk = clk_register(dev, &mix->hw);\n\n\tif (IS_ERR(clk)) {\n\t\tkfree(mix->mux_table);\n\t\tkfree(mix->table);\n\t\tkfree(mix);\n\t}\n\n\treturn clk;\n\nfree_mix:\n\tkfree(mix);\n\treturn ERR_PTR(-ENOMEM);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}