{
  "module_name": "clk.c",
  "hash_id": "f1bb2740d0be41df167931d61a9eda70460c7fc02eef89cd0744e421ea78c804",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mmp/clk.c",
  "human_readable_source": "\n#include <linux/io.h>\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n#include \"clk.h\"\n\nvoid mmp_clk_init(struct device_node *np, struct mmp_clk_unit *unit,\n\t\tint nr_clks)\n{\n\tstruct clk **clk_table;\n\n\tclk_table = kcalloc(nr_clks, sizeof(struct clk *), GFP_KERNEL);\n\tif (!clk_table)\n\t\treturn;\n\n\tunit->clk_table = clk_table;\n\tunit->nr_clks = nr_clks;\n\tunit->clk_data.clks = clk_table;\n\tunit->clk_data.clk_num = nr_clks;\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &unit->clk_data);\n}\n\nvoid mmp_register_fixed_rate_clks(struct mmp_clk_unit *unit,\n\t\t\t\tstruct mmp_param_fixed_rate_clk *clks,\n\t\t\t\tint size)\n{\n\tint i;\n\tstruct clk *clk;\n\n\tfor (i = 0; i < size; i++) {\n\t\tclk = clk_register_fixed_rate(NULL, clks[i].name,\n\t\t\t\t\tclks[i].parent_name,\n\t\t\t\t\tclks[i].flags,\n\t\t\t\t\tclks[i].fixed_rate);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (clks[i].id)\n\t\t\tunit->clk_table[clks[i].id] = clk;\n\t}\n}\n\nvoid mmp_register_fixed_factor_clks(struct mmp_clk_unit *unit,\n\t\t\t\tstruct mmp_param_fixed_factor_clk *clks,\n\t\t\t\tint size)\n{\n\tstruct clk *clk;\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tclk = clk_register_fixed_factor(NULL, clks[i].name,\n\t\t\t\t\t\tclks[i].parent_name,\n\t\t\t\t\t\tclks[i].flags, clks[i].mult,\n\t\t\t\t\t\tclks[i].div);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (clks[i].id)\n\t\t\tunit->clk_table[clks[i].id] = clk;\n\t}\n}\n\nvoid mmp_register_general_gate_clks(struct mmp_clk_unit *unit,\n\t\t\t\tstruct mmp_param_general_gate_clk *clks,\n\t\t\t\tvoid __iomem *base, int size)\n{\n\tstruct clk *clk;\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tclk = clk_register_gate(NULL, clks[i].name,\n\t\t\t\t\tclks[i].parent_name,\n\t\t\t\t\tclks[i].flags,\n\t\t\t\t\tbase + clks[i].offset,\n\t\t\t\t\tclks[i].bit_idx,\n\t\t\t\t\tclks[i].gate_flags,\n\t\t\t\t\tclks[i].lock);\n\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (clks[i].id)\n\t\t\tunit->clk_table[clks[i].id] = clk;\n\t}\n}\n\nvoid mmp_register_gate_clks(struct mmp_clk_unit *unit,\n\t\t\tstruct mmp_param_gate_clk *clks,\n\t\t\tvoid __iomem *base, int size)\n{\n\tstruct clk *clk;\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tclk = mmp_clk_register_gate(NULL, clks[i].name,\n\t\t\t\t\tclks[i].parent_name,\n\t\t\t\t\tclks[i].flags,\n\t\t\t\t\tbase + clks[i].offset,\n\t\t\t\t\tclks[i].mask,\n\t\t\t\t\tclks[i].val_enable,\n\t\t\t\t\tclks[i].val_disable,\n\t\t\t\t\tclks[i].gate_flags,\n\t\t\t\t\tclks[i].lock);\n\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (clks[i].id)\n\t\t\tunit->clk_table[clks[i].id] = clk;\n\t}\n}\n\nvoid mmp_register_mux_clks(struct mmp_clk_unit *unit,\n\t\t\tstruct mmp_param_mux_clk *clks,\n\t\t\tvoid __iomem *base, int size)\n{\n\tstruct clk *clk;\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tclk = clk_register_mux(NULL, clks[i].name,\n\t\t\t\t\tclks[i].parent_name,\n\t\t\t\t\tclks[i].num_parents,\n\t\t\t\t\tclks[i].flags,\n\t\t\t\t\tbase + clks[i].offset,\n\t\t\t\t\tclks[i].shift,\n\t\t\t\t\tclks[i].width,\n\t\t\t\t\tclks[i].mux_flags,\n\t\t\t\t\tclks[i].lock);\n\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (clks[i].id)\n\t\t\tunit->clk_table[clks[i].id] = clk;\n\t}\n}\n\nvoid mmp_register_div_clks(struct mmp_clk_unit *unit,\n\t\t\tstruct mmp_param_div_clk *clks,\n\t\t\tvoid __iomem *base, int size)\n{\n\tstruct clk *clk;\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tclk = clk_register_divider(NULL, clks[i].name,\n\t\t\t\t\tclks[i].parent_name,\n\t\t\t\t\tclks[i].flags,\n\t\t\t\t\tbase + clks[i].offset,\n\t\t\t\t\tclks[i].shift,\n\t\t\t\t\tclks[i].width,\n\t\t\t\t\tclks[i].div_flags,\n\t\t\t\t\tclks[i].lock);\n\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (clks[i].id)\n\t\t\tunit->clk_table[clks[i].id] = clk;\n\t}\n}\n\nvoid mmp_clk_add(struct mmp_clk_unit *unit, unsigned int id,\n\t\t\tstruct clk *clk)\n{\n\tif (IS_ERR_OR_NULL(clk)) {\n\t\tpr_err(\"CLK %d has invalid pointer %p\\n\", id, clk);\n\t\treturn;\n\t}\n\tif (id >= unit->nr_clks) {\n\t\tpr_err(\"CLK %d is invalid\\n\", id);\n\t\treturn;\n\t}\n\n\tunit->clk_table[id] = clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}