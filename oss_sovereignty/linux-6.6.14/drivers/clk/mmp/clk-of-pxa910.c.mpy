{
  "module_name": "clk-of-pxa910.c",
  "hash_id": "3f80766be2281a4227fab7560d208574cf21d96f0af05930149a55eefbae8378",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mmp/clk-of-pxa910.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/of_address.h>\n\n#include <dt-bindings/clock/marvell,pxa910.h>\n\n#include \"clk.h\"\n#include \"reset.h\"\n\n#define APBC_RTC\t0x28\n#define APBC_TWSI0\t0x2c\n#define APBC_KPC\t0x18\n#define APBC_UART0\t0x0\n#define APBC_UART1\t0x4\n#define APBC_GPIO\t0x8\n#define APBC_PWM0\t0xc\n#define APBC_PWM1\t0x10\n#define APBC_PWM2\t0x14\n#define APBC_PWM3\t0x18\n#define APBC_SSP0\t0x1c\n#define APBC_SSP1\t0x20\n#define APBC_SSP2\t0x4c\n#define APBC_TIMER0\t0x30\n#define APBC_TIMER1\t0x44\n#define APBCP_TWSI1\t0x28\n#define APBCP_UART2\t0x1c\n#define APMU_SDH0\t0x54\n#define APMU_SDH1\t0x58\n#define APMU_USB\t0x5c\n#define APMU_DISP0\t0x4c\n#define APMU_CCIC0\t0x50\n#define APMU_DFC\t0x60\n#define MPMU_UART_PLL\t0x14\n\n#define NR_CLKS\t\t200\n\nstruct pxa910_clk_unit {\n\tstruct mmp_clk_unit unit;\n\tvoid __iomem *mpmu_base;\n\tvoid __iomem *apmu_base;\n\tvoid __iomem *apbc_base;\n\tvoid __iomem *apbcp_base;\n};\n\nstatic struct mmp_param_fixed_rate_clk fixed_rate_clks[] = {\n\t{PXA910_CLK_CLK32, \"clk32\", NULL, 0, 32768},\n\t{PXA910_CLK_VCTCXO, \"vctcxo\", NULL, 0, 26000000},\n\t{PXA910_CLK_PLL1, \"pll1\", NULL, 0, 624000000},\n\t{PXA910_CLK_USB_PLL, \"usb_pll\", NULL, 0, 480000000},\n};\n\nstatic struct mmp_param_fixed_factor_clk fixed_factor_clks[] = {\n\t{PXA910_CLK_PLL1_2, \"pll1_2\", \"pll1\", 1, 2, 0},\n\t{PXA910_CLK_PLL1_4, \"pll1_4\", \"pll1_2\", 1, 2, 0},\n\t{PXA910_CLK_PLL1_8, \"pll1_8\", \"pll1_4\", 1, 2, 0},\n\t{PXA910_CLK_PLL1_16, \"pll1_16\", \"pll1_8\", 1, 2, 0},\n\t{PXA910_CLK_PLL1_6, \"pll1_6\", \"pll1_2\", 1, 3, 0},\n\t{PXA910_CLK_PLL1_12, \"pll1_12\", \"pll1_6\", 1, 2, 0},\n\t{PXA910_CLK_PLL1_24, \"pll1_24\", \"pll1_12\", 1, 2, 0},\n\t{PXA910_CLK_PLL1_48, \"pll1_48\", \"pll1_24\", 1, 2, 0},\n\t{PXA910_CLK_PLL1_96, \"pll1_96\", \"pll1_48\", 1, 2, 0},\n\t{PXA910_CLK_PLL1_192, \"pll1_192\", \"pll1_96\", 1, 2, 0},\n\t{PXA910_CLK_PLL1_13, \"pll1_13\", \"pll1\", 1, 13, 0},\n\t{PXA910_CLK_PLL1_13_1_5, \"pll1_13_1_5\", \"pll1_13\", 2, 3, 0},\n\t{PXA910_CLK_PLL1_2_1_5, \"pll1_2_1_5\", \"pll1_2\", 2, 3, 0},\n\t{PXA910_CLK_PLL1_3_16, \"pll1_3_16\", \"pll1\", 3, 16, 0},\n};\n\nstatic struct mmp_clk_factor_masks uart_factor_masks = {\n\t.factor = 2,\n\t.num_mask = 0x1fff,\n\t.den_mask = 0x1fff,\n\t.num_shift = 16,\n\t.den_shift = 0,\n};\n\nstatic struct mmp_clk_factor_tbl uart_factor_tbl[] = {\n\t{.num = 8125, .den = 1536},\t \n};\n\nstatic void pxa910_pll_init(struct pxa910_clk_unit *pxa_unit)\n{\n\tstruct clk *clk;\n\tstruct mmp_clk_unit *unit = &pxa_unit->unit;\n\n\tmmp_register_fixed_rate_clks(unit, fixed_rate_clks,\n\t\t\t\t\tARRAY_SIZE(fixed_rate_clks));\n\n\tmmp_register_fixed_factor_clks(unit, fixed_factor_clks,\n\t\t\t\t\tARRAY_SIZE(fixed_factor_clks));\n\n\tclk = mmp_clk_register_factor(\"uart_pll\", \"pll1_4\",\n\t\t\t\tCLK_SET_RATE_PARENT,\n\t\t\t\tpxa_unit->mpmu_base + MPMU_UART_PLL,\n\t\t\t\t&uart_factor_masks, uart_factor_tbl,\n\t\t\t\tARRAY_SIZE(uart_factor_tbl), NULL);\n\tmmp_clk_add(unit, PXA910_CLK_UART_PLL, clk);\n}\n\nstatic DEFINE_SPINLOCK(uart0_lock);\nstatic DEFINE_SPINLOCK(uart1_lock);\nstatic DEFINE_SPINLOCK(uart2_lock);\nstatic const char *uart_parent_names[] = {\"pll1_3_16\", \"uart_pll\"};\n\nstatic DEFINE_SPINLOCK(ssp0_lock);\nstatic DEFINE_SPINLOCK(ssp1_lock);\nstatic const char *ssp_parent_names[] = {\"pll1_96\", \"pll1_48\", \"pll1_24\", \"pll1_12\"};\n\nstatic DEFINE_SPINLOCK(timer0_lock);\nstatic DEFINE_SPINLOCK(timer1_lock);\nstatic const char *timer_parent_names[] = {\"pll1_48\", \"clk32\", \"pll1_96\"};\n\nstatic DEFINE_SPINLOCK(reset_lock);\n\nstatic struct mmp_param_mux_clk apbc_mux_clks[] = {\n\t{0, \"uart0_mux\", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, APBC_UART0, 4, 3, 0, &uart0_lock},\n\t{0, \"uart1_mux\", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, APBC_UART1, 4, 3, 0, &uart1_lock},\n\t{0, \"ssp0_mux\", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), CLK_SET_RATE_PARENT, APBC_SSP0, 4, 3, 0, &ssp0_lock},\n\t{0, \"ssp1_mux\", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), CLK_SET_RATE_PARENT, APBC_SSP1, 4, 3, 0, &ssp1_lock},\n\t{0, \"timer0_mux\", timer_parent_names, ARRAY_SIZE(timer_parent_names), CLK_SET_RATE_PARENT, APBC_TIMER0, 4, 3, 0, &timer0_lock},\n\t{0, \"timer1_mux\", timer_parent_names, ARRAY_SIZE(timer_parent_names), CLK_SET_RATE_PARENT, APBC_TIMER1, 4, 3, 0, &timer1_lock},\n};\n\nstatic struct mmp_param_mux_clk apbcp_mux_clks[] = {\n\t{0, \"uart2_mux\", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, APBCP_UART2, 4, 3, 0, &uart2_lock},\n};\n\nstatic struct mmp_param_gate_clk apbc_gate_clks[] = {\n\t{PXA910_CLK_TWSI0, \"twsi0_clk\", \"pll1_13_1_5\", CLK_SET_RATE_PARENT, APBC_TWSI0, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA910_CLK_GPIO, \"gpio_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, APBC_GPIO, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA910_CLK_KPC, \"kpc_clk\", \"clk32\", CLK_SET_RATE_PARENT, APBC_KPC, 0x3, 0x3, 0x0, MMP_CLK_GATE_NEED_DELAY, NULL},\n\t{PXA910_CLK_RTC, \"rtc_clk\", \"clk32\", CLK_SET_RATE_PARENT, APBC_RTC, 0x83, 0x83, 0x0, MMP_CLK_GATE_NEED_DELAY, NULL},\n\t{PXA910_CLK_PWM0, \"pwm0_clk\", \"pll1_48\", CLK_SET_RATE_PARENT, APBC_PWM0, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA910_CLK_PWM1, \"pwm1_clk\", \"pll1_48\", CLK_SET_RATE_PARENT, APBC_PWM1, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA910_CLK_PWM2, \"pwm2_clk\", \"pll1_48\", CLK_SET_RATE_PARENT, APBC_PWM2, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t{PXA910_CLK_PWM3, \"pwm3_clk\", \"pll1_48\", CLK_SET_RATE_PARENT, APBC_PWM3, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t \n\t{PXA910_CLK_UART0, \"uart0_clk\", \"uart0_mux\", CLK_SET_RATE_PARENT, APBC_UART0, 0x3, 0x3, 0x0, 0, &uart0_lock},\n\t{PXA910_CLK_UART1, \"uart1_clk\", \"uart1_mux\", CLK_SET_RATE_PARENT, APBC_UART1, 0x3, 0x3, 0x0, 0, &uart1_lock},\n\t{PXA910_CLK_SSP0, \"ssp0_clk\", \"ssp0_mux\", CLK_SET_RATE_PARENT, APBC_SSP0, 0x3, 0x3, 0x0, 0, &ssp0_lock},\n\t{PXA910_CLK_SSP1, \"ssp1_clk\", \"ssp1_mux\", CLK_SET_RATE_PARENT, APBC_SSP1, 0x3, 0x3, 0x0, 0, &ssp1_lock},\n\t{PXA910_CLK_TIMER0, \"timer0_clk\", \"timer0_mux\", CLK_SET_RATE_PARENT, APBC_TIMER0, 0x3, 0x3, 0x0, 0, &timer0_lock},\n\t{PXA910_CLK_TIMER1, \"timer1_clk\", \"timer1_mux\", CLK_SET_RATE_PARENT, APBC_TIMER1, 0x3, 0x3, 0x0, 0, &timer1_lock},\n};\n\nstatic struct mmp_param_gate_clk apbcp_gate_clks[] = {\n\t{PXA910_CLK_TWSI1, \"twsi1_clk\", \"pll1_13_1_5\", CLK_SET_RATE_PARENT, APBCP_TWSI1, 0x3, 0x3, 0x0, 0, &reset_lock},\n\t \n\t{PXA910_CLK_UART2, \"uart2_clk\", \"uart2_mux\", CLK_SET_RATE_PARENT, APBCP_UART2, 0x3, 0x3, 0x0, 0, &uart2_lock},\n};\n\nstatic void pxa910_apb_periph_clk_init(struct pxa910_clk_unit *pxa_unit)\n{\n\tstruct mmp_clk_unit *unit = &pxa_unit->unit;\n\n\tmmp_register_mux_clks(unit, apbc_mux_clks, pxa_unit->apbc_base,\n\t\t\t\tARRAY_SIZE(apbc_mux_clks));\n\n\tmmp_register_mux_clks(unit, apbcp_mux_clks, pxa_unit->apbcp_base,\n\t\t\t\tARRAY_SIZE(apbcp_mux_clks));\n\n\tmmp_register_gate_clks(unit, apbc_gate_clks, pxa_unit->apbc_base,\n\t\t\t\tARRAY_SIZE(apbc_gate_clks));\n\n\tmmp_register_gate_clks(unit, apbcp_gate_clks, pxa_unit->apbcp_base,\n\t\t\t\tARRAY_SIZE(apbcp_gate_clks));\n}\n\nstatic DEFINE_SPINLOCK(sdh0_lock);\nstatic DEFINE_SPINLOCK(sdh1_lock);\nstatic const char *sdh_parent_names[] = {\"pll1_12\", \"pll1_13\"};\n\nstatic DEFINE_SPINLOCK(usb_lock);\n\nstatic DEFINE_SPINLOCK(disp0_lock);\nstatic const char *disp_parent_names[] = {\"pll1_2\", \"pll1_12\"};\n\nstatic DEFINE_SPINLOCK(ccic0_lock);\nstatic const char *ccic_parent_names[] = {\"pll1_2\", \"pll1_12\"};\nstatic const char *ccic_phy_parent_names[] = {\"pll1_6\", \"pll1_12\"};\n\nstatic struct mmp_param_mux_clk apmu_mux_clks[] = {\n\t{0, \"sdh0_mux\", sdh_parent_names, ARRAY_SIZE(sdh_parent_names), CLK_SET_RATE_PARENT, APMU_SDH0, 6, 1, 0, &sdh0_lock},\n\t{0, \"sdh1_mux\", sdh_parent_names, ARRAY_SIZE(sdh_parent_names), CLK_SET_RATE_PARENT, APMU_SDH1, 6, 1, 0, &sdh1_lock},\n\t{0, \"disp0_mux\", disp_parent_names, ARRAY_SIZE(disp_parent_names), CLK_SET_RATE_PARENT, APMU_DISP0, 6, 1, 0, &disp0_lock},\n\t{0, \"ccic0_mux\", ccic_parent_names, ARRAY_SIZE(ccic_parent_names), CLK_SET_RATE_PARENT, APMU_CCIC0, 6, 1, 0, &ccic0_lock},\n\t{0, \"ccic0_phy_mux\", ccic_phy_parent_names, ARRAY_SIZE(ccic_phy_parent_names), CLK_SET_RATE_PARENT, APMU_CCIC0, 7, 1, 0, &ccic0_lock},\n};\n\nstatic struct mmp_param_div_clk apmu_div_clks[] = {\n\t{0, \"ccic0_sphy_div\", \"ccic0_mux\", CLK_SET_RATE_PARENT, APMU_CCIC0, 10, 5, 0, &ccic0_lock},\n};\n\nstatic struct mmp_param_gate_clk apmu_gate_clks[] = {\n\t{PXA910_CLK_DFC, \"dfc_clk\", \"pll1_4\", CLK_SET_RATE_PARENT, APMU_DFC, 0x19b, 0x19b, 0x0, 0, NULL},\n\t{PXA910_CLK_USB, \"usb_clk\", \"usb_pll\", 0, APMU_USB, 0x9, 0x9, 0x0, 0, &usb_lock},\n\t{PXA910_CLK_SPH, \"sph_clk\", \"usb_pll\", 0, APMU_USB, 0x12, 0x12, 0x0, 0, &usb_lock},\n\t \n\t{PXA910_CLK_SDH0, \"sdh0_clk\", \"sdh0_mux\", CLK_SET_RATE_PARENT, APMU_SDH0, 0x1b, 0x1b, 0x0, 0, &sdh0_lock},\n\t{PXA910_CLK_SDH1, \"sdh1_clk\", \"sdh1_mux\", CLK_SET_RATE_PARENT, APMU_SDH1, 0x1b, 0x1b, 0x0, 0, &sdh1_lock},\n\t{PXA910_CLK_DISP0, \"disp0_clk\", \"disp0_mux\", CLK_SET_RATE_PARENT, APMU_DISP0, 0x1b, 0x1b, 0x0, 0, &disp0_lock},\n\t{PXA910_CLK_CCIC0, \"ccic0_clk\", \"ccic0_mux\", CLK_SET_RATE_PARENT, APMU_CCIC0, 0x1b, 0x1b, 0x0, 0, &ccic0_lock},\n\t{PXA910_CLK_CCIC0_PHY, \"ccic0_phy_clk\", \"ccic0_phy_mux\", CLK_SET_RATE_PARENT, APMU_CCIC0, 0x24, 0x24, 0x0, 0, &ccic0_lock},\n\t{PXA910_CLK_CCIC0_SPHY, \"ccic0_sphy_clk\", \"ccic0_sphy_div\", CLK_SET_RATE_PARENT, APMU_CCIC0, 0x300, 0x300, 0x0, 0, &ccic0_lock},\n};\n\nstatic void pxa910_axi_periph_clk_init(struct pxa910_clk_unit *pxa_unit)\n{\n\tstruct mmp_clk_unit *unit = &pxa_unit->unit;\n\n\tmmp_register_mux_clks(unit, apmu_mux_clks, pxa_unit->apmu_base,\n\t\t\t\tARRAY_SIZE(apmu_mux_clks));\n\n\tmmp_register_div_clks(unit, apmu_div_clks, pxa_unit->apmu_base,\n\t\t\t\tARRAY_SIZE(apmu_div_clks));\n\n\tmmp_register_gate_clks(unit, apmu_gate_clks, pxa_unit->apmu_base,\n\t\t\t\tARRAY_SIZE(apmu_gate_clks));\n}\n\nstatic void pxa910_clk_reset_init(struct device_node *np,\n\t\t\t\tstruct pxa910_clk_unit *pxa_unit)\n{\n\tstruct mmp_clk_reset_cell *cells;\n\tint i, base, nr_resets_apbc, nr_resets_apbcp, nr_resets;\n\n\tnr_resets_apbc = ARRAY_SIZE(apbc_gate_clks);\n\tnr_resets_apbcp = ARRAY_SIZE(apbcp_gate_clks);\n\tnr_resets = nr_resets_apbc + nr_resets_apbcp;\n\tcells = kcalloc(nr_resets, sizeof(*cells), GFP_KERNEL);\n\tif (!cells)\n\t\treturn;\n\n\tbase = 0;\n\tfor (i = 0; i < nr_resets_apbc; i++) {\n\t\tcells[base + i].clk_id = apbc_gate_clks[i].id;\n\t\tcells[base + i].reg =\n\t\t\tpxa_unit->apbc_base + apbc_gate_clks[i].offset;\n\t\tcells[base + i].flags = 0;\n\t\tcells[base + i].lock = apbc_gate_clks[i].lock;\n\t\tcells[base + i].bits = 0x4;\n\t}\n\n\tbase = nr_resets_apbc;\n\tfor (i = 0; i < nr_resets_apbcp; i++) {\n\t\tcells[base + i].clk_id = apbcp_gate_clks[i].id;\n\t\tcells[base + i].reg =\n\t\t\tpxa_unit->apbc_base + apbc_gate_clks[i].offset;\n\t\tcells[base + i].flags = 0;\n\t\tcells[base + i].lock = apbc_gate_clks[i].lock;\n\t\tcells[base + i].bits = 0x4;\n\t}\n\n\tmmp_clk_reset_register(np, cells, nr_resets);\n}\n\nstatic void __init pxa910_clk_init(struct device_node *np)\n{\n\tstruct pxa910_clk_unit *pxa_unit;\n\n\tpxa_unit = kzalloc(sizeof(*pxa_unit), GFP_KERNEL);\n\tif (!pxa_unit)\n\t\treturn;\n\n\tpxa_unit->mpmu_base = of_iomap(np, 0);\n\tif (!pxa_unit->mpmu_base) {\n\t\tpr_err(\"failed to map mpmu registers\\n\");\n\t\tgoto free_memory;\n\t}\n\n\tpxa_unit->apmu_base = of_iomap(np, 1);\n\tif (!pxa_unit->apmu_base) {\n\t\tpr_err(\"failed to map apmu registers\\n\");\n\t\tgoto unmap_mpmu_region;\n\t}\n\n\tpxa_unit->apbc_base = of_iomap(np, 2);\n\tif (!pxa_unit->apbc_base) {\n\t\tpr_err(\"failed to map apbc registers\\n\");\n\t\tgoto unmap_apmu_region;\n\t}\n\n\tpxa_unit->apbcp_base = of_iomap(np, 3);\n\tif (!pxa_unit->apbcp_base) {\n\t\tpr_err(\"failed to map apbcp registers\\n\");\n\t\tgoto unmap_apbc_region;\n\t}\n\n\tmmp_clk_init(np, &pxa_unit->unit, NR_CLKS);\n\n\tpxa910_pll_init(pxa_unit);\n\n\tpxa910_apb_periph_clk_init(pxa_unit);\n\n\tpxa910_axi_periph_clk_init(pxa_unit);\n\n\tpxa910_clk_reset_init(np, pxa_unit);\n\n\treturn;\n\nunmap_apbc_region:\n\tiounmap(pxa_unit->apbc_base);\nunmap_apmu_region:\n\tiounmap(pxa_unit->apmu_base);\nunmap_mpmu_region:\n\tiounmap(pxa_unit->mpmu_base);\nfree_memory:\n\tkfree(pxa_unit);\n}\n\nCLK_OF_DECLARE(pxa910_clk, \"marvell,pxa910-clock\", pxa910_clk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}