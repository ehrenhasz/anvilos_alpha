{
  "module_name": "reset.c",
  "hash_id": "dc03426b384e4fe7c8387934539bd179a04cd0f029d0b13697a922517112c5a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mmp/reset.c",
  "human_readable_source": "\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/reset-controller.h>\n\n#include \"reset.h\"\n\n#define rcdev_to_unit(rcdev) container_of(rcdev, struct mmp_clk_reset_unit, rcdev)\n\nstatic int mmp_of_reset_xlate(struct reset_controller_dev *rcdev,\n\t\t\t  const struct of_phandle_args *reset_spec)\n{\n\tstruct mmp_clk_reset_unit *unit = rcdev_to_unit(rcdev);\n\tstruct mmp_clk_reset_cell *cell;\n\tint i;\n\n\tif (WARN_ON(reset_spec->args_count != rcdev->of_reset_n_cells))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < rcdev->nr_resets; i++) {\n\t\tcell = &unit->cells[i];\n\t\tif (cell->clk_id == reset_spec->args[0])\n\t\t\tbreak;\n\t}\n\n\tif (i == rcdev->nr_resets)\n\t\treturn -EINVAL;\n\n\treturn i;\n}\n\nstatic int mmp_clk_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\tstruct mmp_clk_reset_unit *unit = rcdev_to_unit(rcdev);\n\tstruct mmp_clk_reset_cell *cell;\n\tunsigned long flags = 0;\n\tu32 val;\n\n\tcell = &unit->cells[id];\n\tif (cell->lock)\n\t\tspin_lock_irqsave(cell->lock, flags);\n\n\tval = readl(cell->reg);\n\tval |= cell->bits;\n\twritel(val, cell->reg);\n\n\tif (cell->lock)\n\t\tspin_unlock_irqrestore(cell->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mmp_clk_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\tstruct mmp_clk_reset_unit *unit = rcdev_to_unit(rcdev);\n\tstruct mmp_clk_reset_cell *cell;\n\tunsigned long flags = 0;\n\tu32 val;\n\n\tcell = &unit->cells[id];\n\tif (cell->lock)\n\t\tspin_lock_irqsave(cell->lock, flags);\n\n\tval = readl(cell->reg);\n\tval &= ~cell->bits;\n\twritel(val, cell->reg);\n\n\tif (cell->lock)\n\t\tspin_unlock_irqrestore(cell->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct reset_control_ops mmp_clk_reset_ops = {\n\t.assert\t\t= mmp_clk_reset_assert,\n\t.deassert\t= mmp_clk_reset_deassert,\n};\n\nvoid mmp_clk_reset_register(struct device_node *np,\n\t\t\tstruct mmp_clk_reset_cell *cells, int nr_resets)\n{\n\tstruct mmp_clk_reset_unit *unit;\n\n\tunit = kzalloc(sizeof(*unit), GFP_KERNEL);\n\tif (!unit)\n\t\treturn;\n\n\tunit->cells = cells;\n\tunit->rcdev.of_reset_n_cells = 1;\n\tunit->rcdev.nr_resets = nr_resets;\n\tunit->rcdev.ops = &mmp_clk_reset_ops;\n\tunit->rcdev.of_node = np;\n\tunit->rcdev.of_xlate = mmp_of_reset_xlate;\n\n\treset_controller_register(&unit->rcdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}