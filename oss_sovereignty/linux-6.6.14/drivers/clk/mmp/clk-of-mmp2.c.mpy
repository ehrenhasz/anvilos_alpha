{
  "module_name": "clk-of-mmp2.c",
  "hash_id": "ebc9171233e02b3f05ee56ad1fc54d97c8759b3a2452b7c1f49a966a68d30596",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mmp/clk-of-mmp2.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/of_address.h>\n#include <linux/clk.h>\n\n#include <dt-bindings/clock/marvell,mmp2.h>\n#include <dt-bindings/power/marvell,mmp2.h>\n\n#include \"clk.h\"\n#include \"reset.h\"\n\n#define APBC_RTC\t0x0\n#define APBC_TWSI0\t0x4\n#define APBC_TWSI1\t0x8\n#define APBC_TWSI2\t0xc\n#define APBC_TWSI3\t0x10\n#define APBC_TWSI4\t0x7c\n#define APBC_TWSI5\t0x80\n#define APBC_KPC\t0x18\n#define APBC_TIMER\t0x24\n#define APBC_UART0\t0x2c\n#define APBC_UART1\t0x30\n#define APBC_UART2\t0x34\n#define APBC_UART3\t0x88\n#define APBC_GPIO\t0x38\n#define APBC_PWM0\t0x3c\n#define APBC_PWM1\t0x40\n#define APBC_PWM2\t0x44\n#define APBC_PWM3\t0x48\n#define APBC_SSP0\t0x50\n#define APBC_SSP1\t0x54\n#define APBC_SSP2\t0x58\n#define APBC_SSP3\t0x5c\n#define APBC_THERMAL0\t0x90\n#define APBC_THERMAL1\t0x98\n#define APBC_THERMAL2\t0x9c\n#define APBC_THERMAL3\t0xa0\n#define APMU_SDH0\t0x54\n#define APMU_SDH1\t0x58\n#define APMU_SDH2\t0xe8\n#define APMU_SDH3\t0xec\n#define APMU_SDH4\t0x15c\n#define APMU_USB\t0x5c\n#define APMU_DISP0\t0x4c\n#define APMU_DISP1\t0x110\n#define APMU_CCIC0\t0x50\n#define APMU_CCIC1\t0xf4\n#define APMU_USBHSIC0\t0xf8\n#define APMU_USBHSIC1\t0xfc\n#define APMU_GPU\t0xcc\n#define APMU_AUDIO\t0x10c\n#define APMU_CAMERA\t0x1fc\n\n#define MPMU_FCCR\t\t0x8\n#define MPMU_POSR\t\t0x10\n#define MPMU_UART_PLL\t\t0x14\n#define MPMU_PLL2_CR\t\t0x34\n#define MPMU_I2S0_PLL\t\t0x40\n#define MPMU_I2S1_PLL\t\t0x44\n#define MPMU_ACGR\t\t0x1024\n \n#define MPMU_PLL3_CR\t\t0x50\n#define MPMU_PLL3_CTRL1\t\t0x58\n#define MPMU_PLL1_CTRL\t\t0x5c\n#define MPMU_PLL_DIFF_CTRL\t0x68\n#define MPMU_PLL2_CTRL1\t\t0x414\n\n#define NR_CLKS\t\t200\n\nenum mmp2_clk_model {\n\tCLK_MODEL_MMP2,\n\tCLK_MODEL_MMP3,\n};\n\nstruct mmp2_clk_unit {\n\tstruct mmp_clk_unit unit;\n\tenum mmp2_clk_model model;\n\tstruct genpd_onecell_data pd_data;\n\tstruct generic_pm_domain *pm_domains[MMP2_NR_POWER_DOMAINS];\n\tvoid __iomem *mpmu_base;\n\tvoid __iomem *apmu_base;\n\tvoid __iomem *apbc_base;\n};\n\nstatic struct mmp_param_fixed_rate_clk fixed_rate_clks[] = {\n\t{MMP2_CLK_CLK32, \"clk32\", NULL, 0, 32768},\n\t{MMP2_CLK_VCTCXO, \"vctcxo\", NULL, 0, 26000000},\n\t{MMP2_CLK_USB_PLL, \"usb_pll\", NULL, 0, 480000000},\n\t{0, \"i2s_pll\", NULL, 0, 99666667},\n};\n\nstatic struct mmp_param_pll_clk pll_clks[] = {\n\t{MMP2_CLK_PLL1,   \"pll1\",   797330000, MPMU_FCCR,          0x4000, MPMU_POSR,     0},\n\t{MMP2_CLK_PLL2,   \"pll2\",           0, MPMU_PLL2_CR,       0x0300, MPMU_PLL2_CR, 10},\n};\n\nstatic struct mmp_param_pll_clk mmp3_pll_clks[] = {\n\t{MMP2_CLK_PLL2,   \"pll1\",   797330000, MPMU_FCCR,          0x4000, MPMU_POSR,     0,      26000000, MPMU_PLL1_CTRL,      25},\n\t{MMP2_CLK_PLL2,   \"pll2\",           0, MPMU_PLL2_CR,       0x0300, MPMU_PLL2_CR, 10,      26000000, MPMU_PLL2_CTRL1,     25},\n\t{MMP3_CLK_PLL1_P, \"pll1_p\",         0, MPMU_PLL_DIFF_CTRL, 0x0010, 0,             0,     797330000, MPMU_PLL_DIFF_CTRL,   0},\n\t{MMP3_CLK_PLL2_P, \"pll2_p\",         0, MPMU_PLL_DIFF_CTRL, 0x0100, MPMU_PLL2_CR, 10,      26000000, MPMU_PLL_DIFF_CTRL,   5},\n\t{MMP3_CLK_PLL3,   \"pll3\",           0, MPMU_PLL3_CR,       0x0300, MPMU_PLL3_CR, 10,      26000000, MPMU_PLL3_CTRL1,     25},\n};\n\nstatic struct mmp_param_fixed_factor_clk fixed_factor_clks[] = {\n\t{MMP2_CLK_PLL1_2, \"pll1_2\", \"pll1\", 1, 2, 0},\n\t{MMP2_CLK_PLL1_4, \"pll1_4\", \"pll1_2\", 1, 2, 0},\n\t{MMP2_CLK_PLL1_8, \"pll1_8\", \"pll1_4\", 1, 2, 0},\n\t{MMP2_CLK_PLL1_16, \"pll1_16\", \"pll1_8\", 1, 2, 0},\n\t{MMP2_CLK_PLL1_20, \"pll1_20\", \"pll1_4\", 1, 5, 0},\n\t{MMP2_CLK_PLL1_3, \"pll1_3\", \"pll1\", 1, 3, 0},\n\t{MMP2_CLK_PLL1_6, \"pll1_6\", \"pll1_3\", 1, 2, 0},\n\t{MMP2_CLK_PLL1_12, \"pll1_12\", \"pll1_6\", 1, 2, 0},\n\t{MMP2_CLK_PLL2_2, \"pll2_2\", \"pll2\", 1, 2, 0},\n\t{MMP2_CLK_PLL2_4, \"pll2_4\", \"pll2_2\", 1, 2, 0},\n\t{MMP2_CLK_PLL2_8, \"pll2_8\", \"pll2_4\", 1, 2, 0},\n\t{MMP2_CLK_PLL2_16, \"pll2_16\", \"pll2_8\", 1, 2, 0},\n\t{MMP2_CLK_PLL2_3, \"pll2_3\", \"pll2\", 1, 3, 0},\n\t{MMP2_CLK_PLL2_6, \"pll2_6\", \"pll2_3\", 1, 2, 0},\n\t{MMP2_CLK_PLL2_12, \"pll2_12\", \"pll2_6\", 1, 2, 0},\n\t{MMP2_CLK_VCTCXO_2, \"vctcxo_2\", \"vctcxo\", 1, 2, 0},\n\t{MMP2_CLK_VCTCXO_4, \"vctcxo_4\", \"vctcxo_2\", 1, 2, 0},\n};\n\nstatic struct mmp_clk_factor_masks uart_factor_masks = {\n\t.factor = 2,\n\t.num_mask = 0x1fff,\n\t.den_mask = 0x1fff,\n\t.num_shift = 16,\n\t.den_shift = 0,\n};\n\nstatic struct mmp_clk_factor_tbl uart_factor_tbl[] = {\n\t{.num = 8125, .den = 1536},\t \n\t{.num = 3521, .den = 689},\t \n};\n\nstatic struct mmp_clk_factor_masks i2s_factor_masks = {\n\t.factor = 2,\n\t.num_mask = 0x7fff,\n\t.den_mask = 0x1fff,\n\t.num_shift = 0,\n\t.den_shift = 15,\n\t.enable_mask = 0xd0000000,\n};\n\nstatic struct mmp_clk_factor_tbl i2s_factor_tbl[] = {\n\t{.num = 24868, .den =  511},\t \n\t{.num = 28003, .den =  793},\t \n\t{.num = 24941, .den = 1025},\t \n\t{.num = 28003, .den = 1586},\t \n\t{.num = 31158, .den = 2561},\t \n\t{.num = 16288, .den = 1845},\t \n\t{.num = 20772, .den = 2561},\t \n\t{.num =  8144, .den = 1845},\t \n\t{.num = 10386, .den = 2561},\t \n};\n\nstatic DEFINE_SPINLOCK(acgr_lock);\n\nstatic struct mmp_param_gate_clk mpmu_gate_clks[] = {\n\t{MMP2_CLK_I2S0, \"i2s0_clk\", \"i2s0_pll\", CLK_SET_RATE_PARENT, MPMU_ACGR, 0x200000, 0x200000, 0x0, 0, &acgr_lock},\n\t{MMP2_CLK_I2S1, \"i2s1_clk\", \"i2s1_pll\", CLK_SET_RATE_PARENT, MPMU_ACGR, 0x100000, 0x100000, 0x0, 0, &acgr_lock},\n};\n\nstatic void mmp2_main_clk_init(struct mmp2_clk_unit *pxa_unit)\n{\n\tstruct clk *clk;\n\tstruct mmp_clk_unit *unit = &pxa_unit->unit;\n\n\tmmp_register_fixed_rate_clks(unit, fixed_rate_clks,\n\t\t\t\t\tARRAY_SIZE(fixed_rate_clks));\n\n\tif (pxa_unit->model == CLK_MODEL_MMP3) {\n\t\tmmp_register_pll_clks(unit, mmp3_pll_clks,\n\t\t\t\t\tpxa_unit->mpmu_base,\n\t\t\t\t\tARRAY_SIZE(mmp3_pll_clks));\n\t} else {\n\t\tmmp_register_pll_clks(unit, pll_clks,\n\t\t\t\t\tpxa_unit->mpmu_base,\n\t\t\t\t\tARRAY_SIZE(pll_clks));\n\t}\n\n\tmmp_register_fixed_factor_clks(unit, fixed_factor_clks,\n\t\t\t\t\tARRAY_SIZE(fixed_factor_clks));\n\n\tclk = mmp_clk_register_factor(\"uart_pll\", \"pll1_4\",\n\t\t\t\tCLK_SET_RATE_PARENT,\n\t\t\t\tpxa_unit->mpmu_base + MPMU_UART_PLL,\n\t\t\t\t&uart_factor_masks, uart_factor_tbl,\n\t\t\t\tARRAY_SIZE(uart_factor_tbl), NULL);\n\tmmp_clk_add(unit, MMP2_CLK_UART_PLL, clk);\n\n\tmmp_clk_register_factor(\"i2s0_pll\", \"pll1_4\",\n\t\t\t\tCLK_SET_RATE_PARENT,\n\t\t\t\tpxa_unit->mpmu_base + MPMU_I2S0_PLL,\n\t\t\t\t&i2s_factor_masks, i2s_factor_tbl,\n\t\t\t\tARRAY_SIZE(i2s_factor_tbl), NULL);\n\tmmp_clk_register_factor(\"i2s1_pll\", \"pll1_4\",\n\t\t\t\tCLK_SET_RATE_PARENT,\n\t\t\t\tpxa_unit->mpmu_base + MPMU_I2S1_PLL,\n\t\t\t\t&i2s_factor_masks, i2s_factor_tbl,\n\t\t\t\tARRAY_SIZE(i2s_factor_tbl), NULL);\n\n\tmmp_register_gate_clks(unit, mpmu_gate_clks, pxa_unit->mpmu_base,\n\t\t\t\tARRAY_SIZE(mpmu_gate_clks));\n}\n\nstatic DEFINE_SPINLOCK(uart0_lock);\nstatic DEFINE_SPINLOCK(uart1_lock);\nstatic DEFINE_SPINLOCK(uart2_lock);\nstatic const char * const uart_parent_names[] = {\"uart_pll\", \"vctcxo\"};\n\nstatic DEFINE_SPINLOCK(ssp0_lock);\nstatic DEFINE_SPINLOCK(ssp1_lock);\nstatic DEFINE_SPINLOCK(ssp2_lock);\nstatic DEFINE_SPINLOCK(ssp3_lock);\nstatic const char * const ssp_parent_names[] = {\"vctcxo_4\", \"vctcxo_2\", \"vctcxo\", \"pll1_16\"};\n\nstatic DEFINE_SPINLOCK(timer_lock);\nstatic const char * const timer_parent_names[] = {\"clk32\", \"vctcxo_4\", \"vctcxo_2\", \"vctcxo\"};\n\nstatic DEFINE_SPINLOCK(reset_lock);\n\nstatic struct mmp_param_mux_clk apbc_mux_clks[] = {\n\t{0, \"uart0_mux\", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, APBC_UART0, 4, 3, 0, &uart0_lock},\n\t{0, \"uart1_mux\", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, APBC_UART1, 4, 3, 0, &uart1_lock},\n\t{0, \"uart2_mux\", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, APBC_UART2, 4, 3, 0, &uart2_lock},\n\t{0, \"uart3_mux\", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, APBC_UART3, 4, 3, 0, &uart2_lock},\n\t{0, \"ssp0_mux\", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), CLK_SET_RATE_PARENT, APBC_SSP0, 4, 3, 0, &ssp0_lock},\n\t{0, \"ssp1_mux\", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), CLK_SET_RATE_PARENT, APBC_SSP1, 4, 3, 0, &ssp1_lock},\n\t{0, \"ssp2_mux\", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), CLK_SET_RATE_PARENT, APBC_SSP2, 4, 3, 0, &ssp2_lock},\n\t{0, \"ssp3_mux\", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), CLK_SET_RATE_PARENT, APBC_SSP3, 4, 3, 0, &ssp3_lock},\n\t{0, \"timer_mux\", timer_parent_names, ARRAY_SIZE(timer_parent_names), CLK_SET_RATE_PARENT, APBC_TIMER, 4, 3, 0, &timer_lock},\n};\n\nstatic struct mmp_param_gate_clk apbc_gate_clks[] = {\n\t{MMP2_CLK_TWSI0, \"twsi0_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, APBC_TWSI0, 0x7, 0x3, 0x0, 0, &reset_lock},\n\t{MMP2_CLK_TWSI1, \"twsi1_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, APBC_TWSI1, 0x7, 0x3, 0x0, 0, &reset_lock},\n\t{MMP2_CLK_TWSI2, \"twsi2_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, APBC_TWSI2, 0x7, 0x3, 0x0, 0, &reset_lock},\n\t{MMP2_CLK_TWSI3, \"twsi3_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, APBC_TWSI3, 0x7, 0x3, 0x0, 0, &reset_lock},\n\t{MMP2_CLK_TWSI4, \"twsi4_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, APBC_TWSI4, 0x7, 0x3, 0x0, 0, &reset_lock},\n\t{MMP2_CLK_TWSI5, \"twsi5_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, APBC_TWSI5, 0x7, 0x3, 0x0, 0, &reset_lock},\n\t{MMP2_CLK_GPIO, \"gpio_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, APBC_GPIO, 0x7, 0x3, 0x0, 0, &reset_lock},\n\t{MMP2_CLK_KPC, \"kpc_clk\", \"clk32\", CLK_SET_RATE_PARENT, APBC_KPC, 0x7, 0x3, 0x0, MMP_CLK_GATE_NEED_DELAY, &reset_lock},\n\t{MMP2_CLK_RTC, \"rtc_clk\", \"clk32\", CLK_SET_RATE_PARENT, APBC_RTC, 0x87, 0x83, 0x0, MMP_CLK_GATE_NEED_DELAY, &reset_lock},\n\t{MMP2_CLK_PWM0, \"pwm0_clk\", \"pll1_48\", CLK_SET_RATE_PARENT, APBC_PWM0, 0x7, 0x3, 0x0, 0, &reset_lock},\n\t{MMP2_CLK_PWM1, \"pwm1_clk\", \"pll1_48\", CLK_SET_RATE_PARENT, APBC_PWM1, 0x7, 0x3, 0x0, 0, &reset_lock},\n\t{MMP2_CLK_PWM2, \"pwm2_clk\", \"pll1_48\", CLK_SET_RATE_PARENT, APBC_PWM2, 0x7, 0x3, 0x0, 0, &reset_lock},\n\t{MMP2_CLK_PWM3, \"pwm3_clk\", \"pll1_48\", CLK_SET_RATE_PARENT, APBC_PWM3, 0x7, 0x3, 0x0, 0, &reset_lock},\n\t \n\t{MMP2_CLK_UART0, \"uart0_clk\", \"uart0_mux\", CLK_SET_RATE_PARENT, APBC_UART0, 0x7, 0x3, 0x0, 0, &uart0_lock},\n\t{MMP2_CLK_UART1, \"uart1_clk\", \"uart1_mux\", CLK_SET_RATE_PARENT, APBC_UART1, 0x7, 0x3, 0x0, 0, &uart1_lock},\n\t{MMP2_CLK_UART2, \"uart2_clk\", \"uart2_mux\", CLK_SET_RATE_PARENT, APBC_UART2, 0x7, 0x3, 0x0, 0, &uart2_lock},\n\t{MMP2_CLK_UART3, \"uart3_clk\", \"uart3_mux\", CLK_SET_RATE_PARENT, APBC_UART3, 0x7, 0x3, 0x0, 0, &uart2_lock},\n\t{MMP2_CLK_SSP0, \"ssp0_clk\", \"ssp0_mux\", CLK_SET_RATE_PARENT, APBC_SSP0, 0x7, 0x3, 0x0, 0, &ssp0_lock},\n\t{MMP2_CLK_SSP1, \"ssp1_clk\", \"ssp1_mux\", CLK_SET_RATE_PARENT, APBC_SSP1, 0x7, 0x3, 0x0, 0, &ssp1_lock},\n\t{MMP2_CLK_SSP2, \"ssp2_clk\", \"ssp2_mux\", CLK_SET_RATE_PARENT, APBC_SSP2, 0x7, 0x3, 0x0, 0, &ssp2_lock},\n\t{MMP2_CLK_SSP3, \"ssp3_clk\", \"ssp3_mux\", CLK_SET_RATE_PARENT, APBC_SSP3, 0x7, 0x3, 0x0, 0, &ssp3_lock},\n\t{MMP2_CLK_TIMER, \"timer_clk\", \"timer_mux\", CLK_SET_RATE_PARENT, APBC_TIMER, 0x7, 0x3, 0x0, 0, &timer_lock},\n\t{MMP2_CLK_THERMAL0, \"thermal0_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, APBC_THERMAL0, 0x7, 0x3, 0x0, MMP_CLK_GATE_NEED_DELAY, &reset_lock},\n};\n\nstatic struct mmp_param_gate_clk mmp3_apbc_gate_clks[] = {\n\t{MMP3_CLK_THERMAL1, \"thermal1_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, APBC_THERMAL1, 0x7, 0x3, 0x0, MMP_CLK_GATE_NEED_DELAY, &reset_lock},\n\t{MMP3_CLK_THERMAL2, \"thermal2_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, APBC_THERMAL2, 0x7, 0x3, 0x0, MMP_CLK_GATE_NEED_DELAY, &reset_lock},\n\t{MMP3_CLK_THERMAL3, \"thermal3_clk\", \"vctcxo\", CLK_SET_RATE_PARENT, APBC_THERMAL3, 0x7, 0x3, 0x0, MMP_CLK_GATE_NEED_DELAY, &reset_lock},\n};\n\nstatic void mmp2_apb_periph_clk_init(struct mmp2_clk_unit *pxa_unit)\n{\n\tstruct mmp_clk_unit *unit = &pxa_unit->unit;\n\n\tmmp_register_mux_clks(unit, apbc_mux_clks, pxa_unit->apbc_base,\n\t\t\t\tARRAY_SIZE(apbc_mux_clks));\n\n\tmmp_register_gate_clks(unit, apbc_gate_clks, pxa_unit->apbc_base,\n\t\t\t\tARRAY_SIZE(apbc_gate_clks));\n\n\tif (pxa_unit->model == CLK_MODEL_MMP3) {\n\t\tmmp_register_gate_clks(unit, mmp3_apbc_gate_clks, pxa_unit->apbc_base,\n\t\t\t\t\tARRAY_SIZE(mmp3_apbc_gate_clks));\n\t}\n}\n\nstatic DEFINE_SPINLOCK(sdh_lock);\nstatic const char * const sdh_parent_names[] = {\"pll1_4\", \"pll2\", \"usb_pll\", \"pll1\"};\nstatic struct mmp_clk_mix_config sdh_mix_config = {\n\t.reg_info = DEFINE_MIX_REG_INFO(4, 10, 2, 8, 32),\n};\n\nstatic DEFINE_SPINLOCK(usb_lock);\nstatic DEFINE_SPINLOCK(usbhsic0_lock);\nstatic DEFINE_SPINLOCK(usbhsic1_lock);\n\nstatic DEFINE_SPINLOCK(disp0_lock);\nstatic DEFINE_SPINLOCK(disp1_lock);\nstatic const char * const disp_parent_names[] = {\"pll1\", \"pll1_16\", \"pll2\", \"vctcxo\"};\n\nstatic DEFINE_SPINLOCK(ccic0_lock);\nstatic DEFINE_SPINLOCK(ccic1_lock);\nstatic const char * const ccic_parent_names[] = {\"pll1_2\", \"pll1_16\", \"vctcxo\"};\n\nstatic DEFINE_SPINLOCK(gpu_lock);\nstatic const char * const mmp2_gpu_gc_parent_names[] =  {\"pll1_2\", \"pll1_3\", \"pll2_2\", \"pll2_3\", \"pll2\", \"usb_pll\"};\nstatic const u32 mmp2_gpu_gc_parent_table[] = { 0x0000,   0x0040,   0x0080,   0x00c0,   0x1000, 0x1040   };\nstatic const char * const mmp2_gpu_bus_parent_names[] = {\"pll1_4\", \"pll2\",   \"pll2_2\", \"usb_pll\"};\nstatic const u32 mmp2_gpu_bus_parent_table[] = { 0x0000,   0x0020,   0x0030,   0x4020   };\nstatic const char * const mmp3_gpu_bus_parent_names[] = {\"pll1_4\", \"pll1_6\", \"pll1_2\", \"pll2_2\"};\nstatic const char * const mmp3_gpu_gc_parent_names[] =  {\"pll1\",   \"pll2\",   \"pll1_p\", \"pll2_p\"};\n\nstatic DEFINE_SPINLOCK(audio_lock);\n\nstatic struct mmp_clk_mix_config ccic0_mix_config = {\n\t.reg_info = DEFINE_MIX_REG_INFO(4, 17, 2, 6, 32),\n};\nstatic struct mmp_clk_mix_config ccic1_mix_config = {\n\t.reg_info = DEFINE_MIX_REG_INFO(4, 16, 2, 6, 32),\n};\n\nstatic struct mmp_param_mux_clk apmu_mux_clks[] = {\n\t{MMP2_CLK_DISP0_MUX, \"disp0_mux\", disp_parent_names, ARRAY_SIZE(disp_parent_names), CLK_SET_RATE_PARENT, APMU_DISP0, 6, 2, 0, &disp0_lock},\n\t{MMP2_CLK_DISP1_MUX, \"disp1_mux\", disp_parent_names, ARRAY_SIZE(disp_parent_names), CLK_SET_RATE_PARENT, APMU_DISP1, 6, 2, 0, &disp1_lock},\n};\n\nstatic struct mmp_param_mux_clk mmp3_apmu_mux_clks[] = {\n\t{0, \"gpu_bus_mux\", mmp3_gpu_bus_parent_names, ARRAY_SIZE(mmp3_gpu_bus_parent_names),\n\t\t\t\t\t\t\t\t\tCLK_SET_RATE_PARENT, APMU_GPU, 4, 2, 0, &gpu_lock},\n\t{0, \"gpu_3d_mux\", mmp3_gpu_gc_parent_names, ARRAY_SIZE(mmp3_gpu_gc_parent_names),\n\t\t\t\t\t\t\t\t\tCLK_SET_RATE_PARENT, APMU_GPU, 6, 2, 0, &gpu_lock},\n\t{0, \"gpu_2d_mux\", mmp3_gpu_gc_parent_names, ARRAY_SIZE(mmp3_gpu_gc_parent_names),\n\t\t\t\t\t\t\t\t\tCLK_SET_RATE_PARENT, APMU_GPU, 12, 2, 0, &gpu_lock},\n};\n\nstatic struct mmp_param_div_clk apmu_div_clks[] = {\n\t{0, \"disp0_div\", \"disp0_mux\", CLK_SET_RATE_PARENT, APMU_DISP0, 8, 4, CLK_DIVIDER_ONE_BASED, &disp0_lock},\n\t{0, \"disp0_sphy_div\", \"disp0_mux\", CLK_SET_RATE_PARENT, APMU_DISP0, 15, 5, 0, &disp0_lock},\n\t{0, \"disp1_div\", \"disp1_mux\", CLK_SET_RATE_PARENT, APMU_DISP1, 8, 4, CLK_DIVIDER_ONE_BASED, &disp1_lock},\n\t{0, \"ccic0_sphy_div\", \"ccic0_mix_clk\", CLK_SET_RATE_PARENT, APMU_CCIC0, 10, 5, 0, &ccic0_lock},\n\t{0, \"ccic1_sphy_div\", \"ccic1_mix_clk\", CLK_SET_RATE_PARENT, APMU_CCIC1, 10, 5, 0, &ccic1_lock},\n};\n\nstatic struct mmp_param_div_clk mmp3_apmu_div_clks[] = {\n\t{0, \"gpu_3d_div\", \"gpu_3d_mux\", CLK_SET_RATE_PARENT, APMU_GPU, 24, 4, 0, &gpu_lock},\n\t{0, \"gpu_2d_div\", \"gpu_2d_mux\", CLK_SET_RATE_PARENT, APMU_GPU, 28, 4, 0, &gpu_lock},\n};\n\nstatic struct mmp_param_gate_clk apmu_gate_clks[] = {\n\t{MMP2_CLK_USB, \"usb_clk\", \"usb_pll\", 0, APMU_USB, 0x9, 0x9, 0x0, 0, &usb_lock},\n\t{MMP2_CLK_USBHSIC0, \"usbhsic0_clk\", \"usb_pll\", 0, APMU_USBHSIC0, 0x1b, 0x1b, 0x0, 0, &usbhsic0_lock},\n\t{MMP2_CLK_USBHSIC1, \"usbhsic1_clk\", \"usb_pll\", 0, APMU_USBHSIC1, 0x1b, 0x1b, 0x0, 0, &usbhsic1_lock},\n\t \n\t{MMP2_CLK_SDH0, \"sdh0_clk\", \"sdh_mix_clk\", CLK_SET_RATE_PARENT, APMU_SDH0, 0x1b, 0x1b, 0x0, 0, &sdh_lock},\n\t{MMP2_CLK_SDH1, \"sdh1_clk\", \"sdh_mix_clk\", CLK_SET_RATE_PARENT, APMU_SDH1, 0x1b, 0x1b, 0x0, 0, &sdh_lock},\n\t{MMP2_CLK_SDH2, \"sdh2_clk\", \"sdh_mix_clk\", CLK_SET_RATE_PARENT, APMU_SDH2, 0x1b, 0x1b, 0x0, 0, &sdh_lock},\n\t{MMP2_CLK_SDH3, \"sdh3_clk\", \"sdh_mix_clk\", CLK_SET_RATE_PARENT, APMU_SDH3, 0x1b, 0x1b, 0x0, 0, &sdh_lock},\n\t{MMP2_CLK_DISP0, \"disp0_clk\", \"disp0_div\", CLK_SET_RATE_PARENT, APMU_DISP0, 0x12, 0x12, 0x0, 0, &disp0_lock},\n\t{MMP2_CLK_DISP0_LCDC, \"disp0_lcdc_clk\", \"disp0_mux\", CLK_SET_RATE_PARENT, APMU_DISP0, 0x09, 0x09, 0x0, 0, &disp0_lock},\n\t{MMP2_CLK_DISP0_SPHY, \"disp0_sphy_clk\", \"disp0_sphy_div\", CLK_SET_RATE_PARENT, APMU_DISP0, 0x1024, 0x1024, 0x0, 0, &disp0_lock},\n\t{MMP2_CLK_DISP1, \"disp1_clk\", \"disp1_div\", CLK_SET_RATE_PARENT, APMU_DISP1, 0x09, 0x09, 0x0, 0, &disp1_lock},\n\t{MMP2_CLK_CCIC_ARBITER, \"ccic_arbiter\", \"vctcxo\", CLK_SET_RATE_PARENT, APMU_CCIC0, 0x1800, 0x1800, 0x0, 0, &ccic0_lock},\n\t{MMP2_CLK_CCIC0, \"ccic0_clk\", \"ccic0_mix_clk\", CLK_SET_RATE_PARENT, APMU_CCIC0, 0x1b, 0x1b, 0x0, 0, &ccic0_lock},\n\t{MMP2_CLK_CCIC0_PHY, \"ccic0_phy_clk\", \"ccic0_mix_clk\", CLK_SET_RATE_PARENT, APMU_CCIC0, 0x24, 0x24, 0x0, 0, &ccic0_lock},\n\t{MMP2_CLK_CCIC0_SPHY, \"ccic0_sphy_clk\", \"ccic0_sphy_div\", CLK_SET_RATE_PARENT, APMU_CCIC0, 0x300, 0x300, 0x0, 0, &ccic0_lock},\n\t{MMP2_CLK_CCIC1, \"ccic1_clk\", \"ccic1_mix_clk\", CLK_SET_RATE_PARENT, APMU_CCIC1, 0x1b, 0x1b, 0x0, 0, &ccic1_lock},\n\t{MMP2_CLK_CCIC1_PHY, \"ccic1_phy_clk\", \"ccic1_mix_clk\", CLK_SET_RATE_PARENT, APMU_CCIC1, 0x24, 0x24, 0x0, 0, &ccic1_lock},\n\t{MMP2_CLK_CCIC1_SPHY, \"ccic1_sphy_clk\", \"ccic1_sphy_div\", CLK_SET_RATE_PARENT, APMU_CCIC1, 0x300, 0x300, 0x0, 0, &ccic1_lock},\n\t{MMP2_CLK_GPU_BUS, \"gpu_bus_clk\", \"gpu_bus_mux\", CLK_SET_RATE_PARENT, APMU_GPU, 0xa, 0xa, 0x0, MMP_CLK_GATE_NEED_DELAY, &gpu_lock},\n\t{MMP2_CLK_AUDIO, \"audio_clk\", \"audio_mix_clk\", CLK_SET_RATE_PARENT, APMU_AUDIO, 0x12, 0x12, 0x0, 0, &audio_lock},\n};\n\nstatic struct mmp_param_gate_clk mmp2_apmu_gate_clks[] = {\n\t{MMP2_CLK_GPU_3D, \"gpu_3d_clk\", \"gpu_3d_mux\", CLK_SET_RATE_PARENT, APMU_GPU, 0x5, 0x5, 0x0, MMP_CLK_GATE_NEED_DELAY, &gpu_lock},\n};\n\nstatic struct mmp_param_gate_clk mmp3_apmu_gate_clks[] = {\n\t{MMP3_CLK_SDH4, \"sdh4_clk\", \"sdh_mix_clk\", CLK_SET_RATE_PARENT, APMU_SDH4, 0x1b, 0x1b, 0x0, 0, &sdh_lock},\n\t{MMP3_CLK_GPU_3D, \"gpu_3d_clk\", \"gpu_3d_div\", CLK_SET_RATE_PARENT, APMU_GPU, 0x5, 0x5, 0x0, MMP_CLK_GATE_NEED_DELAY, &gpu_lock},\n\t{MMP3_CLK_GPU_2D, \"gpu_2d_clk\", \"gpu_2d_div\", CLK_SET_RATE_PARENT, APMU_GPU, 0x1c0000, 0x1c0000, 0x0, MMP_CLK_GATE_NEED_DELAY, &gpu_lock},\n};\n\nstatic void mmp2_axi_periph_clk_init(struct mmp2_clk_unit *pxa_unit)\n{\n\tstruct clk *clk;\n\tstruct mmp_clk_unit *unit = &pxa_unit->unit;\n\n\tsdh_mix_config.reg_info.reg_clk_ctrl = pxa_unit->apmu_base + APMU_SDH0;\n\tclk = mmp_clk_register_mix(NULL, \"sdh_mix_clk\", sdh_parent_names,\n\t\t\t\t\tARRAY_SIZE(sdh_parent_names),\n\t\t\t\t\tCLK_SET_RATE_PARENT,\n\t\t\t\t\t&sdh_mix_config, &sdh_lock);\n\n\tccic0_mix_config.reg_info.reg_clk_ctrl = pxa_unit->apmu_base + APMU_CCIC0;\n\tclk = mmp_clk_register_mix(NULL, \"ccic0_mix_clk\", ccic_parent_names,\n\t\t\t\t\tARRAY_SIZE(ccic_parent_names),\n\t\t\t\t\tCLK_SET_RATE_PARENT,\n\t\t\t\t\t&ccic0_mix_config, &ccic0_lock);\n\tmmp_clk_add(unit, MMP2_CLK_CCIC0_MIX, clk);\n\n\tccic1_mix_config.reg_info.reg_clk_ctrl = pxa_unit->apmu_base + APMU_CCIC1;\n\tclk = mmp_clk_register_mix(NULL, \"ccic1_mix_clk\", ccic_parent_names,\n\t\t\t\t\tARRAY_SIZE(ccic_parent_names),\n\t\t\t\t\tCLK_SET_RATE_PARENT,\n\t\t\t\t\t&ccic1_mix_config, &ccic1_lock);\n\tmmp_clk_add(unit, MMP2_CLK_CCIC1_MIX, clk);\n\n\tmmp_register_mux_clks(unit, apmu_mux_clks, pxa_unit->apmu_base,\n\t\t\t\tARRAY_SIZE(apmu_mux_clks));\n\n\tmmp_register_div_clks(unit, apmu_div_clks, pxa_unit->apmu_base,\n\t\t\t\tARRAY_SIZE(apmu_div_clks));\n\n\tmmp_register_gate_clks(unit, apmu_gate_clks, pxa_unit->apmu_base,\n\t\t\t\tARRAY_SIZE(apmu_gate_clks));\n\n\tif (pxa_unit->model == CLK_MODEL_MMP3) {\n\t\tmmp_register_mux_clks(unit, mmp3_apmu_mux_clks, pxa_unit->apmu_base,\n\t\t\t\t\tARRAY_SIZE(mmp3_apmu_mux_clks));\n\n\t\tmmp_register_div_clks(unit, mmp3_apmu_div_clks, pxa_unit->apmu_base,\n\t\t\t\t\tARRAY_SIZE(mmp3_apmu_div_clks));\n\n\t\tmmp_register_gate_clks(unit, mmp3_apmu_gate_clks, pxa_unit->apmu_base,\n\t\t\t\t\tARRAY_SIZE(mmp3_apmu_gate_clks));\n\t} else {\n\t\tclk_register_mux_table(NULL, \"gpu_3d_mux\", mmp2_gpu_gc_parent_names,\n\t\t\t\t\tARRAY_SIZE(mmp2_gpu_gc_parent_names),\n\t\t\t\t\tCLK_SET_RATE_PARENT,\n\t\t\t\t\tpxa_unit->apmu_base + APMU_GPU,\n\t\t\t\t\t0, 0x10c0, 0,\n\t\t\t\t\tmmp2_gpu_gc_parent_table, &gpu_lock);\n\n\t\tclk_register_mux_table(NULL, \"gpu_bus_mux\", mmp2_gpu_bus_parent_names,\n\t\t\t\t\tARRAY_SIZE(mmp2_gpu_bus_parent_names),\n\t\t\t\t\tCLK_SET_RATE_PARENT,\n\t\t\t\t\tpxa_unit->apmu_base + APMU_GPU,\n\t\t\t\t\t0, 0x4030, 0,\n\t\t\t\t\tmmp2_gpu_bus_parent_table, &gpu_lock);\n\n\t\tmmp_register_gate_clks(unit, mmp2_apmu_gate_clks, pxa_unit->apmu_base,\n\t\t\t\t\tARRAY_SIZE(mmp2_apmu_gate_clks));\n\t}\n}\n\nstatic void mmp2_clk_reset_init(struct device_node *np,\n\t\t\t\tstruct mmp2_clk_unit *pxa_unit)\n{\n\tstruct mmp_clk_reset_cell *cells;\n\tint i, nr_resets;\n\n\tnr_resets = ARRAY_SIZE(apbc_gate_clks);\n\tcells = kcalloc(nr_resets, sizeof(*cells), GFP_KERNEL);\n\tif (!cells)\n\t\treturn;\n\n\tfor (i = 0; i < nr_resets; i++) {\n\t\tcells[i].clk_id = apbc_gate_clks[i].id;\n\t\tcells[i].reg = pxa_unit->apbc_base + apbc_gate_clks[i].offset;\n\t\tcells[i].flags = 0;\n\t\tcells[i].lock = apbc_gate_clks[i].lock;\n\t\tcells[i].bits = 0x4;\n\t}\n\n\tmmp_clk_reset_register(np, cells, nr_resets);\n}\n\nstatic void mmp2_pm_domain_init(struct device_node *np,\n\t\t\t\tstruct mmp2_clk_unit *pxa_unit)\n{\n\tif (pxa_unit->model == CLK_MODEL_MMP3) {\n\t\tpxa_unit->pm_domains[MMP2_POWER_DOMAIN_GPU]\n\t\t\t= mmp_pm_domain_register(\"gpu\",\n\t\t\t\tpxa_unit->apmu_base + APMU_GPU,\n\t\t\t\t0x0600, 0x40003, 0x18000c, 0, &gpu_lock);\n\t} else {\n\t\tpxa_unit->pm_domains[MMP2_POWER_DOMAIN_GPU]\n\t\t\t= mmp_pm_domain_register(\"gpu\",\n\t\t\t\tpxa_unit->apmu_base + APMU_GPU,\n\t\t\t\t0x8600, 0x00003, 0x00000c,\n\t\t\t\tMMP_PM_DOMAIN_NO_DISABLE, &gpu_lock);\n\t}\n\tpxa_unit->pd_data.num_domains++;\n\n\tpxa_unit->pm_domains[MMP2_POWER_DOMAIN_AUDIO]\n\t\t= mmp_pm_domain_register(\"audio\",\n\t\t\tpxa_unit->apmu_base + APMU_AUDIO,\n\t\t\t0x600, 0x2, 0, 0, &audio_lock);\n\tpxa_unit->pd_data.num_domains++;\n\n\tif (pxa_unit->model == CLK_MODEL_MMP3) {\n\t\tpxa_unit->pm_domains[MMP3_POWER_DOMAIN_CAMERA]\n\t\t\t= mmp_pm_domain_register(\"camera\",\n\t\t\t\tpxa_unit->apmu_base + APMU_CAMERA,\n\t\t\t\t0x600, 0, 0, 0, NULL);\n\t\tpxa_unit->pd_data.num_domains++;\n\t}\n\n\tpxa_unit->pd_data.domains = pxa_unit->pm_domains;\n\tof_genpd_add_provider_onecell(np, &pxa_unit->pd_data);\n}\n\nstatic void __init mmp2_clk_init(struct device_node *np)\n{\n\tstruct mmp2_clk_unit *pxa_unit;\n\n\tpxa_unit = kzalloc(sizeof(*pxa_unit), GFP_KERNEL);\n\tif (!pxa_unit)\n\t\treturn;\n\n\tif (of_device_is_compatible(np, \"marvell,mmp3-clock\"))\n\t\tpxa_unit->model = CLK_MODEL_MMP3;\n\telse\n\t\tpxa_unit->model = CLK_MODEL_MMP2;\n\n\tpxa_unit->mpmu_base = of_iomap(np, 0);\n\tif (!pxa_unit->mpmu_base) {\n\t\tpr_err(\"failed to map mpmu registers\\n\");\n\t\tgoto free_memory;\n\t}\n\n\tpxa_unit->apmu_base = of_iomap(np, 1);\n\tif (!pxa_unit->apmu_base) {\n\t\tpr_err(\"failed to map apmu registers\\n\");\n\t\tgoto unmap_mpmu_region;\n\t}\n\n\tpxa_unit->apbc_base = of_iomap(np, 2);\n\tif (!pxa_unit->apbc_base) {\n\t\tpr_err(\"failed to map apbc registers\\n\");\n\t\tgoto unmap_apmu_region;\n\t}\n\n\tmmp2_pm_domain_init(np, pxa_unit);\n\n\tmmp_clk_init(np, &pxa_unit->unit, NR_CLKS);\n\n\tmmp2_main_clk_init(pxa_unit);\n\n\tmmp2_apb_periph_clk_init(pxa_unit);\n\n\tmmp2_axi_periph_clk_init(pxa_unit);\n\n\tmmp2_clk_reset_init(np, pxa_unit);\n\n\treturn;\n\nunmap_apmu_region:\n\tiounmap(pxa_unit->apmu_base);\nunmap_mpmu_region:\n\tiounmap(pxa_unit->mpmu_base);\nfree_memory:\n\tkfree(pxa_unit);\n}\n\nCLK_OF_DECLARE(mmp2_clk, \"marvell,mmp2-clock\", mmp2_clk_init);\nCLK_OF_DECLARE(mmp3_clk, \"marvell,mmp3-clock\", mmp2_clk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}