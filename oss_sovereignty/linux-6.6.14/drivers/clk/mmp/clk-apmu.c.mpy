{
  "module_name": "clk-apmu.c",
  "hash_id": "2d7c8b72a909f62b7adcf44e3655f659d51ddf6d210eb5b7268511e6881a19cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mmp/clk-apmu.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\n#define to_clk_apmu(clk) (container_of(clk, struct clk_apmu, clk))\nstruct clk_apmu {\n\tstruct clk_hw   hw;\n\tvoid __iomem    *base;\n\tu32\t\trst_mask;\n\tu32\t\tenable_mask;\n\tspinlock_t\t*lock;\n};\n\nstatic int clk_apmu_enable(struct clk_hw *hw)\n{\n\tstruct clk_apmu *apmu = to_clk_apmu(hw);\n\tunsigned long data;\n\tunsigned long flags = 0;\n\n\tif (apmu->lock)\n\t\tspin_lock_irqsave(apmu->lock, flags);\n\n\tdata = readl_relaxed(apmu->base) | apmu->enable_mask;\n\twritel_relaxed(data, apmu->base);\n\n\tif (apmu->lock)\n\t\tspin_unlock_irqrestore(apmu->lock, flags);\n\n\treturn 0;\n}\n\nstatic void clk_apmu_disable(struct clk_hw *hw)\n{\n\tstruct clk_apmu *apmu = to_clk_apmu(hw);\n\tunsigned long data;\n\tunsigned long flags = 0;\n\n\tif (apmu->lock)\n\t\tspin_lock_irqsave(apmu->lock, flags);\n\n\tdata = readl_relaxed(apmu->base) & ~apmu->enable_mask;\n\twritel_relaxed(data, apmu->base);\n\n\tif (apmu->lock)\n\t\tspin_unlock_irqrestore(apmu->lock, flags);\n}\n\nstatic const struct clk_ops clk_apmu_ops = {\n\t.enable = clk_apmu_enable,\n\t.disable = clk_apmu_disable,\n};\n\nstruct clk *mmp_clk_register_apmu(const char *name, const char *parent_name,\n\t\tvoid __iomem *base, u32 enable_mask, spinlock_t *lock)\n{\n\tstruct clk_apmu *apmu;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\tapmu = kzalloc(sizeof(*apmu), GFP_KERNEL);\n\tif (!apmu)\n\t\treturn NULL;\n\n\tinit.name = name;\n\tinit.ops = &clk_apmu_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\n\tapmu->base = base;\n\tapmu->enable_mask = enable_mask;\n\tapmu->lock = lock;\n\tapmu->hw.init = &init;\n\n\tclk = clk_register(NULL, &apmu->hw);\n\n\tif (IS_ERR(clk))\n\t\tkfree(apmu);\n\n\treturn clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}