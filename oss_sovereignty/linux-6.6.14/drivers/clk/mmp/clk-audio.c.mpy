{
  "module_name": "clk-audio.c",
  "hash_id": "7ffabce101dff21b5d5121cff631bf2f07912a30a1c118f4354d4123ccdd15a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mmp/clk-audio.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <dt-bindings/clock/marvell,mmp2-audio.h>\n\n \n#define SSPA_AUD_CTRL\t\t\t\t0x04\n#define SSPA_AUD_PLL_CTRL0\t\t\t0x08\n#define SSPA_AUD_PLL_CTRL1\t\t\t0x0c\n\n \n#define SSPA_AUD_CTRL_SYSCLK_SHIFT\t\t0\n#define SSPA_AUD_CTRL_SYSCLK_DIV_SHIFT\t\t1\n#define SSPA_AUD_CTRL_SSPA0_MUX_SHIFT\t\t7\n#define SSPA_AUD_CTRL_SSPA0_SHIFT\t\t8\n#define SSPA_AUD_CTRL_SSPA0_DIV_SHIFT\t\t9\n#define SSPA_AUD_CTRL_SSPA1_SHIFT\t\t16\n#define SSPA_AUD_CTRL_SSPA1_DIV_SHIFT\t\t17\n#define SSPA_AUD_CTRL_SSPA1_MUX_SHIFT\t\t23\n#define SSPA_AUD_CTRL_DIV_MASK\t\t\t0x7e\n\n \n#define SSPA_AUD_PLL_CTRL0_DIV_OCLK_MODULO_MASK (0x7 << 28)\n#define SSPA_AUD_PLL_CTRL0_DIV_OCLK_MODULO(x)\t((x) << 28)\n#define SSPA_AUD_PLL_CTRL0_FRACT_MASK\t\t(0xfffff << 8)\n#define SSPA_AUD_PLL_CTRL0_FRACT(x)\t\t((x) << 8)\n#define SSPA_AUD_PLL_CTRL0_ENA_DITHER\t\t(1 << 7)\n#define SSPA_AUD_PLL_CTRL0_ICP_2UA\t\t(0 << 5)\n#define SSPA_AUD_PLL_CTRL0_ICP_5UA\t\t(1 << 5)\n#define SSPA_AUD_PLL_CTRL0_ICP_7UA\t\t(2 << 5)\n#define SSPA_AUD_PLL_CTRL0_ICP_10UA\t\t(3 << 5)\n#define SSPA_AUD_PLL_CTRL0_DIV_FBCCLK_MASK\t(0x3 << 3)\n#define SSPA_AUD_PLL_CTRL0_DIV_FBCCLK(x)\t((x) << 3)\n#define SSPA_AUD_PLL_CTRL0_DIV_MCLK_MASK\t(0x1 << 2)\n#define SSPA_AUD_PLL_CTRL0_DIV_MCLK(x)\t\t((x) << 2)\n#define SSPA_AUD_PLL_CTRL0_PD_OVPROT_DIS\t(1 << 1)\n#define SSPA_AUD_PLL_CTRL0_PU\t\t\t(1 << 0)\n\n \n#define SSPA_AUD_PLL_CTRL1_SEL_FAST_CLK\t\t(1 << 24)\n#define SSPA_AUD_PLL_CTRL1_CLK_SEL_MASK\t\t(1 << 11)\n#define SSPA_AUD_PLL_CTRL1_CLK_SEL_AUDIO_PLL\t(1 << 11)\n#define SSPA_AUD_PLL_CTRL1_CLK_SEL_VCXO\t\t(0 << 11)\n#define SSPA_AUD_PLL_CTRL1_DIV_OCLK_PATTERN_MASK (0x7ff << 0)\n#define SSPA_AUD_PLL_CTRL1_DIV_OCLK_PATTERN(x)\t((x) << 0)\n\n#define CLK_AUDIO_NR_CLKS\t\t\t3\n\nstruct mmp2_audio_clk {\n\tvoid __iomem *mmio_base;\n\n\tstruct clk_hw audio_pll_hw;\n\tstruct clk_mux sspa_mux;\n\tstruct clk_mux sspa1_mux;\n\tstruct clk_divider sysclk_div;\n\tstruct clk_divider sspa0_div;\n\tstruct clk_divider sspa1_div;\n\tstruct clk_gate sysclk_gate;\n\tstruct clk_gate sspa0_gate;\n\tstruct clk_gate sspa1_gate;\n\n\tu32 aud_ctrl;\n\tu32 aud_pll_ctrl0;\n\tu32 aud_pll_ctrl1;\n\n\tspinlock_t lock;\n\n\t \n\tstruct clk_hw_onecell_data clk_data;\n};\n\nstatic const struct {\n\tunsigned long parent_rate;\n\tunsigned long freq_vco;\n\tunsigned char mclk;\n\tunsigned char fbcclk;\n\tunsigned short fract;\n} predivs[] = {\n\t{ 26000000, 135475200, 0, 0, 0x8a18 },\n\t{ 26000000, 147456000, 0, 1, 0x0da1 },\n\t{ 38400000, 135475200, 1, 2, 0x8208 },\n\t{ 38400000, 147456000, 1, 3, 0xaaaa },\n};\n\nstatic const struct {\n\tunsigned char divisor;\n\tunsigned char modulo;\n\tunsigned char pattern;\n} postdivs[] = {\n\t{   1,\t3,  0, },\n\t{   2,\t5,  0, },\n\t{   4,\t0,  0, },\n\t{   6,\t1,  1, },\n\t{   8,\t1,  0, },\n\t{   9,\t1,  2, },\n\t{  12,\t2,  1, },\n\t{  16,\t2,  0, },\n\t{  18,\t2,  2, },\n\t{  24,\t4,  1, },\n\t{  36,\t4,  2, },\n\t{  48,\t6,  1, },\n\t{  72,\t6,  2, },\n};\n\nstatic unsigned long audio_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct mmp2_audio_clk *priv = container_of(hw, struct mmp2_audio_clk, audio_pll_hw);\n\tunsigned int prediv;\n\tunsigned int postdiv;\n\tu32 aud_pll_ctrl0;\n\tu32 aud_pll_ctrl1;\n\n\taud_pll_ctrl0 = readl(priv->mmio_base + SSPA_AUD_PLL_CTRL0);\n\taud_pll_ctrl0 &= SSPA_AUD_PLL_CTRL0_DIV_OCLK_MODULO_MASK |\n\t\t\t SSPA_AUD_PLL_CTRL0_FRACT_MASK |\n\t\t\t SSPA_AUD_PLL_CTRL0_ENA_DITHER |\n\t\t\t SSPA_AUD_PLL_CTRL0_DIV_FBCCLK_MASK |\n\t\t\t SSPA_AUD_PLL_CTRL0_DIV_MCLK_MASK |\n\t\t\t SSPA_AUD_PLL_CTRL0_PU;\n\n\taud_pll_ctrl1 = readl(priv->mmio_base + SSPA_AUD_PLL_CTRL1);\n\taud_pll_ctrl1 &= SSPA_AUD_PLL_CTRL1_CLK_SEL_MASK |\n\t\t\t SSPA_AUD_PLL_CTRL1_DIV_OCLK_PATTERN_MASK;\n\n\tfor (prediv = 0; prediv < ARRAY_SIZE(predivs); prediv++) {\n\t\tif (predivs[prediv].parent_rate != parent_rate)\n\t\t\tcontinue;\n\t\tfor (postdiv = 0; postdiv < ARRAY_SIZE(postdivs); postdiv++) {\n\t\t\tunsigned long freq;\n\t\t\tu32 val;\n\n\t\t\tval = SSPA_AUD_PLL_CTRL0_ENA_DITHER;\n\t\t\tval |= SSPA_AUD_PLL_CTRL0_PU;\n\t\t\tval |= SSPA_AUD_PLL_CTRL0_DIV_OCLK_MODULO(postdivs[postdiv].modulo);\n\t\t\tval |= SSPA_AUD_PLL_CTRL0_FRACT(predivs[prediv].fract);\n\t\t\tval |= SSPA_AUD_PLL_CTRL0_DIV_FBCCLK(predivs[prediv].fbcclk);\n\t\t\tval |= SSPA_AUD_PLL_CTRL0_DIV_MCLK(predivs[prediv].mclk);\n\t\t\tif (val != aud_pll_ctrl0)\n\t\t\t\tcontinue;\n\n\t\t\tval = SSPA_AUD_PLL_CTRL1_CLK_SEL_AUDIO_PLL;\n\t\t\tval |= SSPA_AUD_PLL_CTRL1_DIV_OCLK_PATTERN(postdivs[postdiv].pattern);\n\t\t\tif (val != aud_pll_ctrl1)\n\t\t\t\tcontinue;\n\n\t\t\tfreq = predivs[prediv].freq_vco;\n\t\t\tfreq /= postdivs[postdiv].divisor;\n\t\t\treturn freq;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic long audio_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long *parent_rate)\n{\n\tunsigned int prediv;\n\tunsigned int postdiv;\n\tlong rounded = 0;\n\n\tfor (prediv = 0; prediv < ARRAY_SIZE(predivs); prediv++) {\n\t\tif (predivs[prediv].parent_rate != *parent_rate)\n\t\t\tcontinue;\n\t\tfor (postdiv = 0; postdiv < ARRAY_SIZE(postdivs); postdiv++) {\n\t\t\tlong freq = predivs[prediv].freq_vco;\n\n\t\t\tfreq /= postdivs[postdiv].divisor;\n\t\t\tif (freq == rate)\n\t\t\t\treturn rate;\n\t\t\tif (freq < rate)\n\t\t\t\tcontinue;\n\t\t\tif (rounded && freq > rounded)\n\t\t\t\tcontinue;\n\t\t\trounded = freq;\n\t\t}\n\t}\n\n\treturn rounded;\n}\n\nstatic int audio_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct mmp2_audio_clk *priv = container_of(hw, struct mmp2_audio_clk, audio_pll_hw);\n\tunsigned int prediv;\n\tunsigned int postdiv;\n\tunsigned long val;\n\n\tfor (prediv = 0; prediv < ARRAY_SIZE(predivs); prediv++) {\n\t\tif (predivs[prediv].parent_rate != parent_rate)\n\t\t\tcontinue;\n\n\t\tfor (postdiv = 0; postdiv < ARRAY_SIZE(postdivs); postdiv++) {\n\t\t\tif (rate * postdivs[postdiv].divisor != predivs[prediv].freq_vco)\n\t\t\t\tcontinue;\n\n\t\t\tval = SSPA_AUD_PLL_CTRL0_ENA_DITHER;\n\t\t\tval |= SSPA_AUD_PLL_CTRL0_PU;\n\t\t\tval |= SSPA_AUD_PLL_CTRL0_DIV_OCLK_MODULO(postdivs[postdiv].modulo);\n\t\t\tval |= SSPA_AUD_PLL_CTRL0_FRACT(predivs[prediv].fract);\n\t\t\tval |= SSPA_AUD_PLL_CTRL0_DIV_FBCCLK(predivs[prediv].fbcclk);\n\t\t\tval |= SSPA_AUD_PLL_CTRL0_DIV_MCLK(predivs[prediv].mclk);\n\t\t\twritel(val, priv->mmio_base + SSPA_AUD_PLL_CTRL0);\n\n\t\t\tval = SSPA_AUD_PLL_CTRL1_CLK_SEL_AUDIO_PLL;\n\t\t\tval |= SSPA_AUD_PLL_CTRL1_DIV_OCLK_PATTERN(postdivs[postdiv].pattern);\n\t\t\twritel(val, priv->mmio_base + SSPA_AUD_PLL_CTRL1);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ERANGE;\n}\n\nstatic const struct clk_ops audio_pll_ops = {\n\t.recalc_rate = audio_pll_recalc_rate,\n\t.round_rate = audio_pll_round_rate,\n\t.set_rate = audio_pll_set_rate,\n};\n\nstatic int register_clocks(struct mmp2_audio_clk *priv, struct device *dev)\n{\n\tconst struct clk_parent_data sspa_mux_parents[] = {\n\t\t{ .hw = &priv->audio_pll_hw },\n\t\t{ .fw_name = \"i2s0\" },\n\t};\n\tconst struct clk_parent_data sspa1_mux_parents[] = {\n\t\t{ .hw = &priv->audio_pll_hw },\n\t\t{ .fw_name = \"i2s1\" },\n\t};\n\tint ret;\n\n\tpriv->audio_pll_hw.init = CLK_HW_INIT_FW_NAME(\"audio_pll\",\n\t\t\t\t\"vctcxo\", &audio_pll_ops,\n\t\t\t\tCLK_SET_RATE_PARENT);\n\tret = devm_clk_hw_register(dev, &priv->audio_pll_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->sspa_mux.hw.init = CLK_HW_INIT_PARENTS_DATA(\"sspa_mux\",\n\t\t\t\tsspa_mux_parents, &clk_mux_ops,\n\t\t\t\tCLK_SET_RATE_PARENT);\n\tpriv->sspa_mux.reg = priv->mmio_base + SSPA_AUD_CTRL;\n\tpriv->sspa_mux.mask = 1;\n\tpriv->sspa_mux.shift = SSPA_AUD_CTRL_SSPA0_MUX_SHIFT;\n\tret = devm_clk_hw_register(dev, &priv->sspa_mux.hw);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->sysclk_div.hw.init = CLK_HW_INIT_HW(\"sys_div\",\n\t\t\t\t&priv->sspa_mux.hw, &clk_divider_ops,\n\t\t\t\tCLK_SET_RATE_PARENT);\n\tpriv->sysclk_div.reg = priv->mmio_base + SSPA_AUD_CTRL;\n\tpriv->sysclk_div.shift = SSPA_AUD_CTRL_SYSCLK_DIV_SHIFT;\n\tpriv->sysclk_div.width = 6;\n\tpriv->sysclk_div.flags = CLK_DIVIDER_ONE_BASED;\n\tpriv->sysclk_div.flags |= CLK_DIVIDER_ROUND_CLOSEST;\n\tpriv->sysclk_div.flags |= CLK_DIVIDER_ALLOW_ZERO;\n\tret = devm_clk_hw_register(dev, &priv->sysclk_div.hw);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->sysclk_gate.hw.init = CLK_HW_INIT_HW(\"sys_clk\",\n\t\t\t\t&priv->sysclk_div.hw, &clk_gate_ops,\n\t\t\t\tCLK_SET_RATE_PARENT);\n\tpriv->sysclk_gate.reg = priv->mmio_base + SSPA_AUD_CTRL;\n\tpriv->sysclk_gate.bit_idx = SSPA_AUD_CTRL_SYSCLK_SHIFT;\n\tret = devm_clk_hw_register(dev, &priv->sysclk_gate.hw);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->sspa0_div.hw.init = CLK_HW_INIT_HW(\"sspa0_div\",\n\t\t\t\t&priv->sspa_mux.hw, &clk_divider_ops, 0);\n\tpriv->sspa0_div.reg = priv->mmio_base + SSPA_AUD_CTRL;\n\tpriv->sspa0_div.shift = SSPA_AUD_CTRL_SSPA0_DIV_SHIFT;\n\tpriv->sspa0_div.width = 6;\n\tpriv->sspa0_div.flags = CLK_DIVIDER_ONE_BASED;\n\tpriv->sspa0_div.flags |= CLK_DIVIDER_ROUND_CLOSEST;\n\tpriv->sspa0_div.flags |= CLK_DIVIDER_ALLOW_ZERO;\n\tret = devm_clk_hw_register(dev, &priv->sspa0_div.hw);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->sspa0_gate.hw.init = CLK_HW_INIT_HW(\"sspa0_clk\",\n\t\t\t\t&priv->sspa0_div.hw, &clk_gate_ops,\n\t\t\t\tCLK_SET_RATE_PARENT);\n\tpriv->sspa0_gate.reg = priv->mmio_base + SSPA_AUD_CTRL;\n\tpriv->sspa0_gate.bit_idx = SSPA_AUD_CTRL_SSPA0_SHIFT;\n\tret = devm_clk_hw_register(dev, &priv->sspa0_gate.hw);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->sspa1_mux.hw.init = CLK_HW_INIT_PARENTS_DATA(\"sspa1_mux\",\n\t\t\t\tsspa1_mux_parents, &clk_mux_ops,\n\t\t\t\tCLK_SET_RATE_PARENT);\n\tpriv->sspa1_mux.reg = priv->mmio_base + SSPA_AUD_CTRL;\n\tpriv->sspa1_mux.mask = 1;\n\tpriv->sspa1_mux.shift = SSPA_AUD_CTRL_SSPA1_MUX_SHIFT;\n\tret = devm_clk_hw_register(dev, &priv->sspa1_mux.hw);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->sspa1_div.hw.init = CLK_HW_INIT_HW(\"sspa1_div\",\n\t\t\t\t&priv->sspa1_mux.hw, &clk_divider_ops, 0);\n\tpriv->sspa1_div.reg = priv->mmio_base + SSPA_AUD_CTRL;\n\tpriv->sspa1_div.shift = SSPA_AUD_CTRL_SSPA1_DIV_SHIFT;\n\tpriv->sspa1_div.width = 6;\n\tpriv->sspa1_div.flags = CLK_DIVIDER_ONE_BASED;\n\tpriv->sspa1_div.flags |= CLK_DIVIDER_ROUND_CLOSEST;\n\tpriv->sspa1_div.flags |= CLK_DIVIDER_ALLOW_ZERO;\n\tret = devm_clk_hw_register(dev, &priv->sspa1_div.hw);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->sspa1_gate.hw.init = CLK_HW_INIT_HW(\"sspa1_clk\",\n\t\t\t\t&priv->sspa1_div.hw, &clk_gate_ops,\n\t\t\t\tCLK_SET_RATE_PARENT);\n\tpriv->sspa1_gate.reg = priv->mmio_base + SSPA_AUD_CTRL;\n\tpriv->sspa1_gate.bit_idx = SSPA_AUD_CTRL_SSPA1_SHIFT;\n\tret = devm_clk_hw_register(dev, &priv->sspa1_gate.hw);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->clk_data.hws[MMP2_CLK_AUDIO_SYSCLK] = &priv->sysclk_gate.hw;\n\tpriv->clk_data.hws[MMP2_CLK_AUDIO_SSPA0] = &priv->sspa0_gate.hw;\n\tpriv->clk_data.hws[MMP2_CLK_AUDIO_SSPA1] = &priv->sspa1_gate.hw;\n\tpriv->clk_data.num = CLK_AUDIO_NR_CLKS;\n\n\treturn of_clk_add_hw_provider(dev->of_node, of_clk_hw_onecell_get,\n\t\t\t\t      &priv->clk_data);\n}\n\nstatic int mmp2_audio_clk_probe(struct platform_device *pdev)\n{\n\tstruct mmp2_audio_clk *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev,\n\t\t\t    struct_size(priv, clk_data.hws,\n\t\t\t\t\tCLK_AUDIO_NR_CLKS),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->mmio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->mmio_base))\n\t\treturn PTR_ERR(priv->mmio_base);\n\n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_clk_create(&pdev->dev);\n\tif (ret)\n\t\tgoto disable_pm_runtime;\n\n\tret = pm_clk_add(&pdev->dev, \"audio\");\n\tif (ret)\n\t\tgoto destroy_pm_clk;\n\n\tret = register_clocks(priv, &pdev->dev);\n\tif (ret)\n\t\tgoto destroy_pm_clk;\n\n\treturn 0;\n\ndestroy_pm_clk:\n\tpm_clk_destroy(&pdev->dev);\ndisable_pm_runtime:\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void mmp2_audio_clk_remove(struct platform_device *pdev)\n{\n\tpm_clk_destroy(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\n#ifdef CONFIG_PM\nstatic int mmp2_audio_clk_suspend(struct device *dev)\n{\n\tstruct mmp2_audio_clk *priv = dev_get_drvdata(dev);\n\n\tpriv->aud_ctrl = readl(priv->mmio_base + SSPA_AUD_CTRL);\n\tpriv->aud_pll_ctrl0 = readl(priv->mmio_base + SSPA_AUD_PLL_CTRL0);\n\tpriv->aud_pll_ctrl1 = readl(priv->mmio_base + SSPA_AUD_PLL_CTRL1);\n\tpm_clk_suspend(dev);\n\n\treturn 0;\n}\n\nstatic int mmp2_audio_clk_resume(struct device *dev)\n{\n\tstruct mmp2_audio_clk *priv = dev_get_drvdata(dev);\n\n\tpm_clk_resume(dev);\n\twritel(priv->aud_ctrl, priv->mmio_base + SSPA_AUD_CTRL);\n\twritel(priv->aud_pll_ctrl0, priv->mmio_base + SSPA_AUD_PLL_CTRL0);\n\twritel(priv->aud_pll_ctrl1, priv->mmio_base + SSPA_AUD_PLL_CTRL1);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops mmp2_audio_clk_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mmp2_audio_clk_suspend, mmp2_audio_clk_resume, NULL)\n};\n\nstatic const struct of_device_id mmp2_audio_clk_of_match[] = {\n\t{ .compatible = \"marvell,mmp2-audio-clock\" },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, mmp2_audio_clk_of_match);\n\nstatic struct platform_driver mmp2_audio_clk_driver = {\n\t.driver = {\n\t\t.name = \"mmp2-audio-clock\",\n\t\t.of_match_table = of_match_ptr(mmp2_audio_clk_of_match),\n\t\t.pm = &mmp2_audio_clk_pm_ops,\n\t},\n\t.probe = mmp2_audio_clk_probe,\n\t.remove_new = mmp2_audio_clk_remove,\n};\nmodule_platform_driver(mmp2_audio_clk_driver);\n\nMODULE_AUTHOR(\"Lubomir Rintel <lkundrak@v3.sk>\");\nMODULE_DESCRIPTION(\"Clock driver for MMP2 Audio subsystem\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}