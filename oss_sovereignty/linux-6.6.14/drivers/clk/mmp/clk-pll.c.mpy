{
  "module_name": "clk-pll.c",
  "hash_id": "d5ff67e185e023390dc0d198bb22e44ec1eb418262c36a946ed64defb8f8b088",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mmp/clk-pll.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n#include \"clk.h\"\n\n#define to_clk_mmp_pll(hw)\tcontainer_of(hw, struct mmp_clk_pll, hw)\n\nstruct mmp_clk_pll {\n\tstruct clk_hw hw;\n\tunsigned long default_rate;\n\tvoid __iomem *enable_reg;\n\tu32 enable;\n\tvoid __iomem *reg;\n\tu8 shift;\n\n\tunsigned long input_rate;\n\tvoid __iomem *postdiv_reg;\n\tu8 postdiv_shift;\n};\n\nstatic int mmp_clk_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct mmp_clk_pll *pll = to_clk_mmp_pll(hw);\n\tu32 val;\n\n\tval = readl_relaxed(pll->enable_reg);\n\tif ((val & pll->enable) == pll->enable)\n\t\treturn 1;\n\n\t \n\tif (pll->default_rate > 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic unsigned long mmp_clk_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct mmp_clk_pll *pll = to_clk_mmp_pll(hw);\n\tu32 fbdiv, refdiv, postdiv;\n\tu64 rate;\n\tu32 val;\n\n\tval = readl_relaxed(pll->enable_reg);\n\tif ((val & pll->enable) != pll->enable)\n\t\treturn pll->default_rate;\n\n\tif (pll->reg) {\n\t\tval = readl_relaxed(pll->reg);\n\t\tfbdiv = (val >> pll->shift) & 0x1ff;\n\t\trefdiv = (val >> (pll->shift + 9)) & 0x1f;\n\t} else {\n\t\tfbdiv = 2;\n\t\trefdiv = 1;\n\t}\n\n\tif (pll->postdiv_reg) {\n\t\t \n\t\tstatic const u8 postdivs[] = {2, 3, 4, 5, 6, 8, 10, 12, 16};\n\n\t\tval = readl_relaxed(pll->postdiv_reg);\n\t\tpostdiv = (val >> pll->postdiv_shift) & 0x7;\n\n\t\trate = pll->input_rate;\n\t\trate *= 2 * fbdiv;\n\t\tdo_div(rate, refdiv);\n\t\tdo_div(rate, postdivs[postdiv]);\n\t} else {\n\t\t \n\t\tif (refdiv == 3) {\n\t\t\trate = 19200000;\n\t\t} else if (refdiv == 4) {\n\t\t\trate = 26000000;\n\t\t} else {\n\t\t\tpr_err(\"bad refdiv: %d (0x%08x)\\n\", refdiv, val);\n\t\t\treturn 0;\n\t\t}\n\n\t\trate *= fbdiv + 2;\n\t\tdo_div(rate, refdiv + 2);\n\t}\n\n\treturn (unsigned long)rate;\n}\n\nstatic const struct clk_ops mmp_clk_pll_ops = {\n\t.is_enabled = mmp_clk_pll_is_enabled,\n\t.recalc_rate = mmp_clk_pll_recalc_rate,\n};\n\nstatic struct clk *mmp_clk_register_pll(char *name,\n\t\t\tunsigned long default_rate,\n\t\t\tvoid __iomem *enable_reg, u32 enable,\n\t\t\tvoid __iomem *reg, u8 shift,\n\t\t\tunsigned long input_rate,\n\t\t\tvoid __iomem *postdiv_reg, u8 postdiv_shift)\n{\n\tstruct mmp_clk_pll *pll;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &mmp_clk_pll_ops;\n\tinit.flags = 0;\n\tinit.parent_names = NULL;\n\tinit.num_parents = 0;\n\n\tpll->default_rate = default_rate;\n\tpll->enable_reg = enable_reg;\n\tpll->enable = enable;\n\tpll->reg = reg;\n\tpll->shift = shift;\n\n\tpll->input_rate = input_rate;\n\tpll->postdiv_reg = postdiv_reg;\n\tpll->postdiv_shift = postdiv_shift;\n\n\tpll->hw.init = &init;\n\n\tclk = clk_register(NULL, &pll->hw);\n\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n\nvoid mmp_register_pll_clks(struct mmp_clk_unit *unit,\n\t\t\tstruct mmp_param_pll_clk *clks,\n\t\t\tvoid __iomem *base, int size)\n{\n\tstruct clk *clk;\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tvoid __iomem *reg = NULL;\n\n\t\tif (clks[i].offset)\n\t\t\treg = base + clks[i].offset;\n\n\t\tclk = mmp_clk_register_pll(clks[i].name,\n\t\t\t\t\tclks[i].default_rate,\n\t\t\t\t\tbase + clks[i].enable_offset,\n\t\t\t\t\tclks[i].enable,\n\t\t\t\t\treg, clks[i].shift,\n\t\t\t\t\tclks[i].input_rate,\n\t\t\t\t\tbase + clks[i].postdiv_offset,\n\t\t\t\t\tclks[i].postdiv_shift);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (clks[i].id)\n\t\t\tunit->clk_table[clks[i].id] = clk;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}