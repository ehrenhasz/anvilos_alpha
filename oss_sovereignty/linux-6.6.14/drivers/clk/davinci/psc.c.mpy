{
  "module_name": "psc.c",
  "hash_id": "22c6548ea37a8a6595892787bd9716399d326572fd631bde246046d4025cca16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/davinci/psc.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/clk/davinci.h>\n#include <linux/clkdev.h>\n#include <linux/err.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_domain.h>\n#include <linux/regmap.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"psc.h\"\n\n \n#define EPCPR\t\t\t0x070\n#define PTCMD\t\t\t0x120\n#define PTSTAT\t\t\t0x128\n#define PDSTAT(n)\t\t(0x200 + 4 * (n))\n#define PDCTL(n)\t\t(0x300 + 4 * (n))\n#define MDSTAT(n)\t\t(0x800 + 4 * (n))\n#define MDCTL(n)\t\t(0xa00 + 4 * (n))\n\n \nenum davinci_lpsc_state {\n\tLPSC_STATE_SWRSTDISABLE\t= 0,\n\tLPSC_STATE_SYNCRST\t= 1,\n\tLPSC_STATE_DISABLE\t= 2,\n\tLPSC_STATE_ENABLE\t= 3,\n};\n\n#define MDSTAT_STATE_MASK\tGENMASK(5, 0)\n#define MDSTAT_MCKOUT\t\tBIT(12)\n#define PDSTAT_STATE_MASK\tGENMASK(4, 0)\n#define MDCTL_FORCE\t\tBIT(31)\n#define MDCTL_LRESET\t\tBIT(8)\n#define PDCTL_EPCGOOD\t\tBIT(8)\n#define PDCTL_NEXT\t\tBIT(0)\n\nstruct davinci_psc_data {\n\tstruct clk_onecell_data clk_data;\n\tstruct genpd_onecell_data pm_data;\n\tstruct reset_controller_dev rcdev;\n};\n\n \nstruct davinci_lpsc_clk {\n\tstruct device *dev;\n\tstruct clk_hw hw;\n\tstruct generic_pm_domain pm_domain;\n\tstruct clk *genpd_clk;\n\tstruct regmap *regmap;\n\tu32 md;\n\tu32 pd;\n\tu32 flags;\n};\n\n#define to_davinci_psc_data(x) container_of(x, struct davinci_psc_data, x)\n#define to_davinci_lpsc_clk(x) container_of(x, struct davinci_lpsc_clk, x)\n\n \nstatic inline const char *best_dev_name(struct device *dev)\n{\n\tconst char *compatible;\n\n\tif (!of_property_read_string(dev->of_node, \"compatible\", &compatible))\n\t\treturn compatible;\n\n\treturn dev_name(dev);\n}\n\nstatic void davinci_lpsc_config(struct davinci_lpsc_clk *lpsc,\n\t\t\t\tenum davinci_lpsc_state next_state)\n{\n\tu32 epcpr, pdstat, mdstat, ptstat;\n\n\tregmap_write_bits(lpsc->regmap, MDCTL(lpsc->md), MDSTAT_STATE_MASK,\n\t\t\t  next_state);\n\n\tif (lpsc->flags & LPSC_FORCE)\n\t\tregmap_write_bits(lpsc->regmap, MDCTL(lpsc->md), MDCTL_FORCE,\n\t\t\t\t  MDCTL_FORCE);\n\n\tregmap_read(lpsc->regmap, PDSTAT(lpsc->pd), &pdstat);\n\tif ((pdstat & PDSTAT_STATE_MASK) == 0) {\n\t\tregmap_write_bits(lpsc->regmap, PDCTL(lpsc->pd), PDCTL_NEXT,\n\t\t\t\t  PDCTL_NEXT);\n\n\t\tregmap_write(lpsc->regmap, PTCMD, BIT(lpsc->pd));\n\n\t\tregmap_read_poll_timeout(lpsc->regmap, EPCPR, epcpr,\n\t\t\t\t\t epcpr & BIT(lpsc->pd), 0, 0);\n\n\t\tregmap_write_bits(lpsc->regmap, PDCTL(lpsc->pd), PDCTL_EPCGOOD,\n\t\t\t\t  PDCTL_EPCGOOD);\n\t} else {\n\t\tregmap_write(lpsc->regmap, PTCMD, BIT(lpsc->pd));\n\t}\n\n\tregmap_read_poll_timeout(lpsc->regmap, PTSTAT, ptstat,\n\t\t\t\t !(ptstat & BIT(lpsc->pd)), 0, 0);\n\n\tregmap_read_poll_timeout(lpsc->regmap, MDSTAT(lpsc->md), mdstat,\n\t\t\t\t (mdstat & MDSTAT_STATE_MASK) == next_state,\n\t\t\t\t 0, 0);\n}\n\nstatic int davinci_lpsc_clk_enable(struct clk_hw *hw)\n{\n\tstruct davinci_lpsc_clk *lpsc = to_davinci_lpsc_clk(hw);\n\n\tdavinci_lpsc_config(lpsc, LPSC_STATE_ENABLE);\n\n\treturn 0;\n}\n\nstatic void davinci_lpsc_clk_disable(struct clk_hw *hw)\n{\n\tstruct davinci_lpsc_clk *lpsc = to_davinci_lpsc_clk(hw);\n\n\tdavinci_lpsc_config(lpsc, LPSC_STATE_DISABLE);\n}\n\nstatic int davinci_lpsc_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct davinci_lpsc_clk *lpsc = to_davinci_lpsc_clk(hw);\n\tu32 mdstat;\n\n\tregmap_read(lpsc->regmap, MDSTAT(lpsc->md), &mdstat);\n\n\treturn (mdstat & MDSTAT_MCKOUT) ? 1 : 0;\n}\n\nstatic const struct clk_ops davinci_lpsc_clk_ops = {\n\t.enable\t\t= davinci_lpsc_clk_enable,\n\t.disable\t= davinci_lpsc_clk_disable,\n\t.is_enabled\t= davinci_lpsc_clk_is_enabled,\n};\n\nstatic int davinci_psc_genpd_attach_dev(struct generic_pm_domain *pm_domain,\n\t\t\t\t\tstruct device *dev)\n{\n\tstruct davinci_lpsc_clk *lpsc = to_davinci_lpsc_clk(pm_domain);\n\tstruct clk *clk;\n\tint ret;\n\n\t \n\tclk = clk_get_sys(best_dev_name(lpsc->dev), clk_hw_get_name(&lpsc->hw));\n\tif (IS_ERR(clk))\n\t\treturn (PTR_ERR(clk));\n\n\tret = pm_clk_create(dev);\n\tif (ret < 0)\n\t\tgoto fail_clk_put;\n\n\tret = pm_clk_add_clk(dev, clk);\n\tif (ret < 0)\n\t\tgoto fail_pm_clk_destroy;\n\n\tlpsc->genpd_clk = clk;\n\n\treturn 0;\n\nfail_pm_clk_destroy:\n\tpm_clk_destroy(dev);\nfail_clk_put:\n\tclk_put(clk);\n\n\treturn ret;\n}\n\nstatic void davinci_psc_genpd_detach_dev(struct generic_pm_domain *pm_domain,\n\t\t\t\t\t struct device *dev)\n{\n\tstruct davinci_lpsc_clk *lpsc = to_davinci_lpsc_clk(pm_domain);\n\n\tpm_clk_remove_clk(dev, lpsc->genpd_clk);\n\tpm_clk_destroy(dev);\n\n\tlpsc->genpd_clk = NULL;\n}\n\n \nstatic struct davinci_lpsc_clk *\ndavinci_lpsc_clk_register(struct device *dev, const char *name,\n\t\t\t  const char *parent_name, struct regmap *regmap,\n\t\t\t  u32 md, u32 pd, u32 flags)\n{\n\tstruct clk_init_data init;\n\tstruct davinci_lpsc_clk *lpsc;\n\tint ret;\n\tbool is_on;\n\n\tlpsc = kzalloc(sizeof(*lpsc), GFP_KERNEL);\n\tif (!lpsc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &davinci_lpsc_clk_ops;\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\tinit.flags = 0;\n\n\tif (flags & LPSC_ALWAYS_ENABLED)\n\t\tinit.flags |= CLK_IS_CRITICAL;\n\n\tif (flags & LPSC_SET_RATE_PARENT)\n\t\tinit.flags |= CLK_SET_RATE_PARENT;\n\n\tlpsc->dev = dev;\n\tlpsc->regmap = regmap;\n\tlpsc->hw.init = &init;\n\tlpsc->md = md;\n\tlpsc->pd = pd;\n\tlpsc->flags = flags;\n\n\tret = clk_hw_register(dev, &lpsc->hw);\n\tif (ret < 0) {\n\t\tkfree(lpsc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tif (!dev || !dev->of_node)\n\t\treturn lpsc;\n\n\t \n\tret = clk_hw_register_clkdev(&lpsc->hw, name, best_dev_name(dev));\n\n\tlpsc->pm_domain.name = devm_kasprintf(dev, GFP_KERNEL, \"%s: %s\",\n\t\t\t\t\t      best_dev_name(dev), name);\n\tlpsc->pm_domain.attach_dev = davinci_psc_genpd_attach_dev;\n\tlpsc->pm_domain.detach_dev = davinci_psc_genpd_detach_dev;\n\tlpsc->pm_domain.flags = GENPD_FLAG_PM_CLK;\n\n\tis_on = davinci_lpsc_clk_is_enabled(&lpsc->hw);\n\tpm_genpd_init(&lpsc->pm_domain, NULL, is_on);\n\n\treturn lpsc;\n}\n\nstatic int davinci_lpsc_clk_reset(struct clk *clk, bool reset)\n{\n\tstruct clk_hw *hw = __clk_get_hw(clk);\n\tstruct davinci_lpsc_clk *lpsc = to_davinci_lpsc_clk(hw);\n\tu32 mdctl;\n\n\tif (IS_ERR_OR_NULL(lpsc))\n\t\treturn -EINVAL;\n\n\tmdctl = reset ? 0 : MDCTL_LRESET;\n\tregmap_write_bits(lpsc->regmap, MDCTL(lpsc->md), MDCTL_LRESET, mdctl);\n\n\treturn 0;\n}\n\nstatic int davinci_psc_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t\t    unsigned long id)\n{\n\tstruct davinci_psc_data *psc = to_davinci_psc_data(rcdev);\n\tstruct clk *clk = psc->clk_data.clks[id];\n\n\treturn davinci_lpsc_clk_reset(clk, true);\n}\n\nstatic int davinci_psc_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t      unsigned long id)\n{\n\tstruct davinci_psc_data *psc = to_davinci_psc_data(rcdev);\n\tstruct clk *clk = psc->clk_data.clks[id];\n\n\treturn davinci_lpsc_clk_reset(clk, false);\n}\n\nstatic const struct reset_control_ops davinci_psc_reset_ops = {\n\t.assert\t\t= davinci_psc_reset_assert,\n\t.deassert\t= davinci_psc_reset_deassert,\n};\n\nstatic int davinci_psc_reset_of_xlate(struct reset_controller_dev *rcdev,\n\t\t\t\t      const struct of_phandle_args *reset_spec)\n{\n\tstruct of_phandle_args clkspec = *reset_spec;  \n\tstruct clk *clk;\n\tstruct clk_hw *hw;\n\tstruct davinci_lpsc_clk *lpsc;\n\n\t \n\tclk = of_clk_get_from_provider(&clkspec);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\thw = __clk_get_hw(clk);\n\tlpsc = to_davinci_lpsc_clk(hw);\n\tclk_put(clk);\n\n\t \n\tif (!(lpsc->flags & LPSC_LOCAL_RESET))\n\t\treturn -EINVAL;\n\n\treturn lpsc->md;\n}\n\nstatic const struct regmap_config davinci_psc_regmap_config = {\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n};\n\nstatic struct davinci_psc_data *\n__davinci_psc_register_clocks(struct device *dev,\n\t\t\t      const struct davinci_lpsc_clk_info *info,\n\t\t\t      int num_clks,\n\t\t\t      void __iomem *base)\n{\n\tstruct davinci_psc_data *psc;\n\tstruct clk **clks;\n\tstruct generic_pm_domain **pm_domains;\n\tstruct regmap *regmap;\n\tint i, ret;\n\n\tpsc = kzalloc(sizeof(*psc), GFP_KERNEL);\n\tif (!psc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclks = kmalloc_array(num_clks, sizeof(*clks), GFP_KERNEL);\n\tif (!clks) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_psc;\n\t}\n\n\tpsc->clk_data.clks = clks;\n\tpsc->clk_data.clk_num = num_clks;\n\n\t \n\tfor (i = 0; i < num_clks; i++)\n\t\tclks[i] = ERR_PTR(-ENOENT);\n\n\tpm_domains = kcalloc(num_clks, sizeof(*pm_domains), GFP_KERNEL);\n\tif (!pm_domains) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_clks;\n\t}\n\n\tpsc->pm_data.domains = pm_domains;\n\tpsc->pm_data.num_domains = num_clks;\n\n\tregmap = regmap_init_mmio(dev, base, &davinci_psc_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tgoto err_free_pm_domains;\n\t}\n\n\tfor (; info->name; info++) {\n\t\tstruct davinci_lpsc_clk *lpsc;\n\n\t\tlpsc = davinci_lpsc_clk_register(dev, info->name, info->parent,\n\t\t\t\t\t\t regmap, info->md, info->pd,\n\t\t\t\t\t\t info->flags);\n\t\tif (IS_ERR(lpsc)) {\n\t\t\tdev_warn(dev, \"Failed to register %s (%ld)\\n\",\n\t\t\t\t info->name, PTR_ERR(lpsc));\n\t\t\tcontinue;\n\t\t}\n\n\t\tclks[info->md] = lpsc->hw.clk;\n\t\tpm_domains[info->md] = &lpsc->pm_domain;\n\t}\n\n\t \n\tif (!dev)\n\t\treturn psc;\n\n\tpsc->rcdev.ops = &davinci_psc_reset_ops;\n\tpsc->rcdev.owner = THIS_MODULE;\n\tpsc->rcdev.dev = dev;\n\tpsc->rcdev.of_node = dev->of_node;\n\tpsc->rcdev.of_reset_n_cells = 1;\n\tpsc->rcdev.of_xlate = davinci_psc_reset_of_xlate;\n\tpsc->rcdev.nr_resets = num_clks;\n\n\tret = devm_reset_controller_register(dev, &psc->rcdev);\n\tif (ret < 0)\n\t\tdev_warn(dev, \"Failed to register reset controller (%d)\\n\", ret);\n\n\treturn psc;\n\nerr_free_pm_domains:\n\tkfree(pm_domains);\nerr_free_clks:\n\tkfree(clks);\nerr_free_psc:\n\tkfree(psc);\n\n\treturn ERR_PTR(ret);\n}\n\nint davinci_psc_register_clocks(struct device *dev,\n\t\t\t\tconst struct davinci_lpsc_clk_info *info,\n\t\t\t\tu8 num_clks,\n\t\t\t\tvoid __iomem *base)\n{\n\tstruct davinci_psc_data *psc;\n\n\tpsc = __davinci_psc_register_clocks(dev, info, num_clks, base);\n\tif (IS_ERR(psc))\n\t\treturn PTR_ERR(psc);\n\n\tfor (; info->name; info++) {\n\t\tconst struct davinci_lpsc_clkdev_info *cdevs = info->cdevs;\n\t\tstruct clk *clk = psc->clk_data.clks[info->md];\n\n\t\tif (!cdevs || IS_ERR_OR_NULL(clk))\n\t\t\tcontinue;\n\n\t\tfor (; cdevs->con_id || cdevs->dev_id; cdevs++)\n\t\t\tclk_register_clkdev(clk, cdevs->con_id, cdevs->dev_id);\n\t}\n\n\treturn 0;\n}\n\nint of_davinci_psc_clk_init(struct device *dev,\n\t\t\t    const struct davinci_lpsc_clk_info *info,\n\t\t\t    u8 num_clks,\n\t\t\t    void __iomem *base)\n{\n\tstruct device_node *node = dev->of_node;\n\tstruct davinci_psc_data *psc;\n\n\tpsc = __davinci_psc_register_clocks(dev, info, num_clks, base);\n\tif (IS_ERR(psc))\n\t\treturn PTR_ERR(psc);\n\n\tof_genpd_add_provider_onecell(node, &psc->pm_data);\n\n\tof_clk_add_provider(node, of_clk_src_onecell_get, &psc->clk_data);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id davinci_psc_of_match[] = {\n#ifdef CONFIG_ARCH_DAVINCI_DA850\n\t{ .compatible = \"ti,da850-psc0\", .data = &of_da850_psc0_init_data },\n\t{ .compatible = \"ti,da850-psc1\", .data = &of_da850_psc1_init_data },\n#endif\n\t{ }\n};\n\nstatic const struct platform_device_id davinci_psc_id_table[] = {\n#ifdef CONFIG_ARCH_DAVINCI_DA830\n\t{ .name = \"da830-psc0\", .driver_data = (kernel_ulong_t)&da830_psc0_init_data },\n\t{ .name = \"da830-psc1\", .driver_data = (kernel_ulong_t)&da830_psc1_init_data },\n#endif\n#ifdef CONFIG_ARCH_DAVINCI_DA850\n\t{ .name = \"da850-psc0\", .driver_data = (kernel_ulong_t)&da850_psc0_init_data },\n\t{ .name = \"da850-psc1\", .driver_data = (kernel_ulong_t)&da850_psc1_init_data },\n#endif\n\t{ }\n};\n\nstatic int davinci_psc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *of_id;\n\tconst struct davinci_psc_init_data *init_data = NULL;\n\tvoid __iomem *base;\n\tint ret;\n\n\tof_id = of_match_device(davinci_psc_of_match, dev);\n\tif (of_id)\n\t\tinit_data = of_id->data;\n\telse if (pdev->id_entry)\n\t\tinit_data = (void *)pdev->id_entry->driver_data;\n\n\tif (!init_data) {\n\t\tdev_err(dev, \"unable to find driver init data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tret = devm_clk_bulk_get(dev, init_data->num_parent_clks,\n\t\t\t\tinit_data->parent_clks);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn init_data->psc_init(dev, base);\n}\n\nstatic struct platform_driver davinci_psc_driver = {\n\t.probe\t\t= davinci_psc_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"davinci-psc-clk\",\n\t\t.of_match_table\t= davinci_psc_of_match,\n\t},\n\t.id_table\t= davinci_psc_id_table,\n};\n\nstatic int __init davinci_psc_driver_init(void)\n{\n\treturn platform_driver_register(&davinci_psc_driver);\n}\n\n \npostcore_initcall(davinci_psc_driver_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}