{
  "module_name": "da8xx-cfgchip.c",
  "hash_id": "472d5fb0dc22991dce908865bc2d0417cff1ca075730a38b3e321daa81f88b9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/davinci/da8xx-cfgchip.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/init.h>\n#include <linux/mfd/da8xx-cfgchip.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/platform_data/clk-da8xx-cfgchip.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n \n\n#define DA8XX_GATE_CLOCK_IS_DIV4P5\tBIT(1)\n\nstruct da8xx_cfgchip_gate_clk_info {\n\tconst char *name;\n\tu32 cfgchip;\n\tu32 bit;\n\tu32 flags;\n};\n\nstruct da8xx_cfgchip_gate_clk {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tu32 reg;\n\tu32 mask;\n};\n\n#define to_da8xx_cfgchip_gate_clk(_hw) \\\n\tcontainer_of((_hw), struct da8xx_cfgchip_gate_clk, hw)\n\nstatic int da8xx_cfgchip_gate_clk_enable(struct clk_hw *hw)\n{\n\tstruct da8xx_cfgchip_gate_clk *clk = to_da8xx_cfgchip_gate_clk(hw);\n\n\treturn regmap_write_bits(clk->regmap, clk->reg, clk->mask, clk->mask);\n}\n\nstatic void da8xx_cfgchip_gate_clk_disable(struct clk_hw *hw)\n{\n\tstruct da8xx_cfgchip_gate_clk *clk = to_da8xx_cfgchip_gate_clk(hw);\n\n\tregmap_write_bits(clk->regmap, clk->reg, clk->mask, 0);\n}\n\nstatic int da8xx_cfgchip_gate_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct da8xx_cfgchip_gate_clk *clk = to_da8xx_cfgchip_gate_clk(hw);\n\tunsigned int val;\n\n\tregmap_read(clk->regmap, clk->reg, &val);\n\n\treturn !!(val & clk->mask);\n}\n\nstatic unsigned long da8xx_cfgchip_div4p5_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t      unsigned long parent_rate)\n{\n\t \n\treturn parent_rate * 2 / 9;\n}\n\nstatic const struct clk_ops da8xx_cfgchip_gate_clk_ops = {\n\t.enable\t\t= da8xx_cfgchip_gate_clk_enable,\n\t.disable\t= da8xx_cfgchip_gate_clk_disable,\n\t.is_enabled\t= da8xx_cfgchip_gate_clk_is_enabled,\n};\n\nstatic const struct clk_ops da8xx_cfgchip_div4p5_clk_ops = {\n\t.enable\t\t= da8xx_cfgchip_gate_clk_enable,\n\t.disable\t= da8xx_cfgchip_gate_clk_disable,\n\t.is_enabled\t= da8xx_cfgchip_gate_clk_is_enabled,\n\t.recalc_rate\t= da8xx_cfgchip_div4p5_recalc_rate,\n};\n\nstatic struct da8xx_cfgchip_gate_clk * __init\nda8xx_cfgchip_gate_clk_register(struct device *dev,\n\t\t\t\tconst struct da8xx_cfgchip_gate_clk_info *info,\n\t\t\t\tstruct regmap *regmap)\n{\n\tstruct clk *parent;\n\tconst char *parent_name;\n\tstruct da8xx_cfgchip_gate_clk *gate;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tparent = devm_clk_get(dev, NULL);\n\tif (IS_ERR(parent))\n\t\treturn ERR_CAST(parent);\n\n\tparent_name = __clk_get_name(parent);\n\n\tgate = devm_kzalloc(dev, sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = info->name;\n\tif (info->flags & DA8XX_GATE_CLOCK_IS_DIV4P5)\n\t\tinit.ops = &da8xx_cfgchip_div4p5_clk_ops;\n\telse\n\t\tinit.ops = &da8xx_cfgchip_gate_clk_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = 0;\n\n\tgate->hw.init = &init;\n\tgate->regmap = regmap;\n\tgate->reg = info->cfgchip;\n\tgate->mask = info->bit;\n\n\tret = devm_clk_hw_register(dev, &gate->hw);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\treturn gate;\n}\n\nstatic const struct da8xx_cfgchip_gate_clk_info da8xx_tbclksync_info __initconst = {\n\t.name = \"ehrpwm_tbclk\",\n\t.cfgchip = CFGCHIP(1),\n\t.bit = CFGCHIP1_TBCLKSYNC,\n};\n\nstatic int __init da8xx_cfgchip_register_tbclk(struct device *dev,\n\t\t\t\t\t       struct regmap *regmap)\n{\n\tstruct da8xx_cfgchip_gate_clk *gate;\n\n\tgate = da8xx_cfgchip_gate_clk_register(dev, &da8xx_tbclksync_info,\n\t\t\t\t\t       regmap);\n\tif (IS_ERR(gate))\n\t\treturn PTR_ERR(gate);\n\n\tclk_hw_register_clkdev(&gate->hw, \"tbclk\", \"ehrpwm.0\");\n\tclk_hw_register_clkdev(&gate->hw, \"tbclk\", \"ehrpwm.1\");\n\n\treturn 0;\n}\n\nstatic const struct da8xx_cfgchip_gate_clk_info da8xx_div4p5ena_info __initconst = {\n\t.name = \"div4.5\",\n\t.cfgchip = CFGCHIP(3),\n\t.bit = CFGCHIP3_DIV45PENA,\n\t.flags = DA8XX_GATE_CLOCK_IS_DIV4P5,\n};\n\nstatic int __init da8xx_cfgchip_register_div4p5(struct device *dev,\n\t\t\t\t\t\tstruct regmap *regmap)\n{\n\tstruct da8xx_cfgchip_gate_clk *gate;\n\n\tgate = da8xx_cfgchip_gate_clk_register(dev, &da8xx_div4p5ena_info, regmap);\n\n\treturn PTR_ERR_OR_ZERO(gate);\n}\n\nstatic int __init\nof_da8xx_cfgchip_gate_clk_init(struct device *dev,\n\t\t\t       const struct da8xx_cfgchip_gate_clk_info *info,\n\t\t\t       struct regmap *regmap)\n{\n\tstruct da8xx_cfgchip_gate_clk *gate;\n\n\tgate = da8xx_cfgchip_gate_clk_register(dev, info, regmap);\n\tif (IS_ERR(gate))\n\t\treturn PTR_ERR(gate);\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get, gate);\n}\n\nstatic int __init of_da8xx_tbclksync_init(struct device *dev,\n\t\t\t\t\t  struct regmap *regmap)\n{\n\treturn of_da8xx_cfgchip_gate_clk_init(dev, &da8xx_tbclksync_info, regmap);\n}\n\nstatic int __init of_da8xx_div4p5ena_init(struct device *dev,\n\t\t\t\t\t  struct regmap *regmap)\n{\n\treturn of_da8xx_cfgchip_gate_clk_init(dev, &da8xx_div4p5ena_info, regmap);\n}\n\n \n\nstruct da8xx_cfgchip_mux_clk_info {\n\tconst char *name;\n\tconst char *parent0;\n\tconst char *parent1;\n\tu32 cfgchip;\n\tu32 bit;\n};\n\nstruct da8xx_cfgchip_mux_clk {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tu32 reg;\n\tu32 mask;\n};\n\n#define to_da8xx_cfgchip_mux_clk(_hw) \\\n\tcontainer_of((_hw), struct da8xx_cfgchip_mux_clk, hw)\n\nstatic int da8xx_cfgchip_mux_clk_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct da8xx_cfgchip_mux_clk *clk = to_da8xx_cfgchip_mux_clk(hw);\n\tunsigned int val = index ? clk->mask : 0;\n\n\treturn regmap_write_bits(clk->regmap, clk->reg, clk->mask, val);\n}\n\nstatic u8 da8xx_cfgchip_mux_clk_get_parent(struct clk_hw *hw)\n{\n\tstruct da8xx_cfgchip_mux_clk *clk = to_da8xx_cfgchip_mux_clk(hw);\n\tunsigned int val;\n\n\tregmap_read(clk->regmap, clk->reg, &val);\n\n\treturn (val & clk->mask) ? 1 : 0;\n}\n\nstatic const struct clk_ops da8xx_cfgchip_mux_clk_ops = {\n\t.determine_rate\t= clk_hw_determine_rate_no_reparent,\n\t.set_parent\t= da8xx_cfgchip_mux_clk_set_parent,\n\t.get_parent\t= da8xx_cfgchip_mux_clk_get_parent,\n};\n\nstatic struct da8xx_cfgchip_mux_clk * __init\nda8xx_cfgchip_mux_clk_register(struct device *dev,\n\t\t\t       const struct da8xx_cfgchip_mux_clk_info *info,\n\t\t\t       struct regmap *regmap)\n{\n\tconst char * const parent_names[] = { info->parent0, info->parent1 };\n\tstruct da8xx_cfgchip_mux_clk *mux;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tmux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = info->name;\n\tinit.ops = &da8xx_cfgchip_mux_clk_ops;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = 2;\n\tinit.flags = 0;\n\n\tmux->hw.init = &init;\n\tmux->regmap = regmap;\n\tmux->reg = info->cfgchip;\n\tmux->mask = info->bit;\n\n\tret = devm_clk_hw_register(dev, &mux->hw);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\treturn mux;\n}\n\nstatic const struct da8xx_cfgchip_mux_clk_info da850_async1_info __initconst = {\n\t.name = \"async1\",\n\t.parent0 = \"pll0_sysclk3\",\n\t.parent1 = \"div4.5\",\n\t.cfgchip = CFGCHIP(3),\n\t.bit = CFGCHIP3_EMA_CLKSRC,\n};\n\nstatic int __init da8xx_cfgchip_register_async1(struct device *dev,\n\t\t\t\t\t\tstruct regmap *regmap)\n{\n\tstruct da8xx_cfgchip_mux_clk *mux;\n\n\tmux = da8xx_cfgchip_mux_clk_register(dev, &da850_async1_info, regmap);\n\tif (IS_ERR(mux))\n\t\treturn PTR_ERR(mux);\n\n\tclk_hw_register_clkdev(&mux->hw, \"async1\", \"da850-psc0\");\n\n\treturn 0;\n}\n\nstatic const struct da8xx_cfgchip_mux_clk_info da850_async3_info __initconst = {\n\t.name = \"async3\",\n\t.parent0 = \"pll0_sysclk2\",\n\t.parent1 = \"pll1_sysclk2\",\n\t.cfgchip = CFGCHIP(3),\n\t.bit = CFGCHIP3_ASYNC3_CLKSRC,\n};\n\nstatic int __init da850_cfgchip_register_async3(struct device *dev,\n\t\t\t\t\t\tstruct regmap *regmap)\n{\n\tstruct da8xx_cfgchip_mux_clk *mux;\n\tstruct clk_hw *parent;\n\n\tmux = da8xx_cfgchip_mux_clk_register(dev, &da850_async3_info, regmap);\n\tif (IS_ERR(mux))\n\t\treturn PTR_ERR(mux);\n\n\tclk_hw_register_clkdev(&mux->hw, \"async3\", \"da850-psc1\");\n\n\t \n\tparent = clk_hw_get_parent_by_index(&mux->hw, 1);\n\tif (parent)\n\t\tclk_set_parent(mux->hw.clk, parent->clk);\n\telse\n\t\tdev_warn(dev, \"Failed to find async3 parent clock\\n\");\n\n\treturn 0;\n}\n\nstatic int __init\nof_da8xx_cfgchip_init_mux_clock(struct device *dev,\n\t\t\t\tconst struct da8xx_cfgchip_mux_clk_info *info,\n\t\t\t\tstruct regmap *regmap)\n{\n\tstruct da8xx_cfgchip_mux_clk *mux;\n\n\tmux = da8xx_cfgchip_mux_clk_register(dev, info, regmap);\n\tif (IS_ERR(mux))\n\t\treturn PTR_ERR(mux);\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get, &mux->hw);\n}\n\nstatic int __init of_da850_async1_init(struct device *dev, struct regmap *regmap)\n{\n\treturn of_da8xx_cfgchip_init_mux_clock(dev, &da850_async1_info, regmap);\n}\n\nstatic int __init of_da850_async3_init(struct device *dev, struct regmap *regmap)\n{\n\treturn of_da8xx_cfgchip_init_mux_clock(dev, &da850_async3_info, regmap);\n}\n\n \n\nstruct da8xx_usb0_clk48 {\n\tstruct clk_hw hw;\n\tstruct clk *fck;\n\tstruct regmap *regmap;\n};\n\n#define to_da8xx_usb0_clk48(_hw) \\\n\tcontainer_of((_hw), struct da8xx_usb0_clk48, hw)\n\nstatic int da8xx_usb0_clk48_prepare(struct clk_hw *hw)\n{\n\tstruct da8xx_usb0_clk48 *usb0 = to_da8xx_usb0_clk48(hw);\n\n\t \n\treturn clk_prepare(usb0->fck);\n}\n\nstatic void da8xx_usb0_clk48_unprepare(struct clk_hw *hw)\n{\n\tstruct da8xx_usb0_clk48 *usb0 = to_da8xx_usb0_clk48(hw);\n\n\tclk_unprepare(usb0->fck);\n}\n\nstatic int da8xx_usb0_clk48_enable(struct clk_hw *hw)\n{\n\tstruct da8xx_usb0_clk48 *usb0 = to_da8xx_usb0_clk48(hw);\n\tunsigned int mask, val;\n\tint ret;\n\n\t \n\tclk_enable(usb0->fck);\n\n\t \n\tmask = CFGCHIP2_RESET | CFGCHIP2_PHYPWRDN | CFGCHIP2_PHY_PLLON;\n\tval = CFGCHIP2_PHY_PLLON;\n\n\tregmap_write_bits(usb0->regmap, CFGCHIP(2), mask, val);\n\tret = regmap_read_poll_timeout(usb0->regmap, CFGCHIP(2), val,\n\t\t\t\t       val & CFGCHIP2_PHYCLKGD, 0, 500000);\n\n\tclk_disable(usb0->fck);\n\n\treturn ret;\n}\n\nstatic void da8xx_usb0_clk48_disable(struct clk_hw *hw)\n{\n\tstruct da8xx_usb0_clk48 *usb0 = to_da8xx_usb0_clk48(hw);\n\tunsigned int val;\n\n\tval = CFGCHIP2_PHYPWRDN;\n\tregmap_write_bits(usb0->regmap, CFGCHIP(2), val, val);\n}\n\nstatic int da8xx_usb0_clk48_is_enabled(struct clk_hw *hw)\n{\n\tstruct da8xx_usb0_clk48 *usb0 = to_da8xx_usb0_clk48(hw);\n\tunsigned int val;\n\n\tregmap_read(usb0->regmap, CFGCHIP(2), &val);\n\n\treturn !!(val & CFGCHIP2_PHYCLKGD);\n}\n\nstatic unsigned long da8xx_usb0_clk48_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct da8xx_usb0_clk48 *usb0 = to_da8xx_usb0_clk48(hw);\n\tunsigned int mask, val;\n\n\t \n\tmask = CFGCHIP2_REFFREQ_MASK;\n\tswitch (parent_rate) {\n\tcase 12000000:\n\t\tval = CFGCHIP2_REFFREQ_12MHZ;\n\t\tbreak;\n\tcase 13000000:\n\t\tval = CFGCHIP2_REFFREQ_13MHZ;\n\t\tbreak;\n\tcase 19200000:\n\t\tval = CFGCHIP2_REFFREQ_19_2MHZ;\n\t\tbreak;\n\tcase 20000000:\n\t\tval = CFGCHIP2_REFFREQ_20MHZ;\n\t\tbreak;\n\tcase 24000000:\n\t\tval = CFGCHIP2_REFFREQ_24MHZ;\n\t\tbreak;\n\tcase 26000000:\n\t\tval = CFGCHIP2_REFFREQ_26MHZ;\n\t\tbreak;\n\tcase 38400000:\n\t\tval = CFGCHIP2_REFFREQ_38_4MHZ;\n\t\tbreak;\n\tcase 40000000:\n\t\tval = CFGCHIP2_REFFREQ_40MHZ;\n\t\tbreak;\n\tcase 48000000:\n\t\tval = CFGCHIP2_REFFREQ_48MHZ;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tregmap_write_bits(usb0->regmap, CFGCHIP(2), mask, val);\n\n\t \n\treturn 48000000;\n}\n\nstatic int da8xx_usb0_clk48_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t   struct clk_rate_request *req)\n{\n\treq->rate = 48000000;\n\n\treturn 0;\n}\n\nstatic int da8xx_usb0_clk48_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct da8xx_usb0_clk48 *usb0 = to_da8xx_usb0_clk48(hw);\n\n\treturn regmap_write_bits(usb0->regmap, CFGCHIP(2),\n\t\t\t\t CFGCHIP2_USB2PHYCLKMUX,\n\t\t\t\t index ? CFGCHIP2_USB2PHYCLKMUX : 0);\n}\n\nstatic u8 da8xx_usb0_clk48_get_parent(struct clk_hw *hw)\n{\n\tstruct da8xx_usb0_clk48 *usb0 = to_da8xx_usb0_clk48(hw);\n\tunsigned int val;\n\n\tregmap_read(usb0->regmap, CFGCHIP(2), &val);\n\n\treturn (val & CFGCHIP2_USB2PHYCLKMUX) ? 1 : 0;\n}\n\nstatic const struct clk_ops da8xx_usb0_clk48_ops = {\n\t.prepare\t= da8xx_usb0_clk48_prepare,\n\t.unprepare\t= da8xx_usb0_clk48_unprepare,\n\t.enable\t\t= da8xx_usb0_clk48_enable,\n\t.disable\t= da8xx_usb0_clk48_disable,\n\t.is_enabled\t= da8xx_usb0_clk48_is_enabled,\n\t.recalc_rate\t= da8xx_usb0_clk48_recalc_rate,\n\t.determine_rate\t= da8xx_usb0_clk48_determine_rate,\n\t.set_parent\t= da8xx_usb0_clk48_set_parent,\n\t.get_parent\t= da8xx_usb0_clk48_get_parent,\n};\n\nstatic struct da8xx_usb0_clk48 *\nda8xx_cfgchip_register_usb0_clk48(struct device *dev,\n\t\t\t\t  struct regmap *regmap)\n{\n\tconst char * const parent_names[] = { \"usb_refclkin\", \"pll0_auxclk\" };\n\tstruct clk *fck_clk;\n\tstruct da8xx_usb0_clk48 *usb0;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tfck_clk = devm_clk_get(dev, \"fck\");\n\tif (IS_ERR(fck_clk)) {\n\t\tdev_err_probe(dev, PTR_ERR(fck_clk), \"Missing fck clock\\n\");\n\t\treturn ERR_CAST(fck_clk);\n\t}\n\n\tusb0 = devm_kzalloc(dev, sizeof(*usb0), GFP_KERNEL);\n\tif (!usb0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = \"usb0_clk48\";\n\tinit.ops = &da8xx_usb0_clk48_ops;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = 2;\n\n\tusb0->hw.init = &init;\n\tusb0->fck = fck_clk;\n\tusb0->regmap = regmap;\n\n\tret = devm_clk_hw_register(dev, &usb0->hw);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\treturn usb0;\n}\n\n \n\nstruct da8xx_usb1_clk48 {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n};\n\n#define to_da8xx_usb1_clk48(_hw) \\\n\tcontainer_of((_hw), struct da8xx_usb1_clk48, hw)\n\nstatic int da8xx_usb1_clk48_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct da8xx_usb1_clk48 *usb1 = to_da8xx_usb1_clk48(hw);\n\n\treturn regmap_write_bits(usb1->regmap, CFGCHIP(2),\n\t\t\t\t CFGCHIP2_USB1PHYCLKMUX,\n\t\t\t\t index ? CFGCHIP2_USB1PHYCLKMUX : 0);\n}\n\nstatic u8 da8xx_usb1_clk48_get_parent(struct clk_hw *hw)\n{\n\tstruct da8xx_usb1_clk48 *usb1 = to_da8xx_usb1_clk48(hw);\n\tunsigned int val;\n\n\tregmap_read(usb1->regmap, CFGCHIP(2), &val);\n\n\treturn (val & CFGCHIP2_USB1PHYCLKMUX) ? 1 : 0;\n}\n\nstatic const struct clk_ops da8xx_usb1_clk48_ops = {\n\t.determine_rate\t= clk_hw_determine_rate_no_reparent,\n\t.set_parent\t= da8xx_usb1_clk48_set_parent,\n\t.get_parent\t= da8xx_usb1_clk48_get_parent,\n};\n\n \nstatic struct da8xx_usb1_clk48 *\nda8xx_cfgchip_register_usb1_clk48(struct device *dev,\n\t\t\t\t  struct regmap *regmap)\n{\n\tconst char * const parent_names[] = { \"usb0_clk48\", \"usb_refclkin\" };\n\tstruct da8xx_usb1_clk48 *usb1;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tusb1 = devm_kzalloc(dev, sizeof(*usb1), GFP_KERNEL);\n\tif (!usb1)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = \"usb1_clk48\";\n\tinit.ops = &da8xx_usb1_clk48_ops;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = 2;\n\n\tusb1->hw.init = &init;\n\tusb1->regmap = regmap;\n\n\tret = devm_clk_hw_register(dev, &usb1->hw);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\treturn usb1;\n}\n\nstatic int da8xx_cfgchip_register_usb_phy_clk(struct device *dev,\n\t\t\t\t\t      struct regmap *regmap)\n{\n\tstruct da8xx_usb0_clk48 *usb0;\n\tstruct da8xx_usb1_clk48 *usb1;\n\tstruct clk_hw *parent;\n\n\tusb0 = da8xx_cfgchip_register_usb0_clk48(dev, regmap);\n\tif (IS_ERR(usb0))\n\t\treturn PTR_ERR(usb0);\n\n\t \n\tparent = clk_hw_get_parent_by_index(&usb0->hw, 1);\n\tif (parent)\n\t\tclk_set_parent(usb0->hw.clk, parent->clk);\n\telse\n\t\tdev_warn(dev, \"Failed to find usb0 parent clock\\n\");\n\n\tusb1 = da8xx_cfgchip_register_usb1_clk48(dev, regmap);\n\tif (IS_ERR(usb1))\n\t\treturn PTR_ERR(usb1);\n\n\t \n\tparent = clk_hw_get_parent_by_index(&usb1->hw, 0);\n\tif (parent)\n\t\tclk_set_parent(usb1->hw.clk, parent->clk);\n\telse\n\t\tdev_warn(dev, \"Failed to find usb1 parent clock\\n\");\n\n\tclk_hw_register_clkdev(&usb0->hw, \"usb0_clk48\", \"da8xx-usb-phy\");\n\tclk_hw_register_clkdev(&usb1->hw, \"usb1_clk48\", \"da8xx-usb-phy\");\n\n\treturn 0;\n}\n\nstatic int of_da8xx_usb_phy_clk_init(struct device *dev, struct regmap *regmap)\n{\n\tstruct clk_hw_onecell_data *clk_data;\n\tstruct da8xx_usb0_clk48 *usb0;\n\tstruct da8xx_usb1_clk48 *usb1;\n\n\tclk_data = devm_kzalloc(dev, struct_size(clk_data, hws, 2),\n\t\t\t\tGFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tclk_data->num = 2;\n\n\tusb0 = da8xx_cfgchip_register_usb0_clk48(dev, regmap);\n\tif (IS_ERR(usb0)) {\n\t\tif (PTR_ERR(usb0) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tdev_warn(dev, \"Failed to register usb0_clk48 (%ld)\\n\",\n\t\t\t PTR_ERR(usb0));\n\n\t\tclk_data->hws[0] = ERR_PTR(-ENOENT);\n\t} else {\n\t\tclk_data->hws[0] = &usb0->hw;\n\t}\n\n\tusb1 = da8xx_cfgchip_register_usb1_clk48(dev, regmap);\n\tif (IS_ERR(usb1)) {\n\t\tif (PTR_ERR(usb1) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tdev_warn(dev, \"Failed to register usb1_clk48 (%ld)\\n\",\n\t\t\t PTR_ERR(usb1));\n\n\t\tclk_data->hws[1] = ERR_PTR(-ENOENT);\n\t} else {\n\t\tclk_data->hws[1] = &usb1->hw;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);\n}\n\n \n\nstatic const struct of_device_id da8xx_cfgchip_of_match[] = {\n\t{\n\t\t.compatible = \"ti,da830-tbclksync\",\n\t\t.data = of_da8xx_tbclksync_init,\n\t},\n\t{\n\t\t.compatible = \"ti,da830-div4p5ena\",\n\t\t.data = of_da8xx_div4p5ena_init,\n\t},\n\t{\n\t\t.compatible = \"ti,da850-async1-clksrc\",\n\t\t.data = of_da850_async1_init,\n\t},\n\t{\n\t\t.compatible = \"ti,da850-async3-clksrc\",\n\t\t.data = of_da850_async3_init,\n\t},\n\t{\n\t\t.compatible = \"ti,da830-usb-phy-clocks\",\n\t\t.data = of_da8xx_usb_phy_clk_init,\n\t},\n\t{ }\n};\n\nstatic const struct platform_device_id da8xx_cfgchip_id_table[] = {\n\t{\n\t\t.name = \"da830-tbclksync\",\n\t\t.driver_data = (kernel_ulong_t)da8xx_cfgchip_register_tbclk,\n\t},\n\t{\n\t\t.name = \"da830-div4p5ena\",\n\t\t.driver_data = (kernel_ulong_t)da8xx_cfgchip_register_div4p5,\n\t},\n\t{\n\t\t.name = \"da850-async1-clksrc\",\n\t\t.driver_data = (kernel_ulong_t)da8xx_cfgchip_register_async1,\n\t},\n\t{\n\t\t.name = \"da850-async3-clksrc\",\n\t\t.driver_data = (kernel_ulong_t)da850_cfgchip_register_async3,\n\t},\n\t{\n\t\t.name = \"da830-usb-phy-clks\",\n\t\t.driver_data = (kernel_ulong_t)da8xx_cfgchip_register_usb_phy_clk,\n\t},\n\t{ }\n};\n\ntypedef int (*da8xx_cfgchip_init)(struct device *dev, struct regmap *regmap);\n\nstatic int da8xx_cfgchip_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct da8xx_cfgchip_clk_platform_data *pdata = dev->platform_data;\n\tconst struct of_device_id *of_id;\n\tda8xx_cfgchip_init clk_init = NULL;\n\tstruct regmap *regmap = NULL;\n\n\tof_id = of_match_device(da8xx_cfgchip_of_match, dev);\n\tif (of_id) {\n\t\tstruct device_node *parent;\n\n\t\tclk_init = of_id->data;\n\t\tparent = of_get_parent(dev->of_node);\n\t\tregmap = syscon_node_to_regmap(parent);\n\t\tof_node_put(parent);\n\t} else if (pdev->id_entry && pdata) {\n\t\tclk_init = (void *)pdev->id_entry->driver_data;\n\t\tregmap = pdata->cfgchip;\n\t}\n\n\tif (!clk_init) {\n\t\tdev_err(dev, \"unable to find driver data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR_OR_NULL(regmap)) {\n\t\tdev_err(dev, \"no regmap for CFGCHIP syscon\\n\");\n\t\treturn regmap ? PTR_ERR(regmap) : -ENOENT;\n\t}\n\n\treturn clk_init(dev, regmap);\n}\n\nstatic struct platform_driver da8xx_cfgchip_driver = {\n\t.probe\t\t= da8xx_cfgchip_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"da8xx-cfgchip-clk\",\n\t\t.of_match_table\t= da8xx_cfgchip_of_match,\n\t},\n\t.id_table\t= da8xx_cfgchip_id_table,\n};\n\nstatic int __init da8xx_cfgchip_driver_init(void)\n{\n\treturn platform_driver_register(&da8xx_cfgchip_driver);\n}\n\n \npostcore_initcall(da8xx_cfgchip_driver_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}