{
  "module_name": "pll.c",
  "hash_id": "8dcb585ea4dc8d1f07a1de8ca13306ea99b72ada91a66ed843229316760f7a8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/davinci/pll.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/clk/davinci.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/notifier.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/platform_data/clk-davinci-pll.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"pll.h\"\n\n#define MAX_NAME_SIZE\t20\n#define OSCIN_CLK_NAME\t\"oscin\"\n\n#define REVID\t\t0x000\n#define PLLCTL\t\t0x100\n#define OCSEL\t\t0x104\n#define PLLSECCTL\t0x108\n#define PLLM\t\t0x110\n#define PREDIV\t\t0x114\n#define PLLDIV1\t\t0x118\n#define PLLDIV2\t\t0x11c\n#define PLLDIV3\t\t0x120\n#define OSCDIV\t\t0x124\n#define POSTDIV\t\t0x128\n#define BPDIV\t\t0x12c\n#define PLLCMD\t\t0x138\n#define PLLSTAT\t\t0x13c\n#define ALNCTL\t\t0x140\n#define DCHANGE\t\t0x144\n#define CKEN\t\t0x148\n#define CKSTAT\t\t0x14c\n#define SYSTAT\t\t0x150\n#define PLLDIV4\t\t0x160\n#define PLLDIV5\t\t0x164\n#define PLLDIV6\t\t0x168\n#define PLLDIV7\t\t0x16c\n#define PLLDIV8\t\t0x170\n#define PLLDIV9\t\t0x174\n\n#define PLLCTL_PLLEN\t\tBIT(0)\n#define PLLCTL_PLLPWRDN\t\tBIT(1)\n#define PLLCTL_PLLRST\t\tBIT(3)\n#define PLLCTL_PLLDIS\t\tBIT(4)\n#define PLLCTL_PLLENSRC\t\tBIT(5)\n#define PLLCTL_CLKMODE\t\tBIT(8)\n\n \n#define DIV_RATIO_SHIFT\t\t0\n#define DIV_RATIO_WIDTH\t\t5\n#define DIV_ENABLE_SHIFT\t15\n\n#define PLLCMD_GOSET\t\tBIT(0)\n#define PLLSTAT_GOSTAT\t\tBIT(0)\n\n#define CKEN_OBSCLK_SHIFT\t1\n#define CKEN_AUXEN_SHIFT\t0\n\n \n#define PLL_BYPASS_TIME\t\t1\n\n \n#define PLL_RESET_TIME\t\t1\n\n \n#define PLL_LOCK_TIME\t\t20\n\n \nstruct davinci_pll_clk {\n\tstruct clk_hw hw;\n\tvoid __iomem *base;\n\tu32 pllm_min;\n\tu32 pllm_max;\n\tu32 pllm_mask;\n};\n\n#define to_davinci_pll_clk(_hw) \\\n\tcontainer_of((_hw), struct davinci_pll_clk, hw)\n\nstatic unsigned long davinci_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct davinci_pll_clk *pll = to_davinci_pll_clk(hw);\n\tunsigned long rate = parent_rate;\n\tu32 mult;\n\n\tmult = readl(pll->base + PLLM) & pll->pllm_mask;\n\trate *= mult + 1;\n\n\treturn rate;\n}\n\nstatic int davinci_pll_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tstruct davinci_pll_clk *pll = to_davinci_pll_clk(hw);\n\tstruct clk_hw *parent = req->best_parent_hw;\n\tunsigned long parent_rate = req->best_parent_rate;\n\tunsigned long rate = req->rate;\n\tunsigned long best_rate, r;\n\tu32 mult;\n\n\t \n\tif (rate < req->min_rate)\n\t\treturn -EINVAL;\n\n\trate = min(rate, req->max_rate);\n\tmult = rate / parent_rate;\n\tbest_rate = parent_rate * mult;\n\n\t \n\tif (!(clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)) {\n\t\tif (best_rate < req->min_rate)\n\t\t\treturn -EINVAL;\n\n\t\tif (mult < pll->pllm_min || mult > pll->pllm_max)\n\t\t\treturn -EINVAL;\n\n\t\treq->rate = best_rate;\n\n\t\treturn 0;\n\t}\n\n\t \n\tbest_rate = 0;\n\n\tfor (mult = pll->pllm_min; mult <= pll->pllm_max; mult++) {\n\t\tparent_rate = clk_hw_round_rate(parent, rate / mult);\n\t\tr = parent_rate * mult;\n\t\tif (r < req->min_rate)\n\t\t\tcontinue;\n\t\tif (r > rate || r > req->max_rate)\n\t\t\tbreak;\n\t\tif (r > best_rate) {\n\t\t\tbest_rate = r;\n\t\t\treq->rate = best_rate;\n\t\t\treq->best_parent_rate = parent_rate;\n\t\t\tif (best_rate == rate)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int davinci_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct davinci_pll_clk *pll = to_davinci_pll_clk(hw);\n\tu32 mult;\n\n\tmult = rate / parent_rate;\n\twritel(mult - 1, pll->base + PLLM);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void davinci_pll_debug_init(struct clk_hw *hw, struct dentry *dentry);\n#else\n#define davinci_pll_debug_init NULL\n#endif\n\nstatic const struct clk_ops davinci_pll_ops = {\n\t.recalc_rate\t= davinci_pll_recalc_rate,\n\t.determine_rate\t= davinci_pll_determine_rate,\n\t.set_rate\t= davinci_pll_set_rate,\n\t.debug_init\t= davinci_pll_debug_init,\n};\n\n \nstatic unsigned long dm365_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct davinci_pll_clk *pll = to_davinci_pll_clk(hw);\n\tunsigned long rate = parent_rate;\n\tu32 mult;\n\n\tmult = readl(pll->base + PLLM) & pll->pllm_mask;\n\trate *= mult * 2;\n\n\treturn rate;\n}\n\nstatic const struct clk_ops dm365_pll_ops = {\n\t.recalc_rate\t= dm365_pll_recalc_rate,\n\t.debug_init\t= davinci_pll_debug_init,\n};\n\n \nstatic struct clk *davinci_pll_div_register(struct device *dev,\n\t\t\t\t\t    const char *name,\n\t\t\t\t\t    const char *parent_name,\n\t\t\t\t\t    void __iomem *reg,\n\t\t\t\t\t    bool fixed, u32 flags)\n{\n\tconst char * const *parent_names = parent_name ? &parent_name : NULL;\n\tint num_parents = parent_name ? 1 : 0;\n\tconst struct clk_ops *divider_ops = &clk_divider_ops;\n\tstruct clk_gate *gate;\n\tstruct clk_divider *divider;\n\tstruct clk *clk;\n\tint ret;\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgate->reg = reg;\n\tgate->bit_idx = DIV_ENABLE_SHIFT;\n\n\tdivider = kzalloc(sizeof(*divider), GFP_KERNEL);\n\tif (!divider) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_gate;\n\t}\n\n\tdivider->reg = reg;\n\tdivider->shift = DIV_RATIO_SHIFT;\n\tdivider->width = DIV_RATIO_WIDTH;\n\n\tif (fixed) {\n\t\tdivider->flags |= CLK_DIVIDER_READ_ONLY;\n\t\tdivider_ops = &clk_divider_ro_ops;\n\t}\n\n\tclk = clk_register_composite(dev, name, parent_names, num_parents,\n\t\t\t\t     NULL, NULL, &divider->hw, divider_ops,\n\t\t\t\t     &gate->hw, &clk_gate_ops, flags);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tgoto err_free_divider;\n\t}\n\n\treturn clk;\n\nerr_free_divider:\n\tkfree(divider);\nerr_free_gate:\n\tkfree(gate);\n\n\treturn ERR_PTR(ret);\n}\n\nstruct davinci_pllen_clk {\n\tstruct clk_hw hw;\n\tvoid __iomem *base;\n};\n\n#define to_davinci_pllen_clk(_hw) \\\n\tcontainer_of((_hw), struct davinci_pllen_clk, hw)\n\nstatic const struct clk_ops davinci_pllen_ops = {\n\t \n};\n\n \nstatic int davinci_pllen_rate_change(struct notifier_block *nb,\n\t\t\t\t     unsigned long flags, void *data)\n{\n\tstruct clk_notifier_data *cnd = data;\n\tstruct clk_hw *hw = __clk_get_hw(cnd->clk);\n\tstruct davinci_pllen_clk *pll = to_davinci_pllen_clk(hw);\n\tu32 ctrl;\n\n\tctrl = readl(pll->base + PLLCTL);\n\n\tif (flags == PRE_RATE_CHANGE) {\n\t\t \n\t\tctrl &= ~(PLLCTL_PLLENSRC | PLLCTL_PLLEN);\n\t\twritel(ctrl, pll->base + PLLCTL);\n\n\t\tudelay(PLL_BYPASS_TIME);\n\n\t\t \n\t\tctrl &= ~(PLLCTL_PLLRST | PLLCTL_PLLDIS);\n\t\twritel(ctrl, pll->base + PLLCTL);\n\t} else {\n\t\tudelay(PLL_RESET_TIME);\n\n\t\t \n\t\tctrl |= PLLCTL_PLLRST;\n\t\twritel(ctrl, pll->base + PLLCTL);\n\n\t\tudelay(PLL_LOCK_TIME);\n\n\t\t \n\t\tctrl |= PLLCTL_PLLEN;\n\t\twritel(ctrl, pll->base + PLLCTL);\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block davinci_pllen_notifier = {\n\t.notifier_call = davinci_pllen_rate_change,\n};\n\n \nstruct clk *davinci_pll_clk_register(struct device *dev,\n\t\t\t\t     const struct davinci_pll_clk_info *info,\n\t\t\t\t     const char *parent_name,\n\t\t\t\t     void __iomem *base,\n\t\t\t\t     struct regmap *cfgchip)\n{\n\tchar prediv_name[MAX_NAME_SIZE];\n\tchar pllout_name[MAX_NAME_SIZE];\n\tchar postdiv_name[MAX_NAME_SIZE];\n\tchar pllen_name[MAX_NAME_SIZE];\n\tstruct clk_init_data init;\n\tstruct davinci_pll_clk *pllout;\n\tstruct davinci_pllen_clk *pllen;\n\tstruct clk *oscin_clk = NULL;\n\tstruct clk *prediv_clk = NULL;\n\tstruct clk *pllout_clk;\n\tstruct clk *postdiv_clk = NULL;\n\tstruct clk *pllen_clk;\n\tint ret;\n\n\tif (info->flags & PLL_HAS_CLKMODE) {\n\t\t \n\t\toscin_clk = clk_register_fixed_factor(dev, OSCIN_CLK_NAME,\n\t\t\t\t\t\t      parent_name, 0, 1, 1);\n\t\tif (IS_ERR(oscin_clk))\n\t\t\treturn oscin_clk;\n\n\t\tparent_name = OSCIN_CLK_NAME;\n\t}\n\n\tif (info->flags & PLL_HAS_PREDIV) {\n\t\tbool fixed = info->flags & PLL_PREDIV_FIXED_DIV;\n\t\tu32 flags = 0;\n\n\t\tsnprintf(prediv_name, MAX_NAME_SIZE, \"%s_prediv\", info->name);\n\n\t\tif (info->flags & PLL_PREDIV_ALWAYS_ENABLED)\n\t\t\tflags |= CLK_IS_CRITICAL;\n\n\t\t \n\t\tif (info->flags & PLL_PREDIV_FIXED8)\n\t\t\tprediv_clk = clk_register_fixed_factor(dev, prediv_name,\n\t\t\t\t\t\t\tparent_name, flags, 1, 8);\n\t\telse\n\t\t\tprediv_clk = davinci_pll_div_register(dev, prediv_name,\n\t\t\t\tparent_name, base + PREDIV, fixed, flags);\n\t\tif (IS_ERR(prediv_clk)) {\n\t\t\tret = PTR_ERR(prediv_clk);\n\t\t\tgoto err_unregister_oscin;\n\t\t}\n\n\t\tparent_name = prediv_name;\n\t}\n\n\t \n\tif (info->unlock_reg) {\n\t\tif (IS_ERR_OR_NULL(cfgchip))\n\t\t\tdev_warn(dev, \"Failed to get CFGCHIP (%ld)\\n\",\n\t\t\t\t PTR_ERR(cfgchip));\n\t\telse\n\t\t\tregmap_write_bits(cfgchip, info->unlock_reg,\n\t\t\t\t\t  info->unlock_mask, 0);\n\t}\n\n\tpllout = kzalloc(sizeof(*pllout), GFP_KERNEL);\n\tif (!pllout) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unregister_prediv;\n\t}\n\n\tsnprintf(pllout_name, MAX_NAME_SIZE, \"%s_pllout\", info->name);\n\n\tinit.name = pllout_name;\n\tif (info->flags & PLL_PLLM_2X)\n\t\tinit.ops = &dm365_pll_ops;\n\telse\n\t\tinit.ops = &davinci_pll_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = 0;\n\n\tif (info->flags & PLL_HAS_PREDIV)\n\t\tinit.flags |= CLK_SET_RATE_PARENT;\n\n\tpllout->hw.init = &init;\n\tpllout->base = base;\n\tpllout->pllm_mask = info->pllm_mask;\n\tpllout->pllm_min = info->pllm_min;\n\tpllout->pllm_max = info->pllm_max;\n\n\tpllout_clk = clk_register(dev, &pllout->hw);\n\tif (IS_ERR(pllout_clk)) {\n\t\tret = PTR_ERR(pllout_clk);\n\t\tgoto err_free_pllout;\n\t}\n\n\tclk_hw_set_rate_range(&pllout->hw, info->pllout_min_rate,\n\t\t\t      info->pllout_max_rate);\n\n\tparent_name = pllout_name;\n\n\tif (info->flags & PLL_HAS_POSTDIV) {\n\t\tbool fixed = info->flags & PLL_POSTDIV_FIXED_DIV;\n\t\tu32 flags = CLK_SET_RATE_PARENT;\n\n\t\tsnprintf(postdiv_name, MAX_NAME_SIZE, \"%s_postdiv\", info->name);\n\n\t\tif (info->flags & PLL_POSTDIV_ALWAYS_ENABLED)\n\t\t\tflags |= CLK_IS_CRITICAL;\n\n\t\tpostdiv_clk = davinci_pll_div_register(dev, postdiv_name,\n\t\t\t\tparent_name, base + POSTDIV, fixed, flags);\n\t\tif (IS_ERR(postdiv_clk)) {\n\t\t\tret = PTR_ERR(postdiv_clk);\n\t\t\tgoto err_unregister_pllout;\n\t\t}\n\n\t\tparent_name = postdiv_name;\n\t}\n\n\tpllen = kzalloc(sizeof(*pllen), GFP_KERNEL);\n\tif (!pllen) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unregister_postdiv;\n\t}\n\n\tsnprintf(pllen_name, MAX_NAME_SIZE, \"%s_pllen\", info->name);\n\n\tinit.name = pllen_name;\n\tinit.ops = &davinci_pllen_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\n\tpllen->hw.init = &init;\n\tpllen->base = base;\n\n\tpllen_clk = clk_register(dev, &pllen->hw);\n\tif (IS_ERR(pllen_clk)) {\n\t\tret = PTR_ERR(pllen_clk);\n\t\tgoto err_free_pllen;\n\t}\n\n\tclk_notifier_register(pllen_clk, &davinci_pllen_notifier);\n\n\treturn pllout_clk;\n\nerr_free_pllen:\n\tkfree(pllen);\nerr_unregister_postdiv:\n\tclk_unregister(postdiv_clk);\nerr_unregister_pllout:\n\tclk_unregister(pllout_clk);\nerr_free_pllout:\n\tkfree(pllout);\nerr_unregister_prediv:\n\tclk_unregister(prediv_clk);\nerr_unregister_oscin:\n\tclk_unregister(oscin_clk);\n\n\treturn ERR_PTR(ret);\n}\n\n \nstruct clk *davinci_pll_auxclk_register(struct device *dev,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tvoid __iomem *base)\n{\n\treturn clk_register_gate(dev, name, OSCIN_CLK_NAME, 0, base + CKEN,\n\t\t\t\t CKEN_AUXEN_SHIFT, 0, NULL);\n}\n\n \nstruct clk *davinci_pll_sysclkbp_clk_register(struct device *dev,\n\t\t\t\t\t      const char *name,\n\t\t\t\t\t      void __iomem *base)\n{\n\treturn clk_register_divider(dev, name, OSCIN_CLK_NAME, 0, base + BPDIV,\n\t\t\t\t    DIV_RATIO_SHIFT, DIV_RATIO_WIDTH,\n\t\t\t\t    CLK_DIVIDER_READ_ONLY, NULL);\n}\n\n \nstruct clk *\ndavinci_pll_obsclk_register(struct device *dev,\n\t\t\t    const struct davinci_pll_obsclk_info *info,\n\t\t\t    void __iomem *base)\n{\n\tstruct clk_mux *mux;\n\tstruct clk_gate *gate;\n\tstruct clk_divider *divider;\n\tstruct clk *clk;\n\tu32 oscdiv;\n\tint ret;\n\n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmux->reg = base + OCSEL;\n\tmux->table = info->table;\n\tmux->mask = info->ocsrc_mask;\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_mux;\n\t}\n\n\tgate->reg = base + CKEN;\n\tgate->bit_idx = CKEN_OBSCLK_SHIFT;\n\n\tdivider = kzalloc(sizeof(*divider), GFP_KERNEL);\n\tif (!divider) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_gate;\n\t}\n\n\tdivider->reg = base + OSCDIV;\n\tdivider->shift = DIV_RATIO_SHIFT;\n\tdivider->width = DIV_RATIO_WIDTH;\n\n\t \n\toscdiv = readl(base + OSCDIV);\n\toscdiv |= BIT(DIV_ENABLE_SHIFT);\n\twritel(oscdiv, base + OSCDIV);\n\n\tclk = clk_register_composite(dev, info->name, info->parent_names,\n\t\t\t\t     info->num_parents,\n\t\t\t\t     &mux->hw, &clk_mux_ops,\n\t\t\t\t     &divider->hw, &clk_divider_ops,\n\t\t\t\t     &gate->hw, &clk_gate_ops, 0);\n\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tgoto err_free_divider;\n\t}\n\n\treturn clk;\n\nerr_free_divider:\n\tkfree(divider);\nerr_free_gate:\n\tkfree(gate);\nerr_free_mux:\n\tkfree(mux);\n\n\treturn ERR_PTR(ret);\n}\n\n \nstatic int davinci_pll_sysclk_rate_change(struct notifier_block *nb,\n\t\t\t\t\t  unsigned long flags, void *data)\n{\n\tstruct clk_notifier_data *cnd = data;\n\tstruct clk_hw *hw = __clk_get_hw(clk_get_parent(cnd->clk));\n\tstruct davinci_pllen_clk *pll = to_davinci_pllen_clk(hw);\n\tu32 pllcmd, pllstat;\n\n\tswitch (flags) {\n\tcase POST_RATE_CHANGE:\n\t\t \n\t\tpllcmd = readl(pll->base + PLLCMD);\n\t\tpllcmd |= PLLCMD_GOSET;\n\t\twritel(pllcmd, pll->base + PLLCMD);\n\t\tfallthrough;\n\tcase PRE_RATE_CHANGE:\n\t\t \n\t\tdo {\n\t\t\tpllstat = readl(pll->base + PLLSTAT);\n\t\t} while (pllstat & PLLSTAT_GOSTAT);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block davinci_pll_sysclk_notifier = {\n\t.notifier_call = davinci_pll_sysclk_rate_change,\n};\n\n \nstruct clk *\ndavinci_pll_sysclk_register(struct device *dev,\n\t\t\t    const struct davinci_pll_sysclk_info *info,\n\t\t\t    void __iomem *base)\n{\n\tconst struct clk_ops *divider_ops = &clk_divider_ops;\n\tstruct clk_gate *gate;\n\tstruct clk_divider *divider;\n\tstruct clk *clk;\n\tu32 reg;\n\tu32 flags = 0;\n\tint ret;\n\n\t \n\tif (info->id < 4)\n\t\treg = PLLDIV1 + 4 * (info->id - 1);\n\telse\n\t\treg = PLLDIV4 + 4 * (info->id - 4);\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgate->reg = base + reg;\n\tgate->bit_idx = DIV_ENABLE_SHIFT;\n\n\tdivider = kzalloc(sizeof(*divider), GFP_KERNEL);\n\tif (!divider) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_gate;\n\t}\n\n\tdivider->reg = base + reg;\n\tdivider->shift = DIV_RATIO_SHIFT;\n\tdivider->width = info->ratio_width;\n\tdivider->flags = 0;\n\n\tif (info->flags & SYSCLK_FIXED_DIV) {\n\t\tdivider->flags |= CLK_DIVIDER_READ_ONLY;\n\t\tdivider_ops = &clk_divider_ro_ops;\n\t}\n\n\t \n\tif (info->flags & SYSCLK_ARM_RATE)\n\t\tflags |= CLK_SET_RATE_PARENT;\n\n\tif (info->flags & SYSCLK_ALWAYS_ENABLED)\n\t\tflags |= CLK_IS_CRITICAL;\n\n\tclk = clk_register_composite(dev, info->name, &info->parent_name, 1,\n\t\t\t\t     NULL, NULL, &divider->hw, divider_ops,\n\t\t\t\t     &gate->hw, &clk_gate_ops, flags);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tgoto err_free_divider;\n\t}\n\n\tclk_notifier_register(clk, &davinci_pll_sysclk_notifier);\n\n\treturn clk;\n\nerr_free_divider:\n\tkfree(divider);\nerr_free_gate:\n\tkfree(gate);\n\n\treturn ERR_PTR(ret);\n}\n\nint of_davinci_pll_init(struct device *dev, struct device_node *node,\n\t\t\tconst struct davinci_pll_clk_info *info,\n\t\t\tconst struct davinci_pll_obsclk_info *obsclk_info,\n\t\t\tconst struct davinci_pll_sysclk_info **div_info,\n\t\t\tu8 max_sysclk_id,\n\t\t\tvoid __iomem *base,\n\t\t\tstruct regmap *cfgchip)\n{\n\tstruct device_node *child;\n\tconst char *parent_name;\n\tstruct clk *clk;\n\n\tif (info->flags & PLL_HAS_CLKMODE)\n\t\tparent_name = of_clk_get_parent_name(node, 0);\n\telse\n\t\tparent_name = OSCIN_CLK_NAME;\n\n\tclk = davinci_pll_clk_register(dev, info, parent_name, base, cfgchip);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"failed to register %s\\n\", info->name);\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tchild = of_get_child_by_name(node, \"pllout\");\n\tif (of_device_is_available(child))\n\t\tof_clk_add_provider(child, of_clk_src_simple_get, clk);\n\tof_node_put(child);\n\n\tchild = of_get_child_by_name(node, \"sysclk\");\n\tif (of_device_is_available(child)) {\n\t\tstruct clk_onecell_data *clk_data;\n\t\tstruct clk **clks;\n\t\tint n_clks =  max_sysclk_id + 1;\n\t\tint i;\n\n\t\tclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\n\t\tif (!clk_data) {\n\t\t\tof_node_put(child);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tclks = kmalloc_array(n_clks, sizeof(*clks), GFP_KERNEL);\n\t\tif (!clks) {\n\t\t\tkfree(clk_data);\n\t\t\tof_node_put(child);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tclk_data->clks = clks;\n\t\tclk_data->clk_num = n_clks;\n\n\t\tfor (i = 0; i < n_clks; i++)\n\t\t\tclks[i] = ERR_PTR(-ENOENT);\n\n\t\tfor (; *div_info; div_info++) {\n\t\t\tclk = davinci_pll_sysclk_register(dev, *div_info, base);\n\t\t\tif (IS_ERR(clk))\n\t\t\t\tdev_warn(dev, \"failed to register %s (%ld)\\n\",\n\t\t\t\t\t (*div_info)->name, PTR_ERR(clk));\n\t\t\telse\n\t\t\t\tclks[(*div_info)->id] = clk;\n\t\t}\n\t\tof_clk_add_provider(child, of_clk_src_onecell_get, clk_data);\n\t}\n\tof_node_put(child);\n\n\tchild = of_get_child_by_name(node, \"auxclk\");\n\tif (of_device_is_available(child)) {\n\t\tchar child_name[MAX_NAME_SIZE];\n\n\t\tsnprintf(child_name, MAX_NAME_SIZE, \"%s_auxclk\", info->name);\n\n\t\tclk = davinci_pll_auxclk_register(dev, child_name, base);\n\t\tif (IS_ERR(clk))\n\t\t\tdev_warn(dev, \"failed to register %s (%ld)\\n\",\n\t\t\t\t child_name, PTR_ERR(clk));\n\t\telse\n\t\t\tof_clk_add_provider(child, of_clk_src_simple_get, clk);\n\t}\n\tof_node_put(child);\n\n\tchild = of_get_child_by_name(node, \"obsclk\");\n\tif (of_device_is_available(child)) {\n\t\tif (obsclk_info)\n\t\t\tclk = davinci_pll_obsclk_register(dev, obsclk_info, base);\n\t\telse\n\t\t\tclk = ERR_PTR(-EINVAL);\n\n\t\tif (IS_ERR(clk))\n\t\t\tdev_warn(dev, \"failed to register obsclk (%ld)\\n\",\n\t\t\t\t PTR_ERR(clk));\n\t\telse\n\t\t\tof_clk_add_provider(child, of_clk_src_simple_get, clk);\n\t}\n\tof_node_put(child);\n\n\treturn 0;\n}\n\nstatic struct davinci_pll_platform_data *davinci_pll_get_pdata(struct device *dev)\n{\n\tstruct davinci_pll_platform_data *pdata = dev_get_platdata(dev);\n\n\t \n\tif (!pdata)\n\t\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\t \n\tif (dev->of_node)\n\t\tpdata->cfgchip =\n\t\t\tsyscon_regmap_lookup_by_compatible(\"ti,da830-cfgchip\");\n\n\treturn pdata;\n}\n\n \n#ifdef CONFIG_ARCH_DAVINCI_DA850\nCLK_OF_DECLARE(da850_pll0, \"ti,da850-pll0\", of_da850_pll0_init);\n#endif\n\nstatic const struct of_device_id davinci_pll_of_match[] = {\n#ifdef CONFIG_ARCH_DAVINCI_DA850\n\t{ .compatible = \"ti,da850-pll1\", .data = of_da850_pll1_init },\n#endif\n\t{ }\n};\n\nstatic const struct platform_device_id davinci_pll_id_table[] = {\n#ifdef CONFIG_ARCH_DAVINCI_DA830\n\t{ .name = \"da830-pll\",   .driver_data = (kernel_ulong_t)da830_pll_init   },\n#endif\n#ifdef CONFIG_ARCH_DAVINCI_DA850\n\t{ .name = \"da850-pll0\",  .driver_data = (kernel_ulong_t)da850_pll0_init  },\n\t{ .name = \"da850-pll1\",  .driver_data = (kernel_ulong_t)da850_pll1_init  },\n#endif\n\t{ }\n};\n\ntypedef int (*davinci_pll_init)(struct device *dev, void __iomem *base,\n\t\t\t\tstruct regmap *cfgchip);\n\nstatic int davinci_pll_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct davinci_pll_platform_data *pdata;\n\tconst struct of_device_id *of_id;\n\tdavinci_pll_init pll_init = NULL;\n\tvoid __iomem *base;\n\n\tof_id = of_match_device(davinci_pll_of_match, dev);\n\tif (of_id)\n\t\tpll_init = of_id->data;\n\telse if (pdev->id_entry)\n\t\tpll_init = (void *)pdev->id_entry->driver_data;\n\n\tif (!pll_init) {\n\t\tdev_err(dev, \"unable to find driver data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpdata = davinci_pll_get_pdata(dev);\n\tif (!pdata) {\n\t\tdev_err(dev, \"missing platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\treturn pll_init(dev, base, pdata->cfgchip);\n}\n\nstatic struct platform_driver davinci_pll_driver = {\n\t.probe\t\t= davinci_pll_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"davinci-pll-clk\",\n\t\t.of_match_table\t= davinci_pll_of_match,\n\t},\n\t.id_table\t= davinci_pll_id_table,\n};\n\nstatic int __init davinci_pll_driver_init(void)\n{\n\treturn platform_driver_register(&davinci_pll_driver);\n}\n\n \npostcore_initcall(davinci_pll_driver_init);\n\n#ifdef CONFIG_DEBUG_FS\n#include <linux/debugfs.h>\n\n#define DEBUG_REG(n)\t\\\n{\t\t\t\\\n\t.name\t= #n,\t\\\n\t.offset\t= n,\t\\\n}\n\nstatic const struct debugfs_reg32 davinci_pll_regs[] = {\n\tDEBUG_REG(REVID),\n\tDEBUG_REG(PLLCTL),\n\tDEBUG_REG(OCSEL),\n\tDEBUG_REG(PLLSECCTL),\n\tDEBUG_REG(PLLM),\n\tDEBUG_REG(PREDIV),\n\tDEBUG_REG(PLLDIV1),\n\tDEBUG_REG(PLLDIV2),\n\tDEBUG_REG(PLLDIV3),\n\tDEBUG_REG(OSCDIV),\n\tDEBUG_REG(POSTDIV),\n\tDEBUG_REG(BPDIV),\n\tDEBUG_REG(PLLCMD),\n\tDEBUG_REG(PLLSTAT),\n\tDEBUG_REG(ALNCTL),\n\tDEBUG_REG(DCHANGE),\n\tDEBUG_REG(CKEN),\n\tDEBUG_REG(CKSTAT),\n\tDEBUG_REG(SYSTAT),\n\tDEBUG_REG(PLLDIV4),\n\tDEBUG_REG(PLLDIV5),\n\tDEBUG_REG(PLLDIV6),\n\tDEBUG_REG(PLLDIV7),\n\tDEBUG_REG(PLLDIV8),\n\tDEBUG_REG(PLLDIV9),\n};\n\nstatic void davinci_pll_debug_init(struct clk_hw *hw, struct dentry *dentry)\n{\n\tstruct davinci_pll_clk *pll = to_davinci_pll_clk(hw);\n\tstruct debugfs_regset32 *regset;\n\n\tregset = kzalloc(sizeof(*regset), GFP_KERNEL);\n\tif (!regset)\n\t\treturn;\n\n\tregset->regs = davinci_pll_regs;\n\tregset->nregs = ARRAY_SIZE(davinci_pll_regs);\n\tregset->base = pll->base;\n\n\tdebugfs_create_regset32(\"registers\", 0400, dentry, regset);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}