{
  "module_name": "ccu_mp.c",
  "hash_id": "82b0bdd1068618a3e3d0fb34a471197f02b58dc09932e5c9b7bff561523ed217",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi-ng/ccu_mp.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n\n#include \"ccu_gate.h\"\n#include \"ccu_mp.h\"\n\nstatic unsigned long ccu_mp_find_best(unsigned long parent, unsigned long rate,\n\t\t\t\t      unsigned int max_m, unsigned int max_p,\n\t\t\t\t      unsigned int *m, unsigned int *p)\n{\n\tunsigned long best_rate = 0;\n\tunsigned int best_m = 0, best_p = 0;\n\tunsigned int _m, _p;\n\n\tfor (_p = 1; _p <= max_p; _p <<= 1) {\n\t\tfor (_m = 1; _m <= max_m; _m++) {\n\t\t\tunsigned long tmp_rate = parent / _p / _m;\n\n\t\t\tif (tmp_rate > rate)\n\t\t\t\tcontinue;\n\n\t\t\tif ((rate - tmp_rate) < (rate - best_rate)) {\n\t\t\t\tbest_rate = tmp_rate;\n\t\t\t\tbest_m = _m;\n\t\t\t\tbest_p = _p;\n\t\t\t}\n\t\t}\n\t}\n\n\t*m = best_m;\n\t*p = best_p;\n\n\treturn best_rate;\n}\n\nstatic unsigned long ccu_mp_find_best_with_parent_adj(struct clk_hw *hw,\n\t\t\t\t\t\t      unsigned long *parent,\n\t\t\t\t\t\t      unsigned long rate,\n\t\t\t\t\t\t      unsigned int max_m,\n\t\t\t\t\t\t      unsigned int max_p)\n{\n\tunsigned long parent_rate_saved;\n\tunsigned long parent_rate, now;\n\tunsigned long best_rate = 0;\n\tunsigned int _m, _p, div;\n\tunsigned long maxdiv;\n\n\tparent_rate_saved = *parent;\n\n\t \n\tmaxdiv = max_m * max_p;\n\tmaxdiv = min(ULONG_MAX / rate, maxdiv);\n\n\tfor (_p = 1; _p <= max_p; _p <<= 1) {\n\t\tfor (_m = 1; _m <= max_m; _m++) {\n\t\t\tdiv = _m * _p;\n\n\t\t\tif (div > maxdiv)\n\t\t\t\tbreak;\n\n\t\t\tif (rate * div == parent_rate_saved) {\n\t\t\t\t \n\t\t\t\t*parent = parent_rate_saved;\n\t\t\t\treturn rate;\n\t\t\t}\n\n\t\t\tparent_rate = clk_hw_round_rate(hw, rate * div);\n\t\t\tnow = parent_rate / div;\n\n\t\t\tif (now <= rate && now > best_rate) {\n\t\t\t\tbest_rate = now;\n\t\t\t\t*parent = parent_rate;\n\n\t\t\t\tif (now == rate)\n\t\t\t\t\treturn rate;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn best_rate;\n}\n\nstatic unsigned long ccu_mp_round_rate(struct ccu_mux_internal *mux,\n\t\t\t\t       struct clk_hw *hw,\n\t\t\t\t       unsigned long *parent_rate,\n\t\t\t\t       unsigned long rate,\n\t\t\t\t       void *data)\n{\n\tstruct ccu_mp *cmp = data;\n\tunsigned int max_m, max_p;\n\tunsigned int m, p;\n\n\tif (cmp->common.features & CCU_FEATURE_FIXED_POSTDIV)\n\t\trate *= cmp->fixed_post_div;\n\n\tmax_m = cmp->m.max ?: 1 << cmp->m.width;\n\tmax_p = cmp->p.max ?: 1 << ((1 << cmp->p.width) - 1);\n\n\tif (!clk_hw_can_set_rate_parent(&cmp->common.hw)) {\n\t\trate = ccu_mp_find_best(*parent_rate, rate, max_m, max_p, &m, &p);\n\t} else {\n\t\trate = ccu_mp_find_best_with_parent_adj(hw, parent_rate, rate,\n\t\t\t\t\t\t\tmax_m, max_p);\n\t}\n\n\tif (cmp->common.features & CCU_FEATURE_FIXED_POSTDIV)\n\t\trate /= cmp->fixed_post_div;\n\n\treturn rate;\n}\n\nstatic void ccu_mp_disable(struct clk_hw *hw)\n{\n\tstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\n\n\treturn ccu_gate_helper_disable(&cmp->common, cmp->enable);\n}\n\nstatic int ccu_mp_enable(struct clk_hw *hw)\n{\n\tstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\n\n\treturn ccu_gate_helper_enable(&cmp->common, cmp->enable);\n}\n\nstatic int ccu_mp_is_enabled(struct clk_hw *hw)\n{\n\tstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\n\n\treturn ccu_gate_helper_is_enabled(&cmp->common, cmp->enable);\n}\n\nstatic unsigned long ccu_mp_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\n\tunsigned long rate;\n\tunsigned int m, p;\n\tu32 reg;\n\n\t \n\tparent_rate = ccu_mux_helper_apply_prediv(&cmp->common, &cmp->mux, -1,\n\t\t\t\t\t\t  parent_rate);\n\n\treg = readl(cmp->common.base + cmp->common.reg);\n\n\tm = reg >> cmp->m.shift;\n\tm &= (1 << cmp->m.width) - 1;\n\tm += cmp->m.offset;\n\tif (!m)\n\t\tm++;\n\n\tp = reg >> cmp->p.shift;\n\tp &= (1 << cmp->p.width) - 1;\n\n\trate = (parent_rate >> p) / m;\n\tif (cmp->common.features & CCU_FEATURE_FIXED_POSTDIV)\n\t\trate /= cmp->fixed_post_div;\n\n\treturn rate;\n}\n\nstatic int ccu_mp_determine_rate(struct clk_hw *hw,\n\t\t\t\t struct clk_rate_request *req)\n{\n\tstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\n\n\treturn ccu_mux_helper_determine_rate(&cmp->common, &cmp->mux,\n\t\t\t\t\t     req, ccu_mp_round_rate, cmp);\n}\n\nstatic int ccu_mp_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t   unsigned long parent_rate)\n{\n\tstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\n\tunsigned long flags;\n\tunsigned int max_m, max_p;\n\tunsigned int m, p;\n\tu32 reg;\n\n\t \n\tparent_rate = ccu_mux_helper_apply_prediv(&cmp->common, &cmp->mux, -1,\n\t\t\t\t\t\t  parent_rate);\n\n\tmax_m = cmp->m.max ?: 1 << cmp->m.width;\n\tmax_p = cmp->p.max ?: 1 << ((1 << cmp->p.width) - 1);\n\n\t \n\tif (cmp->common.features & CCU_FEATURE_FIXED_POSTDIV)\n\t\trate = rate * cmp->fixed_post_div;\n\n\tccu_mp_find_best(parent_rate, rate, max_m, max_p, &m, &p);\n\n\tspin_lock_irqsave(cmp->common.lock, flags);\n\n\treg = readl(cmp->common.base + cmp->common.reg);\n\treg &= ~GENMASK(cmp->m.width + cmp->m.shift - 1, cmp->m.shift);\n\treg &= ~GENMASK(cmp->p.width + cmp->p.shift - 1, cmp->p.shift);\n\treg |= (m - cmp->m.offset) << cmp->m.shift;\n\treg |= ilog2(p) << cmp->p.shift;\n\n\twritel(reg, cmp->common.base + cmp->common.reg);\n\n\tspin_unlock_irqrestore(cmp->common.lock, flags);\n\n\treturn 0;\n}\n\nstatic u8 ccu_mp_get_parent(struct clk_hw *hw)\n{\n\tstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\n\n\treturn ccu_mux_helper_get_parent(&cmp->common, &cmp->mux);\n}\n\nstatic int ccu_mp_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\n\n\treturn ccu_mux_helper_set_parent(&cmp->common, &cmp->mux, index);\n}\n\nconst struct clk_ops ccu_mp_ops = {\n\t.disable\t= ccu_mp_disable,\n\t.enable\t\t= ccu_mp_enable,\n\t.is_enabled\t= ccu_mp_is_enabled,\n\n\t.get_parent\t= ccu_mp_get_parent,\n\t.set_parent\t= ccu_mp_set_parent,\n\n\t.determine_rate\t= ccu_mp_determine_rate,\n\t.recalc_rate\t= ccu_mp_recalc_rate,\n\t.set_rate\t= ccu_mp_set_rate,\n};\nEXPORT_SYMBOL_NS_GPL(ccu_mp_ops, SUNXI_CCU);\n\n \n\nstatic unsigned long ccu_mp_mmc_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tunsigned long rate = ccu_mp_recalc_rate(hw, parent_rate);\n\tstruct ccu_common *cm = hw_to_ccu_common(hw);\n\tu32 val = readl(cm->base + cm->reg);\n\n\tif (val & CCU_MMC_NEW_TIMING_MODE)\n\t\treturn rate / 2;\n\treturn rate;\n}\n\nstatic int ccu_mp_mmc_determine_rate(struct clk_hw *hw,\n\t\t\t\t     struct clk_rate_request *req)\n{\n\tstruct ccu_common *cm = hw_to_ccu_common(hw);\n\tu32 val = readl(cm->base + cm->reg);\n\tint ret;\n\n\t \n\tif (val & CCU_MMC_NEW_TIMING_MODE) {\n\t\treq->rate *= 2;\n\t\treq->min_rate *= 2;\n\t\treq->max_rate *= 2;\n\t}\n\n\tret = ccu_mp_determine_rate(hw, req);\n\n\t \n\tif (val & CCU_MMC_NEW_TIMING_MODE) {\n\t\treq->rate /= 2;\n\t\treq->min_rate /= 2;\n\t\treq->max_rate /= 2;\n\t}\n\n\treturn ret;\n}\n\nstatic int ccu_mp_mmc_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct ccu_common *cm = hw_to_ccu_common(hw);\n\tu32 val = readl(cm->base + cm->reg);\n\n\tif (val & CCU_MMC_NEW_TIMING_MODE)\n\t\trate *= 2;\n\n\treturn ccu_mp_set_rate(hw, rate, parent_rate);\n}\n\nconst struct clk_ops ccu_mp_mmc_ops = {\n\t.disable\t= ccu_mp_disable,\n\t.enable\t\t= ccu_mp_enable,\n\t.is_enabled\t= ccu_mp_is_enabled,\n\n\t.get_parent\t= ccu_mp_get_parent,\n\t.set_parent\t= ccu_mp_set_parent,\n\n\t.determine_rate\t= ccu_mp_mmc_determine_rate,\n\t.recalc_rate\t= ccu_mp_mmc_recalc_rate,\n\t.set_rate\t= ccu_mp_mmc_set_rate,\n};\nEXPORT_SYMBOL_NS_GPL(ccu_mp_mmc_ops, SUNXI_CCU);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}