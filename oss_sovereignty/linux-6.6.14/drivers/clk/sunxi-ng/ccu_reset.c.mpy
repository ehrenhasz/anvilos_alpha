{
  "module_name": "ccu_reset.c",
  "hash_id": "a5f1d4323a8f371fec139b84b05ff491c19bb1d64c3b292d4c4b08ec9e7048b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi-ng/ccu_reset.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/reset-controller.h>\n\n#include \"ccu_reset.h\"\n\nstatic int ccu_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long id)\n{\n\tstruct ccu_reset *ccu = rcdev_to_ccu_reset(rcdev);\n\tconst struct ccu_reset_map *map = &ccu->reset_map[id];\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(ccu->lock, flags);\n\n\treg = readl(ccu->base + map->reg);\n\twritel(reg & ~map->bit, ccu->base + map->reg);\n\n\tspin_unlock_irqrestore(ccu->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ccu_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct ccu_reset *ccu = rcdev_to_ccu_reset(rcdev);\n\tconst struct ccu_reset_map *map = &ccu->reset_map[id];\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(ccu->lock, flags);\n\n\treg = readl(ccu->base + map->reg);\n\twritel(reg | map->bit, ccu->base + map->reg);\n\n\tspin_unlock_irqrestore(ccu->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ccu_reset_reset(struct reset_controller_dev *rcdev,\n\t\t\t   unsigned long id)\n{\n\tccu_reset_assert(rcdev, id);\n\tudelay(10);\n\tccu_reset_deassert(rcdev, id);\n\n\treturn 0;\n}\n\nstatic int ccu_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long id)\n{\n\tstruct ccu_reset *ccu = rcdev_to_ccu_reset(rcdev);\n\tconst struct ccu_reset_map *map = &ccu->reset_map[id];\n\n\t \n\treturn !(map->bit & readl(ccu->base + map->reg));\n}\n\nconst struct reset_control_ops ccu_reset_ops = {\n\t.assert\t\t= ccu_reset_assert,\n\t.deassert\t= ccu_reset_deassert,\n\t.reset\t\t= ccu_reset_reset,\n\t.status\t\t= ccu_reset_status,\n};\nEXPORT_SYMBOL_NS_GPL(ccu_reset_ops, SUNXI_CCU);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}