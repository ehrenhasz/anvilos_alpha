{
  "module_name": "ccu_mux.c",
  "hash_id": "9238bfba47176c08b6335ca740145649dc5b68cd1ced12e25eae8e4b6c652417",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi-ng/ccu_mux.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n\n#include \"ccu_gate.h\"\n#include \"ccu_mux.h\"\n\n#define CCU_MUX_KEY_VALUE\t\t0x16aa0000\n\nstatic u16 ccu_mux_get_prediv(struct ccu_common *common,\n\t\t\t      struct ccu_mux_internal *cm,\n\t\t\t      int parent_index)\n{\n\tu16 prediv = 1;\n\tu32 reg;\n\n\tif (!((common->features & CCU_FEATURE_FIXED_PREDIV) ||\n\t      (common->features & CCU_FEATURE_VARIABLE_PREDIV) ||\n\t      (common->features & CCU_FEATURE_ALL_PREDIV)))\n\t\treturn 1;\n\n\tif (common->features & CCU_FEATURE_ALL_PREDIV)\n\t\treturn common->prediv;\n\n\treg = readl(common->base + common->reg);\n\tif (parent_index < 0) {\n\t\tparent_index = reg >> cm->shift;\n\t\tparent_index &= (1 << cm->width) - 1;\n\t}\n\n\tif (common->features & CCU_FEATURE_FIXED_PREDIV) {\n\t\tint i;\n\n\t\tfor (i = 0; i < cm->n_predivs; i++)\n\t\t\tif (parent_index == cm->fixed_predivs[i].index)\n\t\t\t\tprediv = cm->fixed_predivs[i].div;\n\t}\n\n\tif (common->features & CCU_FEATURE_VARIABLE_PREDIV) {\n\t\tint i;\n\n\t\tfor (i = 0; i < cm->n_var_predivs; i++)\n\t\t\tif (parent_index == cm->var_predivs[i].index) {\n\t\t\t\tu8 div;\n\n\t\t\t\tdiv = reg >> cm->var_predivs[i].shift;\n\t\t\t\tdiv &= (1 << cm->var_predivs[i].width) - 1;\n\t\t\t\tprediv = div + 1;\n\t\t\t}\n\t}\n\n\treturn prediv;\n}\n\nunsigned long ccu_mux_helper_apply_prediv(struct ccu_common *common,\n\t\t\t\t\t  struct ccu_mux_internal *cm,\n\t\t\t\t\t  int parent_index,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\treturn parent_rate / ccu_mux_get_prediv(common, cm, parent_index);\n}\nEXPORT_SYMBOL_NS_GPL(ccu_mux_helper_apply_prediv, SUNXI_CCU);\n\nstatic unsigned long ccu_mux_helper_unapply_prediv(struct ccu_common *common,\n\t\t\t\t\t    struct ccu_mux_internal *cm,\n\t\t\t\t\t    int parent_index,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\treturn parent_rate * ccu_mux_get_prediv(common, cm, parent_index);\n}\n\nint ccu_mux_helper_determine_rate(struct ccu_common *common,\n\t\t\t\t  struct ccu_mux_internal *cm,\n\t\t\t\t  struct clk_rate_request *req,\n\t\t\t\t  unsigned long (*round)(struct ccu_mux_internal *,\n\t\t\t\t\t\t\t struct clk_hw *,\n\t\t\t\t\t\t\t unsigned long *,\n\t\t\t\t\t\t\t unsigned long,\n\t\t\t\t\t\t\t void *),\n\t\t\t\t  void *data)\n{\n\tunsigned long best_parent_rate = 0, best_rate = 0;\n\tstruct clk_hw *best_parent, *hw = &common->hw;\n\tunsigned int i;\n\n\tif (clk_hw_get_flags(hw) & CLK_SET_RATE_NO_REPARENT) {\n\t\tunsigned long adj_parent_rate;\n\n\t\tbest_parent = clk_hw_get_parent(hw);\n\t\tbest_parent_rate = clk_hw_get_rate(best_parent);\n\t\tadj_parent_rate = ccu_mux_helper_apply_prediv(common, cm, -1,\n\t\t\t\t\t\t\t      best_parent_rate);\n\n\t\tbest_rate = round(cm, best_parent, &adj_parent_rate,\n\t\t\t\t  req->rate, data);\n\n\t\t \n\t\tbest_parent_rate = ccu_mux_helper_unapply_prediv(common, cm, -1,\n\t\t\t\t\t\t\t\t adj_parent_rate);\n\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\n\t\tunsigned long tmp_rate, parent_rate;\n\t\tstruct clk_hw *parent;\n\n\t\tparent = clk_hw_get_parent_by_index(hw, i);\n\t\tif (!parent)\n\t\t\tcontinue;\n\n\t\tparent_rate = ccu_mux_helper_apply_prediv(common, cm, i,\n\t\t\t\t\t\t\t  clk_hw_get_rate(parent));\n\n\t\ttmp_rate = round(cm, parent, &parent_rate, req->rate, data);\n\n\t\t \n\t\tparent_rate = ccu_mux_helper_unapply_prediv(common, cm, i,\n\t\t\t\t\t\t\t    parent_rate);\n\t\tif (tmp_rate == req->rate) {\n\t\t\tbest_parent = parent;\n\t\t\tbest_parent_rate = parent_rate;\n\t\t\tbest_rate = tmp_rate;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ccu_is_better_rate(common, req->rate, tmp_rate, best_rate)) {\n\t\t\tbest_rate = tmp_rate;\n\t\t\tbest_parent_rate = parent_rate;\n\t\t\tbest_parent = parent;\n\t\t}\n\t}\n\n\tif (best_rate == 0)\n\t\treturn -EINVAL;\n\nout:\n\treq->best_parent_hw = best_parent;\n\treq->best_parent_rate = best_parent_rate;\n\treq->rate = best_rate;\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(ccu_mux_helper_determine_rate, SUNXI_CCU);\n\nu8 ccu_mux_helper_get_parent(struct ccu_common *common,\n\t\t\t     struct ccu_mux_internal *cm)\n{\n\tu32 reg;\n\tu8 parent;\n\n\treg = readl(common->base + common->reg);\n\tparent = reg >> cm->shift;\n\tparent &= (1 << cm->width) - 1;\n\n\tif (cm->table) {\n\t\tint num_parents = clk_hw_get_num_parents(&common->hw);\n\t\tint i;\n\n\t\tfor (i = 0; i < num_parents; i++)\n\t\t\tif (cm->table[i] == parent)\n\t\t\t\treturn i;\n\t}\n\n\treturn parent;\n}\nEXPORT_SYMBOL_NS_GPL(ccu_mux_helper_get_parent, SUNXI_CCU);\n\nint ccu_mux_helper_set_parent(struct ccu_common *common,\n\t\t\t      struct ccu_mux_internal *cm,\n\t\t\t      u8 index)\n{\n\tunsigned long flags;\n\tu32 reg;\n\n\tif (cm->table)\n\t\tindex = cm->table[index];\n\n\tspin_lock_irqsave(common->lock, flags);\n\n\treg = readl(common->base + common->reg);\n\n\t \n\tif (common->features & CCU_FEATURE_KEY_FIELD)\n\t\treg |= CCU_MUX_KEY_VALUE;\n\n\treg &= ~GENMASK(cm->width + cm->shift - 1, cm->shift);\n\twritel(reg | (index << cm->shift), common->base + common->reg);\n\n\tspin_unlock_irqrestore(common->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(ccu_mux_helper_set_parent, SUNXI_CCU);\n\nstatic void ccu_mux_disable(struct clk_hw *hw)\n{\n\tstruct ccu_mux *cm = hw_to_ccu_mux(hw);\n\n\treturn ccu_gate_helper_disable(&cm->common, cm->enable);\n}\n\nstatic int ccu_mux_enable(struct clk_hw *hw)\n{\n\tstruct ccu_mux *cm = hw_to_ccu_mux(hw);\n\n\treturn ccu_gate_helper_enable(&cm->common, cm->enable);\n}\n\nstatic int ccu_mux_is_enabled(struct clk_hw *hw)\n{\n\tstruct ccu_mux *cm = hw_to_ccu_mux(hw);\n\n\treturn ccu_gate_helper_is_enabled(&cm->common, cm->enable);\n}\n\nstatic u8 ccu_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct ccu_mux *cm = hw_to_ccu_mux(hw);\n\n\treturn ccu_mux_helper_get_parent(&cm->common, &cm->mux);\n}\n\nstatic int ccu_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct ccu_mux *cm = hw_to_ccu_mux(hw);\n\n\treturn ccu_mux_helper_set_parent(&cm->common, &cm->mux, index);\n}\n\nstatic int ccu_mux_determine_rate(struct clk_hw *hw,\n\t\t\t\t  struct clk_rate_request *req)\n{\n\tstruct ccu_mux *cm = hw_to_ccu_mux(hw);\n\n\tif (cm->common.features & CCU_FEATURE_CLOSEST_RATE)\n\t\treturn clk_mux_determine_rate_flags(hw, req, CLK_MUX_ROUND_CLOSEST);\n\n\treturn clk_mux_determine_rate_flags(hw, req, 0);\n}\n\nstatic unsigned long ccu_mux_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct ccu_mux *cm = hw_to_ccu_mux(hw);\n\n\treturn ccu_mux_helper_apply_prediv(&cm->common, &cm->mux, -1,\n\t\t\t\t\t   parent_rate);\n}\n\nconst struct clk_ops ccu_mux_ops = {\n\t.disable\t= ccu_mux_disable,\n\t.enable\t\t= ccu_mux_enable,\n\t.is_enabled\t= ccu_mux_is_enabled,\n\n\t.get_parent\t= ccu_mux_get_parent,\n\t.set_parent\t= ccu_mux_set_parent,\n\n\t.determine_rate\t= ccu_mux_determine_rate,\n\t.recalc_rate\t= ccu_mux_recalc_rate,\n};\nEXPORT_SYMBOL_NS_GPL(ccu_mux_ops, SUNXI_CCU);\n\n \nstatic int ccu_mux_notifier_cb(struct notifier_block *nb,\n\t\t\t       unsigned long event, void *data)\n{\n\tstruct ccu_mux_nb *mux = to_ccu_mux_nb(nb);\n\tint ret = 0;\n\n\tif (event == PRE_RATE_CHANGE) {\n\t\tmux->original_index = ccu_mux_helper_get_parent(mux->common,\n\t\t\t\t\t\t\t\tmux->cm);\n\t\tret = ccu_mux_helper_set_parent(mux->common, mux->cm,\n\t\t\t\t\t\tmux->bypass_index);\n\t} else if (event == POST_RATE_CHANGE) {\n\t\tret = ccu_mux_helper_set_parent(mux->common, mux->cm,\n\t\t\t\t\t\tmux->original_index);\n\t}\n\n\tudelay(mux->delay_us);\n\n\treturn notifier_from_errno(ret);\n}\n\nint ccu_mux_notifier_register(struct clk *clk, struct ccu_mux_nb *mux_nb)\n{\n\tmux_nb->clk_nb.notifier_call = ccu_mux_notifier_cb;\n\n\treturn clk_notifier_register(clk, &mux_nb->clk_nb);\n}\nEXPORT_SYMBOL_NS_GPL(ccu_mux_notifier_register, SUNXI_CCU);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}