{
  "module_name": "ccu_frac.c",
  "hash_id": "0425e414967668747df818576bf28e2c6457cc90719e083ea3b7afb04c9afbdb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi-ng/ccu_frac.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/spinlock.h>\n\n#include \"ccu_frac.h\"\n\nbool ccu_frac_helper_is_enabled(struct ccu_common *common,\n\t\t\t\tstruct ccu_frac_internal *cf)\n{\n\tif (!(common->features & CCU_FEATURE_FRACTIONAL))\n\t\treturn false;\n\n\treturn !(readl(common->base + common->reg) & cf->enable);\n}\nEXPORT_SYMBOL_NS_GPL(ccu_frac_helper_is_enabled, SUNXI_CCU);\n\nvoid ccu_frac_helper_enable(struct ccu_common *common,\n\t\t\t    struct ccu_frac_internal *cf)\n{\n\tunsigned long flags;\n\tu32 reg;\n\n\tif (!(common->features & CCU_FEATURE_FRACTIONAL))\n\t\treturn;\n\n\tspin_lock_irqsave(common->lock, flags);\n\treg = readl(common->base + common->reg);\n\twritel(reg & ~cf->enable, common->base + common->reg);\n\tspin_unlock_irqrestore(common->lock, flags);\n}\nEXPORT_SYMBOL_NS_GPL(ccu_frac_helper_enable, SUNXI_CCU);\n\nvoid ccu_frac_helper_disable(struct ccu_common *common,\n\t\t\t     struct ccu_frac_internal *cf)\n{\n\tunsigned long flags;\n\tu32 reg;\n\n\tif (!(common->features & CCU_FEATURE_FRACTIONAL))\n\t\treturn;\n\n\tspin_lock_irqsave(common->lock, flags);\n\treg = readl(common->base + common->reg);\n\twritel(reg | cf->enable, common->base + common->reg);\n\tspin_unlock_irqrestore(common->lock, flags);\n}\nEXPORT_SYMBOL_NS_GPL(ccu_frac_helper_disable, SUNXI_CCU);\n\nbool ccu_frac_helper_has_rate(struct ccu_common *common,\n\t\t\t      struct ccu_frac_internal *cf,\n\t\t\t      unsigned long rate)\n{\n\tif (!(common->features & CCU_FEATURE_FRACTIONAL))\n\t\treturn false;\n\n\treturn (cf->rates[0] == rate) || (cf->rates[1] == rate);\n}\nEXPORT_SYMBOL_NS_GPL(ccu_frac_helper_has_rate, SUNXI_CCU);\n\nunsigned long ccu_frac_helper_read_rate(struct ccu_common *common,\n\t\t\t\t\tstruct ccu_frac_internal *cf)\n{\n\tu32 reg;\n\n\tpr_debug(\"%s: Read fractional\\n\", clk_hw_get_name(&common->hw));\n\n\tif (!(common->features & CCU_FEATURE_FRACTIONAL))\n\t\treturn 0;\n\n\tpr_debug(\"%s: clock is fractional (rates %lu and %lu)\\n\",\n\t\t clk_hw_get_name(&common->hw), cf->rates[0], cf->rates[1]);\n\n\treg = readl(common->base + common->reg);\n\n\tpr_debug(\"%s: clock reg is 0x%x (select is 0x%x)\\n\",\n\t\t clk_hw_get_name(&common->hw), reg, cf->select);\n\n\treturn (reg & cf->select) ? cf->rates[1] : cf->rates[0];\n}\nEXPORT_SYMBOL_NS_GPL(ccu_frac_helper_read_rate, SUNXI_CCU);\n\nint ccu_frac_helper_set_rate(struct ccu_common *common,\n\t\t\t     struct ccu_frac_internal *cf,\n\t\t\t     unsigned long rate, u32 lock)\n{\n\tunsigned long flags;\n\tu32 reg, sel;\n\n\tif (!(common->features & CCU_FEATURE_FRACTIONAL))\n\t\treturn -EINVAL;\n\n\tif (cf->rates[0] == rate)\n\t\tsel = 0;\n\telse if (cf->rates[1] == rate)\n\t\tsel = cf->select;\n\telse\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(common->lock, flags);\n\treg = readl(common->base + common->reg);\n\treg &= ~cf->select;\n\twritel(reg | sel, common->base + common->reg);\n\tspin_unlock_irqrestore(common->lock, flags);\n\n\tccu_helper_wait_for_lock(common, lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(ccu_frac_helper_set_rate, SUNXI_CCU);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}