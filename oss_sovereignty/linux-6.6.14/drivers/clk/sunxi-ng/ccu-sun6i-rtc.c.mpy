{
  "module_name": "ccu-sun6i-rtc.c",
  "hash_id": "5e4de5cdc75435c74a8604a80b36eef60cf06e3e68de58bf02356d47288e30fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi-ng/ccu-sun6i-rtc.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n\n#include <linux/clk/sunxi-ng.h>\n\n#include \"ccu_common.h\"\n\n#include \"ccu_div.h\"\n#include \"ccu_gate.h\"\n#include \"ccu_mux.h\"\n\n#include \"ccu-sun6i-rtc.h\"\n\n#define IOSC_ACCURACY\t\t\t300000000  \n#define IOSC_RATE\t\t\t16000000\n\n#define LOSC_RATE\t\t\t32768\n#define LOSC_RATE_SHIFT\t\t\t15\n\n#define LOSC_CTRL_REG\t\t\t0x0\n#define LOSC_CTRL_KEY\t\t\t0x16aa0000\n\n#define IOSC_32K_CLK_DIV_REG\t\t0x8\n#define IOSC_32K_CLK_DIV\t\tGENMASK(4, 0)\n#define IOSC_32K_PRE_DIV\t\t32\n\n#define IOSC_CLK_CALI_REG\t\t0xc\n#define IOSC_CLK_CALI_DIV_ONES\t\t22\n#define IOSC_CLK_CALI_EN\t\tBIT(1)\n#define IOSC_CLK_CALI_SRC_SEL\t\tBIT(0)\n\n#define LOSC_OUT_GATING_REG\t\t0x60\n\n#define DCXO_CTRL_REG\t\t\t0x160\n#define DCXO_CTRL_CLK16M_RC_EN\t\tBIT(0)\n\nstruct sun6i_rtc_match_data {\n\tbool\t\t\t\thave_ext_osc32k\t\t: 1;\n\tbool\t\t\t\thave_iosc_calibration\t: 1;\n\tbool\t\t\t\trtc_32k_single_parent\t: 1;\n\tconst struct clk_parent_data\t*osc32k_fanout_parents;\n\tu8\t\t\t\tosc32k_fanout_nparents;\n};\n\nstatic bool have_iosc_calibration;\n\nstatic int ccu_iosc_enable(struct clk_hw *hw)\n{\n\tstruct ccu_common *cm = hw_to_ccu_common(hw);\n\n\treturn ccu_gate_helper_enable(cm, DCXO_CTRL_CLK16M_RC_EN);\n}\n\nstatic void ccu_iosc_disable(struct clk_hw *hw)\n{\n\tstruct ccu_common *cm = hw_to_ccu_common(hw);\n\n\treturn ccu_gate_helper_disable(cm, DCXO_CTRL_CLK16M_RC_EN);\n}\n\nstatic int ccu_iosc_is_enabled(struct clk_hw *hw)\n{\n\tstruct ccu_common *cm = hw_to_ccu_common(hw);\n\n\treturn ccu_gate_helper_is_enabled(cm, DCXO_CTRL_CLK16M_RC_EN);\n}\n\nstatic unsigned long ccu_iosc_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct ccu_common *cm = hw_to_ccu_common(hw);\n\n\tif (have_iosc_calibration) {\n\t\tu32 reg = readl(cm->base + IOSC_CLK_CALI_REG);\n\n\t\t \n\t\tif (reg & IOSC_CLK_CALI_EN)\n\t\t\treturn reg >> (IOSC_CLK_CALI_DIV_ONES - LOSC_RATE_SHIFT);\n\t}\n\n\treturn IOSC_RATE;\n}\n\nstatic unsigned long ccu_iosc_recalc_accuracy(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_accuracy)\n{\n\treturn IOSC_ACCURACY;\n}\n\nstatic const struct clk_ops ccu_iosc_ops = {\n\t.enable\t\t\t= ccu_iosc_enable,\n\t.disable\t\t= ccu_iosc_disable,\n\t.is_enabled\t\t= ccu_iosc_is_enabled,\n\t.recalc_rate\t\t= ccu_iosc_recalc_rate,\n\t.recalc_accuracy\t= ccu_iosc_recalc_accuracy,\n};\n\nstatic struct ccu_common iosc_clk = {\n\t.reg\t\t= DCXO_CTRL_REG,\n\t.hw.init\t= CLK_HW_INIT_NO_PARENT(\"iosc\", &ccu_iosc_ops,\n\t\t\t\t\t\tCLK_GET_RATE_NOCACHE),\n};\n\nstatic int ccu_iosc_32k_prepare(struct clk_hw *hw)\n{\n\tstruct ccu_common *cm = hw_to_ccu_common(hw);\n\tu32 val;\n\n\tif (!have_iosc_calibration)\n\t\treturn 0;\n\n\tval = readl(cm->base + IOSC_CLK_CALI_REG);\n\twritel(val | IOSC_CLK_CALI_EN | IOSC_CLK_CALI_SRC_SEL,\n\t       cm->base + IOSC_CLK_CALI_REG);\n\n\treturn 0;\n}\n\nstatic void ccu_iosc_32k_unprepare(struct clk_hw *hw)\n{\n\tstruct ccu_common *cm = hw_to_ccu_common(hw);\n\tu32 val;\n\n\tif (!have_iosc_calibration)\n\t\treturn;\n\n\tval = readl(cm->base + IOSC_CLK_CALI_REG);\n\twritel(val & ~(IOSC_CLK_CALI_EN | IOSC_CLK_CALI_SRC_SEL),\n\t       cm->base + IOSC_CLK_CALI_REG);\n}\n\nstatic unsigned long ccu_iosc_32k_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct ccu_common *cm = hw_to_ccu_common(hw);\n\tu32 val;\n\n\tif (have_iosc_calibration) {\n\t\tval = readl(cm->base + IOSC_CLK_CALI_REG);\n\n\t\t \n\t\tif (val & IOSC_CLK_CALI_SRC_SEL)\n\t\t\treturn LOSC_RATE;\n\t}\n\n\tval = readl(cm->base + IOSC_32K_CLK_DIV_REG) & IOSC_32K_CLK_DIV;\n\n\treturn parent_rate / IOSC_32K_PRE_DIV / (val + 1);\n}\n\nstatic unsigned long ccu_iosc_32k_recalc_accuracy(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_accuracy)\n{\n\tstruct ccu_common *cm = hw_to_ccu_common(hw);\n\tu32 val;\n\n\tif (have_iosc_calibration) {\n\t\tval = readl(cm->base + IOSC_CLK_CALI_REG);\n\n\t\t \n\t\tif (val & IOSC_CLK_CALI_SRC_SEL)\n\t\t\treturn 0;\n\t}\n\n\treturn parent_accuracy;\n}\n\nstatic const struct clk_ops ccu_iosc_32k_ops = {\n\t.prepare\t\t= ccu_iosc_32k_prepare,\n\t.unprepare\t\t= ccu_iosc_32k_unprepare,\n\t.recalc_rate\t\t= ccu_iosc_32k_recalc_rate,\n\t.recalc_accuracy\t= ccu_iosc_32k_recalc_accuracy,\n};\n\nstatic struct ccu_common iosc_32k_clk = {\n\t.hw.init\t= CLK_HW_INIT_HW(\"iosc-32k\", &iosc_clk.hw,\n\t\t\t\t\t &ccu_iosc_32k_ops,\n\t\t\t\t\t CLK_GET_RATE_NOCACHE),\n};\n\nstatic const struct clk_hw *ext_osc32k[] = { NULL };  \n\nstatic SUNXI_CCU_GATE_HWS(ext_osc32k_gate_clk, \"ext-osc32k-gate\",\n\t\t\t  ext_osc32k, 0x0, BIT(4), 0);\n\nstatic const struct clk_hw *osc32k_parents[] = {\n\t&iosc_32k_clk.hw,\n\t&ext_osc32k_gate_clk.common.hw\n};\n\nstatic struct clk_init_data osc32k_init_data = {\n\t.name\t\t= \"osc32k\",\n\t.ops\t\t= &ccu_mux_ops,\n\t.parent_hws\t= osc32k_parents,\n\t.num_parents\t= ARRAY_SIZE(osc32k_parents),  \n};\n\nstatic struct ccu_mux osc32k_clk = {\n\t.mux\t= _SUNXI_CCU_MUX(0, 1),\n\t.common\t= {\n\t\t.reg\t\t= LOSC_CTRL_REG,\n\t\t.features\t= CCU_FEATURE_KEY_FIELD,\n\t\t.hw.init\t= &osc32k_init_data,\n\t},\n};\n\n \nstatic const struct clk_parent_data osc24M[] = {\n\t{ .fw_name = \"hosc\", .name = \"osc24M\" }\n};\n\nstatic struct ccu_gate osc24M_32k_clk = {\n\t.enable\t= BIT(16),\n\t.common\t= {\n\t\t.reg\t\t= LOSC_OUT_GATING_REG,\n\t\t.prediv\t\t= 750,\n\t\t.features\t= CCU_FEATURE_ALL_PREDIV,\n\t\t.hw.init\t= CLK_HW_INIT_PARENTS_DATA(\"osc24M-32k\", osc24M,\n\t\t\t\t\t\t\t   &ccu_gate_ops, 0),\n\t},\n};\n\nstatic const struct clk_hw *rtc_32k_parents[] = {\n\t&osc32k_clk.common.hw,\n\t&osc24M_32k_clk.common.hw\n};\n\nstatic struct clk_init_data rtc_32k_init_data = {\n\t.name\t\t= \"rtc-32k\",\n\t.ops\t\t= &ccu_mux_ops,\n\t.parent_hws\t= rtc_32k_parents,\n\t.num_parents\t= ARRAY_SIZE(rtc_32k_parents),  \n\t.flags\t\t= CLK_IS_CRITICAL,\n};\n\nstatic struct ccu_mux rtc_32k_clk = {\n\t.mux\t= _SUNXI_CCU_MUX(1, 1),\n\t.common\t= {\n\t\t.reg\t\t= LOSC_CTRL_REG,\n\t\t.features\t= CCU_FEATURE_KEY_FIELD,\n\t\t.hw.init\t= &rtc_32k_init_data,\n\t},\n};\n\nstatic struct clk_init_data osc32k_fanout_init_data = {\n\t.name\t\t= \"osc32k-fanout\",\n\t.ops\t\t= &ccu_mux_ops,\n\t \n};\n\nstatic struct ccu_mux osc32k_fanout_clk = {\n\t.enable\t= BIT(0),\n\t.mux\t= _SUNXI_CCU_MUX(1, 2),\n\t.common\t= {\n\t\t.reg\t\t= LOSC_OUT_GATING_REG,\n\t\t.hw.init\t= &osc32k_fanout_init_data,\n\t},\n};\n\nstatic struct ccu_common *sun6i_rtc_ccu_clks[] = {\n\t&iosc_clk,\n\t&iosc_32k_clk,\n\t&ext_osc32k_gate_clk.common,\n\t&osc32k_clk.common,\n\t&osc24M_32k_clk.common,\n\t&rtc_32k_clk.common,\n\t&osc32k_fanout_clk.common,\n};\n\nstatic struct clk_hw_onecell_data sun6i_rtc_ccu_hw_clks = {\n\t.num = CLK_NUMBER,\n\t.hws = {\n\t\t[CLK_OSC32K]\t\t= &osc32k_clk.common.hw,\n\t\t[CLK_OSC32K_FANOUT]\t= &osc32k_fanout_clk.common.hw,\n\t\t[CLK_IOSC]\t\t= &iosc_clk.hw,\n\t\t[CLK_IOSC_32K]\t\t= &iosc_32k_clk.hw,\n\t\t[CLK_EXT_OSC32K_GATE]\t= &ext_osc32k_gate_clk.common.hw,\n\t\t[CLK_OSC24M_32K]\t= &osc24M_32k_clk.common.hw,\n\t\t[CLK_RTC_32K]\t\t= &rtc_32k_clk.common.hw,\n\t},\n};\n\nstatic const struct sunxi_ccu_desc sun6i_rtc_ccu_desc = {\n\t.ccu_clks\t= sun6i_rtc_ccu_clks,\n\t.num_ccu_clks\t= ARRAY_SIZE(sun6i_rtc_ccu_clks),\n\n\t.hw_clks\t= &sun6i_rtc_ccu_hw_clks,\n};\n\nstatic const struct clk_parent_data sun50i_h616_osc32k_fanout_parents[] = {\n\t{ .hw = &osc32k_clk.common.hw },\n\t{ .fw_name = \"pll-32k\" },\n\t{ .hw = &osc24M_32k_clk.common.hw }\n};\n\nstatic const struct clk_parent_data sun50i_r329_osc32k_fanout_parents[] = {\n\t{ .hw = &osc32k_clk.common.hw },\n\t{ .hw = &ext_osc32k_gate_clk.common.hw },\n\t{ .hw = &osc24M_32k_clk.common.hw }\n};\n\nstatic const struct sun6i_rtc_match_data sun50i_h616_rtc_ccu_data = {\n\t.have_iosc_calibration\t= true,\n\t.rtc_32k_single_parent\t= true,\n\t.osc32k_fanout_parents\t= sun50i_h616_osc32k_fanout_parents,\n\t.osc32k_fanout_nparents\t= ARRAY_SIZE(sun50i_h616_osc32k_fanout_parents),\n};\n\nstatic const struct sun6i_rtc_match_data sun50i_r329_rtc_ccu_data = {\n\t.have_ext_osc32k\t= true,\n\t.osc32k_fanout_parents\t= sun50i_r329_osc32k_fanout_parents,\n\t.osc32k_fanout_nparents\t= ARRAY_SIZE(sun50i_r329_osc32k_fanout_parents),\n};\n\nstatic const struct of_device_id sun6i_rtc_ccu_match[] = {\n\t{\n\t\t.compatible\t= \"allwinner,sun50i-h616-rtc\",\n\t\t.data\t\t= &sun50i_h616_rtc_ccu_data,\n\t},\n\t{\n\t\t.compatible\t= \"allwinner,sun50i-r329-rtc\",\n\t\t.data\t\t= &sun50i_r329_rtc_ccu_data,\n\t},\n\t{},\n};\n\nint sun6i_rtc_ccu_probe(struct device *dev, void __iomem *reg)\n{\n\tconst struct sun6i_rtc_match_data *data;\n\tstruct clk *ext_osc32k_clk = NULL;\n\tconst struct of_device_id *match;\n\n\t \n\tmatch = of_match_device(sun6i_rtc_ccu_match, dev);\n\tif (!match)\n\t\treturn 0;\n\n\tdata = match->data;\n\thave_iosc_calibration = data->have_iosc_calibration;\n\n\tif (data->have_ext_osc32k) {\n\t\tconst char *fw_name;\n\n\t\t \n\t\tfw_name = of_property_read_bool(dev->of_node, \"clock-names\")\n\t\t\t? \"ext-osc32k\" : NULL;\n\t\text_osc32k_clk = devm_clk_get_optional(dev, fw_name);\n\t\tif (IS_ERR(ext_osc32k_clk))\n\t\t\treturn PTR_ERR(ext_osc32k_clk);\n\t}\n\n\tif (ext_osc32k_clk) {\n\t\t \n\t\t*ext_osc32k = __clk_get_hw(ext_osc32k_clk);\n\t} else {\n\t\t \n\t\tsun6i_rtc_ccu_hw_clks.hws[CLK_EXT_OSC32K_GATE] = NULL;\n\t\tosc32k_init_data.num_parents = 1;\n\t}\n\n\tif (data->rtc_32k_single_parent)\n\t\trtc_32k_init_data.num_parents = 1;\n\n\tosc32k_fanout_init_data.parent_data = data->osc32k_fanout_parents;\n\tosc32k_fanout_init_data.num_parents = data->osc32k_fanout_nparents;\n\n\treturn devm_sunxi_ccu_probe(dev, reg, &sun6i_rtc_ccu_desc);\n}\n\nMODULE_IMPORT_NS(SUNXI_CCU);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}