{
  "module_name": "ccu_phase.c",
  "hash_id": "1d3d9918310e7d1267e14dbee744107e2867048711bc79c1f528afd9594ad215",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi-ng/ccu_phase.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/spinlock.h>\n\n#include \"ccu_phase.h\"\n\nstatic int ccu_phase_get_phase(struct clk_hw *hw)\n{\n\tstruct ccu_phase *phase = hw_to_ccu_phase(hw);\n\tstruct clk_hw *parent, *grandparent;\n\tunsigned int parent_rate, grandparent_rate;\n\tu16 step, parent_div;\n\tu32 reg;\n\tu8 delay;\n\n\treg = readl(phase->common.base + phase->common.reg);\n\tdelay = (reg >> phase->shift);\n\tdelay &= (1 << phase->width) - 1;\n\n\tif (!delay)\n\t\treturn 180;\n\n\t \n\tparent = clk_hw_get_parent(hw);\n\tif (!parent)\n\t\treturn -EINVAL;\n\n\t \n\tparent_rate = clk_hw_get_rate(parent);\n\tif (!parent_rate)\n\t\treturn -EINVAL;\n\n\t \n\tgrandparent = clk_hw_get_parent(parent);\n\tif (!grandparent)\n\t\treturn -EINVAL;\n\n\t \n\tgrandparent_rate = clk_hw_get_rate(grandparent);\n\tif (!grandparent_rate)\n\t\treturn -EINVAL;\n\n\t \n\tparent_div = grandparent_rate / parent_rate;\n\n\tstep = DIV_ROUND_CLOSEST(360, parent_div);\n\treturn delay * step;\n}\n\nstatic int ccu_phase_set_phase(struct clk_hw *hw, int degrees)\n{\n\tstruct ccu_phase *phase = hw_to_ccu_phase(hw);\n\tstruct clk_hw *parent, *grandparent;\n\tunsigned int parent_rate, grandparent_rate;\n\tunsigned long flags;\n\tu32 reg;\n\tu8 delay;\n\n\t \n\tparent = clk_hw_get_parent(hw);\n\tif (!parent)\n\t\treturn -EINVAL;\n\n\t \n\tparent_rate = clk_hw_get_rate(parent);\n\tif (!parent_rate)\n\t\treturn -EINVAL;\n\n\t \n\tgrandparent = clk_hw_get_parent(parent);\n\tif (!grandparent)\n\t\treturn -EINVAL;\n\n\t \n\tgrandparent_rate = clk_hw_get_rate(grandparent);\n\tif (!grandparent_rate)\n\t\treturn -EINVAL;\n\n\tif (degrees != 180) {\n\t\tu16 step, parent_div;\n\n\t\t \n\t\tparent_div = grandparent_rate / parent_rate;\n\n\t\t \n\t\tstep = DIV_ROUND_CLOSEST(360, parent_div);\n\t\tdelay = DIV_ROUND_CLOSEST(degrees, step);\n\t} else {\n\t\tdelay = 0;\n\t}\n\n\tspin_lock_irqsave(phase->common.lock, flags);\n\treg = readl(phase->common.base + phase->common.reg);\n\treg &= ~GENMASK(phase->width + phase->shift - 1, phase->shift);\n\twritel(reg | (delay << phase->shift),\n\t       phase->common.base + phase->common.reg);\n\tspin_unlock_irqrestore(phase->common.lock, flags);\n\n\treturn 0;\n}\n\nconst struct clk_ops ccu_phase_ops = {\n\t.get_phase\t= ccu_phase_get_phase,\n\t.set_phase\t= ccu_phase_set_phase,\n};\nEXPORT_SYMBOL_NS_GPL(ccu_phase_ops, SUNXI_CCU);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}