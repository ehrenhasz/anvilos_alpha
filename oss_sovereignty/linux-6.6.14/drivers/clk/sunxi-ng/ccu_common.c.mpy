{
  "module_name": "ccu_common.c",
  "hash_id": "afb2dbd794be54777a01220402599b530ef2e5d634a8280325598af164f492e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi-ng/ccu_common.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"ccu_common.h\"\n#include \"ccu_gate.h\"\n#include \"ccu_reset.h\"\n\nstruct sunxi_ccu {\n\tconst struct sunxi_ccu_desc\t*desc;\n\tspinlock_t\t\t\tlock;\n\tstruct ccu_reset\t\treset;\n};\n\nvoid ccu_helper_wait_for_lock(struct ccu_common *common, u32 lock)\n{\n\tvoid __iomem *addr;\n\tu32 reg;\n\n\tif (!lock)\n\t\treturn;\n\n\tif (common->features & CCU_FEATURE_LOCK_REG)\n\t\taddr = common->base + common->lock_reg;\n\telse\n\t\taddr = common->base + common->reg;\n\n\tWARN_ON(readl_relaxed_poll_timeout(addr, reg, reg & lock, 100, 70000));\n}\nEXPORT_SYMBOL_NS_GPL(ccu_helper_wait_for_lock, SUNXI_CCU);\n\nbool ccu_is_better_rate(struct ccu_common *common,\n\t\t\tunsigned long target_rate,\n\t\t\tunsigned long current_rate,\n\t\t\tunsigned long best_rate)\n{\n\tif (common->features & CCU_FEATURE_CLOSEST_RATE)\n\t\treturn abs(current_rate - target_rate) < abs(best_rate - target_rate);\n\n\treturn current_rate <= target_rate && current_rate > best_rate;\n}\nEXPORT_SYMBOL_NS_GPL(ccu_is_better_rate, SUNXI_CCU);\n\n \nstatic int ccu_pll_notifier_cb(struct notifier_block *nb,\n\t\t\t       unsigned long event, void *data)\n{\n\tstruct ccu_pll_nb *pll = to_ccu_pll_nb(nb);\n\tint ret = 0;\n\n\tif (event != POST_RATE_CHANGE)\n\t\tgoto out;\n\n\tccu_gate_helper_disable(pll->common, pll->enable);\n\n\tret = ccu_gate_helper_enable(pll->common, pll->enable);\n\tif (ret)\n\t\tgoto out;\n\n\tccu_helper_wait_for_lock(pll->common, pll->lock);\n\nout:\n\treturn notifier_from_errno(ret);\n}\n\nint ccu_pll_notifier_register(struct ccu_pll_nb *pll_nb)\n{\n\tpll_nb->clk_nb.notifier_call = ccu_pll_notifier_cb;\n\n\treturn clk_notifier_register(pll_nb->common->hw.clk,\n\t\t\t\t     &pll_nb->clk_nb);\n}\nEXPORT_SYMBOL_NS_GPL(ccu_pll_notifier_register, SUNXI_CCU);\n\nstatic int sunxi_ccu_probe(struct sunxi_ccu *ccu, struct device *dev,\n\t\t\t   struct device_node *node, void __iomem *reg,\n\t\t\t   const struct sunxi_ccu_desc *desc)\n{\n\tstruct ccu_reset *reset;\n\tint i, ret;\n\n\tccu->desc = desc;\n\n\tspin_lock_init(&ccu->lock);\n\n\tfor (i = 0; i < desc->num_ccu_clks; i++) {\n\t\tstruct ccu_common *cclk = desc->ccu_clks[i];\n\n\t\tif (!cclk)\n\t\t\tcontinue;\n\n\t\tcclk->base = reg;\n\t\tcclk->lock = &ccu->lock;\n\t}\n\n\tfor (i = 0; i < desc->hw_clks->num ; i++) {\n\t\tstruct clk_hw *hw = desc->hw_clks->hws[i];\n\t\tconst char *name;\n\n\t\tif (!hw)\n\t\t\tcontinue;\n\n\t\tname = hw->init->name;\n\t\tif (dev)\n\t\t\tret = clk_hw_register(dev, hw);\n\t\telse\n\t\t\tret = of_clk_hw_register(node, hw);\n\t\tif (ret) {\n\t\t\tpr_err(\"Couldn't register clock %d - %s\\n\", i, name);\n\t\t\tgoto err_clk_unreg;\n\t\t}\n\t}\n\n\tret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get,\n\t\t\t\t     desc->hw_clks);\n\tif (ret)\n\t\tgoto err_clk_unreg;\n\n\treset = &ccu->reset;\n\treset->rcdev.of_node = node;\n\treset->rcdev.ops = &ccu_reset_ops;\n\treset->rcdev.owner = dev ? dev->driver->owner : THIS_MODULE;\n\treset->rcdev.nr_resets = desc->num_resets;\n\treset->base = reg;\n\treset->lock = &ccu->lock;\n\treset->reset_map = desc->resets;\n\n\tret = reset_controller_register(&reset->rcdev);\n\tif (ret)\n\t\tgoto err_del_provider;\n\n\treturn 0;\n\nerr_del_provider:\n\tof_clk_del_provider(node);\nerr_clk_unreg:\n\twhile (--i >= 0) {\n\t\tstruct clk_hw *hw = desc->hw_clks->hws[i];\n\n\t\tif (!hw)\n\t\t\tcontinue;\n\t\tclk_hw_unregister(hw);\n\t}\n\treturn ret;\n}\n\nstatic void devm_sunxi_ccu_release(struct device *dev, void *res)\n{\n\tstruct sunxi_ccu *ccu = res;\n\tconst struct sunxi_ccu_desc *desc = ccu->desc;\n\tint i;\n\n\treset_controller_unregister(&ccu->reset.rcdev);\n\tof_clk_del_provider(dev->of_node);\n\n\tfor (i = 0; i < desc->hw_clks->num; i++) {\n\t\tstruct clk_hw *hw = desc->hw_clks->hws[i];\n\n\t\tif (!hw)\n\t\t\tcontinue;\n\t\tclk_hw_unregister(hw);\n\t}\n}\n\nint devm_sunxi_ccu_probe(struct device *dev, void __iomem *reg,\n\t\t\t const struct sunxi_ccu_desc *desc)\n{\n\tstruct sunxi_ccu *ccu;\n\tint ret;\n\n\tccu = devres_alloc(devm_sunxi_ccu_release, sizeof(*ccu), GFP_KERNEL);\n\tif (!ccu)\n\t\treturn -ENOMEM;\n\n\tret = sunxi_ccu_probe(ccu, dev, dev->of_node, reg, desc);\n\tif (ret) {\n\t\tdevres_free(ccu);\n\t\treturn ret;\n\t}\n\n\tdevres_add(dev, ccu);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(devm_sunxi_ccu_probe, SUNXI_CCU);\n\nvoid of_sunxi_ccu_probe(struct device_node *node, void __iomem *reg,\n\t\t\tconst struct sunxi_ccu_desc *desc)\n{\n\tstruct sunxi_ccu *ccu;\n\tint ret;\n\n\tccu = kzalloc(sizeof(*ccu), GFP_KERNEL);\n\tif (!ccu)\n\t\treturn;\n\n\tret = sunxi_ccu_probe(ccu, NULL, node, reg, desc);\n\tif (ret) {\n\t\tpr_err(\"%pOF: probing clocks failed: %d\\n\", node, ret);\n\t\tkfree(ccu);\n\t}\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}