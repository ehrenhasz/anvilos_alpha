{
  "module_name": "kirkwood.c",
  "hash_id": "020a399573f118be61e3214ffb6eeab7b5c2df311d7bb4aea02c03af8c6511e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mvebu/kirkwood.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include \"common.h\"\n\n \n\n#define SAR_KIRKWOOD_CPU_FREQ(x)\t\\\n\t(((x & (1 <<  1)) >>  1) |\t\\\n\t ((x & (1 << 22)) >> 21) |\t\\\n\t ((x & (3 <<  3)) >>  1))\n#define SAR_KIRKWOOD_L2_RATIO(x)\t\\\n\t(((x & (3 <<  9)) >> 9) |\t\\\n\t (((x & (1 << 19)) >> 17)))\n#define SAR_KIRKWOOD_DDR_RATIO\t\t5\n#define SAR_KIRKWOOD_DDR_RATIO_MASK\t0xf\n#define SAR_MV88F6180_CLK\t\t2\n#define SAR_MV88F6180_CLK_MASK\t\t0x7\n#define SAR_KIRKWOOD_TCLK_FREQ\t\t21\n#define SAR_KIRKWOOD_TCLK_FREQ_MASK\t0x1\n\nenum { KIRKWOOD_CPU_TO_L2, KIRKWOOD_CPU_TO_DDR };\n\nstatic const struct coreclk_ratio kirkwood_coreclk_ratios[] __initconst = {\n\t{ .id = KIRKWOOD_CPU_TO_L2, .name = \"l2clk\", },\n\t{ .id = KIRKWOOD_CPU_TO_DDR, .name = \"ddrclk\", }\n};\n\nstatic u32 __init kirkwood_get_tclk_freq(void __iomem *sar)\n{\n\tu32 opt = (readl(sar) >> SAR_KIRKWOOD_TCLK_FREQ) &\n\t\tSAR_KIRKWOOD_TCLK_FREQ_MASK;\n\treturn (opt) ? 166666667 : 200000000;\n}\n\nstatic const u32 kirkwood_cpu_freqs[] __initconst = {\n\t0, 0, 0, 0,\n\t600000000,\n\t0,\n\t800000000,\n\t1000000000,\n\t0,\n\t1200000000,\n\t0, 0,\n\t1500000000,\n\t1600000000,\n\t1800000000,\n\t2000000000\n};\n\nstatic u32 __init kirkwood_get_cpu_freq(void __iomem *sar)\n{\n\tu32 opt = SAR_KIRKWOOD_CPU_FREQ(readl(sar));\n\treturn kirkwood_cpu_freqs[opt];\n}\n\nstatic const int kirkwood_cpu_l2_ratios[8][2] __initconst = {\n\t{ 0, 1 }, { 1, 2 }, { 0, 1 }, { 1, 3 },\n\t{ 0, 1 }, { 1, 4 }, { 0, 1 }, { 0, 1 }\n};\n\nstatic const int kirkwood_cpu_ddr_ratios[16][2] __initconst = {\n\t{ 0, 1 }, { 0, 1 }, { 1, 2 }, { 0, 1 },\n\t{ 1, 3 }, { 0, 1 }, { 1, 4 }, { 2, 9 },\n\t{ 1, 5 }, { 1, 6 }, { 0, 1 }, { 0, 1 },\n\t{ 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }\n};\n\nstatic void __init kirkwood_get_clk_ratio(\n\tvoid __iomem *sar, int id, int *mult, int *div)\n{\n\tswitch (id) {\n\tcase KIRKWOOD_CPU_TO_L2:\n\t{\n\t\tu32 opt = SAR_KIRKWOOD_L2_RATIO(readl(sar));\n\t\t*mult = kirkwood_cpu_l2_ratios[opt][0];\n\t\t*div = kirkwood_cpu_l2_ratios[opt][1];\n\t\tbreak;\n\t}\n\tcase KIRKWOOD_CPU_TO_DDR:\n\t{\n\t\tu32 opt = (readl(sar) >> SAR_KIRKWOOD_DDR_RATIO) &\n\t\t\tSAR_KIRKWOOD_DDR_RATIO_MASK;\n\t\t*mult = kirkwood_cpu_ddr_ratios[opt][0];\n\t\t*div = kirkwood_cpu_ddr_ratios[opt][1];\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic const u32 mv88f6180_cpu_freqs[] __initconst = {\n\t0, 0, 0, 0, 0,\n\t600000000,\n\t800000000,\n\t1000000000\n};\n\nstatic u32 __init mv88f6180_get_cpu_freq(void __iomem *sar)\n{\n\tu32 opt = (readl(sar) >> SAR_MV88F6180_CLK) & SAR_MV88F6180_CLK_MASK;\n\treturn mv88f6180_cpu_freqs[opt];\n}\n\nstatic const int mv88f6180_cpu_ddr_ratios[8][2] __initconst = {\n\t{ 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },\n\t{ 0, 1 }, { 1, 3 }, { 1, 4 }, { 1, 5 }\n};\n\nstatic void __init mv88f6180_get_clk_ratio(\n\tvoid __iomem *sar, int id, int *mult, int *div)\n{\n\tswitch (id) {\n\tcase KIRKWOOD_CPU_TO_L2:\n\t{\n\t\t \n\t\t*mult = 1;\n\t\t*div = 2;\n\t\tbreak;\n\t}\n\tcase KIRKWOOD_CPU_TO_DDR:\n\t{\n\t\tu32 opt = (readl(sar) >> SAR_MV88F6180_CLK) &\n\t\t\tSAR_MV88F6180_CLK_MASK;\n\t\t*mult = mv88f6180_cpu_ddr_ratios[opt][0];\n\t\t*div = mv88f6180_cpu_ddr_ratios[opt][1];\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic u32 __init mv98dx1135_get_tclk_freq(void __iomem *sar)\n{\n\treturn 166666667;\n}\n\nstatic const struct coreclk_soc_desc kirkwood_coreclks = {\n\t.get_tclk_freq = kirkwood_get_tclk_freq,\n\t.get_cpu_freq = kirkwood_get_cpu_freq,\n\t.get_clk_ratio = kirkwood_get_clk_ratio,\n\t.ratios = kirkwood_coreclk_ratios,\n\t.num_ratios = ARRAY_SIZE(kirkwood_coreclk_ratios),\n};\n\nstatic const struct coreclk_soc_desc mv88f6180_coreclks = {\n\t.get_tclk_freq = kirkwood_get_tclk_freq,\n\t.get_cpu_freq = mv88f6180_get_cpu_freq,\n\t.get_clk_ratio = mv88f6180_get_clk_ratio,\n\t.ratios = kirkwood_coreclk_ratios,\n\t.num_ratios = ARRAY_SIZE(kirkwood_coreclk_ratios),\n};\n\nstatic const struct coreclk_soc_desc mv98dx1135_coreclks = {\n\t.get_tclk_freq = mv98dx1135_get_tclk_freq,\n\t.get_cpu_freq = kirkwood_get_cpu_freq,\n\t.get_clk_ratio = kirkwood_get_clk_ratio,\n\t.ratios = kirkwood_coreclk_ratios,\n\t.num_ratios = ARRAY_SIZE(kirkwood_coreclk_ratios),\n};\n\n \n\nstatic const struct clk_gating_soc_desc kirkwood_gating_desc[] __initconst = {\n\t{ \"ge0\", NULL, 0, 0 },\n\t{ \"pex0\", NULL, 2, 0 },\n\t{ \"usb0\", NULL, 3, 0 },\n\t{ \"sdio\", NULL, 4, 0 },\n\t{ \"tsu\", NULL, 5, 0 },\n\t{ \"runit\", NULL, 7, 0 },\n\t{ \"xor0\", NULL, 8, 0 },\n\t{ \"audio\", NULL, 9, 0 },\n\t{ \"sata0\", NULL, 14, 0 },\n\t{ \"sata1\", NULL, 15, 0 },\n\t{ \"xor1\", NULL, 16, 0 },\n\t{ \"crypto\", NULL, 17, 0 },\n\t{ \"pex1\", NULL, 18, 0 },\n\t{ \"ge1\", NULL, 19, 0 },\n\t{ \"tdm\", NULL, 20, 0 },\n\t{ }\n};\n\n\n \n\nstruct clk_muxing_soc_desc {\n\tconst char *name;\n\tconst char **parents;\n\tint num_parents;\n\tint shift;\n\tint width;\n\tunsigned long flags;\n};\n\nstruct clk_muxing_ctrl {\n\tspinlock_t *lock;\n\tstruct clk **muxes;\n\tint num_muxes;\n};\n\nstatic const char *powersave_parents[] = {\n\t\"cpuclk\",\n\t\"ddrclk\",\n};\n\nstatic const struct clk_muxing_soc_desc kirkwood_mux_desc[] __initconst = {\n\t{ \"powersave\", powersave_parents, ARRAY_SIZE(powersave_parents),\n\t\t11, 1, 0 },\n\t{ }\n};\n\nstatic struct clk *clk_muxing_get_src(\n\tstruct of_phandle_args *clkspec, void *data)\n{\n\tstruct clk_muxing_ctrl *ctrl = (struct clk_muxing_ctrl *)data;\n\tint n;\n\n\tif (clkspec->args_count < 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (n = 0; n < ctrl->num_muxes; n++) {\n\t\tstruct clk_mux *mux =\n\t\t\tto_clk_mux(__clk_get_hw(ctrl->muxes[n]));\n\t\tif (clkspec->args[0] == mux->shift)\n\t\t\treturn ctrl->muxes[n];\n\t}\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic void __init kirkwood_clk_muxing_setup(struct device_node *np,\n\t\t\t\t   const struct clk_muxing_soc_desc *desc)\n{\n\tstruct clk_muxing_ctrl *ctrl;\n\tvoid __iomem *base;\n\tint n;\n\n\tbase = of_iomap(np, 0);\n\tif (WARN_ON(!base))\n\t\treturn;\n\n\tctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);\n\tif (WARN_ON(!ctrl))\n\t\tgoto ctrl_out;\n\n\t \n\tctrl->lock = &ctrl_gating_lock;\n\n\t \n\tfor (n = 0; desc[n].name;)\n\t\tn++;\n\n\tctrl->num_muxes = n;\n\tctrl->muxes = kcalloc(ctrl->num_muxes, sizeof(struct clk *),\n\t\t\tGFP_KERNEL);\n\tif (WARN_ON(!ctrl->muxes))\n\t\tgoto muxes_out;\n\n\tfor (n = 0; n < ctrl->num_muxes; n++) {\n\t\tctrl->muxes[n] = clk_register_mux(NULL, desc[n].name,\n\t\t\t\tdesc[n].parents, desc[n].num_parents,\n\t\t\t\tdesc[n].flags, base, desc[n].shift,\n\t\t\t\tdesc[n].width, desc[n].flags, ctrl->lock);\n\t\tWARN_ON(IS_ERR(ctrl->muxes[n]));\n\t}\n\n\tof_clk_add_provider(np, clk_muxing_get_src, ctrl);\n\n\treturn;\nmuxes_out:\n\tkfree(ctrl);\nctrl_out:\n\tiounmap(base);\n}\n\nstatic void __init kirkwood_clk_init(struct device_node *np)\n{\n\tstruct device_node *cgnp =\n\t\tof_find_compatible_node(NULL, NULL, \"marvell,kirkwood-gating-clock\");\n\n\n\tif (of_device_is_compatible(np, \"marvell,mv88f6180-core-clock\"))\n\t\tmvebu_coreclk_setup(np, &mv88f6180_coreclks);\n\telse if (of_device_is_compatible(np, \"marvell,mv98dx1135-core-clock\"))\n\t\tmvebu_coreclk_setup(np, &mv98dx1135_coreclks);\n\telse\n\t\tmvebu_coreclk_setup(np, &kirkwood_coreclks);\n\n\tif (cgnp) {\n\t\tmvebu_clk_gating_setup(cgnp, kirkwood_gating_desc);\n\t\tkirkwood_clk_muxing_setup(cgnp, kirkwood_mux_desc);\n\n\t\tof_node_put(cgnp);\n\t}\n}\nCLK_OF_DECLARE(kirkwood_clk, \"marvell,kirkwood-core-clock\",\n\t       kirkwood_clk_init);\nCLK_OF_DECLARE(mv88f6180_clk, \"marvell,mv88f6180-core-clock\",\n\t       kirkwood_clk_init);\nCLK_OF_DECLARE(98dx1135_clk, \"marvell,mv98dx1135-core-clock\",\n\t       kirkwood_clk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}