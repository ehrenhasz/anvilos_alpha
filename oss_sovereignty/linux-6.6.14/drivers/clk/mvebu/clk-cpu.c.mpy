{
  "module_name": "clk-cpu.c",
  "hash_id": "e144685119e5d1cc53c1183b11f77d98a1d2d0a226deecbfbd1419b5b27721b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mvebu/clk-cpu.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/of_address.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/delay.h>\n#include <linux/mvebu-pmsu.h>\n#include <asm/smp_plat.h>\n\n#define SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET               0x0\n#define   SYS_CTRL_CLK_DIVIDER_CTRL_RESET_ALL          0xff\n#define   SYS_CTRL_CLK_DIVIDER_CTRL_RESET_SHIFT        8\n#define SYS_CTRL_CLK_DIVIDER_CTRL2_OFFSET              0x8\n#define   SYS_CTRL_CLK_DIVIDER_CTRL2_NBCLK_RATIO_SHIFT 16\n#define SYS_CTRL_CLK_DIVIDER_VALUE_OFFSET              0xC\n#define SYS_CTRL_CLK_DIVIDER_MASK                      0x3F\n\n#define PMU_DFS_RATIO_SHIFT 16\n#define PMU_DFS_RATIO_MASK  0x3F\n\n#define MAX_CPU\t    4\nstruct cpu_clk {\n\tstruct clk_hw hw;\n\tint cpu;\n\tconst char *clk_name;\n\tconst char *parent_name;\n\tvoid __iomem *reg_base;\n\tvoid __iomem *pmu_dfs;\n};\n\nstatic struct clk **clks;\n\nstatic struct clk_onecell_data clk_data;\n\n#define to_cpu_clk(p) container_of(p, struct cpu_clk, hw)\n\nstatic unsigned long clk_cpu_recalc_rate(struct clk_hw *hwclk,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct cpu_clk *cpuclk = to_cpu_clk(hwclk);\n\tu32 reg, div;\n\n\treg = readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_VALUE_OFFSET);\n\tdiv = (reg >> (cpuclk->cpu * 8)) & SYS_CTRL_CLK_DIVIDER_MASK;\n\treturn parent_rate / div;\n}\n\nstatic long clk_cpu_round_rate(struct clk_hw *hwclk, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\t \n\tu32 div;\n\n\tdiv = *parent_rate / rate;\n\tif (div == 0)\n\t\tdiv = 1;\n\telse if (div > 3)\n\t\tdiv = 3;\n\n\treturn *parent_rate / div;\n}\n\nstatic int clk_cpu_off_set_rate(struct clk_hw *hwclk, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n\n{\n\tstruct cpu_clk *cpuclk = to_cpu_clk(hwclk);\n\tu32 reg, div;\n\tu32 reload_mask;\n\n\tdiv = parent_rate / rate;\n\treg = (readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_VALUE_OFFSET)\n\t\t& (~(SYS_CTRL_CLK_DIVIDER_MASK << (cpuclk->cpu * 8))))\n\t\t| (div << (cpuclk->cpu * 8));\n\twritel(reg, cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_VALUE_OFFSET);\n\t \n\treload_mask = 1 << (20 + cpuclk->cpu);\n\n\treg = readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET)\n\t    | reload_mask;\n\twritel(reg, cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET);\n\n\t \n\treg = readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET)\n\t    | 1 << 24;\n\twritel(reg, cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET);\n\n\t \n\tudelay(1000);\n\treg &= ~(reload_mask | 1 << 24);\n\twritel(reg, cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET);\n\tudelay(1000);\n\n\treturn 0;\n}\n\nstatic int clk_cpu_on_set_rate(struct clk_hw *hwclk, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tu32 reg;\n\tunsigned long fabric_div, target_div, cur_rate;\n\tstruct cpu_clk *cpuclk = to_cpu_clk(hwclk);\n\n\t \n\tif (!cpuclk->pmu_dfs)\n\t\treturn -ENODEV;\n\n\tcur_rate = clk_hw_get_rate(hwclk);\n\n\treg = readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL2_OFFSET);\n\tfabric_div = (reg >> SYS_CTRL_CLK_DIVIDER_CTRL2_NBCLK_RATIO_SHIFT) &\n\t\tSYS_CTRL_CLK_DIVIDER_MASK;\n\n\t \n\tif (rate == 2 * cur_rate)\n\t\ttarget_div = fabric_div / 2;\n\t \n\telse\n\t\ttarget_div = fabric_div;\n\n\tif (target_div == 0)\n\t\ttarget_div = 1;\n\n\treg = readl(cpuclk->pmu_dfs);\n\treg &= ~(PMU_DFS_RATIO_MASK << PMU_DFS_RATIO_SHIFT);\n\treg |= (target_div << PMU_DFS_RATIO_SHIFT);\n\twritel(reg, cpuclk->pmu_dfs);\n\n\treg = readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET);\n\treg |= (SYS_CTRL_CLK_DIVIDER_CTRL_RESET_ALL <<\n\t\tSYS_CTRL_CLK_DIVIDER_CTRL_RESET_SHIFT);\n\twritel(reg, cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET);\n\n\treturn mvebu_pmsu_dfs_request(cpuclk->cpu);\n}\n\nstatic int clk_cpu_set_rate(struct clk_hw *hwclk, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tif (__clk_is_enabled(hwclk->clk))\n\t\treturn clk_cpu_on_set_rate(hwclk, rate, parent_rate);\n\telse\n\t\treturn clk_cpu_off_set_rate(hwclk, rate, parent_rate);\n}\n\nstatic const struct clk_ops cpu_ops = {\n\t.recalc_rate = clk_cpu_recalc_rate,\n\t.round_rate = clk_cpu_round_rate,\n\t.set_rate = clk_cpu_set_rate,\n};\n\nstatic void __init of_cpu_clk_setup(struct device_node *node)\n{\n\tstruct cpu_clk *cpuclk;\n\tvoid __iomem *clock_complex_base = of_iomap(node, 0);\n\tvoid __iomem *pmu_dfs_base = of_iomap(node, 1);\n\tint ncpus = num_possible_cpus();\n\tint cpu;\n\n\tif (clock_complex_base == NULL) {\n\t\tpr_err(\"%s: clock-complex base register not set\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tif (pmu_dfs_base == NULL)\n\t\tpr_warn(\"%s: pmu-dfs base register not set, dynamic frequency scaling not available\\n\",\n\t\t\t__func__);\n\n\tcpuclk = kcalloc(ncpus, sizeof(*cpuclk), GFP_KERNEL);\n\tif (WARN_ON(!cpuclk))\n\t\tgoto cpuclk_out;\n\n\tclks = kcalloc(ncpus, sizeof(*clks), GFP_KERNEL);\n\tif (WARN_ON(!clks))\n\t\tgoto clks_out;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct clk_init_data init;\n\t\tstruct clk *clk;\n\t\tchar *clk_name = kzalloc(5, GFP_KERNEL);\n\n\t\tif (WARN_ON(!clk_name))\n\t\t\tgoto bail_out;\n\n\t\tsprintf(clk_name, \"cpu%d\", cpu);\n\n\t\tcpuclk[cpu].parent_name = of_clk_get_parent_name(node, 0);\n\t\tcpuclk[cpu].clk_name = clk_name;\n\t\tcpuclk[cpu].cpu = cpu;\n\t\tcpuclk[cpu].reg_base = clock_complex_base;\n\t\tif (pmu_dfs_base)\n\t\t\tcpuclk[cpu].pmu_dfs = pmu_dfs_base + 4 * cpu;\n\t\tcpuclk[cpu].hw.init = &init;\n\n\t\tinit.name = cpuclk[cpu].clk_name;\n\t\tinit.ops = &cpu_ops;\n\t\tinit.flags = 0;\n\t\tinit.parent_names = &cpuclk[cpu].parent_name;\n\t\tinit.num_parents = 1;\n\n\t\tclk = clk_register(NULL, &cpuclk[cpu].hw);\n\t\tif (WARN_ON(IS_ERR(clk)))\n\t\t\tgoto bail_out;\n\t\tclks[cpu] = clk;\n\t}\n\tclk_data.clk_num = MAX_CPU;\n\tclk_data.clks = clks;\n\tof_clk_add_provider(node, of_clk_src_onecell_get, &clk_data);\n\n\treturn;\nbail_out:\n\tkfree(clks);\n\twhile(ncpus--)\n\t\tkfree(cpuclk[ncpus].clk_name);\nclks_out:\n\tkfree(cpuclk);\ncpuclk_out:\n\tiounmap(clock_complex_base);\n}\n\nCLK_OF_DECLARE(armada_xp_cpu_clock, \"marvell,armada-xp-cpu-clock\",\n\t\t\t\t\t of_cpu_clk_setup);\n\nstatic void __init of_mv98dx3236_cpu_clk_setup(struct device_node *node)\n{\n\tof_clk_add_provider(node, of_clk_src_simple_get, NULL);\n}\n\nCLK_OF_DECLARE(mv98dx3236_cpu_clock, \"marvell,mv98dx3236-cpu-clock\",\n\t\t\t\t\t of_mv98dx3236_cpu_clk_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}