{
  "module_name": "armada-37xx-periph.c",
  "hash_id": "394fb8179ff66588e2018d3d79deefb4301fffb6dfde852a8985d406b4512694",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mvebu/armada-37xx-periph.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n\n#define TBG_SEL\t\t0x0\n#define DIV_SEL0\t0x4\n#define DIV_SEL1\t0x8\n#define DIV_SEL2\t0xC\n#define CLK_SEL\t\t0x10\n#define CLK_DIS\t\t0x14\n\n#define  ARMADA_37XX_DVFS_LOAD_1 1\n#define LOAD_LEVEL_NR\t4\n\n#define ARMADA_37XX_NB_L0L1\t0x18\n#define ARMADA_37XX_NB_L2L3\t0x1C\n#define\t\tARMADA_37XX_NB_TBG_DIV_OFF\t13\n#define\t\tARMADA_37XX_NB_TBG_DIV_MASK\t0x7\n#define\t\tARMADA_37XX_NB_CLK_SEL_OFF\t11\n#define\t\tARMADA_37XX_NB_CLK_SEL_MASK\t0x1\n#define\t\tARMADA_37XX_NB_TBG_SEL_OFF\t9\n#define\t\tARMADA_37XX_NB_TBG_SEL_MASK\t0x3\n#define\t\tARMADA_37XX_NB_CONFIG_SHIFT\t16\n#define ARMADA_37XX_NB_DYN_MOD\t0x24\n#define\t\tARMADA_37XX_NB_DFS_EN\t31\n#define ARMADA_37XX_NB_CPU_LOAD\t0x30\n#define\t\tARMADA_37XX_NB_CPU_LOAD_MASK\t0x3\n#define\t\tARMADA_37XX_DVFS_LOAD_0\t\t0\n#define\t\tARMADA_37XX_DVFS_LOAD_1\t\t1\n#define\t\tARMADA_37XX_DVFS_LOAD_2\t\t2\n#define\t\tARMADA_37XX_DVFS_LOAD_3\t\t3\n\nstruct clk_periph_driver_data {\n\tstruct clk_hw_onecell_data *hw_data;\n\tspinlock_t lock;\n\tvoid __iomem *reg;\n\n\t \n\tu32 tbg_sel;\n\tu32 div_sel0;\n\tu32 div_sel1;\n\tu32 div_sel2;\n\tu32 clk_sel;\n\tu32 clk_dis;\n};\n\nstruct clk_double_div {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg1;\n\tu8 shift1;\n\tvoid __iomem *reg2;\n\tu8 shift2;\n};\n\nstruct clk_pm_cpu {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg_mux;\n\tu8 shift_mux;\n\tu32 mask_mux;\n\tvoid __iomem *reg_div;\n\tu8 shift_div;\n\tstruct regmap *nb_pm_base;\n\tunsigned long l1_expiration;\n};\n\n#define to_clk_double_div(_hw) container_of(_hw, struct clk_double_div, hw)\n#define to_clk_pm_cpu(_hw) container_of(_hw, struct clk_pm_cpu, hw)\n\nstruct clk_periph_data {\n\tconst char *name;\n\tconst char * const *parent_names;\n\tint num_parents;\n\tstruct clk_hw *mux_hw;\n\tstruct clk_hw *rate_hw;\n\tstruct clk_hw *gate_hw;\n\tstruct clk_hw *muxrate_hw;\n\tbool is_double_div;\n};\n\nstatic const struct clk_div_table clk_table6[] = {\n\t{ .val = 1, .div = 1, },\n\t{ .val = 2, .div = 2, },\n\t{ .val = 3, .div = 3, },\n\t{ .val = 4, .div = 4, },\n\t{ .val = 5, .div = 5, },\n\t{ .val = 6, .div = 6, },\n\t{ .val = 0, .div = 0, },  \n};\n\nstatic const struct clk_div_table clk_table1[] = {\n\t{ .val = 0, .div = 1, },\n\t{ .val = 1, .div = 2, },\n\t{ .val = 0, .div = 0, },  \n};\n\nstatic const struct clk_div_table clk_table2[] = {\n\t{ .val = 0, .div = 2, },\n\t{ .val = 1, .div = 4, },\n\t{ .val = 0, .div = 0, },  \n};\n\nstatic const struct clk_ops clk_double_div_ops;\nstatic const struct clk_ops clk_pm_cpu_ops;\n\n#define PERIPH_GATE(_name, _bit)\t\t\\\nstruct clk_gate gate_##_name = {\t\t\\\n\t.reg = (void *)CLK_DIS,\t\t\t\\\n\t.bit_idx = _bit,\t\t\t\\\n\t.hw.init = &(struct clk_init_data){\t\\\n\t\t.ops =  &clk_gate_ops,\t\t\\\n\t}\t\t\t\t\t\\\n};\n\n#define PERIPH_MUX(_name, _shift)\t\t\\\nstruct clk_mux mux_##_name = {\t\t\t\\\n\t.reg = (void *)TBG_SEL,\t\t\t\\\n\t.shift = _shift,\t\t\t\\\n\t.mask = 3,\t\t\t\t\\\n\t.hw.init = &(struct clk_init_data){\t\\\n\t\t.ops =  &clk_mux_ro_ops,\t\\\n\t}\t\t\t\t\t\\\n};\n\n#define PERIPH_DOUBLEDIV(_name, _reg1, _reg2, _shift1, _shift2)\t\\\nstruct clk_double_div rate_##_name = {\t\t\\\n\t.reg1 = (void *)_reg1,\t\t\t\\\n\t.reg2 = (void *)_reg2,\t\t\t\\\n\t.shift1 = _shift1,\t\t\t\\\n\t.shift2 = _shift2,\t\t\t\\\n\t.hw.init = &(struct clk_init_data){\t\\\n\t\t.ops =  &clk_double_div_ops,\t\\\n\t}\t\t\t\t\t\\\n};\n\n#define PERIPH_DIV(_name, _reg, _shift, _table)\t\\\nstruct clk_divider rate_##_name = {\t\t\\\n\t.reg = (void *)_reg,\t\t\t\\\n\t.table = _table,\t\t\t\\\n\t.shift = _shift,\t\t\t\\\n\t.hw.init = &(struct clk_init_data){\t\\\n\t\t.ops =  &clk_divider_ro_ops,\t\\\n\t}\t\t\t\t\t\\\n};\n\n#define PERIPH_PM_CPU(_name, _shift1, _reg, _shift2)\t\\\nstruct clk_pm_cpu muxrate_##_name = {\t\t\\\n\t.reg_mux = (void *)TBG_SEL,\t\t\\\n\t.mask_mux = 3,\t\t\t\t\\\n\t.shift_mux = _shift1,\t\t\t\\\n\t.reg_div = (void *)_reg,\t\t\\\n\t.shift_div = _shift2,\t\t\t\\\n\t.hw.init = &(struct clk_init_data){\t\\\n\t\t.ops =  &clk_pm_cpu_ops,\t\\\n\t}\t\t\t\t\t\\\n};\n\n#define PERIPH_CLK_FULL_DD(_name, _bit, _shift, _reg1, _reg2, _shift1, _shift2)\\\nstatic PERIPH_GATE(_name, _bit);\t\t\t    \\\nstatic PERIPH_MUX(_name, _shift);\t\t\t    \\\nstatic PERIPH_DOUBLEDIV(_name, _reg1, _reg2, _shift1, _shift2);\n\n#define PERIPH_CLK_FULL(_name, _bit, _shift, _reg, _shift1, _table)\t\\\nstatic PERIPH_GATE(_name, _bit);\t\t\t    \\\nstatic PERIPH_MUX(_name, _shift);\t\t\t    \\\nstatic PERIPH_DIV(_name, _reg, _shift1, _table);\n\n#define PERIPH_CLK_GATE_DIV(_name, _bit,  _reg, _shift, _table)\t\\\nstatic PERIPH_GATE(_name, _bit);\t\t\t\\\nstatic PERIPH_DIV(_name, _reg, _shift, _table);\n\n#define PERIPH_CLK_MUX_DD(_name, _shift, _reg1, _reg2, _shift1, _shift2)\\\nstatic PERIPH_MUX(_name, _shift);\t\t\t    \\\nstatic PERIPH_DOUBLEDIV(_name, _reg1, _reg2, _shift1, _shift2);\n\n#define REF_CLK_FULL(_name)\t\t\t\t\\\n\t{ .name = #_name,\t\t\t\t\\\n\t  .parent_names = (const char *[]){ \"TBG-A-P\",\t\\\n\t      \"TBG-B-P\", \"TBG-A-S\", \"TBG-B-S\"},\t\t\\\n\t  .num_parents = 4,\t\t\t\t\\\n\t  .mux_hw = &mux_##_name.hw,\t\t\t\\\n\t  .gate_hw = &gate_##_name.hw,\t\t\t\\\n\t  .rate_hw = &rate_##_name.hw,\t\t\t\\\n\t}\n\n#define REF_CLK_FULL_DD(_name)\t\t\t\t\\\n\t{ .name = #_name,\t\t\t\t\\\n\t  .parent_names = (const char *[]){ \"TBG-A-P\",\t\\\n\t      \"TBG-B-P\", \"TBG-A-S\", \"TBG-B-S\"},\t\t\\\n\t  .num_parents = 4,\t\t\t\t\\\n\t  .mux_hw = &mux_##_name.hw,\t\t\t\\\n\t  .gate_hw = &gate_##_name.hw,\t\t\t\\\n\t  .rate_hw = &rate_##_name.hw,\t\t\t\\\n\t  .is_double_div = true,\t\t\t\\\n\t}\n\n#define REF_CLK_GATE(_name, _parent_name)\t\t\t\\\n\t{ .name = #_name,\t\t\t\t\t\\\n\t  .parent_names = (const char *[]){ _parent_name},\t\\\n\t  .num_parents = 1,\t\t\t\t\t\\\n\t  .gate_hw = &gate_##_name.hw,\t\t\t\t\\\n\t}\n\n#define REF_CLK_GATE_DIV(_name, _parent_name)\t\t\t\\\n\t{ .name = #_name,\t\t\t\t\t\\\n\t  .parent_names = (const char *[]){ _parent_name},\t\\\n\t  .num_parents = 1,\t\t\t\t\t\\\n\t  .gate_hw = &gate_##_name.hw,\t\t\t\t\\\n\t  .rate_hw = &rate_##_name.hw,\t\t\t\t\\\n\t}\n\n#define REF_CLK_PM_CPU(_name)\t\t\t\t\\\n\t{ .name = #_name,\t\t\t\t\\\n\t  .parent_names = (const char *[]){ \"TBG-A-P\",\t\\\n\t      \"TBG-B-P\", \"TBG-A-S\", \"TBG-B-S\"},\t\t\\\n\t  .num_parents = 4,\t\t\t\t\\\n\t  .muxrate_hw = &muxrate_##_name.hw,\t\t\\\n\t}\n\n#define REF_CLK_MUX_DD(_name)\t\t\t\t\\\n\t{ .name = #_name,\t\t\t\t\\\n\t  .parent_names = (const char *[]){ \"TBG-A-P\",\t\\\n\t      \"TBG-B-P\", \"TBG-A-S\", \"TBG-B-S\"},\t\t\\\n\t  .num_parents = 4,\t\t\t\t\\\n\t  .mux_hw = &mux_##_name.hw,\t\t\t\\\n\t  .rate_hw = &rate_##_name.hw,\t\t\t\\\n\t  .is_double_div = true,\t\t\t\\\n\t}\n\n \nPERIPH_CLK_FULL_DD(mmc, 2, 0, DIV_SEL2, DIV_SEL2, 16, 13);\nPERIPH_CLK_FULL_DD(sata_host, 3, 2, DIV_SEL2, DIV_SEL2, 10, 7);\nPERIPH_CLK_FULL_DD(sec_at, 6, 4, DIV_SEL1, DIV_SEL1, 3, 0);\nPERIPH_CLK_FULL_DD(sec_dap, 7, 6, DIV_SEL1, DIV_SEL1, 9, 6);\nPERIPH_CLK_FULL_DD(tscem, 8, 8, DIV_SEL1, DIV_SEL1, 15, 12);\nPERIPH_CLK_FULL(tscem_tmx, 10, 10, DIV_SEL1, 18, clk_table6);\nstatic PERIPH_GATE(avs, 11);\nPERIPH_CLK_FULL_DD(pwm, 13, 14, DIV_SEL0, DIV_SEL0, 3, 0);\nPERIPH_CLK_FULL_DD(sqf, 12, 12, DIV_SEL1, DIV_SEL1, 27, 24);\nstatic PERIPH_GATE(i2c_2, 16);\nstatic PERIPH_GATE(i2c_1, 17);\nPERIPH_CLK_GATE_DIV(ddr_phy, 19, DIV_SEL0, 18, clk_table2);\nPERIPH_CLK_FULL_DD(ddr_fclk, 21, 16, DIV_SEL0, DIV_SEL0, 15, 12);\nPERIPH_CLK_FULL(trace, 22, 18, DIV_SEL0, 20, clk_table6);\nPERIPH_CLK_FULL(counter, 23, 20, DIV_SEL0, 23, clk_table6);\nPERIPH_CLK_FULL_DD(eip97, 24, 24, DIV_SEL2, DIV_SEL2, 22, 19);\nstatic PERIPH_PM_CPU(cpu, 22, DIV_SEL0, 28);\n\nstatic struct clk_periph_data data_nb[] = {\n\tREF_CLK_FULL_DD(mmc),\n\tREF_CLK_FULL_DD(sata_host),\n\tREF_CLK_FULL_DD(sec_at),\n\tREF_CLK_FULL_DD(sec_dap),\n\tREF_CLK_FULL_DD(tscem),\n\tREF_CLK_FULL(tscem_tmx),\n\tREF_CLK_GATE(avs, \"xtal\"),\n\tREF_CLK_FULL_DD(sqf),\n\tREF_CLK_FULL_DD(pwm),\n\tREF_CLK_GATE(i2c_2, \"xtal\"),\n\tREF_CLK_GATE(i2c_1, \"xtal\"),\n\tREF_CLK_GATE_DIV(ddr_phy, \"TBG-A-S\"),\n\tREF_CLK_FULL_DD(ddr_fclk),\n\tREF_CLK_FULL(trace),\n\tREF_CLK_FULL(counter),\n\tREF_CLK_FULL_DD(eip97),\n\tREF_CLK_PM_CPU(cpu),\n\t{ },\n};\n\n \nPERIPH_CLK_MUX_DD(gbe_50, 6, DIV_SEL2, DIV_SEL2, 6, 9);\nPERIPH_CLK_MUX_DD(gbe_core, 8, DIV_SEL1, DIV_SEL1, 18, 21);\nPERIPH_CLK_MUX_DD(gbe_125, 10, DIV_SEL1, DIV_SEL1, 6, 9);\nstatic PERIPH_GATE(gbe1_50, 0);\nstatic PERIPH_GATE(gbe0_50, 1);\nstatic PERIPH_GATE(gbe1_125, 2);\nstatic PERIPH_GATE(gbe0_125, 3);\nPERIPH_CLK_GATE_DIV(gbe1_core, 4, DIV_SEL1, 13, clk_table1);\nPERIPH_CLK_GATE_DIV(gbe0_core, 5, DIV_SEL1, 14, clk_table1);\nPERIPH_CLK_GATE_DIV(gbe_bm, 12, DIV_SEL1, 0, clk_table1);\nPERIPH_CLK_FULL_DD(sdio, 11, 14, DIV_SEL0, DIV_SEL0, 3, 6);\nPERIPH_CLK_FULL_DD(usb32_usb2_sys, 16, 16, DIV_SEL0, DIV_SEL0, 9, 12);\nPERIPH_CLK_FULL_DD(usb32_ss_sys, 17, 18, DIV_SEL0, DIV_SEL0, 15, 18);\nstatic PERIPH_GATE(pcie, 14);\n\nstatic struct clk_periph_data data_sb[] = {\n\tREF_CLK_MUX_DD(gbe_50),\n\tREF_CLK_MUX_DD(gbe_core),\n\tREF_CLK_MUX_DD(gbe_125),\n\tREF_CLK_GATE(gbe1_50, \"gbe_50\"),\n\tREF_CLK_GATE(gbe0_50, \"gbe_50\"),\n\tREF_CLK_GATE(gbe1_125, \"gbe_125\"),\n\tREF_CLK_GATE(gbe0_125, \"gbe_125\"),\n\tREF_CLK_GATE_DIV(gbe1_core, \"gbe_core\"),\n\tREF_CLK_GATE_DIV(gbe0_core, \"gbe_core\"),\n\tREF_CLK_GATE_DIV(gbe_bm, \"gbe_core\"),\n\tREF_CLK_FULL_DD(sdio),\n\tREF_CLK_FULL_DD(usb32_usb2_sys),\n\tREF_CLK_FULL_DD(usb32_ss_sys),\n\tREF_CLK_GATE(pcie, \"gbe_core\"),\n\t{ },\n};\n\nstatic unsigned int get_div(void __iomem *reg, int shift)\n{\n\tu32 val;\n\n\tval = (readl(reg) >> shift) & 0x7;\n\tif (val > 6)\n\t\treturn 0;\n\treturn val;\n}\n\nstatic unsigned long clk_double_div_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_double_div *double_div = to_clk_double_div(hw);\n\tunsigned int div;\n\n\tdiv = get_div(double_div->reg1, double_div->shift1);\n\tdiv *= get_div(double_div->reg2, double_div->shift2);\n\n\treturn DIV_ROUND_UP_ULL((u64)parent_rate, div);\n}\n\nstatic const struct clk_ops clk_double_div_ops = {\n\t.recalc_rate = clk_double_div_recalc_rate,\n};\n\nstatic void armada_3700_pm_dvfs_update_regs(unsigned int load_level,\n\t\t\t\t\t    unsigned int *reg,\n\t\t\t\t\t    unsigned int *offset)\n{\n\tif (load_level <= ARMADA_37XX_DVFS_LOAD_1)\n\t\t*reg = ARMADA_37XX_NB_L0L1;\n\telse\n\t\t*reg = ARMADA_37XX_NB_L2L3;\n\n\tif (load_level == ARMADA_37XX_DVFS_LOAD_0 ||\n\t    load_level ==  ARMADA_37XX_DVFS_LOAD_2)\n\t\t*offset += ARMADA_37XX_NB_CONFIG_SHIFT;\n}\n\nstatic bool armada_3700_pm_dvfs_is_enabled(struct regmap *base)\n{\n\tunsigned int val, reg = ARMADA_37XX_NB_DYN_MOD;\n\n\tif (IS_ERR(base))\n\t\treturn false;\n\n\tregmap_read(base, reg, &val);\n\n\treturn !!(val & BIT(ARMADA_37XX_NB_DFS_EN));\n}\n\nstatic unsigned int armada_3700_pm_dvfs_get_cpu_div(struct regmap *base)\n{\n\tunsigned int reg = ARMADA_37XX_NB_CPU_LOAD;\n\tunsigned int offset = ARMADA_37XX_NB_TBG_DIV_OFF;\n\tunsigned int load_level, div;\n\n\t \n\tregmap_read(base, reg, &load_level);\n\n\t \n\tload_level &= ARMADA_37XX_NB_CPU_LOAD_MASK;\n\tarmada_3700_pm_dvfs_update_regs(load_level, &reg, &offset);\n\n\tregmap_read(base, reg, &div);\n\n\treturn (div >> offset) & ARMADA_37XX_NB_TBG_DIV_MASK;\n}\n\nstatic unsigned int armada_3700_pm_dvfs_get_cpu_parent(struct regmap *base)\n{\n\tunsigned int reg = ARMADA_37XX_NB_CPU_LOAD;\n\tunsigned int offset = ARMADA_37XX_NB_TBG_SEL_OFF;\n\tunsigned int load_level, sel;\n\n\t \n\tregmap_read(base, reg, &load_level);\n\n\t \n\tload_level &= ARMADA_37XX_NB_CPU_LOAD_MASK;\n\tarmada_3700_pm_dvfs_update_regs(load_level, &reg, &offset);\n\n\tregmap_read(base, reg, &sel);\n\n\treturn (sel >> offset) & ARMADA_37XX_NB_TBG_SEL_MASK;\n}\n\nstatic u8 clk_pm_cpu_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_pm_cpu *pm_cpu = to_clk_pm_cpu(hw);\n\tu32 val;\n\n\tif (armada_3700_pm_dvfs_is_enabled(pm_cpu->nb_pm_base)) {\n\t\tval = armada_3700_pm_dvfs_get_cpu_parent(pm_cpu->nb_pm_base);\n\t} else {\n\t\tval = readl(pm_cpu->reg_mux) >> pm_cpu->shift_mux;\n\t\tval &= pm_cpu->mask_mux;\n\t}\n\n\treturn val;\n}\n\nstatic unsigned long clk_pm_cpu_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_pm_cpu *pm_cpu = to_clk_pm_cpu(hw);\n\tunsigned int div;\n\n\tif (armada_3700_pm_dvfs_is_enabled(pm_cpu->nb_pm_base))\n\t\tdiv = armada_3700_pm_dvfs_get_cpu_div(pm_cpu->nb_pm_base);\n\telse\n\t\tdiv = get_div(pm_cpu->reg_div, pm_cpu->shift_div);\n\treturn DIV_ROUND_UP_ULL((u64)parent_rate, div);\n}\n\nstatic long clk_pm_cpu_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long *parent_rate)\n{\n\tstruct clk_pm_cpu *pm_cpu = to_clk_pm_cpu(hw);\n\tstruct regmap *base = pm_cpu->nb_pm_base;\n\tunsigned int div = *parent_rate / rate;\n\tunsigned int load_level;\n\t \n\tif (!armada_3700_pm_dvfs_is_enabled(base))\n\t\treturn -EINVAL;\n\n\tfor (load_level = 0; load_level < LOAD_LEVEL_NR; load_level++) {\n\t\tunsigned int reg, val, offset = ARMADA_37XX_NB_TBG_DIV_OFF;\n\n\t\tarmada_3700_pm_dvfs_update_regs(load_level, &reg, &offset);\n\n\t\tregmap_read(base, reg, &val);\n\n\t\tval >>= offset;\n\t\tval &= ARMADA_37XX_NB_TBG_DIV_MASK;\n\t\tif (val == div)\n\t\t\t \n\t\t\treturn *parent_rate / div;\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\n \nstatic void clk_pm_cpu_set_rate_wa(struct clk_pm_cpu *pm_cpu,\n\t\t\t\t   unsigned int new_level, unsigned long rate,\n\t\t\t\t   struct regmap *base)\n{\n\tunsigned int cur_level;\n\n\tregmap_read(base, ARMADA_37XX_NB_CPU_LOAD, &cur_level);\n\tcur_level &= ARMADA_37XX_NB_CPU_LOAD_MASK;\n\n\tif (cur_level == new_level)\n\t\treturn;\n\n\t \n\tif (new_level == ARMADA_37XX_DVFS_LOAD_1) {\n\t\tif (cur_level == ARMADA_37XX_DVFS_LOAD_0)\n\t\t\tpm_cpu->l1_expiration = jiffies;\n\t\telse\n\t\t\tpm_cpu->l1_expiration = jiffies + msecs_to_jiffies(20);\n\t\treturn;\n\t}\n\n\t \n\tif (rate < 1000*1000*1000)\n\t\tgoto invalidate_l1_exp;\n\n\t \n\tif (pm_cpu->l1_expiration && time_is_before_eq_jiffies(pm_cpu->l1_expiration))\n\t\tgoto invalidate_l1_exp;\n\n\tregmap_update_bits(base, ARMADA_37XX_NB_CPU_LOAD,\n\t\t\t   ARMADA_37XX_NB_CPU_LOAD_MASK,\n\t\t\t   ARMADA_37XX_DVFS_LOAD_1);\n\tmsleep(20);\n\ninvalidate_l1_exp:\n\tpm_cpu->l1_expiration = 0;\n}\n\nstatic int clk_pm_cpu_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct clk_pm_cpu *pm_cpu = to_clk_pm_cpu(hw);\n\tstruct regmap *base = pm_cpu->nb_pm_base;\n\tunsigned int div = parent_rate / rate;\n\tunsigned int load_level;\n\n\t \n\tif (!armada_3700_pm_dvfs_is_enabled(base))\n\t\treturn -EINVAL;\n\n\tfor (load_level = 0; load_level < LOAD_LEVEL_NR; load_level++) {\n\t\tunsigned int reg, mask, val,\n\t\t\toffset = ARMADA_37XX_NB_TBG_DIV_OFF;\n\n\t\tarmada_3700_pm_dvfs_update_regs(load_level, &reg, &offset);\n\n\t\tregmap_read(base, reg, &val);\n\t\tval >>= offset;\n\t\tval &= ARMADA_37XX_NB_TBG_DIV_MASK;\n\n\t\tif (val == div) {\n\t\t\t \n\t\t\treg = ARMADA_37XX_NB_CPU_LOAD;\n\t\t\tmask = ARMADA_37XX_NB_CPU_LOAD_MASK;\n\n\t\t\t \n\t\t\tif (parent_rate >= 1000*1000*1000)\n\t\t\t\tclk_pm_cpu_set_rate_wa(pm_cpu, load_level, rate, base);\n\n\t\t\tregmap_update_bits(base, reg, mask, load_level);\n\n\t\t\treturn rate;\n\t\t}\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\nstatic const struct clk_ops clk_pm_cpu_ops = {\n\t.get_parent = clk_pm_cpu_get_parent,\n\t.round_rate = clk_pm_cpu_round_rate,\n\t.set_rate = clk_pm_cpu_set_rate,\n\t.recalc_rate = clk_pm_cpu_recalc_rate,\n};\n\nstatic const struct of_device_id armada_3700_periph_clock_of_match[] = {\n\t{ .compatible = \"marvell,armada-3700-periph-clock-nb\",\n\t  .data = data_nb, },\n\t{ .compatible = \"marvell,armada-3700-periph-clock-sb\",\n\t.data = data_sb, },\n\t{ }\n};\n\nstatic int armada_3700_add_composite_clk(const struct clk_periph_data *data,\n\t\t\t\t\t void __iomem *reg, spinlock_t *lock,\n\t\t\t\t\t struct device *dev, struct clk_hw **hw)\n{\n\tconst struct clk_ops *mux_ops = NULL, *gate_ops = NULL,\n\t\t*rate_ops = NULL;\n\tstruct clk_hw *mux_hw = NULL, *gate_hw = NULL, *rate_hw = NULL;\n\n\tif (data->mux_hw) {\n\t\tstruct clk_mux *mux;\n\n\t\tmux_hw = data->mux_hw;\n\t\tmux = to_clk_mux(mux_hw);\n\t\tmux->lock = lock;\n\t\tmux_ops = mux_hw->init->ops;\n\t\tmux->reg = reg + (u64)mux->reg;\n\t}\n\n\tif (data->gate_hw) {\n\t\tstruct clk_gate *gate;\n\n\t\tgate_hw = data->gate_hw;\n\t\tgate = to_clk_gate(gate_hw);\n\t\tgate->lock = lock;\n\t\tgate_ops = gate_hw->init->ops;\n\t\tgate->reg = reg + (u64)gate->reg;\n\t\tgate->flags = CLK_GATE_SET_TO_DISABLE;\n\t}\n\n\tif (data->rate_hw) {\n\t\trate_hw = data->rate_hw;\n\t\trate_ops = rate_hw->init->ops;\n\t\tif (data->is_double_div) {\n\t\t\tstruct clk_double_div *rate;\n\n\t\t\trate =  to_clk_double_div(rate_hw);\n\t\t\trate->reg1 = reg + (u64)rate->reg1;\n\t\t\trate->reg2 = reg + (u64)rate->reg2;\n\t\t} else {\n\t\t\tstruct clk_divider *rate = to_clk_divider(rate_hw);\n\t\t\tconst struct clk_div_table *clkt;\n\t\t\tint table_size = 0;\n\n\t\t\trate->reg = reg + (u64)rate->reg;\n\t\t\tfor (clkt = rate->table; clkt->div; clkt++)\n\t\t\t\ttable_size++;\n\t\t\trate->width = order_base_2(table_size);\n\t\t\trate->lock = lock;\n\t\t}\n\t}\n\n\tif (data->muxrate_hw) {\n\t\tstruct clk_pm_cpu *pmcpu_clk;\n\t\tstruct clk_hw *muxrate_hw = data->muxrate_hw;\n\t\tstruct regmap *map;\n\n\t\tpmcpu_clk =  to_clk_pm_cpu(muxrate_hw);\n\t\tpmcpu_clk->reg_mux = reg + (u64)pmcpu_clk->reg_mux;\n\t\tpmcpu_clk->reg_div = reg + (u64)pmcpu_clk->reg_div;\n\n\t\tmux_hw = muxrate_hw;\n\t\trate_hw = muxrate_hw;\n\t\tmux_ops = muxrate_hw->init->ops;\n\t\trate_ops = muxrate_hw->init->ops;\n\n\t\tmap = syscon_regmap_lookup_by_compatible(\n\t\t\t\t\"marvell,armada-3700-nb-pm\");\n\t\tpmcpu_clk->nb_pm_base = map;\n\t}\n\n\t*hw = clk_hw_register_composite(dev, data->name, data->parent_names,\n\t\t\t\t\tdata->num_parents, mux_hw,\n\t\t\t\t\tmux_ops, rate_hw, rate_ops,\n\t\t\t\t\tgate_hw, gate_ops, CLK_IGNORE_UNUSED);\n\n\treturn PTR_ERR_OR_ZERO(*hw);\n}\n\nstatic int __maybe_unused armada_3700_periph_clock_suspend(struct device *dev)\n{\n\tstruct clk_periph_driver_data *data = dev_get_drvdata(dev);\n\n\tdata->tbg_sel = readl(data->reg + TBG_SEL);\n\tdata->div_sel0 = readl(data->reg + DIV_SEL0);\n\tdata->div_sel1 = readl(data->reg + DIV_SEL1);\n\tdata->div_sel2 = readl(data->reg + DIV_SEL2);\n\tdata->clk_sel = readl(data->reg + CLK_SEL);\n\tdata->clk_dis = readl(data->reg + CLK_DIS);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused armada_3700_periph_clock_resume(struct device *dev)\n{\n\tstruct clk_periph_driver_data *data = dev_get_drvdata(dev);\n\n\t \n\twritel(data->clk_dis, data->reg + CLK_DIS);\n\twritel(data->div_sel0, data->reg + DIV_SEL0);\n\twritel(data->div_sel1, data->reg + DIV_SEL1);\n\twritel(data->div_sel2, data->reg + DIV_SEL2);\n\twritel(data->tbg_sel, data->reg + TBG_SEL);\n\twritel(data->clk_sel, data->reg + CLK_SEL);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops armada_3700_periph_clock_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(armada_3700_periph_clock_suspend,\n\t\t\t\t      armada_3700_periph_clock_resume)\n};\n\nstatic int armada_3700_periph_clock_probe(struct platform_device *pdev)\n{\n\tstruct clk_periph_driver_data *driver_data;\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct clk_periph_data *data;\n\tstruct device *dev = &pdev->dev;\n\tint num_periph = 0, i, ret;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\twhile (data[num_periph].name)\n\t\tnum_periph++;\n\n\tdriver_data = devm_kzalloc(dev, sizeof(*driver_data), GFP_KERNEL);\n\tif (!driver_data)\n\t\treturn -ENOMEM;\n\n\tdriver_data->hw_data = devm_kzalloc(dev,\n\t\t\t\t\t    struct_size(driver_data->hw_data,\n\t\t\t\t\t\t\thws, num_periph),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!driver_data->hw_data)\n\t\treturn -ENOMEM;\n\tdriver_data->hw_data->num = num_periph;\n\n\tdriver_data->reg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(driver_data->reg))\n\t\treturn PTR_ERR(driver_data->reg);\n\n\tspin_lock_init(&driver_data->lock);\n\n\tfor (i = 0; i < num_periph; i++) {\n\t\tstruct clk_hw **hw = &driver_data->hw_data->hws[i];\n\t\tif (armada_3700_add_composite_clk(&data[i], driver_data->reg,\n\t\t\t\t\t\t  &driver_data->lock, dev, hw))\n\t\t\tdev_err(dev, \"Can't register periph clock %s\\n\",\n\t\t\t\tdata[i].name);\n\t}\n\n\tret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get,\n\t\t\t\t     driver_data->hw_data);\n\tif (ret) {\n\t\tfor (i = 0; i < num_periph; i++)\n\t\t\tclk_hw_unregister(driver_data->hw_data->hws[i]);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, driver_data);\n\treturn 0;\n}\n\nstatic void armada_3700_periph_clock_remove(struct platform_device *pdev)\n{\n\tstruct clk_periph_driver_data *data = platform_get_drvdata(pdev);\n\tstruct clk_hw_onecell_data *hw_data = data->hw_data;\n\tint i;\n\n\tof_clk_del_provider(pdev->dev.of_node);\n\n\tfor (i = 0; i < hw_data->num; i++)\n\t\tclk_hw_unregister(hw_data->hws[i]);\n}\n\nstatic struct platform_driver armada_3700_periph_clock_driver = {\n\t.probe = armada_3700_periph_clock_probe,\n\t.remove_new = armada_3700_periph_clock_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"marvell-armada-3700-periph-clock\",\n\t\t.of_match_table = armada_3700_periph_clock_of_match,\n\t\t.pm\t= &armada_3700_periph_clock_pm_ops,\n\t},\n};\n\nbuiltin_platform_driver(armada_3700_periph_clock_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}