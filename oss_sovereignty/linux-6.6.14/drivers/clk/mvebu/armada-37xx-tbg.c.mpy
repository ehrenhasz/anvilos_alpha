{
  "module_name": "armada-37xx-tbg.c",
  "hash_id": "48dcbf649b3a61846bdfc407c47dcd9d160fc9844bf5c0c15698cdede2c72f95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mvebu/armada-37xx-tbg.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define NUM_TBG\t    4\n\n#define TBG_CTRL0\t\t0x4\n#define TBG_CTRL1\t\t0x8\n#define TBG_CTRL7\t\t0x20\n#define TBG_CTRL8\t\t0x30\n\n#define TBG_DIV_MASK\t\t0x1FF\n\n#define TBG_A_REFDIV\t\t0\n#define TBG_B_REFDIV\t\t16\n\n#define TBG_A_FBDIV\t\t2\n#define TBG_B_FBDIV\t\t18\n\n#define TBG_A_VCODIV_SE\t\t0\n#define TBG_B_VCODIV_SE\t\t16\n\n#define TBG_A_VCODIV_DIFF\t1\n#define TBG_B_VCODIV_DIFF\t17\n\nstruct tbg_def {\n\tchar *name;\n\tu32 refdiv_offset;\n\tu32 fbdiv_offset;\n\tu32 vcodiv_reg;\n\tu32 vcodiv_offset;\n};\n\nstatic const struct tbg_def tbg[NUM_TBG] = {\n\t{\"TBG-A-P\", TBG_A_REFDIV, TBG_A_FBDIV, TBG_CTRL8, TBG_A_VCODIV_DIFF},\n\t{\"TBG-B-P\", TBG_B_REFDIV, TBG_B_FBDIV, TBG_CTRL8, TBG_B_VCODIV_DIFF},\n\t{\"TBG-A-S\", TBG_A_REFDIV, TBG_A_FBDIV, TBG_CTRL1, TBG_A_VCODIV_SE},\n\t{\"TBG-B-S\", TBG_B_REFDIV, TBG_B_FBDIV, TBG_CTRL1, TBG_B_VCODIV_SE},\n};\n\nstatic unsigned int tbg_get_mult(void __iomem *reg, const struct tbg_def *ptbg)\n{\n\tu32 val;\n\n\tval = readl(reg + TBG_CTRL0);\n\n\treturn ((val >> ptbg->fbdiv_offset) & TBG_DIV_MASK) << 2;\n}\n\nstatic unsigned int tbg_get_div(void __iomem *reg, const struct tbg_def *ptbg)\n{\n\tu32 val;\n\tunsigned int div;\n\n\tval = readl(reg + TBG_CTRL7);\n\n\tdiv = (val >> ptbg->refdiv_offset) & TBG_DIV_MASK;\n\tif (div == 0)\n\t\tdiv = 1;\n\tval = readl(reg + ptbg->vcodiv_reg);\n\n\tdiv *= 1 << ((val >>  ptbg->vcodiv_offset) & TBG_DIV_MASK);\n\n\treturn div;\n}\n\n\nstatic int armada_3700_tbg_clock_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct clk_hw_onecell_data *hw_tbg_data;\n\tstruct device *dev = &pdev->dev;\n\tconst char *parent_name;\n\tstruct clk *parent;\n\tvoid __iomem *reg;\n\tint i;\n\n\thw_tbg_data = devm_kzalloc(&pdev->dev,\n\t\t\t\t   struct_size(hw_tbg_data, hws, NUM_TBG),\n\t\t\t\t   GFP_KERNEL);\n\tif (!hw_tbg_data)\n\t\treturn -ENOMEM;\n\thw_tbg_data->num = NUM_TBG;\n\tplatform_set_drvdata(pdev, hw_tbg_data);\n\n\tparent = clk_get(dev, NULL);\n\tif (IS_ERR(parent)) {\n\t\tdev_err(dev, \"Could get the clock parent\\n\");\n\t\treturn -EINVAL;\n\t}\n\tparent_name = __clk_get_name(parent);\n\tclk_put(parent);\n\n\treg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tfor (i = 0; i < NUM_TBG; i++) {\n\t\tconst char *name;\n\t\tunsigned int mult, div;\n\n\t\tname = tbg[i].name;\n\t\tmult = tbg_get_mult(reg, &tbg[i]);\n\t\tdiv = tbg_get_div(reg, &tbg[i]);\n\t\thw_tbg_data->hws[i] = clk_hw_register_fixed_factor(NULL, name,\n\t\t\t\t\t\tparent_name, 0, mult, div);\n\t\tif (IS_ERR(hw_tbg_data->hws[i]))\n\t\t\tdev_err(dev, \"Can't register TBG clock %s\\n\", name);\n\t}\n\n\treturn of_clk_add_hw_provider(np, of_clk_hw_onecell_get, hw_tbg_data);\n}\n\nstatic void armada_3700_tbg_clock_remove(struct platform_device *pdev)\n{\n\tint i;\n\tstruct clk_hw_onecell_data *hw_tbg_data = platform_get_drvdata(pdev);\n\n\tof_clk_del_provider(pdev->dev.of_node);\n\tfor (i = 0; i < hw_tbg_data->num; i++)\n\t\tclk_hw_unregister_fixed_factor(hw_tbg_data->hws[i]);\n}\n\nstatic const struct of_device_id armada_3700_tbg_clock_of_match[] = {\n\t{ .compatible = \"marvell,armada-3700-tbg-clock\", },\n\t{ }\n};\n\nstatic struct platform_driver armada_3700_tbg_clock_driver = {\n\t.probe = armada_3700_tbg_clock_probe,\n\t.remove_new = armada_3700_tbg_clock_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"marvell-armada-3700-tbg-clock\",\n\t\t.of_match_table = armada_3700_tbg_clock_of_match,\n\t},\n};\n\nbuiltin_platform_driver(armada_3700_tbg_clock_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}