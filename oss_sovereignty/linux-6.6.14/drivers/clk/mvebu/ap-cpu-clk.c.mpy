{
  "module_name": "ap-cpu-clk.c",
  "hash_id": "857aa49de140474a7ca90cd451d7b4982c0e3e8fa6f75fdc395f6e35ed040544",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mvebu/ap-cpu-clk.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ap-cpu-clk: \" fmt\n\n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include \"armada_ap_cp_helper.h\"\n\n#define AP806_CPU_CLUSTER0\t\t0\n#define AP806_CPU_CLUSTER1\t\t1\n#define AP806_CPUS_PER_CLUSTER\t\t2\n#define APN806_CPU1_MASK\t\t0x1\n\n#define APN806_CLUSTER_NUM_OFFSET\t8\n#define APN806_CLUSTER_NUM_MASK\t\tBIT(APN806_CLUSTER_NUM_OFFSET)\n\n#define APN806_MAX_DIVIDER\t\t32\n\n \nstruct cpu_dfs_regs {\n\tunsigned int divider_reg;\n\tunsigned int force_reg;\n\tunsigned int ratio_reg;\n\tunsigned int ratio_state_reg;\n\tunsigned int divider_mask;\n\tunsigned int cluster_offset;\n\tunsigned int force_mask;\n\tint divider_offset;\n\tint divider_ratio;\n\tint ratio_offset;\n\tint ratio_state_offset;\n\tint ratio_state_cluster_offset;\n};\n\n \n#define AP806_CA72MP2_0_PLL_CR_0_REG_OFFSET\t\t0x278\n#define AP806_CA72MP2_0_PLL_CR_1_REG_OFFSET\t\t0x280\n#define AP806_CA72MP2_0_PLL_CR_2_REG_OFFSET\t\t0x284\n#define AP806_CA72MP2_0_PLL_SR_REG_OFFSET\t\t0xC94\n\n#define AP806_CA72MP2_0_PLL_CR_CLUSTER_OFFSET\t\t0x14\n#define AP806_PLL_CR_0_CPU_CLK_DIV_RATIO_OFFSET\t\t0\n#define AP806_PLL_CR_CPU_CLK_DIV_RATIO\t\t\t0\n#define AP806_PLL_CR_0_CPU_CLK_DIV_RATIO_MASK \\\n\t\t\t(0x3f << AP806_PLL_CR_0_CPU_CLK_DIV_RATIO_OFFSET)\n#define AP806_PLL_CR_0_CPU_CLK_RELOAD_FORCE_OFFSET\t24\n#define AP806_PLL_CR_0_CPU_CLK_RELOAD_FORCE_MASK \\\n\t\t\t(0x1 << AP806_PLL_CR_0_CPU_CLK_RELOAD_FORCE_OFFSET)\n#define AP806_PLL_CR_0_CPU_CLK_RELOAD_RATIO_OFFSET\t16\n#define AP806_CA72MP2_0_PLL_RATIO_STABLE_OFFSET\t0\n#define AP806_CA72MP2_0_PLL_RATIO_STATE\t\t\t11\n\n#define STATUS_POLL_PERIOD_US\t\t1\n#define STATUS_POLL_TIMEOUT_US\t\t1000000\n\n#define to_ap_cpu_clk(_hw) container_of(_hw, struct ap_cpu_clk, hw)\n\nstatic const struct cpu_dfs_regs ap806_dfs_regs = {\n\t.divider_reg = AP806_CA72MP2_0_PLL_CR_0_REG_OFFSET,\n\t.force_reg = AP806_CA72MP2_0_PLL_CR_1_REG_OFFSET,\n\t.ratio_reg = AP806_CA72MP2_0_PLL_CR_2_REG_OFFSET,\n\t.ratio_state_reg = AP806_CA72MP2_0_PLL_SR_REG_OFFSET,\n\t.divider_mask = AP806_PLL_CR_0_CPU_CLK_DIV_RATIO_MASK,\n\t.cluster_offset = AP806_CA72MP2_0_PLL_CR_CLUSTER_OFFSET,\n\t.force_mask = AP806_PLL_CR_0_CPU_CLK_RELOAD_FORCE_MASK,\n\t.divider_offset = AP806_PLL_CR_0_CPU_CLK_DIV_RATIO_OFFSET,\n\t.divider_ratio = AP806_PLL_CR_CPU_CLK_DIV_RATIO,\n\t.ratio_offset = AP806_PLL_CR_0_CPU_CLK_RELOAD_RATIO_OFFSET,\n\t.ratio_state_offset = AP806_CA72MP2_0_PLL_RATIO_STABLE_OFFSET,\n\t.ratio_state_cluster_offset = AP806_CA72MP2_0_PLL_RATIO_STABLE_OFFSET,\n};\n\n \n#define AP807_DEVICE_GENERAL_CONTROL_10_REG_OFFSET\t\t0x278\n#define AP807_DEVICE_GENERAL_CONTROL_11_REG_OFFSET\t\t0x27c\n#define AP807_DEVICE_GENERAL_STATUS_6_REG_OFFSET\t\t0xc98\n#define AP807_CA72MP2_0_PLL_CR_CLUSTER_OFFSET\t\t\t0x8\n#define AP807_PLL_CR_0_CPU_CLK_DIV_RATIO_OFFSET\t\t\t18\n#define AP807_PLL_CR_0_CPU_CLK_DIV_RATIO_MASK \\\n\t\t(0x3f << AP807_PLL_CR_0_CPU_CLK_DIV_RATIO_OFFSET)\n#define AP807_PLL_CR_1_CPU_CLK_DIV_RATIO_OFFSET\t\t\t12\n#define AP807_PLL_CR_1_CPU_CLK_DIV_RATIO_MASK \\\n\t\t(0x3f << AP807_PLL_CR_1_CPU_CLK_DIV_RATIO_OFFSET)\n#define AP807_PLL_CR_CPU_CLK_DIV_RATIO\t\t\t\t3\n#define AP807_PLL_CR_0_CPU_CLK_RELOAD_FORCE_OFFSET\t\t0\n#define AP807_PLL_CR_0_CPU_CLK_RELOAD_FORCE_MASK \\\n\t\t(0x3 << AP807_PLL_CR_0_CPU_CLK_RELOAD_FORCE_OFFSET)\n#define AP807_PLL_CR_0_CPU_CLK_RELOAD_RATIO_OFFSET\t\t6\n#define\tAP807_CA72MP2_0_PLL_CLKDIV_RATIO_STABLE_OFFSET\t\t20\n#define AP807_CA72MP2_0_PLL_CLKDIV_RATIO_STABLE_CLUSTER_OFFSET\t3\n\nstatic const struct cpu_dfs_regs ap807_dfs_regs = {\n\t.divider_reg = AP807_DEVICE_GENERAL_CONTROL_10_REG_OFFSET,\n\t.force_reg = AP807_DEVICE_GENERAL_CONTROL_11_REG_OFFSET,\n\t.ratio_reg = AP807_DEVICE_GENERAL_CONTROL_11_REG_OFFSET,\n\t.ratio_state_reg = AP807_DEVICE_GENERAL_STATUS_6_REG_OFFSET,\n\t.divider_mask = AP807_PLL_CR_0_CPU_CLK_DIV_RATIO_MASK,\n\t.cluster_offset = AP807_CA72MP2_0_PLL_CR_CLUSTER_OFFSET,\n\t.force_mask = AP807_PLL_CR_0_CPU_CLK_RELOAD_FORCE_MASK,\n\t.divider_offset = AP807_PLL_CR_0_CPU_CLK_DIV_RATIO_OFFSET,\n\t.divider_ratio = AP807_PLL_CR_CPU_CLK_DIV_RATIO,\n\t.ratio_offset = AP807_PLL_CR_0_CPU_CLK_RELOAD_RATIO_OFFSET,\n\t.ratio_state_offset = AP807_CA72MP2_0_PLL_CLKDIV_RATIO_STABLE_OFFSET,\n\t.ratio_state_cluster_offset =\n\t\tAP807_CA72MP2_0_PLL_CLKDIV_RATIO_STABLE_CLUSTER_OFFSET\n};\n\n \nstruct ap_cpu_clk {\n\tunsigned int cluster;\n\tconst char *clk_name;\n\tstruct device *dev;\n\tstruct clk_hw hw;\n\tstruct regmap *pll_cr_base;\n\tconst struct cpu_dfs_regs *pll_regs;\n};\n\nstatic unsigned long ap_cpu_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct ap_cpu_clk *clk = to_ap_cpu_clk(hw);\n\tunsigned int cpu_clkdiv_reg;\n\tint cpu_clkdiv_ratio;\n\n\tcpu_clkdiv_reg = clk->pll_regs->divider_reg +\n\t\t(clk->cluster * clk->pll_regs->cluster_offset);\n\tregmap_read(clk->pll_cr_base, cpu_clkdiv_reg, &cpu_clkdiv_ratio);\n\tcpu_clkdiv_ratio &= clk->pll_regs->divider_mask;\n\tcpu_clkdiv_ratio >>= clk->pll_regs->divider_offset;\n\n\treturn parent_rate / cpu_clkdiv_ratio;\n}\n\nstatic int ap_cpu_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct ap_cpu_clk *clk = to_ap_cpu_clk(hw);\n\tint ret, reg, divider = parent_rate / rate;\n\tunsigned int cpu_clkdiv_reg, cpu_force_reg, cpu_ratio_reg, stable_bit;\n\n\tcpu_clkdiv_reg = clk->pll_regs->divider_reg +\n\t\t(clk->cluster * clk->pll_regs->cluster_offset);\n\tcpu_force_reg = clk->pll_regs->force_reg +\n\t\t(clk->cluster * clk->pll_regs->cluster_offset);\n\tcpu_ratio_reg = clk->pll_regs->ratio_reg +\n\t\t(clk->cluster * clk->pll_regs->cluster_offset);\n\n\tregmap_read(clk->pll_cr_base, cpu_clkdiv_reg, &reg);\n\treg &= ~(clk->pll_regs->divider_mask);\n\treg |= (divider << clk->pll_regs->divider_offset);\n\n\t \n\tif (clk->pll_regs->divider_ratio) {\n\t\treg &= ~(AP807_PLL_CR_1_CPU_CLK_DIV_RATIO_MASK);\n\t\treg |= ((divider * clk->pll_regs->divider_ratio) <<\n\t\t\t\tAP807_PLL_CR_1_CPU_CLK_DIV_RATIO_OFFSET);\n\t}\n\tregmap_write(clk->pll_cr_base, cpu_clkdiv_reg, reg);\n\n\n\tregmap_update_bits(clk->pll_cr_base, cpu_force_reg,\n\t\t\t   clk->pll_regs->force_mask,\n\t\t\t   clk->pll_regs->force_mask);\n\n\tregmap_update_bits(clk->pll_cr_base, cpu_ratio_reg,\n\t\t\t   BIT(clk->pll_regs->ratio_offset),\n\t\t\t   BIT(clk->pll_regs->ratio_offset));\n\n\tstable_bit = BIT(clk->pll_regs->ratio_state_offset +\n\t\t\t clk->cluster *\n\t\t\t clk->pll_regs->ratio_state_cluster_offset);\n\tret = regmap_read_poll_timeout(clk->pll_cr_base,\n\t\t\t\t       clk->pll_regs->ratio_state_reg, reg,\n\t\t\t\t       reg & stable_bit, STATUS_POLL_PERIOD_US,\n\t\t\t\t       STATUS_POLL_TIMEOUT_US);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(clk->pll_cr_base, cpu_ratio_reg,\n\t\t\t   BIT(clk->pll_regs->ratio_offset), 0);\n\n\treturn 0;\n}\n\nstatic long ap_cpu_clk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long *parent_rate)\n{\n\tint divider = *parent_rate / rate;\n\n\tdivider = min(divider, APN806_MAX_DIVIDER);\n\n\treturn *parent_rate / divider;\n}\n\nstatic const struct clk_ops ap_cpu_clk_ops = {\n\t.recalc_rate\t= ap_cpu_clk_recalc_rate,\n\t.round_rate\t= ap_cpu_clk_round_rate,\n\t.set_rate\t= ap_cpu_clk_set_rate,\n};\n\nstatic int ap_cpu_clock_probe(struct platform_device *pdev)\n{\n\tint ret, nclusters = 0, cluster_index = 0;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *dn, *np = dev->of_node;\n\tstruct clk_hw_onecell_data *ap_cpu_data;\n\tstruct ap_cpu_clk *ap_cpu_clk;\n\tstruct regmap *regmap;\n\n\tregmap = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(regmap)) {\n\t\tpr_err(\"cannot get pll_cr_base regmap\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\t \n\tnclusters = 1;\n\tfor_each_of_cpu_node(dn) {\n\t\tu64 cpu;\n\n\t\tcpu = of_get_cpu_hwid(dn, 0);\n\t\tif (WARN_ON(cpu == OF_BAD_ADDR)) {\n\t\t\tof_node_put(dn);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (cpu & APN806_CLUSTER_NUM_MASK) {\n\t\t\tnclusters = 2;\n\t\t\tof_node_put(dn);\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tap_cpu_clk = devm_kcalloc(dev, nclusters, sizeof(*ap_cpu_clk),\n\t\t\t\t  GFP_KERNEL);\n\tif (!ap_cpu_clk)\n\t\treturn -ENOMEM;\n\n\tap_cpu_data = devm_kzalloc(dev, struct_size(ap_cpu_data, hws,\n\t\t\t\t\t\t    nclusters),\n\t\t\t\tGFP_KERNEL);\n\tif (!ap_cpu_data)\n\t\treturn -ENOMEM;\n\n\tfor_each_of_cpu_node(dn) {\n\t\tchar *clk_name = \"cpu-cluster-0\";\n\t\tstruct clk_init_data init;\n\t\tconst char *parent_name;\n\t\tstruct clk *parent;\n\t\tu64 cpu;\n\n\t\tcpu = of_get_cpu_hwid(dn, 0);\n\t\tif (WARN_ON(cpu == OF_BAD_ADDR)) {\n\t\t\tof_node_put(dn);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcluster_index = cpu & APN806_CLUSTER_NUM_MASK;\n\t\tcluster_index >>= APN806_CLUSTER_NUM_OFFSET;\n\n\t\t \n\t\tif (ap_cpu_data->hws[cluster_index])\n\t\t\tcontinue;\n\n\t\tparent = of_clk_get(np, cluster_index);\n\t\tif (IS_ERR(parent)) {\n\t\t\tdev_err(dev, \"Could not get the clock parent\\n\");\n\t\t\tof_node_put(dn);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tparent_name =  __clk_get_name(parent);\n\t\tclk_name[12] += cluster_index;\n\t\tap_cpu_clk[cluster_index].clk_name =\n\t\t\tap_cp_unique_name(dev, np->parent, clk_name);\n\t\tap_cpu_clk[cluster_index].cluster = cluster_index;\n\t\tap_cpu_clk[cluster_index].pll_cr_base = regmap;\n\t\tap_cpu_clk[cluster_index].hw.init = &init;\n\t\tap_cpu_clk[cluster_index].dev = dev;\n\t\tap_cpu_clk[cluster_index].pll_regs = of_device_get_match_data(&pdev->dev);\n\n\t\tinit.name = ap_cpu_clk[cluster_index].clk_name;\n\t\tinit.ops = &ap_cpu_clk_ops;\n\t\tinit.num_parents = 1;\n\t\tinit.parent_names = &parent_name;\n\n\t\tret = devm_clk_hw_register(dev, &ap_cpu_clk[cluster_index].hw);\n\t\tif (ret) {\n\t\t\tof_node_put(dn);\n\t\t\treturn ret;\n\t\t}\n\t\tap_cpu_data->hws[cluster_index] = &ap_cpu_clk[cluster_index].hw;\n\t}\n\n\tap_cpu_data->num = cluster_index + 1;\n\n\tret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, ap_cpu_data);\n\tif (ret)\n\t\tdev_err(dev, \"failed to register OF clock provider\\n\");\n\n\treturn ret;\n}\n\nstatic const struct of_device_id ap_cpu_clock_of_match[] = {\n\t{\n\t\t.compatible = \"marvell,ap806-cpu-clock\",\n\t\t.data = &ap806_dfs_regs,\n\t},\n\t{\n\t\t.compatible = \"marvell,ap807-cpu-clock\",\n\t\t.data = &ap807_dfs_regs,\n\t},\n\t{ }\n};\n\nstatic struct platform_driver ap_cpu_clock_driver = {\n\t.probe = ap_cpu_clock_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"marvell-ap-cpu-clock\",\n\t\t.of_match_table = ap_cpu_clock_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(ap_cpu_clock_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}