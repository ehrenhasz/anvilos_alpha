{
  "module_name": "ap806-system-controller.c",
  "hash_id": "91556f5d2fceb1bac12f529444a78ab44ae73bf1fcf4f51037e2e83c5743c8a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mvebu/ap806-system-controller.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ap806-system-controller: \" fmt\n\n#include \"armada_ap_cp_helper.h\"\n#include <linux/clk-provider.h>\n#include <linux/mfd/syscon.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define AP806_SAR_REG\t\t\t0x400\n#define AP806_SAR_CLKFREQ_MODE_MASK\t0x1f\n\n#define AP806_CLK_NUM\t\t\t6\n\nstatic struct clk *ap806_clks[AP806_CLK_NUM];\n\nstatic struct clk_onecell_data ap806_clk_data = {\n\t.clks = ap806_clks,\n\t.clk_num = AP806_CLK_NUM,\n};\n\nstatic int ap806_get_sar_clocks(unsigned int freq_mode,\n\t\t\t\tunsigned int *cpuclk_freq,\n\t\t\t\tunsigned int *dclk_freq)\n{\n\tswitch (freq_mode) {\n\tcase 0x0:\n\t\t*cpuclk_freq = 2000;\n\t\t*dclk_freq = 600;\n\t\tbreak;\n\tcase 0x1:\n\t\t*cpuclk_freq = 2000;\n\t\t*dclk_freq = 525;\n\t\tbreak;\n\tcase 0x6:\n\t\t*cpuclk_freq = 1800;\n\t\t*dclk_freq = 600;\n\t\tbreak;\n\tcase 0x7:\n\t\t*cpuclk_freq = 1800;\n\t\t*dclk_freq = 525;\n\t\tbreak;\n\tcase 0x4:\n\t\t*cpuclk_freq = 1600;\n\t\t*dclk_freq = 400;\n\t\tbreak;\n\tcase 0xB:\n\t\t*cpuclk_freq = 1600;\n\t\t*dclk_freq = 450;\n\t\tbreak;\n\tcase 0xD:\n\t\t*cpuclk_freq = 1600;\n\t\t*dclk_freq = 525;\n\t\tbreak;\n\tcase 0x1a:\n\t\t*cpuclk_freq = 1400;\n\t\t*dclk_freq = 400;\n\t\tbreak;\n\tcase 0x14:\n\t\t*cpuclk_freq = 1300;\n\t\t*dclk_freq = 400;\n\t\tbreak;\n\tcase 0x17:\n\t\t*cpuclk_freq = 1300;\n\t\t*dclk_freq = 325;\n\t\tbreak;\n\tcase 0x19:\n\t\t*cpuclk_freq = 1200;\n\t\t*dclk_freq = 400;\n\t\tbreak;\n\tcase 0x13:\n\t\t*cpuclk_freq = 1000;\n\t\t*dclk_freq = 325;\n\t\tbreak;\n\tcase 0x1d:\n\t\t*cpuclk_freq = 1000;\n\t\t*dclk_freq = 400;\n\t\tbreak;\n\tcase 0x1c:\n\t\t*cpuclk_freq = 800;\n\t\t*dclk_freq = 400;\n\t\tbreak;\n\tcase 0x1b:\n\t\t*cpuclk_freq = 600;\n\t\t*dclk_freq = 400;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ap807_get_sar_clocks(unsigned int freq_mode,\n\t\t\t\tunsigned int *cpuclk_freq,\n\t\t\t\tunsigned int *dclk_freq)\n{\n\tswitch (freq_mode) {\n\tcase 0x0:\n\t\t*cpuclk_freq = 2000;\n\t\t*dclk_freq = 1200;\n\t\tbreak;\n\tcase 0x6:\n\t\t*cpuclk_freq = 2200;\n\t\t*dclk_freq = 1200;\n\t\tbreak;\n\tcase 0xD:\n\t\t*cpuclk_freq = 1600;\n\t\t*dclk_freq = 1200;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ap806_syscon_common_probe(struct platform_device *pdev,\n\t\t\t\t     struct device_node *syscon_node)\n{\n\tunsigned int freq_mode, cpuclk_freq, dclk_freq;\n\tconst char *name, *fixedclk_name;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct regmap *regmap;\n\tu32 reg;\n\tint ret;\n\n\tregmap = syscon_node_to_regmap(syscon_node);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"cannot get regmap\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tret = regmap_read(regmap, AP806_SAR_REG, &reg);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot read from regmap\\n\");\n\t\treturn ret;\n\t}\n\n\tfreq_mode = reg & AP806_SAR_CLKFREQ_MODE_MASK;\n\n\tif (of_device_is_compatible(pdev->dev.of_node,\n\t\t\t\t    \"marvell,ap806-clock\")) {\n\t\tret = ap806_get_sar_clocks(freq_mode, &cpuclk_freq, &dclk_freq);\n\t} else if (of_device_is_compatible(pdev->dev.of_node,\n\t\t\t\t\t   \"marvell,ap807-clock\")) {\n\t\tret = ap807_get_sar_clocks(freq_mode, &cpuclk_freq, &dclk_freq);\n\t} else {\n\t\tdev_err(dev, \"compatible not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret) {\n\t\tdev_err(dev, \"invalid Sample at Reset value\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tcpuclk_freq *= 1000 * 1000;\n\tdclk_freq *= 1000 * 1000;\n\n\t \n\tname = ap_cp_unique_name(dev, syscon_node, \"pll-cluster-0\");\n\tap806_clks[0] = clk_register_fixed_rate(dev, name, NULL,\n\t\t\t\t\t\t0, cpuclk_freq);\n\tif (IS_ERR(ap806_clks[0])) {\n\t\tret = PTR_ERR(ap806_clks[0]);\n\t\tgoto fail0;\n\t}\n\n\tname = ap_cp_unique_name(dev, syscon_node, \"pll-cluster-1\");\n\tap806_clks[1] = clk_register_fixed_rate(dev, name, NULL, 0,\n\t\t\t\t\t\tcpuclk_freq);\n\tif (IS_ERR(ap806_clks[1])) {\n\t\tret = PTR_ERR(ap806_clks[1]);\n\t\tgoto fail1;\n\t}\n\n\t \n\tfixedclk_name = ap_cp_unique_name(dev, syscon_node, \"fixed\");\n\tap806_clks[2] = clk_register_fixed_rate(dev, fixedclk_name, NULL,\n\t\t\t\t\t\t0, 1200 * 1000 * 1000);\n\tif (IS_ERR(ap806_clks[2])) {\n\t\tret = PTR_ERR(ap806_clks[2]);\n\t\tgoto fail2;\n\t}\n\n\t \n\tname = ap_cp_unique_name(dev, syscon_node, \"mss\");\n\tap806_clks[3] = clk_register_fixed_factor(NULL, name, fixedclk_name,\n\t\t\t\t\t\t  0, 1, 6);\n\tif (IS_ERR(ap806_clks[3])) {\n\t\tret = PTR_ERR(ap806_clks[3]);\n\t\tgoto fail3;\n\t}\n\n\t \n\tname = ap_cp_unique_name(dev, syscon_node, \"sdio\");\n\tap806_clks[4] = clk_register_fixed_factor(NULL, name,\n\t\t\t\t\t\t  fixedclk_name,\n\t\t\t\t\t\t  0, 1, 3);\n\tif (IS_ERR(ap806_clks[4])) {\n\t\tret = PTR_ERR(ap806_clks[4]);\n\t\tgoto fail4;\n\t}\n\n\t \n\tname = ap_cp_unique_name(dev, syscon_node, \"ap-dclk\");\n\tap806_clks[5] = clk_register_fixed_rate(dev, name, NULL, 0, dclk_freq);\n\tif (IS_ERR(ap806_clks[5])) {\n\t\tret = PTR_ERR(ap806_clks[5]);\n\t\tgoto fail5;\n\t}\n\n\tret = of_clk_add_provider(np, of_clk_src_onecell_get, &ap806_clk_data);\n\tif (ret)\n\t\tgoto fail_clk_add;\n\n\treturn 0;\n\nfail_clk_add:\n\tclk_unregister_fixed_factor(ap806_clks[5]);\nfail5:\n\tclk_unregister_fixed_factor(ap806_clks[4]);\nfail4:\n\tclk_unregister_fixed_factor(ap806_clks[3]);\nfail3:\n\tclk_unregister_fixed_rate(ap806_clks[2]);\nfail2:\n\tclk_unregister_fixed_rate(ap806_clks[1]);\nfail1:\n\tclk_unregister_fixed_rate(ap806_clks[0]);\nfail0:\n\treturn ret;\n}\n\nstatic int ap806_syscon_legacy_probe(struct platform_device *pdev)\n{\n\tdev_warn(&pdev->dev, FW_WARN \"Using legacy device tree binding\\n\");\n\tdev_warn(&pdev->dev, FW_WARN \"Update your device tree:\\n\");\n\tdev_warn(&pdev->dev, FW_WARN\n\t\t \"This binding won't be supported in future kernel\\n\");\n\n\treturn ap806_syscon_common_probe(pdev, pdev->dev.of_node);\n\n}\n\nstatic int ap806_clock_probe(struct platform_device *pdev)\n{\n\treturn ap806_syscon_common_probe(pdev, pdev->dev.of_node->parent);\n}\n\nstatic const struct of_device_id ap806_syscon_legacy_of_match[] = {\n\t{ .compatible = \"marvell,ap806-system-controller\", },\n\t{ }\n};\n\nstatic struct platform_driver ap806_syscon_legacy_driver = {\n\t.probe = ap806_syscon_legacy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"marvell-ap806-system-controller\",\n\t\t.of_match_table = ap806_syscon_legacy_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(ap806_syscon_legacy_driver);\n\nstatic const struct of_device_id ap806_clock_of_match[] = {\n\t{ .compatible = \"marvell,ap806-clock\", },\n\t{ .compatible = \"marvell,ap807-clock\", },\n\t{ }\n};\n\nstatic struct platform_driver ap806_clock_driver = {\n\t.probe = ap806_clock_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"marvell-ap806-clock\",\n\t\t.of_match_table = ap806_clock_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(ap806_clock_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}