{
  "module_name": "armada-xp.c",
  "hash_id": "b598e93252e916e08f49178413fd7d0f8cc754793546e76ef17f280df7feb00b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mvebu/armada-xp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include \"common.h\"\n\n \n\n#define SARL\t\t\t\t0\t \n#define\t SARL_AXP_PCLK_FREQ_OPT\t\t21\n#define\t SARL_AXP_PCLK_FREQ_OPT_MASK\t0x7\n#define\t SARL_AXP_FAB_FREQ_OPT\t\t24\n#define\t SARL_AXP_FAB_FREQ_OPT_MASK\t0xF\n#define SARH\t\t\t\t4\t \n#define\t SARH_AXP_PCLK_FREQ_OPT\t\t(52-32)\n#define\t SARH_AXP_PCLK_FREQ_OPT_MASK\t0x1\n#define\t SARH_AXP_PCLK_FREQ_OPT_SHIFT\t3\n#define\t SARH_AXP_FAB_FREQ_OPT\t\t(51-32)\n#define\t SARH_AXP_FAB_FREQ_OPT_MASK\t0x1\n#define\t SARH_AXP_FAB_FREQ_OPT_SHIFT\t4\n\nenum { AXP_CPU_TO_NBCLK, AXP_CPU_TO_HCLK, AXP_CPU_TO_DRAMCLK };\n\nstatic const struct coreclk_ratio axp_coreclk_ratios[] __initconst = {\n\t{ .id = AXP_CPU_TO_NBCLK, .name = \"nbclk\" },\n\t{ .id = AXP_CPU_TO_HCLK, .name = \"hclk\" },\n\t{ .id = AXP_CPU_TO_DRAMCLK, .name = \"dramclk\" },\n};\n\n \nstatic u32 __init axp_get_tclk_freq(void __iomem *sar)\n{\n\treturn 250000000;\n}\n\nstatic const u32 axp_cpu_freqs[] __initconst = {\n\t1000000000,\n\t1066000000,\n\t1200000000,\n\t1333000000,\n\t1500000000,\n\t1666000000,\n\t1800000000,\n\t2000000000,\n\t667000000,\n\t0,\n\t800000000,\n\t1600000000,\n};\n\nstatic u32 __init axp_get_cpu_freq(void __iomem *sar)\n{\n\tu32 cpu_freq;\n\tu8 cpu_freq_select = 0;\n\n\tcpu_freq_select = ((readl(sar + SARL) >> SARL_AXP_PCLK_FREQ_OPT) &\n\t\t\t   SARL_AXP_PCLK_FREQ_OPT_MASK);\n\t \n\tcpu_freq_select |= (((readl(sar + SARH) >> SARH_AXP_PCLK_FREQ_OPT) &\n\t     SARH_AXP_PCLK_FREQ_OPT_MASK) << SARH_AXP_PCLK_FREQ_OPT_SHIFT);\n\tif (cpu_freq_select >= ARRAY_SIZE(axp_cpu_freqs)) {\n\t\tpr_err(\"CPU freq select unsupported: %d\\n\", cpu_freq_select);\n\t\tcpu_freq = 0;\n\t} else\n\t\tcpu_freq = axp_cpu_freqs[cpu_freq_select];\n\n\treturn cpu_freq;\n}\n\nstatic const int axp_nbclk_ratios[32][2] __initconst = {\n\t{0, 1}, {1, 2}, {2, 2}, {2, 2},\n\t{1, 2}, {1, 2}, {1, 1}, {2, 3},\n\t{0, 1}, {1, 2}, {2, 4}, {0, 1},\n\t{1, 2}, {0, 1}, {0, 1}, {2, 2},\n\t{0, 1}, {0, 1}, {0, 1}, {1, 1},\n\t{2, 3}, {0, 1}, {0, 1}, {0, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {1, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n};\n\nstatic const int axp_hclk_ratios[32][2] __initconst = {\n\t{0, 1}, {1, 2}, {2, 6}, {2, 3},\n\t{1, 3}, {1, 4}, {1, 2}, {2, 6},\n\t{0, 1}, {1, 6}, {2, 10}, {0, 1},\n\t{1, 4}, {0, 1}, {0, 1}, {2, 5},\n\t{0, 1}, {0, 1}, {0, 1}, {1, 2},\n\t{2, 6}, {0, 1}, {0, 1}, {0, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {1, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n};\n\nstatic const int axp_dramclk_ratios[32][2] __initconst = {\n\t{0, 1}, {1, 2}, {2, 3}, {2, 3},\n\t{1, 3}, {1, 2}, {1, 2}, {2, 6},\n\t{0, 1}, {1, 3}, {2, 5}, {0, 1},\n\t{1, 4}, {0, 1}, {0, 1}, {2, 5},\n\t{0, 1}, {0, 1}, {0, 1}, {1, 1},\n\t{2, 3}, {0, 1}, {0, 1}, {0, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {1, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n};\n\nstatic void __init axp_get_clk_ratio(\n\tvoid __iomem *sar, int id, int *mult, int *div)\n{\n\tu32 opt = ((readl(sar + SARL) >> SARL_AXP_FAB_FREQ_OPT) &\n\t      SARL_AXP_FAB_FREQ_OPT_MASK);\n\t \n\topt |= (((readl(sar + SARH) >> SARH_AXP_FAB_FREQ_OPT) &\n\t\t SARH_AXP_FAB_FREQ_OPT_MASK) << SARH_AXP_FAB_FREQ_OPT_SHIFT);\n\n\tswitch (id) {\n\tcase AXP_CPU_TO_NBCLK:\n\t\t*mult = axp_nbclk_ratios[opt][0];\n\t\t*div = axp_nbclk_ratios[opt][1];\n\t\tbreak;\n\tcase AXP_CPU_TO_HCLK:\n\t\t*mult = axp_hclk_ratios[opt][0];\n\t\t*div = axp_hclk_ratios[opt][1];\n\t\tbreak;\n\tcase AXP_CPU_TO_DRAMCLK:\n\t\t*mult = axp_dramclk_ratios[opt][0];\n\t\t*div = axp_dramclk_ratios[opt][1];\n\t\tbreak;\n\t}\n}\n\nstatic const struct coreclk_soc_desc axp_coreclks = {\n\t.get_tclk_freq = axp_get_tclk_freq,\n\t.get_cpu_freq = axp_get_cpu_freq,\n\t.get_clk_ratio = axp_get_clk_ratio,\n\t.ratios = axp_coreclk_ratios,\n\t.num_ratios = ARRAY_SIZE(axp_coreclk_ratios),\n};\n\n \n\nstatic const struct clk_gating_soc_desc axp_gating_desc[] __initconst = {\n\t{ \"audio\", NULL, 0, 0 },\n\t{ \"ge3\", NULL, 1, 0 },\n\t{ \"ge2\", NULL,  2, 0 },\n\t{ \"ge1\", NULL, 3, 0 },\n\t{ \"ge0\", NULL, 4, 0 },\n\t{ \"pex00\", NULL, 5, 0 },\n\t{ \"pex01\", NULL, 6, 0 },\n\t{ \"pex02\", NULL, 7, 0 },\n\t{ \"pex03\", NULL, 8, 0 },\n\t{ \"pex10\", NULL, 9, 0 },\n\t{ \"pex11\", NULL, 10, 0 },\n\t{ \"pex12\", NULL, 11, 0 },\n\t{ \"pex13\", NULL, 12, 0 },\n\t{ \"bp\", NULL, 13, 0 },\n\t{ \"sata0lnk\", NULL, 14, 0 },\n\t{ \"sata0\", \"sata0lnk\", 15, 0 },\n\t{ \"lcd\", NULL, 16, 0 },\n\t{ \"sdio\", NULL, 17, 0 },\n\t{ \"usb0\", NULL, 18, 0 },\n\t{ \"usb1\", NULL, 19, 0 },\n\t{ \"usb2\", NULL, 20, 0 },\n\t{ \"xor0\", NULL, 22, 0 },\n\t{ \"crypto\", NULL, 23, 0 },\n\t{ \"tdm\", NULL, 25, 0 },\n\t{ \"pex20\", NULL, 26, 0 },\n\t{ \"pex30\", NULL, 27, 0 },\n\t{ \"xor1\", NULL, 28, 0 },\n\t{ \"sata1lnk\", NULL, 29, 0 },\n\t{ \"sata1\", \"sata1lnk\", 30, 0 },\n\t{ }\n};\n\nstatic void __init axp_clk_init(struct device_node *np)\n{\n\tstruct device_node *cgnp =\n\t\tof_find_compatible_node(NULL, NULL, \"marvell,armada-xp-gating-clock\");\n\n\tmvebu_coreclk_setup(np, &axp_coreclks);\n\n\tif (cgnp) {\n\t\tmvebu_clk_gating_setup(cgnp, axp_gating_desc);\n\t\tof_node_put(cgnp);\n\t}\n}\nCLK_OF_DECLARE(axp_clk, \"marvell,armada-xp-core-clock\", axp_clk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}