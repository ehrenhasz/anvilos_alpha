{
  "module_name": "dove-divider.c",
  "hash_id": "084f1558bdb3dda76a6ef60e7e2b1f1599e8dcad4a763eecb0c8ad911fa17e15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mvebu/dove-divider.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n#include \"dove-divider.h\"\n\nstruct dove_clk {\n\tconst char *name;\n\tstruct clk_hw hw;\n\tvoid __iomem *base;\n\tspinlock_t *lock;\n\tu8 div_bit_start;\n\tu8 div_bit_end;\n\tu8 div_bit_load;\n\tu8 div_bit_size;\n\tu32 *divider_table;\n};\n\nenum {\n\tDIV_CTRL0 = 0,\n\tDIV_CTRL1 = 4,\n\tDIV_CTRL1_N_RESET_MASK = BIT(10),\n};\n\n#define to_dove_clk(hw) container_of(hw, struct dove_clk, hw)\n\nstatic void dove_load_divider(void __iomem *base, u32 val, u32 mask, u32 load)\n{\n\tu32 v;\n\n\tv = readl_relaxed(base + DIV_CTRL1) | DIV_CTRL1_N_RESET_MASK;\n\twritel_relaxed(v, base + DIV_CTRL1);\n\n\tv = (readl_relaxed(base + DIV_CTRL0) & ~(mask | load)) | val;\n\twritel_relaxed(v, base + DIV_CTRL0);\n\twritel_relaxed(v | load, base + DIV_CTRL0);\n\tndelay(250);\n\twritel_relaxed(v, base + DIV_CTRL0);\n}\n\nstatic unsigned int dove_get_divider(struct dove_clk *dc)\n{\n\tunsigned int divider;\n\tu32 val;\n\n\tval = readl_relaxed(dc->base + DIV_CTRL0);\n\tval >>= dc->div_bit_start;\n\n\tdivider = val & ~(~0 << dc->div_bit_size);\n\n\tif (dc->divider_table)\n\t\tdivider = dc->divider_table[divider];\n\n\treturn divider;\n}\n\nstatic int dove_calc_divider(const struct dove_clk *dc, unsigned long rate,\n\t\t\t     unsigned long parent_rate, bool set)\n{\n\tunsigned int divider, max;\n\n\tdivider = DIV_ROUND_CLOSEST(parent_rate, rate);\n\n\tif (dc->divider_table) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; dc->divider_table[i]; i++)\n\t\t\tif (divider == dc->divider_table[i]) {\n\t\t\t\tdivider = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!dc->divider_table[i])\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tmax = 1 << dc->div_bit_size;\n\n\t\tif (set && (divider == 0 || divider >= max))\n\t\t\treturn -EINVAL;\n\t\tif (divider >= max)\n\t\t\tdivider = max - 1;\n\t\telse if (divider == 0)\n\t\t\tdivider = 1;\n\t}\n\n\treturn divider;\n}\n\nstatic unsigned long dove_recalc_rate(struct clk_hw *hw, unsigned long parent)\n{\n\tstruct dove_clk *dc = to_dove_clk(hw);\n\tunsigned int divider = dove_get_divider(dc);\n\tunsigned long rate = DIV_ROUND_CLOSEST(parent, divider);\n\n\tpr_debug(\"%s(): %s divider=%u parent=%lu rate=%lu\\n\",\n\t\t __func__, dc->name, divider, parent, rate);\n\n\treturn rate;\n}\n\nstatic long dove_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long *parent)\n{\n\tstruct dove_clk *dc = to_dove_clk(hw);\n\tunsigned long parent_rate = *parent;\n\tint divider;\n\n\tdivider = dove_calc_divider(dc, rate, parent_rate, false);\n\tif (divider < 0)\n\t\treturn divider;\n\n\trate = DIV_ROUND_CLOSEST(parent_rate, divider);\n\n\tpr_debug(\"%s(): %s divider=%u parent=%lu rate=%lu\\n\",\n\t\t __func__, dc->name, divider, parent_rate, rate);\n\n\treturn rate;\n}\n\nstatic int dove_set_clock(struct clk_hw *hw, unsigned long rate,\n\t\t\t  unsigned long parent_rate)\n{\n\tstruct dove_clk *dc = to_dove_clk(hw);\n\tu32 mask, load, div;\n\tint divider;\n\n\tdivider = dove_calc_divider(dc, rate, parent_rate, true);\n\tif (divider < 0)\n\t\treturn divider;\n\n\tpr_debug(\"%s(): %s divider=%u parent=%lu rate=%lu\\n\",\n\t\t __func__, dc->name, divider, parent_rate, rate);\n\n\tdiv = (u32)divider << dc->div_bit_start;\n\tmask = ~(~0 << dc->div_bit_size) << dc->div_bit_start;\n\tload = BIT(dc->div_bit_load);\n\n\tspin_lock(dc->lock);\n\tdove_load_divider(dc->base, div, mask, load);\n\tspin_unlock(dc->lock);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops dove_divider_ops = {\n\t.set_rate\t= dove_set_clock,\n\t.round_rate\t= dove_round_rate,\n\t.recalc_rate\t= dove_recalc_rate,\n};\n\nstatic struct clk *clk_register_dove_divider(struct device *dev,\n\tstruct dove_clk *dc, const char **parent_names, size_t num_parents,\n\tvoid __iomem *base)\n{\n\tchar name[32];\n\tstruct clk_init_data init = {\n\t\t.name = name,\n\t\t.ops = &dove_divider_ops,\n\t\t.parent_names = parent_names,\n\t\t.num_parents = num_parents,\n\t};\n\n\tstrscpy(name, dc->name, sizeof(name));\n\n\tdc->hw.init = &init;\n\tdc->base = base;\n\tdc->div_bit_size = dc->div_bit_end - dc->div_bit_start + 1;\n\n\treturn clk_register(dev, &dc->hw);\n}\n\nstatic DEFINE_SPINLOCK(dove_divider_lock);\n\nstatic u32 axi_divider[] = {-1, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 0};\n\nstatic struct dove_clk dove_hw_clocks[4] = {\n\t{\n\t\t.name = \"axi\",\n\t\t.lock = &dove_divider_lock,\n\t\t.div_bit_start = 1,\n\t\t.div_bit_end = 6,\n\t\t.div_bit_load = 7,\n\t\t.divider_table = axi_divider,\n\t}, {\n\t\t.name = \"gpu\",\n\t\t.lock = &dove_divider_lock,\n\t\t.div_bit_start = 8,\n\t\t.div_bit_end = 13,\n\t\t.div_bit_load = 14,\n\t}, {\n\t\t.name = \"vmeta\",\n\t\t.lock = &dove_divider_lock,\n\t\t.div_bit_start = 15,\n\t\t.div_bit_end = 20,\n\t\t.div_bit_load = 21,\n\t}, {\n\t\t.name = \"lcd\",\n\t\t.lock = &dove_divider_lock,\n\t\t.div_bit_start = 22,\n\t\t.div_bit_end = 27,\n\t\t.div_bit_load = 28,\n\t},\n};\n\nstatic const char *core_pll[] = {\n\t\"core-pll\",\n};\n\nstatic int dove_divider_init(struct device *dev, void __iomem *base,\n\tstruct clk **clks)\n{\n\tstruct clk *clk;\n\tint i;\n\n\t \n\tclk = clk_register_fixed_rate(dev, core_pll[0], NULL, 0, 2000000000UL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tfor (i = 0; i < ARRAY_SIZE(dove_hw_clocks); i++)\n\t\tclks[i] = clk_register_dove_divider(dev, &dove_hw_clocks[i],\n\t\t\t\t\t\t    core_pll,\n\t\t\t\t\t\t    ARRAY_SIZE(core_pll), base);\n\n\treturn 0;\n}\n\nstatic struct clk *dove_divider_clocks[4];\n\nstatic struct clk_onecell_data dove_divider_data = {\n\t.clks = dove_divider_clocks,\n\t.clk_num = ARRAY_SIZE(dove_divider_clocks),\n};\n\nvoid __init dove_divider_clk_init(struct device_node *np)\n{\n\tvoid __iomem *base;\n\n\tbase = of_iomap(np, 0);\n\tif (WARN_ON(!base))\n\t\treturn;\n\n\tif (WARN_ON(dove_divider_init(NULL, base, dove_divider_clocks))) {\n\t\tiounmap(base);\n\t\treturn;\n\t}\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &dove_divider_data);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}