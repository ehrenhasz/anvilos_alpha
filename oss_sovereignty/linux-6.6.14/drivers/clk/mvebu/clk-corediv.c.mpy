{
  "module_name": "clk-corediv.c",
  "hash_id": "a413da376780d13c3a4b20afb0b5e43f80f551a7eef70f8d98d4d5d64fd3b1ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mvebu/clk-corediv.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include \"common.h\"\n\n#define CORE_CLK_DIV_RATIO_MASK\t\t0xff\n\n \nstruct clk_corediv_desc {\n\tunsigned int mask;\n\tunsigned int offset;\n\tunsigned int fieldbit;\n};\n\n \nstruct clk_corediv_soc_desc {\n\tconst struct clk_corediv_desc *descs;\n\tunsigned int ndescs;\n\tconst struct clk_ops ops;\n\tu32 ratio_reload;\n\tu32 enable_bit_offset;\n\tu32 ratio_offset;\n};\n\n \nstruct clk_corediv {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n\tconst struct clk_corediv_desc *desc;\n\tconst struct clk_corediv_soc_desc *soc_desc;\n\tspinlock_t lock;\n};\n\nstatic struct clk_onecell_data clk_data;\n\n \nstatic const struct clk_corediv_desc mvebu_corediv_desc[] = {\n\t{ .mask = 0x3f, .offset = 8, .fieldbit = 1 },  \n};\n\nstatic const struct clk_corediv_desc mv98dx3236_corediv_desc[] = {\n\t{ .mask = 0x0f, .offset = 6, .fieldbit = 27 },  \n};\n\n#define to_corediv_clk(p) container_of(p, struct clk_corediv, hw)\n\nstatic int clk_corediv_is_enabled(struct clk_hw *hwclk)\n{\n\tstruct clk_corediv *corediv = to_corediv_clk(hwclk);\n\tconst struct clk_corediv_soc_desc *soc_desc = corediv->soc_desc;\n\tconst struct clk_corediv_desc *desc = corediv->desc;\n\tu32 enable_mask = BIT(desc->fieldbit) << soc_desc->enable_bit_offset;\n\n\treturn !!(readl(corediv->reg) & enable_mask);\n}\n\nstatic int clk_corediv_enable(struct clk_hw *hwclk)\n{\n\tstruct clk_corediv *corediv = to_corediv_clk(hwclk);\n\tconst struct clk_corediv_soc_desc *soc_desc = corediv->soc_desc;\n\tconst struct clk_corediv_desc *desc = corediv->desc;\n\tunsigned long flags = 0;\n\tu32 reg;\n\n\tspin_lock_irqsave(&corediv->lock, flags);\n\n\treg = readl(corediv->reg);\n\treg |= (BIT(desc->fieldbit) << soc_desc->enable_bit_offset);\n\twritel(reg, corediv->reg);\n\n\tspin_unlock_irqrestore(&corediv->lock, flags);\n\n\treturn 0;\n}\n\nstatic void clk_corediv_disable(struct clk_hw *hwclk)\n{\n\tstruct clk_corediv *corediv = to_corediv_clk(hwclk);\n\tconst struct clk_corediv_soc_desc *soc_desc = corediv->soc_desc;\n\tconst struct clk_corediv_desc *desc = corediv->desc;\n\tunsigned long flags = 0;\n\tu32 reg;\n\n\tspin_lock_irqsave(&corediv->lock, flags);\n\n\treg = readl(corediv->reg);\n\treg &= ~(BIT(desc->fieldbit) << soc_desc->enable_bit_offset);\n\twritel(reg, corediv->reg);\n\n\tspin_unlock_irqrestore(&corediv->lock, flags);\n}\n\nstatic unsigned long clk_corediv_recalc_rate(struct clk_hw *hwclk,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_corediv *corediv = to_corediv_clk(hwclk);\n\tconst struct clk_corediv_soc_desc *soc_desc = corediv->soc_desc;\n\tconst struct clk_corediv_desc *desc = corediv->desc;\n\tu32 reg, div;\n\n\treg = readl(corediv->reg + soc_desc->ratio_offset);\n\tdiv = (reg >> desc->offset) & desc->mask;\n\treturn parent_rate / div;\n}\n\nstatic long clk_corediv_round_rate(struct clk_hw *hwclk, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\t \n\tu32 div;\n\n\tdiv = *parent_rate / rate;\n\tif (div < 4)\n\t\tdiv = 4;\n\telse if (div > 6)\n\t\tdiv = 8;\n\n\treturn *parent_rate / div;\n}\n\nstatic int clk_corediv_set_rate(struct clk_hw *hwclk, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_corediv *corediv = to_corediv_clk(hwclk);\n\tconst struct clk_corediv_soc_desc *soc_desc = corediv->soc_desc;\n\tconst struct clk_corediv_desc *desc = corediv->desc;\n\tunsigned long flags = 0;\n\tu32 reg, div;\n\n\tdiv = parent_rate / rate;\n\n\tspin_lock_irqsave(&corediv->lock, flags);\n\n\t \n\treg = readl(corediv->reg + soc_desc->ratio_offset);\n\treg &= ~(desc->mask << desc->offset);\n\treg |= (div & desc->mask) << desc->offset;\n\twritel(reg, corediv->reg + soc_desc->ratio_offset);\n\n\t \n\treg = readl(corediv->reg) | BIT(desc->fieldbit);\n\twritel(reg, corediv->reg);\n\n\t \n\treg = readl(corediv->reg) | soc_desc->ratio_reload;\n\twritel(reg, corediv->reg);\n\n\t \n\tudelay(1000);\n\treg &= ~(CORE_CLK_DIV_RATIO_MASK | soc_desc->ratio_reload);\n\twritel(reg, corediv->reg);\n\tudelay(1000);\n\n\tspin_unlock_irqrestore(&corediv->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_corediv_soc_desc armada370_corediv_soc = {\n\t.descs = mvebu_corediv_desc,\n\t.ndescs = ARRAY_SIZE(mvebu_corediv_desc),\n\t.ops = {\n\t\t.enable = clk_corediv_enable,\n\t\t.disable = clk_corediv_disable,\n\t\t.is_enabled = clk_corediv_is_enabled,\n\t\t.recalc_rate = clk_corediv_recalc_rate,\n\t\t.round_rate = clk_corediv_round_rate,\n\t\t.set_rate = clk_corediv_set_rate,\n\t},\n\t.ratio_reload = BIT(8),\n\t.enable_bit_offset = 24,\n\t.ratio_offset = 0x8,\n};\n\nstatic const struct clk_corediv_soc_desc armada380_corediv_soc = {\n\t.descs = mvebu_corediv_desc,\n\t.ndescs = ARRAY_SIZE(mvebu_corediv_desc),\n\t.ops = {\n\t\t.enable = clk_corediv_enable,\n\t\t.disable = clk_corediv_disable,\n\t\t.is_enabled = clk_corediv_is_enabled,\n\t\t.recalc_rate = clk_corediv_recalc_rate,\n\t\t.round_rate = clk_corediv_round_rate,\n\t\t.set_rate = clk_corediv_set_rate,\n\t},\n\t.ratio_reload = BIT(8),\n\t.enable_bit_offset = 16,\n\t.ratio_offset = 0x4,\n};\n\nstatic const struct clk_corediv_soc_desc armada375_corediv_soc = {\n\t.descs = mvebu_corediv_desc,\n\t.ndescs = ARRAY_SIZE(mvebu_corediv_desc),\n\t.ops = {\n\t\t.recalc_rate = clk_corediv_recalc_rate,\n\t\t.round_rate = clk_corediv_round_rate,\n\t\t.set_rate = clk_corediv_set_rate,\n\t},\n\t.ratio_reload = BIT(8),\n\t.ratio_offset = 0x4,\n};\n\nstatic const struct clk_corediv_soc_desc mv98dx3236_corediv_soc = {\n\t.descs = mv98dx3236_corediv_desc,\n\t.ndescs = ARRAY_SIZE(mv98dx3236_corediv_desc),\n\t.ops = {\n\t\t.recalc_rate = clk_corediv_recalc_rate,\n\t\t.round_rate = clk_corediv_round_rate,\n\t\t.set_rate = clk_corediv_set_rate,\n\t},\n\t.ratio_reload = BIT(10),\n\t.ratio_offset = 0x8,\n};\n\nstatic void __init\nmvebu_corediv_clk_init(struct device_node *node,\n\t\t       const struct clk_corediv_soc_desc *soc_desc)\n{\n\tstruct clk_init_data init;\n\tstruct clk_corediv *corediv;\n\tstruct clk **clks;\n\tvoid __iomem *base;\n\tconst char *parent_name;\n\tconst char *clk_name;\n\tint i;\n\n\tbase = of_iomap(node, 0);\n\tif (WARN_ON(!base))\n\t\treturn;\n\n\tparent_name = of_clk_get_parent_name(node, 0);\n\n\tclk_data.clk_num = soc_desc->ndescs;\n\n\t \n\tclks = kcalloc(clk_data.clk_num, sizeof(struct clk *),\n\t\t\t\tGFP_KERNEL);\n\tif (WARN_ON(!clks))\n\t\tgoto err_unmap;\n\t \n\tcorediv = kcalloc(clk_data.clk_num, sizeof(struct clk_corediv),\n\t\t\t\tGFP_KERNEL);\n\tif (WARN_ON(!corediv))\n\t\tgoto err_free_clks;\n\n\tspin_lock_init(&corediv->lock);\n\n\tfor (i = 0; i < clk_data.clk_num; i++) {\n\t\tof_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t      i, &clk_name);\n\t\tinit.num_parents = 1;\n\t\tinit.parent_names = &parent_name;\n\t\tinit.name = clk_name;\n\t\tinit.ops = &soc_desc->ops;\n\t\tinit.flags = 0;\n\n\t\tcorediv[i].soc_desc = soc_desc;\n\t\tcorediv[i].desc = soc_desc->descs + i;\n\t\tcorediv[i].reg = base;\n\t\tcorediv[i].hw.init = &init;\n\n\t\tclks[i] = clk_register(NULL, &corediv[i].hw);\n\t\tWARN_ON(IS_ERR(clks[i]));\n\t}\n\n\tclk_data.clks = clks;\n\tof_clk_add_provider(node, of_clk_src_onecell_get, &clk_data);\n\treturn;\n\nerr_free_clks:\n\tkfree(clks);\nerr_unmap:\n\tiounmap(base);\n}\n\nstatic void __init armada370_corediv_clk_init(struct device_node *node)\n{\n\treturn mvebu_corediv_clk_init(node, &armada370_corediv_soc);\n}\nCLK_OF_DECLARE(armada370_corediv_clk, \"marvell,armada-370-corediv-clock\",\n\t       armada370_corediv_clk_init);\n\nstatic void __init armada375_corediv_clk_init(struct device_node *node)\n{\n\treturn mvebu_corediv_clk_init(node, &armada375_corediv_soc);\n}\nCLK_OF_DECLARE(armada375_corediv_clk, \"marvell,armada-375-corediv-clock\",\n\t       armada375_corediv_clk_init);\n\nstatic void __init armada380_corediv_clk_init(struct device_node *node)\n{\n\treturn mvebu_corediv_clk_init(node, &armada380_corediv_soc);\n}\nCLK_OF_DECLARE(armada380_corediv_clk, \"marvell,armada-380-corediv-clock\",\n\t       armada380_corediv_clk_init);\n\nstatic void __init mv98dx3236_corediv_clk_init(struct device_node *node)\n{\n\treturn mvebu_corediv_clk_init(node, &mv98dx3236_corediv_soc);\n}\nCLK_OF_DECLARE(mv98dx3236_corediv_clk, \"marvell,mv98dx3236-corediv-clock\",\n\t       mv98dx3236_corediv_clk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}