{
  "module_name": "armada-370.c",
  "hash_id": "216bf54346636d79d8fcae1eca614435d4a2d6bcdd36c08439532d12f1d328eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mvebu/armada-370.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include \"common.h\"\n\n \n\n#define SARL\t\t\t\t0\t \n#define\t SARL_A370_SSCG_ENABLE\t\tBIT(10)\n#define\t SARL_A370_PCLK_FREQ_OPT\t11\n#define\t SARL_A370_PCLK_FREQ_OPT_MASK\t0xF\n#define\t SARL_A370_FAB_FREQ_OPT\t\t15\n#define\t SARL_A370_FAB_FREQ_OPT_MASK\t0x1F\n#define\t SARL_A370_TCLK_FREQ_OPT\t20\n#define\t SARL_A370_TCLK_FREQ_OPT_MASK\t0x1\n\nenum { A370_CPU_TO_NBCLK, A370_CPU_TO_HCLK, A370_CPU_TO_DRAMCLK };\n\nstatic const struct coreclk_ratio a370_coreclk_ratios[] __initconst = {\n\t{ .id = A370_CPU_TO_NBCLK, .name = \"nbclk\" },\n\t{ .id = A370_CPU_TO_HCLK, .name = \"hclk\" },\n\t{ .id = A370_CPU_TO_DRAMCLK, .name = \"dramclk\" },\n};\n\nstatic const u32 a370_tclk_freqs[] __initconst = {\n\t166000000,\n\t200000000,\n};\n\nstatic u32 __init a370_get_tclk_freq(void __iomem *sar)\n{\n\tu8 tclk_freq_select = 0;\n\n\ttclk_freq_select = ((readl(sar) >> SARL_A370_TCLK_FREQ_OPT) &\n\t\t\t    SARL_A370_TCLK_FREQ_OPT_MASK);\n\treturn a370_tclk_freqs[tclk_freq_select];\n}\n\nstatic const u32 a370_cpu_freqs[] __initconst = {\n\t400000000,\n\t533000000,\n\t667000000,\n\t800000000,\n\t1000000000,\n\t1067000000,\n\t1200000000,\n};\n\nstatic u32 __init a370_get_cpu_freq(void __iomem *sar)\n{\n\tu32 cpu_freq;\n\tu8 cpu_freq_select = 0;\n\n\tcpu_freq_select = ((readl(sar) >> SARL_A370_PCLK_FREQ_OPT) &\n\t\t\t   SARL_A370_PCLK_FREQ_OPT_MASK);\n\tif (cpu_freq_select >= ARRAY_SIZE(a370_cpu_freqs)) {\n\t\tpr_err(\"CPU freq select unsupported %d\\n\", cpu_freq_select);\n\t\tcpu_freq = 0;\n\t} else\n\t\tcpu_freq = a370_cpu_freqs[cpu_freq_select];\n\n\treturn cpu_freq;\n}\n\nstatic const int a370_nbclk_ratios[32][2] __initconst = {\n\t{0, 1}, {1, 2}, {2, 2}, {2, 2},\n\t{1, 2}, {1, 2}, {1, 1}, {2, 3},\n\t{0, 1}, {1, 2}, {2, 4}, {0, 1},\n\t{1, 2}, {0, 1}, {0, 1}, {2, 2},\n\t{0, 1}, {0, 1}, {0, 1}, {1, 1},\n\t{2, 3}, {0, 1}, {0, 1}, {0, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {1, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n};\n\nstatic const int a370_hclk_ratios[32][2] __initconst = {\n\t{0, 1}, {1, 2}, {2, 6}, {2, 3},\n\t{1, 3}, {1, 4}, {1, 2}, {2, 6},\n\t{0, 1}, {1, 6}, {2, 10}, {0, 1},\n\t{1, 4}, {0, 1}, {0, 1}, {2, 5},\n\t{0, 1}, {0, 1}, {0, 1}, {1, 2},\n\t{2, 6}, {0, 1}, {0, 1}, {0, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {1, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n};\n\nstatic const int a370_dramclk_ratios[32][2] __initconst = {\n\t{0, 1}, {1, 2}, {2, 3}, {2, 3},\n\t{1, 3}, {1, 2}, {1, 2}, {2, 6},\n\t{0, 1}, {1, 3}, {2, 5}, {0, 1},\n\t{1, 4}, {0, 1}, {0, 1}, {2, 5},\n\t{0, 1}, {0, 1}, {0, 1}, {1, 1},\n\t{2, 3}, {0, 1}, {0, 1}, {0, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {1, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n};\n\nstatic void __init a370_get_clk_ratio(\n\tvoid __iomem *sar, int id, int *mult, int *div)\n{\n\tu32 opt = ((readl(sar) >> SARL_A370_FAB_FREQ_OPT) &\n\t\tSARL_A370_FAB_FREQ_OPT_MASK);\n\n\tswitch (id) {\n\tcase A370_CPU_TO_NBCLK:\n\t\t*mult = a370_nbclk_ratios[opt][0];\n\t\t*div = a370_nbclk_ratios[opt][1];\n\t\tbreak;\n\tcase A370_CPU_TO_HCLK:\n\t\t*mult = a370_hclk_ratios[opt][0];\n\t\t*div = a370_hclk_ratios[opt][1];\n\t\tbreak;\n\tcase A370_CPU_TO_DRAMCLK:\n\t\t*mult = a370_dramclk_ratios[opt][0];\n\t\t*div = a370_dramclk_ratios[opt][1];\n\t\tbreak;\n\t}\n}\n\nstatic bool a370_is_sscg_enabled(void __iomem *sar)\n{\n\treturn !(readl(sar) & SARL_A370_SSCG_ENABLE);\n}\n\nstatic const struct coreclk_soc_desc a370_coreclks = {\n\t.get_tclk_freq = a370_get_tclk_freq,\n\t.get_cpu_freq = a370_get_cpu_freq,\n\t.get_clk_ratio = a370_get_clk_ratio,\n\t.is_sscg_enabled = a370_is_sscg_enabled,\n\t.fix_sscg_deviation = kirkwood_fix_sscg_deviation,\n\t.ratios = a370_coreclk_ratios,\n\t.num_ratios = ARRAY_SIZE(a370_coreclk_ratios),\n};\n\n \n\nstatic const struct clk_gating_soc_desc a370_gating_desc[] __initconst = {\n\t{ \"audio\", NULL, 0, 0 },\n\t{ \"pex0_en\", NULL, 1, 0 },\n\t{ \"pex1_en\", NULL,  2, 0 },\n\t{ \"ge1\", NULL, 3, 0 },\n\t{ \"ge0\", NULL, 4, 0 },\n\t{ \"pex0\", \"pex0_en\", 5, 0 },\n\t{ \"pex1\", \"pex1_en\", 9, 0 },\n\t{ \"sata0\", NULL, 15, 0 },\n\t{ \"sdio\", NULL, 17, 0 },\n\t{ \"crypto\", NULL, 23, CLK_IGNORE_UNUSED },\n\t{ \"tdm\", NULL, 25, 0 },\n\t{ \"ddr\", NULL, 28, CLK_IGNORE_UNUSED },\n\t{ \"sata1\", NULL, 30, 0 },\n\t{ }\n};\n\nstatic void __init a370_clk_init(struct device_node *np)\n{\n\tstruct device_node *cgnp =\n\t\tof_find_compatible_node(NULL, NULL, \"marvell,armada-370-gating-clock\");\n\n\tmvebu_coreclk_setup(np, &a370_coreclks);\n\n\tif (cgnp) {\n\t\tmvebu_clk_gating_setup(cgnp, a370_gating_desc);\n\t\tof_node_put(cgnp);\n\t}\n}\nCLK_OF_DECLARE(a370_clk, \"marvell,armada-370-core-clock\", a370_clk_init);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}