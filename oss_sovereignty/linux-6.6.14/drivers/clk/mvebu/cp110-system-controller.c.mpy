{
  "module_name": "cp110-system-controller.c",
  "hash_id": "ca83327291518d101595aae14ed787925b2d44d83ec6e54496a09342510c02e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mvebu/cp110-system-controller.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) \"cp110-system-controller: \" fmt\n\n#include \"armada_ap_cp_helper.h\"\n#include <linux/clk-provider.h>\n#include <linux/mfd/syscon.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define CP110_PM_CLOCK_GATING_REG\t0x220\n#define CP110_NAND_FLASH_CLK_CTRL_REG\t0x700\n#define    NF_CLOCK_SEL_400_MASK\tBIT(0)\n\nenum {\n\tCP110_CLK_TYPE_CORE,\n\tCP110_CLK_TYPE_GATABLE,\n};\n\n#define CP110_MAX_CORE_CLOCKS\t\t6\n#define CP110_MAX_GATABLE_CLOCKS\t32\n\n#define CP110_CLK_NUM \\\n\t(CP110_MAX_CORE_CLOCKS + CP110_MAX_GATABLE_CLOCKS)\n\n#define CP110_CORE_PLL0\t\t\t0\n#define CP110_CORE_PPV2\t\t\t1\n#define CP110_CORE_X2CORE\t\t2\n#define CP110_CORE_CORE\t\t\t3\n#define CP110_CORE_NAND\t\t\t4\n#define CP110_CORE_SDIO\t\t\t5\n\n \n#define CP110_GATE_AUDIO\t\t0\n#define CP110_GATE_COMM_UNIT\t\t1\n#define CP110_GATE_NAND\t\t\t2\n#define CP110_GATE_PPV2\t\t\t3\n#define CP110_GATE_SDIO\t\t\t4\n#define CP110_GATE_MG\t\t\t5\n#define CP110_GATE_MG_CORE\t\t6\n#define CP110_GATE_XOR1\t\t\t7\n#define CP110_GATE_XOR0\t\t\t8\n#define CP110_GATE_GOP_DP\t\t9\n#define CP110_GATE_PCIE_X1_0\t\t11\n#define CP110_GATE_PCIE_X1_1\t\t12\n#define CP110_GATE_PCIE_X4\t\t13\n#define CP110_GATE_PCIE_XOR\t\t14\n#define CP110_GATE_SATA\t\t\t15\n#define CP110_GATE_SATA_USB\t\t16\n#define CP110_GATE_MAIN\t\t\t17\n#define CP110_GATE_SDMMC_GOP\t\t18\n#define CP110_GATE_SLOW_IO\t\t21\n#define CP110_GATE_USB3H0\t\t22\n#define CP110_GATE_USB3H1\t\t23\n#define CP110_GATE_USB3DEV\t\t24\n#define CP110_GATE_EIP150\t\t25\n#define CP110_GATE_EIP197\t\t26\n\nstatic const char * const gate_base_names[] = {\n\t[CP110_GATE_AUDIO]\t= \"audio\",\n\t[CP110_GATE_COMM_UNIT]\t= \"communit\",\n\t[CP110_GATE_NAND]\t= \"nand\",\n\t[CP110_GATE_PPV2]\t= \"ppv2\",\n\t[CP110_GATE_SDIO]\t= \"sdio\",\n\t[CP110_GATE_MG]\t\t= \"mg-domain\",\n\t[CP110_GATE_MG_CORE]\t= \"mg-core\",\n\t[CP110_GATE_XOR1]\t= \"xor1\",\n\t[CP110_GATE_XOR0]\t= \"xor0\",\n\t[CP110_GATE_GOP_DP]\t= \"gop-dp\",\n\t[CP110_GATE_PCIE_X1_0]\t= \"pcie_x10\",\n\t[CP110_GATE_PCIE_X1_1]\t= \"pcie_x11\",\n\t[CP110_GATE_PCIE_X4]\t= \"pcie_x4\",\n\t[CP110_GATE_PCIE_XOR]\t= \"pcie-xor\",\n\t[CP110_GATE_SATA]\t= \"sata\",\n\t[CP110_GATE_SATA_USB]\t= \"sata-usb\",\n\t[CP110_GATE_MAIN]\t= \"main\",\n\t[CP110_GATE_SDMMC_GOP]\t= \"sd-mmc-gop\",\n\t[CP110_GATE_SLOW_IO]\t= \"slow-io\",\n\t[CP110_GATE_USB3H0]\t= \"usb3h0\",\n\t[CP110_GATE_USB3H1]\t= \"usb3h1\",\n\t[CP110_GATE_USB3DEV]\t= \"usb3dev\",\n\t[CP110_GATE_EIP150]\t= \"eip150\",\n\t[CP110_GATE_EIP197]\t= \"eip197\"\n};\n\nstruct cp110_gate_clk {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tu8 bit_idx;\n};\n\n#define to_cp110_gate_clk(hw) container_of(hw, struct cp110_gate_clk, hw)\n\nstatic int cp110_gate_enable(struct clk_hw *hw)\n{\n\tstruct cp110_gate_clk *gate = to_cp110_gate_clk(hw);\n\n\tregmap_update_bits(gate->regmap, CP110_PM_CLOCK_GATING_REG,\n\t\t\t   BIT(gate->bit_idx), BIT(gate->bit_idx));\n\n\treturn 0;\n}\n\nstatic void cp110_gate_disable(struct clk_hw *hw)\n{\n\tstruct cp110_gate_clk *gate = to_cp110_gate_clk(hw);\n\n\tregmap_update_bits(gate->regmap, CP110_PM_CLOCK_GATING_REG,\n\t\t\t   BIT(gate->bit_idx), 0);\n}\n\nstatic int cp110_gate_is_enabled(struct clk_hw *hw)\n{\n\tstruct cp110_gate_clk *gate = to_cp110_gate_clk(hw);\n\tu32 val;\n\n\tregmap_read(gate->regmap, CP110_PM_CLOCK_GATING_REG, &val);\n\n\treturn val & BIT(gate->bit_idx);\n}\n\nstatic const struct clk_ops cp110_gate_ops = {\n\t.enable = cp110_gate_enable,\n\t.disable = cp110_gate_disable,\n\t.is_enabled = cp110_gate_is_enabled,\n};\n\nstatic struct clk_hw *cp110_register_gate(const char *name,\n\t\t\t\t\t  const char *parent_name,\n\t\t\t\t\t  struct regmap *regmap, u8 bit_idx)\n{\n\tstruct cp110_gate_clk *gate;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemset(&init, 0, sizeof(init));\n\n\tinit.name = name;\n\tinit.ops = &cp110_gate_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tgate->regmap = regmap;\n\tgate->bit_idx = bit_idx;\n\tgate->hw.init = &init;\n\n\thw = &gate->hw;\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(gate);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstatic void cp110_unregister_gate(struct clk_hw *hw)\n{\n\tclk_hw_unregister(hw);\n\tkfree(to_cp110_gate_clk(hw));\n}\n\nstatic struct clk_hw *cp110_of_clk_get(struct of_phandle_args *clkspec,\n\t\t\t\t       void *data)\n{\n\tstruct clk_hw_onecell_data *clk_data = data;\n\tunsigned int type = clkspec->args[0];\n\tunsigned int idx = clkspec->args[1];\n\n\tif (type == CP110_CLK_TYPE_CORE) {\n\t\tif (idx >= CP110_MAX_CORE_CLOCKS)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn clk_data->hws[idx];\n\t} else if (type == CP110_CLK_TYPE_GATABLE) {\n\t\tif (idx >= CP110_MAX_GATABLE_CLOCKS)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn clk_data->hws[CP110_MAX_CORE_CLOCKS + idx];\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int cp110_syscon_common_probe(struct platform_device *pdev,\n\t\t\t\t     struct device_node *syscon_node)\n{\n\tstruct regmap *regmap;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst char *ppv2_name, *pll0_name, *core_name, *x2core_name, *nand_name,\n\t\t*sdio_name;\n\tstruct clk_hw_onecell_data *cp110_clk_data;\n\tstruct clk_hw *hw, **cp110_clks;\n\tu32 nand_clk_ctrl;\n\tint i, ret;\n\tchar *gate_name[ARRAY_SIZE(gate_base_names)];\n\n\tregmap = syscon_node_to_regmap(syscon_node);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tret = regmap_read(regmap, CP110_NAND_FLASH_CLK_CTRL_REG,\n\t\t\t  &nand_clk_ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tcp110_clk_data = devm_kzalloc(dev, struct_size(cp110_clk_data, hws,\n\t\t\t\t\t\t       CP110_CLK_NUM),\n\t\t\t\t      GFP_KERNEL);\n\tif (!cp110_clk_data)\n\t\treturn -ENOMEM;\n\tcp110_clk_data->num = CP110_CLK_NUM;\n\n\tcp110_clks = cp110_clk_data->hws;\n\n\t \n\tpll0_name = ap_cp_unique_name(dev, syscon_node, \"pll0\");\n\thw = clk_hw_register_fixed_rate(NULL, pll0_name, NULL, 0,\n\t\t\t\t\t1000 * 1000 * 1000);\n\tif (IS_ERR(hw)) {\n\t\tret = PTR_ERR(hw);\n\t\tgoto fail_pll0;\n\t}\n\n\tcp110_clks[CP110_CORE_PLL0] = hw;\n\n\t \n\tppv2_name = ap_cp_unique_name(dev, syscon_node, \"ppv2-core\");\n\thw = clk_hw_register_fixed_factor(NULL, ppv2_name, pll0_name, 0, 1, 3);\n\tif (IS_ERR(hw)) {\n\t\tret = PTR_ERR(hw);\n\t\tgoto fail_ppv2;\n\t}\n\n\tcp110_clks[CP110_CORE_PPV2] = hw;\n\n\t \n\tx2core_name = ap_cp_unique_name(dev, syscon_node, \"x2core\");\n\thw = clk_hw_register_fixed_factor(NULL, x2core_name, pll0_name,\n\t\t\t\t\t  0, 1, 2);\n\tif (IS_ERR(hw)) {\n\t\tret = PTR_ERR(hw);\n\t\tgoto fail_eip;\n\t}\n\n\tcp110_clks[CP110_CORE_X2CORE] = hw;\n\n\t \n\tcore_name = ap_cp_unique_name(dev, syscon_node, \"core\");\n\thw = clk_hw_register_fixed_factor(NULL, core_name, x2core_name,\n\t\t\t\t\t  0, 1, 2);\n\tif (IS_ERR(hw)) {\n\t\tret = PTR_ERR(hw);\n\t\tgoto fail_core;\n\t}\n\n\tcp110_clks[CP110_CORE_CORE] = hw;\n\t \n\tnand_name = ap_cp_unique_name(dev, syscon_node, \"nand-core\");\n\tif (nand_clk_ctrl & NF_CLOCK_SEL_400_MASK)\n\t\thw = clk_hw_register_fixed_factor(NULL, nand_name,\n\t\t\t\t\t\t   pll0_name, 0, 2, 5);\n\telse\n\t\thw = clk_hw_register_fixed_factor(NULL, nand_name,\n\t\t\t\t\t\t   core_name, 0, 1, 1);\n\tif (IS_ERR(hw)) {\n\t\tret = PTR_ERR(hw);\n\t\tgoto fail_nand;\n\t}\n\n\tcp110_clks[CP110_CORE_NAND] = hw;\n\n\t \n\tsdio_name = ap_cp_unique_name(dev, syscon_node, \"sdio-core\");\n\thw = clk_hw_register_fixed_factor(NULL, sdio_name,\n\t\t\t\t\t  pll0_name, 0, 2, 5);\n\tif (IS_ERR(hw)) {\n\t\tret = PTR_ERR(hw);\n\t\tgoto fail_sdio;\n\t}\n\n\tcp110_clks[CP110_CORE_SDIO] = hw;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(gate_base_names); i++)\n\t\tgate_name[i] =\tap_cp_unique_name(dev, syscon_node,\n\t\t\t\t\t\t  gate_base_names[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(gate_base_names); i++) {\n\t\tconst char *parent;\n\n\t\tif (gate_name[i] == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase CP110_GATE_NAND:\n\t\t\tparent = nand_name;\n\t\t\tbreak;\n\t\tcase CP110_GATE_MG:\n\t\tcase CP110_GATE_GOP_DP:\n\t\tcase CP110_GATE_PPV2:\n\t\t\tparent = ppv2_name;\n\t\t\tbreak;\n\t\tcase CP110_GATE_SDIO:\n\t\t\tparent = sdio_name;\n\t\t\tbreak;\n\t\tcase CP110_GATE_MAIN:\n\t\tcase CP110_GATE_PCIE_XOR:\n\t\tcase CP110_GATE_PCIE_X4:\n\t\tcase CP110_GATE_EIP150:\n\t\tcase CP110_GATE_EIP197:\n\t\t\tparent = x2core_name;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparent = core_name;\n\t\t\tbreak;\n\t\t}\n\t\thw = cp110_register_gate(gate_name[i], parent, regmap, i);\n\n\t\tif (IS_ERR(hw)) {\n\t\t\tret = PTR_ERR(hw);\n\t\t\tgoto fail_gate;\n\t\t}\n\n\t\tcp110_clks[CP110_MAX_CORE_CLOCKS + i] = hw;\n\t}\n\n\tret = of_clk_add_hw_provider(np, cp110_of_clk_get, cp110_clk_data);\n\tif (ret)\n\t\tgoto fail_clk_add;\n\n\tplatform_set_drvdata(pdev, cp110_clks);\n\n\treturn 0;\n\nfail_clk_add:\nfail_gate:\n\tfor (i = 0; i < CP110_MAX_GATABLE_CLOCKS; i++) {\n\t\thw = cp110_clks[CP110_MAX_CORE_CLOCKS + i];\n\n\t\tif (hw)\n\t\t\tcp110_unregister_gate(hw);\n\t}\n\n\tclk_hw_unregister_fixed_factor(cp110_clks[CP110_CORE_SDIO]);\nfail_sdio:\n\tclk_hw_unregister_fixed_factor(cp110_clks[CP110_CORE_NAND]);\nfail_nand:\n\tclk_hw_unregister_fixed_factor(cp110_clks[CP110_CORE_CORE]);\nfail_core:\n\tclk_hw_unregister_fixed_factor(cp110_clks[CP110_CORE_X2CORE]);\nfail_eip:\n\tclk_hw_unregister_fixed_factor(cp110_clks[CP110_CORE_PPV2]);\nfail_ppv2:\n\tclk_hw_unregister_fixed_rate(cp110_clks[CP110_CORE_PLL0]);\nfail_pll0:\n\treturn ret;\n}\n\nstatic int cp110_syscon_legacy_clk_probe(struct platform_device *pdev)\n{\n\tdev_warn(&pdev->dev, FW_WARN \"Using legacy device tree binding\\n\");\n\tdev_warn(&pdev->dev, FW_WARN \"Update your device tree:\\n\");\n\tdev_warn(&pdev->dev, FW_WARN\n\t\t \"This binding won't be supported in future kernels\\n\");\n\n\treturn cp110_syscon_common_probe(pdev, pdev->dev.of_node);\n}\n\nstatic int cp110_clk_probe(struct platform_device *pdev)\n{\n\treturn cp110_syscon_common_probe(pdev, pdev->dev.of_node->parent);\n}\n\nstatic const struct of_device_id cp110_syscon_legacy_of_match[] = {\n\t{ .compatible = \"marvell,cp110-system-controller0\", },\n\t{ }\n};\n\nstatic struct platform_driver cp110_syscon_legacy_driver = {\n\t.probe = cp110_syscon_legacy_clk_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"marvell-cp110-system-controller0\",\n\t\t.of_match_table = cp110_syscon_legacy_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(cp110_syscon_legacy_driver);\n\nstatic const struct of_device_id cp110_clock_of_match[] = {\n\t{ .compatible = \"marvell,cp110-clock\", },\n\t{ }\n};\n\nstatic struct platform_driver cp110_clock_driver = {\n\t.probe = cp110_clk_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"marvell-cp110-clock\",\n\t\t.of_match_table = cp110_clock_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(cp110_clock_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}