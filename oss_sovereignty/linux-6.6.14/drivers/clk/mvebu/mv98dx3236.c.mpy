{
  "module_name": "mv98dx3236.c",
  "hash_id": "3211f9f5c8736cc5eff481be70ceda06248f76235b3ce4ea76665637e64ca71c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mvebu/mv98dx3236.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include \"common.h\"\n\n\n \n\n#define SAR1_MV98DX3236_CPU_DDR_MPLL_FREQ_OPT\t\t18\n#define SAR1_MV98DX3236_CPU_DDR_MPLL_FREQ_OPT_MASK\t0x7\n\nstatic u32 __init mv98dx3236_get_tclk_freq(void __iomem *sar)\n{\n\t \n\treturn 200000000;\n}\n\nstatic const u32 mv98dx3236_cpu_frequencies[] __initconst = {\n\t0,\n\t667000000,\n\t400000000,\n\t800000000,\n\t0,\n\t800000000,\n\t0, 0,\n};\n\nstatic const u32 mv98dx4251_cpu_frequencies[] __initconst = {\n\t400000000,\n\t0,\n\t667000000,\n\t800000000,\n\t0, 0, 0, 0,\n};\n\nstatic u32 __init mv98dx3236_get_cpu_freq(void __iomem *sar)\n{\n\tu32 cpu_freq = 0;\n\tu8 cpu_freq_select = 0;\n\n\tcpu_freq_select = ((readl(sar) >> SAR1_MV98DX3236_CPU_DDR_MPLL_FREQ_OPT) &\n\t\t\t   SAR1_MV98DX3236_CPU_DDR_MPLL_FREQ_OPT_MASK);\n\n\tif (of_machine_is_compatible(\"marvell,armadaxp-98dx4251\"))\n\t\tcpu_freq = mv98dx4251_cpu_frequencies[cpu_freq_select];\n\telse if (of_machine_is_compatible(\"marvell,armadaxp-98dx3236\"))\n\t\tcpu_freq = mv98dx3236_cpu_frequencies[cpu_freq_select];\n\n\tif (!cpu_freq)\n\t\tpr_err(\"CPU freq select unsupported %d\\n\", cpu_freq_select);\n\n\treturn cpu_freq;\n}\n\nenum {\n\tMV98DX3236_CPU_TO_DDR,\n\tMV98DX3236_CPU_TO_MPLL\n};\n\nstatic const struct coreclk_ratio mv98dx3236_core_ratios[] __initconst = {\n\t{ .id = MV98DX3236_CPU_TO_DDR, .name = \"ddrclk\" },\n\t{ .id = MV98DX3236_CPU_TO_MPLL, .name = \"mpll\" },\n};\n\nstatic const int __initconst mv98dx3236_cpu_mpll_ratios[8][2] = {\n\t{0, 1}, {3, 1}, {1, 1}, {1, 1},\n\t{0, 1}, {1, 1}, {0, 1}, {0, 1},\n};\n\nstatic const int __initconst mv98dx3236_cpu_ddr_ratios[8][2] = {\n\t{0, 1}, {1, 1}, {1, 1}, {1, 1},\n\t{0, 1}, {1, 2}, {0, 1}, {0, 1},\n};\n\nstatic const int __initconst mv98dx4251_cpu_mpll_ratios[8][2] = {\n\t{2, 1}, {0, 1}, {3, 1}, {2, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n};\n\nstatic const int __initconst mv98dx4251_cpu_ddr_ratios[8][2] = {\n\t{1, 1}, {0, 1}, {1, 1}, {1, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n};\n\nstatic void __init mv98dx3236_get_clk_ratio(\n\tvoid __iomem *sar, int id, int *mult, int *div)\n{\n\tu32 opt = ((readl(sar) >> SAR1_MV98DX3236_CPU_DDR_MPLL_FREQ_OPT) &\n\t\tSAR1_MV98DX3236_CPU_DDR_MPLL_FREQ_OPT_MASK);\n\n\tswitch (id) {\n\tcase MV98DX3236_CPU_TO_DDR:\n\t\tif (of_machine_is_compatible(\"marvell,armadaxp-98dx4251\")) {\n\t\t\t*mult = mv98dx4251_cpu_ddr_ratios[opt][0];\n\t\t\t*div = mv98dx4251_cpu_ddr_ratios[opt][1];\n\t\t} else if (of_machine_is_compatible(\"marvell,armadaxp-98dx3236\")) {\n\t\t\t*mult = mv98dx3236_cpu_ddr_ratios[opt][0];\n\t\t\t*div = mv98dx3236_cpu_ddr_ratios[opt][1];\n\t\t}\n\t\tbreak;\n\tcase MV98DX3236_CPU_TO_MPLL:\n\t\tif (of_machine_is_compatible(\"marvell,armadaxp-98dx4251\")) {\n\t\t\t*mult = mv98dx4251_cpu_mpll_ratios[opt][0];\n\t\t\t*div = mv98dx4251_cpu_mpll_ratios[opt][1];\n\t\t} else if (of_machine_is_compatible(\"marvell,armadaxp-98dx3236\")) {\n\t\t\t*mult = mv98dx3236_cpu_mpll_ratios[opt][0];\n\t\t\t*div = mv98dx3236_cpu_mpll_ratios[opt][1];\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic const struct coreclk_soc_desc mv98dx3236_core_clocks = {\n\t.get_tclk_freq = mv98dx3236_get_tclk_freq,\n\t.get_cpu_freq = mv98dx3236_get_cpu_freq,\n\t.get_clk_ratio = mv98dx3236_get_clk_ratio,\n\t.ratios = mv98dx3236_core_ratios,\n\t.num_ratios = ARRAY_SIZE(mv98dx3236_core_ratios),\n};\n\n\n \n\nstatic const struct clk_gating_soc_desc mv98dx3236_gating_desc[] __initconst = {\n\t{ \"ge1\", NULL, 3, 0 },\n\t{ \"ge0\", NULL, 4, 0 },\n\t{ \"pex00\", NULL, 5, 0 },\n\t{ \"sdio\", NULL, 17, 0 },\n\t{ \"usb0\", NULL, 18, 0 },\n\t{ \"xor0\", NULL, 22, 0 },\n\t{ }\n};\n\nstatic void __init mv98dx3236_clk_init(struct device_node *np)\n{\n\tstruct device_node *cgnp =\n\t\tof_find_compatible_node(NULL, NULL, \"marvell,mv98dx3236-gating-clock\");\n\n\tmvebu_coreclk_setup(np, &mv98dx3236_core_clocks);\n\n\tif (cgnp) {\n\t\tmvebu_clk_gating_setup(cgnp, mv98dx3236_gating_desc);\n\t\tof_node_put(cgnp);\n\t}\n}\nCLK_OF_DECLARE(mv98dx3236_clk, \"marvell,mv98dx3236-core-clock\", mv98dx3236_clk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}