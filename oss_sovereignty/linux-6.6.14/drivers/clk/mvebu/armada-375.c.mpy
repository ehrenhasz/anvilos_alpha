{
  "module_name": "armada-375.c",
  "hash_id": "9dfbcfcb7312f8a5ff9ce8eff2c0098486e1a05c1cbaaba33d9e03fbc3ff490b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mvebu/armada-375.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include \"common.h\"\n\n \n\n \n\n#define SAR1_A375_TCLK_FREQ_OPT\t\t   22\n#define SAR1_A375_TCLK_FREQ_OPT_MASK\t   0x1\n#define SAR1_A375_CPU_DDR_L2_FREQ_OPT\t   17\n#define SAR1_A375_CPU_DDR_L2_FREQ_OPT_MASK 0x1F\n\nstatic const u32 armada_375_tclk_frequencies[] __initconst = {\n\t166000000,\n\t200000000,\n};\n\nstatic u32 __init armada_375_get_tclk_freq(void __iomem *sar)\n{\n\tu8 tclk_freq_select;\n\n\ttclk_freq_select = ((readl(sar) >> SAR1_A375_TCLK_FREQ_OPT) &\n\t\t\t    SAR1_A375_TCLK_FREQ_OPT_MASK);\n\treturn armada_375_tclk_frequencies[tclk_freq_select];\n}\n\n\nstatic const u32 armada_375_cpu_frequencies[] __initconst = {\n\t0, 0, 0, 0, 0, 0,\n\t400000000,\n\t0, 0, 0, 0, 0, 0, 0, 0,\n\t600000000,\n\t0, 0, 0, 0, 0,\n\t800000000,\n\t0, 0, 0,\n\t1000000000,\n};\n\nstatic u32 __init armada_375_get_cpu_freq(void __iomem *sar)\n{\n\tu8 cpu_freq_select;\n\n\tcpu_freq_select = ((readl(sar) >> SAR1_A375_CPU_DDR_L2_FREQ_OPT) &\n\t\t\t   SAR1_A375_CPU_DDR_L2_FREQ_OPT_MASK);\n\tif (cpu_freq_select >= ARRAY_SIZE(armada_375_cpu_frequencies)) {\n\t\tpr_err(\"Selected CPU frequency (%d) unsupported\\n\",\n\t\t\tcpu_freq_select);\n\t\treturn 0;\n\t} else\n\t\treturn armada_375_cpu_frequencies[cpu_freq_select];\n}\n\nenum { A375_CPU_TO_DDR, A375_CPU_TO_L2 };\n\nstatic const struct coreclk_ratio armada_375_coreclk_ratios[] __initconst = {\n\t{ .id = A375_CPU_TO_L2,\t .name = \"l2clk\" },\n\t{ .id = A375_CPU_TO_DDR, .name = \"ddrclk\" },\n};\n\nstatic const int armada_375_cpu_l2_ratios[32][2] __initconst = {\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n\t{0, 1}, {0, 1}, {1, 2}, {0, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {1, 2},\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n\t{0, 1}, {1, 2}, {0, 1}, {0, 1},\n\t{0, 1}, {1, 2}, {0, 1}, {0, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n};\n\nstatic const int armada_375_cpu_ddr_ratios[32][2] __initconst = {\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n\t{0, 1}, {0, 1}, {1, 1}, {0, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {2, 3},\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n\t{0, 1}, {2, 3}, {0, 1}, {0, 1},\n\t{0, 1}, {1, 2}, {0, 1}, {0, 1},\n\t{0, 1}, {0, 1}, {0, 1}, {0, 1},\n};\n\nstatic void __init armada_375_get_clk_ratio(\n\tvoid __iomem *sar, int id, int *mult, int *div)\n{\n\tu32 opt = ((readl(sar) >> SAR1_A375_CPU_DDR_L2_FREQ_OPT) &\n\t\tSAR1_A375_CPU_DDR_L2_FREQ_OPT_MASK);\n\n\tswitch (id) {\n\tcase A375_CPU_TO_L2:\n\t\t*mult = armada_375_cpu_l2_ratios[opt][0];\n\t\t*div = armada_375_cpu_l2_ratios[opt][1];\n\t\tbreak;\n\tcase A375_CPU_TO_DDR:\n\t\t*mult = armada_375_cpu_ddr_ratios[opt][0];\n\t\t*div = armada_375_cpu_ddr_ratios[opt][1];\n\t\tbreak;\n\t}\n}\n\nstatic const struct coreclk_soc_desc armada_375_coreclks = {\n\t.get_tclk_freq = armada_375_get_tclk_freq,\n\t.get_cpu_freq = armada_375_get_cpu_freq,\n\t.get_clk_ratio = armada_375_get_clk_ratio,\n\t.ratios = armada_375_coreclk_ratios,\n\t.num_ratios = ARRAY_SIZE(armada_375_coreclk_ratios),\n};\n\nstatic void __init armada_375_coreclk_init(struct device_node *np)\n{\n\tmvebu_coreclk_setup(np, &armada_375_coreclks);\n}\nCLK_OF_DECLARE(armada_375_core_clk, \"marvell,armada-375-core-clock\",\n\t       armada_375_coreclk_init);\n\n \nstatic const struct clk_gating_soc_desc armada_375_gating_desc[] __initconst = {\n\t{ \"mu\", NULL, 2 },\n\t{ \"pp\", NULL, 3 },\n\t{ \"ptp\", NULL, 4 },\n\t{ \"pex0\", NULL, 5 },\n\t{ \"pex1\", NULL, 6 },\n\t{ \"audio\", NULL, 8 },\n\t{ \"nd_clk\", \"nand\", 11 },\n\t{ \"sata0_link\", \"sata0_core\", 14 },\n\t{ \"sata0_core\", NULL, 15 },\n\t{ \"usb3\", NULL, 16 },\n\t{ \"sdio\", NULL, 17 },\n\t{ \"usb\", NULL, 18 },\n\t{ \"gop\", NULL, 19 },\n\t{ \"sata1_link\", \"sata1_core\", 20 },\n\t{ \"sata1_core\", NULL, 21 },\n\t{ \"xor0\", NULL, 22 },\n\t{ \"xor1\", NULL, 23 },\n\t{ \"copro\", NULL, 24 },\n\t{ \"tdm\", NULL, 25 },\n\t{ \"crypto0_enc\", NULL, 28 },\n\t{ \"crypto0_core\", NULL, 29 },\n\t{ \"crypto1_enc\", NULL, 30 },\n\t{ \"crypto1_core\", NULL, 31 },\n\t{ }\n};\n\nstatic void __init armada_375_clk_gating_init(struct device_node *np)\n{\n\tmvebu_clk_gating_setup(np, armada_375_gating_desc);\n}\nCLK_OF_DECLARE(armada_375_clk_gating, \"marvell,armada-375-gating-clock\",\n\t       armada_375_clk_gating_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}