{
  "module_name": "common.c",
  "hash_id": "c2ba5a641f99f1e78e3771362b2c156b1da1b92ce385de5c38b86217f37f25c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mvebu/common.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/syscore_ops.h>\n\n#include \"common.h\"\n\n \n\n#define SSCG_CONF_MODE(reg)\t(((reg) >> 16) & 0x3)\n#define SSCG_SPREAD_DOWN\t0x0\n#define SSCG_SPREAD_UP\t\t0x1\n#define SSCG_SPREAD_CENTRAL\t0x2\n#define SSCG_CONF_LOW(reg)\t(((reg) >> 8) & 0xFF)\n#define SSCG_CONF_HIGH(reg)\t((reg) & 0xFF)\n\nstatic struct clk_onecell_data clk_data;\n\n \nu32 kirkwood_fix_sscg_deviation(u32 system_clk)\n{\n\tstruct device_node *sscg_np = NULL;\n\tvoid __iomem *sscg_map;\n\tu32 sscg_reg;\n\ts32 low_bound, high_bound;\n\tu64 freq_swing_half;\n\n\tsscg_np = of_find_node_by_name(NULL, \"sscg\");\n\tif (sscg_np == NULL) {\n\t\tpr_err(\"cannot get SSCG register node\\n\");\n\t\treturn system_clk;\n\t}\n\n\tsscg_map = of_iomap(sscg_np, 0);\n\tif (sscg_map == NULL) {\n\t\tpr_err(\"cannot map SSCG register\\n\");\n\t\tgoto out;\n\t}\n\n\tsscg_reg = readl(sscg_map);\n\thigh_bound = SSCG_CONF_HIGH(sscg_reg);\n\tlow_bound = SSCG_CONF_LOW(sscg_reg);\n\n\tif ((high_bound - low_bound) <= 0)\n\t\tgoto out;\n\t \n\n\tfreq_swing_half = (((u64)high_bound - (u64)low_bound)\n\t\t\t* (u64)system_clk);\n\tdo_div(freq_swing_half, (2 * 96 * high_bound));\n\n\tswitch (SSCG_CONF_MODE(sscg_reg)) {\n\tcase SSCG_SPREAD_DOWN:\n\t\tsystem_clk -= freq_swing_half;\n\t\tbreak;\n\tcase SSCG_SPREAD_UP:\n\t\tsystem_clk += freq_swing_half;\n\t\tbreak;\n\tcase SSCG_SPREAD_CENTRAL:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tiounmap(sscg_map);\n\nout:\n\tof_node_put(sscg_np);\n\n\treturn system_clk;\n}\n\nvoid __init mvebu_coreclk_setup(struct device_node *np,\n\t\t\t\tconst struct coreclk_soc_desc *desc)\n{\n\tconst char *tclk_name = \"tclk\";\n\tconst char *cpuclk_name = \"cpuclk\";\n\tvoid __iomem *base;\n\tunsigned long rate;\n\tint n;\n\n\tbase = of_iomap(np, 0);\n\tif (WARN_ON(!base))\n\t\treturn;\n\n\t \n\tclk_data.clk_num = 2 + desc->num_ratios;\n\n\t \n\tif (desc->get_refclk_freq)\n\t\tclk_data.clk_num += 1;\n\n\tclk_data.clks = kcalloc(clk_data.clk_num, sizeof(*clk_data.clks),\n\t\t\t\tGFP_KERNEL);\n\tif (WARN_ON(!clk_data.clks)) {\n\t\tiounmap(base);\n\t\treturn;\n\t}\n\n\t \n\tof_property_read_string_index(np, \"clock-output-names\", 0,\n\t\t\t\t      &tclk_name);\n\trate = desc->get_tclk_freq(base);\n\tclk_data.clks[0] = clk_register_fixed_rate(NULL, tclk_name, NULL, 0,\n\t\t\t\t\t\t   rate);\n\tWARN_ON(IS_ERR(clk_data.clks[0]));\n\n\t \n\tof_property_read_string_index(np, \"clock-output-names\", 1,\n\t\t\t\t      &cpuclk_name);\n\trate = desc->get_cpu_freq(base);\n\n\tif (desc->is_sscg_enabled && desc->fix_sscg_deviation\n\t\t&& desc->is_sscg_enabled(base))\n\t\trate = desc->fix_sscg_deviation(rate);\n\n\tclk_data.clks[1] = clk_register_fixed_rate(NULL, cpuclk_name, NULL, 0,\n\t\t\t\t\t\t   rate);\n\tWARN_ON(IS_ERR(clk_data.clks[1]));\n\n\t \n\tfor (n = 0; n < desc->num_ratios; n++) {\n\t\tconst char *rclk_name = desc->ratios[n].name;\n\t\tint mult, div;\n\n\t\tof_property_read_string_index(np, \"clock-output-names\",\n\t\t\t\t\t      2+n, &rclk_name);\n\t\tdesc->get_clk_ratio(base, desc->ratios[n].id, &mult, &div);\n\t\tclk_data.clks[2+n] = clk_register_fixed_factor(NULL, rclk_name,\n\t\t\t\t       cpuclk_name, 0, mult, div);\n\t\tWARN_ON(IS_ERR(clk_data.clks[2+n]));\n\t}\n\n\t \n\tif (desc->get_refclk_freq) {\n\t\tconst char *name = \"refclk\";\n\t\tof_property_read_string_index(np, \"clock-output-names\",\n\t\t\t\t\t      2 + desc->num_ratios, &name);\n\t\trate = desc->get_refclk_freq(base);\n\t\tclk_data.clks[2 + desc->num_ratios] =\n\t\t\tclk_register_fixed_rate(NULL, name, NULL, 0, rate);\n\t\tWARN_ON(IS_ERR(clk_data.clks[2 + desc->num_ratios]));\n\t}\n\n\t \n\tiounmap(base);\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);\n}\n\n \n\nDEFINE_SPINLOCK(ctrl_gating_lock);\n\nstruct clk_gating_ctrl {\n\tspinlock_t *lock;\n\tstruct clk **gates;\n\tint num_gates;\n\tvoid __iomem *base;\n\tu32 saved_reg;\n};\n\nstatic struct clk_gating_ctrl *ctrl;\n\nstatic struct clk *clk_gating_get_src(\n\tstruct of_phandle_args *clkspec, void *data)\n{\n\tint n;\n\n\tif (clkspec->args_count < 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (n = 0; n < ctrl->num_gates; n++) {\n\t\tstruct clk_gate *gate =\n\t\t\tto_clk_gate(__clk_get_hw(ctrl->gates[n]));\n\t\tif (clkspec->args[0] == gate->bit_idx)\n\t\t\treturn ctrl->gates[n];\n\t}\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic int mvebu_clk_gating_suspend(void)\n{\n\tctrl->saved_reg = readl(ctrl->base);\n\treturn 0;\n}\n\nstatic void mvebu_clk_gating_resume(void)\n{\n\twritel(ctrl->saved_reg, ctrl->base);\n}\n\nstatic struct syscore_ops clk_gate_syscore_ops = {\n\t.suspend = mvebu_clk_gating_suspend,\n\t.resume = mvebu_clk_gating_resume,\n};\n\nvoid __init mvebu_clk_gating_setup(struct device_node *np,\n\t\t\t\t   const struct clk_gating_soc_desc *desc)\n{\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tconst char *default_parent = NULL;\n\tint n;\n\n\tif (ctrl) {\n\t\tpr_err(\"mvebu-clk-gating: cannot instantiate more than one gateable clock device\\n\");\n\t\treturn;\n\t}\n\n\tbase = of_iomap(np, 0);\n\tif (WARN_ON(!base))\n\t\treturn;\n\n\tclk = of_clk_get(np, 0);\n\tif (!IS_ERR(clk)) {\n\t\tdefault_parent = __clk_get_name(clk);\n\t\tclk_put(clk);\n\t}\n\n\tctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);\n\tif (WARN_ON(!ctrl))\n\t\tgoto ctrl_out;\n\n\t \n\tctrl->lock = &ctrl_gating_lock;\n\n\tctrl->base = base;\n\n\t \n\tfor (n = 0; desc[n].name;)\n\t\tn++;\n\n\tctrl->num_gates = n;\n\tctrl->gates = kcalloc(ctrl->num_gates, sizeof(*ctrl->gates),\n\t\t\t      GFP_KERNEL);\n\tif (WARN_ON(!ctrl->gates))\n\t\tgoto gates_out;\n\n\tfor (n = 0; n < ctrl->num_gates; n++) {\n\t\tconst char *parent =\n\t\t\t(desc[n].parent) ? desc[n].parent : default_parent;\n\t\tctrl->gates[n] = clk_register_gate(NULL, desc[n].name, parent,\n\t\t\t\t\tdesc[n].flags, base, desc[n].bit_idx,\n\t\t\t\t\t0, ctrl->lock);\n\t\tWARN_ON(IS_ERR(ctrl->gates[n]));\n\t}\n\n\tof_clk_add_provider(np, clk_gating_get_src, ctrl);\n\n\tregister_syscore_ops(&clk_gate_syscore_ops);\n\n\treturn;\ngates_out:\n\tkfree(ctrl);\nctrl_out:\n\tiounmap(base);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}