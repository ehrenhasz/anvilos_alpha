{
  "module_name": "clk-k210.c",
  "hash_id": "1e034c00147d1473e27010db111aa0a2a175276fddc4ba34ead7bd9cc9397eff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-k210.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt)     \"k210-clk: \" fmt\n\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_clk.h>\n#include <linux/of_address.h>\n#include <linux/clk-provider.h>\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <soc/canaan/k210-sysctl.h>\n\n#include <dt-bindings/clock/k210-clk.h>\n\nstruct k210_sysclk;\n\nstruct k210_clk {\n\tint id;\n\tstruct k210_sysclk *ksc;\n\tstruct clk_hw hw;\n};\n\nstruct k210_clk_cfg {\n\tconst char *name;\n\tu8 gate_reg;\n\tu8 gate_bit;\n\tu8 div_reg;\n\tu8 div_shift;\n\tu8 div_width;\n\tu8 div_type;\n\tu8 mux_reg;\n\tu8 mux_bit;\n};\n\nenum k210_clk_div_type {\n\tK210_DIV_NONE,\n\tK210_DIV_ONE_BASED,\n\tK210_DIV_DOUBLE_ONE_BASED,\n\tK210_DIV_POWER_OF_TWO,\n};\n\n#define K210_GATE(_reg, _bit)\t\\\n\t.gate_reg = (_reg),\t\\\n\t.gate_bit = (_bit)\n\n#define K210_DIV(_reg, _shift, _width, _type)\t\\\n\t.div_reg = (_reg),\t\t\t\\\n\t.div_shift = (_shift),\t\t\t\\\n\t.div_width = (_width),\t\t\t\\\n\t.div_type = (_type)\n\n#define K210_MUX(_reg, _bit)\t\\\n\t.mux_reg = (_reg),\t\\\n\t.mux_bit = (_bit)\n\nstatic struct k210_clk_cfg k210_clk_cfgs[K210_NUM_CLKS] = {\n\t \n\t[K210_CLK_CPU] = {\n\t\t.name = \"cpu\",\n\t\tK210_GATE(K210_SYSCTL_EN_CENT, 0)\n\t},\n\t[K210_CLK_DMA] = {\n\t\t.name = \"dma\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 1)\n\t},\n\t[K210_CLK_FFT] = {\n\t\t.name = \"fft\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 4)\n\t},\n\t[K210_CLK_GPIO] = {\n\t\t.name = \"gpio\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 5)\n\t},\n\t[K210_CLK_UART1] = {\n\t\t.name = \"uart1\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 16)\n\t},\n\t[K210_CLK_UART2] = {\n\t\t.name = \"uart2\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 17)\n\t},\n\t[K210_CLK_UART3] = {\n\t\t.name = \"uart3\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 18)\n\t},\n\t[K210_CLK_FPIOA] = {\n\t\t.name = \"fpioa\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 20)\n\t},\n\t[K210_CLK_SHA] = {\n\t\t.name = \"sha\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 26)\n\t},\n\t[K210_CLK_AES] = {\n\t\t.name = \"aes\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 19)\n\t},\n\t[K210_CLK_OTP] = {\n\t\t.name = \"otp\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 27)\n\t},\n\t[K210_CLK_RTC] = {\n\t\t.name = \"rtc\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 29)\n\t},\n\n\t \n\t[K210_CLK_SRAM0] = {\n\t\t.name = \"sram0\",\n\t\tK210_GATE(K210_SYSCTL_EN_CENT, 1),\n\t\tK210_DIV(K210_SYSCTL_THR0, 0, 4, K210_DIV_ONE_BASED)\n\t},\n\t[K210_CLK_SRAM1] = {\n\t\t.name = \"sram1\",\n\t\tK210_GATE(K210_SYSCTL_EN_CENT, 2),\n\t\tK210_DIV(K210_SYSCTL_THR0, 4, 4, K210_DIV_ONE_BASED)\n\t},\n\t[K210_CLK_ROM] = {\n\t\t.name = \"rom\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 0),\n\t\tK210_DIV(K210_SYSCTL_THR0, 16, 4, K210_DIV_ONE_BASED)\n\t},\n\t[K210_CLK_DVP] = {\n\t\t.name = \"dvp\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 3),\n\t\tK210_DIV(K210_SYSCTL_THR0, 12, 4, K210_DIV_ONE_BASED)\n\t},\n\t[K210_CLK_APB0] = {\n\t\t.name = \"apb0\",\n\t\tK210_GATE(K210_SYSCTL_EN_CENT, 3),\n\t\tK210_DIV(K210_SYSCTL_SEL0, 3, 3, K210_DIV_ONE_BASED)\n\t},\n\t[K210_CLK_APB1] = {\n\t\t.name = \"apb1\",\n\t\tK210_GATE(K210_SYSCTL_EN_CENT, 4),\n\t\tK210_DIV(K210_SYSCTL_SEL0, 6, 3, K210_DIV_ONE_BASED)\n\t},\n\t[K210_CLK_APB2] = {\n\t\t.name = \"apb2\",\n\t\tK210_GATE(K210_SYSCTL_EN_CENT, 5),\n\t\tK210_DIV(K210_SYSCTL_SEL0, 9, 3, K210_DIV_ONE_BASED)\n\t},\n\t[K210_CLK_AI] = {\n\t\t.name = \"ai\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 2),\n\t\tK210_DIV(K210_SYSCTL_THR0, 8, 4, K210_DIV_ONE_BASED)\n\t},\n\t[K210_CLK_SPI0] = {\n\t\t.name = \"spi0\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 6),\n\t\tK210_DIV(K210_SYSCTL_THR1, 0, 8, K210_DIV_DOUBLE_ONE_BASED)\n\t},\n\t[K210_CLK_SPI1] = {\n\t\t.name = \"spi1\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 7),\n\t\tK210_DIV(K210_SYSCTL_THR1, 8, 8, K210_DIV_DOUBLE_ONE_BASED)\n\t},\n\t[K210_CLK_SPI2] = {\n\t\t.name = \"spi2\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 8),\n\t\tK210_DIV(K210_SYSCTL_THR1, 16, 8, K210_DIV_DOUBLE_ONE_BASED)\n\t},\n\t[K210_CLK_I2C0] = {\n\t\t.name = \"i2c0\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 13),\n\t\tK210_DIV(K210_SYSCTL_THR5, 8, 8, K210_DIV_DOUBLE_ONE_BASED)\n\t},\n\t[K210_CLK_I2C1] = {\n\t\t.name = \"i2c1\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 14),\n\t\tK210_DIV(K210_SYSCTL_THR5, 16, 8, K210_DIV_DOUBLE_ONE_BASED)\n\t},\n\t[K210_CLK_I2C2] = {\n\t\t.name = \"i2c2\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 15),\n\t\tK210_DIV(K210_SYSCTL_THR5, 24, 8, K210_DIV_DOUBLE_ONE_BASED)\n\t},\n\t[K210_CLK_WDT0] = {\n\t\t.name = \"wdt0\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 24),\n\t\tK210_DIV(K210_SYSCTL_THR6, 0, 8, K210_DIV_DOUBLE_ONE_BASED)\n\t},\n\t[K210_CLK_WDT1] = {\n\t\t.name = \"wdt1\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 25),\n\t\tK210_DIV(K210_SYSCTL_THR6, 8, 8, K210_DIV_DOUBLE_ONE_BASED)\n\t},\n\t[K210_CLK_I2S0] = {\n\t\t.name = \"i2s0\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 10),\n\t\tK210_DIV(K210_SYSCTL_THR3, 0, 16, K210_DIV_DOUBLE_ONE_BASED)\n\t},\n\t[K210_CLK_I2S1] = {\n\t\t.name = \"i2s1\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 11),\n\t\tK210_DIV(K210_SYSCTL_THR3, 16, 16, K210_DIV_DOUBLE_ONE_BASED)\n\t},\n\t[K210_CLK_I2S2] = {\n\t\t.name = \"i2s2\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 12),\n\t\tK210_DIV(K210_SYSCTL_THR4, 0, 16, K210_DIV_DOUBLE_ONE_BASED)\n\t},\n\n\t \n\t[K210_CLK_I2S0_M] = {\n\t\t.name = \"i2s0_m\",\n\t\tK210_DIV(K210_SYSCTL_THR4, 16, 8, K210_DIV_DOUBLE_ONE_BASED)\n\t},\n\t[K210_CLK_I2S1_M] = {\n\t\t.name = \"i2s1_m\",\n\t\tK210_DIV(K210_SYSCTL_THR4, 24, 8, K210_DIV_DOUBLE_ONE_BASED)\n\t},\n\t[K210_CLK_I2S2_M] = {\n\t\t.name = \"i2s2_m\",\n\t\tK210_DIV(K210_SYSCTL_THR4, 0, 8, K210_DIV_DOUBLE_ONE_BASED)\n\t},\n\n\t \n\t[K210_CLK_SPI3] = {\n\t\t.name = \"spi3\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 9),\n\t\tK210_DIV(K210_SYSCTL_THR1, 24, 8, K210_DIV_DOUBLE_ONE_BASED),\n\t\tK210_MUX(K210_SYSCTL_SEL0, 12)\n\t},\n\t[K210_CLK_TIMER0] = {\n\t\t.name = \"timer0\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 21),\n\t\tK210_DIV(K210_SYSCTL_THR2,  0, 8, K210_DIV_DOUBLE_ONE_BASED),\n\t\tK210_MUX(K210_SYSCTL_SEL0, 13)\n\t},\n\t[K210_CLK_TIMER1] = {\n\t\t.name = \"timer1\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 22),\n\t\tK210_DIV(K210_SYSCTL_THR2, 8, 8, K210_DIV_DOUBLE_ONE_BASED),\n\t\tK210_MUX(K210_SYSCTL_SEL0, 14)\n\t},\n\t[K210_CLK_TIMER2] = {\n\t\t.name = \"timer2\",\n\t\tK210_GATE(K210_SYSCTL_EN_PERI, 23),\n\t\tK210_DIV(K210_SYSCTL_THR2, 16, 8, K210_DIV_DOUBLE_ONE_BASED),\n\t\tK210_MUX(K210_SYSCTL_SEL0, 15)\n\t},\n};\n\n \n#define K210_PLL_CLKR\t\tGENMASK(3, 0)\n#define K210_PLL_CLKF\t\tGENMASK(9, 4)\n#define K210_PLL_CLKOD\t\tGENMASK(13, 10)\n#define K210_PLL_BWADJ\t\tGENMASK(19, 14)\n#define K210_PLL_RESET\t\t(1 << 20)\n#define K210_PLL_PWRD\t\t(1 << 21)\n#define K210_PLL_INTFB\t\t(1 << 22)\n#define K210_PLL_BYPASS\t\t(1 << 23)\n#define K210_PLL_TEST\t\t(1 << 24)\n#define K210_PLL_EN\t\t(1 << 25)\n#define K210_PLL_SEL\t\tGENMASK(27, 26)  \n\n \n#define K210_PLL_LOCK\t\t0\n#define K210_PLL_CLEAR_SLIP\t2\n#define K210_PLL_TEST_OUT\t3\n\n \n#define K210_ACLK_SEL\t\tBIT(0)\n#define K210_ACLK_DIV\t\tGENMASK(2, 1)\n\n \nenum k210_pll_id {\n\tK210_PLL0, K210_PLL1, K210_PLL2, K210_PLL_NUM\n};\n\nstruct k210_pll {\n\tenum k210_pll_id id;\n\tstruct k210_sysclk *ksc;\n\tvoid __iomem *base;\n\tvoid __iomem *reg;\n\tvoid __iomem *lock;\n\tu8 lock_shift;\n\tu8 lock_width;\n\tstruct clk_hw hw;\n};\n#define to_k210_pll(_hw)\tcontainer_of(_hw, struct k210_pll, hw)\n\n \nstruct k210_pll_cfg {\n\tu32 reg;\n\tu8 lock_shift;\n\tu8 lock_width;\n\tu32 r;\n\tu32 f;\n\tu32 od;\n\tu32 bwadj;\n};\n\nstatic struct k210_pll_cfg k210_plls_cfg[] = {\n\t{ K210_SYSCTL_PLL0,  0, 2, 0, 59, 1, 59 },  \n\t{ K210_SYSCTL_PLL1,  8, 1, 0, 59, 3, 59 },  \n\t{ K210_SYSCTL_PLL2, 16, 1, 0, 22, 1, 22 },  \n};\n\n \nstruct k210_sysclk {\n\tvoid __iomem\t\t\t*regs;\n\tspinlock_t\t\t\tclk_lock;\n\tstruct k210_pll\t\t\tplls[K210_PLL_NUM];\n\tstruct clk_hw\t\t\taclk;\n\tstruct k210_clk\t\t\tclks[K210_NUM_CLKS];\n};\n\n#define to_k210_sysclk(_hw)\tcontainer_of(_hw, struct k210_sysclk, aclk)\n\n \nstatic void k210_aclk_set_selector(void __iomem *regs, u8 sel)\n{\n\tu32 reg = readl(regs + K210_SYSCTL_SEL0);\n\n\tif (sel)\n\t\treg |= K210_ACLK_SEL;\n\telse\n\t\treg &= K210_ACLK_SEL;\n\twritel(reg, regs + K210_SYSCTL_SEL0);\n}\n\nstatic void k210_init_pll(void __iomem *regs, enum k210_pll_id pllid,\n\t\t\t  struct k210_pll *pll)\n{\n\tpll->id = pllid;\n\tpll->reg = regs + k210_plls_cfg[pllid].reg;\n\tpll->lock = regs + K210_SYSCTL_PLL_LOCK;\n\tpll->lock_shift = k210_plls_cfg[pllid].lock_shift;\n\tpll->lock_width = k210_plls_cfg[pllid].lock_width;\n}\n\nstatic void k210_pll_wait_for_lock(struct k210_pll *pll)\n{\n\tu32 reg, mask = GENMASK(pll->lock_shift + pll->lock_width - 1,\n\t\t\t\tpll->lock_shift);\n\n\twhile (true) {\n\t\treg = readl(pll->lock);\n\t\tif ((reg & mask) == mask)\n\t\t\tbreak;\n\n\t\treg |= BIT(pll->lock_shift + K210_PLL_CLEAR_SLIP);\n\t\twritel(reg, pll->lock);\n\t}\n}\n\nstatic bool k210_pll_hw_is_enabled(struct k210_pll *pll)\n{\n\tu32 reg = readl(pll->reg);\n\tu32 mask = K210_PLL_PWRD | K210_PLL_EN;\n\n\tif (reg & K210_PLL_RESET)\n\t\treturn false;\n\n\treturn (reg & mask) == mask;\n}\n\nstatic void k210_pll_enable_hw(void __iomem *regs, struct k210_pll *pll)\n{\n\tstruct k210_pll_cfg *pll_cfg = &k210_plls_cfg[pll->id];\n\tu32 reg;\n\n\tif (k210_pll_hw_is_enabled(pll))\n\t\treturn;\n\n\t \n\tif (pll->id == K210_PLL0)\n\t\tk210_aclk_set_selector(regs, 0);\n\n\t \n\treg = readl(pll->reg);\n\treg &= ~GENMASK(19, 0);\n\treg |= FIELD_PREP(K210_PLL_CLKR, pll_cfg->r);\n\treg |= FIELD_PREP(K210_PLL_CLKF, pll_cfg->f);\n\treg |= FIELD_PREP(K210_PLL_CLKOD, pll_cfg->od);\n\treg |= FIELD_PREP(K210_PLL_BWADJ, pll_cfg->bwadj);\n\treg |= K210_PLL_PWRD;\n\twritel(reg, pll->reg);\n\n\t \n\treg &= ~K210_PLL_RESET;\n\twritel(reg, pll->reg);\n\treg |= K210_PLL_RESET;\n\twritel(reg, pll->reg);\n\tnop();\n\tnop();\n\treg &= ~K210_PLL_RESET;\n\twritel(reg, pll->reg);\n\n\tk210_pll_wait_for_lock(pll);\n\n\treg &= ~K210_PLL_BYPASS;\n\treg |= K210_PLL_EN;\n\twritel(reg, pll->reg);\n\n\tif (pll->id == K210_PLL0)\n\t\tk210_aclk_set_selector(regs, 1);\n}\n\nstatic int k210_pll_enable(struct clk_hw *hw)\n{\n\tstruct k210_pll *pll = to_k210_pll(hw);\n\tstruct k210_sysclk *ksc = pll->ksc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ksc->clk_lock, flags);\n\n\tk210_pll_enable_hw(ksc->regs, pll);\n\n\tspin_unlock_irqrestore(&ksc->clk_lock, flags);\n\n\treturn 0;\n}\n\nstatic void k210_pll_disable(struct clk_hw *hw)\n{\n\tstruct k210_pll *pll = to_k210_pll(hw);\n\tstruct k210_sysclk *ksc = pll->ksc;\n\tunsigned long flags;\n\tu32 reg;\n\n\t \n\tspin_lock_irqsave(&ksc->clk_lock, flags);\n\treg = readl(pll->reg);\n\treg |= K210_PLL_BYPASS;\n\twritel(reg, pll->reg);\n\n\treg &= ~K210_PLL_PWRD;\n\treg &= ~K210_PLL_EN;\n\twritel(reg, pll->reg);\n\tspin_unlock_irqrestore(&ksc->clk_lock, flags);\n}\n\nstatic int k210_pll_is_enabled(struct clk_hw *hw)\n{\n\treturn k210_pll_hw_is_enabled(to_k210_pll(hw));\n}\n\nstatic unsigned long k210_pll_get_rate(struct clk_hw *hw,\n\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct k210_pll *pll = to_k210_pll(hw);\n\tu32 reg = readl(pll->reg);\n\tu32 r, f, od;\n\n\tif (reg & K210_PLL_BYPASS)\n\t\treturn parent_rate;\n\n\tif (!(reg & K210_PLL_PWRD))\n\t\treturn 0;\n\n\tr = FIELD_GET(K210_PLL_CLKR, reg) + 1;\n\tf = FIELD_GET(K210_PLL_CLKF, reg) + 1;\n\tod = FIELD_GET(K210_PLL_CLKOD, reg) + 1;\n\n\treturn div_u64((u64)parent_rate * f, r * od);\n}\n\nstatic const struct clk_ops k210_pll_ops = {\n\t.enable\t\t= k210_pll_enable,\n\t.disable\t= k210_pll_disable,\n\t.is_enabled\t= k210_pll_is_enabled,\n\t.recalc_rate\t= k210_pll_get_rate,\n};\n\nstatic int k210_pll2_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct k210_pll *pll = to_k210_pll(hw);\n\tstruct k210_sysclk *ksc = pll->ksc;\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&ksc->clk_lock, flags);\n\n\treg = readl(pll->reg);\n\treg &= ~K210_PLL_SEL;\n\treg |= FIELD_PREP(K210_PLL_SEL, index);\n\twritel(reg, pll->reg);\n\n\tspin_unlock_irqrestore(&ksc->clk_lock, flags);\n\n\treturn 0;\n}\n\nstatic u8 k210_pll2_get_parent(struct clk_hw *hw)\n{\n\tstruct k210_pll *pll = to_k210_pll(hw);\n\tu32 reg = readl(pll->reg);\n\n\treturn FIELD_GET(K210_PLL_SEL, reg);\n}\n\nstatic const struct clk_ops k210_pll2_ops = {\n\t.enable\t\t= k210_pll_enable,\n\t.disable\t= k210_pll_disable,\n\t.is_enabled\t= k210_pll_is_enabled,\n\t.recalc_rate\t= k210_pll_get_rate,\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.set_parent\t= k210_pll2_set_parent,\n\t.get_parent\t= k210_pll2_get_parent,\n};\n\nstatic int __init k210_register_pll(struct device_node *np,\n\t\t\t\t    struct k210_sysclk *ksc,\n\t\t\t\t    enum k210_pll_id pllid, const char *name,\n\t\t\t\t    int num_parents, const struct clk_ops *ops)\n{\n\tstruct k210_pll *pll = &ksc->plls[pllid];\n\tstruct clk_init_data init = {};\n\tconst struct clk_parent_data parent_data[] = {\n\t\t{   },\n\t\t{ .hw = &ksc->plls[K210_PLL0].hw },\n\t\t{ .hw = &ksc->plls[K210_PLL1].hw },\n\t};\n\n\tinit.name = name;\n\tinit.parent_data = parent_data;\n\tinit.num_parents = num_parents;\n\tinit.ops = ops;\n\n\tpll->hw.init = &init;\n\tpll->ksc = ksc;\n\n\treturn of_clk_hw_register(np, &pll->hw);\n}\n\nstatic int __init k210_register_plls(struct device_node *np,\n\t\t\t\t     struct k210_sysclk *ksc)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < K210_PLL_NUM; i++)\n\t\tk210_init_pll(ksc->regs, i, &ksc->plls[i]);\n\n\t \n\tret = k210_register_pll(np, ksc, K210_PLL0, \"pll0\", 1, &k210_pll_ops);\n\tif (ret) {\n\t\tpr_err(\"%pOFP: register PLL0 failed\\n\", np);\n\t\treturn ret;\n\t}\n\tret = k210_register_pll(np, ksc, K210_PLL1, \"pll1\", 1, &k210_pll_ops);\n\tif (ret) {\n\t\tpr_err(\"%pOFP: register PLL1 failed\\n\", np);\n\t\treturn ret;\n\t}\n\n\t \n\tret = k210_register_pll(np, ksc, K210_PLL2, \"pll2\", 3, &k210_pll2_ops);\n\tif (ret) {\n\t\tpr_err(\"%pOFP: register PLL2 failed\\n\", np);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int k210_aclk_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct k210_sysclk *ksc = to_k210_sysclk(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ksc->clk_lock, flags);\n\n\tk210_aclk_set_selector(ksc->regs, index);\n\n\tspin_unlock_irqrestore(&ksc->clk_lock, flags);\n\n\treturn 0;\n}\n\nstatic u8 k210_aclk_get_parent(struct clk_hw *hw)\n{\n\tstruct k210_sysclk *ksc = to_k210_sysclk(hw);\n\tu32 sel;\n\n\tsel = readl(ksc->regs + K210_SYSCTL_SEL0) & K210_ACLK_SEL;\n\n\treturn sel ? 1 : 0;\n}\n\nstatic unsigned long k210_aclk_get_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct k210_sysclk *ksc = to_k210_sysclk(hw);\n\tu32 reg = readl(ksc->regs + K210_SYSCTL_SEL0);\n\tunsigned int shift;\n\n\tif (!(reg & 0x1))\n\t\treturn parent_rate;\n\n\tshift = FIELD_GET(K210_ACLK_DIV, reg);\n\n\treturn parent_rate / (2UL << shift);\n}\n\nstatic const struct clk_ops k210_aclk_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.set_parent\t= k210_aclk_set_parent,\n\t.get_parent\t= k210_aclk_get_parent,\n\t.recalc_rate\t= k210_aclk_get_rate,\n};\n\n \nstatic int __init k210_register_aclk(struct device_node *np,\n\t\t\t\t     struct k210_sysclk *ksc)\n{\n\tstruct clk_init_data init = {};\n\tconst struct clk_parent_data parent_data[] = {\n\t\t{   },\n\t\t{ .hw = &ksc->plls[K210_PLL0].hw },\n\t};\n\tint ret;\n\n\tinit.name = \"aclk\";\n\tinit.parent_data = parent_data;\n\tinit.num_parents = 2;\n\tinit.ops = &k210_aclk_ops;\n\tksc->aclk.init = &init;\n\n\tret = of_clk_hw_register(np, &ksc->aclk);\n\tif (ret) {\n\t\tpr_err(\"%pOFP: register aclk failed\\n\", np);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#define to_k210_clk(_hw)\tcontainer_of(_hw, struct k210_clk, hw)\n\nstatic int k210_clk_enable(struct clk_hw *hw)\n{\n\tstruct k210_clk *kclk = to_k210_clk(hw);\n\tstruct k210_sysclk *ksc = kclk->ksc;\n\tstruct k210_clk_cfg *cfg = &k210_clk_cfgs[kclk->id];\n\tunsigned long flags;\n\tu32 reg;\n\n\tif (!cfg->gate_reg)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&ksc->clk_lock, flags);\n\treg = readl(ksc->regs + cfg->gate_reg);\n\treg |= BIT(cfg->gate_bit);\n\twritel(reg, ksc->regs + cfg->gate_reg);\n\tspin_unlock_irqrestore(&ksc->clk_lock, flags);\n\n\treturn 0;\n}\n\nstatic void k210_clk_disable(struct clk_hw *hw)\n{\n\tstruct k210_clk *kclk = to_k210_clk(hw);\n\tstruct k210_sysclk *ksc = kclk->ksc;\n\tstruct k210_clk_cfg *cfg = &k210_clk_cfgs[kclk->id];\n\tunsigned long flags;\n\tu32 reg;\n\n\tif (!cfg->gate_reg)\n\t\treturn;\n\n\tspin_lock_irqsave(&ksc->clk_lock, flags);\n\treg = readl(ksc->regs + cfg->gate_reg);\n\treg &= ~BIT(cfg->gate_bit);\n\twritel(reg, ksc->regs + cfg->gate_reg);\n\tspin_unlock_irqrestore(&ksc->clk_lock, flags);\n}\n\nstatic int k210_clk_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct k210_clk *kclk = to_k210_clk(hw);\n\tstruct k210_sysclk *ksc = kclk->ksc;\n\tstruct k210_clk_cfg *cfg = &k210_clk_cfgs[kclk->id];\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&ksc->clk_lock, flags);\n\treg = readl(ksc->regs + cfg->mux_reg);\n\tif (index)\n\t\treg |= BIT(cfg->mux_bit);\n\telse\n\t\treg &= ~BIT(cfg->mux_bit);\n\twritel(reg, ksc->regs + cfg->mux_reg);\n\tspin_unlock_irqrestore(&ksc->clk_lock, flags);\n\n\treturn 0;\n}\n\nstatic u8 k210_clk_get_parent(struct clk_hw *hw)\n{\n\tstruct k210_clk *kclk = to_k210_clk(hw);\n\tstruct k210_sysclk *ksc = kclk->ksc;\n\tstruct k210_clk_cfg *cfg = &k210_clk_cfgs[kclk->id];\n\tunsigned long flags;\n\tu32 reg, idx;\n\n\tspin_lock_irqsave(&ksc->clk_lock, flags);\n\treg = readl(ksc->regs + cfg->mux_reg);\n\tidx = (reg & BIT(cfg->mux_bit)) ? 1 : 0;\n\tspin_unlock_irqrestore(&ksc->clk_lock, flags);\n\n\treturn idx;\n}\n\nstatic unsigned long k210_clk_get_rate(struct clk_hw *hw,\n\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct k210_clk *kclk = to_k210_clk(hw);\n\tstruct k210_sysclk *ksc = kclk->ksc;\n\tstruct k210_clk_cfg *cfg = &k210_clk_cfgs[kclk->id];\n\tu32 reg, div_val;\n\n\tif (!cfg->div_reg)\n\t\treturn parent_rate;\n\n\treg = readl(ksc->regs + cfg->div_reg);\n\tdiv_val = (reg >> cfg->div_shift) & GENMASK(cfg->div_width - 1, 0);\n\n\tswitch (cfg->div_type) {\n\tcase K210_DIV_ONE_BASED:\n\t\treturn parent_rate / (div_val + 1);\n\tcase K210_DIV_DOUBLE_ONE_BASED:\n\t\treturn parent_rate / ((div_val + 1) * 2);\n\tcase K210_DIV_POWER_OF_TWO:\n\t\treturn parent_rate / (2UL << div_val);\n\tcase K210_DIV_NONE:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct clk_ops k210_clk_mux_ops = {\n\t.enable\t\t= k210_clk_enable,\n\t.disable\t= k210_clk_disable,\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.set_parent\t= k210_clk_set_parent,\n\t.get_parent\t= k210_clk_get_parent,\n\t.recalc_rate\t= k210_clk_get_rate,\n};\n\nstatic const struct clk_ops k210_clk_ops = {\n\t.enable\t\t= k210_clk_enable,\n\t.disable\t= k210_clk_disable,\n\t.recalc_rate\t= k210_clk_get_rate,\n};\n\nstatic void __init k210_register_clk(struct device_node *np,\n\t\t\t\t     struct k210_sysclk *ksc, int id,\n\t\t\t\t     const struct clk_parent_data *parent_data,\n\t\t\t\t     int num_parents, unsigned long flags)\n{\n\tstruct k210_clk *kclk = &ksc->clks[id];\n\tstruct clk_init_data init = {};\n\tint ret;\n\n\tinit.name = k210_clk_cfgs[id].name;\n\tinit.flags = flags;\n\tinit.parent_data = parent_data;\n\tinit.num_parents = num_parents;\n\tif (num_parents > 1)\n\t\tinit.ops = &k210_clk_mux_ops;\n\telse\n\t\tinit.ops = &k210_clk_ops;\n\n\tkclk->id = id;\n\tkclk->ksc = ksc;\n\tkclk->hw.init = &init;\n\n\tret = of_clk_hw_register(np, &kclk->hw);\n\tif (ret) {\n\t\tpr_err(\"%pOFP: register clock %s failed\\n\",\n\t\t       np, k210_clk_cfgs[id].name);\n\t\tkclk->id = -1;\n\t}\n}\n\n \nstatic inline void __init k210_register_mux_clk(struct device_node *np,\n\t\t\t\t\t\tstruct k210_sysclk *ksc, int id)\n{\n\tconst struct clk_parent_data parent_data[2] = {\n\t\t{   },\n\t\t{ .hw = &ksc->plls[K210_PLL0].hw }\n\t};\n\n\tk210_register_clk(np, ksc, id, parent_data, 2, 0);\n}\n\nstatic inline void __init k210_register_in0_child(struct device_node *np,\n\t\t\t\t\t\tstruct k210_sysclk *ksc, int id)\n{\n\tconst struct clk_parent_data parent_data = {\n\t\t \n\t};\n\n\tk210_register_clk(np, ksc, id, &parent_data, 1, 0);\n}\n\nstatic inline void __init k210_register_pll_child(struct device_node *np,\n\t\t\t\t\t\tstruct k210_sysclk *ksc, int id,\n\t\t\t\t\t\tenum k210_pll_id pllid,\n\t\t\t\t\t\tunsigned long flags)\n{\n\tconst struct clk_parent_data parent_data = {\n\t\t.hw = &ksc->plls[pllid].hw,\n\t};\n\n\tk210_register_clk(np, ksc, id, &parent_data, 1, flags);\n}\n\nstatic inline void __init k210_register_aclk_child(struct device_node *np,\n\t\t\t\t\t\tstruct k210_sysclk *ksc, int id,\n\t\t\t\t\t\tunsigned long flags)\n{\n\tconst struct clk_parent_data parent_data = {\n\t\t.hw = &ksc->aclk,\n\t};\n\n\tk210_register_clk(np, ksc, id, &parent_data, 1, flags);\n}\n\nstatic inline void __init k210_register_clk_child(struct device_node *np,\n\t\t\t\t\t\tstruct k210_sysclk *ksc, int id,\n\t\t\t\t\t\tint parent_id)\n{\n\tconst struct clk_parent_data parent_data = {\n\t\t.hw = &ksc->clks[parent_id].hw,\n\t};\n\n\tk210_register_clk(np, ksc, id, &parent_data, 1, 0);\n}\n\nstatic struct clk_hw *k210_clk_hw_onecell_get(struct of_phandle_args *clkspec,\n\t\t\t\t\t      void *data)\n{\n\tstruct k210_sysclk *ksc = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= K210_NUM_CLKS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn &ksc->clks[idx].hw;\n}\n\nstatic void __init k210_clk_init(struct device_node *np)\n{\n\tstruct device_node *sysctl_np;\n\tstruct k210_sysclk *ksc;\n\tint i, ret;\n\n\tksc = kzalloc(sizeof(*ksc), GFP_KERNEL);\n\tif (!ksc)\n\t\treturn;\n\n\tspin_lock_init(&ksc->clk_lock);\n\tsysctl_np = of_get_parent(np);\n\tksc->regs = of_iomap(sysctl_np, 0);\n\tof_node_put(sysctl_np);\n\tif (!ksc->regs) {\n\t\tpr_err(\"%pOFP: failed to map registers\\n\", np);\n\t\treturn;\n\t}\n\n\tret = k210_register_plls(np, ksc);\n\tif (ret)\n\t\treturn;\n\n\tret = k210_register_aclk(np, ksc);\n\tif (ret)\n\t\treturn;\n\n\t \n\tk210_register_aclk_child(np, ksc, K210_CLK_CPU, CLK_IS_CRITICAL);\n\tk210_register_aclk_child(np, ksc, K210_CLK_SRAM0, CLK_IS_CRITICAL);\n\tk210_register_aclk_child(np, ksc, K210_CLK_SRAM1, CLK_IS_CRITICAL);\n\tk210_register_pll_child(np, ksc, K210_CLK_AI, K210_PLL1,\n\t\t\t\tCLK_IS_CRITICAL);\n\n\t \n\tk210_register_aclk_child(np, ksc, K210_CLK_DMA, 0);\n\tk210_register_aclk_child(np, ksc, K210_CLK_FFT, 0);\n\tk210_register_aclk_child(np, ksc, K210_CLK_ROM, 0);\n\tk210_register_aclk_child(np, ksc, K210_CLK_DVP, 0);\n\tk210_register_aclk_child(np, ksc, K210_CLK_APB0, 0);\n\tk210_register_aclk_child(np, ksc, K210_CLK_APB1, 0);\n\tk210_register_aclk_child(np, ksc, K210_CLK_APB2, 0);\n\n\t \n\tk210_register_pll_child(np, ksc, K210_CLK_SPI0, K210_PLL0, 0);\n\tk210_register_pll_child(np, ksc, K210_CLK_SPI1, K210_PLL0, 0);\n\tk210_register_pll_child(np, ksc, K210_CLK_SPI2, K210_PLL0, 0);\n\tk210_register_pll_child(np, ksc, K210_CLK_I2C0, K210_PLL0, 0);\n\tk210_register_pll_child(np, ksc, K210_CLK_I2C1, K210_PLL0, 0);\n\tk210_register_pll_child(np, ksc, K210_CLK_I2C2, K210_PLL0, 0);\n\n\t \n\tk210_register_pll_child(np, ksc, K210_CLK_I2S0, K210_PLL2, 0);\n\tk210_register_pll_child(np, ksc, K210_CLK_I2S1, K210_PLL2, 0);\n\tk210_register_pll_child(np, ksc, K210_CLK_I2S2, K210_PLL2, 0);\n\tk210_register_pll_child(np, ksc, K210_CLK_I2S0_M, K210_PLL2, 0);\n\tk210_register_pll_child(np, ksc, K210_CLK_I2S1_M, K210_PLL2, 0);\n\tk210_register_pll_child(np, ksc, K210_CLK_I2S2_M, K210_PLL2, 0);\n\n\t \n\tk210_register_in0_child(np, ksc, K210_CLK_WDT0);\n\tk210_register_in0_child(np, ksc, K210_CLK_WDT1);\n\tk210_register_in0_child(np, ksc, K210_CLK_RTC);\n\n\t \n\tk210_register_clk_child(np, ksc, K210_CLK_GPIO, K210_CLK_APB0);\n\tk210_register_clk_child(np, ksc, K210_CLK_UART1, K210_CLK_APB0);\n\tk210_register_clk_child(np, ksc, K210_CLK_UART2, K210_CLK_APB0);\n\tk210_register_clk_child(np, ksc, K210_CLK_UART3, K210_CLK_APB0);\n\tk210_register_clk_child(np, ksc, K210_CLK_FPIOA, K210_CLK_APB0);\n\tk210_register_clk_child(np, ksc, K210_CLK_SHA, K210_CLK_APB0);\n\n\t \n\tk210_register_clk_child(np, ksc, K210_CLK_AES, K210_CLK_APB1);\n\tk210_register_clk_child(np, ksc, K210_CLK_OTP, K210_CLK_APB1);\n\n\t \n\tk210_register_mux_clk(np, ksc, K210_CLK_SPI3);\n\tk210_register_mux_clk(np, ksc, K210_CLK_TIMER0);\n\tk210_register_mux_clk(np, ksc, K210_CLK_TIMER1);\n\tk210_register_mux_clk(np, ksc, K210_CLK_TIMER2);\n\n\t \n\tfor (i = 0; i < K210_NUM_CLKS; i++) {\n\t\tif (ksc->clks[i].id != i)\n\t\t\treturn;\n\t}\n\n\tret = of_clk_add_hw_provider(np, k210_clk_hw_onecell_get, ksc);\n\tif (ret) {\n\t\tpr_err(\"%pOFP: add clock provider failed %d\\n\", np, ret);\n\t\treturn;\n\t}\n\n\tpr_info(\"%pOFP: CPU running at %lu MHz\\n\",\n\t\tnp, clk_hw_get_rate(&ksc->clks[K210_CLK_CPU].hw) / 1000000);\n}\n\nCLK_OF_DECLARE(k210_clk, \"canaan,k210-clk\", k210_clk_init);\n\n \nvoid __init k210_clk_early_init(void __iomem *regs)\n{\n\tstruct k210_pll pll1;\n\n\t \n\tk210_aclk_set_selector(regs, 1);\n\n\t \n\tk210_init_pll(regs, K210_PLL1, &pll1);\n\tk210_pll_enable_hw(regs, &pll1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}