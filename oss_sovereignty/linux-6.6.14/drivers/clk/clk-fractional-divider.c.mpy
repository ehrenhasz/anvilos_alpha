{
  "module_name": "clk-fractional-divider.c",
  "hash_id": "1a40fbccd8ee2ebdc853e2b91b216c390dfbfbb001176d58557ba80091a1270d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-fractional-divider.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/rational.h>\n#include <linux/slab.h>\n\n#include <linux/clk-provider.h>\n\n#include \"clk-fractional-divider.h\"\n\nstatic inline u32 clk_fd_readl(struct clk_fractional_divider *fd)\n{\n\tif (fd->flags & CLK_FRAC_DIVIDER_BIG_ENDIAN)\n\t\treturn ioread32be(fd->reg);\n\n\treturn readl(fd->reg);\n}\n\nstatic inline void clk_fd_writel(struct clk_fractional_divider *fd, u32 val)\n{\n\tif (fd->flags & CLK_FRAC_DIVIDER_BIG_ENDIAN)\n\t\tiowrite32be(val, fd->reg);\n\telse\n\t\twritel(val, fd->reg);\n}\n\nstatic void clk_fd_get_div(struct clk_hw *hw, struct u32_fract *fract)\n{\n\tstruct clk_fractional_divider *fd = to_clk_fd(hw);\n\tunsigned long flags = 0;\n\tunsigned long m, n;\n\tu32 mmask, nmask;\n\tu32 val;\n\n\tif (fd->lock)\n\t\tspin_lock_irqsave(fd->lock, flags);\n\telse\n\t\t__acquire(fd->lock);\n\n\tval = clk_fd_readl(fd);\n\n\tif (fd->lock)\n\t\tspin_unlock_irqrestore(fd->lock, flags);\n\telse\n\t\t__release(fd->lock);\n\n\tmmask = GENMASK(fd->mwidth - 1, 0) << fd->mshift;\n\tnmask = GENMASK(fd->nwidth - 1, 0) << fd->nshift;\n\n\tm = (val & mmask) >> fd->mshift;\n\tn = (val & nmask) >> fd->nshift;\n\n\tif (fd->flags & CLK_FRAC_DIVIDER_ZERO_BASED) {\n\t\tm++;\n\t\tn++;\n\t}\n\n\tfract->numerator = m;\n\tfract->denominator = n;\n}\n\nstatic unsigned long clk_fd_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct u32_fract fract;\n\tu64 ret;\n\n\tclk_fd_get_div(hw, &fract);\n\n\tif (!fract.numerator || !fract.denominator)\n\t\treturn parent_rate;\n\n\tret = (u64)parent_rate * fract.numerator;\n\tdo_div(ret, fract.denominator);\n\n\treturn ret;\n}\n\nvoid clk_fractional_divider_general_approximation(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long rate,\n\t\t\t\t\t\t  unsigned long *parent_rate,\n\t\t\t\t\t\t  unsigned long *m, unsigned long *n)\n{\n\tstruct clk_fractional_divider *fd = to_clk_fd(hw);\n\n\t \n\tif (fd->flags & CLK_FRAC_DIVIDER_POWER_OF_TWO_PS) {\n\t\tunsigned long scale = fls_long(*parent_rate / rate - 1);\n\n\t\tif (scale > fd->nwidth)\n\t\t\trate <<= scale - fd->nwidth;\n\t}\n\n\trational_best_approximation(rate, *parent_rate,\n\t\t\tGENMASK(fd->mwidth - 1, 0), GENMASK(fd->nwidth - 1, 0),\n\t\t\tm, n);\n}\n\nstatic long clk_fd_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long *parent_rate)\n{\n\tstruct clk_fractional_divider *fd = to_clk_fd(hw);\n\tunsigned long m, n;\n\tu64 ret;\n\n\tif (!rate || (!clk_hw_can_set_rate_parent(hw) && rate >= *parent_rate))\n\t\treturn *parent_rate;\n\n\tif (fd->approximation)\n\t\tfd->approximation(hw, rate, parent_rate, &m, &n);\n\telse\n\t\tclk_fractional_divider_general_approximation(hw, rate, parent_rate, &m, &n);\n\n\tret = (u64)*parent_rate * m;\n\tdo_div(ret, n);\n\n\treturn ret;\n}\n\nstatic int clk_fd_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t   unsigned long parent_rate)\n{\n\tstruct clk_fractional_divider *fd = to_clk_fd(hw);\n\tunsigned long flags = 0;\n\tunsigned long m, n;\n\tu32 mmask, nmask;\n\tu32 val;\n\n\trational_best_approximation(rate, parent_rate,\n\t\t\tGENMASK(fd->mwidth - 1, 0), GENMASK(fd->nwidth - 1, 0),\n\t\t\t&m, &n);\n\n\tif (fd->flags & CLK_FRAC_DIVIDER_ZERO_BASED) {\n\t\tm--;\n\t\tn--;\n\t}\n\n\tif (fd->lock)\n\t\tspin_lock_irqsave(fd->lock, flags);\n\telse\n\t\t__acquire(fd->lock);\n\n\tmmask = GENMASK(fd->mwidth - 1, 0) << fd->mshift;\n\tnmask = GENMASK(fd->nwidth - 1, 0) << fd->nshift;\n\n\tval = clk_fd_readl(fd);\n\tval &= ~(mmask | nmask);\n\tval |= (m << fd->mshift) | (n << fd->nshift);\n\tclk_fd_writel(fd, val);\n\n\tif (fd->lock)\n\t\tspin_unlock_irqrestore(fd->lock, flags);\n\telse\n\t\t__release(fd->lock);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int clk_fd_numerator_get(void *hw, u64 *val)\n{\n\tstruct u32_fract fract;\n\n\tclk_fd_get_div(hw, &fract);\n\n\t*val = fract.numerator;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(clk_fd_numerator_fops, clk_fd_numerator_get, NULL, \"%llu\\n\");\n\nstatic int clk_fd_denominator_get(void *hw, u64 *val)\n{\n\tstruct u32_fract fract;\n\n\tclk_fd_get_div(hw, &fract);\n\n\t*val = fract.denominator;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(clk_fd_denominator_fops, clk_fd_denominator_get, NULL, \"%llu\\n\");\n\nstatic void clk_fd_debug_init(struct clk_hw *hw, struct dentry *dentry)\n{\n\tdebugfs_create_file(\"numerator\", 0444, dentry, hw, &clk_fd_numerator_fops);\n\tdebugfs_create_file(\"denominator\", 0444, dentry, hw, &clk_fd_denominator_fops);\n}\n#endif\n\nconst struct clk_ops clk_fractional_divider_ops = {\n\t.recalc_rate = clk_fd_recalc_rate,\n\t.round_rate = clk_fd_round_rate,\n\t.set_rate = clk_fd_set_rate,\n#ifdef CONFIG_DEBUG_FS\n\t.debug_init = clk_fd_debug_init,\n#endif\n};\nEXPORT_SYMBOL_GPL(clk_fractional_divider_ops);\n\nstruct clk_hw *clk_hw_register_fractional_divider(struct device *dev,\n\t\tconst char *name, const char *parent_name, unsigned long flags,\n\t\tvoid __iomem *reg, u8 mshift, u8 mwidth, u8 nshift, u8 nwidth,\n\t\tu8 clk_divider_flags, spinlock_t *lock)\n{\n\tstruct clk_fractional_divider *fd;\n\tstruct clk_init_data init;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tfd = kzalloc(sizeof(*fd), GFP_KERNEL);\n\tif (!fd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &clk_fractional_divider_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\n\tfd->reg = reg;\n\tfd->mshift = mshift;\n\tfd->mwidth = mwidth;\n\tfd->nshift = nshift;\n\tfd->nwidth = nwidth;\n\tfd->flags = clk_divider_flags;\n\tfd->lock = lock;\n\tfd->hw.init = &init;\n\n\thw = &fd->hw;\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\tkfree(fd);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(clk_hw_register_fractional_divider);\n\nstruct clk *clk_register_fractional_divider(struct device *dev,\n\t\tconst char *name, const char *parent_name, unsigned long flags,\n\t\tvoid __iomem *reg, u8 mshift, u8 mwidth, u8 nshift, u8 nwidth,\n\t\tu8 clk_divider_flags, spinlock_t *lock)\n{\n\tstruct clk_hw *hw;\n\n\thw = clk_hw_register_fractional_divider(dev, name, parent_name, flags,\n\t\t\treg, mshift, mwidth, nshift, nwidth, clk_divider_flags,\n\t\t\tlock);\n\tif (IS_ERR(hw))\n\t\treturn ERR_CAST(hw);\n\treturn hw->clk;\n}\nEXPORT_SYMBOL_GPL(clk_register_fractional_divider);\n\nvoid clk_hw_unregister_fractional_divider(struct clk_hw *hw)\n{\n\tstruct clk_fractional_divider *fd;\n\n\tfd = to_clk_fd(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(fd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}