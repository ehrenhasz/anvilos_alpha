{
  "module_name": "clk-exynos4412-isp.c",
  "hash_id": "d53bbaa42d5055150e21ace14f5a4cb9e1bfdaa90823c36e2ce20eaa88f7149e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/samsung/clk-exynos4412-isp.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/clock/exynos4.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include \"clk.h\"\n\n \n#define E4X12_DIV_ISP0\t\t0x0300\n#define E4X12_DIV_ISP1\t\t0x0304\n#define E4X12_GATE_ISP0\t\t0x0800\n#define E4X12_GATE_ISP1\t\t0x0804\n\n \n#define CLKS_NR_ISP\t\t(CLK_ISP_DIV_MCUISP1 + 1)\n\n \nstatic struct samsung_clk_reg_dump *exynos4x12_save_isp;\n\nstatic const unsigned long exynos4x12_clk_isp_save[] __initconst = {\n\tE4X12_DIV_ISP0,\n\tE4X12_DIV_ISP1,\n\tE4X12_GATE_ISP0,\n\tE4X12_GATE_ISP1,\n};\n\nstatic struct samsung_div_clock exynos4x12_isp_div_clks[] = {\n\tDIV(CLK_ISP_DIV_ISP0, \"div_isp0\", \"aclk200\", E4X12_DIV_ISP0, 0, 3),\n\tDIV(CLK_ISP_DIV_ISP1, \"div_isp1\", \"aclk200\", E4X12_DIV_ISP0, 4, 3),\n\tDIV(CLK_ISP_DIV_MCUISP0, \"div_mcuisp0\", \"aclk400_mcuisp\",\n\t    E4X12_DIV_ISP1, 4, 3),\n\tDIV(CLK_ISP_DIV_MCUISP1, \"div_mcuisp1\", \"div_mcuisp0\",\n\t    E4X12_DIV_ISP1, 8, 3),\n\tDIV(0, \"div_mpwm\", \"div_isp1\", E4X12_DIV_ISP1, 0, 3),\n};\n\nstatic struct samsung_gate_clock exynos4x12_isp_gate_clks[] = {\n\tGATE(CLK_ISP_FIMC_ISP, \"isp\", \"aclk200\", E4X12_GATE_ISP0, 0, 0, 0),\n\tGATE(CLK_ISP_FIMC_DRC, \"drc\", \"aclk200\", E4X12_GATE_ISP0, 1, 0, 0),\n\tGATE(CLK_ISP_FIMC_FD, \"fd\", \"aclk200\", E4X12_GATE_ISP0, 2, 0, 0),\n\tGATE(CLK_ISP_FIMC_LITE0, \"lite0\", \"aclk200\", E4X12_GATE_ISP0, 3, 0, 0),\n\tGATE(CLK_ISP_FIMC_LITE1, \"lite1\", \"aclk200\", E4X12_GATE_ISP0, 4, 0, 0),\n\tGATE(CLK_ISP_MCUISP, \"mcuisp\", \"aclk200\", E4X12_GATE_ISP0, 5, 0, 0),\n\tGATE(CLK_ISP_GICISP, \"gicisp\", \"aclk200\", E4X12_GATE_ISP0, 7, 0, 0),\n\tGATE(CLK_ISP_SMMU_ISP, \"smmu_isp\", \"aclk200\", E4X12_GATE_ISP0, 8, 0, 0),\n\tGATE(CLK_ISP_SMMU_DRC, \"smmu_drc\", \"aclk200\", E4X12_GATE_ISP0, 9, 0, 0),\n\tGATE(CLK_ISP_SMMU_FD, \"smmu_fd\", \"aclk200\", E4X12_GATE_ISP0, 10, 0, 0),\n\tGATE(CLK_ISP_SMMU_LITE0, \"smmu_lite0\", \"aclk200\", E4X12_GATE_ISP0, 11,\n\t     0, 0),\n\tGATE(CLK_ISP_SMMU_LITE1, \"smmu_lite1\", \"aclk200\", E4X12_GATE_ISP0, 12,\n\t     0, 0),\n\tGATE(CLK_ISP_PPMUISPMX, \"ppmuispmx\", \"aclk200\", E4X12_GATE_ISP0, 20,\n\t     0, 0),\n\tGATE(CLK_ISP_PPMUISPX, \"ppmuispx\", \"aclk200\", E4X12_GATE_ISP0, 21,\n\t     0, 0),\n\tGATE(CLK_ISP_MCUCTL_ISP, \"mcuctl_isp\", \"aclk200\", E4X12_GATE_ISP0, 23,\n\t     0, 0),\n\tGATE(CLK_ISP_MPWM_ISP, \"mpwm_isp\", \"aclk200\", E4X12_GATE_ISP0, 24,\n\t     0, 0),\n\tGATE(CLK_ISP_I2C0_ISP, \"i2c0_isp\", \"aclk200\", E4X12_GATE_ISP0, 25,\n\t     0, 0),\n\tGATE(CLK_ISP_I2C1_ISP, \"i2c1_isp\", \"aclk200\", E4X12_GATE_ISP0, 26,\n\t     0, 0),\n\tGATE(CLK_ISP_MTCADC_ISP, \"mtcadc_isp\", \"aclk200\", E4X12_GATE_ISP0, 27,\n\t     0, 0),\n\tGATE(CLK_ISP_PWM_ISP, \"pwm_isp\", \"aclk200\", E4X12_GATE_ISP0, 28, 0, 0),\n\tGATE(CLK_ISP_WDT_ISP, \"wdt_isp\", \"aclk200\", E4X12_GATE_ISP0, 30, 0, 0),\n\tGATE(CLK_ISP_UART_ISP, \"uart_isp\", \"aclk200\", E4X12_GATE_ISP0, 31,\n\t     0, 0),\n\tGATE(CLK_ISP_ASYNCAXIM, \"asyncaxim\", \"aclk200\", E4X12_GATE_ISP1, 0,\n\t     0, 0),\n\tGATE(CLK_ISP_SMMU_ISPCX, \"smmu_ispcx\", \"aclk200\", E4X12_GATE_ISP1, 4,\n\t     0, 0),\n\tGATE(CLK_ISP_SPI0_ISP, \"spi0_isp\", \"aclk200\", E4X12_GATE_ISP1, 12,\n\t     0, 0),\n\tGATE(CLK_ISP_SPI1_ISP, \"spi1_isp\", \"aclk200\", E4X12_GATE_ISP1, 13,\n\t     0, 0),\n};\n\nstatic int __maybe_unused exynos4x12_isp_clk_suspend(struct device *dev)\n{\n\tstruct samsung_clk_provider *ctx = dev_get_drvdata(dev);\n\n\tsamsung_clk_save(ctx->reg_base, exynos4x12_save_isp,\n\t\t\t ARRAY_SIZE(exynos4x12_clk_isp_save));\n\treturn 0;\n}\n\nstatic int __maybe_unused exynos4x12_isp_clk_resume(struct device *dev)\n{\n\tstruct samsung_clk_provider *ctx = dev_get_drvdata(dev);\n\n\tsamsung_clk_restore(ctx->reg_base, exynos4x12_save_isp,\n\t\t\t    ARRAY_SIZE(exynos4x12_clk_isp_save));\n\treturn 0;\n}\n\nstatic int __init exynos4x12_isp_clk_probe(struct platform_device *pdev)\n{\n\tstruct samsung_clk_provider *ctx;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tvoid __iomem *reg_base;\n\n\treg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(reg_base))\n\t\treturn PTR_ERR(reg_base);\n\n\texynos4x12_save_isp = samsung_clk_alloc_reg_dump(exynos4x12_clk_isp_save,\n\t\t\t\t\tARRAY_SIZE(exynos4x12_clk_isp_save));\n\tif (!exynos4x12_save_isp)\n\t\treturn -ENOMEM;\n\n\tctx = samsung_clk_init(dev, reg_base, CLKS_NR_ISP);\n\n\tplatform_set_drvdata(pdev, ctx);\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\tsamsung_clk_register_div(ctx, exynos4x12_isp_div_clks,\n\t\t\t\t ARRAY_SIZE(exynos4x12_isp_div_clks));\n\tsamsung_clk_register_gate(ctx, exynos4x12_isp_gate_clks,\n\t\t\t\t  ARRAY_SIZE(exynos4x12_isp_gate_clks));\n\n\tsamsung_clk_of_add_provider(np, ctx);\n\tpm_runtime_put(dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id exynos4x12_isp_clk_of_match[] = {\n\t{ .compatible = \"samsung,exynos4412-isp-clock\", },\n\t{ },\n};\n\nstatic const struct dev_pm_ops exynos4x12_isp_pm_ops = {\n\tSET_RUNTIME_PM_OPS(exynos4x12_isp_clk_suspend,\n\t\t\t   exynos4x12_isp_clk_resume, NULL)\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t     pm_runtime_force_resume)\n};\n\nstatic struct platform_driver exynos4x12_isp_clk_driver __refdata = {\n\t.driver\t= {\n\t\t.name = \"exynos4x12-isp-clk\",\n\t\t.of_match_table = exynos4x12_isp_clk_of_match,\n\t\t.suppress_bind_attrs = true,\n\t\t.pm = &exynos4x12_isp_pm_ops,\n\t},\n\t.probe = exynos4x12_isp_clk_probe,\n};\n\nstatic int __init exynos4x12_isp_clk_init(void)\n{\n\treturn platform_driver_register(&exynos4x12_isp_clk_driver);\n}\ncore_initcall(exynos4x12_isp_clk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}