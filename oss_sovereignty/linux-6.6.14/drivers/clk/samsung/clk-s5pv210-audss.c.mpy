{
  "module_name": "clk-s5pv210-audss.c",
  "hash_id": "1b2cbea4b30731d0e73df0475bfc84073fd1e5bba251b66e0f3fa112350ad8d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/samsung/clk-s5pv210-audss.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/of_address.h>\n#include <linux/syscore_ops.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n\n#include <dt-bindings/clock/s5pv210-audss.h>\n\nstatic DEFINE_SPINLOCK(lock);\nstatic void __iomem *reg_base;\nstatic struct clk_hw_onecell_data *clk_data;\n\n#define ASS_CLK_SRC 0x0\n#define ASS_CLK_DIV 0x4\n#define ASS_CLK_GATE 0x8\n\n#ifdef CONFIG_PM_SLEEP\nstatic unsigned long reg_save[][2] = {\n\t{ASS_CLK_SRC,  0},\n\t{ASS_CLK_DIV,  0},\n\t{ASS_CLK_GATE, 0},\n};\n\nstatic int s5pv210_audss_clk_suspend(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_save); i++)\n\t\treg_save[i][1] = readl(reg_base + reg_save[i][0]);\n\n\treturn 0;\n}\n\nstatic void s5pv210_audss_clk_resume(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_save); i++)\n\t\twritel(reg_save[i][1], reg_base + reg_save[i][0]);\n}\n\nstatic struct syscore_ops s5pv210_audss_clk_syscore_ops = {\n\t.suspend\t= s5pv210_audss_clk_suspend,\n\t.resume\t\t= s5pv210_audss_clk_resume,\n};\n#endif  \n\n \nstatic int s5pv210_audss_clk_probe(struct platform_device *pdev)\n{\n\tint i, ret = 0;\n\tconst char *mout_audss_p[2];\n\tconst char *mout_i2s_p[3];\n\tconst char *hclk_p;\n\tstruct clk_hw **clk_table;\n\tstruct clk *hclk, *pll_ref, *pll_in, *cdclk, *sclk_audio;\n\n\treg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(reg_base))\n\t\treturn PTR_ERR(reg_base);\n\n\tclk_data = devm_kzalloc(&pdev->dev,\n\t\t\t\tstruct_size(clk_data, hws, AUDSS_MAX_CLKS),\n\t\t\t\tGFP_KERNEL);\n\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tclk_data->num = AUDSS_MAX_CLKS;\n\tclk_table = clk_data->hws;\n\n\thclk = devm_clk_get(&pdev->dev, \"hclk\");\n\tif (IS_ERR(hclk)) {\n\t\tdev_err(&pdev->dev, \"failed to get hclk clock\\n\");\n\t\treturn PTR_ERR(hclk);\n\t}\n\n\tpll_in = devm_clk_get(&pdev->dev, \"fout_epll\");\n\tif (IS_ERR(pll_in)) {\n\t\tdev_err(&pdev->dev, \"failed to get fout_epll clock\\n\");\n\t\treturn PTR_ERR(pll_in);\n\t}\n\n\tsclk_audio = devm_clk_get(&pdev->dev, \"sclk_audio0\");\n\tif (IS_ERR(sclk_audio)) {\n\t\tdev_err(&pdev->dev, \"failed to get sclk_audio0 clock\\n\");\n\t\treturn PTR_ERR(sclk_audio);\n\t}\n\n\t \n\tcdclk = devm_clk_get(&pdev->dev, \"iiscdclk0\");\n\tpll_ref = devm_clk_get(&pdev->dev, \"xxti\");\n\n\tif (!IS_ERR(pll_ref))\n\t\tmout_audss_p[0] = __clk_get_name(pll_ref);\n\telse\n\t\tmout_audss_p[0] = \"xxti\";\n\tmout_audss_p[1] = __clk_get_name(pll_in);\n\tclk_table[CLK_MOUT_AUDSS] = clk_hw_register_mux(NULL, \"mout_audss\",\n\t\t\t\tmout_audss_p, ARRAY_SIZE(mout_audss_p),\n\t\t\t\tCLK_SET_RATE_NO_REPARENT,\n\t\t\t\treg_base + ASS_CLK_SRC, 0, 1, 0, &lock);\n\n\tmout_i2s_p[0] = \"mout_audss\";\n\tif (!IS_ERR(cdclk))\n\t\tmout_i2s_p[1] = __clk_get_name(cdclk);\n\telse\n\t\tmout_i2s_p[1] = \"iiscdclk0\";\n\tmout_i2s_p[2] = __clk_get_name(sclk_audio);\n\tclk_table[CLK_MOUT_I2S_A] = clk_hw_register_mux(NULL, \"mout_i2s_audss\",\n\t\t\t\tmout_i2s_p, ARRAY_SIZE(mout_i2s_p),\n\t\t\t\tCLK_SET_RATE_NO_REPARENT,\n\t\t\t\treg_base + ASS_CLK_SRC, 2, 2, 0, &lock);\n\n\tclk_table[CLK_DOUT_AUD_BUS] = clk_hw_register_divider(NULL,\n\t\t\t\t\"dout_aud_bus\", \"mout_audss\", 0,\n\t\t\t\treg_base + ASS_CLK_DIV, 0, 4, 0, &lock);\n\tclk_table[CLK_DOUT_I2S_A] = clk_hw_register_divider(NULL,\n\t\t\t\t\"dout_i2s_audss\", \"mout_i2s_audss\", 0,\n\t\t\t\treg_base + ASS_CLK_DIV, 4, 4, 0, &lock);\n\n\tclk_table[CLK_I2S] = clk_hw_register_gate(NULL, \"i2s_audss\",\n\t\t\t\t\"dout_i2s_audss\", CLK_SET_RATE_PARENT,\n\t\t\t\treg_base + ASS_CLK_GATE, 6, 0, &lock);\n\n\thclk_p = __clk_get_name(hclk);\n\n\tclk_table[CLK_HCLK_I2S] = clk_hw_register_gate(NULL, \"hclk_i2s_audss\",\n\t\t\t\thclk_p, CLK_IGNORE_UNUSED,\n\t\t\t\treg_base + ASS_CLK_GATE, 5, 0, &lock);\n\tclk_table[CLK_HCLK_UART] = clk_hw_register_gate(NULL, \"hclk_uart_audss\",\n\t\t\t\thclk_p, CLK_IGNORE_UNUSED,\n\t\t\t\treg_base + ASS_CLK_GATE, 4, 0, &lock);\n\tclk_table[CLK_HCLK_HWA] = clk_hw_register_gate(NULL, \"hclk_hwa_audss\",\n\t\t\t\thclk_p, CLK_IGNORE_UNUSED,\n\t\t\t\treg_base + ASS_CLK_GATE, 3, 0, &lock);\n\tclk_table[CLK_HCLK_DMA] = clk_hw_register_gate(NULL, \"hclk_dma_audss\",\n\t\t\t\thclk_p, CLK_IGNORE_UNUSED,\n\t\t\t\treg_base + ASS_CLK_GATE, 2, 0, &lock);\n\tclk_table[CLK_HCLK_BUF] = clk_hw_register_gate(NULL, \"hclk_buf_audss\",\n\t\t\t\thclk_p, CLK_IGNORE_UNUSED,\n\t\t\t\treg_base + ASS_CLK_GATE, 1, 0, &lock);\n\tclk_table[CLK_HCLK_RP] = clk_hw_register_gate(NULL, \"hclk_rp_audss\",\n\t\t\t\thclk_p, CLK_IGNORE_UNUSED,\n\t\t\t\treg_base + ASS_CLK_GATE, 0, 0, &lock);\n\n\tfor (i = 0; i < clk_data->num; i++) {\n\t\tif (IS_ERR(clk_table[i])) {\n\t\t\tdev_err(&pdev->dev, \"failed to register clock %d\\n\", i);\n\t\t\tret = PTR_ERR(clk_table[i]);\n\t\t\tgoto unregister;\n\t\t}\n\t}\n\n\tret = of_clk_add_hw_provider(pdev->dev.of_node, of_clk_hw_onecell_get,\n\t\t\t\t     clk_data);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add clock provider\\n\");\n\t\tgoto unregister;\n\t}\n\n#ifdef CONFIG_PM_SLEEP\n\tregister_syscore_ops(&s5pv210_audss_clk_syscore_ops);\n#endif\n\n\treturn 0;\n\nunregister:\n\tfor (i = 0; i < clk_data->num; i++) {\n\t\tif (!IS_ERR(clk_table[i]))\n\t\t\tclk_hw_unregister(clk_table[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct of_device_id s5pv210_audss_clk_of_match[] = {\n\t{ .compatible = \"samsung,s5pv210-audss-clock\", },\n\t{},\n};\n\nstatic struct platform_driver s5pv210_audss_clk_driver = {\n\t.driver\t= {\n\t\t.name = \"s5pv210-audss-clk\",\n\t\t.suppress_bind_attrs = true,\n\t\t.of_match_table = s5pv210_audss_clk_of_match,\n\t},\n\t.probe = s5pv210_audss_clk_probe,\n};\n\nstatic int __init s5pv210_audss_clk_init(void)\n{\n\treturn platform_driver_register(&s5pv210_audss_clk_driver);\n}\ncore_initcall(s5pv210_audss_clk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}