{
  "module_name": "clk-pll.c",
  "hash_id": "d94853fb06f2801999eb8f51a779bf2b1f69f77028486e6cf76f87b573577ca4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/samsung/clk-pll.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/hrtimer.h>\n#include <linux/iopoll.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/timekeeping.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include \"clk.h\"\n#include \"clk-pll.h\"\n\n#define PLL_TIMEOUT_US\t\t20000U\n#define PLL_TIMEOUT_LOOPS\t1000000U\n\nstruct samsung_clk_pll {\n\tstruct clk_hw\t\thw;\n\tvoid __iomem\t\t*lock_reg;\n\tvoid __iomem\t\t*con_reg;\n\t \n\tunsigned short\t\tenable_offs;\n\t \n\tunsigned short\t\tlock_offs;\n\tenum samsung_pll_type\ttype;\n\tunsigned int\t\trate_count;\n\tconst struct samsung_pll_rate_table *rate_table;\n};\n\n#define to_clk_pll(_hw) container_of(_hw, struct samsung_clk_pll, hw)\n\nstatic const struct samsung_pll_rate_table *samsung_get_pll_settings(\n\t\t\t\tstruct samsung_clk_pll *pll, unsigned long rate)\n{\n\tconst struct samsung_pll_rate_table  *rate_table = pll->rate_table;\n\tint i;\n\n\tfor (i = 0; i < pll->rate_count; i++) {\n\t\tif (rate == rate_table[i].rate)\n\t\t\treturn &rate_table[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic long samsung_pll_round_rate(struct clk_hw *hw,\n\t\t\tunsigned long drate, unsigned long *prate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tconst struct samsung_pll_rate_table *rate_table = pll->rate_table;\n\tint i;\n\n\t \n\tfor (i = 0; i < pll->rate_count; i++) {\n\t\tif (drate >= rate_table[i].rate)\n\t\t\treturn rate_table[i].rate;\n\t}\n\n\t \n\treturn rate_table[i - 1].rate;\n}\n\nstatic bool pll_early_timeout = true;\n\nstatic int __init samsung_pll_disable_early_timeout(void)\n{\n\tpll_early_timeout = false;\n\treturn 0;\n}\narch_initcall(samsung_pll_disable_early_timeout);\n\n \nstatic int samsung_pll_lock_wait(struct samsung_clk_pll *pll,\n\t\t\t\t unsigned int reg_mask)\n{\n\tint i, ret;\n\tu32 val;\n\n\t \n\tif (pll_early_timeout || timekeeping_suspended) {\n\t\ti = PLL_TIMEOUT_LOOPS;\n\t\twhile (i-- > 0) {\n\t\t\tif (readl_relaxed(pll->con_reg) & reg_mask)\n\t\t\t\treturn 0;\n\n\t\t\tcpu_relax();\n\t\t}\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\tret = readl_relaxed_poll_timeout_atomic(pll->con_reg, val,\n\t\t\t\t\tval & reg_mask, 0, PLL_TIMEOUT_US);\n\t}\n\n\tif (ret < 0)\n\t\tpr_err(\"Could not lock PLL %s\\n\", clk_hw_get_name(&pll->hw));\n\n\treturn ret;\n}\n\nstatic int samsung_pll3xxx_enable(struct clk_hw *hw)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 tmp;\n\n\ttmp = readl_relaxed(pll->con_reg);\n\ttmp |= BIT(pll->enable_offs);\n\twritel_relaxed(tmp, pll->con_reg);\n\n\treturn samsung_pll_lock_wait(pll, BIT(pll->lock_offs));\n}\n\nstatic void samsung_pll3xxx_disable(struct clk_hw *hw)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 tmp;\n\n\ttmp = readl_relaxed(pll->con_reg);\n\ttmp &= ~BIT(pll->enable_offs);\n\twritel_relaxed(tmp, pll->con_reg);\n}\n\n \n\n#define PLL2126_MDIV_MASK\t(0xff)\n#define PLL2126_PDIV_MASK\t(0x3f)\n#define PLL2126_SDIV_MASK\t(0x3)\n#define PLL2126_MDIV_SHIFT\t(16)\n#define PLL2126_PDIV_SHIFT\t(8)\n#define PLL2126_SDIV_SHIFT\t(0)\n\nstatic unsigned long samsung_pll2126_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 pll_con, mdiv, pdiv, sdiv;\n\tu64 fvco = parent_rate;\n\n\tpll_con = readl_relaxed(pll->con_reg);\n\tmdiv = (pll_con >> PLL2126_MDIV_SHIFT) & PLL2126_MDIV_MASK;\n\tpdiv = (pll_con >> PLL2126_PDIV_SHIFT) & PLL2126_PDIV_MASK;\n\tsdiv = (pll_con >> PLL2126_SDIV_SHIFT) & PLL2126_SDIV_MASK;\n\n\tfvco *= (mdiv + 8);\n\tdo_div(fvco, (pdiv + 2) << sdiv);\n\n\treturn (unsigned long)fvco;\n}\n\nstatic const struct clk_ops samsung_pll2126_clk_ops = {\n\t.recalc_rate = samsung_pll2126_recalc_rate,\n};\n\n \n\n#define PLL3000_MDIV_MASK\t(0xff)\n#define PLL3000_PDIV_MASK\t(0x3)\n#define PLL3000_SDIV_MASK\t(0x3)\n#define PLL3000_MDIV_SHIFT\t(16)\n#define PLL3000_PDIV_SHIFT\t(8)\n#define PLL3000_SDIV_SHIFT\t(0)\n\nstatic unsigned long samsung_pll3000_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 pll_con, mdiv, pdiv, sdiv;\n\tu64 fvco = parent_rate;\n\n\tpll_con = readl_relaxed(pll->con_reg);\n\tmdiv = (pll_con >> PLL3000_MDIV_SHIFT) & PLL3000_MDIV_MASK;\n\tpdiv = (pll_con >> PLL3000_PDIV_SHIFT) & PLL3000_PDIV_MASK;\n\tsdiv = (pll_con >> PLL3000_SDIV_SHIFT) & PLL3000_SDIV_MASK;\n\n\tfvco *= (2 * (mdiv + 8));\n\tdo_div(fvco, pdiv << sdiv);\n\n\treturn (unsigned long)fvco;\n}\n\nstatic const struct clk_ops samsung_pll3000_clk_ops = {\n\t.recalc_rate = samsung_pll3000_recalc_rate,\n};\n\n \n \n#define PLL35XX_LOCK_FACTOR\t(270)\n\n#define PLL35XX_MDIV_MASK       (0x3FF)\n#define PLL35XX_PDIV_MASK       (0x3F)\n#define PLL35XX_SDIV_MASK       (0x7)\n#define PLL35XX_MDIV_SHIFT      (16)\n#define PLL35XX_PDIV_SHIFT      (8)\n#define PLL35XX_SDIV_SHIFT      (0)\n#define PLL35XX_LOCK_STAT_SHIFT\t(29)\n#define PLL35XX_ENABLE_SHIFT\t(31)\n\nstatic unsigned long samsung_pll35xx_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 mdiv, pdiv, sdiv, pll_con;\n\tu64 fvco = parent_rate;\n\n\tpll_con = readl_relaxed(pll->con_reg);\n\tmdiv = (pll_con >> PLL35XX_MDIV_SHIFT) & PLL35XX_MDIV_MASK;\n\tpdiv = (pll_con >> PLL35XX_PDIV_SHIFT) & PLL35XX_PDIV_MASK;\n\tsdiv = (pll_con >> PLL35XX_SDIV_SHIFT) & PLL35XX_SDIV_MASK;\n\n\tfvco *= mdiv;\n\tdo_div(fvco, (pdiv << sdiv));\n\n\treturn (unsigned long)fvco;\n}\n\nstatic inline bool samsung_pll35xx_mp_change(\n\t\tconst struct samsung_pll_rate_table *rate, u32 pll_con)\n{\n\tu32 old_mdiv, old_pdiv;\n\n\told_mdiv = (pll_con >> PLL35XX_MDIV_SHIFT) & PLL35XX_MDIV_MASK;\n\told_pdiv = (pll_con >> PLL35XX_PDIV_SHIFT) & PLL35XX_PDIV_MASK;\n\n\treturn (rate->mdiv != old_mdiv || rate->pdiv != old_pdiv);\n}\n\nstatic int samsung_pll35xx_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t\tunsigned long prate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tconst struct samsung_pll_rate_table *rate;\n\tu32 tmp;\n\n\t \n\trate = samsung_get_pll_settings(pll, drate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for pll clk %s\\n\", __func__,\n\t\t\tdrate, clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = readl_relaxed(pll->con_reg);\n\n\tif (!(samsung_pll35xx_mp_change(rate, tmp))) {\n\t\t \n\t\ttmp &= ~(PLL35XX_SDIV_MASK << PLL35XX_SDIV_SHIFT);\n\t\ttmp |= rate->sdiv << PLL35XX_SDIV_SHIFT;\n\t\twritel_relaxed(tmp, pll->con_reg);\n\n\t\treturn 0;\n\t}\n\n\t \n\twritel_relaxed(rate->pdiv * PLL35XX_LOCK_FACTOR,\n\t\t\tpll->lock_reg);\n\n\t \n\ttmp &= ~((PLL35XX_MDIV_MASK << PLL35XX_MDIV_SHIFT) |\n\t\t\t(PLL35XX_PDIV_MASK << PLL35XX_PDIV_SHIFT) |\n\t\t\t(PLL35XX_SDIV_MASK << PLL35XX_SDIV_SHIFT));\n\ttmp |= (rate->mdiv << PLL35XX_MDIV_SHIFT) |\n\t\t\t(rate->pdiv << PLL35XX_PDIV_SHIFT) |\n\t\t\t(rate->sdiv << PLL35XX_SDIV_SHIFT);\n\twritel_relaxed(tmp, pll->con_reg);\n\n\t \n\tif (tmp & BIT(pll->enable_offs))\n\t\treturn samsung_pll_lock_wait(pll, BIT(pll->lock_offs));\n\n\treturn 0;\n}\n\nstatic const struct clk_ops samsung_pll35xx_clk_ops = {\n\t.recalc_rate = samsung_pll35xx_recalc_rate,\n\t.round_rate = samsung_pll_round_rate,\n\t.set_rate = samsung_pll35xx_set_rate,\n\t.enable = samsung_pll3xxx_enable,\n\t.disable = samsung_pll3xxx_disable,\n};\n\nstatic const struct clk_ops samsung_pll35xx_clk_min_ops = {\n\t.recalc_rate = samsung_pll35xx_recalc_rate,\n};\n\n \n \n#define PLL36XX_LOCK_FACTOR    (3000)\n\n#define PLL36XX_KDIV_MASK\t(0xFFFF)\n#define PLL36XX_MDIV_MASK\t(0x1FF)\n#define PLL36XX_PDIV_MASK\t(0x3F)\n#define PLL36XX_SDIV_MASK\t(0x7)\n#define PLL36XX_MDIV_SHIFT\t(16)\n#define PLL36XX_PDIV_SHIFT\t(8)\n#define PLL36XX_SDIV_SHIFT\t(0)\n#define PLL36XX_KDIV_SHIFT\t(0)\n#define PLL36XX_LOCK_STAT_SHIFT\t(29)\n#define PLL36XX_ENABLE_SHIFT\t(31)\n\nstatic unsigned long samsung_pll36xx_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 mdiv, pdiv, sdiv, pll_con0, pll_con1;\n\ts16 kdiv;\n\tu64 fvco = parent_rate;\n\n\tpll_con0 = readl_relaxed(pll->con_reg);\n\tpll_con1 = readl_relaxed(pll->con_reg + 4);\n\tmdiv = (pll_con0 >> PLL36XX_MDIV_SHIFT) & PLL36XX_MDIV_MASK;\n\tpdiv = (pll_con0 >> PLL36XX_PDIV_SHIFT) & PLL36XX_PDIV_MASK;\n\tsdiv = (pll_con0 >> PLL36XX_SDIV_SHIFT) & PLL36XX_SDIV_MASK;\n\tkdiv = (s16)(pll_con1 & PLL36XX_KDIV_MASK);\n\n\tfvco *= (mdiv << 16) + kdiv;\n\tdo_div(fvco, (pdiv << sdiv));\n\tfvco >>= 16;\n\n\treturn (unsigned long)fvco;\n}\n\nstatic inline bool samsung_pll36xx_mpk_change(\n\tconst struct samsung_pll_rate_table *rate, u32 pll_con0, u32 pll_con1)\n{\n\tu32 old_mdiv, old_pdiv, old_kdiv;\n\n\told_mdiv = (pll_con0 >> PLL36XX_MDIV_SHIFT) & PLL36XX_MDIV_MASK;\n\told_pdiv = (pll_con0 >> PLL36XX_PDIV_SHIFT) & PLL36XX_PDIV_MASK;\n\told_kdiv = (pll_con1 >> PLL36XX_KDIV_SHIFT) & PLL36XX_KDIV_MASK;\n\n\treturn (rate->mdiv != old_mdiv || rate->pdiv != old_pdiv ||\n\t\trate->kdiv != old_kdiv);\n}\n\nstatic int samsung_pll36xx_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 pll_con0, pll_con1;\n\tconst struct samsung_pll_rate_table *rate;\n\n\trate = samsung_get_pll_settings(pll, drate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for pll clk %s\\n\", __func__,\n\t\t\tdrate, clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\tpll_con0 = readl_relaxed(pll->con_reg);\n\tpll_con1 = readl_relaxed(pll->con_reg + 4);\n\n\tif (!(samsung_pll36xx_mpk_change(rate, pll_con0, pll_con1))) {\n\t\t \n\t\tpll_con0 &= ~(PLL36XX_SDIV_MASK << PLL36XX_SDIV_SHIFT);\n\t\tpll_con0 |= (rate->sdiv << PLL36XX_SDIV_SHIFT);\n\t\twritel_relaxed(pll_con0, pll->con_reg);\n\n\t\treturn 0;\n\t}\n\n\t \n\twritel_relaxed(rate->pdiv * PLL36XX_LOCK_FACTOR, pll->lock_reg);\n\n\t  \n\tpll_con0 &= ~((PLL36XX_MDIV_MASK << PLL36XX_MDIV_SHIFT) |\n\t\t\t(PLL36XX_PDIV_MASK << PLL36XX_PDIV_SHIFT) |\n\t\t\t(PLL36XX_SDIV_MASK << PLL36XX_SDIV_SHIFT));\n\tpll_con0 |= (rate->mdiv << PLL36XX_MDIV_SHIFT) |\n\t\t\t(rate->pdiv << PLL36XX_PDIV_SHIFT) |\n\t\t\t(rate->sdiv << PLL36XX_SDIV_SHIFT);\n\twritel_relaxed(pll_con0, pll->con_reg);\n\n\tpll_con1 &= ~(PLL36XX_KDIV_MASK << PLL36XX_KDIV_SHIFT);\n\tpll_con1 |= rate->kdiv << PLL36XX_KDIV_SHIFT;\n\twritel_relaxed(pll_con1, pll->con_reg + 4);\n\n\tif (pll_con0 & BIT(pll->enable_offs))\n\t\treturn samsung_pll_lock_wait(pll, BIT(pll->lock_offs));\n\n\treturn 0;\n}\n\nstatic const struct clk_ops samsung_pll36xx_clk_ops = {\n\t.recalc_rate = samsung_pll36xx_recalc_rate,\n\t.set_rate = samsung_pll36xx_set_rate,\n\t.round_rate = samsung_pll_round_rate,\n\t.enable = samsung_pll3xxx_enable,\n\t.disable = samsung_pll3xxx_disable,\n};\n\nstatic const struct clk_ops samsung_pll36xx_clk_min_ops = {\n\t.recalc_rate = samsung_pll36xx_recalc_rate,\n};\n\n \n \n#define PLL0822X_LOCK_FACTOR\t\t(150)\n\n#define PLL0822X_MDIV_MASK\t\t(0x3FF)\n#define PLL0822X_PDIV_MASK\t\t(0x3F)\n#define PLL0822X_SDIV_MASK\t\t(0x7)\n#define PLL0822X_MDIV_SHIFT\t\t(16)\n#define PLL0822X_PDIV_SHIFT\t\t(8)\n#define PLL0822X_SDIV_SHIFT\t\t(0)\n#define PLL0822X_LOCK_STAT_SHIFT\t(29)\n#define PLL0822X_ENABLE_SHIFT\t\t(31)\n\nstatic unsigned long samsung_pll0822x_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 mdiv, pdiv, sdiv, pll_con3;\n\tu64 fvco = parent_rate;\n\n\tpll_con3 = readl_relaxed(pll->con_reg);\n\tmdiv = (pll_con3 >> PLL0822X_MDIV_SHIFT) & PLL0822X_MDIV_MASK;\n\tpdiv = (pll_con3 >> PLL0822X_PDIV_SHIFT) & PLL0822X_PDIV_MASK;\n\tsdiv = (pll_con3 >> PLL0822X_SDIV_SHIFT) & PLL0822X_SDIV_MASK;\n\n\tfvco *= mdiv;\n\tdo_div(fvco, (pdiv << sdiv));\n\n\treturn (unsigned long)fvco;\n}\n\nstatic int samsung_pll0822x_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t     unsigned long prate)\n{\n\tconst struct samsung_pll_rate_table *rate;\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 pll_con3;\n\n\t \n\trate = samsung_get_pll_settings(pll, drate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for pll clk %s\\n\", __func__,\n\t\t\tdrate, clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpll_con3 = readl_relaxed(pll->con_reg);\n\tpll_con3 &= ~((PLL0822X_MDIV_MASK << PLL0822X_MDIV_SHIFT) |\n\t\t\t(PLL0822X_PDIV_MASK << PLL0822X_PDIV_SHIFT) |\n\t\t\t(PLL0822X_SDIV_MASK << PLL0822X_SDIV_SHIFT));\n\tpll_con3 |= (rate->mdiv << PLL0822X_MDIV_SHIFT) |\n\t\t\t(rate->pdiv << PLL0822X_PDIV_SHIFT) |\n\t\t\t(rate->sdiv << PLL0822X_SDIV_SHIFT);\n\n\t \n\twritel_relaxed(rate->pdiv * PLL0822X_LOCK_FACTOR,\n\t\t\tpll->lock_reg);\n\n\t \n\twritel_relaxed(pll_con3, pll->con_reg);\n\n\t \n\tif (pll_con3 & BIT(pll->enable_offs))\n\t\treturn samsung_pll_lock_wait(pll, BIT(pll->lock_offs));\n\n\treturn 0;\n}\n\nstatic const struct clk_ops samsung_pll0822x_clk_ops = {\n\t.recalc_rate = samsung_pll0822x_recalc_rate,\n\t.round_rate = samsung_pll_round_rate,\n\t.set_rate = samsung_pll0822x_set_rate,\n\t.enable = samsung_pll3xxx_enable,\n\t.disable = samsung_pll3xxx_disable,\n};\n\nstatic const struct clk_ops samsung_pll0822x_clk_min_ops = {\n\t.recalc_rate = samsung_pll0822x_recalc_rate,\n};\n\n \n \n#define PLL0831X_LOCK_FACTOR\t\t(500)\n\n#define PLL0831X_KDIV_MASK\t\t(0xFFFF)\n#define PLL0831X_MDIV_MASK\t\t(0x1FF)\n#define PLL0831X_PDIV_MASK\t\t(0x3F)\n#define PLL0831X_SDIV_MASK\t\t(0x7)\n#define PLL0831X_MDIV_SHIFT\t\t(16)\n#define PLL0831X_PDIV_SHIFT\t\t(8)\n#define PLL0831X_SDIV_SHIFT\t\t(0)\n#define PLL0831X_KDIV_SHIFT\t\t(0)\n#define PLL0831X_LOCK_STAT_SHIFT\t(29)\n#define PLL0831X_ENABLE_SHIFT\t\t(31)\n\nstatic unsigned long samsung_pll0831x_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 mdiv, pdiv, sdiv, pll_con3, pll_con5;\n\ts16 kdiv;\n\tu64 fvco = parent_rate;\n\n\tpll_con3 = readl_relaxed(pll->con_reg);\n\tpll_con5 = readl_relaxed(pll->con_reg + 8);\n\tmdiv = (pll_con3 >> PLL0831X_MDIV_SHIFT) & PLL0831X_MDIV_MASK;\n\tpdiv = (pll_con3 >> PLL0831X_PDIV_SHIFT) & PLL0831X_PDIV_MASK;\n\tsdiv = (pll_con3 >> PLL0831X_SDIV_SHIFT) & PLL0831X_SDIV_MASK;\n\tkdiv = (s16)((pll_con5 >> PLL0831X_KDIV_SHIFT) & PLL0831X_KDIV_MASK);\n\n\tfvco *= (mdiv << 16) + kdiv;\n\tdo_div(fvco, (pdiv << sdiv));\n\tfvco >>= 16;\n\n\treturn (unsigned long)fvco;\n}\n\nstatic int samsung_pll0831x_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tconst struct samsung_pll_rate_table *rate;\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 pll_con3, pll_con5;\n\n\t \n\trate = samsung_get_pll_settings(pll, drate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for pll clk %s\\n\", __func__,\n\t\t\tdrate, clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\tpll_con3 = readl_relaxed(pll->con_reg);\n\tpll_con5 = readl_relaxed(pll->con_reg + 8);\n\n\t \n\tpll_con3 &= ~((PLL0831X_MDIV_MASK << PLL0831X_MDIV_SHIFT) |\n\t\t\t(PLL0831X_PDIV_MASK << PLL0831X_PDIV_SHIFT) |\n\t\t\t(PLL0831X_SDIV_MASK << PLL0831X_SDIV_SHIFT));\n\tpll_con3 |= (rate->mdiv << PLL0831X_MDIV_SHIFT) |\n\t\t\t(rate->pdiv << PLL0831X_PDIV_SHIFT) |\n\t\t\t(rate->sdiv << PLL0831X_SDIV_SHIFT);\n\tpll_con5 &= ~(PLL0831X_KDIV_MASK << PLL0831X_KDIV_SHIFT);\n\t \n\tpll_con5 |= ((u16)rate->kdiv << PLL0831X_KDIV_SHIFT);\n\n\t \n\twritel_relaxed(rate->pdiv * PLL0831X_LOCK_FACTOR, pll->lock_reg);\n\n\t \n\twritel_relaxed(pll_con3, pll->con_reg);\n\twritel_relaxed(pll_con5, pll->con_reg + 8);\n\n\t \n\tif (pll_con3 & BIT(pll->enable_offs))\n\t\treturn samsung_pll_lock_wait(pll, BIT(pll->lock_offs));\n\n\treturn 0;\n}\n\nstatic const struct clk_ops samsung_pll0831x_clk_ops = {\n\t.recalc_rate = samsung_pll0831x_recalc_rate,\n\t.set_rate = samsung_pll0831x_set_rate,\n\t.round_rate = samsung_pll_round_rate,\n\t.enable = samsung_pll3xxx_enable,\n\t.disable = samsung_pll3xxx_disable,\n};\n\nstatic const struct clk_ops samsung_pll0831x_clk_min_ops = {\n\t.recalc_rate = samsung_pll0831x_recalc_rate,\n};\n\n \n#define PLL4502_LOCK_FACTOR\t400\n#define PLL4508_LOCK_FACTOR\t240\n\n#define PLL45XX_MDIV_MASK\t(0x3FF)\n#define PLL45XX_PDIV_MASK\t(0x3F)\n#define PLL45XX_SDIV_MASK\t(0x7)\n#define PLL45XX_AFC_MASK\t(0x1F)\n#define PLL45XX_MDIV_SHIFT\t(16)\n#define PLL45XX_PDIV_SHIFT\t(8)\n#define PLL45XX_SDIV_SHIFT\t(0)\n#define PLL45XX_AFC_SHIFT\t(0)\n\n#define PLL45XX_ENABLE\t\tBIT(31)\n#define PLL45XX_LOCKED\t\tBIT(29)\n\nstatic unsigned long samsung_pll45xx_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 mdiv, pdiv, sdiv, pll_con;\n\tu64 fvco = parent_rate;\n\n\tpll_con = readl_relaxed(pll->con_reg);\n\tmdiv = (pll_con >> PLL45XX_MDIV_SHIFT) & PLL45XX_MDIV_MASK;\n\tpdiv = (pll_con >> PLL45XX_PDIV_SHIFT) & PLL45XX_PDIV_MASK;\n\tsdiv = (pll_con >> PLL45XX_SDIV_SHIFT) & PLL45XX_SDIV_MASK;\n\n\tif (pll->type == pll_4508)\n\t\tsdiv = sdiv - 1;\n\n\tfvco *= mdiv;\n\tdo_div(fvco, (pdiv << sdiv));\n\n\treturn (unsigned long)fvco;\n}\n\nstatic bool samsung_pll45xx_mp_change(u32 pll_con0, u32 pll_con1,\n\t\t\t\tconst struct samsung_pll_rate_table *rate)\n{\n\tu32 old_mdiv, old_pdiv, old_afc;\n\n\told_mdiv = (pll_con0 >> PLL45XX_MDIV_SHIFT) & PLL45XX_MDIV_MASK;\n\told_pdiv = (pll_con0 >> PLL45XX_PDIV_SHIFT) & PLL45XX_PDIV_MASK;\n\told_afc = (pll_con1 >> PLL45XX_AFC_SHIFT) & PLL45XX_AFC_MASK;\n\n\treturn (old_mdiv != rate->mdiv || old_pdiv != rate->pdiv\n\t\t|| old_afc != rate->afc);\n}\n\nstatic int samsung_pll45xx_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t\tunsigned long prate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tconst struct samsung_pll_rate_table *rate;\n\tu32 con0, con1;\n\n\t \n\trate = samsung_get_pll_settings(pll, drate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for pll clk %s\\n\", __func__,\n\t\t\tdrate, clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\tcon0 = readl_relaxed(pll->con_reg);\n\tcon1 = readl_relaxed(pll->con_reg + 0x4);\n\n\tif (!(samsung_pll45xx_mp_change(con0, con1, rate))) {\n\t\t \n\t\tcon0 &= ~(PLL45XX_SDIV_MASK << PLL45XX_SDIV_SHIFT);\n\t\tcon0 |= rate->sdiv << PLL45XX_SDIV_SHIFT;\n\t\twritel_relaxed(con0, pll->con_reg);\n\n\t\treturn 0;\n\t}\n\n\t \n\tcon0 &= ~((PLL45XX_MDIV_MASK << PLL45XX_MDIV_SHIFT) |\n\t\t\t(PLL45XX_PDIV_MASK << PLL45XX_PDIV_SHIFT) |\n\t\t\t(PLL45XX_SDIV_MASK << PLL45XX_SDIV_SHIFT));\n\tcon0 |= (rate->mdiv << PLL45XX_MDIV_SHIFT) |\n\t\t\t(rate->pdiv << PLL45XX_PDIV_SHIFT) |\n\t\t\t(rate->sdiv << PLL45XX_SDIV_SHIFT);\n\n\t \n\tcon1 = readl_relaxed(pll->con_reg + 0x4);\n\tcon1 &= ~(PLL45XX_AFC_MASK << PLL45XX_AFC_SHIFT);\n\tcon1 |= (rate->afc << PLL45XX_AFC_SHIFT);\n\n\t \n\tswitch (pll->type) {\n\tcase pll_4502:\n\t\twritel_relaxed(rate->pdiv * PLL4502_LOCK_FACTOR, pll->lock_reg);\n\t\tbreak;\n\tcase pll_4508:\n\t\twritel_relaxed(rate->pdiv * PLL4508_LOCK_FACTOR, pll->lock_reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\twritel_relaxed(con1, pll->con_reg + 0x4);\n\twritel_relaxed(con0, pll->con_reg);\n\n\t \n\treturn samsung_pll_lock_wait(pll, PLL45XX_LOCKED);\n}\n\nstatic const struct clk_ops samsung_pll45xx_clk_ops = {\n\t.recalc_rate = samsung_pll45xx_recalc_rate,\n\t.round_rate = samsung_pll_round_rate,\n\t.set_rate = samsung_pll45xx_set_rate,\n};\n\nstatic const struct clk_ops samsung_pll45xx_clk_min_ops = {\n\t.recalc_rate = samsung_pll45xx_recalc_rate,\n};\n\n \n#define PLL46XX_LOCK_FACTOR\t3000\n\n#define PLL46XX_VSEL_MASK\t(1)\n#define PLL46XX_MDIV_MASK\t(0x1FF)\n#define PLL1460X_MDIV_MASK\t(0x3FF)\n\n#define PLL46XX_PDIV_MASK\t(0x3F)\n#define PLL46XX_SDIV_MASK\t(0x7)\n#define PLL46XX_VSEL_SHIFT\t(27)\n#define PLL46XX_MDIV_SHIFT\t(16)\n#define PLL46XX_PDIV_SHIFT\t(8)\n#define PLL46XX_SDIV_SHIFT\t(0)\n\n#define PLL46XX_KDIV_MASK\t(0xFFFF)\n#define PLL4650C_KDIV_MASK\t(0xFFF)\n#define PLL46XX_KDIV_SHIFT\t(0)\n#define PLL46XX_MFR_MASK\t(0x3F)\n#define PLL46XX_MRR_MASK\t(0x1F)\n#define PLL46XX_KDIV_SHIFT\t(0)\n#define PLL46XX_MFR_SHIFT\t(16)\n#define PLL46XX_MRR_SHIFT\t(24)\n\n#define PLL46XX_ENABLE\t\tBIT(31)\n#define PLL46XX_LOCKED\t\tBIT(29)\n#define PLL46XX_VSEL\t\tBIT(27)\n\nstatic unsigned long samsung_pll46xx_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 mdiv, pdiv, sdiv, kdiv, pll_con0, pll_con1, shift;\n\tu64 fvco = parent_rate;\n\n\tpll_con0 = readl_relaxed(pll->con_reg);\n\tpll_con1 = readl_relaxed(pll->con_reg + 4);\n\tmdiv = (pll_con0 >> PLL46XX_MDIV_SHIFT) & ((pll->type == pll_1460x) ?\n\t\t\t\tPLL1460X_MDIV_MASK : PLL46XX_MDIV_MASK);\n\tpdiv = (pll_con0 >> PLL46XX_PDIV_SHIFT) & PLL46XX_PDIV_MASK;\n\tsdiv = (pll_con0 >> PLL46XX_SDIV_SHIFT) & PLL46XX_SDIV_MASK;\n\tkdiv = pll->type == pll_4650c ? pll_con1 & PLL4650C_KDIV_MASK :\n\t\t\t\t\tpll_con1 & PLL46XX_KDIV_MASK;\n\n\tshift = ((pll->type == pll_4600) || (pll->type == pll_1460x)) ? 16 : 10;\n\n\tfvco *= (mdiv << shift) + kdiv;\n\tdo_div(fvco, (pdiv << sdiv));\n\tfvco >>= shift;\n\n\treturn (unsigned long)fvco;\n}\n\nstatic bool samsung_pll46xx_mpk_change(u32 pll_con0, u32 pll_con1,\n\t\t\t\tconst struct samsung_pll_rate_table *rate)\n{\n\tu32 old_mdiv, old_pdiv, old_kdiv;\n\n\told_mdiv = (pll_con0 >> PLL46XX_MDIV_SHIFT) & PLL46XX_MDIV_MASK;\n\told_pdiv = (pll_con0 >> PLL46XX_PDIV_SHIFT) & PLL46XX_PDIV_MASK;\n\told_kdiv = (pll_con1 >> PLL46XX_KDIV_SHIFT) & PLL46XX_KDIV_MASK;\n\n\treturn (old_mdiv != rate->mdiv || old_pdiv != rate->pdiv\n\t\t|| old_kdiv != rate->kdiv);\n}\n\nstatic int samsung_pll46xx_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t\tunsigned long prate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tconst struct samsung_pll_rate_table *rate;\n\tu32 con0, con1, lock;\n\n\t \n\trate = samsung_get_pll_settings(pll, drate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for pll clk %s\\n\", __func__,\n\t\t\tdrate, clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\tcon0 = readl_relaxed(pll->con_reg);\n\tcon1 = readl_relaxed(pll->con_reg + 0x4);\n\n\tif (!(samsung_pll46xx_mpk_change(con0, con1, rate))) {\n\t\t \n\t\tcon0 &= ~(PLL46XX_SDIV_MASK << PLL46XX_SDIV_SHIFT);\n\t\tcon0 |= rate->sdiv << PLL46XX_SDIV_SHIFT;\n\t\twritel_relaxed(con0, pll->con_reg);\n\n\t\treturn 0;\n\t}\n\n\t \n\tlock = rate->pdiv * PLL46XX_LOCK_FACTOR;\n\tif (lock > 0xffff)\n\t\t \n\t\tlock = 0xffff;\n\n\t \n\tif (pll->type == pll_1460x) {\n\t\tcon0 &= ~((PLL1460X_MDIV_MASK << PLL46XX_MDIV_SHIFT) |\n\t\t\t(PLL46XX_PDIV_MASK << PLL46XX_PDIV_SHIFT) |\n\t\t\t(PLL46XX_SDIV_MASK << PLL46XX_SDIV_SHIFT));\n\t} else {\n\t\tcon0 &= ~((PLL46XX_MDIV_MASK << PLL46XX_MDIV_SHIFT) |\n\t\t\t(PLL46XX_PDIV_MASK << PLL46XX_PDIV_SHIFT) |\n\t\t\t(PLL46XX_SDIV_MASK << PLL46XX_SDIV_SHIFT) |\n\t\t\t(PLL46XX_VSEL_MASK << PLL46XX_VSEL_SHIFT));\n\t\tcon0 |=\trate->vsel << PLL46XX_VSEL_SHIFT;\n\t}\n\n\tcon0 |= (rate->mdiv << PLL46XX_MDIV_SHIFT) |\n\t\t\t(rate->pdiv << PLL46XX_PDIV_SHIFT) |\n\t\t\t(rate->sdiv << PLL46XX_SDIV_SHIFT);\n\n\t \n\tcon1 = readl_relaxed(pll->con_reg + 0x4);\n\tcon1 &= ~((PLL46XX_KDIV_MASK << PLL46XX_KDIV_SHIFT) |\n\t\t\t(PLL46XX_MFR_MASK << PLL46XX_MFR_SHIFT) |\n\t\t\t(PLL46XX_MRR_MASK << PLL46XX_MRR_SHIFT));\n\tcon1 |= (rate->kdiv << PLL46XX_KDIV_SHIFT) |\n\t\t\t(rate->mfr << PLL46XX_MFR_SHIFT) |\n\t\t\t(rate->mrr << PLL46XX_MRR_SHIFT);\n\n\t \n\twritel_relaxed(lock, pll->lock_reg);\n\twritel_relaxed(con0, pll->con_reg);\n\twritel_relaxed(con1, pll->con_reg + 0x4);\n\n\t \n\treturn samsung_pll_lock_wait(pll, PLL46XX_LOCKED);\n}\n\nstatic const struct clk_ops samsung_pll46xx_clk_ops = {\n\t.recalc_rate = samsung_pll46xx_recalc_rate,\n\t.round_rate = samsung_pll_round_rate,\n\t.set_rate = samsung_pll46xx_set_rate,\n};\n\nstatic const struct clk_ops samsung_pll46xx_clk_min_ops = {\n\t.recalc_rate = samsung_pll46xx_recalc_rate,\n};\n\n \n\n#define PLL6552_MDIV_MASK\t0x3ff\n#define PLL6552_PDIV_MASK\t0x3f\n#define PLL6552_SDIV_MASK\t0x7\n#define PLL6552_MDIV_SHIFT\t16\n#define PLL6552_MDIV_SHIFT_2416\t14\n#define PLL6552_PDIV_SHIFT\t8\n#define PLL6552_PDIV_SHIFT_2416\t5\n#define PLL6552_SDIV_SHIFT\t0\n\nstatic unsigned long samsung_pll6552_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 mdiv, pdiv, sdiv, pll_con;\n\tu64 fvco = parent_rate;\n\n\tpll_con = readl_relaxed(pll->con_reg);\n\tif (pll->type == pll_6552_s3c2416) {\n\t\tmdiv = (pll_con >> PLL6552_MDIV_SHIFT_2416) & PLL6552_MDIV_MASK;\n\t\tpdiv = (pll_con >> PLL6552_PDIV_SHIFT_2416) & PLL6552_PDIV_MASK;\n\t} else {\n\t\tmdiv = (pll_con >> PLL6552_MDIV_SHIFT) & PLL6552_MDIV_MASK;\n\t\tpdiv = (pll_con >> PLL6552_PDIV_SHIFT) & PLL6552_PDIV_MASK;\n\t}\n\tsdiv = (pll_con >> PLL6552_SDIV_SHIFT) & PLL6552_SDIV_MASK;\n\n\tfvco *= mdiv;\n\tdo_div(fvco, (pdiv << sdiv));\n\n\treturn (unsigned long)fvco;\n}\n\nstatic const struct clk_ops samsung_pll6552_clk_ops = {\n\t.recalc_rate = samsung_pll6552_recalc_rate,\n};\n\n \n\n#define PLL6553_MDIV_MASK\t0xff\n#define PLL6553_PDIV_MASK\t0x3f\n#define PLL6553_SDIV_MASK\t0x7\n#define PLL6553_KDIV_MASK\t0xffff\n#define PLL6553_MDIV_SHIFT\t16\n#define PLL6553_PDIV_SHIFT\t8\n#define PLL6553_SDIV_SHIFT\t0\n#define PLL6553_KDIV_SHIFT\t0\n\nstatic unsigned long samsung_pll6553_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 mdiv, pdiv, sdiv, kdiv, pll_con0, pll_con1;\n\tu64 fvco = parent_rate;\n\n\tpll_con0 = readl_relaxed(pll->con_reg);\n\tpll_con1 = readl_relaxed(pll->con_reg + 0x4);\n\tmdiv = (pll_con0 >> PLL6553_MDIV_SHIFT) & PLL6553_MDIV_MASK;\n\tpdiv = (pll_con0 >> PLL6553_PDIV_SHIFT) & PLL6553_PDIV_MASK;\n\tsdiv = (pll_con0 >> PLL6553_SDIV_SHIFT) & PLL6553_SDIV_MASK;\n\tkdiv = (pll_con1 >> PLL6553_KDIV_SHIFT) & PLL6553_KDIV_MASK;\n\n\tfvco *= (mdiv << 16) + kdiv;\n\tdo_div(fvco, (pdiv << sdiv));\n\tfvco >>= 16;\n\n\treturn (unsigned long)fvco;\n}\n\nstatic const struct clk_ops samsung_pll6553_clk_ops = {\n\t.recalc_rate = samsung_pll6553_recalc_rate,\n};\n\n \n\n#define PLL2550X_R_MASK       (0x1)\n#define PLL2550X_P_MASK       (0x3F)\n#define PLL2550X_M_MASK       (0x3FF)\n#define PLL2550X_S_MASK       (0x7)\n#define PLL2550X_R_SHIFT      (20)\n#define PLL2550X_P_SHIFT      (14)\n#define PLL2550X_M_SHIFT      (4)\n#define PLL2550X_S_SHIFT      (0)\n\nstatic unsigned long samsung_pll2550x_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 r, p, m, s, pll_stat;\n\tu64 fvco = parent_rate;\n\n\tpll_stat = readl_relaxed(pll->con_reg);\n\tr = (pll_stat >> PLL2550X_R_SHIFT) & PLL2550X_R_MASK;\n\tif (!r)\n\t\treturn 0;\n\tp = (pll_stat >> PLL2550X_P_SHIFT) & PLL2550X_P_MASK;\n\tm = (pll_stat >> PLL2550X_M_SHIFT) & PLL2550X_M_MASK;\n\ts = (pll_stat >> PLL2550X_S_SHIFT) & PLL2550X_S_MASK;\n\n\tfvco *= m;\n\tdo_div(fvco, (p << s));\n\n\treturn (unsigned long)fvco;\n}\n\nstatic const struct clk_ops samsung_pll2550x_clk_ops = {\n\t.recalc_rate = samsung_pll2550x_recalc_rate,\n};\n\n \n\n \n#define PLL2550XX_LOCK_FACTOR 270\n\n#define PLL2550XX_M_MASK\t\t0x3FF\n#define PLL2550XX_P_MASK\t\t0x3F\n#define PLL2550XX_S_MASK\t\t0x7\n#define PLL2550XX_LOCK_STAT_MASK\t0x1\n#define PLL2550XX_M_SHIFT\t\t9\n#define PLL2550XX_P_SHIFT\t\t3\n#define PLL2550XX_S_SHIFT\t\t0\n#define PLL2550XX_LOCK_STAT_SHIFT\t21\n\nstatic unsigned long samsung_pll2550xx_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 mdiv, pdiv, sdiv, pll_con;\n\tu64 fvco = parent_rate;\n\n\tpll_con = readl_relaxed(pll->con_reg);\n\tmdiv = (pll_con >> PLL2550XX_M_SHIFT) & PLL2550XX_M_MASK;\n\tpdiv = (pll_con >> PLL2550XX_P_SHIFT) & PLL2550XX_P_MASK;\n\tsdiv = (pll_con >> PLL2550XX_S_SHIFT) & PLL2550XX_S_MASK;\n\n\tfvco *= mdiv;\n\tdo_div(fvco, (pdiv << sdiv));\n\n\treturn (unsigned long)fvco;\n}\n\nstatic inline bool samsung_pll2550xx_mp_change(u32 mdiv, u32 pdiv, u32 pll_con)\n{\n\tu32 old_mdiv, old_pdiv;\n\n\told_mdiv = (pll_con >> PLL2550XX_M_SHIFT) & PLL2550XX_M_MASK;\n\told_pdiv = (pll_con >> PLL2550XX_P_SHIFT) & PLL2550XX_P_MASK;\n\n\treturn mdiv != old_mdiv || pdiv != old_pdiv;\n}\n\nstatic int samsung_pll2550xx_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t\tunsigned long prate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tconst struct samsung_pll_rate_table *rate;\n\tu32 tmp;\n\n\t \n\trate = samsung_get_pll_settings(pll, drate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for pll clk %s\\n\", __func__,\n\t\t\tdrate, clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = readl_relaxed(pll->con_reg);\n\n\tif (!(samsung_pll2550xx_mp_change(rate->mdiv, rate->pdiv, tmp))) {\n\t\t \n\t\ttmp &= ~(PLL2550XX_S_MASK << PLL2550XX_S_SHIFT);\n\t\ttmp |= rate->sdiv << PLL2550XX_S_SHIFT;\n\t\twritel_relaxed(tmp, pll->con_reg);\n\n\t\treturn 0;\n\t}\n\n\t \n\twritel_relaxed(rate->pdiv * PLL2550XX_LOCK_FACTOR, pll->lock_reg);\n\n\t \n\ttmp &= ~((PLL2550XX_M_MASK << PLL2550XX_M_SHIFT) |\n\t\t\t(PLL2550XX_P_MASK << PLL2550XX_P_SHIFT) |\n\t\t\t(PLL2550XX_S_MASK << PLL2550XX_S_SHIFT));\n\ttmp |= (rate->mdiv << PLL2550XX_M_SHIFT) |\n\t\t\t(rate->pdiv << PLL2550XX_P_SHIFT) |\n\t\t\t(rate->sdiv << PLL2550XX_S_SHIFT);\n\twritel_relaxed(tmp, pll->con_reg);\n\n\t \n\treturn samsung_pll_lock_wait(pll,\n\t\t\tPLL2550XX_LOCK_STAT_MASK << PLL2550XX_LOCK_STAT_SHIFT);\n}\n\nstatic const struct clk_ops samsung_pll2550xx_clk_ops = {\n\t.recalc_rate = samsung_pll2550xx_recalc_rate,\n\t.round_rate = samsung_pll_round_rate,\n\t.set_rate = samsung_pll2550xx_set_rate,\n};\n\nstatic const struct clk_ops samsung_pll2550xx_clk_min_ops = {\n\t.recalc_rate = samsung_pll2550xx_recalc_rate,\n};\n\n \n\n \n#define PLL2650X_LOCK_FACTOR\t\t3000\n\n#define PLL2650X_M_MASK\t\t\t0x1ff\n#define PLL2650X_P_MASK\t\t\t0x3f\n#define PLL2650X_S_MASK\t\t\t0x7\n#define PLL2650X_K_MASK\t\t\t0xffff\n#define PLL2650X_LOCK_STAT_MASK\t\t0x1\n#define PLL2650X_M_SHIFT\t\t16\n#define PLL2650X_P_SHIFT\t\t8\n#define PLL2650X_S_SHIFT\t\t0\n#define PLL2650X_K_SHIFT\t\t0\n#define PLL2650X_LOCK_STAT_SHIFT\t29\n#define PLL2650X_PLL_ENABLE_SHIFT\t31\n\nstatic unsigned long samsung_pll2650x_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu64 fout = parent_rate;\n\tu32 mdiv, pdiv, sdiv, pll_con0, pll_con1;\n\ts16 kdiv;\n\n\tpll_con0 = readl_relaxed(pll->con_reg);\n\tmdiv = (pll_con0 >> PLL2650X_M_SHIFT) & PLL2650X_M_MASK;\n\tpdiv = (pll_con0 >> PLL2650X_P_SHIFT) & PLL2650X_P_MASK;\n\tsdiv = (pll_con0 >> PLL2650X_S_SHIFT) & PLL2650X_S_MASK;\n\n\tpll_con1 = readl_relaxed(pll->con_reg + 4);\n\tkdiv = (s16)((pll_con1 >> PLL2650X_K_SHIFT) & PLL2650X_K_MASK);\n\n\tfout *= (mdiv << 16) + kdiv;\n\tdo_div(fout, (pdiv << sdiv));\n\tfout >>= 16;\n\n\treturn (unsigned long)fout;\n}\n\nstatic int samsung_pll2650x_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t\tunsigned long prate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tconst struct samsung_pll_rate_table *rate;\n\tu32 con0, con1;\n\n\t \n\trate = samsung_get_pll_settings(pll, drate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for pll clk %s\\n\", __func__,\n\t\t\tdrate, clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\tcon0 = readl_relaxed(pll->con_reg);\n\tcon1 = readl_relaxed(pll->con_reg + 4);\n\n\t \n\twritel_relaxed(rate->pdiv * PLL2650X_LOCK_FACTOR, pll->lock_reg);\n\n\t \n\tcon0 &= ~((PLL2650X_M_MASK << PLL2650X_M_SHIFT) |\n\t\t\t(PLL2650X_P_MASK << PLL2650X_P_SHIFT) |\n\t\t\t(PLL2650X_S_MASK << PLL2650X_S_SHIFT));\n\tcon0 |= (rate->mdiv << PLL2650X_M_SHIFT) |\n\t\t\t(rate->pdiv << PLL2650X_P_SHIFT) |\n\t\t\t(rate->sdiv << PLL2650X_S_SHIFT);\n\tcon0 |= (1 << PLL2650X_PLL_ENABLE_SHIFT);\n\twritel_relaxed(con0, pll->con_reg);\n\n\tcon1 &= ~(PLL2650X_K_MASK << PLL2650X_K_SHIFT);\n\tcon1 |= ((rate->kdiv & PLL2650X_K_MASK) << PLL2650X_K_SHIFT);\n\twritel_relaxed(con1, pll->con_reg + 4);\n\n\t \n\treturn samsung_pll_lock_wait(pll,\n\t\t\tPLL2650X_LOCK_STAT_MASK << PLL2650X_LOCK_STAT_SHIFT);\n}\n\nstatic const struct clk_ops samsung_pll2650x_clk_ops = {\n\t.recalc_rate = samsung_pll2650x_recalc_rate,\n\t.round_rate = samsung_pll_round_rate,\n\t.set_rate = samsung_pll2650x_set_rate,\n};\n\nstatic const struct clk_ops samsung_pll2650x_clk_min_ops = {\n\t.recalc_rate = samsung_pll2650x_recalc_rate,\n};\n\n \n\n \n#define PLL2650XX_LOCK_FACTOR 3000\n\n#define PLL2650XX_MDIV_SHIFT\t\t9\n#define PLL2650XX_PDIV_SHIFT\t\t3\n#define PLL2650XX_SDIV_SHIFT\t\t0\n#define PLL2650XX_KDIV_SHIFT\t\t0\n#define PLL2650XX_MDIV_MASK\t\t0x1ff\n#define PLL2650XX_PDIV_MASK\t\t0x3f\n#define PLL2650XX_SDIV_MASK\t\t0x7\n#define PLL2650XX_KDIV_MASK\t\t0xffff\n#define PLL2650XX_PLL_ENABLE_SHIFT\t23\n#define PLL2650XX_PLL_LOCKTIME_SHIFT\t21\n#define PLL2650XX_PLL_FOUTMASK_SHIFT\t31\n\nstatic unsigned long samsung_pll2650xx_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 mdiv, pdiv, sdiv, pll_con0, pll_con2;\n\ts16 kdiv;\n\tu64 fvco = parent_rate;\n\n\tpll_con0 = readl_relaxed(pll->con_reg);\n\tpll_con2 = readl_relaxed(pll->con_reg + 8);\n\tmdiv = (pll_con0 >> PLL2650XX_MDIV_SHIFT) & PLL2650XX_MDIV_MASK;\n\tpdiv = (pll_con0 >> PLL2650XX_PDIV_SHIFT) & PLL2650XX_PDIV_MASK;\n\tsdiv = (pll_con0 >> PLL2650XX_SDIV_SHIFT) & PLL2650XX_SDIV_MASK;\n\tkdiv = (s16)(pll_con2 & PLL2650XX_KDIV_MASK);\n\n\tfvco *= (mdiv << 16) + kdiv;\n\tdo_div(fvco, (pdiv << sdiv));\n\tfvco >>= 16;\n\n\treturn (unsigned long)fvco;\n}\n\nstatic int samsung_pll2650xx_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct samsung_clk_pll *pll = to_clk_pll(hw);\n\tu32 pll_con0, pll_con2;\n\tconst struct samsung_pll_rate_table *rate;\n\n\trate = samsung_get_pll_settings(pll, drate);\n\tif (!rate) {\n\t\tpr_err(\"%s: Invalid rate : %lu for pll clk %s\\n\", __func__,\n\t\t\tdrate, clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\tpll_con0 = readl_relaxed(pll->con_reg);\n\tpll_con2 = readl_relaxed(pll->con_reg + 8);\n\n\t  \n\tpll_con0 &= ~(PLL2650XX_MDIV_MASK << PLL2650XX_MDIV_SHIFT |\n\t\t\tPLL2650XX_PDIV_MASK << PLL2650XX_PDIV_SHIFT |\n\t\t\tPLL2650XX_SDIV_MASK << PLL2650XX_SDIV_SHIFT);\n\tpll_con0 |= rate->mdiv << PLL2650XX_MDIV_SHIFT;\n\tpll_con0 |= rate->pdiv << PLL2650XX_PDIV_SHIFT;\n\tpll_con0 |= rate->sdiv << PLL2650XX_SDIV_SHIFT;\n\tpll_con0 |= 1 << PLL2650XX_PLL_ENABLE_SHIFT;\n\tpll_con0 |= 1 << PLL2650XX_PLL_FOUTMASK_SHIFT;\n\n\tpll_con2 &= ~(PLL2650XX_KDIV_MASK << PLL2650XX_KDIV_SHIFT);\n\tpll_con2 |= ((~(rate->kdiv) + 1) & PLL2650XX_KDIV_MASK)\n\t\t\t<< PLL2650XX_KDIV_SHIFT;\n\n\t \n\twritel_relaxed(PLL2650XX_LOCK_FACTOR * rate->pdiv, pll->lock_reg);\n\n\twritel_relaxed(pll_con0, pll->con_reg);\n\twritel_relaxed(pll_con2, pll->con_reg + 8);\n\n\treturn samsung_pll_lock_wait(pll, 0x1 << PLL2650XX_PLL_LOCKTIME_SHIFT);\n}\n\nstatic const struct clk_ops samsung_pll2650xx_clk_ops = {\n\t.recalc_rate = samsung_pll2650xx_recalc_rate,\n\t.set_rate = samsung_pll2650xx_set_rate,\n\t.round_rate = samsung_pll_round_rate,\n};\n\nstatic const struct clk_ops samsung_pll2650xx_clk_min_ops = {\n\t.recalc_rate = samsung_pll2650xx_recalc_rate,\n};\n\nstatic void __init _samsung_clk_register_pll(struct samsung_clk_provider *ctx,\n\t\t\t\tconst struct samsung_pll_clock *pll_clk)\n{\n\tstruct samsung_clk_pll *pll;\n\tstruct clk_init_data init;\n\tint ret, len;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll) {\n\t\tpr_err(\"%s: could not allocate pll clk %s\\n\",\n\t\t\t__func__, pll_clk->name);\n\t\treturn;\n\t}\n\n\tinit.name = pll_clk->name;\n\tinit.flags = pll_clk->flags;\n\tinit.parent_names = &pll_clk->parent_name;\n\tinit.num_parents = 1;\n\n\tif (pll_clk->rate_table) {\n\t\t \n\t\tfor (len = 0; pll_clk->rate_table[len].rate != 0; )\n\t\t\tlen++;\n\n\t\tpll->rate_count = len;\n\t\tpll->rate_table = kmemdup(pll_clk->rate_table,\n\t\t\t\t\tpll->rate_count *\n\t\t\t\t\tsizeof(struct samsung_pll_rate_table),\n\t\t\t\t\tGFP_KERNEL);\n\t\tWARN(!pll->rate_table,\n\t\t\t\"%s: could not allocate rate table for %s\\n\",\n\t\t\t__func__, pll_clk->name);\n\t}\n\n\tswitch (pll_clk->type) {\n\tcase pll_2126:\n\t\tinit.ops = &samsung_pll2126_clk_ops;\n\t\tbreak;\n\tcase pll_3000:\n\t\tinit.ops = &samsung_pll3000_clk_ops;\n\t\tbreak;\n\t \n\tcase pll_35xx:\n\tcase pll_2550:\n\tcase pll_1450x:\n\tcase pll_1451x:\n\tcase pll_1452x:\n\tcase pll_142xx:\n\t\tpll->enable_offs = PLL35XX_ENABLE_SHIFT;\n\t\tpll->lock_offs = PLL35XX_LOCK_STAT_SHIFT;\n\t\tif (!pll->rate_table)\n\t\t\tinit.ops = &samsung_pll35xx_clk_min_ops;\n\t\telse\n\t\t\tinit.ops = &samsung_pll35xx_clk_ops;\n\t\tbreak;\n\tcase pll_1417x:\n\tcase pll_0818x:\n\tcase pll_0822x:\n\t\tpll->enable_offs = PLL0822X_ENABLE_SHIFT;\n\t\tpll->lock_offs = PLL0822X_LOCK_STAT_SHIFT;\n\t\tif (!pll->rate_table)\n\t\t\tinit.ops = &samsung_pll0822x_clk_min_ops;\n\t\telse\n\t\t\tinit.ops = &samsung_pll0822x_clk_ops;\n\t\tbreak;\n\tcase pll_4500:\n\t\tinit.ops = &samsung_pll45xx_clk_min_ops;\n\t\tbreak;\n\tcase pll_4502:\n\tcase pll_4508:\n\t\tif (!pll->rate_table)\n\t\t\tinit.ops = &samsung_pll45xx_clk_min_ops;\n\t\telse\n\t\t\tinit.ops = &samsung_pll45xx_clk_ops;\n\t\tbreak;\n\t \n\tcase pll_36xx:\n\tcase pll_2650:\n\t\tpll->enable_offs = PLL36XX_ENABLE_SHIFT;\n\t\tpll->lock_offs = PLL36XX_LOCK_STAT_SHIFT;\n\t\tif (!pll->rate_table)\n\t\t\tinit.ops = &samsung_pll36xx_clk_min_ops;\n\t\telse\n\t\t\tinit.ops = &samsung_pll36xx_clk_ops;\n\t\tbreak;\n\tcase pll_0831x:\n\t\tpll->enable_offs = PLL0831X_ENABLE_SHIFT;\n\t\tpll->lock_offs = PLL0831X_LOCK_STAT_SHIFT;\n\t\tif (!pll->rate_table)\n\t\t\tinit.ops = &samsung_pll0831x_clk_min_ops;\n\t\telse\n\t\t\tinit.ops = &samsung_pll0831x_clk_ops;\n\t\tbreak;\n\tcase pll_6552:\n\tcase pll_6552_s3c2416:\n\t\tinit.ops = &samsung_pll6552_clk_ops;\n\t\tbreak;\n\tcase pll_6553:\n\t\tinit.ops = &samsung_pll6553_clk_ops;\n\t\tbreak;\n\tcase pll_4600:\n\tcase pll_4650:\n\tcase pll_4650c:\n\tcase pll_1460x:\n\t\tif (!pll->rate_table)\n\t\t\tinit.ops = &samsung_pll46xx_clk_min_ops;\n\t\telse\n\t\t\tinit.ops = &samsung_pll46xx_clk_ops;\n\t\tbreak;\n\tcase pll_2550x:\n\t\tinit.ops = &samsung_pll2550x_clk_ops;\n\t\tbreak;\n\tcase pll_2550xx:\n\t\tif (!pll->rate_table)\n\t\t\tinit.ops = &samsung_pll2550xx_clk_min_ops;\n\t\telse\n\t\t\tinit.ops = &samsung_pll2550xx_clk_ops;\n\t\tbreak;\n\tcase pll_2650x:\n\t\tif (!pll->rate_table)\n\t\t\tinit.ops = &samsung_pll2650x_clk_min_ops;\n\t\telse\n\t\t\tinit.ops = &samsung_pll2650x_clk_ops;\n\t\tbreak;\n\tcase pll_2650xx:\n\t\tif (!pll->rate_table)\n\t\t\tinit.ops = &samsung_pll2650xx_clk_min_ops;\n\t\telse\n\t\t\tinit.ops = &samsung_pll2650xx_clk_ops;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Unknown pll type for pll clk %s\\n\",\n\t\t\t__func__, pll_clk->name);\n\t}\n\n\tpll->hw.init = &init;\n\tpll->type = pll_clk->type;\n\tpll->lock_reg = ctx->reg_base + pll_clk->lock_offset;\n\tpll->con_reg = ctx->reg_base + pll_clk->con_offset;\n\n\tret = clk_hw_register(ctx->dev, &pll->hw);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to register pll clock %s : %d\\n\",\n\t\t\t__func__, pll_clk->name, ret);\n\t\tkfree(pll->rate_table);\n\t\tkfree(pll);\n\t\treturn;\n\t}\n\n\tsamsung_clk_add_lookup(ctx, &pll->hw, pll_clk->id);\n}\n\nvoid __init samsung_clk_register_pll(struct samsung_clk_provider *ctx,\n\t\t\tconst struct samsung_pll_clock *pll_list,\n\t\t\tunsigned int nr_pll)\n{\n\tint cnt;\n\n\tfor (cnt = 0; cnt < nr_pll; cnt++)\n\t\t_samsung_clk_register_pll(ctx, &pll_list[cnt]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}