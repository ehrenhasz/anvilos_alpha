{
  "module_name": "clk-exynos-clkout.c",
  "hash_id": "9f86122e4f0db32df1ae3da2ad9e4b8d7fb5660aef4a0b7edea0574c7ddb6ffd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/samsung/clk-exynos-clkout.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n\n#define EXYNOS_CLKOUT_NR_CLKS\t\t1\n#define EXYNOS_CLKOUT_PARENTS\t\t32\n\n#define EXYNOS_PMU_DEBUG_REG\t\t0xa00\n#define EXYNOS_CLKOUT_DISABLE_SHIFT\t0\n#define EXYNOS_CLKOUT_MUX_SHIFT\t\t8\n#define EXYNOS4_CLKOUT_MUX_MASK\t\t0xf\n#define EXYNOS5_CLKOUT_MUX_MASK\t\t0x1f\n\nstruct exynos_clkout {\n\tstruct clk_gate gate;\n\tstruct clk_mux mux;\n\tspinlock_t slock;\n\tvoid __iomem *reg;\n\tstruct device_node *np;\n\tu32 pmu_debug_save;\n\tstruct clk_hw_onecell_data data;\n};\n\nstruct exynos_clkout_variant {\n\tu32 mux_mask;\n};\n\nstatic const struct exynos_clkout_variant exynos_clkout_exynos4 = {\n\t.mux_mask\t= EXYNOS4_CLKOUT_MUX_MASK,\n};\n\nstatic const struct exynos_clkout_variant exynos_clkout_exynos5 = {\n\t.mux_mask\t= EXYNOS5_CLKOUT_MUX_MASK,\n};\n\nstatic const struct of_device_id exynos_clkout_ids[] = {\n\t{\n\t\t.compatible = \"samsung,exynos3250-pmu\",\n\t\t.data = &exynos_clkout_exynos4,\n\t}, {\n\t\t.compatible = \"samsung,exynos4210-pmu\",\n\t\t.data = &exynos_clkout_exynos4,\n\t}, {\n\t\t.compatible = \"samsung,exynos4212-pmu\",\n\t\t.data = &exynos_clkout_exynos4,\n\t}, {\n\t\t.compatible = \"samsung,exynos4412-pmu\",\n\t\t.data = &exynos_clkout_exynos4,\n\t}, {\n\t\t.compatible = \"samsung,exynos5250-pmu\",\n\t\t.data = &exynos_clkout_exynos5,\n\t}, {\n\t\t.compatible = \"samsung,exynos5410-pmu\",\n\t\t.data = &exynos_clkout_exynos5,\n\t}, {\n\t\t.compatible = \"samsung,exynos5420-pmu\",\n\t\t.data = &exynos_clkout_exynos5,\n\t}, {\n\t\t.compatible = \"samsung,exynos5433-pmu\",\n\t\t.data = &exynos_clkout_exynos5,\n\t}, { }\n};\nMODULE_DEVICE_TABLE(of, exynos_clkout_ids);\n\n \nstatic int exynos_clkout_match_parent_dev(struct device *dev, u32 *mux_mask)\n{\n\tconst struct exynos_clkout_variant *variant;\n\tconst struct of_device_id *match;\n\n\tif (!dev->parent) {\n\t\tdev_err(dev, \"not instantiated from MFD\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmatch = of_match_device(exynos_clkout_ids, dev->parent);\n\tif (!match) {\n\t\tdev_err(dev, \"cannot match parent device\\n\");\n\t\treturn -EINVAL;\n\t}\n\tvariant = match->data;\n\n\t*mux_mask = variant->mux_mask;\n\n\treturn 0;\n}\n\nstatic int exynos_clkout_probe(struct platform_device *pdev)\n{\n\tconst char *parent_names[EXYNOS_CLKOUT_PARENTS];\n\tstruct clk *parents[EXYNOS_CLKOUT_PARENTS];\n\tstruct exynos_clkout *clkout;\n\tint parent_count, ret, i;\n\tu32 mux_mask;\n\n\tclkout = devm_kzalloc(&pdev->dev,\n\t\t\t      struct_size(clkout, data.hws, EXYNOS_CLKOUT_NR_CLKS),\n\t\t\t      GFP_KERNEL);\n\tif (!clkout)\n\t\treturn -ENOMEM;\n\n\tret = exynos_clkout_match_parent_dev(&pdev->dev, &mux_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tclkout->np = pdev->dev.of_node;\n\tif (!clkout->np) {\n\t\t \n\t\tclkout->np = pdev->dev.parent->of_node;\n\t}\n\n\tplatform_set_drvdata(pdev, clkout);\n\n\tspin_lock_init(&clkout->slock);\n\n\tparent_count = 0;\n\tfor (i = 0; i < EXYNOS_CLKOUT_PARENTS; ++i) {\n\t\tchar name[] = \"clkoutXX\";\n\n\t\tsnprintf(name, sizeof(name), \"clkout%d\", i);\n\t\tparents[i] = of_clk_get_by_name(clkout->np, name);\n\t\tif (IS_ERR(parents[i])) {\n\t\t\tparent_names[i] = \"none\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tparent_names[i] = __clk_get_name(parents[i]);\n\t\tparent_count = i + 1;\n\t}\n\n\tif (!parent_count)\n\t\treturn -EINVAL;\n\n\tclkout->reg = of_iomap(clkout->np, 0);\n\tif (!clkout->reg) {\n\t\tret = -ENODEV;\n\t\tgoto clks_put;\n\t}\n\n\tclkout->gate.reg = clkout->reg + EXYNOS_PMU_DEBUG_REG;\n\tclkout->gate.bit_idx = EXYNOS_CLKOUT_DISABLE_SHIFT;\n\tclkout->gate.flags = CLK_GATE_SET_TO_DISABLE;\n\tclkout->gate.lock = &clkout->slock;\n\n\tclkout->mux.reg = clkout->reg + EXYNOS_PMU_DEBUG_REG;\n\tclkout->mux.mask = mux_mask;\n\tclkout->mux.shift = EXYNOS_CLKOUT_MUX_SHIFT;\n\tclkout->mux.lock = &clkout->slock;\n\n\tclkout->data.hws[0] = clk_hw_register_composite(NULL, \"clkout\",\n\t\t\t\tparent_names, parent_count, &clkout->mux.hw,\n\t\t\t\t&clk_mux_ops, NULL, NULL, &clkout->gate.hw,\n\t\t\t\t&clk_gate_ops, CLK_SET_RATE_PARENT\n\t\t\t\t| CLK_SET_RATE_NO_REPARENT);\n\tif (IS_ERR(clkout->data.hws[0])) {\n\t\tret = PTR_ERR(clkout->data.hws[0]);\n\t\tgoto err_unmap;\n\t}\n\n\tclkout->data.num = EXYNOS_CLKOUT_NR_CLKS;\n\tret = of_clk_add_hw_provider(clkout->np, of_clk_hw_onecell_get, &clkout->data);\n\tif (ret)\n\t\tgoto err_clk_unreg;\n\n\treturn 0;\n\nerr_clk_unreg:\n\tclk_hw_unregister(clkout->data.hws[0]);\nerr_unmap:\n\tiounmap(clkout->reg);\nclks_put:\n\tfor (i = 0; i < EXYNOS_CLKOUT_PARENTS; ++i)\n\t\tif (!IS_ERR(parents[i]))\n\t\t\tclk_put(parents[i]);\n\n\tdev_err(&pdev->dev, \"failed to register clkout clock\\n\");\n\n\treturn ret;\n}\n\nstatic void exynos_clkout_remove(struct platform_device *pdev)\n{\n\tstruct exynos_clkout *clkout = platform_get_drvdata(pdev);\n\n\tof_clk_del_provider(clkout->np);\n\tclk_hw_unregister(clkout->data.hws[0]);\n\tiounmap(clkout->reg);\n}\n\nstatic int __maybe_unused exynos_clkout_suspend(struct device *dev)\n{\n\tstruct exynos_clkout *clkout = dev_get_drvdata(dev);\n\n\tclkout->pmu_debug_save = readl(clkout->reg + EXYNOS_PMU_DEBUG_REG);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused exynos_clkout_resume(struct device *dev)\n{\n\tstruct exynos_clkout *clkout = dev_get_drvdata(dev);\n\n\twritel(clkout->pmu_debug_save, clkout->reg + EXYNOS_PMU_DEBUG_REG);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(exynos_clkout_pm_ops, exynos_clkout_suspend,\n\t\t\t exynos_clkout_resume);\n\nstatic struct platform_driver exynos_clkout_driver = {\n\t.driver = {\n\t\t.name = \"exynos-clkout\",\n\t\t.of_match_table = exynos_clkout_ids,\n\t\t.pm = &exynos_clkout_pm_ops,\n\t},\n\t.probe = exynos_clkout_probe,\n\t.remove_new = exynos_clkout_remove,\n};\nmodule_platform_driver(exynos_clkout_driver);\n\nMODULE_AUTHOR(\"Krzysztof Kozlowski <krzk@kernel.org>\");\nMODULE_AUTHOR(\"Tomasz Figa <tomasz.figa@gmail.com>\");\nMODULE_DESCRIPTION(\"Samsung Exynos clock output driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}