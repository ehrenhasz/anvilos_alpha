{
  "module_name": "clk-exynos-arm64.c",
  "hash_id": "70d118682a171b1f09d79cbc959822d9d313b2d051cbaba59d4b2638ce733008",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/samsung/clk-exynos-arm64.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include \"clk-exynos-arm64.h\"\n\n \n#define GATE_MANUAL\t\tBIT(20)\n#define GATE_ENABLE_HWACG\tBIT(28)\n\n \n#define GATE_OFF_START\t\t0x2000\n#define GATE_OFF_END\t\t0x2fff\n\nstruct exynos_arm64_cmu_data {\n\tstruct samsung_clk_reg_dump *clk_save;\n\tunsigned int nr_clk_save;\n\tconst struct samsung_clk_reg_dump *clk_suspend;\n\tunsigned int nr_clk_suspend;\n\n\tstruct clk *clk;\n\tstruct clk **pclks;\n\tint nr_pclks;\n\n\tstruct samsung_clk_provider *ctx;\n};\n\n \nstatic void __init exynos_arm64_init_clocks(struct device_node *np,\n\t\tconst unsigned long *reg_offs, size_t reg_offs_len)\n{\n\tvoid __iomem *reg_base;\n\tsize_t i;\n\n\treg_base = of_iomap(np, 0);\n\tif (!reg_base)\n\t\tpanic(\"%s: failed to map registers\\n\", __func__);\n\n\tfor (i = 0; i < reg_offs_len; ++i) {\n\t\tvoid __iomem *reg = reg_base + reg_offs[i];\n\t\tu32 val;\n\n\t\t \n\t\tif (reg_offs[i] < GATE_OFF_START || reg_offs[i] > GATE_OFF_END)\n\t\t\tcontinue;\n\n\t\tval = readl(reg);\n\t\tval |= GATE_MANUAL;\n\t\tval &= ~GATE_ENABLE_HWACG;\n\t\twritel(val, reg);\n\t}\n\n\tiounmap(reg_base);\n}\n\n \nstatic int __init exynos_arm64_enable_bus_clk(struct device *dev,\n\t\tstruct device_node *np, const struct samsung_cmu_info *cmu)\n{\n\tstruct clk *parent_clk;\n\n\tif (!cmu->clk_name)\n\t\treturn 0;\n\n\tif (dev) {\n\t\tstruct exynos_arm64_cmu_data *data;\n\n\t\tparent_clk = clk_get(dev, cmu->clk_name);\n\t\tdata = dev_get_drvdata(dev);\n\t\tif (data)\n\t\t\tdata->clk = parent_clk;\n\t} else {\n\t\tparent_clk = of_clk_get_by_name(np, cmu->clk_name);\n\t}\n\n\tif (IS_ERR(parent_clk))\n\t\treturn PTR_ERR(parent_clk);\n\n\treturn clk_prepare_enable(parent_clk);\n}\n\nstatic int __init exynos_arm64_cmu_prepare_pm(struct device *dev,\n\t\tconst struct samsung_cmu_info *cmu)\n{\n\tstruct exynos_arm64_cmu_data *data = dev_get_drvdata(dev);\n\tint i;\n\n\tdata->clk_save = samsung_clk_alloc_reg_dump(cmu->clk_regs,\n\t\t\t\t\t\t    cmu->nr_clk_regs);\n\tif (!data->clk_save)\n\t\treturn -ENOMEM;\n\n\tdata->nr_clk_save = cmu->nr_clk_regs;\n\tdata->clk_suspend = cmu->suspend_regs;\n\tdata->nr_clk_suspend = cmu->nr_suspend_regs;\n\tdata->nr_pclks = of_clk_get_parent_count(dev->of_node);\n\tif (!data->nr_pclks)\n\t\treturn 0;\n\n\tdata->pclks = devm_kcalloc(dev, sizeof(struct clk *), data->nr_pclks,\n\t\t\t\t   GFP_KERNEL);\n\tif (!data->pclks) {\n\t\tkfree(data->clk_save);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < data->nr_pclks; i++) {\n\t\tstruct clk *clk = of_clk_get(dev->of_node, i);\n\n\t\tif (IS_ERR(clk)) {\n\t\t\tkfree(data->clk_save);\n\t\t\twhile (--i >= 0)\n\t\t\t\tclk_put(data->pclks[i]);\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\t\tdata->pclks[i] = clk;\n\t}\n\n\treturn 0;\n}\n\n \nvoid __init exynos_arm64_register_cmu(struct device *dev,\n\t\tstruct device_node *np, const struct samsung_cmu_info *cmu)\n{\n\tint err;\n\n\t \n\terr = exynos_arm64_enable_bus_clk(dev, np, cmu);\n\tif (err)\n\t\tpr_err(\"%s: could not enable bus clock %s; err = %d\\n\",\n\t\t       __func__, cmu->clk_name, err);\n\n\texynos_arm64_init_clocks(np, cmu->clk_regs, cmu->nr_clk_regs);\n\tsamsung_cmu_register_one(np, cmu);\n}\n\n \nint __init exynos_arm64_register_cmu_pm(struct platform_device *pdev,\n\t\t\t\t\tbool set_manual)\n{\n\tconst struct samsung_cmu_info *cmu;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct exynos_arm64_cmu_data *data;\n\tvoid __iomem *reg_base;\n\tint ret;\n\n\tcmu = of_device_get_match_data(dev);\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, data);\n\n\tret = exynos_arm64_cmu_prepare_pm(dev, cmu);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = exynos_arm64_enable_bus_clk(dev, NULL, cmu);\n\tif (ret)\n\t\tdev_err(dev, \"%s: could not enable bus clock %s; err = %d\\n\",\n\t\t       __func__, cmu->clk_name, ret);\n\n\tif (set_manual)\n\t\texynos_arm64_init_clocks(np, cmu->clk_regs, cmu->nr_clk_regs);\n\n\treg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(reg_base))\n\t\treturn PTR_ERR(reg_base);\n\n\tdata->ctx = samsung_clk_init(dev, reg_base, cmu->nr_clk_ids);\n\n\t \n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\tsamsung_cmu_register_clocks(data->ctx, cmu);\n\tsamsung_clk_of_add_provider(dev->of_node, data->ctx);\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nint exynos_arm64_cmu_suspend(struct device *dev)\n{\n\tstruct exynos_arm64_cmu_data *data = dev_get_drvdata(dev);\n\tint i;\n\n\tsamsung_clk_save(data->ctx->reg_base, data->clk_save,\n\t\t\t data->nr_clk_save);\n\n\tfor (i = 0; i < data->nr_pclks; i++)\n\t\tclk_prepare_enable(data->pclks[i]);\n\n\t \n\tsamsung_clk_restore(data->ctx->reg_base, data->clk_suspend,\n\t\t\t    data->nr_clk_suspend);\n\n\tfor (i = 0; i < data->nr_pclks; i++)\n\t\tclk_disable_unprepare(data->pclks[i]);\n\n\tclk_disable_unprepare(data->clk);\n\n\treturn 0;\n}\n\nint exynos_arm64_cmu_resume(struct device *dev)\n{\n\tstruct exynos_arm64_cmu_data *data = dev_get_drvdata(dev);\n\tint i;\n\n\tclk_prepare_enable(data->clk);\n\n\tfor (i = 0; i < data->nr_pclks; i++)\n\t\tclk_prepare_enable(data->pclks[i]);\n\n\tsamsung_clk_restore(data->ctx->reg_base, data->clk_save,\n\t\t\t    data->nr_clk_save);\n\n\tfor (i = 0; i < data->nr_pclks; i++)\n\t\tclk_disable_unprepare(data->pclks[i]);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}