{
  "module_name": "clk.c",
  "hash_id": "2a84cd5834de6c00f590176a8fd5c7586e7d75cae4f0a73a7dc1b1219a594d5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/samsung/clk.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/clkdev.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/syscore_ops.h>\n\n#include \"clk.h\"\n\nstatic LIST_HEAD(clock_reg_cache_list);\n\nvoid samsung_clk_save(void __iomem *base,\n\t\t\t\t    struct samsung_clk_reg_dump *rd,\n\t\t\t\t    unsigned int num_regs)\n{\n\tfor (; num_regs > 0; --num_regs, ++rd)\n\t\trd->value = readl(base + rd->offset);\n}\n\nvoid samsung_clk_restore(void __iomem *base,\n\t\t\t\t      const struct samsung_clk_reg_dump *rd,\n\t\t\t\t      unsigned int num_regs)\n{\n\tfor (; num_regs > 0; --num_regs, ++rd)\n\t\twritel(rd->value, base + rd->offset);\n}\n\nstruct samsung_clk_reg_dump *samsung_clk_alloc_reg_dump(\n\t\t\t\t\t\tconst unsigned long *rdump,\n\t\t\t\t\t\tunsigned long nr_rdump)\n{\n\tstruct samsung_clk_reg_dump *rd;\n\tunsigned int i;\n\n\trd = kcalloc(nr_rdump, sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn NULL;\n\n\tfor (i = 0; i < nr_rdump; ++i)\n\t\trd[i].offset = rdump[i];\n\n\treturn rd;\n}\n\n \nstruct samsung_clk_provider * __init samsung_clk_init(struct device *dev,\n\t\t\tvoid __iomem *base, unsigned long nr_clks)\n{\n\tstruct samsung_clk_provider *ctx;\n\tint i;\n\n\tctx = kzalloc(struct_size(ctx, clk_data.hws, nr_clks), GFP_KERNEL);\n\tif (!ctx)\n\t\tpanic(\"could not allocate clock provider context.\\n\");\n\n\tfor (i = 0; i < nr_clks; ++i)\n\t\tctx->clk_data.hws[i] = ERR_PTR(-ENOENT);\n\n\tctx->dev = dev;\n\tctx->reg_base = base;\n\tctx->clk_data.num = nr_clks;\n\tspin_lock_init(&ctx->lock);\n\n\treturn ctx;\n}\n\nvoid __init samsung_clk_of_add_provider(struct device_node *np,\n\t\t\t\tstruct samsung_clk_provider *ctx)\n{\n\tif (np) {\n\t\tif (of_clk_add_hw_provider(np, of_clk_hw_onecell_get,\n\t\t\t\t\t&ctx->clk_data))\n\t\t\tpanic(\"could not register clk provider\\n\");\n\t}\n}\n\n \nvoid samsung_clk_add_lookup(struct samsung_clk_provider *ctx,\n\t\t\t    struct clk_hw *clk_hw, unsigned int id)\n{\n\tif (id)\n\t\tctx->clk_data.hws[id] = clk_hw;\n}\n\n \nvoid __init samsung_clk_register_alias(struct samsung_clk_provider *ctx,\n\t\t\t\tconst struct samsung_clock_alias *list,\n\t\t\t\tunsigned int nr_clk)\n{\n\tstruct clk_hw *clk_hw;\n\tunsigned int idx, ret;\n\n\tfor (idx = 0; idx < nr_clk; idx++, list++) {\n\t\tif (!list->id) {\n\t\t\tpr_err(\"%s: clock id missing for index %d\\n\", __func__,\n\t\t\t\tidx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tclk_hw = ctx->clk_data.hws[list->id];\n\t\tif (!clk_hw) {\n\t\t\tpr_err(\"%s: failed to find clock %d\\n\", __func__,\n\t\t\t\tlist->id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = clk_hw_register_clkdev(clk_hw, list->alias,\n\t\t\t\t\t     list->dev_name);\n\t\tif (ret)\n\t\t\tpr_err(\"%s: failed to register lookup %s\\n\",\n\t\t\t\t\t__func__, list->alias);\n\t}\n}\n\n \nvoid __init samsung_clk_register_fixed_rate(struct samsung_clk_provider *ctx,\n\t\tconst struct samsung_fixed_rate_clock *list,\n\t\tunsigned int nr_clk)\n{\n\tstruct clk_hw *clk_hw;\n\tunsigned int idx, ret;\n\n\tfor (idx = 0; idx < nr_clk; idx++, list++) {\n\t\tclk_hw = clk_hw_register_fixed_rate(ctx->dev, list->name,\n\t\t\tlist->parent_name, list->flags, list->fixed_rate);\n\t\tif (IS_ERR(clk_hw)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\", __func__,\n\t\t\t\tlist->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsamsung_clk_add_lookup(ctx, clk_hw, list->id);\n\n\t\t \n\t\tret = clk_hw_register_clkdev(clk_hw, list->name, NULL);\n\t\tif (ret)\n\t\t\tpr_err(\"%s: failed to register clock lookup for %s\",\n\t\t\t\t__func__, list->name);\n\t}\n}\n\n \nvoid __init samsung_clk_register_fixed_factor(struct samsung_clk_provider *ctx,\n\t\tconst struct samsung_fixed_factor_clock *list, unsigned int nr_clk)\n{\n\tstruct clk_hw *clk_hw;\n\tunsigned int idx;\n\n\tfor (idx = 0; idx < nr_clk; idx++, list++) {\n\t\tclk_hw = clk_hw_register_fixed_factor(ctx->dev, list->name,\n\t\t\tlist->parent_name, list->flags, list->mult, list->div);\n\t\tif (IS_ERR(clk_hw)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\", __func__,\n\t\t\t\tlist->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsamsung_clk_add_lookup(ctx, clk_hw, list->id);\n\t}\n}\n\n \nvoid __init samsung_clk_register_mux(struct samsung_clk_provider *ctx,\n\t\t\t\tconst struct samsung_mux_clock *list,\n\t\t\t\tunsigned int nr_clk)\n{\n\tstruct clk_hw *clk_hw;\n\tunsigned int idx;\n\n\tfor (idx = 0; idx < nr_clk; idx++, list++) {\n\t\tclk_hw = clk_hw_register_mux(ctx->dev, list->name,\n\t\t\tlist->parent_names, list->num_parents, list->flags,\n\t\t\tctx->reg_base + list->offset,\n\t\t\tlist->shift, list->width, list->mux_flags, &ctx->lock);\n\t\tif (IS_ERR(clk_hw)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\", __func__,\n\t\t\t\tlist->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsamsung_clk_add_lookup(ctx, clk_hw, list->id);\n\t}\n}\n\n \nvoid __init samsung_clk_register_div(struct samsung_clk_provider *ctx,\n\t\t\t\tconst struct samsung_div_clock *list,\n\t\t\t\tunsigned int nr_clk)\n{\n\tstruct clk_hw *clk_hw;\n\tunsigned int idx;\n\n\tfor (idx = 0; idx < nr_clk; idx++, list++) {\n\t\tif (list->table)\n\t\t\tclk_hw = clk_hw_register_divider_table(ctx->dev,\n\t\t\t\tlist->name, list->parent_name, list->flags,\n\t\t\t\tctx->reg_base + list->offset,\n\t\t\t\tlist->shift, list->width, list->div_flags,\n\t\t\t\tlist->table, &ctx->lock);\n\t\telse\n\t\t\tclk_hw = clk_hw_register_divider(ctx->dev, list->name,\n\t\t\t\tlist->parent_name, list->flags,\n\t\t\t\tctx->reg_base + list->offset, list->shift,\n\t\t\t\tlist->width, list->div_flags, &ctx->lock);\n\t\tif (IS_ERR(clk_hw)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\", __func__,\n\t\t\t\tlist->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsamsung_clk_add_lookup(ctx, clk_hw, list->id);\n\t}\n}\n\n \nvoid __init samsung_clk_register_gate(struct samsung_clk_provider *ctx,\n\t\t\t\tconst struct samsung_gate_clock *list,\n\t\t\t\tunsigned int nr_clk)\n{\n\tstruct clk_hw *clk_hw;\n\tunsigned int idx;\n\n\tfor (idx = 0; idx < nr_clk; idx++, list++) {\n\t\tclk_hw = clk_hw_register_gate(ctx->dev, list->name, list->parent_name,\n\t\t\t\tlist->flags, ctx->reg_base + list->offset,\n\t\t\t\tlist->bit_idx, list->gate_flags, &ctx->lock);\n\t\tif (IS_ERR(clk_hw)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\", __func__,\n\t\t\t\tlist->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsamsung_clk_add_lookup(ctx, clk_hw, list->id);\n\t}\n}\n\n \nvoid __init samsung_clk_of_register_fixed_ext(struct samsung_clk_provider *ctx,\n\t\t\tstruct samsung_fixed_rate_clock *fixed_rate_clk,\n\t\t\tunsigned int nr_fixed_rate_clk,\n\t\t\tconst struct of_device_id *clk_matches)\n{\n\tconst struct of_device_id *match;\n\tstruct device_node *clk_np;\n\tu32 freq;\n\n\tfor_each_matching_node_and_match(clk_np, clk_matches, &match) {\n\t\tif (of_property_read_u32(clk_np, \"clock-frequency\", &freq))\n\t\t\tcontinue;\n\t\tfixed_rate_clk[(unsigned long)match->data].fixed_rate = freq;\n\t}\n\tsamsung_clk_register_fixed_rate(ctx, fixed_rate_clk, nr_fixed_rate_clk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int samsung_clk_suspend(void)\n{\n\tstruct samsung_clock_reg_cache *reg_cache;\n\n\tlist_for_each_entry(reg_cache, &clock_reg_cache_list, node) {\n\t\tsamsung_clk_save(reg_cache->reg_base, reg_cache->rdump,\n\t\t\t\treg_cache->rd_num);\n\t\tsamsung_clk_restore(reg_cache->reg_base, reg_cache->rsuspend,\n\t\t\t\treg_cache->rsuspend_num);\n\t}\n\treturn 0;\n}\n\nstatic void samsung_clk_resume(void)\n{\n\tstruct samsung_clock_reg_cache *reg_cache;\n\n\tlist_for_each_entry(reg_cache, &clock_reg_cache_list, node)\n\t\tsamsung_clk_restore(reg_cache->reg_base, reg_cache->rdump,\n\t\t\t\treg_cache->rd_num);\n}\n\nstatic struct syscore_ops samsung_clk_syscore_ops = {\n\t.suspend = samsung_clk_suspend,\n\t.resume = samsung_clk_resume,\n};\n\nvoid samsung_clk_extended_sleep_init(void __iomem *reg_base,\n\t\t\tconst unsigned long *rdump,\n\t\t\tunsigned long nr_rdump,\n\t\t\tconst struct samsung_clk_reg_dump *rsuspend,\n\t\t\tunsigned long nr_rsuspend)\n{\n\tstruct samsung_clock_reg_cache *reg_cache;\n\n\treg_cache = kzalloc(sizeof(struct samsung_clock_reg_cache),\n\t\t\tGFP_KERNEL);\n\tif (!reg_cache)\n\t\tpanic(\"could not allocate register reg_cache.\\n\");\n\treg_cache->rdump = samsung_clk_alloc_reg_dump(rdump, nr_rdump);\n\n\tif (!reg_cache->rdump)\n\t\tpanic(\"could not allocate register dump storage.\\n\");\n\n\tif (list_empty(&clock_reg_cache_list))\n\t\tregister_syscore_ops(&samsung_clk_syscore_ops);\n\n\treg_cache->reg_base = reg_base;\n\treg_cache->rd_num = nr_rdump;\n\treg_cache->rsuspend = rsuspend;\n\treg_cache->rsuspend_num = nr_rsuspend;\n\tlist_add_tail(&reg_cache->node, &clock_reg_cache_list);\n}\n#endif\n\n \nvoid __init samsung_cmu_register_clocks(struct samsung_clk_provider *ctx,\n\t\t\t\t\tconst struct samsung_cmu_info *cmu)\n{\n\tif (cmu->pll_clks)\n\t\tsamsung_clk_register_pll(ctx, cmu->pll_clks, cmu->nr_pll_clks);\n\tif (cmu->mux_clks)\n\t\tsamsung_clk_register_mux(ctx, cmu->mux_clks, cmu->nr_mux_clks);\n\tif (cmu->div_clks)\n\t\tsamsung_clk_register_div(ctx, cmu->div_clks, cmu->nr_div_clks);\n\tif (cmu->gate_clks)\n\t\tsamsung_clk_register_gate(ctx, cmu->gate_clks,\n\t\t\t\t\t  cmu->nr_gate_clks);\n\tif (cmu->fixed_clks)\n\t\tsamsung_clk_register_fixed_rate(ctx, cmu->fixed_clks,\n\t\t\t\t\t\tcmu->nr_fixed_clks);\n\tif (cmu->fixed_factor_clks)\n\t\tsamsung_clk_register_fixed_factor(ctx, cmu->fixed_factor_clks,\n\t\t\t\t\t\t  cmu->nr_fixed_factor_clks);\n\tif (cmu->cpu_clks)\n\t\tsamsung_clk_register_cpu(ctx, cmu->cpu_clks, cmu->nr_cpu_clks);\n}\n\n \nstruct samsung_clk_provider * __init samsung_cmu_register_one(\n\t\t\tstruct device_node *np,\n\t\t\tconst struct samsung_cmu_info *cmu)\n{\n\tvoid __iomem *reg_base;\n\tstruct samsung_clk_provider *ctx;\n\n\treg_base = of_iomap(np, 0);\n\tif (!reg_base) {\n\t\tpanic(\"%s: failed to map registers\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tctx = samsung_clk_init(NULL, reg_base, cmu->nr_clk_ids);\n\tsamsung_cmu_register_clocks(ctx, cmu);\n\n\tif (cmu->clk_regs)\n\t\tsamsung_clk_extended_sleep_init(reg_base,\n\t\t\tcmu->clk_regs, cmu->nr_clk_regs,\n\t\t\tcmu->suspend_regs, cmu->nr_suspend_regs);\n\n\tsamsung_clk_of_add_provider(np, ctx);\n\n\treturn ctx;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}