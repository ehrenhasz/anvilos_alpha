{
  "module_name": "clk-exynos5-subcmu.c",
  "hash_id": "3b8a43a06f73856e5fec4678d1e5d8ecafc895c8222bec721a0fa89df624925d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/samsung/clk-exynos5-subcmu.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n\n#include \"clk.h\"\n#include \"clk-exynos5-subcmu.h\"\n\nstatic struct samsung_clk_provider *ctx;\nstatic const struct exynos5_subcmu_info **cmu;\nstatic int nr_cmus;\n\nstatic void exynos5_subcmu_clk_save(void __iomem *base,\n\t\t\t\t    struct exynos5_subcmu_reg_dump *rd,\n\t\t\t\t    unsigned int num_regs)\n{\n\tfor (; num_regs > 0; --num_regs, ++rd) {\n\t\trd->save = readl(base + rd->offset);\n\t\twritel((rd->save & ~rd->mask) | rd->value, base + rd->offset);\n\t\trd->save &= rd->mask;\n\t}\n};\n\nstatic void exynos5_subcmu_clk_restore(void __iomem *base,\n\t\t\t\t       struct exynos5_subcmu_reg_dump *rd,\n\t\t\t\t       unsigned int num_regs)\n{\n\tfor (; num_regs > 0; --num_regs, ++rd)\n\t\twritel((readl(base + rd->offset) & ~rd->mask) | rd->save,\n\t\t       base + rd->offset);\n}\n\nstatic void exynos5_subcmu_defer_gate(struct samsung_clk_provider *ctx,\n\t\t\t      const struct samsung_gate_clock *list, int nr_clk)\n{\n\twhile (nr_clk--)\n\t\tsamsung_clk_add_lookup(ctx, ERR_PTR(-EPROBE_DEFER), list++->id);\n}\n\n \nvoid exynos5_subcmus_init(struct samsung_clk_provider *_ctx, int _nr_cmus,\n\t\t\t  const struct exynos5_subcmu_info **_cmu)\n{\n\tctx = _ctx;\n\tcmu = _cmu;\n\tnr_cmus = _nr_cmus;\n\n\tfor (; _nr_cmus--; _cmu++) {\n\t\texynos5_subcmu_defer_gate(ctx, (*_cmu)->gate_clks,\n\t\t\t\t\t  (*_cmu)->nr_gate_clks);\n\t\texynos5_subcmu_clk_save(ctx->reg_base, (*_cmu)->suspend_regs,\n\t\t\t\t\t(*_cmu)->nr_suspend_regs);\n\t}\n}\n\nstatic int __maybe_unused exynos5_subcmu_suspend(struct device *dev)\n{\n\tstruct exynos5_subcmu_info *info = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->lock, flags);\n\texynos5_subcmu_clk_save(ctx->reg_base, info->suspend_regs,\n\t\t\t\tinfo->nr_suspend_regs);\n\tspin_unlock_irqrestore(&ctx->lock, flags);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused exynos5_subcmu_resume(struct device *dev)\n{\n\tstruct exynos5_subcmu_info *info = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->lock, flags);\n\texynos5_subcmu_clk_restore(ctx->reg_base, info->suspend_regs,\n\t\t\t\t   info->nr_suspend_regs);\n\tspin_unlock_irqrestore(&ctx->lock, flags);\n\n\treturn 0;\n}\n\nstatic int __init exynos5_subcmu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct exynos5_subcmu_info *info = dev_get_drvdata(dev);\n\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_get(dev);\n\n\tctx->dev = dev;\n\tsamsung_clk_register_div(ctx, info->div_clks, info->nr_div_clks);\n\tsamsung_clk_register_gate(ctx, info->gate_clks, info->nr_gate_clks);\n\tctx->dev = NULL;\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops exynos5_subcmu_pm_ops = {\n\tSET_RUNTIME_PM_OPS(exynos5_subcmu_suspend,\n\t\t\t   exynos5_subcmu_resume, NULL)\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t     pm_runtime_force_resume)\n};\n\nstatic struct platform_driver exynos5_subcmu_driver __refdata = {\n\t.driver\t= {\n\t\t.name = \"exynos5-subcmu\",\n\t\t.suppress_bind_attrs = true,\n\t\t.pm = &exynos5_subcmu_pm_ops,\n\t},\n\t.probe = exynos5_subcmu_probe,\n};\n\nstatic int __init exynos5_clk_register_subcmu(struct device *parent,\n\t\t\t\t\t const struct exynos5_subcmu_info *info,\n\t\t\t\t\t      struct device_node *pd_node)\n{\n\tstruct of_phandle_args genpdspec = { .np = pd_node };\n\tstruct platform_device *pdev;\n\tint ret;\n\n\tpdev = platform_device_alloc(\"exynos5-subcmu\", PLATFORM_DEVID_AUTO);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\n\tpdev->dev.parent = parent;\n\tplatform_set_drvdata(pdev, (void *)info);\n\tof_genpd_add_device(&genpdspec, &pdev->dev);\n\tret = platform_device_add(pdev);\n\tif (ret)\n\t\tplatform_device_put(pdev);\n\n\treturn ret;\n}\n\nstatic int __init exynos5_clk_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np;\n\tconst char *name;\n\tint i;\n\n\tfor_each_compatible_node(np, NULL, \"samsung,exynos4210-pd\") {\n\t\tif (of_property_read_string(np, \"label\", &name) < 0)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < nr_cmus; i++)\n\t\t\tif (strcmp(cmu[i]->pd_name, name) == 0)\n\t\t\t\texynos5_clk_register_subcmu(&pdev->dev,\n\t\t\t\t\t\t\t    cmu[i], np);\n\t}\n\treturn 0;\n}\n\nstatic const struct of_device_id exynos5_clk_of_match[] = {\n\t{ .compatible = \"samsung,exynos5250-clock\", },\n\t{ .compatible = \"samsung,exynos5420-clock\", },\n\t{ .compatible = \"samsung,exynos5800-clock\", },\n\t{ },\n};\n\nstatic struct platform_driver exynos5_clk_driver __refdata = {\n\t.driver\t= {\n\t\t.name = \"exynos5-clock\",\n\t\t.of_match_table = exynos5_clk_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = exynos5_clk_probe,\n};\n\nstatic int __init exynos5_clk_drv_init(void)\n{\n\tplatform_driver_register(&exynos5_clk_driver);\n\tplatform_driver_register(&exynos5_subcmu_driver);\n\treturn 0;\n}\ncore_initcall(exynos5_clk_drv_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}