{
  "module_name": "clk-exynos-audss.c",
  "hash_id": "1d7dc67d4b7c93b89c800bdb11d3517572d0b673aebf414a6b78f62b29f2d53a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/samsung/clk-exynos-audss.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <dt-bindings/clock/exynos-audss-clk.h>\n\nstatic DEFINE_SPINLOCK(lock);\nstatic void __iomem *reg_base;\nstatic struct clk_hw_onecell_data *clk_data;\n \nstatic struct clk *epll;\n\n#define ASS_CLK_SRC 0x0\n#define ASS_CLK_DIV 0x4\n#define ASS_CLK_GATE 0x8\n\nstatic unsigned long reg_save[][2] = {\n\t{ ASS_CLK_SRC,  0 },\n\t{ ASS_CLK_DIV,  0 },\n\t{ ASS_CLK_GATE, 0 },\n};\n\nstatic int __maybe_unused exynos_audss_clk_suspend(struct device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_save); i++)\n\t\treg_save[i][1] = readl(reg_base + reg_save[i][0]);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused exynos_audss_clk_resume(struct device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_save); i++)\n\t\twritel(reg_save[i][1], reg_base + reg_save[i][0]);\n\n\treturn 0;\n}\n\nstruct exynos_audss_clk_drvdata {\n\tunsigned int has_adma_clk:1;\n\tunsigned int has_mst_clk:1;\n\tunsigned int enable_epll:1;\n\tunsigned int num_clks;\n};\n\nstatic const struct exynos_audss_clk_drvdata exynos4210_drvdata = {\n\t.num_clks\t= EXYNOS_AUDSS_MAX_CLKS - 1,\n\t.enable_epll\t= 1,\n};\n\nstatic const struct exynos_audss_clk_drvdata exynos5410_drvdata = {\n\t.num_clks\t= EXYNOS_AUDSS_MAX_CLKS - 1,\n\t.has_mst_clk\t= 1,\n};\n\nstatic const struct exynos_audss_clk_drvdata exynos5420_drvdata = {\n\t.num_clks\t= EXYNOS_AUDSS_MAX_CLKS,\n\t.has_adma_clk\t= 1,\n\t.enable_epll\t= 1,\n};\n\nstatic const struct of_device_id exynos_audss_clk_of_match[] = {\n\t{\n\t\t.compatible\t= \"samsung,exynos4210-audss-clock\",\n\t\t.data\t\t= &exynos4210_drvdata,\n\t}, {\n\t\t.compatible\t= \"samsung,exynos5250-audss-clock\",\n\t\t.data\t\t= &exynos4210_drvdata,\n\t}, {\n\t\t.compatible\t= \"samsung,exynos5410-audss-clock\",\n\t\t.data\t\t= &exynos5410_drvdata,\n\t}, {\n\t\t.compatible\t= \"samsung,exynos5420-audss-clock\",\n\t\t.data\t\t= &exynos5420_drvdata,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, exynos_audss_clk_of_match);\n\nstatic void exynos_audss_clk_teardown(void)\n{\n\tint i;\n\n\tfor (i = EXYNOS_MOUT_AUDSS; i < EXYNOS_DOUT_SRP; i++) {\n\t\tif (!IS_ERR(clk_data->hws[i]))\n\t\t\tclk_hw_unregister_mux(clk_data->hws[i]);\n\t}\n\n\tfor (; i < EXYNOS_SRP_CLK; i++) {\n\t\tif (!IS_ERR(clk_data->hws[i]))\n\t\t\tclk_hw_unregister_divider(clk_data->hws[i]);\n\t}\n\n\tfor (; i < clk_data->num; i++) {\n\t\tif (!IS_ERR(clk_data->hws[i]))\n\t\t\tclk_hw_unregister_gate(clk_data->hws[i]);\n\t}\n}\n\n \nstatic int exynos_audss_clk_probe(struct platform_device *pdev)\n{\n\tconst char *mout_audss_p[] = {\"fin_pll\", \"fout_epll\"};\n\tconst char *mout_i2s_p[] = {\"mout_audss\", \"cdclk0\", \"sclk_audio0\"};\n\tconst char *sclk_pcm_p = \"sclk_pcm0\";\n\tstruct clk *pll_ref, *pll_in, *cdclk, *sclk_audio, *sclk_pcm_in;\n\tconst struct exynos_audss_clk_drvdata *variant;\n\tstruct clk_hw **clk_table;\n\tstruct device *dev = &pdev->dev;\n\tint i, ret = 0;\n\n\tvariant = of_device_get_match_data(&pdev->dev);\n\tif (!variant)\n\t\treturn -EINVAL;\n\n\treg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(reg_base))\n\t\treturn PTR_ERR(reg_base);\n\n\tepll = ERR_PTR(-ENODEV);\n\n\tclk_data = devm_kzalloc(dev,\n\t\t\t\tstruct_size(clk_data, hws,\n\t\t\t\t\t    EXYNOS_AUDSS_MAX_CLKS),\n\t\t\t\tGFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tclk_data->num = variant->num_clks;\n\tclk_table = clk_data->hws;\n\n\tpll_ref = devm_clk_get(dev, \"pll_ref\");\n\tpll_in = devm_clk_get(dev, \"pll_in\");\n\tif (!IS_ERR(pll_ref))\n\t\tmout_audss_p[0] = __clk_get_name(pll_ref);\n\tif (!IS_ERR(pll_in)) {\n\t\tmout_audss_p[1] = __clk_get_name(pll_in);\n\n\t\tif (variant->enable_epll) {\n\t\t\tepll = pll_in;\n\n\t\t\tret = clk_prepare_enable(epll);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"failed to prepare the epll clock\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\tclk_table[EXYNOS_MOUT_AUDSS] = clk_hw_register_mux(dev, \"mout_audss\",\n\t\t\t\tmout_audss_p, ARRAY_SIZE(mout_audss_p),\n\t\t\t\tCLK_SET_RATE_NO_REPARENT | CLK_SET_RATE_PARENT,\n\t\t\t\treg_base + ASS_CLK_SRC, 0, 1, 0, &lock);\n\n\tcdclk = devm_clk_get(dev, \"cdclk\");\n\tsclk_audio = devm_clk_get(dev, \"sclk_audio\");\n\tif (!IS_ERR(cdclk))\n\t\tmout_i2s_p[1] = __clk_get_name(cdclk);\n\tif (!IS_ERR(sclk_audio))\n\t\tmout_i2s_p[2] = __clk_get_name(sclk_audio);\n\tclk_table[EXYNOS_MOUT_I2S] = clk_hw_register_mux(dev, \"mout_i2s\",\n\t\t\t\tmout_i2s_p, ARRAY_SIZE(mout_i2s_p),\n\t\t\t\tCLK_SET_RATE_NO_REPARENT,\n\t\t\t\treg_base + ASS_CLK_SRC, 2, 2, 0, &lock);\n\n\tclk_table[EXYNOS_DOUT_SRP] = clk_hw_register_divider(dev, \"dout_srp\",\n\t\t\t\t\"mout_audss\", CLK_SET_RATE_PARENT,\n\t\t\t\treg_base + ASS_CLK_DIV, 0, 4, 0, &lock);\n\n\tclk_table[EXYNOS_DOUT_AUD_BUS] = clk_hw_register_divider(dev,\n\t\t\t\t\"dout_aud_bus\", \"dout_srp\", CLK_SET_RATE_PARENT,\n\t\t\t\treg_base + ASS_CLK_DIV, 4, 4, 0, &lock);\n\n\tclk_table[EXYNOS_DOUT_I2S] = clk_hw_register_divider(dev, \"dout_i2s\",\n\t\t\t\t\"mout_i2s\", 0, reg_base + ASS_CLK_DIV, 8, 4, 0,\n\t\t\t\t&lock);\n\n\tclk_table[EXYNOS_SRP_CLK] = clk_hw_register_gate(dev, \"srp_clk\",\n\t\t\t\t\"dout_srp\", CLK_SET_RATE_PARENT,\n\t\t\t\treg_base + ASS_CLK_GATE, 0, 0, &lock);\n\n\tclk_table[EXYNOS_I2S_BUS] = clk_hw_register_gate(dev, \"i2s_bus\",\n\t\t\t\t\"dout_aud_bus\", CLK_SET_RATE_PARENT,\n\t\t\t\treg_base + ASS_CLK_GATE, 2, 0, &lock);\n\n\tclk_table[EXYNOS_SCLK_I2S] = clk_hw_register_gate(dev, \"sclk_i2s\",\n\t\t\t\t\"dout_i2s\", CLK_SET_RATE_PARENT,\n\t\t\t\treg_base + ASS_CLK_GATE, 3, 0, &lock);\n\n\tclk_table[EXYNOS_PCM_BUS] = clk_hw_register_gate(dev, \"pcm_bus\",\n\t\t\t\t \"sclk_pcm\", CLK_SET_RATE_PARENT,\n\t\t\t\treg_base + ASS_CLK_GATE, 4, 0, &lock);\n\n\tsclk_pcm_in = devm_clk_get(dev, \"sclk_pcm_in\");\n\tif (!IS_ERR(sclk_pcm_in))\n\t\tsclk_pcm_p = __clk_get_name(sclk_pcm_in);\n\tclk_table[EXYNOS_SCLK_PCM] = clk_hw_register_gate(dev, \"sclk_pcm\",\n\t\t\t\tsclk_pcm_p, CLK_SET_RATE_PARENT,\n\t\t\t\treg_base + ASS_CLK_GATE, 5, 0, &lock);\n\n\tif (variant->has_adma_clk) {\n\t\tclk_table[EXYNOS_ADMA] = clk_hw_register_gate(dev, \"adma\",\n\t\t\t\t\"dout_srp\", CLK_SET_RATE_PARENT,\n\t\t\t\treg_base + ASS_CLK_GATE, 9, 0, &lock);\n\t}\n\n\tfor (i = 0; i < clk_data->num; i++) {\n\t\tif (IS_ERR(clk_table[i])) {\n\t\t\tdev_err(dev, \"failed to register clock %d\\n\", i);\n\t\t\tret = PTR_ERR(clk_table[i]);\n\t\t\tgoto unregister;\n\t\t}\n\t}\n\n\tret = of_clk_add_hw_provider(dev->of_node, of_clk_hw_onecell_get,\n\t\t\t\t     clk_data);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add clock provider\\n\");\n\t\tgoto unregister;\n\t}\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n\nunregister:\n\texynos_audss_clk_teardown();\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\n\tif (!IS_ERR(epll))\n\t\tclk_disable_unprepare(epll);\n\n\treturn ret;\n}\n\nstatic void exynos_audss_clk_remove(struct platform_device *pdev)\n{\n\tof_clk_del_provider(pdev->dev.of_node);\n\n\texynos_audss_clk_teardown();\n\tpm_runtime_disable(&pdev->dev);\n\n\tif (!IS_ERR(epll))\n\t\tclk_disable_unprepare(epll);\n}\n\nstatic const struct dev_pm_ops exynos_audss_clk_pm_ops = {\n\tSET_RUNTIME_PM_OPS(exynos_audss_clk_suspend, exynos_audss_clk_resume,\n\t\t\t   NULL)\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t     pm_runtime_force_resume)\n};\n\nstatic struct platform_driver exynos_audss_clk_driver = {\n\t.driver\t= {\n\t\t.name = \"exynos-audss-clk\",\n\t\t.of_match_table = exynos_audss_clk_of_match,\n\t\t.pm = &exynos_audss_clk_pm_ops,\n\t},\n\t.probe = exynos_audss_clk_probe,\n\t.remove_new = exynos_audss_clk_remove,\n};\n\nmodule_platform_driver(exynos_audss_clk_driver);\n\nMODULE_AUTHOR(\"Padmavathi Venna <padma.v@samsung.com>\");\nMODULE_DESCRIPTION(\"Exynos Audio Subsystem Clock Controller\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:exynos-audss-clk\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}