{
  "module_name": "clk-cpu.c",
  "hash_id": "8240afac5e85643e4aa7fe7aca0a96a7a54be8b40d383b436d39e393de33b776",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/samsung/clk-cpu.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include \"clk-cpu.h\"\n\n#define E4210_SRC_CPU\t\t0x0\n#define E4210_STAT_CPU\t\t0x200\n#define E4210_DIV_CPU0\t\t0x300\n#define E4210_DIV_CPU1\t\t0x304\n#define E4210_DIV_STAT_CPU0\t0x400\n#define E4210_DIV_STAT_CPU1\t0x404\n\n#define E5433_MUX_SEL2\t\t0x008\n#define E5433_MUX_STAT2\t\t0x208\n#define E5433_DIV_CPU0\t\t0x400\n#define E5433_DIV_CPU1\t\t0x404\n#define E5433_DIV_STAT_CPU0\t0x500\n#define E5433_DIV_STAT_CPU1\t0x504\n\n#define E4210_DIV0_RATIO0_MASK\t0x7\n#define E4210_DIV1_HPM_MASK\t(0x7 << 4)\n#define E4210_DIV1_COPY_MASK\t(0x7 << 0)\n#define E4210_MUX_HPM_MASK\t(1 << 20)\n#define E4210_DIV0_ATB_SHIFT\t16\n#define E4210_DIV0_ATB_MASK\t(DIV_MASK << E4210_DIV0_ATB_SHIFT)\n\n#define MAX_DIV\t\t\t8\n#define DIV_MASK\t\t7\n#define DIV_MASK_ALL\t\t0xffffffff\n#define MUX_MASK\t\t7\n\n \nstatic void wait_until_divider_stable(void __iomem *div_reg, unsigned long mask)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(10);\n\n\tdo {\n\t\tif (!(readl(div_reg) & mask))\n\t\t\treturn;\n\t} while (time_before(jiffies, timeout));\n\n\tif (!(readl(div_reg) & mask))\n\t\treturn;\n\n\tpr_err(\"%s: timeout in divider stablization\\n\", __func__);\n}\n\n \nstatic void wait_until_mux_stable(void __iomem *mux_reg, u32 mux_pos,\n\t\t\t\t\tunsigned long mux_value)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(10);\n\n\tdo {\n\t\tif (((readl(mux_reg) >> mux_pos) & MUX_MASK) == mux_value)\n\t\t\treturn;\n\t} while (time_before(jiffies, timeout));\n\n\tif (((readl(mux_reg) >> mux_pos) & MUX_MASK) == mux_value)\n\t\treturn;\n\n\tpr_err(\"%s: re-parenting mux timed-out\\n\", __func__);\n}\n\n \nstatic long exynos_cpuclk_round_rate(struct clk_hw *hw,\n\t\t\tunsigned long drate, unsigned long *prate)\n{\n\tstruct clk_hw *parent = clk_hw_get_parent(hw);\n\t*prate = clk_hw_round_rate(parent, drate);\n\treturn *prate;\n}\n\n \nstatic unsigned long exynos_cpuclk_recalc_rate(struct clk_hw *hw,\n\t\t\tunsigned long parent_rate)\n{\n\t \n\treturn parent_rate;\n}\n\nstatic const struct clk_ops exynos_cpuclk_clk_ops = {\n\t.recalc_rate = exynos_cpuclk_recalc_rate,\n\t.round_rate = exynos_cpuclk_round_rate,\n};\n\n \nstatic void exynos_set_safe_div(void __iomem *base, unsigned long div,\n\t\t\t\t\tunsigned long mask)\n{\n\tunsigned long div0;\n\n\tdiv0 = readl(base + E4210_DIV_CPU0);\n\tdiv0 = (div0 & ~mask) | (div & mask);\n\twritel(div0, base + E4210_DIV_CPU0);\n\twait_until_divider_stable(base + E4210_DIV_STAT_CPU0, mask);\n}\n\n \nstatic int exynos_cpuclk_pre_rate_change(struct clk_notifier_data *ndata,\n\t\t\tstruct exynos_cpuclk *cpuclk, void __iomem *base)\n{\n\tconst struct exynos_cpuclk_cfg_data *cfg_data = cpuclk->cfg;\n\tunsigned long alt_prate = clk_hw_get_rate(cpuclk->alt_parent);\n\tunsigned long alt_div = 0, alt_div_mask = DIV_MASK;\n\tunsigned long div0, div1 = 0, mux_reg;\n\tunsigned long flags;\n\n\t \n\twhile ((cfg_data->prate * 1000) != ndata->new_rate) {\n\t\tif (cfg_data->prate == 0)\n\t\t\treturn -EINVAL;\n\t\tcfg_data++;\n\t}\n\n\tspin_lock_irqsave(cpuclk->lock, flags);\n\n\t \n\tdiv0 = cfg_data->div0;\n\tif (cpuclk->flags & CLK_CPU_HAS_DIV1) {\n\t\tdiv1 = cfg_data->div1;\n\t\tif (readl(base + E4210_SRC_CPU) & E4210_MUX_HPM_MASK)\n\t\t\tdiv1 = readl(base + E4210_DIV_CPU1) &\n\t\t\t\t(E4210_DIV1_HPM_MASK | E4210_DIV1_COPY_MASK);\n\t}\n\n\t \n\tif (alt_prate > ndata->old_rate || ndata->old_rate > ndata->new_rate) {\n\t\tunsigned long tmp_rate = min(ndata->old_rate, ndata->new_rate);\n\n\t\talt_div = DIV_ROUND_UP(alt_prate, tmp_rate) - 1;\n\t\tWARN_ON(alt_div >= MAX_DIV);\n\n\t\tif (cpuclk->flags & CLK_CPU_NEEDS_DEBUG_ALT_DIV) {\n\t\t\t \n\t\t\talt_div |= E4210_DIV0_ATB_MASK;\n\t\t\talt_div_mask |= E4210_DIV0_ATB_MASK;\n\t\t}\n\t\texynos_set_safe_div(base, alt_div, alt_div_mask);\n\t\tdiv0 |= alt_div;\n\t}\n\n\t \n\tmux_reg = readl(base + E4210_SRC_CPU);\n\twritel(mux_reg | (1 << 16), base + E4210_SRC_CPU);\n\twait_until_mux_stable(base + E4210_STAT_CPU, 16, 2);\n\n\t \n\twritel(div0, base + E4210_DIV_CPU0);\n\twait_until_divider_stable(base + E4210_DIV_STAT_CPU0, DIV_MASK_ALL);\n\n\tif (cpuclk->flags & CLK_CPU_HAS_DIV1) {\n\t\twritel(div1, base + E4210_DIV_CPU1);\n\t\twait_until_divider_stable(base + E4210_DIV_STAT_CPU1,\n\t\t\t\tDIV_MASK_ALL);\n\t}\n\n\tspin_unlock_irqrestore(cpuclk->lock, flags);\n\treturn 0;\n}\n\n \nstatic int exynos_cpuclk_post_rate_change(struct clk_notifier_data *ndata,\n\t\t\tstruct exynos_cpuclk *cpuclk, void __iomem *base)\n{\n\tconst struct exynos_cpuclk_cfg_data *cfg_data = cpuclk->cfg;\n\tunsigned long div = 0, div_mask = DIV_MASK;\n\tunsigned long mux_reg;\n\tunsigned long flags;\n\n\t \n\tif (cpuclk->flags & CLK_CPU_NEEDS_DEBUG_ALT_DIV) {\n\t\twhile ((cfg_data->prate * 1000) != ndata->new_rate) {\n\t\t\tif (cfg_data->prate == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tcfg_data++;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(cpuclk->lock, flags);\n\n\t \n\tmux_reg = readl(base + E4210_SRC_CPU);\n\twritel(mux_reg & ~(1 << 16), base + E4210_SRC_CPU);\n\twait_until_mux_stable(base + E4210_STAT_CPU, 16, 1);\n\n\tif (cpuclk->flags & CLK_CPU_NEEDS_DEBUG_ALT_DIV) {\n\t\tdiv |= (cfg_data->div0 & E4210_DIV0_ATB_MASK);\n\t\tdiv_mask |= E4210_DIV0_ATB_MASK;\n\t}\n\n\texynos_set_safe_div(base, div, div_mask);\n\tspin_unlock_irqrestore(cpuclk->lock, flags);\n\treturn 0;\n}\n\n \nstatic void exynos5433_set_safe_div(void __iomem *base, unsigned long div,\n\t\t\t\t\tunsigned long mask)\n{\n\tunsigned long div0;\n\n\tdiv0 = readl(base + E5433_DIV_CPU0);\n\tdiv0 = (div0 & ~mask) | (div & mask);\n\twritel(div0, base + E5433_DIV_CPU0);\n\twait_until_divider_stable(base + E5433_DIV_STAT_CPU0, mask);\n}\n\n \nstatic int exynos5433_cpuclk_pre_rate_change(struct clk_notifier_data *ndata,\n\t\t\tstruct exynos_cpuclk *cpuclk, void __iomem *base)\n{\n\tconst struct exynos_cpuclk_cfg_data *cfg_data = cpuclk->cfg;\n\tunsigned long alt_prate = clk_hw_get_rate(cpuclk->alt_parent);\n\tunsigned long alt_div = 0, alt_div_mask = DIV_MASK;\n\tunsigned long div0, div1 = 0, mux_reg;\n\tunsigned long flags;\n\n\t \n\twhile ((cfg_data->prate * 1000) != ndata->new_rate) {\n\t\tif (cfg_data->prate == 0)\n\t\t\treturn -EINVAL;\n\t\tcfg_data++;\n\t}\n\n\tspin_lock_irqsave(cpuclk->lock, flags);\n\n\t \n\tdiv0 = cfg_data->div0;\n\tdiv1 = cfg_data->div1;\n\n\t \n\tif (alt_prate > ndata->old_rate || ndata->old_rate > ndata->new_rate) {\n\t\tunsigned long tmp_rate = min(ndata->old_rate, ndata->new_rate);\n\n\t\talt_div = DIV_ROUND_UP(alt_prate, tmp_rate) - 1;\n\t\tWARN_ON(alt_div >= MAX_DIV);\n\n\t\texynos5433_set_safe_div(base, alt_div, alt_div_mask);\n\t\tdiv0 |= alt_div;\n\t}\n\n\t \n\tmux_reg = readl(base + E5433_MUX_SEL2);\n\twritel(mux_reg | 1, base + E5433_MUX_SEL2);\n\twait_until_mux_stable(base + E5433_MUX_STAT2, 0, 2);\n\n\t \n\twritel(div0, base + E5433_DIV_CPU0);\n\twait_until_divider_stable(base + E5433_DIV_STAT_CPU0, DIV_MASK_ALL);\n\n\twritel(div1, base + E5433_DIV_CPU1);\n\twait_until_divider_stable(base + E5433_DIV_STAT_CPU1, DIV_MASK_ALL);\n\n\tspin_unlock_irqrestore(cpuclk->lock, flags);\n\treturn 0;\n}\n\n \nstatic int exynos5433_cpuclk_post_rate_change(struct clk_notifier_data *ndata,\n\t\t\tstruct exynos_cpuclk *cpuclk, void __iomem *base)\n{\n\tunsigned long div = 0, div_mask = DIV_MASK;\n\tunsigned long mux_reg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(cpuclk->lock, flags);\n\n\t \n\tmux_reg = readl(base + E5433_MUX_SEL2);\n\twritel(mux_reg & ~1, base + E5433_MUX_SEL2);\n\twait_until_mux_stable(base + E5433_MUX_STAT2, 0, 1);\n\n\texynos5433_set_safe_div(base, div, div_mask);\n\tspin_unlock_irqrestore(cpuclk->lock, flags);\n\treturn 0;\n}\n\n \nstatic int exynos_cpuclk_notifier_cb(struct notifier_block *nb,\n\t\t\t\tunsigned long event, void *data)\n{\n\tstruct clk_notifier_data *ndata = data;\n\tstruct exynos_cpuclk *cpuclk;\n\tvoid __iomem *base;\n\tint err = 0;\n\n\tcpuclk = container_of(nb, struct exynos_cpuclk, clk_nb);\n\tbase = cpuclk->ctrl_base;\n\n\tif (event == PRE_RATE_CHANGE)\n\t\terr = exynos_cpuclk_pre_rate_change(ndata, cpuclk, base);\n\telse if (event == POST_RATE_CHANGE)\n\t\terr = exynos_cpuclk_post_rate_change(ndata, cpuclk, base);\n\n\treturn notifier_from_errno(err);\n}\n\n \nstatic int exynos5433_cpuclk_notifier_cb(struct notifier_block *nb,\n\t\t\t\tunsigned long event, void *data)\n{\n\tstruct clk_notifier_data *ndata = data;\n\tstruct exynos_cpuclk *cpuclk;\n\tvoid __iomem *base;\n\tint err = 0;\n\n\tcpuclk = container_of(nb, struct exynos_cpuclk, clk_nb);\n\tbase = cpuclk->ctrl_base;\n\n\tif (event == PRE_RATE_CHANGE)\n\t\terr = exynos5433_cpuclk_pre_rate_change(ndata, cpuclk, base);\n\telse if (event == POST_RATE_CHANGE)\n\t\terr = exynos5433_cpuclk_post_rate_change(ndata, cpuclk, base);\n\n\treturn notifier_from_errno(err);\n}\n\n \nstatic int __init exynos_register_cpu_clock(struct samsung_clk_provider *ctx,\n\t\tunsigned int lookup_id, const char *name,\n\t\tconst struct clk_hw *parent, const struct clk_hw *alt_parent,\n\t\tunsigned long offset, const struct exynos_cpuclk_cfg_data *cfg,\n\t\tunsigned long num_cfgs, unsigned long flags)\n{\n\tstruct exynos_cpuclk *cpuclk;\n\tstruct clk_init_data init;\n\tconst char *parent_name;\n\tint ret = 0;\n\n\tif (IS_ERR(parent) || IS_ERR(alt_parent)) {\n\t\tpr_err(\"%s: invalid parent clock(s)\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tcpuclk = kzalloc(sizeof(*cpuclk), GFP_KERNEL);\n\tif (!cpuclk)\n\t\treturn -ENOMEM;\n\n\tparent_name = clk_hw_get_name(parent);\n\n\tinit.name = name;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.ops = &exynos_cpuclk_clk_ops;\n\n\tcpuclk->alt_parent = alt_parent;\n\tcpuclk->hw.init = &init;\n\tcpuclk->ctrl_base = ctx->reg_base + offset;\n\tcpuclk->lock = &ctx->lock;\n\tcpuclk->flags = flags;\n\tif (flags & CLK_CPU_HAS_E5433_REGS_LAYOUT)\n\t\tcpuclk->clk_nb.notifier_call = exynos5433_cpuclk_notifier_cb;\n\telse\n\t\tcpuclk->clk_nb.notifier_call = exynos_cpuclk_notifier_cb;\n\n\n\tret = clk_notifier_register(parent->clk, &cpuclk->clk_nb);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to register clock notifier for %s\\n\",\n\t\t\t\t__func__, name);\n\t\tgoto free_cpuclk;\n\t}\n\n\tcpuclk->cfg = kmemdup(cfg, sizeof(*cfg) * num_cfgs, GFP_KERNEL);\n\tif (!cpuclk->cfg) {\n\t\tret = -ENOMEM;\n\t\tgoto unregister_clk_nb;\n\t}\n\n\tret = clk_hw_register(NULL, &cpuclk->hw);\n\tif (ret) {\n\t\tpr_err(\"%s: could not register cpuclk %s\\n\", __func__,\tname);\n\t\tgoto free_cpuclk_data;\n\t}\n\n\tsamsung_clk_add_lookup(ctx, &cpuclk->hw, lookup_id);\n\treturn 0;\n\nfree_cpuclk_data:\n\tkfree(cpuclk->cfg);\nunregister_clk_nb:\n\tclk_notifier_unregister(parent->clk, &cpuclk->clk_nb);\nfree_cpuclk:\n\tkfree(cpuclk);\n\treturn ret;\n}\n\nvoid __init samsung_clk_register_cpu(struct samsung_clk_provider *ctx,\n\t\tconst struct samsung_cpu_clock *list, unsigned int nr_clk)\n{\n\tunsigned int idx;\n\tunsigned int num_cfgs;\n\tstruct clk_hw **hws = ctx->clk_data.hws;\n\n\tfor (idx = 0; idx < nr_clk; idx++, list++) {\n\t\t \n\t\tfor (num_cfgs = 0; list->cfg[num_cfgs].prate != 0; )\n\t\t\tnum_cfgs++;\n\n\t\texynos_register_cpu_clock(ctx, list->id, list->name, hws[list->parent_id],\n\t\t\t\thws[list->alt_parent_id], list->offset, list->cfg, num_cfgs,\n\t\t\t\tlist->flags);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}