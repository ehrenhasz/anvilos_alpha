{
  "module_name": "clk-apple-nco.c",
  "hash_id": "1a2b1f81e8df3c48efda08a1d61777dc8d3af202924a0271c60e564b0dd4b8d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-apple-nco.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#define NCO_CHANNEL_STRIDE\t0x4000\n#define NCO_CHANNEL_REGSIZE\t20\n\n#define REG_CTRL\t0\n#define CTRL_ENABLE\tBIT(31)\n#define REG_DIV\t\t4\n#define DIV_FINE\tGENMASK(1, 0)\n#define DIV_COARSE\tGENMASK(12, 2)\n#define REG_INC1\t8\n#define REG_INC2\t12\n#define REG_ACCINIT\t16\n\n \n\n#define LFSR_POLY\t0xa01\n#define LFSR_INIT\t0x7ff\n#define LFSR_LEN\t11\n#define LFSR_PERIOD\t((1 << LFSR_LEN) - 1)\n#define LFSR_TBLSIZE\t(1 << LFSR_LEN)\n\n \n#define COARSE_DIV_OFFSET 2\n\nstruct applnco_tables {\n\tu16 fwd[LFSR_TBLSIZE];\n\tu16 inv[LFSR_TBLSIZE];\n};\n\nstruct applnco_channel {\n\tvoid __iomem *base;\n\tstruct applnco_tables *tbl;\n\tstruct clk_hw hw;\n\n\tspinlock_t lock;\n};\n\n#define to_applnco_channel(_hw) container_of(_hw, struct applnco_channel, hw)\n\nstatic void applnco_enable_nolock(struct clk_hw *hw)\n{\n\tstruct applnco_channel *chan = to_applnco_channel(hw);\n\tu32 val;\n\n\tval = readl_relaxed(chan->base + REG_CTRL);\n\twritel_relaxed(val | CTRL_ENABLE, chan->base + REG_CTRL);\n}\n\nstatic void applnco_disable_nolock(struct clk_hw *hw)\n{\n\tstruct applnco_channel *chan = to_applnco_channel(hw);\n\tu32 val;\n\n\tval = readl_relaxed(chan->base + REG_CTRL);\n\twritel_relaxed(val & ~CTRL_ENABLE, chan->base + REG_CTRL);\n}\n\nstatic int applnco_is_enabled(struct clk_hw *hw)\n{\n\tstruct applnco_channel *chan = to_applnco_channel(hw);\n\n\treturn (readl_relaxed(chan->base + REG_CTRL) & CTRL_ENABLE) != 0;\n}\n\nstatic void applnco_compute_tables(struct applnco_tables *tbl)\n{\n\tint i;\n\tu32 state = LFSR_INIT;\n\n\t \n\tfor (i = LFSR_PERIOD; i > 0; i--) {\n\t\tif (state & 1)\n\t\t\tstate = (state >> 1) ^ (LFSR_POLY >> 1);\n\t\telse\n\t\t\tstate = (state >> 1);\n\t\ttbl->fwd[i] = state;\n\t\ttbl->inv[state] = i;\n\t}\n\n\t \n\ttbl->fwd[0] = 0;\n\ttbl->inv[0] = 0;\n}\n\nstatic bool applnco_div_out_of_range(unsigned int div)\n{\n\tunsigned int coarse = div / 4;\n\n\treturn coarse < COARSE_DIV_OFFSET ||\n\t\tcoarse >= COARSE_DIV_OFFSET + LFSR_TBLSIZE;\n}\n\nstatic u32 applnco_div_translate(struct applnco_tables *tbl, unsigned int div)\n{\n\tunsigned int coarse = div / 4;\n\n\tif (WARN_ON(applnco_div_out_of_range(div)))\n\t\treturn 0;\n\n\treturn FIELD_PREP(DIV_COARSE, tbl->fwd[coarse - COARSE_DIV_OFFSET]) |\n\t\t\tFIELD_PREP(DIV_FINE, div % 4);\n}\n\nstatic unsigned int applnco_div_translate_inv(struct applnco_tables *tbl, u32 regval)\n{\n\tunsigned int coarse, fine;\n\n\tcoarse = tbl->inv[FIELD_GET(DIV_COARSE, regval)] + COARSE_DIV_OFFSET;\n\tfine = FIELD_GET(DIV_FINE, regval);\n\n\treturn coarse * 4 + fine;\n}\n\nstatic int applnco_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct applnco_channel *chan = to_applnco_channel(hw);\n\tunsigned long flags;\n\tu32 div, inc1, inc2;\n\tbool was_enabled;\n\n\tdiv = 2 * parent_rate / rate;\n\tinc1 = 2 * parent_rate - div * rate;\n\tinc2 = inc1 - rate;\n\n\tif (applnco_div_out_of_range(div))\n\t\treturn -EINVAL;\n\n\tdiv = applnco_div_translate(chan->tbl, div);\n\n\tspin_lock_irqsave(&chan->lock, flags);\n\twas_enabled = applnco_is_enabled(hw);\n\tapplnco_disable_nolock(hw);\n\n\twritel_relaxed(div,  chan->base + REG_DIV);\n\twritel_relaxed(inc1, chan->base + REG_INC1);\n\twritel_relaxed(inc2, chan->base + REG_INC2);\n\n\t \n\twritel_relaxed(1 << 31, chan->base + REG_ACCINIT);\n\n\tif (was_enabled)\n\t\tapplnco_enable_nolock(hw);\n\tspin_unlock_irqrestore(&chan->lock, flags);\n\n\treturn 0;\n}\n\nstatic unsigned long applnco_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct applnco_channel *chan = to_applnco_channel(hw);\n\tu32 div, inc1, inc2, incbase;\n\n\tdiv = applnco_div_translate_inv(chan->tbl,\n\t\t\treadl_relaxed(chan->base + REG_DIV));\n\n\tinc1 = readl_relaxed(chan->base + REG_INC1);\n\tinc2 = readl_relaxed(chan->base + REG_INC2);\n\n\t \n\tif (inc1 >= (1 << 31) || inc2 < (1 << 31) || (inc1 == 0 && inc2 == 0))\n\t\treturn 0;\n\n\t \n\tincbase = inc1 - inc2;\n\n\treturn div64_u64(((u64) parent_rate) * 2 * incbase,\n\t\t\t((u64) div) * incbase + inc1);\n}\n\nstatic long applnco_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *parent_rate)\n{\n\tunsigned long lo = *parent_rate / (COARSE_DIV_OFFSET + LFSR_TBLSIZE) + 1;\n\tunsigned long hi = *parent_rate / COARSE_DIV_OFFSET;\n\n\treturn clamp(rate, lo, hi);\n}\n\nstatic int applnco_enable(struct clk_hw *hw)\n{\n\tstruct applnco_channel *chan = to_applnco_channel(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chan->lock, flags);\n\tapplnco_enable_nolock(hw);\n\tspin_unlock_irqrestore(&chan->lock, flags);\n\n\treturn 0;\n}\n\nstatic void applnco_disable(struct clk_hw *hw)\n{\n\tstruct applnco_channel *chan = to_applnco_channel(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chan->lock, flags);\n\tapplnco_disable_nolock(hw);\n\tspin_unlock_irqrestore(&chan->lock, flags);\n}\n\nstatic const struct clk_ops applnco_ops = {\n\t.set_rate = applnco_set_rate,\n\t.recalc_rate = applnco_recalc_rate,\n\t.round_rate = applnco_round_rate,\n\t.enable = applnco_enable,\n\t.disable = applnco_disable,\n\t.is_enabled = applnco_is_enabled,\n};\n\nstatic int applnco_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct clk_parent_data pdata = { .index = 0 };\n\tstruct clk_init_data init;\n\tstruct clk_hw_onecell_data *onecell_data;\n\tvoid __iomem *base;\n\tstruct resource *res;\n\tstruct applnco_tables *tbl;\n\tunsigned int nchannels;\n\tint ret, i;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tif (resource_size(res) < NCO_CHANNEL_REGSIZE)\n\t\treturn -EINVAL;\n\tnchannels = (resource_size(res) - NCO_CHANNEL_REGSIZE)\n\t\t\t/ NCO_CHANNEL_STRIDE + 1;\n\n\tonecell_data = devm_kzalloc(&pdev->dev, struct_size(onecell_data, hws,\n\t\t\t\t\t\t\tnchannels), GFP_KERNEL);\n\tif (!onecell_data)\n\t\treturn -ENOMEM;\n\tonecell_data->num = nchannels;\n\n\ttbl = devm_kzalloc(&pdev->dev, sizeof(*tbl), GFP_KERNEL);\n\tif (!tbl)\n\t\treturn -ENOMEM;\n\tapplnco_compute_tables(tbl);\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tstruct applnco_channel *chan;\n\n\t\tchan = devm_kzalloc(&pdev->dev, sizeof(*chan), GFP_KERNEL);\n\t\tif (!chan)\n\t\t\treturn -ENOMEM;\n\t\tchan->base = base + NCO_CHANNEL_STRIDE * i;\n\t\tchan->tbl = tbl;\n\t\tspin_lock_init(&chan->lock);\n\n\t\tmemset(&init, 0, sizeof(init));\n\t\tinit.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t\"%s-%d\", np->name, i);\n\t\tinit.ops = &applnco_ops;\n\t\tinit.parent_data = &pdata;\n\t\tinit.num_parents = 1;\n\t\tinit.flags = 0;\n\n\t\tchan->hw.init = &init;\n\t\tret = devm_clk_hw_register(&pdev->dev, &chan->hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tonecell_data->hws[i] = &chan->hw;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, of_clk_hw_onecell_get,\n\t\t\t\t\t\t\tonecell_data);\n}\n\nstatic const struct of_device_id applnco_ids[] = {\n\t{ .compatible = \"apple,nco\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, applnco_ids);\n\nstatic struct platform_driver applnco_driver = {\n\t.driver = {\n\t\t.name = \"apple-nco\",\n\t\t.of_match_table = applnco_ids,\n\t},\n\t.probe = applnco_probe,\n};\nmodule_platform_driver(applnco_driver);\n\nMODULE_AUTHOR(\"Martin Povi\u0161er <povik+lin@cutebit.org>\");\nMODULE_DESCRIPTION(\"Clock driver for NCO blocks on Apple SoCs\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}