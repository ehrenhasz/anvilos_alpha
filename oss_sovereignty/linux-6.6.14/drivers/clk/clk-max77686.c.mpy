{
  "module_name": "clk-max77686.c",
  "hash_id": "0abea79731c10eb6dfd40b1d91a21ffafe935427ba787552a3110341893b7d51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-max77686.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/max77620.h>\n#include <linux/mfd/max77686.h>\n#include <linux/mfd/max77686-private.h>\n#include <linux/clk-provider.h>\n#include <linux/mutex.h>\n#include <linux/clkdev.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/clock/maxim,max77686.h>\n#include <dt-bindings/clock/maxim,max77802.h>\n#include <dt-bindings/clock/maxim,max77620.h>\n\n#define MAX77802_CLOCK_LOW_JITTER_SHIFT 0x3\n\nenum max77686_chip_name {\n\tCHIP_MAX77686,\n\tCHIP_MAX77802,\n\tCHIP_MAX77620,\n};\n\nstruct max77686_hw_clk_info {\n\tconst char *name;\n\tu32 clk_reg;\n\tu32 clk_enable_mask;\n\tu32 flags;\n};\n\nstruct max77686_clk_init_data {\n\tstruct regmap *regmap;\n\tstruct clk_hw hw;\n\tstruct clk_init_data clk_idata;\n\tconst struct max77686_hw_clk_info *clk_info;\n};\n\nstruct max77686_clk_driver_data {\n\tenum max77686_chip_name chip;\n\tstruct max77686_clk_init_data *max_clk_data;\n\tsize_t num_clks;\n};\n\nstatic const struct\nmax77686_hw_clk_info max77686_hw_clks_info[MAX77686_CLKS_NUM] = {\n\t[MAX77686_CLK_AP] = {\n\t\t.name = \"32khz_ap\",\n\t\t.clk_reg = MAX77686_REG_32KHZ,\n\t\t.clk_enable_mask = BIT(MAX77686_CLK_AP),\n\t},\n\t[MAX77686_CLK_CP] = {\n\t\t.name = \"32khz_cp\",\n\t\t.clk_reg = MAX77686_REG_32KHZ,\n\t\t.clk_enable_mask = BIT(MAX77686_CLK_CP),\n\t},\n\t[MAX77686_CLK_PMIC] = {\n\t\t.name = \"32khz_pmic\",\n\t\t.clk_reg = MAX77686_REG_32KHZ,\n\t\t.clk_enable_mask = BIT(MAX77686_CLK_PMIC),\n\t},\n};\n\nstatic const struct\nmax77686_hw_clk_info max77802_hw_clks_info[MAX77802_CLKS_NUM] = {\n\t[MAX77802_CLK_32K_AP] = {\n\t\t.name = \"32khz_ap\",\n\t\t.clk_reg = MAX77802_REG_32KHZ,\n\t\t.clk_enable_mask = BIT(MAX77802_CLK_32K_AP),\n\t},\n\t[MAX77802_CLK_32K_CP] = {\n\t\t.name = \"32khz_cp\",\n\t\t.clk_reg = MAX77802_REG_32KHZ,\n\t\t.clk_enable_mask = BIT(MAX77802_CLK_32K_CP),\n\t},\n};\n\nstatic const struct\nmax77686_hw_clk_info max77620_hw_clks_info[MAX77620_CLKS_NUM] = {\n\t[MAX77620_CLK_32K_OUT0] = {\n\t\t.name = \"32khz_out0\",\n\t\t.clk_reg = MAX77620_REG_CNFG1_32K,\n\t\t.clk_enable_mask = MAX77620_CNFG1_32K_OUT0_EN,\n\t},\n};\n\nstatic struct max77686_clk_init_data *to_max77686_clk_init_data(\n\t\t\t\tstruct clk_hw *hw)\n{\n\treturn container_of(hw, struct max77686_clk_init_data, hw);\n}\n\nstatic int max77686_clk_prepare(struct clk_hw *hw)\n{\n\tstruct max77686_clk_init_data *max77686 = to_max77686_clk_init_data(hw);\n\n\treturn regmap_update_bits(max77686->regmap, max77686->clk_info->clk_reg,\n\t\t\t\t  max77686->clk_info->clk_enable_mask,\n\t\t\t\t  max77686->clk_info->clk_enable_mask);\n}\n\nstatic void max77686_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct max77686_clk_init_data *max77686 = to_max77686_clk_init_data(hw);\n\n\tregmap_update_bits(max77686->regmap, max77686->clk_info->clk_reg,\n\t\t\t   max77686->clk_info->clk_enable_mask,\n\t\t\t   ~max77686->clk_info->clk_enable_mask);\n}\n\nstatic int max77686_clk_is_prepared(struct clk_hw *hw)\n{\n\tstruct max77686_clk_init_data *max77686 = to_max77686_clk_init_data(hw);\n\tint ret;\n\tu32 val;\n\n\tret = regmap_read(max77686->regmap, max77686->clk_info->clk_reg, &val);\n\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\treturn val & max77686->clk_info->clk_enable_mask;\n}\n\nstatic unsigned long max77686_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\treturn 32768;\n}\n\nstatic const struct clk_ops max77686_clk_ops = {\n\t.prepare\t= max77686_clk_prepare,\n\t.unprepare\t= max77686_clk_unprepare,\n\t.is_prepared\t= max77686_clk_is_prepared,\n\t.recalc_rate\t= max77686_recalc_rate,\n};\n\nstatic struct clk_hw *\nof_clk_max77686_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct max77686_clk_driver_data *drv_data = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= drv_data->num_clks) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &drv_data->max_clk_data[idx].hw;\n}\n\nstatic int max77686_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device *parent = dev->parent;\n\tconst struct platform_device_id *id = platform_get_device_id(pdev);\n\tstruct max77686_clk_driver_data *drv_data;\n\tconst struct max77686_hw_clk_info *hw_clks;\n\tstruct regmap *regmap;\n\tint i, ret, num_clks;\n\n\tdrv_data = devm_kzalloc(dev, sizeof(*drv_data), GFP_KERNEL);\n\tif (!drv_data)\n\t\treturn -ENOMEM;\n\n\tregmap = dev_get_regmap(parent, NULL);\n\tif (!regmap) {\n\t\tdev_err(dev, \"Failed to get rtc regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdrv_data->chip = id->driver_data;\n\n\tswitch (drv_data->chip) {\n\tcase CHIP_MAX77686:\n\t\tnum_clks = MAX77686_CLKS_NUM;\n\t\thw_clks = max77686_hw_clks_info;\n\t\tbreak;\n\n\tcase CHIP_MAX77802:\n\t\tnum_clks = MAX77802_CLKS_NUM;\n\t\thw_clks = max77802_hw_clks_info;\n\t\tbreak;\n\n\tcase CHIP_MAX77620:\n\t\tnum_clks = MAX77620_CLKS_NUM;\n\t\thw_clks = max77620_hw_clks_info;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unknown Chip ID\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdrv_data->num_clks = num_clks;\n\tdrv_data->max_clk_data = devm_kcalloc(dev, num_clks,\n\t\t\t\t\t      sizeof(*drv_data->max_clk_data),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!drv_data->max_clk_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tstruct max77686_clk_init_data *max_clk_data;\n\t\tconst char *clk_name;\n\n\t\tmax_clk_data = &drv_data->max_clk_data[i];\n\n\t\tmax_clk_data->regmap = regmap;\n\t\tmax_clk_data->clk_info = &hw_clks[i];\n\t\tmax_clk_data->clk_idata.flags = hw_clks[i].flags;\n\t\tmax_clk_data->clk_idata.ops = &max77686_clk_ops;\n\n\t\tif (parent->of_node &&\n\t\t    !of_property_read_string_index(parent->of_node,\n\t\t\t\t\t\t   \"clock-output-names\",\n\t\t\t\t\t\t   i, &clk_name))\n\t\t\tmax_clk_data->clk_idata.name = clk_name;\n\t\telse\n\t\t\tmax_clk_data->clk_idata.name = hw_clks[i].name;\n\n\t\tmax_clk_data->hw.init = &max_clk_data->clk_idata;\n\n\t\tret = devm_clk_hw_register(dev, &max_clk_data->hw);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to clock register: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_clk_hw_register_clkdev(dev, &max_clk_data->hw,\n\t\t\t\t\t\t  max_clk_data->clk_idata.name,\n\t\t\t\t\t\t  NULL);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to clkdev register: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (parent->of_node) {\n\t\tret = devm_of_clk_add_hw_provider(dev, of_clk_max77686_get,\n\t\t\t\t\t\t  drv_data);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to register OF clock provider: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (drv_data->chip == CHIP_MAX77802) {\n\t\tret = regmap_update_bits(regmap, MAX77802_REG_32KHZ,\n\t\t\t\t\t 1 << MAX77802_CLOCK_LOW_JITTER_SHIFT,\n\t\t\t\t\t 1 << MAX77802_CLOCK_LOW_JITTER_SHIFT);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to config low-jitter: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id max77686_clk_id[] = {\n\t{ \"max77686-clk\", .driver_data = CHIP_MAX77686, },\n\t{ \"max77802-clk\", .driver_data = CHIP_MAX77802, },\n\t{ \"max77620-clock\", .driver_data = CHIP_MAX77620, },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, max77686_clk_id);\n\nstatic struct platform_driver max77686_clk_driver = {\n\t.driver = {\n\t\t.name  = \"max77686-clk\",\n\t},\n\t.probe = max77686_clk_probe,\n\t.id_table = max77686_clk_id,\n};\n\nmodule_platform_driver(max77686_clk_driver);\n\nMODULE_DESCRIPTION(\"MAXIM 77686 Clock Driver\");\nMODULE_AUTHOR(\"Jonghwa Lee <jonghwa3.lee@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}