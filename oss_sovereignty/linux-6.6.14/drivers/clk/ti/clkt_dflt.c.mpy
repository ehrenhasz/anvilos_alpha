{
  "module_name": "clkt_dflt.c",
  "hash_id": "64062b7f43e33b8d32293cc99a4223ebe4e91bd18171fee430ee5ef67b8fc8a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/clkt_dflt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/clk/ti.h>\n#include <linux/delay.h>\n\n#include \"clock.h\"\n\n \n#define MAX_MODULE_ENABLE_WAIT\t\t100000\n\n \n#define CM_FCLKEN\t\t\t0x0000\n#define CM_ICLKEN\t\t\t0x0010\n\n \nstatic int _wait_idlest_generic(struct clk_hw_omap *clk,\n\t\t\t\tstruct clk_omap_reg *reg,\n\t\t\t\tu32 mask, u8 idlest, const char *name)\n{\n\tint i = 0, ena = 0;\n\n\tena = (idlest) ? 0 : mask;\n\n\t \n\tfor (i = 0; i < MAX_MODULE_ENABLE_WAIT; i++) {\n\t\tif ((ti_clk_ll_ops->clk_readl(reg) & mask) == ena)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i < MAX_MODULE_ENABLE_WAIT)\n\t\tpr_debug(\"omap clock: module associated with clock %s ready after %d loops\\n\",\n\t\t\t name, i);\n\telse\n\t\tpr_err(\"omap clock: module associated with clock %s didn't enable in %d tries\\n\",\n\t\t       name, MAX_MODULE_ENABLE_WAIT);\n\n\treturn (i < MAX_MODULE_ENABLE_WAIT) ? 1 : 0;\n}\n\n \nstatic void _omap2_module_wait_ready(struct clk_hw_omap *clk)\n{\n\tstruct clk_omap_reg companion_reg, idlest_reg;\n\tu8 other_bit, idlest_bit, idlest_val, idlest_reg_id;\n\ts16 prcm_mod;\n\tint r;\n\n\t \n\tif (clk->ops->find_companion) {\n\t\tclk->ops->find_companion(clk, &companion_reg, &other_bit);\n\t\tif (!(ti_clk_ll_ops->clk_readl(&companion_reg) &\n\t\t      (1 << other_bit)))\n\t\t\treturn;\n\t}\n\n\tclk->ops->find_idlest(clk, &idlest_reg, &idlest_bit, &idlest_val);\n\tr = ti_clk_ll_ops->cm_split_idlest_reg(&idlest_reg, &prcm_mod,\n\t\t\t\t\t       &idlest_reg_id);\n\tif (r) {\n\t\t \n\t\t_wait_idlest_generic(clk, &idlest_reg, (1 << idlest_bit),\n\t\t\t\t     idlest_val, clk_hw_get_name(&clk->hw));\n\t} else {\n\t\tti_clk_ll_ops->cm_wait_module_ready(0, prcm_mod, idlest_reg_id,\n\t\t\t\t\t\t    idlest_bit);\n\t}\n}\n\n \nvoid omap2_clk_dflt_find_companion(struct clk_hw_omap *clk,\n\t\t\t\t   struct clk_omap_reg *other_reg,\n\t\t\t\t   u8 *other_bit)\n{\n\tmemcpy(other_reg, &clk->enable_reg, sizeof(*other_reg));\n\n\t \n\tother_reg->offset ^= (CM_FCLKEN ^ CM_ICLKEN);\n\n\t*other_bit = clk->enable_bit;\n}\n\n \nvoid omap2_clk_dflt_find_idlest(struct clk_hw_omap *clk,\n\t\t\t\tstruct clk_omap_reg *idlest_reg, u8 *idlest_bit,\n\t\t\t\tu8 *idlest_val)\n{\n\tmemcpy(idlest_reg, &clk->enable_reg, sizeof(*idlest_reg));\n\n\tidlest_reg->offset &= ~0xf0;\n\tidlest_reg->offset |= 0x20;\n\n\t*idlest_bit = clk->enable_bit;\n\n\t \n\t*idlest_val = ti_clk_get_features()->cm_idlest_val;\n}\n\n \nint omap2_dflt_clk_enable(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk;\n\tu32 v;\n\tint ret = 0;\n\tbool clkdm_control;\n\n\tif (ti_clk_get_features()->flags & TI_CLK_DISABLE_CLKDM_CONTROL)\n\t\tclkdm_control = false;\n\telse\n\t\tclkdm_control = true;\n\n\tclk = to_clk_hw_omap(hw);\n\n\tif (clkdm_control && clk->clkdm) {\n\t\tret = ti_clk_ll_ops->clkdm_clk_enable(clk->clkdm, hw->clk);\n\t\tif (ret) {\n\t\t\tWARN(1,\n\t\t\t     \"%s: could not enable %s's clockdomain %s: %d\\n\",\n\t\t\t     __func__, clk_hw_get_name(hw),\n\t\t\t     clk->clkdm_name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tv = ti_clk_ll_ops->clk_readl(&clk->enable_reg);\n\tif (clk->flags & INVERT_ENABLE)\n\t\tv &= ~(1 << clk->enable_bit);\n\telse\n\t\tv |= (1 << clk->enable_bit);\n\tti_clk_ll_ops->clk_writel(v, &clk->enable_reg);\n\tv = ti_clk_ll_ops->clk_readl(&clk->enable_reg);  \n\n\tif (clk->ops && clk->ops->find_idlest)\n\t\t_omap2_module_wait_ready(clk);\n\n\treturn 0;\n}\n\n \nvoid omap2_dflt_clk_disable(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk;\n\tu32 v;\n\n\tclk = to_clk_hw_omap(hw);\n\n\tv = ti_clk_ll_ops->clk_readl(&clk->enable_reg);\n\tif (clk->flags & INVERT_ENABLE)\n\t\tv |= (1 << clk->enable_bit);\n\telse\n\t\tv &= ~(1 << clk->enable_bit);\n\tti_clk_ll_ops->clk_writel(v, &clk->enable_reg);\n\t \n\n\tif (!(ti_clk_get_features()->flags & TI_CLK_DISABLE_CLKDM_CONTROL) &&\n\t    clk->clkdm)\n\t\tti_clk_ll_ops->clkdm_clk_disable(clk->clkdm, hw->clk);\n}\n\n \nint omap2_dflt_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tu32 v;\n\n\tv = ti_clk_ll_ops->clk_readl(&clk->enable_reg);\n\n\tif (clk->flags & INVERT_ENABLE)\n\t\tv ^= BIT(clk->enable_bit);\n\n\tv &= BIT(clk->enable_bit);\n\n\treturn v ? 1 : 0;\n}\n\nconst struct clk_hw_omap_ops clkhwops_wait = {\n\t.find_idlest\t= omap2_clk_dflt_find_idlest,\n\t.find_companion\t= omap2_clk_dflt_find_companion,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}