{
  "module_name": "fapll.c",
  "hash_id": "b42cd67190d567c0047b8727038c073fc0b91e426e6ac1b65462c966f2583b03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/fapll.c",
  "human_readable_source": "\n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/math64.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/clk/ti.h>\n\n#include \"clock.h\"\n\n \n#define FAPLL_MAIN_MULT_N_SHIFT\t16\n#define FAPLL_MAIN_DIV_P_SHIFT\t8\n#define FAPLL_MAIN_LOCK\t\tBIT(7)\n#define FAPLL_MAIN_PLLEN\tBIT(3)\n#define FAPLL_MAIN_BP\t\tBIT(2)\n#define FAPLL_MAIN_LOC_CTL\tBIT(0)\n\n#define FAPLL_MAIN_MAX_MULT_N\t0xffff\n#define FAPLL_MAIN_MAX_DIV_P\t0xff\n#define FAPLL_MAIN_CLEAR_MASK\t\\\n\t((FAPLL_MAIN_MAX_MULT_N << FAPLL_MAIN_MULT_N_SHIFT) | \\\n\t (FAPLL_MAIN_DIV_P_SHIFT << FAPLL_MAIN_DIV_P_SHIFT) | \\\n\t FAPLL_MAIN_LOC_CTL)\n\n \n#define FAPLL_PWD_OFFSET\t4\n\n#define MAX_FAPLL_OUTPUTS\t7\n#define FAPLL_MAX_RETRIES\t1000\n\n#define to_fapll(_hw)\t\tcontainer_of(_hw, struct fapll_data, hw)\n#define to_synth(_hw)\t\tcontainer_of(_hw, struct fapll_synth, hw)\n\n \n#define fapll_is_ddr_pll(va)\t(((u32)(va) & 0xffff) == 0x0440)\n\n \n#define is_ddr_pll_clk1(va)\t(((u32)(va) & 0xffff) == 0x044c)\n#define is_audio_pll_clk1(va)\t(((u32)(va) & 0xffff) == 0x04a8)\n\n \n#define SYNTH_LDMDIV1\t\tBIT(8)\n\n \n#define SYNTH_LDFREQ\t\tBIT(31)\n\n#define SYNTH_PHASE_K\t\t8\n#define SYNTH_MAX_INT_DIV\t0xf\n#define SYNTH_MAX_DIV_M\t\t0xff\n\nstruct fapll_data {\n\tstruct clk_hw hw;\n\tvoid __iomem *base;\n\tconst char *name;\n\tstruct clk *clk_ref;\n\tstruct clk *clk_bypass;\n\tstruct clk_onecell_data outputs;\n\tbool bypass_bit_inverted;\n};\n\nstruct fapll_synth {\n\tstruct clk_hw hw;\n\tstruct fapll_data *fd;\n\tint index;\n\tvoid __iomem *freq;\n\tvoid __iomem *div;\n\tconst char *name;\n\tstruct clk *clk_pll;\n};\n\nstatic bool ti_fapll_clock_is_bypass(struct fapll_data *fd)\n{\n\tu32 v = readl_relaxed(fd->base);\n\n\tif (fd->bypass_bit_inverted)\n\t\treturn !(v & FAPLL_MAIN_BP);\n\telse\n\t\treturn !!(v & FAPLL_MAIN_BP);\n}\n\nstatic void ti_fapll_set_bypass(struct fapll_data *fd)\n{\n\tu32 v = readl_relaxed(fd->base);\n\n\tif (fd->bypass_bit_inverted)\n\t\tv &= ~FAPLL_MAIN_BP;\n\telse\n\t\tv |= FAPLL_MAIN_BP;\n\twritel_relaxed(v, fd->base);\n}\n\nstatic void ti_fapll_clear_bypass(struct fapll_data *fd)\n{\n\tu32 v = readl_relaxed(fd->base);\n\n\tif (fd->bypass_bit_inverted)\n\t\tv |= FAPLL_MAIN_BP;\n\telse\n\t\tv &= ~FAPLL_MAIN_BP;\n\twritel_relaxed(v, fd->base);\n}\n\nstatic int ti_fapll_wait_lock(struct fapll_data *fd)\n{\n\tint retries = FAPLL_MAX_RETRIES;\n\tu32 v;\n\n\twhile ((v = readl_relaxed(fd->base))) {\n\t\tif (v & FAPLL_MAIN_LOCK)\n\t\t\treturn 0;\n\n\t\tif (retries-- <= 0)\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t}\n\n\tpr_err(\"%s failed to lock\\n\", fd->name);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int ti_fapll_enable(struct clk_hw *hw)\n{\n\tstruct fapll_data *fd = to_fapll(hw);\n\tu32 v = readl_relaxed(fd->base);\n\n\tv |= FAPLL_MAIN_PLLEN;\n\twritel_relaxed(v, fd->base);\n\tti_fapll_wait_lock(fd);\n\n\treturn 0;\n}\n\nstatic void ti_fapll_disable(struct clk_hw *hw)\n{\n\tstruct fapll_data *fd = to_fapll(hw);\n\tu32 v = readl_relaxed(fd->base);\n\n\tv &= ~FAPLL_MAIN_PLLEN;\n\twritel_relaxed(v, fd->base);\n}\n\nstatic int ti_fapll_is_enabled(struct clk_hw *hw)\n{\n\tstruct fapll_data *fd = to_fapll(hw);\n\tu32 v = readl_relaxed(fd->base);\n\n\treturn v & FAPLL_MAIN_PLLEN;\n}\n\nstatic unsigned long ti_fapll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct fapll_data *fd = to_fapll(hw);\n\tu32 fapll_n, fapll_p, v;\n\tu64 rate;\n\n\tif (ti_fapll_clock_is_bypass(fd))\n\t\treturn parent_rate;\n\n\trate = parent_rate;\n\n\t \n\tv = readl_relaxed(fd->base);\n\tfapll_p = (v >> 8) & 0xff;\n\tif (fapll_p)\n\t\tdo_div(rate, fapll_p);\n\tfapll_n = v >> 16;\n\tif (fapll_n)\n\t\trate *= fapll_n;\n\n\treturn rate;\n}\n\nstatic u8 ti_fapll_get_parent(struct clk_hw *hw)\n{\n\tstruct fapll_data *fd = to_fapll(hw);\n\n\tif (ti_fapll_clock_is_bypass(fd))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int ti_fapll_set_div_mult(unsigned long rate,\n\t\t\t\t unsigned long parent_rate,\n\t\t\t\t u32 *pre_div_p, u32 *mult_n)\n{\n\t \n\tif (rate < parent_rate) {\n\t\tpr_warn(\"FAPLL main divider rates unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*mult_n = rate / parent_rate;\n\tif (*mult_n > FAPLL_MAIN_MAX_MULT_N)\n\t\treturn -EINVAL;\n\t*pre_div_p = 1;\n\n\treturn 0;\n}\n\nstatic long ti_fapll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *parent_rate)\n{\n\tu32 pre_div_p, mult_n;\n\tint error;\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\terror = ti_fapll_set_div_mult(rate, *parent_rate,\n\t\t\t\t      &pre_div_p, &mult_n);\n\tif (error)\n\t\treturn error;\n\n\trate = *parent_rate / pre_div_p;\n\trate *= mult_n;\n\n\treturn rate;\n}\n\nstatic int ti_fapll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t     unsigned long parent_rate)\n{\n\tstruct fapll_data *fd = to_fapll(hw);\n\tu32 pre_div_p, mult_n, v;\n\tint error;\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\terror = ti_fapll_set_div_mult(rate, parent_rate,\n\t\t\t\t      &pre_div_p, &mult_n);\n\tif (error)\n\t\treturn error;\n\n\tti_fapll_set_bypass(fd);\n\tv = readl_relaxed(fd->base);\n\tv &= ~FAPLL_MAIN_CLEAR_MASK;\n\tv |= pre_div_p << FAPLL_MAIN_DIV_P_SHIFT;\n\tv |= mult_n << FAPLL_MAIN_MULT_N_SHIFT;\n\twritel_relaxed(v, fd->base);\n\tif (ti_fapll_is_enabled(hw))\n\t\tti_fapll_wait_lock(fd);\n\tti_fapll_clear_bypass(fd);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops ti_fapll_ops = {\n\t.enable = ti_fapll_enable,\n\t.disable = ti_fapll_disable,\n\t.is_enabled = ti_fapll_is_enabled,\n\t.recalc_rate = ti_fapll_recalc_rate,\n\t.get_parent = ti_fapll_get_parent,\n\t.round_rate = ti_fapll_round_rate,\n\t.set_rate = ti_fapll_set_rate,\n};\n\nstatic int ti_fapll_synth_enable(struct clk_hw *hw)\n{\n\tstruct fapll_synth *synth = to_synth(hw);\n\tu32 v = readl_relaxed(synth->fd->base + FAPLL_PWD_OFFSET);\n\n\tv &= ~(1 << synth->index);\n\twritel_relaxed(v, synth->fd->base + FAPLL_PWD_OFFSET);\n\n\treturn 0;\n}\n\nstatic void ti_fapll_synth_disable(struct clk_hw *hw)\n{\n\tstruct fapll_synth *synth = to_synth(hw);\n\tu32 v = readl_relaxed(synth->fd->base + FAPLL_PWD_OFFSET);\n\n\tv |= 1 << synth->index;\n\twritel_relaxed(v, synth->fd->base + FAPLL_PWD_OFFSET);\n}\n\nstatic int ti_fapll_synth_is_enabled(struct clk_hw *hw)\n{\n\tstruct fapll_synth *synth = to_synth(hw);\n\tu32 v = readl_relaxed(synth->fd->base + FAPLL_PWD_OFFSET);\n\n\treturn !(v & (1 << synth->index));\n}\n\n \nstatic unsigned long ti_fapll_synth_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct fapll_synth *synth = to_synth(hw);\n\tu32 synth_div_m;\n\tu64 rate;\n\n\t \n\tif (!synth->div)\n\t\treturn 32768;\n\n\t \n\tif (ti_fapll_clock_is_bypass(synth->fd))\n\t\treturn parent_rate;\n\n\trate = parent_rate;\n\n\t \n\tif (synth->freq) {\n\t\tu32 v, synth_int_div, synth_frac_div, synth_div_freq;\n\n\t\tv = readl_relaxed(synth->freq);\n\t\tsynth_int_div = (v >> 24) & 0xf;\n\t\tsynth_frac_div = v & 0xffffff;\n\t\tsynth_div_freq = (synth_int_div * 10000000) + synth_frac_div;\n\t\trate *= 10000000;\n\t\tdo_div(rate, synth_div_freq);\n\t\trate *= SYNTH_PHASE_K;\n\t}\n\n\t \n\tsynth_div_m = readl_relaxed(synth->div) & SYNTH_MAX_DIV_M;\n\n\treturn DIV_ROUND_UP_ULL(rate, synth_div_m);\n}\n\nstatic unsigned long ti_fapll_synth_get_frac_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct fapll_synth *synth = to_synth(hw);\n\tunsigned long current_rate, frac_rate;\n\tu32 post_div_m;\n\n\tcurrent_rate = ti_fapll_synth_recalc_rate(hw, parent_rate);\n\tpost_div_m = readl_relaxed(synth->div) & SYNTH_MAX_DIV_M;\n\tfrac_rate = current_rate * post_div_m;\n\n\treturn frac_rate;\n}\n\nstatic u32 ti_fapll_synth_set_frac_rate(struct fapll_synth *synth,\n\t\t\t\t\tunsigned long rate,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tu32 post_div_m, synth_int_div = 0, synth_frac_div = 0, v;\n\n\tpost_div_m = DIV_ROUND_UP_ULL((u64)parent_rate * SYNTH_PHASE_K, rate);\n\tpost_div_m = post_div_m / SYNTH_MAX_INT_DIV;\n\tif (post_div_m > SYNTH_MAX_DIV_M)\n\t\treturn -EINVAL;\n\tif (!post_div_m)\n\t\tpost_div_m = 1;\n\n\tfor (; post_div_m < SYNTH_MAX_DIV_M; post_div_m++) {\n\t\tsynth_int_div = DIV_ROUND_UP_ULL((u64)parent_rate *\n\t\t\t\t\t\t SYNTH_PHASE_K *\n\t\t\t\t\t\t 10000000,\n\t\t\t\t\t\t rate * post_div_m);\n\t\tsynth_frac_div = synth_int_div % 10000000;\n\t\tsynth_int_div /= 10000000;\n\n\t\tif (synth_int_div <= SYNTH_MAX_INT_DIV)\n\t\t\tbreak;\n\t}\n\n\tif (synth_int_div > SYNTH_MAX_INT_DIV)\n\t\treturn -EINVAL;\n\n\tv = readl_relaxed(synth->freq);\n\tv &= ~0x1fffffff;\n\tv |= (synth_int_div & SYNTH_MAX_INT_DIV) << 24;\n\tv |= (synth_frac_div & 0xffffff);\n\tv |= SYNTH_LDFREQ;\n\twritel_relaxed(v, synth->freq);\n\n\treturn post_div_m;\n}\n\nstatic long ti_fapll_synth_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long *parent_rate)\n{\n\tstruct fapll_synth *synth = to_synth(hw);\n\tstruct fapll_data *fd = synth->fd;\n\tunsigned long r;\n\n\tif (ti_fapll_clock_is_bypass(fd) || !synth->div || !rate)\n\t\treturn -EINVAL;\n\n\t \n\tif (!synth->freq) {\n\t\tunsigned long frac_rate;\n\t\tu32 synth_post_div_m;\n\n\t\tfrac_rate = ti_fapll_synth_get_frac_rate(hw, *parent_rate);\n\t\tsynth_post_div_m = DIV_ROUND_UP(frac_rate, rate);\n\t\tr = DIV_ROUND_UP(frac_rate, synth_post_div_m);\n\t\tgoto out;\n\t}\n\n\tr = *parent_rate * SYNTH_PHASE_K;\n\tif (rate > r)\n\t\tgoto out;\n\n\tr = DIV_ROUND_UP_ULL(r, SYNTH_MAX_INT_DIV * SYNTH_MAX_DIV_M);\n\tif (rate < r)\n\t\tgoto out;\n\n\tr = rate;\nout:\n\treturn r;\n}\n\nstatic int ti_fapll_synth_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct fapll_synth *synth = to_synth(hw);\n\tstruct fapll_data *fd = synth->fd;\n\tunsigned long frac_rate, post_rate = 0;\n\tu32 post_div_m = 0, v;\n\n\tif (ti_fapll_clock_is_bypass(fd) || !synth->div || !rate)\n\t\treturn -EINVAL;\n\n\t \n\tfrac_rate = ti_fapll_synth_get_frac_rate(hw, parent_rate);\n\tif (frac_rate < rate) {\n\t\tif (!synth->freq)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tpost_div_m = DIV_ROUND_UP(frac_rate, rate);\n\t\tif (post_div_m && (post_div_m <= SYNTH_MAX_DIV_M))\n\t\t\tpost_rate = DIV_ROUND_UP(frac_rate, post_div_m);\n\t\tif (!synth->freq && !post_rate)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((post_rate != rate) && synth->freq)\n\t\tpost_div_m = ti_fapll_synth_set_frac_rate(synth,\n\t\t\t\t\t\t\t  rate,\n\t\t\t\t\t\t\t  parent_rate);\n\n\tv = readl_relaxed(synth->div);\n\tv &= ~SYNTH_MAX_DIV_M;\n\tv |= post_div_m;\n\tv |= SYNTH_LDMDIV1;\n\twritel_relaxed(v, synth->div);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops ti_fapll_synt_ops = {\n\t.enable = ti_fapll_synth_enable,\n\t.disable = ti_fapll_synth_disable,\n\t.is_enabled = ti_fapll_synth_is_enabled,\n\t.recalc_rate = ti_fapll_synth_recalc_rate,\n\t.round_rate = ti_fapll_synth_round_rate,\n\t.set_rate = ti_fapll_synth_set_rate,\n};\n\nstatic struct clk * __init ti_fapll_synth_setup(struct fapll_data *fd,\n\t\t\t\t\t\tvoid __iomem *freq,\n\t\t\t\t\t\tvoid __iomem *div,\n\t\t\t\t\t\tint index,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tconst char *parent,\n\t\t\t\t\t\tstruct clk *pll_clk)\n{\n\tstruct clk_init_data *init;\n\tstruct fapll_synth *synth;\n\tstruct clk *clk = ERR_PTR(-ENOMEM);\n\n\tinit = kzalloc(sizeof(*init), GFP_KERNEL);\n\tif (!init)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit->ops = &ti_fapll_synt_ops;\n\tinit->name = name;\n\tinit->parent_names = &parent;\n\tinit->num_parents = 1;\n\n\tsynth = kzalloc(sizeof(*synth), GFP_KERNEL);\n\tif (!synth)\n\t\tgoto free;\n\n\tsynth->fd = fd;\n\tsynth->index = index;\n\tsynth->freq = freq;\n\tsynth->div = div;\n\tsynth->name = name;\n\tsynth->hw.init = init;\n\tsynth->clk_pll = pll_clk;\n\n\tclk = clk_register(NULL, &synth->hw);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"failed to register clock\\n\");\n\t\tgoto free;\n\t}\n\n\treturn clk;\n\nfree:\n\tkfree(synth);\n\tkfree(init);\n\n\treturn clk;\n}\n\nstatic void __init ti_fapll_setup(struct device_node *node)\n{\n\tstruct fapll_data *fd;\n\tstruct clk_init_data *init = NULL;\n\tconst char *parent_name[2];\n\tstruct clk *pll_clk;\n\tconst char *name;\n\tint i;\n\n\tfd = kzalloc(sizeof(*fd), GFP_KERNEL);\n\tif (!fd)\n\t\treturn;\n\n\tfd->outputs.clks = kzalloc(sizeof(struct clk *) *\n\t\t\t\t   MAX_FAPLL_OUTPUTS + 1,\n\t\t\t\t   GFP_KERNEL);\n\tif (!fd->outputs.clks)\n\t\tgoto free;\n\n\tinit = kzalloc(sizeof(*init), GFP_KERNEL);\n\tif (!init)\n\t\tgoto free;\n\n\tinit->ops = &ti_fapll_ops;\n\tname = ti_dt_clk_name(node);\n\tinit->name = name;\n\n\tinit->num_parents = of_clk_get_parent_count(node);\n\tif (init->num_parents != 2) {\n\t\tpr_err(\"%pOFn must have two parents\\n\", node);\n\t\tgoto free;\n\t}\n\n\tof_clk_parent_fill(node, parent_name, 2);\n\tinit->parent_names = parent_name;\n\n\tfd->clk_ref = of_clk_get(node, 0);\n\tif (IS_ERR(fd->clk_ref)) {\n\t\tpr_err(\"%pOFn could not get clk_ref\\n\", node);\n\t\tgoto free;\n\t}\n\n\tfd->clk_bypass = of_clk_get(node, 1);\n\tif (IS_ERR(fd->clk_bypass)) {\n\t\tpr_err(\"%pOFn could not get clk_bypass\\n\", node);\n\t\tgoto free;\n\t}\n\n\tfd->base = of_iomap(node, 0);\n\tif (!fd->base) {\n\t\tpr_err(\"%pOFn could not get IO base\\n\", node);\n\t\tgoto free;\n\t}\n\n\tif (fapll_is_ddr_pll(fd->base))\n\t\tfd->bypass_bit_inverted = true;\n\n\tfd->name = name;\n\tfd->hw.init = init;\n\n\t \n\tpll_clk = clk_register(NULL, &fd->hw);\n\tif (IS_ERR(pll_clk))\n\t\tgoto unmap;\n\n\tfd->outputs.clks[0] = pll_clk;\n\tfd->outputs.clk_num++;\n\n\t \n\tfor (i = 0; i < MAX_FAPLL_OUTPUTS; i++) {\n\t\tconst char *output_name;\n\t\tvoid __iomem *freq, *div;\n\t\tstruct clk *synth_clk;\n\t\tint output_instance;\n\t\tu32 v;\n\n\t\tif (of_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t\t  i, &output_name))\n\t\t\tcontinue;\n\n\t\tif (of_property_read_u32_index(node, \"clock-indices\", i,\n\t\t\t\t\t       &output_instance))\n\t\t\toutput_instance = i;\n\n\t\tfreq = fd->base + (output_instance * 8);\n\t\tdiv = freq + 4;\n\n\t\t \n\t\tif (is_audio_pll_clk1(freq)) {\n\t\t\tfreq = NULL;\n\t\t\tdiv = NULL;\n\t\t} else {\n\t\t\t \n\t\t\tv = readl_relaxed(freq);\n\t\t\tif (!v)\n\t\t\t\tfreq = NULL;\n\t\t}\n\t\tsynth_clk = ti_fapll_synth_setup(fd, freq, div, output_instance,\n\t\t\t\t\t\t output_name, name, pll_clk);\n\t\tif (IS_ERR(synth_clk))\n\t\t\tcontinue;\n\n\t\tfd->outputs.clks[output_instance] = synth_clk;\n\t\tfd->outputs.clk_num++;\n\n\t\tclk_register_clkdev(synth_clk, output_name, NULL);\n\t}\n\n\t \n\tof_clk_add_provider(node, of_clk_src_onecell_get, &fd->outputs);\n\t \n\n\tkfree(init);\n\n\treturn;\n\nunmap:\n\tiounmap(fd->base);\nfree:\n\tif (fd->clk_bypass)\n\t\tclk_put(fd->clk_bypass);\n\tif (fd->clk_ref)\n\t\tclk_put(fd->clk_ref);\n\tkfree(fd->outputs.clks);\n\tkfree(fd);\n\tkfree(init);\n}\n\nCLK_OF_DECLARE(ti_fapll_clock, \"ti,dm816-fapll-clock\", ti_fapll_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}