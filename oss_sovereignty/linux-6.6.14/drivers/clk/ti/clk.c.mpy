{
  "module_name": "clk.c",
  "hash_id": "e807d8667298f4485591e8fdcac6d48b5a9a8c218ef4be914d4d1775504f1aa5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/clk.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/ti.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/list.h>\n#include <linux/regmap.h>\n#include <linux/string_helpers.h>\n#include <linux/memblock.h>\n#include <linux/device.h>\n\n#include \"clock.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\nstatic LIST_HEAD(clk_hw_omap_clocks);\nstruct ti_clk_ll_ops *ti_clk_ll_ops;\nstatic struct device_node *clocks_node_ptr[CLK_MAX_MEMMAPS];\n\nstruct ti_clk_features ti_clk_features;\n\nstruct clk_iomap {\n\tstruct regmap *regmap;\n\tvoid __iomem *mem;\n};\n\nstatic struct clk_iomap *clk_memmaps[CLK_MAX_MEMMAPS];\n\nstatic void clk_memmap_writel(u32 val, const struct clk_omap_reg *reg)\n{\n\tstruct clk_iomap *io = clk_memmaps[reg->index];\n\n\tif (reg->ptr)\n\t\twritel_relaxed(val, reg->ptr);\n\telse if (io->regmap)\n\t\tregmap_write(io->regmap, reg->offset, val);\n\telse\n\t\twritel_relaxed(val, io->mem + reg->offset);\n}\n\nstatic void _clk_rmw(u32 val, u32 mask, void __iomem *ptr)\n{\n\tu32 v;\n\n\tv = readl_relaxed(ptr);\n\tv &= ~mask;\n\tv |= val;\n\twritel_relaxed(v, ptr);\n}\n\nstatic void clk_memmap_rmw(u32 val, u32 mask, const struct clk_omap_reg *reg)\n{\n\tstruct clk_iomap *io = clk_memmaps[reg->index];\n\n\tif (reg->ptr) {\n\t\t_clk_rmw(val, mask, reg->ptr);\n\t} else if (io->regmap) {\n\t\tregmap_update_bits(io->regmap, reg->offset, mask, val);\n\t} else {\n\t\t_clk_rmw(val, mask, io->mem + reg->offset);\n\t}\n}\n\nstatic u32 clk_memmap_readl(const struct clk_omap_reg *reg)\n{\n\tu32 val;\n\tstruct clk_iomap *io = clk_memmaps[reg->index];\n\n\tif (reg->ptr)\n\t\tval = readl_relaxed(reg->ptr);\n\telse if (io->regmap)\n\t\tregmap_read(io->regmap, reg->offset, &val);\n\telse\n\t\tval = readl_relaxed(io->mem + reg->offset);\n\n\treturn val;\n}\n\n \nint ti_clk_setup_ll_ops(struct ti_clk_ll_ops *ops)\n{\n\tif (ti_clk_ll_ops) {\n\t\tpr_err(\"Attempt to register ll_ops multiple times.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tti_clk_ll_ops = ops;\n\tops->clk_readl = clk_memmap_readl;\n\tops->clk_writel = clk_memmap_writel;\n\tops->clk_rmw = clk_memmap_rmw;\n\n\treturn 0;\n}\n\n \nstatic struct device_node *ti_find_clock_provider(struct device_node *from,\n\t\t\t\t\t\t  const char *name)\n{\n\tstruct device_node *np;\n\tbool found = false;\n\tconst char *n;\n\tchar *tmp;\n\n\ttmp = kstrdup_and_replace(name, '-', '_', GFP_KERNEL);\n\tif (!tmp)\n\t\treturn NULL;\n\n\t \n\tfor_each_of_allnodes_from(from, np) {\n\t\tif (of_property_read_string_index(np, \"clock-output-names\",\n\t\t\t\t\t\t  0, &n))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(n, tmp, strlen(tmp))) {\n\t\t\tof_node_get(np);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(tmp);\n\n\tif (found) {\n\t\tof_node_put(from);\n\t\treturn np;\n\t}\n\n\t \n\treturn of_find_node_by_name(from, name);\n}\n\n \nvoid __init ti_dt_clocks_register(struct ti_dt_clk oclks[])\n{\n\tstruct ti_dt_clk *c;\n\tstruct device_node *node, *parent, *child;\n\tstruct clk *clk;\n\tstruct of_phandle_args clkspec;\n\tchar buf[64];\n\tchar *ptr;\n\tchar *tags[2];\n\tint i;\n\tint num_args;\n\tint ret;\n\tstatic bool clkctrl_nodes_missing;\n\tstatic bool has_clkctrl_data;\n\tstatic bool compat_mode;\n\n\tcompat_mode = ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT;\n\n\tfor (c = oclks; c->node_name != NULL; c++) {\n\t\tstrcpy(buf, c->node_name);\n\t\tptr = buf;\n\t\tfor (i = 0; i < 2; i++)\n\t\t\ttags[i] = NULL;\n\t\tnum_args = 0;\n\t\twhile (*ptr) {\n\t\t\tif (*ptr == ':') {\n\t\t\t\tif (num_args >= 2) {\n\t\t\t\t\tpr_warn(\"Bad number of tags on %s\\n\",\n\t\t\t\t\t\tc->node_name);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttags[num_args++] = ptr + 1;\n\t\t\t\t*ptr = 0;\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\n\t\tif (num_args && clkctrl_nodes_missing)\n\t\t\tcontinue;\n\n\t\tnode = ti_find_clock_provider(NULL, buf);\n\t\tif (num_args && compat_mode) {\n\t\t\tparent = node;\n\t\t\tchild = of_get_child_by_name(parent, \"clock\");\n\t\t\tif (!child)\n\t\t\t\tchild = of_get_child_by_name(parent, \"clk\");\n\t\t\tif (child) {\n\t\t\t\tof_node_put(parent);\n\t\t\t\tnode = child;\n\t\t\t}\n\t\t}\n\n\t\tclkspec.np = node;\n\t\tclkspec.args_count = num_args;\n\t\tfor (i = 0; i < num_args; i++) {\n\t\t\tret = kstrtoint(tags[i], i ? 10 : 16, clkspec.args + i);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"Bad tag in %s at %d: %s\\n\",\n\t\t\t\t\tc->node_name, i, tags[i]);\n\t\t\t\tof_node_put(node);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tclk = of_clk_get_from_provider(&clkspec);\n\t\tof_node_put(node);\n\t\tif (!IS_ERR(clk)) {\n\t\t\tc->lk.clk = clk;\n\t\t\tclkdev_add(&c->lk);\n\t\t} else {\n\t\t\tif (num_args && !has_clkctrl_data) {\n\t\t\t\tstruct device_node *np;\n\n\t\t\t\tnp = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t\t\t     \"ti,clkctrl\");\n\t\t\t\tif (np) {\n\t\t\t\t\thas_clkctrl_data = true;\n\t\t\t\t\tof_node_put(np);\n\t\t\t\t} else {\n\t\t\t\t\tclkctrl_nodes_missing = true;\n\n\t\t\t\t\tpr_warn(\"missing clkctrl nodes, please update your dts.\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpr_warn(\"failed to lookup clock node %s, ret=%ld\\n\",\n\t\t\t\tc->node_name, PTR_ERR(clk));\n\t\t}\n\t}\n}\n\nstruct clk_init_item {\n\tstruct device_node *node;\n\tvoid *user;\n\tti_of_clk_init_cb_t func;\n\tstruct list_head link;\n};\n\nstatic LIST_HEAD(retry_list);\n\n \nint __init ti_clk_retry_init(struct device_node *node, void *user,\n\t\t\t     ti_of_clk_init_cb_t func)\n{\n\tstruct clk_init_item *retry;\n\n\tpr_debug(\"%pOFn: adding to retry list...\\n\", node);\n\tretry = kzalloc(sizeof(*retry), GFP_KERNEL);\n\tif (!retry)\n\t\treturn -ENOMEM;\n\n\tretry->node = node;\n\tretry->func = func;\n\tretry->user = user;\n\tlist_add(&retry->link, &retry_list);\n\n\treturn 0;\n}\n\n \nint ti_clk_get_reg_addr(struct device_node *node, int index,\n\t\t\tstruct clk_omap_reg *reg)\n{\n\tu32 val;\n\tint i;\n\n\tfor (i = 0; i < CLK_MAX_MEMMAPS; i++) {\n\t\tif (clocks_node_ptr[i] == node->parent)\n\t\t\tbreak;\n\t\tif (clocks_node_ptr[i] == node->parent->parent)\n\t\t\tbreak;\n\t}\n\n\tif (i == CLK_MAX_MEMMAPS) {\n\t\tpr_err(\"clk-provider not found for %pOFn!\\n\", node);\n\t\treturn -ENOENT;\n\t}\n\n\treg->index = i;\n\n\tif (of_property_read_u32_index(node, \"reg\", index, &val)) {\n\t\tif (of_property_read_u32_index(node->parent, \"reg\",\n\t\t\t\t\t       index, &val)) {\n\t\t\tpr_err(\"%pOFn or parent must have reg[%d]!\\n\",\n\t\t\t       node, index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treg->offset = val;\n\treg->ptr = NULL;\n\n\treturn 0;\n}\n\nvoid ti_clk_latch(struct clk_omap_reg *reg, s8 shift)\n{\n\tu32 latch;\n\n\tif (shift < 0)\n\t\treturn;\n\n\tlatch = 1 << shift;\n\n\tti_clk_ll_ops->clk_rmw(latch, latch, reg);\n\tti_clk_ll_ops->clk_rmw(0, latch, reg);\n\tti_clk_ll_ops->clk_readl(reg);  \n}\n\n \nint __init omap2_clk_provider_init(struct device_node *parent, int index,\n\t\t\t\t   struct regmap *syscon, void __iomem *mem)\n{\n\tstruct device_node *clocks;\n\tstruct clk_iomap *io;\n\n\t \n\tclocks = of_get_child_by_name(parent, \"clocks\");\n\tif (!clocks) {\n\t\tpr_err(\"%pOFn missing 'clocks' child node.\\n\", parent);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tclocks_node_ptr[index] = clocks;\n\n\tio = kzalloc(sizeof(*io), GFP_KERNEL);\n\tif (!io)\n\t\treturn -ENOMEM;\n\n\tio->regmap = syscon;\n\tio->mem = mem;\n\n\tclk_memmaps[index] = io;\n\n\treturn 0;\n}\n\n \nvoid __init omap2_clk_legacy_provider_init(int index, void __iomem *mem)\n{\n\tstruct clk_iomap *io;\n\n\tio = memblock_alloc(sizeof(*io), SMP_CACHE_BYTES);\n\tif (!io)\n\t\tpanic(\"%s: Failed to allocate %zu bytes\\n\", __func__,\n\t\t      sizeof(*io));\n\n\tio->mem = mem;\n\n\tclk_memmaps[index] = io;\n}\n\n \nvoid ti_dt_clk_init_retry_clks(void)\n{\n\tstruct clk_init_item *retry;\n\tstruct clk_init_item *tmp;\n\tint retries = 5;\n\n\twhile (!list_empty(&retry_list) && retries) {\n\t\tlist_for_each_entry_safe(retry, tmp, &retry_list, link) {\n\t\t\tpr_debug(\"retry-init: %pOFn\\n\", retry->node);\n\t\t\tretry->func(retry->user, retry->node);\n\t\t\tlist_del(&retry->link);\n\t\t\tkfree(retry);\n\t\t}\n\t\tretries--;\n\t}\n}\n\nstatic const struct of_device_id simple_clk_match_table[] __initconst = {\n\t{ .compatible = \"fixed-clock\" },\n\t{ .compatible = \"fixed-factor-clock\" },\n\t{ }\n};\n\n \nconst char *ti_dt_clk_name(struct device_node *np)\n{\n\tconst char *name;\n\n\tif (!of_property_read_string_index(np, \"clock-output-names\", 0,\n\t\t\t\t\t   &name))\n\t\treturn name;\n\n\treturn np->name;\n}\n\n \nvoid __init ti_clk_add_aliases(void)\n{\n\tstruct device_node *np;\n\tstruct clk *clk;\n\n\tfor_each_matching_node(np, simple_clk_match_table) {\n\t\tstruct of_phandle_args clkspec;\n\n\t\tclkspec.np = np;\n\t\tclk = of_clk_get_from_provider(&clkspec);\n\n\t\tti_clk_add_alias(clk, ti_dt_clk_name(np));\n\t}\n}\n\n \nvoid __init ti_clk_setup_features(struct ti_clk_features *features)\n{\n\tmemcpy(&ti_clk_features, features, sizeof(*features));\n}\n\n \nconst struct ti_clk_features *ti_clk_get_features(void)\n{\n\treturn &ti_clk_features;\n}\n\n \nvoid omap2_clk_enable_init_clocks(const char **clk_names, u8 num_clocks)\n{\n\tstruct clk *init_clk;\n\tint i;\n\n\tfor (i = 0; i < num_clocks; i++) {\n\t\tinit_clk = clk_get(NULL, clk_names[i]);\n\t\tif (WARN(IS_ERR(init_clk), \"could not find init clock %s\\n\",\n\t\t\t clk_names[i]))\n\t\t\tcontinue;\n\t\tclk_prepare_enable(init_clk);\n\t}\n}\n\n \nint ti_clk_add_alias(struct clk *clk, const char *con)\n{\n\tstruct clk_lookup *cl;\n\n\tif (!clk)\n\t\treturn 0;\n\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tcl = kzalloc(sizeof(*cl), GFP_KERNEL);\n\tif (!cl)\n\t\treturn -ENOMEM;\n\n\tcl->con_id = con;\n\tcl->clk = clk;\n\n\tclkdev_add(cl);\n\n\treturn 0;\n}\n\n \nstruct clk *of_ti_clk_register(struct device_node *node, struct clk_hw *hw,\n\t\t\t       const char *con)\n{\n\tstruct clk *clk;\n\tint ret;\n\n\tret = of_clk_hw_register(node, hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tclk = hw->clk;\n\tret = ti_clk_add_alias(clk, con);\n\tif (ret) {\n\t\tclk_unregister(clk);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn clk;\n}\n\n \nstruct clk *of_ti_clk_register_omap_hw(struct device_node *node,\n\t\t\t\t       struct clk_hw *hw, const char *con)\n{\n\tstruct clk *clk;\n\tstruct clk_hw_omap *oclk;\n\n\tclk = of_ti_clk_register(node, hw, con);\n\tif (IS_ERR(clk))\n\t\treturn clk;\n\n\toclk = to_clk_hw_omap(hw);\n\n\tlist_add(&oclk->node, &clk_hw_omap_clocks);\n\n\treturn clk;\n}\n\n \nint omap2_clk_for_each(int (*fn)(struct clk_hw_omap *hw))\n{\n\tint ret;\n\tstruct clk_hw_omap *hw;\n\n\tlist_for_each_entry(hw, &clk_hw_omap_clocks, node) {\n\t\tret = (*fn)(hw);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nbool omap2_clk_is_hw_omap(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *oclk;\n\n\tlist_for_each_entry(oclk, &clk_hw_omap_clocks, node) {\n\t\tif (&oclk->hw == hw)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}