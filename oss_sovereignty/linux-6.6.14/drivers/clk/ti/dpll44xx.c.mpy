{
  "module_name": "dpll44xx.c",
  "hash_id": "f9ae4927963566f343d498ce11ea8634610509da0d62d55b42561fe2b9f92b59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/dpll44xx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/bitops.h>\n#include <linux/clk/ti.h>\n\n#include \"clock.h\"\n\n \n#define OMAP4_DPLL_LP_FINT_MAX\t1000000\n#define OMAP4_DPLL_LP_FOUT_MAX\t100000000\n\n \n#define OMAP4430_DPLL_CLKOUT_GATE_CTRL_MASK\t\tBIT(8)\n#define OMAP4430_DPLL_CLKOUTX2_GATE_CTRL_MASK\t\tBIT(10)\n#define OMAP4430_DPLL_REGM4XEN_MASK\t\t\tBIT(11)\n\n \n#define OMAP4430_REGM4XEN_MULT\t\t\t\t4\n\nstatic void omap4_dpllmx_allow_gatectrl(struct clk_hw_omap *clk)\n{\n\tu32 v;\n\tu32 mask;\n\n\tif (!clk)\n\t\treturn;\n\n\tmask = clk->flags & CLOCK_CLKOUTX2 ?\n\t\t\tOMAP4430_DPLL_CLKOUTX2_GATE_CTRL_MASK :\n\t\t\tOMAP4430_DPLL_CLKOUT_GATE_CTRL_MASK;\n\n\tv = ti_clk_ll_ops->clk_readl(&clk->clksel_reg);\n\t \n\tv &= ~mask;\n\tti_clk_ll_ops->clk_writel(v, &clk->clksel_reg);\n}\n\nstatic void omap4_dpllmx_deny_gatectrl(struct clk_hw_omap *clk)\n{\n\tu32 v;\n\tu32 mask;\n\n\tif (!clk)\n\t\treturn;\n\n\tmask = clk->flags & CLOCK_CLKOUTX2 ?\n\t\t\tOMAP4430_DPLL_CLKOUTX2_GATE_CTRL_MASK :\n\t\t\tOMAP4430_DPLL_CLKOUT_GATE_CTRL_MASK;\n\n\tv = ti_clk_ll_ops->clk_readl(&clk->clksel_reg);\n\t \n\tv |= mask;\n\tti_clk_ll_ops->clk_writel(v, &clk->clksel_reg);\n}\n\nconst struct clk_hw_omap_ops clkhwops_omap4_dpllmx = {\n\t.allow_idle\t= omap4_dpllmx_allow_gatectrl,\n\t.deny_idle      = omap4_dpllmx_deny_gatectrl,\n};\n\n \nstatic void omap4_dpll_lpmode_recalc(struct dpll_data *dd)\n{\n\tlong fint, fout;\n\n\tfint = clk_hw_get_rate(dd->clk_ref) / (dd->last_rounded_n + 1);\n\tfout = fint * dd->last_rounded_m;\n\n\tif ((fint < OMAP4_DPLL_LP_FINT_MAX) && (fout < OMAP4_DPLL_LP_FOUT_MAX))\n\t\tdd->last_rounded_lpmode = 1;\n\telse\n\t\tdd->last_rounded_lpmode = 0;\n}\n\n \nunsigned long omap4_dpll_regm4xen_recalc(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tu32 v;\n\tunsigned long rate;\n\tstruct dpll_data *dd;\n\n\tif (!clk || !clk->dpll_data)\n\t\treturn 0;\n\n\tdd = clk->dpll_data;\n\n\trate = omap2_get_dpll_rate(clk);\n\n\t \n\tv = ti_clk_ll_ops->clk_readl(&dd->control_reg);\n\tif (v & OMAP4430_DPLL_REGM4XEN_MASK)\n\t\trate *= OMAP4430_REGM4XEN_MULT;\n\n\treturn rate;\n}\n\n \nlong omap4_dpll_regm4xen_round_rate(struct clk_hw *hw,\n\t\t\t\t    unsigned long target_rate,\n\t\t\t\t    unsigned long *parent_rate)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tstruct dpll_data *dd;\n\tlong r;\n\n\tif (!clk || !clk->dpll_data)\n\t\treturn -EINVAL;\n\n\tdd = clk->dpll_data;\n\n\tdd->last_rounded_m4xen = 0;\n\n\t \n\tr = omap2_dpll_round_rate(hw, target_rate, NULL);\n\tif (r != ~0)\n\t\tgoto out;\n\n\t \n\tr = omap2_dpll_round_rate(hw, target_rate / OMAP4430_REGM4XEN_MULT,\n\t\t\t\t  NULL);\n\tif (r == ~0)\n\t\treturn r;\n\n\tdd->last_rounded_rate *= OMAP4430_REGM4XEN_MULT;\n\tdd->last_rounded_m4xen = 1;\n\nout:\n\tomap4_dpll_lpmode_recalc(dd);\n\n\treturn dd->last_rounded_rate;\n}\n\n \nint omap4_dpll_regm4xen_determine_rate(struct clk_hw *hw,\n\t\t\t\t       struct clk_rate_request *req)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tstruct dpll_data *dd;\n\n\tif (!req->rate)\n\t\treturn -EINVAL;\n\n\tdd = clk->dpll_data;\n\tif (!dd)\n\t\treturn -EINVAL;\n\n\tif (clk_hw_get_rate(dd->clk_bypass) == req->rate &&\n\t    (dd->modes & (1 << DPLL_LOW_POWER_BYPASS))) {\n\t\treq->best_parent_hw = dd->clk_bypass;\n\t} else {\n\t\treq->rate = omap4_dpll_regm4xen_round_rate(hw, req->rate,\n\t\t\t\t\t\t&req->best_parent_rate);\n\t\treq->best_parent_hw = dd->clk_ref;\n\t}\n\n\treq->best_parent_rate = req->rate;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}