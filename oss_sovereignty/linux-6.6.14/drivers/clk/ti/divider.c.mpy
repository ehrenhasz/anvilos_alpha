{
  "module_name": "divider.c",
  "hash_id": "08a74c5264e37ca9cdae6f6bbd86d781b39f495234fdfa069e41a7561c300a5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/divider.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/clk/ti.h>\n#include \"clock.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\nstatic unsigned int _get_table_div(const struct clk_div_table *table,\n\t\t\t\t   unsigned int val)\n{\n\tconst struct clk_div_table *clkt;\n\n\tfor (clkt = table; clkt->div; clkt++)\n\t\tif (clkt->val == val)\n\t\t\treturn clkt->div;\n\treturn 0;\n}\n\nstatic void _setup_mask(struct clk_omap_divider *divider)\n{\n\tu16 mask;\n\tu32 max_val;\n\tconst struct clk_div_table *clkt;\n\n\tif (divider->table) {\n\t\tmax_val = 0;\n\n\t\tfor (clkt = divider->table; clkt->div; clkt++)\n\t\t\tif (clkt->val > max_val)\n\t\t\t\tmax_val = clkt->val;\n\t} else {\n\t\tmax_val = divider->max;\n\n\t\tif (!(divider->flags & CLK_DIVIDER_ONE_BASED) &&\n\t\t    !(divider->flags & CLK_DIVIDER_POWER_OF_TWO))\n\t\t\tmax_val--;\n\t}\n\n\tif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\tmask = fls(max_val) - 1;\n\telse\n\t\tmask = max_val;\n\n\tdivider->mask = (1 << fls(mask)) - 1;\n}\n\nstatic unsigned int _get_div(struct clk_omap_divider *divider, unsigned int val)\n{\n\tif (divider->flags & CLK_DIVIDER_ONE_BASED)\n\t\treturn val;\n\tif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\treturn 1 << val;\n\tif (divider->table)\n\t\treturn _get_table_div(divider->table, val);\n\treturn val + 1;\n}\n\nstatic unsigned int _get_table_val(const struct clk_div_table *table,\n\t\t\t\t   unsigned int div)\n{\n\tconst struct clk_div_table *clkt;\n\n\tfor (clkt = table; clkt->div; clkt++)\n\t\tif (clkt->div == div)\n\t\t\treturn clkt->val;\n\treturn 0;\n}\n\nstatic unsigned int _get_val(struct clk_omap_divider *divider, u8 div)\n{\n\tif (divider->flags & CLK_DIVIDER_ONE_BASED)\n\t\treturn div;\n\tif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\treturn __ffs(div);\n\tif (divider->table)\n\t\treturn  _get_table_val(divider->table, div);\n\treturn div - 1;\n}\n\nstatic unsigned long ti_clk_divider_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_omap_divider *divider = to_clk_omap_divider(hw);\n\tunsigned int div, val;\n\n\tval = ti_clk_ll_ops->clk_readl(&divider->reg) >> divider->shift;\n\tval &= divider->mask;\n\n\tdiv = _get_div(divider, val);\n\tif (!div) {\n\t\tWARN(!(divider->flags & CLK_DIVIDER_ALLOW_ZERO),\n\t\t     \"%s: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set\\n\",\n\t\t     clk_hw_get_name(hw));\n\t\treturn parent_rate;\n\t}\n\n\treturn DIV_ROUND_UP(parent_rate, div);\n}\n\n \n#define MULT_ROUND_UP(r, m) ((r) * (m) + (m) - 1)\n\nstatic bool _is_valid_table_div(const struct clk_div_table *table,\n\t\t\t\tunsigned int div)\n{\n\tconst struct clk_div_table *clkt;\n\n\tfor (clkt = table; clkt->div; clkt++)\n\t\tif (clkt->div == div)\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic bool _is_valid_div(struct clk_omap_divider *divider, unsigned int div)\n{\n\tif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\treturn is_power_of_2(div);\n\tif (divider->table)\n\t\treturn _is_valid_table_div(divider->table, div);\n\treturn true;\n}\n\nstatic int _div_round_up(const struct clk_div_table *table,\n\t\t\t unsigned long parent_rate, unsigned long rate)\n{\n\tconst struct clk_div_table *clkt;\n\tint up = INT_MAX;\n\tint div = DIV_ROUND_UP_ULL((u64)parent_rate, rate);\n\n\tfor (clkt = table; clkt->div; clkt++) {\n\t\tif (clkt->div == div)\n\t\t\treturn clkt->div;\n\t\telse if (clkt->div < div)\n\t\t\tcontinue;\n\n\t\tif ((clkt->div - div) < (up - div))\n\t\t\tup = clkt->div;\n\t}\n\n\treturn up;\n}\n\nstatic int _div_round(const struct clk_div_table *table,\n\t\t      unsigned long parent_rate, unsigned long rate)\n{\n\tif (!table)\n\t\treturn DIV_ROUND_UP(parent_rate, rate);\n\n\treturn _div_round_up(table, parent_rate, rate);\n}\n\nstatic int ti_clk_divider_bestdiv(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long *best_parent_rate)\n{\n\tstruct clk_omap_divider *divider = to_clk_omap_divider(hw);\n\tint i, bestdiv = 0;\n\tunsigned long parent_rate, best = 0, now, maxdiv;\n\tunsigned long parent_rate_saved = *best_parent_rate;\n\n\tif (!rate)\n\t\trate = 1;\n\n\tmaxdiv = divider->max;\n\n\tif (!(clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)) {\n\t\tparent_rate = *best_parent_rate;\n\t\tbestdiv = _div_round(divider->table, parent_rate, rate);\n\t\tbestdiv = bestdiv == 0 ? 1 : bestdiv;\n\t\tbestdiv = bestdiv > maxdiv ? maxdiv : bestdiv;\n\t\treturn bestdiv;\n\t}\n\n\t \n\tmaxdiv = min(ULONG_MAX / rate, maxdiv);\n\n\tfor (i = 1; i <= maxdiv; i++) {\n\t\tif (!_is_valid_div(divider, i))\n\t\t\tcontinue;\n\t\tif (rate * i == parent_rate_saved) {\n\t\t\t \n\t\t\t*best_parent_rate = parent_rate_saved;\n\t\t\treturn i;\n\t\t}\n\t\tparent_rate = clk_hw_round_rate(clk_hw_get_parent(hw),\n\t\t\t\tMULT_ROUND_UP(rate, i));\n\t\tnow = DIV_ROUND_UP(parent_rate, i);\n\t\tif (now <= rate && now > best) {\n\t\t\tbestdiv = i;\n\t\t\tbest = now;\n\t\t\t*best_parent_rate = parent_rate;\n\t\t}\n\t}\n\n\tif (!bestdiv) {\n\t\tbestdiv = divider->max;\n\t\t*best_parent_rate =\n\t\t\tclk_hw_round_rate(clk_hw_get_parent(hw), 1);\n\t}\n\n\treturn bestdiv;\n}\n\nstatic long ti_clk_divider_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long *prate)\n{\n\tint div;\n\tdiv = ti_clk_divider_bestdiv(hw, rate, prate);\n\n\treturn DIV_ROUND_UP(*prate, div);\n}\n\nstatic int ti_clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct clk_omap_divider *divider;\n\tunsigned int div, value;\n\tu32 val;\n\n\tif (!hw || !rate)\n\t\treturn -EINVAL;\n\n\tdivider = to_clk_omap_divider(hw);\n\n\tdiv = DIV_ROUND_UP(parent_rate, rate);\n\n\tif (div > divider->max)\n\t\tdiv = divider->max;\n\tif (div < divider->min)\n\t\tdiv = divider->min;\n\n\tvalue = _get_val(divider, div);\n\n\tval = ti_clk_ll_ops->clk_readl(&divider->reg);\n\tval &= ~(divider->mask << divider->shift);\n\tval |= value << divider->shift;\n\tti_clk_ll_ops->clk_writel(val, &divider->reg);\n\n\tti_clk_latch(&divider->reg, divider->latch);\n\n\treturn 0;\n}\n\n \nstatic int clk_divider_save_context(struct clk_hw *hw)\n{\n\tstruct clk_omap_divider *divider = to_clk_omap_divider(hw);\n\tu32 val;\n\n\tval = ti_clk_ll_ops->clk_readl(&divider->reg) >> divider->shift;\n\tdivider->context = val & divider->mask;\n\n\treturn 0;\n}\n\n \nstatic void clk_divider_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_omap_divider *divider = to_clk_omap_divider(hw);\n\tu32 val;\n\n\tval = ti_clk_ll_ops->clk_readl(&divider->reg);\n\tval &= ~(divider->mask << divider->shift);\n\tval |= divider->context << divider->shift;\n\tti_clk_ll_ops->clk_writel(val, &divider->reg);\n}\n\nconst struct clk_ops ti_clk_divider_ops = {\n\t.recalc_rate = ti_clk_divider_recalc_rate,\n\t.round_rate = ti_clk_divider_round_rate,\n\t.set_rate = ti_clk_divider_set_rate,\n\t.save_context = clk_divider_save_context,\n\t.restore_context = clk_divider_restore_context,\n};\n\nstatic struct clk *_register_divider(struct device_node *node,\n\t\t\t\t     u32 flags,\n\t\t\t\t     struct clk_omap_divider *div)\n{\n\tstruct clk_init_data init;\n\tconst char *parent_name;\n\tconst char *name;\n\n\tparent_name = of_clk_get_parent_name(node, 0);\n\n\tname = ti_dt_clk_name(node);\n\tinit.name = name;\n\tinit.ops = &ti_clk_divider_ops;\n\tinit.flags = flags;\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\n\tdiv->hw.init = &init;\n\n\t \n\treturn of_ti_clk_register(node, &div->hw, name);\n}\n\nint ti_clk_parse_divider_data(int *div_table, int num_dividers, int max_div,\n\t\t\t      u8 flags, struct clk_omap_divider *divider)\n{\n\tint valid_div = 0;\n\tint i;\n\tstruct clk_div_table *tmp;\n\tu16 min_div = 0;\n\n\tif (!div_table) {\n\t\tdivider->min = 1;\n\t\tdivider->max = max_div;\n\t\t_setup_mask(divider);\n\t\treturn 0;\n\t}\n\n\ti = 0;\n\n\twhile (!num_dividers || i < num_dividers) {\n\t\tif (div_table[i] == -1)\n\t\t\tbreak;\n\t\tif (div_table[i])\n\t\t\tvalid_div++;\n\t\ti++;\n\t}\n\n\tnum_dividers = i;\n\n\ttmp = kcalloc(valid_div + 1, sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tvalid_div = 0;\n\n\tfor (i = 0; i < num_dividers; i++)\n\t\tif (div_table[i] > 0) {\n\t\t\ttmp[valid_div].div = div_table[i];\n\t\t\ttmp[valid_div].val = i;\n\t\t\tvalid_div++;\n\t\t\tif (div_table[i] > max_div)\n\t\t\t\tmax_div = div_table[i];\n\t\t\tif (!min_div || div_table[i] < min_div)\n\t\t\t\tmin_div = div_table[i];\n\t\t}\n\n\tdivider->min = min_div;\n\tdivider->max = max_div;\n\tdivider->table = tmp;\n\t_setup_mask(divider);\n\n\treturn 0;\n}\n\nstatic int __init ti_clk_get_div_table(struct device_node *node,\n\t\t\t\t       struct clk_omap_divider *div)\n{\n\tstruct clk_div_table *table;\n\tconst __be32 *divspec;\n\tu32 val;\n\tu32 num_div;\n\tu32 valid_div;\n\tint i;\n\n\tdivspec = of_get_property(node, \"ti,dividers\", &num_div);\n\n\tif (!divspec)\n\t\treturn 0;\n\n\tnum_div /= 4;\n\n\tvalid_div = 0;\n\n\t \n\tfor (i = 0; i < num_div; i++) {\n\t\tof_property_read_u32_index(node, \"ti,dividers\", i, &val);\n\t\tif (val)\n\t\t\tvalid_div++;\n\t}\n\n\tif (!valid_div) {\n\t\tpr_err(\"no valid dividers for %pOFn table\\n\", node);\n\t\treturn -EINVAL;\n\t}\n\n\ttable = kcalloc(valid_div + 1, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tvalid_div = 0;\n\n\tfor (i = 0; i < num_div; i++) {\n\t\tof_property_read_u32_index(node, \"ti,dividers\", i, &val);\n\t\tif (val) {\n\t\t\ttable[valid_div].div = val;\n\t\t\ttable[valid_div].val = i;\n\t\t\tvalid_div++;\n\t\t}\n\t}\n\n\tdiv->table = table;\n\n\treturn 0;\n}\n\nstatic int _populate_divider_min_max(struct device_node *node,\n\t\t\t\t     struct clk_omap_divider *divider)\n{\n\tu32 min_div = 0;\n\tu32 max_div = 0;\n\tu32 val;\n\tconst struct clk_div_table *clkt;\n\n\tif (!divider->table) {\n\t\t \n\t\tif (of_property_read_u32(node, \"ti,min-div\", &min_div))\n\t\t\tmin_div = 1;\n\n\t\tif (of_property_read_u32(node, \"ti,max-div\", &max_div)) {\n\t\t\tpr_err(\"no max-div for %pOFn!\\n\", node);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\n\t\tfor (clkt = divider->table; clkt->div; clkt++) {\n\t\t\tval = clkt->div;\n\t\t\tif (val > max_div)\n\t\t\t\tmax_div = val;\n\t\t\tif (!min_div || val < min_div)\n\t\t\t\tmin_div = val;\n\t\t}\n\t}\n\n\tdivider->min = min_div;\n\tdivider->max = max_div;\n\t_setup_mask(divider);\n\n\treturn 0;\n}\n\nstatic int __init ti_clk_divider_populate(struct device_node *node,\n\t\t\t\t\t  struct clk_omap_divider *div,\n\t\t\t\t\t  u32 *flags)\n{\n\tu32 val;\n\tint ret;\n\n\tret = ti_clk_get_reg_addr(node, 0, &div->reg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!of_property_read_u32(node, \"ti,bit-shift\", &val))\n\t\tdiv->shift = val;\n\telse\n\t\tdiv->shift = 0;\n\n\tif (!of_property_read_u32(node, \"ti,latch-bit\", &val))\n\t\tdiv->latch = val;\n\telse\n\t\tdiv->latch = -EINVAL;\n\n\t*flags = 0;\n\tdiv->flags = 0;\n\n\tif (of_property_read_bool(node, \"ti,index-starts-at-one\"))\n\t\tdiv->flags |= CLK_DIVIDER_ONE_BASED;\n\n\tif (of_property_read_bool(node, \"ti,index-power-of-two\"))\n\t\tdiv->flags |= CLK_DIVIDER_POWER_OF_TWO;\n\n\tif (of_property_read_bool(node, \"ti,set-rate-parent\"))\n\t\t*flags |= CLK_SET_RATE_PARENT;\n\n\tret = ti_clk_get_div_table(node, div);\n\tif (ret)\n\t\treturn ret;\n\n\treturn _populate_divider_min_max(node, div);\n}\n\n \nstatic void __init of_ti_divider_clk_setup(struct device_node *node)\n{\n\tstruct clk *clk;\n\tu32 flags = 0;\n\tstruct clk_omap_divider *div;\n\n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn;\n\n\tif (ti_clk_divider_populate(node, div, &flags))\n\t\tgoto cleanup;\n\n\tclk = _register_divider(node, flags, div);\n\tif (!IS_ERR(clk)) {\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\t\tof_ti_clk_autoidle_setup(node);\n\t\treturn;\n\t}\n\ncleanup:\n\tkfree(div->table);\n\tkfree(div);\n}\nCLK_OF_DECLARE(divider_clk, \"ti,divider-clock\", of_ti_divider_clk_setup);\n\nstatic void __init of_ti_composite_divider_clk_setup(struct device_node *node)\n{\n\tstruct clk_omap_divider *div;\n\tu32 tmp;\n\n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn;\n\n\tif (ti_clk_divider_populate(node, div, &tmp))\n\t\tgoto cleanup;\n\n\tif (!ti_clk_add_component(node, &div->hw, CLK_COMPONENT_TYPE_DIVIDER))\n\t\treturn;\n\ncleanup:\n\tkfree(div->table);\n\tkfree(div);\n}\nCLK_OF_DECLARE(ti_composite_divider_clk, \"ti,composite-divider-clock\",\n\t       of_ti_composite_divider_clk_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}