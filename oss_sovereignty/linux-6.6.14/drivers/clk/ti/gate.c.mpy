{
  "module_name": "gate.c",
  "hash_id": "312eb578644da25f3596365a991fb23323edd2994ef2093f5eebe7a15fda833d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/gate.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/clk/ti.h>\n\n#include \"clock.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\nstatic int omap36xx_gate_clk_enable_with_hsdiv_restore(struct clk_hw *clk);\n\nstatic const struct clk_ops omap_gate_clkdm_clk_ops = {\n\t.init\t\t= &omap2_init_clk_clkdm,\n\t.enable\t\t= &omap2_clkops_enable_clkdm,\n\t.disable\t= &omap2_clkops_disable_clkdm,\n\t.restore_context = clk_gate_restore_context,\n};\n\nconst struct clk_ops omap_gate_clk_ops = {\n\t.init\t\t= &omap2_init_clk_clkdm,\n\t.enable\t\t= &omap2_dflt_clk_enable,\n\t.disable\t= &omap2_dflt_clk_disable,\n\t.is_enabled\t= &omap2_dflt_clk_is_enabled,\n\t.restore_context = clk_gate_restore_context,\n};\n\nstatic const struct clk_ops omap_gate_clk_hsdiv_restore_ops = {\n\t.init\t\t= &omap2_init_clk_clkdm,\n\t.enable\t\t= &omap36xx_gate_clk_enable_with_hsdiv_restore,\n\t.disable\t= &omap2_dflt_clk_disable,\n\t.is_enabled\t= &omap2_dflt_clk_is_enabled,\n\t.restore_context = clk_gate_restore_context,\n};\n\n \nstatic int omap36xx_gate_clk_enable_with_hsdiv_restore(struct clk_hw *hw)\n{\n\tstruct clk_omap_divider *parent;\n\tstruct clk_hw *parent_hw;\n\tu32 dummy_v, orig_v;\n\tint ret;\n\n\t \n\tret = omap2_dflt_clk_enable(hw);\n\n\t \n\tparent_hw = clk_hw_get_parent(clk_hw_get_parent(hw));\n\tparent = to_clk_omap_divider(parent_hw);\n\n\t \n\tif (!ret) {\n\t\torig_v = ti_clk_ll_ops->clk_readl(&parent->reg);\n\t\tdummy_v = orig_v;\n\n\t\t \n\t\tdummy_v ^= (1 << parent->shift);\n\t\tti_clk_ll_ops->clk_writel(dummy_v, &parent->reg);\n\n\t\t \n\t\tti_clk_ll_ops->clk_writel(orig_v, &parent->reg);\n\t}\n\n\treturn ret;\n}\n\nstatic struct clk *_register_gate(struct device_node *node, const char *name,\n\t\t\t\t  const char *parent_name, unsigned long flags,\n\t\t\t\t  struct clk_omap_reg *reg, u8 bit_idx,\n\t\t\t\t  u8 clk_gate_flags, const struct clk_ops *ops,\n\t\t\t\t  const struct clk_hw_omap_ops *hw_ops)\n{\n\tstruct clk_init_data init = { NULL };\n\tstruct clk_hw_omap *clk_hw;\n\tstruct clk *clk;\n\n\tclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\n\tif (!clk_hw)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk_hw->hw.init = &init;\n\n\tinit.name = name;\n\tinit.ops = ops;\n\n\tmemcpy(&clk_hw->enable_reg, reg, sizeof(*reg));\n\tclk_hw->enable_bit = bit_idx;\n\tclk_hw->ops = hw_ops;\n\n\tclk_hw->flags = clk_gate_flags;\n\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tinit.flags = flags;\n\n\tclk = of_ti_clk_register_omap_hw(node, &clk_hw->hw, name);\n\n\tif (IS_ERR(clk))\n\t\tkfree(clk_hw);\n\n\treturn clk;\n}\n\nstatic void __init _of_ti_gate_clk_setup(struct device_node *node,\n\t\t\t\t\t const struct clk_ops *ops,\n\t\t\t\t\t const struct clk_hw_omap_ops *hw_ops)\n{\n\tstruct clk *clk;\n\tconst char *parent_name;\n\tstruct clk_omap_reg reg;\n\tconst char *name;\n\tu8 enable_bit = 0;\n\tu32 val;\n\tu32 flags = 0;\n\tu8 clk_gate_flags = 0;\n\n\tif (ops != &omap_gate_clkdm_clk_ops) {\n\t\tif (ti_clk_get_reg_addr(node, 0, &reg))\n\t\t\treturn;\n\n\t\tif (!of_property_read_u32(node, \"ti,bit-shift\", &val))\n\t\t\tenable_bit = val;\n\t}\n\n\tif (of_clk_get_parent_count(node) != 1) {\n\t\tpr_err(\"%pOFn must have 1 parent\\n\", node);\n\t\treturn;\n\t}\n\n\tparent_name = of_clk_get_parent_name(node, 0);\n\n\tif (of_property_read_bool(node, \"ti,set-rate-parent\"))\n\t\tflags |= CLK_SET_RATE_PARENT;\n\n\tif (of_property_read_bool(node, \"ti,set-bit-to-disable\"))\n\t\tclk_gate_flags |= INVERT_ENABLE;\n\n\tname = ti_dt_clk_name(node);\n\tclk = _register_gate(node, name, parent_name, flags, &reg,\n\t\t\t     enable_bit, clk_gate_flags, ops, hw_ops);\n\n\tif (!IS_ERR(clk))\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n}\n\nstatic void __init\n_of_ti_composite_gate_clk_setup(struct device_node *node,\n\t\t\t\tconst struct clk_hw_omap_ops *hw_ops)\n{\n\tstruct clk_hw_omap *gate;\n\tu32 val = 0;\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn;\n\n\tif (ti_clk_get_reg_addr(node, 0, &gate->enable_reg))\n\t\tgoto cleanup;\n\n\tof_property_read_u32(node, \"ti,bit-shift\", &val);\n\n\tgate->enable_bit = val;\n\tgate->ops = hw_ops;\n\n\tif (!ti_clk_add_component(node, &gate->hw, CLK_COMPONENT_TYPE_GATE))\n\t\treturn;\n\ncleanup:\n\tkfree(gate);\n}\n\nstatic void __init\nof_ti_composite_no_wait_gate_clk_setup(struct device_node *node)\n{\n\t_of_ti_composite_gate_clk_setup(node, NULL);\n}\nCLK_OF_DECLARE(ti_composite_no_wait_gate_clk, \"ti,composite-no-wait-gate-clock\",\n\t       of_ti_composite_no_wait_gate_clk_setup);\n\n#if defined(CONFIG_ARCH_OMAP2) || defined(CONFIG_ARCH_OMAP3)\nstatic void __init of_ti_composite_interface_clk_setup(struct device_node *node)\n{\n\t_of_ti_composite_gate_clk_setup(node, &clkhwops_iclk_wait);\n}\nCLK_OF_DECLARE(ti_composite_interface_clk, \"ti,composite-interface-clock\",\n\t       of_ti_composite_interface_clk_setup);\n#endif\n\nstatic void __init of_ti_composite_gate_clk_setup(struct device_node *node)\n{\n\t_of_ti_composite_gate_clk_setup(node, &clkhwops_wait);\n}\nCLK_OF_DECLARE(ti_composite_gate_clk, \"ti,composite-gate-clock\",\n\t       of_ti_composite_gate_clk_setup);\n\n\nstatic void __init of_ti_clkdm_gate_clk_setup(struct device_node *node)\n{\n\t_of_ti_gate_clk_setup(node, &omap_gate_clkdm_clk_ops, NULL);\n}\nCLK_OF_DECLARE(ti_clkdm_gate_clk, \"ti,clkdm-gate-clock\",\n\t       of_ti_clkdm_gate_clk_setup);\n\nstatic void __init of_ti_hsdiv_gate_clk_setup(struct device_node *node)\n{\n\t_of_ti_gate_clk_setup(node, &omap_gate_clk_hsdiv_restore_ops,\n\t\t\t      &clkhwops_wait);\n}\nCLK_OF_DECLARE(ti_hsdiv_gate_clk, \"ti,hsdiv-gate-clock\",\n\t       of_ti_hsdiv_gate_clk_setup);\n\nstatic void __init of_ti_gate_clk_setup(struct device_node *node)\n{\n\t_of_ti_gate_clk_setup(node, &omap_gate_clk_ops, NULL);\n}\nCLK_OF_DECLARE(ti_gate_clk, \"ti,gate-clock\", of_ti_gate_clk_setup);\n\nstatic void __init of_ti_wait_gate_clk_setup(struct device_node *node)\n{\n\t_of_ti_gate_clk_setup(node, &omap_gate_clk_ops, &clkhwops_wait);\n}\nCLK_OF_DECLARE(ti_wait_gate_clk, \"ti,wait-gate-clock\",\n\t       of_ti_wait_gate_clk_setup);\n\n#ifdef CONFIG_ARCH_OMAP3\nstatic void __init of_ti_am35xx_gate_clk_setup(struct device_node *node)\n{\n\t_of_ti_gate_clk_setup(node, &omap_gate_clk_ops,\n\t\t\t      &clkhwops_am35xx_ipss_module_wait);\n}\nCLK_OF_DECLARE(ti_am35xx_gate_clk, \"ti,am35xx-gate-clock\",\n\t       of_ti_am35xx_gate_clk_setup);\n\nstatic void __init of_ti_dss_gate_clk_setup(struct device_node *node)\n{\n\t_of_ti_gate_clk_setup(node, &omap_gate_clk_ops,\n\t\t\t      &clkhwops_omap3430es2_dss_usbhost_wait);\n}\nCLK_OF_DECLARE(ti_dss_gate_clk, \"ti,dss-gate-clock\",\n\t       of_ti_dss_gate_clk_setup);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}