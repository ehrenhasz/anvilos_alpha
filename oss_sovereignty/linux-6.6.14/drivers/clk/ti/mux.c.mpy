{
  "module_name": "mux.c",
  "hash_id": "2dc020319c23b0f6406071edb7842a9ce54216c8aa70de2fbab5c410c8f1fe38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/mux.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/clk/ti.h>\n#include \"clock.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\nstatic u8 ti_clk_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_omap_mux *mux = to_clk_omap_mux(hw);\n\tint num_parents = clk_hw_get_num_parents(hw);\n\tu32 val;\n\n\t \n\tval = ti_clk_ll_ops->clk_readl(&mux->reg) >> mux->shift;\n\tval &= mux->mask;\n\n\tif (mux->table) {\n\t\tint i;\n\n\t\tfor (i = 0; i < num_parents; i++)\n\t\t\tif (mux->table[i] == val)\n\t\t\t\treturn i;\n\t\treturn -EINVAL;\n\t}\n\n\tif (val && (mux->flags & CLK_MUX_INDEX_BIT))\n\t\tval = ffs(val) - 1;\n\n\tif (val && (mux->flags & CLK_MUX_INDEX_ONE))\n\t\tval--;\n\n\tif (val >= num_parents)\n\t\treturn -EINVAL;\n\n\treturn val;\n}\n\nstatic int ti_clk_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_omap_mux *mux = to_clk_omap_mux(hw);\n\tu32 val;\n\n\tif (mux->table) {\n\t\tindex = mux->table[index];\n\t} else {\n\t\tif (mux->flags & CLK_MUX_INDEX_BIT)\n\t\t\tindex = (1 << ffs(index));\n\n\t\tif (mux->flags & CLK_MUX_INDEX_ONE)\n\t\t\tindex++;\n\t}\n\n\tif (mux->flags & CLK_MUX_HIWORD_MASK) {\n\t\tval = mux->mask << (mux->shift + 16);\n\t} else {\n\t\tval = ti_clk_ll_ops->clk_readl(&mux->reg);\n\t\tval &= ~(mux->mask << mux->shift);\n\t}\n\tval |= index << mux->shift;\n\tti_clk_ll_ops->clk_writel(val, &mux->reg);\n\tti_clk_latch(&mux->reg, mux->latch);\n\n\treturn 0;\n}\n\n \nstatic int clk_mux_save_context(struct clk_hw *hw)\n{\n\tstruct clk_omap_mux *mux = to_clk_omap_mux(hw);\n\n\tmux->saved_parent = ti_clk_mux_get_parent(hw);\n\treturn 0;\n}\n\n \nstatic void clk_mux_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_omap_mux *mux = to_clk_omap_mux(hw);\n\n\tti_clk_mux_set_parent(hw, mux->saved_parent);\n}\n\nconst struct clk_ops ti_clk_mux_ops = {\n\t.get_parent = ti_clk_mux_get_parent,\n\t.set_parent = ti_clk_mux_set_parent,\n\t.determine_rate = __clk_mux_determine_rate,\n\t.save_context = clk_mux_save_context,\n\t.restore_context = clk_mux_restore_context,\n};\n\nstatic struct clk *_register_mux(struct device_node *node, const char *name,\n\t\t\t\t const char * const *parent_names,\n\t\t\t\t u8 num_parents, unsigned long flags,\n\t\t\t\t struct clk_omap_reg *reg, u8 shift, u32 mask,\n\t\t\t\t s8 latch, u8 clk_mux_flags, u32 *table)\n{\n\tstruct clk_omap_mux *mux;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\t \n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &ti_clk_mux_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\n\t \n\tmemcpy(&mux->reg, reg, sizeof(*reg));\n\tmux->shift = shift;\n\tmux->mask = mask;\n\tmux->latch = latch;\n\tmux->flags = clk_mux_flags;\n\tmux->table = table;\n\tmux->hw.init = &init;\n\n\tclk = of_ti_clk_register(node, &mux->hw, name);\n\n\tif (IS_ERR(clk))\n\t\tkfree(mux);\n\n\treturn clk;\n}\n\n \nstatic void of_mux_clk_setup(struct device_node *node)\n{\n\tstruct clk *clk;\n\tstruct clk_omap_reg reg;\n\tunsigned int num_parents;\n\tconst char **parent_names;\n\tconst char *name;\n\tu8 clk_mux_flags = 0;\n\tu32 mask = 0;\n\tu32 shift = 0;\n\ts32 latch = -EINVAL;\n\tu32 flags = CLK_SET_RATE_NO_REPARENT;\n\n\tnum_parents = of_clk_get_parent_count(node);\n\tif (num_parents < 2) {\n\t\tpr_err(\"mux-clock %pOFn must have parents\\n\", node);\n\t\treturn;\n\t}\n\tparent_names = kzalloc((sizeof(char *) * num_parents), GFP_KERNEL);\n\tif (!parent_names)\n\t\tgoto cleanup;\n\n\tof_clk_parent_fill(node, parent_names, num_parents);\n\n\tif (ti_clk_get_reg_addr(node, 0, &reg))\n\t\tgoto cleanup;\n\n\tof_property_read_u32(node, \"ti,bit-shift\", &shift);\n\n\tof_property_read_u32(node, \"ti,latch-bit\", &latch);\n\n\tif (of_property_read_bool(node, \"ti,index-starts-at-one\"))\n\t\tclk_mux_flags |= CLK_MUX_INDEX_ONE;\n\n\tif (of_property_read_bool(node, \"ti,set-rate-parent\"))\n\t\tflags |= CLK_SET_RATE_PARENT;\n\n\t \n\tmask = num_parents;\n\tif (!(clk_mux_flags & CLK_MUX_INDEX_ONE))\n\t\tmask--;\n\n\tmask = (1 << fls(mask)) - 1;\n\n\tname = ti_dt_clk_name(node);\n\tclk = _register_mux(node, name, parent_names, num_parents,\n\t\t\t    flags, &reg, shift, mask, latch, clk_mux_flags,\n\t\t\t    NULL);\n\n\tif (!IS_ERR(clk))\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\ncleanup:\n\tkfree(parent_names);\n}\nCLK_OF_DECLARE(mux_clk, \"ti,mux-clock\", of_mux_clk_setup);\n\nstruct clk_hw *ti_clk_build_component_mux(struct ti_clk_mux *setup)\n{\n\tstruct clk_omap_mux *mux;\n\tint num_parents;\n\n\tif (!setup)\n\t\treturn NULL;\n\n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmux->shift = setup->bit_shift;\n\tmux->latch = -EINVAL;\n\n\tmux->reg.index = setup->module;\n\tmux->reg.offset = setup->reg;\n\n\tif (setup->flags & CLKF_INDEX_STARTS_AT_ONE)\n\t\tmux->flags |= CLK_MUX_INDEX_ONE;\n\n\tnum_parents = setup->num_parents;\n\n\tmux->mask = num_parents - 1;\n\tmux->mask = (1 << fls(mux->mask)) - 1;\n\n\treturn &mux->hw;\n}\n\nstatic void __init of_ti_composite_mux_clk_setup(struct device_node *node)\n{\n\tstruct clk_omap_mux *mux;\n\tunsigned int num_parents;\n\tu32 val;\n\n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn;\n\n\tif (ti_clk_get_reg_addr(node, 0, &mux->reg))\n\t\tgoto cleanup;\n\n\tif (!of_property_read_u32(node, \"ti,bit-shift\", &val))\n\t\tmux->shift = val;\n\n\tif (of_property_read_bool(node, \"ti,index-starts-at-one\"))\n\t\tmux->flags |= CLK_MUX_INDEX_ONE;\n\n\tnum_parents = of_clk_get_parent_count(node);\n\n\tif (num_parents < 2) {\n\t\tpr_err(\"%pOFn must have parents\\n\", node);\n\t\tgoto cleanup;\n\t}\n\n\tmux->mask = num_parents - 1;\n\tmux->mask = (1 << fls(mux->mask)) - 1;\n\n\tif (!ti_clk_add_component(node, &mux->hw, CLK_COMPONENT_TYPE_MUX))\n\t\treturn;\n\ncleanup:\n\tkfree(mux);\n}\nCLK_OF_DECLARE(ti_composite_mux_clk_setup, \"ti,composite-mux-clock\",\n\t       of_ti_composite_mux_clk_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}