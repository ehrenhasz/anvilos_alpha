{
  "module_name": "clkctrl.c",
  "hash_id": "2d07e65bd1bbfe669cc059321e64fd006f5f85ec340ff416efaffa196127a940",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/clkctrl.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/clk/ti.h>\n#include <linux/delay.h>\n#include <linux/string_helpers.h>\n#include <linux/timekeeping.h>\n#include \"clock.h\"\n\n#define NO_IDLEST\t\t\t0\n\n#define OMAP4_MODULEMODE_MASK\t\t0x3\n\n#define MODULEMODE_HWCTRL\t\t0x1\n#define MODULEMODE_SWCTRL\t\t0x2\n\n#define OMAP4_IDLEST_MASK\t\t(0x3 << 16)\n#define OMAP4_IDLEST_SHIFT\t\t16\n\n#define OMAP4_STBYST_MASK\t\tBIT(18)\n#define OMAP4_STBYST_SHIFT\t\t18\n\n#define CLKCTRL_IDLEST_FUNCTIONAL\t0x0\n#define CLKCTRL_IDLEST_INTERFACE_IDLE\t0x2\n#define CLKCTRL_IDLEST_DISABLED\t\t0x3\n\n \n#define OMAP4_MAX_MODULE_READY_TIME\t2000\n#define OMAP4_MAX_MODULE_DISABLE_TIME\t5000\n\nstatic bool _early_timeout = true;\n\nstruct omap_clkctrl_provider {\n\tvoid __iomem *base;\n\tstruct list_head clocks;\n\tchar *clkdm_name;\n};\n\nstruct omap_clkctrl_clk {\n\tstruct clk_hw *clk;\n\tu16 reg_offset;\n\tint bit_offset;\n\tstruct list_head node;\n};\n\nunion omap4_timeout {\n\tu32 cycles;\n\tktime_t start;\n};\n\nstatic const struct omap_clkctrl_data default_clkctrl_data[] __initconst = {\n\t{ 0 },\n};\n\nstatic u32 _omap4_idlest(u32 val)\n{\n\tval &= OMAP4_IDLEST_MASK;\n\tval >>= OMAP4_IDLEST_SHIFT;\n\n\treturn val;\n}\n\nstatic bool _omap4_is_idle(u32 val)\n{\n\tval = _omap4_idlest(val);\n\n\treturn val == CLKCTRL_IDLEST_DISABLED;\n}\n\nstatic bool _omap4_is_ready(u32 val)\n{\n\tval = _omap4_idlest(val);\n\n\treturn val == CLKCTRL_IDLEST_FUNCTIONAL ||\n\t       val == CLKCTRL_IDLEST_INTERFACE_IDLE;\n}\n\nstatic bool _omap4_is_timeout(union omap4_timeout *time, u32 timeout)\n{\n\t \n\tif (unlikely(_early_timeout || timekeeping_suspended)) {\n\t\tif (time->cycles++ < timeout) {\n\t\t\tudelay(1 * 2);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (!ktime_to_ns(time->start)) {\n\t\t\ttime->start = ktime_get();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (ktime_us_delta(ktime_get(), time->start) < timeout) {\n\t\t\tcpu_relax();\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic int __init _omap4_disable_early_timeout(void)\n{\n\t_early_timeout = false;\n\n\treturn 0;\n}\narch_initcall(_omap4_disable_early_timeout);\n\nstatic int _omap4_clkctrl_clk_enable(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tu32 val;\n\tint ret;\n\tunion omap4_timeout timeout = { 0 };\n\n\tif (clk->clkdm) {\n\t\tret = ti_clk_ll_ops->clkdm_clk_enable(clk->clkdm, hw->clk);\n\t\tif (ret) {\n\t\t\tWARN(1,\n\t\t\t     \"%s: could not enable %s's clockdomain %s: %d\\n\",\n\t\t\t     __func__, clk_hw_get_name(hw),\n\t\t\t     clk->clkdm_name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!clk->enable_bit)\n\t\treturn 0;\n\n\tval = ti_clk_ll_ops->clk_readl(&clk->enable_reg);\n\n\tval &= ~OMAP4_MODULEMODE_MASK;\n\tval |= clk->enable_bit;\n\n\tti_clk_ll_ops->clk_writel(val, &clk->enable_reg);\n\n\tif (test_bit(NO_IDLEST, &clk->flags))\n\t\treturn 0;\n\n\t \n\twhile (!_omap4_is_ready(ti_clk_ll_ops->clk_readl(&clk->enable_reg))) {\n\t\tif (_omap4_is_timeout(&timeout, OMAP4_MAX_MODULE_READY_TIME)) {\n\t\t\tpr_err(\"%s: failed to enable\\n\", clk_hw_get_name(hw));\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void _omap4_clkctrl_clk_disable(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tu32 val;\n\tunion omap4_timeout timeout = { 0 };\n\n\tif (!clk->enable_bit)\n\t\tgoto exit;\n\n\tval = ti_clk_ll_ops->clk_readl(&clk->enable_reg);\n\n\tval &= ~OMAP4_MODULEMODE_MASK;\n\n\tti_clk_ll_ops->clk_writel(val, &clk->enable_reg);\n\n\tif (test_bit(NO_IDLEST, &clk->flags))\n\t\tgoto exit;\n\n\t \n\twhile (!_omap4_is_idle(ti_clk_ll_ops->clk_readl(&clk->enable_reg))) {\n\t\tif (_omap4_is_timeout(&timeout,\n\t\t\t\t      OMAP4_MAX_MODULE_DISABLE_TIME)) {\n\t\t\tpr_err(\"%s: failed to disable\\n\", clk_hw_get_name(hw));\n\t\t\tbreak;\n\t\t}\n\t}\n\nexit:\n\tif (clk->clkdm)\n\t\tti_clk_ll_ops->clkdm_clk_disable(clk->clkdm, hw->clk);\n}\n\nstatic int _omap4_clkctrl_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tu32 val;\n\n\tval = ti_clk_ll_ops->clk_readl(&clk->enable_reg);\n\n\tif (val & clk->enable_bit)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops omap4_clkctrl_clk_ops = {\n\t.enable\t\t= _omap4_clkctrl_clk_enable,\n\t.disable\t= _omap4_clkctrl_clk_disable,\n\t.is_enabled\t= _omap4_clkctrl_clk_is_enabled,\n\t.init\t\t= omap2_init_clk_clkdm,\n};\n\nstatic struct clk_hw *_ti_omap4_clkctrl_xlate(struct of_phandle_args *clkspec,\n\t\t\t\t\t      void *data)\n{\n\tstruct omap_clkctrl_provider *provider = data;\n\tstruct omap_clkctrl_clk *entry = NULL, *iter;\n\n\tif (clkspec->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpr_debug(\"%s: looking for %x:%x\\n\", __func__,\n\t\t clkspec->args[0], clkspec->args[1]);\n\n\tlist_for_each_entry(iter, &provider->clocks, node) {\n\t\tif (iter->reg_offset == clkspec->args[0] &&\n\t\t    iter->bit_offset == clkspec->args[1]) {\n\t\t\tentry = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!entry)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn entry->clk;\n}\n\n \nstatic const char * __init clkctrl_get_clock_name(struct device_node *np,\n\t\t\t\t\t\t  const char *clkctrl_name,\n\t\t\t\t\t\t  int offset, int index,\n\t\t\t\t\t\t  bool legacy_naming)\n{\n\tchar *clock_name;\n\n\t \n\tif (clkctrl_name && !legacy_naming) {\n\t\tclock_name = kasprintf(GFP_KERNEL, \"%s-clkctrl:%04x:%d\",\n\t\t\t\t       clkctrl_name, offset, index);\n\t\tif (!clock_name)\n\t\t\treturn NULL;\n\n\t\tstrreplace(clock_name, '_', '-');\n\n\t\treturn clock_name;\n\t}\n\n\t \n\tif (clkctrl_name)\n\t\treturn kasprintf(GFP_KERNEL, \"%s_cm:clk:%04x:%d\",\n\t\t\t\t clkctrl_name, offset, index);\n\n\t \n\tif (legacy_naming)\n\t\treturn kasprintf(GFP_KERNEL, \"%pOFn:clk:%04x:%d\",\n\t\t\t\t np->parent, offset, index);\n\n\t \n\treturn kasprintf(GFP_KERNEL, \"%pOFn:%04x:%d\", np, offset, index);\n}\n\nstatic int __init\n_ti_clkctrl_clk_register(struct omap_clkctrl_provider *provider,\n\t\t\t struct device_node *node, struct clk_hw *clk_hw,\n\t\t\t u16 offset, u8 bit, const char * const *parents,\n\t\t\t int num_parents, const struct clk_ops *ops,\n\t\t\t const char *clkctrl_name)\n{\n\tstruct clk_init_data init = { NULL };\n\tstruct clk *clk;\n\tstruct omap_clkctrl_clk *clkctrl_clk;\n\tint ret = 0;\n\n\tinit.name = clkctrl_get_clock_name(node, clkctrl_name, offset, bit,\n\t\t\t\t\t   ti_clk_get_features()->flags &\n\t\t\t\t\t   TI_CLK_CLKCTRL_COMPAT);\n\n\tclkctrl_clk = kzalloc(sizeof(*clkctrl_clk), GFP_KERNEL);\n\tif (!init.name || !clkctrl_clk) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tclk_hw->init = &init;\n\tinit.parent_names = parents;\n\tinit.num_parents = num_parents;\n\tinit.ops = ops;\n\tinit.flags = 0;\n\n\tclk = of_ti_clk_register(node, clk_hw, init.name);\n\tif (IS_ERR_OR_NULL(clk)) {\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tclkctrl_clk->reg_offset = offset;\n\tclkctrl_clk->bit_offset = bit;\n\tclkctrl_clk->clk = clk_hw;\n\n\tlist_add(&clkctrl_clk->node, &provider->clocks);\n\n\treturn 0;\n\ncleanup:\n\tkfree(init.name);\n\tkfree(clkctrl_clk);\n\treturn ret;\n}\n\nstatic void __init\n_ti_clkctrl_setup_gate(struct omap_clkctrl_provider *provider,\n\t\t       struct device_node *node, u16 offset,\n\t\t       const struct omap_clkctrl_bit_data *data,\n\t\t       void __iomem *reg, const char *clkctrl_name)\n{\n\tstruct clk_hw_omap *clk_hw;\n\n\tclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\n\tif (!clk_hw)\n\t\treturn;\n\n\tclk_hw->enable_bit = data->bit;\n\tclk_hw->enable_reg.ptr = reg;\n\n\tif (_ti_clkctrl_clk_register(provider, node, &clk_hw->hw, offset,\n\t\t\t\t     data->bit, data->parents, 1,\n\t\t\t\t     &omap_gate_clk_ops, clkctrl_name))\n\t\tkfree(clk_hw);\n}\n\nstatic void __init\n_ti_clkctrl_setup_mux(struct omap_clkctrl_provider *provider,\n\t\t      struct device_node *node, u16 offset,\n\t\t      const struct omap_clkctrl_bit_data *data,\n\t\t      void __iomem *reg, const char *clkctrl_name)\n{\n\tstruct clk_omap_mux *mux;\n\tint num_parents = 0;\n\tconst char * const *pname;\n\n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn;\n\n\tpname = data->parents;\n\twhile (*pname) {\n\t\tnum_parents++;\n\t\tpname++;\n\t}\n\n\tmux->mask = num_parents;\n\tif (!(mux->flags & CLK_MUX_INDEX_ONE))\n\t\tmux->mask--;\n\n\tmux->mask = (1 << fls(mux->mask)) - 1;\n\n\tmux->shift = data->bit;\n\tmux->reg.ptr = reg;\n\n\tif (_ti_clkctrl_clk_register(provider, node, &mux->hw, offset,\n\t\t\t\t     data->bit, data->parents, num_parents,\n\t\t\t\t     &ti_clk_mux_ops, clkctrl_name))\n\t\tkfree(mux);\n}\n\nstatic void __init\n_ti_clkctrl_setup_div(struct omap_clkctrl_provider *provider,\n\t\t      struct device_node *node, u16 offset,\n\t\t      const struct omap_clkctrl_bit_data *data,\n\t\t      void __iomem *reg, const char *clkctrl_name)\n{\n\tstruct clk_omap_divider *div;\n\tconst struct omap_clkctrl_div_data *div_data = data->data;\n\tu8 div_flags = 0;\n\n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn;\n\n\tdiv->reg.ptr = reg;\n\tdiv->shift = data->bit;\n\tdiv->flags = div_data->flags;\n\n\tif (div->flags & CLK_DIVIDER_POWER_OF_TWO)\n\t\tdiv_flags |= CLKF_INDEX_POWER_OF_TWO;\n\n\tif (ti_clk_parse_divider_data((int *)div_data->dividers, 0,\n\t\t\t\t      div_data->max_div, div_flags,\n\t\t\t\t      div)) {\n\t\tpr_err(\"%s: Data parsing for %pOF:%04x:%d failed\\n\", __func__,\n\t\t       node, offset, data->bit);\n\t\tkfree(div);\n\t\treturn;\n\t}\n\n\tif (_ti_clkctrl_clk_register(provider, node, &div->hw, offset,\n\t\t\t\t     data->bit, data->parents, 1,\n\t\t\t\t     &ti_clk_divider_ops, clkctrl_name))\n\t\tkfree(div);\n}\n\nstatic void __init\n_ti_clkctrl_setup_subclks(struct omap_clkctrl_provider *provider,\n\t\t\t  struct device_node *node,\n\t\t\t  const struct omap_clkctrl_reg_data *data,\n\t\t\t  void __iomem *reg, const char *clkctrl_name)\n{\n\tconst struct omap_clkctrl_bit_data *bits = data->bit_data;\n\n\tif (!bits)\n\t\treturn;\n\n\twhile (bits->bit) {\n\t\tswitch (bits->type) {\n\t\tcase TI_CLK_GATE:\n\t\t\t_ti_clkctrl_setup_gate(provider, node, data->offset,\n\t\t\t\t\t       bits, reg, clkctrl_name);\n\t\t\tbreak;\n\n\t\tcase TI_CLK_DIVIDER:\n\t\t\t_ti_clkctrl_setup_div(provider, node, data->offset,\n\t\t\t\t\t      bits, reg, clkctrl_name);\n\t\t\tbreak;\n\n\t\tcase TI_CLK_MUX:\n\t\t\t_ti_clkctrl_setup_mux(provider, node, data->offset,\n\t\t\t\t\t      bits, reg, clkctrl_name);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"%s: bad subclk type: %d\\n\", __func__,\n\t\t\t       bits->type);\n\t\t\treturn;\n\t\t}\n\t\tbits++;\n\t}\n}\n\nstatic void __init _clkctrl_add_provider(void *data,\n\t\t\t\t\t struct device_node *np)\n{\n\tof_clk_add_hw_provider(np, _ti_omap4_clkctrl_xlate, data);\n}\n\n \nstatic const char * __init clkctrl_get_name(struct device_node *np)\n{\n\tstruct property *prop;\n\tconst int prefix_len = 11;\n\tconst char *compat;\n\tconst char *output;\n\tconst char *end;\n\tchar *name;\n\n\tif (!of_property_read_string_index(np, \"clock-output-names\", 0,\n\t\t\t\t\t   &output)) {\n\t\tint len;\n\n\t\tlen = strlen(output);\n\t\tend = strstr(output, \"_clkctrl\");\n\t\tif (end)\n\t\t\tlen -= strlen(end);\n\t\tname = kstrndup(output, len, GFP_KERNEL);\n\n\t\treturn name;\n\t}\n\n\tof_property_for_each_string(np, \"compatible\", prop, compat) {\n\t\tif (!strncmp(\"ti,clkctrl-\", compat, prefix_len)) {\n\t\t\tend = compat + prefix_len;\n\t\t\t \n\t\t\tif (strnlen(end, 16) < 2)\n\t\t\t\tcontinue;\n\t\t\tname = kstrdup_and_replace(end, '-', '_', GFP_KERNEL);\n\t\t\tif (!name)\n\t\t\t\tcontinue;\n\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void __init _ti_omap4_clkctrl_setup(struct device_node *node)\n{\n\tstruct omap_clkctrl_provider *provider;\n\tconst struct omap_clkctrl_data *data = default_clkctrl_data;\n\tconst struct omap_clkctrl_reg_data *reg_data;\n\tstruct clk_init_data init = { NULL };\n\tstruct clk_hw_omap *hw;\n\tstruct clk *clk;\n\tstruct omap_clkctrl_clk *clkctrl_clk = NULL;\n\tbool legacy_naming;\n\tconst char *clkctrl_name;\n\tu32 addr;\n\tint ret;\n\tchar *c;\n\tu16 soc_mask = 0;\n\tstruct resource res;\n\n\tof_address_to_resource(node, 0, &res);\n\taddr = (u32)res.start;\n\n#ifdef CONFIG_ARCH_OMAP4\n\tif (of_machine_is_compatible(\"ti,omap4\"))\n\t\tdata = omap4_clkctrl_data;\n#endif\n#ifdef CONFIG_SOC_OMAP5\n\tif (of_machine_is_compatible(\"ti,omap5\"))\n\t\tdata = omap5_clkctrl_data;\n#endif\n#ifdef CONFIG_SOC_DRA7XX\n\tif (of_machine_is_compatible(\"ti,dra7\"))\n\t\tdata = dra7_clkctrl_data;\n\tif (of_machine_is_compatible(\"ti,dra72\"))\n\t\tsoc_mask = CLKF_SOC_DRA72;\n\tif (of_machine_is_compatible(\"ti,dra74\"))\n\t\tsoc_mask = CLKF_SOC_DRA74;\n\tif (of_machine_is_compatible(\"ti,dra76\"))\n\t\tsoc_mask = CLKF_SOC_DRA76;\n#endif\n#ifdef CONFIG_SOC_AM33XX\n\tif (of_machine_is_compatible(\"ti,am33xx\"))\n\t\tdata = am3_clkctrl_data;\n#endif\n#ifdef CONFIG_SOC_AM43XX\n\tif (of_machine_is_compatible(\"ti,am4372\"))\n\t\tdata = am4_clkctrl_data;\n\n\tif (of_machine_is_compatible(\"ti,am438x\"))\n\t\tdata = am438x_clkctrl_data;\n#endif\n#ifdef CONFIG_SOC_TI81XX\n\tif (of_machine_is_compatible(\"ti,dm814\"))\n\t\tdata = dm814_clkctrl_data;\n\n\tif (of_machine_is_compatible(\"ti,dm816\"))\n\t\tdata = dm816_clkctrl_data;\n#endif\n\n\tif (ti_clk_get_features()->flags & TI_CLK_DEVICE_TYPE_GP)\n\t\tsoc_mask |= CLKF_SOC_NONSEC;\n\n\twhile (data->addr) {\n\t\tif (addr == data->addr)\n\t\t\tbreak;\n\n\t\tdata++;\n\t}\n\n\tif (!data->addr) {\n\t\tpr_err(\"%pOF not found from clkctrl data.\\n\", node);\n\t\treturn;\n\t}\n\n\tprovider = kzalloc(sizeof(*provider), GFP_KERNEL);\n\tif (!provider)\n\t\treturn;\n\n\tprovider->base = of_iomap(node, 0);\n\n\tlegacy_naming = ti_clk_get_features()->flags & TI_CLK_CLKCTRL_COMPAT;\n\tclkctrl_name = clkctrl_get_name(node);\n\tif (clkctrl_name) {\n\t\tprovider->clkdm_name = kasprintf(GFP_KERNEL,\n\t\t\t\t\t\t \"%s_clkdm\", clkctrl_name);\n\t\tif (!provider->clkdm_name) {\n\t\t\tkfree(provider);\n\t\t\treturn;\n\t\t}\n\t\tgoto clkdm_found;\n\t}\n\n\t \n\tif (legacy_naming) {\n\t\tprovider->clkdm_name = kasprintf(GFP_KERNEL, \"%pOFnxxx\", node->parent);\n\t\tif (!provider->clkdm_name) {\n\t\t\tkfree(provider);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tprovider->clkdm_name[strlen(provider->clkdm_name) - 2] = 0;\n\t} else {\n\t\tprovider->clkdm_name = kasprintf(GFP_KERNEL, \"%pOFn\", node);\n\t\tif (!provider->clkdm_name) {\n\t\t\tkfree(provider);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tprovider->clkdm_name[strlen(provider->clkdm_name) - 7] = 0;\n\t}\n\n\tstrcat(provider->clkdm_name, \"clkdm\");\n\n\t \n\tc = provider->clkdm_name;\n\n\twhile (*c) {\n\t\tif (*c == '-')\n\t\t\t*c = '_';\n\t\tc++;\n\t}\nclkdm_found:\n\tINIT_LIST_HEAD(&provider->clocks);\n\n\t \n\treg_data = data->regs;\n\n\twhile (reg_data->parent) {\n\t\tif ((reg_data->flags & CLKF_SOC_MASK) &&\n\t\t    (reg_data->flags & soc_mask) == 0) {\n\t\t\treg_data++;\n\t\t\tcontinue;\n\t\t}\n\n\t\thw = kzalloc(sizeof(*hw), GFP_KERNEL);\n\t\tif (!hw)\n\t\t\treturn;\n\n\t\thw->enable_reg.ptr = provider->base + reg_data->offset;\n\n\t\t_ti_clkctrl_setup_subclks(provider, node, reg_data,\n\t\t\t\t\t  hw->enable_reg.ptr, clkctrl_name);\n\n\t\tif (reg_data->flags & CLKF_SW_SUP)\n\t\t\thw->enable_bit = MODULEMODE_SWCTRL;\n\t\tif (reg_data->flags & CLKF_HW_SUP)\n\t\t\thw->enable_bit = MODULEMODE_HWCTRL;\n\t\tif (reg_data->flags & CLKF_NO_IDLEST)\n\t\t\tset_bit(NO_IDLEST, &hw->flags);\n\n\t\tif (reg_data->clkdm_name)\n\t\t\thw->clkdm_name = reg_data->clkdm_name;\n\t\telse\n\t\t\thw->clkdm_name = provider->clkdm_name;\n\n\t\tinit.parent_names = &reg_data->parent;\n\t\tinit.num_parents = 1;\n\t\tinit.flags = 0;\n\t\tif (reg_data->flags & CLKF_SET_RATE_PARENT)\n\t\t\tinit.flags |= CLK_SET_RATE_PARENT;\n\n\t\tinit.name = clkctrl_get_clock_name(node, clkctrl_name,\n\t\t\t\t\t\t   reg_data->offset, 0,\n\t\t\t\t\t\t   legacy_naming);\n\t\tif (!init.name)\n\t\t\tgoto cleanup;\n\n\t\tclkctrl_clk = kzalloc(sizeof(*clkctrl_clk), GFP_KERNEL);\n\t\tif (!clkctrl_clk)\n\t\t\tgoto cleanup;\n\n\t\tinit.ops = &omap4_clkctrl_clk_ops;\n\t\thw->hw.init = &init;\n\n\t\tclk = of_ti_clk_register_omap_hw(node, &hw->hw, init.name);\n\t\tif (IS_ERR_OR_NULL(clk))\n\t\t\tgoto cleanup;\n\n\t\tclkctrl_clk->reg_offset = reg_data->offset;\n\t\tclkctrl_clk->clk = &hw->hw;\n\n\t\tlist_add(&clkctrl_clk->node, &provider->clocks);\n\n\t\treg_data++;\n\t}\n\n\tret = of_clk_add_hw_provider(node, _ti_omap4_clkctrl_xlate, provider);\n\tif (ret == -EPROBE_DEFER)\n\t\tti_clk_retry_init(node, provider, _clkctrl_add_provider);\n\n\tkfree(clkctrl_name);\n\n\treturn;\n\ncleanup:\n\tkfree(hw);\n\tkfree(init.name);\n\tkfree(clkctrl_name);\n\tkfree(clkctrl_clk);\n}\nCLK_OF_DECLARE(ti_omap4_clkctrl_clock, \"ti,clkctrl\",\n\t       _ti_omap4_clkctrl_setup);\n\n \nbool ti_clk_is_in_standby(struct clk *clk)\n{\n\tstruct clk_hw *hw;\n\tstruct clk_hw_omap *hwclk;\n\tu32 val;\n\n\thw = __clk_get_hw(clk);\n\n\tif (!omap2_clk_is_hw_omap(hw))\n\t\treturn false;\n\n\thwclk = to_clk_hw_omap(hw);\n\n\tval = ti_clk_ll_ops->clk_readl(&hwclk->enable_reg);\n\n\tif (val & OMAP4_STBYST_MASK)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(ti_clk_is_in_standby);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}