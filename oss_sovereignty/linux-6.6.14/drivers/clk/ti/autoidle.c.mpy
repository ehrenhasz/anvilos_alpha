{
  "module_name": "autoidle.c",
  "hash_id": "819de40bc19ff8f60a278502b5c4d72348744f804d38674b0c9f710c78bc1799",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/autoidle.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/clk/ti.h>\n\n#include \"clock.h\"\n\nstruct clk_ti_autoidle {\n\tstruct clk_omap_reg\treg;\n\tu8\t\t\tshift;\n\tu8\t\t\tflags;\n\tconst char\t\t*name;\n\tstruct list_head\tnode;\n};\n\n#define AUTOIDLE_LOW\t\t0x1\n\nstatic LIST_HEAD(autoidle_clks);\n\n \nstatic DEFINE_SPINLOCK(autoidle_spinlock);\n\nstatic int _omap2_clk_deny_idle(struct clk_hw_omap *clk)\n{\n\tif (clk->ops && clk->ops->deny_idle) {\n\t\tunsigned long irqflags;\n\n\t\tspin_lock_irqsave(&autoidle_spinlock, irqflags);\n\t\tclk->autoidle_count++;\n\t\tif (clk->autoidle_count == 1)\n\t\t\tclk->ops->deny_idle(clk);\n\n\t\tspin_unlock_irqrestore(&autoidle_spinlock, irqflags);\n\t}\n\treturn 0;\n}\n\nstatic int _omap2_clk_allow_idle(struct clk_hw_omap *clk)\n{\n\tif (clk->ops && clk->ops->allow_idle) {\n\t\tunsigned long irqflags;\n\n\t\tspin_lock_irqsave(&autoidle_spinlock, irqflags);\n\t\tclk->autoidle_count--;\n\t\tif (clk->autoidle_count == 0)\n\t\t\tclk->ops->allow_idle(clk);\n\n\t\tspin_unlock_irqrestore(&autoidle_spinlock, irqflags);\n\t}\n\treturn 0;\n}\n\n \nint omap2_clk_deny_idle(struct clk *clk)\n{\n\tstruct clk_hw *hw;\n\n\tif (!clk)\n\t\treturn -EINVAL;\n\n\thw = __clk_get_hw(clk);\n\n\tif (omap2_clk_is_hw_omap(hw)) {\n\t\tstruct clk_hw_omap *c = to_clk_hw_omap(hw);\n\n\t\treturn _omap2_clk_deny_idle(c);\n\t}\n\n\treturn -EINVAL;\n}\n\n \nint omap2_clk_allow_idle(struct clk *clk)\n{\n\tstruct clk_hw *hw;\n\n\tif (!clk)\n\t\treturn -EINVAL;\n\n\thw = __clk_get_hw(clk);\n\n\tif (omap2_clk_is_hw_omap(hw)) {\n\t\tstruct clk_hw_omap *c = to_clk_hw_omap(hw);\n\n\t\treturn _omap2_clk_allow_idle(c);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void _allow_autoidle(struct clk_ti_autoidle *clk)\n{\n\tu32 val;\n\n\tval = ti_clk_ll_ops->clk_readl(&clk->reg);\n\n\tif (clk->flags & AUTOIDLE_LOW)\n\t\tval &= ~(1 << clk->shift);\n\telse\n\t\tval |= (1 << clk->shift);\n\n\tti_clk_ll_ops->clk_writel(val, &clk->reg);\n}\n\nstatic void _deny_autoidle(struct clk_ti_autoidle *clk)\n{\n\tu32 val;\n\n\tval = ti_clk_ll_ops->clk_readl(&clk->reg);\n\n\tif (clk->flags & AUTOIDLE_LOW)\n\t\tval |= (1 << clk->shift);\n\telse\n\t\tval &= ~(1 << clk->shift);\n\n\tti_clk_ll_ops->clk_writel(val, &clk->reg);\n}\n\n \nstatic void _clk_generic_allow_autoidle_all(void)\n{\n\tstruct clk_ti_autoidle *c;\n\n\tlist_for_each_entry(c, &autoidle_clks, node)\n\t\t_allow_autoidle(c);\n}\n\n \nstatic void _clk_generic_deny_autoidle_all(void)\n{\n\tstruct clk_ti_autoidle *c;\n\n\tlist_for_each_entry(c, &autoidle_clks, node)\n\t\t_deny_autoidle(c);\n}\n\n \nint __init of_ti_clk_autoidle_setup(struct device_node *node)\n{\n\tu32 shift;\n\tstruct clk_ti_autoidle *clk;\n\tint ret;\n\n\t \n\tif (of_property_read_u32(node, \"ti,autoidle-shift\", &shift))\n\t\treturn 0;\n\n\tclk = kzalloc(sizeof(*clk), GFP_KERNEL);\n\n\tif (!clk)\n\t\treturn -ENOMEM;\n\n\tclk->shift = shift;\n\tclk->name = ti_dt_clk_name(node);\n\tret = ti_clk_get_reg_addr(node, 0, &clk->reg);\n\tif (ret) {\n\t\tkfree(clk);\n\t\treturn ret;\n\t}\n\n\tif (of_property_read_bool(node, \"ti,invert-autoidle-bit\"))\n\t\tclk->flags |= AUTOIDLE_LOW;\n\n\tlist_add(&clk->node, &autoidle_clks);\n\n\treturn 0;\n}\n\n \nint omap2_clk_enable_autoidle_all(void)\n{\n\tint ret;\n\n\tret = omap2_clk_for_each(_omap2_clk_allow_idle);\n\tif (ret)\n\t\treturn ret;\n\n\t_clk_generic_allow_autoidle_all();\n\n\treturn 0;\n}\n\n \nint omap2_clk_disable_autoidle_all(void)\n{\n\tint ret;\n\n\tret = omap2_clk_for_each(_omap2_clk_deny_idle);\n\tif (ret)\n\t\treturn ret;\n\n\t_clk_generic_deny_autoidle_all();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}