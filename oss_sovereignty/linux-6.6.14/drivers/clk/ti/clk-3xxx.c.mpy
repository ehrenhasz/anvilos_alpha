{
  "module_name": "clk-3xxx.c",
  "hash_id": "bd46cb21964ef163f86355385b7d054f9ec82e39d812b00c17785d60233b66ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/clk-3xxx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clk/ti.h>\n\n#include \"clock.h\"\n\n#define OMAP3430ES2_ST_DSS_IDLE_SHIFT\t\t\t1\n#define OMAP3430ES2_ST_HSOTGUSB_IDLE_SHIFT\t\t5\n#define OMAP3430ES2_ST_SSI_IDLE_SHIFT\t\t\t8\n\n#define OMAP34XX_CM_IDLEST_VAL\t\t\t\t1\n\n \n#define AM35XX_IPSS_ICK_MASK\t\t\t0xF\n#define AM35XX_IPSS_ICK_EN_ACK_OFFSET\t\t0x4\n#define AM35XX_IPSS_ICK_FCK_OFFSET\t\t0x8\n#define AM35XX_IPSS_CLK_IDLEST_VAL\t\t0\n\n#define AM35XX_ST_IPSS_SHIFT\t\t\t5\n\n \nstatic void omap3430es2_clk_ssi_find_idlest(struct clk_hw_omap *clk,\n\t\t\t\t\t    struct clk_omap_reg *idlest_reg,\n\t\t\t\t\t    u8 *idlest_bit,\n\t\t\t\t\t    u8 *idlest_val)\n{\n\tmemcpy(idlest_reg, &clk->enable_reg, sizeof(*idlest_reg));\n\tidlest_reg->offset &= ~0xf0;\n\tidlest_reg->offset |= 0x20;\n\t*idlest_bit = OMAP3430ES2_ST_SSI_IDLE_SHIFT;\n\t*idlest_val = OMAP34XX_CM_IDLEST_VAL;\n}\n\nconst struct clk_hw_omap_ops clkhwops_omap3430es2_iclk_ssi_wait = {\n\t.allow_idle\t= omap2_clkt_iclk_allow_idle,\n\t.deny_idle\t= omap2_clkt_iclk_deny_idle,\n\t.find_idlest\t= omap3430es2_clk_ssi_find_idlest,\n\t.find_companion\t= omap2_clk_dflt_find_companion,\n};\n\n \nstatic void\nomap3430es2_clk_dss_usbhost_find_idlest(struct clk_hw_omap *clk,\n\t\t\t\t\tstruct clk_omap_reg *idlest_reg,\n\t\t\t\t\tu8 *idlest_bit, u8 *idlest_val)\n{\n\tmemcpy(idlest_reg, &clk->enable_reg, sizeof(*idlest_reg));\n\n\tidlest_reg->offset &= ~0xf0;\n\tidlest_reg->offset |= 0x20;\n\t \n\t*idlest_bit = OMAP3430ES2_ST_DSS_IDLE_SHIFT;\n\t*idlest_val = OMAP34XX_CM_IDLEST_VAL;\n}\n\nconst struct clk_hw_omap_ops clkhwops_omap3430es2_dss_usbhost_wait = {\n\t.find_idlest\t= omap3430es2_clk_dss_usbhost_find_idlest,\n\t.find_companion\t= omap2_clk_dflt_find_companion,\n};\n\nconst struct clk_hw_omap_ops clkhwops_omap3430es2_iclk_dss_usbhost_wait = {\n\t.allow_idle\t= omap2_clkt_iclk_allow_idle,\n\t.deny_idle\t= omap2_clkt_iclk_deny_idle,\n\t.find_idlest\t= omap3430es2_clk_dss_usbhost_find_idlest,\n\t.find_companion\t= omap2_clk_dflt_find_companion,\n};\n\n \nstatic void\nomap3430es2_clk_hsotgusb_find_idlest(struct clk_hw_omap *clk,\n\t\t\t\t     struct clk_omap_reg *idlest_reg,\n\t\t\t\t     u8 *idlest_bit,\n\t\t\t\t     u8 *idlest_val)\n{\n\tmemcpy(idlest_reg, &clk->enable_reg, sizeof(*idlest_reg));\n\tidlest_reg->offset &= ~0xf0;\n\tidlest_reg->offset |= 0x20;\n\t*idlest_bit = OMAP3430ES2_ST_HSOTGUSB_IDLE_SHIFT;\n\t*idlest_val = OMAP34XX_CM_IDLEST_VAL;\n}\n\nconst struct clk_hw_omap_ops clkhwops_omap3430es2_iclk_hsotgusb_wait = {\n\t.allow_idle\t= omap2_clkt_iclk_allow_idle,\n\t.deny_idle\t= omap2_clkt_iclk_deny_idle,\n\t.find_idlest\t= omap3430es2_clk_hsotgusb_find_idlest,\n\t.find_companion\t= omap2_clk_dflt_find_companion,\n};\n\n \nstatic void am35xx_clk_find_idlest(struct clk_hw_omap *clk,\n\t\t\t\t   struct clk_omap_reg *idlest_reg,\n\t\t\t\t   u8 *idlest_bit,\n\t\t\t\t   u8 *idlest_val)\n{\n\tmemcpy(idlest_reg, &clk->enable_reg, sizeof(*idlest_reg));\n\t*idlest_bit = clk->enable_bit + AM35XX_IPSS_ICK_EN_ACK_OFFSET;\n\t*idlest_val = AM35XX_IPSS_CLK_IDLEST_VAL;\n}\n\n \nstatic void am35xx_clk_find_companion(struct clk_hw_omap *clk,\n\t\t\t\t      struct clk_omap_reg *other_reg,\n\t\t\t\t      u8 *other_bit)\n{\n\tmemcpy(other_reg, &clk->enable_reg, sizeof(*other_reg));\n\tif (clk->enable_bit & AM35XX_IPSS_ICK_MASK)\n\t\t*other_bit = clk->enable_bit + AM35XX_IPSS_ICK_FCK_OFFSET;\n\telse\n\t*other_bit = clk->enable_bit - AM35XX_IPSS_ICK_FCK_OFFSET;\n}\n\nconst struct clk_hw_omap_ops clkhwops_am35xx_ipss_module_wait = {\n\t.find_idlest\t= am35xx_clk_find_idlest,\n\t.find_companion\t= am35xx_clk_find_companion,\n};\n\n \nstatic void am35xx_clk_ipss_find_idlest(struct clk_hw_omap *clk,\n\t\t\t\t\tstruct clk_omap_reg *idlest_reg,\n\t\t\t\t\tu8 *idlest_bit,\n\t\t\t\t\tu8 *idlest_val)\n{\n\tmemcpy(idlest_reg, &clk->enable_reg, sizeof(*idlest_reg));\n\n\tidlest_reg->offset &= ~0xf0;\n\tidlest_reg->offset |= 0x20;\n\t*idlest_bit = AM35XX_ST_IPSS_SHIFT;\n\t*idlest_val = OMAP34XX_CM_IDLEST_VAL;\n}\n\nconst struct clk_hw_omap_ops clkhwops_am35xx_ipss_wait = {\n\t.allow_idle\t= omap2_clkt_iclk_allow_idle,\n\t.deny_idle\t= omap2_clkt_iclk_deny_idle,\n\t.find_idlest\t= am35xx_clk_ipss_find_idlest,\n\t.find_companion\t= omap2_clk_dflt_find_companion,\n};\n\nstatic struct ti_dt_clk omap3xxx_clks[] = {\n\tDT_CLK(NULL, \"timer_32k_ck\", \"omap_32k_fck\"),\n\tDT_CLK(NULL, \"timer_sys_ck\", \"sys_ck\"),\n\t{ .node_name = NULL },\n};\n\nstatic struct ti_dt_clk omap36xx_omap3430es2plus_clks[] = {\n\tDT_CLK(NULL, \"ssi_ssr_fck\", \"ssi_ssr_fck_3430es2\"),\n\tDT_CLK(NULL, \"ssi_sst_fck\", \"ssi_sst_fck_3430es2\"),\n\tDT_CLK(NULL, \"hsotgusb_ick\", \"hsotgusb_ick_3430es2\"),\n\tDT_CLK(NULL, \"ssi_ick\", \"ssi_ick_3430es2\"),\n\t{ .node_name = NULL },\n};\n\nstatic struct ti_dt_clk omap3430es1_clks[] = {\n\tDT_CLK(NULL, \"ssi_ssr_fck\", \"ssi_ssr_fck_3430es1\"),\n\tDT_CLK(NULL, \"ssi_sst_fck\", \"ssi_sst_fck_3430es1\"),\n\tDT_CLK(NULL, \"hsotgusb_ick\", \"hsotgusb_ick_3430es1\"),\n\tDT_CLK(NULL, \"ssi_ick\", \"ssi_ick_3430es1\"),\n\tDT_CLK(NULL, \"dss1_alwon_fck\", \"dss1_alwon_fck_3430es1\"),\n\tDT_CLK(NULL, \"dss_ick\", \"dss_ick_3430es1\"),\n\t{ .node_name = NULL },\n};\n\nstatic struct ti_dt_clk omap36xx_am35xx_omap3430es2plus_clks[] = {\n\tDT_CLK(NULL, \"dss1_alwon_fck\", \"dss1_alwon_fck_3430es2\"),\n\tDT_CLK(NULL, \"dss_ick\", \"dss_ick_3430es2\"),\n\t{ .node_name = NULL },\n};\n\nstatic struct ti_dt_clk am35xx_clks[] = {\n\tDT_CLK(NULL, \"hsotgusb_ick\", \"hsotgusb_ick_am35xx\"),\n\tDT_CLK(NULL, \"hsotgusb_fck\", \"hsotgusb_fck_am35xx\"),\n\tDT_CLK(NULL, \"uart4_ick\", \"uart4_ick_am35xx\"),\n\tDT_CLK(NULL, \"uart4_fck\", \"uart4_fck_am35xx\"),\n\t{ .node_name = NULL },\n};\n\nstatic const char *enable_init_clks[] = {\n\t\"sdrc_ick\",\n\t\"gpmc_fck\",\n\t\"omapctrl_ick\",\n};\n\nenum {\n\tOMAP3_SOC_AM35XX,\n\tOMAP3_SOC_OMAP3430_ES1,\n\tOMAP3_SOC_OMAP3430_ES2_PLUS,\n\tOMAP3_SOC_OMAP3630,\n};\n\n \nvoid __init omap3_clk_lock_dpll5(void)\n{\n\tstruct clk *dpll5_clk;\n\tstruct clk *dpll5_m2_clk;\n\n\t \n\tdpll5_clk = clk_get(NULL, \"dpll5_ck\");\n\tclk_set_rate(dpll5_clk, OMAP3_DPLL5_FREQ_FOR_USBHOST * 8);\n\tclk_prepare_enable(dpll5_clk);\n\n\t \n\tdpll5_m2_clk = clk_get(NULL, \"dpll5_m2_ck\");\n\tclk_prepare_enable(dpll5_m2_clk);\n\tclk_set_rate(dpll5_m2_clk, OMAP3_DPLL5_FREQ_FOR_USBHOST);\n\n\tclk_disable_unprepare(dpll5_m2_clk);\n\tclk_disable_unprepare(dpll5_clk);\n}\n\nstatic int __init omap3xxx_dt_clk_init(int soc_type)\n{\n\tif (soc_type == OMAP3_SOC_AM35XX || soc_type == OMAP3_SOC_OMAP3630 ||\n\t    soc_type == OMAP3_SOC_OMAP3430_ES1 ||\n\t    soc_type == OMAP3_SOC_OMAP3430_ES2_PLUS)\n\t\tti_dt_clocks_register(omap3xxx_clks);\n\n\tif (soc_type == OMAP3_SOC_AM35XX)\n\t\tti_dt_clocks_register(am35xx_clks);\n\n\tif (soc_type == OMAP3_SOC_OMAP3630 || soc_type == OMAP3_SOC_AM35XX ||\n\t    soc_type == OMAP3_SOC_OMAP3430_ES2_PLUS)\n\t\tti_dt_clocks_register(omap36xx_am35xx_omap3430es2plus_clks);\n\n\tif (soc_type == OMAP3_SOC_OMAP3430_ES1)\n\t\tti_dt_clocks_register(omap3430es1_clks);\n\n\tif (soc_type == OMAP3_SOC_OMAP3430_ES2_PLUS ||\n\t    soc_type == OMAP3_SOC_OMAP3630)\n\t\tti_dt_clocks_register(omap36xx_omap3430es2plus_clks);\n\n\tomap2_clk_disable_autoidle_all();\n\n\tti_clk_add_aliases();\n\n\tomap2_clk_enable_init_clocks(enable_init_clks,\n\t\t\t\t     ARRAY_SIZE(enable_init_clks));\n\n\tpr_info(\"Clocking rate (Crystal/Core/MPU): %ld.%01ld/%ld/%ld MHz\\n\",\n\t\t(clk_get_rate(clk_get_sys(NULL, \"osc_sys_ck\")) / 1000000),\n\t\t(clk_get_rate(clk_get_sys(NULL, \"osc_sys_ck\")) / 100000) % 10,\n\t\t(clk_get_rate(clk_get_sys(NULL, \"core_ck\")) / 1000000),\n\t\t(clk_get_rate(clk_get_sys(NULL, \"arm_fck\")) / 1000000));\n\n\tif (soc_type != OMAP3_SOC_OMAP3430_ES1)\n\t\tomap3_clk_lock_dpll5();\n\n\treturn 0;\n}\n\nint __init omap3430_dt_clk_init(void)\n{\n\treturn omap3xxx_dt_clk_init(OMAP3_SOC_OMAP3430_ES2_PLUS);\n}\n\nint __init omap3630_dt_clk_init(void)\n{\n\treturn omap3xxx_dt_clk_init(OMAP3_SOC_OMAP3630);\n}\n\nint __init am35xx_dt_clk_init(void)\n{\n\treturn omap3xxx_dt_clk_init(OMAP3_SOC_AM35XX);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}