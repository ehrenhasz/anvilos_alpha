{
  "module_name": "dpll3xxx.c",
  "hash_id": "12c46560cd19b0d6100fe49409592b8e1cea5ca2f142ad8dd123513e5365f680",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/dpll3xxx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/bitops.h>\n#include <linux/clkdev.h>\n#include <linux/clk/ti.h>\n\n#include \"clock.h\"\n\n \n#define DPLL_AUTOIDLE_DISABLE\t\t\t0x0\n#define DPLL_AUTOIDLE_LOW_POWER_STOP\t\t0x1\n\n#define MAX_DPLL_WAIT_TRIES\t\t1000000\n\n#define OMAP3XXX_EN_DPLL_LOCKED\t\t0x7\n\n \nstatic u32 omap3_dpll_autoidle_read(struct clk_hw_omap *clk);\nstatic void omap3_dpll_deny_idle(struct clk_hw_omap *clk);\nstatic void omap3_dpll_allow_idle(struct clk_hw_omap *clk);\n\n \n\n \nstatic void _omap3_dpll_write_clken(struct clk_hw_omap *clk, u8 clken_bits)\n{\n\tconst struct dpll_data *dd;\n\tu32 v;\n\n\tdd = clk->dpll_data;\n\n\tv = ti_clk_ll_ops->clk_readl(&dd->control_reg);\n\tv &= ~dd->enable_mask;\n\tv |= clken_bits << __ffs(dd->enable_mask);\n\tti_clk_ll_ops->clk_writel(v, &dd->control_reg);\n}\n\n \nstatic int _omap3_wait_dpll_status(struct clk_hw_omap *clk, u8 state)\n{\n\tconst struct dpll_data *dd;\n\tint i = 0;\n\tint ret = -EINVAL;\n\tconst char *clk_name;\n\n\tdd = clk->dpll_data;\n\tclk_name = clk_hw_get_name(&clk->hw);\n\n\tstate <<= __ffs(dd->idlest_mask);\n\n\twhile (((ti_clk_ll_ops->clk_readl(&dd->idlest_reg) & dd->idlest_mask)\n\t\t!= state) && i < MAX_DPLL_WAIT_TRIES) {\n\t\ti++;\n\t\tudelay(1);\n\t}\n\n\tif (i == MAX_DPLL_WAIT_TRIES) {\n\t\tpr_err(\"clock: %s failed transition to '%s'\\n\",\n\t\t       clk_name, (state) ? \"locked\" : \"bypassed\");\n\t} else {\n\t\tpr_debug(\"clock: %s transition to '%s' in %d loops\\n\",\n\t\t\t clk_name, (state) ? \"locked\" : \"bypassed\", i);\n\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic u16 _omap3_dpll_compute_freqsel(struct clk_hw_omap *clk, u8 n)\n{\n\tunsigned long fint;\n\tu16 f = 0;\n\n\tfint = clk_hw_get_rate(clk->dpll_data->clk_ref) / n;\n\n\tpr_debug(\"clock: fint is %lu\\n\", fint);\n\n\tif (fint >= 750000 && fint <= 1000000)\n\t\tf = 0x3;\n\telse if (fint > 1000000 && fint <= 1250000)\n\t\tf = 0x4;\n\telse if (fint > 1250000 && fint <= 1500000)\n\t\tf = 0x5;\n\telse if (fint > 1500000 && fint <= 1750000)\n\t\tf = 0x6;\n\telse if (fint > 1750000 && fint <= 2100000)\n\t\tf = 0x7;\n\telse if (fint > 7500000 && fint <= 10000000)\n\t\tf = 0xB;\n\telse if (fint > 10000000 && fint <= 12500000)\n\t\tf = 0xC;\n\telse if (fint > 12500000 && fint <= 15000000)\n\t\tf = 0xD;\n\telse if (fint > 15000000 && fint <= 17500000)\n\t\tf = 0xE;\n\telse if (fint > 17500000 && fint <= 21000000)\n\t\tf = 0xF;\n\telse\n\t\tpr_debug(\"clock: unknown freqsel setting for %d\\n\", n);\n\n\treturn f;\n}\n\n \nstatic int _omap3_noncore_dpll_lock(struct clk_hw_omap *clk)\n{\n\tconst struct dpll_data *dd;\n\tu8 ai;\n\tu8 state = 1;\n\tint r = 0;\n\n\tpr_debug(\"clock: locking DPLL %s\\n\", clk_hw_get_name(&clk->hw));\n\n\tdd = clk->dpll_data;\n\tstate <<= __ffs(dd->idlest_mask);\n\n\t \n\tif ((ti_clk_ll_ops->clk_readl(&dd->idlest_reg) & dd->idlest_mask) ==\n\t    state)\n\t\tgoto done;\n\n\tai = omap3_dpll_autoidle_read(clk);\n\n\tif (ai)\n\t\tomap3_dpll_deny_idle(clk);\n\n\t_omap3_dpll_write_clken(clk, DPLL_LOCKED);\n\n\tr = _omap3_wait_dpll_status(clk, 1);\n\n\tif (ai)\n\t\tomap3_dpll_allow_idle(clk);\n\ndone:\n\treturn r;\n}\n\n \nstatic int _omap3_noncore_dpll_bypass(struct clk_hw_omap *clk)\n{\n\tint r;\n\tu8 ai;\n\n\tif (!(clk->dpll_data->modes & (1 << DPLL_LOW_POWER_BYPASS)))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"clock: configuring DPLL %s for low-power bypass\\n\",\n\t\t clk_hw_get_name(&clk->hw));\n\n\tai = omap3_dpll_autoidle_read(clk);\n\n\t_omap3_dpll_write_clken(clk, DPLL_LOW_POWER_BYPASS);\n\n\tr = _omap3_wait_dpll_status(clk, 0);\n\n\tif (ai)\n\t\tomap3_dpll_allow_idle(clk);\n\n\treturn r;\n}\n\n \nstatic int _omap3_noncore_dpll_stop(struct clk_hw_omap *clk)\n{\n\tu8 ai;\n\n\tif (!(clk->dpll_data->modes & (1 << DPLL_LOW_POWER_STOP)))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"clock: stopping DPLL %s\\n\", clk_hw_get_name(&clk->hw));\n\n\tai = omap3_dpll_autoidle_read(clk);\n\n\t_omap3_dpll_write_clken(clk, DPLL_LOW_POWER_STOP);\n\n\tif (ai)\n\t\tomap3_dpll_allow_idle(clk);\n\n\treturn 0;\n}\n\n \nstatic void _lookup_dco(struct clk_hw_omap *clk, u8 *dco, u16 m, u8 n)\n{\n\tunsigned long fint, clkinp;  \n\n\tclkinp = clk_hw_get_rate(clk_hw_get_parent(&clk->hw));\n\tfint = (clkinp / n) * m;\n\n\tif (fint < 1000000000)\n\t\t*dco = 2;\n\telse\n\t\t*dco = 4;\n}\n\n \nstatic void _lookup_sddiv(struct clk_hw_omap *clk, u8 *sd_div, u16 m, u8 n)\n{\n\tunsigned long clkinp, sd;  \n\tint mod1, mod2;\n\n\tclkinp = clk_hw_get_rate(clk_hw_get_parent(&clk->hw));\n\n\t \n\tclkinp /= 100000;  \n\tmod1 = (clkinp * m) % (250 * n);\n\tsd = (clkinp * m) / (250 * n);\n\tmod2 = sd % 10;\n\tsd /= 10;\n\n\tif (mod1 || mod2)\n\t\tsd++;\n\t*sd_div = sd;\n}\n\n \nstatic void omap3_noncore_dpll_ssc_program(struct clk_hw_omap *clk)\n{\n\tstruct dpll_data *dd = clk->dpll_data;\n\tunsigned long ref_rate;\n\tu32 v, ctrl, mod_freq_divider, exponent, mantissa;\n\tu32 deltam_step, deltam_ceil;\n\n\tctrl = ti_clk_ll_ops->clk_readl(&dd->control_reg);\n\n\tif (dd->ssc_modfreq && dd->ssc_deltam) {\n\t\tctrl |= dd->ssc_enable_mask;\n\n\t\tif (dd->ssc_downspread)\n\t\t\tctrl |= dd->ssc_downspread_mask;\n\t\telse\n\t\t\tctrl &= ~dd->ssc_downspread_mask;\n\n\t\tref_rate = clk_hw_get_rate(dd->clk_ref);\n\t\tmod_freq_divider =\n\t\t    (ref_rate / dd->last_rounded_n) / (4 * dd->ssc_modfreq);\n\t\tif (dd->ssc_modfreq > (ref_rate / 70))\n\t\t\tpr_warn(\"clock: SSC modulation frequency of DPLL %s greater than %ld\\n\",\n\t\t\t\t__clk_get_name(clk->hw.clk), ref_rate / 70);\n\n\t\texponent = 0;\n\t\tmantissa = mod_freq_divider;\n\t\twhile ((mantissa > 127) && (exponent < 7)) {\n\t\t\texponent++;\n\t\t\tmantissa /= 2;\n\t\t}\n\t\tif (mantissa > 127)\n\t\t\tmantissa = 127;\n\n\t\tv = ti_clk_ll_ops->clk_readl(&dd->ssc_modfreq_reg);\n\t\tv &= ~(dd->ssc_modfreq_mant_mask | dd->ssc_modfreq_exp_mask);\n\t\tv |= mantissa << __ffs(dd->ssc_modfreq_mant_mask);\n\t\tv |= exponent << __ffs(dd->ssc_modfreq_exp_mask);\n\t\tti_clk_ll_ops->clk_writel(v, &dd->ssc_modfreq_reg);\n\n\t\tdeltam_step = dd->last_rounded_m * dd->ssc_deltam;\n\t\tdeltam_step /= 10;\n\t\tif (dd->ssc_downspread)\n\t\t\tdeltam_step /= 2;\n\n\t\tdeltam_step <<= __ffs(dd->ssc_deltam_int_mask);\n\t\tdeltam_step /= 100;\n\t\tdeltam_step /= mod_freq_divider;\n\t\tif (deltam_step > 0xFFFFF)\n\t\t\tdeltam_step = 0xFFFFF;\n\n\t\tdeltam_ceil = (deltam_step & dd->ssc_deltam_int_mask) >>\n\t\t    __ffs(dd->ssc_deltam_int_mask);\n\t\tif (deltam_step & dd->ssc_deltam_frac_mask)\n\t\t\tdeltam_ceil++;\n\n\t\tif ((dd->ssc_downspread &&\n\t\t     ((dd->last_rounded_m - (2 * deltam_ceil)) < 20 ||\n\t\t      dd->last_rounded_m > 2045)) ||\n\t\t    ((dd->last_rounded_m - deltam_ceil) < 20 ||\n\t\t     (dd->last_rounded_m + deltam_ceil) > 2045))\n\t\t\tpr_warn(\"clock: SSC multiplier of DPLL %s is out of range\\n\",\n\t\t\t\t__clk_get_name(clk->hw.clk));\n\n\t\tv = ti_clk_ll_ops->clk_readl(&dd->ssc_deltam_reg);\n\t\tv &= ~(dd->ssc_deltam_int_mask | dd->ssc_deltam_frac_mask);\n\t\tv |= deltam_step << __ffs(dd->ssc_deltam_int_mask |\n\t\t\t\t\t  dd->ssc_deltam_frac_mask);\n\t\tti_clk_ll_ops->clk_writel(v, &dd->ssc_deltam_reg);\n\t} else {\n\t\tctrl &= ~dd->ssc_enable_mask;\n\t}\n\n\tti_clk_ll_ops->clk_writel(ctrl, &dd->control_reg);\n}\n\n \nstatic int omap3_noncore_dpll_program(struct clk_hw_omap *clk, u16 freqsel)\n{\n\tstruct dpll_data *dd = clk->dpll_data;\n\tu8 dco, sd_div, ai = 0;\n\tu32 v;\n\tbool errata_i810;\n\n\t \n\t_omap3_noncore_dpll_bypass(clk);\n\n\t \n\tif (ti_clk_get_features()->flags & TI_CLK_DPLL_HAS_FREQSEL) {\n\t\tv = ti_clk_ll_ops->clk_readl(&dd->control_reg);\n\t\tv &= ~dd->freqsel_mask;\n\t\tv |= freqsel << __ffs(dd->freqsel_mask);\n\t\tti_clk_ll_ops->clk_writel(v, &dd->control_reg);\n\t}\n\n\t \n\tv = ti_clk_ll_ops->clk_readl(&dd->mult_div1_reg);\n\n\t \n\tif (dd->dcc_mask) {\n\t\tif (dd->last_rounded_rate >= dd->dcc_rate)\n\t\t\tv |= dd->dcc_mask;  \n\t\telse\n\t\t\tv &= ~dd->dcc_mask;  \n\t}\n\n\tv &= ~(dd->mult_mask | dd->div1_mask);\n\tv |= dd->last_rounded_m << __ffs(dd->mult_mask);\n\tv |= (dd->last_rounded_n - 1) << __ffs(dd->div1_mask);\n\n\t \n\tif (dd->dco_mask) {\n\t\t_lookup_dco(clk, &dco, dd->last_rounded_m, dd->last_rounded_n);\n\t\tv &= ~(dd->dco_mask);\n\t\tv |= dco << __ffs(dd->dco_mask);\n\t}\n\tif (dd->sddiv_mask) {\n\t\t_lookup_sddiv(clk, &sd_div, dd->last_rounded_m,\n\t\t\t      dd->last_rounded_n);\n\t\tv &= ~(dd->sddiv_mask);\n\t\tv |= sd_div << __ffs(dd->sddiv_mask);\n\t}\n\n\t \n\terrata_i810 = ti_clk_get_features()->flags & TI_CLK_ERRATA_I810;\n\n\tif (errata_i810) {\n\t\tai = omap3_dpll_autoidle_read(clk);\n\t\tif (ai) {\n\t\t\tomap3_dpll_deny_idle(clk);\n\n\t\t\t \n\t\t\tomap3_dpll_autoidle_read(clk);\n\t\t}\n\t}\n\n\tti_clk_ll_ops->clk_writel(v, &dd->mult_div1_reg);\n\n\t \n\tif (dd->m4xen_mask || dd->lpmode_mask) {\n\t\tv = ti_clk_ll_ops->clk_readl(&dd->control_reg);\n\n\t\tif (dd->m4xen_mask) {\n\t\t\tif (dd->last_rounded_m4xen)\n\t\t\t\tv |= dd->m4xen_mask;\n\t\t\telse\n\t\t\t\tv &= ~dd->m4xen_mask;\n\t\t}\n\n\t\tif (dd->lpmode_mask) {\n\t\t\tif (dd->last_rounded_lpmode)\n\t\t\t\tv |= dd->lpmode_mask;\n\t\t\telse\n\t\t\t\tv &= ~dd->lpmode_mask;\n\t\t}\n\n\t\tti_clk_ll_ops->clk_writel(v, &dd->control_reg);\n\t}\n\n\tif (dd->ssc_enable_mask)\n\t\tomap3_noncore_dpll_ssc_program(clk);\n\n\t \n\n\t \n\n\t_omap3_noncore_dpll_lock(clk);\n\n\tif (errata_i810 && ai)\n\t\tomap3_dpll_allow_idle(clk);\n\n\treturn 0;\n}\n\n \n\n \nunsigned long omap3_dpll_recalc(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\n\treturn omap2_get_dpll_rate(clk);\n}\n\n \n\n \nint omap3_noncore_dpll_enable(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tint r;\n\tstruct dpll_data *dd;\n\tstruct clk_hw *parent;\n\n\tdd = clk->dpll_data;\n\tif (!dd)\n\t\treturn -EINVAL;\n\n\tif (clk->clkdm) {\n\t\tr = ti_clk_ll_ops->clkdm_clk_enable(clk->clkdm, hw->clk);\n\t\tif (r) {\n\t\t\tWARN(1,\n\t\t\t     \"%s: could not enable %s's clockdomain %s: %d\\n\",\n\t\t\t     __func__, clk_hw_get_name(hw),\n\t\t\t     clk->clkdm_name, r);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tparent = clk_hw_get_parent(hw);\n\n\tif (clk_hw_get_rate(hw) == clk_hw_get_rate(dd->clk_bypass)) {\n\t\tWARN_ON(parent != dd->clk_bypass);\n\t\tr = _omap3_noncore_dpll_bypass(clk);\n\t} else {\n\t\tWARN_ON(parent != dd->clk_ref);\n\t\tr = _omap3_noncore_dpll_lock(clk);\n\t}\n\n\treturn r;\n}\n\n \nvoid omap3_noncore_dpll_disable(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\n\t_omap3_noncore_dpll_stop(clk);\n\tif (clk->clkdm)\n\t\tti_clk_ll_ops->clkdm_clk_disable(clk->clkdm, hw->clk);\n}\n\n \n\n \nint omap3_noncore_dpll_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tstruct dpll_data *dd;\n\n\tif (!req->rate)\n\t\treturn -EINVAL;\n\n\tdd = clk->dpll_data;\n\tif (!dd)\n\t\treturn -EINVAL;\n\n\tif (clk_hw_get_rate(dd->clk_bypass) == req->rate &&\n\t    (dd->modes & (1 << DPLL_LOW_POWER_BYPASS))) {\n\t\treq->best_parent_hw = dd->clk_bypass;\n\t} else {\n\t\treq->rate = omap2_dpll_round_rate(hw, req->rate,\n\t\t\t\t\t  &req->best_parent_rate);\n\t\treq->best_parent_hw = dd->clk_ref;\n\t}\n\n\treq->best_parent_rate = req->rate;\n\n\treturn 0;\n}\n\n \nint omap3_noncore_dpll_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tint ret;\n\n\tif (!hw)\n\t\treturn -EINVAL;\n\n\tif (index)\n\t\tret = _omap3_noncore_dpll_bypass(clk);\n\telse\n\t\tret = _omap3_noncore_dpll_lock(clk);\n\n\treturn ret;\n}\n\n \nint omap3_noncore_dpll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tstruct dpll_data *dd;\n\tu16 freqsel = 0;\n\tint ret;\n\n\tif (!hw || !rate)\n\t\treturn -EINVAL;\n\n\tdd = clk->dpll_data;\n\tif (!dd)\n\t\treturn -EINVAL;\n\n\tif (clk_hw_get_parent(hw) != dd->clk_ref)\n\t\treturn -EINVAL;\n\n\tif (dd->last_rounded_rate == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (ti_clk_get_features()->flags & TI_CLK_DPLL_HAS_FREQSEL) {\n\t\tfreqsel = _omap3_dpll_compute_freqsel(clk, dd->last_rounded_n);\n\t\tWARN_ON(!freqsel);\n\t}\n\n\tpr_debug(\"%s: %s: set rate: locking rate to %lu.\\n\", __func__,\n\t\t clk_hw_get_name(hw), rate);\n\n\tret = omap3_noncore_dpll_program(clk, freqsel);\n\n\treturn ret;\n}\n\n \nint omap3_noncore_dpll_set_rate_and_parent(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long rate,\n\t\t\t\t\t   unsigned long parent_rate,\n\t\t\t\t\t   u8 index)\n{\n\tint ret;\n\n\tif (!hw || !rate)\n\t\treturn -EINVAL;\n\n\t \n\tif (index)\n\t\tret = omap3_noncore_dpll_set_parent(hw, index);\n\telse\n\t\tret = omap3_noncore_dpll_set_rate(hw, rate, parent_rate);\n\n\treturn ret;\n}\n\n \n\n \nstatic u32 omap3_dpll_autoidle_read(struct clk_hw_omap *clk)\n{\n\tconst struct dpll_data *dd;\n\tu32 v;\n\n\tif (!clk || !clk->dpll_data)\n\t\treturn -EINVAL;\n\n\tdd = clk->dpll_data;\n\n\tif (!dd->autoidle_mask)\n\t\treturn -EINVAL;\n\n\tv = ti_clk_ll_ops->clk_readl(&dd->autoidle_reg);\n\tv &= dd->autoidle_mask;\n\tv >>= __ffs(dd->autoidle_mask);\n\n\treturn v;\n}\n\n \nstatic void omap3_dpll_allow_idle(struct clk_hw_omap *clk)\n{\n\tconst struct dpll_data *dd;\n\tu32 v;\n\n\tif (!clk || !clk->dpll_data)\n\t\treturn;\n\n\tdd = clk->dpll_data;\n\n\tif (!dd->autoidle_mask)\n\t\treturn;\n\n\t \n\tv = ti_clk_ll_ops->clk_readl(&dd->autoidle_reg);\n\tv &= ~dd->autoidle_mask;\n\tv |= DPLL_AUTOIDLE_LOW_POWER_STOP << __ffs(dd->autoidle_mask);\n\tti_clk_ll_ops->clk_writel(v, &dd->autoidle_reg);\n}\n\n \nstatic void omap3_dpll_deny_idle(struct clk_hw_omap *clk)\n{\n\tconst struct dpll_data *dd;\n\tu32 v;\n\n\tif (!clk || !clk->dpll_data)\n\t\treturn;\n\n\tdd = clk->dpll_data;\n\n\tif (!dd->autoidle_mask)\n\t\treturn;\n\n\tv = ti_clk_ll_ops->clk_readl(&dd->autoidle_reg);\n\tv &= ~dd->autoidle_mask;\n\tv |= DPLL_AUTOIDLE_DISABLE << __ffs(dd->autoidle_mask);\n\tti_clk_ll_ops->clk_writel(v, &dd->autoidle_reg);\n}\n\n \n\n \nstatic struct clk_hw_omap *omap3_find_clkoutx2_dpll(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *pclk = NULL;\n\n\t \n\tdo {\n\t\tdo {\n\t\t\thw = clk_hw_get_parent(hw);\n\t\t} while (hw && (!omap2_clk_is_hw_omap(hw)));\n\t\tif (!hw)\n\t\t\tbreak;\n\t\tpclk = to_clk_hw_omap(hw);\n\t} while (pclk && !pclk->dpll_data);\n\n\t \n\tif (!pclk) {\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\treturn pclk;\n}\n\n \nunsigned long omap3_clkoutx2_recalc(struct clk_hw *hw,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tconst struct dpll_data *dd;\n\tunsigned long rate;\n\tu32 v;\n\tstruct clk_hw_omap *pclk = NULL;\n\n\tif (!parent_rate)\n\t\treturn 0;\n\n\tpclk = omap3_find_clkoutx2_dpll(hw);\n\n\tif (!pclk)\n\t\treturn 0;\n\n\tdd = pclk->dpll_data;\n\n\tWARN_ON(!dd->enable_mask);\n\n\tv = ti_clk_ll_ops->clk_readl(&dd->control_reg) & dd->enable_mask;\n\tv >>= __ffs(dd->enable_mask);\n\tif ((v != OMAP3XXX_EN_DPLL_LOCKED) || (dd->flags & DPLL_J_TYPE))\n\t\trate = parent_rate;\n\telse\n\t\trate = parent_rate * 2;\n\treturn rate;\n}\n\n \nint omap3_core_dpll_save_context(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tstruct dpll_data *dd;\n\tu32 v;\n\n\tdd = clk->dpll_data;\n\n\tv = ti_clk_ll_ops->clk_readl(&dd->control_reg);\n\tclk->context = (v & dd->enable_mask) >> __ffs(dd->enable_mask);\n\n\tif (clk->context == DPLL_LOCKED) {\n\t\tv = ti_clk_ll_ops->clk_readl(&dd->mult_div1_reg);\n\t\tdd->last_rounded_m = (v & dd->mult_mask) >>\n\t\t\t\t\t\t__ffs(dd->mult_mask);\n\t\tdd->last_rounded_n = ((v & dd->div1_mask) >>\n\t\t\t\t\t\t__ffs(dd->div1_mask)) + 1;\n\t}\n\n\treturn 0;\n}\n\n \nvoid omap3_core_dpll_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tconst struct dpll_data *dd;\n\tu32 v;\n\n\tdd = clk->dpll_data;\n\n\tif (clk->context == DPLL_LOCKED) {\n\t\t_omap3_dpll_write_clken(clk, 0x4);\n\t\t_omap3_wait_dpll_status(clk, 0);\n\n\t\tv = ti_clk_ll_ops->clk_readl(&dd->mult_div1_reg);\n\t\tv &= ~(dd->mult_mask | dd->div1_mask);\n\t\tv |= dd->last_rounded_m << __ffs(dd->mult_mask);\n\t\tv |= (dd->last_rounded_n - 1) << __ffs(dd->div1_mask);\n\t\tti_clk_ll_ops->clk_writel(v, &dd->mult_div1_reg);\n\n\t\t_omap3_dpll_write_clken(clk, DPLL_LOCKED);\n\t\t_omap3_wait_dpll_status(clk, 1);\n\t} else {\n\t\t_omap3_dpll_write_clken(clk, clk->context);\n\t}\n}\n\n \nint omap3_noncore_dpll_save_context(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tstruct dpll_data *dd;\n\tu32 v;\n\n\tdd = clk->dpll_data;\n\n\tv = ti_clk_ll_ops->clk_readl(&dd->control_reg);\n\tclk->context = (v & dd->enable_mask) >> __ffs(dd->enable_mask);\n\n\tif (clk->context == DPLL_LOCKED) {\n\t\tv = ti_clk_ll_ops->clk_readl(&dd->mult_div1_reg);\n\t\tdd->last_rounded_m = (v & dd->mult_mask) >>\n\t\t\t\t\t\t__ffs(dd->mult_mask);\n\t\tdd->last_rounded_n = ((v & dd->div1_mask) >>\n\t\t\t\t\t\t__ffs(dd->div1_mask)) + 1;\n\t}\n\n\treturn 0;\n}\n\n \nvoid omap3_noncore_dpll_restore_context(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tconst struct dpll_data *dd;\n\tu32 ctrl, mult_div1;\n\n\tdd = clk->dpll_data;\n\n\tctrl = ti_clk_ll_ops->clk_readl(&dd->control_reg);\n\tmult_div1 = ti_clk_ll_ops->clk_readl(&dd->mult_div1_reg);\n\n\tif (clk->context == ((ctrl & dd->enable_mask) >>\n\t\t\t     __ffs(dd->enable_mask)) &&\n\t    dd->last_rounded_m == ((mult_div1 & dd->mult_mask) >>\n\t\t\t\t   __ffs(dd->mult_mask)) &&\n\t    dd->last_rounded_n == ((mult_div1 & dd->div1_mask) >>\n\t\t\t\t   __ffs(dd->div1_mask)) + 1) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (clk->context == DPLL_LOCKED)\n\t\tomap3_noncore_dpll_program(clk, 0);\n\telse\n\t\t_omap3_dpll_write_clken(clk, clk->context);\n}\n\n \nconst struct clk_hw_omap_ops clkhwops_omap3_dpll = {\n\t.allow_idle\t= omap3_dpll_allow_idle,\n\t.deny_idle\t= omap3_dpll_deny_idle,\n};\n\n \nint omap3_dpll4_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t unsigned long parent_rate)\n{\n\t \n\tif (ti_clk_get_features()->flags & TI_CLK_DPLL4_DENY_REPROGRAM) {\n\t\tpr_err(\"clock: DPLL4 cannot change rate due to silicon 'Limitation 2.5' on 3430ES1.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn omap3_noncore_dpll_set_rate(hw, rate, parent_rate);\n}\n\n \nint omap3_dpll4_set_rate_and_parent(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long parent_rate, u8 index)\n{\n\tif (ti_clk_get_features()->flags & TI_CLK_DPLL4_DENY_REPROGRAM) {\n\t\tpr_err(\"clock: DPLL4 cannot change rate due to silicon 'Limitation 2.5' on 3430ES1.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn omap3_noncore_dpll_set_rate_and_parent(hw, rate, parent_rate,\n\t\t\t\t\t\t      index);\n}\n\n \nstatic bool omap3_dpll5_apply_errata(struct clk_hw *hw,\n\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct omap3_dpll5_settings {\n\t\tunsigned int rate, m, n;\n\t};\n\n\tstatic const struct omap3_dpll5_settings precomputed[] = {\n\t\t \n\t\t{ 12000000,  80,  0 + 1 },\n\t\t{ 13000000, 443,  5 + 1 },\n\t\t{ 19200000,  50,  0 + 1 },\n\t\t{ 26000000, 443, 11 + 1 },\n\t\t{ 38400000,  25,  0 + 1 }\n\t};\n\n\tconst struct omap3_dpll5_settings *d;\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tstruct dpll_data *dd;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(precomputed); ++i) {\n\t\tif (parent_rate == precomputed[i].rate)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(precomputed))\n\t\treturn false;\n\n\td = &precomputed[i];\n\n\t \n\tdd = clk->dpll_data;\n\tdd->last_rounded_m = d->m;\n\tdd->last_rounded_n = d->n;\n\tdd->last_rounded_rate = div_u64((u64)parent_rate * d->m, d->n);\n\tomap3_noncore_dpll_program(clk, 0);\n\n\treturn true;\n}\n\n \nint omap3_dpll5_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t unsigned long parent_rate)\n{\n\tif (rate == OMAP3_DPLL5_FREQ_FOR_USBHOST * 8) {\n\t\tif (omap3_dpll5_apply_errata(hw, parent_rate))\n\t\t\treturn 0;\n\t}\n\n\treturn omap3_noncore_dpll_set_rate(hw, rate, parent_rate);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}