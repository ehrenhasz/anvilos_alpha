{
  "module_name": "composite.c",
  "hash_id": "0c3fba4eb5788ce073ed66035cb62976af4c53d813cbe220b7d918dec886e168",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/composite.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/clk/ti.h>\n#include <linux/list.h>\n\n#include \"clock.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\nstatic unsigned long ti_composite_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\treturn ti_clk_divider_ops.recalc_rate(hw, parent_rate);\n}\n\nstatic long ti_composite_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *prate)\n{\n\treturn -EINVAL;\n}\n\nstatic int ti_composite_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long parent_rate)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct clk_ops ti_composite_divider_ops = {\n\t.recalc_rate\t= &ti_composite_recalc_rate,\n\t.round_rate\t= &ti_composite_round_rate,\n\t.set_rate\t= &ti_composite_set_rate,\n};\n\nstatic const struct clk_ops ti_composite_gate_ops = {\n\t.enable\t\t= &omap2_dflt_clk_enable,\n\t.disable\t= &omap2_dflt_clk_disable,\n\t.is_enabled\t= &omap2_dflt_clk_is_enabled,\n};\n\nstruct component_clk {\n\tint num_parents;\n\tconst char **parent_names;\n\tstruct device_node *node;\n\tint type;\n\tstruct clk_hw *hw;\n\tstruct list_head link;\n};\n\nstatic const char * const component_clk_types[] __initconst = {\n\t\"gate\", \"divider\", \"mux\"\n};\n\nstatic LIST_HEAD(component_clks);\n\nstatic struct device_node *_get_component_node(struct device_node *node, int i)\n{\n\tint rc;\n\tstruct of_phandle_args clkspec;\n\n\trc = of_parse_phandle_with_args(node, \"clocks\", \"#clock-cells\", i,\n\t\t\t\t\t&clkspec);\n\tif (rc)\n\t\treturn NULL;\n\n\treturn clkspec.np;\n}\n\nstatic struct component_clk *_lookup_component(struct device_node *node)\n{\n\tstruct component_clk *comp;\n\n\tlist_for_each_entry(comp, &component_clks, link) {\n\t\tif (comp->node == node)\n\t\t\treturn comp;\n\t}\n\treturn NULL;\n}\n\nstruct clk_hw_omap_comp {\n\tstruct clk_hw hw;\n\tstruct device_node *comp_nodes[CLK_COMPONENT_TYPE_MAX];\n\tstruct component_clk *comp_clks[CLK_COMPONENT_TYPE_MAX];\n};\n\nstatic inline struct clk_hw *_get_hw(struct clk_hw_omap_comp *clk, int idx)\n{\n\tif (!clk)\n\t\treturn NULL;\n\n\tif (!clk->comp_clks[idx])\n\t\treturn NULL;\n\n\treturn clk->comp_clks[idx]->hw;\n}\n\n#define to_clk_hw_comp(_hw) container_of(_hw, struct clk_hw_omap_comp, hw)\n\nstatic void __init _register_composite(void *user,\n\t\t\t\t       struct device_node *node)\n{\n\tstruct clk_hw *hw = user;\n\tstruct clk *clk;\n\tstruct clk_hw_omap_comp *cclk = to_clk_hw_comp(hw);\n\tstruct component_clk *comp;\n\tint num_parents = 0;\n\tconst char **parent_names = NULL;\n\tconst char *name;\n\tint i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < CLK_COMPONENT_TYPE_MAX; i++) {\n\t\tif (!cclk->comp_nodes[i])\n\t\t\tcontinue;\n\n\t\tcomp = _lookup_component(cclk->comp_nodes[i]);\n\t\tif (!comp) {\n\t\t\tpr_debug(\"component %s not ready for %pOFn, retry\\n\",\n\t\t\t\t cclk->comp_nodes[i]->name, node);\n\t\t\tif (!ti_clk_retry_init(node, hw,\n\t\t\t\t\t       _register_composite))\n\t\t\t\treturn;\n\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (cclk->comp_clks[comp->type] != NULL) {\n\t\t\tpr_err(\"duplicate component types for %pOFn (%s)!\\n\",\n\t\t\t       node, component_clk_types[comp->type]);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tcclk->comp_clks[comp->type] = comp;\n\n\t\t \n\t\tcclk->comp_nodes[i] = NULL;\n\t}\n\n\t \n\tfor (i = CLK_COMPONENT_TYPE_MAX - 1; i >= 0; i--) {\n\t\tcomp = cclk->comp_clks[i];\n\t\tif (!comp)\n\t\t\tcontinue;\n\t\tif (comp->num_parents) {\n\t\t\tnum_parents = comp->num_parents;\n\t\t\tparent_names = comp->parent_names;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!num_parents) {\n\t\tpr_err(\"%s: no parents found for %pOFn!\\n\", __func__, node);\n\t\tgoto cleanup;\n\t}\n\n\tname = ti_dt_clk_name(node);\n\tclk = clk_register_composite(NULL, name,\n\t\t\t\t     parent_names, num_parents,\n\t\t\t\t     _get_hw(cclk, CLK_COMPONENT_TYPE_MUX),\n\t\t\t\t     &ti_clk_mux_ops,\n\t\t\t\t     _get_hw(cclk, CLK_COMPONENT_TYPE_DIVIDER),\n\t\t\t\t     &ti_composite_divider_ops,\n\t\t\t\t     _get_hw(cclk, CLK_COMPONENT_TYPE_GATE),\n\t\t\t\t     &ti_composite_gate_ops, 0);\n\n\tif (!IS_ERR(clk)) {\n\t\tret = ti_clk_add_alias(clk, name);\n\t\tif (ret) {\n\t\t\tclk_unregister(clk);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\t}\n\ncleanup:\n\t \n\tfor (i = 0; i < CLK_COMPONENT_TYPE_MAX; i++) {\n\t\tif (!cclk->comp_clks[i])\n\t\t\tcontinue;\n\t\tlist_del(&cclk->comp_clks[i]->link);\n\t\tkfree(cclk->comp_clks[i]->parent_names);\n\t\tkfree(cclk->comp_clks[i]);\n\t}\n\n\tkfree(cclk);\n}\n\nstatic void __init of_ti_composite_clk_setup(struct device_node *node)\n{\n\tunsigned int num_clks;\n\tint i;\n\tstruct clk_hw_omap_comp *cclk;\n\n\t \n\tnum_clks = of_clk_get_parent_count(node);\n\n\tif (!num_clks) {\n\t\tpr_err(\"composite clk %pOFn must have component(s)\\n\", node);\n\t\treturn;\n\t}\n\n\tcclk = kzalloc(sizeof(*cclk), GFP_KERNEL);\n\tif (!cclk)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < num_clks; i++)\n\t\tcclk->comp_nodes[i] = _get_component_node(node, i);\n\n\t_register_composite(&cclk->hw, node);\n}\nCLK_OF_DECLARE(ti_composite_clock, \"ti,composite-clock\",\n\t       of_ti_composite_clk_setup);\n\n \nint __init ti_clk_add_component(struct device_node *node, struct clk_hw *hw,\n\t\t\t\tint type)\n{\n\tunsigned int num_parents;\n\tconst char **parent_names;\n\tstruct component_clk *clk;\n\n\tnum_parents = of_clk_get_parent_count(node);\n\n\tif (!num_parents) {\n\t\tpr_err(\"component-clock %pOFn must have parent(s)\\n\", node);\n\t\treturn -EINVAL;\n\t}\n\n\tparent_names = kcalloc(num_parents, sizeof(char *), GFP_KERNEL);\n\tif (!parent_names)\n\t\treturn -ENOMEM;\n\n\tof_clk_parent_fill(node, parent_names, num_parents);\n\n\tclk = kzalloc(sizeof(*clk), GFP_KERNEL);\n\tif (!clk) {\n\t\tkfree(parent_names);\n\t\treturn -ENOMEM;\n\t}\n\n\tclk->num_parents = num_parents;\n\tclk->parent_names = parent_names;\n\tclk->hw = hw;\n\tclk->node = node;\n\tclk->type = type;\n\tlist_add(&clk->link, &component_clks);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}