{
  "module_name": "clk-dra7-atl.c",
  "hash_id": "fe16ffb41a6169fb888ecd883f2d04130d380da04d4aff5f3bb9ae6a11c93dc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/clk-dra7-atl.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/clk/ti.h>\n\n#include \"clock.h\"\n\n#define DRA7_ATL_INSTANCES\t4\n\n#define DRA7_ATL_PPMR_REG(id)\t\t(0x200 + (id * 0x80))\n#define DRA7_ATL_BBSR_REG(id)\t\t(0x204 + (id * 0x80))\n#define DRA7_ATL_ATLCR_REG(id)\t\t(0x208 + (id * 0x80))\n#define DRA7_ATL_SWEN_REG(id)\t\t(0x210 + (id * 0x80))\n#define DRA7_ATL_BWSMUX_REG(id)\t\t(0x214 + (id * 0x80))\n#define DRA7_ATL_AWSMUX_REG(id)\t\t(0x218 + (id * 0x80))\n#define DRA7_ATL_PCLKMUX_REG(id)\t(0x21c + (id * 0x80))\n\n#define DRA7_ATL_SWEN\t\t\tBIT(0)\n#define DRA7_ATL_DIVIDER_MASK\t\t(0x1f)\n#define DRA7_ATL_PCLKMUX\t\tBIT(0)\nstruct dra7_atl_clock_info;\n\nstruct dra7_atl_desc {\n\tstruct clk *clk;\n\tstruct clk_hw hw;\n\tstruct dra7_atl_clock_info *cinfo;\n\tint id;\n\n\tbool probed;\t\t \n\tbool valid;\t\t \n\tbool enabled;\n\tu32 bws;\t\t \n\tu32 aws;\t\t \n\tu32 divider;\t\t \n};\n\nstruct dra7_atl_clock_info {\n\tstruct device *dev;\n\tvoid __iomem *iobase;\n\n\tstruct dra7_atl_desc *cdesc;\n};\n\n#define to_atl_desc(_hw)\tcontainer_of(_hw, struct dra7_atl_desc, hw)\n\nstatic inline void atl_write(struct dra7_atl_clock_info *cinfo, u32 reg,\n\t\t\t     u32 val)\n{\n\t__raw_writel(val, cinfo->iobase + reg);\n}\n\nstatic inline int atl_read(struct dra7_atl_clock_info *cinfo, u32 reg)\n{\n\treturn __raw_readl(cinfo->iobase + reg);\n}\n\nstatic int atl_clk_enable(struct clk_hw *hw)\n{\n\tstruct dra7_atl_desc *cdesc = to_atl_desc(hw);\n\n\tif (!cdesc->probed)\n\t\tgoto out;\n\n\tif (unlikely(!cdesc->valid))\n\t\tdev_warn(cdesc->cinfo->dev, \"atl%d has not been configured\\n\",\n\t\t\t cdesc->id);\n\tpm_runtime_get_sync(cdesc->cinfo->dev);\n\n\tatl_write(cdesc->cinfo, DRA7_ATL_ATLCR_REG(cdesc->id),\n\t\t  cdesc->divider - 1);\n\tatl_write(cdesc->cinfo, DRA7_ATL_SWEN_REG(cdesc->id), DRA7_ATL_SWEN);\n\nout:\n\tcdesc->enabled = true;\n\n\treturn 0;\n}\n\nstatic void atl_clk_disable(struct clk_hw *hw)\n{\n\tstruct dra7_atl_desc *cdesc = to_atl_desc(hw);\n\n\tif (!cdesc->probed)\n\t\tgoto out;\n\n\tatl_write(cdesc->cinfo, DRA7_ATL_SWEN_REG(cdesc->id), 0);\n\tpm_runtime_put_sync(cdesc->cinfo->dev);\n\nout:\n\tcdesc->enabled = false;\n}\n\nstatic int atl_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct dra7_atl_desc *cdesc = to_atl_desc(hw);\n\n\treturn cdesc->enabled;\n}\n\nstatic unsigned long atl_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct dra7_atl_desc *cdesc = to_atl_desc(hw);\n\n\treturn parent_rate / cdesc->divider;\n}\n\nstatic long atl_clk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\tunsigned divider;\n\n\tdivider = (*parent_rate + rate / 2) / rate;\n\tif (divider > DRA7_ATL_DIVIDER_MASK + 1)\n\t\tdivider = DRA7_ATL_DIVIDER_MASK + 1;\n\n\treturn *parent_rate / divider;\n}\n\nstatic int atl_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct dra7_atl_desc *cdesc;\n\tu32 divider;\n\n\tif (!hw || !rate)\n\t\treturn -EINVAL;\n\n\tcdesc = to_atl_desc(hw);\n\tdivider = ((parent_rate + rate / 2) / rate) - 1;\n\tif (divider > DRA7_ATL_DIVIDER_MASK)\n\t\tdivider = DRA7_ATL_DIVIDER_MASK;\n\n\tcdesc->divider = divider + 1;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops atl_clk_ops = {\n\t.enable\t\t= atl_clk_enable,\n\t.disable\t= atl_clk_disable,\n\t.is_enabled\t= atl_clk_is_enabled,\n\t.recalc_rate\t= atl_clk_recalc_rate,\n\t.round_rate\t= atl_clk_round_rate,\n\t.set_rate\t= atl_clk_set_rate,\n};\n\nstatic void __init of_dra7_atl_clock_setup(struct device_node *node)\n{\n\tstruct dra7_atl_desc *clk_hw = NULL;\n\tstruct clk_parent_data pdata = { .index = 0 };\n\tstruct clk_init_data init = { NULL };\n\tconst char *name;\n\tstruct clk *clk;\n\n\tclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\n\tif (!clk_hw) {\n\t\tpr_err(\"%s: could not allocate dra7_atl_desc\\n\", __func__);\n\t\treturn;\n\t}\n\n\tclk_hw->hw.init = &init;\n\tclk_hw->divider = 1;\n\tname = ti_dt_clk_name(node);\n\tinit.name = name;\n\tinit.ops = &atl_clk_ops;\n\tinit.flags = CLK_IGNORE_UNUSED;\n\tinit.num_parents = of_clk_get_parent_count(node);\n\n\tif (init.num_parents != 1) {\n\t\tpr_err(\"%s: atl clock %pOFn must have 1 parent\\n\", __func__,\n\t\t       node);\n\t\tgoto cleanup;\n\t}\n\n\tinit.parent_data = &pdata;\n\tclk = of_ti_clk_register(node, &clk_hw->hw, name);\n\n\tif (!IS_ERR(clk)) {\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\t\treturn;\n\t}\ncleanup:\n\tkfree(clk_hw);\n}\nCLK_OF_DECLARE(dra7_atl_clock, \"ti,dra7-atl-clock\", of_dra7_atl_clock_setup);\n\nstatic int of_dra7_atl_clk_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct dra7_atl_clock_info *cinfo;\n\tint i;\n\tint ret = 0;\n\n\tif (!node)\n\t\treturn -ENODEV;\n\n\tcinfo = devm_kzalloc(&pdev->dev, sizeof(*cinfo), GFP_KERNEL);\n\tif (!cinfo)\n\t\treturn -ENOMEM;\n\n\tcinfo->iobase = of_iomap(node, 0);\n\tcinfo->dev = &pdev->dev;\n\tpm_runtime_enable(cinfo->dev);\n\n\tpm_runtime_get_sync(cinfo->dev);\n\tatl_write(cinfo, DRA7_ATL_PCLKMUX_REG(0), DRA7_ATL_PCLKMUX);\n\n\tfor (i = 0; i < DRA7_ATL_INSTANCES; i++) {\n\t\tstruct device_node *cfg_node;\n\t\tchar prop[5];\n\t\tstruct dra7_atl_desc *cdesc;\n\t\tstruct of_phandle_args clkspec;\n\t\tstruct clk *clk;\n\t\tint rc;\n\n\t\trc = of_parse_phandle_with_args(node, \"ti,provided-clocks\",\n\t\t\t\t\t\tNULL, i, &clkspec);\n\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: failed to lookup atl clock %d\\n\", __func__,\n\t\t\t       i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto pm_put;\n\t\t}\n\n\t\tclk = of_clk_get_from_provider(&clkspec);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: failed to get atl clock %d from provider\\n\",\n\t\t\t       __func__, i);\n\t\t\tret = PTR_ERR(clk);\n\t\t\tgoto pm_put;\n\t\t}\n\n\t\tcdesc = to_atl_desc(__clk_get_hw(clk));\n\t\tcdesc->cinfo = cinfo;\n\t\tcdesc->id = i;\n\n\t\t \n\t\tsnprintf(prop, sizeof(prop), \"atl%u\", i);\n\t\tcfg_node = of_get_child_by_name(node, prop);\n\t\tif (cfg_node) {\n\t\t\tret = of_property_read_u32(cfg_node, \"bws\",\n\t\t\t\t\t\t   &cdesc->bws);\n\t\t\tret |= of_property_read_u32(cfg_node, \"aws\",\n\t\t\t\t\t\t    &cdesc->aws);\n\t\t\tif (!ret) {\n\t\t\t\tcdesc->valid = true;\n\t\t\t\tatl_write(cinfo, DRA7_ATL_BWSMUX_REG(i),\n\t\t\t\t\t  cdesc->bws);\n\t\t\t\tatl_write(cinfo, DRA7_ATL_AWSMUX_REG(i),\n\t\t\t\t\t  cdesc->aws);\n\t\t\t}\n\t\t\tof_node_put(cfg_node);\n\t\t}\n\n\t\tcdesc->probed = true;\n\t\t \n\t\tif (cdesc->enabled)\n\t\t\tatl_clk_enable(__clk_get_hw(clk));\n\t}\n\npm_put:\n\tpm_runtime_put_sync(cinfo->dev);\n\treturn ret;\n}\n\nstatic const struct of_device_id of_dra7_atl_clk_match_tbl[] = {\n\t{ .compatible = \"ti,dra7-atl\", },\n\t{},\n};\n\nstatic struct platform_driver dra7_atl_clk_driver = {\n\t.driver = {\n\t\t.name = \"dra7-atl\",\n\t\t.suppress_bind_attrs = true,\n\t\t.of_match_table = of_dra7_atl_clk_match_tbl,\n\t},\n\t.probe = of_dra7_atl_clk_probe,\n};\nbuiltin_platform_driver(dra7_atl_clk_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}