{
  "module_name": "clk-814x.c",
  "hash_id": "0e29e355060a48ffbd94c09b22fd975dba33c3663f27009cd0a03ac0703e11c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/clk-814x.c",
  "human_readable_source": "\n\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clk/ti.h>\n#include <linux/of_platform.h>\n#include <dt-bindings/clock/dm814.h>\n\n#include \"clock.h\"\n\nstatic const struct omap_clkctrl_reg_data dm814_default_clkctrl_regs[] __initconst = {\n\t{ DM814_USB_OTG_HS_CLKCTRL, NULL, CLKF_SW_SUP, \"pll260dcoclkldo\" },\n\t{ 0 },\n};\n\nstatic const struct omap_clkctrl_reg_data dm814_alwon_clkctrl_regs[] __initconst = {\n\t{ DM814_UART1_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk10_ck\" },\n\t{ DM814_UART2_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk10_ck\" },\n\t{ DM814_UART3_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk10_ck\" },\n\t{ DM814_GPIO1_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk6_ck\" },\n\t{ DM814_GPIO2_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk6_ck\" },\n\t{ DM814_I2C1_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk10_ck\" },\n\t{ DM814_I2C2_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk10_ck\" },\n\t{ DM814_WD_TIMER_CLKCTRL, NULL, CLKF_SW_SUP | CLKF_NO_IDLEST, \"sysclk18_ck\" },\n\t{ DM814_MCSPI1_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk10_ck\" },\n\t{ DM814_GPMC_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk6_ck\" },\n\t{ DM814_MPU_CLKCTRL, NULL, CLKF_SW_SUP, \"mpu_ck\" },\n\t{ DM814_RTC_CLKCTRL, NULL, CLKF_SW_SUP | CLKF_NO_IDLEST, \"sysclk18_ck\" },\n\t{ DM814_TPCC_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk4_ck\" },\n\t{ DM814_TPTC0_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk4_ck\" },\n\t{ DM814_TPTC1_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk4_ck\" },\n\t{ DM814_TPTC2_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk4_ck\" },\n\t{ DM814_TPTC3_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk4_ck\" },\n\t{ DM814_MMC1_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk8_ck\" },\n\t{ DM814_MMC2_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk8_ck\" },\n\t{ DM814_MMC3_CLKCTRL, NULL, CLKF_SW_SUP, \"sysclk8_ck\" },\n\t{ 0 },\n};\n\nstatic const struct\nomap_clkctrl_reg_data dm814_alwon_ethernet_clkctrl_regs[] __initconst = {\n\t{ 0, NULL, CLKF_SW_SUP, \"cpsw_125mhz_gclk\" },\n};\n\nconst struct omap_clkctrl_data dm814_clkctrl_data[] __initconst = {\n\t{ 0x48180500, dm814_default_clkctrl_regs },\n\t{ 0x48181400, dm814_alwon_clkctrl_regs },\n\t{ 0x481815d4, dm814_alwon_ethernet_clkctrl_regs },\n\t{ 0 },\n};\n\nstatic struct ti_dt_clk dm814_clks[] = {\n\tDT_CLK(NULL, \"timer_sys_ck\", \"devosc_ck\"),\n\t{ .node_name = NULL },\n};\n\nstatic bool timer_clocks_initialized;\n\nstatic int __init dm814x_adpll_early_init(void)\n{\n\tstruct device_node *np;\n\n\tif (!timer_clocks_initialized)\n\t\treturn -ENODEV;\n\n\tnp = of_find_node_by_name(NULL, \"pllss\");\n\tif (!np) {\n\t\tpr_err(\"Could not find node for plls\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tof_platform_populate(np, NULL, NULL, NULL);\n\tof_node_put(np);\n\n\treturn 0;\n}\ncore_initcall(dm814x_adpll_early_init);\n\nstatic const char * const init_clocks[] = {\n\t\"pll040clkout\",\t\t \n\t\"pll290clkout\",\t\t \n};\n\nstatic int __init dm814x_adpll_enable_init_clocks(void)\n{\n\tint i, err;\n\n\tif (!timer_clocks_initialized)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < ARRAY_SIZE(init_clocks); i++) {\n\t\tstruct clk *clock;\n\n\t\tclock = clk_get(NULL, init_clocks[i]);\n\t\tif (WARN(IS_ERR(clock), \"could not find init clock %s\\n\",\n\t\t\t init_clocks[i]))\n\t\t\tcontinue;\n\t\terr = clk_prepare_enable(clock);\n\t\tif (WARN(err, \"could not enable init clock %s\\n\",\n\t\t\t init_clocks[i]))\n\t\t\tcontinue;\n\t}\n\n\treturn 0;\n}\npostcore_initcall(dm814x_adpll_enable_init_clocks);\n\nint __init dm814x_dt_clk_init(void)\n{\n\tti_dt_clocks_register(dm814_clks);\n\tomap2_clk_disable_autoidle_all();\n\tti_clk_add_aliases();\n\tomap2_clk_enable_init_clocks(NULL, 0);\n\ttimer_clocks_initialized = true;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}