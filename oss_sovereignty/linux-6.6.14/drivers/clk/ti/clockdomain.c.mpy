{
  "module_name": "clockdomain.c",
  "hash_id": "14195e5e4515fb669a5a763e4be26debeb8d87d3efb6eabde5921f9ee6849efd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/clockdomain.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/clk/ti.h>\n\n#include \"clock.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n \nint omap2_clkops_enable_clkdm(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk;\n\tint ret = 0;\n\n\tclk = to_clk_hw_omap(hw);\n\n\tif (unlikely(!clk->clkdm)) {\n\t\tpr_err(\"%s: %s: no clkdm set ?!\\n\", __func__,\n\t\t       clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\tif (ti_clk_get_features()->flags & TI_CLK_DISABLE_CLKDM_CONTROL) {\n\t\tpr_err(\"%s: %s: clkfw-based clockdomain control disabled ?!\\n\",\n\t\t       __func__, clk_hw_get_name(hw));\n\t\treturn 0;\n\t}\n\n\tret = ti_clk_ll_ops->clkdm_clk_enable(clk->clkdm, hw->clk);\n\tWARN(ret, \"%s: could not enable %s's clockdomain %s: %d\\n\",\n\t     __func__, clk_hw_get_name(hw), clk->clkdm_name, ret);\n\n\treturn ret;\n}\n\n \nvoid omap2_clkops_disable_clkdm(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk;\n\n\tclk = to_clk_hw_omap(hw);\n\n\tif (unlikely(!clk->clkdm)) {\n\t\tpr_err(\"%s: %s: no clkdm set ?!\\n\", __func__,\n\t\t       clk_hw_get_name(hw));\n\t\treturn;\n\t}\n\n\tif (ti_clk_get_features()->flags & TI_CLK_DISABLE_CLKDM_CONTROL) {\n\t\tpr_err(\"%s: %s: clkfw-based clockdomain control disabled ?!\\n\",\n\t\t       __func__, clk_hw_get_name(hw));\n\t\treturn;\n\t}\n\n\tti_clk_ll_ops->clkdm_clk_disable(clk->clkdm, hw->clk);\n}\n\n \nint omap2_init_clk_clkdm(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tstruct clockdomain *clkdm;\n\tconst char *clk_name;\n\n\tif (!clk->clkdm_name)\n\t\treturn 0;\n\n\tclk_name = __clk_get_name(hw->clk);\n\n\tclkdm = ti_clk_ll_ops->clkdm_lookup(clk->clkdm_name);\n\tif (clkdm) {\n\t\tpr_debug(\"clock: associated clk %s to clkdm %s\\n\",\n\t\t\t clk_name, clk->clkdm_name);\n\t\tclk->clkdm = clkdm;\n\t} else {\n\t\tpr_debug(\"clock: could not associate clk %s to clkdm %s\\n\",\n\t\t\t clk_name, clk->clkdm_name);\n\t}\n\n\treturn 0;\n}\n\nstatic void __init of_ti_clockdomain_setup(struct device_node *node)\n{\n\tstruct clk *clk;\n\tstruct clk_hw *clk_hw;\n\tconst char *clkdm_name = ti_dt_clk_name(node);\n\tint i;\n\tunsigned int num_clks;\n\n\tnum_clks = of_clk_get_parent_count(node);\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tclk = of_clk_get(node, i);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: Failed get %pOF' clock nr %d (%ld)\\n\",\n\t\t\t       __func__, node, i, PTR_ERR(clk));\n\t\t\tcontinue;\n\t\t}\n\t\tclk_hw = __clk_get_hw(clk);\n\t\tif (!omap2_clk_is_hw_omap(clk_hw)) {\n\t\t\tpr_warn(\"can't setup clkdm for basic clk %s\\n\",\n\t\t\t\t__clk_get_name(clk));\n\t\t\tclk_put(clk);\n\t\t\tcontinue;\n\t\t}\n\t\tto_clk_hw_omap(clk_hw)->clkdm_name = clkdm_name;\n\t\tomap2_init_clk_clkdm(clk_hw);\n\t\tclk_put(clk);\n\t}\n}\n\nstatic const struct of_device_id ti_clkdm_match_table[] __initconst = {\n\t{ .compatible = \"ti,clockdomain\" },\n\t{ }\n};\n\n \nvoid __init ti_dt_clockdomains_setup(void)\n{\n\tstruct device_node *np;\n\tfor_each_matching_node(np, ti_clkdm_match_table) {\n\t\tof_ti_clockdomain_setup(np);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}