{
  "module_name": "apll.c",
  "hash_id": "808b2f813253f28e6bc2353599d0555616ed243546435135b1092fe0ad1e1d78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/apll.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/log2.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/clk/ti.h>\n#include <linux/delay.h>\n\n#include \"clock.h\"\n\n#define APLL_FORCE_LOCK 0x1\n#define APLL_AUTO_IDLE\t0x2\n#define MAX_APLL_WAIT_TRIES\t\t1000000\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\nstatic int dra7_apll_enable(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tint r = 0, i = 0;\n\tstruct dpll_data *ad;\n\tconst char *clk_name;\n\tu8 state = 1;\n\tu32 v;\n\n\tad = clk->dpll_data;\n\tif (!ad)\n\t\treturn -EINVAL;\n\n\tclk_name = clk_hw_get_name(&clk->hw);\n\n\tstate <<= __ffs(ad->idlest_mask);\n\n\t \n\tv = ti_clk_ll_ops->clk_readl(&ad->idlest_reg);\n\n\tif ((v & ad->idlest_mask) == state)\n\t\treturn r;\n\n\tv = ti_clk_ll_ops->clk_readl(&ad->control_reg);\n\tv &= ~ad->enable_mask;\n\tv |= APLL_FORCE_LOCK << __ffs(ad->enable_mask);\n\tti_clk_ll_ops->clk_writel(v, &ad->control_reg);\n\n\tstate <<= __ffs(ad->idlest_mask);\n\n\twhile (1) {\n\t\tv = ti_clk_ll_ops->clk_readl(&ad->idlest_reg);\n\t\tif ((v & ad->idlest_mask) == state)\n\t\t\tbreak;\n\t\tif (i > MAX_APLL_WAIT_TRIES)\n\t\t\tbreak;\n\t\ti++;\n\t\tudelay(1);\n\t}\n\n\tif (i == MAX_APLL_WAIT_TRIES) {\n\t\tpr_warn(\"clock: %s failed transition to '%s'\\n\",\n\t\t\tclk_name, (state) ? \"locked\" : \"bypassed\");\n\t\tr = -EBUSY;\n\t} else\n\t\tpr_debug(\"clock: %s transition to '%s' in %d loops\\n\",\n\t\t\t clk_name, (state) ? \"locked\" : \"bypassed\", i);\n\n\treturn r;\n}\n\nstatic void dra7_apll_disable(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tstruct dpll_data *ad;\n\tu8 state = 1;\n\tu32 v;\n\n\tad = clk->dpll_data;\n\n\tstate <<= __ffs(ad->idlest_mask);\n\n\tv = ti_clk_ll_ops->clk_readl(&ad->control_reg);\n\tv &= ~ad->enable_mask;\n\tv |= APLL_AUTO_IDLE << __ffs(ad->enable_mask);\n\tti_clk_ll_ops->clk_writel(v, &ad->control_reg);\n}\n\nstatic int dra7_apll_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tstruct dpll_data *ad;\n\tu32 v;\n\n\tad = clk->dpll_data;\n\n\tv = ti_clk_ll_ops->clk_readl(&ad->control_reg);\n\tv &= ad->enable_mask;\n\n\tv >>= __ffs(ad->enable_mask);\n\n\treturn v == APLL_AUTO_IDLE ? 0 : 1;\n}\n\nstatic u8 dra7_init_apll_parent(struct clk_hw *hw)\n{\n\treturn 0;\n}\n\nstatic const struct clk_ops apll_ck_ops = {\n\t.enable\t\t= &dra7_apll_enable,\n\t.disable\t= &dra7_apll_disable,\n\t.is_enabled\t= &dra7_apll_is_enabled,\n\t.get_parent\t= &dra7_init_apll_parent,\n};\n\nstatic void __init omap_clk_register_apll(void *user,\n\t\t\t\t\t  struct device_node *node)\n{\n\tstruct clk_hw *hw = user;\n\tstruct clk_hw_omap *clk_hw = to_clk_hw_omap(hw);\n\tstruct dpll_data *ad = clk_hw->dpll_data;\n\tconst char *name;\n\tstruct clk *clk;\n\tconst struct clk_init_data *init = clk_hw->hw.init;\n\n\tclk = of_clk_get(node, 0);\n\tif (IS_ERR(clk)) {\n\t\tpr_debug(\"clk-ref for %pOFn not ready, retry\\n\",\n\t\t\t node);\n\t\tif (!ti_clk_retry_init(node, hw, omap_clk_register_apll))\n\t\t\treturn;\n\n\t\tgoto cleanup;\n\t}\n\n\tad->clk_ref = __clk_get_hw(clk);\n\n\tclk = of_clk_get(node, 1);\n\tif (IS_ERR(clk)) {\n\t\tpr_debug(\"clk-bypass for %pOFn not ready, retry\\n\",\n\t\t\t node);\n\t\tif (!ti_clk_retry_init(node, hw, omap_clk_register_apll))\n\t\t\treturn;\n\n\t\tgoto cleanup;\n\t}\n\n\tad->clk_bypass = __clk_get_hw(clk);\n\n\tname = ti_dt_clk_name(node);\n\tclk = of_ti_clk_register_omap_hw(node, &clk_hw->hw, name);\n\tif (!IS_ERR(clk)) {\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\t\tkfree(init->parent_names);\n\t\tkfree(init);\n\t\treturn;\n\t}\n\ncleanup:\n\tkfree(clk_hw->dpll_data);\n\tkfree(init->parent_names);\n\tkfree(init);\n\tkfree(clk_hw);\n}\n\nstatic void __init of_dra7_apll_setup(struct device_node *node)\n{\n\tstruct dpll_data *ad = NULL;\n\tstruct clk_hw_omap *clk_hw = NULL;\n\tstruct clk_init_data *init = NULL;\n\tconst char **parent_names = NULL;\n\tint ret;\n\n\tad = kzalloc(sizeof(*ad), GFP_KERNEL);\n\tclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\n\tinit = kzalloc(sizeof(*init), GFP_KERNEL);\n\tif (!ad || !clk_hw || !init)\n\t\tgoto cleanup;\n\n\tclk_hw->dpll_data = ad;\n\tclk_hw->hw.init = init;\n\n\tinit->name = ti_dt_clk_name(node);\n\tinit->ops = &apll_ck_ops;\n\n\tinit->num_parents = of_clk_get_parent_count(node);\n\tif (init->num_parents < 1) {\n\t\tpr_err(\"dra7 apll %pOFn must have parent(s)\\n\", node);\n\t\tgoto cleanup;\n\t}\n\n\tparent_names = kcalloc(init->num_parents, sizeof(char *), GFP_KERNEL);\n\tif (!parent_names)\n\t\tgoto cleanup;\n\n\tof_clk_parent_fill(node, parent_names, init->num_parents);\n\n\tinit->parent_names = parent_names;\n\n\tret = ti_clk_get_reg_addr(node, 0, &ad->control_reg);\n\tret |= ti_clk_get_reg_addr(node, 1, &ad->idlest_reg);\n\n\tif (ret)\n\t\tgoto cleanup;\n\n\tad->idlest_mask = 0x1;\n\tad->enable_mask = 0x3;\n\n\tomap_clk_register_apll(&clk_hw->hw, node);\n\treturn;\n\ncleanup:\n\tkfree(parent_names);\n\tkfree(ad);\n\tkfree(clk_hw);\n\tkfree(init);\n}\nCLK_OF_DECLARE(dra7_apll_clock, \"ti,dra7-apll-clock\", of_dra7_apll_setup);\n\n#define OMAP2_EN_APLL_LOCKED\t0x3\n#define OMAP2_EN_APLL_STOPPED\t0x0\n\nstatic int omap2_apll_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tstruct dpll_data *ad = clk->dpll_data;\n\tu32 v;\n\n\tv = ti_clk_ll_ops->clk_readl(&ad->control_reg);\n\tv &= ad->enable_mask;\n\n\tv >>= __ffs(ad->enable_mask);\n\n\treturn v == OMAP2_EN_APLL_LOCKED ? 1 : 0;\n}\n\nstatic unsigned long omap2_apll_recalc(struct clk_hw *hw,\n\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\n\tif (omap2_apll_is_enabled(hw))\n\t\treturn clk->fixed_rate;\n\n\treturn 0;\n}\n\nstatic int omap2_apll_enable(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tstruct dpll_data *ad = clk->dpll_data;\n\tu32 v;\n\tint i = 0;\n\n\tv = ti_clk_ll_ops->clk_readl(&ad->control_reg);\n\tv &= ~ad->enable_mask;\n\tv |= OMAP2_EN_APLL_LOCKED << __ffs(ad->enable_mask);\n\tti_clk_ll_ops->clk_writel(v, &ad->control_reg);\n\n\twhile (1) {\n\t\tv = ti_clk_ll_ops->clk_readl(&ad->idlest_reg);\n\t\tif (v & ad->idlest_mask)\n\t\t\tbreak;\n\t\tif (i > MAX_APLL_WAIT_TRIES)\n\t\t\tbreak;\n\t\ti++;\n\t\tudelay(1);\n\t}\n\n\tif (i == MAX_APLL_WAIT_TRIES) {\n\t\tpr_warn(\"%s failed to transition to locked\\n\",\n\t\t\tclk_hw_get_name(&clk->hw));\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic void omap2_apll_disable(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tstruct dpll_data *ad = clk->dpll_data;\n\tu32 v;\n\n\tv = ti_clk_ll_ops->clk_readl(&ad->control_reg);\n\tv &= ~ad->enable_mask;\n\tv |= OMAP2_EN_APLL_STOPPED << __ffs(ad->enable_mask);\n\tti_clk_ll_ops->clk_writel(v, &ad->control_reg);\n}\n\nstatic const struct clk_ops omap2_apll_ops = {\n\t.enable\t\t= &omap2_apll_enable,\n\t.disable\t= &omap2_apll_disable,\n\t.is_enabled\t= &omap2_apll_is_enabled,\n\t.recalc_rate\t= &omap2_apll_recalc,\n};\n\nstatic void omap2_apll_set_autoidle(struct clk_hw_omap *clk, u32 val)\n{\n\tstruct dpll_data *ad = clk->dpll_data;\n\tu32 v;\n\n\tv = ti_clk_ll_ops->clk_readl(&ad->autoidle_reg);\n\tv &= ~ad->autoidle_mask;\n\tv |= val << __ffs(ad->autoidle_mask);\n\tti_clk_ll_ops->clk_writel(v, &ad->control_reg);\n}\n\n#define OMAP2_APLL_AUTOIDLE_LOW_POWER_STOP\t0x3\n#define OMAP2_APLL_AUTOIDLE_DISABLE\t\t0x0\n\nstatic void omap2_apll_allow_idle(struct clk_hw_omap *clk)\n{\n\tomap2_apll_set_autoidle(clk, OMAP2_APLL_AUTOIDLE_LOW_POWER_STOP);\n}\n\nstatic void omap2_apll_deny_idle(struct clk_hw_omap *clk)\n{\n\tomap2_apll_set_autoidle(clk, OMAP2_APLL_AUTOIDLE_DISABLE);\n}\n\nstatic const struct clk_hw_omap_ops omap2_apll_hwops = {\n\t.allow_idle\t= &omap2_apll_allow_idle,\n\t.deny_idle\t= &omap2_apll_deny_idle,\n};\n\nstatic void __init of_omap2_apll_setup(struct device_node *node)\n{\n\tstruct dpll_data *ad = NULL;\n\tstruct clk_hw_omap *clk_hw = NULL;\n\tstruct clk_init_data *init = NULL;\n\tconst char *name;\n\tstruct clk *clk;\n\tconst char *parent_name;\n\tu32 val;\n\tint ret;\n\n\tad = kzalloc(sizeof(*ad), GFP_KERNEL);\n\tclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\n\tinit = kzalloc(sizeof(*init), GFP_KERNEL);\n\n\tif (!ad || !clk_hw || !init)\n\t\tgoto cleanup;\n\n\tclk_hw->dpll_data = ad;\n\tclk_hw->hw.init = init;\n\tinit->ops = &omap2_apll_ops;\n\tname = ti_dt_clk_name(node);\n\tinit->name = name;\n\tclk_hw->ops = &omap2_apll_hwops;\n\n\tinit->num_parents = of_clk_get_parent_count(node);\n\tif (init->num_parents != 1) {\n\t\tpr_err(\"%pOFn must have one parent\\n\", node);\n\t\tgoto cleanup;\n\t}\n\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tinit->parent_names = &parent_name;\n\n\tif (of_property_read_u32(node, \"ti,clock-frequency\", &val)) {\n\t\tpr_err(\"%pOFn missing clock-frequency\\n\", node);\n\t\tgoto cleanup;\n\t}\n\tclk_hw->fixed_rate = val;\n\n\tif (of_property_read_u32(node, \"ti,bit-shift\", &val)) {\n\t\tpr_err(\"%pOFn missing bit-shift\\n\", node);\n\t\tgoto cleanup;\n\t}\n\n\tclk_hw->enable_bit = val;\n\tad->enable_mask = 0x3 << val;\n\tad->autoidle_mask = 0x3 << val;\n\n\tif (of_property_read_u32(node, \"ti,idlest-shift\", &val)) {\n\t\tpr_err(\"%pOFn missing idlest-shift\\n\", node);\n\t\tgoto cleanup;\n\t}\n\n\tad->idlest_mask = 1 << val;\n\n\tret = ti_clk_get_reg_addr(node, 0, &ad->control_reg);\n\tret |= ti_clk_get_reg_addr(node, 1, &ad->autoidle_reg);\n\tret |= ti_clk_get_reg_addr(node, 2, &ad->idlest_reg);\n\n\tif (ret)\n\t\tgoto cleanup;\n\n\tname = ti_dt_clk_name(node);\n\tclk = of_ti_clk_register_omap_hw(node, &clk_hw->hw, name);\n\tif (!IS_ERR(clk)) {\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\t\tkfree(init);\n\t\treturn;\n\t}\ncleanup:\n\tkfree(ad);\n\tkfree(clk_hw);\n\tkfree(init);\n}\nCLK_OF_DECLARE(omap2_apll_clock, \"ti,omap2-apll-clock\",\n\t       of_omap2_apll_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}