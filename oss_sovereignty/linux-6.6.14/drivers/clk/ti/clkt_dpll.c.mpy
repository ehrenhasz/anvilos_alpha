{
  "module_name": "clkt_dpll.c",
  "hash_id": "747b95592b32f7ec002e1f3c3b520087cc34ec6ce829f0ecf924a3ce204b1ca3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/clkt_dpll.c",
  "human_readable_source": "\n \n#undef DEBUG\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/clk/ti.h>\n\n#include <asm/div64.h>\n\n#include \"clock.h\"\n\n \n#define DPLL_MIN_MULTIPLIER\t\t2\n#define DPLL_MIN_DIVIDER\t\t1\n\n \n#define DPLL_MULT_UNDERFLOW\t\t-1\n\n \n#define DPLL_SCALE_FACTOR\t\t64\n#define DPLL_SCALE_BASE\t\t\t2\n#define DPLL_ROUNDING_VAL\t\t((DPLL_SCALE_BASE / 2) * \\\n\t\t\t\t\t (DPLL_SCALE_FACTOR / DPLL_SCALE_BASE))\n\n \n#define OMAP3PLUS_DPLL_FINT_JTYPE_MIN\t500000\n#define OMAP3PLUS_DPLL_FINT_JTYPE_MAX\t2500000\n\n \n#define DPLL_FINT_UNDERFLOW\t\t-1\n#define DPLL_FINT_INVALID\t\t-2\n\n \n\n \nstatic int _dpll_test_fint(struct clk_hw_omap *clk, unsigned int n)\n{\n\tstruct dpll_data *dd;\n\tlong fint, fint_min, fint_max;\n\tint ret = 0;\n\n\tdd = clk->dpll_data;\n\n\t \n\tfint = clk_hw_get_rate(clk_hw_get_parent(&clk->hw)) / n;\n\n\tif (dd->flags & DPLL_J_TYPE) {\n\t\tfint_min = OMAP3PLUS_DPLL_FINT_JTYPE_MIN;\n\t\tfint_max = OMAP3PLUS_DPLL_FINT_JTYPE_MAX;\n\t} else {\n\t\tfint_min = ti_clk_get_features()->fint_min;\n\t\tfint_max = ti_clk_get_features()->fint_max;\n\t}\n\n\tif (!fint_min || !fint_max) {\n\t\tWARN(1, \"No fint limits available!\\n\");\n\t\treturn DPLL_FINT_INVALID;\n\t}\n\n\tif (fint < ti_clk_get_features()->fint_min) {\n\t\tpr_debug(\"rejecting n=%d due to Fint failure, lowering max_divider\\n\",\n\t\t\t n);\n\t\tdd->max_divider = n;\n\t\tret = DPLL_FINT_UNDERFLOW;\n\t} else if (fint > ti_clk_get_features()->fint_max) {\n\t\tpr_debug(\"rejecting n=%d due to Fint failure, boosting min_divider\\n\",\n\t\t\t n);\n\t\tdd->min_divider = n;\n\t\tret = DPLL_FINT_INVALID;\n\t} else if (fint > ti_clk_get_features()->fint_band1_max &&\n\t\t   fint < ti_clk_get_features()->fint_band2_min) {\n\t\tpr_debug(\"rejecting n=%d due to Fint failure\\n\", n);\n\t\tret = DPLL_FINT_INVALID;\n\t}\n\n\treturn ret;\n}\n\nstatic unsigned long _dpll_compute_new_rate(unsigned long parent_rate,\n\t\t\t\t\t    unsigned int m, unsigned int n)\n{\n\tunsigned long long num;\n\n\tnum = (unsigned long long)parent_rate * m;\n\tdo_div(num, n);\n\treturn num;\n}\n\n \nstatic int _dpll_test_mult(int *m, int n, unsigned long *new_rate,\n\t\t\t   unsigned long target_rate,\n\t\t\t   unsigned long parent_rate)\n{\n\tint r = 0, carry = 0;\n\n\t \n\tif (*m % DPLL_SCALE_FACTOR >= DPLL_ROUNDING_VAL)\n\t\tcarry = 1;\n\t*m = (*m / DPLL_SCALE_FACTOR) + carry;\n\n\t \n\t*new_rate = _dpll_compute_new_rate(parent_rate, *m, n);\n\tif (*new_rate > target_rate) {\n\t\t(*m)--;\n\t\t*new_rate = 0;\n\t}\n\n\t \n\tif (*m < DPLL_MIN_MULTIPLIER) {\n\t\t*m = DPLL_MIN_MULTIPLIER;\n\t\t*new_rate = 0;\n\t\tr = DPLL_MULT_UNDERFLOW;\n\t}\n\n\tif (*new_rate == 0)\n\t\t*new_rate = _dpll_compute_new_rate(parent_rate, *m, n);\n\n\treturn r;\n}\n\n \nstatic int _omap2_dpll_is_in_bypass(u32 v)\n{\n\tu8 mask, val;\n\n\tmask = ti_clk_get_features()->dpll_bypass_vals;\n\n\t \n\twhile (mask) {\n\t\tval = __ffs(mask);\n\t\tmask ^= (1 << val);\n\t\tif (v == val)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nu8 omap2_init_dpll_parent(struct clk_hw *hw)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tu32 v;\n\tstruct dpll_data *dd;\n\n\tdd = clk->dpll_data;\n\tif (!dd)\n\t\treturn -EINVAL;\n\n\tv = ti_clk_ll_ops->clk_readl(&dd->control_reg);\n\tv &= dd->enable_mask;\n\tv >>= __ffs(dd->enable_mask);\n\n\t \n\tif (_omap2_dpll_is_in_bypass(v))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nunsigned long omap2_get_dpll_rate(struct clk_hw_omap *clk)\n{\n\tu64 dpll_clk;\n\tu32 dpll_mult, dpll_div, v;\n\tstruct dpll_data *dd;\n\n\tdd = clk->dpll_data;\n\tif (!dd)\n\t\treturn 0;\n\n\t \n\tv = ti_clk_ll_ops->clk_readl(&dd->control_reg);\n\tv &= dd->enable_mask;\n\tv >>= __ffs(dd->enable_mask);\n\n\tif (_omap2_dpll_is_in_bypass(v))\n\t\treturn clk_hw_get_rate(dd->clk_bypass);\n\n\tv = ti_clk_ll_ops->clk_readl(&dd->mult_div1_reg);\n\tdpll_mult = v & dd->mult_mask;\n\tdpll_mult >>= __ffs(dd->mult_mask);\n\tdpll_div = v & dd->div1_mask;\n\tdpll_div >>= __ffs(dd->div1_mask);\n\n\tdpll_clk = (u64)clk_hw_get_rate(dd->clk_ref) * dpll_mult;\n\tdo_div(dpll_clk, dpll_div + 1);\n\n\treturn dpll_clk;\n}\n\n \n\n \nlong omap2_dpll_round_rate(struct clk_hw *hw, unsigned long target_rate,\n\t\t\t   unsigned long *parent_rate)\n{\n\tstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\n\tint m, n, r, scaled_max_m;\n\tint min_delta_m = INT_MAX, min_delta_n = INT_MAX;\n\tunsigned long scaled_rt_rp;\n\tunsigned long new_rate = 0;\n\tstruct dpll_data *dd;\n\tunsigned long ref_rate;\n\tlong delta;\n\tlong prev_min_delta = LONG_MAX;\n\tconst char *clk_name;\n\n\tif (!clk || !clk->dpll_data)\n\t\treturn ~0;\n\n\tdd = clk->dpll_data;\n\n\tif (dd->max_rate && target_rate > dd->max_rate)\n\t\ttarget_rate = dd->max_rate;\n\n\tref_rate = clk_hw_get_rate(dd->clk_ref);\n\tclk_name = clk_hw_get_name(hw);\n\tpr_debug(\"clock: %s: starting DPLL round_rate, target rate %lu\\n\",\n\t\t clk_name, target_rate);\n\n\tscaled_rt_rp = target_rate / (ref_rate / DPLL_SCALE_FACTOR);\n\tscaled_max_m = dd->max_multiplier * DPLL_SCALE_FACTOR;\n\n\tdd->last_rounded_rate = 0;\n\n\tfor (n = dd->min_divider; n <= dd->max_divider; n++) {\n\t\t \n\t\tr = _dpll_test_fint(clk, n);\n\t\tif (r == DPLL_FINT_UNDERFLOW)\n\t\t\tbreak;\n\t\telse if (r == DPLL_FINT_INVALID)\n\t\t\tcontinue;\n\n\t\t \n\t\tm = scaled_rt_rp * n;\n\n\t\t \n\t\tif (m > scaled_max_m)\n\t\t\tbreak;\n\n\t\tr = _dpll_test_mult(&m, n, &new_rate, target_rate,\n\t\t\t\t    ref_rate);\n\n\t\t \n\t\tif (r == DPLL_MULT_UNDERFLOW)\n\t\t\tcontinue;\n\n\t\t \n\t\tdelta = target_rate - new_rate;\n\t\tif (delta < 0)\n\t\t\tcontinue;\n\n\t\tif (delta < prev_min_delta) {\n\t\t\tprev_min_delta = delta;\n\t\t\tmin_delta_m = m;\n\t\t\tmin_delta_n = n;\n\t\t}\n\n\t\tpr_debug(\"clock: %s: m = %d: n = %d: new_rate = %lu\\n\",\n\t\t\t clk_name, m, n, new_rate);\n\n\t\tif (delta == 0)\n\t\t\tbreak;\n\t}\n\n\tif (prev_min_delta == LONG_MAX) {\n\t\tpr_debug(\"clock: %s: cannot round to rate %lu\\n\",\n\t\t\t clk_name, target_rate);\n\t\treturn ~0;\n\t}\n\n\tdd->last_rounded_m = min_delta_m;\n\tdd->last_rounded_n = min_delta_n;\n\tdd->last_rounded_rate = target_rate - prev_min_delta;\n\n\treturn dd->last_rounded_rate;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}