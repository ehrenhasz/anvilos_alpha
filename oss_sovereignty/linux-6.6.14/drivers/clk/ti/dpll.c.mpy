{
  "module_name": "dpll.c",
  "hash_id": "79a112bed8db4d5ba655657e166794b20a2d4ec29706a743da81c7a92ea2a58a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/dpll.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/clk/ti.h>\n#include \"clock.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) || \\\n\tdefined(CONFIG_SOC_DRA7XX)\nstatic const struct clk_ops dpll_m4xen_ck_ops = {\n\t.enable\t\t= &omap3_noncore_dpll_enable,\n\t.disable\t= &omap3_noncore_dpll_disable,\n\t.recalc_rate\t= &omap4_dpll_regm4xen_recalc,\n\t.round_rate\t= &omap4_dpll_regm4xen_round_rate,\n\t.set_rate\t= &omap3_noncore_dpll_set_rate,\n\t.set_parent\t= &omap3_noncore_dpll_set_parent,\n\t.set_rate_and_parent\t= &omap3_noncore_dpll_set_rate_and_parent,\n\t.determine_rate\t= &omap4_dpll_regm4xen_determine_rate,\n\t.get_parent\t= &omap2_init_dpll_parent,\n\t.save_context\t= &omap3_core_dpll_save_context,\n\t.restore_context = &omap3_core_dpll_restore_context,\n};\n#else\nstatic const struct clk_ops dpll_m4xen_ck_ops = {};\n#endif\n\n#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_ARCH_OMAP4) || \\\n\tdefined(CONFIG_SOC_OMAP5) || defined(CONFIG_SOC_DRA7XX) || \\\n\tdefined(CONFIG_SOC_AM33XX) || defined(CONFIG_SOC_AM43XX)\nstatic const struct clk_ops dpll_core_ck_ops = {\n\t.recalc_rate\t= &omap3_dpll_recalc,\n\t.get_parent\t= &omap2_init_dpll_parent,\n};\n\nstatic const struct clk_ops dpll_ck_ops = {\n\t.enable\t\t= &omap3_noncore_dpll_enable,\n\t.disable\t= &omap3_noncore_dpll_disable,\n\t.recalc_rate\t= &omap3_dpll_recalc,\n\t.round_rate\t= &omap2_dpll_round_rate,\n\t.set_rate\t= &omap3_noncore_dpll_set_rate,\n\t.set_parent\t= &omap3_noncore_dpll_set_parent,\n\t.set_rate_and_parent\t= &omap3_noncore_dpll_set_rate_and_parent,\n\t.determine_rate\t= &omap3_noncore_dpll_determine_rate,\n\t.get_parent\t= &omap2_init_dpll_parent,\n\t.save_context\t= &omap3_noncore_dpll_save_context,\n\t.restore_context = &omap3_noncore_dpll_restore_context,\n};\n\nstatic const struct clk_ops dpll_no_gate_ck_ops = {\n\t.recalc_rate\t= &omap3_dpll_recalc,\n\t.get_parent\t= &omap2_init_dpll_parent,\n\t.round_rate\t= &omap2_dpll_round_rate,\n\t.set_rate\t= &omap3_noncore_dpll_set_rate,\n\t.set_parent\t= &omap3_noncore_dpll_set_parent,\n\t.set_rate_and_parent\t= &omap3_noncore_dpll_set_rate_and_parent,\n\t.determine_rate\t= &omap3_noncore_dpll_determine_rate,\n\t.save_context\t= &omap3_noncore_dpll_save_context,\n\t.restore_context = &omap3_noncore_dpll_restore_context\n};\n#else\nstatic const struct clk_ops dpll_core_ck_ops = {};\nstatic const struct clk_ops dpll_ck_ops = {};\nstatic const struct clk_ops dpll_no_gate_ck_ops = {};\nconst struct clk_hw_omap_ops clkhwops_omap3_dpll = {};\n#endif\n\n#ifdef CONFIG_ARCH_OMAP2\nstatic const struct clk_ops omap2_dpll_core_ck_ops = {\n\t.get_parent\t= &omap2_init_dpll_parent,\n\t.recalc_rate\t= &omap2_dpllcore_recalc,\n\t.round_rate\t= &omap2_dpll_round_rate,\n\t.set_rate\t= &omap2_reprogram_dpllcore,\n};\n#else\nstatic const struct clk_ops omap2_dpll_core_ck_ops = {};\n#endif\n\n#ifdef CONFIG_ARCH_OMAP3\nstatic const struct clk_ops omap3_dpll_core_ck_ops = {\n\t.get_parent\t= &omap2_init_dpll_parent,\n\t.recalc_rate\t= &omap3_dpll_recalc,\n\t.round_rate\t= &omap2_dpll_round_rate,\n};\n#else\nstatic const struct clk_ops omap3_dpll_core_ck_ops = {};\n#endif\n\n#ifdef CONFIG_ARCH_OMAP3\nstatic const struct clk_ops omap3_dpll_ck_ops = {\n\t.enable\t\t= &omap3_noncore_dpll_enable,\n\t.disable\t= &omap3_noncore_dpll_disable,\n\t.get_parent\t= &omap2_init_dpll_parent,\n\t.recalc_rate\t= &omap3_dpll_recalc,\n\t.set_rate\t= &omap3_noncore_dpll_set_rate,\n\t.set_parent\t= &omap3_noncore_dpll_set_parent,\n\t.set_rate_and_parent\t= &omap3_noncore_dpll_set_rate_and_parent,\n\t.determine_rate\t= &omap3_noncore_dpll_determine_rate,\n\t.round_rate\t= &omap2_dpll_round_rate,\n};\n\nstatic const struct clk_ops omap3_dpll5_ck_ops = {\n\t.enable\t\t= &omap3_noncore_dpll_enable,\n\t.disable\t= &omap3_noncore_dpll_disable,\n\t.get_parent\t= &omap2_init_dpll_parent,\n\t.recalc_rate\t= &omap3_dpll_recalc,\n\t.set_rate\t= &omap3_dpll5_set_rate,\n\t.set_parent\t= &omap3_noncore_dpll_set_parent,\n\t.set_rate_and_parent\t= &omap3_noncore_dpll_set_rate_and_parent,\n\t.determine_rate\t= &omap3_noncore_dpll_determine_rate,\n\t.round_rate\t= &omap2_dpll_round_rate,\n};\n\nstatic const struct clk_ops omap3_dpll_per_ck_ops = {\n\t.enable\t\t= &omap3_noncore_dpll_enable,\n\t.disable\t= &omap3_noncore_dpll_disable,\n\t.get_parent\t= &omap2_init_dpll_parent,\n\t.recalc_rate\t= &omap3_dpll_recalc,\n\t.set_rate\t= &omap3_dpll4_set_rate,\n\t.set_parent\t= &omap3_noncore_dpll_set_parent,\n\t.set_rate_and_parent\t= &omap3_dpll4_set_rate_and_parent,\n\t.determine_rate\t= &omap3_noncore_dpll_determine_rate,\n\t.round_rate\t= &omap2_dpll_round_rate,\n};\n#endif\n\nstatic const struct clk_ops dpll_x2_ck_ops = {\n\t.recalc_rate\t= &omap3_clkoutx2_recalc,\n};\n\n \nstatic void __init _register_dpll(void *user,\n\t\t\t\t  struct device_node *node)\n{\n\tstruct clk_hw *hw = user;\n\tstruct clk_hw_omap *clk_hw = to_clk_hw_omap(hw);\n\tstruct dpll_data *dd = clk_hw->dpll_data;\n\tconst char *name;\n\tstruct clk *clk;\n\tconst struct clk_init_data *init = hw->init;\n\n\tclk = of_clk_get(node, 0);\n\tif (IS_ERR(clk)) {\n\t\tpr_debug(\"clk-ref missing for %pOFn, retry later\\n\",\n\t\t\t node);\n\t\tif (!ti_clk_retry_init(node, hw, _register_dpll))\n\t\t\treturn;\n\n\t\tgoto cleanup;\n\t}\n\n\tdd->clk_ref = __clk_get_hw(clk);\n\n\tclk = of_clk_get(node, 1);\n\n\tif (IS_ERR(clk)) {\n\t\tpr_debug(\"clk-bypass missing for %pOFn, retry later\\n\",\n\t\t\t node);\n\t\tif (!ti_clk_retry_init(node, hw, _register_dpll))\n\t\t\treturn;\n\n\t\tgoto cleanup;\n\t}\n\n\tdd->clk_bypass = __clk_get_hw(clk);\n\n\t \n\tname = ti_dt_clk_name(node);\n\tclk = of_ti_clk_register_omap_hw(node, &clk_hw->hw, name);\n\n\tif (!IS_ERR(clk)) {\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\t\tkfree(init->parent_names);\n\t\tkfree(init);\n\t\treturn;\n\t}\n\ncleanup:\n\tkfree(clk_hw->dpll_data);\n\tkfree(init->parent_names);\n\tkfree(init);\n\tkfree(clk_hw);\n}\n\n#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) || \\\n\tdefined(CONFIG_SOC_DRA7XX) || defined(CONFIG_SOC_AM33XX) || \\\n\tdefined(CONFIG_SOC_AM43XX)\n \nstatic void _register_dpll_x2(struct device_node *node,\n\t\t\t      const struct clk_ops *ops,\n\t\t\t      const struct clk_hw_omap_ops *hw_ops)\n{\n\tstruct clk *clk;\n\tstruct clk_init_data init = { NULL };\n\tstruct clk_hw_omap *clk_hw;\n\tconst char *name = ti_dt_clk_name(node);\n\tconst char *parent_name;\n\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tif (!parent_name) {\n\t\tpr_err(\"%pOFn must have parent\\n\", node);\n\t\treturn;\n\t}\n\n\tclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\n\tif (!clk_hw)\n\t\treturn;\n\n\tclk_hw->ops = hw_ops;\n\tclk_hw->hw.init = &init;\n\n\tinit.name = name;\n\tinit.ops = ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) || \\\n\tdefined(CONFIG_SOC_DRA7XX)\n\tif (hw_ops == &clkhwops_omap4_dpllmx) {\n\t\tint ret;\n\n\t\t \n\t\tret = of_property_count_elems_of_size(node, \"reg\", 1);\n\t\tif (ret <= 0) {\n\t\t\tclk_hw->ops = NULL;\n\t\t} else if (ti_clk_get_reg_addr(node, 0, &clk_hw->clksel_reg)) {\n\t\t\tkfree(clk_hw);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\t \n\tclk = of_ti_clk_register_omap_hw(node, &clk_hw->hw, name);\n\n\tif (IS_ERR(clk))\n\t\tkfree(clk_hw);\n\telse\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n}\n#endif\n\n \nstatic void __init of_ti_dpll_setup(struct device_node *node,\n\t\t\t\t    const struct clk_ops *ops,\n\t\t\t\t    const struct dpll_data *ddt)\n{\n\tstruct clk_hw_omap *clk_hw = NULL;\n\tstruct clk_init_data *init = NULL;\n\tconst char **parent_names = NULL;\n\tstruct dpll_data *dd = NULL;\n\tint ssc_clk_index;\n\tu8 dpll_mode = 0;\n\tu32 min_div;\n\n\tdd = kmemdup(ddt, sizeof(*dd), GFP_KERNEL);\n\tclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\n\tinit = kzalloc(sizeof(*init), GFP_KERNEL);\n\tif (!dd || !clk_hw || !init)\n\t\tgoto cleanup;\n\n\tclk_hw->dpll_data = dd;\n\tclk_hw->ops = &clkhwops_omap3_dpll;\n\tclk_hw->hw.init = init;\n\n\tinit->name = ti_dt_clk_name(node);\n\tinit->ops = ops;\n\n\tinit->num_parents = of_clk_get_parent_count(node);\n\tif (!init->num_parents) {\n\t\tpr_err(\"%pOFn must have parent(s)\\n\", node);\n\t\tgoto cleanup;\n\t}\n\n\tparent_names = kcalloc(init->num_parents, sizeof(char *), GFP_KERNEL);\n\tif (!parent_names)\n\t\tgoto cleanup;\n\n\tof_clk_parent_fill(node, parent_names, init->num_parents);\n\n\tinit->parent_names = parent_names;\n\n\tif (ti_clk_get_reg_addr(node, 0, &dd->control_reg))\n\t\tgoto cleanup;\n\n\t \n\tif (!dd->idlest_mask) {\n\t\tif (ti_clk_get_reg_addr(node, 1, &dd->mult_div1_reg))\n\t\t\tgoto cleanup;\n#ifdef CONFIG_ARCH_OMAP2\n\t\tclk_hw->ops = &clkhwops_omap2xxx_dpll;\n\t\tomap2xxx_clkt_dpllcore_init(&clk_hw->hw);\n#endif\n\t} else {\n\t\tif (ti_clk_get_reg_addr(node, 1, &dd->idlest_reg))\n\t\t\tgoto cleanup;\n\n\t\tif (ti_clk_get_reg_addr(node, 2, &dd->mult_div1_reg))\n\t\t\tgoto cleanup;\n\t}\n\n\tif (dd->autoidle_mask) {\n\t\tif (ti_clk_get_reg_addr(node, 3, &dd->autoidle_reg))\n\t\t\tgoto cleanup;\n\n\t\tssc_clk_index = 4;\n\t} else {\n\t\tssc_clk_index = 3;\n\t}\n\n\tif (dd->ssc_deltam_int_mask && dd->ssc_deltam_frac_mask &&\n\t    dd->ssc_modfreq_mant_mask && dd->ssc_modfreq_exp_mask) {\n\t\tif (ti_clk_get_reg_addr(node, ssc_clk_index++,\n\t\t\t\t\t&dd->ssc_deltam_reg))\n\t\t\tgoto cleanup;\n\n\t\tif (ti_clk_get_reg_addr(node, ssc_clk_index++,\n\t\t\t\t\t&dd->ssc_modfreq_reg))\n\t\t\tgoto cleanup;\n\n\t\tof_property_read_u32(node, \"ti,ssc-modfreq-hz\",\n\t\t\t\t     &dd->ssc_modfreq);\n\t\tof_property_read_u32(node, \"ti,ssc-deltam\", &dd->ssc_deltam);\n\t\tdd->ssc_downspread =\n\t\t\tof_property_read_bool(node, \"ti,ssc-downspread\");\n\t}\n\n\tif (of_property_read_bool(node, \"ti,low-power-stop\"))\n\t\tdpll_mode |= 1 << DPLL_LOW_POWER_STOP;\n\n\tif (of_property_read_bool(node, \"ti,low-power-bypass\"))\n\t\tdpll_mode |= 1 << DPLL_LOW_POWER_BYPASS;\n\n\tif (of_property_read_bool(node, \"ti,lock\"))\n\t\tdpll_mode |= 1 << DPLL_LOCKED;\n\n\tif (!of_property_read_u32(node, \"ti,min-div\", &min_div) &&\n\t    min_div > dd->min_divider)\n\t\tdd->min_divider = min_div;\n\n\tif (dpll_mode)\n\t\tdd->modes = dpll_mode;\n\n\t_register_dpll(&clk_hw->hw, node);\n\treturn;\n\ncleanup:\n\tkfree(dd);\n\tkfree(parent_names);\n\tkfree(init);\n\tkfree(clk_hw);\n}\n\n#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) || \\\n\tdefined(CONFIG_SOC_DRA7XX)\nstatic void __init of_ti_omap4_dpll_x2_setup(struct device_node *node)\n{\n\t_register_dpll_x2(node, &dpll_x2_ck_ops, &clkhwops_omap4_dpllmx);\n}\nCLK_OF_DECLARE(ti_omap4_dpll_x2_clock, \"ti,omap4-dpll-x2-clock\",\n\t       of_ti_omap4_dpll_x2_setup);\n#endif\n\n#if defined(CONFIG_SOC_AM33XX) || defined(CONFIG_SOC_AM43XX)\nstatic void __init of_ti_am3_dpll_x2_setup(struct device_node *node)\n{\n\t_register_dpll_x2(node, &dpll_x2_ck_ops, NULL);\n}\nCLK_OF_DECLARE(ti_am3_dpll_x2_clock, \"ti,am3-dpll-x2-clock\",\n\t       of_ti_am3_dpll_x2_setup);\n#endif\n\n#ifdef CONFIG_ARCH_OMAP3\nstatic void __init of_ti_omap3_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.idlest_mask = 0x1,\n\t\t.enable_mask = 0x7,\n\t\t.autoidle_mask = 0x7,\n\t\t.mult_mask = 0x7ff << 8,\n\t\t.div1_mask = 0x7f,\n\t\t.max_multiplier = 2047,\n\t\t.max_divider = 128,\n\t\t.min_divider = 1,\n\t\t.freqsel_mask = 0xf0,\n\t\t.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\n\t};\n\n\tif ((of_machine_is_compatible(\"ti,omap3630\") ||\n\t     of_machine_is_compatible(\"ti,omap36xx\")) &&\n\t     of_node_name_eq(node, \"dpll5_ck\"))\n\t\tof_ti_dpll_setup(node, &omap3_dpll5_ck_ops, &dd);\n\telse\n\t\tof_ti_dpll_setup(node, &omap3_dpll_ck_ops, &dd);\n}\nCLK_OF_DECLARE(ti_omap3_dpll_clock, \"ti,omap3-dpll-clock\",\n\t       of_ti_omap3_dpll_setup);\n\nstatic void __init of_ti_omap3_core_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.idlest_mask = 0x1,\n\t\t.enable_mask = 0x7,\n\t\t.autoidle_mask = 0x7,\n\t\t.mult_mask = 0x7ff << 16,\n\t\t.div1_mask = 0x7f << 8,\n\t\t.max_multiplier = 2047,\n\t\t.max_divider = 128,\n\t\t.min_divider = 1,\n\t\t.freqsel_mask = 0xf0,\n\t};\n\n\tof_ti_dpll_setup(node, &omap3_dpll_core_ck_ops, &dd);\n}\nCLK_OF_DECLARE(ti_omap3_core_dpll_clock, \"ti,omap3-dpll-core-clock\",\n\t       of_ti_omap3_core_dpll_setup);\n\nstatic void __init of_ti_omap3_per_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.idlest_mask = 0x1 << 1,\n\t\t.enable_mask = 0x7 << 16,\n\t\t.autoidle_mask = 0x7 << 3,\n\t\t.mult_mask = 0x7ff << 8,\n\t\t.div1_mask = 0x7f,\n\t\t.max_multiplier = 2047,\n\t\t.max_divider = 128,\n\t\t.min_divider = 1,\n\t\t.freqsel_mask = 0xf00000,\n\t\t.modes = (1 << DPLL_LOW_POWER_STOP) | (1 << DPLL_LOCKED),\n\t};\n\n\tof_ti_dpll_setup(node, &omap3_dpll_per_ck_ops, &dd);\n}\nCLK_OF_DECLARE(ti_omap3_per_dpll_clock, \"ti,omap3-dpll-per-clock\",\n\t       of_ti_omap3_per_dpll_setup);\n\nstatic void __init of_ti_omap3_per_jtype_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.idlest_mask = 0x1 << 1,\n\t\t.enable_mask = 0x7 << 16,\n\t\t.autoidle_mask = 0x7 << 3,\n\t\t.mult_mask = 0xfff << 8,\n\t\t.div1_mask = 0x7f,\n\t\t.max_multiplier = 4095,\n\t\t.max_divider = 128,\n\t\t.min_divider = 1,\n\t\t.sddiv_mask = 0xff << 24,\n\t\t.dco_mask = 0xe << 20,\n\t\t.flags = DPLL_J_TYPE,\n\t\t.modes = (1 << DPLL_LOW_POWER_STOP) | (1 << DPLL_LOCKED),\n\t};\n\n\tof_ti_dpll_setup(node, &omap3_dpll_per_ck_ops, &dd);\n}\nCLK_OF_DECLARE(ti_omap3_per_jtype_dpll_clock, \"ti,omap3-dpll-per-j-type-clock\",\n\t       of_ti_omap3_per_jtype_dpll_setup);\n#endif\n\nstatic void __init of_ti_omap4_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.idlest_mask = 0x1,\n\t\t.enable_mask = 0x7,\n\t\t.autoidle_mask = 0x7,\n\t\t.mult_mask = 0x7ff << 8,\n\t\t.div1_mask = 0x7f,\n\t\t.max_multiplier = 2047,\n\t\t.max_divider = 128,\n\t\t.min_divider = 1,\n\t\t.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\n\t};\n\n\tof_ti_dpll_setup(node, &dpll_ck_ops, &dd);\n}\nCLK_OF_DECLARE(ti_omap4_dpll_clock, \"ti,omap4-dpll-clock\",\n\t       of_ti_omap4_dpll_setup);\n\nstatic void __init of_ti_omap5_mpu_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.idlest_mask = 0x1,\n\t\t.enable_mask = 0x7,\n\t\t.autoidle_mask = 0x7,\n\t\t.mult_mask = 0x7ff << 8,\n\t\t.div1_mask = 0x7f,\n\t\t.max_multiplier = 2047,\n\t\t.max_divider = 128,\n\t\t.dcc_mask = BIT(22),\n\t\t.dcc_rate = 1400000000,  \n\t\t.min_divider = 1,\n\t\t.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\n\t};\n\n\tof_ti_dpll_setup(node, &dpll_ck_ops, &dd);\n}\nCLK_OF_DECLARE(of_ti_omap5_mpu_dpll_clock, \"ti,omap5-mpu-dpll-clock\",\n\t       of_ti_omap5_mpu_dpll_setup);\n\nstatic void __init of_ti_omap4_core_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.idlest_mask = 0x1,\n\t\t.enable_mask = 0x7,\n\t\t.autoidle_mask = 0x7,\n\t\t.mult_mask = 0x7ff << 8,\n\t\t.div1_mask = 0x7f,\n\t\t.max_multiplier = 2047,\n\t\t.max_divider = 128,\n\t\t.min_divider = 1,\n\t\t.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\n\t};\n\n\tof_ti_dpll_setup(node, &dpll_core_ck_ops, &dd);\n}\nCLK_OF_DECLARE(ti_omap4_core_dpll_clock, \"ti,omap4-dpll-core-clock\",\n\t       of_ti_omap4_core_dpll_setup);\n\n#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) || \\\n\tdefined(CONFIG_SOC_DRA7XX)\nstatic void __init of_ti_omap4_m4xen_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.idlest_mask = 0x1,\n\t\t.enable_mask = 0x7,\n\t\t.autoidle_mask = 0x7,\n\t\t.mult_mask = 0x7ff << 8,\n\t\t.div1_mask = 0x7f,\n\t\t.max_multiplier = 2047,\n\t\t.max_divider = 128,\n\t\t.min_divider = 1,\n\t\t.m4xen_mask = 0x800,\n\t\t.lpmode_mask = 1 << 10,\n\t\t.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\n\t};\n\n\tof_ti_dpll_setup(node, &dpll_m4xen_ck_ops, &dd);\n}\nCLK_OF_DECLARE(ti_omap4_m4xen_dpll_clock, \"ti,omap4-dpll-m4xen-clock\",\n\t       of_ti_omap4_m4xen_dpll_setup);\n\nstatic void __init of_ti_omap4_jtype_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.idlest_mask = 0x1,\n\t\t.enable_mask = 0x7,\n\t\t.autoidle_mask = 0x7,\n\t\t.mult_mask = 0xfff << 8,\n\t\t.div1_mask = 0xff,\n\t\t.max_multiplier = 4095,\n\t\t.max_divider = 256,\n\t\t.min_divider = 1,\n\t\t.sddiv_mask = 0xff << 24,\n\t\t.flags = DPLL_J_TYPE,\n\t\t.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\n\t};\n\n\tof_ti_dpll_setup(node, &dpll_m4xen_ck_ops, &dd);\n}\nCLK_OF_DECLARE(ti_omap4_jtype_dpll_clock, \"ti,omap4-dpll-j-type-clock\",\n\t       of_ti_omap4_jtype_dpll_setup);\n#endif\n\nstatic void __init of_ti_am3_no_gate_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.idlest_mask = 0x1,\n\t\t.enable_mask = 0x7,\n\t\t.ssc_enable_mask = 0x1 << 12,\n\t\t.ssc_downspread_mask = 0x1 << 14,\n\t\t.mult_mask = 0x7ff << 8,\n\t\t.div1_mask = 0x7f,\n\t\t.ssc_deltam_int_mask = 0x3 << 18,\n\t\t.ssc_deltam_frac_mask = 0x3ffff,\n\t\t.ssc_modfreq_mant_mask = 0x7f,\n\t\t.ssc_modfreq_exp_mask = 0x7 << 8,\n\t\t.max_multiplier = 2047,\n\t\t.max_divider = 128,\n\t\t.min_divider = 1,\n\t\t.max_rate = 1000000000,\n\t\t.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\n\t};\n\n\tof_ti_dpll_setup(node, &dpll_no_gate_ck_ops, &dd);\n}\nCLK_OF_DECLARE(ti_am3_no_gate_dpll_clock, \"ti,am3-dpll-no-gate-clock\",\n\t       of_ti_am3_no_gate_dpll_setup);\n\nstatic void __init of_ti_am3_jtype_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.idlest_mask = 0x1,\n\t\t.enable_mask = 0x7,\n\t\t.mult_mask = 0x7ff << 8,\n\t\t.div1_mask = 0x7f,\n\t\t.max_multiplier = 4095,\n\t\t.max_divider = 256,\n\t\t.min_divider = 2,\n\t\t.flags = DPLL_J_TYPE,\n\t\t.max_rate = 2000000000,\n\t\t.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\n\t};\n\n\tof_ti_dpll_setup(node, &dpll_ck_ops, &dd);\n}\nCLK_OF_DECLARE(ti_am3_jtype_dpll_clock, \"ti,am3-dpll-j-type-clock\",\n\t       of_ti_am3_jtype_dpll_setup);\n\nstatic void __init of_ti_am3_no_gate_jtype_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.idlest_mask = 0x1,\n\t\t.enable_mask = 0x7,\n\t\t.mult_mask = 0x7ff << 8,\n\t\t.div1_mask = 0x7f,\n\t\t.max_multiplier = 2047,\n\t\t.max_divider = 128,\n\t\t.min_divider = 1,\n\t\t.max_rate = 2000000000,\n\t\t.flags = DPLL_J_TYPE,\n\t\t.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\n\t};\n\n\tof_ti_dpll_setup(node, &dpll_no_gate_ck_ops, &dd);\n}\nCLK_OF_DECLARE(ti_am3_no_gate_jtype_dpll_clock,\n\t       \"ti,am3-dpll-no-gate-j-type-clock\",\n\t       of_ti_am3_no_gate_jtype_dpll_setup);\n\nstatic void __init of_ti_am3_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.idlest_mask = 0x1,\n\t\t.enable_mask = 0x7,\n\t\t.ssc_enable_mask = 0x1 << 12,\n\t\t.ssc_downspread_mask = 0x1 << 14,\n\t\t.mult_mask = 0x7ff << 8,\n\t\t.div1_mask = 0x7f,\n\t\t.ssc_deltam_int_mask = 0x3 << 18,\n\t\t.ssc_deltam_frac_mask = 0x3ffff,\n\t\t.ssc_modfreq_mant_mask = 0x7f,\n\t\t.ssc_modfreq_exp_mask = 0x7 << 8,\n\t\t.max_multiplier = 2047,\n\t\t.max_divider = 128,\n\t\t.min_divider = 1,\n\t\t.max_rate = 1000000000,\n\t\t.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\n\t};\n\n\tof_ti_dpll_setup(node, &dpll_ck_ops, &dd);\n}\nCLK_OF_DECLARE(ti_am3_dpll_clock, \"ti,am3-dpll-clock\", of_ti_am3_dpll_setup);\n\nstatic void __init of_ti_am3_core_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.idlest_mask = 0x1,\n\t\t.enable_mask = 0x7,\n\t\t.mult_mask = 0x7ff << 8,\n\t\t.div1_mask = 0x7f,\n\t\t.max_multiplier = 2047,\n\t\t.max_divider = 128,\n\t\t.min_divider = 1,\n\t\t.max_rate = 1000000000,\n\t\t.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\n\t};\n\n\tof_ti_dpll_setup(node, &dpll_core_ck_ops, &dd);\n}\nCLK_OF_DECLARE(ti_am3_core_dpll_clock, \"ti,am3-dpll-core-clock\",\n\t       of_ti_am3_core_dpll_setup);\n\nstatic void __init of_ti_omap2_core_dpll_setup(struct device_node *node)\n{\n\tconst struct dpll_data dd = {\n\t\t.enable_mask = 0x3,\n\t\t.mult_mask = 0x3ff << 12,\n\t\t.div1_mask = 0xf << 8,\n\t\t.max_divider = 16,\n\t\t.min_divider = 1,\n\t};\n\n\tof_ti_dpll_setup(node, &omap2_dpll_core_ck_ops, &dd);\n}\nCLK_OF_DECLARE(ti_omap2_core_dpll_clock, \"ti,omap2-dpll-core-clock\",\n\t       of_ti_omap2_core_dpll_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}