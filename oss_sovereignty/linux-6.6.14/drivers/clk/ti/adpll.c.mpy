{
  "module_name": "adpll.c",
  "hash_id": "2fbecd16e0be5b7100dba98e5c4ea093ed6792b59b482c6dc8a93785ba86f40c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/ti/adpll.c",
  "human_readable_source": "\n\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/string.h>\n\n#define ADPLL_PLLSS_MMR_LOCK_OFFSET\t0x00\t \n#define ADPLL_PLLSS_MMR_LOCK_ENABLED\t0x1f125B64\n#define ADPLL_PLLSS_MMR_UNLOCK_MAGIC\t0x1eda4c3d\n\n#define ADPLL_PWRCTRL_OFFSET\t\t0x00\n#define ADPLL_PWRCTRL_PONIN\t\t5\n#define ADPLL_PWRCTRL_PGOODIN\t\t4\n#define ADPLL_PWRCTRL_RET\t\t3\n#define ADPLL_PWRCTRL_ISORET\t\t2\n#define ADPLL_PWRCTRL_ISOSCAN\t\t1\n#define ADPLL_PWRCTRL_OFFMODE\t\t0\n\n#define ADPLL_CLKCTRL_OFFSET\t\t0x04\n#define ADPLL_CLKCTRL_CLKDCOLDOEN\t29\n#define ADPLL_CLKCTRL_IDLE\t\t23\n#define ADPLL_CLKCTRL_CLKOUTEN\t\t20\n#define ADPLL_CLKINPHIFSEL_ADPLL_S\t19\t \n#define ADPLL_CLKCTRL_CLKOUTLDOEN_ADPLL_LJ 19\n#define ADPLL_CLKCTRL_ULOWCLKEN\t\t18\n#define ADPLL_CLKCTRL_CLKDCOLDOPWDNZ\t17\n#define ADPLL_CLKCTRL_M2PWDNZ\t\t16\n#define ADPLL_CLKCTRL_M3PWDNZ_ADPLL_S\t15\n#define ADPLL_CLKCTRL_LOWCURRSTDBY_ADPLL_S 13\n#define ADPLL_CLKCTRL_LPMODE_ADPLL_S\t12\n#define ADPLL_CLKCTRL_REGM4XEN_ADPLL_S\t10\n#define ADPLL_CLKCTRL_SELFREQDCO_ADPLL_LJ 10\n#define ADPLL_CLKCTRL_TINITZ\t\t0\n\n#define ADPLL_TENABLE_OFFSET\t\t0x08\n#define ADPLL_TENABLEDIV_OFFSET\t\t0x8c\n\n#define ADPLL_M2NDIV_OFFSET\t\t0x10\n#define ADPLL_M2NDIV_M2\t\t\t16\n#define ADPLL_M2NDIV_M2_ADPLL_S_WIDTH\t5\n#define ADPLL_M2NDIV_M2_ADPLL_LJ_WIDTH\t7\n\n#define ADPLL_MN2DIV_OFFSET\t\t0x14\n#define ADPLL_MN2DIV_N2\t\t\t16\n\n#define ADPLL_FRACDIV_OFFSET\t\t0x18\n#define ADPLL_FRACDIV_REGSD\t\t24\n#define ADPLL_FRACDIV_FRACTIONALM\t0\n#define ADPLL_FRACDIV_FRACTIONALM_MASK\t0x3ffff\n\n#define ADPLL_BWCTRL_OFFSET\t\t0x1c\n#define ADPLL_BWCTRL_BWCONTROL\t\t1\n#define ADPLL_BWCTRL_BW_INCR_DECRZ\t0\n\n#define ADPLL_RESERVED_OFFSET\t\t0x20\n\n#define ADPLL_STATUS_OFFSET\t\t0x24\n#define ADPLL_STATUS_PONOUT\t\t31\n#define ADPLL_STATUS_PGOODOUT\t\t30\n#define ADPLL_STATUS_LDOPWDN\t\t29\n#define ADPLL_STATUS_RECAL_BSTATUS3\t28\n#define ADPLL_STATUS_RECAL_OPPIN\t27\n#define ADPLL_STATUS_PHASELOCK\t\t10\n#define ADPLL_STATUS_FREQLOCK\t\t9\n#define ADPLL_STATUS_BYPASSACK\t\t8\n#define ADPLL_STATUS_LOSSREF\t\t6\n#define ADPLL_STATUS_CLKOUTENACK\t5\n#define ADPLL_STATUS_LOCK2\t\t4\n#define ADPLL_STATUS_M2CHANGEACK\t3\n#define ADPLL_STATUS_HIGHJITTER\t\t1\n#define ADPLL_STATUS_BYPASS\t\t0\n#define ADPLL_STATUS_PREPARED_MASK\t(BIT(ADPLL_STATUS_PHASELOCK) | \\\n\t\t\t\t\t BIT(ADPLL_STATUS_FREQLOCK))\n\n#define ADPLL_M3DIV_OFFSET\t\t0x28\t \n#define ADPLL_M3DIV_M3\t\t\t0\n#define ADPLL_M3DIV_M3_WIDTH\t\t5\n#define ADPLL_M3DIV_M3_MASK\t\t0x1f\n\n#define ADPLL_RAMPCTRL_OFFSET\t\t0x2c\t \n#define ADPLL_RAMPCTRL_CLKRAMPLEVEL\t19\n#define ADPLL_RAMPCTRL_CLKRAMPRATE\t16\n#define ADPLL_RAMPCTRL_RELOCK_RAMP_EN\t0\n\n#define MAX_ADPLL_INPUTS\t\t3\n#define MAX_ADPLL_OUTPUTS\t\t4\n#define ADPLL_MAX_RETRIES\t\t5\n\n#define to_dco(_hw)\tcontainer_of(_hw, struct ti_adpll_dco_data, hw)\n#define to_adpll(_hw)\tcontainer_of(_hw, struct ti_adpll_data, dco)\n#define to_clkout(_hw)\tcontainer_of(_hw, struct ti_adpll_clkout_data, hw)\n\nenum ti_adpll_clocks {\n\tTI_ADPLL_DCO,\n\tTI_ADPLL_DCO_GATE,\n\tTI_ADPLL_N2,\n\tTI_ADPLL_M2,\n\tTI_ADPLL_M2_GATE,\n\tTI_ADPLL_BYPASS,\n\tTI_ADPLL_HIF,\n\tTI_ADPLL_DIV2,\n\tTI_ADPLL_CLKOUT,\n\tTI_ADPLL_CLKOUT2,\n\tTI_ADPLL_M3,\n};\n\n#define TI_ADPLL_NR_CLOCKS\t(TI_ADPLL_M3 + 1)\n\nenum ti_adpll_inputs {\n\tTI_ADPLL_CLKINP,\n\tTI_ADPLL_CLKINPULOW,\n\tTI_ADPLL_CLKINPHIF,\n};\n\nenum ti_adpll_s_outputs {\n\tTI_ADPLL_S_DCOCLKLDO,\n\tTI_ADPLL_S_CLKOUT,\n\tTI_ADPLL_S_CLKOUTX2,\n\tTI_ADPLL_S_CLKOUTHIF,\n};\n\nenum ti_adpll_lj_outputs {\n\tTI_ADPLL_LJ_CLKDCOLDO,\n\tTI_ADPLL_LJ_CLKOUT,\n\tTI_ADPLL_LJ_CLKOUTLDO,\n};\n\nstruct ti_adpll_platform_data {\n\tconst bool is_type_s;\n\tconst int nr_max_inputs;\n\tconst int nr_max_outputs;\n\tconst int output_index;\n};\n\nstruct ti_adpll_clock {\n\tstruct clk *clk;\n\tstruct clk_lookup *cl;\n\tvoid (*unregister)(struct clk *clk);\n};\n\nstruct ti_adpll_dco_data {\n\tstruct clk_hw hw;\n};\n\nstruct ti_adpll_clkout_data {\n\tstruct ti_adpll_data *adpll;\n\tstruct clk_gate gate;\n\tstruct clk_hw hw;\n};\n\nstruct ti_adpll_data {\n\tstruct device *dev;\n\tconst struct ti_adpll_platform_data *c;\n\tstruct device_node *np;\n\tunsigned long pa;\n\tvoid __iomem *iobase;\n\tvoid __iomem *regs;\n\tspinlock_t lock;\t \n\tconst char *parent_names[MAX_ADPLL_INPUTS];\n\tstruct clk *parent_clocks[MAX_ADPLL_INPUTS];\n\tstruct ti_adpll_clock *clocks;\n\tstruct clk_onecell_data outputs;\n\tstruct ti_adpll_dco_data dco;\n};\n\nstatic const char *ti_adpll_clk_get_name(struct ti_adpll_data *d,\n\t\t\t\t\t int output_index,\n\t\t\t\t\t const char *postfix)\n{\n\tconst char *name;\n\tint err;\n\n\tif (output_index >= 0) {\n\t\terr = of_property_read_string_index(d->np,\n\t\t\t\t\t\t    \"clock-output-names\",\n\t\t\t\t\t\t    output_index,\n\t\t\t\t\t\t    &name);\n\t\tif (err)\n\t\t\treturn NULL;\n\t} else {\n\t\tname = devm_kasprintf(d->dev, GFP_KERNEL, \"%08lx.adpll.%s\",\n\t\t\t\t      d->pa, postfix);\n\t}\n\n\treturn name;\n}\n\n#define ADPLL_MAX_CON_ID\t16\t \n\nstatic int ti_adpll_setup_clock(struct ti_adpll_data *d, struct clk *clock,\n\t\t\t\tint index, int output_index, const char *name,\n\t\t\t\tvoid (*unregister)(struct clk *clk))\n{\n\tstruct clk_lookup *cl;\n\tconst char *postfix = NULL;\n\tchar con_id[ADPLL_MAX_CON_ID];\n\n\td->clocks[index].clk = clock;\n\td->clocks[index].unregister = unregister;\n\n\t \n\tpostfix = strrchr(name, '.');\n\tif (postfix && strlen(postfix) > 1) {\n\t\tif (strlen(postfix) > ADPLL_MAX_CON_ID)\n\t\t\tdev_warn(d->dev, \"clock %s con_id lookup may fail\\n\",\n\t\t\t\t name);\n\t\tsnprintf(con_id, 16, \"pll%03lx%s\", d->pa & 0xfff, postfix + 1);\n\t\tcl = clkdev_create(clock, con_id, NULL);\n\t\tif (!cl)\n\t\t\treturn -ENOMEM;\n\t\td->clocks[index].cl = cl;\n\t} else {\n\t\tdev_warn(d->dev, \"no con_id for clock %s\\n\", name);\n\t}\n\n\tif (output_index < 0)\n\t\treturn 0;\n\n\td->outputs.clks[output_index] = clock;\n\td->outputs.clk_num++;\n\n\treturn 0;\n}\n\nstatic int ti_adpll_init_divider(struct ti_adpll_data *d,\n\t\t\t\t enum ti_adpll_clocks index,\n\t\t\t\t int output_index, char *name,\n\t\t\t\t struct clk *parent_clock,\n\t\t\t\t void __iomem *reg,\n\t\t\t\t u8 shift, u8 width,\n\t\t\t\t u8 clk_divider_flags)\n{\n\tconst char *child_name;\n\tconst char *parent_name;\n\tstruct clk *clock;\n\n\tchild_name = ti_adpll_clk_get_name(d, output_index, name);\n\tif (!child_name)\n\t\treturn -EINVAL;\n\n\tparent_name = __clk_get_name(parent_clock);\n\tclock = clk_register_divider(d->dev, child_name, parent_name, 0,\n\t\t\t\t     reg, shift, width, clk_divider_flags,\n\t\t\t\t     &d->lock);\n\tif (IS_ERR(clock)) {\n\t\tdev_err(d->dev, \"failed to register divider %s: %li\\n\",\n\t\t\tname, PTR_ERR(clock));\n\t\treturn PTR_ERR(clock);\n\t}\n\n\treturn ti_adpll_setup_clock(d, clock, index, output_index, child_name,\n\t\t\t\t    clk_unregister_divider);\n}\n\nstatic int ti_adpll_init_mux(struct ti_adpll_data *d,\n\t\t\t     enum ti_adpll_clocks index,\n\t\t\t     char *name, struct clk *clk0,\n\t\t\t     struct clk *clk1,\n\t\t\t     void __iomem *reg,\n\t\t\t     u8 shift)\n{\n\tconst char *child_name;\n\tconst char *parents[2];\n\tstruct clk *clock;\n\n\tchild_name = ti_adpll_clk_get_name(d, -ENODEV, name);\n\tif (!child_name)\n\t\treturn -ENOMEM;\n\tparents[0] = __clk_get_name(clk0);\n\tparents[1] = __clk_get_name(clk1);\n\tclock = clk_register_mux(d->dev, child_name, parents, 2, 0,\n\t\t\t\t reg, shift, 1, 0, &d->lock);\n\tif (IS_ERR(clock)) {\n\t\tdev_err(d->dev, \"failed to register mux %s: %li\\n\",\n\t\t\tname, PTR_ERR(clock));\n\t\treturn PTR_ERR(clock);\n\t}\n\n\treturn ti_adpll_setup_clock(d, clock, index, -ENODEV, child_name,\n\t\t\t\t    clk_unregister_mux);\n}\n\nstatic int ti_adpll_init_gate(struct ti_adpll_data *d,\n\t\t\t      enum ti_adpll_clocks index,\n\t\t\t      int output_index, char *name,\n\t\t\t      struct clk *parent_clock,\n\t\t\t      void __iomem *reg,\n\t\t\t      u8 bit_idx,\n\t\t\t      u8 clk_gate_flags)\n{\n\tconst char *child_name;\n\tconst char *parent_name;\n\tstruct clk *clock;\n\n\tchild_name = ti_adpll_clk_get_name(d, output_index, name);\n\tif (!child_name)\n\t\treturn -EINVAL;\n\n\tparent_name = __clk_get_name(parent_clock);\n\tclock = clk_register_gate(d->dev, child_name, parent_name, 0,\n\t\t\t\t  reg, bit_idx, clk_gate_flags,\n\t\t\t\t  &d->lock);\n\tif (IS_ERR(clock)) {\n\t\tdev_err(d->dev, \"failed to register gate %s: %li\\n\",\n\t\t\tname, PTR_ERR(clock));\n\t\treturn PTR_ERR(clock);\n\t}\n\n\treturn ti_adpll_setup_clock(d, clock, index, output_index, child_name,\n\t\t\t\t    clk_unregister_gate);\n}\n\nstatic int ti_adpll_init_fixed_factor(struct ti_adpll_data *d,\n\t\t\t\t      enum ti_adpll_clocks index,\n\t\t\t\t      char *name,\n\t\t\t\t      struct clk *parent_clock,\n\t\t\t\t      unsigned int mult,\n\t\t\t\t      unsigned int div)\n{\n\tconst char *child_name;\n\tconst char *parent_name;\n\tstruct clk *clock;\n\n\tchild_name = ti_adpll_clk_get_name(d, -ENODEV, name);\n\tif (!child_name)\n\t\treturn -ENOMEM;\n\n\tparent_name = __clk_get_name(parent_clock);\n\tclock = clk_register_fixed_factor(d->dev, child_name, parent_name,\n\t\t\t\t\t  0, mult, div);\n\tif (IS_ERR(clock))\n\t\treturn PTR_ERR(clock);\n\n\treturn ti_adpll_setup_clock(d, clock, index, -ENODEV, child_name,\n\t\t\t\t    clk_unregister);\n}\n\nstatic void ti_adpll_set_idle_bypass(struct ti_adpll_data *d)\n{\n\tunsigned long flags;\n\tu32 v;\n\n\tspin_lock_irqsave(&d->lock, flags);\n\tv = readl_relaxed(d->regs + ADPLL_CLKCTRL_OFFSET);\n\tv |= BIT(ADPLL_CLKCTRL_IDLE);\n\twritel_relaxed(v, d->regs + ADPLL_CLKCTRL_OFFSET);\n\tspin_unlock_irqrestore(&d->lock, flags);\n}\n\nstatic void ti_adpll_clear_idle_bypass(struct ti_adpll_data *d)\n{\n\tunsigned long flags;\n\tu32 v;\n\n\tspin_lock_irqsave(&d->lock, flags);\n\tv = readl_relaxed(d->regs + ADPLL_CLKCTRL_OFFSET);\n\tv &= ~BIT(ADPLL_CLKCTRL_IDLE);\n\twritel_relaxed(v, d->regs + ADPLL_CLKCTRL_OFFSET);\n\tspin_unlock_irqrestore(&d->lock, flags);\n}\n\nstatic bool ti_adpll_clock_is_bypass(struct ti_adpll_data *d)\n{\n\tu32 v;\n\n\tv = readl_relaxed(d->regs + ADPLL_STATUS_OFFSET);\n\n\treturn v & BIT(ADPLL_STATUS_BYPASS);\n}\n\n \nstatic bool ti_adpll_is_locked(struct ti_adpll_data *d)\n{\n\tu32 v = readl_relaxed(d->regs + ADPLL_STATUS_OFFSET);\n\n\treturn (v & ADPLL_STATUS_PREPARED_MASK) == ADPLL_STATUS_PREPARED_MASK;\n}\n\nstatic int ti_adpll_wait_lock(struct ti_adpll_data *d)\n{\n\tint retries = ADPLL_MAX_RETRIES;\n\n\tdo {\n\t\tif (ti_adpll_is_locked(d))\n\t\t\treturn 0;\n\t\tusleep_range(200, 300);\n\t} while (retries--);\n\n\tdev_err(d->dev, \"pll failed to lock\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int ti_adpll_prepare(struct clk_hw *hw)\n{\n\tstruct ti_adpll_dco_data *dco = to_dco(hw);\n\tstruct ti_adpll_data *d = to_adpll(dco);\n\n\tti_adpll_clear_idle_bypass(d);\n\tti_adpll_wait_lock(d);\n\n\treturn 0;\n}\n\nstatic void ti_adpll_unprepare(struct clk_hw *hw)\n{\n\tstruct ti_adpll_dco_data *dco = to_dco(hw);\n\tstruct ti_adpll_data *d = to_adpll(dco);\n\n\tti_adpll_set_idle_bypass(d);\n}\n\nstatic int ti_adpll_is_prepared(struct clk_hw *hw)\n{\n\tstruct ti_adpll_dco_data *dco = to_dco(hw);\n\tstruct ti_adpll_data *d = to_adpll(dco);\n\n\treturn ti_adpll_is_locked(d);\n}\n\n \nstatic unsigned long ti_adpll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct ti_adpll_dco_data *dco = to_dco(hw);\n\tstruct ti_adpll_data *d = to_adpll(dco);\n\tu32 frac_m, divider, v;\n\tu64 rate;\n\tunsigned long flags;\n\n\tif (ti_adpll_clock_is_bypass(d))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&d->lock, flags);\n\tfrac_m = readl_relaxed(d->regs + ADPLL_FRACDIV_OFFSET);\n\tfrac_m &= ADPLL_FRACDIV_FRACTIONALM_MASK;\n\trate = (u64)readw_relaxed(d->regs + ADPLL_MN2DIV_OFFSET) << 18;\n\trate += frac_m;\n\trate *= parent_rate;\n\tdivider = (readw_relaxed(d->regs + ADPLL_M2NDIV_OFFSET) + 1) << 18;\n\tspin_unlock_irqrestore(&d->lock, flags);\n\n\tdo_div(rate, divider);\n\n\tif (d->c->is_type_s) {\n\t\tv = readl_relaxed(d->regs + ADPLL_CLKCTRL_OFFSET);\n\t\tif (v & BIT(ADPLL_CLKCTRL_REGM4XEN_ADPLL_S))\n\t\t\trate *= 4;\n\t\trate *= 2;\n\t}\n\n\treturn rate;\n}\n\n \nstatic u8 ti_adpll_get_parent(struct clk_hw *hw)\n{\n\treturn 0;\n}\n\nstatic const struct clk_ops ti_adpll_ops = {\n\t.prepare = ti_adpll_prepare,\n\t.unprepare = ti_adpll_unprepare,\n\t.is_prepared = ti_adpll_is_prepared,\n\t.recalc_rate = ti_adpll_recalc_rate,\n\t.get_parent = ti_adpll_get_parent,\n};\n\nstatic int ti_adpll_init_dco(struct ti_adpll_data *d)\n{\n\tstruct clk_init_data init;\n\tstruct clk *clock;\n\tconst char *postfix;\n\tint width, err;\n\n\td->outputs.clks = devm_kcalloc(d->dev,\n\t\t\t\t       MAX_ADPLL_OUTPUTS,\n\t\t\t\t       sizeof(struct clk *),\n\t\t\t\t       GFP_KERNEL);\n\tif (!d->outputs.clks)\n\t\treturn -ENOMEM;\n\n\tif (d->c->output_index < 0)\n\t\tpostfix = \"dco\";\n\telse\n\t\tpostfix = NULL;\n\n\tinit.name = ti_adpll_clk_get_name(d, d->c->output_index, postfix);\n\tif (!init.name)\n\t\treturn -EINVAL;\n\n\tinit.parent_names = d->parent_names;\n\tinit.num_parents = d->c->nr_max_inputs;\n\tinit.ops = &ti_adpll_ops;\n\tinit.flags = CLK_GET_RATE_NOCACHE;\n\td->dco.hw.init = &init;\n\n\tif (d->c->is_type_s)\n\t\twidth = 5;\n\telse\n\t\twidth = 4;\n\n\t \n\terr = ti_adpll_init_divider(d, TI_ADPLL_N2, -ENODEV, \"n2\",\n\t\t\t\t    d->parent_clocks[TI_ADPLL_CLKINP],\n\t\t\t\t    d->regs + ADPLL_MN2DIV_OFFSET,\n\t\t\t\t    ADPLL_MN2DIV_N2, width, 0);\n\tif (err)\n\t\treturn err;\n\n\tclock = devm_clk_register(d->dev, &d->dco.hw);\n\tif (IS_ERR(clock))\n\t\treturn PTR_ERR(clock);\n\n\treturn ti_adpll_setup_clock(d, clock, TI_ADPLL_DCO, d->c->output_index,\n\t\t\t\t    init.name, NULL);\n}\n\nstatic int ti_adpll_clkout_enable(struct clk_hw *hw)\n{\n\tstruct ti_adpll_clkout_data *co = to_clkout(hw);\n\tstruct clk_hw *gate_hw = &co->gate.hw;\n\n\t__clk_hw_set_clk(gate_hw, hw);\n\n\treturn clk_gate_ops.enable(gate_hw);\n}\n\nstatic void ti_adpll_clkout_disable(struct clk_hw *hw)\n{\n\tstruct ti_adpll_clkout_data *co = to_clkout(hw);\n\tstruct clk_hw *gate_hw = &co->gate.hw;\n\n\t__clk_hw_set_clk(gate_hw, hw);\n\tclk_gate_ops.disable(gate_hw);\n}\n\nstatic int ti_adpll_clkout_is_enabled(struct clk_hw *hw)\n{\n\tstruct ti_adpll_clkout_data *co = to_clkout(hw);\n\tstruct clk_hw *gate_hw = &co->gate.hw;\n\n\t__clk_hw_set_clk(gate_hw, hw);\n\n\treturn clk_gate_ops.is_enabled(gate_hw);\n}\n\n \nstatic u8 ti_adpll_clkout_get_parent(struct clk_hw *hw)\n{\n\tstruct ti_adpll_clkout_data *co = to_clkout(hw);\n\tstruct ti_adpll_data *d = co->adpll;\n\n\treturn ti_adpll_clock_is_bypass(d);\n}\n\nstatic int ti_adpll_init_clkout(struct ti_adpll_data *d,\n\t\t\t\tenum ti_adpll_clocks index,\n\t\t\t\tint output_index, int gate_bit,\n\t\t\t\tchar *name, struct clk *clk0,\n\t\t\t\tstruct clk *clk1)\n{\n\tstruct ti_adpll_clkout_data *co;\n\tstruct clk_init_data init;\n\tstruct clk_ops *ops;\n\tconst char *parent_names[2];\n\tconst char *child_name;\n\tstruct clk *clock;\n\tint err;\n\n\tco = devm_kzalloc(d->dev, sizeof(*co), GFP_KERNEL);\n\tif (!co)\n\t\treturn -ENOMEM;\n\tco->adpll = d;\n\n\terr = of_property_read_string_index(d->np,\n\t\t\t\t\t    \"clock-output-names\",\n\t\t\t\t\t    output_index,\n\t\t\t\t\t    &child_name);\n\tif (err)\n\t\treturn err;\n\n\tops = devm_kzalloc(d->dev, sizeof(*ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\tinit.name = child_name;\n\tinit.ops = ops;\n\tinit.flags = 0;\n\tco->hw.init = &init;\n\tparent_names[0] = __clk_get_name(clk0);\n\tparent_names[1] = __clk_get_name(clk1);\n\tinit.parent_names = parent_names;\n\tinit.num_parents = 2;\n\n\tops->get_parent = ti_adpll_clkout_get_parent;\n\tops->determine_rate = __clk_mux_determine_rate;\n\tif (gate_bit) {\n\t\tco->gate.lock = &d->lock;\n\t\tco->gate.reg = d->regs + ADPLL_CLKCTRL_OFFSET;\n\t\tco->gate.bit_idx = gate_bit;\n\t\tops->enable = ti_adpll_clkout_enable;\n\t\tops->disable = ti_adpll_clkout_disable;\n\t\tops->is_enabled = ti_adpll_clkout_is_enabled;\n\t}\n\n\tclock = devm_clk_register(d->dev, &co->hw);\n\tif (IS_ERR(clock)) {\n\t\tdev_err(d->dev, \"failed to register output %s: %li\\n\",\n\t\t\tname, PTR_ERR(clock));\n\t\treturn PTR_ERR(clock);\n\t}\n\n\treturn ti_adpll_setup_clock(d, clock, index, output_index, child_name,\n\t\t\t\t    NULL);\n}\n\nstatic int ti_adpll_init_children_adpll_s(struct ti_adpll_data *d)\n{\n\tint err;\n\n\tif (!d->c->is_type_s)\n\t\treturn 0;\n\n\t \n\terr = ti_adpll_init_mux(d, TI_ADPLL_BYPASS, \"bypass\",\n\t\t\t\td->clocks[TI_ADPLL_N2].clk,\n\t\t\t\td->parent_clocks[TI_ADPLL_CLKINPULOW],\n\t\t\t\td->regs + ADPLL_CLKCTRL_OFFSET,\n\t\t\t\tADPLL_CLKCTRL_ULOWCLKEN);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ti_adpll_init_divider(d, TI_ADPLL_M2, -ENODEV, \"m2\",\n\t\t\t\t    d->clocks[TI_ADPLL_DCO].clk,\n\t\t\t\t    d->regs + ADPLL_M2NDIV_OFFSET,\n\t\t\t\t    ADPLL_M2NDIV_M2,\n\t\t\t\t    ADPLL_M2NDIV_M2_ADPLL_S_WIDTH,\n\t\t\t\t    CLK_DIVIDER_ONE_BASED);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ti_adpll_init_fixed_factor(d, TI_ADPLL_DIV2, \"div2\",\n\t\t\t\t\t d->clocks[TI_ADPLL_M2].clk,\n\t\t\t\t\t 1, 2);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ti_adpll_init_clkout(d, TI_ADPLL_CLKOUT, TI_ADPLL_S_CLKOUT,\n\t\t\t\t   ADPLL_CLKCTRL_CLKOUTEN, \"clkout\",\n\t\t\t\t   d->clocks[TI_ADPLL_DIV2].clk,\n\t\t\t\t   d->clocks[TI_ADPLL_BYPASS].clk);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ti_adpll_init_clkout(d, TI_ADPLL_CLKOUT2, TI_ADPLL_S_CLKOUTX2, 0,\n\t\t\t\t   \"clkout2\", d->clocks[TI_ADPLL_M2].clk,\n\t\t\t\t   d->clocks[TI_ADPLL_BYPASS].clk);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (d->parent_clocks[TI_ADPLL_CLKINPHIF]) {\n\t\terr = ti_adpll_init_mux(d, TI_ADPLL_HIF, \"hif\",\n\t\t\t\t\td->clocks[TI_ADPLL_DCO].clk,\n\t\t\t\t\td->parent_clocks[TI_ADPLL_CLKINPHIF],\n\t\t\t\t\td->regs + ADPLL_CLKCTRL_OFFSET,\n\t\t\t\t\tADPLL_CLKINPHIFSEL_ADPLL_S);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = ti_adpll_init_divider(d, TI_ADPLL_M3, TI_ADPLL_S_CLKOUTHIF, \"m3\",\n\t\t\t\t    d->clocks[TI_ADPLL_HIF].clk,\n\t\t\t\t    d->regs + ADPLL_M3DIV_OFFSET,\n\t\t\t\t    ADPLL_M3DIV_M3,\n\t\t\t\t    ADPLL_M3DIV_M3_WIDTH,\n\t\t\t\t    CLK_DIVIDER_ONE_BASED);\n\tif (err)\n\t\treturn err;\n\n\t \n\n\treturn 0;\n}\n\nstatic int ti_adpll_init_children_adpll_lj(struct ti_adpll_data *d)\n{\n\tint err;\n\n\tif (d->c->is_type_s)\n\t\treturn 0;\n\n\t \n\terr = ti_adpll_init_gate(d, TI_ADPLL_DCO_GATE, TI_ADPLL_LJ_CLKDCOLDO,\n\t\t\t\t \"clkdcoldo\", d->clocks[TI_ADPLL_DCO].clk,\n\t\t\t\t d->regs + ADPLL_CLKCTRL_OFFSET,\n\t\t\t\t ADPLL_CLKCTRL_CLKDCOLDOEN, 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ti_adpll_init_divider(d, TI_ADPLL_M2, -ENODEV,\n\t\t\t\t    \"m2\", d->clocks[TI_ADPLL_DCO].clk,\n\t\t\t\t    d->regs + ADPLL_M2NDIV_OFFSET,\n\t\t\t\t    ADPLL_M2NDIV_M2,\n\t\t\t\t    ADPLL_M2NDIV_M2_ADPLL_LJ_WIDTH,\n\t\t\t\t    CLK_DIVIDER_ONE_BASED);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ti_adpll_init_gate(d, TI_ADPLL_M2_GATE, TI_ADPLL_LJ_CLKOUTLDO,\n\t\t\t\t \"clkoutldo\", d->clocks[TI_ADPLL_M2].clk,\n\t\t\t\t d->regs + ADPLL_CLKCTRL_OFFSET,\n\t\t\t\t ADPLL_CLKCTRL_CLKOUTLDOEN_ADPLL_LJ,\n\t\t\t\t 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ti_adpll_init_mux(d, TI_ADPLL_BYPASS, \"bypass\",\n\t\t\t\td->clocks[TI_ADPLL_N2].clk,\n\t\t\t\td->parent_clocks[TI_ADPLL_CLKINPULOW],\n\t\t\t\td->regs + ADPLL_CLKCTRL_OFFSET,\n\t\t\t\tADPLL_CLKCTRL_ULOWCLKEN);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ti_adpll_init_clkout(d, TI_ADPLL_CLKOUT, TI_ADPLL_S_CLKOUT,\n\t\t\t\t   ADPLL_CLKCTRL_CLKOUTEN, \"clkout\",\n\t\t\t\t   d->clocks[TI_ADPLL_M2].clk,\n\t\t\t\t   d->clocks[TI_ADPLL_BYPASS].clk);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void ti_adpll_free_resources(struct ti_adpll_data *d)\n{\n\tint i;\n\n\tfor (i = TI_ADPLL_M3; i >= 0; i--) {\n\t\tstruct ti_adpll_clock *ac = &d->clocks[i];\n\n\t\tif (!ac || IS_ERR_OR_NULL(ac->clk))\n\t\t\tcontinue;\n\t\tif (ac->cl)\n\t\t\tclkdev_drop(ac->cl);\n\t\tif (ac->unregister)\n\t\t\tac->unregister(ac->clk);\n\t}\n}\n\n \nstatic void ti_adpll_unlock_all(void __iomem *reg)\n{\n\tu32 v;\n\n\tv = readl_relaxed(reg);\n\tif (v == ADPLL_PLLSS_MMR_LOCK_ENABLED)\n\t\twritel_relaxed(ADPLL_PLLSS_MMR_UNLOCK_MAGIC, reg);\n}\n\nstatic int ti_adpll_init_registers(struct ti_adpll_data *d)\n{\n\tint register_offset = 0;\n\n\tif (d->c->is_type_s) {\n\t\tregister_offset = 8;\n\t\tti_adpll_unlock_all(d->iobase + ADPLL_PLLSS_MMR_LOCK_OFFSET);\n\t}\n\n\td->regs = d->iobase + register_offset + ADPLL_PWRCTRL_OFFSET;\n\n\treturn 0;\n}\n\nstatic int ti_adpll_init_inputs(struct ti_adpll_data *d)\n{\n\tstatic const char error[] = \"need at least %i inputs\";\n\tstruct clk *clock;\n\tint nr_inputs;\n\n\tnr_inputs = of_clk_get_parent_count(d->np);\n\tif (nr_inputs < d->c->nr_max_inputs) {\n\t\tdev_err(d->dev, error, nr_inputs);\n\t\treturn -EINVAL;\n\t}\n\tof_clk_parent_fill(d->np, d->parent_names, nr_inputs);\n\n\tclock = devm_clk_get(d->dev, d->parent_names[0]);\n\tif (IS_ERR(clock)) {\n\t\tdev_err(d->dev, \"could not get clkinp\\n\");\n\t\treturn PTR_ERR(clock);\n\t}\n\td->parent_clocks[TI_ADPLL_CLKINP] = clock;\n\n\tclock = devm_clk_get(d->dev, d->parent_names[1]);\n\tif (IS_ERR(clock)) {\n\t\tdev_err(d->dev, \"could not get clkinpulow clock\\n\");\n\t\treturn PTR_ERR(clock);\n\t}\n\td->parent_clocks[TI_ADPLL_CLKINPULOW] = clock;\n\n\tif (d->c->is_type_s) {\n\t\tclock =  devm_clk_get(d->dev, d->parent_names[2]);\n\t\tif (IS_ERR(clock)) {\n\t\t\tdev_err(d->dev, \"could not get clkinphif clock\\n\");\n\t\t\treturn PTR_ERR(clock);\n\t\t}\n\t\td->parent_clocks[TI_ADPLL_CLKINPHIF] = clock;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ti_adpll_platform_data ti_adpll_type_s = {\n\t.is_type_s = true,\n\t.nr_max_inputs = MAX_ADPLL_INPUTS,\n\t.nr_max_outputs = MAX_ADPLL_OUTPUTS,\n\t.output_index = TI_ADPLL_S_DCOCLKLDO,\n};\n\nstatic const struct ti_adpll_platform_data ti_adpll_type_lj = {\n\t.is_type_s = false,\n\t.nr_max_inputs = MAX_ADPLL_INPUTS - 1,\n\t.nr_max_outputs = MAX_ADPLL_OUTPUTS - 1,\n\t.output_index = -EINVAL,\n};\n\nstatic const struct of_device_id ti_adpll_match[] = {\n\t{ .compatible = \"ti,dm814-adpll-s-clock\", &ti_adpll_type_s },\n\t{ .compatible = \"ti,dm814-adpll-lj-clock\", &ti_adpll_type_lj },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ti_adpll_match);\n\nstatic int ti_adpll_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *match;\n\tconst struct ti_adpll_platform_data *pdata;\n\tstruct ti_adpll_data *d;\n\tstruct resource *res;\n\tint err;\n\n\tmatch = of_match_device(ti_adpll_match, dev);\n\tif (match)\n\t\tpdata = match->data;\n\telse\n\t\treturn -ENODEV;\n\n\td = devm_kzalloc(dev, sizeof(*d), GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\td->dev = dev;\n\td->np = node;\n\td->c = pdata;\n\tdev_set_drvdata(d->dev, d);\n\tspin_lock_init(&d->lock);\n\n\td->iobase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(d->iobase))\n\t\treturn PTR_ERR(d->iobase);\n\td->pa = res->start;\n\n\terr = ti_adpll_init_registers(d);\n\tif (err)\n\t\treturn err;\n\n\terr = ti_adpll_init_inputs(d);\n\tif (err)\n\t\treturn err;\n\n\td->clocks = devm_kcalloc(d->dev,\n\t\t\t\t TI_ADPLL_NR_CLOCKS,\n\t\t\t\t sizeof(struct ti_adpll_clock),\n\t\t\t\t GFP_KERNEL);\n\tif (!d->clocks)\n\t\treturn -ENOMEM;\n\n\terr = ti_adpll_init_dco(d);\n\tif (err) {\n\t\tdev_err(dev, \"could not register dco: %i\\n\", err);\n\t\tgoto free;\n\t}\n\n\terr = ti_adpll_init_children_adpll_s(d);\n\tif (err)\n\t\tgoto free;\n\terr = ti_adpll_init_children_adpll_lj(d);\n\tif (err)\n\t\tgoto free;\n\n\terr = of_clk_add_provider(d->np, of_clk_src_onecell_get, &d->outputs);\n\tif (err)\n\t\tgoto free;\n\n\treturn 0;\n\nfree:\n\tWARN_ON(1);\n\tti_adpll_free_resources(d);\n\n\treturn err;\n}\n\nstatic void ti_adpll_remove(struct platform_device *pdev)\n{\n\tstruct ti_adpll_data *d = dev_get_drvdata(&pdev->dev);\n\n\tti_adpll_free_resources(d);\n}\n\nstatic struct platform_driver ti_adpll_driver = {\n\t.driver = {\n\t\t.name = \"ti-adpll\",\n\t\t.of_match_table = ti_adpll_match,\n\t},\n\t.probe = ti_adpll_probe,\n\t.remove_new = ti_adpll_remove,\n};\n\nstatic int __init ti_adpll_init(void)\n{\n\treturn platform_driver_register(&ti_adpll_driver);\n}\ncore_initcall(ti_adpll_init);\n\nstatic void __exit ti_adpll_exit(void)\n{\n\tplatform_driver_unregister(&ti_adpll_driver);\n}\nmodule_exit(ti_adpll_exit);\n\nMODULE_DESCRIPTION(\"Clock driver for dm814x ADPLL\");\nMODULE_ALIAS(\"platform:dm814-adpll-clock\");\nMODULE_AUTHOR(\"Tony LIndgren <tony@atomide.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}