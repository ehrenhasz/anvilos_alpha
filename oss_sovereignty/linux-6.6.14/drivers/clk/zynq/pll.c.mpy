{
  "module_name": "pll.c",
  "hash_id": "83615c0ba2506e66de255e162a86e09f6bab9ce5a3d55bc113306d12c3da8106",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/zynq/pll.c",
  "human_readable_source": "\n \n#include <linux/clk/zynq.h>\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n \nstruct zynq_pll {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*pll_ctrl;\n\tvoid __iomem\t*pll_status;\n\tspinlock_t\t*lock;\n\tu8\t\tlockbit;\n};\n#define to_zynq_pll(_hw)\tcontainer_of(_hw, struct zynq_pll, hw)\n\n \n#define PLLCTRL_FBDIV_MASK\t0x7f000\n#define PLLCTRL_FBDIV_SHIFT\t12\n#define PLLCTRL_BPQUAL_MASK\t(1 << 3)\n#define PLLCTRL_PWRDWN_MASK\t2\n#define PLLCTRL_PWRDWN_SHIFT\t1\n#define PLLCTRL_RESET_MASK\t1\n#define PLLCTRL_RESET_SHIFT\t0\n\n#define PLL_FBDIV_MIN\t13\n#define PLL_FBDIV_MAX\t66\n\n \nstatic long zynq_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long *prate)\n{\n\tu32 fbdiv;\n\n\tfbdiv = DIV_ROUND_CLOSEST(rate, *prate);\n\tif (fbdiv < PLL_FBDIV_MIN)\n\t\tfbdiv = PLL_FBDIV_MIN;\n\telse if (fbdiv > PLL_FBDIV_MAX)\n\t\tfbdiv = PLL_FBDIV_MAX;\n\n\treturn *prate * fbdiv;\n}\n\n \nstatic unsigned long zynq_pll_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct zynq_pll *clk = to_zynq_pll(hw);\n\tu32 fbdiv;\n\n\t \n\tfbdiv = (readl(clk->pll_ctrl) & PLLCTRL_FBDIV_MASK) >>\n\t\t\tPLLCTRL_FBDIV_SHIFT;\n\n\treturn parent_rate * fbdiv;\n}\n\n \nstatic int zynq_pll_is_enabled(struct clk_hw *hw)\n{\n\tunsigned long flags = 0;\n\tu32 reg;\n\tstruct zynq_pll *clk = to_zynq_pll(hw);\n\n\tspin_lock_irqsave(clk->lock, flags);\n\n\treg = readl(clk->pll_ctrl);\n\n\tspin_unlock_irqrestore(clk->lock, flags);\n\n\treturn !(reg & (PLLCTRL_RESET_MASK | PLLCTRL_PWRDWN_MASK));\n}\n\n \nstatic int zynq_pll_enable(struct clk_hw *hw)\n{\n\tunsigned long flags = 0;\n\tu32 reg;\n\tstruct zynq_pll *clk = to_zynq_pll(hw);\n\n\tif (zynq_pll_is_enabled(hw))\n\t\treturn 0;\n\n\tpr_info(\"PLL: enable\\n\");\n\n\t \n\tspin_lock_irqsave(clk->lock, flags);\n\n\treg = readl(clk->pll_ctrl);\n\treg &= ~(PLLCTRL_RESET_MASK | PLLCTRL_PWRDWN_MASK);\n\twritel(reg, clk->pll_ctrl);\n\twhile (!(readl(clk->pll_status) & (1 << clk->lockbit)))\n\t\t;\n\n\tspin_unlock_irqrestore(clk->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void zynq_pll_disable(struct clk_hw *hw)\n{\n\tunsigned long flags = 0;\n\tu32 reg;\n\tstruct zynq_pll *clk = to_zynq_pll(hw);\n\n\tif (!zynq_pll_is_enabled(hw))\n\t\treturn;\n\n\tpr_info(\"PLL: shutdown\\n\");\n\n\t \n\tspin_lock_irqsave(clk->lock, flags);\n\n\treg = readl(clk->pll_ctrl);\n\treg |= PLLCTRL_RESET_MASK | PLLCTRL_PWRDWN_MASK;\n\twritel(reg, clk->pll_ctrl);\n\n\tspin_unlock_irqrestore(clk->lock, flags);\n}\n\nstatic const struct clk_ops zynq_pll_ops = {\n\t.enable = zynq_pll_enable,\n\t.disable = zynq_pll_disable,\n\t.is_enabled = zynq_pll_is_enabled,\n\t.round_rate = zynq_pll_round_rate,\n\t.recalc_rate = zynq_pll_recalc_rate\n};\n\n \nstruct clk *clk_register_zynq_pll(const char *name, const char *parent,\n\t\tvoid __iomem *pll_ctrl, void __iomem *pll_status, u8 lock_index,\n\t\tspinlock_t *lock)\n{\n\tstruct zynq_pll *pll;\n\tstruct clk *clk;\n\tu32 reg;\n\tconst char *parent_arr[1] = {parent};\n\tunsigned long flags = 0;\n\tstruct clk_init_data initd = {\n\t\t.name = name,\n\t\t.parent_names = parent_arr,\n\t\t.ops = &zynq_pll_ops,\n\t\t.num_parents = 1,\n\t\t.flags = 0\n\t};\n\n\tpll = kmalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tpll->hw.init = &initd;\n\tpll->pll_ctrl = pll_ctrl;\n\tpll->pll_status = pll_status;\n\tpll->lockbit = lock_index;\n\tpll->lock = lock;\n\n\tspin_lock_irqsave(pll->lock, flags);\n\n\treg = readl(pll->pll_ctrl);\n\treg &= ~PLLCTRL_BPQUAL_MASK;\n\twritel(reg, pll->pll_ctrl);\n\n\tspin_unlock_irqrestore(pll->lock, flags);\n\n\tclk = clk_register(NULL, &pll->hw);\n\tif (WARN_ON(IS_ERR(clk)))\n\t\tgoto free_pll;\n\n\treturn clk;\n\nfree_pll:\n\tkfree(pll);\n\n\treturn clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}