{
  "module_name": "clkc.c",
  "hash_id": "3fd3da3306935c1cc8598c1c3ced1ba3baf8a8344d66166d71686fde2f250b64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/zynq/clkc.c",
  "human_readable_source": "\n \n\n#include <linux/clk/zynq.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/io.h>\n\nstatic void __iomem *zynq_clkc_base;\n\n#define SLCR_ARMPLL_CTRL\t\t(zynq_clkc_base + 0x00)\n#define SLCR_DDRPLL_CTRL\t\t(zynq_clkc_base + 0x04)\n#define SLCR_IOPLL_CTRL\t\t\t(zynq_clkc_base + 0x08)\n#define SLCR_PLL_STATUS\t\t\t(zynq_clkc_base + 0x0c)\n#define SLCR_ARM_CLK_CTRL\t\t(zynq_clkc_base + 0x20)\n#define SLCR_DDR_CLK_CTRL\t\t(zynq_clkc_base + 0x24)\n#define SLCR_DCI_CLK_CTRL\t\t(zynq_clkc_base + 0x28)\n#define SLCR_APER_CLK_CTRL\t\t(zynq_clkc_base + 0x2c)\n#define SLCR_GEM0_CLK_CTRL\t\t(zynq_clkc_base + 0x40)\n#define SLCR_GEM1_CLK_CTRL\t\t(zynq_clkc_base + 0x44)\n#define SLCR_SMC_CLK_CTRL\t\t(zynq_clkc_base + 0x48)\n#define SLCR_LQSPI_CLK_CTRL\t\t(zynq_clkc_base + 0x4c)\n#define SLCR_SDIO_CLK_CTRL\t\t(zynq_clkc_base + 0x50)\n#define SLCR_UART_CLK_CTRL\t\t(zynq_clkc_base + 0x54)\n#define SLCR_SPI_CLK_CTRL\t\t(zynq_clkc_base + 0x58)\n#define SLCR_CAN_CLK_CTRL\t\t(zynq_clkc_base + 0x5c)\n#define SLCR_CAN_MIOCLK_CTRL\t\t(zynq_clkc_base + 0x60)\n#define SLCR_DBG_CLK_CTRL\t\t(zynq_clkc_base + 0x64)\n#define SLCR_PCAP_CLK_CTRL\t\t(zynq_clkc_base + 0x68)\n#define SLCR_FPGA0_CLK_CTRL\t\t(zynq_clkc_base + 0x70)\n#define SLCR_621_TRUE\t\t\t(zynq_clkc_base + 0xc4)\n#define SLCR_SWDT_CLK_SEL\t\t(zynq_clkc_base + 0x204)\n\n#define NUM_MIO_PINS\t54\n\n#define DBG_CLK_CTRL_CLKACT_TRC\t\tBIT(0)\n#define DBG_CLK_CTRL_CPU_1XCLKACT\tBIT(1)\n\nenum zynq_clk {\n\tarmpll, ddrpll, iopll,\n\tcpu_6or4x, cpu_3or2x, cpu_2x, cpu_1x,\n\tddr2x, ddr3x, dci,\n\tlqspi, smc, pcap, gem0, gem1, fclk0, fclk1, fclk2, fclk3, can0, can1,\n\tsdio0, sdio1, uart0, uart1, spi0, spi1, dma,\n\tusb0_aper, usb1_aper, gem0_aper, gem1_aper,\n\tsdio0_aper, sdio1_aper, spi0_aper, spi1_aper, can0_aper, can1_aper,\n\ti2c0_aper, i2c1_aper, uart0_aper, uart1_aper, gpio_aper, lqspi_aper,\n\tsmc_aper, swdt, dbg_trc, dbg_apb, clk_max};\n\nstatic struct clk *ps_clk;\nstatic struct clk *clks[clk_max];\nstatic struct clk_onecell_data clk_data;\n\nstatic DEFINE_SPINLOCK(armpll_lock);\nstatic DEFINE_SPINLOCK(ddrpll_lock);\nstatic DEFINE_SPINLOCK(iopll_lock);\nstatic DEFINE_SPINLOCK(armclk_lock);\nstatic DEFINE_SPINLOCK(swdtclk_lock);\nstatic DEFINE_SPINLOCK(ddrclk_lock);\nstatic DEFINE_SPINLOCK(dciclk_lock);\nstatic DEFINE_SPINLOCK(gem0clk_lock);\nstatic DEFINE_SPINLOCK(gem1clk_lock);\nstatic DEFINE_SPINLOCK(canclk_lock);\nstatic DEFINE_SPINLOCK(canmioclk_lock);\nstatic DEFINE_SPINLOCK(dbgclk_lock);\nstatic DEFINE_SPINLOCK(aperclk_lock);\n\nstatic const char *const armpll_parents[] __initconst = {\"armpll_int\",\n\t\"ps_clk\"};\nstatic const char *const ddrpll_parents[] __initconst = {\"ddrpll_int\",\n\t\"ps_clk\"};\nstatic const char *const iopll_parents[] __initconst = {\"iopll_int\",\n\t\"ps_clk\"};\nstatic const char *gem0_mux_parents[] __initdata = {\"gem0_div1\", \"dummy_name\"};\nstatic const char *gem1_mux_parents[] __initdata = {\"gem1_div1\", \"dummy_name\"};\nstatic const char *const can0_mio_mux2_parents[] __initconst = {\"can0_gate\",\n\t\"can0_mio_mux\"};\nstatic const char *const can1_mio_mux2_parents[] __initconst = {\"can1_gate\",\n\t\"can1_mio_mux\"};\nstatic const char *dbg_emio_mux_parents[] __initdata = {\"dbg_div\",\n\t\"dummy_name\"};\n\nstatic const char *const dbgtrc_emio_input_names[] __initconst = {\n\t\"trace_emio_clk\"};\nstatic const char *const gem0_emio_input_names[] __initconst = {\n\t\"gem0_emio_clk\"};\nstatic const char *const gem1_emio_input_names[] __initconst = {\n\t\"gem1_emio_clk\"};\nstatic const char *const swdt_ext_clk_input_names[] __initconst = {\n\t\"swdt_ext_clk\"};\n\nstatic void __init zynq_clk_register_fclk(enum zynq_clk fclk,\n\t\tconst char *clk_name, void __iomem *fclk_ctrl_reg,\n\t\tconst char **parents, int enable)\n{\n\tu32 enable_reg;\n\tchar *mux_name;\n\tchar *div0_name;\n\tchar *div1_name;\n\tspinlock_t *fclk_lock;\n\tspinlock_t *fclk_gate_lock;\n\tvoid __iomem *fclk_gate_reg = fclk_ctrl_reg + 8;\n\n\tfclk_lock = kmalloc(sizeof(*fclk_lock), GFP_KERNEL);\n\tif (!fclk_lock)\n\t\tgoto err;\n\tfclk_gate_lock = kmalloc(sizeof(*fclk_gate_lock), GFP_KERNEL);\n\tif (!fclk_gate_lock)\n\t\tgoto err_fclk_gate_lock;\n\tspin_lock_init(fclk_lock);\n\tspin_lock_init(fclk_gate_lock);\n\n\tmux_name = kasprintf(GFP_KERNEL, \"%s_mux\", clk_name);\n\tif (!mux_name)\n\t\tgoto err_mux_name;\n\tdiv0_name = kasprintf(GFP_KERNEL, \"%s_div0\", clk_name);\n\tif (!div0_name)\n\t\tgoto err_div0_name;\n\tdiv1_name = kasprintf(GFP_KERNEL, \"%s_div1\", clk_name);\n\tif (!div1_name)\n\t\tgoto err_div1_name;\n\n\tclk_register_mux(NULL, mux_name, parents, 4,\n\t\t\tCLK_SET_RATE_NO_REPARENT, fclk_ctrl_reg, 4, 2, 0,\n\t\t\tfclk_lock);\n\n\tclk_register_divider(NULL, div0_name, mux_name,\n\t\t\t0, fclk_ctrl_reg, 8, 6, CLK_DIVIDER_ONE_BASED |\n\t\t\tCLK_DIVIDER_ALLOW_ZERO, fclk_lock);\n\n\tclk_register_divider(NULL, div1_name, div0_name,\n\t\t\tCLK_SET_RATE_PARENT, fclk_ctrl_reg, 20, 6,\n\t\t\tCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\n\t\t\tfclk_lock);\n\n\tclks[fclk] = clk_register_gate(NULL, clk_name,\n\t\t\tdiv1_name, CLK_SET_RATE_PARENT, fclk_gate_reg,\n\t\t\t0, CLK_GATE_SET_TO_DISABLE, fclk_gate_lock);\n\tenable_reg = readl(fclk_gate_reg) & 1;\n\tif (enable && !enable_reg) {\n\t\tif (clk_prepare_enable(clks[fclk]))\n\t\t\tpr_warn(\"%s: FCLK%u enable failed\\n\", __func__,\n\t\t\t\t\tfclk - fclk0);\n\t}\n\tkfree(mux_name);\n\tkfree(div0_name);\n\tkfree(div1_name);\n\n\treturn;\n\nerr_div1_name:\n\tkfree(div0_name);\nerr_div0_name:\n\tkfree(mux_name);\nerr_mux_name:\n\tkfree(fclk_gate_lock);\nerr_fclk_gate_lock:\n\tkfree(fclk_lock);\nerr:\n\tclks[fclk] = ERR_PTR(-ENOMEM);\n}\n\nstatic void __init zynq_clk_register_periph_clk(enum zynq_clk clk0,\n\t\tenum zynq_clk clk1, const char *clk_name0,\n\t\tconst char *clk_name1, void __iomem *clk_ctrl,\n\t\tconst char **parents, unsigned int two_gates)\n{\n\tchar *mux_name;\n\tchar *div_name;\n\tspinlock_t *lock;\n\n\tlock = kmalloc(sizeof(*lock), GFP_KERNEL);\n\tif (!lock)\n\t\tgoto err;\n\tspin_lock_init(lock);\n\n\tmux_name = kasprintf(GFP_KERNEL, \"%s_mux\", clk_name0);\n\tdiv_name = kasprintf(GFP_KERNEL, \"%s_div\", clk_name0);\n\n\tclk_register_mux(NULL, mux_name, parents, 4,\n\t\t\tCLK_SET_RATE_NO_REPARENT, clk_ctrl, 4, 2, 0, lock);\n\n\tclk_register_divider(NULL, div_name, mux_name, 0, clk_ctrl, 8, 6,\n\t\t\tCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO, lock);\n\n\tclks[clk0] = clk_register_gate(NULL, clk_name0, div_name,\n\t\t\tCLK_SET_RATE_PARENT, clk_ctrl, 0, 0, lock);\n\tif (two_gates)\n\t\tclks[clk1] = clk_register_gate(NULL, clk_name1, div_name,\n\t\t\t\tCLK_SET_RATE_PARENT, clk_ctrl, 1, 0, lock);\n\n\tkfree(mux_name);\n\tkfree(div_name);\n\n\treturn;\n\nerr:\n\tclks[clk0] = ERR_PTR(-ENOMEM);\n\tif (two_gates)\n\t\tclks[clk1] = ERR_PTR(-ENOMEM);\n}\n\nstatic void __init zynq_clk_setup(struct device_node *np)\n{\n\tint i;\n\tu32 tmp;\n\tint ret;\n\tchar *clk_name;\n\tunsigned int fclk_enable = 0;\n\tconst char *clk_output_name[clk_max];\n\tconst char *cpu_parents[4];\n\tconst char *periph_parents[4];\n\tconst char *swdt_ext_clk_mux_parents[2];\n\tconst char *can_mio_mux_parents[NUM_MIO_PINS];\n\tconst char *dummy_nm = \"dummy_name\";\n\n\tpr_info(\"Zynq clock init\\n\");\n\n\t \n\tfor (i = 0; i < clk_max; i++) {\n\t\tif (of_property_read_string_index(np, \"clock-output-names\",\n\t\t\t\t  i, &clk_output_name[i])) {\n\t\t\tpr_err(\"%s: clock output name not in DT\\n\", __func__);\n\t\t\tBUG();\n\t\t}\n\t}\n\tcpu_parents[0] = clk_output_name[armpll];\n\tcpu_parents[1] = clk_output_name[armpll];\n\tcpu_parents[2] = clk_output_name[ddrpll];\n\tcpu_parents[3] = clk_output_name[iopll];\n\tperiph_parents[0] = clk_output_name[iopll];\n\tperiph_parents[1] = clk_output_name[iopll];\n\tperiph_parents[2] = clk_output_name[armpll];\n\tperiph_parents[3] = clk_output_name[ddrpll];\n\n\tof_property_read_u32(np, \"fclk-enable\", &fclk_enable);\n\n\t \n\tret = of_property_read_u32(np, \"ps-clk-frequency\", &tmp);\n\tif (ret) {\n\t\tpr_warn(\"ps_clk frequency not specified, using 33 MHz.\\n\");\n\t\ttmp = 33333333;\n\t}\n\tps_clk = clk_register_fixed_rate(NULL, \"ps_clk\", NULL, 0, tmp);\n\n\t \n\tclk_register_zynq_pll(\"armpll_int\", \"ps_clk\", SLCR_ARMPLL_CTRL,\n\t\t\tSLCR_PLL_STATUS, 0, &armpll_lock);\n\tclks[armpll] = clk_register_mux(NULL, clk_output_name[armpll],\n\t\t\tarmpll_parents, 2, CLK_SET_RATE_NO_REPARENT,\n\t\t\tSLCR_ARMPLL_CTRL, 4, 1, 0, &armpll_lock);\n\n\tclk_register_zynq_pll(\"ddrpll_int\", \"ps_clk\", SLCR_DDRPLL_CTRL,\n\t\t\tSLCR_PLL_STATUS, 1, &ddrpll_lock);\n\tclks[ddrpll] = clk_register_mux(NULL, clk_output_name[ddrpll],\n\t\t\tddrpll_parents, 2, CLK_SET_RATE_NO_REPARENT,\n\t\t\tSLCR_DDRPLL_CTRL, 4, 1, 0, &ddrpll_lock);\n\n\tclk_register_zynq_pll(\"iopll_int\", \"ps_clk\", SLCR_IOPLL_CTRL,\n\t\t\tSLCR_PLL_STATUS, 2, &iopll_lock);\n\tclks[iopll] = clk_register_mux(NULL, clk_output_name[iopll],\n\t\t\tiopll_parents, 2, CLK_SET_RATE_NO_REPARENT,\n\t\t\tSLCR_IOPLL_CTRL, 4, 1, 0, &iopll_lock);\n\n\t \n\ttmp = readl(SLCR_621_TRUE) & 1;\n\tclk_register_mux(NULL, \"cpu_mux\", cpu_parents, 4,\n\t\t\tCLK_SET_RATE_NO_REPARENT, SLCR_ARM_CLK_CTRL, 4, 2, 0,\n\t\t\t&armclk_lock);\n\tclk_register_divider(NULL, \"cpu_div\", \"cpu_mux\", 0,\n\t\t\tSLCR_ARM_CLK_CTRL, 8, 6, CLK_DIVIDER_ONE_BASED |\n\t\t\tCLK_DIVIDER_ALLOW_ZERO, &armclk_lock);\n\n\tclks[cpu_6or4x] = clk_register_gate(NULL, clk_output_name[cpu_6or4x],\n\t\t\t\"cpu_div\", CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,\n\t\t\tSLCR_ARM_CLK_CTRL, 24, 0, &armclk_lock);\n\n\tclk_register_fixed_factor(NULL, \"cpu_3or2x_div\", \"cpu_div\", 0,\n\t\t\t1, 2);\n\tclks[cpu_3or2x] = clk_register_gate(NULL, clk_output_name[cpu_3or2x],\n\t\t\t\"cpu_3or2x_div\", CLK_IGNORE_UNUSED,\n\t\t\tSLCR_ARM_CLK_CTRL, 25, 0, &armclk_lock);\n\n\tclk_register_fixed_factor(NULL, \"cpu_2x_div\", \"cpu_div\", 0, 1,\n\t\t\t2 + tmp);\n\tclks[cpu_2x] = clk_register_gate(NULL, clk_output_name[cpu_2x],\n\t\t\t\"cpu_2x_div\", CLK_IGNORE_UNUSED, SLCR_ARM_CLK_CTRL,\n\t\t\t26, 0, &armclk_lock);\n\tclk_prepare_enable(clks[cpu_2x]);\n\n\tclk_register_fixed_factor(NULL, \"cpu_1x_div\", \"cpu_div\", 0, 1,\n\t\t\t4 + 2 * tmp);\n\tclks[cpu_1x] = clk_register_gate(NULL, clk_output_name[cpu_1x],\n\t\t\t\"cpu_1x_div\", CLK_IGNORE_UNUSED, SLCR_ARM_CLK_CTRL, 27,\n\t\t\t0, &armclk_lock);\n\n\t \n\tswdt_ext_clk_mux_parents[0] = clk_output_name[cpu_1x];\n\tfor (i = 0; i < ARRAY_SIZE(swdt_ext_clk_input_names); i++) {\n\t\tint idx = of_property_match_string(np, \"clock-names\",\n\t\t\t\tswdt_ext_clk_input_names[i]);\n\t\tif (idx >= 0)\n\t\t\tswdt_ext_clk_mux_parents[i + 1] =\n\t\t\t\tof_clk_get_parent_name(np, idx);\n\t\telse\n\t\t\tswdt_ext_clk_mux_parents[i + 1] = dummy_nm;\n\t}\n\tclks[swdt] = clk_register_mux(NULL, clk_output_name[swdt],\n\t\t\tswdt_ext_clk_mux_parents, 2, CLK_SET_RATE_PARENT |\n\t\t\tCLK_SET_RATE_NO_REPARENT, SLCR_SWDT_CLK_SEL, 0, 1, 0,\n\t\t\t&swdtclk_lock);\n\n\t \n\tclk_register_divider(NULL, \"ddr2x_div\", \"ddrpll\", 0,\n\t\t\tSLCR_DDR_CLK_CTRL, 26, 6, CLK_DIVIDER_ONE_BASED |\n\t\t\tCLK_DIVIDER_ALLOW_ZERO, &ddrclk_lock);\n\tclks[ddr2x] = clk_register_gate(NULL, clk_output_name[ddr2x],\n\t\t\t\"ddr2x_div\", 0, SLCR_DDR_CLK_CTRL, 1, 0, &ddrclk_lock);\n\tclk_prepare_enable(clks[ddr2x]);\n\tclk_register_divider(NULL, \"ddr3x_div\", \"ddrpll\", 0,\n\t\t\tSLCR_DDR_CLK_CTRL, 20, 6, CLK_DIVIDER_ONE_BASED |\n\t\t\tCLK_DIVIDER_ALLOW_ZERO, &ddrclk_lock);\n\tclks[ddr3x] = clk_register_gate(NULL, clk_output_name[ddr3x],\n\t\t\t\"ddr3x_div\", 0, SLCR_DDR_CLK_CTRL, 0, 0, &ddrclk_lock);\n\tclk_prepare_enable(clks[ddr3x]);\n\n\tclk_register_divider(NULL, \"dci_div0\", \"ddrpll\", 0,\n\t\t\tSLCR_DCI_CLK_CTRL, 8, 6, CLK_DIVIDER_ONE_BASED |\n\t\t\tCLK_DIVIDER_ALLOW_ZERO, &dciclk_lock);\n\tclk_register_divider(NULL, \"dci_div1\", \"dci_div0\",\n\t\t\tCLK_SET_RATE_PARENT, SLCR_DCI_CLK_CTRL, 20, 6,\n\t\t\tCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\n\t\t\t&dciclk_lock);\n\tclks[dci] = clk_register_gate(NULL, clk_output_name[dci], \"dci_div1\",\n\t\t\tCLK_SET_RATE_PARENT, SLCR_DCI_CLK_CTRL, 0, 0,\n\t\t\t&dciclk_lock);\n\tclk_prepare_enable(clks[dci]);\n\n\t \n\tfor (i = fclk0; i <= fclk3; i++) {\n\t\tint enable = !!(fclk_enable & BIT(i - fclk0));\n\n\t\tzynq_clk_register_fclk(i, clk_output_name[i],\n\t\t\t\tSLCR_FPGA0_CLK_CTRL + 0x10 * (i - fclk0),\n\t\t\t\tperiph_parents, enable);\n\t}\n\n\tzynq_clk_register_periph_clk(lqspi, clk_max, clk_output_name[lqspi], NULL,\n\t\t\t\t     SLCR_LQSPI_CLK_CTRL, periph_parents, 0);\n\n\tzynq_clk_register_periph_clk(smc, clk_max, clk_output_name[smc], NULL,\n\t\t\t\t     SLCR_SMC_CLK_CTRL, periph_parents, 0);\n\n\tzynq_clk_register_periph_clk(pcap, clk_max, clk_output_name[pcap], NULL,\n\t\t\t\t     SLCR_PCAP_CLK_CTRL, periph_parents, 0);\n\n\tzynq_clk_register_periph_clk(sdio0, sdio1, clk_output_name[sdio0],\n\t\t\tclk_output_name[sdio1], SLCR_SDIO_CLK_CTRL,\n\t\t\tperiph_parents, 1);\n\n\tzynq_clk_register_periph_clk(uart0, uart1, clk_output_name[uart0],\n\t\t\tclk_output_name[uart1], SLCR_UART_CLK_CTRL,\n\t\t\tperiph_parents, 1);\n\n\tzynq_clk_register_periph_clk(spi0, spi1, clk_output_name[spi0],\n\t\t\tclk_output_name[spi1], SLCR_SPI_CLK_CTRL,\n\t\t\tperiph_parents, 1);\n\n\tfor (i = 0; i < ARRAY_SIZE(gem0_emio_input_names); i++) {\n\t\tint idx = of_property_match_string(np, \"clock-names\",\n\t\t\t\tgem0_emio_input_names[i]);\n\t\tif (idx >= 0)\n\t\t\tgem0_mux_parents[i + 1] = of_clk_get_parent_name(np,\n\t\t\t\t\tidx);\n\t}\n\tclk_register_mux(NULL, \"gem0_mux\", periph_parents, 4,\n\t\t\tCLK_SET_RATE_NO_REPARENT, SLCR_GEM0_CLK_CTRL, 4, 2, 0,\n\t\t\t&gem0clk_lock);\n\tclk_register_divider(NULL, \"gem0_div0\", \"gem0_mux\", 0,\n\t\t\tSLCR_GEM0_CLK_CTRL, 8, 6, CLK_DIVIDER_ONE_BASED |\n\t\t\tCLK_DIVIDER_ALLOW_ZERO, &gem0clk_lock);\n\tclk_register_divider(NULL, \"gem0_div1\", \"gem0_div0\",\n\t\t\tCLK_SET_RATE_PARENT, SLCR_GEM0_CLK_CTRL, 20, 6,\n\t\t\tCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\n\t\t\t&gem0clk_lock);\n\tclk_register_mux(NULL, \"gem0_emio_mux\", gem0_mux_parents, 2,\n\t\t\tCLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,\n\t\t\tSLCR_GEM0_CLK_CTRL, 6, 1, 0,\n\t\t\t&gem0clk_lock);\n\tclks[gem0] = clk_register_gate(NULL, clk_output_name[gem0],\n\t\t\t\"gem0_emio_mux\", CLK_SET_RATE_PARENT,\n\t\t\tSLCR_GEM0_CLK_CTRL, 0, 0, &gem0clk_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(gem1_emio_input_names); i++) {\n\t\tint idx = of_property_match_string(np, \"clock-names\",\n\t\t\t\tgem1_emio_input_names[i]);\n\t\tif (idx >= 0)\n\t\t\tgem1_mux_parents[i + 1] = of_clk_get_parent_name(np,\n\t\t\t\t\tidx);\n\t}\n\tclk_register_mux(NULL, \"gem1_mux\", periph_parents, 4,\n\t\t\tCLK_SET_RATE_NO_REPARENT, SLCR_GEM1_CLK_CTRL, 4, 2, 0,\n\t\t\t&gem1clk_lock);\n\tclk_register_divider(NULL, \"gem1_div0\", \"gem1_mux\", 0,\n\t\t\tSLCR_GEM1_CLK_CTRL, 8, 6, CLK_DIVIDER_ONE_BASED |\n\t\t\tCLK_DIVIDER_ALLOW_ZERO, &gem1clk_lock);\n\tclk_register_divider(NULL, \"gem1_div1\", \"gem1_div0\",\n\t\t\tCLK_SET_RATE_PARENT, SLCR_GEM1_CLK_CTRL, 20, 6,\n\t\t\tCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\n\t\t\t&gem1clk_lock);\n\tclk_register_mux(NULL, \"gem1_emio_mux\", gem1_mux_parents, 2,\n\t\t\tCLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,\n\t\t\tSLCR_GEM1_CLK_CTRL, 6, 1, 0,\n\t\t\t&gem1clk_lock);\n\tclks[gem1] = clk_register_gate(NULL, clk_output_name[gem1],\n\t\t\t\"gem1_emio_mux\", CLK_SET_RATE_PARENT,\n\t\t\tSLCR_GEM1_CLK_CTRL, 0, 0, &gem1clk_lock);\n\n\ttmp = strlen(\"mio_clk_00x\");\n\tclk_name = kmalloc(tmp, GFP_KERNEL);\n\tfor (i = 0; i < NUM_MIO_PINS; i++) {\n\t\tint idx;\n\n\t\tsnprintf(clk_name, tmp, \"mio_clk_%2.2d\", i);\n\t\tidx = of_property_match_string(np, \"clock-names\", clk_name);\n\t\tif (idx >= 0)\n\t\t\tcan_mio_mux_parents[i] = of_clk_get_parent_name(np,\n\t\t\t\t\t\tidx);\n\t\telse\n\t\t\tcan_mio_mux_parents[i] = dummy_nm;\n\t}\n\tkfree(clk_name);\n\tclk_register_mux(NULL, \"can_mux\", periph_parents, 4,\n\t\t\tCLK_SET_RATE_NO_REPARENT, SLCR_CAN_CLK_CTRL, 4, 2, 0,\n\t\t\t&canclk_lock);\n\tclk_register_divider(NULL, \"can_div0\", \"can_mux\", 0,\n\t\t\tSLCR_CAN_CLK_CTRL, 8, 6, CLK_DIVIDER_ONE_BASED |\n\t\t\tCLK_DIVIDER_ALLOW_ZERO, &canclk_lock);\n\tclk_register_divider(NULL, \"can_div1\", \"can_div0\",\n\t\t\tCLK_SET_RATE_PARENT, SLCR_CAN_CLK_CTRL, 20, 6,\n\t\t\tCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\n\t\t\t&canclk_lock);\n\tclk_register_gate(NULL, \"can0_gate\", \"can_div1\",\n\t\t\tCLK_SET_RATE_PARENT, SLCR_CAN_CLK_CTRL, 0, 0,\n\t\t\t&canclk_lock);\n\tclk_register_gate(NULL, \"can1_gate\", \"can_div1\",\n\t\t\tCLK_SET_RATE_PARENT, SLCR_CAN_CLK_CTRL, 1, 0,\n\t\t\t&canclk_lock);\n\tclk_register_mux(NULL, \"can0_mio_mux\",\n\t\t\tcan_mio_mux_parents, 54, CLK_SET_RATE_PARENT |\n\t\t\tCLK_SET_RATE_NO_REPARENT, SLCR_CAN_MIOCLK_CTRL, 0, 6, 0,\n\t\t\t&canmioclk_lock);\n\tclk_register_mux(NULL, \"can1_mio_mux\",\n\t\t\tcan_mio_mux_parents, 54, CLK_SET_RATE_PARENT |\n\t\t\tCLK_SET_RATE_NO_REPARENT, SLCR_CAN_MIOCLK_CTRL, 16, 6,\n\t\t\t0, &canmioclk_lock);\n\tclks[can0] = clk_register_mux(NULL, clk_output_name[can0],\n\t\t\tcan0_mio_mux2_parents, 2, CLK_SET_RATE_PARENT |\n\t\t\tCLK_SET_RATE_NO_REPARENT, SLCR_CAN_MIOCLK_CTRL, 6, 1, 0,\n\t\t\t&canmioclk_lock);\n\tclks[can1] = clk_register_mux(NULL, clk_output_name[can1],\n\t\t\tcan1_mio_mux2_parents, 2, CLK_SET_RATE_PARENT |\n\t\t\tCLK_SET_RATE_NO_REPARENT, SLCR_CAN_MIOCLK_CTRL, 22, 1,\n\t\t\t0, &canmioclk_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(dbgtrc_emio_input_names); i++) {\n\t\tint idx = of_property_match_string(np, \"clock-names\",\n\t\t\t\tdbgtrc_emio_input_names[i]);\n\t\tif (idx >= 0)\n\t\t\tdbg_emio_mux_parents[i + 1] = of_clk_get_parent_name(np,\n\t\t\t\t\tidx);\n\t}\n\tclk_register_mux(NULL, \"dbg_mux\", periph_parents, 4,\n\t\t\tCLK_SET_RATE_NO_REPARENT, SLCR_DBG_CLK_CTRL, 4, 2, 0,\n\t\t\t&dbgclk_lock);\n\tclk_register_divider(NULL, \"dbg_div\", \"dbg_mux\", 0,\n\t\t\tSLCR_DBG_CLK_CTRL, 8, 6, CLK_DIVIDER_ONE_BASED |\n\t\t\tCLK_DIVIDER_ALLOW_ZERO, &dbgclk_lock);\n\tclk_register_mux(NULL, \"dbg_emio_mux\", dbg_emio_mux_parents, 2,\n\t\t\tCLK_SET_RATE_NO_REPARENT, SLCR_DBG_CLK_CTRL, 6, 1, 0,\n\t\t\t&dbgclk_lock);\n\tclks[dbg_trc] = clk_register_gate(NULL, clk_output_name[dbg_trc],\n\t\t\t\"dbg_emio_mux\", CLK_SET_RATE_PARENT, SLCR_DBG_CLK_CTRL,\n\t\t\t0, 0, &dbgclk_lock);\n\tclks[dbg_apb] = clk_register_gate(NULL, clk_output_name[dbg_apb],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_DBG_CLK_CTRL, 1, 0,\n\t\t\t&dbgclk_lock);\n\n\t \n\ttmp = readl(SLCR_DBG_CLK_CTRL);\n\tif (tmp & DBG_CLK_CTRL_CLKACT_TRC)\n\t\tif (clk_prepare_enable(clks[dbg_trc]))\n\t\t\tpr_warn(\"%s: trace clk enable failed\\n\", __func__);\n\tif (tmp & DBG_CLK_CTRL_CPU_1XCLKACT)\n\t\tif (clk_prepare_enable(clks[dbg_apb]))\n\t\t\tpr_warn(\"%s: debug APB clk enable failed\\n\", __func__);\n\n\t \n\tclks[dma] = clk_register_gate(NULL, clk_output_name[dma],\n\t\t\tclk_output_name[cpu_2x], 0, SLCR_APER_CLK_CTRL, 0, 0,\n\t\t\t&aperclk_lock);\n\tclks[usb0_aper] = clk_register_gate(NULL, clk_output_name[usb0_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 2, 0,\n\t\t\t&aperclk_lock);\n\tclks[usb1_aper] = clk_register_gate(NULL, clk_output_name[usb1_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 3, 0,\n\t\t\t&aperclk_lock);\n\tclks[gem0_aper] = clk_register_gate(NULL, clk_output_name[gem0_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 6, 0,\n\t\t\t&aperclk_lock);\n\tclks[gem1_aper] = clk_register_gate(NULL, clk_output_name[gem1_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 7, 0,\n\t\t\t&aperclk_lock);\n\tclks[sdio0_aper] = clk_register_gate(NULL, clk_output_name[sdio0_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 10, 0,\n\t\t\t&aperclk_lock);\n\tclks[sdio1_aper] = clk_register_gate(NULL, clk_output_name[sdio1_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 11, 0,\n\t\t\t&aperclk_lock);\n\tclks[spi0_aper] = clk_register_gate(NULL, clk_output_name[spi0_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 14, 0,\n\t\t\t&aperclk_lock);\n\tclks[spi1_aper] = clk_register_gate(NULL, clk_output_name[spi1_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 15, 0,\n\t\t\t&aperclk_lock);\n\tclks[can0_aper] = clk_register_gate(NULL, clk_output_name[can0_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 16, 0,\n\t\t\t&aperclk_lock);\n\tclks[can1_aper] = clk_register_gate(NULL, clk_output_name[can1_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 17, 0,\n\t\t\t&aperclk_lock);\n\tclks[i2c0_aper] = clk_register_gate(NULL, clk_output_name[i2c0_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 18, 0,\n\t\t\t&aperclk_lock);\n\tclks[i2c1_aper] = clk_register_gate(NULL, clk_output_name[i2c1_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 19, 0,\n\t\t\t&aperclk_lock);\n\tclks[uart0_aper] = clk_register_gate(NULL, clk_output_name[uart0_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 20, 0,\n\t\t\t&aperclk_lock);\n\tclks[uart1_aper] = clk_register_gate(NULL, clk_output_name[uart1_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 21, 0,\n\t\t\t&aperclk_lock);\n\tclks[gpio_aper] = clk_register_gate(NULL, clk_output_name[gpio_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 22, 0,\n\t\t\t&aperclk_lock);\n\tclks[lqspi_aper] = clk_register_gate(NULL, clk_output_name[lqspi_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 23, 0,\n\t\t\t&aperclk_lock);\n\tclks[smc_aper] = clk_register_gate(NULL, clk_output_name[smc_aper],\n\t\t\tclk_output_name[cpu_1x], 0, SLCR_APER_CLK_CTRL, 24, 0,\n\t\t\t&aperclk_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(clks); i++) {\n\t\tif (IS_ERR(clks[i])) {\n\t\t\tpr_err(\"Zynq clk %d: register failed with %ld\\n\",\n\t\t\t       i, PTR_ERR(clks[i]));\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tclk_data.clks = clks;\n\tclk_data.clk_num = ARRAY_SIZE(clks);\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);\n}\n\nCLK_OF_DECLARE(zynq_clkc, \"xlnx,ps7-clkc\", zynq_clk_setup);\n\nvoid __init zynq_clock_init(void)\n{\n\tstruct device_node *np;\n\tstruct device_node *slcr;\n\tstruct resource res;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"xlnx,ps7-clkc\");\n\tif (!np) {\n\t\tpr_err(\"%s: clkc node not found\\n\", __func__);\n\t\tgoto np_err;\n\t}\n\n\tif (of_address_to_resource(np, 0, &res)) {\n\t\tpr_err(\"%pOFn: failed to get resource\\n\", np);\n\t\tgoto np_err;\n\t}\n\n\tslcr = of_get_parent(np);\n\n\tif (slcr->data) {\n\t\tzynq_clkc_base = (__force void __iomem *)slcr->data + res.start;\n\t} else {\n\t\tpr_err(\"%pOFn: Unable to get I/O memory\\n\", np);\n\t\tof_node_put(slcr);\n\t\tgoto np_err;\n\t}\n\n\tpr_info(\"%s: clkc starts at %p\\n\", __func__, zynq_clkc_base);\n\n\tof_node_put(slcr);\n\tof_node_put(np);\n\n\treturn;\n\nnp_err:\n\tof_node_put(np);\n\tBUG();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}