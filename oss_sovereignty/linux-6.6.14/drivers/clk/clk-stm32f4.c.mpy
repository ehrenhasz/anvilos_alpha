{
  "module_name": "clk-stm32f4.c",
  "hash_id": "bc38d75b93a131bdbc477695230ed005913edd36f18ac4fce77a1f2f2a49ae38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-stm32f4.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n\n \n#include <dt-bindings/clock/stm32fx-clock.h>\n\n#define STM32F4_RCC_CR\t\t\t0x00\n#define STM32F4_RCC_PLLCFGR\t\t0x04\n#define STM32F4_RCC_CFGR\t\t0x08\n#define STM32F4_RCC_AHB1ENR\t\t0x30\n#define STM32F4_RCC_AHB2ENR\t\t0x34\n#define STM32F4_RCC_AHB3ENR\t\t0x38\n#define STM32F4_RCC_APB1ENR\t\t0x40\n#define STM32F4_RCC_APB2ENR\t\t0x44\n#define STM32F4_RCC_BDCR\t\t0x70\n#define STM32F4_RCC_CSR\t\t\t0x74\n#define STM32F4_RCC_PLLI2SCFGR\t\t0x84\n#define STM32F4_RCC_PLLSAICFGR\t\t0x88\n#define STM32F4_RCC_DCKCFGR\t\t0x8c\n#define STM32F7_RCC_DCKCFGR2\t\t0x90\n\n#define NONE -1\n#define NO_IDX  NONE\n#define NO_MUX  NONE\n#define NO_GATE NONE\n\nstruct stm32f4_gate_data {\n\tu8\toffset;\n\tu8\tbit_idx;\n\tconst char *name;\n\tconst char *parent_name;\n\tunsigned long flags;\n};\n\nstatic const struct stm32f4_gate_data stm32f429_gates[] __initconst = {\n\t{ STM32F4_RCC_AHB1ENR,  0,\t\"gpioa\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  1,\t\"gpiob\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  2,\t\"gpioc\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  3,\t\"gpiod\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  4,\t\"gpioe\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  5,\t\"gpiof\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  6,\t\"gpiog\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  7,\t\"gpioh\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  8,\t\"gpioi\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  9,\t\"gpioj\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 10,\t\"gpiok\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 12,\t\"crc\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 18,\t\"bkpsra\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 20,\t\"ccmdatam\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 21,\t\"dma1\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 22,\t\"dma2\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 23,\t\"dma2d\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 25,\t\"ethmac\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 26,\t\"ethmactx\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 27,\t\"ethmacrx\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 28,\t\"ethmacptp\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 29,\t\"otghs\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 30,\t\"otghsulpi\",\t\"ahb_div\" },\n\n\t{ STM32F4_RCC_AHB2ENR,  0,\t\"dcmi\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB2ENR,  4,\t\"cryp\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB2ENR,  5,\t\"hash\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB2ENR,  6,\t\"rng\",\t\t\"pll48\" },\n\t{ STM32F4_RCC_AHB2ENR,  7,\t\"otgfs\",\t\"pll48\" },\n\n\t{ STM32F4_RCC_AHB3ENR,  0,\t\"fmc\",\t\t\"ahb_div\",\n\t\tCLK_IGNORE_UNUSED },\n\n\t{ STM32F4_RCC_APB1ENR,  0,\t\"tim2\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  1,\t\"tim3\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  2,\t\"tim4\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  3,\t\"tim5\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  4,\t\"tim6\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  5,\t\"tim7\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  6,\t\"tim12\",\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  7,\t\"tim13\",\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  8,\t\"tim14\",\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR, 11,\t\"wwdg\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 14,\t\"spi2\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 15,\t\"spi3\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 17,\t\"uart2\",\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 18,\t\"uart3\",\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 19,\t\"uart4\",\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 20,\t\"uart5\",\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 21,\t\"i2c1\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 22,\t\"i2c2\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 23,\t\"i2c3\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 25,\t\"can1\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 26,\t\"can2\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 28,\t\"pwr\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 29,\t\"dac\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 30,\t\"uart7\",\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 31,\t\"uart8\",\t\"apb1_div\" },\n\n\t{ STM32F4_RCC_APB2ENR,  0,\t\"tim1\",\t\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR,  1,\t\"tim8\",\t\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR,  4,\t\"usart1\",\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR,  5,\t\"usart6\",\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR,  8,\t\"adc1\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR,  9,\t\"adc2\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 10,\t\"adc3\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 11,\t\"sdio\",\t\t\"pll48\" },\n\t{ STM32F4_RCC_APB2ENR, 12,\t\"spi1\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 13,\t\"spi4\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 14,\t\"syscfg\",\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 16,\t\"tim9\",\t\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR, 17,\t\"tim10\",\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR, 18,\t\"tim11\",\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR, 20,\t\"spi5\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 21,\t\"spi6\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 22,\t\"sai1\",\t\t\"apb2_div\" },\n};\n\nstatic const struct stm32f4_gate_data stm32f469_gates[] __initconst = {\n\t{ STM32F4_RCC_AHB1ENR,  0,\t\"gpioa\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  1,\t\"gpiob\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  2,\t\"gpioc\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  3,\t\"gpiod\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  4,\t\"gpioe\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  5,\t\"gpiof\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  6,\t\"gpiog\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  7,\t\"gpioh\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  8,\t\"gpioi\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  9,\t\"gpioj\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 10,\t\"gpiok\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 12,\t\"crc\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 18,\t\"bkpsra\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 20,\t\"ccmdatam\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 21,\t\"dma1\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 22,\t\"dma2\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 23,\t\"dma2d\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 25,\t\"ethmac\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 26,\t\"ethmactx\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 27,\t\"ethmacrx\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 28,\t\"ethmacptp\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 29,\t\"otghs\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 30,\t\"otghsulpi\",\t\"ahb_div\" },\n\n\t{ STM32F4_RCC_AHB2ENR,  0,\t\"dcmi\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB2ENR,  4,\t\"cryp\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB2ENR,  5,\t\"hash\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB2ENR,  6,\t\"rng\",\t\t\"pll48\" },\n\t{ STM32F4_RCC_AHB2ENR,  7,\t\"otgfs\",\t\"pll48\" },\n\n\t{ STM32F4_RCC_AHB3ENR,  0,\t\"fmc\",\t\t\"ahb_div\",\n\t\tCLK_IGNORE_UNUSED },\n\t{ STM32F4_RCC_AHB3ENR,  1,\t\"qspi\",\t\t\"ahb_div\",\n\t\tCLK_IGNORE_UNUSED },\n\n\t{ STM32F4_RCC_APB1ENR,  0,\t\"tim2\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  1,\t\"tim3\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  2,\t\"tim4\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  3,\t\"tim5\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  4,\t\"tim6\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  5,\t\"tim7\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  6,\t\"tim12\",\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  7,\t\"tim13\",\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  8,\t\"tim14\",\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR, 11,\t\"wwdg\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 14,\t\"spi2\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 15,\t\"spi3\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 17,\t\"uart2\",\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 18,\t\"uart3\",\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 19,\t\"uart4\",\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 20,\t\"uart5\",\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 21,\t\"i2c1\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 22,\t\"i2c2\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 23,\t\"i2c3\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 25,\t\"can1\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 26,\t\"can2\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 28,\t\"pwr\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 29,\t\"dac\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 30,\t\"uart7\",\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 31,\t\"uart8\",\t\"apb1_div\" },\n\n\t{ STM32F4_RCC_APB2ENR,  0,\t\"tim1\",\t\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR,  1,\t\"tim8\",\t\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR,  4,\t\"usart1\",\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR,  5,\t\"usart6\",\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR,  8,\t\"adc1\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR,  9,\t\"adc2\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 10,\t\"adc3\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 11,\t\"sdio\",\t\t\"sdmux\" },\n\t{ STM32F4_RCC_APB2ENR, 12,\t\"spi1\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 13,\t\"spi4\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 14,\t\"syscfg\",\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 16,\t\"tim9\",\t\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR, 17,\t\"tim10\",\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR, 18,\t\"tim11\",\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR, 20,\t\"spi5\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 21,\t\"spi6\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 22,\t\"sai1\",\t\t\"apb2_div\" },\n};\n\nstatic const struct stm32f4_gate_data stm32f746_gates[] __initconst = {\n\t{ STM32F4_RCC_AHB1ENR,  0,\t\"gpioa\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  1,\t\"gpiob\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  2,\t\"gpioc\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  3,\t\"gpiod\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  4,\t\"gpioe\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  5,\t\"gpiof\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  6,\t\"gpiog\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  7,\t\"gpioh\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  8,\t\"gpioi\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  9,\t\"gpioj\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 10,\t\"gpiok\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 12,\t\"crc\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 18,\t\"bkpsra\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 20,\t\"dtcmram\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 21,\t\"dma1\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 22,\t\"dma2\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 23,\t\"dma2d\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 25,\t\"ethmac\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 26,\t\"ethmactx\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 27,\t\"ethmacrx\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 28,\t\"ethmacptp\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 29,\t\"otghs\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 30,\t\"otghsulpi\",\t\"ahb_div\" },\n\n\t{ STM32F4_RCC_AHB2ENR,  0,\t\"dcmi\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB2ENR,  4,\t\"cryp\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB2ENR,  5,\t\"hash\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB2ENR,  6,\t\"rng\",\t\t\"pll48\"   },\n\t{ STM32F4_RCC_AHB2ENR,  7,\t\"otgfs\",\t\"pll48\"   },\n\n\t{ STM32F4_RCC_AHB3ENR,  0,\t\"fmc\",\t\t\"ahb_div\",\n\t\tCLK_IGNORE_UNUSED },\n\t{ STM32F4_RCC_AHB3ENR,  1,\t\"qspi\",\t\t\"ahb_div\",\n\t\tCLK_IGNORE_UNUSED },\n\n\t{ STM32F4_RCC_APB1ENR,  0,\t\"tim2\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  1,\t\"tim3\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  2,\t\"tim4\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  3,\t\"tim5\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  4,\t\"tim6\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  5,\t\"tim7\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  6,\t\"tim12\",\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  7,\t\"tim13\",\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  8,\t\"tim14\",\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR, 11,\t\"wwdg\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 14,\t\"spi2\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 15,\t\"spi3\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 16,\t\"spdifrx\",\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 25,\t\"can1\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 26,\t\"can2\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 27,\t\"cec\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 28,\t\"pwr\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 29,\t\"dac\",\t\t\"apb1_div\" },\n\n\t{ STM32F4_RCC_APB2ENR,  0,\t\"tim1\",\t\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR,  1,\t\"tim8\",\t\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR,  7,\t\"sdmmc2\",\t\"sdmux\"    },\n\t{ STM32F4_RCC_APB2ENR,  8,\t\"adc1\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR,  9,\t\"adc2\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 10,\t\"adc3\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 11,\t\"sdmmc\",\t\"sdmux\"    },\n\t{ STM32F4_RCC_APB2ENR, 12,\t\"spi1\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 13,\t\"spi4\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 14,\t\"syscfg\",\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 16,\t\"tim9\",\t\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR, 17,\t\"tim10\",\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR, 18,\t\"tim11\",\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR, 20,\t\"spi5\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 21,\t\"spi6\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 22,\t\"sai1\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 23,\t\"sai2\",\t\t\"apb2_div\" },\n};\n\nstatic const struct stm32f4_gate_data stm32f769_gates[] __initconst = {\n\t{ STM32F4_RCC_AHB1ENR,  0,\t\"gpioa\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  1,\t\"gpiob\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  2,\t\"gpioc\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  3,\t\"gpiod\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  4,\t\"gpioe\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  5,\t\"gpiof\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  6,\t\"gpiog\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  7,\t\"gpioh\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  8,\t\"gpioi\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR,  9,\t\"gpioj\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 10,\t\"gpiok\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 12,\t\"crc\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 18,\t\"bkpsra\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 20,\t\"dtcmram\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 21,\t\"dma1\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 22,\t\"dma2\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 23,\t\"dma2d\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 25,\t\"ethmac\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 26,\t\"ethmactx\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 27,\t\"ethmacrx\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 28,\t\"ethmacptp\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 29,\t\"otghs\",\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB1ENR, 30,\t\"otghsulpi\",\t\"ahb_div\" },\n\n\t{ STM32F4_RCC_AHB2ENR,  0,\t\"dcmi\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB2ENR,  1,\t\"jpeg\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB2ENR,  4,\t\"cryp\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB2ENR,  5,\t\"hash\",\t\t\"ahb_div\" },\n\t{ STM32F4_RCC_AHB2ENR,  6,\t\"rng\",\t\t\"pll48\"   },\n\t{ STM32F4_RCC_AHB2ENR,  7,\t\"otgfs\",\t\"pll48\"   },\n\n\t{ STM32F4_RCC_AHB3ENR,  0,\t\"fmc\",\t\t\"ahb_div\",\n\t\tCLK_IGNORE_UNUSED },\n\t{ STM32F4_RCC_AHB3ENR,  1,\t\"qspi\",\t\t\"ahb_div\",\n\t\tCLK_IGNORE_UNUSED },\n\n\t{ STM32F4_RCC_APB1ENR,  0,\t\"tim2\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  1,\t\"tim3\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  2,\t\"tim4\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  3,\t\"tim5\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  4,\t\"tim6\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  5,\t\"tim7\",\t\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  6,\t\"tim12\",\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  7,\t\"tim13\",\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR,  8,\t\"tim14\",\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR, 10,\t\"rtcapb\",\t\"apb1_mul\" },\n\t{ STM32F4_RCC_APB1ENR, 11,\t\"wwdg\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 13,\t\"can3\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 14,\t\"spi2\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 15,\t\"spi3\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 16,\t\"spdifrx\",\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 25,\t\"can1\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 26,\t\"can2\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 27,\t\"cec\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 28,\t\"pwr\",\t\t\"apb1_div\" },\n\t{ STM32F4_RCC_APB1ENR, 29,\t\"dac\",\t\t\"apb1_div\" },\n\n\t{ STM32F4_RCC_APB2ENR,  0,\t\"tim1\",\t\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR,  1,\t\"tim8\",\t\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR,  7,\t\"sdmmc2\",\t\"sdmux2\" },\n\t{ STM32F4_RCC_APB2ENR,  8,\t\"adc1\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR,  9,\t\"adc2\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 10,\t\"adc3\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 11,\t\"sdmmc1\",\t\"sdmux1\" },\n\t{ STM32F4_RCC_APB2ENR, 12,\t\"spi1\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 13,\t\"spi4\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 14,\t\"syscfg\",\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 16,\t\"tim9\",\t\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR, 17,\t\"tim10\",\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR, 18,\t\"tim11\",\t\"apb2_mul\" },\n\t{ STM32F4_RCC_APB2ENR, 20,\t\"spi5\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 21,\t\"spi6\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 22,\t\"sai1\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 23,\t\"sai2\",\t\t\"apb2_div\" },\n\t{ STM32F4_RCC_APB2ENR, 30,\t\"mdio\",\t\t\"apb2_div\" },\n};\n\n \n#define MAX_GATE_MAP 3\n\nstatic const u64 stm32f42xx_gate_map[MAX_GATE_MAP] = { 0x000000f17ef417ffull,\n\t\t\t\t\t\t       0x0000000000000001ull,\n\t\t\t\t\t\t       0x04777f33f6fec9ffull };\n\nstatic const u64 stm32f46xx_gate_map[MAX_GATE_MAP] = { 0x000000f17ef417ffull,\n\t\t\t\t\t\t       0x0000000000000003ull,\n\t\t\t\t\t\t       0x0c777f33f6fec9ffull };\n\nstatic const u64 stm32f746_gate_map[MAX_GATE_MAP] = { 0x000000f17ef417ffull,\n\t\t\t\t\t\t      0x0000000000000003ull,\n\t\t\t\t\t\t      0x04f77f833e01c9ffull };\n\nstatic const u64 stm32f769_gate_map[MAX_GATE_MAP] = { 0x000000f37ef417ffull,\n\t\t\t\t\t\t      0x0000000000000003ull,\n\t\t\t\t\t\t      0x44F77F833E01EDFFull };\n\nstatic const u64 *stm32f4_gate_map;\n\nstatic struct clk_hw **clks;\n\nstatic DEFINE_SPINLOCK(stm32f4_clk_lock);\nstatic void __iomem *base;\n\nstatic struct regmap *pdrm;\n\nstatic int stm32fx_end_primary_clk;\n\n \nstruct clk_apb_mul {\n\tstruct clk_hw hw;\n\tu8 bit_idx;\n};\n\n#define to_clk_apb_mul(_hw) container_of(_hw, struct clk_apb_mul, hw)\n\nstatic unsigned long clk_apb_mul_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct clk_apb_mul *am = to_clk_apb_mul(hw);\n\n\tif (readl(base + STM32F4_RCC_CFGR) & BIT(am->bit_idx))\n\t\treturn parent_rate * 2;\n\n\treturn parent_rate;\n}\n\nstatic long clk_apb_mul_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long *prate)\n{\n\tstruct clk_apb_mul *am = to_clk_apb_mul(hw);\n\tunsigned long mult = 1;\n\n\tif (readl(base + STM32F4_RCC_CFGR) & BIT(am->bit_idx))\n\t\tmult = 2;\n\n\tif (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) {\n\t\tunsigned long best_parent = rate / mult;\n\n\t\t*prate = clk_hw_round_rate(clk_hw_get_parent(hw), best_parent);\n\t}\n\n\treturn *prate * mult;\n}\n\nstatic int clk_apb_mul_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\t \n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_apb_mul_factor_ops = {\n\t.round_rate = clk_apb_mul_round_rate,\n\t.set_rate = clk_apb_mul_set_rate,\n\t.recalc_rate = clk_apb_mul_recalc_rate,\n};\n\nstatic struct clk *clk_register_apb_mul(struct device *dev, const char *name,\n\t\t\t\t\tconst char *parent_name,\n\t\t\t\t\tunsigned long flags, u8 bit_idx)\n{\n\tstruct clk_apb_mul *am;\n\tstruct clk_init_data init;\n\tstruct clk *clk;\n\n\tam = kzalloc(sizeof(*am), GFP_KERNEL);\n\tif (!am)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tam->bit_idx = bit_idx;\n\tam->hw.init = &init;\n\n\tinit.name = name;\n\tinit.ops = &clk_apb_mul_factor_ops;\n\tinit.flags = flags;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tclk = clk_register(dev, &am->hw);\n\n\tif (IS_ERR(clk))\n\t\tkfree(am);\n\n\treturn clk;\n}\n\nenum {\n\tPLL,\n\tPLL_I2S,\n\tPLL_SAI,\n};\n\nstatic const struct clk_div_table pll_divp_table[] = {\n\t{ 0, 2 }, { 1, 4 }, { 2, 6 }, { 3, 8 }, { 0 }\n};\n\nstatic const struct clk_div_table pll_divq_table[] = {\n\t{ 2, 2 }, { 3, 3 }, { 4, 4 }, { 5, 5 }, { 6, 6 }, { 7, 7 },\n\t{ 8, 8 }, { 9, 9 }, { 10, 10 }, { 11, 11 }, { 12, 12 }, { 13, 13 },\n\t{ 14, 14 }, { 15, 15 },\n\t{ 0 }\n};\n\nstatic const struct clk_div_table pll_divr_table[] = {\n\t{ 2, 2 }, { 3, 3 }, { 4, 4 }, { 5, 5 }, { 6, 6 }, { 7, 7 }, { 0 }\n};\n\nstruct stm32f4_pll {\n\tspinlock_t *lock;\n\tstruct\tclk_gate gate;\n\tu8 offset;\n\tu8 bit_rdy_idx;\n\tu8 status;\n\tu8 n_start;\n};\n\n#define to_stm32f4_pll(_gate) container_of(_gate, struct stm32f4_pll, gate)\n\nstruct stm32f4_pll_post_div_data {\n\tint idx;\n\tint pll_idx;\n\tconst char *name;\n\tconst char *parent;\n\tu8 flag;\n\tu8 offset;\n\tu8 shift;\n\tu8 width;\n\tu8 flag_div;\n\tconst struct clk_div_table *div_table;\n};\n\nstruct stm32f4_vco_data {\n\tconst char *vco_name;\n\tu8 offset;\n\tu8 bit_idx;\n\tu8 bit_rdy_idx;\n};\n\nstatic const struct stm32f4_vco_data  vco_data[] = {\n\t{ \"vco\",     STM32F4_RCC_PLLCFGR,    24, 25 },\n\t{ \"vco-i2s\", STM32F4_RCC_PLLI2SCFGR, 26, 27 },\n\t{ \"vco-sai\", STM32F4_RCC_PLLSAICFGR, 28, 29 },\n};\n\n\nstatic const struct clk_div_table post_divr_table[] = {\n\t{ 0, 2 }, { 1, 4 }, { 2, 8 }, { 3, 16 }, { 0 }\n};\n\n#define MAX_POST_DIV 3\nstatic const struct stm32f4_pll_post_div_data  post_div_data[MAX_POST_DIV] = {\n\t{ CLK_I2SQ_PDIV, PLL_VCO_I2S, \"plli2s-q-div\", \"plli2s-q\",\n\t\tCLK_SET_RATE_PARENT, STM32F4_RCC_DCKCFGR, 0, 5, 0, NULL},\n\n\t{ CLK_SAIQ_PDIV, PLL_VCO_SAI, \"pllsai-q-div\", \"pllsai-q\",\n\t\tCLK_SET_RATE_PARENT, STM32F4_RCC_DCKCFGR, 8, 5, 0, NULL },\n\n\t{ NO_IDX, PLL_VCO_SAI, \"pllsai-r-div\", \"pllsai-r\", CLK_SET_RATE_PARENT,\n\t\tSTM32F4_RCC_DCKCFGR, 16, 2, 0, post_divr_table },\n};\n\nstruct stm32f4_div_data {\n\tu8 shift;\n\tu8 width;\n\tu8 flag_div;\n\tconst struct clk_div_table *div_table;\n};\n\n#define MAX_PLL_DIV 3\nstatic const struct stm32f4_div_data  div_data[MAX_PLL_DIV] = {\n\t{ 16, 2, 0, pll_divp_table },\n\t{ 24, 4, 0, pll_divq_table },\n\t{ 28, 3, 0, pll_divr_table },\n};\n\nstruct stm32f4_pll_data {\n\tu8 pll_num;\n\tu8 n_start;\n\tconst char *div_name[MAX_PLL_DIV];\n};\n\nstatic const struct stm32f4_pll_data stm32f429_pll[MAX_PLL_DIV] = {\n\t{ PLL,\t   192, { \"pll\", \"pll48\",    NULL\t} },\n\t{ PLL_I2S, 192, { NULL,  \"plli2s-q\", \"plli2s-r\" } },\n\t{ PLL_SAI,  49, { NULL,  \"pllsai-q\", \"pllsai-r\" } },\n};\n\nstatic const struct stm32f4_pll_data stm32f469_pll[MAX_PLL_DIV] = {\n\t{ PLL,\t   50, { \"pll\",\t     \"pll-q\",    \"pll-r\"    } },\n\t{ PLL_I2S, 50, { \"plli2s-p\", \"plli2s-q\", \"plli2s-r\" } },\n\t{ PLL_SAI, 50, { \"pllsai-p\", \"pllsai-q\", \"pllsai-r\" } },\n};\n\nstatic int stm32f4_pll_is_enabled(struct clk_hw *hw)\n{\n\treturn clk_gate_ops.is_enabled(hw);\n}\n\n#define PLL_TIMEOUT 10000\n\nstatic int stm32f4_pll_enable(struct clk_hw *hw)\n{\n\tstruct clk_gate *gate = to_clk_gate(hw);\n\tstruct stm32f4_pll *pll = to_stm32f4_pll(gate);\n\tint bit_status;\n\tunsigned int timeout = PLL_TIMEOUT;\n\n\tif (clk_gate_ops.is_enabled(hw))\n\t\treturn 0;\n\n\tclk_gate_ops.enable(hw);\n\n\tdo {\n\t\tbit_status = !(readl(gate->reg) & BIT(pll->bit_rdy_idx));\n\n\t} while (bit_status && --timeout);\n\n\treturn bit_status;\n}\n\nstatic void stm32f4_pll_disable(struct clk_hw *hw)\n{\n\tclk_gate_ops.disable(hw);\n}\n\nstatic unsigned long stm32f4_pll_recalc(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_gate *gate = to_clk_gate(hw);\n\tstruct stm32f4_pll *pll = to_stm32f4_pll(gate);\n\tunsigned long n;\n\n\tn = (readl(base + pll->offset) >> 6) & 0x1ff;\n\n\treturn parent_rate * n;\n}\n\nstatic long stm32f4_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long *prate)\n{\n\tstruct clk_gate *gate = to_clk_gate(hw);\n\tstruct stm32f4_pll *pll = to_stm32f4_pll(gate);\n\tunsigned long n;\n\n\tn = rate / *prate;\n\n\tif (n < pll->n_start)\n\t\tn = pll->n_start;\n\telse if (n > 432)\n\t\tn = 432;\n\n\treturn *prate * n;\n}\n\nstatic int stm32f4_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_gate *gate = to_clk_gate(hw);\n\tstruct stm32f4_pll *pll = to_stm32f4_pll(gate);\n\n\tunsigned long n;\n\tunsigned long val;\n\tint pll_state;\n\n\tpll_state = stm32f4_pll_is_enabled(hw);\n\n\tif (pll_state)\n\t\tstm32f4_pll_disable(hw);\n\n\tn = rate  / parent_rate;\n\n\tval = readl(base + pll->offset) & ~(0x1ff << 6);\n\n\twritel(val | ((n & 0x1ff) <<  6), base + pll->offset);\n\n\tif (pll_state)\n\t\tstm32f4_pll_enable(hw);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops stm32f4_pll_gate_ops = {\n\t.enable\t\t= stm32f4_pll_enable,\n\t.disable\t= stm32f4_pll_disable,\n\t.is_enabled\t= stm32f4_pll_is_enabled,\n\t.recalc_rate\t= stm32f4_pll_recalc,\n\t.round_rate\t= stm32f4_pll_round_rate,\n\t.set_rate\t= stm32f4_pll_set_rate,\n};\n\nstruct stm32f4_pll_div {\n\tstruct clk_divider div;\n\tstruct clk_hw *hw_pll;\n};\n\n#define to_pll_div_clk(_div) container_of(_div, struct stm32f4_pll_div, div)\n\nstatic unsigned long stm32f4_pll_div_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\treturn clk_divider_ops.recalc_rate(hw, parent_rate);\n}\n\nstatic int stm32f4_pll_div_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t  struct clk_rate_request *req)\n{\n\treturn clk_divider_ops.determine_rate(hw, req);\n}\n\nstatic int stm32f4_pll_div_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tint pll_state, ret;\n\n\tstruct clk_divider *div = to_clk_divider(hw);\n\tstruct stm32f4_pll_div *pll_div = to_pll_div_clk(div);\n\n\tpll_state = stm32f4_pll_is_enabled(pll_div->hw_pll);\n\n\tif (pll_state)\n\t\tstm32f4_pll_disable(pll_div->hw_pll);\n\n\tret = clk_divider_ops.set_rate(hw, rate, parent_rate);\n\n\tif (pll_state)\n\t\tstm32f4_pll_enable(pll_div->hw_pll);\n\n\treturn ret;\n}\n\nstatic const struct clk_ops stm32f4_pll_div_ops = {\n\t.recalc_rate = stm32f4_pll_div_recalc_rate,\n\t.determine_rate = stm32f4_pll_div_determine_rate,\n\t.set_rate = stm32f4_pll_div_set_rate,\n};\n\nstatic struct clk_hw *clk_register_pll_div(const char *name,\n\t\tconst char *parent_name, unsigned long flags,\n\t\tvoid __iomem *reg, u8 shift, u8 width,\n\t\tu8 clk_divider_flags, const struct clk_div_table *table,\n\t\tstruct clk_hw *pll_hw, spinlock_t *lock)\n{\n\tstruct stm32f4_pll_div *pll_div;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\t \n\tpll_div = kzalloc(sizeof(*pll_div), GFP_KERNEL);\n\tif (!pll_div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &stm32f4_pll_div_ops;\n\tinit.flags = flags;\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\n\t \n\tpll_div->div.reg = reg;\n\tpll_div->div.shift = shift;\n\tpll_div->div.width = width;\n\tpll_div->div.flags = clk_divider_flags;\n\tpll_div->div.lock = lock;\n\tpll_div->div.table = table;\n\tpll_div->div.hw.init = &init;\n\n\tpll_div->hw_pll = pll_hw;\n\n\t \n\thw = &pll_div->div.hw;\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(pll_div);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstatic struct clk_hw *stm32f4_rcc_register_pll(const char *pllsrc,\n\t\tconst struct stm32f4_pll_data *data,  spinlock_t *lock)\n{\n\tstruct stm32f4_pll *pll;\n\tstruct clk_init_data init = { NULL };\n\tvoid __iomem *reg;\n\tstruct clk_hw *pll_hw;\n\tint ret;\n\tint i;\n\tconst struct stm32f4_vco_data *vco;\n\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvco = &vco_data[data->pll_num];\n\n\tinit.name = vco->vco_name;\n\tinit.ops = &stm32f4_pll_gate_ops;\n\tinit.flags = CLK_SET_RATE_GATE;\n\tinit.parent_names = &pllsrc;\n\tinit.num_parents = 1;\n\n\tpll->gate.lock = lock;\n\tpll->gate.reg = base + STM32F4_RCC_CR;\n\tpll->gate.bit_idx = vco->bit_idx;\n\tpll->gate.hw.init = &init;\n\n\tpll->offset = vco->offset;\n\tpll->n_start = data->n_start;\n\tpll->bit_rdy_idx = vco->bit_rdy_idx;\n\tpll->status = (readl(base + STM32F4_RCC_CR) >> vco->bit_idx) & 0x1;\n\n\treg = base + pll->offset;\n\n\tpll_hw = &pll->gate.hw;\n\tret = clk_hw_register(NULL, pll_hw);\n\tif (ret) {\n\t\tkfree(pll);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tfor (i = 0; i < MAX_PLL_DIV; i++)\n\t\tif (data->div_name[i])\n\t\t\tclk_register_pll_div(data->div_name[i],\n\t\t\t\t\tvco->vco_name,\n\t\t\t\t\t0,\n\t\t\t\t\treg,\n\t\t\t\t\tdiv_data[i].shift,\n\t\t\t\t\tdiv_data[i].width,\n\t\t\t\t\tdiv_data[i].flag_div,\n\t\t\t\t\tdiv_data[i].div_table,\n\t\t\t\t\tpll_hw,\n\t\t\t\t\tlock);\n\treturn pll_hw;\n}\n\n \nstatic int stm32f4_rcc_lookup_clk_idx(u8 primary, u8 secondary)\n{\n\tu64 table[MAX_GATE_MAP];\n\n\tif (primary == 1) {\n\t\tif (WARN_ON(secondary >= stm32fx_end_primary_clk))\n\t\t\treturn -EINVAL;\n\t\treturn secondary;\n\t}\n\n\tmemcpy(table, stm32f4_gate_map, sizeof(table));\n\n\t \n\tif (WARN_ON(secondary >= BITS_PER_BYTE * sizeof(table) ||\n\t\t    0 == (table[BIT_ULL_WORD(secondary)] &\n\t\t\t  BIT_ULL_MASK(secondary))))\n\t\treturn -EINVAL;\n\n\t \n\ttable[BIT_ULL_WORD(secondary)] &=\n\t    GENMASK_ULL(secondary % BITS_PER_LONG_LONG, 0);\n\n\treturn stm32fx_end_primary_clk - 1 + hweight64(table[0]) +\n\t       (BIT_ULL_WORD(secondary) >= 1 ? hweight64(table[1]) : 0) +\n\t       (BIT_ULL_WORD(secondary) >= 2 ? hweight64(table[2]) : 0);\n}\n\nstatic struct clk_hw *\nstm32f4_rcc_lookup_clk(struct of_phandle_args *clkspec, void *data)\n{\n\tint i = stm32f4_rcc_lookup_clk_idx(clkspec->args[0], clkspec->args[1]);\n\n\tif (i < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn clks[i];\n}\n\n#define to_rgclk(_rgate) container_of(_rgate, struct stm32_rgate, gate)\n\nstatic inline void disable_power_domain_write_protection(void)\n{\n\tif (pdrm)\n\t\tregmap_update_bits(pdrm, 0x00, (1 << 8), (1 << 8));\n}\n\nstatic inline void enable_power_domain_write_protection(void)\n{\n\tif (pdrm)\n\t\tregmap_update_bits(pdrm, 0x00, (1 << 8), (0 << 8));\n}\n\nstatic inline void sofware_reset_backup_domain(void)\n{\n\tunsigned long val;\n\n\tval = readl(base + STM32F4_RCC_BDCR);\n\twritel(val | BIT(16), base + STM32F4_RCC_BDCR);\n\twritel(val & ~BIT(16), base + STM32F4_RCC_BDCR);\n}\n\nstruct stm32_rgate {\n\tstruct\tclk_gate gate;\n\tu8\tbit_rdy_idx;\n};\n\n#define RGATE_TIMEOUT 50000\n\nstatic int rgclk_enable(struct clk_hw *hw)\n{\n\tstruct clk_gate *gate = to_clk_gate(hw);\n\tstruct stm32_rgate *rgate = to_rgclk(gate);\n\tint bit_status;\n\tunsigned int timeout = RGATE_TIMEOUT;\n\n\tif (clk_gate_ops.is_enabled(hw))\n\t\treturn 0;\n\n\tdisable_power_domain_write_protection();\n\n\tclk_gate_ops.enable(hw);\n\n\tdo {\n\t\tbit_status = !(readl(gate->reg) & BIT(rgate->bit_rdy_idx));\n\t\tif (bit_status)\n\t\t\tudelay(100);\n\n\t} while (bit_status && --timeout);\n\n\tenable_power_domain_write_protection();\n\n\treturn bit_status;\n}\n\nstatic void rgclk_disable(struct clk_hw *hw)\n{\n\tclk_gate_ops.disable(hw);\n}\n\nstatic int rgclk_is_enabled(struct clk_hw *hw)\n{\n\treturn clk_gate_ops.is_enabled(hw);\n}\n\nstatic const struct clk_ops rgclk_ops = {\n\t.enable = rgclk_enable,\n\t.disable = rgclk_disable,\n\t.is_enabled = rgclk_is_enabled,\n};\n\nstatic struct clk_hw *clk_register_rgate(struct device *dev, const char *name,\n\t\tconst char *parent_name, unsigned long flags,\n\t\tvoid __iomem *reg, u8 bit_idx, u8 bit_rdy_idx,\n\t\tu8 clk_gate_flags, spinlock_t *lock)\n{\n\tstruct stm32_rgate *rgate;\n\tstruct clk_init_data init = { NULL };\n\tstruct clk_hw *hw;\n\tint ret;\n\n\trgate = kzalloc(sizeof(*rgate), GFP_KERNEL);\n\tif (!rgate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &rgclk_ops;\n\tinit.flags = flags;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\trgate->bit_rdy_idx = bit_rdy_idx;\n\n\trgate->gate.lock = lock;\n\trgate->gate.reg = reg;\n\trgate->gate.bit_idx = bit_idx;\n\trgate->gate.hw.init = &init;\n\n\thw = &rgate->gate.hw;\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\tkfree(rgate);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstatic int cclk_gate_enable(struct clk_hw *hw)\n{\n\tint ret;\n\n\tdisable_power_domain_write_protection();\n\n\tret = clk_gate_ops.enable(hw);\n\n\tenable_power_domain_write_protection();\n\n\treturn ret;\n}\n\nstatic void cclk_gate_disable(struct clk_hw *hw)\n{\n\tdisable_power_domain_write_protection();\n\n\tclk_gate_ops.disable(hw);\n\n\tenable_power_domain_write_protection();\n}\n\nstatic int cclk_gate_is_enabled(struct clk_hw *hw)\n{\n\treturn clk_gate_ops.is_enabled(hw);\n}\n\nstatic const struct clk_ops cclk_gate_ops = {\n\t.enable\t\t= cclk_gate_enable,\n\t.disable\t= cclk_gate_disable,\n\t.is_enabled\t= cclk_gate_is_enabled,\n};\n\nstatic u8 cclk_mux_get_parent(struct clk_hw *hw)\n{\n\treturn clk_mux_ops.get_parent(hw);\n}\n\nstatic int cclk_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tint ret;\n\n\tdisable_power_domain_write_protection();\n\n\tsofware_reset_backup_domain();\n\n\tret = clk_mux_ops.set_parent(hw, index);\n\n\tenable_power_domain_write_protection();\n\n\treturn ret;\n}\n\nstatic const struct clk_ops cclk_mux_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.get_parent = cclk_mux_get_parent,\n\t.set_parent = cclk_mux_set_parent,\n};\n\nstatic struct clk_hw *stm32_register_cclk(struct device *dev, const char *name,\n\t\tconst char * const *parent_names, int num_parents,\n\t\tvoid __iomem *reg, u8 bit_idx, u8 shift, unsigned long flags,\n\t\tspinlock_t *lock)\n{\n\tstruct clk_hw *hw;\n\tstruct clk_gate *gate;\n\tstruct clk_mux *mux;\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate) {\n\t\thw = ERR_PTR(-EINVAL);\n\t\tgoto fail;\n\t}\n\n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux) {\n\t\tkfree(gate);\n\t\thw = ERR_PTR(-EINVAL);\n\t\tgoto fail;\n\t}\n\n\tgate->reg = reg;\n\tgate->bit_idx = bit_idx;\n\tgate->flags = 0;\n\tgate->lock = lock;\n\n\tmux->reg = reg;\n\tmux->shift = shift;\n\tmux->mask = 3;\n\tmux->flags = 0;\n\n\thw = clk_hw_register_composite(dev, name, parent_names, num_parents,\n\t\t\t&mux->hw, &cclk_mux_ops,\n\t\t\tNULL, NULL,\n\t\t\t&gate->hw, &cclk_gate_ops,\n\t\t\tflags);\n\n\tif (IS_ERR(hw)) {\n\t\tkfree(gate);\n\t\tkfree(mux);\n\t}\n\nfail:\n\treturn hw;\n}\n\nstatic const char *sys_parents[] __initdata =   { \"hsi\", NULL, \"pll\" };\n\nstatic const struct clk_div_table ahb_div_table[] = {\n\t{ 0x0,   1 }, { 0x1,   1 }, { 0x2,   1 }, { 0x3,   1 },\n\t{ 0x4,   1 }, { 0x5,   1 }, { 0x6,   1 }, { 0x7,   1 },\n\t{ 0x8,   2 }, { 0x9,   4 }, { 0xa,   8 }, { 0xb,  16 },\n\t{ 0xc,  64 }, { 0xd, 128 }, { 0xe, 256 }, { 0xf, 512 },\n\t{ 0 },\n};\n\nstatic const struct clk_div_table apb_div_table[] = {\n\t{ 0,  1 }, { 0,  1 }, { 0,  1 }, { 0,  1 },\n\t{ 4,  2 }, { 5,  4 }, { 6,  8 }, { 7, 16 },\n\t{ 0 },\n};\n\nstatic const char *rtc_parents[4] = {\n\t\"no-clock\", \"lse\", \"lsi\", \"hse-rtc\"\n};\n\nstatic const char *pll_src = \"pll-src\";\n\nstatic const char *pllsrc_parent[2] = { \"hsi\", NULL };\n\nstatic const char *dsi_parent[2] = { NULL, \"pll-r\" };\n\nstatic const char *lcd_parent[1] = { \"pllsai-r-div\" };\n\nstatic const char *i2s_parents[2] = { \"plli2s-r\", NULL };\n\nstatic const char *sai_parents[4] = { \"pllsai-q-div\", \"plli2s-q-div\", NULL,\n\t\"no-clock\" };\n\nstatic const char *pll48_parents[2] = { \"pll-q\", \"pllsai-p\" };\n\nstatic const char *sdmux_parents[2] = { \"pll48\", \"sys\" };\n\nstatic const char *hdmi_parents[2] = { \"lse\", \"hsi_div488\" };\n\nstatic const char *spdif_parent[1] = { \"plli2s-p\" };\n\nstatic const char *lptim_parent[4] = { \"apb1_mul\", \"lsi\", \"hsi\", \"lse\" };\n\nstatic const char *uart_parents1[4] = { \"apb2_div\", \"sys\", \"hsi\", \"lse\" };\nstatic const char *uart_parents2[4] = { \"apb1_div\", \"sys\", \"hsi\", \"lse\" };\n\nstatic const char *i2c_parents[4] = { \"apb1_div\", \"sys\", \"hsi\", \"no-clock\" };\n\nstatic const char * const dfsdm1_src[] = { \"apb2_div\", \"sys\" };\nstatic const char * const adsfdm1_parent[] = { \"sai1_clk\", \"sai2_clk\" };\n\nstruct stm32_aux_clk {\n\tint idx;\n\tconst char *name;\n\tconst char * const *parent_names;\n\tint num_parents;\n\tint offset_mux;\n\tu8 shift;\n\tu8 mask;\n\tint offset_gate;\n\tu8 bit_idx;\n\tunsigned long flags;\n};\n\nstruct stm32f4_clk_data {\n\tconst struct stm32f4_gate_data *gates_data;\n\tconst u64 *gates_map;\n\tint gates_num;\n\tconst struct stm32f4_pll_data *pll_data;\n\tconst struct stm32_aux_clk *aux_clk;\n\tint aux_clk_num;\n\tint end_primary;\n};\n\nstatic const struct stm32_aux_clk stm32f429_aux_clk[] = {\n\t{\n\t\tCLK_LCD, \"lcd-tft\", lcd_parent, ARRAY_SIZE(lcd_parent),\n\t\tNO_MUX, 0, 0,\n\t\tSTM32F4_RCC_APB2ENR, 26,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_I2S, \"i2s\", i2s_parents, ARRAY_SIZE(i2s_parents),\n\t\tSTM32F4_RCC_CFGR, 23, 1,\n\t\tNO_GATE, 0,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_SAI1, \"sai1-a\", sai_parents, ARRAY_SIZE(sai_parents),\n\t\tSTM32F4_RCC_DCKCFGR, 20, 3,\n\t\tSTM32F4_RCC_APB2ENR, 22,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_SAI2, \"sai1-b\", sai_parents, ARRAY_SIZE(sai_parents),\n\t\tSTM32F4_RCC_DCKCFGR, 22, 3,\n\t\tSTM32F4_RCC_APB2ENR, 22,\n\t\tCLK_SET_RATE_PARENT\n\t},\n};\n\nstatic const struct stm32_aux_clk stm32f469_aux_clk[] = {\n\t{\n\t\tCLK_LCD, \"lcd-tft\", lcd_parent, ARRAY_SIZE(lcd_parent),\n\t\tNO_MUX, 0, 0,\n\t\tSTM32F4_RCC_APB2ENR, 26,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_I2S, \"i2s\", i2s_parents, ARRAY_SIZE(i2s_parents),\n\t\tSTM32F4_RCC_CFGR, 23, 1,\n\t\tNO_GATE, 0,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_SAI1, \"sai1-a\", sai_parents, ARRAY_SIZE(sai_parents),\n\t\tSTM32F4_RCC_DCKCFGR, 20, 3,\n\t\tSTM32F4_RCC_APB2ENR, 22,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_SAI2, \"sai1-b\", sai_parents, ARRAY_SIZE(sai_parents),\n\t\tSTM32F4_RCC_DCKCFGR, 22, 3,\n\t\tSTM32F4_RCC_APB2ENR, 22,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tNO_IDX, \"pll48\", pll48_parents, ARRAY_SIZE(pll48_parents),\n\t\tSTM32F4_RCC_DCKCFGR, 27, 1,\n\t\tNO_GATE, 0,\n\t\t0\n\t},\n\t{\n\t\tNO_IDX, \"sdmux\", sdmux_parents, ARRAY_SIZE(sdmux_parents),\n\t\tSTM32F4_RCC_DCKCFGR, 28, 1,\n\t\tNO_GATE, 0,\n\t\t0\n\t},\n\t{\n\t\tCLK_F469_DSI, \"dsi\", dsi_parent, ARRAY_SIZE(dsi_parent),\n\t\tSTM32F4_RCC_DCKCFGR, 29, 1,\n\t\tSTM32F4_RCC_APB2ENR, 27,\n\t\tCLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT\n\t},\n};\n\nstatic const struct stm32_aux_clk stm32f746_aux_clk[] = {\n\t{\n\t\tCLK_LCD, \"lcd-tft\", lcd_parent, ARRAY_SIZE(lcd_parent),\n\t\tNO_MUX, 0, 0,\n\t\tSTM32F4_RCC_APB2ENR, 26,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_I2S, \"i2s\", i2s_parents, ARRAY_SIZE(i2s_parents),\n\t\tSTM32F4_RCC_CFGR, 23, 1,\n\t\tNO_GATE, 0,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_SAI1, \"sai1_clk\", sai_parents, ARRAY_SIZE(sai_parents),\n\t\tSTM32F4_RCC_DCKCFGR, 20, 3,\n\t\tSTM32F4_RCC_APB2ENR, 22,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_SAI2, \"sai2_clk\", sai_parents, ARRAY_SIZE(sai_parents),\n\t\tSTM32F4_RCC_DCKCFGR, 22, 3,\n\t\tSTM32F4_RCC_APB2ENR, 23,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tNO_IDX, \"pll48\", pll48_parents, ARRAY_SIZE(pll48_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 27, 1,\n\t\tNO_GATE, 0,\n\t\t0\n\t},\n\t{\n\t\tNO_IDX, \"sdmux\", sdmux_parents, ARRAY_SIZE(sdmux_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 28, 1,\n\t\tNO_GATE, 0,\n\t\t0\n\t},\n\t{\n\t\tCLK_HDMI_CEC, \"hdmi-cec\",\n\t\thdmi_parents, ARRAY_SIZE(hdmi_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 26, 1,\n\t\tNO_GATE, 0,\n\t\t0\n\t},\n\t{\n\t\tCLK_SPDIF, \"spdif-rx\",\n\t\tspdif_parent, ARRAY_SIZE(spdif_parent),\n\t\tSTM32F7_RCC_DCKCFGR2, 22, 3,\n\t\tSTM32F4_RCC_APB2ENR, 23,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_USART1, \"usart1\",\n\t\tuart_parents1, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 0, 3,\n\t\tSTM32F4_RCC_APB2ENR, 4,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_USART2, \"usart2\",\n\t\tuart_parents2, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 2, 3,\n\t\tSTM32F4_RCC_APB1ENR, 17,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_USART3, \"usart3\",\n\t\tuart_parents2, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 4, 3,\n\t\tSTM32F4_RCC_APB1ENR, 18,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_UART4, \"uart4\",\n\t\tuart_parents2, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 6, 3,\n\t\tSTM32F4_RCC_APB1ENR, 19,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_UART5, \"uart5\",\n\t\tuart_parents2, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 8, 3,\n\t\tSTM32F4_RCC_APB1ENR, 20,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_USART6, \"usart6\",\n\t\tuart_parents1, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 10, 3,\n\t\tSTM32F4_RCC_APB2ENR, 5,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\n\t{\n\t\tCLK_UART7, \"uart7\",\n\t\tuart_parents2, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 12, 3,\n\t\tSTM32F4_RCC_APB1ENR, 30,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_UART8, \"uart8\",\n\t\tuart_parents2, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 14, 3,\n\t\tSTM32F4_RCC_APB1ENR, 31,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_I2C1, \"i2c1\",\n\t\ti2c_parents, ARRAY_SIZE(i2c_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 16, 3,\n\t\tSTM32F4_RCC_APB1ENR, 21,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_I2C2, \"i2c2\",\n\t\ti2c_parents, ARRAY_SIZE(i2c_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 18, 3,\n\t\tSTM32F4_RCC_APB1ENR, 22,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_I2C3, \"i2c3\",\n\t\ti2c_parents, ARRAY_SIZE(i2c_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 20, 3,\n\t\tSTM32F4_RCC_APB1ENR, 23,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_I2C4, \"i2c4\",\n\t\ti2c_parents, ARRAY_SIZE(i2c_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 22, 3,\n\t\tSTM32F4_RCC_APB1ENR, 24,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\n\t{\n\t\tCLK_LPTIMER, \"lptim1\",\n\t\tlptim_parent, ARRAY_SIZE(lptim_parent),\n\t\tSTM32F7_RCC_DCKCFGR2, 24, 3,\n\t\tSTM32F4_RCC_APB1ENR, 9,\n\t\tCLK_SET_RATE_PARENT\n\t},\n};\n\nstatic const struct stm32_aux_clk stm32f769_aux_clk[] = {\n\t{\n\t\tCLK_LCD, \"lcd-tft\", lcd_parent, ARRAY_SIZE(lcd_parent),\n\t\tNO_MUX, 0, 0,\n\t\tSTM32F4_RCC_APB2ENR, 26,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_I2S, \"i2s\", i2s_parents, ARRAY_SIZE(i2s_parents),\n\t\tSTM32F4_RCC_CFGR, 23, 1,\n\t\tNO_GATE, 0,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_SAI1, \"sai1_clk\", sai_parents, ARRAY_SIZE(sai_parents),\n\t\tSTM32F4_RCC_DCKCFGR, 20, 3,\n\t\tSTM32F4_RCC_APB2ENR, 22,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_SAI2, \"sai2_clk\", sai_parents, ARRAY_SIZE(sai_parents),\n\t\tSTM32F4_RCC_DCKCFGR, 22, 3,\n\t\tSTM32F4_RCC_APB2ENR, 23,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tNO_IDX, \"pll48\", pll48_parents, ARRAY_SIZE(pll48_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 27, 1,\n\t\tNO_GATE, 0,\n\t\t0\n\t},\n\t{\n\t\tNO_IDX, \"sdmux1\", sdmux_parents, ARRAY_SIZE(sdmux_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 28, 1,\n\t\tNO_GATE, 0,\n\t\t0\n\t},\n\t{\n\t\tNO_IDX, \"sdmux2\", sdmux_parents, ARRAY_SIZE(sdmux_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 29, 1,\n\t\tNO_GATE, 0,\n\t\t0\n\t},\n\t{\n\t\tCLK_HDMI_CEC, \"hdmi-cec\",\n\t\thdmi_parents, ARRAY_SIZE(hdmi_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 26, 1,\n\t\tNO_GATE, 0,\n\t\t0\n\t},\n\t{\n\t\tCLK_SPDIF, \"spdif-rx\",\n\t\tspdif_parent, ARRAY_SIZE(spdif_parent),\n\t\tSTM32F7_RCC_DCKCFGR2, 22, 3,\n\t\tSTM32F4_RCC_APB2ENR, 23,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_USART1, \"usart1\",\n\t\tuart_parents1, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 0, 3,\n\t\tSTM32F4_RCC_APB2ENR, 4,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_USART2, \"usart2\",\n\t\tuart_parents2, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 2, 3,\n\t\tSTM32F4_RCC_APB1ENR, 17,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_USART3, \"usart3\",\n\t\tuart_parents2, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 4, 3,\n\t\tSTM32F4_RCC_APB1ENR, 18,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_UART4, \"uart4\",\n\t\tuart_parents2, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 6, 3,\n\t\tSTM32F4_RCC_APB1ENR, 19,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_UART5, \"uart5\",\n\t\tuart_parents2, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 8, 3,\n\t\tSTM32F4_RCC_APB1ENR, 20,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_USART6, \"usart6\",\n\t\tuart_parents1, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 10, 3,\n\t\tSTM32F4_RCC_APB2ENR, 5,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_UART7, \"uart7\",\n\t\tuart_parents2, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 12, 3,\n\t\tSTM32F4_RCC_APB1ENR, 30,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_UART8, \"uart8\",\n\t\tuart_parents2, ARRAY_SIZE(uart_parents1),\n\t\tSTM32F7_RCC_DCKCFGR2, 14, 3,\n\t\tSTM32F4_RCC_APB1ENR, 31,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_I2C1, \"i2c1\",\n\t\ti2c_parents, ARRAY_SIZE(i2c_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 16, 3,\n\t\tSTM32F4_RCC_APB1ENR, 21,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_I2C2, \"i2c2\",\n\t\ti2c_parents, ARRAY_SIZE(i2c_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 18, 3,\n\t\tSTM32F4_RCC_APB1ENR, 22,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_I2C3, \"i2c3\",\n\t\ti2c_parents, ARRAY_SIZE(i2c_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 20, 3,\n\t\tSTM32F4_RCC_APB1ENR, 23,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_I2C4, \"i2c4\",\n\t\ti2c_parents, ARRAY_SIZE(i2c_parents),\n\t\tSTM32F7_RCC_DCKCFGR2, 22, 3,\n\t\tSTM32F4_RCC_APB1ENR, 24,\n\t\tCLK_SET_RATE_PARENT,\n\t},\n\t{\n\t\tCLK_LPTIMER, \"lptim1\",\n\t\tlptim_parent, ARRAY_SIZE(lptim_parent),\n\t\tSTM32F7_RCC_DCKCFGR2, 24, 3,\n\t\tSTM32F4_RCC_APB1ENR, 9,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_F769_DSI, \"dsi\",\n\t\tdsi_parent, ARRAY_SIZE(dsi_parent),\n\t\tSTM32F7_RCC_DCKCFGR2, 0, 1,\n\t\tSTM32F4_RCC_APB2ENR, 27,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_DFSDM1, \"dfsdm1\",\n\t\tdfsdm1_src, ARRAY_SIZE(dfsdm1_src),\n\t\tSTM32F4_RCC_DCKCFGR, 25, 1,\n\t\tSTM32F4_RCC_APB2ENR, 29,\n\t\tCLK_SET_RATE_PARENT\n\t},\n\t{\n\t\tCLK_ADFSDM1, \"adfsdm1\",\n\t\tadsfdm1_parent, ARRAY_SIZE(adsfdm1_parent),\n\t\tSTM32F4_RCC_DCKCFGR, 26, 1,\n\t\tSTM32F4_RCC_APB2ENR, 29,\n\t\tCLK_SET_RATE_PARENT\n\t},\n};\n\nstatic const struct stm32f4_clk_data stm32f429_clk_data = {\n\t.end_primary\t= END_PRIMARY_CLK,\n\t.gates_data\t= stm32f429_gates,\n\t.gates_map\t= stm32f42xx_gate_map,\n\t.gates_num\t= ARRAY_SIZE(stm32f429_gates),\n\t.pll_data\t= stm32f429_pll,\n\t.aux_clk\t= stm32f429_aux_clk,\n\t.aux_clk_num\t= ARRAY_SIZE(stm32f429_aux_clk),\n};\n\nstatic const struct stm32f4_clk_data stm32f469_clk_data = {\n\t.end_primary\t= END_PRIMARY_CLK,\n\t.gates_data\t= stm32f469_gates,\n\t.gates_map\t= stm32f46xx_gate_map,\n\t.gates_num\t= ARRAY_SIZE(stm32f469_gates),\n\t.pll_data\t= stm32f469_pll,\n\t.aux_clk\t= stm32f469_aux_clk,\n\t.aux_clk_num\t= ARRAY_SIZE(stm32f469_aux_clk),\n};\n\nstatic const struct stm32f4_clk_data stm32f746_clk_data = {\n\t.end_primary\t= END_PRIMARY_CLK_F7,\n\t.gates_data\t= stm32f746_gates,\n\t.gates_map\t= stm32f746_gate_map,\n\t.gates_num\t= ARRAY_SIZE(stm32f746_gates),\n\t.pll_data\t= stm32f469_pll,\n\t.aux_clk\t= stm32f746_aux_clk,\n\t.aux_clk_num\t= ARRAY_SIZE(stm32f746_aux_clk),\n};\n\nstatic const struct stm32f4_clk_data stm32f769_clk_data = {\n\t.end_primary\t= END_PRIMARY_CLK_F7,\n\t.gates_data\t= stm32f769_gates,\n\t.gates_map\t= stm32f769_gate_map,\n\t.gates_num\t= ARRAY_SIZE(stm32f769_gates),\n\t.pll_data\t= stm32f469_pll,\n\t.aux_clk\t= stm32f769_aux_clk,\n\t.aux_clk_num\t= ARRAY_SIZE(stm32f769_aux_clk),\n};\n\nstatic const struct of_device_id stm32f4_of_match[] = {\n\t{\n\t\t.compatible = \"st,stm32f42xx-rcc\",\n\t\t.data = &stm32f429_clk_data\n\t},\n\t{\n\t\t.compatible = \"st,stm32f469-rcc\",\n\t\t.data = &stm32f469_clk_data\n\t},\n\t{\n\t\t.compatible = \"st,stm32f746-rcc\",\n\t\t.data = &stm32f746_clk_data\n\t},\n\t{\n\t\t.compatible = \"st,stm32f769-rcc\",\n\t\t.data = &stm32f769_clk_data\n\t},\n\t{}\n};\n\nstatic struct clk_hw *stm32_register_aux_clk(const char *name,\n\t\tconst char * const *parent_names, int num_parents,\n\t\tint offset_mux, u8 shift, u8 mask,\n\t\tint offset_gate, u8 bit_idx,\n\t\tunsigned long flags, spinlock_t *lock)\n{\n\tstruct clk_hw *hw;\n\tstruct clk_gate *gate = NULL;\n\tstruct clk_mux *mux = NULL;\n\tstruct clk_hw *mux_hw = NULL, *gate_hw = NULL;\n\tconst struct clk_ops *mux_ops = NULL, *gate_ops = NULL;\n\n\tif (offset_gate != NO_GATE) {\n\t\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\t\tif (!gate) {\n\t\t\thw = ERR_PTR(-EINVAL);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tgate->reg = base + offset_gate;\n\t\tgate->bit_idx = bit_idx;\n\t\tgate->flags = 0;\n\t\tgate->lock = lock;\n\t\tgate_hw = &gate->hw;\n\t\tgate_ops = &clk_gate_ops;\n\t}\n\n\tif (offset_mux != NO_MUX) {\n\t\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\t\tif (!mux) {\n\t\t\thw = ERR_PTR(-EINVAL);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tmux->reg = base + offset_mux;\n\t\tmux->shift = shift;\n\t\tmux->mask = mask;\n\t\tmux->flags = 0;\n\t\tmux_hw = &mux->hw;\n\t\tmux_ops = &clk_mux_ops;\n\t}\n\n\tif (mux_hw == NULL && gate_hw == NULL) {\n\t\thw = ERR_PTR(-EINVAL);\n\t\tgoto fail;\n\t}\n\n\thw = clk_hw_register_composite(NULL, name, parent_names, num_parents,\n\t\t\tmux_hw, mux_ops,\n\t\t\tNULL, NULL,\n\t\t\tgate_hw, gate_ops,\n\t\t\tflags);\n\nfail:\n\tif (IS_ERR(hw)) {\n\t\tkfree(gate);\n\t\tkfree(mux);\n\t}\n\n\treturn hw;\n}\n\nstatic void __init stm32f4_rcc_init(struct device_node *np)\n{\n\tconst char *hse_clk, *i2s_in_clk;\n\tint n;\n\tconst struct of_device_id *match;\n\tconst struct stm32f4_clk_data *data;\n\tunsigned long pllm;\n\tstruct clk_hw *pll_src_hw;\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tpr_err(\"%pOFn: unable to map resource\\n\", np);\n\t\treturn;\n\t}\n\n\tpdrm = syscon_regmap_lookup_by_phandle(np, \"st,syscfg\");\n\tif (IS_ERR(pdrm)) {\n\t\tpdrm = NULL;\n\t\tpr_warn(\"%s: Unable to get syscfg\\n\", __func__);\n\t}\n\n\tmatch = of_match_node(stm32f4_of_match, np);\n\tif (WARN_ON(!match))\n\t\treturn;\n\n\tdata = match->data;\n\n\tstm32fx_end_primary_clk = data->end_primary;\n\n\tclks = kmalloc_array(data->gates_num + stm32fx_end_primary_clk,\n\t\t\tsizeof(*clks), GFP_KERNEL);\n\tif (!clks)\n\t\tgoto fail;\n\n\tstm32f4_gate_map = data->gates_map;\n\n\thse_clk = of_clk_get_parent_name(np, 0);\n\tdsi_parent[0] = hse_clk;\n\tpllsrc_parent[1] = hse_clk;\n\n\ti2s_in_clk = of_clk_get_parent_name(np, 1);\n\n\ti2s_parents[1] = i2s_in_clk;\n\tsai_parents[2] = i2s_in_clk;\n\n\tif (of_device_is_compatible(np, \"st,stm32f769-rcc\")) {\n\t\tclk_hw_register_gate(NULL, \"dfsdm1_apb\", \"apb2_div\", 0,\n\t\t\t\t     base + STM32F4_RCC_APB2ENR, 29,\n\t\t\t\t     CLK_IGNORE_UNUSED, &stm32f4_clk_lock);\n\t\tdsi_parent[0] = pll_src;\n\t\tsai_parents[3] = pll_src;\n\t}\n\n\tclks[CLK_HSI] = clk_hw_register_fixed_rate_with_accuracy(NULL, \"hsi\",\n\t\t\tNULL, 0, 16000000, 160000);\n\n\tpll_src_hw = clk_hw_register_mux(NULL, pll_src, pllsrc_parent,\n\t\t\t\t\t ARRAY_SIZE(pllsrc_parent), 0,\n\t\t\t\t\t base + STM32F4_RCC_PLLCFGR, 22, 1, 0,\n\t\t\t\t\t &stm32f4_clk_lock);\n\n\tpllm = readl(base + STM32F4_RCC_PLLCFGR) & 0x3f;\n\n\tclk_hw_register_fixed_factor(NULL, \"vco_in\", pll_src,\n\t\t\t\t     0, 1, pllm);\n\n\tstm32f4_rcc_register_pll(\"vco_in\", &data->pll_data[0],\n\t\t\t&stm32f4_clk_lock);\n\n\tclks[PLL_VCO_I2S] = stm32f4_rcc_register_pll(\"vco_in\",\n\t\t\t&data->pll_data[1], &stm32f4_clk_lock);\n\n\tclks[PLL_VCO_SAI] = stm32f4_rcc_register_pll(\"vco_in\",\n\t\t\t&data->pll_data[2], &stm32f4_clk_lock);\n\n\tfor (n = 0; n < MAX_POST_DIV; n++) {\n\t\tconst struct stm32f4_pll_post_div_data *post_div;\n\t\tstruct clk_hw *hw;\n\n\t\tpost_div = &post_div_data[n];\n\n\t\thw = clk_register_pll_div(post_div->name,\n\t\t\t\tpost_div->parent,\n\t\t\t\tpost_div->flag,\n\t\t\t\tbase + post_div->offset,\n\t\t\t\tpost_div->shift,\n\t\t\t\tpost_div->width,\n\t\t\t\tpost_div->flag_div,\n\t\t\t\tpost_div->div_table,\n\t\t\t\tclks[post_div->pll_idx],\n\t\t\t\t&stm32f4_clk_lock);\n\n\t\tif (post_div->idx != NO_IDX)\n\t\t\tclks[post_div->idx] = hw;\n\t}\n\n\tsys_parents[1] = hse_clk;\n\n\tclks[CLK_SYSCLK] = clk_hw_register_mux_table(\n\t    NULL, \"sys\", sys_parents, ARRAY_SIZE(sys_parents), 0,\n\t    base + STM32F4_RCC_CFGR, 0, 3, 0, NULL, &stm32f4_clk_lock);\n\n\tclk_register_divider_table(NULL, \"ahb_div\", \"sys\",\n\t\t\t\t   CLK_SET_RATE_PARENT, base + STM32F4_RCC_CFGR,\n\t\t\t\t   4, 4, 0, ahb_div_table, &stm32f4_clk_lock);\n\n\tclk_register_divider_table(NULL, \"apb1_div\", \"ahb_div\",\n\t\t\t\t   CLK_SET_RATE_PARENT, base + STM32F4_RCC_CFGR,\n\t\t\t\t   10, 3, 0, apb_div_table, &stm32f4_clk_lock);\n\tclk_register_apb_mul(NULL, \"apb1_mul\", \"apb1_div\",\n\t\t\t     CLK_SET_RATE_PARENT, 12);\n\n\tclk_register_divider_table(NULL, \"apb2_div\", \"ahb_div\",\n\t\t\t\t   CLK_SET_RATE_PARENT, base + STM32F4_RCC_CFGR,\n\t\t\t\t   13, 3, 0, apb_div_table, &stm32f4_clk_lock);\n\tclk_register_apb_mul(NULL, \"apb2_mul\", \"apb2_div\",\n\t\t\t     CLK_SET_RATE_PARENT, 15);\n\n\tclks[SYSTICK] = clk_hw_register_fixed_factor(NULL, \"systick\", \"ahb_div\",\n\t\t\t\t\t\t  0, 1, 8);\n\tclks[FCLK] = clk_hw_register_fixed_factor(NULL, \"fclk\", \"ahb_div\",\n\t\t\t\t\t       0, 1, 1);\n\n\tfor (n = 0; n < data->gates_num; n++) {\n\t\tconst struct stm32f4_gate_data *gd;\n\t\tunsigned int secondary;\n\t\tint idx;\n\n\t\tgd = &data->gates_data[n];\n\t\tsecondary = 8 * (gd->offset - STM32F4_RCC_AHB1ENR) +\n\t\t\tgd->bit_idx;\n\t\tidx = stm32f4_rcc_lookup_clk_idx(0, secondary);\n\n\t\tif (idx < 0)\n\t\t\tgoto fail;\n\n\t\tclks[idx] = clk_hw_register_gate(\n\t\t    NULL, gd->name, gd->parent_name, gd->flags,\n\t\t    base + gd->offset, gd->bit_idx, 0, &stm32f4_clk_lock);\n\n\t\tif (IS_ERR(clks[idx])) {\n\t\t\tpr_err(\"%pOF: Unable to register leaf clock %s\\n\",\n\t\t\t       np, gd->name);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tclks[CLK_LSI] = clk_register_rgate(NULL, \"lsi\", \"clk-lsi\", 0,\n\t\t\tbase + STM32F4_RCC_CSR, 0, 1, 0, &stm32f4_clk_lock);\n\n\tif (IS_ERR(clks[CLK_LSI])) {\n\t\tpr_err(\"Unable to register lsi clock\\n\");\n\t\tgoto fail;\n\t}\n\n\tclks[CLK_LSE] = clk_register_rgate(NULL, \"lse\", \"clk-lse\", 0,\n\t\t\tbase + STM32F4_RCC_BDCR, 0, 1, 0, &stm32f4_clk_lock);\n\n\tif (IS_ERR(clks[CLK_LSE])) {\n\t\tpr_err(\"Unable to register lse clock\\n\");\n\t\tgoto fail;\n\t}\n\n\tclks[CLK_HSE_RTC] = clk_hw_register_divider(NULL, \"hse-rtc\", \"clk-hse\",\n\t\t\t0, base + STM32F4_RCC_CFGR, 16, 5, 0,\n\t\t\t&stm32f4_clk_lock);\n\n\tif (IS_ERR(clks[CLK_HSE_RTC])) {\n\t\tpr_err(\"Unable to register hse-rtc clock\\n\");\n\t\tgoto fail;\n\t}\n\n\tclks[CLK_RTC] = stm32_register_cclk(NULL, \"rtc\", rtc_parents, 4,\n\t\t\tbase + STM32F4_RCC_BDCR, 15, 8, 0, &stm32f4_clk_lock);\n\n\tif (IS_ERR(clks[CLK_RTC])) {\n\t\tpr_err(\"Unable to register rtc clock\\n\");\n\t\tgoto fail;\n\t}\n\n\tfor (n = 0; n < data->aux_clk_num; n++) {\n\t\tconst struct stm32_aux_clk *aux_clk;\n\t\tstruct clk_hw *hw;\n\n\t\taux_clk = &data->aux_clk[n];\n\n\t\thw = stm32_register_aux_clk(aux_clk->name,\n\t\t\t\taux_clk->parent_names, aux_clk->num_parents,\n\t\t\t\taux_clk->offset_mux, aux_clk->shift,\n\t\t\t\taux_clk->mask, aux_clk->offset_gate,\n\t\t\t\taux_clk->bit_idx, aux_clk->flags,\n\t\t\t\t&stm32f4_clk_lock);\n\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_warn(\"Unable to register %s clk\\n\", aux_clk->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (aux_clk->idx != NO_IDX)\n\t\t\tclks[aux_clk->idx] = hw;\n\t}\n\n\tif (of_device_is_compatible(np, \"st,stm32f746-rcc\")) {\n\n\t\tclk_hw_register_fixed_factor(NULL, \"hsi_div488\", \"hsi\", 0,\n\t\t\t\t1, 488);\n\n\t\tclks[CLK_PLL_SRC] = pll_src_hw;\n\t}\n\n\tof_clk_add_hw_provider(np, stm32f4_rcc_lookup_clk, NULL);\n\n\treturn;\nfail:\n\tkfree(clks);\n\tiounmap(base);\n}\nCLK_OF_DECLARE_DRIVER(stm32f42xx_rcc, \"st,stm32f42xx-rcc\", stm32f4_rcc_init);\nCLK_OF_DECLARE_DRIVER(stm32f46xx_rcc, \"st,stm32f469-rcc\", stm32f4_rcc_init);\nCLK_OF_DECLARE_DRIVER(stm32f746_rcc, \"st,stm32f746-rcc\", stm32f4_rcc_init);\nCLK_OF_DECLARE_DRIVER(stm32f769_rcc, \"st,stm32f769-rcc\", stm32f4_rcc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}