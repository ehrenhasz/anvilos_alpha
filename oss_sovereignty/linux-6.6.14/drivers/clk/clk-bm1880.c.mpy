{
  "module_name": "clk-bm1880.c",
  "hash_id": "4b6b9c2a637aaace1a6c592113dab69e0480fae988854e4a4ca76cc4500bd458",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-bm1880.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/clock/bm1880-clock.h>\n\n#define BM1880_CLK_MPLL_CTL\t0x00\n#define BM1880_CLK_SPLL_CTL\t0x04\n#define BM1880_CLK_FPLL_CTL\t0x08\n#define BM1880_CLK_DDRPLL_CTL\t0x0c\n\n#define BM1880_CLK_ENABLE0\t0x00\n#define BM1880_CLK_ENABLE1\t0x04\n#define BM1880_CLK_SELECT\t0x20\n#define BM1880_CLK_DIV0\t\t0x40\n#define BM1880_CLK_DIV1\t\t0x44\n#define BM1880_CLK_DIV2\t\t0x48\n#define BM1880_CLK_DIV3\t\t0x4c\n#define BM1880_CLK_DIV4\t\t0x50\n#define BM1880_CLK_DIV5\t\t0x54\n#define BM1880_CLK_DIV6\t\t0x58\n#define BM1880_CLK_DIV7\t\t0x5c\n#define BM1880_CLK_DIV8\t\t0x60\n#define BM1880_CLK_DIV9\t\t0x64\n#define BM1880_CLK_DIV10\t0x68\n#define BM1880_CLK_DIV11\t0x6c\n#define BM1880_CLK_DIV12\t0x70\n#define BM1880_CLK_DIV13\t0x74\n#define BM1880_CLK_DIV14\t0x78\n#define BM1880_CLK_DIV15\t0x7c\n#define BM1880_CLK_DIV16\t0x80\n#define BM1880_CLK_DIV17\t0x84\n#define BM1880_CLK_DIV18\t0x88\n#define BM1880_CLK_DIV19\t0x8c\n#define BM1880_CLK_DIV20\t0x90\n#define BM1880_CLK_DIV21\t0x94\n#define BM1880_CLK_DIV22\t0x98\n#define BM1880_CLK_DIV23\t0x9c\n#define BM1880_CLK_DIV24\t0xa0\n#define BM1880_CLK_DIV25\t0xa4\n#define BM1880_CLK_DIV26\t0xa8\n#define BM1880_CLK_DIV27\t0xac\n#define BM1880_CLK_DIV28\t0xb0\n\n#define to_bm1880_pll_clk(_hw) container_of(_hw, struct bm1880_pll_hw_clock, hw)\n#define to_bm1880_div_clk(_hw) container_of(_hw, struct bm1880_div_hw_clock, hw)\n\nstatic DEFINE_SPINLOCK(bm1880_clk_lock);\n\nstruct bm1880_clock_data {\n\tvoid __iomem *pll_base;\n\tvoid __iomem *sys_base;\n\tstruct clk_hw_onecell_data hw_data;\n};\n\nstruct bm1880_gate_clock {\n\tunsigned int\tid;\n\tconst char\t*name;\n\tconst char      *parent;\n\tu32\t\tgate_reg;\n\ts8\t\tgate_shift;\n\tunsigned long\tflags;\n};\n\nstruct bm1880_mux_clock {\n\tunsigned int\tid;\n\tconst char\t*name;\n\tconst char      * const *parents;\n\ts8\t\tnum_parents;\n\tu32\t\treg;\n\ts8\t\tshift;\n\tunsigned long\tflags;\n};\n\nstruct bm1880_div_clock {\n\tunsigned int\tid;\n\tconst char\t*name;\n\tu32\t\treg;\n\tu8\t\tshift;\n\tu8\t\twidth;\n\tu32\t\tinitval;\n\tconst struct clk_div_table *table;\n\tunsigned long flags;\n};\n\nstruct bm1880_div_hw_clock {\n\tstruct bm1880_div_clock div;\n\tvoid __iomem *base;\n\tspinlock_t *lock;\n\tstruct clk_hw hw;\n\tstruct clk_init_data init;\n};\n\nstruct bm1880_composite_clock {\n\tunsigned int\tid;\n\tconst char\t*name;\n\tconst char\t*parent;\n\tconst char      * const *parents;\n\tunsigned int\tnum_parents;\n\tunsigned long\tflags;\n\n\tu32\t\tgate_reg;\n\tu32\t\tmux_reg;\n\tu32\t\tdiv_reg;\n\n\ts8\t\tgate_shift;\n\ts8\t\tmux_shift;\n\ts8\t\tdiv_shift;\n\ts8\t\tdiv_width;\n\ts16\t\tdiv_initval;\n\tconst struct clk_div_table *table;\n};\n\nstruct bm1880_pll_clock {\n\tunsigned int\tid;\n\tconst char\t*name;\n\tu32\t\treg;\n\tunsigned long\tflags;\n};\n\nstruct bm1880_pll_hw_clock {\n\tstruct bm1880_pll_clock pll;\n\tvoid __iomem *base;\n\tstruct clk_hw hw;\n\tstruct clk_init_data init;\n};\n\nstatic const struct clk_ops bm1880_pll_ops;\nstatic const struct clk_ops bm1880_clk_div_ops;\n\n#define GATE_DIV(_id, _name, _parent, _gate_reg, _gate_shift, _div_reg,\t\\\n\t\t\t_div_shift, _div_width, _div_initval, _table,\t\\\n\t\t\t_flags) {\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\t\\\n\t\t.parent = _parent,\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.gate_reg = _gate_reg,\t\t\t\t\t\\\n\t\t.gate_shift = _gate_shift,\t\t\t\t\\\n\t\t.div_reg = _div_reg,\t\t\t\t\t\\\n\t\t.div_shift = _div_shift,\t\t\t\t\\\n\t\t.div_width = _div_width,\t\t\t\t\\\n\t\t.div_initval = _div_initval,\t\t\t\t\\\n\t\t.table = _table,\t\t\t\t\t\\\n\t\t.mux_shift = -1,\t\t\t\t\t\\\n\t\t.flags = _flags,\t\t\t\t\t\\\n\t}\n\n#define GATE_MUX(_id, _name, _parents, _gate_reg, _gate_shift,\t\t\\\n\t\t\t_mux_reg, _mux_shift, _flags) {\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\t\\\n\t\t.parents = _parents,\t\t\t\t\t\\\n\t\t.num_parents = ARRAY_SIZE(_parents),\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.gate_reg = _gate_reg,\t\t\t\t\t\\\n\t\t.gate_shift = _gate_shift,\t\t\t\t\\\n\t\t.div_shift = -1,\t\t\t\t\t\\\n\t\t.mux_reg = _mux_reg,\t\t\t\t\t\\\n\t\t.mux_shift = _mux_shift,\t\t\t\t\\\n\t\t.flags = _flags,\t\t\t\t\t\\\n\t}\n\n#define CLK_PLL(_id, _name, _parent, _reg, _flags) {\t\t\t\\\n\t\t.pll.id = _id,\t\t\t\t\t\t\\\n\t\t.pll.name = _name,\t\t\t\t\t\\\n\t\t.pll.reg = _reg,\t\t\t\t\t\\\n\t\t.hw.init = CLK_HW_INIT_PARENTS_DATA(_name, _parent,\t\\\n\t\t\t\t\t\t    &bm1880_pll_ops,\t\\\n\t\t\t\t\t\t    _flags),\t\t\\\n\t}\n\n#define CLK_DIV(_id, _name, _parent, _reg, _shift, _width, _initval,\t\\\n\t\t\t\t_table,\t_flags) {\t\t\t\\\n\t\t.div.id = _id,\t\t\t\t\t\t\\\n\t\t.div.name = _name,\t\t\t\t\t\\\n\t\t.div.reg = _reg,\t\t\t\t\t\\\n\t\t.div.shift = _shift,\t\t\t\t\t\\\n\t\t.div.width = _width,\t\t\t\t\t\\\n\t\t.div.initval = _initval,\t\t\t\t\\\n\t\t.div.table = _table,\t\t\t\t\t\\\n\t\t.hw.init = CLK_HW_INIT_HW(_name, _parent,\t\t\\\n\t\t\t\t\t  &bm1880_clk_div_ops,\t\t\\\n\t\t\t\t\t  _flags),\t\t\t\\\n\t}\n\nstatic struct clk_parent_data bm1880_pll_parent[] = {\n\t{ .fw_name = \"osc\", .name = \"osc\" },\n};\n\n \nstatic struct bm1880_pll_hw_clock bm1880_pll_clks[] = {\n\tCLK_PLL(BM1880_CLK_MPLL, \"clk_mpll\", bm1880_pll_parent,\n\t\tBM1880_CLK_MPLL_CTL, 0),\n\tCLK_PLL(BM1880_CLK_SPLL, \"clk_spll\", bm1880_pll_parent,\n\t\tBM1880_CLK_SPLL_CTL, 0),\n\tCLK_PLL(BM1880_CLK_FPLL, \"clk_fpll\", bm1880_pll_parent,\n\t\tBM1880_CLK_FPLL_CTL, 0),\n\tCLK_PLL(BM1880_CLK_DDRPLL, \"clk_ddrpll\", bm1880_pll_parent,\n\t\tBM1880_CLK_DDRPLL_CTL, 0),\n};\n\n \nstatic const struct bm1880_gate_clock bm1880_gate_clks[] = {\n\t{ BM1880_CLK_AHB_ROM, \"clk_ahb_rom\", \"clk_mux_axi6\",\n\t  BM1880_CLK_ENABLE0, 2, 0 },\n\t{ BM1880_CLK_AXI_SRAM, \"clk_axi_sram\", \"clk_axi1\",\n\t  BM1880_CLK_ENABLE0, 3, 0 },\n\t \n\t{ BM1880_CLK_DDR_AXI, \"clk_ddr_axi\", \"clk_mux_axi6\",\n\t  BM1880_CLK_ENABLE0, 4, CLK_IS_CRITICAL },\n\t{ BM1880_CLK_APB_EFUSE, \"clk_apb_efuse\", \"clk_mux_axi6\",\n\t  BM1880_CLK_ENABLE0, 6, 0 },\n\t{ BM1880_CLK_AXI5_EMMC, \"clk_axi5_emmc\", \"clk_axi5\",\n\t  BM1880_CLK_ENABLE0, 7, 0 },\n\t{ BM1880_CLK_AXI5_SD, \"clk_axi5_sd\", \"clk_axi5\",\n\t  BM1880_CLK_ENABLE0, 10, 0 },\n\t{ BM1880_CLK_AXI4_ETH0, \"clk_axi4_eth0\", \"clk_axi4\",\n\t  BM1880_CLK_ENABLE0, 14, 0 },\n\t{ BM1880_CLK_AXI4_ETH1, \"clk_axi4_eth1\", \"clk_axi4\",\n\t  BM1880_CLK_ENABLE0, 16, 0 },\n\t{ BM1880_CLK_AXI1_GDMA, \"clk_axi1_gdma\", \"clk_axi1\",\n\t  BM1880_CLK_ENABLE0, 17, 0 },\n\t \n\t{ BM1880_CLK_APB_GPIO, \"clk_apb_gpio\", \"clk_mux_axi6\",\n\t  BM1880_CLK_ENABLE0, 18, CLK_IGNORE_UNUSED },\n\t{ BM1880_CLK_APB_GPIO_INTR, \"clk_apb_gpio_intr\", \"clk_mux_axi6\",\n\t  BM1880_CLK_ENABLE0, 19, CLK_IGNORE_UNUSED },\n\t{ BM1880_CLK_AXI1_MINER, \"clk_axi1_miner\", \"clk_axi1\",\n\t  BM1880_CLK_ENABLE0, 21, 0 },\n\t{ BM1880_CLK_AHB_SF, \"clk_ahb_sf\", \"clk_mux_axi6\",\n\t  BM1880_CLK_ENABLE0, 22, 0 },\n\t \n\t{ BM1880_CLK_SDMA_AXI, \"clk_sdma_axi\", \"clk_axi5\",\n\t  BM1880_CLK_ENABLE0, 23, CLK_IS_CRITICAL },\n\t{ BM1880_CLK_APB_I2C, \"clk_apb_i2c\", \"clk_mux_axi6\",\n\t  BM1880_CLK_ENABLE0, 25, 0 },\n\t{ BM1880_CLK_APB_WDT, \"clk_apb_wdt\", \"clk_mux_axi6\",\n\t  BM1880_CLK_ENABLE0, 26, 0 },\n\t{ BM1880_CLK_APB_JPEG, \"clk_apb_jpeg\", \"clk_axi6\",\n\t  BM1880_CLK_ENABLE0, 27, 0 },\n\t{ BM1880_CLK_AXI5_NF, \"clk_axi5_nf\", \"clk_axi5\",\n\t  BM1880_CLK_ENABLE0, 29, 0 },\n\t{ BM1880_CLK_APB_NF, \"clk_apb_nf\", \"clk_axi6\",\n\t  BM1880_CLK_ENABLE0, 30, 0 },\n\t{ BM1880_CLK_APB_PWM, \"clk_apb_pwm\", \"clk_mux_axi6\",\n\t  BM1880_CLK_ENABLE1, 0, 0 },\n\t{ BM1880_CLK_RV, \"clk_rv\", \"clk_mux_rv\",\n\t  BM1880_CLK_ENABLE1, 1, 0 },\n\t{ BM1880_CLK_APB_SPI, \"clk_apb_spi\", \"clk_mux_axi6\",\n\t  BM1880_CLK_ENABLE1, 2, 0 },\n\t{ BM1880_CLK_UART_500M, \"clk_uart_500m\", \"clk_div_uart_500m\",\n\t  BM1880_CLK_ENABLE1, 4, 0 },\n\t{ BM1880_CLK_APB_UART, \"clk_apb_uart\", \"clk_axi6\",\n\t  BM1880_CLK_ENABLE1, 5, 0 },\n\t{ BM1880_CLK_APB_I2S, \"clk_apb_i2s\", \"clk_axi6\",\n\t  BM1880_CLK_ENABLE1, 6, 0 },\n\t{ BM1880_CLK_AXI4_USB, \"clk_axi4_usb\", \"clk_axi4\",\n\t  BM1880_CLK_ENABLE1, 7, 0 },\n\t{ BM1880_CLK_APB_USB, \"clk_apb_usb\", \"clk_axi6\",\n\t  BM1880_CLK_ENABLE1, 8, 0 },\n\t{ BM1880_CLK_12M_USB, \"clk_12m_usb\", \"clk_div_12m_usb\",\n\t  BM1880_CLK_ENABLE1, 11, 0 },\n\t{ BM1880_CLK_APB_VIDEO, \"clk_apb_video\", \"clk_axi6\",\n\t  BM1880_CLK_ENABLE1, 12, 0 },\n\t{ BM1880_CLK_APB_VPP, \"clk_apb_vpp\", \"clk_axi6\",\n\t  BM1880_CLK_ENABLE1, 15, 0 },\n\t{ BM1880_CLK_AXI6, \"clk_axi6\", \"clk_mux_axi6\",\n\t  BM1880_CLK_ENABLE1, 21, 0 },\n};\n\nstatic const char * const clk_a53_parents[] = { \"clk_spll\", \"clk_mpll\" };\nstatic const char * const clk_rv_parents[] = { \"clk_div_1_rv\", \"clk_div_0_rv\" };\nstatic const char * const clk_axi1_parents[] = { \"clk_div_1_axi1\", \"clk_div_0_axi1\" };\nstatic const char * const clk_axi6_parents[] = { \"clk_div_1_axi6\", \"clk_div_0_axi6\" };\n\nstatic const struct bm1880_mux_clock bm1880_mux_clks[] = {\n\t{ BM1880_CLK_MUX_RV, \"clk_mux_rv\", clk_rv_parents, 2,\n\t  BM1880_CLK_SELECT, 1, 0 },\n\t{ BM1880_CLK_MUX_AXI6, \"clk_mux_axi6\", clk_axi6_parents, 2,\n\t  BM1880_CLK_SELECT, 3, 0 },\n};\n\nstatic const struct clk_div_table bm1880_div_table_0[] = {\n\t{ 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 },\n\t{ 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 8 },\n\t{ 8, 9 }, { 9, 10 }, { 10, 11 }, { 11, 12 },\n\t{ 12, 13 }, { 13, 14 }, { 14, 15 }, { 15, 16 },\n\t{ 16, 17 }, { 17, 18 }, { 18, 19 }, { 19, 20 },\n\t{ 20, 21 }, { 21, 22 }, { 22, 23 }, { 23, 24 },\n\t{ 24, 25 }, { 25, 26 }, { 26, 27 }, { 27, 28 },\n\t{ 28, 29 }, { 29, 30 }, { 30, 31 }, { 31, 32 },\n\t{ 0, 0 }\n};\n\nstatic const struct clk_div_table bm1880_div_table_1[] = {\n\t{ 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 },\n\t{ 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 8 },\n\t{ 8, 9 }, { 9, 10 }, { 10, 11 }, { 11, 12 },\n\t{ 12, 13 }, { 13, 14 }, { 14, 15 }, { 15, 16 },\n\t{ 16, 17 }, { 17, 18 }, { 18, 19 }, { 19, 20 },\n\t{ 20, 21 }, { 21, 22 }, { 22, 23 }, { 23, 24 },\n\t{ 24, 25 }, { 25, 26 }, { 26, 27 }, { 27, 28 },\n\t{ 28, 29 }, { 29, 30 }, { 30, 31 }, { 31, 32 },\n\t{ 127, 128 }, { 0, 0 }\n};\n\nstatic const struct clk_div_table bm1880_div_table_2[] = {\n\t{ 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 },\n\t{ 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 8 },\n\t{ 8, 9 }, { 9, 10 }, { 10, 11 }, { 11, 12 },\n\t{ 12, 13 }, { 13, 14 }, { 14, 15 }, { 15, 16 },\n\t{ 16, 17 }, { 17, 18 }, { 18, 19 }, { 19, 20 },\n\t{ 20, 21 }, { 21, 22 }, { 22, 23 }, { 23, 24 },\n\t{ 24, 25 }, { 25, 26 }, { 26, 27 }, { 27, 28 },\n\t{ 28, 29 }, { 29, 30 }, { 30, 31 }, { 31, 32 },\n\t{ 127, 128 }, { 255, 256 }, { 0, 0 }\n};\n\nstatic const struct clk_div_table bm1880_div_table_3[] = {\n\t{ 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 },\n\t{ 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 8 },\n\t{ 8, 9 }, { 9, 10 }, { 10, 11 }, { 11, 12 },\n\t{ 12, 13 }, { 13, 14 }, { 14, 15 }, { 15, 16 },\n\t{ 16, 17 }, { 17, 18 }, { 18, 19 }, { 19, 20 },\n\t{ 20, 21 }, { 21, 22 }, { 22, 23 }, { 23, 24 },\n\t{ 24, 25 }, { 25, 26 }, { 26, 27 }, { 27, 28 },\n\t{ 28, 29 }, { 29, 30 }, { 30, 31 }, { 31, 32 },\n\t{ 127, 128 }, { 255, 256 }, { 511, 512 }, { 0, 0 }\n};\n\nstatic const struct clk_div_table bm1880_div_table_4[] = {\n\t{ 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 },\n\t{ 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 8 },\n\t{ 8, 9 }, { 9, 10 }, { 10, 11 }, { 11, 12 },\n\t{ 12, 13 }, { 13, 14 }, { 14, 15 }, { 15, 16 },\n\t{ 16, 17 }, { 17, 18 }, { 18, 19 }, { 19, 20 },\n\t{ 20, 21 }, { 21, 22 }, { 22, 23 }, { 23, 24 },\n\t{ 24, 25 }, { 25, 26 }, { 26, 27 }, { 27, 28 },\n\t{ 28, 29 }, { 29, 30 }, { 30, 31 }, { 31, 32 },\n\t{ 127, 128 }, { 255, 256 }, { 511, 512 }, { 65535, 65536 },\n\t{ 0, 0 }\n};\n\n \nstatic struct bm1880_div_hw_clock bm1880_div_clks[] = {\n\tCLK_DIV(BM1880_CLK_DIV_0_RV, \"clk_div_0_rv\", &bm1880_pll_clks[1].hw,\n\t\tBM1880_CLK_DIV12, 16, 5, 1, bm1880_div_table_0, 0),\n\tCLK_DIV(BM1880_CLK_DIV_1_RV, \"clk_div_1_rv\", &bm1880_pll_clks[2].hw,\n\t\tBM1880_CLK_DIV13, 16, 5, 1, bm1880_div_table_0, 0),\n\tCLK_DIV(BM1880_CLK_DIV_UART_500M, \"clk_div_uart_500m\", &bm1880_pll_clks[2].hw,\n\t\tBM1880_CLK_DIV15, 16, 7, 3, bm1880_div_table_1, 0),\n\tCLK_DIV(BM1880_CLK_DIV_0_AXI1, \"clk_div_0_axi1\", &bm1880_pll_clks[0].hw,\n\t\tBM1880_CLK_DIV21, 16, 5, 2, bm1880_div_table_0,\n\t\t0),\n\tCLK_DIV(BM1880_CLK_DIV_1_AXI1, \"clk_div_1_axi1\", &bm1880_pll_clks[2].hw,\n\t\tBM1880_CLK_DIV22, 16, 5, 3, bm1880_div_table_0,\n\t\t0),\n\tCLK_DIV(BM1880_CLK_DIV_0_AXI6, \"clk_div_0_axi6\", &bm1880_pll_clks[2].hw,\n\t\tBM1880_CLK_DIV27, 16, 5, 15, bm1880_div_table_0,\n\t\t0),\n\tCLK_DIV(BM1880_CLK_DIV_1_AXI6, \"clk_div_1_axi6\", &bm1880_pll_clks[0].hw,\n\t\tBM1880_CLK_DIV28, 16, 5, 11, bm1880_div_table_0,\n\t\t0),\n\tCLK_DIV(BM1880_CLK_DIV_12M_USB, \"clk_div_12m_usb\", &bm1880_pll_clks[2].hw,\n\t\tBM1880_CLK_DIV18, 16, 7, 125, bm1880_div_table_1, 0),\n};\n\n \nstatic struct bm1880_composite_clock bm1880_composite_clks[] = {\n\t \n\tGATE_MUX(BM1880_CLK_A53, \"clk_a53\", clk_a53_parents,\n\t\t BM1880_CLK_ENABLE0, 0, BM1880_CLK_SELECT, 0,\n\t\t CLK_IS_CRITICAL),\n\tGATE_DIV(BM1880_CLK_50M_A53, \"clk_50m_a53\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE0, 1, BM1880_CLK_DIV0, 16, 5, 30,\n\t\t bm1880_div_table_0, CLK_IS_CRITICAL),\n\tGATE_DIV(BM1880_CLK_EFUSE, \"clk_efuse\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE0, 5, BM1880_CLK_DIV1, 16, 7, 60,\n\t\t bm1880_div_table_1, 0),\n\tGATE_DIV(BM1880_CLK_EMMC, \"clk_emmc\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE0, 8, BM1880_CLK_DIV2, 16, 5, 15,\n\t\t bm1880_div_table_0, 0),\n\tGATE_DIV(BM1880_CLK_100K_EMMC, \"clk_100k_emmc\", \"clk_div_12m_usb\",\n\t\t BM1880_CLK_ENABLE0, 9, BM1880_CLK_DIV3, 16, 8, 120,\n\t\t bm1880_div_table_2, 0),\n\tGATE_DIV(BM1880_CLK_SD, \"clk_sd\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE0, 11, BM1880_CLK_DIV4, 16, 5, 15,\n\t\t bm1880_div_table_0, 0),\n\tGATE_DIV(BM1880_CLK_100K_SD, \"clk_100k_sd\", \"clk_div_12m_usb\",\n\t\t BM1880_CLK_ENABLE0, 12, BM1880_CLK_DIV5, 16, 8, 120,\n\t\t bm1880_div_table_2, 0),\n\tGATE_DIV(BM1880_CLK_500M_ETH0, \"clk_500m_eth0\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE0, 13, BM1880_CLK_DIV6, 16, 5, 3,\n\t\t bm1880_div_table_0, 0),\n\tGATE_DIV(BM1880_CLK_500M_ETH1, \"clk_500m_eth1\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE0, 15, BM1880_CLK_DIV7, 16, 5, 3,\n\t\t bm1880_div_table_0, 0),\n\t \n\tGATE_DIV(BM1880_CLK_GPIO_DB, \"clk_gpio_db\", \"clk_div_12m_usb\",\n\t\t BM1880_CLK_ENABLE0, 20, BM1880_CLK_DIV8, 16, 16, 120,\n\t\t bm1880_div_table_4, CLK_IGNORE_UNUSED),\n\tGATE_DIV(BM1880_CLK_SDMA_AUD, \"clk_sdma_aud\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE0, 24, BM1880_CLK_DIV9, 16, 7, 61,\n\t\t bm1880_div_table_1, 0),\n\tGATE_DIV(BM1880_CLK_JPEG_AXI, \"clk_jpeg_axi\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE0, 28, BM1880_CLK_DIV10, 16, 5, 4,\n\t\t bm1880_div_table_0, 0),\n\tGATE_DIV(BM1880_CLK_NF, \"clk_nf\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE0, 31, BM1880_CLK_DIV11, 16, 5, 30,\n\t\t bm1880_div_table_0, 0),\n\tGATE_DIV(BM1880_CLK_TPU_AXI, \"clk_tpu_axi\", \"clk_spll\",\n\t\t BM1880_CLK_ENABLE1, 3, BM1880_CLK_DIV14, 16, 5, 1,\n\t\t bm1880_div_table_0, 0),\n\tGATE_DIV(BM1880_CLK_125M_USB, \"clk_125m_usb\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE1, 9, BM1880_CLK_DIV16, 16, 5, 12,\n\t\t bm1880_div_table_0, 0),\n\tGATE_DIV(BM1880_CLK_33K_USB, \"clk_33k_usb\", \"clk_div_12m_usb\",\n\t\t BM1880_CLK_ENABLE1, 10, BM1880_CLK_DIV17, 16, 9, 363,\n\t\t bm1880_div_table_3, 0),\n\tGATE_DIV(BM1880_CLK_VIDEO_AXI, \"clk_video_axi\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE1, 13, BM1880_CLK_DIV19, 16, 5, 4,\n\t\t bm1880_div_table_0, 0),\n\tGATE_DIV(BM1880_CLK_VPP_AXI, \"clk_vpp_axi\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE1, 14, BM1880_CLK_DIV20, 16, 5, 4,\n\t\t bm1880_div_table_0, 0),\n\tGATE_MUX(BM1880_CLK_AXI1, \"clk_axi1\", clk_axi1_parents,\n\t\t BM1880_CLK_ENABLE1, 15, BM1880_CLK_SELECT, 2, 0),\n\tGATE_DIV(BM1880_CLK_AXI2, \"clk_axi2\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE1, 17, BM1880_CLK_DIV23, 16, 5, 3,\n\t\t bm1880_div_table_0, 0),\n\tGATE_DIV(BM1880_CLK_AXI3, \"clk_axi3\", \"clk_mux_rv\",\n\t\t BM1880_CLK_ENABLE1, 18, BM1880_CLK_DIV24, 16, 5, 2,\n\t\t bm1880_div_table_0, 0),\n\tGATE_DIV(BM1880_CLK_AXI4, \"clk_axi4\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE1, 19, BM1880_CLK_DIV25, 16, 5, 6,\n\t\t bm1880_div_table_0, 0),\n\tGATE_DIV(BM1880_CLK_AXI5, \"clk_axi5\", \"clk_fpll\",\n\t\t BM1880_CLK_ENABLE1, 20, BM1880_CLK_DIV26, 16, 5, 15,\n\t\t bm1880_div_table_0, 0),\n};\n\nstatic unsigned long bm1880_pll_rate_calc(u32 regval, unsigned long parent_rate)\n{\n\tu64 numerator;\n\tu32 fbdiv, refdiv;\n\tu32 postdiv1, postdiv2, denominator;\n\n\tfbdiv = (regval >> 16) & 0xfff;\n\trefdiv = regval & 0x1f;\n\tpostdiv1 = (regval >> 8) & 0x7;\n\tpostdiv2 = (regval >> 12) & 0x7;\n\n\tnumerator = parent_rate * fbdiv;\n\tdenominator = refdiv * postdiv1 * postdiv2;\n\tdo_div(numerator, denominator);\n\n\treturn (unsigned long)numerator;\n}\n\nstatic unsigned long bm1880_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct bm1880_pll_hw_clock *pll_hw = to_bm1880_pll_clk(hw);\n\tunsigned long rate;\n\tu32 regval;\n\n\tregval = readl(pll_hw->base + pll_hw->pll.reg);\n\trate = bm1880_pll_rate_calc(regval, parent_rate);\n\n\treturn rate;\n}\n\nstatic const struct clk_ops bm1880_pll_ops = {\n\t.recalc_rate\t= bm1880_pll_recalc_rate,\n};\n\nstatic struct clk_hw *bm1880_clk_register_pll(struct bm1880_pll_hw_clock *pll_clk,\n\t\t\t\t\t      void __iomem *sys_base)\n{\n\tstruct clk_hw *hw;\n\tint err;\n\n\tpll_clk->base = sys_base;\n\thw = &pll_clk->hw;\n\n\terr = clk_hw_register(NULL, hw);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn hw;\n}\n\nstatic int bm1880_clk_register_plls(struct bm1880_pll_hw_clock *clks,\n\t\t\t\t    int num_clks,\n\t\t\t\t    struct bm1880_clock_data *data)\n{\n\tstruct clk_hw *hw;\n\tvoid __iomem *pll_base = data->pll_base;\n\tint i;\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tstruct bm1880_pll_hw_clock *bm1880_clk = &clks[i];\n\n\t\thw = bm1880_clk_register_pll(bm1880_clk, pll_base);\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, bm1880_clk->pll.name);\n\t\t\tgoto err_clk;\n\t\t}\n\n\t\tdata->hw_data.hws[clks[i].pll.id] = hw;\n\t}\n\n\treturn 0;\n\nerr_clk:\n\twhile (i--)\n\t\tclk_hw_unregister(data->hw_data.hws[clks[i].pll.id]);\n\n\treturn PTR_ERR(hw);\n}\n\nstatic int bm1880_clk_register_mux(const struct bm1880_mux_clock *clks,\n\t\t\t\t   int num_clks,\n\t\t\t\t   struct bm1880_clock_data *data)\n{\n\tstruct clk_hw *hw;\n\tvoid __iomem *sys_base = data->sys_base;\n\tint i;\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\thw = clk_hw_register_mux(NULL, clks[i].name,\n\t\t\t\t\t clks[i].parents,\n\t\t\t\t\t clks[i].num_parents,\n\t\t\t\t\t clks[i].flags,\n\t\t\t\t\t sys_base + clks[i].reg,\n\t\t\t\t\t clks[i].shift, 1, 0,\n\t\t\t\t\t &bm1880_clk_lock);\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tgoto err_clk;\n\t\t}\n\n\t\tdata->hw_data.hws[clks[i].id] = hw;\n\t}\n\n\treturn 0;\n\nerr_clk:\n\twhile (i--)\n\t\tclk_hw_unregister_mux(data->hw_data.hws[clks[i].id]);\n\n\treturn PTR_ERR(hw);\n}\n\nstatic unsigned long bm1880_clk_div_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct bm1880_div_hw_clock *div_hw = to_bm1880_div_clk(hw);\n\tstruct bm1880_div_clock *div = &div_hw->div;\n\tvoid __iomem *reg_addr = div_hw->base + div->reg;\n\tunsigned int val;\n\tunsigned long rate;\n\n\tif (!(readl(reg_addr) & BIT(3))) {\n\t\tval = div->initval;\n\t} else {\n\t\tval = readl(reg_addr) >> div->shift;\n\t\tval &= clk_div_mask(div->width);\n\t}\n\n\trate = divider_recalc_rate(hw, parent_rate, val, div->table,\n\t\t\t\t   div->flags, div->width);\n\n\treturn rate;\n}\n\nstatic long bm1880_clk_div_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long *prate)\n{\n\tstruct bm1880_div_hw_clock *div_hw = to_bm1880_div_clk(hw);\n\tstruct bm1880_div_clock *div = &div_hw->div;\n\tvoid __iomem *reg_addr = div_hw->base + div->reg;\n\n\tif (div->flags & CLK_DIVIDER_READ_ONLY) {\n\t\tu32 val;\n\n\t\tval = readl(reg_addr) >> div->shift;\n\t\tval &= clk_div_mask(div->width);\n\n\t\treturn divider_ro_round_rate(hw, rate, prate, div->table,\n\t\t\t\t\t     div->width, div->flags,\n\t\t\t\t\t     val);\n\t}\n\n\treturn divider_round_rate(hw, rate, prate, div->table,\n\t\t\t\t  div->width, div->flags);\n}\n\nstatic int bm1880_clk_div_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct bm1880_div_hw_clock *div_hw = to_bm1880_div_clk(hw);\n\tstruct bm1880_div_clock *div = &div_hw->div;\n\tvoid __iomem *reg_addr = div_hw->base + div->reg;\n\tunsigned long flags = 0;\n\tint value;\n\tu32 val;\n\n\tvalue = divider_get_val(rate, parent_rate, div->table,\n\t\t\t\tdiv->width, div_hw->div.flags);\n\tif (value < 0)\n\t\treturn value;\n\n\tif (div_hw->lock)\n\t\tspin_lock_irqsave(div_hw->lock, flags);\n\telse\n\t\t__acquire(div_hw->lock);\n\n\tval = readl(reg_addr);\n\tval &= ~(clk_div_mask(div->width) << div_hw->div.shift);\n\tval |= (u32)value << div->shift;\n\twritel(val, reg_addr);\n\n\tif (div_hw->lock)\n\t\tspin_unlock_irqrestore(div_hw->lock, flags);\n\telse\n\t\t__release(div_hw->lock);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops bm1880_clk_div_ops = {\n\t.recalc_rate = bm1880_clk_div_recalc_rate,\n\t.round_rate = bm1880_clk_div_round_rate,\n\t.set_rate = bm1880_clk_div_set_rate,\n};\n\nstatic struct clk_hw *bm1880_clk_register_div(struct bm1880_div_hw_clock *div_clk,\n\t\t\t\t\t      void __iomem *sys_base)\n{\n\tstruct clk_hw *hw;\n\tint err;\n\n\tdiv_clk->div.flags = CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO;\n\tdiv_clk->base = sys_base;\n\tdiv_clk->lock = &bm1880_clk_lock;\n\n\thw = &div_clk->hw;\n\terr = clk_hw_register(NULL, hw);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn hw;\n}\n\nstatic int bm1880_clk_register_divs(struct bm1880_div_hw_clock *clks,\n\t\t\t\t    int num_clks,\n\t\t\t\t    struct bm1880_clock_data *data)\n{\n\tstruct clk_hw *hw;\n\tvoid __iomem *sys_base = data->sys_base;\n\tunsigned int i, id;\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tstruct bm1880_div_hw_clock *bm1880_clk = &clks[i];\n\n\t\thw = bm1880_clk_register_div(bm1880_clk, sys_base);\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, bm1880_clk->div.name);\n\t\t\tgoto err_clk;\n\t\t}\n\n\t\tid = clks[i].div.id;\n\t\tdata->hw_data.hws[id] = hw;\n\t}\n\n\treturn 0;\n\nerr_clk:\n\twhile (i--)\n\t\tclk_hw_unregister(data->hw_data.hws[clks[i].div.id]);\n\n\treturn PTR_ERR(hw);\n}\n\nstatic int bm1880_clk_register_gate(const struct bm1880_gate_clock *clks,\n\t\t\t\t    int num_clks,\n\t\t\t\t    struct bm1880_clock_data *data)\n{\n\tstruct clk_hw *hw;\n\tvoid __iomem *sys_base = data->sys_base;\n\tint i;\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\thw = clk_hw_register_gate(NULL, clks[i].name,\n\t\t\t\t\t  clks[i].parent,\n\t\t\t\t\t  clks[i].flags,\n\t\t\t\t\t  sys_base + clks[i].gate_reg,\n\t\t\t\t\t  clks[i].gate_shift, 0,\n\t\t\t\t\t  &bm1880_clk_lock);\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, clks[i].name);\n\t\t\tgoto err_clk;\n\t\t}\n\n\t\tdata->hw_data.hws[clks[i].id] = hw;\n\t}\n\n\treturn 0;\n\nerr_clk:\n\twhile (i--)\n\t\tclk_hw_unregister_gate(data->hw_data.hws[clks[i].id]);\n\n\treturn PTR_ERR(hw);\n}\n\nstatic struct clk_hw *bm1880_clk_register_composite(struct bm1880_composite_clock *clks,\n\t\t\t\t\t\t    void __iomem *sys_base)\n{\n\tstruct clk_hw *hw;\n\tstruct clk_mux *mux = NULL;\n\tstruct clk_gate *gate = NULL;\n\tstruct bm1880_div_hw_clock *div_hws = NULL;\n\tstruct clk_hw *mux_hw = NULL, *gate_hw = NULL, *div_hw = NULL;\n\tconst struct clk_ops *mux_ops = NULL, *gate_ops = NULL, *div_ops = NULL;\n\tconst char * const *parent_names;\n\tconst char *parent;\n\tint num_parents;\n\tint ret;\n\n\tif (clks->mux_shift >= 0) {\n\t\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\t\tif (!mux)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tmux->reg = sys_base + clks->mux_reg;\n\t\tmux->mask = 1;\n\t\tmux->shift = clks->mux_shift;\n\t\tmux_hw = &mux->hw;\n\t\tmux_ops = &clk_mux_ops;\n\t\tmux->lock = &bm1880_clk_lock;\n\n\t\tparent_names = clks->parents;\n\t\tnum_parents = clks->num_parents;\n\t} else {\n\t\tparent = clks->parent;\n\t\tparent_names = &parent;\n\t\tnum_parents = 1;\n\t}\n\n\tif (clks->gate_shift >= 0) {\n\t\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\t\tif (!gate) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tgate->reg = sys_base + clks->gate_reg;\n\t\tgate->bit_idx = clks->gate_shift;\n\t\tgate->lock = &bm1880_clk_lock;\n\n\t\tgate_hw = &gate->hw;\n\t\tgate_ops = &clk_gate_ops;\n\t}\n\n\tif (clks->div_shift >= 0) {\n\t\tdiv_hws = kzalloc(sizeof(*div_hws), GFP_KERNEL);\n\t\tif (!div_hws) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tdiv_hws->base = sys_base;\n\t\tdiv_hws->div.reg = clks->div_reg;\n\t\tdiv_hws->div.shift = clks->div_shift;\n\t\tdiv_hws->div.width = clks->div_width;\n\t\tdiv_hws->div.table = clks->table;\n\t\tdiv_hws->div.initval = clks->div_initval;\n\t\tdiv_hws->lock = &bm1880_clk_lock;\n\t\tdiv_hws->div.flags = CLK_DIVIDER_ONE_BASED |\n\t\t\t\t     CLK_DIVIDER_ALLOW_ZERO;\n\n\t\tdiv_hw = &div_hws->hw;\n\t\tdiv_ops = &bm1880_clk_div_ops;\n\t}\n\n\thw = clk_hw_register_composite(NULL, clks->name, parent_names,\n\t\t\t\t       num_parents, mux_hw, mux_ops, div_hw,\n\t\t\t\t       div_ops, gate_hw, gate_ops,\n\t\t\t\t       clks->flags);\n\n\tif (IS_ERR(hw)) {\n\t\tret = PTR_ERR(hw);\n\t\tgoto err_out;\n\t}\n\n\treturn hw;\n\nerr_out:\n\tkfree(div_hws);\n\tkfree(gate);\n\tkfree(mux);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic int bm1880_clk_register_composites(struct bm1880_composite_clock *clks,\n\t\t\t\t\t  int num_clks,\n\t\t\t\t\t  struct bm1880_clock_data *data)\n{\n\tstruct clk_hw *hw;\n\tvoid __iomem *sys_base = data->sys_base;\n\tint i;\n\n\tfor (i = 0; i < num_clks; i++) {\n\t\tstruct bm1880_composite_clock *bm1880_clk = &clks[i];\n\n\t\thw = bm1880_clk_register_composite(bm1880_clk, sys_base);\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"%s: failed to register clock %s\\n\",\n\t\t\t       __func__, bm1880_clk->name);\n\t\t\tgoto err_clk;\n\t\t}\n\n\t\tdata->hw_data.hws[clks[i].id] = hw;\n\t}\n\n\treturn 0;\n\nerr_clk:\n\twhile (i--)\n\t\tclk_hw_unregister_composite(data->hw_data.hws[clks[i].id]);\n\n\treturn PTR_ERR(hw);\n}\n\nstatic int bm1880_clk_probe(struct platform_device *pdev)\n{\n\tstruct bm1880_clock_data *clk_data;\n\tvoid __iomem *pll_base, *sys_base;\n\tstruct device *dev = &pdev->dev;\n\tint num_clks, i;\n\n\tpll_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pll_base))\n\t\treturn PTR_ERR(pll_base);\n\n\tsys_base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(sys_base))\n\t\treturn PTR_ERR(sys_base);\n\n\tnum_clks = ARRAY_SIZE(bm1880_pll_clks) +\n\t\t   ARRAY_SIZE(bm1880_div_clks) +\n\t\t   ARRAY_SIZE(bm1880_mux_clks) +\n\t\t   ARRAY_SIZE(bm1880_composite_clks) +\n\t\t   ARRAY_SIZE(bm1880_gate_clks);\n\n\tclk_data = devm_kzalloc(dev, struct_size(clk_data, hw_data.hws,\n\t\t\t\t\t\t num_clks), GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tclk_data->pll_base = pll_base;\n\tclk_data->sys_base = sys_base;\n\n\tfor (i = 0; i < num_clks; i++)\n\t\tclk_data->hw_data.hws[i] = ERR_PTR(-ENOENT);\n\n\tclk_data->hw_data.num = num_clks;\n\n\tbm1880_clk_register_plls(bm1880_pll_clks,\n\t\t\t\t ARRAY_SIZE(bm1880_pll_clks),\n\t\t\t\t clk_data);\n\n\tbm1880_clk_register_divs(bm1880_div_clks,\n\t\t\t\t ARRAY_SIZE(bm1880_div_clks),\n\t\t\t\t clk_data);\n\n\tbm1880_clk_register_mux(bm1880_mux_clks,\n\t\t\t\tARRAY_SIZE(bm1880_mux_clks),\n\t\t\t\tclk_data);\n\n\tbm1880_clk_register_composites(bm1880_composite_clks,\n\t\t\t\t       ARRAY_SIZE(bm1880_composite_clks),\n\t\t\t\t       clk_data);\n\n\tbm1880_clk_register_gate(bm1880_gate_clks,\n\t\t\t\t ARRAY_SIZE(bm1880_gate_clks),\n\t\t\t\t clk_data);\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get,\n\t\t\t\t      &clk_data->hw_data);\n}\n\nstatic const struct of_device_id bm1880_of_match[] = {\n\t{ .compatible = \"bitmain,bm1880-clk\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, bm1880_of_match);\n\nstatic struct platform_driver bm1880_clk_driver = {\n\t.driver = {\n\t\t.name = \"bm1880-clk\",\n\t\t.of_match_table = bm1880_of_match,\n\t},\n\t.probe = bm1880_clk_probe,\n};\nmodule_platform_driver(bm1880_clk_driver);\n\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\nMODULE_DESCRIPTION(\"Clock driver for Bitmain BM1880 SoC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}