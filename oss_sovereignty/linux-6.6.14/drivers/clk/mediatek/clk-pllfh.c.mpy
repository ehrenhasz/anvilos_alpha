{
  "module_name": "clk-pllfh.c",
  "hash_id": "f04823bdf3a45f8cfab2f4e2aaf6e941bc4178b56b39d2ec0ec8fd54999a4f41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mediatek/clk-pllfh.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/clkdev.h>\n#include <linux/delay.h>\n\n#include \"clk-mtk.h\"\n#include \"clk-pllfh.h\"\n#include \"clk-fhctl.h\"\n\nstatic DEFINE_SPINLOCK(pllfh_lock);\n\ninline struct mtk_fh *to_mtk_fh(struct clk_hw *hw)\n{\n\tstruct mtk_clk_pll *pll = to_mtk_clk_pll(hw);\n\n\treturn container_of(pll, struct mtk_fh, clk_pll);\n}\n\nstatic int mtk_fhctl_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct mtk_clk_pll *pll = to_mtk_clk_pll(hw);\n\tstruct mtk_fh *fh = to_mtk_fh(hw);\n\tu32 pcw = 0;\n\tu32 postdiv;\n\n\tmtk_pll_calc_values(pll, &pcw, &postdiv, rate, parent_rate);\n\n\treturn fh->ops->hopping(fh, pcw, postdiv);\n}\n\nstatic const struct clk_ops mtk_pllfh_ops = {\n\t.is_prepared\t= mtk_pll_is_prepared,\n\t.prepare\t= mtk_pll_prepare,\n\t.unprepare\t= mtk_pll_unprepare,\n\t.recalc_rate\t= mtk_pll_recalc_rate,\n\t.round_rate\t= mtk_pll_round_rate,\n\t.set_rate\t= mtk_fhctl_set_rate,\n};\n\nstatic struct mtk_pllfh_data *get_pllfh_by_id(struct mtk_pllfh_data *pllfhs,\n\t\t\t\t\t      int num_fhs, int pll_id)\n{\n\tint i;\n\n\tfor (i = 0; i < num_fhs; i++)\n\t\tif (pllfhs[i].data.pll_id == pll_id)\n\t\t\treturn &pllfhs[i];\n\n\treturn NULL;\n}\n\nvoid fhctl_parse_dt(const u8 *compatible_node, struct mtk_pllfh_data *pllfhs,\n\t\t    int num_fhs)\n{\n\tvoid __iomem *base;\n\tstruct device_node *node;\n\tu32 num_clocks, pll_id, ssc_rate;\n\tint offset, i;\n\n\tnode = of_find_compatible_node(NULL, NULL, compatible_node);\n\tif (!node) {\n\t\tpr_err(\"cannot find \\\"%s\\\"\\n\", compatible_node);\n\t\treturn;\n\t}\n\n\tbase = of_iomap(node, 0);\n\tif (!base) {\n\t\tpr_err(\"%s(): ioremap failed\\n\", __func__);\n\t\tgoto out_node_put;\n\t}\n\n\tnum_clocks = of_clk_get_parent_count(node);\n\tif (!num_clocks) {\n\t\tpr_err(\"%s(): failed to get clocks property\\n\", __func__);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < num_clocks; i++) {\n\t\tstruct mtk_pllfh_data *pllfh;\n\n\t\toffset = i * 2;\n\n\t\tof_property_read_u32_index(node, \"clocks\", offset + 1, &pll_id);\n\t\tof_property_read_u32_index(node,\n\t\t\t\t\t   \"mediatek,hopping-ssc-percent\",\n\t\t\t\t\t   i, &ssc_rate);\n\n\t\tpllfh = get_pllfh_by_id(pllfhs, num_fhs, pll_id);\n\t\tif (!pllfh)\n\t\t\tcontinue;\n\n\t\tpllfh->state.fh_enable = 1;\n\t\tpllfh->state.ssc_rate = ssc_rate;\n\t\tpllfh->state.base = base;\n\t}\n\nout_node_put:\n\tof_node_put(node);\n\treturn;\nerr:\n\tiounmap(base);\n\tgoto out_node_put;\n}\nEXPORT_SYMBOL_GPL(fhctl_parse_dt);\n\nstatic int pllfh_init(struct mtk_fh *fh, struct mtk_pllfh_data *pllfh_data)\n{\n\tstruct fh_pll_regs *regs = &fh->regs;\n\tconst struct fhctl_offset *offset;\n\tvoid __iomem *base = pllfh_data->state.base;\n\tvoid __iomem *fhx_base = base + pllfh_data->data.fhx_offset;\n\n\toffset = fhctl_get_offset_table(pllfh_data->data.fh_ver);\n\tif (IS_ERR(offset))\n\t\treturn PTR_ERR(offset);\n\n\tregs->reg_hp_en = base + offset->offset_hp_en;\n\tregs->reg_clk_con = base + offset->offset_clk_con;\n\tregs->reg_rst_con = base + offset->offset_rst_con;\n\tregs->reg_slope0 = base + offset->offset_slope0;\n\tregs->reg_slope1 = base + offset->offset_slope1;\n\n\tregs->reg_cfg = fhx_base + offset->offset_cfg;\n\tregs->reg_updnlmt = fhx_base + offset->offset_updnlmt;\n\tregs->reg_dds = fhx_base + offset->offset_dds;\n\tregs->reg_dvfs = fhx_base + offset->offset_dvfs;\n\tregs->reg_mon = fhx_base + offset->offset_mon;\n\n\tfh->pllfh_data = pllfh_data;\n\tfh->lock = &pllfh_lock;\n\n\tfh->ops = fhctl_get_ops();\n\n\treturn 0;\n}\n\nstatic bool fhctl_is_supported_and_enabled(const struct mtk_pllfh_data *pllfh)\n{\n\treturn pllfh && (pllfh->state.fh_enable == 1);\n}\n\nstatic struct clk_hw *\nmtk_clk_register_pllfh(const struct mtk_pll_data *pll_data,\n\t\t       struct mtk_pllfh_data *pllfh_data, void __iomem *base)\n{\n\tstruct clk_hw *hw;\n\tstruct mtk_fh *fh;\n\tint ret;\n\n\tfh = kzalloc(sizeof(*fh), GFP_KERNEL);\n\tif (!fh)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = pllfh_init(fh, pllfh_data);\n\tif (ret) {\n\t\thw = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\thw = mtk_clk_register_pll_ops(&fh->clk_pll, pll_data, base,\n\t\t\t\t      &mtk_pllfh_ops);\n\n\tif (IS_ERR(hw))\n\t\tgoto out;\n\n\tfhctl_hw_init(fh);\n\nout:\n\tif (IS_ERR(hw))\n\t\tkfree(fh);\n\n\treturn hw;\n}\n\nstatic void mtk_clk_unregister_pllfh(struct clk_hw *hw)\n{\n\tstruct mtk_fh *fh;\n\n\tif (!hw)\n\t\treturn;\n\n\tfh = to_mtk_fh(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(fh);\n}\n\nint mtk_clk_register_pllfhs(struct device_node *node,\n\t\t\t    const struct mtk_pll_data *plls, int num_plls,\n\t\t\t    struct mtk_pllfh_data *pllfhs, int num_fhs,\n\t\t\t    struct clk_hw_onecell_data *clk_data)\n{\n\tvoid __iomem *base;\n\tint i;\n\tstruct clk_hw *hw;\n\n\tbase = of_iomap(node, 0);\n\tif (!base) {\n\t\tpr_err(\"%s(): ioremap failed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_plls; i++) {\n\t\tconst struct mtk_pll_data *pll = &plls[i];\n\t\tstruct mtk_pllfh_data *pllfh;\n\t\tbool use_fhctl;\n\n\t\tpllfh = get_pllfh_by_id(pllfhs, num_fhs, pll->id);\n\t\tuse_fhctl = fhctl_is_supported_and_enabled(pllfh);\n\n\t\tif (use_fhctl)\n\t\t\thw = mtk_clk_register_pllfh(pll, pllfh, base);\n\t\telse\n\t\t\thw = mtk_clk_register_pll(pll, base);\n\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"Failed to register %s clk %s: %ld\\n\",\n\t\t\t       use_fhctl ? \"fhpll\" : \"pll\", pll->name,\n\t\t\t       PTR_ERR(hw));\n\t\t\tgoto err;\n\t\t}\n\n\t\tclk_data->hws[pll->id] = hw;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0) {\n\t\tconst struct mtk_pll_data *pll = &plls[i];\n\t\tstruct mtk_pllfh_data *pllfh;\n\t\tbool use_fhctl;\n\n\t\tpllfh = get_pllfh_by_id(pllfhs, num_fhs, pll->id);\n\t\tuse_fhctl = fhctl_is_supported_and_enabled(pllfh);\n\n\t\tif (use_fhctl)\n\t\t\tmtk_clk_unregister_pllfh(clk_data->hws[pll->id]);\n\t\telse\n\t\t\tmtk_clk_unregister_pll(clk_data->hws[pll->id]);\n\n\t\tclk_data->hws[pll->id] = ERR_PTR(-ENOENT);\n\t}\n\n\tiounmap(base);\n\n\treturn PTR_ERR(hw);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_register_pllfhs);\n\nvoid mtk_clk_unregister_pllfhs(const struct mtk_pll_data *plls, int num_plls,\n\t\t\t       struct mtk_pllfh_data *pllfhs, int num_fhs,\n\t\t\t       struct clk_hw_onecell_data *clk_data)\n{\n\tvoid __iomem *base = NULL, *fhctl_base = NULL;\n\tint i;\n\n\tif (!clk_data)\n\t\treturn;\n\n\tfor (i = num_plls; i > 0; i--) {\n\t\tconst struct mtk_pll_data *pll = &plls[i - 1];\n\t\tstruct mtk_pllfh_data *pllfh;\n\t\tbool use_fhctl;\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[pll->id]))\n\t\t\tcontinue;\n\n\t\tpllfh = get_pllfh_by_id(pllfhs, num_fhs, pll->id);\n\t\tuse_fhctl = fhctl_is_supported_and_enabled(pllfh);\n\n\t\tif (use_fhctl) {\n\t\t\tfhctl_base = pllfh->state.base;\n\t\t\tmtk_clk_unregister_pllfh(clk_data->hws[pll->id]);\n\t\t} else {\n\t\t\tbase = mtk_clk_pll_get_base(clk_data->hws[pll->id],\n\t\t\t\t\t\t    pll);\n\t\t\tmtk_clk_unregister_pll(clk_data->hws[pll->id]);\n\t\t}\n\n\t\tclk_data->hws[pll->id] = ERR_PTR(-ENOENT);\n\t}\n\n\tif (fhctl_base)\n\t\tiounmap(fhctl_base);\n\n\tiounmap(base);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_unregister_pllfhs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}