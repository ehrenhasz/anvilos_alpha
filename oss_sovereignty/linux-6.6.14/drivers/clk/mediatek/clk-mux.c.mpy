{
  "module_name": "clk-mux.c",
  "hash_id": "2b8f3ecba4d8664a0442284c6d6eb9012fb3dbb05f9a03b8d4079a2850552ef7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mediatek/clk-mux.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/compiler_types.h>\n#include <linux/container_of.h>\n#include <linux/err.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#include \"clk-mux.h\"\n\nstruct mtk_clk_mux {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tconst struct mtk_mux *data;\n\tspinlock_t *lock;\n\tbool reparent;\n};\n\nstatic inline struct mtk_clk_mux *to_mtk_clk_mux(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct mtk_clk_mux, hw);\n}\n\nstatic int mtk_clk_mux_enable_setclr(struct clk_hw *hw)\n{\n\tstruct mtk_clk_mux *mux = to_mtk_clk_mux(hw);\n\tunsigned long flags = 0;\n\n\tif (mux->lock)\n\t\tspin_lock_irqsave(mux->lock, flags);\n\telse\n\t\t__acquire(mux->lock);\n\n\tregmap_write(mux->regmap, mux->data->clr_ofs,\n\t\t     BIT(mux->data->gate_shift));\n\n\t \n\tif (mux->reparent && mux->data->upd_shift >= 0) {\n\t\tregmap_write(mux->regmap, mux->data->upd_ofs,\n\t\t\t     BIT(mux->data->upd_shift));\n\t\tmux->reparent = false;\n\t}\n\n\tif (mux->lock)\n\t\tspin_unlock_irqrestore(mux->lock, flags);\n\telse\n\t\t__release(mux->lock);\n\n\treturn 0;\n}\n\nstatic void mtk_clk_mux_disable_setclr(struct clk_hw *hw)\n{\n\tstruct mtk_clk_mux *mux = to_mtk_clk_mux(hw);\n\n\tregmap_write(mux->regmap, mux->data->set_ofs,\n\t\t\tBIT(mux->data->gate_shift));\n}\n\nstatic int mtk_clk_mux_is_enabled(struct clk_hw *hw)\n{\n\tstruct mtk_clk_mux *mux = to_mtk_clk_mux(hw);\n\tu32 val;\n\n\tregmap_read(mux->regmap, mux->data->mux_ofs, &val);\n\n\treturn (val & BIT(mux->data->gate_shift)) == 0;\n}\n\nstatic u8 mtk_clk_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct mtk_clk_mux *mux = to_mtk_clk_mux(hw);\n\tu32 mask = GENMASK(mux->data->mux_width - 1, 0);\n\tu32 val;\n\n\tregmap_read(mux->regmap, mux->data->mux_ofs, &val);\n\tval = (val >> mux->data->mux_shift) & mask;\n\n\treturn val;\n}\n\nstatic int mtk_clk_mux_set_parent_setclr_lock(struct clk_hw *hw, u8 index)\n{\n\tstruct mtk_clk_mux *mux = to_mtk_clk_mux(hw);\n\tu32 mask = GENMASK(mux->data->mux_width - 1, 0);\n\tu32 val, orig;\n\tunsigned long flags = 0;\n\n\tif (mux->lock)\n\t\tspin_lock_irqsave(mux->lock, flags);\n\telse\n\t\t__acquire(mux->lock);\n\n\tregmap_read(mux->regmap, mux->data->mux_ofs, &orig);\n\tval = (orig & ~(mask << mux->data->mux_shift))\n\t\t\t| (index << mux->data->mux_shift);\n\n\tif (val != orig) {\n\t\tregmap_write(mux->regmap, mux->data->clr_ofs,\n\t\t\t\tmask << mux->data->mux_shift);\n\t\tregmap_write(mux->regmap, mux->data->set_ofs,\n\t\t\t\tindex << mux->data->mux_shift);\n\n\t\tif (mux->data->upd_shift >= 0) {\n\t\t\tregmap_write(mux->regmap, mux->data->upd_ofs,\n\t\t\t\t\tBIT(mux->data->upd_shift));\n\t\t\tmux->reparent = true;\n\t\t}\n\t}\n\n\tif (mux->lock)\n\t\tspin_unlock_irqrestore(mux->lock, flags);\n\telse\n\t\t__release(mux->lock);\n\n\treturn 0;\n}\n\nstatic int mtk_clk_mux_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tstruct mtk_clk_mux *mux = to_mtk_clk_mux(hw);\n\n\treturn clk_mux_determine_rate_flags(hw, req, mux->data->flags);\n}\n\nconst struct clk_ops mtk_mux_clr_set_upd_ops = {\n\t.get_parent = mtk_clk_mux_get_parent,\n\t.set_parent = mtk_clk_mux_set_parent_setclr_lock,\n\t.determine_rate = mtk_clk_mux_determine_rate,\n};\nEXPORT_SYMBOL_GPL(mtk_mux_clr_set_upd_ops);\n\nconst struct clk_ops mtk_mux_gate_clr_set_upd_ops  = {\n\t.enable = mtk_clk_mux_enable_setclr,\n\t.disable = mtk_clk_mux_disable_setclr,\n\t.is_enabled = mtk_clk_mux_is_enabled,\n\t.get_parent = mtk_clk_mux_get_parent,\n\t.set_parent = mtk_clk_mux_set_parent_setclr_lock,\n\t.determine_rate = mtk_clk_mux_determine_rate,\n};\nEXPORT_SYMBOL_GPL(mtk_mux_gate_clr_set_upd_ops);\n\nstatic struct clk_hw *mtk_clk_register_mux(struct device *dev,\n\t\t\t\t\t   const struct mtk_mux *mux,\n\t\t\t\t\t   struct regmap *regmap,\n\t\t\t\t\t   spinlock_t *lock)\n{\n\tstruct mtk_clk_mux *clk_mux;\n\tstruct clk_init_data init = {};\n\tint ret;\n\n\tclk_mux = kzalloc(sizeof(*clk_mux), GFP_KERNEL);\n\tif (!clk_mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = mux->name;\n\tinit.flags = mux->flags;\n\tinit.parent_names = mux->parent_names;\n\tinit.num_parents = mux->num_parents;\n\tinit.ops = mux->ops;\n\n\tclk_mux->regmap = regmap;\n\tclk_mux->data = mux;\n\tclk_mux->lock = lock;\n\tclk_mux->hw.init = &init;\n\n\tret = clk_hw_register(dev, &clk_mux->hw);\n\tif (ret) {\n\t\tkfree(clk_mux);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn &clk_mux->hw;\n}\n\nstatic void mtk_clk_unregister_mux(struct clk_hw *hw)\n{\n\tstruct mtk_clk_mux *mux;\n\tif (!hw)\n\t\treturn;\n\n\tmux = to_mtk_clk_mux(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(mux);\n}\n\nint mtk_clk_register_muxes(struct device *dev,\n\t\t\t   const struct mtk_mux *muxes,\n\t\t\t   int num, struct device_node *node,\n\t\t\t   spinlock_t *lock,\n\t\t\t   struct clk_hw_onecell_data *clk_data)\n{\n\tstruct regmap *regmap;\n\tstruct clk_hw *hw;\n\tint i;\n\n\tregmap = device_node_to_regmap(node);\n\tif (IS_ERR(regmap)) {\n\t\tpr_err(\"Cannot find regmap for %pOF: %pe\\n\", node, regmap);\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tconst struct mtk_mux *mux = &muxes[i];\n\n\t\tif (!IS_ERR_OR_NULL(clk_data->hws[mux->id])) {\n\t\t\tpr_warn(\"%pOF: Trying to register duplicate clock ID: %d\\n\",\n\t\t\t\tnode, mux->id);\n\t\t\tcontinue;\n\t\t}\n\n\t\thw = mtk_clk_register_mux(dev, mux, regmap, lock);\n\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"Failed to register clk %s: %pe\\n\", mux->name,\n\t\t\t       hw);\n\t\t\tgoto err;\n\t\t}\n\n\t\tclk_data->hws[mux->id] = hw;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0) {\n\t\tconst struct mtk_mux *mux = &muxes[i];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[mux->id]))\n\t\t\tcontinue;\n\n\t\tmtk_clk_unregister_mux(clk_data->hws[mux->id]);\n\t\tclk_data->hws[mux->id] = ERR_PTR(-ENOENT);\n\t}\n\n\treturn PTR_ERR(hw);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_register_muxes);\n\nvoid mtk_clk_unregister_muxes(const struct mtk_mux *muxes, int num,\n\t\t\t      struct clk_hw_onecell_data *clk_data)\n{\n\tint i;\n\n\tif (!clk_data)\n\t\treturn;\n\n\tfor (i = num; i > 0; i--) {\n\t\tconst struct mtk_mux *mux = &muxes[i - 1];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[mux->id]))\n\t\t\tcontinue;\n\n\t\tmtk_clk_unregister_mux(clk_data->hws[mux->id]);\n\t\tclk_data->hws[mux->id] = ERR_PTR(-ENOENT);\n\t}\n}\nEXPORT_SYMBOL_GPL(mtk_clk_unregister_muxes);\n\n \nstatic int mtk_clk_mux_notifier_cb(struct notifier_block *nb,\n\t\t\t\t   unsigned long event, void *_data)\n{\n\tstruct clk_notifier_data *data = _data;\n\tstruct clk_hw *hw = __clk_get_hw(data->clk);\n\tstruct mtk_mux_nb *mux_nb = to_mtk_mux_nb(nb);\n\tint ret = 0;\n\n\tswitch (event) {\n\tcase PRE_RATE_CHANGE:\n\t\tmux_nb->original_index = mux_nb->ops->get_parent(hw);\n\t\tret = mux_nb->ops->set_parent(hw, mux_nb->bypass_index);\n\t\tbreak;\n\tcase POST_RATE_CHANGE:\n\tcase ABORT_RATE_CHANGE:\n\t\tret = mux_nb->ops->set_parent(hw, mux_nb->original_index);\n\t\tbreak;\n\t}\n\n\treturn notifier_from_errno(ret);\n}\n\nint devm_mtk_clk_mux_notifier_register(struct device *dev, struct clk *clk,\n\t\t\t\t       struct mtk_mux_nb *mux_nb)\n{\n\tmux_nb->nb.notifier_call = mtk_clk_mux_notifier_cb;\n\n\treturn devm_clk_notifier_register(dev, clk, &mux_nb->nb);\n}\nEXPORT_SYMBOL_GPL(devm_mtk_clk_mux_notifier_register);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}