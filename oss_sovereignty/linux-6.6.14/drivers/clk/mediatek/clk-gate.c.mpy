{
  "module_name": "clk-gate.c",
  "hash_id": "e969a132740fc21f4b6a7acd9e3e75a7c090869dce64250e602dd4872a511a92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mediatek/clk-gate.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"clk-gate.h\"\n\nstruct mtk_clk_gate {\n\tstruct clk_hw\thw;\n\tstruct regmap\t*regmap;\n\tint\t\tset_ofs;\n\tint\t\tclr_ofs;\n\tint\t\tsta_ofs;\n\tu8\t\tbit;\n};\n\nstatic inline struct mtk_clk_gate *to_mtk_clk_gate(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct mtk_clk_gate, hw);\n}\n\nstatic u32 mtk_get_clockgating(struct clk_hw *hw)\n{\n\tstruct mtk_clk_gate *cg = to_mtk_clk_gate(hw);\n\tu32 val;\n\n\tregmap_read(cg->regmap, cg->sta_ofs, &val);\n\n\treturn val & BIT(cg->bit);\n}\n\nstatic int mtk_cg_bit_is_cleared(struct clk_hw *hw)\n{\n\treturn mtk_get_clockgating(hw) == 0;\n}\n\nstatic int mtk_cg_bit_is_set(struct clk_hw *hw)\n{\n\treturn mtk_get_clockgating(hw) != 0;\n}\n\nstatic void mtk_cg_set_bit(struct clk_hw *hw)\n{\n\tstruct mtk_clk_gate *cg = to_mtk_clk_gate(hw);\n\n\tregmap_write(cg->regmap, cg->set_ofs, BIT(cg->bit));\n}\n\nstatic void mtk_cg_clr_bit(struct clk_hw *hw)\n{\n\tstruct mtk_clk_gate *cg = to_mtk_clk_gate(hw);\n\n\tregmap_write(cg->regmap, cg->clr_ofs, BIT(cg->bit));\n}\n\nstatic void mtk_cg_set_bit_no_setclr(struct clk_hw *hw)\n{\n\tstruct mtk_clk_gate *cg = to_mtk_clk_gate(hw);\n\n\tregmap_set_bits(cg->regmap, cg->sta_ofs, BIT(cg->bit));\n}\n\nstatic void mtk_cg_clr_bit_no_setclr(struct clk_hw *hw)\n{\n\tstruct mtk_clk_gate *cg = to_mtk_clk_gate(hw);\n\n\tregmap_clear_bits(cg->regmap, cg->sta_ofs, BIT(cg->bit));\n}\n\nstatic int mtk_cg_enable(struct clk_hw *hw)\n{\n\tmtk_cg_clr_bit(hw);\n\n\treturn 0;\n}\n\nstatic void mtk_cg_disable(struct clk_hw *hw)\n{\n\tmtk_cg_set_bit(hw);\n}\n\nstatic int mtk_cg_enable_inv(struct clk_hw *hw)\n{\n\tmtk_cg_set_bit(hw);\n\n\treturn 0;\n}\n\nstatic void mtk_cg_disable_inv(struct clk_hw *hw)\n{\n\tmtk_cg_clr_bit(hw);\n}\n\nstatic int mtk_cg_enable_no_setclr(struct clk_hw *hw)\n{\n\tmtk_cg_clr_bit_no_setclr(hw);\n\n\treturn 0;\n}\n\nstatic void mtk_cg_disable_no_setclr(struct clk_hw *hw)\n{\n\tmtk_cg_set_bit_no_setclr(hw);\n}\n\nstatic int mtk_cg_enable_inv_no_setclr(struct clk_hw *hw)\n{\n\tmtk_cg_set_bit_no_setclr(hw);\n\n\treturn 0;\n}\n\nstatic void mtk_cg_disable_inv_no_setclr(struct clk_hw *hw)\n{\n\tmtk_cg_clr_bit_no_setclr(hw);\n}\n\nconst struct clk_ops mtk_clk_gate_ops_setclr = {\n\t.is_enabled\t= mtk_cg_bit_is_cleared,\n\t.enable\t\t= mtk_cg_enable,\n\t.disable\t= mtk_cg_disable,\n};\nEXPORT_SYMBOL_GPL(mtk_clk_gate_ops_setclr);\n\nconst struct clk_ops mtk_clk_gate_ops_setclr_inv = {\n\t.is_enabled\t= mtk_cg_bit_is_set,\n\t.enable\t\t= mtk_cg_enable_inv,\n\t.disable\t= mtk_cg_disable_inv,\n};\nEXPORT_SYMBOL_GPL(mtk_clk_gate_ops_setclr_inv);\n\nconst struct clk_ops mtk_clk_gate_ops_no_setclr = {\n\t.is_enabled\t= mtk_cg_bit_is_cleared,\n\t.enable\t\t= mtk_cg_enable_no_setclr,\n\t.disable\t= mtk_cg_disable_no_setclr,\n};\nEXPORT_SYMBOL_GPL(mtk_clk_gate_ops_no_setclr);\n\nconst struct clk_ops mtk_clk_gate_ops_no_setclr_inv = {\n\t.is_enabled\t= mtk_cg_bit_is_set,\n\t.enable\t\t= mtk_cg_enable_inv_no_setclr,\n\t.disable\t= mtk_cg_disable_inv_no_setclr,\n};\nEXPORT_SYMBOL_GPL(mtk_clk_gate_ops_no_setclr_inv);\n\nstatic struct clk_hw *mtk_clk_register_gate(struct device *dev, const char *name,\n\t\t\t\t\t const char *parent_name,\n\t\t\t\t\t struct regmap *regmap, int set_ofs,\n\t\t\t\t\t int clr_ofs, int sta_ofs, u8 bit,\n\t\t\t\t\t const struct clk_ops *ops,\n\t\t\t\t\t unsigned long flags)\n{\n\tstruct mtk_clk_gate *cg;\n\tint ret;\n\tstruct clk_init_data init = {};\n\n\tcg = kzalloc(sizeof(*cg), GFP_KERNEL);\n\tif (!cg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.flags = flags | CLK_SET_RATE_PARENT;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\tinit.ops = ops;\n\n\tcg->regmap = regmap;\n\tcg->set_ofs = set_ofs;\n\tcg->clr_ofs = clr_ofs;\n\tcg->sta_ofs = sta_ofs;\n\tcg->bit = bit;\n\n\tcg->hw.init = &init;\n\n\tret = clk_hw_register(dev, &cg->hw);\n\tif (ret) {\n\t\tkfree(cg);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn &cg->hw;\n}\n\nstatic void mtk_clk_unregister_gate(struct clk_hw *hw)\n{\n\tstruct mtk_clk_gate *cg;\n\tif (!hw)\n\t\treturn;\n\n\tcg = to_mtk_clk_gate(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(cg);\n}\n\nint mtk_clk_register_gates(struct device *dev, struct device_node *node,\n\t\t\t   const struct mtk_gate *clks, int num,\n\t\t\t   struct clk_hw_onecell_data *clk_data)\n{\n\tint i;\n\tstruct clk_hw *hw;\n\tstruct regmap *regmap;\n\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tregmap = device_node_to_regmap(node);\n\tif (IS_ERR(regmap)) {\n\t\tpr_err(\"Cannot find regmap for %pOF: %pe\\n\", node, regmap);\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tconst struct mtk_gate *gate = &clks[i];\n\n\t\tif (!IS_ERR_OR_NULL(clk_data->hws[gate->id])) {\n\t\t\tpr_warn(\"%pOF: Trying to register duplicate clock ID: %d\\n\",\n\t\t\t\tnode, gate->id);\n\t\t\tcontinue;\n\t\t}\n\n\t\thw = mtk_clk_register_gate(dev, gate->name, gate->parent_name,\n\t\t\t\t\t    regmap,\n\t\t\t\t\t    gate->regs->set_ofs,\n\t\t\t\t\t    gate->regs->clr_ofs,\n\t\t\t\t\t    gate->regs->sta_ofs,\n\t\t\t\t\t    gate->shift, gate->ops,\n\t\t\t\t\t    gate->flags);\n\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"Failed to register clk %s: %pe\\n\", gate->name,\n\t\t\t       hw);\n\t\t\tgoto err;\n\t\t}\n\n\t\tclk_data->hws[gate->id] = hw;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0) {\n\t\tconst struct mtk_gate *gate = &clks[i];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[gate->id]))\n\t\t\tcontinue;\n\n\t\tmtk_clk_unregister_gate(clk_data->hws[gate->id]);\n\t\tclk_data->hws[gate->id] = ERR_PTR(-ENOENT);\n\t}\n\n\treturn PTR_ERR(hw);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_register_gates);\n\nvoid mtk_clk_unregister_gates(const struct mtk_gate *clks, int num,\n\t\t\t      struct clk_hw_onecell_data *clk_data)\n{\n\tint i;\n\n\tif (!clk_data)\n\t\treturn;\n\n\tfor (i = num; i > 0; i--) {\n\t\tconst struct mtk_gate *gate = &clks[i - 1];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[gate->id]))\n\t\t\tcontinue;\n\n\t\tmtk_clk_unregister_gate(clk_data->hws[gate->id]);\n\t\tclk_data->hws[gate->id] = ERR_PTR(-ENOENT);\n\t}\n}\nEXPORT_SYMBOL_GPL(mtk_clk_unregister_gates);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}