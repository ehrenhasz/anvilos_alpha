{
  "module_name": "clk-apmixed.c",
  "hash_id": "eac66561fa2781ca02506e4235ace5fa5bc0206078dcbe77848e9943c446fed5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mediatek/clk-apmixed.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n\n#include \"clk-mtk.h\"\n\n#define REF2USB_TX_EN\t\tBIT(0)\n#define REF2USB_TX_LPF_EN\tBIT(1)\n#define REF2USB_TX_OUT_EN\tBIT(2)\n#define REF2USB_EN_MASK\t\t(REF2USB_TX_EN | REF2USB_TX_LPF_EN | \\\n\t\t\t\t REF2USB_TX_OUT_EN)\n\nstruct mtk_ref2usb_tx {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*base_addr;\n};\n\nstatic inline struct mtk_ref2usb_tx *to_mtk_ref2usb_tx(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct mtk_ref2usb_tx, hw);\n}\n\nstatic int mtk_ref2usb_tx_is_prepared(struct clk_hw *hw)\n{\n\tstruct mtk_ref2usb_tx *tx = to_mtk_ref2usb_tx(hw);\n\n\treturn (readl(tx->base_addr) & REF2USB_EN_MASK) == REF2USB_EN_MASK;\n}\n\nstatic int mtk_ref2usb_tx_prepare(struct clk_hw *hw)\n{\n\tstruct mtk_ref2usb_tx *tx = to_mtk_ref2usb_tx(hw);\n\tu32 val;\n\n\tval = readl(tx->base_addr);\n\n\tval |= REF2USB_TX_EN;\n\twritel(val, tx->base_addr);\n\tudelay(100);\n\n\tval |= REF2USB_TX_LPF_EN;\n\twritel(val, tx->base_addr);\n\n\tval |= REF2USB_TX_OUT_EN;\n\twritel(val, tx->base_addr);\n\n\treturn 0;\n}\n\nstatic void mtk_ref2usb_tx_unprepare(struct clk_hw *hw)\n{\n\tstruct mtk_ref2usb_tx *tx = to_mtk_ref2usb_tx(hw);\n\tu32 val;\n\n\tval = readl(tx->base_addr);\n\tval &= ~REF2USB_EN_MASK;\n\twritel(val, tx->base_addr);\n}\n\nstatic const struct clk_ops mtk_ref2usb_tx_ops = {\n\t.is_prepared\t= mtk_ref2usb_tx_is_prepared,\n\t.prepare\t= mtk_ref2usb_tx_prepare,\n\t.unprepare\t= mtk_ref2usb_tx_unprepare,\n};\n\nstruct clk_hw *mtk_clk_register_ref2usb_tx(const char *name,\n\t\t\tconst char *parent_name, void __iomem *reg)\n{\n\tstruct mtk_ref2usb_tx *tx;\n\tstruct clk_init_data init = {};\n\tint ret;\n\n\ttx = kzalloc(sizeof(*tx), GFP_KERNEL);\n\tif (!tx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttx->base_addr = reg;\n\ttx->hw.init = &init;\n\n\tinit.name = name;\n\tinit.ops = &mtk_ref2usb_tx_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tret = clk_hw_register(NULL, &tx->hw);\n\n\tif (ret) {\n\t\tkfree(tx);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn &tx->hw;\n}\nEXPORT_SYMBOL_GPL(mtk_clk_register_ref2usb_tx);\n\nvoid mtk_clk_unregister_ref2usb_tx(struct clk_hw *hw)\n{\n\tstruct mtk_ref2usb_tx *tx = to_mtk_ref2usb_tx(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(tx);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_unregister_ref2usb_tx);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}