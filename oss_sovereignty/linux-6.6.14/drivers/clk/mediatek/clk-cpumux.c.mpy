{
  "module_name": "clk-cpumux.c",
  "hash_id": "f5854f0df133d12a694436aab8d4717aeef28db5910183a2b39e76740f162db9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mediatek/clk-cpumux.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/container_of.h>\n#include <linux/err.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"clk-mtk.h\"\n#include \"clk-cpumux.h\"\n\nstruct mtk_clk_cpumux {\n\tstruct clk_hw\thw;\n\tstruct regmap\t*regmap;\n\tu32\t\treg;\n\tu32\t\tmask;\n\tu8\t\tshift;\n};\n\nstatic inline struct mtk_clk_cpumux *to_mtk_clk_cpumux(struct clk_hw *_hw)\n{\n\treturn container_of(_hw, struct mtk_clk_cpumux, hw);\n}\n\nstatic u8 clk_cpumux_get_parent(struct clk_hw *hw)\n{\n\tstruct mtk_clk_cpumux *mux = to_mtk_clk_cpumux(hw);\n\tunsigned int val;\n\n\tregmap_read(mux->regmap, mux->reg, &val);\n\n\tval >>= mux->shift;\n\tval &= mux->mask;\n\n\treturn val;\n}\n\nstatic int clk_cpumux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct mtk_clk_cpumux *mux = to_mtk_clk_cpumux(hw);\n\tu32 mask, val;\n\n\tval = index << mux->shift;\n\tmask = mux->mask << mux->shift;\n\n\treturn regmap_update_bits(mux->regmap, mux->reg, mask, val);\n}\n\nstatic const struct clk_ops clk_cpumux_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.get_parent = clk_cpumux_get_parent,\n\t.set_parent = clk_cpumux_set_parent,\n};\n\nstatic struct clk_hw *\nmtk_clk_register_cpumux(struct device *dev, const struct mtk_composite *mux,\n\t\t\tstruct regmap *regmap)\n{\n\tstruct mtk_clk_cpumux *cpumux;\n\tint ret;\n\tstruct clk_init_data init;\n\n\tcpumux = kzalloc(sizeof(*cpumux), GFP_KERNEL);\n\tif (!cpumux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = mux->name;\n\tinit.ops = &clk_cpumux_ops;\n\tinit.parent_names = mux->parent_names;\n\tinit.num_parents = mux->num_parents;\n\tinit.flags = mux->flags;\n\n\tcpumux->reg = mux->mux_reg;\n\tcpumux->shift = mux->mux_shift;\n\tcpumux->mask = BIT(mux->mux_width) - 1;\n\tcpumux->regmap = regmap;\n\tcpumux->hw.init = &init;\n\n\tret = clk_hw_register(dev, &cpumux->hw);\n\tif (ret) {\n\t\tkfree(cpumux);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn &cpumux->hw;\n}\n\nstatic void mtk_clk_unregister_cpumux(struct clk_hw *hw)\n{\n\tstruct mtk_clk_cpumux *cpumux;\n\tif (!hw)\n\t\treturn;\n\n\tcpumux = to_mtk_clk_cpumux(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(cpumux);\n}\n\nint mtk_clk_register_cpumuxes(struct device *dev, struct device_node *node,\n\t\t\t      const struct mtk_composite *clks, int num,\n\t\t\t      struct clk_hw_onecell_data *clk_data)\n{\n\tint i;\n\tstruct clk_hw *hw;\n\tstruct regmap *regmap;\n\n\tregmap = device_node_to_regmap(node);\n\tif (IS_ERR(regmap)) {\n\t\tpr_err(\"Cannot find regmap for %pOF: %pe\\n\", node, regmap);\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tconst struct mtk_composite *mux = &clks[i];\n\n\t\tif (!IS_ERR_OR_NULL(clk_data->hws[mux->id])) {\n\t\t\tpr_warn(\"%pOF: Trying to register duplicate clock ID: %d\\n\",\n\t\t\t\tnode, mux->id);\n\t\t\tcontinue;\n\t\t}\n\n\t\thw = mtk_clk_register_cpumux(dev, mux, regmap);\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"Failed to register clk %s: %pe\\n\", mux->name,\n\t\t\t       hw);\n\t\t\tgoto err;\n\t\t}\n\n\t\tclk_data->hws[mux->id] = hw;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0) {\n\t\tconst struct mtk_composite *mux = &clks[i];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[mux->id]))\n\t\t\tcontinue;\n\n\t\tmtk_clk_unregister_cpumux(clk_data->hws[mux->id]);\n\t\tclk_data->hws[mux->id] = ERR_PTR(-ENOENT);\n\t}\n\n\treturn PTR_ERR(hw);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_register_cpumuxes);\n\nvoid mtk_clk_unregister_cpumuxes(const struct mtk_composite *clks, int num,\n\t\t\t\t struct clk_hw_onecell_data *clk_data)\n{\n\tint i;\n\n\tfor (i = num; i > 0; i--) {\n\t\tconst struct mtk_composite *mux = &clks[i - 1];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[mux->id]))\n\t\t\tcontinue;\n\n\t\tmtk_clk_unregister_cpumux(clk_data->hws[mux->id]);\n\t\tclk_data->hws[mux->id] = ERR_PTR(-ENOENT);\n\t}\n}\nEXPORT_SYMBOL_GPL(mtk_clk_unregister_cpumuxes);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}