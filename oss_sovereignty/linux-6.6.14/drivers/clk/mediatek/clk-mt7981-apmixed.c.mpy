{
  "module_name": "clk-mt7981-apmixed.c",
  "hash_id": "746812b102d3b7e1726fe9c24959ec9bf264abfa53916b85cccd14bfb0a2bd3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mediatek/clk-mt7981-apmixed.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n\n#include \"clk-gate.h\"\n#include \"clk-mtk.h\"\n#include \"clk-mux.h\"\n#include \"clk-pll.h\"\n\n#include <dt-bindings/clock/mediatek,mt7981-clk.h>\n#include <linux/clk.h>\n\n#define MT7981_PLL_FMAX (2500UL * MHZ)\n#define CON0_MT7981_RST_BAR BIT(27)\n\n#define PLL_xtal(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,       \\\n\t\t _pd_reg, _pd_shift, _tuner_reg, _pcw_reg, _pcw_shift,         \\\n\t\t _div_table, _parent_name)                                     \\\n\t{                                                                      \\\n\t\t.id = _id, .name = _name, .reg = _reg, .pwr_reg = _pwr_reg,    \\\n\t\t.en_mask = _en_mask, .flags = _flags,                          \\\n\t\t.rst_bar_mask = CON0_MT7981_RST_BAR, .fmax = MT7981_PLL_FMAX,  \\\n\t\t.pcwbits = _pcwbits, .pd_reg = _pd_reg, .pd_shift = _pd_shift, \\\n\t\t.tuner_reg = _tuner_reg, .pcw_reg = _pcw_reg,                  \\\n\t\t.pcw_shift = _pcw_shift, .div_table = _div_table,              \\\n\t\t.parent_name = _parent_name,                                   \\\n\t}\n\n#define PLL(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits, _pd_reg,   \\\n\t    _pd_shift, _tuner_reg, _pcw_reg, _pcw_shift)                       \\\n\tPLL_xtal(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,       \\\n\t\t _pd_reg, _pd_shift, _tuner_reg, _pcw_reg, _pcw_shift, NULL,   \\\n\t\t \"clkxtal\")\n\nstatic const struct mtk_pll_data plls[] = {\n\tPLL(CLK_APMIXED_ARMPLL, \"armpll\", 0x0200, 0x020C, 0x00000001, PLL_AO,\n\t    32, 0x0200, 4, 0, 0x0204, 0),\n\tPLL(CLK_APMIXED_NET2PLL, \"net2pll\", 0x0210, 0x021C, 0x00000001, 0, 32,\n\t    0x0210, 4, 0, 0x0214, 0),\n\tPLL(CLK_APMIXED_MMPLL, \"mmpll\", 0x0220, 0x022C, 0x00000001, 0, 32,\n\t    0x0220, 4, 0, 0x0224, 0),\n\tPLL(CLK_APMIXED_SGMPLL, \"sgmpll\", 0x0230, 0x023C, 0x00000001, 0, 32,\n\t    0x0230, 4, 0, 0x0234, 0),\n\tPLL(CLK_APMIXED_WEDMCUPLL, \"wedmcupll\", 0x0240, 0x024C, 0x00000001, 0, 32,\n\t    0x0240, 4, 0, 0x0244, 0),\n\tPLL(CLK_APMIXED_NET1PLL, \"net1pll\", 0x0250, 0x025C, 0x00000001, 0, 32,\n\t    0x0250, 4, 0, 0x0254, 0),\n\tPLL(CLK_APMIXED_MPLL, \"mpll\", 0x0260, 0x0270, 0x00000001, 0, 32,\n\t    0x0260, 4, 0, 0x0264, 0),\n\tPLL(CLK_APMIXED_APLL2, \"apll2\", 0x0278, 0x0288, 0x00000001, 0, 32,\n\t    0x0278, 4, 0, 0x027C, 0),\n};\n\nstatic const struct of_device_id of_match_clk_mt7981_apmixed[] = {\n\t{ .compatible = \"mediatek,mt7981-apmixedsys\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_match_clk_mt7981_apmixed);\n\nstatic int clk_mt7981_apmixed_probe(struct platform_device *pdev)\n{\n\tstruct clk_hw_onecell_data *clk_data;\n\tstruct device_node *node = pdev->dev.of_node;\n\tint r;\n\n\tclk_data = mtk_alloc_clk_data(ARRAY_SIZE(plls));\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tmtk_clk_register_plls(node, plls, ARRAY_SIZE(plls), clk_data);\n\n\tr = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, clk_data);\n\tif (r) {\n\t\tpr_err(\"%s(): could not register clock provider: %d\\n\",\n\t\t       __func__, r);\n\t\tgoto free_apmixed_data;\n\t}\n\treturn r;\n\nfree_apmixed_data:\n\tmtk_free_clk_data(clk_data);\n\treturn r;\n}\n\nstatic struct platform_driver clk_mt7981_apmixed_drv = {\n\t.probe = clk_mt7981_apmixed_probe,\n\t.driver = {\n\t\t.name = \"clk-mt7981-apmixed\",\n\t\t.of_match_table = of_match_clk_mt7981_apmixed,\n\t},\n};\nbuiltin_platform_driver(clk_mt7981_apmixed_drv);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}