{
  "module_name": "clk-pll.c",
  "hash_id": "1ab49f14ffafc12f3ea15928c01a181ef07235c9a678a896bfcb8a300b353989",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mediatek/clk-pll.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/container_of.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n\n#include \"clk-pll.h\"\n\n#define MHZ\t\t\t(1000 * 1000)\n\n#define REG_CON0\t\t0\n#define REG_CON1\t\t4\n\n#define CON0_BASE_EN\t\tBIT(0)\n#define CON0_PWR_ON\t\tBIT(0)\n#define CON0_ISO_EN\t\tBIT(1)\n#define PCW_CHG_MASK\t\tBIT(31)\n\n#define AUDPLL_TUNER_EN\t\tBIT(31)\n\n \n#define INTEGER_BITS\t\t7\n\nint mtk_pll_is_prepared(struct clk_hw *hw)\n{\n\tstruct mtk_clk_pll *pll = to_mtk_clk_pll(hw);\n\n\treturn (readl(pll->en_addr) & BIT(pll->data->pll_en_bit)) != 0;\n}\n\nstatic unsigned long __mtk_pll_recalc_rate(struct mtk_clk_pll *pll, u32 fin,\n\t\tu32 pcw, int postdiv)\n{\n\tint pcwbits = pll->data->pcwbits;\n\tint pcwfbits = 0;\n\tint ibits;\n\tu64 vco;\n\tu8 c = 0;\n\n\t \n\tibits = pll->data->pcwibits ? pll->data->pcwibits : INTEGER_BITS;\n\tif (pcwbits > ibits)\n\t\tpcwfbits = pcwbits - ibits;\n\n\tvco = (u64)fin * pcw;\n\n\tif (pcwfbits && (vco & GENMASK(pcwfbits - 1, 0)))\n\t\tc = 1;\n\n\tvco >>= pcwfbits;\n\n\tif (c)\n\t\tvco++;\n\n\treturn ((unsigned long)vco + postdiv - 1) / postdiv;\n}\n\nstatic void __mtk_pll_tuner_enable(struct mtk_clk_pll *pll)\n{\n\tu32 r;\n\n\tif (pll->tuner_en_addr) {\n\t\tr = readl(pll->tuner_en_addr) | BIT(pll->data->tuner_en_bit);\n\t\twritel(r, pll->tuner_en_addr);\n\t} else if (pll->tuner_addr) {\n\t\tr = readl(pll->tuner_addr) | AUDPLL_TUNER_EN;\n\t\twritel(r, pll->tuner_addr);\n\t}\n}\n\nstatic void __mtk_pll_tuner_disable(struct mtk_clk_pll *pll)\n{\n\tu32 r;\n\n\tif (pll->tuner_en_addr) {\n\t\tr = readl(pll->tuner_en_addr) & ~BIT(pll->data->tuner_en_bit);\n\t\twritel(r, pll->tuner_en_addr);\n\t} else if (pll->tuner_addr) {\n\t\tr = readl(pll->tuner_addr) & ~AUDPLL_TUNER_EN;\n\t\twritel(r, pll->tuner_addr);\n\t}\n}\n\nstatic void mtk_pll_set_rate_regs(struct mtk_clk_pll *pll, u32 pcw,\n\t\tint postdiv)\n{\n\tu32 chg, val;\n\n\t \n\t__mtk_pll_tuner_disable(pll);\n\n\t \n\tval = readl(pll->pd_addr);\n\tval &= ~(POSTDIV_MASK << pll->data->pd_shift);\n\tval |= (ffs(postdiv) - 1) << pll->data->pd_shift;\n\n\t \n\tif (pll->pd_addr != pll->pcw_addr) {\n\t\twritel(val, pll->pd_addr);\n\t\tval = readl(pll->pcw_addr);\n\t}\n\n\t \n\tval &= ~GENMASK(pll->data->pcw_shift + pll->data->pcwbits - 1,\n\t\t\tpll->data->pcw_shift);\n\tval |= pcw << pll->data->pcw_shift;\n\twritel(val, pll->pcw_addr);\n\tchg = readl(pll->pcw_chg_addr) | PCW_CHG_MASK;\n\twritel(chg, pll->pcw_chg_addr);\n\tif (pll->tuner_addr)\n\t\twritel(val + 1, pll->tuner_addr);\n\n\t \n\t__mtk_pll_tuner_enable(pll);\n\n\tudelay(20);\n}\n\n \nvoid mtk_pll_calc_values(struct mtk_clk_pll *pll, u32 *pcw, u32 *postdiv,\n\t\t\t u32 freq, u32 fin)\n{\n\tunsigned long fmin = pll->data->fmin ? pll->data->fmin : (1000 * MHZ);\n\tconst struct mtk_pll_div_table *div_table = pll->data->div_table;\n\tu64 _pcw;\n\tint ibits;\n\tu32 val;\n\n\tif (freq > pll->data->fmax)\n\t\tfreq = pll->data->fmax;\n\n\tif (div_table) {\n\t\tif (freq > div_table[0].freq)\n\t\t\tfreq = div_table[0].freq;\n\n\t\tfor (val = 0; div_table[val + 1].freq != 0; val++) {\n\t\t\tif (freq > div_table[val + 1].freq)\n\t\t\t\tbreak;\n\t\t}\n\t\t*postdiv = 1 << val;\n\t} else {\n\t\tfor (val = 0; val < 5; val++) {\n\t\t\t*postdiv = 1 << val;\n\t\t\tif ((u64)freq * *postdiv >= fmin)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tibits = pll->data->pcwibits ? pll->data->pcwibits : INTEGER_BITS;\n\t_pcw = ((u64)freq << val) << (pll->data->pcwbits - ibits);\n\tdo_div(_pcw, fin);\n\n\t*pcw = (u32)_pcw;\n}\n\nint mtk_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t     unsigned long parent_rate)\n{\n\tstruct mtk_clk_pll *pll = to_mtk_clk_pll(hw);\n\tu32 pcw = 0;\n\tu32 postdiv;\n\n\tmtk_pll_calc_values(pll, &pcw, &postdiv, rate, parent_rate);\n\tmtk_pll_set_rate_regs(pll, pcw, postdiv);\n\n\treturn 0;\n}\n\nunsigned long mtk_pll_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct mtk_clk_pll *pll = to_mtk_clk_pll(hw);\n\tu32 postdiv;\n\tu32 pcw;\n\n\tpostdiv = (readl(pll->pd_addr) >> pll->data->pd_shift) & POSTDIV_MASK;\n\tpostdiv = 1 << postdiv;\n\n\tpcw = readl(pll->pcw_addr) >> pll->data->pcw_shift;\n\tpcw &= GENMASK(pll->data->pcwbits - 1, 0);\n\n\treturn __mtk_pll_recalc_rate(pll, parent_rate, pcw, postdiv);\n}\n\nlong mtk_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\tunsigned long *prate)\n{\n\tstruct mtk_clk_pll *pll = to_mtk_clk_pll(hw);\n\tu32 pcw = 0;\n\tint postdiv;\n\n\tmtk_pll_calc_values(pll, &pcw, &postdiv, rate, *prate);\n\n\treturn __mtk_pll_recalc_rate(pll, *prate, pcw, postdiv);\n}\n\nint mtk_pll_prepare(struct clk_hw *hw)\n{\n\tstruct mtk_clk_pll *pll = to_mtk_clk_pll(hw);\n\tu32 r;\n\n\tr = readl(pll->pwr_addr) | CON0_PWR_ON;\n\twritel(r, pll->pwr_addr);\n\tudelay(1);\n\n\tr = readl(pll->pwr_addr) & ~CON0_ISO_EN;\n\twritel(r, pll->pwr_addr);\n\tudelay(1);\n\n\tr = readl(pll->en_addr) | BIT(pll->data->pll_en_bit);\n\twritel(r, pll->en_addr);\n\n\tif (pll->data->en_mask) {\n\t\tr = readl(pll->base_addr + REG_CON0) | pll->data->en_mask;\n\t\twritel(r, pll->base_addr + REG_CON0);\n\t}\n\n\t__mtk_pll_tuner_enable(pll);\n\n\tudelay(20);\n\n\tif (pll->data->flags & HAVE_RST_BAR) {\n\t\tr = readl(pll->base_addr + REG_CON0);\n\t\tr |= pll->data->rst_bar_mask;\n\t\twritel(r, pll->base_addr + REG_CON0);\n\t}\n\n\treturn 0;\n}\n\nvoid mtk_pll_unprepare(struct clk_hw *hw)\n{\n\tstruct mtk_clk_pll *pll = to_mtk_clk_pll(hw);\n\tu32 r;\n\n\tif (pll->data->flags & HAVE_RST_BAR) {\n\t\tr = readl(pll->base_addr + REG_CON0);\n\t\tr &= ~pll->data->rst_bar_mask;\n\t\twritel(r, pll->base_addr + REG_CON0);\n\t}\n\n\t__mtk_pll_tuner_disable(pll);\n\n\tif (pll->data->en_mask) {\n\t\tr = readl(pll->base_addr + REG_CON0) & ~pll->data->en_mask;\n\t\twritel(r, pll->base_addr + REG_CON0);\n\t}\n\n\tr = readl(pll->en_addr) & ~BIT(pll->data->pll_en_bit);\n\twritel(r, pll->en_addr);\n\n\tr = readl(pll->pwr_addr) | CON0_ISO_EN;\n\twritel(r, pll->pwr_addr);\n\n\tr = readl(pll->pwr_addr) & ~CON0_PWR_ON;\n\twritel(r, pll->pwr_addr);\n}\n\nconst struct clk_ops mtk_pll_ops = {\n\t.is_prepared\t= mtk_pll_is_prepared,\n\t.prepare\t= mtk_pll_prepare,\n\t.unprepare\t= mtk_pll_unprepare,\n\t.recalc_rate\t= mtk_pll_recalc_rate,\n\t.round_rate\t= mtk_pll_round_rate,\n\t.set_rate\t= mtk_pll_set_rate,\n};\n\nstruct clk_hw *mtk_clk_register_pll_ops(struct mtk_clk_pll *pll,\n\t\t\t\t\tconst struct mtk_pll_data *data,\n\t\t\t\t\tvoid __iomem *base,\n\t\t\t\t\tconst struct clk_ops *pll_ops)\n{\n\tstruct clk_init_data init = {};\n\tint ret;\n\tconst char *parent_name = \"clk26m\";\n\n\tpll->base_addr = base + data->reg;\n\tpll->pwr_addr = base + data->pwr_reg;\n\tpll->pd_addr = base + data->pd_reg;\n\tpll->pcw_addr = base + data->pcw_reg;\n\tif (data->pcw_chg_reg)\n\t\tpll->pcw_chg_addr = base + data->pcw_chg_reg;\n\telse\n\t\tpll->pcw_chg_addr = pll->base_addr + REG_CON1;\n\tif (data->tuner_reg)\n\t\tpll->tuner_addr = base + data->tuner_reg;\n\tif (data->tuner_en_reg || data->tuner_en_bit)\n\t\tpll->tuner_en_addr = base + data->tuner_en_reg;\n\tif (data->en_reg)\n\t\tpll->en_addr = base + data->en_reg;\n\telse\n\t\tpll->en_addr = pll->base_addr + REG_CON0;\n\tpll->hw.init = &init;\n\tpll->data = data;\n\n\tinit.name = data->name;\n\tinit.flags = (data->flags & PLL_AO) ? CLK_IS_CRITICAL : 0;\n\tinit.ops = pll_ops;\n\tif (data->parent_name)\n\t\tinit.parent_names = &data->parent_name;\n\telse\n\t\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tret = clk_hw_register(NULL, &pll->hw);\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn &pll->hw;\n}\n\nstruct clk_hw *mtk_clk_register_pll(const struct mtk_pll_data *data,\n\t\t\t\t    void __iomem *base)\n{\n\tstruct mtk_clk_pll *pll;\n\tstruct clk_hw *hw;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thw = mtk_clk_register_pll_ops(pll, data, base, &mtk_pll_ops);\n\tif (IS_ERR(hw))\n\t\tkfree(pll);\n\n\treturn hw;\n}\n\nvoid mtk_clk_unregister_pll(struct clk_hw *hw)\n{\n\tstruct mtk_clk_pll *pll;\n\n\tif (!hw)\n\t\treturn;\n\n\tpll = to_mtk_clk_pll(hw);\n\n\tclk_hw_unregister(hw);\n\tkfree(pll);\n}\n\nint mtk_clk_register_plls(struct device_node *node,\n\t\t\t  const struct mtk_pll_data *plls, int num_plls,\n\t\t\t  struct clk_hw_onecell_data *clk_data)\n{\n\tvoid __iomem *base;\n\tint i;\n\tstruct clk_hw *hw;\n\n\tbase = of_iomap(node, 0);\n\tif (!base) {\n\t\tpr_err(\"%s(): ioremap failed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_plls; i++) {\n\t\tconst struct mtk_pll_data *pll = &plls[i];\n\n\t\tif (!IS_ERR_OR_NULL(clk_data->hws[pll->id])) {\n\t\t\tpr_warn(\"%pOF: Trying to register duplicate clock ID: %d\\n\",\n\t\t\t\tnode, pll->id);\n\t\t\tcontinue;\n\t\t}\n\n\t\thw = mtk_clk_register_pll(pll, base);\n\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"Failed to register clk %s: %pe\\n\", pll->name,\n\t\t\t       hw);\n\t\t\tgoto err;\n\t\t}\n\n\t\tclk_data->hws[pll->id] = hw;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0) {\n\t\tconst struct mtk_pll_data *pll = &plls[i];\n\n\t\tmtk_clk_unregister_pll(clk_data->hws[pll->id]);\n\t\tclk_data->hws[pll->id] = ERR_PTR(-ENOENT);\n\t}\n\n\tiounmap(base);\n\n\treturn PTR_ERR(hw);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_register_plls);\n\n__iomem void *mtk_clk_pll_get_base(struct clk_hw *hw,\n\t\t\t\t   const struct mtk_pll_data *data)\n{\n\tstruct mtk_clk_pll *pll = to_mtk_clk_pll(hw);\n\n\treturn pll->base_addr - data->reg;\n}\n\nvoid mtk_clk_unregister_plls(const struct mtk_pll_data *plls, int num_plls,\n\t\t\t     struct clk_hw_onecell_data *clk_data)\n{\n\t__iomem void *base = NULL;\n\tint i;\n\n\tif (!clk_data)\n\t\treturn;\n\n\tfor (i = num_plls; i > 0; i--) {\n\t\tconst struct mtk_pll_data *pll = &plls[i - 1];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[pll->id]))\n\t\t\tcontinue;\n\n\t\t \n\t\tbase = mtk_clk_pll_get_base(clk_data->hws[pll->id], pll);\n\n\t\tmtk_clk_unregister_pll(clk_data->hws[pll->id]);\n\t\tclk_data->hws[pll->id] = ERR_PTR(-ENOENT);\n\t}\n\n\tiounmap(base);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_unregister_plls);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}