{
  "module_name": "clk-mt8192-apmixedsys.c",
  "hash_id": "95bcfdbe327cd4859f4e64ec4cf7fe399a63ea196526093b38a03a730d8621ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mediatek/clk-mt8192-apmixedsys.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/clock/mt8192-clk.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include \"clk-fhctl.h\"\n#include \"clk-gate.h\"\n#include \"clk-mtk.h\"\n#include \"clk-pll.h\"\n#include \"clk-pllfh.h\"\n\nstatic const struct mtk_gate_regs apmixed_cg_regs = {\n\t.set_ofs = 0x14,\n\t.clr_ofs = 0x14,\n\t.sta_ofs = 0x14,\n};\n\n#define GATE_APMIXED(_id, _name, _parent, _shift)\t\\\n\tGATE_MTK(_id, _name, _parent, &apmixed_cg_regs, _shift, &mtk_clk_gate_ops_no_setclr_inv)\n\nstatic const struct mtk_gate apmixed_clks[] = {\n\tGATE_APMIXED(CLK_APMIXED_MIPID26M, \"mipid26m\", \"clk26m\", 16),\n};\n\n#define MT8192_PLL_FMAX\t\t(3800UL * MHZ)\n#define MT8192_PLL_FMIN\t\t(1500UL * MHZ)\n#define MT8192_INTEGER_BITS\t8\n\n#define PLL(_id, _name, _reg, _pwr_reg, _en_mask, _flags,\t\t\\\n\t\t\t_rst_bar_mask, _pcwbits, _pd_reg, _pd_shift,\t\\\n\t\t\t_tuner_reg, _tuner_en_reg, _tuner_en_bit,\t\\\n\t\t\t_pcw_reg, _pcw_shift, _pcw_chg_reg,\t\t\\\n\t\t\t_en_reg, _pll_en_bit) {\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.reg = _reg,\t\t\t\t\t\t\\\n\t\t.pwr_reg = _pwr_reg,\t\t\t\t\t\\\n\t\t.en_mask = _en_mask,\t\t\t\t\t\\\n\t\t.flags = _flags,\t\t\t\t\t\\\n\t\t.rst_bar_mask = _rst_bar_mask,\t\t\t\t\\\n\t\t.fmax = MT8192_PLL_FMAX,\t\t\t\t\\\n\t\t.fmin = MT8192_PLL_FMIN,\t\t\t\t\\\n\t\t.pcwbits = _pcwbits,\t\t\t\t\t\\\n\t\t.pcwibits = MT8192_INTEGER_BITS,\t\t\t\\\n\t\t.pd_reg = _pd_reg,\t\t\t\t\t\\\n\t\t.pd_shift = _pd_shift,\t\t\t\t\t\\\n\t\t.tuner_reg = _tuner_reg,\t\t\t\t\\\n\t\t.tuner_en_reg = _tuner_en_reg,\t\t\t\t\\\n\t\t.tuner_en_bit = _tuner_en_bit,\t\t\t\t\\\n\t\t.pcw_reg = _pcw_reg,\t\t\t\t\t\\\n\t\t.pcw_shift = _pcw_shift,\t\t\t\t\\\n\t\t.pcw_chg_reg = _pcw_chg_reg,\t\t\t\t\\\n\t\t.en_reg = _en_reg,\t\t\t\t\t\\\n\t\t.pll_en_bit = _pll_en_bit,\t\t\t\t\\\n\t}\n\n#define PLL_B(_id, _name, _reg, _pwr_reg, _en_mask, _flags,\t\t\\\n\t\t\t_rst_bar_mask, _pcwbits, _pd_reg, _pd_shift,\t\\\n\t\t\t_tuner_reg, _tuner_en_reg, _tuner_en_bit,\t\\\n\t\t\t_pcw_reg, _pcw_shift)\t\t\t\t\\\n\t\tPLL(_id, _name, _reg, _pwr_reg, _en_mask, _flags,\t\\\n\t\t\t_rst_bar_mask, _pcwbits, _pd_reg, _pd_shift,\t\\\n\t\t\t_tuner_reg, _tuner_en_reg, _tuner_en_bit,\t\\\n\t\t\t_pcw_reg, _pcw_shift, 0, 0, 0)\n\nstatic const struct mtk_pll_data plls[] = {\n\tPLL_B(CLK_APMIXED_MAINPLL, \"mainpll\", 0x0340, 0x034c, 0xff000000,\n\t      HAVE_RST_BAR, BIT(23), 22, 0x0344, 24, 0, 0, 0, 0x0344, 0),\n\tPLL_B(CLK_APMIXED_UNIVPLL, \"univpll\", 0x0308, 0x0314, 0xff000000,\n\t      HAVE_RST_BAR, BIT(23), 22, 0x030c, 24, 0, 0, 0, 0x030c, 0),\n\tPLL(CLK_APMIXED_USBPLL, \"usbpll\", 0x03c4, 0x03cc, 0x00000000,\n\t    0, 0, 22, 0x03c4, 24, 0, 0, 0, 0x03c4, 0, 0x03c4, 0x03cc, 2),\n\tPLL_B(CLK_APMIXED_MSDCPLL, \"msdcpll\", 0x0350, 0x035c, 0x00000000,\n\t      0, 0, 22, 0x0354, 24, 0, 0, 0, 0x0354, 0),\n\tPLL_B(CLK_APMIXED_MMPLL, \"mmpll\", 0x0360, 0x036c, 0xff000000,\n\t      HAVE_RST_BAR, BIT(23), 22, 0x0364, 24, 0, 0, 0, 0x0364, 0),\n\tPLL_B(CLK_APMIXED_ADSPPLL, \"adsppll\", 0x0370, 0x037c, 0xff000000,\n\t      HAVE_RST_BAR, BIT(23), 22, 0x0374, 24, 0, 0, 0, 0x0374, 0),\n\tPLL_B(CLK_APMIXED_MFGPLL, \"mfgpll\", 0x0268, 0x0274, 0x00000000,\n\t      0, 0, 22, 0x026c, 24, 0, 0, 0, 0x026c, 0),\n\tPLL_B(CLK_APMIXED_TVDPLL, \"tvdpll\", 0x0380, 0x038c, 0x00000000,\n\t      0, 0, 22, 0x0384, 24, 0, 0, 0, 0x0384, 0),\n\tPLL_B(CLK_APMIXED_APLL1, \"apll1\", 0x0318, 0x0328, 0x00000000,\n\t      0, 0, 32, 0x031c, 24, 0x0040, 0x000c, 0, 0x0320, 0),\n\tPLL_B(CLK_APMIXED_APLL2, \"apll2\", 0x032c, 0x033c, 0x00000000,\n\t      0, 0, 32, 0x0330, 24, 0, 0, 0, 0x0334, 0),\n};\n\nenum fh_pll_id {\n\tFH_ARMPLL_LL,\n\tFH_ARMPLL_BL0,\n\tFH_ARMPLL_BL1,\n\tFH_ARMPLL_BL2,\n\tFH_ARMPLL_BL3,\n\tFH_CCIPLL,\n\tFH_MFGPLL,\n\tFH_MEMPLL,\n\tFH_MPLL,\n\tFH_MMPLL,\n\tFH_MAINPLL,\n\tFH_MSDCPLL,\n\tFH_ADSPPLL,\n\tFH_APUPLL,\n\tFH_TVDPLL,\n\tFH_NR_FH,\n};\n\n#define FH(_pllid, _fhid, _offset) {\t\t\t\t\t\\\n\t\t.data = {\t\t\t\t\t\t\\\n\t\t\t.pll_id = _pllid,\t\t\t\t\\\n\t\t\t.fh_id = _fhid,\t\t\t\t\t\\\n\t\t\t.fh_ver = FHCTL_PLLFH_V2,\t\t\t\\\n\t\t\t.fhx_offset = _offset,\t\t\t\t\\\n\t\t\t.dds_mask = GENMASK(21, 0),\t\t\t\\\n\t\t\t.slope0_value = 0x6003c97,\t\t\t\\\n\t\t\t.slope1_value = 0x6003c97,\t\t\t\\\n\t\t\t.sfstrx_en = BIT(2),\t\t\t\t\\\n\t\t\t.frddsx_en = BIT(1),\t\t\t\t\\\n\t\t\t.fhctlx_en = BIT(0),\t\t\t\t\\\n\t\t\t.tgl_org = BIT(31),\t\t\t\t\\\n\t\t\t.dvfs_tri = BIT(31),\t\t\t\t\\\n\t\t\t.pcwchg = BIT(31),\t\t\t\t\\\n\t\t\t.dt_val = 0x0,\t\t\t\t\t\\\n\t\t\t.df_val = 0x9,\t\t\t\t\t\\\n\t\t\t.updnlmt_shft = 16,\t\t\t\t\\\n\t\t\t.msk_frddsx_dys = GENMASK(23, 20),\t\t\\\n\t\t\t.msk_frddsx_dts = GENMASK(19, 16),\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\nstatic struct mtk_pllfh_data pllfhs[] = {\n\tFH(CLK_APMIXED_MFGPLL, FH_MFGPLL, 0xb4),\n\tFH(CLK_APMIXED_MMPLL, FH_MMPLL, 0xf0),\n\tFH(CLK_APMIXED_MAINPLL, FH_MAINPLL, 0x104),\n\tFH(CLK_APMIXED_MSDCPLL, FH_MSDCPLL, 0x118),\n\tFH(CLK_APMIXED_ADSPPLL, FH_ADSPPLL, 0x12c),\n\tFH(CLK_APMIXED_TVDPLL, FH_TVDPLL, 0x154),\n};\n\nstatic const struct of_device_id of_match_clk_mt8192_apmixed[] = {\n\t{ .compatible = \"mediatek,mt8192-apmixedsys\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_match_clk_mt8192_apmixed);\n\nstatic int clk_mt8192_apmixed_probe(struct platform_device *pdev)\n{\n\tstruct clk_hw_onecell_data *clk_data;\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst u8 *fhctl_node = \"mediatek,mt8192-fhctl\";\n\tint r;\n\n\tclk_data = mtk_alloc_clk_data(CLK_APMIXED_NR_CLK);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tfhctl_parse_dt(fhctl_node, pllfhs, ARRAY_SIZE(pllfhs));\n\n\tr = mtk_clk_register_pllfhs(node, plls, ARRAY_SIZE(plls),\n\t\t\t\t    pllfhs, ARRAY_SIZE(pllfhs), clk_data);\n\tif (r)\n\t\tgoto free_clk_data;\n\n\tr = mtk_clk_register_gates(&pdev->dev, node, apmixed_clks,\n\t\t\t\t   ARRAY_SIZE(apmixed_clks), clk_data);\n\tif (r)\n\t\tgoto unregister_plls;\n\n\tr = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, clk_data);\n\tif (r)\n\t\tgoto unregister_gates;\n\n\treturn r;\n\nunregister_gates:\n\tmtk_clk_unregister_gates(apmixed_clks, ARRAY_SIZE(apmixed_clks), clk_data);\nunregister_plls:\n\tmtk_clk_unregister_pllfhs(plls, ARRAY_SIZE(plls), pllfhs,\n\t\t\t\t  ARRAY_SIZE(pllfhs), clk_data);\nfree_clk_data:\n\tmtk_free_clk_data(clk_data);\n\treturn r;\n}\n\nstatic void clk_mt8192_apmixed_remove(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct clk_hw_onecell_data *clk_data = platform_get_drvdata(pdev);\n\n\tof_clk_del_provider(node);\n\tmtk_clk_unregister_gates(apmixed_clks, ARRAY_SIZE(apmixed_clks), clk_data);\n\tmtk_clk_unregister_pllfhs(plls, ARRAY_SIZE(plls), pllfhs,\n\t\t\t\t  ARRAY_SIZE(pllfhs), clk_data);\n\tmtk_free_clk_data(clk_data);\n}\n\nstatic struct platform_driver clk_mt8192_apmixed_drv = {\n\t.driver = {\n\t\t.name = \"clk-mt8192-apmixed\",\n\t\t.of_match_table = of_match_clk_mt8192_apmixed,\n\t},\n\t.probe = clk_mt8192_apmixed_probe,\n\t.remove_new = clk_mt8192_apmixed_remove,\n};\nmodule_platform_driver(clk_mt8192_apmixed_drv);\nMODULE_DESCRIPTION(\"MediaTek MT8192 apmixed clocks driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}