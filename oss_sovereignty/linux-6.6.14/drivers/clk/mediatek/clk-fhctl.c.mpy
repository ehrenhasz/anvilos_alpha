{
  "module_name": "clk-fhctl.c",
  "hash_id": "33c9add89de94a503fb0dc1b4519606f5a79123d9a0ff476497f832fc409334b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mediatek/clk-fhctl.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/iopoll.h>\n\n#include \"clk-mtk.h\"\n#include \"clk-pllfh.h\"\n#include \"clk-fhctl.h\"\n\n#define PERCENT_TO_DDSLMT(dds, percent_m10) \\\n\t((((dds) * (percent_m10)) >> 5) / 100)\n\nstatic const struct fhctl_offset fhctl_offset_v1 = {\n\t.offset_hp_en = 0x0,\n\t.offset_clk_con = 0x4,\n\t.offset_rst_con = 0x8,\n\t.offset_slope0 = 0xc,\n\t.offset_slope1 = 0x10,\n\t.offset_cfg = 0x0,\n\t.offset_updnlmt = 0x4,\n\t.offset_dds = 0x8,\n\t.offset_dvfs = 0xc,\n\t.offset_mon = 0x10,\n};\n\nstatic const struct fhctl_offset fhctl_offset_v2 = {\n\t.offset_hp_en = 0x0,\n\t.offset_clk_con = 0x8,\n\t.offset_rst_con = 0xc,\n\t.offset_slope0 = 0x10,\n\t.offset_slope1 = 0x14,\n\t.offset_cfg = 0x0,\n\t.offset_updnlmt = 0x4,\n\t.offset_dds = 0x8,\n\t.offset_dvfs = 0xc,\n\t.offset_mon = 0x10,\n};\n\nconst struct fhctl_offset *fhctl_get_offset_table(enum fhctl_variant v)\n{\n\tswitch (v) {\n\tcase FHCTL_PLLFH_V1:\n\t\treturn &fhctl_offset_v1;\n\tcase FHCTL_PLLFH_V2:\n\t\treturn &fhctl_offset_v2;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t};\n}\n\nstatic void dump_hw(struct mtk_clk_pll *pll, struct fh_pll_regs *regs,\n\t\t    const struct fh_pll_data *data)\n{\n\tpr_info(\"hp_en<%x>,clk_con<%x>,slope0<%x>,slope1<%x>\\n\",\n\t\treadl(regs->reg_hp_en), readl(regs->reg_clk_con),\n\t\treadl(regs->reg_slope0), readl(regs->reg_slope1));\n\tpr_info(\"cfg<%x>,lmt<%x>,dds<%x>,dvfs<%x>,mon<%x>\\n\",\n\t\treadl(regs->reg_cfg), readl(regs->reg_updnlmt),\n\t\treadl(regs->reg_dds), readl(regs->reg_dvfs),\n\t\treadl(regs->reg_mon));\n\tpr_info(\"pcw<%x>\\n\", readl(pll->pcw_addr));\n}\n\nstatic int fhctl_set_ssc_regs(struct mtk_clk_pll *pll, struct fh_pll_regs *regs,\n\t\t\t      const struct fh_pll_data *data, u32 rate)\n{\n\tu32 updnlmt_val, r;\n\n\twritel((readl(regs->reg_cfg) & ~(data->frddsx_en)), regs->reg_cfg);\n\twritel((readl(regs->reg_cfg) & ~(data->sfstrx_en)), regs->reg_cfg);\n\twritel((readl(regs->reg_cfg) & ~(data->fhctlx_en)), regs->reg_cfg);\n\n\tif (rate > 0) {\n\t\t \n\t\tr = readl(regs->reg_cfg);\n\t\tr &= ~(data->msk_frddsx_dys);\n\t\tr |= (data->df_val << (ffs(data->msk_frddsx_dys) - 1));\n\t\twritel(r, regs->reg_cfg);\n\n\t\tr = readl(regs->reg_cfg);\n\t\tr &= ~(data->msk_frddsx_dts);\n\t\tr |= (data->dt_val << (ffs(data->msk_frddsx_dts) - 1));\n\t\twritel(r, regs->reg_cfg);\n\n\t\twritel((readl(pll->pcw_addr) & data->dds_mask) | data->tgl_org,\n\t\t\tregs->reg_dds);\n\n\t\t \n\t\tupdnlmt_val = PERCENT_TO_DDSLMT((readl(regs->reg_dds) &\n\t\t\t\t\t\t data->dds_mask), rate) <<\n\t\t\t\t\t\t data->updnlmt_shft;\n\n\t\twritel(updnlmt_val, regs->reg_updnlmt);\n\t\twritel(readl(regs->reg_hp_en) | BIT(data->fh_id),\n\t\t       regs->reg_hp_en);\n\t\t \n\t\twritel(readl(regs->reg_cfg) | data->frddsx_en, regs->reg_cfg);\n\t\t \n\t\twritel(readl(regs->reg_cfg) | data->fhctlx_en, regs->reg_cfg);\n\n\t} else {\n\t\t \n\t\twritel(readl(regs->reg_hp_en) & ~BIT(data->fh_id),\n\t\t       regs->reg_hp_en);\n\t\t \n\t\tudelay(30);\n\t}\n\n\treturn 0;\n}\n\nstatic int hopping_hw_flow(struct mtk_clk_pll *pll, struct fh_pll_regs *regs,\n\t\t\t   const struct fh_pll_data *data,\n\t\t\t   struct fh_pll_state *state, unsigned int new_dds)\n{\n\tu32 dds_mask = data->dds_mask;\n\tu32 mon_dds = 0;\n\tu32 con_pcw_tmp;\n\tint ret;\n\n\tif (state->ssc_rate)\n\t\tfhctl_set_ssc_regs(pll, regs, data, 0);\n\n\twritel((readl(pll->pcw_addr) & dds_mask) | data->tgl_org,\n\t\tregs->reg_dds);\n\n\twritel(readl(regs->reg_cfg) | data->sfstrx_en, regs->reg_cfg);\n\twritel(readl(regs->reg_cfg) | data->fhctlx_en, regs->reg_cfg);\n\twritel(data->slope0_value, regs->reg_slope0);\n\twritel(data->slope1_value, regs->reg_slope1);\n\n\twritel(readl(regs->reg_hp_en) | BIT(data->fh_id), regs->reg_hp_en);\n\twritel((new_dds) | (data->dvfs_tri), regs->reg_dvfs);\n\n\t \n\tret = readl_poll_timeout_atomic(regs->reg_mon, mon_dds,\n\t\t\t\t       (mon_dds & dds_mask) == new_dds,\n\t\t\t\t\t10, 1000);\n\tif (ret) {\n\t\tpr_warn(\"%s: FHCTL hopping timeout\\n\", pll->data->name);\n\t\tdump_hw(pll, regs, data);\n\t}\n\n\tcon_pcw_tmp = readl(pll->pcw_addr) & (~dds_mask);\n\tcon_pcw_tmp = (con_pcw_tmp | (readl(regs->reg_mon) & dds_mask) |\n\t\t       data->pcwchg);\n\n\twritel(con_pcw_tmp, pll->pcw_addr);\n\twritel(readl(regs->reg_hp_en) & ~BIT(data->fh_id), regs->reg_hp_en);\n\n\tif (state->ssc_rate)\n\t\tfhctl_set_ssc_regs(pll, regs, data, state->ssc_rate);\n\n\treturn ret;\n}\n\nstatic unsigned int __get_postdiv(struct mtk_clk_pll *pll)\n{\n\tunsigned int regval;\n\n\tregval = readl(pll->pd_addr) >> pll->data->pd_shift;\n\tregval &= POSTDIV_MASK;\n\n\treturn BIT(regval);\n}\n\nstatic void __set_postdiv(struct mtk_clk_pll *pll, unsigned int postdiv)\n{\n\tunsigned int regval;\n\n\tregval = readl(pll->pd_addr);\n\tregval &= ~(POSTDIV_MASK << pll->data->pd_shift);\n\tregval |= (ffs(postdiv) - 1) << pll->data->pd_shift;\n\twritel(regval, pll->pd_addr);\n}\n\nstatic int fhctl_hopping(struct mtk_fh *fh, unsigned int new_dds,\n\t\t\t unsigned int postdiv)\n{\n\tconst struct fh_pll_data *data = &fh->pllfh_data->data;\n\tstruct fh_pll_state *state = &fh->pllfh_data->state;\n\tstruct fh_pll_regs *regs = &fh->regs;\n\tstruct mtk_clk_pll *pll = &fh->clk_pll;\n\tspinlock_t *lock = fh->lock;\n\tunsigned int pll_postdiv;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (postdiv) {\n\t\tpll_postdiv = __get_postdiv(pll);\n\n\t\tif (postdiv > pll_postdiv)\n\t\t\t__set_postdiv(pll, postdiv);\n\t}\n\n\tspin_lock_irqsave(lock, flags);\n\n\tret = hopping_hw_flow(pll, regs, data, state, new_dds);\n\n\tspin_unlock_irqrestore(lock, flags);\n\n\tif (postdiv && postdiv < pll_postdiv)\n\t\t__set_postdiv(pll, postdiv);\n\n\treturn ret;\n}\n\nstatic int fhctl_ssc_enable(struct mtk_fh *fh, u32 rate)\n{\n\tconst struct fh_pll_data *data = &fh->pllfh_data->data;\n\tstruct fh_pll_state *state = &fh->pllfh_data->state;\n\tstruct fh_pll_regs *regs = &fh->regs;\n\tstruct mtk_clk_pll *pll = &fh->clk_pll;\n\tspinlock_t *lock = fh->lock;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(lock, flags);\n\n\tfhctl_set_ssc_regs(pll, regs, data, rate);\n\tstate->ssc_rate = rate;\n\n\tspin_unlock_irqrestore(lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct fh_operation fhctl_ops = {\n\t.hopping = fhctl_hopping,\n\t.ssc_enable = fhctl_ssc_enable,\n};\n\nconst struct fh_operation *fhctl_get_ops(void)\n{\n\treturn &fhctl_ops;\n}\n\nvoid fhctl_hw_init(struct mtk_fh *fh)\n{\n\tconst struct fh_pll_data data = fh->pllfh_data->data;\n\tstruct fh_pll_state state = fh->pllfh_data->state;\n\tstruct fh_pll_regs regs = fh->regs;\n\tu32 val;\n\n\t \n\tval = readl(regs.reg_clk_con) | BIT(data.fh_id);\n\twritel(val, regs.reg_clk_con);\n\n\tval = readl(regs.reg_rst_con) & ~BIT(data.fh_id);\n\twritel(val, regs.reg_rst_con);\n\tval = readl(regs.reg_rst_con) | BIT(data.fh_id);\n\twritel(val, regs.reg_rst_con);\n\n\twritel(0x0, regs.reg_cfg);\n\twritel(0x0, regs.reg_updnlmt);\n\twritel(0x0, regs.reg_dds);\n\n\t \n\tif (state.ssc_rate)\n\t\tfh->ops->ssc_enable(fh, state.ssc_rate);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}