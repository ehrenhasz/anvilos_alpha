{
  "module_name": "reset.c",
  "hash_id": "fdb0942a9d52f655fa7f086cfc1c769ea5e6cb21b5f3c52b82a83ac7333d965a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mediatek/reset.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"reset.h\"\n\nstatic inline struct mtk_clk_rst_data *to_mtk_clk_rst_data(struct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct mtk_clk_rst_data, rcdev);\n}\n\nstatic int mtk_reset_update(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long id, bool deassert)\n{\n\tstruct mtk_clk_rst_data *data = to_mtk_clk_rst_data(rcdev);\n\tunsigned int val = deassert ? 0 : ~0;\n\n\treturn regmap_update_bits(data->regmap,\n\t\t\t\t  data->desc->rst_bank_ofs[id / RST_NR_PER_BANK],\n\t\t\t\t  BIT(id % RST_NR_PER_BANK), val);\n}\n\nstatic int mtk_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t    unsigned long id)\n{\n\treturn mtk_reset_update(rcdev, id, false);\n}\n\nstatic int mtk_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\treturn mtk_reset_update(rcdev, id, true);\n}\n\nstatic int mtk_reset(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tint ret;\n\n\tret = mtk_reset_assert(rcdev, id);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mtk_reset_deassert(rcdev, id);\n}\n\nstatic int mtk_reset_update_set_clr(struct reset_controller_dev *rcdev,\n\t\t\t\t    unsigned long id, bool deassert)\n{\n\tstruct mtk_clk_rst_data *data = to_mtk_clk_rst_data(rcdev);\n\tunsigned int deassert_ofs = deassert ? 0x4 : 0;\n\n\treturn regmap_write(data->regmap,\n\t\t\t    data->desc->rst_bank_ofs[id / RST_NR_PER_BANK] +\n\t\t\t    deassert_ofs,\n\t\t\t    BIT(id % RST_NR_PER_BANK));\n}\n\nstatic int mtk_reset_assert_set_clr(struct reset_controller_dev *rcdev,\n\t\t\t\t    unsigned long id)\n{\n\treturn mtk_reset_update_set_clr(rcdev, id, false);\n}\n\nstatic int mtk_reset_deassert_set_clr(struct reset_controller_dev *rcdev,\n\t\t\t\t      unsigned long id)\n{\n\treturn mtk_reset_update_set_clr(rcdev, id, true);\n}\n\nstatic int mtk_reset_set_clr(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned long id)\n{\n\tint ret;\n\n\tret = mtk_reset_assert_set_clr(rcdev, id);\n\tif (ret)\n\t\treturn ret;\n\treturn mtk_reset_deassert_set_clr(rcdev, id);\n}\n\nstatic const struct reset_control_ops mtk_reset_ops = {\n\t.assert = mtk_reset_assert,\n\t.deassert = mtk_reset_deassert,\n\t.reset = mtk_reset,\n};\n\nstatic const struct reset_control_ops mtk_reset_ops_set_clr = {\n\t.assert = mtk_reset_assert_set_clr,\n\t.deassert = mtk_reset_deassert_set_clr,\n\t.reset = mtk_reset_set_clr,\n};\n\nstatic int reset_xlate(struct reset_controller_dev *rcdev,\n\t\t       const struct of_phandle_args *reset_spec)\n{\n\tstruct mtk_clk_rst_data *data = to_mtk_clk_rst_data(rcdev);\n\n\tif (reset_spec->args[0] >= rcdev->nr_resets ||\n\t    reset_spec->args[0] >= data->desc->rst_idx_map_nr)\n\t\treturn -EINVAL;\n\n\treturn data->desc->rst_idx_map[reset_spec->args[0]];\n}\n\nint mtk_register_reset_controller(struct device_node *np,\n\t\t\t\t  const struct mtk_clk_rst_desc *desc)\n{\n\tstruct regmap *regmap;\n\tconst struct reset_control_ops *rcops = NULL;\n\tstruct mtk_clk_rst_data *data;\n\tint ret;\n\n\tif (!desc) {\n\t\tpr_err(\"mtk clock reset desc is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (desc->version) {\n\tcase MTK_RST_SIMPLE:\n\t\trcops = &mtk_reset_ops;\n\t\tbreak;\n\tcase MTK_RST_SET_CLR:\n\t\trcops = &mtk_reset_ops_set_clr;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown reset version %d\\n\", desc->version);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap = device_node_to_regmap(np);\n\tif (IS_ERR(regmap)) {\n\t\tpr_err(\"Cannot find regmap for %pOF: %pe\\n\", np, regmap);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->desc = desc;\n\tdata->regmap = regmap;\n\tdata->rcdev.owner = THIS_MODULE;\n\tdata->rcdev.ops = rcops;\n\tdata->rcdev.of_node = np;\n\n\tif (data->desc->rst_idx_map_nr > 0) {\n\t\tdata->rcdev.of_reset_n_cells = 1;\n\t\tdata->rcdev.nr_resets = desc->rst_idx_map_nr;\n\t\tdata->rcdev.of_xlate = reset_xlate;\n\t} else {\n\t\tdata->rcdev.nr_resets = desc->rst_bank_nr * RST_NR_PER_BANK;\n\t}\n\n\tret = reset_controller_register(&data->rcdev);\n\tif (ret) {\n\t\tpr_err(\"could not register reset controller: %d\\n\", ret);\n\t\tkfree(data);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint mtk_register_reset_controller_with_dev(struct device *dev,\n\t\t\t\t\t   const struct mtk_clk_rst_desc *desc)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct regmap *regmap;\n\tconst struct reset_control_ops *rcops = NULL;\n\tstruct mtk_clk_rst_data *data;\n\tint ret;\n\n\tif (!desc) {\n\t\tdev_err(dev, \"mtk clock reset desc is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (desc->version) {\n\tcase MTK_RST_SIMPLE:\n\t\trcops = &mtk_reset_ops;\n\t\tbreak;\n\tcase MTK_RST_SET_CLR:\n\t\trcops = &mtk_reset_ops_set_clr;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unknown reset version %d\\n\", desc->version);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap = device_node_to_regmap(np);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"Cannot find regmap %pe\\n\", regmap);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->desc = desc;\n\tdata->regmap = regmap;\n\tdata->rcdev.owner = THIS_MODULE;\n\tdata->rcdev.ops = rcops;\n\tdata->rcdev.of_node = np;\n\tdata->rcdev.dev = dev;\n\n\tif (data->desc->rst_idx_map_nr > 0) {\n\t\tdata->rcdev.of_reset_n_cells = 1;\n\t\tdata->rcdev.nr_resets = desc->rst_idx_map_nr;\n\t\tdata->rcdev.of_xlate = reset_xlate;\n\t} else {\n\t\tdata->rcdev.nr_resets = desc->rst_bank_nr * RST_NR_PER_BANK;\n\t}\n\n\tret = devm_reset_controller_register(dev, &data->rcdev);\n\tif (ret) {\n\t\tdev_err(dev, \"could not register reset controller: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_register_reset_controller_with_dev);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}