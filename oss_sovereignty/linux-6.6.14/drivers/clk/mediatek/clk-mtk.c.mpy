{
  "module_name": "clk-mtk.c",
  "hash_id": "994a6352c542b9f0107b11c04dd871d974ecc52f7e7d7fac83f0299c871730d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mediatek/clk-mtk.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"clk-mtk.h\"\n#include \"clk-gate.h\"\n#include \"clk-mux.h\"\n\nconst struct mtk_gate_regs cg_regs_dummy = { 0, 0, 0 };\nEXPORT_SYMBOL_GPL(cg_regs_dummy);\n\nstatic int mtk_clk_dummy_enable(struct clk_hw *hw)\n{\n\treturn 0;\n}\n\nstatic void mtk_clk_dummy_disable(struct clk_hw *hw) { }\n\nconst struct clk_ops mtk_clk_dummy_ops = {\n\t.enable\t\t= mtk_clk_dummy_enable,\n\t.disable\t= mtk_clk_dummy_disable,\n};\nEXPORT_SYMBOL_GPL(mtk_clk_dummy_ops);\n\nstatic void mtk_init_clk_data(struct clk_hw_onecell_data *clk_data,\n\t\t\t      unsigned int clk_num)\n{\n\tint i;\n\n\tclk_data->num = clk_num;\n\n\tfor (i = 0; i < clk_num; i++)\n\t\tclk_data->hws[i] = ERR_PTR(-ENOENT);\n}\n\nstruct clk_hw_onecell_data *mtk_devm_alloc_clk_data(struct device *dev,\n\t\t\t\t\t\t    unsigned int clk_num)\n{\n\tstruct clk_hw_onecell_data *clk_data;\n\n\tclk_data = devm_kzalloc(dev, struct_size(clk_data, hws, clk_num),\n\t\t\t\tGFP_KERNEL);\n\tif (!clk_data)\n\t\treturn NULL;\n\n\tmtk_init_clk_data(clk_data, clk_num);\n\n\treturn clk_data;\n}\nEXPORT_SYMBOL_GPL(mtk_devm_alloc_clk_data);\n\nstruct clk_hw_onecell_data *mtk_alloc_clk_data(unsigned int clk_num)\n{\n\tstruct clk_hw_onecell_data *clk_data;\n\n\tclk_data = kzalloc(struct_size(clk_data, hws, clk_num), GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn NULL;\n\n\tmtk_init_clk_data(clk_data, clk_num);\n\n\treturn clk_data;\n}\nEXPORT_SYMBOL_GPL(mtk_alloc_clk_data);\n\nvoid mtk_free_clk_data(struct clk_hw_onecell_data *clk_data)\n{\n\tkfree(clk_data);\n}\nEXPORT_SYMBOL_GPL(mtk_free_clk_data);\n\nint mtk_clk_register_fixed_clks(const struct mtk_fixed_clk *clks, int num,\n\t\t\t\tstruct clk_hw_onecell_data *clk_data)\n{\n\tint i;\n\tstruct clk_hw *hw;\n\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num; i++) {\n\t\tconst struct mtk_fixed_clk *rc = &clks[i];\n\n\t\tif (!IS_ERR_OR_NULL(clk_data->hws[rc->id])) {\n\t\t\tpr_warn(\"Trying to register duplicate clock ID: %d\\n\", rc->id);\n\t\t\tcontinue;\n\t\t}\n\n\t\thw = clk_hw_register_fixed_rate(NULL, rc->name, rc->parent, 0,\n\t\t\t\t\t      rc->rate);\n\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"Failed to register clk %s: %pe\\n\", rc->name,\n\t\t\t       hw);\n\t\t\tgoto err;\n\t\t}\n\n\t\tclk_data->hws[rc->id] = hw;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0) {\n\t\tconst struct mtk_fixed_clk *rc = &clks[i];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[rc->id]))\n\t\t\tcontinue;\n\n\t\tclk_hw_unregister_fixed_rate(clk_data->hws[rc->id]);\n\t\tclk_data->hws[rc->id] = ERR_PTR(-ENOENT);\n\t}\n\n\treturn PTR_ERR(hw);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_register_fixed_clks);\n\nvoid mtk_clk_unregister_fixed_clks(const struct mtk_fixed_clk *clks, int num,\n\t\t\t\t   struct clk_hw_onecell_data *clk_data)\n{\n\tint i;\n\n\tif (!clk_data)\n\t\treturn;\n\n\tfor (i = num; i > 0; i--) {\n\t\tconst struct mtk_fixed_clk *rc = &clks[i - 1];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[rc->id]))\n\t\t\tcontinue;\n\n\t\tclk_hw_unregister_fixed_rate(clk_data->hws[rc->id]);\n\t\tclk_data->hws[rc->id] = ERR_PTR(-ENOENT);\n\t}\n}\nEXPORT_SYMBOL_GPL(mtk_clk_unregister_fixed_clks);\n\nint mtk_clk_register_factors(const struct mtk_fixed_factor *clks, int num,\n\t\t\t     struct clk_hw_onecell_data *clk_data)\n{\n\tint i;\n\tstruct clk_hw *hw;\n\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num; i++) {\n\t\tconst struct mtk_fixed_factor *ff = &clks[i];\n\n\t\tif (!IS_ERR_OR_NULL(clk_data->hws[ff->id])) {\n\t\t\tpr_warn(\"Trying to register duplicate clock ID: %d\\n\", ff->id);\n\t\t\tcontinue;\n\t\t}\n\n\t\thw = clk_hw_register_fixed_factor(NULL, ff->name, ff->parent_name,\n\t\t\t\tff->flags, ff->mult, ff->div);\n\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"Failed to register clk %s: %pe\\n\", ff->name,\n\t\t\t       hw);\n\t\t\tgoto err;\n\t\t}\n\n\t\tclk_data->hws[ff->id] = hw;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0) {\n\t\tconst struct mtk_fixed_factor *ff = &clks[i];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[ff->id]))\n\t\t\tcontinue;\n\n\t\tclk_hw_unregister_fixed_factor(clk_data->hws[ff->id]);\n\t\tclk_data->hws[ff->id] = ERR_PTR(-ENOENT);\n\t}\n\n\treturn PTR_ERR(hw);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_register_factors);\n\nvoid mtk_clk_unregister_factors(const struct mtk_fixed_factor *clks, int num,\n\t\t\t\tstruct clk_hw_onecell_data *clk_data)\n{\n\tint i;\n\n\tif (!clk_data)\n\t\treturn;\n\n\tfor (i = num; i > 0; i--) {\n\t\tconst struct mtk_fixed_factor *ff = &clks[i - 1];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[ff->id]))\n\t\t\tcontinue;\n\n\t\tclk_hw_unregister_fixed_factor(clk_data->hws[ff->id]);\n\t\tclk_data->hws[ff->id] = ERR_PTR(-ENOENT);\n\t}\n}\nEXPORT_SYMBOL_GPL(mtk_clk_unregister_factors);\n\nstatic struct clk_hw *mtk_clk_register_composite(struct device *dev,\n\t\tconst struct mtk_composite *mc, void __iomem *base, spinlock_t *lock)\n{\n\tstruct clk_hw *hw;\n\tstruct clk_mux *mux = NULL;\n\tstruct clk_gate *gate = NULL;\n\tstruct clk_divider *div = NULL;\n\tstruct clk_hw *mux_hw = NULL, *gate_hw = NULL, *div_hw = NULL;\n\tconst struct clk_ops *mux_ops = NULL, *gate_ops = NULL, *div_ops = NULL;\n\tconst char * const *parent_names;\n\tconst char *parent;\n\tint num_parents;\n\tint ret;\n\n\tif (mc->mux_shift >= 0) {\n\t\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\t\tif (!mux)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tmux->reg = base + mc->mux_reg;\n\t\tmux->mask = BIT(mc->mux_width) - 1;\n\t\tmux->shift = mc->mux_shift;\n\t\tmux->lock = lock;\n\t\tmux->flags = mc->mux_flags;\n\t\tmux_hw = &mux->hw;\n\t\tmux_ops = &clk_mux_ops;\n\n\t\tparent_names = mc->parent_names;\n\t\tnum_parents = mc->num_parents;\n\t} else {\n\t\tparent = mc->parent;\n\t\tparent_names = &parent;\n\t\tnum_parents = 1;\n\t}\n\n\tif (mc->gate_shift >= 0) {\n\t\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\t\tif (!gate) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tgate->reg = base + mc->gate_reg;\n\t\tgate->bit_idx = mc->gate_shift;\n\t\tgate->flags = CLK_GATE_SET_TO_DISABLE;\n\t\tgate->lock = lock;\n\n\t\tgate_hw = &gate->hw;\n\t\tgate_ops = &clk_gate_ops;\n\t}\n\n\tif (mc->divider_shift >= 0) {\n\t\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\t\tif (!div) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tdiv->reg = base + mc->divider_reg;\n\t\tdiv->shift = mc->divider_shift;\n\t\tdiv->width = mc->divider_width;\n\t\tdiv->lock = lock;\n\n\t\tdiv_hw = &div->hw;\n\t\tdiv_ops = &clk_divider_ops;\n\t}\n\n\thw = clk_hw_register_composite(dev, mc->name, parent_names, num_parents,\n\t\tmux_hw, mux_ops,\n\t\tdiv_hw, div_ops,\n\t\tgate_hw, gate_ops,\n\t\tmc->flags);\n\n\tif (IS_ERR(hw)) {\n\t\tret = PTR_ERR(hw);\n\t\tgoto err_out;\n\t}\n\n\treturn hw;\nerr_out:\n\tkfree(div);\n\tkfree(gate);\n\tkfree(mux);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic void mtk_clk_unregister_composite(struct clk_hw *hw)\n{\n\tstruct clk_composite *composite;\n\tstruct clk_mux *mux = NULL;\n\tstruct clk_gate *gate = NULL;\n\tstruct clk_divider *div = NULL;\n\n\tif (!hw)\n\t\treturn;\n\n\tcomposite = to_clk_composite(hw);\n\tif (composite->mux_hw)\n\t\tmux = to_clk_mux(composite->mux_hw);\n\tif (composite->gate_hw)\n\t\tgate = to_clk_gate(composite->gate_hw);\n\tif (composite->rate_hw)\n\t\tdiv = to_clk_divider(composite->rate_hw);\n\n\tclk_hw_unregister_composite(hw);\n\tkfree(div);\n\tkfree(gate);\n\tkfree(mux);\n}\n\nint mtk_clk_register_composites(struct device *dev,\n\t\t\t\tconst struct mtk_composite *mcs, int num,\n\t\t\t\tvoid __iomem *base, spinlock_t *lock,\n\t\t\t\tstruct clk_hw_onecell_data *clk_data)\n{\n\tstruct clk_hw *hw;\n\tint i;\n\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num; i++) {\n\t\tconst struct mtk_composite *mc = &mcs[i];\n\n\t\tif (!IS_ERR_OR_NULL(clk_data->hws[mc->id])) {\n\t\t\tpr_warn(\"Trying to register duplicate clock ID: %d\\n\",\n\t\t\t\tmc->id);\n\t\t\tcontinue;\n\t\t}\n\n\t\thw = mtk_clk_register_composite(dev, mc, base, lock);\n\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"Failed to register clk %s: %pe\\n\", mc->name,\n\t\t\t       hw);\n\t\t\tgoto err;\n\t\t}\n\n\t\tclk_data->hws[mc->id] = hw;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0) {\n\t\tconst struct mtk_composite *mc = &mcs[i];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[mcs->id]))\n\t\t\tcontinue;\n\n\t\tmtk_clk_unregister_composite(clk_data->hws[mc->id]);\n\t\tclk_data->hws[mc->id] = ERR_PTR(-ENOENT);\n\t}\n\n\treturn PTR_ERR(hw);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_register_composites);\n\nvoid mtk_clk_unregister_composites(const struct mtk_composite *mcs, int num,\n\t\t\t\t   struct clk_hw_onecell_data *clk_data)\n{\n\tint i;\n\n\tif (!clk_data)\n\t\treturn;\n\n\tfor (i = num; i > 0; i--) {\n\t\tconst struct mtk_composite *mc = &mcs[i - 1];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[mc->id]))\n\t\t\tcontinue;\n\n\t\tmtk_clk_unregister_composite(clk_data->hws[mc->id]);\n\t\tclk_data->hws[mc->id] = ERR_PTR(-ENOENT);\n\t}\n}\nEXPORT_SYMBOL_GPL(mtk_clk_unregister_composites);\n\nint mtk_clk_register_dividers(struct device *dev,\n\t\t\t      const struct mtk_clk_divider *mcds, int num,\n\t\t\t      void __iomem *base, spinlock_t *lock,\n\t\t\t      struct clk_hw_onecell_data *clk_data)\n{\n\tstruct clk_hw *hw;\n\tint i;\n\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i <  num; i++) {\n\t\tconst struct mtk_clk_divider *mcd = &mcds[i];\n\n\t\tif (!IS_ERR_OR_NULL(clk_data->hws[mcd->id])) {\n\t\t\tpr_warn(\"Trying to register duplicate clock ID: %d\\n\",\n\t\t\t\tmcd->id);\n\t\t\tcontinue;\n\t\t}\n\n\t\thw = clk_hw_register_divider(dev, mcd->name, mcd->parent_name,\n\t\t\tmcd->flags, base +  mcd->div_reg, mcd->div_shift,\n\t\t\tmcd->div_width, mcd->clk_divider_flags, lock);\n\n\t\tif (IS_ERR(hw)) {\n\t\t\tpr_err(\"Failed to register clk %s: %pe\\n\", mcd->name,\n\t\t\t       hw);\n\t\t\tgoto err;\n\t\t}\n\n\t\tclk_data->hws[mcd->id] = hw;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0) {\n\t\tconst struct mtk_clk_divider *mcd = &mcds[i];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[mcd->id]))\n\t\t\tcontinue;\n\n\t\tclk_hw_unregister_divider(clk_data->hws[mcd->id]);\n\t\tclk_data->hws[mcd->id] = ERR_PTR(-ENOENT);\n\t}\n\n\treturn PTR_ERR(hw);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_register_dividers);\n\nvoid mtk_clk_unregister_dividers(const struct mtk_clk_divider *mcds, int num,\n\t\t\t\t struct clk_hw_onecell_data *clk_data)\n{\n\tint i;\n\n\tif (!clk_data)\n\t\treturn;\n\n\tfor (i = num; i > 0; i--) {\n\t\tconst struct mtk_clk_divider *mcd = &mcds[i - 1];\n\n\t\tif (IS_ERR_OR_NULL(clk_data->hws[mcd->id]))\n\t\t\tcontinue;\n\n\t\tclk_hw_unregister_divider(clk_data->hws[mcd->id]);\n\t\tclk_data->hws[mcd->id] = ERR_PTR(-ENOENT);\n\t}\n}\nEXPORT_SYMBOL_GPL(mtk_clk_unregister_dividers);\n\nstatic int __mtk_clk_simple_probe(struct platform_device *pdev,\n\t\t\t\t  struct device_node *node)\n{\n\tconst struct platform_device_id *id;\n\tconst struct mtk_clk_desc *mcd;\n\tstruct clk_hw_onecell_data *clk_data;\n\tvoid __iomem *base = NULL;\n\tint num_clks, r;\n\n\tmcd = device_get_match_data(&pdev->dev);\n\tif (!mcd) {\n\t\t \n\t\tid = platform_get_device_id(pdev);\n\t\tif (id)\n\t\t\tmcd = (const struct mtk_clk_desc *)id->driver_data;\n\n\t\tif (!mcd)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mcd->composite_clks || mcd->divider_clks) {\n\t\tif (!mcd->shared_io)\n\t\t\tbase = devm_platform_ioremap_resource(pdev, 0);\n\t\telse\n\t\t\tbase = of_iomap(node, 0);\n\n\t\tif (IS_ERR_OR_NULL(base))\n\t\t\treturn IS_ERR(base) ? PTR_ERR(base) : -ENOMEM;\n\t}\n\n\t \n\tnum_clks = mcd->num_clks + mcd->num_composite_clks;\n\tnum_clks += mcd->num_fixed_clks + mcd->num_factor_clks;\n\tnum_clks += mcd->num_mux_clks + mcd->num_divider_clks;\n\n\tclk_data = mtk_alloc_clk_data(num_clks);\n\tif (!clk_data) {\n\t\tr = -ENOMEM;\n\t\tgoto free_base;\n\t}\n\n\tif (mcd->fixed_clks) {\n\t\tr = mtk_clk_register_fixed_clks(mcd->fixed_clks,\n\t\t\t\t\t\tmcd->num_fixed_clks, clk_data);\n\t\tif (r)\n\t\t\tgoto free_data;\n\t}\n\n\tif (mcd->factor_clks) {\n\t\tr = mtk_clk_register_factors(mcd->factor_clks,\n\t\t\t\t\t     mcd->num_factor_clks, clk_data);\n\t\tif (r)\n\t\t\tgoto unregister_fixed_clks;\n\t}\n\n\tif (mcd->mux_clks) {\n\t\tr = mtk_clk_register_muxes(&pdev->dev, mcd->mux_clks,\n\t\t\t\t\t   mcd->num_mux_clks, node,\n\t\t\t\t\t   mcd->clk_lock, clk_data);\n\t\tif (r)\n\t\t\tgoto unregister_factors;\n\t}\n\n\tif (mcd->composite_clks) {\n\t\t \n\t\tr = mtk_clk_register_composites(&pdev->dev,\n\t\t\t\t\t\tmcd->composite_clks,\n\t\t\t\t\t\tmcd->num_composite_clks,\n\t\t\t\t\t\tbase, mcd->clk_lock, clk_data);\n\t\tif (r)\n\t\t\tgoto unregister_muxes;\n\t}\n\n\tif (mcd->divider_clks) {\n\t\tr = mtk_clk_register_dividers(&pdev->dev,\n\t\t\t\t\t      mcd->divider_clks,\n\t\t\t\t\t      mcd->num_divider_clks,\n\t\t\t\t\t      base, mcd->clk_lock, clk_data);\n\t\tif (r)\n\t\t\tgoto unregister_composites;\n\t}\n\n\tif (mcd->clks) {\n\t\tr = mtk_clk_register_gates(&pdev->dev, node, mcd->clks,\n\t\t\t\t\t   mcd->num_clks, clk_data);\n\t\tif (r)\n\t\t\tgoto unregister_dividers;\n\t}\n\n\tif (mcd->clk_notifier_func) {\n\t\tstruct clk *mfg_mux = clk_data->hws[mcd->mfg_clk_idx]->clk;\n\n\t\tr = mcd->clk_notifier_func(&pdev->dev, mfg_mux);\n\t\tif (r)\n\t\t\tgoto unregister_clks;\n\t}\n\n\tr = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, clk_data);\n\tif (r)\n\t\tgoto unregister_clks;\n\n\tplatform_set_drvdata(pdev, clk_data);\n\n\tif (mcd->rst_desc) {\n\t\tr = mtk_register_reset_controller_with_dev(&pdev->dev,\n\t\t\t\t\t\t\t   mcd->rst_desc);\n\t\tif (r)\n\t\t\tgoto unregister_clks;\n\t}\n\n\treturn r;\n\nunregister_clks:\n\tif (mcd->clks)\n\t\tmtk_clk_unregister_gates(mcd->clks, mcd->num_clks, clk_data);\nunregister_dividers:\n\tif (mcd->divider_clks)\n\t\tmtk_clk_unregister_dividers(mcd->divider_clks,\n\t\t\t\t\t    mcd->num_divider_clks, clk_data);\nunregister_composites:\n\tif (mcd->composite_clks)\n\t\tmtk_clk_unregister_composites(mcd->composite_clks,\n\t\t\t\t\t      mcd->num_composite_clks, clk_data);\nunregister_muxes:\n\tif (mcd->mux_clks)\n\t\tmtk_clk_unregister_muxes(mcd->mux_clks,\n\t\t\t\t\t mcd->num_mux_clks, clk_data);\nunregister_factors:\n\tif (mcd->factor_clks)\n\t\tmtk_clk_unregister_factors(mcd->factor_clks,\n\t\t\t\t\t   mcd->num_factor_clks, clk_data);\nunregister_fixed_clks:\n\tif (mcd->fixed_clks)\n\t\tmtk_clk_unregister_fixed_clks(mcd->fixed_clks,\n\t\t\t\t\t      mcd->num_fixed_clks, clk_data);\nfree_data:\n\tmtk_free_clk_data(clk_data);\nfree_base:\n\tif (mcd->shared_io && base)\n\t\tiounmap(base);\n\treturn r;\n}\n\nstatic void __mtk_clk_simple_remove(struct platform_device *pdev,\n\t\t\t\t   struct device_node *node)\n{\n\tstruct clk_hw_onecell_data *clk_data = platform_get_drvdata(pdev);\n\tconst struct mtk_clk_desc *mcd = device_get_match_data(&pdev->dev);\n\n\tof_clk_del_provider(node);\n\tif (mcd->clks)\n\t\tmtk_clk_unregister_gates(mcd->clks, mcd->num_clks, clk_data);\n\tif (mcd->divider_clks)\n\t\tmtk_clk_unregister_dividers(mcd->divider_clks,\n\t\t\t\t\t    mcd->num_divider_clks, clk_data);\n\tif (mcd->composite_clks)\n\t\tmtk_clk_unregister_composites(mcd->composite_clks,\n\t\t\t\t\t      mcd->num_composite_clks, clk_data);\n\tif (mcd->mux_clks)\n\t\tmtk_clk_unregister_muxes(mcd->mux_clks,\n\t\t\t\t\t mcd->num_mux_clks, clk_data);\n\tif (mcd->factor_clks)\n\t\tmtk_clk_unregister_factors(mcd->factor_clks,\n\t\t\t\t\t   mcd->num_factor_clks, clk_data);\n\tif (mcd->fixed_clks)\n\t\tmtk_clk_unregister_fixed_clks(mcd->fixed_clks,\n\t\t\t\t\t      mcd->num_fixed_clks, clk_data);\n\tmtk_free_clk_data(clk_data);\n}\n\nint mtk_clk_pdev_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->parent->of_node;\n\n\treturn __mtk_clk_simple_probe(pdev, node);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_pdev_probe);\n\nint mtk_clk_simple_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\n\treturn __mtk_clk_simple_probe(pdev, node);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_simple_probe);\n\nvoid mtk_clk_pdev_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->parent->of_node;\n\n\t__mtk_clk_simple_remove(pdev, node);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_pdev_remove);\n\nvoid mtk_clk_simple_remove(struct platform_device *pdev)\n{\n\t__mtk_clk_simple_remove(pdev, pdev->dev.of_node);\n}\nEXPORT_SYMBOL_GPL(mtk_clk_simple_remove);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}