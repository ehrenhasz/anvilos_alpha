{
  "module_name": "clkdev.c",
  "hash_id": "91f21ae4dd8844c2d11a357a45cceedc163fed39b6acfea17ca803dde163ddae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clkdev.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/of.h>\n\n#include \"clk.h\"\n\nstatic LIST_HEAD(clocks);\nstatic DEFINE_MUTEX(clocks_mutex);\n\n \nstatic struct clk_lookup *clk_find(const char *dev_id, const char *con_id)\n{\n\tstruct clk_lookup *p, *cl = NULL;\n\tint match, best_found = 0, best_possible = 0;\n\n\tif (dev_id)\n\t\tbest_possible += 2;\n\tif (con_id)\n\t\tbest_possible += 1;\n\n\tlockdep_assert_held(&clocks_mutex);\n\n\tlist_for_each_entry(p, &clocks, node) {\n\t\tmatch = 0;\n\t\tif (p->dev_id) {\n\t\t\tif (!dev_id || strcmp(p->dev_id, dev_id))\n\t\t\t\tcontinue;\n\t\t\tmatch += 2;\n\t\t}\n\t\tif (p->con_id) {\n\t\t\tif (!con_id || strcmp(p->con_id, con_id))\n\t\t\t\tcontinue;\n\t\t\tmatch += 1;\n\t\t}\n\n\t\tif (match > best_found) {\n\t\t\tcl = p;\n\t\t\tif (match != best_possible)\n\t\t\t\tbest_found = match;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn cl;\n}\n\nstruct clk_hw *clk_find_hw(const char *dev_id, const char *con_id)\n{\n\tstruct clk_lookup *cl;\n\tstruct clk_hw *hw = ERR_PTR(-ENOENT);\n\n\tmutex_lock(&clocks_mutex);\n\tcl = clk_find(dev_id, con_id);\n\tif (cl)\n\t\thw = cl->clk_hw;\n\tmutex_unlock(&clocks_mutex);\n\n\treturn hw;\n}\n\nstatic struct clk *__clk_get_sys(struct device *dev, const char *dev_id,\n\t\t\t\t const char *con_id)\n{\n\tstruct clk_hw *hw = clk_find_hw(dev_id, con_id);\n\n\treturn clk_hw_create_clk(dev, hw, dev_id, con_id);\n}\n\nstruct clk *clk_get_sys(const char *dev_id, const char *con_id)\n{\n\treturn __clk_get_sys(NULL, dev_id, con_id);\n}\nEXPORT_SYMBOL(clk_get_sys);\n\nstruct clk *clk_get(struct device *dev, const char *con_id)\n{\n\tconst char *dev_id = dev ? dev_name(dev) : NULL;\n\tstruct clk_hw *hw;\n\n\tif (dev && dev->of_node) {\n\t\thw = of_clk_get_hw(dev->of_node, 0, con_id);\n\t\tif (!IS_ERR(hw) || PTR_ERR(hw) == -EPROBE_DEFER)\n\t\t\treturn clk_hw_create_clk(dev, hw, dev_id, con_id);\n\t}\n\n\treturn __clk_get_sys(dev, dev_id, con_id);\n}\nEXPORT_SYMBOL(clk_get);\n\nvoid clk_put(struct clk *clk)\n{\n\t__clk_put(clk);\n}\nEXPORT_SYMBOL(clk_put);\n\nstatic void __clkdev_add(struct clk_lookup *cl)\n{\n\tmutex_lock(&clocks_mutex);\n\tlist_add_tail(&cl->node, &clocks);\n\tmutex_unlock(&clocks_mutex);\n}\n\nvoid clkdev_add(struct clk_lookup *cl)\n{\n\tif (!cl->clk_hw)\n\t\tcl->clk_hw = __clk_get_hw(cl->clk);\n\t__clkdev_add(cl);\n}\nEXPORT_SYMBOL(clkdev_add);\n\nvoid clkdev_add_table(struct clk_lookup *cl, size_t num)\n{\n\tmutex_lock(&clocks_mutex);\n\twhile (num--) {\n\t\tcl->clk_hw = __clk_get_hw(cl->clk);\n\t\tlist_add_tail(&cl->node, &clocks);\n\t\tcl++;\n\t}\n\tmutex_unlock(&clocks_mutex);\n}\n\n#define MAX_DEV_ID\t20\n#define MAX_CON_ID\t16\n\nstruct clk_lookup_alloc {\n\tstruct clk_lookup cl;\n\tchar\tdev_id[MAX_DEV_ID];\n\tchar\tcon_id[MAX_CON_ID];\n};\n\nstatic struct clk_lookup * __ref\nvclkdev_alloc(struct clk_hw *hw, const char *con_id, const char *dev_fmt,\n\tva_list ap)\n{\n\tstruct clk_lookup_alloc *cla;\n\n\tcla = kzalloc(sizeof(*cla), GFP_KERNEL);\n\tif (!cla)\n\t\treturn NULL;\n\n\tcla->cl.clk_hw = hw;\n\tif (con_id) {\n\t\tstrscpy(cla->con_id, con_id, sizeof(cla->con_id));\n\t\tcla->cl.con_id = cla->con_id;\n\t}\n\n\tif (dev_fmt) {\n\t\tvscnprintf(cla->dev_id, sizeof(cla->dev_id), dev_fmt, ap);\n\t\tcla->cl.dev_id = cla->dev_id;\n\t}\n\n\treturn &cla->cl;\n}\n\nstatic struct clk_lookup *\nvclkdev_create(struct clk_hw *hw, const char *con_id, const char *dev_fmt,\n\tva_list ap)\n{\n\tstruct clk_lookup *cl;\n\n\tcl = vclkdev_alloc(hw, con_id, dev_fmt, ap);\n\tif (cl)\n\t\t__clkdev_add(cl);\n\n\treturn cl;\n}\n\n \nstruct clk_lookup *clkdev_create(struct clk *clk, const char *con_id,\n\tconst char *dev_fmt, ...)\n{\n\tstruct clk_lookup *cl;\n\tva_list ap;\n\n\tva_start(ap, dev_fmt);\n\tcl = vclkdev_create(__clk_get_hw(clk), con_id, dev_fmt, ap);\n\tva_end(ap);\n\n\treturn cl;\n}\nEXPORT_SYMBOL_GPL(clkdev_create);\n\n \nstruct clk_lookup *clkdev_hw_create(struct clk_hw *hw, const char *con_id,\n\tconst char *dev_fmt, ...)\n{\n\tstruct clk_lookup *cl;\n\tva_list ap;\n\n\tva_start(ap, dev_fmt);\n\tcl = vclkdev_create(hw, con_id, dev_fmt, ap);\n\tva_end(ap);\n\n\treturn cl;\n}\nEXPORT_SYMBOL_GPL(clkdev_hw_create);\n\nint clk_add_alias(const char *alias, const char *alias_dev_name,\n\tconst char *con_id, struct device *dev)\n{\n\tstruct clk *r = clk_get(dev, con_id);\n\tstruct clk_lookup *l;\n\n\tif (IS_ERR(r))\n\t\treturn PTR_ERR(r);\n\n\tl = clkdev_create(r, alias, alias_dev_name ? \"%s\" : NULL,\n\t\t\t  alias_dev_name);\n\tclk_put(r);\n\n\treturn l ? 0 : -ENODEV;\n}\nEXPORT_SYMBOL(clk_add_alias);\n\n \nvoid clkdev_drop(struct clk_lookup *cl)\n{\n\tmutex_lock(&clocks_mutex);\n\tlist_del(&cl->node);\n\tmutex_unlock(&clocks_mutex);\n\tkfree(cl);\n}\nEXPORT_SYMBOL(clkdev_drop);\n\nstatic struct clk_lookup *__clk_register_clkdev(struct clk_hw *hw,\n\t\t\t\t\t\tconst char *con_id,\n\t\t\t\t\t\tconst char *dev_id, ...)\n{\n\tstruct clk_lookup *cl;\n\tva_list ap;\n\n\tva_start(ap, dev_id);\n\tcl = vclkdev_create(hw, con_id, dev_id, ap);\n\tva_end(ap);\n\n\treturn cl;\n}\n\nstatic int do_clk_register_clkdev(struct clk_hw *hw,\n\tstruct clk_lookup **cl, const char *con_id, const char *dev_id)\n{\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\t \n\tif (dev_id)\n\t\t*cl = __clk_register_clkdev(hw, con_id, \"%s\", dev_id);\n\telse\n\t\t*cl = __clk_register_clkdev(hw, con_id, NULL);\n\n\treturn *cl ? 0 : -ENOMEM;\n}\n\n \nint clk_register_clkdev(struct clk *clk, const char *con_id,\n\tconst char *dev_id)\n{\n\tstruct clk_lookup *cl;\n\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\treturn do_clk_register_clkdev(__clk_get_hw(clk), &cl, con_id,\n\t\t\t\t\t      dev_id);\n}\nEXPORT_SYMBOL(clk_register_clkdev);\n\n \nint clk_hw_register_clkdev(struct clk_hw *hw, const char *con_id,\n\tconst char *dev_id)\n{\n\tstruct clk_lookup *cl;\n\n\treturn do_clk_register_clkdev(hw, &cl, con_id, dev_id);\n}\nEXPORT_SYMBOL(clk_hw_register_clkdev);\n\nstatic void devm_clkdev_release(void *res)\n{\n\tclkdev_drop(res);\n}\n\n \nint devm_clk_hw_register_clkdev(struct device *dev, struct clk_hw *hw,\n\t\t\t\tconst char *con_id, const char *dev_id)\n{\n\tstruct clk_lookup *cl;\n\tint rval;\n\n\trval = do_clk_register_clkdev(hw, &cl, con_id, dev_id);\n\tif (rval)\n\t\treturn rval;\n\n\treturn devm_add_action_or_reset(dev, devm_clkdev_release, cl);\n}\nEXPORT_SYMBOL(devm_clk_hw_register_clkdev);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}