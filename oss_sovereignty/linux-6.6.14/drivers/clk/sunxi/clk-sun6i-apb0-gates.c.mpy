{
  "module_name": "clk-sun6i-apb0-gates.c",
  "hash_id": "4e1f6e9a0e06ad3d14caf224325a22bcded42477739ab1957c2e35e9226be8d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi/clk-sun6i-apb0-gates.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#define SUN6I_APB0_GATES_MAX_SIZE\t32\n\nstruct gates_data {\n\tDECLARE_BITMAP(mask, SUN6I_APB0_GATES_MAX_SIZE);\n};\n\nstatic const struct gates_data sun6i_a31_apb0_gates __initconst = {\n\t.mask = {0x7F},\n};\n\nstatic const struct gates_data sun8i_a23_apb0_gates __initconst = {\n\t.mask = {0x5D},\n};\n\nstatic const struct of_device_id sun6i_a31_apb0_gates_clk_dt_ids[] = {\n\t{ .compatible = \"allwinner,sun6i-a31-apb0-gates-clk\", .data = &sun6i_a31_apb0_gates },\n\t{ .compatible = \"allwinner,sun8i-a23-apb0-gates-clk\", .data = &sun8i_a23_apb0_gates },\n\t{   }\n};\n\nstatic int sun6i_a31_apb0_gates_clk_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct clk_onecell_data *clk_data;\n\tconst struct gates_data *data;\n\tconst char *clk_parent;\n\tconst char *clk_name;\n\tvoid __iomem *reg;\n\tint ngates;\n\tint i;\n\tint j = 0;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\treg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tclk_parent = of_clk_get_parent_name(np, 0);\n\tif (!clk_parent)\n\t\treturn -EINVAL;\n\n\tclk_data = devm_kzalloc(&pdev->dev, sizeof(struct clk_onecell_data),\n\t\t\t\tGFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\t \n\tngates = find_last_bit(data->mask, SUN6I_APB0_GATES_MAX_SIZE);\n\tclk_data->clks = devm_kcalloc(&pdev->dev, (ngates + 1),\n\t\t\t\t      sizeof(struct clk *), GFP_KERNEL);\n\tif (!clk_data->clks)\n\t\treturn -ENOMEM;\n\n\tfor_each_set_bit(i, data->mask, SUN6I_APB0_GATES_MAX_SIZE) {\n\t\tof_property_read_string_index(np, \"clock-output-names\",\n\t\t\t\t\t      j, &clk_name);\n\n\t\tclk_data->clks[i] = clk_register_gate(&pdev->dev, clk_name,\n\t\t\t\t\t\t      clk_parent, 0, reg, i,\n\t\t\t\t\t\t      0, NULL);\n\t\tWARN_ON(IS_ERR(clk_data->clks[i]));\n\n\t\tj++;\n\t}\n\n\tclk_data->clk_num = ngates + 1;\n\n\treturn of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);\n}\n\nstatic struct platform_driver sun6i_a31_apb0_gates_clk_driver = {\n\t.driver = {\n\t\t.name = \"sun6i-a31-apb0-gates-clk\",\n\t\t.of_match_table = sun6i_a31_apb0_gates_clk_dt_ids,\n\t},\n\t.probe = sun6i_a31_apb0_gates_clk_probe,\n};\nbuiltin_platform_driver(sun6i_a31_apb0_gates_clk_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}