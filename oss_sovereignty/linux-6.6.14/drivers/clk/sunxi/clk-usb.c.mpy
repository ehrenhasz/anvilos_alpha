{
  "module_name": "clk-usb.c",
  "hash_id": "e6a1610f74c3c38d95b0d72ac0f6ba624fd1fb5a7c5d573be3dee1a25addf074",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi/clk-usb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n\n \n\nstruct usb_reset_data {\n\tvoid __iomem\t\t\t*reg;\n\tspinlock_t\t\t\t*lock;\n\tstruct clk\t\t\t*clk;\n\tstruct reset_controller_dev\trcdev;\n};\n\nstatic int sunxi_usb_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct usb_reset_data *data = container_of(rcdev,\n\t\t\t\t\t\t   struct usb_reset_data,\n\t\t\t\t\t\t   rcdev);\n\tunsigned long flags;\n\tu32 reg;\n\n\tclk_prepare_enable(data->clk);\n\tspin_lock_irqsave(data->lock, flags);\n\n\treg = readl(data->reg);\n\twritel(reg & ~BIT(id), data->reg);\n\n\tspin_unlock_irqrestore(data->lock, flags);\n\tclk_disable_unprepare(data->clk);\n\n\treturn 0;\n}\n\nstatic int sunxi_usb_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\tstruct usb_reset_data *data = container_of(rcdev,\n\t\t\t\t\t\t     struct usb_reset_data,\n\t\t\t\t\t\t     rcdev);\n\tunsigned long flags;\n\tu32 reg;\n\n\tclk_prepare_enable(data->clk);\n\tspin_lock_irqsave(data->lock, flags);\n\n\treg = readl(data->reg);\n\twritel(reg | BIT(id), data->reg);\n\n\tspin_unlock_irqrestore(data->lock, flags);\n\tclk_disable_unprepare(data->clk);\n\n\treturn 0;\n}\n\nstatic const struct reset_control_ops sunxi_usb_reset_ops = {\n\t.assert\t\t= sunxi_usb_reset_assert,\n\t.deassert\t= sunxi_usb_reset_deassert,\n};\n\n \n\n#define SUNXI_USB_MAX_SIZE 32\n\nstruct usb_clk_data {\n\tu32 clk_mask;\n\tu32 reset_mask;\n\tbool reset_needs_clk;\n};\n\nstatic void __init sunxi_usb_clk_setup(struct device_node *node,\n\t\t\t\t       const struct usb_clk_data *data,\n\t\t\t\t       spinlock_t *lock)\n{\n\tstruct clk_onecell_data *clk_data;\n\tstruct usb_reset_data *reset_data;\n\tconst char *clk_parent;\n\tconst char *clk_name;\n\tvoid __iomem *reg;\n\tint qty;\n\tint i = 0;\n\tint j = 0;\n\n\treg = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(reg))\n\t\treturn;\n\n\tclk_parent = of_clk_get_parent_name(node, 0);\n\tif (!clk_parent)\n\t\treturn;\n\n\t \n\tqty = find_last_bit((unsigned long *)&data->clk_mask,\n\t\t\t    SUNXI_USB_MAX_SIZE);\n\n\tclk_data = kmalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn;\n\n\tclk_data->clks = kcalloc(qty + 1, sizeof(struct clk *), GFP_KERNEL);\n\tif (!clk_data->clks) {\n\t\tkfree(clk_data);\n\t\treturn;\n\t}\n\n\tfor_each_set_bit(i, (unsigned long *)&data->clk_mask,\n\t\t\t SUNXI_USB_MAX_SIZE) {\n\t\tof_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t      j, &clk_name);\n\t\tclk_data->clks[i] = clk_register_gate(NULL, clk_name,\n\t\t\t\t\t\t      clk_parent, 0,\n\t\t\t\t\t\t      reg, i, 0, lock);\n\t\tWARN_ON(IS_ERR(clk_data->clks[i]));\n\n\t\tj++;\n\t}\n\n\t \n\tclk_data->clk_num = i;\n\n\tof_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\n\n\t \n\tif (data->reset_mask == 0)\n\t\treturn;\n\n\treset_data = kzalloc(sizeof(*reset_data), GFP_KERNEL);\n\tif (!reset_data)\n\t\treturn;\n\n\tif (data->reset_needs_clk) {\n\t\treset_data->clk = of_clk_get(node, 0);\n\t\tif (IS_ERR(reset_data->clk)) {\n\t\t\tpr_err(\"Could not get clock for reset controls\\n\");\n\t\t\tkfree(reset_data);\n\t\t\treturn;\n\t\t}\n\t}\n\n\treset_data->reg = reg;\n\treset_data->lock = lock;\n\treset_data->rcdev.nr_resets = __fls(data->reset_mask) + 1;\n\treset_data->rcdev.ops = &sunxi_usb_reset_ops;\n\treset_data->rcdev.of_node = node;\n\treset_controller_register(&reset_data->rcdev);\n}\n\nstatic const struct usb_clk_data sun4i_a10_usb_clk_data __initconst = {\n\t.clk_mask = BIT(8) | BIT(7) | BIT(6),\n\t.reset_mask = BIT(2) | BIT(1) | BIT(0),\n};\n\nstatic DEFINE_SPINLOCK(sun4i_a10_usb_lock);\n\nstatic void __init sun4i_a10_usb_setup(struct device_node *node)\n{\n\tsunxi_usb_clk_setup(node, &sun4i_a10_usb_clk_data, &sun4i_a10_usb_lock);\n}\nCLK_OF_DECLARE(sun4i_a10_usb, \"allwinner,sun4i-a10-usb-clk\", sun4i_a10_usb_setup);\n\nstatic const struct usb_clk_data sun5i_a13_usb_clk_data __initconst = {\n\t.clk_mask = BIT(8) | BIT(6),\n\t.reset_mask = BIT(1) | BIT(0),\n};\n\nstatic void __init sun5i_a13_usb_setup(struct device_node *node)\n{\n\tsunxi_usb_clk_setup(node, &sun5i_a13_usb_clk_data, &sun4i_a10_usb_lock);\n}\nCLK_OF_DECLARE(sun5i_a13_usb, \"allwinner,sun5i-a13-usb-clk\", sun5i_a13_usb_setup);\n\nstatic const struct usb_clk_data sun6i_a31_usb_clk_data __initconst = {\n\t.clk_mask = BIT(18) | BIT(17) | BIT(16) | BIT(10) | BIT(9) | BIT(8),\n\t.reset_mask = BIT(2) | BIT(1) | BIT(0),\n};\n\nstatic void __init sun6i_a31_usb_setup(struct device_node *node)\n{\n\tsunxi_usb_clk_setup(node, &sun6i_a31_usb_clk_data, &sun4i_a10_usb_lock);\n}\nCLK_OF_DECLARE(sun6i_a31_usb, \"allwinner,sun6i-a31-usb-clk\", sun6i_a31_usb_setup);\n\nstatic const struct usb_clk_data sun8i_a23_usb_clk_data __initconst = {\n\t.clk_mask = BIT(16) | BIT(11) | BIT(10) | BIT(9) | BIT(8),\n\t.reset_mask = BIT(2) | BIT(1) | BIT(0),\n};\n\nstatic void __init sun8i_a23_usb_setup(struct device_node *node)\n{\n\tsunxi_usb_clk_setup(node, &sun8i_a23_usb_clk_data, &sun4i_a10_usb_lock);\n}\nCLK_OF_DECLARE(sun8i_a23_usb, \"allwinner,sun8i-a23-usb-clk\", sun8i_a23_usb_setup);\n\nstatic const struct usb_clk_data sun8i_h3_usb_clk_data __initconst = {\n\t.clk_mask =  BIT(19) | BIT(18) | BIT(17) | BIT(16) |\n\t\t     BIT(11) | BIT(10) | BIT(9) | BIT(8),\n\t.reset_mask = BIT(3) | BIT(2) | BIT(1) | BIT(0),\n};\n\nstatic void __init sun8i_h3_usb_setup(struct device_node *node)\n{\n\tsunxi_usb_clk_setup(node, &sun8i_h3_usb_clk_data, &sun4i_a10_usb_lock);\n}\nCLK_OF_DECLARE(sun8i_h3_usb, \"allwinner,sun8i-h3-usb-clk\", sun8i_h3_usb_setup);\n\nstatic const struct usb_clk_data sun9i_a80_usb_mod_data __initconst = {\n\t.clk_mask = BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2) | BIT(1),\n\t.reset_mask = BIT(19) | BIT(18) | BIT(17),\n\t.reset_needs_clk = 1,\n};\n\nstatic DEFINE_SPINLOCK(a80_usb_mod_lock);\n\nstatic void __init sun9i_a80_usb_mod_setup(struct device_node *node)\n{\n\tsunxi_usb_clk_setup(node, &sun9i_a80_usb_mod_data, &a80_usb_mod_lock);\n}\nCLK_OF_DECLARE(sun9i_a80_usb_mod, \"allwinner,sun9i-a80-usb-mod-clk\", sun9i_a80_usb_mod_setup);\n\nstatic const struct usb_clk_data sun9i_a80_usb_phy_data __initconst = {\n\t.clk_mask = BIT(10) | BIT(5) | BIT(4) | BIT(3) | BIT(2) | BIT(1),\n\t.reset_mask = BIT(21) | BIT(20) | BIT(19) | BIT(18) | BIT(17),\n\t.reset_needs_clk = 1,\n};\n\nstatic DEFINE_SPINLOCK(a80_usb_phy_lock);\n\nstatic void __init sun9i_a80_usb_phy_setup(struct device_node *node)\n{\n\tsunxi_usb_clk_setup(node, &sun9i_a80_usb_phy_data, &a80_usb_phy_lock);\n}\nCLK_OF_DECLARE(sun9i_a80_usb_phy, \"allwinner,sun9i-a80-usb-phy-clk\", sun9i_a80_usb_phy_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}