{
  "module_name": "clk-a10-ve.c",
  "hash_id": "523adebbf89b6fd111300d8ca895cb6f6eb534f57010e200c4a20952de48e358",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi/clk-a10-ve.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\nstatic DEFINE_SPINLOCK(ve_lock);\n\n#define SUN4I_VE_ENABLE\t\t31\n#define SUN4I_VE_DIVIDER_SHIFT\t16\n#define SUN4I_VE_DIVIDER_WIDTH\t3\n#define SUN4I_VE_RESET\t\t0\n\n \n\nstruct ve_reset_data {\n\tvoid __iomem\t\t\t*reg;\n\tspinlock_t\t\t\t*lock;\n\tstruct reset_controller_dev\trcdev;\n};\n\nstatic int sunxi_ve_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t\t unsigned long id)\n{\n\tstruct ve_reset_data *data = container_of(rcdev,\n\t\t\t\t\t\t  struct ve_reset_data,\n\t\t\t\t\t\t  rcdev);\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(data->lock, flags);\n\n\treg = readl(data->reg);\n\twritel(reg & ~BIT(SUN4I_VE_RESET), data->reg);\n\n\tspin_unlock_irqrestore(data->lock, flags);\n\n\treturn 0;\n}\n\nstatic int sunxi_ve_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t   unsigned long id)\n{\n\tstruct ve_reset_data *data = container_of(rcdev,\n\t\t\t\t\t\t  struct ve_reset_data,\n\t\t\t\t\t\t  rcdev);\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(data->lock, flags);\n\n\treg = readl(data->reg);\n\twritel(reg | BIT(SUN4I_VE_RESET), data->reg);\n\n\tspin_unlock_irqrestore(data->lock, flags);\n\n\treturn 0;\n}\n\nstatic int sunxi_ve_of_xlate(struct reset_controller_dev *rcdev,\n\t\t\t     const struct of_phandle_args *reset_spec)\n{\n\tif (WARN_ON(reset_spec->args_count != 0))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct reset_control_ops sunxi_ve_reset_ops = {\n\t.assert\t\t= sunxi_ve_reset_assert,\n\t.deassert\t= sunxi_ve_reset_deassert,\n};\n\nstatic void __init sun4i_ve_clk_setup(struct device_node *node)\n{\n\tstruct clk *clk;\n\tstruct clk_divider *div;\n\tstruct clk_gate *gate;\n\tstruct ve_reset_data *reset_data;\n\tconst char *parent;\n\tconst char *clk_name = node->name;\n\tvoid __iomem *reg;\n\tint err;\n\n\treg = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(reg))\n\t\treturn;\n\n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\tgoto err_unmap;\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\tgoto err_free_div;\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\tparent = of_clk_get_parent_name(node, 0);\n\n\tgate->reg = reg;\n\tgate->bit_idx = SUN4I_VE_ENABLE;\n\tgate->lock = &ve_lock;\n\n\tdiv->reg = reg;\n\tdiv->shift = SUN4I_VE_DIVIDER_SHIFT;\n\tdiv->width = SUN4I_VE_DIVIDER_WIDTH;\n\tdiv->lock = &ve_lock;\n\n\tclk = clk_register_composite(NULL, clk_name, &parent, 1,\n\t\t\t\t     NULL, NULL,\n\t\t\t\t     &div->hw, &clk_divider_ops,\n\t\t\t\t     &gate->hw, &clk_gate_ops,\n\t\t\t\t     CLK_SET_RATE_PARENT);\n\tif (IS_ERR(clk))\n\t\tgoto err_free_gate;\n\n\terr = of_clk_add_provider(node, of_clk_src_simple_get, clk);\n\tif (err)\n\t\tgoto err_unregister_clk;\n\n\treset_data = kzalloc(sizeof(*reset_data), GFP_KERNEL);\n\tif (!reset_data)\n\t\tgoto err_del_provider;\n\n\treset_data->reg = reg;\n\treset_data->lock = &ve_lock;\n\treset_data->rcdev.nr_resets = 1;\n\treset_data->rcdev.ops = &sunxi_ve_reset_ops;\n\treset_data->rcdev.of_node = node;\n\treset_data->rcdev.of_xlate = sunxi_ve_of_xlate;\n\treset_data->rcdev.of_reset_n_cells = 0;\n\terr = reset_controller_register(&reset_data->rcdev);\n\tif (err)\n\t\tgoto err_free_reset;\n\n\treturn;\n\nerr_free_reset:\n\tkfree(reset_data);\nerr_del_provider:\n\tof_clk_del_provider(node);\nerr_unregister_clk:\n\tclk_unregister(clk);\nerr_free_gate:\n\tkfree(gate);\nerr_free_div:\n\tkfree(div);\nerr_unmap:\n\tiounmap(reg);\n}\nCLK_OF_DECLARE(sun4i_ve, \"allwinner,sun4i-a10-ve-clk\",\n\t       sun4i_ve_clk_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}