{
  "module_name": "clk-sun9i-cpus.c",
  "hash_id": "d0ab1e4906ea59d5cafdf9d99adea8d5bb5d3467f17b97760e393fa9c82cda84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi/clk-sun9i-cpus.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\nstatic DEFINE_SPINLOCK(sun9i_a80_cpus_lock);\n\n \n\n#define SUN9I_CPUS_MAX_PARENTS\t\t4\n#define SUN9I_CPUS_MUX_PARENT_PLL4\t3\n#define SUN9I_CPUS_MUX_SHIFT\t\t16\n#define SUN9I_CPUS_MUX_MASK\t\tGENMASK(17, 16)\n#define SUN9I_CPUS_MUX_GET_PARENT(reg)\t((reg & SUN9I_CPUS_MUX_MASK) >> \\\n\t\t\t\t\t\tSUN9I_CPUS_MUX_SHIFT)\n\n#define SUN9I_CPUS_DIV_SHIFT\t\t4\n#define SUN9I_CPUS_DIV_MASK\t\tGENMASK(5, 4)\n#define SUN9I_CPUS_DIV_GET(reg)\t\t((reg & SUN9I_CPUS_DIV_MASK) >> \\\n\t\t\t\t\t\tSUN9I_CPUS_DIV_SHIFT)\n#define SUN9I_CPUS_DIV_SET(reg, div)\t((reg & ~SUN9I_CPUS_DIV_MASK) | \\\n\t\t\t\t\t\t(div << SUN9I_CPUS_DIV_SHIFT))\n#define SUN9I_CPUS_PLL4_DIV_SHIFT\t8\n#define SUN9I_CPUS_PLL4_DIV_MASK\tGENMASK(12, 8)\n#define SUN9I_CPUS_PLL4_DIV_GET(reg)\t((reg & SUN9I_CPUS_PLL4_DIV_MASK) >> \\\n\t\t\t\t\t\tSUN9I_CPUS_PLL4_DIV_SHIFT)\n#define SUN9I_CPUS_PLL4_DIV_SET(reg, div) ((reg & ~SUN9I_CPUS_PLL4_DIV_MASK) | \\\n\t\t\t\t\t\t(div << SUN9I_CPUS_PLL4_DIV_SHIFT))\n\nstruct sun9i_a80_cpus_clk {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n};\n\n#define to_sun9i_a80_cpus_clk(_hw) container_of(_hw, struct sun9i_a80_cpus_clk, hw)\n\nstatic unsigned long sun9i_a80_cpus_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct sun9i_a80_cpus_clk *cpus = to_sun9i_a80_cpus_clk(hw);\n\tunsigned long rate;\n\tu32 reg;\n\n\t \n\treg = readl(cpus->reg);\n\n\t \n\tif (SUN9I_CPUS_MUX_GET_PARENT(reg) == SUN9I_CPUS_MUX_PARENT_PLL4)\n\t\tparent_rate /= SUN9I_CPUS_PLL4_DIV_GET(reg) + 1;\n\n\t \n\trate = parent_rate / (SUN9I_CPUS_DIV_GET(reg) + 1);\n\n\treturn rate;\n}\n\nstatic long sun9i_a80_cpus_clk_round(unsigned long rate, u8 *divp, u8 *pre_divp,\n\t\t\t\t     u8 parent, unsigned long parent_rate)\n{\n\tu8 div, pre_div = 1;\n\n\t \n\tif (parent_rate && rate > parent_rate)\n\t\trate = parent_rate;\n\n\tdiv = DIV_ROUND_UP(parent_rate, rate);\n\n\t \n\tif (parent == SUN9I_CPUS_MUX_PARENT_PLL4 && div > 4) {\n\t\t \n\t\tif (div < 32) {\n\t\t\tpre_div = div;\n\t\t\tdiv = 1;\n\t\t} else if (div < 64) {\n\t\t\tpre_div = DIV_ROUND_UP(div, 2);\n\t\t\tdiv = 2;\n\t\t} else if (div < 96) {\n\t\t\tpre_div = DIV_ROUND_UP(div, 3);\n\t\t\tdiv = 3;\n\t\t} else {\n\t\t\tpre_div = DIV_ROUND_UP(div, 4);\n\t\t\tdiv = 4;\n\t\t}\n\t}\n\n\t \n\tif (divp) {\n\t\t*divp = div - 1;\n\t\t*pre_divp = pre_div - 1;\n\t}\n\n\treturn parent_rate / pre_div / div;\n}\n\nstatic int sun9i_a80_cpus_clk_determine_rate(struct clk_hw *clk,\n\t\t\t\t\t     struct clk_rate_request *req)\n{\n\tstruct clk_hw *parent, *best_parent = NULL;\n\tint i, num_parents;\n\tunsigned long parent_rate, best = 0, child_rate, best_child_rate = 0;\n\tunsigned long rate = req->rate;\n\n\t \n\tnum_parents = clk_hw_get_num_parents(clk);\n\tfor (i = 0; i < num_parents; i++) {\n\t\tparent = clk_hw_get_parent_by_index(clk, i);\n\t\tif (!parent)\n\t\t\tcontinue;\n\t\tif (clk_hw_get_flags(clk) & CLK_SET_RATE_PARENT)\n\t\t\tparent_rate = clk_hw_round_rate(parent, rate);\n\t\telse\n\t\t\tparent_rate = clk_hw_get_rate(parent);\n\n\t\tchild_rate = sun9i_a80_cpus_clk_round(rate, NULL, NULL, i,\n\t\t\t\t\t\t      parent_rate);\n\n\t\tif (child_rate <= rate && child_rate > best_child_rate) {\n\t\t\tbest_parent = parent;\n\t\t\tbest = parent_rate;\n\t\t\tbest_child_rate = child_rate;\n\t\t}\n\t}\n\n\tif (!best_parent)\n\t\treturn -EINVAL;\n\n\treq->best_parent_hw = best_parent;\n\treq->best_parent_rate = best;\n\treq->rate = best_child_rate;\n\n\treturn 0;\n}\n\nstatic int sun9i_a80_cpus_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct sun9i_a80_cpus_clk *cpus = to_sun9i_a80_cpus_clk(hw);\n\tunsigned long flags;\n\tu8 div, pre_div, parent;\n\tu32 reg;\n\n\tspin_lock_irqsave(&sun9i_a80_cpus_lock, flags);\n\n\treg = readl(cpus->reg);\n\n\t \n\tparent = SUN9I_CPUS_MUX_GET_PARENT(reg);\n\tsun9i_a80_cpus_clk_round(rate, &div, &pre_div, parent, parent_rate);\n\n\treg = SUN9I_CPUS_DIV_SET(reg, div);\n\treg = SUN9I_CPUS_PLL4_DIV_SET(reg, pre_div);\n\twritel(reg, cpus->reg);\n\n\tspin_unlock_irqrestore(&sun9i_a80_cpus_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops sun9i_a80_cpus_clk_ops = {\n\t.determine_rate\t= sun9i_a80_cpus_clk_determine_rate,\n\t.recalc_rate\t= sun9i_a80_cpus_clk_recalc_rate,\n\t.set_rate\t= sun9i_a80_cpus_clk_set_rate,\n};\n\nstatic void sun9i_a80_cpus_setup(struct device_node *node)\n{\n\tconst char *clk_name = node->name;\n\tconst char *parents[SUN9I_CPUS_MAX_PARENTS];\n\tstruct resource res;\n\tstruct sun9i_a80_cpus_clk *cpus;\n\tstruct clk_mux *mux;\n\tstruct clk *clk;\n\tint ret;\n\n\tcpus = kzalloc(sizeof(*cpus), GFP_KERNEL);\n\tif (!cpus)\n\t\treturn;\n\n\tcpus->reg = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(cpus->reg))\n\t\tgoto err_free_cpus;\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\n\t \n\tret = of_clk_parent_fill(node, parents, SUN9I_CPUS_MAX_PARENTS);\n\n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\tgoto err_unmap;\n\n\t \n\tmux->reg = cpus->reg;\n\tmux->shift = SUN9I_CPUS_MUX_SHIFT;\n\t \n\tmux->mask = SUN9I_CPUS_MUX_MASK >> SUN9I_CPUS_MUX_SHIFT;\n\tmux->lock = &sun9i_a80_cpus_lock;\n\n\tclk = clk_register_composite(NULL, clk_name, parents, ret,\n\t\t\t\t     &mux->hw, &clk_mux_ops,\n\t\t\t\t     &cpus->hw, &sun9i_a80_cpus_clk_ops,\n\t\t\t\t     NULL, NULL, 0);\n\tif (IS_ERR(clk))\n\t\tgoto err_free_mux;\n\n\tret = of_clk_add_provider(node, of_clk_src_simple_get, clk);\n\tif (ret)\n\t\tgoto err_unregister;\n\n\treturn;\n\nerr_unregister:\n\tclk_unregister(clk);\nerr_free_mux:\n\tkfree(mux);\nerr_unmap:\n\tiounmap(cpus->reg);\n\tof_address_to_resource(node, 0, &res);\n\trelease_mem_region(res.start, resource_size(&res));\nerr_free_cpus:\n\tkfree(cpus);\n}\nCLK_OF_DECLARE(sun9i_a80_cpus, \"allwinner,sun9i-a80-cpus-clk\",\n\t       sun9i_a80_cpus_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}