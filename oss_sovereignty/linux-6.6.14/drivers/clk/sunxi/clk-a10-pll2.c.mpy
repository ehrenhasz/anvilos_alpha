{
  "module_name": "clk-a10-pll2.c",
  "hash_id": "4a03ddbbdda8d7eb09e5b70501f42567c96ee59c500ae9f1adbb9778300a15ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi/clk-a10-pll2.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/clock/sun4i-a10-pll2.h>\n\n#define SUN4I_PLL2_ENABLE\t\t31\n\n#define SUN4I_PLL2_PRE_DIV_SHIFT\t0\n#define SUN4I_PLL2_PRE_DIV_WIDTH\t5\n#define SUN4I_PLL2_PRE_DIV_MASK\t\tGENMASK(SUN4I_PLL2_PRE_DIV_WIDTH - 1, 0)\n\n#define SUN4I_PLL2_N_SHIFT\t\t8\n#define SUN4I_PLL2_N_WIDTH\t\t7\n#define SUN4I_PLL2_N_MASK\t\tGENMASK(SUN4I_PLL2_N_WIDTH - 1, 0)\n\n#define SUN4I_PLL2_POST_DIV_SHIFT\t26\n#define SUN4I_PLL2_POST_DIV_WIDTH\t4\n#define SUN4I_PLL2_POST_DIV_MASK\tGENMASK(SUN4I_PLL2_POST_DIV_WIDTH - 1, 0)\n\n#define SUN4I_PLL2_POST_DIV_VALUE\t4\n\n#define SUN4I_PLL2_OUTPUTS\t\t4\n\nstatic DEFINE_SPINLOCK(sun4i_a10_pll2_lock);\n\nstatic void __init sun4i_pll2_setup(struct device_node *node,\n\t\t\t\t    int post_div_offset)\n{\n\tconst char *clk_name = node->name, *parent;\n\tstruct clk **clks, *base_clk, *prediv_clk;\n\tstruct clk_onecell_data *clk_data;\n\tstruct clk_multiplier *mult;\n\tstruct clk_gate *gate;\n\tvoid __iomem *reg;\n\tu32 val;\n\n\treg = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(reg))\n\t\treturn;\n\n\tclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\n\tif (!clk_data)\n\t\tgoto err_unmap;\n\n\tclks = kcalloc(SUN4I_PLL2_OUTPUTS, sizeof(struct clk *), GFP_KERNEL);\n\tif (!clks)\n\t\tgoto err_free_data;\n\n\tparent = of_clk_get_parent_name(node, 0);\n\tprediv_clk = clk_register_divider(NULL, \"pll2-prediv\",\n\t\t\t\t\t  parent, 0, reg,\n\t\t\t\t\t  SUN4I_PLL2_PRE_DIV_SHIFT,\n\t\t\t\t\t  SUN4I_PLL2_PRE_DIV_WIDTH,\n\t\t\t\t\t  CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\n\t\t\t\t\t  &sun4i_a10_pll2_lock);\n\tif (IS_ERR(prediv_clk)) {\n\t\tpr_err(\"Couldn't register the prediv clock\\n\");\n\t\tgoto err_free_array;\n\t}\n\n\t \n\tgate = kzalloc(sizeof(struct clk_gate), GFP_KERNEL);\n\tif (!gate)\n\t\tgoto err_unregister_prediv;\n\n\tgate->reg = reg;\n\tgate->bit_idx = SUN4I_PLL2_ENABLE;\n\tgate->lock = &sun4i_a10_pll2_lock;\n\n\t \n\tmult = kzalloc(sizeof(struct clk_multiplier), GFP_KERNEL);\n\tif (!mult)\n\t\tgoto err_free_gate;\n\n\tmult->reg = reg;\n\tmult->shift = SUN4I_PLL2_N_SHIFT;\n\tmult->width = 7;\n\tmult->flags = CLK_MULTIPLIER_ZERO_BYPASS |\n\t\t\tCLK_MULTIPLIER_ROUND_CLOSEST;\n\tmult->lock = &sun4i_a10_pll2_lock;\n\n\tparent = __clk_get_name(prediv_clk);\n\tbase_clk = clk_register_composite(NULL, \"pll2-base\",\n\t\t\t\t\t  &parent, 1,\n\t\t\t\t\t  NULL, NULL,\n\t\t\t\t\t  &mult->hw, &clk_multiplier_ops,\n\t\t\t\t\t  &gate->hw, &clk_gate_ops,\n\t\t\t\t\t  CLK_SET_RATE_PARENT);\n\tif (IS_ERR(base_clk)) {\n\t\tpr_err(\"Couldn't register the base multiplier clock\\n\");\n\t\tgoto err_free_multiplier;\n\t}\n\n\tparent = __clk_get_name(base_clk);\n\n\t \n\tval = readl(reg);\n\tval &= ~(SUN4I_PLL2_POST_DIV_MASK << SUN4I_PLL2_POST_DIV_SHIFT);\n\tval |= (SUN4I_PLL2_POST_DIV_VALUE - post_div_offset) << SUN4I_PLL2_POST_DIV_SHIFT;\n\twritel(val, reg);\n\n\tof_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t      SUN4I_A10_PLL2_1X, &clk_name);\n\tclks[SUN4I_A10_PLL2_1X] = clk_register_fixed_factor(NULL, clk_name,\n\t\t\t\t\t\t\t    parent,\n\t\t\t\t\t\t\t    CLK_SET_RATE_PARENT,\n\t\t\t\t\t\t\t    1,\n\t\t\t\t\t\t\t    SUN4I_PLL2_POST_DIV_VALUE);\n\tWARN_ON(IS_ERR(clks[SUN4I_A10_PLL2_1X]));\n\n\t \n\tof_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t      SUN4I_A10_PLL2_2X, &clk_name);\n\tclks[SUN4I_A10_PLL2_2X] = clk_register_fixed_factor(NULL, clk_name,\n\t\t\t\t\t\t\t    parent,\n\t\t\t\t\t\t\t    CLK_SET_RATE_PARENT,\n\t\t\t\t\t\t\t    1, 2);\n\tWARN_ON(IS_ERR(clks[SUN4I_A10_PLL2_2X]));\n\n\t \n\tof_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t      SUN4I_A10_PLL2_4X, &clk_name);\n\tclks[SUN4I_A10_PLL2_4X] = clk_register_fixed_factor(NULL, clk_name,\n\t\t\t\t\t\t\t    parent,\n\t\t\t\t\t\t\t    CLK_SET_RATE_PARENT,\n\t\t\t\t\t\t\t    1, 1);\n\tWARN_ON(IS_ERR(clks[SUN4I_A10_PLL2_4X]));\n\n\t \n\tof_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t      SUN4I_A10_PLL2_8X, &clk_name);\n\tclks[SUN4I_A10_PLL2_8X] = clk_register_fixed_factor(NULL, clk_name,\n\t\t\t\t\t\t\t    parent,\n\t\t\t\t\t\t\t    CLK_SET_RATE_PARENT,\n\t\t\t\t\t\t\t    2, 1);\n\tWARN_ON(IS_ERR(clks[SUN4I_A10_PLL2_8X]));\n\n\tclk_data->clks = clks;\n\tclk_data->clk_num = SUN4I_PLL2_OUTPUTS;\n\tof_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\n\n\treturn;\n\nerr_free_multiplier:\n\tkfree(mult);\nerr_free_gate:\n\tkfree(gate);\nerr_unregister_prediv:\n\tclk_unregister_divider(prediv_clk);\nerr_free_array:\n\tkfree(clks);\nerr_free_data:\n\tkfree(clk_data);\nerr_unmap:\n\tiounmap(reg);\n}\n\nstatic void __init sun4i_a10_pll2_setup(struct device_node *node)\n{\n\tsun4i_pll2_setup(node, 0);\n}\n\nCLK_OF_DECLARE(sun4i_a10_pll2, \"allwinner,sun4i-a10-pll2-clk\",\n\t       sun4i_a10_pll2_setup);\n\nstatic void __init sun5i_a13_pll2_setup(struct device_node *node)\n{\n\tsun4i_pll2_setup(node, 1);\n}\n\nCLK_OF_DECLARE(sun5i_a13_pll2, \"allwinner,sun5i-a13-pll2-clk\",\n\t       sun5i_a13_pll2_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}