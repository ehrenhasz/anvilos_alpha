{
  "module_name": "clk-mod0.c",
  "hash_id": "66e11dec95d4c8027c7ac82bc5f8ee3929178252e6bf10220ca59b467740d56d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi/clk-mod0.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"clk-factors.h\"\n\n \n\nstatic void sun4i_a10_get_mod0_factors(struct factors_request *req)\n{\n\tu8 div, calcm, calcp;\n\n\t \n\tif (req->rate > req->parent_rate)\n\t\treq->rate = req->parent_rate;\n\n\tdiv = DIV_ROUND_UP(req->parent_rate, req->rate);\n\n\tif (div < 16)\n\t\tcalcp = 0;\n\telse if (div / 2 < 16)\n\t\tcalcp = 1;\n\telse if (div / 4 < 16)\n\t\tcalcp = 2;\n\telse\n\t\tcalcp = 3;\n\n\tcalcm = DIV_ROUND_UP(div, 1 << calcp);\n\n\treq->rate = (req->parent_rate >> calcp) / calcm;\n\treq->m = calcm - 1;\n\treq->p = calcp;\n}\n\n \nstatic const struct clk_factors_config sun4i_a10_mod0_config = {\n\t.mshift = 0,\n\t.mwidth = 4,\n\t.pshift = 16,\n\t.pwidth = 2,\n};\n\nstatic const struct factors_data sun4i_a10_mod0_data = {\n\t.enable = 31,\n\t.mux = 24,\n\t.muxmask = BIT(1) | BIT(0),\n\t.table = &sun4i_a10_mod0_config,\n\t.getter = sun4i_a10_get_mod0_factors,\n};\n\nstatic DEFINE_SPINLOCK(sun4i_a10_mod0_lock);\n\nstatic void __init sun4i_a10_mod0_setup(struct device_node *node)\n{\n\tvoid __iomem *reg;\n\n\treg = of_iomap(node, 0);\n\tif (!reg) {\n\t\t \n\t\treturn;\n\t}\n\n\tsunxi_factors_register(node, &sun4i_a10_mod0_data,\n\t\t\t       &sun4i_a10_mod0_lock, reg);\n}\nCLK_OF_DECLARE_DRIVER(sun4i_a10_mod0, \"allwinner,sun4i-a10-mod0-clk\",\n\t\t      sun4i_a10_mod0_setup);\n\nstatic int sun4i_a10_mod0_clk_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tvoid __iomem *reg;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\treg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tsunxi_factors_register(np, &sun4i_a10_mod0_data,\n\t\t\t       &sun4i_a10_mod0_lock, reg);\n\treturn 0;\n}\n\nstatic const struct of_device_id sun4i_a10_mod0_clk_dt_ids[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-mod0-clk\" },\n\t{   }\n};\n\nstatic struct platform_driver sun4i_a10_mod0_clk_driver = {\n\t.driver = {\n\t\t.name = \"sun4i-a10-mod0-clk\",\n\t\t.of_match_table = sun4i_a10_mod0_clk_dt_ids,\n\t},\n\t.probe = sun4i_a10_mod0_clk_probe,\n};\nbuiltin_platform_driver(sun4i_a10_mod0_clk_driver);\n\nstatic const struct factors_data sun9i_a80_mod0_data __initconst = {\n\t.enable = 31,\n\t.mux = 24,\n\t.muxmask = BIT(3) | BIT(2) | BIT(1) | BIT(0),\n\t.table = &sun4i_a10_mod0_config,\n\t.getter = sun4i_a10_get_mod0_factors,\n};\n\nstatic void __init sun9i_a80_mod0_setup(struct device_node *node)\n{\n\tvoid __iomem *reg;\n\n\treg = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(reg)) {\n\t\tpr_err(\"Could not get registers for mod0-clk: %pOFn\\n\",\n\t\t       node);\n\t\treturn;\n\t}\n\n\tsunxi_factors_register(node, &sun9i_a80_mod0_data,\n\t\t\t       &sun4i_a10_mod0_lock, reg);\n}\nCLK_OF_DECLARE(sun9i_a80_mod0, \"allwinner,sun9i-a80-mod0-clk\", sun9i_a80_mod0_setup);\n\nstatic DEFINE_SPINLOCK(sun5i_a13_mbus_lock);\n\nstatic void __init sun5i_a13_mbus_setup(struct device_node *node)\n{\n\tvoid __iomem *reg;\n\n\treg = of_iomap(node, 0);\n\tif (!reg) {\n\t\tpr_err(\"Could not get registers for a13-mbus-clk\\n\");\n\t\treturn;\n\t}\n\n\t \n\tsunxi_factors_register_critical(node, &sun4i_a10_mod0_data,\n\t\t\t\t\t&sun5i_a13_mbus_lock, reg);\n}\nCLK_OF_DECLARE(sun5i_a13_mbus, \"allwinner,sun5i-a13-mbus-clk\", sun5i_a13_mbus_setup);\n\nstruct mmc_phase {\n\tstruct clk_hw\t\thw;\n\tu8\t\t\toffset;\n\tvoid __iomem\t\t*reg;\n\tspinlock_t\t\t*lock;\n};\n\n#define to_mmc_phase(_hw) container_of(_hw, struct mmc_phase, hw)\n\nstatic int mmc_get_phase(struct clk_hw *hw)\n{\n\tstruct clk *mmc, *mmc_parent, *clk = hw->clk;\n\tstruct mmc_phase *phase = to_mmc_phase(hw);\n\tunsigned int mmc_rate, mmc_parent_rate;\n\tu16 step, mmc_div;\n\tu32 value;\n\tu8 delay;\n\n\tvalue = readl(phase->reg);\n\tdelay = (value >> phase->offset) & 0x3;\n\n\tif (!delay)\n\t\treturn 180;\n\n\t \n\tmmc = clk_get_parent(clk);\n\tif (!mmc)\n\t\treturn -EINVAL;\n\n\t \n\tmmc_rate = clk_get_rate(mmc);\n\tif (!mmc_rate)\n\t\treturn -EINVAL;\n\n\t \n\tmmc_parent = clk_get_parent(mmc);\n\tif (!mmc_parent)\n\t\treturn -EINVAL;\n\n\t \n\tmmc_parent_rate = clk_get_rate(mmc_parent);\n\tif (!mmc_parent_rate)\n\t\treturn -EINVAL;\n\n\t \n\tmmc_div = mmc_parent_rate / mmc_rate;\n\n\tstep = DIV_ROUND_CLOSEST(360, mmc_div);\n\treturn delay * step;\n}\n\nstatic int mmc_set_phase(struct clk_hw *hw, int degrees)\n{\n\tstruct clk *mmc, *mmc_parent, *clk = hw->clk;\n\tstruct mmc_phase *phase = to_mmc_phase(hw);\n\tunsigned int mmc_rate, mmc_parent_rate;\n\tunsigned long flags;\n\tu32 value;\n\tu8 delay;\n\n\t \n\tmmc = clk_get_parent(clk);\n\tif (!mmc)\n\t\treturn -EINVAL;\n\n\t \n\tmmc_rate = clk_get_rate(mmc);\n\tif (!mmc_rate)\n\t\treturn -EINVAL;\n\n\t \n\tmmc_parent = clk_get_parent(mmc);\n\tif (!mmc_parent)\n\t\treturn -EINVAL;\n\n\t \n\tmmc_parent_rate = clk_get_rate(mmc_parent);\n\tif (!mmc_parent_rate)\n\t\treturn -EINVAL;\n\n\tif (degrees != 180) {\n\t\tu16 step, mmc_div;\n\n\t\t \n\t\tmmc_div = mmc_parent_rate / mmc_rate;\n\n\t\t \n\t\tstep = DIV_ROUND_CLOSEST(360, mmc_div);\n\t\tdelay = DIV_ROUND_CLOSEST(degrees, step);\n\t} else {\n\t\tdelay = 0;\n\t}\n\n\tspin_lock_irqsave(phase->lock, flags);\n\tvalue = readl(phase->reg);\n\tvalue &= ~GENMASK(phase->offset + 3, phase->offset);\n\tvalue |= delay << phase->offset;\n\twritel(value, phase->reg);\n\tspin_unlock_irqrestore(phase->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops mmc_clk_ops = {\n\t.get_phase\t= mmc_get_phase,\n\t.set_phase\t= mmc_set_phase,\n};\n\n \nstatic void __init sunxi_mmc_setup(struct device_node *node,\n\t\t\t\t   const struct factors_data *data,\n\t\t\t\t   spinlock_t *lock)\n{\n\tstruct clk_onecell_data *clk_data;\n\tconst char *parent;\n\tvoid __iomem *reg;\n\tint i;\n\n\treg = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(reg)) {\n\t\tpr_err(\"Couldn't map the %pOFn clock registers\\n\", node);\n\t\treturn;\n\t}\n\n\tclk_data = kmalloc(sizeof(*clk_data), GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn;\n\n\tclk_data->clks = kcalloc(3, sizeof(*clk_data->clks), GFP_KERNEL);\n\tif (!clk_data->clks)\n\t\tgoto err_free_data;\n\n\tclk_data->clk_num = 3;\n\tclk_data->clks[0] = sunxi_factors_register(node, data, lock, reg);\n\tif (!clk_data->clks[0])\n\t\tgoto err_free_clks;\n\n\tparent = __clk_get_name(clk_data->clks[0]);\n\n\tfor (i = 1; i < 3; i++) {\n\t\tstruct clk_init_data init = {\n\t\t\t.num_parents\t= 1,\n\t\t\t.parent_names\t= &parent,\n\t\t\t.ops\t\t= &mmc_clk_ops,\n\t\t};\n\t\tstruct mmc_phase *phase;\n\n\t\tphase = kmalloc(sizeof(*phase), GFP_KERNEL);\n\t\tif (!phase)\n\t\t\tcontinue;\n\n\t\tphase->hw.init = &init;\n\t\tphase->reg = reg;\n\t\tphase->lock = lock;\n\n\t\tif (i == 1)\n\t\t\tphase->offset = 8;\n\t\telse\n\t\t\tphase->offset = 20;\n\n\t\tif (of_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t\t  i, &init.name))\n\t\t\tinit.name = node->name;\n\n\t\tclk_data->clks[i] = clk_register(NULL, &phase->hw);\n\t\tif (IS_ERR(clk_data->clks[i])) {\n\t\t\tkfree(phase);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tof_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\n\n\treturn;\n\nerr_free_clks:\n\tkfree(clk_data->clks);\nerr_free_data:\n\tkfree(clk_data);\n}\n\nstatic DEFINE_SPINLOCK(sun4i_a10_mmc_lock);\n\nstatic void __init sun4i_a10_mmc_setup(struct device_node *node)\n{\n\tsunxi_mmc_setup(node, &sun4i_a10_mod0_data, &sun4i_a10_mmc_lock);\n}\nCLK_OF_DECLARE(sun4i_a10_mmc, \"allwinner,sun4i-a10-mmc-clk\", sun4i_a10_mmc_setup);\n\nstatic DEFINE_SPINLOCK(sun9i_a80_mmc_lock);\n\nstatic void __init sun9i_a80_mmc_setup(struct device_node *node)\n{\n\tsunxi_mmc_setup(node, &sun9i_a80_mod0_data, &sun9i_a80_mmc_lock);\n}\nCLK_OF_DECLARE(sun9i_a80_mmc, \"allwinner,sun9i-a80-mmc-clk\", sun9i_a80_mmc_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}