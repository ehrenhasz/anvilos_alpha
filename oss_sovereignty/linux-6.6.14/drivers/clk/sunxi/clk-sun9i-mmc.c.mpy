{
  "module_name": "clk-sun9i-mmc.c",
  "hash_id": "7c049dc3a3b94aac4093d6e66c2e3906a69f329df7e50e49163f947f93eee881",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi/clk-sun9i-mmc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/reset.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#define SUN9I_MMC_WIDTH\t\t4\n\n#define SUN9I_MMC_GATE_BIT\t16\n#define SUN9I_MMC_RESET_BIT\t18\n\nstruct sun9i_mmc_clk_data {\n\tspinlock_t\t\t\tlock;\n\tvoid __iomem\t\t\t*membase;\n\tstruct clk\t\t\t*clk;\n\tstruct reset_control\t\t*reset;\n\tstruct clk_onecell_data\t\tclk_data;\n\tstruct reset_controller_dev\trcdev;\n};\n\nstatic int sun9i_mmc_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t      unsigned long id)\n{\n\tstruct sun9i_mmc_clk_data *data = container_of(rcdev,\n\t\t\t\t\t\t       struct sun9i_mmc_clk_data,\n\t\t\t\t\t\t       rcdev);\n\tunsigned long flags;\n\tvoid __iomem *reg = data->membase + SUN9I_MMC_WIDTH * id;\n\tu32 val;\n\n\tclk_prepare_enable(data->clk);\n\tspin_lock_irqsave(&data->lock, flags);\n\n\tval = readl(reg);\n\twritel(val & ~BIT(SUN9I_MMC_RESET_BIT), reg);\n\n\tspin_unlock_irqrestore(&data->lock, flags);\n\tclk_disable_unprepare(data->clk);\n\n\treturn 0;\n}\n\nstatic int sun9i_mmc_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\tunsigned long id)\n{\n\tstruct sun9i_mmc_clk_data *data = container_of(rcdev,\n\t\t\t\t\t\t       struct sun9i_mmc_clk_data,\n\t\t\t\t\t\t       rcdev);\n\tunsigned long flags;\n\tvoid __iomem *reg = data->membase + SUN9I_MMC_WIDTH * id;\n\tu32 val;\n\n\tclk_prepare_enable(data->clk);\n\tspin_lock_irqsave(&data->lock, flags);\n\n\tval = readl(reg);\n\twritel(val | BIT(SUN9I_MMC_RESET_BIT), reg);\n\n\tspin_unlock_irqrestore(&data->lock, flags);\n\tclk_disable_unprepare(data->clk);\n\n\treturn 0;\n}\n\nstatic int sun9i_mmc_reset_reset(struct reset_controller_dev *rcdev,\n\t\t\t\t unsigned long id)\n{\n\tsun9i_mmc_reset_assert(rcdev, id);\n\tudelay(10);\n\tsun9i_mmc_reset_deassert(rcdev, id);\n\n\treturn 0;\n}\n\nstatic const struct reset_control_ops sun9i_mmc_reset_ops = {\n\t.assert\t\t= sun9i_mmc_reset_assert,\n\t.deassert\t= sun9i_mmc_reset_deassert,\n\t.reset\t\t= sun9i_mmc_reset_reset,\n};\n\nstatic int sun9i_a80_mmc_config_clk_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct sun9i_mmc_clk_data *data;\n\tstruct clk_onecell_data *clk_data;\n\tconst char *clk_name = np->name;\n\tconst char *clk_parent;\n\tstruct resource *r;\n\tint count, i, ret;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&data->lock);\n\n\tdata->membase = devm_platform_get_and_ioremap_resource(pdev, 0, &r);\n\tif (IS_ERR(data->membase))\n\t\treturn PTR_ERR(data->membase);\n\n\t \n\tcount = DIV_ROUND_UP((resource_size(r)), SUN9I_MMC_WIDTH);\n\n\tclk_data = &data->clk_data;\n\tclk_data->clk_num = count;\n\tclk_data->clks = devm_kcalloc(&pdev->dev, count, sizeof(struct clk *),\n\t\t\t\t      GFP_KERNEL);\n\tif (!clk_data->clks)\n\t\treturn -ENOMEM;\n\n\tdata->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(data->clk)) {\n\t\tdev_err(&pdev->dev, \"Could not get clock\\n\");\n\t\treturn PTR_ERR(data->clk);\n\t}\n\n\tdata->reset = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(data->reset)) {\n\t\tdev_err(&pdev->dev, \"Could not get reset control\\n\");\n\t\treturn PTR_ERR(data->reset);\n\t}\n\n\tret = reset_control_deassert(data->reset);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Reset deassert err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tclk_parent = __clk_get_name(data->clk);\n\tfor (i = 0; i < count; i++) {\n\t\tof_property_read_string_index(np, \"clock-output-names\",\n\t\t\t\t\t      i, &clk_name);\n\n\t\tclk_data->clks[i] = clk_register_gate(&pdev->dev, clk_name,\n\t\t\t\t\t\t      clk_parent, 0,\n\t\t\t\t\t\t      data->membase + SUN9I_MMC_WIDTH * i,\n\t\t\t\t\t\t      SUN9I_MMC_GATE_BIT, 0,\n\t\t\t\t\t\t      &data->lock);\n\n\t\tif (IS_ERR(clk_data->clks[i])) {\n\t\t\tret = PTR_ERR(clk_data->clks[i]);\n\t\t\tgoto err_clk_register;\n\t\t}\n\t}\n\n\tret = of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);\n\tif (ret)\n\t\tgoto err_clk_provider;\n\n\tdata->rcdev.owner = THIS_MODULE;\n\tdata->rcdev.nr_resets = count;\n\tdata->rcdev.ops = &sun9i_mmc_reset_ops;\n\tdata->rcdev.of_node = pdev->dev.of_node;\n\n\tret = reset_controller_register(&data->rcdev);\n\tif (ret)\n\t\tgoto err_rc_reg;\n\n\tplatform_set_drvdata(pdev, data);\n\n\treturn 0;\n\nerr_rc_reg:\n\tof_clk_del_provider(np);\n\nerr_clk_provider:\n\tfor (i = 0; i < count; i++)\n\t\tclk_unregister(clk_data->clks[i]);\n\nerr_clk_register:\n\treset_control_assert(data->reset);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id sun9i_a80_mmc_config_clk_dt_ids[] = {\n\t{ .compatible = \"allwinner,sun9i-a80-mmc-config-clk\" },\n\t{   }\n};\n\nstatic struct platform_driver sun9i_a80_mmc_config_clk_driver = {\n\t.driver = {\n\t\t.name = \"sun9i-a80-mmc-config-clk\",\n\t\t.suppress_bind_attrs = true,\n\t\t.of_match_table = sun9i_a80_mmc_config_clk_dt_ids,\n\t},\n\t.probe = sun9i_a80_mmc_config_clk_probe,\n};\nbuiltin_platform_driver(sun9i_a80_mmc_config_clk_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}