{
  "module_name": "clk-sun4i-tcon-ch1.c",
  "hash_id": "9fe1839a8e5aaa08fb14c249e14c156ca67786e1fa86ed94c37abca64043727c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi/clk-sun4i-tcon-ch1.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#define TCON_CH1_SCLK2_PARENTS\t\t4\n\n#define TCON_CH1_SCLK2_GATE_BIT\t\tBIT(31)\n#define TCON_CH1_SCLK2_MUX_MASK\t\t3\n#define TCON_CH1_SCLK2_MUX_SHIFT\t24\n#define TCON_CH1_SCLK2_DIV_MASK\t\t0xf\n#define TCON_CH1_SCLK2_DIV_SHIFT\t0\n\n#define TCON_CH1_SCLK1_GATE_BIT\t\tBIT(15)\n#define TCON_CH1_SCLK1_HALF_BIT\t\tBIT(11)\n\nstruct tcon_ch1_clk {\n\tstruct clk_hw\thw;\n\tspinlock_t\tlock;\n\tvoid __iomem\t*reg;\n};\n\n#define hw_to_tclk(hw)\tcontainer_of(hw, struct tcon_ch1_clk, hw)\n\nstatic void tcon_ch1_disable(struct clk_hw *hw)\n{\n\tstruct tcon_ch1_clk *tclk = hw_to_tclk(hw);\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&tclk->lock, flags);\n\treg = readl(tclk->reg);\n\treg &= ~(TCON_CH1_SCLK2_GATE_BIT | TCON_CH1_SCLK1_GATE_BIT);\n\twritel(reg, tclk->reg);\n\tspin_unlock_irqrestore(&tclk->lock, flags);\n}\n\nstatic int tcon_ch1_enable(struct clk_hw *hw)\n{\n\tstruct tcon_ch1_clk *tclk = hw_to_tclk(hw);\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&tclk->lock, flags);\n\treg = readl(tclk->reg);\n\treg |= TCON_CH1_SCLK2_GATE_BIT | TCON_CH1_SCLK1_GATE_BIT;\n\twritel(reg, tclk->reg);\n\tspin_unlock_irqrestore(&tclk->lock, flags);\n\n\treturn 0;\n}\n\nstatic int tcon_ch1_is_enabled(struct clk_hw *hw)\n{\n\tstruct tcon_ch1_clk *tclk = hw_to_tclk(hw);\n\tu32 reg;\n\n\treg = readl(tclk->reg);\n\treturn reg & (TCON_CH1_SCLK2_GATE_BIT | TCON_CH1_SCLK1_GATE_BIT);\n}\n\nstatic u8 tcon_ch1_get_parent(struct clk_hw *hw)\n{\n\tstruct tcon_ch1_clk *tclk = hw_to_tclk(hw);\n\tu32 reg;\n\n\treg = readl(tclk->reg) >> TCON_CH1_SCLK2_MUX_SHIFT;\n\treg &= reg >> TCON_CH1_SCLK2_MUX_MASK;\n\n\treturn reg;\n}\n\nstatic int tcon_ch1_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct tcon_ch1_clk *tclk = hw_to_tclk(hw);\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&tclk->lock, flags);\n\treg = readl(tclk->reg);\n\treg &= ~(TCON_CH1_SCLK2_MUX_MASK << TCON_CH1_SCLK2_MUX_SHIFT);\n\treg |= index << TCON_CH1_SCLK2_MUX_SHIFT;\n\twritel(reg, tclk->reg);\n\tspin_unlock_irqrestore(&tclk->lock, flags);\n\n\treturn 0;\n};\n\nstatic unsigned long tcon_ch1_calc_divider(unsigned long rate,\n\t\t\t\t\t   unsigned long parent_rate,\n\t\t\t\t\t   u8 *div,\n\t\t\t\t\t   bool *half)\n{\n\tunsigned long best_rate = 0;\n\tu8 best_m = 0, m;\n\tbool is_double;\n\n\tfor (m = 1; m < 16; m++) {\n\t\tu8 d;\n\n\t\tfor (d = 1; d < 3; d++) {\n\t\t\tunsigned long tmp_rate;\n\n\t\t\ttmp_rate = parent_rate / m / d;\n\n\t\t\tif (tmp_rate > rate)\n\t\t\t\tcontinue;\n\n\t\t\tif (!best_rate ||\n\t\t\t    (rate - tmp_rate) < (rate - best_rate)) {\n\t\t\t\tbest_rate = tmp_rate;\n\t\t\t\tbest_m = m;\n\t\t\t\tis_double = d;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (div && half) {\n\t\t*div = best_m;\n\t\t*half = is_double;\n\t}\n\n\treturn best_rate;\n}\n\nstatic int tcon_ch1_determine_rate(struct clk_hw *hw,\n\t\t\t\t   struct clk_rate_request *req)\n{\n\tlong best_rate = -EINVAL;\n\tint i;\n\n\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\n\t\tunsigned long parent_rate;\n\t\tunsigned long tmp_rate;\n\t\tstruct clk_hw *parent;\n\n\t\tparent = clk_hw_get_parent_by_index(hw, i);\n\t\tif (!parent)\n\t\t\tcontinue;\n\n\t\tparent_rate = clk_hw_get_rate(parent);\n\n\t\ttmp_rate = tcon_ch1_calc_divider(req->rate, parent_rate,\n\t\t\t\t\t\t NULL, NULL);\n\n\t\tif (best_rate < 0 ||\n\t\t    (req->rate - tmp_rate) < (req->rate - best_rate)) {\n\t\t\tbest_rate = tmp_rate;\n\t\t\treq->best_parent_rate = parent_rate;\n\t\t\treq->best_parent_hw = parent;\n\t\t}\n\t}\n\n\tif (best_rate < 0)\n\t\treturn best_rate;\n\n\treq->rate = best_rate;\n\treturn 0;\n}\n\nstatic unsigned long tcon_ch1_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct tcon_ch1_clk *tclk = hw_to_tclk(hw);\n\tu32 reg;\n\n\treg = readl(tclk->reg);\n\n\tparent_rate /= (reg & TCON_CH1_SCLK2_DIV_MASK) + 1;\n\n\tif (reg & TCON_CH1_SCLK1_HALF_BIT)\n\t\tparent_rate /= 2;\n\n\treturn parent_rate;\n}\n\nstatic int tcon_ch1_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t     unsigned long parent_rate)\n{\n\tstruct tcon_ch1_clk *tclk = hw_to_tclk(hw);\n\tunsigned long flags;\n\tbool half;\n\tu8 div_m;\n\tu32 reg;\n\n\ttcon_ch1_calc_divider(rate, parent_rate, &div_m, &half);\n\n\tspin_lock_irqsave(&tclk->lock, flags);\n\treg = readl(tclk->reg);\n\treg &= ~(TCON_CH1_SCLK2_DIV_MASK | TCON_CH1_SCLK1_HALF_BIT);\n\treg |= (div_m - 1) & TCON_CH1_SCLK2_DIV_MASK;\n\n\tif (half)\n\t\treg |= TCON_CH1_SCLK1_HALF_BIT;\n\n\twritel(reg, tclk->reg);\n\tspin_unlock_irqrestore(&tclk->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops tcon_ch1_ops = {\n\t.disable\t= tcon_ch1_disable,\n\t.enable\t\t= tcon_ch1_enable,\n\t.is_enabled\t= tcon_ch1_is_enabled,\n\n\t.get_parent\t= tcon_ch1_get_parent,\n\t.set_parent\t= tcon_ch1_set_parent,\n\n\t.determine_rate\t= tcon_ch1_determine_rate,\n\t.recalc_rate\t= tcon_ch1_recalc_rate,\n\t.set_rate\t= tcon_ch1_set_rate,\n};\n\nstatic void __init tcon_ch1_setup(struct device_node *node)\n{\n\tconst char *parents[TCON_CH1_SCLK2_PARENTS];\n\tconst char *clk_name = node->name;\n\tstruct clk_init_data init;\n\tstruct tcon_ch1_clk *tclk;\n\tstruct resource res;\n\tstruct clk *clk;\n\tvoid __iomem *reg;\n\tint ret;\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\n\treg = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(reg)) {\n\t\tpr_err(\"%s: Could not map the clock registers\\n\", clk_name);\n\t\treturn;\n\t}\n\n\tret = of_clk_parent_fill(node, parents, TCON_CH1_SCLK2_PARENTS);\n\tif (ret != TCON_CH1_SCLK2_PARENTS) {\n\t\tpr_err(\"%s Could not retrieve the parents\\n\", clk_name);\n\t\tgoto err_unmap;\n\t}\n\n\ttclk = kzalloc(sizeof(*tclk), GFP_KERNEL);\n\tif (!tclk)\n\t\tgoto err_unmap;\n\n\tinit.name = clk_name;\n\tinit.ops = &tcon_ch1_ops;\n\tinit.parent_names = parents;\n\tinit.num_parents = TCON_CH1_SCLK2_PARENTS;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\n\ttclk->reg = reg;\n\ttclk->hw.init = &init;\n\tspin_lock_init(&tclk->lock);\n\n\tclk = clk_register(NULL, &tclk->hw);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: Couldn't register the clock\\n\", clk_name);\n\t\tgoto err_free_data;\n\t}\n\n\tret = of_clk_add_provider(node, of_clk_src_simple_get, clk);\n\tif (ret) {\n\t\tpr_err(\"%s: Couldn't register our clock provider\\n\", clk_name);\n\t\tgoto err_unregister_clk;\n\t}\n\n\treturn;\n\nerr_unregister_clk:\n\tclk_unregister(clk);\nerr_free_data:\n\tkfree(tclk);\nerr_unmap:\n\tiounmap(reg);\n\tof_address_to_resource(node, 0, &res);\n\trelease_mem_region(res.start, resource_size(&res));\n}\n\nCLK_OF_DECLARE(tcon_ch1, \"allwinner,sun4i-a10-tcon-ch1-clk\",\n\t       tcon_ch1_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}