{
  "module_name": "clk-sun9i-core.c",
  "hash_id": "a2b65920b426df470058e4f5cf621fd1e70b45ee4559c3c79ae66e905e3f5ecb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi/clk-sun9i-core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/log2.h>\n\n#include \"clk-factors.h\"\n\n\n \n\nstatic void sun9i_a80_get_pll4_factors(struct factors_request *req)\n{\n\tint n;\n\tint m = 1;\n\tint p = 1;\n\n\t \n\tn = DIV_ROUND_UP(req->rate, 6000000);\n\n\t \n\tif (n > 255) {\n\t\tm = 0;\n\t\tn = (n + 1) / 2;\n\t}\n\n\t \n\tif (n > 255) {\n\t\tp = 0;\n\t\tn = (n + 1) / 2;\n\t}\n\n\t \n\tif (n > 255)\n\t\tn = 255;\n\telse if (n < 12)\n\t\tn = 12;\n\n\treq->rate = ((24000000 * n) >> p) / (m + 1);\n\treq->n = n;\n\treq->m = m;\n\treq->p = p;\n}\n\nstatic const struct clk_factors_config sun9i_a80_pll4_config = {\n\t.mshift = 18,\n\t.mwidth = 1,\n\t.nshift = 8,\n\t.nwidth = 8,\n\t.pshift = 16,\n\t.pwidth = 1,\n};\n\nstatic const struct factors_data sun9i_a80_pll4_data __initconst = {\n\t.enable = 31,\n\t.table = &sun9i_a80_pll4_config,\n\t.getter = sun9i_a80_get_pll4_factors,\n};\n\nstatic DEFINE_SPINLOCK(sun9i_a80_pll4_lock);\n\nstatic void __init sun9i_a80_pll4_setup(struct device_node *node)\n{\n\tvoid __iomem *reg;\n\n\treg = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(reg)) {\n\t\tpr_err(\"Could not get registers for a80-pll4-clk: %pOFn\\n\",\n\t\t       node);\n\t\treturn;\n\t}\n\n\tsunxi_factors_register(node, &sun9i_a80_pll4_data,\n\t\t\t       &sun9i_a80_pll4_lock, reg);\n}\nCLK_OF_DECLARE(sun9i_a80_pll4, \"allwinner,sun9i-a80-pll4-clk\", sun9i_a80_pll4_setup);\n\n\n \n\nstatic void sun9i_a80_get_gt_factors(struct factors_request *req)\n{\n\tu32 div;\n\n\tif (req->parent_rate < req->rate)\n\t\treq->rate = req->parent_rate;\n\n\tdiv = DIV_ROUND_UP(req->parent_rate, req->rate);\n\n\t \n\tif (div > 4)\n\t\tdiv = 4;\n\n\treq->rate = req->parent_rate / div;\n\treq->m = div;\n}\n\nstatic const struct clk_factors_config sun9i_a80_gt_config = {\n\t.mshift = 0,\n\t.mwidth = 2,\n};\n\nstatic const struct factors_data sun9i_a80_gt_data __initconst = {\n\t.mux = 24,\n\t.muxmask = BIT(1) | BIT(0),\n\t.table = &sun9i_a80_gt_config,\n\t.getter = sun9i_a80_get_gt_factors,\n};\n\nstatic DEFINE_SPINLOCK(sun9i_a80_gt_lock);\n\nstatic void __init sun9i_a80_gt_setup(struct device_node *node)\n{\n\tvoid __iomem *reg;\n\n\treg = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(reg)) {\n\t\tpr_err(\"Could not get registers for a80-gt-clk: %pOFn\\n\",\n\t\t       node);\n\t\treturn;\n\t}\n\n\t \n\tsunxi_factors_register_critical(node, &sun9i_a80_gt_data,\n\t\t\t\t\t&sun9i_a80_gt_lock, reg);\n}\nCLK_OF_DECLARE(sun9i_a80_gt, \"allwinner,sun9i-a80-gt-clk\", sun9i_a80_gt_setup);\n\n\n \n\nstatic void sun9i_a80_get_ahb_factors(struct factors_request *req)\n{\n\tu32 _p;\n\n\tif (req->parent_rate < req->rate)\n\t\treq->rate = req->parent_rate;\n\n\t_p = order_base_2(DIV_ROUND_UP(req->parent_rate, req->rate));\n\n\t \n\tif (_p > 3)\n\t\t_p = 3;\n\n\treq->rate = req->parent_rate >> _p;\n\treq->p = _p;\n}\n\nstatic const struct clk_factors_config sun9i_a80_ahb_config = {\n\t.pshift = 0,\n\t.pwidth = 2,\n};\n\nstatic const struct factors_data sun9i_a80_ahb_data __initconst = {\n\t.mux = 24,\n\t.muxmask = BIT(1) | BIT(0),\n\t.table = &sun9i_a80_ahb_config,\n\t.getter = sun9i_a80_get_ahb_factors,\n};\n\nstatic DEFINE_SPINLOCK(sun9i_a80_ahb_lock);\n\nstatic void __init sun9i_a80_ahb_setup(struct device_node *node)\n{\n\tvoid __iomem *reg;\n\n\treg = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(reg)) {\n\t\tpr_err(\"Could not get registers for a80-ahb-clk: %pOFn\\n\",\n\t\t       node);\n\t\treturn;\n\t}\n\n\tsunxi_factors_register(node, &sun9i_a80_ahb_data,\n\t\t\t       &sun9i_a80_ahb_lock, reg);\n}\nCLK_OF_DECLARE(sun9i_a80_ahb, \"allwinner,sun9i-a80-ahb-clk\", sun9i_a80_ahb_setup);\n\n\nstatic const struct factors_data sun9i_a80_apb0_data __initconst = {\n\t.mux = 24,\n\t.muxmask = BIT(0),\n\t.table = &sun9i_a80_ahb_config,\n\t.getter = sun9i_a80_get_ahb_factors,\n};\n\nstatic DEFINE_SPINLOCK(sun9i_a80_apb0_lock);\n\nstatic void __init sun9i_a80_apb0_setup(struct device_node *node)\n{\n\tvoid __iomem *reg;\n\n\treg = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(reg)) {\n\t\tpr_err(\"Could not get registers for a80-apb0-clk: %pOFn\\n\",\n\t\t       node);\n\t\treturn;\n\t}\n\n\tsunxi_factors_register(node, &sun9i_a80_apb0_data,\n\t\t\t       &sun9i_a80_apb0_lock, reg);\n}\nCLK_OF_DECLARE(sun9i_a80_apb0, \"allwinner,sun9i-a80-apb0-clk\", sun9i_a80_apb0_setup);\n\n\n \n\nstatic void sun9i_a80_get_apb1_factors(struct factors_request *req)\n{\n\tu32 div;\n\n\tif (req->parent_rate < req->rate)\n\t\treq->rate = req->parent_rate;\n\n\tdiv = DIV_ROUND_UP(req->parent_rate, req->rate);\n\n\t \n\tif (div > 256)\n\t\tdiv = 256;\n\n\treq->p = order_base_2(div);\n\treq->m = (req->parent_rate >> req->p) - 1;\n\treq->rate = (req->parent_rate >> req->p) / (req->m + 1);\n}\n\nstatic const struct clk_factors_config sun9i_a80_apb1_config = {\n\t.mshift = 0,\n\t.mwidth = 5,\n\t.pshift = 16,\n\t.pwidth = 2,\n};\n\nstatic const struct factors_data sun9i_a80_apb1_data __initconst = {\n\t.mux = 24,\n\t.muxmask = BIT(0),\n\t.table = &sun9i_a80_apb1_config,\n\t.getter = sun9i_a80_get_apb1_factors,\n};\n\nstatic DEFINE_SPINLOCK(sun9i_a80_apb1_lock);\n\nstatic void __init sun9i_a80_apb1_setup(struct device_node *node)\n{\n\tvoid __iomem *reg;\n\n\treg = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(reg)) {\n\t\tpr_err(\"Could not get registers for a80-apb1-clk: %pOFn\\n\",\n\t\t       node);\n\t\treturn;\n\t}\n\n\tsunxi_factors_register(node, &sun9i_a80_apb1_data,\n\t\t\t       &sun9i_a80_apb1_lock, reg);\n}\nCLK_OF_DECLARE(sun9i_a80_apb1, \"allwinner,sun9i-a80-apb1-clk\", sun9i_a80_apb1_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}