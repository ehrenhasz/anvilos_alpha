{
  "module_name": "clk-factors.c",
  "hash_id": "857c8c7a8f33d6350352ecdf47c09e5e0c990689bf234f9e75514fa841ce95d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi/clk-factors.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include \"clk-factors.h\"\n\n \n\n#define to_clk_factors(_hw) container_of(_hw, struct clk_factors, hw)\n\n#define FACTORS_MAX_PARENTS\t\t5\n\n#define SETMASK(len, pos)\t\t(((1U << (len)) - 1) << (pos))\n#define CLRMASK(len, pos)\t\t(~(SETMASK(len, pos)))\n#define FACTOR_GET(bit, len, reg)\t(((reg) & SETMASK(len, bit)) >> (bit))\n\n#define FACTOR_SET(bit, len, reg, val) \\\n\t(((reg) & CLRMASK(len, bit)) | (val << (bit)))\n\nstatic unsigned long clk_factors_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tu8 n = 1, k = 0, p = 0, m = 0;\n\tu32 reg;\n\tunsigned long rate;\n\tstruct clk_factors *factors = to_clk_factors(hw);\n\tconst struct clk_factors_config *config = factors->config;\n\n\t \n\treg = readl(factors->reg);\n\n\t \n\tif (config->nwidth != SUNXI_FACTORS_NOT_APPLICABLE)\n\t\tn = FACTOR_GET(config->nshift, config->nwidth, reg);\n\tif (config->kwidth != SUNXI_FACTORS_NOT_APPLICABLE)\n\t\tk = FACTOR_GET(config->kshift, config->kwidth, reg);\n\tif (config->mwidth != SUNXI_FACTORS_NOT_APPLICABLE)\n\t\tm = FACTOR_GET(config->mshift, config->mwidth, reg);\n\tif (config->pwidth != SUNXI_FACTORS_NOT_APPLICABLE)\n\t\tp = FACTOR_GET(config->pshift, config->pwidth, reg);\n\n\tif (factors->recalc) {\n\t\tstruct factors_request factors_req = {\n\t\t\t.parent_rate = parent_rate,\n\t\t\t.n = n,\n\t\t\t.k = k,\n\t\t\t.m = m,\n\t\t\t.p = p,\n\t\t};\n\n\t\t \n\t\tif (factors->mux)\n\t\t\tfactors_req.parent_index =\n\t\t\t\t(reg >> factors->mux->shift) &\n\t\t\t\tfactors->mux->mask;\n\n\t\tfactors->recalc(&factors_req);\n\n\t\treturn factors_req.rate;\n\t}\n\n\t \n\trate = (parent_rate * (n + config->n_start) * (k + 1) >> p) / (m + 1);\n\n\treturn rate;\n}\n\nstatic int clk_factors_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tstruct clk_factors *factors = to_clk_factors(hw);\n\tstruct clk_hw *parent, *best_parent = NULL;\n\tint i, num_parents;\n\tunsigned long parent_rate, best = 0, child_rate, best_child_rate = 0;\n\n\t \n\tnum_parents = clk_hw_get_num_parents(hw);\n\tfor (i = 0; i < num_parents; i++) {\n\t\tstruct factors_request factors_req = {\n\t\t\t.rate = req->rate,\n\t\t\t.parent_index = i,\n\t\t};\n\t\tparent = clk_hw_get_parent_by_index(hw, i);\n\t\tif (!parent)\n\t\t\tcontinue;\n\t\tif (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)\n\t\t\tparent_rate = clk_hw_round_rate(parent, req->rate);\n\t\telse\n\t\t\tparent_rate = clk_hw_get_rate(parent);\n\n\t\tfactors_req.parent_rate = parent_rate;\n\t\tfactors->get_factors(&factors_req);\n\t\tchild_rate = factors_req.rate;\n\n\t\tif (child_rate <= req->rate && child_rate > best_child_rate) {\n\t\t\tbest_parent = parent;\n\t\t\tbest = parent_rate;\n\t\t\tbest_child_rate = child_rate;\n\t\t}\n\t}\n\n\tif (!best_parent)\n\t\treturn -EINVAL;\n\n\treq->best_parent_hw = best_parent;\n\treq->best_parent_rate = best;\n\treq->rate = best_child_rate;\n\n\treturn 0;\n}\n\nstatic int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct factors_request req = {\n\t\t.rate = rate,\n\t\t.parent_rate = parent_rate,\n\t};\n\tu32 reg;\n\tstruct clk_factors *factors = to_clk_factors(hw);\n\tconst struct clk_factors_config *config = factors->config;\n\tunsigned long flags = 0;\n\n\tfactors->get_factors(&req);\n\n\tif (factors->lock)\n\t\tspin_lock_irqsave(factors->lock, flags);\n\n\t \n\treg = readl(factors->reg);\n\n\t \n\treg = FACTOR_SET(config->nshift, config->nwidth, reg, req.n);\n\treg = FACTOR_SET(config->kshift, config->kwidth, reg, req.k);\n\treg = FACTOR_SET(config->mshift, config->mwidth, reg, req.m);\n\treg = FACTOR_SET(config->pshift, config->pwidth, reg, req.p);\n\n\t \n\twritel(reg, factors->reg);\n\n\t \n\t__delay((rate >> 20) * 500 / 2);\n\n\tif (factors->lock)\n\t\tspin_unlock_irqrestore(factors->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_factors_ops = {\n\t.determine_rate = clk_factors_determine_rate,\n\t.recalc_rate = clk_factors_recalc_rate,\n\t.set_rate = clk_factors_set_rate,\n};\n\nstatic struct clk *__sunxi_factors_register(struct device_node *node,\n\t\t\t\t\t    const struct factors_data *data,\n\t\t\t\t\t    spinlock_t *lock, void __iomem *reg,\n\t\t\t\t\t    unsigned long flags)\n{\n\tstruct clk *clk;\n\tstruct clk_factors *factors;\n\tstruct clk_gate *gate = NULL;\n\tstruct clk_mux *mux = NULL;\n\tstruct clk_hw *gate_hw = NULL;\n\tstruct clk_hw *mux_hw = NULL;\n\tconst char *clk_name = node->name;\n\tconst char *parents[FACTORS_MAX_PARENTS];\n\tint ret, i = 0;\n\n\t \n\ti = of_clk_parent_fill(node, parents, FACTORS_MAX_PARENTS);\n\n\t \n\tif (data->name)\n\t\tclk_name = data->name;\n\telse\n\t\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\n\tfactors = kzalloc(sizeof(struct clk_factors), GFP_KERNEL);\n\tif (!factors)\n\t\tgoto err_factors;\n\n\t \n\tfactors->reg = reg;\n\tfactors->config = data->table;\n\tfactors->get_factors = data->getter;\n\tfactors->recalc = data->recalc;\n\tfactors->lock = lock;\n\n\t \n\tif (data->enable) {\n\t\tgate = kzalloc(sizeof(struct clk_gate), GFP_KERNEL);\n\t\tif (!gate)\n\t\t\tgoto err_gate;\n\n\t\tfactors->gate = gate;\n\n\t\t \n\t\tgate->reg = reg;\n\t\tgate->bit_idx = data->enable;\n\t\tgate->lock = factors->lock;\n\t\tgate_hw = &gate->hw;\n\t}\n\n\t \n\tif (data->mux) {\n\t\tmux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);\n\t\tif (!mux)\n\t\t\tgoto err_mux;\n\n\t\tfactors->mux = mux;\n\n\t\t \n\t\tmux->reg = reg;\n\t\tmux->shift = data->mux;\n\t\tmux->mask = data->muxmask;\n\t\tmux->lock = factors->lock;\n\t\tmux_hw = &mux->hw;\n\t}\n\n\tclk = clk_register_composite(NULL, clk_name,\n\t\t\tparents, i,\n\t\t\tmux_hw, &clk_mux_ops,\n\t\t\t&factors->hw, &clk_factors_ops,\n\t\t\tgate_hw, &clk_gate_ops, CLK_IS_CRITICAL);\n\tif (IS_ERR(clk))\n\t\tgoto err_register;\n\n\tret = of_clk_add_provider(node, of_clk_src_simple_get, clk);\n\tif (ret)\n\t\tgoto err_provider;\n\n\treturn clk;\n\nerr_provider:\n\t \n\tclk_unregister(clk);\nerr_register:\n\tkfree(mux);\nerr_mux:\n\tkfree(gate);\nerr_gate:\n\tkfree(factors);\nerr_factors:\n\treturn NULL;\n}\n\nstruct clk *sunxi_factors_register(struct device_node *node,\n\t\t\t\t   const struct factors_data *data,\n\t\t\t\t   spinlock_t *lock,\n\t\t\t\t   void __iomem *reg)\n{\n\treturn __sunxi_factors_register(node, data, lock, reg, 0);\n}\n\nstruct clk *sunxi_factors_register_critical(struct device_node *node,\n\t\t\t\t\t    const struct factors_data *data,\n\t\t\t\t\t    spinlock_t *lock,\n\t\t\t\t\t    void __iomem *reg)\n{\n\treturn __sunxi_factors_register(node, data, lock, reg, CLK_IS_CRITICAL);\n}\n\nvoid sunxi_factors_unregister(struct device_node *node, struct clk *clk)\n{\n\tstruct clk_hw *hw = __clk_get_hw(clk);\n\tstruct clk_factors *factors;\n\n\tif (!hw)\n\t\treturn;\n\n\tfactors = to_clk_factors(hw);\n\n\tof_clk_del_provider(node);\n\t \n\tclk_unregister(clk);\n\tkfree(factors->mux);\n\tkfree(factors->gate);\n\tkfree(factors);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}