{
  "module_name": "clk-sun4i-display.c",
  "hash_id": "5272d32b6554a201213cab1f29f0d658e1cc9ded9c4ab4ef1e89a6922d529948",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi/clk-sun4i-display.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of_address.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\nstruct sun4i_a10_display_clk_data {\n\tbool\thas_div;\n\tu8\tnum_rst;\n\tu8\tparents;\n\n\tu8\toffset_en;\n\tu8\toffset_div;\n\tu8\toffset_mux;\n\tu8\toffset_rst;\n\n\tu8\twidth_div;\n\tu8\twidth_mux;\n\n\tu32\tflags;\n};\n\nstruct reset_data {\n\tvoid __iomem\t\t\t*reg;\n\tspinlock_t\t\t\t*lock;\n\tstruct reset_controller_dev\trcdev;\n\tu8\t\t\t\toffset;\n};\n\nstatic DEFINE_SPINLOCK(sun4i_a10_display_lock);\n\nstatic inline struct reset_data *rcdev_to_reset_data(struct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct reset_data, rcdev);\n};\n\nstatic int sun4i_a10_display_assert(struct reset_controller_dev *rcdev,\n\t\t\t\t    unsigned long id)\n{\n\tstruct reset_data *data = rcdev_to_reset_data(rcdev);\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(data->lock, flags);\n\n\treg = readl(data->reg);\n\twritel(reg & ~BIT(data->offset + id), data->reg);\n\n\tspin_unlock_irqrestore(data->lock, flags);\n\n\treturn 0;\n}\n\nstatic int sun4i_a10_display_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t      unsigned long id)\n{\n\tstruct reset_data *data = rcdev_to_reset_data(rcdev);\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(data->lock, flags);\n\n\treg = readl(data->reg);\n\twritel(reg | BIT(data->offset + id), data->reg);\n\n\tspin_unlock_irqrestore(data->lock, flags);\n\n\treturn 0;\n}\n\nstatic int sun4i_a10_display_status(struct reset_controller_dev *rcdev,\n\t\t\t\t    unsigned long id)\n{\n\tstruct reset_data *data = rcdev_to_reset_data(rcdev);\n\n\treturn !(readl(data->reg) & BIT(data->offset + id));\n}\n\nstatic const struct reset_control_ops sun4i_a10_display_reset_ops = {\n\t.assert\t\t= sun4i_a10_display_assert,\n\t.deassert\t= sun4i_a10_display_deassert,\n\t.status\t\t= sun4i_a10_display_status,\n};\n\nstatic int sun4i_a10_display_reset_xlate(struct reset_controller_dev *rcdev,\n\t\t\t\t\t const struct of_phandle_args *spec)\n{\n\t \n\treturn 0;\n}\n\nstatic void __init sun4i_a10_display_init(struct device_node *node,\n\t\t\t\t\t  const struct sun4i_a10_display_clk_data *data)\n{\n\tconst char *parents[4];\n\tconst char *clk_name = node->name;\n\tstruct reset_data *reset_data;\n\tstruct clk_divider *div = NULL;\n\tstruct clk_gate *gate;\n\tstruct resource res;\n\tstruct clk_mux *mux;\n\tvoid __iomem *reg;\n\tstruct clk *clk;\n\tint ret;\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\n\treg = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(reg)) {\n\t\tpr_err(\"%s: Could not map the clock registers\\n\", clk_name);\n\t\treturn;\n\t}\n\n\tret = of_clk_parent_fill(node, parents, data->parents);\n\tif (ret != data->parents) {\n\t\tpr_err(\"%s: Could not retrieve the parents\\n\", clk_name);\n\t\tgoto unmap;\n\t}\n\n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\tgoto unmap;\n\n\tmux->reg = reg;\n\tmux->shift = data->offset_mux;\n\tmux->mask = (1 << data->width_mux) - 1;\n\tmux->lock = &sun4i_a10_display_lock;\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\tgoto free_mux;\n\n\tgate->reg = reg;\n\tgate->bit_idx = data->offset_en;\n\tgate->lock = &sun4i_a10_display_lock;\n\n\tif (data->has_div) {\n\t\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\t\tif (!div)\n\t\t\tgoto free_gate;\n\n\t\tdiv->reg = reg;\n\t\tdiv->shift = data->offset_div;\n\t\tdiv->width = data->width_div;\n\t\tdiv->lock = &sun4i_a10_display_lock;\n\t}\n\n\tclk = clk_register_composite(NULL, clk_name,\n\t\t\t\t     parents, data->parents,\n\t\t\t\t     &mux->hw, &clk_mux_ops,\n\t\t\t\t     data->has_div ? &div->hw : NULL,\n\t\t\t\t     data->has_div ? &clk_divider_ops : NULL,\n\t\t\t\t     &gate->hw, &clk_gate_ops,\n\t\t\t\t     data->flags);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: Couldn't register the clock\\n\", clk_name);\n\t\tgoto free_div;\n\t}\n\n\tret = of_clk_add_provider(node, of_clk_src_simple_get, clk);\n\tif (ret) {\n\t\tpr_err(\"%s: Couldn't register DT provider\\n\", clk_name);\n\t\tgoto free_clk;\n\t}\n\n\tif (!data->num_rst)\n\t\treturn;\n\n\treset_data = kzalloc(sizeof(*reset_data), GFP_KERNEL);\n\tif (!reset_data)\n\t\tgoto free_of_clk;\n\n\treset_data->reg = reg;\n\treset_data->offset = data->offset_rst;\n\treset_data->lock = &sun4i_a10_display_lock;\n\treset_data->rcdev.nr_resets = data->num_rst;\n\treset_data->rcdev.ops = &sun4i_a10_display_reset_ops;\n\treset_data->rcdev.of_node = node;\n\n\tif (data->num_rst == 1) {\n\t\treset_data->rcdev.of_reset_n_cells = 0;\n\t\treset_data->rcdev.of_xlate = &sun4i_a10_display_reset_xlate;\n\t} else {\n\t\treset_data->rcdev.of_reset_n_cells = 1;\n\t}\n\n\tif (reset_controller_register(&reset_data->rcdev)) {\n\t\tpr_err(\"%s: Couldn't register the reset controller\\n\",\n\t\t       clk_name);\n\t\tgoto free_reset;\n\t}\n\n\treturn;\n\nfree_reset:\n\tkfree(reset_data);\nfree_of_clk:\n\tof_clk_del_provider(node);\nfree_clk:\n\tclk_unregister_composite(clk);\nfree_div:\n\tkfree(div);\nfree_gate:\n\tkfree(gate);\nfree_mux:\n\tkfree(mux);\nunmap:\n\tiounmap(reg);\n\tof_address_to_resource(node, 0, &res);\n\trelease_mem_region(res.start, resource_size(&res));\n}\n\nstatic const struct sun4i_a10_display_clk_data sun4i_a10_tcon_ch0_data __initconst = {\n\t.num_rst\t= 2,\n\t.parents\t= 4,\n\t.offset_en\t= 31,\n\t.offset_rst\t= 29,\n\t.offset_mux\t= 24,\n\t.width_mux\t= 2,\n\t.flags\t\t= CLK_SET_RATE_PARENT,\n};\n\nstatic void __init sun4i_a10_tcon_ch0_setup(struct device_node *node)\n{\n\tsun4i_a10_display_init(node, &sun4i_a10_tcon_ch0_data);\n}\nCLK_OF_DECLARE(sun4i_a10_tcon_ch0, \"allwinner,sun4i-a10-tcon-ch0-clk\",\n\t       sun4i_a10_tcon_ch0_setup);\n\nstatic const struct sun4i_a10_display_clk_data sun4i_a10_display_data __initconst = {\n\t.has_div\t= true,\n\t.num_rst\t= 1,\n\t.parents\t= 3,\n\t.offset_en\t= 31,\n\t.offset_rst\t= 30,\n\t.offset_mux\t= 24,\n\t.offset_div\t= 0,\n\t.width_mux\t= 2,\n\t.width_div\t= 4,\n};\n\nstatic void __init sun4i_a10_display_setup(struct device_node *node)\n{\n\tsun4i_a10_display_init(node, &sun4i_a10_display_data);\n}\nCLK_OF_DECLARE(sun4i_a10_display, \"allwinner,sun4i-a10-display-clk\",\n\t       sun4i_a10_display_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}