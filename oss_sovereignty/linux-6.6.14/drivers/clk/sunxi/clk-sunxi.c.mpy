{
  "module_name": "clk-sunxi.c",
  "hash_id": "eacc75ab3d9359899eacd4a1b97a360c0ce9fcfdcbf8d3945fe4f62e6cabb9b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sunxi/clk-sunxi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/reset-controller.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n\n#include \"clk-factors.h\"\n\nstatic DEFINE_SPINLOCK(clk_lock);\n\n \n#define SUNXI_MAX_PARENTS\t5\n\n \n\nstatic void sun4i_get_pll1_factors(struct factors_request *req)\n{\n\tu8 div;\n\n\t \n\tdiv = req->rate / 6000000;\n\treq->rate = 6000000 * div;\n\n\t \n\treq->m = 0;\n\n\t \n\tif (req->rate >= 768000000 || req->rate == 42000000 ||\n\t\t\treq->rate == 54000000)\n\t\treq->k = 1;\n\telse\n\t\treq->k = 0;\n\n\t \n\tif (div < 10)\n\t\treq->p = 3;\n\n\t \n\telse if (div < 20 || (div < 32 && (div & 1)))\n\t\treq->p = 2;\n\n\t \n\telse if (div < 40 || (div < 64 && (div & 2)))\n\t\treq->p = 1;\n\n\t \n\telse\n\t\treq->p = 0;\n\n\t \n\tdiv <<= req->p;\n\tdiv /= (req->k + 1);\n\treq->n = div / 4;\n}\n\n \nstatic void sun6i_a31_get_pll1_factors(struct factors_request *req)\n{\n\t \n\tu32 freq_mhz = req->rate / 1000000;\n\tu32 parent_freq_mhz = req->parent_rate / 1000000;\n\n\t \n\tu32 round_freq_6 = rounddown(freq_mhz, 6);\n\tu32 round_freq_16 = round_down(freq_mhz, 16);\n\n\tif (round_freq_6 > round_freq_16)\n\t\tfreq_mhz = round_freq_6;\n\telse\n\t\tfreq_mhz = round_freq_16;\n\n\treq->rate = freq_mhz * 1000000;\n\n\t \n\tif (!(freq_mhz % 32))\n\t\treq->k = 3;\n\t \n\telse if (!(freq_mhz % 9))\n\t\treq->k = 2;\n\t \n\telse if (!(freq_mhz % 8))\n\t\treq->k = 1;\n\t \n\telse\n\t\treq->k = 0;\n\n\t \n\tif ((freq_mhz % 6) == 2 || (freq_mhz % 6) == 4)\n\t\treq->m = 2;\n\t \n\telse if ((freq_mhz / 6) & 1)\n\t\treq->m = 3;\n\t \n\telse\n\t\treq->m = 1;\n\n\t \n\treq->n = freq_mhz * (req->m + 1) / ((req->k + 1) * parent_freq_mhz)\n\t\t - 1;\n\n\t \n\tif ((req->n + 1) > 31 && (req->m + 1) > 1) {\n\t\treq->n = (req->n + 1) / 2 - 1;\n\t\treq->m = (req->m + 1) / 2 - 1;\n\t}\n}\n\n \n\nstatic void sun8i_a23_get_pll1_factors(struct factors_request *req)\n{\n\tu8 div;\n\n\t \n\tdiv = req->rate / 6000000;\n\treq->rate = 6000000 * div;\n\n\t \n\treq->m = 0;\n\n\t \n\tif (req->rate >= 768000000 || req->rate == 42000000 ||\n\t\t\treq->rate == 54000000)\n\t\treq->k = 1;\n\telse\n\t\treq->k = 0;\n\n\t \n\tif (div < 20 || (div < 32 && (div & 1)))\n\t\treq->p = 2;\n\n\t \n\telse if (div < 40 || (div < 64 && (div & 2)))\n\t\treq->p = 1;\n\n\t \n\telse\n\t\treq->p = 0;\n\n\t \n\tdiv <<= req->p;\n\tdiv /= (req->k + 1);\n\treq->n = div / 4 - 1;\n}\n\n \n\nstatic void sun4i_get_pll5_factors(struct factors_request *req)\n{\n\tu8 div;\n\n\t \n\tdiv = req->rate / req->parent_rate;\n\treq->rate = req->parent_rate * div;\n\n\tif (div < 31)\n\t\treq->k = 0;\n\telse if (div / 2 < 31)\n\t\treq->k = 1;\n\telse if (div / 3 < 31)\n\t\treq->k = 2;\n\telse\n\t\treq->k = 3;\n\n\treq->n = DIV_ROUND_UP(div, (req->k + 1));\n}\n\n \n\nstatic void sun6i_a31_get_pll6_factors(struct factors_request *req)\n{\n\tu8 div;\n\n\t \n\tdiv = req->rate / req->parent_rate;\n\treq->rate = req->parent_rate * div;\n\n\treq->k = div / 32;\n\tif (req->k > 3)\n\t\treq->k = 3;\n\n\treq->n = DIV_ROUND_UP(div, (req->k + 1)) - 1;\n}\n\n \n\nstatic void sun5i_a13_get_ahb_factors(struct factors_request *req)\n{\n\tu32 div;\n\n\t \n\tif (req->parent_rate < req->rate)\n\t\treq->rate = req->parent_rate;\n\n\t \n\tif (req->rate < 8000)\n\t\treq->rate = 8000;\n\tif (req->rate > 300000000)\n\t\treq->rate = 300000000;\n\n\tdiv = order_base_2(DIV_ROUND_UP(req->parent_rate, req->rate));\n\n\t \n\tif (div > 3)\n\t\tdiv = 3;\n\n\treq->rate = req->parent_rate >> div;\n\n\treq->p = div;\n}\n\n#define SUN6I_AHB1_PARENT_PLL6\t3\n\n \n\nstatic void sun6i_get_ahb1_factors(struct factors_request *req)\n{\n\tu8 div, calcp, calcm = 1;\n\n\t \n\tif (req->parent_rate && req->rate > req->parent_rate)\n\t\treq->rate = req->parent_rate;\n\n\tdiv = DIV_ROUND_UP(req->parent_rate, req->rate);\n\n\t \n\tif (req->parent_index == SUN6I_AHB1_PARENT_PLL6) {\n\t\tif (div < 4)\n\t\t\tcalcp = 0;\n\t\telse if (div / 2 < 4)\n\t\t\tcalcp = 1;\n\t\telse if (div / 4 < 4)\n\t\t\tcalcp = 2;\n\t\telse\n\t\t\tcalcp = 3;\n\n\t\tcalcm = DIV_ROUND_UP(div, 1 << calcp);\n\t} else {\n\t\tcalcp = __roundup_pow_of_two(div);\n\t\tcalcp = calcp > 3 ? 3 : calcp;\n\t}\n\n\treq->rate = (req->parent_rate / calcm) >> calcp;\n\treq->p = calcp;\n\treq->m = calcm - 1;\n}\n\n \nstatic void sun6i_ahb1_recalc(struct factors_request *req)\n{\n\treq->rate = req->parent_rate;\n\n\t \n\tif (req->parent_index == SUN6I_AHB1_PARENT_PLL6)\n\t\treq->rate /= req->m + 1;\n\n\t \n\treq->rate >>= req->p;\n}\n\n \n\nstatic void sun4i_get_apb1_factors(struct factors_request *req)\n{\n\tu8 calcm, calcp;\n\tint div;\n\n\tif (req->parent_rate < req->rate)\n\t\treq->rate = req->parent_rate;\n\n\tdiv = DIV_ROUND_UP(req->parent_rate, req->rate);\n\n\t \n\tif (div > 32)\n\t\treturn;\n\n\tif (div <= 4)\n\t\tcalcp = 0;\n\telse if (div <= 8)\n\t\tcalcp = 1;\n\telse if (div <= 16)\n\t\tcalcp = 2;\n\telse\n\t\tcalcp = 3;\n\n\tcalcm = (div >> calcp) - 1;\n\n\treq->rate = (req->parent_rate >> calcp) / (calcm + 1);\n\treq->m = calcm;\n\treq->p = calcp;\n}\n\n\n\n\n \n\nstatic void sun7i_a20_get_out_factors(struct factors_request *req)\n{\n\tu8 div, calcm, calcp;\n\n\t \n\tif (req->rate > req->parent_rate)\n\t\treq->rate = req->parent_rate;\n\n\tdiv = DIV_ROUND_UP(req->parent_rate, req->rate);\n\n\tif (div < 32)\n\t\tcalcp = 0;\n\telse if (div / 2 < 32)\n\t\tcalcp = 1;\n\telse if (div / 4 < 32)\n\t\tcalcp = 2;\n\telse\n\t\tcalcp = 3;\n\n\tcalcm = DIV_ROUND_UP(div, 1 << calcp);\n\n\treq->rate = (req->parent_rate >> calcp) / calcm;\n\treq->m = calcm - 1;\n\treq->p = calcp;\n}\n\n \n\nstatic const struct clk_factors_config sun4i_pll1_config = {\n\t.nshift = 8,\n\t.nwidth = 5,\n\t.kshift = 4,\n\t.kwidth = 2,\n\t.mshift = 0,\n\t.mwidth = 2,\n\t.pshift = 16,\n\t.pwidth = 2,\n};\n\nstatic const struct clk_factors_config sun6i_a31_pll1_config = {\n\t.nshift\t= 8,\n\t.nwidth = 5,\n\t.kshift = 4,\n\t.kwidth = 2,\n\t.mshift = 0,\n\t.mwidth = 2,\n\t.n_start = 1,\n};\n\nstatic const struct clk_factors_config sun8i_a23_pll1_config = {\n\t.nshift = 8,\n\t.nwidth = 5,\n\t.kshift = 4,\n\t.kwidth = 2,\n\t.mshift = 0,\n\t.mwidth = 2,\n\t.pshift = 16,\n\t.pwidth = 2,\n\t.n_start = 1,\n};\n\nstatic const struct clk_factors_config sun4i_pll5_config = {\n\t.nshift = 8,\n\t.nwidth = 5,\n\t.kshift = 4,\n\t.kwidth = 2,\n};\n\nstatic const struct clk_factors_config sun6i_a31_pll6_config = {\n\t.nshift\t= 8,\n\t.nwidth = 5,\n\t.kshift = 4,\n\t.kwidth = 2,\n\t.n_start = 1,\n};\n\nstatic const struct clk_factors_config sun5i_a13_ahb_config = {\n\t.pshift = 4,\n\t.pwidth = 2,\n};\n\nstatic const struct clk_factors_config sun6i_ahb1_config = {\n\t.mshift = 6,\n\t.mwidth = 2,\n\t.pshift = 4,\n\t.pwidth = 2,\n};\n\nstatic const struct clk_factors_config sun4i_apb1_config = {\n\t.mshift = 0,\n\t.mwidth = 5,\n\t.pshift = 16,\n\t.pwidth = 2,\n};\n\n \nstatic const struct clk_factors_config sun7i_a20_out_config = {\n\t.mshift = 8,\n\t.mwidth = 5,\n\t.pshift = 20,\n\t.pwidth = 2,\n};\n\nstatic const struct factors_data sun4i_pll1_data __initconst = {\n\t.enable = 31,\n\t.table = &sun4i_pll1_config,\n\t.getter = sun4i_get_pll1_factors,\n};\n\nstatic const struct factors_data sun6i_a31_pll1_data __initconst = {\n\t.enable = 31,\n\t.table = &sun6i_a31_pll1_config,\n\t.getter = sun6i_a31_get_pll1_factors,\n};\n\nstatic const struct factors_data sun8i_a23_pll1_data __initconst = {\n\t.enable = 31,\n\t.table = &sun8i_a23_pll1_config,\n\t.getter = sun8i_a23_get_pll1_factors,\n};\n\nstatic const struct factors_data sun7i_a20_pll4_data __initconst = {\n\t.enable = 31,\n\t.table = &sun4i_pll5_config,\n\t.getter = sun4i_get_pll5_factors,\n};\n\nstatic const struct factors_data sun4i_pll5_data __initconst = {\n\t.enable = 31,\n\t.table = &sun4i_pll5_config,\n\t.getter = sun4i_get_pll5_factors,\n};\n\nstatic const struct factors_data sun6i_a31_pll6_data __initconst = {\n\t.enable = 31,\n\t.table = &sun6i_a31_pll6_config,\n\t.getter = sun6i_a31_get_pll6_factors,\n};\n\nstatic const struct factors_data sun5i_a13_ahb_data __initconst = {\n\t.mux = 6,\n\t.muxmask = BIT(1) | BIT(0),\n\t.table = &sun5i_a13_ahb_config,\n\t.getter = sun5i_a13_get_ahb_factors,\n};\n\nstatic const struct factors_data sun6i_ahb1_data __initconst = {\n\t.mux = 12,\n\t.muxmask = BIT(1) | BIT(0),\n\t.table = &sun6i_ahb1_config,\n\t.getter = sun6i_get_ahb1_factors,\n\t.recalc = sun6i_ahb1_recalc,\n};\n\nstatic const struct factors_data sun4i_apb1_data __initconst = {\n\t.mux = 24,\n\t.muxmask = BIT(1) | BIT(0),\n\t.table = &sun4i_apb1_config,\n\t.getter = sun4i_get_apb1_factors,\n};\n\nstatic const struct factors_data sun7i_a20_out_data __initconst = {\n\t.enable = 31,\n\t.mux = 24,\n\t.muxmask = BIT(1) | BIT(0),\n\t.table = &sun7i_a20_out_config,\n\t.getter = sun7i_a20_get_out_factors,\n};\n\nstatic struct clk * __init sunxi_factors_clk_setup(struct device_node *node,\n\t\t\t\t\t\t   const struct factors_data *data)\n{\n\tvoid __iomem *reg;\n\n\treg = of_iomap(node, 0);\n\tif (!reg) {\n\t\tpr_err(\"Could not get registers for factors-clk: %pOFn\\n\",\n\t\t       node);\n\t\treturn NULL;\n\t}\n\n\treturn sunxi_factors_register(node, data, &clk_lock, reg);\n}\n\nstatic void __init sun4i_pll1_clk_setup(struct device_node *node)\n{\n\tsunxi_factors_clk_setup(node, &sun4i_pll1_data);\n}\nCLK_OF_DECLARE(sun4i_pll1, \"allwinner,sun4i-a10-pll1-clk\",\n\t       sun4i_pll1_clk_setup);\n\nstatic void __init sun6i_pll1_clk_setup(struct device_node *node)\n{\n\tsunxi_factors_clk_setup(node, &sun6i_a31_pll1_data);\n}\nCLK_OF_DECLARE(sun6i_pll1, \"allwinner,sun6i-a31-pll1-clk\",\n\t       sun6i_pll1_clk_setup);\n\nstatic void __init sun8i_pll1_clk_setup(struct device_node *node)\n{\n\tsunxi_factors_clk_setup(node, &sun8i_a23_pll1_data);\n}\nCLK_OF_DECLARE(sun8i_pll1, \"allwinner,sun8i-a23-pll1-clk\",\n\t       sun8i_pll1_clk_setup);\n\nstatic void __init sun7i_pll4_clk_setup(struct device_node *node)\n{\n\tsunxi_factors_clk_setup(node, &sun7i_a20_pll4_data);\n}\nCLK_OF_DECLARE(sun7i_pll4, \"allwinner,sun7i-a20-pll4-clk\",\n\t       sun7i_pll4_clk_setup);\n\nstatic void __init sun5i_ahb_clk_setup(struct device_node *node)\n{\n\tsunxi_factors_clk_setup(node, &sun5i_a13_ahb_data);\n}\nCLK_OF_DECLARE(sun5i_ahb, \"allwinner,sun5i-a13-ahb-clk\",\n\t       sun5i_ahb_clk_setup);\n\nstatic void __init sun6i_ahb1_clk_setup(struct device_node *node)\n{\n\tsunxi_factors_clk_setup(node, &sun6i_ahb1_data);\n}\nCLK_OF_DECLARE(sun6i_a31_ahb1, \"allwinner,sun6i-a31-ahb1-clk\",\n\t       sun6i_ahb1_clk_setup);\n\nstatic void __init sun4i_apb1_clk_setup(struct device_node *node)\n{\n\tsunxi_factors_clk_setup(node, &sun4i_apb1_data);\n}\nCLK_OF_DECLARE(sun4i_apb1, \"allwinner,sun4i-a10-apb1-clk\",\n\t       sun4i_apb1_clk_setup);\n\nstatic void __init sun7i_out_clk_setup(struct device_node *node)\n{\n\tsunxi_factors_clk_setup(node, &sun7i_a20_out_data);\n}\nCLK_OF_DECLARE(sun7i_out, \"allwinner,sun7i-a20-out-clk\",\n\t       sun7i_out_clk_setup);\n\n\n \n\n#define SUNXI_MUX_GATE_WIDTH\t2\n\nstruct mux_data {\n\tu8 shift;\n};\n\nstatic const struct mux_data sun4i_cpu_mux_data __initconst = {\n\t.shift = 16,\n};\n\nstatic const struct mux_data sun6i_a31_ahb1_mux_data __initconst = {\n\t.shift = 12,\n};\n\nstatic const struct mux_data sun8i_h3_ahb2_mux_data __initconst = {\n\t.shift = 0,\n};\n\nstatic struct clk * __init sunxi_mux_clk_setup(struct device_node *node,\n\t\t\t\t\t       const struct mux_data *data,\n\t\t\t\t\t       unsigned long flags)\n{\n\tstruct clk *clk;\n\tconst char *clk_name = node->name;\n\tconst char *parents[SUNXI_MAX_PARENTS];\n\tvoid __iomem *reg;\n\tint i;\n\n\treg = of_iomap(node, 0);\n\tif (!reg) {\n\t\tpr_err(\"Could not map registers for mux-clk: %pOF\\n\", node);\n\t\treturn NULL;\n\t}\n\n\ti = of_clk_parent_fill(node, parents, SUNXI_MAX_PARENTS);\n\tif (of_property_read_string(node, \"clock-output-names\", &clk_name)) {\n\t\tpr_err(\"%s: could not read clock-output-names from \\\"%pOF\\\"\\n\",\n\t\t       __func__, node);\n\t\tgoto out_unmap;\n\t}\n\n\tclk = clk_register_mux(NULL, clk_name, parents, i,\n\t\t\t       CLK_SET_RATE_PARENT | flags, reg,\n\t\t\t       data->shift, SUNXI_MUX_GATE_WIDTH,\n\t\t\t       0, &clk_lock);\n\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: failed to register mux clock %s: %ld\\n\", __func__,\n\t\t       clk_name, PTR_ERR(clk));\n\t\tgoto out_unmap;\n\t}\n\n\tif (of_clk_add_provider(node, of_clk_src_simple_get, clk)) {\n\t\tpr_err(\"%s: failed to add clock provider for %s\\n\",\n\t\t       __func__, clk_name);\n\t\tclk_unregister_divider(clk);\n\t\tgoto out_unmap;\n\t}\n\n\treturn clk;\nout_unmap:\n\tiounmap(reg);\n\treturn NULL;\n}\n\nstatic void __init sun4i_cpu_clk_setup(struct device_node *node)\n{\n\t \n\tsunxi_mux_clk_setup(node, &sun4i_cpu_mux_data, CLK_IS_CRITICAL);\n}\nCLK_OF_DECLARE(sun4i_cpu, \"allwinner,sun4i-a10-cpu-clk\",\n\t       sun4i_cpu_clk_setup);\n\nstatic void __init sun6i_ahb1_mux_clk_setup(struct device_node *node)\n{\n\tsunxi_mux_clk_setup(node, &sun6i_a31_ahb1_mux_data, 0);\n}\nCLK_OF_DECLARE(sun6i_ahb1_mux, \"allwinner,sun6i-a31-ahb1-mux-clk\",\n\t       sun6i_ahb1_mux_clk_setup);\n\nstatic void __init sun8i_ahb2_clk_setup(struct device_node *node)\n{\n\tsunxi_mux_clk_setup(node, &sun8i_h3_ahb2_mux_data, 0);\n}\nCLK_OF_DECLARE(sun8i_ahb2, \"allwinner,sun8i-h3-ahb2-clk\",\n\t       sun8i_ahb2_clk_setup);\n\n\n \n\nstruct div_data {\n\tu8\tshift;\n\tu8\tpow;\n\tu8\twidth;\n\tconst struct clk_div_table *table;\n};\n\nstatic const struct div_data sun4i_axi_data __initconst = {\n\t.shift\t= 0,\n\t.pow\t= 0,\n\t.width\t= 2,\n};\n\nstatic const struct clk_div_table sun8i_a23_axi_table[] __initconst = {\n\t{ .val = 0, .div = 1 },\n\t{ .val = 1, .div = 2 },\n\t{ .val = 2, .div = 3 },\n\t{ .val = 3, .div = 4 },\n\t{ .val = 4, .div = 4 },\n\t{ .val = 5, .div = 4 },\n\t{ .val = 6, .div = 4 },\n\t{ .val = 7, .div = 4 },\n\t{ }  \n};\n\nstatic const struct div_data sun8i_a23_axi_data __initconst = {\n\t.width\t= 3,\n\t.table\t= sun8i_a23_axi_table,\n};\n\nstatic const struct div_data sun4i_ahb_data __initconst = {\n\t.shift\t= 4,\n\t.pow\t= 1,\n\t.width\t= 2,\n};\n\nstatic const struct clk_div_table sun4i_apb0_table[] __initconst = {\n\t{ .val = 0, .div = 2 },\n\t{ .val = 1, .div = 2 },\n\t{ .val = 2, .div = 4 },\n\t{ .val = 3, .div = 8 },\n\t{ }  \n};\n\nstatic const struct div_data sun4i_apb0_data __initconst = {\n\t.shift\t= 8,\n\t.pow\t= 1,\n\t.width\t= 2,\n\t.table\t= sun4i_apb0_table,\n};\n\nstatic void __init sunxi_divider_clk_setup(struct device_node *node,\n\t\t\t\t\t   const struct div_data *data)\n{\n\tstruct clk *clk;\n\tconst char *clk_name = node->name;\n\tconst char *clk_parent;\n\tvoid __iomem *reg;\n\n\treg = of_iomap(node, 0);\n\tif (!reg) {\n\t\tpr_err(\"Could not map registers for mux-clk: %pOF\\n\", node);\n\t\treturn;\n\t}\n\n\tclk_parent = of_clk_get_parent_name(node, 0);\n\n\tif (of_property_read_string(node, \"clock-output-names\", &clk_name)) {\n\t\tpr_err(\"%s: could not read clock-output-names from \\\"%pOF\\\"\\n\",\n\t\t       __func__, node);\n\t\tgoto out_unmap;\n\t}\n\n\tclk = clk_register_divider_table(NULL, clk_name, clk_parent, 0,\n\t\t\t\t\t reg, data->shift, data->width,\n\t\t\t\t\t data->pow ? CLK_DIVIDER_POWER_OF_TWO : 0,\n\t\t\t\t\t data->table, &clk_lock);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: failed to register divider clock %s: %ld\\n\",\n\t\t       __func__, clk_name, PTR_ERR(clk));\n\t\tgoto out_unmap;\n\t}\n\n\tif (of_clk_add_provider(node, of_clk_src_simple_get, clk)) {\n\t\tpr_err(\"%s: failed to add clock provider for %s\\n\",\n\t\t       __func__, clk_name);\n\t\tgoto out_unregister;\n\t}\n\n\tif (clk_register_clkdev(clk, clk_name, NULL)) {\n\t\tof_clk_del_provider(node);\n\t\tgoto out_unregister;\n\t}\n\n\treturn;\nout_unregister:\n\tclk_unregister_divider(clk);\n\nout_unmap:\n\tiounmap(reg);\n}\n\nstatic void __init sun4i_ahb_clk_setup(struct device_node *node)\n{\n\tsunxi_divider_clk_setup(node, &sun4i_ahb_data);\n}\nCLK_OF_DECLARE(sun4i_ahb, \"allwinner,sun4i-a10-ahb-clk\",\n\t       sun4i_ahb_clk_setup);\n\nstatic void __init sun4i_apb0_clk_setup(struct device_node *node)\n{\n\tsunxi_divider_clk_setup(node, &sun4i_apb0_data);\n}\nCLK_OF_DECLARE(sun4i_apb0, \"allwinner,sun4i-a10-apb0-clk\",\n\t       sun4i_apb0_clk_setup);\n\nstatic void __init sun4i_axi_clk_setup(struct device_node *node)\n{\n\tsunxi_divider_clk_setup(node, &sun4i_axi_data);\n}\nCLK_OF_DECLARE(sun4i_axi, \"allwinner,sun4i-a10-axi-clk\",\n\t       sun4i_axi_clk_setup);\n\nstatic void __init sun8i_axi_clk_setup(struct device_node *node)\n{\n\tsunxi_divider_clk_setup(node, &sun8i_a23_axi_data);\n}\nCLK_OF_DECLARE(sun8i_axi, \"allwinner,sun8i-a23-axi-clk\",\n\t       sun8i_axi_clk_setup);\n\n\n\n \n\n#define SUNXI_GATES_MAX_SIZE\t64\n\nstruct gates_data {\n\tDECLARE_BITMAP(mask, SUNXI_GATES_MAX_SIZE);\n};\n\n \n\n#define SUNXI_DIVS_MAX_QTY\t4\n#define SUNXI_DIVISOR_WIDTH\t2\n\nstruct divs_data {\n\tconst struct factors_data *factors;  \n\tint ndivs;  \n\t \n\tstruct {\n\t\tu8 self;  \n\t\tu8 fixed;  \n\t\tstruct clk_div_table *table;  \n\t\tu8 shift;  \n\t\tu8 pow;    \n\t\tu8 gate;   \n\t\tbool critical;\n\t} div[SUNXI_DIVS_MAX_QTY];\n};\n\nstatic struct clk_div_table pll6_sata_tbl[] = {\n\t{ .val = 0, .div = 6, },\n\t{ .val = 1, .div = 12, },\n\t{ .val = 2, .div = 18, },\n\t{ .val = 3, .div = 24, },\n\t{ }  \n};\n\nstatic const struct divs_data pll5_divs_data __initconst = {\n\t.factors = &sun4i_pll5_data,\n\t.ndivs = 2,\n\t.div = {\n\t\t \n\t\t{ .shift = 0, .pow = 0, .critical = true },  \n\t\t{ .shift = 16, .pow = 1, },  \n\t\t \n\t}\n};\n\nstatic const struct divs_data pll6_divs_data __initconst = {\n\t.factors = &sun4i_pll5_data,\n\t.ndivs = 4,\n\t.div = {\n\t\t{ .shift = 0, .table = pll6_sata_tbl, .gate = 14 },  \n\t\t{ .fixed = 2 },  \n\t\t{ .self = 1 },  \n\t\t{ .fixed = 4 },  \n\t}\n};\n\nstatic const struct divs_data sun6i_a31_pll6_divs_data __initconst = {\n\t.factors = &sun6i_a31_pll6_data,\n\t.ndivs = 2,\n\t.div = {\n\t\t{ .fixed = 2 },  \n\t\t{ .self = 1 },  \n\t}\n};\n\n \n\nstatic struct clk ** __init sunxi_divs_clk_setup(struct device_node *node,\n\t\t\t\t\t\t const struct divs_data *data)\n{\n\tstruct clk_onecell_data *clk_data;\n\tconst char *parent;\n\tconst char *clk_name;\n\tstruct clk **clks, *pclk;\n\tstruct clk_hw *gate_hw, *rate_hw;\n\tconst struct clk_ops *rate_ops;\n\tstruct clk_gate *gate = NULL;\n\tstruct clk_fixed_factor *fix_factor;\n\tstruct clk_divider *divider;\n\tstruct factors_data factors = *data->factors;\n\tchar *derived_name = NULL;\n\tvoid __iomem *reg;\n\tint ndivs = SUNXI_DIVS_MAX_QTY, i = 0;\n\tint flags, clkflags;\n\n\t \n\tif (data->ndivs)\n\t\tndivs = data->ndivs;\n\n\t \n\tfor (i = 0; i < ndivs; i++) {\n\t\tif (data->div[i].self) {\n\t\t\tof_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t\t      i, &factors.name);\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (factors.name == NULL) {\n\t\tchar *endp;\n\n\t\tof_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t\t      0, &clk_name);\n\t\tendp = strchr(clk_name, '_');\n\t\tif (endp) {\n\t\t\tderived_name = kstrndup(clk_name, endp - clk_name,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!derived_name)\n\t\t\t\treturn NULL;\n\t\t\tfactors.name = derived_name;\n\t\t} else {\n\t\t\tfactors.name = clk_name;\n\t\t}\n\t}\n\n\t \n\tpclk = sunxi_factors_clk_setup(node, &factors);\n\tif (!pclk)\n\t\treturn NULL;\n\n\tparent = __clk_get_name(pclk);\n\tkfree(derived_name);\n\n\treg = of_iomap(node, 0);\n\tif (!reg) {\n\t\tpr_err(\"Could not map registers for divs-clk: %pOF\\n\", node);\n\t\treturn NULL;\n\t}\n\n\tclk_data = kmalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);\n\tif (!clk_data)\n\t\tgoto out_unmap;\n\n\tclks = kcalloc(ndivs, sizeof(*clks), GFP_KERNEL);\n\tif (!clks)\n\t\tgoto free_clkdata;\n\n\tclk_data->clks = clks;\n\n\t \n\tclkflags = !strcmp(\"pll5\", parent) ? 0 : CLK_SET_RATE_PARENT;\n\n\tfor (i = 0; i < ndivs; i++) {\n\t\tif (of_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t\t  i, &clk_name) != 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (data->div[i].self) {\n\t\t\tclk_data->clks[i] = pclk;\n\t\t\tcontinue;\n\t\t}\n\n\t\tgate_hw = NULL;\n\t\trate_hw = NULL;\n\t\trate_ops = NULL;\n\n\t\t \n\t\tif (data->div[i].gate) {\n\t\t\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\t\t\tif (!gate)\n\t\t\t\tgoto free_clks;\n\n\t\t\tgate->reg = reg;\n\t\t\tgate->bit_idx = data->div[i].gate;\n\t\t\tgate->lock = &clk_lock;\n\n\t\t\tgate_hw = &gate->hw;\n\t\t}\n\n\t\t \n\t\tif (data->div[i].fixed) {\n\t\t\tfix_factor = kzalloc(sizeof(*fix_factor), GFP_KERNEL);\n\t\t\tif (!fix_factor)\n\t\t\t\tgoto free_gate;\n\n\t\t\tfix_factor->mult = 1;\n\t\t\tfix_factor->div = data->div[i].fixed;\n\n\t\t\trate_hw = &fix_factor->hw;\n\t\t\trate_ops = &clk_fixed_factor_ops;\n\t\t} else {\n\t\t\tdivider = kzalloc(sizeof(*divider), GFP_KERNEL);\n\t\t\tif (!divider)\n\t\t\t\tgoto free_gate;\n\n\t\t\tflags = data->div[i].pow ? CLK_DIVIDER_POWER_OF_TWO : 0;\n\n\t\t\tdivider->reg = reg;\n\t\t\tdivider->shift = data->div[i].shift;\n\t\t\tdivider->width = SUNXI_DIVISOR_WIDTH;\n\t\t\tdivider->flags = flags;\n\t\t\tdivider->lock = &clk_lock;\n\t\t\tdivider->table = data->div[i].table;\n\n\t\t\trate_hw = &divider->hw;\n\t\t\trate_ops = &clk_divider_ops;\n\t\t}\n\n\t\t \n\t\tclks[i] = clk_register_composite(NULL, clk_name, &parent, 1,\n\t\t\t\t\t\t NULL, NULL,\n\t\t\t\t\t\t rate_hw, rate_ops,\n\t\t\t\t\t\t gate_hw, &clk_gate_ops,\n\t\t\t\t\t\t clkflags |\n\t\t\t\t\t\t (data->div[i].critical ?\n\t\t\t\t\t\t\tCLK_IS_CRITICAL : 0));\n\n\t\tWARN_ON(IS_ERR(clk_data->clks[i]));\n\t}\n\n\t \n\tclk_data->clk_num = i;\n\n\tif (of_clk_add_provider(node, of_clk_src_onecell_get, clk_data)) {\n\t\tpr_err(\"%s: failed to add clock provider for %s\\n\",\n\t\t       __func__, clk_name);\n\t\tgoto free_gate;\n\t}\n\n\treturn clks;\nfree_gate:\n\tkfree(gate);\nfree_clks:\n\tkfree(clks);\nfree_clkdata:\n\tkfree(clk_data);\nout_unmap:\n\tiounmap(reg);\n\treturn NULL;\n}\n\nstatic void __init sun4i_pll5_clk_setup(struct device_node *node)\n{\n\tsunxi_divs_clk_setup(node, &pll5_divs_data);\n}\nCLK_OF_DECLARE(sun4i_pll5, \"allwinner,sun4i-a10-pll5-clk\",\n\t       sun4i_pll5_clk_setup);\n\nstatic void __init sun4i_pll6_clk_setup(struct device_node *node)\n{\n\tsunxi_divs_clk_setup(node, &pll6_divs_data);\n}\nCLK_OF_DECLARE(sun4i_pll6, \"allwinner,sun4i-a10-pll6-clk\",\n\t       sun4i_pll6_clk_setup);\n\nstatic void __init sun6i_pll6_clk_setup(struct device_node *node)\n{\n\tsunxi_divs_clk_setup(node, &sun6i_a31_pll6_divs_data);\n}\nCLK_OF_DECLARE(sun6i_pll6, \"allwinner,sun6i-a31-pll6-clk\",\n\t       sun6i_pll6_clk_setup);\n\n \nstatic void sun6i_display_factors(struct factors_request *req)\n{\n\tu8 m;\n\n\tif (req->rate > req->parent_rate)\n\t\treq->rate = req->parent_rate;\n\n\tm = DIV_ROUND_UP(req->parent_rate, req->rate);\n\n\treq->rate = req->parent_rate / m;\n\treq->m = m - 1;\n}\n\nstatic const struct clk_factors_config sun6i_display_config = {\n\t.mshift = 0,\n\t.mwidth = 4,\n};\n\nstatic const struct factors_data sun6i_display_data __initconst = {\n\t.enable = 31,\n\t.mux = 24,\n\t.muxmask = BIT(2) | BIT(1) | BIT(0),\n\t.table = &sun6i_display_config,\n\t.getter = sun6i_display_factors,\n};\n\nstatic void __init sun6i_display_setup(struct device_node *node)\n{\n\tsunxi_factors_clk_setup(node, &sun6i_display_data);\n}\nCLK_OF_DECLARE(sun6i_display, \"allwinner,sun6i-a31-display-clk\",\n\t       sun6i_display_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}