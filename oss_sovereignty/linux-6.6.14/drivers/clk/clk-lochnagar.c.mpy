{
  "module_name": "clk-lochnagar.c",
  "hash_id": "401feb3bf50590bb2592ea350916218fe3962c84de757e0b8c6ad80f70968268",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-lochnagar.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <linux/mfd/lochnagar1_regs.h>\n#include <linux/mfd/lochnagar2_regs.h>\n\n#include <dt-bindings/clock/lochnagar.h>\n\n#define LOCHNAGAR_NUM_CLOCKS\t(LOCHNAGAR_SPDIF_CLKOUT + 1)\n\nstruct lochnagar_clk {\n\tconst char * const name;\n\tstruct clk_hw hw;\n\n\tstruct lochnagar_clk_priv *priv;\n\n\tu16 cfg_reg;\n\tu16 ena_mask;\n\n\tu16 src_reg;\n\tu16 src_mask;\n};\n\nstruct lochnagar_clk_priv {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\n\tstruct lochnagar_clk lclks[LOCHNAGAR_NUM_CLOCKS];\n};\n\n#define LN_PARENT(NAME) { .name = NAME, .fw_name = NAME }\n\nstatic const struct clk_parent_data lochnagar1_clk_parents[] = {\n\tLN_PARENT(\"ln-none\"),\n\tLN_PARENT(\"ln-spdif-mclk\"),\n\tLN_PARENT(\"ln-psia1-mclk\"),\n\tLN_PARENT(\"ln-psia2-mclk\"),\n\tLN_PARENT(\"ln-cdc-clkout\"),\n\tLN_PARENT(\"ln-dsp-clkout\"),\n\tLN_PARENT(\"ln-pmic-32k\"),\n\tLN_PARENT(\"ln-gf-mclk1\"),\n\tLN_PARENT(\"ln-gf-mclk3\"),\n\tLN_PARENT(\"ln-gf-mclk2\"),\n\tLN_PARENT(\"ln-gf-mclk4\"),\n};\n\nstatic const struct clk_parent_data lochnagar2_clk_parents[] = {\n\tLN_PARENT(\"ln-none\"),\n\tLN_PARENT(\"ln-cdc-clkout\"),\n\tLN_PARENT(\"ln-dsp-clkout\"),\n\tLN_PARENT(\"ln-pmic-32k\"),\n\tLN_PARENT(\"ln-spdif-mclk\"),\n\tLN_PARENT(\"ln-clk-12m\"),\n\tLN_PARENT(\"ln-clk-11m\"),\n\tLN_PARENT(\"ln-clk-24m\"),\n\tLN_PARENT(\"ln-clk-22m\"),\n\tLN_PARENT(\"ln-clk-8m\"),\n\tLN_PARENT(\"ln-usb-clk-24m\"),\n\tLN_PARENT(\"ln-gf-mclk1\"),\n\tLN_PARENT(\"ln-gf-mclk3\"),\n\tLN_PARENT(\"ln-gf-mclk2\"),\n\tLN_PARENT(\"ln-psia1-mclk\"),\n\tLN_PARENT(\"ln-psia2-mclk\"),\n\tLN_PARENT(\"ln-spdif-clkout\"),\n\tLN_PARENT(\"ln-adat-mclk\"),\n\tLN_PARENT(\"ln-usb-clk-12m\"),\n};\n\n#define LN1_CLK(ID, NAME, REG) \\\n\t[LOCHNAGAR_##ID] = { \\\n\t\t.name = NAME, \\\n\t\t.cfg_reg = LOCHNAGAR1_##REG, \\\n\t\t.ena_mask = LOCHNAGAR1_##ID##_ENA_MASK, \\\n\t\t.src_reg = LOCHNAGAR1_##ID##_SEL, \\\n\t\t.src_mask = LOCHNAGAR1_SRC_MASK, \\\n\t}\n\n#define LN2_CLK(ID, NAME) \\\n\t[LOCHNAGAR_##ID] = { \\\n\t\t.name = NAME, \\\n\t\t.cfg_reg = LOCHNAGAR2_##ID##_CTRL, \\\n\t\t.src_reg = LOCHNAGAR2_##ID##_CTRL, \\\n\t\t.ena_mask = LOCHNAGAR2_CLK_ENA_MASK, \\\n\t\t.src_mask = LOCHNAGAR2_CLK_SRC_MASK, \\\n\t}\n\nstatic const struct lochnagar_clk lochnagar1_clks[LOCHNAGAR_NUM_CLOCKS] = {\n\tLN1_CLK(CDC_MCLK1,      \"ln-cdc-mclk1\",  CDC_AIF_CTRL2),\n\tLN1_CLK(CDC_MCLK2,      \"ln-cdc-mclk2\",  CDC_AIF_CTRL2),\n\tLN1_CLK(DSP_CLKIN,      \"ln-dsp-clkin\",  DSP_AIF),\n\tLN1_CLK(GF_CLKOUT1,     \"ln-gf-clkout1\", GF_AIF1),\n};\n\nstatic const struct lochnagar_clk lochnagar2_clks[LOCHNAGAR_NUM_CLOCKS] = {\n\tLN2_CLK(CDC_MCLK1,      \"ln-cdc-mclk1\"),\n\tLN2_CLK(CDC_MCLK2,      \"ln-cdc-mclk2\"),\n\tLN2_CLK(DSP_CLKIN,      \"ln-dsp-clkin\"),\n\tLN2_CLK(GF_CLKOUT1,     \"ln-gf-clkout1\"),\n\tLN2_CLK(GF_CLKOUT2,     \"ln-gf-clkout2\"),\n\tLN2_CLK(PSIA1_MCLK,     \"ln-psia1-mclk\"),\n\tLN2_CLK(PSIA2_MCLK,     \"ln-psia2-mclk\"),\n\tLN2_CLK(SPDIF_MCLK,     \"ln-spdif-mclk\"),\n\tLN2_CLK(ADAT_MCLK,      \"ln-adat-mclk\"),\n\tLN2_CLK(SOUNDCARD_MCLK, \"ln-soundcard-mclk\"),\n};\n\nstruct lochnagar_config {\n\tconst struct clk_parent_data *parents;\n\tint nparents;\n\tconst struct lochnagar_clk *clks;\n};\n\nstatic const struct lochnagar_config lochnagar1_conf = {\n\t.parents = lochnagar1_clk_parents,\n\t.nparents = ARRAY_SIZE(lochnagar1_clk_parents),\n\t.clks = lochnagar1_clks,\n};\n\nstatic const struct lochnagar_config lochnagar2_conf = {\n\t.parents = lochnagar2_clk_parents,\n\t.nparents = ARRAY_SIZE(lochnagar2_clk_parents),\n\t.clks = lochnagar2_clks,\n};\n\nstatic inline struct lochnagar_clk *lochnagar_hw_to_lclk(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct lochnagar_clk, hw);\n}\n\nstatic int lochnagar_clk_prepare(struct clk_hw *hw)\n{\n\tstruct lochnagar_clk *lclk = lochnagar_hw_to_lclk(hw);\n\tstruct lochnagar_clk_priv *priv = lclk->priv;\n\tstruct regmap *regmap = priv->regmap;\n\tint ret;\n\n\tret = regmap_update_bits(regmap, lclk->cfg_reg,\n\t\t\t\t lclk->ena_mask, lclk->ena_mask);\n\tif (ret < 0)\n\t\tdev_dbg(priv->dev, \"Failed to prepare %s: %d\\n\",\n\t\t\tlclk->name, ret);\n\n\treturn ret;\n}\n\nstatic void lochnagar_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct lochnagar_clk *lclk = lochnagar_hw_to_lclk(hw);\n\tstruct lochnagar_clk_priv *priv = lclk->priv;\n\tstruct regmap *regmap = priv->regmap;\n\tint ret;\n\n\tret = regmap_update_bits(regmap, lclk->cfg_reg, lclk->ena_mask, 0);\n\tif (ret < 0)\n\t\tdev_dbg(priv->dev, \"Failed to unprepare %s: %d\\n\",\n\t\t\tlclk->name, ret);\n}\n\nstatic int lochnagar_clk_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct lochnagar_clk *lclk = lochnagar_hw_to_lclk(hw);\n\tstruct lochnagar_clk_priv *priv = lclk->priv;\n\tstruct regmap *regmap = priv->regmap;\n\tint ret;\n\n\tret = regmap_update_bits(regmap, lclk->src_reg, lclk->src_mask, index);\n\tif (ret < 0)\n\t\tdev_dbg(priv->dev, \"Failed to reparent %s: %d\\n\",\n\t\t\tlclk->name, ret);\n\n\treturn ret;\n}\n\nstatic u8 lochnagar_clk_get_parent(struct clk_hw *hw)\n{\n\tstruct lochnagar_clk *lclk = lochnagar_hw_to_lclk(hw);\n\tstruct lochnagar_clk_priv *priv = lclk->priv;\n\tstruct regmap *regmap = priv->regmap;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(regmap, lclk->src_reg, &val);\n\tif (ret < 0) {\n\t\tdev_dbg(priv->dev, \"Failed to read parent of %s: %d\\n\",\n\t\t\tlclk->name, ret);\n\t\treturn clk_hw_get_num_parents(hw);\n\t}\n\n\tval &= lclk->src_mask;\n\n\treturn val;\n}\n\nstatic const struct clk_ops lochnagar_clk_ops = {\n\t.prepare = lochnagar_clk_prepare,\n\t.unprepare = lochnagar_clk_unprepare,\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.set_parent = lochnagar_clk_set_parent,\n\t.get_parent = lochnagar_clk_get_parent,\n};\n\nstatic struct clk_hw *\nlochnagar_of_clk_hw_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct lochnagar_clk_priv *priv = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= ARRAY_SIZE(priv->lclks)) {\n\t\tdev_err(priv->dev, \"Invalid index %u\\n\", idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &priv->lclks[idx].hw;\n}\n\nstatic const struct of_device_id lochnagar_of_match[] = {\n\t{ .compatible = \"cirrus,lochnagar1-clk\", .data = &lochnagar1_conf },\n\t{ .compatible = \"cirrus,lochnagar2-clk\", .data = &lochnagar2_conf },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, lochnagar_of_match);\n\nstatic int lochnagar_clk_probe(struct platform_device *pdev)\n{\n\tstruct clk_init_data clk_init = {\n\t\t.ops = &lochnagar_clk_ops,\n\t};\n\tstruct device *dev = &pdev->dev;\n\tstruct lochnagar_clk_priv *priv;\n\tconst struct of_device_id *of_id;\n\tstruct lochnagar_clk *lclk;\n\tstruct lochnagar_config *conf;\n\tint ret, i;\n\n\tof_id = of_match_device(lochnagar_of_match, dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->regmap = dev_get_regmap(dev->parent, NULL);\n\tconf = (struct lochnagar_config *)of_id->data;\n\n\tmemcpy(priv->lclks, conf->clks, sizeof(priv->lclks));\n\n\tclk_init.parent_data = conf->parents;\n\tclk_init.num_parents = conf->nparents;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->lclks); i++) {\n\t\tlclk = &priv->lclks[i];\n\n\t\tif (!lclk->name)\n\t\t\tcontinue;\n\n\t\tclk_init.name = lclk->name;\n\n\t\tlclk->priv = priv;\n\t\tlclk->hw.init = &clk_init;\n\n\t\tret = devm_clk_hw_register(dev, &lclk->hw);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to register %s: %d\\n\",\n\t\t\t\tlclk->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = devm_of_clk_add_hw_provider(dev, lochnagar_of_clk_hw_get, priv);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to register provider: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic struct platform_driver lochnagar_clk_driver = {\n\t.driver = {\n\t\t.name = \"lochnagar-clk\",\n\t\t.of_match_table = lochnagar_of_match,\n\t},\n\t.probe = lochnagar_clk_probe,\n};\nmodule_platform_driver(lochnagar_clk_driver);\n\nMODULE_AUTHOR(\"Charles Keepax <ckeepax@opensource.cirrus.com>\");\nMODULE_DESCRIPTION(\"Clock driver for Cirrus Logic Lochnagar Board\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}