{
  "module_name": "clk-lpc18xx-creg.c",
  "hash_id": "74bb81d522143f6355d4347944a60033f7bae379f53490c2e48dafa18485d596",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/nxp/clk-lpc18xx-creg.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define LPC18XX_CREG_CREG0\t\t\t0x004\n#define  LPC18XX_CREG_CREG0_EN1KHZ\t\tBIT(0)\n#define  LPC18XX_CREG_CREG0_EN32KHZ\t\tBIT(1)\n#define  LPC18XX_CREG_CREG0_RESET32KHZ\t\tBIT(2)\n#define  LPC18XX_CREG_CREG0_PD32KHZ\t\tBIT(3)\n\n#define to_clk_creg(_hw) container_of(_hw, struct clk_creg_data, hw)\n\nenum {\n\tCREG_CLK_1KHZ,\n\tCREG_CLK_32KHZ,\n\tCREG_CLK_MAX,\n};\n\nstruct clk_creg_data {\n\tstruct clk_hw hw;\n\tconst char *name;\n\tstruct regmap *reg;\n\tunsigned int en_mask;\n\tconst struct clk_ops *ops;\n};\n\n#define CREG_CLK(_name, _emask, _ops)\t\t\\\n{\t\t\t\t\t\t\\\n\t.name = _name,\t\t\t\t\\\n\t.en_mask = LPC18XX_CREG_CREG0_##_emask,\t\\\n\t.ops = &_ops,\t\t\t\t\\\n}\n\nstatic int clk_creg_32k_prepare(struct clk_hw *hw)\n{\n\tstruct clk_creg_data *creg = to_clk_creg(hw);\n\tint ret;\n\n\tret = regmap_update_bits(creg->reg, LPC18XX_CREG_CREG0,\n\t\t\t\t LPC18XX_CREG_CREG0_PD32KHZ |\n\t\t\t\t LPC18XX_CREG_CREG0_RESET32KHZ, 0);\n\n\t \n\tmsleep(2500);\n\n\treturn ret;\n}\n\nstatic void clk_creg_32k_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_creg_data *creg = to_clk_creg(hw);\n\n\tregmap_update_bits(creg->reg, LPC18XX_CREG_CREG0,\n\t\t\t   LPC18XX_CREG_CREG0_PD32KHZ,\n\t\t\t   LPC18XX_CREG_CREG0_PD32KHZ);\n}\n\nstatic int clk_creg_32k_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_creg_data *creg = to_clk_creg(hw);\n\tu32 reg;\n\n\tregmap_read(creg->reg, LPC18XX_CREG_CREG0, &reg);\n\n\treturn !(reg & LPC18XX_CREG_CREG0_PD32KHZ) &&\n\t       !(reg & LPC18XX_CREG_CREG0_RESET32KHZ);\n}\n\nstatic unsigned long clk_creg_1k_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\treturn parent_rate / 32;\n}\n\nstatic int clk_creg_enable(struct clk_hw *hw)\n{\n\tstruct clk_creg_data *creg = to_clk_creg(hw);\n\n\treturn regmap_update_bits(creg->reg, LPC18XX_CREG_CREG0,\n\t\t\t\t  creg->en_mask, creg->en_mask);\n}\n\nstatic void clk_creg_disable(struct clk_hw *hw)\n{\n\tstruct clk_creg_data *creg = to_clk_creg(hw);\n\n\tregmap_update_bits(creg->reg, LPC18XX_CREG_CREG0,\n\t\t\t   creg->en_mask, 0);\n}\n\nstatic int clk_creg_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_creg_data *creg = to_clk_creg(hw);\n\tu32 reg;\n\n\tregmap_read(creg->reg, LPC18XX_CREG_CREG0, &reg);\n\n\treturn !!(reg & creg->en_mask);\n}\n\nstatic const struct clk_ops clk_creg_32k = {\n\t.enable\t\t= clk_creg_enable,\n\t.disable\t= clk_creg_disable,\n\t.is_enabled\t= clk_creg_is_enabled,\n\t.prepare\t= clk_creg_32k_prepare,\n\t.unprepare\t= clk_creg_32k_unprepare,\n\t.is_prepared\t= clk_creg_32k_is_prepared,\n};\n\nstatic const struct clk_ops clk_creg_1k = {\n\t.enable\t\t= clk_creg_enable,\n\t.disable\t= clk_creg_disable,\n\t.is_enabled\t= clk_creg_is_enabled,\n\t.recalc_rate\t= clk_creg_1k_recalc_rate,\n};\n\nstatic struct clk_creg_data clk_creg_clocks[] = {\n\t[CREG_CLK_1KHZ]  = CREG_CLK(\"1khz_clk\",  EN1KHZ,  clk_creg_1k),\n\t[CREG_CLK_32KHZ] = CREG_CLK(\"32khz_clk\", EN32KHZ, clk_creg_32k),\n};\n\nstatic struct clk *clk_register_creg_clk(struct device *dev,\n\t\t\t\t\t struct clk_creg_data *creg_clk,\n\t\t\t\t\t const char **parent_name,\n\t\t\t\t\t struct regmap *syscon)\n{\n\tstruct clk_init_data init;\n\n\tinit.ops = creg_clk->ops;\n\tinit.name = creg_clk->name;\n\tinit.parent_names = parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = 0;\n\n\tcreg_clk->reg = syscon;\n\tcreg_clk->hw.init = &init;\n\n\tif (dev)\n\t\treturn devm_clk_register(dev, &creg_clk->hw);\n\n\treturn clk_register(NULL, &creg_clk->hw);\n}\n\nstatic struct clk *clk_creg_early[CREG_CLK_MAX];\nstatic struct clk_onecell_data clk_creg_early_data = {\n\t.clks = clk_creg_early,\n\t.clk_num = CREG_CLK_MAX,\n};\n\nstatic void __init lpc18xx_creg_clk_init(struct device_node *np)\n{\n\tconst char *clk_32khz_parent;\n\tstruct regmap *syscon;\n\n\tsyscon = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(syscon)) {\n\t\tpr_err(\"%s: syscon lookup failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\tclk_32khz_parent = of_clk_get_parent_name(np, 0);\n\n\tclk_creg_early[CREG_CLK_32KHZ] =\n\t\tclk_register_creg_clk(NULL, &clk_creg_clocks[CREG_CLK_32KHZ],\n\t\t\t\t      &clk_32khz_parent, syscon);\n\tclk_creg_early[CREG_CLK_1KHZ] = ERR_PTR(-EPROBE_DEFER);\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &clk_creg_early_data);\n}\nCLK_OF_DECLARE_DRIVER(lpc18xx_creg_clk, \"nxp,lpc1850-creg-clk\",\n\t\t      lpc18xx_creg_clk_init);\n\nstatic struct clk *clk_creg[CREG_CLK_MAX];\nstatic struct clk_onecell_data clk_creg_data = {\n\t.clks = clk_creg,\n\t.clk_num = CREG_CLK_MAX,\n};\n\nstatic int lpc18xx_creg_clk_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct regmap *syscon;\n\n\tsyscon = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(syscon)) {\n\t\tdev_err(&pdev->dev, \"syscon lookup failed\\n\");\n\t\treturn PTR_ERR(syscon);\n\t}\n\n\tclk_creg[CREG_CLK_32KHZ] = clk_creg_early[CREG_CLK_32KHZ];\n\tclk_creg[CREG_CLK_1KHZ] =\n\t\tclk_register_creg_clk(NULL, &clk_creg_clocks[CREG_CLK_1KHZ],\n\t\t\t\t      &clk_creg_clocks[CREG_CLK_32KHZ].name,\n\t\t\t\t      syscon);\n\n\treturn of_clk_add_provider(np, of_clk_src_onecell_get, &clk_creg_data);\n}\n\nstatic const struct of_device_id lpc18xx_creg_clk_of_match[] = {\n\t{ .compatible = \"nxp,lpc1850-creg-clk\" },\n\t{},\n};\n\nstatic struct platform_driver lpc18xx_creg_clk_driver = {\n\t.probe = lpc18xx_creg_clk_probe,\n\t.driver = {\n\t\t.name = \"lpc18xx-creg-clk\",\n\t\t.of_match_table = lpc18xx_creg_clk_of_match,\n\t},\n};\nbuiltin_platform_driver(lpc18xx_creg_clk_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}