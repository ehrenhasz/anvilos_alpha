{
  "module_name": "clk-lpc18xx-cgu.c",
  "hash_id": "e550eadf43ebb1f65285b0a4e3f6f94e4f1a600e42eb0526d836d85e71e9de19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/nxp/clk-lpc18xx-cgu.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n#include <dt-bindings/clock/lpc18xx-cgu.h>\n\n \n#define LPC18XX_CGU_XTAL_OSC_CTRL\t0x018\n#define LPC18XX_CGU_PLL0USB_STAT\t0x01c\n#define LPC18XX_CGU_PLL0USB_CTRL\t0x020\n#define LPC18XX_CGU_PLL0USB_MDIV\t0x024\n#define LPC18XX_CGU_PLL0USB_NP_DIV\t0x028\n#define LPC18XX_CGU_PLL0AUDIO_STAT\t0x02c\n#define LPC18XX_CGU_PLL0AUDIO_CTRL\t0x030\n#define LPC18XX_CGU_PLL0AUDIO_MDIV\t0x034\n#define LPC18XX_CGU_PLL0AUDIO_NP_DIV\t0x038\n#define LPC18XX_CGU_PLL0AUDIO_FRAC\t0x03c\n#define LPC18XX_CGU_PLL1_STAT\t\t0x040\n#define LPC18XX_CGU_PLL1_CTRL\t\t0x044\n#define  LPC18XX_PLL1_CTRL_FBSEL\tBIT(6)\n#define  LPC18XX_PLL1_CTRL_DIRECT\tBIT(7)\n#define LPC18XX_CGU_IDIV_CTRL(n)\t(0x048 + (n) * sizeof(u32))\n#define LPC18XX_CGU_BASE_CLK(id)\t(0x05c + (id) * sizeof(u32))\n#define LPC18XX_CGU_PLL_CTRL_OFFSET\t0x4\n\n \n#define LPC18XX_PLL0_STAT_LOCK\t\tBIT(0)\n#define LPC18XX_PLL0_CTRL_PD\t\tBIT(0)\n#define LPC18XX_PLL0_CTRL_BYPASS\tBIT(1)\n#define LPC18XX_PLL0_CTRL_DIRECTI\tBIT(2)\n#define LPC18XX_PLL0_CTRL_DIRECTO\tBIT(3)\n#define LPC18XX_PLL0_CTRL_CLKEN\t\tBIT(4)\n#define LPC18XX_PLL0_MDIV_MDEC_MASK\t0x1ffff\n#define LPC18XX_PLL0_MDIV_SELP_SHIFT\t17\n#define LPC18XX_PLL0_MDIV_SELI_SHIFT\t22\n#define LPC18XX_PLL0_MSEL_MAX\t\tBIT(15)\n\n \n#define LPC18XX_PLL0_NP_DIVS_1\t\t0x00302062\n\nenum {\n\tCLK_SRC_OSC32,\n\tCLK_SRC_IRC,\n\tCLK_SRC_ENET_RX_CLK,\n\tCLK_SRC_ENET_TX_CLK,\n\tCLK_SRC_GP_CLKIN,\n\tCLK_SRC_RESERVED1,\n\tCLK_SRC_OSC,\n\tCLK_SRC_PLL0USB,\n\tCLK_SRC_PLL0AUDIO,\n\tCLK_SRC_PLL1,\n\tCLK_SRC_RESERVED2,\n\tCLK_SRC_RESERVED3,\n\tCLK_SRC_IDIVA,\n\tCLK_SRC_IDIVB,\n\tCLK_SRC_IDIVC,\n\tCLK_SRC_IDIVD,\n\tCLK_SRC_IDIVE,\n\tCLK_SRC_MAX\n};\n\nstatic const char *clk_src_names[CLK_SRC_MAX] = {\n\t[CLK_SRC_OSC32]\t\t= \"osc32\",\n\t[CLK_SRC_IRC]\t\t= \"irc\",\n\t[CLK_SRC_ENET_RX_CLK]\t= \"enet_rx_clk\",\n\t[CLK_SRC_ENET_TX_CLK]\t= \"enet_tx_clk\",\n\t[CLK_SRC_GP_CLKIN]\t= \"gp_clkin\",\n\t[CLK_SRC_OSC]\t\t= \"osc\",\n\t[CLK_SRC_PLL0USB]\t= \"pll0usb\",\n\t[CLK_SRC_PLL0AUDIO]\t= \"pll0audio\",\n\t[CLK_SRC_PLL1]\t\t= \"pll1\",\n\t[CLK_SRC_IDIVA]\t\t= \"idiva\",\n\t[CLK_SRC_IDIVB]\t\t= \"idivb\",\n\t[CLK_SRC_IDIVC]\t\t= \"idivc\",\n\t[CLK_SRC_IDIVD]\t\t= \"idivd\",\n\t[CLK_SRC_IDIVE]\t\t= \"idive\",\n};\n\nstatic const char *clk_base_names[BASE_CLK_MAX] = {\n\t[BASE_SAFE_CLK]\t\t= \"base_safe_clk\",\n\t[BASE_USB0_CLK]\t\t= \"base_usb0_clk\",\n\t[BASE_PERIPH_CLK]\t= \"base_periph_clk\",\n\t[BASE_USB1_CLK]\t\t= \"base_usb1_clk\",\n\t[BASE_CPU_CLK]\t\t= \"base_cpu_clk\",\n\t[BASE_SPIFI_CLK]\t= \"base_spifi_clk\",\n\t[BASE_SPI_CLK]\t\t= \"base_spi_clk\",\n\t[BASE_PHY_RX_CLK]\t= \"base_phy_rx_clk\",\n\t[BASE_PHY_TX_CLK]\t= \"base_phy_tx_clk\",\n\t[BASE_APB1_CLK]\t\t= \"base_apb1_clk\",\n\t[BASE_APB3_CLK]\t\t= \"base_apb3_clk\",\n\t[BASE_LCD_CLK]\t\t= \"base_lcd_clk\",\n\t[BASE_ADCHS_CLK]\t= \"base_adchs_clk\",\n\t[BASE_SDIO_CLK]\t\t= \"base_sdio_clk\",\n\t[BASE_SSP0_CLK]\t\t= \"base_ssp0_clk\",\n\t[BASE_SSP1_CLK]\t\t= \"base_ssp1_clk\",\n\t[BASE_UART0_CLK]\t= \"base_uart0_clk\",\n\t[BASE_UART1_CLK]\t= \"base_uart1_clk\",\n\t[BASE_UART2_CLK]\t= \"base_uart2_clk\",\n\t[BASE_UART3_CLK]\t= \"base_uart3_clk\",\n\t[BASE_OUT_CLK]\t\t= \"base_out_clk\",\n\t[BASE_AUDIO_CLK]\t= \"base_audio_clk\",\n\t[BASE_CGU_OUT0_CLK]\t= \"base_cgu_out0_clk\",\n\t[BASE_CGU_OUT1_CLK]\t= \"base_cgu_out1_clk\",\n};\n\nstatic u32 lpc18xx_cgu_pll0_src_ids[] = {\n\tCLK_SRC_OSC32, CLK_SRC_IRC, CLK_SRC_ENET_RX_CLK,\n\tCLK_SRC_ENET_TX_CLK, CLK_SRC_GP_CLKIN, CLK_SRC_OSC,\n\tCLK_SRC_PLL1, CLK_SRC_IDIVA, CLK_SRC_IDIVB, CLK_SRC_IDIVC,\n\tCLK_SRC_IDIVD, CLK_SRC_IDIVE,\n};\n\nstatic u32 lpc18xx_cgu_pll1_src_ids[] = {\n\tCLK_SRC_OSC32, CLK_SRC_IRC, CLK_SRC_ENET_RX_CLK,\n\tCLK_SRC_ENET_TX_CLK, CLK_SRC_GP_CLKIN, CLK_SRC_OSC,\n\tCLK_SRC_PLL0USB, CLK_SRC_PLL0AUDIO, CLK_SRC_IDIVA,\n\tCLK_SRC_IDIVB, CLK_SRC_IDIVC, CLK_SRC_IDIVD, CLK_SRC_IDIVE,\n};\n\nstatic u32 lpc18xx_cgu_idiva_src_ids[] = {\n\tCLK_SRC_OSC32, CLK_SRC_IRC, CLK_SRC_ENET_RX_CLK,\n\tCLK_SRC_ENET_TX_CLK, CLK_SRC_GP_CLKIN, CLK_SRC_OSC,\n\tCLK_SRC_PLL0USB, CLK_SRC_PLL0AUDIO, CLK_SRC_PLL1\n};\n\nstatic u32 lpc18xx_cgu_idivbcde_src_ids[] = {\n\tCLK_SRC_OSC32, CLK_SRC_IRC, CLK_SRC_ENET_RX_CLK,\n\tCLK_SRC_ENET_TX_CLK, CLK_SRC_GP_CLKIN, CLK_SRC_OSC,\n\tCLK_SRC_PLL0AUDIO, CLK_SRC_PLL1, CLK_SRC_IDIVA,\n};\n\nstatic u32 lpc18xx_cgu_base_irc_src_ids[] = {CLK_SRC_IRC};\n\nstatic u32 lpc18xx_cgu_base_usb0_src_ids[] = {CLK_SRC_PLL0USB};\n\nstatic u32 lpc18xx_cgu_base_common_src_ids[] = {\n\tCLK_SRC_OSC32, CLK_SRC_IRC, CLK_SRC_ENET_RX_CLK,\n\tCLK_SRC_ENET_TX_CLK, CLK_SRC_GP_CLKIN, CLK_SRC_OSC,\n\tCLK_SRC_PLL0AUDIO, CLK_SRC_PLL1, CLK_SRC_IDIVA,\n\tCLK_SRC_IDIVB, CLK_SRC_IDIVC, CLK_SRC_IDIVD, CLK_SRC_IDIVE,\n};\n\nstatic u32 lpc18xx_cgu_base_all_src_ids[] = {\n\tCLK_SRC_OSC32, CLK_SRC_IRC, CLK_SRC_ENET_RX_CLK,\n\tCLK_SRC_ENET_TX_CLK, CLK_SRC_GP_CLKIN, CLK_SRC_OSC,\n\tCLK_SRC_PLL0USB, CLK_SRC_PLL0AUDIO, CLK_SRC_PLL1,\n\tCLK_SRC_IDIVA, CLK_SRC_IDIVB, CLK_SRC_IDIVC,\n\tCLK_SRC_IDIVD, CLK_SRC_IDIVE,\n};\n\nstruct lpc18xx_cgu_src_clk_div {\n\tu8 clk_id;\n\tu8 n_parents;\n\tstruct clk_divider\tdiv;\n\tstruct clk_mux\t\tmux;\n\tstruct clk_gate\t\tgate;\n};\n\n#define LPC1XX_CGU_SRC_CLK_DIV(_id, _width, _table)\t\\\n{\t\t\t\t\t\t\t\\\n\t.clk_id = CLK_SRC_ ##_id,\t\t\t\\\n\t.n_parents = ARRAY_SIZE(lpc18xx_cgu_ ##_table),\t\\\n\t.div = {\t\t\t\t\t\\\n\t\t.shift = 2,\t\t\t\t\\\n\t\t.width = _width,\t\t\t\\\n\t},\t\t\t\t\t\t\\\n\t.mux = {\t\t\t\t\t\\\n\t\t.mask = 0x1f,\t\t\t\t\\\n\t\t.shift = 24,\t\t\t\t\\\n\t\t.table = lpc18xx_cgu_ ##_table,\t\t\\\n\t},\t\t\t\t\t\t\\\n\t.gate = {\t\t\t\t\t\\\n\t\t.bit_idx = 0,\t\t\t\t\\\n\t\t.flags = CLK_GATE_SET_TO_DISABLE,\t\\\n\t},\t\t\t\t\t\t\\\n}\n\nstatic struct lpc18xx_cgu_src_clk_div lpc18xx_cgu_src_clk_divs[] = {\n\tLPC1XX_CGU_SRC_CLK_DIV(IDIVA, 2, idiva_src_ids),\n\tLPC1XX_CGU_SRC_CLK_DIV(IDIVB, 4, idivbcde_src_ids),\n\tLPC1XX_CGU_SRC_CLK_DIV(IDIVC, 4, idivbcde_src_ids),\n\tLPC1XX_CGU_SRC_CLK_DIV(IDIVD, 4, idivbcde_src_ids),\n\tLPC1XX_CGU_SRC_CLK_DIV(IDIVE, 8, idivbcde_src_ids),\n};\n\nstruct lpc18xx_cgu_base_clk {\n\tu8 clk_id;\n\tu8 n_parents;\n\tstruct clk_mux mux;\n\tstruct clk_gate gate;\n};\n\n#define LPC1XX_CGU_BASE_CLK(_id, _table, _flags)\t\\\n{\t\t\t\t\t\t\t\\\n\t.clk_id = BASE_ ##_id ##_CLK,\t\t\t\\\n\t.n_parents = ARRAY_SIZE(lpc18xx_cgu_ ##_table),\t\\\n\t.mux = {\t\t\t\t\t\\\n\t\t.mask = 0x1f,\t\t\t\t\\\n\t\t.shift = 24,\t\t\t\t\\\n\t\t.table = lpc18xx_cgu_ ##_table,\t\t\\\n\t\t.flags = _flags,\t\t\t\\\n\t},\t\t\t\t\t\t\\\n\t.gate = {\t\t\t\t\t\\\n\t\t.bit_idx = 0,\t\t\t\t\\\n\t\t.flags = CLK_GATE_SET_TO_DISABLE,\t\\\n\t},\t\t\t\t\t\t\\\n}\n\nstatic struct lpc18xx_cgu_base_clk lpc18xx_cgu_base_clks[] = {\n\tLPC1XX_CGU_BASE_CLK(SAFE,\tbase_irc_src_ids, CLK_MUX_READ_ONLY),\n\tLPC1XX_CGU_BASE_CLK(USB0,\tbase_usb0_src_ids,   0),\n\tLPC1XX_CGU_BASE_CLK(PERIPH,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(USB1,\tbase_all_src_ids,    0),\n\tLPC1XX_CGU_BASE_CLK(CPU,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(SPIFI,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(SPI,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(PHY_RX,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(PHY_TX,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(APB1,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(APB3,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(LCD,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(ADCHS,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(SDIO,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(SSP0,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(SSP1,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(UART0,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(UART1,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(UART2,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(UART3,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(OUT,\tbase_all_src_ids,    0),\n\t{   },\n\t{   },\n\t{   },\n\t{   },\n\tLPC1XX_CGU_BASE_CLK(AUDIO,\tbase_common_src_ids, 0),\n\tLPC1XX_CGU_BASE_CLK(CGU_OUT0,\tbase_all_src_ids,    0),\n\tLPC1XX_CGU_BASE_CLK(CGU_OUT1,\tbase_all_src_ids,    0),\n};\n\nstruct lpc18xx_pll {\n\tstruct\t\tclk_hw hw;\n\tvoid __iomem\t*reg;\n\tspinlock_t\t*lock;\n\tu8\t\tflags;\n};\n\n#define to_lpc_pll(hw) container_of(hw, struct lpc18xx_pll, hw)\n\nstruct lpc18xx_cgu_pll_clk {\n\tu8 clk_id;\n\tu8 n_parents;\n\tu8 reg_offset;\n\tstruct clk_mux mux;\n\tstruct clk_gate gate;\n\tstruct lpc18xx_pll pll;\n\tconst struct clk_ops *pll_ops;\n};\n\n#define LPC1XX_CGU_CLK_PLL(_id, _table, _pll_ops)\t\\\n{\t\t\t\t\t\t\t\\\n\t.clk_id = CLK_SRC_ ##_id,\t\t\t\\\n\t.n_parents = ARRAY_SIZE(lpc18xx_cgu_ ##_table),\t\\\n\t.reg_offset = LPC18XX_CGU_ ##_id ##_STAT,\t\\\n\t.mux = {\t\t\t\t\t\\\n\t\t.mask = 0x1f,\t\t\t\t\\\n\t\t.shift = 24,\t\t\t\t\\\n\t\t.table = lpc18xx_cgu_ ##_table,\t\t\\\n\t},\t\t\t\t\t\t\\\n\t.gate = {\t\t\t\t\t\\\n\t\t.bit_idx = 0,\t\t\t\t\\\n\t\t.flags = CLK_GATE_SET_TO_DISABLE,\t\\\n\t},\t\t\t\t\t\t\\\n\t.pll_ops = &lpc18xx_ ##_pll_ops,\t\t\\\n}\n\n \n\n \nstatic u32 lpc18xx_pll0_mdec2msel(u32 x)\n{\n\tint i;\n\n\tswitch (x) {\n\tcase 0x18003: return 1;\n\tcase 0x10003: return 2;\n\tdefault:\n\t\tfor (i = LPC18XX_PLL0_MSEL_MAX + 1; x != 0x4000 && i > 0; i--)\n\t\t\tx = ((x ^ x >> 14) & 1) | (x << 1 & 0x7fff);\n\t\treturn i;\n\t}\n}\n \nstatic u32 lpc18xx_pll0_msel2mdec(u32 msel)\n{\n\tu32 i, x = 0x4000;\n\n\tswitch (msel) {\n\tcase 0: return 0;\n\tcase 1: return 0x18003;\n\tcase 2: return 0x10003;\n\tdefault:\n\t\tfor (i = msel; i <= LPC18XX_PLL0_MSEL_MAX; i++)\n\t\t\tx = ((x ^ x >> 1) & 1) << 14 | (x >> 1 & 0xffff);\n\t\treturn x;\n\t}\n}\n\n \nstatic u32 lpc18xx_pll0_msel2seli(u32 msel)\n{\n\tu32 tmp;\n\n\tif (msel > 16384) return 1;\n\tif (msel >  8192) return 2;\n\tif (msel >  2048) return 4;\n\tif (msel >=  501) return 8;\n\tif (msel >=   60) {\n\t\ttmp = 1024 / (msel + 9);\n\t\treturn ((1024 == (tmp * (msel + 9))) == 0) ? tmp * 4 : (tmp + 1) * 4;\n\t}\n\n\treturn (msel & 0x3c) + 4;\n}\n\n \nstatic u32 lpc18xx_pll0_msel2selp(u32 msel)\n{\n\tif (msel < 60)\n\t\treturn (msel >> 1) + 1;\n\n\treturn 31;\n}\n\nstatic unsigned long lpc18xx_pll0_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct lpc18xx_pll *pll = to_lpc_pll(hw);\n\tu32 ctrl, mdiv, msel, npdiv;\n\n\tctrl = readl(pll->reg + LPC18XX_CGU_PLL0USB_CTRL);\n\tmdiv = readl(pll->reg + LPC18XX_CGU_PLL0USB_MDIV);\n\tnpdiv = readl(pll->reg + LPC18XX_CGU_PLL0USB_NP_DIV);\n\n\tif (ctrl & LPC18XX_PLL0_CTRL_BYPASS)\n\t\treturn parent_rate;\n\n\tif (npdiv != LPC18XX_PLL0_NP_DIVS_1) {\n\t\tpr_warn(\"%s: pre/post dividers not supported\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tmsel = lpc18xx_pll0_mdec2msel(mdiv & LPC18XX_PLL0_MDIV_MDEC_MASK);\n\tif (msel)\n\t\treturn 2 * msel * parent_rate;\n\n\tpr_warn(\"%s: unable to calculate rate\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic long lpc18xx_pll0_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *prate)\n{\n\tunsigned long m;\n\n\tif (*prate < rate) {\n\t\tpr_warn(\"%s: pll dividers not supported\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tm = DIV_ROUND_UP_ULL(*prate, rate * 2);\n\tif (m <= 0 && m > LPC18XX_PLL0_MSEL_MAX) {\n\t\tpr_warn(\"%s: unable to support rate %lu\\n\", __func__, rate);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 2 * *prate * m;\n}\n\nstatic int lpc18xx_pll0_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long parent_rate)\n{\n\tstruct lpc18xx_pll *pll = to_lpc_pll(hw);\n\tu32 ctrl, stat, m;\n\tint retry = 3;\n\n\tif (parent_rate < rate) {\n\t\tpr_warn(\"%s: pll dividers not supported\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tm = DIV_ROUND_UP_ULL(parent_rate, rate * 2);\n\tif (m <= 0 && m > LPC18XX_PLL0_MSEL_MAX) {\n\t\tpr_warn(\"%s: unable to support rate %lu\\n\", __func__, rate);\n\t\treturn -EINVAL;\n\t}\n\n\tm  = lpc18xx_pll0_msel2mdec(m);\n\tm |= lpc18xx_pll0_msel2selp(m) << LPC18XX_PLL0_MDIV_SELP_SHIFT;\n\tm |= lpc18xx_pll0_msel2seli(m) << LPC18XX_PLL0_MDIV_SELI_SHIFT;\n\n\t \n\tctrl = readl(pll->reg + LPC18XX_CGU_PLL0USB_CTRL);\n\tctrl |= LPC18XX_PLL0_CTRL_PD;\n\tctrl &= ~(LPC18XX_PLL0_CTRL_BYPASS | LPC18XX_PLL0_CTRL_DIRECTI |\n\t\t  LPC18XX_PLL0_CTRL_DIRECTO | LPC18XX_PLL0_CTRL_CLKEN);\n\twritel(ctrl, pll->reg + LPC18XX_CGU_PLL0USB_CTRL);\n\n\t \n\twritel(m, pll->reg + LPC18XX_CGU_PLL0USB_MDIV);\n\twritel(LPC18XX_PLL0_NP_DIVS_1, pll->reg + LPC18XX_CGU_PLL0USB_NP_DIV);\n\n\t \n\tctrl &= ~LPC18XX_PLL0_CTRL_PD;\n\twritel(ctrl, pll->reg + LPC18XX_CGU_PLL0USB_CTRL);\n\tdo {\n\t\tudelay(10);\n\t\tstat = readl(pll->reg + LPC18XX_CGU_PLL0USB_STAT);\n\t\tif (stat & LPC18XX_PLL0_STAT_LOCK) {\n\t\t\tctrl |= LPC18XX_PLL0_CTRL_CLKEN;\n\t\t\twritel(ctrl, pll->reg + LPC18XX_CGU_PLL0USB_CTRL);\n\n\t\t\treturn 0;\n\t\t}\n\t} while (retry--);\n\n\tpr_warn(\"%s: unable to lock pll\\n\", __func__);\n\n\treturn -EINVAL;\n}\n\nstatic const struct clk_ops lpc18xx_pll0_ops = {\n\t.recalc_rate\t= lpc18xx_pll0_recalc_rate,\n\t.round_rate\t= lpc18xx_pll0_round_rate,\n\t.set_rate\t= lpc18xx_pll0_set_rate,\n};\n\nstatic unsigned long lpc18xx_pll1_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct lpc18xx_pll *pll = to_lpc_pll(hw);\n\tu16 msel, nsel, psel;\n\tbool direct, fbsel;\n\tu32 ctrl;\n\n\tctrl = readl(pll->reg + LPC18XX_CGU_PLL1_CTRL);\n\n\tdirect = (ctrl & LPC18XX_PLL1_CTRL_DIRECT) ? true : false;\n\tfbsel = (ctrl & LPC18XX_PLL1_CTRL_FBSEL) ? true : false;\n\n\tmsel = ((ctrl >> 16) & 0xff) + 1;\n\tnsel = ((ctrl >> 12) & 0x3) + 1;\n\n\tif (direct || fbsel)\n\t\treturn msel * (parent_rate / nsel);\n\n\tpsel = (ctrl >>  8) & 0x3;\n\tpsel = 1 << psel;\n\n\treturn (msel / (2 * psel)) * (parent_rate / nsel);\n}\n\nstatic const struct clk_ops lpc18xx_pll1_ops = {\n\t.recalc_rate = lpc18xx_pll1_recalc_rate,\n};\n\nstatic int lpc18xx_cgu_gate_enable(struct clk_hw *hw)\n{\n\treturn clk_gate_ops.enable(hw);\n}\n\nstatic void lpc18xx_cgu_gate_disable(struct clk_hw *hw)\n{\n\tclk_gate_ops.disable(hw);\n}\n\nstatic int lpc18xx_cgu_gate_is_enabled(struct clk_hw *hw)\n{\n\tconst struct clk_hw *parent;\n\n\t \n\tparent = clk_hw_get_parent(hw);\n\tif (!parent)\n\t\treturn 0;\n\n\tif (!clk_hw_is_enabled(parent))\n\t\treturn 0;\n\n\treturn clk_gate_ops.is_enabled(hw);\n}\n\nstatic const struct clk_ops lpc18xx_gate_ops = {\n\t.enable = lpc18xx_cgu_gate_enable,\n\t.disable = lpc18xx_cgu_gate_disable,\n\t.is_enabled = lpc18xx_cgu_gate_is_enabled,\n};\n\nstatic struct lpc18xx_cgu_pll_clk lpc18xx_cgu_src_clk_plls[] = {\n\tLPC1XX_CGU_CLK_PLL(PLL0USB,\tpll0_src_ids, pll0_ops),\n\tLPC1XX_CGU_CLK_PLL(PLL0AUDIO,\tpll0_src_ids, pll0_ops),\n\tLPC1XX_CGU_CLK_PLL(PLL1,\tpll1_src_ids, pll1_ops),\n};\n\nstatic void lpc18xx_fill_parent_names(const char **parent, const u32 *id, int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tparent[i] = clk_src_names[id[i]];\n}\n\nstatic struct clk *lpc18xx_cgu_register_div(struct lpc18xx_cgu_src_clk_div *clk,\n\t\t\t\t\t    void __iomem *base, int n)\n{\n\tvoid __iomem *reg = base + LPC18XX_CGU_IDIV_CTRL(n);\n\tconst char *name = clk_src_names[clk->clk_id];\n\tconst char *parents[CLK_SRC_MAX];\n\n\tclk->div.reg = reg;\n\tclk->mux.reg = reg;\n\tclk->gate.reg = reg;\n\n\tlpc18xx_fill_parent_names(parents, clk->mux.table, clk->n_parents);\n\n\treturn clk_register_composite(NULL, name, parents, clk->n_parents,\n\t\t\t\t      &clk->mux.hw, &clk_mux_ops,\n\t\t\t\t      &clk->div.hw, &clk_divider_ops,\n\t\t\t\t      &clk->gate.hw, &lpc18xx_gate_ops, 0);\n}\n\n\nstatic struct clk *lpc18xx_register_base_clk(struct lpc18xx_cgu_base_clk *clk,\n\t\t\t\t\t     void __iomem *reg_base, int n)\n{\n\tvoid __iomem *reg = reg_base + LPC18XX_CGU_BASE_CLK(n);\n\tconst char *name = clk_base_names[clk->clk_id];\n\tconst char *parents[CLK_SRC_MAX];\n\n\tif (clk->n_parents == 0)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tclk->mux.reg = reg;\n\tclk->gate.reg = reg;\n\n\tlpc18xx_fill_parent_names(parents, clk->mux.table, clk->n_parents);\n\n\t \n\tif (n == BASE_SAFE_CLK)\n\t\treturn clk_register_composite(NULL, name, parents, clk->n_parents,\n\t\t\t\t\t      &clk->mux.hw, &clk_mux_ops,\n\t\t\t\t\t      NULL, NULL, NULL, NULL, 0);\n\n\treturn clk_register_composite(NULL, name, parents, clk->n_parents,\n\t\t\t\t      &clk->mux.hw, &clk_mux_ops,\n\t\t\t\t      NULL,  NULL,\n\t\t\t\t      &clk->gate.hw, &lpc18xx_gate_ops, 0);\n}\n\n\nstatic struct clk *lpc18xx_cgu_register_pll(struct lpc18xx_cgu_pll_clk *clk,\n\t\t\t\t\t    void __iomem *base)\n{\n\tconst char *name = clk_src_names[clk->clk_id];\n\tconst char *parents[CLK_SRC_MAX];\n\n\tclk->pll.reg  = base;\n\tclk->mux.reg  = base + clk->reg_offset + LPC18XX_CGU_PLL_CTRL_OFFSET;\n\tclk->gate.reg = base + clk->reg_offset + LPC18XX_CGU_PLL_CTRL_OFFSET;\n\n\tlpc18xx_fill_parent_names(parents, clk->mux.table, clk->n_parents);\n\n\treturn clk_register_composite(NULL, name, parents, clk->n_parents,\n\t\t\t\t      &clk->mux.hw, &clk_mux_ops,\n\t\t\t\t      &clk->pll.hw, clk->pll_ops,\n\t\t\t\t      &clk->gate.hw, &lpc18xx_gate_ops, 0);\n}\n\nstatic void __init lpc18xx_cgu_register_source_clks(struct device_node *np,\n\t\t\t\t\t\t    void __iomem *base)\n{\n\tconst char *parents[CLK_SRC_MAX];\n\tstruct clk *clk;\n\tint i;\n\n\t \n\tclk = clk_register_fixed_rate(NULL, clk_src_names[CLK_SRC_IRC],\n\t\t\t\t      NULL, 0, 12000000);\n\tif (IS_ERR(clk))\n\t\tpr_warn(\"%s: failed to register irc clk\\n\", __func__);\n\n\t \n\tparents[0] = of_clk_get_parent_name(np, 0);\n\tclk = clk_register_gate(NULL, clk_src_names[CLK_SRC_OSC], parents[0],\n\t\t\t\t0, base + LPC18XX_CGU_XTAL_OSC_CTRL,\n\t\t\t\t0, CLK_GATE_SET_TO_DISABLE, NULL);\n\tif (IS_ERR(clk))\n\t\tpr_warn(\"%s: failed to register osc clk\\n\", __func__);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(lpc18xx_cgu_src_clk_plls); i++) {\n\t\tclk = lpc18xx_cgu_register_pll(&lpc18xx_cgu_src_clk_plls[i],\n\t\t\t\t\t\t   base);\n\t\tif (IS_ERR(clk))\n\t\t\tpr_warn(\"%s: failed to register pll (%d)\\n\", __func__, i);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(lpc18xx_cgu_src_clk_divs); i++) {\n\t\tclk = lpc18xx_cgu_register_div(&lpc18xx_cgu_src_clk_divs[i],\n\t\t\t\t\t       base, i);\n\t\tif (IS_ERR(clk))\n\t\t\tpr_warn(\"%s: failed to register div %d\\n\", __func__, i);\n\t}\n}\n\nstatic struct clk *clk_base[BASE_CLK_MAX];\nstatic struct clk_onecell_data clk_base_data = {\n\t.clks = clk_base,\n\t.clk_num = BASE_CLK_MAX,\n};\n\nstatic void __init lpc18xx_cgu_register_base_clks(void __iomem *reg_base)\n{\n\tint i;\n\n\tfor (i = BASE_SAFE_CLK; i < BASE_CLK_MAX; i++) {\n\t\tclk_base[i] = lpc18xx_register_base_clk(&lpc18xx_cgu_base_clks[i],\n\t\t\t\t\t\t\treg_base, i);\n\t\tif (IS_ERR(clk_base[i]) && PTR_ERR(clk_base[i]) != -ENOENT)\n\t\t\tpr_warn(\"%s: register base clk %d failed\\n\", __func__, i);\n\t}\n}\n\nstatic void __init lpc18xx_cgu_init(struct device_node *np)\n{\n\tvoid __iomem *reg_base;\n\n\treg_base = of_iomap(np, 0);\n\tif (!reg_base) {\n\t\tpr_warn(\"%s: failed to map address range\\n\", __func__);\n\t\treturn;\n\t}\n\n\tlpc18xx_cgu_register_source_clks(np, reg_base);\n\tlpc18xx_cgu_register_base_clks(reg_base);\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &clk_base_data);\n}\nCLK_OF_DECLARE(lpc18xx_cgu, \"nxp,lpc1850-cgu\", lpc18xx_cgu_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}