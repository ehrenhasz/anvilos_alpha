{
  "module_name": "clk-lpc18xx-ccu.c",
  "hash_id": "2d6c5289bb91fbcecc41b51b5ebf57458101478eeff8946c057e24de8a9ee49d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/nxp/clk-lpc18xx-ccu.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <dt-bindings/clock/lpc18xx-ccu.h>\n\n \n#define LPC18XX_CCU_RUN\t\tBIT(0)\n#define LPC18XX_CCU_AUTO\tBIT(1)\n#define LPC18XX_CCU_DIV\t\tBIT(5)\n#define LPC18XX_CCU_DIVSTAT\tBIT(27)\n\n \n#define CCU_BRANCH_IS_BUS\tBIT(0)\n#define CCU_BRANCH_HAVE_DIV2\tBIT(1)\n\nstruct lpc18xx_branch_clk_data {\n\tconst char **name;\n\tint num;\n};\n\nstruct lpc18xx_clk_branch {\n\tconst char *base_name;\n\tconst char *name;\n\tu16 offset;\n\tu16 flags;\n\tstruct clk *clk;\n\tstruct clk_gate gate;\n};\n\nstatic struct lpc18xx_clk_branch clk_branches[] = {\n\t{\"base_apb3_clk\", \"apb3_bus\",\t\tCLK_APB3_BUS,\t\tCCU_BRANCH_IS_BUS},\n\t{\"base_apb3_clk\", \"apb3_i2c1\",\t\tCLK_APB3_I2C1,\t\t0},\n\t{\"base_apb3_clk\", \"apb3_dac\",\t\tCLK_APB3_DAC,\t\t0},\n\t{\"base_apb3_clk\", \"apb3_adc0\",\t\tCLK_APB3_ADC0,\t\t0},\n\t{\"base_apb3_clk\", \"apb3_adc1\",\t\tCLK_APB3_ADC1,\t\t0},\n\t{\"base_apb3_clk\", \"apb3_can0\",\t\tCLK_APB3_CAN0,\t\t0},\n\n\t{\"base_apb1_clk\", \"apb1_bus\",\t\tCLK_APB1_BUS,\t\tCCU_BRANCH_IS_BUS},\n\t{\"base_apb1_clk\", \"apb1_mc_pwm\",\tCLK_APB1_MOTOCON_PWM,\t0},\n\t{\"base_apb1_clk\", \"apb1_i2c0\",\t\tCLK_APB1_I2C0,\t\t0},\n\t{\"base_apb1_clk\", \"apb1_i2s\",\t\tCLK_APB1_I2S,\t\t0},\n\t{\"base_apb1_clk\", \"apb1_can1\",\t\tCLK_APB1_CAN1,\t\t0},\n\n\t{\"base_spifi_clk\", \"spifi\",\t\tCLK_SPIFI,\t\t0},\n\n\t{\"base_cpu_clk\", \"cpu_bus\",\t\tCLK_CPU_BUS,\t\tCCU_BRANCH_IS_BUS},\n\t{\"base_cpu_clk\", \"cpu_spifi\",\t\tCLK_CPU_SPIFI,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_gpio\",\t\tCLK_CPU_GPIO,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_lcd\",\t\tCLK_CPU_LCD,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_ethernet\",\tCLK_CPU_ETHERNET,\t0},\n\t{\"base_cpu_clk\", \"cpu_usb0\",\t\tCLK_CPU_USB0,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_emc\",\t\tCLK_CPU_EMC,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_sdio\",\t\tCLK_CPU_SDIO,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_dma\",\t\tCLK_CPU_DMA,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_core\",\t\tCLK_CPU_CORE,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_sct\",\t\tCLK_CPU_SCT,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_usb1\",\t\tCLK_CPU_USB1,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_emcdiv\",\t\tCLK_CPU_EMCDIV,\t\tCCU_BRANCH_HAVE_DIV2},\n\t{\"base_cpu_clk\", \"cpu_flasha\",\t\tCLK_CPU_FLASHA,\t\tCCU_BRANCH_HAVE_DIV2},\n\t{\"base_cpu_clk\", \"cpu_flashb\",\t\tCLK_CPU_FLASHB,\t\tCCU_BRANCH_HAVE_DIV2},\n\t{\"base_cpu_clk\", \"cpu_m0app\",\t\tCLK_CPU_M0APP,\t\tCCU_BRANCH_HAVE_DIV2},\n\t{\"base_cpu_clk\", \"cpu_adchs\",\t\tCLK_CPU_ADCHS,\t\tCCU_BRANCH_HAVE_DIV2},\n\t{\"base_cpu_clk\", \"cpu_eeprom\",\t\tCLK_CPU_EEPROM,\t\tCCU_BRANCH_HAVE_DIV2},\n\t{\"base_cpu_clk\", \"cpu_wwdt\",\t\tCLK_CPU_WWDT,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_uart0\",\t\tCLK_CPU_UART0,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_uart1\",\t\tCLK_CPU_UART1,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_ssp0\",\t\tCLK_CPU_SSP0,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_timer0\",\t\tCLK_CPU_TIMER0,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_timer1\",\t\tCLK_CPU_TIMER1,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_scu\",\t\tCLK_CPU_SCU,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_creg\",\t\tCLK_CPU_CREG,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_ritimer\",\t\tCLK_CPU_RITIMER,\t0},\n\t{\"base_cpu_clk\", \"cpu_uart2\",\t\tCLK_CPU_UART2,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_uart3\",\t\tCLK_CPU_UART3,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_timer2\",\t\tCLK_CPU_TIMER2,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_timer3\",\t\tCLK_CPU_TIMER3,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_ssp1\",\t\tCLK_CPU_SSP1,\t\t0},\n\t{\"base_cpu_clk\", \"cpu_qei\",\t\tCLK_CPU_QEI,\t\t0},\n\n\t{\"base_periph_clk\", \"periph_bus\",\tCLK_PERIPH_BUS,\t\tCCU_BRANCH_IS_BUS},\n\t{\"base_periph_clk\", \"periph_core\",\tCLK_PERIPH_CORE,\t0},\n\t{\"base_periph_clk\", \"periph_sgpio\",\tCLK_PERIPH_SGPIO,\t0},\n\n\t{\"base_usb0_clk\",  \"usb0\",\t\tCLK_USB0,\t\t0},\n\t{\"base_usb1_clk\",  \"usb1\",\t\tCLK_USB1,\t\t0},\n\t{\"base_spi_clk\",   \"spi\",\t\tCLK_SPI,\t\t0},\n\t{\"base_adchs_clk\", \"adchs\",\t\tCLK_ADCHS,\t\t0},\n\n\t{\"base_audio_clk\", \"audio\",\t\tCLK_AUDIO,\t\t0},\n\t{\"base_uart3_clk\", \"apb2_uart3\",\tCLK_APB2_UART3,\t\t0},\n\t{\"base_uart2_clk\", \"apb2_uart2\",\tCLK_APB2_UART2,\t\t0},\n\t{\"base_uart1_clk\", \"apb0_uart1\",\tCLK_APB0_UART1,\t\t0},\n\t{\"base_uart0_clk\", \"apb0_uart0\",\tCLK_APB0_UART0,\t\t0},\n\t{\"base_ssp1_clk\",  \"apb2_ssp1\",\t\tCLK_APB2_SSP1,\t\t0},\n\t{\"base_ssp0_clk\",  \"apb0_ssp0\",\t\tCLK_APB0_SSP0,\t\t0},\n\t{\"base_sdio_clk\",  \"sdio\",\t\tCLK_SDIO,\t\t0},\n};\n\nstatic struct clk *lpc18xx_ccu_branch_clk_get(struct of_phandle_args *clkspec,\n\t\t\t\t\t      void *data)\n{\n\tstruct lpc18xx_branch_clk_data *clk_data = data;\n\tunsigned int offset = clkspec->args[0];\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(clk_branches); i++) {\n\t\tif (clk_branches[i].offset != offset)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < clk_data->num; j++) {\n\t\t\tif (!strcmp(clk_branches[i].base_name, clk_data->name[j]))\n\t\t\t\treturn clk_branches[i].clk;\n\t\t}\n\t}\n\n\tpr_err(\"%s: invalid clock offset %d\\n\", __func__, offset);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int lpc18xx_ccu_gate_endisable(struct clk_hw *hw, bool enable)\n{\n\tstruct clk_gate *gate = to_clk_gate(hw);\n\tu32 val;\n\n\t \n\tval = readl(gate->reg);\n\tif (val & LPC18XX_CCU_DIVSTAT)\n\t\tval |= LPC18XX_CCU_DIV;\n\n\tif (enable) {\n\t\tval |= LPC18XX_CCU_RUN;\n\t} else {\n\t\t \n\t\tval |= LPC18XX_CCU_AUTO;\n\t\twritel(val, gate->reg);\n\n\t\tval &= ~LPC18XX_CCU_RUN;\n\t}\n\n\twritel(val, gate->reg);\n\n\treturn 0;\n}\n\nstatic int lpc18xx_ccu_gate_enable(struct clk_hw *hw)\n{\n\treturn lpc18xx_ccu_gate_endisable(hw, true);\n}\n\nstatic void lpc18xx_ccu_gate_disable(struct clk_hw *hw)\n{\n\tlpc18xx_ccu_gate_endisable(hw, false);\n}\n\nstatic int lpc18xx_ccu_gate_is_enabled(struct clk_hw *hw)\n{\n\tconst struct clk_hw *parent;\n\n\t \n\tparent = clk_hw_get_parent(hw);\n\tif (!parent)\n\t\treturn 0;\n\n\tif (!clk_hw_is_enabled(parent))\n\t\treturn 0;\n\n\treturn clk_gate_ops.is_enabled(hw);\n}\n\nstatic const struct clk_ops lpc18xx_ccu_gate_ops = {\n\t.enable\t\t= lpc18xx_ccu_gate_enable,\n\t.disable\t= lpc18xx_ccu_gate_disable,\n\t.is_enabled\t= lpc18xx_ccu_gate_is_enabled,\n};\n\nstatic void lpc18xx_ccu_register_branch_gate_div(struct lpc18xx_clk_branch *branch,\n\t\t\t\t\t\t void __iomem *reg_base,\n\t\t\t\t\t\t const char *parent)\n{\n\tconst struct clk_ops *div_ops = NULL;\n\tstruct clk_divider *div = NULL;\n\tstruct clk_hw *div_hw = NULL;\n\n\tif (branch->flags & CCU_BRANCH_HAVE_DIV2) {\n\t\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\t\tif (!div)\n\t\t\treturn;\n\n\t\tdiv->reg = branch->offset + reg_base;\n\t\tdiv->flags = CLK_DIVIDER_READ_ONLY;\n\t\tdiv->shift = 27;\n\t\tdiv->width = 1;\n\n\t\tdiv_hw = &div->hw;\n\t\tdiv_ops = &clk_divider_ro_ops;\n\t}\n\n\tbranch->gate.reg = branch->offset + reg_base;\n\tbranch->gate.bit_idx = 0;\n\n\tbranch->clk = clk_register_composite(NULL, branch->name, &parent, 1,\n\t\t\t\t\t     NULL, NULL,\n\t\t\t\t\t     div_hw, div_ops,\n\t\t\t\t\t     &branch->gate.hw, &lpc18xx_ccu_gate_ops, 0);\n\tif (IS_ERR(branch->clk)) {\n\t\tkfree(div);\n\t\tpr_warn(\"%s: failed to register %s\\n\", __func__, branch->name);\n\t\treturn;\n\t}\n\n\t \n\tswitch (branch->offset) {\n\tcase CLK_CPU_EMC:\n\tcase CLK_CPU_CORE:\n\tcase CLK_CPU_CREG:\n\tcase CLK_CPU_EMCDIV:\n\t\tclk_prepare_enable(branch->clk);\n\t}\n}\n\nstatic void lpc18xx_ccu_register_branch_clks(void __iomem *reg_base,\n\t\t\t\t\t     const char *base_name)\n{\n\tconst char *parent = base_name;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(clk_branches); i++) {\n\t\tif (strcmp(clk_branches[i].base_name, base_name))\n\t\t\tcontinue;\n\n\t\tlpc18xx_ccu_register_branch_gate_div(&clk_branches[i], reg_base,\n\t\t\t\t\t\t     parent);\n\n\t\tif (clk_branches[i].flags & CCU_BRANCH_IS_BUS)\n\t\t\tparent = clk_branches[i].name;\n\t}\n}\n\nstatic void __init lpc18xx_ccu_init(struct device_node *np)\n{\n\tstruct lpc18xx_branch_clk_data *clk_data;\n\tvoid __iomem *reg_base;\n\tint i, ret;\n\n\treg_base = of_iomap(np, 0);\n\tif (!reg_base) {\n\t\tpr_warn(\"%s: failed to map address range\\n\", __func__);\n\t\treturn;\n\t}\n\n\tclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\n\tif (!clk_data) {\n\t\tiounmap(reg_base);\n\t\treturn;\n\t}\n\n\tclk_data->num = of_property_count_strings(np, \"clock-names\");\n\tclk_data->name = kcalloc(clk_data->num, sizeof(char *), GFP_KERNEL);\n\tif (!clk_data->name) {\n\t\tiounmap(reg_base);\n\t\tkfree(clk_data);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < clk_data->num; i++) {\n\t\tret = of_property_read_string_index(np, \"clock-names\", i,\n\t\t\t\t\t\t    &clk_data->name[i]);\n\t\tif (ret) {\n\t\t\tpr_warn(\"%s: failed to get clock name at idx %d\\n\",\n\t\t\t\t__func__, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlpc18xx_ccu_register_branch_clks(reg_base, clk_data->name[i]);\n\t}\n\n\tof_clk_add_provider(np, lpc18xx_ccu_branch_clk_get, clk_data);\n}\nCLK_OF_DECLARE(lpc18xx_ccu, \"nxp,lpc1850-ccu\", lpc18xx_ccu_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}