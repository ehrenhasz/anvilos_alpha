{
  "module_name": "clk-lpc32xx.c",
  "hash_id": "0468c3d68c8fba56afce9f7e7e26d1569e3fd4a12d1024263b991b6e2e476c54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/nxp/clk-lpc32xx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/clock/lpc32xx-clock.h>\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n \n#define PLL_CTRL_ENABLE\t\t\tBIT(16)\n#define PLL_CTRL_BYPASS\t\t\tBIT(15)\n#define PLL_CTRL_DIRECT\t\t\tBIT(14)\n#define PLL_CTRL_FEEDBACK\t\tBIT(13)\n#define PLL_CTRL_POSTDIV\t\t(BIT(12)|BIT(11))\n#define PLL_CTRL_PREDIV\t\t\t(BIT(10)|BIT(9))\n#define PLL_CTRL_FEEDDIV\t\t(0xFF << 1)\n#define PLL_CTRL_LOCK\t\t\tBIT(0)\n\n \n#define LPC32XX_CLKPWR_DEBUG_CTRL\t0x00\n#define LPC32XX_CLKPWR_USB_DIV\t\t0x1C\n#define LPC32XX_CLKPWR_HCLKDIV_CTRL\t0x40\n#define LPC32XX_CLKPWR_PWR_CTRL\t\t0x44\n#define LPC32XX_CLKPWR_PLL397_CTRL\t0x48\n#define LPC32XX_CLKPWR_OSC_CTRL\t\t0x4C\n#define LPC32XX_CLKPWR_SYSCLK_CTRL\t0x50\n#define LPC32XX_CLKPWR_LCDCLK_CTRL\t0x54\n#define LPC32XX_CLKPWR_HCLKPLL_CTRL\t0x58\n#define LPC32XX_CLKPWR_ADCCLK_CTRL1\t0x60\n#define LPC32XX_CLKPWR_USB_CTRL\t\t0x64\n#define LPC32XX_CLKPWR_SSP_CTRL\t\t0x78\n#define LPC32XX_CLKPWR_I2S_CTRL\t\t0x7C\n#define LPC32XX_CLKPWR_MS_CTRL\t\t0x80\n#define LPC32XX_CLKPWR_MACCLK_CTRL\t0x90\n#define LPC32XX_CLKPWR_TEST_CLK_CTRL\t0xA4\n#define LPC32XX_CLKPWR_I2CCLK_CTRL\t0xAC\n#define LPC32XX_CLKPWR_KEYCLK_CTRL\t0xB0\n#define LPC32XX_CLKPWR_ADCCLK_CTRL\t0xB4\n#define LPC32XX_CLKPWR_PWMCLK_CTRL\t0xB8\n#define LPC32XX_CLKPWR_TIMCLK_CTRL\t0xBC\n#define LPC32XX_CLKPWR_TIMCLK_CTRL1\t0xC0\n#define LPC32XX_CLKPWR_SPI_CTRL\t\t0xC4\n#define LPC32XX_CLKPWR_FLASHCLK_CTRL\t0xC8\n#define LPC32XX_CLKPWR_UART3_CLK_CTRL\t0xD0\n#define LPC32XX_CLKPWR_UART4_CLK_CTRL\t0xD4\n#define LPC32XX_CLKPWR_UART5_CLK_CTRL\t0xD8\n#define LPC32XX_CLKPWR_UART6_CLK_CTRL\t0xDC\n#define LPC32XX_CLKPWR_IRDA_CLK_CTRL\t0xE0\n#define LPC32XX_CLKPWR_UART_CLK_CTRL\t0xE4\n#define LPC32XX_CLKPWR_DMA_CLK_CTRL\t0xE8\n\n \n#define LPC32XX_USB_CLK_CTRL\t\t0xF4\n#define LPC32XX_USB_CLK_STS\t\t0xF8\n\nstatic struct regmap_config lpc32xx_scb_regmap_config = {\n\t.name = \"scb\",\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.max_register = 0x114,\n\t.fast_io = true,\n};\n\nstatic struct regmap *clk_regmap;\nstatic void __iomem *usb_clk_vbase;\n\nenum {\n\tLPC32XX_USB_CLK_OTG = LPC32XX_USB_CLK_HOST + 1,\n\tLPC32XX_USB_CLK_AHB,\n\n\tLPC32XX_USB_CLK_MAX = LPC32XX_USB_CLK_AHB + 1,\n};\n\nenum {\n\t \n\tLPC32XX_CLK_ADC_DIV = LPC32XX_CLK_PERIPH + 1,\n\tLPC32XX_CLK_ADC_RTC,\n\tLPC32XX_CLK_TEST1,\n\tLPC32XX_CLK_TEST2,\n\n\t \n\tLPC32XX_CLK_OSC,\n\tLPC32XX_CLK_SYS,\n\tLPC32XX_CLK_PLL397X,\n\tLPC32XX_CLK_HCLK_DIV_PERIPH,\n\tLPC32XX_CLK_HCLK_DIV,\n\tLPC32XX_CLK_HCLK,\n\tLPC32XX_CLK_ARM,\n\tLPC32XX_CLK_ARM_VFP,\n\n\t \n\tLPC32XX_CLK_USB_PLL,\n\tLPC32XX_CLK_USB_DIV,\n\tLPC32XX_CLK_USB,\n\n\t \n\tLPC32XX_CLK_PERIPH_HCLK_MUX,\n\tLPC32XX_CLK_PERIPH_ARM_MUX,\n\n\t \n\tLPC32XX_CLK_SYSCLK_PERIPH_MUX,\n\tLPC32XX_CLK_SYSCLK_HCLK_MUX,\n\tLPC32XX_CLK_SYSCLK_ARM_MUX,\n\n\t \n\tLPC32XX_CLK_XTAL_32K,\n\tLPC32XX_CLK_XTAL,\n\n\t \n\tLPC32XX_CLK_USB_OFFSET,\n\tLPC32XX_CLK_USB_I2C = LPC32XX_USB_CLK_I2C + LPC32XX_CLK_USB_OFFSET,\n\tLPC32XX_CLK_USB_DEV = LPC32XX_USB_CLK_DEVICE + LPC32XX_CLK_USB_OFFSET,\n\tLPC32XX_CLK_USB_HOST = LPC32XX_USB_CLK_HOST + LPC32XX_CLK_USB_OFFSET,\n\tLPC32XX_CLK_USB_OTG = LPC32XX_USB_CLK_OTG + LPC32XX_CLK_USB_OFFSET,\n\tLPC32XX_CLK_USB_AHB = LPC32XX_USB_CLK_AHB + LPC32XX_CLK_USB_OFFSET,\n\n\t \n\tLPC32XX_CLK__NULL,\n\n\t \n\tLPC32XX_CLK_PWM1_MUX,\n\tLPC32XX_CLK_PWM1_DIV,\n\tLPC32XX_CLK_PWM1_GATE,\n\tLPC32XX_CLK_PWM2_MUX,\n\tLPC32XX_CLK_PWM2_DIV,\n\tLPC32XX_CLK_PWM2_GATE,\n\tLPC32XX_CLK_UART3_MUX,\n\tLPC32XX_CLK_UART3_DIV,\n\tLPC32XX_CLK_UART3_GATE,\n\tLPC32XX_CLK_UART4_MUX,\n\tLPC32XX_CLK_UART4_DIV,\n\tLPC32XX_CLK_UART4_GATE,\n\tLPC32XX_CLK_UART5_MUX,\n\tLPC32XX_CLK_UART5_DIV,\n\tLPC32XX_CLK_UART5_GATE,\n\tLPC32XX_CLK_UART6_MUX,\n\tLPC32XX_CLK_UART6_DIV,\n\tLPC32XX_CLK_UART6_GATE,\n\tLPC32XX_CLK_TEST1_MUX,\n\tLPC32XX_CLK_TEST1_GATE,\n\tLPC32XX_CLK_TEST2_MUX,\n\tLPC32XX_CLK_TEST2_GATE,\n\tLPC32XX_CLK_USB_DIV_DIV,\n\tLPC32XX_CLK_USB_DIV_GATE,\n\tLPC32XX_CLK_SD_DIV,\n\tLPC32XX_CLK_SD_GATE,\n\tLPC32XX_CLK_LCD_DIV,\n\tLPC32XX_CLK_LCD_GATE,\n\n\tLPC32XX_CLK_HW_MAX,\n\tLPC32XX_CLK_MAX = LPC32XX_CLK_SYSCLK_ARM_MUX + 1,\n\tLPC32XX_CLK_CCF_MAX = LPC32XX_CLK_USB_AHB + 1,\n};\n\nstatic struct clk *clk[LPC32XX_CLK_MAX];\nstatic struct clk_onecell_data clk_data = {\n\t.clks = clk,\n\t.clk_num = LPC32XX_CLK_MAX,\n};\n\nstatic struct clk *usb_clk[LPC32XX_USB_CLK_MAX];\nstatic struct clk_onecell_data usb_clk_data = {\n\t.clks = usb_clk,\n\t.clk_num = LPC32XX_USB_CLK_MAX,\n};\n\n#define LPC32XX_CLK_PARENTS_MAX\t\t\t5\n\nstruct clk_proto_t {\n\tconst char *name;\n\tconst u8 parents[LPC32XX_CLK_PARENTS_MAX];\n\tu8 num_parents;\n\tunsigned long flags;\n};\n\n#define CLK_PREFIX(LITERAL)\t\tLPC32XX_CLK_ ## LITERAL\n#define NUMARGS(...)\t(sizeof((int[]){__VA_ARGS__})/sizeof(int))\n\n#define LPC32XX_CLK_DEFINE(_idx, _name, _flags, ...)\t\t\\\n\t[CLK_PREFIX(_idx)] = {\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\\\n\t\t.flags = _flags,\t\t\t\t\\\n\t\t.parents = { __VA_ARGS__ },\t\t\t\\\n\t\t.num_parents = NUMARGS(__VA_ARGS__),\t\t\\\n\t }\n\nstatic const struct clk_proto_t clk_proto[LPC32XX_CLK_CCF_MAX] __initconst = {\n\tLPC32XX_CLK_DEFINE(XTAL, \"xtal\", 0x0),\n\tLPC32XX_CLK_DEFINE(XTAL_32K, \"xtal_32k\", 0x0),\n\n\tLPC32XX_CLK_DEFINE(RTC, \"rtc\", 0x0, LPC32XX_CLK_XTAL_32K),\n\tLPC32XX_CLK_DEFINE(OSC, \"osc\", CLK_IGNORE_UNUSED, LPC32XX_CLK_XTAL),\n\tLPC32XX_CLK_DEFINE(SYS, \"sys\", CLK_IGNORE_UNUSED,\n\t\tLPC32XX_CLK_OSC, LPC32XX_CLK_PLL397X),\n\tLPC32XX_CLK_DEFINE(PLL397X, \"pll_397x\", CLK_IGNORE_UNUSED,\n\t\tLPC32XX_CLK_RTC),\n\tLPC32XX_CLK_DEFINE(HCLK_PLL, \"hclk_pll\", CLK_IGNORE_UNUSED,\n\t\tLPC32XX_CLK_SYS),\n\tLPC32XX_CLK_DEFINE(HCLK_DIV_PERIPH, \"hclk_div_periph\",\n\t\tCLK_IGNORE_UNUSED, LPC32XX_CLK_HCLK_PLL),\n\tLPC32XX_CLK_DEFINE(HCLK_DIV, \"hclk_div\", CLK_IGNORE_UNUSED,\n\t\tLPC32XX_CLK_HCLK_PLL),\n\tLPC32XX_CLK_DEFINE(HCLK, \"hclk\", CLK_IGNORE_UNUSED,\n\t\tLPC32XX_CLK_PERIPH_HCLK_MUX),\n\tLPC32XX_CLK_DEFINE(PERIPH, \"pclk\", CLK_IGNORE_UNUSED,\n\t\tLPC32XX_CLK_SYSCLK_PERIPH_MUX),\n\tLPC32XX_CLK_DEFINE(ARM, \"arm\", CLK_IGNORE_UNUSED,\n\t\tLPC32XX_CLK_PERIPH_ARM_MUX),\n\n\tLPC32XX_CLK_DEFINE(PERIPH_HCLK_MUX, \"periph_hclk_mux\",\n\t\tCLK_IGNORE_UNUSED,\n\t\tLPC32XX_CLK_SYSCLK_HCLK_MUX, LPC32XX_CLK_SYSCLK_PERIPH_MUX),\n\tLPC32XX_CLK_DEFINE(PERIPH_ARM_MUX, \"periph_arm_mux\", CLK_IGNORE_UNUSED,\n\t\tLPC32XX_CLK_SYSCLK_ARM_MUX, LPC32XX_CLK_SYSCLK_PERIPH_MUX),\n\tLPC32XX_CLK_DEFINE(SYSCLK_PERIPH_MUX, \"sysclk_periph_mux\",\n\t\tCLK_IGNORE_UNUSED,\n\t\tLPC32XX_CLK_SYS, LPC32XX_CLK_HCLK_DIV_PERIPH),\n\tLPC32XX_CLK_DEFINE(SYSCLK_HCLK_MUX, \"sysclk_hclk_mux\",\n\t\tCLK_IGNORE_UNUSED,\n\t\tLPC32XX_CLK_SYS, LPC32XX_CLK_HCLK_DIV),\n\tLPC32XX_CLK_DEFINE(SYSCLK_ARM_MUX, \"sysclk_arm_mux\", CLK_IGNORE_UNUSED,\n\t\tLPC32XX_CLK_SYS, LPC32XX_CLK_HCLK_PLL),\n\n\tLPC32XX_CLK_DEFINE(ARM_VFP, \"vfp9\", CLK_IGNORE_UNUSED,\n\t\tLPC32XX_CLK_ARM),\n\tLPC32XX_CLK_DEFINE(USB_PLL, \"usb_pll\",\n\t\tCLK_SET_RATE_GATE | CLK_SET_RATE_PARENT, LPC32XX_CLK_USB_DIV),\n\tLPC32XX_CLK_DEFINE(USB_DIV, \"usb_div\", 0x0, LPC32XX_CLK_OSC),\n\tLPC32XX_CLK_DEFINE(USB, \"usb\", 0x0, LPC32XX_CLK_USB_PLL),\n\tLPC32XX_CLK_DEFINE(DMA, \"dma\", 0x0, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(MLC, \"mlc\", 0x0, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(SLC, \"slc\", 0x0, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(LCD, \"lcd\", 0x0, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(MAC, \"mac\", 0x0, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(SD, \"sd\", 0x0, LPC32XX_CLK_ARM),\n\tLPC32XX_CLK_DEFINE(DDRAM, \"ddram\", CLK_GET_RATE_NOCACHE,\n\t\tLPC32XX_CLK_SYSCLK_ARM_MUX),\n\tLPC32XX_CLK_DEFINE(SSP0, \"ssp0\", 0x0, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(SSP1, \"ssp1\", 0x0, LPC32XX_CLK_HCLK),\n\n\t \n\tLPC32XX_CLK_DEFINE(UART3, \"uart3\", CLK_GET_RATE_NOCACHE,\n\t\tLPC32XX_CLK_PERIPH, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(UART4, \"uart4\", CLK_GET_RATE_NOCACHE,\n\t\tLPC32XX_CLK_PERIPH, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(UART5, \"uart5\", CLK_GET_RATE_NOCACHE,\n\t\tLPC32XX_CLK_PERIPH, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(UART6, \"uart6\", CLK_GET_RATE_NOCACHE,\n\t\tLPC32XX_CLK_PERIPH, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(IRDA, \"irda\", 0x0, LPC32XX_CLK_PERIPH),\n\tLPC32XX_CLK_DEFINE(I2C1, \"i2c1\", 0x0, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(I2C2, \"i2c2\", 0x0, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(TIMER0, \"timer0\", 0x0, LPC32XX_CLK_PERIPH),\n\tLPC32XX_CLK_DEFINE(TIMER1, \"timer1\", 0x0, LPC32XX_CLK_PERIPH),\n\tLPC32XX_CLK_DEFINE(TIMER2, \"timer2\", 0x0, LPC32XX_CLK_PERIPH),\n\tLPC32XX_CLK_DEFINE(TIMER3, \"timer3\", 0x0, LPC32XX_CLK_PERIPH),\n\tLPC32XX_CLK_DEFINE(TIMER4, \"timer4\", 0x0, LPC32XX_CLK_PERIPH),\n\tLPC32XX_CLK_DEFINE(TIMER5, \"timer5\", 0x0, LPC32XX_CLK_PERIPH),\n\tLPC32XX_CLK_DEFINE(WDOG, \"watchdog\", 0x0, LPC32XX_CLK_PERIPH),\n\tLPC32XX_CLK_DEFINE(I2S0, \"i2s0\", 0x0, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(I2S1, \"i2s1\", 0x0, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(SPI1, \"spi1\", 0x0, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(SPI2, \"spi2\", 0x0, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(MCPWM, \"mcpwm\", 0x0, LPC32XX_CLK_HCLK),\n\tLPC32XX_CLK_DEFINE(HSTIMER, \"hstimer\", 0x0, LPC32XX_CLK_PERIPH),\n\tLPC32XX_CLK_DEFINE(KEY, \"key\", 0x0, LPC32XX_CLK_RTC),\n\tLPC32XX_CLK_DEFINE(PWM1, \"pwm1\", 0x0,\n\t\tLPC32XX_CLK_RTC, LPC32XX_CLK_PERIPH),\n\tLPC32XX_CLK_DEFINE(PWM2, \"pwm2\", 0x0,\n\t\tLPC32XX_CLK_RTC, LPC32XX_CLK_PERIPH),\n\tLPC32XX_CLK_DEFINE(ADC, \"adc\", 0x0,\n\t\tLPC32XX_CLK_ADC_RTC, LPC32XX_CLK_ADC_DIV),\n\tLPC32XX_CLK_DEFINE(ADC_DIV, \"adc_div\", 0x0, LPC32XX_CLK_PERIPH),\n\tLPC32XX_CLK_DEFINE(ADC_RTC, \"adc_rtc\", 0x0, LPC32XX_CLK_RTC),\n\tLPC32XX_CLK_DEFINE(TEST1, \"test1\", 0x0,\n\t\tLPC32XX_CLK_PERIPH, LPC32XX_CLK_RTC, LPC32XX_CLK_OSC),\n\tLPC32XX_CLK_DEFINE(TEST2, \"test2\", 0x0,\n\t\tLPC32XX_CLK_HCLK, LPC32XX_CLK_PERIPH, LPC32XX_CLK_USB,\n\t\tLPC32XX_CLK_OSC, LPC32XX_CLK_PLL397X),\n\n\t \n\tLPC32XX_CLK_DEFINE(USB_AHB, \"usb_ahb\", 0x0, LPC32XX_CLK_USB),\n\tLPC32XX_CLK_DEFINE(USB_OTG, \"usb_otg\", 0x0, LPC32XX_CLK_USB_AHB),\n\tLPC32XX_CLK_DEFINE(USB_I2C, \"usb_i2c\", 0x0, LPC32XX_CLK_USB_AHB),\n\tLPC32XX_CLK_DEFINE(USB_DEV, \"usb_dev\", 0x0, LPC32XX_CLK_USB_OTG),\n\tLPC32XX_CLK_DEFINE(USB_HOST, \"usb_host\", 0x0, LPC32XX_CLK_USB_OTG),\n};\n\nstruct lpc32xx_clk {\n\tstruct clk_hw hw;\n\tu32 reg;\n\tu32 enable;\n\tu32 enable_mask;\n\tu32 disable;\n\tu32 disable_mask;\n\tu32 busy;\n\tu32 busy_mask;\n};\n\nenum clk_pll_mode {\n\tPLL_UNKNOWN,\n\tPLL_DIRECT,\n\tPLL_BYPASS,\n\tPLL_DIRECT_BYPASS,\n\tPLL_INTEGER,\n\tPLL_NON_INTEGER,\n};\n\nstruct lpc32xx_pll_clk {\n\tstruct clk_hw hw;\n\tu32 reg;\n\tu32 enable;\n\tunsigned long m_div;\n\tunsigned long n_div;\n\tunsigned long p_div;\n\tenum clk_pll_mode mode;\n};\n\nstruct lpc32xx_usb_clk {\n\tstruct clk_hw hw;\n\tu32 ctrl_enable;\n\tu32 ctrl_disable;\n\tu32 ctrl_mask;\n\tu32 enable;\n\tu32 busy;\n};\n\nstruct lpc32xx_clk_mux {\n\tstruct clk_hw\thw;\n\tu32\t\treg;\n\tu32\t\tmask;\n\tu8\t\tshift;\n\tu32\t\t*table;\n\tu8\t\tflags;\n};\n\nstruct lpc32xx_clk_div {\n\tstruct clk_hw\thw;\n\tu32\t\treg;\n\tu8\t\tshift;\n\tu8\t\twidth;\n\tconst struct clk_div_table\t*table;\n\tu8\t\tflags;\n};\n\nstruct lpc32xx_clk_gate {\n\tstruct clk_hw\thw;\n\tu32\t\treg;\n\tu8\t\tbit_idx;\n\tu8\t\tflags;\n};\n\n#define to_lpc32xx_clk(_hw)\tcontainer_of(_hw, struct lpc32xx_clk, hw)\n#define to_lpc32xx_pll_clk(_hw)\tcontainer_of(_hw, struct lpc32xx_pll_clk, hw)\n#define to_lpc32xx_usb_clk(_hw)\tcontainer_of(_hw, struct lpc32xx_usb_clk, hw)\n#define to_lpc32xx_mux(_hw)\tcontainer_of(_hw, struct lpc32xx_clk_mux, hw)\n#define to_lpc32xx_div(_hw)\tcontainer_of(_hw, struct lpc32xx_clk_div, hw)\n#define to_lpc32xx_gate(_hw)\tcontainer_of(_hw, struct lpc32xx_clk_gate, hw)\n\nstatic inline bool pll_is_valid(u64 val0, u64 val1, u64 min, u64 max)\n{\n\treturn (val0 >= (val1 * min) && val0 <= (val1 * max));\n}\n\nstatic inline u32 lpc32xx_usb_clk_read(struct lpc32xx_usb_clk *clk)\n{\n\treturn readl(usb_clk_vbase + LPC32XX_USB_CLK_STS);\n}\n\nstatic inline void lpc32xx_usb_clk_write(struct lpc32xx_usb_clk *clk, u32 val)\n{\n\twritel(val, usb_clk_vbase + LPC32XX_USB_CLK_CTRL);\n}\n\nstatic int clk_mask_enable(struct clk_hw *hw)\n{\n\tstruct lpc32xx_clk *clk = to_lpc32xx_clk(hw);\n\tu32 val;\n\n\tregmap_read(clk_regmap, clk->reg, &val);\n\n\tif (clk->busy_mask && (val & clk->busy_mask) == clk->busy)\n\t\treturn -EBUSY;\n\n\treturn regmap_update_bits(clk_regmap, clk->reg,\n\t\t\t\t  clk->enable_mask, clk->enable);\n}\n\nstatic void clk_mask_disable(struct clk_hw *hw)\n{\n\tstruct lpc32xx_clk *clk = to_lpc32xx_clk(hw);\n\n\tregmap_update_bits(clk_regmap, clk->reg,\n\t\t\t   clk->disable_mask, clk->disable);\n}\n\nstatic int clk_mask_is_enabled(struct clk_hw *hw)\n{\n\tstruct lpc32xx_clk *clk = to_lpc32xx_clk(hw);\n\tu32 val;\n\n\tregmap_read(clk_regmap, clk->reg, &val);\n\n\treturn ((val & clk->enable_mask) == clk->enable);\n}\n\nstatic const struct clk_ops clk_mask_ops = {\n\t.enable = clk_mask_enable,\n\t.disable = clk_mask_disable,\n\t.is_enabled = clk_mask_is_enabled,\n};\n\nstatic int clk_pll_enable(struct clk_hw *hw)\n{\n\tstruct lpc32xx_pll_clk *clk = to_lpc32xx_pll_clk(hw);\n\tu32 val, count;\n\n\tregmap_update_bits(clk_regmap, clk->reg, clk->enable, clk->enable);\n\n\tfor (count = 0; count < 1000; count++) {\n\t\tregmap_read(clk_regmap, clk->reg, &val);\n\t\tif (val & PLL_CTRL_LOCK)\n\t\t\tbreak;\n\t}\n\n\tif (val & PLL_CTRL_LOCK)\n\t\treturn 0;\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void clk_pll_disable(struct clk_hw *hw)\n{\n\tstruct lpc32xx_pll_clk *clk = to_lpc32xx_pll_clk(hw);\n\n\tregmap_update_bits(clk_regmap, clk->reg, clk->enable, 0x0);\n}\n\nstatic int clk_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct lpc32xx_pll_clk *clk = to_lpc32xx_pll_clk(hw);\n\tu32 val;\n\n\tregmap_read(clk_regmap, clk->reg, &val);\n\n\tval &= clk->enable | PLL_CTRL_LOCK;\n\tif (val == (clk->enable | PLL_CTRL_LOCK))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic unsigned long clk_pll_397x_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\treturn parent_rate * 397;\n}\n\nstatic unsigned long clk_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct lpc32xx_pll_clk *clk = to_lpc32xx_pll_clk(hw);\n\tbool is_direct, is_bypass, is_feedback;\n\tunsigned long rate, cco_rate, ref_rate;\n\tu32 val;\n\n\tregmap_read(clk_regmap, clk->reg, &val);\n\tis_direct = val & PLL_CTRL_DIRECT;\n\tis_bypass = val & PLL_CTRL_BYPASS;\n\tis_feedback = val & PLL_CTRL_FEEDBACK;\n\n\tclk->m_div = ((val & PLL_CTRL_FEEDDIV) >> 1) + 1;\n\tclk->n_div = ((val & PLL_CTRL_PREDIV) >> 9) + 1;\n\tclk->p_div = ((val & PLL_CTRL_POSTDIV) >> 11) + 1;\n\n\tif (is_direct && is_bypass) {\n\t\tclk->p_div = 0;\n\t\tclk->mode = PLL_DIRECT_BYPASS;\n\t\treturn parent_rate;\n\t}\n\tif (is_bypass) {\n\t\tclk->mode = PLL_BYPASS;\n\t\treturn parent_rate / (1 << clk->p_div);\n\t}\n\tif (is_direct) {\n\t\tclk->p_div = 0;\n\t\tclk->mode = PLL_DIRECT;\n\t}\n\n\tref_rate = parent_rate / clk->n_div;\n\trate = cco_rate = ref_rate * clk->m_div;\n\n\tif (!is_direct) {\n\t\tif (is_feedback) {\n\t\t\tcco_rate *= (1 << clk->p_div);\n\t\t\tclk->mode = PLL_INTEGER;\n\t\t} else {\n\t\t\trate /= (1 << clk->p_div);\n\t\t\tclk->mode = PLL_NON_INTEGER;\n\t\t}\n\t}\n\n\tpr_debug(\"%s: %lu: 0x%x: %d/%d/%d, %lu/%lu/%d => %lu\\n\",\n\t\t clk_hw_get_name(hw),\n\t\t parent_rate, val, is_direct, is_bypass, is_feedback,\n\t\t clk->n_div, clk->m_div, (1 << clk->p_div), rate);\n\n\tif (clk_pll_is_enabled(hw) &&\n\t    !(pll_is_valid(parent_rate, 1, 1000000, 20000000)\n\t      && pll_is_valid(cco_rate, 1, 156000000, 320000000)\n\t      && pll_is_valid(ref_rate, 1, 1000000, 27000000)))\n\t\tpr_err(\"%s: PLL clocks are not in valid ranges: %lu/%lu/%lu\\n\",\n\t\t       clk_hw_get_name(hw),\n\t\t       parent_rate, cco_rate, ref_rate);\n\n\treturn rate;\n}\n\nstatic int clk_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct lpc32xx_pll_clk *clk = to_lpc32xx_pll_clk(hw);\n\tu32 val;\n\tunsigned long new_rate;\n\n\t \n\tswitch (clk->mode) {\n\tcase PLL_DIRECT:\n\t\tval = PLL_CTRL_DIRECT;\n\t\tval |= (clk->m_div - 1) << 1;\n\t\tval |= (clk->n_div - 1) << 9;\n\t\tnew_rate = (parent_rate * clk->m_div) / clk->n_div;\n\t\tbreak;\n\tcase PLL_BYPASS:\n\t\tval = PLL_CTRL_BYPASS;\n\t\tval |= (clk->p_div - 1) << 11;\n\t\tnew_rate = parent_rate / (1 << (clk->p_div));\n\t\tbreak;\n\tcase PLL_DIRECT_BYPASS:\n\t\tval = PLL_CTRL_DIRECT | PLL_CTRL_BYPASS;\n\t\tnew_rate = parent_rate;\n\t\tbreak;\n\tcase PLL_INTEGER:\n\t\tval = PLL_CTRL_FEEDBACK;\n\t\tval |= (clk->m_div - 1) << 1;\n\t\tval |= (clk->n_div - 1) << 9;\n\t\tval |= (clk->p_div - 1) << 11;\n\t\tnew_rate = (parent_rate * clk->m_div) / clk->n_div;\n\t\tbreak;\n\tcase PLL_NON_INTEGER:\n\t\tval = 0x0;\n\t\tval |= (clk->m_div - 1) << 1;\n\t\tval |= (clk->n_div - 1) << 9;\n\t\tval |= (clk->p_div - 1) << 11;\n\t\tnew_rate = (parent_rate * clk->m_div) /\n\t\t\t\t(clk->n_div * (1 << clk->p_div));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (new_rate != rate)\n\t\treturn -EINVAL;\n\n\treturn regmap_update_bits(clk_regmap, clk->reg, 0x1FFFF, val);\n}\n\nstatic long clk_hclk_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *parent_rate)\n{\n\tstruct lpc32xx_pll_clk *clk = to_lpc32xx_pll_clk(hw);\n\tu64 m_i, o = rate, i = *parent_rate, d = (u64)rate << 6;\n\tu64 m = 0, n = 0, p = 0;\n\tint p_i, n_i;\n\n\tpr_debug(\"%s: %lu/%lu\\n\", clk_hw_get_name(hw), *parent_rate, rate);\n\n\tif (rate > 266500000)\n\t\treturn -EINVAL;\n\n\t \n\tfor (p_i = 4; p_i >= 0; p_i--) {\n\t\tfor (n_i = 4; n_i > 0; n_i--) {\n\t\t\tm_i = div64_u64(o * n_i * (1 << p_i), i);\n\n\t\t\t \n\t\t\tif (!(m_i && m_i <= 256\n\t\t\t      && pll_is_valid(i, n_i, 1000000, 27000000)\n\t\t\t      && pll_is_valid(i * m_i * (1 << p_i), n_i,\n\t\t\t\t\t      156000000, 320000000)))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (o * n_i * (1 << p_i) - i * m_i <= d) {\n\t\t\t\tm = m_i;\n\t\t\t\tn = n_i;\n\t\t\t\tp = p_i;\n\t\t\t\td = o * n_i * (1 << p_i) - i * m_i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (d == (u64)rate << 6) {\n\t\tpr_err(\"%s: %lu: no valid PLL parameters are found\\n\",\n\t\t       clk_hw_get_name(hw), rate);\n\t\treturn -EINVAL;\n\t}\n\n\tclk->m_div = m;\n\tclk->n_div = n;\n\tclk->p_div = p;\n\n\t \n\tif (!p)\n\t\tclk->mode = PLL_DIRECT;\n\telse\n\t\tclk->mode = PLL_NON_INTEGER;\n\n\to = div64_u64(i * m, n * (1 << p));\n\n\tif (!d)\n\t\tpr_debug(\"%s: %lu: found exact match: %llu/%llu/%llu\\n\",\n\t\t\t clk_hw_get_name(hw), rate, m, n, p);\n\telse\n\t\tpr_debug(\"%s: %lu: found closest: %llu/%llu/%llu - %llu\\n\",\n\t\t\t clk_hw_get_name(hw), rate, m, n, p, o);\n\n\treturn o;\n}\n\nstatic long clk_usb_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long *parent_rate)\n{\n\tstruct lpc32xx_pll_clk *clk = to_lpc32xx_pll_clk(hw);\n\tstruct clk_hw *usb_div_hw, *osc_hw;\n\tu64 d_i, n_i, m, o;\n\n\tpr_debug(\"%s: %lu/%lu\\n\", clk_hw_get_name(hw), *parent_rate, rate);\n\n\t \n\tif (rate != 48000000)\n\t\treturn -EINVAL;\n\n\t \n\tusb_div_hw = clk_hw_get_parent_by_index(hw, 0);\n\tif (!usb_div_hw)\n\t\treturn -EINVAL;\n\n\t \n\tosc_hw = clk_hw_get_parent_by_index(usb_div_hw, 0);\n\tif (!osc_hw)\n\t\treturn -EINVAL;\n\to = clk_hw_get_rate(osc_hw);\t \n\n\t \n\tfor (d_i = 16; d_i >= 1; d_i--) {\n\t\tfor (n_i = 1; n_i <= 4; n_i++) {\n\t\t\tm = div64_u64(192000000 * d_i * n_i, o);\n\t\t\tif (!(m && m <= 256\n\t\t\t      && m * o == 192000000 * d_i * n_i\n\t\t\t      && pll_is_valid(o, d_i, 1000000, 20000000)\n\t\t\t      && pll_is_valid(o, d_i * n_i, 1000000, 27000000)))\n\t\t\t\tcontinue;\n\n\t\t\tclk->n_div = n_i;\n\t\t\tclk->m_div = m;\n\t\t\tclk->p_div = 2;\n\t\t\tclk->mode = PLL_NON_INTEGER;\n\t\t\t*parent_rate = div64_u64(o, d_i);\n\n\t\t\treturn rate;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n#define LPC32XX_DEFINE_PLL_OPS(_name, _rc, _sr, _rr)\t\t\t\\\n\tstatic const struct clk_ops clk_ ##_name ## _ops = {\t\t\\\n\t\t.enable = clk_pll_enable,\t\t\t\t\\\n\t\t.disable = clk_pll_disable,\t\t\t\t\\\n\t\t.is_enabled = clk_pll_is_enabled,\t\t\t\\\n\t\t.recalc_rate = _rc,\t\t\t\t\t\\\n\t\t.set_rate = _sr,\t\t\t\t\t\\\n\t\t.round_rate = _rr,\t\t\t\t\t\\\n\t}\n\nLPC32XX_DEFINE_PLL_OPS(pll_397x, clk_pll_397x_recalc_rate, NULL, NULL);\nLPC32XX_DEFINE_PLL_OPS(hclk_pll, clk_pll_recalc_rate,\n\t\t       clk_pll_set_rate, clk_hclk_pll_round_rate);\nLPC32XX_DEFINE_PLL_OPS(usb_pll,  clk_pll_recalc_rate,\n\t\t       clk_pll_set_rate, clk_usb_pll_round_rate);\n\nstatic int clk_ddram_is_enabled(struct clk_hw *hw)\n{\n\tstruct lpc32xx_clk *clk = to_lpc32xx_clk(hw);\n\tu32 val;\n\n\tregmap_read(clk_regmap, clk->reg, &val);\n\tval &= clk->enable_mask | clk->busy_mask;\n\n\treturn (val == (BIT(7) | BIT(0)) ||\n\t\tval == (BIT(8) | BIT(1)));\n}\n\nstatic int clk_ddram_enable(struct clk_hw *hw)\n{\n\tstruct lpc32xx_clk *clk = to_lpc32xx_clk(hw);\n\tu32 val, hclk_div;\n\n\tregmap_read(clk_regmap, clk->reg, &val);\n\thclk_div = val & clk->busy_mask;\n\n\t \n\tif (hclk_div == 0x0 || hclk_div == (BIT(1) | BIT(0)))\n\t\treturn -EINVAL;\n\n\treturn regmap_update_bits(clk_regmap, clk->reg,\n\t\t\t\t  clk->enable_mask, hclk_div << 7);\n}\n\nstatic unsigned long clk_ddram_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct lpc32xx_clk *clk = to_lpc32xx_clk(hw);\n\tu32 val;\n\n\tif (!clk_ddram_is_enabled(hw))\n\t\treturn 0;\n\n\tregmap_read(clk_regmap, clk->reg, &val);\n\tval &= clk->enable_mask;\n\n\treturn parent_rate / (val >> 7);\n}\n\nstatic const struct clk_ops clk_ddram_ops = {\n\t.enable = clk_ddram_enable,\n\t.disable = clk_mask_disable,\n\t.is_enabled = clk_ddram_is_enabled,\n\t.recalc_rate = clk_ddram_recalc_rate,\n};\n\nstatic unsigned long lpc32xx_clk_uart_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct lpc32xx_clk *clk = to_lpc32xx_clk(hw);\n\tu32 val, x, y;\n\n\tregmap_read(clk_regmap, clk->reg, &val);\n\tx = (val & 0xFF00) >> 8;\n\ty = val & 0xFF;\n\n\tif (x && y)\n\t\treturn (parent_rate * x) / y;\n\telse\n\t\treturn 0;\n}\n\nstatic const struct clk_ops lpc32xx_uart_div_ops = {\n\t.recalc_rate = lpc32xx_clk_uart_recalc_rate,\n};\n\nstatic const struct clk_div_table clk_hclk_div_table[] = {\n\t{ .val = 0, .div = 1 },\n\t{ .val = 1, .div = 2 },\n\t{ .val = 2, .div = 4 },\n\t{ },\n};\n\nstatic u32 test1_mux_table[] = { 0, 1, 2, };\nstatic u32 test2_mux_table[] = { 0, 1, 2, 5, 7, };\n\nstatic int clk_usb_enable(struct clk_hw *hw)\n{\n\tstruct lpc32xx_usb_clk *clk = to_lpc32xx_usb_clk(hw);\n\tu32 val, ctrl_val, count;\n\n\tpr_debug(\"%s: 0x%x\\n\", clk_hw_get_name(hw), clk->enable);\n\n\tif (clk->ctrl_mask) {\n\t\tregmap_read(clk_regmap, LPC32XX_CLKPWR_USB_CTRL, &ctrl_val);\n\t\tregmap_update_bits(clk_regmap, LPC32XX_CLKPWR_USB_CTRL,\n\t\t\t\t   clk->ctrl_mask, clk->ctrl_enable);\n\t}\n\n\tval = lpc32xx_usb_clk_read(clk);\n\tif (clk->busy && (val & clk->busy) == clk->busy) {\n\t\tif (clk->ctrl_mask)\n\t\t\tregmap_write(clk_regmap, LPC32XX_CLKPWR_USB_CTRL,\n\t\t\t\t     ctrl_val);\n\t\treturn -EBUSY;\n\t}\n\n\tval |= clk->enable;\n\tlpc32xx_usb_clk_write(clk, val);\n\n\tfor (count = 0; count < 1000; count++) {\n\t\tval = lpc32xx_usb_clk_read(clk);\n\t\tif ((val & clk->enable) == clk->enable)\n\t\t\tbreak;\n\t}\n\n\tif ((val & clk->enable) == clk->enable)\n\t\treturn 0;\n\n\tif (clk->ctrl_mask)\n\t\tregmap_write(clk_regmap, LPC32XX_CLKPWR_USB_CTRL, ctrl_val);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void clk_usb_disable(struct clk_hw *hw)\n{\n\tstruct lpc32xx_usb_clk *clk = to_lpc32xx_usb_clk(hw);\n\tu32 val = lpc32xx_usb_clk_read(clk);\n\n\tval &= ~clk->enable;\n\tlpc32xx_usb_clk_write(clk, val);\n\n\tif (clk->ctrl_mask)\n\t\tregmap_update_bits(clk_regmap, LPC32XX_CLKPWR_USB_CTRL,\n\t\t\t\t   clk->ctrl_mask, clk->ctrl_disable);\n}\n\nstatic int clk_usb_is_enabled(struct clk_hw *hw)\n{\n\tstruct lpc32xx_usb_clk *clk = to_lpc32xx_usb_clk(hw);\n\tu32 ctrl_val, val;\n\n\tif (clk->ctrl_mask) {\n\t\tregmap_read(clk_regmap, LPC32XX_CLKPWR_USB_CTRL, &ctrl_val);\n\t\tif ((ctrl_val & clk->ctrl_mask) != clk->ctrl_enable)\n\t\t\treturn 0;\n\t}\n\n\tval = lpc32xx_usb_clk_read(clk);\n\n\treturn ((val & clk->enable) == clk->enable);\n}\n\nstatic unsigned long clk_usb_i2c_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\treturn clk_get_rate(clk[LPC32XX_CLK_PERIPH]);\n}\n\nstatic const struct clk_ops clk_usb_ops = {\n\t.enable = clk_usb_enable,\n\t.disable = clk_usb_disable,\n\t.is_enabled = clk_usb_is_enabled,\n};\n\nstatic const struct clk_ops clk_usb_i2c_ops = {\n\t.enable = clk_usb_enable,\n\t.disable = clk_usb_disable,\n\t.is_enabled = clk_usb_is_enabled,\n\t.recalc_rate = clk_usb_i2c_recalc_rate,\n};\n\nstatic int lpc32xx_clk_gate_enable(struct clk_hw *hw)\n{\n\tstruct lpc32xx_clk_gate *clk = to_lpc32xx_gate(hw);\n\tu32 mask = BIT(clk->bit_idx);\n\tu32 val = (clk->flags & CLK_GATE_SET_TO_DISABLE ? 0x0 : mask);\n\n\treturn regmap_update_bits(clk_regmap, clk->reg, mask, val);\n}\n\nstatic void lpc32xx_clk_gate_disable(struct clk_hw *hw)\n{\n\tstruct lpc32xx_clk_gate *clk = to_lpc32xx_gate(hw);\n\tu32 mask = BIT(clk->bit_idx);\n\tu32 val = (clk->flags & CLK_GATE_SET_TO_DISABLE ? mask : 0x0);\n\n\tregmap_update_bits(clk_regmap, clk->reg, mask, val);\n}\n\nstatic int lpc32xx_clk_gate_is_enabled(struct clk_hw *hw)\n{\n\tstruct lpc32xx_clk_gate *clk = to_lpc32xx_gate(hw);\n\tu32 val;\n\tbool is_set;\n\n\tregmap_read(clk_regmap, clk->reg, &val);\n\tis_set = val & BIT(clk->bit_idx);\n\n\treturn (clk->flags & CLK_GATE_SET_TO_DISABLE ? !is_set : is_set);\n}\n\nstatic const struct clk_ops lpc32xx_clk_gate_ops = {\n\t.enable = lpc32xx_clk_gate_enable,\n\t.disable = lpc32xx_clk_gate_disable,\n\t.is_enabled = lpc32xx_clk_gate_is_enabled,\n};\n\n#define div_mask(width)\t((1 << (width)) - 1)\n\nstatic unsigned int _get_table_div(const struct clk_div_table *table,\n\t\t\t\t\t\t\tunsigned int val)\n{\n\tconst struct clk_div_table *clkt;\n\n\tfor (clkt = table; clkt->div; clkt++)\n\t\tif (clkt->val == val)\n\t\t\treturn clkt->div;\n\treturn 0;\n}\n\nstatic unsigned int _get_div(const struct clk_div_table *table,\n\t\t\t     unsigned int val, unsigned long flags, u8 width)\n{\n\tif (flags & CLK_DIVIDER_ONE_BASED)\n\t\treturn val;\n\tif (table)\n\t\treturn _get_table_div(table, val);\n\treturn val + 1;\n}\n\nstatic unsigned long clk_divider_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct lpc32xx_clk_div *divider = to_lpc32xx_div(hw);\n\tunsigned int val;\n\n\tregmap_read(clk_regmap, divider->reg, &val);\n\n\tval >>= divider->shift;\n\tval &= div_mask(divider->width);\n\n\treturn divider_recalc_rate(hw, parent_rate, val, divider->table,\n\t\t\t\t   divider->flags, divider->width);\n}\n\nstatic long clk_divider_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *prate)\n{\n\tstruct lpc32xx_clk_div *divider = to_lpc32xx_div(hw);\n\tunsigned int bestdiv;\n\n\t \n\tif (divider->flags & CLK_DIVIDER_READ_ONLY) {\n\t\tregmap_read(clk_regmap, divider->reg, &bestdiv);\n\t\tbestdiv >>= divider->shift;\n\t\tbestdiv &= div_mask(divider->width);\n\t\tbestdiv = _get_div(divider->table, bestdiv, divider->flags,\n\t\t\tdivider->width);\n\t\treturn DIV_ROUND_UP(*prate, bestdiv);\n\t}\n\n\treturn divider_round_rate(hw, rate, prate, divider->table,\n\t\t\t\t  divider->width, divider->flags);\n}\n\nstatic int clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct lpc32xx_clk_div *divider = to_lpc32xx_div(hw);\n\tunsigned int value;\n\n\tvalue = divider_get_val(rate, parent_rate, divider->table,\n\t\t\t\tdivider->width, divider->flags);\n\n\treturn regmap_update_bits(clk_regmap, divider->reg,\n\t\t\t\t  div_mask(divider->width) << divider->shift,\n\t\t\t\t  value << divider->shift);\n}\n\nstatic const struct clk_ops lpc32xx_clk_divider_ops = {\n\t.recalc_rate = clk_divider_recalc_rate,\n\t.round_rate = clk_divider_round_rate,\n\t.set_rate = clk_divider_set_rate,\n};\n\nstatic u8 clk_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct lpc32xx_clk_mux *mux = to_lpc32xx_mux(hw);\n\tu32 num_parents = clk_hw_get_num_parents(hw);\n\tu32 val;\n\n\tregmap_read(clk_regmap, mux->reg, &val);\n\tval >>= mux->shift;\n\tval &= mux->mask;\n\n\tif (mux->table) {\n\t\tu32 i;\n\n\t\tfor (i = 0; i < num_parents; i++)\n\t\t\tif (mux->table[i] == val)\n\t\t\t\treturn i;\n\t\treturn -EINVAL;\n\t}\n\n\tif (val >= num_parents)\n\t\treturn -EINVAL;\n\n\treturn val;\n}\n\nstatic int clk_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct lpc32xx_clk_mux *mux = to_lpc32xx_mux(hw);\n\n\tif (mux->table)\n\t\tindex = mux->table[index];\n\n\treturn regmap_update_bits(clk_regmap, mux->reg,\n\t\t\t  mux->mask << mux->shift, index << mux->shift);\n}\n\nstatic const struct clk_ops lpc32xx_clk_mux_ro_ops = {\n\t.get_parent = clk_mux_get_parent,\n};\n\nstatic const struct clk_ops lpc32xx_clk_mux_ops = {\n\t.get_parent = clk_mux_get_parent,\n\t.set_parent = clk_mux_set_parent,\n\t.determine_rate = __clk_mux_determine_rate,\n};\n\nenum lpc32xx_clk_type {\n\tCLK_FIXED,\n\tCLK_MUX,\n\tCLK_DIV,\n\tCLK_GATE,\n\tCLK_COMPOSITE,\n\tCLK_LPC32XX,\n\tCLK_LPC32XX_PLL,\n\tCLK_LPC32XX_USB,\n};\n\nstruct clk_hw_proto0 {\n\tconst struct clk_ops *ops;\n\tunion {\n\t\tstruct lpc32xx_pll_clk pll;\n\t\tstruct lpc32xx_clk clk;\n\t\tstruct lpc32xx_usb_clk usb_clk;\n\t\tstruct lpc32xx_clk_mux mux;\n\t\tstruct lpc32xx_clk_div div;\n\t\tstruct lpc32xx_clk_gate gate;\n\t};\n};\n\nstruct clk_hw_proto1 {\n\tstruct clk_hw_proto0 *mux;\n\tstruct clk_hw_proto0 *div;\n\tstruct clk_hw_proto0 *gate;\n};\n\nstruct clk_hw_proto {\n\tenum lpc32xx_clk_type type;\n\n\tunion {\n\t\tstruct clk_fixed_rate f;\n\t\tstruct clk_hw_proto0 hw0;\n\t\tstruct clk_hw_proto1 hw1;\n\t};\n};\n\n#define LPC32XX_DEFINE_FIXED(_idx, _rate)\t\t\t\\\n[CLK_PREFIX(_idx)] = {\t\t\t\t\t\t\t\\\n\t.type = CLK_FIXED,\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.f = {\t\t\t\t\t\t\t\\\n\t\t\t.fixed_rate = (_rate),\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\n#define LPC32XX_DEFINE_PLL(_idx, _name, _reg, _enable)\t\t\t\\\n[CLK_PREFIX(_idx)] = {\t\t\t\t\t\t\t\\\n\t.type = CLK_LPC32XX_PLL,\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.hw0 = {\t\t\t\t\t\t\\\n\t\t\t.ops = &clk_ ##_name ## _ops,\t\t\t\\\n\t\t\t{\t\t\t\t\t\t\\\n\t\t\t\t.pll = {\t\t\t\t\\\n\t\t\t\t\t.reg = LPC32XX_CLKPWR_ ## _reg,\t\\\n\t\t\t\t\t.enable = (_enable),\t\t\\\n\t\t\t\t},\t\t\t\t\t\\\n\t\t\t},\t\t\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\n#define LPC32XX_DEFINE_MUX(_idx, _reg, _shift, _mask, _table, _flags)\t\\\n[CLK_PREFIX(_idx)] = {\t\t\t\t\t\t\t\\\n\t.type = CLK_MUX,\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.hw0 = {\t\t\t\t\t\t\\\n\t\t\t.ops = (_flags & CLK_MUX_READ_ONLY ?\t\t\\\n\t\t\t\t&lpc32xx_clk_mux_ro_ops :\t\t\\\n\t\t\t\t&lpc32xx_clk_mux_ops),\t\t\t\\\n\t\t\t{\t\t\t\t\t\t\\\n\t\t\t\t.mux = {\t\t\t\t\\\n\t\t\t\t\t.reg = LPC32XX_CLKPWR_ ## _reg,\t\\\n\t\t\t\t\t.mask = (_mask),\t\t\\\n\t\t\t\t\t.shift = (_shift),\t\t\\\n\t\t\t\t\t.table = (_table),\t\t\\\n\t\t\t\t\t.flags = (_flags),\t\t\\\n\t\t\t\t},\t\t\t\t\t\\\n\t\t\t},\t\t\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\n#define LPC32XX_DEFINE_DIV(_idx, _reg, _shift, _width, _table, _flags)\t\\\n[CLK_PREFIX(_idx)] = {\t\t\t\t\t\t\t\\\n\t.type = CLK_DIV,\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.hw0 = {\t\t\t\t\t\t\\\n\t\t\t.ops = &lpc32xx_clk_divider_ops,\t\t\\\n\t\t\t{\t\t\t\t\t\t\\\n\t\t\t\t.div = {\t\t\t\t\\\n\t\t\t\t\t.reg = LPC32XX_CLKPWR_ ## _reg,\t\\\n\t\t\t\t\t.shift = (_shift),\t\t\\\n\t\t\t\t\t.width = (_width),\t\t\\\n\t\t\t\t\t.table = (_table),\t\t\\\n\t\t\t\t\t.flags = (_flags),\t\t\\\n\t\t\t\t },\t\t\t\t\t\\\n\t\t\t},\t\t\t\t\t\t\\\n\t\t },\t\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\n#define LPC32XX_DEFINE_GATE(_idx, _reg, _bit, _flags)\t\t\t\\\n[CLK_PREFIX(_idx)] = {\t\t\t\t\t\t\t\\\n\t.type = CLK_GATE,\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.hw0 = {\t\t\t\t\t\t\\\n\t\t\t.ops = &lpc32xx_clk_gate_ops,\t\t\t\\\n\t\t\t{\t\t\t\t\t\t\\\n\t\t\t\t.gate = {\t\t\t\t\\\n\t\t\t\t\t.reg = LPC32XX_CLKPWR_ ## _reg,\t\\\n\t\t\t\t\t.bit_idx = (_bit),\t\t\\\n\t\t\t\t\t.flags = (_flags),\t\t\\\n\t\t\t\t},\t\t\t\t\t\\\n\t\t\t},\t\t\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\n#define LPC32XX_DEFINE_CLK(_idx, _reg, _e, _em, _d, _dm, _b, _bm, _ops)\t\\\n[CLK_PREFIX(_idx)] = {\t\t\t\t\t\t\t\\\n\t.type = CLK_LPC32XX,\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.hw0 = {\t\t\t\t\t\t\\\n\t\t\t.ops = &(_ops),\t\t\t\t\t\\\n\t\t\t{\t\t\t\t\t\t\\\n\t\t\t\t.clk = {\t\t\t\t\\\n\t\t\t\t\t.reg = LPC32XX_CLKPWR_ ## _reg,\t\\\n\t\t\t\t\t.enable = (_e),\t\t\t\\\n\t\t\t\t\t.enable_mask = (_em),\t\t\\\n\t\t\t\t\t.disable = (_d),\t\t\\\n\t\t\t\t\t.disable_mask = (_dm),\t\t\\\n\t\t\t\t\t.busy = (_b),\t\t\t\\\n\t\t\t\t\t.busy_mask = (_bm),\t\t\\\n\t\t\t\t},\t\t\t\t\t\\\n\t\t\t},\t\t\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\n#define LPC32XX_DEFINE_USB(_idx, _ce, _cd, _cm, _e, _b, _ops)\t\t\\\n[CLK_PREFIX(_idx)] = {\t\t\t\t\t\t\t\\\n\t.type = CLK_LPC32XX_USB,\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.hw0 = {\t\t\t\t\t\t\\\n\t\t\t.ops = &(_ops),\t\t\t\t\t\\\n\t\t\t{\t\t\t\t\t\t\\\n\t\t\t\t.usb_clk = {\t\t\t\t\\\n\t\t\t\t\t.ctrl_enable = (_ce),\t\t\\\n\t\t\t\t\t.ctrl_disable = (_cd),\t\t\\\n\t\t\t\t\t.ctrl_mask = (_cm),\t\t\\\n\t\t\t\t\t.enable = (_e),\t\t\t\\\n\t\t\t\t\t.busy = (_b),\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t\t},\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\n#define LPC32XX_DEFINE_COMPOSITE(_idx, _mux, _div, _gate)\t\t\\\n[CLK_PREFIX(_idx)] = {\t\t\t\t\t\t\t\\\n\t.type = CLK_COMPOSITE,\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.hw1 = {\t\t\t\t\t\t\\\n\t\t.mux = (CLK_PREFIX(_mux) == LPC32XX_CLK__NULL ? NULL :\t\\\n\t\t\t&clk_hw_proto[CLK_PREFIX(_mux)].hw0),\t\t\\\n\t\t.div = (CLK_PREFIX(_div) == LPC32XX_CLK__NULL ? NULL :\t\\\n\t\t\t&clk_hw_proto[CLK_PREFIX(_div)].hw0),\t\t\\\n\t\t.gate = (CLK_PREFIX(_gate) == LPC32XX_CLK__NULL ? NULL :\\\n\t\t\t &clk_hw_proto[CLK_PREFIX(_gate)].hw0),\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nstatic struct clk_hw_proto clk_hw_proto[LPC32XX_CLK_HW_MAX] = {\n\tLPC32XX_DEFINE_FIXED(RTC, 32768),\n\tLPC32XX_DEFINE_PLL(PLL397X, pll_397x, HCLKPLL_CTRL, BIT(1)),\n\tLPC32XX_DEFINE_PLL(HCLK_PLL, hclk_pll, HCLKPLL_CTRL, PLL_CTRL_ENABLE),\n\tLPC32XX_DEFINE_PLL(USB_PLL, usb_pll, USB_CTRL, PLL_CTRL_ENABLE),\n\tLPC32XX_DEFINE_GATE(OSC, OSC_CTRL, 0, CLK_GATE_SET_TO_DISABLE),\n\tLPC32XX_DEFINE_GATE(USB, USB_CTRL, 18, 0),\n\n\tLPC32XX_DEFINE_DIV(HCLK_DIV_PERIPH, HCLKDIV_CTRL, 2, 5, NULL,\n\t\t\t   CLK_DIVIDER_READ_ONLY),\n\tLPC32XX_DEFINE_DIV(HCLK_DIV, HCLKDIV_CTRL, 0, 2, clk_hclk_div_table,\n\t\t\t   CLK_DIVIDER_READ_ONLY),\n\n\t \n\tLPC32XX_DEFINE_MUX(SYSCLK_PERIPH_MUX, PWR_CTRL, 2, 0x1, NULL,\n\t\t\t   CLK_MUX_READ_ONLY),\n\tLPC32XX_DEFINE_MUX(SYSCLK_HCLK_MUX, PWR_CTRL, 2, 0x1, NULL,\n\t\t\t   CLK_MUX_READ_ONLY),\n\tLPC32XX_DEFINE_MUX(SYSCLK_ARM_MUX, PWR_CTRL, 2, 0x1, NULL,\n\t\t\t   CLK_MUX_READ_ONLY),\n\t \n\tLPC32XX_DEFINE_MUX(PERIPH_HCLK_MUX, PWR_CTRL, 10, 0x1, NULL,\n\t\t\t   CLK_MUX_READ_ONLY),\n\tLPC32XX_DEFINE_MUX(PERIPH_ARM_MUX, PWR_CTRL, 10, 0x1, NULL,\n\t\t\t   CLK_MUX_READ_ONLY),\n\n\t \n\tLPC32XX_DEFINE_GATE(PERIPH, PWR_CTRL, 0, CLK_GATE_SET_TO_DISABLE),\n\tLPC32XX_DEFINE_GATE(HCLK, PWR_CTRL, 0, CLK_GATE_SET_TO_DISABLE),\n\tLPC32XX_DEFINE_GATE(ARM, PWR_CTRL, 0, CLK_GATE_SET_TO_DISABLE),\n\n\tLPC32XX_DEFINE_GATE(ARM_VFP, DEBUG_CTRL, 4, 0),\n\tLPC32XX_DEFINE_GATE(DMA, DMA_CLK_CTRL, 0, 0),\n\tLPC32XX_DEFINE_CLK(DDRAM, HCLKDIV_CTRL, 0x0, BIT(8) | BIT(7),\n\t\t   0x0, BIT(8) | BIT(7), 0x0, BIT(1) | BIT(0), clk_ddram_ops),\n\n\tLPC32XX_DEFINE_GATE(TIMER0, TIMCLK_CTRL1, 2, 0),\n\tLPC32XX_DEFINE_GATE(TIMER1, TIMCLK_CTRL1, 3, 0),\n\tLPC32XX_DEFINE_GATE(TIMER2, TIMCLK_CTRL1, 4, 0),\n\tLPC32XX_DEFINE_GATE(TIMER3, TIMCLK_CTRL1, 5, 0),\n\tLPC32XX_DEFINE_GATE(TIMER4, TIMCLK_CTRL1, 0, 0),\n\tLPC32XX_DEFINE_GATE(TIMER5, TIMCLK_CTRL1, 1, 0),\n\n\tLPC32XX_DEFINE_GATE(SSP0, SSP_CTRL, 0, 0),\n\tLPC32XX_DEFINE_GATE(SSP1, SSP_CTRL, 1, 0),\n\tLPC32XX_DEFINE_GATE(SPI1, SPI_CTRL, 0, 0),\n\tLPC32XX_DEFINE_GATE(SPI2, SPI_CTRL, 4, 0),\n\tLPC32XX_DEFINE_GATE(I2S0, I2S_CTRL, 0, 0),\n\tLPC32XX_DEFINE_GATE(I2S1, I2S_CTRL, 1, 0),\n\tLPC32XX_DEFINE_GATE(I2C1, I2CCLK_CTRL, 0, 0),\n\tLPC32XX_DEFINE_GATE(I2C2, I2CCLK_CTRL, 1, 0),\n\tLPC32XX_DEFINE_GATE(WDOG, TIMCLK_CTRL, 0, 0),\n\tLPC32XX_DEFINE_GATE(HSTIMER, TIMCLK_CTRL, 1, 0),\n\n\tLPC32XX_DEFINE_GATE(KEY, KEYCLK_CTRL, 0, 0),\n\tLPC32XX_DEFINE_GATE(MCPWM, TIMCLK_CTRL1, 6, 0),\n\n\tLPC32XX_DEFINE_MUX(PWM1_MUX, PWMCLK_CTRL, 1, 0x1, NULL, 0),\n\tLPC32XX_DEFINE_DIV(PWM1_DIV, PWMCLK_CTRL, 4, 4, NULL,\n\t\t\t   CLK_DIVIDER_ONE_BASED),\n\tLPC32XX_DEFINE_GATE(PWM1_GATE, PWMCLK_CTRL, 0, 0),\n\tLPC32XX_DEFINE_COMPOSITE(PWM1, PWM1_MUX, PWM1_DIV, PWM1_GATE),\n\n\tLPC32XX_DEFINE_MUX(PWM2_MUX, PWMCLK_CTRL, 3, 0x1, NULL, 0),\n\tLPC32XX_DEFINE_DIV(PWM2_DIV, PWMCLK_CTRL, 8, 4, NULL,\n\t\t\t   CLK_DIVIDER_ONE_BASED),\n\tLPC32XX_DEFINE_GATE(PWM2_GATE, PWMCLK_CTRL, 2, 0),\n\tLPC32XX_DEFINE_COMPOSITE(PWM2, PWM2_MUX, PWM2_DIV, PWM2_GATE),\n\n\tLPC32XX_DEFINE_MUX(UART3_MUX, UART3_CLK_CTRL, 16, 0x1, NULL, 0),\n\tLPC32XX_DEFINE_CLK(UART3_DIV, UART3_CLK_CTRL,\n\t\t\t   0, 0, 0, 0, 0, 0, lpc32xx_uart_div_ops),\n\tLPC32XX_DEFINE_GATE(UART3_GATE, UART_CLK_CTRL, 0, 0),\n\tLPC32XX_DEFINE_COMPOSITE(UART3, UART3_MUX, UART3_DIV, UART3_GATE),\n\n\tLPC32XX_DEFINE_MUX(UART4_MUX, UART4_CLK_CTRL, 16, 0x1, NULL, 0),\n\tLPC32XX_DEFINE_CLK(UART4_DIV, UART4_CLK_CTRL,\n\t\t\t   0, 0, 0, 0, 0, 0, lpc32xx_uart_div_ops),\n\tLPC32XX_DEFINE_GATE(UART4_GATE, UART_CLK_CTRL, 1, 0),\n\tLPC32XX_DEFINE_COMPOSITE(UART4, UART4_MUX, UART4_DIV, UART4_GATE),\n\n\tLPC32XX_DEFINE_MUX(UART5_MUX, UART5_CLK_CTRL, 16, 0x1, NULL, 0),\n\tLPC32XX_DEFINE_CLK(UART5_DIV, UART5_CLK_CTRL,\n\t\t\t   0, 0, 0, 0, 0, 0, lpc32xx_uart_div_ops),\n\tLPC32XX_DEFINE_GATE(UART5_GATE, UART_CLK_CTRL, 2, 0),\n\tLPC32XX_DEFINE_COMPOSITE(UART5, UART5_MUX, UART5_DIV, UART5_GATE),\n\n\tLPC32XX_DEFINE_MUX(UART6_MUX, UART6_CLK_CTRL, 16, 0x1, NULL, 0),\n\tLPC32XX_DEFINE_CLK(UART6_DIV, UART6_CLK_CTRL,\n\t\t\t   0, 0, 0, 0, 0, 0, lpc32xx_uart_div_ops),\n\tLPC32XX_DEFINE_GATE(UART6_GATE, UART_CLK_CTRL, 3, 0),\n\tLPC32XX_DEFINE_COMPOSITE(UART6, UART6_MUX, UART6_DIV, UART6_GATE),\n\n\tLPC32XX_DEFINE_CLK(IRDA, IRDA_CLK_CTRL,\n\t\t\t   0, 0, 0, 0, 0, 0, lpc32xx_uart_div_ops),\n\n\tLPC32XX_DEFINE_MUX(TEST1_MUX, TEST_CLK_CTRL, 5, 0x3,\n\t\t\t   test1_mux_table, 0),\n\tLPC32XX_DEFINE_GATE(TEST1_GATE, TEST_CLK_CTRL, 4, 0),\n\tLPC32XX_DEFINE_COMPOSITE(TEST1, TEST1_MUX, _NULL, TEST1_GATE),\n\n\tLPC32XX_DEFINE_MUX(TEST2_MUX, TEST_CLK_CTRL, 1, 0x7,\n\t\t\t   test2_mux_table, 0),\n\tLPC32XX_DEFINE_GATE(TEST2_GATE, TEST_CLK_CTRL, 0, 0),\n\tLPC32XX_DEFINE_COMPOSITE(TEST2, TEST2_MUX, _NULL, TEST2_GATE),\n\n\tLPC32XX_DEFINE_MUX(SYS, SYSCLK_CTRL, 0, 0x1, NULL, CLK_MUX_READ_ONLY),\n\n\tLPC32XX_DEFINE_DIV(USB_DIV_DIV, USB_DIV, 0, 4, NULL, 0),\n\tLPC32XX_DEFINE_GATE(USB_DIV_GATE, USB_CTRL, 17, 0),\n\tLPC32XX_DEFINE_COMPOSITE(USB_DIV, _NULL, USB_DIV_DIV, USB_DIV_GATE),\n\n\tLPC32XX_DEFINE_DIV(SD_DIV, MS_CTRL, 0, 4, NULL, CLK_DIVIDER_ONE_BASED),\n\tLPC32XX_DEFINE_CLK(SD_GATE, MS_CTRL, BIT(5) | BIT(9), BIT(5) | BIT(9),\n\t\t\t   0x0, BIT(5) | BIT(9), 0x0, 0x0, clk_mask_ops),\n\tLPC32XX_DEFINE_COMPOSITE(SD, _NULL, SD_DIV, SD_GATE),\n\n\tLPC32XX_DEFINE_DIV(LCD_DIV, LCDCLK_CTRL, 0, 5, NULL, 0),\n\tLPC32XX_DEFINE_GATE(LCD_GATE, LCDCLK_CTRL, 5, 0),\n\tLPC32XX_DEFINE_COMPOSITE(LCD, _NULL, LCD_DIV, LCD_GATE),\n\n\tLPC32XX_DEFINE_CLK(MAC, MACCLK_CTRL,\n\t\t\t   BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1) | BIT(0),\n\t\t\t   BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1) | BIT(0),\n\t\t\t   0x0, 0x0, clk_mask_ops),\n\tLPC32XX_DEFINE_CLK(SLC, FLASHCLK_CTRL,\n\t\t\t   BIT(2) | BIT(0), BIT(2) | BIT(0), 0x0,\n\t\t\t   BIT(0), BIT(1), BIT(2) | BIT(1), clk_mask_ops),\n\tLPC32XX_DEFINE_CLK(MLC, FLASHCLK_CTRL,\n\t\t\t   BIT(1), BIT(2) | BIT(1), 0x0, BIT(1),\n\t\t\t   BIT(2) | BIT(0), BIT(2) | BIT(0), clk_mask_ops),\n\t \n\tLPC32XX_DEFINE_DIV(ADC_DIV, ADCCLK_CTRL1, 0, 8, NULL, 0),\n\tLPC32XX_DEFINE_GATE(ADC_RTC, ADCCLK_CTRL, 0, 0),\n\tLPC32XX_DEFINE_MUX(ADC, ADCCLK_CTRL1, 8, 0x1, NULL, 0),\n\n\t \n\tLPC32XX_DEFINE_USB(USB_AHB,\n\t\t\t   BIT(24), 0x0, BIT(24), BIT(4), 0, clk_usb_ops),\n\tLPC32XX_DEFINE_USB(USB_OTG,\n\t\t\t   0x0, 0x0, 0x0, BIT(3), 0, clk_usb_ops),\n\tLPC32XX_DEFINE_USB(USB_I2C,\n\t\t\t   0x0, BIT(23), BIT(23), BIT(2), 0, clk_usb_i2c_ops),\n\tLPC32XX_DEFINE_USB(USB_DEV,\n\t\t\t   BIT(22), 0x0, BIT(22), BIT(1), BIT(0), clk_usb_ops),\n\tLPC32XX_DEFINE_USB(USB_HOST,\n\t\t\t   BIT(21), 0x0, BIT(21), BIT(0), BIT(1), clk_usb_ops),\n};\n\nstatic struct clk * __init lpc32xx_clk_register(u32 id)\n{\n\tconst struct clk_proto_t *lpc32xx_clk = &clk_proto[id];\n\tstruct clk_hw_proto *clk_hw = &clk_hw_proto[id];\n\tconst char *parents[LPC32XX_CLK_PARENTS_MAX];\n\tstruct clk *clk;\n\tunsigned int i;\n\n\tfor (i = 0; i < lpc32xx_clk->num_parents; i++)\n\t\tparents[i] = clk_proto[lpc32xx_clk->parents[i]].name;\n\n\tpr_debug(\"%s: derived from '%s', clock type %d\\n\", lpc32xx_clk->name,\n\t\t parents[0], clk_hw->type);\n\n\tswitch (clk_hw->type) {\n\tcase CLK_LPC32XX:\n\tcase CLK_LPC32XX_PLL:\n\tcase CLK_LPC32XX_USB:\n\tcase CLK_MUX:\n\tcase CLK_DIV:\n\tcase CLK_GATE:\n\t{\n\t\tstruct clk_init_data clk_init = {\n\t\t\t.name = lpc32xx_clk->name,\n\t\t\t.parent_names = parents,\n\t\t\t.num_parents = lpc32xx_clk->num_parents,\n\t\t\t.flags = lpc32xx_clk->flags,\n\t\t\t.ops = clk_hw->hw0.ops,\n\t\t};\n\t\tstruct clk_hw *hw;\n\n\t\tif (clk_hw->type == CLK_LPC32XX)\n\t\t\thw = &clk_hw->hw0.clk.hw;\n\t\telse if (clk_hw->type == CLK_LPC32XX_PLL)\n\t\t\thw = &clk_hw->hw0.pll.hw;\n\t\telse if (clk_hw->type == CLK_LPC32XX_USB)\n\t\t\thw = &clk_hw->hw0.usb_clk.hw;\n\t\telse if (clk_hw->type == CLK_MUX)\n\t\t\thw = &clk_hw->hw0.mux.hw;\n\t\telse if (clk_hw->type == CLK_DIV)\n\t\t\thw = &clk_hw->hw0.div.hw;\n\t\telse if (clk_hw->type == CLK_GATE)\n\t\t\thw = &clk_hw->hw0.gate.hw;\n\t\telse\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\thw->init = &clk_init;\n\t\tclk = clk_register(NULL, hw);\n\t\tbreak;\n\t}\n\tcase CLK_COMPOSITE:\n\t{\n\t\tstruct clk_hw *mux_hw = NULL, *div_hw = NULL, *gate_hw = NULL;\n\t\tconst struct clk_ops *mops = NULL, *dops = NULL, *gops = NULL;\n\t\tstruct clk_hw_proto0 *mux0, *div0, *gate0;\n\n\t\tmux0 = clk_hw->hw1.mux;\n\t\tdiv0 = clk_hw->hw1.div;\n\t\tgate0 = clk_hw->hw1.gate;\n\t\tif (mux0) {\n\t\t\tmops = mux0->ops;\n\t\t\tmux_hw = &mux0->clk.hw;\n\t\t}\n\t\tif (div0) {\n\t\t\tdops = div0->ops;\n\t\t\tdiv_hw = &div0->clk.hw;\n\t\t}\n\t\tif (gate0) {\n\t\t\tgops = gate0->ops;\n\t\t\tgate_hw = &gate0->clk.hw;\n\t\t}\n\n\t\tclk = clk_register_composite(NULL, lpc32xx_clk->name,\n\t\t\t\tparents, lpc32xx_clk->num_parents,\n\t\t\t\tmux_hw, mops, div_hw, dops,\n\t\t\t\tgate_hw, gops, lpc32xx_clk->flags);\n\t\tbreak;\n\t}\n\tcase CLK_FIXED:\n\t{\n\t\tstruct clk_fixed_rate *fixed = &clk_hw->f;\n\n\t\tclk = clk_register_fixed_rate(NULL, lpc32xx_clk->name,\n\t\t\tparents[0], 0, fixed->fixed_rate);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tclk = ERR_PTR(-EINVAL);\n\t}\n\n\treturn clk;\n}\n\nstatic void __init lpc32xx_clk_div_quirk(u32 reg, u32 div_mask, u32 gate)\n{\n\tu32 val;\n\n\tregmap_read(clk_regmap, reg, &val);\n\n\tif (!(val & div_mask)) {\n\t\tval &= ~gate;\n\t\tval |= BIT(__ffs(div_mask));\n\t}\n\n\tregmap_update_bits(clk_regmap, reg, gate | div_mask, val);\n}\n\nstatic void __init lpc32xx_clk_init(struct device_node *np)\n{\n\tunsigned int i;\n\tstruct clk *clk_osc, *clk_32k;\n\tvoid __iomem *base = NULL;\n\n\t \n\tclk_32k = of_clk_get_by_name(np, clk_proto[LPC32XX_CLK_XTAL_32K].name);\n\tif (IS_ERR(clk_32k)) {\n\t\tpr_err(\"failed to find external 32KHz clock: %ld\\n\",\n\t\t       PTR_ERR(clk_32k));\n\t\treturn;\n\t}\n\tif (clk_get_rate(clk_32k) != 32768) {\n\t\tpr_err(\"invalid clock rate of external 32KHz oscillator\\n\");\n\t\treturn;\n\t}\n\n\tclk_osc = of_clk_get_by_name(np, clk_proto[LPC32XX_CLK_XTAL].name);\n\tif (IS_ERR(clk_osc)) {\n\t\tpr_err(\"failed to find external main oscillator clock: %ld\\n\",\n\t\t       PTR_ERR(clk_osc));\n\t\treturn;\n\t}\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tpr_err(\"failed to map system control block registers\\n\");\n\t\treturn;\n\t}\n\n\tclk_regmap = regmap_init_mmio(NULL, base, &lpc32xx_scb_regmap_config);\n\tif (IS_ERR(clk_regmap)) {\n\t\tpr_err(\"failed to regmap system control block: %ld\\n\",\n\t\t\tPTR_ERR(clk_regmap));\n\t\tiounmap(base);\n\t\treturn;\n\t}\n\n\t \n\tlpc32xx_clk_div_quirk(LPC32XX_CLKPWR_PWMCLK_CTRL, 0xf0, BIT(0));\n\tlpc32xx_clk_div_quirk(LPC32XX_CLKPWR_PWMCLK_CTRL, 0xf00, BIT(2));\n\tlpc32xx_clk_div_quirk(LPC32XX_CLKPWR_MS_CTRL, 0xf, BIT(5) | BIT(9));\n\n\tfor (i = 1; i < LPC32XX_CLK_MAX; i++) {\n\t\tclk[i] = lpc32xx_clk_register(i);\n\t\tif (IS_ERR(clk[i])) {\n\t\t\tpr_err(\"failed to register %s clock: %ld\\n\",\n\t\t\t\tclk_proto[i].name, PTR_ERR(clk[i]));\n\t\t\tclk[i] = NULL;\n\t\t}\n\t}\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);\n\n\t \n\tclk_set_rate(clk[LPC32XX_CLK_USB_PLL], 48000000);\n\n\t \n\tclk_prepare_enable(clk[LPC32XX_CLK_ARM]);\n\tclk_prepare_enable(clk[LPC32XX_CLK_HCLK]);\n\n\t \n\tclk_prepare_enable(clk[LPC32XX_CLK_ARM_VFP]);\n\n\t \n\tclk_mask_disable(&clk_hw_proto[LPC32XX_CLK_SLC].hw0.clk.hw);\n\tclk_mask_disable(&clk_hw_proto[LPC32XX_CLK_MLC].hw0.clk.hw);\n}\nCLK_OF_DECLARE(lpc32xx_clk, \"nxp,lpc3220-clk\", lpc32xx_clk_init);\n\nstatic void __init lpc32xx_usb_clk_init(struct device_node *np)\n{\n\tunsigned int i;\n\n\tusb_clk_vbase = of_iomap(np, 0);\n\tif (!usb_clk_vbase) {\n\t\tpr_err(\"failed to map address range\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 1; i < LPC32XX_USB_CLK_MAX; i++) {\n\t\tusb_clk[i] = lpc32xx_clk_register(i + LPC32XX_CLK_USB_OFFSET);\n\t\tif (IS_ERR(usb_clk[i])) {\n\t\t\tpr_err(\"failed to register %s clock: %ld\\n\",\n\t\t\t\tclk_proto[i].name, PTR_ERR(usb_clk[i]));\n\t\t\tusb_clk[i] = NULL;\n\t\t}\n\t}\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &usb_clk_data);\n}\nCLK_OF_DECLARE(lpc32xx_usb_clk, \"nxp,lpc3220-usb-clk\", lpc32xx_usb_clk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}