{
  "module_name": "clk-renesas-pcie.c",
  "hash_id": "3da8ff90fab047108c3d0add44e627204e15ca70a62c85bda2681317605142e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-renesas-pcie.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#define RS9_REG_OE\t\t\t\t0x0\n#define RS9_REG_SS\t\t\t\t0x1\n#define RS9_REG_SS_AMP_0V6\t\t\t0x0\n#define RS9_REG_SS_AMP_0V7\t\t\t0x1\n#define RS9_REG_SS_AMP_0V8\t\t\t0x2\n#define RS9_REG_SS_AMP_0V9\t\t\t0x3\n#define RS9_REG_SS_AMP_MASK\t\t\t0x3\n#define RS9_REG_SS_SSC_100\t\t\t0\n#define RS9_REG_SS_SSC_M025\t\t\t(1 << 3)\n#define RS9_REG_SS_SSC_M050\t\t\t(3 << 3)\n#define RS9_REG_SS_SSC_MASK\t\t\t(3 << 3)\n#define RS9_REG_SS_SSC_LOCK\t\t\tBIT(5)\n#define RS9_REG_SR\t\t\t\t0x2\n#define RS9_REG_REF\t\t\t\t0x3\n#define RS9_REG_REF_OE\t\t\t\tBIT(4)\n#define RS9_REG_REF_OD\t\t\t\tBIT(5)\n#define RS9_REG_REF_SR_SLOWEST\t\t\t0\n#define RS9_REG_REF_SR_SLOW\t\t\t(1 << 6)\n#define RS9_REG_REF_SR_FAST\t\t\t(2 << 6)\n#define RS9_REG_REF_SR_FASTER\t\t\t(3 << 6)\n#define RS9_REG_VID\t\t\t\t0x5\n#define RS9_REG_DID\t\t\t\t0x6\n#define RS9_REG_BCP\t\t\t\t0x7\n\n#define RS9_REG_VID_IDT\t\t\t\t0x01\n\n#define RS9_REG_DID_TYPE_FGV\t\t\t(0x0 << RS9_REG_DID_TYPE_SHIFT)\n#define RS9_REG_DID_TYPE_DBV\t\t\t(0x1 << RS9_REG_DID_TYPE_SHIFT)\n#define RS9_REG_DID_TYPE_DMV\t\t\t(0x2 << RS9_REG_DID_TYPE_SHIFT)\n#define RS9_REG_DID_TYPE_SHIFT\t\t\t0x6\n\n \nenum rs9_model {\n\tRENESAS_9FGV0241,\n\tRENESAS_9FGV0441,\n};\n\n \nstruct rs9_chip_info {\n\tconst enum rs9_model\tmodel;\n\tunsigned int\t\tnum_clks;\n\tu8\t\t\tdid;\n};\n\nstruct rs9_driver_data {\n\tstruct i2c_client\t*client;\n\tstruct regmap\t\t*regmap;\n\tconst struct rs9_chip_info *chip_info;\n\tstruct clk_hw\t\t*clk_dif[4];\n\tu8\t\t\tpll_amplitude;\n\tu8\t\t\tpll_ssc;\n\tu8\t\t\tclk_dif_sr;\n};\n\n \nstatic const struct regmap_range rs9_readable_ranges[] = {\n\tregmap_reg_range(RS9_REG_OE, RS9_REG_REF),\n\tregmap_reg_range(RS9_REG_VID, RS9_REG_BCP),\n};\n\nstatic const struct regmap_access_table rs9_readable_table = {\n\t.yes_ranges = rs9_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(rs9_readable_ranges),\n};\n\nstatic const struct regmap_range rs9_writeable_ranges[] = {\n\tregmap_reg_range(RS9_REG_OE, RS9_REG_REF),\n\tregmap_reg_range(RS9_REG_BCP, RS9_REG_BCP),\n};\n\nstatic const struct regmap_access_table rs9_writeable_table = {\n\t.yes_ranges = rs9_writeable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(rs9_writeable_ranges),\n};\n\nstatic int rs9_regmap_i2c_write(void *context,\n\t\t\t\tunsigned int reg, unsigned int val)\n{\n\tstruct i2c_client *i2c = context;\n\tconst u8 data[3] = { reg, 1, val };\n\tconst int count = ARRAY_SIZE(data);\n\tint ret;\n\n\tret = i2c_master_send(i2c, data, count);\n\tif (ret == count)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int rs9_regmap_i2c_read(void *context,\n\t\t\t       unsigned int reg, unsigned int *val)\n{\n\tstruct i2c_client *i2c = context;\n\tstruct i2c_msg xfer[2];\n\tu8 txdata = reg;\n\tu8 rxdata[2];\n\tint ret;\n\n\txfer[0].addr = i2c->addr;\n\txfer[0].flags = 0;\n\txfer[0].len = 1;\n\txfer[0].buf = (void *)&txdata;\n\n\txfer[1].addr = i2c->addr;\n\txfer[1].flags = I2C_M_RD;\n\txfer[1].len = 2;\n\txfer[1].buf = (void *)rxdata;\n\n\tret = i2c_transfer(i2c->adapter, xfer, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != 2)\n\t\treturn -EIO;\n\n\t \n\t*val = rxdata[1];\n\treturn 0;\n}\n\nstatic const struct regmap_config rs9_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_FLAT,\n\t.max_register = RS9_REG_BCP,\n\t.num_reg_defaults_raw = 0x8,\n\t.rd_table = &rs9_readable_table,\n\t.wr_table = &rs9_writeable_table,\n\t.reg_write = rs9_regmap_i2c_write,\n\t.reg_read = rs9_regmap_i2c_read,\n};\n\nstatic u8 rs9_calc_dif(const struct rs9_driver_data *rs9, int idx)\n{\n\tenum rs9_model model = rs9->chip_info->model;\n\n\tif (model == RENESAS_9FGV0241)\n\t\treturn BIT(idx + 1);\n\telse if (model == RENESAS_9FGV0441)\n\t\treturn BIT(idx);\n\n\treturn 0;\n}\n\nstatic int rs9_get_output_config(struct rs9_driver_data *rs9, int idx)\n{\n\tstruct i2c_client *client = rs9->client;\n\tu8 dif = rs9_calc_dif(rs9, idx);\n\tunsigned char name[5] = \"DIF0\";\n\tstruct device_node *np;\n\tint ret;\n\tu32 sr;\n\n\t \n\trs9->clk_dif_sr |= dif;\n\n\tsnprintf(name, 5, \"DIF%d\", idx);\n\tnp = of_get_child_by_name(client->dev.of_node, name);\n\tif (!np)\n\t\treturn 0;\n\n\t \n\tret = of_property_read_u32(np, \"renesas,slew-rate\", &sr);\n\tof_node_put(np);\n\tif (!ret) {\n\t\tif (sr == 2000000) {\t\t \n\t\t\trs9->clk_dif_sr &= ~dif;\n\t\t} else if (sr == 3000000) {\t \n\t\t\trs9->clk_dif_sr |= dif;\n\t\t} else\n\t\t\tret = dev_err_probe(&client->dev, -EINVAL,\n\t\t\t\t\t    \"Invalid renesas,slew-rate value\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int rs9_get_common_config(struct rs9_driver_data *rs9)\n{\n\tstruct i2c_client *client = rs9->client;\n\tstruct device_node *np = client->dev.of_node;\n\tunsigned int amp, ssc;\n\tint ret;\n\n\t \n\trs9->pll_amplitude = RS9_REG_SS_AMP_0V7;\n\trs9->pll_ssc = RS9_REG_SS_SSC_100;\n\n\t \n\tret = of_property_read_u32(np, \"renesas,out-amplitude-microvolt\",\n\t\t\t\t   &amp);\n\tif (!ret) {\n\t\tif (amp == 600000)\t \n\t\t\trs9->pll_amplitude = RS9_REG_SS_AMP_0V6;\n\t\telse if (amp == 700000)\t \n\t\t\trs9->pll_amplitude = RS9_REG_SS_AMP_0V7;\n\t\telse if (amp == 800000)\t \n\t\t\trs9->pll_amplitude = RS9_REG_SS_AMP_0V8;\n\t\telse if (amp == 900000)\t \n\t\t\trs9->pll_amplitude = RS9_REG_SS_AMP_0V9;\n\t\telse\n\t\t\treturn dev_err_probe(&client->dev, -EINVAL,\n\t\t\t\t\t     \"Invalid renesas,out-amplitude-microvolt value\\n\");\n\t}\n\n\t \n\tret = of_property_read_u32(np, \"renesas,out-spread-spectrum\", &ssc);\n\tif (!ret) {\n\t\tif (ssc == 100000)\t \n\t\t\trs9->pll_ssc = RS9_REG_SS_SSC_100;\n\t\telse if (ssc == 99750)\t \n\t\t\trs9->pll_ssc = RS9_REG_SS_SSC_M025;\n\t\telse if (ssc == 99500)\t \n\t\t\trs9->pll_ssc = RS9_REG_SS_SSC_M050;\n\t\telse\n\t\t\treturn dev_err_probe(&client->dev, -EINVAL,\n\t\t\t\t\t     \"Invalid renesas,out-spread-spectrum value\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void rs9_update_config(struct rs9_driver_data *rs9)\n{\n\tint i;\n\n\t \n\tif (rs9->pll_amplitude != RS9_REG_SS_AMP_0V7) {\n\t\tregmap_update_bits(rs9->regmap, RS9_REG_SS, RS9_REG_SS_AMP_MASK,\n\t\t\t\t   rs9->pll_amplitude);\n\t}\n\n\t \n\tif (rs9->pll_ssc != RS9_REG_SS_SSC_100) {\n\t\tregmap_update_bits(rs9->regmap, RS9_REG_SS, RS9_REG_SS_SSC_MASK,\n\t\t\t\t   rs9->pll_ssc);\n\t}\n\n\tfor (i = 0; i < rs9->chip_info->num_clks; i++) {\n\t\tu8 dif = rs9_calc_dif(rs9, i);\n\n\t\tif (rs9->clk_dif_sr & dif)\n\t\t\tcontinue;\n\n\t\tregmap_update_bits(rs9->regmap, RS9_REG_SR, dif,\n\t\t\t\t   rs9->clk_dif_sr & dif);\n\t}\n}\n\nstatic struct clk_hw *\nrs9_of_clk_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct rs9_driver_data *rs9 = data;\n\tunsigned int idx = clkspec->args[0];\n\n\treturn rs9->clk_dif[idx];\n}\n\nstatic int rs9_probe(struct i2c_client *client)\n{\n\tunsigned char name[5] = \"DIF0\";\n\tstruct rs9_driver_data *rs9;\n\tunsigned int vid, did;\n\tstruct clk_hw *hw;\n\tint i, ret;\n\n\trs9 = devm_kzalloc(&client->dev, sizeof(*rs9), GFP_KERNEL);\n\tif (!rs9)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, rs9);\n\trs9->client = client;\n\trs9->chip_info = device_get_match_data(&client->dev);\n\tif (!rs9->chip_info)\n\t\treturn -EINVAL;\n\n\t \n\tret = rs9_get_common_config(rs9);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < rs9->chip_info->num_clks; i++) {\n\t\tret = rs9_get_output_config(rs9, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\trs9->regmap = devm_regmap_init(&client->dev, NULL,\n\t\t\t\t       client, &rs9_regmap_config);\n\tif (IS_ERR(rs9->regmap))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(rs9->regmap),\n\t\t\t\t     \"Failed to allocate register map\\n\");\n\n\t \n\tret = regmap_write(rs9->regmap, RS9_REG_BCP, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(rs9->regmap, RS9_REG_VID, &vid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(rs9->regmap, RS9_REG_DID, &did);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (vid != RS9_REG_VID_IDT || did != rs9->chip_info->did)\n\t\treturn dev_err_probe(&client->dev, -ENODEV,\n\t\t\t\t     \"Incorrect VID/DID: %#02x, %#02x. Expected %#02x, %#02x\\n\",\n\t\t\t\t     vid, did, RS9_REG_VID_IDT,\n\t\t\t\t     rs9->chip_info->did);\n\n\t \n\tfor (i = 0; i < rs9->chip_info->num_clks; i++) {\n\t\tsnprintf(name, 5, \"DIF%d\", i);\n\t\thw = devm_clk_hw_register_fixed_factor_index(&client->dev, name,\n\t\t\t\t\t\t    0, 0, 4, 1);\n\t\tif (IS_ERR(hw))\n\t\t\treturn PTR_ERR(hw);\n\n\t\trs9->clk_dif[i] = hw;\n\t}\n\n\tret = devm_of_clk_add_hw_provider(&client->dev, rs9_of_clk_get, rs9);\n\tif (!ret)\n\t\trs9_update_config(rs9);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused rs9_suspend(struct device *dev)\n{\n\tstruct rs9_driver_data *rs9 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(rs9->regmap, true);\n\tregcache_mark_dirty(rs9->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rs9_resume(struct device *dev)\n{\n\tstruct rs9_driver_data *rs9 = dev_get_drvdata(dev);\n\tint ret;\n\n\tregcache_cache_only(rs9->regmap, false);\n\tret = regcache_sync(rs9->regmap);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to restore register map: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct rs9_chip_info renesas_9fgv0241_info = {\n\t.model\t\t= RENESAS_9FGV0241,\n\t.num_clks\t= 2,\n\t.did\t\t= RS9_REG_DID_TYPE_FGV | 0x02,\n};\n\nstatic const struct rs9_chip_info renesas_9fgv0441_info = {\n\t.model\t\t= RENESAS_9FGV0441,\n\t.num_clks\t= 4,\n\t.did\t\t= RS9_REG_DID_TYPE_FGV | 0x04,\n};\n\nstatic const struct i2c_device_id rs9_id[] = {\n\t{ \"9fgv0241\", .driver_data = (kernel_ulong_t)&renesas_9fgv0241_info },\n\t{ \"9fgv0441\", .driver_data = (kernel_ulong_t)&renesas_9fgv0441_info },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rs9_id);\n\nstatic const struct of_device_id clk_rs9_of_match[] = {\n\t{ .compatible = \"renesas,9fgv0241\", .data = &renesas_9fgv0241_info },\n\t{ .compatible = \"renesas,9fgv0441\", .data = &renesas_9fgv0441_info },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, clk_rs9_of_match);\n\nstatic SIMPLE_DEV_PM_OPS(rs9_pm_ops, rs9_suspend, rs9_resume);\n\nstatic struct i2c_driver rs9_driver = {\n\t.driver = {\n\t\t.name = \"clk-renesas-pcie-9series\",\n\t\t.pm\t= &rs9_pm_ops,\n\t\t.of_match_table = clk_rs9_of_match,\n\t},\n\t.probe\t\t= rs9_probe,\n\t.id_table\t= rs9_id,\n};\nmodule_i2c_driver(rs9_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"Renesas 9-series PCIe clock generator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}