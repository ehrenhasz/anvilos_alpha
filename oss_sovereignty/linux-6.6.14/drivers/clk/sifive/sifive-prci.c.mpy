{
  "module_name": "sifive-prci.c",
  "hash_id": "aac0a28de1a6a43b6cbc60c0bb3676f0bb546b61550390c18c22261b34ee016b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sifive/sifive-prci.c",
  "human_readable_source": "\n \n\n#include <linux/clkdev.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include \"sifive-prci.h\"\n#include \"fu540-prci.h\"\n#include \"fu740-prci.h\"\n\n \n\n \nstatic u32 __prci_readl(struct __prci_data *pd, u32 offs)\n{\n\treturn readl_relaxed(pd->va + offs);\n}\n\nstatic void __prci_writel(u32 v, u32 offs, struct __prci_data *pd)\n{\n\twritel_relaxed(v, pd->va + offs);\n}\n\n \n\n \nstatic void __prci_wrpll_unpack(struct wrpll_cfg *c, u32 r)\n{\n\tu32 v;\n\n\tv = r & PRCI_COREPLLCFG0_DIVR_MASK;\n\tv >>= PRCI_COREPLLCFG0_DIVR_SHIFT;\n\tc->divr = v;\n\n\tv = r & PRCI_COREPLLCFG0_DIVF_MASK;\n\tv >>= PRCI_COREPLLCFG0_DIVF_SHIFT;\n\tc->divf = v;\n\n\tv = r & PRCI_COREPLLCFG0_DIVQ_MASK;\n\tv >>= PRCI_COREPLLCFG0_DIVQ_SHIFT;\n\tc->divq = v;\n\n\tv = r & PRCI_COREPLLCFG0_RANGE_MASK;\n\tv >>= PRCI_COREPLLCFG0_RANGE_SHIFT;\n\tc->range = v;\n\n\tc->flags &=\n\t    (WRPLL_FLAGS_INT_FEEDBACK_MASK | WRPLL_FLAGS_EXT_FEEDBACK_MASK);\n\n\t \n\tc->flags |= WRPLL_FLAGS_INT_FEEDBACK_MASK;\n}\n\n \nstatic u32 __prci_wrpll_pack(const struct wrpll_cfg *c)\n{\n\tu32 r = 0;\n\n\tr |= c->divr << PRCI_COREPLLCFG0_DIVR_SHIFT;\n\tr |= c->divf << PRCI_COREPLLCFG0_DIVF_SHIFT;\n\tr |= c->divq << PRCI_COREPLLCFG0_DIVQ_SHIFT;\n\tr |= c->range << PRCI_COREPLLCFG0_RANGE_SHIFT;\n\n\t \n\tr |= PRCI_COREPLLCFG0_FSE_MASK;\n\n\treturn r;\n}\n\n \nstatic void __prci_wrpll_read_cfg0(struct __prci_data *pd,\n\t\t\t\t   struct __prci_wrpll_data *pwd)\n{\n\t__prci_wrpll_unpack(&pwd->c, __prci_readl(pd, pwd->cfg0_offs));\n}\n\n \nstatic void __prci_wrpll_write_cfg0(struct __prci_data *pd,\n\t\t\t\t    struct __prci_wrpll_data *pwd,\n\t\t\t\t    struct wrpll_cfg *c)\n{\n\t__prci_writel(__prci_wrpll_pack(c), pwd->cfg0_offs, pd);\n\n\tmemcpy(&pwd->c, c, sizeof(*c));\n}\n\n \nstatic void __prci_wrpll_write_cfg1(struct __prci_data *pd,\n\t\t\t\t    struct __prci_wrpll_data *pwd,\n\t\t\t\t    u32 enable)\n{\n\t__prci_writel(enable, pwd->cfg1_offs, pd);\n}\n\n \n\nunsigned long sifive_prci_wrpll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct __prci_clock *pc = clk_hw_to_prci_clock(hw);\n\tstruct __prci_wrpll_data *pwd = pc->pwd;\n\n\treturn wrpll_calc_output_rate(&pwd->c, parent_rate);\n}\n\nlong sifive_prci_wrpll_round_rate(struct clk_hw *hw,\n\t\t\t\t  unsigned long rate,\n\t\t\t\t  unsigned long *parent_rate)\n{\n\tstruct __prci_clock *pc = clk_hw_to_prci_clock(hw);\n\tstruct __prci_wrpll_data *pwd = pc->pwd;\n\tstruct wrpll_cfg c;\n\n\tmemcpy(&c, &pwd->c, sizeof(c));\n\n\twrpll_configure_for_rate(&c, rate, *parent_rate);\n\n\treturn wrpll_calc_output_rate(&c, *parent_rate);\n}\n\nint sifive_prci_wrpll_set_rate(struct clk_hw *hw,\n\t\t\t       unsigned long rate, unsigned long parent_rate)\n{\n\tstruct __prci_clock *pc = clk_hw_to_prci_clock(hw);\n\tstruct __prci_wrpll_data *pwd = pc->pwd;\n\tstruct __prci_data *pd = pc->pd;\n\tint r;\n\n\tr = wrpll_configure_for_rate(&pwd->c, rate, parent_rate);\n\tif (r)\n\t\treturn r;\n\n\tif (pwd->enable_bypass)\n\t\tpwd->enable_bypass(pd);\n\n\t__prci_wrpll_write_cfg0(pd, pwd, &pwd->c);\n\n\tudelay(wrpll_calc_max_lock_us(&pwd->c));\n\n\treturn 0;\n}\n\nint sifive_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct __prci_clock *pc = clk_hw_to_prci_clock(hw);\n\tstruct __prci_wrpll_data *pwd = pc->pwd;\n\tstruct __prci_data *pd = pc->pd;\n\tu32 r;\n\n\tr = __prci_readl(pd, pwd->cfg1_offs);\n\n\tif (r & PRCI_COREPLLCFG1_CKE_MASK)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nint sifive_prci_clock_enable(struct clk_hw *hw)\n{\n\tstruct __prci_clock *pc = clk_hw_to_prci_clock(hw);\n\tstruct __prci_wrpll_data *pwd = pc->pwd;\n\tstruct __prci_data *pd = pc->pd;\n\n\tif (sifive_clk_is_enabled(hw))\n\t\treturn 0;\n\n\t__prci_wrpll_write_cfg1(pd, pwd, PRCI_COREPLLCFG1_CKE_MASK);\n\n\tif (pwd->disable_bypass)\n\t\tpwd->disable_bypass(pd);\n\n\treturn 0;\n}\n\nvoid sifive_prci_clock_disable(struct clk_hw *hw)\n{\n\tstruct __prci_clock *pc = clk_hw_to_prci_clock(hw);\n\tstruct __prci_wrpll_data *pwd = pc->pwd;\n\tstruct __prci_data *pd = pc->pd;\n\tu32 r;\n\n\tif (pwd->enable_bypass)\n\t\tpwd->enable_bypass(pd);\n\n\tr = __prci_readl(pd, pwd->cfg1_offs);\n\tr &= ~PRCI_COREPLLCFG1_CKE_MASK;\n\n\t__prci_wrpll_write_cfg1(pd, pwd, r);\n}\n\n \n\nunsigned long sifive_prci_tlclksel_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct __prci_clock *pc = clk_hw_to_prci_clock(hw);\n\tstruct __prci_data *pd = pc->pd;\n\tu32 v;\n\tu8 div;\n\n\tv = __prci_readl(pd, PRCI_CLKMUXSTATUSREG_OFFSET);\n\tv &= PRCI_CLKMUXSTATUSREG_TLCLKSEL_STATUS_MASK;\n\tdiv = v ? 1 : 2;\n\n\treturn div_u64(parent_rate, div);\n}\n\n \n\nunsigned long sifive_prci_hfpclkplldiv_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct __prci_clock *pc = clk_hw_to_prci_clock(hw);\n\tstruct __prci_data *pd = pc->pd;\n\tu32 div = __prci_readl(pd, PRCI_HFPCLKPLLDIV_OFFSET);\n\n\treturn div_u64(parent_rate, div + 2);\n}\n\n \n\n \nvoid sifive_prci_coreclksel_use_hfclk(struct __prci_data *pd)\n{\n\tu32 r;\n\n\tr = __prci_readl(pd, PRCI_CORECLKSEL_OFFSET);\n\tr |= PRCI_CORECLKSEL_CORECLKSEL_MASK;\n\t__prci_writel(r, PRCI_CORECLKSEL_OFFSET, pd);\n\n\tr = __prci_readl(pd, PRCI_CORECLKSEL_OFFSET);\t \n}\n\n \nvoid sifive_prci_coreclksel_use_corepll(struct __prci_data *pd)\n{\n\tu32 r;\n\n\tr = __prci_readl(pd, PRCI_CORECLKSEL_OFFSET);\n\tr &= ~PRCI_CORECLKSEL_CORECLKSEL_MASK;\n\t__prci_writel(r, PRCI_CORECLKSEL_OFFSET, pd);\n\n\tr = __prci_readl(pd, PRCI_CORECLKSEL_OFFSET);\t \n}\n\n \nvoid sifive_prci_coreclksel_use_final_corepll(struct __prci_data *pd)\n{\n\tu32 r;\n\n\tr = __prci_readl(pd, PRCI_CORECLKSEL_OFFSET);\n\tr &= ~PRCI_CORECLKSEL_CORECLKSEL_MASK;\n\t__prci_writel(r, PRCI_CORECLKSEL_OFFSET, pd);\n\n\tr = __prci_readl(pd, PRCI_CORECLKSEL_OFFSET);\t \n}\n\n \nvoid sifive_prci_corepllsel_use_dvfscorepll(struct __prci_data *pd)\n{\n\tu32 r;\n\n\tr = __prci_readl(pd, PRCI_COREPLLSEL_OFFSET);\n\tr |= PRCI_COREPLLSEL_COREPLLSEL_MASK;\n\t__prci_writel(r, PRCI_COREPLLSEL_OFFSET, pd);\n\n\tr = __prci_readl(pd, PRCI_COREPLLSEL_OFFSET);\t \n}\n\n \nvoid sifive_prci_corepllsel_use_corepll(struct __prci_data *pd)\n{\n\tu32 r;\n\n\tr = __prci_readl(pd, PRCI_COREPLLSEL_OFFSET);\n\tr &= ~PRCI_COREPLLSEL_COREPLLSEL_MASK;\n\t__prci_writel(r, PRCI_COREPLLSEL_OFFSET, pd);\n\n\tr = __prci_readl(pd, PRCI_COREPLLSEL_OFFSET);\t \n}\n\n \nvoid sifive_prci_hfpclkpllsel_use_hfclk(struct __prci_data *pd)\n{\n\tu32 r;\n\n\tr = __prci_readl(pd, PRCI_HFPCLKPLLSEL_OFFSET);\n\tr |= PRCI_HFPCLKPLLSEL_HFPCLKPLLSEL_MASK;\n\t__prci_writel(r, PRCI_HFPCLKPLLSEL_OFFSET, pd);\n\n\tr = __prci_readl(pd, PRCI_HFPCLKPLLSEL_OFFSET);\t \n}\n\n \nvoid sifive_prci_hfpclkpllsel_use_hfpclkpll(struct __prci_data *pd)\n{\n\tu32 r;\n\n\tr = __prci_readl(pd, PRCI_HFPCLKPLLSEL_OFFSET);\n\tr &= ~PRCI_HFPCLKPLLSEL_HFPCLKPLLSEL_MASK;\n\t__prci_writel(r, PRCI_HFPCLKPLLSEL_OFFSET, pd);\n\n\tr = __prci_readl(pd, PRCI_HFPCLKPLLSEL_OFFSET);\t \n}\n\n \nint sifive_prci_pcie_aux_clock_is_enabled(struct clk_hw *hw)\n{\n\tstruct __prci_clock *pc = clk_hw_to_prci_clock(hw);\n\tstruct __prci_data *pd = pc->pd;\n\tu32 r;\n\n\tr = __prci_readl(pd, PRCI_PCIE_AUX_OFFSET);\n\n\tif (r & PRCI_PCIE_AUX_EN_MASK)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nint sifive_prci_pcie_aux_clock_enable(struct clk_hw *hw)\n{\n\tstruct __prci_clock *pc = clk_hw_to_prci_clock(hw);\n\tstruct __prci_data *pd = pc->pd;\n\tu32 r __maybe_unused;\n\n\tif (sifive_prci_pcie_aux_clock_is_enabled(hw))\n\t\treturn 0;\n\n\t__prci_writel(1, PRCI_PCIE_AUX_OFFSET, pd);\n\tr = __prci_readl(pd, PRCI_PCIE_AUX_OFFSET);\t \n\n\treturn 0;\n}\n\nvoid sifive_prci_pcie_aux_clock_disable(struct clk_hw *hw)\n{\n\tstruct __prci_clock *pc = clk_hw_to_prci_clock(hw);\n\tstruct __prci_data *pd = pc->pd;\n\tu32 r __maybe_unused;\n\n\t__prci_writel(0, PRCI_PCIE_AUX_OFFSET, pd);\n\tr = __prci_readl(pd, PRCI_PCIE_AUX_OFFSET);\t \n\n}\n\n \nstatic int __prci_register_clocks(struct device *dev, struct __prci_data *pd,\n\t\t\t\t  const struct prci_clk_desc *desc)\n{\n\tstruct clk_init_data init = { };\n\tstruct __prci_clock *pic;\n\tint parent_count, i, r;\n\n\tparent_count = of_clk_get_parent_count(dev->of_node);\n\tif (parent_count != EXPECTED_CLK_PARENT_COUNT) {\n\t\tdev_err(dev, \"expected only two parent clocks, found %d\\n\",\n\t\t\tparent_count);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < desc->num_clks; ++i) {\n\t\tpic = &(desc->clks[i]);\n\n\t\tinit.name = pic->name;\n\t\tinit.parent_names = &pic->parent_name;\n\t\tinit.num_parents = 1;\n\t\tinit.ops = pic->ops;\n\t\tpic->hw.init = &init;\n\n\t\tpic->pd = pd;\n\n\t\tif (pic->pwd)\n\t\t\t__prci_wrpll_read_cfg0(pd, pic->pwd);\n\n\t\tr = devm_clk_hw_register(dev, &pic->hw);\n\t\tif (r) {\n\t\t\tdev_warn(dev, \"Failed to register clock %s: %d\\n\",\n\t\t\t\t init.name, r);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = clk_hw_register_clkdev(&pic->hw, pic->name, dev_name(dev));\n\t\tif (r) {\n\t\t\tdev_warn(dev, \"Failed to register clkdev for %s: %d\\n\",\n\t\t\t\t init.name, r);\n\t\t\treturn r;\n\t\t}\n\n\t\tpd->hw_clks.hws[i] = &pic->hw;\n\t}\n\n\tpd->hw_clks.num = i;\n\n\tr = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get,\n\t\t\t\t\t&pd->hw_clks);\n\tif (r) {\n\t\tdev_err(dev, \"could not add hw_provider: %d\\n\", r);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sifive_prci_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct __prci_data *pd;\n\tconst struct prci_clk_desc *desc;\n\tint r;\n\n\tdesc = of_device_get_match_data(&pdev->dev);\n\n\tpd = devm_kzalloc(dev, struct_size(pd, hw_clks.hws, desc->num_clks), GFP_KERNEL);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\tpd->va = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pd->va))\n\t\treturn PTR_ERR(pd->va);\n\n\tpd->reset.rcdev.owner = THIS_MODULE;\n\tpd->reset.rcdev.nr_resets = PRCI_RST_NR;\n\tpd->reset.rcdev.ops = &reset_simple_ops;\n\tpd->reset.rcdev.of_node = pdev->dev.of_node;\n\tpd->reset.active_low = true;\n\tpd->reset.membase = pd->va + PRCI_DEVICESRESETREG_OFFSET;\n\tspin_lock_init(&pd->reset.lock);\n\n\tr = devm_reset_controller_register(&pdev->dev, &pd->reset.rcdev);\n\tif (r) {\n\t\tdev_err(dev, \"could not register reset controller: %d\\n\", r);\n\t\treturn r;\n\t}\n\tr = __prci_register_clocks(dev, pd, desc);\n\tif (r) {\n\t\tdev_err(dev, \"could not register clocks: %d\\n\", r);\n\t\treturn r;\n\t}\n\n\tdev_dbg(dev, \"SiFive PRCI probed\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sifive_prci_of_match[] = {\n\t{.compatible = \"sifive,fu540-c000-prci\", .data = &prci_clk_fu540},\n\t{.compatible = \"sifive,fu740-c000-prci\", .data = &prci_clk_fu740},\n\t{}\n};\n\nstatic struct platform_driver sifive_prci_driver = {\n\t.driver = {\n\t\t.name = \"sifive-clk-prci\",\n\t\t.of_match_table = sifive_prci_of_match,\n\t},\n\t.probe = sifive_prci_probe,\n};\n\nstatic int __init sifive_prci_init(void)\n{\n\treturn platform_driver_register(&sifive_prci_driver);\n}\ncore_initcall(sifive_prci_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}