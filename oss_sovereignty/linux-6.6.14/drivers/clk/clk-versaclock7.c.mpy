{
  "module_name": "clk-versaclock7.c",
  "hash_id": "f294d44e869a7a133ddfdd1e95b5e0cf9b22d51e2f9d5611054f880e9c03d570",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-versaclock7.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/i2c.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/swab.h>\n\n \n#define VC7_PAGE_ADDR\t\t\t0xFD\n#define VC7_PAGE_WINDOW\t\t\t256\n#define VC7_MAX_REG\t\t\t0x364\n\n \n#define VC7_NUM_BANKS\t\t\t7\n\n \n#define VC7_NUM_FOD\t\t\t3\n\n \n#define VC7_NUM_IOD\t\t\t4\n\n \n#define VC7_NUM_OUT\t\t\t12\n\n \n#define VC7_APLL_VCO_MIN\t\t9500000000UL\n#define VC7_APLL_VCO_MAX\t\t10700000000UL\n\n \n#define VC7_APLL_DENOMINATOR_BITS\t27\n\n \n#define VC7_FOD_DENOMINATOR_BITS\t34\n\n \n#define VC7_IOD_RATE_MIN\t\t1000UL\n#define VC7_IOD_RATE_MAX\t\t650000000UL\n#define VC7_IOD_MIN_DIVISOR\t\t14\n#define VC7_IOD_MAX_DIVISOR\t\t0x1ffffff  \n\n#define VC7_FOD_RATE_MIN\t\t1000UL\n#define VC7_FOD_RATE_MAX\t\t650000000UL\n#define VC7_FOD_1ST_STAGE_RATE_MIN\t33000000UL  \n#define VC7_FOD_1ST_STAGE_RATE_MAX\t650000000UL  \n#define VC7_FOD_1ST_INT_MAX\t\t324\n#define VC7_FOD_2ND_INT_MIN\t\t2\n#define VC7_FOD_2ND_INT_MAX\t\t0x1ffff  \n\n \n\n#define VC7_REG_XO_CNFG\t\t\t0x2C\n#define VC7_REG_XO_CNFG_COUNT\t\t4\n#define VC7_REG_XO_IB_H_DIV_SHIFT\t24\n#define VC7_REG_XO_IB_H_DIV_MASK\tGENMASK(28, VC7_REG_XO_IB_H_DIV_SHIFT)\n\n#define VC7_REG_APLL_FB_DIV_FRAC\t0x120\n#define VC7_REG_APLL_FB_DIV_FRAC_COUNT\t4\n#define VC7_REG_APLL_FB_DIV_FRAC_MASK\tGENMASK(26, 0)\n\n#define VC7_REG_APLL_FB_DIV_INT\t\t0x124\n#define VC7_REG_APLL_FB_DIV_INT_COUNT\t2\n#define VC7_REG_APLL_FB_DIV_INT_MASK\tGENMASK(9, 0)\n\n#define VC7_REG_APLL_CNFG\t\t0x127\n#define VC7_REG_APLL_EN_DOUBLER\t\tBIT(0)\n\n#define VC7_REG_OUT_BANK_CNFG(idx)\t(0x280 + (0x4 * (idx)))\n#define VC7_REG_OUTPUT_BANK_SRC_MASK\tGENMASK(2, 0)\n\n#define VC7_REG_FOD_INT_CNFG(idx)\t(0x1E0 + (0x10 * (idx)))\n#define VC7_REG_FOD_INT_CNFG_COUNT\t8\n#define VC7_REG_FOD_1ST_INT_MASK\tGENMASK(8, 0)\n#define VC7_REG_FOD_2ND_INT_SHIFT\t9\n#define VC7_REG_FOD_2ND_INT_MASK\tGENMASK(25, VC7_REG_FOD_2ND_INT_SHIFT)\n#define VC7_REG_FOD_FRAC_SHIFT\t\t26\n#define VC7_REG_FOD_FRAC_MASK\t\tGENMASK_ULL(59, VC7_REG_FOD_FRAC_SHIFT)\n\n#define VC7_REG_IOD_INT_CNFG(idx)\t(0x1C0 + (0x8 * (idx)))\n#define VC7_REG_IOD_INT_CNFG_COUNT\t4\n#define VC7_REG_IOD_INT_MASK\t\tGENMASK(24, 0)\n\n#define VC7_REG_ODRV_EN(idx)\t\t(0x240 + (0x4 * (idx)))\n#define VC7_REG_OUT_DIS\t\t\tBIT(0)\n\nstruct vc7_driver_data;\nstatic const struct regmap_config vc7_regmap_config;\n\n \nenum vc7_model {\n\tVC7_RC21008A,\n};\n\nstruct vc7_chip_info {\n\tconst enum vc7_model model;\n\tconst unsigned int banks[VC7_NUM_BANKS];\n\tconst unsigned int num_banks;\n\tconst unsigned int outputs[VC7_NUM_OUT];\n\tconst unsigned int num_outputs;\n};\n\n \nstruct vc7_apll_data {\n\tstruct clk *clk;\n\tstruct vc7_driver_data *vc7;\n\tu8 xo_ib_h_div;\n\tu8 en_doubler;\n\tu16 apll_fb_div_int;\n\tu32 apll_fb_div_frac;\n};\n\nstruct vc7_fod_data {\n\tstruct clk_hw hw;\n\tstruct vc7_driver_data *vc7;\n\tunsigned int num;\n\tu32 fod_1st_int;\n\tu32 fod_2nd_int;\n\tu64 fod_frac;\n};\n\nstruct vc7_iod_data {\n\tstruct clk_hw hw;\n\tstruct vc7_driver_data *vc7;\n\tunsigned int num;\n\tu32 iod_int;\n};\n\nstruct vc7_out_data {\n\tstruct clk_hw hw;\n\tstruct vc7_driver_data *vc7;\n\tunsigned int num;\n\tunsigned int out_dis;\n};\n\nstruct vc7_driver_data {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tconst struct vc7_chip_info *chip_info;\n\n\tstruct clk *pin_xin;\n\tstruct vc7_apll_data clk_apll;\n\tstruct vc7_fod_data clk_fod[VC7_NUM_FOD];\n\tstruct vc7_iod_data clk_iod[VC7_NUM_IOD];\n\tstruct vc7_out_data clk_out[VC7_NUM_OUT];\n};\n\nstruct vc7_bank_src_map {\n\tenum vc7_bank_src_type {\n\t\tVC7_FOD,\n\t\tVC7_IOD,\n\t} type;\n\tunion _divider {\n\t\tstruct vc7_iod_data *iod;\n\t\tstruct vc7_fod_data *fod;\n\t} src;\n};\n\nstatic struct clk_hw *vc7_of_clk_get(struct of_phandle_args *clkspec,\n\t\t\t\t     void *data)\n{\n\tstruct vc7_driver_data *vc7 = data;\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= vc7->chip_info->num_outputs)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn &vc7->clk_out[idx].hw;\n}\n\nstatic const unsigned int RC21008A_index_to_output_mapping[] = {\n\t1, 2, 3, 6, 7, 8, 10, 11\n};\n\nstatic int vc7_map_index_to_output(const enum vc7_model model, const unsigned int i)\n{\n\tswitch (model) {\n\tcase VC7_RC21008A:\n\t\treturn RC21008A_index_to_output_mapping[i];\n\tdefault:\n\t\treturn i;\n\t}\n}\n\n \nstatic const unsigned int output_bank_mapping[] = {\n\t0,  \n\t1,  \n\t2,  \n\t2,  \n\t3,  \n\t3,  \n\t3,  \n\t3,  \n\t4,  \n\t4,  \n\t5,  \n\t6   \n};\n\n \nstatic void vc7_64_mul_64_to_128(u64 left, u64 right, u64 *hi, u64 *lo)\n{\n\tu64 a0 = left & 0xffffffffull;\n\tu64 a1 = left >> 32;\n\tu64 b0 = right & 0xffffffffull;\n\tu64 b1 = right >> 32;\n\tu64 m0 = a0 * b0;\n\tu64 m1 = a0 * b1;\n\tu64 m2 = a1 * b0;\n\tu64 m3 = a1 * b1;\n\n\tm2 += (m0 >> 32);\n\tm2 += m1;\n\n\t \n\tif (m2 < m1)\n\t\tm3 += 0x100000000ull;\n\n\t*lo = (m0 & 0xffffffffull) | (m2 << 32);\n\t*hi = m3 + (m2 >> 32);\n}\n\n \nstatic u64 vc7_128_div_64_to_64(u64 numhi, u64 numlo, u64 den, u64 *r)\n{\n\t \n\tconst u64 b = ((u64)1 << 32);\n\n\t \n\tu32 q1, q0;\n\n\t \n\tint shift;\n\n\t \n\tu32 den1, den0, num1, num0;\n\n\t \n\tu64 rem;\n\n\t \n\tu64 qhat, rhat;\n\n\t \n\tu64 c1, c2;\n\n\t \n\tif (numhi >= den) {\n\t\tif (r)\n\t\t\t*r = ~0ull;\n\t\treturn ~0ull;\n\t}\n\n\t \n\tshift = __builtin_clzll(den);\n\tden <<= shift;\n\tnumhi <<= shift;\n\tnumhi |= (numlo >> (-shift & 63)) & (-(s64)shift >> 63);\n\tnumlo <<= shift;\n\n\t \n\tnum1 = (u32)(numlo >> 32);\n\tnum0 = (u32)(numlo & 0xFFFFFFFFu);\n\tden1 = (u32)(den >> 32);\n\tden0 = (u32)(den & 0xFFFFFFFFu);\n\n\t \n\tqhat = div64_u64_rem(numhi, den1, &rhat);\n\tc1 = qhat * den0;\n\tc2 = rhat * b + num1;\n\tif (c1 > c2)\n\t\tqhat -= (c1 - c2 > den) ? 2 : 1;\n\tq1 = (u32)qhat;\n\n\t \n\trem = numhi * b + num1 - q1 * den;\n\n\t \n\tqhat = div64_u64_rem(rem, den1, &rhat);\n\tc1 = qhat * den0;\n\tc2 = rhat * b + num0;\n\tif (c1 > c2)\n\t\tqhat -= (c1 - c2 > den) ? 2 : 1;\n\tq0 = (u32)qhat;\n\n\t \n\tif (r)\n\t\t*r = (rem * b + num0 - q0 * den) >> shift;\n\treturn ((u64)q1 << 32) | q0;\n}\n\nstatic int vc7_get_bank_clk(struct vc7_driver_data *vc7,\n\t\t\t    unsigned int bank_idx,\n\t\t\t    unsigned int output_bank_src,\n\t\t\t    struct vc7_bank_src_map *map)\n{\n\t \n\tif (bank_idx == 0 || bank_idx == 1) {\n\t\tswitch (output_bank_src) {\n\t\tcase 0:\n\t\t\tmap->type = VC7_IOD,\n\t\t\tmap->src.iod = &vc7->clk_iod[0];\n\t\t\treturn 0;\n\t\tcase 1:\n\t\t\tmap->type = VC7_IOD,\n\t\t\tmap->src.iod = &vc7->clk_iod[1];\n\t\t\treturn 0;\n\t\tcase 4:\n\t\t\tmap->type = VC7_FOD,\n\t\t\tmap->src.fod = &vc7->clk_fod[0];\n\t\t\treturn 0;\n\t\tcase 5:\n\t\t\tmap->type = VC7_FOD,\n\t\t\tmap->src.fod = &vc7->clk_fod[1];\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (bank_idx == 2) {\n\t\tswitch (output_bank_src) {\n\t\tcase 1:\n\t\t\tmap->type = VC7_IOD,\n\t\t\tmap->src.iod = &vc7->clk_iod[1];\n\t\t\treturn 0;\n\t\tcase 4:\n\t\t\tmap->type = VC7_FOD,\n\t\t\tmap->src.fod = &vc7->clk_fod[0];\n\t\t\treturn 0;\n\t\tcase 5:\n\t\t\tmap->type = VC7_FOD,\n\t\t\tmap->src.fod = &vc7->clk_fod[1];\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (bank_idx == 3) {\n\t\tswitch (output_bank_src) {\n\t\tcase 4:\n\t\t\tmap->type = VC7_FOD,\n\t\t\tmap->src.fod = &vc7->clk_fod[0];\n\t\t\treturn 0;\n\t\tcase 5:\n\t\t\tmap->type = VC7_FOD,\n\t\t\tmap->src.fod = &vc7->clk_fod[1];\n\t\t\treturn 0;\n\t\tcase 6:\n\t\t\tmap->type = VC7_FOD,\n\t\t\tmap->src.fod = &vc7->clk_fod[2];\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (bank_idx == 4) {\n\t\tswitch (output_bank_src) {\n\t\tcase 0:\n\t\t\t \n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmap->type = VC7_IOD,\n\t\t\tmap->src.iod = &vc7->clk_iod[2];\n\t\t\treturn 0;\n\t\tcase 5:\n\t\t\tmap->type = VC7_FOD,\n\t\t\tmap->src.fod = &vc7->clk_fod[1];\n\t\t\treturn 0;\n\t\tcase 6:\n\t\t\tmap->type = VC7_FOD,\n\t\t\tmap->src.fod = &vc7->clk_fod[2];\n\t\t\treturn 0;\n\t\tcase 7:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (bank_idx == 5) {\n\t\tswitch (output_bank_src) {\n\t\tcase 0:\n\t\t\t \n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmap->type = VC7_IOD,\n\t\t\tmap->src.iod = &vc7->clk_iod[2];\n\t\t\treturn 0;\n\t\tcase 3:\n\t\t\tmap->type = VC7_IOD,\n\t\t\tmap->src.iod = &vc7->clk_iod[3];\n\t\t\treturn 0;\n\t\tcase 5:\n\t\t\tmap->type = VC7_FOD,\n\t\t\tmap->src.fod = &vc7->clk_fod[1];\n\t\t\treturn 0;\n\t\tcase 6:\n\t\t\tmap->type = VC7_FOD,\n\t\t\tmap->src.fod = &vc7->clk_fod[2];\n\t\t\treturn 0;\n\t\tcase 7:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (bank_idx == 6) {\n\t\tswitch (output_bank_src) {\n\t\tcase 0:\n\t\t\t \n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmap->type = VC7_IOD,\n\t\t\tmap->src.iod = &vc7->clk_iod[2];\n\t\t\treturn 0;\n\t\tcase 3:\n\t\t\tmap->type = VC7_IOD,\n\t\t\tmap->src.iod = &vc7->clk_iod[3];\n\t\t\treturn 0;\n\t\tcase 5:\n\t\t\tmap->type = VC7_FOD,\n\t\t\tmap->src.fod = &vc7->clk_fod[1];\n\t\t\treturn 0;\n\t\tcase 6:\n\t\t\tmap->type = VC7_FOD,\n\t\t\tmap->src.fod = &vc7->clk_fod[2];\n\t\t\treturn 0;\n\t\tcase 7:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpr_warn(\"bank_src%d = %d is not supported\\n\", bank_idx, output_bank_src);\n\treturn -1;\n}\n\nstatic int vc7_read_apll(struct vc7_driver_data *vc7)\n{\n\tint err;\n\tu32 val32;\n\tu16 val16;\n\n\terr = regmap_bulk_read(vc7->regmap,\n\t\t\t       VC7_REG_XO_CNFG,\n\t\t\t       (u32 *)&val32,\n\t\t\t       VC7_REG_XO_CNFG_COUNT);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"failed to read XO_CNFG\\n\");\n\t\treturn err;\n\t}\n\n\tvc7->clk_apll.xo_ib_h_div = (val32 & VC7_REG_XO_IB_H_DIV_MASK)\n\t\t>> VC7_REG_XO_IB_H_DIV_SHIFT;\n\n\terr = regmap_read(vc7->regmap,\n\t\t\t  VC7_REG_APLL_CNFG,\n\t\t\t  &val32);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"failed to read APLL_CNFG\\n\");\n\t\treturn err;\n\t}\n\n\tvc7->clk_apll.en_doubler = val32 & VC7_REG_APLL_EN_DOUBLER;\n\n\terr = regmap_bulk_read(vc7->regmap,\n\t\t\t       VC7_REG_APLL_FB_DIV_FRAC,\n\t\t\t       (u32 *)&val32,\n\t\t\t       VC7_REG_APLL_FB_DIV_FRAC_COUNT);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"failed to read APLL_FB_DIV_FRAC\\n\");\n\t\treturn err;\n\t}\n\n\tvc7->clk_apll.apll_fb_div_frac = val32 & VC7_REG_APLL_FB_DIV_FRAC_MASK;\n\n\terr = regmap_bulk_read(vc7->regmap,\n\t\t\t       VC7_REG_APLL_FB_DIV_INT,\n\t\t\t       (u16 *)&val16,\n\t\t\t       VC7_REG_APLL_FB_DIV_INT_COUNT);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"failed to read APLL_FB_DIV_INT\\n\");\n\t\treturn err;\n\t}\n\n\tvc7->clk_apll.apll_fb_div_int = val16 & VC7_REG_APLL_FB_DIV_INT_MASK;\n\n\treturn 0;\n}\n\nstatic int vc7_read_fod(struct vc7_driver_data *vc7, unsigned int idx)\n{\n\tint err;\n\tu64 val;\n\n\terr = regmap_bulk_read(vc7->regmap,\n\t\t\t       VC7_REG_FOD_INT_CNFG(idx),\n\t\t\t       (u64 *)&val,\n\t\t\t       VC7_REG_FOD_INT_CNFG_COUNT);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"failed to read FOD%d\\n\", idx);\n\t\treturn err;\n\t}\n\n\tvc7->clk_fod[idx].fod_1st_int = (val & VC7_REG_FOD_1ST_INT_MASK);\n\tvc7->clk_fod[idx].fod_2nd_int =\n\t    (val & VC7_REG_FOD_2ND_INT_MASK) >> VC7_REG_FOD_2ND_INT_SHIFT;\n\tvc7->clk_fod[idx].fod_frac = (val & VC7_REG_FOD_FRAC_MASK)\n\t\t>> VC7_REG_FOD_FRAC_SHIFT;\n\n\treturn 0;\n}\n\nstatic int vc7_write_fod(struct vc7_driver_data *vc7, unsigned int idx)\n{\n\tint err;\n\tu64 val;\n\n\t \n\n\terr = regmap_bulk_read(vc7->regmap,\n\t\t\t       VC7_REG_FOD_INT_CNFG(idx),\n\t\t\t       (u64 *)&val,\n\t\t\t       VC7_REG_FOD_INT_CNFG_COUNT);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"failed to read FOD%d\\n\", idx);\n\t\treturn err;\n\t}\n\n\tval = u64_replace_bits(val,\n\t\t\t       vc7->clk_fod[idx].fod_1st_int,\n\t\t\t       VC7_REG_FOD_1ST_INT_MASK);\n\tval = u64_replace_bits(val,\n\t\t\t       vc7->clk_fod[idx].fod_2nd_int,\n\t\t\t       VC7_REG_FOD_2ND_INT_MASK);\n\tval = u64_replace_bits(val,\n\t\t\t       vc7->clk_fod[idx].fod_frac,\n\t\t\t       VC7_REG_FOD_FRAC_MASK);\n\n\terr = regmap_bulk_write(vc7->regmap,\n\t\t\t\tVC7_REG_FOD_INT_CNFG(idx),\n\t\t\t\t(u64 *)&val,\n\t\t\t\tsizeof(u64));\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"failed to write FOD%d\\n\", idx);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int vc7_read_iod(struct vc7_driver_data *vc7, unsigned int idx)\n{\n\tint err;\n\tu32 val;\n\n\terr = regmap_bulk_read(vc7->regmap,\n\t\t\t       VC7_REG_IOD_INT_CNFG(idx),\n\t\t\t       (u32 *)&val,\n\t\t\t       VC7_REG_IOD_INT_CNFG_COUNT);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"failed to read IOD%d\\n\", idx);\n\t\treturn err;\n\t}\n\n\tvc7->clk_iod[idx].iod_int = (val & VC7_REG_IOD_INT_MASK);\n\n\treturn 0;\n}\n\nstatic int vc7_write_iod(struct vc7_driver_data *vc7, unsigned int idx)\n{\n\tint err;\n\tu32 val;\n\n\t \n\n\terr = regmap_bulk_read(vc7->regmap,\n\t\t\t       VC7_REG_IOD_INT_CNFG(idx),\n\t\t\t       (u32 *)&val,\n\t\t\t       VC7_REG_IOD_INT_CNFG_COUNT);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"failed to read IOD%d\\n\", idx);\n\t\treturn err;\n\t}\n\n\tval = u32_replace_bits(val,\n\t\t\t       vc7->clk_iod[idx].iod_int,\n\t\t\t       VC7_REG_IOD_INT_MASK);\n\n\terr = regmap_bulk_write(vc7->regmap,\n\t\t\t\tVC7_REG_IOD_INT_CNFG(idx),\n\t\t\t\t(u32 *)&val,\n\t\t\t\tsizeof(u32));\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"failed to write IOD%d\\n\", idx);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int vc7_read_output(struct vc7_driver_data *vc7, unsigned int idx)\n{\n\tint err;\n\tunsigned int val, out_num;\n\n\tout_num = vc7_map_index_to_output(vc7->chip_info->model, idx);\n\terr = regmap_read(vc7->regmap,\n\t\t\t  VC7_REG_ODRV_EN(out_num),\n\t\t\t  &val);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"failed to read ODRV_EN[%d]\\n\", idx);\n\t\treturn err;\n\t}\n\n\tvc7->clk_out[idx].out_dis = val & VC7_REG_OUT_DIS;\n\n\treturn 0;\n}\n\nstatic int vc7_write_output(struct vc7_driver_data *vc7, unsigned int idx)\n{\n\tint err;\n\tunsigned int out_num;\n\n\tout_num = vc7_map_index_to_output(vc7->chip_info->model, idx);\n\terr = regmap_write_bits(vc7->regmap,\n\t\t\t\tVC7_REG_ODRV_EN(out_num),\n\t\t\t\tVC7_REG_OUT_DIS,\n\t\t\t\tvc7->clk_out[idx].out_dis);\n\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"failed to write ODRV_EN[%d]\\n\", idx);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long vc7_get_apll_rate(struct vc7_driver_data *vc7)\n{\n\tint err;\n\tunsigned long xtal_rate;\n\tu64 refin_div, apll_rate;\n\n\txtal_rate = clk_get_rate(vc7->pin_xin);\n\terr = vc7_read_apll(vc7);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"unable to read apll\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (vc7->clk_apll.xo_ib_h_div < 2)\n\t\trefin_div = xtal_rate;\n\telse\n\t\trefin_div = div64_u64(xtal_rate, vc7->clk_apll.xo_ib_h_div);\n\n\tif (vc7->clk_apll.en_doubler)\n\t\trefin_div *= 2;\n\n\t \n\tapll_rate = (refin_div * vc7->clk_apll.apll_fb_div_int) +\n\t\t    ((refin_div * vc7->clk_apll.apll_fb_div_frac) >> VC7_APLL_DENOMINATOR_BITS);\n\n\tpr_debug(\"%s - xo_ib_h_div: %u, apll_fb_div_int: %u, apll_fb_div_frac: %u\\n\",\n\t\t __func__, vc7->clk_apll.xo_ib_h_div, vc7->clk_apll.apll_fb_div_int,\n\t\t vc7->clk_apll.apll_fb_div_frac);\n\tpr_debug(\"%s - refin_div: %llu, apll rate: %llu\\n\",\n\t\t __func__, refin_div, apll_rate);\n\n\treturn apll_rate;\n}\n\nstatic void vc7_calc_iod_divider(unsigned long rate, unsigned long parent_rate,\n\t\t\t\t u32 *divider)\n{\n\t*divider = DIV_ROUND_UP(parent_rate, rate);\n\tif (*divider < VC7_IOD_MIN_DIVISOR)\n\t\t*divider = VC7_IOD_MIN_DIVISOR;\n\tif (*divider > VC7_IOD_MAX_DIVISOR)\n\t\t*divider = VC7_IOD_MAX_DIVISOR;\n}\n\nstatic void vc7_calc_fod_1st_stage(unsigned long rate, unsigned long parent_rate,\n\t\t\t\t   u32 *div_int, u64 *div_frac)\n{\n\tu64 rem;\n\n\t*div_int = (u32)div64_u64_rem(parent_rate, rate, &rem);\n\t*div_frac = div64_u64(rem << VC7_FOD_DENOMINATOR_BITS, rate);\n}\n\nstatic unsigned long vc7_calc_fod_1st_stage_rate(unsigned long parent_rate,\n\t\t\t\t\t\t u32 fod_1st_int, u64 fod_frac)\n{\n\tu64 numer, denom, hi, lo, divisor;\n\n\tnumer = fod_frac;\n\tdenom = BIT_ULL(VC7_FOD_DENOMINATOR_BITS);\n\n\tif (fod_frac) {\n\t\tvc7_64_mul_64_to_128(parent_rate, denom, &hi, &lo);\n\t\tdivisor = ((u64)fod_1st_int * denom) + numer;\n\t\treturn vc7_128_div_64_to_64(hi, lo, divisor, NULL);\n\t}\n\n\treturn div64_u64(parent_rate, fod_1st_int);\n}\n\nstatic unsigned long vc7_calc_fod_2nd_stage_rate(unsigned long parent_rate,\n\t\t\t\t\t\t u32 fod_1st_int, u32 fod_2nd_int, u64 fod_frac)\n{\n\tunsigned long fod_1st_stage_rate;\n\n\tfod_1st_stage_rate = vc7_calc_fod_1st_stage_rate(parent_rate, fod_1st_int, fod_frac);\n\n\tif (fod_2nd_int < 2)\n\t\treturn fod_1st_stage_rate;\n\n\t \n\treturn div64_u64(fod_1st_stage_rate >> 1, fod_2nd_int);\n}\n\nstatic void vc7_calc_fod_divider(unsigned long rate, unsigned long parent_rate,\n\t\t\t\t u32 *fod_1st_int, u32 *fod_2nd_int, u64 *fod_frac)\n{\n\tunsigned int allow_frac, i, best_frac_i;\n\tunsigned long first_stage_rate;\n\n\tvc7_calc_fod_1st_stage(rate, parent_rate, fod_1st_int, fod_frac);\n\tfirst_stage_rate = vc7_calc_fod_1st_stage_rate(parent_rate, *fod_1st_int, *fod_frac);\n\n\t*fod_2nd_int = 0;\n\n\t \n\tif (first_stage_rate < VC7_FOD_1ST_STAGE_RATE_MIN) {\n\t\tallow_frac = 0;\n\t\tbest_frac_i = VC7_FOD_2ND_INT_MIN;\n\n\t\tfor (i = VC7_FOD_2ND_INT_MIN; i <= VC7_FOD_2ND_INT_MAX; i++) {\n\t\t\t \n\t\t\tvc7_calc_fod_1st_stage(parent_rate, rate * 2 * i, fod_1st_int, fod_frac);\n\t\t\tfirst_stage_rate = vc7_calc_fod_1st_stage_rate(parent_rate,\n\t\t\t\t\t\t\t\t       *fod_1st_int,\n\t\t\t\t\t\t\t\t       *fod_frac);\n\n\t\t\t \n\t\t\tif (best_frac_i == VC7_FOD_2ND_INT_MIN &&\n\t\t\t    first_stage_rate > VC7_FOD_1ST_STAGE_RATE_MIN) {\n\t\t\t\tbest_frac_i = i;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (*fod_1st_int < VC7_FOD_1ST_INT_MAX &&\n\t\t\t    first_stage_rate >= VC7_FOD_1ST_STAGE_RATE_MIN &&\n\t\t\t    (allow_frac || *fod_frac == 0)) {\n\t\t\t\t*fod_2nd_int = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (i >= VC7_FOD_2ND_INT_MAX ||\n\t\t\t    first_stage_rate > VC7_FOD_1ST_STAGE_RATE_MAX) {\n\t\t\t\tallow_frac = 1;\n\t\t\t\ti = best_frac_i;\n\n\t\t\t\t \n\t\t\t\tif (best_frac_i != VC7_FOD_2ND_INT_MIN)\n\t\t\t\t\ti--;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic unsigned long vc7_fod_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct vc7_fod_data *fod = container_of(hw, struct vc7_fod_data, hw);\n\tstruct vc7_driver_data *vc7 = fod->vc7;\n\tint err;\n\tunsigned long fod_rate;\n\n\terr = vc7_read_fod(vc7, fod->num);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"error reading registers for %s\\n\",\n\t\t\tclk_hw_get_name(hw));\n\t\treturn err;\n\t}\n\n\tpr_debug(\"%s - %s: parent_rate: %lu\\n\", __func__, clk_hw_get_name(hw), parent_rate);\n\n\tfod_rate = vc7_calc_fod_2nd_stage_rate(parent_rate, fod->fod_1st_int,\n\t\t\t\t\t       fod->fod_2nd_int, fod->fod_frac);\n\n\tpr_debug(\"%s - %s: fod_1st_int: %u, fod_2nd_int: %u, fod_frac: %llu\\n\",\n\t\t __func__, clk_hw_get_name(hw),\n\t\t fod->fod_1st_int, fod->fod_2nd_int, fod->fod_frac);\n\tpr_debug(\"%s - %s rate: %lu\\n\", __func__, clk_hw_get_name(hw), fod_rate);\n\n\treturn fod_rate;\n}\n\nstatic long vc7_fod_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *parent_rate)\n{\n\tstruct vc7_fod_data *fod = container_of(hw, struct vc7_fod_data, hw);\n\tunsigned long fod_rate;\n\n\tpr_debug(\"%s - %s: requested rate: %lu, parent_rate: %lu\\n\",\n\t\t __func__, clk_hw_get_name(hw), rate, *parent_rate);\n\n\tvc7_calc_fod_divider(rate, *parent_rate,\n\t\t\t     &fod->fod_1st_int, &fod->fod_2nd_int, &fod->fod_frac);\n\tfod_rate = vc7_calc_fod_2nd_stage_rate(*parent_rate, fod->fod_1st_int,\n\t\t\t\t\t       fod->fod_2nd_int, fod->fod_frac);\n\n\tpr_debug(\"%s - %s: fod_1st_int: %u, fod_2nd_int: %u, fod_frac: %llu\\n\",\n\t\t __func__, clk_hw_get_name(hw),\n\t\t fod->fod_1st_int, fod->fod_2nd_int, fod->fod_frac);\n\tpr_debug(\"%s - %s rate: %lu\\n\", __func__, clk_hw_get_name(hw), fod_rate);\n\n\treturn fod_rate;\n}\n\nstatic int vc7_fod_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate)\n{\n\tstruct vc7_fod_data *fod = container_of(hw, struct vc7_fod_data, hw);\n\tstruct vc7_driver_data *vc7 = fod->vc7;\n\tunsigned long fod_rate;\n\n\tpr_debug(\"%s - %s: rate: %lu, parent_rate: %lu\\n\",\n\t\t __func__, clk_hw_get_name(hw), rate, parent_rate);\n\n\tif (rate < VC7_FOD_RATE_MIN || rate > VC7_FOD_RATE_MAX) {\n\t\tdev_err(&vc7->client->dev,\n\t\t\t\"requested frequency %lu Hz for %s is out of range\\n\",\n\t\t\trate, clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\tvc7_write_fod(vc7, fod->num);\n\n\tfod_rate = vc7_calc_fod_2nd_stage_rate(parent_rate, fod->fod_1st_int,\n\t\t\t\t\t       fod->fod_2nd_int, fod->fod_frac);\n\n\tpr_debug(\"%s - %s: fod_1st_int: %u, fod_2nd_int: %u, fod_frac: %llu\\n\",\n\t\t __func__, clk_hw_get_name(hw),\n\t\t fod->fod_1st_int, fod->fod_2nd_int, fod->fod_frac);\n\tpr_debug(\"%s - %s rate: %lu\\n\", __func__, clk_hw_get_name(hw), fod_rate);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops vc7_fod_ops = {\n\t.recalc_rate = vc7_fod_recalc_rate,\n\t.round_rate = vc7_fod_round_rate,\n\t.set_rate = vc7_fod_set_rate,\n};\n\nstatic unsigned long vc7_iod_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct vc7_iod_data *iod = container_of(hw, struct vc7_iod_data, hw);\n\tstruct vc7_driver_data *vc7 = iod->vc7;\n\tint err;\n\tunsigned long iod_rate;\n\n\terr = vc7_read_iod(vc7, iod->num);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"error reading registers for %s\\n\",\n\t\t\tclk_hw_get_name(hw));\n\t\treturn err;\n\t}\n\n\tiod_rate = div64_u64(parent_rate, iod->iod_int);\n\n\tpr_debug(\"%s - %s: iod_int: %u\\n\", __func__, clk_hw_get_name(hw), iod->iod_int);\n\tpr_debug(\"%s - %s rate: %lu\\n\", __func__, clk_hw_get_name(hw), iod_rate);\n\n\treturn iod_rate;\n}\n\nstatic long vc7_iod_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *parent_rate)\n{\n\tstruct vc7_iod_data *iod = container_of(hw, struct vc7_iod_data, hw);\n\tunsigned long iod_rate;\n\n\tpr_debug(\"%s - %s: requested rate: %lu, parent_rate: %lu\\n\",\n\t\t __func__, clk_hw_get_name(hw), rate, *parent_rate);\n\n\tvc7_calc_iod_divider(rate, *parent_rate, &iod->iod_int);\n\tiod_rate = div64_u64(*parent_rate, iod->iod_int);\n\n\tpr_debug(\"%s - %s: iod_int: %u\\n\", __func__, clk_hw_get_name(hw), iod->iod_int);\n\tpr_debug(\"%s - %s rate: %ld\\n\", __func__, clk_hw_get_name(hw), iod_rate);\n\n\treturn iod_rate;\n}\n\nstatic int vc7_iod_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate)\n{\n\tstruct vc7_iod_data *iod = container_of(hw, struct vc7_iod_data, hw);\n\tstruct vc7_driver_data *vc7 = iod->vc7;\n\tunsigned long iod_rate;\n\n\tpr_debug(\"%s - %s: rate: %lu, parent_rate: %lu\\n\",\n\t\t __func__, clk_hw_get_name(hw), rate, parent_rate);\n\n\tif (rate < VC7_IOD_RATE_MIN || rate > VC7_IOD_RATE_MAX) {\n\t\tdev_err(&vc7->client->dev,\n\t\t\t\"requested frequency %lu Hz for %s is out of range\\n\",\n\t\t\trate, clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\tvc7_write_iod(vc7, iod->num);\n\n\tiod_rate = div64_u64(parent_rate, iod->iod_int);\n\n\tpr_debug(\"%s - %s: iod_int: %u\\n\", __func__, clk_hw_get_name(hw), iod->iod_int);\n\tpr_debug(\"%s - %s rate: %ld\\n\", __func__, clk_hw_get_name(hw), iod_rate);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops vc7_iod_ops = {\n\t.recalc_rate = vc7_iod_recalc_rate,\n\t.round_rate = vc7_iod_round_rate,\n\t.set_rate = vc7_iod_set_rate,\n};\n\nstatic int vc7_clk_out_prepare(struct clk_hw *hw)\n{\n\tstruct vc7_out_data *out = container_of(hw, struct vc7_out_data, hw);\n\tstruct vc7_driver_data *vc7 = out->vc7;\n\tint err;\n\n\tout->out_dis = 0;\n\n\terr = vc7_write_output(vc7, out->num);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"error writing registers for %s\\n\",\n\t\t\tclk_hw_get_name(hw));\n\t\treturn err;\n\t}\n\n\tpr_debug(\"%s - %s: clk prepared\\n\", __func__, clk_hw_get_name(hw));\n\n\treturn 0;\n}\n\nstatic void vc7_clk_out_unprepare(struct clk_hw *hw)\n{\n\tstruct vc7_out_data *out = container_of(hw, struct vc7_out_data, hw);\n\tstruct vc7_driver_data *vc7 = out->vc7;\n\tint err;\n\n\tout->out_dis = 1;\n\n\terr = vc7_write_output(vc7, out->num);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"error writing registers for %s\\n\",\n\t\t\tclk_hw_get_name(hw));\n\t\treturn;\n\t}\n\n\tpr_debug(\"%s - %s: clk unprepared\\n\", __func__, clk_hw_get_name(hw));\n}\n\nstatic int vc7_clk_out_is_enabled(struct clk_hw *hw)\n{\n\tstruct vc7_out_data *out = container_of(hw, struct vc7_out_data, hw);\n\tstruct vc7_driver_data *vc7 = out->vc7;\n\tint err, is_enabled;\n\n\terr = vc7_read_output(vc7, out->num);\n\tif (err) {\n\t\tdev_err(&vc7->client->dev, \"error reading registers for %s\\n\",\n\t\t\tclk_hw_get_name(hw));\n\t\treturn err;\n\t}\n\n\tis_enabled = !out->out_dis;\n\n\tpr_debug(\"%s - %s: is_enabled=%d\\n\", __func__, clk_hw_get_name(hw), is_enabled);\n\n\treturn is_enabled;\n}\n\nstatic const struct clk_ops vc7_clk_out_ops = {\n\t.prepare = vc7_clk_out_prepare,\n\t.unprepare = vc7_clk_out_unprepare,\n\t.is_enabled = vc7_clk_out_is_enabled,\n};\n\nstatic int vc7_probe(struct i2c_client *client)\n{\n\tstruct vc7_driver_data *vc7;\n\tstruct clk_init_data clk_init;\n\tstruct vc7_bank_src_map bank_src_map;\n\tconst char *node_name, *apll_name;\n\tconst char *parent_names[1];\n\tunsigned int i, val, bank_idx, out_num;\n\tunsigned long apll_rate;\n\tint ret;\n\n\tvc7 = devm_kzalloc(&client->dev, sizeof(*vc7), GFP_KERNEL);\n\tif (!vc7)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, vc7);\n\tvc7->client = client;\n\tvc7->chip_info = i2c_get_match_data(client);\n\n\tvc7->pin_xin = devm_clk_get(&client->dev, \"xin\");\n\tif (PTR_ERR(vc7->pin_xin) == -EPROBE_DEFER) {\n\t\treturn dev_err_probe(&client->dev, -EPROBE_DEFER,\n\t\t\t\t     \"xin not specified\\n\");\n\t}\n\n\tvc7->regmap = devm_regmap_init_i2c(client, &vc7_regmap_config);\n\tif (IS_ERR(vc7->regmap)) {\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(vc7->regmap),\n\t\t\t\t     \"failed to allocate register map\\n\");\n\t}\n\n\tif (of_property_read_string(client->dev.of_node, \"clock-output-names\",\n\t\t\t\t    &node_name))\n\t\tnode_name = client->dev.of_node->name;\n\n\t \n\tapll_rate = vc7_get_apll_rate(vc7);\n\tapll_name = kasprintf(GFP_KERNEL, \"%s_apll\", node_name);\n\tvc7->clk_apll.clk = clk_register_fixed_rate(&client->dev, apll_name,\n\t\t\t\t\t\t    __clk_get_name(vc7->pin_xin),\n\t\t\t\t\t\t    0, apll_rate);\n\tkfree(apll_name);  \n\tif (IS_ERR(vc7->clk_apll.clk)) {\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(vc7->clk_apll.clk),\n\t\t\t\t     \"failed to register apll\\n\");\n\t}\n\n\t \n\tfor (i = 0; i < VC7_NUM_FOD; i++) {\n\t\tmemset(&clk_init, 0, sizeof(clk_init));\n\t\tclk_init.name = kasprintf(GFP_KERNEL, \"%s_fod%d\", node_name, i);\n\t\tclk_init.ops = &vc7_fod_ops;\n\t\tclk_init.parent_names = parent_names;\n\t\tparent_names[0] = __clk_get_name(vc7->clk_apll.clk);\n\t\tclk_init.num_parents = 1;\n\t\tvc7->clk_fod[i].num = i;\n\t\tvc7->clk_fod[i].vc7 = vc7;\n\t\tvc7->clk_fod[i].hw.init = &clk_init;\n\t\tret = devm_clk_hw_register(&client->dev, &vc7->clk_fod[i].hw);\n\t\tif (ret)\n\t\t\tgoto err_clk_register;\n\t\tkfree(clk_init.name);  \n\t}\n\n\t \n\tfor (i = 0; i < VC7_NUM_IOD; i++) {\n\t\tmemset(&clk_init, 0, sizeof(clk_init));\n\t\tclk_init.name = kasprintf(GFP_KERNEL, \"%s_iod%d\", node_name, i);\n\t\tclk_init.ops = &vc7_iod_ops;\n\t\tclk_init.parent_names = parent_names;\n\t\tparent_names[0] = __clk_get_name(vc7->clk_apll.clk);\n\t\tclk_init.num_parents = 1;\n\t\tvc7->clk_iod[i].num = i;\n\t\tvc7->clk_iod[i].vc7 = vc7;\n\t\tvc7->clk_iod[i].hw.init = &clk_init;\n\t\tret = devm_clk_hw_register(&client->dev, &vc7->clk_iod[i].hw);\n\t\tif (ret)\n\t\t\tgoto err_clk_register;\n\t\tkfree(clk_init.name);  \n\t}\n\n\t \n\tfor (i = 0; i < vc7->chip_info->num_outputs; i++) {\n\t\tout_num = vc7_map_index_to_output(vc7->chip_info->model, i);\n\n\t\t \n\t\tbank_idx = output_bank_mapping[out_num];\n\n\t\tregmap_read(vc7->regmap, VC7_REG_OUT_BANK_CNFG(bank_idx), &val);\n\t\tval &= VC7_REG_OUTPUT_BANK_SRC_MASK;\n\n\t\tmemset(&bank_src_map, 0, sizeof(bank_src_map));\n\t\tret = vc7_get_bank_clk(vc7, bank_idx, val, &bank_src_map);\n\t\tif (ret) {\n\t\t\tdev_err_probe(&client->dev, ret,\n\t\t\t\t      \"unable to register output %d\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch (bank_src_map.type) {\n\t\tcase VC7_FOD:\n\t\t\tparent_names[0] = clk_hw_get_name(&bank_src_map.src.fod->hw);\n\t\t\tbreak;\n\t\tcase VC7_IOD:\n\t\t\tparent_names[0] = clk_hw_get_name(&bank_src_map.src.iod->hw);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&clk_init, 0, sizeof(clk_init));\n\t\tclk_init.name = kasprintf(GFP_KERNEL, \"%s_out%d\", node_name, i);\n\t\tclk_init.ops = &vc7_clk_out_ops;\n\t\tclk_init.flags = CLK_SET_RATE_PARENT;\n\t\tclk_init.parent_names = parent_names;\n\t\tclk_init.num_parents = 1;\n\t\tvc7->clk_out[i].num = i;\n\t\tvc7->clk_out[i].vc7 = vc7;\n\t\tvc7->clk_out[i].hw.init = &clk_init;\n\t\tret = devm_clk_hw_register(&client->dev, &vc7->clk_out[i].hw);\n\t\tif (ret)\n\t\t\tgoto err_clk_register;\n\t\tkfree(clk_init.name);  \n\t}\n\n\tret = of_clk_add_hw_provider(client->dev.of_node, vc7_of_clk_get, vc7);\n\tif (ret) {\n\t\tdev_err_probe(&client->dev, ret, \"unable to add clk provider\\n\");\n\t\tgoto err_clk;\n\t}\n\n\treturn ret;\n\nerr_clk_register:\n\tdev_err_probe(&client->dev, ret,\n\t\t      \"unable to register %s\\n\", clk_init.name);\n\tkfree(clk_init.name);  \nerr_clk:\n\tclk_unregister_fixed_rate(vc7->clk_apll.clk);\n\treturn ret;\n}\n\nstatic void vc7_remove(struct i2c_client *client)\n{\n\tstruct vc7_driver_data *vc7 = i2c_get_clientdata(client);\n\n\tof_clk_del_provider(client->dev.of_node);\n\tclk_unregister_fixed_rate(vc7->clk_apll.clk);\n}\n\nstatic bool vc7_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tif (reg == VC7_PAGE_ADDR)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic const struct vc7_chip_info vc7_rc21008a_info = {\n\t.model = VC7_RC21008A,\n\t.num_banks = 6,\n\t.num_outputs = 8,\n};\n\nstatic struct regmap_range_cfg vc7_range_cfg[] = {\n{\n\t.range_min = 0,\n\t.range_max = VC7_MAX_REG,\n\t.selector_reg = VC7_PAGE_ADDR,\n\t.selector_mask = 0xFF,\n\t.selector_shift = 0,\n\t.window_start = 0,\n\t.window_len = VC7_PAGE_WINDOW,\n}};\n\nstatic const struct regmap_config vc7_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = VC7_MAX_REG,\n\t.ranges = vc7_range_cfg,\n\t.num_ranges = ARRAY_SIZE(vc7_range_cfg),\n\t.volatile_reg = vc7_volatile_reg,\n\t.cache_type = REGCACHE_RBTREE,\n\t.can_multi_write = true,\n\t.reg_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n};\n\nstatic const struct i2c_device_id vc7_i2c_id[] = {\n\t{ \"rc21008a\", .driver_data = (kernel_ulong_t)&vc7_rc21008a_info },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, vc7_i2c_id);\n\nstatic const struct of_device_id vc7_of_match[] = {\n\t{ .compatible = \"renesas,rc21008a\", .data = &vc7_rc21008a_info },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, vc7_of_match);\n\nstatic struct i2c_driver vc7_i2c_driver = {\n\t.driver = {\n\t\t.name = \"vc7\",\n\t\t.of_match_table = vc7_of_match,\n\t},\n\t.probe = vc7_probe,\n\t.remove = vc7_remove,\n\t.id_table = vc7_i2c_id,\n};\nmodule_i2c_driver(vc7_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alex Helms <alexander.helms.jy@renesas.com\");\nMODULE_DESCRIPTION(\"Renesas Versaclock7 common clock framework driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}