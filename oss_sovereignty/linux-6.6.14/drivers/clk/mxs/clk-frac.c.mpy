{
  "module_name": "clk-frac.c",
  "hash_id": "0d0225972c620d46c8db895df12ca29ce8e9976e06d5b5293f1bb1eb41d60c6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mxs/clk-frac.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include \"clk.h\"\n\n \nstruct clk_frac {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n\tu8 shift;\n\tu8 width;\n\tu8 busy;\n};\n\n#define to_clk_frac(_hw) container_of(_hw, struct clk_frac, hw)\n\nstatic unsigned long clk_frac_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_frac *frac = to_clk_frac(hw);\n\tu32 div;\n\tu64 tmp_rate;\n\n\tdiv = readl_relaxed(frac->reg) >> frac->shift;\n\tdiv &= (1 << frac->width) - 1;\n\n\ttmp_rate = (u64)parent_rate * div;\n\treturn tmp_rate >> frac->width;\n}\n\nstatic long clk_frac_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *prate)\n{\n\tstruct clk_frac *frac = to_clk_frac(hw);\n\tunsigned long parent_rate = *prate;\n\tu32 div;\n\tu64 tmp, tmp_rate, result;\n\n\tif (rate > parent_rate)\n\t\treturn -EINVAL;\n\n\ttmp = rate;\n\ttmp <<= frac->width;\n\tdo_div(tmp, parent_rate);\n\tdiv = tmp;\n\n\tif (!div)\n\t\treturn -EINVAL;\n\n\ttmp_rate = (u64)parent_rate * div;\n\tresult = tmp_rate >> frac->width;\n\tif ((result << frac->width) < tmp_rate)\n\t\tresult += 1;\n\treturn result;\n}\n\nstatic int clk_frac_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t     unsigned long parent_rate)\n{\n\tstruct clk_frac *frac = to_clk_frac(hw);\n\tunsigned long flags;\n\tu32 div, val;\n\tu64 tmp;\n\n\tif (rate > parent_rate)\n\t\treturn -EINVAL;\n\n\ttmp = rate;\n\ttmp <<= frac->width;\n\tdo_div(tmp, parent_rate);\n\tdiv = tmp;\n\n\tif (!div)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&mxs_lock, flags);\n\n\tval = readl_relaxed(frac->reg);\n\tval &= ~(((1 << frac->width) - 1) << frac->shift);\n\tval |= div << frac->shift;\n\twritel_relaxed(val, frac->reg);\n\n\tspin_unlock_irqrestore(&mxs_lock, flags);\n\n\treturn mxs_clk_wait(frac->reg, frac->busy);\n}\n\nstatic const struct clk_ops clk_frac_ops = {\n\t.recalc_rate = clk_frac_recalc_rate,\n\t.round_rate = clk_frac_round_rate,\n\t.set_rate = clk_frac_set_rate,\n};\n\nstruct clk *mxs_clk_frac(const char *name, const char *parent_name,\n\t\t\t void __iomem *reg, u8 shift, u8 width, u8 busy)\n{\n\tstruct clk_frac *frac;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\tfrac = kzalloc(sizeof(*frac), GFP_KERNEL);\n\tif (!frac)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &clk_frac_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = (parent_name ? &parent_name: NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\n\tfrac->reg = reg;\n\tfrac->shift = shift;\n\tfrac->width = width;\n\tfrac->busy = busy;\n\tfrac->hw.init = &init;\n\n\tclk = clk_register(NULL, &frac->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(frac);\n\n\treturn clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}