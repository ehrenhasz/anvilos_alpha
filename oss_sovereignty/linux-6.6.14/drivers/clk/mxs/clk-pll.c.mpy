{
  "module_name": "clk-pll.c",
  "hash_id": "74c6c4b76121a6d268bbe92891724f22e6ab21664844e8d22943201697af121b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mxs/clk-pll.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include \"clk.h\"\n\n \nstruct clk_pll {\n\tstruct clk_hw hw;\n\tvoid __iomem *base;\n\tu8 power;\n\tunsigned long rate;\n};\n\n#define to_clk_pll(_hw) container_of(_hw, struct clk_pll, hw)\n\nstatic int clk_pll_prepare(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\n\twritel_relaxed(1 << pll->power, pll->base + SET);\n\n\tudelay(10);\n\n\treturn 0;\n}\n\nstatic void clk_pll_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\n\twritel_relaxed(1 << pll->power, pll->base + CLR);\n}\n\nstatic int clk_pll_enable(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\n\twritel_relaxed(1 << 31, pll->base + CLR);\n\n\treturn 0;\n}\n\nstatic void clk_pll_disable(struct clk_hw *hw)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\n\twritel_relaxed(1 << 31, pll->base + SET);\n}\n\nstatic unsigned long clk_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\n\treturn pll->rate;\n}\n\nstatic const struct clk_ops clk_pll_ops = {\n\t.prepare = clk_pll_prepare,\n\t.unprepare = clk_pll_unprepare,\n\t.enable = clk_pll_enable,\n\t.disable = clk_pll_disable,\n\t.recalc_rate = clk_pll_recalc_rate,\n};\n\nstruct clk *mxs_clk_pll(const char *name, const char *parent_name,\n\t\t\tvoid __iomem *base, u8 power, unsigned long rate)\n{\n\tstruct clk_pll *pll;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &clk_pll_ops;\n\tinit.flags = 0;\n\tinit.parent_names = (parent_name ? &parent_name: NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\n\tpll->base = base;\n\tpll->rate = rate;\n\tpll->power = power;\n\tpll->hw.init = &init;\n\n\tclk = clk_register(NULL, &pll->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(pll);\n\n\treturn clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}