{
  "module_name": "clk-imx23.c",
  "hash_id": "d383e6adba4925451d80bc00660b62da41f83c1e0ae3299a2953bfb6aa4bfdcb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mxs/clk-imx23.c",
  "human_readable_source": "\n \n\n#include <linux/clk/mxs.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include \"clk.h\"\n\nstatic void __iomem *clkctrl;\nstatic void __iomem *digctrl;\n\n#define CLKCTRL clkctrl\n#define DIGCTRL digctrl\n\n#define PLLCTRL0\t\t(CLKCTRL + 0x0000)\n#define CPU\t\t\t(CLKCTRL + 0x0020)\n#define HBUS\t\t\t(CLKCTRL + 0x0030)\n#define XBUS\t\t\t(CLKCTRL + 0x0040)\n#define XTAL\t\t\t(CLKCTRL + 0x0050)\n#define PIX\t\t\t(CLKCTRL + 0x0060)\n#define SSP\t\t\t(CLKCTRL + 0x0070)\n#define GPMI\t\t\t(CLKCTRL + 0x0080)\n#define SPDIF\t\t\t(CLKCTRL + 0x0090)\n#define EMI\t\t\t(CLKCTRL + 0x00a0)\n#define SAIF\t\t\t(CLKCTRL + 0x00c0)\n#define TV\t\t\t(CLKCTRL + 0x00d0)\n#define ETM\t\t\t(CLKCTRL + 0x00e0)\n#define FRAC\t\t\t(CLKCTRL + 0x00f0)\n#define CLKSEQ\t\t\t(CLKCTRL + 0x0110)\n\n#define BP_CPU_INTERRUPT_WAIT\t12\n#define BP_CLKSEQ_BYPASS_SAIF\t0\n#define BP_CLKSEQ_BYPASS_SSP\t5\n#define BP_SAIF_DIV_FRAC_EN\t16\n#define BP_FRAC_IOFRAC\t\t24\n\nstatic void __init clk_misc_init(void)\n{\n\tu32 val;\n\n\t \n\twritel_relaxed(1 << BP_CPU_INTERRUPT_WAIT, CPU + SET);\n\n\t \n\twritel_relaxed(1 << BP_CLKSEQ_BYPASS_SAIF, CLKSEQ + CLR);\n\n\t \n\tval = readl_relaxed(SAIF);\n\tval |= 1 << BP_SAIF_DIV_FRAC_EN;\n\twritel_relaxed(val, SAIF);\n\n\t \n\twritel_relaxed(1 << BP_CLKSEQ_BYPASS_SSP, CLKSEQ + CLR);\n\n\t \n\twritel_relaxed(0x3f << BP_FRAC_IOFRAC, FRAC + CLR);\n\twritel_relaxed(30 << BP_FRAC_IOFRAC, FRAC + SET);\n}\n\nstatic const char *const sel_pll[]  __initconst = { \"pll\", \"ref_xtal\", };\nstatic const char *const sel_cpu[]  __initconst = { \"ref_cpu\", \"ref_xtal\", };\nstatic const char *const sel_pix[]  __initconst = { \"ref_pix\", \"ref_xtal\", };\nstatic const char *const sel_io[]   __initconst = { \"ref_io\", \"ref_xtal\", };\nstatic const char *const cpu_sels[] __initconst = { \"cpu_pll\", \"cpu_xtal\", };\nstatic const char *const emi_sels[] __initconst = { \"emi_pll\", \"emi_xtal\", };\n\nenum imx23_clk {\n\tref_xtal, pll, ref_cpu, ref_emi, ref_pix, ref_io, saif_sel,\n\tlcdif_sel, gpmi_sel, ssp_sel, emi_sel, cpu, etm_sel, cpu_pll,\n\tcpu_xtal, hbus, xbus, lcdif_div, ssp_div, gpmi_div, emi_pll,\n\temi_xtal, etm_div, saif_div, clk32k_div, rtc, adc, spdif_div,\n\tclk32k, dri, pwm, filt, uart, ssp, gpmi, spdif, emi, saif,\n\tlcdif, etm, usb, usb_phy,\n\tclk_max\n};\n\nstatic struct clk *clks[clk_max];\nstatic struct clk_onecell_data clk_data;\n\nstatic enum imx23_clk clks_init_on[] __initdata = {\n\tcpu, hbus, xbus, emi, uart,\n};\n\nstatic void __init mx23_clocks_init(struct device_node *np)\n{\n\tstruct device_node *dcnp;\n\tu32 i;\n\n\tdcnp = of_find_compatible_node(NULL, NULL, \"fsl,imx23-digctl\");\n\tdigctrl = of_iomap(dcnp, 0);\n\tWARN_ON(!digctrl);\n\tof_node_put(dcnp);\n\n\tclkctrl = of_iomap(np, 0);\n\tWARN_ON(!clkctrl);\n\n\tclk_misc_init();\n\n\tclks[ref_xtal] = mxs_clk_fixed(\"ref_xtal\", 24000000);\n\tclks[pll] = mxs_clk_pll(\"pll\", \"ref_xtal\", PLLCTRL0, 16, 480000000);\n\tclks[ref_cpu] = mxs_clk_ref(\"ref_cpu\", \"pll\", FRAC, 0);\n\tclks[ref_emi] = mxs_clk_ref(\"ref_emi\", \"pll\", FRAC, 1);\n\tclks[ref_pix] = mxs_clk_ref(\"ref_pix\", \"pll\", FRAC, 2);\n\tclks[ref_io] = mxs_clk_ref(\"ref_io\", \"pll\", FRAC, 3);\n\tclks[saif_sel] = mxs_clk_mux(\"saif_sel\", CLKSEQ, 0, 1, sel_pll, ARRAY_SIZE(sel_pll));\n\tclks[lcdif_sel] = mxs_clk_mux(\"lcdif_sel\", CLKSEQ, 1, 1, sel_pix, ARRAY_SIZE(sel_pix));\n\tclks[gpmi_sel] = mxs_clk_mux(\"gpmi_sel\", CLKSEQ, 4, 1, sel_io, ARRAY_SIZE(sel_io));\n\tclks[ssp_sel] = mxs_clk_mux(\"ssp_sel\", CLKSEQ, 5, 1, sel_io, ARRAY_SIZE(sel_io));\n\tclks[emi_sel] = mxs_clk_mux(\"emi_sel\", CLKSEQ, 6, 1, emi_sels, ARRAY_SIZE(emi_sels));\n\tclks[cpu] = mxs_clk_mux(\"cpu\", CLKSEQ, 7, 1, cpu_sels, ARRAY_SIZE(cpu_sels));\n\tclks[etm_sel] = mxs_clk_mux(\"etm_sel\", CLKSEQ, 8, 1, sel_cpu, ARRAY_SIZE(sel_cpu));\n\tclks[cpu_pll] = mxs_clk_div(\"cpu_pll\", \"ref_cpu\", CPU, 0, 6, 28);\n\tclks[cpu_xtal] = mxs_clk_div(\"cpu_xtal\", \"ref_xtal\", CPU, 16, 10, 29);\n\tclks[hbus] = mxs_clk_div(\"hbus\", \"cpu\", HBUS, 0, 5, 29);\n\tclks[xbus] = mxs_clk_div(\"xbus\", \"ref_xtal\", XBUS, 0, 10, 31);\n\tclks[lcdif_div] = mxs_clk_div(\"lcdif_div\", \"lcdif_sel\", PIX, 0, 12, 29);\n\tclks[ssp_div] = mxs_clk_div(\"ssp_div\", \"ssp_sel\", SSP, 0, 9, 29);\n\tclks[gpmi_div] = mxs_clk_div(\"gpmi_div\", \"gpmi_sel\", GPMI, 0, 10, 29);\n\tclks[emi_pll] = mxs_clk_div(\"emi_pll\", \"ref_emi\", EMI, 0, 6, 28);\n\tclks[emi_xtal] = mxs_clk_div(\"emi_xtal\", \"ref_xtal\", EMI, 8, 4, 29);\n\tclks[etm_div] = mxs_clk_div(\"etm_div\", \"etm_sel\", ETM, 0, 6, 29);\n\tclks[saif_div] = mxs_clk_frac(\"saif_div\", \"saif_sel\", SAIF, 0, 16, 29);\n\tclks[clk32k_div] = mxs_clk_fixed_factor(\"clk32k_div\", \"ref_xtal\", 1, 750);\n\tclks[rtc] = mxs_clk_fixed_factor(\"rtc\", \"ref_xtal\", 1, 768);\n\tclks[adc] = mxs_clk_fixed_factor(\"adc\", \"clk32k\", 1, 16);\n\tclks[spdif_div] = mxs_clk_fixed_factor(\"spdif_div\", \"pll\", 1, 4);\n\tclks[clk32k] = mxs_clk_gate(\"clk32k\", \"clk32k_div\", XTAL, 26);\n\tclks[dri] = mxs_clk_gate(\"dri\", \"ref_xtal\", XTAL, 28);\n\tclks[pwm] = mxs_clk_gate(\"pwm\", \"ref_xtal\", XTAL, 29);\n\tclks[filt] = mxs_clk_gate(\"filt\", \"ref_xtal\", XTAL, 30);\n\tclks[uart] = mxs_clk_gate(\"uart\", \"ref_xtal\", XTAL, 31);\n\tclks[ssp] = mxs_clk_gate(\"ssp\", \"ssp_div\", SSP, 31);\n\tclks[gpmi] = mxs_clk_gate(\"gpmi\", \"gpmi_div\", GPMI, 31);\n\tclks[spdif] = mxs_clk_gate(\"spdif\", \"spdif_div\", SPDIF, 31);\n\tclks[emi] = mxs_clk_gate(\"emi\", \"emi_sel\", EMI, 31);\n\tclks[saif] = mxs_clk_gate(\"saif\", \"saif_div\", SAIF, 31);\n\tclks[lcdif] = mxs_clk_gate(\"lcdif\", \"lcdif_div\", PIX, 31);\n\tclks[etm] = mxs_clk_gate(\"etm\", \"etm_div\", ETM, 31);\n\tclks[usb] = mxs_clk_gate(\"usb\", \"usb_phy\", DIGCTRL, 2);\n\tclks[usb_phy] = clk_register_gate(NULL, \"usb_phy\", \"pll\", 0, PLLCTRL0, 18, 0, &mxs_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(clks); i++)\n\t\tif (IS_ERR(clks[i])) {\n\t\t\tpr_err(\"i.MX23 clk %d: register failed with %ld\\n\",\n\t\t\t\ti, PTR_ERR(clks[i]));\n\t\t\treturn;\n\t\t}\n\n\tclk_data.clks = clks;\n\tclk_data.clk_num = ARRAY_SIZE(clks);\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);\n\n\tfor (i = 0; i < ARRAY_SIZE(clks_init_on); i++)\n\t\tclk_prepare_enable(clks[clks_init_on[i]]);\n\n}\nCLK_OF_DECLARE(imx23_clkctrl, \"fsl,imx23-clkctrl\", mx23_clocks_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}