{
  "module_name": "clk-imx28.c",
  "hash_id": "5a4f249852bacee415f604bb59614b31945134588f436b6d7a2394015a4291df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mxs/clk-imx28.c",
  "human_readable_source": "\n \n\n#include <linux/clk/mxs.h>\n#include <linux/clkdev.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include \"clk.h\"\n\nstatic void __iomem *clkctrl;\n#define CLKCTRL clkctrl\n\n#define PLL0CTRL0\t\t(CLKCTRL + 0x0000)\n#define PLL1CTRL0\t\t(CLKCTRL + 0x0020)\n#define PLL2CTRL0\t\t(CLKCTRL + 0x0040)\n#define CPU\t\t\t(CLKCTRL + 0x0050)\n#define HBUS\t\t\t(CLKCTRL + 0x0060)\n#define XBUS\t\t\t(CLKCTRL + 0x0070)\n#define XTAL\t\t\t(CLKCTRL + 0x0080)\n#define SSP0\t\t\t(CLKCTRL + 0x0090)\n#define SSP1\t\t\t(CLKCTRL + 0x00a0)\n#define SSP2\t\t\t(CLKCTRL + 0x00b0)\n#define SSP3\t\t\t(CLKCTRL + 0x00c0)\n#define GPMI\t\t\t(CLKCTRL + 0x00d0)\n#define SPDIF\t\t\t(CLKCTRL + 0x00e0)\n#define EMI\t\t\t(CLKCTRL + 0x00f0)\n#define SAIF0\t\t\t(CLKCTRL + 0x0100)\n#define SAIF1\t\t\t(CLKCTRL + 0x0110)\n#define LCDIF\t\t\t(CLKCTRL + 0x0120)\n#define ETM\t\t\t(CLKCTRL + 0x0130)\n#define ENET\t\t\t(CLKCTRL + 0x0140)\n#define FLEXCAN\t\t\t(CLKCTRL + 0x0160)\n#define FRAC0\t\t\t(CLKCTRL + 0x01b0)\n#define FRAC1\t\t\t(CLKCTRL + 0x01c0)\n#define CLKSEQ\t\t\t(CLKCTRL + 0x01d0)\n\n#define BP_CPU_INTERRUPT_WAIT\t12\n#define BP_SAIF_DIV_FRAC_EN\t16\n#define BP_ENET_DIV_TIME\t21\n#define BP_ENET_SLEEP\t\t31\n#define BP_CLKSEQ_BYPASS_SAIF0\t0\n#define BP_CLKSEQ_BYPASS_SSP0\t3\n#define BP_FRAC0_IO1FRAC\t16\n#define BP_FRAC0_IO0FRAC\t24\n\nstatic void __iomem *digctrl;\n#define DIGCTRL digctrl\n#define BP_SAIF_CLKMUX\t\t10\n\n \nint mxs_saif_clkmux_select(unsigned int clkmux)\n{\n\tif (clkmux > 0x3)\n\t\treturn -EINVAL;\n\n\twritel_relaxed(0x3 << BP_SAIF_CLKMUX, DIGCTRL + CLR);\n\twritel_relaxed(clkmux << BP_SAIF_CLKMUX, DIGCTRL + SET);\n\n\treturn 0;\n}\n\nstatic void __init clk_misc_init(void)\n{\n\tu32 val;\n\n\t \n\twritel_relaxed(1 << BP_CPU_INTERRUPT_WAIT, CPU + SET);\n\n\t \n\twritel_relaxed(1 << BP_ENET_DIV_TIME, ENET + SET);\n\n\t \n\twritel_relaxed(0x3 << BP_CLKSEQ_BYPASS_SAIF0, CLKSEQ + CLR);\n\n\t \n\tval = readl_relaxed(SAIF0);\n\tval |= 1 << BP_SAIF_DIV_FRAC_EN;\n\twritel_relaxed(val, SAIF0);\n\n\tval = readl_relaxed(SAIF1);\n\tval |= 1 << BP_SAIF_DIV_FRAC_EN;\n\twritel_relaxed(val, SAIF1);\n\n\t \n\tval = readl_relaxed(ENET);\n\tval &= ~(1 << BP_ENET_SLEEP);\n\twritel_relaxed(val, ENET);\n\n\t \n\twritel_relaxed(0xf << BP_CLKSEQ_BYPASS_SSP0, CLKSEQ + CLR);\n\n\t \n\tval = readl_relaxed(FRAC0);\n\tval &= ~((0x3f << BP_FRAC0_IO0FRAC) | (0x3f << BP_FRAC0_IO1FRAC));\n\tval |= (30 << BP_FRAC0_IO0FRAC) | (30 << BP_FRAC0_IO1FRAC);\n\twritel_relaxed(val, FRAC0);\n}\n\nstatic const char *const sel_cpu[]  __initconst = { \"ref_cpu\", \"ref_xtal\", };\nstatic const char *const sel_io0[]  __initconst = { \"ref_io0\", \"ref_xtal\", };\nstatic const char *const sel_io1[]  __initconst = { \"ref_io1\", \"ref_xtal\", };\nstatic const char *const sel_pix[]  __initconst = { \"ref_pix\", \"ref_xtal\", };\nstatic const char *const sel_gpmi[] __initconst = { \"ref_gpmi\", \"ref_xtal\", };\nstatic const char *const sel_pll0[] __initconst = { \"pll0\", \"ref_xtal\", };\nstatic const char *const cpu_sels[] __initconst = { \"cpu_pll\", \"cpu_xtal\", };\nstatic const char *const emi_sels[] __initconst = { \"emi_pll\", \"emi_xtal\", };\nstatic const char *const ptp_sels[] __initconst = { \"ref_xtal\", \"pll0\", };\n\nenum imx28_clk {\n\tref_xtal, pll0, pll1, pll2, ref_cpu, ref_emi, ref_io0, ref_io1,\n\tref_pix, ref_hsadc, ref_gpmi, saif0_sel, saif1_sel, gpmi_sel,\n\tssp0_sel, ssp1_sel, ssp2_sel, ssp3_sel, emi_sel, etm_sel,\n\tlcdif_sel, cpu, ptp_sel, cpu_pll, cpu_xtal, hbus, xbus,\n\tssp0_div, ssp1_div, ssp2_div, ssp3_div, gpmi_div, emi_pll,\n\temi_xtal, lcdif_div, etm_div, ptp, saif0_div, saif1_div,\n\tclk32k_div, rtc, lradc, spdif_div, clk32k, pwm, uart, ssp0,\n\tssp1, ssp2, ssp3, gpmi, spdif, emi, saif0, saif1, lcdif, etm,\n\tfec, can0, can1, usb0, usb1, usb0_phy, usb1_phy, enet_out,\n\tclk_max\n};\n\nstatic struct clk *clks[clk_max];\nstatic struct clk_onecell_data clk_data;\n\nstatic enum imx28_clk clks_init_on[] __initdata = {\n\tcpu, hbus, xbus, emi, uart,\n};\n\nstatic void __init mx28_clocks_init(struct device_node *np)\n{\n\tstruct device_node *dcnp;\n\tu32 i;\n\n\tdcnp = of_find_compatible_node(NULL, NULL, \"fsl,imx28-digctl\");\n\tdigctrl = of_iomap(dcnp, 0);\n\tWARN_ON(!digctrl);\n\tof_node_put(dcnp);\n\n\tclkctrl = of_iomap(np, 0);\n\tWARN_ON(!clkctrl);\n\n\tclk_misc_init();\n\n\tclks[ref_xtal] = mxs_clk_fixed(\"ref_xtal\", 24000000);\n\tclks[pll0] = mxs_clk_pll(\"pll0\", \"ref_xtal\", PLL0CTRL0, 17, 480000000);\n\tclks[pll1] = mxs_clk_pll(\"pll1\", \"ref_xtal\", PLL1CTRL0, 17, 480000000);\n\tclks[pll2] = mxs_clk_pll(\"pll2\", \"ref_xtal\", PLL2CTRL0, 23, 50000000);\n\tclks[ref_cpu] = mxs_clk_ref(\"ref_cpu\", \"pll0\", FRAC0, 0);\n\tclks[ref_emi] = mxs_clk_ref(\"ref_emi\", \"pll0\", FRAC0, 1);\n\tclks[ref_io1] = mxs_clk_ref(\"ref_io1\", \"pll0\", FRAC0, 2);\n\tclks[ref_io0] = mxs_clk_ref(\"ref_io0\", \"pll0\", FRAC0, 3);\n\tclks[ref_pix] = mxs_clk_ref(\"ref_pix\", \"pll0\", FRAC1, 0);\n\tclks[ref_hsadc] = mxs_clk_ref(\"ref_hsadc\", \"pll0\", FRAC1, 1);\n\tclks[ref_gpmi] = mxs_clk_ref(\"ref_gpmi\", \"pll0\", FRAC1, 2);\n\tclks[saif0_sel] = mxs_clk_mux(\"saif0_sel\", CLKSEQ, 0, 1, sel_pll0, ARRAY_SIZE(sel_pll0));\n\tclks[saif1_sel] = mxs_clk_mux(\"saif1_sel\", CLKSEQ, 1, 1, sel_pll0, ARRAY_SIZE(sel_pll0));\n\tclks[gpmi_sel] = mxs_clk_mux(\"gpmi_sel\", CLKSEQ, 2, 1, sel_gpmi, ARRAY_SIZE(sel_gpmi));\n\tclks[ssp0_sel] = mxs_clk_mux(\"ssp0_sel\", CLKSEQ, 3, 1, sel_io0, ARRAY_SIZE(sel_io0));\n\tclks[ssp1_sel] = mxs_clk_mux(\"ssp1_sel\", CLKSEQ, 4, 1, sel_io0, ARRAY_SIZE(sel_io0));\n\tclks[ssp2_sel] = mxs_clk_mux(\"ssp2_sel\", CLKSEQ, 5, 1, sel_io1, ARRAY_SIZE(sel_io1));\n\tclks[ssp3_sel] = mxs_clk_mux(\"ssp3_sel\", CLKSEQ, 6, 1, sel_io1, ARRAY_SIZE(sel_io1));\n\tclks[emi_sel] = mxs_clk_mux(\"emi_sel\", CLKSEQ, 7, 1, emi_sels, ARRAY_SIZE(emi_sels));\n\tclks[etm_sel] = mxs_clk_mux(\"etm_sel\", CLKSEQ, 8, 1, sel_cpu, ARRAY_SIZE(sel_cpu));\n\tclks[lcdif_sel] = mxs_clk_mux(\"lcdif_sel\", CLKSEQ, 14, 1, sel_pix, ARRAY_SIZE(sel_pix));\n\tclks[cpu] = mxs_clk_mux(\"cpu\", CLKSEQ, 18, 1, cpu_sels, ARRAY_SIZE(cpu_sels));\n\tclks[ptp_sel] = mxs_clk_mux(\"ptp_sel\", ENET, 19, 1, ptp_sels, ARRAY_SIZE(ptp_sels));\n\tclks[cpu_pll] = mxs_clk_div(\"cpu_pll\", \"ref_cpu\", CPU, 0, 6, 28);\n\tclks[cpu_xtal] = mxs_clk_div(\"cpu_xtal\", \"ref_xtal\", CPU, 16, 10, 29);\n\tclks[hbus] = mxs_clk_div(\"hbus\", \"cpu\", HBUS, 0, 5, 31);\n\tclks[xbus] = mxs_clk_div(\"xbus\", \"ref_xtal\", XBUS, 0, 10, 31);\n\tclks[ssp0_div] = mxs_clk_div(\"ssp0_div\", \"ssp0_sel\", SSP0, 0, 9, 29);\n\tclks[ssp1_div] = mxs_clk_div(\"ssp1_div\", \"ssp1_sel\", SSP1, 0, 9, 29);\n\tclks[ssp2_div] = mxs_clk_div(\"ssp2_div\", \"ssp2_sel\", SSP2, 0, 9, 29);\n\tclks[ssp3_div] = mxs_clk_div(\"ssp3_div\", \"ssp3_sel\", SSP3, 0, 9, 29);\n\tclks[gpmi_div] = mxs_clk_div(\"gpmi_div\", \"gpmi_sel\", GPMI, 0, 10, 29);\n\tclks[emi_pll] = mxs_clk_div(\"emi_pll\", \"ref_emi\", EMI, 0, 6, 28);\n\tclks[emi_xtal] = mxs_clk_div(\"emi_xtal\", \"ref_xtal\", EMI, 8, 4, 29);\n\tclks[lcdif_div] = mxs_clk_div(\"lcdif_div\", \"lcdif_sel\", LCDIF, 0, 13, 29);\n\tclks[etm_div] = mxs_clk_div(\"etm_div\", \"etm_sel\", ETM, 0, 7, 29);\n\tclks[ptp] = mxs_clk_div(\"ptp\", \"ptp_sel\", ENET, 21, 6, 27);\n\tclks[saif0_div] = mxs_clk_frac(\"saif0_div\", \"saif0_sel\", SAIF0, 0, 16, 29);\n\tclks[saif1_div] = mxs_clk_frac(\"saif1_div\", \"saif1_sel\", SAIF1, 0, 16, 29);\n\tclks[clk32k_div] = mxs_clk_fixed_factor(\"clk32k_div\", \"ref_xtal\", 1, 750);\n\tclks[rtc] = mxs_clk_fixed_factor(\"rtc\", \"ref_xtal\", 1, 768);\n\tclks[lradc] = mxs_clk_fixed_factor(\"lradc\", \"clk32k\", 1, 16);\n\tclks[spdif_div] = mxs_clk_fixed_factor(\"spdif_div\", \"pll0\", 1, 4);\n\tclks[clk32k] = mxs_clk_gate(\"clk32k\", \"clk32k_div\", XTAL, 26);\n\tclks[pwm] = mxs_clk_gate(\"pwm\", \"ref_xtal\", XTAL, 29);\n\tclks[uart] = mxs_clk_gate(\"uart\", \"ref_xtal\", XTAL, 31);\n\tclks[ssp0] = mxs_clk_gate(\"ssp0\", \"ssp0_div\", SSP0, 31);\n\tclks[ssp1] = mxs_clk_gate(\"ssp1\", \"ssp1_div\", SSP1, 31);\n\tclks[ssp2] = mxs_clk_gate(\"ssp2\", \"ssp2_div\", SSP2, 31);\n\tclks[ssp3] = mxs_clk_gate(\"ssp3\", \"ssp3_div\", SSP3, 31);\n\tclks[gpmi] = mxs_clk_gate(\"gpmi\", \"gpmi_div\", GPMI, 31);\n\tclks[spdif] = mxs_clk_gate(\"spdif\", \"spdif_div\", SPDIF, 31);\n\tclks[emi] = mxs_clk_gate(\"emi\", \"emi_sel\", EMI, 31);\n\tclks[saif0] = mxs_clk_gate(\"saif0\", \"saif0_div\", SAIF0, 31);\n\tclks[saif1] = mxs_clk_gate(\"saif1\", \"saif1_div\", SAIF1, 31);\n\tclks[lcdif] = mxs_clk_gate(\"lcdif\", \"lcdif_div\", LCDIF, 31);\n\tclks[etm] = mxs_clk_gate(\"etm\", \"etm_div\", ETM, 31);\n\tclks[fec] = mxs_clk_gate(\"fec\", \"hbus\", ENET, 30);\n\tclks[can0] = mxs_clk_gate(\"can0\", \"ref_xtal\", FLEXCAN, 30);\n\tclks[can1] = mxs_clk_gate(\"can1\", \"ref_xtal\", FLEXCAN, 28);\n\tclks[usb0] = mxs_clk_gate(\"usb0\", \"usb0_phy\", DIGCTRL, 2);\n\tclks[usb1] = mxs_clk_gate(\"usb1\", \"usb1_phy\", DIGCTRL, 16);\n\tclks[usb0_phy] = clk_register_gate(NULL, \"usb0_phy\", \"pll0\", 0, PLL0CTRL0, 18, 0, &mxs_lock);\n\tclks[usb1_phy] = clk_register_gate(NULL, \"usb1_phy\", \"pll1\", 0, PLL1CTRL0, 18, 0, &mxs_lock);\n\tclks[enet_out] = clk_register_gate(NULL, \"enet_out\", \"pll2\", 0, ENET, 18, 0, &mxs_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(clks); i++)\n\t\tif (IS_ERR(clks[i])) {\n\t\t\tpr_err(\"i.MX28 clk %d: register failed with %ld\\n\",\n\t\t\t\ti, PTR_ERR(clks[i]));\n\t\t\treturn;\n\t\t}\n\n\tclk_data.clks = clks;\n\tclk_data.clk_num = ARRAY_SIZE(clks);\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);\n\n\tclk_register_clkdev(clks[enet_out], NULL, \"enet_out\");\n\n\tfor (i = 0; i < ARRAY_SIZE(clks_init_on); i++)\n\t\tclk_prepare_enable(clks[clks_init_on[i]]);\n}\nCLK_OF_DECLARE(imx28_clkctrl, \"fsl,imx28-clkctrl\", mx28_clocks_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}