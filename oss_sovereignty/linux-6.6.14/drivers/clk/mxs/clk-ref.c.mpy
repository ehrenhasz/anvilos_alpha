{
  "module_name": "clk-ref.c",
  "hash_id": "dfa27182080522fa69e293cf64aa233b30b187ac9686b77460be1dcd516bec80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/mxs/clk-ref.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include \"clk.h\"\n\n \nstruct clk_ref {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n\tu8 idx;\n};\n\n#define to_clk_ref(_hw) container_of(_hw, struct clk_ref, hw)\n\nstatic int clk_ref_enable(struct clk_hw *hw)\n{\n\tstruct clk_ref *ref = to_clk_ref(hw);\n\n\twritel_relaxed(1 << ((ref->idx + 1) * 8 - 1), ref->reg + CLR);\n\n\treturn 0;\n}\n\nstatic void clk_ref_disable(struct clk_hw *hw)\n{\n\tstruct clk_ref *ref = to_clk_ref(hw);\n\n\twritel_relaxed(1 << ((ref->idx + 1) * 8 - 1), ref->reg + SET);\n}\n\nstatic unsigned long clk_ref_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_ref *ref = to_clk_ref(hw);\n\tu64 tmp = parent_rate;\n\tu8 frac = (readl_relaxed(ref->reg) >> (ref->idx * 8)) & 0x3f;\n\n\ttmp *= 18;\n\tdo_div(tmp, frac);\n\n\treturn tmp;\n}\n\nstatic long clk_ref_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *prate)\n{\n\tunsigned long parent_rate = *prate;\n\tu64 tmp = parent_rate;\n\tu8 frac;\n\n\ttmp = tmp * 18 + rate / 2;\n\tdo_div(tmp, rate);\n\tfrac = tmp;\n\n\tif (frac < 18)\n\t\tfrac = 18;\n\telse if (frac > 35)\n\t\tfrac = 35;\n\n\ttmp = parent_rate;\n\ttmp *= 18;\n\tdo_div(tmp, frac);\n\n\treturn tmp;\n}\n\nstatic int clk_ref_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_ref *ref = to_clk_ref(hw);\n\tunsigned long flags;\n\tu64 tmp = parent_rate;\n\tu32 val;\n\tu8 frac, shift = ref->idx * 8;\n\n\ttmp = tmp * 18 + rate / 2;\n\tdo_div(tmp, rate);\n\tfrac = tmp;\n\n\tif (frac < 18)\n\t\tfrac = 18;\n\telse if (frac > 35)\n\t\tfrac = 35;\n\n\tspin_lock_irqsave(&mxs_lock, flags);\n\n\tval = readl_relaxed(ref->reg);\n\tval &= ~(0x3f << shift);\n\tval |= frac << shift;\n\twritel_relaxed(val, ref->reg);\n\n\tspin_unlock_irqrestore(&mxs_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_ref_ops = {\n\t.enable\t\t= clk_ref_enable,\n\t.disable\t= clk_ref_disable,\n\t.recalc_rate\t= clk_ref_recalc_rate,\n\t.round_rate\t= clk_ref_round_rate,\n\t.set_rate\t= clk_ref_set_rate,\n};\n\nstruct clk *mxs_clk_ref(const char *name, const char *parent_name,\n\t\t\tvoid __iomem *reg, u8 idx)\n{\n\tstruct clk_ref *ref;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\tref = kzalloc(sizeof(*ref), GFP_KERNEL);\n\tif (!ref)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &clk_ref_ops;\n\tinit.flags = 0;\n\tinit.parent_names = (parent_name ? &parent_name: NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\n\tref->reg = reg;\n\tref->idx = idx;\n\tref->hw.init = &init;\n\n\tclk = clk_register(NULL, &ref->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(ref);\n\n\treturn clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}