{
  "module_name": "clk-cgu-pll.c",
  "hash_id": "5a3e9e681032799c12bac69405fa9d11402a51873ccbf162857282fd738f4e44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/x86/clk-cgu-pll.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n\n#include \"clk-cgu.h\"\n\n#define to_lgm_clk_pll(_hw)\tcontainer_of(_hw, struct lgm_clk_pll, hw)\n#define PLL_REF_DIV(x)\t\t((x) + 0x08)\n\n \nstatic unsigned long\nlgm_pll_calc_rate(unsigned long prate, unsigned int mult,\n\t\t  unsigned int div, unsigned int frac, unsigned int frac_div)\n{\n\tu64 crate, frate, rate64;\n\n\trate64 = prate;\n\tcrate = rate64 * mult;\n\tfrate = rate64 * frac;\n\tdo_div(frate, frac_div);\n\tcrate += frate;\n\tdo_div(crate, div);\n\n\treturn crate;\n}\n\nstatic unsigned long lgm_pll_recalc_rate(struct clk_hw *hw, unsigned long prate)\n{\n\tstruct lgm_clk_pll *pll = to_lgm_clk_pll(hw);\n\tunsigned int div, mult, frac;\n\n\tmult = lgm_get_clk_val(pll->membase, PLL_REF_DIV(pll->reg), 0, 12);\n\tdiv = lgm_get_clk_val(pll->membase, PLL_REF_DIV(pll->reg), 18, 6);\n\tfrac = lgm_get_clk_val(pll->membase, pll->reg, 2, 24);\n\n\tif (pll->type == TYPE_LJPLL)\n\t\tdiv *= 4;\n\n\treturn lgm_pll_calc_rate(prate, mult, div, frac, BIT(24));\n}\n\nstatic int lgm_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct lgm_clk_pll *pll = to_lgm_clk_pll(hw);\n\tunsigned int ret;\n\n\tret = lgm_get_clk_val(pll->membase, pll->reg, 0, 1);\n\n\treturn ret;\n}\n\nstatic int lgm_pll_enable(struct clk_hw *hw)\n{\n\tstruct lgm_clk_pll *pll = to_lgm_clk_pll(hw);\n\tu32 val;\n\tint ret;\n\n\tlgm_set_clk_val(pll->membase, pll->reg, 0, 1, 1);\n\tret = regmap_read_poll_timeout_atomic(pll->membase, pll->reg,\n\t\t\t\t\t      val, (val & 0x1), 1, 100);\n\n\n\treturn ret;\n}\n\nstatic void lgm_pll_disable(struct clk_hw *hw)\n{\n\tstruct lgm_clk_pll *pll = to_lgm_clk_pll(hw);\n\n\tlgm_set_clk_val(pll->membase, pll->reg, 0, 1, 0);\n}\n\nstatic const struct clk_ops lgm_pll_ops = {\n\t.recalc_rate = lgm_pll_recalc_rate,\n\t.is_enabled = lgm_pll_is_enabled,\n\t.enable = lgm_pll_enable,\n\t.disable = lgm_pll_disable,\n};\n\nstatic struct clk_hw *\nlgm_clk_register_pll(struct lgm_clk_provider *ctx,\n\t\t     const struct lgm_pll_clk_data *list)\n{\n\tstruct clk_init_data init = {};\n\tstruct lgm_clk_pll *pll;\n\tstruct device *dev = ctx->dev;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tinit.ops = &lgm_pll_ops;\n\tinit.name = list->name;\n\tinit.flags = list->flags;\n\tinit.parent_data = list->parent_data;\n\tinit.num_parents = list->num_parents;\n\n\tpll = devm_kzalloc(dev, sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpll->membase = ctx->membase;\n\tpll->reg = list->reg;\n\tpll->flags = list->flags;\n\tpll->type = list->type;\n\tpll->hw.init = &init;\n\n\thw = &pll->hw;\n\tret = devm_clk_hw_register(dev, hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn hw;\n}\n\nint lgm_clk_register_plls(struct lgm_clk_provider *ctx,\n\t\t\t  const struct lgm_pll_clk_data *list,\n\t\t\t  unsigned int nr_clk)\n{\n\tstruct clk_hw *hw;\n\tint i;\n\n\tfor (i = 0; i < nr_clk; i++, list++) {\n\t\thw = lgm_clk_register_pll(ctx, list);\n\t\tif (IS_ERR(hw)) {\n\t\t\tdev_err(ctx->dev, \"failed to register pll: %s\\n\",\n\t\t\t\tlist->name);\n\t\t\treturn PTR_ERR(hw);\n\t\t}\n\t\tctx->clk_data.hws[list->id] = hw;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}