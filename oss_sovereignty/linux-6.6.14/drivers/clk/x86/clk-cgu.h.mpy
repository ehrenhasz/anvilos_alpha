{
  "module_name": "clk-cgu.h",
  "hash_id": "c5cf6a7260eee360626193c1f9d1a25aa178b488d01c341eb9b75a7fc23fa681",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/x86/clk-cgu.h",
  "human_readable_source": " \n \n\n#ifndef __CLK_CGU_H\n#define __CLK_CGU_H\n\n#include <linux/regmap.h>\n\nstruct lgm_clk_mux {\n\tstruct clk_hw hw;\n\tstruct regmap *membase;\n\tunsigned int reg;\n\tu8 shift;\n\tu8 width;\n\tunsigned long flags;\n};\n\nstruct lgm_clk_divider {\n\tstruct clk_hw hw;\n\tstruct regmap *membase;\n\tunsigned int reg;\n\tu8 shift;\n\tu8 width;\n\tu8 shift_gate;\n\tu8 width_gate;\n\tunsigned long flags;\n\tconst struct clk_div_table *table;\n};\n\nstruct lgm_clk_ddiv {\n\tstruct clk_hw hw;\n\tstruct regmap *membase;\n\tunsigned int reg;\n\tu8 shift0;\n\tu8 width0;\n\tu8 shift1;\n\tu8 width1;\n\tu8 shift2;\n\tu8 width2;\n\tu8 shift_gate;\n\tu8 width_gate;\n\tunsigned int mult;\n\tunsigned int div;\n\tunsigned long flags;\n};\n\nstruct lgm_clk_gate {\n\tstruct clk_hw hw;\n\tstruct regmap *membase;\n\tunsigned int reg;\n\tu8 shift;\n\tunsigned long flags;\n};\n\nenum lgm_clk_type {\n\tCLK_TYPE_FIXED,\n\tCLK_TYPE_MUX,\n\tCLK_TYPE_DIVIDER,\n\tCLK_TYPE_FIXED_FACTOR,\n\tCLK_TYPE_GATE,\n\tCLK_TYPE_NONE,\n};\n\n \nstruct lgm_clk_provider {\n\tstruct regmap *membase;\n\tstruct device_node *np;\n\tstruct device *dev;\n\tstruct clk_hw_onecell_data clk_data;\n};\n\nenum pll_type {\n\tTYPE_ROPLL,\n\tTYPE_LJPLL,\n\tTYPE_NONE,\n};\n\nstruct lgm_clk_pll {\n\tstruct clk_hw hw;\n\tstruct regmap *membase;\n\tunsigned int reg;\n\tunsigned long flags;\n\tenum pll_type type;\n};\n\n \nstruct lgm_pll_clk_data {\n\tunsigned int id;\n\tconst char *name;\n\tconst struct clk_parent_data *parent_data;\n\tu8 num_parents;\n\tunsigned long flags;\n\tenum pll_type type;\n\tint reg;\n};\n\n#define LGM_PLL(_id, _name, _pdata, _flags,\t\t\\\n\t\t_reg, _type)\t\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\\\n\t\t.parent_data = _pdata,\t\t\t\\\n\t\t.num_parents = ARRAY_SIZE(_pdata),\t\\\n\t\t.flags = _flags,\t\t\t\\\n\t\t.reg = _reg,\t\t\t\t\\\n\t\t.type = _type,\t\t\t\t\\\n\t}\n\nstruct lgm_clk_ddiv_data {\n\tunsigned int id;\n\tconst char *name;\n\tconst struct clk_parent_data *parent_data;\n\tu8 flags;\n\tunsigned long div_flags;\n\tunsigned int reg;\n\tu8 shift0;\n\tu8 width0;\n\tu8 shift1;\n\tu8 width1;\n\tu8 shift_gate;\n\tu8 width_gate;\n\tu8 ex_shift;\n\tu8 ex_width;\n};\n\n#define LGM_DDIV(_id, _name, _pname, _flags, _reg,\t\t\\\n\t\t _shft0, _wdth0, _shft1, _wdth1,\t\t\\\n\t\t _shft_gate, _wdth_gate, _xshft, _df)\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\\\n\t\t.parent_data = &(const struct clk_parent_data){\t\\\n\t\t\t.fw_name = _pname,\t\t\t\\\n\t\t\t.name = _pname,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.flags = _flags,\t\t\t\t\\\n\t\t.reg = _reg,\t\t\t\t\t\\\n\t\t.shift0 = _shft0,\t\t\t\t\\\n\t\t.width0 = _wdth0,\t\t\t\t\\\n\t\t.shift1 = _shft1,\t\t\t\t\\\n\t\t.width1 = _wdth1,\t\t\t\t\\\n\t\t.shift_gate = _shft_gate,\t\t\t\\\n\t\t.width_gate = _wdth_gate,\t\t\t\\\n\t\t.ex_shift = _xshft,\t\t\t\t\\\n\t\t.ex_width = 1,\t\t\t\t\t\\\n\t\t.div_flags = _df,\t\t\t\t\\\n\t}\n\nstruct lgm_clk_branch {\n\tunsigned int id;\n\tenum lgm_clk_type type;\n\tconst char *name;\n\tconst struct clk_parent_data *parent_data;\n\tu8 num_parents;\n\tunsigned long flags;\n\tunsigned int mux_off;\n\tu8 mux_shift;\n\tu8 mux_width;\n\tunsigned long mux_flags;\n\tunsigned int mux_val;\n\tunsigned int div_off;\n\tu8 div_shift;\n\tu8 div_width;\n\tu8 div_shift_gate;\n\tu8 div_width_gate;\n\tunsigned long div_flags;\n\tunsigned int div_val;\n\tconst struct clk_div_table *div_table;\n\tunsigned int gate_off;\n\tu8 gate_shift;\n\tunsigned long gate_flags;\n\tunsigned int gate_val;\n\tunsigned int mult;\n\tunsigned int div;\n};\n\n \n#define CLOCK_FLAG_VAL_INIT\tBIT(16)\n#define MUX_CLK_SW\t\tBIT(17)\n#define GATE_CLK_HW\t\tBIT(18)\n#define DIV_CLK_NO_MASK\t\tBIT(19)\n\n#define LGM_MUX(_id, _name, _pdata, _f, _reg,\t\t\\\n\t\t_shift, _width, _cf, _v)\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\\\n\t\t.type = CLK_TYPE_MUX,\t\t\t\\\n\t\t.name = _name,\t\t\t\t\\\n\t\t.parent_data = _pdata,\t\t\t\\\n\t\t.num_parents = ARRAY_SIZE(_pdata),\t\\\n\t\t.flags = _f,\t\t\t\t\\\n\t\t.mux_off = _reg,\t\t\t\\\n\t\t.mux_shift = _shift,\t\t\t\\\n\t\t.mux_width = _width,\t\t\t\\\n\t\t.mux_flags = _cf,\t\t\t\\\n\t\t.mux_val = _v,\t\t\t\t\\\n\t}\n\n#define LGM_DIV(_id, _name, _pname, _f, _reg, _shift, _width,\t\\\n\t\t_shift_gate, _width_gate, _cf, _v, _dtable)\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\\\n\t\t.type = CLK_TYPE_DIVIDER,\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\\\n\t\t.parent_data = &(const struct clk_parent_data){\t\\\n\t\t\t.fw_name = _pname,\t\t\t\\\n\t\t\t.name = _pname,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.num_parents = 1,\t\t\t\t\\\n\t\t.flags = _f,\t\t\t\t\t\\\n\t\t.div_off = _reg,\t\t\t\t\\\n\t\t.div_shift = _shift,\t\t\t\t\\\n\t\t.div_width = _width,\t\t\t\t\\\n\t\t.div_shift_gate = _shift_gate,\t\t\t\\\n\t\t.div_width_gate = _width_gate,\t\t\t\\\n\t\t.div_flags = _cf,\t\t\t\t\\\n\t\t.div_val = _v,\t\t\t\t\t\\\n\t\t.div_table = _dtable,\t\t\t\t\\\n\t}\n\n#define LGM_GATE(_id, _name, _pname, _f, _reg,\t\t\t\\\n\t\t _shift, _cf, _v)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\\\n\t\t.type = CLK_TYPE_GATE,\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\\\n\t\t.parent_data = &(const struct clk_parent_data){\t\\\n\t\t\t.fw_name = _pname,\t\t\t\\\n\t\t\t.name = _pname,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.num_parents = !_pname ? 0 : 1,\t\t\t\\\n\t\t.flags = _f,\t\t\t\t\t\\\n\t\t.gate_off = _reg,\t\t\t\t\\\n\t\t.gate_shift = _shift,\t\t\t\t\\\n\t\t.gate_flags = _cf,\t\t\t\t\\\n\t\t.gate_val = _v,\t\t\t\t\t\\\n\t}\n\n#define LGM_FIXED(_id, _name, _pname, _f, _reg,\t\t\t\\\n\t\t  _shift, _width, _cf, _freq, _v)\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\\\n\t\t.type = CLK_TYPE_FIXED,\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\\\n\t\t.parent_data = &(const struct clk_parent_data){\t\\\n\t\t\t.fw_name = _pname,\t\t\t\\\n\t\t\t.name = _pname,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.num_parents = !_pname ? 0 : 1,\t\t\t\\\n\t\t.flags = _f,\t\t\t\t\t\\\n\t\t.div_off = _reg,\t\t\t\t\\\n\t\t.div_shift = _shift,\t\t\t\t\\\n\t\t.div_width = _width,\t\t\t\t\\\n\t\t.div_flags = _cf,\t\t\t\t\\\n\t\t.div_val = _v,\t\t\t\t\t\\\n\t\t.mux_flags = _freq,\t\t\t\t\\\n\t}\n\n#define LGM_FIXED_FACTOR(_id, _name, _pname, _f, _reg,\t\t\\\n\t\t\t _shift, _width, _cf, _v, _m, _d)\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\\\n\t\t.type = CLK_TYPE_FIXED_FACTOR,\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\\\n\t\t.parent_data = &(const struct clk_parent_data){\t\\\n\t\t\t.fw_name = _pname,\t\t\t\\\n\t\t\t.name = _pname,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.num_parents = 1,\t\t\t\t\\\n\t\t.flags = _f,\t\t\t\t\t\\\n\t\t.div_off = _reg,\t\t\t\t\\\n\t\t.div_shift = _shift,\t\t\t\t\\\n\t\t.div_width = _width,\t\t\t\t\\\n\t\t.div_flags = _cf,\t\t\t\t\\\n\t\t.div_val = _v,\t\t\t\t\t\\\n\t\t.mult = _m,\t\t\t\t\t\\\n\t\t.div = _d,\t\t\t\t\t\\\n\t}\n\nstatic inline void lgm_set_clk_val(struct regmap *membase, u32 reg,\n\t\t\t\t   u8 shift, u8 width, u32 set_val)\n{\n\tu32 mask = (GENMASK(width - 1, 0) << shift);\n\n\tregmap_update_bits(membase, reg, mask, set_val << shift);\n}\n\nstatic inline u32 lgm_get_clk_val(struct regmap *membase, u32 reg,\n\t\t\t\t  u8 shift, u8 width)\n{\n\tu32 mask = (GENMASK(width - 1, 0) << shift);\n\tu32 val;\n\n\tif (regmap_read(membase, reg, &val)) {\n\t\tWARN_ONCE(1, \"Failed to read clk reg: 0x%x\\n\", reg);\n\t\treturn 0;\n\t}\n\n\tval = (val & mask) >> shift;\n\n\treturn val;\n}\n\n\n\nint lgm_clk_register_branches(struct lgm_clk_provider *ctx,\n\t\t\t      const struct lgm_clk_branch *list,\n\t\t\t      unsigned int nr_clk);\nint lgm_clk_register_plls(struct lgm_clk_provider *ctx,\n\t\t\t  const struct lgm_pll_clk_data *list,\n\t\t\t  unsigned int nr_clk);\nint lgm_clk_register_ddiv(struct lgm_clk_provider *ctx,\n\t\t\t  const struct lgm_clk_ddiv_data *list,\n\t\t\t  unsigned int nr_clk);\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}