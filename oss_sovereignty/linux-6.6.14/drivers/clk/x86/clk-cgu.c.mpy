{
  "module_name": "clk-cgu.c",
  "hash_id": "6838b4536a694c0c0c6bb0834a26cbf40c4a3f2bb0c8bfda36ebb3f5fe86e14b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/x86/clk-cgu.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/of.h>\n\n#include \"clk-cgu.h\"\n\n#define GATE_HW_REG_STAT(reg)\t((reg) + 0x0)\n#define GATE_HW_REG_EN(reg)\t((reg) + 0x4)\n#define GATE_HW_REG_DIS(reg)\t((reg) + 0x8)\n#define MAX_DDIV_REG\t8\n#define MAX_DIVIDER_VAL 64\n\n#define to_lgm_clk_mux(_hw) container_of(_hw, struct lgm_clk_mux, hw)\n#define to_lgm_clk_divider(_hw) container_of(_hw, struct lgm_clk_divider, hw)\n#define to_lgm_clk_gate(_hw) container_of(_hw, struct lgm_clk_gate, hw)\n#define to_lgm_clk_ddiv(_hw) container_of(_hw, struct lgm_clk_ddiv, hw)\n\nstatic struct clk_hw *lgm_clk_register_fixed(struct lgm_clk_provider *ctx,\n\t\t\t\t\t     const struct lgm_clk_branch *list)\n{\n\n\tif (list->div_flags & CLOCK_FLAG_VAL_INIT)\n\t\tlgm_set_clk_val(ctx->membase, list->div_off, list->div_shift,\n\t\t\t\tlist->div_width, list->div_val);\n\n\treturn clk_hw_register_fixed_rate(NULL, list->name,\n\t\t\t\t\t  list->parent_data[0].name,\n\t\t\t\t\t  list->flags, list->mux_flags);\n}\n\nstatic u8 lgm_clk_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct lgm_clk_mux *mux = to_lgm_clk_mux(hw);\n\tu32 val;\n\n\tif (mux->flags & MUX_CLK_SW)\n\t\tval = mux->reg;\n\telse\n\t\tval = lgm_get_clk_val(mux->membase, mux->reg, mux->shift,\n\t\t\t\t      mux->width);\n\treturn clk_mux_val_to_index(hw, NULL, mux->flags, val);\n}\n\nstatic int lgm_clk_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct lgm_clk_mux *mux = to_lgm_clk_mux(hw);\n\tu32 val;\n\n\tval = clk_mux_index_to_val(NULL, mux->flags, index);\n\tif (mux->flags & MUX_CLK_SW)\n\t\tmux->reg = val;\n\telse\n\t\tlgm_set_clk_val(mux->membase, mux->reg, mux->shift,\n\t\t\t\tmux->width, val);\n\n\treturn 0;\n}\n\nstatic int lgm_clk_mux_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tstruct lgm_clk_mux *mux = to_lgm_clk_mux(hw);\n\n\treturn clk_mux_determine_rate_flags(hw, req, mux->flags);\n}\n\nstatic const struct clk_ops lgm_clk_mux_ops = {\n\t.get_parent = lgm_clk_mux_get_parent,\n\t.set_parent = lgm_clk_mux_set_parent,\n\t.determine_rate = lgm_clk_mux_determine_rate,\n};\n\nstatic struct clk_hw *\nlgm_clk_register_mux(struct lgm_clk_provider *ctx,\n\t\t     const struct lgm_clk_branch *list)\n{\n\tunsigned long cflags = list->mux_flags;\n\tstruct device *dev = ctx->dev;\n\tu8 shift = list->mux_shift;\n\tu8 width = list->mux_width;\n\tstruct clk_init_data init = {};\n\tstruct lgm_clk_mux *mux;\n\tu32 reg = list->mux_off;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tmux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = list->name;\n\tinit.ops = &lgm_clk_mux_ops;\n\tinit.flags = list->flags;\n\tinit.parent_data = list->parent_data;\n\tinit.num_parents = list->num_parents;\n\n\tmux->membase = ctx->membase;\n\tmux->reg = reg;\n\tmux->shift = shift;\n\tmux->width = width;\n\tmux->flags = cflags;\n\tmux->hw.init = &init;\n\n\thw = &mux->hw;\n\tret = devm_clk_hw_register(dev, hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (cflags & CLOCK_FLAG_VAL_INIT)\n\t\tlgm_set_clk_val(mux->membase, reg, shift, width, list->mux_val);\n\n\treturn hw;\n}\n\nstatic unsigned long\nlgm_clk_divider_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct lgm_clk_divider *divider = to_lgm_clk_divider(hw);\n\tunsigned int val;\n\n\tval = lgm_get_clk_val(divider->membase, divider->reg,\n\t\t\t      divider->shift, divider->width);\n\n\treturn divider_recalc_rate(hw, parent_rate, val, divider->table,\n\t\t\t\t   divider->flags, divider->width);\n}\n\nstatic long\nlgm_clk_divider_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t   unsigned long *prate)\n{\n\tstruct lgm_clk_divider *divider = to_lgm_clk_divider(hw);\n\n\treturn divider_round_rate(hw, rate, prate, divider->table,\n\t\t\t\t  divider->width, divider->flags);\n}\n\nstatic int\nlgm_clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t unsigned long prate)\n{\n\tstruct lgm_clk_divider *divider = to_lgm_clk_divider(hw);\n\tint value;\n\n\tvalue = divider_get_val(rate, prate, divider->table,\n\t\t\t\tdivider->width, divider->flags);\n\tif (value < 0)\n\t\treturn value;\n\n\tlgm_set_clk_val(divider->membase, divider->reg,\n\t\t\tdivider->shift, divider->width, value);\n\n\treturn 0;\n}\n\nstatic int lgm_clk_divider_enable_disable(struct clk_hw *hw, int enable)\n{\n\tstruct lgm_clk_divider *div = to_lgm_clk_divider(hw);\n\n\tif (div->flags != DIV_CLK_NO_MASK)\n\t\tlgm_set_clk_val(div->membase, div->reg, div->shift_gate,\n\t\t\t\tdiv->width_gate, enable);\n\treturn 0;\n}\n\nstatic int lgm_clk_divider_enable(struct clk_hw *hw)\n{\n\treturn lgm_clk_divider_enable_disable(hw, 1);\n}\n\nstatic void lgm_clk_divider_disable(struct clk_hw *hw)\n{\n\tlgm_clk_divider_enable_disable(hw, 0);\n}\n\nstatic const struct clk_ops lgm_clk_divider_ops = {\n\t.recalc_rate = lgm_clk_divider_recalc_rate,\n\t.round_rate = lgm_clk_divider_round_rate,\n\t.set_rate = lgm_clk_divider_set_rate,\n\t.enable = lgm_clk_divider_enable,\n\t.disable = lgm_clk_divider_disable,\n};\n\nstatic struct clk_hw *\nlgm_clk_register_divider(struct lgm_clk_provider *ctx,\n\t\t\t const struct lgm_clk_branch *list)\n{\n\tunsigned long cflags = list->div_flags;\n\tstruct device *dev = ctx->dev;\n\tstruct lgm_clk_divider *div;\n\tstruct clk_init_data init = {};\n\tu8 shift = list->div_shift;\n\tu8 width = list->div_width;\n\tu8 shift_gate = list->div_shift_gate;\n\tu8 width_gate = list->div_width_gate;\n\tu32 reg = list->div_off;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tdiv = devm_kzalloc(dev, sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = list->name;\n\tinit.ops = &lgm_clk_divider_ops;\n\tinit.flags = list->flags;\n\tinit.parent_data = list->parent_data;\n\tinit.num_parents = 1;\n\n\tdiv->membase = ctx->membase;\n\tdiv->reg = reg;\n\tdiv->shift = shift;\n\tdiv->width = width;\n\tdiv->shift_gate\t= shift_gate;\n\tdiv->width_gate\t= width_gate;\n\tdiv->flags = cflags;\n\tdiv->table = list->div_table;\n\tdiv->hw.init = &init;\n\n\thw = &div->hw;\n\tret = devm_clk_hw_register(dev, hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (cflags & CLOCK_FLAG_VAL_INIT)\n\t\tlgm_set_clk_val(div->membase, reg, shift, width, list->div_val);\n\n\treturn hw;\n}\n\nstatic struct clk_hw *\nlgm_clk_register_fixed_factor(struct lgm_clk_provider *ctx,\n\t\t\t      const struct lgm_clk_branch *list)\n{\n\tstruct clk_hw *hw;\n\n\thw = clk_hw_register_fixed_factor(ctx->dev, list->name,\n\t\t\t\t\t  list->parent_data[0].name, list->flags,\n\t\t\t\t\t  list->mult, list->div);\n\tif (IS_ERR(hw))\n\t\treturn ERR_CAST(hw);\n\n\tif (list->div_flags & CLOCK_FLAG_VAL_INIT)\n\t\tlgm_set_clk_val(ctx->membase, list->div_off, list->div_shift,\n\t\t\t\tlist->div_width, list->div_val);\n\n\treturn hw;\n}\n\nstatic int lgm_clk_gate_enable(struct clk_hw *hw)\n{\n\tstruct lgm_clk_gate *gate = to_lgm_clk_gate(hw);\n\tunsigned int reg;\n\n\treg = GATE_HW_REG_EN(gate->reg);\n\tlgm_set_clk_val(gate->membase, reg, gate->shift, 1, 1);\n\n\treturn 0;\n}\n\nstatic void lgm_clk_gate_disable(struct clk_hw *hw)\n{\n\tstruct lgm_clk_gate *gate = to_lgm_clk_gate(hw);\n\tunsigned int reg;\n\n\treg = GATE_HW_REG_DIS(gate->reg);\n\tlgm_set_clk_val(gate->membase, reg, gate->shift, 1, 1);\n}\n\nstatic int lgm_clk_gate_is_enabled(struct clk_hw *hw)\n{\n\tstruct lgm_clk_gate *gate = to_lgm_clk_gate(hw);\n\tunsigned int reg, ret;\n\n\treg = GATE_HW_REG_STAT(gate->reg);\n\tret = lgm_get_clk_val(gate->membase, reg, gate->shift, 1);\n\n\treturn ret;\n}\n\nstatic const struct clk_ops lgm_clk_gate_ops = {\n\t.enable = lgm_clk_gate_enable,\n\t.disable = lgm_clk_gate_disable,\n\t.is_enabled = lgm_clk_gate_is_enabled,\n};\n\nstatic struct clk_hw *\nlgm_clk_register_gate(struct lgm_clk_provider *ctx,\n\t\t      const struct lgm_clk_branch *list)\n{\n\tunsigned long cflags = list->gate_flags;\n\tconst char *pname = list->parent_data[0].name;\n\tstruct device *dev = ctx->dev;\n\tu8 shift = list->gate_shift;\n\tstruct clk_init_data init = {};\n\tstruct lgm_clk_gate *gate;\n\tu32 reg = list->gate_off;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tgate = devm_kzalloc(dev, sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = list->name;\n\tinit.ops = &lgm_clk_gate_ops;\n\tinit.flags = list->flags;\n\tinit.parent_names = pname ? &pname : NULL;\n\tinit.num_parents = pname ? 1 : 0;\n\n\tgate->membase = ctx->membase;\n\tgate->reg = reg;\n\tgate->shift = shift;\n\tgate->flags = cflags;\n\tgate->hw.init = &init;\n\n\thw = &gate->hw;\n\tret = devm_clk_hw_register(dev, hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (cflags & CLOCK_FLAG_VAL_INIT) {\n\t\tlgm_set_clk_val(gate->membase, reg, shift, 1, list->gate_val);\n\t}\n\n\treturn hw;\n}\n\nint lgm_clk_register_branches(struct lgm_clk_provider *ctx,\n\t\t\t      const struct lgm_clk_branch *list,\n\t\t\t      unsigned int nr_clk)\n{\n\tstruct clk_hw *hw;\n\tunsigned int idx;\n\n\tfor (idx = 0; idx < nr_clk; idx++, list++) {\n\t\tswitch (list->type) {\n\t\tcase CLK_TYPE_FIXED:\n\t\t\thw = lgm_clk_register_fixed(ctx, list);\n\t\t\tbreak;\n\t\tcase CLK_TYPE_MUX:\n\t\t\thw = lgm_clk_register_mux(ctx, list);\n\t\t\tbreak;\n\t\tcase CLK_TYPE_DIVIDER:\n\t\t\thw = lgm_clk_register_divider(ctx, list);\n\t\t\tbreak;\n\t\tcase CLK_TYPE_FIXED_FACTOR:\n\t\t\thw = lgm_clk_register_fixed_factor(ctx, list);\n\t\t\tbreak;\n\t\tcase CLK_TYPE_GATE:\n\t\t\tif (list->gate_flags & GATE_CLK_HW) {\n\t\t\t\thw = lgm_clk_register_gate(ctx, list);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\thw = NULL;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(ctx->dev, \"invalid clk type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (IS_ERR(hw)) {\n\t\t\tdev_err(ctx->dev,\n\t\t\t\t\"register clk: %s, type: %u failed!\\n\",\n\t\t\t\tlist->name, list->type);\n\t\t\treturn -EIO;\n\t\t}\n\t\tctx->clk_data.hws[list->id] = hw;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long\nlgm_clk_ddiv_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct lgm_clk_ddiv *ddiv = to_lgm_clk_ddiv(hw);\n\tunsigned int div0, div1, exdiv;\n\tu64 prate;\n\n\tdiv0 = lgm_get_clk_val(ddiv->membase, ddiv->reg,\n\t\t\t       ddiv->shift0, ddiv->width0) + 1;\n\tdiv1 = lgm_get_clk_val(ddiv->membase, ddiv->reg,\n\t\t\t       ddiv->shift1, ddiv->width1) + 1;\n\texdiv = lgm_get_clk_val(ddiv->membase, ddiv->reg,\n\t\t\t\tddiv->shift2, ddiv->width2);\n\tprate = (u64)parent_rate;\n\tdo_div(prate, div0);\n\tdo_div(prate, div1);\n\n\tif (exdiv) {\n\t\tdo_div(prate, ddiv->div);\n\t\tprate *= ddiv->mult;\n\t}\n\n\treturn prate;\n}\n\nstatic int lgm_clk_ddiv_enable(struct clk_hw *hw)\n{\n\tstruct lgm_clk_ddiv *ddiv = to_lgm_clk_ddiv(hw);\n\n\tlgm_set_clk_val(ddiv->membase, ddiv->reg, ddiv->shift_gate,\n\t\t\tddiv->width_gate, 1);\n\treturn 0;\n}\n\nstatic void lgm_clk_ddiv_disable(struct clk_hw *hw)\n{\n\tstruct lgm_clk_ddiv *ddiv = to_lgm_clk_ddiv(hw);\n\n\tlgm_set_clk_val(ddiv->membase, ddiv->reg, ddiv->shift_gate,\n\t\t\tddiv->width_gate, 0);\n}\n\nstatic int\nlgm_clk_get_ddiv_val(u32 div, u32 *ddiv1, u32 *ddiv2)\n{\n\tu32 idx, temp;\n\n\t*ddiv1 = 1;\n\t*ddiv2 = 1;\n\n\tif (div > MAX_DIVIDER_VAL)\n\t\tdiv = MAX_DIVIDER_VAL;\n\n\tif (div > 1) {\n\t\tfor (idx = 2; idx <= MAX_DDIV_REG; idx++) {\n\t\t\ttemp = DIV_ROUND_UP_ULL((u64)div, idx);\n\t\t\tif (div % idx == 0 && temp <= MAX_DDIV_REG)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (idx > MAX_DDIV_REG)\n\t\t\treturn -EINVAL;\n\n\t\t*ddiv1 = temp;\n\t\t*ddiv2 = idx;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nlgm_clk_ddiv_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t      unsigned long prate)\n{\n\tstruct lgm_clk_ddiv *ddiv = to_lgm_clk_ddiv(hw);\n\tu32 div, ddiv1, ddiv2;\n\n\tdiv = DIV_ROUND_CLOSEST_ULL((u64)prate, rate);\n\n\tif (lgm_get_clk_val(ddiv->membase, ddiv->reg, ddiv->shift2, 1)) {\n\t\tdiv = DIV_ROUND_CLOSEST_ULL((u64)div, 5);\n\t\tdiv = div * 2;\n\t}\n\n\tif (div <= 0)\n\t\treturn -EINVAL;\n\n\tif (lgm_clk_get_ddiv_val(div, &ddiv1, &ddiv2))\n\t\treturn -EINVAL;\n\n\tlgm_set_clk_val(ddiv->membase, ddiv->reg, ddiv->shift0, ddiv->width0,\n\t\t\tddiv1 - 1);\n\n\tlgm_set_clk_val(ddiv->membase, ddiv->reg,  ddiv->shift1, ddiv->width1,\n\t\t\tddiv2 - 1);\n\n\treturn 0;\n}\n\nstatic long\nlgm_clk_ddiv_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\tunsigned long *prate)\n{\n\tstruct lgm_clk_ddiv *ddiv = to_lgm_clk_ddiv(hw);\n\tu32 div, ddiv1, ddiv2;\n\tu64 rate64;\n\n\tdiv = DIV_ROUND_CLOSEST_ULL((u64)*prate, rate);\n\n\t \n\tif (lgm_get_clk_val(ddiv->membase, ddiv->reg, ddiv->shift2, 1)) {\n\t\tdiv = div * 2;\n\t\tdiv = DIV_ROUND_CLOSEST_ULL((u64)div, 5);\n\t}\n\n\tif (div <= 0)\n\t\treturn *prate;\n\n\tif (lgm_clk_get_ddiv_val(div, &ddiv1, &ddiv2) != 0)\n\t\tif (lgm_clk_get_ddiv_val(div + 1, &ddiv1, &ddiv2) != 0)\n\t\t\treturn -EINVAL;\n\n\trate64 = *prate;\n\tdo_div(rate64, ddiv1);\n\tdo_div(rate64, ddiv2);\n\n\t \n\tif (lgm_get_clk_val(ddiv->membase, ddiv->reg, ddiv->shift2, 1)) {\n\t\trate64 = rate64 * 2;\n\t\trate64 = DIV_ROUND_CLOSEST_ULL(rate64, 5);\n\t}\n\n\treturn rate64;\n}\n\nstatic const struct clk_ops lgm_clk_ddiv_ops = {\n\t.recalc_rate = lgm_clk_ddiv_recalc_rate,\n\t.enable\t= lgm_clk_ddiv_enable,\n\t.disable = lgm_clk_ddiv_disable,\n\t.set_rate = lgm_clk_ddiv_set_rate,\n\t.round_rate = lgm_clk_ddiv_round_rate,\n};\n\nint lgm_clk_register_ddiv(struct lgm_clk_provider *ctx,\n\t\t\t  const struct lgm_clk_ddiv_data *list,\n\t\t\t  unsigned int nr_clk)\n{\n\tstruct device *dev = ctx->dev;\n\tstruct clk_hw *hw;\n\tunsigned int idx;\n\tint ret;\n\n\tfor (idx = 0; idx < nr_clk; idx++, list++) {\n\t\tstruct clk_init_data init = {};\n\t\tstruct lgm_clk_ddiv *ddiv;\n\n\t\tddiv = devm_kzalloc(dev, sizeof(*ddiv), GFP_KERNEL);\n\t\tif (!ddiv)\n\t\t\treturn -ENOMEM;\n\n\t\tinit.name = list->name;\n\t\tinit.ops = &lgm_clk_ddiv_ops;\n\t\tinit.flags = list->flags;\n\t\tinit.parent_data = list->parent_data;\n\t\tinit.num_parents = 1;\n\n\t\tddiv->membase = ctx->membase;\n\t\tddiv->reg = list->reg;\n\t\tddiv->shift0 = list->shift0;\n\t\tddiv->width0 = list->width0;\n\t\tddiv->shift1 = list->shift1;\n\t\tddiv->width1 = list->width1;\n\t\tddiv->shift_gate = list->shift_gate;\n\t\tddiv->width_gate = list->width_gate;\n\t\tddiv->shift2 = list->ex_shift;\n\t\tddiv->width2 = list->ex_width;\n\t\tddiv->flags = list->div_flags;\n\t\tddiv->mult = 2;\n\t\tddiv->div = 5;\n\t\tddiv->hw.init = &init;\n\n\t\thw = &ddiv->hw;\n\t\tret = devm_clk_hw_register(dev, hw);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"register clk: %s failed!\\n\", list->name);\n\t\t\treturn ret;\n\t\t}\n\t\tctx->clk_data.hws[list->id] = hw;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}