{
  "module_name": "clk-pmc-atom.c",
  "hash_id": "77ef280a433dc1d89f1b3e047ac380e8423c222d6815a7842e9726a25803e31a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/x86/clk-pmc-atom.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/platform_data/x86/clk-pmc-atom.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define PLT_CLK_NAME_BASE\t\"pmc_plt_clk\"\n\n#define PMC_CLK_CTL_OFFSET\t\t0x60\n#define PMC_CLK_CTL_SIZE\t\t4\n#define PMC_CLK_NUM\t\t\t6\n#define PMC_CLK_CTL_GATED_ON_D3\t\t0x0\n#define PMC_CLK_CTL_FORCE_ON\t\t0x1\n#define PMC_CLK_CTL_FORCE_OFF\t\t0x2\n#define PMC_CLK_CTL_RESERVED\t\t0x3\n#define PMC_MASK_CLK_CTL\t\tGENMASK(1, 0)\n#define PMC_MASK_CLK_FREQ\t\tBIT(2)\n#define PMC_CLK_FREQ_XTAL\t\t(0 << 2)\t \n#define PMC_CLK_FREQ_PLL\t\t(1 << 2)\t \n\nstruct clk_plt_fixed {\n\tstruct clk_hw *clk;\n\tstruct clk_lookup *lookup;\n};\n\nstruct clk_plt {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n\tstruct clk_lookup *lookup;\n\t \n\tspinlock_t lock;\n};\n\n#define to_clk_plt(_hw) container_of(_hw, struct clk_plt, hw)\n\nstruct clk_plt_data {\n\tstruct clk_plt_fixed **parents;\n\tu8 nparents;\n\tstruct clk_plt *clks[PMC_CLK_NUM];\n\tstruct clk_lookup *mclk_lookup;\n\tstruct clk_lookup *ether_clk_lookup;\n};\n\n \nstatic inline int plt_reg_to_parent(int reg)\n{\n\tswitch (reg & PMC_MASK_CLK_FREQ) {\n\tdefault:\n\tcase PMC_CLK_FREQ_XTAL:\n\t\treturn 0;\n\tcase PMC_CLK_FREQ_PLL:\n\t\treturn 1;\n\t}\n}\n\n \nstatic inline int plt_parent_to_reg(int index)\n{\n\tswitch (index) {\n\tdefault:\n\tcase 0:\n\t\treturn PMC_CLK_FREQ_XTAL;\n\tcase 1:\n\t\treturn PMC_CLK_FREQ_PLL;\n\t}\n}\n\n \nstatic inline int plt_reg_to_enabled(int reg)\n{\n\tswitch (reg & PMC_MASK_CLK_CTL) {\n\tcase PMC_CLK_CTL_GATED_ON_D3:\n\tcase PMC_CLK_CTL_FORCE_ON:\n\t\treturn 1;\t \n\tcase PMC_CLK_CTL_FORCE_OFF:\n\tcase PMC_CLK_CTL_RESERVED:\n\tdefault:\n\t\treturn 0;\t \n\t}\n}\n\nstatic void plt_clk_reg_update(struct clk_plt *clk, u32 mask, u32 val)\n{\n\tu32 tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&clk->lock, flags);\n\n\ttmp = readl(clk->reg);\n\ttmp = (tmp & ~mask) | (val & mask);\n\twritel(tmp, clk->reg);\n\n\tspin_unlock_irqrestore(&clk->lock, flags);\n}\n\nstatic int plt_clk_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_plt *clk = to_clk_plt(hw);\n\n\tplt_clk_reg_update(clk, PMC_MASK_CLK_FREQ, plt_parent_to_reg(index));\n\n\treturn 0;\n}\n\nstatic u8 plt_clk_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_plt *clk = to_clk_plt(hw);\n\tu32 value;\n\n\tvalue = readl(clk->reg);\n\n\treturn plt_reg_to_parent(value);\n}\n\nstatic int plt_clk_enable(struct clk_hw *hw)\n{\n\tstruct clk_plt *clk = to_clk_plt(hw);\n\n\tplt_clk_reg_update(clk, PMC_MASK_CLK_CTL, PMC_CLK_CTL_FORCE_ON);\n\n\treturn 0;\n}\n\nstatic void plt_clk_disable(struct clk_hw *hw)\n{\n\tstruct clk_plt *clk = to_clk_plt(hw);\n\n\tplt_clk_reg_update(clk, PMC_MASK_CLK_CTL, PMC_CLK_CTL_FORCE_OFF);\n}\n\nstatic int plt_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_plt *clk = to_clk_plt(hw);\n\tu32 value;\n\n\tvalue = readl(clk->reg);\n\n\treturn plt_reg_to_enabled(value);\n}\n\nstatic const struct clk_ops plt_clk_ops = {\n\t.enable = plt_clk_enable,\n\t.disable = plt_clk_disable,\n\t.is_enabled = plt_clk_is_enabled,\n\t.get_parent = plt_clk_get_parent,\n\t.set_parent = plt_clk_set_parent,\n\t.determine_rate = __clk_mux_determine_rate,\n};\n\nstatic struct clk_plt *plt_clk_register(struct platform_device *pdev, int id,\n\t\t\t\t\tconst struct pmc_clk_data *pmc_data,\n\t\t\t\t\tconst char **parent_names,\n\t\t\t\t\tint num_parents)\n{\n\tstruct clk_plt *pclk;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tpclk = devm_kzalloc(&pdev->dev, sizeof(*pclk), GFP_KERNEL);\n\tif (!pclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name =  kasprintf(GFP_KERNEL, \"%s_%d\", PLT_CLK_NAME_BASE, id);\n\tinit.ops = &plt_clk_ops;\n\tinit.flags = 0;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\n\tpclk->hw.init = &init;\n\tpclk->reg = pmc_data->base + PMC_CLK_CTL_OFFSET + id * PMC_CLK_CTL_SIZE;\n\tspin_lock_init(&pclk->lock);\n\n\t \n\tif (pmc_data->critical && plt_clk_is_enabled(&pclk->hw))\n\t\tinit.flags |= CLK_IS_CRITICAL;\n\n\tret = devm_clk_hw_register(&pdev->dev, &pclk->hw);\n\tif (ret) {\n\t\tpclk = ERR_PTR(ret);\n\t\tgoto err_free_init;\n\t}\n\n\tpclk->lookup = clkdev_hw_create(&pclk->hw, init.name, NULL);\n\tif (!pclk->lookup) {\n\t\tpclk = ERR_PTR(-ENOMEM);\n\t\tgoto err_free_init;\n\t}\n\nerr_free_init:\n\tkfree(init.name);\n\treturn pclk;\n}\n\nstatic void plt_clk_unregister(struct clk_plt *pclk)\n{\n\tclkdev_drop(pclk->lookup);\n}\n\nstatic struct clk_plt_fixed *plt_clk_register_fixed_rate(struct platform_device *pdev,\n\t\t\t\t\t\t const char *name,\n\t\t\t\t\t\t const char *parent_name,\n\t\t\t\t\t\t unsigned long fixed_rate)\n{\n\tstruct clk_plt_fixed *pclk;\n\n\tpclk = devm_kzalloc(&pdev->dev, sizeof(*pclk), GFP_KERNEL);\n\tif (!pclk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpclk->clk = clk_hw_register_fixed_rate(&pdev->dev, name, parent_name,\n\t\t\t\t\t       0, fixed_rate);\n\tif (IS_ERR(pclk->clk))\n\t\treturn ERR_CAST(pclk->clk);\n\n\tpclk->lookup = clkdev_hw_create(pclk->clk, name, NULL);\n\tif (!pclk->lookup) {\n\t\tclk_hw_unregister_fixed_rate(pclk->clk);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn pclk;\n}\n\nstatic void plt_clk_unregister_fixed_rate(struct clk_plt_fixed *pclk)\n{\n\tclkdev_drop(pclk->lookup);\n\tclk_hw_unregister_fixed_rate(pclk->clk);\n}\n\nstatic void plt_clk_unregister_fixed_rate_loop(struct clk_plt_data *data,\n\t\t\t\t\t       unsigned int i)\n{\n\twhile (i--)\n\t\tplt_clk_unregister_fixed_rate(data->parents[i]);\n}\n\nstatic void plt_clk_free_parent_names_loop(const char **parent_names,\n\t\t\t\t\t   unsigned int i)\n{\n\twhile (i--)\n\t\tkfree_const(parent_names[i]);\n\tkfree(parent_names);\n}\n\nstatic void plt_clk_unregister_loop(struct clk_plt_data *data,\n\t\t\t\t    unsigned int i)\n{\n\twhile (i--)\n\t\tplt_clk_unregister(data->clks[i]);\n}\n\nstatic const char **plt_clk_register_parents(struct platform_device *pdev,\n\t\t\t\t\t     struct clk_plt_data *data,\n\t\t\t\t\t     const struct pmc_clk *clks)\n{\n\tconst char **parent_names;\n\tunsigned int i;\n\tint err;\n\tint nparents = 0;\n\n\tdata->nparents = 0;\n\twhile (clks[nparents].name)\n\t\tnparents++;\n\n\tdata->parents = devm_kcalloc(&pdev->dev, nparents,\n\t\t\t\t     sizeof(*data->parents), GFP_KERNEL);\n\tif (!data->parents)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tparent_names = kcalloc(nparents, sizeof(*parent_names),\n\t\t\t       GFP_KERNEL);\n\tif (!parent_names)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < nparents; i++) {\n\t\tdata->parents[i] =\n\t\t\tplt_clk_register_fixed_rate(pdev, clks[i].name,\n\t\t\t\t\t\t    clks[i].parent_name,\n\t\t\t\t\t\t    clks[i].freq);\n\t\tif (IS_ERR(data->parents[i])) {\n\t\t\terr = PTR_ERR(data->parents[i]);\n\t\t\tgoto err_unreg;\n\t\t}\n\t\tparent_names[i] = kstrdup_const(clks[i].name, GFP_KERNEL);\n\t}\n\n\tdata->nparents = nparents;\n\treturn parent_names;\n\nerr_unreg:\n\tplt_clk_unregister_fixed_rate_loop(data, i);\n\tplt_clk_free_parent_names_loop(parent_names, i);\n\treturn ERR_PTR(err);\n}\n\nstatic void plt_clk_unregister_parents(struct clk_plt_data *data)\n{\n\tplt_clk_unregister_fixed_rate_loop(data, data->nparents);\n}\n\nstatic int plt_clk_probe(struct platform_device *pdev)\n{\n\tconst struct pmc_clk_data *pmc_data;\n\tconst char **parent_names;\n\tstruct clk_plt_data *data;\n\tunsigned int i;\n\tint err;\n\n\tpmc_data = dev_get_platdata(&pdev->dev);\n\tif (!pmc_data || !pmc_data->clks)\n\t\treturn -EINVAL;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tparent_names = plt_clk_register_parents(pdev, data, pmc_data->clks);\n\tif (IS_ERR(parent_names))\n\t\treturn PTR_ERR(parent_names);\n\n\tfor (i = 0; i < PMC_CLK_NUM; i++) {\n\t\tdata->clks[i] = plt_clk_register(pdev, i, pmc_data,\n\t\t\t\t\t\t parent_names, data->nparents);\n\t\tif (IS_ERR(data->clks[i])) {\n\t\t\terr = PTR_ERR(data->clks[i]);\n\t\t\tgoto err_unreg_clk_plt;\n\t\t}\n\t}\n\tdata->mclk_lookup = clkdev_hw_create(&data->clks[3]->hw, \"mclk\", NULL);\n\tif (!data->mclk_lookup) {\n\t\terr = -ENOMEM;\n\t\tgoto err_unreg_clk_plt;\n\t}\n\n\tdata->ether_clk_lookup = clkdev_hw_create(&data->clks[4]->hw,\n\t\t\t\t\t\t  \"ether_clk\", NULL);\n\tif (!data->ether_clk_lookup) {\n\t\terr = -ENOMEM;\n\t\tgoto err_drop_mclk;\n\t}\n\n\tplt_clk_free_parent_names_loop(parent_names, data->nparents);\n\n\tplatform_set_drvdata(pdev, data);\n\treturn 0;\n\nerr_drop_mclk:\n\tclkdev_drop(data->mclk_lookup);\nerr_unreg_clk_plt:\n\tplt_clk_unregister_loop(data, i);\n\tplt_clk_unregister_parents(data);\n\tplt_clk_free_parent_names_loop(parent_names, data->nparents);\n\treturn err;\n}\n\nstatic void plt_clk_remove(struct platform_device *pdev)\n{\n\tstruct clk_plt_data *data;\n\n\tdata = platform_get_drvdata(pdev);\n\n\tclkdev_drop(data->ether_clk_lookup);\n\tclkdev_drop(data->mclk_lookup);\n\tplt_clk_unregister_loop(data, PMC_CLK_NUM);\n\tplt_clk_unregister_parents(data);\n}\n\nstatic struct platform_driver plt_clk_driver = {\n\t.driver = {\n\t\t.name = \"clk-pmc-atom\",\n\t},\n\t.probe = plt_clk_probe,\n\t.remove_new = plt_clk_remove,\n};\nbuiltin_platform_driver(plt_clk_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}