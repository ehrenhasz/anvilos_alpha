{
  "module_name": "clk-fch.c",
  "hash_id": "6810d16721bc70a0a52d1a2fec3a91d17706df74fcc57a64fe46118c59e7b4da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/x86/clk-fch.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/pci.h>\n#include <linux/platform_data/clk-fch.h>\n#include <linux/platform_device.h>\n\n \n#define CLKDRVSTR2\t0x28\n \n#define MISCCLKCNTL1\t0x40\n \n#define OSCCLKENB\t2\n \n#define OSCOUT1CLK25MHZ\t16\n\n#define ST_CLK_48M\t0\n#define ST_CLK_25M\t1\n#define ST_CLK_MUX\t2\n#define ST_CLK_GATE\t3\n#define ST_MAX_CLKS\t4\n\n#define CLK_48M_FIXED\t0\n#define CLK_GATE_FIXED\t1\n#define CLK_MAX_FIXED\t2\n\n \n#define AMD_CPU_ID_ST                  0x1576\n\nstatic const char * const clk_oscout1_parents[] = { \"clk48MHz\", \"clk25MHz\" };\nstatic struct clk_hw *hws[ST_MAX_CLKS];\n\nstatic const struct pci_device_id fch_pci_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_ST) },\n\t{ }\n};\n\nstatic int fch_clk_probe(struct platform_device *pdev)\n{\n\tstruct fch_clk_data *fch_data;\n\tstruct pci_dev *rdev;\n\n\tfch_data = dev_get_platdata(&pdev->dev);\n\tif (!fch_data || !fch_data->base)\n\t\treturn -EINVAL;\n\n\trdev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(0, 0));\n\tif (!rdev) {\n\t\tdev_err(&pdev->dev, \"FCH device not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pci_match_id(fch_pci_ids, rdev)) {\n\t\thws[ST_CLK_48M] = clk_hw_register_fixed_rate(NULL, \"clk48MHz\",\n\t\t\tNULL, 0, 48000000);\n\t\thws[ST_CLK_25M] = clk_hw_register_fixed_rate(NULL, \"clk25MHz\",\n\t\t\tNULL, 0, 25000000);\n\n\t\thws[ST_CLK_MUX] = clk_hw_register_mux(NULL, \"oscout1_mux\",\n\t\t\tclk_oscout1_parents, ARRAY_SIZE(clk_oscout1_parents),\n\t\t\t0, fch_data->base + CLKDRVSTR2, OSCOUT1CLK25MHZ, 3, 0,\n\t\t\tNULL);\n\n\t\tclk_set_parent(hws[ST_CLK_MUX]->clk, hws[ST_CLK_48M]->clk);\n\n\t\thws[ST_CLK_GATE] = clk_hw_register_gate(NULL, \"oscout1\",\n\t\t\t\"oscout1_mux\", 0, fch_data->base + MISCCLKCNTL1,\n\t\t\tOSCCLKENB, CLK_GATE_SET_TO_DISABLE, NULL);\n\n\t\tdevm_clk_hw_register_clkdev(&pdev->dev, hws[ST_CLK_GATE],\n\t\t\t\t\t    fch_data->name, NULL);\n\t} else {\n\t\thws[CLK_48M_FIXED] = clk_hw_register_fixed_rate(NULL, \"clk48MHz\",\n\t\t\tNULL, 0, 48000000);\n\n\t\thws[CLK_GATE_FIXED] = clk_hw_register_gate(NULL, \"oscout1\",\n\t\t\t\"clk48MHz\", 0, fch_data->base + MISCCLKCNTL1,\n\t\t\tOSCCLKENB, 0, NULL);\n\n\t\tdevm_clk_hw_register_clkdev(&pdev->dev, hws[CLK_GATE_FIXED],\n\t\t\t\t\t    fch_data->name, NULL);\n\t}\n\n\tpci_dev_put(rdev);\n\treturn 0;\n}\n\nstatic void fch_clk_remove(struct platform_device *pdev)\n{\n\tint i, clks;\n\tstruct pci_dev *rdev;\n\n\trdev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(0, 0));\n\tif (!rdev)\n\t\treturn;\n\n\tclks = pci_match_id(fch_pci_ids, rdev) ? CLK_MAX_FIXED : ST_MAX_CLKS;\n\n\tfor (i = 0; i < clks; i++)\n\t\tclk_hw_unregister(hws[i]);\n\n\tpci_dev_put(rdev);\n}\n\nstatic struct platform_driver fch_clk_driver = {\n\t.driver = {\n\t\t.name = \"clk-fch\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = fch_clk_probe,\n\t.remove_new = fch_clk_remove,\n};\nbuiltin_platform_driver(fch_clk_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}