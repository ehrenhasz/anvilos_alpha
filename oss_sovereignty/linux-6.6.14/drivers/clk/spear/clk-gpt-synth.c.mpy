{
  "module_name": "clk-gpt-synth.c",
  "hash_id": "420ff3d428710fe32d7a051ccffa4f6830e87ff7027f86a629ad2bfd641e7a3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/spear/clk-gpt-synth.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"clk-gpt-synth: \" fmt\n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include \"clk.h\"\n\n#define GPT_MSCALE_MASK\t\t0xFFF\n#define GPT_NSCALE_SHIFT\t12\n#define GPT_NSCALE_MASK\t\t0xF\n\n \n\n#define to_clk_gpt(_hw) container_of(_hw, struct clk_gpt, hw)\n\nstatic unsigned long gpt_calc_rate(struct clk_hw *hw, unsigned long prate,\n\t\tint index)\n{\n\tstruct clk_gpt *gpt = to_clk_gpt(hw);\n\tstruct gpt_rate_tbl *rtbl = gpt->rtbl;\n\n\tprate /= ((1 << (rtbl[index].nscale + 1)) * (rtbl[index].mscale + 1));\n\n\treturn prate;\n}\n\nstatic long clk_gpt_round_rate(struct clk_hw *hw, unsigned long drate,\n\t\tunsigned long *prate)\n{\n\tstruct clk_gpt *gpt = to_clk_gpt(hw);\n\tint unused;\n\n\treturn clk_round_rate_index(hw, drate, *prate, gpt_calc_rate,\n\t\t\tgpt->rtbl_cnt, &unused);\n}\n\nstatic unsigned long clk_gpt_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_gpt *gpt = to_clk_gpt(hw);\n\tunsigned long flags = 0;\n\tunsigned int div = 1, val;\n\n\tif (gpt->lock)\n\t\tspin_lock_irqsave(gpt->lock, flags);\n\n\tval = readl_relaxed(gpt->reg);\n\n\tif (gpt->lock)\n\t\tspin_unlock_irqrestore(gpt->lock, flags);\n\n\tdiv += val & GPT_MSCALE_MASK;\n\tdiv *= 1 << (((val >> GPT_NSCALE_SHIFT) & GPT_NSCALE_MASK) + 1);\n\n\tif (!div)\n\t\treturn 0;\n\n\treturn parent_rate / div;\n}\n\n \nstatic int clk_gpt_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\tunsigned long prate)\n{\n\tstruct clk_gpt *gpt = to_clk_gpt(hw);\n\tstruct gpt_rate_tbl *rtbl = gpt->rtbl;\n\tunsigned long flags = 0, val;\n\tint i;\n\n\tclk_round_rate_index(hw, drate, prate, gpt_calc_rate, gpt->rtbl_cnt,\n\t\t\t&i);\n\n\tif (gpt->lock)\n\t\tspin_lock_irqsave(gpt->lock, flags);\n\n\tval = readl(gpt->reg) & ~GPT_MSCALE_MASK;\n\tval &= ~(GPT_NSCALE_MASK << GPT_NSCALE_SHIFT);\n\n\tval |= rtbl[i].mscale & GPT_MSCALE_MASK;\n\tval |= (rtbl[i].nscale & GPT_NSCALE_MASK) << GPT_NSCALE_SHIFT;\n\n\twritel_relaxed(val, gpt->reg);\n\n\tif (gpt->lock)\n\t\tspin_unlock_irqrestore(gpt->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_gpt_ops = {\n\t.recalc_rate = clk_gpt_recalc_rate,\n\t.round_rate = clk_gpt_round_rate,\n\t.set_rate = clk_gpt_set_rate,\n};\n\nstruct clk *clk_register_gpt(const char *name, const char *parent_name, unsigned\n\t\tlong flags, void __iomem *reg, struct gpt_rate_tbl *rtbl, u8\n\t\trtbl_cnt, spinlock_t *lock)\n{\n\tstruct clk_init_data init;\n\tstruct clk_gpt *gpt;\n\tstruct clk *clk;\n\n\tif (!name || !parent_name || !reg || !rtbl || !rtbl_cnt) {\n\t\tpr_err(\"Invalid arguments passed\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tgpt = kzalloc(sizeof(*gpt), GFP_KERNEL);\n\tif (!gpt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tgpt->reg = reg;\n\tgpt->rtbl = rtbl;\n\tgpt->rtbl_cnt = rtbl_cnt;\n\tgpt->lock = lock;\n\tgpt->hw.init = &init;\n\n\tinit.name = name;\n\tinit.ops = &clk_gpt_ops;\n\tinit.flags = flags;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tclk = clk_register(NULL, &gpt->hw);\n\tif (!IS_ERR_OR_NULL(clk))\n\t\treturn clk;\n\n\tpr_err(\"clk register failed\\n\");\n\tkfree(gpt);\n\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}