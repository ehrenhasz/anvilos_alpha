{
  "module_name": "clk-aux-synth.c",
  "hash_id": "3d6cc4e0f0ef91dae4e8791cb80f47865abad71990710e6f6c690fa11fe94455",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/spear/clk-aux-synth.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"clk-aux-synth: \" fmt\n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include \"clk.h\"\n\n \n\n#define to_clk_aux(_hw) container_of(_hw, struct clk_aux, hw)\n\nstatic const  struct aux_clk_masks default_aux_masks = {\n\t.eq_sel_mask = AUX_EQ_SEL_MASK,\n\t.eq_sel_shift = AUX_EQ_SEL_SHIFT,\n\t.eq1_mask = AUX_EQ1_SEL,\n\t.eq2_mask = AUX_EQ2_SEL,\n\t.xscale_sel_mask = AUX_XSCALE_MASK,\n\t.xscale_sel_shift = AUX_XSCALE_SHIFT,\n\t.yscale_sel_mask = AUX_YSCALE_MASK,\n\t.yscale_sel_shift = AUX_YSCALE_SHIFT,\n\t.enable_bit = AUX_SYNT_ENB,\n};\n\nstatic unsigned long aux_calc_rate(struct clk_hw *hw, unsigned long prate,\n\t\tint index)\n{\n\tstruct clk_aux *aux = to_clk_aux(hw);\n\tstruct aux_rate_tbl *rtbl = aux->rtbl;\n\tu8 eq = rtbl[index].eq ? 1 : 2;\n\n\treturn (((prate / 10000) * rtbl[index].xscale) /\n\t\t\t(rtbl[index].yscale * eq)) * 10000;\n}\n\nstatic long clk_aux_round_rate(struct clk_hw *hw, unsigned long drate,\n\t\tunsigned long *prate)\n{\n\tstruct clk_aux *aux = to_clk_aux(hw);\n\tint unused;\n\n\treturn clk_round_rate_index(hw, drate, *prate, aux_calc_rate,\n\t\t\taux->rtbl_cnt, &unused);\n}\n\nstatic unsigned long clk_aux_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_aux *aux = to_clk_aux(hw);\n\tunsigned int num = 1, den = 1, val, eqn;\n\tunsigned long flags = 0;\n\n\tif (aux->lock)\n\t\tspin_lock_irqsave(aux->lock, flags);\n\n\tval = readl_relaxed(aux->reg);\n\n\tif (aux->lock)\n\t\tspin_unlock_irqrestore(aux->lock, flags);\n\n\teqn = (val >> aux->masks->eq_sel_shift) & aux->masks->eq_sel_mask;\n\tif (eqn == aux->masks->eq1_mask)\n\t\tden = 2;\n\n\t \n\tnum = (val >> aux->masks->xscale_sel_shift) &\n\t\taux->masks->xscale_sel_mask;\n\n\t \n\tden *= (val >> aux->masks->yscale_sel_shift) &\n\t\taux->masks->yscale_sel_mask;\n\n\tif (!den)\n\t\treturn 0;\n\n\treturn (((parent_rate / 10000) * num) / den) * 10000;\n}\n\n \nstatic int clk_aux_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\tunsigned long prate)\n{\n\tstruct clk_aux *aux = to_clk_aux(hw);\n\tstruct aux_rate_tbl *rtbl = aux->rtbl;\n\tunsigned long val, flags = 0;\n\tint i;\n\n\tclk_round_rate_index(hw, drate, prate, aux_calc_rate, aux->rtbl_cnt,\n\t\t\t&i);\n\n\tif (aux->lock)\n\t\tspin_lock_irqsave(aux->lock, flags);\n\n\tval = readl_relaxed(aux->reg) &\n\t\t~(aux->masks->eq_sel_mask << aux->masks->eq_sel_shift);\n\tval |= (rtbl[i].eq & aux->masks->eq_sel_mask) <<\n\t\taux->masks->eq_sel_shift;\n\tval &= ~(aux->masks->xscale_sel_mask << aux->masks->xscale_sel_shift);\n\tval |= (rtbl[i].xscale & aux->masks->xscale_sel_mask) <<\n\t\taux->masks->xscale_sel_shift;\n\tval &= ~(aux->masks->yscale_sel_mask << aux->masks->yscale_sel_shift);\n\tval |= (rtbl[i].yscale & aux->masks->yscale_sel_mask) <<\n\t\taux->masks->yscale_sel_shift;\n\twritel_relaxed(val, aux->reg);\n\n\tif (aux->lock)\n\t\tspin_unlock_irqrestore(aux->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_aux_ops = {\n\t.recalc_rate = clk_aux_recalc_rate,\n\t.round_rate = clk_aux_round_rate,\n\t.set_rate = clk_aux_set_rate,\n};\n\nstruct clk *clk_register_aux(const char *aux_name, const char *gate_name,\n\t\tconst char *parent_name, unsigned long flags, void __iomem *reg,\n\t        const struct aux_clk_masks *masks, struct aux_rate_tbl *rtbl,\n\t\tu8 rtbl_cnt, spinlock_t *lock, struct clk **gate_clk)\n{\n\tstruct clk_aux *aux;\n\tstruct clk_init_data init;\n\tstruct clk *clk;\n\n\tif (!aux_name || !parent_name || !reg || !rtbl || !rtbl_cnt) {\n\t\tpr_err(\"Invalid arguments passed\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\taux = kzalloc(sizeof(*aux), GFP_KERNEL);\n\tif (!aux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tif (!masks)\n\t\taux->masks = &default_aux_masks;\n\telse\n\t\taux->masks = masks;\n\n\taux->reg = reg;\n\taux->rtbl = rtbl;\n\taux->rtbl_cnt = rtbl_cnt;\n\taux->lock = lock;\n\taux->hw.init = &init;\n\n\tinit.name = aux_name;\n\tinit.ops = &clk_aux_ops;\n\tinit.flags = flags;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tclk = clk_register(NULL, &aux->hw);\n\tif (IS_ERR_OR_NULL(clk))\n\t\tgoto free_aux;\n\n\tif (gate_name) {\n\t\tstruct clk *tgate_clk;\n\n\t\ttgate_clk = clk_register_gate(NULL, gate_name, aux_name,\n\t\t\t\tCLK_SET_RATE_PARENT, reg,\n\t\t\t\taux->masks->enable_bit, 0, lock);\n\t\tif (IS_ERR_OR_NULL(tgate_clk))\n\t\t\tgoto free_aux;\n\n\t\tif (gate_clk)\n\t\t\t*gate_clk = tgate_clk;\n\t}\n\n\treturn clk;\n\nfree_aux:\n\tkfree(aux);\n\tpr_err(\"clk register failed\\n\");\n\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}