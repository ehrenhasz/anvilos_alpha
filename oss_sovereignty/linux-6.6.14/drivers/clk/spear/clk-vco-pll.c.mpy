{
  "module_name": "clk-vco-pll.c",
  "hash_id": "2b53365294b215d797f44a1cc9db090e81b1279654c63d5af21f5a701686c0f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/spear/clk-vco-pll.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"clk-vco-pll: \" fmt\n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include \"clk.h\"\n\n \n\n \n#define PLL_MODE_NORMAL\t\t0\n#define PLL_MODE_FRACTION\t1\n#define PLL_MODE_DITH_DSM\t2\n#define PLL_MODE_DITH_SSM\t3\n#define PLL_MODE_MASK\t\t3\n#define PLL_MODE_SHIFT\t\t3\n#define PLL_ENABLE\t\t2\n\n#define PLL_LOCK_SHIFT\t\t0\n#define PLL_LOCK_MASK\t\t1\n\n \n#define PLL_NORM_FDBK_M_MASK\t0xFF\n#define PLL_NORM_FDBK_M_SHIFT\t24\n#define PLL_DITH_FDBK_M_MASK\t0xFFFF\n#define PLL_DITH_FDBK_M_SHIFT\t16\n#define PLL_DIV_P_MASK\t\t0x7\n#define PLL_DIV_P_SHIFT\t\t8\n#define PLL_DIV_N_MASK\t\t0xFF\n#define PLL_DIV_N_SHIFT\t\t0\n\n#define to_clk_vco(_hw) container_of(_hw, struct clk_vco, hw)\n#define to_clk_pll(_hw) container_of(_hw, struct clk_pll, hw)\n\n \nstatic unsigned long pll_calc_rate(struct pll_rate_tbl *rtbl,\n\t\tunsigned long prate, int index, unsigned long *pll_rate)\n{\n\tunsigned long rate = prate;\n\tunsigned int mode;\n\n\tmode = rtbl[index].mode ? 256 : 1;\n\trate = (((2 * rate / 10000) * rtbl[index].m) / (mode * rtbl[index].n));\n\n\tif (pll_rate)\n\t\t*pll_rate = (rate / (1 << rtbl[index].p)) * 10000;\n\n\treturn rate * 10000;\n}\n\nstatic long clk_pll_round_rate_index(struct clk_hw *hw, unsigned long drate,\n\t\t\t\tunsigned long *prate, int *index)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tunsigned long prev_rate, vco_prev_rate, rate = 0;\n\tunsigned long vco_parent_rate =\n\t\tclk_hw_get_rate(clk_hw_get_parent(clk_hw_get_parent(hw)));\n\n\tif (!prate) {\n\t\tpr_err(\"%s: prate is must for pll clk\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (*index = 0; *index < pll->vco->rtbl_cnt; (*index)++) {\n\t\tprev_rate = rate;\n\t\tvco_prev_rate = *prate;\n\t\t*prate = pll_calc_rate(pll->vco->rtbl, vco_parent_rate, *index,\n\t\t\t\t&rate);\n\t\tif (drate < rate) {\n\t\t\t \n\t\t\tif (*index) {\n\t\t\t\trate = prev_rate;\n\t\t\t\t*prate = vco_prev_rate;\n\t\t\t\t(*index)--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rate;\n}\n\nstatic long clk_pll_round_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\tunsigned long *prate)\n{\n\tint unused;\n\n\treturn clk_pll_round_rate_index(hw, drate, prate, &unused);\n}\n\nstatic unsigned long clk_pll_recalc_rate(struct clk_hw *hw, unsigned long\n\t\tparent_rate)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tunsigned long flags = 0;\n\tunsigned int p;\n\n\tif (pll->vco->lock)\n\t\tspin_lock_irqsave(pll->vco->lock, flags);\n\n\tp = readl_relaxed(pll->vco->cfg_reg);\n\n\tif (pll->vco->lock)\n\t\tspin_unlock_irqrestore(pll->vco->lock, flags);\n\n\tp = (p >> PLL_DIV_P_SHIFT) & PLL_DIV_P_MASK;\n\n\treturn parent_rate / (1 << p);\n}\n\nstatic int clk_pll_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\tunsigned long prate)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tstruct pll_rate_tbl *rtbl = pll->vco->rtbl;\n\tunsigned long flags = 0, val;\n\tint i = 0;\n\n\tclk_pll_round_rate_index(hw, drate, NULL, &i);\n\n\tif (pll->vco->lock)\n\t\tspin_lock_irqsave(pll->vco->lock, flags);\n\n\tval = readl_relaxed(pll->vco->cfg_reg);\n\tval &= ~(PLL_DIV_P_MASK << PLL_DIV_P_SHIFT);\n\tval |= (rtbl[i].p & PLL_DIV_P_MASK) << PLL_DIV_P_SHIFT;\n\twritel_relaxed(val, pll->vco->cfg_reg);\n\n\tif (pll->vco->lock)\n\t\tspin_unlock_irqrestore(pll->vco->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_pll_ops = {\n\t.recalc_rate = clk_pll_recalc_rate,\n\t.round_rate = clk_pll_round_rate,\n\t.set_rate = clk_pll_set_rate,\n};\n\nstatic inline unsigned long vco_calc_rate(struct clk_hw *hw,\n\t\tunsigned long prate, int index)\n{\n\tstruct clk_vco *vco = to_clk_vco(hw);\n\n\treturn pll_calc_rate(vco->rtbl, prate, index, NULL);\n}\n\nstatic long clk_vco_round_rate(struct clk_hw *hw, unsigned long drate,\n\t\tunsigned long *prate)\n{\n\tstruct clk_vco *vco = to_clk_vco(hw);\n\tint unused;\n\n\treturn clk_round_rate_index(hw, drate, *prate, vco_calc_rate,\n\t\t\tvco->rtbl_cnt, &unused);\n}\n\nstatic unsigned long clk_vco_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_vco *vco = to_clk_vco(hw);\n\tunsigned long flags = 0;\n\tunsigned int num = 2, den = 0, val, mode = 0;\n\n\tif (vco->lock)\n\t\tspin_lock_irqsave(vco->lock, flags);\n\n\tmode = (readl_relaxed(vco->mode_reg) >> PLL_MODE_SHIFT) & PLL_MODE_MASK;\n\n\tval = readl_relaxed(vco->cfg_reg);\n\n\tif (vco->lock)\n\t\tspin_unlock_irqrestore(vco->lock, flags);\n\n\tden = (val >> PLL_DIV_N_SHIFT) & PLL_DIV_N_MASK;\n\n\t \n\tif (!mode) {\n\t\t \n\t\tnum *= (val >> PLL_NORM_FDBK_M_SHIFT) & PLL_NORM_FDBK_M_MASK;\n\t} else {\n\t\t \n\t\tnum *= (val >> PLL_DITH_FDBK_M_SHIFT) & PLL_DITH_FDBK_M_MASK;\n\t\tden *= 256;\n\t}\n\n\tif (!den) {\n\t\tWARN(1, \"%s: denominator can't be zero\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\treturn (((parent_rate / 10000) * num) / den) * 10000;\n}\n\n \nstatic int clk_vco_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\tunsigned long prate)\n{\n\tstruct clk_vco *vco = to_clk_vco(hw);\n\tstruct pll_rate_tbl *rtbl = vco->rtbl;\n\tunsigned long flags = 0, val;\n\tint i;\n\n\tclk_round_rate_index(hw, drate, prate, vco_calc_rate, vco->rtbl_cnt,\n\t\t\t&i);\n\n\tif (vco->lock)\n\t\tspin_lock_irqsave(vco->lock, flags);\n\n\tval = readl_relaxed(vco->mode_reg);\n\tval &= ~(PLL_MODE_MASK << PLL_MODE_SHIFT);\n\tval |= (rtbl[i].mode & PLL_MODE_MASK) << PLL_MODE_SHIFT;\n\twritel_relaxed(val, vco->mode_reg);\n\n\tval = readl_relaxed(vco->cfg_reg);\n\tval &= ~(PLL_DIV_N_MASK << PLL_DIV_N_SHIFT);\n\tval |= (rtbl[i].n & PLL_DIV_N_MASK) << PLL_DIV_N_SHIFT;\n\n\tval &= ~(PLL_DITH_FDBK_M_MASK << PLL_DITH_FDBK_M_SHIFT);\n\tif (rtbl[i].mode)\n\t\tval |= (rtbl[i].m & PLL_DITH_FDBK_M_MASK) <<\n\t\t\tPLL_DITH_FDBK_M_SHIFT;\n\telse\n\t\tval |= (rtbl[i].m & PLL_NORM_FDBK_M_MASK) <<\n\t\t\tPLL_NORM_FDBK_M_SHIFT;\n\n\twritel_relaxed(val, vco->cfg_reg);\n\n\tif (vco->lock)\n\t\tspin_unlock_irqrestore(vco->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_vco_ops = {\n\t.recalc_rate = clk_vco_recalc_rate,\n\t.round_rate = clk_vco_round_rate,\n\t.set_rate = clk_vco_set_rate,\n};\n\nstruct clk *clk_register_vco_pll(const char *vco_name, const char *pll_name,\n\t\tconst char *vco_gate_name, const char *parent_name,\n\t\tunsigned long flags, void __iomem *mode_reg, void __iomem\n\t\t*cfg_reg, struct pll_rate_tbl *rtbl, u8 rtbl_cnt,\n\t\tspinlock_t *lock, struct clk **pll_clk,\n\t\tstruct clk **vco_gate_clk)\n{\n\tstruct clk_vco *vco;\n\tstruct clk_pll *pll;\n\tstruct clk *vco_clk, *tpll_clk, *tvco_gate_clk;\n\tstruct clk_init_data vco_init, pll_init;\n\tconst char **vco_parent_name;\n\n\tif (!vco_name || !pll_name || !parent_name || !mode_reg || !cfg_reg ||\n\t\t\t!rtbl || !rtbl_cnt) {\n\t\tpr_err(\"Invalid arguments passed\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tvco = kzalloc(sizeof(*vco), GFP_KERNEL);\n\tif (!vco)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\tgoto free_vco;\n\n\t \n\tvco->mode_reg = mode_reg;\n\tvco->cfg_reg = cfg_reg;\n\tvco->rtbl = rtbl;\n\tvco->rtbl_cnt = rtbl_cnt;\n\tvco->lock = lock;\n\tvco->hw.init = &vco_init;\n\n\tpll->vco = vco;\n\tpll->hw.init = &pll_init;\n\n\tif (vco_gate_name) {\n\t\ttvco_gate_clk = clk_register_gate(NULL, vco_gate_name,\n\t\t\t\tparent_name, 0, mode_reg, PLL_ENABLE, 0, lock);\n\t\tif (IS_ERR_OR_NULL(tvco_gate_clk))\n\t\t\tgoto free_pll;\n\n\t\tif (vco_gate_clk)\n\t\t\t*vco_gate_clk = tvco_gate_clk;\n\t\tvco_parent_name = &vco_gate_name;\n\t} else {\n\t\tvco_parent_name = &parent_name;\n\t}\n\n\tvco_init.name = vco_name;\n\tvco_init.ops = &clk_vco_ops;\n\tvco_init.flags = flags;\n\tvco_init.parent_names = vco_parent_name;\n\tvco_init.num_parents = 1;\n\n\tpll_init.name = pll_name;\n\tpll_init.ops = &clk_pll_ops;\n\tpll_init.flags = CLK_SET_RATE_PARENT;\n\tpll_init.parent_names = &vco_name;\n\tpll_init.num_parents = 1;\n\n\tvco_clk = clk_register(NULL, &vco->hw);\n\tif (IS_ERR_OR_NULL(vco_clk))\n\t\tgoto free_pll;\n\n\ttpll_clk = clk_register(NULL, &pll->hw);\n\tif (IS_ERR_OR_NULL(tpll_clk))\n\t\tgoto free_pll;\n\n\tif (pll_clk)\n\t\t*pll_clk = tpll_clk;\n\n\treturn vco_clk;\n\nfree_pll:\n\tkfree(pll);\nfree_vco:\n\tkfree(vco);\n\n\tpr_err(\"Failed to register vco pll clock\\n\");\n\n\treturn ERR_PTR(-ENOMEM);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}