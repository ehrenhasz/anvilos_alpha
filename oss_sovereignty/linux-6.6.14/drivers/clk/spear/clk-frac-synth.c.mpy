{
  "module_name": "clk-frac-synth.c",
  "hash_id": "62de2c2e816b5aeff529f9144debaf4adf3b3dee7a706212b86f8ddbf8cc4d79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/spear/clk-frac-synth.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"clk-frac-synth: \" fmt\n\n#include <linux/clk-provider.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include \"clk.h\"\n\n#define DIV_FACTOR_MASK\t\t0x1FFFF\n\n \n\n#define to_clk_frac(_hw) container_of(_hw, struct clk_frac, hw)\n\nstatic unsigned long frac_calc_rate(struct clk_hw *hw, unsigned long prate,\n\t\tint index)\n{\n\tstruct clk_frac *frac = to_clk_frac(hw);\n\tstruct frac_rate_tbl *rtbl = frac->rtbl;\n\n\tprate /= 10000;\n\tprate <<= 14;\n\tprate /= (2 * rtbl[index].div);\n\tprate *= 10000;\n\n\treturn prate;\n}\n\nstatic long clk_frac_round_rate(struct clk_hw *hw, unsigned long drate,\n\t\tunsigned long *prate)\n{\n\tstruct clk_frac *frac = to_clk_frac(hw);\n\tint unused;\n\n\treturn clk_round_rate_index(hw, drate, *prate, frac_calc_rate,\n\t\t\tfrac->rtbl_cnt, &unused);\n}\n\nstatic unsigned long clk_frac_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_frac *frac = to_clk_frac(hw);\n\tunsigned long flags = 0;\n\tunsigned int div = 1, val;\n\n\tif (frac->lock)\n\t\tspin_lock_irqsave(frac->lock, flags);\n\n\tval = readl_relaxed(frac->reg);\n\n\tif (frac->lock)\n\t\tspin_unlock_irqrestore(frac->lock, flags);\n\n\tdiv = val & DIV_FACTOR_MASK;\n\n\tif (!div)\n\t\treturn 0;\n\n\tparent_rate = parent_rate / 10000;\n\n\tparent_rate = (parent_rate << 14) / (2 * div);\n\treturn parent_rate * 10000;\n}\n\n \nstatic int clk_frac_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\tunsigned long prate)\n{\n\tstruct clk_frac *frac = to_clk_frac(hw);\n\tstruct frac_rate_tbl *rtbl = frac->rtbl;\n\tunsigned long flags = 0, val;\n\tint i;\n\n\tclk_round_rate_index(hw, drate, prate, frac_calc_rate, frac->rtbl_cnt,\n\t\t\t&i);\n\n\tif (frac->lock)\n\t\tspin_lock_irqsave(frac->lock, flags);\n\n\tval = readl_relaxed(frac->reg) & ~DIV_FACTOR_MASK;\n\tval |= rtbl[i].div & DIV_FACTOR_MASK;\n\twritel_relaxed(val, frac->reg);\n\n\tif (frac->lock)\n\t\tspin_unlock_irqrestore(frac->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_frac_ops = {\n\t.recalc_rate = clk_frac_recalc_rate,\n\t.round_rate = clk_frac_round_rate,\n\t.set_rate = clk_frac_set_rate,\n};\n\nstruct clk *clk_register_frac(const char *name, const char *parent_name,\n\t\tunsigned long flags, void __iomem *reg,\n\t\tstruct frac_rate_tbl *rtbl, u8 rtbl_cnt, spinlock_t *lock)\n{\n\tstruct clk_init_data init;\n\tstruct clk_frac *frac;\n\tstruct clk *clk;\n\n\tif (!name || !parent_name || !reg || !rtbl || !rtbl_cnt) {\n\t\tpr_err(\"Invalid arguments passed\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfrac = kzalloc(sizeof(*frac), GFP_KERNEL);\n\tif (!frac)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tfrac->reg = reg;\n\tfrac->rtbl = rtbl;\n\tfrac->rtbl_cnt = rtbl_cnt;\n\tfrac->lock = lock;\n\tfrac->hw.init = &init;\n\n\tinit.name = name;\n\tinit.ops = &clk_frac_ops;\n\tinit.flags = flags;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tclk = clk_register(NULL, &frac->hw);\n\tif (!IS_ERR_OR_NULL(clk))\n\t\treturn clk;\n\n\tpr_err(\"clk register failed\\n\");\n\tkfree(frac);\n\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}