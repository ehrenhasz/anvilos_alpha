{
  "module_name": "clk-twl6040.c",
  "hash_id": "310a89c797960ec29faff19d304515f517c8ae9a7e715c15248cab38456b921b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-twl6040.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/twl6040.h>\n#include <linux/clk-provider.h>\n\nstruct twl6040_pdmclk {\n\tstruct twl6040 *twl6040;\n\tstruct device *dev;\n\tstruct clk_hw pdmclk_hw;\n\tint enabled;\n};\n\nstatic int twl6040_pdmclk_is_prepared(struct clk_hw *hw)\n{\n\tstruct twl6040_pdmclk *pdmclk = container_of(hw, struct twl6040_pdmclk,\n\t\t\t\t\t\t     pdmclk_hw);\n\n\treturn pdmclk->enabled;\n}\n\nstatic int twl6040_pdmclk_reset_one_clock(struct twl6040_pdmclk *pdmclk,\n\t\t\t\t\t  unsigned int reg)\n{\n\tconst u8 reset_mask = TWL6040_HPLLRST;\t \n\tint ret;\n\n\tret = twl6040_set_bits(pdmclk->twl6040, reg, reset_mask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = twl6040_clear_bits(pdmclk->twl6040, reg, reset_mask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int twl6040_pdmclk_quirk_reset_clocks(struct twl6040_pdmclk *pdmclk)\n{\n\tint ret;\n\n\tret = twl6040_pdmclk_reset_one_clock(pdmclk, TWL6040_REG_HPPLLCTL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = twl6040_pdmclk_reset_one_clock(pdmclk, TWL6040_REG_LPPLLCTL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int twl6040_pdmclk_prepare(struct clk_hw *hw)\n{\n\tstruct twl6040_pdmclk *pdmclk = container_of(hw, struct twl6040_pdmclk,\n\t\t\t\t\t\t     pdmclk_hw);\n\tint ret;\n\n\tret = twl6040_power(pdmclk->twl6040, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = twl6040_pdmclk_quirk_reset_clocks(pdmclk);\n\tif (ret)\n\t\tgoto out_err;\n\n\tpdmclk->enabled = 1;\n\n\treturn 0;\n\nout_err:\n\tdev_err(pdmclk->dev, \"%s: error %i\\n\", __func__, ret);\n\ttwl6040_power(pdmclk->twl6040, 0);\n\n\treturn ret;\n}\n\nstatic void twl6040_pdmclk_unprepare(struct clk_hw *hw)\n{\n\tstruct twl6040_pdmclk *pdmclk = container_of(hw, struct twl6040_pdmclk,\n\t\t\t\t\t\t     pdmclk_hw);\n\tint ret;\n\n\tret = twl6040_power(pdmclk->twl6040, 0);\n\tif (!ret)\n\t\tpdmclk->enabled = 0;\n\n}\n\nstatic unsigned long twl6040_pdmclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct twl6040_pdmclk *pdmclk = container_of(hw, struct twl6040_pdmclk,\n\t\t\t\t\t\t     pdmclk_hw);\n\n\treturn twl6040_get_sysclk(pdmclk->twl6040);\n}\n\nstatic const struct clk_ops twl6040_pdmclk_ops = {\n\t.is_prepared = twl6040_pdmclk_is_prepared,\n\t.prepare = twl6040_pdmclk_prepare,\n\t.unprepare = twl6040_pdmclk_unprepare,\n\t.recalc_rate = twl6040_pdmclk_recalc_rate,\n};\n\nstatic const struct clk_init_data twl6040_pdmclk_init = {\n\t.name = \"pdmclk\",\n\t.ops = &twl6040_pdmclk_ops,\n\t.flags = CLK_GET_RATE_NOCACHE,\n};\n\nstatic int twl6040_pdmclk_probe(struct platform_device *pdev)\n{\n\tstruct twl6040 *twl6040 = dev_get_drvdata(pdev->dev.parent);\n\tstruct twl6040_pdmclk *clkdata;\n\tint ret;\n\n\tclkdata = devm_kzalloc(&pdev->dev, sizeof(*clkdata), GFP_KERNEL);\n\tif (!clkdata)\n\t\treturn -ENOMEM;\n\n\tclkdata->dev = &pdev->dev;\n\tclkdata->twl6040 = twl6040;\n\n\tclkdata->pdmclk_hw.init = &twl6040_pdmclk_init;\n\tret = devm_clk_hw_register(&pdev->dev, &clkdata->pdmclk_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, clkdata);\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, of_clk_hw_simple_get,\n\t\t\t\t\t   &clkdata->pdmclk_hw);\n}\n\nstatic struct platform_driver twl6040_pdmclk_driver = {\n\t.driver = {\n\t\t.name = \"twl6040-pdmclk\",\n\t},\n\t.probe = twl6040_pdmclk_probe,\n};\n\nmodule_platform_driver(twl6040_pdmclk_driver);\n\nMODULE_DESCRIPTION(\"TWL6040 clock driver for McPDM functional clock\");\nMODULE_AUTHOR(\"Peter Ujfalusi <peter.ujfalusi@ti.com>\");\nMODULE_ALIAS(\"platform:twl6040-pdmclk\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}