{
  "module_name": "clk-ast2600.c",
  "hash_id": "2fb20f6c607fe3cb4ac1ae0d398e17e200af064d4720af2f40bb296103e32d8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-ast2600.c",
  "human_readable_source": "\n\n\n\n#define pr_fmt(fmt) \"clk-ast2600: \" fmt\n\n#include <linux/mfd/syscon.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/clock/ast2600-clock.h>\n\n#include \"clk-aspeed.h\"\n\n \n#define ASPEED_G6_NUM_CLKS\t\t72\n\n#define ASPEED_G6_SILICON_REV\t\t0x014\n#define CHIP_REVISION_ID\t\t\tGENMASK(23, 16)\n\n#define ASPEED_G6_RESET_CTRL\t\t0x040\n#define ASPEED_G6_RESET_CTRL2\t\t0x050\n\n#define ASPEED_G6_CLK_STOP_CTRL\t\t0x080\n#define ASPEED_G6_CLK_STOP_CTRL2\t0x090\n\n#define ASPEED_G6_MISC_CTRL\t\t0x0C0\n#define  UART_DIV13_EN\t\t\tBIT(12)\n\n#define ASPEED_G6_CLK_SELECTION1\t0x300\n#define ASPEED_G6_CLK_SELECTION2\t0x304\n#define ASPEED_G6_CLK_SELECTION4\t0x310\n#define ASPEED_G6_CLK_SELECTION5\t0x314\n#define   I3C_CLK_SELECTION_SHIFT\t31\n#define   I3C_CLK_SELECTION\t\tBIT(31)\n#define     I3C_CLK_SELECT_HCLK\t\t(0 << I3C_CLK_SELECTION_SHIFT)\n#define     I3C_CLK_SELECT_APLL_DIV\t(1 << I3C_CLK_SELECTION_SHIFT)\n#define   APLL_DIV_SELECTION_SHIFT\t28\n#define   APLL_DIV_SELECTION\t\tGENMASK(30, 28)\n#define     APLL_DIV_2\t\t\t(0b001 << APLL_DIV_SELECTION_SHIFT)\n#define     APLL_DIV_3\t\t\t(0b010 << APLL_DIV_SELECTION_SHIFT)\n#define     APLL_DIV_4\t\t\t(0b011 << APLL_DIV_SELECTION_SHIFT)\n#define     APLL_DIV_5\t\t\t(0b100 << APLL_DIV_SELECTION_SHIFT)\n#define     APLL_DIV_6\t\t\t(0b101 << APLL_DIV_SELECTION_SHIFT)\n#define     APLL_DIV_7\t\t\t(0b110 << APLL_DIV_SELECTION_SHIFT)\n#define     APLL_DIV_8\t\t\t(0b111 << APLL_DIV_SELECTION_SHIFT)\n\n#define ASPEED_HPLL_PARAM\t\t0x200\n#define ASPEED_APLL_PARAM\t\t0x210\n#define ASPEED_MPLL_PARAM\t\t0x220\n#define ASPEED_EPLL_PARAM\t\t0x240\n#define ASPEED_DPLL_PARAM\t\t0x260\n\n#define ASPEED_G6_STRAP1\t\t0x500\n\n#define ASPEED_MAC12_CLK_DLY\t\t0x340\n#define ASPEED_MAC34_CLK_DLY\t\t0x350\n\n \nstatic DEFINE_SPINLOCK(aspeed_g6_clk_lock);\n\n \nstatic struct clk_hw_onecell_data *aspeed_g6_clk_data;\n\nstatic void __iomem *scu_g6_base;\n \nstatic u8 soc_rev;\n\n \nstatic const struct aspeed_gate_data aspeed_g6_gates[] = {\n\t \n\t[ASPEED_CLK_GATE_MCLK]\t\t= {  0, -1, \"mclk-gate\",\t\"mpll\",\t CLK_IS_CRITICAL },  \n\t[ASPEED_CLK_GATE_ECLK]\t\t= {  1,  6, \"eclk-gate\",\t\"eclk\",\t 0 },\t \n\t[ASPEED_CLK_GATE_GCLK]\t\t= {  2,  7, \"gclk-gate\",\tNULL,\t 0 },\t \n\t \n\t[ASPEED_CLK_GATE_VCLK]\t\t= {  3, -1, \"vclk-gate\",\tNULL,\t 0 },\t \n\t[ASPEED_CLK_GATE_BCLK]\t\t= {  4,  8, \"bclk-gate\",\t\"bclk\",\t 0 },  \n\t \n\t[ASPEED_CLK_GATE_DCLK]\t\t= {  5, -1, \"dclk-gate\",\tNULL,\t CLK_IS_CRITICAL },  \n\t[ASPEED_CLK_GATE_REF0CLK]\t= {  6, -1, \"ref0clk-gate\",\t\"clkin\", CLK_IS_CRITICAL },\n\t[ASPEED_CLK_GATE_USBPORT2CLK]\t= {  7,  3, \"usb-port2-gate\",\tNULL,\t 0 },\t \n\t \n\t[ASPEED_CLK_GATE_USBUHCICLK]\t= {  9, 15, \"usb-uhci-gate\",\tNULL,\t 0 },\t \n\t \n\t[ASPEED_CLK_GATE_D1CLK]\t\t= { 10, 13, \"d1clk-gate\",\t\"d1clk\", 0 },\t \n\t \n\t[ASPEED_CLK_GATE_YCLK]\t\t= { 13,  4, \"yclk-gate\",\tNULL,\t 0 },\t \n\t[ASPEED_CLK_GATE_USBPORT1CLK]\t= { 14, 14, \"usb-port1-gate\",\tNULL,\t 0 },\t \n\t[ASPEED_CLK_GATE_UART5CLK]\t= { 15, -1, \"uart5clk-gate\",\t\"uart\",\t 0 },\t \n\t \n\t[ASPEED_CLK_GATE_MAC1CLK]\t= { 20, 11, \"mac1clk-gate\",\t\"mac12\", 0 },\t \n\t[ASPEED_CLK_GATE_MAC2CLK]\t= { 21, 12, \"mac2clk-gate\",\t\"mac12\", 0 },\t \n\t \n\t[ASPEED_CLK_GATE_RSACLK]\t= { 24,  4, \"rsaclk-gate\",\tNULL,\t 0 },\t \n\t[ASPEED_CLK_GATE_RVASCLK]\t= { 25,  9, \"rvasclk-gate\",\tNULL,\t 0 },\t \n\t \n\t[ASPEED_CLK_GATE_EMMCCLK]\t= { 27, 16, \"emmcclk-gate\",\tNULL,\t 0 },\t \n\t \n\t[ASPEED_CLK_GATE_LCLK]\t\t= { 32, 32, \"lclk-gate\",\tNULL,\t 0 },  \n\t[ASPEED_CLK_GATE_ESPICLK]\t= { 33, -1, \"espiclk-gate\",\tNULL,\t 0 },  \n\t[ASPEED_CLK_GATE_REF1CLK]\t= { 34, -1, \"ref1clk-gate\",\t\"clkin\", CLK_IS_CRITICAL },\n\t \n\t[ASPEED_CLK_GATE_SDCLK]\t\t= { 36, 56, \"sdclk-gate\",\tNULL,\t 0 },\t \n\t[ASPEED_CLK_GATE_LHCCLK]\t= { 37, -1, \"lhclk-gate\",\t\"lhclk\", 0 },\t \n\t \n\t \n\t[ASPEED_CLK_GATE_I3C0CLK]\t= { 40,  40, \"i3c0clk-gate\",\t\"i3cclk\", 0 },  \n\t[ASPEED_CLK_GATE_I3C1CLK]\t= { 41,  41, \"i3c1clk-gate\",\t\"i3cclk\", 0 },  \n\t[ASPEED_CLK_GATE_I3C2CLK]\t= { 42,  42, \"i3c2clk-gate\",\t\"i3cclk\", 0 },  \n\t[ASPEED_CLK_GATE_I3C3CLK]\t= { 43,  43, \"i3c3clk-gate\",\t\"i3cclk\", 0 },  \n\t[ASPEED_CLK_GATE_I3C4CLK]\t= { 44,  44, \"i3c4clk-gate\",\t\"i3cclk\", 0 },  \n\t[ASPEED_CLK_GATE_I3C5CLK]\t= { 45,  45, \"i3c5clk-gate\",\t\"i3cclk\", 0 },  \n\t \n\t[ASPEED_CLK_GATE_UART1CLK]\t= { 48,  -1, \"uart1clk-gate\",\t\"uart\",\t 0 },\t \n\t[ASPEED_CLK_GATE_UART2CLK]\t= { 49,  -1, \"uart2clk-gate\",\t\"uart\",\t 0 },\t \n\t[ASPEED_CLK_GATE_UART3CLK]\t= { 50,  -1, \"uart3clk-gate\",\t\"uart\",  0 },\t \n\t[ASPEED_CLK_GATE_UART4CLK]\t= { 51,  -1, \"uart4clk-gate\",\t\"uart\",\t 0 },\t \n\t[ASPEED_CLK_GATE_MAC3CLK]\t= { 52,  52, \"mac3clk-gate\",\t\"mac34\", 0 },\t \n\t[ASPEED_CLK_GATE_MAC4CLK]\t= { 53,  53, \"mac4clk-gate\",\t\"mac34\", 0 },\t \n\t[ASPEED_CLK_GATE_UART6CLK]\t= { 54,  -1, \"uart6clk-gate\",\t\"uartx\", 0 },\t \n\t[ASPEED_CLK_GATE_UART7CLK]\t= { 55,  -1, \"uart7clk-gate\",\t\"uartx\", 0 },\t \n\t[ASPEED_CLK_GATE_UART8CLK]\t= { 56,  -1, \"uart8clk-gate\",\t\"uartx\", 0 },\t \n\t[ASPEED_CLK_GATE_UART9CLK]\t= { 57,  -1, \"uart9clk-gate\",\t\"uartx\", 0 },\t \n\t[ASPEED_CLK_GATE_UART10CLK]\t= { 58,  -1, \"uart10clk-gate\",\t\"uartx\", 0 },\t \n\t[ASPEED_CLK_GATE_UART11CLK]\t= { 59,  -1, \"uart11clk-gate\",\t\"uartx\", 0 },\t \n\t[ASPEED_CLK_GATE_UART12CLK]\t= { 60,  -1, \"uart12clk-gate\",\t\"uartx\", 0 },\t \n\t[ASPEED_CLK_GATE_UART13CLK]\t= { 61,  -1, \"uart13clk-gate\",\t\"uartx\", 0 },\t \n\t[ASPEED_CLK_GATE_FSICLK]\t= { 62,  59, \"fsiclk-gate\",\tNULL,\t 0 },\t \n};\n\nstatic const struct clk_div_table ast2600_eclk_div_table[] = {\n\t{ 0x0, 2 },\n\t{ 0x1, 2 },\n\t{ 0x2, 3 },\n\t{ 0x3, 4 },\n\t{ 0x4, 5 },\n\t{ 0x5, 6 },\n\t{ 0x6, 7 },\n\t{ 0x7, 8 },\n\t{ 0 }\n};\n\nstatic const struct clk_div_table ast2600_emmc_extclk_div_table[] = {\n\t{ 0x0, 2 },\n\t{ 0x1, 4 },\n\t{ 0x2, 6 },\n\t{ 0x3, 8 },\n\t{ 0x4, 10 },\n\t{ 0x5, 12 },\n\t{ 0x6, 14 },\n\t{ 0x7, 16 },\n\t{ 0 }\n};\n\nstatic const struct clk_div_table ast2600_mac_div_table[] = {\n\t{ 0x0, 4 },\n\t{ 0x1, 4 },\n\t{ 0x2, 6 },\n\t{ 0x3, 8 },\n\t{ 0x4, 10 },\n\t{ 0x5, 12 },\n\t{ 0x6, 14 },\n\t{ 0x7, 16 },\n\t{ 0 }\n};\n\nstatic const struct clk_div_table ast2600_div_table[] = {\n\t{ 0x0, 4 },\n\t{ 0x1, 8 },\n\t{ 0x2, 12 },\n\t{ 0x3, 16 },\n\t{ 0x4, 20 },\n\t{ 0x5, 24 },\n\t{ 0x6, 28 },\n\t{ 0x7, 32 },\n\t{ 0 }\n};\n\n \nstatic struct clk_hw *ast2600_calc_pll(const char *name, u32 val)\n{\n\tunsigned int mult, div;\n\n\tif (val & BIT(24)) {\n\t\t \n\t\tmult = div = 1;\n\t} else {\n\t\t \n\t\tu32 m = val  & 0x1fff;\n\t\tu32 n = (val >> 13) & 0x3f;\n\t\tu32 p = (val >> 19) & 0xf;\n\t\tmult = (m + 1) / (n + 1);\n\t\tdiv = (p + 1);\n\t}\n\treturn clk_hw_register_fixed_factor(NULL, name, \"clkin\", 0,\n\t\t\tmult, div);\n};\n\nstatic struct clk_hw *ast2600_calc_apll(const char *name, u32 val)\n{\n\tunsigned int mult, div;\n\n\tif (soc_rev >= 2) {\n\t\tif (val & BIT(24)) {\n\t\t\t \n\t\t\tmult = div = 1;\n\t\t} else {\n\t\t\t \n\t\t\tu32 m = val & 0x1fff;\n\t\t\tu32 n = (val >> 13) & 0x3f;\n\t\t\tu32 p = (val >> 19) & 0xf;\n\n\t\t\tmult = (m + 1);\n\t\t\tdiv = (n + 1) * (p + 1);\n\t\t}\n\t} else {\n\t\tif (val & BIT(20)) {\n\t\t\t \n\t\t\tmult = div = 1;\n\t\t} else {\n\t\t\t \n\t\t\tu32 m = (val >> 5) & 0x3f;\n\t\t\tu32 od = (val >> 4) & 0x1;\n\t\t\tu32 n = val & 0xf;\n\n\t\t\tmult = (2 - od) * (m + 2);\n\t\t\tdiv = n + 1;\n\t\t}\n\t}\n\treturn clk_hw_register_fixed_factor(NULL, name, \"clkin\", 0,\n\t\t\tmult, div);\n};\n\nstatic u32 get_bit(u8 idx)\n{\n\treturn BIT(idx % 32);\n}\n\nstatic u32 get_reset_reg(struct aspeed_clk_gate *gate)\n{\n\tif (gate->reset_idx < 32)\n\t\treturn ASPEED_G6_RESET_CTRL;\n\n\treturn ASPEED_G6_RESET_CTRL2;\n}\n\nstatic u32 get_clock_reg(struct aspeed_clk_gate *gate)\n{\n\tif (gate->clock_idx < 32)\n\t\treturn ASPEED_G6_CLK_STOP_CTRL;\n\n\treturn ASPEED_G6_CLK_STOP_CTRL2;\n}\n\nstatic int aspeed_g6_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct aspeed_clk_gate *gate = to_aspeed_clk_gate(hw);\n\tu32 clk = get_bit(gate->clock_idx);\n\tu32 rst = get_bit(gate->reset_idx);\n\tu32 reg;\n\tu32 enval;\n\n\t \n\tif (gate->reset_idx >= 0) {\n\t\tregmap_read(gate->map, get_reset_reg(gate), &reg);\n\n\t\tif (reg & rst)\n\t\t\treturn 0;\n\t}\n\n\tregmap_read(gate->map, get_clock_reg(gate), &reg);\n\n\tenval = (gate->flags & CLK_GATE_SET_TO_DISABLE) ? 0 : clk;\n\n\treturn ((reg & clk) == enval) ? 1 : 0;\n}\n\nstatic int aspeed_g6_clk_enable(struct clk_hw *hw)\n{\n\tstruct aspeed_clk_gate *gate = to_aspeed_clk_gate(hw);\n\tunsigned long flags;\n\tu32 clk = get_bit(gate->clock_idx);\n\tu32 rst = get_bit(gate->reset_idx);\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tif (aspeed_g6_clk_is_enabled(hw)) {\n\t\tspin_unlock_irqrestore(gate->lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (gate->reset_idx >= 0) {\n\t\t \n\t\tregmap_write(gate->map, get_reset_reg(gate), rst);\n\t\t \n\t\tudelay(100);\n\t}\n\n\t \n\tif (gate->flags & CLK_GATE_SET_TO_DISABLE) {\n\t\t \n\t\tregmap_write(gate->map, get_clock_reg(gate) + 0x04, clk);\n\t} else {\n\t\t \n\t\tregmap_write(gate->map, get_clock_reg(gate), clk);\n\t}\n\n\tif (gate->reset_idx >= 0) {\n\t\t \n\t\tmdelay(10);\n\t\t \n\t\tregmap_write(gate->map, get_reset_reg(gate) + 0x4, rst);\n\t}\n\n\tspin_unlock_irqrestore(gate->lock, flags);\n\n\treturn 0;\n}\n\nstatic void aspeed_g6_clk_disable(struct clk_hw *hw)\n{\n\tstruct aspeed_clk_gate *gate = to_aspeed_clk_gate(hw);\n\tunsigned long flags;\n\tu32 clk = get_bit(gate->clock_idx);\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tif (gate->flags & CLK_GATE_SET_TO_DISABLE) {\n\t\tregmap_write(gate->map, get_clock_reg(gate), clk);\n\t} else {\n\t\t \n\t\tregmap_write(gate->map, get_clock_reg(gate) + 0x4, clk);\n\t}\n\n\tspin_unlock_irqrestore(gate->lock, flags);\n}\n\nstatic const struct clk_ops aspeed_g6_clk_gate_ops = {\n\t.enable = aspeed_g6_clk_enable,\n\t.disable = aspeed_g6_clk_disable,\n\t.is_enabled = aspeed_g6_clk_is_enabled,\n};\n\nstatic int aspeed_g6_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t    unsigned long id)\n{\n\tstruct aspeed_reset *ar = to_aspeed_reset(rcdev);\n\tu32 rst = get_bit(id);\n\tu32 reg = id >= 32 ? ASPEED_G6_RESET_CTRL2 : ASPEED_G6_RESET_CTRL;\n\n\t \n\treturn regmap_write(ar->map, reg + 0x04, rst);\n}\n\nstatic int aspeed_g6_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t\t  unsigned long id)\n{\n\tstruct aspeed_reset *ar = to_aspeed_reset(rcdev);\n\tu32 rst = get_bit(id);\n\tu32 reg = id >= 32 ? ASPEED_G6_RESET_CTRL2 : ASPEED_G6_RESET_CTRL;\n\n\treturn regmap_write(ar->map, reg, rst);\n}\n\nstatic int aspeed_g6_reset_status(struct reset_controller_dev *rcdev,\n\t\t\t\t  unsigned long id)\n{\n\tstruct aspeed_reset *ar = to_aspeed_reset(rcdev);\n\tint ret;\n\tu32 val;\n\tu32 rst = get_bit(id);\n\tu32 reg = id >= 32 ? ASPEED_G6_RESET_CTRL2 : ASPEED_G6_RESET_CTRL;\n\n\tret = regmap_read(ar->map, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(val & rst);\n}\n\nstatic const struct reset_control_ops aspeed_g6_reset_ops = {\n\t.assert = aspeed_g6_reset_assert,\n\t.deassert = aspeed_g6_reset_deassert,\n\t.status = aspeed_g6_reset_status,\n};\n\nstatic struct clk_hw *aspeed_g6_clk_hw_register_gate(struct device *dev,\n\t\tconst char *name, const char *parent_name, unsigned long flags,\n\t\tstruct regmap *map, u8 clock_idx, u8 reset_idx,\n\t\tu8 clk_gate_flags, spinlock_t *lock)\n{\n\tstruct aspeed_clk_gate *gate;\n\tstruct clk_init_data init;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &aspeed_g6_clk_gate_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\n\tgate->map = map;\n\tgate->clock_idx = clock_idx;\n\tgate->reset_idx = reset_idx;\n\tgate->flags = clk_gate_flags;\n\tgate->lock = lock;\n\tgate->hw.init = &init;\n\n\thw = &gate->hw;\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\tkfree(gate);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstatic const char *const emmc_extclk_parent_names[] = {\n\t\"emmc_extclk_hpll_in\",\n\t\"mpll\",\n};\n\nstatic const char * const vclk_parent_names[] = {\n\t\"dpll\",\n\t\"d1pll\",\n\t\"hclk\",\n\t\"mclk\",\n};\n\nstatic const char * const d1clk_parent_names[] = {\n\t\"dpll\",\n\t\"epll\",\n\t\"usb-phy-40m\",\n\t\"gpioc6_clkin\",\n\t\"dp_phy_pll\",\n};\n\nstatic int aspeed_g6_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct aspeed_reset *ar;\n\tstruct regmap *map;\n\tstruct clk_hw *hw;\n\tu32 val, rate;\n\tint i, ret;\n\n\tmap = syscon_node_to_regmap(dev->of_node);\n\tif (IS_ERR(map)) {\n\t\tdev_err(dev, \"no syscon regmap\\n\");\n\t\treturn PTR_ERR(map);\n\t}\n\n\tar = devm_kzalloc(dev, sizeof(*ar), GFP_KERNEL);\n\tif (!ar)\n\t\treturn -ENOMEM;\n\n\tar->map = map;\n\n\tar->rcdev.owner = THIS_MODULE;\n\tar->rcdev.nr_resets = 64;\n\tar->rcdev.ops = &aspeed_g6_reset_ops;\n\tar->rcdev.of_node = dev->of_node;\n\n\tret = devm_reset_controller_register(dev, &ar->rcdev);\n\tif (ret) {\n\t\tdev_err(dev, \"could not register reset controller\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tregmap_read(map, ASPEED_G6_MISC_CTRL, &val);\n\tif (val & UART_DIV13_EN)\n\t\trate = 24000000 / 13;\n\telse\n\t\trate = 24000000;\n\thw = clk_hw_register_fixed_rate(dev, \"uart\", NULL, 0, rate);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_UART] = hw;\n\n\t \n\tregmap_read(map, 0x80, &val);\n\tif (val & BIT(31))\n\t\trate = 24000000 / 13;\n\telse\n\t\trate = 24000000;\n\thw = clk_hw_register_fixed_rate(dev, \"uartx\", NULL, 0, rate);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_UARTX] = hw;\n\n\t \n\thw = clk_hw_register_fixed_factor(dev, \"emmc_extclk_hpll_in\", \"hpll\",\n\t\t\t\t\t  0, 1, 2);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\n\thw = clk_hw_register_mux(dev, \"emmc_extclk_mux\",\n\t\t\t\t emmc_extclk_parent_names,\n\t\t\t\t ARRAY_SIZE(emmc_extclk_parent_names), 0,\n\t\t\t\t scu_g6_base + ASPEED_G6_CLK_SELECTION1, 11, 1,\n\t\t\t\t 0, &aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\n\thw = clk_hw_register_gate(dev, \"emmc_extclk_gate\", \"emmc_extclk_mux\",\n\t\t\t\t  0, scu_g6_base + ASPEED_G6_CLK_SELECTION1,\n\t\t\t\t  15, 0, &aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\n\thw = clk_hw_register_divider_table(dev, \"emmc_extclk\",\n\t\t\t\t\t   \"emmc_extclk_gate\", 0,\n\t\t\t\t\t   scu_g6_base +\n\t\t\t\t\t\tASPEED_G6_CLK_SELECTION1, 12,\n\t\t\t\t\t   3, 0, ast2600_emmc_extclk_div_table,\n\t\t\t\t\t   &aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_EMMC] = hw;\n\n\t \n\thw = clk_hw_register_gate(dev, \"sd_extclk_gate\", \"hpll\", 0,\n\t\t\tscu_g6_base + ASPEED_G6_CLK_SELECTION4, 31, 0,\n\t\t\t&aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\thw = clk_hw_register_divider_table(dev, \"sd_extclk\", \"sd_extclk_gate\",\n\t\t\t0, scu_g6_base + ASPEED_G6_CLK_SELECTION4, 28, 3, 0,\n\t\t\tast2600_div_table,\n\t\t\t&aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_SDIO] = hw;\n\n\t \n\thw = clk_hw_register_fixed_rate(dev, \"mac12rclk\", \"hpll\", 0, 50000000);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\n\t \n\thw = clk_hw_register_divider_table(dev, \"mac12\", \"hpll\", 0,\n\t\t\tscu_g6_base + ASPEED_G6_CLK_SELECTION1, 16, 3, 0,\n\t\t\tast2600_mac_div_table,\n\t\t\t&aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_MAC12] = hw;\n\n\t \n\thw = clk_hw_register_gate(dev, \"mac1rclk\", \"mac12rclk\", 0,\n\t\t\tscu_g6_base + ASPEED_MAC12_CLK_DLY, 29, 0,\n\t\t\t&aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_MAC1RCLK] = hw;\n\n\t \n\thw = clk_hw_register_gate(dev, \"mac2rclk\", \"mac12rclk\", 0,\n\t\t\tscu_g6_base + ASPEED_MAC12_CLK_DLY, 30, 0,\n\t\t\t&aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_MAC2RCLK] = hw;\n\n\t \n\thw = clk_hw_register_fixed_rate(dev, \"mac34rclk\", \"hclk\", 0, 50000000);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\n\t \n\thw = clk_hw_register_divider_table(dev, \"mac34\", \"hpll\", 0,\n\t\t\tscu_g6_base + 0x310, 24, 3, 0,\n\t\t\tast2600_mac_div_table,\n\t\t\t&aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_MAC34] = hw;\n\n\t \n\thw = clk_hw_register_gate(dev, \"mac3rclk\", \"mac34rclk\", 0,\n\t\t\tscu_g6_base + ASPEED_MAC34_CLK_DLY, 29, 0,\n\t\t\t&aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_MAC3RCLK] = hw;\n\n\t \n\thw = clk_hw_register_gate(dev, \"mac4rclk\", \"mac34rclk\", 0,\n\t\t\tscu_g6_base + ASPEED_MAC34_CLK_DLY, 30, 0,\n\t\t\t&aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_MAC4RCLK] = hw;\n\n\t \n\thw = clk_hw_register_divider_table(dev, \"lhclk\", \"hpll\", 0,\n\t\t\tscu_g6_base + ASPEED_G6_CLK_SELECTION1, 20, 3, 0,\n\t\t\tast2600_div_table,\n\t\t\t&aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_LHCLK] = hw;\n\n\t \n\tregmap_update_bits(map, ASPEED_G6_CLK_SELECTION1, GENMASK(10, 8), BIT(10));\n\t \n\thw = clk_hw_register_mux(dev, \"d1clk\", d1clk_parent_names,\n\t\t\tARRAY_SIZE(d1clk_parent_names), 0,\n\t\t\tscu_g6_base + ASPEED_G6_CLK_SELECTION1, 8, 3, 0,\n\t\t\t&aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_D1CLK] = hw;\n\n\t \n\tregmap_write(map, 0x308, 0x12000);  \n\n\t \n\thw = clk_hw_register_divider_table(dev, \"bclk\", \"epll\", 0,\n\t\t\tscu_g6_base + ASPEED_G6_CLK_SELECTION1, 20, 3, 0,\n\t\t\tast2600_div_table,\n\t\t\t&aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_BCLK] = hw;\n\n\t \n\thw = clk_hw_register_mux(dev, \"vclk\", vclk_parent_names,\n\t\t\tARRAY_SIZE(vclk_parent_names), 0,\n\t\t\tscu_g6_base + ASPEED_G6_CLK_SELECTION2, 12, 3, 0,\n\t\t\t&aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_VCLK] = hw;\n\n\t \n\thw = clk_hw_register_divider_table(dev, \"eclk\", NULL, 0,\n\t\t\tscu_g6_base + ASPEED_G6_CLK_SELECTION1, 28, 3, 0,\n\t\t\tast2600_eclk_div_table,\n\t\t\t&aspeed_g6_clk_lock);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_ECLK] = hw;\n\n\tfor (i = 0; i < ARRAY_SIZE(aspeed_g6_gates); i++) {\n\t\tconst struct aspeed_gate_data *gd = &aspeed_g6_gates[i];\n\t\tu32 gate_flags;\n\n\t\tif (!gd->name)\n\t\t\tcontinue;\n\n\t\t \n\t\tgate_flags = (gd->clock_idx == 14) ? 0 : CLK_GATE_SET_TO_DISABLE;\n\t\thw = aspeed_g6_clk_hw_register_gate(dev,\n\t\t\t\tgd->name,\n\t\t\t\tgd->parent_name,\n\t\t\t\tgd->flags,\n\t\t\t\tmap,\n\t\t\t\tgd->clock_idx,\n\t\t\t\tgd->reset_idx,\n\t\t\t\tgate_flags,\n\t\t\t\t&aspeed_g6_clk_lock);\n\t\tif (IS_ERR(hw))\n\t\t\treturn PTR_ERR(hw);\n\t\taspeed_g6_clk_data->hws[i] = hw;\n\t}\n\n\treturn 0;\n};\n\nstatic const struct of_device_id aspeed_g6_clk_dt_ids[] = {\n\t{ .compatible = \"aspeed,ast2600-scu\" },\n\t{ }\n};\n\nstatic struct platform_driver aspeed_g6_clk_driver = {\n\t.probe  = aspeed_g6_clk_probe,\n\t.driver = {\n\t\t.name = \"ast2600-clk\",\n\t\t.of_match_table = aspeed_g6_clk_dt_ids,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(aspeed_g6_clk_driver);\n\nstatic const u32 ast2600_a0_axi_ahb_div_table[] = {\n\t2, 2, 3, 5,\n};\n\nstatic const u32 ast2600_a1_axi_ahb_div0_tbl[] = {\n\t3, 2, 3, 4,\n};\n\nstatic const u32 ast2600_a1_axi_ahb_div1_tbl[] = {\n\t3, 4, 6, 8,\n};\n\nstatic const u32 ast2600_a1_axi_ahb200_tbl[] = {\n\t3, 4, 3, 4, 2, 2, 2, 2,\n};\n\nstatic void __init aspeed_g6_cc(struct regmap *map)\n{\n\tstruct clk_hw *hw;\n\tu32 val, div, divbits, axi_div, ahb_div;\n\n\tclk_hw_register_fixed_rate(NULL, \"clkin\", NULL, 0, 25000000);\n\n\t \n\tregmap_read(map, ASPEED_HPLL_PARAM, &val);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_HPLL] = ast2600_calc_pll(\"hpll\", val);\n\n\tregmap_read(map, ASPEED_MPLL_PARAM, &val);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_MPLL] = ast2600_calc_pll(\"mpll\", val);\n\n\tregmap_read(map, ASPEED_DPLL_PARAM, &val);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_DPLL] = ast2600_calc_pll(\"dpll\", val);\n\n\tregmap_read(map, ASPEED_EPLL_PARAM, &val);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_EPLL] = ast2600_calc_pll(\"epll\", val);\n\n\tregmap_read(map, ASPEED_APLL_PARAM, &val);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_APLL] = ast2600_calc_apll(\"apll\", val);\n\n\t \n\tregmap_read(map, ASPEED_G6_STRAP1, &val);\n\tif (val & BIT(16))\n\t\taxi_div = 1;\n\telse\n\t\taxi_div = 2;\n\n\tdivbits = (val >> 11) & 0x3;\n\tif (soc_rev >= 1) {\n\t\tif (!divbits) {\n\t\t\tahb_div = ast2600_a1_axi_ahb200_tbl[(val >> 8) & 0x3];\n\t\t\tif (val & BIT(16))\n\t\t\t\tahb_div *= 2;\n\t\t} else {\n\t\t\tif (val & BIT(16))\n\t\t\t\tahb_div = ast2600_a1_axi_ahb_div1_tbl[divbits];\n\t\t\telse\n\t\t\t\tahb_div = ast2600_a1_axi_ahb_div0_tbl[divbits];\n\t\t}\n\t} else {\n\t\tahb_div = ast2600_a0_axi_ahb_div_table[(val >> 11) & 0x3];\n\t}\n\n\thw = clk_hw_register_fixed_factor(NULL, \"ahb\", \"hpll\", 0, 1, axi_div * ahb_div);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_AHB] = hw;\n\n\tregmap_read(map, ASPEED_G6_CLK_SELECTION1, &val);\n\tval = (val >> 23) & 0x7;\n\tdiv = 4 * (val + 1);\n\thw = clk_hw_register_fixed_factor(NULL, \"apb1\", \"hpll\", 0, 1, div);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_APB1] = hw;\n\n\tregmap_read(map, ASPEED_G6_CLK_SELECTION4, &val);\n\tval = (val >> 9) & 0x7;\n\tdiv = 2 * (val + 1);\n\thw = clk_hw_register_fixed_factor(NULL, \"apb2\", \"ahb\", 0, 1, div);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_APB2] = hw;\n\n\t \n\thw = clk_hw_register_fixed_rate(NULL, \"usb-phy-40m\", NULL, 0, 40000000);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_USBPHY_40M] = hw;\n\n\t \n\tregmap_update_bits(map, ASPEED_G6_CLK_SELECTION5,\n\t\t\t   I3C_CLK_SELECTION | APLL_DIV_SELECTION,\n\t\t\t   I3C_CLK_SELECT_APLL_DIV | APLL_DIV_8);\n\n\thw = clk_hw_register_fixed_factor(NULL, \"i3cclk\", \"apll\", 0, 1, 8);\n\taspeed_g6_clk_data->hws[ASPEED_CLK_I3C] = hw;\n};\n\nstatic void __init aspeed_g6_cc_init(struct device_node *np)\n{\n\tstruct regmap *map;\n\tint ret;\n\tint i;\n\n\tscu_g6_base = of_iomap(np, 0);\n\tif (!scu_g6_base)\n\t\treturn;\n\n\tsoc_rev = (readl(scu_g6_base + ASPEED_G6_SILICON_REV) & CHIP_REVISION_ID) >> 16;\n\n\taspeed_g6_clk_data = kzalloc(struct_size(aspeed_g6_clk_data, hws,\n\t\t\t\t      ASPEED_G6_NUM_CLKS), GFP_KERNEL);\n\tif (!aspeed_g6_clk_data)\n\t\treturn;\n\taspeed_g6_clk_data->num = ASPEED_G6_NUM_CLKS;\n\n\t \n\tfor (i = 0; i < ASPEED_G6_NUM_CLKS; i++)\n\t\taspeed_g6_clk_data->hws[i] = ERR_PTR(-EPROBE_DEFER);\n\n\t \n\tmap = syscon_node_to_regmap(np);\n\tif (IS_ERR(map)) {\n\t\tpr_err(\"no syscon regmap\\n\");\n\t\treturn;\n\t}\n\n\taspeed_g6_cc(map);\n\tret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, aspeed_g6_clk_data);\n\tif (ret)\n\t\tpr_err(\"failed to add DT provider: %d\\n\", ret);\n};\nCLK_OF_DECLARE_DRIVER(aspeed_cc_g6, \"aspeed,ast2600-scu\", aspeed_g6_cc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}