{
  "module_name": "gate.c",
  "hash_id": "a2925241ef59bf4462d9074c8cf4360430ba8e8e929456bfc904e38c5fb46c3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sprd/gate.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/clk-provider.h>\n#include <linux/regmap.h>\n\n#include \"gate.h\"\n\nstatic void clk_gate_toggle(const struct sprd_gate *sg, bool en)\n{\n\tconst struct sprd_clk_common *common = &sg->common;\n\tunsigned int reg;\n\tbool set = sg->flags & CLK_GATE_SET_TO_DISABLE ? true : false;\n\n\tset ^= en;\n\n\tregmap_read(common->regmap, common->reg, &reg);\n\n\tif (set)\n\t\treg |= sg->enable_mask;\n\telse\n\t\treg &= ~sg->enable_mask;\n\n\tregmap_write(common->regmap, common->reg, reg);\n}\n\nstatic void clk_sc_gate_toggle(const struct sprd_gate *sg, bool en)\n{\n\tconst struct sprd_clk_common *common = &sg->common;\n\tbool set = sg->flags & CLK_GATE_SET_TO_DISABLE ? 1 : 0;\n\tunsigned int offset;\n\n\tset ^= en;\n\n\t \n\toffset = set ? sg->sc_offset : sg->sc_offset * 2;\n\n\tregmap_write(common->regmap, common->reg + offset,\n\t\t\t  sg->enable_mask);\n}\n\nstatic void sprd_gate_disable(struct clk_hw *hw)\n{\n\tstruct sprd_gate *sg = hw_to_sprd_gate(hw);\n\n\tclk_gate_toggle(sg, false);\n}\n\nstatic int sprd_gate_enable(struct clk_hw *hw)\n{\n\tstruct sprd_gate *sg = hw_to_sprd_gate(hw);\n\n\tclk_gate_toggle(sg, true);\n\n\treturn 0;\n}\n\nstatic void sprd_sc_gate_disable(struct clk_hw *hw)\n{\n\tstruct sprd_gate *sg = hw_to_sprd_gate(hw);\n\n\tclk_sc_gate_toggle(sg, false);\n}\n\nstatic int sprd_sc_gate_enable(struct clk_hw *hw)\n{\n\tstruct sprd_gate *sg = hw_to_sprd_gate(hw);\n\n\tclk_sc_gate_toggle(sg, true);\n\n\treturn 0;\n}\n\nstatic int sprd_pll_sc_gate_prepare(struct clk_hw *hw)\n{\n\tstruct sprd_gate *sg = hw_to_sprd_gate(hw);\n\n\tclk_sc_gate_toggle(sg, true);\n\tudelay(sg->udelay);\n\n\treturn 0;\n}\n\nstatic int sprd_gate_is_enabled(struct clk_hw *hw)\n{\n\tstruct sprd_gate *sg = hw_to_sprd_gate(hw);\n\tstruct sprd_clk_common *common = &sg->common;\n\tstruct clk_hw *parent;\n\tunsigned int reg;\n\n\tif (sg->flags & SPRD_GATE_NON_AON) {\n\t\tparent = clk_hw_get_parent(hw);\n\t\tif (!parent || !clk_hw_is_enabled(parent))\n\t\t\treturn 0;\n\t}\n\n\tregmap_read(common->regmap, common->reg, &reg);\n\n\tif (sg->flags & CLK_GATE_SET_TO_DISABLE)\n\t\treg ^= sg->enable_mask;\n\n\treg &= sg->enable_mask;\n\n\treturn reg ? 1 : 0;\n}\n\nconst struct clk_ops sprd_gate_ops = {\n\t.disable\t= sprd_gate_disable,\n\t.enable\t\t= sprd_gate_enable,\n\t.is_enabled\t= sprd_gate_is_enabled,\n};\nEXPORT_SYMBOL_GPL(sprd_gate_ops);\n\nconst struct clk_ops sprd_sc_gate_ops = {\n\t.disable\t= sprd_sc_gate_disable,\n\t.enable\t\t= sprd_sc_gate_enable,\n\t.is_enabled\t= sprd_gate_is_enabled,\n};\nEXPORT_SYMBOL_GPL(sprd_sc_gate_ops);\n\nconst struct clk_ops sprd_pll_sc_gate_ops = {\n\t.unprepare\t= sprd_sc_gate_disable,\n\t.prepare\t= sprd_pll_sc_gate_prepare,\n\t.is_enabled\t= sprd_gate_is_enabled,\n};\nEXPORT_SYMBOL_GPL(sprd_pll_sc_gate_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}