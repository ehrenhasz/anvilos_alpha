{
  "module_name": "common.c",
  "hash_id": "2e53e49240603d876b1dc612cd75ffe00cf5e47bb74661fa85f03c1c7647b610",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sprd/common.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include \"common.h\"\n\nstatic const struct regmap_config sprdclk_regmap_config = {\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n\t.fast_io\t= true,\n};\n\nstatic void sprd_clk_set_regmap(const struct sprd_clk_desc *desc,\n\t\t\t struct regmap *regmap)\n{\n\tint i;\n\tstruct sprd_clk_common *cclk;\n\n\tfor (i = 0; i < desc->num_clk_clks; i++) {\n\t\tcclk = desc->clk_clks[i];\n\t\tif (!cclk)\n\t\t\tcontinue;\n\n\t\tcclk->regmap = regmap;\n\t}\n}\n\nint sprd_clk_regmap_init(struct platform_device *pdev,\n\t\t\t const struct sprd_clk_desc *desc)\n{\n\tvoid __iomem *base;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node, *np;\n\tstruct regmap *regmap;\n\tstruct resource *res;\n\tstruct regmap_config reg_config = sprdclk_regmap_config;\n\n\tif (of_property_present(node, \"sprd,syscon\")) {\n\t\tregmap = syscon_regmap_lookup_by_phandle(node, \"sprd,syscon\");\n\t\tif (IS_ERR(regmap)) {\n\t\t\tpr_err(\"%s: failed to get syscon regmap\\n\", __func__);\n\t\t\treturn PTR_ERR(regmap);\n\t\t}\n\t} else if (of_device_is_compatible(np =\tof_get_parent(node), \"syscon\") ||\n\t\t   (of_node_put(np), 0)) {\n\t\tregmap = device_node_to_regmap(np);\n\t\tof_node_put(np);\n\t\tif (IS_ERR(regmap)) {\n\t\t\tdev_err(dev, \"failed to get regmap from its parent.\\n\");\n\t\t\treturn PTR_ERR(regmap);\n\t\t}\n\t} else {\n\t\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\t\tif (IS_ERR(base))\n\t\t\treturn PTR_ERR(base);\n\n\t\treg_config.max_register = resource_size(res) - reg_config.reg_stride;\n\n\t\tregmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t       &reg_config);\n\t\tif (IS_ERR(regmap)) {\n\t\t\tpr_err(\"failed to init regmap\\n\");\n\t\t\treturn PTR_ERR(regmap);\n\t\t}\n\t}\n\n\tsprd_clk_set_regmap(desc, regmap);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sprd_clk_regmap_init);\n\nint sprd_clk_probe(struct device *dev, struct clk_hw_onecell_data *clkhw)\n{\n\tint i, ret;\n\tstruct clk_hw *hw;\n\n\tfor (i = 0; i < clkhw->num; i++) {\n\t\tconst char *name;\n\n\t\thw = clkhw->hws[i];\n\t\tif (!hw)\n\t\t\tcontinue;\n\n\t\tname = hw->init->name;\n\t\tret = devm_clk_hw_register(dev, hw);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Couldn't register clock %d - %s\\n\",\n\t\t\t\ti, name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clkhw);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to add clock provider\\n\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sprd_clk_probe);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}