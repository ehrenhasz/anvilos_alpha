{
  "module_name": "pll.c",
  "hash_id": "e0a9b2a27f50e084f7c23dbc65819b729b3ad0e9683a980dab1817bea7583856",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/sprd/pll.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"pll.h\"\n\n#define CLK_PLL_1M\t1000000\n#define CLK_PLL_10M\t(CLK_PLL_1M * 10)\n\n#define pindex(pll, member)\t\t\\\n\t(pll->factors[member].shift / (8 * sizeof(pll->regs_num)))\n\n#define pshift(pll, member)\t\t\\\n\t(pll->factors[member].shift % (8 * sizeof(pll->regs_num)))\n\n#define pwidth(pll, member)\t\t\\\n\tpll->factors[member].width\n\n#define pmask(pll, member)\t\t\t\t\t\\\n\t((pwidth(pll, member)) ?\t\t\t\t\\\n\tGENMASK(pwidth(pll, member) + pshift(pll, member) - 1,\t\\\n\tpshift(pll, member)) : 0)\n\n#define pinternal(pll, cfg, member)\t\\\n\t(cfg[pindex(pll, member)] & pmask(pll, member))\n\n#define pinternal_val(pll, cfg, member)\t\\\n\t(pinternal(pll, cfg, member) >> pshift(pll, member))\n\nstatic inline unsigned int\nsprd_pll_read(const struct sprd_pll *pll, u8 index)\n{\n\tconst struct sprd_clk_common *common = &pll->common;\n\tunsigned int val = 0;\n\n\tif (WARN_ON(index >= pll->regs_num))\n\t\treturn 0;\n\n\tregmap_read(common->regmap, common->reg + index * 4, &val);\n\n\treturn val;\n}\n\nstatic inline void\nsprd_pll_write(const struct sprd_pll *pll, u8 index,\n\t\t\t\t  u32 msk, u32 val)\n{\n\tconst struct sprd_clk_common *common = &pll->common;\n\tunsigned int offset, reg;\n\tint ret = 0;\n\n\tif (WARN_ON(index >= pll->regs_num))\n\t\treturn;\n\n\toffset = common->reg + index * 4;\n\tret = regmap_read(common->regmap, offset, &reg);\n\tif (!ret)\n\t\tregmap_write(common->regmap, offset, (reg & ~msk) | val);\n}\n\nstatic unsigned long pll_get_refin(const struct sprd_pll *pll)\n{\n\tu32 shift, mask, index, refin_id = 3;\n\tconst unsigned long refin[4] = { 2, 4, 13, 26 };\n\n\tif (pwidth(pll, PLL_REFIN)) {\n\t\tindex = pindex(pll, PLL_REFIN);\n\t\tshift = pshift(pll, PLL_REFIN);\n\t\tmask = pmask(pll, PLL_REFIN);\n\t\trefin_id = (sprd_pll_read(pll, index) & mask) >> shift;\n\t\tif (refin_id > 3)\n\t\t\trefin_id = 3;\n\t}\n\n\treturn refin[refin_id];\n}\n\nstatic u32 pll_get_ibias(u64 rate, const u64 *table)\n{\n\tu32 i, num = table[0];\n\n\t \n\tfor (i = 0; i < num; i++)\n\t\tif (rate <= table[i + 1])\n\t\t\tbreak;\n\n\treturn i == num ? num - 1 : i;\n}\n\nstatic unsigned long _sprd_pll_recalc_rate(const struct sprd_pll *pll,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tu32 *cfg;\n\tu32 i, mask, regs_num = pll->regs_num;\n\tunsigned long rate, nint, kint = 0;\n\tu64 refin;\n\tu16 k1, k2;\n\n\tcfg = kcalloc(regs_num, sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn parent_rate;\n\n\tfor (i = 0; i < regs_num; i++)\n\t\tcfg[i] = sprd_pll_read(pll, i);\n\n\trefin = pll_get_refin(pll);\n\n\tif (pinternal(pll, cfg, PLL_PREDIV))\n\t\trefin = refin * 2;\n\n\tif (pwidth(pll, PLL_POSTDIV) &&\n\t    ((pll->fflag == 1 && pinternal(pll, cfg, PLL_POSTDIV)) ||\n\t     (!pll->fflag && !pinternal(pll, cfg, PLL_POSTDIV))))\n\t\trefin = refin / 2;\n\n\tif (!pinternal(pll, cfg, PLL_DIV_S)) {\n\t\trate = refin * pinternal_val(pll, cfg, PLL_N) * CLK_PLL_10M;\n\t} else {\n\t\tnint = pinternal_val(pll, cfg, PLL_NINT);\n\t\tif (pinternal(pll, cfg, PLL_SDM_EN))\n\t\t\tkint = pinternal_val(pll, cfg, PLL_KINT);\n\n\t\tmask = pmask(pll, PLL_KINT);\n\n\t\tk1 = pll->k1;\n\t\tk2 = pll->k2;\n\t\trate = DIV_ROUND_CLOSEST_ULL(refin * kint * k1,\n\t\t\t\t\t ((mask >> __ffs(mask)) + 1)) *\n\t\t\t\t\t k2 + refin * nint * CLK_PLL_1M;\n\t}\n\n\tkfree(cfg);\n\treturn rate;\n}\n\n#define SPRD_PLL_WRITE_CHECK(pll, i, mask, val)\t\t\\\n\t(((sprd_pll_read(pll, i) & mask) == val) ? 0 : (-EFAULT))\n\nstatic int _sprd_pll_set_rate(const struct sprd_pll *pll,\n\t\t\t      unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct reg_cfg *cfg;\n\tint ret = 0;\n\tu32 mask, shift, width, ibias_val, index;\n\tu32 regs_num = pll->regs_num, i = 0;\n\tunsigned long kint, nint;\n\tu64 tmp, refin, fvco = rate;\n\n\tcfg = kcalloc(regs_num, sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\trefin = pll_get_refin(pll);\n\n\tmask = pmask(pll, PLL_PREDIV);\n\tindex = pindex(pll, PLL_PREDIV);\n\twidth = pwidth(pll, PLL_PREDIV);\n\tif (width && (sprd_pll_read(pll, index) & mask))\n\t\trefin = refin * 2;\n\n\tmask = pmask(pll, PLL_POSTDIV);\n\tindex = pindex(pll, PLL_POSTDIV);\n\twidth = pwidth(pll, PLL_POSTDIV);\n\tcfg[index].msk = mask;\n\tif (width && ((pll->fflag == 1 && fvco <= pll->fvco) ||\n\t\t      (pll->fflag == 0 && fvco > pll->fvco)))\n\t\tcfg[index].val |= mask;\n\n\tif (width && fvco <= pll->fvco)\n\t\tfvco = fvco * 2;\n\n\tmask = pmask(pll, PLL_DIV_S);\n\tindex = pindex(pll, PLL_DIV_S);\n\tcfg[index].val |= mask;\n\tcfg[index].msk |= mask;\n\n\tmask = pmask(pll, PLL_SDM_EN);\n\tindex = pindex(pll, PLL_SDM_EN);\n\tcfg[index].val |= mask;\n\tcfg[index].msk |= mask;\n\n\tnint = do_div(fvco, refin * CLK_PLL_1M);\n\tmask = pmask(pll, PLL_NINT);\n\tindex = pindex(pll, PLL_NINT);\n\tshift = pshift(pll, PLL_NINT);\n\tcfg[index].val |= (nint << shift) & mask;\n\tcfg[index].msk |= mask;\n\n\tmask = pmask(pll, PLL_KINT);\n\tindex = pindex(pll, PLL_KINT);\n\twidth = pwidth(pll, PLL_KINT);\n\tshift = pshift(pll, PLL_KINT);\n\ttmp = fvco - refin * nint * CLK_PLL_1M;\n\ttmp = do_div(tmp, 10000) * ((mask >> shift) + 1);\n\tkint = DIV_ROUND_CLOSEST_ULL(tmp, refin * 100);\n\tcfg[index].val |= (kint << shift) & mask;\n\tcfg[index].msk |= mask;\n\n\tibias_val = pll_get_ibias(fvco, pll->itable);\n\n\tmask = pmask(pll, PLL_IBIAS);\n\tindex = pindex(pll, PLL_IBIAS);\n\tshift = pshift(pll, PLL_IBIAS);\n\tcfg[index].val |= ibias_val << shift & mask;\n\tcfg[index].msk |= mask;\n\n\tfor (i = 0; i < regs_num; i++) {\n\t\tif (cfg[i].msk) {\n\t\t\tsprd_pll_write(pll, i, cfg[i].msk, cfg[i].val);\n\t\t\tret |= SPRD_PLL_WRITE_CHECK(pll, i, cfg[i].msk,\n\t\t\t\t\t\t   cfg[i].val);\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tudelay(pll->udelay);\n\n\tkfree(cfg);\n\treturn ret;\n}\n\nstatic unsigned long sprd_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct sprd_pll *pll = hw_to_sprd_pll(hw);\n\n\treturn _sprd_pll_recalc_rate(pll, parent_rate);\n}\n\nstatic int sprd_pll_set_rate(struct clk_hw *hw,\n\t\t\t     unsigned long rate,\n\t\t\t     unsigned long parent_rate)\n{\n\tstruct sprd_pll *pll = hw_to_sprd_pll(hw);\n\n\treturn _sprd_pll_set_rate(pll, rate, parent_rate);\n}\n\nstatic int sprd_pll_clk_prepare(struct clk_hw *hw)\n{\n\tstruct sprd_pll *pll = hw_to_sprd_pll(hw);\n\n\tudelay(pll->udelay);\n\n\treturn 0;\n}\n\nstatic long sprd_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *prate)\n{\n\treturn rate;\n}\n\nconst struct clk_ops sprd_pll_ops = {\n\t.prepare = sprd_pll_clk_prepare,\n\t.recalc_rate = sprd_pll_recalc_rate,\n\t.round_rate = sprd_pll_round_rate,\n\t.set_rate = sprd_pll_set_rate,\n};\nEXPORT_SYMBOL_GPL(sprd_pll_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}