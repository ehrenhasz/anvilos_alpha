{
  "module_name": "clk-lan966x.c",
  "hash_id": "405665910856402f4837b749e0b1a29d4c6c42e4ca343916ea7265d77de90860",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-lan966x.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/clock/microchip,lan966x.h>\n\n#define GCK_ENA         BIT(0)\n#define GCK_SRC_SEL     GENMASK(9, 8)\n#define GCK_PRESCALER   GENMASK(23, 16)\n\n#define DIV_MAX\t\t255\n\nstatic const char *clk_names[N_CLOCKS] = {\n\t\"qspi0\", \"qspi1\", \"qspi2\", \"sdmmc0\",\n\t\"pi\", \"mcan0\", \"mcan1\", \"flexcom0\",\n\t\"flexcom1\", \"flexcom2\", \"flexcom3\",\n\t\"flexcom4\", \"timer1\", \"usb_refclk\",\n};\n\nstruct lan966x_gck {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n};\n#define to_lan966x_gck(hw) container_of(hw, struct lan966x_gck, hw)\n\nstatic const struct clk_parent_data lan966x_gck_pdata[] = {\n\t{ .fw_name = \"cpu\", },\n\t{ .fw_name = \"ddr\", },\n\t{ .fw_name = \"sys\", },\n};\n\nstatic struct clk_init_data init = {\n\t.parent_data = lan966x_gck_pdata,\n\t.num_parents = ARRAY_SIZE(lan966x_gck_pdata),\n};\n\nstruct clk_gate_soc_desc {\n\tconst char *name;\n\tint bit_idx;\n};\n\nstatic const struct clk_gate_soc_desc clk_gate_desc[] = {\n\t{ \"uhphs\", 11 },\n\t{ \"udphs\", 10 },\n\t{ \"mcramc\", 9 },\n\t{ \"hmatrix\", 8 },\n\t{ }\n};\n\nstatic DEFINE_SPINLOCK(clk_gate_lock);\nstatic void __iomem *base;\n\nstatic int lan966x_gck_enable(struct clk_hw *hw)\n{\n\tstruct lan966x_gck *gck = to_lan966x_gck(hw);\n\tu32 val = readl(gck->reg);\n\n\tval |= GCK_ENA;\n\twritel(val, gck->reg);\n\n\treturn 0;\n}\n\nstatic void lan966x_gck_disable(struct clk_hw *hw)\n{\n\tstruct lan966x_gck *gck = to_lan966x_gck(hw);\n\tu32 val = readl(gck->reg);\n\n\tval &= ~GCK_ENA;\n\twritel(val, gck->reg);\n}\n\nstatic int lan966x_gck_set_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct lan966x_gck *gck = to_lan966x_gck(hw);\n\tu32 div, val = readl(gck->reg);\n\n\tif (rate == 0 || parent_rate == 0)\n\t\treturn -EINVAL;\n\n\t \n\tdiv = parent_rate / rate;\n\tval &= ~GCK_PRESCALER;\n\tval |= FIELD_PREP(GCK_PRESCALER, (div - 1));\n\twritel(val, gck->reg);\n\n\treturn 0;\n}\n\nstatic unsigned long lan966x_gck_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct lan966x_gck *gck = to_lan966x_gck(hw);\n\tu32 div, val = readl(gck->reg);\n\n\tdiv = FIELD_GET(GCK_PRESCALER, val);\n\n\treturn parent_rate / (div + 1);\n}\n\nstatic int lan966x_gck_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tstruct clk_hw *parent;\n\tint i;\n\n\tfor (i = 0; i < clk_hw_get_num_parents(hw); ++i) {\n\t\tparent = clk_hw_get_parent_by_index(hw, i);\n\t\tif (!parent)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (clk_hw_get_rate(parent) / req->rate <= DIV_MAX) {\n\t\t\treq->best_parent_hw = parent;\n\t\t\treq->best_parent_rate = clk_hw_get_rate(parent);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic u8 lan966x_gck_get_parent(struct clk_hw *hw)\n{\n\tstruct lan966x_gck *gck = to_lan966x_gck(hw);\n\tu32 val = readl(gck->reg);\n\n\treturn FIELD_GET(GCK_SRC_SEL, val);\n}\n\nstatic int lan966x_gck_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct lan966x_gck *gck = to_lan966x_gck(hw);\n\tu32 val = readl(gck->reg);\n\n\tval &= ~GCK_SRC_SEL;\n\tval |= FIELD_PREP(GCK_SRC_SEL, index);\n\twritel(val, gck->reg);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops lan966x_gck_ops = {\n\t.enable         = lan966x_gck_enable,\n\t.disable        = lan966x_gck_disable,\n\t.set_rate       = lan966x_gck_set_rate,\n\t.recalc_rate    = lan966x_gck_recalc_rate,\n\t.determine_rate = lan966x_gck_determine_rate,\n\t.set_parent     = lan966x_gck_set_parent,\n\t.get_parent     = lan966x_gck_get_parent,\n};\n\nstatic struct clk_hw *lan966x_gck_clk_register(struct device *dev, int i)\n{\n\tstruct lan966x_gck *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpriv->reg = base + (i * 4);\n\tpriv->hw.init = &init;\n\tret = devm_clk_hw_register(dev, &priv->hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn &priv->hw;\n};\n\nstatic int lan966x_gate_clk_register(struct device *dev,\n\t\t\t\t     struct clk_hw_onecell_data *hw_data,\n\t\t\t\t     void __iomem *gate_base)\n{\n\tint i;\n\n\tfor (i = GCK_GATE_UHPHS; i < N_CLOCKS; ++i) {\n\t\tint idx = i - GCK_GATE_UHPHS;\n\n\t\thw_data->hws[i] =\n\t\t\tdevm_clk_hw_register_gate(dev, clk_gate_desc[idx].name,\n\t\t\t\t\t\t  \"lan966x\", 0, gate_base,\n\t\t\t\t\t\t  clk_gate_desc[idx].bit_idx,\n\t\t\t\t\t\t  0, &clk_gate_lock);\n\n\t\tif (IS_ERR(hw_data->hws[i]))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(hw_data->hws[i]),\n\t\t\t\t\t     \"failed to register %s clock\\n\",\n\t\t\t\t\t     clk_gate_desc[idx].name);\n\t}\n\n\treturn 0;\n}\n\nstatic int lan966x_clk_probe(struct platform_device *pdev)\n{\n\tstruct clk_hw_onecell_data *hw_data;\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *gate_base;\n\tstruct resource *res;\n\tint i, ret;\n\n\thw_data = devm_kzalloc(dev, struct_size(hw_data, hws, N_CLOCKS),\n\t\t\t       GFP_KERNEL);\n\tif (!hw_data)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tinit.ops = &lan966x_gck_ops;\n\n\thw_data->num = GCK_GATE_UHPHS;\n\n\tfor (i = 0; i < GCK_GATE_UHPHS; i++) {\n\t\tinit.name = clk_names[i];\n\t\thw_data->hws[i] = lan966x_gck_clk_register(dev, i);\n\t\tif (IS_ERR(hw_data->hws[i])) {\n\t\t\tdev_err(dev, \"failed to register %s clock\\n\",\n\t\t\t\tinit.name);\n\t\t\treturn PTR_ERR(hw_data->hws[i]);\n\t\t}\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (res) {\n\t\tgate_base = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(gate_base))\n\t\t\treturn PTR_ERR(gate_base);\n\n\t\thw_data->num = N_CLOCKS;\n\n\t\tret = lan966x_gate_clk_register(dev, hw_data, gate_base);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, hw_data);\n}\n\nstatic const struct of_device_id lan966x_clk_dt_ids[] = {\n\t{ .compatible = \"microchip,lan966x-gck\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lan966x_clk_dt_ids);\n\nstatic struct platform_driver lan966x_clk_driver = {\n\t.probe  = lan966x_clk_probe,\n\t.driver = {\n\t\t.name = \"lan966x-clk\",\n\t\t.of_match_table = lan966x_clk_dt_ids,\n\t},\n};\nmodule_platform_driver(lan966x_clk_driver);\n\nMODULE_AUTHOR(\"Kavyasree Kotagiri <kavyasree.kotagiri@microchip.com>\");\nMODULE_DESCRIPTION(\"LAN966X clock driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}