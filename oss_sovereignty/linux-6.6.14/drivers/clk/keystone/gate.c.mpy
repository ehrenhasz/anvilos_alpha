{
  "module_name": "gate.c",
  "hash_id": "053ac7e68995cd87b7e0355ec6a87f92fd3c7ab88fd1f9e3f0255abe7a6b9335",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/keystone/gate.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/module.h>\n\n \n#define PTCMD\t\t\t0x120\n#define PTSTAT\t\t\t0x128\n#define PDSTAT\t\t\t0x200\n#define PDCTL\t\t\t0x300\n#define MDSTAT\t\t\t0x800\n#define MDCTL\t\t\t0xa00\n\n \n#define PSC_STATE_SWRSTDISABLE\t0\n#define PSC_STATE_SYNCRST\t1\n#define PSC_STATE_DISABLE\t2\n#define PSC_STATE_ENABLE\t3\n\n#define MDSTAT_STATE_MASK\t0x3f\n#define MDSTAT_MCKOUT\t\tBIT(12)\n#define PDSTAT_STATE_MASK\t0x1f\n#define MDCTL_FORCE\t\tBIT(31)\n#define MDCTL_LRESET\t\tBIT(8)\n#define PDCTL_NEXT\t\tBIT(0)\n\n \n#define STATE_TRANS_MAX_COUNT\t0xffff\n\nstatic void __iomem *domain_transition_base;\n\n \nstruct clk_psc_data {\n\tvoid __iomem *control_base;\n\tvoid __iomem *domain_base;\n\tu32 domain_id;\n};\n\n \nstruct clk_psc {\n\tstruct clk_hw hw;\n\tstruct clk_psc_data *psc_data;\n\tspinlock_t *lock;\n};\n\nstatic DEFINE_SPINLOCK(psc_lock);\n\n#define to_clk_psc(_hw) container_of(_hw, struct clk_psc, hw)\n\nstatic void psc_config(void __iomem *control_base, void __iomem *domain_base,\n\t\t\t\t\t\tu32 next_state, u32 domain_id)\n{\n\tu32 ptcmd, pdstat, pdctl, mdstat, mdctl, ptstat;\n\tu32 count = STATE_TRANS_MAX_COUNT;\n\n\tmdctl = readl(control_base + MDCTL);\n\tmdctl &= ~MDSTAT_STATE_MASK;\n\tmdctl |= next_state;\n\t \n\tif (next_state == PSC_STATE_DISABLE)\n\t\tmdctl &= ~MDCTL_LRESET;\n\twritel(mdctl, control_base + MDCTL);\n\n\tpdstat = readl(domain_base + PDSTAT);\n\tif (!(pdstat & PDSTAT_STATE_MASK)) {\n\t\tpdctl = readl(domain_base + PDCTL);\n\t\tpdctl |= PDCTL_NEXT;\n\t\twritel(pdctl, domain_base + PDCTL);\n\t}\n\n\tptcmd = 1 << domain_id;\n\twritel(ptcmd, domain_transition_base + PTCMD);\n\tdo {\n\t\tptstat = readl(domain_transition_base + PTSTAT);\n\t} while (((ptstat >> domain_id) & 1) && count--);\n\n\tcount = STATE_TRANS_MAX_COUNT;\n\tdo {\n\t\tmdstat = readl(control_base + MDSTAT);\n\t} while (!((mdstat & MDSTAT_STATE_MASK) == next_state) && count--);\n}\n\nstatic int keystone_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_psc *psc = to_clk_psc(hw);\n\tstruct clk_psc_data *data = psc->psc_data;\n\tu32 mdstat = readl(data->control_base + MDSTAT);\n\n\treturn (mdstat & MDSTAT_MCKOUT) ? 1 : 0;\n}\n\nstatic int keystone_clk_enable(struct clk_hw *hw)\n{\n\tstruct clk_psc *psc = to_clk_psc(hw);\n\tstruct clk_psc_data *data = psc->psc_data;\n\tunsigned long flags = 0;\n\n\tif (psc->lock)\n\t\tspin_lock_irqsave(psc->lock, flags);\n\n\tpsc_config(data->control_base, data->domain_base,\n\t\t\t\tPSC_STATE_ENABLE, data->domain_id);\n\n\tif (psc->lock)\n\t\tspin_unlock_irqrestore(psc->lock, flags);\n\n\treturn 0;\n}\n\nstatic void keystone_clk_disable(struct clk_hw *hw)\n{\n\tstruct clk_psc *psc = to_clk_psc(hw);\n\tstruct clk_psc_data *data = psc->psc_data;\n\tunsigned long flags = 0;\n\n\tif (psc->lock)\n\t\tspin_lock_irqsave(psc->lock, flags);\n\n\tpsc_config(data->control_base, data->domain_base,\n\t\t\t\tPSC_STATE_DISABLE, data->domain_id);\n\n\tif (psc->lock)\n\t\tspin_unlock_irqrestore(psc->lock, flags);\n}\n\nstatic const struct clk_ops clk_psc_ops = {\n\t.enable = keystone_clk_enable,\n\t.disable = keystone_clk_disable,\n\t.is_enabled = keystone_clk_is_enabled,\n};\n\n \nstatic struct clk *clk_register_psc(struct device *dev,\n\t\t\tconst char *name,\n\t\t\tconst char *parent_name,\n\t\t\tstruct clk_psc_data *psc_data,\n\t\t\tspinlock_t *lock)\n{\n\tstruct clk_init_data init;\n\tstruct clk_psc *psc;\n\tstruct clk *clk;\n\n\tpsc = kzalloc(sizeof(*psc), GFP_KERNEL);\n\tif (!psc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &clk_psc_ops;\n\tinit.flags = 0;\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\n\tpsc->psc_data = psc_data;\n\tpsc->lock = lock;\n\tpsc->hw.init = &init;\n\n\tclk = clk_register(NULL, &psc->hw);\n\tif (IS_ERR(clk))\n\t\tkfree(psc);\n\n\treturn clk;\n}\n\n \nstatic void __init of_psc_clk_init(struct device_node *node, spinlock_t *lock)\n{\n\tconst char *clk_name = node->name;\n\tconst char *parent_name;\n\tstruct clk_psc_data *data;\n\tstruct clk *clk;\n\tint i;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tpr_err(\"%s: Out of memory\\n\", __func__);\n\t\treturn;\n\t}\n\n\ti = of_property_match_string(node, \"reg-names\", \"control\");\n\tdata->control_base = of_iomap(node, i);\n\tif (!data->control_base) {\n\t\tpr_err(\"%s: control ioremap failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\ti = of_property_match_string(node, \"reg-names\", \"domain\");\n\tdata->domain_base = of_iomap(node, i);\n\tif (!data->domain_base) {\n\t\tpr_err(\"%s: domain ioremap failed\\n\", __func__);\n\t\tgoto unmap_ctrl;\n\t}\n\n\tof_property_read_u32(node, \"domain-id\", &data->domain_id);\n\n\t \n\tif (!domain_transition_base && !data->domain_id)\n\t\tdomain_transition_base = data->domain_base;\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tif (!parent_name) {\n\t\tpr_err(\"%s: Parent clock not found\\n\", __func__);\n\t\tgoto unmap_domain;\n\t}\n\n\tclk = clk_register_psc(NULL, clk_name, parent_name, data, lock);\n\tif (!IS_ERR(clk)) {\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\t\treturn;\n\t}\n\n\tpr_err(\"%s: error registering clk %pOFn\\n\", __func__, node);\n\nunmap_domain:\n\tiounmap(data->domain_base);\nunmap_ctrl:\n\tiounmap(data->control_base);\nout:\n\tkfree(data);\n\treturn;\n}\n\n \nstatic void __init of_keystone_psc_clk_init(struct device_node *node)\n{\n\tof_psc_clk_init(node, &psc_lock);\n}\nCLK_OF_DECLARE(keystone_gate_clk, \"ti,keystone,psc-clock\",\n\t\t\t\t\tof_keystone_psc_clk_init);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Clock driver for Keystone 2 based devices\");\nMODULE_AUTHOR(\"Murali Karicheri <m-karicheri2@ti.com>\");\nMODULE_AUTHOR(\"Santosh Shilimkar <santosh.shilimkar@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}