{
  "module_name": "pll.c",
  "hash_id": "d43fcd128b834bbb5bca46ce36385120d5f0fb5a5fc1bb16b5040041825741a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/keystone/pll.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/module.h>\n\n#define PLLM_LOW_MASK\t\t0x3f\n#define PLLM_HIGH_MASK\t\t0x7ffc0\n#define MAIN_PLLM_HIGH_MASK\t0x7f000\n#define PLLM_HIGH_SHIFT\t\t6\n#define PLLD_MASK\t\t0x3f\n#define CLKOD_MASK\t\t0x780000\n#define CLKOD_SHIFT\t\t19\n\n \nstruct clk_pll_data {\n\tbool has_pllctrl;\n\tu32 phy_pllm;\n\tu32 phy_pll_ctl0;\n\tvoid __iomem *pllm;\n\tvoid __iomem *pllod;\n\tvoid __iomem *pll_ctl0;\n\tu32 pllm_lower_mask;\n\tu32 pllm_upper_mask;\n\tu32 pllm_upper_shift;\n\tu32 plld_mask;\n\tu32 clkod_mask;\n\tu32 clkod_shift;\n\tu32 postdiv;\n};\n\n \nstruct clk_pll {\n\tstruct clk_hw hw;\n\tstruct clk_pll_data *pll_data;\n};\n\n#define to_clk_pll(_hw) container_of(_hw, struct clk_pll, hw)\n\nstatic unsigned long clk_pllclk_recalc(struct clk_hw *hw,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_pll *pll = to_clk_pll(hw);\n\tstruct clk_pll_data *pll_data = pll->pll_data;\n\tunsigned long rate = parent_rate;\n\tu32  mult = 0, prediv, postdiv, val;\n\n\t \n\tif (pll_data->has_pllctrl) {\n\t\tval = readl(pll_data->pllm);\n\t\tmult = (val & pll_data->pllm_lower_mask);\n\t}\n\n\t \n\tval = readl(pll_data->pll_ctl0);\n\tmult |= ((val & pll_data->pllm_upper_mask)\n\t\t\t>> pll_data->pllm_upper_shift);\n\tprediv = (val & pll_data->plld_mask);\n\n\tif (!pll_data->has_pllctrl)\n\t\t \n\t\tpostdiv = ((val & pll_data->clkod_mask) >>\n\t\t\t\t pll_data->clkod_shift) + 1;\n\telse if (pll_data->pllod) {\n\t\tpostdiv = readl(pll_data->pllod);\n\t\tpostdiv = ((postdiv & pll_data->clkod_mask) >>\n\t\t\t\tpll_data->clkod_shift) + 1;\n\t} else\n\t\tpostdiv = pll_data->postdiv;\n\n\trate /= (prediv + 1);\n\trate = (rate * (mult + 1));\n\trate /= postdiv;\n\n\treturn rate;\n}\n\nstatic const struct clk_ops clk_pll_ops = {\n\t.recalc_rate = clk_pllclk_recalc,\n};\n\nstatic struct clk *clk_register_pll(struct device *dev,\n\t\t\tconst char *name,\n\t\t\tconst char *parent_name,\n\t\t\tstruct clk_pll_data *pll_data)\n{\n\tstruct clk_init_data init;\n\tstruct clk_pll *pll;\n\tstruct clk *clk;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &clk_pll_ops;\n\tinit.flags = 0;\n\tinit.parent_names = (parent_name ? &parent_name : NULL);\n\tinit.num_parents = (parent_name ? 1 : 0);\n\n\tpll->pll_data\t= pll_data;\n\tpll->hw.init = &init;\n\n\tclk = clk_register(NULL, &pll->hw);\n\tif (IS_ERR(clk))\n\t\tgoto out;\n\n\treturn clk;\nout:\n\tkfree(pll);\n\treturn NULL;\n}\n\n \nstatic void __init _of_pll_clk_init(struct device_node *node, bool pllctrl)\n{\n\tstruct clk_pll_data *pll_data;\n\tconst char *parent_name;\n\tstruct clk *clk;\n\tint i;\n\n\tpll_data = kzalloc(sizeof(*pll_data), GFP_KERNEL);\n\tif (!pll_data) {\n\t\tpr_err(\"%s: Out of memory\\n\", __func__);\n\t\treturn;\n\t}\n\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tif (of_property_read_u32(node, \"fixed-postdiv\",\t&pll_data->postdiv)) {\n\t\t \n\t\tpll_data->clkod_mask = CLKOD_MASK;\n\t\tpll_data->clkod_shift = CLKOD_SHIFT;\n\n\t\t \n\t\ti = of_property_match_string(node, \"reg-names\",\n\t\t\t\t\t     \"post-divider\");\n\t\tpll_data->pllod = of_iomap(node, i);\n\t}\n\n\ti = of_property_match_string(node, \"reg-names\", \"control\");\n\tpll_data->pll_ctl0 = of_iomap(node, i);\n\tif (!pll_data->pll_ctl0) {\n\t\tpr_err(\"%s: ioremap failed\\n\", __func__);\n\t\tiounmap(pll_data->pllod);\n\t\tgoto out;\n\t}\n\n\tpll_data->pllm_lower_mask = PLLM_LOW_MASK;\n\tpll_data->pllm_upper_shift = PLLM_HIGH_SHIFT;\n\tpll_data->plld_mask = PLLD_MASK;\n\tpll_data->has_pllctrl = pllctrl;\n\tif (!pll_data->has_pllctrl) {\n\t\tpll_data->pllm_upper_mask = PLLM_HIGH_MASK;\n\t} else {\n\t\tpll_data->pllm_upper_mask = MAIN_PLLM_HIGH_MASK;\n\t\ti = of_property_match_string(node, \"reg-names\", \"multiplier\");\n\t\tpll_data->pllm = of_iomap(node, i);\n\t\tif (!pll_data->pllm) {\n\t\t\tiounmap(pll_data->pll_ctl0);\n\t\t\tiounmap(pll_data->pllod);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tclk = clk_register_pll(NULL, node->name, parent_name, pll_data);\n\tif (!IS_ERR_OR_NULL(clk)) {\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\t\treturn;\n\t}\n\nout:\n\tpr_err(\"%s: error initializing pll %pOFn\\n\", __func__, node);\n\tkfree(pll_data);\n}\n\n \nstatic void __init of_keystone_pll_clk_init(struct device_node *node)\n{\n\t_of_pll_clk_init(node, false);\n}\nCLK_OF_DECLARE(keystone_pll_clock, \"ti,keystone,pll-clock\",\n\t\t\t\t\tof_keystone_pll_clk_init);\n\n \nstatic void __init of_keystone_main_pll_clk_init(struct device_node *node)\n{\n\t_of_pll_clk_init(node, true);\n}\nCLK_OF_DECLARE(keystone_main_pll_clock, \"ti,keystone,main-pll-clock\",\n\t\t\t\t\t\tof_keystone_main_pll_clk_init);\n\n \nstatic void __init of_pll_div_clk_init(struct device_node *node)\n{\n\tconst char *parent_name;\n\tvoid __iomem *reg;\n\tu32 shift, mask;\n\tstruct clk *clk;\n\tconst char *clk_name = node->name;\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\treg = of_iomap(node, 0);\n\tif (!reg) {\n\t\tpr_err(\"%s: ioremap failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\tparent_name = of_clk_get_parent_name(node, 0);\n\tif (!parent_name) {\n\t\tpr_err(\"%s: missing parent clock\\n\", __func__);\n\t\tiounmap(reg);\n\t\treturn;\n\t}\n\n\tif (of_property_read_u32(node, \"bit-shift\", &shift)) {\n\t\tpr_err(\"%s: missing 'shift' property\\n\", __func__);\n\t\tiounmap(reg);\n\t\treturn;\n\t}\n\n\tif (of_property_read_u32(node, \"bit-mask\", &mask)) {\n\t\tpr_err(\"%s: missing 'bit-mask' property\\n\", __func__);\n\t\tiounmap(reg);\n\t\treturn;\n\t}\n\n\tclk = clk_register_divider(NULL, clk_name, parent_name, 0, reg, shift,\n\t\t\t\t mask, 0, NULL);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: error registering divider %s\\n\", __func__, clk_name);\n\t\tiounmap(reg);\n\t\treturn;\n\t}\n\n\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n}\nCLK_OF_DECLARE(pll_divider_clock, \"ti,keystone,pll-divider-clock\", of_pll_div_clk_init);\n\n \nstatic void __init of_pll_mux_clk_init(struct device_node *node)\n{\n\tvoid __iomem *reg;\n\tu32 shift, mask;\n\tstruct clk *clk;\n\tconst char *parents[2];\n\tconst char *clk_name = node->name;\n\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\treg = of_iomap(node, 0);\n\tif (!reg) {\n\t\tpr_err(\"%s: ioremap failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\tof_clk_parent_fill(node, parents, 2);\n\tif (!parents[0] || !parents[1]) {\n\t\tpr_err(\"%s: missing parent clocks\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (of_property_read_u32(node, \"bit-shift\", &shift)) {\n\t\tpr_err(\"%s: missing 'shift' property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (of_property_read_u32(node, \"bit-mask\", &mask)) {\n\t\tpr_err(\"%s: missing 'bit-mask' property\\n\", __func__);\n\t\treturn;\n\t}\n\n\tclk = clk_register_mux(NULL, clk_name, (const char **)&parents,\n\t\t\t\tARRAY_SIZE(parents) , 0, reg, shift, mask,\n\t\t\t\t0, NULL);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: error registering mux %s\\n\", __func__, clk_name);\n\t\treturn;\n\t}\n\n\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n}\nCLK_OF_DECLARE(pll_mux_clock, \"ti,keystone,pll-mux-clock\", of_pll_mux_clk_init);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"PLL clock driver for Keystone devices\");\nMODULE_AUTHOR(\"Murali Karicheri <m-karicheri2@ti.com>\");\nMODULE_AUTHOR(\"Santosh Shilimkar <santosh.shilimkar@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}