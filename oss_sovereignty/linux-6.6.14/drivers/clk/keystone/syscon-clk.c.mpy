{
  "module_name": "syscon-clk.c",
  "hash_id": "5db16f0330a88a367cf520d768b5223fc4490ec18dc51d4b89fcff1dcdcf6c27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/keystone/syscon-clk.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\nstruct ti_syscon_gate_clk_priv {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tu32 reg;\n\tu32 idx;\n};\n\nstruct ti_syscon_gate_clk_data {\n\tchar *name;\n\tu32 offset;\n\tu32 bit_idx;\n};\n\nstatic struct\nti_syscon_gate_clk_priv *to_ti_syscon_gate_clk_priv(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct ti_syscon_gate_clk_priv, hw);\n}\n\nstatic int ti_syscon_gate_clk_enable(struct clk_hw *hw)\n{\n\tstruct ti_syscon_gate_clk_priv *priv = to_ti_syscon_gate_clk_priv(hw);\n\n\treturn regmap_write_bits(priv->regmap, priv->reg, priv->idx,\n\t\t\t\t priv->idx);\n}\n\nstatic void ti_syscon_gate_clk_disable(struct clk_hw *hw)\n{\n\tstruct ti_syscon_gate_clk_priv *priv = to_ti_syscon_gate_clk_priv(hw);\n\n\tregmap_write_bits(priv->regmap, priv->reg, priv->idx, 0);\n}\n\nstatic int ti_syscon_gate_clk_is_enabled(struct clk_hw *hw)\n{\n\tunsigned int val;\n\tstruct ti_syscon_gate_clk_priv *priv = to_ti_syscon_gate_clk_priv(hw);\n\n\tregmap_read(priv->regmap, priv->reg, &val);\n\n\treturn !!(val & priv->idx);\n}\n\nstatic const struct clk_ops ti_syscon_gate_clk_ops = {\n\t.enable\t\t= ti_syscon_gate_clk_enable,\n\t.disable\t= ti_syscon_gate_clk_disable,\n\t.is_enabled\t= ti_syscon_gate_clk_is_enabled,\n};\n\nstatic struct clk_hw\n*ti_syscon_gate_clk_register(struct device *dev, struct regmap *regmap,\n\t\t\t     const char *parent_name,\n\t\t\t     const struct ti_syscon_gate_clk_data *data)\n{\n\tstruct ti_syscon_gate_clk_priv *priv;\n\tstruct clk_init_data init;\n\tchar *name = NULL;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.ops = &ti_syscon_gate_clk_ops;\n\tif (parent_name) {\n\t\tname = kasprintf(GFP_KERNEL, \"%s:%s\", data->name, parent_name);\n\t\tinit.name = name;\n\t\tinit.parent_names = &parent_name;\n\t\tinit.num_parents = 1;\n\t\tinit.flags = CLK_SET_RATE_PARENT;\n\t} else {\n\t\tinit.name = data->name;\n\t\tinit.parent_names = NULL;\n\t\tinit.num_parents = 0;\n\t\tinit.flags = 0;\n\t}\n\n\tpriv->regmap = regmap;\n\tpriv->reg = data->offset;\n\tpriv->idx = BIT(data->bit_idx);\n\tpriv->hw.init = &init;\n\n\tret = devm_clk_hw_register(dev, &priv->hw);\n\n\tif (name)\n\t\tkfree(init.name);\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn &priv->hw;\n}\n\nstatic int ti_syscon_gate_clk_probe(struct platform_device *pdev)\n{\n\tconst struct ti_syscon_gate_clk_data *data, *p;\n\tstruct clk_hw_onecell_data *hw_data;\n\tstruct device *dev = &pdev->dev;\n\tint num_clks, num_parents, i;\n\tconst char *parent_name;\n\tstruct regmap *regmap;\n\n\tdata = device_get_match_data(dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tregmap = device_node_to_regmap(dev->of_node);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap),\n\t\t\t\t     \"failed to get regmap\\n\");\n\n\tnum_clks = 0;\n\tfor (p = data; p->name; p++)\n\t\tnum_clks++;\n\n\tnum_parents = of_clk_get_parent_count(dev->of_node);\n\tif (of_device_is_compatible(dev->of_node, \"ti,am62-audio-refclk\") &&\n\t    num_parents == 0) {\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"must specify a parent clock\\n\");\n\t}\n\n\thw_data = devm_kzalloc(dev, struct_size(hw_data, hws, num_clks),\n\t\t\t       GFP_KERNEL);\n\tif (!hw_data)\n\t\treturn -ENOMEM;\n\n\thw_data->num = num_clks;\n\n\tparent_name = of_clk_get_parent_name(dev->of_node, 0);\n\tfor (i = 0; i < num_clks; i++) {\n\t\thw_data->hws[i] = ti_syscon_gate_clk_register(dev, regmap,\n\t\t\t\t\t\t\t      parent_name,\n\t\t\t\t\t\t\t      &data[i]);\n\t\tif (IS_ERR(hw_data->hws[i]))\n\t\t\tdev_warn(dev, \"failed to register %s\\n\",\n\t\t\t\t data[i].name);\n\t}\n\n\tif (num_clks == 1)\n\t\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,\n\t\t\t\t\t\t   hw_data->hws[0]);\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, hw_data);\n}\n\n#define TI_SYSCON_CLK_GATE(_name, _offset, _bit_idx)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\\\n\t\t.offset = (_offset),\t\t\t\\\n\t\t.bit_idx = (_bit_idx),\t\t\t\\\n\t}\n\nstatic const struct ti_syscon_gate_clk_data am654_clk_data[] = {\n\tTI_SYSCON_CLK_GATE(\"ehrpwm_tbclk0\", 0x0, 0),\n\tTI_SYSCON_CLK_GATE(\"ehrpwm_tbclk1\", 0x4, 0),\n\tTI_SYSCON_CLK_GATE(\"ehrpwm_tbclk2\", 0x8, 0),\n\tTI_SYSCON_CLK_GATE(\"ehrpwm_tbclk3\", 0xc, 0),\n\tTI_SYSCON_CLK_GATE(\"ehrpwm_tbclk4\", 0x10, 0),\n\tTI_SYSCON_CLK_GATE(\"ehrpwm_tbclk5\", 0x14, 0),\n\t{   },\n};\n\nstatic const struct ti_syscon_gate_clk_data am64_clk_data[] = {\n\tTI_SYSCON_CLK_GATE(\"epwm_tbclk0\", 0x0, 0),\n\tTI_SYSCON_CLK_GATE(\"epwm_tbclk1\", 0x0, 1),\n\tTI_SYSCON_CLK_GATE(\"epwm_tbclk2\", 0x0, 2),\n\tTI_SYSCON_CLK_GATE(\"epwm_tbclk3\", 0x0, 3),\n\tTI_SYSCON_CLK_GATE(\"epwm_tbclk4\", 0x0, 4),\n\tTI_SYSCON_CLK_GATE(\"epwm_tbclk5\", 0x0, 5),\n\tTI_SYSCON_CLK_GATE(\"epwm_tbclk6\", 0x0, 6),\n\tTI_SYSCON_CLK_GATE(\"epwm_tbclk7\", 0x0, 7),\n\tTI_SYSCON_CLK_GATE(\"epwm_tbclk8\", 0x0, 8),\n\t{   },\n};\n\nstatic const struct ti_syscon_gate_clk_data am62_clk_data[] = {\n\tTI_SYSCON_CLK_GATE(\"epwm_tbclk0\", 0x0, 0),\n\tTI_SYSCON_CLK_GATE(\"epwm_tbclk1\", 0x0, 1),\n\tTI_SYSCON_CLK_GATE(\"epwm_tbclk2\", 0x0, 2),\n\t{   },\n};\n\nstatic const struct ti_syscon_gate_clk_data am62_audio_clk_data[] = {\n\tTI_SYSCON_CLK_GATE(\"audio_refclk\", 0x0, 15),\n\t{   },\n};\n\nstatic const struct of_device_id ti_syscon_gate_clk_ids[] = {\n\t{\n\t\t.compatible = \"ti,am654-ehrpwm-tbclk\",\n\t\t.data = &am654_clk_data,\n\t},\n\t{\n\t\t.compatible = \"ti,am64-epwm-tbclk\",\n\t\t.data = &am64_clk_data,\n\t},\n\t{\n\t\t.compatible = \"ti,am62-epwm-tbclk\",\n\t\t.data = &am62_clk_data,\n\t},\n\t{\n\t\t.compatible = \"ti,am62-audio-refclk\",\n\t\t.data = &am62_audio_clk_data,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ti_syscon_gate_clk_ids);\n\nstatic struct platform_driver ti_syscon_gate_clk_driver = {\n\t.probe = ti_syscon_gate_clk_probe,\n\t.driver = {\n\t\t.name = \"ti-syscon-gate-clk\",\n\t\t.of_match_table = ti_syscon_gate_clk_ids,\n\t},\n};\nmodule_platform_driver(ti_syscon_gate_clk_driver);\n\nMODULE_AUTHOR(\"Vignesh Raghavendra <vigneshr@ti.com>\");\nMODULE_DESCRIPTION(\"Syscon backed gate-clock driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}