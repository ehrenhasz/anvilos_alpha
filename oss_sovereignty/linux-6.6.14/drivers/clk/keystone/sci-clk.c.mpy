{
  "module_name": "sci-clk.c",
  "hash_id": "c27324f308bc57f0ae774604c926e3ff1e2b2668a396c1df406ed1325720f7e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/keystone/sci-clk.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/soc/ti/ti_sci_protocol.h>\n#include <linux/bsearch.h>\n#include <linux/list_sort.h>\n\n#define SCI_CLK_SSC_ENABLE\t\tBIT(0)\n#define SCI_CLK_ALLOW_FREQ_CHANGE\tBIT(1)\n#define SCI_CLK_INPUT_TERMINATION\tBIT(2)\n\n \nstruct sci_clk_provider {\n\tconst struct ti_sci_handle *sci;\n\tconst struct ti_sci_clk_ops *ops;\n\tstruct device *dev;\n\tstruct sci_clk **clocks;\n\tint num_clocks;\n};\n\n \nstruct sci_clk {\n\tstruct clk_hw hw;\n\tu16 dev_id;\n\tu32 clk_id;\n\tu32 num_parents;\n\tstruct sci_clk_provider *provider;\n\tu8 flags;\n\tstruct list_head node;\n\tunsigned long cached_req;\n\tunsigned long cached_res;\n};\n\n#define to_sci_clk(_hw) container_of(_hw, struct sci_clk, hw)\n\n \nstatic int sci_clk_prepare(struct clk_hw *hw)\n{\n\tstruct sci_clk *clk = to_sci_clk(hw);\n\tbool enable_ssc = clk->flags & SCI_CLK_SSC_ENABLE;\n\tbool allow_freq_change = clk->flags & SCI_CLK_ALLOW_FREQ_CHANGE;\n\tbool input_termination = clk->flags & SCI_CLK_INPUT_TERMINATION;\n\n\treturn clk->provider->ops->get_clock(clk->provider->sci, clk->dev_id,\n\t\t\t\t\t     clk->clk_id, enable_ssc,\n\t\t\t\t\t     allow_freq_change,\n\t\t\t\t\t     input_termination);\n}\n\n \nstatic void sci_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct sci_clk *clk = to_sci_clk(hw);\n\tint ret;\n\n\tret = clk->provider->ops->put_clock(clk->provider->sci, clk->dev_id,\n\t\t\t\t\t    clk->clk_id);\n\tif (ret)\n\t\tdev_err(clk->provider->dev,\n\t\t\t\"unprepare failed for dev=%d, clk=%d, ret=%d\\n\",\n\t\t\tclk->dev_id, clk->clk_id, ret);\n}\n\n \nstatic int sci_clk_is_prepared(struct clk_hw *hw)\n{\n\tstruct sci_clk *clk = to_sci_clk(hw);\n\tbool req_state, current_state;\n\tint ret;\n\n\tret = clk->provider->ops->is_on(clk->provider->sci, clk->dev_id,\n\t\t\t\t\tclk->clk_id, &req_state,\n\t\t\t\t\t&current_state);\n\tif (ret) {\n\t\tdev_err(clk->provider->dev,\n\t\t\t\"is_prepared failed for dev=%d, clk=%d, ret=%d\\n\",\n\t\t\tclk->dev_id, clk->clk_id, ret);\n\t\treturn 0;\n\t}\n\n\treturn req_state;\n}\n\n \nstatic unsigned long sci_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct sci_clk *clk = to_sci_clk(hw);\n\tu64 freq;\n\tint ret;\n\n\tret = clk->provider->ops->get_freq(clk->provider->sci, clk->dev_id,\n\t\t\t\t\t   clk->clk_id, &freq);\n\tif (ret) {\n\t\tdev_err(clk->provider->dev,\n\t\t\t\"recalc-rate failed for dev=%d, clk=%d, ret=%d\\n\",\n\t\t\tclk->dev_id, clk->clk_id, ret);\n\t\treturn 0;\n\t}\n\n\treturn freq;\n}\n\n \nstatic int sci_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t  struct clk_rate_request *req)\n{\n\tstruct sci_clk *clk = to_sci_clk(hw);\n\tint ret;\n\tu64 new_rate;\n\n\tif (clk->cached_req && clk->cached_req == req->rate) {\n\t\treq->rate = clk->cached_res;\n\t\treturn 0;\n\t}\n\n\tret = clk->provider->ops->get_best_match_freq(clk->provider->sci,\n\t\t\t\t\t\t      clk->dev_id,\n\t\t\t\t\t\t      clk->clk_id,\n\t\t\t\t\t\t      req->min_rate,\n\t\t\t\t\t\t      req->rate,\n\t\t\t\t\t\t      req->max_rate,\n\t\t\t\t\t\t      &new_rate);\n\tif (ret) {\n\t\tdev_err(clk->provider->dev,\n\t\t\t\"determine-rate failed for dev=%d, clk=%d, ret=%d\\n\",\n\t\t\tclk->dev_id, clk->clk_id, ret);\n\t\treturn ret;\n\t}\n\n\tclk->cached_req = req->rate;\n\tclk->cached_res = new_rate;\n\n\treq->rate = new_rate;\n\n\treturn 0;\n}\n\n \nstatic int sci_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct sci_clk *clk = to_sci_clk(hw);\n\n\treturn clk->provider->ops->set_freq(clk->provider->sci, clk->dev_id,\n\t\t\t\t\t    clk->clk_id, rate / 10 * 9, rate,\n\t\t\t\t\t    rate / 10 * 11);\n}\n\n \nstatic u8 sci_clk_get_parent(struct clk_hw *hw)\n{\n\tstruct sci_clk *clk = to_sci_clk(hw);\n\tu32 parent_id = 0;\n\tint ret;\n\n\tret = clk->provider->ops->get_parent(clk->provider->sci, clk->dev_id,\n\t\t\t\t\t     clk->clk_id, (void *)&parent_id);\n\tif (ret) {\n\t\tdev_err(clk->provider->dev,\n\t\t\t\"get-parent failed for dev=%d, clk=%d, ret=%d\\n\",\n\t\t\tclk->dev_id, clk->clk_id, ret);\n\t\treturn 0;\n\t}\n\n\tparent_id = parent_id - clk->clk_id - 1;\n\n\treturn (u8)parent_id;\n}\n\n \nstatic int sci_clk_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct sci_clk *clk = to_sci_clk(hw);\n\n\tclk->cached_req = 0;\n\n\treturn clk->provider->ops->set_parent(clk->provider->sci, clk->dev_id,\n\t\t\t\t\t      clk->clk_id,\n\t\t\t\t\t      index + 1 + clk->clk_id);\n}\n\nstatic const struct clk_ops sci_clk_ops = {\n\t.prepare = sci_clk_prepare,\n\t.unprepare = sci_clk_unprepare,\n\t.is_prepared = sci_clk_is_prepared,\n\t.recalc_rate = sci_clk_recalc_rate,\n\t.determine_rate = sci_clk_determine_rate,\n\t.set_rate = sci_clk_set_rate,\n\t.get_parent = sci_clk_get_parent,\n\t.set_parent = sci_clk_set_parent,\n};\n\n \nstatic int _sci_clk_build(struct sci_clk_provider *provider,\n\t\t\t  struct sci_clk *sci_clk)\n{\n\tstruct clk_init_data init = { NULL };\n\tchar *name = NULL;\n\tchar **parent_names = NULL;\n\tint i;\n\tint ret = 0;\n\n\tname = kasprintf(GFP_KERNEL, \"clk:%d:%d\", sci_clk->dev_id,\n\t\t\t sci_clk->clk_id);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tinit.name = name;\n\n\t \n\tif (sci_clk->num_parents < 2)\n\t\tsci_clk->num_parents = 0;\n\n\tif (sci_clk->num_parents) {\n\t\tparent_names = kcalloc(sci_clk->num_parents, sizeof(char *),\n\t\t\t\t       GFP_KERNEL);\n\n\t\tif (!parent_names) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tfor (i = 0; i < sci_clk->num_parents; i++) {\n\t\t\tchar *parent_name;\n\n\t\t\tparent_name = kasprintf(GFP_KERNEL, \"clk:%d:%d\",\n\t\t\t\t\t\tsci_clk->dev_id,\n\t\t\t\t\t\tsci_clk->clk_id + 1 + i);\n\t\t\tif (!parent_name) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tparent_names[i] = parent_name;\n\t\t}\n\t\tinit.parent_names = (void *)parent_names;\n\t}\n\n\tinit.ops = &sci_clk_ops;\n\tinit.num_parents = sci_clk->num_parents;\n\tsci_clk->hw.init = &init;\n\n\tret = devm_clk_hw_register(provider->dev, &sci_clk->hw);\n\tif (ret)\n\t\tdev_err(provider->dev, \"failed clk register with %d\\n\", ret);\n\nerr:\n\tif (parent_names) {\n\t\tfor (i = 0; i < sci_clk->num_parents; i++)\n\t\t\tkfree(parent_names[i]);\n\n\t\tkfree(parent_names);\n\t}\n\n\tkfree(name);\n\n\treturn ret;\n}\n\nstatic int _cmp_sci_clk(const void *a, const void *b)\n{\n\tconst struct sci_clk *ca = a;\n\tconst struct sci_clk *cb = *(struct sci_clk **)b;\n\n\tif (ca->dev_id == cb->dev_id && ca->clk_id == cb->clk_id)\n\t\treturn 0;\n\tif (ca->dev_id > cb->dev_id ||\n\t    (ca->dev_id == cb->dev_id && ca->clk_id > cb->clk_id))\n\t\treturn 1;\n\treturn -1;\n}\n\n \nstatic struct clk_hw *sci_clk_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct sci_clk_provider *provider = data;\n\tstruct sci_clk **clk;\n\tstruct sci_clk key;\n\n\tif (clkspec->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tkey.dev_id = clkspec->args[0];\n\tkey.clk_id = clkspec->args[1];\n\n\tclk = bsearch(&key, provider->clocks, provider->num_clocks,\n\t\t      sizeof(clk), _cmp_sci_clk);\n\n\tif (!clk)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn &(*clk)->hw;\n}\n\nstatic int ti_sci_init_clocks(struct sci_clk_provider *p)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < p->num_clocks; i++) {\n\t\tret = _sci_clk_build(p, p->clocks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ti_sci_clk_of_match[] = {\n\t{ .compatible = \"ti,k2g-sci-clk\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ti_sci_clk_of_match);\n\n#ifdef CONFIG_TI_SCI_CLK_PROBE_FROM_FW\nstatic int ti_sci_scan_clocks_from_fw(struct sci_clk_provider *provider)\n{\n\tint ret;\n\tint num_clks = 0;\n\tstruct sci_clk **clks = NULL;\n\tstruct sci_clk **tmp_clks;\n\tstruct sci_clk *sci_clk;\n\tint max_clks = 0;\n\tint clk_id = 0;\n\tint dev_id = 0;\n\tu32 num_parents = 0;\n\tint gap_size = 0;\n\tstruct device *dev = provider->dev;\n\n\twhile (1) {\n\t\tret = provider->ops->get_num_parents(provider->sci, dev_id,\n\t\t\t\t\t\t     clk_id,\n\t\t\t\t\t\t     (void *)&num_parents);\n\t\tif (ret) {\n\t\t\tgap_size++;\n\t\t\tif (!clk_id) {\n\t\t\t\tif (gap_size >= 5)\n\t\t\t\t\tbreak;\n\t\t\t\tdev_id++;\n\t\t\t} else {\n\t\t\t\tif (gap_size >= 2) {\n\t\t\t\t\tdev_id++;\n\t\t\t\t\tclk_id = 0;\n\t\t\t\t\tgap_size = 0;\n\t\t\t\t} else {\n\t\t\t\t\tclk_id++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgap_size = 0;\n\n\t\tif (num_clks == max_clks) {\n\t\t\ttmp_clks = devm_kmalloc_array(dev, max_clks + 64,\n\t\t\t\t\t\t      sizeof(sci_clk),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\tmemcpy(tmp_clks, clks, max_clks * sizeof(sci_clk));\n\t\t\tif (max_clks)\n\t\t\t\tdevm_kfree(dev, clks);\n\t\t\tmax_clks += 64;\n\t\t\tclks = tmp_clks;\n\t\t}\n\n\t\tsci_clk = devm_kzalloc(dev, sizeof(*sci_clk), GFP_KERNEL);\n\t\tif (!sci_clk)\n\t\t\treturn -ENOMEM;\n\t\tsci_clk->dev_id = dev_id;\n\t\tsci_clk->clk_id = clk_id;\n\t\tsci_clk->provider = provider;\n\t\tsci_clk->num_parents = num_parents;\n\n\t\tclks[num_clks] = sci_clk;\n\n\t\tclk_id++;\n\t\tnum_clks++;\n\t}\n\n\tprovider->clocks = devm_kmalloc_array(dev, num_clks, sizeof(sci_clk),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!provider->clocks)\n\t\treturn -ENOMEM;\n\n\tmemcpy(provider->clocks, clks, num_clks * sizeof(sci_clk));\n\n\tprovider->num_clocks = num_clks;\n\n\tdevm_kfree(dev, clks);\n\n\treturn 0;\n}\n\n#else\n\nstatic int _cmp_sci_clk_list(void *priv, const struct list_head *a,\n\t\t\t     const struct list_head *b)\n{\n\tstruct sci_clk *ca = container_of(a, struct sci_clk, node);\n\tstruct sci_clk *cb = container_of(b, struct sci_clk, node);\n\n\treturn _cmp_sci_clk(ca, &cb);\n}\n\nstatic int ti_sci_scan_clocks_from_dt(struct sci_clk_provider *provider)\n{\n\tstruct device *dev = provider->dev;\n\tstruct device_node *np = NULL;\n\tint ret;\n\tint index;\n\tstruct of_phandle_args args;\n\tstruct list_head clks;\n\tstruct sci_clk *sci_clk, *prev;\n\tint num_clks = 0;\n\tint num_parents;\n\tint clk_id;\n\tconst char * const clk_names[] = {\n\t\t\"clocks\", \"assigned-clocks\", \"assigned-clock-parents\", NULL\n\t};\n\tconst char * const *clk_name;\n\n\tINIT_LIST_HEAD(&clks);\n\n\tclk_name = clk_names;\n\n\twhile (*clk_name) {\n\t\tnp = of_find_node_with_property(np, *clk_name);\n\t\tif (!np) {\n\t\t\tclk_name++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!of_device_is_available(np))\n\t\t\tcontinue;\n\n\t\tindex = 0;\n\n\t\tdo {\n\t\t\tret = of_parse_phandle_with_args(np, *clk_name,\n\t\t\t\t\t\t\t \"#clock-cells\", index,\n\t\t\t\t\t\t\t &args);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (args.args_count == 2 && args.np == dev->of_node) {\n\t\t\t\tsci_clk = devm_kzalloc(dev, sizeof(*sci_clk),\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\t\tif (!sci_clk)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tsci_clk->dev_id = args.args[0];\n\t\t\t\tsci_clk->clk_id = args.args[1];\n\t\t\t\tsci_clk->provider = provider;\n\t\t\t\tprovider->ops->get_num_parents(provider->sci,\n\t\t\t\t\t\t\t       sci_clk->dev_id,\n\t\t\t\t\t\t\t       sci_clk->clk_id,\n\t\t\t\t\t\t\t       (void *)&sci_clk->num_parents);\n\t\t\t\tlist_add_tail(&sci_clk->node, &clks);\n\n\t\t\t\tnum_clks++;\n\n\t\t\t\tnum_parents = sci_clk->num_parents;\n\t\t\t\tif (num_parents == 1)\n\t\t\t\t\tnum_parents = 0;\n\n\t\t\t\t \n\t\t\t\tif (num_parents >= 255) {\n\t\t\t\t\tdev_warn(dev, \"too many parents for dev=%d, clk=%d (%d), cropping to 255.\\n\",\n\t\t\t\t\t\t sci_clk->dev_id,\n\t\t\t\t\t\t sci_clk->clk_id, num_parents);\n\t\t\t\t\tnum_parents = 255;\n\t\t\t\t}\n\n\t\t\t\tclk_id = args.args[1] + 1;\n\n\t\t\t\twhile (num_parents--) {\n\t\t\t\t\tsci_clk = devm_kzalloc(dev,\n\t\t\t\t\t\t\t       sizeof(*sci_clk),\n\t\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\t\t\tif (!sci_clk)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\tsci_clk->dev_id = args.args[0];\n\t\t\t\t\tsci_clk->clk_id = clk_id++;\n\t\t\t\t\tsci_clk->provider = provider;\n\t\t\t\t\tlist_add_tail(&sci_clk->node, &clks);\n\n\t\t\t\t\tnum_clks++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tindex++;\n\t\t} while (args.np);\n\t}\n\n\tlist_sort(NULL, &clks, _cmp_sci_clk_list);\n\n\tprovider->clocks = devm_kmalloc_array(dev, num_clks, sizeof(sci_clk),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!provider->clocks)\n\t\treturn -ENOMEM;\n\n\tnum_clks = 0;\n\tprev = NULL;\n\n\tlist_for_each_entry(sci_clk, &clks, node) {\n\t\tif (prev && prev->dev_id == sci_clk->dev_id &&\n\t\t    prev->clk_id == sci_clk->clk_id)\n\t\t\tcontinue;\n\n\t\tprovider->clocks[num_clks++] = sci_clk;\n\t\tprev = sci_clk;\n\t}\n\n\tprovider->num_clocks = num_clks;\n\n\treturn 0;\n}\n#endif\n\n \nstatic int ti_sci_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct sci_clk_provider *provider;\n\tconst struct ti_sci_handle *handle;\n\tint ret;\n\n\thandle = devm_ti_sci_get_handle(dev);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tprovider = devm_kzalloc(dev, sizeof(*provider), GFP_KERNEL);\n\tif (!provider)\n\t\treturn -ENOMEM;\n\n\tprovider->sci = handle;\n\tprovider->ops = &handle->ops.clk_ops;\n\tprovider->dev = dev;\n\n#ifdef CONFIG_TI_SCI_CLK_PROBE_FROM_FW\n\tret = ti_sci_scan_clocks_from_fw(provider);\n\tif (ret) {\n\t\tdev_err(dev, \"scan clocks from FW failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n#else\n\tret = ti_sci_scan_clocks_from_dt(provider);\n\tif (ret) {\n\t\tdev_err(dev, \"scan clocks from DT failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n#endif\n\n\tret = ti_sci_init_clocks(provider);\n\tif (ret) {\n\t\tpr_err(\"ti-sci-init-clocks failed.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn of_clk_add_hw_provider(np, sci_clk_get, provider);\n}\n\n \nstatic void ti_sci_clk_remove(struct platform_device *pdev)\n{\n\tof_clk_del_provider(pdev->dev.of_node);\n}\n\nstatic struct platform_driver ti_sci_clk_driver = {\n\t.probe = ti_sci_clk_probe,\n\t.remove_new = ti_sci_clk_remove,\n\t.driver = {\n\t\t.name = \"ti-sci-clk\",\n\t\t.of_match_table = of_match_ptr(ti_sci_clk_of_match),\n\t},\n};\nmodule_platform_driver(ti_sci_clk_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"TI System Control Interface(SCI) Clock driver\");\nMODULE_AUTHOR(\"Tero Kristo\");\nMODULE_ALIAS(\"platform:ti-sci-clk\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}