{
  "module_name": "clk-pfdv2.c",
  "hash_id": "8d75b6060a97a093a14fda7a5329bd8707535a45af47da020de9702e3c28d9f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-pfdv2.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\n \n\nstruct clk_pfdv2 {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*reg;\n\tu8\t\tgate_bit;\n\tu8\t\tvld_bit;\n\tu8\t\tfrac_off;\n};\n\n#define to_clk_pfdv2(_hw) container_of(_hw, struct clk_pfdv2, hw)\n\n#define CLK_PFDV2_FRAC_MASK 0x3f\n\n#define LOCK_TIMEOUT_US\t\tUSEC_PER_MSEC\n\nstatic DEFINE_SPINLOCK(pfd_lock);\n\nstatic int clk_pfdv2_wait(struct clk_pfdv2 *pfd)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(pfd->reg, val, val & (1 << pfd->vld_bit),\n\t\t\t\t  0, LOCK_TIMEOUT_US);\n}\n\nstatic int clk_pfdv2_enable(struct clk_hw *hw)\n{\n\tstruct clk_pfdv2 *pfd = to_clk_pfdv2(hw);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&pfd_lock, flags);\n\tval = readl_relaxed(pfd->reg);\n\tval &= ~(1 << pfd->gate_bit);\n\twritel_relaxed(val, pfd->reg);\n\tspin_unlock_irqrestore(&pfd_lock, flags);\n\n\treturn clk_pfdv2_wait(pfd);\n}\n\nstatic void clk_pfdv2_disable(struct clk_hw *hw)\n{\n\tstruct clk_pfdv2 *pfd = to_clk_pfdv2(hw);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&pfd_lock, flags);\n\tval = readl_relaxed(pfd->reg);\n\tval |= (1 << pfd->gate_bit);\n\twritel_relaxed(val, pfd->reg);\n\tspin_unlock_irqrestore(&pfd_lock, flags);\n}\n\nstatic unsigned long clk_pfdv2_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct clk_pfdv2 *pfd = to_clk_pfdv2(hw);\n\tu64 tmp = parent_rate;\n\tu8 frac;\n\n\tfrac = (readl_relaxed(pfd->reg) >> pfd->frac_off)\n\t\t& CLK_PFDV2_FRAC_MASK;\n\n\tif (!frac) {\n\t\tpr_debug(\"clk_pfdv2: %s invalid pfd frac value 0\\n\",\n\t\t\t clk_hw_get_name(hw));\n\t\treturn 0;\n\t}\n\n\ttmp *= 18;\n\tdo_div(tmp, frac);\n\n\treturn tmp;\n}\n\nstatic int clk_pfdv2_determine_rate(struct clk_hw *hw,\n\t\t\t\t    struct clk_rate_request *req)\n{\n\tunsigned long parent_rates[] = {\n\t\t\t\t\t480000000,\n\t\t\t\t\t528000000,\n\t\t\t\t\treq->best_parent_rate\n\t\t\t\t       };\n\tunsigned long best_rate = -1UL, rate = req->rate;\n\tunsigned long best_parent_rate = req->best_parent_rate;\n\tu64 tmp;\n\tu8 frac;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(parent_rates); i++) {\n\t\ttmp = parent_rates[i];\n\t\ttmp = tmp * 18 + rate / 2;\n\t\tdo_div(tmp, rate);\n\t\tfrac = tmp;\n\n\t\tif (frac < 12)\n\t\t\tfrac = 12;\n\t\telse if (frac > 35)\n\t\t\tfrac = 35;\n\n\t\ttmp = parent_rates[i];\n\t\ttmp *= 18;\n\t\tdo_div(tmp, frac);\n\n\t\tif (abs(tmp - req->rate) < abs(best_rate - req->rate)) {\n\t\t\tbest_rate = tmp;\n\t\t\tbest_parent_rate = parent_rates[i];\n\t\t}\n\t}\n\n\treq->best_parent_rate = best_parent_rate;\n\treq->rate = best_rate;\n\n\treturn 0;\n}\n\nstatic int clk_pfdv2_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_pfdv2 *pfd = to_clk_pfdv2(hw);\n\n\tif (readl_relaxed(pfd->reg) & (1 << pfd->gate_bit))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int clk_pfdv2_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct clk_pfdv2 *pfd = to_clk_pfdv2(hw);\n\tunsigned long flags;\n\tu64 tmp = parent_rate;\n\tu32 val;\n\tu8 frac;\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\t \n\tif (clk_pfdv2_is_enabled(hw))\n\t\tclk_pfdv2_disable(hw);\n\n\ttmp = tmp * 18 + rate / 2;\n\tdo_div(tmp, rate);\n\tfrac = tmp;\n\tif (frac < 12)\n\t\tfrac = 12;\n\telse if (frac > 35)\n\t\tfrac = 35;\n\n\tspin_lock_irqsave(&pfd_lock, flags);\n\tval = readl_relaxed(pfd->reg);\n\tval &= ~(CLK_PFDV2_FRAC_MASK << pfd->frac_off);\n\tval |= frac << pfd->frac_off;\n\twritel_relaxed(val, pfd->reg);\n\tspin_unlock_irqrestore(&pfd_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_pfdv2_ops = {\n\t.enable\t\t= clk_pfdv2_enable,\n\t.disable\t= clk_pfdv2_disable,\n\t.recalc_rate\t= clk_pfdv2_recalc_rate,\n\t.determine_rate\t= clk_pfdv2_determine_rate,\n\t.set_rate\t= clk_pfdv2_set_rate,\n\t.is_enabled     = clk_pfdv2_is_enabled,\n};\n\nstruct clk_hw *imx_clk_hw_pfdv2(enum imx_pfdv2_type type, const char *name,\n\t\t\t     const char *parent_name, void __iomem *reg, u8 idx)\n{\n\tstruct clk_init_data init;\n\tstruct clk_pfdv2 *pfd;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tWARN_ON(idx > 3);\n\n\tpfd = kzalloc(sizeof(*pfd), GFP_KERNEL);\n\tif (!pfd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpfd->reg = reg;\n\tpfd->gate_bit = (idx + 1) * 8 - 1;\n\tpfd->vld_bit = pfd->gate_bit - 1;\n\tpfd->frac_off = idx * 8;\n\n\tinit.name = name;\n\tinit.ops = &clk_pfdv2_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tif (type == IMX_PFDV2_IMX7ULP)\n\t\tinit.flags = CLK_SET_RATE_GATE | CLK_SET_RATE_PARENT;\n\telse\n\t\tinit.flags = CLK_SET_RATE_GATE;\n\n\tpfd->hw.init = &init;\n\n\thw = &pfd->hw;\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(pfd);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(imx_clk_hw_pfdv2);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}