{
  "module_name": "clk-imx8qxp-lpcg.c",
  "hash_id": "3bc14a48163fc8f9c7f2e6e3ca4be8828275ceb6b7df9f523ccd1232926f1dfd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-imx8qxp-lpcg.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include \"clk-scu.h\"\n#include \"clk-imx8qxp-lpcg.h\"\n\n#include <dt-bindings/clock/imx8-clock.h>\n\n \nstruct imx8qxp_lpcg_data {\n\tint id;\n\tchar *name;\n\tchar *parent;\n\tunsigned long flags;\n\tu32 offset;\n\tu8 bit_idx;\n\tbool hw_gate;\n};\n\n \nstruct imx8qxp_ss_lpcg {\n\tconst struct imx8qxp_lpcg_data *lpcg;\n\tu8 num_lpcg;\n\tu8 num_max;\n};\n\nstatic const struct imx8qxp_lpcg_data imx8qxp_lpcg_adma[] = {\n\t{ IMX_ADMA_LPCG_UART0_IPG_CLK, \"uart0_lpcg_ipg_clk\", \"dma_ipg_clk_root\", 0, ADMA_LPUART_0_LPCG, 16, 0, },\n\t{ IMX_ADMA_LPCG_UART0_BAUD_CLK, \"uart0_lpcg_baud_clk\", \"uart0_clk\", 0, ADMA_LPUART_0_LPCG, 0, 0, },\n\t{ IMX_ADMA_LPCG_UART1_IPG_CLK, \"uart1_lpcg_ipg_clk\", \"dma_ipg_clk_root\", 0, ADMA_LPUART_1_LPCG, 16, 0, },\n\t{ IMX_ADMA_LPCG_UART1_BAUD_CLK, \"uart1_lpcg_baud_clk\", \"uart1_clk\", 0, ADMA_LPUART_1_LPCG, 0, 0, },\n\t{ IMX_ADMA_LPCG_UART2_IPG_CLK, \"uart2_lpcg_ipg_clk\", \"dma_ipg_clk_root\", 0, ADMA_LPUART_2_LPCG, 16, 0, },\n\t{ IMX_ADMA_LPCG_UART2_BAUD_CLK, \"uart2_lpcg_baud_clk\", \"uart2_clk\", 0, ADMA_LPUART_2_LPCG, 0, 0, },\n\t{ IMX_ADMA_LPCG_UART3_IPG_CLK, \"uart3_lpcg_ipg_clk\", \"dma_ipg_clk_root\", 0, ADMA_LPUART_3_LPCG, 16, 0, },\n\t{ IMX_ADMA_LPCG_UART3_BAUD_CLK, \"uart3_lpcg_baud_clk\", \"uart3_clk\", 0, ADMA_LPUART_3_LPCG, 0, 0, },\n\t{ IMX_ADMA_LPCG_I2C0_IPG_CLK, \"i2c0_lpcg_ipg_clk\", \"dma_ipg_clk_root\", 0, ADMA_LPI2C_0_LPCG, 16, 0, },\n\t{ IMX_ADMA_LPCG_I2C0_CLK, \"i2c0_lpcg_clk\", \"i2c0_clk\", 0, ADMA_LPI2C_0_LPCG, 0, 0, },\n\t{ IMX_ADMA_LPCG_I2C1_IPG_CLK, \"i2c1_lpcg_ipg_clk\", \"dma_ipg_clk_root\", 0, ADMA_LPI2C_1_LPCG, 16, 0, },\n\t{ IMX_ADMA_LPCG_I2C1_CLK, \"i2c1_lpcg_clk\", \"i2c1_clk\", 0, ADMA_LPI2C_1_LPCG, 0, 0, },\n\t{ IMX_ADMA_LPCG_I2C2_IPG_CLK, \"i2c2_lpcg_ipg_clk\", \"dma_ipg_clk_root\", 0, ADMA_LPI2C_2_LPCG, 16, 0, },\n\t{ IMX_ADMA_LPCG_I2C2_CLK, \"i2c2_lpcg_clk\", \"i2c2_clk\", 0, ADMA_LPI2C_2_LPCG, 0, 0, },\n\t{ IMX_ADMA_LPCG_I2C3_IPG_CLK, \"i2c3_lpcg_ipg_clk\", \"dma_ipg_clk_root\", 0, ADMA_LPI2C_3_LPCG, 16, 0, },\n\t{ IMX_ADMA_LPCG_I2C3_CLK, \"i2c3_lpcg_clk\", \"i2c3_clk\", 0, ADMA_LPI2C_3_LPCG, 0, 0, },\n\n\t{ IMX_ADMA_LPCG_DSP_CORE_CLK, \"dsp_lpcg_core_clk\", \"dma_ipg_clk_root\", 0, ADMA_HIFI_LPCG, 28, 0, },\n\t{ IMX_ADMA_LPCG_DSP_IPG_CLK, \"dsp_lpcg_ipg_clk\", \"dma_ipg_clk_root\", 0, ADMA_HIFI_LPCG, 20, 0, },\n\t{ IMX_ADMA_LPCG_DSP_ADB_CLK, \"dsp_lpcg_adb_clk\", \"dma_ipg_clk_root\", 0, ADMA_HIFI_LPCG, 16, 0, },\n\t{ IMX_ADMA_LPCG_OCRAM_IPG_CLK, \"ocram_lpcg_ipg_clk\", \"dma_ipg_clk_root\", 0, ADMA_OCRAM_LPCG, 16, 0, },\n};\n\nstatic const struct imx8qxp_ss_lpcg imx8qxp_ss_adma = {\n\t.lpcg = imx8qxp_lpcg_adma,\n\t.num_lpcg = ARRAY_SIZE(imx8qxp_lpcg_adma),\n\t.num_max = IMX_ADMA_LPCG_CLK_END,\n};\n\nstatic const struct imx8qxp_lpcg_data imx8qxp_lpcg_conn[] = {\n\t{ IMX_CONN_LPCG_SDHC0_PER_CLK, \"sdhc0_lpcg_per_clk\", \"sdhc0_clk\", 0, CONN_USDHC_0_LPCG, 0, 0, },\n\t{ IMX_CONN_LPCG_SDHC0_IPG_CLK, \"sdhc0_lpcg_ipg_clk\", \"conn_ipg_clk_root\", 0, CONN_USDHC_0_LPCG, 16, 0, },\n\t{ IMX_CONN_LPCG_SDHC0_HCLK, \"sdhc0_lpcg_ahb_clk\", \"conn_axi_clk_root\", 0, CONN_USDHC_0_LPCG, 20, 0, },\n\t{ IMX_CONN_LPCG_SDHC1_PER_CLK, \"sdhc1_lpcg_per_clk\", \"sdhc1_clk\", 0, CONN_USDHC_1_LPCG, 0, 0, },\n\t{ IMX_CONN_LPCG_SDHC1_IPG_CLK, \"sdhc1_lpcg_ipg_clk\", \"conn_ipg_clk_root\", 0, CONN_USDHC_1_LPCG, 16, 0, },\n\t{ IMX_CONN_LPCG_SDHC1_HCLK, \"sdhc1_lpcg_ahb_clk\", \"conn_axi_clk_root\", 0, CONN_USDHC_1_LPCG, 20, 0, },\n\t{ IMX_CONN_LPCG_SDHC2_PER_CLK, \"sdhc2_lpcg_per_clk\", \"sdhc2_clk\", 0, CONN_USDHC_2_LPCG, 0, 0, },\n\t{ IMX_CONN_LPCG_SDHC2_IPG_CLK, \"sdhc2_lpcg_ipg_clk\", \"conn_ipg_clk_root\", 0, CONN_USDHC_2_LPCG, 16, 0, },\n\t{ IMX_CONN_LPCG_SDHC2_HCLK, \"sdhc2_lpcg_ahb_clk\", \"conn_axi_clk_root\", 0, CONN_USDHC_2_LPCG, 20, 0, },\n\t{ IMX_CONN_LPCG_ENET0_ROOT_CLK, \"enet0_ipg_root_clk\", \"enet0_clk\", 0, CONN_ENET_0_LPCG, 0, 0, },\n\t{ IMX_CONN_LPCG_ENET0_TX_CLK, \"enet0_tx_clk\", \"enet0_clk\", 0, CONN_ENET_0_LPCG, 4, 0, },\n\t{ IMX_CONN_LPCG_ENET0_AHB_CLK, \"enet0_ahb_clk\", \"conn_axi_clk_root\", 0, CONN_ENET_0_LPCG, 8, 0, },\n\t{ IMX_CONN_LPCG_ENET0_IPG_S_CLK, \"enet0_ipg_s_clk\", \"conn_ipg_clk_root\", 0, CONN_ENET_0_LPCG, 20, 0, },\n\t{ IMX_CONN_LPCG_ENET0_IPG_CLK, \"enet0_ipg_clk\", \"enet0_ipg_s_clk\", 0, CONN_ENET_0_LPCG, 16, 0, },\n\t{ IMX_CONN_LPCG_ENET1_ROOT_CLK, \"enet1_ipg_root_clk\", \"enet1_clk\", 0, CONN_ENET_1_LPCG, 0, 0, },\n\t{ IMX_CONN_LPCG_ENET1_TX_CLK, \"enet1_tx_clk\", \"enet1_clk\", 0, CONN_ENET_1_LPCG, 4, 0, },\n\t{ IMX_CONN_LPCG_ENET1_AHB_CLK, \"enet1_ahb_clk\", \"conn_axi_clk_root\", 0, CONN_ENET_1_LPCG, 8, 0, },\n\t{ IMX_CONN_LPCG_ENET1_IPG_S_CLK, \"enet1_ipg_s_clk\", \"conn_ipg_clk_root\", 0, CONN_ENET_1_LPCG, 20, 0, },\n\t{ IMX_CONN_LPCG_ENET1_IPG_CLK, \"enet1_ipg_clk\", \"enet0_ipg_s_clk\", 0, CONN_ENET_1_LPCG, 16, 0, },\n};\n\nstatic const struct imx8qxp_ss_lpcg imx8qxp_ss_conn = {\n\t.lpcg = imx8qxp_lpcg_conn,\n\t.num_lpcg = ARRAY_SIZE(imx8qxp_lpcg_conn),\n\t.num_max = IMX_CONN_LPCG_CLK_END,\n};\n\nstatic const struct imx8qxp_lpcg_data imx8qxp_lpcg_lsio[] = {\n\t{ IMX_LSIO_LPCG_PWM0_IPG_CLK, \"pwm0_lpcg_ipg_clk\", \"pwm0_clk\", 0, LSIO_PWM_0_LPCG, 0, 0, },\n\t{ IMX_LSIO_LPCG_PWM0_IPG_HF_CLK, \"pwm0_lpcg_ipg_hf_clk\", \"pwm0_clk\", 0, LSIO_PWM_0_LPCG, 4, 0, },\n\t{ IMX_LSIO_LPCG_PWM0_IPG_S_CLK, \"pwm0_lpcg_ipg_s_clk\", \"pwm0_clk\", 0, LSIO_PWM_0_LPCG, 16, 0, },\n\t{ IMX_LSIO_LPCG_PWM0_IPG_SLV_CLK, \"pwm0_lpcg_ipg_slv_clk\", \"lsio_bus_clk_root\", 0, LSIO_PWM_0_LPCG, 20, 0, },\n\t{ IMX_LSIO_LPCG_PWM0_IPG_MSTR_CLK, \"pwm0_lpcg_ipg_mstr_clk\", \"pwm0_clk\", 0, LSIO_PWM_0_LPCG, 24, 0, },\n\t{ IMX_LSIO_LPCG_PWM1_IPG_CLK, \"pwm1_lpcg_ipg_clk\", \"pwm1_clk\", 0, LSIO_PWM_1_LPCG, 0, 0, },\n\t{ IMX_LSIO_LPCG_PWM1_IPG_HF_CLK, \"pwm1_lpcg_ipg_hf_clk\", \"pwm1_clk\", 0, LSIO_PWM_1_LPCG, 4, 0, },\n\t{ IMX_LSIO_LPCG_PWM1_IPG_S_CLK, \"pwm1_lpcg_ipg_s_clk\", \"pwm1_clk\", 0, LSIO_PWM_1_LPCG, 16, 0, },\n\t{ IMX_LSIO_LPCG_PWM1_IPG_SLV_CLK, \"pwm1_lpcg_ipg_slv_clk\", \"lsio_bus_clk_root\", 0, LSIO_PWM_1_LPCG, 20, 0, },\n\t{ IMX_LSIO_LPCG_PWM1_IPG_MSTR_CLK, \"pwm1_lpcg_ipg_mstr_clk\", \"pwm1_clk\", 0, LSIO_PWM_1_LPCG, 24, 0, },\n\t{ IMX_LSIO_LPCG_PWM2_IPG_CLK, \"pwm2_lpcg_ipg_clk\", \"pwm2_clk\", 0, LSIO_PWM_2_LPCG, 0, 0, },\n\t{ IMX_LSIO_LPCG_PWM2_IPG_HF_CLK, \"pwm2_lpcg_ipg_hf_clk\", \"pwm2_clk\", 0, LSIO_PWM_2_LPCG, 4, 0, },\n\t{ IMX_LSIO_LPCG_PWM2_IPG_S_CLK, \"pwm2_lpcg_ipg_s_clk\", \"pwm2_clk\", 0, LSIO_PWM_2_LPCG, 16, 0, },\n\t{ IMX_LSIO_LPCG_PWM2_IPG_SLV_CLK, \"pwm2_lpcg_ipg_slv_clk\", \"lsio_bus_clk_root\", 0, LSIO_PWM_2_LPCG, 20, 0, },\n\t{ IMX_LSIO_LPCG_PWM2_IPG_MSTR_CLK, \"pwm2_lpcg_ipg_mstr_clk\", \"pwm2_clk\", 0, LSIO_PWM_2_LPCG, 24, 0, },\n\t{ IMX_LSIO_LPCG_PWM3_IPG_CLK, \"pwm3_lpcg_ipg_clk\", \"pwm3_clk\", 0, LSIO_PWM_3_LPCG, 0, 0, },\n\t{ IMX_LSIO_LPCG_PWM3_IPG_HF_CLK, \"pwm3_lpcg_ipg_hf_clk\", \"pwm3_clk\", 0, LSIO_PWM_3_LPCG, 4, 0, },\n\t{ IMX_LSIO_LPCG_PWM3_IPG_S_CLK, \"pwm3_lpcg_ipg_s_clk\", \"pwm3_clk\", 0, LSIO_PWM_3_LPCG, 16, 0, },\n\t{ IMX_LSIO_LPCG_PWM3_IPG_SLV_CLK, \"pwm3_lpcg_ipg_slv_clk\", \"lsio_bus_clk_root\", 0, LSIO_PWM_3_LPCG, 20, 0, },\n\t{ IMX_LSIO_LPCG_PWM3_IPG_MSTR_CLK, \"pwm3_lpcg_ipg_mstr_clk\", \"pwm3_clk\", 0, LSIO_PWM_3_LPCG, 24, 0, },\n\t{ IMX_LSIO_LPCG_PWM4_IPG_CLK, \"pwm4_lpcg_ipg_clk\", \"pwm4_clk\", 0, LSIO_PWM_4_LPCG, 0, 0, },\n\t{ IMX_LSIO_LPCG_PWM4_IPG_HF_CLK, \"pwm4_lpcg_ipg_hf_clk\", \"pwm4_clk\", 0, LSIO_PWM_4_LPCG, 4, 0, },\n\t{ IMX_LSIO_LPCG_PWM4_IPG_S_CLK, \"pwm4_lpcg_ipg_s_clk\", \"pwm4_clk\", 0, LSIO_PWM_4_LPCG, 16, 0, },\n\t{ IMX_LSIO_LPCG_PWM4_IPG_SLV_CLK, \"pwm4_lpcg_ipg_slv_clk\", \"lsio_bus_clk_root\", 0, LSIO_PWM_4_LPCG, 20, 0, },\n\t{ IMX_LSIO_LPCG_PWM4_IPG_MSTR_CLK, \"pwm4_lpcg_ipg_mstr_clk\", \"pwm4_clk\", 0, LSIO_PWM_4_LPCG, 24, 0, },\n\t{ IMX_LSIO_LPCG_PWM5_IPG_CLK, \"pwm5_lpcg_ipg_clk\", \"pwm5_clk\", 0, LSIO_PWM_5_LPCG, 0, 0, },\n\t{ IMX_LSIO_LPCG_PWM5_IPG_HF_CLK, \"pwm5_lpcg_ipg_hf_clk\", \"pwm5_clk\", 0, LSIO_PWM_5_LPCG, 4, 0, },\n\t{ IMX_LSIO_LPCG_PWM5_IPG_S_CLK, \"pwm5_lpcg_ipg_s_clk\", \"pwm5_clk\", 0, LSIO_PWM_5_LPCG, 16, 0, },\n\t{ IMX_LSIO_LPCG_PWM5_IPG_SLV_CLK, \"pwm5_lpcg_ipg_slv_clk\", \"lsio_bus_clk_root\", 0, LSIO_PWM_5_LPCG, 20, 0, },\n\t{ IMX_LSIO_LPCG_PWM5_IPG_MSTR_CLK, \"pwm5_lpcg_ipg_mstr_clk\", \"pwm5_clk\", 0, LSIO_PWM_5_LPCG, 24, 0, },\n\t{ IMX_LSIO_LPCG_PWM6_IPG_CLK, \"pwm6_lpcg_ipg_clk\", \"pwm6_clk\", 0, LSIO_PWM_6_LPCG, 0, 0, },\n\t{ IMX_LSIO_LPCG_PWM6_IPG_HF_CLK, \"pwm6_lpcg_ipg_hf_clk\", \"pwm6_clk\", 0, LSIO_PWM_6_LPCG, 4, 0, },\n\t{ IMX_LSIO_LPCG_PWM6_IPG_S_CLK, \"pwm6_lpcg_ipg_s_clk\", \"pwm6_clk\", 0, LSIO_PWM_6_LPCG, 16, 0, },\n\t{ IMX_LSIO_LPCG_PWM6_IPG_SLV_CLK, \"pwm6_lpcg_ipg_slv_clk\", \"lsio_bus_clk_root\", 0, LSIO_PWM_6_LPCG, 20, 0, },\n\t{ IMX_LSIO_LPCG_PWM6_IPG_MSTR_CLK, \"pwm6_lpcg_ipg_mstr_clk\", \"pwm6_clk\", 0, LSIO_PWM_6_LPCG, 24, 0, },\n};\n\nstatic const struct imx8qxp_ss_lpcg imx8qxp_ss_lsio = {\n\t.lpcg = imx8qxp_lpcg_lsio,\n\t.num_lpcg = ARRAY_SIZE(imx8qxp_lpcg_lsio),\n\t.num_max = IMX_LSIO_LPCG_CLK_END,\n};\n\n#define IMX_LPCG_MAX_CLKS\t8\n\nstatic struct clk_hw *imx_lpcg_of_clk_src_get(struct of_phandle_args *clkspec,\n\t\t\t\t\t      void *data)\n{\n\tstruct clk_hw_onecell_data *hw_data = data;\n\tunsigned int idx = clkspec->args[0] / 4;\n\n\tif (idx >= hw_data->num) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn hw_data->hws[idx];\n}\n\nstatic int imx_lpcg_parse_clks_from_dt(struct platform_device *pdev,\n\t\t\t\t       struct device_node *np)\n{\n\tconst char *output_names[IMX_LPCG_MAX_CLKS];\n\tconst char *parent_names[IMX_LPCG_MAX_CLKS];\n\tunsigned int bit_offset[IMX_LPCG_MAX_CLKS];\n\tstruct clk_hw_onecell_data *clk_data;\n\tstruct clk_hw **clk_hws;\n\tvoid __iomem *base;\n\tint count;\n\tint idx;\n\tint ret;\n\tint i;\n\n\tif (!of_device_is_compatible(np, \"fsl,imx8qxp-lpcg\"))\n\t\treturn -EINVAL;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tcount = of_property_count_u32_elems(np, \"clock-indices\");\n\tif (count < 0) {\n\t\tdev_err(&pdev->dev, \"failed to count clocks\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tclk_data = devm_kzalloc(&pdev->dev, struct_size(clk_data, hws,\n\t\t\t\tIMX_LPCG_MAX_CLKS), GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tclk_data->num = IMX_LPCG_MAX_CLKS;\n\tclk_hws = clk_data->hws;\n\n\tret = of_property_read_u32_array(np, \"clock-indices\", bit_offset,\n\t\t\t\t\t count);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to read clock-indices\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_clk_parent_fill(np, parent_names, count);\n\tif (ret != count) {\n\t\tdev_err(&pdev->dev, \"failed to get clock parent names\\n\");\n\t\treturn count;\n\t}\n\n\tret = of_property_read_string_array(np, \"clock-output-names\",\n\t\t\t\t\t    output_names, count);\n\tif (ret != count) {\n\t\tdev_err(&pdev->dev, \"failed to read clock-output-names\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 500);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tfor (i = 0; i < count; i++) {\n\t\tidx = bit_offset[i] / 4;\n\t\tif (idx >= IMX_LPCG_MAX_CLKS) {\n\t\t\tdev_warn(&pdev->dev, \"invalid bit offset of clock %d\\n\",\n\t\t\t\t i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto unreg;\n\t\t}\n\n\t\tclk_hws[idx] = imx_clk_lpcg_scu_dev(&pdev->dev, output_names[i],\n\t\t\t\t\t\t    parent_names[i], 0, base,\n\t\t\t\t\t\t    bit_offset[i], false);\n\t\tif (IS_ERR(clk_hws[idx])) {\n\t\t\tdev_warn(&pdev->dev, \"failed to register clock %d\\n\",\n\t\t\t\t idx);\n\t\t\tret = PTR_ERR(clk_hws[idx]);\n\t\t\tgoto unreg;\n\t\t}\n\t}\n\n\tret = devm_of_clk_add_hw_provider(&pdev->dev, imx_lpcg_of_clk_src_get,\n\t\t\t\t\t  clk_data);\n\tif (ret)\n\t\tgoto unreg;\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n\nunreg:\n\twhile (--i >= 0) {\n\t\tidx = bit_offset[i] / 4;\n\t\tif (clk_hws[idx])\n\t\t\timx_clk_lpcg_scu_unregister(clk_hws[idx]);\n\t}\n\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic int imx8qxp_lpcg_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct clk_hw_onecell_data *clk_data;\n\tconst struct imx8qxp_ss_lpcg *ss_lpcg;\n\tconst struct imx8qxp_lpcg_data *lpcg;\n\tstruct resource *res;\n\tstruct clk_hw **clks;\n\tvoid __iomem *base;\n\tint ret;\n\tint i;\n\n\t \n\tret = imx_lpcg_parse_clks_from_dt(pdev, np);\n\tif (!ret)\n\t\treturn 0;\n\n\tss_lpcg = of_device_get_match_data(dev);\n\tif (!ss_lpcg)\n\t\treturn -ENODEV;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\tbase = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!base)\n\t\treturn -ENOMEM;\n\n\tclk_data = devm_kzalloc(&pdev->dev, struct_size(clk_data, hws,\n\t\t\t\tss_lpcg->num_max), GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tclk_data->num = ss_lpcg->num_max;\n\tclks = clk_data->hws;\n\n\tfor (i = 0; i < ss_lpcg->num_lpcg; i++) {\n\t\tlpcg = ss_lpcg->lpcg + i;\n\t\tclks[lpcg->id] = imx_clk_lpcg_scu(lpcg->name, lpcg->parent,\n\t\t\t\t\t\t  lpcg->flags, base + lpcg->offset,\n\t\t\t\t\t\t  lpcg->bit_idx, lpcg->hw_gate);\n\t}\n\n\tfor (i = 0; i < clk_data->num; i++) {\n\t\tif (IS_ERR(clks[i]))\n\t\t\tpr_warn(\"i.MX clk %u: register failed with %ld\\n\",\n\t\t\t\ti, PTR_ERR(clks[i]));\n\t}\n\n\treturn of_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_data);\n}\n\nstatic const struct of_device_id imx8qxp_lpcg_match[] = {\n\t{ .compatible = \"fsl,imx8qxp-lpcg-adma\", &imx8qxp_ss_adma, },\n\t{ .compatible = \"fsl,imx8qxp-lpcg-conn\", &imx8qxp_ss_conn, },\n\t{ .compatible = \"fsl,imx8qxp-lpcg-lsio\", &imx8qxp_ss_lsio, },\n\t{ .compatible = \"fsl,imx8qxp-lpcg\", NULL },\n\t{   }\n};\n\nstatic struct platform_driver imx8qxp_lpcg_clk_driver = {\n\t.driver = {\n\t\t.name = \"imx8qxp-lpcg-clk\",\n\t\t.of_match_table = imx8qxp_lpcg_match,\n\t\t.pm = &imx_clk_lpcg_scu_pm_ops,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = imx8qxp_lpcg_clk_probe,\n};\n\nmodule_platform_driver(imx8qxp_lpcg_clk_driver);\n\nMODULE_AUTHOR(\"Aisheng Dong <aisheng.dong@nxp.com>\");\nMODULE_DESCRIPTION(\"NXP i.MX8QXP LPCG clock driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}