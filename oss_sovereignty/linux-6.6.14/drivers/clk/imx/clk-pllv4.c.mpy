{
  "module_name": "clk-pllv4.c",
  "hash_id": "ef984a3abed7493326e909593fee4d78700aa6b67de3f4eeb7797e58e196760b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-pllv4.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\n \n#define PLL_CSR_OFFSET\t\t0x0\n#define PLL_VLD\t\t\tBIT(24)\n#define PLL_EN\t\t\tBIT(0)\n\n \n#define PLL_CFG_OFFSET\t\t0x08\n#define IMX8ULP_PLL_CFG_OFFSET\t0x10\n#define BP_PLL_MULT\t\t16\n#define BM_PLL_MULT\t\t(0x7f << 16)\n\n \n#define PLL_NUM_OFFSET\t\t0x10\n#define IMX8ULP_PLL_NUM_OFFSET\t0x1c\n\n \n#define PLL_DENOM_OFFSET\t0x14\n#define IMX8ULP_PLL_DENOM_OFFSET\t0x18\n\n#define MAX_MFD\t\t\t0x3fffffff\n#define DEFAULT_MFD\t\t1000000\n\nstruct clk_pllv4 {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*base;\n\tu32\t\tcfg_offset;\n\tu32\t\tnum_offset;\n\tu32\t\tdenom_offset;\n\tbool\t\tuse_mult_range;\n};\n\n \nstatic const int pllv4_mult_table[] = {33, 27, 22, 20, 17, 16};\n\n \nstatic const int pllv4_mult_range[] = {54, 27};\n\n#define to_clk_pllv4(__hw) container_of(__hw, struct clk_pllv4, hw)\n\n#define LOCK_TIMEOUT_US\t\tUSEC_PER_MSEC\n\nstatic inline int clk_pllv4_wait_lock(struct clk_pllv4 *pll)\n{\n\tu32 csr;\n\n\treturn readl_poll_timeout(pll->base  + PLL_CSR_OFFSET,\n\t\t\t\t  csr, csr & PLL_VLD, 0, LOCK_TIMEOUT_US);\n}\n\nstatic int clk_pllv4_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_pllv4 *pll = to_clk_pllv4(hw);\n\n\tif (readl_relaxed(pll->base) & PLL_EN)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic unsigned long clk_pllv4_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct clk_pllv4 *pll = to_clk_pllv4(hw);\n\tu32 mult, mfn, mfd;\n\tu64 temp64;\n\n\tmult = readl_relaxed(pll->base + pll->cfg_offset);\n\tmult &= BM_PLL_MULT;\n\tmult >>= BP_PLL_MULT;\n\n\tmfn = readl_relaxed(pll->base + pll->num_offset);\n\tmfd = readl_relaxed(pll->base + pll->denom_offset);\n\ttemp64 = parent_rate;\n\ttemp64 *= mfn;\n\tdo_div(temp64, mfd);\n\n\treturn (parent_rate * mult) + (u32)temp64;\n}\n\nstatic long clk_pllv4_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long *prate)\n{\n\tstruct clk_pllv4 *pll = to_clk_pllv4(hw);\n\tunsigned long parent_rate = *prate;\n\tunsigned long round_rate, i;\n\tu32 mfn, mfd = DEFAULT_MFD;\n\tbool found = false;\n\tu64 temp64;\n\tu32 mult;\n\n\tif (pll->use_mult_range) {\n\t\ttemp64 = (u64)rate;\n\t\tdo_div(temp64, parent_rate);\n\t\tmult = temp64;\n\t\tif (mult >= pllv4_mult_range[1] &&\n\t\t    mult <= pllv4_mult_range[0]) {\n\t\t\tround_rate = parent_rate * mult;\n\t\t\tfound = true;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(pllv4_mult_table); i++) {\n\t\t\tround_rate = parent_rate * pllv4_mult_table[i];\n\t\t\tif (rate >= round_rate) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tpr_warn(\"%s: unable to round rate %lu, parent rate %lu\\n\",\n\t\t\tclk_hw_get_name(hw), rate, parent_rate);\n\t\treturn 0;\n\t}\n\n\tif (parent_rate <= MAX_MFD)\n\t\tmfd = parent_rate;\n\n\ttemp64 = (u64)(rate - round_rate);\n\ttemp64 *= mfd;\n\tdo_div(temp64, parent_rate);\n\tmfn = temp64;\n\n\t \n\tif (mfn >= mfd)\n\t\treturn round_rate;\n\n\ttemp64 = (u64)parent_rate;\n\ttemp64 *= mfn;\n\tdo_div(temp64, mfd);\n\n\treturn round_rate + (u32)temp64;\n}\n\nstatic bool clk_pllv4_is_valid_mult(struct clk_pllv4 *pll, unsigned int mult)\n{\n\tint i;\n\n\t \n\tif (pll->use_mult_range) {\n\t\tif (mult >= pllv4_mult_range[1] &&\n\t\t    mult <= pllv4_mult_range[0])\n\t\t\treturn true;\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(pllv4_mult_table); i++) {\n\t\t\tif (pllv4_mult_table[i] == mult)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int clk_pllv4_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct clk_pllv4 *pll = to_clk_pllv4(hw);\n\tu32 val, mult, mfn, mfd = DEFAULT_MFD;\n\tu64 temp64;\n\n\tmult = rate / parent_rate;\n\n\tif (!clk_pllv4_is_valid_mult(pll, mult))\n\t\treturn -EINVAL;\n\n\tif (parent_rate <= MAX_MFD)\n\t\tmfd = parent_rate;\n\n\ttemp64 = (u64)(rate - mult * parent_rate);\n\ttemp64 *= mfd;\n\tdo_div(temp64, parent_rate);\n\tmfn = temp64;\n\n\tval = readl_relaxed(pll->base + pll->cfg_offset);\n\tval &= ~BM_PLL_MULT;\n\tval |= mult << BP_PLL_MULT;\n\twritel_relaxed(val, pll->base + pll->cfg_offset);\n\n\twritel_relaxed(mfn, pll->base + pll->num_offset);\n\twritel_relaxed(mfd, pll->base + pll->denom_offset);\n\n\treturn 0;\n}\n\nstatic int clk_pllv4_prepare(struct clk_hw *hw)\n{\n\tu32 val;\n\tstruct clk_pllv4 *pll = to_clk_pllv4(hw);\n\n\tval = readl_relaxed(pll->base);\n\tval |= PLL_EN;\n\twritel_relaxed(val, pll->base);\n\n\treturn clk_pllv4_wait_lock(pll);\n}\n\nstatic void clk_pllv4_unprepare(struct clk_hw *hw)\n{\n\tu32 val;\n\tstruct clk_pllv4 *pll = to_clk_pllv4(hw);\n\n\tval = readl_relaxed(pll->base);\n\tval &= ~PLL_EN;\n\twritel_relaxed(val, pll->base);\n}\n\nstatic const struct clk_ops clk_pllv4_ops = {\n\t.recalc_rate\t= clk_pllv4_recalc_rate,\n\t.round_rate\t= clk_pllv4_round_rate,\n\t.set_rate\t= clk_pllv4_set_rate,\n\t.prepare\t= clk_pllv4_prepare,\n\t.unprepare\t= clk_pllv4_unprepare,\n\t.is_prepared\t= clk_pllv4_is_prepared,\n};\n\nstruct clk_hw *imx_clk_hw_pllv4(enum imx_pllv4_type type, const char *name,\n\t\t const char *parent_name, void __iomem *base)\n{\n\tstruct clk_pllv4 *pll;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpll->base = base;\n\n\tif (type == IMX_PLLV4_IMX8ULP ||\n\t    type == IMX_PLLV4_IMX8ULP_1GHZ) {\n\t\tpll->cfg_offset = IMX8ULP_PLL_CFG_OFFSET;\n\t\tpll->num_offset = IMX8ULP_PLL_NUM_OFFSET;\n\t\tpll->denom_offset = IMX8ULP_PLL_DENOM_OFFSET;\n\t\tif (type == IMX_PLLV4_IMX8ULP_1GHZ)\n\t\t\tpll->use_mult_range = true;\n\t} else {\n\t\tpll->cfg_offset = PLL_CFG_OFFSET;\n\t\tpll->num_offset = PLL_NUM_OFFSET;\n\t\tpll->denom_offset = PLL_DENOM_OFFSET;\n\t}\n\n\tinit.name = name;\n\tinit.ops = &clk_pllv4_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = CLK_SET_RATE_GATE;\n\n\tpll->hw.init = &init;\n\n\thw = &pll->hw;\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(pll);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(imx_clk_hw_pllv4);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}