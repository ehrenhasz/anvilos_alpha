{
  "module_name": "clk-divider-gate.c",
  "hash_id": "ec2b4700aa6776076ed021792194f3e94753ddd55e16e6048a56805550ace057",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-divider-gate.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\nstruct clk_divider_gate {\n\tstruct clk_divider divider;\n\tu32 cached_val;\n};\n\nstatic inline struct clk_divider_gate *to_clk_divider_gate(struct clk_hw *hw)\n{\n\tstruct clk_divider *div = to_clk_divider(hw);\n\n\treturn container_of(div, struct clk_divider_gate, divider);\n}\n\nstatic unsigned long clk_divider_gate_recalc_rate_ro(struct clk_hw *hw,\n\t\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct clk_divider *div = to_clk_divider(hw);\n\tunsigned int val;\n\n\tval = readl(div->reg) >> div->shift;\n\tval &= clk_div_mask(div->width);\n\tif (!val)\n\t\treturn 0;\n\n\treturn divider_recalc_rate(hw, parent_rate, val, div->table,\n\t\t\t\t   div->flags, div->width);\n}\n\nstatic unsigned long clk_divider_gate_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_divider_gate *div_gate = to_clk_divider_gate(hw);\n\tstruct clk_divider *div = to_clk_divider(hw);\n\tunsigned long flags;\n\tunsigned int val;\n\n\tspin_lock_irqsave(div->lock, flags);\n\n\tif (!clk_hw_is_enabled(hw)) {\n\t\tval = div_gate->cached_val;\n\t} else {\n\t\tval = readl(div->reg) >> div->shift;\n\t\tval &= clk_div_mask(div->width);\n\t}\n\n\tspin_unlock_irqrestore(div->lock, flags);\n\n\tif (!val)\n\t\treturn 0;\n\n\treturn divider_recalc_rate(hw, parent_rate, val, div->table,\n\t\t\t\t   div->flags, div->width);\n}\n\nstatic int clk_divider_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\treturn clk_divider_ops.determine_rate(hw, req);\n}\n\nstatic int clk_divider_gate_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_divider_gate *div_gate = to_clk_divider_gate(hw);\n\tstruct clk_divider *div = to_clk_divider(hw);\n\tunsigned long flags;\n\tint value;\n\tu32 val;\n\n\tvalue = divider_get_val(rate, parent_rate, div->table,\n\t\t\t\tdiv->width, div->flags);\n\tif (value < 0)\n\t\treturn value;\n\n\tspin_lock_irqsave(div->lock, flags);\n\n\tif (clk_hw_is_enabled(hw)) {\n\t\tval = readl(div->reg);\n\t\tval &= ~(clk_div_mask(div->width) << div->shift);\n\t\tval |= (u32)value << div->shift;\n\t\twritel(val, div->reg);\n\t} else {\n\t\tdiv_gate->cached_val = value;\n\t}\n\n\tspin_unlock_irqrestore(div->lock, flags);\n\n\treturn 0;\n}\n\nstatic int clk_divider_enable(struct clk_hw *hw)\n{\n\tstruct clk_divider_gate *div_gate = to_clk_divider_gate(hw);\n\tstruct clk_divider *div = to_clk_divider(hw);\n\tunsigned long flags;\n\tu32 val;\n\n\tif (!div_gate->cached_val) {\n\t\tpr_err(\"%s: no valid preset rate\\n\", clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(div->lock, flags);\n\t \n\tval = readl(div->reg);\n\tval |= div_gate->cached_val << div->shift;\n\twritel(val, div->reg);\n\n\tspin_unlock_irqrestore(div->lock, flags);\n\n\treturn 0;\n}\n\nstatic void clk_divider_disable(struct clk_hw *hw)\n{\n\tstruct clk_divider_gate *div_gate = to_clk_divider_gate(hw);\n\tstruct clk_divider *div = to_clk_divider(hw);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(div->lock, flags);\n\n\t \n\tval = readl(div->reg) >> div->shift;\n\tval &= clk_div_mask(div->width);\n\tdiv_gate->cached_val = val;\n\twritel(0, div->reg);\n\n\tspin_unlock_irqrestore(div->lock, flags);\n}\n\nstatic int clk_divider_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_divider *div = to_clk_divider(hw);\n\tu32 val;\n\n\tval = readl(div->reg) >> div->shift;\n\tval &= clk_div_mask(div->width);\n\n\treturn val ? 1 : 0;\n}\n\nstatic const struct clk_ops clk_divider_gate_ro_ops = {\n\t.recalc_rate = clk_divider_gate_recalc_rate_ro,\n\t.determine_rate = clk_divider_determine_rate,\n};\n\nstatic const struct clk_ops clk_divider_gate_ops = {\n\t.recalc_rate = clk_divider_gate_recalc_rate,\n\t.determine_rate = clk_divider_determine_rate,\n\t.set_rate = clk_divider_gate_set_rate,\n\t.enable = clk_divider_enable,\n\t.disable = clk_divider_disable,\n\t.is_enabled = clk_divider_is_enabled,\n};\n\n \nstruct clk_hw *imx_clk_hw_divider_gate(const char *name, const char *parent_name,\n\t\t\t\t    unsigned long flags, void __iomem *reg,\n\t\t\t\t    u8 shift, u8 width, u8 clk_divider_flags,\n\t\t\t\t    const struct clk_div_table *table,\n\t\t\t\t    spinlock_t *lock)\n{\n\tstruct clk_init_data init;\n\tstruct clk_divider_gate *div_gate;\n\tstruct clk_hw *hw;\n\tu32 val;\n\tint ret;\n\n\tdiv_gate  = kzalloc(sizeof(*div_gate), GFP_KERNEL);\n\tif (!div_gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tif (clk_divider_flags & CLK_DIVIDER_READ_ONLY)\n\t\tinit.ops = &clk_divider_gate_ro_ops;\n\telse\n\t\tinit.ops = &clk_divider_gate_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\n\tdiv_gate->divider.reg = reg;\n\tdiv_gate->divider.shift = shift;\n\tdiv_gate->divider.width = width;\n\tdiv_gate->divider.lock = lock;\n\tdiv_gate->divider.table = table;\n\tdiv_gate->divider.hw.init = &init;\n\tdiv_gate->divider.flags = CLK_DIVIDER_ONE_BASED | clk_divider_flags;\n\t \n\tval = readl(reg) >> shift;\n\tval &= clk_div_mask(width);\n\tdiv_gate->cached_val = val;\n\n\thw = &div_gate->divider.hw;\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(div_gate);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}