{
  "module_name": "clk-lpcg-scu.c",
  "hash_id": "d81fc95e35aca4712232d8e97d93e6aa0454d4a0320bc53d9c891071a4ff68fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-lpcg-scu.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include \"clk-scu.h\"\n\nstatic DEFINE_SPINLOCK(imx_lpcg_scu_lock);\n\n#define CLK_GATE_SCU_LPCG_MASK\t\t0x3\n#define CLK_GATE_SCU_LPCG_HW_SEL\tBIT(0)\n#define CLK_GATE_SCU_LPCG_SW_SEL\tBIT(1)\n\n \nstruct clk_lpcg_scu {\n\tstruct clk_hw hw;\n\tvoid __iomem *reg;\n\tu8 bit_idx;\n\tbool hw_gate;\n\n\t \n\tu32 state;\n};\n\n#define to_clk_lpcg_scu(_hw) container_of(_hw, struct clk_lpcg_scu, hw)\n\nstatic int clk_lpcg_scu_enable(struct clk_hw *hw)\n{\n\tstruct clk_lpcg_scu *clk = to_clk_lpcg_scu(hw);\n\tunsigned long flags;\n\tu32 reg, val;\n\n\tspin_lock_irqsave(&imx_lpcg_scu_lock, flags);\n\n\treg = readl_relaxed(clk->reg);\n\treg &= ~(CLK_GATE_SCU_LPCG_MASK << clk->bit_idx);\n\n\tval = CLK_GATE_SCU_LPCG_SW_SEL;\n\tif (clk->hw_gate)\n\t\tval |= CLK_GATE_SCU_LPCG_HW_SEL;\n\n\treg |= val << clk->bit_idx;\n\twritel(reg, clk->reg);\n\n\tspin_unlock_irqrestore(&imx_lpcg_scu_lock, flags);\n\n\treturn 0;\n}\n\nstatic void clk_lpcg_scu_disable(struct clk_hw *hw)\n{\n\tstruct clk_lpcg_scu *clk = to_clk_lpcg_scu(hw);\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&imx_lpcg_scu_lock, flags);\n\n\treg = readl_relaxed(clk->reg);\n\treg &= ~(CLK_GATE_SCU_LPCG_MASK << clk->bit_idx);\n\twritel(reg, clk->reg);\n\n\tspin_unlock_irqrestore(&imx_lpcg_scu_lock, flags);\n}\n\nstatic const struct clk_ops clk_lpcg_scu_ops = {\n\t.enable = clk_lpcg_scu_enable,\n\t.disable = clk_lpcg_scu_disable,\n};\n\nstruct clk_hw *__imx_clk_lpcg_scu(struct device *dev, const char *name,\n\t\t\t\t  const char *parent_name, unsigned long flags,\n\t\t\t\t  void __iomem *reg, u8 bit_idx, bool hw_gate)\n{\n\tstruct clk_lpcg_scu *clk;\n\tstruct clk_init_data init;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tclk = kzalloc(sizeof(*clk), GFP_KERNEL);\n\tif (!clk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk->reg = reg;\n\tclk->bit_idx = bit_idx;\n\tclk->hw_gate = hw_gate;\n\n\tinit.name = name;\n\tinit.ops = &clk_lpcg_scu_ops;\n\tinit.flags = CLK_SET_RATE_PARENT | flags;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\n\tclk->hw.init = &init;\n\n\thw = &clk->hw;\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\tkfree(clk);\n\t\thw = ERR_PTR(ret);\n\t\treturn hw;\n\t}\n\n\tif (dev)\n\t\tdev_set_drvdata(dev, clk);\n\n\treturn hw;\n}\n\nvoid imx_clk_lpcg_scu_unregister(struct clk_hw *hw)\n{\n\tstruct clk_lpcg_scu *clk = to_clk_lpcg_scu(hw);\n\n\tclk_hw_unregister(&clk->hw);\n\tkfree(clk);\n}\n\nstatic int __maybe_unused imx_clk_lpcg_scu_suspend(struct device *dev)\n{\n\tstruct clk_lpcg_scu *clk = dev_get_drvdata(dev);\n\n\tclk->state = readl_relaxed(clk->reg);\n\tdev_dbg(dev, \"save lpcg state 0x%x\\n\", clk->state);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx_clk_lpcg_scu_resume(struct device *dev)\n{\n\tstruct clk_lpcg_scu *clk = dev_get_drvdata(dev);\n\n\t \n\n\twritel(clk->state, clk->reg);\n\twritel(clk->state, clk->reg);\n\tdev_dbg(dev, \"restore lpcg state 0x%x\\n\", clk->state);\n\n\treturn 0;\n}\n\nconst struct dev_pm_ops imx_clk_lpcg_scu_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(imx_clk_lpcg_scu_suspend,\n\t\t\t\t      imx_clk_lpcg_scu_resume)\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}