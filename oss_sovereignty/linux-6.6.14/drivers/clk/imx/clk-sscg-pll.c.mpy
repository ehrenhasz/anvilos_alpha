{
  "module_name": "clk-sscg-pll.c",
  "hash_id": "aa08e607d2b291341a29cad689cc32fdbcb57ec2d6147e668007fe345fc0fb09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-sscg-pll.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/slab.h>\n#include <linux/bitfield.h>\n\n#include \"clk.h\"\n\n \n#define PLL_CFG0\t\t0x0\n#define PLL_CFG1\t\t0x4\n#define PLL_CFG2\t\t0x8\n\n#define PLL_DIVF1_MASK\t\tGENMASK(18, 13)\n#define PLL_DIVF2_MASK\t\tGENMASK(12, 7)\n#define PLL_DIVR1_MASK\t\tGENMASK(27, 25)\n#define PLL_DIVR2_MASK\t\tGENMASK(24, 19)\n#define PLL_DIVQ_MASK           GENMASK(6, 1)\n#define PLL_REF_MASK\t\tGENMASK(2, 0)\n\n#define PLL_LOCK_MASK\t\tBIT(31)\n#define PLL_PD_MASK\t\tBIT(7)\n\n \n#define PLL_REF_MIN_FREQ\t\t25000000UL\n#define PLL_REF_MAX_FREQ\t\t235000000UL\n\n#define PLL_STAGE1_MIN_FREQ\t\t1600000000UL\n#define PLL_STAGE1_MAX_FREQ\t\t2400000000UL\n\n#define PLL_STAGE1_REF_MIN_FREQ\t\t25000000UL\n#define PLL_STAGE1_REF_MAX_FREQ\t\t54000000UL\n\n#define PLL_STAGE2_MIN_FREQ\t\t1200000000UL\n#define PLL_STAGE2_MAX_FREQ\t\t2400000000UL\n\n#define PLL_STAGE2_REF_MIN_FREQ\t\t54000000UL\n#define PLL_STAGE2_REF_MAX_FREQ\t\t75000000UL\n\n#define PLL_OUT_MIN_FREQ\t\t20000000UL\n#define PLL_OUT_MAX_FREQ\t\t1200000000UL\n\n#define PLL_DIVR1_MAX\t\t\t7\n#define PLL_DIVR2_MAX\t\t\t63\n#define PLL_DIVF1_MAX\t\t\t63\n#define PLL_DIVF2_MAX\t\t\t63\n#define PLL_DIVQ_MAX\t\t\t63\n\n#define PLL_BYPASS_NONE\t\t\t0x0\n#define PLL_BYPASS1\t\t\t0x2\n#define PLL_BYPASS2\t\t\t0x1\n\n#define SSCG_PLL_BYPASS1_MASK           BIT(5)\n#define SSCG_PLL_BYPASS2_MASK           BIT(4)\n#define SSCG_PLL_BYPASS_MASK\t\tGENMASK(5, 4)\n\n#define PLL_SCCG_LOCK_TIMEOUT\t\t70\n\nstruct clk_sscg_pll_setup {\n\tint divr1, divf1;\n\tint divr2, divf2;\n\tint divq;\n\tint bypass;\n\tuint64_t vco1;\n\tuint64_t vco2;\n\tuint64_t fout;\n\tuint64_t ref;\n\tuint64_t ref_div1;\n\tuint64_t ref_div2;\n\tuint64_t fout_request;\n\tint fout_error;\n};\n\nstruct clk_sscg_pll {\n\tstruct clk_hw\thw;\n\tconst struct clk_ops  ops;\n\tvoid __iomem *base;\n\tstruct clk_sscg_pll_setup setup;\n\tu8 parent;\n\tu8 bypass1;\n\tu8 bypass2;\n};\n\n#define to_clk_sscg_pll(_hw) container_of(_hw, struct clk_sscg_pll, hw)\n\nstatic int clk_sscg_pll_wait_lock(struct clk_sscg_pll *pll)\n{\n\tu32 val;\n\n\tval = readl_relaxed(pll->base + PLL_CFG0);\n\n\t \n\tif (!(val & SSCG_PLL_BYPASS2_MASK))\n\t\treturn readl_poll_timeout(pll->base, val, val & PLL_LOCK_MASK,\n\t\t\t\t\t\t0, PLL_SCCG_LOCK_TIMEOUT);\n\n\treturn 0;\n}\n\nstatic int clk_sscg_pll2_check_match(struct clk_sscg_pll_setup *setup,\n\t\t\t\t\tstruct clk_sscg_pll_setup *temp_setup)\n{\n\tint new_diff = temp_setup->fout - temp_setup->fout_request;\n\tint diff = temp_setup->fout_error;\n\n\tif (abs(diff) > abs(new_diff)) {\n\t\ttemp_setup->fout_error = new_diff;\n\t\tmemcpy(setup, temp_setup, sizeof(struct clk_sscg_pll_setup));\n\n\t\tif (temp_setup->fout_request == temp_setup->fout)\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic int clk_sscg_divq_lookup(struct clk_sscg_pll_setup *setup,\n\t\t\t\tstruct clk_sscg_pll_setup *temp_setup)\n{\n\tint ret = -EINVAL;\n\n\tfor (temp_setup->divq = 0; temp_setup->divq <= PLL_DIVQ_MAX;\n\t     temp_setup->divq++) {\n\t\ttemp_setup->vco2 = temp_setup->vco1;\n\t\tdo_div(temp_setup->vco2, temp_setup->divr2 + 1);\n\t\ttemp_setup->vco2 *= 2;\n\t\ttemp_setup->vco2 *= temp_setup->divf2 + 1;\n\t\tif (temp_setup->vco2 >= PLL_STAGE2_MIN_FREQ &&\n\t\t\t\ttemp_setup->vco2 <= PLL_STAGE2_MAX_FREQ) {\n\t\t\ttemp_setup->fout = temp_setup->vco2;\n\t\t\tdo_div(temp_setup->fout, 2 * (temp_setup->divq + 1));\n\n\t\t\tret = clk_sscg_pll2_check_match(setup, temp_setup);\n\t\t\tif (!ret) {\n\t\t\t\ttemp_setup->bypass = PLL_BYPASS1;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int clk_sscg_divf2_lookup(struct clk_sscg_pll_setup *setup,\n\t\t\t\t\tstruct clk_sscg_pll_setup *temp_setup)\n{\n\tint ret = -EINVAL;\n\n\tfor (temp_setup->divf2 = 0; temp_setup->divf2 <= PLL_DIVF2_MAX;\n\t     temp_setup->divf2++) {\n\t\tret = clk_sscg_divq_lookup(setup, temp_setup);\n\t\tif (!ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int clk_sscg_divr2_lookup(struct clk_sscg_pll_setup *setup,\n\t\t\t\tstruct clk_sscg_pll_setup *temp_setup)\n{\n\tint ret = -EINVAL;\n\n\tfor (temp_setup->divr2 = 0; temp_setup->divr2 <= PLL_DIVR2_MAX;\n\t     temp_setup->divr2++) {\n\t\ttemp_setup->ref_div2 = temp_setup->vco1;\n\t\tdo_div(temp_setup->ref_div2, temp_setup->divr2 + 1);\n\t\tif (temp_setup->ref_div2 >= PLL_STAGE2_REF_MIN_FREQ &&\n\t\t    temp_setup->ref_div2 <= PLL_STAGE2_REF_MAX_FREQ) {\n\t\t\tret = clk_sscg_divf2_lookup(setup, temp_setup);\n\t\t\tif (!ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int clk_sscg_pll2_find_setup(struct clk_sscg_pll_setup *setup,\n\t\t\t\t\tstruct clk_sscg_pll_setup *temp_setup,\n\t\t\t\t\tuint64_t ref)\n{\n\tint ret;\n\n\tif (ref < PLL_STAGE1_MIN_FREQ || ref > PLL_STAGE1_MAX_FREQ)\n\t\treturn -EINVAL;\n\n\ttemp_setup->vco1 = ref;\n\n\tret = clk_sscg_divr2_lookup(setup, temp_setup);\n\treturn ret;\n}\n\nstatic int clk_sscg_divf1_lookup(struct clk_sscg_pll_setup *setup,\n\t\t\t\tstruct clk_sscg_pll_setup *temp_setup)\n{\n\tint ret = -EINVAL;\n\n\tfor (temp_setup->divf1 = 0; temp_setup->divf1 <= PLL_DIVF1_MAX;\n\t     temp_setup->divf1++) {\n\t\tuint64_t vco1 = temp_setup->ref;\n\n\t\tdo_div(vco1, temp_setup->divr1 + 1);\n\t\tvco1 *= 2;\n\t\tvco1 *= temp_setup->divf1 + 1;\n\n\t\tret = clk_sscg_pll2_find_setup(setup, temp_setup, vco1);\n\t\tif (!ret) {\n\t\t\ttemp_setup->bypass = PLL_BYPASS_NONE;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int clk_sscg_divr1_lookup(struct clk_sscg_pll_setup *setup,\n\t\t\t\tstruct clk_sscg_pll_setup *temp_setup)\n{\n\tint ret = -EINVAL;\n\n\tfor (temp_setup->divr1 = 0; temp_setup->divr1 <= PLL_DIVR1_MAX;\n\t     temp_setup->divr1++) {\n\t\ttemp_setup->ref_div1 = temp_setup->ref;\n\t\tdo_div(temp_setup->ref_div1, temp_setup->divr1 + 1);\n\t\tif (temp_setup->ref_div1 >= PLL_STAGE1_REF_MIN_FREQ &&\n\t\t    temp_setup->ref_div1 <= PLL_STAGE1_REF_MAX_FREQ) {\n\t\t\tret = clk_sscg_divf1_lookup(setup, temp_setup);\n\t\t\tif (!ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int clk_sscg_pll1_find_setup(struct clk_sscg_pll_setup *setup,\n\t\t\t\t\tstruct clk_sscg_pll_setup *temp_setup,\n\t\t\t\t\tuint64_t ref)\n{\n\tint ret;\n\n\tif (ref < PLL_REF_MIN_FREQ || ref > PLL_REF_MAX_FREQ)\n\t\treturn -EINVAL;\n\n\ttemp_setup->ref = ref;\n\n\tret = clk_sscg_divr1_lookup(setup, temp_setup);\n\n\treturn ret;\n}\n\nstatic int clk_sscg_pll_find_setup(struct clk_sscg_pll_setup *setup,\n\t\t\t\t\tuint64_t prate,\n\t\t\t\t\tuint64_t rate, int try_bypass)\n{\n\tstruct clk_sscg_pll_setup temp_setup;\n\tint ret = -EINVAL;\n\n\tmemset(&temp_setup, 0, sizeof(struct clk_sscg_pll_setup));\n\tmemset(setup, 0, sizeof(struct clk_sscg_pll_setup));\n\n\ttemp_setup.fout_error = PLL_OUT_MAX_FREQ;\n\ttemp_setup.fout_request = rate;\n\n\tswitch (try_bypass) {\n\tcase PLL_BYPASS2:\n\t\tif (prate == rate) {\n\t\t\tsetup->bypass = PLL_BYPASS2;\n\t\t\tsetup->fout = rate;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\tcase PLL_BYPASS1:\n\t\tret = clk_sscg_pll2_find_setup(setup, &temp_setup, prate);\n\t\tbreak;\n\tcase PLL_BYPASS_NONE:\n\t\tret = clk_sscg_pll1_find_setup(setup, &temp_setup, prate);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int clk_sscg_pll_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_sscg_pll *pll = to_clk_sscg_pll(hw);\n\n\tu32 val = readl_relaxed(pll->base + PLL_CFG0);\n\n\treturn (val & PLL_PD_MASK) ? 0 : 1;\n}\n\nstatic int clk_sscg_pll_prepare(struct clk_hw *hw)\n{\n\tstruct clk_sscg_pll *pll = to_clk_sscg_pll(hw);\n\tu32 val;\n\n\tval = readl_relaxed(pll->base + PLL_CFG0);\n\tval &= ~PLL_PD_MASK;\n\twritel_relaxed(val, pll->base + PLL_CFG0);\n\n\treturn clk_sscg_pll_wait_lock(pll);\n}\n\nstatic void clk_sscg_pll_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_sscg_pll *pll = to_clk_sscg_pll(hw);\n\tu32 val;\n\n\tval = readl_relaxed(pll->base + PLL_CFG0);\n\tval |= PLL_PD_MASK;\n\twritel_relaxed(val, pll->base + PLL_CFG0);\n}\n\nstatic unsigned long clk_sscg_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_sscg_pll *pll = to_clk_sscg_pll(hw);\n\tu32 val, divr1, divf1, divr2, divf2, divq;\n\tu64 temp64;\n\n\tval = readl_relaxed(pll->base + PLL_CFG2);\n\tdivr1 = FIELD_GET(PLL_DIVR1_MASK, val);\n\tdivr2 = FIELD_GET(PLL_DIVR2_MASK, val);\n\tdivf1 = FIELD_GET(PLL_DIVF1_MASK, val);\n\tdivf2 = FIELD_GET(PLL_DIVF2_MASK, val);\n\tdivq = FIELD_GET(PLL_DIVQ_MASK, val);\n\n\ttemp64 = parent_rate;\n\n\tval = readl(pll->base + PLL_CFG0);\n\tif (val & SSCG_PLL_BYPASS2_MASK) {\n\t\ttemp64 = parent_rate;\n\t} else if (val & SSCG_PLL_BYPASS1_MASK) {\n\t\ttemp64 *= divf2;\n\t\tdo_div(temp64, (divr2 + 1) * (divq + 1));\n\t} else {\n\t\ttemp64 *= 2;\n\t\ttemp64 *= (divf1 + 1) * (divf2 + 1);\n\t\tdo_div(temp64, (divr1 + 1) * (divr2 + 1) * (divq + 1));\n\t}\n\n\treturn temp64;\n}\n\nstatic int clk_sscg_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_sscg_pll *pll = to_clk_sscg_pll(hw);\n\tstruct clk_sscg_pll_setup *setup = &pll->setup;\n\tu32 val;\n\n\t \n\tval = readl(pll->base + PLL_CFG0);\n\tval &= ~SSCG_PLL_BYPASS_MASK;\n\tval |= FIELD_PREP(SSCG_PLL_BYPASS_MASK, setup->bypass);\n\twritel(val, pll->base + PLL_CFG0);\n\n\tval = readl_relaxed(pll->base + PLL_CFG2);\n\tval &= ~(PLL_DIVF1_MASK | PLL_DIVF2_MASK);\n\tval &= ~(PLL_DIVR1_MASK | PLL_DIVR2_MASK | PLL_DIVQ_MASK);\n\tval |= FIELD_PREP(PLL_DIVF1_MASK, setup->divf1);\n\tval |= FIELD_PREP(PLL_DIVF2_MASK, setup->divf2);\n\tval |= FIELD_PREP(PLL_DIVR1_MASK, setup->divr1);\n\tval |= FIELD_PREP(PLL_DIVR2_MASK, setup->divr2);\n\tval |= FIELD_PREP(PLL_DIVQ_MASK, setup->divq);\n\twritel_relaxed(val, pll->base + PLL_CFG2);\n\n\treturn clk_sscg_pll_wait_lock(pll);\n}\n\nstatic u8 clk_sscg_pll_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_sscg_pll *pll = to_clk_sscg_pll(hw);\n\tu32 val;\n\tu8 ret = pll->parent;\n\n\tval = readl(pll->base + PLL_CFG0);\n\tif (val & SSCG_PLL_BYPASS2_MASK)\n\t\tret = pll->bypass2;\n\telse if (val & SSCG_PLL_BYPASS1_MASK)\n\t\tret = pll->bypass1;\n\treturn ret;\n}\n\nstatic int clk_sscg_pll_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_sscg_pll *pll = to_clk_sscg_pll(hw);\n\tu32 val;\n\n\tval = readl(pll->base + PLL_CFG0);\n\tval &= ~SSCG_PLL_BYPASS_MASK;\n\tval |= FIELD_PREP(SSCG_PLL_BYPASS_MASK, pll->setup.bypass);\n\twritel(val, pll->base + PLL_CFG0);\n\n\treturn clk_sscg_pll_wait_lock(pll);\n}\n\nstatic int __clk_sscg_pll_determine_rate(struct clk_hw *hw,\n\t\t\t\t\tstruct clk_rate_request *req,\n\t\t\t\t\tuint64_t min,\n\t\t\t\t\tuint64_t max,\n\t\t\t\t\tuint64_t rate,\n\t\t\t\t\tint bypass)\n{\n\tstruct clk_sscg_pll *pll = to_clk_sscg_pll(hw);\n\tstruct clk_sscg_pll_setup *setup = &pll->setup;\n\tstruct clk_hw *parent_hw = NULL;\n\tint bypass_parent_index;\n\tint ret;\n\n\treq->max_rate = max;\n\treq->min_rate = min;\n\n\tswitch (bypass) {\n\tcase PLL_BYPASS2:\n\t\tbypass_parent_index = pll->bypass2;\n\t\tbreak;\n\tcase PLL_BYPASS1:\n\t\tbypass_parent_index = pll->bypass1;\n\t\tbreak;\n\tdefault:\n\t\tbypass_parent_index = pll->parent;\n\t\tbreak;\n\t}\n\n\tparent_hw = clk_hw_get_parent_by_index(hw, bypass_parent_index);\n\tret = __clk_determine_rate(parent_hw, req);\n\tif (!ret) {\n\t\tret = clk_sscg_pll_find_setup(setup, req->rate,\n\t\t\t\t\t\trate, bypass);\n\t}\n\n\treq->best_parent_hw = parent_hw;\n\treq->best_parent_rate = req->rate;\n\treq->rate = setup->fout;\n\n\treturn ret;\n}\n\nstatic int clk_sscg_pll_determine_rate(struct clk_hw *hw,\n\t\t\t\t       struct clk_rate_request *req)\n{\n\tstruct clk_sscg_pll *pll = to_clk_sscg_pll(hw);\n\tstruct clk_sscg_pll_setup *setup = &pll->setup;\n\tuint64_t rate = req->rate;\n\tuint64_t min = req->min_rate;\n\tuint64_t max = req->max_rate;\n\tint ret;\n\n\tif (rate < PLL_OUT_MIN_FREQ || rate > PLL_OUT_MAX_FREQ)\n\t\treturn -EINVAL;\n\n\tret = __clk_sscg_pll_determine_rate(hw, req, req->rate, req->rate,\n\t\t\t\t\t\trate, PLL_BYPASS2);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = __clk_sscg_pll_determine_rate(hw, req, PLL_STAGE1_REF_MIN_FREQ,\n\t\t\t\t\t\tPLL_STAGE1_REF_MAX_FREQ, rate,\n\t\t\t\t\t\tPLL_BYPASS1);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = __clk_sscg_pll_determine_rate(hw, req, PLL_REF_MIN_FREQ,\n\t\t\t\t\t\tPLL_REF_MAX_FREQ, rate,\n\t\t\t\t\t\tPLL_BYPASS_NONE);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (setup->fout >= min && setup->fout <= max)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic const struct clk_ops clk_sscg_pll_ops = {\n\t.prepare\t= clk_sscg_pll_prepare,\n\t.unprepare\t= clk_sscg_pll_unprepare,\n\t.is_prepared\t= clk_sscg_pll_is_prepared,\n\t.recalc_rate\t= clk_sscg_pll_recalc_rate,\n\t.set_rate\t= clk_sscg_pll_set_rate,\n\t.set_parent\t= clk_sscg_pll_set_parent,\n\t.get_parent\t= clk_sscg_pll_get_parent,\n\t.determine_rate\t= clk_sscg_pll_determine_rate,\n};\n\nstruct clk_hw *imx_clk_hw_sscg_pll(const char *name,\n\t\t\t\tconst char * const *parent_names,\n\t\t\t\tu8 num_parents,\n\t\t\t\tu8 parent, u8 bypass1, u8 bypass2,\n\t\t\t\tvoid __iomem *base,\n\t\t\t\tunsigned long flags)\n{\n\tstruct clk_sscg_pll *pll;\n\tstruct clk_init_data init;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpll->parent = parent;\n\tpll->bypass1 = bypass1;\n\tpll->bypass2 = bypass2;\n\n\tpll->base = base;\n\tinit.name = name;\n\tinit.ops = &clk_sscg_pll_ops;\n\n\tinit.flags = flags;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\n\tpll->hw.init = &init;\n\n\thw = &pll->hw;\n\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(pll);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(imx_clk_hw_sscg_pll);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}