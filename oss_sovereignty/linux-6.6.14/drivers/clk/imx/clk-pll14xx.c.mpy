{
  "module_name": "clk-pll14xx.c",
  "hash_id": "acccdc1a8f276af6b88b5f904d2c35731d747f9ad9888eacf1a3f0205db7796f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-pll14xx.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"pll14xx: \" fmt\n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n\n#include \"clk.h\"\n\n#define GNRL_CTL\t0x0\n#define DIV_CTL0\t0x4\n#define DIV_CTL1\t0x8\n#define LOCK_STATUS\tBIT(31)\n#define LOCK_SEL_MASK\tBIT(29)\n#define CLKE_MASK\tBIT(11)\n#define RST_MASK\tBIT(9)\n#define BYPASS_MASK\tBIT(4)\n#define MDIV_MASK\tGENMASK(21, 12)\n#define PDIV_MASK\tGENMASK(9, 4)\n#define SDIV_MASK\tGENMASK(2, 0)\n#define KDIV_MASK\tGENMASK(15, 0)\n#define KDIV_MIN\tSHRT_MIN\n#define KDIV_MAX\tSHRT_MAX\n\n#define LOCK_TIMEOUT_US\t\t10000\n\nstruct clk_pll14xx {\n\tstruct clk_hw\t\t\thw;\n\tvoid __iomem\t\t\t*base;\n\tenum imx_pll14xx_type\t\ttype;\n\tconst struct imx_pll14xx_rate_table *rate_table;\n\tint rate_count;\n};\n\n#define to_clk_pll14xx(_hw) container_of(_hw, struct clk_pll14xx, hw)\n\nstatic const struct imx_pll14xx_rate_table imx_pll1416x_tbl[] = {\n\tPLL_1416X_RATE(1800000000U, 225, 3, 0),\n\tPLL_1416X_RATE(1600000000U, 200, 3, 0),\n\tPLL_1416X_RATE(1500000000U, 375, 3, 1),\n\tPLL_1416X_RATE(1400000000U, 350, 3, 1),\n\tPLL_1416X_RATE(1200000000U, 300, 3, 1),\n\tPLL_1416X_RATE(1000000000U, 250, 3, 1),\n\tPLL_1416X_RATE(800000000U,  200, 3, 1),\n\tPLL_1416X_RATE(750000000U,  250, 2, 2),\n\tPLL_1416X_RATE(700000000U,  350, 3, 2),\n\tPLL_1416X_RATE(640000000U,  320, 3, 2),\n\tPLL_1416X_RATE(600000000U,  300, 3, 2),\n\tPLL_1416X_RATE(320000000U,  160, 3, 2),\n};\n\nstatic const struct imx_pll14xx_rate_table imx_pll1443x_tbl[] = {\n\tPLL_1443X_RATE(1039500000U, 173, 2, 1, 16384),\n\tPLL_1443X_RATE(650000000U, 325, 3, 2, 0),\n\tPLL_1443X_RATE(594000000U, 198, 2, 2, 0),\n\tPLL_1443X_RATE(519750000U, 173, 2, 2, 16384),\n};\n\nstruct imx_pll14xx_clk imx_1443x_pll = {\n\t.type = PLL_1443X,\n\t.rate_table = imx_pll1443x_tbl,\n\t.rate_count = ARRAY_SIZE(imx_pll1443x_tbl),\n};\nEXPORT_SYMBOL_GPL(imx_1443x_pll);\n\nstruct imx_pll14xx_clk imx_1443x_dram_pll = {\n\t.type = PLL_1443X,\n\t.rate_table = imx_pll1443x_tbl,\n\t.rate_count = ARRAY_SIZE(imx_pll1443x_tbl),\n\t.flags = CLK_GET_RATE_NOCACHE,\n};\nEXPORT_SYMBOL_GPL(imx_1443x_dram_pll);\n\nstruct imx_pll14xx_clk imx_1416x_pll = {\n\t.type = PLL_1416X,\n\t.rate_table = imx_pll1416x_tbl,\n\t.rate_count = ARRAY_SIZE(imx_pll1416x_tbl),\n};\nEXPORT_SYMBOL_GPL(imx_1416x_pll);\n\nstatic const struct imx_pll14xx_rate_table *imx_get_pll_settings(\n\t\tstruct clk_pll14xx *pll, unsigned long rate)\n{\n\tconst struct imx_pll14xx_rate_table *rate_table = pll->rate_table;\n\tint i;\n\n\tfor (i = 0; i < pll->rate_count; i++)\n\t\tif (rate == rate_table[i].rate)\n\t\t\treturn &rate_table[i];\n\n\treturn NULL;\n}\n\nstatic long pll14xx_calc_rate(struct clk_pll14xx *pll, int mdiv, int pdiv,\n\t\t\t      int sdiv, int kdiv, unsigned long prate)\n{\n\tu64 fvco = prate;\n\n\t \n\tfvco *= (mdiv * 65536 + kdiv);\n\tpdiv *= 65536;\n\n\tdo_div(fvco, pdiv << sdiv);\n\n\treturn fvco;\n}\n\nstatic long pll1443x_calc_kdiv(int mdiv, int pdiv, int sdiv,\n\t\tunsigned long rate, unsigned long prate)\n{\n\tlong kdiv;\n\n\t \n\tkdiv = ((rate * ((pdiv * 65536) << sdiv) + prate / 2) / prate) - (mdiv * 65536);\n\n\treturn clamp_t(short, kdiv, KDIV_MIN, KDIV_MAX);\n}\n\nstatic void imx_pll14xx_calc_settings(struct clk_pll14xx *pll, unsigned long rate,\n\t\t\t\t      unsigned long prate, struct imx_pll14xx_rate_table *t)\n{\n\tu32 pll_div_ctl0, pll_div_ctl1;\n\tint mdiv, pdiv, sdiv, kdiv;\n\tlong fvco, rate_min, rate_max, dist, best = LONG_MAX;\n\tconst struct imx_pll14xx_rate_table *tt;\n\n\t \n\n\t \n\ttt = imx_get_pll_settings(pll, rate);\n\tif (tt) {\n\t\tpr_debug(\"%s: in=%ld, want=%ld, Using PLL setting from table\\n\",\n\t\t\t clk_hw_get_name(&pll->hw), prate, rate);\n\t\tt->rate = tt->rate;\n\t\tt->mdiv = tt->mdiv;\n\t\tt->pdiv = tt->pdiv;\n\t\tt->sdiv = tt->sdiv;\n\t\tt->kdiv = tt->kdiv;\n\t\treturn;\n\t}\n\n\tpll_div_ctl0 = readl_relaxed(pll->base + DIV_CTL0);\n\tmdiv = FIELD_GET(MDIV_MASK, pll_div_ctl0);\n\tpdiv = FIELD_GET(PDIV_MASK, pll_div_ctl0);\n\tsdiv = FIELD_GET(SDIV_MASK, pll_div_ctl0);\n\tpll_div_ctl1 = readl_relaxed(pll->base + DIV_CTL1);\n\n\t \n\trate_min = pll14xx_calc_rate(pll, mdiv, pdiv, sdiv, KDIV_MIN, prate);\n\trate_max = pll14xx_calc_rate(pll, mdiv, pdiv, sdiv, KDIV_MAX, prate);\n\n\tif (rate >= rate_min && rate <= rate_max) {\n\t\tkdiv = pll1443x_calc_kdiv(mdiv, pdiv, sdiv, rate, prate);\n\t\tpr_debug(\"%s: in=%ld, want=%ld Only adjust kdiv %ld -> %d\\n\",\n\t\t\t clk_hw_get_name(&pll->hw), prate, rate,\n\t\t\t FIELD_GET(KDIV_MASK, pll_div_ctl1), kdiv);\n\t\tfvco = pll14xx_calc_rate(pll, mdiv, pdiv, sdiv, kdiv, prate);\n\t\tt->rate = (unsigned int)fvco;\n\t\tt->mdiv = mdiv;\n\t\tt->pdiv = pdiv;\n\t\tt->sdiv = sdiv;\n\t\tt->kdiv = kdiv;\n\t\treturn;\n\t}\n\n\t \n\tfor (pdiv = 1; pdiv <= 63; pdiv++) {\n\t\tfor (sdiv = 0; sdiv <= 6; sdiv++) {\n\t\t\t \n\t\t\tmdiv = DIV_ROUND_CLOSEST(rate * (pdiv << sdiv), prate);\n\t\t\tmdiv = clamp(mdiv, 64, 1023);\n\n\t\t\tkdiv = pll1443x_calc_kdiv(mdiv, pdiv, sdiv, rate, prate);\n\t\t\tfvco = pll14xx_calc_rate(pll, mdiv, pdiv, sdiv, kdiv, prate);\n\n\t\t\t \n\t\t\tdist = abs((long)rate - (long)fvco);\n\t\t\tif (dist < best) {\n\t\t\t\tbest = dist;\n\t\t\t\tt->rate = (unsigned int)fvco;\n\t\t\t\tt->mdiv = mdiv;\n\t\t\t\tt->pdiv = pdiv;\n\t\t\t\tt->sdiv = sdiv;\n\t\t\t\tt->kdiv = kdiv;\n\n\t\t\t\tif (!dist)\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\nfound:\n\tpr_debug(\"%s: in=%ld, want=%ld got=%d (pdiv=%d sdiv=%d mdiv=%d kdiv=%d)\\n\",\n\t\t clk_hw_get_name(&pll->hw), prate, rate, t->rate, t->pdiv, t->sdiv,\n\t\t t->mdiv, t->kdiv);\n}\n\nstatic long clk_pll1416x_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\tunsigned long *prate)\n{\n\tstruct clk_pll14xx *pll = to_clk_pll14xx(hw);\n\tconst struct imx_pll14xx_rate_table *rate_table = pll->rate_table;\n\tint i;\n\n\t \n\tfor (i = 0; i < pll->rate_count; i++)\n\t\tif (rate >= rate_table[i].rate)\n\t\t\treturn rate_table[i].rate;\n\n\t \n\treturn rate_table[pll->rate_count - 1].rate;\n}\n\nstatic long clk_pll1443x_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\tunsigned long *prate)\n{\n\tstruct clk_pll14xx *pll = to_clk_pll14xx(hw);\n\tstruct imx_pll14xx_rate_table t;\n\n\timx_pll14xx_calc_settings(pll, rate, *prate, &t);\n\n\treturn t.rate;\n}\n\nstatic unsigned long clk_pll14xx_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_pll14xx *pll = to_clk_pll14xx(hw);\n\tu32 mdiv, pdiv, sdiv, kdiv, pll_div_ctl0, pll_div_ctl1;\n\n\tpll_div_ctl0 = readl_relaxed(pll->base + DIV_CTL0);\n\tmdiv = FIELD_GET(MDIV_MASK, pll_div_ctl0);\n\tpdiv = FIELD_GET(PDIV_MASK, pll_div_ctl0);\n\tsdiv = FIELD_GET(SDIV_MASK, pll_div_ctl0);\n\n\tif (pll->type == PLL_1443X) {\n\t\tpll_div_ctl1 = readl_relaxed(pll->base + DIV_CTL1);\n\t\tkdiv = (s16)FIELD_GET(KDIV_MASK, pll_div_ctl1);\n\t} else {\n\t\tkdiv = 0;\n\t}\n\n\treturn pll14xx_calc_rate(pll, mdiv, pdiv, sdiv, kdiv, parent_rate);\n}\n\nstatic inline bool clk_pll14xx_mp_change(const struct imx_pll14xx_rate_table *rate,\n\t\t\t\t\t  u32 pll_div)\n{\n\tu32 old_mdiv, old_pdiv;\n\n\told_mdiv = FIELD_GET(MDIV_MASK, pll_div);\n\told_pdiv = FIELD_GET(PDIV_MASK, pll_div);\n\n\treturn rate->mdiv != old_mdiv || rate->pdiv != old_pdiv;\n}\n\nstatic int clk_pll14xx_wait_lock(struct clk_pll14xx *pll)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(pll->base + GNRL_CTL, val, val & LOCK_STATUS, 0,\n\t\t\tLOCK_TIMEOUT_US);\n}\n\nstatic int clk_pll1416x_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t unsigned long prate)\n{\n\tstruct clk_pll14xx *pll = to_clk_pll14xx(hw);\n\tconst struct imx_pll14xx_rate_table *rate;\n\tu32 tmp, div_val;\n\tint ret;\n\n\trate = imx_get_pll_settings(pll, drate);\n\tif (!rate) {\n\t\tpr_err(\"Invalid rate %lu for pll clk %s\\n\", drate,\n\t\t       clk_hw_get_name(hw));\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = readl_relaxed(pll->base + DIV_CTL0);\n\n\tif (!clk_pll14xx_mp_change(rate, tmp)) {\n\t\ttmp &= ~SDIV_MASK;\n\t\ttmp |= FIELD_PREP(SDIV_MASK, rate->sdiv);\n\t\twritel_relaxed(tmp, pll->base + DIV_CTL0);\n\n\t\treturn 0;\n\t}\n\n\t \n\ttmp = readl_relaxed(pll->base + GNRL_CTL);\n\ttmp |= LOCK_SEL_MASK;\n\twritel_relaxed(tmp, pll->base + GNRL_CTL);\n\n\t \n\ttmp &= ~RST_MASK;\n\twritel_relaxed(tmp, pll->base + GNRL_CTL);\n\n\t \n\ttmp |= BYPASS_MASK;\n\twritel(tmp, pll->base + GNRL_CTL);\n\n\tdiv_val = FIELD_PREP(MDIV_MASK, rate->mdiv) | FIELD_PREP(PDIV_MASK, rate->pdiv) |\n\t\tFIELD_PREP(SDIV_MASK, rate->sdiv);\n\twritel_relaxed(div_val, pll->base + DIV_CTL0);\n\n\t \n\tudelay(3);\n\n\t \n\ttmp |= RST_MASK;\n\twritel_relaxed(tmp, pll->base + GNRL_CTL);\n\n\t \n\tret = clk_pll14xx_wait_lock(pll);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttmp &= ~BYPASS_MASK;\n\twritel_relaxed(tmp, pll->base + GNRL_CTL);\n\n\treturn 0;\n}\n\nstatic int clk_pll1443x_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t unsigned long prate)\n{\n\tstruct clk_pll14xx *pll = to_clk_pll14xx(hw);\n\tstruct imx_pll14xx_rate_table rate;\n\tu32 gnrl_ctl, div_ctl0;\n\tint ret;\n\n\timx_pll14xx_calc_settings(pll, drate, prate, &rate);\n\n\tdiv_ctl0 = readl_relaxed(pll->base + DIV_CTL0);\n\n\tif (!clk_pll14xx_mp_change(&rate, div_ctl0)) {\n\t\t \n\t\tdiv_ctl0 &= ~SDIV_MASK;\n\t\tdiv_ctl0 |= FIELD_PREP(SDIV_MASK, rate.sdiv);\n\t\twritel_relaxed(div_ctl0, pll->base + DIV_CTL0);\n\n\t\twritel_relaxed(FIELD_PREP(KDIV_MASK, rate.kdiv),\n\t\t\t       pll->base + DIV_CTL1);\n\n\t\treturn 0;\n\t}\n\n\t \n\tgnrl_ctl = readl_relaxed(pll->base + GNRL_CTL);\n\tgnrl_ctl &= ~RST_MASK;\n\twritel_relaxed(gnrl_ctl, pll->base + GNRL_CTL);\n\n\t \n\tgnrl_ctl |= BYPASS_MASK;\n\twritel_relaxed(gnrl_ctl, pll->base + GNRL_CTL);\n\n\tdiv_ctl0 = FIELD_PREP(MDIV_MASK, rate.mdiv) |\n\t\t   FIELD_PREP(PDIV_MASK, rate.pdiv) |\n\t\t   FIELD_PREP(SDIV_MASK, rate.sdiv);\n\twritel_relaxed(div_ctl0, pll->base + DIV_CTL0);\n\n\twritel_relaxed(FIELD_PREP(KDIV_MASK, rate.kdiv), pll->base + DIV_CTL1);\n\n\t \n\tudelay(3);\n\n\t \n\tgnrl_ctl |= RST_MASK;\n\twritel_relaxed(gnrl_ctl, pll->base + GNRL_CTL);\n\n\t \n\tret = clk_pll14xx_wait_lock(pll);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tgnrl_ctl &= ~BYPASS_MASK;\n\twritel_relaxed(gnrl_ctl, pll->base + GNRL_CTL);\n\n\treturn 0;\n}\n\nstatic int clk_pll14xx_prepare(struct clk_hw *hw)\n{\n\tstruct clk_pll14xx *pll = to_clk_pll14xx(hw);\n\tu32 val;\n\tint ret;\n\n\t \n\tval = readl_relaxed(pll->base + GNRL_CTL);\n\tif (val & RST_MASK)\n\t\treturn 0;\n\tval |= BYPASS_MASK;\n\twritel_relaxed(val, pll->base + GNRL_CTL);\n\tval |= RST_MASK;\n\twritel_relaxed(val, pll->base + GNRL_CTL);\n\n\tret = clk_pll14xx_wait_lock(pll);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~BYPASS_MASK;\n\twritel_relaxed(val, pll->base + GNRL_CTL);\n\n\treturn 0;\n}\n\nstatic int clk_pll14xx_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_pll14xx *pll = to_clk_pll14xx(hw);\n\tu32 val;\n\n\tval = readl_relaxed(pll->base + GNRL_CTL);\n\n\treturn (val & RST_MASK) ? 1 : 0;\n}\n\nstatic void clk_pll14xx_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_pll14xx *pll = to_clk_pll14xx(hw);\n\tu32 val;\n\n\t \n\tval = readl_relaxed(pll->base + GNRL_CTL);\n\tval &= ~RST_MASK;\n\twritel_relaxed(val, pll->base + GNRL_CTL);\n}\n\nstatic const struct clk_ops clk_pll1416x_ops = {\n\t.prepare\t= clk_pll14xx_prepare,\n\t.unprepare\t= clk_pll14xx_unprepare,\n\t.is_prepared\t= clk_pll14xx_is_prepared,\n\t.recalc_rate\t= clk_pll14xx_recalc_rate,\n\t.round_rate\t= clk_pll1416x_round_rate,\n\t.set_rate\t= clk_pll1416x_set_rate,\n};\n\nstatic const struct clk_ops clk_pll1416x_min_ops = {\n\t.recalc_rate\t= clk_pll14xx_recalc_rate,\n};\n\nstatic const struct clk_ops clk_pll1443x_ops = {\n\t.prepare\t= clk_pll14xx_prepare,\n\t.unprepare\t= clk_pll14xx_unprepare,\n\t.is_prepared\t= clk_pll14xx_is_prepared,\n\t.recalc_rate\t= clk_pll14xx_recalc_rate,\n\t.round_rate\t= clk_pll1443x_round_rate,\n\t.set_rate\t= clk_pll1443x_set_rate,\n};\n\nstruct clk_hw *imx_dev_clk_hw_pll14xx(struct device *dev, const char *name,\n\t\t\t\tconst char *parent_name, void __iomem *base,\n\t\t\t\tconst struct imx_pll14xx_clk *pll_clk)\n{\n\tstruct clk_pll14xx *pll;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\tu32 val;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.flags = pll_clk->flags;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tswitch (pll_clk->type) {\n\tcase PLL_1416X:\n\t\tif (!pll_clk->rate_table)\n\t\t\tinit.ops = &clk_pll1416x_min_ops;\n\t\telse\n\t\t\tinit.ops = &clk_pll1416x_ops;\n\t\tbreak;\n\tcase PLL_1443X:\n\t\tinit.ops = &clk_pll1443x_ops;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown pll type for pll clk %s\\n\", name);\n\t\tkfree(pll);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpll->base = base;\n\tpll->hw.init = &init;\n\tpll->type = pll_clk->type;\n\tpll->rate_table = pll_clk->rate_table;\n\tpll->rate_count = pll_clk->rate_count;\n\n\tval = readl_relaxed(pll->base + GNRL_CTL);\n\tval &= ~BYPASS_MASK;\n\twritel_relaxed(val, pll->base + GNRL_CTL);\n\n\thw = &pll->hw;\n\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\tpr_err(\"failed to register pll %s %d\\n\", name, ret);\n\t\tkfree(pll);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(imx_dev_clk_hw_pll14xx);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}