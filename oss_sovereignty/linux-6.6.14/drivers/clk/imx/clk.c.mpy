{
  "module_name": "clk.c",
  "hash_id": "949dd80300b55684194a6b1d0294e4097791d755441d2d73543b83c13864dc3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk.c",
  "human_readable_source": "\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include \"clk.h\"\n\n#define CCM_CCDR\t\t\t0x4\n#define CCDR_MMDC_CH0_MASK\t\tBIT(17)\n#define CCDR_MMDC_CH1_MASK\t\tBIT(16)\n\nDEFINE_SPINLOCK(imx_ccm_lock);\nEXPORT_SYMBOL_GPL(imx_ccm_lock);\n\nbool mcore_booted;\nEXPORT_SYMBOL_GPL(mcore_booted);\n\nvoid imx_unregister_hw_clocks(struct clk_hw *hws[], unsigned int count)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tclk_hw_unregister(hws[i]);\n}\nEXPORT_SYMBOL_GPL(imx_unregister_hw_clocks);\n\nvoid imx_mmdc_mask_handshake(void __iomem *ccm_base,\n\t\t\t\t    unsigned int chn)\n{\n\tunsigned int reg;\n\n\treg = readl_relaxed(ccm_base + CCM_CCDR);\n\treg |= chn == 0 ? CCDR_MMDC_CH0_MASK : CCDR_MMDC_CH1_MASK;\n\twritel_relaxed(reg, ccm_base + CCM_CCDR);\n}\n\nvoid imx_check_clocks(struct clk *clks[], unsigned int count)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < count; i++)\n\t\tif (IS_ERR(clks[i]))\n\t\t\tpr_err(\"i.MX clk %u: register failed with %ld\\n\",\n\t\t\t       i, PTR_ERR(clks[i]));\n}\n\nvoid imx_check_clk_hws(struct clk_hw *clks[], unsigned int count)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tif (IS_ERR(clks[i]))\n\t\t\tpr_err(\"i.MX clk %u: register failed with %ld\\n\",\n\t\t\t       i, PTR_ERR(clks[i]));\n}\nEXPORT_SYMBOL_GPL(imx_check_clk_hws);\n\nstatic struct clk *imx_obtain_fixed_clock_from_dt(const char *name)\n{\n\tstruct of_phandle_args phandle;\n\tstruct clk *clk = ERR_PTR(-ENODEV);\n\tchar *path;\n\n\tpath = kasprintf(GFP_KERNEL, \"/clocks/%s\", name);\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tphandle.np = of_find_node_by_path(path);\n\tkfree(path);\n\n\tif (phandle.np) {\n\t\tclk = of_clk_get_from_provider(&phandle);\n\t\tof_node_put(phandle.np);\n\t}\n\treturn clk;\n}\n\nstruct clk *imx_obtain_fixed_clock(\n\t\t\tconst char *name, unsigned long rate)\n{\n\tstruct clk *clk;\n\n\tclk = imx_obtain_fixed_clock_from_dt(name);\n\tif (IS_ERR(clk))\n\t\tclk = imx_clk_fixed(name, rate);\n\treturn clk;\n}\n\nstruct clk_hw *imx_obtain_fixed_clock_hw(\n\t\t\tconst char *name, unsigned long rate)\n{\n\tstruct clk *clk;\n\n\tclk = imx_obtain_fixed_clock_from_dt(name);\n\tif (IS_ERR(clk))\n\t\tclk = imx_clk_fixed(name, rate);\n\treturn __clk_get_hw(clk);\n}\n\nstruct clk_hw *imx_obtain_fixed_of_clock(struct device_node *np,\n\t\t\t\t\t const char *name, unsigned long rate)\n{\n\tstruct clk *clk = of_clk_get_by_name(np, name);\n\tstruct clk_hw *hw;\n\n\tif (IS_ERR(clk))\n\t\thw = imx_obtain_fixed_clock_hw(name, rate);\n\telse\n\t\thw = __clk_get_hw(clk);\n\n\treturn hw;\n}\n\nstruct clk_hw *imx_get_clk_hw_by_name(struct device_node *np, const char *name)\n{\n\tstruct clk *clk;\n\n\tclk = of_clk_get_by_name(np, name);\n\tif (IS_ERR(clk))\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn __clk_get_hw(clk);\n}\nEXPORT_SYMBOL_GPL(imx_get_clk_hw_by_name);\n\n \n#define CSCMR1_FIXUP\t0x00600000\n\nvoid imx_cscmr1_fixup(u32 *val)\n{\n\t*val ^= CSCMR1_FIXUP;\n\treturn;\n}\n\n#ifndef MODULE\n\nstatic bool imx_keep_uart_clocks;\nstatic int imx_enabled_uart_clocks;\nstatic struct clk **imx_uart_clocks;\n\nstatic int __init imx_keep_uart_clocks_param(char *str)\n{\n\timx_keep_uart_clocks = 1;\n\n\treturn 0;\n}\n__setup_param(\"earlycon\", imx_keep_uart_earlycon,\n\t      imx_keep_uart_clocks_param, 0);\n__setup_param(\"earlyprintk\", imx_keep_uart_earlyprintk,\n\t      imx_keep_uart_clocks_param, 0);\n\nvoid imx_register_uart_clocks(void)\n{\n\tunsigned int num __maybe_unused;\n\n\timx_enabled_uart_clocks = 0;\n\n \n#ifdef CONFIG_OF\n\tif (imx_keep_uart_clocks) {\n\t\tint i;\n\n\t\tnum = of_clk_get_parent_count(of_stdout);\n\t\tif (!num)\n\t\t\treturn;\n\n\t\tif (!of_stdout)\n\t\t\treturn;\n\n\t\timx_uart_clocks = kcalloc(num, sizeof(struct clk *), GFP_KERNEL);\n\t\tif (!imx_uart_clocks)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\timx_uart_clocks[imx_enabled_uart_clocks] = of_clk_get(of_stdout, i);\n\n\t\t\t \n\t\t\tif (IS_ERR(imx_uart_clocks[imx_enabled_uart_clocks]))\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tif (imx_uart_clocks[imx_enabled_uart_clocks])\n\t\t\t\tclk_prepare_enable(imx_uart_clocks[imx_enabled_uart_clocks++]);\n\t\t}\n\t}\n#endif\n}\n\nstatic int __init imx_clk_disable_uart(void)\n{\n\tif (imx_keep_uart_clocks && imx_enabled_uart_clocks) {\n\t\tint i;\n\n\t\tfor (i = 0; i < imx_enabled_uart_clocks; i++) {\n\t\t\tclk_disable_unprepare(imx_uart_clocks[i]);\n\t\t\tclk_put(imx_uart_clocks[i]);\n\t\t}\n\t}\n\n\tkfree(imx_uart_clocks);\n\n\treturn 0;\n}\nlate_initcall_sync(imx_clk_disable_uart);\n#endif\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}