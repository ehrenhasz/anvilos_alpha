{
  "module_name": "clk-gate-93.c",
  "hash_id": "a5209c171aa27f22ba1b6d2758359a41e7327d8a5b20ff39b664f606604490c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-gate-93.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\n#define DIRECT_OFFSET\t\t0x0\n\n \n#define LPM_SETTING_OFF\t\t0x0\n#define LPM_SETTING_ON\t\t0x4\n\n#define LPM_CUR_OFFSET\t\t0x1c\n\n#define AUTHEN_OFFSET\t\t0x30\n#define CPULPM_EN\t\tBIT(2)\n#define TZ_NS_SHIFT\t\t9\n#define TZ_NS_MASK\t\tBIT(9)\n\n#define WHITE_LIST_SHIFT\t16\n\nstruct imx93_clk_gate {\n\tstruct clk_hw hw;\n\tvoid __iomem\t*reg;\n\tu32\t\tbit_idx;\n\tu32\t\tval;\n\tu32\t\tmask;\n\tspinlock_t\t*lock;\n\tunsigned int\t*share_count;\n};\n\n#define to_imx93_clk_gate(_hw) container_of(_hw, struct imx93_clk_gate, hw)\n\nstatic void imx93_clk_gate_do_hardware(struct clk_hw *hw, bool enable)\n{\n\tstruct imx93_clk_gate *gate = to_imx93_clk_gate(hw);\n\tu32 val;\n\n\tval = readl(gate->reg + AUTHEN_OFFSET);\n\tif (val & CPULPM_EN) {\n\t\tval = enable ? LPM_SETTING_ON : LPM_SETTING_OFF;\n\t\twritel(val, gate->reg + LPM_CUR_OFFSET);\n\t} else {\n\t\tval = readl(gate->reg + DIRECT_OFFSET);\n\t\tval &= ~(gate->mask << gate->bit_idx);\n\t\tif (enable)\n\t\t\tval |= (gate->val & gate->mask) << gate->bit_idx;\n\t\twritel(val, gate->reg + DIRECT_OFFSET);\n\t}\n}\n\nstatic int imx93_clk_gate_enable(struct clk_hw *hw)\n{\n\tstruct imx93_clk_gate *gate = to_imx93_clk_gate(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tif (gate->share_count && (*gate->share_count)++ > 0)\n\t\tgoto out;\n\n\timx93_clk_gate_do_hardware(hw, true);\nout:\n\tspin_unlock_irqrestore(gate->lock, flags);\n\n\treturn 0;\n}\n\nstatic void imx93_clk_gate_disable(struct clk_hw *hw)\n{\n\tstruct imx93_clk_gate *gate = to_imx93_clk_gate(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tif (gate->share_count) {\n\t\tif (WARN_ON(*gate->share_count == 0))\n\t\t\tgoto out;\n\t\telse if (--(*gate->share_count) > 0)\n\t\t\tgoto out;\n\t}\n\n\timx93_clk_gate_do_hardware(hw, false);\nout:\n\tspin_unlock_irqrestore(gate->lock, flags);\n}\n\nstatic int imx93_clk_gate_reg_is_enabled(struct imx93_clk_gate *gate)\n{\n\tu32 val = readl(gate->reg + AUTHEN_OFFSET);\n\n\tif (val & CPULPM_EN) {\n\t\tval = readl(gate->reg + LPM_CUR_OFFSET);\n\t\tif (val == LPM_SETTING_ON)\n\t\t\treturn 1;\n\t} else {\n\t\tval = readl(gate->reg);\n\t\tif (((val >> gate->bit_idx) & gate->mask) == gate->val)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx93_clk_gate_is_enabled(struct clk_hw *hw)\n{\n\tstruct imx93_clk_gate *gate = to_imx93_clk_gate(hw);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tret = imx93_clk_gate_reg_is_enabled(gate);\n\n\tspin_unlock_irqrestore(gate->lock, flags);\n\n\treturn ret;\n}\n\nstatic void imx93_clk_gate_disable_unused(struct clk_hw *hw)\n{\n\tstruct imx93_clk_gate *gate = to_imx93_clk_gate(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tif (!gate->share_count || *gate->share_count == 0)\n\t\timx93_clk_gate_do_hardware(hw, false);\n\n\tspin_unlock_irqrestore(gate->lock, flags);\n}\n\nstatic const struct clk_ops imx93_clk_gate_ops = {\n\t.enable = imx93_clk_gate_enable,\n\t.disable = imx93_clk_gate_disable,\n\t.disable_unused = imx93_clk_gate_disable_unused,\n\t.is_enabled = imx93_clk_gate_is_enabled,\n};\n\nstatic const struct clk_ops imx93_clk_gate_ro_ops = {\n\t.is_enabled = imx93_clk_gate_is_enabled,\n};\n\nstruct clk_hw *imx93_clk_gate(struct device *dev, const char *name, const char *parent_name,\n\t\t\t      unsigned long flags, void __iomem *reg, u32 bit_idx, u32 val,\n\t\t\t      u32 mask, u32 domain_id, unsigned int *share_count)\n{\n\tstruct imx93_clk_gate *gate;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\tu32 authen;\n\n\tgate = kzalloc(sizeof(struct imx93_clk_gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgate->reg = reg;\n\tgate->lock = &imx_ccm_lock;\n\tgate->bit_idx = bit_idx;\n\tgate->val = val;\n\tgate->mask = mask;\n\tgate->share_count = share_count;\n\n\tinit.name = name;\n\tinit.ops = &imx93_clk_gate_ops;\n\tinit.flags = flags | CLK_SET_RATE_PARENT | CLK_OPS_PARENT_ENABLE;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\n\tgate->hw.init = &init;\n\thw = &gate->hw;\n\n\tauthen = readl(reg + AUTHEN_OFFSET);\n\tif (!(authen & TZ_NS_MASK) || !(authen & BIT(WHITE_LIST_SHIFT + domain_id)))\n\t\tinit.ops = &imx93_clk_gate_ro_ops;\n\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\tkfree(gate);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(imx93_clk_gate);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}