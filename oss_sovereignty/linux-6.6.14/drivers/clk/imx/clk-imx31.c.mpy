{
  "module_name": "clk-imx31.c",
  "hash_id": "7f3dc8c62e49f7667d47a9e67174c692a3457d5bce9865e9776e3bd6b859f06e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-imx31.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <soc/imx/revision.h>\n#include <asm/irq.h>\n\n#include \"clk.h\"\n\n#define MX31_CCM_BASE_ADDR\t0x53f80000\n#define MX31_GPT1_BASE_ADDR\t0x53f90000\n#define MX31_INT_GPT\t\t(NR_IRQS_LEGACY + 29)\n\n#define MXC_CCM_CCMR\t\t0x00\n#define MXC_CCM_PDR0\t\t0x04\n#define MXC_CCM_PDR1\t\t0x08\n#define MXC_CCM_MPCTL\t\t0x10\n#define MXC_CCM_UPCTL\t\t0x14\n#define MXC_CCM_SRPCTL\t\t0x18\n#define MXC_CCM_CGR0\t\t0x20\n#define MXC_CCM_CGR1\t\t0x24\n#define MXC_CCM_CGR2\t\t0x28\n#define MXC_CCM_PMCR0\t\t0x5c\n\nstatic const char *mcu_main_sel[] = { \"spll\", \"mpll\", };\nstatic const char *per_sel[] = { \"per_div\", \"ipg\", };\nstatic const char *csi_sel[] = { \"upll\", \"spll\", };\nstatic const char *fir_sel[] = { \"mcu_main\", \"upll\", \"spll\" };\n\nenum mx31_clks {\n\tdummy, ckih, ckil, mpll, spll, upll, mcu_main, hsp, ahb, nfc, ipg,\n\tper_div, per, csi, fir, csi_div, usb_div_pre, usb_div_post, fir_div_pre,\n\tfir_div_post, sdhc1_gate, sdhc2_gate, gpt_gate, epit1_gate, epit2_gate,\n\tiim_gate, ata_gate, sdma_gate, cspi3_gate, rng_gate, uart1_gate,\n\tuart2_gate, ssi1_gate, i2c1_gate, i2c2_gate, i2c3_gate, hantro_gate,\n\tmstick1_gate, mstick2_gate, csi_gate, rtc_gate, wdog_gate, pwm_gate,\n\tsim_gate, ect_gate, usb_gate, kpp_gate, ipu_gate, uart3_gate,\n\tuart4_gate, uart5_gate, owire_gate, ssi2_gate, cspi1_gate, cspi2_gate,\n\tgacc_gate, emi_gate, rtic_gate, firi_gate, clk_max\n};\n\nstatic struct clk *clk[clk_max];\nstatic struct clk_onecell_data clk_data;\n\nstatic void __init _mx31_clocks_init(void __iomem *base, unsigned long fref)\n{\n\tclk[dummy] = imx_clk_fixed(\"dummy\", 0);\n\tclk[ckih] = imx_clk_fixed(\"ckih\", fref);\n\tclk[ckil] = imx_clk_fixed(\"ckil\", 32768);\n\tclk[mpll] = imx_clk_pllv1(IMX_PLLV1_IMX31, \"mpll\", \"ckih\", base + MXC_CCM_MPCTL);\n\tclk[spll] = imx_clk_pllv1(IMX_PLLV1_IMX31, \"spll\", \"ckih\", base + MXC_CCM_SRPCTL);\n\tclk[upll] = imx_clk_pllv1(IMX_PLLV1_IMX31, \"upll\", \"ckih\", base + MXC_CCM_UPCTL);\n\tclk[mcu_main] = imx_clk_mux(\"mcu_main\", base + MXC_CCM_PMCR0, 31, 1, mcu_main_sel, ARRAY_SIZE(mcu_main_sel));\n\tclk[hsp] = imx_clk_divider(\"hsp\", \"mcu_main\", base + MXC_CCM_PDR0, 11, 3);\n\tclk[ahb] = imx_clk_divider(\"ahb\", \"mcu_main\", base + MXC_CCM_PDR0, 3, 3);\n\tclk[nfc] = imx_clk_divider(\"nfc\", \"ahb\", base + MXC_CCM_PDR0, 8, 3);\n\tclk[ipg] = imx_clk_divider(\"ipg\", \"ahb\", base + MXC_CCM_PDR0, 6, 2);\n\tclk[per_div] = imx_clk_divider(\"per_div\", \"upll\", base + MXC_CCM_PDR0, 16, 5);\n\tclk[per] = imx_clk_mux(\"per\", base + MXC_CCM_CCMR, 24, 1, per_sel, ARRAY_SIZE(per_sel));\n\tclk[csi] = imx_clk_mux(\"csi_sel\", base + MXC_CCM_CCMR, 25, 1, csi_sel, ARRAY_SIZE(csi_sel));\n\tclk[fir] = imx_clk_mux(\"fir_sel\", base + MXC_CCM_CCMR, 11, 2, fir_sel, ARRAY_SIZE(fir_sel));\n\tclk[csi_div] = imx_clk_divider(\"csi_div\", \"csi_sel\", base + MXC_CCM_PDR0, 23, 9);\n\tclk[usb_div_pre] = imx_clk_divider(\"usb_div_pre\", \"upll\", base + MXC_CCM_PDR1, 30, 2);\n\tclk[usb_div_post] = imx_clk_divider(\"usb_div_post\", \"usb_div_pre\", base + MXC_CCM_PDR1, 27, 3);\n\tclk[fir_div_pre] = imx_clk_divider(\"fir_div_pre\", \"fir_sel\", base + MXC_CCM_PDR1, 24, 3);\n\tclk[fir_div_post] = imx_clk_divider(\"fir_div_post\", \"fir_div_pre\", base + MXC_CCM_PDR1, 23, 6);\n\tclk[sdhc1_gate] = imx_clk_gate2(\"sdhc1_gate\", \"per\", base + MXC_CCM_CGR0, 0);\n\tclk[sdhc2_gate] = imx_clk_gate2(\"sdhc2_gate\", \"per\", base + MXC_CCM_CGR0, 2);\n\tclk[gpt_gate] = imx_clk_gate2(\"gpt_gate\", \"per\", base + MXC_CCM_CGR0, 4);\n\tclk[epit1_gate] = imx_clk_gate2(\"epit1_gate\", \"per\", base + MXC_CCM_CGR0, 6);\n\tclk[epit2_gate] = imx_clk_gate2(\"epit2_gate\", \"per\", base + MXC_CCM_CGR0, 8);\n\tclk[iim_gate] = imx_clk_gate2(\"iim_gate\", \"ipg\", base + MXC_CCM_CGR0, 10);\n\tclk[ata_gate] = imx_clk_gate2(\"ata_gate\", \"ipg\", base + MXC_CCM_CGR0, 12);\n\tclk[sdma_gate] = imx_clk_gate2(\"sdma_gate\", \"ahb\", base + MXC_CCM_CGR0, 14);\n\tclk[cspi3_gate] = imx_clk_gate2(\"cspi3_gate\", \"ipg\", base + MXC_CCM_CGR0, 16);\n\tclk[rng_gate] = imx_clk_gate2(\"rng_gate\", \"ipg\", base + MXC_CCM_CGR0, 18);\n\tclk[uart1_gate] = imx_clk_gate2(\"uart1_gate\", \"per\", base + MXC_CCM_CGR0, 20);\n\tclk[uart2_gate] = imx_clk_gate2(\"uart2_gate\", \"per\", base + MXC_CCM_CGR0, 22);\n\tclk[ssi1_gate] = imx_clk_gate2(\"ssi1_gate\", \"spll\", base + MXC_CCM_CGR0, 24);\n\tclk[i2c1_gate] = imx_clk_gate2(\"i2c1_gate\", \"per\", base + MXC_CCM_CGR0, 26);\n\tclk[i2c2_gate] = imx_clk_gate2(\"i2c2_gate\", \"per\", base + MXC_CCM_CGR0, 28);\n\tclk[i2c3_gate] = imx_clk_gate2(\"i2c3_gate\", \"per\", base + MXC_CCM_CGR0, 30);\n\tclk[hantro_gate] = imx_clk_gate2(\"hantro_gate\", \"per\", base + MXC_CCM_CGR1, 0);\n\tclk[mstick1_gate] = imx_clk_gate2(\"mstick1_gate\", \"per\", base + MXC_CCM_CGR1, 2);\n\tclk[mstick2_gate] = imx_clk_gate2(\"mstick2_gate\", \"per\", base + MXC_CCM_CGR1, 4);\n\tclk[csi_gate] = imx_clk_gate2(\"csi_gate\", \"csi_div\", base + MXC_CCM_CGR1, 6);\n\tclk[rtc_gate] = imx_clk_gate2(\"rtc_gate\", \"ipg\", base + MXC_CCM_CGR1, 8);\n\tclk[wdog_gate] = imx_clk_gate2(\"wdog_gate\", \"ipg\", base + MXC_CCM_CGR1, 10);\n\tclk[pwm_gate] = imx_clk_gate2(\"pwm_gate\", \"per\", base + MXC_CCM_CGR1, 12);\n\tclk[sim_gate] = imx_clk_gate2(\"sim_gate\", \"per\", base + MXC_CCM_CGR1, 14);\n\tclk[ect_gate] = imx_clk_gate2(\"ect_gate\", \"per\", base + MXC_CCM_CGR1, 16);\n\tclk[usb_gate] = imx_clk_gate2(\"usb_gate\", \"ahb\", base + MXC_CCM_CGR1, 18);\n\tclk[kpp_gate] = imx_clk_gate2(\"kpp_gate\", \"ipg\", base + MXC_CCM_CGR1, 20);\n\tclk[ipu_gate] = imx_clk_gate2(\"ipu_gate\", \"hsp\", base + MXC_CCM_CGR1, 22);\n\tclk[uart3_gate] = imx_clk_gate2(\"uart3_gate\", \"per\", base + MXC_CCM_CGR1, 24);\n\tclk[uart4_gate] = imx_clk_gate2(\"uart4_gate\", \"per\", base + MXC_CCM_CGR1, 26);\n\tclk[uart5_gate] = imx_clk_gate2(\"uart5_gate\", \"per\", base + MXC_CCM_CGR1, 28);\n\tclk[owire_gate] = imx_clk_gate2(\"owire_gate\", \"per\", base + MXC_CCM_CGR1, 30);\n\tclk[ssi2_gate] = imx_clk_gate2(\"ssi2_gate\", \"spll\", base + MXC_CCM_CGR2, 0);\n\tclk[cspi1_gate] = imx_clk_gate2(\"cspi1_gate\", \"ipg\", base + MXC_CCM_CGR2, 2);\n\tclk[cspi2_gate] = imx_clk_gate2(\"cspi2_gate\", \"ipg\", base + MXC_CCM_CGR2, 4);\n\tclk[gacc_gate] = imx_clk_gate2(\"gacc_gate\", \"per\", base + MXC_CCM_CGR2, 6);\n\tclk[emi_gate] = imx_clk_gate2(\"emi_gate\", \"ahb\", base + MXC_CCM_CGR2, 8);\n\tclk[rtic_gate] = imx_clk_gate2(\"rtic_gate\", \"ahb\", base + MXC_CCM_CGR2, 10);\n\tclk[firi_gate] = imx_clk_gate2(\"firi_gate\", \"upll\", base+MXC_CCM_CGR2, 12);\n\n\timx_check_clocks(clk, ARRAY_SIZE(clk));\n\n\tclk_set_parent(clk[csi], clk[upll]);\n\tclk_prepare_enable(clk[emi_gate]);\n\tclk_prepare_enable(clk[iim_gate]);\n\tmx31_revision();\n\tclk_disable_unprepare(clk[iim_gate]);\n}\n\nstatic void __init mx31_clocks_init_dt(struct device_node *np)\n{\n\tstruct device_node *osc_np;\n\tu32 fref = 26000000;  \n\tvoid __iomem *ccm;\n\n\tfor_each_compatible_node(osc_np, NULL, \"fixed-clock\") {\n\t\tif (!of_device_is_compatible(osc_np, \"fsl,imx-osc26m\"))\n\t\t\tcontinue;\n\n\t\tif (!of_property_read_u32(osc_np, \"clock-frequency\", &fref)) {\n\t\t\tof_node_put(osc_np);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tccm = of_iomap(np, 0);\n\tif (!ccm)\n\t\tpanic(\"%s: failed to map registers\\n\", __func__);\n\n\t_mx31_clocks_init(ccm, fref);\n\n\tclk_data.clks = clk;\n\tclk_data.clk_num = ARRAY_SIZE(clk);\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);\n}\n\nCLK_OF_DECLARE(imx31_ccm, \"fsl,imx31-ccm\", mx31_clocks_init_dt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}