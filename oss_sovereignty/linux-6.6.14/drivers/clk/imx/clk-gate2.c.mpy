{
  "module_name": "clk-gate2.c",
  "hash_id": "81c7a276bc4f5c16e472ab79a04f344c24956beb22c51ad04f26a8e16ae86c22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-gate2.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include \"clk.h\"\n\n \n\nstruct clk_gate2 {\n\tstruct clk_hw hw;\n\tvoid __iomem\t*reg;\n\tu8\t\tbit_idx;\n\tu8\t\tcgr_val;\n\tu8\t\tcgr_mask;\n\tu8\t\tflags;\n\tspinlock_t\t*lock;\n\tunsigned int\t*share_count;\n};\n\n#define to_clk_gate2(_hw) container_of(_hw, struct clk_gate2, hw)\n\nstatic void clk_gate2_do_shared_clks(struct clk_hw *hw, bool enable)\n{\n\tstruct clk_gate2 *gate = to_clk_gate2(hw);\n\tu32 reg;\n\n\treg = readl(gate->reg);\n\treg &= ~(gate->cgr_mask << gate->bit_idx);\n\tif (enable)\n\t\treg |= (gate->cgr_val & gate->cgr_mask) << gate->bit_idx;\n\twritel(reg, gate->reg);\n}\n\nstatic int clk_gate2_enable(struct clk_hw *hw)\n{\n\tstruct clk_gate2 *gate = to_clk_gate2(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tif (gate->share_count && (*gate->share_count)++ > 0)\n\t\tgoto out;\n\n\tclk_gate2_do_shared_clks(hw, true);\nout:\n\tspin_unlock_irqrestore(gate->lock, flags);\n\n\treturn 0;\n}\n\nstatic void clk_gate2_disable(struct clk_hw *hw)\n{\n\tstruct clk_gate2 *gate = to_clk_gate2(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tif (gate->share_count) {\n\t\tif (WARN_ON(*gate->share_count == 0))\n\t\t\tgoto out;\n\t\telse if (--(*gate->share_count) > 0)\n\t\t\tgoto out;\n\t}\n\n\tclk_gate2_do_shared_clks(hw, false);\nout:\n\tspin_unlock_irqrestore(gate->lock, flags);\n}\n\nstatic int clk_gate2_reg_is_enabled(void __iomem *reg, u8 bit_idx,\n\t\t\t\t\tu8 cgr_val, u8 cgr_mask)\n{\n\tu32 val = readl(reg);\n\n\tif (((val >> bit_idx) & cgr_mask) == cgr_val)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int clk_gate2_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_gate2 *gate = to_clk_gate2(hw);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tret = clk_gate2_reg_is_enabled(gate->reg, gate->bit_idx,\n\t\t\t\t\tgate->cgr_val, gate->cgr_mask);\n\n\tspin_unlock_irqrestore(gate->lock, flags);\n\n\treturn ret;\n}\n\nstatic void clk_gate2_disable_unused(struct clk_hw *hw)\n{\n\tstruct clk_gate2 *gate = to_clk_gate2(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(gate->lock, flags);\n\n\tif (!gate->share_count || *gate->share_count == 0)\n\t\tclk_gate2_do_shared_clks(hw, false);\n\n\tspin_unlock_irqrestore(gate->lock, flags);\n}\n\nstatic const struct clk_ops clk_gate2_ops = {\n\t.enable = clk_gate2_enable,\n\t.disable = clk_gate2_disable,\n\t.disable_unused = clk_gate2_disable_unused,\n\t.is_enabled = clk_gate2_is_enabled,\n};\n\nstruct clk_hw *clk_hw_register_gate2(struct device *dev, const char *name,\n\t\tconst char *parent_name, unsigned long flags,\n\t\tvoid __iomem *reg, u8 bit_idx, u8 cgr_val, u8 cgr_mask,\n\t\tu8 clk_gate2_flags, spinlock_t *lock,\n\t\tunsigned int *share_count)\n{\n\tstruct clk_gate2 *gate;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tgate = kzalloc(sizeof(struct clk_gate2), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tgate->reg = reg;\n\tgate->bit_idx = bit_idx;\n\tgate->cgr_val = cgr_val;\n\tgate->cgr_mask = cgr_mask;\n\tgate->flags = clk_gate2_flags;\n\tgate->lock = lock;\n\tgate->share_count = share_count;\n\n\tinit.name = name;\n\tinit.ops = &clk_gate2_ops;\n\tinit.flags = flags;\n\tinit.parent_names = parent_name ? &parent_name : NULL;\n\tinit.num_parents = parent_name ? 1 : 0;\n\n\tgate->hw.init = &init;\n\thw = &gate->hw;\n\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\tkfree(gate);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(clk_hw_register_gate2);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}