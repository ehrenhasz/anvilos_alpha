{
  "module_name": "clk-frac-pll.c",
  "hash_id": "da6ef96185dc82a52dcb376bb6b34629e7b97fe0d44d76a0d718dfa253340d9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-frac-pll.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/slab.h>\n#include <linux/bitfield.h>\n\n#include \"clk.h\"\n\n#define PLL_CFG0\t\t0x0\n#define PLL_CFG1\t\t0x4\n\n#define PLL_LOCK_STATUS\t\tBIT(31)\n#define PLL_PD_MASK\t\tBIT(19)\n#define PLL_BYPASS_MASK\t\tBIT(14)\n#define PLL_NEWDIV_VAL\t\tBIT(12)\n#define PLL_NEWDIV_ACK\t\tBIT(11)\n#define PLL_FRAC_DIV_MASK\tGENMASK(30, 7)\n#define PLL_INT_DIV_MASK\tGENMASK(6, 0)\n#define PLL_OUTPUT_DIV_MASK\tGENMASK(4, 0)\n#define PLL_FRAC_DENOM\t\t0x1000000\n\n#define PLL_FRAC_LOCK_TIMEOUT\t10000\n#define PLL_FRAC_ACK_TIMEOUT\t500000\n\nstruct clk_frac_pll {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*base;\n};\n\n#define to_clk_frac_pll(_hw) container_of(_hw, struct clk_frac_pll, hw)\n\nstatic int clk_wait_lock(struct clk_frac_pll *pll)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(pll->base, val, val & PLL_LOCK_STATUS, 0,\n\t\t\t\t\tPLL_FRAC_LOCK_TIMEOUT);\n}\n\nstatic int clk_wait_ack(struct clk_frac_pll *pll)\n{\n\tu32 val;\n\n\t \n\tif (readl_relaxed(pll->base) & (PLL_PD_MASK | PLL_BYPASS_MASK))\n\t\treturn 0;\n\n\t \n\treturn readl_poll_timeout(pll->base, val, val & PLL_NEWDIV_ACK, 0,\n\t\t\t\t\tPLL_FRAC_ACK_TIMEOUT);\n}\n\nstatic int clk_pll_prepare(struct clk_hw *hw)\n{\n\tstruct clk_frac_pll *pll = to_clk_frac_pll(hw);\n\tu32 val;\n\n\tval = readl_relaxed(pll->base + PLL_CFG0);\n\tval &= ~PLL_PD_MASK;\n\twritel_relaxed(val, pll->base + PLL_CFG0);\n\n\treturn clk_wait_lock(pll);\n}\n\nstatic void clk_pll_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_frac_pll *pll = to_clk_frac_pll(hw);\n\tu32 val;\n\n\tval = readl_relaxed(pll->base + PLL_CFG0);\n\tval |= PLL_PD_MASK;\n\twritel_relaxed(val, pll->base + PLL_CFG0);\n}\n\nstatic int clk_pll_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_frac_pll *pll = to_clk_frac_pll(hw);\n\tu32 val;\n\n\tval = readl_relaxed(pll->base + PLL_CFG0);\n\treturn (val & PLL_PD_MASK) ? 0 : 1;\n}\n\nstatic unsigned long clk_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_frac_pll *pll = to_clk_frac_pll(hw);\n\tu32 val, divff, divfi, divq;\n\tu64 temp64 = parent_rate;\n\tu64 rate;\n\n\tval = readl_relaxed(pll->base + PLL_CFG0);\n\tdivq = (FIELD_GET(PLL_OUTPUT_DIV_MASK, val) + 1) * 2;\n\tval = readl_relaxed(pll->base + PLL_CFG1);\n\tdivff = FIELD_GET(PLL_FRAC_DIV_MASK, val);\n\tdivfi = FIELD_GET(PLL_INT_DIV_MASK, val);\n\n\ttemp64 *= 8;\n\ttemp64 *= divff;\n\tdo_div(temp64, PLL_FRAC_DENOM);\n\tdo_div(temp64, divq);\n\n\trate = parent_rate * 8 * (divfi + 1);\n\tdo_div(rate, divq);\n\trate += temp64;\n\n\treturn rate;\n}\n\nstatic long clk_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *prate)\n{\n\tu64 parent_rate = *prate;\n\tu32 divff, divfi;\n\tu64 temp64;\n\n\tparent_rate *= 8;\n\trate *= 2;\n\ttemp64 = rate;\n\tdo_div(temp64, parent_rate);\n\tdivfi = temp64;\n\ttemp64 = rate - divfi * parent_rate;\n\ttemp64 *= PLL_FRAC_DENOM;\n\tdo_div(temp64, parent_rate);\n\tdivff = temp64;\n\n\ttemp64 = parent_rate;\n\ttemp64 *= divff;\n\tdo_div(temp64, PLL_FRAC_DENOM);\n\n\trate = parent_rate * divfi + temp64;\n\n\treturn rate / 2;\n}\n\n \nstatic int clk_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_frac_pll *pll = to_clk_frac_pll(hw);\n\tu32 val, divfi, divff;\n\tu64 temp64;\n\tint ret;\n\n\tparent_rate *= 8;\n\trate *= 2;\n\tdivfi = rate / parent_rate;\n\ttemp64 = parent_rate * divfi;\n\ttemp64 = rate - temp64;\n\ttemp64 *= PLL_FRAC_DENOM;\n\tdo_div(temp64, parent_rate);\n\tdivff = temp64;\n\n\tval = readl_relaxed(pll->base + PLL_CFG1);\n\tval &= ~(PLL_FRAC_DIV_MASK | PLL_INT_DIV_MASK);\n\tval |= (divff << 7) | (divfi - 1);\n\twritel_relaxed(val, pll->base + PLL_CFG1);\n\n\tval = readl_relaxed(pll->base + PLL_CFG0);\n\tval &= ~0x1f;\n\twritel_relaxed(val, pll->base + PLL_CFG0);\n\n\t \n\tval = readl_relaxed(pll->base + PLL_CFG0);\n\tval |= PLL_NEWDIV_VAL;\n\twritel_relaxed(val, pll->base + PLL_CFG0);\n\n\tret = clk_wait_ack(pll);\n\n\t \n\tval = readl_relaxed(pll->base + PLL_CFG0);\n\tval &= ~PLL_NEWDIV_VAL;\n\twritel_relaxed(val, pll->base + PLL_CFG0);\n\n\treturn ret;\n}\n\nstatic const struct clk_ops clk_frac_pll_ops = {\n\t.prepare\t= clk_pll_prepare,\n\t.unprepare\t= clk_pll_unprepare,\n\t.is_prepared\t= clk_pll_is_prepared,\n\t.recalc_rate\t= clk_pll_recalc_rate,\n\t.round_rate\t= clk_pll_round_rate,\n\t.set_rate\t= clk_pll_set_rate,\n};\n\nstruct clk_hw *imx_clk_hw_frac_pll(const char *name,\n\t\t\t\t   const char *parent_name,\n\t\t\t\t   void __iomem *base)\n{\n\tstruct clk_init_data init;\n\tstruct clk_frac_pll *pll;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &clk_frac_pll_ops;\n\tinit.flags = 0;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tpll->base = base;\n\tpll->hw.init = &init;\n\n\thw = &pll->hw;\n\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(pll);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(imx_clk_hw_frac_pll);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}