{
  "module_name": "clk-imxrt1050.c",
  "hash_id": "f76cb06fb8c39d2e0e75b085463bdabba8cb2bb8cd92d8b68a776bbba341358d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-imxrt1050.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <dt-bindings/clock/imxrt1050-clock.h>\n\n#include \"clk.h\"\n\nstatic const char * const pll_ref_sels[] = {\"osc\", \"dummy\", };\nstatic const char * const per_sels[] = {\"ipg_pdof\", \"osc\", };\nstatic const char * const pll1_bypass_sels[] = {\"pll1_arm\", \"pll1_arm_ref_sel\", };\nstatic const char * const pll2_bypass_sels[] = {\"pll2_sys\", \"pll2_sys_ref_sel\", };\nstatic const char * const pll3_bypass_sels[] = {\"pll3_usb_otg\", \"pll3_usb_otg_ref_sel\", };\nstatic const char * const pll5_bypass_sels[] = {\"pll5_video\", \"pll5_video_ref_sel\", };\nstatic const char *const pre_periph_sels[] = {\n\t\"pll2_sys\", \"pll2_pfd2_396m\", \"pll2_pfd0_352m\", \"arm_podf\", };\nstatic const char *const periph_sels[] = { \"pre_periph_sel\", \"todo\", };\nstatic const char *const usdhc_sels[] = { \"pll2_pfd2_396m\", \"pll2_pfd0_352m\", };\nstatic const char *const lpuart_sels[] = { \"pll3_80m\", \"osc\", };\nstatic const char *const lcdif_sels[] = {\n\t\"pll2_sys\", \"pll3_pfd3_454_74m\", \"pll5_video\", \"pll2_pfd0_352m\",\n\t\"pll2_pfd1_594m\", \"pll3_pfd1_664_62m\", };\nstatic const char *const semc_alt_sels[] = { \"pll2_pfd2_396m\", \"pll3_pfd1_664_62m\", };\nstatic const char *const semc_sels[] = { \"periph_sel\", \"semc_alt_sel\", };\n\nstatic struct clk_hw **hws;\nstatic struct clk_hw_onecell_data *clk_hw_data;\n\nstatic int imxrt1050_clocks_probe(struct platform_device *pdev)\n{\n\tvoid __iomem *ccm_base;\n\tvoid __iomem *pll_base;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *anp;\n\tint ret;\n\n\tclk_hw_data = devm_kzalloc(dev, struct_size(clk_hw_data, hws,\n\t\t\t\t\t  IMXRT1050_CLK_END), GFP_KERNEL);\n\tif (WARN_ON(!clk_hw_data))\n\t\treturn -ENOMEM;\n\n\tclk_hw_data->num = IMXRT1050_CLK_END;\n\thws = clk_hw_data->hws;\n\n\thws[IMXRT1050_CLK_OSC] = imx_get_clk_hw_by_name(np, \"osc\");\n\n\tanp = of_find_compatible_node(NULL, NULL, \"fsl,imxrt-anatop\");\n\tpll_base = devm_of_iomap(dev, anp, 0, NULL);\n\tof_node_put(anp);\n\tif (WARN_ON(IS_ERR(pll_base))) {\n\t\tret = PTR_ERR(pll_base);\n\t\tgoto unregister_hws;\n\t}\n\n\t \n\thws[IMXRT1050_CLK_DUMMY] = imx_clk_hw_fixed(\"dummy\", 0UL);\n\n\thws[IMXRT1050_CLK_PLL1_REF_SEL] = imx_clk_hw_mux(\"pll1_arm_ref_sel\",\n\t\tpll_base + 0x0, 14, 2, pll_ref_sels, ARRAY_SIZE(pll_ref_sels));\n\thws[IMXRT1050_CLK_PLL2_REF_SEL] = imx_clk_hw_mux(\"pll2_sys_ref_sel\",\n\t\tpll_base + 0x30, 14, 2, pll_ref_sels, ARRAY_SIZE(pll_ref_sels));\n\thws[IMXRT1050_CLK_PLL3_REF_SEL] = imx_clk_hw_mux(\"pll3_usb_otg_ref_sel\",\n\t\tpll_base + 0x10, 14, 2, pll_ref_sels, ARRAY_SIZE(pll_ref_sels));\n\thws[IMXRT1050_CLK_PLL5_REF_SEL] = imx_clk_hw_mux(\"pll5_video_ref_sel\",\n\t\tpll_base + 0xa0, 14, 2, pll_ref_sels, ARRAY_SIZE(pll_ref_sels));\n\n\thws[IMXRT1050_CLK_PLL1_ARM] = imx_clk_hw_pllv3(IMX_PLLV3_SYS, \"pll1_arm\",\n\t\t\"pll1_arm_ref_sel\", pll_base + 0x0, 0x7f);\n\thws[IMXRT1050_CLK_PLL2_SYS] = imx_clk_hw_pllv3(IMX_PLLV3_GENERIC, \"pll2_sys\",\n\t\t\"pll2_sys_ref_sel\", pll_base + 0x30, 0x1);\n\thws[IMXRT1050_CLK_PLL3_USB_OTG] = imx_clk_hw_pllv3(IMX_PLLV3_USB, \"pll3_usb_otg\",\n\t\t\"pll3_usb_otg_ref_sel\", pll_base + 0x10, 0x1);\n\thws[IMXRT1050_CLK_PLL5_VIDEO] = imx_clk_hw_pllv3(IMX_PLLV3_AV, \"pll5_video\",\n\t\t\"pll5_video_ref_sel\", pll_base + 0xa0, 0x7f);\n\n\t \n\thws[IMXRT1050_CLK_PLL1_BYPASS] = imx_clk_hw_mux_flags(\"pll1_bypass\", pll_base + 0x0, 16, 1,\n\t\tpll1_bypass_sels, ARRAY_SIZE(pll1_bypass_sels), CLK_SET_RATE_PARENT);\n\thws[IMXRT1050_CLK_PLL2_BYPASS] = imx_clk_hw_mux_flags(\"pll2_bypass\", pll_base + 0x30, 16, 1,\n\t\tpll2_bypass_sels, ARRAY_SIZE(pll2_bypass_sels), CLK_SET_RATE_PARENT);\n\thws[IMXRT1050_CLK_PLL3_BYPASS] = imx_clk_hw_mux_flags(\"pll3_bypass\", pll_base + 0x10, 16, 1,\n\t\tpll3_bypass_sels, ARRAY_SIZE(pll3_bypass_sels), CLK_SET_RATE_PARENT);\n\thws[IMXRT1050_CLK_PLL5_BYPASS] = imx_clk_hw_mux_flags(\"pll5_bypass\", pll_base + 0xa0, 16, 1,\n\t\tpll5_bypass_sels, ARRAY_SIZE(pll5_bypass_sels), CLK_SET_RATE_PARENT);\n\n\thws[IMXRT1050_CLK_VIDEO_POST_DIV_SEL] = imx_clk_hw_divider(\"video_post_div_sel\",\n\t\t\"pll5_video\", pll_base + 0xa0, 19, 2);\n\thws[IMXRT1050_CLK_VIDEO_DIV] = imx_clk_hw_divider(\"video_div\",\n\t\t\"video_post_div_sel\", pll_base + 0x170, 30, 2);\n\n\thws[IMXRT1050_CLK_PLL3_80M] = imx_clk_hw_fixed_factor(\"pll3_80m\",  \"pll3_usb_otg\", 1, 6);\n\n\thws[IMXRT1050_CLK_PLL2_PFD0_352M] = imx_clk_hw_pfd(\"pll2_pfd0_352m\", \"pll2_sys\", pll_base + 0x100, 0);\n\thws[IMXRT1050_CLK_PLL2_PFD1_594M] = imx_clk_hw_pfd(\"pll2_pfd1_594m\", \"pll2_sys\", pll_base + 0x100, 1);\n\thws[IMXRT1050_CLK_PLL2_PFD2_396M] = imx_clk_hw_pfd(\"pll2_pfd2_396m\", \"pll2_sys\", pll_base + 0x100, 2);\n\thws[IMXRT1050_CLK_PLL3_PFD1_664_62M] = imx_clk_hw_pfd(\"pll3_pfd1_664_62m\", \"pll3_usb_otg\", pll_base + 0xf0, 1);\n\thws[IMXRT1050_CLK_PLL3_PFD3_454_74M] = imx_clk_hw_pfd(\"pll3_pfd3_454_74m\", \"pll3_usb_otg\", pll_base + 0xf0, 3);\n\n\t \n\tccm_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (WARN_ON(IS_ERR(ccm_base))) {\n\t\tret = PTR_ERR(ccm_base);\n\t\tgoto unregister_hws;\n\t}\n\n\thws[IMXRT1050_CLK_ARM_PODF] = imx_clk_hw_divider(\"arm_podf\", \"pll1_arm\", ccm_base + 0x10, 0, 3);\n\thws[IMXRT1050_CLK_PRE_PERIPH_SEL] = imx_clk_hw_mux(\"pre_periph_sel\", ccm_base + 0x18, 18, 2,\n\t\tpre_periph_sels, ARRAY_SIZE(pre_periph_sels));\n\thws[IMXRT1050_CLK_PERIPH_SEL] = imx_clk_hw_mux(\"periph_sel\", ccm_base + 0x14, 25, 1,\n\t\tperiph_sels, ARRAY_SIZE(periph_sels));\n\thws[IMXRT1050_CLK_USDHC1_SEL] = imx_clk_hw_mux(\"usdhc1_sel\", ccm_base + 0x1c, 16, 1,\n\t\tusdhc_sels, ARRAY_SIZE(usdhc_sels));\n\thws[IMXRT1050_CLK_USDHC2_SEL] = imx_clk_hw_mux(\"usdhc2_sel\", ccm_base + 0x1c, 17, 1,\n\t\tusdhc_sels, ARRAY_SIZE(usdhc_sels));\n\thws[IMXRT1050_CLK_LPUART_SEL] = imx_clk_hw_mux(\"lpuart_sel\", ccm_base + 0x24, 6, 1,\n\t\tlpuart_sels, ARRAY_SIZE(lpuart_sels));\n\thws[IMXRT1050_CLK_LCDIF_SEL] = imx_clk_hw_mux(\"lcdif_sel\", ccm_base + 0x38, 15, 3,\n\t\tlcdif_sels, ARRAY_SIZE(lcdif_sels));\n\thws[IMXRT1050_CLK_PER_CLK_SEL] = imx_clk_hw_mux(\"per_sel\", ccm_base + 0x1C, 6, 1,\n\t\tper_sels, ARRAY_SIZE(per_sels));\n\thws[IMXRT1050_CLK_SEMC_ALT_SEL] = imx_clk_hw_mux(\"semc_alt_sel\", ccm_base + 0x14, 7, 1,\n\t\tsemc_alt_sels, ARRAY_SIZE(semc_alt_sels));\n\thws[IMXRT1050_CLK_SEMC_SEL] = imx_clk_hw_mux_flags(\"semc_sel\", ccm_base + 0x14, 6, 1,\n\t\tsemc_sels, ARRAY_SIZE(semc_sels), CLK_IS_CRITICAL);\n\n\thws[IMXRT1050_CLK_AHB_PODF] = imx_clk_hw_divider(\"ahb\", \"periph_sel\", ccm_base + 0x14, 10, 3);\n\thws[IMXRT1050_CLK_IPG_PDOF] = imx_clk_hw_divider(\"ipg\", \"ahb\", ccm_base + 0x14, 8, 2);\n\thws[IMXRT1050_CLK_PER_PDOF] = imx_clk_hw_divider(\"per\", \"per_sel\", ccm_base + 0x1C, 0, 5);\n\n\thws[IMXRT1050_CLK_USDHC1_PODF] = imx_clk_hw_divider(\"usdhc1_podf\", \"usdhc1_sel\", ccm_base + 0x24, 11, 3);\n\thws[IMXRT1050_CLK_USDHC2_PODF] = imx_clk_hw_divider(\"usdhc2_podf\", \"usdhc2_sel\", ccm_base + 0x24, 16, 3);\n\thws[IMXRT1050_CLK_LPUART_PODF] = imx_clk_hw_divider(\"lpuart_podf\", \"lpuart_sel\", ccm_base + 0x24, 0, 6);\n\thws[IMXRT1050_CLK_LCDIF_PRED] = imx_clk_hw_divider(\"lcdif_pred\", \"lcdif_sel\", ccm_base + 0x38, 12, 3);\n\thws[IMXRT1050_CLK_LCDIF_PODF] = imx_clk_hw_divider(\"lcdif_podf\", \"lcdif_pred\", ccm_base + 0x18, 23, 3);\n\n\thws[IMXRT1050_CLK_USDHC1] = imx_clk_hw_gate2(\"usdhc1\", \"usdhc1_podf\", ccm_base + 0x80, 2);\n\thws[IMXRT1050_CLK_USDHC2] = imx_clk_hw_gate2(\"usdhc2\", \"usdhc2_podf\", ccm_base + 0x80, 4);\n\thws[IMXRT1050_CLK_LPUART1] = imx_clk_hw_gate2(\"lpuart1\", \"lpuart_podf\", ccm_base + 0x7c, 24);\n\thws[IMXRT1050_CLK_LCDIF_APB] = imx_clk_hw_gate2(\"lcdif\", \"lcdif_podf\", ccm_base + 0x70, 28);\n\thws[IMXRT1050_CLK_LCDIF_PIX] = imx_clk_hw_gate2(\"lcdif_pix\", \"lcdif\", ccm_base + 0x74, 10);\n\thws[IMXRT1050_CLK_DMA] = imx_clk_hw_gate(\"dma\", \"ipg\", ccm_base + 0x7C, 6);\n\thws[IMXRT1050_CLK_DMA_MUX] = imx_clk_hw_gate(\"dmamux0\", \"ipg\", ccm_base + 0x7C, 7);\n\timx_check_clk_hws(hws, IMXRT1050_CLK_END);\n\n\tret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_hw_data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register clks for i.MXRT1050.\\n\");\n\t\tgoto unregister_hws;\n\t}\n\treturn 0;\n\nunregister_hws:\n\timx_unregister_hw_clocks(hws, IMXRT1050_CLK_END);\n\treturn ret;\n}\nstatic const struct of_device_id imxrt1050_clk_of_match[] = {\n\t{ .compatible = \"fsl,imxrt1050-ccm\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imxrt1050_clk_of_match);\n\nstatic struct platform_driver imxrt1050_clk_driver = {\n\t.probe = imxrt1050_clocks_probe,\n\t.driver = {\n\t\t.name = \"imxrt1050-ccm\",\n\t\t.of_match_table = imxrt1050_clk_of_match,\n\t},\n};\nmodule_platform_driver(imxrt1050_clk_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Jesse Taube <Mr.Bossman075@gmail.com>\");\nMODULE_AUTHOR(\"Giulio Benetti <giulio.benetti@benettiengineering.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}