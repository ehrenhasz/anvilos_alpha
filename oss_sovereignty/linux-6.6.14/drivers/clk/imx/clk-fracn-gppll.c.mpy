{
  "module_name": "clk-fracn-gppll.c",
  "hash_id": "f7e64b6097cfa4a8cf272b595397b9c2ac640936ff6d1a2fb6ed4e359d8f63dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-fracn-gppll.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/slab.h>\n#include <asm/div64.h>\n\n#include \"clk.h\"\n\n#define PLL_CTRL\t\t0x0\n#define HW_CTRL_SEL\t\tBIT(16)\n#define CLKMUX_BYPASS\t\tBIT(2)\n#define CLKMUX_EN\t\tBIT(1)\n#define POWERUP_MASK\t\tBIT(0)\n\n#define PLL_ANA_PRG\t\t0x10\n#define PLL_SPREAD_SPECTRUM\t0x30\n\n#define PLL_NUMERATOR\t\t0x40\n#define PLL_MFN_MASK\t\tGENMASK(31, 2)\n\n#define PLL_DENOMINATOR\t\t0x50\n#define PLL_MFD_MASK\t\tGENMASK(29, 0)\n\n#define PLL_DIV\t\t\t0x60\n#define PLL_MFI_MASK\t\tGENMASK(24, 16)\n#define PLL_RDIV_MASK\t\tGENMASK(15, 13)\n#define PLL_ODIV_MASK\t\tGENMASK(7, 0)\n\n#define PLL_DFS_CTRL(x)\t\t(0x70 + (x) * 0x10)\n\n#define PLL_STATUS\t\t0xF0\n#define LOCK_STATUS\t\tBIT(0)\n\n#define DFS_STATUS\t\t0xF4\n\n#define LOCK_TIMEOUT_US\t\t200\n\n#define PLL_FRACN_GP(_rate, _mfi, _mfn, _mfd, _rdiv, _odiv)\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.rate\t=\t(_rate),\t\t\t\\\n\t\t.mfi\t=\t(_mfi),\t\t\t\t\\\n\t\t.mfn\t=\t(_mfn),\t\t\t\t\\\n\t\t.mfd\t=\t(_mfd),\t\t\t\t\\\n\t\t.rdiv\t=\t(_rdiv),\t\t\t\\\n\t\t.odiv\t=\t(_odiv),\t\t\t\\\n\t}\n\n#define PLL_FRACN_GP_INTEGER(_rate, _mfi, _rdiv, _odiv)\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.rate\t=\t(_rate),\t\t\t\\\n\t\t.mfi\t=\t(_mfi),\t\t\t\t\\\n\t\t.mfn\t=\t0,\t\t\t\t\\\n\t\t.mfd\t=\t0,\t\t\t\t\\\n\t\t.rdiv\t=\t(_rdiv),\t\t\t\\\n\t\t.odiv\t=\t(_odiv),\t\t\t\\\n\t}\n\nstruct clk_fracn_gppll {\n\tstruct clk_hw\t\t\thw;\n\tvoid __iomem\t\t\t*base;\n\tconst struct imx_fracn_gppll_rate_table *rate_table;\n\tint rate_count;\n\tu32 flags;\n};\n\n \nstatic const struct imx_fracn_gppll_rate_table fracn_tbl[] = {\n\tPLL_FRACN_GP(650000000U, 162, 50, 100, 0, 6),\n\tPLL_FRACN_GP(594000000U, 198, 0, 1, 0, 8),\n\tPLL_FRACN_GP(560000000U, 140, 0, 1, 0, 6),\n\tPLL_FRACN_GP(519750000U, 173, 25, 100, 1, 8),\n\tPLL_FRACN_GP(498000000U, 166, 0, 1, 0, 8),\n\tPLL_FRACN_GP(484000000U, 121, 0, 1, 0, 6),\n\tPLL_FRACN_GP(445333333U, 167, 0, 1, 0, 9),\n\tPLL_FRACN_GP(400000000U, 200, 0, 1, 0, 12),\n\tPLL_FRACN_GP(393216000U, 163, 84, 100, 0, 10),\n\tPLL_FRACN_GP(300000000U, 150, 0, 1, 0, 12)\n};\n\nstruct imx_fracn_gppll_clk imx_fracn_gppll = {\n\t.rate_table = fracn_tbl,\n\t.rate_count = ARRAY_SIZE(fracn_tbl),\n};\nEXPORT_SYMBOL_GPL(imx_fracn_gppll);\n\n \nstatic const struct imx_fracn_gppll_rate_table int_tbl[] = {\n\tPLL_FRACN_GP_INTEGER(1700000000U, 141, 1, 2),\n\tPLL_FRACN_GP_INTEGER(1400000000U, 175, 1, 3),\n\tPLL_FRACN_GP_INTEGER(900000000U, 150, 1, 4),\n};\n\nstruct imx_fracn_gppll_clk imx_fracn_gppll_integer = {\n\t.rate_table = int_tbl,\n\t.rate_count = ARRAY_SIZE(int_tbl),\n};\nEXPORT_SYMBOL_GPL(imx_fracn_gppll_integer);\n\nstatic inline struct clk_fracn_gppll *to_clk_fracn_gppll(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct clk_fracn_gppll, hw);\n}\n\nstatic const struct imx_fracn_gppll_rate_table *\nimx_get_pll_settings(struct clk_fracn_gppll *pll, unsigned long rate)\n{\n\tconst struct imx_fracn_gppll_rate_table *rate_table = pll->rate_table;\n\tint i;\n\n\tfor (i = 0; i < pll->rate_count; i++)\n\t\tif (rate == rate_table[i].rate)\n\t\t\treturn &rate_table[i];\n\n\treturn NULL;\n}\n\nstatic long clk_fracn_gppll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long *prate)\n{\n\tstruct clk_fracn_gppll *pll = to_clk_fracn_gppll(hw);\n\tconst struct imx_fracn_gppll_rate_table *rate_table = pll->rate_table;\n\tint i;\n\n\t \n\tfor (i = 0; i < pll->rate_count; i++)\n\t\tif (rate >= rate_table[i].rate)\n\t\t\treturn rate_table[i].rate;\n\n\t \n\treturn rate_table[pll->rate_count - 1].rate;\n}\n\nstatic unsigned long clk_fracn_gppll_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct clk_fracn_gppll *pll = to_clk_fracn_gppll(hw);\n\tconst struct imx_fracn_gppll_rate_table *rate_table = pll->rate_table;\n\tu32 pll_numerator, pll_denominator, pll_div;\n\tu32 mfi, mfn, mfd, rdiv, odiv;\n\tu64 fvco = parent_rate;\n\tlong rate = 0;\n\tint i;\n\n\tpll_numerator = readl_relaxed(pll->base + PLL_NUMERATOR);\n\tmfn = FIELD_GET(PLL_MFN_MASK, pll_numerator);\n\n\tpll_denominator = readl_relaxed(pll->base + PLL_DENOMINATOR);\n\tmfd = FIELD_GET(PLL_MFD_MASK, pll_denominator);\n\n\tpll_div = readl_relaxed(pll->base + PLL_DIV);\n\tmfi = FIELD_GET(PLL_MFI_MASK, pll_div);\n\n\trdiv = FIELD_GET(PLL_RDIV_MASK, pll_div);\n\todiv = FIELD_GET(PLL_ODIV_MASK, pll_div);\n\n\t \n\tfor (i = 0; i < pll->rate_count; i++) {\n\t\tif (rate_table[i].mfn == mfn && rate_table[i].mfi == mfi &&\n\t\t    rate_table[i].mfd == mfd && rate_table[i].rdiv == rdiv &&\n\t\t    rate_table[i].odiv == odiv)\n\t\t\trate = rate_table[i].rate;\n\t}\n\n\tif (rate)\n\t\treturn (unsigned long)rate;\n\n\tif (!rdiv)\n\t\trdiv = rdiv + 1;\n\n\tswitch (odiv) {\n\tcase 0:\n\t\todiv = 2;\n\t\tbreak;\n\tcase 1:\n\t\todiv = 3;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (pll->flags & CLK_FRACN_GPPLL_INTEGER) {\n\t\t \n\t\tfvco = fvco * mfi;\n\t\tdo_div(fvco, rdiv * odiv);\n\t} else {\n\t\t \n\t\tfvco = fvco * mfi * mfd + fvco * mfn;\n\t\tdo_div(fvco, mfd * rdiv * odiv);\n\t}\n\n\treturn (unsigned long)fvco;\n}\n\nstatic int clk_fracn_gppll_wait_lock(struct clk_fracn_gppll *pll)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(pll->base + PLL_STATUS, val,\n\t\t\t\t  val & LOCK_STATUS, 0, LOCK_TIMEOUT_US);\n}\n\nstatic int clk_fracn_gppll_set_rate(struct clk_hw *hw, unsigned long drate,\n\t\t\t\t    unsigned long prate)\n{\n\tstruct clk_fracn_gppll *pll = to_clk_fracn_gppll(hw);\n\tconst struct imx_fracn_gppll_rate_table *rate;\n\tu32 tmp, pll_div, ana_mfn;\n\tint ret;\n\n\trate = imx_get_pll_settings(pll, drate);\n\n\t \n\ttmp = readl_relaxed(pll->base + PLL_CTRL);\n\ttmp &= ~HW_CTRL_SEL;\n\twritel_relaxed(tmp, pll->base + PLL_CTRL);\n\n\t \n\ttmp = readl_relaxed(pll->base + PLL_CTRL);\n\ttmp &= ~CLKMUX_EN;\n\twritel_relaxed(tmp, pll->base + PLL_CTRL);\n\n\t \n\ttmp &= ~POWERUP_MASK;\n\twritel_relaxed(tmp, pll->base + PLL_CTRL);\n\n\t \n\ttmp &= ~CLKMUX_BYPASS;\n\twritel_relaxed(tmp, pll->base + PLL_CTRL);\n\n\tpll_div = FIELD_PREP(PLL_RDIV_MASK, rate->rdiv) | rate->odiv |\n\t\tFIELD_PREP(PLL_MFI_MASK, rate->mfi);\n\twritel_relaxed(pll_div, pll->base + PLL_DIV);\n\tif (pll->flags & CLK_FRACN_GPPLL_FRACN) {\n\t\twritel_relaxed(rate->mfd, pll->base + PLL_DENOMINATOR);\n\t\twritel_relaxed(FIELD_PREP(PLL_MFN_MASK, rate->mfn), pll->base + PLL_NUMERATOR);\n\t}\n\n\t \n\tudelay(5);\n\n\t \n\ttmp |= POWERUP_MASK;\n\twritel_relaxed(tmp, pll->base + PLL_CTRL);\n\n\t \n\tret = clk_fracn_gppll_wait_lock(pll);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttmp |= CLKMUX_EN;\n\twritel_relaxed(tmp, pll->base + PLL_CTRL);\n\n\tana_mfn = readl_relaxed(pll->base + PLL_STATUS);\n\tana_mfn = FIELD_GET(PLL_MFN_MASK, ana_mfn);\n\n\tWARN(ana_mfn != rate->mfn, \"ana_mfn != rate->mfn\\n\");\n\n\treturn 0;\n}\n\nstatic int clk_fracn_gppll_prepare(struct clk_hw *hw)\n{\n\tstruct clk_fracn_gppll *pll = to_clk_fracn_gppll(hw);\n\tu32 val;\n\tint ret;\n\n\tval = readl_relaxed(pll->base + PLL_CTRL);\n\tif (val & POWERUP_MASK)\n\t\treturn 0;\n\n\tval |= CLKMUX_BYPASS;\n\twritel_relaxed(val, pll->base + PLL_CTRL);\n\n\tval |= POWERUP_MASK;\n\twritel_relaxed(val, pll->base + PLL_CTRL);\n\n\tval |= CLKMUX_EN;\n\twritel_relaxed(val, pll->base + PLL_CTRL);\n\n\tret = clk_fracn_gppll_wait_lock(pll);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~CLKMUX_BYPASS;\n\twritel_relaxed(val, pll->base + PLL_CTRL);\n\n\treturn 0;\n}\n\nstatic int clk_fracn_gppll_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_fracn_gppll *pll = to_clk_fracn_gppll(hw);\n\tu32 val;\n\n\tval = readl_relaxed(pll->base + PLL_CTRL);\n\n\treturn (val & POWERUP_MASK) ? 1 : 0;\n}\n\nstatic void clk_fracn_gppll_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_fracn_gppll *pll = to_clk_fracn_gppll(hw);\n\tu32 val;\n\n\tval = readl_relaxed(pll->base + PLL_CTRL);\n\tval &= ~POWERUP_MASK;\n\twritel_relaxed(val, pll->base + PLL_CTRL);\n}\n\nstatic const struct clk_ops clk_fracn_gppll_ops = {\n\t.prepare\t= clk_fracn_gppll_prepare,\n\t.unprepare\t= clk_fracn_gppll_unprepare,\n\t.is_prepared\t= clk_fracn_gppll_is_prepared,\n\t.recalc_rate\t= clk_fracn_gppll_recalc_rate,\n\t.round_rate\t= clk_fracn_gppll_round_rate,\n\t.set_rate\t= clk_fracn_gppll_set_rate,\n};\n\nstatic struct clk_hw *_imx_clk_fracn_gppll(const char *name, const char *parent_name,\n\t\t\t\t\t   void __iomem *base,\n\t\t\t\t\t   const struct imx_fracn_gppll_clk *pll_clk,\n\t\t\t\t\t   u32 pll_flags)\n{\n\tstruct clk_fracn_gppll *pll;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.flags = pll_clk->flags;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.ops = &clk_fracn_gppll_ops;\n\n\tpll->base = base;\n\tpll->hw.init = &init;\n\tpll->rate_table = pll_clk->rate_table;\n\tpll->rate_count = pll_clk->rate_count;\n\tpll->flags = pll_flags;\n\n\thw = &pll->hw;\n\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to register pll %s %d\\n\", __func__, name, ret);\n\t\tkfree(pll);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstruct clk_hw *imx_clk_fracn_gppll(const char *name, const char *parent_name, void __iomem *base,\n\t\t\t\t   const struct imx_fracn_gppll_clk *pll_clk)\n{\n\treturn _imx_clk_fracn_gppll(name, parent_name, base, pll_clk, CLK_FRACN_GPPLL_FRACN);\n}\nEXPORT_SYMBOL_GPL(imx_clk_fracn_gppll);\n\nstruct clk_hw *imx_clk_fracn_gppll_integer(const char *name, const char *parent_name,\n\t\t\t\t\t   void __iomem *base,\n\t\t\t\t\t   const struct imx_fracn_gppll_clk *pll_clk)\n{\n\treturn _imx_clk_fracn_gppll(name, parent_name, base, pll_clk, CLK_FRACN_GPPLL_INTEGER);\n}\nEXPORT_SYMBOL_GPL(imx_clk_fracn_gppll_integer);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}