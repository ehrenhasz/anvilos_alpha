{
  "module_name": "clk-composite-93.c",
  "hash_id": "3d73bda47a9c2beed65bf56e20f91950f534c75a7abd97f08d93412f2d848a4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-composite-93.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\n#define TIMEOUT_US\t500U\n\n#define CCM_DIV_SHIFT\t0\n#define CCM_DIV_WIDTH\t8\n#define CCM_MUX_SHIFT\t8\n#define CCM_MUX_MASK\t3\n#define CCM_OFF_SHIFT\t24\n#define CCM_BUSY_SHIFT\t28\n\n#define STAT_OFFSET\t0x4\n#define AUTHEN_OFFSET\t0x30\n#define TZ_NS_SHIFT\t9\n#define TZ_NS_MASK\tBIT(9)\n\n#define WHITE_LIST_SHIFT\t16\n\nstatic int imx93_clk_composite_wait_ready(struct clk_hw *hw, void __iomem *reg)\n{\n\tint ret;\n\tu32 val;\n\n\tret = readl_poll_timeout_atomic(reg + STAT_OFFSET, val, !(val & BIT(CCM_BUSY_SHIFT)),\n\t\t\t\t\t0, TIMEOUT_US);\n\tif (ret)\n\t\tpr_err(\"Slice[%s] busy timeout\\n\", clk_hw_get_name(hw));\n\n\treturn ret;\n}\n\nstatic void imx93_clk_composite_gate_endisable(struct clk_hw *hw, int enable)\n{\n\tstruct clk_gate *gate = to_clk_gate(hw);\n\tunsigned long flags;\n\tu32 reg;\n\n\tif (gate->lock)\n\t\tspin_lock_irqsave(gate->lock, flags);\n\n\treg = readl(gate->reg);\n\n\tif (enable)\n\t\treg &= ~BIT(gate->bit_idx);\n\telse\n\t\treg |= BIT(gate->bit_idx);\n\n\twritel(reg, gate->reg);\n\n\timx93_clk_composite_wait_ready(hw, gate->reg);\n\n\tif (gate->lock)\n\t\tspin_unlock_irqrestore(gate->lock, flags);\n}\n\nstatic int imx93_clk_composite_gate_enable(struct clk_hw *hw)\n{\n\timx93_clk_composite_gate_endisable(hw, 1);\n\n\treturn 0;\n}\n\nstatic void imx93_clk_composite_gate_disable(struct clk_hw *hw)\n{\n\timx93_clk_composite_gate_endisable(hw, 0);\n}\n\nstatic const struct clk_ops imx93_clk_composite_gate_ops = {\n\t.enable = imx93_clk_composite_gate_enable,\n\t.disable = imx93_clk_composite_gate_disable,\n\t.is_enabled = clk_gate_is_enabled,\n};\n\nstatic unsigned long\nimx93_clk_composite_divider_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\treturn clk_divider_ops.recalc_rate(hw, parent_rate);\n}\n\nstatic long\nimx93_clk_composite_divider_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *prate)\n{\n\treturn clk_divider_ops.round_rate(hw, rate, prate);\n}\n\nstatic int\nimx93_clk_composite_divider_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)\n{\n\treturn clk_divider_ops.determine_rate(hw, req);\n}\n\nstatic int imx93_clk_composite_divider_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\tint value;\n\tunsigned long flags = 0;\n\tu32 val;\n\tint ret;\n\n\tvalue = divider_get_val(rate, parent_rate, divider->table, divider->width, divider->flags);\n\tif (value < 0)\n\t\treturn value;\n\n\tif (divider->lock)\n\t\tspin_lock_irqsave(divider->lock, flags);\n\n\tval = readl(divider->reg);\n\tval &= ~(clk_div_mask(divider->width) << divider->shift);\n\tval |= (u32)value << divider->shift;\n\twritel(val, divider->reg);\n\n\tret = imx93_clk_composite_wait_ready(hw, divider->reg);\n\n\tif (divider->lock)\n\t\tspin_unlock_irqrestore(divider->lock, flags);\n\n\treturn ret;\n}\n\nstatic const struct clk_ops imx93_clk_composite_divider_ops = {\n\t.recalc_rate = imx93_clk_composite_divider_recalc_rate,\n\t.round_rate = imx93_clk_composite_divider_round_rate,\n\t.determine_rate = imx93_clk_composite_divider_determine_rate,\n\t.set_rate = imx93_clk_composite_divider_set_rate,\n};\n\nstatic u8 imx93_clk_composite_mux_get_parent(struct clk_hw *hw)\n{\n\treturn clk_mux_ops.get_parent(hw);\n}\n\nstatic int imx93_clk_composite_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_mux *mux = to_clk_mux(hw);\n\tu32 val = clk_mux_index_to_val(mux->table, mux->flags, index);\n\tunsigned long flags = 0;\n\tu32 reg;\n\tint ret;\n\n\tif (mux->lock)\n\t\tspin_lock_irqsave(mux->lock, flags);\n\n\treg = readl(mux->reg);\n\treg &= ~(mux->mask << mux->shift);\n\tval = val << mux->shift;\n\treg |= val;\n\twritel(reg, mux->reg);\n\n\tret = imx93_clk_composite_wait_ready(hw, mux->reg);\n\n\tif (mux->lock)\n\t\tspin_unlock_irqrestore(mux->lock, flags);\n\n\treturn ret;\n}\n\nstatic int\nimx93_clk_composite_mux_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)\n{\n\treturn clk_mux_ops.determine_rate(hw, req);\n}\n\nstatic const struct clk_ops imx93_clk_composite_mux_ops = {\n\t.get_parent = imx93_clk_composite_mux_get_parent,\n\t.set_parent = imx93_clk_composite_mux_set_parent,\n\t.determine_rate = imx93_clk_composite_mux_determine_rate,\n};\n\nstruct clk_hw *imx93_clk_composite_flags(const char *name, const char * const *parent_names,\n\t\t\t\t\t int num_parents, void __iomem *reg, u32 domain_id,\n\t\t\t\t\t unsigned long flags)\n{\n\tstruct clk_hw *hw = ERR_PTR(-ENOMEM), *mux_hw;\n\tstruct clk_hw *div_hw, *gate_hw;\n\tstruct clk_divider *div = NULL;\n\tstruct clk_gate *gate = NULL;\n\tstruct clk_mux *mux = NULL;\n\tbool clk_ro = false;\n\tu32 authen;\n\n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\tgoto fail;\n\n\tmux_hw = &mux->hw;\n\tmux->reg = reg;\n\tmux->shift = CCM_MUX_SHIFT;\n\tmux->mask = CCM_MUX_MASK;\n\tmux->lock = &imx_ccm_lock;\n\n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\tgoto fail;\n\n\tdiv_hw = &div->hw;\n\tdiv->reg = reg;\n\tdiv->shift = CCM_DIV_SHIFT;\n\tdiv->width = CCM_DIV_WIDTH;\n\tdiv->lock = &imx_ccm_lock;\n\tdiv->flags = CLK_DIVIDER_ROUND_CLOSEST;\n\n\tauthen = readl(reg + AUTHEN_OFFSET);\n\tif (!(authen & TZ_NS_MASK) || !(authen & BIT(WHITE_LIST_SHIFT + domain_id)))\n\t\tclk_ro = true;\n\n\tif (clk_ro) {\n\t\thw = clk_hw_register_composite(NULL, name, parent_names, num_parents,\n\t\t\t\t\t       mux_hw, &clk_mux_ro_ops, div_hw,\n\t\t\t\t\t       &clk_divider_ro_ops, NULL, NULL, flags);\n\t} else if (!mcore_booted) {\n\t\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\t\tif (!gate)\n\t\t\tgoto fail;\n\n\t\tgate_hw = &gate->hw;\n\t\tgate->reg = reg;\n\t\tgate->bit_idx = CCM_OFF_SHIFT;\n\t\tgate->lock = &imx_ccm_lock;\n\t\tgate->flags = CLK_GATE_SET_TO_DISABLE;\n\n\t\thw = clk_hw_register_composite(NULL, name, parent_names, num_parents,\n\t\t\t\t\t       mux_hw, &imx93_clk_composite_mux_ops, div_hw,\n\t\t\t\t\t       &imx93_clk_composite_divider_ops, gate_hw,\n\t\t\t\t\t       &imx93_clk_composite_gate_ops,\n\t\t\t\t\t       flags | CLK_SET_RATE_NO_REPARENT);\n\t} else {\n\t\thw = clk_hw_register_composite(NULL, name, parent_names, num_parents,\n\t\t\t\t\t       mux_hw, &imx93_clk_composite_mux_ops, div_hw,\n\t\t\t\t\t       &imx93_clk_composite_divider_ops, NULL,\n\t\t\t\t\t       &imx93_clk_composite_gate_ops,\n\t\t\t\t\t       flags | CLK_SET_RATE_NO_REPARENT);\n\t}\n\n\tif (IS_ERR(hw))\n\t\tgoto fail;\n\n\treturn hw;\n\nfail:\n\tkfree(gate);\n\tkfree(div);\n\tkfree(mux);\n\treturn ERR_CAST(hw);\n}\nEXPORT_SYMBOL_GPL(imx93_clk_composite_flags);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}