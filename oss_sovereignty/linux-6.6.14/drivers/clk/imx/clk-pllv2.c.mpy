{
  "module_name": "clk-pllv2.c",
  "hash_id": "24d59ef454fd7f7f1bc8e68626337437c603646cfddf70bfa2fa302fd9a8a986",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-pllv2.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\n#include <asm/div64.h>\n\n#include \"clk.h\"\n\n#define to_clk_pllv2(clk) (container_of(clk, struct clk_pllv2, clk))\n\n \n#define MXC_PLL_DP_CTL\t\t\t0x00\n#define MXC_PLL_DP_CONFIG\t\t0x04\n#define MXC_PLL_DP_OP\t\t\t0x08\n#define MXC_PLL_DP_MFD\t\t\t0x0C\n#define MXC_PLL_DP_MFN\t\t\t0x10\n#define MXC_PLL_DP_MFNMINUS\t\t0x14\n#define MXC_PLL_DP_MFNPLUS\t\t0x18\n#define MXC_PLL_DP_HFS_OP\t\t0x1C\n#define MXC_PLL_DP_HFS_MFD\t\t0x20\n#define MXC_PLL_DP_HFS_MFN\t\t0x24\n#define MXC_PLL_DP_MFN_TOGC\t\t0x28\n#define MXC_PLL_DP_DESTAT\t\t0x2c\n\n \n#define MXC_PLL_DP_CTL_MUL_CTRL\t\t0x2000\n#define MXC_PLL_DP_CTL_DPDCK0_2_EN\t0x1000\n#define MXC_PLL_DP_CTL_DPDCK0_2_OFFSET\t12\n#define MXC_PLL_DP_CTL_ADE\t\t0x800\n#define MXC_PLL_DP_CTL_REF_CLK_DIV\t0x400\n#define MXC_PLL_DP_CTL_REF_CLK_SEL_MASK\t(3 << 8)\n#define MXC_PLL_DP_CTL_REF_CLK_SEL_OFFSET\t8\n#define MXC_PLL_DP_CTL_HFSM\t\t0x80\n#define MXC_PLL_DP_CTL_PRE\t\t0x40\n#define MXC_PLL_DP_CTL_UPEN\t\t0x20\n#define MXC_PLL_DP_CTL_RST\t\t0x10\n#define MXC_PLL_DP_CTL_RCP\t\t0x8\n#define MXC_PLL_DP_CTL_PLM\t\t0x4\n#define MXC_PLL_DP_CTL_BRM0\t\t0x2\n#define MXC_PLL_DP_CTL_LRF\t\t0x1\n\n#define MXC_PLL_DP_CONFIG_BIST\t\t0x8\n#define MXC_PLL_DP_CONFIG_SJC_CE\t0x4\n#define MXC_PLL_DP_CONFIG_AREN\t\t0x2\n#define MXC_PLL_DP_CONFIG_LDREQ\t\t0x1\n\n#define MXC_PLL_DP_OP_MFI_OFFSET\t4\n#define MXC_PLL_DP_OP_MFI_MASK\t\t(0xF << 4)\n#define MXC_PLL_DP_OP_PDF_OFFSET\t0\n#define MXC_PLL_DP_OP_PDF_MASK\t\t0xF\n\n#define MXC_PLL_DP_MFD_OFFSET\t\t0\n#define MXC_PLL_DP_MFD_MASK\t\t0x07FFFFFF\n\n#define MXC_PLL_DP_MFN_OFFSET\t\t0x0\n#define MXC_PLL_DP_MFN_MASK\t\t0x07FFFFFF\n\n#define MXC_PLL_DP_MFN_TOGC_TOG_DIS\t(1 << 17)\n#define MXC_PLL_DP_MFN_TOGC_TOG_EN\t(1 << 16)\n#define MXC_PLL_DP_MFN_TOGC_CNT_OFFSET\t0x0\n#define MXC_PLL_DP_MFN_TOGC_CNT_MASK\t0xFFFF\n\n#define MXC_PLL_DP_DESTAT_TOG_SEL\t(1 << 31)\n#define MXC_PLL_DP_DESTAT_MFN\t\t0x07FFFFFF\n\n#define MAX_DPLL_WAIT_TRIES\t1000  \n\nstruct clk_pllv2 {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*base;\n};\n\nstatic unsigned long __clk_pllv2_recalc_rate(unsigned long parent_rate,\n\t\tu32 dp_ctl, u32 dp_op, u32 dp_mfd, u32 dp_mfn)\n{\n\tlong mfi, mfn, mfd, pdf, ref_clk;\n\tunsigned long dbl;\n\tu64 temp;\n\n\tdbl = dp_ctl & MXC_PLL_DP_CTL_DPDCK0_2_EN;\n\n\tpdf = dp_op & MXC_PLL_DP_OP_PDF_MASK;\n\tmfi = (dp_op & MXC_PLL_DP_OP_MFI_MASK) >> MXC_PLL_DP_OP_MFI_OFFSET;\n\tmfi = (mfi <= 5) ? 5 : mfi;\n\tmfd = dp_mfd & MXC_PLL_DP_MFD_MASK;\n\tmfn = dp_mfn & MXC_PLL_DP_MFN_MASK;\n\tmfn = sign_extend32(mfn, 26);\n\n\tref_clk = 2 * parent_rate;\n\tif (dbl != 0)\n\t\tref_clk *= 2;\n\n\tref_clk /= (pdf + 1);\n\ttemp = (u64) ref_clk * abs(mfn);\n\tdo_div(temp, mfd + 1);\n\tif (mfn < 0)\n\t\ttemp = (ref_clk * mfi) - temp;\n\telse\n\t\ttemp = (ref_clk * mfi) + temp;\n\n\treturn temp;\n}\n\nstatic unsigned long clk_pllv2_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tu32 dp_op, dp_mfd, dp_mfn, dp_ctl;\n\tvoid __iomem *pllbase;\n\tstruct clk_pllv2 *pll = to_clk_pllv2(hw);\n\n\tpllbase = pll->base;\n\n\tdp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);\n\tdp_op = __raw_readl(pllbase + MXC_PLL_DP_OP);\n\tdp_mfd = __raw_readl(pllbase + MXC_PLL_DP_MFD);\n\tdp_mfn = __raw_readl(pllbase + MXC_PLL_DP_MFN);\n\n\treturn __clk_pllv2_recalc_rate(parent_rate, dp_ctl, dp_op, dp_mfd, dp_mfn);\n}\n\nstatic int __clk_pllv2_set_rate(unsigned long rate, unsigned long parent_rate,\n\t\tu32 *dp_op, u32 *dp_mfd, u32 *dp_mfn)\n{\n\tu32 reg;\n\tlong mfi, pdf, mfn, mfd = 999999;\n\tu64 temp64;\n\tunsigned long quad_parent_rate;\n\n\tquad_parent_rate = 4 * parent_rate;\n\tpdf = mfi = -1;\n\twhile (++pdf < 16 && mfi < 5)\n\t\tmfi = rate * (pdf+1) / quad_parent_rate;\n\tif (mfi > 15)\n\t\treturn -EINVAL;\n\tpdf--;\n\n\ttemp64 = rate * (pdf + 1) - quad_parent_rate * mfi;\n\tdo_div(temp64, quad_parent_rate / 1000000);\n\tmfn = (long)temp64;\n\n\treg = mfi << 4 | pdf;\n\n\t*dp_op = reg;\n\t*dp_mfd = mfd;\n\t*dp_mfn = mfn;\n\n\treturn 0;\n}\n\nstatic int clk_pllv2_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_pllv2 *pll = to_clk_pllv2(hw);\n\tvoid __iomem *pllbase;\n\tu32 dp_ctl, dp_op, dp_mfd, dp_mfn;\n\tint ret;\n\n\tpllbase = pll->base;\n\n\n\tret = __clk_pllv2_set_rate(rate, parent_rate, &dp_op, &dp_mfd, &dp_mfn);\n\tif (ret)\n\t\treturn ret;\n\n\tdp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);\n\t \n\t__raw_writel(dp_ctl | 0x1000L, pllbase + MXC_PLL_DP_CTL);\n\n\t__raw_writel(dp_op, pllbase + MXC_PLL_DP_OP);\n\t__raw_writel(dp_mfd, pllbase + MXC_PLL_DP_MFD);\n\t__raw_writel(dp_mfn, pllbase + MXC_PLL_DP_MFN);\n\n\treturn 0;\n}\n\nstatic long clk_pllv2_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long *prate)\n{\n\tu32 dp_op, dp_mfd, dp_mfn;\n\tint ret;\n\n\tret = __clk_pllv2_set_rate(rate, *prate, &dp_op, &dp_mfd, &dp_mfn);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __clk_pllv2_recalc_rate(*prate, MXC_PLL_DP_CTL_DPDCK0_2_EN,\n\t\t\tdp_op, dp_mfd, dp_mfn);\n}\n\nstatic int clk_pllv2_prepare(struct clk_hw *hw)\n{\n\tstruct clk_pllv2 *pll = to_clk_pllv2(hw);\n\tu32 reg;\n\tvoid __iomem *pllbase;\n\tint i = 0;\n\n\tpllbase = pll->base;\n\treg = __raw_readl(pllbase + MXC_PLL_DP_CTL) | MXC_PLL_DP_CTL_UPEN;\n\t__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);\n\n\t \n\tdo {\n\t\treg = __raw_readl(pllbase + MXC_PLL_DP_CTL);\n\t\tif (reg & MXC_PLL_DP_CTL_LRF)\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t} while (++i < MAX_DPLL_WAIT_TRIES);\n\n\tif (i == MAX_DPLL_WAIT_TRIES) {\n\t\tpr_err(\"MX5: pll locking failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void clk_pllv2_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_pllv2 *pll = to_clk_pllv2(hw);\n\tu32 reg;\n\tvoid __iomem *pllbase;\n\n\tpllbase = pll->base;\n\treg = __raw_readl(pllbase + MXC_PLL_DP_CTL) & ~MXC_PLL_DP_CTL_UPEN;\n\t__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);\n}\n\nstatic const struct clk_ops clk_pllv2_ops = {\n\t.prepare = clk_pllv2_prepare,\n\t.unprepare = clk_pllv2_unprepare,\n\t.recalc_rate = clk_pllv2_recalc_rate,\n\t.round_rate = clk_pllv2_round_rate,\n\t.set_rate = clk_pllv2_set_rate,\n};\n\nstruct clk_hw *imx_clk_hw_pllv2(const char *name, const char *parent,\n\t\tvoid __iomem *base)\n{\n\tstruct clk_pllv2 *pll;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpll->base = base;\n\n\tinit.name = name;\n\tinit.ops = &clk_pllv2_ops;\n\tinit.flags = 0;\n\tinit.parent_names = &parent;\n\tinit.num_parents = 1;\n\n\tpll->hw.init = &init;\n\thw = &pll->hw;\n\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(pll);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}