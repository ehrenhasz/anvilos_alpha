{
  "module_name": "clk-fixup-mux.c",
  "hash_id": "7450b46ece03eeba7c59fac1bffe9e5b1206c28ee1048373b4d08526cc2e0bbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-fixup-mux.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include \"clk.h\"\n\n \nstruct clk_fixup_mux {\n\tstruct clk_mux mux;\n\tconst struct clk_ops *ops;\n\tvoid (*fixup)(u32 *val);\n};\n\nstatic inline struct clk_fixup_mux *to_clk_fixup_mux(struct clk_hw *hw)\n{\n\tstruct clk_mux *mux = to_clk_mux(hw);\n\n\treturn container_of(mux, struct clk_fixup_mux, mux);\n}\n\nstatic u8 clk_fixup_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_fixup_mux *fixup_mux = to_clk_fixup_mux(hw);\n\n\treturn fixup_mux->ops->get_parent(&fixup_mux->mux.hw);\n}\n\nstatic int clk_fixup_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_fixup_mux *fixup_mux = to_clk_fixup_mux(hw);\n\tstruct clk_mux *mux = to_clk_mux(hw);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(mux->lock, flags);\n\n\tval = readl(mux->reg);\n\tval &= ~(mux->mask << mux->shift);\n\tval |= index << mux->shift;\n\tfixup_mux->fixup(&val);\n\twritel(val, mux->reg);\n\n\tspin_unlock_irqrestore(mux->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_fixup_mux_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.get_parent = clk_fixup_mux_get_parent,\n\t.set_parent = clk_fixup_mux_set_parent,\n};\n\nstruct clk_hw *imx_clk_hw_fixup_mux(const char *name, void __iomem *reg,\n\t\t\t      u8 shift, u8 width, const char * const *parents,\n\t\t\t      int num_parents, void (*fixup)(u32 *val))\n{\n\tstruct clk_fixup_mux *fixup_mux;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tif (!fixup)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfixup_mux = kzalloc(sizeof(*fixup_mux), GFP_KERNEL);\n\tif (!fixup_mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &clk_fixup_mux_ops;\n\tinit.parent_names = parents;\n\tinit.num_parents = num_parents;\n\tinit.flags = 0;\n\n\tfixup_mux->mux.reg = reg;\n\tfixup_mux->mux.shift = shift;\n\tfixup_mux->mux.mask = BIT(width) - 1;\n\tfixup_mux->mux.lock = &imx_ccm_lock;\n\tfixup_mux->mux.hw.init = &init;\n\tfixup_mux->ops = &clk_mux_ops;\n\tfixup_mux->fixup = fixup;\n\n\thw = &fixup_mux->mux.hw;\n\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(fixup_mux);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}