{
  "module_name": "clk-imx8-acm.c",
  "hash_id": "5dbd4a716c241c1322739d5b693324c78e4aa97b60e880e2436bdbb991adac5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-imx8-acm.c",
  "human_readable_source": "\n\n\n\n\n#include <dt-bindings/clock/imx8-clock.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\n \nstruct clk_imx_acm_pm_domains {\n\tstruct device **pd_dev;\n\tstruct device_link **pd_dev_link;\n\tint    num_domains;\n};\n\n \nstruct clk_imx8_acm_sel {\n\tconst char\t\t\t*name;\n\tint\t\t\t\tclkid;\n\tconst struct clk_parent_data\t*parents;\t \n\tint\t\t\t\tnum_parents;\n\tu32\t\t\t\treg;\n\tu8\t\t\t\tshift;\n\tu8\t\t\t\twidth;\n};\n\n \nstruct imx8_acm_soc_data {\n\tstruct clk_imx8_acm_sel *sels;\n\tunsigned int num_sels;\n};\n\n \nstruct imx8_acm_priv {\n\tstruct clk_imx_acm_pm_domains dev_pm;\n\tconst struct imx8_acm_soc_data *soc_data;\n\tvoid __iomem *reg;\n\tu32 regs[IMX_ADMA_ACM_CLK_END];\n};\n\nstatic const struct clk_parent_data imx8qm_aud_clk_sels[] = {\n\t{ .fw_name = \"aud_rec_clk0_lpcg_clk\" },\n\t{ .fw_name = \"aud_rec_clk1_lpcg_clk\" },\n\t{ .fw_name = \"mlb_clk\" },\n\t{ .fw_name = \"hdmi_rx_mclk\" },\n\t{ .fw_name = \"ext_aud_mclk0\" },\n\t{ .fw_name = \"ext_aud_mclk1\" },\n\t{ .fw_name = \"esai0_rx_clk\" },\n\t{ .fw_name = \"esai0_rx_hf_clk\" },\n\t{ .fw_name = \"esai0_tx_clk\" },\n\t{ .fw_name = \"esai0_tx_hf_clk\" },\n\t{ .fw_name = \"esai1_rx_clk\" },\n\t{ .fw_name = \"esai1_rx_hf_clk\" },\n\t{ .fw_name = \"esai1_tx_clk\" },\n\t{ .fw_name = \"esai1_tx_hf_clk\" },\n\t{ .fw_name = \"spdif0_rx\" },\n\t{ .fw_name = \"spdif1_rx\" },\n\t{ .fw_name = \"sai0_rx_bclk\" },\n\t{ .fw_name = \"sai0_tx_bclk\" },\n\t{ .fw_name = \"sai1_rx_bclk\" },\n\t{ .fw_name = \"sai1_tx_bclk\" },\n\t{ .fw_name = \"sai2_rx_bclk\" },\n\t{ .fw_name = \"sai3_rx_bclk\" },\n\t{ .fw_name = \"sai4_rx_bclk\" },\n};\n\nstatic const struct clk_parent_data imx8qm_mclk_out_sels[] = {\n\t{ .fw_name = \"aud_rec_clk0_lpcg_clk\" },\n\t{ .fw_name = \"aud_rec_clk1_lpcg_clk\" },\n\t{ .fw_name = \"mlb_clk\" },\n\t{ .fw_name = \"hdmi_rx_mclk\" },\n\t{ .fw_name = \"spdif0_rx\" },\n\t{ .fw_name = \"spdif1_rx\" },\n\t{ .fw_name = \"sai4_rx_bclk\" },\n\t{ .fw_name = \"sai6_rx_bclk\" },\n};\n\nstatic const struct clk_parent_data imx8qm_mclk_sels[] = {\n\t{ .fw_name = \"aud_pll_div_clk0_lpcg_clk\" },\n\t{ .fw_name = \"aud_pll_div_clk1_lpcg_clk\" },\n\t{ .fw_name = \"acm_aud_clk0_sel\" },\n\t{ .fw_name = \"acm_aud_clk1_sel\" },\n};\n\nstatic const struct clk_parent_data imx8qm_asrc_mux_clk_sels[] = {\n\t{ .fw_name = \"sai4_rx_bclk\" },\n\t{ .fw_name = \"sai5_tx_bclk\" },\n\t{ .index = -1 },\n\t{ .fw_name = \"mlb_clk\" },\n\n};\n\nstatic struct clk_imx8_acm_sel imx8qm_sels[] = {\n\t{ \"acm_aud_clk0_sel\", IMX_ADMA_ACM_AUD_CLK0_SEL, imx8qm_aud_clk_sels, ARRAY_SIZE(imx8qm_aud_clk_sels), 0x000000, 0, 5 },\n\t{ \"acm_aud_clk1_sel\", IMX_ADMA_ACM_AUD_CLK1_SEL, imx8qm_aud_clk_sels, ARRAY_SIZE(imx8qm_aud_clk_sels), 0x010000, 0, 5 },\n\t{ \"acm_mclkout0_sel\", IMX_ADMA_ACM_MCLKOUT0_SEL, imx8qm_mclk_out_sels, ARRAY_SIZE(imx8qm_mclk_out_sels), 0x020000, 0, 3 },\n\t{ \"acm_mclkout1_sel\", IMX_ADMA_ACM_MCLKOUT1_SEL, imx8qm_mclk_out_sels, ARRAY_SIZE(imx8qm_mclk_out_sels), 0x030000, 0, 3 },\n\t{ \"acm_asrc0_mclk_sel\", IMX_ADMA_ACM_ASRC0_MUX_CLK_SEL, imx8qm_asrc_mux_clk_sels, ARRAY_SIZE(imx8qm_asrc_mux_clk_sels), 0x040000, 0, 2 },\n\t{ \"acm_esai0_mclk_sel\", IMX_ADMA_ACM_ESAI0_MCLK_SEL, imx8qm_mclk_sels, ARRAY_SIZE(imx8qm_mclk_sels), 0x060000, 0, 2 },\n\t{ \"acm_esai1_mclk_sel\", IMX_ADMA_ACM_ESAI1_MCLK_SEL, imx8qm_mclk_sels, ARRAY_SIZE(imx8qm_mclk_sels), 0x070000, 0, 2 },\n\t{ \"acm_sai0_mclk_sel\", IMX_ADMA_ACM_SAI0_MCLK_SEL, imx8qm_mclk_sels, ARRAY_SIZE(imx8qm_mclk_sels), 0x0E0000, 0, 2 },\n\t{ \"acm_sai1_mclk_sel\", IMX_ADMA_ACM_SAI1_MCLK_SEL, imx8qm_mclk_sels, ARRAY_SIZE(imx8qm_mclk_sels), 0x0F0000, 0, 2 },\n\t{ \"acm_sai2_mclk_sel\", IMX_ADMA_ACM_SAI2_MCLK_SEL, imx8qm_mclk_sels, ARRAY_SIZE(imx8qm_mclk_sels), 0x100000, 0, 2 },\n\t{ \"acm_sai3_mclk_sel\", IMX_ADMA_ACM_SAI3_MCLK_SEL, imx8qm_mclk_sels, ARRAY_SIZE(imx8qm_mclk_sels), 0x110000, 0, 2 },\n\t{ \"acm_sai4_mclk_sel\", IMX_ADMA_ACM_SAI4_MCLK_SEL, imx8qm_mclk_sels, ARRAY_SIZE(imx8qm_mclk_sels), 0x120000, 0, 2 },\n\t{ \"acm_sai5_mclk_sel\", IMX_ADMA_ACM_SAI5_MCLK_SEL, imx8qm_mclk_sels, ARRAY_SIZE(imx8qm_mclk_sels), 0x130000, 0, 2 },\n\t{ \"acm_sai6_mclk_sel\", IMX_ADMA_ACM_SAI6_MCLK_SEL, imx8qm_mclk_sels, ARRAY_SIZE(imx8qm_mclk_sels), 0x140000, 0, 2 },\n\t{ \"acm_sai7_mclk_sel\", IMX_ADMA_ACM_SAI7_MCLK_SEL, imx8qm_mclk_sels, ARRAY_SIZE(imx8qm_mclk_sels), 0x150000, 0, 2 },\n\t{ \"acm_spdif0_mclk_sel\", IMX_ADMA_ACM_SPDIF0_TX_CLK_SEL, imx8qm_mclk_sels, ARRAY_SIZE(imx8qm_mclk_sels), 0x1A0000, 0, 2 },\n\t{ \"acm_spdif1_mclk_sel\", IMX_ADMA_ACM_SPDIF1_TX_CLK_SEL, imx8qm_mclk_sels, ARRAY_SIZE(imx8qm_mclk_sels), 0x1B0000, 0, 2 },\n\t{ \"acm_mqs_mclk_sel\", IMX_ADMA_ACM_MQS_TX_CLK_SEL, imx8qm_mclk_sels, ARRAY_SIZE(imx8qm_mclk_sels), 0x1C0000, 0, 2 },\n};\n\nstatic const struct clk_parent_data imx8qxp_aud_clk_sels[] = {\n\t{ .fw_name = \"aud_rec_clk0_lpcg_clk\" },\n\t{ .fw_name = \"aud_rec_clk1_lpcg_clk\" },\n\t{ .fw_name = \"ext_aud_mclk0\" },\n\t{ .fw_name = \"ext_aud_mclk1\" },\n\t{ .fw_name = \"esai0_rx_clk\" },\n\t{ .fw_name = \"esai0_rx_hf_clk\" },\n\t{ .fw_name = \"esai0_tx_clk\" },\n\t{ .fw_name = \"esai0_tx_hf_clk\" },\n\t{ .fw_name = \"spdif0_rx\" },\n\t{ .fw_name = \"sai0_rx_bclk\" },\n\t{ .fw_name = \"sai0_tx_bclk\" },\n\t{ .fw_name = \"sai1_rx_bclk\" },\n\t{ .fw_name = \"sai1_tx_bclk\" },\n\t{ .fw_name = \"sai2_rx_bclk\" },\n\t{ .fw_name = \"sai3_rx_bclk\" },\n};\n\nstatic const struct clk_parent_data imx8qxp_mclk_out_sels[] = {\n\t{ .fw_name = \"aud_rec_clk0_lpcg_clk\" },\n\t{ .fw_name = \"aud_rec_clk1_lpcg_clk\" },\n\t{ .index = -1 },\n\t{ .index = -1 },\n\t{ .fw_name = \"spdif0_rx\" },\n\t{ .index = -1 },\n\t{ .index = -1 },\n\t{ .fw_name = \"sai4_rx_bclk\" },\n};\n\nstatic const struct clk_parent_data imx8qxp_mclk_sels[] = {\n\t{ .fw_name = \"aud_pll_div_clk0_lpcg_clk\" },\n\t{ .fw_name = \"aud_pll_div_clk1_lpcg_clk\" },\n\t{ .fw_name = \"acm_aud_clk0_sel\" },\n\t{ .fw_name = \"acm_aud_clk1_sel\" },\n};\n\nstatic struct clk_imx8_acm_sel imx8qxp_sels[] = {\n\t{ \"acm_aud_clk0_sel\", IMX_ADMA_ACM_AUD_CLK0_SEL, imx8qxp_aud_clk_sels, ARRAY_SIZE(imx8qxp_aud_clk_sels), 0x000000, 0, 5 },\n\t{ \"acm_aud_clk1_sel\", IMX_ADMA_ACM_AUD_CLK1_SEL, imx8qxp_aud_clk_sels, ARRAY_SIZE(imx8qxp_aud_clk_sels), 0x010000, 0, 5 },\n\t{ \"acm_mclkout0_sel\", IMX_ADMA_ACM_MCLKOUT0_SEL, imx8qxp_mclk_out_sels, ARRAY_SIZE(imx8qxp_mclk_out_sels), 0x020000, 0, 3 },\n\t{ \"acm_mclkout1_sel\", IMX_ADMA_ACM_MCLKOUT1_SEL, imx8qxp_mclk_out_sels, ARRAY_SIZE(imx8qxp_mclk_out_sels), 0x030000, 0, 3 },\n\t{ \"acm_esai0_mclk_sel\", IMX_ADMA_ACM_ESAI0_MCLK_SEL, imx8qxp_mclk_sels, ARRAY_SIZE(imx8qxp_mclk_sels), 0x060000, 0, 2 },\n\t{ \"acm_sai0_mclk_sel\", IMX_ADMA_ACM_SAI0_MCLK_SEL, imx8qxp_mclk_sels, ARRAY_SIZE(imx8qxp_mclk_sels), 0x0E0000, 0, 2 },\n\t{ \"acm_sai1_mclk_sel\", IMX_ADMA_ACM_SAI1_MCLK_SEL, imx8qxp_mclk_sels, ARRAY_SIZE(imx8qxp_mclk_sels), 0x0F0000, 0, 2 },\n\t{ \"acm_sai2_mclk_sel\", IMX_ADMA_ACM_SAI2_MCLK_SEL, imx8qxp_mclk_sels, ARRAY_SIZE(imx8qxp_mclk_sels), 0x100000, 0, 2 },\n\t{ \"acm_sai3_mclk_sel\", IMX_ADMA_ACM_SAI3_MCLK_SEL, imx8qxp_mclk_sels, ARRAY_SIZE(imx8qxp_mclk_sels), 0x110000, 0, 2 },\n\t{ \"acm_sai4_mclk_sel\", IMX_ADMA_ACM_SAI4_MCLK_SEL, imx8qxp_mclk_sels, ARRAY_SIZE(imx8qxp_mclk_sels), 0x140000, 0, 2 },\n\t{ \"acm_sai5_mclk_sel\", IMX_ADMA_ACM_SAI5_MCLK_SEL, imx8qxp_mclk_sels, ARRAY_SIZE(imx8qxp_mclk_sels), 0x150000, 0, 2 },\n\t{ \"acm_spdif0_mclk_sel\", IMX_ADMA_ACM_SPDIF0_TX_CLK_SEL, imx8qxp_mclk_sels, ARRAY_SIZE(imx8qxp_mclk_sels), 0x1A0000, 0, 2 },\n\t{ \"acm_mqs_mclk_sel\", IMX_ADMA_ACM_MQS_TX_CLK_SEL, imx8qxp_mclk_sels, ARRAY_SIZE(imx8qxp_mclk_sels), 0x1C0000, 0, 2 },\n};\n\nstatic const struct clk_parent_data imx8dxl_aud_clk_sels[] = {\n\t{ .fw_name = \"aud_rec_clk0_lpcg_clk\" },\n\t{ .fw_name = \"aud_rec_clk1_lpcg_clk\" },\n\t{ .fw_name = \"ext_aud_mclk0\" },\n\t{ .fw_name = \"ext_aud_mclk1\" },\n\t{ .index = -1 },\n\t{ .index = -1 },\n\t{ .index = -1 },\n\t{ .index = -1 },\n\t{ .fw_name = \"spdif0_rx\" },\n\t{ .fw_name = \"sai0_rx_bclk\" },\n\t{ .fw_name = \"sai0_tx_bclk\" },\n\t{ .fw_name = \"sai1_rx_bclk\" },\n\t{ .fw_name = \"sai1_tx_bclk\" },\n\t{ .fw_name = \"sai2_rx_bclk\" },\n\t{ .fw_name = \"sai3_rx_bclk\" },\n};\n\nstatic const struct clk_parent_data imx8dxl_mclk_out_sels[] = {\n\t{ .fw_name = \"aud_rec_clk0_lpcg_clk\" },\n\t{ .fw_name = \"aud_rec_clk1_lpcg_clk\" },\n\t{ .index = -1 },\n\t{ .index = -1 },\n\t{ .fw_name = \"spdif0_rx\" },\n\t{ .index = -1 },\n\t{ .index = -1 },\n\t{ .index = -1 },\n};\n\nstatic const struct clk_parent_data imx8dxl_mclk_sels[] = {\n\t{ .fw_name = \"aud_pll_div_clk0_lpcg_clk\" },\n\t{ .fw_name = \"aud_pll_div_clk1_lpcg_clk\" },\n\t{ .fw_name = \"acm_aud_clk0_sel\" },\n\t{ .fw_name = \"acm_aud_clk1_sel\" },\n};\n\nstatic struct clk_imx8_acm_sel imx8dxl_sels[] = {\n\t{ \"acm_aud_clk0_sel\", IMX_ADMA_ACM_AUD_CLK0_SEL, imx8dxl_aud_clk_sels, ARRAY_SIZE(imx8dxl_aud_clk_sels), 0x000000, 0, 5 },\n\t{ \"acm_aud_clk1_sel\", IMX_ADMA_ACM_AUD_CLK1_SEL, imx8dxl_aud_clk_sels, ARRAY_SIZE(imx8dxl_aud_clk_sels), 0x010000, 0, 5 },\n\t{ \"acm_mclkout0_sel\", IMX_ADMA_ACM_MCLKOUT0_SEL, imx8dxl_mclk_out_sels, ARRAY_SIZE(imx8dxl_mclk_out_sels), 0x020000, 0, 3 },\n\t{ \"acm_mclkout1_sel\", IMX_ADMA_ACM_MCLKOUT1_SEL, imx8dxl_mclk_out_sels, ARRAY_SIZE(imx8dxl_mclk_out_sels), 0x030000, 0, 3 },\n\t{ \"acm_sai0_mclk_sel\", IMX_ADMA_ACM_SAI0_MCLK_SEL, imx8dxl_mclk_sels, ARRAY_SIZE(imx8dxl_mclk_sels), 0x0E0000, 0, 2 },\n\t{ \"acm_sai1_mclk_sel\", IMX_ADMA_ACM_SAI1_MCLK_SEL, imx8dxl_mclk_sels, ARRAY_SIZE(imx8dxl_mclk_sels), 0x0F0000, 0, 2 },\n\t{ \"acm_sai2_mclk_sel\", IMX_ADMA_ACM_SAI2_MCLK_SEL, imx8dxl_mclk_sels, ARRAY_SIZE(imx8dxl_mclk_sels), 0x100000, 0, 2 },\n\t{ \"acm_sai3_mclk_sel\", IMX_ADMA_ACM_SAI3_MCLK_SEL, imx8dxl_mclk_sels, ARRAY_SIZE(imx8dxl_mclk_sels), 0x110000, 0, 2 },\n\t{ \"acm_spdif0_mclk_sel\", IMX_ADMA_ACM_SPDIF0_TX_CLK_SEL, imx8dxl_mclk_sels, ARRAY_SIZE(imx8dxl_mclk_sels), 0x1A0000, 0, 2 },\n\t{ \"acm_mqs_mclk_sel\", IMX_ADMA_ACM_MQS_TX_CLK_SEL, imx8dxl_mclk_sels, ARRAY_SIZE(imx8dxl_mclk_sels), 0x1C0000, 0, 2 },\n};\n\n \nstatic int clk_imx_acm_attach_pm_domains(struct device *dev,\n\t\t\t\t\t struct clk_imx_acm_pm_domains *dev_pm)\n{\n\tint ret;\n\tint i;\n\n\tdev_pm->num_domains = of_count_phandle_with_args(dev->of_node, \"power-domains\",\n\t\t\t\t\t\t\t \"#power-domain-cells\");\n\tif (dev_pm->num_domains <= 1)\n\t\treturn 0;\n\n\tdev_pm->pd_dev = devm_kmalloc_array(dev, dev_pm->num_domains,\n\t\t\t\t\t    sizeof(*dev_pm->pd_dev),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!dev_pm->pd_dev)\n\t\treturn -ENOMEM;\n\n\tdev_pm->pd_dev_link = devm_kmalloc_array(dev,\n\t\t\t\t\t\t dev_pm->num_domains,\n\t\t\t\t\t\t sizeof(*dev_pm->pd_dev_link),\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!dev_pm->pd_dev_link)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < dev_pm->num_domains; i++) {\n\t\tdev_pm->pd_dev[i] = dev_pm_domain_attach_by_id(dev, i);\n\t\tif (IS_ERR(dev_pm->pd_dev[i])) {\n\t\t\tret = PTR_ERR(dev_pm->pd_dev[i]);\n\t\t\tgoto detach_pm;\n\t\t}\n\n\t\tdev_pm->pd_dev_link[i] = device_link_add(dev,\n\t\t\t\t\t\t\t dev_pm->pd_dev[i],\n\t\t\t\t\t\t\t DL_FLAG_STATELESS |\n\t\t\t\t\t\t\t DL_FLAG_PM_RUNTIME |\n\t\t\t\t\t\t\t DL_FLAG_RPM_ACTIVE);\n\t\tif (IS_ERR(dev_pm->pd_dev_link[i])) {\n\t\t\tdev_pm_domain_detach(dev_pm->pd_dev[i], false);\n\t\t\tret = PTR_ERR(dev_pm->pd_dev_link[i]);\n\t\t\tgoto detach_pm;\n\t\t}\n\t}\n\treturn 0;\n\ndetach_pm:\n\twhile (--i >= 0) {\n\t\tdevice_link_del(dev_pm->pd_dev_link[i]);\n\t\tdev_pm_domain_detach(dev_pm->pd_dev[i], false);\n\t}\n\treturn ret;\n}\n\n \nstatic int clk_imx_acm_detach_pm_domains(struct device *dev,\n\t\t\t\t\t struct clk_imx_acm_pm_domains *dev_pm)\n{\n\tint i;\n\n\tif (dev_pm->num_domains <= 1)\n\t\treturn 0;\n\n\tfor (i = 0; i < dev_pm->num_domains; i++) {\n\t\tdevice_link_del(dev_pm->pd_dev_link[i]);\n\t\tdev_pm_domain_detach(dev_pm->pd_dev[i], false);\n\t}\n\n\treturn 0;\n}\n\nstatic int imx8_acm_clk_probe(struct platform_device *pdev)\n{\n\tstruct clk_hw_onecell_data *clk_hw_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct clk_imx8_acm_sel *sels;\n\tstruct imx8_acm_priv *priv;\n\tstruct clk_hw **hws;\n\tvoid __iomem *base;\n\tint ret;\n\tint i;\n\n\tbase = devm_of_iomap(dev, dev->of_node, 0, NULL);\n\tif (WARN_ON(IS_ERR(base)))\n\t\treturn PTR_ERR(base);\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->reg = base;\n\tpriv->soc_data = of_device_get_match_data(dev);\n\tplatform_set_drvdata(pdev, priv);\n\n\tclk_hw_data = devm_kzalloc(&pdev->dev, struct_size(clk_hw_data, hws, IMX_ADMA_ACM_CLK_END),\n\t\t\t\t   GFP_KERNEL);\n\tif (!clk_hw_data)\n\t\treturn -ENOMEM;\n\n\tclk_hw_data->num = IMX_ADMA_ACM_CLK_END;\n\thws = clk_hw_data->hws;\n\n\tret = clk_imx_acm_attach_pm_domains(&pdev->dev, &priv->dev_pm);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tsels = priv->soc_data->sels;\n\tfor (i = 0; i < priv->soc_data->num_sels; i++) {\n\t\thws[sels[i].clkid] = devm_clk_hw_register_mux_parent_data_table(dev,\n\t\t\t\t\t\t\t\t\t\tsels[i].name, sels[i].parents,\n\t\t\t\t\t\t\t\t\t\tsels[i].num_parents, 0,\n\t\t\t\t\t\t\t\t\t\tbase + sels[i].reg,\n\t\t\t\t\t\t\t\t\t\tsels[i].shift, sels[i].width,\n\t\t\t\t\t\t\t\t\t\t0, NULL, NULL);\n\t\tif (IS_ERR(hws[sels[i].clkid])) {\n\t\t\tret = PTR_ERR(hws[sels[i].clkid]);\n\t\t\tgoto err_clk_register;\n\t\t}\n\t}\n\n\timx_check_clk_hws(hws, IMX_ADMA_ACM_CLK_END);\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_hw_data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register hws for ACM\\n\");\n\t\tgoto err_clk_register;\n\t}\n\n\tpm_runtime_put_sync(&pdev->dev);\n\treturn 0;\n\nerr_clk_register:\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tclk_imx_acm_detach_pm_domains(&pdev->dev, &priv->dev_pm);\n\n\treturn ret;\n}\n\nstatic int imx8_acm_clk_remove(struct platform_device *pdev)\n{\n\tstruct imx8_acm_priv *priv = dev_get_drvdata(&pdev->dev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tclk_imx_acm_detach_pm_domains(&pdev->dev, &priv->dev_pm);\n\n\treturn 0;\n}\n\nstatic const struct imx8_acm_soc_data imx8qm_acm_data = {\n\t.sels = imx8qm_sels,\n\t.num_sels = ARRAY_SIZE(imx8qm_sels),\n};\n\nstatic const struct imx8_acm_soc_data imx8qxp_acm_data = {\n\t.sels = imx8qxp_sels,\n\t.num_sels = ARRAY_SIZE(imx8qxp_sels),\n};\n\nstatic const struct imx8_acm_soc_data imx8dxl_acm_data = {\n\t.sels = imx8dxl_sels,\n\t.num_sels = ARRAY_SIZE(imx8dxl_sels),\n};\n\nstatic const struct of_device_id imx8_acm_match[] = {\n\t{ .compatible = \"fsl,imx8qm-acm\", .data = &imx8qm_acm_data },\n\t{ .compatible = \"fsl,imx8qxp-acm\", .data = &imx8qxp_acm_data },\n\t{ .compatible = \"fsl,imx8dxl-acm\", .data = &imx8dxl_acm_data },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx8_acm_match);\n\nstatic int __maybe_unused imx8_acm_runtime_suspend(struct device *dev)\n{\n\tstruct imx8_acm_priv *priv = dev_get_drvdata(dev);\n\tstruct clk_imx8_acm_sel *sels;\n\tint i;\n\n\tsels = priv->soc_data->sels;\n\n\tfor (i = 0; i < priv->soc_data->num_sels; i++)\n\t\tpriv->regs[i] = readl_relaxed(priv->reg + sels[i].reg);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx8_acm_runtime_resume(struct device *dev)\n{\n\tstruct imx8_acm_priv *priv = dev_get_drvdata(dev);\n\tstruct clk_imx8_acm_sel *sels;\n\tint i;\n\n\tsels = priv->soc_data->sels;\n\n\tfor (i = 0; i < priv->soc_data->num_sels; i++)\n\t\twritel_relaxed(priv->regs[i], priv->reg + sels[i].reg);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops imx8_acm_pm_ops = {\n\tSET_RUNTIME_PM_OPS(imx8_acm_runtime_suspend,\n\t\t\t   imx8_acm_runtime_resume, NULL)\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t      pm_runtime_force_resume)\n};\n\nstatic struct platform_driver imx8_acm_clk_driver = {\n\t.driver = {\n\t\t.name = \"imx8-acm\",\n\t\t.of_match_table = imx8_acm_match,\n\t\t.pm = &imx8_acm_pm_ops,\n\t},\n\t.probe = imx8_acm_clk_probe,\n\t.remove = imx8_acm_clk_remove,\n};\nmodule_platform_driver(imx8_acm_clk_driver);\n\nMODULE_AUTHOR(\"Shengjiu Wang <shengjiu.wang@nxp.com>\");\nMODULE_DESCRIPTION(\"Freescale i.MX8 Audio Clock Mux driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}