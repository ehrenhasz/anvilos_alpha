{
  "module_name": "clk-composite-8m.c",
  "hash_id": "e6ab8ff06b59817b75c2720371638431ddc80c5cbda9656688b0bd6b7bed559b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-composite-8m.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#include \"clk.h\"\n\n#define PCG_PREDIV_SHIFT\t16\n#define PCG_PREDIV_WIDTH\t3\n#define PCG_PREDIV_MAX\t\t8\n\n#define PCG_DIV_SHIFT\t\t0\n#define PCG_CORE_DIV_WIDTH\t3\n#define PCG_DIV_WIDTH\t\t6\n#define PCG_DIV_MAX\t\t64\n\n#define PCG_PCS_SHIFT\t\t24\n#define PCG_PCS_MASK\t\t0x7\n\n#define PCG_CGC_SHIFT\t\t28\n\nstatic unsigned long imx8m_clk_composite_divider_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\tunsigned long prediv_rate;\n\tunsigned int prediv_value;\n\tunsigned int div_value;\n\n\tprediv_value = readl(divider->reg) >> divider->shift;\n\tprediv_value &= clk_div_mask(divider->width);\n\n\tprediv_rate = divider_recalc_rate(hw, parent_rate, prediv_value,\n\t\t\t\t\t\tNULL, divider->flags,\n\t\t\t\t\t\tdivider->width);\n\n\tdiv_value = readl(divider->reg) >> PCG_DIV_SHIFT;\n\tdiv_value &= clk_div_mask(PCG_DIV_WIDTH);\n\n\treturn divider_recalc_rate(hw, prediv_rate, div_value, NULL,\n\t\t\t\t   divider->flags, PCG_DIV_WIDTH);\n}\n\nstatic int imx8m_clk_composite_compute_dividers(unsigned long rate,\n\t\t\t\t\t\tunsigned long parent_rate,\n\t\t\t\t\t\tint *prediv, int *postdiv)\n{\n\tint div1, div2;\n\tint error = INT_MAX;\n\tint ret = -EINVAL;\n\n\t*prediv = 1;\n\t*postdiv = 1;\n\n\tfor (div1 = 1; div1 <= PCG_PREDIV_MAX; div1++) {\n\t\tfor (div2 = 1; div2 <= PCG_DIV_MAX; div2++) {\n\t\t\tint new_error = ((parent_rate / div1) / div2) - rate;\n\n\t\t\tif (abs(new_error) < abs(error)) {\n\t\t\t\t*prediv = div1;\n\t\t\t\t*postdiv = div2;\n\t\t\t\terror = new_error;\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic long imx8m_clk_composite_divider_round_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long rate,\n\t\t\t\t\t\tunsigned long *prate)\n{\n\tint prediv_value;\n\tint div_value;\n\n\timx8m_clk_composite_compute_dividers(rate, *prate,\n\t\t\t\t\t\t&prediv_value, &div_value);\n\trate = DIV_ROUND_UP(*prate, prediv_value);\n\n\treturn DIV_ROUND_UP(rate, div_value);\n\n}\n\nstatic int imx8m_clk_composite_divider_set_rate(struct clk_hw *hw,\n\t\t\t\t\tunsigned long rate,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\tunsigned long flags;\n\tint prediv_value;\n\tint div_value;\n\tint ret;\n\tu32 orig, val;\n\n\tret = imx8m_clk_composite_compute_dividers(rate, parent_rate,\n\t\t\t\t\t\t&prediv_value, &div_value);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(divider->lock, flags);\n\n\torig = readl(divider->reg);\n\tval = orig & ~((clk_div_mask(divider->width) << divider->shift) |\n\t\t       (clk_div_mask(PCG_DIV_WIDTH) << PCG_DIV_SHIFT));\n\n\tval |= (u32)(prediv_value  - 1) << divider->shift;\n\tval |= (u32)(div_value - 1) << PCG_DIV_SHIFT;\n\n\tif (val != orig)\n\t\twritel(val, divider->reg);\n\n\tspin_unlock_irqrestore(divider->lock, flags);\n\n\treturn ret;\n}\n\nstatic int imx8m_divider_determine_rate(struct clk_hw *hw,\n\t\t\t\t      struct clk_rate_request *req)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\tint prediv_value;\n\tint div_value;\n\n\t \n\tif (divider->flags & CLK_DIVIDER_READ_ONLY) {\n\t\tu32 val;\n\n\t\tval = readl(divider->reg);\n\t\tprediv_value = val >> divider->shift;\n\t\tprediv_value &= clk_div_mask(divider->width);\n\t\tprediv_value++;\n\n\t\tdiv_value = val >> PCG_DIV_SHIFT;\n\t\tdiv_value &= clk_div_mask(PCG_DIV_WIDTH);\n\t\tdiv_value++;\n\n\t\treturn divider_ro_determine_rate(hw, req, divider->table,\n\t\t\t\t\t\t PCG_PREDIV_WIDTH + PCG_DIV_WIDTH,\n\t\t\t\t\t\t divider->flags, prediv_value * div_value);\n\t}\n\n\treturn divider_determine_rate(hw, req, divider->table,\n\t\t\t\t      PCG_PREDIV_WIDTH + PCG_DIV_WIDTH,\n\t\t\t\t      divider->flags);\n}\n\nstatic const struct clk_ops imx8m_clk_composite_divider_ops = {\n\t.recalc_rate = imx8m_clk_composite_divider_recalc_rate,\n\t.round_rate = imx8m_clk_composite_divider_round_rate,\n\t.set_rate = imx8m_clk_composite_divider_set_rate,\n\t.determine_rate = imx8m_divider_determine_rate,\n};\n\nstatic u8 imx8m_clk_composite_mux_get_parent(struct clk_hw *hw)\n{\n\treturn clk_mux_ops.get_parent(hw);\n}\n\nstatic int imx8m_clk_composite_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_mux *mux = to_clk_mux(hw);\n\tu32 val = clk_mux_index_to_val(mux->table, mux->flags, index);\n\tunsigned long flags = 0;\n\tu32 reg;\n\n\tif (mux->lock)\n\t\tspin_lock_irqsave(mux->lock, flags);\n\n\treg = readl(mux->reg);\n\treg &= ~(mux->mask << mux->shift);\n\tval = val << mux->shift;\n\treg |= val;\n\t \n\twritel(reg, mux->reg);\n\twritel(reg, mux->reg);\n\n\tif (mux->lock)\n\t\tspin_unlock_irqrestore(mux->lock, flags);\n\n\treturn 0;\n}\n\nstatic int\nimx8m_clk_composite_mux_determine_rate(struct clk_hw *hw,\n\t\t\t\t       struct clk_rate_request *req)\n{\n\treturn clk_mux_ops.determine_rate(hw, req);\n}\n\n\nstatic const struct clk_ops imx8m_clk_composite_mux_ops = {\n\t.get_parent = imx8m_clk_composite_mux_get_parent,\n\t.set_parent = imx8m_clk_composite_mux_set_parent,\n\t.determine_rate = imx8m_clk_composite_mux_determine_rate,\n};\n\nstruct clk_hw *__imx8m_clk_hw_composite(const char *name,\n\t\t\t\t\tconst char * const *parent_names,\n\t\t\t\t\tint num_parents, void __iomem *reg,\n\t\t\t\t\tu32 composite_flags,\n\t\t\t\t\tunsigned long flags)\n{\n\tstruct clk_hw *hw = ERR_PTR(-ENOMEM), *mux_hw;\n\tstruct clk_hw *div_hw, *gate_hw = NULL;\n\tstruct clk_divider *div = NULL;\n\tstruct clk_gate *gate = NULL;\n\tstruct clk_mux *mux = NULL;\n\tconst struct clk_ops *divider_ops;\n\tconst struct clk_ops *mux_ops;\n\n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\tgoto fail;\n\n\tmux_hw = &mux->hw;\n\tmux->reg = reg;\n\tmux->shift = PCG_PCS_SHIFT;\n\tmux->mask = PCG_PCS_MASK;\n\tmux->lock = &imx_ccm_lock;\n\n\tdiv = kzalloc(sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\tgoto fail;\n\n\tdiv_hw = &div->hw;\n\tdiv->reg = reg;\n\tif (composite_flags & IMX_COMPOSITE_CORE) {\n\t\tdiv->shift = PCG_DIV_SHIFT;\n\t\tdiv->width = PCG_CORE_DIV_WIDTH;\n\t\tdivider_ops = &clk_divider_ops;\n\t\tmux_ops = &imx8m_clk_composite_mux_ops;\n\t} else if (composite_flags & IMX_COMPOSITE_BUS) {\n\t\tdiv->shift = PCG_PREDIV_SHIFT;\n\t\tdiv->width = PCG_PREDIV_WIDTH;\n\t\tdivider_ops = &imx8m_clk_composite_divider_ops;\n\t\tmux_ops = &imx8m_clk_composite_mux_ops;\n\t} else {\n\t\tdiv->shift = PCG_PREDIV_SHIFT;\n\t\tdiv->width = PCG_PREDIV_WIDTH;\n\t\tdivider_ops = &imx8m_clk_composite_divider_ops;\n\t\tmux_ops = &clk_mux_ops;\n\t\tif (!(composite_flags & IMX_COMPOSITE_FW_MANAGED))\n\t\t\tflags |= CLK_SET_PARENT_GATE;\n\t}\n\n\tdiv->lock = &imx_ccm_lock;\n\tdiv->flags = CLK_DIVIDER_ROUND_CLOSEST;\n\n\t \n\tif (!mcore_booted) {\n\t\tgate = kzalloc(sizeof(*gate), GFP_KERNEL);\n\t\tif (!gate)\n\t\t\tgoto fail;\n\n\t\tgate_hw = &gate->hw;\n\t\tgate->reg = reg;\n\t\tgate->bit_idx = PCG_CGC_SHIFT;\n\t\tgate->lock = &imx_ccm_lock;\n\t}\n\n\thw = clk_hw_register_composite(NULL, name, parent_names, num_parents,\n\t\t\tmux_hw, mux_ops, div_hw,\n\t\t\tdivider_ops, gate_hw, &clk_gate_ops, flags);\n\tif (IS_ERR(hw))\n\t\tgoto fail;\n\n\treturn hw;\n\nfail:\n\tkfree(gate);\n\tkfree(div);\n\tkfree(mux);\n\treturn ERR_CAST(hw);\n}\nEXPORT_SYMBOL_GPL(__imx8m_clk_hw_composite);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}