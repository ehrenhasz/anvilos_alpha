{
  "module_name": "clk-pfd.c",
  "hash_id": "149e4f0695945c6c1c16bd7c1ca47c3083d9f42d0c4476a29a4779ab7230e944",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-pfd.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include \"clk.h\"\n\n \nstruct clk_pfd {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*reg;\n\tu8\t\tidx;\n};\n\n#define to_clk_pfd(_hw) container_of(_hw, struct clk_pfd, hw)\n\n#define SET\t0x4\n#define CLR\t0x8\n#define OTG\t0xc\n\nstatic int clk_pfd_enable(struct clk_hw *hw)\n{\n\tstruct clk_pfd *pfd = to_clk_pfd(hw);\n\n\twritel_relaxed(1 << ((pfd->idx + 1) * 8 - 1), pfd->reg + CLR);\n\n\treturn 0;\n}\n\nstatic void clk_pfd_disable(struct clk_hw *hw)\n{\n\tstruct clk_pfd *pfd = to_clk_pfd(hw);\n\n\twritel_relaxed(1 << ((pfd->idx + 1) * 8 - 1), pfd->reg + SET);\n}\n\nstatic unsigned long clk_pfd_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_pfd *pfd = to_clk_pfd(hw);\n\tu64 tmp = parent_rate;\n\tu8 frac = (readl_relaxed(pfd->reg) >> (pfd->idx * 8)) & 0x3f;\n\n\ttmp *= 18;\n\tdo_div(tmp, frac);\n\n\treturn tmp;\n}\n\nstatic long clk_pfd_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *prate)\n{\n\tu64 tmp = *prate;\n\tu8 frac;\n\n\ttmp = tmp * 18 + rate / 2;\n\tdo_div(tmp, rate);\n\tfrac = tmp;\n\tif (frac < 12)\n\t\tfrac = 12;\n\telse if (frac > 35)\n\t\tfrac = 35;\n\ttmp = *prate;\n\ttmp *= 18;\n\tdo_div(tmp, frac);\n\n\treturn tmp;\n}\n\nstatic int clk_pfd_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_pfd *pfd = to_clk_pfd(hw);\n\tu64 tmp = parent_rate;\n\tu8 frac;\n\n\ttmp = tmp * 18 + rate / 2;\n\tdo_div(tmp, rate);\n\tfrac = tmp;\n\tif (frac < 12)\n\t\tfrac = 12;\n\telse if (frac > 35)\n\t\tfrac = 35;\n\n\twritel_relaxed(0x3f << (pfd->idx * 8), pfd->reg + CLR);\n\twritel_relaxed(frac << (pfd->idx * 8), pfd->reg + SET);\n\n\treturn 0;\n}\n\nstatic int clk_pfd_is_enabled(struct clk_hw *hw)\n{\n\tstruct clk_pfd *pfd = to_clk_pfd(hw);\n\n\tif (readl_relaxed(pfd->reg) & (1 << ((pfd->idx + 1) * 8 - 1)))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic const struct clk_ops clk_pfd_ops = {\n\t.enable\t\t= clk_pfd_enable,\n\t.disable\t= clk_pfd_disable,\n\t.recalc_rate\t= clk_pfd_recalc_rate,\n\t.round_rate\t= clk_pfd_round_rate,\n\t.set_rate\t= clk_pfd_set_rate,\n\t.is_enabled     = clk_pfd_is_enabled,\n};\n\nstruct clk_hw *imx_clk_hw_pfd(const char *name, const char *parent_name,\n\t\t\tvoid __iomem *reg, u8 idx)\n{\n\tstruct clk_pfd *pfd;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tpfd = kzalloc(sizeof(*pfd), GFP_KERNEL);\n\tif (!pfd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpfd->reg = reg;\n\tpfd->idx = idx;\n\n\tinit.name = name;\n\tinit.ops = &clk_pfd_ops;\n\tinit.flags = 0;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tpfd->hw.init = &init;\n\thw = &pfd->hw;\n\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(pfd);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(imx_clk_hw_pfd);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}