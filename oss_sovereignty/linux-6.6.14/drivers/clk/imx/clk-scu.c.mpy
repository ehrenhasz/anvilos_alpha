{
  "module_name": "clk-scu.c",
  "hash_id": "106ef6d646edd8429da94361f25efb4a4fcc5523539b768626645963ed7b0c93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-scu.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/firmware/imx/rsrc.h>\n#include <linux/arm-smccc.h>\n#include <linux/bsearch.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include \"clk-scu.h\"\n\n#define IMX_SIP_CPUFREQ\t\t\t0xC2000001\n#define IMX_SIP_SET_CPUFREQ\t\t0x00\n\nstatic struct imx_sc_ipc *ccm_ipc_handle;\nstatic struct device_node *pd_np;\nstatic struct platform_driver imx_clk_scu_driver;\nstatic const struct imx_clk_scu_rsrc_table *rsrc_table;\n\nstruct imx_scu_clk_node {\n\tconst char *name;\n\tu32 rsrc;\n\tu8 clk_type;\n\tconst char * const *parents;\n\tint num_parents;\n\n\tstruct clk_hw *hw;\n\tstruct list_head node;\n};\n\nstruct list_head imx_scu_clks[IMX_SC_R_LAST];\n\n \nstruct clk_scu {\n\tstruct clk_hw hw;\n\tu16 rsrc_id;\n\tu8 clk_type;\n\n\t \n\tstruct clk_hw *parent;\n\tu8 parent_index;\n\tbool is_enabled;\n\tu32 rate;\n};\n\n \nstruct clk_gpr_scu {\n\tstruct clk_hw hw;\n\tu16 rsrc_id;\n\tu8 gpr_id;\n\tu8 flags;\n\tbool gate_invert;\n};\n\n#define to_clk_gpr_scu(_hw) container_of(_hw, struct clk_gpr_scu, hw)\n\n \nstruct imx_sc_msg_req_set_clock_rate {\n\tstruct imx_sc_rpc_msg hdr;\n\t__le32 rate;\n\t__le16 resource;\n\tu8 clk;\n} __packed __aligned(4);\n\nstruct req_get_clock_rate {\n\t__le16 resource;\n\tu8 clk;\n} __packed __aligned(4);\n\nstruct resp_get_clock_rate {\n\t__le32 rate;\n};\n\n \nstruct imx_sc_msg_get_clock_rate {\n\tstruct imx_sc_rpc_msg hdr;\n\tunion {\n\t\tstruct req_get_clock_rate req;\n\t\tstruct resp_get_clock_rate resp;\n\t} data;\n};\n\n \nstruct imx_sc_msg_get_clock_parent {\n\tstruct imx_sc_rpc_msg hdr;\n\tunion {\n\t\tstruct req_get_clock_parent {\n\t\t\t__le16 resource;\n\t\t\tu8 clk;\n\t\t} __packed __aligned(4) req;\n\t\tstruct resp_get_clock_parent {\n\t\t\tu8 parent;\n\t\t} resp;\n\t} data;\n};\n\n \nstruct imx_sc_msg_set_clock_parent {\n\tstruct imx_sc_rpc_msg hdr;\n\t__le16 resource;\n\tu8 clk;\n\tu8 parent;\n} __packed;\n\n \nstruct imx_sc_msg_req_clock_enable {\n\tstruct imx_sc_rpc_msg hdr;\n\t__le16 resource;\n\tu8 clk;\n\tu8 enable;\n\tu8 autog;\n} __packed __aligned(4);\n\nstatic inline struct clk_scu *to_clk_scu(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct clk_scu, hw);\n}\n\nstatic inline int imx_scu_clk_search_cmp(const void *rsrc, const void *rsrc_p)\n{\n\treturn *(u32 *)rsrc - *(u32 *)rsrc_p;\n}\n\nstatic bool imx_scu_clk_is_valid(u32 rsrc_id)\n{\n\tvoid *p;\n\n\tif (!rsrc_table)\n\t\treturn true;\n\n\tp = bsearch(&rsrc_id, rsrc_table->rsrc, rsrc_table->num,\n\t\t    sizeof(rsrc_table->rsrc[0]), imx_scu_clk_search_cmp);\n\n\treturn p != NULL;\n}\n\nint imx_clk_scu_init(struct device_node *np,\n\t\t     const struct imx_clk_scu_rsrc_table *data)\n{\n\tu32 clk_cells;\n\tint ret, i;\n\n\tret = imx_scu_get_handle(&ccm_ipc_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tof_property_read_u32(np, \"#clock-cells\", &clk_cells);\n\n\tif (clk_cells == 2) {\n\t\tfor (i = 0; i < IMX_SC_R_LAST; i++)\n\t\t\tINIT_LIST_HEAD(&imx_scu_clks[i]);\n\n\t\t \n\t\tpd_np = of_find_compatible_node(NULL, NULL, \"fsl,scu-pd\");\n\t\tif (!pd_np)\n\t\t\treturn -EINVAL;\n\n\t\trsrc_table = data;\n\t}\n\n\treturn platform_driver_register(&imx_clk_scu_driver);\n}\n\n \nstatic unsigned long clk_scu_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_scu *clk = to_clk_scu(hw);\n\tstruct imx_sc_msg_get_clock_rate msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\tint ret;\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_PM;\n\thdr->func = IMX_SC_PM_FUNC_GET_CLOCK_RATE;\n\thdr->size = 2;\n\n\tmsg.data.req.resource = cpu_to_le16(clk->rsrc_id);\n\tmsg.data.req.clk = clk->clk_type;\n\n\tret = imx_scu_call_rpc(ccm_ipc_handle, &msg, true);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to get clock rate %d\\n\",\n\t\t       clk_hw_get_name(hw), ret);\n\t\treturn 0;\n\t}\n\n\treturn le32_to_cpu(msg.data.resp.rate);\n}\n\n \nstatic int clk_scu_determine_rate(struct clk_hw *hw,\n\t\t\t\t  struct clk_rate_request *req)\n{\n\t \n\treturn 0;\n}\n\n \nstatic long clk_scu_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\t \n\treturn rate;\n}\n\nstatic int clk_scu_atf_set_cpu_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_scu *clk = to_clk_scu(hw);\n\tstruct arm_smccc_res res;\n\tunsigned long cluster_id;\n\n\tif (clk->rsrc_id == IMX_SC_R_A35 || clk->rsrc_id == IMX_SC_R_A53)\n\t\tcluster_id = 0;\n\telse if (clk->rsrc_id == IMX_SC_R_A72)\n\t\tcluster_id = 1;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tarm_smccc_smc(IMX_SIP_CPUFREQ, IMX_SIP_SET_CPUFREQ,\n\t\t      cluster_id, rate, 0, 0, 0, 0, &res);\n\n\treturn 0;\n}\n\n \nstatic int clk_scu_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_scu *clk = to_clk_scu(hw);\n\tstruct imx_sc_msg_req_set_clock_rate msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_PM;\n\thdr->func = IMX_SC_PM_FUNC_SET_CLOCK_RATE;\n\thdr->size = 3;\n\n\tmsg.rate = cpu_to_le32(rate);\n\tmsg.resource = cpu_to_le16(clk->rsrc_id);\n\tmsg.clk = clk->clk_type;\n\n\treturn imx_scu_call_rpc(ccm_ipc_handle, &msg, true);\n}\n\nstatic u8 clk_scu_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_scu *clk = to_clk_scu(hw);\n\tstruct imx_sc_msg_get_clock_parent msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\tint ret;\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_PM;\n\thdr->func = IMX_SC_PM_FUNC_GET_CLOCK_PARENT;\n\thdr->size = 2;\n\n\tmsg.data.req.resource = cpu_to_le16(clk->rsrc_id);\n\tmsg.data.req.clk = clk->clk_type;\n\n\tret = imx_scu_call_rpc(ccm_ipc_handle, &msg, true);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to get clock parent %d\\n\",\n\t\t       clk_hw_get_name(hw), ret);\n\t\treturn 0;\n\t}\n\n\tclk->parent_index = msg.data.resp.parent;\n\n\treturn msg.data.resp.parent;\n}\n\nstatic int clk_scu_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_scu *clk = to_clk_scu(hw);\n\tstruct imx_sc_msg_set_clock_parent msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\tint ret;\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_PM;\n\thdr->func = IMX_SC_PM_FUNC_SET_CLOCK_PARENT;\n\thdr->size = 2;\n\n\tmsg.resource = cpu_to_le16(clk->rsrc_id);\n\tmsg.clk = clk->clk_type;\n\tmsg.parent = index;\n\n\tret = imx_scu_call_rpc(ccm_ipc_handle, &msg, true);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to set clock parent %d\\n\",\n\t\t       clk_hw_get_name(hw), ret);\n\t\treturn ret;\n\t}\n\n\tclk->parent_index = index;\n\n\treturn 0;\n}\n\nstatic int sc_pm_clock_enable(struct imx_sc_ipc *ipc, u16 resource,\n\t\t\t      u8 clk, bool enable, bool autog)\n{\n\tstruct imx_sc_msg_req_clock_enable msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_PM;\n\thdr->func = IMX_SC_PM_FUNC_CLOCK_ENABLE;\n\thdr->size = 3;\n\n\tmsg.resource = cpu_to_le16(resource);\n\tmsg.clk = clk;\n\tmsg.enable = enable;\n\tmsg.autog = autog;\n\n\treturn imx_scu_call_rpc(ccm_ipc_handle, &msg, true);\n}\n\n \nstatic int clk_scu_prepare(struct clk_hw *hw)\n{\n\tstruct clk_scu *clk = to_clk_scu(hw);\n\n\treturn sc_pm_clock_enable(ccm_ipc_handle, clk->rsrc_id,\n\t\t\t\t  clk->clk_type, true, false);\n}\n\n \nstatic void clk_scu_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_scu *clk = to_clk_scu(hw);\n\tint ret;\n\n\tret = sc_pm_clock_enable(ccm_ipc_handle, clk->rsrc_id,\n\t\t\t\t clk->clk_type, false, false);\n\tif (ret)\n\t\tpr_warn(\"%s: clk unprepare failed %d\\n\", clk_hw_get_name(hw),\n\t\t\tret);\n}\n\nstatic const struct clk_ops clk_scu_ops = {\n\t.recalc_rate = clk_scu_recalc_rate,\n\t.determine_rate = clk_scu_determine_rate,\n\t.set_rate = clk_scu_set_rate,\n\t.get_parent = clk_scu_get_parent,\n\t.set_parent = clk_scu_set_parent,\n\t.prepare = clk_scu_prepare,\n\t.unprepare = clk_scu_unprepare,\n};\n\nstatic const struct clk_ops clk_scu_cpu_ops = {\n\t.recalc_rate = clk_scu_recalc_rate,\n\t.round_rate = clk_scu_round_rate,\n\t.set_rate = clk_scu_atf_set_cpu_rate,\n\t.prepare = clk_scu_prepare,\n\t.unprepare = clk_scu_unprepare,\n};\n\nstatic const struct clk_ops clk_scu_pi_ops = {\n\t.recalc_rate = clk_scu_recalc_rate,\n\t.round_rate  = clk_scu_round_rate,\n\t.set_rate    = clk_scu_set_rate,\n};\n\nstruct clk_hw *__imx_clk_scu(struct device *dev, const char *name,\n\t\t\t     const char * const *parents, int num_parents,\n\t\t\t     u32 rsrc_id, u8 clk_type)\n{\n\tstruct clk_init_data init;\n\tstruct clk_scu *clk;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tclk = kzalloc(sizeof(*clk), GFP_KERNEL);\n\tif (!clk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclk->rsrc_id = rsrc_id;\n\tclk->clk_type = clk_type;\n\n\tinit.name = name;\n\tinit.ops = &clk_scu_ops;\n\tif (rsrc_id == IMX_SC_R_A35 || rsrc_id == IMX_SC_R_A53 || rsrc_id == IMX_SC_R_A72)\n\t\tinit.ops = &clk_scu_cpu_ops;\n\telse if (rsrc_id == IMX_SC_R_PI_0_PLL)\n\t\tinit.ops = &clk_scu_pi_ops;\n\telse\n\t\tinit.ops = &clk_scu_ops;\n\tinit.parent_names = parents;\n\tinit.num_parents = num_parents;\n\n\t \n\tinit.flags = CLK_GET_RATE_NOCACHE;\n\tclk->hw.init = &init;\n\n\thw = &clk->hw;\n\tret = clk_hw_register(dev, hw);\n\tif (ret) {\n\t\tkfree(clk);\n\t\thw = ERR_PTR(ret);\n\t\treturn hw;\n\t}\n\n\tif (dev)\n\t\tdev_set_drvdata(dev, clk);\n\n\treturn hw;\n}\n\nstruct clk_hw *imx_scu_of_clk_src_get(struct of_phandle_args *clkspec,\n\t\t\t\t      void *data)\n{\n\tunsigned int rsrc = clkspec->args[0];\n\tunsigned int idx = clkspec->args[1];\n\tstruct list_head *scu_clks = data;\n\tstruct imx_scu_clk_node *clk;\n\n\tlist_for_each_entry(clk, &scu_clks[rsrc], node) {\n\t\tif (clk->clk_type == idx)\n\t\t\treturn clk->hw;\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic int imx_clk_scu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct imx_scu_clk_node *clk = dev_get_platdata(dev);\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tif (!((clk->rsrc == IMX_SC_R_A35) || (clk->rsrc == IMX_SC_R_A53) ||\n\t    (clk->rsrc == IMX_SC_R_A72))) {\n\t\tpm_runtime_set_suspended(dev);\n\t\tpm_runtime_set_autosuspend_delay(dev, 50);\n\t\tpm_runtime_use_autosuspend(&pdev->dev);\n\t\tpm_runtime_enable(dev);\n\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tif (ret) {\n\t\t\tpm_genpd_remove_device(dev);\n\t\t\tpm_runtime_disable(dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\thw = __imx_clk_scu(dev, clk->name, clk->parents, clk->num_parents,\n\t\t\t   clk->rsrc, clk->clk_type);\n\tif (IS_ERR(hw)) {\n\t\tpm_runtime_disable(dev);\n\t\treturn PTR_ERR(hw);\n\t}\n\n\tclk->hw = hw;\n\tlist_add_tail(&clk->node, &imx_scu_clks[clk->rsrc]);\n\n\tif (!((clk->rsrc == IMX_SC_R_A35) || (clk->rsrc == IMX_SC_R_A53) ||\n\t    (clk->rsrc == IMX_SC_R_A72))) {\n\t\tpm_runtime_mark_last_busy(&pdev->dev);\n\t\tpm_runtime_put_autosuspend(&pdev->dev);\n\t}\n\n\tdev_dbg(dev, \"register SCU clock rsrc:%d type:%d\\n\", clk->rsrc,\n\t\tclk->clk_type);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx_clk_scu_suspend(struct device *dev)\n{\n\tstruct clk_scu *clk = dev_get_drvdata(dev);\n\tu32 rsrc_id = clk->rsrc_id;\n\n\tif ((rsrc_id == IMX_SC_R_A35) || (rsrc_id == IMX_SC_R_A53) ||\n\t    (rsrc_id == IMX_SC_R_A72))\n\t\treturn 0;\n\n\tclk->parent = clk_hw_get_parent(&clk->hw);\n\n\t \n\tif (clk->rsrc_id == IMX_SC_R_DC_0_VIDEO0 ||\n\t\tclk->rsrc_id == IMX_SC_R_DC_0_VIDEO1 ||\n\t\tclk->rsrc_id == IMX_SC_R_DC_1_VIDEO0 ||\n\t\tclk->rsrc_id == IMX_SC_R_DC_1_VIDEO1)\n\t\tclk->rate = clk_scu_recalc_rate(&clk->hw, 0);\n\telse\n\t\tclk->rate = clk_hw_get_rate(&clk->hw);\n\tclk->is_enabled = clk_hw_is_enabled(&clk->hw);\n\n\tif (clk->parent)\n\t\tdev_dbg(dev, \"save parent %s idx %u\\n\", clk_hw_get_name(clk->parent),\n\t\t\tclk->parent_index);\n\n\tif (clk->rate)\n\t\tdev_dbg(dev, \"save rate %d\\n\", clk->rate);\n\n\tif (clk->is_enabled)\n\t\tdev_dbg(dev, \"save enabled state\\n\");\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx_clk_scu_resume(struct device *dev)\n{\n\tstruct clk_scu *clk = dev_get_drvdata(dev);\n\tu32 rsrc_id = clk->rsrc_id;\n\tint ret = 0;\n\n\tif ((rsrc_id == IMX_SC_R_A35) || (rsrc_id == IMX_SC_R_A53) ||\n\t    (rsrc_id == IMX_SC_R_A72))\n\t\treturn 0;\n\n\tif (clk->parent) {\n\t\tret = clk_scu_set_parent(&clk->hw, clk->parent_index);\n\t\tdev_dbg(dev, \"restore parent %s idx %u %s\\n\",\n\t\t\tclk_hw_get_name(clk->parent),\n\t\t\tclk->parent_index, !ret ? \"success\" : \"failed\");\n\t}\n\n\tif (clk->rate) {\n\t\tret = clk_scu_set_rate(&clk->hw, clk->rate, 0);\n\t\tdev_dbg(dev, \"restore rate %d %s\\n\", clk->rate,\n\t\t\t!ret ? \"success\" : \"failed\");\n\t}\n\n\tif (clk->is_enabled && rsrc_id != IMX_SC_R_PI_0_PLL) {\n\t\tret = clk_scu_prepare(&clk->hw);\n\t\tdev_dbg(dev, \"restore enabled state %s\\n\",\n\t\t\t!ret ? \"success\" : \"failed\");\n\t}\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops imx_clk_scu_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(imx_clk_scu_suspend,\n\t\t\t\t      imx_clk_scu_resume)\n};\n\nstatic struct platform_driver imx_clk_scu_driver = {\n\t.driver = {\n\t\t.name = \"imx-scu-clk\",\n\t\t.suppress_bind_attrs = true,\n\t\t.pm = &imx_clk_scu_pm_ops,\n\t},\n\t.probe = imx_clk_scu_probe,\n};\n\nstatic int imx_clk_scu_attach_pd(struct device *dev, u32 rsrc_id)\n{\n\tstruct of_phandle_args genpdspec = {\n\t\t.np = pd_np,\n\t\t.args_count = 1,\n\t\t.args[0] = rsrc_id,\n\t};\n\n\tif (rsrc_id == IMX_SC_R_A35 || rsrc_id == IMX_SC_R_A53 ||\n\t    rsrc_id == IMX_SC_R_A72)\n\t\treturn 0;\n\n\treturn of_genpd_add_device(&genpdspec, dev);\n}\n\nstruct clk_hw *imx_clk_scu_alloc_dev(const char *name,\n\t\t\t\t     const char * const *parents,\n\t\t\t\t     int num_parents, u32 rsrc_id, u8 clk_type)\n{\n\tstruct imx_scu_clk_node clk = {\n\t\t.name = name,\n\t\t.rsrc = rsrc_id,\n\t\t.clk_type = clk_type,\n\t\t.parents = parents,\n\t\t.num_parents = num_parents,\n\t};\n\tstruct platform_device *pdev;\n\tint ret;\n\n\tif (!imx_scu_clk_is_valid(rsrc_id))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpdev = platform_device_alloc(name, PLATFORM_DEVID_NONE);\n\tif (!pdev) {\n\t\tpr_err(\"%s: failed to allocate scu clk dev rsrc %d type %d\\n\",\n\t\t       name, rsrc_id, clk_type);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tret = platform_device_add_data(pdev, &clk, sizeof(clk));\n\tif (ret) {\n\t\tplatform_device_put(pdev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = driver_set_override(&pdev->dev, &pdev->driver_override,\n\t\t\t\t  \"imx-scu-clk\", strlen(\"imx-scu-clk\"));\n\tif (ret) {\n\t\tplatform_device_put(pdev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = imx_clk_scu_attach_pd(&pdev->dev, rsrc_id);\n\tif (ret)\n\t\tpr_warn(\"%s: failed to attached the power domain %d\\n\",\n\t\t\tname, ret);\n\n\tret = platform_device_add(pdev);\n\tif (ret) {\n\t\tplatform_device_put(pdev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\treturn NULL;\n}\n\nvoid imx_clk_scu_unregister(void)\n{\n\tstruct imx_scu_clk_node *clk, *n;\n\tint i;\n\n\tfor (i = 0; i < IMX_SC_R_LAST; i++) {\n\t\tlist_for_each_entry_safe(clk, n, &imx_scu_clks[i], node) {\n\t\t\tclk_hw_unregister(clk->hw);\n\t\t\tkfree(clk);\n\t\t}\n\t}\n}\n\nstatic unsigned long clk_gpr_div_scu_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_gpr_scu *clk = to_clk_gpr_scu(hw);\n\tunsigned long rate = 0;\n\tu32 val;\n\tint err;\n\n\terr = imx_sc_misc_get_control(ccm_ipc_handle, clk->rsrc_id,\n\t\t\t\t      clk->gpr_id, &val);\n\n\trate  = val ? parent_rate / 2 : parent_rate;\n\n\treturn err ? 0 : rate;\n}\n\nstatic long clk_gpr_div_scu_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long *prate)\n{\n\tif (rate < *prate)\n\t\trate = *prate / 2;\n\telse\n\t\trate = *prate;\n\n\treturn rate;\n}\n\nstatic int clk_gpr_div_scu_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_gpr_scu *clk = to_clk_gpr_scu(hw);\n\tuint32_t val;\n\tint err;\n\n\tval = (rate < parent_rate) ? 1 : 0;\n\terr = imx_sc_misc_set_control(ccm_ipc_handle, clk->rsrc_id,\n\t\t\t\t      clk->gpr_id, val);\n\n\treturn err ? -EINVAL : 0;\n}\n\nstatic const struct clk_ops clk_gpr_div_scu_ops = {\n\t.recalc_rate = clk_gpr_div_scu_recalc_rate,\n\t.round_rate = clk_gpr_div_scu_round_rate,\n\t.set_rate = clk_gpr_div_scu_set_rate,\n};\n\nstatic u8 clk_gpr_mux_scu_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_gpr_scu *clk = to_clk_gpr_scu(hw);\n\tu32 val = 0;\n\n\timx_sc_misc_get_control(ccm_ipc_handle, clk->rsrc_id,\n\t\t\t\tclk->gpr_id, &val);\n\n\treturn (u8)val;\n}\n\nstatic int clk_gpr_mux_scu_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_gpr_scu *clk = to_clk_gpr_scu(hw);\n\n\treturn imx_sc_misc_set_control(ccm_ipc_handle, clk->rsrc_id,\n\t\t\t\t       clk->gpr_id, index);\n}\n\nstatic const struct clk_ops clk_gpr_mux_scu_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.get_parent = clk_gpr_mux_scu_get_parent,\n\t.set_parent = clk_gpr_mux_scu_set_parent,\n};\n\nstatic int clk_gpr_gate_scu_prepare(struct clk_hw *hw)\n{\n\tstruct clk_gpr_scu *clk = to_clk_gpr_scu(hw);\n\n\treturn imx_sc_misc_set_control(ccm_ipc_handle, clk->rsrc_id,\n\t\t\t\t       clk->gpr_id, !clk->gate_invert);\n}\n\nstatic void clk_gpr_gate_scu_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_gpr_scu *clk = to_clk_gpr_scu(hw);\n\tint ret;\n\n\tret = imx_sc_misc_set_control(ccm_ipc_handle, clk->rsrc_id,\n\t\t\t\t      clk->gpr_id, clk->gate_invert);\n\tif (ret)\n\t\tpr_err(\"%s: clk unprepare failed %d\\n\", clk_hw_get_name(hw),\n\t\t       ret);\n}\n\nstatic int clk_gpr_gate_scu_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_gpr_scu *clk = to_clk_gpr_scu(hw);\n\tint ret;\n\tu32 val;\n\n\tret = imx_sc_misc_get_control(ccm_ipc_handle, clk->rsrc_id,\n\t\t\t\t      clk->gpr_id, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn clk->gate_invert ? !val : val;\n}\n\nstatic const struct clk_ops clk_gpr_gate_scu_ops = {\n\t.prepare = clk_gpr_gate_scu_prepare,\n\t.unprepare = clk_gpr_gate_scu_unprepare,\n\t.is_prepared = clk_gpr_gate_scu_is_prepared,\n};\n\nstruct clk_hw *__imx_clk_gpr_scu(const char *name, const char * const *parent_name,\n\t\t\t\t int num_parents, u32 rsrc_id, u8 gpr_id, u8 flags,\n\t\t\t\t bool invert)\n{\n\tstruct imx_scu_clk_node *clk_node;\n\tstruct clk_gpr_scu *clk;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tif (rsrc_id >= IMX_SC_R_LAST || gpr_id >= IMX_SC_C_LAST)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tclk_node = kzalloc(sizeof(*clk_node), GFP_KERNEL);\n\tif (!clk_node)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!imx_scu_clk_is_valid(rsrc_id)) {\n\t\tkfree(clk_node);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tclk = kzalloc(sizeof(*clk), GFP_KERNEL);\n\tif (!clk) {\n\t\tkfree(clk_node);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tclk->rsrc_id = rsrc_id;\n\tclk->gpr_id = gpr_id;\n\tclk->flags = flags;\n\tclk->gate_invert = invert;\n\n\tif (flags & IMX_SCU_GPR_CLK_GATE)\n\t\tinit.ops = &clk_gpr_gate_scu_ops;\n\n\tif (flags & IMX_SCU_GPR_CLK_DIV)\n\t\tinit.ops = &clk_gpr_div_scu_ops;\n\n\tif (flags & IMX_SCU_GPR_CLK_MUX)\n\t\tinit.ops = &clk_gpr_mux_scu_ops;\n\n\tinit.flags = 0;\n\tinit.name = name;\n\tinit.parent_names = parent_name;\n\tinit.num_parents = num_parents;\n\n\tclk->hw.init = &init;\n\n\thw = &clk->hw;\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(clk);\n\t\tkfree(clk_node);\n\t\thw = ERR_PTR(ret);\n\t} else {\n\t\tclk_node->hw = hw;\n\t\tclk_node->clk_type = gpr_id;\n\t\tlist_add_tail(&clk_node->node, &imx_scu_clks[rsrc_id]);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}