{
  "module_name": "clk-busy.c",
  "hash_id": "253f422c199daf49aca6197c85940c429cff8426393ab6630f935e89766d05f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-busy.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/err.h>\n#include \"clk.h\"\n\nstatic int clk_busy_wait(void __iomem *reg, u8 shift)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(10);\n\n\twhile (readl_relaxed(reg) & (1 << shift))\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstruct clk_busy_divider {\n\tstruct clk_divider div;\n\tconst struct clk_ops *div_ops;\n\tvoid __iomem *reg;\n\tu8 shift;\n};\n\nstatic inline struct clk_busy_divider *to_clk_busy_divider(struct clk_hw *hw)\n{\n\tstruct clk_divider *div = to_clk_divider(hw);\n\n\treturn container_of(div, struct clk_busy_divider, div);\n}\n\nstatic unsigned long clk_busy_divider_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct clk_busy_divider *busy = to_clk_busy_divider(hw);\n\n\treturn busy->div_ops->recalc_rate(&busy->div.hw, parent_rate);\n}\n\nstatic long clk_busy_divider_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\tunsigned long *prate)\n{\n\tstruct clk_busy_divider *busy = to_clk_busy_divider(hw);\n\n\treturn busy->div_ops->round_rate(&busy->div.hw, rate, prate);\n}\n\nstatic int clk_busy_divider_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_busy_divider *busy = to_clk_busy_divider(hw);\n\tint ret;\n\n\tret = busy->div_ops->set_rate(&busy->div.hw, rate, parent_rate);\n\tif (!ret)\n\t\tret = clk_busy_wait(busy->reg, busy->shift);\n\n\treturn ret;\n}\n\nstatic const struct clk_ops clk_busy_divider_ops = {\n\t.recalc_rate = clk_busy_divider_recalc_rate,\n\t.round_rate = clk_busy_divider_round_rate,\n\t.set_rate = clk_busy_divider_set_rate,\n};\n\nstruct clk_hw *imx_clk_hw_busy_divider(const char *name, const char *parent_name,\n\t\t\t\t void __iomem *reg, u8 shift, u8 width,\n\t\t\t\t void __iomem *busy_reg, u8 busy_shift)\n{\n\tstruct clk_busy_divider *busy;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tbusy = kzalloc(sizeof(*busy), GFP_KERNEL);\n\tif (!busy)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbusy->reg = busy_reg;\n\tbusy->shift = busy_shift;\n\n\tbusy->div.reg = reg;\n\tbusy->div.shift = shift;\n\tbusy->div.width = width;\n\tbusy->div.lock = &imx_ccm_lock;\n\tbusy->div_ops = &clk_divider_ops;\n\n\tinit.name = name;\n\tinit.ops = &clk_busy_divider_ops;\n\tinit.flags = CLK_SET_RATE_PARENT | CLK_IS_CRITICAL;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tbusy->div.hw.init = &init;\n\n\thw = &busy->div.hw;\n\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(busy);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n\nstruct clk_busy_mux {\n\tstruct clk_mux mux;\n\tconst struct clk_ops *mux_ops;\n\tvoid __iomem *reg;\n\tu8 shift;\n};\n\nstatic inline struct clk_busy_mux *to_clk_busy_mux(struct clk_hw *hw)\n{\n\tstruct clk_mux *mux = to_clk_mux(hw);\n\n\treturn container_of(mux, struct clk_busy_mux, mux);\n}\n\nstatic u8 clk_busy_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_busy_mux *busy = to_clk_busy_mux(hw);\n\n\treturn busy->mux_ops->get_parent(&busy->mux.hw);\n}\n\nstatic int clk_busy_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_busy_mux *busy = to_clk_busy_mux(hw);\n\tint ret;\n\n\tret = busy->mux_ops->set_parent(&busy->mux.hw, index);\n\tif (!ret)\n\t\tret = clk_busy_wait(busy->reg, busy->shift);\n\n\treturn ret;\n}\n\nstatic const struct clk_ops clk_busy_mux_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.get_parent = clk_busy_mux_get_parent,\n\t.set_parent = clk_busy_mux_set_parent,\n};\n\nstruct clk_hw *imx_clk_hw_busy_mux(const char *name, void __iomem *reg, u8 shift,\n\t\t\t     u8 width, void __iomem *busy_reg, u8 busy_shift,\n\t\t\t     const char * const *parent_names, int num_parents)\n{\n\tstruct clk_busy_mux *busy;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tbusy = kzalloc(sizeof(*busy), GFP_KERNEL);\n\tif (!busy)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbusy->reg = busy_reg;\n\tbusy->shift = busy_shift;\n\n\tbusy->mux.reg = reg;\n\tbusy->mux.shift = shift;\n\tbusy->mux.mask = BIT(width) - 1;\n\tbusy->mux.lock = &imx_ccm_lock;\n\tbusy->mux_ops = &clk_mux_ops;\n\n\tinit.name = name;\n\tinit.ops = &clk_busy_mux_ops;\n\tinit.flags = CLK_IS_CRITICAL;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\n\tbusy->mux.hw.init = &init;\n\n\thw = &busy->mux.hw;\n\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(busy);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}