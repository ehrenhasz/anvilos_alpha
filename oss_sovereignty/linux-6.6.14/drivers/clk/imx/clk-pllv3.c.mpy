{
  "module_name": "clk-pllv3.c",
  "hash_id": "266178dae266721bbcd5f456dfcb0883a13ed66a44ad960f6c13af80246e86af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-pllv3.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/err.h>\n#include \"clk.h\"\n\n#define PLL_NUM_OFFSET\t\t0x10\n#define PLL_DENOM_OFFSET\t0x20\n#define PLL_IMX7_NUM_OFFSET\t0x20\n#define PLL_IMX7_DENOM_OFFSET\t0x30\n\n#define PLL_VF610_NUM_OFFSET\t0x20\n#define PLL_VF610_DENOM_OFFSET\t0x30\n\n#define BM_PLL_POWER\t\t(0x1 << 12)\n#define BM_PLL_LOCK\t\t(0x1 << 31)\n#define IMX7_ENET_PLL_POWER\t(0x1 << 5)\n#define IMX7_DDR_PLL_POWER\t(0x1 << 20)\n\n#define PLL_LOCK_TIMEOUT\t10000\n\n \nstruct clk_pllv3 {\n\tstruct clk_hw\thw;\n\tvoid __iomem\t*base;\n\tu32\t\tpower_bit;\n\tbool\t\tpowerup_set;\n\tu32\t\tdiv_mask;\n\tu32\t\tdiv_shift;\n\tunsigned long\tref_clock;\n\tu32\t\tnum_offset;\n\tu32\t\tdenom_offset;\n};\n\n#define to_clk_pllv3(_hw) container_of(_hw, struct clk_pllv3, hw)\n\nstatic int clk_pllv3_wait_lock(struct clk_pllv3 *pll)\n{\n\tu32 val = readl_relaxed(pll->base) & pll->power_bit;\n\n\t \n\tif ((pll->powerup_set && !val) || (!pll->powerup_set && val))\n\t\treturn 0;\n\n\treturn readl_relaxed_poll_timeout(pll->base, val, val & BM_PLL_LOCK,\n\t\t\t\t\t  500, PLL_LOCK_TIMEOUT);\n}\n\nstatic int clk_pllv3_prepare(struct clk_hw *hw)\n{\n\tstruct clk_pllv3 *pll = to_clk_pllv3(hw);\n\tu32 val;\n\n\tval = readl_relaxed(pll->base);\n\tif (pll->powerup_set)\n\t\tval |= pll->power_bit;\n\telse\n\t\tval &= ~pll->power_bit;\n\twritel_relaxed(val, pll->base);\n\n\treturn clk_pllv3_wait_lock(pll);\n}\n\nstatic void clk_pllv3_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_pllv3 *pll = to_clk_pllv3(hw);\n\tu32 val;\n\n\tval = readl_relaxed(pll->base);\n\tif (pll->powerup_set)\n\t\tval &= ~pll->power_bit;\n\telse\n\t\tval |= pll->power_bit;\n\twritel_relaxed(val, pll->base);\n}\n\nstatic int clk_pllv3_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_pllv3 *pll = to_clk_pllv3(hw);\n\n\tif (readl_relaxed(pll->base) & BM_PLL_LOCK)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic unsigned long clk_pllv3_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct clk_pllv3 *pll = to_clk_pllv3(hw);\n\tu32 div = (readl_relaxed(pll->base) >> pll->div_shift)  & pll->div_mask;\n\n\treturn (div == 1) ? parent_rate * 22 : parent_rate * 20;\n}\n\nstatic long clk_pllv3_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long *prate)\n{\n\tunsigned long parent_rate = *prate;\n\n\treturn (rate >= parent_rate * 22) ? parent_rate * 22 :\n\t\t\t\t\t    parent_rate * 20;\n}\n\nstatic int clk_pllv3_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_pllv3 *pll = to_clk_pllv3(hw);\n\tu32 val, div;\n\n\tif (rate == parent_rate * 22)\n\t\tdiv = 1;\n\telse if (rate == parent_rate * 20)\n\t\tdiv = 0;\n\telse\n\t\treturn -EINVAL;\n\n\tval = readl_relaxed(pll->base);\n\tval &= ~(pll->div_mask << pll->div_shift);\n\tval |= (div << pll->div_shift);\n\twritel_relaxed(val, pll->base);\n\n\treturn clk_pllv3_wait_lock(pll);\n}\n\nstatic const struct clk_ops clk_pllv3_ops = {\n\t.prepare\t= clk_pllv3_prepare,\n\t.unprepare\t= clk_pllv3_unprepare,\n\t.is_prepared\t= clk_pllv3_is_prepared,\n\t.recalc_rate\t= clk_pllv3_recalc_rate,\n\t.round_rate\t= clk_pllv3_round_rate,\n\t.set_rate\t= clk_pllv3_set_rate,\n};\n\nstatic unsigned long clk_pllv3_sys_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct clk_pllv3 *pll = to_clk_pllv3(hw);\n\tu32 div = readl_relaxed(pll->base) & pll->div_mask;\n\n\treturn parent_rate * div / 2;\n}\n\nstatic long clk_pllv3_sys_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long *prate)\n{\n\tunsigned long parent_rate = *prate;\n\tunsigned long min_rate = parent_rate * 54 / 2;\n\tunsigned long max_rate = parent_rate * 108 / 2;\n\tu32 div;\n\n\tif (rate > max_rate)\n\t\trate = max_rate;\n\telse if (rate < min_rate)\n\t\trate = min_rate;\n\tdiv = rate * 2 / parent_rate;\n\n\treturn parent_rate * div / 2;\n}\n\nstatic int clk_pllv3_sys_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_pllv3 *pll = to_clk_pllv3(hw);\n\tunsigned long min_rate = parent_rate * 54 / 2;\n\tunsigned long max_rate = parent_rate * 108 / 2;\n\tu32 val, div;\n\n\tif (rate < min_rate || rate > max_rate)\n\t\treturn -EINVAL;\n\n\tdiv = rate * 2 / parent_rate;\n\tval = readl_relaxed(pll->base);\n\tval &= ~pll->div_mask;\n\tval |= div;\n\twritel_relaxed(val, pll->base);\n\n\treturn clk_pllv3_wait_lock(pll);\n}\n\nstatic const struct clk_ops clk_pllv3_sys_ops = {\n\t.prepare\t= clk_pllv3_prepare,\n\t.unprepare\t= clk_pllv3_unprepare,\n\t.is_prepared\t= clk_pllv3_is_prepared,\n\t.recalc_rate\t= clk_pllv3_sys_recalc_rate,\n\t.round_rate\t= clk_pllv3_sys_round_rate,\n\t.set_rate\t= clk_pllv3_sys_set_rate,\n};\n\nstatic unsigned long clk_pllv3_av_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct clk_pllv3 *pll = to_clk_pllv3(hw);\n\tu32 mfn = readl_relaxed(pll->base + pll->num_offset);\n\tu32 mfd = readl_relaxed(pll->base + pll->denom_offset);\n\tu32 div = readl_relaxed(pll->base) & pll->div_mask;\n\tu64 temp64 = (u64)parent_rate;\n\n\ttemp64 *= mfn;\n\tdo_div(temp64, mfd);\n\n\treturn parent_rate * div + (unsigned long)temp64;\n}\n\nstatic long clk_pllv3_av_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *prate)\n{\n\tunsigned long parent_rate = *prate;\n\tunsigned long min_rate = parent_rate * 27;\n\tunsigned long max_rate = parent_rate * 54;\n\tu32 div;\n\tu32 mfn, mfd = 1000000;\n\tu32 max_mfd = 0x3FFFFFFF;\n\tu64 temp64;\n\n\tif (rate > max_rate)\n\t\trate = max_rate;\n\telse if (rate < min_rate)\n\t\trate = min_rate;\n\n\tif (parent_rate <= max_mfd)\n\t\tmfd = parent_rate;\n\n\tdiv = rate / parent_rate;\n\ttemp64 = (u64) (rate - div * parent_rate);\n\ttemp64 *= mfd;\n\ttemp64 = div64_ul(temp64, parent_rate);\n\tmfn = temp64;\n\n\ttemp64 = (u64)parent_rate;\n\ttemp64 *= mfn;\n\tdo_div(temp64, mfd);\n\n\treturn parent_rate * div + (unsigned long)temp64;\n}\n\nstatic int clk_pllv3_av_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_pllv3 *pll = to_clk_pllv3(hw);\n\tunsigned long min_rate = parent_rate * 27;\n\tunsigned long max_rate = parent_rate * 54;\n\tu32 val, div;\n\tu32 mfn, mfd = 1000000;\n\tu32 max_mfd = 0x3FFFFFFF;\n\tu64 temp64;\n\n\tif (rate < min_rate || rate > max_rate)\n\t\treturn -EINVAL;\n\n\tif (parent_rate <= max_mfd)\n\t\tmfd = parent_rate;\n\n\tdiv = rate / parent_rate;\n\ttemp64 = (u64) (rate - div * parent_rate);\n\ttemp64 *= mfd;\n\ttemp64 = div64_ul(temp64, parent_rate);\n\tmfn = temp64;\n\n\tval = readl_relaxed(pll->base);\n\tval &= ~pll->div_mask;\n\tval |= div;\n\twritel_relaxed(val, pll->base);\n\twritel_relaxed(mfn, pll->base + pll->num_offset);\n\twritel_relaxed(mfd, pll->base + pll->denom_offset);\n\n\treturn clk_pllv3_wait_lock(pll);\n}\n\nstatic const struct clk_ops clk_pllv3_av_ops = {\n\t.prepare\t= clk_pllv3_prepare,\n\t.unprepare\t= clk_pllv3_unprepare,\n\t.is_prepared\t= clk_pllv3_is_prepared,\n\t.recalc_rate\t= clk_pllv3_av_recalc_rate,\n\t.round_rate\t= clk_pllv3_av_round_rate,\n\t.set_rate\t= clk_pllv3_av_set_rate,\n};\n\nstruct clk_pllv3_vf610_mf {\n\tu32 mfi;\t \n\tu32 mfn;\t \n\tu32 mfd;\t \n};\n\nstatic unsigned long clk_pllv3_vf610_mf_to_rate(unsigned long parent_rate,\n\t\tstruct clk_pllv3_vf610_mf mf)\n{\n\tu64 temp64;\n\n\ttemp64 = parent_rate;\n\ttemp64 *= mf.mfn;\n\tdo_div(temp64, mf.mfd);\n\n\treturn (parent_rate * mf.mfi) + temp64;\n}\n\nstatic struct clk_pllv3_vf610_mf clk_pllv3_vf610_rate_to_mf(\n\t\tunsigned long parent_rate, unsigned long rate)\n{\n\tstruct clk_pllv3_vf610_mf mf;\n\tu64 temp64;\n\n\tmf.mfi = (rate >= 22 * parent_rate) ? 22 : 20;\n\tmf.mfd = 0x3fffffff;\t \n\n\tif (rate <= parent_rate * mf.mfi)\n\t\tmf.mfn = 0;\n\telse if (rate >= parent_rate * (mf.mfi + 1))\n\t\tmf.mfn = mf.mfd - 1;\n\telse {\n\t\t \n\t\ttemp64 = rate - parent_rate * mf.mfi;\n\t\ttemp64 *= mf.mfd;\n\t\ttemp64 = div64_ul(temp64, parent_rate);\n\t\tmf.mfn = temp64;\n\t}\n\n\treturn mf;\n}\n\nstatic unsigned long clk_pllv3_vf610_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct clk_pllv3 *pll = to_clk_pllv3(hw);\n\tstruct clk_pllv3_vf610_mf mf;\n\n\tmf.mfn = readl_relaxed(pll->base + pll->num_offset);\n\tmf.mfd = readl_relaxed(pll->base + pll->denom_offset);\n\tmf.mfi = (readl_relaxed(pll->base) & pll->div_mask) ? 22 : 20;\n\n\treturn clk_pllv3_vf610_mf_to_rate(parent_rate, mf);\n}\n\nstatic long clk_pllv3_vf610_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *prate)\n{\n\tstruct clk_pllv3_vf610_mf mf = clk_pllv3_vf610_rate_to_mf(*prate, rate);\n\n\treturn clk_pllv3_vf610_mf_to_rate(*prate, mf);\n}\n\nstatic int clk_pllv3_vf610_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct clk_pllv3 *pll = to_clk_pllv3(hw);\n\tstruct clk_pllv3_vf610_mf mf =\n\t\t\tclk_pllv3_vf610_rate_to_mf(parent_rate, rate);\n\tu32 val;\n\n\tval = readl_relaxed(pll->base);\n\tif (mf.mfi == 20)\n\t\tval &= ~pll->div_mask;\t \n\telse\n\t\tval |= pll->div_mask;\t \n\twritel_relaxed(val, pll->base);\n\n\twritel_relaxed(mf.mfn, pll->base + pll->num_offset);\n\twritel_relaxed(mf.mfd, pll->base + pll->denom_offset);\n\n\treturn clk_pllv3_wait_lock(pll);\n}\n\nstatic const struct clk_ops clk_pllv3_vf610_ops = {\n\t.prepare\t= clk_pllv3_prepare,\n\t.unprepare\t= clk_pllv3_unprepare,\n\t.is_prepared\t= clk_pllv3_is_prepared,\n\t.recalc_rate\t= clk_pllv3_vf610_recalc_rate,\n\t.round_rate\t= clk_pllv3_vf610_round_rate,\n\t.set_rate\t= clk_pllv3_vf610_set_rate,\n};\n\nstatic unsigned long clk_pllv3_enet_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_pllv3 *pll = to_clk_pllv3(hw);\n\n\treturn pll->ref_clock;\n}\n\nstatic const struct clk_ops clk_pllv3_enet_ops = {\n\t.prepare\t= clk_pllv3_prepare,\n\t.unprepare\t= clk_pllv3_unprepare,\n\t.is_prepared\t= clk_pllv3_is_prepared,\n\t.recalc_rate\t= clk_pllv3_enet_recalc_rate,\n};\n\nstruct clk_hw *imx_clk_hw_pllv3(enum imx_pllv3_type type, const char *name,\n\t\t\t  const char *parent_name, void __iomem *base,\n\t\t\t  u32 div_mask)\n{\n\tstruct clk_pllv3 *pll;\n\tconst struct clk_ops *ops;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tpll = kzalloc(sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpll->power_bit = BM_PLL_POWER;\n\tpll->num_offset = PLL_NUM_OFFSET;\n\tpll->denom_offset = PLL_DENOM_OFFSET;\n\n\tswitch (type) {\n\tcase IMX_PLLV3_SYS:\n\t\tops = &clk_pllv3_sys_ops;\n\t\tbreak;\n\tcase IMX_PLLV3_SYS_VF610:\n\t\tops = &clk_pllv3_vf610_ops;\n\t\tpll->num_offset = PLL_VF610_NUM_OFFSET;\n\t\tpll->denom_offset = PLL_VF610_DENOM_OFFSET;\n\t\tbreak;\n\tcase IMX_PLLV3_USB_VF610:\n\t\tpll->div_shift = 1;\n\t\tfallthrough;\n\tcase IMX_PLLV3_USB:\n\t\tops = &clk_pllv3_ops;\n\t\tpll->powerup_set = true;\n\t\tbreak;\n\tcase IMX_PLLV3_AV_IMX7:\n\t\tpll->num_offset = PLL_IMX7_NUM_OFFSET;\n\t\tpll->denom_offset = PLL_IMX7_DENOM_OFFSET;\n\t\tfallthrough;\n\tcase IMX_PLLV3_AV:\n\t\tops = &clk_pllv3_av_ops;\n\t\tbreak;\n\tcase IMX_PLLV3_ENET_IMX7:\n\t\tpll->power_bit = IMX7_ENET_PLL_POWER;\n\t\tpll->ref_clock = 1000000000;\n\t\tops = &clk_pllv3_enet_ops;\n\t\tbreak;\n\tcase IMX_PLLV3_ENET:\n\t\tpll->ref_clock = 500000000;\n\t\tops = &clk_pllv3_enet_ops;\n\t\tbreak;\n\tcase IMX_PLLV3_DDR_IMX7:\n\t\tpll->power_bit = IMX7_DDR_PLL_POWER;\n\t\tpll->num_offset = PLL_IMX7_NUM_OFFSET;\n\t\tpll->denom_offset = PLL_IMX7_DENOM_OFFSET;\n\t\tops = &clk_pllv3_av_ops;\n\t\tbreak;\n\tdefault:\n\t\tops = &clk_pllv3_ops;\n\t}\n\tpll->base = base;\n\tpll->div_mask = div_mask;\n\n\tinit.name = name;\n\tinit.ops = ops;\n\tinit.flags = 0;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\n\tpll->hw.init = &init;\n\thw = &pll->hw;\n\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(pll);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(imx_clk_hw_pllv3);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}