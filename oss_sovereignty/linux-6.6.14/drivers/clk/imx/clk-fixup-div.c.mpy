{
  "module_name": "clk-fixup-div.c",
  "hash_id": "79503277682016929c8c75d847c01ee011f29207d9ad53ea9d64a4838eb51538",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-fixup-div.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include \"clk.h\"\n\n#define div_mask(d)\t((1 << (d->width)) - 1)\n\n \nstruct clk_fixup_div {\n\tstruct clk_divider divider;\n\tconst struct clk_ops *ops;\n\tvoid (*fixup)(u32 *val);\n};\n\nstatic inline struct clk_fixup_div *to_clk_fixup_div(struct clk_hw *hw)\n{\n\tstruct clk_divider *divider = to_clk_divider(hw);\n\n\treturn container_of(divider, struct clk_fixup_div, divider);\n}\n\nstatic unsigned long clk_fixup_div_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_fixup_div *fixup_div = to_clk_fixup_div(hw);\n\n\treturn fixup_div->ops->recalc_rate(&fixup_div->divider.hw, parent_rate);\n}\n\nstatic long clk_fixup_div_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *prate)\n{\n\tstruct clk_fixup_div *fixup_div = to_clk_fixup_div(hw);\n\n\treturn fixup_div->ops->round_rate(&fixup_div->divider.hw, rate, prate);\n}\n\nstatic int clk_fixup_div_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct clk_fixup_div *fixup_div = to_clk_fixup_div(hw);\n\tstruct clk_divider *div = to_clk_divider(hw);\n\tunsigned int divider, value;\n\tunsigned long flags;\n\tu32 val;\n\n\tdivider = parent_rate / rate;\n\n\t \n\tvalue = divider - 1;\n\n\tif (value > div_mask(div))\n\t\tvalue = div_mask(div);\n\n\tspin_lock_irqsave(div->lock, flags);\n\n\tval = readl(div->reg);\n\tval &= ~(div_mask(div) << div->shift);\n\tval |= value << div->shift;\n\tfixup_div->fixup(&val);\n\twritel(val, div->reg);\n\n\tspin_unlock_irqrestore(div->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_fixup_div_ops = {\n\t.recalc_rate = clk_fixup_div_recalc_rate,\n\t.round_rate = clk_fixup_div_round_rate,\n\t.set_rate = clk_fixup_div_set_rate,\n};\n\nstruct clk_hw *imx_clk_hw_fixup_divider(const char *name, const char *parent,\n\t\t\t\t  void __iomem *reg, u8 shift, u8 width,\n\t\t\t\t  void (*fixup)(u32 *val))\n{\n\tstruct clk_fixup_div *fixup_div;\n\tstruct clk_hw *hw;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tif (!fixup)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfixup_div = kzalloc(sizeof(*fixup_div), GFP_KERNEL);\n\tif (!fixup_div)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &clk_fixup_div_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = parent ? &parent : NULL;\n\tinit.num_parents = parent ? 1 : 0;\n\n\tfixup_div->divider.reg = reg;\n\tfixup_div->divider.shift = shift;\n\tfixup_div->divider.width = width;\n\tfixup_div->divider.lock = &imx_ccm_lock;\n\tfixup_div->divider.hw.init = &init;\n\tfixup_div->ops = &clk_divider_ops;\n\tfixup_div->fixup = fixup;\n\n\thw = &fixup_div->divider.hw;\n\n\tret = clk_hw_register(NULL, hw);\n\tif (ret) {\n\t\tkfree(fixup_div);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}