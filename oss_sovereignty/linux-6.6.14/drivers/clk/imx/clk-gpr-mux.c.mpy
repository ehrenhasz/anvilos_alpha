{
  "module_name": "clk-gpr-mux.c",
  "hash_id": "c1a045fa8c27ea9470a7baf3b60bcab4f76cfe304a2a991104ca58a047ee57c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-gpr-mux.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"imx:clk-gpr-mux: \" fmt\n\n#include <linux/module.h>\n\n#include <linux/clk-provider.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n\n#include \"clk.h\"\n\nstruct imx_clk_gpr {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tu32 mask;\n\tu32 reg;\n\tconst u32 *mux_table;\n};\n\nstatic struct imx_clk_gpr *to_imx_clk_gpr(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct imx_clk_gpr, hw);\n}\n\nstatic u8 imx_clk_gpr_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct imx_clk_gpr *priv = to_imx_clk_gpr(hw);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, priv->reg, &val);\n\tif (ret)\n\t\tgoto get_parent_err;\n\n\tval &= priv->mask;\n\n\tret = clk_mux_val_to_index(hw, priv->mux_table, 0, val);\n\tif (ret < 0)\n\t\tgoto get_parent_err;\n\n\treturn ret;\n\nget_parent_err:\n\tpr_err(\"%s: failed to get parent (%pe)\\n\",\n\t       clk_hw_get_name(hw), ERR_PTR(ret));\n\n\t \n\treturn 0;\n}\n\nstatic int imx_clk_gpr_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct imx_clk_gpr *priv = to_imx_clk_gpr(hw);\n\tunsigned int val = clk_mux_index_to_val(priv->mux_table, 0, index);\n\n\treturn regmap_update_bits(priv->regmap, priv->reg, priv->mask, val);\n}\n\nstatic const struct clk_ops imx_clk_gpr_mux_ops = {\n\t.get_parent = imx_clk_gpr_mux_get_parent,\n\t.set_parent = imx_clk_gpr_mux_set_parent,\n\t.determine_rate = __clk_mux_determine_rate,\n};\n\nstruct clk_hw *imx_clk_gpr_mux(const char *name, const char *compatible,\n\t\t\t       u32 reg, const char **parent_names,\n\t\t\t       u8 num_parents, const u32 *mux_table, u32 mask)\n{\n\tstruct clk_init_data init  = { };\n\tstruct imx_clk_gpr *priv;\n\tstruct regmap *regmap;\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tregmap = syscon_regmap_lookup_by_compatible(compatible);\n\tif (IS_ERR(regmap)) {\n\t\tpr_err(\"failed to find %s regmap\\n\", compatible);\n\t\treturn ERR_CAST(regmap);\n\t}\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &imx_clk_gpr_mux_ops;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = num_parents;\n\tinit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\n\n\tpriv->hw.init = &init;\n\tpriv->regmap = regmap;\n\tpriv->mux_table = mux_table;\n\tpriv->reg = reg;\n\tpriv->mask = mask;\n\n\thw = &priv->hw;\n\tret = clk_hw_register(NULL, &priv->hw);\n\tif (ret) {\n\t\tkfree(priv);\n\t\thw = ERR_PTR(ret);\n\t}\n\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}