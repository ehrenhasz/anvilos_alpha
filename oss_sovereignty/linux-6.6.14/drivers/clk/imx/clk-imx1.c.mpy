{
  "module_name": "clk-imx1.c",
  "hash_id": "fe7b2cba893e15ae93d2ce467c9b0901dd097c8ce2d91c748299b7acb898a3a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-imx1.c",
  "human_readable_source": "\n \n\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <dt-bindings/clock/imx1-clock.h>\n#include <asm/irq.h>\n\n#include \"clk.h\"\n\n#define MX1_CCM_BASE_ADDR\t0x0021b000\n#define MX1_TIM1_BASE_ADDR\t0x00220000\n#define MX1_TIM1_INT\t\t(NR_IRQS_LEGACY + 59)\n\nstatic const char *prem_sel_clks[] = { \"clk32_premult\", \"clk16m\", };\nstatic const char *clko_sel_clks[] = { \"per1\", \"hclk\", \"clk48m\", \"clk16m\",\n\t\t\t\t       \"prem\", \"fclk\", };\n\nstatic struct clk *clk[IMX1_CLK_MAX];\nstatic struct clk_onecell_data clk_data;\n\nstatic void __iomem *ccm __initdata;\n#define CCM_CSCR\t(ccm + 0x0000)\n#define CCM_MPCTL0\t(ccm + 0x0004)\n#define CCM_SPCTL0\t(ccm + 0x000c)\n#define CCM_PCDR\t(ccm + 0x0020)\n#define SCM_GCCR\t(ccm + 0x0810)\n\nstatic void __init mx1_clocks_init_dt(struct device_node *np)\n{\n\tccm = of_iomap(np, 0);\n\tBUG_ON(!ccm);\n\n\tclk[IMX1_CLK_DUMMY] = imx_clk_fixed(\"dummy\", 0);\n\tclk[IMX1_CLK_CLK32] = imx_obtain_fixed_clock(\"clk32\", 32768);\n\tclk[IMX1_CLK_CLK16M_EXT] = imx_clk_fixed(\"clk16m_ext\", 16000000);\n\tclk[IMX1_CLK_CLK16M] = imx_clk_gate(\"clk16m\", \"clk16m_ext\", CCM_CSCR, 17);\n\tclk[IMX1_CLK_CLK32_PREMULT] = imx_clk_fixed_factor(\"clk32_premult\", \"clk32\", 512, 1);\n\tclk[IMX1_CLK_PREM] = imx_clk_mux(\"prem\", CCM_CSCR, 16, 1, prem_sel_clks, ARRAY_SIZE(prem_sel_clks));\n\tclk[IMX1_CLK_MPLL] = imx_clk_pllv1(IMX_PLLV1_IMX1, \"mpll\", \"clk32_premult\", CCM_MPCTL0);\n\tclk[IMX1_CLK_MPLL_GATE] = imx_clk_gate(\"mpll_gate\", \"mpll\", CCM_CSCR, 0);\n\tclk[IMX1_CLK_SPLL] = imx_clk_pllv1(IMX_PLLV1_IMX1, \"spll\", \"prem\", CCM_SPCTL0);\n\tclk[IMX1_CLK_SPLL_GATE] = imx_clk_gate(\"spll_gate\", \"spll\", CCM_CSCR, 1);\n\tclk[IMX1_CLK_MCU] = imx_clk_divider(\"mcu\", \"clk32_premult\", CCM_CSCR, 15, 1);\n\tclk[IMX1_CLK_FCLK] = imx_clk_divider(\"fclk\", \"mpll_gate\", CCM_CSCR, 15, 1);\n\tclk[IMX1_CLK_HCLK] = imx_clk_divider(\"hclk\", \"spll_gate\", CCM_CSCR, 10, 4);\n\tclk[IMX1_CLK_CLK48M] = imx_clk_divider(\"clk48m\", \"spll_gate\", CCM_CSCR, 26, 3);\n\tclk[IMX1_CLK_PER1] = imx_clk_divider(\"per1\", \"spll_gate\", CCM_PCDR, 0, 4);\n\tclk[IMX1_CLK_PER2] = imx_clk_divider(\"per2\", \"spll_gate\", CCM_PCDR, 4, 4);\n\tclk[IMX1_CLK_PER3] = imx_clk_divider(\"per3\", \"spll_gate\", CCM_PCDR, 16, 7);\n\tclk[IMX1_CLK_CLKO] = imx_clk_mux(\"clko\", CCM_CSCR, 29, 3, clko_sel_clks, ARRAY_SIZE(clko_sel_clks));\n\tclk[IMX1_CLK_UART3_GATE] = imx_clk_gate(\"uart3_gate\", \"hclk\", SCM_GCCR, 6);\n\tclk[IMX1_CLK_SSI2_GATE] = imx_clk_gate(\"ssi2_gate\", \"hclk\", SCM_GCCR, 5);\n\tclk[IMX1_CLK_BROM_GATE] = imx_clk_gate(\"brom_gate\", \"hclk\", SCM_GCCR, 4);\n\tclk[IMX1_CLK_DMA_GATE] = imx_clk_gate(\"dma_gate\", \"hclk\", SCM_GCCR, 3);\n\tclk[IMX1_CLK_CSI_GATE] = imx_clk_gate(\"csi_gate\", \"hclk\", SCM_GCCR, 2);\n\tclk[IMX1_CLK_MMA_GATE] = imx_clk_gate(\"mma_gate\", \"hclk\", SCM_GCCR, 1);\n\tclk[IMX1_CLK_USBD_GATE] = imx_clk_gate(\"usbd_gate\", \"clk48m\", SCM_GCCR, 0);\n\n\timx_check_clocks(clk, ARRAY_SIZE(clk));\n\n\tclk_data.clks = clk;\n\tclk_data.clk_num = ARRAY_SIZE(clk);\n\tof_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);\n}\nCLK_OF_DECLARE(imx1_ccm, \"fsl,imx1-ccm\", mx1_clocks_init_dt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}