{
  "module_name": "clk-imx35.c",
  "hash_id": "314b8cf2738da2678ff55730802eeafd5ad4c2c69c1927f008a8ca17e028c637",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/imx/clk-imx35.c",
  "human_readable_source": "\n \n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/clkdev.h>\n#include <linux/of.h>\n#include <linux/err.h>\n#include <soc/imx/revision.h>\n#include <asm/irq.h>\n\n#include \"clk.h\"\n\n#define MX35_CCM_BASE_ADDR\t0x53f80000\n#define MX35_GPT1_BASE_ADDR\t0x53f90000\n#define MX35_INT_GPT\t\t(NR_IRQS_LEGACY + 29)\n\n#define MXC_CCM_PDR0\t\t0x04\n#define MX35_CCM_PDR2\t\t0x0c\n#define MX35_CCM_PDR3\t\t0x10\n#define MX35_CCM_PDR4\t\t0x14\n#define MX35_CCM_MPCTL\t\t0x1c\n#define MX35_CCM_PPCTL\t\t0x20\n#define MX35_CCM_CGR0\t\t0x2c\n#define MX35_CCM_CGR1\t\t0x30\n#define MX35_CCM_CGR2\t\t0x34\n#define MX35_CCM_CGR3\t\t0x38\n\nstruct arm_ahb_div {\n\tunsigned char arm, ahb, sel;\n};\n\nstatic struct arm_ahb_div clk_consumer[] = {\n\t{ .arm = 1, .ahb = 4, .sel = 0},\n\t{ .arm = 1, .ahb = 3, .sel = 1},\n\t{ .arm = 2, .ahb = 2, .sel = 0},\n\t{ .arm = 0, .ahb = 0, .sel = 0},\n\t{ .arm = 0, .ahb = 0, .sel = 0},\n\t{ .arm = 0, .ahb = 0, .sel = 0},\n\t{ .arm = 4, .ahb = 1, .sel = 0},\n\t{ .arm = 1, .ahb = 5, .sel = 0},\n\t{ .arm = 1, .ahb = 8, .sel = 0},\n\t{ .arm = 1, .ahb = 6, .sel = 1},\n\t{ .arm = 2, .ahb = 4, .sel = 0},\n\t{ .arm = 0, .ahb = 0, .sel = 0},\n\t{ .arm = 0, .ahb = 0, .sel = 0},\n\t{ .arm = 0, .ahb = 0, .sel = 0},\n\t{ .arm = 4, .ahb = 2, .sel = 0},\n\t{ .arm = 0, .ahb = 0, .sel = 0},\n};\n\nstatic char hsp_div_532[] = { 4, 8, 3, 0 };\nstatic char hsp_div_400[] = { 3, 6, 3, 0 };\n\nstatic struct clk_onecell_data clk_data;\n\nstatic const char *std_sel[] = {\"ppll\", \"arm\"};\nstatic const char *ipg_per_sel[] = {\"ahb_per_div\", \"arm_per_div\"};\n\nenum mx35_clks {\n\t  ckih, mpll, ppll, mpll_075, arm, hsp, hsp_div, hsp_sel, ahb,\n\t  ipg, arm_per_div, ahb_per_div, ipg_per, uart_sel, uart_div,\n\t  esdhc_sel, esdhc1_div, esdhc2_div, esdhc3_div, spdif_sel,\n\t  spdif_div_pre, spdif_div_post, ssi_sel, ssi1_div_pre,\n\t  ssi1_div_post, ssi2_div_pre, ssi2_div_post, usb_sel, usb_div,\n\t  nfc_div, asrc_gate, pata_gate, audmux_gate, can1_gate,\n\t  can2_gate, cspi1_gate, cspi2_gate, ect_gate, edio_gate,\n\t  emi_gate, epit1_gate, epit2_gate, esai_gate, esdhc1_gate,\n\t  esdhc2_gate, esdhc3_gate, fec_gate, gpio1_gate, gpio2_gate,\n\t  gpio3_gate, gpt_gate, i2c1_gate, i2c2_gate, i2c3_gate,\n\t  iomuxc_gate, ipu_gate, kpp_gate, mlb_gate, mshc_gate,\n\t  owire_gate, pwm_gate, rngc_gate, rtc_gate, rtic_gate, scc_gate,\n\t  sdma_gate, spba_gate, spdif_gate, ssi1_gate, ssi2_gate,\n\t  uart1_gate, uart2_gate, uart3_gate, usbotg_gate, wdog_gate,\n\t  max_gate, admux_gate, csi_gate, csi_div, csi_sel, iim_gate,\n\t  gpu2d_gate, ckil, clk_max\n};\n\nstatic struct clk *clk[clk_max];\n\nstatic void __init _mx35_clocks_init(void)\n{\n\tvoid __iomem *base;\n\tu32 pdr0, consumer_sel, hsp_sel;\n\tstruct arm_ahb_div *aad;\n\tunsigned char *hsp_div;\n\n\tbase = ioremap(MX35_CCM_BASE_ADDR, SZ_4K);\n\tBUG_ON(!base);\n\n\tpdr0 = __raw_readl(base + MXC_CCM_PDR0);\n\tconsumer_sel = (pdr0 >> 16) & 0xf;\n\taad = &clk_consumer[consumer_sel];\n\tif (!aad->arm) {\n\t\tpr_err(\"i.MX35 clk: illegal consumer mux selection 0x%x\\n\", consumer_sel);\n\t\t \n\t\taad = &clk_consumer[0];\n\t}\n\n\tclk[ckih] = imx_clk_fixed(\"ckih\", 24000000);\n\tclk[ckil] = imx_clk_fixed(\"ckil\", 32768);\n\tclk[mpll] = imx_clk_pllv1(IMX_PLLV1_IMX35, \"mpll\", \"ckih\", base + MX35_CCM_MPCTL);\n\tclk[ppll] = imx_clk_pllv1(IMX_PLLV1_IMX35, \"ppll\", \"ckih\", base + MX35_CCM_PPCTL);\n\n\tclk[mpll] = imx_clk_fixed_factor(\"mpll_075\", \"mpll\", 3, 4);\n\n\tif (aad->sel)\n\t\tclk[arm] = imx_clk_fixed_factor(\"arm\", \"mpll_075\", 1, aad->arm);\n\telse\n\t\tclk[arm] = imx_clk_fixed_factor(\"arm\", \"mpll\", 1, aad->arm);\n\n\tif (clk_get_rate(clk[arm]) > 400000000)\n\t\thsp_div = hsp_div_532;\n\telse\n\t\thsp_div = hsp_div_400;\n\n\thsp_sel = (pdr0 >> 20) & 0x3;\n\tif (!hsp_div[hsp_sel]) {\n\t\tpr_err(\"i.MX35 clk: illegal hsp clk selection 0x%x\\n\", hsp_sel);\n\t\thsp_sel = 0;\n\t}\n\n\tclk[hsp] = imx_clk_fixed_factor(\"hsp\", \"arm\", 1, hsp_div[hsp_sel]);\n\n\tclk[ahb] = imx_clk_fixed_factor(\"ahb\", \"arm\", 1, aad->ahb);\n\tclk[ipg] = imx_clk_fixed_factor(\"ipg\", \"ahb\", 1, 2);\n\n\tclk[arm_per_div] = imx_clk_divider(\"arm_per_div\", \"arm\", base + MX35_CCM_PDR4, 16, 6);\n\tclk[ahb_per_div] = imx_clk_divider(\"ahb_per_div\", \"ahb\", base + MXC_CCM_PDR0, 12, 3);\n\tclk[ipg_per] = imx_clk_mux(\"ipg_per\", base + MXC_CCM_PDR0, 26, 1, ipg_per_sel, ARRAY_SIZE(ipg_per_sel));\n\n\tclk[uart_sel] = imx_clk_mux(\"uart_sel\", base + MX35_CCM_PDR3, 14, 1, std_sel, ARRAY_SIZE(std_sel));\n\tclk[uart_div] = imx_clk_divider(\"uart_div\", \"uart_sel\", base + MX35_CCM_PDR4, 10, 6);\n\n\tclk[esdhc_sel] = imx_clk_mux(\"esdhc_sel\", base + MX35_CCM_PDR4, 9, 1, std_sel, ARRAY_SIZE(std_sel));\n\tclk[esdhc1_div] = imx_clk_divider(\"esdhc1_div\", \"esdhc_sel\", base + MX35_CCM_PDR3, 0, 6);\n\tclk[esdhc2_div] = imx_clk_divider(\"esdhc2_div\", \"esdhc_sel\", base + MX35_CCM_PDR3, 8, 6);\n\tclk[esdhc3_div] = imx_clk_divider(\"esdhc3_div\", \"esdhc_sel\", base + MX35_CCM_PDR3, 16, 6);\n\n\tclk[spdif_sel] = imx_clk_mux(\"spdif_sel\", base + MX35_CCM_PDR3, 22, 1, std_sel, ARRAY_SIZE(std_sel));\n\tclk[spdif_div_pre] = imx_clk_divider(\"spdif_div_pre\", \"spdif_sel\", base + MX35_CCM_PDR3, 29, 3);   \n\tclk[spdif_div_post] = imx_clk_divider(\"spdif_div_post\", \"spdif_div_pre\", base + MX35_CCM_PDR3, 23, 6);\n\n\tclk[ssi_sel] = imx_clk_mux(\"ssi_sel\", base + MX35_CCM_PDR2, 6, 1, std_sel, ARRAY_SIZE(std_sel));\n\tclk[ssi1_div_pre] = imx_clk_divider(\"ssi1_div_pre\", \"ssi_sel\", base + MX35_CCM_PDR2, 24, 3);\n\tclk[ssi1_div_post] = imx_clk_divider(\"ssi1_div_post\", \"ssi1_div_pre\", base + MX35_CCM_PDR2, 0, 6);\n\tclk[ssi2_div_pre] = imx_clk_divider(\"ssi2_div_pre\", \"ssi_sel\", base + MX35_CCM_PDR2, 27, 3);\n\tclk[ssi2_div_post] = imx_clk_divider(\"ssi2_div_post\", \"ssi2_div_pre\", base + MX35_CCM_PDR2, 8, 6);\n\n\tclk[usb_sel] = imx_clk_mux(\"usb_sel\", base + MX35_CCM_PDR4, 9, 1, std_sel, ARRAY_SIZE(std_sel));\n\tclk[usb_div] = imx_clk_divider(\"usb_div\", \"usb_sel\", base + MX35_CCM_PDR4, 22, 6);\n\n\tclk[nfc_div] = imx_clk_divider(\"nfc_div\", \"ahb\", base + MX35_CCM_PDR4, 28, 4);\n\n\tclk[csi_sel] = imx_clk_mux(\"csi_sel\", base + MX35_CCM_PDR2, 7, 1, std_sel, ARRAY_SIZE(std_sel));\n\tclk[csi_div] = imx_clk_divider(\"csi_div\", \"csi_sel\", base + MX35_CCM_PDR2, 16, 6);\n\n\tclk[asrc_gate] = imx_clk_gate2(\"asrc_gate\", \"ipg\", base + MX35_CCM_CGR0,  0);\n\tclk[pata_gate] = imx_clk_gate2(\"pata_gate\", \"ipg\", base + MX35_CCM_CGR0,  2);\n\tclk[audmux_gate] = imx_clk_gate2(\"audmux_gate\", \"ipg\", base + MX35_CCM_CGR0,  4);\n\tclk[can1_gate] = imx_clk_gate2(\"can1_gate\", \"ipg\", base + MX35_CCM_CGR0,  6);\n\tclk[can2_gate] = imx_clk_gate2(\"can2_gate\", \"ipg\", base + MX35_CCM_CGR0,  8);\n\tclk[cspi1_gate] = imx_clk_gate2(\"cspi1_gate\", \"ipg\", base + MX35_CCM_CGR0, 10);\n\tclk[cspi2_gate] = imx_clk_gate2(\"cspi2_gate\", \"ipg\", base + MX35_CCM_CGR0, 12);\n\tclk[ect_gate] = imx_clk_gate2(\"ect_gate\", \"ipg\", base + MX35_CCM_CGR0, 14);\n\tclk[edio_gate] = imx_clk_gate2(\"edio_gate\",   \"ipg\", base + MX35_CCM_CGR0, 16);\n\tclk[emi_gate] = imx_clk_gate2(\"emi_gate\", \"ipg\", base + MX35_CCM_CGR0, 18);\n\tclk[epit1_gate] = imx_clk_gate2(\"epit1_gate\", \"ipg\", base + MX35_CCM_CGR0, 20);\n\tclk[epit2_gate] = imx_clk_gate2(\"epit2_gate\", \"ipg\", base + MX35_CCM_CGR0, 22);\n\tclk[esai_gate] = imx_clk_gate2(\"esai_gate\",   \"ipg\", base + MX35_CCM_CGR0, 24);\n\tclk[esdhc1_gate] = imx_clk_gate2(\"esdhc1_gate\", \"esdhc1_div\", base + MX35_CCM_CGR0, 26);\n\tclk[esdhc2_gate] = imx_clk_gate2(\"esdhc2_gate\", \"esdhc2_div\", base + MX35_CCM_CGR0, 28);\n\tclk[esdhc3_gate] = imx_clk_gate2(\"esdhc3_gate\", \"esdhc3_div\", base + MX35_CCM_CGR0, 30);\n\n\tclk[fec_gate] = imx_clk_gate2(\"fec_gate\", \"ipg\", base + MX35_CCM_CGR1,  0);\n\tclk[gpio1_gate] = imx_clk_gate2(\"gpio1_gate\", \"ipg\", base + MX35_CCM_CGR1,  2);\n\tclk[gpio2_gate] = imx_clk_gate2(\"gpio2_gate\", \"ipg\", base + MX35_CCM_CGR1,  4);\n\tclk[gpio3_gate] = imx_clk_gate2(\"gpio3_gate\", \"ipg\", base + MX35_CCM_CGR1,  6);\n\tclk[gpt_gate] = imx_clk_gate2(\"gpt_gate\", \"ipg\", base + MX35_CCM_CGR1,  8);\n\tclk[i2c1_gate] = imx_clk_gate2(\"i2c1_gate\", \"ipg_per\", base + MX35_CCM_CGR1, 10);\n\tclk[i2c2_gate] = imx_clk_gate2(\"i2c2_gate\", \"ipg_per\", base + MX35_CCM_CGR1, 12);\n\tclk[i2c3_gate] = imx_clk_gate2(\"i2c3_gate\", \"ipg_per\", base + MX35_CCM_CGR1, 14);\n\tclk[iomuxc_gate] = imx_clk_gate2(\"iomuxc_gate\", \"ipg\", base + MX35_CCM_CGR1, 16);\n\tclk[ipu_gate] = imx_clk_gate2(\"ipu_gate\", \"hsp\", base + MX35_CCM_CGR1, 18);\n\tclk[kpp_gate] = imx_clk_gate2(\"kpp_gate\", \"ipg\", base + MX35_CCM_CGR1, 20);\n\tclk[mlb_gate] = imx_clk_gate2(\"mlb_gate\", \"ahb\", base + MX35_CCM_CGR1, 22);\n\tclk[mshc_gate] = imx_clk_gate2(\"mshc_gate\", \"dummy\", base + MX35_CCM_CGR1, 24);\n\tclk[owire_gate] = imx_clk_gate2(\"owire_gate\", \"ipg_per\", base + MX35_CCM_CGR1, 26);\n\tclk[pwm_gate] = imx_clk_gate2(\"pwm_gate\", \"ipg_per\", base + MX35_CCM_CGR1, 28);\n\tclk[rngc_gate] = imx_clk_gate2(\"rngc_gate\", \"ipg\", base + MX35_CCM_CGR1, 30);\n\n\tclk[rtc_gate] = imx_clk_gate2(\"rtc_gate\", \"ipg\", base + MX35_CCM_CGR2,  0);\n\tclk[rtic_gate] = imx_clk_gate2(\"rtic_gate\", \"ahb\", base + MX35_CCM_CGR2,  2);\n\tclk[scc_gate] = imx_clk_gate2(\"scc_gate\", \"ipg\", base + MX35_CCM_CGR2,  4);\n\tclk[sdma_gate] = imx_clk_gate2(\"sdma_gate\", \"ahb\", base + MX35_CCM_CGR2,  6);\n\tclk[spba_gate] = imx_clk_gate2(\"spba_gate\", \"ipg\", base + MX35_CCM_CGR2,  8);\n\tclk[spdif_gate] = imx_clk_gate2(\"spdif_gate\", \"spdif_div_post\", base + MX35_CCM_CGR2, 10);\n\tclk[ssi1_gate] = imx_clk_gate2(\"ssi1_gate\", \"ssi1_div_post\", base + MX35_CCM_CGR2, 12);\n\tclk[ssi2_gate] = imx_clk_gate2(\"ssi2_gate\", \"ssi2_div_post\", base + MX35_CCM_CGR2, 14);\n\tclk[uart1_gate] = imx_clk_gate2(\"uart1_gate\", \"uart_div\", base + MX35_CCM_CGR2, 16);\n\tclk[uart2_gate] = imx_clk_gate2(\"uart2_gate\", \"uart_div\", base + MX35_CCM_CGR2, 18);\n\tclk[uart3_gate] = imx_clk_gate2(\"uart3_gate\", \"uart_div\", base + MX35_CCM_CGR2, 20);\n\tclk[usbotg_gate] = imx_clk_gate2(\"usbotg_gate\", \"ahb\", base + MX35_CCM_CGR2, 22);\n\tclk[wdog_gate] = imx_clk_gate2(\"wdog_gate\", \"ipg\", base + MX35_CCM_CGR2, 24);\n\tclk[max_gate] = imx_clk_gate2(\"max_gate\", \"dummy\", base + MX35_CCM_CGR2, 26);\n\tclk[admux_gate] = imx_clk_gate2(\"admux_gate\", \"ipg\", base + MX35_CCM_CGR2, 30);\n\n\tclk[csi_gate] = imx_clk_gate2(\"csi_gate\", \"csi_div\", base + MX35_CCM_CGR3,  0);\n\tclk[iim_gate] = imx_clk_gate2(\"iim_gate\", \"ipg\", base + MX35_CCM_CGR3,  2);\n\tclk[gpu2d_gate] = imx_clk_gate2(\"gpu2d_gate\", \"ahb\", base + MX35_CCM_CGR3,  4);\n\n\timx_check_clocks(clk, ARRAY_SIZE(clk));\n\n\tclk_prepare_enable(clk[spba_gate]);\n\tclk_prepare_enable(clk[gpio1_gate]);\n\tclk_prepare_enable(clk[gpio2_gate]);\n\tclk_prepare_enable(clk[gpio3_gate]);\n\tclk_prepare_enable(clk[iim_gate]);\n\tclk_prepare_enable(clk[emi_gate]);\n\tclk_prepare_enable(clk[max_gate]);\n\tclk_prepare_enable(clk[iomuxc_gate]);\n\n\t \n\tclk_prepare_enable(clk[scc_gate]);\n\n\timx_register_uart_clocks();\n\n\timx_print_silicon_rev(\"i.MX35\", mx35_revision());\n}\n\nstatic void __init mx35_clocks_init_dt(struct device_node *ccm_node)\n{\n\t_mx35_clocks_init();\n\n\tclk_data.clks = clk;\n\tclk_data.clk_num = ARRAY_SIZE(clk);\n\tof_clk_add_provider(ccm_node, of_clk_src_onecell_get, &clk_data);\n}\nCLK_OF_DECLARE(imx35, \"fsl,imx35-ccm\", mx35_clocks_init_dt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}