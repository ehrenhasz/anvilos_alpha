{
  "module_name": "clk-max9485.c",
  "hash_id": "3f7dd7a358664bff027f1c69f60420bc8eae782660d3f9defb691ed6d0180c4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-max9485.c",
  "human_readable_source": "\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/regulator/consumer.h>\n\n#include <dt-bindings/clock/maxim,max9485.h>\n\n#define MAX9485_NUM_CLKS 4\n\n \n\n#define MAX9485_FS_12KHZ\t(0 << 0)\n#define MAX9485_FS_32KHZ\t(1 << 0)\n#define MAX9485_FS_44_1KHZ\t(2 << 0)\n#define MAX9485_FS_48KHZ\t(3 << 0)\n\n#define MAX9485_SCALE_256\t(0 << 2)\n#define MAX9485_SCALE_384\t(1 << 2)\n#define MAX9485_SCALE_768\t(2 << 2)\n\n#define MAX9485_DOUBLE\t\tBIT(4)\n#define MAX9485_CLKOUT1_ENABLE\tBIT(5)\n#define MAX9485_CLKOUT2_ENABLE\tBIT(6)\n#define MAX9485_MCLK_ENABLE\tBIT(7)\n#define MAX9485_FREQ_MASK\t0x1f\n\nstruct max9485_rate {\n\tunsigned long out;\n\tu8 reg_value;\n};\n\n \nstatic const struct max9485_rate max9485_rates[] = {\n\t{  3072000, MAX9485_FS_12KHZ   | MAX9485_SCALE_256 },\n\t{  4608000, MAX9485_FS_12KHZ   | MAX9485_SCALE_384 },\n\t{  8192000, MAX9485_FS_32KHZ   | MAX9485_SCALE_256 },\n\t{  9126000, MAX9485_FS_12KHZ   | MAX9485_SCALE_768 },\n\t{ 11289600, MAX9485_FS_44_1KHZ | MAX9485_SCALE_256 },\n\t{ 12288000, MAX9485_FS_48KHZ   | MAX9485_SCALE_256 },\n\t{ 12288000, MAX9485_FS_32KHZ   | MAX9485_SCALE_384 },\n\t{ 16384000, MAX9485_FS_32KHZ   | MAX9485_SCALE_256 | MAX9485_DOUBLE },\n\t{ 16934400, MAX9485_FS_44_1KHZ | MAX9485_SCALE_384 },\n\t{ 18384000, MAX9485_FS_48KHZ   | MAX9485_SCALE_384 },\n\t{ 22579200, MAX9485_FS_44_1KHZ | MAX9485_SCALE_256 | MAX9485_DOUBLE },\n\t{ 24576000, MAX9485_FS_48KHZ   | MAX9485_SCALE_256 | MAX9485_DOUBLE },\n\t{ 24576000, MAX9485_FS_32KHZ   | MAX9485_SCALE_384 | MAX9485_DOUBLE },\n\t{ 24576000, MAX9485_FS_32KHZ   | MAX9485_SCALE_768 },\n\t{ 33868800, MAX9485_FS_44_1KHZ | MAX9485_SCALE_384 | MAX9485_DOUBLE },\n\t{ 33868800, MAX9485_FS_44_1KHZ | MAX9485_SCALE_768 },\n\t{ 36864000, MAX9485_FS_48KHZ   | MAX9485_SCALE_384 | MAX9485_DOUBLE },\n\t{ 36864000, MAX9485_FS_48KHZ   | MAX9485_SCALE_768 },\n\t{ 49152000, MAX9485_FS_32KHZ   | MAX9485_SCALE_768 | MAX9485_DOUBLE },\n\t{ 67737600, MAX9485_FS_44_1KHZ | MAX9485_SCALE_768 | MAX9485_DOUBLE },\n\t{ 73728000, MAX9485_FS_48KHZ   | MAX9485_SCALE_768 | MAX9485_DOUBLE },\n\t{ }  \n};\n\nstruct max9485_driver_data;\n\nstruct max9485_clk_hw {\n\tstruct clk_hw hw;\n\tstruct clk_init_data init;\n\tu8 enable_bit;\n\tstruct max9485_driver_data *drvdata;\n};\n\nstruct max9485_driver_data {\n\tstruct clk *xclk;\n\tstruct i2c_client *client;\n\tu8 reg_value;\n\tstruct regulator *supply;\n\tstruct gpio_desc *reset_gpio;\n\tstruct max9485_clk_hw hw[MAX9485_NUM_CLKS];\n};\n\nstatic inline struct max9485_clk_hw *to_max9485_clk(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct max9485_clk_hw, hw);\n}\n\nstatic int max9485_update_bits(struct max9485_driver_data *drvdata,\n\t\t\t       u8 mask, u8 value)\n{\n\tint ret;\n\n\tdrvdata->reg_value &= ~mask;\n\tdrvdata->reg_value |= value;\n\n\tdev_dbg(&drvdata->client->dev,\n\t\t\"updating mask 0x%02x value 0x%02x -> 0x%02x\\n\",\n\t\tmask, value, drvdata->reg_value);\n\n\tret = i2c_master_send(drvdata->client,\n\t\t\t      &drvdata->reg_value,\n\t\t\t      sizeof(drvdata->reg_value));\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int max9485_clk_prepare(struct clk_hw *hw)\n{\n\tstruct max9485_clk_hw *clk_hw = to_max9485_clk(hw);\n\n\treturn max9485_update_bits(clk_hw->drvdata,\n\t\t\t\t   clk_hw->enable_bit,\n\t\t\t\t   clk_hw->enable_bit);\n}\n\nstatic void max9485_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct max9485_clk_hw *clk_hw = to_max9485_clk(hw);\n\n\tmax9485_update_bits(clk_hw->drvdata, clk_hw->enable_bit, 0);\n}\n\n \nstatic int max9485_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct max9485_clk_hw *clk_hw = to_max9485_clk(hw);\n\tconst struct max9485_rate *entry;\n\n\tfor (entry = max9485_rates; entry->out != 0; entry++)\n\t\tif (entry->out == rate)\n\t\t\tbreak;\n\n\tif (entry->out == 0)\n\t\treturn -EINVAL;\n\n\treturn max9485_update_bits(clk_hw->drvdata,\n\t\t\t\t   MAX9485_FREQ_MASK,\n\t\t\t\t   entry->reg_value);\n}\n\nstatic unsigned long max9485_clkout_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct max9485_clk_hw *clk_hw = to_max9485_clk(hw);\n\tstruct max9485_driver_data *drvdata = clk_hw->drvdata;\n\tu8 val = drvdata->reg_value & MAX9485_FREQ_MASK;\n\tconst struct max9485_rate *entry;\n\n\tfor (entry = max9485_rates; entry->out != 0; entry++)\n\t\tif (val == entry->reg_value)\n\t\t\treturn entry->out;\n\n\treturn 0;\n}\n\nstatic long max9485_clkout_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long *parent_rate)\n{\n\tconst struct max9485_rate *curr, *prev = NULL;\n\n\tfor (curr = max9485_rates; curr->out != 0; curr++) {\n\t\t \n\t\tif (curr->out == rate)\n\t\t\treturn rate;\n\n\t\t \n\t\tif (curr->out > rate) {\n\t\t\tunsigned int mid;\n\n\t\t\t \n\t\t\tif (!prev)\n\t\t\t\treturn curr->out;\n\n\t\t\t \n\t\t\tmid = prev->out + ((curr->out - prev->out) / 2);\n\n\t\t\treturn (mid > rate) ? prev->out : curr->out;\n\t\t}\n\n\t\tprev = curr;\n\t}\n\n\t \n\treturn prev->out;\n}\n\nstruct max9485_clk {\n\tconst char *name;\n\tint parent_index;\n\tconst struct clk_ops ops;\n\tu8 enable_bit;\n};\n\nstatic const struct max9485_clk max9485_clks[MAX9485_NUM_CLKS] = {\n\t[MAX9485_MCLKOUT] = {\n\t\t.name = \"mclkout\",\n\t\t.parent_index = -1,\n\t\t.enable_bit = MAX9485_MCLK_ENABLE,\n\t\t.ops = {\n\t\t\t.prepare\t= max9485_clk_prepare,\n\t\t\t.unprepare\t= max9485_clk_unprepare,\n\t\t},\n\t},\n\t[MAX9485_CLKOUT] = {\n\t\t.name = \"clkout\",\n\t\t.parent_index = -1,\n\t\t.ops = {\n\t\t\t.set_rate\t= max9485_clkout_set_rate,\n\t\t\t.round_rate\t= max9485_clkout_round_rate,\n\t\t\t.recalc_rate\t= max9485_clkout_recalc_rate,\n\t\t},\n\t},\n\t[MAX9485_CLKOUT1] = {\n\t\t.name = \"clkout1\",\n\t\t.parent_index = MAX9485_CLKOUT,\n\t\t.enable_bit = MAX9485_CLKOUT1_ENABLE,\n\t\t.ops = {\n\t\t\t.prepare\t= max9485_clk_prepare,\n\t\t\t.unprepare\t= max9485_clk_unprepare,\n\t\t},\n\t},\n\t[MAX9485_CLKOUT2] = {\n\t\t.name = \"clkout2\",\n\t\t.parent_index = MAX9485_CLKOUT,\n\t\t.enable_bit = MAX9485_CLKOUT2_ENABLE,\n\t\t.ops = {\n\t\t\t.prepare\t= max9485_clk_prepare,\n\t\t\t.unprepare\t= max9485_clk_unprepare,\n\t\t},\n\t},\n};\n\nstatic struct clk_hw *\nmax9485_of_clk_get(struct of_phandle_args *clkspec, void *data)\n{\n\tstruct max9485_driver_data *drvdata = data;\n\tunsigned int idx = clkspec->args[0];\n\n\treturn &drvdata->hw[idx].hw;\n}\n\nstatic int max9485_i2c_probe(struct i2c_client *client)\n{\n\tstruct max9485_driver_data *drvdata;\n\tstruct device *dev = &client->dev;\n\tconst char *xclk_name;\n\tint i, ret;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->xclk = devm_clk_get(dev, \"xclk\");\n\tif (IS_ERR(drvdata->xclk))\n\t\treturn PTR_ERR(drvdata->xclk);\n\n\txclk_name = __clk_get_name(drvdata->xclk);\n\n\tdrvdata->supply = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(drvdata->supply))\n\t\treturn PTR_ERR(drvdata->supply);\n\n\tret = regulator_enable(drvdata->supply);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrvdata->reset_gpio =\n\t\tdevm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(drvdata->reset_gpio))\n\t\treturn PTR_ERR(drvdata->reset_gpio);\n\n\ti2c_set_clientdata(client, drvdata);\n\tdrvdata->client = client;\n\n\tret = i2c_master_recv(drvdata->client, &drvdata->reg_value,\n\t\t\t      sizeof(drvdata->reg_value));\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Unable to read device register: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < MAX9485_NUM_CLKS; i++) {\n\t\tint parent_index = max9485_clks[i].parent_index;\n\t\tconst char *name;\n\n\t\tif (of_property_read_string_index(dev->of_node,\n\t\t\t\t\t\t  \"clock-output-names\",\n\t\t\t\t\t\t  i, &name) == 0) {\n\t\t\tdrvdata->hw[i].init.name = name;\n\t\t} else {\n\t\t\tdrvdata->hw[i].init.name = max9485_clks[i].name;\n\t\t}\n\n\t\tdrvdata->hw[i].init.ops = &max9485_clks[i].ops;\n\t\tdrvdata->hw[i].init.num_parents = 1;\n\t\tdrvdata->hw[i].init.flags = 0;\n\n\t\tif (parent_index > 0) {\n\t\t\tdrvdata->hw[i].init.parent_names =\n\t\t\t\t&drvdata->hw[parent_index].init.name;\n\t\t\tdrvdata->hw[i].init.flags |= CLK_SET_RATE_PARENT;\n\t\t} else {\n\t\t\tdrvdata->hw[i].init.parent_names = &xclk_name;\n\t\t}\n\n\t\tdrvdata->hw[i].enable_bit = max9485_clks[i].enable_bit;\n\t\tdrvdata->hw[i].hw.init = &drvdata->hw[i].init;\n\t\tdrvdata->hw[i].drvdata = drvdata;\n\n\t\tret = devm_clk_hw_register(dev, &drvdata->hw[i].hw);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(dev, max9485_of_clk_get, drvdata);\n}\n\nstatic int __maybe_unused max9485_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct max9485_driver_data *drvdata = i2c_get_clientdata(client);\n\n\tgpiod_set_value_cansleep(drvdata->reset_gpio, 0);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused max9485_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct max9485_driver_data *drvdata = i2c_get_clientdata(client);\n\tint ret;\n\n\tgpiod_set_value_cansleep(drvdata->reset_gpio, 1);\n\n\tret = i2c_master_send(client, &drvdata->reg_value,\n\t\t\t      sizeof(drvdata->reg_value));\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic const struct dev_pm_ops max9485_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(max9485_suspend, max9485_resume)\n};\n\nstatic const struct of_device_id max9485_dt_ids[] = {\n\t{ .compatible = \"maxim,max9485\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max9485_dt_ids);\n\nstatic const struct i2c_device_id max9485_i2c_ids[] = {\n\t{ .name = \"max9485\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max9485_i2c_ids);\n\nstatic struct i2c_driver max9485_driver = {\n\t.driver = {\n\t\t.name\t\t= \"max9485\",\n\t\t.pm\t\t= &max9485_pm_ops,\n\t\t.of_match_table\t= max9485_dt_ids,\n\t},\n\t.probe = max9485_i2c_probe,\n\t.id_table = max9485_i2c_ids,\n};\nmodule_i2c_driver(max9485_driver);\n\nMODULE_AUTHOR(\"Daniel Mack <daniel@zonque.org>\");\nMODULE_DESCRIPTION(\"MAX9485 Programmable Audio Clock Generator\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}