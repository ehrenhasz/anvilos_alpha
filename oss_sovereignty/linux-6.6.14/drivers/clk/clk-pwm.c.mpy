{
  "module_name": "clk-pwm.c",
  "hash_id": "dfc113125396557ec291dd27707b1bec571bf8bbb153071140b320fb4b036d91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clk/clk-pwm.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n\nstruct clk_pwm {\n\tstruct clk_hw hw;\n\tstruct pwm_device *pwm;\n\tu32 fixed_rate;\n};\n\nstatic inline struct clk_pwm *to_clk_pwm(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct clk_pwm, hw);\n}\n\nstatic int clk_pwm_prepare(struct clk_hw *hw)\n{\n\tstruct clk_pwm *clk_pwm = to_clk_pwm(hw);\n\n\treturn pwm_enable(clk_pwm->pwm);\n}\n\nstatic void clk_pwm_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_pwm *clk_pwm = to_clk_pwm(hw);\n\n\tpwm_disable(clk_pwm->pwm);\n}\n\nstatic unsigned long clk_pwm_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct clk_pwm *clk_pwm = to_clk_pwm(hw);\n\n\treturn clk_pwm->fixed_rate;\n}\n\nstatic int clk_pwm_get_duty_cycle(struct clk_hw *hw, struct clk_duty *duty)\n{\n\tstruct clk_pwm *clk_pwm = to_clk_pwm(hw);\n\tstruct pwm_state state;\n\n\tpwm_get_state(clk_pwm->pwm, &state);\n\n\tduty->num = state.duty_cycle;\n\tduty->den = state.period;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops clk_pwm_ops = {\n\t.prepare = clk_pwm_prepare,\n\t.unprepare = clk_pwm_unprepare,\n\t.recalc_rate = clk_pwm_recalc_rate,\n\t.get_duty_cycle = clk_pwm_get_duty_cycle,\n};\n\nstatic int clk_pwm_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct clk_init_data init;\n\tstruct clk_pwm *clk_pwm;\n\tstruct pwm_device *pwm;\n\tstruct pwm_args pargs;\n\tconst char *clk_name;\n\tint ret;\n\n\tclk_pwm = devm_kzalloc(&pdev->dev, sizeof(*clk_pwm), GFP_KERNEL);\n\tif (!clk_pwm)\n\t\treturn -ENOMEM;\n\n\tpwm = devm_pwm_get(&pdev->dev, NULL);\n\tif (IS_ERR(pwm))\n\t\treturn PTR_ERR(pwm);\n\n\tpwm_get_args(pwm, &pargs);\n\tif (!pargs.period) {\n\t\tdev_err(&pdev->dev, \"invalid PWM period\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(node, \"clock-frequency\", &clk_pwm->fixed_rate))\n\t\tclk_pwm->fixed_rate = div64_u64(NSEC_PER_SEC, pargs.period);\n\n\tif (!clk_pwm->fixed_rate) {\n\t\tdev_err(&pdev->dev, \"fixed_rate cannot be zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pargs.period != NSEC_PER_SEC / clk_pwm->fixed_rate &&\n\t    pargs.period != DIV_ROUND_UP(NSEC_PER_SEC, clk_pwm->fixed_rate)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"clock-frequency does not match PWM period\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpwm_apply_args(pwm);\n\tret = pwm_config(pwm, (pargs.period + 1) >> 1, pargs.period);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tclk_name = node->name;\n\tof_property_read_string(node, \"clock-output-names\", &clk_name);\n\n\tinit.name = clk_name;\n\tinit.ops = &clk_pwm_ops;\n\tinit.flags = 0;\n\tinit.num_parents = 0;\n\n\tclk_pwm->pwm = pwm;\n\tclk_pwm->hw.init = &init;\n\tret = devm_clk_hw_register(&pdev->dev, &clk_pwm->hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn of_clk_add_hw_provider(node, of_clk_hw_simple_get, &clk_pwm->hw);\n}\n\nstatic void clk_pwm_remove(struct platform_device *pdev)\n{\n\tof_clk_del_provider(pdev->dev.of_node);\n}\n\nstatic const struct of_device_id clk_pwm_dt_ids[] = {\n\t{ .compatible = \"pwm-clock\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, clk_pwm_dt_ids);\n\nstatic struct platform_driver clk_pwm_driver = {\n\t.probe = clk_pwm_probe,\n\t.remove_new = clk_pwm_remove,\n\t.driver = {\n\t\t.name = \"pwm-clock\",\n\t\t.of_match_table = clk_pwm_dt_ids,\n\t},\n};\n\nmodule_platform_driver(clk_pwm_driver);\n\nMODULE_AUTHOR(\"Philipp Zabel <p.zabel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"PWM clock driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}