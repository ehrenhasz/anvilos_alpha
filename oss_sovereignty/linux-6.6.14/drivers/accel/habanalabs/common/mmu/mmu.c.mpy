{
  "module_name": "mmu.c",
  "hash_id": "bf9b3769cd7d94e17ba23d6f6ce8793e598a7932f604a0ba39e2475a3ac0219a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/common/mmu/mmu.c",
  "human_readable_source": "\n\n \n\n#include <linux/slab.h>\n\n#include \"../habanalabs.h\"\n\n#include <trace/events/habanalabs.h>\n\n \nstatic struct hl_mmu_funcs *hl_mmu_get_funcs(struct hl_device *hdev, int pgt_residency,\n\t\t\t\t\t\t\t\t\tbool is_dram_addr)\n{\n\treturn &hdev->mmu_func[pgt_residency];\n}\n\nbool hl_is_dram_va(struct hl_device *hdev, u64 virt_addr)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\n\treturn hl_mem_area_inside_range(virt_addr, prop->dmmu.page_size,\n\t\t\t\t\tprop->dmmu.start_addr,\n\t\t\t\t\tprop->dmmu.end_addr);\n}\n\n \nint hl_mmu_init(struct hl_device *hdev)\n{\n\tint rc = -EOPNOTSUPP;\n\n\tif (hdev->mmu_disable)\n\t\treturn 0;\n\n\tmutex_init(&hdev->mmu_lock);\n\n\tif (hdev->mmu_func[MMU_DR_PGT].init != NULL) {\n\t\trc = hdev->mmu_func[MMU_DR_PGT].init(hdev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (hdev->mmu_func[MMU_HR_PGT].init != NULL) {\n\t\trc = hdev->mmu_func[MMU_HR_PGT].init(hdev);\n\t\tif (rc)\n\t\t\tgoto fini_dr_mmu;\n\t}\n\n\treturn 0;\n\nfini_dr_mmu:\n\tif (hdev->mmu_func[MMU_DR_PGT].fini != NULL)\n\t\thdev->mmu_func[MMU_DR_PGT].fini(hdev);\n\n\treturn rc;\n}\n\n \nvoid hl_mmu_fini(struct hl_device *hdev)\n{\n\tif (hdev->mmu_disable)\n\t\treturn;\n\n\tif (hdev->mmu_func[MMU_DR_PGT].fini != NULL)\n\t\thdev->mmu_func[MMU_DR_PGT].fini(hdev);\n\n\tif (hdev->mmu_func[MMU_HR_PGT].fini != NULL)\n\t\thdev->mmu_func[MMU_HR_PGT].fini(hdev);\n\n\tmutex_destroy(&hdev->mmu_lock);\n}\n\n \nint hl_mmu_ctx_init(struct hl_ctx *ctx)\n{\n\tstruct hl_device *hdev = ctx->hdev;\n\tint rc = -EOPNOTSUPP;\n\n\tif (hdev->mmu_disable)\n\t\treturn 0;\n\n\tif (hdev->mmu_func[MMU_DR_PGT].ctx_init != NULL) {\n\t\trc = hdev->mmu_func[MMU_DR_PGT].ctx_init(ctx);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (hdev->mmu_func[MMU_HR_PGT].ctx_init != NULL) {\n\t\trc = hdev->mmu_func[MMU_HR_PGT].ctx_init(ctx);\n\t\tif (rc)\n\t\t\tgoto fini_dr_ctx;\n\t}\n\n\treturn 0;\n\nfini_dr_ctx:\n\tif (hdev->mmu_func[MMU_DR_PGT].fini != NULL)\n\t\thdev->mmu_func[MMU_DR_PGT].fini(hdev);\n\n\treturn rc;\n}\n\n \nvoid hl_mmu_ctx_fini(struct hl_ctx *ctx)\n{\n\tstruct hl_device *hdev = ctx->hdev;\n\n\tif (hdev->mmu_disable)\n\t\treturn;\n\n\tif (hdev->mmu_func[MMU_DR_PGT].ctx_fini != NULL)\n\t\thdev->mmu_func[MMU_DR_PGT].ctx_fini(ctx);\n\n\tif (hdev->mmu_func[MMU_HR_PGT].ctx_fini != NULL)\n\t\thdev->mmu_func[MMU_HR_PGT].ctx_fini(ctx);\n}\n\n \nint hl_mmu_get_real_page_size(struct hl_device *hdev, struct hl_mmu_properties *mmu_prop,\n\t\t\t\tu32 page_size, u32 *real_page_size, bool is_dram_addr)\n{\n\t \n\tif ((page_size % mmu_prop->page_size) == 0) {\n\t\t*real_page_size = mmu_prop->page_size;\n\t\treturn 0;\n\t}\n\n\tdev_err(hdev->dev, \"page size of %u is not %uKB aligned, can't map\\n\",\n\t\t\t\t\t\tpage_size, mmu_prop->page_size >> 10);\n\n\treturn -EFAULT;\n}\n\nstatic struct hl_mmu_properties *hl_mmu_get_prop(struct hl_device *hdev, u32 page_size,\n\t\t\t\t\t\t\tbool is_dram_addr)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\n\tif (is_dram_addr)\n\t\treturn &prop->dmmu;\n\telse if ((page_size % prop->pmmu_huge.page_size) == 0)\n\t\treturn &prop->pmmu_huge;\n\n\treturn &prop->pmmu;\n}\n\n \nint hl_mmu_unmap_page(struct hl_ctx *ctx, u64 virt_addr, u32 page_size, bool flush_pte)\n{\n\tstruct hl_device *hdev = ctx->hdev;\n\tstruct hl_mmu_properties *mmu_prop;\n\tstruct hl_mmu_funcs *mmu_funcs;\n\tint i, pgt_residency, rc = 0;\n\tu32 real_page_size, npages;\n\tu64 real_virt_addr;\n\tbool is_dram_addr;\n\n\tif (hdev->mmu_disable)\n\t\treturn 0;\n\n\tis_dram_addr = hl_is_dram_va(hdev, virt_addr);\n\tmmu_prop = hl_mmu_get_prop(hdev, page_size, is_dram_addr);\n\n\tpgt_residency = mmu_prop->host_resident ? MMU_HR_PGT : MMU_DR_PGT;\n\tmmu_funcs = hl_mmu_get_funcs(hdev, pgt_residency, is_dram_addr);\n\n\trc = hdev->asic_funcs->mmu_get_real_page_size(hdev, mmu_prop, page_size, &real_page_size,\n\t\t\t\t\t\t\tis_dram_addr);\n\tif (rc)\n\t\treturn rc;\n\n\tnpages = page_size / real_page_size;\n\treal_virt_addr = virt_addr;\n\n\tfor (i = 0 ; i < npages ; i++) {\n\t\trc = mmu_funcs->unmap(ctx, real_virt_addr, is_dram_addr);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\treal_virt_addr += real_page_size;\n\t}\n\n\tif (flush_pte)\n\t\tmmu_funcs->flush(ctx);\n\n\tif (trace_habanalabs_mmu_unmap_enabled() && !rc)\n\t\ttrace_habanalabs_mmu_unmap(hdev->dev, virt_addr, 0, page_size, flush_pte);\n\n\treturn rc;\n}\n\n \nint hl_mmu_map_page(struct hl_ctx *ctx, u64 virt_addr, u64 phys_addr, u32 page_size,\n\t\t\tbool flush_pte)\n{\n\tint i, rc, pgt_residency, mapped_cnt = 0;\n\tstruct hl_device *hdev = ctx->hdev;\n\tstruct hl_mmu_properties *mmu_prop;\n\tu64 real_virt_addr, real_phys_addr;\n\tstruct hl_mmu_funcs *mmu_funcs;\n\tu32 real_page_size, npages;\n\tbool is_dram_addr;\n\n\n\tif (hdev->mmu_disable)\n\t\treturn 0;\n\n\tis_dram_addr = hl_is_dram_va(hdev, virt_addr);\n\tmmu_prop = hl_mmu_get_prop(hdev, page_size, is_dram_addr);\n\n\tpgt_residency = mmu_prop->host_resident ? MMU_HR_PGT : MMU_DR_PGT;\n\tmmu_funcs = hl_mmu_get_funcs(hdev, pgt_residency, is_dram_addr);\n\n\trc = hdev->asic_funcs->mmu_get_real_page_size(hdev, mmu_prop, page_size, &real_page_size,\n\t\t\t\t\t\t\tis_dram_addr);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif ((is_dram_addr &&\n\t\t\t((hdev->asic_funcs->scramble_addr(hdev, phys_addr) &\n\t\t\t\t(mmu_prop->page_size - 1)) ||\n\t\t\t(hdev->asic_funcs->scramble_addr(hdev, virt_addr) &\n\t\t\t\t(mmu_prop->page_size - 1)))) ||\n\t\t(!is_dram_addr && ((phys_addr & (real_page_size - 1)) ||\n\t\t\t\t(virt_addr & (real_page_size - 1)))))\n\t\tdev_crit(hdev->dev,\n\t\t\t\"Mapping address 0x%llx with virtual address 0x%llx and page size of 0x%x is erroneous! Addresses must be divisible by page size\",\n\t\t\tphys_addr, virt_addr, real_page_size);\n\n\tnpages = page_size / real_page_size;\n\treal_virt_addr = virt_addr;\n\treal_phys_addr = phys_addr;\n\n\tfor (i = 0 ; i < npages ; i++) {\n\t\trc = mmu_funcs->map(ctx, real_virt_addr, real_phys_addr, real_page_size,\n\t\t\t\t\t\t\t\t\t\tis_dram_addr);\n\t\tif (rc)\n\t\t\tgoto err;\n\n\t\treal_virt_addr += real_page_size;\n\t\treal_phys_addr += real_page_size;\n\t\tmapped_cnt++;\n\t}\n\n\tif (flush_pte)\n\t\tmmu_funcs->flush(ctx);\n\n\ttrace_habanalabs_mmu_map(hdev->dev, virt_addr, phys_addr, page_size, flush_pte);\n\n\treturn 0;\n\nerr:\n\treal_virt_addr = virt_addr;\n\tfor (i = 0 ; i < mapped_cnt ; i++) {\n\t\tif (mmu_funcs->unmap(ctx, real_virt_addr, is_dram_addr))\n\t\t\tdev_warn_ratelimited(hdev->dev,\n\t\t\t\t\"failed to unmap va: 0x%llx\\n\", real_virt_addr);\n\n\t\treal_virt_addr += real_page_size;\n\t}\n\n\tmmu_funcs->flush(ctx);\n\n\treturn rc;\n}\n\n \nint hl_mmu_map_contiguous(struct hl_ctx *ctx, u64 virt_addr,\n\t\t\t\t\tu64 phys_addr, u32 size)\n{\n\tstruct hl_device *hdev = ctx->hdev;\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu64 curr_va, curr_pa;\n\tu32 page_size;\n\tbool flush_pte;\n\tint rc = 0, off;\n\n\tif (hl_mem_area_inside_range(virt_addr, size,\n\t\t\tprop->dmmu.start_addr, prop->dmmu.end_addr))\n\t\tpage_size = prop->dmmu.page_size;\n\telse if (hl_mem_area_inside_range(virt_addr, size,\n\t\t\tprop->pmmu.start_addr, prop->pmmu.end_addr))\n\t\tpage_size = prop->pmmu.page_size;\n\telse if (hl_mem_area_inside_range(virt_addr, size,\n\t\t\tprop->pmmu_huge.start_addr, prop->pmmu_huge.end_addr))\n\t\tpage_size = prop->pmmu_huge.page_size;\n\telse\n\t\treturn -EINVAL;\n\n\tfor (off = 0 ; off < size ; off += page_size) {\n\t\tcurr_va = virt_addr + off;\n\t\tcurr_pa = phys_addr + off;\n\t\tflush_pte = (off + page_size) >= size;\n\t\trc = hl_mmu_map_page(ctx, curr_va, curr_pa, page_size,\n\t\t\t\t\t\t\t\tflush_pte);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Map failed for va 0x%llx to pa 0x%llx\\n\",\n\t\t\t\tcurr_va, curr_pa);\n\t\t\t \n\t\t\toff -= page_size;\n\t\t\tgoto unmap;\n\t\t}\n\t}\n\n\treturn rc;\n\nunmap:\n\tfor (; off >= 0 ; off -= page_size) {\n\t\tcurr_va = virt_addr + off;\n\t\tflush_pte = (off - (s32) page_size) < 0;\n\t\tif (hl_mmu_unmap_page(ctx, curr_va, page_size, flush_pte))\n\t\t\tdev_warn_ratelimited(hdev->dev,\n\t\t\t\t\"failed to unmap va 0x%llx\\n\", curr_va);\n\t}\n\n\treturn rc;\n}\n\n \nint hl_mmu_unmap_contiguous(struct hl_ctx *ctx, u64 virt_addr, u32 size)\n{\n\tstruct hl_device *hdev = ctx->hdev;\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu64 curr_va;\n\tu32 page_size;\n\tbool flush_pte;\n\tint rc = 0, off;\n\n\tif (hl_mem_area_inside_range(virt_addr, size,\n\t\t\tprop->dmmu.start_addr, prop->dmmu.end_addr))\n\t\tpage_size = prop->dmmu.page_size;\n\telse if (hl_mem_area_inside_range(virt_addr, size,\n\t\t\tprop->pmmu.start_addr, prop->pmmu.end_addr))\n\t\tpage_size = prop->pmmu.page_size;\n\telse if (hl_mem_area_inside_range(virt_addr, size,\n\t\t\tprop->pmmu_huge.start_addr, prop->pmmu_huge.end_addr))\n\t\tpage_size = prop->pmmu_huge.page_size;\n\telse\n\t\treturn -EINVAL;\n\n\tfor (off = 0 ; off < size ; off += page_size) {\n\t\tcurr_va = virt_addr + off;\n\t\tflush_pte = (off + page_size) >= size;\n\t\trc = hl_mmu_unmap_page(ctx, curr_va, page_size, flush_pte);\n\t\tif (rc)\n\t\t\tdev_warn_ratelimited(hdev->dev,\n\t\t\t\t\"Unmap failed for va 0x%llx\\n\", curr_va);\n\t}\n\n\treturn rc;\n}\n\nstatic void hl_mmu_pa_page_with_offset(struct hl_ctx *ctx, u64 virt_addr,\n\t\t\t\t\t\tstruct hl_mmu_hop_info *hops,\n\t\t\t\t\t\tu64 *phys_addr)\n{\n\tstruct asic_fixed_properties *prop = &ctx->hdev->asic_prop;\n\tu64 offset_mask, addr_mask, hop_shift, tmp_phys_addr;\n\tstruct hl_mmu_properties *mmu_prop;\n\n\t \n\tif (hops->unscrambled_paddr)\n\t\ttmp_phys_addr = hops->unscrambled_paddr;\n\telse\n\t\ttmp_phys_addr = hops->hop_info[hops->used_hops - 1].hop_pte_val;\n\n\tif (hops->range_type == HL_VA_RANGE_TYPE_HOST_HUGE)\n\t\tmmu_prop = &prop->pmmu_huge;\n\telse if (hops->range_type == HL_VA_RANGE_TYPE_HOST)\n\t\tmmu_prop = &prop->pmmu;\n\telse  \n\t\tmmu_prop = &prop->dmmu;\n\n\tif ((hops->range_type == HL_VA_RANGE_TYPE_DRAM) &&\n\t\t\t!is_power_of_2(prop->dram_page_size)) {\n\t\tu64 dram_page_size, dram_base, abs_phys_addr, abs_virt_addr,\n\t\t\tpage_id, page_start;\n\t\tu32 page_off;\n\n\t\t \n\n\t\tdram_page_size = prop->dram_page_size;\n\t\tdram_base = prop->dram_base_address;\n\t\tabs_phys_addr = tmp_phys_addr - dram_base;\n\t\tabs_virt_addr = virt_addr - dram_base;\n\t\tpage_id = DIV_ROUND_DOWN_ULL(abs_phys_addr, dram_page_size);\n\t\tpage_start = page_id * dram_page_size;\n\t\tdiv_u64_rem(abs_virt_addr, dram_page_size, &page_off);\n\n\t\t*phys_addr = page_start + page_off + dram_base;\n\t} else {\n\t\t \n\t\thop_shift = mmu_prop->hop_shifts[hops->used_hops - 1];\n\t\toffset_mask = (1ull << hop_shift) - 1;\n\t\taddr_mask = ~(offset_mask);\n\t\t*phys_addr = (tmp_phys_addr & addr_mask) |\n\t\t\t\t(virt_addr & offset_mask);\n\t}\n}\n\nint hl_mmu_va_to_pa(struct hl_ctx *ctx, u64 virt_addr, u64 *phys_addr)\n{\n\tstruct hl_mmu_hop_info hops;\n\tint rc;\n\n\tmemset(&hops, 0, sizeof(hops));\n\n\trc = hl_mmu_get_tlb_info(ctx, virt_addr, &hops);\n\tif (rc)\n\t\treturn rc;\n\n\thl_mmu_pa_page_with_offset(ctx, virt_addr, &hops,  phys_addr);\n\n\treturn 0;\n}\n\nint hl_mmu_get_tlb_info(struct hl_ctx *ctx, u64 virt_addr,\n\t\t\tstruct hl_mmu_hop_info *hops)\n{\n\tstruct hl_device *hdev = ctx->hdev;\n\tstruct asic_fixed_properties *prop;\n\tstruct hl_mmu_properties *mmu_prop;\n\tstruct hl_mmu_funcs *mmu_funcs;\n\tint pgt_residency, rc;\n\tbool is_dram_addr;\n\n\tif (hdev->mmu_disable)\n\t\treturn -EOPNOTSUPP;\n\n\tprop = &hdev->asic_prop;\n\thops->scrambled_vaddr = virt_addr;       \n\n\tis_dram_addr = hl_mem_area_inside_range(virt_addr, prop->dmmu.page_size,\n\t\t\t\t\t\t\t\tprop->dmmu.start_addr,\n\t\t\t\t\t\t\t\tprop->dmmu.end_addr);\n\n\t \n\tmmu_prop = is_dram_addr ? &prop->dmmu : &prop->pmmu;\n\tpgt_residency = mmu_prop->host_resident ? MMU_HR_PGT : MMU_DR_PGT;\n\tmmu_funcs = hl_mmu_get_funcs(hdev, pgt_residency, is_dram_addr);\n\n\tmutex_lock(&hdev->mmu_lock);\n\trc = mmu_funcs->get_tlb_info(ctx, virt_addr, hops);\n\tmutex_unlock(&hdev->mmu_lock);\n\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (hops->unscrambled_paddr)\n\t\thl_mmu_pa_page_with_offset(ctx, virt_addr, hops, &hops->unscrambled_paddr);\n\n\treturn 0;\n}\n\nint hl_mmu_if_set_funcs(struct hl_device *hdev)\n{\n\tif (hdev->mmu_disable)\n\t\treturn 0;\n\n\tswitch (hdev->asic_type) {\n\tcase ASIC_GOYA:\n\tcase ASIC_GAUDI:\n\tcase ASIC_GAUDI_SEC:\n\t\thl_mmu_v1_set_funcs(hdev, &hdev->mmu_func[MMU_DR_PGT]);\n\t\tbreak;\n\tcase ASIC_GAUDI2:\n\tcase ASIC_GAUDI2B:\n\t\t \n\t\thl_mmu_v2_hr_set_funcs(hdev, &hdev->mmu_func[MMU_HR_PGT]);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdev->dev, \"Unrecognized ASIC type %d\\n\",\n\t\t\thdev->asic_type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nu64 hl_mmu_scramble_addr(struct hl_device *hdev, u64 addr)\n{\n\treturn addr;\n}\n\n \nu64 hl_mmu_descramble_addr(struct hl_device *hdev, u64 addr)\n{\n\treturn addr;\n}\n\nint hl_mmu_invalidate_cache(struct hl_device *hdev, bool is_hard, u32 flags)\n{\n\tint rc;\n\n\trc = hdev->asic_funcs->mmu_invalidate_cache(hdev, is_hard, flags);\n\tif (rc)\n\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\t\"%s cache invalidation failed, rc=%d\\n\",\n\t\t\t\tflags == VM_TYPE_USERPTR ? \"PMMU\" : \"HMMU\", rc);\n\n\treturn rc;\n}\n\nint hl_mmu_invalidate_cache_range(struct hl_device *hdev, bool is_hard,\n\t\t\t\t\tu32 flags, u32 asid, u64 va, u64 size)\n{\n\tint rc;\n\n\trc = hdev->asic_funcs->mmu_invalidate_cache_range(hdev, is_hard, flags,\n\t\t\t\t\t\t\t\tasid, va, size);\n\tif (rc)\n\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\t\"%s cache range invalidation failed: va=%#llx, size=%llu, rc=%d\",\n\t\t\t\tflags == VM_TYPE_USERPTR ? \"PMMU\" : \"HMMU\", va, size, rc);\n\n\treturn rc;\n}\n\nstatic void hl_mmu_prefetch_work_function(struct work_struct *work)\n{\n\tstruct hl_prefetch_work *pfw = container_of(work, struct hl_prefetch_work, prefetch_work);\n\tstruct hl_ctx *ctx = pfw->ctx;\n\tstruct hl_device *hdev = ctx->hdev;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\tgoto put_ctx;\n\n\tmutex_lock(&hdev->mmu_lock);\n\n\thdev->asic_funcs->mmu_prefetch_cache_range(ctx, pfw->flags, pfw->asid, pfw->va, pfw->size);\n\n\tmutex_unlock(&hdev->mmu_lock);\n\nput_ctx:\n\t \n\thl_ctx_put(ctx);\n\tkfree(pfw);\n}\n\nint hl_mmu_prefetch_cache_range(struct hl_ctx *ctx, u32 flags, u32 asid, u64 va, u64 size)\n{\n\tstruct hl_prefetch_work *handle_prefetch_work;\n\n\thandle_prefetch_work = kmalloc(sizeof(*handle_prefetch_work), GFP_KERNEL);\n\tif (!handle_prefetch_work)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&handle_prefetch_work->prefetch_work, hl_mmu_prefetch_work_function);\n\thandle_prefetch_work->ctx = ctx;\n\thandle_prefetch_work->va = va;\n\thandle_prefetch_work->size = size;\n\thandle_prefetch_work->flags = flags;\n\thandle_prefetch_work->asid = asid;\n\n\t \n\thl_ctx_get(ctx);\n\tqueue_work(ctx->hdev->prefetch_wq, &handle_prefetch_work->prefetch_work);\n\n\treturn 0;\n}\n\nu64 hl_mmu_get_next_hop_addr(struct hl_ctx *ctx, u64 curr_pte)\n{\n\treturn (curr_pte & PAGE_PRESENT_MASK) ? (curr_pte & HOP_PHYS_ADDR_MASK) : ULLONG_MAX;\n}\n\n \nu64 hl_mmu_get_hop_pte_phys_addr(struct hl_ctx *ctx, struct hl_mmu_properties *mmu_prop,\n\t\t\t\t\tu8 hop_idx, u64 hop_addr, u64 virt_addr)\n{\n\tu64 mask, shift;\n\n\tif (hop_idx >= mmu_prop->num_hops) {\n\t\tdev_err_ratelimited(ctx->hdev->dev, \"Invalid hop index %d\\n\", hop_idx);\n\t\treturn U64_MAX;\n\t}\n\n\tshift = mmu_prop->hop_shifts[hop_idx];\n\tmask = mmu_prop->hop_masks[hop_idx];\n\n\treturn hop_addr + ctx->hdev->asic_prop.mmu_pte_size * ((virt_addr & mask) >> shift);\n}\n\nstatic void mmu_dma_mem_free_from_chunk(struct gen_pool *pool,\n\t\t\t\t\tstruct gen_pool_chunk *chunk,\n\t\t\t\t\tvoid *data)\n{\n\tstruct hl_device *hdev = data;\n\n\thl_asic_dma_free_coherent(hdev, (chunk->end_addr - chunk->start_addr) + 1,\n\t\t\t\t\t(void *)chunk->start_addr, chunk->phys_addr);\n}\n\nvoid hl_mmu_hr_flush(struct hl_ctx *ctx)\n{\n\t \n\tmb();\n}\n\n \nstatic void hl_mmu_hr_pool_destroy(struct hl_device *hdev, struct hl_mmu_hr_priv *hr_priv,\n\t\t\t\t\tu32 hop_table_size)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct gen_pool **pool = &hr_priv->mmu_pgt_pool;\n\tstruct pgt_info *hop0_pgt;\n\tint asid;\n\n\tif (ZERO_OR_NULL_PTR(*pool))\n\t\treturn;\n\n\t \n\tif (hr_priv->mmu_asid_hop0) {\n\t\tfor (asid = 0 ; asid < prop->max_asid ; asid++) {\n\t\t\thop0_pgt = &hr_priv->mmu_asid_hop0[asid];\n\t\t\tif (ZERO_OR_NULL_PTR(hop0_pgt->virt_addr))\n\t\t\t\tcontinue;\n\n\t\t\tgen_pool_free(*pool, (uintptr_t) hop0_pgt->virt_addr, hop_table_size);\n\t\t}\n\t}\n\n\tgen_pool_for_each_chunk(*pool, mmu_dma_mem_free_from_chunk, hdev);\n\tgen_pool_destroy(*pool);\n\n\t \n\t*pool = NULL;\n}\n\n \nint hl_mmu_hr_init(struct hl_device *hdev, struct hl_mmu_hr_priv *hr_priv, u32 hop_table_size,\n\t\t\tu64 pgt_size)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tsize_t pool_chunk_size = SZ_4M;\n\tstruct pgt_info *hop0_pgt;\n\tdma_addr_t dma_addr;\n\tu64 virt_addr;\n\tint i, rc;\n\n\t \n\thr_priv->mmu_pgt_pool = gen_pool_create(PAGE_SHIFT, -1);\n\tif (ZERO_OR_NULL_PTR(hr_priv->mmu_pgt_pool)) {\n\t\tdev_err(hdev->dev, \"Failed to create hr page pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thr_priv->mmu_asid_hop0 = kvcalloc(prop->max_asid, sizeof(struct pgt_info), GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(hr_priv->mmu_asid_hop0)) {\n\t\tdev_err(hdev->dev, \"Failed to allocate hr-mmu hop0 table\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto destroy_mmu_pgt_pool;\n\t}\n\n\tfor (i = 0 ; i < pgt_size ; i += pool_chunk_size) {\n\t\tvirt_addr = (uintptr_t) hl_asic_dma_alloc_coherent(hdev, pool_chunk_size,\n\t\t\t\t\t\t\t\t\t&dma_addr,\n\t\t\t\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\t\tif (ZERO_OR_NULL_PTR(virt_addr)) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Failed to allocate memory for host-resident page pool\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto destroy_mmu_pgt_pool;\n\t\t}\n\n\t\trc = gen_pool_add_virt(hr_priv->mmu_pgt_pool, virt_addr, (phys_addr_t) dma_addr,\n\t\t\t\t\t\tpool_chunk_size, -1);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev, \"Failed to fill host-resident page pool\\n\");\n\t\t\tgoto destroy_mmu_pgt_pool;\n\t\t}\n\t}\n\n\tfor (i = 0 ; i < prop->max_asid ; i++) {\n\t\thop0_pgt = &hr_priv->mmu_asid_hop0[i];\n\t\thop0_pgt->virt_addr = (uintptr_t)\n\t\t\t\t\tgen_pool_dma_zalloc_align(hr_priv->mmu_pgt_pool,\n\t\t\t\t\t\t\t\thop_table_size,\n\t\t\t\t\t\t\t\t(dma_addr_t *) &hop0_pgt->phys_addr,\n\t\t\t\t\t\t\t\thop_table_size);\n\t\tif (!hop0_pgt->virt_addr) {\n\t\t\tdev_err(hdev->dev, \"Failed to allocate HOP from pgt pool\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto destroy_mmu_pgt_pool;\n\t\t}\n\t}\n\n\t \n\n\treturn 0;\n\ndestroy_mmu_pgt_pool:\n\thl_mmu_hr_pool_destroy(hdev, hr_priv, hop_table_size);\n\tif (!ZERO_OR_NULL_PTR(hr_priv->mmu_asid_hop0))\n\t\tkvfree(hr_priv->mmu_asid_hop0);\n\n\treturn rc;\n}\n\n \nvoid hl_mmu_hr_fini(struct hl_device *hdev, struct hl_mmu_hr_priv *hr_priv, u32 hop_table_size)\n{\n\t \n\n\thl_mmu_hr_pool_destroy(hdev, hr_priv, hop_table_size);\n\n\tif (!ZERO_OR_NULL_PTR(hr_priv->mmu_asid_hop0)) {\n\t\tkvfree(hr_priv->mmu_asid_hop0);\n\n\t\t \n\t\thr_priv->mmu_asid_hop0 = NULL;\n\t}\n}\n\n \nvoid hl_mmu_hr_free_hop_remove_pgt(struct pgt_info *pgt_info, struct hl_mmu_hr_priv *hr_priv,\n\t\t\t\t\tu32 hop_table_size)\n{\n\tgen_pool_free(hr_priv->mmu_pgt_pool, pgt_info->virt_addr, hop_table_size);\n\thash_del(&pgt_info->node);\n\tkfree(pgt_info);\n}\n\n \nu64 hl_mmu_hr_pte_phys_to_virt(struct hl_ctx *ctx, struct pgt_info *pgt,\n\t\t\t\t\t\t\tu64 phys_pte_addr, u32 hop_table_size)\n{\n\tu64 page_mask = (hop_table_size - 1);\n\tu64 pte_offset = phys_pte_addr & page_mask;\n\n\treturn pgt->virt_addr + pte_offset;\n}\n\n \nvoid hl_mmu_hr_write_pte(struct hl_ctx *ctx, struct pgt_info *pgt_info, u64 phys_pte_addr,\n\t\t\t\t\t\t\t\tu64 val, u32 hop_table_size)\n{\n\t \n\tu64 virt_addr = hl_mmu_hr_pte_phys_to_virt(ctx, pgt_info, phys_pte_addr, hop_table_size);\n\n\t*((u64 *) (uintptr_t) virt_addr) = val;\n}\n\n \nvoid hl_mmu_hr_clear_pte(struct hl_ctx *ctx, struct pgt_info *pgt_info, u64 phys_pte_addr,\n\t\t\t\t\t\tu32 hop_table_size)\n{\n\t \n\thl_mmu_hr_write_pte(ctx, pgt_info, phys_pte_addr, 0, hop_table_size);\n}\n\n \nint hl_mmu_hr_put_pte(struct hl_ctx *ctx, struct pgt_info *pgt_info,\n\t\t\t\t\t\tstruct hl_mmu_hr_priv *hr_priv,\n\t\t\t\t\t\tu32 hop_table_size)\n{\n\tint num_of_ptes_left;\n\n\tpgt_info->num_of_ptes--;\n\n\t \n\tnum_of_ptes_left = pgt_info->num_of_ptes;\n\tif (!num_of_ptes_left)\n\t\thl_mmu_hr_free_hop_remove_pgt(pgt_info, hr_priv, hop_table_size);\n\n\treturn num_of_ptes_left;\n}\n\n \nvoid hl_mmu_hr_get_pte(struct hl_ctx *ctx, struct hl_hr_mmu_funcs *hr_func, u64 phys_hop_addr)\n{\n\thr_func->get_pgt_info(ctx, phys_hop_addr)->num_of_ptes++;\n}\n\n \nstruct pgt_info *hl_mmu_hr_get_next_hop_pgt_info(struct hl_ctx *ctx,\n\t\t\t\t\t\t\tstruct hl_hr_mmu_funcs *hr_func,\n\t\t\t\t\t\t\tu64 curr_pte)\n{\n\tu64 next_hop_phys_addr = hl_mmu_get_next_hop_addr(ctx, curr_pte);\n\n\tif (next_hop_phys_addr == ULLONG_MAX)\n\t\treturn NULL;\n\n\treturn hr_func->get_pgt_info(ctx, next_hop_phys_addr);\n}\n\n \nstruct pgt_info *hl_mmu_hr_alloc_hop(struct hl_ctx *ctx, struct hl_mmu_hr_priv *hr_priv,\n\t\t\t\t\t\t\tstruct hl_hr_mmu_funcs *hr_func,\n\t\t\t\t\t\t\tstruct hl_mmu_properties *mmu_prop)\n{\n\tstruct hl_device *hdev = ctx->hdev;\n\tstruct pgt_info *pgt_info;\n\tdma_addr_t phys_addr;\n\tvoid *virt_addr;\n\tint i, retry = 1;\n\n\tpgt_info = kmalloc(sizeof(*pgt_info), GFP_KERNEL);\n\tif (!pgt_info)\n\t\treturn NULL;\n\n\tfor (i = 0; i <= retry; i++) {\n\t\tvirt_addr = gen_pool_dma_zalloc_align(hr_priv->mmu_pgt_pool,\n\t\t\t\t\t\t\tmmu_prop->hop_table_size,\n\t\t\t\t\t\t\t&phys_addr,\n\t\t\t\t\t\t\tmmu_prop->hop_table_size);\n\t\tif (virt_addr)\n\t\t\tbreak;\n\n\t\t \n\t\tvirt_addr = hl_asic_dma_alloc_coherent(hdev, SZ_2M, &phys_addr,\n\t\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\t\tif (ZERO_OR_NULL_PTR(virt_addr))\n\t\t\tbreak;\n\n\t\tif (gen_pool_add_virt(hr_priv->mmu_pgt_pool, (unsigned long)virt_addr,\n\t\t\t\t\t\t\t\tphys_addr, SZ_2M, -1)) {\n\t\t\thl_asic_dma_free_coherent(hdev, SZ_2M, virt_addr, phys_addr);\n\t\t\tvirt_addr = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ZERO_OR_NULL_PTR(virt_addr)) {\n\t\tdev_err(hdev->dev, \"failed to allocate page\\n\");\n\t\tgoto pool_alloc_err;\n\t}\n\n\tpgt_info->phys_addr = phys_addr;\n\tpgt_info->shadow_addr = (unsigned long) NULL;\n\tpgt_info->virt_addr = (unsigned long)virt_addr;\n\tpgt_info->ctx = ctx;\n\tpgt_info->num_of_ptes = 0;\n\thr_func->add_pgt_info(ctx, pgt_info, phys_addr);\n\n\treturn pgt_info;\n\npool_alloc_err:\n\tkfree(pgt_info);\n\n\treturn NULL;\n}\n\n \nstruct pgt_info *hl_mmu_hr_get_alloc_next_hop(struct hl_ctx *ctx,\n\t\t\t\t\t\t\tstruct hl_mmu_hr_priv *hr_priv,\n\t\t\t\t\t\t\tstruct hl_hr_mmu_funcs *hr_func,\n\t\t\t\t\t\t\tstruct hl_mmu_properties *mmu_prop,\n\t\t\t\t\t\t\tu64 curr_pte, bool *is_new_hop)\n{\n\tu64 hop_addr = hl_mmu_get_next_hop_addr(ctx, curr_pte);\n\n\tif (hop_addr != ULLONG_MAX)\n\t\treturn hr_func->get_pgt_info(ctx, hop_addr);\n\n\t*is_new_hop = true;\n\treturn hl_mmu_hr_alloc_hop(ctx, hr_priv, hr_func, mmu_prop);\n}\n\n \nint hl_mmu_hr_get_tlb_info(struct hl_ctx *ctx, u64 virt_addr, struct hl_mmu_hop_info *hops,\n\t\t\t\t\t\t\t\tstruct hl_hr_mmu_funcs *hr_func)\n{\n\t \n\tstruct pgt_info *hops_pgt_info[MMU_ARCH_6_HOPS] = { NULL };\n\tstruct hl_device *hdev = ctx->hdev;\n\tstruct hl_mmu_properties *mmu_prop;\n\tint rc, i, used_hops;\n\tbool is_huge;\n\n\trc = hr_func->get_tlb_mapping_params(hdev, &mmu_prop, hops, virt_addr, &is_huge);\n\tif (rc)\n\t\treturn rc;\n\n\tused_hops = mmu_prop->num_hops;\n\n\t \n\tif (is_huge)\n\t\tused_hops--;\n\n\thops->scrambled_vaddr = hdev->asic_funcs->scramble_addr(hdev, virt_addr);\n\n\tfor (i = 0 ; i < used_hops ; i++) {\n\t\tif (i == 0)\n\t\t\thops_pgt_info[i] = hr_func->get_hop0_pgt_info(ctx);\n\t\telse\n\t\t\thops_pgt_info[i] = hl_mmu_hr_get_next_hop_pgt_info(ctx, hr_func,\n\t\t\t\t\t\t\t\thops->hop_info[i - 1].hop_pte_val);\n\n\t\tif (!hops_pgt_info[i])\n\t\t\treturn -EFAULT;\n\n\t\thops->hop_info[i].hop_addr = hops_pgt_info[i]->phys_addr;\n\t\thops->hop_info[i].hop_pte_addr =\n\t\t\t\thl_mmu_get_hop_pte_phys_addr(ctx, mmu_prop, i,\n\t\t\t\t\t\t\t\thops->hop_info[i].hop_addr,\n\t\t\t\t\t\t\t\thops->scrambled_vaddr);\n\t\thops->hop_info[i].hop_pte_val = *(u64 *) (uintptr_t)\n\t\t\t\t\t\thl_mmu_hr_pte_phys_to_virt(ctx, hops_pgt_info[i],\n\t\t\t\t\t\t\t\thops->hop_info[i].hop_pte_addr,\n\t\t\t\t\t\t\t\tmmu_prop->hop_table_size);\n\n\t\tif (!(hops->hop_info[i].hop_pte_val & PAGE_PRESENT_MASK))\n\t\t\treturn -EFAULT;\n\n\t\tif (hops->hop_info[i].hop_pte_val & mmu_prop->last_mask)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (i == mmu_prop->num_hops)\n\t\treturn -EFAULT;\n\n\tif (hops->scrambled_vaddr != virt_addr)\n\t\thops->unscrambled_paddr = hdev->asic_funcs->descramble_addr\n\t\t\t\t(hdev, hops->hop_info[i].hop_pte_val);\n\telse\n\t\thops->unscrambled_paddr = hops->hop_info[i].hop_pte_val;\n\n\thops->used_hops = i + 1;\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}