{
  "module_name": "firmware_if.c",
  "hash_id": "1f10b9bccbcbb8a32c9e35d67e97d4d240ebffaa9b313b0b087c121ad019623c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/common/firmware_if.c",
  "human_readable_source": "\n\n \n\n#include \"habanalabs.h\"\n#include \"../include/common/hl_boot_if.h\"\n\n#include <linux/firmware.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/vmalloc.h>\n\n#include <trace/events/habanalabs.h>\n\n#define FW_FILE_MAX_SIZE\t\t0x1400000  \n\nstatic char *comms_cmd_str_arr[COMMS_INVLD_LAST] = {\n\t[COMMS_NOOP] = __stringify(COMMS_NOOP),\n\t[COMMS_CLR_STS] = __stringify(COMMS_CLR_STS),\n\t[COMMS_RST_STATE] = __stringify(COMMS_RST_STATE),\n\t[COMMS_PREP_DESC] = __stringify(COMMS_PREP_DESC),\n\t[COMMS_DATA_RDY] = __stringify(COMMS_DATA_RDY),\n\t[COMMS_EXEC] = __stringify(COMMS_EXEC),\n\t[COMMS_RST_DEV] = __stringify(COMMS_RST_DEV),\n\t[COMMS_GOTO_WFE] = __stringify(COMMS_GOTO_WFE),\n\t[COMMS_SKIP_BMC] = __stringify(COMMS_SKIP_BMC),\n\t[COMMS_PREP_DESC_ELBI] = __stringify(COMMS_PREP_DESC_ELBI),\n};\n\nstatic char *comms_sts_str_arr[COMMS_STS_INVLD_LAST] = {\n\t[COMMS_STS_NOOP] = __stringify(COMMS_STS_NOOP),\n\t[COMMS_STS_ACK] = __stringify(COMMS_STS_ACK),\n\t[COMMS_STS_OK] = __stringify(COMMS_STS_OK),\n\t[COMMS_STS_ERR] = __stringify(COMMS_STS_ERR),\n\t[COMMS_STS_VALID_ERR] = __stringify(COMMS_STS_VALID_ERR),\n\t[COMMS_STS_TIMEOUT_ERR] = __stringify(COMMS_STS_TIMEOUT_ERR),\n};\n\nstatic char *extract_fw_ver_from_str(const char *fw_str)\n{\n\tchar *str, *fw_ver, *whitespace;\n\tu32 ver_offset;\n\n\tfw_ver = kmalloc(VERSION_MAX_LEN, GFP_KERNEL);\n\tif (!fw_ver)\n\t\treturn NULL;\n\n\tstr = strnstr(fw_str, \"fw-\", VERSION_MAX_LEN);\n\tif (!str)\n\t\tgoto free_fw_ver;\n\n\t \n\tstr += 3;\n\tver_offset = str - fw_str;\n\n\t \n\twhitespace = strnstr(str, \" \", VERSION_MAX_LEN - ver_offset);\n\tif (!whitespace)\n\t\tgoto free_fw_ver;\n\n\tstrscpy(fw_ver, str, whitespace - str + 1);\n\n\treturn fw_ver;\n\nfree_fw_ver:\n\tkfree(fw_ver);\n\treturn NULL;\n}\n\n \nstatic char *extract_u32_until_given_char(char *str, u32 *ver_num, char given_char)\n{\n\tchar num_str[8] = {}, *ch;\n\n\tch = strchrnul(str, given_char);\n\tif (*ch == '\\0' || ch == str || ch - str >= sizeof(num_str))\n\t\treturn NULL;\n\n\tmemcpy(num_str, str, ch - str);\n\tif (kstrtou32(num_str, 10, ver_num))\n\t\treturn NULL;\n\treturn ch;\n}\n\n \nstatic int hl_get_sw_major_minor_subminor(struct hl_device *hdev, const char *fw_str)\n{\n\tchar *end, *start;\n\n\tend = strnstr(fw_str, \"-rc-\", VERSION_MAX_LEN);\n\tif (end == fw_str)\n\t\treturn -EINVAL;\n\n\tif (!end)\n\t\tend = strnstr(fw_str, \"-fw-\", VERSION_MAX_LEN);\n\n\tif (end == fw_str)\n\t\treturn -EINVAL;\n\n\tif (!end)\n\t\treturn -EINVAL;\n\n\tfor (start = end - 1; start != fw_str; start--) {\n\t\tif (*start == '-')\n\t\t\tbreak;\n\t}\n\n\tif (start == fw_str)\n\t\treturn -EINVAL;\n\n\t \n\tstart++;\n\tstart = extract_u32_until_given_char(start, &hdev->fw_sw_major_ver, '.');\n\tif (!start)\n\t\tgoto err_zero_ver;\n\n\tstart++;\n\tstart = extract_u32_until_given_char(start, &hdev->fw_sw_minor_ver, '.');\n\tif (!start)\n\t\tgoto err_zero_ver;\n\n\tstart++;\n\tstart = extract_u32_until_given_char(start, &hdev->fw_sw_sub_minor_ver, '-');\n\tif (!start)\n\t\tgoto err_zero_ver;\n\n\treturn 0;\n\nerr_zero_ver:\n\thdev->fw_sw_major_ver = 0;\n\thdev->fw_sw_minor_ver = 0;\n\thdev->fw_sw_sub_minor_ver = 0;\n\treturn -EINVAL;\n}\n\n \nstatic int hl_get_preboot_major_minor(struct hl_device *hdev, char *preboot_ver)\n{\n\tpreboot_ver = extract_u32_until_given_char(preboot_ver, &hdev->fw_inner_major_ver, '.');\n\tif (!preboot_ver) {\n\t\tdev_err(hdev->dev, \"Error parsing preboot major version\\n\");\n\t\tgoto err_zero_ver;\n\t}\n\n\tpreboot_ver++;\n\n\tpreboot_ver = extract_u32_until_given_char(preboot_ver, &hdev->fw_inner_minor_ver, '.');\n\tif (!preboot_ver) {\n\t\tdev_err(hdev->dev, \"Error parsing preboot minor version\\n\");\n\t\tgoto err_zero_ver;\n\t}\n\treturn 0;\n\nerr_zero_ver:\n\thdev->fw_inner_major_ver = 0;\n\thdev->fw_inner_minor_ver = 0;\n\treturn -EINVAL;\n}\n\nstatic int hl_request_fw(struct hl_device *hdev,\n\t\t\t\tconst struct firmware **firmware_p,\n\t\t\t\tconst char *fw_name)\n{\n\tsize_t fw_size;\n\tint rc;\n\n\trc = request_firmware(firmware_p, fw_name, hdev->dev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Firmware file %s is not found! (error %d)\\n\",\n\t\t\t\tfw_name, rc);\n\t\tgoto out;\n\t}\n\n\tfw_size = (*firmware_p)->size;\n\tif ((fw_size % 4) != 0) {\n\t\tdev_err(hdev->dev, \"Illegal %s firmware size %zu\\n\",\n\t\t\t\tfw_name, fw_size);\n\t\trc = -EINVAL;\n\t\tgoto release_fw;\n\t}\n\n\tdev_dbg(hdev->dev, \"%s firmware size == %zu\\n\", fw_name, fw_size);\n\n\tif (fw_size > FW_FILE_MAX_SIZE) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"FW file size %zu exceeds maximum of %u bytes\\n\",\n\t\t\tfw_size, FW_FILE_MAX_SIZE);\n\t\trc = -EINVAL;\n\t\tgoto release_fw;\n\t}\n\n\treturn 0;\n\nrelease_fw:\n\trelease_firmware(*firmware_p);\nout:\n\treturn rc;\n}\n\n \nstatic inline void hl_release_firmware(const struct firmware *fw)\n{\n\trelease_firmware(fw);\n}\n\n \nstatic int hl_fw_copy_fw_to_device(struct hl_device *hdev,\n\t\t\t\tconst struct firmware *fw, void __iomem *dst,\n\t\t\t\tu32 src_offset, u32 size)\n{\n\tconst void *fw_data;\n\n\t \n\tif (!size)\n\t\tsize = fw->size;\n\n\tif (src_offset + size > fw->size) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"size to copy(%u) and offset(%u) are invalid\\n\",\n\t\t\tsize, src_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tfw_data = (const void *) fw->data;\n\n\tmemcpy_toio(dst, fw_data + src_offset, size);\n\treturn 0;\n}\n\n \nstatic int hl_fw_copy_msg_to_device(struct hl_device *hdev,\n\t\tstruct lkd_msg_comms *msg, void __iomem *dst,\n\t\tu32 src_offset, u32 size)\n{\n\tvoid *msg_data;\n\n\t \n\tif (!size)\n\t\tsize = sizeof(struct lkd_msg_comms);\n\n\tif (src_offset + size > sizeof(struct lkd_msg_comms)) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"size to copy(%u) and offset(%u) are invalid\\n\",\n\t\t\tsize, src_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tmsg_data = (void *) msg;\n\n\tmemcpy_toio(dst, msg_data + src_offset, size);\n\n\treturn 0;\n}\n\n \nint hl_fw_load_fw_to_device(struct hl_device *hdev, const char *fw_name,\n\t\t\t\tvoid __iomem *dst, u32 src_offset, u32 size)\n{\n\tconst struct firmware *fw;\n\tint rc;\n\n\trc = hl_request_fw(hdev, &fw, fw_name);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hl_fw_copy_fw_to_device(hdev, fw, dst, src_offset, size);\n\n\thl_release_firmware(fw);\n\treturn rc;\n}\n\nint hl_fw_send_pci_access_msg(struct hl_device *hdev, u32 opcode, u64 value)\n{\n\tstruct cpucp_packet pkt = {};\n\n\tpkt.ctl = cpu_to_le32(opcode << CPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.value = cpu_to_le64(value);\n\n\treturn hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt), 0, NULL);\n}\n\nint hl_fw_send_cpu_message(struct hl_device *hdev, u32 hw_queue_id, u32 *msg,\n\t\t\t\tu16 len, u32 timeout, u64 *result)\n{\n\tstruct hl_hw_queue *queue = &hdev->kernel_queues[hw_queue_id];\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct cpucp_packet *pkt;\n\tdma_addr_t pkt_dma_addr;\n\tstruct hl_bd *sent_bd;\n\tu32 tmp, expected_ack_val, pi, opcode;\n\tint rc;\n\n\tpkt = hl_cpu_accessible_dma_pool_alloc(hdev, len, &pkt_dma_addr);\n\tif (!pkt) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate DMA memory for packet to CPU\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(pkt, msg, len);\n\n\tmutex_lock(&hdev->send_cpu_message_lock);\n\n\t \n\tif (hdev->disabled && !hdev->reset_info.in_compute_reset) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (hdev->device_cpu_disabled) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tpkt->fence = cpu_to_le32(UINT_MAX);\n\tpi = queue->pi;\n\n\t \n\thl_hw_queue_submit_bd(hdev, queue, hl_queue_inc_ptr(queue->pi), len, pkt_dma_addr);\n\n\tif (prop->fw_app_cpu_boot_dev_sts0 & CPU_BOOT_DEV_STS0_PKT_PI_ACK_EN)\n\t\texpected_ack_val = queue->pi;\n\telse\n\t\texpected_ack_val = CPUCP_PACKET_FENCE_VAL;\n\n\trc = hl_poll_timeout_memory(hdev, &pkt->fence, tmp,\n\t\t\t\t(tmp == expected_ack_val), 1000,\n\t\t\t\ttimeout, true);\n\n\thl_hw_queue_inc_ci_kernel(hdev, hw_queue_id);\n\n\tif (rc == -ETIMEDOUT) {\n\t\t \n\t\tif (!hl_device_operational(hdev, NULL) && !hdev->reset_info.in_compute_reset)\n\t\t\tdev_dbg(hdev->dev, \"Device CPU packet timeout (0x%x) due to FW reset\\n\",\n\t\t\t\t\ttmp);\n\t\telse\n\t\t\tdev_err(hdev->dev, \"Device CPU packet timeout (status = 0x%x)\\n\", tmp);\n\t\thdev->device_cpu_disabled = true;\n\t\tgoto out;\n\t}\n\n\ttmp = le32_to_cpu(pkt->ctl);\n\n\trc = (tmp & CPUCP_PKT_CTL_RC_MASK) >> CPUCP_PKT_CTL_RC_SHIFT;\n\tif (rc) {\n\t\topcode = (tmp & CPUCP_PKT_CTL_OPCODE_MASK) >> CPUCP_PKT_CTL_OPCODE_SHIFT;\n\n\t\tif (!prop->supports_advanced_cpucp_rc) {\n\t\t\tdev_dbg(hdev->dev, \"F/W ERROR %d for CPU packet %d\\n\", rc, opcode);\n\t\t\trc = -EIO;\n\t\t\tgoto scrub_descriptor;\n\t\t}\n\n\t\tswitch (rc) {\n\t\tcase cpucp_packet_invalid:\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"CPU packet %d is not supported by F/W\\n\", opcode);\n\t\t\tbreak;\n\t\tcase cpucp_packet_fault:\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"F/W failed processing CPU packet %d\\n\", opcode);\n\t\t\tbreak;\n\t\tcase cpucp_packet_invalid_pkt:\n\t\t\tdev_dbg(hdev->dev,\n\t\t\t\t\"CPU packet %d is not supported by F/W\\n\", opcode);\n\t\t\tbreak;\n\t\tcase cpucp_packet_invalid_params:\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"F/W reports invalid parameters for CPU packet %d\\n\", opcode);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Unknown F/W ERROR %d for CPU packet %d\\n\", rc, opcode);\n\t\t}\n\n\t\t \n\t\tif (result)\n\t\t\t*result = rc;\n\n\t\trc = -EIO;\n\n\t} else if (result) {\n\t\t*result = le64_to_cpu(pkt->result);\n\t}\n\nscrub_descriptor:\n\t \n\tsent_bd = queue->kernel_address;\n\tsent_bd += hl_pi_2_offset(pi);\n\tsent_bd->ctl = cpu_to_le32(UINT_MAX);\n\nout:\n\tmutex_unlock(&hdev->send_cpu_message_lock);\n\n\thl_cpu_accessible_dma_pool_free(hdev, len, pkt);\n\n\treturn rc;\n}\n\nint hl_fw_unmask_irq(struct hl_device *hdev, u16 event_type)\n{\n\tstruct cpucp_packet pkt;\n\tu64 result;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_UNMASK_RAZWI_IRQ <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.value = cpu_to_le64(event_type);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, &result);\n\n\tif (rc)\n\t\tdev_err(hdev->dev, \"failed to unmask RAZWI IRQ %d\", event_type);\n\n\treturn rc;\n}\n\nint hl_fw_unmask_irq_arr(struct hl_device *hdev, const u32 *irq_arr,\n\t\tsize_t irq_arr_size)\n{\n\tstruct cpucp_unmask_irq_arr_packet *pkt;\n\tsize_t total_pkt_size;\n\tu64 result;\n\tint rc;\n\n\ttotal_pkt_size = sizeof(struct cpucp_unmask_irq_arr_packet) +\n\t\t\tirq_arr_size;\n\n\t \n\ttotal_pkt_size = (total_pkt_size + 0x7) & ~0x7;\n\n\t \n\tif (total_pkt_size > USHRT_MAX) {\n\t\tdev_err(hdev->dev, \"too many elements in IRQ array\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpkt = kzalloc(total_pkt_size, GFP_KERNEL);\n\tif (!pkt)\n\t\treturn -ENOMEM;\n\n\tpkt->length = cpu_to_le32(irq_arr_size / sizeof(irq_arr[0]));\n\tmemcpy(&pkt->irqs, irq_arr, irq_arr_size);\n\n\tpkt->cpucp_pkt.ctl = cpu_to_le32(CPUCP_PACKET_UNMASK_RAZWI_IRQ_ARRAY <<\n\t\t\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) pkt,\n\t\t\t\t\t\ttotal_pkt_size, 0, &result);\n\n\tif (rc)\n\t\tdev_err(hdev->dev, \"failed to unmask IRQ array\\n\");\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nint hl_fw_test_cpu_queue(struct hl_device *hdev)\n{\n\tstruct cpucp_packet test_pkt = {};\n\tu64 result;\n\tint rc;\n\n\ttest_pkt.ctl = cpu_to_le32(CPUCP_PACKET_TEST <<\n\t\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\ttest_pkt.value = cpu_to_le64(CPUCP_PACKET_FENCE_VAL);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &test_pkt,\n\t\t\t\t\t\tsizeof(test_pkt), 0, &result);\n\n\tif (!rc) {\n\t\tif (result != CPUCP_PACKET_FENCE_VAL)\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"CPU queue test failed (%#08llx)\\n\", result);\n\t} else {\n\t\tdev_err(hdev->dev, \"CPU queue test failed, error %d\\n\", rc);\n\t}\n\n\treturn rc;\n}\n\nvoid *hl_fw_cpu_accessible_dma_pool_alloc(struct hl_device *hdev, size_t size,\n\t\t\t\t\t\tdma_addr_t *dma_handle)\n{\n\tu64 kernel_addr;\n\n\tkernel_addr = gen_pool_alloc(hdev->cpu_accessible_dma_pool, size);\n\n\t*dma_handle = hdev->cpu_accessible_dma_address +\n\t\t(kernel_addr - (u64) (uintptr_t) hdev->cpu_accessible_dma_mem);\n\n\treturn (void *) (uintptr_t) kernel_addr;\n}\n\nvoid hl_fw_cpu_accessible_dma_pool_free(struct hl_device *hdev, size_t size,\n\t\t\t\t\tvoid *vaddr)\n{\n\tgen_pool_free(hdev->cpu_accessible_dma_pool, (u64) (uintptr_t) vaddr,\n\t\t\tsize);\n}\n\nint hl_fw_send_soft_reset(struct hl_device *hdev)\n{\n\tstruct cpucp_packet pkt;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_SOFT_RESET << CPUCP_PKT_CTL_OPCODE_SHIFT);\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt), 0, NULL);\n\tif (rc)\n\t\tdev_err(hdev->dev, \"failed to send soft-reset msg (err = %d)\\n\", rc);\n\n\treturn rc;\n}\n\nint hl_fw_send_device_activity(struct hl_device *hdev, bool open)\n{\n\tstruct cpucp_packet pkt;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_ACTIVE_STATUS_SET <<\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.value = cpu_to_le64(open);\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt), 0, NULL);\n\tif (rc)\n\t\tdev_err(hdev->dev, \"failed to send device activity msg(%u)\\n\", open);\n\n\treturn rc;\n}\n\nint hl_fw_send_heartbeat(struct hl_device *hdev)\n{\n\tstruct cpucp_packet hb_pkt;\n\tu64 result;\n\tint rc;\n\n\tmemset(&hb_pkt, 0, sizeof(hb_pkt));\n\thb_pkt.ctl = cpu_to_le32(CPUCP_PACKET_TEST <<\n\t\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\thb_pkt.value = cpu_to_le64(CPUCP_PACKET_FENCE_VAL);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &hb_pkt,\n\t\t\t\t\t\tsizeof(hb_pkt), 0, &result);\n\n\tif ((rc) || (result != CPUCP_PACKET_FENCE_VAL))\n\t\treturn -EIO;\n\n\tif (le32_to_cpu(hb_pkt.status_mask) &\n\t\t\t\t\tCPUCP_PKT_HB_STATUS_EQ_FAULT_MASK) {\n\t\tdev_warn(hdev->dev, \"FW reported EQ fault during heartbeat\\n\");\n\t\trc = -EIO;\n\t}\n\n\treturn rc;\n}\n\nstatic bool fw_report_boot_dev0(struct hl_device *hdev, u32 err_val,\n\t\t\t\t\t\t\t\tu32 sts_val)\n{\n\tbool err_exists = false;\n\n\tif (!(err_val & CPU_BOOT_ERR0_ENABLED))\n\t\treturn false;\n\n\tif (err_val & CPU_BOOT_ERR0_DRAM_INIT_FAIL) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot error - DRAM initialization failed\\n\");\n\t\terr_exists = true;\n\t}\n\n\tif (err_val & CPU_BOOT_ERR0_FIT_CORRUPTED) {\n\t\tdev_err(hdev->dev, \"Device boot error - FIT image corrupted\\n\");\n\t\terr_exists = true;\n\t}\n\n\tif (err_val & CPU_BOOT_ERR0_TS_INIT_FAIL) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot error - Thermal Sensor initialization failed\\n\");\n\t\terr_exists = true;\n\t}\n\n\tif (err_val & CPU_BOOT_ERR0_BMC_WAIT_SKIPPED) {\n\t\tif (hdev->bmc_enable) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Device boot error - Skipped waiting for BMC\\n\");\n\t\t\terr_exists = true;\n\t\t} else {\n\t\t\tdev_info(hdev->dev,\n\t\t\t\t\"Device boot message - Skipped waiting for BMC\\n\");\n\t\t\t \n\t\t\terr_val &= ~CPU_BOOT_ERR0_BMC_WAIT_SKIPPED;\n\t\t}\n\t}\n\n\tif (err_val & CPU_BOOT_ERR0_NIC_DATA_NOT_RDY) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot error - Serdes data from BMC not available\\n\");\n\t\terr_exists = true;\n\t}\n\n\tif (err_val & CPU_BOOT_ERR0_NIC_FW_FAIL) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot error - NIC F/W initialization failed\\n\");\n\t\terr_exists = true;\n\t}\n\n\tif (err_val & CPU_BOOT_ERR0_SECURITY_NOT_RDY) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot warning - security not ready\\n\");\n\t\terr_exists = true;\n\t}\n\n\tif (err_val & CPU_BOOT_ERR0_SECURITY_FAIL) {\n\t\tdev_err(hdev->dev, \"Device boot error - security failure\\n\");\n\t\terr_exists = true;\n\t}\n\n\tif (err_val & CPU_BOOT_ERR0_EFUSE_FAIL) {\n\t\tdev_err(hdev->dev, \"Device boot error - eFuse failure\\n\");\n\t\terr_exists = true;\n\t}\n\n\tif (err_val & CPU_BOOT_ERR0_SEC_IMG_VER_FAIL) {\n\t\tdev_err(hdev->dev, \"Device boot error - Failed to load preboot secondary image\\n\");\n\t\terr_exists = true;\n\t}\n\n\tif (err_val & CPU_BOOT_ERR0_PLL_FAIL) {\n\t\tdev_err(hdev->dev, \"Device boot error - PLL failure\\n\");\n\t\terr_exists = true;\n\t}\n\n\tif (err_val & CPU_BOOT_ERR0_DEVICE_UNUSABLE_FAIL) {\n\t\t \n\t\tdev_dbg(hdev->dev, \"device unusable status is set\\n\");\n\t\terr_val &= ~CPU_BOOT_ERR0_DEVICE_UNUSABLE_FAIL;\n\t}\n\n\tif (err_val & CPU_BOOT_ERR0_BINNING_FAIL) {\n\t\tdev_err(hdev->dev, \"Device boot error - binning failure\\n\");\n\t\terr_exists = true;\n\t}\n\n\tif (sts_val & CPU_BOOT_DEV_STS0_ENABLED)\n\t\tdev_dbg(hdev->dev, \"Device status0 %#x\\n\", sts_val);\n\n\tif (err_val & CPU_BOOT_ERR0_EEPROM_FAIL) {\n\t\tdev_err(hdev->dev, \"Device boot error - EEPROM failure detected\\n\");\n\t\terr_exists = true;\n\t}\n\n\t \n\tif (err_val & CPU_BOOT_ERR0_DRAM_SKIPPED) {\n\t\tdev_warn(hdev->dev,\n\t\t\t\"Device boot warning - Skipped DRAM initialization\\n\");\n\t\t \n\t\terr_val &= ~CPU_BOOT_ERR0_DRAM_SKIPPED;\n\t}\n\n\tif (err_val & CPU_BOOT_ERR0_PRI_IMG_VER_FAIL) {\n\t\tdev_warn(hdev->dev,\n\t\t\t\"Device boot warning - Failed to load preboot primary image\\n\");\n\t\t \n\t\terr_val &= ~CPU_BOOT_ERR0_PRI_IMG_VER_FAIL;\n\t}\n\n\tif (err_val & CPU_BOOT_ERR0_TPM_FAIL) {\n\t\tdev_warn(hdev->dev,\n\t\t\t\"Device boot warning - TPM failure\\n\");\n\t\t \n\t\terr_val &= ~CPU_BOOT_ERR0_TPM_FAIL;\n\t}\n\n\tif (!err_exists && (err_val & ~CPU_BOOT_ERR0_ENABLED)) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot error - unknown ERR0 error 0x%08x\\n\", err_val);\n\t\terr_exists = true;\n\t}\n\n\t \n\tif (err_exists && ((err_val & ~CPU_BOOT_ERR0_ENABLED) &\n\t\t\t\tlower_32_bits(hdev->boot_error_status_mask)))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool fw_report_boot_dev1(struct hl_device *hdev, u32 err_val,\n\t\t\t\t\t\t\t\tu32 sts_val)\n{\n\t \n\tbool err_exists = false;\n\n\tif (!(err_val & CPU_BOOT_ERR1_ENABLED))\n\t\treturn false;\n\n\tif (sts_val & CPU_BOOT_DEV_STS1_ENABLED)\n\t\tdev_dbg(hdev->dev, \"Device status1 %#x\\n\", sts_val);\n\n\tif (!err_exists && (err_val & ~CPU_BOOT_ERR1_ENABLED)) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot error - unknown ERR1 error 0x%08x\\n\",\n\t\t\t\t\t\t\t\terr_val);\n\t\terr_exists = true;\n\t}\n\n\t \n\tif (err_exists && ((err_val & ~CPU_BOOT_ERR1_ENABLED) &\n\t\t\t\tupper_32_bits(hdev->boot_error_status_mask)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int fw_read_errors(struct hl_device *hdev, u32 boot_err0_reg,\n\t\t\t\tu32 boot_err1_reg, u32 cpu_boot_dev_status0_reg,\n\t\t\t\tu32 cpu_boot_dev_status1_reg)\n{\n\tu32 err_val, status_val;\n\tbool err_exists = false;\n\n\t \n\terr_val = RREG32(boot_err0_reg);\n\tstatus_val = RREG32(cpu_boot_dev_status0_reg);\n\terr_exists = fw_report_boot_dev0(hdev, err_val, status_val);\n\n\terr_val = RREG32(boot_err1_reg);\n\tstatus_val = RREG32(cpu_boot_dev_status1_reg);\n\terr_exists |= fw_report_boot_dev1(hdev, err_val, status_val);\n\n\tif (err_exists)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint hl_fw_cpucp_info_get(struct hl_device *hdev,\n\t\t\t\tu32 sts_boot_dev_sts0_reg,\n\t\t\t\tu32 sts_boot_dev_sts1_reg, u32 boot_err0_reg,\n\t\t\t\tu32 boot_err1_reg)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct cpucp_packet pkt = {};\n\tdma_addr_t cpucp_info_dma_addr;\n\tvoid *cpucp_info_cpu_addr;\n\tchar *kernel_ver;\n\tu64 result;\n\tint rc;\n\n\tcpucp_info_cpu_addr = hl_cpu_accessible_dma_pool_alloc(hdev, sizeof(struct cpucp_info),\n\t\t\t\t\t\t\t\t&cpucp_info_dma_addr);\n\tif (!cpucp_info_cpu_addr) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate DMA memory for CPU-CP info packet\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(cpucp_info_cpu_addr, 0, sizeof(struct cpucp_info));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_INFO_GET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.addr = cpu_to_le64(cpucp_info_dma_addr);\n\tpkt.data_max_size = cpu_to_le32(sizeof(struct cpucp_info));\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\tHL_CPUCP_INFO_TIMEOUT_USEC, &result);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to handle CPU-CP info pkt, error %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\trc = fw_read_errors(hdev, boot_err0_reg, boot_err1_reg,\n\t\t\t\tsts_boot_dev_sts0_reg, sts_boot_dev_sts1_reg);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Errors in device boot\\n\");\n\t\tgoto out;\n\t}\n\n\tmemcpy(&prop->cpucp_info, cpucp_info_cpu_addr,\n\t\t\tsizeof(prop->cpucp_info));\n\n\trc = hl_build_hwmon_channel_info(hdev, prop->cpucp_info.sensors);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to build hwmon channel info, error %d\\n\", rc);\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tkernel_ver = extract_fw_ver_from_str(prop->cpucp_info.kernel_version);\n\tif (kernel_ver) {\n\t\tdev_info(hdev->dev, \"Linux version %s\", kernel_ver);\n\t\tkfree(kernel_ver);\n\t}\n\n\t \n\thdev->event_queue.check_eqe_index = false;\n\n\t \n\tif (prop->fw_cpu_boot_dev_sts0_valid) {\n\t\tprop->fw_app_cpu_boot_dev_sts0 = RREG32(sts_boot_dev_sts0_reg);\n\t\tif (prop->fw_app_cpu_boot_dev_sts0 &\n\t\t\t\tCPU_BOOT_DEV_STS0_EQ_INDEX_EN)\n\t\t\thdev->event_queue.check_eqe_index = true;\n\t}\n\n\tif (prop->fw_cpu_boot_dev_sts1_valid)\n\t\tprop->fw_app_cpu_boot_dev_sts1 = RREG32(sts_boot_dev_sts1_reg);\n\nout:\n\thl_cpu_accessible_dma_pool_free(hdev, sizeof(struct cpucp_info), cpucp_info_cpu_addr);\n\n\treturn rc;\n}\n\nstatic int hl_fw_send_msi_info_msg(struct hl_device *hdev)\n{\n\tstruct cpucp_array_data_packet *pkt;\n\tsize_t total_pkt_size, data_size;\n\tu64 result;\n\tint rc;\n\n\t \n\tif (!hdev->asic_funcs->get_msi_info)\n\t\treturn 0;\n\n\tdata_size = CPUCP_NUM_OF_MSI_TYPES * sizeof(u32);\n\ttotal_pkt_size = sizeof(struct cpucp_array_data_packet) + data_size;\n\n\t \n\ttotal_pkt_size = (total_pkt_size + 0x7) & ~0x7;\n\n\t \n\tif (total_pkt_size > USHRT_MAX) {\n\t\tdev_err(hdev->dev, \"CPUCP array data is too big\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpkt = kzalloc(total_pkt_size, GFP_KERNEL);\n\tif (!pkt)\n\t\treturn -ENOMEM;\n\n\tpkt->length = cpu_to_le32(CPUCP_NUM_OF_MSI_TYPES);\n\n\tmemset((void *) &pkt->data, 0xFF, data_size);\n\thdev->asic_funcs->get_msi_info(pkt->data);\n\n\tpkt->cpucp_pkt.ctl = cpu_to_le32(CPUCP_PACKET_MSI_INFO_SET <<\n\t\t\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *)pkt,\n\t\t\t\t\t\ttotal_pkt_size, 0, &result);\n\n\t \n\tif (rc && result == cpucp_packet_invalid)\n\t\trc = 0;\n\n\tif (rc)\n\t\tdev_err(hdev->dev, \"failed to send CPUCP array data\\n\");\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nint hl_fw_cpucp_handshake(struct hl_device *hdev,\n\t\t\t\tu32 sts_boot_dev_sts0_reg,\n\t\t\t\tu32 sts_boot_dev_sts1_reg, u32 boot_err0_reg,\n\t\t\t\tu32 boot_err1_reg)\n{\n\tint rc;\n\n\trc = hl_fw_cpucp_info_get(hdev, sts_boot_dev_sts0_reg,\n\t\t\t\t\tsts_boot_dev_sts1_reg, boot_err0_reg,\n\t\t\t\t\tboot_err1_reg);\n\tif (rc)\n\t\treturn rc;\n\n\treturn hl_fw_send_msi_info_msg(hdev);\n}\n\nint hl_fw_get_eeprom_data(struct hl_device *hdev, void *data, size_t max_size)\n{\n\tstruct cpucp_packet pkt = {};\n\tvoid *eeprom_info_cpu_addr;\n\tdma_addr_t eeprom_info_dma_addr;\n\tu64 result;\n\tint rc;\n\n\teeprom_info_cpu_addr = hl_cpu_accessible_dma_pool_alloc(hdev, max_size,\n\t\t\t\t\t\t\t\t\t&eeprom_info_dma_addr);\n\tif (!eeprom_info_cpu_addr) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate DMA memory for CPU-CP EEPROM packet\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(eeprom_info_cpu_addr, 0, max_size);\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_EEPROM_DATA_GET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.addr = cpu_to_le64(eeprom_info_dma_addr);\n\tpkt.data_max_size = cpu_to_le32(max_size);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\tHL_CPUCP_EEPROM_TIMEOUT_USEC, &result);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to handle CPU-CP EEPROM packet, error %d\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\n\t \n\tmemcpy(data, eeprom_info_cpu_addr, min((size_t)result, max_size));\n\nout:\n\thl_cpu_accessible_dma_pool_free(hdev, max_size, eeprom_info_cpu_addr);\n\n\treturn rc;\n}\n\nint hl_fw_get_monitor_dump(struct hl_device *hdev, void *data)\n{\n\tstruct cpucp_monitor_dump *mon_dump_cpu_addr;\n\tdma_addr_t mon_dump_dma_addr;\n\tstruct cpucp_packet pkt = {};\n\tsize_t data_size;\n\t__le32 *src_ptr;\n\tu32 *dst_ptr;\n\tu64 result;\n\tint i, rc;\n\n\tdata_size = sizeof(struct cpucp_monitor_dump);\n\tmon_dump_cpu_addr = hl_cpu_accessible_dma_pool_alloc(hdev, data_size, &mon_dump_dma_addr);\n\tif (!mon_dump_cpu_addr) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate DMA memory for CPU-CP monitor-dump packet\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(mon_dump_cpu_addr, 0, data_size);\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_MONITOR_DUMP_GET << CPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.addr = cpu_to_le64(mon_dump_dma_addr);\n\tpkt.data_max_size = cpu_to_le32(data_size);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t\tHL_CPUCP_MON_DUMP_TIMEOUT_USEC, &result);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to handle CPU-CP monitor-dump packet, error %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\t \n\tsrc_ptr = (__le32 *) mon_dump_cpu_addr;\n\tdst_ptr = data;\n\tfor (i = 0; i < (data_size / sizeof(u32)); i++) {\n\t\t*dst_ptr = le32_to_cpu(*src_ptr);\n\t\tsrc_ptr++;\n\t\tdst_ptr++;\n\t}\n\nout:\n\thl_cpu_accessible_dma_pool_free(hdev, data_size, mon_dump_cpu_addr);\n\n\treturn rc;\n}\n\nint hl_fw_cpucp_pci_counters_get(struct hl_device *hdev,\n\t\tstruct hl_info_pci_counters *counters)\n{\n\tstruct cpucp_packet pkt = {};\n\tu64 result;\n\tint rc;\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_PCIE_THROUGHPUT_GET <<\n\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\n\t \n\tpkt.index = cpu_to_le32(cpucp_pcie_throughput_rx);\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\tHL_CPUCP_INFO_TIMEOUT_USEC, &result);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to handle CPU-CP PCI info pkt, error %d\\n\", rc);\n\t\treturn rc;\n\t}\n\tcounters->rx_throughput = result;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_PCIE_THROUGHPUT_GET <<\n\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\n\t \n\tpkt.index = cpu_to_le32(cpucp_pcie_throughput_tx);\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\tHL_CPUCP_INFO_TIMEOUT_USEC, &result);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to handle CPU-CP PCI info pkt, error %d\\n\", rc);\n\t\treturn rc;\n\t}\n\tcounters->tx_throughput = result;\n\n\t \n\tmemset(&pkt, 0, sizeof(pkt));\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_PCIE_REPLAY_CNT_GET <<\n\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\tHL_CPUCP_INFO_TIMEOUT_USEC, &result);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to handle CPU-CP PCI info pkt, error %d\\n\", rc);\n\t\treturn rc;\n\t}\n\tcounters->replay_cnt = (u32) result;\n\n\treturn rc;\n}\n\nint hl_fw_cpucp_total_energy_get(struct hl_device *hdev, u64 *total_energy)\n{\n\tstruct cpucp_packet pkt = {};\n\tu64 result;\n\tint rc;\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_TOTAL_ENERGY_GET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\tHL_CPUCP_INFO_TIMEOUT_USEC, &result);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to handle CpuCP total energy pkt, error %d\\n\",\n\t\t\t\trc);\n\t\treturn rc;\n\t}\n\n\t*total_energy = result;\n\n\treturn rc;\n}\n\nint get_used_pll_index(struct hl_device *hdev, u32 input_pll_index,\n\t\t\t\t\t\tenum pll_index *pll_index)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu8 pll_byte, pll_bit_off;\n\tbool dynamic_pll;\n\tint fw_pll_idx;\n\n\tdynamic_pll = !!(prop->fw_app_cpu_boot_dev_sts0 &\n\t\t\t\t\t\tCPU_BOOT_DEV_STS0_DYN_PLL_EN);\n\n\tif (!dynamic_pll) {\n\t\t \n\t\t*pll_index = input_pll_index;\n\t\treturn 0;\n\t}\n\n\t \n\tfw_pll_idx = hdev->asic_funcs->map_pll_idx_to_fw_idx(input_pll_index);\n\tif (fw_pll_idx < 0) {\n\t\tdev_err(hdev->dev, \"Invalid PLL index (%u) error %d\\n\",\n\t\t\tinput_pll_index, fw_pll_idx);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpll_byte = prop->cpucp_info.pll_map[fw_pll_idx >> 3];\n\tpll_bit_off = fw_pll_idx & 0x7;\n\n\tif (!(pll_byte & BIT(pll_bit_off))) {\n\t\tdev_err(hdev->dev, \"PLL index %d is not supported\\n\",\n\t\t\tfw_pll_idx);\n\t\treturn -EINVAL;\n\t}\n\n\t*pll_index = fw_pll_idx;\n\n\treturn 0;\n}\n\nint hl_fw_cpucp_pll_info_get(struct hl_device *hdev, u32 pll_index,\n\t\tu16 *pll_freq_arr)\n{\n\tstruct cpucp_packet pkt;\n\tenum pll_index used_pll_idx;\n\tu64 result;\n\tint rc;\n\n\trc = get_used_pll_index(hdev, pll_index, &used_pll_idx);\n\tif (rc)\n\t\treturn rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_PLL_INFO_GET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.pll_type = __cpu_to_le16((u16)used_pll_idx);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\tHL_CPUCP_INFO_TIMEOUT_USEC, &result);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to read PLL info, error %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tpll_freq_arr[0] = FIELD_GET(CPUCP_PKT_RES_PLL_OUT0_MASK, result);\n\tpll_freq_arr[1] = FIELD_GET(CPUCP_PKT_RES_PLL_OUT1_MASK, result);\n\tpll_freq_arr[2] = FIELD_GET(CPUCP_PKT_RES_PLL_OUT2_MASK, result);\n\tpll_freq_arr[3] = FIELD_GET(CPUCP_PKT_RES_PLL_OUT3_MASK, result);\n\n\treturn 0;\n}\n\nint hl_fw_cpucp_power_get(struct hl_device *hdev, u64 *power)\n{\n\tstruct cpucp_packet pkt;\n\tu64 result;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_POWER_GET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.type = cpu_to_le16(CPUCP_POWER_INPUT);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\tHL_CPUCP_INFO_TIMEOUT_USEC, &result);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to read power, error %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t*power = result;\n\n\treturn rc;\n}\n\nint hl_fw_dram_replaced_row_get(struct hl_device *hdev,\n\t\t\t\tstruct cpucp_hbm_row_info *info)\n{\n\tstruct cpucp_hbm_row_info *cpucp_repl_rows_info_cpu_addr;\n\tdma_addr_t cpucp_repl_rows_info_dma_addr;\n\tstruct cpucp_packet pkt = {};\n\tu64 result;\n\tint rc;\n\n\tcpucp_repl_rows_info_cpu_addr = hl_cpu_accessible_dma_pool_alloc(hdev,\n\t\t\t\t\t\t\tsizeof(struct cpucp_hbm_row_info),\n\t\t\t\t\t\t\t&cpucp_repl_rows_info_dma_addr);\n\tif (!cpucp_repl_rows_info_cpu_addr) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate DMA memory for CPU-CP replaced rows info packet\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(cpucp_repl_rows_info_cpu_addr, 0, sizeof(struct cpucp_hbm_row_info));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_HBM_REPLACED_ROWS_INFO_GET <<\n\t\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.addr = cpu_to_le64(cpucp_repl_rows_info_dma_addr);\n\tpkt.data_max_size = cpu_to_le32(sizeof(struct cpucp_hbm_row_info));\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\tHL_CPUCP_INFO_TIMEOUT_USEC, &result);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to handle CPU-CP replaced rows info pkt, error %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tmemcpy(info, cpucp_repl_rows_info_cpu_addr, sizeof(*info));\n\nout:\n\thl_cpu_accessible_dma_pool_free(hdev, sizeof(struct cpucp_hbm_row_info),\n\t\t\t\t\t\tcpucp_repl_rows_info_cpu_addr);\n\n\treturn rc;\n}\n\nint hl_fw_dram_pending_row_get(struct hl_device *hdev, u32 *pend_rows_num)\n{\n\tstruct cpucp_packet pkt;\n\tu64 result;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_HBM_PENDING_ROWS_STATUS << CPUCP_PKT_CTL_OPCODE_SHIFT);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt), 0, &result);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\t\"Failed to handle CPU-CP pending rows info pkt, error %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\t*pend_rows_num = (u32) result;\nout:\n\treturn rc;\n}\n\nint hl_fw_cpucp_engine_core_asid_set(struct hl_device *hdev, u32 asid)\n{\n\tstruct cpucp_packet pkt;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_ENGINE_CORE_ASID_SET << CPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.value = cpu_to_le64(asid);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\tHL_CPUCP_INFO_TIMEOUT_USEC, NULL);\n\tif (rc)\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed on ASID configuration request for engine core, error %d\\n\",\n\t\t\trc);\n\n\treturn rc;\n}\n\nvoid hl_fw_ask_hard_reset_without_linux(struct hl_device *hdev)\n{\n\tstruct static_fw_load_mgr *static_loader =\n\t\t\t&hdev->fw_loader.static_loader;\n\tint rc;\n\n\tif (hdev->asic_prop.dynamic_fw_load) {\n\t\trc = hl_fw_dynamic_send_protocol_cmd(hdev, &hdev->fw_loader,\n\t\t\t\tCOMMS_RST_DEV, 0, false,\n\t\t\t\thdev->fw_loader.cpu_timeout);\n\t\tif (rc)\n\t\t\tdev_err(hdev->dev, \"Failed sending COMMS_RST_DEV\\n\");\n\t} else {\n\t\tWREG32(static_loader->kmd_msg_to_cpu_reg, KMD_MSG_RST_DEV);\n\t}\n}\n\nvoid hl_fw_ask_halt_machine_without_linux(struct hl_device *hdev)\n{\n\tstruct fw_load_mgr *fw_loader = &hdev->fw_loader;\n\tu32 status, cpu_boot_status_reg, cpu_timeout;\n\tstruct static_fw_load_mgr *static_loader;\n\tstruct pre_fw_load_props *pre_fw_load;\n\tint rc;\n\n\tif (hdev->device_cpu_is_halted)\n\t\treturn;\n\n\t \n\tif (hdev->asic_prop.dynamic_fw_load) {\n\t\tpre_fw_load = &fw_loader->pre_fw_load;\n\t\tcpu_timeout = fw_loader->cpu_timeout;\n\t\tcpu_boot_status_reg = pre_fw_load->cpu_boot_status_reg;\n\n\t\trc = hl_fw_dynamic_send_protocol_cmd(hdev, &hdev->fw_loader,\n\t\t\t\tCOMMS_GOTO_WFE, 0, false, cpu_timeout);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev, \"Failed sending COMMS_GOTO_WFE\\n\");\n\t\t} else {\n\t\t\trc = hl_poll_timeout(\n\t\t\t\thdev,\n\t\t\t\tcpu_boot_status_reg,\n\t\t\t\tstatus,\n\t\t\t\tstatus == CPU_BOOT_STATUS_IN_WFE,\n\t\t\t\thdev->fw_poll_interval_usec,\n\t\t\t\tcpu_timeout);\n\t\t\tif (rc)\n\t\t\t\tdev_err(hdev->dev, \"Current status=%u. Timed-out updating to WFE\\n\",\n\t\t\t\t\t\tstatus);\n\t\t}\n\t} else {\n\t\tstatic_loader = &hdev->fw_loader.static_loader;\n\t\tWREG32(static_loader->kmd_msg_to_cpu_reg, KMD_MSG_GOTO_WFE);\n\t\tmsleep(static_loader->cpu_reset_wait_msec);\n\n\t\t \n\t\tWREG32(static_loader->kmd_msg_to_cpu_reg, KMD_MSG_NA);\n\t}\n\n\thdev->device_cpu_is_halted = true;\n}\n\nstatic void detect_cpu_boot_status(struct hl_device *hdev, u32 status)\n{\n\t \n\tswitch (status) {\n\tcase CPU_BOOT_STATUS_NA:\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot progress - BTL/ROM did NOT run\\n\");\n\t\tbreak;\n\tcase CPU_BOOT_STATUS_IN_WFE:\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot progress - Stuck inside WFE loop\\n\");\n\t\tbreak;\n\tcase CPU_BOOT_STATUS_IN_BTL:\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot progress - Stuck in BTL\\n\");\n\t\tbreak;\n\tcase CPU_BOOT_STATUS_IN_PREBOOT:\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot progress - Stuck in Preboot\\n\");\n\t\tbreak;\n\tcase CPU_BOOT_STATUS_IN_SPL:\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot progress - Stuck in SPL\\n\");\n\t\tbreak;\n\tcase CPU_BOOT_STATUS_IN_UBOOT:\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot progress - Stuck in u-boot\\n\");\n\t\tbreak;\n\tcase CPU_BOOT_STATUS_DRAM_INIT_FAIL:\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot progress - DRAM initialization failed\\n\");\n\t\tbreak;\n\tcase CPU_BOOT_STATUS_UBOOT_NOT_READY:\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot progress - Cannot boot\\n\");\n\t\tbreak;\n\tcase CPU_BOOT_STATUS_TS_INIT_FAIL:\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot progress - Thermal Sensor initialization failed\\n\");\n\t\tbreak;\n\tcase CPU_BOOT_STATUS_SECURITY_READY:\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot progress - Stuck in preboot after security initialization\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdev->dev,\n\t\t\t\"Device boot progress - Invalid or unexpected status code %d\\n\", status);\n\t\tbreak;\n\t}\n}\n\nint hl_fw_wait_preboot_ready(struct hl_device *hdev)\n{\n\tstruct pre_fw_load_props *pre_fw_load = &hdev->fw_loader.pre_fw_load;\n\tu32 status;\n\tint rc;\n\n\t \n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tpre_fw_load->cpu_boot_status_reg,\n\t\tstatus,\n\t\t(status == CPU_BOOT_STATUS_NIC_FW_RDY) ||\n\t\t(status == CPU_BOOT_STATUS_READY_TO_BOOT) ||\n\t\t(status == CPU_BOOT_STATUS_WAITING_FOR_BOOT_FIT),\n\t\thdev->fw_poll_interval_usec,\n\t\tpre_fw_load->wait_for_preboot_timeout);\n\n\tif (rc) {\n\t\tdetect_cpu_boot_status(hdev, status);\n\t\tdev_err(hdev->dev, \"CPU boot ready timeout (status = %d)\\n\", status);\n\n\t\t \n\t\tif (status != -1)\n\t\t\tfw_read_errors(hdev, pre_fw_load->boot_err0_reg,\n\t\t\t\t\t\tpre_fw_load->boot_err1_reg,\n\t\t\t\t\t\tpre_fw_load->sts_boot_dev_sts0_reg,\n\t\t\t\t\t\tpre_fw_load->sts_boot_dev_sts1_reg);\n\t\treturn -EIO;\n\t}\n\n\thdev->fw_loader.fw_comp_loaded |= FW_TYPE_PREBOOT_CPU;\n\n\treturn 0;\n}\n\nstatic int hl_fw_read_preboot_caps(struct hl_device *hdev)\n{\n\tstruct pre_fw_load_props *pre_fw_load;\n\tstruct asic_fixed_properties *prop;\n\tu32 reg_val;\n\tint rc;\n\n\tprop = &hdev->asic_prop;\n\tpre_fw_load = &hdev->fw_loader.pre_fw_load;\n\n\trc = hl_fw_wait_preboot_ready(hdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\treg_val = RREG32(pre_fw_load->sts_boot_dev_sts0_reg);\n\tif (reg_val & CPU_BOOT_DEV_STS0_ENABLED) {\n\t\tprop->fw_cpu_boot_dev_sts0_valid = true;\n\t\tprop->fw_preboot_cpu_boot_dev_sts0 = reg_val;\n\t}\n\n\treg_val = RREG32(pre_fw_load->sts_boot_dev_sts1_reg);\n\tif (reg_val & CPU_BOOT_DEV_STS1_ENABLED) {\n\t\tprop->fw_cpu_boot_dev_sts1_valid = true;\n\t\tprop->fw_preboot_cpu_boot_dev_sts1 = reg_val;\n\t}\n\n\tprop->dynamic_fw_load = !!(prop->fw_preboot_cpu_boot_dev_sts0 &\n\t\t\t\t\t\tCPU_BOOT_DEV_STS0_FW_LD_COM_EN);\n\n\t \n\thdev->asic_funcs->init_firmware_loader(hdev);\n\n\tdev_dbg(hdev->dev, \"Attempting %s FW load\\n\",\n\t\t\tprop->dynamic_fw_load ? \"dynamic\" : \"legacy\");\n\treturn 0;\n}\n\nstatic int hl_fw_static_read_device_fw_version(struct hl_device *hdev,\n\t\t\t\t\tenum hl_fw_component fwc)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct fw_load_mgr *fw_loader = &hdev->fw_loader;\n\tstruct static_fw_load_mgr *static_loader;\n\tchar *dest, *boot_ver, *preboot_ver;\n\tu32 ver_off, limit;\n\tconst char *name;\n\tchar btl_ver[32];\n\n\tstatic_loader = &hdev->fw_loader.static_loader;\n\n\tswitch (fwc) {\n\tcase FW_COMP_BOOT_FIT:\n\t\tver_off = RREG32(static_loader->boot_fit_version_offset_reg);\n\t\tdest = prop->uboot_ver;\n\t\tname = \"Boot-fit\";\n\t\tlimit = static_loader->boot_fit_version_max_off;\n\t\tbreak;\n\tcase FW_COMP_PREBOOT:\n\t\tver_off = RREG32(static_loader->preboot_version_offset_reg);\n\t\tdest = prop->preboot_ver;\n\t\tname = \"Preboot\";\n\t\tlimit = static_loader->preboot_version_max_off;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(hdev->dev, \"Undefined FW component: %d\\n\", fwc);\n\t\treturn -EIO;\n\t}\n\n\tver_off &= static_loader->sram_offset_mask;\n\n\tif (ver_off < limit) {\n\t\tmemcpy_fromio(dest,\n\t\t\thdev->pcie_bar[fw_loader->sram_bar_id] + ver_off,\n\t\t\tVERSION_MAX_LEN);\n\t} else {\n\t\tdev_err(hdev->dev, \"%s version offset (0x%x) is above SRAM\\n\",\n\t\t\t\t\t\t\t\tname, ver_off);\n\t\tstrscpy(dest, \"unavailable\", VERSION_MAX_LEN);\n\t\treturn -EIO;\n\t}\n\n\tif (fwc == FW_COMP_BOOT_FIT) {\n\t\tboot_ver = extract_fw_ver_from_str(prop->uboot_ver);\n\t\tif (boot_ver) {\n\t\t\tdev_info(hdev->dev, \"boot-fit version %s\\n\", boot_ver);\n\t\t\tkfree(boot_ver);\n\t\t}\n\t} else if (fwc == FW_COMP_PREBOOT) {\n\t\tpreboot_ver = strnstr(prop->preboot_ver, \"Preboot\",\n\t\t\t\t\t\tVERSION_MAX_LEN);\n\t\tif (preboot_ver && preboot_ver != prop->preboot_ver) {\n\t\t\tstrscpy(btl_ver, prop->preboot_ver,\n\t\t\t\tmin((int) (preboot_ver - prop->preboot_ver),\n\t\t\t\t\t\t\t\t\t31));\n\t\t\tdev_info(hdev->dev, \"%s\\n\", btl_ver);\n\t\t}\n\n\t\tpreboot_ver = extract_fw_ver_from_str(prop->preboot_ver);\n\t\tif (preboot_ver) {\n\t\t\tdev_info(hdev->dev, \"preboot version %s\\n\",\n\t\t\t\t\t\t\t\tpreboot_ver);\n\t\t\tkfree(preboot_ver);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void hl_fw_preboot_update_state(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu32 cpu_boot_dev_sts0, cpu_boot_dev_sts1;\n\n\tcpu_boot_dev_sts0 = prop->fw_preboot_cpu_boot_dev_sts0;\n\tcpu_boot_dev_sts1 = prop->fw_preboot_cpu_boot_dev_sts1;\n\n\t \n\tprop->hard_reset_done_by_fw = !!(cpu_boot_dev_sts0 & CPU_BOOT_DEV_STS0_FW_HARD_RST_EN);\n\n\tprop->fw_security_enabled = !!(cpu_boot_dev_sts0 & CPU_BOOT_DEV_STS0_SECURITY_EN);\n\n\tdev_dbg(hdev->dev, \"Firmware preboot boot device status0 %#x\\n\",\n\t\t\t\t\t\t\tcpu_boot_dev_sts0);\n\n\tdev_dbg(hdev->dev, \"Firmware preboot boot device status1 %#x\\n\",\n\t\t\t\t\t\t\tcpu_boot_dev_sts1);\n\n\tdev_dbg(hdev->dev, \"Firmware preboot hard-reset is %s\\n\",\n\t\t\tprop->hard_reset_done_by_fw ? \"enabled\" : \"disabled\");\n\n\tdev_dbg(hdev->dev, \"firmware-level security is %s\\n\",\n\t\t\tprop->fw_security_enabled ? \"enabled\" : \"disabled\");\n\n\tdev_dbg(hdev->dev, \"GIC controller is %s\\n\",\n\t\t\tprop->gic_interrupts_enable ? \"enabled\" : \"disabled\");\n}\n\nstatic int hl_fw_static_read_preboot_status(struct hl_device *hdev)\n{\n\tint rc;\n\n\trc = hl_fw_static_read_device_fw_version(hdev, FW_COMP_PREBOOT);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nint hl_fw_read_preboot_status(struct hl_device *hdev)\n{\n\tint rc;\n\n\tif (!(hdev->fw_components & FW_TYPE_PREBOOT_CPU))\n\t\treturn 0;\n\n\t \n\thdev->asic_funcs->init_firmware_preload_params(hdev);\n\n\t \n\trc = hl_fw_read_preboot_caps(hdev);\n\tif (rc)\n\t\treturn rc;\n\n\thl_fw_preboot_update_state(hdev);\n\n\t \n\tif (hdev->asic_prop.dynamic_fw_load)\n\t\treturn 0;\n\n\treturn hl_fw_static_read_preboot_status(hdev);\n}\n\n \nstatic char *hl_dynamic_fw_status_str[COMMS_STS_INVLD_LAST] = {\n\t[COMMS_STS_NOOP] = \"NOOP\",\n\t[COMMS_STS_ACK] = \"ACK\",\n\t[COMMS_STS_OK] = \"OK\",\n\t[COMMS_STS_ERR] = \"ERR\",\n\t[COMMS_STS_VALID_ERR] = \"VALID_ERR\",\n\t[COMMS_STS_TIMEOUT_ERR] = \"TIMEOUT_ERR\",\n};\n\n \nstatic void hl_fw_dynamic_report_error_status(struct hl_device *hdev,\n\t\t\t\t\t\tu32 status,\n\t\t\t\t\t\tenum comms_sts expected_status)\n{\n\tenum comms_sts comm_status =\n\t\t\t\tFIELD_GET(COMMS_STATUS_STATUS_MASK, status);\n\n\tif (comm_status < COMMS_STS_INVLD_LAST)\n\t\tdev_err(hdev->dev, \"Device status %s, expected status: %s\\n\",\n\t\t\t\thl_dynamic_fw_status_str[comm_status],\n\t\t\t\thl_dynamic_fw_status_str[expected_status]);\n\telse\n\t\tdev_err(hdev->dev, \"Device status unknown %d, expected status: %s\\n\",\n\t\t\t\tcomm_status,\n\t\t\t\thl_dynamic_fw_status_str[expected_status]);\n}\n\n \nstatic void hl_fw_dynamic_send_cmd(struct hl_device *hdev,\n\t\t\t\tstruct fw_load_mgr *fw_loader,\n\t\t\t\tenum comms_cmd cmd, unsigned int size)\n{\n\tstruct cpu_dyn_regs *dyn_regs;\n\tu32 val;\n\n\tdyn_regs = &fw_loader->dynamic_loader.comm_desc.cpu_dyn_regs;\n\n\tval = FIELD_PREP(COMMS_COMMAND_CMD_MASK, cmd);\n\tval |= FIELD_PREP(COMMS_COMMAND_SIZE_MASK, size);\n\n\ttrace_habanalabs_comms_send_cmd(hdev->dev, comms_cmd_str_arr[cmd]);\n\tWREG32(le32_to_cpu(dyn_regs->kmd_msg_to_cpu), val);\n}\n\n \nstatic int hl_fw_dynamic_extract_fw_response(struct hl_device *hdev,\n\t\t\t\t\t\tstruct fw_load_mgr *fw_loader,\n\t\t\t\t\t\tstruct fw_response *response,\n\t\t\t\t\t\tu32 status)\n{\n\tresponse->status = FIELD_GET(COMMS_STATUS_STATUS_MASK, status);\n\tresponse->ram_offset = FIELD_GET(COMMS_STATUS_OFFSET_MASK, status) <<\n\t\t\t\t\t\tCOMMS_STATUS_OFFSET_ALIGN_SHIFT;\n\tresponse->ram_type = FIELD_GET(COMMS_STATUS_RAM_TYPE_MASK, status);\n\n\tif ((response->ram_type != COMMS_SRAM) &&\n\t\t\t\t\t(response->ram_type != COMMS_DRAM)) {\n\t\tdev_err(hdev->dev, \"FW status: invalid RAM type %u\\n\",\n\t\t\t\t\t\t\tresponse->ram_type);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hl_fw_dynamic_wait_for_status(struct hl_device *hdev,\n\t\t\t\t\t\tstruct fw_load_mgr *fw_loader,\n\t\t\t\t\t\tenum comms_sts expected_status,\n\t\t\t\t\t\tu32 timeout)\n{\n\tstruct cpu_dyn_regs *dyn_regs;\n\tu32 status;\n\tint rc;\n\n\tdyn_regs = &fw_loader->dynamic_loader.comm_desc.cpu_dyn_regs;\n\n\ttrace_habanalabs_comms_wait_status(hdev->dev, comms_sts_str_arr[expected_status]);\n\n\t \n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tle32_to_cpu(dyn_regs->cpu_cmd_status_to_host),\n\t\tstatus,\n\t\tFIELD_GET(COMMS_STATUS_STATUS_MASK, status) == expected_status,\n\t\thdev->fw_comms_poll_interval_usec,\n\t\ttimeout);\n\n\tif (rc) {\n\t\thl_fw_dynamic_report_error_status(hdev, status,\n\t\t\t\t\t\t\texpected_status);\n\t\treturn -EIO;\n\t}\n\n\ttrace_habanalabs_comms_wait_status_done(hdev->dev, comms_sts_str_arr[expected_status]);\n\n\t \n\tif (expected_status == COMMS_STS_NOOP)\n\t\treturn 0;\n\n\trc = hl_fw_dynamic_extract_fw_response(hdev, fw_loader,\n\t\t\t\t\t&fw_loader->dynamic_loader.response,\n\t\t\t\t\tstatus);\n\treturn rc;\n}\n\n \nstatic int hl_fw_dynamic_send_clear_cmd(struct hl_device *hdev,\n\t\t\t\t\t\tstruct fw_load_mgr *fw_loader)\n{\n\thl_fw_dynamic_send_cmd(hdev, fw_loader, COMMS_CLR_STS, 0);\n\n\treturn hl_fw_dynamic_wait_for_status(hdev, fw_loader, COMMS_STS_NOOP,\n\t\t\t\t\t\t\tfw_loader->cpu_timeout);\n}\n\n \nint hl_fw_dynamic_send_protocol_cmd(struct hl_device *hdev,\n\t\t\t\tstruct fw_load_mgr *fw_loader,\n\t\t\t\tenum comms_cmd cmd, unsigned int size,\n\t\t\t\tbool wait_ok, u32 timeout)\n{\n\tint rc;\n\n\ttrace_habanalabs_comms_protocol_cmd(hdev->dev, comms_cmd_str_arr[cmd]);\n\n\t \n\trc = hl_fw_dynamic_send_clear_cmd(hdev, fw_loader);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\thl_fw_dynamic_send_cmd(hdev, fw_loader, cmd, size);\n\n\t \n\trc = hl_fw_dynamic_wait_for_status(hdev, fw_loader, COMMS_STS_ACK,\n\t\t\t\t\t\t\t\ttimeout);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = hl_fw_dynamic_send_clear_cmd(hdev, fw_loader);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\thl_fw_dynamic_send_cmd(hdev, fw_loader, COMMS_NOOP, 0);\n\n\tif (!wait_ok)\n\t\treturn 0;\n\n\trc = hl_fw_dynamic_wait_for_status(hdev, fw_loader, COMMS_STS_OK,\n\t\t\t\t\t\t\t\ttimeout);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = hl_fw_dynamic_send_clear_cmd(hdev, fw_loader);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\thl_fw_dynamic_send_cmd(hdev, fw_loader, COMMS_NOOP, 0);\n\n\treturn 0;\n}\n\n \nstatic u32 hl_fw_compat_crc32(u8 *data, size_t size)\n{\n\treturn ~crc32_le(~((u32)0), data, size);\n}\n\n \nstatic int hl_fw_dynamic_validate_memory_bound(struct hl_device *hdev,\n\t\t\t\t\t\tu64 addr, size_t size,\n\t\t\t\t\t\tstruct pci_mem_region *region)\n{\n\tu64 end_addr;\n\n\t \n\tend_addr = addr + size;\n\tif (end_addr >= region->region_base + region->region_size) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"dynamic FW load: memory transfer end address out of memory region bounds. addr: %llx\\n\",\n\t\t\t\t\t\t\tend_addr);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (end_addr >= region->region_base - region->offset_in_bar +\n\t\t\t\t\t\t\tregion->bar_size) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"FW image beyond PCI BAR bounds\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hl_fw_dynamic_validate_descriptor(struct hl_device *hdev,\n\t\t\t\t\tstruct fw_load_mgr *fw_loader,\n\t\t\t\t\tstruct lkd_fw_comms_desc *fw_desc)\n{\n\tstruct pci_mem_region *region;\n\tenum pci_region region_id;\n\tsize_t data_size;\n\tu32 data_crc32;\n\tu8 *data_ptr;\n\tu64 addr;\n\tint rc;\n\n\tif (le32_to_cpu(fw_desc->header.magic) != HL_COMMS_DESC_MAGIC)\n\t\tdev_dbg(hdev->dev, \"Invalid magic for dynamic FW descriptor (%x)\\n\",\n\t\t\t\tfw_desc->header.magic);\n\n\tif (fw_desc->header.version != HL_COMMS_DESC_VER)\n\t\tdev_dbg(hdev->dev, \"Invalid version for dynamic FW descriptor (%x)\\n\",\n\t\t\t\tfw_desc->header.version);\n\n\t \n\tdata_ptr = (u8 *)fw_desc + sizeof(struct comms_desc_header);\n\tdata_size = le16_to_cpu(fw_desc->header.size);\n\n\tdata_crc32 = hl_fw_compat_crc32(data_ptr, data_size);\n\tif (data_crc32 != le32_to_cpu(fw_desc->header.crc32)) {\n\t\tdev_err(hdev->dev, \"CRC32 mismatch for dynamic FW descriptor (%x:%x)\\n\",\n\t\t\tdata_crc32, fw_desc->header.crc32);\n\t\treturn -EIO;\n\t}\n\n\t \n\taddr = le64_to_cpu(fw_desc->img_addr);\n\tregion_id = hl_get_pci_memory_region(hdev, addr);\n\tif ((region_id != PCI_REGION_SRAM) && ((region_id != PCI_REGION_DRAM))) {\n\t\tdev_err(hdev->dev, \"Invalid region to copy FW image address=%llx\\n\", addr);\n\t\treturn -EIO;\n\t}\n\n\tregion = &hdev->pci_mem_region[region_id];\n\n\t \n\tfw_loader->dynamic_loader.image_region = region;\n\n\t \n\trc = hl_fw_dynamic_validate_memory_bound(hdev, addr,\n\t\t\t\t\tfw_loader->dynamic_loader.fw_image_size,\n\t\t\t\t\tregion);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"invalid mem transfer request for FW image\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tfw_loader->dynamic_loader.fw_desc_valid = true;\n\n\treturn 0;\n}\n\nstatic int hl_fw_dynamic_validate_response(struct hl_device *hdev,\n\t\t\t\t\t\tstruct fw_response *response,\n\t\t\t\t\t\tstruct pci_mem_region *region)\n{\n\tu64 device_addr;\n\tint rc;\n\n\tdevice_addr = region->region_base + response->ram_offset;\n\n\t \n\trc = hl_fw_dynamic_validate_memory_bound(hdev, device_addr,\n\t\t\t\t\tsizeof(struct lkd_fw_comms_desc),\n\t\t\t\t\tregion);\n\treturn rc;\n}\n\n \nstatic void hl_fw_dynamic_read_descriptor_msg(struct hl_device *hdev,\n\t\t\t\t\tstruct lkd_fw_comms_desc *fw_desc)\n{\n\tint i;\n\tchar *msg;\n\n\tfor (i = 0 ; i < LKD_FW_ASCII_MSG_MAX ; i++) {\n\t\tif (!fw_desc->ascii_msg[i].valid)\n\t\t\treturn;\n\n\t\t \n\t\tmsg = fw_desc->ascii_msg[i].msg;\n\t\tmsg[LKD_FW_ASCII_MSG_MAX_LEN - 1] = '\\0';\n\n\t\tswitch (fw_desc->ascii_msg[i].msg_lvl) {\n\t\tcase LKD_FW_ASCII_MSG_ERR:\n\t\t\tdev_err(hdev->dev, \"fw: %s\", fw_desc->ascii_msg[i].msg);\n\t\t\tbreak;\n\t\tcase LKD_FW_ASCII_MSG_WRN:\n\t\t\tdev_warn(hdev->dev, \"fw: %s\", fw_desc->ascii_msg[i].msg);\n\t\t\tbreak;\n\t\tcase LKD_FW_ASCII_MSG_INF:\n\t\t\tdev_info(hdev->dev, \"fw: %s\", fw_desc->ascii_msg[i].msg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(hdev->dev, \"fw: %s\", fw_desc->ascii_msg[i].msg);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic int hl_fw_dynamic_read_and_validate_descriptor(struct hl_device *hdev,\n\t\t\t\t\t\tstruct fw_load_mgr *fw_loader)\n{\n\tstruct lkd_fw_comms_desc *fw_desc;\n\tstruct pci_mem_region *region;\n\tstruct fw_response *response;\n\tvoid *temp_fw_desc;\n\tvoid __iomem *src;\n\tu16 fw_data_size;\n\tenum pci_region region_id;\n\tint rc;\n\n\tfw_desc = &fw_loader->dynamic_loader.comm_desc;\n\tresponse = &fw_loader->dynamic_loader.response;\n\n\tregion_id = (response->ram_type == COMMS_SRAM) ?\n\t\t\t\t\tPCI_REGION_SRAM : PCI_REGION_DRAM;\n\n\tregion = &hdev->pci_mem_region[region_id];\n\n\trc = hl_fw_dynamic_validate_response(hdev, response, region);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"invalid mem transfer request for FW descriptor\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tfw_loader->dynamic_loader.fw_desc_valid = false;\n\tsrc = hdev->pcie_bar[region->bar_id] + region->offset_in_bar +\n\t\t\t\t\t\t\tresponse->ram_offset;\n\n\t \n\tmemcpy_fromio(fw_desc, src, sizeof(struct lkd_fw_comms_desc));\n\tfw_data_size = le16_to_cpu(fw_desc->header.size);\n\n\ttemp_fw_desc = vzalloc(sizeof(struct comms_desc_header) + fw_data_size);\n\tif (!temp_fw_desc)\n\t\treturn -ENOMEM;\n\n\tmemcpy_fromio(temp_fw_desc, src, sizeof(struct comms_desc_header) + fw_data_size);\n\n\trc = hl_fw_dynamic_validate_descriptor(hdev, fw_loader,\n\t\t\t\t\t(struct lkd_fw_comms_desc *) temp_fw_desc);\n\n\tif (!rc)\n\t\thl_fw_dynamic_read_descriptor_msg(hdev, temp_fw_desc);\n\n\tvfree(temp_fw_desc);\n\n\treturn rc;\n}\n\n \nstatic int hl_fw_dynamic_request_descriptor(struct hl_device *hdev,\n\t\t\t\t\t\tstruct fw_load_mgr *fw_loader,\n\t\t\t\t\t\tsize_t next_image_size)\n{\n\tint rc;\n\n\trc = hl_fw_dynamic_send_protocol_cmd(hdev, fw_loader, COMMS_PREP_DESC,\n\t\t\t\t\t\tnext_image_size, true,\n\t\t\t\t\t\tfw_loader->cpu_timeout);\n\tif (rc)\n\t\treturn rc;\n\n\treturn hl_fw_dynamic_read_and_validate_descriptor(hdev, fw_loader);\n}\n\n \nstatic int hl_fw_dynamic_read_device_fw_version(struct hl_device *hdev,\n\t\t\t\t\tenum hl_fw_component fwc,\n\t\t\t\t\tconst char *fw_version)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tchar *preboot_ver, *boot_ver;\n\tchar btl_ver[32];\n\tint rc;\n\n\tswitch (fwc) {\n\tcase FW_COMP_BOOT_FIT:\n\t\tstrscpy(prop->uboot_ver, fw_version, VERSION_MAX_LEN);\n\t\tboot_ver = extract_fw_ver_from_str(prop->uboot_ver);\n\t\tif (boot_ver) {\n\t\t\tdev_info(hdev->dev, \"boot-fit version %s\\n\", boot_ver);\n\t\t\tkfree(boot_ver);\n\t\t}\n\n\t\tbreak;\n\tcase FW_COMP_PREBOOT:\n\t\tstrscpy(prop->preboot_ver, fw_version, VERSION_MAX_LEN);\n\t\tpreboot_ver = strnstr(prop->preboot_ver, \"Preboot\", VERSION_MAX_LEN);\n\t\tdev_info(hdev->dev, \"preboot full version: '%s'\\n\", preboot_ver);\n\n\t\tif (preboot_ver && preboot_ver != prop->preboot_ver) {\n\t\t\tstrscpy(btl_ver, prop->preboot_ver,\n\t\t\t\tmin((int) (preboot_ver - prop->preboot_ver), 31));\n\t\t\tdev_info(hdev->dev, \"%s\\n\", btl_ver);\n\t\t}\n\n\t\trc = hl_get_sw_major_minor_subminor(hdev, preboot_ver);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tpreboot_ver = extract_fw_ver_from_str(prop->preboot_ver);\n\t\tif (preboot_ver) {\n\t\t\trc = hl_get_preboot_major_minor(hdev, preboot_ver);\n\t\t\tkfree(preboot_ver);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(hdev->dev, \"Undefined FW component: %d\\n\", fwc);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hl_fw_dynamic_copy_image(struct hl_device *hdev,\n\t\t\t\t\t\tconst struct firmware *fw,\n\t\t\t\t\t\tstruct fw_load_mgr *fw_loader)\n{\n\tstruct lkd_fw_comms_desc *fw_desc;\n\tstruct pci_mem_region *region;\n\tvoid __iomem *dest;\n\tu64 addr;\n\tint rc;\n\n\tfw_desc = &fw_loader->dynamic_loader.comm_desc;\n\taddr = le64_to_cpu(fw_desc->img_addr);\n\n\t \n\tregion = fw_loader->dynamic_loader.image_region;\n\n\tdest = hdev->pcie_bar[region->bar_id] + region->offset_in_bar +\n\t\t\t\t\t(addr - region->region_base);\n\n\trc = hl_fw_copy_fw_to_device(hdev, fw, dest,\n\t\t\t\t\tfw_loader->boot_fit_img.src_off,\n\t\t\t\t\tfw_loader->boot_fit_img.copy_size);\n\n\treturn rc;\n}\n\n \nstatic int hl_fw_dynamic_copy_msg(struct hl_device *hdev,\n\t\tstruct lkd_msg_comms *msg, struct fw_load_mgr *fw_loader)\n{\n\tstruct lkd_fw_comms_desc *fw_desc;\n\tstruct pci_mem_region *region;\n\tvoid __iomem *dest;\n\tu64 addr;\n\tint rc;\n\n\tfw_desc = &fw_loader->dynamic_loader.comm_desc;\n\taddr = le64_to_cpu(fw_desc->img_addr);\n\n\t \n\tregion = fw_loader->dynamic_loader.image_region;\n\n\tdest = hdev->pcie_bar[region->bar_id] + region->offset_in_bar +\n\t\t\t\t\t(addr - region->region_base);\n\n\trc = hl_fw_copy_msg_to_device(hdev, msg, dest, 0, 0);\n\n\treturn rc;\n}\n\n \nstatic void hl_fw_boot_fit_update_state(struct hl_device *hdev,\n\t\t\t\t\t\tu32 cpu_boot_dev_sts0_reg,\n\t\t\t\t\t\tu32 cpu_boot_dev_sts1_reg)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\n\thdev->fw_loader.fw_comp_loaded |= FW_TYPE_BOOT_CPU;\n\n\t \n\tif (prop->fw_preboot_cpu_boot_dev_sts0 & CPU_BOOT_DEV_STS0_ENABLED) {\n\t\tprop->fw_bootfit_cpu_boot_dev_sts0 =\n\t\t\t\tRREG32(cpu_boot_dev_sts0_reg);\n\n\t\tprop->hard_reset_done_by_fw = !!(prop->fw_bootfit_cpu_boot_dev_sts0 &\n\t\t\t\t\t\t\tCPU_BOOT_DEV_STS0_FW_HARD_RST_EN);\n\n\t\tdev_dbg(hdev->dev, \"Firmware boot CPU status0 %#x\\n\",\n\t\t\t\t\tprop->fw_bootfit_cpu_boot_dev_sts0);\n\t}\n\n\tif (prop->fw_cpu_boot_dev_sts1_valid) {\n\t\tprop->fw_bootfit_cpu_boot_dev_sts1 =\n\t\t\t\tRREG32(cpu_boot_dev_sts1_reg);\n\n\t\tdev_dbg(hdev->dev, \"Firmware boot CPU status1 %#x\\n\",\n\t\t\t\t\tprop->fw_bootfit_cpu_boot_dev_sts1);\n\t}\n\n\tdev_dbg(hdev->dev, \"Firmware boot CPU hard-reset is %s\\n\",\n\t\t\tprop->hard_reset_done_by_fw ? \"enabled\" : \"disabled\");\n}\n\nstatic void hl_fw_dynamic_update_linux_interrupt_if(struct hl_device *hdev)\n{\n\tstruct cpu_dyn_regs *dyn_regs =\n\t\t\t&hdev->fw_loader.dynamic_loader.comm_desc.cpu_dyn_regs;\n\n\t \n\tif (!hdev->asic_prop.gic_interrupts_enable &&\n\t\t\t!(hdev->asic_prop.fw_app_cpu_boot_dev_sts0 &\n\t\t\t\tCPU_BOOT_DEV_STS0_MULTI_IRQ_POLL_EN)) {\n\t\tdyn_regs->gic_host_halt_irq = dyn_regs->gic_host_pi_upd_irq;\n\t\tdyn_regs->gic_host_ints_irq = dyn_regs->gic_host_pi_upd_irq;\n\n\t\tdev_warn(hdev->dev,\n\t\t\t\"Using a single interrupt interface towards cpucp\");\n\t}\n}\n \nstatic int hl_fw_dynamic_load_image(struct hl_device *hdev,\n\t\t\t\t\t\tstruct fw_load_mgr *fw_loader,\n\t\t\t\t\t\tenum hl_fw_component load_fwc,\n\t\t\t\t\t\tu32 img_ld_timeout)\n{\n\tenum hl_fw_component cur_fwc;\n\tconst struct firmware *fw;\n\tchar *fw_name;\n\tint rc = 0;\n\n\t \n\tif (load_fwc == FW_COMP_BOOT_FIT) {\n\t\tcur_fwc = FW_COMP_PREBOOT;\n\t\tfw_name = fw_loader->boot_fit_img.image_name;\n\t} else {\n\t\tcur_fwc = FW_COMP_BOOT_FIT;\n\t\tfw_name = fw_loader->linux_img.image_name;\n\t}\n\n\t \n\trc = hl_request_fw(hdev, &fw, fw_name);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tfw_loader->dynamic_loader.fw_image_size = fw->size;\n\n\trc = hl_fw_dynamic_request_descriptor(hdev, fw_loader, fw->size);\n\tif (rc)\n\t\tgoto release_fw;\n\n\t \n\trc = hl_fw_dynamic_read_device_fw_version(hdev, cur_fwc,\n\t\t\t\tfw_loader->dynamic_loader.comm_desc.cur_fw_ver);\n\tif (rc)\n\t\tgoto release_fw;\n\n\t \n\trc = hl_fw_dynamic_copy_image(hdev, fw, fw_loader);\n\tif (rc)\n\t\tgoto release_fw;\n\n\trc = hl_fw_dynamic_send_protocol_cmd(hdev, fw_loader, COMMS_DATA_RDY,\n\t\t\t\t\t\t0, true,\n\t\t\t\t\t\tfw_loader->cpu_timeout);\n\tif (rc)\n\t\tgoto release_fw;\n\n\trc = hl_fw_dynamic_send_protocol_cmd(hdev, fw_loader, COMMS_EXEC,\n\t\t\t\t\t\t0, false,\n\t\t\t\t\t\timg_ld_timeout);\n\nrelease_fw:\n\thl_release_firmware(fw);\n\treturn rc;\n}\n\nstatic int hl_fw_dynamic_wait_for_boot_fit_active(struct hl_device *hdev,\n\t\t\t\t\tstruct fw_load_mgr *fw_loader)\n{\n\tstruct dynamic_fw_load_mgr *dyn_loader;\n\tu32 status;\n\tint rc;\n\n\tdyn_loader = &fw_loader->dynamic_loader;\n\n\t \n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tle32_to_cpu(dyn_loader->comm_desc.cpu_dyn_regs.cpu_boot_status),\n\t\tstatus,\n\t\t(status == CPU_BOOT_STATUS_READY_TO_BOOT) ||\n\t\t(status == CPU_BOOT_STATUS_SRAM_AVAIL),\n\t\thdev->fw_poll_interval_usec,\n\t\tdyn_loader->wait_for_bl_timeout);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to wait for boot (status = %d)\\n\", status);\n\t\treturn rc;\n\t}\n\n\tdev_dbg(hdev->dev, \"uboot status = %d\\n\", status);\n\treturn 0;\n}\n\nstatic int hl_fw_dynamic_wait_for_linux_active(struct hl_device *hdev,\n\t\t\t\t\t\tstruct fw_load_mgr *fw_loader)\n{\n\tstruct dynamic_fw_load_mgr *dyn_loader;\n\tu32 status;\n\tint rc;\n\n\tdyn_loader = &fw_loader->dynamic_loader;\n\n\t \n\n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tle32_to_cpu(dyn_loader->comm_desc.cpu_dyn_regs.cpu_boot_status),\n\t\tstatus,\n\t\t(status == CPU_BOOT_STATUS_SRAM_AVAIL),\n\t\thdev->fw_poll_interval_usec,\n\t\tfw_loader->cpu_timeout);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to wait for Linux (status = %d)\\n\", status);\n\t\treturn rc;\n\t}\n\n\tdev_dbg(hdev->dev, \"Boot status = %d\\n\", status);\n\treturn 0;\n}\n\n \nstatic void hl_fw_linux_update_state(struct hl_device *hdev,\n\t\t\t\t\t\tu32 cpu_boot_dev_sts0_reg,\n\t\t\t\t\t\tu32 cpu_boot_dev_sts1_reg)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\n\thdev->fw_loader.fw_comp_loaded |= FW_TYPE_LINUX;\n\n\t \n\tif (prop->fw_cpu_boot_dev_sts0_valid) {\n\t\tprop->fw_app_cpu_boot_dev_sts0 = RREG32(cpu_boot_dev_sts0_reg);\n\n\t\tprop->hard_reset_done_by_fw = !!(prop->fw_app_cpu_boot_dev_sts0 &\n\t\t\t\t\t\t\tCPU_BOOT_DEV_STS0_FW_HARD_RST_EN);\n\n\t\tif (prop->fw_app_cpu_boot_dev_sts0 &\n\t\t\t\tCPU_BOOT_DEV_STS0_GIC_PRIVILEGED_EN)\n\t\t\tprop->gic_interrupts_enable = false;\n\n\t\tdev_dbg(hdev->dev,\n\t\t\t\"Firmware application CPU status0 %#x\\n\",\n\t\t\tprop->fw_app_cpu_boot_dev_sts0);\n\n\t\tdev_dbg(hdev->dev, \"GIC controller is %s\\n\",\n\t\t\t\tprop->gic_interrupts_enable ?\n\t\t\t\t\t\t\"enabled\" : \"disabled\");\n\t}\n\n\tif (prop->fw_cpu_boot_dev_sts1_valid) {\n\t\tprop->fw_app_cpu_boot_dev_sts1 = RREG32(cpu_boot_dev_sts1_reg);\n\n\t\tdev_dbg(hdev->dev,\n\t\t\t\"Firmware application CPU status1 %#x\\n\",\n\t\t\tprop->fw_app_cpu_boot_dev_sts1);\n\t}\n\n\tdev_dbg(hdev->dev, \"Firmware application CPU hard-reset is %s\\n\",\n\t\t\tprop->hard_reset_done_by_fw ? \"enabled\" : \"disabled\");\n\n\tdev_info(hdev->dev, \"Successfully loaded firmware to device\\n\");\n}\n\n \nstatic int hl_fw_dynamic_send_msg(struct hl_device *hdev,\n\t\tstruct fw_load_mgr *fw_loader, u8 msg_type, void *data)\n{\n\tstruct lkd_msg_comms *msg;\n\tint rc;\n\n\tmsg = kzalloc(sizeof(*msg), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\t \n\tmsg->header.type = msg_type;\n\tmsg->header.size = cpu_to_le16(sizeof(struct comms_msg_header));\n\tmsg->header.magic = cpu_to_le32(HL_COMMS_MSG_MAGIC);\n\n\tswitch (msg_type) {\n\tcase HL_COMMS_RESET_CAUSE_TYPE:\n\t\tmsg->reset_cause = *(__u8 *) data;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(hdev->dev,\n\t\t\t\"Send COMMS message - invalid message type %u\\n\",\n\t\t\tmsg_type);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = hl_fw_dynamic_request_descriptor(hdev, fw_loader,\n\t\t\tsizeof(struct lkd_msg_comms));\n\tif (rc)\n\t\tgoto out;\n\n\t \n\trc = hl_fw_dynamic_copy_msg(hdev, msg, fw_loader);\n\tif (rc)\n\t\tgoto out;\n\n\trc = hl_fw_dynamic_send_protocol_cmd(hdev, fw_loader, COMMS_DATA_RDY,\n\t\t\t\t\t\t0, true,\n\t\t\t\t\t\tfw_loader->cpu_timeout);\n\tif (rc)\n\t\tgoto out;\n\n\trc = hl_fw_dynamic_send_protocol_cmd(hdev, fw_loader, COMMS_EXEC,\n\t\t\t\t\t\t0, true,\n\t\t\t\t\t\tfw_loader->cpu_timeout);\n\nout:\n\tkfree(msg);\n\treturn rc;\n}\n\n \nstatic int hl_fw_dynamic_init_cpu(struct hl_device *hdev,\n\t\t\t\t\tstruct fw_load_mgr *fw_loader)\n{\n\tstruct cpu_dyn_regs *dyn_regs;\n\tint rc, fw_error_rc;\n\n\tdev_info(hdev->dev,\n\t\t\"Loading %sfirmware to device, may take some time...\\n\",\n\t\thdev->asic_prop.fw_security_enabled ? \"secured \" : \"\");\n\n\t \n\tfw_loader->dynamic_loader.fw_desc_valid = false;\n\n\t \n\tdyn_regs = &fw_loader->dynamic_loader.comm_desc.cpu_dyn_regs;\n\n\trc = hl_fw_dynamic_send_protocol_cmd(hdev, fw_loader, COMMS_RST_STATE,\n\t\t\t\t\t\t0, true,\n\t\t\t\t\t\tfw_loader->cpu_timeout);\n\tif (rc)\n\t\tgoto protocol_err;\n\n\tif (hdev->reset_info.curr_reset_cause) {\n\t\trc = hl_fw_dynamic_send_msg(hdev, fw_loader,\n\t\t\t\tHL_COMMS_RESET_CAUSE_TYPE, &hdev->reset_info.curr_reset_cause);\n\t\tif (rc)\n\t\t\tgoto protocol_err;\n\n\t\t \n\t\thdev->reset_info.curr_reset_cause = HL_RESET_CAUSE_UNKNOWN;\n\t}\n\n\tif (!(hdev->fw_components & FW_TYPE_BOOT_CPU)) {\n\t\tstruct lkd_fw_binning_info *binning_info;\n\n\t\trc = hl_fw_dynamic_request_descriptor(hdev, fw_loader, 0);\n\t\tif (rc)\n\t\t\tgoto protocol_err;\n\n\t\t \n\t\trc = hl_fw_dynamic_read_device_fw_version(hdev, FW_COMP_PREBOOT,\n\t\t\t\tfw_loader->dynamic_loader.comm_desc.cur_fw_ver);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tif (hdev->support_preboot_binning) {\n\t\t\tbinning_info = &fw_loader->dynamic_loader.comm_desc.binning_info;\n\t\t\thdev->tpc_binning = le64_to_cpu(binning_info->tpc_mask_l);\n\t\t\thdev->dram_binning = le32_to_cpu(binning_info->dram_mask);\n\t\t\thdev->edma_binning = le32_to_cpu(binning_info->edma_mask);\n\t\t\thdev->decoder_binning = le32_to_cpu(binning_info->dec_mask);\n\t\t\thdev->rotator_binning = le32_to_cpu(binning_info->rot_mask);\n\n\t\t\trc = hdev->asic_funcs->set_dram_properties(hdev);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\trc = hdev->asic_funcs->set_binning_masks(hdev);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tdev_dbg(hdev->dev,\n\t\t\t\t\"Read binning masks: tpc: 0x%llx, dram: 0x%llx, edma: 0x%x, dec: 0x%x, rot:0x%x\\n\",\n\t\t\t\thdev->tpc_binning, hdev->dram_binning, hdev->edma_binning,\n\t\t\t\thdev->decoder_binning, hdev->rotator_binning);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\trc = hl_fw_dynamic_load_image(hdev, fw_loader, FW_COMP_BOOT_FIT,\n\t\t\t\t\t\tfw_loader->boot_fit_timeout);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to load boot fit\\n\");\n\t\tgoto protocol_err;\n\t}\n\n\trc = hl_fw_dynamic_wait_for_boot_fit_active(hdev, fw_loader);\n\tif (rc)\n\t\tgoto protocol_err;\n\n\thl_fw_boot_fit_update_state(hdev,\n\t\t\tle32_to_cpu(dyn_regs->cpu_boot_dev_sts0),\n\t\t\tle32_to_cpu(dyn_regs->cpu_boot_dev_sts1));\n\n\t \n\tif (hdev->pldm && !(hdev->fw_components & FW_TYPE_LINUX))\n\t\treturn 0;\n\n\t \n\thdev->asic_funcs->init_cpu_scrambler_dram(hdev);\n\n\tif (!(hdev->fw_components & FW_TYPE_LINUX)) {\n\t\tdev_info(hdev->dev, \"Skip loading Linux F/W\\n\");\n\t\treturn 0;\n\t}\n\n\tif (fw_loader->skip_bmc) {\n\t\trc = hl_fw_dynamic_send_protocol_cmd(hdev, fw_loader,\n\t\t\t\t\t\t\tCOMMS_SKIP_BMC, 0,\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\tfw_loader->cpu_timeout);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev, \"failed to load boot fit\\n\");\n\t\t\tgoto protocol_err;\n\t\t}\n\t}\n\n\t \n\trc = hl_fw_dynamic_load_image(hdev, fw_loader, FW_COMP_LINUX,\n\t\t\t\t\t\t\tfw_loader->cpu_timeout);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to load Linux\\n\");\n\t\tgoto protocol_err;\n\t}\n\n\trc = hl_fw_dynamic_wait_for_linux_active(hdev, fw_loader);\n\tif (rc)\n\t\tgoto protocol_err;\n\n\thl_fw_linux_update_state(hdev,\n\t\t\t\tle32_to_cpu(dyn_regs->cpu_boot_dev_sts0),\n\t\t\t\tle32_to_cpu(dyn_regs->cpu_boot_dev_sts1));\n\n\thl_fw_dynamic_update_linux_interrupt_if(hdev);\n\nprotocol_err:\n\tif (fw_loader->dynamic_loader.fw_desc_valid) {\n\t\tfw_error_rc = fw_read_errors(hdev, le32_to_cpu(dyn_regs->cpu_boot_err0),\n\t\t\t\tle32_to_cpu(dyn_regs->cpu_boot_err1),\n\t\t\t\tle32_to_cpu(dyn_regs->cpu_boot_dev_sts0),\n\t\t\t\tle32_to_cpu(dyn_regs->cpu_boot_dev_sts1));\n\n\t\tif (fw_error_rc)\n\t\t\treturn fw_error_rc;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int hl_fw_static_init_cpu(struct hl_device *hdev,\n\t\t\t\t\tstruct fw_load_mgr *fw_loader)\n{\n\tu32 cpu_msg_status_reg, cpu_timeout, msg_to_cpu_reg, status;\n\tu32 cpu_boot_dev_status0_reg, cpu_boot_dev_status1_reg;\n\tstruct static_fw_load_mgr *static_loader;\n\tu32 cpu_boot_status_reg;\n\tint rc;\n\n\tif (!(hdev->fw_components & FW_TYPE_BOOT_CPU))\n\t\treturn 0;\n\n\t \n\tcpu_timeout = fw_loader->cpu_timeout;\n\n\t \n\tstatic_loader = &fw_loader->static_loader;\n\tcpu_msg_status_reg = static_loader->cpu_cmd_status_to_host_reg;\n\tmsg_to_cpu_reg = static_loader->kmd_msg_to_cpu_reg;\n\tcpu_boot_dev_status0_reg = static_loader->cpu_boot_dev_status0_reg;\n\tcpu_boot_dev_status1_reg = static_loader->cpu_boot_dev_status1_reg;\n\tcpu_boot_status_reg = static_loader->cpu_boot_status_reg;\n\n\tdev_info(hdev->dev, \"Going to wait for device boot (up to %lds)\\n\",\n\t\tcpu_timeout / USEC_PER_SEC);\n\n\t \n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tcpu_boot_status_reg,\n\t\tstatus,\n\t\tstatus == CPU_BOOT_STATUS_WAITING_FOR_BOOT_FIT,\n\t\thdev->fw_poll_interval_usec,\n\t\tfw_loader->boot_fit_timeout);\n\n\tif (rc) {\n\t\tdev_dbg(hdev->dev,\n\t\t\t\"No boot fit request received (status = %d), resuming boot\\n\", status);\n\t} else {\n\t\trc = hdev->asic_funcs->load_boot_fit_to_device(hdev);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\t \n\t\tWREG32(cpu_msg_status_reg, CPU_MSG_CLR);\n\n\t\t \n\t\tWREG32(msg_to_cpu_reg, KMD_MSG_FIT_RDY);\n\n\t\t \n\t\trc = hl_poll_timeout(\n\t\t\thdev,\n\t\t\tcpu_msg_status_reg,\n\t\t\tstatus,\n\t\t\tstatus == CPU_MSG_OK,\n\t\t\thdev->fw_poll_interval_usec,\n\t\t\tfw_loader->boot_fit_timeout);\n\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Timeout waiting for boot fit load ack (status = %d)\\n\", status);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tWREG32(msg_to_cpu_reg, KMD_MSG_NA);\n\t}\n\n\t \n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tcpu_boot_status_reg,\n\t\tstatus,\n\t\t(status == CPU_BOOT_STATUS_DRAM_RDY) ||\n\t\t(status == CPU_BOOT_STATUS_NIC_FW_RDY) ||\n\t\t(status == CPU_BOOT_STATUS_READY_TO_BOOT) ||\n\t\t(status == CPU_BOOT_STATUS_SRAM_AVAIL),\n\t\thdev->fw_poll_interval_usec,\n\t\tcpu_timeout);\n\n\tdev_dbg(hdev->dev, \"uboot status = %d\\n\", status);\n\n\t \n\thl_fw_static_read_device_fw_version(hdev, FW_COMP_BOOT_FIT);\n\n\t \n\thl_fw_boot_fit_update_state(hdev, cpu_boot_dev_status0_reg,\n\t\t\t\t\t\tcpu_boot_dev_status1_reg);\n\n\tif (rc) {\n\t\tdetect_cpu_boot_status(hdev, status);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\thdev->asic_funcs->init_cpu_scrambler_dram(hdev);\n\n\tif (!(hdev->fw_components & FW_TYPE_LINUX)) {\n\t\tdev_info(hdev->dev, \"Skip loading Linux F/W\\n\");\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (status == CPU_BOOT_STATUS_SRAM_AVAIL) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tdev_info(hdev->dev,\n\t\t\"Loading firmware to device, may take some time...\\n\");\n\n\trc = hdev->asic_funcs->load_firmware_to_device(hdev);\n\tif (rc)\n\t\tgoto out;\n\n\tif (fw_loader->skip_bmc) {\n\t\tWREG32(msg_to_cpu_reg, KMD_MSG_SKIP_BMC);\n\n\t\trc = hl_poll_timeout(\n\t\t\thdev,\n\t\t\tcpu_boot_status_reg,\n\t\t\tstatus,\n\t\t\t(status == CPU_BOOT_STATUS_BMC_WAITING_SKIPPED),\n\t\t\thdev->fw_poll_interval_usec,\n\t\t\tcpu_timeout);\n\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Failed to get ACK on skipping BMC (status = %d)\\n\",\n\t\t\t\tstatus);\n\t\t\tWREG32(msg_to_cpu_reg, KMD_MSG_NA);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tWREG32(msg_to_cpu_reg, KMD_MSG_FIT_RDY);\n\n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tcpu_boot_status_reg,\n\t\tstatus,\n\t\t(status == CPU_BOOT_STATUS_SRAM_AVAIL),\n\t\thdev->fw_poll_interval_usec,\n\t\tcpu_timeout);\n\n\t \n\tWREG32(msg_to_cpu_reg, KMD_MSG_NA);\n\n\tif (rc) {\n\t\tif (status == CPU_BOOT_STATUS_FIT_CORRUPTED)\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Device reports FIT image is corrupted\\n\");\n\t\telse\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Failed to load firmware to device (status = %d)\\n\",\n\t\t\t\tstatus);\n\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\trc = fw_read_errors(hdev, fw_loader->static_loader.boot_err0_reg,\n\t\t\t\t\tfw_loader->static_loader.boot_err1_reg,\n\t\t\t\t\tcpu_boot_dev_status0_reg,\n\t\t\t\t\tcpu_boot_dev_status1_reg);\n\tif (rc)\n\t\treturn rc;\n\n\thl_fw_linux_update_state(hdev, cpu_boot_dev_status0_reg,\n\t\t\t\t\t\tcpu_boot_dev_status1_reg);\n\n\treturn 0;\n\nout:\n\tfw_read_errors(hdev, fw_loader->static_loader.boot_err0_reg,\n\t\t\t\t\tfw_loader->static_loader.boot_err1_reg,\n\t\t\t\t\tcpu_boot_dev_status0_reg,\n\t\t\t\t\tcpu_boot_dev_status1_reg);\n\n\treturn rc;\n}\n\n \nint hl_fw_init_cpu(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct fw_load_mgr *fw_loader = &hdev->fw_loader;\n\n\treturn  prop->dynamic_fw_load ?\n\t\t\thl_fw_dynamic_init_cpu(hdev, fw_loader) :\n\t\t\thl_fw_static_init_cpu(hdev, fw_loader);\n}\n\nvoid hl_fw_set_pll_profile(struct hl_device *hdev)\n{\n\thl_fw_set_frequency(hdev, hdev->asic_prop.clk_pll_index,\n\t\t\t\thdev->asic_prop.max_freq_value);\n}\n\nint hl_fw_get_clk_rate(struct hl_device *hdev, u32 *cur_clk, u32 *max_clk)\n{\n\tlong value;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\tif (!hdev->pdev) {\n\t\t*cur_clk = 0;\n\t\t*max_clk = 0;\n\t\treturn 0;\n\t}\n\n\tvalue = hl_fw_get_frequency(hdev, hdev->asic_prop.clk_pll_index, false);\n\n\tif (value < 0) {\n\t\tdev_err(hdev->dev, \"Failed to retrieve device max clock %ld\\n\", value);\n\t\treturn value;\n\t}\n\n\t*max_clk = (value / 1000 / 1000);\n\n\tvalue = hl_fw_get_frequency(hdev, hdev->asic_prop.clk_pll_index, true);\n\n\tif (value < 0) {\n\t\tdev_err(hdev->dev, \"Failed to retrieve device current clock %ld\\n\", value);\n\t\treturn value;\n\t}\n\n\t*cur_clk = (value / 1000 / 1000);\n\n\treturn 0;\n}\n\nlong hl_fw_get_frequency(struct hl_device *hdev, u32 pll_index, bool curr)\n{\n\tstruct cpucp_packet pkt;\n\tu32 used_pll_idx;\n\tu64 result;\n\tint rc;\n\n\trc = get_used_pll_index(hdev, pll_index, &used_pll_idx);\n\tif (rc)\n\t\treturn rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tif (curr)\n\t\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_FREQUENCY_CURR_GET <<\n\t\t\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\telse\n\t\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_FREQUENCY_GET << CPUCP_PKT_CTL_OPCODE_SHIFT);\n\n\tpkt.pll_index = cpu_to_le32((u32)used_pll_idx);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt), 0, &result);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to get frequency of PLL %d, error %d\\n\",\n\t\t\tused_pll_idx, rc);\n\t\treturn rc;\n\t}\n\n\treturn (long) result;\n}\n\nvoid hl_fw_set_frequency(struct hl_device *hdev, u32 pll_index, u64 freq)\n{\n\tstruct cpucp_packet pkt;\n\tu32 used_pll_idx;\n\tint rc;\n\n\trc = get_used_pll_index(hdev, pll_index, &used_pll_idx);\n\tif (rc)\n\t\treturn;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_FREQUENCY_SET << CPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.pll_index = cpu_to_le32((u32)used_pll_idx);\n\tpkt.value = cpu_to_le64(freq);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt), 0, NULL);\n\n\tif (rc)\n\t\tdev_err(hdev->dev, \"Failed to set frequency to PLL %d, error %d\\n\",\n\t\t\tused_pll_idx, rc);\n}\n\nlong hl_fw_get_max_power(struct hl_device *hdev)\n{\n\tstruct cpucp_packet pkt;\n\tu64 result;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_MAX_POWER_GET << CPUCP_PKT_CTL_OPCODE_SHIFT);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt), 0, &result);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to get max power, error %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn result;\n}\n\nvoid hl_fw_set_max_power(struct hl_device *hdev)\n{\n\tstruct cpucp_packet pkt;\n\tint rc;\n\n\t \n\tif (!hdev->pdev)\n\t\treturn;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_MAX_POWER_SET << CPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.value = cpu_to_le64(hdev->max_power);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt), 0, NULL);\n\n\tif (rc)\n\t\tdev_err(hdev->dev, \"Failed to set max power, error %d\\n\", rc);\n}\n\nstatic int hl_fw_get_sec_attest_data(struct hl_device *hdev, u32 packet_id, void *data, u32 size,\n\t\t\t\t\tu32 nonce, u32 timeout)\n{\n\tstruct cpucp_packet pkt = {};\n\tdma_addr_t req_dma_addr;\n\tvoid *req_cpu_addr;\n\tint rc;\n\n\treq_cpu_addr = hl_cpu_accessible_dma_pool_alloc(hdev, size, &req_dma_addr);\n\tif (!req_cpu_addr) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate DMA memory for CPU-CP packet %u\\n\", packet_id);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(data, 0, size);\n\n\tpkt.ctl = cpu_to_le32(packet_id << CPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.addr = cpu_to_le64(req_dma_addr);\n\tpkt.data_max_size = cpu_to_le32(size);\n\tpkt.nonce = cpu_to_le32(nonce);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\ttimeout, NULL);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to handle CPU-CP pkt %u, error %d\\n\", packet_id, rc);\n\t\tgoto out;\n\t}\n\n\tmemcpy(data, req_cpu_addr, size);\n\nout:\n\thl_cpu_accessible_dma_pool_free(hdev, size, req_cpu_addr);\n\n\treturn rc;\n}\n\nint hl_fw_get_sec_attest_info(struct hl_device *hdev, struct cpucp_sec_attest_info *sec_attest_info,\n\t\t\t\tu32 nonce)\n{\n\treturn hl_fw_get_sec_attest_data(hdev, CPUCP_PACKET_SEC_ATTEST_GET, sec_attest_info,\n\t\t\t\t\tsizeof(struct cpucp_sec_attest_info), nonce,\n\t\t\t\t\tHL_CPUCP_SEC_ATTEST_INFO_TINEOUT_USEC);\n}\n\nint hl_fw_send_generic_request(struct hl_device *hdev, enum hl_passthrough_type sub_opcode,\n\t\t\t\t\t\tdma_addr_t buff, u32 *size)\n{\n\tstruct cpucp_packet pkt = {};\n\tu64 result;\n\tint rc = 0;\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_GENERIC_PASSTHROUGH << CPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.addr = cpu_to_le64(buff);\n\tpkt.data_max_size = cpu_to_le32(*size);\n\tpkt.pkt_subidx = cpu_to_le32(sub_opcode);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *)&pkt, sizeof(pkt),\n\t\t\t\t\t\tHL_CPUCP_INFO_TIMEOUT_USEC, &result);\n\tif (rc)\n\t\tdev_err(hdev->dev, \"failed to send CPUCP data of generic fw pkt\\n\");\n\telse\n\t\tdev_dbg(hdev->dev, \"generic pkt was successful, result: 0x%llx\\n\", result);\n\n\t*size = (u32)result;\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}