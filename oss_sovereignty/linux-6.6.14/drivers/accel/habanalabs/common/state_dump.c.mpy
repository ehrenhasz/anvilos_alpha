{
  "module_name": "state_dump.c",
  "hash_id": "daff69254a739adc54bb177756e76d8fcdf487634372ff528f8985b820572e16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/common/state_dump.c",
  "human_readable_source": "\n\n \n\n#include <linux/vmalloc.h>\n#include <uapi/drm/habanalabs_accel.h>\n#include \"habanalabs.h\"\n\n \nchar *hl_format_as_binary(char *buf, size_t buf_len, u32 n)\n{\n\tint i;\n\tu32 bit;\n\tbool leading0 = true;\n\tchar *wrptr = buf;\n\n\tif (buf_len > 0 && buf_len < 3) {\n\t\t*wrptr = '\\0';\n\t\treturn buf;\n\t}\n\n\twrptr[0] = '0';\n\twrptr[1] = 'b';\n\twrptr += 2;\n\t \n\tbuf_len -= 3;\n\n\tfor (i = 0; i < sizeof(n) * BITS_PER_BYTE && buf_len; ++i, n <<= 1) {\n\t\t \n\t\tbit = n & (1 << (sizeof(n) * BITS_PER_BYTE - 1));\n\t\tbit = !!bit;\n\t\tleading0 &= !bit;\n\t\tif (!leading0) {\n\t\t\t*wrptr = '0' + bit;\n\t\t\t++wrptr;\n\t\t}\n\t}\n\n\t*wrptr = '\\0';\n\n\treturn buf;\n}\n\n \nstatic int resize_to_fit(char **buf, size_t *size, size_t desired_size)\n{\n\tchar *resized_buf;\n\tsize_t new_size;\n\n\tif (*size >= desired_size)\n\t\treturn 0;\n\n\t \n\tnew_size = max_t(size_t, PAGE_SIZE, round_up(desired_size, PAGE_SIZE));\n\tresized_buf = vmalloc(new_size);\n\tif (!resized_buf)\n\t\treturn -ENOMEM;\n\tmemcpy(resized_buf, *buf, *size);\n\tvfree(*buf);\n\t*buf = resized_buf;\n\t*size = new_size;\n\n\treturn 1;\n}\n\n \nint hl_snprintf_resize(char **buf, size_t *size, size_t *offset,\n\t\t\t   const char *format, ...)\n{\n\tva_list args;\n\tsize_t length;\n\tint rc;\n\n\tif (*buf == NULL && (*size != 0 || *offset != 0))\n\t\treturn -EINVAL;\n\n\tva_start(args, format);\n\tlength = vsnprintf(*buf + *offset, *size - *offset, format, args);\n\tva_end(args);\n\n\trc = resize_to_fit(buf, size, *offset + length + 1);\n\tif (rc < 0)\n\t\treturn rc;\n\telse if (rc > 0) {\n\t\t \n\t\tva_start(args, format);\n\t\tlength = vsnprintf(*buf + *offset, *size - *offset, format,\n\t\t\t\t   args);\n\t\tva_end(args);\n\t}\n\n\t*offset += length;\n\n\treturn 0;\n}\n\n \nconst char *hl_sync_engine_to_string(enum hl_sync_engine_type engine_type)\n{\n\tswitch (engine_type) {\n\tcase ENGINE_DMA:\n\t\treturn \"DMA\";\n\tcase ENGINE_MME:\n\t\treturn \"MME\";\n\tcase ENGINE_TPC:\n\t\treturn \"TPC\";\n\t}\n\treturn \"Invalid Engine Type\";\n}\n\n \nstatic int hl_print_resize_sync_engine(char **buf, size_t *size, size_t *offset,\n\t\t\t\tenum hl_sync_engine_type engine_type,\n\t\t\t\tu32 engine_id)\n{\n\treturn hl_snprintf_resize(buf, size, offset, \"%s%u\",\n\t\t\thl_sync_engine_to_string(engine_type), engine_id);\n}\n\n \nconst char *hl_state_dump_get_sync_name(struct hl_device *hdev, u32 sync_id)\n{\n\tstruct hl_state_dump_specs *sds = &hdev->state_dump_specs;\n\tstruct hl_hw_obj_name_entry *entry;\n\n\thash_for_each_possible(sds->so_id_to_str_tb, entry,\n\t\t\t\tnode, sync_id)\n\t\tif (sync_id == entry->id)\n\t\t\treturn entry->name;\n\n\treturn NULL;\n}\n\n \nconst char *hl_state_dump_get_monitor_name(struct hl_device *hdev,\n\t\t\t\t\tstruct hl_mon_state_dump *mon)\n{\n\tstruct hl_state_dump_specs *sds = &hdev->state_dump_specs;\n\tstruct hl_hw_obj_name_entry *entry;\n\n\thash_for_each_possible(sds->monitor_id_to_str_tb,\n\t\t\t\tentry, node, mon->id)\n\t\tif (mon->id == entry->id)\n\t\t\treturn entry->name;\n\n\treturn NULL;\n}\n\n \nvoid hl_state_dump_free_sync_to_engine_map(struct hl_sync_to_engine_map *map)\n{\n\tstruct hl_sync_to_engine_map_entry *entry;\n\tstruct hlist_node *tmp_node;\n\tint i;\n\n\thash_for_each_safe(map->tb, i, tmp_node, entry, node) {\n\t\thash_del(&entry->node);\n\t\tkfree(entry);\n\t}\n}\n\n \nstatic struct hl_sync_to_engine_map_entry *\nhl_state_dump_get_sync_to_engine(struct hl_sync_to_engine_map *map, u32 sync_id)\n{\n\tstruct hl_sync_to_engine_map_entry *entry;\n\n\thash_for_each_possible(map->tb, entry, node, sync_id)\n\t\tif (entry->sync_id == sync_id)\n\t\t\treturn entry;\n\treturn NULL;\n}\n\n \nstatic u32 *hl_state_dump_read_sync_objects(struct hl_device *hdev, u32 index)\n{\n\tstruct hl_state_dump_specs *sds = &hdev->state_dump_specs;\n\tu32 *sync_objects;\n\ts64 base_addr;  \n\tint i;\n\n\tbase_addr = sds->props[SP_SYNC_OBJ_BASE_ADDR] +\n\t\t\tsds->props[SP_NEXT_SYNC_OBJ_ADDR] * index;\n\n\tsync_objects = vmalloc(sds->props[SP_SYNC_OBJ_AMOUNT] * sizeof(u32));\n\tif (!sync_objects)\n\t\treturn NULL;\n\n\tfor (i = 0; i < sds->props[SP_SYNC_OBJ_AMOUNT]; ++i)\n\t\tsync_objects[i] = RREG32(base_addr + i * sizeof(u32));\n\n\treturn sync_objects;\n}\n\n \nstatic void hl_state_dump_free_sync_objects(u32 *sync_objects)\n{\n\tvfree(sync_objects);\n}\n\n\n \nstatic int\nhl_state_dump_print_syncs_single_block(struct hl_device *hdev, u32 index,\n\t\t\t\tchar **buf, size_t *size, size_t *offset,\n\t\t\t\tstruct hl_sync_to_engine_map *map)\n{\n\tstruct hl_state_dump_specs *sds = &hdev->state_dump_specs;\n\tconst char *sync_name;\n\tu32 *sync_objects = NULL;\n\tint rc = 0, i;\n\n\tif (sds->sync_namager_names) {\n\t\trc = hl_snprintf_resize(\n\t\t\tbuf, size, offset, \"%s\\n\",\n\t\t\tsds->sync_namager_names[index]);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tsync_objects = hl_state_dump_read_sync_objects(hdev, index);\n\tif (!sync_objects) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < sds->props[SP_SYNC_OBJ_AMOUNT]; ++i) {\n\t\tstruct hl_sync_to_engine_map_entry *entry;\n\t\tu64 sync_object_addr;\n\n\t\tif (!sync_objects[i])\n\t\t\tcontinue;\n\n\t\tsync_object_addr = sds->props[SP_SYNC_OBJ_BASE_ADDR] +\n\t\t\t\tsds->props[SP_NEXT_SYNC_OBJ_ADDR] * index +\n\t\t\t\ti * sizeof(u32);\n\n\t\trc = hl_snprintf_resize(buf, size, offset, \"sync id: %u\", i);\n\t\tif (rc)\n\t\t\tgoto free_sync_objects;\n\t\tsync_name = hl_state_dump_get_sync_name(hdev, i);\n\t\tif (sync_name) {\n\t\t\trc = hl_snprintf_resize(buf, size, offset, \" %s\",\n\t\t\t\t\t\tsync_name);\n\t\t\tif (rc)\n\t\t\t\tgoto free_sync_objects;\n\t\t}\n\t\trc = hl_snprintf_resize(buf, size, offset, \", value: %u\",\n\t\t\t\t\tsync_objects[i]);\n\t\tif (rc)\n\t\t\tgoto free_sync_objects;\n\n\t\t \n\t\tentry = hl_state_dump_get_sync_to_engine(map,\n\t\t\t(u32)sync_object_addr);\n\t\tif (entry) {\n\t\t\trc = hl_snprintf_resize(buf, size, offset,\n\t\t\t\t\t\t\", Engine: \");\n\t\t\tif (rc)\n\t\t\t\tgoto free_sync_objects;\n\t\t\trc = hl_print_resize_sync_engine(buf, size, offset,\n\t\t\t\t\t\tentry->engine_type,\n\t\t\t\t\t\tentry->engine_id);\n\t\t\tif (rc)\n\t\t\t\tgoto free_sync_objects;\n\t\t}\n\n\t\trc = hl_snprintf_resize(buf, size, offset, \"\\n\");\n\t\tif (rc)\n\t\t\tgoto free_sync_objects;\n\t}\n\nfree_sync_objects:\n\thl_state_dump_free_sync_objects(sync_objects);\nout:\n\treturn rc;\n}\n\n \nstatic int hl_state_dump_print_syncs(struct hl_device *hdev,\n\t\t\t\t\tchar **buf, size_t *size,\n\t\t\t\t\tsize_t *offset)\n\n{\n\tstruct hl_state_dump_specs *sds = &hdev->state_dump_specs;\n\tstruct hl_sync_to_engine_map *map;\n\tu32 index;\n\tint rc = 0;\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\trc = sds->funcs.gen_sync_to_engine_map(hdev, map);\n\tif (rc)\n\t\tgoto free_map_mem;\n\n\trc = hl_snprintf_resize(buf, size, offset, \"Non zero sync objects:\\n\");\n\tif (rc)\n\t\tgoto out;\n\n\tif (sds->sync_namager_names) {\n\t\tfor (index = 0; sds->sync_namager_names[index]; ++index) {\n\t\t\trc = hl_state_dump_print_syncs_single_block(\n\t\t\t\thdev, index, buf, size, offset, map);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tfor (index = 0; index < sds->props[SP_NUM_CORES]; ++index) {\n\t\t\trc = hl_state_dump_print_syncs_single_block(\n\t\t\t\thdev, index, buf, size, offset, map);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\thl_state_dump_free_sync_to_engine_map(map);\nfree_map_mem:\n\tkfree(map);\n\n\treturn rc;\n}\n\n \nstatic struct hl_mon_state_dump *\nhl_state_dump_alloc_read_sm_block_monitors(struct hl_device *hdev, u32 index)\n{\n\tstruct hl_state_dump_specs *sds = &hdev->state_dump_specs;\n\tstruct hl_mon_state_dump *monitors;\n\ts64 base_addr;  \n\tint i;\n\n\tmonitors = vmalloc(sds->props[SP_MONITORS_AMOUNT] *\n\t\t\t   sizeof(struct hl_mon_state_dump));\n\tif (!monitors)\n\t\treturn NULL;\n\n\tbase_addr = sds->props[SP_NEXT_SYNC_OBJ_ADDR] * index;\n\n\tfor (i = 0; i < sds->props[SP_MONITORS_AMOUNT]; ++i) {\n\t\tmonitors[i].id = i;\n\t\tmonitors[i].wr_addr_low =\n\t\t\tRREG32(base_addr + sds->props[SP_MON_OBJ_WR_ADDR_LOW] +\n\t\t\t\ti * sizeof(u32));\n\n\t\tmonitors[i].wr_addr_high =\n\t\t\tRREG32(base_addr + sds->props[SP_MON_OBJ_WR_ADDR_HIGH] +\n\t\t\t\ti * sizeof(u32));\n\n\t\tmonitors[i].wr_data =\n\t\t\tRREG32(base_addr + sds->props[SP_MON_OBJ_WR_DATA] +\n\t\t\t\ti * sizeof(u32));\n\n\t\tmonitors[i].arm_data =\n\t\t\tRREG32(base_addr + sds->props[SP_MON_OBJ_ARM_DATA] +\n\t\t\t\ti * sizeof(u32));\n\n\t\tmonitors[i].status =\n\t\t\tRREG32(base_addr + sds->props[SP_MON_OBJ_STATUS] +\n\t\t\t\ti * sizeof(u32));\n\t}\n\n\treturn monitors;\n}\n\n \nstatic void hl_state_dump_free_monitors(struct hl_mon_state_dump *monitors)\n{\n\tvfree(monitors);\n}\n\n \nstatic int hl_state_dump_print_monitors_single_block(struct hl_device *hdev,\n\t\t\t\t\t\tu32 index,\n\t\t\t\t\t\tchar **buf, size_t *size,\n\t\t\t\t\t\tsize_t *offset)\n{\n\tstruct hl_state_dump_specs *sds = &hdev->state_dump_specs;\n\tstruct hl_mon_state_dump *monitors = NULL;\n\tint rc = 0, i;\n\n\tif (sds->sync_namager_names) {\n\t\trc = hl_snprintf_resize(\n\t\t\tbuf, size, offset, \"%s\\n\",\n\t\t\tsds->sync_namager_names[index]);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tmonitors = hl_state_dump_alloc_read_sm_block_monitors(hdev, index);\n\tif (!monitors) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < sds->props[SP_MONITORS_AMOUNT]; ++i) {\n\t\tif (!(sds->funcs.monitor_valid(&monitors[i])))\n\t\t\tcontinue;\n\n\t\t \n\t\trc = sds->funcs.print_single_monitor(buf, size, offset, hdev,\n\t\t\t\t\t\t\t&monitors[i]);\n\t\tif (rc)\n\t\t\tgoto free_monitors;\n\n\t\thl_snprintf_resize(buf, size, offset, \"\\n\");\n\t}\n\nfree_monitors:\n\thl_state_dump_free_monitors(monitors);\nout:\n\treturn rc;\n}\n\n \nstatic int hl_state_dump_print_monitors(struct hl_device *hdev,\n\t\t\t\t\tchar **buf, size_t *size,\n\t\t\t\t\tsize_t *offset)\n{\n\tstruct hl_state_dump_specs *sds = &hdev->state_dump_specs;\n\tu32 index;\n\tint rc = 0;\n\n\trc = hl_snprintf_resize(buf, size, offset,\n\t\t\"Valid (armed) monitor objects:\\n\");\n\tif (rc)\n\t\tgoto out;\n\n\tif (sds->sync_namager_names) {\n\t\tfor (index = 0; sds->sync_namager_names[index]; ++index) {\n\t\t\trc = hl_state_dump_print_monitors_single_block(\n\t\t\t\thdev, index, buf, size, offset);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tfor (index = 0; index < sds->props[SP_NUM_CORES]; ++index) {\n\t\t\trc = hl_state_dump_print_monitors_single_block(\n\t\t\t\thdev, index, buf, size, offset);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn rc;\n}\n\n \nstatic int\nhl_state_dump_print_engine_fences(struct hl_device *hdev,\n\t\t\t\t  enum hl_sync_engine_type engine_type,\n\t\t\t\t  char **buf, size_t *size, size_t *offset)\n{\n\tstruct hl_state_dump_specs *sds = &hdev->state_dump_specs;\n\tint rc = 0, i, n_fences;\n\tu64 base_addr, next_fence;\n\n\tswitch (engine_type) {\n\tcase ENGINE_TPC:\n\t\tn_fences = sds->props[SP_NUM_OF_TPC_ENGINES];\n\t\tbase_addr = sds->props[SP_TPC0_CMDQ];\n\t\tnext_fence = sds->props[SP_NEXT_TPC];\n\t\tbreak;\n\tcase ENGINE_MME:\n\t\tn_fences = sds->props[SP_NUM_OF_MME_ENGINES];\n\t\tbase_addr = sds->props[SP_MME_CMDQ];\n\t\tnext_fence = sds->props[SP_NEXT_MME];\n\t\tbreak;\n\tcase ENGINE_DMA:\n\t\tn_fences = sds->props[SP_NUM_OF_DMA_ENGINES];\n\t\tbase_addr = sds->props[SP_DMA_CMDQ];\n\t\tnext_fence = sds->props[SP_DMA_QUEUES_OFFSET];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < n_fences; ++i) {\n\t\trc = sds->funcs.print_fences_single_engine(\n\t\t\thdev,\n\t\t\tbase_addr + next_fence * i +\n\t\t\t\tsds->props[SP_FENCE0_CNT_OFFSET],\n\t\t\tbase_addr + next_fence * i +\n\t\t\t\tsds->props[SP_CP_STS_OFFSET],\n\t\t\tengine_type, i, buf, size, offset);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}\n\n \nstatic int hl_state_dump_print_fences(struct hl_device *hdev, char **buf,\n\t\t\t\t      size_t *size, size_t *offset)\n{\n\tint rc = 0;\n\n\trc = hl_snprintf_resize(buf, size, offset, \"Valid (armed) fences:\\n\");\n\tif (rc)\n\t\tgoto out;\n\n\trc = hl_state_dump_print_engine_fences(hdev, ENGINE_TPC, buf, size, offset);\n\tif (rc)\n\t\tgoto out;\n\n\trc = hl_state_dump_print_engine_fences(hdev, ENGINE_MME, buf, size, offset);\n\tif (rc)\n\t\tgoto out;\n\n\trc = hl_state_dump_print_engine_fences(hdev, ENGINE_DMA, buf, size, offset);\n\tif (rc)\n\t\tgoto out;\n\nout:\n\treturn rc;\n}\n\n \nint hl_state_dump(struct hl_device *hdev)\n{\n\tchar *buf = NULL;\n\tsize_t offset = 0, size = 0;\n\tint rc;\n\n\trc = hl_snprintf_resize(&buf, &size, &offset,\n\t\t\t\t\"Timestamp taken on: %llu\\n\\n\",\n\t\t\t\tktime_to_ns(ktime_get()));\n\tif (rc)\n\t\tgoto err;\n\n\trc = hl_state_dump_print_syncs(hdev, &buf, &size, &offset);\n\tif (rc)\n\t\tgoto err;\n\n\thl_snprintf_resize(&buf, &size, &offset, \"\\n\");\n\n\trc = hl_state_dump_print_monitors(hdev, &buf, &size, &offset);\n\tif (rc)\n\t\tgoto err;\n\n\thl_snprintf_resize(&buf, &size, &offset, \"\\n\");\n\n\trc = hl_state_dump_print_fences(hdev, &buf, &size, &offset);\n\tif (rc)\n\t\tgoto err;\n\n\thl_snprintf_resize(&buf, &size, &offset, \"\\n\");\n\n\thl_debugfs_set_state_dump(hdev, buf, size);\n\n\treturn 0;\nerr:\n\tvfree(buf);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}