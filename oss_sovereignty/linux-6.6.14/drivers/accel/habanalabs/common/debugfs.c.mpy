{
  "module_name": "debugfs.c",
  "hash_id": "15ec4d92d8ecb7c38b16c4b449c9e5580c161efeccb4fc49d22277d2cfc35375",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/common/debugfs.c",
  "human_readable_source": "\n\n \n\n#include \"habanalabs.h\"\n#include \"../include/hw_ip/mmu/mmu_general.h\"\n\n#include <linux/pci.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/iommu.h>\n\n#define MMU_ADDR_BUF_SIZE\t40\n#define MMU_ASID_BUF_SIZE\t10\n#define MMU_KBUF_SIZE\t\t(MMU_ADDR_BUF_SIZE + MMU_ASID_BUF_SIZE)\n#define I2C_MAX_TRANSACTION_LEN\t8\n\nstatic struct dentry *hl_debug_root;\n\nstatic int hl_debugfs_i2c_read(struct hl_device *hdev, u8 i2c_bus, u8 i2c_addr,\n\t\t\t\tu8 i2c_reg, u8 i2c_len, u64 *val)\n{\n\tstruct cpucp_packet pkt;\n\tint rc;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -EBUSY;\n\n\tif (i2c_len > I2C_MAX_TRANSACTION_LEN) {\n\t\tdev_err(hdev->dev, \"I2C transaction length %u, exceeds maximum of %u\\n\",\n\t\t\t\ti2c_len, I2C_MAX_TRANSACTION_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_I2C_RD <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.i2c_bus = i2c_bus;\n\tpkt.i2c_addr = i2c_addr;\n\tpkt.i2c_reg = i2c_reg;\n\tpkt.i2c_len = i2c_len;\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, val);\n\tif (rc)\n\t\tdev_err(hdev->dev, \"Failed to read from I2C, error %d\\n\", rc);\n\n\treturn rc;\n}\n\nstatic int hl_debugfs_i2c_write(struct hl_device *hdev, u8 i2c_bus, u8 i2c_addr,\n\t\t\t\tu8 i2c_reg, u8 i2c_len, u64 val)\n{\n\tstruct cpucp_packet pkt;\n\tint rc;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -EBUSY;\n\n\tif (i2c_len > I2C_MAX_TRANSACTION_LEN) {\n\t\tdev_err(hdev->dev, \"I2C transaction length %u, exceeds maximum of %u\\n\",\n\t\t\t\ti2c_len, I2C_MAX_TRANSACTION_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_I2C_WR <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.i2c_bus = i2c_bus;\n\tpkt.i2c_addr = i2c_addr;\n\tpkt.i2c_reg = i2c_reg;\n\tpkt.i2c_len = i2c_len;\n\tpkt.value = cpu_to_le64(val);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, NULL);\n\n\tif (rc)\n\t\tdev_err(hdev->dev, \"Failed to write to I2C, error %d\\n\", rc);\n\n\treturn rc;\n}\n\nstatic void hl_debugfs_led_set(struct hl_device *hdev, u8 led, u8 state)\n{\n\tstruct cpucp_packet pkt;\n\tint rc;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_LED_SET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.led_index = cpu_to_le32(led);\n\tpkt.value = cpu_to_le64(state);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, NULL);\n\n\tif (rc)\n\t\tdev_err(hdev->dev, \"Failed to set LED %d, error %d\\n\", led, rc);\n}\n\nstatic int command_buffers_show(struct seq_file *s, void *data)\n{\n\tstruct hl_debugfs_entry *entry = s->private;\n\tstruct hl_dbg_device_entry *dev_entry = entry->dev_entry;\n\tstruct hl_cb *cb;\n\tbool first = true;\n\n\tspin_lock(&dev_entry->cb_spinlock);\n\n\tlist_for_each_entry(cb, &dev_entry->cb_list, debugfs_list) {\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t\tseq_puts(s, \"\\n\");\n\t\t\tseq_puts(s, \" CB ID   CTX ID   CB size    CB RefCnt    mmap?   CS counter\\n\");\n\t\t\tseq_puts(s, \"---------------------------------------------------------------\\n\");\n\t\t}\n\t\tseq_printf(s,\n\t\t\t\"   %03llu        %d    0x%08x      %d          %d          %d\\n\",\n\t\t\tcb->buf->handle, cb->ctx->asid, cb->size,\n\t\t\tkref_read(&cb->buf->refcount),\n\t\t\tatomic_read(&cb->buf->mmap), atomic_read(&cb->cs_cnt));\n\t}\n\n\tspin_unlock(&dev_entry->cb_spinlock);\n\n\tif (!first)\n\t\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\n\nstatic int command_submission_show(struct seq_file *s, void *data)\n{\n\tstruct hl_debugfs_entry *entry = s->private;\n\tstruct hl_dbg_device_entry *dev_entry = entry->dev_entry;\n\tstruct hl_cs *cs;\n\tbool first = true;\n\n\tspin_lock(&dev_entry->cs_spinlock);\n\n\tlist_for_each_entry(cs, &dev_entry->cs_list, debugfs_list) {\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t\tseq_puts(s, \"\\n\");\n\t\t\tseq_puts(s, \" CS ID   CS TYPE   CTX ASID   CS RefCnt   Submitted    Completed\\n\");\n\t\t\tseq_puts(s, \"----------------------------------------------------------------\\n\");\n\t\t}\n\t\tseq_printf(s,\n\t\t\t\"   %llu        %d          %d          %d           %d            %d\\n\",\n\t\t\tcs->sequence, cs->type, cs->ctx->asid,\n\t\t\tkref_read(&cs->refcount),\n\t\t\tcs->submitted, cs->completed);\n\t}\n\n\tspin_unlock(&dev_entry->cs_spinlock);\n\n\tif (!first)\n\t\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\n\nstatic int command_submission_jobs_show(struct seq_file *s, void *data)\n{\n\tstruct hl_debugfs_entry *entry = s->private;\n\tstruct hl_dbg_device_entry *dev_entry = entry->dev_entry;\n\tstruct hl_cs_job *job;\n\tbool first = true;\n\n\tspin_lock(&dev_entry->cs_job_spinlock);\n\n\tlist_for_each_entry(job, &dev_entry->cs_job_list, debugfs_list) {\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t\tseq_puts(s, \"\\n\");\n\t\t\tseq_puts(s, \" JOB ID   CS ID    CS TYPE    CTX ASID   JOB RefCnt   H/W Queue\\n\");\n\t\t\tseq_puts(s, \"---------------------------------------------------------------\\n\");\n\t\t}\n\t\tif (job->cs)\n\t\t\tseq_printf(s,\n\t\t\t\t\"   %02d      %llu        %d        %d          %d           %d\\n\",\n\t\t\t\tjob->id, job->cs->sequence, job->cs->type,\n\t\t\t\tjob->cs->ctx->asid, kref_read(&job->refcount),\n\t\t\t\tjob->hw_queue_id);\n\t\telse\n\t\t\tseq_printf(s,\n\t\t\t\t\"   %02d      0        0        %d          %d           %d\\n\",\n\t\t\t\tjob->id, HL_KERNEL_ASID_ID,\n\t\t\t\tkref_read(&job->refcount), job->hw_queue_id);\n\t}\n\n\tspin_unlock(&dev_entry->cs_job_spinlock);\n\n\tif (!first)\n\t\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\n\nstatic int userptr_show(struct seq_file *s, void *data)\n{\n\tstruct hl_debugfs_entry *entry = s->private;\n\tstruct hl_dbg_device_entry *dev_entry = entry->dev_entry;\n\tstruct hl_userptr *userptr;\n\tchar dma_dir[4][30] = {\"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t\"DMA_FROM_DEVICE\", \"DMA_NONE\"};\n\tbool first = true;\n\n\tspin_lock(&dev_entry->userptr_spinlock);\n\n\tlist_for_each_entry(userptr, &dev_entry->userptr_list, debugfs_list) {\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t\tseq_puts(s, \"\\n\");\n\t\t\tseq_puts(s, \" pid      user virtual address     size             dma dir\\n\");\n\t\t\tseq_puts(s, \"----------------------------------------------------------\\n\");\n\t\t}\n\t\tseq_printf(s, \" %-7d  0x%-14llx      %-10llu    %-30s\\n\",\n\t\t\t\tuserptr->pid, userptr->addr, userptr->size,\n\t\t\t\tdma_dir[userptr->dir]);\n\t}\n\n\tspin_unlock(&dev_entry->userptr_spinlock);\n\n\tif (!first)\n\t\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\n\nstatic int vm_show(struct seq_file *s, void *data)\n{\n\tstruct hl_debugfs_entry *entry = s->private;\n\tstruct hl_dbg_device_entry *dev_entry = entry->dev_entry;\n\tstruct hl_vm_hw_block_list_node *lnode;\n\tstruct hl_ctx *ctx;\n\tstruct hl_vm *vm;\n\tstruct hl_vm_hash_node *hnode;\n\tstruct hl_userptr *userptr;\n\tstruct hl_vm_phys_pg_pack *phys_pg_pack = NULL;\n\tstruct hl_va_range *va_range;\n\tstruct hl_vm_va_block *va_block;\n\tenum vm_type *vm_type;\n\tbool once = true;\n\tu64 j;\n\tint i;\n\n\tmutex_lock(&dev_entry->ctx_mem_hash_mutex);\n\n\tlist_for_each_entry(ctx, &dev_entry->ctx_mem_hash_list, debugfs_list) {\n\t\tonce = false;\n\t\tseq_puts(s, \"\\n\\n----------------------------------------------------\");\n\t\tseq_puts(s, \"\\n----------------------------------------------------\\n\\n\");\n\t\tseq_printf(s, \"ctx asid: %u\\n\", ctx->asid);\n\n\t\tseq_puts(s, \"\\nmappings:\\n\\n\");\n\t\tseq_puts(s, \"    virtual address        size          handle\\n\");\n\t\tseq_puts(s, \"----------------------------------------------------\\n\");\n\t\tmutex_lock(&ctx->mem_hash_lock);\n\t\thash_for_each(ctx->mem_hash, i, hnode, node) {\n\t\t\tvm_type = hnode->ptr;\n\n\t\t\tif (*vm_type == VM_TYPE_USERPTR) {\n\t\t\t\tuserptr = hnode->ptr;\n\t\t\t\tseq_printf(s,\n\t\t\t\t\t\"    0x%-14llx      %-10llu\\n\",\n\t\t\t\t\thnode->vaddr, userptr->size);\n\t\t\t} else {\n\t\t\t\tphys_pg_pack = hnode->ptr;\n\t\t\t\tseq_printf(s,\n\t\t\t\t\t\"    0x%-14llx      %-10llu       %-4u\\n\",\n\t\t\t\t\thnode->vaddr, phys_pg_pack->total_size,\n\t\t\t\t\tphys_pg_pack->handle);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ctx->mem_hash_lock);\n\n\t\tif (ctx->asid != HL_KERNEL_ASID_ID &&\n\t\t    !list_empty(&ctx->hw_block_mem_list)) {\n\t\t\tseq_puts(s, \"\\nhw_block mappings:\\n\\n\");\n\t\t\tseq_puts(s,\n\t\t\t\t\"    virtual address    block size    mapped size    HW block id\\n\");\n\t\t\tseq_puts(s,\n\t\t\t\t\"---------------------------------------------------------------\\n\");\n\t\t\tmutex_lock(&ctx->hw_block_list_lock);\n\t\t\tlist_for_each_entry(lnode, &ctx->hw_block_mem_list, node) {\n\t\t\t\tseq_printf(s,\n\t\t\t\t\t\"    0x%-14lx   %-6u        %-6u             %-9u\\n\",\n\t\t\t\t\tlnode->vaddr, lnode->block_size, lnode->mapped_size,\n\t\t\t\t\tlnode->id);\n\t\t\t}\n\t\t\tmutex_unlock(&ctx->hw_block_list_lock);\n\t\t}\n\n\t\tvm = &ctx->hdev->vm;\n\t\tspin_lock(&vm->idr_lock);\n\n\t\tif (!idr_is_empty(&vm->phys_pg_pack_handles))\n\t\t\tseq_puts(s, \"\\n\\nallocations:\\n\");\n\n\t\tidr_for_each_entry(&vm->phys_pg_pack_handles, phys_pg_pack, i) {\n\t\t\tif (phys_pg_pack->asid != ctx->asid)\n\t\t\t\tcontinue;\n\n\t\t\tseq_printf(s, \"\\nhandle: %u\\n\", phys_pg_pack->handle);\n\t\t\tseq_printf(s, \"page size: %u\\n\\n\",\n\t\t\t\t\t\tphys_pg_pack->page_size);\n\t\t\tseq_puts(s, \"   physical address\\n\");\n\t\t\tseq_puts(s, \"---------------------\\n\");\n\t\t\tfor (j = 0 ; j < phys_pg_pack->npages ; j++) {\n\t\t\t\tseq_printf(s, \"    0x%-14llx\\n\",\n\t\t\t\t\t\tphys_pg_pack->pages[j]);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&vm->idr_lock);\n\n\t}\n\n\tmutex_unlock(&dev_entry->ctx_mem_hash_mutex);\n\n\tctx = hl_get_compute_ctx(dev_entry->hdev);\n\tif (ctx) {\n\t\tseq_puts(s, \"\\nVA ranges:\\n\\n\");\n\t\tfor (i = HL_VA_RANGE_TYPE_HOST ; i < HL_VA_RANGE_TYPE_MAX ; ++i) {\n\t\t\tva_range = ctx->va_range[i];\n\t\t\tseq_printf(s, \"   va_range %d\\n\", i);\n\t\t\tseq_puts(s, \"---------------------\\n\");\n\t\t\tmutex_lock(&va_range->lock);\n\t\t\tlist_for_each_entry(va_block, &va_range->list, node) {\n\t\t\t\tseq_printf(s, \"%#16llx - %#16llx (%#llx)\\n\",\n\t\t\t\t\t   va_block->start, va_block->end,\n\t\t\t\t\t   va_block->size);\n\t\t\t}\n\t\t\tmutex_unlock(&va_range->lock);\n\t\t\tseq_puts(s, \"\\n\");\n\t\t}\n\t\thl_ctx_put(ctx);\n\t}\n\n\tif (!once)\n\t\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\n\nstatic int userptr_lookup_show(struct seq_file *s, void *data)\n{\n\tstruct hl_debugfs_entry *entry = s->private;\n\tstruct hl_dbg_device_entry *dev_entry = entry->dev_entry;\n\tstruct scatterlist *sg;\n\tstruct hl_userptr *userptr;\n\tbool first = true;\n\tu64 total_npages, npages, sg_start, sg_end;\n\tdma_addr_t dma_addr;\n\tint i;\n\n\tspin_lock(&dev_entry->userptr_spinlock);\n\n\tlist_for_each_entry(userptr, &dev_entry->userptr_list, debugfs_list) {\n\t\tif (dev_entry->userptr_lookup >= userptr->addr &&\n\t\tdev_entry->userptr_lookup < userptr->addr + userptr->size) {\n\t\t\ttotal_npages = 0;\n\t\t\tfor_each_sgtable_dma_sg(userptr->sgt, sg, i) {\n\t\t\t\tnpages = hl_get_sg_info(sg, &dma_addr);\n\t\t\t\tsg_start = userptr->addr +\n\t\t\t\t\ttotal_npages * PAGE_SIZE;\n\t\t\t\tsg_end = userptr->addr +\n\t\t\t\t\t(total_npages + npages) * PAGE_SIZE;\n\n\t\t\t\tif (dev_entry->userptr_lookup >= sg_start &&\n\t\t\t\t    dev_entry->userptr_lookup < sg_end) {\n\t\t\t\t\tdma_addr += (dev_entry->userptr_lookup -\n\t\t\t\t\t\t\tsg_start);\n\t\t\t\t\tif (first) {\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\tseq_puts(s, \"\\n\");\n\t\t\t\t\t\tseq_puts(s, \" user virtual address         dma address       pid        region start     region size\\n\");\n\t\t\t\t\t\tseq_puts(s, \"---------------------------------------------------------------------------------------\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tseq_printf(s, \" 0x%-18llx  0x%-16llx  %-8u  0x%-16llx %-12llu\\n\",\n\t\t\t\t\t\tdev_entry->userptr_lookup,\n\t\t\t\t\t\t(u64)dma_addr, userptr->pid,\n\t\t\t\t\t\tuserptr->addr, userptr->size);\n\t\t\t\t}\n\t\t\t\ttotal_npages += npages;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(&dev_entry->userptr_spinlock);\n\n\tif (!first)\n\t\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t userptr_lookup_write(struct file *file, const char __user *buf,\n\t\tsize_t count, loff_t *f_pos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct hl_debugfs_entry *entry = s->private;\n\tstruct hl_dbg_device_entry *dev_entry = entry->dev_entry;\n\tssize_t rc;\n\tu64 value;\n\n\trc = kstrtoull_from_user(buf, count, 16, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tdev_entry->userptr_lookup = value;\n\n\treturn count;\n}\n\nstatic int mmu_show(struct seq_file *s, void *data)\n{\n\tstruct hl_debugfs_entry *entry = s->private;\n\tstruct hl_dbg_device_entry *dev_entry = entry->dev_entry;\n\tstruct hl_device *hdev = dev_entry->hdev;\n\tstruct hl_ctx *ctx;\n\tstruct hl_mmu_hop_info hops_info = {0};\n\tu64 virt_addr = dev_entry->mmu_addr, phys_addr;\n\tint i;\n\n\tif (dev_entry->mmu_asid == HL_KERNEL_ASID_ID)\n\t\tctx = hdev->kernel_ctx;\n\telse\n\t\tctx = hl_get_compute_ctx(hdev);\n\n\tif (!ctx) {\n\t\tdev_err(hdev->dev, \"no ctx available\\n\");\n\t\treturn 0;\n\t}\n\n\tif (hl_mmu_get_tlb_info(ctx, virt_addr, &hops_info)) {\n\t\tdev_err(hdev->dev, \"virt addr 0x%llx is not mapped to phys addr\\n\",\n\t\t\t\tvirt_addr);\n\t\tgoto put_ctx;\n\t}\n\n\thl_mmu_va_to_pa(ctx, virt_addr, &phys_addr);\n\n\tif (hops_info.scrambled_vaddr &&\n\t\t(dev_entry->mmu_addr != hops_info.scrambled_vaddr))\n\t\tseq_printf(s,\n\t\t\t\"asid: %u, virt_addr: 0x%llx, scrambled virt_addr: 0x%llx,\\nphys_addr: 0x%llx, scrambled_phys_addr: 0x%llx\\n\",\n\t\t\tdev_entry->mmu_asid, dev_entry->mmu_addr,\n\t\t\thops_info.scrambled_vaddr,\n\t\t\thops_info.unscrambled_paddr, phys_addr);\n\telse\n\t\tseq_printf(s,\n\t\t\t\"asid: %u, virt_addr: 0x%llx, phys_addr: 0x%llx\\n\",\n\t\t\tdev_entry->mmu_asid, dev_entry->mmu_addr, phys_addr);\n\n\tfor (i = 0 ; i < hops_info.used_hops ; i++) {\n\t\tseq_printf(s, \"hop%d_addr: 0x%llx\\n\",\n\t\t\t\ti, hops_info.hop_info[i].hop_addr);\n\t\tseq_printf(s, \"hop%d_pte_addr: 0x%llx\\n\",\n\t\t\t\ti, hops_info.hop_info[i].hop_pte_addr);\n\t\tseq_printf(s, \"hop%d_pte: 0x%llx\\n\",\n\t\t\t\ti, hops_info.hop_info[i].hop_pte_val);\n\t}\n\nput_ctx:\n\tif (dev_entry->mmu_asid != HL_KERNEL_ASID_ID)\n\t\thl_ctx_put(ctx);\n\n\treturn 0;\n}\n\nstatic ssize_t mmu_asid_va_write(struct file *file, const char __user *buf,\n\t\tsize_t count, loff_t *f_pos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct hl_debugfs_entry *entry = s->private;\n\tstruct hl_dbg_device_entry *dev_entry = entry->dev_entry;\n\tstruct hl_device *hdev = dev_entry->hdev;\n\tchar kbuf[MMU_KBUF_SIZE];\n\tchar *c;\n\tssize_t rc;\n\n\tif (count > sizeof(kbuf) - 1)\n\t\tgoto err;\n\tif (copy_from_user(kbuf, buf, count))\n\t\tgoto err;\n\tkbuf[count] = 0;\n\n\tc = strchr(kbuf, ' ');\n\tif (!c)\n\t\tgoto err;\n\t*c = '\\0';\n\n\trc = kstrtouint(kbuf, 10, &dev_entry->mmu_asid);\n\tif (rc)\n\t\tgoto err;\n\n\tif (strncmp(c+1, \"0x\", 2))\n\t\tgoto err;\n\trc = kstrtoull(c+3, 16, &dev_entry->mmu_addr);\n\tif (rc)\n\t\tgoto err;\n\n\treturn count;\n\nerr:\n\tdev_err(hdev->dev, \"usage: echo <asid> <0xaddr> > mmu\\n\");\n\n\treturn -EINVAL;\n}\n\nstatic int mmu_ack_error(struct seq_file *s, void *data)\n{\n\tstruct hl_debugfs_entry *entry = s->private;\n\tstruct hl_dbg_device_entry *dev_entry = entry->dev_entry;\n\tstruct hl_device *hdev = dev_entry->hdev;\n\tint rc;\n\n\tif (!dev_entry->mmu_cap_mask) {\n\t\tdev_err(hdev->dev, \"mmu_cap_mask is not set\\n\");\n\t\tgoto err;\n\t}\n\n\trc = hdev->asic_funcs->ack_mmu_errors(hdev, dev_entry->mmu_cap_mask);\n\tif (rc)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\treturn -EINVAL;\n}\n\nstatic ssize_t mmu_ack_error_value_write(struct file *file,\n\t\tconst char __user *buf,\n\t\tsize_t count, loff_t *f_pos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct hl_debugfs_entry *entry = s->private;\n\tstruct hl_dbg_device_entry *dev_entry = entry->dev_entry;\n\tstruct hl_device *hdev = dev_entry->hdev;\n\tchar kbuf[MMU_KBUF_SIZE];\n\tssize_t rc;\n\n\tif (count > sizeof(kbuf) - 1)\n\t\tgoto err;\n\n\tif (copy_from_user(kbuf, buf, count))\n\t\tgoto err;\n\n\tkbuf[count] = 0;\n\n\tif (strncmp(kbuf, \"0x\", 2))\n\t\tgoto err;\n\n\trc = kstrtoull(kbuf, 16, &dev_entry->mmu_cap_mask);\n\tif (rc)\n\t\tgoto err;\n\n\treturn count;\nerr:\n\tdev_err(hdev->dev, \"usage: echo <0xmmu_cap_mask > > mmu_error\\n\");\n\n\treturn -EINVAL;\n}\n\nstatic int engines_show(struct seq_file *s, void *data)\n{\n\tstruct hl_debugfs_entry *entry = s->private;\n\tstruct hl_dbg_device_entry *dev_entry = entry->dev_entry;\n\tstruct hl_device *hdev = dev_entry->hdev;\n\tstruct engines_data eng_data;\n\n\tif (hdev->reset_info.in_reset) {\n\t\tdev_warn_ratelimited(hdev->dev,\n\t\t\t\t\"Can't check device idle during reset\\n\");\n\t\treturn 0;\n\t}\n\n\teng_data.actual_size = 0;\n\teng_data.allocated_buf_size = HL_ENGINES_DATA_MAX_SIZE;\n\teng_data.buf = vmalloc(eng_data.allocated_buf_size);\n\tif (!eng_data.buf)\n\t\treturn -ENOMEM;\n\n\thdev->asic_funcs->is_device_idle(hdev, NULL, 0, &eng_data);\n\n\tif (eng_data.actual_size > eng_data.allocated_buf_size) {\n\t\tdev_err(hdev->dev,\n\t\t\t\t\"Engines data size (%d Bytes) is bigger than allocated size (%u Bytes)\\n\",\n\t\t\t\teng_data.actual_size, eng_data.allocated_buf_size);\n\t\tvfree(eng_data.buf);\n\t\treturn -ENOMEM;\n\t}\n\n\tseq_write(s, eng_data.buf, eng_data.actual_size);\n\n\tvfree(eng_data.buf);\n\n\treturn 0;\n}\n\nstatic ssize_t hl_memory_scrub(struct file *f, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tu64 val = hdev->memory_scrub_val;\n\tint rc;\n\n\tif (!hl_device_operational(hdev, NULL)) {\n\t\tdev_warn_ratelimited(hdev->dev, \"Can't scrub memory, device is not operational\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmutex_lock(&hdev->fpriv_list_lock);\n\tif (hdev->is_compute_ctx_active) {\n\t\tmutex_unlock(&hdev->fpriv_list_lock);\n\t\tdev_err(hdev->dev, \"can't scrub dram, context exist\\n\");\n\t\treturn -EBUSY;\n\t}\n\thdev->is_in_dram_scrub = true;\n\tmutex_unlock(&hdev->fpriv_list_lock);\n\n\trc = hdev->asic_funcs->scrub_device_dram(hdev, val);\n\n\tmutex_lock(&hdev->fpriv_list_lock);\n\thdev->is_in_dram_scrub = false;\n\tmutex_unlock(&hdev->fpriv_list_lock);\n\n\tif (rc)\n\t\treturn rc;\n\treturn count;\n}\n\nstatic bool hl_is_device_va(struct hl_device *hdev, u64 addr)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\n\tif (prop->dram_supports_virtual_memory &&\n\t\t(addr >= prop->dmmu.start_addr && addr < prop->dmmu.end_addr))\n\t\treturn true;\n\n\tif (addr >= prop->pmmu.start_addr &&\n\t\taddr < prop->pmmu.end_addr)\n\t\treturn true;\n\n\tif (addr >= prop->pmmu_huge.start_addr &&\n\t\taddr < prop->pmmu_huge.end_addr)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool hl_is_device_internal_memory_va(struct hl_device *hdev, u64 addr,\n\t\t\t\t\t\tu32 size)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu64 dram_start_addr, dram_end_addr;\n\n\tif (prop->dram_supports_virtual_memory) {\n\t\tdram_start_addr = prop->dmmu.start_addr;\n\t\tdram_end_addr = prop->dmmu.end_addr;\n\t} else {\n\t\tdram_start_addr = prop->dram_base_address;\n\t\tdram_end_addr = prop->dram_end_address;\n\t}\n\n\tif (hl_mem_area_inside_range(addr, size, dram_start_addr,\n\t\t\t\t\tdram_end_addr))\n\t\treturn true;\n\n\tif (hl_mem_area_inside_range(addr, size, prop->sram_base_address,\n\t\t\t\t\tprop->sram_end_address))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int device_va_to_pa(struct hl_device *hdev, u64 virt_addr, u32 size,\n\t\t\tu64 *phys_addr)\n{\n\tstruct hl_vm_phys_pg_pack *phys_pg_pack;\n\tstruct hl_ctx *ctx;\n\tstruct hl_vm_hash_node *hnode;\n\tu64 end_address, range_size;\n\tstruct hl_userptr *userptr;\n\tenum vm_type *vm_type;\n\tbool valid = false;\n\tint i, rc = 0;\n\n\tctx = hl_get_compute_ctx(hdev);\n\n\tif (!ctx) {\n\t\tdev_err(hdev->dev, \"no ctx available\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmutex_lock(&ctx->mem_hash_lock);\n\thash_for_each(ctx->mem_hash, i, hnode, node) {\n\t\tvm_type = hnode->ptr;\n\n\t\tif (*vm_type == VM_TYPE_USERPTR) {\n\t\t\tuserptr = hnode->ptr;\n\t\t\trange_size = userptr->size;\n\t\t} else {\n\t\t\tphys_pg_pack = hnode->ptr;\n\t\t\trange_size = phys_pg_pack->total_size;\n\t\t}\n\n\t\tend_address = virt_addr + size;\n\t\tif ((virt_addr >= hnode->vaddr) &&\n\t\t\t\t(end_address <= hnode->vaddr + range_size)) {\n\t\t\tvalid = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ctx->mem_hash_lock);\n\n\tif (!valid) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"virt addr 0x%llx is not mapped\\n\",\n\t\t\tvirt_addr);\n\t\trc = -EINVAL;\n\t\tgoto put_ctx;\n\t}\n\n\trc = hl_mmu_va_to_pa(ctx, virt_addr, phys_addr);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"virt addr 0x%llx is not mapped to phys addr\\n\",\n\t\t\tvirt_addr);\n\t\trc = -EINVAL;\n\t}\n\nput_ctx:\n\thl_ctx_put(ctx);\n\n\treturn rc;\n}\n\nstatic int hl_access_dev_mem_by_region(struct hl_device *hdev, u64 addr,\n\t\tu64 *val, enum debugfs_access_type acc_type, bool *found)\n{\n\tsize_t acc_size = (acc_type == DEBUGFS_READ64 || acc_type == DEBUGFS_WRITE64) ?\n\t\tsizeof(u64) : sizeof(u32);\n\tstruct pci_mem_region *mem_reg;\n\tint i;\n\n\tfor (i = 0; i < PCI_REGION_NUMBER; i++) {\n\t\tmem_reg = &hdev->pci_mem_region[i];\n\t\tif (!mem_reg->used)\n\t\t\tcontinue;\n\t\tif (addr >= mem_reg->region_base &&\n\t\t\taddr <= mem_reg->region_base + mem_reg->region_size - acc_size) {\n\t\t\t*found = true;\n\t\t\treturn hdev->asic_funcs->access_dev_mem(hdev, i, addr, val, acc_type);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void hl_access_host_mem(struct hl_device *hdev, u64 addr, u64 *val,\n\t\tenum debugfs_access_type acc_type)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu64 offset = prop->device_dma_offset_for_host_access;\n\n\tswitch (acc_type) {\n\tcase DEBUGFS_READ32:\n\t\t*val = *(u32 *) phys_to_virt(addr - offset);\n\t\tbreak;\n\tcase DEBUGFS_WRITE32:\n\t\t*(u32 *) phys_to_virt(addr - offset) = *val;\n\t\tbreak;\n\tcase DEBUGFS_READ64:\n\t\t*val = *(u64 *) phys_to_virt(addr - offset);\n\t\tbreak;\n\tcase DEBUGFS_WRITE64:\n\t\t*(u64 *) phys_to_virt(addr - offset) = *val;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdev->dev, \"hostmem access-type %d id not supported\\n\", acc_type);\n\t\tbreak;\n\t}\n}\n\nstatic int hl_access_mem(struct hl_device *hdev, u64 addr, u64 *val,\n\t\t\t\tenum debugfs_access_type acc_type)\n{\n\tsize_t acc_size = (acc_type == DEBUGFS_READ64 || acc_type == DEBUGFS_WRITE64) ?\n\t\tsizeof(u64) : sizeof(u32);\n\tu64 host_start = hdev->asic_prop.host_base_address;\n\tu64 host_end = hdev->asic_prop.host_end_address;\n\tbool user_address, found = false;\n\tint rc;\n\n\tuser_address = hl_is_device_va(hdev, addr);\n\tif (user_address) {\n\t\trc = device_va_to_pa(hdev, addr, acc_size, &addr);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = hl_access_dev_mem_by_region(hdev, addr, val, acc_type, &found);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed reading addr %#llx from dev mem (%d)\\n\",\n\t\t\taddr, rc);\n\t\treturn rc;\n\t}\n\n\tif (found)\n\t\treturn 0;\n\n\tif (!user_address || device_iommu_mapped(&hdev->pdev->dev)) {\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (addr >= host_start && addr <= host_end - acc_size) {\n\t\thl_access_host_mem(hdev, addr, val, acc_type);\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_err(hdev->dev, \"invalid addr %#llx\\n\", addr);\n\treturn rc;\n}\n\nstatic ssize_t hl_data_read32(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tu64 value64, addr = entry->addr;\n\tchar tmp_buf[32];\n\tssize_t rc;\n\tu32 val;\n\n\tif (hdev->reset_info.in_reset) {\n\t\tdev_warn_ratelimited(hdev->dev, \"Can't read during reset\\n\");\n\t\treturn 0;\n\t}\n\n\tif (*ppos)\n\t\treturn 0;\n\n\trc = hl_access_mem(hdev, addr, &value64, DEBUGFS_READ32);\n\tif (rc)\n\t\treturn rc;\n\n\tval = value64;  \n\n\tsprintf(tmp_buf, \"0x%08x\\n\", val);\n\treturn simple_read_from_buffer(buf, count, ppos, tmp_buf,\n\t\t\tstrlen(tmp_buf));\n}\n\nstatic ssize_t hl_data_write32(struct file *f, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tu64 value64, addr = entry->addr;\n\tu32 value;\n\tssize_t rc;\n\n\tif (hdev->reset_info.in_reset) {\n\t\tdev_warn_ratelimited(hdev->dev, \"Can't write during reset\\n\");\n\t\treturn 0;\n\t}\n\n\trc = kstrtouint_from_user(buf, count, 16, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tvalue64 = value;\n\trc = hl_access_mem(hdev, addr, &value64, DEBUGFS_WRITE32);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic ssize_t hl_data_read64(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tu64 addr = entry->addr;\n\tchar tmp_buf[32];\n\tssize_t rc;\n\tu64 val;\n\n\tif (hdev->reset_info.in_reset) {\n\t\tdev_warn_ratelimited(hdev->dev, \"Can't read during reset\\n\");\n\t\treturn 0;\n\t}\n\n\tif (*ppos)\n\t\treturn 0;\n\n\trc = hl_access_mem(hdev, addr, &val, DEBUGFS_READ64);\n\tif (rc)\n\t\treturn rc;\n\n\tsprintf(tmp_buf, \"0x%016llx\\n\", val);\n\treturn simple_read_from_buffer(buf, count, ppos, tmp_buf,\n\t\t\tstrlen(tmp_buf));\n}\n\nstatic ssize_t hl_data_write64(struct file *f, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tu64 addr = entry->addr;\n\tu64 value;\n\tssize_t rc;\n\n\tif (hdev->reset_info.in_reset) {\n\t\tdev_warn_ratelimited(hdev->dev, \"Can't write during reset\\n\");\n\t\treturn 0;\n\t}\n\n\trc = kstrtoull_from_user(buf, count, 16, &value);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hl_access_mem(hdev, addr, &value, DEBUGFS_WRITE64);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic ssize_t hl_dma_size_write(struct file *f, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tu64 addr = entry->addr;\n\tssize_t rc;\n\tu32 size;\n\n\tif (hdev->reset_info.in_reset) {\n\t\tdev_warn_ratelimited(hdev->dev, \"Can't DMA during reset\\n\");\n\t\treturn 0;\n\t}\n\trc = kstrtouint_from_user(buf, count, 16, &size);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!size) {\n\t\tdev_err(hdev->dev, \"DMA read failed. size can't be 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (size > SZ_128M) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"DMA read failed. size can't be larger than 128MB\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!hl_is_device_internal_memory_va(hdev, addr, size)) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"DMA read failed. Invalid 0x%010llx + 0x%08x\\n\",\n\t\t\taddr, size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tentry->data_dma_blob_desc.size = 0;\n\tvfree(entry->data_dma_blob_desc.data);\n\n\tentry->data_dma_blob_desc.data = vmalloc(size);\n\tif (!entry->data_dma_blob_desc.data)\n\t\treturn -ENOMEM;\n\n\trc = hdev->asic_funcs->debugfs_read_dma(hdev, addr, size,\n\t\t\t\t\t\tentry->data_dma_blob_desc.data);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to DMA from 0x%010llx\\n\", addr);\n\t\tvfree(entry->data_dma_blob_desc.data);\n\t\tentry->data_dma_blob_desc.data = NULL;\n\t\treturn -EIO;\n\t}\n\n\tentry->data_dma_blob_desc.size = size;\n\n\treturn count;\n}\n\nstatic ssize_t hl_monitor_dump_trigger(struct file *f, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tu32 size, trig;\n\tssize_t rc;\n\n\tif (hdev->reset_info.in_reset) {\n\t\tdev_warn_ratelimited(hdev->dev, \"Can't dump monitors during reset\\n\");\n\t\treturn 0;\n\t}\n\trc = kstrtouint_from_user(buf, count, 10, &trig);\n\tif (rc)\n\t\treturn rc;\n\n\tif (trig != 1) {\n\t\tdev_err(hdev->dev, \"Must write 1 to trigger monitor dump\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsize = sizeof(struct cpucp_monitor_dump);\n\n\t \n\tentry->mon_dump_blob_desc.size = 0;\n\tvfree(entry->mon_dump_blob_desc.data);\n\n\tentry->mon_dump_blob_desc.data = vmalloc(size);\n\tif (!entry->mon_dump_blob_desc.data)\n\t\treturn -ENOMEM;\n\n\trc = hdev->asic_funcs->get_monitor_dump(hdev, entry->mon_dump_blob_desc.data);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to dump monitors\\n\");\n\t\tvfree(entry->mon_dump_blob_desc.data);\n\t\tentry->mon_dump_blob_desc.data = NULL;\n\t\treturn -EIO;\n\t}\n\n\tentry->mon_dump_blob_desc.size = size;\n\n\treturn count;\n}\n\nstatic ssize_t hl_get_power_state(struct file *f, char __user *buf,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tchar tmp_buf[200];\n\tint i;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tif (hdev->pdev->current_state == PCI_D0)\n\t\ti = 1;\n\telse if (hdev->pdev->current_state == PCI_D3hot)\n\t\ti = 2;\n\telse\n\t\ti = 3;\n\n\tsprintf(tmp_buf,\n\t\t\"current power state: %d\\n1 - D0\\n2 - D3hot\\n3 - Unknown\\n\", i);\n\treturn simple_read_from_buffer(buf, count, ppos, tmp_buf,\n\t\t\tstrlen(tmp_buf));\n}\n\nstatic ssize_t hl_set_power_state(struct file *f, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tu32 value;\n\tssize_t rc;\n\n\trc = kstrtouint_from_user(buf, count, 10, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tif (value == 1) {\n\t\tpci_set_power_state(hdev->pdev, PCI_D0);\n\t\tpci_restore_state(hdev->pdev);\n\t\trc = pci_enable_device(hdev->pdev);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t} else if (value == 2) {\n\t\tpci_save_state(hdev->pdev);\n\t\tpci_disable_device(hdev->pdev);\n\t\tpci_set_power_state(hdev->pdev, PCI_D3hot);\n\t} else {\n\t\tdev_dbg(hdev->dev, \"invalid power state value %u\\n\", value);\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t hl_i2c_data_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tchar tmp_buf[32];\n\tu64 val;\n\tssize_t rc;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\trc = hl_debugfs_i2c_read(hdev, entry->i2c_bus, entry->i2c_addr,\n\t\t\tentry->i2c_reg, entry->i2c_len, &val);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to read from I2C bus %d, addr %d, reg %d, len %d\\n\",\n\t\t\tentry->i2c_bus, entry->i2c_addr, entry->i2c_reg, entry->i2c_len);\n\t\treturn rc;\n\t}\n\n\tsprintf(tmp_buf, \"%#02llx\\n\", val);\n\trc = simple_read_from_buffer(buf, count, ppos, tmp_buf,\n\t\t\tstrlen(tmp_buf));\n\n\treturn rc;\n}\n\nstatic ssize_t hl_i2c_data_write(struct file *f, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tu64 value;\n\tssize_t rc;\n\n\trc = kstrtou64_from_user(buf, count, 16, &value);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hl_debugfs_i2c_write(hdev, entry->i2c_bus, entry->i2c_addr,\n\t\t\tentry->i2c_reg, entry->i2c_len, value);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to write %#02llx to I2C bus %d, addr %d, reg %d, len %d\\n\",\n\t\t\tvalue, entry->i2c_bus, entry->i2c_addr, entry->i2c_reg, entry->i2c_len);\n\t\treturn rc;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t hl_led0_write(struct file *f, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tu32 value;\n\tssize_t rc;\n\n\trc = kstrtouint_from_user(buf, count, 10, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tvalue = value ? 1 : 0;\n\n\thl_debugfs_led_set(hdev, 0, value);\n\n\treturn count;\n}\n\nstatic ssize_t hl_led1_write(struct file *f, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tu32 value;\n\tssize_t rc;\n\n\trc = kstrtouint_from_user(buf, count, 10, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tvalue = value ? 1 : 0;\n\n\thl_debugfs_led_set(hdev, 1, value);\n\n\treturn count;\n}\n\nstatic ssize_t hl_led2_write(struct file *f, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tu32 value;\n\tssize_t rc;\n\n\trc = kstrtouint_from_user(buf, count, 10, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tvalue = value ? 1 : 0;\n\n\thl_debugfs_led_set(hdev, 2, value);\n\n\treturn count;\n}\n\nstatic ssize_t hl_device_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstatic const char *help =\n\t\t\"Valid values: disable, enable, suspend, resume, cpu_timeout\\n\";\n\treturn simple_read_from_buffer(buf, count, ppos, help, strlen(help));\n}\n\nstatic ssize_t hl_device_write(struct file *f, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tchar data[30] = {0};\n\n\t \n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsimple_write_to_buffer(data, 29, ppos, buf, count);\n\n\tif (strncmp(\"disable\", data, strlen(\"disable\")) == 0) {\n\t\thdev->disabled = true;\n\t} else if (strncmp(\"enable\", data, strlen(\"enable\")) == 0) {\n\t\thdev->disabled = false;\n\t} else if (strncmp(\"suspend\", data, strlen(\"suspend\")) == 0) {\n\t\thdev->asic_funcs->suspend(hdev);\n\t} else if (strncmp(\"resume\", data, strlen(\"resume\")) == 0) {\n\t\thdev->asic_funcs->resume(hdev);\n\t} else if (strncmp(\"cpu_timeout\", data, strlen(\"cpu_timeout\")) == 0) {\n\t\thdev->device_cpu_disabled = true;\n\t} else {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Valid values: disable, enable, suspend, resume, cpu_timeout\\n\");\n\t\tcount = -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t hl_clk_gate_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn 0;\n}\n\nstatic ssize_t hl_clk_gate_write(struct file *f, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\treturn count;\n}\n\nstatic ssize_t hl_stop_on_err_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tchar tmp_buf[200];\n\tssize_t rc;\n\n\tif (!hdev->asic_prop.configurable_stop_on_err)\n\t\treturn -EOPNOTSUPP;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tsprintf(tmp_buf, \"%d\\n\", hdev->stop_on_err);\n\trc = simple_read_from_buffer(buf, strlen(tmp_buf) + 1, ppos, tmp_buf,\n\t\t\tstrlen(tmp_buf) + 1);\n\n\treturn rc;\n}\n\nstatic ssize_t hl_stop_on_err_write(struct file *f, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tu32 value;\n\tssize_t rc;\n\n\tif (!hdev->asic_prop.configurable_stop_on_err)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hdev->reset_info.in_reset) {\n\t\tdev_warn_ratelimited(hdev->dev,\n\t\t\t\t\"Can't change stop on error during reset\\n\");\n\t\treturn 0;\n\t}\n\n\trc = kstrtouint_from_user(buf, count, 10, &value);\n\tif (rc)\n\t\treturn rc;\n\n\thdev->stop_on_err = value ? 1 : 0;\n\n\thl_device_reset(hdev, 0);\n\n\treturn count;\n}\n\nstatic ssize_t hl_security_violations_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\n\thdev->asic_funcs->ack_protection_bits_errors(hdev);\n\n\treturn 0;\n}\n\nstatic ssize_t hl_state_dump_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tssize_t rc;\n\n\tdown_read(&entry->state_dump_sem);\n\tif (!entry->state_dump[entry->state_dump_head])\n\t\trc = 0;\n\telse\n\t\trc = simple_read_from_buffer(\n\t\t\tbuf, count, ppos,\n\t\t\tentry->state_dump[entry->state_dump_head],\n\t\t\tstrlen(entry->state_dump[entry->state_dump_head]));\n\tup_read(&entry->state_dump_sem);\n\n\treturn rc;\n}\n\nstatic ssize_t hl_state_dump_write(struct file *f, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tssize_t rc;\n\tu32 size;\n\tint i;\n\n\trc = kstrtouint_from_user(buf, count, 10, &size);\n\tif (rc)\n\t\treturn rc;\n\n\tif (size <= 0 || size >= ARRAY_SIZE(entry->state_dump)) {\n\t\tdev_err(hdev->dev, \"Invalid number of dumps to skip\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (entry->state_dump[entry->state_dump_head]) {\n\t\tdown_write(&entry->state_dump_sem);\n\t\tfor (i = 0; i < size; ++i) {\n\t\t\tvfree(entry->state_dump[entry->state_dump_head]);\n\t\t\tentry->state_dump[entry->state_dump_head] = NULL;\n\t\t\tif (entry->state_dump_head > 0)\n\t\t\t\tentry->state_dump_head--;\n\t\t\telse\n\t\t\t\tentry->state_dump_head =\n\t\t\t\t\tARRAY_SIZE(entry->state_dump) - 1;\n\t\t}\n\t\tup_write(&entry->state_dump_sem);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t hl_timeout_locked_read(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tchar tmp_buf[200];\n\tssize_t rc;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tsprintf(tmp_buf, \"%d\\n\",\n\t\tjiffies_to_msecs(hdev->timeout_jiffies) / 1000);\n\trc = simple_read_from_buffer(buf, strlen(tmp_buf) + 1, ppos, tmp_buf,\n\t\t\tstrlen(tmp_buf) + 1);\n\n\treturn rc;\n}\n\nstatic ssize_t hl_timeout_locked_write(struct file *f, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\tu32 value;\n\tssize_t rc;\n\n\trc = kstrtouint_from_user(buf, count, 10, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tif (value)\n\t\thdev->timeout_jiffies = msecs_to_jiffies(value * 1000);\n\telse\n\t\thdev->timeout_jiffies = MAX_SCHEDULE_TIMEOUT;\n\n\treturn count;\n}\n\nstatic ssize_t hl_check_razwi_happened(struct file *f, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hl_dbg_device_entry *entry = file_inode(f)->i_private;\n\tstruct hl_device *hdev = entry->hdev;\n\n\thdev->asic_funcs->check_if_razwi_happened(hdev);\n\n\treturn 0;\n}\n\nstatic const struct file_operations hl_mem_scrub_fops = {\n\t.owner = THIS_MODULE,\n\t.write = hl_memory_scrub,\n};\n\nstatic const struct file_operations hl_data32b_fops = {\n\t.owner = THIS_MODULE,\n\t.read = hl_data_read32,\n\t.write = hl_data_write32\n};\n\nstatic const struct file_operations hl_data64b_fops = {\n\t.owner = THIS_MODULE,\n\t.read = hl_data_read64,\n\t.write = hl_data_write64\n};\n\nstatic const struct file_operations hl_dma_size_fops = {\n\t.owner = THIS_MODULE,\n\t.write = hl_dma_size_write\n};\n\nstatic const struct file_operations hl_monitor_dump_fops = {\n\t.owner = THIS_MODULE,\n\t.write = hl_monitor_dump_trigger\n};\n\nstatic const struct file_operations hl_i2c_data_fops = {\n\t.owner = THIS_MODULE,\n\t.read = hl_i2c_data_read,\n\t.write = hl_i2c_data_write\n};\n\nstatic const struct file_operations hl_power_fops = {\n\t.owner = THIS_MODULE,\n\t.read = hl_get_power_state,\n\t.write = hl_set_power_state\n};\n\nstatic const struct file_operations hl_led0_fops = {\n\t.owner = THIS_MODULE,\n\t.write = hl_led0_write\n};\n\nstatic const struct file_operations hl_led1_fops = {\n\t.owner = THIS_MODULE,\n\t.write = hl_led1_write\n};\n\nstatic const struct file_operations hl_led2_fops = {\n\t.owner = THIS_MODULE,\n\t.write = hl_led2_write\n};\n\nstatic const struct file_operations hl_device_fops = {\n\t.owner = THIS_MODULE,\n\t.read = hl_device_read,\n\t.write = hl_device_write\n};\n\nstatic const struct file_operations hl_clk_gate_fops = {\n\t.owner = THIS_MODULE,\n\t.read = hl_clk_gate_read,\n\t.write = hl_clk_gate_write\n};\n\nstatic const struct file_operations hl_stop_on_err_fops = {\n\t.owner = THIS_MODULE,\n\t.read = hl_stop_on_err_read,\n\t.write = hl_stop_on_err_write\n};\n\nstatic const struct file_operations hl_security_violations_fops = {\n\t.owner = THIS_MODULE,\n\t.read = hl_security_violations_read\n};\n\nstatic const struct file_operations hl_state_dump_fops = {\n\t.owner = THIS_MODULE,\n\t.read = hl_state_dump_read,\n\t.write = hl_state_dump_write\n};\n\nstatic const struct file_operations hl_timeout_locked_fops = {\n\t.owner = THIS_MODULE,\n\t.read = hl_timeout_locked_read,\n\t.write = hl_timeout_locked_write\n};\n\nstatic const struct file_operations hl_razwi_check_fops = {\n\t.owner = THIS_MODULE,\n\t.read = hl_check_razwi_happened\n};\n\nstatic const struct hl_info_list hl_debugfs_list[] = {\n\t{\"command_buffers\", command_buffers_show, NULL},\n\t{\"command_submission\", command_submission_show, NULL},\n\t{\"command_submission_jobs\", command_submission_jobs_show, NULL},\n\t{\"userptr\", userptr_show, NULL},\n\t{\"vm\", vm_show, NULL},\n\t{\"userptr_lookup\", userptr_lookup_show, userptr_lookup_write},\n\t{\"mmu\", mmu_show, mmu_asid_va_write},\n\t{\"mmu_error\", mmu_ack_error, mmu_ack_error_value_write},\n\t{\"engines\", engines_show, NULL},\n};\n\nstatic int hl_debugfs_open(struct inode *inode, struct file *file)\n{\n\tstruct hl_debugfs_entry *node = inode->i_private;\n\n\treturn single_open(file, node->info_ent->show, node);\n}\n\nstatic ssize_t hl_debugfs_write(struct file *file, const char __user *buf,\n\t\tsize_t count, loff_t *f_pos)\n{\n\tstruct hl_debugfs_entry *node = file->f_inode->i_private;\n\n\tif (node->info_ent->write)\n\t\treturn node->info_ent->write(file, buf, count, f_pos);\n\telse\n\t\treturn -EINVAL;\n\n}\n\nstatic const struct file_operations hl_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.open = hl_debugfs_open,\n\t.read = seq_read,\n\t.write = hl_debugfs_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic void add_secured_nodes(struct hl_dbg_device_entry *dev_entry, struct dentry *root)\n{\n\tdebugfs_create_u8(\"i2c_bus\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\t&dev_entry->i2c_bus);\n\n\tdebugfs_create_u8(\"i2c_addr\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\t&dev_entry->i2c_addr);\n\n\tdebugfs_create_u8(\"i2c_reg\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\t&dev_entry->i2c_reg);\n\n\tdebugfs_create_u8(\"i2c_len\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\t&dev_entry->i2c_len);\n\n\tdebugfs_create_file(\"i2c_data\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_i2c_data_fops);\n\n\tdebugfs_create_file(\"led0\",\n\t\t\t\t0200,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_led0_fops);\n\n\tdebugfs_create_file(\"led1\",\n\t\t\t\t0200,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_led1_fops);\n\n\tdebugfs_create_file(\"led2\",\n\t\t\t\t0200,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_led2_fops);\n}\n\nstatic void add_files_to_device(struct hl_device *hdev, struct hl_dbg_device_entry *dev_entry,\n\t\t\t\tstruct dentry *root)\n{\n\tint count = ARRAY_SIZE(hl_debugfs_list);\n\tstruct hl_debugfs_entry *entry;\n\tint i;\n\n\tdebugfs_create_x64(\"memory_scrub_val\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\t&hdev->memory_scrub_val);\n\n\tdebugfs_create_file(\"memory_scrub\",\n\t\t\t\t0200,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_mem_scrub_fops);\n\n\tdebugfs_create_x64(\"addr\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\t&dev_entry->addr);\n\n\tdebugfs_create_file(\"data32\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_data32b_fops);\n\n\tdebugfs_create_file(\"data64\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_data64b_fops);\n\n\tdebugfs_create_file(\"set_power_state\",\n\t\t\t\t0200,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_power_fops);\n\n\tdebugfs_create_file(\"device\",\n\t\t\t\t0200,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_device_fops);\n\n\tdebugfs_create_file(\"clk_gate\",\n\t\t\t\t0200,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_clk_gate_fops);\n\n\tdebugfs_create_file(\"stop_on_err\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_stop_on_err_fops);\n\n\tdebugfs_create_file(\"dump_security_violations\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_security_violations_fops);\n\n\tdebugfs_create_file(\"dump_razwi_events\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_razwi_check_fops);\n\n\tdebugfs_create_file(\"dma_size\",\n\t\t\t\t0200,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_dma_size_fops);\n\n\tdebugfs_create_blob(\"data_dma\",\n\t\t\t\t0400,\n\t\t\t\troot,\n\t\t\t\t&dev_entry->data_dma_blob_desc);\n\n\tdebugfs_create_file(\"monitor_dump_trig\",\n\t\t\t\t0200,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_monitor_dump_fops);\n\n\tdebugfs_create_blob(\"monitor_dump\",\n\t\t\t\t0400,\n\t\t\t\troot,\n\t\t\t\t&dev_entry->mon_dump_blob_desc);\n\n\tdebugfs_create_x8(\"skip_reset_on_timeout\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\t&hdev->reset_info.skip_reset_on_timeout);\n\n\tdebugfs_create_file(\"state_dump\",\n\t\t\t\t0600,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_state_dump_fops);\n\n\tdebugfs_create_file(\"timeout_locked\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\tdev_entry,\n\t\t\t\t&hl_timeout_locked_fops);\n\n\tdebugfs_create_u32(\"device_release_watchdog_timeout\",\n\t\t\t\t0644,\n\t\t\t\troot,\n\t\t\t\t&hdev->device_release_watchdog_timeout_sec);\n\n\tfor (i = 0, entry = dev_entry->entry_arr ; i < count ; i++, entry++) {\n\t\tdebugfs_create_file(hl_debugfs_list[i].name,\n\t\t\t\t\t0444,\n\t\t\t\t\troot,\n\t\t\t\t\tentry,\n\t\t\t\t\t&hl_debugfs_fops);\n\t\tentry->info_ent = &hl_debugfs_list[i];\n\t\tentry->dev_entry = dev_entry;\n\t}\n}\n\nint hl_debugfs_device_init(struct hl_device *hdev)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &hdev->hl_debugfs;\n\tint count = ARRAY_SIZE(hl_debugfs_list);\n\n\tdev_entry->hdev = hdev;\n\tdev_entry->entry_arr = kmalloc_array(count, sizeof(struct hl_debugfs_entry), GFP_KERNEL);\n\tif (!dev_entry->entry_arr)\n\t\treturn -ENOMEM;\n\n\tdev_entry->data_dma_blob_desc.size = 0;\n\tdev_entry->data_dma_blob_desc.data = NULL;\n\tdev_entry->mon_dump_blob_desc.size = 0;\n\tdev_entry->mon_dump_blob_desc.data = NULL;\n\n\tINIT_LIST_HEAD(&dev_entry->file_list);\n\tINIT_LIST_HEAD(&dev_entry->cb_list);\n\tINIT_LIST_HEAD(&dev_entry->cs_list);\n\tINIT_LIST_HEAD(&dev_entry->cs_job_list);\n\tINIT_LIST_HEAD(&dev_entry->userptr_list);\n\tINIT_LIST_HEAD(&dev_entry->ctx_mem_hash_list);\n\tmutex_init(&dev_entry->file_mutex);\n\tinit_rwsem(&dev_entry->state_dump_sem);\n\tspin_lock_init(&dev_entry->cb_spinlock);\n\tspin_lock_init(&dev_entry->cs_spinlock);\n\tspin_lock_init(&dev_entry->cs_job_spinlock);\n\tspin_lock_init(&dev_entry->userptr_spinlock);\n\tmutex_init(&dev_entry->ctx_mem_hash_mutex);\n\n\treturn 0;\n}\n\nvoid hl_debugfs_device_fini(struct hl_device *hdev)\n{\n\tstruct hl_dbg_device_entry *entry = &hdev->hl_debugfs;\n\tint i;\n\n\tmutex_destroy(&entry->ctx_mem_hash_mutex);\n\tmutex_destroy(&entry->file_mutex);\n\n\tvfree(entry->data_dma_blob_desc.data);\n\tvfree(entry->mon_dump_blob_desc.data);\n\n\tfor (i = 0; i < ARRAY_SIZE(entry->state_dump); ++i)\n\t\tvfree(entry->state_dump[i]);\n\n\tkfree(entry->entry_arr);\n}\n\nvoid hl_debugfs_add_device(struct hl_device *hdev)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &hdev->hl_debugfs;\n\n\tdev_entry->root = debugfs_create_dir(dev_name(hdev->dev), hl_debug_root);\n\n\tadd_files_to_device(hdev, dev_entry, dev_entry->root);\n\tif (!hdev->asic_prop.fw_security_enabled)\n\t\tadd_secured_nodes(dev_entry, dev_entry->root);\n}\n\nvoid hl_debugfs_remove_device(struct hl_device *hdev)\n{\n\tstruct hl_dbg_device_entry *entry = &hdev->hl_debugfs;\n\n\tdebugfs_remove_recursive(entry->root);\n}\n\nvoid hl_debugfs_add_file(struct hl_fpriv *hpriv)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &hpriv->hdev->hl_debugfs;\n\n\tmutex_lock(&dev_entry->file_mutex);\n\tlist_add(&hpriv->debugfs_list, &dev_entry->file_list);\n\tmutex_unlock(&dev_entry->file_mutex);\n}\n\nvoid hl_debugfs_remove_file(struct hl_fpriv *hpriv)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &hpriv->hdev->hl_debugfs;\n\n\tmutex_lock(&dev_entry->file_mutex);\n\tlist_del(&hpriv->debugfs_list);\n\tmutex_unlock(&dev_entry->file_mutex);\n}\n\nvoid hl_debugfs_add_cb(struct hl_cb *cb)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &cb->hdev->hl_debugfs;\n\n\tspin_lock(&dev_entry->cb_spinlock);\n\tlist_add(&cb->debugfs_list, &dev_entry->cb_list);\n\tspin_unlock(&dev_entry->cb_spinlock);\n}\n\nvoid hl_debugfs_remove_cb(struct hl_cb *cb)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &cb->hdev->hl_debugfs;\n\n\tspin_lock(&dev_entry->cb_spinlock);\n\tlist_del(&cb->debugfs_list);\n\tspin_unlock(&dev_entry->cb_spinlock);\n}\n\nvoid hl_debugfs_add_cs(struct hl_cs *cs)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &cs->ctx->hdev->hl_debugfs;\n\n\tspin_lock(&dev_entry->cs_spinlock);\n\tlist_add(&cs->debugfs_list, &dev_entry->cs_list);\n\tspin_unlock(&dev_entry->cs_spinlock);\n}\n\nvoid hl_debugfs_remove_cs(struct hl_cs *cs)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &cs->ctx->hdev->hl_debugfs;\n\n\tspin_lock(&dev_entry->cs_spinlock);\n\tlist_del(&cs->debugfs_list);\n\tspin_unlock(&dev_entry->cs_spinlock);\n}\n\nvoid hl_debugfs_add_job(struct hl_device *hdev, struct hl_cs_job *job)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &hdev->hl_debugfs;\n\n\tspin_lock(&dev_entry->cs_job_spinlock);\n\tlist_add(&job->debugfs_list, &dev_entry->cs_job_list);\n\tspin_unlock(&dev_entry->cs_job_spinlock);\n}\n\nvoid hl_debugfs_remove_job(struct hl_device *hdev, struct hl_cs_job *job)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &hdev->hl_debugfs;\n\n\tspin_lock(&dev_entry->cs_job_spinlock);\n\tlist_del(&job->debugfs_list);\n\tspin_unlock(&dev_entry->cs_job_spinlock);\n}\n\nvoid hl_debugfs_add_userptr(struct hl_device *hdev, struct hl_userptr *userptr)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &hdev->hl_debugfs;\n\n\tspin_lock(&dev_entry->userptr_spinlock);\n\tlist_add(&userptr->debugfs_list, &dev_entry->userptr_list);\n\tspin_unlock(&dev_entry->userptr_spinlock);\n}\n\nvoid hl_debugfs_remove_userptr(struct hl_device *hdev,\n\t\t\t\tstruct hl_userptr *userptr)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &hdev->hl_debugfs;\n\n\tspin_lock(&dev_entry->userptr_spinlock);\n\tlist_del(&userptr->debugfs_list);\n\tspin_unlock(&dev_entry->userptr_spinlock);\n}\n\nvoid hl_debugfs_add_ctx_mem_hash(struct hl_device *hdev, struct hl_ctx *ctx)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &hdev->hl_debugfs;\n\n\tmutex_lock(&dev_entry->ctx_mem_hash_mutex);\n\tlist_add(&ctx->debugfs_list, &dev_entry->ctx_mem_hash_list);\n\tmutex_unlock(&dev_entry->ctx_mem_hash_mutex);\n}\n\nvoid hl_debugfs_remove_ctx_mem_hash(struct hl_device *hdev, struct hl_ctx *ctx)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &hdev->hl_debugfs;\n\n\tmutex_lock(&dev_entry->ctx_mem_hash_mutex);\n\tlist_del(&ctx->debugfs_list);\n\tmutex_unlock(&dev_entry->ctx_mem_hash_mutex);\n}\n\n \nvoid hl_debugfs_set_state_dump(struct hl_device *hdev, char *data,\n\t\t\t\t\tunsigned long length)\n{\n\tstruct hl_dbg_device_entry *dev_entry = &hdev->hl_debugfs;\n\n\tdown_write(&dev_entry->state_dump_sem);\n\n\tdev_entry->state_dump_head = (dev_entry->state_dump_head + 1) %\n\t\t\t\t\tARRAY_SIZE(dev_entry->state_dump);\n\tvfree(dev_entry->state_dump[dev_entry->state_dump_head]);\n\tdev_entry->state_dump[dev_entry->state_dump_head] = data;\n\n\tup_write(&dev_entry->state_dump_sem);\n}\n\nvoid __init hl_debugfs_init(void)\n{\n\thl_debug_root = debugfs_create_dir(\"habanalabs\", NULL);\n}\n\nvoid hl_debugfs_fini(void)\n{\n\tdebugfs_remove_recursive(hl_debug_root);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}