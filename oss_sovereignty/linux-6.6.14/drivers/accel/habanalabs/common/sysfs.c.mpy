{
  "module_name": "sysfs.c",
  "hash_id": "996721070987ad165022dc6e1d8eb46211a85ece5e32521141eedad8dc56ef4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/common/sysfs.c",
  "human_readable_source": "\n\n \n\n#include \"habanalabs.h\"\n\n#include <linux/pci.h>\n\nstatic ssize_t clk_max_freq_mhz_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tlong value;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\tvalue = hl_fw_get_frequency(hdev, hdev->asic_prop.clk_pll_index, false);\n\tif (value < 0)\n\t\treturn value;\n\n\thdev->asic_prop.max_freq_value = value;\n\n\treturn sprintf(buf, \"%lu\\n\", (value / 1000 / 1000));\n}\n\nstatic ssize_t clk_max_freq_mhz_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tint rc;\n\tu64 value;\n\n\tif (!hl_device_operational(hdev, NULL)) {\n\t\tcount = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\trc = kstrtoull(buf, 0, &value);\n\tif (rc) {\n\t\tcount = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\thdev->asic_prop.max_freq_value = value * 1000 * 1000;\n\n\thl_fw_set_frequency(hdev, hdev->asic_prop.clk_pll_index, hdev->asic_prop.max_freq_value);\n\nfail:\n\treturn count;\n}\n\nstatic ssize_t clk_cur_freq_mhz_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tlong value;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\tvalue = hl_fw_get_frequency(hdev, hdev->asic_prop.clk_pll_index, true);\n\tif (value < 0)\n\t\treturn value;\n\n\treturn sprintf(buf, \"%lu\\n\", (value / 1000 / 1000));\n}\n\nstatic DEVICE_ATTR_RW(clk_max_freq_mhz);\nstatic DEVICE_ATTR_RO(clk_cur_freq_mhz);\n\nstatic struct attribute *hl_dev_clk_attrs[] = {\n\t&dev_attr_clk_max_freq_mhz.attr,\n\t&dev_attr_clk_cur_freq_mhz.attr,\n\tNULL,\n};\n\nstatic ssize_t vrm_ver_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tstruct cpucp_info *cpucp_info;\n\n\tcpucp_info = &hdev->asic_prop.cpucp_info;\n\n\tif (cpucp_info->infineon_second_stage_version)\n\t\treturn sprintf(buf, \"%#04x %#04x\\n\", le32_to_cpu(cpucp_info->infineon_version),\n\t\t\t\tle32_to_cpu(cpucp_info->infineon_second_stage_version));\n\telse\n\t\treturn sprintf(buf, \"%#04x\\n\", le32_to_cpu(cpucp_info->infineon_version));\n}\n\nstatic DEVICE_ATTR_RO(vrm_ver);\n\nstatic struct attribute *hl_dev_vrm_attrs[] = {\n\t&dev_attr_vrm_ver.attr,\n\tNULL,\n};\n\nstatic ssize_t uboot_ver_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", hdev->asic_prop.uboot_ver);\n}\n\nstatic ssize_t armcp_kernel_ver_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\", hdev->asic_prop.cpucp_info.kernel_version);\n}\n\nstatic ssize_t armcp_ver_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", hdev->asic_prop.cpucp_info.cpucp_version);\n}\n\nstatic ssize_t cpld_ver_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"0x%08x\\n\",\n\t\t\tle32_to_cpu(hdev->asic_prop.cpucp_info.cpld_version));\n}\n\nstatic ssize_t cpucp_kernel_ver_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\", hdev->asic_prop.cpucp_info.kernel_version);\n}\n\nstatic ssize_t cpucp_ver_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", hdev->asic_prop.cpucp_info.cpucp_version);\n}\n\nstatic ssize_t fuse_ver_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", hdev->asic_prop.cpucp_info.fuse_version);\n}\n\nstatic ssize_t thermal_ver_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\", hdev->asic_prop.cpucp_info.thermal_version);\n}\n\nstatic ssize_t fw_os_ver_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\", hdev->asic_prop.cpucp_info.fw_os_version);\n}\n\nstatic ssize_t preboot_btl_ver_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", hdev->asic_prop.preboot_ver);\n}\n\nstatic ssize_t soft_reset_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tlong value;\n\tint rc;\n\n\trc = kstrtoul(buf, 0, &value);\n\n\tif (rc) {\n\t\tcount = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!hdev->asic_prop.allow_inference_soft_reset) {\n\t\tdev_err(hdev->dev, \"Device does not support inference soft-reset\\n\");\n\t\tgoto out;\n\t}\n\n\tdev_warn(hdev->dev, \"Inference Soft-Reset requested through sysfs\\n\");\n\n\thl_device_reset(hdev, 0);\n\nout:\n\treturn count;\n}\n\nstatic ssize_t hard_reset_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tlong value;\n\tint rc;\n\n\trc = kstrtoul(buf, 0, &value);\n\n\tif (rc) {\n\t\tcount = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdev_warn(hdev->dev, \"Hard-Reset requested through sysfs\\n\");\n\n\thl_device_reset(hdev, HL_DRV_RESET_HARD);\n\nout:\n\treturn count;\n}\n\nstatic ssize_t device_type_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tchar *str;\n\n\tswitch (hdev->asic_type) {\n\tcase ASIC_GOYA:\n\t\tstr = \"GOYA\";\n\t\tbreak;\n\tcase ASIC_GAUDI:\n\t\tstr = \"GAUDI\";\n\t\tbreak;\n\tcase ASIC_GAUDI_SEC:\n\t\tstr = \"GAUDI SEC\";\n\t\tbreak;\n\tcase ASIC_GAUDI2:\n\t\tstr = \"GAUDI2\";\n\t\tbreak;\n\tcase ASIC_GAUDI2B:\n\t\tstr = \"GAUDI2B\";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdev->dev, \"Unrecognized ASIC type %d\\n\",\n\t\t\t\thdev->asic_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", str);\n}\n\nstatic ssize_t pci_addr_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%04x:%02x:%02x.%x\\n\",\n\t\t\tpci_domain_nr(hdev->pdev->bus),\n\t\t\thdev->pdev->bus->number,\n\t\t\tPCI_SLOT(hdev->pdev->devfn),\n\t\t\tPCI_FUNC(hdev->pdev->devfn));\n}\n\nstatic ssize_t status_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tchar str[HL_STR_MAX];\n\n\tstrscpy(str, hdev->status[hl_device_status(hdev)], HL_STR_MAX);\n\n\t \n\tstr[0] = 'A' + (str[0] - 'a');\n\n\treturn sprintf(buf, \"%s\\n\", str);\n}\n\nstatic ssize_t soft_reset_cnt_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", hdev->reset_info.compute_reset_cnt);\n}\n\nstatic ssize_t hard_reset_cnt_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", hdev->reset_info.hard_reset_cnt);\n}\n\nstatic ssize_t max_power_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tlong val;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\tval = hl_fw_get_max_power(hdev);\n\tif (val < 0)\n\t\treturn val;\n\n\treturn sprintf(buf, \"%lu\\n\", val);\n}\n\nstatic ssize_t max_power_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tunsigned long value;\n\tint rc;\n\n\tif (!hl_device_operational(hdev, NULL)) {\n\t\tcount = -ENODEV;\n\t\tgoto out;\n\t}\n\n\trc = kstrtoul(buf, 0, &value);\n\n\tif (rc) {\n\t\tcount = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thdev->max_power = value;\n\thl_fw_set_max_power(hdev);\n\nout:\n\treturn count;\n}\n\nstatic ssize_t eeprom_read_handler(struct file *filp, struct kobject *kobj,\n\t\t\tstruct bin_attribute *attr, char *buf, loff_t offset,\n\t\t\tsize_t max_size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tchar *data;\n\tint rc;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\tif (!max_size)\n\t\treturn -EINVAL;\n\n\tdata = kzalloc(max_size, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\trc = hdev->asic_funcs->get_eeprom_data(hdev, data, max_size);\n\tif (rc)\n\t\tgoto out;\n\n\tmemcpy(buf, data, max_size);\n\nout:\n\tkfree(data);\n\n\treturn max_size;\n}\n\nstatic ssize_t security_enabled_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", hdev->asic_prop.fw_security_enabled);\n}\n\nstatic DEVICE_ATTR_RO(armcp_kernel_ver);\nstatic DEVICE_ATTR_RO(armcp_ver);\nstatic DEVICE_ATTR_RO(cpld_ver);\nstatic DEVICE_ATTR_RO(cpucp_kernel_ver);\nstatic DEVICE_ATTR_RO(cpucp_ver);\nstatic DEVICE_ATTR_RO(device_type);\nstatic DEVICE_ATTR_RO(fuse_ver);\nstatic DEVICE_ATTR_WO(hard_reset);\nstatic DEVICE_ATTR_RO(hard_reset_cnt);\nstatic DEVICE_ATTR_RW(max_power);\nstatic DEVICE_ATTR_RO(pci_addr);\nstatic DEVICE_ATTR_RO(preboot_btl_ver);\nstatic DEVICE_ATTR_WO(soft_reset);\nstatic DEVICE_ATTR_RO(soft_reset_cnt);\nstatic DEVICE_ATTR_RO(status);\nstatic DEVICE_ATTR_RO(thermal_ver);\nstatic DEVICE_ATTR_RO(uboot_ver);\nstatic DEVICE_ATTR_RO(fw_os_ver);\nstatic DEVICE_ATTR_RO(security_enabled);\n\nstatic struct bin_attribute bin_attr_eeprom = {\n\t.attr = {.name = \"eeprom\", .mode = (0444)},\n\t.size = PAGE_SIZE,\n\t.read = eeprom_read_handler\n};\n\nstatic struct attribute *hl_dev_attrs[] = {\n\t&dev_attr_armcp_kernel_ver.attr,\n\t&dev_attr_armcp_ver.attr,\n\t&dev_attr_cpld_ver.attr,\n\t&dev_attr_cpucp_kernel_ver.attr,\n\t&dev_attr_cpucp_ver.attr,\n\t&dev_attr_device_type.attr,\n\t&dev_attr_fuse_ver.attr,\n\t&dev_attr_hard_reset.attr,\n\t&dev_attr_hard_reset_cnt.attr,\n\t&dev_attr_max_power.attr,\n\t&dev_attr_pci_addr.attr,\n\t&dev_attr_preboot_btl_ver.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_thermal_ver.attr,\n\t&dev_attr_uboot_ver.attr,\n\t&dev_attr_fw_os_ver.attr,\n\t&dev_attr_security_enabled.attr,\n\tNULL,\n};\n\nstatic struct bin_attribute *hl_dev_bin_attrs[] = {\n\t&bin_attr_eeprom,\n\tNULL\n};\n\nstatic struct attribute_group hl_dev_attr_group = {\n\t.attrs = hl_dev_attrs,\n\t.bin_attrs = hl_dev_bin_attrs,\n};\n\nstatic struct attribute_group hl_dev_clks_attr_group;\nstatic struct attribute_group hl_dev_vrm_attr_group;\n\nstatic const struct attribute_group *hl_dev_attr_groups[] = {\n\t&hl_dev_attr_group,\n\t&hl_dev_clks_attr_group,\n\t&hl_dev_vrm_attr_group,\n\tNULL,\n};\n\nstatic struct attribute *hl_dev_inference_attrs[] = {\n\t&dev_attr_soft_reset.attr,\n\t&dev_attr_soft_reset_cnt.attr,\n\tNULL,\n};\n\nstatic struct attribute_group hl_dev_inference_attr_group = {\n\t.attrs = hl_dev_inference_attrs,\n};\n\nstatic const struct attribute_group *hl_dev_inference_attr_groups[] = {\n\t&hl_dev_inference_attr_group,\n\tNULL,\n};\n\nvoid hl_sysfs_add_dev_clk_attr(struct hl_device *hdev, struct attribute_group *dev_clk_attr_grp)\n{\n\tdev_clk_attr_grp->attrs = hl_dev_clk_attrs;\n}\n\nvoid hl_sysfs_add_dev_vrm_attr(struct hl_device *hdev, struct attribute_group *dev_vrm_attr_grp)\n{\n\tdev_vrm_attr_grp->attrs = hl_dev_vrm_attrs;\n}\n\nint hl_sysfs_init(struct hl_device *hdev)\n{\n\tint rc;\n\n\thdev->max_power = hdev->asic_prop.max_power_default;\n\n\thdev->asic_funcs->add_device_attr(hdev, &hl_dev_clks_attr_group, &hl_dev_vrm_attr_group);\n\n\trc = device_add_groups(hdev->dev, hl_dev_attr_groups);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to add groups to device, error %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (!hdev->asic_prop.allow_inference_soft_reset)\n\t\treturn 0;\n\n\trc = device_add_groups(hdev->dev, hl_dev_inference_attr_groups);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to add groups to device, error %d\\n\", rc);\n\t\tgoto remove_groups;\n\t}\n\n\treturn 0;\n\nremove_groups:\n\tdevice_remove_groups(hdev->dev, hl_dev_attr_groups);\n\treturn rc;\n}\n\nvoid hl_sysfs_fini(struct hl_device *hdev)\n{\n\tdevice_remove_groups(hdev->dev, hl_dev_attr_groups);\n\n\tif (!hdev->asic_prop.allow_inference_soft_reset)\n\t\treturn;\n\n\tdevice_remove_groups(hdev->dev, hl_dev_inference_attr_groups);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}