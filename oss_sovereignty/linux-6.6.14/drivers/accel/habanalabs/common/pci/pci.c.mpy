{
  "module_name": "pci.c",
  "hash_id": "df7ef54c65b08a3df09037f04b4bdbe65db3d8c36cc043c569ae06d53258720a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/common/pci/pci.c",
  "human_readable_source": "\n\n \n\n#include \"../habanalabs.h\"\n#include \"../../include/hw_ip/pci/pci_general.h\"\n\n#include <linux/pci.h>\n\n#include <trace/events/habanalabs.h>\n\n#define HL_PLDM_PCI_ELBI_TIMEOUT_MSEC\t(HL_PCI_ELBI_TIMEOUT_MSEC * 100)\n\n#define IATU_REGION_CTRL_REGION_EN_MASK\t\tBIT(31)\n#define IATU_REGION_CTRL_MATCH_MODE_MASK\tBIT(30)\n#define IATU_REGION_CTRL_NUM_MATCH_EN_MASK\tBIT(19)\n#define IATU_REGION_CTRL_BAR_NUM_MASK\t\tGENMASK(10, 8)\n\n \nint hl_pci_bars_map(struct hl_device *hdev, const char * const name[3],\n\t\t\tbool is_wc[3])\n{\n\tstruct pci_dev *pdev = hdev->pdev;\n\tint rc, i, bar;\n\n\trc = pci_request_regions(pdev, HL_NAME);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Cannot obtain PCI resources\\n\");\n\t\treturn rc;\n\t}\n\n\tfor (i = 0 ; i < 3 ; i++) {\n\t\tbar = i * 2;  \n\t\thdev->pcie_bar[bar] = is_wc[i] ?\n\t\t\t\tpci_ioremap_wc_bar(pdev, bar) :\n\t\t\t\tpci_ioremap_bar(pdev, bar);\n\t\tif (!hdev->pcie_bar[bar]) {\n\t\t\tdev_err(hdev->dev, \"pci_ioremap%s_bar failed for %s\\n\",\n\t\t\t\t\tis_wc[i] ? \"_wc\" : \"\", name[i]);\n\t\t\trc = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i = 2 ; i >= 0 ; i--) {\n\t\tbar = i * 2;  \n\t\tif (hdev->pcie_bar[bar])\n\t\t\tiounmap(hdev->pcie_bar[bar]);\n\t}\n\n\tpci_release_regions(pdev);\n\n\treturn rc;\n}\n\n \nstatic void hl_pci_bars_unmap(struct hl_device *hdev)\n{\n\tstruct pci_dev *pdev = hdev->pdev;\n\tint i, bar;\n\n\tfor (i = 2 ; i >= 0 ; i--) {\n\t\tbar = i * 2;  \n\t\tiounmap(hdev->pcie_bar[bar]);\n\t}\n\n\tpci_release_regions(pdev);\n}\n\nint hl_pci_elbi_read(struct hl_device *hdev, u64 addr, u32 *data)\n{\n\tstruct pci_dev *pdev = hdev->pdev;\n\tktime_t timeout;\n\tu64 msec;\n\tu32 val;\n\n\tif (hdev->pldm)\n\t\tmsec = HL_PLDM_PCI_ELBI_TIMEOUT_MSEC;\n\telse\n\t\tmsec = HL_PCI_ELBI_TIMEOUT_MSEC;\n\n\t \n\tpci_write_config_dword(pdev, mmPCI_CONFIG_ELBI_STS, 0);\n\n\tpci_write_config_dword(pdev, mmPCI_CONFIG_ELBI_ADDR, (u32) addr);\n\tpci_write_config_dword(pdev, mmPCI_CONFIG_ELBI_CTRL, 0);\n\n\ttimeout = ktime_add_ms(ktime_get(), msec);\n\tfor (;;) {\n\t\tpci_read_config_dword(pdev, mmPCI_CONFIG_ELBI_STS, &val);\n\t\tif (val & PCI_CONFIG_ELBI_STS_MASK)\n\t\t\tbreak;\n\t\tif (ktime_compare(ktime_get(), timeout) > 0) {\n\t\t\tpci_read_config_dword(pdev, mmPCI_CONFIG_ELBI_STS,\n\t\t\t\t\t\t&val);\n\t\t\tbreak;\n\t\t}\n\n\t\tusleep_range(300, 500);\n\t}\n\n\tif ((val & PCI_CONFIG_ELBI_STS_MASK) == PCI_CONFIG_ELBI_STS_DONE) {\n\t\tpci_read_config_dword(pdev, mmPCI_CONFIG_ELBI_DATA, data);\n\n\t\tif (unlikely(trace_habanalabs_elbi_read_enabled()))\n\t\t\ttrace_habanalabs_elbi_read(hdev->dev, (u32) addr, val);\n\n\t\treturn 0;\n\t}\n\n\tif (val & PCI_CONFIG_ELBI_STS_ERR) {\n\t\tdev_err(hdev->dev, \"Error reading from ELBI\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (!(val & PCI_CONFIG_ELBI_STS_MASK)) {\n\t\tdev_err(hdev->dev, \"ELBI read didn't finish in time\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev_err(hdev->dev, \"ELBI read has undefined bits in status\\n\");\n\treturn -EIO;\n}\n\n \nstatic int hl_pci_elbi_write(struct hl_device *hdev, u64 addr, u32 data)\n{\n\tstruct pci_dev *pdev = hdev->pdev;\n\tktime_t timeout;\n\tu64 msec;\n\tu32 val;\n\n\tif (hdev->pldm)\n\t\tmsec = HL_PLDM_PCI_ELBI_TIMEOUT_MSEC;\n\telse\n\t\tmsec = HL_PCI_ELBI_TIMEOUT_MSEC;\n\n\t \n\tpci_write_config_dword(pdev, mmPCI_CONFIG_ELBI_STS, 0);\n\n\tpci_write_config_dword(pdev, mmPCI_CONFIG_ELBI_ADDR, (u32) addr);\n\tpci_write_config_dword(pdev, mmPCI_CONFIG_ELBI_DATA, data);\n\tpci_write_config_dword(pdev, mmPCI_CONFIG_ELBI_CTRL,\n\t\t\t\tPCI_CONFIG_ELBI_CTRL_WRITE);\n\n\ttimeout = ktime_add_ms(ktime_get(), msec);\n\tfor (;;) {\n\t\tpci_read_config_dword(pdev, mmPCI_CONFIG_ELBI_STS, &val);\n\t\tif (val & PCI_CONFIG_ELBI_STS_MASK)\n\t\t\tbreak;\n\t\tif (ktime_compare(ktime_get(), timeout) > 0) {\n\t\t\tpci_read_config_dword(pdev, mmPCI_CONFIG_ELBI_STS,\n\t\t\t\t\t\t&val);\n\t\t\tbreak;\n\t\t}\n\n\t\tusleep_range(300, 500);\n\t}\n\n\tif ((val & PCI_CONFIG_ELBI_STS_MASK) == PCI_CONFIG_ELBI_STS_DONE) {\n\t\tif (unlikely(trace_habanalabs_elbi_write_enabled()))\n\t\t\ttrace_habanalabs_elbi_write(hdev->dev, (u32) addr, val);\n\t\treturn 0;\n\t}\n\n\tif (val & PCI_CONFIG_ELBI_STS_ERR)\n\t\treturn -EIO;\n\n\tif (!(val & PCI_CONFIG_ELBI_STS_MASK)) {\n\t\tdev_err(hdev->dev, \"ELBI write didn't finish in time\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev_err(hdev->dev, \"ELBI write has undefined bits in status\\n\");\n\treturn -EIO;\n}\n\n \nint hl_pci_iatu_write(struct hl_device *hdev, u32 addr, u32 data)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu32 dbi_offset;\n\tint rc;\n\n\tdbi_offset = addr & 0xFFF;\n\n\t \n\thl_pci_elbi_write(hdev, prop->pcie_aux_dbi_reg_addr, 0x00300000);\n\n\trc = hl_pci_elbi_write(hdev, prop->pcie_dbi_base_address + dbi_offset,\n\t\t\t\tdata);\n\n\tif (rc)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nint hl_pci_set_inbound_region(struct hl_device *hdev, u8 region,\n\t\tstruct hl_inbound_pci_region *pci_region)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu64 bar_phys_base, region_base, region_end_address;\n\tu32 offset, ctrl_reg_val;\n\tint rc = 0;\n\n\t \n\toffset = (0x200 * region) + 0x100;\n\n\tif (pci_region->mode == PCI_ADDRESS_MATCH_MODE) {\n\t\tbar_phys_base = hdev->pcie_bar_phys[pci_region->bar];\n\t\tregion_base = bar_phys_base + pci_region->offset_in_bar;\n\t\tregion_end_address = region_base + pci_region->size - 1;\n\n\t\trc |= hl_pci_iatu_write(hdev, offset + 0x8,\n\t\t\t\tlower_32_bits(region_base));\n\t\trc |= hl_pci_iatu_write(hdev, offset + 0xC,\n\t\t\t\tupper_32_bits(region_base));\n\t\trc |= hl_pci_iatu_write(hdev, offset + 0x10,\n\t\t\t\tlower_32_bits(region_end_address));\n\t}\n\n\t \n\trc |= hl_pci_iatu_write(hdev, offset + 0x14, lower_32_bits(pci_region->addr));\n\trc |= hl_pci_iatu_write(hdev, offset + 0x18, upper_32_bits(pci_region->addr));\n\n\t \n\trc |= hl_pci_iatu_write(hdev, offset + 0x0, 0);\n\n\t \n\tctrl_reg_val = FIELD_PREP(IATU_REGION_CTRL_REGION_EN_MASK, 1);\n\tctrl_reg_val |= FIELD_PREP(IATU_REGION_CTRL_MATCH_MODE_MASK, pci_region->mode);\n\tctrl_reg_val |= FIELD_PREP(IATU_REGION_CTRL_NUM_MATCH_EN_MASK, 1);\n\n\tif (pci_region->mode == PCI_BAR_MATCH_MODE)\n\t\tctrl_reg_val |= FIELD_PREP(IATU_REGION_CTRL_BAR_NUM_MASK, pci_region->bar);\n\n\trc |= hl_pci_iatu_write(hdev, offset + 0x4, ctrl_reg_val);\n\n\t \n\thl_pci_elbi_write(hdev, prop->pcie_aux_dbi_reg_addr, 0);\n\n\tif (rc)\n\t\tdev_err(hdev->dev, \"failed to map bar %u to 0x%08llx\\n\",\n\t\t\t\tpci_region->bar, pci_region->addr);\n\n\treturn rc;\n}\n\n \nint hl_pci_set_outbound_region(struct hl_device *hdev,\n\t\tstruct hl_outbound_pci_region *pci_region)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu64 outbound_region_end_address;\n\tint rc = 0;\n\n\t \n\toutbound_region_end_address =\n\t\t\tpci_region->addr + pci_region->size - 1;\n\trc |= hl_pci_iatu_write(hdev, 0x008,\n\t\t\t\tlower_32_bits(pci_region->addr));\n\trc |= hl_pci_iatu_write(hdev, 0x00C,\n\t\t\t\tupper_32_bits(pci_region->addr));\n\trc |= hl_pci_iatu_write(hdev, 0x010,\n\t\t\t\tlower_32_bits(outbound_region_end_address));\n\trc |= hl_pci_iatu_write(hdev, 0x014, 0);\n\n\trc |= hl_pci_iatu_write(hdev, 0x018, 0);\n\n\trc |= hl_pci_iatu_write(hdev, 0x020,\n\t\t\t\tupper_32_bits(outbound_region_end_address));\n\t \n\trc |= hl_pci_iatu_write(hdev, 0x000, 0x00002000);\n\t \n\trc |= hl_pci_iatu_write(hdev, 0x004, 0x80000000);\n\n\t \n\thl_pci_elbi_write(hdev, prop->pcie_aux_dbi_reg_addr, 0);\n\n\treturn rc;\n}\n\n \nenum pci_region hl_get_pci_memory_region(struct hl_device *hdev, u64 addr)\n{\n\tint i;\n\n\tfor  (i = 0 ; i < PCI_REGION_NUMBER ; i++) {\n\t\tstruct pci_mem_region *region = &hdev->pci_mem_region[i];\n\n\t\tif (!region->used)\n\t\t\tcontinue;\n\n\t\tif ((addr >= region->region_base) &&\n\t\t\t(addr < region->region_base + region->region_size))\n\t\t\treturn i;\n\t}\n\n\treturn PCI_REGION_NUMBER;\n}\n\n \nint hl_pci_init(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct pci_dev *pdev = hdev->pdev;\n\tint rc;\n\n\trc = pci_enable_device_mem(pdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"can't enable PCI device\\n\");\n\t\treturn rc;\n\t}\n\n\tpci_set_master(pdev);\n\n\trc = hdev->asic_funcs->pci_bars_map(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to map PCI BAR addresses\\n\");\n\t\tgoto disable_device;\n\t}\n\n\trc = hdev->asic_funcs->init_iatu(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"PCI controller was not initialized successfully\\n\");\n\t\tgoto unmap_pci_bars;\n\t}\n\n\t \n\tif (hdev->asic_prop.iatu_done_by_fw)\n\t\tusleep_range(2000, 3000);\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(prop->dma_mask));\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to set dma mask to %d bits, error %d\\n\",\n\t\t\tprop->dma_mask, rc);\n\t\tgoto unmap_pci_bars;\n\t}\n\n\tdma_set_max_seg_size(&pdev->dev, U32_MAX);\n\n\treturn 0;\n\nunmap_pci_bars:\n\thl_pci_bars_unmap(hdev);\ndisable_device:\n\tpci_disable_device(pdev);\n\n\treturn rc;\n}\n\n \nvoid hl_pci_fini(struct hl_device *hdev)\n{\n\thl_pci_bars_unmap(hdev);\n\n\tpci_disable_device(hdev->pdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}