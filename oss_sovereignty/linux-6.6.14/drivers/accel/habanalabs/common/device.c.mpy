{
  "module_name": "device.c",
  "hash_id": "2bfd758695782fa894c1a75f4866c32618d0ef60b83324b197006dedd5ec6f16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/common/device.c",
  "human_readable_source": "\n\n \n\n#define pr_fmt(fmt)\t\t\t\"habanalabs: \" fmt\n\n#include <uapi/drm/habanalabs_accel.h>\n#include \"habanalabs.h\"\n\n#include <linux/pci.h>\n#include <linux/hwmon.h>\n#include <linux/vmalloc.h>\n\n#include <trace/events/habanalabs.h>\n\n#define HL_RESET_DELAY_USEC\t\t\t10000\t \n\n#define HL_DEVICE_RELEASE_WATCHDOG_TIMEOUT_SEC\t5\n\nenum dma_alloc_type {\n\tDMA_ALLOC_COHERENT,\n\tDMA_ALLOC_POOL,\n};\n\n#define MEM_SCRUB_DEFAULT_VAL 0x1122334455667788\n\n \nstatic u64 hl_set_dram_bar(struct hl_device *hdev, u64 addr, struct pci_mem_region *region,\n\t\t\t\tu64 *new_bar_region_base)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu64 bar_base_addr, old_base;\n\n\tif (is_power_of_2(prop->dram_pci_bar_size))\n\t\tbar_base_addr = addr & ~(prop->dram_pci_bar_size - 0x1ull);\n\telse\n\t\tbar_base_addr = DIV_ROUND_DOWN_ULL(addr, prop->dram_pci_bar_size) *\n\t\t\t\tprop->dram_pci_bar_size;\n\n\told_base = hdev->asic_funcs->set_dram_bar_base(hdev, bar_base_addr);\n\n\t \n\tif ((old_base != U64_MAX) && new_bar_region_base)\n\t\t*new_bar_region_base = bar_base_addr;\n\n\treturn old_base;\n}\n\nint hl_access_sram_dram_region(struct hl_device *hdev, u64 addr, u64 *val,\n\tenum debugfs_access_type acc_type, enum pci_region region_type, bool set_dram_bar)\n{\n\tstruct pci_mem_region *region = &hdev->pci_mem_region[region_type];\n\tu64 old_base = 0, rc, bar_region_base = region->region_base;\n\tvoid __iomem *acc_addr;\n\n\tif (set_dram_bar) {\n\t\told_base = hl_set_dram_bar(hdev, addr, region, &bar_region_base);\n\t\tif (old_base == U64_MAX)\n\t\t\treturn -EIO;\n\t}\n\n\tacc_addr = hdev->pcie_bar[region->bar_id] + region->offset_in_bar +\n\t\t\t(addr - bar_region_base);\n\n\tswitch (acc_type) {\n\tcase DEBUGFS_READ8:\n\t\t*val = readb(acc_addr);\n\t\tbreak;\n\tcase DEBUGFS_WRITE8:\n\t\twriteb(*val, acc_addr);\n\t\tbreak;\n\tcase DEBUGFS_READ32:\n\t\t*val = readl(acc_addr);\n\t\tbreak;\n\tcase DEBUGFS_WRITE32:\n\t\twritel(*val, acc_addr);\n\t\tbreak;\n\tcase DEBUGFS_READ64:\n\t\t*val = readq(acc_addr);\n\t\tbreak;\n\tcase DEBUGFS_WRITE64:\n\t\twriteq(*val, acc_addr);\n\t\tbreak;\n\t}\n\n\tif (set_dram_bar) {\n\t\trc = hl_set_dram_bar(hdev, old_base, region, NULL);\n\t\tif (rc == U64_MAX)\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void *hl_dma_alloc_common(struct hl_device *hdev, size_t size, dma_addr_t *dma_handle,\n\t\t\t\t\tgfp_t flag, enum dma_alloc_type alloc_type,\n\t\t\t\t\tconst char *caller)\n{\n\tvoid *ptr = NULL;\n\n\tswitch (alloc_type) {\n\tcase DMA_ALLOC_COHERENT:\n\t\tptr = hdev->asic_funcs->asic_dma_alloc_coherent(hdev, size, dma_handle, flag);\n\t\tbreak;\n\tcase DMA_ALLOC_POOL:\n\t\tptr = hdev->asic_funcs->asic_dma_pool_zalloc(hdev, size, flag, dma_handle);\n\t\tbreak;\n\t}\n\n\tif (trace_habanalabs_dma_alloc_enabled() && !ZERO_OR_NULL_PTR(ptr))\n\t\ttrace_habanalabs_dma_alloc(hdev->dev, (u64) (uintptr_t) ptr, *dma_handle, size,\n\t\t\t\t\t\tcaller);\n\n\treturn ptr;\n}\n\nstatic void hl_asic_dma_free_common(struct hl_device *hdev, size_t size, void *cpu_addr,\n\t\t\t\t\tdma_addr_t dma_handle, enum dma_alloc_type alloc_type,\n\t\t\t\t\tconst char *caller)\n{\n\t \n\tu64 store_cpu_addr = (u64) (uintptr_t) cpu_addr;\n\n\tswitch (alloc_type) {\n\tcase DMA_ALLOC_COHERENT:\n\t\thdev->asic_funcs->asic_dma_free_coherent(hdev, size, cpu_addr, dma_handle);\n\t\tbreak;\n\tcase DMA_ALLOC_POOL:\n\t\thdev->asic_funcs->asic_dma_pool_free(hdev, cpu_addr, dma_handle);\n\t\tbreak;\n\t}\n\n\ttrace_habanalabs_dma_free(hdev->dev, store_cpu_addr, dma_handle, size, caller);\n}\n\nvoid *hl_asic_dma_alloc_coherent_caller(struct hl_device *hdev, size_t size, dma_addr_t *dma_handle,\n\t\t\t\t\tgfp_t flag, const char *caller)\n{\n\treturn hl_dma_alloc_common(hdev, size, dma_handle, flag, DMA_ALLOC_COHERENT, caller);\n}\n\nvoid hl_asic_dma_free_coherent_caller(struct hl_device *hdev, size_t size, void *cpu_addr,\n\t\t\t\t\tdma_addr_t dma_handle, const char *caller)\n{\n\thl_asic_dma_free_common(hdev, size, cpu_addr, dma_handle, DMA_ALLOC_COHERENT, caller);\n}\n\nvoid *hl_asic_dma_pool_zalloc_caller(struct hl_device *hdev, size_t size, gfp_t mem_flags,\n\t\t\t\t\tdma_addr_t *dma_handle, const char *caller)\n{\n\treturn hl_dma_alloc_common(hdev, size, dma_handle, mem_flags, DMA_ALLOC_POOL, caller);\n}\n\nvoid hl_asic_dma_pool_free_caller(struct hl_device *hdev, void *vaddr, dma_addr_t dma_addr,\n\t\t\t\t\tconst char *caller)\n{\n\thl_asic_dma_free_common(hdev, 0, vaddr, dma_addr, DMA_ALLOC_POOL, caller);\n}\n\nvoid *hl_cpu_accessible_dma_pool_alloc(struct hl_device *hdev, size_t size, dma_addr_t *dma_handle)\n{\n\treturn hdev->asic_funcs->cpu_accessible_dma_pool_alloc(hdev, size, dma_handle);\n}\n\nvoid hl_cpu_accessible_dma_pool_free(struct hl_device *hdev, size_t size, void *vaddr)\n{\n\thdev->asic_funcs->cpu_accessible_dma_pool_free(hdev, size, vaddr);\n}\n\nint hl_dma_map_sgtable(struct hl_device *hdev, struct sg_table *sgt, enum dma_data_direction dir)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct scatterlist *sg;\n\tint rc, i;\n\n\trc = dma_map_sgtable(&hdev->pdev->dev, sgt, dir, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (prop->device_dma_offset_for_host_access)\n\t\tfor_each_sgtable_dma_sg(sgt, sg, i)\n\t\t\tsg->dma_address += prop->device_dma_offset_for_host_access;\n\n\treturn 0;\n}\n\nvoid hl_dma_unmap_sgtable(struct hl_device *hdev, struct sg_table *sgt, enum dma_data_direction dir)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct scatterlist *sg;\n\tint i;\n\n\t \n\tif (prop->device_dma_offset_for_host_access)\n\t\tfor_each_sgtable_dma_sg(sgt, sg, i)\n\t\t\tsg->dma_address -= prop->device_dma_offset_for_host_access;\n\n\tdma_unmap_sgtable(&hdev->pdev->dev, sgt, dir, 0);\n}\n\n \nint hl_access_cfg_region(struct hl_device *hdev, u64 addr, u64 *val,\n\tenum debugfs_access_type acc_type)\n{\n\tstruct pci_mem_region *cfg_region = &hdev->pci_mem_region[PCI_REGION_CFG];\n\tu32 val_h, val_l;\n\n\tif (!IS_ALIGNED(addr, sizeof(u32))) {\n\t\tdev_err(hdev->dev, \"address %#llx not a multiple of %zu\\n\", addr, sizeof(u32));\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (acc_type) {\n\tcase DEBUGFS_READ32:\n\t\t*val = RREG32(addr - cfg_region->region_base);\n\t\tbreak;\n\tcase DEBUGFS_WRITE32:\n\t\tWREG32(addr - cfg_region->region_base, *val);\n\t\tbreak;\n\tcase DEBUGFS_READ64:\n\t\tval_l = RREG32(addr - cfg_region->region_base);\n\t\tval_h = RREG32(addr + sizeof(u32) - cfg_region->region_base);\n\n\t\t*val = (((u64) val_h) << 32) | val_l;\n\t\tbreak;\n\tcase DEBUGFS_WRITE64:\n\t\tWREG32(addr - cfg_region->region_base, lower_32_bits(*val));\n\t\tWREG32(addr + sizeof(u32) - cfg_region->region_base, upper_32_bits(*val));\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdev->dev, \"access type %d is not supported\\n\", acc_type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nint hl_access_dev_mem(struct hl_device *hdev, enum pci_region region_type,\n\t\t\tu64 addr, u64 *val, enum debugfs_access_type acc_type)\n{\n\tswitch (region_type) {\n\tcase PCI_REGION_CFG:\n\t\treturn hl_access_cfg_region(hdev, addr, val, acc_type);\n\tcase PCI_REGION_SRAM:\n\tcase PCI_REGION_DRAM:\n\t\treturn hl_access_sram_dram_region(hdev, addr, val, acc_type,\n\t\t\t\tregion_type, (region_type == PCI_REGION_DRAM));\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nvoid hl_engine_data_sprintf(struct engines_data *e, const char *fmt, ...)\n{\n\tva_list args;\n\tint str_size;\n\n\tva_start(args, fmt);\n\t \n\tstr_size = vsnprintf(NULL, 0, fmt, args) + 1;\n\tva_end(args);\n\n\tif ((e->actual_size + str_size) < e->allocated_buf_size) {\n\t\tva_start(args, fmt);\n\t\tvsnprintf(e->buf + e->actual_size, str_size, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t \n\te->actual_size += str_size;\n}\n\nenum hl_device_status hl_device_status(struct hl_device *hdev)\n{\n\tenum hl_device_status status;\n\n\tif (hdev->reset_info.in_reset) {\n\t\tif (hdev->reset_info.in_compute_reset)\n\t\t\tstatus = HL_DEVICE_STATUS_IN_RESET_AFTER_DEVICE_RELEASE;\n\t\telse\n\t\t\tstatus = HL_DEVICE_STATUS_IN_RESET;\n\t} else if (hdev->reset_info.needs_reset) {\n\t\tstatus = HL_DEVICE_STATUS_NEEDS_RESET;\n\t} else if (hdev->disabled) {\n\t\tstatus = HL_DEVICE_STATUS_MALFUNCTION;\n\t} else if (!hdev->init_done) {\n\t\tstatus = HL_DEVICE_STATUS_IN_DEVICE_CREATION;\n\t} else {\n\t\tstatus = HL_DEVICE_STATUS_OPERATIONAL;\n\t}\n\n\treturn status;\n}\n\nbool hl_device_operational(struct hl_device *hdev,\n\t\tenum hl_device_status *status)\n{\n\tenum hl_device_status current_status;\n\n\tcurrent_status = hl_device_status(hdev);\n\tif (status)\n\t\t*status = current_status;\n\n\tswitch (current_status) {\n\tcase HL_DEVICE_STATUS_IN_RESET:\n\tcase HL_DEVICE_STATUS_IN_RESET_AFTER_DEVICE_RELEASE:\n\tcase HL_DEVICE_STATUS_MALFUNCTION:\n\tcase HL_DEVICE_STATUS_NEEDS_RESET:\n\t\treturn false;\n\tcase HL_DEVICE_STATUS_OPERATIONAL:\n\tcase HL_DEVICE_STATUS_IN_DEVICE_CREATION:\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nbool hl_ctrl_device_operational(struct hl_device *hdev,\n\t\tenum hl_device_status *status)\n{\n\tenum hl_device_status current_status;\n\n\tcurrent_status = hl_device_status(hdev);\n\tif (status)\n\t\t*status = current_status;\n\n\tswitch (current_status) {\n\tcase HL_DEVICE_STATUS_MALFUNCTION:\n\t\treturn false;\n\tcase HL_DEVICE_STATUS_IN_RESET:\n\tcase HL_DEVICE_STATUS_IN_RESET_AFTER_DEVICE_RELEASE:\n\tcase HL_DEVICE_STATUS_NEEDS_RESET:\n\tcase HL_DEVICE_STATUS_OPERATIONAL:\n\tcase HL_DEVICE_STATUS_IN_DEVICE_CREATION:\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic void print_idle_status_mask(struct hl_device *hdev, const char *message,\n\t\t\t\t\tu64 idle_mask[HL_BUSY_ENGINES_MASK_EXT_SIZE])\n{\n\tif (idle_mask[3])\n\t\tdev_err(hdev->dev, \"%s (mask %#llx_%016llx_%016llx_%016llx)\\n\",\n\t\t\tmessage, idle_mask[3], idle_mask[2], idle_mask[1], idle_mask[0]);\n\telse if (idle_mask[2])\n\t\tdev_err(hdev->dev, \"%s (mask %#llx_%016llx_%016llx)\\n\",\n\t\t\tmessage, idle_mask[2], idle_mask[1], idle_mask[0]);\n\telse if (idle_mask[1])\n\t\tdev_err(hdev->dev, \"%s (mask %#llx_%016llx)\\n\",\n\t\t\tmessage, idle_mask[1], idle_mask[0]);\n\telse\n\t\tdev_err(hdev->dev, \"%s (mask %#llx)\\n\", message, idle_mask[0]);\n}\n\nstatic void hpriv_release(struct kref *ref)\n{\n\tu64 idle_mask[HL_BUSY_ENGINES_MASK_EXT_SIZE] = {0};\n\tbool reset_device, device_is_idle = true;\n\tstruct hl_fpriv *hpriv;\n\tstruct hl_device *hdev;\n\n\thpriv = container_of(ref, struct hl_fpriv, refcount);\n\n\thdev = hpriv->hdev;\n\n\thdev->asic_funcs->send_device_activity(hdev, false);\n\n\tput_pid(hpriv->taskpid);\n\n\thl_debugfs_remove_file(hpriv);\n\n\tmutex_destroy(&hpriv->ctx_lock);\n\tmutex_destroy(&hpriv->restore_phase_mutex);\n\n\t \n\thl_mem_mgr_idr_destroy(&hpriv->mem_mgr);\n\n\t \n\treset_device = hdev->reset_upon_device_release || hdev->reset_info.watchdog_active;\n\n\t \n\tif (!hdev->reset_info.in_reset && !reset_device && hdev->pdev && !hdev->pldm)\n\t\tdevice_is_idle = hdev->asic_funcs->is_device_idle(hdev, idle_mask,\n\t\t\t\t\t\t\tHL_BUSY_ENGINES_MASK_EXT_SIZE, NULL);\n\tif (!device_is_idle) {\n\t\tprint_idle_status_mask(hdev, \"device is not idle after user context is closed\",\n\t\t\t\t\tidle_mask);\n\t\treset_device = true;\n\t}\n\n\t \n\tmutex_lock(&hdev->fpriv_list_lock);\n\tlist_del(&hpriv->dev_node);\n\tmutex_unlock(&hdev->fpriv_list_lock);\n\n\tif (reset_device) {\n\t\thl_device_reset(hdev, HL_DRV_RESET_DEV_RELEASE);\n\t} else {\n\t\t \n\t\tint rc = hdev->asic_funcs->scrub_device_mem(hdev);\n\n\t\tif (rc)\n\t\t\tdev_err(hdev->dev, \"failed to scrub memory from hpriv release (%d)\\n\", rc);\n\t}\n\n\t \n\tmutex_lock(&hdev->fpriv_list_lock);\n\thdev->is_compute_ctx_active = false;\n\tmutex_unlock(&hdev->fpriv_list_lock);\n\n\thdev->compute_ctx_in_release = 0;\n\n\t \n\tif (hpriv->notifier_event.eventfd)\n\t\teventfd_ctx_put(hpriv->notifier_event.eventfd);\n\n\tmutex_destroy(&hpriv->notifier_event.lock);\n\n\tkfree(hpriv);\n}\n\nvoid hl_hpriv_get(struct hl_fpriv *hpriv)\n{\n\tkref_get(&hpriv->refcount);\n}\n\nint hl_hpriv_put(struct hl_fpriv *hpriv)\n{\n\treturn kref_put(&hpriv->refcount, hpriv_release);\n}\n\nstatic void print_device_in_use_info(struct hl_device *hdev, const char *message)\n{\n\tu32 active_cs_num, dmabuf_export_cnt;\n\tbool unknown_reason = true;\n\tchar buf[128];\n\tsize_t size;\n\tint offset;\n\n\tsize = sizeof(buf);\n\toffset = 0;\n\n\tactive_cs_num = hl_get_active_cs_num(hdev);\n\tif (active_cs_num) {\n\t\tunknown_reason = false;\n\t\toffset += scnprintf(buf + offset, size - offset, \" [%u active CS]\", active_cs_num);\n\t}\n\n\tdmabuf_export_cnt = atomic_read(&hdev->dmabuf_export_cnt);\n\tif (dmabuf_export_cnt) {\n\t\tunknown_reason = false;\n\t\toffset += scnprintf(buf + offset, size - offset, \" [%u exported dma-buf]\",\n\t\t\t\t\tdmabuf_export_cnt);\n\t}\n\n\tif (unknown_reason)\n\t\tscnprintf(buf + offset, size - offset, \" [unknown reason]\");\n\n\tdev_notice(hdev->dev, \"%s%s\\n\", message, buf);\n}\n\n \nstatic int hl_device_release(struct inode *inode, struct file *filp)\n{\n\tstruct hl_fpriv *hpriv = filp->private_data;\n\tstruct hl_device *hdev = hpriv->hdev;\n\n\tfilp->private_data = NULL;\n\n\tif (!hdev) {\n\t\tpr_crit(\"Closing FD after device was removed. Memory leak will occur and it is advised to reboot.\\n\");\n\t\tput_pid(hpriv->taskpid);\n\t\treturn 0;\n\t}\n\n\thl_ctx_mgr_fini(hdev, &hpriv->ctx_mgr);\n\n\t \n\thl_mem_mgr_fini(&hpriv->mem_mgr);\n\n\thdev->compute_ctx_in_release = 1;\n\n\tif (!hl_hpriv_put(hpriv)) {\n\t\tprint_device_in_use_info(hdev, \"User process closed FD but device still in use\");\n\t\thl_device_reset(hdev, HL_DRV_RESET_HARD);\n\t}\n\n\thdev->last_open_session_duration_jif = jiffies - hdev->last_successful_open_jif;\n\n\treturn 0;\n}\n\nstatic int hl_device_release_ctrl(struct inode *inode, struct file *filp)\n{\n\tstruct hl_fpriv *hpriv = filp->private_data;\n\tstruct hl_device *hdev = hpriv->hdev;\n\n\tfilp->private_data = NULL;\n\n\tif (!hdev) {\n\t\tpr_err(\"Closing FD after device was removed\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&hdev->fpriv_ctrl_list_lock);\n\tlist_del(&hpriv->dev_node);\n\tmutex_unlock(&hdev->fpriv_ctrl_list_lock);\nout:\n\t \n\tif (hpriv->notifier_event.eventfd)\n\t\teventfd_ctx_put(hpriv->notifier_event.eventfd);\n\n\tmutex_destroy(&hpriv->notifier_event.lock);\n\tput_pid(hpriv->taskpid);\n\n\tkfree(hpriv);\n\n\treturn 0;\n}\n\n \nstatic int hl_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct hl_fpriv *hpriv = filp->private_data;\n\tstruct hl_device *hdev = hpriv->hdev;\n\tunsigned long vm_pgoff;\n\n\tif (!hdev) {\n\t\tpr_err_ratelimited(\"Trying to mmap after device was removed! Please close FD\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tvm_pgoff = vma->vm_pgoff;\n\n\tswitch (vm_pgoff & HL_MMAP_TYPE_MASK) {\n\tcase HL_MMAP_TYPE_BLOCK:\n\t\tvma->vm_pgoff = HL_MMAP_OFFSET_VALUE_GET(vm_pgoff);\n\t\treturn hl_hw_block_mmap(hpriv, vma);\n\n\tcase HL_MMAP_TYPE_CB:\n\tcase HL_MMAP_TYPE_TS_BUFF:\n\t\treturn hl_mem_mgr_mmap(&hpriv->mem_mgr, vma, NULL);\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct file_operations hl_ops = {\n\t.owner = THIS_MODULE,\n\t.open = hl_device_open,\n\t.release = hl_device_release,\n\t.mmap = hl_mmap,\n\t.unlocked_ioctl = hl_ioctl,\n\t.compat_ioctl = hl_ioctl\n};\n\nstatic const struct file_operations hl_ctrl_ops = {\n\t.owner = THIS_MODULE,\n\t.open = hl_device_open_ctrl,\n\t.release = hl_device_release_ctrl,\n\t.unlocked_ioctl = hl_ioctl_control,\n\t.compat_ioctl = hl_ioctl_control\n};\n\nstatic void device_release_func(struct device *dev)\n{\n\tkfree(dev);\n}\n\n \nstatic int device_init_cdev(struct hl_device *hdev, struct class *class,\n\t\t\t\tint minor, const struct file_operations *fops,\n\t\t\t\tchar *name, struct cdev *cdev,\n\t\t\t\tstruct device **dev)\n{\n\tcdev_init(cdev, fops);\n\tcdev->owner = THIS_MODULE;\n\n\t*dev = kzalloc(sizeof(**dev), GFP_KERNEL);\n\tif (!*dev)\n\t\treturn -ENOMEM;\n\n\tdevice_initialize(*dev);\n\t(*dev)->devt = MKDEV(hdev->major, minor);\n\t(*dev)->class = class;\n\t(*dev)->release = device_release_func;\n\tdev_set_drvdata(*dev, hdev);\n\tdev_set_name(*dev, \"%s\", name);\n\n\treturn 0;\n}\n\nstatic int cdev_sysfs_debugfs_add(struct hl_device *hdev)\n{\n\tint rc;\n\n\trc = cdev_device_add(&hdev->cdev, hdev->dev);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"failed to add a char device to the system\\n\");\n\t\treturn rc;\n\t}\n\n\trc = cdev_device_add(&hdev->cdev_ctrl, hdev->dev_ctrl);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"failed to add a control char device to the system\\n\");\n\t\tgoto delete_cdev_device;\n\t}\n\n\t \n\trc = hl_sysfs_init(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to initialize sysfs\\n\");\n\t\tgoto delete_ctrl_cdev_device;\n\t}\n\n\thl_debugfs_add_device(hdev);\n\n\thdev->cdev_sysfs_debugfs_created = true;\n\n\treturn 0;\n\ndelete_ctrl_cdev_device:\n\tcdev_device_del(&hdev->cdev_ctrl, hdev->dev_ctrl);\ndelete_cdev_device:\n\tcdev_device_del(&hdev->cdev, hdev->dev);\n\treturn rc;\n}\n\nstatic void cdev_sysfs_debugfs_remove(struct hl_device *hdev)\n{\n\tif (!hdev->cdev_sysfs_debugfs_created)\n\t\tgoto put_devices;\n\n\thl_debugfs_remove_device(hdev);\n\thl_sysfs_fini(hdev);\n\tcdev_device_del(&hdev->cdev_ctrl, hdev->dev_ctrl);\n\tcdev_device_del(&hdev->cdev, hdev->dev);\n\nput_devices:\n\tput_device(hdev->dev);\n\tput_device(hdev->dev_ctrl);\n}\n\nstatic void device_hard_reset_pending(struct work_struct *work)\n{\n\tstruct hl_device_reset_work *device_reset_work =\n\t\tcontainer_of(work, struct hl_device_reset_work, reset_work.work);\n\tstruct hl_device *hdev = device_reset_work->hdev;\n\tu32 flags;\n\tint rc;\n\n\tflags = device_reset_work->flags | HL_DRV_RESET_FROM_RESET_THR;\n\n\trc = hl_device_reset(hdev, flags);\n\n\tif ((rc == -EBUSY) && !hdev->device_fini_pending) {\n\t\tstruct hl_ctx *ctx = hl_get_compute_ctx(hdev);\n\n\t\tif (ctx) {\n\t\t\t \n\t\t\tdev_info(hdev->dev,\n\t\t\t\t\"Could not reset device (compute_ctx refcount %u). will try again in %u seconds\",\n\t\t\t\tkref_read(&ctx->refcount) - 1, HL_PENDING_RESET_PER_SEC);\n\t\t\thl_ctx_put(ctx);\n\t\t} else {\n\t\t\tdev_info(hdev->dev, \"Could not reset device. will try again in %u seconds\",\n\t\t\t\tHL_PENDING_RESET_PER_SEC);\n\t\t}\n\n\t\tqueue_delayed_work(hdev->reset_wq, &device_reset_work->reset_work,\n\t\t\t\t\tmsecs_to_jiffies(HL_PENDING_RESET_PER_SEC * 1000));\n\t}\n}\n\nstatic void device_release_watchdog_func(struct work_struct *work)\n{\n\tstruct hl_device_reset_work *watchdog_work =\n\t\t\tcontainer_of(work, struct hl_device_reset_work, reset_work.work);\n\tstruct hl_device *hdev = watchdog_work->hdev;\n\tu32 flags;\n\n\tdev_dbg(hdev->dev, \"Device wasn't released in time. Initiate hard-reset.\\n\");\n\n\tflags = watchdog_work->flags | HL_DRV_RESET_HARD | HL_DRV_RESET_FROM_WD_THR;\n\n\thl_device_reset(hdev, flags);\n}\n\n \nstatic int device_early_init(struct hl_device *hdev)\n{\n\tint i, rc;\n\tchar workq_name[32];\n\n\tswitch (hdev->asic_type) {\n\tcase ASIC_GOYA:\n\t\tgoya_set_asic_funcs(hdev);\n\t\tstrscpy(hdev->asic_name, \"GOYA\", sizeof(hdev->asic_name));\n\t\tbreak;\n\tcase ASIC_GAUDI:\n\t\tgaudi_set_asic_funcs(hdev);\n\t\tstrscpy(hdev->asic_name, \"GAUDI\", sizeof(hdev->asic_name));\n\t\tbreak;\n\tcase ASIC_GAUDI_SEC:\n\t\tgaudi_set_asic_funcs(hdev);\n\t\tstrscpy(hdev->asic_name, \"GAUDI SEC\", sizeof(hdev->asic_name));\n\t\tbreak;\n\tcase ASIC_GAUDI2:\n\t\tgaudi2_set_asic_funcs(hdev);\n\t\tstrscpy(hdev->asic_name, \"GAUDI2\", sizeof(hdev->asic_name));\n\t\tbreak;\n\tcase ASIC_GAUDI2B:\n\t\tgaudi2_set_asic_funcs(hdev);\n\t\tstrscpy(hdev->asic_name, \"GAUDI2B\", sizeof(hdev->asic_name));\n\t\tbreak;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdev->dev, \"Unrecognized ASIC type %d\\n\",\n\t\t\thdev->asic_type);\n\t\treturn -EINVAL;\n\t}\n\n\trc = hdev->asic_funcs->early_init(hdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hl_asid_init(hdev);\n\tif (rc)\n\t\tgoto early_fini;\n\n\tif (hdev->asic_prop.completion_queues_count) {\n\t\thdev->cq_wq = kcalloc(hdev->asic_prop.completion_queues_count,\n\t\t\t\tsizeof(struct workqueue_struct *),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!hdev->cq_wq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto asid_fini;\n\t\t}\n\t}\n\n\tfor (i = 0 ; i < hdev->asic_prop.completion_queues_count ; i++) {\n\t\tsnprintf(workq_name, 32, \"hl%u-free-jobs-%u\", hdev->cdev_idx, (u32) i);\n\t\thdev->cq_wq[i] = create_singlethread_workqueue(workq_name);\n\t\tif (hdev->cq_wq[i] == NULL) {\n\t\t\tdev_err(hdev->dev, \"Failed to allocate CQ workqueue\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_cq_wq;\n\t\t}\n\t}\n\n\tsnprintf(workq_name, 32, \"hl%u-events\", hdev->cdev_idx);\n\thdev->eq_wq = create_singlethread_workqueue(workq_name);\n\tif (hdev->eq_wq == NULL) {\n\t\tdev_err(hdev->dev, \"Failed to allocate EQ workqueue\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto free_cq_wq;\n\t}\n\n\tsnprintf(workq_name, 32, \"hl%u-cs-completions\", hdev->cdev_idx);\n\thdev->cs_cmplt_wq = alloc_workqueue(workq_name, WQ_UNBOUND, 0);\n\tif (!hdev->cs_cmplt_wq) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate CS completions workqueue\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto free_eq_wq;\n\t}\n\n\tsnprintf(workq_name, 32, \"hl%u-ts-free-obj\", hdev->cdev_idx);\n\thdev->ts_free_obj_wq = alloc_workqueue(workq_name, WQ_UNBOUND, 0);\n\tif (!hdev->ts_free_obj_wq) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate Timestamp registration free workqueue\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto free_cs_cmplt_wq;\n\t}\n\n\tsnprintf(workq_name, 32, \"hl%u-prefetch\", hdev->cdev_idx);\n\thdev->prefetch_wq = alloc_workqueue(workq_name, WQ_UNBOUND, 0);\n\tif (!hdev->prefetch_wq) {\n\t\tdev_err(hdev->dev, \"Failed to allocate MMU prefetch workqueue\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto free_ts_free_wq;\n\t}\n\n\thdev->hl_chip_info = kzalloc(sizeof(struct hwmon_chip_info), GFP_KERNEL);\n\tif (!hdev->hl_chip_info) {\n\t\trc = -ENOMEM;\n\t\tgoto free_prefetch_wq;\n\t}\n\n\trc = hl_mmu_if_set_funcs(hdev);\n\tif (rc)\n\t\tgoto free_chip_info;\n\n\thl_mem_mgr_init(hdev->dev, &hdev->kernel_mem_mgr);\n\n\tsnprintf(workq_name, 32, \"hl%u_device_reset\", hdev->cdev_idx);\n\thdev->reset_wq = create_singlethread_workqueue(workq_name);\n\tif (!hdev->reset_wq) {\n\t\trc = -ENOMEM;\n\t\tdev_err(hdev->dev, \"Failed to create device reset WQ\\n\");\n\t\tgoto free_cb_mgr;\n\t}\n\n\tINIT_DELAYED_WORK(&hdev->device_reset_work.reset_work, device_hard_reset_pending);\n\thdev->device_reset_work.hdev = hdev;\n\thdev->device_fini_pending = 0;\n\n\tINIT_DELAYED_WORK(&hdev->device_release_watchdog_work.reset_work,\n\t\t\t\tdevice_release_watchdog_func);\n\thdev->device_release_watchdog_work.hdev = hdev;\n\n\tmutex_init(&hdev->send_cpu_message_lock);\n\tmutex_init(&hdev->debug_lock);\n\tINIT_LIST_HEAD(&hdev->cs_mirror_list);\n\tspin_lock_init(&hdev->cs_mirror_lock);\n\tspin_lock_init(&hdev->reset_info.lock);\n\tINIT_LIST_HEAD(&hdev->fpriv_list);\n\tINIT_LIST_HEAD(&hdev->fpriv_ctrl_list);\n\tmutex_init(&hdev->fpriv_list_lock);\n\tmutex_init(&hdev->fpriv_ctrl_list_lock);\n\tmutex_init(&hdev->clk_throttling.lock);\n\n\treturn 0;\n\nfree_cb_mgr:\n\thl_mem_mgr_fini(&hdev->kernel_mem_mgr);\n\thl_mem_mgr_idr_destroy(&hdev->kernel_mem_mgr);\nfree_chip_info:\n\tkfree(hdev->hl_chip_info);\nfree_prefetch_wq:\n\tdestroy_workqueue(hdev->prefetch_wq);\nfree_ts_free_wq:\n\tdestroy_workqueue(hdev->ts_free_obj_wq);\nfree_cs_cmplt_wq:\n\tdestroy_workqueue(hdev->cs_cmplt_wq);\nfree_eq_wq:\n\tdestroy_workqueue(hdev->eq_wq);\nfree_cq_wq:\n\tfor (i = 0 ; i < hdev->asic_prop.completion_queues_count ; i++)\n\t\tif (hdev->cq_wq[i])\n\t\t\tdestroy_workqueue(hdev->cq_wq[i]);\n\tkfree(hdev->cq_wq);\nasid_fini:\n\thl_asid_fini(hdev);\nearly_fini:\n\tif (hdev->asic_funcs->early_fini)\n\t\thdev->asic_funcs->early_fini(hdev);\n\n\treturn rc;\n}\n\n \nstatic void device_early_fini(struct hl_device *hdev)\n{\n\tint i;\n\n\tmutex_destroy(&hdev->debug_lock);\n\tmutex_destroy(&hdev->send_cpu_message_lock);\n\n\tmutex_destroy(&hdev->fpriv_list_lock);\n\tmutex_destroy(&hdev->fpriv_ctrl_list_lock);\n\n\tmutex_destroy(&hdev->clk_throttling.lock);\n\n\thl_mem_mgr_fini(&hdev->kernel_mem_mgr);\n\thl_mem_mgr_idr_destroy(&hdev->kernel_mem_mgr);\n\n\tkfree(hdev->hl_chip_info);\n\n\tdestroy_workqueue(hdev->prefetch_wq);\n\tdestroy_workqueue(hdev->ts_free_obj_wq);\n\tdestroy_workqueue(hdev->cs_cmplt_wq);\n\tdestroy_workqueue(hdev->eq_wq);\n\tdestroy_workqueue(hdev->reset_wq);\n\n\tfor (i = 0 ; i < hdev->asic_prop.completion_queues_count ; i++)\n\t\tdestroy_workqueue(hdev->cq_wq[i]);\n\tkfree(hdev->cq_wq);\n\n\thl_asid_fini(hdev);\n\n\tif (hdev->asic_funcs->early_fini)\n\t\thdev->asic_funcs->early_fini(hdev);\n}\n\nstatic bool is_pci_link_healthy(struct hl_device *hdev)\n{\n\tu16 vendor_id;\n\n\tif (!hdev->pdev)\n\t\treturn false;\n\n\tpci_read_config_word(hdev->pdev, PCI_VENDOR_ID, &vendor_id);\n\n\treturn (vendor_id == PCI_VENDOR_ID_HABANALABS);\n}\n\nstatic void hl_device_heartbeat(struct work_struct *work)\n{\n\tstruct hl_device *hdev = container_of(work, struct hl_device,\n\t\t\t\t\t\twork_heartbeat.work);\n\tstruct hl_info_fw_err_info info = {0};\n\tu64 event_mask = HL_NOTIFIER_EVENT_DEVICE_RESET | HL_NOTIFIER_EVENT_DEVICE_UNAVAILABLE;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\tgoto reschedule;\n\n\tif (!hdev->asic_funcs->send_heartbeat(hdev))\n\t\tgoto reschedule;\n\n\tif (hl_device_operational(hdev, NULL))\n\t\tdev_err(hdev->dev, \"Device heartbeat failed! PCI link is %s\\n\",\n\t\t\tis_pci_link_healthy(hdev) ? \"healthy\" : \"broken\");\n\n\tinfo.err_type = HL_INFO_FW_HEARTBEAT_ERR;\n\tinfo.event_mask = &event_mask;\n\thl_handle_fw_err(hdev, &info);\n\thl_device_cond_reset(hdev, HL_DRV_RESET_HARD | HL_DRV_RESET_HEARTBEAT, event_mask);\n\n\treturn;\n\nreschedule:\n\t \n\tif (!hdev->reset_info.in_reset)\n\t\thdev->reset_info.prev_reset_trigger = HL_RESET_TRIGGER_DEFAULT;\n\n\tschedule_delayed_work(&hdev->work_heartbeat,\n\t\t\tusecs_to_jiffies(HL_HEARTBEAT_PER_USEC));\n}\n\n \nstatic int device_late_init(struct hl_device *hdev)\n{\n\tint rc;\n\n\tif (hdev->asic_funcs->late_init) {\n\t\trc = hdev->asic_funcs->late_init(hdev);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"failed late initialization for the H/W\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\thdev->high_pll = hdev->asic_prop.high_pll;\n\n\tif (hdev->heartbeat) {\n\t\tINIT_DELAYED_WORK(&hdev->work_heartbeat, hl_device_heartbeat);\n\t\tschedule_delayed_work(&hdev->work_heartbeat,\n\t\t\t\tusecs_to_jiffies(HL_HEARTBEAT_PER_USEC));\n\t}\n\n\thdev->late_init_done = true;\n\n\treturn 0;\n}\n\n \nstatic void device_late_fini(struct hl_device *hdev)\n{\n\tif (!hdev->late_init_done)\n\t\treturn;\n\n\tif (hdev->heartbeat)\n\t\tcancel_delayed_work_sync(&hdev->work_heartbeat);\n\n\tif (hdev->asic_funcs->late_fini)\n\t\thdev->asic_funcs->late_fini(hdev);\n\n\thdev->late_init_done = false;\n}\n\nint hl_device_utilization(struct hl_device *hdev, u32 *utilization)\n{\n\tu64 max_power, curr_power, dc_power, dividend, divisor;\n\tint rc;\n\n\tmax_power = hdev->max_power;\n\tdc_power = hdev->asic_prop.dc_power_default;\n\tdivisor = max_power - dc_power;\n\tif (!divisor) {\n\t\tdev_warn(hdev->dev, \"device utilization is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\trc = hl_fw_cpucp_power_get(hdev, &curr_power);\n\n\tif (rc)\n\t\treturn rc;\n\n\tcurr_power = clamp(curr_power, dc_power, max_power);\n\n\tdividend = (curr_power - dc_power) * 100;\n\t*utilization = (u32) div_u64(dividend, divisor);\n\n\treturn 0;\n}\n\nint hl_device_set_debug_mode(struct hl_device *hdev, struct hl_ctx *ctx, bool enable)\n{\n\tint rc = 0;\n\n\tmutex_lock(&hdev->debug_lock);\n\n\tif (!enable) {\n\t\tif (!hdev->in_debug) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Failed to disable debug mode because device was not in debug mode\\n\");\n\t\t\trc = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!hdev->reset_info.hard_reset_pending)\n\t\t\thdev->asic_funcs->halt_coresight(hdev, ctx);\n\n\t\thdev->in_debug = 0;\n\n\t\tgoto out;\n\t}\n\n\tif (hdev->in_debug) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to enable debug mode because device is already in debug mode\\n\");\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\thdev->in_debug = 1;\n\nout:\n\tmutex_unlock(&hdev->debug_lock);\n\n\treturn rc;\n}\n\nstatic void take_release_locks(struct hl_device *hdev)\n{\n\t \n\thdev->asic_funcs->hw_queues_lock(hdev);\n\thdev->asic_funcs->hw_queues_unlock(hdev);\n\n\t \n\tmutex_lock(&hdev->send_cpu_message_lock);\n\tmutex_unlock(&hdev->send_cpu_message_lock);\n\n\t \n\tmutex_lock(&hdev->fpriv_list_lock);\n\tmutex_unlock(&hdev->fpriv_list_lock);\n\tmutex_lock(&hdev->fpriv_ctrl_list_lock);\n\tmutex_unlock(&hdev->fpriv_ctrl_list_lock);\n}\n\nstatic void hl_abort_waiting_for_completions(struct hl_device *hdev)\n{\n\thl_abort_waiting_for_cs_completions(hdev);\n\n\t \n\thl_release_pending_user_interrupts(hdev);\n}\n\nstatic void cleanup_resources(struct hl_device *hdev, bool hard_reset, bool fw_reset,\n\t\t\t\tbool skip_wq_flush)\n{\n\tif (hard_reset)\n\t\tdevice_late_fini(hdev);\n\n\t \n\thdev->asic_funcs->halt_engines(hdev, hard_reset, fw_reset);\n\n\t \n\thl_cs_rollback_all(hdev, skip_wq_flush);\n\n\t \n\tflush_workqueue(hdev->prefetch_wq);\n\n\thl_abort_waiting_for_completions(hdev);\n}\n\n \nint hl_device_suspend(struct hl_device *hdev)\n{\n\tint rc;\n\n\tpci_save_state(hdev->pdev);\n\n\t \n\tspin_lock(&hdev->reset_info.lock);\n\tif (hdev->reset_info.in_reset) {\n\t\tspin_unlock(&hdev->reset_info.lock);\n\t\tdev_err(hdev->dev, \"Can't suspend while in reset\\n\");\n\t\treturn -EIO;\n\t}\n\thdev->reset_info.in_reset = 1;\n\tspin_unlock(&hdev->reset_info.lock);\n\n\t \n\thdev->disabled = true;\n\n\ttake_release_locks(hdev);\n\n\trc = hdev->asic_funcs->suspend(hdev);\n\tif (rc)\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to disable PCI access of device CPU\\n\");\n\n\t \n\tpci_disable_device(hdev->pdev);\n\tpci_set_power_state(hdev->pdev, PCI_D3hot);\n\n\treturn 0;\n}\n\n \nint hl_device_resume(struct hl_device *hdev)\n{\n\tint rc;\n\n\tpci_set_power_state(hdev->pdev, PCI_D0);\n\tpci_restore_state(hdev->pdev);\n\trc = pci_enable_device_mem(hdev->pdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to enable PCI device in resume\\n\");\n\t\treturn rc;\n\t}\n\n\tpci_set_master(hdev->pdev);\n\n\trc = hdev->asic_funcs->resume(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to resume device after suspend\\n\");\n\t\tgoto disable_device;\n\t}\n\n\n\t \n\tspin_lock(&hdev->reset_info.lock);\n\thdev->reset_info.in_reset = 0;\n\tspin_unlock(&hdev->reset_info.lock);\n\n\trc = hl_device_reset(hdev, HL_DRV_RESET_HARD);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to reset device during resume\\n\");\n\t\tgoto disable_device;\n\t}\n\n\treturn 0;\n\ndisable_device:\n\tpci_disable_device(hdev->pdev);\n\n\treturn rc;\n}\n\nstatic int device_kill_open_processes(struct hl_device *hdev, u32 timeout, bool control_dev)\n{\n\tstruct task_struct *task = NULL;\n\tstruct list_head *fd_list;\n\tstruct hl_fpriv\t*hpriv;\n\tstruct mutex *fd_lock;\n\tu32 pending_cnt;\n\n\tfd_lock = control_dev ? &hdev->fpriv_ctrl_list_lock : &hdev->fpriv_list_lock;\n\tfd_list = control_dev ? &hdev->fpriv_ctrl_list : &hdev->fpriv_list;\n\n\t \n\tif (!list_empty(fd_list))\n\t\tssleep(1);\n\n\tif (timeout) {\n\t\tpending_cnt = timeout;\n\t} else {\n\t\tif (hdev->process_kill_trial_cnt) {\n\t\t\t \n\t\t\tpending_cnt = 1;\n\t\t\tgoto wait_for_processes;\n\t\t} else {\n\t\t\t \n\t\t\tpending_cnt = HL_PENDING_RESET_PER_SEC;\n\t\t}\n\t}\n\n\tmutex_lock(fd_lock);\n\n\t \n\tlist_for_each_entry(hpriv, fd_list, dev_node) {\n\t\ttask = get_pid_task(hpriv->taskpid, PIDTYPE_PID);\n\t\tif (task) {\n\t\t\tdev_info(hdev->dev, \"Killing user process pid=%d\\n\",\n\t\t\t\ttask_pid_nr(task));\n\t\t\tsend_sig(SIGKILL, task, 1);\n\t\t\tusleep_range(1000, 10000);\n\n\t\t\tput_task_struct(task);\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(hdev->dev,\n\t\t\t\t\"Can't get task struct for user process, assuming process was killed from outside the driver\\n\");\n\t\t}\n\t}\n\n\tmutex_unlock(fd_lock);\n\n\t \n\nwait_for_processes:\n\twhile ((!list_empty(fd_list)) && (pending_cnt)) {\n\t\tdev_dbg(hdev->dev,\n\t\t\t\"Waiting for all unmap operations to finish before hard reset\\n\");\n\n\t\tpending_cnt--;\n\n\t\tssleep(1);\n\t}\n\n\t \n\tif (list_empty(fd_list))\n\t\treturn 0;\n\n\t \n\tif (hdev->process_kill_trial_cnt == HL_PENDING_RESET_MAX_TRIALS)\n\t\treturn -ETIME;\n\n\thdev->process_kill_trial_cnt++;\n\n\treturn -EBUSY;\n}\n\nstatic void device_disable_open_processes(struct hl_device *hdev, bool control_dev)\n{\n\tstruct list_head *fd_list;\n\tstruct hl_fpriv *hpriv;\n\tstruct mutex *fd_lock;\n\n\tfd_lock = control_dev ? &hdev->fpriv_ctrl_list_lock : &hdev->fpriv_list_lock;\n\tfd_list = control_dev ? &hdev->fpriv_ctrl_list : &hdev->fpriv_list;\n\n\tmutex_lock(fd_lock);\n\tlist_for_each_entry(hpriv, fd_list, dev_node)\n\t\thpriv->hdev = NULL;\n\tmutex_unlock(fd_lock);\n}\n\nstatic void send_disable_pci_access(struct hl_device *hdev, u32 flags)\n{\n\t \n\tif ((flags & HL_DRV_RESET_HARD) &&\n\t\t\t!(flags & (HL_DRV_RESET_HEARTBEAT | HL_DRV_RESET_BYPASS_REQ_TO_FW))) {\n\t\t \n\t\tif (hl_fw_send_pci_access_msg(hdev, CPUCP_PACKET_DISABLE_PCI_ACCESS, 0x0)) {\n\t\t\tdev_warn(hdev->dev, \"Failed to disable FW's PCI access\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (hdev->cpu_queues_enable)\n\t\t\tsynchronize_irq(pci_irq_vector(hdev->pdev,\n\t\t\t\t\thdev->asic_prop.eq_interrupt_id));\n\t}\n}\n\nstatic void handle_reset_trigger(struct hl_device *hdev, u32 flags)\n{\n\tu32 cur_reset_trigger = HL_RESET_TRIGGER_DEFAULT;\n\n\t \n\tif (hdev->is_compute_ctx_active)\n\t\treturn;\n\n\t \n\tif (flags & HL_DRV_RESET_HEARTBEAT) {\n\t\thdev->reset_info.curr_reset_cause = HL_RESET_CAUSE_HEARTBEAT;\n\t\tcur_reset_trigger = HL_DRV_RESET_HEARTBEAT;\n\t} else if (flags & HL_DRV_RESET_TDR) {\n\t\thdev->reset_info.curr_reset_cause = HL_RESET_CAUSE_TDR;\n\t\tcur_reset_trigger = HL_DRV_RESET_TDR;\n\t} else if (flags & HL_DRV_RESET_FW_FATAL_ERR) {\n\t\thdev->reset_info.curr_reset_cause = HL_RESET_CAUSE_UNKNOWN;\n\t\tcur_reset_trigger = HL_DRV_RESET_FW_FATAL_ERR;\n\t} else {\n\t\thdev->reset_info.curr_reset_cause = HL_RESET_CAUSE_UNKNOWN;\n\t}\n\n\t \n\tif (hdev->reset_info.prev_reset_trigger != cur_reset_trigger) {\n\t\thdev->reset_info.prev_reset_trigger = cur_reset_trigger;\n\t\thdev->reset_info.reset_trigger_repeated = 0;\n\t} else {\n\t\thdev->reset_info.reset_trigger_repeated = 1;\n\t}\n}\n\n \nint hl_device_reset(struct hl_device *hdev, u32 flags)\n{\n\tbool hard_reset, from_hard_reset_thread, fw_reset, reset_upon_device_release,\n\t\tschedule_hard_reset = false, delay_reset, from_dev_release, from_watchdog_thread;\n\tu64 idle_mask[HL_BUSY_ENGINES_MASK_EXT_SIZE] = {0};\n\tstruct hl_ctx *ctx;\n\tint i, rc, hw_fini_rc;\n\n\tif (!hdev->init_done) {\n\t\tdev_err(hdev->dev, \"Can't reset before initialization is done\\n\");\n\t\treturn 0;\n\t}\n\n\thard_reset = !!(flags & HL_DRV_RESET_HARD);\n\tfrom_hard_reset_thread = !!(flags & HL_DRV_RESET_FROM_RESET_THR);\n\tfw_reset = !!(flags & HL_DRV_RESET_BYPASS_REQ_TO_FW);\n\tfrom_dev_release = !!(flags & HL_DRV_RESET_DEV_RELEASE);\n\tdelay_reset = !!(flags & HL_DRV_RESET_DELAY);\n\tfrom_watchdog_thread = !!(flags & HL_DRV_RESET_FROM_WD_THR);\n\treset_upon_device_release = hdev->reset_upon_device_release && from_dev_release;\n\n\tif (!hard_reset && (hl_device_status(hdev) == HL_DEVICE_STATUS_MALFUNCTION)) {\n\t\tdev_dbg(hdev->dev, \"soft-reset isn't supported on a malfunctioning device\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!hard_reset && !hdev->asic_prop.supports_compute_reset) {\n\t\tdev_dbg(hdev->dev, \"asic doesn't support compute reset - do hard-reset instead\\n\");\n\t\thard_reset = true;\n\t}\n\n\tif (reset_upon_device_release) {\n\t\tif (hard_reset) {\n\t\t\tdev_crit(hdev->dev,\n\t\t\t\t\"Aborting reset because hard-reset is mutually exclusive with reset-on-device-release\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgoto do_reset;\n\t}\n\n\tif (!hard_reset && !hdev->asic_prop.allow_inference_soft_reset) {\n\t\tdev_dbg(hdev->dev,\n\t\t\t\"asic doesn't allow inference soft reset - do hard-reset instead\\n\");\n\t\thard_reset = true;\n\t}\n\ndo_reset:\n\t \n\tif (from_hard_reset_thread && hdev->process_kill_trial_cnt)\n\t\tgoto kill_processes;\n\n\t \n\tif (!from_hard_reset_thread) {\n\t\t \n\t\tspin_lock(&hdev->reset_info.lock);\n\t\tif (hdev->reset_info.in_reset) {\n\t\t\t \n\t\t\tif (hard_reset && hdev->reset_info.in_compute_reset)\n\t\t\t\thdev->reset_info.hard_reset_schedule_flags = flags;\n\t\t\tspin_unlock(&hdev->reset_info.lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\thdev->reset_info.in_compute_reset = !hard_reset;\n\n\t\thdev->reset_info.in_reset = 1;\n\n\t\tspin_unlock(&hdev->reset_info.lock);\n\n\t\t \n\t\tif ((hard_reset || from_dev_release) && hdev->reset_info.watchdog_active) {\n\t\t\tstruct hl_device_reset_work *watchdog_work =\n\t\t\t\t\t&hdev->device_release_watchdog_work;\n\n\t\t\thdev->reset_info.watchdog_active = 0;\n\t\t\tif (!from_watchdog_thread)\n\t\t\t\tcancel_delayed_work_sync(&watchdog_work->reset_work);\n\n\t\t\tif (from_dev_release && (watchdog_work->flags & HL_DRV_RESET_HARD)) {\n\t\t\t\thdev->reset_info.in_compute_reset = 0;\n\t\t\t\tflags |= HL_DRV_RESET_HARD;\n\t\t\t\tflags &= ~HL_DRV_RESET_DEV_RELEASE;\n\t\t\t\thard_reset = true;\n\t\t\t}\n\t\t}\n\n\t\tif (delay_reset)\n\t\t\tusleep_range(HL_RESET_DELAY_USEC, HL_RESET_DELAY_USEC << 1);\n\nescalate_reset_flow:\n\t\thandle_reset_trigger(hdev, flags);\n\t\tsend_disable_pci_access(hdev, flags);\n\n\t\t \n\t\thdev->disabled = true;\n\n\t\ttake_release_locks(hdev);\n\n\t\tif (hard_reset)\n\t\t\tdev_info(hdev->dev, \"Going to reset device\\n\");\n\t\telse if (reset_upon_device_release)\n\t\t\tdev_dbg(hdev->dev, \"Going to reset device after release by user\\n\");\n\t\telse\n\t\t\tdev_dbg(hdev->dev, \"Going to reset engines of inference device\\n\");\n\t}\n\n\tif ((hard_reset) && (!from_hard_reset_thread)) {\n\t\thdev->reset_info.hard_reset_pending = true;\n\n\t\thdev->process_kill_trial_cnt = 0;\n\n\t\thdev->device_reset_work.flags = flags;\n\n\t\t \n\t\tqueue_delayed_work(hdev->reset_wq, &hdev->device_reset_work.reset_work, 0);\n\n\t\treturn 0;\n\t}\n\n\tcleanup_resources(hdev, hard_reset, fw_reset, from_dev_release);\n\nkill_processes:\n\tif (hard_reset) {\n\t\t \n\t\trc = device_kill_open_processes(hdev, 0, false);\n\n\t\tif (rc == -EBUSY) {\n\t\t\tif (hdev->device_fini_pending) {\n\t\t\t\tdev_crit(hdev->dev,\n\t\t\t\t\t\"%s Failed to kill all open processes, stopping hard reset\\n\",\n\t\t\t\t\tdev_name(&(hdev)->pdev->dev));\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\t \n\t\t\treturn rc;\n\t\t}\n\n\t\tif (rc) {\n\t\t\tdev_crit(hdev->dev,\n\t\t\t\t\"%s Failed to kill all open processes, stopping hard reset\\n\",\n\t\t\t\tdev_name(&(hdev)->pdev->dev));\n\t\t\tgoto out_err;\n\t\t}\n\n\t\t \n\t\tflush_workqueue(hdev->eq_wq);\n\t}\n\n\t \n\thw_fini_rc = hdev->asic_funcs->hw_fini(hdev, hard_reset, fw_reset);\n\n\tif (hard_reset) {\n\t\thdev->fw_loader.fw_comp_loaded = FW_TYPE_NONE;\n\n\t\t \n\t\tif (hdev->kernel_ctx && hl_ctx_put(hdev->kernel_ctx) == 1)\n\t\t\thdev->kernel_ctx = NULL;\n\n\t\thl_vm_fini(hdev);\n\t\thl_mmu_fini(hdev);\n\t\thl_eq_reset(hdev, &hdev->event_queue);\n\t}\n\n\t \n\thl_hw_queue_reset(hdev, hard_reset);\n\tfor (i = 0 ; i < hdev->asic_prop.completion_queues_count ; i++)\n\t\thl_cq_reset(hdev, &hdev->completion_queue[i]);\n\n\t \n\tctx = hl_get_compute_ctx(hdev);\n\tif (ctx) {\n\t\tatomic_set(&ctx->thread_ctx_switch_token, 1);\n\t\tctx->thread_ctx_switch_wait_token = 0;\n\t\thl_ctx_put(ctx);\n\t}\n\n\tif (hw_fini_rc) {\n\t\trc = hw_fini_rc;\n\t\tgoto out_err;\n\t}\n\t \n\n\tif (hard_reset) {\n\t\thdev->device_cpu_disabled = false;\n\t\thdev->reset_info.hard_reset_pending = false;\n\n\t\tif (hdev->reset_info.reset_trigger_repeated &&\n\t\t\t\t(hdev->reset_info.prev_reset_trigger ==\n\t\t\t\t\t\tHL_DRV_RESET_FW_FATAL_ERR)) {\n\t\t\t \n\t\t\tdev_crit(hdev->dev,\n\t\t\t\t\"%s Consecutive FW fatal errors received, stopping hard reset\\n\",\n\t\t\t\tdev_name(&(hdev)->pdev->dev));\n\t\t\trc = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (hdev->kernel_ctx) {\n\t\t\tdev_crit(hdev->dev,\n\t\t\t\t\"%s kernel ctx was alive during hard reset, something is terribly wrong\\n\",\n\t\t\t\tdev_name(&(hdev)->pdev->dev));\n\t\t\trc = -EBUSY;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\trc = hl_mmu_init(hdev);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Failed to initialize MMU S/W after hard reset\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\t \n\t\thdev->kernel_ctx = kzalloc(sizeof(*hdev->kernel_ctx),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!hdev->kernel_ctx) {\n\t\t\trc = -ENOMEM;\n\t\t\thl_mmu_fini(hdev);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\thdev->is_compute_ctx_active = false;\n\n\t\trc = hl_ctx_init(hdev, hdev->kernel_ctx, true);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"failed to init kernel ctx in hard reset\\n\");\n\t\t\tkfree(hdev->kernel_ctx);\n\t\t\thdev->kernel_ctx = NULL;\n\t\t\thl_mmu_fini(hdev);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\t \n\thdev->disabled = false;\n\n\t \n\tif (hard_reset) {\n\t\trc = hl_fw_read_preboot_status(hdev);\n\t\tif (rc)\n\t\t\tgoto out_err;\n\t}\n\n\trc = hdev->asic_funcs->hw_init(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to initialize the H/W after reset\\n\");\n\t\tgoto out_err;\n\t}\n\n\t \n\tif (!hdev->asic_funcs->is_device_idle(hdev, idle_mask,\n\t\t\t\t\t\tHL_BUSY_ENGINES_MASK_EXT_SIZE, NULL)) {\n\t\tprint_idle_status_mask(hdev, \"device is not idle after reset\", idle_mask);\n\t\trc = -EIO;\n\t\tgoto out_err;\n\t}\n\n\t \n\trc = hdev->asic_funcs->test_queues(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to detect if device is alive after reset\\n\");\n\t\tgoto out_err;\n\t}\n\n\tif (hard_reset) {\n\t\trc = device_late_init(hdev);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev, \"Failed late init after hard reset\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\trc = hl_vm_init(hdev);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev, \"Failed to init memory module after hard reset\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (!hdev->asic_prop.fw_security_enabled)\n\t\t\thl_fw_set_max_power(hdev);\n\t} else {\n\t\trc = hdev->asic_funcs->compute_reset_late_init(hdev);\n\t\tif (rc) {\n\t\t\tif (reset_upon_device_release)\n\t\t\t\tdev_err(hdev->dev,\n\t\t\t\t\t\"Failed late init in reset after device release\\n\");\n\t\t\telse\n\t\t\t\tdev_err(hdev->dev, \"Failed late init after compute reset\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\trc = hdev->asic_funcs->scrub_device_mem(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"scrub mem failed from device reset (%d)\\n\", rc);\n\t\tgoto out_err;\n\t}\n\n\tspin_lock(&hdev->reset_info.lock);\n\thdev->reset_info.in_compute_reset = 0;\n\n\t \n\tif (!hard_reset && hdev->reset_info.hard_reset_schedule_flags)\n\t\tschedule_hard_reset = true;\n\telse\n\t\thdev->reset_info.in_reset = 0;\n\n\tspin_unlock(&hdev->reset_info.lock);\n\n\thdev->reset_info.needs_reset = false;\n\n\tif (hard_reset)\n\t\tdev_info(hdev->dev,\n\t\t\t \"Successfully finished resetting the %s device\\n\",\n\t\t\t dev_name(&(hdev)->pdev->dev));\n\telse\n\t\tdev_dbg(hdev->dev,\n\t\t\t\"Successfully finished resetting the %s device\\n\",\n\t\t\tdev_name(&(hdev)->pdev->dev));\n\n\tif (hard_reset) {\n\t\thdev->reset_info.hard_reset_cnt++;\n\n\t\t \n\t\thdev->asic_funcs->enable_events_from_fw(hdev);\n\t} else {\n\t\tif (!reset_upon_device_release)\n\t\t\thdev->reset_info.compute_reset_cnt++;\n\n\t\tif (schedule_hard_reset) {\n\t\t\tdev_info(hdev->dev, \"Performing hard reset scheduled during compute reset\\n\");\n\t\t\tflags = hdev->reset_info.hard_reset_schedule_flags;\n\t\t\thdev->reset_info.hard_reset_schedule_flags = 0;\n\t\t\thard_reset = true;\n\t\t\tgoto escalate_reset_flow;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_err:\n\thdev->disabled = true;\n\n\tspin_lock(&hdev->reset_info.lock);\n\thdev->reset_info.in_compute_reset = 0;\n\n\tif (hard_reset) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"%s Failed to reset! Device is NOT usable\\n\",\n\t\t\tdev_name(&(hdev)->pdev->dev));\n\t\thdev->reset_info.hard_reset_cnt++;\n\t} else {\n\t\tif (reset_upon_device_release) {\n\t\t\tdev_err(hdev->dev, \"Failed to reset device after user release\\n\");\n\t\t\tflags &= ~HL_DRV_RESET_DEV_RELEASE;\n\t\t} else {\n\t\t\tdev_err(hdev->dev, \"Failed to do compute reset\\n\");\n\t\t\thdev->reset_info.compute_reset_cnt++;\n\t\t}\n\n\t\tspin_unlock(&hdev->reset_info.lock);\n\t\tflags |= HL_DRV_RESET_HARD;\n\t\thard_reset = true;\n\t\tgoto escalate_reset_flow;\n\t}\n\n\thdev->reset_info.in_reset = 0;\n\n\tspin_unlock(&hdev->reset_info.lock);\n\n\treturn rc;\n}\n\n \nint hl_device_cond_reset(struct hl_device *hdev, u32 flags, u64 event_mask)\n{\n\tstruct hl_ctx *ctx = NULL;\n\n\t \n\tif (flags & HL_DRV_RESET_BYPASS_REQ_TO_FW)\n\t\tgoto device_reset;\n\n\t \n\tif (!(event_mask & HL_NOTIFIER_EVENT_DEVICE_RESET)) {\n\t\tdev_err(hdev->dev, \"Resetting device without a reset indication to user\\n\");\n\t\tgoto device_reset;\n\t}\n\n\tctx = hl_get_compute_ctx(hdev);\n\tif (!ctx || !ctx->hpriv->notifier_event.eventfd)\n\t\tgoto device_reset;\n\n\t \n\tspin_lock(&hdev->reset_info.lock);\n\tif (hdev->reset_info.in_reset) {\n\t\tspin_unlock(&hdev->reset_info.lock);\n\t\tgoto device_reset;\n\t}\n\n\tif (hdev->reset_info.watchdog_active)\n\t\tgoto out;\n\n\thdev->device_release_watchdog_work.flags = flags;\n\tdev_dbg(hdev->dev, \"Device is going to be hard-reset in %u sec unless being released\\n\",\n\t\thdev->device_release_watchdog_timeout_sec);\n\tschedule_delayed_work(&hdev->device_release_watchdog_work.reset_work,\n\t\t\t\tmsecs_to_jiffies(hdev->device_release_watchdog_timeout_sec * 1000));\n\thdev->reset_info.watchdog_active = 1;\nout:\n\tspin_unlock(&hdev->reset_info.lock);\n\n\thl_notifier_event_send_all(hdev, event_mask);\n\n\thl_ctx_put(ctx);\n\n\thl_abort_waiting_for_completions(hdev);\n\n\treturn 0;\n\ndevice_reset:\n\tif (event_mask)\n\t\thl_notifier_event_send_all(hdev, event_mask);\n\tif (ctx)\n\t\thl_ctx_put(ctx);\n\n\treturn hl_device_reset(hdev, flags);\n}\n\nstatic void hl_notifier_event_send(struct hl_notifier_event *notifier_event, u64 event_mask)\n{\n\tmutex_lock(&notifier_event->lock);\n\tnotifier_event->events_mask |= event_mask;\n\n\tif (notifier_event->eventfd)\n\t\teventfd_signal(notifier_event->eventfd, 1);\n\n\tmutex_unlock(&notifier_event->lock);\n}\n\n \nvoid hl_notifier_event_send_all(struct hl_device *hdev, u64 event_mask)\n{\n\tstruct hl_fpriv\t*hpriv;\n\n\tif (!event_mask) {\n\t\tdev_warn(hdev->dev, \"Skip sending zero event\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&hdev->fpriv_list_lock);\n\n\tlist_for_each_entry(hpriv, &hdev->fpriv_list, dev_node)\n\t\thl_notifier_event_send(&hpriv->notifier_event, event_mask);\n\n\tmutex_unlock(&hdev->fpriv_list_lock);\n\n\t \n\tmutex_lock(&hdev->fpriv_ctrl_list_lock);\n\n\tlist_for_each_entry(hpriv, &hdev->fpriv_ctrl_list, dev_node)\n\t\thl_notifier_event_send(&hpriv->notifier_event, event_mask);\n\n\tmutex_unlock(&hdev->fpriv_ctrl_list_lock);\n}\n\nstatic int create_cdev(struct hl_device *hdev)\n{\n\tchar *name;\n\tint rc;\n\n\thdev->cdev_idx = hdev->id / 2;\n\n\tname = kasprintf(GFP_KERNEL, \"hl%d\", hdev->cdev_idx);\n\tif (!name) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\t \n\trc = device_init_cdev(hdev, hdev->hclass, hdev->id, &hl_ops, name,\n\t\t\t\t&hdev->cdev, &hdev->dev);\n\n\tkfree(name);\n\n\tif (rc)\n\t\tgoto out_err;\n\n\tname = kasprintf(GFP_KERNEL, \"hl_controlD%d\", hdev->cdev_idx);\n\tif (!name) {\n\t\trc = -ENOMEM;\n\t\tgoto free_dev;\n\t}\n\n\t \n\trc = device_init_cdev(hdev, hdev->hclass, hdev->id_control, &hl_ctrl_ops,\n\t\t\t\tname, &hdev->cdev_ctrl, &hdev->dev_ctrl);\n\n\tkfree(name);\n\n\tif (rc)\n\t\tgoto free_dev;\n\n\treturn 0;\n\nfree_dev:\n\tput_device(hdev->dev);\nout_err:\n\treturn rc;\n}\n\n \nint hl_device_init(struct hl_device *hdev)\n{\n\tint i, rc, cq_cnt, user_interrupt_cnt, cq_ready_cnt;\n\tbool expose_interfaces_on_err = false;\n\n\trc = create_cdev(hdev);\n\tif (rc)\n\t\tgoto out_disabled;\n\n\t \n\trc = device_early_init(hdev);\n\tif (rc)\n\t\tgoto free_dev;\n\n\tuser_interrupt_cnt = hdev->asic_prop.user_dec_intr_count +\n\t\t\t\thdev->asic_prop.user_interrupt_count;\n\n\tif (user_interrupt_cnt) {\n\t\thdev->user_interrupt = kcalloc(user_interrupt_cnt, sizeof(*hdev->user_interrupt),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!hdev->user_interrupt) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto early_fini;\n\t\t}\n\t}\n\n\t \n\trc = hdev->asic_funcs->sw_init(hdev);\n\tif (rc)\n\t\tgoto free_usr_intr_mem;\n\n\n\t \n\thl_multi_cs_completion_init(hdev);\n\n\t \n\trc = hl_hw_queues_create(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to initialize kernel queues\\n\");\n\t\tgoto sw_fini;\n\t}\n\n\tcq_cnt = hdev->asic_prop.completion_queues_count;\n\n\t \n\tif (cq_cnt) {\n\t\thdev->completion_queue = kcalloc(cq_cnt,\n\t\t\t\tsizeof(*hdev->completion_queue),\n\t\t\t\tGFP_KERNEL);\n\n\t\tif (!hdev->completion_queue) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"failed to allocate completion queues\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto hw_queues_destroy;\n\t\t}\n\t}\n\n\tfor (i = 0, cq_ready_cnt = 0 ; i < cq_cnt ; i++, cq_ready_cnt++) {\n\t\trc = hl_cq_init(hdev, &hdev->completion_queue[i],\n\t\t\t\thdev->asic_funcs->get_queue_id_for_cq(hdev, i));\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"failed to initialize completion queue\\n\");\n\t\t\tgoto cq_fini;\n\t\t}\n\t\thdev->completion_queue[i].cq_idx = i;\n\t}\n\n\thdev->shadow_cs_queue = kcalloc(hdev->asic_prop.max_pending_cs,\n\t\t\t\t\tsizeof(struct hl_cs *), GFP_KERNEL);\n\tif (!hdev->shadow_cs_queue) {\n\t\trc = -ENOMEM;\n\t\tgoto cq_fini;\n\t}\n\n\t \n\trc = hl_eq_init(hdev, &hdev->event_queue);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to initialize event queue\\n\");\n\t\tgoto free_shadow_cs_queue;\n\t}\n\n\t \n\trc = hl_mmu_init(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to initialize MMU S/W structures\\n\");\n\t\tgoto eq_fini;\n\t}\n\n\t \n\thdev->kernel_ctx = kzalloc(sizeof(*hdev->kernel_ctx), GFP_KERNEL);\n\tif (!hdev->kernel_ctx) {\n\t\trc = -ENOMEM;\n\t\tgoto mmu_fini;\n\t}\n\n\thdev->is_compute_ctx_active = false;\n\n\thdev->asic_funcs->state_dump_init(hdev);\n\n\thdev->device_release_watchdog_timeout_sec = HL_DEVICE_RELEASE_WATCHDOG_TIMEOUT_SEC;\n\n\thdev->memory_scrub_val = MEM_SCRUB_DEFAULT_VAL;\n\n\trc = hl_debugfs_device_init(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to initialize debugfs entry structure\\n\");\n\t\tkfree(hdev->kernel_ctx);\n\t\tgoto mmu_fini;\n\t}\n\n\t \n\trc = hl_ctx_init(hdev, hdev->kernel_ctx, true);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to initialize kernel context\\n\");\n\t\tkfree(hdev->kernel_ctx);\n\t\tgoto debugfs_device_fini;\n\t}\n\n\trc = hl_cb_pool_init(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to initialize CB pool\\n\");\n\t\tgoto release_ctx;\n\t}\n\n\trc = hl_dec_init(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to initialize the decoder module\\n\");\n\t\tgoto cb_pool_fini;\n\t}\n\n\t \n\texpose_interfaces_on_err = true;\n\n\t \n\thdev->disabled = false;\n\n\trc = hdev->asic_funcs->hw_init(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to initialize the H/W\\n\");\n\t\trc = 0;\n\t\tgoto out_disabled;\n\t}\n\n\t \n\trc = hdev->asic_funcs->test_queues(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to detect if device is alive\\n\");\n\t\trc = 0;\n\t\tgoto out_disabled;\n\t}\n\n\trc = device_late_init(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed late initialization\\n\");\n\t\trc = 0;\n\t\tgoto out_disabled;\n\t}\n\n\tdev_info(hdev->dev, \"Found %s device with %lluGB DRAM\\n\",\n\t\thdev->asic_name,\n\t\thdev->asic_prop.dram_size / SZ_1G);\n\n\trc = hl_vm_init(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to initialize memory module\\n\");\n\t\trc = 0;\n\t\tgoto out_disabled;\n\t}\n\n\t \n\texpose_interfaces_on_err = false;\n\trc = cdev_sysfs_debugfs_add(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to add char devices and sysfs/debugfs files\\n\");\n\t\trc = 0;\n\t\tgoto out_disabled;\n\t}\n\n\t \n\tif (hdev->asic_prop.set_max_power_on_device_init &&\n\t\t\t!hdev->asic_prop.fw_security_enabled)\n\t\thl_fw_set_max_power(hdev);\n\n\t \n\trc = hl_hwmon_init(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to initialize hwmon\\n\");\n\t\trc = 0;\n\t\tgoto out_disabled;\n\t}\n\n\tdev_notice(hdev->dev,\n\t\t\"Successfully added device %s to habanalabs driver\\n\",\n\t\tdev_name(&(hdev)->pdev->dev));\n\n\thdev->init_done = true;\n\n\t \n\thdev->asic_funcs->enable_events_from_fw(hdev);\n\n\treturn 0;\n\ncb_pool_fini:\n\thl_cb_pool_fini(hdev);\nrelease_ctx:\n\tif (hl_ctx_put(hdev->kernel_ctx) != 1)\n\t\tdev_err(hdev->dev,\n\t\t\t\"kernel ctx is still alive on initialization failure\\n\");\ndebugfs_device_fini:\n\thl_debugfs_device_fini(hdev);\nmmu_fini:\n\thl_mmu_fini(hdev);\neq_fini:\n\thl_eq_fini(hdev, &hdev->event_queue);\nfree_shadow_cs_queue:\n\tkfree(hdev->shadow_cs_queue);\ncq_fini:\n\tfor (i = 0 ; i < cq_ready_cnt ; i++)\n\t\thl_cq_fini(hdev, &hdev->completion_queue[i]);\n\tkfree(hdev->completion_queue);\nhw_queues_destroy:\n\thl_hw_queues_destroy(hdev);\nsw_fini:\n\thdev->asic_funcs->sw_fini(hdev);\nfree_usr_intr_mem:\n\tkfree(hdev->user_interrupt);\nearly_fini:\n\tdevice_early_fini(hdev);\nfree_dev:\n\tput_device(hdev->dev_ctrl);\n\tput_device(hdev->dev);\nout_disabled:\n\thdev->disabled = true;\n\tif (expose_interfaces_on_err)\n\t\tcdev_sysfs_debugfs_add(hdev);\n\tdev_err(&hdev->pdev->dev,\n\t\t\"Failed to initialize hl%d. Device %s is NOT usable !\\n\",\n\t\thdev->cdev_idx, dev_name(&hdev->pdev->dev));\n\n\treturn rc;\n}\n\n \nvoid hl_device_fini(struct hl_device *hdev)\n{\n\tbool device_in_reset;\n\tktime_t timeout;\n\tu64 reset_sec;\n\tint i, rc;\n\n\tdev_info(hdev->dev, \"Removing device\\n\");\n\n\thdev->device_fini_pending = 1;\n\tflush_delayed_work(&hdev->device_reset_work.reset_work);\n\n\tif (hdev->pldm)\n\t\treset_sec = HL_PLDM_HARD_RESET_MAX_TIMEOUT;\n\telse\n\t\treset_sec = HL_HARD_RESET_MAX_TIMEOUT;\n\n\t \n\n\ttimeout = ktime_add_us(ktime_get(), reset_sec * 1000 * 1000);\n\n\tspin_lock(&hdev->reset_info.lock);\n\tdevice_in_reset = !!hdev->reset_info.in_reset;\n\tif (!device_in_reset)\n\t\thdev->reset_info.in_reset = 1;\n\tspin_unlock(&hdev->reset_info.lock);\n\n\twhile (device_in_reset) {\n\t\tusleep_range(50, 200);\n\n\t\tspin_lock(&hdev->reset_info.lock);\n\t\tdevice_in_reset = !!hdev->reset_info.in_reset;\n\t\tif (!device_in_reset)\n\t\t\thdev->reset_info.in_reset = 1;\n\t\tspin_unlock(&hdev->reset_info.lock);\n\n\t\tif (ktime_compare(ktime_get(), timeout) > 0) {\n\t\t\tdev_crit(hdev->dev,\n\t\t\t\t\"%s Failed to remove device because reset function did not finish\\n\",\n\t\t\t\tdev_name(&(hdev)->pdev->dev));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcancel_delayed_work_sync(&hdev->device_release_watchdog_work.reset_work);\n\n\t \n\thl_fw_send_pci_access_msg(hdev,\tCPUCP_PACKET_DISABLE_PCI_ACCESS, 0x0);\n\n\t \n\thdev->disabled = true;\n\n\ttake_release_locks(hdev);\n\n\thdev->reset_info.hard_reset_pending = true;\n\n\thl_hwmon_fini(hdev);\n\n\tcleanup_resources(hdev, true, false, false);\n\n\t \n\tdev_info(hdev->dev,\n\t\t\"Waiting for all processes to exit (timeout of %u seconds)\",\n\t\tHL_WAIT_PROCESS_KILL_ON_DEVICE_FINI);\n\n\thdev->process_kill_trial_cnt = 0;\n\trc = device_kill_open_processes(hdev, HL_WAIT_PROCESS_KILL_ON_DEVICE_FINI, false);\n\tif (rc) {\n\t\tdev_crit(hdev->dev, \"Failed to kill all open processes\\n\");\n\t\tdevice_disable_open_processes(hdev, false);\n\t}\n\n\thdev->process_kill_trial_cnt = 0;\n\trc = device_kill_open_processes(hdev, 0, true);\n\tif (rc) {\n\t\tdev_crit(hdev->dev, \"Failed to kill all control device open processes\\n\");\n\t\tdevice_disable_open_processes(hdev, true);\n\t}\n\n\thl_cb_pool_fini(hdev);\n\n\t \n\trc = hdev->asic_funcs->hw_fini(hdev, true, false);\n\tif (rc)\n\t\tdev_err(hdev->dev, \"hw_fini failed in device fini while removing device %d\\n\", rc);\n\n\thdev->fw_loader.fw_comp_loaded = FW_TYPE_NONE;\n\n\t \n\tif ((hdev->kernel_ctx) && (hl_ctx_put(hdev->kernel_ctx) != 1))\n\t\tdev_err(hdev->dev, \"kernel ctx is still alive\\n\");\n\n\thl_dec_fini(hdev);\n\n\thl_vm_fini(hdev);\n\n\thl_mmu_fini(hdev);\n\n\tvfree(hdev->captured_err_info.page_fault_info.user_mappings);\n\n\thl_eq_fini(hdev, &hdev->event_queue);\n\n\tkfree(hdev->shadow_cs_queue);\n\n\tfor (i = 0 ; i < hdev->asic_prop.completion_queues_count ; i++)\n\t\thl_cq_fini(hdev, &hdev->completion_queue[i]);\n\tkfree(hdev->completion_queue);\n\tkfree(hdev->user_interrupt);\n\n\thl_hw_queues_destroy(hdev);\n\n\t \n\thdev->asic_funcs->sw_fini(hdev);\n\n\tdevice_early_fini(hdev);\n\n\t \n\tcdev_sysfs_debugfs_remove(hdev);\n\n\thl_debugfs_device_fini(hdev);\n\n\tpr_info(\"removed device successfully\\n\");\n}\n\n \n\n \ninline u32 hl_rreg(struct hl_device *hdev, u32 reg)\n{\n\tu32 val = readl(hdev->rmmio + reg);\n\n\tif (unlikely(trace_habanalabs_rreg32_enabled()))\n\t\ttrace_habanalabs_rreg32(hdev->dev, reg, val);\n\n\treturn val;\n}\n\n \ninline void hl_wreg(struct hl_device *hdev, u32 reg, u32 val)\n{\n\tif (unlikely(trace_habanalabs_wreg32_enabled()))\n\t\ttrace_habanalabs_wreg32(hdev->dev, reg, val);\n\n\twritel(val, hdev->rmmio + reg);\n}\n\nvoid hl_capture_razwi(struct hl_device *hdev, u64 addr, u16 *engine_id, u16 num_of_engines,\n\t\t\tu8 flags)\n{\n\tstruct razwi_info *razwi_info = &hdev->captured_err_info.razwi_info;\n\n\tif (num_of_engines > HL_RAZWI_MAX_NUM_OF_ENGINES_PER_RTR) {\n\t\tdev_err(hdev->dev,\n\t\t\t\t\"Number of possible razwi initiators (%u) exceeded limit (%u)\\n\",\n\t\t\t\tnum_of_engines, HL_RAZWI_MAX_NUM_OF_ENGINES_PER_RTR);\n\t\treturn;\n\t}\n\n\t \n\tif (atomic_cmpxchg(&hdev->captured_err_info.razwi_info.razwi_detected, 0, 1))\n\t\treturn;\n\n\trazwi_info->razwi.timestamp = ktime_to_ns(ktime_get());\n\trazwi_info->razwi.addr = addr;\n\trazwi_info->razwi.num_of_possible_engines = num_of_engines;\n\tmemcpy(&razwi_info->razwi.engine_id[0], &engine_id[0],\n\t\t\tnum_of_engines * sizeof(u16));\n\trazwi_info->razwi.flags = flags;\n\n\trazwi_info->razwi_info_available = true;\n}\n\nvoid hl_handle_razwi(struct hl_device *hdev, u64 addr, u16 *engine_id, u16 num_of_engines,\n\t\t\tu8 flags, u64 *event_mask)\n{\n\thl_capture_razwi(hdev, addr, engine_id, num_of_engines, flags);\n\n\tif (event_mask)\n\t\t*event_mask |= HL_NOTIFIER_EVENT_RAZWI;\n}\n\nstatic void hl_capture_user_mappings(struct hl_device *hdev, bool is_pmmu)\n{\n\tstruct page_fault_info *pgf_info = &hdev->captured_err_info.page_fault_info;\n\tstruct hl_vm_phys_pg_pack *phys_pg_pack = NULL;\n\tstruct hl_vm_hash_node *hnode;\n\tstruct hl_userptr *userptr;\n\tenum vm_type *vm_type;\n\tstruct hl_ctx *ctx;\n\tu32 map_idx = 0;\n\tint i;\n\n\t \n\tpgf_info->num_of_user_mappings = 0;\n\n\tctx = hl_get_compute_ctx(hdev);\n\tif (!ctx) {\n\t\tdev_err(hdev->dev, \"Can't get user context for user mappings\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&ctx->mem_hash_lock);\n\thash_for_each(ctx->mem_hash, i, hnode, node) {\n\t\tvm_type = hnode->ptr;\n\t\tif (((*vm_type == VM_TYPE_USERPTR) && is_pmmu) ||\n\t\t\t\t((*vm_type == VM_TYPE_PHYS_PACK) && !is_pmmu))\n\t\t\tpgf_info->num_of_user_mappings++;\n\n\t}\n\n\tif (!pgf_info->num_of_user_mappings)\n\t\tgoto finish;\n\n\t \n\tvfree(pgf_info->user_mappings);\n\tpgf_info->user_mappings =\n\t\t\tvzalloc(pgf_info->num_of_user_mappings * sizeof(struct hl_user_mapping));\n\tif (!pgf_info->user_mappings) {\n\t\tpgf_info->num_of_user_mappings = 0;\n\t\tgoto finish;\n\t}\n\n\thash_for_each(ctx->mem_hash, i, hnode, node) {\n\t\tvm_type = hnode->ptr;\n\t\tif ((*vm_type == VM_TYPE_USERPTR) && (is_pmmu)) {\n\t\t\tuserptr = hnode->ptr;\n\t\t\tpgf_info->user_mappings[map_idx].dev_va = hnode->vaddr;\n\t\t\tpgf_info->user_mappings[map_idx].size = userptr->size;\n\t\t\tmap_idx++;\n\t\t} else if ((*vm_type == VM_TYPE_PHYS_PACK) && (!is_pmmu)) {\n\t\t\tphys_pg_pack = hnode->ptr;\n\t\t\tpgf_info->user_mappings[map_idx].dev_va = hnode->vaddr;\n\t\t\tpgf_info->user_mappings[map_idx].size = phys_pg_pack->total_size;\n\t\t\tmap_idx++;\n\t\t}\n\t}\nfinish:\n\tmutex_unlock(&ctx->mem_hash_lock);\n\thl_ctx_put(ctx);\n}\n\nvoid hl_capture_page_fault(struct hl_device *hdev, u64 addr, u16 eng_id, bool is_pmmu)\n{\n\tstruct page_fault_info *pgf_info = &hdev->captured_err_info.page_fault_info;\n\n\t \n\tif (atomic_cmpxchg(&pgf_info->page_fault_detected, 0, 1))\n\t\treturn;\n\n\tpgf_info->page_fault.timestamp = ktime_to_ns(ktime_get());\n\tpgf_info->page_fault.addr = addr;\n\tpgf_info->page_fault.engine_id = eng_id;\n\thl_capture_user_mappings(hdev, is_pmmu);\n\n\tpgf_info->page_fault_info_available = true;\n}\n\nvoid hl_handle_page_fault(struct hl_device *hdev, u64 addr, u16 eng_id, bool is_pmmu,\n\t\t\t\tu64 *event_mask)\n{\n\thl_capture_page_fault(hdev, addr, eng_id, is_pmmu);\n\n\tif (event_mask)\n\t\t*event_mask |=  HL_NOTIFIER_EVENT_PAGE_FAULT;\n}\n\nstatic void hl_capture_hw_err(struct hl_device *hdev, u16 event_id)\n{\n\tstruct hw_err_info *info = &hdev->captured_err_info.hw_err;\n\n\t \n\tif (atomic_cmpxchg(&info->event_detected, 0, 1))\n\t\treturn;\n\n\tinfo->event.timestamp = ktime_to_ns(ktime_get());\n\tinfo->event.event_id = event_id;\n\n\tinfo->event_info_available = true;\n}\n\nvoid hl_handle_critical_hw_err(struct hl_device *hdev, u16 event_id, u64 *event_mask)\n{\n\thl_capture_hw_err(hdev, event_id);\n\n\tif (event_mask)\n\t\t*event_mask |= HL_NOTIFIER_EVENT_CRITICL_HW_ERR;\n}\n\nstatic void hl_capture_fw_err(struct hl_device *hdev, struct hl_info_fw_err_info *fw_info)\n{\n\tstruct fw_err_info *info = &hdev->captured_err_info.fw_err;\n\n\t \n\tif (atomic_cmpxchg(&info->event_detected, 0, 1))\n\t\treturn;\n\n\tinfo->event.timestamp = ktime_to_ns(ktime_get());\n\tinfo->event.err_type = fw_info->err_type;\n\tif (fw_info->err_type == HL_INFO_FW_REPORTED_ERR)\n\t\tinfo->event.event_id = fw_info->event_id;\n\n\tinfo->event_info_available = true;\n}\n\nvoid hl_handle_fw_err(struct hl_device *hdev, struct hl_info_fw_err_info *info)\n{\n\thl_capture_fw_err(hdev, info);\n\n\tif (info->event_mask)\n\t\t*info->event_mask |= HL_NOTIFIER_EVENT_CRITICL_FW_ERR;\n}\n\nvoid hl_enable_err_info_capture(struct hl_error_info *captured_err_info)\n{\n\tvfree(captured_err_info->page_fault_info.user_mappings);\n\tmemset(captured_err_info, 0, sizeof(struct hl_error_info));\n\tatomic_set(&captured_err_info->cs_timeout.write_enable, 1);\n\tcaptured_err_info->undef_opcode.write_enable = true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}