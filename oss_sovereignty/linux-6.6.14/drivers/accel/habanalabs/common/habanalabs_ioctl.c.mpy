{
  "module_name": "habanalabs_ioctl.c",
  "hash_id": "b0844f8feea6d3d32b2278327a1dd81964a1e52ecf201ddef98acadf53270e07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/common/habanalabs_ioctl.c",
  "human_readable_source": "\n\n \n\n#define pr_fmt(fmt)\t\"habanalabs: \" fmt\n\n#include <uapi/drm/habanalabs_accel.h>\n#include \"habanalabs.h\"\n\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n\nstatic u32 hl_debug_struct_size[HL_DEBUG_OP_TIMESTAMP + 1] = {\n\t[HL_DEBUG_OP_ETR] = sizeof(struct hl_debug_params_etr),\n\t[HL_DEBUG_OP_ETF] = sizeof(struct hl_debug_params_etf),\n\t[HL_DEBUG_OP_STM] = sizeof(struct hl_debug_params_stm),\n\t[HL_DEBUG_OP_FUNNEL] = 0,\n\t[HL_DEBUG_OP_BMON] = sizeof(struct hl_debug_params_bmon),\n\t[HL_DEBUG_OP_SPMU] = sizeof(struct hl_debug_params_spmu),\n\t[HL_DEBUG_OP_TIMESTAMP] = 0\n\n};\n\nstatic int device_status_info(struct hl_device *hdev, struct hl_info_args *args)\n{\n\tstruct hl_info_device_status dev_stat = {0};\n\tu32 size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\n\tif ((!size) || (!out))\n\t\treturn -EINVAL;\n\n\tdev_stat.status = hl_device_status(hdev);\n\n\treturn copy_to_user(out, &dev_stat,\n\t\t\tmin((size_t)size, sizeof(dev_stat))) ? -EFAULT : 0;\n}\n\nstatic int hw_ip_info(struct hl_device *hdev, struct hl_info_args *args)\n{\n\tstruct hl_info_hw_ip_info hw_ip = {0};\n\tu32 size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu64 sram_kmd_size, dram_kmd_size, dram_available_size;\n\n\tif ((!size) || (!out))\n\t\treturn -EINVAL;\n\n\tsram_kmd_size = (prop->sram_user_base_address -\n\t\t\t\tprop->sram_base_address);\n\tdram_kmd_size = (prop->dram_user_base_address -\n\t\t\t\tprop->dram_base_address);\n\n\thw_ip.device_id = hdev->asic_funcs->get_pci_id(hdev);\n\thw_ip.sram_base_address = prop->sram_user_base_address;\n\thw_ip.dram_base_address =\n\t\t\tprop->dram_supports_virtual_memory ?\n\t\t\tprop->dmmu.start_addr : prop->dram_user_base_address;\n\thw_ip.tpc_enabled_mask = prop->tpc_enabled_mask & 0xFF;\n\thw_ip.tpc_enabled_mask_ext = prop->tpc_enabled_mask;\n\n\thw_ip.sram_size = prop->sram_size - sram_kmd_size;\n\n\tdram_available_size = prop->dram_size - dram_kmd_size;\n\n\thw_ip.dram_size = DIV_ROUND_DOWN_ULL(dram_available_size, prop->dram_page_size) *\n\t\t\t\tprop->dram_page_size;\n\n\tif (hw_ip.dram_size > PAGE_SIZE)\n\t\thw_ip.dram_enabled = 1;\n\n\thw_ip.dram_page_size = prop->dram_page_size;\n\thw_ip.device_mem_alloc_default_page_size = prop->device_mem_alloc_default_page_size;\n\thw_ip.num_of_events = prop->num_of_events;\n\n\tmemcpy(hw_ip.cpucp_version, prop->cpucp_info.cpucp_version,\n\t\tmin(VERSION_MAX_LEN, HL_INFO_VERSION_MAX_LEN));\n\n\tmemcpy(hw_ip.card_name, prop->cpucp_info.card_name,\n\t\tmin(CARD_NAME_MAX_LEN, HL_INFO_CARD_NAME_MAX_LEN));\n\n\thw_ip.cpld_version = le32_to_cpu(prop->cpucp_info.cpld_version);\n\thw_ip.module_id = le32_to_cpu(prop->cpucp_info.card_location);\n\n\thw_ip.psoc_pci_pll_nr = prop->psoc_pci_pll_nr;\n\thw_ip.psoc_pci_pll_nf = prop->psoc_pci_pll_nf;\n\thw_ip.psoc_pci_pll_od = prop->psoc_pci_pll_od;\n\thw_ip.psoc_pci_pll_div_factor = prop->psoc_pci_pll_div_factor;\n\n\thw_ip.decoder_enabled_mask = prop->decoder_enabled_mask;\n\thw_ip.mme_master_slave_mode = prop->mme_master_slave_mode;\n\thw_ip.first_available_interrupt_id = prop->first_available_user_interrupt;\n\thw_ip.number_of_user_interrupts = prop->user_interrupt_count;\n\thw_ip.tpc_interrupt_id = prop->tpc_interrupt_id;\n\n\thw_ip.edma_enabled_mask = prop->edma_enabled_mask;\n\thw_ip.server_type = prop->server_type;\n\thw_ip.security_enabled = prop->fw_security_enabled;\n\thw_ip.revision_id = hdev->pdev->revision;\n\thw_ip.rotator_enabled_mask = prop->rotator_enabled_mask;\n\thw_ip.engine_core_interrupt_reg_addr = prop->engine_core_interrupt_reg_addr;\n\thw_ip.reserved_dram_size = dram_kmd_size;\n\n\treturn copy_to_user(out, &hw_ip,\n\t\tmin((size_t) size, sizeof(hw_ip))) ? -EFAULT : 0;\n}\n\nstatic int hw_events_info(struct hl_device *hdev, bool aggregate,\n\t\t\tstruct hl_info_args *args)\n{\n\tu32 size, max_size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tvoid *arr;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\tarr = hdev->asic_funcs->get_events_stat(hdev, aggregate, &size);\n\tif (!arr) {\n\t\tdev_err(hdev->dev, \"Events info not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn copy_to_user(out, arr, min(max_size, size)) ? -EFAULT : 0;\n}\n\nstatic int events_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tu32 max_size = args->return_size;\n\tu64 events_mask;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\n\tif ((max_size < sizeof(u64)) || (!out))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&hpriv->notifier_event.lock);\n\tevents_mask = hpriv->notifier_event.events_mask;\n\thpriv->notifier_event.events_mask = 0;\n\tmutex_unlock(&hpriv->notifier_event.lock);\n\n\treturn copy_to_user(out, &events_mask, sizeof(u64)) ? -EFAULT : 0;\n}\n\nstatic int dram_usage_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tstruct hl_device *hdev = hpriv->hdev;\n\tstruct hl_info_dram_usage dram_usage = {0};\n\tu32 max_size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu64 dram_kmd_size;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\tdram_kmd_size = (prop->dram_user_base_address -\n\t\t\t\tprop->dram_base_address);\n\tdram_usage.dram_free_mem = (prop->dram_size - dram_kmd_size) -\n\t\t\t\t\tatomic64_read(&hdev->dram_used_mem);\n\tif (hpriv->ctx)\n\t\tdram_usage.ctx_dram_mem =\n\t\t\tatomic64_read(&hpriv->ctx->dram_phys_mem);\n\n\treturn copy_to_user(out, &dram_usage,\n\t\tmin((size_t) max_size, sizeof(dram_usage))) ? -EFAULT : 0;\n}\n\nstatic int hw_idle(struct hl_device *hdev, struct hl_info_args *args)\n{\n\tstruct hl_info_hw_idle hw_idle = {0};\n\tu32 max_size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\thw_idle.is_idle = hdev->asic_funcs->is_device_idle(hdev,\n\t\t\t\t\thw_idle.busy_engines_mask_ext,\n\t\t\t\t\tHL_BUSY_ENGINES_MASK_EXT_SIZE, NULL);\n\thw_idle.busy_engines_mask =\n\t\t\tlower_32_bits(hw_idle.busy_engines_mask_ext[0]);\n\n\treturn copy_to_user(out, &hw_idle,\n\t\tmin((size_t) max_size, sizeof(hw_idle))) ? -EFAULT : 0;\n}\n\nstatic int debug_coresight(struct hl_device *hdev, struct hl_ctx *ctx, struct hl_debug_args *args)\n{\n\tstruct hl_debug_params *params;\n\tvoid *input = NULL, *output = NULL;\n\tint rc;\n\n\tparams = kzalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\tparams->reg_idx = args->reg_idx;\n\tparams->enable = args->enable;\n\tparams->op = args->op;\n\n\tif (args->input_ptr && args->input_size) {\n\t\tinput = kzalloc(hl_debug_struct_size[args->op], GFP_KERNEL);\n\t\tif (!input) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_from_user(input, u64_to_user_ptr(args->input_ptr),\n\t\t\t\t\targs->input_size)) {\n\t\t\trc = -EFAULT;\n\t\t\tdev_err(hdev->dev, \"failed to copy input debug data\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tparams->input = input;\n\t}\n\n\tif (args->output_ptr && args->output_size) {\n\t\toutput = kzalloc(args->output_size, GFP_KERNEL);\n\t\tif (!output) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparams->output = output;\n\t\tparams->output_size = args->output_size;\n\t}\n\n\trc = hdev->asic_funcs->debug_coresight(hdev, ctx, params);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"debug coresight operation failed %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (output && copy_to_user((void __user *) (uintptr_t) args->output_ptr,\n\t\t\t\t\toutput, args->output_size)) {\n\t\tdev_err(hdev->dev, \"copy to user failed in debug ioctl\\n\");\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\nout:\n\tkfree(params);\n\tkfree(output);\n\tkfree(input);\n\n\treturn rc;\n}\n\nstatic int device_utilization(struct hl_device *hdev, struct hl_info_args *args)\n{\n\tstruct hl_info_device_utilization device_util = {0};\n\tu32 max_size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tint rc;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\trc = hl_device_utilization(hdev, &device_util.utilization);\n\tif (rc)\n\t\treturn -EINVAL;\n\n\treturn copy_to_user(out, &device_util,\n\t\tmin((size_t) max_size, sizeof(device_util))) ? -EFAULT : 0;\n}\n\nstatic int get_clk_rate(struct hl_device *hdev, struct hl_info_args *args)\n{\n\tstruct hl_info_clk_rate clk_rate = {0};\n\tu32 max_size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tint rc;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\trc = hl_fw_get_clk_rate(hdev, &clk_rate.cur_clk_rate_mhz, &clk_rate.max_clk_rate_mhz);\n\tif (rc)\n\t\treturn rc;\n\n\treturn copy_to_user(out, &clk_rate, min_t(size_t, max_size, sizeof(clk_rate)))\n\t\t\t\t\t\t\t\t\t\t? -EFAULT : 0;\n}\n\nstatic int get_reset_count(struct hl_device *hdev, struct hl_info_args *args)\n{\n\tstruct hl_info_reset_count reset_count = {0};\n\tu32 max_size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\treset_count.hard_reset_cnt = hdev->reset_info.hard_reset_cnt;\n\treset_count.soft_reset_cnt = hdev->reset_info.compute_reset_cnt;\n\n\treturn copy_to_user(out, &reset_count,\n\t\tmin((size_t) max_size, sizeof(reset_count))) ? -EFAULT : 0;\n}\n\nstatic int time_sync_info(struct hl_device *hdev, struct hl_info_args *args)\n{\n\tstruct hl_info_time_sync time_sync = {0};\n\tu32 max_size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\ttime_sync.device_time = hdev->asic_funcs->get_device_time(hdev);\n\ttime_sync.host_time = ktime_get_raw_ns();\n\n\treturn copy_to_user(out, &time_sync,\n\t\tmin((size_t) max_size, sizeof(time_sync))) ? -EFAULT : 0;\n}\n\nstatic int pci_counters_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tstruct hl_device *hdev = hpriv->hdev;\n\tstruct hl_info_pci_counters pci_counters = {0};\n\tu32 max_size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tint rc;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\trc = hl_fw_cpucp_pci_counters_get(hdev, &pci_counters);\n\tif (rc)\n\t\treturn rc;\n\n\treturn copy_to_user(out, &pci_counters,\n\t\tmin((size_t) max_size, sizeof(pci_counters))) ? -EFAULT : 0;\n}\n\nstatic int clk_throttle_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tstruct hl_device *hdev = hpriv->hdev;\n\tstruct hl_info_clk_throttle clk_throttle = {0};\n\tktime_t end_time, zero_time = ktime_set(0, 0);\n\tu32 max_size = args->return_size;\n\tint i;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&hdev->clk_throttling.lock);\n\n\tclk_throttle.clk_throttling_reason = hdev->clk_throttling.current_reason;\n\n\tfor (i = 0 ; i < HL_CLK_THROTTLE_TYPE_MAX ; i++) {\n\t\tif (!(hdev->clk_throttling.aggregated_reason & BIT(i)))\n\t\t\tcontinue;\n\n\t\tclk_throttle.clk_throttling_timestamp_us[i] =\n\t\t\tktime_to_us(hdev->clk_throttling.timestamp[i].start);\n\n\t\tif (ktime_compare(hdev->clk_throttling.timestamp[i].end, zero_time))\n\t\t\tend_time = hdev->clk_throttling.timestamp[i].end;\n\t\telse\n\t\t\tend_time = ktime_get();\n\n\t\tclk_throttle.clk_throttling_duration_ns[i] =\n\t\t\tktime_to_ns(ktime_sub(end_time,\n\t\t\t\thdev->clk_throttling.timestamp[i].start));\n\n\t}\n\tmutex_unlock(&hdev->clk_throttling.lock);\n\n\treturn copy_to_user(out, &clk_throttle,\n\t\tmin((size_t) max_size, sizeof(clk_throttle))) ? -EFAULT : 0;\n}\n\nstatic int cs_counters_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tstruct hl_info_cs_counters cs_counters = {0};\n\tstruct hl_device *hdev = hpriv->hdev;\n\tstruct hl_cs_counters_atomic *cntr;\n\tu32 max_size = args->return_size;\n\n\tcntr = &hdev->aggregated_cs_counters;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\tcs_counters.total_out_of_mem_drop_cnt =\n\t\t\tatomic64_read(&cntr->out_of_mem_drop_cnt);\n\tcs_counters.total_parsing_drop_cnt =\n\t\t\tatomic64_read(&cntr->parsing_drop_cnt);\n\tcs_counters.total_queue_full_drop_cnt =\n\t\t\tatomic64_read(&cntr->queue_full_drop_cnt);\n\tcs_counters.total_device_in_reset_drop_cnt =\n\t\t\tatomic64_read(&cntr->device_in_reset_drop_cnt);\n\tcs_counters.total_max_cs_in_flight_drop_cnt =\n\t\t\tatomic64_read(&cntr->max_cs_in_flight_drop_cnt);\n\tcs_counters.total_validation_drop_cnt =\n\t\t\tatomic64_read(&cntr->validation_drop_cnt);\n\n\tif (hpriv->ctx) {\n\t\tcs_counters.ctx_out_of_mem_drop_cnt =\n\t\t\t\tatomic64_read(\n\t\t\t\t&hpriv->ctx->cs_counters.out_of_mem_drop_cnt);\n\t\tcs_counters.ctx_parsing_drop_cnt =\n\t\t\t\tatomic64_read(\n\t\t\t\t&hpriv->ctx->cs_counters.parsing_drop_cnt);\n\t\tcs_counters.ctx_queue_full_drop_cnt =\n\t\t\t\tatomic64_read(\n\t\t\t\t&hpriv->ctx->cs_counters.queue_full_drop_cnt);\n\t\tcs_counters.ctx_device_in_reset_drop_cnt =\n\t\t\t\tatomic64_read(\n\t\t\t&hpriv->ctx->cs_counters.device_in_reset_drop_cnt);\n\t\tcs_counters.ctx_max_cs_in_flight_drop_cnt =\n\t\t\t\tatomic64_read(\n\t\t\t&hpriv->ctx->cs_counters.max_cs_in_flight_drop_cnt);\n\t\tcs_counters.ctx_validation_drop_cnt =\n\t\t\t\tatomic64_read(\n\t\t\t\t&hpriv->ctx->cs_counters.validation_drop_cnt);\n\t}\n\n\treturn copy_to_user(out, &cs_counters,\n\t\tmin((size_t) max_size, sizeof(cs_counters))) ? -EFAULT : 0;\n}\n\nstatic int sync_manager_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tstruct hl_device *hdev = hpriv->hdev;\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct hl_info_sync_manager sm_info = {0};\n\tu32 max_size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\tif (args->dcore_id >= HL_MAX_DCORES)\n\t\treturn -EINVAL;\n\n\tsm_info.first_available_sync_object =\n\t\t\tprop->first_available_user_sob[args->dcore_id];\n\tsm_info.first_available_monitor =\n\t\t\tprop->first_available_user_mon[args->dcore_id];\n\tsm_info.first_available_cq =\n\t\t\tprop->first_available_cq[args->dcore_id];\n\n\treturn copy_to_user(out, &sm_info, min_t(size_t, (size_t) max_size,\n\t\t\tsizeof(sm_info))) ? -EFAULT : 0;\n}\n\nstatic int total_energy_consumption_info(struct hl_fpriv *hpriv,\n\t\t\tstruct hl_info_args *args)\n{\n\tstruct hl_device *hdev = hpriv->hdev;\n\tstruct hl_info_energy total_energy = {0};\n\tu32 max_size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tint rc;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\trc = hl_fw_cpucp_total_energy_get(hdev,\n\t\t\t&total_energy.total_energy_consumption);\n\tif (rc)\n\t\treturn rc;\n\n\treturn copy_to_user(out, &total_energy,\n\t\tmin((size_t) max_size, sizeof(total_energy))) ? -EFAULT : 0;\n}\n\nstatic int pll_frequency_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tstruct hl_device *hdev = hpriv->hdev;\n\tstruct hl_pll_frequency_info freq_info = { {0} };\n\tu32 max_size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tint rc;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\trc = hl_fw_cpucp_pll_info_get(hdev, args->pll_index, freq_info.output);\n\tif (rc)\n\t\treturn rc;\n\n\treturn copy_to_user(out, &freq_info,\n\t\tmin((size_t) max_size, sizeof(freq_info))) ? -EFAULT : 0;\n}\n\nstatic int power_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tstruct hl_device *hdev = hpriv->hdev;\n\tu32 max_size = args->return_size;\n\tstruct hl_power_info power_info = {0};\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tint rc;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\trc = hl_fw_cpucp_power_get(hdev, &power_info.power);\n\tif (rc)\n\t\treturn rc;\n\n\treturn copy_to_user(out, &power_info,\n\t\tmin((size_t) max_size, sizeof(power_info))) ? -EFAULT : 0;\n}\n\nstatic int open_stats_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tstruct hl_device *hdev = hpriv->hdev;\n\tu32 max_size = args->return_size;\n\tstruct hl_open_stats_info open_stats_info = {0};\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\topen_stats_info.last_open_period_ms = jiffies64_to_msecs(\n\t\thdev->last_open_session_duration_jif);\n\topen_stats_info.open_counter = hdev->open_counter;\n\topen_stats_info.is_compute_ctx_active = hdev->is_compute_ctx_active;\n\topen_stats_info.compute_ctx_in_release = hdev->compute_ctx_in_release;\n\n\treturn copy_to_user(out, &open_stats_info,\n\t\tmin((size_t) max_size, sizeof(open_stats_info))) ? -EFAULT : 0;\n}\n\nstatic int dram_pending_rows_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tstruct hl_device *hdev = hpriv->hdev;\n\tu32 max_size = args->return_size;\n\tu32 pend_rows_num = 0;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tint rc;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\trc = hl_fw_dram_pending_row_get(hdev, &pend_rows_num);\n\tif (rc)\n\t\treturn rc;\n\n\treturn copy_to_user(out, &pend_rows_num,\n\t\t\tmin_t(size_t, max_size, sizeof(pend_rows_num))) ? -EFAULT : 0;\n}\n\nstatic int dram_replaced_rows_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tstruct hl_device *hdev = hpriv->hdev;\n\tu32 max_size = args->return_size;\n\tstruct cpucp_hbm_row_info info = {0};\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tint rc;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\trc = hl_fw_dram_replaced_row_get(hdev, &info);\n\tif (rc)\n\t\treturn rc;\n\n\treturn copy_to_user(out, &info, min_t(size_t, max_size, sizeof(info))) ? -EFAULT : 0;\n}\n\nstatic int last_err_open_dev_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tstruct hl_info_last_err_open_dev_time info = {0};\n\tstruct hl_device *hdev = hpriv->hdev;\n\tu32 max_size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\tinfo.timestamp = ktime_to_ns(hdev->last_successful_open_ktime);\n\n\treturn copy_to_user(out, &info, min_t(size_t, max_size, sizeof(info))) ? -EFAULT : 0;\n}\n\nstatic int cs_timeout_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tstruct hl_info_cs_timeout_event info = {0};\n\tstruct hl_device *hdev = hpriv->hdev;\n\tu32 max_size = args->return_size;\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\tinfo.seq = hdev->captured_err_info.cs_timeout.seq;\n\tinfo.timestamp = ktime_to_ns(hdev->captured_err_info.cs_timeout.timestamp);\n\n\treturn copy_to_user(out, &info, min_t(size_t, max_size, sizeof(info))) ? -EFAULT : 0;\n}\n\nstatic int razwi_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tstruct hl_device *hdev = hpriv->hdev;\n\tu32 max_size = args->return_size;\n\tstruct razwi_info *razwi_info;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\trazwi_info = &hdev->captured_err_info.razwi_info;\n\tif (!razwi_info->razwi_info_available)\n\t\treturn 0;\n\n\treturn copy_to_user(out, &razwi_info->razwi,\n\t\t\tmin_t(size_t, max_size, sizeof(struct hl_info_razwi_event))) ? -EFAULT : 0;\n}\n\nstatic int undefined_opcode_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tstruct hl_device *hdev = hpriv->hdev;\n\tu32 max_size = args->return_size;\n\tstruct hl_info_undefined_opcode_event info = {0};\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\tinfo.timestamp = ktime_to_ns(hdev->captured_err_info.undef_opcode.timestamp);\n\tinfo.engine_id = hdev->captured_err_info.undef_opcode.engine_id;\n\tinfo.cq_addr = hdev->captured_err_info.undef_opcode.cq_addr;\n\tinfo.cq_size = hdev->captured_err_info.undef_opcode.cq_size;\n\tinfo.stream_id = hdev->captured_err_info.undef_opcode.stream_id;\n\tinfo.cb_addr_streams_len = hdev->captured_err_info.undef_opcode.cb_addr_streams_len;\n\tmemcpy(info.cb_addr_streams, hdev->captured_err_info.undef_opcode.cb_addr_streams,\n\t\t\tsizeof(info.cb_addr_streams));\n\n\treturn copy_to_user(out, &info, min_t(size_t, max_size, sizeof(info))) ? -EFAULT : 0;\n}\n\nstatic int dev_mem_alloc_page_sizes_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tstruct hl_info_dev_memalloc_page_sizes info = {0};\n\tstruct hl_device *hdev = hpriv->hdev;\n\tu32 max_size = args->return_size;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\t \n\tinfo.page_order_bitmask = hdev->asic_prop.dmmu.supported_pages_mask;\n\n\treturn copy_to_user(out, &info, min_t(size_t, max_size, sizeof(info))) ? -EFAULT : 0;\n}\n\nstatic int sec_attest_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tstruct cpucp_sec_attest_info *sec_attest_info;\n\tstruct hl_info_sec_attest *info;\n\tu32 max_size = args->return_size;\n\tint rc;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\tsec_attest_info = kmalloc(sizeof(*sec_attest_info), GFP_KERNEL);\n\tif (!sec_attest_info)\n\t\treturn -ENOMEM;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info) {\n\t\trc = -ENOMEM;\n\t\tgoto free_sec_attest_info;\n\t}\n\n\trc = hl_fw_get_sec_attest_info(hpriv->hdev, sec_attest_info, args->sec_attest_nonce);\n\tif (rc)\n\t\tgoto free_info;\n\n\tinfo->nonce = le32_to_cpu(sec_attest_info->nonce);\n\tinfo->pcr_quote_len = le16_to_cpu(sec_attest_info->pcr_quote_len);\n\tinfo->pub_data_len = le16_to_cpu(sec_attest_info->pub_data_len);\n\tinfo->certificate_len = le16_to_cpu(sec_attest_info->certificate_len);\n\tinfo->pcr_num_reg = sec_attest_info->pcr_num_reg;\n\tinfo->pcr_reg_len = sec_attest_info->pcr_reg_len;\n\tinfo->quote_sig_len = sec_attest_info->quote_sig_len;\n\tmemcpy(&info->pcr_data, &sec_attest_info->pcr_data, sizeof(info->pcr_data));\n\tmemcpy(&info->pcr_quote, &sec_attest_info->pcr_quote, sizeof(info->pcr_quote));\n\tmemcpy(&info->public_data, &sec_attest_info->public_data, sizeof(info->public_data));\n\tmemcpy(&info->certificate, &sec_attest_info->certificate, sizeof(info->certificate));\n\tmemcpy(&info->quote_sig, &sec_attest_info->quote_sig, sizeof(info->quote_sig));\n\n\trc = copy_to_user(out, info,\n\t\t\t\tmin_t(size_t, max_size, sizeof(*info))) ? -EFAULT : 0;\n\nfree_info:\n\tkfree(info);\nfree_sec_attest_info:\n\tkfree(sec_attest_info);\n\n\treturn rc;\n}\n\nstatic int eventfd_register(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tint rc;\n\n\t \n\tmutex_lock(&hpriv->notifier_event.lock);\n\tif (hpriv->notifier_event.eventfd) {\n\t\tmutex_unlock(&hpriv->notifier_event.lock);\n\t\treturn -EINVAL;\n\t}\n\n\thpriv->notifier_event.eventfd = eventfd_ctx_fdget(args->eventfd);\n\tif (IS_ERR(hpriv->notifier_event.eventfd)) {\n\t\trc = PTR_ERR(hpriv->notifier_event.eventfd);\n\t\thpriv->notifier_event.eventfd = NULL;\n\t\tmutex_unlock(&hpriv->notifier_event.lock);\n\t\treturn rc;\n\t}\n\n\tmutex_unlock(&hpriv->notifier_event.lock);\n\treturn 0;\n}\n\nstatic int eventfd_unregister(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tmutex_lock(&hpriv->notifier_event.lock);\n\tif (!hpriv->notifier_event.eventfd) {\n\t\tmutex_unlock(&hpriv->notifier_event.lock);\n\t\treturn -EINVAL;\n\t}\n\n\teventfd_ctx_put(hpriv->notifier_event.eventfd);\n\thpriv->notifier_event.eventfd = NULL;\n\tmutex_unlock(&hpriv->notifier_event.lock);\n\treturn 0;\n}\n\nstatic int engine_status_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tu32 status_buf_size = args->return_size;\n\tstruct hl_device *hdev = hpriv->hdev;\n\tstruct engines_data eng_data;\n\tint rc;\n\n\tif ((status_buf_size < SZ_1K) || (status_buf_size > HL_ENGINES_DATA_MAX_SIZE) || (!out))\n\t\treturn -EINVAL;\n\n\teng_data.actual_size = 0;\n\teng_data.allocated_buf_size = status_buf_size;\n\teng_data.buf = vmalloc(status_buf_size);\n\tif (!eng_data.buf)\n\t\treturn -ENOMEM;\n\n\thdev->asic_funcs->is_device_idle(hdev, NULL, 0, &eng_data);\n\n\tif (eng_data.actual_size > eng_data.allocated_buf_size) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Engines data size (%d Bytes) is bigger than allocated size (%u Bytes)\\n\",\n\t\t\teng_data.actual_size, status_buf_size);\n\t\tvfree(eng_data.buf);\n\t\treturn -ENOMEM;\n\t}\n\n\targs->user_buffer_actual_size = eng_data.actual_size;\n\trc = copy_to_user(out, eng_data.buf, min_t(size_t, status_buf_size, eng_data.actual_size)) ?\n\t\t\t\t-EFAULT : 0;\n\n\tvfree(eng_data.buf);\n\n\treturn rc;\n}\n\nstatic int page_fault_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tstruct hl_device *hdev = hpriv->hdev;\n\tu32 max_size = args->return_size;\n\tstruct page_fault_info *pgf_info;\n\n\tif ((!max_size) || (!out))\n\t\treturn -EINVAL;\n\n\tpgf_info = &hdev->captured_err_info.page_fault_info;\n\tif (!pgf_info->page_fault_info_available)\n\t\treturn 0;\n\n\treturn copy_to_user(out, &pgf_info->page_fault,\n\t\t\tmin_t(size_t, max_size, sizeof(struct hl_page_fault_info))) ? -EFAULT : 0;\n}\n\nstatic int user_mappings_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n\tu32 user_buf_size = args->return_size;\n\tstruct hl_device *hdev = hpriv->hdev;\n\tstruct page_fault_info *pgf_info;\n\tu64 actual_size;\n\n\tif (!out)\n\t\treturn -EINVAL;\n\n\tpgf_info = &hdev->captured_err_info.page_fault_info;\n\tif (!pgf_info->page_fault_info_available)\n\t\treturn 0;\n\n\targs->array_size = pgf_info->num_of_user_mappings;\n\n\tactual_size = pgf_info->num_of_user_mappings * sizeof(struct hl_user_mapping);\n\tif (user_buf_size < actual_size)\n\t\treturn -ENOMEM;\n\n\treturn copy_to_user(out, pgf_info->user_mappings, actual_size) ? -EFAULT : 0;\n}\n\nstatic int hw_err_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tvoid __user *user_buf = (void __user *) (uintptr_t) args->return_pointer;\n\tstruct hl_device *hdev = hpriv->hdev;\n\tu32 user_buf_size = args->return_size;\n\tstruct hw_err_info *info;\n\tint rc;\n\n\tif (!user_buf)\n\t\treturn -EINVAL;\n\n\tinfo = &hdev->captured_err_info.hw_err;\n\tif (!info->event_info_available)\n\t\treturn 0;\n\n\tif (user_buf_size < sizeof(struct hl_info_hw_err_event))\n\t\treturn -ENOMEM;\n\n\trc = copy_to_user(user_buf, &info->event, sizeof(struct hl_info_hw_err_event));\n\treturn rc ? -EFAULT : 0;\n}\n\nstatic int fw_err_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n{\n\tvoid __user *user_buf = (void __user *) (uintptr_t) args->return_pointer;\n\tstruct hl_device *hdev = hpriv->hdev;\n\tu32 user_buf_size = args->return_size;\n\tstruct fw_err_info *info;\n\tint rc;\n\n\tif (!user_buf)\n\t\treturn -EINVAL;\n\n\tinfo = &hdev->captured_err_info.fw_err;\n\tif (!info->event_info_available)\n\t\treturn 0;\n\n\tif (user_buf_size < sizeof(struct hl_info_fw_err_event))\n\t\treturn -ENOMEM;\n\n\trc = copy_to_user(user_buf, &info->event, sizeof(struct hl_info_fw_err_event));\n\treturn rc ? -EFAULT : 0;\n}\n\nstatic int send_fw_generic_request(struct hl_device *hdev, struct hl_info_args *info_args)\n{\n\tvoid __user *buff = (void __user *) (uintptr_t) info_args->return_pointer;\n\tu32 size = info_args->return_size;\n\tdma_addr_t dma_handle;\n\tbool need_input_buff;\n\tvoid *fw_buff;\n\tint rc = 0;\n\n\tswitch (info_args->fw_sub_opcode) {\n\tcase HL_PASSTHROUGH_VERSIONS:\n\t\tneed_input_buff = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (size > SZ_1M) {\n\t\tdev_err(hdev->dev, \"buffer size cannot exceed 1MB\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfw_buff = hl_cpu_accessible_dma_pool_alloc(hdev, size, &dma_handle);\n\tif (!fw_buff)\n\t\treturn -ENOMEM;\n\n\n\tif (need_input_buff && copy_from_user(fw_buff, buff, size)) {\n\t\tdev_dbg(hdev->dev, \"Failed to copy from user FW buff\\n\");\n\t\trc = -EFAULT;\n\t\tgoto free_buff;\n\t}\n\n\trc = hl_fw_send_generic_request(hdev, info_args->fw_sub_opcode, dma_handle, &size);\n\tif (rc)\n\t\tgoto free_buff;\n\n\tif (copy_to_user(buff, fw_buff, min(size, info_args->return_size))) {\n\t\tdev_dbg(hdev->dev, \"Failed to copy to user FW generic req output\\n\");\n\t\trc = -EFAULT;\n\t}\n\nfree_buff:\n\thl_cpu_accessible_dma_pool_free(hdev, info_args->return_size, fw_buff);\n\n\treturn rc;\n}\n\nstatic int _hl_info_ioctl(struct hl_fpriv *hpriv, void *data,\n\t\t\t\tstruct device *dev)\n{\n\tenum hl_device_status status;\n\tstruct hl_info_args *args = data;\n\tstruct hl_device *hdev = hpriv->hdev;\n\tint rc;\n\n\tif (args->pad) {\n\t\tdev_dbg(hdev->dev, \"Padding bytes must be 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (args->op) {\n\tcase HL_INFO_HW_IP_INFO:\n\t\treturn hw_ip_info(hdev, args);\n\n\tcase HL_INFO_DEVICE_STATUS:\n\t\treturn device_status_info(hdev, args);\n\n\tcase HL_INFO_RESET_COUNT:\n\t\treturn get_reset_count(hdev, args);\n\n\tcase HL_INFO_HW_EVENTS:\n\t\treturn hw_events_info(hdev, false, args);\n\n\tcase HL_INFO_HW_EVENTS_AGGREGATE:\n\t\treturn hw_events_info(hdev, true, args);\n\n\tcase HL_INFO_CS_COUNTERS:\n\t\treturn cs_counters_info(hpriv, args);\n\n\tcase HL_INFO_CLK_THROTTLE_REASON:\n\t\treturn clk_throttle_info(hpriv, args);\n\n\tcase HL_INFO_SYNC_MANAGER:\n\t\treturn sync_manager_info(hpriv, args);\n\n\tcase HL_INFO_OPEN_STATS:\n\t\treturn open_stats_info(hpriv, args);\n\n\tcase HL_INFO_LAST_ERR_OPEN_DEV_TIME:\n\t\treturn last_err_open_dev_info(hpriv, args);\n\n\tcase HL_INFO_CS_TIMEOUT_EVENT:\n\t\treturn cs_timeout_info(hpriv, args);\n\n\tcase HL_INFO_RAZWI_EVENT:\n\t\treturn razwi_info(hpriv, args);\n\n\tcase HL_INFO_UNDEFINED_OPCODE_EVENT:\n\t\treturn undefined_opcode_info(hpriv, args);\n\n\tcase HL_INFO_DEV_MEM_ALLOC_PAGE_SIZES:\n\t\treturn dev_mem_alloc_page_sizes_info(hpriv, args);\n\n\tcase HL_INFO_GET_EVENTS:\n\t\treturn events_info(hpriv, args);\n\n\tcase HL_INFO_PAGE_FAULT_EVENT:\n\t\treturn page_fault_info(hpriv, args);\n\n\tcase HL_INFO_USER_MAPPINGS:\n\t\treturn user_mappings_info(hpriv, args);\n\n\tcase HL_INFO_UNREGISTER_EVENTFD:\n\t\treturn eventfd_unregister(hpriv, args);\n\n\tcase HL_INFO_HW_ERR_EVENT:\n\t\treturn hw_err_info(hpriv, args);\n\n\tcase HL_INFO_FW_ERR_EVENT:\n\t\treturn fw_err_info(hpriv, args);\n\n\tcase HL_INFO_DRAM_USAGE:\n\t\treturn dram_usage_info(hpriv, args);\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!hl_device_operational(hdev, &status)) {\n\t\tdev_dbg_ratelimited(dev,\n\t\t\t\"Device is %s. Can't execute INFO IOCTL\\n\",\n\t\t\thdev->status[status]);\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (args->op) {\n\tcase HL_INFO_HW_IDLE:\n\t\trc = hw_idle(hdev, args);\n\t\tbreak;\n\n\tcase HL_INFO_DEVICE_UTILIZATION:\n\t\trc = device_utilization(hdev, args);\n\t\tbreak;\n\n\tcase HL_INFO_CLK_RATE:\n\t\trc = get_clk_rate(hdev, args);\n\t\tbreak;\n\n\tcase HL_INFO_TIME_SYNC:\n\t\treturn time_sync_info(hdev, args);\n\n\tcase HL_INFO_PCI_COUNTERS:\n\t\treturn pci_counters_info(hpriv, args);\n\n\tcase HL_INFO_TOTAL_ENERGY:\n\t\treturn total_energy_consumption_info(hpriv, args);\n\n\tcase HL_INFO_PLL_FREQUENCY:\n\t\treturn pll_frequency_info(hpriv, args);\n\n\tcase HL_INFO_POWER:\n\t\treturn power_info(hpriv, args);\n\n\n\tcase HL_INFO_DRAM_REPLACED_ROWS:\n\t\treturn dram_replaced_rows_info(hpriv, args);\n\n\tcase HL_INFO_DRAM_PENDING_ROWS:\n\t\treturn dram_pending_rows_info(hpriv, args);\n\n\tcase HL_INFO_SECURED_ATTESTATION:\n\t\treturn sec_attest_info(hpriv, args);\n\n\tcase HL_INFO_REGISTER_EVENTFD:\n\t\treturn eventfd_register(hpriv, args);\n\n\tcase HL_INFO_ENGINE_STATUS:\n\t\treturn engine_status_info(hpriv, args);\n\n\tcase HL_INFO_FW_GENERIC_REQ:\n\t\treturn send_fw_generic_request(hdev, args);\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid request %d\\n\", args->op);\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int hl_info_ioctl(struct hl_fpriv *hpriv, void *data)\n{\n\treturn _hl_info_ioctl(hpriv, data, hpriv->hdev->dev);\n}\n\nstatic int hl_info_ioctl_control(struct hl_fpriv *hpriv, void *data)\n{\n\treturn _hl_info_ioctl(hpriv, data, hpriv->hdev->dev_ctrl);\n}\n\nstatic int hl_debug_ioctl(struct hl_fpriv *hpriv, void *data)\n{\n\tstruct hl_debug_args *args = data;\n\tstruct hl_device *hdev = hpriv->hdev;\n\tenum hl_device_status status;\n\n\tint rc = 0;\n\n\tif (!hl_device_operational(hdev, &status)) {\n\t\tdev_dbg_ratelimited(hdev->dev,\n\t\t\t\"Device is %s. Can't execute DEBUG IOCTL\\n\",\n\t\t\thdev->status[status]);\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (args->op) {\n\tcase HL_DEBUG_OP_ETR:\n\tcase HL_DEBUG_OP_ETF:\n\tcase HL_DEBUG_OP_STM:\n\tcase HL_DEBUG_OP_FUNNEL:\n\tcase HL_DEBUG_OP_BMON:\n\tcase HL_DEBUG_OP_SPMU:\n\tcase HL_DEBUG_OP_TIMESTAMP:\n\t\tif (!hdev->in_debug) {\n\t\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\t\"Rejecting debug configuration request because device not in debug mode\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\targs->input_size = min(args->input_size, hl_debug_struct_size[args->op]);\n\t\trc = debug_coresight(hdev, hpriv->ctx, args);\n\t\tbreak;\n\n\tcase HL_DEBUG_OP_SET_MODE:\n\t\trc = hl_device_set_debug_mode(hdev, hpriv->ctx, (bool) args->enable);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(hdev->dev, \"Invalid request %d\\n\", args->op);\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n#define HL_IOCTL_DEF(ioctl, _func) \\\n\t[_IOC_NR(ioctl)] = {.cmd = ioctl, .func = _func}\n\nstatic const struct hl_ioctl_desc hl_ioctls[] = {\n\tHL_IOCTL_DEF(HL_IOCTL_INFO, hl_info_ioctl),\n\tHL_IOCTL_DEF(HL_IOCTL_CB, hl_cb_ioctl),\n\tHL_IOCTL_DEF(HL_IOCTL_CS, hl_cs_ioctl),\n\tHL_IOCTL_DEF(HL_IOCTL_WAIT_CS, hl_wait_ioctl),\n\tHL_IOCTL_DEF(HL_IOCTL_MEMORY, hl_mem_ioctl),\n\tHL_IOCTL_DEF(HL_IOCTL_DEBUG, hl_debug_ioctl)\n};\n\nstatic const struct hl_ioctl_desc hl_ioctls_control[] = {\n\tHL_IOCTL_DEF(HL_IOCTL_INFO, hl_info_ioctl_control)\n};\n\nstatic long _hl_ioctl(struct file *filep, unsigned int cmd, unsigned long arg,\n\t\tconst struct hl_ioctl_desc *ioctl, struct device *dev)\n{\n\tstruct hl_fpriv *hpriv = filep->private_data;\n\tunsigned int nr = _IOC_NR(cmd);\n\tchar stack_kdata[128] = {0};\n\tchar *kdata = NULL;\n\tunsigned int usize, asize;\n\thl_ioctl_t *func;\n\tu32 hl_size;\n\tint retcode;\n\n\t \n\tfunc = ioctl->func;\n\n\tif (unlikely(!func)) {\n\t\tdev_dbg(dev, \"no function\\n\");\n\t\tretcode = -ENOTTY;\n\t\tgoto out_err;\n\t}\n\n\thl_size = _IOC_SIZE(ioctl->cmd);\n\tusize = asize = _IOC_SIZE(cmd);\n\tif (hl_size > asize)\n\t\tasize = hl_size;\n\n\tcmd = ioctl->cmd;\n\n\tif (cmd & (IOC_IN | IOC_OUT)) {\n\t\tif (asize <= sizeof(stack_kdata)) {\n\t\t\tkdata = stack_kdata;\n\t\t} else {\n\t\t\tkdata = kzalloc(asize, GFP_KERNEL);\n\t\t\tif (!kdata) {\n\t\t\t\tretcode = -ENOMEM;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmd & IOC_IN) {\n\t\tif (copy_from_user(kdata, (void __user *)arg, usize)) {\n\t\t\tretcode = -EFAULT;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tretcode = func(hpriv, kdata);\n\n\tif ((cmd & IOC_OUT) && copy_to_user((void __user *)arg, kdata, usize))\n\t\tretcode = -EFAULT;\n\nout_err:\n\tif (retcode)\n\t\tdev_dbg_ratelimited(dev, \"error in ioctl: pid=%d, cmd=0x%02x, nr=0x%02x\\n\",\n\t\t\t  task_pid_nr(current), cmd, nr);\n\n\tif (kdata != stack_kdata)\n\t\tkfree(kdata);\n\n\treturn retcode;\n}\n\nlong hl_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\n{\n\tstruct hl_fpriv *hpriv = filep->private_data;\n\tstruct hl_device *hdev = hpriv->hdev;\n\tconst struct hl_ioctl_desc *ioctl = NULL;\n\tunsigned int nr = _IOC_NR(cmd);\n\n\tif (!hdev) {\n\t\tpr_err_ratelimited(\"Sending ioctl after device was removed! Please close FD\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif ((nr >= HL_COMMAND_START) && (nr < HL_COMMAND_END)) {\n\t\tioctl = &hl_ioctls[nr];\n\t} else {\n\t\tdev_dbg_ratelimited(hdev->dev, \"invalid ioctl: pid=%d, nr=0x%02x\\n\",\n\t\t\ttask_pid_nr(current), nr);\n\t\treturn -ENOTTY;\n\t}\n\n\treturn _hl_ioctl(filep, cmd, arg, ioctl, hdev->dev);\n}\n\nlong hl_ioctl_control(struct file *filep, unsigned int cmd, unsigned long arg)\n{\n\tstruct hl_fpriv *hpriv = filep->private_data;\n\tstruct hl_device *hdev = hpriv->hdev;\n\tconst struct hl_ioctl_desc *ioctl = NULL;\n\tunsigned int nr = _IOC_NR(cmd);\n\n\tif (!hdev) {\n\t\tpr_err_ratelimited(\"Sending ioctl after device was removed! Please close FD\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (nr == _IOC_NR(HL_IOCTL_INFO)) {\n\t\tioctl = &hl_ioctls_control[nr];\n\t} else {\n\t\tdev_dbg_ratelimited(hdev->dev_ctrl, \"invalid ioctl: pid=%d, nr=0x%02x\\n\",\n\t\t\ttask_pid_nr(current), nr);\n\t\treturn -ENOTTY;\n\t}\n\n\treturn _hl_ioctl(filep, cmd, arg, ioctl, hdev->dev_ctrl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}