{
  "module_name": "memory_mgr.c",
  "hash_id": "e50dca8446c9e8077523a903b62194c54daa3917db2e31e62c10ceb0dcf64b31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/common/memory_mgr.c",
  "human_readable_source": "\n\n \n\n#include \"habanalabs.h\"\n\n \nstruct hl_mmap_mem_buf *hl_mmap_mem_buf_get(struct hl_mem_mgr *mmg, u64 handle)\n{\n\tstruct hl_mmap_mem_buf *buf;\n\n\tspin_lock(&mmg->lock);\n\tbuf = idr_find(&mmg->handles, lower_32_bits(handle >> PAGE_SHIFT));\n\tif (!buf) {\n\t\tspin_unlock(&mmg->lock);\n\t\tdev_dbg(mmg->dev, \"Buff get failed, no match to handle %#llx\\n\", handle);\n\t\treturn NULL;\n\t}\n\tkref_get(&buf->refcount);\n\tspin_unlock(&mmg->lock);\n\treturn buf;\n}\n\n \nstatic void hl_mmap_mem_buf_destroy(struct hl_mmap_mem_buf *buf)\n{\n\tif (buf->behavior->release)\n\t\tbuf->behavior->release(buf);\n\n\tkfree(buf);\n}\n\n \nstatic void hl_mmap_mem_buf_release(struct kref *kref)\n{\n\tstruct hl_mmap_mem_buf *buf =\n\t\tcontainer_of(kref, struct hl_mmap_mem_buf, refcount);\n\n\tspin_lock(&buf->mmg->lock);\n\tidr_remove(&buf->mmg->handles, lower_32_bits(buf->handle >> PAGE_SHIFT));\n\tspin_unlock(&buf->mmg->lock);\n\n\thl_mmap_mem_buf_destroy(buf);\n}\n\n \nstatic void hl_mmap_mem_buf_remove_idr_locked(struct kref *kref)\n{\n\tstruct hl_mmap_mem_buf *buf =\n\t\tcontainer_of(kref, struct hl_mmap_mem_buf, refcount);\n\n\tidr_remove(&buf->mmg->handles, lower_32_bits(buf->handle >> PAGE_SHIFT));\n}\n\n \nint hl_mmap_mem_buf_put(struct hl_mmap_mem_buf *buf)\n{\n\treturn kref_put(&buf->refcount, hl_mmap_mem_buf_release);\n}\n\n \nint hl_mmap_mem_buf_put_handle(struct hl_mem_mgr *mmg, u64 handle)\n{\n\tstruct hl_mmap_mem_buf *buf;\n\n\tspin_lock(&mmg->lock);\n\tbuf = idr_find(&mmg->handles, lower_32_bits(handle >> PAGE_SHIFT));\n\tif (!buf) {\n\t\tspin_unlock(&mmg->lock);\n\t\tdev_dbg(mmg->dev,\n\t\t\t \"Buff put failed, no match to handle %#llx\\n\", handle);\n\t\treturn -EINVAL;\n\t}\n\n\tif (kref_put(&buf->refcount, hl_mmap_mem_buf_remove_idr_locked)) {\n\t\tspin_unlock(&mmg->lock);\n\t\thl_mmap_mem_buf_destroy(buf);\n\t\treturn 1;\n\t}\n\n\tspin_unlock(&mmg->lock);\n\treturn 0;\n}\n\n \nstruct hl_mmap_mem_buf *\nhl_mmap_mem_buf_alloc(struct hl_mem_mgr *mmg,\n\t\t      struct hl_mmap_mem_buf_behavior *behavior, gfp_t gfp,\n\t\t      void *args)\n{\n\tstruct hl_mmap_mem_buf *buf;\n\tint rc;\n\n\tbuf = kzalloc(sizeof(*buf), gfp);\n\tif (!buf)\n\t\treturn NULL;\n\n\tspin_lock(&mmg->lock);\n\trc = idr_alloc(&mmg->handles, buf, 1, 0, GFP_ATOMIC);\n\tspin_unlock(&mmg->lock);\n\tif (rc < 0) {\n\t\tdev_err(mmg->dev,\n\t\t\t\"%s: Failed to allocate IDR for a new buffer, rc=%d\\n\",\n\t\t\tbehavior->topic, rc);\n\t\tgoto free_buf;\n\t}\n\n\tbuf->mmg = mmg;\n\tbuf->behavior = behavior;\n\tbuf->handle = (((u64)rc | buf->behavior->mem_id) << PAGE_SHIFT);\n\tkref_init(&buf->refcount);\n\n\trc = buf->behavior->alloc(buf, gfp, args);\n\tif (rc) {\n\t\tdev_err(mmg->dev, \"%s: Failure in buffer alloc callback %d\\n\",\n\t\t\tbehavior->topic, rc);\n\t\tgoto remove_idr;\n\t}\n\n\treturn buf;\n\nremove_idr:\n\tspin_lock(&mmg->lock);\n\tidr_remove(&mmg->handles, lower_32_bits(buf->handle >> PAGE_SHIFT));\n\tspin_unlock(&mmg->lock);\nfree_buf:\n\tkfree(buf);\n\treturn NULL;\n}\n\n \nstatic void hl_mmap_mem_buf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct hl_mmap_mem_buf *buf =\n\t\t(struct hl_mmap_mem_buf *)vma->vm_private_data;\n\tlong new_mmap_size;\n\n\tnew_mmap_size = buf->real_mapped_size - (vma->vm_end - vma->vm_start);\n\n\tif (new_mmap_size > 0) {\n\t\tbuf->real_mapped_size = new_mmap_size;\n\t\treturn;\n\t}\n\n\tatomic_set(&buf->mmap, 0);\n\thl_mmap_mem_buf_put(buf);\n\tvma->vm_private_data = NULL;\n}\n\nstatic const struct vm_operations_struct hl_mmap_mem_buf_vm_ops = {\n\t.close = hl_mmap_mem_buf_vm_close\n};\n\n \nint hl_mem_mgr_mmap(struct hl_mem_mgr *mmg, struct vm_area_struct *vma,\n\t\t    void *args)\n{\n\tstruct hl_mmap_mem_buf *buf;\n\tu64 user_mem_size;\n\tu64 handle;\n\tint rc;\n\n\t \n\thandle = vma->vm_pgoff << PAGE_SHIFT;\n\tvma->vm_pgoff = 0;\n\n\t \n\tbuf = hl_mmap_mem_buf_get(mmg, handle);\n\tif (!buf) {\n\t\tdev_err(mmg->dev,\n\t\t\t\"Memory mmap failed, no match to handle %#llx\\n\", handle);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tuser_mem_size = vma->vm_end - vma->vm_start;\n\tif (user_mem_size != ALIGN(buf->mappable_size, PAGE_SIZE)) {\n\t\tdev_err(mmg->dev,\n\t\t\t\"%s: Memory mmap failed, mmap VM size 0x%llx != 0x%llx allocated physical mem size\\n\",\n\t\t\tbuf->behavior->topic, user_mem_size, buf->mappable_size);\n\t\trc = -EINVAL;\n\t\tgoto put_mem;\n\t}\n\n#ifdef _HAS_TYPE_ARG_IN_ACCESS_OK\n\tif (!access_ok(VERIFY_WRITE, (void __user *)(uintptr_t)vma->vm_start,\n\t\t       user_mem_size)) {\n#else\n\tif (!access_ok((void __user *)(uintptr_t)vma->vm_start,\n\t\t       user_mem_size)) {\n#endif\n\t\tdev_err(mmg->dev, \"%s: User pointer is invalid - 0x%lx\\n\",\n\t\t\tbuf->behavior->topic, vma->vm_start);\n\n\t\trc = -EINVAL;\n\t\tgoto put_mem;\n\t}\n\n\tif (atomic_cmpxchg(&buf->mmap, 0, 1)) {\n\t\tdev_err(mmg->dev,\n\t\t\t\"%s, Memory mmap failed, already mapped to user\\n\",\n\t\t\tbuf->behavior->topic);\n\t\trc = -EINVAL;\n\t\tgoto put_mem;\n\t}\n\n\tvma->vm_ops = &hl_mmap_mem_buf_vm_ops;\n\n\t \n\n\tvma->vm_private_data = buf;\n\n\trc = buf->behavior->mmap(buf, vma, args);\n\tif (rc) {\n\t\tatomic_set(&buf->mmap, 0);\n\t\tgoto put_mem;\n\t}\n\n\tbuf->real_mapped_size = buf->mappable_size;\n\tvma->vm_pgoff = handle >> PAGE_SHIFT;\n\n\treturn 0;\n\nput_mem:\n\thl_mmap_mem_buf_put(buf);\n\treturn rc;\n}\n\n \nvoid hl_mem_mgr_init(struct device *dev, struct hl_mem_mgr *mmg)\n{\n\tmmg->dev = dev;\n\tspin_lock_init(&mmg->lock);\n\tidr_init(&mmg->handles);\n}\n\n \nvoid hl_mem_mgr_fini(struct hl_mem_mgr *mmg)\n{\n\tstruct hl_mmap_mem_buf *buf;\n\tstruct idr *idp;\n\tconst char *topic;\n\tu32 id;\n\n\tidp = &mmg->handles;\n\n\tidr_for_each_entry(idp, buf, id) {\n\t\ttopic = buf->behavior->topic;\n\t\tif (hl_mmap_mem_buf_put(buf) != 1)\n\t\t\tdev_err(mmg->dev,\n\t\t\t\t\"%s: Buff handle %u for CTX is still alive\\n\",\n\t\t\t\ttopic, id);\n\t}\n}\n\n \nvoid hl_mem_mgr_idr_destroy(struct hl_mem_mgr *mmg)\n{\n\tif (!idr_is_empty(&mmg->handles))\n\t\tdev_crit(mmg->dev, \"memory manager IDR is destroyed while it is not empty!\\n\");\n\n\tidr_destroy(&mmg->handles);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}