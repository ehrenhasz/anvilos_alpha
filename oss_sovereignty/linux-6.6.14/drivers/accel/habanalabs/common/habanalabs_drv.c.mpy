{
  "module_name": "habanalabs_drv.c",
  "hash_id": "af7135135ebf407ce65ed3a91612f332bda9dfbd27584dce0eb537165f3068b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/common/habanalabs_drv.c",
  "human_readable_source": "\n\n \n\n#define pr_fmt(fmt)\t\t\"habanalabs: \" fmt\n\n#include \"habanalabs.h\"\n#include \"../include/hw_ip/pci/pci_general.h\"\n\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/habanalabs.h>\n\n#define HL_DRIVER_AUTHOR\t\"HabanaLabs Kernel Driver Team\"\n\n#define HL_DRIVER_DESC\t\t\"Driver for HabanaLabs's AI Accelerators\"\n\nMODULE_AUTHOR(HL_DRIVER_AUTHOR);\nMODULE_DESCRIPTION(HL_DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\n\nstatic int hl_major;\nstatic struct class *hl_class;\nstatic DEFINE_IDR(hl_devs_idr);\nstatic DEFINE_MUTEX(hl_devs_idr_lock);\n\n#define HL_DEFAULT_TIMEOUT_LOCKED\t30\t \n#define GAUDI_DEFAULT_TIMEOUT_LOCKED\t600\t \n\nstatic int timeout_locked = HL_DEFAULT_TIMEOUT_LOCKED;\nstatic int reset_on_lockup = 1;\nstatic int memory_scrub;\nstatic ulong boot_error_status_mask = ULONG_MAX;\n\nmodule_param(timeout_locked, int, 0444);\nMODULE_PARM_DESC(timeout_locked,\n\t\"Device lockup timeout in seconds (0 = disabled, default 30s)\");\n\nmodule_param(reset_on_lockup, int, 0444);\nMODULE_PARM_DESC(reset_on_lockup,\n\t\"Do device reset on lockup (0 = no, 1 = yes, default yes)\");\n\nmodule_param(memory_scrub, int, 0444);\nMODULE_PARM_DESC(memory_scrub,\n\t\"Scrub device memory in various states (0 = no, 1 = yes, default no)\");\n\nmodule_param(boot_error_status_mask, ulong, 0444);\nMODULE_PARM_DESC(boot_error_status_mask,\n\t\"Mask of the error status during device CPU boot (If bitX is cleared then error X is masked. Default all 1's)\");\n\n#define PCI_IDS_GOYA\t\t\t0x0001\n#define PCI_IDS_GAUDI\t\t\t0x1000\n#define PCI_IDS_GAUDI_SEC\t\t0x1010\n\n#define PCI_IDS_GAUDI2\t\t\t0x1020\n\nstatic const struct pci_device_id ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HABANALABS, PCI_IDS_GOYA), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HABANALABS, PCI_IDS_GAUDI), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HABANALABS, PCI_IDS_GAUDI_SEC), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HABANALABS, PCI_IDS_GAUDI2), },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, ids);\n\n \nstatic enum hl_asic_type get_asic_type(struct hl_device *hdev)\n{\n\tstruct pci_dev *pdev = hdev->pdev;\n\tenum hl_asic_type asic_type = ASIC_INVALID;\n\n\tswitch (pdev->device) {\n\tcase PCI_IDS_GOYA:\n\t\tasic_type = ASIC_GOYA;\n\t\tbreak;\n\tcase PCI_IDS_GAUDI:\n\t\tasic_type = ASIC_GAUDI;\n\t\tbreak;\n\tcase PCI_IDS_GAUDI_SEC:\n\t\tasic_type = ASIC_GAUDI_SEC;\n\t\tbreak;\n\tcase PCI_IDS_GAUDI2:\n\t\tswitch (pdev->revision) {\n\t\tcase REV_ID_A:\n\t\t\tasic_type = ASIC_GAUDI2;\n\t\t\tbreak;\n\t\tcase REV_ID_B:\n\t\t\tasic_type = ASIC_GAUDI2B;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn asic_type;\n}\n\nstatic bool is_asic_secured(enum hl_asic_type asic_type)\n{\n\tswitch (asic_type) {\n\tcase ASIC_GAUDI_SEC:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nint hl_device_open(struct inode *inode, struct file *filp)\n{\n\tenum hl_device_status status;\n\tstruct hl_device *hdev;\n\tstruct hl_fpriv *hpriv;\n\tint rc;\n\n\tmutex_lock(&hl_devs_idr_lock);\n\thdev = idr_find(&hl_devs_idr, iminor(inode));\n\tmutex_unlock(&hl_devs_idr_lock);\n\n\tif (!hdev) {\n\t\tpr_err(\"Couldn't find device %d:%d\\n\",\n\t\t\timajor(inode), iminor(inode));\n\t\treturn -ENXIO;\n\t}\n\n\thpriv = kzalloc(sizeof(*hpriv), GFP_KERNEL);\n\tif (!hpriv)\n\t\treturn -ENOMEM;\n\n\thpriv->hdev = hdev;\n\tfilp->private_data = hpriv;\n\thpriv->filp = filp;\n\n\tmutex_init(&hpriv->notifier_event.lock);\n\tmutex_init(&hpriv->restore_phase_mutex);\n\tmutex_init(&hpriv->ctx_lock);\n\tkref_init(&hpriv->refcount);\n\tnonseekable_open(inode, filp);\n\n\thl_ctx_mgr_init(&hpriv->ctx_mgr);\n\thl_mem_mgr_init(hpriv->hdev->dev, &hpriv->mem_mgr);\n\n\thpriv->taskpid = get_task_pid(current, PIDTYPE_PID);\n\n\tmutex_lock(&hdev->fpriv_list_lock);\n\n\tif (!hl_device_operational(hdev, &status)) {\n\t\tdev_dbg_ratelimited(hdev->dev,\n\t\t\t\"Can't open %s because it is %s\\n\",\n\t\t\tdev_name(hdev->dev), hdev->status[status]);\n\n\t\tif (status == HL_DEVICE_STATUS_IN_RESET ||\n\t\t\t\t\tstatus == HL_DEVICE_STATUS_IN_RESET_AFTER_DEVICE_RELEASE)\n\t\t\trc = -EAGAIN;\n\t\telse\n\t\t\trc = -EPERM;\n\n\t\tgoto out_err;\n\t}\n\n\tif (hdev->is_in_dram_scrub) {\n\t\tdev_dbg_ratelimited(hdev->dev,\n\t\t\t\"Can't open %s during dram scrub\\n\",\n\t\t\tdev_name(hdev->dev));\n\t\trc = -EAGAIN;\n\t\tgoto out_err;\n\t}\n\n\tif (hdev->compute_ctx_in_release) {\n\t\tdev_dbg_ratelimited(hdev->dev,\n\t\t\t\"Can't open %s because another user is still releasing it\\n\",\n\t\t\tdev_name(hdev->dev));\n\t\trc = -EAGAIN;\n\t\tgoto out_err;\n\t}\n\n\tif (hdev->is_compute_ctx_active) {\n\t\tdev_dbg_ratelimited(hdev->dev,\n\t\t\t\"Can't open %s because another user is working on it\\n\",\n\t\t\tdev_name(hdev->dev));\n\t\trc = -EBUSY;\n\t\tgoto out_err;\n\t}\n\n\trc = hl_ctx_create(hdev, hpriv);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to create context %d\\n\", rc);\n\t\tgoto out_err;\n\t}\n\n\tlist_add(&hpriv->dev_node, &hdev->fpriv_list);\n\tmutex_unlock(&hdev->fpriv_list_lock);\n\n\thdev->asic_funcs->send_device_activity(hdev, true);\n\n\thl_debugfs_add_file(hpriv);\n\n\thl_enable_err_info_capture(&hdev->captured_err_info);\n\n\thdev->open_counter++;\n\thdev->last_successful_open_jif = jiffies;\n\thdev->last_successful_open_ktime = ktime_get();\n\n\treturn 0;\n\nout_err:\n\tmutex_unlock(&hdev->fpriv_list_lock);\n\thl_mem_mgr_fini(&hpriv->mem_mgr);\n\thl_mem_mgr_idr_destroy(&hpriv->mem_mgr);\n\thl_ctx_mgr_fini(hpriv->hdev, &hpriv->ctx_mgr);\n\tfilp->private_data = NULL;\n\tmutex_destroy(&hpriv->ctx_lock);\n\tmutex_destroy(&hpriv->restore_phase_mutex);\n\tmutex_destroy(&hpriv->notifier_event.lock);\n\tput_pid(hpriv->taskpid);\n\n\tkfree(hpriv);\n\n\treturn rc;\n}\n\nint hl_device_open_ctrl(struct inode *inode, struct file *filp)\n{\n\tstruct hl_device *hdev;\n\tstruct hl_fpriv *hpriv;\n\tint rc;\n\n\tmutex_lock(&hl_devs_idr_lock);\n\thdev = idr_find(&hl_devs_idr, iminor(inode));\n\tmutex_unlock(&hl_devs_idr_lock);\n\n\tif (!hdev) {\n\t\tpr_err(\"Couldn't find device %d:%d\\n\",\n\t\t\timajor(inode), iminor(inode));\n\t\treturn -ENXIO;\n\t}\n\n\thpriv = kzalloc(sizeof(*hpriv), GFP_KERNEL);\n\tif (!hpriv)\n\t\treturn -ENOMEM;\n\n\t \n\thpriv->hdev = hdev;\n\tfilp->private_data = hpriv;\n\thpriv->filp = filp;\n\n\tmutex_init(&hpriv->notifier_event.lock);\n\tnonseekable_open(inode, filp);\n\n\thpriv->taskpid = get_task_pid(current, PIDTYPE_PID);\n\n\tmutex_lock(&hdev->fpriv_ctrl_list_lock);\n\n\tif (!hl_ctrl_device_operational(hdev, NULL)) {\n\t\tdev_dbg_ratelimited(hdev->dev_ctrl,\n\t\t\t\"Can't open %s because it is disabled\\n\",\n\t\t\tdev_name(hdev->dev_ctrl));\n\t\trc = -EPERM;\n\t\tgoto out_err;\n\t}\n\n\tlist_add(&hpriv->dev_node, &hdev->fpriv_ctrl_list);\n\tmutex_unlock(&hdev->fpriv_ctrl_list_lock);\n\n\treturn 0;\n\nout_err:\n\tmutex_unlock(&hdev->fpriv_ctrl_list_lock);\n\tfilp->private_data = NULL;\n\tput_pid(hpriv->taskpid);\n\n\tkfree(hpriv);\n\n\treturn rc;\n}\n\nstatic void set_driver_behavior_per_device(struct hl_device *hdev)\n{\n\thdev->nic_ports_mask = 0;\n\thdev->fw_components = FW_TYPE_ALL_TYPES;\n\thdev->cpu_queues_enable = 1;\n\thdev->pldm = 0;\n\thdev->hard_reset_on_fw_events = 1;\n\thdev->bmc_enable = 1;\n\thdev->reset_on_preboot_fail = 1;\n\thdev->heartbeat = 1;\n}\n\nstatic void copy_kernel_module_params_to_device(struct hl_device *hdev)\n{\n\thdev->asic_prop.fw_security_enabled = is_asic_secured(hdev->asic_type);\n\n\thdev->major = hl_major;\n\thdev->hclass = hl_class;\n\thdev->memory_scrub = memory_scrub;\n\thdev->reset_on_lockup = reset_on_lockup;\n\thdev->boot_error_status_mask = boot_error_status_mask;\n}\n\nstatic void fixup_device_params_per_asic(struct hl_device *hdev, int timeout)\n{\n\tswitch (hdev->asic_type) {\n\tcase ASIC_GAUDI:\n\tcase ASIC_GAUDI_SEC:\n\t\t \n\t\tif (timeout == HL_DEFAULT_TIMEOUT_LOCKED)\n\t\t\thdev->timeout_jiffies = msecs_to_jiffies(GAUDI_DEFAULT_TIMEOUT_LOCKED *\n\t\t\t\t\t\t\t\t\t\tMSEC_PER_SEC);\n\n\t\thdev->reset_upon_device_release = 0;\n\t\tbreak;\n\n\tcase ASIC_GOYA:\n\t\thdev->reset_upon_device_release = 0;\n\t\tbreak;\n\n\tdefault:\n\t\thdev->reset_upon_device_release = 1;\n\t\tbreak;\n\t}\n}\n\nstatic int fixup_device_params(struct hl_device *hdev)\n{\n\tint tmp_timeout;\n\n\ttmp_timeout = timeout_locked;\n\n\thdev->fw_poll_interval_usec = HL_FW_STATUS_POLL_INTERVAL_USEC;\n\thdev->fw_comms_poll_interval_usec = HL_FW_STATUS_POLL_INTERVAL_USEC;\n\n\tif (tmp_timeout)\n\t\thdev->timeout_jiffies = msecs_to_jiffies(tmp_timeout * MSEC_PER_SEC);\n\telse\n\t\thdev->timeout_jiffies = MAX_SCHEDULE_TIMEOUT;\n\n\thdev->stop_on_err = true;\n\thdev->reset_info.curr_reset_cause = HL_RESET_CAUSE_UNKNOWN;\n\thdev->reset_info.prev_reset_trigger = HL_RESET_TRIGGER_DEFAULT;\n\n\t \n\thdev->disabled = true;\n\n\tif (!(hdev->fw_components & FW_TYPE_PREBOOT_CPU) &&\n\t\t\t(hdev->fw_components & ~FW_TYPE_PREBOOT_CPU)) {\n\t\tpr_err(\"Preboot must be set along with other components\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!hdev->cpu_queues_enable)\n\t\thdev->heartbeat = 0;\n\tfixup_device_params_per_asic(hdev, tmp_timeout);\n\n\treturn 0;\n}\n\n \nstatic int create_hdev(struct hl_device **dev, struct pci_dev *pdev)\n{\n\tint main_id, ctrl_id = 0, rc = 0;\n\tstruct hl_device *hdev;\n\n\t*dev = NULL;\n\n\thdev = kzalloc(sizeof(*hdev), GFP_KERNEL);\n\tif (!hdev)\n\t\treturn -ENOMEM;\n\n\t \n\thdev->pdev = pdev;\n\n\t \n\tstrncpy(hdev->status[HL_DEVICE_STATUS_OPERATIONAL], \"operational\", HL_STR_MAX);\n\tstrncpy(hdev->status[HL_DEVICE_STATUS_IN_RESET], \"in reset\", HL_STR_MAX);\n\tstrncpy(hdev->status[HL_DEVICE_STATUS_MALFUNCTION], \"disabled\", HL_STR_MAX);\n\tstrncpy(hdev->status[HL_DEVICE_STATUS_NEEDS_RESET], \"needs reset\", HL_STR_MAX);\n\tstrncpy(hdev->status[HL_DEVICE_STATUS_IN_DEVICE_CREATION],\n\t\t\t\t\t\"in device creation\", HL_STR_MAX);\n\tstrncpy(hdev->status[HL_DEVICE_STATUS_IN_RESET_AFTER_DEVICE_RELEASE],\n\t\t\t\t\t\"in reset after device release\", HL_STR_MAX);\n\n\n\t \n\thdev->asic_type = get_asic_type(hdev);\n\tif (hdev->asic_type == ASIC_INVALID) {\n\t\tdev_err(&pdev->dev, \"Unsupported ASIC\\n\");\n\t\trc = -ENODEV;\n\t\tgoto free_hdev;\n\t}\n\n\tcopy_kernel_module_params_to_device(hdev);\n\n\tset_driver_behavior_per_device(hdev);\n\n\tfixup_device_params(hdev);\n\n\tmutex_lock(&hl_devs_idr_lock);\n\n\t \n\tmain_id = idr_alloc(&hl_devs_idr, hdev, 0, HL_MAX_MINORS, GFP_KERNEL);\n\n\tif (main_id >= 0)\n\t\tctrl_id = idr_alloc(&hl_devs_idr, hdev, main_id + 1,\n\t\t\t\t\tmain_id + 2, GFP_KERNEL);\n\n\tmutex_unlock(&hl_devs_idr_lock);\n\n\tif ((main_id < 0) || (ctrl_id < 0)) {\n\t\tif ((main_id == -ENOSPC) || (ctrl_id == -ENOSPC))\n\t\t\tpr_err(\"too many devices in the system\\n\");\n\n\t\tif (main_id >= 0) {\n\t\t\tmutex_lock(&hl_devs_idr_lock);\n\t\t\tidr_remove(&hl_devs_idr, main_id);\n\t\t\tmutex_unlock(&hl_devs_idr_lock);\n\t\t}\n\n\t\trc = -EBUSY;\n\t\tgoto free_hdev;\n\t}\n\n\thdev->id = main_id;\n\thdev->id_control = ctrl_id;\n\n\t*dev = hdev;\n\n\treturn 0;\n\nfree_hdev:\n\tkfree(hdev);\n\treturn rc;\n}\n\n \nstatic void destroy_hdev(struct hl_device *hdev)\n{\n\t \n\tmutex_lock(&hl_devs_idr_lock);\n\tidr_remove(&hl_devs_idr, hdev->id);\n\tidr_remove(&hl_devs_idr, hdev->id_control);\n\tmutex_unlock(&hl_devs_idr_lock);\n\n\tkfree(hdev);\n}\n\nstatic int hl_pmops_suspend(struct device *dev)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\tpr_debug(\"Going to suspend PCI device\\n\");\n\n\tif (!hdev) {\n\t\tpr_err(\"device pointer is NULL in suspend\\n\");\n\t\treturn 0;\n\t}\n\n\treturn hl_device_suspend(hdev);\n}\n\nstatic int hl_pmops_resume(struct device *dev)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\tpr_debug(\"Going to resume PCI device\\n\");\n\n\tif (!hdev) {\n\t\tpr_err(\"device pointer is NULL in resume\\n\");\n\t\treturn 0;\n\t}\n\n\treturn hl_device_resume(hdev);\n}\n\n \nstatic int hl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct hl_device *hdev;\n\tint rc;\n\n\tdev_info(&pdev->dev, HL_NAME\n\t\t \" device found [%04x:%04x] (rev %x)\\n\",\n\t\t (int)pdev->vendor, (int)pdev->device, (int)pdev->revision);\n\n\trc = create_hdev(&hdev, pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_set_drvdata(pdev, hdev);\n\n\trc = hl_device_init(hdev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Fatal error during habanalabs device init\\n\");\n\t\trc = -ENODEV;\n\t\tgoto disable_device;\n\t}\n\n\treturn 0;\n\ndisable_device:\n\tpci_set_drvdata(pdev, NULL);\n\tdestroy_hdev(hdev);\n\n\treturn rc;\n}\n\n \nstatic void hl_pci_remove(struct pci_dev *pdev)\n{\n\tstruct hl_device *hdev;\n\n\thdev = pci_get_drvdata(pdev);\n\tif (!hdev)\n\t\treturn;\n\n\thl_device_fini(hdev);\n\tpci_set_drvdata(pdev, NULL);\n\tdestroy_hdev(hdev);\n}\n\n \nstatic pci_ers_result_t\nhl_pci_err_detected(struct pci_dev *pdev, pci_channel_state_t state)\n{\n\tstruct hl_device *hdev = pci_get_drvdata(pdev);\n\tenum pci_ers_result result;\n\n\tswitch (state) {\n\tcase pci_channel_io_normal:\n\t\tdev_warn(hdev->dev, \"PCI normal state error detected\\n\");\n\t\treturn PCI_ERS_RESULT_CAN_RECOVER;\n\n\tcase pci_channel_io_frozen:\n\t\tdev_warn(hdev->dev, \"PCI frozen state error detected\\n\");\n\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\tbreak;\n\n\tcase pci_channel_io_perm_failure:\n\t\tdev_warn(hdev->dev, \"PCI failure state error detected\\n\");\n\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\tbreak;\n\n\tdefault:\n\t\tresult = PCI_ERS_RESULT_NONE;\n\t}\n\n\thdev->asic_funcs->halt_engines(hdev, true, false);\n\n\treturn result;\n}\n\n \nstatic void hl_pci_err_resume(struct pci_dev *pdev)\n{\n\tstruct hl_device *hdev = pci_get_drvdata(pdev);\n\n\tdev_warn(hdev->dev, \"Resuming device after PCI slot reset\\n\");\n\thl_device_resume(hdev);\n}\n\n \nstatic pci_ers_result_t hl_pci_err_slot_reset(struct pci_dev *pdev)\n{\n\tstruct hl_device *hdev = pci_get_drvdata(pdev);\n\n\tdev_warn(hdev->dev, \"PCI slot reset detected\\n\");\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic const struct dev_pm_ops hl_pm_ops = {\n\t.suspend = hl_pmops_suspend,\n\t.resume = hl_pmops_resume,\n};\n\nstatic const struct pci_error_handlers hl_pci_err_handler = {\n\t.error_detected = hl_pci_err_detected,\n\t.slot_reset = hl_pci_err_slot_reset,\n\t.resume = hl_pci_err_resume,\n};\n\nstatic struct pci_driver hl_pci_driver = {\n\t.name = HL_NAME,\n\t.id_table = ids,\n\t.probe = hl_pci_probe,\n\t.remove = hl_pci_remove,\n\t.shutdown = hl_pci_remove,\n\t.driver = {\n\t\t.name = HL_NAME,\n\t\t.pm = &hl_pm_ops,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.err_handler = &hl_pci_err_handler,\n};\n\n \nstatic int __init hl_init(void)\n{\n\tint rc;\n\tdev_t dev;\n\n\tpr_info(\"loading driver\\n\");\n\n\trc = alloc_chrdev_region(&dev, 0, HL_MAX_MINORS, HL_NAME);\n\tif (rc < 0) {\n\t\tpr_err(\"unable to get major\\n\");\n\t\treturn rc;\n\t}\n\n\thl_major = MAJOR(dev);\n\n\thl_class = class_create(HL_NAME);\n\tif (IS_ERR(hl_class)) {\n\t\tpr_err(\"failed to allocate class\\n\");\n\t\trc = PTR_ERR(hl_class);\n\t\tgoto remove_major;\n\t}\n\n\thl_debugfs_init();\n\n\trc = pci_register_driver(&hl_pci_driver);\n\tif (rc) {\n\t\tpr_err(\"failed to register pci device\\n\");\n\t\tgoto remove_debugfs;\n\t}\n\n\tpr_debug(\"driver loaded\\n\");\n\n\treturn 0;\n\nremove_debugfs:\n\thl_debugfs_fini();\n\tclass_destroy(hl_class);\nremove_major:\n\tunregister_chrdev_region(MKDEV(hl_major, 0), HL_MAX_MINORS);\n\treturn rc;\n}\n\n \nstatic void __exit hl_exit(void)\n{\n\tpci_unregister_driver(&hl_pci_driver);\n\n\t \n\thl_debugfs_fini();\n\n\tclass_destroy(hl_class);\n\tunregister_chrdev_region(MKDEV(hl_major, 0), HL_MAX_MINORS);\n\n\tidr_destroy(&hl_devs_idr);\n\n\tpr_debug(\"driver removed\\n\");\n}\n\nmodule_init(hl_init);\nmodule_exit(hl_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}