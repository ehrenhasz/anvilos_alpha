{
  "module_name": "hwmon.c",
  "hash_id": "bc64c5c19bf09632c242c19140d9af7c601b8a7b1c42abc339708c505a1e3ce3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/common/hwmon.c",
  "human_readable_source": "\n\n \n\n#include \"habanalabs.h\"\n\n#include <linux/pci.h>\n#include <linux/hwmon.h>\n\n#define HWMON_NR_SENSOR_TYPES\t\t(hwmon_max)\n\n#ifdef _HAS_HWMON_HWMON_T_ENABLE\n\nstatic u32 fixup_flags_legacy_fw(struct hl_device *hdev, enum hwmon_sensor_types type,\n\t\t\t\t\tu32 cpucp_flags)\n{\n\tu32 flags;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tflags = (cpucp_flags << 1) | HWMON_T_ENABLE;\n\t\tbreak;\n\n\tcase hwmon_in:\n\t\tflags = (cpucp_flags << 1) | HWMON_I_ENABLE;\n\t\tbreak;\n\n\tcase hwmon_curr:\n\t\tflags = (cpucp_flags << 1) | HWMON_C_ENABLE;\n\t\tbreak;\n\n\tcase hwmon_fan:\n\t\tflags = (cpucp_flags << 1) | HWMON_F_ENABLE;\n\t\tbreak;\n\n\tcase hwmon_power:\n\t\tflags = (cpucp_flags << 1) | HWMON_P_ENABLE;\n\t\tbreak;\n\n\tcase hwmon_pwm:\n\t\t \n\t\tflags = cpucp_flags;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(hdev->dev, \"unsupported h/w sensor type %d\\n\", type);\n\t\tflags = cpucp_flags;\n\t\tbreak;\n\t}\n\n\treturn flags;\n}\n\nstatic u32 fixup_attr_legacy_fw(u32 attr)\n{\n\treturn (attr - 1);\n}\n\n#else\n\nstatic u32 fixup_flags_legacy_fw(struct hl_device *hdev, enum hwmon_sensor_types type,\n\t\t\t\t\t\tu32 cpucp_flags)\n{\n\treturn cpucp_flags;\n}\n\nstatic u32 fixup_attr_legacy_fw(u32 attr)\n{\n\treturn attr;\n}\n\n#endif  \n\nstatic u32 adjust_hwmon_flags(struct hl_device *hdev, enum hwmon_sensor_types type, u32 cpucp_flags)\n{\n\tu32 flags, cpucp_input_val;\n\tbool use_cpucp_enum;\n\n\tuse_cpucp_enum = (hdev->asic_prop.fw_app_cpu_boot_dev_sts0 &\n\t\t\t\t\tCPU_BOOT_DEV_STS0_MAP_HWMON_EN) ? true : false;\n\n\t \n\tif (use_cpucp_enum) {\n\t\tswitch (type) {\n\t\tcase hwmon_temp:\n\t\t\tcpucp_input_val = cpucp_temp_input;\n\t\t\tif (cpucp_input_val == hwmon_temp_input)\n\t\t\t\tflags = cpucp_flags;\n\t\t\telse\n\t\t\t\tflags = (cpucp_flags << 1) | HWMON_T_ENABLE;\n\t\t\tbreak;\n\n\t\tcase hwmon_in:\n\t\t\tcpucp_input_val = cpucp_in_input;\n\t\t\tif (cpucp_input_val == hwmon_in_input)\n\t\t\t\tflags = cpucp_flags;\n\t\t\telse\n\t\t\t\tflags = (cpucp_flags << 1) | HWMON_I_ENABLE;\n\t\t\tbreak;\n\n\t\tcase hwmon_curr:\n\t\t\tcpucp_input_val = cpucp_curr_input;\n\t\t\tif (cpucp_input_val == hwmon_curr_input)\n\t\t\t\tflags = cpucp_flags;\n\t\t\telse\n\t\t\t\tflags = (cpucp_flags << 1) | HWMON_C_ENABLE;\n\t\t\tbreak;\n\n\t\tcase hwmon_fan:\n\t\t\tcpucp_input_val = cpucp_fan_input;\n\t\t\tif (cpucp_input_val == hwmon_fan_input)\n\t\t\t\tflags = cpucp_flags;\n\t\t\telse\n\t\t\t\tflags = (cpucp_flags << 1) | HWMON_F_ENABLE;\n\t\t\tbreak;\n\n\t\tcase hwmon_pwm:\n\t\t\t \n\t\t\tflags = cpucp_flags;\n\t\t\tbreak;\n\n\t\tcase hwmon_power:\n\t\t\tcpucp_input_val = CPUCP_POWER_INPUT;\n\t\t\tif (cpucp_input_val == hwmon_power_input)\n\t\t\t\tflags = cpucp_flags;\n\t\t\telse\n\t\t\t\tflags = (cpucp_flags << 1) | HWMON_P_ENABLE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(hdev->dev, \"unsupported h/w sensor type %d\\n\", type);\n\t\t\tflags = cpucp_flags;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tflags = fixup_flags_legacy_fw(hdev, type, cpucp_flags);\n\t}\n\n\treturn flags;\n}\n\nint hl_build_hwmon_channel_info(struct hl_device *hdev, struct cpucp_sensor *sensors_arr)\n{\n\tu32 num_sensors_for_type, flags, num_active_sensor_types = 0, arr_size = 0, *curr_arr;\n\tu32 sensors_by_type_next_index[HWMON_NR_SENSOR_TYPES] = {0};\n\tu32 *sensors_by_type[HWMON_NR_SENSOR_TYPES] = {NULL};\n\tstruct hwmon_channel_info **channels_info;\n\tu32 counts[HWMON_NR_SENSOR_TYPES] = {0};\n\tenum hwmon_sensor_types type;\n\tint rc, i, j;\n\n\tfor (i = 0 ; i < CPUCP_MAX_SENSORS ; i++) {\n\t\ttype = le32_to_cpu(sensors_arr[i].type);\n\n\t\tif ((type == 0) && (sensors_arr[i].flags == 0))\n\t\t\tbreak;\n\n\t\tif (type >= HWMON_NR_SENSOR_TYPES) {\n\t\t\tdev_err(hdev->dev, \"Got wrong sensor type %d from device\\n\", type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcounts[type]++;\n\t\tarr_size++;\n\t}\n\n\tfor (i = 0 ; i < HWMON_NR_SENSOR_TYPES ; i++) {\n\t\tif (counts[i] == 0)\n\t\t\tcontinue;\n\n\t\tnum_sensors_for_type = counts[i] + 1;\n\t\tdev_dbg(hdev->dev, \"num_sensors_for_type %d = %d\\n\", i, num_sensors_for_type);\n\n\t\tcurr_arr = kcalloc(num_sensors_for_type, sizeof(*curr_arr), GFP_KERNEL);\n\t\tif (!curr_arr) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto sensors_type_err;\n\t\t}\n\n\t\tnum_active_sensor_types++;\n\t\tsensors_by_type[i] = curr_arr;\n\t}\n\n\tfor (i = 0 ; i < arr_size ; i++) {\n\t\ttype = le32_to_cpu(sensors_arr[i].type);\n\t\tcurr_arr = sensors_by_type[type];\n\t\tflags = adjust_hwmon_flags(hdev, type, le32_to_cpu(sensors_arr[i].flags));\n\t\tcurr_arr[sensors_by_type_next_index[type]++] = flags;\n\t}\n\n\tchannels_info = kcalloc(num_active_sensor_types + 1, sizeof(struct hwmon_channel_info *),\n\t\t\t\tGFP_KERNEL);\n\tif (!channels_info) {\n\t\trc = -ENOMEM;\n\t\tgoto channels_info_array_err;\n\t}\n\n\tfor (i = 0 ; i < num_active_sensor_types ; i++) {\n\t\tchannels_info[i] = kzalloc(sizeof(*channels_info[i]), GFP_KERNEL);\n\t\tif (!channels_info[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto channel_info_err;\n\t\t}\n\t}\n\n\tfor (i = 0, j = 0 ; i < HWMON_NR_SENSOR_TYPES ; i++) {\n\t\tif (!sensors_by_type[i])\n\t\t\tcontinue;\n\n\t\tchannels_info[j]->type = i;\n\t\tchannels_info[j]->config = sensors_by_type[i];\n\t\tj++;\n\t}\n\n\thdev->hl_chip_info->info = (const struct hwmon_channel_info **)channels_info;\n\n\treturn 0;\n\nchannel_info_err:\n\tfor (i = 0 ; i < num_active_sensor_types ; i++) {\n\t\tif (channels_info[i]) {\n\t\t\tkfree(channels_info[i]->config);\n\t\t\tkfree(channels_info[i]);\n\t\t}\n\t}\n\tkfree(channels_info);\n\nchannels_info_array_err:\nsensors_type_err:\n\tfor (i = 0 ; i < HWMON_NR_SENSOR_TYPES ; i++)\n\t\tkfree(sensors_by_type[i]);\n\n\treturn rc;\n}\n\nstatic int hl_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tbool use_cpucp_enum;\n\tu32 cpucp_attr;\n\tint rc;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\tuse_cpucp_enum = (hdev->asic_prop.fw_app_cpu_boot_dev_sts0 &\n\t\t\t\t\tCPU_BOOT_DEV_STS0_MAP_HWMON_EN) ? true : false;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\tcpucp_attr = cpucp_temp_input;\n\t\t\tbreak;\n\t\tcase hwmon_temp_max:\n\t\t\tcpucp_attr = cpucp_temp_max;\n\t\t\tbreak;\n\t\tcase hwmon_temp_crit:\n\t\t\tcpucp_attr = cpucp_temp_crit;\n\t\t\tbreak;\n\t\tcase hwmon_temp_max_hyst:\n\t\t\tcpucp_attr = cpucp_temp_max_hyst;\n\t\t\tbreak;\n\t\tcase hwmon_temp_crit_hyst:\n\t\t\tcpucp_attr = cpucp_temp_crit_hyst;\n\t\t\tbreak;\n\t\tcase hwmon_temp_offset:\n\t\t\tcpucp_attr = cpucp_temp_offset;\n\t\t\tbreak;\n\t\tcase hwmon_temp_highest:\n\t\t\tcpucp_attr = cpucp_temp_highest;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (use_cpucp_enum)\n\t\t\trc = hl_get_temperature(hdev, channel, cpucp_attr, val);\n\t\telse\n\t\t\trc = hl_get_temperature(hdev, channel, fixup_attr_legacy_fw(attr), val);\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\t\tcpucp_attr = cpucp_in_input;\n\t\t\tbreak;\n\t\tcase hwmon_in_min:\n\t\t\tcpucp_attr = cpucp_in_min;\n\t\t\tbreak;\n\t\tcase hwmon_in_max:\n\t\t\tcpucp_attr = cpucp_in_max;\n\t\t\tbreak;\n\t\tcase hwmon_in_highest:\n\t\t\tcpucp_attr = cpucp_in_highest;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (use_cpucp_enum)\n\t\t\trc = hl_get_voltage(hdev, channel, cpucp_attr, val);\n\t\telse\n\t\t\trc = hl_get_voltage(hdev, channel, fixup_attr_legacy_fw(attr), val);\n\t\tbreak;\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_input:\n\t\t\tcpucp_attr = cpucp_curr_input;\n\t\t\tbreak;\n\t\tcase hwmon_curr_min:\n\t\t\tcpucp_attr = cpucp_curr_min;\n\t\t\tbreak;\n\t\tcase hwmon_curr_max:\n\t\t\tcpucp_attr = cpucp_curr_max;\n\t\t\tbreak;\n\t\tcase hwmon_curr_highest:\n\t\t\tcpucp_attr = cpucp_curr_highest;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (use_cpucp_enum)\n\t\t\trc = hl_get_current(hdev, channel, cpucp_attr, val);\n\t\telse\n\t\t\trc = hl_get_current(hdev, channel, fixup_attr_legacy_fw(attr), val);\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\t\tcpucp_attr = cpucp_fan_input;\n\t\t\tbreak;\n\t\tcase hwmon_fan_min:\n\t\t\tcpucp_attr = cpucp_fan_min;\n\t\t\tbreak;\n\t\tcase hwmon_fan_max:\n\t\t\tcpucp_attr = cpucp_fan_max;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (use_cpucp_enum)\n\t\t\trc = hl_get_fan_speed(hdev, channel, cpucp_attr, val);\n\t\telse\n\t\t\trc = hl_get_fan_speed(hdev, channel, fixup_attr_legacy_fw(attr), val);\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\tcpucp_attr = cpucp_pwm_input;\n\t\t\tbreak;\n\t\tcase hwmon_pwm_enable:\n\t\t\tcpucp_attr = cpucp_pwm_enable;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (use_cpucp_enum)\n\t\t\trc = hl_get_pwm_info(hdev, channel, cpucp_attr, val);\n\t\telse\n\t\t\t \n\t\t\trc = hl_get_pwm_info(hdev, channel, attr, val);\n\t\tbreak;\n\tcase hwmon_power:\n\t\tswitch (attr) {\n\t\tcase hwmon_power_input:\n\t\t\tcpucp_attr = CPUCP_POWER_INPUT;\n\t\t\tbreak;\n\t\tcase hwmon_power_input_highest:\n\t\t\tcpucp_attr = CPUCP_POWER_INPUT_HIGHEST;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (use_cpucp_enum)\n\t\t\trc = hl_get_power(hdev, channel, cpucp_attr, val);\n\t\telse\n\t\t\trc = hl_get_power(hdev, channel, fixup_attr_legacy_fw(attr), val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn rc;\n}\n\nstatic int hl_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long val)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tu32 cpucp_attr;\n\tbool use_cpucp_enum = (hdev->asic_prop.fw_app_cpu_boot_dev_sts0 &\n\t\t\t\tCPU_BOOT_DEV_STS0_MAP_HWMON_EN) ? true : false;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_offset:\n\t\t\tcpucp_attr = cpucp_temp_offset;\n\t\t\tbreak;\n\t\tcase hwmon_temp_reset_history:\n\t\t\tcpucp_attr = cpucp_temp_reset_history;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (use_cpucp_enum)\n\t\t\thl_set_temperature(hdev, channel, cpucp_attr, val);\n\t\telse\n\t\t\thl_set_temperature(hdev, channel, fixup_attr_legacy_fw(attr), val);\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\t\tcpucp_attr = cpucp_pwm_input;\n\t\t\tbreak;\n\t\tcase hwmon_pwm_enable:\n\t\t\tcpucp_attr = cpucp_pwm_enable;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (use_cpucp_enum)\n\t\t\thl_set_pwm_info(hdev, channel, cpucp_attr, val);\n\t\telse\n\t\t\t \n\t\t\thl_set_pwm_info(hdev, channel, attr, val);\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_reset_history:\n\t\t\tcpucp_attr = cpucp_in_reset_history;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (use_cpucp_enum)\n\t\t\thl_set_voltage(hdev, channel, cpucp_attr, val);\n\t\telse\n\t\t\thl_set_voltage(hdev, channel, fixup_attr_legacy_fw(attr), val);\n\t\tbreak;\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_reset_history:\n\t\t\tcpucp_attr = cpucp_curr_reset_history;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (use_cpucp_enum)\n\t\t\thl_set_current(hdev, channel, cpucp_attr, val);\n\t\telse\n\t\t\thl_set_current(hdev, channel, fixup_attr_legacy_fw(attr), val);\n\t\tbreak;\n\tcase hwmon_power:\n\t\tswitch (attr) {\n\t\tcase hwmon_power_reset_history:\n\t\t\tcpucp_attr = CPUCP_POWER_RESET_INPUT_HISTORY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (use_cpucp_enum)\n\t\t\thl_set_power(hdev, channel, cpucp_attr, val);\n\t\telse\n\t\t\thl_set_power(hdev, channel, fixup_attr_legacy_fw(attr), val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic umode_t hl_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\tu32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_max:\n\t\tcase hwmon_temp_max_hyst:\n\t\tcase hwmon_temp_crit:\n\t\tcase hwmon_temp_crit_hyst:\n\t\tcase hwmon_temp_highest:\n\t\t\treturn 0444;\n\t\tcase hwmon_temp_offset:\n\t\t\treturn 0644;\n\t\tcase hwmon_temp_reset_history:\n\t\t\treturn 0200;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_input:\n\t\tcase hwmon_in_min:\n\t\tcase hwmon_in_max:\n\t\tcase hwmon_in_highest:\n\t\t\treturn 0444;\n\t\tcase hwmon_in_reset_history:\n\t\t\treturn 0200;\n\t\t}\n\t\tbreak;\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_input:\n\t\tcase hwmon_curr_min:\n\t\tcase hwmon_curr_max:\n\t\tcase hwmon_curr_highest:\n\t\t\treturn 0444;\n\t\tcase hwmon_curr_reset_history:\n\t\t\treturn 0200;\n\t\t}\n\t\tbreak;\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_input:\n\t\tcase hwmon_fan_min:\n\t\tcase hwmon_fan_max:\n\t\t\treturn 0444;\n\t\t}\n\t\tbreak;\n\tcase hwmon_pwm:\n\t\tswitch (attr) {\n\t\tcase hwmon_pwm_input:\n\t\tcase hwmon_pwm_enable:\n\t\t\treturn 0644;\n\t\t}\n\t\tbreak;\n\tcase hwmon_power:\n\t\tswitch (attr) {\n\t\tcase hwmon_power_input:\n\t\tcase hwmon_power_input_highest:\n\t\t\treturn 0444;\n\t\tcase hwmon_power_reset_history:\n\t\t\treturn 0200;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_ops hl_hwmon_ops = {\n\t.is_visible = hl_is_visible,\n\t.read = hl_read,\n\t.write = hl_write\n};\n\nint hl_get_temperature(struct hl_device *hdev,\n\t\t\tint sensor_index, u32 attr, long *value)\n{\n\tstruct cpucp_packet pkt;\n\tu64 result;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_TEMPERATURE_GET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.sensor_index = __cpu_to_le16(sensor_index);\n\tpkt.type = __cpu_to_le16(attr);\n\n\tdev_dbg(hdev->dev, \"get temp, ctl 0x%x, sensor %d, type %d\\n\",\n\t\tpkt.ctl, pkt.sensor_index, pkt.type);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, &result);\n\n\t*value = (long) result;\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to get temperature from sensor %d, error %d\\n\",\n\t\t\tsensor_index, rc);\n\t\t*value = 0;\n\t}\n\n\treturn rc;\n}\n\nint hl_set_temperature(struct hl_device *hdev,\n\t\t\tint sensor_index, u32 attr, long value)\n{\n\tstruct cpucp_packet pkt;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_TEMPERATURE_SET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.sensor_index = __cpu_to_le16(sensor_index);\n\tpkt.type = __cpu_to_le16(attr);\n\tpkt.value = __cpu_to_le64(value);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, NULL);\n\n\tif (rc)\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to set temperature of sensor %d, error %d\\n\",\n\t\t\tsensor_index, rc);\n\n\treturn rc;\n}\n\nint hl_get_voltage(struct hl_device *hdev,\n\t\t\tint sensor_index, u32 attr, long *value)\n{\n\tstruct cpucp_packet pkt;\n\tu64 result;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_VOLTAGE_GET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.sensor_index = __cpu_to_le16(sensor_index);\n\tpkt.type = __cpu_to_le16(attr);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, &result);\n\n\t*value = (long) result;\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to get voltage from sensor %d, error %d\\n\",\n\t\t\tsensor_index, rc);\n\t\t*value = 0;\n\t}\n\n\treturn rc;\n}\n\nint hl_get_current(struct hl_device *hdev,\n\t\t\tint sensor_index, u32 attr, long *value)\n{\n\tstruct cpucp_packet pkt;\n\tu64 result;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_CURRENT_GET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.sensor_index = __cpu_to_le16(sensor_index);\n\tpkt.type = __cpu_to_le16(attr);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, &result);\n\n\t*value = (long) result;\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to get current from sensor %d, error %d\\n\",\n\t\t\tsensor_index, rc);\n\t\t*value = 0;\n\t}\n\n\treturn rc;\n}\n\nint hl_get_fan_speed(struct hl_device *hdev,\n\t\t\tint sensor_index, u32 attr, long *value)\n{\n\tstruct cpucp_packet pkt;\n\tu64 result;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_FAN_SPEED_GET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.sensor_index = __cpu_to_le16(sensor_index);\n\tpkt.type = __cpu_to_le16(attr);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, &result);\n\n\t*value = (long) result;\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to get fan speed from sensor %d, error %d\\n\",\n\t\t\tsensor_index, rc);\n\t\t*value = 0;\n\t}\n\n\treturn rc;\n}\n\nint hl_get_pwm_info(struct hl_device *hdev,\n\t\t\tint sensor_index, u32 attr, long *value)\n{\n\tstruct cpucp_packet pkt;\n\tu64 result;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_PWM_GET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.sensor_index = __cpu_to_le16(sensor_index);\n\tpkt.type = __cpu_to_le16(attr);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, &result);\n\n\t*value = (long) result;\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to get pwm info from sensor %d, error %d\\n\",\n\t\t\tsensor_index, rc);\n\t\t*value = 0;\n\t}\n\n\treturn rc;\n}\n\nvoid hl_set_pwm_info(struct hl_device *hdev, int sensor_index, u32 attr,\n\t\t\tlong value)\n{\n\tstruct cpucp_packet pkt;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_PWM_SET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.sensor_index = __cpu_to_le16(sensor_index);\n\tpkt.type = __cpu_to_le16(attr);\n\tpkt.value = cpu_to_le64(value);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, NULL);\n\n\tif (rc)\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to set pwm info to sensor %d, error %d\\n\",\n\t\t\tsensor_index, rc);\n}\n\nint hl_set_voltage(struct hl_device *hdev,\n\t\t\tint sensor_index, u32 attr, long value)\n{\n\tstruct cpucp_packet pkt;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_VOLTAGE_SET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.sensor_index = __cpu_to_le16(sensor_index);\n\tpkt.type = __cpu_to_le16(attr);\n\tpkt.value = __cpu_to_le64(value);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, NULL);\n\n\tif (rc)\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to set voltage of sensor %d, error %d\\n\",\n\t\t\tsensor_index, rc);\n\n\treturn rc;\n}\n\nint hl_set_current(struct hl_device *hdev,\n\t\t\tint sensor_index, u32 attr, long value)\n{\n\tstruct cpucp_packet pkt;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_CURRENT_SET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.sensor_index = __cpu_to_le16(sensor_index);\n\tpkt.type = __cpu_to_le16(attr);\n\tpkt.value = __cpu_to_le64(value);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, NULL);\n\n\tif (rc)\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to set current of sensor %d, error %d\\n\",\n\t\t\tsensor_index, rc);\n\n\treturn rc;\n}\n\nint hl_set_power(struct hl_device *hdev,\n\t\t\tint sensor_index, u32 attr, long value)\n{\n\tstruct cpucp_packet pkt;\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tif (prop->use_get_power_for_reset_history)\n\t\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_POWER_GET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\telse\n\t\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_POWER_SET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\n\tpkt.sensor_index = __cpu_to_le16(sensor_index);\n\tpkt.type = __cpu_to_le16(attr);\n\tpkt.value = __cpu_to_le64(value);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, NULL);\n\n\tif (rc)\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to set power of sensor %d, error %d\\n\",\n\t\t\tsensor_index, rc);\n\n\treturn rc;\n}\n\nint hl_get_power(struct hl_device *hdev,\n\t\t\tint sensor_index, u32 attr, long *value)\n{\n\tstruct cpucp_packet pkt;\n\tu64 result;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_POWER_GET <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.sensor_index = __cpu_to_le16(sensor_index);\n\tpkt.type = __cpu_to_le16(attr);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, &result);\n\n\t*value = (long) result;\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to get power of sensor %d, error %d\\n\",\n\t\t\tsensor_index, rc);\n\t\t*value = 0;\n\t}\n\n\treturn rc;\n}\n\nint hl_hwmon_init(struct hl_device *hdev)\n{\n\tstruct device *dev = hdev->pdev ? &hdev->pdev->dev : hdev->dev;\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tint rc;\n\n\tif ((hdev->hwmon_initialized) || !(hdev->cpu_queues_enable))\n\t\treturn 0;\n\n\tif (hdev->hl_chip_info->info) {\n\t\thdev->hl_chip_info->ops = &hl_hwmon_ops;\n\n\t\thdev->hwmon_dev = hwmon_device_register_with_info(dev,\n\t\t\t\t\tprop->cpucp_info.card_name, hdev,\n\t\t\t\t\thdev->hl_chip_info, NULL);\n\t\tif (IS_ERR(hdev->hwmon_dev)) {\n\t\t\trc = PTR_ERR(hdev->hwmon_dev);\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Unable to register hwmon device: %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tdev_info(hdev->dev, \"%s: add sensors information\\n\",\n\t\t\tdev_name(hdev->hwmon_dev));\n\n\t\thdev->hwmon_initialized = true;\n\t} else {\n\t\tdev_info(hdev->dev, \"no available sensors\\n\");\n\t}\n\n\treturn 0;\n}\n\nvoid hl_hwmon_fini(struct hl_device *hdev)\n{\n\tif (!hdev->hwmon_initialized)\n\t\treturn;\n\n\thwmon_device_unregister(hdev->hwmon_dev);\n}\n\nvoid hl_hwmon_release_resources(struct hl_device *hdev)\n{\n\tconst struct hwmon_channel_info * const *channel_info_arr;\n\tint i = 0;\n\n\tif (!hdev->hl_chip_info->info)\n\t\treturn;\n\n\tchannel_info_arr = hdev->hl_chip_info->info;\n\n\twhile (channel_info_arr[i]) {\n\t\tkfree(channel_info_arr[i]->config);\n\t\tkfree(channel_info_arr[i]);\n\t\ti++;\n\t}\n\n\tkfree(channel_info_arr);\n\n\thdev->hl_chip_info->info = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}