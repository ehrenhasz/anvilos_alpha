{
  "module_name": "gaudi_coresight.c",
  "hash_id": "ba5af65b7c9a21e0e5949015b5516961930a94cd5c826565031cb59a59d822bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/gaudi/gaudi_coresight.c",
  "human_readable_source": "\n\n \n\n#include \"gaudiP.h\"\n#include \"../include/gaudi/gaudi_coresight.h\"\n#include \"../include/gaudi/asic_reg/gaudi_regs.h\"\n#include \"../include/gaudi/gaudi_masks.h\"\n#include \"../include/gaudi/gaudi_reg_map.h\"\n\n#include <uapi/drm/habanalabs_accel.h>\n\n#define SPMU_SECTION_SIZE\t\tMME0_ACC_SPMU_MAX_OFFSET\n#define SPMU_EVENT_TYPES_OFFSET\t\t0x400\n#define SPMU_MAX_COUNTERS\t\t6\n\nstatic u64 debug_stm_regs[GAUDI_STM_LAST + 1] = {\n\t[GAUDI_STM_MME0_ACC]\t= mmMME0_ACC_STM_BASE,\n\t[GAUDI_STM_MME0_SBAB]\t= mmMME0_SBAB_STM_BASE,\n\t[GAUDI_STM_MME0_CTRL]\t= mmMME0_CTRL_STM_BASE,\n\t[GAUDI_STM_MME1_ACC]\t= mmMME1_ACC_STM_BASE,\n\t[GAUDI_STM_MME1_SBAB]\t= mmMME1_SBAB_STM_BASE,\n\t[GAUDI_STM_MME1_CTRL]\t= mmMME1_CTRL_STM_BASE,\n\t[GAUDI_STM_MME2_ACC]\t= mmMME2_ACC_STM_BASE,\n\t[GAUDI_STM_MME2_SBAB]\t= mmMME2_SBAB_STM_BASE,\n\t[GAUDI_STM_MME2_CTRL]\t= mmMME2_CTRL_STM_BASE,\n\t[GAUDI_STM_MME3_ACC]\t= mmMME3_ACC_STM_BASE,\n\t[GAUDI_STM_MME3_SBAB]\t= mmMME3_SBAB_STM_BASE,\n\t[GAUDI_STM_MME3_CTRL]\t= mmMME3_CTRL_STM_BASE,\n\t[GAUDI_STM_DMA_IF_W_S]\t= mmDMA_IF_W_S_STM_BASE,\n\t[GAUDI_STM_DMA_IF_E_S]\t= mmDMA_IF_E_S_STM_BASE,\n\t[GAUDI_STM_DMA_IF_W_N]\t= mmDMA_IF_W_N_STM_BASE,\n\t[GAUDI_STM_DMA_IF_E_N]\t= mmDMA_IF_E_N_STM_BASE,\n\t[GAUDI_STM_CPU]\t\t= mmCPU_STM_BASE,\n\t[GAUDI_STM_DMA_CH_0_CS]\t= mmDMA_CH_0_CS_STM_BASE,\n\t[GAUDI_STM_DMA_CH_1_CS]\t= mmDMA_CH_1_CS_STM_BASE,\n\t[GAUDI_STM_DMA_CH_2_CS]\t= mmDMA_CH_2_CS_STM_BASE,\n\t[GAUDI_STM_DMA_CH_3_CS]\t= mmDMA_CH_3_CS_STM_BASE,\n\t[GAUDI_STM_DMA_CH_4_CS]\t= mmDMA_CH_4_CS_STM_BASE,\n\t[GAUDI_STM_DMA_CH_5_CS]\t= mmDMA_CH_5_CS_STM_BASE,\n\t[GAUDI_STM_DMA_CH_6_CS]\t= mmDMA_CH_6_CS_STM_BASE,\n\t[GAUDI_STM_DMA_CH_7_CS]\t= mmDMA_CH_7_CS_STM_BASE,\n\t[GAUDI_STM_PCIE]\t= mmPCIE_STM_BASE,\n\t[GAUDI_STM_MMU_CS]\t= mmMMU_CS_STM_BASE,\n\t[GAUDI_STM_PSOC]\t= mmPSOC_STM_BASE,\n\t[GAUDI_STM_NIC0_0]\t= mmSTM_0_NIC0_DBG_BASE,\n\t[GAUDI_STM_NIC0_1]\t= mmSTM_1_NIC0_DBG_BASE,\n\t[GAUDI_STM_NIC1_0]\t= mmSTM_0_NIC1_DBG_BASE,\n\t[GAUDI_STM_NIC1_1]\t= mmSTM_1_NIC1_DBG_BASE,\n\t[GAUDI_STM_NIC2_0]\t= mmSTM_0_NIC2_DBG_BASE,\n\t[GAUDI_STM_NIC2_1]\t= mmSTM_1_NIC2_DBG_BASE,\n\t[GAUDI_STM_NIC3_0]\t= mmSTM_0_NIC3_DBG_BASE,\n\t[GAUDI_STM_NIC3_1]\t= mmSTM_1_NIC3_DBG_BASE,\n\t[GAUDI_STM_NIC4_0]\t= mmSTM_0_NIC4_DBG_BASE,\n\t[GAUDI_STM_NIC4_1]\t= mmSTM_1_NIC4_DBG_BASE,\n\t[GAUDI_STM_TPC0_EML]\t= mmTPC0_EML_STM_BASE,\n\t[GAUDI_STM_TPC1_EML]\t= mmTPC1_EML_STM_BASE,\n\t[GAUDI_STM_TPC2_EML]\t= mmTPC2_EML_STM_BASE,\n\t[GAUDI_STM_TPC3_EML]\t= mmTPC3_EML_STM_BASE,\n\t[GAUDI_STM_TPC4_EML]\t= mmTPC4_EML_STM_BASE,\n\t[GAUDI_STM_TPC5_EML]\t= mmTPC5_EML_STM_BASE,\n\t[GAUDI_STM_TPC6_EML]\t= mmTPC6_EML_STM_BASE,\n\t[GAUDI_STM_TPC7_EML]\t= mmTPC7_EML_STM_BASE\n};\n\nstatic u64 debug_etf_regs[GAUDI_ETF_LAST + 1] = {\n\t[GAUDI_ETF_MME0_ACC]\t\t= mmMME0_ACC_ETF_BASE,\n\t[GAUDI_ETF_MME0_SBAB]\t\t= mmMME0_SBAB_ETF_BASE,\n\t[GAUDI_ETF_MME0_CTRL]\t\t= mmMME0_CTRL_ETF_BASE,\n\t[GAUDI_ETF_MME1_ACC]\t\t= mmMME1_ACC_ETF_BASE,\n\t[GAUDI_ETF_MME1_SBAB]\t\t= mmMME1_SBAB_ETF_BASE,\n\t[GAUDI_ETF_MME1_CTRL]\t\t= mmMME1_CTRL_ETF_BASE,\n\t[GAUDI_ETF_MME2_ACC]\t\t= mmMME2_MME2_ACC_ETF_BASE,\n\t[GAUDI_ETF_MME2_SBAB]\t\t= mmMME2_SBAB_ETF_BASE,\n\t[GAUDI_ETF_MME2_CTRL]\t\t= mmMME2_CTRL_ETF_BASE,\n\t[GAUDI_ETF_MME3_ACC]\t\t= mmMME3_ACC_ETF_BASE,\n\t[GAUDI_ETF_MME3_SBAB]\t\t= mmMME3_SBAB_ETF_BASE,\n\t[GAUDI_ETF_MME3_CTRL]\t\t= mmMME3_CTRL_ETF_BASE,\n\t[GAUDI_ETF_DMA_IF_W_S]\t\t= mmDMA_IF_W_S_ETF_BASE,\n\t[GAUDI_ETF_DMA_IF_E_S]\t\t= mmDMA_IF_E_S_ETF_BASE,\n\t[GAUDI_ETF_DMA_IF_W_N]\t\t= mmDMA_IF_W_N_ETF_BASE,\n\t[GAUDI_ETF_DMA_IF_E_N]\t\t= mmDMA_IF_E_N_ETF_BASE,\n\t[GAUDI_ETF_CPU_0]\t\t= mmCPU_ETF_0_BASE,\n\t[GAUDI_ETF_CPU_1]\t\t= mmCPU_ETF_1_BASE,\n\t[GAUDI_ETF_CPU_TRACE]\t\t= mmCPU_ETF_TRACE_BASE,\n\t[GAUDI_ETF_DMA_CH_0_CS]\t\t= mmDMA_CH_0_CS_ETF_BASE,\n\t[GAUDI_ETF_DMA_CH_1_CS]\t\t= mmDMA_CH_1_CS_ETF_BASE,\n\t[GAUDI_ETF_DMA_CH_2_CS]\t\t= mmDMA_CH_2_CS_ETF_BASE,\n\t[GAUDI_ETF_DMA_CH_3_CS]\t\t= mmDMA_CH_3_CS_ETF_BASE,\n\t[GAUDI_ETF_DMA_CH_4_CS]\t\t= mmDMA_CH_4_CS_ETF_BASE,\n\t[GAUDI_ETF_DMA_CH_5_CS]\t\t= mmDMA_CH_5_CS_ETF_BASE,\n\t[GAUDI_ETF_DMA_CH_6_CS]\t\t= mmDMA_CH_6_CS_ETF_BASE,\n\t[GAUDI_ETF_DMA_CH_7_CS]\t\t= mmDMA_CH_7_CS_ETF_BASE,\n\t[GAUDI_ETF_PCIE]\t\t= mmPCIE_ETF_BASE,\n\t[GAUDI_ETF_MMU_CS]\t\t= mmMMU_CS_ETF_BASE,\n\t[GAUDI_ETF_PSOC]\t\t= mmPSOC_ETF_BASE,\n\t[GAUDI_ETF_NIC0_0]\t\t= mmETF_0_NIC0_DBG_BASE,\n\t[GAUDI_ETF_NIC0_1]\t\t= mmETF_1_NIC0_DBG_BASE,\n\t[GAUDI_ETF_NIC1_0]\t\t= mmETF_0_NIC1_DBG_BASE,\n\t[GAUDI_ETF_NIC1_1]\t\t= mmETF_1_NIC1_DBG_BASE,\n\t[GAUDI_ETF_NIC2_0]\t\t= mmETF_0_NIC2_DBG_BASE,\n\t[GAUDI_ETF_NIC2_1]\t\t= mmETF_1_NIC2_DBG_BASE,\n\t[GAUDI_ETF_NIC3_0]\t\t= mmETF_0_NIC3_DBG_BASE,\n\t[GAUDI_ETF_NIC3_1]\t\t= mmETF_1_NIC3_DBG_BASE,\n\t[GAUDI_ETF_NIC4_0]\t\t= mmETF_0_NIC4_DBG_BASE,\n\t[GAUDI_ETF_NIC4_1]\t\t= mmETF_1_NIC4_DBG_BASE,\n\t[GAUDI_ETF_TPC0_EML]\t\t= mmTPC0_EML_ETF_BASE,\n\t[GAUDI_ETF_TPC1_EML]\t\t= mmTPC1_EML_ETF_BASE,\n\t[GAUDI_ETF_TPC2_EML]\t\t= mmTPC2_EML_ETF_BASE,\n\t[GAUDI_ETF_TPC3_EML]\t\t= mmTPC3_EML_ETF_BASE,\n\t[GAUDI_ETF_TPC4_EML]\t\t= mmTPC4_EML_ETF_BASE,\n\t[GAUDI_ETF_TPC5_EML]\t\t= mmTPC5_EML_ETF_BASE,\n\t[GAUDI_ETF_TPC6_EML]\t\t= mmTPC6_EML_ETF_BASE,\n\t[GAUDI_ETF_TPC7_EML]\t\t= mmTPC7_EML_ETF_BASE\n};\n\nstatic u64 debug_funnel_regs[GAUDI_FUNNEL_LAST + 1] = {\n\t[GAUDI_FUNNEL_MME0_ACC]\t\t= mmMME0_ACC_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_MME1_ACC]\t\t= mmMME1_ACC_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_MME2_ACC]\t\t= mmMME2_ACC_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_MME3_ACC]\t\t= mmMME3_ACC_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y0_X0]\t= mmSRAM_Y0_X0_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y0_X1]\t= mmSRAM_Y0_X1_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y0_X2]\t= mmSRAM_Y0_X2_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y0_X3]\t= mmSRAM_Y0_X3_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y0_X4]\t= mmSRAM_Y0_X4_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y0_X5]\t= mmSRAM_Y0_X5_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y0_X6]\t= mmSRAM_Y0_X6_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y0_X7]\t= mmSRAM_Y0_X7_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y1_X0]\t= mmSRAM_Y1_X0_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y1_X1]\t= mmSRAM_Y1_X1_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y1_X2]\t= mmSRAM_Y1_X2_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y1_X3]\t= mmSRAM_Y1_X3_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y1_X4]\t= mmSRAM_Y1_X4_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y1_X5]\t= mmSRAM_Y1_X5_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y1_X6]\t= mmSRAM_Y1_X6_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y1_X7]\t= mmSRAM_Y1_X7_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y2_X0]\t= mmSRAM_Y2_X0_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y2_X1]\t= mmSRAM_Y2_X1_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y2_X2]\t= mmSRAM_Y2_X2_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y2_X3]\t= mmSRAM_Y2_X3_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y2_X4]\t= mmSRAM_Y2_X4_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y2_X5]\t= mmSRAM_Y2_X5_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y2_X6]\t= mmSRAM_Y2_X6_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y2_X7]\t= mmSRAM_Y2_X7_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y3_X0]\t= mmSRAM_Y3_X0_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y3_X1]\t= mmSRAM_Y3_X1_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y3_X2]\t= mmSRAM_Y3_X2_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y3_X4]\t= mmSRAM_Y3_X4_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y3_X3]\t= mmSRAM_Y3_X3_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y3_X5]\t= mmSRAM_Y3_X5_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y3_X6]\t= mmSRAM_Y3_X6_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SRAM_Y3_X7]\t= mmSRAM_Y3_X7_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_SIF_0]\t\t= mmSIF_FUNNEL_0_BASE,\n\t[GAUDI_FUNNEL_SIF_1]\t\t= mmSIF_FUNNEL_1_BASE,\n\t[GAUDI_FUNNEL_SIF_2]\t\t= mmSIF_FUNNEL_2_BASE,\n\t[GAUDI_FUNNEL_SIF_3]\t\t= mmSIF_FUNNEL_3_BASE,\n\t[GAUDI_FUNNEL_SIF_4]\t\t= mmSIF_FUNNEL_4_BASE,\n\t[GAUDI_FUNNEL_SIF_5]\t\t= mmSIF_FUNNEL_5_BASE,\n\t[GAUDI_FUNNEL_SIF_6]\t\t= mmSIF_FUNNEL_6_BASE,\n\t[GAUDI_FUNNEL_SIF_7]\t\t= mmSIF_FUNNEL_7_BASE,\n\t[GAUDI_FUNNEL_NIF_0]\t\t= mmNIF_FUNNEL_0_BASE,\n\t[GAUDI_FUNNEL_NIF_1]\t\t= mmNIF_FUNNEL_1_BASE,\n\t[GAUDI_FUNNEL_NIF_2]\t\t= mmNIF_FUNNEL_2_BASE,\n\t[GAUDI_FUNNEL_NIF_3]\t\t= mmNIF_FUNNEL_3_BASE,\n\t[GAUDI_FUNNEL_NIF_4]\t\t= mmNIF_FUNNEL_4_BASE,\n\t[GAUDI_FUNNEL_NIF_5]\t\t= mmNIF_FUNNEL_5_BASE,\n\t[GAUDI_FUNNEL_NIF_6]\t\t= mmNIF_FUNNEL_6_BASE,\n\t[GAUDI_FUNNEL_NIF_7]\t\t= mmNIF_FUNNEL_7_BASE,\n\t[GAUDI_FUNNEL_DMA_IF_W_S]\t= mmDMA_IF_W_S_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_DMA_IF_E_S]\t= mmDMA_IF_E_S_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_DMA_IF_W_N]\t= mmDMA_IF_W_N_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_DMA_IF_E_N]\t= mmDMA_IF_E_N_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_CPU]\t\t= mmCPU_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_NIC_TPC_W_S]\t= mmNIC_TPC_FUNNEL_W_S_BASE,\n\t[GAUDI_FUNNEL_NIC_TPC_E_S]\t= mmNIC_TPC_FUNNEL_E_S_BASE,\n\t[GAUDI_FUNNEL_NIC_TPC_W_N]\t= mmNIC_TPC_FUNNEL_W_N_BASE,\n\t[GAUDI_FUNNEL_NIC_TPC_E_N]\t= mmNIC_TPC_FUNNEL_E_N_BASE,\n\t[GAUDI_FUNNEL_PCIE]\t\t= mmPCIE_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_PSOC]\t\t= mmPSOC_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_NIC0]\t\t= mmFUNNEL_NIC0_DBG_BASE,\n\t[GAUDI_FUNNEL_NIC1]\t\t= mmFUNNEL_NIC1_DBG_BASE,\n\t[GAUDI_FUNNEL_NIC2]\t\t= mmFUNNEL_NIC2_DBG_BASE,\n\t[GAUDI_FUNNEL_NIC3]\t\t= mmFUNNEL_NIC3_DBG_BASE,\n\t[GAUDI_FUNNEL_NIC4]\t\t= mmFUNNEL_NIC4_DBG_BASE,\n\t[GAUDI_FUNNEL_TPC0_EML]\t\t= mmTPC0_EML_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_TPC1_EML]\t\t= mmTPC1_EML_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_TPC2_EML]\t\t= mmTPC2_EML_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_TPC3_EML]\t\t= mmTPC3_EML_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_TPC4_EML]\t\t= mmTPC4_EML_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_TPC5_EML]\t\t= mmTPC5_EML_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_TPC6_EML]\t\t= mmTPC6_EML_FUNNEL_BASE,\n\t[GAUDI_FUNNEL_TPC7_EML]\t\t= mmTPC7_EML_FUNNEL_BASE\n};\n\nstatic u64 debug_bmon_regs[GAUDI_BMON_LAST + 1] = {\n\t[GAUDI_BMON_MME0_ACC_0]\t\t= mmMME0_ACC_BMON0_BASE,\n\t[GAUDI_BMON_MME0_SBAB_0]\t= mmMME0_SBAB_BMON0_BASE,\n\t[GAUDI_BMON_MME0_SBAB_1]\t= mmMME0_SBAB_BMON1_BASE,\n\t[GAUDI_BMON_MME0_CTRL_0]\t= mmMME0_CTRL_BMON0_BASE,\n\t[GAUDI_BMON_MME0_CTRL_1]\t= mmMME0_CTRL_BMON1_BASE,\n\t[GAUDI_BMON_MME1_ACC_0]\t\t= mmMME1_ACC_BMON0_BASE,\n\t[GAUDI_BMON_MME1_SBAB_0]\t= mmMME1_SBAB_BMON0_BASE,\n\t[GAUDI_BMON_MME1_SBAB_1]\t= mmMME1_SBAB_BMON1_BASE,\n\t[GAUDI_BMON_MME1_CTRL_0]\t= mmMME1_CTRL_BMON0_BASE,\n\t[GAUDI_BMON_MME1_CTRL_1]\t= mmMME1_CTRL_BMON1_BASE,\n\t[GAUDI_BMON_MME2_ACC_0]\t\t= mmMME2_ACC_BMON0_BASE,\n\t[GAUDI_BMON_MME2_SBAB_0]\t= mmMME2_SBAB_BMON0_BASE,\n\t[GAUDI_BMON_MME2_SBAB_1]\t= mmMME2_SBAB_BMON1_BASE,\n\t[GAUDI_BMON_MME2_CTRL_0]\t= mmMME2_CTRL_BMON0_BASE,\n\t[GAUDI_BMON_MME2_CTRL_1]\t= mmMME2_CTRL_BMON1_BASE,\n\t[GAUDI_BMON_MME3_ACC_0]\t\t= mmMME3_ACC_BMON0_BASE,\n\t[GAUDI_BMON_MME3_SBAB_0]\t= mmMME3_SBAB_BMON0_BASE,\n\t[GAUDI_BMON_MME3_SBAB_1]\t= mmMME3_SBAB_BMON1_BASE,\n\t[GAUDI_BMON_MME3_CTRL_0]\t= mmMME3_CTRL_BMON0_BASE,\n\t[GAUDI_BMON_MME3_CTRL_1]\t= mmMME3_CTRL_BMON1_BASE,\n\t[GAUDI_BMON_DMA_IF_W_S_SOB_WR]\t= mmDMA_IF_W_S_SOB_WR_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_W_S_0_WR]\t= mmDMA_IF_W_S_HBM0_WR_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_W_S_0_RD]\t= mmDMA_IF_W_S_HBM0_RD_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_W_S_1_WR]\t= mmDMA_IF_W_S_HBM1_WR_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_W_S_1_RD]\t= mmDMA_IF_W_S_HBM1_RD_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_E_S_SOB_WR]\t= mmDMA_IF_E_S_SOB_WR_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_E_S_0_WR]\t= mmDMA_IF_E_S_HBM0_WR_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_E_S_0_RD]\t= mmDMA_IF_E_S_HBM0_RD_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_E_S_1_WR]\t= mmDMA_IF_E_S_HBM1_WR_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_E_S_1_RD]\t= mmDMA_IF_E_S_HBM1_RD_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_W_N_SOB_WR]\t= mmDMA_IF_W_N_SOB_WR_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_W_N_HBM0_WR]\t= mmDMA_IF_W_N_HBM0_WR_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_W_N_HBM0_RD]\t= mmDMA_IF_W_N_HBM0_RD_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_W_N_HBM1_WR]\t= mmDMA_IF_W_N_HBM1_WR_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_W_N_HBM1_RD]\t= mmDMA_IF_W_N_HBM1_RD_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_E_N_SOB_WR]\t= mmDMA_IF_E_N_SOB_WR_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_E_N_HBM0_WR]\t= mmDMA_IF_E_N_HBM0_WR_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_E_N_HBM0_RD]\t= mmDMA_IF_E_N_HBM0_RD_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_E_N_HBM1_WR]\t= mmDMA_IF_E_N_HBM1_WR_BMON_BASE,\n\t[GAUDI_BMON_DMA_IF_E_N_HBM1_RD]\t= mmDMA_IF_E_N_HBM1_RD_BMON_BASE,\n\t[GAUDI_BMON_CPU_WR]\t\t= mmCPU_WR_BMON_BASE,\n\t[GAUDI_BMON_CPU_RD]\t\t= mmCPU_RD_BMON_BASE,\n\t[GAUDI_BMON_DMA_CH_0_0]\t\t= mmDMA_CH_0_BMON_0_BASE,\n\t[GAUDI_BMON_DMA_CH_0_1]\t\t= mmDMA_CH_0_BMON_1_BASE,\n\t[GAUDI_BMON_DMA_CH_1_0]\t\t= mmDMA_CH_1_BMON_0_BASE,\n\t[GAUDI_BMON_DMA_CH_1_1]\t\t= mmDMA_CH_1_BMON_1_BASE,\n\t[GAUDI_BMON_DMA_CH_2_0]\t\t= mmDMA_CH_2_BMON_0_BASE,\n\t[GAUDI_BMON_DMA_CH_2_1]\t\t= mmDMA_CH_2_BMON_1_BASE,\n\t[GAUDI_BMON_DMA_CH_3_0]\t\t= mmDMA_CH_3_BMON_0_BASE,\n\t[GAUDI_BMON_DMA_CH_3_1]\t\t= mmDMA_CH_3_BMON_1_BASE,\n\t[GAUDI_BMON_DMA_CH_4_0]\t\t= mmDMA_CH_4_BMON_0_BASE,\n\t[GAUDI_BMON_DMA_CH_4_1]\t\t= mmDMA_CH_4_BMON_1_BASE,\n\t[GAUDI_BMON_DMA_CH_5_0]\t\t= mmDMA_CH_5_BMON_0_BASE,\n\t[GAUDI_BMON_DMA_CH_5_1]\t\t= mmDMA_CH_5_BMON_1_BASE,\n\t[GAUDI_BMON_DMA_CH_6_0]\t\t= mmDMA_CH_6_BMON_0_BASE,\n\t[GAUDI_BMON_DMA_CH_6_1]\t\t= mmDMA_CH_6_BMON_1_BASE,\n\t[GAUDI_BMON_DMA_CH_7_0]\t\t= mmDMA_CH_7_BMON_0_BASE,\n\t[GAUDI_BMON_DMA_CH_7_1]\t\t= mmDMA_CH_7_BMON_1_BASE,\n\t[GAUDI_BMON_PCIE_MSTR_WR]\t= mmPCIE_BMON_MSTR_WR_BASE,\n\t[GAUDI_BMON_PCIE_MSTR_RD]\t= mmPCIE_BMON_MSTR_RD_BASE,\n\t[GAUDI_BMON_PCIE_SLV_WR]\t= mmPCIE_BMON_SLV_WR_BASE,\n\t[GAUDI_BMON_PCIE_SLV_RD]\t= mmPCIE_BMON_SLV_RD_BASE,\n\t[GAUDI_BMON_MMU_0]\t\t= mmMMU_BMON_0_BASE,\n\t[GAUDI_BMON_MMU_1]\t\t= mmMMU_BMON_1_BASE,\n\t[GAUDI_BMON_NIC0_0]\t\t= mmBMON0_NIC0_DBG_BASE,\n\t[GAUDI_BMON_NIC0_1]\t\t= mmBMON1_NIC0_DBG_BASE,\n\t[GAUDI_BMON_NIC0_2]\t\t= mmBMON2_NIC0_DBG_BASE,\n\t[GAUDI_BMON_NIC0_3]\t\t= mmBMON3_NIC0_DBG_BASE,\n\t[GAUDI_BMON_NIC0_4]\t\t= mmBMON4_NIC0_DBG_BASE,\n\t[GAUDI_BMON_NIC1_0]\t\t= mmBMON0_NIC1_DBG_BASE,\n\t[GAUDI_BMON_NIC1_1]\t\t= mmBMON1_NIC1_DBG_BASE,\n\t[GAUDI_BMON_NIC1_2]\t\t= mmBMON2_NIC1_DBG_BASE,\n\t[GAUDI_BMON_NIC1_3]\t\t= mmBMON3_NIC1_DBG_BASE,\n\t[GAUDI_BMON_NIC1_4]\t\t= mmBMON4_NIC1_DBG_BASE,\n\t[GAUDI_BMON_NIC2_0]\t\t= mmBMON0_NIC2_DBG_BASE,\n\t[GAUDI_BMON_NIC2_1]\t\t= mmBMON1_NIC2_DBG_BASE,\n\t[GAUDI_BMON_NIC2_2]\t\t= mmBMON2_NIC2_DBG_BASE,\n\t[GAUDI_BMON_NIC2_3]\t\t= mmBMON3_NIC2_DBG_BASE,\n\t[GAUDI_BMON_NIC2_4]\t\t= mmBMON4_NIC2_DBG_BASE,\n\t[GAUDI_BMON_NIC3_0]\t\t= mmBMON0_NIC3_DBG_BASE,\n\t[GAUDI_BMON_NIC3_1]\t\t= mmBMON1_NIC3_DBG_BASE,\n\t[GAUDI_BMON_NIC3_2]\t\t= mmBMON2_NIC3_DBG_BASE,\n\t[GAUDI_BMON_NIC3_3]\t\t= mmBMON3_NIC3_DBG_BASE,\n\t[GAUDI_BMON_NIC3_4]\t\t= mmBMON4_NIC3_DBG_BASE,\n\t[GAUDI_BMON_NIC4_0]\t\t= mmBMON0_NIC4_DBG_BASE,\n\t[GAUDI_BMON_NIC4_1]\t\t= mmBMON1_NIC4_DBG_BASE,\n\t[GAUDI_BMON_NIC4_2]\t\t= mmBMON2_NIC4_DBG_BASE,\n\t[GAUDI_BMON_NIC4_3]\t\t= mmBMON3_NIC4_DBG_BASE,\n\t[GAUDI_BMON_NIC4_4]\t\t= mmBMON4_NIC4_DBG_BASE,\n\t[GAUDI_BMON_TPC0_EML_0]\t\t= mmTPC0_EML_BUSMON_0_BASE,\n\t[GAUDI_BMON_TPC0_EML_1]\t\t= mmTPC0_EML_BUSMON_1_BASE,\n\t[GAUDI_BMON_TPC0_EML_2]\t\t= mmTPC0_EML_BUSMON_2_BASE,\n\t[GAUDI_BMON_TPC0_EML_3]\t\t= mmTPC0_EML_BUSMON_3_BASE,\n\t[GAUDI_BMON_TPC1_EML_0]\t\t= mmTPC1_EML_BUSMON_0_BASE,\n\t[GAUDI_BMON_TPC1_EML_1]\t\t= mmTPC1_EML_BUSMON_1_BASE,\n\t[GAUDI_BMON_TPC1_EML_2]\t\t= mmTPC1_EML_BUSMON_2_BASE,\n\t[GAUDI_BMON_TPC1_EML_3]\t\t= mmTPC1_EML_BUSMON_3_BASE,\n\t[GAUDI_BMON_TPC2_EML_0]\t\t= mmTPC2_EML_BUSMON_0_BASE,\n\t[GAUDI_BMON_TPC2_EML_1]\t\t= mmTPC2_EML_BUSMON_1_BASE,\n\t[GAUDI_BMON_TPC2_EML_2]\t\t= mmTPC2_EML_BUSMON_2_BASE,\n\t[GAUDI_BMON_TPC2_EML_3]\t\t= mmTPC2_EML_BUSMON_3_BASE,\n\t[GAUDI_BMON_TPC3_EML_0]\t\t= mmTPC3_EML_BUSMON_0_BASE,\n\t[GAUDI_BMON_TPC3_EML_1]\t\t= mmTPC3_EML_BUSMON_1_BASE,\n\t[GAUDI_BMON_TPC3_EML_2]\t\t= mmTPC3_EML_BUSMON_2_BASE,\n\t[GAUDI_BMON_TPC3_EML_3]\t\t= mmTPC3_EML_BUSMON_3_BASE,\n\t[GAUDI_BMON_TPC4_EML_0]\t\t= mmTPC4_EML_BUSMON_0_BASE,\n\t[GAUDI_BMON_TPC4_EML_1]\t\t= mmTPC4_EML_BUSMON_1_BASE,\n\t[GAUDI_BMON_TPC4_EML_2]\t\t= mmTPC4_EML_BUSMON_2_BASE,\n\t[GAUDI_BMON_TPC4_EML_3]\t\t= mmTPC4_EML_BUSMON_3_BASE,\n\t[GAUDI_BMON_TPC5_EML_0]\t\t= mmTPC5_EML_BUSMON_0_BASE,\n\t[GAUDI_BMON_TPC5_EML_1]\t\t= mmTPC5_EML_BUSMON_1_BASE,\n\t[GAUDI_BMON_TPC5_EML_2]\t\t= mmTPC5_EML_BUSMON_2_BASE,\n\t[GAUDI_BMON_TPC5_EML_3]\t\t= mmTPC5_EML_BUSMON_3_BASE,\n\t[GAUDI_BMON_TPC6_EML_0]\t\t= mmTPC6_EML_BUSMON_0_BASE,\n\t[GAUDI_BMON_TPC6_EML_1]\t\t= mmTPC6_EML_BUSMON_1_BASE,\n\t[GAUDI_BMON_TPC6_EML_2]\t\t= mmTPC6_EML_BUSMON_2_BASE,\n\t[GAUDI_BMON_TPC6_EML_3]\t\t= mmTPC6_EML_BUSMON_3_BASE,\n\t[GAUDI_BMON_TPC7_EML_0]\t\t= mmTPC7_EML_BUSMON_0_BASE,\n\t[GAUDI_BMON_TPC7_EML_1]\t\t= mmTPC7_EML_BUSMON_1_BASE,\n\t[GAUDI_BMON_TPC7_EML_2]\t\t= mmTPC7_EML_BUSMON_2_BASE,\n\t[GAUDI_BMON_TPC7_EML_3]\t\t= mmTPC7_EML_BUSMON_3_BASE\n};\n\nstatic u64 debug_spmu_regs[GAUDI_SPMU_LAST + 1] = {\n\t[GAUDI_SPMU_MME0_ACC]\t\t= mmMME0_ACC_SPMU_BASE,\n\t[GAUDI_SPMU_MME0_SBAB]\t\t= mmMME0_SBAB_SPMU_BASE,\n\t[GAUDI_SPMU_MME0_CTRL]\t\t= mmMME0_CTRL_SPMU_BASE,\n\t[GAUDI_SPMU_MME1_ACC]\t\t= mmMME1_ACC_SPMU_BASE,\n\t[GAUDI_SPMU_MME1_SBAB]\t\t= mmMME1_SBAB_SPMU_BASE,\n\t[GAUDI_SPMU_MME1_CTRL]\t\t= mmMME1_CTRL_SPMU_BASE,\n\t[GAUDI_SPMU_MME2_MME2_ACC]\t= mmMME2_ACC_SPMU_BASE,\n\t[GAUDI_SPMU_MME2_SBAB]\t\t= mmMME2_SBAB_SPMU_BASE,\n\t[GAUDI_SPMU_MME2_CTRL]\t\t= mmMME2_CTRL_SPMU_BASE,\n\t[GAUDI_SPMU_MME3_ACC]\t\t= mmMME3_ACC_SPMU_BASE,\n\t[GAUDI_SPMU_MME3_SBAB]\t\t= mmMME3_SBAB_SPMU_BASE,\n\t[GAUDI_SPMU_MME3_CTRL]\t\t= mmMME3_CTRL_SPMU_BASE,\n\t[GAUDI_SPMU_DMA_CH_0_CS]\t= mmDMA_CH_0_CS_SPMU_BASE,\n\t[GAUDI_SPMU_DMA_CH_1_CS]\t= mmDMA_CH_1_CS_SPMU_BASE,\n\t[GAUDI_SPMU_DMA_CH_2_CS]\t= mmDMA_CH_2_CS_SPMU_BASE,\n\t[GAUDI_SPMU_DMA_CH_3_CS]\t= mmDMA_CH_3_CS_SPMU_BASE,\n\t[GAUDI_SPMU_DMA_CH_4_CS]\t= mmDMA_CH_4_CS_SPMU_BASE,\n\t[GAUDI_SPMU_DMA_CH_5_CS]\t= mmDMA_CH_5_CS_SPMU_BASE,\n\t[GAUDI_SPMU_DMA_CH_6_CS]\t= mmDMA_CH_6_CS_SPMU_BASE,\n\t[GAUDI_SPMU_DMA_CH_7_CS]\t= mmDMA_CH_7_CS_SPMU_BASE,\n\t[GAUDI_SPMU_PCIE]\t\t= mmPCIE_SPMU_BASE,\n\t[GAUDI_SPMU_MMU_CS]\t\t= mmMMU_CS_SPMU_BASE,\n\t[GAUDI_SPMU_NIC0_0]\t\t= mmSPMU_0_NIC0_DBG_BASE,\n\t[GAUDI_SPMU_NIC0_1]\t\t= mmSPMU_1_NIC0_DBG_BASE,\n\t[GAUDI_SPMU_NIC1_0]\t\t= mmSPMU_0_NIC1_DBG_BASE,\n\t[GAUDI_SPMU_NIC1_1]\t\t= mmSPMU_1_NIC1_DBG_BASE,\n\t[GAUDI_SPMU_NIC2_0]\t\t= mmSPMU_0_NIC2_DBG_BASE,\n\t[GAUDI_SPMU_NIC2_1]\t\t= mmSPMU_1_NIC2_DBG_BASE,\n\t[GAUDI_SPMU_NIC3_0]\t\t= mmSPMU_0_NIC3_DBG_BASE,\n\t[GAUDI_SPMU_NIC3_1]\t\t= mmSPMU_1_NIC3_DBG_BASE,\n\t[GAUDI_SPMU_NIC4_0]\t\t= mmSPMU_0_NIC4_DBG_BASE,\n\t[GAUDI_SPMU_NIC4_1]\t\t= mmSPMU_1_NIC4_DBG_BASE,\n\t[GAUDI_SPMU_TPC0_EML]\t\t= mmTPC0_EML_SPMU_BASE,\n\t[GAUDI_SPMU_TPC1_EML]\t\t= mmTPC1_EML_SPMU_BASE,\n\t[GAUDI_SPMU_TPC2_EML]\t\t= mmTPC2_EML_SPMU_BASE,\n\t[GAUDI_SPMU_TPC3_EML]\t\t= mmTPC3_EML_SPMU_BASE,\n\t[GAUDI_SPMU_TPC4_EML]\t\t= mmTPC4_EML_SPMU_BASE,\n\t[GAUDI_SPMU_TPC5_EML]\t\t= mmTPC5_EML_SPMU_BASE,\n\t[GAUDI_SPMU_TPC6_EML]\t\t= mmTPC6_EML_SPMU_BASE,\n\t[GAUDI_SPMU_TPC7_EML]\t\t= mmTPC7_EML_SPMU_BASE\n};\n\nstatic int gaudi_coresight_timeout(struct hl_device *hdev, u64 addr,\n\t\tint position, bool up)\n{\n\tint rc;\n\tu32 val;\n\n\trc = hl_poll_timeout(\n\t\thdev,\n\t\taddr,\n\t\tval,\n\t\tup ? val & BIT(position) : !(val & BIT(position)),\n\t\t1000,\n\t\tCORESIGHT_TIMEOUT_USEC);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Timeout while waiting for coresight, addr: 0x%llx, position: %d, up: %d\\n\",\n\t\t\t\taddr, position, up);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int gaudi_config_stm(struct hl_device *hdev,\n\t\tstruct hl_debug_params *params)\n{\n\tstruct hl_debug_params_stm *input;\n\tu64 base_reg;\n\tu32 frequency;\n\tint rc;\n\n\tif (params->reg_idx >= ARRAY_SIZE(debug_stm_regs)) {\n\t\tdev_err(hdev->dev, \"Invalid register index in STM\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbase_reg = debug_stm_regs[params->reg_idx] - CFG_BASE;\n\n\tWREG32(base_reg + 0xFB0, CORESIGHT_UNLOCK);\n\n\tif (params->enable) {\n\t\tinput = params->input;\n\n\t\tif (!input)\n\t\t\treturn -EINVAL;\n\n\t\tWREG32(base_reg + 0xE80, 0x80004);\n\t\tWREG32(base_reg + 0xD64, 7);\n\t\tWREG32(base_reg + 0xD60, 0);\n\t\tWREG32(base_reg + 0xD00, lower_32_bits(input->he_mask));\n\t\tWREG32(base_reg + 0xD60, 1);\n\t\tWREG32(base_reg + 0xD00, upper_32_bits(input->he_mask));\n\t\tWREG32(base_reg + 0xE70, 0x10);\n\t\tWREG32(base_reg + 0xE60, 0);\n\t\tWREG32(base_reg + 0xE00, lower_32_bits(input->sp_mask));\n\t\tWREG32(base_reg + 0xEF4, input->id);\n\t\tWREG32(base_reg + 0xDF4, 0x80);\n\t\tfrequency = hdev->asic_prop.psoc_timestamp_frequency;\n\t\tif (frequency == 0)\n\t\t\tfrequency = input->frequency;\n\t\tWREG32(base_reg + 0xE8C, frequency);\n\t\tWREG32(base_reg + 0xE90, 0x1F00);\n\n\t\t \n\t\tif ((CFG_BASE + base_reg) >= mmDMA_CH_0_CS_STM_BASE &&\n\t\t\t(CFG_BASE + base_reg) <= mmDMA_CH_7_CS_STM_BASE) {\n\n\t\t\tWREG32(base_reg + 0xE68, 0xffff8005);\n\t\t\tWREG32(base_reg + 0xE6C, 0x0);\n\t\t}\n\n\t\tWREG32(base_reg + 0xE80, 0x23 | (input->id << 16));\n\t} else {\n\t\tWREG32(base_reg + 0xE80, 4);\n\t\tWREG32(base_reg + 0xD64, 0);\n\t\tWREG32(base_reg + 0xD60, 1);\n\t\tWREG32(base_reg + 0xD00, 0);\n\t\tWREG32(base_reg + 0xD20, 0);\n\t\tWREG32(base_reg + 0xD60, 0);\n\t\tWREG32(base_reg + 0xE20, 0);\n\t\tWREG32(base_reg + 0xE00, 0);\n\t\tWREG32(base_reg + 0xDF4, 0x80);\n\t\tWREG32(base_reg + 0xE70, 0);\n\t\tWREG32(base_reg + 0xE60, 0);\n\t\tWREG32(base_reg + 0xE64, 0);\n\t\tWREG32(base_reg + 0xE8C, 0);\n\n\t\trc = gaudi_coresight_timeout(hdev, base_reg + 0xE80, 23, false);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Failed to disable STM on timeout, error %d\\n\",\n\t\t\t\trc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tWREG32(base_reg + 0xE80, 4);\n\t}\n\n\treturn 0;\n}\n\nstatic int gaudi_config_etf(struct hl_device *hdev,\n\t\tstruct hl_debug_params *params)\n{\n\tstruct hl_debug_params_etf *input;\n\tu64 base_reg;\n\tu32 val;\n\tint rc;\n\n\tif (params->reg_idx >= ARRAY_SIZE(debug_etf_regs)) {\n\t\tdev_err(hdev->dev, \"Invalid register index in ETF\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbase_reg = debug_etf_regs[params->reg_idx] - CFG_BASE;\n\n\tWREG32(base_reg + 0xFB0, CORESIGHT_UNLOCK);\n\n\tval = RREG32(base_reg + 0x304);\n\tval |= 0x1000;\n\tWREG32(base_reg + 0x304, val);\n\tval |= 0x40;\n\tWREG32(base_reg + 0x304, val);\n\n\trc = gaudi_coresight_timeout(hdev, base_reg + 0x304, 6, false);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to %s ETF on timeout, error %d\\n\",\n\t\t\t\tparams->enable ? \"enable\" : \"disable\", rc);\n\t\treturn rc;\n\t}\n\n\trc = gaudi_coresight_timeout(hdev, base_reg + 0xC, 2, true);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to %s ETF on timeout, error %d\\n\",\n\t\t\t\tparams->enable ? \"enable\" : \"disable\", rc);\n\t\treturn rc;\n\t}\n\n\tWREG32(base_reg + 0x20, 0);\n\n\tif (params->enable) {\n\t\tinput = params->input;\n\n\t\tif (!input)\n\t\t\treturn -EINVAL;\n\n\t\tWREG32(base_reg + 0x34, 0x3FFC);\n\t\tWREG32(base_reg + 0x28, input->sink_mode);\n\t\tWREG32(base_reg + 0x304, 0x4001);\n\t\tWREG32(base_reg + 0x308, 0xA);\n\t\tWREG32(base_reg + 0x20, 1);\n\t} else {\n\t\tWREG32(base_reg + 0x34, 0);\n\t\tWREG32(base_reg + 0x28, 0);\n\t\tWREG32(base_reg + 0x304, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic bool gaudi_etr_validate_address(struct hl_device *hdev, u64 addr,\n\t\t\t\t\tu64 size, bool *is_host)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct gaudi_device *gaudi = hdev->asic_specific;\n\n\t \n\tif (addr >> 50) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"ETR buffer address shouldn't exceed 50 bits\\n\");\n\t\treturn false;\n\t}\n\n\tif (addr > (addr + size)) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"ETR buffer size %llu overflow\\n\", size);\n\t\treturn false;\n\t}\n\n\t \n\tif ((gaudi->hw_cap_initialized & HW_CAP_MMU) &&\n\t\thl_mem_area_inside_range(addr, size,\n\t\t\t\tprop->pmmu.start_addr,\n\t\t\t\tprop->pmmu.end_addr)) {\n\t\t*is_host = true;\n\t\treturn true;\n\t}\n\n\tif (hl_mem_area_inside_range(addr, size,\n\t\t\tprop->dram_user_base_address,\n\t\t\tprop->dram_end_address))\n\t\treturn true;\n\n\tif (hl_mem_area_inside_range(addr, size,\n\t\t\tprop->sram_user_base_address,\n\t\t\tprop->sram_end_address))\n\t\treturn true;\n\n\tif (!(gaudi->hw_cap_initialized & HW_CAP_MMU))\n\t\tdev_err(hdev->dev, \"ETR buffer should be in SRAM/DRAM\\n\");\n\n\treturn false;\n}\n\nstatic int gaudi_config_etr(struct hl_device *hdev,\n\t\tstruct hl_debug_params *params)\n{\n\tstruct hl_debug_params_etr *input;\n\tu64 msb;\n\tu32 val;\n\tint rc;\n\n\tWREG32(mmPSOC_ETR_LAR, CORESIGHT_UNLOCK);\n\n\tval = RREG32(mmPSOC_ETR_FFCR);\n\tval |= 0x1000;\n\tWREG32(mmPSOC_ETR_FFCR, val);\n\tval |= 0x40;\n\tWREG32(mmPSOC_ETR_FFCR, val);\n\n\trc = gaudi_coresight_timeout(hdev, mmPSOC_ETR_FFCR, 6, false);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to %s ETR on timeout, error %d\\n\",\n\t\t\t\tparams->enable ? \"enable\" : \"disable\", rc);\n\t\treturn rc;\n\t}\n\n\trc = gaudi_coresight_timeout(hdev, mmPSOC_ETR_STS, 2, true);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to %s ETR on timeout, error %d\\n\",\n\t\t\t\tparams->enable ? \"enable\" : \"disable\", rc);\n\t\treturn rc;\n\t}\n\n\tWREG32(mmPSOC_ETR_CTL, 0);\n\n\tif (params->enable) {\n\t\tbool is_host = false;\n\n\t\tinput = params->input;\n\n\t\tif (!input)\n\t\t\treturn -EINVAL;\n\n\t\tif (input->buffer_size == 0) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"ETR buffer size should be bigger than 0\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!gaudi_etr_validate_address(hdev,\n\t\t\t\tinput->buffer_address, input->buffer_size,\n\t\t\t\t&is_host)) {\n\t\t\tdev_err(hdev->dev, \"ETR buffer address is invalid\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmsb = upper_32_bits(input->buffer_address) >> 8;\n\t\tmsb &= PSOC_GLOBAL_CONF_TRACE_ADDR_MSB_MASK;\n\t\tWREG32(mmPSOC_GLOBAL_CONF_TRACE_ADDR, msb);\n\n\t\tWREG32(mmPSOC_ETR_BUFWM, 0x3FFC);\n\t\tWREG32(mmPSOC_ETR_RSZ, input->buffer_size);\n\t\tWREG32(mmPSOC_ETR_MODE, input->sink_mode);\n\t\tif (!hdev->asic_prop.fw_security_enabled) {\n\t\t\t \n\t\t\tval = FIELD_PREP(\n\t\t\t\t\tPSOC_ETR_AXICTL_PROTCTRLBIT0_MASK, 0);\n\t\t\t \n\t\t\tval |= FIELD_PREP(\n\t\t\t\t\tPSOC_ETR_AXICTL_PROTCTRLBIT1_MASK, 1);\n\t\t\t \n\t\t\tval |= FIELD_PREP(PSOC_ETR_AXICTL_WRBURSTLEN_MASK,\n\t\t\t\t\t\t\tis_host ? 0 : 7);\n\t\t\tWREG32(mmPSOC_ETR_AXICTL, val);\n\t\t}\n\t\tWREG32(mmPSOC_ETR_DBALO,\n\t\t\t\tlower_32_bits(input->buffer_address));\n\t\tWREG32(mmPSOC_ETR_DBAHI,\n\t\t\t\tupper_32_bits(input->buffer_address));\n\t\tWREG32(mmPSOC_ETR_FFCR, 3);\n\t\tWREG32(mmPSOC_ETR_PSCR, 0xA);\n\t\tWREG32(mmPSOC_ETR_CTL, 1);\n\t} else {\n\t\tWREG32(mmPSOC_ETR_BUFWM, 0);\n\t\tWREG32(mmPSOC_ETR_RSZ, 0x400);\n\t\tWREG32(mmPSOC_ETR_DBALO, 0);\n\t\tWREG32(mmPSOC_ETR_DBAHI, 0);\n\t\tWREG32(mmPSOC_ETR_PSCR, 0);\n\t\tWREG32(mmPSOC_ETR_MODE, 0);\n\t\tWREG32(mmPSOC_ETR_FFCR, 0);\n\n\t\tif (params->output_size >= sizeof(u64)) {\n\t\t\tu32 rwp, rwphi;\n\n\t\t\t \n\t\t\trwp = RREG32(mmPSOC_ETR_RWP);\n\t\t\trwphi = RREG32(mmPSOC_ETR_RWPHI) & 0xff;\n\t\t\tmsb = RREG32(mmPSOC_GLOBAL_CONF_TRACE_ADDR) &\n\t\t\t\t\tPSOC_GLOBAL_CONF_TRACE_ADDR_MSB_MASK;\n\t\t\t*(u64 *) params->output = ((u64) msb << 40) |\n\t\t\t\t\t\t((u64) rwphi << 32) | rwp;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int gaudi_config_funnel(struct hl_device *hdev,\n\t\tstruct hl_debug_params *params)\n{\n\tu64 base_reg;\n\n\tif (params->reg_idx >= ARRAY_SIZE(debug_funnel_regs)) {\n\t\tdev_err(hdev->dev, \"Invalid register index in FUNNEL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbase_reg = debug_funnel_regs[params->reg_idx] - CFG_BASE;\n\n\tWREG32(base_reg + 0xFB0, CORESIGHT_UNLOCK);\n\n\tWREG32(base_reg, params->enable ? 0x33F : 0);\n\n\treturn 0;\n}\n\nstatic int gaudi_config_bmon(struct hl_device *hdev,\n\t\tstruct hl_debug_params *params)\n{\n\tstruct hl_debug_params_bmon *input;\n\tu64 base_reg;\n\n\tif (params->reg_idx >= ARRAY_SIZE(debug_bmon_regs)) {\n\t\tdev_err(hdev->dev, \"Invalid register index in BMON\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbase_reg = debug_bmon_regs[params->reg_idx] - CFG_BASE;\n\n\tWREG32(base_reg + 0x104, 1);\n\n\tif (params->enable) {\n\t\tinput = params->input;\n\n\t\tif (!input)\n\t\t\treturn -EINVAL;\n\n\t\tWREG32(base_reg + 0x200, lower_32_bits(input->start_addr0));\n\t\tWREG32(base_reg + 0x204, upper_32_bits(input->start_addr0));\n\t\tWREG32(base_reg + 0x208, lower_32_bits(input->addr_mask0));\n\t\tWREG32(base_reg + 0x20C, upper_32_bits(input->addr_mask0));\n\t\tWREG32(base_reg + 0x240, lower_32_bits(input->start_addr1));\n\t\tWREG32(base_reg + 0x244, upper_32_bits(input->start_addr1));\n\t\tWREG32(base_reg + 0x248, lower_32_bits(input->addr_mask1));\n\t\tWREG32(base_reg + 0x24C, upper_32_bits(input->addr_mask1));\n\t\tWREG32(base_reg + 0x224, 0);\n\t\tWREG32(base_reg + 0x234, 0);\n\t\tWREG32(base_reg + 0x30C, input->bw_win);\n\t\tWREG32(base_reg + 0x308, input->win_capture);\n\t\tWREG32(base_reg + 0x700, 0xA000B00 | (input->id << 12));\n\t\tWREG32(base_reg + 0x708, 0xA000A00 | (input->id << 12));\n\t\tWREG32(base_reg + 0x70C, 0xA000C00 | (input->id << 12));\n\t\tWREG32(base_reg + 0x100, 0x11);\n\t\tWREG32(base_reg + 0x304, 0x1);\n\t} else {\n\t\tWREG32(base_reg + 0x200, 0);\n\t\tWREG32(base_reg + 0x204, 0);\n\t\tWREG32(base_reg + 0x208, 0xFFFFFFFF);\n\t\tWREG32(base_reg + 0x20C, 0xFFFFFFFF);\n\t\tWREG32(base_reg + 0x240, 0);\n\t\tWREG32(base_reg + 0x244, 0);\n\t\tWREG32(base_reg + 0x248, 0xFFFFFFFF);\n\t\tWREG32(base_reg + 0x24C, 0xFFFFFFFF);\n\t\tWREG32(base_reg + 0x224, 0xFFFFFFFF);\n\t\tWREG32(base_reg + 0x234, 0x1070F);\n\t\tWREG32(base_reg + 0x30C, 0);\n\t\tWREG32(base_reg + 0x308, 0xFFFF);\n\t\tWREG32(base_reg + 0x700, 0xA000B00);\n\t\tWREG32(base_reg + 0x708, 0xA000A00);\n\t\tWREG32(base_reg + 0x70C, 0xA000C00);\n\t\tWREG32(base_reg + 0x100, 1);\n\t\tWREG32(base_reg + 0x304, 0);\n\t\tWREG32(base_reg + 0x104, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int gaudi_config_spmu(struct hl_device *hdev,\n\t\tstruct hl_debug_params *params)\n{\n\tu64 base_reg;\n\tstruct hl_debug_params_spmu *input = params->input;\n\tu64 *output;\n\tu32 output_arr_len;\n\tu32 events_num;\n\tu32 overflow_idx;\n\tu32 cycle_cnt_idx;\n\tint i;\n\n\tif (params->reg_idx >= ARRAY_SIZE(debug_spmu_regs)) {\n\t\tdev_err(hdev->dev, \"Invalid register index in SPMU\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbase_reg = debug_spmu_regs[params->reg_idx] - CFG_BASE;\n\n\tif (params->enable) {\n\t\tinput = params->input;\n\n\t\tif (!input)\n\t\t\treturn -EINVAL;\n\n\t\tif (input->event_types_num < 3) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"not enough event types values for SPMU enable\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (input->event_types_num > SPMU_MAX_COUNTERS) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"too many event types values for SPMU enable\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tWREG32(base_reg + 0xE04, 0x41013046);\n\t\tWREG32(base_reg + 0xE04, 0x41013040);\n\n\t\tfor (i = 0 ; i < input->event_types_num ; i++)\n\t\t\tWREG32(base_reg + SPMU_EVENT_TYPES_OFFSET + i * 4,\n\t\t\t\tinput->event_types[i]);\n\n\t\tWREG32(base_reg + 0xE04, 0x41013041);\n\t\tWREG32(base_reg + 0xC00, 0x8000003F);\n\t} else {\n\t\toutput = params->output;\n\t\toutput_arr_len = params->output_size / 8;\n\t\tevents_num = output_arr_len - 2;\n\t\toverflow_idx = output_arr_len - 2;\n\t\tcycle_cnt_idx = output_arr_len - 1;\n\n\t\tif (!output)\n\t\t\treturn -EINVAL;\n\n\t\tif (output_arr_len < 3) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"not enough values for SPMU disable\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (events_num > SPMU_MAX_COUNTERS) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"too many events values for SPMU disable\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tWREG32(base_reg + 0xE04, 0x41013040);\n\n\t\tfor (i = 0 ; i < events_num ; i++)\n\t\t\toutput[i] = RREG32(base_reg + i * 8);\n\n\t\toutput[overflow_idx] = RREG32(base_reg + 0xCC0);\n\n\t\toutput[cycle_cnt_idx] = RREG32(base_reg + 0xFC);\n\t\toutput[cycle_cnt_idx] <<= 32;\n\t\toutput[cycle_cnt_idx] |= RREG32(base_reg + 0xF8);\n\n\t\tWREG32(base_reg + 0xCC0, 0);\n\t}\n\n\treturn 0;\n}\n\nint gaudi_debug_coresight(struct hl_device *hdev, struct hl_ctx *ctx, void *data)\n{\n\tstruct hl_debug_params *params = data;\n\tint rc = 0;\n\n\tswitch (params->op) {\n\tcase HL_DEBUG_OP_STM:\n\t\trc = gaudi_config_stm(hdev, params);\n\t\tbreak;\n\tcase HL_DEBUG_OP_ETF:\n\t\trc = gaudi_config_etf(hdev, params);\n\t\tbreak;\n\tcase HL_DEBUG_OP_ETR:\n\t\trc = gaudi_config_etr(hdev, params);\n\t\tbreak;\n\tcase HL_DEBUG_OP_FUNNEL:\n\t\trc = gaudi_config_funnel(hdev, params);\n\t\tbreak;\n\tcase HL_DEBUG_OP_BMON:\n\t\trc = gaudi_config_bmon(hdev, params);\n\t\tbreak;\n\tcase HL_DEBUG_OP_SPMU:\n\t\trc = gaudi_config_spmu(hdev, params);\n\t\tbreak;\n\tcase HL_DEBUG_OP_TIMESTAMP:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(hdev->dev, \"Unknown coresight id %d\\n\", params->op);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tRREG32(mmHW_STATE);\n\n\treturn rc;\n}\n\nvoid gaudi_halt_coresight(struct hl_device *hdev, struct hl_ctx *ctx)\n{\n\tstruct hl_debug_params params = {};\n\tint i, rc;\n\n\tfor (i = GAUDI_ETF_FIRST ; i <= GAUDI_ETF_LAST ; i++) {\n\t\tparams.reg_idx = i;\n\t\trc = gaudi_config_etf(hdev, &params);\n\t\tif (rc)\n\t\t\tdev_err(hdev->dev, \"halt ETF failed, %d/%d\\n\", rc, i);\n\t}\n\n\trc = gaudi_config_etr(hdev, &params);\n\tif (rc)\n\t\tdev_err(hdev->dev, \"halt ETR failed, %d\\n\", rc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}