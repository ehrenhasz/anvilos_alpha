{
  "module_name": "goya.c",
  "hash_id": "501903b46a36886afbf30f9e1539b8ef103392c475acbeafe0ec2cfadb35b948",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/goya/goya.c",
  "human_readable_source": "\n\n \n\n#include \"goyaP.h\"\n#include \"../include/hw_ip/mmu/mmu_general.h\"\n#include \"../include/hw_ip/mmu/mmu_v1_0.h\"\n#include \"../include/goya/asic_reg/goya_masks.h\"\n#include \"../include/goya/goya_reg_map.h\"\n\n#include <linux/pci.h>\n#include <linux/hwmon.h>\n#include <linux/iommu.h>\n#include <linux/seq_file.h>\n\n \n\n#define GOYA_BOOT_FIT_FILE\t\"habanalabs/goya/goya-boot-fit.itb\"\n#define GOYA_LINUX_FW_FILE\t\"habanalabs/goya/goya-fit.itb\"\n\n#define GOYA_MMU_REGS_NUM\t\t63\n\n#define GOYA_DMA_POOL_BLK_SIZE\t\t0x100\t\t \n\n#define GOYA_RESET_TIMEOUT_MSEC\t\t500\t\t \n#define GOYA_PLDM_RESET_TIMEOUT_MSEC\t20000\t\t \n#define GOYA_RESET_WAIT_MSEC\t\t1\t\t \n#define GOYA_CPU_RESET_WAIT_MSEC\t100\t\t \n#define GOYA_PLDM_RESET_WAIT_MSEC\t1000\t\t \n#define GOYA_TEST_QUEUE_WAIT_USEC\t100000\t\t \n#define GOYA_PLDM_MMU_TIMEOUT_USEC\t(MMU_CONFIG_TIMEOUT_USEC * 100)\n#define GOYA_PLDM_QMAN0_TIMEOUT_USEC\t(HL_DEVICE_TIMEOUT_USEC * 30)\n#define GOYA_BOOT_FIT_REQ_TIMEOUT_USEC\t1000000\t\t \n#define GOYA_MSG_TO_CPU_TIMEOUT_USEC\t4000000\t\t \n#define GOYA_WAIT_FOR_BL_TIMEOUT_USEC\t15000000\t \n\n#define GOYA_QMAN0_FENCE_VAL\t\t0xD169B243\n\n#define GOYA_MAX_STRING_LEN\t\t20\n\n#define GOYA_CB_POOL_CB_CNT\t\t512\n#define GOYA_CB_POOL_CB_SIZE\t\t0x20000\t\t \n\n#define IS_QM_IDLE(engine, qm_glbl_sts0) \\\n\t(((qm_glbl_sts0) & engine##_QM_IDLE_MASK) == engine##_QM_IDLE_MASK)\n#define IS_DMA_QM_IDLE(qm_glbl_sts0)\tIS_QM_IDLE(DMA, qm_glbl_sts0)\n#define IS_TPC_QM_IDLE(qm_glbl_sts0)\tIS_QM_IDLE(TPC, qm_glbl_sts0)\n#define IS_MME_QM_IDLE(qm_glbl_sts0)\tIS_QM_IDLE(MME, qm_glbl_sts0)\n\n#define IS_CMDQ_IDLE(engine, cmdq_glbl_sts0) \\\n\t(((cmdq_glbl_sts0) & engine##_CMDQ_IDLE_MASK) == \\\n\t\t\tengine##_CMDQ_IDLE_MASK)\n#define IS_TPC_CMDQ_IDLE(cmdq_glbl_sts0) \\\n\tIS_CMDQ_IDLE(TPC, cmdq_glbl_sts0)\n#define IS_MME_CMDQ_IDLE(cmdq_glbl_sts0) \\\n\tIS_CMDQ_IDLE(MME, cmdq_glbl_sts0)\n\n#define IS_DMA_IDLE(dma_core_sts0) \\\n\t!((dma_core_sts0) & DMA_CH_0_STS0_DMA_BUSY_MASK)\n\n#define IS_TPC_IDLE(tpc_cfg_sts) \\\n\t(((tpc_cfg_sts) & TPC_CFG_IDLE_MASK) == TPC_CFG_IDLE_MASK)\n\n#define IS_MME_IDLE(mme_arch_sts) \\\n\t(((mme_arch_sts) & MME_ARCH_IDLE_MASK) == MME_ARCH_IDLE_MASK)\n\nstatic const char goya_irq_name[GOYA_MSIX_ENTRIES][GOYA_MAX_STRING_LEN] = {\n\t\t\"goya cq 0\", \"goya cq 1\", \"goya cq 2\", \"goya cq 3\",\n\t\t\"goya cq 4\", \"goya cpu eq\"\n};\n\nstatic u16 goya_packet_sizes[MAX_PACKET_ID] = {\n\t[PACKET_WREG_32]\t= sizeof(struct packet_wreg32),\n\t[PACKET_WREG_BULK]\t= sizeof(struct packet_wreg_bulk),\n\t[PACKET_MSG_LONG]\t= sizeof(struct packet_msg_long),\n\t[PACKET_MSG_SHORT]\t= sizeof(struct packet_msg_short),\n\t[PACKET_CP_DMA]\t\t= sizeof(struct packet_cp_dma),\n\t[PACKET_MSG_PROT]\t= sizeof(struct packet_msg_prot),\n\t[PACKET_FENCE]\t\t= sizeof(struct packet_fence),\n\t[PACKET_LIN_DMA]\t= sizeof(struct packet_lin_dma),\n\t[PACKET_NOP]\t\t= sizeof(struct packet_nop),\n\t[PACKET_STOP]\t\t= sizeof(struct packet_stop)\n};\n\nstatic inline bool validate_packet_id(enum packet_id id)\n{\n\tswitch (id) {\n\tcase PACKET_WREG_32:\n\tcase PACKET_WREG_BULK:\n\tcase PACKET_MSG_LONG:\n\tcase PACKET_MSG_SHORT:\n\tcase PACKET_CP_DMA:\n\tcase PACKET_MSG_PROT:\n\tcase PACKET_FENCE:\n\tcase PACKET_LIN_DMA:\n\tcase PACKET_NOP:\n\tcase PACKET_STOP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic u64 goya_mmu_regs[GOYA_MMU_REGS_NUM] = {\n\tmmDMA_QM_0_GLBL_NON_SECURE_PROPS,\n\tmmDMA_QM_1_GLBL_NON_SECURE_PROPS,\n\tmmDMA_QM_2_GLBL_NON_SECURE_PROPS,\n\tmmDMA_QM_3_GLBL_NON_SECURE_PROPS,\n\tmmDMA_QM_4_GLBL_NON_SECURE_PROPS,\n\tmmTPC0_QM_GLBL_SECURE_PROPS,\n\tmmTPC0_QM_GLBL_NON_SECURE_PROPS,\n\tmmTPC0_CMDQ_GLBL_SECURE_PROPS,\n\tmmTPC0_CMDQ_GLBL_NON_SECURE_PROPS,\n\tmmTPC0_CFG_ARUSER,\n\tmmTPC0_CFG_AWUSER,\n\tmmTPC1_QM_GLBL_SECURE_PROPS,\n\tmmTPC1_QM_GLBL_NON_SECURE_PROPS,\n\tmmTPC1_CMDQ_GLBL_SECURE_PROPS,\n\tmmTPC1_CMDQ_GLBL_NON_SECURE_PROPS,\n\tmmTPC1_CFG_ARUSER,\n\tmmTPC1_CFG_AWUSER,\n\tmmTPC2_QM_GLBL_SECURE_PROPS,\n\tmmTPC2_QM_GLBL_NON_SECURE_PROPS,\n\tmmTPC2_CMDQ_GLBL_SECURE_PROPS,\n\tmmTPC2_CMDQ_GLBL_NON_SECURE_PROPS,\n\tmmTPC2_CFG_ARUSER,\n\tmmTPC2_CFG_AWUSER,\n\tmmTPC3_QM_GLBL_SECURE_PROPS,\n\tmmTPC3_QM_GLBL_NON_SECURE_PROPS,\n\tmmTPC3_CMDQ_GLBL_SECURE_PROPS,\n\tmmTPC3_CMDQ_GLBL_NON_SECURE_PROPS,\n\tmmTPC3_CFG_ARUSER,\n\tmmTPC3_CFG_AWUSER,\n\tmmTPC4_QM_GLBL_SECURE_PROPS,\n\tmmTPC4_QM_GLBL_NON_SECURE_PROPS,\n\tmmTPC4_CMDQ_GLBL_SECURE_PROPS,\n\tmmTPC4_CMDQ_GLBL_NON_SECURE_PROPS,\n\tmmTPC4_CFG_ARUSER,\n\tmmTPC4_CFG_AWUSER,\n\tmmTPC5_QM_GLBL_SECURE_PROPS,\n\tmmTPC5_QM_GLBL_NON_SECURE_PROPS,\n\tmmTPC5_CMDQ_GLBL_SECURE_PROPS,\n\tmmTPC5_CMDQ_GLBL_NON_SECURE_PROPS,\n\tmmTPC5_CFG_ARUSER,\n\tmmTPC5_CFG_AWUSER,\n\tmmTPC6_QM_GLBL_SECURE_PROPS,\n\tmmTPC6_QM_GLBL_NON_SECURE_PROPS,\n\tmmTPC6_CMDQ_GLBL_SECURE_PROPS,\n\tmmTPC6_CMDQ_GLBL_NON_SECURE_PROPS,\n\tmmTPC6_CFG_ARUSER,\n\tmmTPC6_CFG_AWUSER,\n\tmmTPC7_QM_GLBL_SECURE_PROPS,\n\tmmTPC7_QM_GLBL_NON_SECURE_PROPS,\n\tmmTPC7_CMDQ_GLBL_SECURE_PROPS,\n\tmmTPC7_CMDQ_GLBL_NON_SECURE_PROPS,\n\tmmTPC7_CFG_ARUSER,\n\tmmTPC7_CFG_AWUSER,\n\tmmMME_QM_GLBL_SECURE_PROPS,\n\tmmMME_QM_GLBL_NON_SECURE_PROPS,\n\tmmMME_CMDQ_GLBL_SECURE_PROPS,\n\tmmMME_CMDQ_GLBL_NON_SECURE_PROPS,\n\tmmMME_SBA_CONTROL_DATA,\n\tmmMME_SBB_CONTROL_DATA,\n\tmmMME_SBC_CONTROL_DATA,\n\tmmMME_WBC_CONTROL_DATA,\n\tmmPCIE_WRAP_PSOC_ARUSER,\n\tmmPCIE_WRAP_PSOC_AWUSER\n};\n\nstatic u32 goya_all_events[] = {\n\tGOYA_ASYNC_EVENT_ID_PCIE_IF,\n\tGOYA_ASYNC_EVENT_ID_TPC0_ECC,\n\tGOYA_ASYNC_EVENT_ID_TPC1_ECC,\n\tGOYA_ASYNC_EVENT_ID_TPC2_ECC,\n\tGOYA_ASYNC_EVENT_ID_TPC3_ECC,\n\tGOYA_ASYNC_EVENT_ID_TPC4_ECC,\n\tGOYA_ASYNC_EVENT_ID_TPC5_ECC,\n\tGOYA_ASYNC_EVENT_ID_TPC6_ECC,\n\tGOYA_ASYNC_EVENT_ID_TPC7_ECC,\n\tGOYA_ASYNC_EVENT_ID_MME_ECC,\n\tGOYA_ASYNC_EVENT_ID_MME_ECC_EXT,\n\tGOYA_ASYNC_EVENT_ID_MMU_ECC,\n\tGOYA_ASYNC_EVENT_ID_DMA_MACRO,\n\tGOYA_ASYNC_EVENT_ID_DMA_ECC,\n\tGOYA_ASYNC_EVENT_ID_CPU_IF_ECC,\n\tGOYA_ASYNC_EVENT_ID_PSOC_MEM,\n\tGOYA_ASYNC_EVENT_ID_PSOC_CORESIGHT,\n\tGOYA_ASYNC_EVENT_ID_SRAM0,\n\tGOYA_ASYNC_EVENT_ID_SRAM1,\n\tGOYA_ASYNC_EVENT_ID_SRAM2,\n\tGOYA_ASYNC_EVENT_ID_SRAM3,\n\tGOYA_ASYNC_EVENT_ID_SRAM4,\n\tGOYA_ASYNC_EVENT_ID_SRAM5,\n\tGOYA_ASYNC_EVENT_ID_SRAM6,\n\tGOYA_ASYNC_EVENT_ID_SRAM7,\n\tGOYA_ASYNC_EVENT_ID_SRAM8,\n\tGOYA_ASYNC_EVENT_ID_SRAM9,\n\tGOYA_ASYNC_EVENT_ID_SRAM10,\n\tGOYA_ASYNC_EVENT_ID_SRAM11,\n\tGOYA_ASYNC_EVENT_ID_SRAM12,\n\tGOYA_ASYNC_EVENT_ID_SRAM13,\n\tGOYA_ASYNC_EVENT_ID_SRAM14,\n\tGOYA_ASYNC_EVENT_ID_SRAM15,\n\tGOYA_ASYNC_EVENT_ID_SRAM16,\n\tGOYA_ASYNC_EVENT_ID_SRAM17,\n\tGOYA_ASYNC_EVENT_ID_SRAM18,\n\tGOYA_ASYNC_EVENT_ID_SRAM19,\n\tGOYA_ASYNC_EVENT_ID_SRAM20,\n\tGOYA_ASYNC_EVENT_ID_SRAM21,\n\tGOYA_ASYNC_EVENT_ID_SRAM22,\n\tGOYA_ASYNC_EVENT_ID_SRAM23,\n\tGOYA_ASYNC_EVENT_ID_SRAM24,\n\tGOYA_ASYNC_EVENT_ID_SRAM25,\n\tGOYA_ASYNC_EVENT_ID_SRAM26,\n\tGOYA_ASYNC_EVENT_ID_SRAM27,\n\tGOYA_ASYNC_EVENT_ID_SRAM28,\n\tGOYA_ASYNC_EVENT_ID_SRAM29,\n\tGOYA_ASYNC_EVENT_ID_GIC500,\n\tGOYA_ASYNC_EVENT_ID_PLL0,\n\tGOYA_ASYNC_EVENT_ID_PLL1,\n\tGOYA_ASYNC_EVENT_ID_PLL3,\n\tGOYA_ASYNC_EVENT_ID_PLL4,\n\tGOYA_ASYNC_EVENT_ID_PLL5,\n\tGOYA_ASYNC_EVENT_ID_PLL6,\n\tGOYA_ASYNC_EVENT_ID_AXI_ECC,\n\tGOYA_ASYNC_EVENT_ID_L2_RAM_ECC,\n\tGOYA_ASYNC_EVENT_ID_PSOC_GPIO_05_SW_RESET,\n\tGOYA_ASYNC_EVENT_ID_PSOC_GPIO_10_VRHOT_ICRIT,\n\tGOYA_ASYNC_EVENT_ID_PCIE_DEC,\n\tGOYA_ASYNC_EVENT_ID_TPC0_DEC,\n\tGOYA_ASYNC_EVENT_ID_TPC1_DEC,\n\tGOYA_ASYNC_EVENT_ID_TPC2_DEC,\n\tGOYA_ASYNC_EVENT_ID_TPC3_DEC,\n\tGOYA_ASYNC_EVENT_ID_TPC4_DEC,\n\tGOYA_ASYNC_EVENT_ID_TPC5_DEC,\n\tGOYA_ASYNC_EVENT_ID_TPC6_DEC,\n\tGOYA_ASYNC_EVENT_ID_TPC7_DEC,\n\tGOYA_ASYNC_EVENT_ID_MME_WACS,\n\tGOYA_ASYNC_EVENT_ID_MME_WACSD,\n\tGOYA_ASYNC_EVENT_ID_CPU_AXI_SPLITTER,\n\tGOYA_ASYNC_EVENT_ID_PSOC_AXI_DEC,\n\tGOYA_ASYNC_EVENT_ID_PSOC,\n\tGOYA_ASYNC_EVENT_ID_TPC0_KRN_ERR,\n\tGOYA_ASYNC_EVENT_ID_TPC1_KRN_ERR,\n\tGOYA_ASYNC_EVENT_ID_TPC2_KRN_ERR,\n\tGOYA_ASYNC_EVENT_ID_TPC3_KRN_ERR,\n\tGOYA_ASYNC_EVENT_ID_TPC4_KRN_ERR,\n\tGOYA_ASYNC_EVENT_ID_TPC5_KRN_ERR,\n\tGOYA_ASYNC_EVENT_ID_TPC6_KRN_ERR,\n\tGOYA_ASYNC_EVENT_ID_TPC7_KRN_ERR,\n\tGOYA_ASYNC_EVENT_ID_TPC0_CMDQ,\n\tGOYA_ASYNC_EVENT_ID_TPC1_CMDQ,\n\tGOYA_ASYNC_EVENT_ID_TPC2_CMDQ,\n\tGOYA_ASYNC_EVENT_ID_TPC3_CMDQ,\n\tGOYA_ASYNC_EVENT_ID_TPC4_CMDQ,\n\tGOYA_ASYNC_EVENT_ID_TPC5_CMDQ,\n\tGOYA_ASYNC_EVENT_ID_TPC6_CMDQ,\n\tGOYA_ASYNC_EVENT_ID_TPC7_CMDQ,\n\tGOYA_ASYNC_EVENT_ID_TPC0_QM,\n\tGOYA_ASYNC_EVENT_ID_TPC1_QM,\n\tGOYA_ASYNC_EVENT_ID_TPC2_QM,\n\tGOYA_ASYNC_EVENT_ID_TPC3_QM,\n\tGOYA_ASYNC_EVENT_ID_TPC4_QM,\n\tGOYA_ASYNC_EVENT_ID_TPC5_QM,\n\tGOYA_ASYNC_EVENT_ID_TPC6_QM,\n\tGOYA_ASYNC_EVENT_ID_TPC7_QM,\n\tGOYA_ASYNC_EVENT_ID_MME_QM,\n\tGOYA_ASYNC_EVENT_ID_MME_CMDQ,\n\tGOYA_ASYNC_EVENT_ID_DMA0_QM,\n\tGOYA_ASYNC_EVENT_ID_DMA1_QM,\n\tGOYA_ASYNC_EVENT_ID_DMA2_QM,\n\tGOYA_ASYNC_EVENT_ID_DMA3_QM,\n\tGOYA_ASYNC_EVENT_ID_DMA4_QM,\n\tGOYA_ASYNC_EVENT_ID_DMA0_CH,\n\tGOYA_ASYNC_EVENT_ID_DMA1_CH,\n\tGOYA_ASYNC_EVENT_ID_DMA2_CH,\n\tGOYA_ASYNC_EVENT_ID_DMA3_CH,\n\tGOYA_ASYNC_EVENT_ID_DMA4_CH,\n\tGOYA_ASYNC_EVENT_ID_TPC0_BMON_SPMU,\n\tGOYA_ASYNC_EVENT_ID_TPC1_BMON_SPMU,\n\tGOYA_ASYNC_EVENT_ID_TPC2_BMON_SPMU,\n\tGOYA_ASYNC_EVENT_ID_TPC3_BMON_SPMU,\n\tGOYA_ASYNC_EVENT_ID_TPC4_BMON_SPMU,\n\tGOYA_ASYNC_EVENT_ID_TPC5_BMON_SPMU,\n\tGOYA_ASYNC_EVENT_ID_TPC6_BMON_SPMU,\n\tGOYA_ASYNC_EVENT_ID_TPC7_BMON_SPMU,\n\tGOYA_ASYNC_EVENT_ID_DMA_BM_CH0,\n\tGOYA_ASYNC_EVENT_ID_DMA_BM_CH1,\n\tGOYA_ASYNC_EVENT_ID_DMA_BM_CH2,\n\tGOYA_ASYNC_EVENT_ID_DMA_BM_CH3,\n\tGOYA_ASYNC_EVENT_ID_DMA_BM_CH4,\n\tGOYA_ASYNC_EVENT_ID_FIX_POWER_ENV_S,\n\tGOYA_ASYNC_EVENT_ID_FIX_POWER_ENV_E,\n\tGOYA_ASYNC_EVENT_ID_FIX_THERMAL_ENV_S,\n\tGOYA_ASYNC_EVENT_ID_FIX_THERMAL_ENV_E\n};\n\nstatic s64 goya_state_dump_specs_props[SP_MAX] = {0};\n\nstatic int goya_mmu_clear_pgt_range(struct hl_device *hdev);\nstatic int goya_mmu_set_dram_default_page(struct hl_device *hdev);\nstatic int goya_mmu_add_mappings_for_device_cpu(struct hl_device *hdev);\nstatic void goya_mmu_prepare(struct hl_device *hdev, u32 asid);\n\nint goya_set_fixed_properties(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tint i;\n\n\tprop->max_queues = GOYA_QUEUE_ID_SIZE;\n\tprop->hw_queues_props = kcalloc(prop->max_queues,\n\t\t\tsizeof(struct hw_queue_properties),\n\t\t\tGFP_KERNEL);\n\n\tif (!prop->hw_queues_props)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0 ; i < NUMBER_OF_EXT_HW_QUEUES ; i++) {\n\t\tprop->hw_queues_props[i].type = QUEUE_TYPE_EXT;\n\t\tprop->hw_queues_props[i].driver_only = 0;\n\t\tprop->hw_queues_props[i].cb_alloc_flags = CB_ALLOC_KERNEL;\n\t}\n\n\tfor (; i < NUMBER_OF_EXT_HW_QUEUES + NUMBER_OF_CPU_HW_QUEUES ; i++) {\n\t\tprop->hw_queues_props[i].type = QUEUE_TYPE_CPU;\n\t\tprop->hw_queues_props[i].driver_only = 1;\n\t\tprop->hw_queues_props[i].cb_alloc_flags = CB_ALLOC_KERNEL;\n\t}\n\n\tfor (; i < NUMBER_OF_EXT_HW_QUEUES + NUMBER_OF_CPU_HW_QUEUES +\n\t\t\tNUMBER_OF_INT_HW_QUEUES; i++) {\n\t\tprop->hw_queues_props[i].type = QUEUE_TYPE_INT;\n\t\tprop->hw_queues_props[i].driver_only = 0;\n\t\tprop->hw_queues_props[i].cb_alloc_flags = CB_ALLOC_USER;\n\t}\n\n\tprop->cfg_base_address = CFG_BASE;\n\tprop->device_dma_offset_for_host_access = HOST_PHYS_BASE;\n\tprop->host_base_address = HOST_PHYS_BASE;\n\tprop->host_end_address = prop->host_base_address + HOST_PHYS_SIZE;\n\tprop->completion_queues_count = NUMBER_OF_CMPLT_QUEUES;\n\tprop->completion_mode = HL_COMPLETION_MODE_JOB;\n\tprop->dram_base_address = DRAM_PHYS_BASE;\n\tprop->dram_size = DRAM_PHYS_DEFAULT_SIZE;\n\tprop->dram_end_address = prop->dram_base_address + prop->dram_size;\n\tprop->dram_user_base_address = DRAM_BASE_ADDR_USER;\n\n\tprop->sram_base_address = SRAM_BASE_ADDR;\n\tprop->sram_size = SRAM_SIZE;\n\tprop->sram_end_address = prop->sram_base_address + prop->sram_size;\n\tprop->sram_user_base_address = prop->sram_base_address +\n\t\t\t\t\t\tSRAM_USER_BASE_OFFSET;\n\n\tprop->mmu_pgt_addr = MMU_PAGE_TABLES_ADDR;\n\tprop->mmu_dram_default_page_addr = MMU_DRAM_DEFAULT_PAGE_ADDR;\n\tif (hdev->pldm)\n\t\tprop->mmu_pgt_size = 0x800000;  \n\telse\n\t\tprop->mmu_pgt_size = MMU_PAGE_TABLES_SIZE;\n\tprop->mmu_pte_size = HL_PTE_SIZE;\n\tprop->mmu_hop_table_size = HOP_TABLE_SIZE_512_PTE;\n\tprop->mmu_hop0_tables_total_size = HOP0_512_PTE_TABLES_TOTAL_SIZE;\n\tprop->dram_page_size = PAGE_SIZE_2MB;\n\tprop->device_mem_alloc_default_page_size = prop->dram_page_size;\n\tprop->dram_supports_virtual_memory = true;\n\n\tprop->dmmu.hop_shifts[MMU_HOP0] = MMU_V1_0_HOP0_SHIFT;\n\tprop->dmmu.hop_shifts[MMU_HOP1] = MMU_V1_0_HOP1_SHIFT;\n\tprop->dmmu.hop_shifts[MMU_HOP2] = MMU_V1_0_HOP2_SHIFT;\n\tprop->dmmu.hop_shifts[MMU_HOP3] = MMU_V1_0_HOP3_SHIFT;\n\tprop->dmmu.hop_shifts[MMU_HOP4] = MMU_V1_0_HOP4_SHIFT;\n\tprop->dmmu.hop_masks[MMU_HOP0] = MMU_V1_0_HOP0_MASK;\n\tprop->dmmu.hop_masks[MMU_HOP1] = MMU_V1_0_HOP1_MASK;\n\tprop->dmmu.hop_masks[MMU_HOP2] = MMU_V1_0_HOP2_MASK;\n\tprop->dmmu.hop_masks[MMU_HOP3] = MMU_V1_0_HOP3_MASK;\n\tprop->dmmu.hop_masks[MMU_HOP4] = MMU_V1_0_HOP4_MASK;\n\tprop->dmmu.start_addr = VA_DDR_SPACE_START;\n\tprop->dmmu.end_addr = VA_DDR_SPACE_END;\n\tprop->dmmu.page_size = PAGE_SIZE_2MB;\n\tprop->dmmu.num_hops = MMU_ARCH_5_HOPS;\n\tprop->dmmu.last_mask = LAST_MASK;\n\t \n\tprop->dmmu.hop_table_size = prop->mmu_hop_table_size;\n\tprop->dmmu.hop0_tables_total_size = prop->mmu_hop0_tables_total_size;\n\n\t \n\tmemcpy(&prop->pmmu, &prop->dmmu, sizeof(prop->dmmu));\n\tprop->pmmu.start_addr = VA_HOST_SPACE_START;\n\tprop->pmmu.end_addr = VA_HOST_SPACE_END;\n\tprop->pmmu.page_size = PAGE_SIZE_4KB;\n\tprop->pmmu.num_hops = MMU_ARCH_5_HOPS;\n\tprop->pmmu.last_mask = LAST_MASK;\n\t \n\tprop->pmmu.hop_table_size = prop->mmu_hop_table_size;\n\tprop->pmmu.hop0_tables_total_size = prop->mmu_hop0_tables_total_size;\n\n\t \n\tmemcpy(&prop->pmmu_huge, &prop->pmmu, sizeof(prop->pmmu));\n\tprop->pmmu_huge.page_size = PAGE_SIZE_2MB;\n\n\tprop->dram_size_for_default_page_mapping = VA_DDR_SPACE_END;\n\tprop->cfg_size = CFG_SIZE;\n\tprop->max_asid = MAX_ASID;\n\tprop->num_of_events = GOYA_ASYNC_EVENT_ID_SIZE;\n\tprop->high_pll = PLL_HIGH_DEFAULT;\n\tprop->cb_pool_cb_cnt = GOYA_CB_POOL_CB_CNT;\n\tprop->cb_pool_cb_size = GOYA_CB_POOL_CB_SIZE;\n\tprop->max_power_default = MAX_POWER_DEFAULT;\n\tprop->dc_power_default = DC_POWER_DEFAULT;\n\tprop->tpc_enabled_mask = TPC_ENABLED_MASK;\n\tprop->pcie_dbi_base_address = mmPCIE_DBI_BASE;\n\tprop->pcie_aux_dbi_reg_addr = CFG_BASE + mmPCIE_AUX_DBI;\n\n\tstrncpy(prop->cpucp_info.card_name, GOYA_DEFAULT_CARD_NAME,\n\t\tCARD_NAME_MAX_LEN);\n\n\tprop->max_pending_cs = GOYA_MAX_PENDING_CS;\n\n\tprop->first_available_user_interrupt = USHRT_MAX;\n\tprop->tpc_interrupt_id = USHRT_MAX;\n\tprop->eq_interrupt_id = GOYA_EVENT_QUEUE_MSIX_IDX;\n\n\tfor (i = 0 ; i < HL_MAX_DCORES ; i++)\n\t\tprop->first_available_cq[i] = USHRT_MAX;\n\n\tprop->fw_cpu_boot_dev_sts0_valid = false;\n\tprop->fw_cpu_boot_dev_sts1_valid = false;\n\tprop->hard_reset_done_by_fw = false;\n\tprop->gic_interrupts_enable = true;\n\n\tprop->server_type = HL_SERVER_TYPE_UNKNOWN;\n\n\tprop->clk_pll_index = HL_GOYA_MME_PLL;\n\n\tprop->use_get_power_for_reset_history = true;\n\n\tprop->configurable_stop_on_err = true;\n\n\tprop->set_max_power_on_device_init = true;\n\n\tprop->dma_mask = 48;\n\n\treturn 0;\n}\n\n \nstatic int goya_pci_bars_map(struct hl_device *hdev)\n{\n\tstatic const char * const name[] = {\"SRAM_CFG\", \"MSIX\", \"DDR\"};\n\tbool is_wc[3] = {false, false, true};\n\tint rc;\n\n\trc = hl_pci_bars_map(hdev, name, is_wc);\n\tif (rc)\n\t\treturn rc;\n\n\thdev->rmmio = hdev->pcie_bar[SRAM_CFG_BAR_ID] +\n\t\t\t(CFG_BASE - SRAM_BASE_ADDR);\n\n\treturn 0;\n}\n\nstatic u64 goya_set_ddr_bar_base(struct hl_device *hdev, u64 addr)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tstruct hl_inbound_pci_region pci_region;\n\tu64 old_addr = addr;\n\tint rc;\n\n\tif ((goya) && (goya->ddr_bar_cur_addr == addr))\n\t\treturn old_addr;\n\n\t \n\tpci_region.mode = PCI_BAR_MATCH_MODE;\n\tpci_region.bar = DDR_BAR_ID;\n\tpci_region.addr = addr;\n\trc = hl_pci_set_inbound_region(hdev, 1, &pci_region);\n\tif (rc)\n\t\treturn U64_MAX;\n\n\tif (goya) {\n\t\told_addr = goya->ddr_bar_cur_addr;\n\t\tgoya->ddr_bar_cur_addr = addr;\n\t}\n\n\treturn old_addr;\n}\n\n \nstatic int goya_init_iatu(struct hl_device *hdev)\n{\n\tstruct hl_inbound_pci_region inbound_region;\n\tstruct hl_outbound_pci_region outbound_region;\n\tint rc;\n\n\tif (hdev->asic_prop.iatu_done_by_fw)\n\t\treturn 0;\n\n\t \n\tinbound_region.mode = PCI_BAR_MATCH_MODE;\n\tinbound_region.bar = SRAM_CFG_BAR_ID;\n\tinbound_region.addr = SRAM_BASE_ADDR;\n\trc = hl_pci_set_inbound_region(hdev, 0, &inbound_region);\n\tif (rc)\n\t\tgoto done;\n\n\t \n\tinbound_region.mode = PCI_BAR_MATCH_MODE;\n\tinbound_region.bar = DDR_BAR_ID;\n\tinbound_region.addr = DRAM_PHYS_BASE;\n\trc = hl_pci_set_inbound_region(hdev, 1, &inbound_region);\n\tif (rc)\n\t\tgoto done;\n\n\t \n\toutbound_region.addr = HOST_PHYS_BASE;\n\toutbound_region.size = HOST_PHYS_SIZE;\n\trc = hl_pci_set_outbound_region(hdev, &outbound_region);\n\ndone:\n\treturn rc;\n}\n\nstatic enum hl_device_hw_state goya_get_hw_state(struct hl_device *hdev)\n{\n\treturn RREG32(mmHW_STATE);\n}\n\n \nstatic int goya_early_init(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct pci_dev *pdev = hdev->pdev;\n\tresource_size_t pci_bar_size;\n\tu32 fw_boot_status, val;\n\tint rc;\n\n\trc = goya_set_fixed_properties(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to get fixed properties\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tpci_bar_size = pci_resource_len(pdev, SRAM_CFG_BAR_ID);\n\n\tif (pci_bar_size != CFG_BAR_SIZE) {\n\t\tdev_err(hdev->dev, \"Not \" HL_NAME \"? BAR %d size %pa, expecting %llu\\n\",\n\t\t\tSRAM_CFG_BAR_ID, &pci_bar_size, CFG_BAR_SIZE);\n\t\trc = -ENODEV;\n\t\tgoto free_queue_props;\n\t}\n\n\tpci_bar_size = pci_resource_len(pdev, MSIX_BAR_ID);\n\n\tif (pci_bar_size != MSIX_BAR_SIZE) {\n\t\tdev_err(hdev->dev, \"Not \" HL_NAME \"? BAR %d size %pa, expecting %llu\\n\",\n\t\t\tMSIX_BAR_ID, &pci_bar_size, MSIX_BAR_SIZE);\n\t\trc = -ENODEV;\n\t\tgoto free_queue_props;\n\t}\n\n\tprop->dram_pci_bar_size = pci_resource_len(pdev, DDR_BAR_ID);\n\thdev->dram_pci_bar_start = pci_resource_start(pdev, DDR_BAR_ID);\n\n\t \n\tif (hdev->asic_prop.fw_security_enabled) {\n\t\thdev->asic_prop.iatu_done_by_fw = true;\n\t\tgoto pci_init;\n\t}\n\n\trc = hl_pci_elbi_read(hdev, CFG_BASE + mmCPU_BOOT_DEV_STS0,\n\t\t\t\t&fw_boot_status);\n\tif (rc)\n\t\tgoto free_queue_props;\n\n\t \n\tif ((fw_boot_status & CPU_BOOT_DEV_STS0_ENABLED) &&\n\t\t\t(fw_boot_status & CPU_BOOT_DEV_STS0_FW_IATU_CONF_EN))\n\t\thdev->asic_prop.iatu_done_by_fw = true;\n\npci_init:\n\trc = hl_pci_init(hdev);\n\tif (rc)\n\t\tgoto free_queue_props;\n\n\t \n\trc = hl_fw_read_preboot_status(hdev);\n\tif (rc) {\n\t\tif (hdev->reset_on_preboot_fail)\n\t\t\t \n\t\t\thdev->asic_funcs->hw_fini(hdev, true, false);\n\t\tgoto pci_fini;\n\t}\n\n\tif (goya_get_hw_state(hdev) == HL_DEVICE_HW_STATE_DIRTY) {\n\t\tdev_dbg(hdev->dev, \"H/W state is dirty, must reset before initializing\\n\");\n\t\trc = hdev->asic_funcs->hw_fini(hdev, true, false);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev, \"failed to reset HW in dirty state (%d)\\n\", rc);\n\t\t\tgoto pci_fini;\n\t\t}\n\t}\n\n\tif (!hdev->pldm) {\n\t\tval = RREG32(mmPSOC_GLOBAL_CONF_BOOT_STRAP_PINS);\n\t\tif (val & PSOC_GLOBAL_CONF_BOOT_STRAP_PINS_SRIOV_EN_MASK)\n\t\t\tdev_warn(hdev->dev,\n\t\t\t\t\"PCI strap is not configured correctly, PCI bus errors may occur\\n\");\n\t}\n\n\treturn 0;\n\npci_fini:\n\thl_pci_fini(hdev);\nfree_queue_props:\n\tkfree(hdev->asic_prop.hw_queues_props);\n\treturn rc;\n}\n\n \nstatic int goya_early_fini(struct hl_device *hdev)\n{\n\tkfree(hdev->asic_prop.hw_queues_props);\n\thl_pci_fini(hdev);\n\n\treturn 0;\n}\n\nstatic void goya_mmu_prepare_reg(struct hl_device *hdev, u64 reg, u32 asid)\n{\n\t \n\tWREG32_AND(reg, ~0x7FF);\n\tWREG32_OR(reg, asid);\n}\n\nstatic void goya_qman0_set_security(struct hl_device *hdev, bool secure)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_MMU))\n\t\treturn;\n\n\tif (secure)\n\t\tWREG32(mmDMA_QM_0_GLBL_PROT, QMAN_DMA_FULLY_TRUSTED);\n\telse\n\t\tWREG32(mmDMA_QM_0_GLBL_PROT, QMAN_DMA_PARTLY_TRUSTED);\n\n\tRREG32(mmDMA_QM_0_GLBL_PROT);\n}\n\n \nstatic void goya_fetch_psoc_frequency(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu32 nr = 0, nf = 0, od = 0, div_fctr = 0, pll_clk, div_sel;\n\tu16 pll_freq_arr[HL_PLL_NUM_OUTPUTS], freq;\n\tint rc;\n\n\tif (hdev->asic_prop.fw_security_enabled) {\n\t\tstruct goya_device *goya = hdev->asic_specific;\n\n\t\tif (!(goya->hw_cap_initialized & HW_CAP_CPU_Q))\n\t\t\treturn;\n\n\t\trc = hl_fw_cpucp_pll_info_get(hdev, HL_GOYA_PCI_PLL,\n\t\t\t\tpll_freq_arr);\n\n\t\tif (rc)\n\t\t\treturn;\n\n\t\tfreq = pll_freq_arr[1];\n\t} else {\n\t\tdiv_fctr = RREG32(mmPSOC_PCI_PLL_DIV_FACTOR_1);\n\t\tdiv_sel = RREG32(mmPSOC_PCI_PLL_DIV_SEL_1);\n\t\tnr = RREG32(mmPSOC_PCI_PLL_NR);\n\t\tnf = RREG32(mmPSOC_PCI_PLL_NF);\n\t\tod = RREG32(mmPSOC_PCI_PLL_OD);\n\n\t\tif (div_sel == DIV_SEL_REF_CLK ||\n\t\t\t\tdiv_sel == DIV_SEL_DIVIDED_REF) {\n\t\t\tif (div_sel == DIV_SEL_REF_CLK)\n\t\t\t\tfreq = PLL_REF_CLK;\n\t\t\telse\n\t\t\t\tfreq = PLL_REF_CLK / (div_fctr + 1);\n\t\t} else if (div_sel == DIV_SEL_PLL_CLK ||\n\t\t\t\tdiv_sel == DIV_SEL_DIVIDED_PLL) {\n\t\t\tpll_clk = PLL_REF_CLK * (nf + 1) /\n\t\t\t\t\t((nr + 1) * (od + 1));\n\t\t\tif (div_sel == DIV_SEL_PLL_CLK)\n\t\t\t\tfreq = pll_clk;\n\t\t\telse\n\t\t\t\tfreq = pll_clk / (div_fctr + 1);\n\t\t} else {\n\t\t\tdev_warn(hdev->dev,\n\t\t\t\t\"Received invalid div select value: %d\",\n\t\t\t\tdiv_sel);\n\t\t\tfreq = 0;\n\t\t}\n\t}\n\n\tprop->psoc_timestamp_frequency = freq;\n\tprop->psoc_pci_pll_nr = nr;\n\tprop->psoc_pci_pll_nf = nf;\n\tprop->psoc_pci_pll_od = od;\n\tprop->psoc_pci_pll_div_factor = div_fctr;\n}\n\n \nint goya_set_frequency(struct hl_device *hdev, enum hl_pll_frequency freq)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif ((goya->pm_mng_profile == PM_MANUAL) ||\n\t\t\t(goya->curr_pll_profile == freq))\n\t\treturn 0;\n\n\tdev_dbg(hdev->dev, \"Changing device frequency to %s\\n\",\n\t\tfreq == PLL_HIGH ? \"high\" : \"low\");\n\n\tgoya_set_pll_profile(hdev, freq);\n\n\tgoya->curr_pll_profile = freq;\n\n\treturn 1;\n}\n\nstatic void goya_set_freq_to_low_job(struct work_struct *work)\n{\n\tstruct goya_work_freq *goya_work = container_of(work,\n\t\t\t\t\t\tstruct goya_work_freq,\n\t\t\t\t\t\twork_freq.work);\n\tstruct hl_device *hdev = goya_work->hdev;\n\n\tmutex_lock(&hdev->fpriv_list_lock);\n\n\tif (!hdev->is_compute_ctx_active)\n\t\tgoya_set_frequency(hdev, PLL_LOW);\n\n\tmutex_unlock(&hdev->fpriv_list_lock);\n\n\tschedule_delayed_work(&goya_work->work_freq,\n\t\t\tusecs_to_jiffies(HL_PLL_LOW_JOB_FREQ_USEC));\n}\n\nint goya_late_init(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct goya_device *goya = hdev->asic_specific;\n\tint rc;\n\n\tgoya_fetch_psoc_frequency(hdev);\n\n\trc = goya_mmu_clear_pgt_range(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to clear MMU page tables range %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = goya_mmu_set_dram_default_page(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to set DRAM default page %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = goya_mmu_add_mappings_for_device_cpu(hdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = goya_init_cpu_queues(hdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = goya_test_cpu_queue(hdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = goya_cpucp_info_get(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to get cpucp info %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tWREG32(mmMMU_LOG2_DDR_SIZE, ilog2(prop->dram_size));\n\n\trc = hl_fw_send_pci_access_msg(hdev, CPUCP_PACKET_ENABLE_PCI_ACCESS, 0x0);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to enable PCI access from CPU %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tgoya->curr_pll_profile = PLL_LOW;\n\n\tgoya->pm_mng_profile = PM_AUTO;\n\n\tgoya_set_pll_profile(hdev, PLL_LOW);\n\n\tschedule_delayed_work(&goya->goya_work->work_freq,\n\t\tusecs_to_jiffies(HL_PLL_LOW_JOB_FREQ_USEC));\n\n\treturn 0;\n}\n\n \nvoid goya_late_fini(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tcancel_delayed_work_sync(&goya->goya_work->work_freq);\n\n\thl_hwmon_release_resources(hdev);\n}\n\nstatic void goya_set_pci_memory_regions(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct pci_mem_region *region;\n\n\t \n\tregion = &hdev->pci_mem_region[PCI_REGION_CFG];\n\tregion->region_base = CFG_BASE;\n\tregion->region_size = CFG_SIZE;\n\tregion->offset_in_bar = CFG_BASE - SRAM_BASE_ADDR;\n\tregion->bar_size = CFG_BAR_SIZE;\n\tregion->bar_id = SRAM_CFG_BAR_ID;\n\tregion->used = 1;\n\n\t \n\tregion = &hdev->pci_mem_region[PCI_REGION_SRAM];\n\tregion->region_base = SRAM_BASE_ADDR;\n\tregion->region_size = SRAM_SIZE;\n\tregion->offset_in_bar = 0;\n\tregion->bar_size = CFG_BAR_SIZE;\n\tregion->bar_id = SRAM_CFG_BAR_ID;\n\tregion->used = 1;\n\n\t \n\tregion = &hdev->pci_mem_region[PCI_REGION_DRAM];\n\tregion->region_base = DRAM_PHYS_BASE;\n\tregion->region_size = hdev->asic_prop.dram_size;\n\tregion->offset_in_bar = 0;\n\tregion->bar_size = prop->dram_pci_bar_size;\n\tregion->bar_id = DDR_BAR_ID;\n\tregion->used = 1;\n}\n\n \nstatic int goya_sw_init(struct hl_device *hdev)\n{\n\tstruct goya_device *goya;\n\tint rc;\n\n\t \n\tgoya = kzalloc(sizeof(*goya), GFP_KERNEL);\n\tif (!goya)\n\t\treturn -ENOMEM;\n\n\t \n\tgoya->ddr_bar_cur_addr = DRAM_PHYS_BASE;\n\n\tgoya->mme_clk = GOYA_PLL_FREQ_LOW;\n\tgoya->tpc_clk = GOYA_PLL_FREQ_LOW;\n\tgoya->ic_clk = GOYA_PLL_FREQ_LOW;\n\n\thdev->asic_specific = goya;\n\n\t \n\thdev->dma_pool = dma_pool_create(dev_name(hdev->dev),\n\t\t\t&hdev->pdev->dev, GOYA_DMA_POOL_BLK_SIZE, 8, 0);\n\tif (!hdev->dma_pool) {\n\t\tdev_err(hdev->dev, \"failed to create DMA pool\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto free_goya_device;\n\t}\n\n\thdev->cpu_accessible_dma_mem = hl_asic_dma_alloc_coherent(hdev, HL_CPU_ACCESSIBLE_MEM_SIZE,\n\t\t\t\t\t\t\t&hdev->cpu_accessible_dma_address,\n\t\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\n\tif (!hdev->cpu_accessible_dma_mem) {\n\t\trc = -ENOMEM;\n\t\tgoto free_dma_pool;\n\t}\n\n\tdev_dbg(hdev->dev, \"cpu accessible memory at bus address %pad\\n\",\n\t\t&hdev->cpu_accessible_dma_address);\n\n\thdev->cpu_accessible_dma_pool = gen_pool_create(ilog2(32), -1);\n\tif (!hdev->cpu_accessible_dma_pool) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to create CPU accessible DMA pool\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto free_cpu_dma_mem;\n\t}\n\n\trc = gen_pool_add(hdev->cpu_accessible_dma_pool,\n\t\t\t\t(uintptr_t) hdev->cpu_accessible_dma_mem,\n\t\t\t\tHL_CPU_ACCESSIBLE_MEM_SIZE, -1);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to add memory to CPU accessible DMA pool\\n\");\n\t\trc = -EFAULT;\n\t\tgoto free_cpu_accessible_dma_pool;\n\t}\n\n\tspin_lock_init(&goya->hw_queues_lock);\n\thdev->supports_coresight = true;\n\thdev->asic_prop.supports_compute_reset = true;\n\thdev->asic_prop.allow_inference_soft_reset = true;\n\thdev->supports_wait_for_multi_cs = false;\n\thdev->supports_ctx_switch = true;\n\n\thdev->asic_funcs->set_pci_memory_regions(hdev);\n\n\tgoya->goya_work = kmalloc(sizeof(struct goya_work_freq), GFP_KERNEL);\n\tif (!goya->goya_work) {\n\t\trc = -ENOMEM;\n\t\tgoto free_cpu_accessible_dma_pool;\n\t}\n\n\tgoya->goya_work->hdev = hdev;\n\tINIT_DELAYED_WORK(&goya->goya_work->work_freq, goya_set_freq_to_low_job);\n\n\treturn 0;\n\nfree_cpu_accessible_dma_pool:\n\tgen_pool_destroy(hdev->cpu_accessible_dma_pool);\nfree_cpu_dma_mem:\n\thl_asic_dma_free_coherent(hdev, HL_CPU_ACCESSIBLE_MEM_SIZE, hdev->cpu_accessible_dma_mem,\n\t\t\t\t\thdev->cpu_accessible_dma_address);\nfree_dma_pool:\n\tdma_pool_destroy(hdev->dma_pool);\nfree_goya_device:\n\tkfree(goya);\n\n\treturn rc;\n}\n\n \nstatic int goya_sw_fini(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tgen_pool_destroy(hdev->cpu_accessible_dma_pool);\n\n\thl_asic_dma_free_coherent(hdev, HL_CPU_ACCESSIBLE_MEM_SIZE, hdev->cpu_accessible_dma_mem,\n\t\t\t\t\thdev->cpu_accessible_dma_address);\n\n\tdma_pool_destroy(hdev->dma_pool);\n\n\tkfree(goya->goya_work);\n\tkfree(goya);\n\n\treturn 0;\n}\n\nstatic void goya_init_dma_qman(struct hl_device *hdev, int dma_id,\n\t\tdma_addr_t bus_address)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tu32 mtr_base_lo, mtr_base_hi;\n\tu32 so_base_lo, so_base_hi;\n\tu32 gic_base_lo, gic_base_hi;\n\tu32 reg_off = dma_id * (mmDMA_QM_1_PQ_PI - mmDMA_QM_0_PQ_PI);\n\tu32 dma_err_cfg = QMAN_DMA_ERR_MSG_EN;\n\n\tmtr_base_lo = lower_32_bits(CFG_BASE + mmSYNC_MNGR_MON_PAY_ADDRL_0);\n\tmtr_base_hi = upper_32_bits(CFG_BASE + mmSYNC_MNGR_MON_PAY_ADDRL_0);\n\tso_base_lo = lower_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\tso_base_hi = upper_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\n\tgic_base_lo =\n\t\tlower_32_bits(CFG_BASE + mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR);\n\tgic_base_hi =\n\t\tupper_32_bits(CFG_BASE + mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR);\n\n\tWREG32(mmDMA_QM_0_PQ_BASE_LO + reg_off, lower_32_bits(bus_address));\n\tWREG32(mmDMA_QM_0_PQ_BASE_HI + reg_off, upper_32_bits(bus_address));\n\n\tWREG32(mmDMA_QM_0_PQ_SIZE + reg_off, ilog2(HL_QUEUE_LENGTH));\n\tWREG32(mmDMA_QM_0_PQ_PI + reg_off, 0);\n\tWREG32(mmDMA_QM_0_PQ_CI + reg_off, 0);\n\n\tWREG32(mmDMA_QM_0_CP_MSG_BASE0_ADDR_LO + reg_off, mtr_base_lo);\n\tWREG32(mmDMA_QM_0_CP_MSG_BASE0_ADDR_HI + reg_off, mtr_base_hi);\n\tWREG32(mmDMA_QM_0_CP_MSG_BASE1_ADDR_LO + reg_off, so_base_lo);\n\tWREG32(mmDMA_QM_0_CP_MSG_BASE1_ADDR_HI + reg_off, so_base_hi);\n\tWREG32(mmDMA_QM_0_GLBL_ERR_ADDR_LO + reg_off, gic_base_lo);\n\tWREG32(mmDMA_QM_0_GLBL_ERR_ADDR_HI + reg_off, gic_base_hi);\n\tWREG32(mmDMA_QM_0_GLBL_ERR_WDATA + reg_off,\n\t\t\tGOYA_ASYNC_EVENT_ID_DMA0_QM + dma_id);\n\n\t \n\tWREG32(mmDMA_QM_0_PQ_CFG1 + reg_off, 0x00020002);\n\tWREG32(mmDMA_QM_0_CQ_CFG1 + reg_off, 0x00080008);\n\n\tif (goya->hw_cap_initialized & HW_CAP_MMU)\n\t\tWREG32(mmDMA_QM_0_GLBL_PROT + reg_off, QMAN_DMA_PARTLY_TRUSTED);\n\telse\n\t\tWREG32(mmDMA_QM_0_GLBL_PROT + reg_off, QMAN_DMA_FULLY_TRUSTED);\n\n\tif (hdev->stop_on_err)\n\t\tdma_err_cfg |= 1 << DMA_QM_0_GLBL_ERR_CFG_DMA_STOP_ON_ERR_SHIFT;\n\n\tWREG32(mmDMA_QM_0_GLBL_ERR_CFG + reg_off, dma_err_cfg);\n\tWREG32(mmDMA_QM_0_GLBL_CFG0 + reg_off, QMAN_DMA_ENABLE);\n}\n\nstatic void goya_init_dma_ch(struct hl_device *hdev, int dma_id)\n{\n\tu32 gic_base_lo, gic_base_hi;\n\tu64 sob_addr;\n\tu32 reg_off = dma_id * (mmDMA_CH_1_CFG1 - mmDMA_CH_0_CFG1);\n\n\tgic_base_lo =\n\t\tlower_32_bits(CFG_BASE + mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR);\n\tgic_base_hi =\n\t\tupper_32_bits(CFG_BASE + mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR);\n\n\tWREG32(mmDMA_CH_0_ERRMSG_ADDR_LO + reg_off, gic_base_lo);\n\tWREG32(mmDMA_CH_0_ERRMSG_ADDR_HI + reg_off, gic_base_hi);\n\tWREG32(mmDMA_CH_0_ERRMSG_WDATA + reg_off,\n\t\t\tGOYA_ASYNC_EVENT_ID_DMA0_CH + dma_id);\n\n\tif (dma_id)\n\t\tsob_addr = CFG_BASE + mmSYNC_MNGR_SOB_OBJ_1000 +\n\t\t\t\t(dma_id - 1) * 4;\n\telse\n\t\tsob_addr = CFG_BASE + mmSYNC_MNGR_SOB_OBJ_1007;\n\n\tWREG32(mmDMA_CH_0_WR_COMP_ADDR_HI + reg_off, upper_32_bits(sob_addr));\n\tWREG32(mmDMA_CH_0_WR_COMP_WDATA + reg_off, 0x80000001);\n}\n\n \nvoid goya_init_dma_qmans(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tstruct hl_hw_queue *q;\n\tint i;\n\n\tif (goya->hw_cap_initialized & HW_CAP_DMA)\n\t\treturn;\n\n\tq = &hdev->kernel_queues[0];\n\n\tfor (i = 0 ; i < NUMBER_OF_EXT_HW_QUEUES ; i++, q++) {\n\t\tq->cq_id = q->msi_vec = i;\n\t\tgoya_init_dma_qman(hdev, i, q->bus_address);\n\t\tgoya_init_dma_ch(hdev, i);\n\t}\n\n\tgoya->hw_cap_initialized |= HW_CAP_DMA;\n}\n\n \nstatic void goya_disable_external_queues(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_DMA))\n\t\treturn;\n\n\tWREG32(mmDMA_QM_0_GLBL_CFG0, 0);\n\tWREG32(mmDMA_QM_1_GLBL_CFG0, 0);\n\tWREG32(mmDMA_QM_2_GLBL_CFG0, 0);\n\tWREG32(mmDMA_QM_3_GLBL_CFG0, 0);\n\tWREG32(mmDMA_QM_4_GLBL_CFG0, 0);\n}\n\nstatic int goya_stop_queue(struct hl_device *hdev, u32 cfg_reg,\n\t\t\t\tu32 cp_sts_reg, u32 glbl_sts0_reg)\n{\n\tint rc;\n\tu32 status;\n\n\t \n\n\tWREG32(cfg_reg, 1 << TPC0_QM_GLBL_CFG1_CP_STOP_SHIFT);\n\n\tstatus = RREG32(cp_sts_reg);\n\tif (status & TPC0_QM_CP_STS_FENCE_IN_PROGRESS_MASK) {\n\t\trc = hl_poll_timeout(\n\t\t\thdev,\n\t\t\tcp_sts_reg,\n\t\t\tstatus,\n\t\t\t!(status & TPC0_QM_CP_STS_FENCE_IN_PROGRESS_MASK),\n\t\t\t1000,\n\t\t\tQMAN_FENCE_TIMEOUT_USEC);\n\n\t\t \n\t\tif (rc)\n\t\t\treturn 0;\n\t}\n\n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tglbl_sts0_reg,\n\t\tstatus,\n\t\t(status & TPC0_QM_GLBL_STS0_CP_IS_STOP_MASK),\n\t\t1000,\n\t\tQMAN_STOP_TIMEOUT_USEC);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Timeout while waiting for QMAN to stop\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int goya_stop_external_queues(struct hl_device *hdev)\n{\n\tint rc, retval = 0;\n\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_DMA))\n\t\treturn retval;\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmDMA_QM_0_GLBL_CFG1,\n\t\t\tmmDMA_QM_0_CP_STS,\n\t\t\tmmDMA_QM_0_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop DMA QMAN 0\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmDMA_QM_1_GLBL_CFG1,\n\t\t\tmmDMA_QM_1_CP_STS,\n\t\t\tmmDMA_QM_1_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop DMA QMAN 1\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmDMA_QM_2_GLBL_CFG1,\n\t\t\tmmDMA_QM_2_CP_STS,\n\t\t\tmmDMA_QM_2_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop DMA QMAN 2\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmDMA_QM_3_GLBL_CFG1,\n\t\t\tmmDMA_QM_3_CP_STS,\n\t\t\tmmDMA_QM_3_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop DMA QMAN 3\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmDMA_QM_4_GLBL_CFG1,\n\t\t\tmmDMA_QM_4_CP_STS,\n\t\t\tmmDMA_QM_4_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop DMA QMAN 4\\n\");\n\t\tretval = -EIO;\n\t}\n\n\treturn retval;\n}\n\n \nint goya_init_cpu_queues(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct hl_eq *eq;\n\tu32 status;\n\tstruct hl_hw_queue *cpu_pq = &hdev->kernel_queues[GOYA_QUEUE_ID_CPU_PQ];\n\tint err;\n\n\tif (!hdev->cpu_queues_enable)\n\t\treturn 0;\n\n\tif (goya->hw_cap_initialized & HW_CAP_CPU_Q)\n\t\treturn 0;\n\n\teq = &hdev->event_queue;\n\n\tWREG32(mmCPU_PQ_BASE_ADDR_LOW, lower_32_bits(cpu_pq->bus_address));\n\tWREG32(mmCPU_PQ_BASE_ADDR_HIGH, upper_32_bits(cpu_pq->bus_address));\n\n\tWREG32(mmCPU_EQ_BASE_ADDR_LOW, lower_32_bits(eq->bus_address));\n\tWREG32(mmCPU_EQ_BASE_ADDR_HIGH, upper_32_bits(eq->bus_address));\n\n\tWREG32(mmCPU_CQ_BASE_ADDR_LOW,\n\t\t\tlower_32_bits(VA_CPU_ACCESSIBLE_MEM_ADDR));\n\tWREG32(mmCPU_CQ_BASE_ADDR_HIGH,\n\t\t\tupper_32_bits(VA_CPU_ACCESSIBLE_MEM_ADDR));\n\n\tWREG32(mmCPU_PQ_LENGTH, HL_QUEUE_SIZE_IN_BYTES);\n\tWREG32(mmCPU_EQ_LENGTH, HL_EQ_SIZE_IN_BYTES);\n\tWREG32(mmCPU_CQ_LENGTH, HL_CPU_ACCESSIBLE_MEM_SIZE);\n\n\t \n\tWREG32(mmCPU_EQ_CI, 0);\n\n\tWREG32(mmCPU_IF_PF_PQ_PI, 0);\n\n\tWREG32(mmCPU_PQ_INIT_STATUS, PQ_INIT_STATUS_READY_FOR_CP);\n\n\tWREG32(mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR,\n\t\t\tGOYA_ASYNC_EVENT_ID_PI_UPDATE);\n\n\terr = hl_poll_timeout(\n\t\thdev,\n\t\tmmCPU_PQ_INIT_STATUS,\n\t\tstatus,\n\t\t(status == PQ_INIT_STATUS_READY_FOR_HOST),\n\t\t1000,\n\t\tGOYA_CPU_TIMEOUT_USEC);\n\n\tif (err) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to setup communication with device CPU\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (prop->fw_cpu_boot_dev_sts0_valid)\n\t\tprop->fw_app_cpu_boot_dev_sts0 = RREG32(mmCPU_BOOT_DEV_STS0);\n\n\tif (prop->fw_cpu_boot_dev_sts1_valid)\n\t\tprop->fw_app_cpu_boot_dev_sts1 = RREG32(mmCPU_BOOT_DEV_STS1);\n\n\tgoya->hw_cap_initialized |= HW_CAP_CPU_Q;\n\treturn 0;\n}\n\nstatic void goya_set_pll_refclk(struct hl_device *hdev)\n{\n\tWREG32(mmCPU_PLL_DIV_SEL_0, 0x0);\n\tWREG32(mmCPU_PLL_DIV_SEL_1, 0x0);\n\tWREG32(mmCPU_PLL_DIV_SEL_2, 0x0);\n\tWREG32(mmCPU_PLL_DIV_SEL_3, 0x0);\n\n\tWREG32(mmIC_PLL_DIV_SEL_0, 0x0);\n\tWREG32(mmIC_PLL_DIV_SEL_1, 0x0);\n\tWREG32(mmIC_PLL_DIV_SEL_2, 0x0);\n\tWREG32(mmIC_PLL_DIV_SEL_3, 0x0);\n\n\tWREG32(mmMC_PLL_DIV_SEL_0, 0x0);\n\tWREG32(mmMC_PLL_DIV_SEL_1, 0x0);\n\tWREG32(mmMC_PLL_DIV_SEL_2, 0x0);\n\tWREG32(mmMC_PLL_DIV_SEL_3, 0x0);\n\n\tWREG32(mmPSOC_MME_PLL_DIV_SEL_0, 0x0);\n\tWREG32(mmPSOC_MME_PLL_DIV_SEL_1, 0x0);\n\tWREG32(mmPSOC_MME_PLL_DIV_SEL_2, 0x0);\n\tWREG32(mmPSOC_MME_PLL_DIV_SEL_3, 0x0);\n\n\tWREG32(mmPSOC_PCI_PLL_DIV_SEL_0, 0x0);\n\tWREG32(mmPSOC_PCI_PLL_DIV_SEL_1, 0x0);\n\tWREG32(mmPSOC_PCI_PLL_DIV_SEL_2, 0x0);\n\tWREG32(mmPSOC_PCI_PLL_DIV_SEL_3, 0x0);\n\n\tWREG32(mmPSOC_EMMC_PLL_DIV_SEL_0, 0x0);\n\tWREG32(mmPSOC_EMMC_PLL_DIV_SEL_1, 0x0);\n\tWREG32(mmPSOC_EMMC_PLL_DIV_SEL_2, 0x0);\n\tWREG32(mmPSOC_EMMC_PLL_DIV_SEL_3, 0x0);\n\n\tWREG32(mmTPC_PLL_DIV_SEL_0, 0x0);\n\tWREG32(mmTPC_PLL_DIV_SEL_1, 0x0);\n\tWREG32(mmTPC_PLL_DIV_SEL_2, 0x0);\n\tWREG32(mmTPC_PLL_DIV_SEL_3, 0x0);\n}\n\nstatic void goya_disable_clk_rlx(struct hl_device *hdev)\n{\n\tWREG32(mmPSOC_MME_PLL_CLK_RLX_0, 0x100010);\n\tWREG32(mmIC_PLL_CLK_RLX_0, 0x100010);\n}\n\nstatic void _goya_tpc_mbist_workaround(struct hl_device *hdev, u8 tpc_id)\n{\n\tu64 tpc_eml_address;\n\tu32 val, tpc_offset, tpc_eml_offset, tpc_slm_offset;\n\tint err, slm_index;\n\n\ttpc_offset = tpc_id * 0x40000;\n\ttpc_eml_offset = tpc_id * 0x200000;\n\ttpc_eml_address = (mmTPC0_EML_CFG_BASE + tpc_eml_offset - CFG_BASE);\n\ttpc_slm_offset = tpc_eml_address + 0x100000;\n\n\t \n\n\tval = RREG32(mmTPC0_CFG_FUNC_MBIST_CNTRL + tpc_offset);\n\tif (val & TPC0_CFG_FUNC_MBIST_CNTRL_MBIST_ACTIVE_MASK)\n\t\tdev_warn(hdev->dev, \"TPC%d MBIST ACTIVE is not cleared\\n\",\n\t\t\ttpc_id);\n\n\tWREG32(mmTPC0_CFG_FUNC_MBIST_PAT + tpc_offset, val & 0xFFFFF000);\n\n\tWREG32(mmTPC0_CFG_FUNC_MBIST_MEM_0 + tpc_offset, 0x37FF);\n\tWREG32(mmTPC0_CFG_FUNC_MBIST_MEM_1 + tpc_offset, 0x303F);\n\tWREG32(mmTPC0_CFG_FUNC_MBIST_MEM_2 + tpc_offset, 0x71FF);\n\tWREG32(mmTPC0_CFG_FUNC_MBIST_MEM_3 + tpc_offset, 0x71FF);\n\tWREG32(mmTPC0_CFG_FUNC_MBIST_MEM_4 + tpc_offset, 0x70FF);\n\tWREG32(mmTPC0_CFG_FUNC_MBIST_MEM_5 + tpc_offset, 0x70FF);\n\tWREG32(mmTPC0_CFG_FUNC_MBIST_MEM_6 + tpc_offset, 0x70FF);\n\tWREG32(mmTPC0_CFG_FUNC_MBIST_MEM_7 + tpc_offset, 0x70FF);\n\tWREG32(mmTPC0_CFG_FUNC_MBIST_MEM_8 + tpc_offset, 0x70FF);\n\tWREG32(mmTPC0_CFG_FUNC_MBIST_MEM_9 + tpc_offset, 0x70FF);\n\n\tWREG32_OR(mmTPC0_CFG_FUNC_MBIST_CNTRL + tpc_offset,\n\t\t1 << TPC0_CFG_FUNC_MBIST_CNTRL_MBIST_START_SHIFT);\n\n\terr = hl_poll_timeout(\n\t\thdev,\n\t\tmmTPC0_CFG_FUNC_MBIST_CNTRL + tpc_offset,\n\t\tval,\n\t\t(val & TPC0_CFG_FUNC_MBIST_CNTRL_MBIST_DONE_MASK),\n\t\t1000,\n\t\tHL_DEVICE_TIMEOUT_USEC);\n\n\tif (err)\n\t\tdev_err(hdev->dev,\n\t\t\t\"Timeout while waiting for TPC%d MBIST DONE\\n\", tpc_id);\n\n\tWREG32_OR(mmTPC0_EML_CFG_DBG_CNT + tpc_eml_offset,\n\t\t1 << TPC0_EML_CFG_DBG_CNT_CORE_RST_SHIFT);\n\n\tmsleep(GOYA_RESET_WAIT_MSEC);\n\n\tWREG32_AND(mmTPC0_EML_CFG_DBG_CNT + tpc_eml_offset,\n\t\t~(1 << TPC0_EML_CFG_DBG_CNT_CORE_RST_SHIFT));\n\n\tmsleep(GOYA_RESET_WAIT_MSEC);\n\n\tfor (slm_index = 0 ; slm_index < 256 ; slm_index++)\n\t\tWREG32(tpc_slm_offset + (slm_index << 2), 0);\n\n\tval = RREG32(tpc_slm_offset);\n}\n\nstatic void goya_tpc_mbist_workaround(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tint i;\n\n\tif (hdev->pldm)\n\t\treturn;\n\n\tif (goya->hw_cap_initialized & HW_CAP_TPC_MBIST)\n\t\treturn;\n\n\t \n\n\tfor (i = 0 ; i < TPC_MAX_NUM ; i++)\n\t\t_goya_tpc_mbist_workaround(hdev, i);\n\n\tgoya->hw_cap_initialized |= HW_CAP_TPC_MBIST;\n}\n\n \nstatic void goya_init_golden_registers(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tu32 polynom[10], tpc_intr_mask, offset;\n\tint i;\n\n\tif (goya->hw_cap_initialized & HW_CAP_GOLDEN)\n\t\treturn;\n\n\tpolynom[0] = 0x00020080;\n\tpolynom[1] = 0x00401000;\n\tpolynom[2] = 0x00200800;\n\tpolynom[3] = 0x00002000;\n\tpolynom[4] = 0x00080200;\n\tpolynom[5] = 0x00040100;\n\tpolynom[6] = 0x00100400;\n\tpolynom[7] = 0x00004000;\n\tpolynom[8] = 0x00010000;\n\tpolynom[9] = 0x00008000;\n\n\t \n\ttpc_intr_mask = 0x7FFF;\n\n\tfor (i = 0, offset = 0 ; i < 6 ; i++, offset += 0x20000) {\n\t\tWREG32(mmSRAM_Y0_X0_RTR_HBW_RD_RQ_L_ARB + offset, 0x302);\n\t\tWREG32(mmSRAM_Y0_X1_RTR_HBW_RD_RQ_L_ARB + offset, 0x302);\n\t\tWREG32(mmSRAM_Y0_X2_RTR_HBW_RD_RQ_L_ARB + offset, 0x302);\n\t\tWREG32(mmSRAM_Y0_X3_RTR_HBW_RD_RQ_L_ARB + offset, 0x302);\n\t\tWREG32(mmSRAM_Y0_X4_RTR_HBW_RD_RQ_L_ARB + offset, 0x302);\n\n\t\tWREG32(mmSRAM_Y0_X0_RTR_HBW_DATA_L_ARB + offset, 0x204);\n\t\tWREG32(mmSRAM_Y0_X1_RTR_HBW_DATA_L_ARB + offset, 0x204);\n\t\tWREG32(mmSRAM_Y0_X2_RTR_HBW_DATA_L_ARB + offset, 0x204);\n\t\tWREG32(mmSRAM_Y0_X3_RTR_HBW_DATA_L_ARB + offset, 0x204);\n\t\tWREG32(mmSRAM_Y0_X4_RTR_HBW_DATA_L_ARB + offset, 0x204);\n\n\n\t\tWREG32(mmSRAM_Y0_X0_RTR_HBW_DATA_E_ARB + offset, 0x206);\n\t\tWREG32(mmSRAM_Y0_X1_RTR_HBW_DATA_E_ARB + offset, 0x206);\n\t\tWREG32(mmSRAM_Y0_X2_RTR_HBW_DATA_E_ARB + offset, 0x206);\n\t\tWREG32(mmSRAM_Y0_X3_RTR_HBW_DATA_E_ARB + offset, 0x207);\n\t\tWREG32(mmSRAM_Y0_X4_RTR_HBW_DATA_E_ARB + offset, 0x207);\n\n\t\tWREG32(mmSRAM_Y0_X0_RTR_HBW_DATA_W_ARB + offset, 0x207);\n\t\tWREG32(mmSRAM_Y0_X1_RTR_HBW_DATA_W_ARB + offset, 0x207);\n\t\tWREG32(mmSRAM_Y0_X2_RTR_HBW_DATA_W_ARB + offset, 0x206);\n\t\tWREG32(mmSRAM_Y0_X3_RTR_HBW_DATA_W_ARB + offset, 0x206);\n\t\tWREG32(mmSRAM_Y0_X4_RTR_HBW_DATA_W_ARB + offset, 0x206);\n\n\t\tWREG32(mmSRAM_Y0_X0_RTR_HBW_WR_RS_E_ARB + offset, 0x101);\n\t\tWREG32(mmSRAM_Y0_X1_RTR_HBW_WR_RS_E_ARB + offset, 0x102);\n\t\tWREG32(mmSRAM_Y0_X2_RTR_HBW_WR_RS_E_ARB + offset, 0x103);\n\t\tWREG32(mmSRAM_Y0_X3_RTR_HBW_WR_RS_E_ARB + offset, 0x104);\n\t\tWREG32(mmSRAM_Y0_X4_RTR_HBW_WR_RS_E_ARB + offset, 0x105);\n\n\t\tWREG32(mmSRAM_Y0_X0_RTR_HBW_WR_RS_W_ARB + offset, 0x105);\n\t\tWREG32(mmSRAM_Y0_X1_RTR_HBW_WR_RS_W_ARB + offset, 0x104);\n\t\tWREG32(mmSRAM_Y0_X2_RTR_HBW_WR_RS_W_ARB + offset, 0x103);\n\t\tWREG32(mmSRAM_Y0_X3_RTR_HBW_WR_RS_W_ARB + offset, 0x102);\n\t\tWREG32(mmSRAM_Y0_X4_RTR_HBW_WR_RS_W_ARB + offset, 0x101);\n\t}\n\n\tWREG32(mmMME_STORE_MAX_CREDIT, 0x21);\n\tWREG32(mmMME_AGU, 0x0f0f0f10);\n\tWREG32(mmMME_SEI_MASK, ~0x0);\n\n\tWREG32(mmMME6_RTR_HBW_RD_RQ_N_ARB, 0x01010101);\n\tWREG32(mmMME5_RTR_HBW_RD_RQ_N_ARB, 0x01040101);\n\tWREG32(mmMME4_RTR_HBW_RD_RQ_N_ARB, 0x01030101);\n\tWREG32(mmMME3_RTR_HBW_RD_RQ_N_ARB, 0x01020101);\n\tWREG32(mmMME2_RTR_HBW_RD_RQ_N_ARB, 0x01010101);\n\tWREG32(mmMME1_RTR_HBW_RD_RQ_N_ARB, 0x07010701);\n\tWREG32(mmMME6_RTR_HBW_RD_RQ_S_ARB, 0x04010401);\n\tWREG32(mmMME5_RTR_HBW_RD_RQ_S_ARB, 0x04050401);\n\tWREG32(mmMME4_RTR_HBW_RD_RQ_S_ARB, 0x03070301);\n\tWREG32(mmMME3_RTR_HBW_RD_RQ_S_ARB, 0x01030101);\n\tWREG32(mmMME2_RTR_HBW_RD_RQ_S_ARB, 0x01040101);\n\tWREG32(mmMME1_RTR_HBW_RD_RQ_S_ARB, 0x01050105);\n\tWREG32(mmMME6_RTR_HBW_RD_RQ_W_ARB, 0x01010501);\n\tWREG32(mmMME5_RTR_HBW_RD_RQ_W_ARB, 0x01010501);\n\tWREG32(mmMME4_RTR_HBW_RD_RQ_W_ARB, 0x01040301);\n\tWREG32(mmMME3_RTR_HBW_RD_RQ_W_ARB, 0x01030401);\n\tWREG32(mmMME2_RTR_HBW_RD_RQ_W_ARB, 0x01040101);\n\tWREG32(mmMME1_RTR_HBW_RD_RQ_W_ARB, 0x01050101);\n\tWREG32(mmMME6_RTR_HBW_WR_RQ_N_ARB, 0x02020202);\n\tWREG32(mmMME5_RTR_HBW_WR_RQ_N_ARB, 0x01070101);\n\tWREG32(mmMME4_RTR_HBW_WR_RQ_N_ARB, 0x02020201);\n\tWREG32(mmMME3_RTR_HBW_WR_RQ_N_ARB, 0x07020701);\n\tWREG32(mmMME2_RTR_HBW_WR_RQ_N_ARB, 0x01020101);\n\tWREG32(mmMME1_RTR_HBW_WR_RQ_S_ARB, 0x01010101);\n\tWREG32(mmMME6_RTR_HBW_WR_RQ_S_ARB, 0x01070101);\n\tWREG32(mmMME5_RTR_HBW_WR_RQ_S_ARB, 0x01070101);\n\tWREG32(mmMME4_RTR_HBW_WR_RQ_S_ARB, 0x07020701);\n\tWREG32(mmMME3_RTR_HBW_WR_RQ_S_ARB, 0x02020201);\n\tWREG32(mmMME2_RTR_HBW_WR_RQ_S_ARB, 0x01070101);\n\tWREG32(mmMME1_RTR_HBW_WR_RQ_S_ARB, 0x01020102);\n\tWREG32(mmMME6_RTR_HBW_WR_RQ_W_ARB, 0x01020701);\n\tWREG32(mmMME5_RTR_HBW_WR_RQ_W_ARB, 0x01020701);\n\tWREG32(mmMME4_RTR_HBW_WR_RQ_W_ARB, 0x07020707);\n\tWREG32(mmMME3_RTR_HBW_WR_RQ_W_ARB, 0x01020201);\n\tWREG32(mmMME2_RTR_HBW_WR_RQ_W_ARB, 0x01070201);\n\tWREG32(mmMME1_RTR_HBW_WR_RQ_W_ARB, 0x01070201);\n\tWREG32(mmMME6_RTR_HBW_RD_RS_N_ARB, 0x01070102);\n\tWREG32(mmMME5_RTR_HBW_RD_RS_N_ARB, 0x01070102);\n\tWREG32(mmMME4_RTR_HBW_RD_RS_N_ARB, 0x01060102);\n\tWREG32(mmMME3_RTR_HBW_RD_RS_N_ARB, 0x01040102);\n\tWREG32(mmMME2_RTR_HBW_RD_RS_N_ARB, 0x01020102);\n\tWREG32(mmMME1_RTR_HBW_RD_RS_N_ARB, 0x01020107);\n\tWREG32(mmMME6_RTR_HBW_RD_RS_S_ARB, 0x01020106);\n\tWREG32(mmMME5_RTR_HBW_RD_RS_S_ARB, 0x01020102);\n\tWREG32(mmMME4_RTR_HBW_RD_RS_S_ARB, 0x01040102);\n\tWREG32(mmMME3_RTR_HBW_RD_RS_S_ARB, 0x01060102);\n\tWREG32(mmMME2_RTR_HBW_RD_RS_S_ARB, 0x01070102);\n\tWREG32(mmMME1_RTR_HBW_RD_RS_S_ARB, 0x01070102);\n\tWREG32(mmMME6_RTR_HBW_RD_RS_E_ARB, 0x01020702);\n\tWREG32(mmMME5_RTR_HBW_RD_RS_E_ARB, 0x01020702);\n\tWREG32(mmMME4_RTR_HBW_RD_RS_E_ARB, 0x01040602);\n\tWREG32(mmMME3_RTR_HBW_RD_RS_E_ARB, 0x01060402);\n\tWREG32(mmMME2_RTR_HBW_RD_RS_E_ARB, 0x01070202);\n\tWREG32(mmMME1_RTR_HBW_RD_RS_E_ARB, 0x01070102);\n\tWREG32(mmMME6_RTR_HBW_RD_RS_W_ARB, 0x01060401);\n\tWREG32(mmMME5_RTR_HBW_RD_RS_W_ARB, 0x01060401);\n\tWREG32(mmMME4_RTR_HBW_RD_RS_W_ARB, 0x01060401);\n\tWREG32(mmMME3_RTR_HBW_RD_RS_W_ARB, 0x01060401);\n\tWREG32(mmMME2_RTR_HBW_RD_RS_W_ARB, 0x01060401);\n\tWREG32(mmMME1_RTR_HBW_RD_RS_W_ARB, 0x01060401);\n\tWREG32(mmMME6_RTR_HBW_WR_RS_N_ARB, 0x01050101);\n\tWREG32(mmMME5_RTR_HBW_WR_RS_N_ARB, 0x01040101);\n\tWREG32(mmMME4_RTR_HBW_WR_RS_N_ARB, 0x01030101);\n\tWREG32(mmMME3_RTR_HBW_WR_RS_N_ARB, 0x01020101);\n\tWREG32(mmMME2_RTR_HBW_WR_RS_N_ARB, 0x01010101);\n\tWREG32(mmMME1_RTR_HBW_WR_RS_N_ARB, 0x01010107);\n\tWREG32(mmMME6_RTR_HBW_WR_RS_S_ARB, 0x01010107);\n\tWREG32(mmMME5_RTR_HBW_WR_RS_S_ARB, 0x01010101);\n\tWREG32(mmMME4_RTR_HBW_WR_RS_S_ARB, 0x01020101);\n\tWREG32(mmMME3_RTR_HBW_WR_RS_S_ARB, 0x01030101);\n\tWREG32(mmMME2_RTR_HBW_WR_RS_S_ARB, 0x01040101);\n\tWREG32(mmMME1_RTR_HBW_WR_RS_S_ARB, 0x01050101);\n\tWREG32(mmMME6_RTR_HBW_WR_RS_E_ARB, 0x01010501);\n\tWREG32(mmMME5_RTR_HBW_WR_RS_E_ARB, 0x01010501);\n\tWREG32(mmMME4_RTR_HBW_WR_RS_E_ARB, 0x01040301);\n\tWREG32(mmMME3_RTR_HBW_WR_RS_E_ARB, 0x01030401);\n\tWREG32(mmMME2_RTR_HBW_WR_RS_E_ARB, 0x01040101);\n\tWREG32(mmMME1_RTR_HBW_WR_RS_E_ARB, 0x01050101);\n\tWREG32(mmMME6_RTR_HBW_WR_RS_W_ARB, 0x01010101);\n\tWREG32(mmMME5_RTR_HBW_WR_RS_W_ARB, 0x01010101);\n\tWREG32(mmMME4_RTR_HBW_WR_RS_W_ARB, 0x01010101);\n\tWREG32(mmMME3_RTR_HBW_WR_RS_W_ARB, 0x01010101);\n\tWREG32(mmMME2_RTR_HBW_WR_RS_W_ARB, 0x01010101);\n\tWREG32(mmMME1_RTR_HBW_WR_RS_W_ARB, 0x01010101);\n\n\tWREG32(mmTPC1_RTR_HBW_RD_RQ_N_ARB, 0x01010101);\n\tWREG32(mmTPC1_RTR_HBW_RD_RQ_S_ARB, 0x01010101);\n\tWREG32(mmTPC1_RTR_HBW_RD_RQ_E_ARB, 0x01060101);\n\tWREG32(mmTPC1_RTR_HBW_WR_RQ_N_ARB, 0x02020102);\n\tWREG32(mmTPC1_RTR_HBW_WR_RQ_S_ARB, 0x01010101);\n\tWREG32(mmTPC1_RTR_HBW_WR_RQ_E_ARB, 0x02070202);\n\tWREG32(mmTPC1_RTR_HBW_RD_RS_N_ARB, 0x01020201);\n\tWREG32(mmTPC1_RTR_HBW_RD_RS_S_ARB, 0x01070201);\n\tWREG32(mmTPC1_RTR_HBW_RD_RS_W_ARB, 0x01070202);\n\tWREG32(mmTPC1_RTR_HBW_WR_RS_N_ARB, 0x01010101);\n\tWREG32(mmTPC1_RTR_HBW_WR_RS_S_ARB, 0x01050101);\n\tWREG32(mmTPC1_RTR_HBW_WR_RS_W_ARB, 0x01050101);\n\n\tWREG32(mmTPC2_RTR_HBW_RD_RQ_N_ARB, 0x01020101);\n\tWREG32(mmTPC2_RTR_HBW_RD_RQ_S_ARB, 0x01050101);\n\tWREG32(mmTPC2_RTR_HBW_RD_RQ_E_ARB, 0x01010201);\n\tWREG32(mmTPC2_RTR_HBW_WR_RQ_N_ARB, 0x02040102);\n\tWREG32(mmTPC2_RTR_HBW_WR_RQ_S_ARB, 0x01050101);\n\tWREG32(mmTPC2_RTR_HBW_WR_RQ_E_ARB, 0x02060202);\n\tWREG32(mmTPC2_RTR_HBW_RD_RS_N_ARB, 0x01020201);\n\tWREG32(mmTPC2_RTR_HBW_RD_RS_S_ARB, 0x01070201);\n\tWREG32(mmTPC2_RTR_HBW_RD_RS_W_ARB, 0x01070202);\n\tWREG32(mmTPC2_RTR_HBW_WR_RS_N_ARB, 0x01010101);\n\tWREG32(mmTPC2_RTR_HBW_WR_RS_S_ARB, 0x01040101);\n\tWREG32(mmTPC2_RTR_HBW_WR_RS_W_ARB, 0x01040101);\n\n\tWREG32(mmTPC3_RTR_HBW_RD_RQ_N_ARB, 0x01030101);\n\tWREG32(mmTPC3_RTR_HBW_RD_RQ_S_ARB, 0x01040101);\n\tWREG32(mmTPC3_RTR_HBW_RD_RQ_E_ARB, 0x01040301);\n\tWREG32(mmTPC3_RTR_HBW_WR_RQ_N_ARB, 0x02060102);\n\tWREG32(mmTPC3_RTR_HBW_WR_RQ_S_ARB, 0x01040101);\n\tWREG32(mmTPC3_RTR_HBW_WR_RQ_E_ARB, 0x01040301);\n\tWREG32(mmTPC3_RTR_HBW_RD_RS_N_ARB, 0x01040201);\n\tWREG32(mmTPC3_RTR_HBW_RD_RS_S_ARB, 0x01060201);\n\tWREG32(mmTPC3_RTR_HBW_RD_RS_W_ARB, 0x01060402);\n\tWREG32(mmTPC3_RTR_HBW_WR_RS_N_ARB, 0x01020101);\n\tWREG32(mmTPC3_RTR_HBW_WR_RS_S_ARB, 0x01030101);\n\tWREG32(mmTPC3_RTR_HBW_WR_RS_W_ARB, 0x01030401);\n\n\tWREG32(mmTPC4_RTR_HBW_RD_RQ_N_ARB, 0x01040101);\n\tWREG32(mmTPC4_RTR_HBW_RD_RQ_S_ARB, 0x01030101);\n\tWREG32(mmTPC4_RTR_HBW_RD_RQ_E_ARB, 0x01030401);\n\tWREG32(mmTPC4_RTR_HBW_WR_RQ_N_ARB, 0x02070102);\n\tWREG32(mmTPC4_RTR_HBW_WR_RQ_S_ARB, 0x01030101);\n\tWREG32(mmTPC4_RTR_HBW_WR_RQ_E_ARB, 0x02060702);\n\tWREG32(mmTPC4_RTR_HBW_RD_RS_N_ARB, 0x01060201);\n\tWREG32(mmTPC4_RTR_HBW_RD_RS_S_ARB, 0x01040201);\n\tWREG32(mmTPC4_RTR_HBW_RD_RS_W_ARB, 0x01040602);\n\tWREG32(mmTPC4_RTR_HBW_WR_RS_N_ARB, 0x01030101);\n\tWREG32(mmTPC4_RTR_HBW_WR_RS_S_ARB, 0x01020101);\n\tWREG32(mmTPC4_RTR_HBW_WR_RS_W_ARB, 0x01040301);\n\n\tWREG32(mmTPC5_RTR_HBW_RD_RQ_N_ARB, 0x01050101);\n\tWREG32(mmTPC5_RTR_HBW_RD_RQ_S_ARB, 0x01020101);\n\tWREG32(mmTPC5_RTR_HBW_RD_RQ_E_ARB, 0x01200501);\n\tWREG32(mmTPC5_RTR_HBW_WR_RQ_N_ARB, 0x02070102);\n\tWREG32(mmTPC5_RTR_HBW_WR_RQ_S_ARB, 0x01020101);\n\tWREG32(mmTPC5_RTR_HBW_WR_RQ_E_ARB, 0x02020602);\n\tWREG32(mmTPC5_RTR_HBW_RD_RS_N_ARB, 0x01070201);\n\tWREG32(mmTPC5_RTR_HBW_RD_RS_S_ARB, 0x01020201);\n\tWREG32(mmTPC5_RTR_HBW_RD_RS_W_ARB, 0x01020702);\n\tWREG32(mmTPC5_RTR_HBW_WR_RS_N_ARB, 0x01040101);\n\tWREG32(mmTPC5_RTR_HBW_WR_RS_S_ARB, 0x01010101);\n\tWREG32(mmTPC5_RTR_HBW_WR_RS_W_ARB, 0x01010501);\n\n\tWREG32(mmTPC6_RTR_HBW_RD_RQ_N_ARB, 0x01010101);\n\tWREG32(mmTPC6_RTR_HBW_RD_RQ_S_ARB, 0x01010101);\n\tWREG32(mmTPC6_RTR_HBW_RD_RQ_E_ARB, 0x01010601);\n\tWREG32(mmTPC6_RTR_HBW_WR_RQ_N_ARB, 0x01010101);\n\tWREG32(mmTPC6_RTR_HBW_WR_RQ_S_ARB, 0x01010101);\n\tWREG32(mmTPC6_RTR_HBW_WR_RQ_E_ARB, 0x02020702);\n\tWREG32(mmTPC6_RTR_HBW_RD_RS_N_ARB, 0x01010101);\n\tWREG32(mmTPC6_RTR_HBW_RD_RS_S_ARB, 0x01010101);\n\tWREG32(mmTPC6_RTR_HBW_RD_RS_W_ARB, 0x01020702);\n\tWREG32(mmTPC6_RTR_HBW_WR_RS_N_ARB, 0x01050101);\n\tWREG32(mmTPC6_RTR_HBW_WR_RS_S_ARB, 0x01010101);\n\tWREG32(mmTPC6_RTR_HBW_WR_RS_W_ARB, 0x01010501);\n\n\tfor (i = 0, offset = 0 ; i < 10 ; i++, offset += 4) {\n\t\tWREG32(mmMME1_RTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\t\tWREG32(mmMME2_RTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\t\tWREG32(mmMME3_RTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\t\tWREG32(mmMME4_RTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\t\tWREG32(mmMME5_RTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\t\tWREG32(mmMME6_RTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\n\t\tWREG32(mmTPC0_NRTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\t\tWREG32(mmTPC1_RTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\t\tWREG32(mmTPC2_RTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\t\tWREG32(mmTPC3_RTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\t\tWREG32(mmTPC4_RTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\t\tWREG32(mmTPC5_RTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\t\tWREG32(mmTPC6_RTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\t\tWREG32(mmTPC7_NRTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\n\t\tWREG32(mmPCI_NRTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\t\tWREG32(mmDMA_NRTR_SPLIT_COEF_0 + offset, polynom[i] >> 7);\n\t}\n\n\tfor (i = 0, offset = 0 ; i < 6 ; i++, offset += 0x40000) {\n\t\tWREG32(mmMME1_RTR_SCRAMB_EN + offset,\n\t\t\t\t1 << MME1_RTR_SCRAMB_EN_VAL_SHIFT);\n\t\tWREG32(mmMME1_RTR_NON_LIN_SCRAMB + offset,\n\t\t\t\t1 << MME1_RTR_NON_LIN_SCRAMB_EN_SHIFT);\n\t}\n\n\tfor (i = 0, offset = 0 ; i < 8 ; i++, offset += 0x40000) {\n\t\t \n\t\tWREG32(mmTPC0_CFG_TPC_INTR_MASK + offset, tpc_intr_mask);\n\n\t\tWREG32(mmTPC0_NRTR_SCRAMB_EN + offset,\n\t\t\t\t1 << TPC0_NRTR_SCRAMB_EN_VAL_SHIFT);\n\t\tWREG32(mmTPC0_NRTR_NON_LIN_SCRAMB + offset,\n\t\t\t\t1 << TPC0_NRTR_NON_LIN_SCRAMB_EN_SHIFT);\n\n\t\tWREG32_FIELD(TPC0_CFG_MSS_CONFIG, offset,\n\t\t\t\tICACHE_FETCH_LINE_NUM, 2);\n\t}\n\n\tWREG32(mmDMA_NRTR_SCRAMB_EN, 1 << DMA_NRTR_SCRAMB_EN_VAL_SHIFT);\n\tWREG32(mmDMA_NRTR_NON_LIN_SCRAMB,\n\t\t\t1 << DMA_NRTR_NON_LIN_SCRAMB_EN_SHIFT);\n\n\tWREG32(mmPCI_NRTR_SCRAMB_EN, 1 << PCI_NRTR_SCRAMB_EN_VAL_SHIFT);\n\tWREG32(mmPCI_NRTR_NON_LIN_SCRAMB,\n\t\t\t1 << PCI_NRTR_NON_LIN_SCRAMB_EN_SHIFT);\n\n\t \n\tWREG32(mmDMA_CH_1_CFG0, 0x0fff00F0);\n\n\tWREG32(mmTPC_PLL_CLK_RLX_0, 0x200020);\n\n\tgoya->hw_cap_initialized |= HW_CAP_GOLDEN;\n}\n\nstatic void goya_init_mme_qman(struct hl_device *hdev)\n{\n\tu32 mtr_base_lo, mtr_base_hi;\n\tu32 so_base_lo, so_base_hi;\n\tu32 gic_base_lo, gic_base_hi;\n\tu64 qman_base_addr;\n\n\tmtr_base_lo = lower_32_bits(CFG_BASE + mmSYNC_MNGR_MON_PAY_ADDRL_0);\n\tmtr_base_hi = upper_32_bits(CFG_BASE + mmSYNC_MNGR_MON_PAY_ADDRL_0);\n\tso_base_lo = lower_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\tso_base_hi = upper_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\n\tgic_base_lo =\n\t\tlower_32_bits(CFG_BASE + mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR);\n\tgic_base_hi =\n\t\tupper_32_bits(CFG_BASE + mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR);\n\n\tqman_base_addr = hdev->asic_prop.sram_base_address +\n\t\t\t\tMME_QMAN_BASE_OFFSET;\n\n\tWREG32(mmMME_QM_PQ_BASE_LO, lower_32_bits(qman_base_addr));\n\tWREG32(mmMME_QM_PQ_BASE_HI, upper_32_bits(qman_base_addr));\n\tWREG32(mmMME_QM_PQ_SIZE, ilog2(MME_QMAN_LENGTH));\n\tWREG32(mmMME_QM_PQ_PI, 0);\n\tWREG32(mmMME_QM_PQ_CI, 0);\n\tWREG32(mmMME_QM_CP_LDMA_SRC_BASE_LO_OFFSET, 0x10C0);\n\tWREG32(mmMME_QM_CP_LDMA_SRC_BASE_HI_OFFSET, 0x10C4);\n\tWREG32(mmMME_QM_CP_LDMA_TSIZE_OFFSET, 0x10C8);\n\tWREG32(mmMME_QM_CP_LDMA_COMMIT_OFFSET, 0x10CC);\n\n\tWREG32(mmMME_QM_CP_MSG_BASE0_ADDR_LO, mtr_base_lo);\n\tWREG32(mmMME_QM_CP_MSG_BASE0_ADDR_HI, mtr_base_hi);\n\tWREG32(mmMME_QM_CP_MSG_BASE1_ADDR_LO, so_base_lo);\n\tWREG32(mmMME_QM_CP_MSG_BASE1_ADDR_HI, so_base_hi);\n\n\t \n\tWREG32(mmMME_QM_CQ_CFG1, 0x00080008);\n\n\tWREG32(mmMME_QM_GLBL_ERR_ADDR_LO, gic_base_lo);\n\tWREG32(mmMME_QM_GLBL_ERR_ADDR_HI, gic_base_hi);\n\n\tWREG32(mmMME_QM_GLBL_ERR_WDATA, GOYA_ASYNC_EVENT_ID_MME_QM);\n\n\tWREG32(mmMME_QM_GLBL_ERR_CFG, QMAN_MME_ERR_MSG_EN);\n\n\tWREG32(mmMME_QM_GLBL_PROT, QMAN_MME_ERR_PROT);\n\n\tWREG32(mmMME_QM_GLBL_CFG0, QMAN_MME_ENABLE);\n}\n\nstatic void goya_init_mme_cmdq(struct hl_device *hdev)\n{\n\tu32 mtr_base_lo, mtr_base_hi;\n\tu32 so_base_lo, so_base_hi;\n\tu32 gic_base_lo, gic_base_hi;\n\n\tmtr_base_lo = lower_32_bits(CFG_BASE + mmSYNC_MNGR_MON_PAY_ADDRL_0);\n\tmtr_base_hi = upper_32_bits(CFG_BASE + mmSYNC_MNGR_MON_PAY_ADDRL_0);\n\tso_base_lo = lower_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\tso_base_hi = upper_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\n\tgic_base_lo =\n\t\tlower_32_bits(CFG_BASE + mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR);\n\tgic_base_hi =\n\t\tupper_32_bits(CFG_BASE + mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR);\n\n\tWREG32(mmMME_CMDQ_CP_MSG_BASE0_ADDR_LO, mtr_base_lo);\n\tWREG32(mmMME_CMDQ_CP_MSG_BASE0_ADDR_HI, mtr_base_hi);\n\tWREG32(mmMME_CMDQ_CP_MSG_BASE1_ADDR_LO,\tso_base_lo);\n\tWREG32(mmMME_CMDQ_CP_MSG_BASE1_ADDR_HI, so_base_hi);\n\n\t \n\tWREG32(mmMME_CMDQ_CQ_CFG1, 0x00140014);\n\n\tWREG32(mmMME_CMDQ_GLBL_ERR_ADDR_LO, gic_base_lo);\n\tWREG32(mmMME_CMDQ_GLBL_ERR_ADDR_HI, gic_base_hi);\n\n\tWREG32(mmMME_CMDQ_GLBL_ERR_WDATA, GOYA_ASYNC_EVENT_ID_MME_CMDQ);\n\n\tWREG32(mmMME_CMDQ_GLBL_ERR_CFG, CMDQ_MME_ERR_MSG_EN);\n\n\tWREG32(mmMME_CMDQ_GLBL_PROT, CMDQ_MME_ERR_PROT);\n\n\tWREG32(mmMME_CMDQ_GLBL_CFG0, CMDQ_MME_ENABLE);\n}\n\nvoid goya_init_mme_qmans(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tu32 so_base_lo, so_base_hi;\n\n\tif (goya->hw_cap_initialized & HW_CAP_MME)\n\t\treturn;\n\n\tso_base_lo = lower_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\tso_base_hi = upper_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\n\tWREG32(mmMME_SM_BASE_ADDRESS_LOW, so_base_lo);\n\tWREG32(mmMME_SM_BASE_ADDRESS_HIGH, so_base_hi);\n\n\tgoya_init_mme_qman(hdev);\n\tgoya_init_mme_cmdq(hdev);\n\n\tgoya->hw_cap_initialized |= HW_CAP_MME;\n}\n\nstatic void goya_init_tpc_qman(struct hl_device *hdev, u32 base_off, int tpc_id)\n{\n\tu32 mtr_base_lo, mtr_base_hi;\n\tu32 so_base_lo, so_base_hi;\n\tu32 gic_base_lo, gic_base_hi;\n\tu64 qman_base_addr;\n\tu32 reg_off = tpc_id * (mmTPC1_QM_PQ_PI - mmTPC0_QM_PQ_PI);\n\n\tmtr_base_lo = lower_32_bits(CFG_BASE + mmSYNC_MNGR_MON_PAY_ADDRL_0);\n\tmtr_base_hi = upper_32_bits(CFG_BASE + mmSYNC_MNGR_MON_PAY_ADDRL_0);\n\tso_base_lo = lower_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\tso_base_hi = upper_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\n\tgic_base_lo =\n\t\tlower_32_bits(CFG_BASE + mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR);\n\tgic_base_hi =\n\t\tupper_32_bits(CFG_BASE + mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR);\n\n\tqman_base_addr = hdev->asic_prop.sram_base_address + base_off;\n\n\tWREG32(mmTPC0_QM_PQ_BASE_LO + reg_off, lower_32_bits(qman_base_addr));\n\tWREG32(mmTPC0_QM_PQ_BASE_HI + reg_off, upper_32_bits(qman_base_addr));\n\tWREG32(mmTPC0_QM_PQ_SIZE + reg_off, ilog2(TPC_QMAN_LENGTH));\n\tWREG32(mmTPC0_QM_PQ_PI + reg_off, 0);\n\tWREG32(mmTPC0_QM_PQ_CI + reg_off, 0);\n\tWREG32(mmTPC0_QM_CP_LDMA_SRC_BASE_LO_OFFSET + reg_off, 0x10C0);\n\tWREG32(mmTPC0_QM_CP_LDMA_SRC_BASE_HI_OFFSET + reg_off, 0x10C4);\n\tWREG32(mmTPC0_QM_CP_LDMA_TSIZE_OFFSET + reg_off, 0x10C8);\n\tWREG32(mmTPC0_QM_CP_LDMA_COMMIT_OFFSET + reg_off, 0x10CC);\n\n\tWREG32(mmTPC0_QM_CP_MSG_BASE0_ADDR_LO + reg_off, mtr_base_lo);\n\tWREG32(mmTPC0_QM_CP_MSG_BASE0_ADDR_HI + reg_off, mtr_base_hi);\n\tWREG32(mmTPC0_QM_CP_MSG_BASE1_ADDR_LO + reg_off, so_base_lo);\n\tWREG32(mmTPC0_QM_CP_MSG_BASE1_ADDR_HI + reg_off, so_base_hi);\n\n\tWREG32(mmTPC0_QM_CQ_CFG1 + reg_off, 0x00080008);\n\n\tWREG32(mmTPC0_QM_GLBL_ERR_ADDR_LO + reg_off, gic_base_lo);\n\tWREG32(mmTPC0_QM_GLBL_ERR_ADDR_HI + reg_off, gic_base_hi);\n\n\tWREG32(mmTPC0_QM_GLBL_ERR_WDATA + reg_off,\n\t\t\tGOYA_ASYNC_EVENT_ID_TPC0_QM + tpc_id);\n\n\tWREG32(mmTPC0_QM_GLBL_ERR_CFG + reg_off, QMAN_TPC_ERR_MSG_EN);\n\n\tWREG32(mmTPC0_QM_GLBL_PROT + reg_off, QMAN_TPC_ERR_PROT);\n\n\tWREG32(mmTPC0_QM_GLBL_CFG0 + reg_off, QMAN_TPC_ENABLE);\n}\n\nstatic void goya_init_tpc_cmdq(struct hl_device *hdev, int tpc_id)\n{\n\tu32 mtr_base_lo, mtr_base_hi;\n\tu32 so_base_lo, so_base_hi;\n\tu32 gic_base_lo, gic_base_hi;\n\tu32 reg_off = tpc_id * (mmTPC1_CMDQ_CQ_CFG1 - mmTPC0_CMDQ_CQ_CFG1);\n\n\tmtr_base_lo = lower_32_bits(CFG_BASE + mmSYNC_MNGR_MON_PAY_ADDRL_0);\n\tmtr_base_hi = upper_32_bits(CFG_BASE + mmSYNC_MNGR_MON_PAY_ADDRL_0);\n\tso_base_lo = lower_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\tso_base_hi = upper_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\n\tgic_base_lo =\n\t\tlower_32_bits(CFG_BASE + mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR);\n\tgic_base_hi =\n\t\tupper_32_bits(CFG_BASE + mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR);\n\n\tWREG32(mmTPC0_CMDQ_CP_MSG_BASE0_ADDR_LO + reg_off, mtr_base_lo);\n\tWREG32(mmTPC0_CMDQ_CP_MSG_BASE0_ADDR_HI + reg_off, mtr_base_hi);\n\tWREG32(mmTPC0_CMDQ_CP_MSG_BASE1_ADDR_LO + reg_off, so_base_lo);\n\tWREG32(mmTPC0_CMDQ_CP_MSG_BASE1_ADDR_HI + reg_off, so_base_hi);\n\n\tWREG32(mmTPC0_CMDQ_CQ_CFG1 + reg_off, 0x00140014);\n\n\tWREG32(mmTPC0_CMDQ_GLBL_ERR_ADDR_LO + reg_off, gic_base_lo);\n\tWREG32(mmTPC0_CMDQ_GLBL_ERR_ADDR_HI + reg_off, gic_base_hi);\n\n\tWREG32(mmTPC0_CMDQ_GLBL_ERR_WDATA + reg_off,\n\t\t\tGOYA_ASYNC_EVENT_ID_TPC0_CMDQ + tpc_id);\n\n\tWREG32(mmTPC0_CMDQ_GLBL_ERR_CFG + reg_off, CMDQ_TPC_ERR_MSG_EN);\n\n\tWREG32(mmTPC0_CMDQ_GLBL_PROT + reg_off, CMDQ_TPC_ERR_PROT);\n\n\tWREG32(mmTPC0_CMDQ_GLBL_CFG0 + reg_off, CMDQ_TPC_ENABLE);\n}\n\nvoid goya_init_tpc_qmans(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tu32 so_base_lo, so_base_hi;\n\tu32 cfg_off = mmTPC1_CFG_SM_BASE_ADDRESS_LOW -\n\t\t\tmmTPC0_CFG_SM_BASE_ADDRESS_LOW;\n\tint i;\n\n\tif (goya->hw_cap_initialized & HW_CAP_TPC)\n\t\treturn;\n\n\tso_base_lo = lower_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\tso_base_hi = upper_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\n\tfor (i = 0 ; i < TPC_MAX_NUM ; i++) {\n\t\tWREG32(mmTPC0_CFG_SM_BASE_ADDRESS_LOW + i * cfg_off,\n\t\t\t\tso_base_lo);\n\t\tWREG32(mmTPC0_CFG_SM_BASE_ADDRESS_HIGH + i * cfg_off,\n\t\t\t\tso_base_hi);\n\t}\n\n\tgoya_init_tpc_qman(hdev, TPC0_QMAN_BASE_OFFSET, 0);\n\tgoya_init_tpc_qman(hdev, TPC1_QMAN_BASE_OFFSET, 1);\n\tgoya_init_tpc_qman(hdev, TPC2_QMAN_BASE_OFFSET, 2);\n\tgoya_init_tpc_qman(hdev, TPC3_QMAN_BASE_OFFSET, 3);\n\tgoya_init_tpc_qman(hdev, TPC4_QMAN_BASE_OFFSET, 4);\n\tgoya_init_tpc_qman(hdev, TPC5_QMAN_BASE_OFFSET, 5);\n\tgoya_init_tpc_qman(hdev, TPC6_QMAN_BASE_OFFSET, 6);\n\tgoya_init_tpc_qman(hdev, TPC7_QMAN_BASE_OFFSET, 7);\n\n\tfor (i = 0 ; i < TPC_MAX_NUM ; i++)\n\t\tgoya_init_tpc_cmdq(hdev, i);\n\n\tgoya->hw_cap_initialized |= HW_CAP_TPC;\n}\n\n \nstatic void goya_disable_internal_queues(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_MME))\n\t\tgoto disable_tpc;\n\n\tWREG32(mmMME_QM_GLBL_CFG0, 0);\n\tWREG32(mmMME_CMDQ_GLBL_CFG0, 0);\n\ndisable_tpc:\n\tif (!(goya->hw_cap_initialized & HW_CAP_TPC))\n\t\treturn;\n\n\tWREG32(mmTPC0_QM_GLBL_CFG0, 0);\n\tWREG32(mmTPC0_CMDQ_GLBL_CFG0, 0);\n\n\tWREG32(mmTPC1_QM_GLBL_CFG0, 0);\n\tWREG32(mmTPC1_CMDQ_GLBL_CFG0, 0);\n\n\tWREG32(mmTPC2_QM_GLBL_CFG0, 0);\n\tWREG32(mmTPC2_CMDQ_GLBL_CFG0, 0);\n\n\tWREG32(mmTPC3_QM_GLBL_CFG0, 0);\n\tWREG32(mmTPC3_CMDQ_GLBL_CFG0, 0);\n\n\tWREG32(mmTPC4_QM_GLBL_CFG0, 0);\n\tWREG32(mmTPC4_CMDQ_GLBL_CFG0, 0);\n\n\tWREG32(mmTPC5_QM_GLBL_CFG0, 0);\n\tWREG32(mmTPC5_CMDQ_GLBL_CFG0, 0);\n\n\tWREG32(mmTPC6_QM_GLBL_CFG0, 0);\n\tWREG32(mmTPC6_CMDQ_GLBL_CFG0, 0);\n\n\tWREG32(mmTPC7_QM_GLBL_CFG0, 0);\n\tWREG32(mmTPC7_CMDQ_GLBL_CFG0, 0);\n}\n\n \nstatic int goya_stop_internal_queues(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tint rc, retval = 0;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_MME))\n\t\tgoto stop_tpc;\n\n\t \n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmMME_QM_GLBL_CFG1,\n\t\t\tmmMME_QM_CP_STS,\n\t\t\tmmMME_QM_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop MME QMAN\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmMME_CMDQ_GLBL_CFG1,\n\t\t\tmmMME_CMDQ_CP_STS,\n\t\t\tmmMME_CMDQ_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop MME CMDQ\\n\");\n\t\tretval = -EIO;\n\t}\n\nstop_tpc:\n\tif (!(goya->hw_cap_initialized & HW_CAP_TPC))\n\t\treturn retval;\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC0_QM_GLBL_CFG1,\n\t\t\tmmTPC0_QM_CP_STS,\n\t\t\tmmTPC0_QM_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 0 QMAN\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC0_CMDQ_GLBL_CFG1,\n\t\t\tmmTPC0_CMDQ_CP_STS,\n\t\t\tmmTPC0_CMDQ_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 0 CMDQ\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC1_QM_GLBL_CFG1,\n\t\t\tmmTPC1_QM_CP_STS,\n\t\t\tmmTPC1_QM_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 1 QMAN\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC1_CMDQ_GLBL_CFG1,\n\t\t\tmmTPC1_CMDQ_CP_STS,\n\t\t\tmmTPC1_CMDQ_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 1 CMDQ\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC2_QM_GLBL_CFG1,\n\t\t\tmmTPC2_QM_CP_STS,\n\t\t\tmmTPC2_QM_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 2 QMAN\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC2_CMDQ_GLBL_CFG1,\n\t\t\tmmTPC2_CMDQ_CP_STS,\n\t\t\tmmTPC2_CMDQ_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 2 CMDQ\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC3_QM_GLBL_CFG1,\n\t\t\tmmTPC3_QM_CP_STS,\n\t\t\tmmTPC3_QM_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 3 QMAN\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC3_CMDQ_GLBL_CFG1,\n\t\t\tmmTPC3_CMDQ_CP_STS,\n\t\t\tmmTPC3_CMDQ_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 3 CMDQ\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC4_QM_GLBL_CFG1,\n\t\t\tmmTPC4_QM_CP_STS,\n\t\t\tmmTPC4_QM_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 4 QMAN\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC4_CMDQ_GLBL_CFG1,\n\t\t\tmmTPC4_CMDQ_CP_STS,\n\t\t\tmmTPC4_CMDQ_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 4 CMDQ\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC5_QM_GLBL_CFG1,\n\t\t\tmmTPC5_QM_CP_STS,\n\t\t\tmmTPC5_QM_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 5 QMAN\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC5_CMDQ_GLBL_CFG1,\n\t\t\tmmTPC5_CMDQ_CP_STS,\n\t\t\tmmTPC5_CMDQ_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 5 CMDQ\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC6_QM_GLBL_CFG1,\n\t\t\tmmTPC6_QM_CP_STS,\n\t\t\tmmTPC6_QM_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 6 QMAN\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC6_CMDQ_GLBL_CFG1,\n\t\t\tmmTPC6_CMDQ_CP_STS,\n\t\t\tmmTPC6_CMDQ_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 6 CMDQ\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC7_QM_GLBL_CFG1,\n\t\t\tmmTPC7_QM_CP_STS,\n\t\t\tmmTPC7_QM_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 7 QMAN\\n\");\n\t\tretval = -EIO;\n\t}\n\n\trc = goya_stop_queue(hdev,\n\t\t\tmmTPC7_CMDQ_GLBL_CFG1,\n\t\t\tmmTPC7_CMDQ_CP_STS,\n\t\t\tmmTPC7_CMDQ_GLBL_STS0);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to stop TPC 7 CMDQ\\n\");\n\t\tretval = -EIO;\n\t}\n\n\treturn retval;\n}\n\nstatic void goya_dma_stall(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_DMA))\n\t\treturn;\n\n\tWREG32(mmDMA_QM_0_GLBL_CFG1, 1 << DMA_QM_0_GLBL_CFG1_DMA_STOP_SHIFT);\n\tWREG32(mmDMA_QM_1_GLBL_CFG1, 1 << DMA_QM_1_GLBL_CFG1_DMA_STOP_SHIFT);\n\tWREG32(mmDMA_QM_2_GLBL_CFG1, 1 << DMA_QM_2_GLBL_CFG1_DMA_STOP_SHIFT);\n\tWREG32(mmDMA_QM_3_GLBL_CFG1, 1 << DMA_QM_3_GLBL_CFG1_DMA_STOP_SHIFT);\n\tWREG32(mmDMA_QM_4_GLBL_CFG1, 1 << DMA_QM_4_GLBL_CFG1_DMA_STOP_SHIFT);\n}\n\nstatic void goya_tpc_stall(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_TPC))\n\t\treturn;\n\n\tWREG32(mmTPC0_CFG_TPC_STALL, 1 << TPC0_CFG_TPC_STALL_V_SHIFT);\n\tWREG32(mmTPC1_CFG_TPC_STALL, 1 << TPC1_CFG_TPC_STALL_V_SHIFT);\n\tWREG32(mmTPC2_CFG_TPC_STALL, 1 << TPC2_CFG_TPC_STALL_V_SHIFT);\n\tWREG32(mmTPC3_CFG_TPC_STALL, 1 << TPC3_CFG_TPC_STALL_V_SHIFT);\n\tWREG32(mmTPC4_CFG_TPC_STALL, 1 << TPC4_CFG_TPC_STALL_V_SHIFT);\n\tWREG32(mmTPC5_CFG_TPC_STALL, 1 << TPC5_CFG_TPC_STALL_V_SHIFT);\n\tWREG32(mmTPC6_CFG_TPC_STALL, 1 << TPC6_CFG_TPC_STALL_V_SHIFT);\n\tWREG32(mmTPC7_CFG_TPC_STALL, 1 << TPC7_CFG_TPC_STALL_V_SHIFT);\n}\n\nstatic void goya_mme_stall(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_MME))\n\t\treturn;\n\n\tWREG32(mmMME_STALL, 0xFFFFFFFF);\n}\n\nstatic int goya_enable_msix(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tint cq_cnt = hdev->asic_prop.completion_queues_count;\n\tint rc, i, irq_cnt_init, irq;\n\n\tif (goya->hw_cap_initialized & HW_CAP_MSIX)\n\t\treturn 0;\n\n\trc = pci_alloc_irq_vectors(hdev->pdev, GOYA_MSIX_ENTRIES,\n\t\t\t\tGOYA_MSIX_ENTRIES, PCI_IRQ_MSIX);\n\tif (rc < 0) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"MSI-X: Failed to enable support -- %d/%d\\n\",\n\t\t\tGOYA_MSIX_ENTRIES, rc);\n\t\treturn rc;\n\t}\n\n\tfor (i = 0, irq_cnt_init = 0 ; i < cq_cnt ; i++, irq_cnt_init++) {\n\t\tirq = pci_irq_vector(hdev->pdev, i);\n\t\trc = request_irq(irq, hl_irq_handler_cq, 0, goya_irq_name[i],\n\t\t\t\t&hdev->completion_queue[i]);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev, \"Failed to request IRQ %d\", irq);\n\t\t\tgoto free_irqs;\n\t\t}\n\t}\n\n\tirq = pci_irq_vector(hdev->pdev, GOYA_EVENT_QUEUE_MSIX_IDX);\n\n\trc = request_irq(irq, hl_irq_handler_eq, 0,\n\t\t\tgoya_irq_name[GOYA_EVENT_QUEUE_MSIX_IDX],\n\t\t\t&hdev->event_queue);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to request IRQ %d\", irq);\n\t\tgoto free_irqs;\n\t}\n\n\tgoya->hw_cap_initialized |= HW_CAP_MSIX;\n\treturn 0;\n\nfree_irqs:\n\tfor (i = 0 ; i < irq_cnt_init ; i++)\n\t\tfree_irq(pci_irq_vector(hdev->pdev, i),\n\t\t\t&hdev->completion_queue[i]);\n\n\tpci_free_irq_vectors(hdev->pdev);\n\treturn rc;\n}\n\nstatic void goya_sync_irqs(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tint i;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_MSIX))\n\t\treturn;\n\n\t \n\tfor (i = 0 ; i < hdev->asic_prop.completion_queues_count ; i++)\n\t\tsynchronize_irq(pci_irq_vector(hdev->pdev, i));\n\n\tsynchronize_irq(pci_irq_vector(hdev->pdev, GOYA_EVENT_QUEUE_MSIX_IDX));\n}\n\nstatic void goya_disable_msix(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tint i, irq;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_MSIX))\n\t\treturn;\n\n\tgoya_sync_irqs(hdev);\n\n\tirq = pci_irq_vector(hdev->pdev, GOYA_EVENT_QUEUE_MSIX_IDX);\n\tfree_irq(irq, &hdev->event_queue);\n\n\tfor (i = 0 ; i < hdev->asic_prop.completion_queues_count ; i++) {\n\t\tirq = pci_irq_vector(hdev->pdev, i);\n\t\tfree_irq(irq, &hdev->completion_queue[i]);\n\t}\n\n\tpci_free_irq_vectors(hdev->pdev);\n\n\tgoya->hw_cap_initialized &= ~HW_CAP_MSIX;\n}\n\nstatic void goya_enable_timestamp(struct hl_device *hdev)\n{\n\t \n\tWREG32(mmPSOC_TIMESTAMP_BASE - CFG_BASE, 0);\n\n\t \n\tWREG32(mmPSOC_TIMESTAMP_BASE - CFG_BASE + 0xC, 0);\n\tWREG32(mmPSOC_TIMESTAMP_BASE - CFG_BASE + 0x8, 0);\n\n\t \n\tWREG32(mmPSOC_TIMESTAMP_BASE - CFG_BASE, 1);\n}\n\nstatic void goya_disable_timestamp(struct hl_device *hdev)\n{\n\t \n\tWREG32(mmPSOC_TIMESTAMP_BASE - CFG_BASE, 0);\n}\n\nstatic void goya_halt_engines(struct hl_device *hdev, bool hard_reset, bool fw_reset)\n{\n\tu32 wait_timeout_ms;\n\n\tif (hdev->pldm)\n\t\twait_timeout_ms = GOYA_PLDM_RESET_WAIT_MSEC;\n\telse\n\t\twait_timeout_ms = GOYA_RESET_WAIT_MSEC;\n\n\tgoya_stop_external_queues(hdev);\n\tgoya_stop_internal_queues(hdev);\n\n\tmsleep(wait_timeout_ms);\n\n\tgoya_dma_stall(hdev);\n\tgoya_tpc_stall(hdev);\n\tgoya_mme_stall(hdev);\n\n\tmsleep(wait_timeout_ms);\n\n\tgoya_disable_external_queues(hdev);\n\tgoya_disable_internal_queues(hdev);\n\n\tgoya_disable_timestamp(hdev);\n\n\tif (hard_reset) {\n\t\tgoya_disable_msix(hdev);\n\t\tgoya_mmu_remove_device_cpu_mappings(hdev);\n\t} else {\n\t\tgoya_sync_irqs(hdev);\n\t}\n}\n\n \nstatic int goya_load_firmware_to_device(struct hl_device *hdev)\n{\n\tvoid __iomem *dst;\n\n\tdst = hdev->pcie_bar[DDR_BAR_ID] + LINUX_FW_OFFSET;\n\n\treturn hl_fw_load_fw_to_device(hdev, GOYA_LINUX_FW_FILE, dst, 0, 0);\n}\n\n \nstatic int goya_load_boot_fit_to_device(struct hl_device *hdev)\n{\n\tvoid __iomem *dst;\n\n\tdst = hdev->pcie_bar[SRAM_CFG_BAR_ID] + BOOT_FIT_SRAM_OFFSET;\n\n\treturn hl_fw_load_fw_to_device(hdev, GOYA_BOOT_FIT_FILE, dst, 0, 0);\n}\n\nstatic void goya_init_dynamic_firmware_loader(struct hl_device *hdev)\n{\n\tstruct dynamic_fw_load_mgr *dynamic_loader;\n\tstruct cpu_dyn_regs *dyn_regs;\n\n\tdynamic_loader = &hdev->fw_loader.dynamic_loader;\n\n\t \n\tdyn_regs = &dynamic_loader->comm_desc.cpu_dyn_regs;\n\tdyn_regs->kmd_msg_to_cpu =\n\t\t\t\tcpu_to_le32(mmPSOC_GLOBAL_CONF_KMD_MSG_TO_CPU);\n\tdyn_regs->cpu_cmd_status_to_host =\n\t\t\t\tcpu_to_le32(mmCPU_CMD_STATUS_TO_HOST);\n\n\tdynamic_loader->wait_for_bl_timeout = GOYA_WAIT_FOR_BL_TIMEOUT_USEC;\n}\n\nstatic void goya_init_static_firmware_loader(struct hl_device *hdev)\n{\n\tstruct static_fw_load_mgr *static_loader;\n\n\tstatic_loader = &hdev->fw_loader.static_loader;\n\n\tstatic_loader->preboot_version_max_off = SRAM_SIZE - VERSION_MAX_LEN;\n\tstatic_loader->boot_fit_version_max_off = SRAM_SIZE - VERSION_MAX_LEN;\n\tstatic_loader->kmd_msg_to_cpu_reg = mmPSOC_GLOBAL_CONF_KMD_MSG_TO_CPU;\n\tstatic_loader->cpu_cmd_status_to_host_reg = mmCPU_CMD_STATUS_TO_HOST;\n\tstatic_loader->cpu_boot_status_reg = mmPSOC_GLOBAL_CONF_CPU_BOOT_STATUS;\n\tstatic_loader->cpu_boot_dev_status0_reg = mmCPU_BOOT_DEV_STS0;\n\tstatic_loader->cpu_boot_dev_status1_reg = mmCPU_BOOT_DEV_STS1;\n\tstatic_loader->boot_err0_reg = mmCPU_BOOT_ERR0;\n\tstatic_loader->boot_err1_reg = mmCPU_BOOT_ERR1;\n\tstatic_loader->preboot_version_offset_reg = mmPREBOOT_VER_OFFSET;\n\tstatic_loader->boot_fit_version_offset_reg = mmUBOOT_VER_OFFSET;\n\tstatic_loader->sram_offset_mask = ~(lower_32_bits(SRAM_BASE_ADDR));\n}\n\nstatic void goya_init_firmware_preload_params(struct hl_device *hdev)\n{\n\tstruct pre_fw_load_props *pre_fw_load = &hdev->fw_loader.pre_fw_load;\n\n\tpre_fw_load->cpu_boot_status_reg = mmPSOC_GLOBAL_CONF_CPU_BOOT_STATUS;\n\tpre_fw_load->sts_boot_dev_sts0_reg = mmCPU_BOOT_DEV_STS0;\n\tpre_fw_load->sts_boot_dev_sts1_reg = mmCPU_BOOT_DEV_STS1;\n\tpre_fw_load->boot_err0_reg = mmCPU_BOOT_ERR0;\n\tpre_fw_load->boot_err1_reg = mmCPU_BOOT_ERR1;\n\tpre_fw_load->wait_for_preboot_timeout = GOYA_BOOT_FIT_REQ_TIMEOUT_USEC;\n}\n\nstatic void goya_init_firmware_loader(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct fw_load_mgr *fw_loader = &hdev->fw_loader;\n\n\t \n\tfw_loader->fw_comp_loaded = FW_TYPE_NONE;\n\tfw_loader->boot_fit_img.image_name = GOYA_BOOT_FIT_FILE;\n\tfw_loader->linux_img.image_name = GOYA_LINUX_FW_FILE;\n\tfw_loader->cpu_timeout = GOYA_CPU_TIMEOUT_USEC;\n\tfw_loader->boot_fit_timeout = GOYA_BOOT_FIT_REQ_TIMEOUT_USEC;\n\tfw_loader->skip_bmc = false;\n\tfw_loader->sram_bar_id = SRAM_CFG_BAR_ID;\n\tfw_loader->dram_bar_id = DDR_BAR_ID;\n\n\tif (prop->dynamic_fw_load)\n\t\tgoya_init_dynamic_firmware_loader(hdev);\n\telse\n\t\tgoya_init_static_firmware_loader(hdev);\n}\n\nstatic int goya_init_cpu(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tint rc;\n\n\tif (!(hdev->fw_components & FW_TYPE_PREBOOT_CPU))\n\t\treturn 0;\n\n\tif (goya->hw_cap_initialized & HW_CAP_CPU)\n\t\treturn 0;\n\n\t \n\tif (goya_set_ddr_bar_base(hdev, DRAM_PHYS_BASE) == U64_MAX) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"failed to map DDR bar to DRAM base address\\n\");\n\t\treturn -EIO;\n\t}\n\n\trc = hl_fw_init_cpu(hdev);\n\n\tif (rc)\n\t\treturn rc;\n\n\tgoya->hw_cap_initialized |= HW_CAP_CPU;\n\n\treturn 0;\n}\n\nstatic int goya_mmu_update_asid_hop0_addr(struct hl_device *hdev, u32 asid,\n\t\t\t\t\t\tu64 phys_addr)\n{\n\tu32 status, timeout_usec;\n\tint rc;\n\n\tif (hdev->pldm)\n\t\ttimeout_usec = GOYA_PLDM_MMU_TIMEOUT_USEC;\n\telse\n\t\ttimeout_usec = MMU_CONFIG_TIMEOUT_USEC;\n\n\tWREG32(MMU_HOP0_PA43_12, phys_addr >> MMU_HOP0_PA43_12_SHIFT);\n\tWREG32(MMU_HOP0_PA49_44, phys_addr >> MMU_HOP0_PA49_44_SHIFT);\n\tWREG32(MMU_ASID_BUSY, 0x80000000 | asid);\n\n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tMMU_ASID_BUSY,\n\t\tstatus,\n\t\t!(status & 0x80000000),\n\t\t1000,\n\t\ttimeout_usec);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Timeout during MMU hop0 config of asid %d\\n\", asid);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nint goya_mmu_init(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct goya_device *goya = hdev->asic_specific;\n\tu64 hop0_addr;\n\tint rc, i;\n\n\tif (goya->hw_cap_initialized & HW_CAP_MMU)\n\t\treturn 0;\n\n\thdev->dram_default_page_mapping = true;\n\n\tfor (i = 0 ; i < prop->max_asid ; i++) {\n\t\thop0_addr = prop->mmu_pgt_addr +\n\t\t\t\t(i * prop->mmu_hop_table_size);\n\n\t\trc = goya_mmu_update_asid_hop0_addr(hdev, i, hop0_addr);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"failed to set hop0 addr for asid %d\\n\", i);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tgoya->hw_cap_initialized |= HW_CAP_MMU;\n\n\t \n\tWREG32(mmSTLB_CACHE_INV_BASE_39_8,\n\t\t\t\tlower_32_bits(MMU_CACHE_MNG_ADDR >> 8));\n\tWREG32(mmSTLB_CACHE_INV_BASE_49_40, MMU_CACHE_MNG_ADDR >> 40);\n\n\t \n\tWREG32_AND(mmSTLB_STLB_FEATURE_EN,\n\t\t\t(~STLB_STLB_FEATURE_EN_FOLLOWER_EN_MASK));\n\n\thl_mmu_invalidate_cache(hdev, true, MMU_OP_USERPTR | MMU_OP_PHYS_PACK);\n\n\tWREG32(mmMMU_MMU_ENABLE, 1);\n\tWREG32(mmMMU_SPI_MASK, 0xF);\n\n\treturn 0;\n\nerr:\n\treturn rc;\n}\n\n \nstatic int goya_hw_init(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tint rc;\n\n\t \n\tRREG32(mmPCIE_DBI_DEVICE_ID_VENDOR_ID_REG);\n\n\t \n\tWREG32(mmHW_STATE, HL_DEVICE_HW_STATE_DIRTY);\n\n\trc = goya_init_cpu(hdev);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to initialize CPU\\n\");\n\t\treturn rc;\n\t}\n\n\tgoya_tpc_mbist_workaround(hdev);\n\n\tgoya_init_golden_registers(hdev);\n\n\t \n\tif (goya_set_ddr_bar_base(hdev, (MMU_PAGE_TABLES_ADDR &\n\t\t\t~(prop->dram_pci_bar_size - 0x1ull))) == U64_MAX) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"failed to map DDR bar to MMU page tables\\n\");\n\t\treturn -EIO;\n\t}\n\n\trc = goya_mmu_init(hdev);\n\tif (rc)\n\t\treturn rc;\n\n\tgoya_init_security(hdev);\n\n\tgoya_init_dma_qmans(hdev);\n\n\tgoya_init_mme_qmans(hdev);\n\n\tgoya_init_tpc_qmans(hdev);\n\n\tgoya_enable_timestamp(hdev);\n\n\t \n\trc = goya_enable_msix(hdev);\n\tif (rc)\n\t\tgoto disable_queues;\n\n\t \n\tRREG32(mmPCIE_DBI_DEVICE_ID_VENDOR_ID_REG);\n\n\treturn 0;\n\ndisable_queues:\n\tgoya_disable_internal_queues(hdev);\n\tgoya_disable_external_queues(hdev);\n\n\treturn rc;\n}\n\nstatic int goya_hw_fini(struct hl_device *hdev, bool hard_reset, bool fw_reset)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tu32 reset_timeout_ms, cpu_timeout_ms, status;\n\n\tif (hdev->pldm) {\n\t\treset_timeout_ms = GOYA_PLDM_RESET_TIMEOUT_MSEC;\n\t\tcpu_timeout_ms = GOYA_PLDM_RESET_WAIT_MSEC;\n\t} else {\n\t\treset_timeout_ms = GOYA_RESET_TIMEOUT_MSEC;\n\t\tcpu_timeout_ms = GOYA_CPU_RESET_WAIT_MSEC;\n\t}\n\n\tif (hard_reset) {\n\t\t \n\t\tWREG32(mmPSOC_GLOBAL_CONF_UBOOT_MAGIC, KMD_MSG_GOTO_WFE);\n\t\tWREG32(mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR,\n\t\t\tGOYA_ASYNC_EVENT_ID_HALT_MACHINE);\n\n\t\tmsleep(cpu_timeout_ms);\n\n\t\tgoya_set_ddr_bar_base(hdev, DRAM_PHYS_BASE);\n\t\tgoya_disable_clk_rlx(hdev);\n\t\tgoya_set_pll_refclk(hdev);\n\n\t\tWREG32(mmPSOC_GLOBAL_CONF_SW_ALL_RST_CFG, RESET_ALL);\n\t\tdev_dbg(hdev->dev,\n\t\t\t\"Issued HARD reset command, going to wait %dms\\n\",\n\t\t\treset_timeout_ms);\n\t} else {\n\t\tWREG32(mmPSOC_GLOBAL_CONF_SW_ALL_RST_CFG, DMA_MME_TPC_RESET);\n\t\tdev_dbg(hdev->dev,\n\t\t\t\"Issued SOFT reset command, going to wait %dms\\n\",\n\t\t\treset_timeout_ms);\n\t}\n\n\t \n\tmsleep(reset_timeout_ms);\n\n\tstatus = RREG32(mmPSOC_GLOBAL_CONF_BTM_FSM);\n\tif (status & PSOC_GLOBAL_CONF_BTM_FSM_STATE_MASK) {\n\t\tdev_err(hdev->dev, \"Timeout while waiting for device to reset 0x%x\\n\", status);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (!hard_reset && goya) {\n\t\tgoya->hw_cap_initialized &= ~(HW_CAP_DMA | HW_CAP_MME |\n\t\t\t\t\t\tHW_CAP_GOLDEN | HW_CAP_TPC);\n\t\tWREG32(mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR,\n\t\t\t\tGOYA_ASYNC_EVENT_ID_SOFT_RESET);\n\t\treturn 0;\n\t}\n\n\t \n\tWREG32(mmPSOC_GLOBAL_CONF_BOOT_SEQ_RE_START,\n\t\t1 << PSOC_GLOBAL_CONF_BOOT_SEQ_RE_START_IND_SHIFT);\n\t \n\tWREG32(mmPSOC_GLOBAL_CONF_SW_BTM_FSM,\n\t\t\t0xA << PSOC_GLOBAL_CONF_SW_BTM_FSM_CTRL_SHIFT);\n\n\tif (goya) {\n\t\tgoya->hw_cap_initialized &= ~(HW_CAP_CPU | HW_CAP_CPU_Q |\n\t\t\t\tHW_CAP_DDR_0 | HW_CAP_DDR_1 |\n\t\t\t\tHW_CAP_DMA | HW_CAP_MME |\n\t\t\t\tHW_CAP_MMU | HW_CAP_TPC_MBIST |\n\t\t\t\tHW_CAP_GOLDEN | HW_CAP_TPC);\n\n\t\tmemset(goya->events_stat, 0, sizeof(goya->events_stat));\n\t}\n\treturn 0;\n}\n\nint goya_suspend(struct hl_device *hdev)\n{\n\tint rc;\n\n\trc = hl_fw_send_pci_access_msg(hdev, CPUCP_PACKET_DISABLE_PCI_ACCESS, 0x0);\n\tif (rc)\n\t\tdev_err(hdev->dev, \"Failed to disable PCI access from CPU\\n\");\n\n\treturn rc;\n}\n\nint goya_resume(struct hl_device *hdev)\n{\n\treturn goya_init_iatu(hdev);\n}\n\nstatic int goya_mmap(struct hl_device *hdev, struct vm_area_struct *vma,\n\t\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size)\n{\n\tint rc;\n\n\tvm_flags_set(vma, VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP |\n\t\t\tVM_DONTCOPY | VM_NORESERVE);\n\n\trc = dma_mmap_coherent(hdev->dev, vma, cpu_addr,\n\t\t\t\t(dma_addr - HOST_PHYS_BASE), size);\n\tif (rc)\n\t\tdev_err(hdev->dev, \"dma_mmap_coherent error %d\", rc);\n\n\treturn rc;\n}\n\nvoid goya_ring_doorbell(struct hl_device *hdev, u32 hw_queue_id, u32 pi)\n{\n\tu32 db_reg_offset, db_value;\n\n\tswitch (hw_queue_id) {\n\tcase GOYA_QUEUE_ID_DMA_0:\n\t\tdb_reg_offset = mmDMA_QM_0_PQ_PI;\n\t\tbreak;\n\n\tcase GOYA_QUEUE_ID_DMA_1:\n\t\tdb_reg_offset = mmDMA_QM_1_PQ_PI;\n\t\tbreak;\n\n\tcase GOYA_QUEUE_ID_DMA_2:\n\t\tdb_reg_offset = mmDMA_QM_2_PQ_PI;\n\t\tbreak;\n\n\tcase GOYA_QUEUE_ID_DMA_3:\n\t\tdb_reg_offset = mmDMA_QM_3_PQ_PI;\n\t\tbreak;\n\n\tcase GOYA_QUEUE_ID_DMA_4:\n\t\tdb_reg_offset = mmDMA_QM_4_PQ_PI;\n\t\tbreak;\n\n\tcase GOYA_QUEUE_ID_CPU_PQ:\n\t\tdb_reg_offset = mmCPU_IF_PF_PQ_PI;\n\t\tbreak;\n\n\tcase GOYA_QUEUE_ID_MME:\n\t\tdb_reg_offset = mmMME_QM_PQ_PI;\n\t\tbreak;\n\n\tcase GOYA_QUEUE_ID_TPC0:\n\t\tdb_reg_offset = mmTPC0_QM_PQ_PI;\n\t\tbreak;\n\n\tcase GOYA_QUEUE_ID_TPC1:\n\t\tdb_reg_offset = mmTPC1_QM_PQ_PI;\n\t\tbreak;\n\n\tcase GOYA_QUEUE_ID_TPC2:\n\t\tdb_reg_offset = mmTPC2_QM_PQ_PI;\n\t\tbreak;\n\n\tcase GOYA_QUEUE_ID_TPC3:\n\t\tdb_reg_offset = mmTPC3_QM_PQ_PI;\n\t\tbreak;\n\n\tcase GOYA_QUEUE_ID_TPC4:\n\t\tdb_reg_offset = mmTPC4_QM_PQ_PI;\n\t\tbreak;\n\n\tcase GOYA_QUEUE_ID_TPC5:\n\t\tdb_reg_offset = mmTPC5_QM_PQ_PI;\n\t\tbreak;\n\n\tcase GOYA_QUEUE_ID_TPC6:\n\t\tdb_reg_offset = mmTPC6_QM_PQ_PI;\n\t\tbreak;\n\n\tcase GOYA_QUEUE_ID_TPC7:\n\t\tdb_reg_offset = mmTPC7_QM_PQ_PI;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tdev_err(hdev->dev, \"H/W queue %d is invalid. Can't set pi\\n\",\n\t\t\thw_queue_id);\n\t\treturn;\n\t}\n\n\tdb_value = pi;\n\n\t \n\tWREG32(db_reg_offset, db_value);\n\n\tif (hw_queue_id == GOYA_QUEUE_ID_CPU_PQ) {\n\t\t \n\t\tmb();\n\t\tWREG32(mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR,\n\t\t\t\tGOYA_ASYNC_EVENT_ID_PI_UPDATE);\n\t}\n}\n\nvoid goya_pqe_write(struct hl_device *hdev, __le64 *pqe, struct hl_bd *bd)\n{\n\t \n\tmemcpy_toio((void __iomem *) pqe, bd, sizeof(struct hl_bd));\n}\n\nstatic void *goya_dma_alloc_coherent(struct hl_device *hdev, size_t size,\n\t\t\t\t\tdma_addr_t *dma_handle, gfp_t flags)\n{\n\tvoid *kernel_addr = dma_alloc_coherent(&hdev->pdev->dev, size,\n\t\t\t\t\t\tdma_handle, flags);\n\n\t \n\tif (kernel_addr)\n\t\t*dma_handle += HOST_PHYS_BASE;\n\n\treturn kernel_addr;\n}\n\nstatic void goya_dma_free_coherent(struct hl_device *hdev, size_t size,\n\t\t\t\t\tvoid *cpu_addr, dma_addr_t dma_handle)\n{\n\t \n\tdma_addr_t fixed_dma_handle = dma_handle - HOST_PHYS_BASE;\n\n\tdma_free_coherent(&hdev->pdev->dev, size, cpu_addr, fixed_dma_handle);\n}\n\nint goya_scrub_device_mem(struct hl_device *hdev)\n{\n\treturn 0;\n}\n\nvoid *goya_get_int_queue_base(struct hl_device *hdev, u32 queue_id,\n\t\t\t\tdma_addr_t *dma_handle,\tu16 *queue_len)\n{\n\tvoid *base;\n\tu32 offset;\n\n\t*dma_handle = hdev->asic_prop.sram_base_address;\n\n\tbase = (__force void *) hdev->pcie_bar[SRAM_CFG_BAR_ID];\n\n\tswitch (queue_id) {\n\tcase GOYA_QUEUE_ID_MME:\n\t\toffset = MME_QMAN_BASE_OFFSET;\n\t\t*queue_len = MME_QMAN_LENGTH;\n\t\tbreak;\n\tcase GOYA_QUEUE_ID_TPC0:\n\t\toffset = TPC0_QMAN_BASE_OFFSET;\n\t\t*queue_len = TPC_QMAN_LENGTH;\n\t\tbreak;\n\tcase GOYA_QUEUE_ID_TPC1:\n\t\toffset = TPC1_QMAN_BASE_OFFSET;\n\t\t*queue_len = TPC_QMAN_LENGTH;\n\t\tbreak;\n\tcase GOYA_QUEUE_ID_TPC2:\n\t\toffset = TPC2_QMAN_BASE_OFFSET;\n\t\t*queue_len = TPC_QMAN_LENGTH;\n\t\tbreak;\n\tcase GOYA_QUEUE_ID_TPC3:\n\t\toffset = TPC3_QMAN_BASE_OFFSET;\n\t\t*queue_len = TPC_QMAN_LENGTH;\n\t\tbreak;\n\tcase GOYA_QUEUE_ID_TPC4:\n\t\toffset = TPC4_QMAN_BASE_OFFSET;\n\t\t*queue_len = TPC_QMAN_LENGTH;\n\t\tbreak;\n\tcase GOYA_QUEUE_ID_TPC5:\n\t\toffset = TPC5_QMAN_BASE_OFFSET;\n\t\t*queue_len = TPC_QMAN_LENGTH;\n\t\tbreak;\n\tcase GOYA_QUEUE_ID_TPC6:\n\t\toffset = TPC6_QMAN_BASE_OFFSET;\n\t\t*queue_len = TPC_QMAN_LENGTH;\n\t\tbreak;\n\tcase GOYA_QUEUE_ID_TPC7:\n\t\toffset = TPC7_QMAN_BASE_OFFSET;\n\t\t*queue_len = TPC_QMAN_LENGTH;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdev->dev, \"Got invalid queue id %d\\n\", queue_id);\n\t\treturn NULL;\n\t}\n\n\tbase += offset;\n\t*dma_handle += offset;\n\n\treturn base;\n}\n\nstatic int goya_send_job_on_qman0(struct hl_device *hdev, struct hl_cs_job *job)\n{\n\tstruct packet_msg_prot *fence_pkt;\n\tu32 *fence_ptr;\n\tdma_addr_t fence_dma_addr;\n\tstruct hl_cb *cb;\n\tu32 tmp, timeout;\n\tint rc;\n\n\tif (hdev->pldm)\n\t\ttimeout = GOYA_PLDM_QMAN0_TIMEOUT_USEC;\n\telse\n\t\ttimeout = HL_DEVICE_TIMEOUT_USEC;\n\n\tif (!hdev->asic_funcs->is_device_idle(hdev, NULL, 0, NULL)) {\n\t\tdev_err_ratelimited(hdev->dev,\n\t\t\t\"Can't send driver job on QMAN0 because the device is not idle\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tfence_ptr = hl_asic_dma_pool_zalloc(hdev, 4, GFP_KERNEL, &fence_dma_addr);\n\tif (!fence_ptr) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate fence memory for QMAN0\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgoya_qman0_set_security(hdev, true);\n\n\tcb = job->patched_cb;\n\n\tfence_pkt = cb->kernel_address +\n\t\t\tjob->job_cb_size - sizeof(struct packet_msg_prot);\n\n\ttmp = (PACKET_MSG_PROT << GOYA_PKT_CTL_OPCODE_SHIFT) |\n\t\t\t(1 << GOYA_PKT_CTL_EB_SHIFT) |\n\t\t\t(1 << GOYA_PKT_CTL_MB_SHIFT);\n\tfence_pkt->ctl = cpu_to_le32(tmp);\n\tfence_pkt->value = cpu_to_le32(GOYA_QMAN0_FENCE_VAL);\n\tfence_pkt->addr = cpu_to_le64(fence_dma_addr);\n\n\trc = hl_hw_queue_send_cb_no_cmpl(hdev, GOYA_QUEUE_ID_DMA_0,\n\t\t\t\t\tjob->job_cb_size, cb->bus_address);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to send CB on QMAN0, %d\\n\", rc);\n\t\tgoto free_fence_ptr;\n\t}\n\n\trc = hl_poll_timeout_memory(hdev, fence_ptr, tmp,\n\t\t\t\t(tmp == GOYA_QMAN0_FENCE_VAL), 1000,\n\t\t\t\ttimeout, true);\n\n\thl_hw_queue_inc_ci_kernel(hdev, GOYA_QUEUE_ID_DMA_0);\n\n\tif (rc == -ETIMEDOUT) {\n\t\tdev_err(hdev->dev, \"QMAN0 Job timeout (0x%x)\\n\", tmp);\n\t\tgoto free_fence_ptr;\n\t}\n\nfree_fence_ptr:\n\thl_asic_dma_pool_free(hdev, (void *) fence_ptr, fence_dma_addr);\n\n\tgoya_qman0_set_security(hdev, false);\n\n\treturn rc;\n}\n\nint goya_send_cpu_message(struct hl_device *hdev, u32 *msg, u16 len,\n\t\t\t\tu32 timeout, u64 *result)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_CPU_Q)) {\n\t\tif (result)\n\t\t\t*result = 0;\n\t\treturn 0;\n\t}\n\n\tif (!timeout)\n\t\ttimeout = GOYA_MSG_TO_CPU_TIMEOUT_USEC;\n\n\treturn hl_fw_send_cpu_message(hdev, GOYA_QUEUE_ID_CPU_PQ, msg, len,\n\t\t\t\t\ttimeout, result);\n}\n\nint goya_test_queue(struct hl_device *hdev, u32 hw_queue_id)\n{\n\tstruct packet_msg_prot *fence_pkt;\n\tdma_addr_t pkt_dma_addr;\n\tu32 fence_val, tmp;\n\tdma_addr_t fence_dma_addr;\n\tu32 *fence_ptr;\n\tint rc;\n\n\tfence_val = GOYA_QMAN0_FENCE_VAL;\n\n\tfence_ptr = hl_asic_dma_pool_zalloc(hdev, 4, GFP_KERNEL, &fence_dma_addr);\n\tif (!fence_ptr) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate memory for H/W queue %d testing\\n\",\n\t\t\thw_queue_id);\n\t\treturn -ENOMEM;\n\t}\n\n\t*fence_ptr = 0;\n\n\tfence_pkt = hl_asic_dma_pool_zalloc(hdev, sizeof(struct packet_msg_prot), GFP_KERNEL,\n\t\t\t\t\t\t&pkt_dma_addr);\n\tif (!fence_pkt) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate packet for H/W queue %d testing\\n\",\n\t\t\thw_queue_id);\n\t\trc = -ENOMEM;\n\t\tgoto free_fence_ptr;\n\t}\n\n\ttmp = (PACKET_MSG_PROT << GOYA_PKT_CTL_OPCODE_SHIFT) |\n\t\t\t(1 << GOYA_PKT_CTL_EB_SHIFT) |\n\t\t\t(1 << GOYA_PKT_CTL_MB_SHIFT);\n\tfence_pkt->ctl = cpu_to_le32(tmp);\n\tfence_pkt->value = cpu_to_le32(fence_val);\n\tfence_pkt->addr = cpu_to_le64(fence_dma_addr);\n\n\trc = hl_hw_queue_send_cb_no_cmpl(hdev, hw_queue_id,\n\t\t\t\t\tsizeof(struct packet_msg_prot),\n\t\t\t\t\tpkt_dma_addr);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to send fence packet to H/W queue %d\\n\",\n\t\t\thw_queue_id);\n\t\tgoto free_pkt;\n\t}\n\n\trc = hl_poll_timeout_memory(hdev, fence_ptr, tmp, (tmp == fence_val),\n\t\t\t\t\t1000, GOYA_TEST_QUEUE_WAIT_USEC, true);\n\n\thl_hw_queue_inc_ci_kernel(hdev, hw_queue_id);\n\n\tif (rc == -ETIMEDOUT) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"H/W queue %d test failed (scratch(0x%08llX) == 0x%08X)\\n\",\n\t\t\thw_queue_id, (unsigned long long) fence_dma_addr, tmp);\n\t\trc = -EIO;\n\t}\n\nfree_pkt:\n\thl_asic_dma_pool_free(hdev, (void *) fence_pkt, pkt_dma_addr);\nfree_fence_ptr:\n\thl_asic_dma_pool_free(hdev, (void *) fence_ptr, fence_dma_addr);\n\treturn rc;\n}\n\nint goya_test_cpu_queue(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\t \n\tif (!(goya->hw_cap_initialized & HW_CAP_CPU_Q))\n\t\treturn 0;\n\n\treturn hl_fw_test_cpu_queue(hdev);\n}\n\nint goya_test_queues(struct hl_device *hdev)\n{\n\tint i, rc, ret_val = 0;\n\n\tfor (i = 0 ; i < NUMBER_OF_EXT_HW_QUEUES ; i++) {\n\t\trc = goya_test_queue(hdev, i);\n\t\tif (rc)\n\t\t\tret_val = -EINVAL;\n\t}\n\n\treturn ret_val;\n}\n\nstatic void *goya_dma_pool_zalloc(struct hl_device *hdev, size_t size,\n\t\t\t\t\tgfp_t mem_flags, dma_addr_t *dma_handle)\n{\n\tvoid *kernel_addr;\n\n\tif (size > GOYA_DMA_POOL_BLK_SIZE)\n\t\treturn NULL;\n\n\tkernel_addr =  dma_pool_zalloc(hdev->dma_pool, mem_flags, dma_handle);\n\n\t \n\tif (kernel_addr)\n\t\t*dma_handle += HOST_PHYS_BASE;\n\n\treturn kernel_addr;\n}\n\nstatic void goya_dma_pool_free(struct hl_device *hdev, void *vaddr,\n\t\t\t\tdma_addr_t dma_addr)\n{\n\t \n\tdma_addr_t fixed_dma_addr = dma_addr - HOST_PHYS_BASE;\n\n\tdma_pool_free(hdev->dma_pool, vaddr, fixed_dma_addr);\n}\n\nvoid *goya_cpu_accessible_dma_pool_alloc(struct hl_device *hdev, size_t size,\n\t\t\t\t\tdma_addr_t *dma_handle)\n{\n\tvoid *vaddr;\n\n\tvaddr = hl_fw_cpu_accessible_dma_pool_alloc(hdev, size, dma_handle);\n\t*dma_handle = (*dma_handle) - hdev->cpu_accessible_dma_address +\n\t\t\tVA_CPU_ACCESSIBLE_MEM_ADDR;\n\n\treturn vaddr;\n}\n\nvoid goya_cpu_accessible_dma_pool_free(struct hl_device *hdev, size_t size,\n\t\t\t\t\tvoid *vaddr)\n{\n\thl_fw_cpu_accessible_dma_pool_free(hdev, size, vaddr);\n}\n\nu32 goya_get_dma_desc_list_size(struct hl_device *hdev, struct sg_table *sgt)\n{\n\tstruct scatterlist *sg, *sg_next_iter;\n\tu32 count, dma_desc_cnt;\n\tu64 len, len_next;\n\tdma_addr_t addr, addr_next;\n\n\tdma_desc_cnt = 0;\n\n\tfor_each_sgtable_dma_sg(sgt, sg, count) {\n\t\tlen = sg_dma_len(sg);\n\t\taddr = sg_dma_address(sg);\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\twhile ((count + 1) < sgt->nents) {\n\t\t\tsg_next_iter = sg_next(sg);\n\t\t\tlen_next = sg_dma_len(sg_next_iter);\n\t\t\taddr_next = sg_dma_address(sg_next_iter);\n\n\t\t\tif (len_next == 0)\n\t\t\t\tbreak;\n\n\t\t\tif ((addr + len == addr_next) &&\n\t\t\t\t(len + len_next <= DMA_MAX_TRANSFER_SIZE)) {\n\t\t\t\tlen += len_next;\n\t\t\t\tcount++;\n\t\t\t\tsg = sg_next_iter;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdma_desc_cnt++;\n\t}\n\n\treturn dma_desc_cnt * sizeof(struct packet_lin_dma);\n}\n\nstatic int goya_pin_memory_before_cs(struct hl_device *hdev,\n\t\t\t\tstruct hl_cs_parser *parser,\n\t\t\t\tstruct packet_lin_dma *user_dma_pkt,\n\t\t\t\tu64 addr, enum dma_data_direction dir)\n{\n\tstruct hl_userptr *userptr;\n\tint rc;\n\n\tif (hl_userptr_is_pinned(hdev, addr, le32_to_cpu(user_dma_pkt->tsize),\n\t\t\tparser->job_userptr_list, &userptr))\n\t\tgoto already_pinned;\n\n\tuserptr = kzalloc(sizeof(*userptr), GFP_KERNEL);\n\tif (!userptr)\n\t\treturn -ENOMEM;\n\n\trc = hl_pin_host_memory(hdev, addr, le32_to_cpu(user_dma_pkt->tsize),\n\t\t\t\tuserptr);\n\tif (rc)\n\t\tgoto free_userptr;\n\n\tlist_add_tail(&userptr->job_node, parser->job_userptr_list);\n\n\trc = hdev->asic_funcs->asic_dma_map_sgtable(hdev, userptr->sgt, dir);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"failed to map sgt with DMA region\\n\");\n\t\tgoto unpin_memory;\n\t}\n\n\tuserptr->dma_mapped = true;\n\tuserptr->dir = dir;\n\nalready_pinned:\n\tparser->patched_cb_size +=\n\t\t\tgoya_get_dma_desc_list_size(hdev, userptr->sgt);\n\n\treturn 0;\n\nunpin_memory:\n\tlist_del(&userptr->job_node);\n\thl_unpin_host_memory(hdev, userptr);\nfree_userptr:\n\tkfree(userptr);\n\treturn rc;\n}\n\nstatic int goya_validate_dma_pkt_host(struct hl_device *hdev,\n\t\t\t\tstruct hl_cs_parser *parser,\n\t\t\t\tstruct packet_lin_dma *user_dma_pkt)\n{\n\tu64 device_memory_addr, addr;\n\tenum dma_data_direction dir;\n\tenum hl_goya_dma_direction user_dir;\n\tbool sram_addr = true;\n\tbool skip_host_mem_pin = false;\n\tbool user_memset;\n\tu32 ctl;\n\tint rc = 0;\n\n\tctl = le32_to_cpu(user_dma_pkt->ctl);\n\n\tuser_dir = (ctl & GOYA_PKT_LIN_DMA_CTL_DMA_DIR_MASK) >>\n\t\t\tGOYA_PKT_LIN_DMA_CTL_DMA_DIR_SHIFT;\n\n\tuser_memset = (ctl & GOYA_PKT_LIN_DMA_CTL_MEMSET_MASK) >>\n\t\t\tGOYA_PKT_LIN_DMA_CTL_MEMSET_SHIFT;\n\n\tswitch (user_dir) {\n\tcase HL_DMA_HOST_TO_DRAM:\n\t\tdev_dbg(hdev->dev, \"DMA direction is HOST --> DRAM\\n\");\n\t\tdir = DMA_TO_DEVICE;\n\t\tsram_addr = false;\n\t\taddr = le64_to_cpu(user_dma_pkt->src_addr);\n\t\tdevice_memory_addr = le64_to_cpu(user_dma_pkt->dst_addr);\n\t\tif (user_memset)\n\t\t\tskip_host_mem_pin = true;\n\t\tbreak;\n\n\tcase HL_DMA_DRAM_TO_HOST:\n\t\tdev_dbg(hdev->dev, \"DMA direction is DRAM --> HOST\\n\");\n\t\tdir = DMA_FROM_DEVICE;\n\t\tsram_addr = false;\n\t\taddr = le64_to_cpu(user_dma_pkt->dst_addr);\n\t\tdevice_memory_addr = le64_to_cpu(user_dma_pkt->src_addr);\n\t\tbreak;\n\n\tcase HL_DMA_HOST_TO_SRAM:\n\t\tdev_dbg(hdev->dev, \"DMA direction is HOST --> SRAM\\n\");\n\t\tdir = DMA_TO_DEVICE;\n\t\taddr = le64_to_cpu(user_dma_pkt->src_addr);\n\t\tdevice_memory_addr = le64_to_cpu(user_dma_pkt->dst_addr);\n\t\tif (user_memset)\n\t\t\tskip_host_mem_pin = true;\n\t\tbreak;\n\n\tcase HL_DMA_SRAM_TO_HOST:\n\t\tdev_dbg(hdev->dev, \"DMA direction is SRAM --> HOST\\n\");\n\t\tdir = DMA_FROM_DEVICE;\n\t\taddr = le64_to_cpu(user_dma_pkt->dst_addr);\n\t\tdevice_memory_addr = le64_to_cpu(user_dma_pkt->src_addr);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdev->dev, \"DMA direction %d is unsupported/undefined\\n\", user_dir);\n\t\treturn -EFAULT;\n\t}\n\n\tif (sram_addr) {\n\t\tif (!hl_mem_area_inside_range(device_memory_addr,\n\t\t\t\tle32_to_cpu(user_dma_pkt->tsize),\n\t\t\t\thdev->asic_prop.sram_user_base_address,\n\t\t\t\thdev->asic_prop.sram_end_address)) {\n\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"SRAM address 0x%llx + 0x%x is invalid\\n\",\n\t\t\t\tdevice_memory_addr,\n\t\t\t\tuser_dma_pkt->tsize);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else {\n\t\tif (!hl_mem_area_inside_range(device_memory_addr,\n\t\t\t\tle32_to_cpu(user_dma_pkt->tsize),\n\t\t\t\thdev->asic_prop.dram_user_base_address,\n\t\t\t\thdev->asic_prop.dram_end_address)) {\n\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"DRAM address 0x%llx + 0x%x is invalid\\n\",\n\t\t\t\tdevice_memory_addr,\n\t\t\t\tuser_dma_pkt->tsize);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (skip_host_mem_pin)\n\t\tparser->patched_cb_size += sizeof(*user_dma_pkt);\n\telse {\n\t\tif ((dir == DMA_TO_DEVICE) &&\n\t\t\t\t(parser->hw_queue_id > GOYA_QUEUE_ID_DMA_1)) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Can't DMA from host on queue other then 1\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\trc = goya_pin_memory_before_cs(hdev, parser, user_dma_pkt,\n\t\t\t\t\t\taddr, dir);\n\t}\n\n\treturn rc;\n}\n\nstatic int goya_validate_dma_pkt_no_host(struct hl_device *hdev,\n\t\t\t\tstruct hl_cs_parser *parser,\n\t\t\t\tstruct packet_lin_dma *user_dma_pkt)\n{\n\tu64 sram_memory_addr, dram_memory_addr;\n\tenum hl_goya_dma_direction user_dir;\n\tu32 ctl;\n\n\tctl = le32_to_cpu(user_dma_pkt->ctl);\n\tuser_dir = (ctl & GOYA_PKT_LIN_DMA_CTL_DMA_DIR_MASK) >>\n\t\t\tGOYA_PKT_LIN_DMA_CTL_DMA_DIR_SHIFT;\n\n\tif (user_dir == HL_DMA_DRAM_TO_SRAM) {\n\t\tdev_dbg(hdev->dev, \"DMA direction is DRAM --> SRAM\\n\");\n\t\tdram_memory_addr = le64_to_cpu(user_dma_pkt->src_addr);\n\t\tsram_memory_addr = le64_to_cpu(user_dma_pkt->dst_addr);\n\t} else {\n\t\tdev_dbg(hdev->dev, \"DMA direction is SRAM --> DRAM\\n\");\n\t\tsram_memory_addr = le64_to_cpu(user_dma_pkt->src_addr);\n\t\tdram_memory_addr = le64_to_cpu(user_dma_pkt->dst_addr);\n\t}\n\n\tif (!hl_mem_area_inside_range(sram_memory_addr,\n\t\t\t\tle32_to_cpu(user_dma_pkt->tsize),\n\t\t\t\thdev->asic_prop.sram_user_base_address,\n\t\t\t\thdev->asic_prop.sram_end_address)) {\n\t\tdev_err(hdev->dev, \"SRAM address 0x%llx + 0x%x is invalid\\n\",\n\t\t\tsram_memory_addr, user_dma_pkt->tsize);\n\t\treturn -EFAULT;\n\t}\n\n\tif (!hl_mem_area_inside_range(dram_memory_addr,\n\t\t\t\tle32_to_cpu(user_dma_pkt->tsize),\n\t\t\t\thdev->asic_prop.dram_user_base_address,\n\t\t\t\thdev->asic_prop.dram_end_address)) {\n\t\tdev_err(hdev->dev, \"DRAM address 0x%llx + 0x%x is invalid\\n\",\n\t\t\tdram_memory_addr, user_dma_pkt->tsize);\n\t\treturn -EFAULT;\n\t}\n\n\tparser->patched_cb_size += sizeof(*user_dma_pkt);\n\n\treturn 0;\n}\n\nstatic int goya_validate_dma_pkt_no_mmu(struct hl_device *hdev,\n\t\t\t\tstruct hl_cs_parser *parser,\n\t\t\t\tstruct packet_lin_dma *user_dma_pkt)\n{\n\tenum hl_goya_dma_direction user_dir;\n\tu32 ctl;\n\tint rc;\n\n\tdev_dbg(hdev->dev, \"DMA packet details:\\n\");\n\tdev_dbg(hdev->dev, \"source == 0x%llx\\n\",\n\t\tle64_to_cpu(user_dma_pkt->src_addr));\n\tdev_dbg(hdev->dev, \"destination == 0x%llx\\n\",\n\t\tle64_to_cpu(user_dma_pkt->dst_addr));\n\tdev_dbg(hdev->dev, \"size == %u\\n\", le32_to_cpu(user_dma_pkt->tsize));\n\n\tctl = le32_to_cpu(user_dma_pkt->ctl);\n\tuser_dir = (ctl & GOYA_PKT_LIN_DMA_CTL_DMA_DIR_MASK) >>\n\t\t\tGOYA_PKT_LIN_DMA_CTL_DMA_DIR_SHIFT;\n\n\t \n\tif (user_dma_pkt->tsize == 0) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Got DMA with size 0, might reset the device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((user_dir == HL_DMA_DRAM_TO_SRAM) || (user_dir == HL_DMA_SRAM_TO_DRAM))\n\t\trc = goya_validate_dma_pkt_no_host(hdev, parser, user_dma_pkt);\n\telse\n\t\trc = goya_validate_dma_pkt_host(hdev, parser, user_dma_pkt);\n\n\treturn rc;\n}\n\nstatic int goya_validate_dma_pkt_mmu(struct hl_device *hdev,\n\t\t\t\tstruct hl_cs_parser *parser,\n\t\t\t\tstruct packet_lin_dma *user_dma_pkt)\n{\n\tdev_dbg(hdev->dev, \"DMA packet details:\\n\");\n\tdev_dbg(hdev->dev, \"source == 0x%llx\\n\",\n\t\tle64_to_cpu(user_dma_pkt->src_addr));\n\tdev_dbg(hdev->dev, \"destination == 0x%llx\\n\",\n\t\tle64_to_cpu(user_dma_pkt->dst_addr));\n\tdev_dbg(hdev->dev, \"size == %u\\n\", le32_to_cpu(user_dma_pkt->tsize));\n\n\t \n\tif (parser->hw_queue_id != GOYA_QUEUE_ID_DMA_1 &&\n\t\thl_mem_area_inside_range(le64_to_cpu(user_dma_pkt->src_addr),\n\t\t\t\tle32_to_cpu(user_dma_pkt->tsize),\n\t\t\t\thdev->asic_prop.pmmu.start_addr,\n\t\t\t\thdev->asic_prop.pmmu.end_addr)) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Can't DMA from host on queue other then 1\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (user_dma_pkt->tsize == 0) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Got DMA with size 0, might reset the device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tparser->patched_cb_size += sizeof(*user_dma_pkt);\n\n\treturn 0;\n}\n\nstatic int goya_validate_wreg32(struct hl_device *hdev,\n\t\t\t\tstruct hl_cs_parser *parser,\n\t\t\t\tstruct packet_wreg32 *wreg_pkt)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tu32 sob_start_addr, sob_end_addr;\n\tu16 reg_offset;\n\n\treg_offset = le32_to_cpu(wreg_pkt->ctl) &\n\t\t\tGOYA_PKT_WREG32_CTL_REG_OFFSET_MASK;\n\n\tdev_dbg(hdev->dev, \"WREG32 packet details:\\n\");\n\tdev_dbg(hdev->dev, \"reg_offset == 0x%x\\n\", reg_offset);\n\tdev_dbg(hdev->dev, \"value      == 0x%x\\n\",\n\t\tle32_to_cpu(wreg_pkt->value));\n\n\tif (reg_offset != (mmDMA_CH_0_WR_COMP_ADDR_LO & 0x1FFF)) {\n\t\tdev_err(hdev->dev, \"WREG32 packet with illegal address 0x%x\\n\",\n\t\t\treg_offset);\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (goya->hw_cap_initialized & HW_CAP_MMU)\n\t\treturn 0;\n\n\tsob_start_addr = lower_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_0);\n\tsob_end_addr = lower_32_bits(CFG_BASE + mmSYNC_MNGR_SOB_OBJ_1023);\n\n\tif ((le32_to_cpu(wreg_pkt->value) < sob_start_addr) ||\n\t\t\t(le32_to_cpu(wreg_pkt->value) > sob_end_addr)) {\n\n\t\tdev_err(hdev->dev, \"WREG32 packet with illegal value 0x%x\\n\",\n\t\t\twreg_pkt->value);\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\nstatic int goya_validate_cb(struct hl_device *hdev,\n\t\t\tstruct hl_cs_parser *parser, bool is_mmu)\n{\n\tu32 cb_parsed_length = 0;\n\tint rc = 0;\n\n\tparser->patched_cb_size = 0;\n\n\t \n\twhile (cb_parsed_length < parser->user_cb_size) {\n\t\tenum packet_id pkt_id;\n\t\tu16 pkt_size;\n\t\tstruct goya_packet *user_pkt;\n\n\t\tuser_pkt = parser->user_cb->kernel_address + cb_parsed_length;\n\n\t\tpkt_id = (enum packet_id) (\n\t\t\t\t(le64_to_cpu(user_pkt->header) &\n\t\t\t\tPACKET_HEADER_PACKET_ID_MASK) >>\n\t\t\t\t\tPACKET_HEADER_PACKET_ID_SHIFT);\n\n\t\tif (!validate_packet_id(pkt_id)) {\n\t\t\tdev_err(hdev->dev, \"Invalid packet id %u\\n\", pkt_id);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpkt_size = goya_packet_sizes[pkt_id];\n\t\tcb_parsed_length += pkt_size;\n\t\tif (cb_parsed_length > parser->user_cb_size) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"packet 0x%x is out of CB boundary\\n\", pkt_id);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (pkt_id) {\n\t\tcase PACKET_WREG_32:\n\t\t\t \n\t\t\trc = goya_validate_wreg32(hdev,\n\t\t\t\tparser, (struct packet_wreg32 *) user_pkt);\n\t\t\tparser->patched_cb_size += pkt_size;\n\t\t\tbreak;\n\n\t\tcase PACKET_WREG_BULK:\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"User not allowed to use WREG_BULK\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_MSG_PROT:\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"User not allowed to use MSG_PROT\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_CP_DMA:\n\t\t\tdev_err(hdev->dev, \"User not allowed to use CP_DMA\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_STOP:\n\t\t\tdev_err(hdev->dev, \"User not allowed to use STOP\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_LIN_DMA:\n\t\t\tif (is_mmu)\n\t\t\t\trc = goya_validate_dma_pkt_mmu(hdev, parser,\n\t\t\t\t\t(struct packet_lin_dma *) user_pkt);\n\t\t\telse\n\t\t\t\trc = goya_validate_dma_pkt_no_mmu(hdev, parser,\n\t\t\t\t\t(struct packet_lin_dma *) user_pkt);\n\t\t\tbreak;\n\n\t\tcase PACKET_MSG_LONG:\n\t\tcase PACKET_MSG_SHORT:\n\t\tcase PACKET_FENCE:\n\t\tcase PACKET_NOP:\n\t\t\tparser->patched_cb_size += pkt_size;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(hdev->dev, \"Invalid packet header 0x%x\\n\",\n\t\t\t\tpkt_id);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\t \n\tparser->patched_cb_size += sizeof(struct packet_msg_prot) * 2;\n\n\treturn rc;\n}\n\nstatic int goya_patch_dma_packet(struct hl_device *hdev,\n\t\t\t\tstruct hl_cs_parser *parser,\n\t\t\t\tstruct packet_lin_dma *user_dma_pkt,\n\t\t\t\tstruct packet_lin_dma *new_dma_pkt,\n\t\t\t\tu32 *new_dma_pkt_size)\n{\n\tstruct hl_userptr *userptr;\n\tstruct scatterlist *sg, *sg_next_iter;\n\tu32 count, dma_desc_cnt;\n\tu64 len, len_next;\n\tdma_addr_t dma_addr, dma_addr_next;\n\tenum hl_goya_dma_direction user_dir;\n\tu64 device_memory_addr, addr;\n\tenum dma_data_direction dir;\n\tstruct sg_table *sgt;\n\tbool skip_host_mem_pin = false;\n\tbool user_memset;\n\tu32 user_rdcomp_mask, user_wrcomp_mask, ctl;\n\n\tctl = le32_to_cpu(user_dma_pkt->ctl);\n\n\tuser_dir = (ctl & GOYA_PKT_LIN_DMA_CTL_DMA_DIR_MASK) >>\n\t\t\tGOYA_PKT_LIN_DMA_CTL_DMA_DIR_SHIFT;\n\n\tuser_memset = (ctl & GOYA_PKT_LIN_DMA_CTL_MEMSET_MASK) >>\n\t\t\tGOYA_PKT_LIN_DMA_CTL_MEMSET_SHIFT;\n\n\tif ((user_dir == HL_DMA_DRAM_TO_SRAM) || (user_dir == HL_DMA_SRAM_TO_DRAM) ||\n\t\t\t(user_dma_pkt->tsize == 0)) {\n\t\tmemcpy(new_dma_pkt, user_dma_pkt, sizeof(*new_dma_pkt));\n\t\t*new_dma_pkt_size = sizeof(*new_dma_pkt);\n\t\treturn 0;\n\t}\n\n\tif ((user_dir == HL_DMA_HOST_TO_DRAM) || (user_dir == HL_DMA_HOST_TO_SRAM)) {\n\t\taddr = le64_to_cpu(user_dma_pkt->src_addr);\n\t\tdevice_memory_addr = le64_to_cpu(user_dma_pkt->dst_addr);\n\t\tdir = DMA_TO_DEVICE;\n\t\tif (user_memset)\n\t\t\tskip_host_mem_pin = true;\n\t} else {\n\t\taddr = le64_to_cpu(user_dma_pkt->dst_addr);\n\t\tdevice_memory_addr = le64_to_cpu(user_dma_pkt->src_addr);\n\t\tdir = DMA_FROM_DEVICE;\n\t}\n\n\tif ((!skip_host_mem_pin) &&\n\t\t(hl_userptr_is_pinned(hdev, addr,\n\t\t\tle32_to_cpu(user_dma_pkt->tsize),\n\t\t\tparser->job_userptr_list, &userptr) == false)) {\n\t\tdev_err(hdev->dev, \"Userptr 0x%llx + 0x%x NOT mapped\\n\",\n\t\t\t\taddr, user_dma_pkt->tsize);\n\t\treturn -EFAULT;\n\t}\n\n\tif ((user_memset) && (dir == DMA_TO_DEVICE)) {\n\t\tmemcpy(new_dma_pkt, user_dma_pkt, sizeof(*user_dma_pkt));\n\t\t*new_dma_pkt_size = sizeof(*user_dma_pkt);\n\t\treturn 0;\n\t}\n\n\tuser_rdcomp_mask = ctl & GOYA_PKT_LIN_DMA_CTL_RDCOMP_MASK;\n\n\tuser_wrcomp_mask = ctl & GOYA_PKT_LIN_DMA_CTL_WRCOMP_MASK;\n\n\tsgt = userptr->sgt;\n\tdma_desc_cnt = 0;\n\n\tfor_each_sgtable_dma_sg(sgt, sg, count) {\n\t\tlen = sg_dma_len(sg);\n\t\tdma_addr = sg_dma_address(sg);\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\twhile ((count + 1) < sgt->nents) {\n\t\t\tsg_next_iter = sg_next(sg);\n\t\t\tlen_next = sg_dma_len(sg_next_iter);\n\t\t\tdma_addr_next = sg_dma_address(sg_next_iter);\n\n\t\t\tif (len_next == 0)\n\t\t\t\tbreak;\n\n\t\t\tif ((dma_addr + len == dma_addr_next) &&\n\t\t\t\t(len + len_next <= DMA_MAX_TRANSFER_SIZE)) {\n\t\t\t\tlen += len_next;\n\t\t\t\tcount++;\n\t\t\t\tsg = sg_next_iter;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tctl = le32_to_cpu(user_dma_pkt->ctl);\n\t\tif (likely(dma_desc_cnt))\n\t\t\tctl &= ~GOYA_PKT_CTL_EB_MASK;\n\t\tctl &= ~(GOYA_PKT_LIN_DMA_CTL_RDCOMP_MASK |\n\t\t\t\tGOYA_PKT_LIN_DMA_CTL_WRCOMP_MASK);\n\t\tnew_dma_pkt->ctl = cpu_to_le32(ctl);\n\t\tnew_dma_pkt->tsize = cpu_to_le32((u32) len);\n\n\t\tif (dir == DMA_TO_DEVICE) {\n\t\t\tnew_dma_pkt->src_addr = cpu_to_le64(dma_addr);\n\t\t\tnew_dma_pkt->dst_addr = cpu_to_le64(device_memory_addr);\n\t\t} else {\n\t\t\tnew_dma_pkt->src_addr = cpu_to_le64(device_memory_addr);\n\t\t\tnew_dma_pkt->dst_addr = cpu_to_le64(dma_addr);\n\t\t}\n\n\t\tif (!user_memset)\n\t\t\tdevice_memory_addr += len;\n\t\tdma_desc_cnt++;\n\t\tnew_dma_pkt++;\n\t}\n\n\tif (!dma_desc_cnt) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Error of 0 SG entries when patching DMA packet\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tnew_dma_pkt--;\n\tnew_dma_pkt->ctl |= cpu_to_le32(user_rdcomp_mask | user_wrcomp_mask);\n\n\t*new_dma_pkt_size = dma_desc_cnt * sizeof(struct packet_lin_dma);\n\n\treturn 0;\n}\n\nstatic int goya_patch_cb(struct hl_device *hdev,\n\t\t\t\tstruct hl_cs_parser *parser)\n{\n\tu32 cb_parsed_length = 0;\n\tu32 cb_patched_cur_length = 0;\n\tint rc = 0;\n\n\t \n\twhile (cb_parsed_length < parser->user_cb_size) {\n\t\tenum packet_id pkt_id;\n\t\tu16 pkt_size;\n\t\tu32 new_pkt_size = 0;\n\t\tstruct goya_packet *user_pkt, *kernel_pkt;\n\n\t\tuser_pkt = parser->user_cb->kernel_address + cb_parsed_length;\n\t\tkernel_pkt = parser->patched_cb->kernel_address +\n\t\t\t\t\tcb_patched_cur_length;\n\n\t\tpkt_id = (enum packet_id) (\n\t\t\t\t(le64_to_cpu(user_pkt->header) &\n\t\t\t\tPACKET_HEADER_PACKET_ID_MASK) >>\n\t\t\t\t\tPACKET_HEADER_PACKET_ID_SHIFT);\n\n\t\tif (!validate_packet_id(pkt_id)) {\n\t\t\tdev_err(hdev->dev, \"Invalid packet id %u\\n\", pkt_id);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpkt_size = goya_packet_sizes[pkt_id];\n\t\tcb_parsed_length += pkt_size;\n\t\tif (cb_parsed_length > parser->user_cb_size) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"packet 0x%x is out of CB boundary\\n\", pkt_id);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (pkt_id) {\n\t\tcase PACKET_LIN_DMA:\n\t\t\trc = goya_patch_dma_packet(hdev, parser,\n\t\t\t\t\t(struct packet_lin_dma *) user_pkt,\n\t\t\t\t\t(struct packet_lin_dma *) kernel_pkt,\n\t\t\t\t\t&new_pkt_size);\n\t\t\tcb_patched_cur_length += new_pkt_size;\n\t\t\tbreak;\n\n\t\tcase PACKET_WREG_32:\n\t\t\tmemcpy(kernel_pkt, user_pkt, pkt_size);\n\t\t\tcb_patched_cur_length += pkt_size;\n\t\t\trc = goya_validate_wreg32(hdev, parser,\n\t\t\t\t\t(struct packet_wreg32 *) kernel_pkt);\n\t\t\tbreak;\n\n\t\tcase PACKET_WREG_BULK:\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"User not allowed to use WREG_BULK\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_MSG_PROT:\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"User not allowed to use MSG_PROT\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_CP_DMA:\n\t\t\tdev_err(hdev->dev, \"User not allowed to use CP_DMA\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_STOP:\n\t\t\tdev_err(hdev->dev, \"User not allowed to use STOP\\n\");\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\n\t\tcase PACKET_MSG_LONG:\n\t\tcase PACKET_MSG_SHORT:\n\t\tcase PACKET_FENCE:\n\t\tcase PACKET_NOP:\n\t\t\tmemcpy(kernel_pkt, user_pkt, pkt_size);\n\t\t\tcb_patched_cur_length += pkt_size;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(hdev->dev, \"Invalid packet header 0x%x\\n\",\n\t\t\t\tpkt_id);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int goya_parse_cb_mmu(struct hl_device *hdev,\n\t\tstruct hl_cs_parser *parser)\n{\n\tu64 handle;\n\tu32 patched_cb_size;\n\tstruct hl_cb *user_cb;\n\tint rc;\n\n\t \n\tparser->patched_cb_size = parser->user_cb_size +\n\t\t\tsizeof(struct packet_msg_prot) * 2;\n\n\trc = hl_cb_create(hdev, &hdev->kernel_mem_mgr, hdev->kernel_ctx,\n\t\t\t\tparser->patched_cb_size, false, false,\n\t\t\t\t&handle);\n\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate patched CB for DMA CS %d\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\tparser->patched_cb = hl_cb_get(&hdev->kernel_mem_mgr, handle);\n\t \n\tif (!parser->patched_cb) {\n\t\tdev_crit(hdev->dev, \"DMA CB handle invalid 0x%llx\\n\", handle);\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t \n\tmemcpy(parser->patched_cb->kernel_address,\n\t\tparser->user_cb->kernel_address,\n\t\tparser->user_cb_size);\n\n\tpatched_cb_size = parser->patched_cb_size;\n\n\t \n\tuser_cb = parser->user_cb;\n\tparser->user_cb = parser->patched_cb;\n\trc = goya_validate_cb(hdev, parser, true);\n\tparser->user_cb = user_cb;\n\n\tif (rc) {\n\t\thl_cb_put(parser->patched_cb);\n\t\tgoto out;\n\t}\n\n\tif (patched_cb_size != parser->patched_cb_size) {\n\t\tdev_err(hdev->dev, \"user CB size mismatch\\n\");\n\t\thl_cb_put(parser->patched_cb);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\t \n\thl_cb_destroy(&hdev->kernel_mem_mgr, handle);\n\n\treturn rc;\n}\n\nstatic int goya_parse_cb_no_mmu(struct hl_device *hdev,\n\t\t\t\tstruct hl_cs_parser *parser)\n{\n\tu64 handle;\n\tint rc;\n\n\trc = goya_validate_cb(hdev, parser, false);\n\n\tif (rc)\n\t\tgoto free_userptr;\n\n\trc = hl_cb_create(hdev, &hdev->kernel_mem_mgr, hdev->kernel_ctx,\n\t\t\t\tparser->patched_cb_size, false, false,\n\t\t\t\t&handle);\n\tif (rc) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Failed to allocate patched CB for DMA CS %d\\n\", rc);\n\t\tgoto free_userptr;\n\t}\n\n\tparser->patched_cb = hl_cb_get(&hdev->kernel_mem_mgr, handle);\n\t \n\tif (!parser->patched_cb) {\n\t\tdev_crit(hdev->dev, \"DMA CB handle invalid 0x%llx\\n\", handle);\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\trc = goya_patch_cb(hdev, parser);\n\n\tif (rc)\n\t\thl_cb_put(parser->patched_cb);\n\nout:\n\t \n\thl_cb_destroy(&hdev->kernel_mem_mgr, handle);\n\nfree_userptr:\n\tif (rc)\n\t\thl_userptr_delete_list(hdev, parser->job_userptr_list);\n\treturn rc;\n}\n\nstatic int goya_parse_cb_no_ext_queue(struct hl_device *hdev,\n\t\t\t\t\tstruct hl_cs_parser *parser)\n{\n\tstruct asic_fixed_properties *asic_prop = &hdev->asic_prop;\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (goya->hw_cap_initialized & HW_CAP_MMU)\n\t\treturn 0;\n\n\t \n\tif (hl_mem_area_inside_range(\n\t\t\t(u64) (uintptr_t) parser->user_cb,\n\t\t\tparser->user_cb_size,\n\t\t\tasic_prop->sram_user_base_address,\n\t\t\tasic_prop->sram_end_address))\n\t\treturn 0;\n\n\tif (hl_mem_area_inside_range(\n\t\t\t(u64) (uintptr_t) parser->user_cb,\n\t\t\tparser->user_cb_size,\n\t\t\tasic_prop->dram_user_base_address,\n\t\t\tasic_prop->dram_end_address))\n\t\treturn 0;\n\n\tdev_err(hdev->dev,\n\t\t\"Internal CB address 0x%px + 0x%x is not in SRAM nor in DRAM\\n\",\n\t\tparser->user_cb, parser->user_cb_size);\n\n\treturn -EFAULT;\n}\n\nint goya_cs_parser(struct hl_device *hdev, struct hl_cs_parser *parser)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (parser->queue_type == QUEUE_TYPE_INT)\n\t\treturn goya_parse_cb_no_ext_queue(hdev, parser);\n\n\tif (goya->hw_cap_initialized & HW_CAP_MMU)\n\t\treturn goya_parse_cb_mmu(hdev, parser);\n\telse\n\t\treturn goya_parse_cb_no_mmu(hdev, parser);\n}\n\nvoid goya_add_end_of_cb_packets(struct hl_device *hdev, void *kernel_address,\n\t\t\t\tu32 len, u32 original_len, u64 cq_addr, u32 cq_val,\n\t\t\t\tu32 msix_vec, bool eb)\n{\n\tstruct packet_msg_prot *cq_pkt;\n\tu32 tmp;\n\n\tcq_pkt = kernel_address + len - (sizeof(struct packet_msg_prot) * 2);\n\n\ttmp = (PACKET_MSG_PROT << GOYA_PKT_CTL_OPCODE_SHIFT) |\n\t\t\t(1 << GOYA_PKT_CTL_EB_SHIFT) |\n\t\t\t(1 << GOYA_PKT_CTL_MB_SHIFT);\n\tcq_pkt->ctl = cpu_to_le32(tmp);\n\tcq_pkt->value = cpu_to_le32(cq_val);\n\tcq_pkt->addr = cpu_to_le64(cq_addr);\n\n\tcq_pkt++;\n\n\ttmp = (PACKET_MSG_PROT << GOYA_PKT_CTL_OPCODE_SHIFT) |\n\t\t\t(1 << GOYA_PKT_CTL_MB_SHIFT);\n\tcq_pkt->ctl = cpu_to_le32(tmp);\n\tcq_pkt->value = cpu_to_le32(msix_vec & 0x7FF);\n\tcq_pkt->addr = cpu_to_le64(CFG_BASE + mmPCIE_DBI_MSIX_DOORBELL_OFF);\n}\n\nvoid goya_update_eq_ci(struct hl_device *hdev, u32 val)\n{\n\tWREG32(mmCPU_EQ_CI, val);\n}\n\nvoid goya_restore_phase_topology(struct hl_device *hdev)\n{\n\n}\n\nstatic void goya_clear_sm_regs(struct hl_device *hdev)\n{\n\tint i, num_of_sob_in_longs, num_of_mon_in_longs;\n\n\tnum_of_sob_in_longs =\n\t\t((mmSYNC_MNGR_SOB_OBJ_1023 - mmSYNC_MNGR_SOB_OBJ_0) + 4);\n\n\tnum_of_mon_in_longs =\n\t\t((mmSYNC_MNGR_MON_STATUS_255 - mmSYNC_MNGR_MON_STATUS_0) + 4);\n\n\tfor (i = 0 ; i < num_of_sob_in_longs ; i += 4)\n\t\tWREG32(mmSYNC_MNGR_SOB_OBJ_0 + i, 0);\n\n\tfor (i = 0 ; i < num_of_mon_in_longs ; i += 4)\n\t\tWREG32(mmSYNC_MNGR_MON_STATUS_0 + i, 0);\n\n\t \n\ti = RREG32(mmSYNC_MNGR_SOB_OBJ_0);\n}\n\nstatic int goya_debugfs_read_dma(struct hl_device *hdev, u64 addr, u32 size, void *blob_addr)\n{\n\tdev_err(hdev->dev, \"Reading via DMA is unimplemented yet\\n\");\n\treturn -EPERM;\n}\n\nstatic u64 goya_read_pte(struct hl_device *hdev, u64 addr)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (hdev->reset_info.hard_reset_pending)\n\t\treturn U64_MAX;\n\n\treturn readq(hdev->pcie_bar[DDR_BAR_ID] +\n\t\t\t(addr - goya->ddr_bar_cur_addr));\n}\n\nstatic void goya_write_pte(struct hl_device *hdev, u64 addr, u64 val)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (hdev->reset_info.hard_reset_pending)\n\t\treturn;\n\n\twriteq(val, hdev->pcie_bar[DDR_BAR_ID] +\n\t\t\t(addr - goya->ddr_bar_cur_addr));\n}\n\nstatic const char *_goya_get_event_desc(u16 event_type)\n{\n\tswitch (event_type) {\n\tcase GOYA_ASYNC_EVENT_ID_PCIE_IF:\n\t\treturn \"PCIe_if\";\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC1_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC2_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC3_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC4_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC5_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC6_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC7_ECC:\n\t\treturn \"TPC%d_ecc\";\n\tcase GOYA_ASYNC_EVENT_ID_MME_ECC:\n\t\treturn \"MME_ecc\";\n\tcase GOYA_ASYNC_EVENT_ID_MME_ECC_EXT:\n\t\treturn \"MME_ecc_ext\";\n\tcase GOYA_ASYNC_EVENT_ID_MMU_ECC:\n\t\treturn \"MMU_ecc\";\n\tcase GOYA_ASYNC_EVENT_ID_DMA_MACRO:\n\t\treturn \"DMA_macro\";\n\tcase GOYA_ASYNC_EVENT_ID_DMA_ECC:\n\t\treturn \"DMA_ecc\";\n\tcase GOYA_ASYNC_EVENT_ID_CPU_IF_ECC:\n\t\treturn \"CPU_if_ecc\";\n\tcase GOYA_ASYNC_EVENT_ID_PSOC_MEM:\n\t\treturn \"PSOC_mem\";\n\tcase GOYA_ASYNC_EVENT_ID_PSOC_CORESIGHT:\n\t\treturn \"PSOC_coresight\";\n\tcase GOYA_ASYNC_EVENT_ID_SRAM0 ... GOYA_ASYNC_EVENT_ID_SRAM29:\n\t\treturn \"SRAM%d\";\n\tcase GOYA_ASYNC_EVENT_ID_GIC500:\n\t\treturn \"GIC500\";\n\tcase GOYA_ASYNC_EVENT_ID_PLL0 ... GOYA_ASYNC_EVENT_ID_PLL6:\n\t\treturn \"PLL%d\";\n\tcase GOYA_ASYNC_EVENT_ID_AXI_ECC:\n\t\treturn \"AXI_ecc\";\n\tcase GOYA_ASYNC_EVENT_ID_L2_RAM_ECC:\n\t\treturn \"L2_ram_ecc\";\n\tcase GOYA_ASYNC_EVENT_ID_PSOC_GPIO_05_SW_RESET:\n\t\treturn \"PSOC_gpio_05_sw_reset\";\n\tcase GOYA_ASYNC_EVENT_ID_PSOC_GPIO_10_VRHOT_ICRIT:\n\t\treturn \"PSOC_gpio_10_vrhot_icrit\";\n\tcase GOYA_ASYNC_EVENT_ID_PCIE_DEC:\n\t\treturn \"PCIe_dec\";\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC1_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC2_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC3_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC4_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC5_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC6_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC7_DEC:\n\t\treturn \"TPC%d_dec\";\n\tcase GOYA_ASYNC_EVENT_ID_MME_WACS:\n\t\treturn \"MME_wacs\";\n\tcase GOYA_ASYNC_EVENT_ID_MME_WACSD:\n\t\treturn \"MME_wacsd\";\n\tcase GOYA_ASYNC_EVENT_ID_CPU_AXI_SPLITTER:\n\t\treturn \"CPU_axi_splitter\";\n\tcase GOYA_ASYNC_EVENT_ID_PSOC_AXI_DEC:\n\t\treturn \"PSOC_axi_dec\";\n\tcase GOYA_ASYNC_EVENT_ID_PSOC:\n\t\treturn \"PSOC\";\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC1_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC2_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC3_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC4_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC5_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC6_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC7_KRN_ERR:\n\t\treturn \"TPC%d_krn_err\";\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_CMDQ ... GOYA_ASYNC_EVENT_ID_TPC7_CMDQ:\n\t\treturn \"TPC%d_cq\";\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_QM ... GOYA_ASYNC_EVENT_ID_TPC7_QM:\n\t\treturn \"TPC%d_qm\";\n\tcase GOYA_ASYNC_EVENT_ID_MME_QM:\n\t\treturn \"MME_qm\";\n\tcase GOYA_ASYNC_EVENT_ID_MME_CMDQ:\n\t\treturn \"MME_cq\";\n\tcase GOYA_ASYNC_EVENT_ID_DMA0_QM ... GOYA_ASYNC_EVENT_ID_DMA4_QM:\n\t\treturn \"DMA%d_qm\";\n\tcase GOYA_ASYNC_EVENT_ID_DMA0_CH ... GOYA_ASYNC_EVENT_ID_DMA4_CH:\n\t\treturn \"DMA%d_ch\";\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC1_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC2_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC3_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC4_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC5_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC6_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC7_BMON_SPMU:\n\t\treturn \"TPC%d_bmon_spmu\";\n\tcase GOYA_ASYNC_EVENT_ID_DMA_BM_CH0 ... GOYA_ASYNC_EVENT_ID_DMA_BM_CH4:\n\t\treturn \"DMA_bm_ch%d\";\n\tcase GOYA_ASYNC_EVENT_ID_FIX_POWER_ENV_S:\n\t\treturn \"POWER_ENV_S\";\n\tcase GOYA_ASYNC_EVENT_ID_FIX_POWER_ENV_E:\n\t\treturn \"POWER_ENV_E\";\n\tcase GOYA_ASYNC_EVENT_ID_FIX_THERMAL_ENV_S:\n\t\treturn \"THERMAL_ENV_S\";\n\tcase GOYA_ASYNC_EVENT_ID_FIX_THERMAL_ENV_E:\n\t\treturn \"THERMAL_ENV_E\";\n\tcase GOYA_ASYNC_EVENT_PKT_QUEUE_OUT_SYNC:\n\t\treturn \"QUEUE_OUT_OF_SYNC\";\n\tdefault:\n\t\treturn \"N/A\";\n\t}\n}\n\nstatic void goya_get_event_desc(u16 event_type, char *desc, size_t size)\n{\n\tu8 index;\n\n\tswitch (event_type) {\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC1_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC2_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC3_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC4_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC5_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC6_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC7_ECC:\n\t\tindex = (event_type - GOYA_ASYNC_EVENT_ID_TPC0_ECC) / 3;\n\t\tsnprintf(desc, size, _goya_get_event_desc(event_type), index);\n\t\tbreak;\n\tcase GOYA_ASYNC_EVENT_ID_SRAM0 ... GOYA_ASYNC_EVENT_ID_SRAM29:\n\t\tindex = event_type - GOYA_ASYNC_EVENT_ID_SRAM0;\n\t\tsnprintf(desc, size, _goya_get_event_desc(event_type), index);\n\t\tbreak;\n\tcase GOYA_ASYNC_EVENT_ID_PLL0 ... GOYA_ASYNC_EVENT_ID_PLL6:\n\t\tindex = event_type - GOYA_ASYNC_EVENT_ID_PLL0;\n\t\tsnprintf(desc, size, _goya_get_event_desc(event_type), index);\n\t\tbreak;\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC1_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC2_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC3_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC4_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC5_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC6_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC7_DEC:\n\t\tindex = (event_type - GOYA_ASYNC_EVENT_ID_TPC0_DEC) / 3;\n\t\tsnprintf(desc, size, _goya_get_event_desc(event_type), index);\n\t\tbreak;\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC1_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC2_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC3_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC4_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC5_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC6_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC7_KRN_ERR:\n\t\tindex = (event_type - GOYA_ASYNC_EVENT_ID_TPC0_KRN_ERR) / 10;\n\t\tsnprintf(desc, size, _goya_get_event_desc(event_type), index);\n\t\tbreak;\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_CMDQ ... GOYA_ASYNC_EVENT_ID_TPC7_CMDQ:\n\t\tindex = event_type - GOYA_ASYNC_EVENT_ID_TPC0_CMDQ;\n\t\tsnprintf(desc, size, _goya_get_event_desc(event_type), index);\n\t\tbreak;\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_QM ... GOYA_ASYNC_EVENT_ID_TPC7_QM:\n\t\tindex = event_type - GOYA_ASYNC_EVENT_ID_TPC0_QM;\n\t\tsnprintf(desc, size, _goya_get_event_desc(event_type), index);\n\t\tbreak;\n\tcase GOYA_ASYNC_EVENT_ID_DMA0_QM ... GOYA_ASYNC_EVENT_ID_DMA4_QM:\n\t\tindex = event_type - GOYA_ASYNC_EVENT_ID_DMA0_QM;\n\t\tsnprintf(desc, size, _goya_get_event_desc(event_type), index);\n\t\tbreak;\n\tcase GOYA_ASYNC_EVENT_ID_DMA0_CH ... GOYA_ASYNC_EVENT_ID_DMA4_CH:\n\t\tindex = event_type - GOYA_ASYNC_EVENT_ID_DMA0_CH;\n\t\tsnprintf(desc, size, _goya_get_event_desc(event_type), index);\n\t\tbreak;\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC1_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC2_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC3_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC4_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC5_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC6_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC7_BMON_SPMU:\n\t\tindex = (event_type - GOYA_ASYNC_EVENT_ID_TPC0_BMON_SPMU) / 10;\n\t\tsnprintf(desc, size, _goya_get_event_desc(event_type), index);\n\t\tbreak;\n\tcase GOYA_ASYNC_EVENT_ID_DMA_BM_CH0 ... GOYA_ASYNC_EVENT_ID_DMA_BM_CH4:\n\t\tindex = event_type - GOYA_ASYNC_EVENT_ID_DMA_BM_CH0;\n\t\tsnprintf(desc, size, _goya_get_event_desc(event_type), index);\n\t\tbreak;\n\tcase GOYA_ASYNC_EVENT_PKT_QUEUE_OUT_SYNC:\n\t\tsnprintf(desc, size, _goya_get_event_desc(event_type));\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(desc, size, _goya_get_event_desc(event_type));\n\t\tbreak;\n\t}\n}\n\nstatic void goya_print_razwi_info(struct hl_device *hdev)\n{\n\tif (RREG32(mmDMA_MACRO_RAZWI_LBW_WT_VLD)) {\n\t\tdev_err_ratelimited(hdev->dev, \"Illegal write to LBW\\n\");\n\t\tWREG32(mmDMA_MACRO_RAZWI_LBW_WT_VLD, 0);\n\t}\n\n\tif (RREG32(mmDMA_MACRO_RAZWI_LBW_RD_VLD)) {\n\t\tdev_err_ratelimited(hdev->dev, \"Illegal read from LBW\\n\");\n\t\tWREG32(mmDMA_MACRO_RAZWI_LBW_RD_VLD, 0);\n\t}\n\n\tif (RREG32(mmDMA_MACRO_RAZWI_HBW_WT_VLD)) {\n\t\tdev_err_ratelimited(hdev->dev, \"Illegal write to HBW\\n\");\n\t\tWREG32(mmDMA_MACRO_RAZWI_HBW_WT_VLD, 0);\n\t}\n\n\tif (RREG32(mmDMA_MACRO_RAZWI_HBW_RD_VLD)) {\n\t\tdev_err_ratelimited(hdev->dev, \"Illegal read from HBW\\n\");\n\t\tWREG32(mmDMA_MACRO_RAZWI_HBW_RD_VLD, 0);\n\t}\n}\n\nstatic void goya_print_mmu_error_info(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tu64 addr;\n\tu32 val;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_MMU))\n\t\treturn;\n\n\tval = RREG32(mmMMU_PAGE_ERROR_CAPTURE);\n\tif (val & MMU_PAGE_ERROR_CAPTURE_ENTRY_VALID_MASK) {\n\t\taddr = val & MMU_PAGE_ERROR_CAPTURE_VA_49_32_MASK;\n\t\taddr <<= 32;\n\t\taddr |= RREG32(mmMMU_PAGE_ERROR_CAPTURE_VA);\n\n\t\tdev_err_ratelimited(hdev->dev, \"MMU page fault on va 0x%llx\\n\",\n\t\t\t\t\taddr);\n\n\t\tWREG32(mmMMU_PAGE_ERROR_CAPTURE, 0);\n\t}\n}\n\nstatic void goya_print_out_of_sync_info(struct hl_device *hdev,\n\t\t\t\t\tstruct cpucp_pkt_sync_err *sync_err)\n{\n\tstruct hl_hw_queue *q = &hdev->kernel_queues[GOYA_QUEUE_ID_CPU_PQ];\n\n\tdev_err(hdev->dev, \"Out of sync with FW, FW: pi=%u, ci=%u, LKD: pi=%u, ci=%d\\n\",\n\t\tle32_to_cpu(sync_err->pi), le32_to_cpu(sync_err->ci), q->pi, atomic_read(&q->ci));\n}\n\nstatic void goya_print_irq_info(struct hl_device *hdev, u16 event_type,\n\t\t\t\tbool razwi)\n{\n\tchar desc[20] = \"\";\n\n\tgoya_get_event_desc(event_type, desc, sizeof(desc));\n\tdev_err_ratelimited(hdev->dev, \"Received H/W interrupt %d [\\\"%s\\\"]\\n\",\n\t\tevent_type, desc);\n\n\tif (razwi) {\n\t\tgoya_print_razwi_info(hdev);\n\t\tgoya_print_mmu_error_info(hdev);\n\t}\n}\n\nstatic int goya_unmask_irq_arr(struct hl_device *hdev, u32 *irq_arr,\n\t\tsize_t irq_arr_size)\n{\n\tstruct cpucp_unmask_irq_arr_packet *pkt;\n\tsize_t total_pkt_size;\n\tu64 result;\n\tint rc;\n\tint irq_num_entries, irq_arr_index;\n\t__le32 *goya_irq_arr;\n\n\ttotal_pkt_size = sizeof(struct cpucp_unmask_irq_arr_packet) +\n\t\t\tirq_arr_size;\n\n\t \n\ttotal_pkt_size = (total_pkt_size + 0x7) & ~0x7;\n\n\t \n\tif (total_pkt_size > USHRT_MAX) {\n\t\tdev_err(hdev->dev, \"too many elements in IRQ array\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpkt = kzalloc(total_pkt_size, GFP_KERNEL);\n\tif (!pkt)\n\t\treturn -ENOMEM;\n\n\tirq_num_entries = irq_arr_size / sizeof(irq_arr[0]);\n\tpkt->length = cpu_to_le32(irq_num_entries);\n\n\t \n\tfor (irq_arr_index = 0, goya_irq_arr = (__le32 *) &pkt->irqs;\n\t\t\tirq_arr_index < irq_num_entries ; irq_arr_index++)\n\t\tgoya_irq_arr[irq_arr_index] =\n\t\t\t\tcpu_to_le32(irq_arr[irq_arr_index]);\n\n\tpkt->cpucp_pkt.ctl = cpu_to_le32(CPUCP_PACKET_UNMASK_RAZWI_IRQ_ARRAY <<\n\t\t\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) pkt,\n\t\t\t\t\t\ttotal_pkt_size,\t0, &result);\n\n\tif (rc)\n\t\tdev_err(hdev->dev, \"failed to unmask IRQ array\\n\");\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nstatic int goya_compute_reset_late_init(struct hl_device *hdev)\n{\n\t \n\treturn goya_unmask_irq_arr(hdev, goya_all_events,\n\t\t\t\t\tsizeof(goya_all_events));\n}\n\nstatic int goya_unmask_irq(struct hl_device *hdev, u16 event_type)\n{\n\tstruct cpucp_packet pkt;\n\tu64 result;\n\tint rc;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\n\tpkt.ctl = cpu_to_le32(CPUCP_PACKET_UNMASK_RAZWI_IRQ <<\n\t\t\t\tCPUCP_PKT_CTL_OPCODE_SHIFT);\n\tpkt.value = cpu_to_le64(event_type);\n\n\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n\t\t\t\t\t\t0, &result);\n\n\tif (rc)\n\t\tdev_err(hdev->dev, \"failed to unmask RAZWI IRQ %d\", event_type);\n\n\treturn rc;\n}\n\nstatic void goya_print_clk_change_info(struct hl_device *hdev, u16 event_type)\n{\n\tktime_t zero_time = ktime_set(0, 0);\n\n\tmutex_lock(&hdev->clk_throttling.lock);\n\n\tswitch (event_type) {\n\tcase GOYA_ASYNC_EVENT_ID_FIX_POWER_ENV_S:\n\t\thdev->clk_throttling.current_reason |= HL_CLK_THROTTLE_POWER;\n\t\thdev->clk_throttling.aggregated_reason |= HL_CLK_THROTTLE_POWER;\n\t\thdev->clk_throttling.timestamp[HL_CLK_THROTTLE_TYPE_POWER].start = ktime_get();\n\t\thdev->clk_throttling.timestamp[HL_CLK_THROTTLE_TYPE_POWER].end = zero_time;\n\t\tdev_info_ratelimited(hdev->dev,\n\t\t\t\"Clock throttling due to power consumption\\n\");\n\t\tbreak;\n\n\tcase GOYA_ASYNC_EVENT_ID_FIX_POWER_ENV_E:\n\t\thdev->clk_throttling.current_reason &= ~HL_CLK_THROTTLE_POWER;\n\t\thdev->clk_throttling.timestamp[HL_CLK_THROTTLE_TYPE_POWER].end = ktime_get();\n\t\tdev_info_ratelimited(hdev->dev,\n\t\t\t\"Power envelop is safe, back to optimal clock\\n\");\n\t\tbreak;\n\n\tcase GOYA_ASYNC_EVENT_ID_FIX_THERMAL_ENV_S:\n\t\thdev->clk_throttling.current_reason |= HL_CLK_THROTTLE_THERMAL;\n\t\thdev->clk_throttling.aggregated_reason |= HL_CLK_THROTTLE_THERMAL;\n\t\thdev->clk_throttling.timestamp[HL_CLK_THROTTLE_TYPE_THERMAL].start = ktime_get();\n\t\thdev->clk_throttling.timestamp[HL_CLK_THROTTLE_TYPE_THERMAL].end = zero_time;\n\t\tdev_info_ratelimited(hdev->dev,\n\t\t\t\"Clock throttling due to overheating\\n\");\n\t\tbreak;\n\n\tcase GOYA_ASYNC_EVENT_ID_FIX_THERMAL_ENV_E:\n\t\thdev->clk_throttling.current_reason &= ~HL_CLK_THROTTLE_THERMAL;\n\t\thdev->clk_throttling.timestamp[HL_CLK_THROTTLE_TYPE_THERMAL].end = ktime_get();\n\t\tdev_info_ratelimited(hdev->dev,\n\t\t\t\"Thermal envelop is safe, back to optimal clock\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(hdev->dev, \"Received invalid clock change event %d\\n\",\n\t\t\tevent_type);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&hdev->clk_throttling.lock);\n}\n\nvoid goya_handle_eqe(struct hl_device *hdev, struct hl_eq_entry *eq_entry)\n{\n\tu32 ctl = le32_to_cpu(eq_entry->hdr.ctl);\n\tu16 event_type = ((ctl & EQ_CTL_EVENT_TYPE_MASK)\n\t\t\t\t>> EQ_CTL_EVENT_TYPE_SHIFT);\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (event_type >= GOYA_ASYNC_EVENT_ID_SIZE) {\n\t\tdev_err(hdev->dev, \"Event type %u exceeds maximum of %u\",\n\t\t\t\tevent_type, GOYA_ASYNC_EVENT_ID_SIZE - 1);\n\t\treturn;\n\t}\n\n\tgoya->events_stat[event_type]++;\n\tgoya->events_stat_aggregate[event_type]++;\n\n\tswitch (event_type) {\n\tcase GOYA_ASYNC_EVENT_ID_PCIE_IF:\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC1_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC2_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC3_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC4_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC5_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC6_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC7_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_MME_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_MME_ECC_EXT:\n\tcase GOYA_ASYNC_EVENT_ID_MMU_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_DMA_MACRO:\n\tcase GOYA_ASYNC_EVENT_ID_DMA_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_CPU_IF_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_PSOC_MEM:\n\tcase GOYA_ASYNC_EVENT_ID_PSOC_CORESIGHT:\n\tcase GOYA_ASYNC_EVENT_ID_SRAM0 ... GOYA_ASYNC_EVENT_ID_SRAM29:\n\tcase GOYA_ASYNC_EVENT_ID_GIC500:\n\tcase GOYA_ASYNC_EVENT_ID_PLL0 ... GOYA_ASYNC_EVENT_ID_PLL6:\n\tcase GOYA_ASYNC_EVENT_ID_AXI_ECC:\n\tcase GOYA_ASYNC_EVENT_ID_L2_RAM_ECC:\n\t\tgoya_print_irq_info(hdev, event_type, false);\n\t\tif (hdev->hard_reset_on_fw_events)\n\t\t\thl_device_reset(hdev, (HL_DRV_RESET_HARD |\n\t\t\t\t\t\tHL_DRV_RESET_FW_FATAL_ERR));\n\t\tbreak;\n\n\tcase GOYA_ASYNC_EVENT_ID_PSOC_GPIO_05_SW_RESET:\n\t\tgoya_print_irq_info(hdev, event_type, false);\n\t\tif (hdev->hard_reset_on_fw_events)\n\t\t\thl_device_reset(hdev, HL_DRV_RESET_HARD);\n\t\tbreak;\n\n\tcase GOYA_ASYNC_EVENT_ID_PCIE_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC1_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC2_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC3_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC4_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC5_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC6_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC7_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_MME_WACS:\n\tcase GOYA_ASYNC_EVENT_ID_MME_WACSD:\n\tcase GOYA_ASYNC_EVENT_ID_CPU_AXI_SPLITTER:\n\tcase GOYA_ASYNC_EVENT_ID_PSOC_AXI_DEC:\n\tcase GOYA_ASYNC_EVENT_ID_PSOC:\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC1_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC2_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC3_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC4_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC5_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC6_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC7_KRN_ERR:\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_CMDQ ... GOYA_ASYNC_EVENT_ID_TPC7_QM:\n\tcase GOYA_ASYNC_EVENT_ID_MME_QM:\n\tcase GOYA_ASYNC_EVENT_ID_MME_CMDQ:\n\tcase GOYA_ASYNC_EVENT_ID_DMA0_QM ... GOYA_ASYNC_EVENT_ID_DMA4_QM:\n\tcase GOYA_ASYNC_EVENT_ID_DMA0_CH ... GOYA_ASYNC_EVENT_ID_DMA4_CH:\n\t\tgoya_print_irq_info(hdev, event_type, true);\n\t\tgoya_unmask_irq(hdev, event_type);\n\t\tbreak;\n\n\tcase GOYA_ASYNC_EVENT_ID_PSOC_GPIO_10_VRHOT_ICRIT:\n\tcase GOYA_ASYNC_EVENT_ID_TPC0_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC1_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC2_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC3_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC4_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC5_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC6_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_TPC7_BMON_SPMU:\n\tcase GOYA_ASYNC_EVENT_ID_DMA_BM_CH0 ... GOYA_ASYNC_EVENT_ID_DMA_BM_CH4:\n\t\tgoya_print_irq_info(hdev, event_type, false);\n\t\tgoya_unmask_irq(hdev, event_type);\n\t\tbreak;\n\n\tcase GOYA_ASYNC_EVENT_ID_FIX_POWER_ENV_S:\n\tcase GOYA_ASYNC_EVENT_ID_FIX_POWER_ENV_E:\n\tcase GOYA_ASYNC_EVENT_ID_FIX_THERMAL_ENV_S:\n\tcase GOYA_ASYNC_EVENT_ID_FIX_THERMAL_ENV_E:\n\t\tgoya_print_clk_change_info(hdev, event_type);\n\t\tgoya_unmask_irq(hdev, event_type);\n\t\tbreak;\n\n\tcase GOYA_ASYNC_EVENT_PKT_QUEUE_OUT_SYNC:\n\t\tgoya_print_irq_info(hdev, event_type, false);\n\t\tgoya_print_out_of_sync_info(hdev, &eq_entry->pkt_sync_err);\n\t\tif (hdev->hard_reset_on_fw_events)\n\t\t\thl_device_reset(hdev, HL_DRV_RESET_HARD);\n\t\telse\n\t\t\thl_fw_unmask_irq(hdev, event_type);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(hdev->dev, \"Received invalid H/W interrupt %d\\n\",\n\t\t\t\tevent_type);\n\t\tbreak;\n\t}\n}\n\nvoid *goya_get_events_stat(struct hl_device *hdev, bool aggregate, u32 *size)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (aggregate) {\n\t\t*size = (u32) sizeof(goya->events_stat_aggregate);\n\t\treturn goya->events_stat_aggregate;\n\t}\n\n\t*size = (u32) sizeof(goya->events_stat);\n\treturn goya->events_stat;\n}\n\nstatic int goya_memset_device_memory(struct hl_device *hdev, u64 addr, u64 size,\n\t\t\t\tu64 val, bool is_dram)\n{\n\tstruct packet_lin_dma *lin_dma_pkt;\n\tstruct hl_cs_job *job;\n\tu32 cb_size, ctl;\n\tstruct hl_cb *cb;\n\tint rc, lin_dma_pkts_cnt;\n\n\tlin_dma_pkts_cnt = DIV_ROUND_UP_ULL(size, SZ_2G);\n\tcb_size = lin_dma_pkts_cnt * sizeof(struct packet_lin_dma) +\n\t\t\t\t\t\tsizeof(struct packet_msg_prot);\n\tcb = hl_cb_kernel_create(hdev, cb_size, false);\n\tif (!cb)\n\t\treturn -ENOMEM;\n\n\tlin_dma_pkt = cb->kernel_address;\n\n\tdo {\n\t\tmemset(lin_dma_pkt, 0, sizeof(*lin_dma_pkt));\n\n\t\tctl = ((PACKET_LIN_DMA << GOYA_PKT_CTL_OPCODE_SHIFT) |\n\t\t\t\t(1 << GOYA_PKT_LIN_DMA_CTL_MEMSET_SHIFT) |\n\t\t\t\t(1 << GOYA_PKT_LIN_DMA_CTL_WO_SHIFT) |\n\t\t\t\t(1 << GOYA_PKT_CTL_RB_SHIFT) |\n\t\t\t\t(1 << GOYA_PKT_CTL_MB_SHIFT));\n\t\tctl |= (is_dram ? HL_DMA_HOST_TO_DRAM : HL_DMA_HOST_TO_SRAM) <<\n\t\t\t\tGOYA_PKT_LIN_DMA_CTL_DMA_DIR_SHIFT;\n\t\tlin_dma_pkt->ctl = cpu_to_le32(ctl);\n\n\t\tlin_dma_pkt->src_addr = cpu_to_le64(val);\n\t\tlin_dma_pkt->dst_addr = cpu_to_le64(addr);\n\t\tif (lin_dma_pkts_cnt > 1)\n\t\t\tlin_dma_pkt->tsize = cpu_to_le32(SZ_2G);\n\t\telse\n\t\t\tlin_dma_pkt->tsize = cpu_to_le32(size);\n\n\t\tsize -= SZ_2G;\n\t\taddr += SZ_2G;\n\t\tlin_dma_pkt++;\n\t} while (--lin_dma_pkts_cnt);\n\n\tjob = hl_cs_allocate_job(hdev, QUEUE_TYPE_EXT, true);\n\tif (!job) {\n\t\tdev_err(hdev->dev, \"Failed to allocate a new job\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto release_cb;\n\t}\n\n\tjob->id = 0;\n\tjob->user_cb = cb;\n\tatomic_inc(&job->user_cb->cs_cnt);\n\tjob->user_cb_size = cb_size;\n\tjob->hw_queue_id = GOYA_QUEUE_ID_DMA_0;\n\tjob->patched_cb = job->user_cb;\n\tjob->job_cb_size = job->user_cb_size;\n\n\thl_debugfs_add_job(hdev, job);\n\n\trc = goya_send_job_on_qman0(hdev, job);\n\n\thl_debugfs_remove_job(hdev, job);\n\tkfree(job);\n\tatomic_dec(&cb->cs_cnt);\n\nrelease_cb:\n\thl_cb_put(cb);\n\thl_cb_destroy(&hdev->kernel_mem_mgr, cb->buf->handle);\n\n\treturn rc;\n}\n\nint goya_context_switch(struct hl_device *hdev, u32 asid)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu64 addr = prop->sram_base_address, sob_addr;\n\tu32 size = hdev->pldm ? 0x10000 : prop->sram_size;\n\tu64 val = 0x7777777777777777ull;\n\tint rc, dma_id;\n\tu32 channel_off = mmDMA_CH_1_WR_COMP_ADDR_LO -\n\t\t\t\t\tmmDMA_CH_0_WR_COMP_ADDR_LO;\n\n\trc = goya_memset_device_memory(hdev, addr, size, val, false);\n\tif (rc) {\n\t\tdev_err(hdev->dev, \"Failed to clear SRAM in context switch\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tsob_addr = CFG_BASE + mmSYNC_MNGR_SOB_OBJ_1007;\n\tWREG32(mmDMA_CH_0_WR_COMP_ADDR_LO, lower_32_bits(sob_addr));\n\n\tfor (dma_id = 1 ; dma_id < NUMBER_OF_EXT_HW_QUEUES ; dma_id++) {\n\t\tsob_addr = CFG_BASE + mmSYNC_MNGR_SOB_OBJ_1000 +\n\t\t\t\t\t\t\t(dma_id - 1) * 4;\n\t\tWREG32(mmDMA_CH_0_WR_COMP_ADDR_LO + channel_off * dma_id,\n\t\t\t\t\t\tlower_32_bits(sob_addr));\n\t}\n\n\tWREG32(mmTPC_PLL_CLK_RLX_0, 0x200020);\n\n\tgoya_clear_sm_regs(hdev);\n\n\treturn 0;\n}\n\nstatic int goya_mmu_clear_pgt_range(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct goya_device *goya = hdev->asic_specific;\n\tu64 addr = prop->mmu_pgt_addr;\n\tu32 size = prop->mmu_pgt_size + MMU_DRAM_DEFAULT_PAGE_SIZE +\n\t\t\tMMU_CACHE_MNG_SIZE;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_MMU))\n\t\treturn 0;\n\n\treturn goya_memset_device_memory(hdev, addr, size, 0, true);\n}\n\nstatic int goya_mmu_set_dram_default_page(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tu64 addr = hdev->asic_prop.mmu_dram_default_page_addr;\n\tu32 size = MMU_DRAM_DEFAULT_PAGE_SIZE;\n\tu64 val = 0x9999999999999999ull;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_MMU))\n\t\treturn 0;\n\n\treturn goya_memset_device_memory(hdev, addr, size, val, true);\n}\n\nstatic int goya_mmu_add_mappings_for_device_cpu(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct goya_device *goya = hdev->asic_specific;\n\ts64 off, cpu_off;\n\tint rc;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_MMU))\n\t\treturn 0;\n\n\tfor (off = 0 ; off < CPU_FW_IMAGE_SIZE ; off += PAGE_SIZE_2MB) {\n\t\trc = hl_mmu_map_page(hdev->kernel_ctx,\n\t\t\tprop->dram_base_address + off,\n\t\t\tprop->dram_base_address + off, PAGE_SIZE_2MB,\n\t\t\t(off + PAGE_SIZE_2MB) == CPU_FW_IMAGE_SIZE);\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev, \"Map failed for address 0x%llx\\n\",\n\t\t\t\tprop->dram_base_address + off);\n\t\t\tgoto unmap;\n\t\t}\n\t}\n\n\tif (!(hdev->cpu_accessible_dma_address & (PAGE_SIZE_2MB - 1))) {\n\t\trc = hl_mmu_map_page(hdev->kernel_ctx,\n\t\t\tVA_CPU_ACCESSIBLE_MEM_ADDR,\n\t\t\thdev->cpu_accessible_dma_address,\n\t\t\tPAGE_SIZE_2MB, true);\n\n\t\tif (rc) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"Map failed for CPU accessible memory\\n\");\n\t\t\toff -= PAGE_SIZE_2MB;\n\t\t\tgoto unmap;\n\t\t}\n\t} else {\n\t\tfor (cpu_off = 0 ; cpu_off < SZ_2M ; cpu_off += PAGE_SIZE_4KB) {\n\t\t\trc = hl_mmu_map_page(hdev->kernel_ctx,\n\t\t\t\tVA_CPU_ACCESSIBLE_MEM_ADDR + cpu_off,\n\t\t\t\thdev->cpu_accessible_dma_address + cpu_off,\n\t\t\t\tPAGE_SIZE_4KB, true);\n\t\t\tif (rc) {\n\t\t\t\tdev_err(hdev->dev,\n\t\t\t\t\t\"Map failed for CPU accessible memory\\n\");\n\t\t\t\tcpu_off -= PAGE_SIZE_4KB;\n\t\t\t\tgoto unmap_cpu;\n\t\t\t}\n\t\t}\n\t}\n\n\tgoya_mmu_prepare_reg(hdev, mmCPU_IF_ARUSER_OVR, HL_KERNEL_ASID_ID);\n\tgoya_mmu_prepare_reg(hdev, mmCPU_IF_AWUSER_OVR, HL_KERNEL_ASID_ID);\n\tWREG32(mmCPU_IF_ARUSER_OVR_EN, 0x7FF);\n\tWREG32(mmCPU_IF_AWUSER_OVR_EN, 0x7FF);\n\n\t \n\tRREG32(mmCPU_IF_AWUSER_OVR_EN);\n\n\tgoya->device_cpu_mmu_mappings_done = true;\n\n\treturn 0;\n\nunmap_cpu:\n\tfor (; cpu_off >= 0 ; cpu_off -= PAGE_SIZE_4KB)\n\t\tif (hl_mmu_unmap_page(hdev->kernel_ctx,\n\t\t\t\tVA_CPU_ACCESSIBLE_MEM_ADDR + cpu_off,\n\t\t\t\tPAGE_SIZE_4KB, true))\n\t\t\tdev_warn_ratelimited(hdev->dev,\n\t\t\t\t\"failed to unmap address 0x%llx\\n\",\n\t\t\t\tVA_CPU_ACCESSIBLE_MEM_ADDR + cpu_off);\nunmap:\n\tfor (; off >= 0 ; off -= PAGE_SIZE_2MB)\n\t\tif (hl_mmu_unmap_page(hdev->kernel_ctx,\n\t\t\t\tprop->dram_base_address + off, PAGE_SIZE_2MB,\n\t\t\t\ttrue))\n\t\t\tdev_warn_ratelimited(hdev->dev,\n\t\t\t\t\"failed to unmap address 0x%llx\\n\",\n\t\t\t\tprop->dram_base_address + off);\n\n\treturn rc;\n}\n\nvoid goya_mmu_remove_device_cpu_mappings(struct hl_device *hdev)\n{\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tstruct goya_device *goya = hdev->asic_specific;\n\tu32 off, cpu_off;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_MMU))\n\t\treturn;\n\n\tif (!goya->device_cpu_mmu_mappings_done)\n\t\treturn;\n\n\tWREG32(mmCPU_IF_ARUSER_OVR_EN, 0);\n\tWREG32(mmCPU_IF_AWUSER_OVR_EN, 0);\n\n\tif (!(hdev->cpu_accessible_dma_address & (PAGE_SIZE_2MB - 1))) {\n\t\tif (hl_mmu_unmap_page(hdev->kernel_ctx,\n\t\t\t\tVA_CPU_ACCESSIBLE_MEM_ADDR,\n\t\t\t\tPAGE_SIZE_2MB, true))\n\t\t\tdev_warn(hdev->dev,\n\t\t\t\t\"Failed to unmap CPU accessible memory\\n\");\n\t} else {\n\t\tfor (cpu_off = 0 ; cpu_off < SZ_2M ; cpu_off += PAGE_SIZE_4KB)\n\t\t\tif (hl_mmu_unmap_page(hdev->kernel_ctx,\n\t\t\t\t\tVA_CPU_ACCESSIBLE_MEM_ADDR + cpu_off,\n\t\t\t\t\tPAGE_SIZE_4KB,\n\t\t\t\t\t(cpu_off + PAGE_SIZE_4KB) >= SZ_2M))\n\t\t\t\tdev_warn_ratelimited(hdev->dev,\n\t\t\t\t\t\"failed to unmap address 0x%llx\\n\",\n\t\t\t\t\tVA_CPU_ACCESSIBLE_MEM_ADDR + cpu_off);\n\t}\n\n\tfor (off = 0 ; off < CPU_FW_IMAGE_SIZE ; off += PAGE_SIZE_2MB)\n\t\tif (hl_mmu_unmap_page(hdev->kernel_ctx,\n\t\t\t\tprop->dram_base_address + off, PAGE_SIZE_2MB,\n\t\t\t\t(off + PAGE_SIZE_2MB) >= CPU_FW_IMAGE_SIZE))\n\t\t\tdev_warn_ratelimited(hdev->dev,\n\t\t\t\t\t\"Failed to unmap address 0x%llx\\n\",\n\t\t\t\t\tprop->dram_base_address + off);\n\n\tgoya->device_cpu_mmu_mappings_done = false;\n}\n\nstatic void goya_mmu_prepare(struct hl_device *hdev, u32 asid)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tint i;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_MMU))\n\t\treturn;\n\n\tif (asid & ~MME_QM_GLBL_SECURE_PROPS_ASID_MASK) {\n\t\tdev_crit(hdev->dev, \"asid %u is too big\\n\", asid);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0 ; i < GOYA_MMU_REGS_NUM ; i++)\n\t\tgoya_mmu_prepare_reg(hdev, goya_mmu_regs[i], asid);\n}\n\nstatic int goya_mmu_invalidate_cache(struct hl_device *hdev, bool is_hard,\n\t\t\t\t\tu32 flags)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tu32 status, timeout_usec;\n\tint rc;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_MMU) ||\n\t\thdev->reset_info.hard_reset_pending)\n\t\treturn 0;\n\n\t \n\tif (!is_hard)\n\t\treturn 0;\n\n\tif (hdev->pldm)\n\t\ttimeout_usec = GOYA_PLDM_MMU_TIMEOUT_USEC;\n\telse\n\t\ttimeout_usec = MMU_CONFIG_TIMEOUT_USEC;\n\n\t \n\tWREG32(mmSTLB_INV_ALL_START, 1);\n\n\trc = hl_poll_timeout(\n\t\thdev,\n\t\tmmSTLB_INV_ALL_START,\n\t\tstatus,\n\t\t!status,\n\t\t1000,\n\t\ttimeout_usec);\n\n\treturn rc;\n}\n\nstatic int goya_mmu_invalidate_cache_range(struct hl_device *hdev,\n\t\t\t\t\t\tbool is_hard, u32 flags,\n\t\t\t\t\t\tu32 asid, u64 va, u64 size)\n{\n\t \n\treturn hl_mmu_invalidate_cache(hdev, is_hard, flags);\n}\n\nint goya_send_heartbeat(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_CPU_Q))\n\t\treturn 0;\n\n\treturn hl_fw_send_heartbeat(hdev);\n}\n\nint goya_cpucp_info_get(struct hl_device *hdev)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\tstruct asic_fixed_properties *prop = &hdev->asic_prop;\n\tu64 dram_size;\n\tint rc;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_CPU_Q))\n\t\treturn 0;\n\n\trc = hl_fw_cpucp_handshake(hdev, mmCPU_BOOT_DEV_STS0,\n\t\t\t\t\tmmCPU_BOOT_DEV_STS1, mmCPU_BOOT_ERR0,\n\t\t\t\t\tmmCPU_BOOT_ERR1);\n\tif (rc)\n\t\treturn rc;\n\n\tdram_size = le64_to_cpu(prop->cpucp_info.dram_size);\n\tif (dram_size) {\n\t\tif ((!is_power_of_2(dram_size)) ||\n\t\t\t\t(dram_size < DRAM_PHYS_DEFAULT_SIZE)) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"F/W reported invalid DRAM size %llu. Trying to use default size\\n\",\n\t\t\t\tdram_size);\n\t\t\tdram_size = DRAM_PHYS_DEFAULT_SIZE;\n\t\t}\n\n\t\tprop->dram_size = dram_size;\n\t\tprop->dram_end_address = prop->dram_base_address + dram_size;\n\t}\n\n\tif (!strlen(prop->cpucp_info.card_name))\n\t\tstrncpy(prop->cpucp_info.card_name, GOYA_DEFAULT_CARD_NAME,\n\t\t\t\tCARD_NAME_MAX_LEN);\n\n\treturn 0;\n}\n\nstatic bool goya_is_device_idle(struct hl_device *hdev, u64 *mask_arr, u8 mask_len,\n\t\t\t\tstruct engines_data *e)\n{\n\tconst char *fmt = \"%-5d%-9s%#-14x%#-16x%#x\\n\";\n\tconst char *dma_fmt = \"%-5d%-9s%#-14x%#x\\n\";\n\tunsigned long *mask = (unsigned long *)mask_arr;\n\tu32 qm_glbl_sts0, cmdq_glbl_sts0, dma_core_sts0, tpc_cfg_sts,\n\t\tmme_arch_sts;\n\tbool is_idle = true, is_eng_idle;\n\tu64 offset;\n\tint i;\n\n\tif (e)\n\t\thl_engine_data_sprintf(e, \"\\nDMA  is_idle  QM_GLBL_STS0  DMA_CORE_STS0\\n\"\n\t\t\t\t\t\"---  -------  ------------  -------------\\n\");\n\n\toffset = mmDMA_QM_1_GLBL_STS0 - mmDMA_QM_0_GLBL_STS0;\n\n\tfor (i = 0 ; i < DMA_MAX_NUM ; i++) {\n\t\tqm_glbl_sts0 = RREG32(mmDMA_QM_0_GLBL_STS0 + i * offset);\n\t\tdma_core_sts0 = RREG32(mmDMA_CH_0_STS0 + i * offset);\n\t\tis_eng_idle = IS_DMA_QM_IDLE(qm_glbl_sts0) &&\n\t\t\t\tIS_DMA_IDLE(dma_core_sts0);\n\t\tis_idle &= is_eng_idle;\n\n\t\tif (mask && !is_eng_idle)\n\t\t\tset_bit(GOYA_ENGINE_ID_DMA_0 + i, mask);\n\t\tif (e)\n\t\t\thl_engine_data_sprintf(e, dma_fmt, i, is_eng_idle ? \"Y\" : \"N\",\n\t\t\t\t\tqm_glbl_sts0, dma_core_sts0);\n\t}\n\n\tif (e)\n\t\thl_engine_data_sprintf(e,\n\t\t\t\"\\nTPC  is_idle  QM_GLBL_STS0  CMDQ_GLBL_STS0  CFG_STATUS\\n\"\n\t\t\t\"---  -------  ------------  --------------  ----------\\n\");\n\n\toffset = mmTPC1_QM_GLBL_STS0 - mmTPC0_QM_GLBL_STS0;\n\n\tfor (i = 0 ; i < TPC_MAX_NUM ; i++) {\n\t\tqm_glbl_sts0 = RREG32(mmTPC0_QM_GLBL_STS0 + i * offset);\n\t\tcmdq_glbl_sts0 = RREG32(mmTPC0_CMDQ_GLBL_STS0 + i * offset);\n\t\ttpc_cfg_sts = RREG32(mmTPC0_CFG_STATUS + i * offset);\n\t\tis_eng_idle = IS_TPC_QM_IDLE(qm_glbl_sts0) &&\n\t\t\t\tIS_TPC_CMDQ_IDLE(cmdq_glbl_sts0) &&\n\t\t\t\tIS_TPC_IDLE(tpc_cfg_sts);\n\t\tis_idle &= is_eng_idle;\n\n\t\tif (mask && !is_eng_idle)\n\t\t\tset_bit(GOYA_ENGINE_ID_TPC_0 + i, mask);\n\t\tif (e)\n\t\t\thl_engine_data_sprintf(e, fmt, i, is_eng_idle ? \"Y\" : \"N\",\n\t\t\t\tqm_glbl_sts0, cmdq_glbl_sts0, tpc_cfg_sts);\n\t}\n\n\tif (e)\n\t\thl_engine_data_sprintf(e,\n\t\t\t\"\\nMME  is_idle  QM_GLBL_STS0  CMDQ_GLBL_STS0  ARCH_STATUS\\n\"\n\t\t\t\"---  -------  ------------  --------------  -----------\\n\");\n\n\tqm_glbl_sts0 = RREG32(mmMME_QM_GLBL_STS0);\n\tcmdq_glbl_sts0 = RREG32(mmMME_CMDQ_GLBL_STS0);\n\tmme_arch_sts = RREG32(mmMME_ARCH_STATUS);\n\tis_eng_idle = IS_MME_QM_IDLE(qm_glbl_sts0) &&\n\t\t\tIS_MME_CMDQ_IDLE(cmdq_glbl_sts0) &&\n\t\t\tIS_MME_IDLE(mme_arch_sts);\n\tis_idle &= is_eng_idle;\n\n\tif (mask && !is_eng_idle)\n\t\tset_bit(GOYA_ENGINE_ID_MME_0, mask);\n\tif (e) {\n\t\thl_engine_data_sprintf(e, fmt, 0, is_eng_idle ? \"Y\" : \"N\", qm_glbl_sts0,\n\t\t\t\tcmdq_glbl_sts0, mme_arch_sts);\n\t\thl_engine_data_sprintf(e, \"\\n\");\n\t}\n\n\treturn is_idle;\n}\n\nstatic void goya_hw_queues_lock(struct hl_device *hdev)\n\t__acquires(&goya->hw_queues_lock)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tspin_lock(&goya->hw_queues_lock);\n}\n\nstatic void goya_hw_queues_unlock(struct hl_device *hdev)\n\t__releases(&goya->hw_queues_lock)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tspin_unlock(&goya->hw_queues_lock);\n}\n\nstatic u32 goya_get_pci_id(struct hl_device *hdev)\n{\n\treturn hdev->pdev->device;\n}\n\nstatic int goya_get_eeprom_data(struct hl_device *hdev, void *data,\n\t\t\t\tsize_t max_size)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (!(goya->hw_cap_initialized & HW_CAP_CPU_Q))\n\t\treturn 0;\n\n\treturn hl_fw_get_eeprom_data(hdev, data, max_size);\n}\n\nstatic void goya_cpu_init_scrambler_dram(struct hl_device *hdev)\n{\n\n}\n\nstatic int goya_ctx_init(struct hl_ctx *ctx)\n{\n\tif (ctx->asid != HL_KERNEL_ASID_ID)\n\t\tgoya_mmu_prepare(ctx->hdev, ctx->asid);\n\n\treturn 0;\n}\n\nstatic int goya_pre_schedule_cs(struct hl_cs *cs)\n{\n\treturn 0;\n}\n\nu32 goya_get_queue_id_for_cq(struct hl_device *hdev, u32 cq_idx)\n{\n\treturn cq_idx;\n}\n\nstatic u32 goya_get_signal_cb_size(struct hl_device *hdev)\n{\n\treturn 0;\n}\n\nstatic u32 goya_get_wait_cb_size(struct hl_device *hdev)\n{\n\treturn 0;\n}\n\nstatic u32 goya_gen_signal_cb(struct hl_device *hdev, void *data, u16 sob_id,\n\t\t\t\tu32 size, bool eb)\n{\n\treturn 0;\n}\n\nstatic u32 goya_gen_wait_cb(struct hl_device *hdev,\n\t\tstruct hl_gen_wait_properties *prop)\n{\n\treturn 0;\n}\n\nstatic void goya_reset_sob(struct hl_device *hdev, void *data)\n{\n\n}\n\nstatic void goya_reset_sob_group(struct hl_device *hdev, u16 sob_group)\n{\n\n}\n\nu64 goya_get_device_time(struct hl_device *hdev)\n{\n\tu64 device_time = ((u64) RREG32(mmPSOC_TIMESTAMP_CNTCVU)) << 32;\n\n\treturn device_time | RREG32(mmPSOC_TIMESTAMP_CNTCVL);\n}\n\nstatic int goya_collective_wait_init_cs(struct hl_cs *cs)\n{\n\treturn 0;\n}\n\nstatic int goya_collective_wait_create_jobs(struct hl_device *hdev,\n\t\tstruct hl_ctx *ctx, struct hl_cs *cs, u32 wait_queue_id,\n\t\tu32 collective_engine_id, u32 encaps_signal_offset)\n{\n\treturn -EINVAL;\n}\n\nstatic void goya_ctx_fini(struct hl_ctx *ctx)\n{\n\n}\n\nstatic int goya_get_hw_block_id(struct hl_device *hdev, u64 block_addr,\n\t\t\tu32 *block_size, u32 *block_id)\n{\n\treturn -EPERM;\n}\n\nstatic int goya_block_mmap(struct hl_device *hdev, struct vm_area_struct *vma,\n\t\t\t\tu32 block_id, u32 block_size)\n{\n\treturn -EPERM;\n}\n\nstatic void goya_enable_events_from_fw(struct hl_device *hdev)\n{\n\tWREG32(mmGIC_DISTRIBUTOR__5_GICD_SETSPI_NSR,\n\t\t\tGOYA_ASYNC_EVENT_ID_INTS_REGISTER);\n}\n\nstatic int goya_ack_mmu_page_fault_or_access_error(struct hl_device *hdev, u64 mmu_cap_mask)\n{\n\treturn -EINVAL;\n}\n\nstatic int goya_map_pll_idx_to_fw_idx(u32 pll_idx)\n{\n\tswitch (pll_idx) {\n\tcase HL_GOYA_CPU_PLL: return CPU_PLL;\n\tcase HL_GOYA_PCI_PLL: return PCI_PLL;\n\tcase HL_GOYA_MME_PLL: return MME_PLL;\n\tcase HL_GOYA_TPC_PLL: return TPC_PLL;\n\tcase HL_GOYA_IC_PLL: return IC_PLL;\n\tcase HL_GOYA_MC_PLL: return MC_PLL;\n\tcase HL_GOYA_EMMC_PLL: return EMMC_PLL;\n\tdefault: return -EINVAL;\n\t}\n}\n\nstatic int goya_gen_sync_to_engine_map(struct hl_device *hdev,\n\t\t\t\tstruct hl_sync_to_engine_map *map)\n{\n\t \n\treturn 0;\n}\n\nstatic int goya_monitor_valid(struct hl_mon_state_dump *mon)\n{\n\t \n\treturn 0;\n}\n\nstatic int goya_print_single_monitor(char **buf, size_t *size, size_t *offset,\n\t\t\t\tstruct hl_device *hdev,\n\t\t\t\tstruct hl_mon_state_dump *mon)\n{\n\t \n\treturn 0;\n}\n\n\nstatic int goya_print_fences_single_engine(\n\tstruct hl_device *hdev, u64 base_offset, u64 status_base_offset,\n\tenum hl_sync_engine_type engine_type, u32 engine_id, char **buf,\n\tsize_t *size, size_t *offset)\n{\n\t \n\treturn 0;\n}\n\n\nstatic struct hl_state_dump_specs_funcs goya_state_dump_funcs = {\n\t.monitor_valid = goya_monitor_valid,\n\t.print_single_monitor = goya_print_single_monitor,\n\t.gen_sync_to_engine_map = goya_gen_sync_to_engine_map,\n\t.print_fences_single_engine = goya_print_fences_single_engine,\n};\n\nstatic void goya_state_dump_init(struct hl_device *hdev)\n{\n\t \n\thdev->state_dump_specs.props = goya_state_dump_specs_props;\n\thdev->state_dump_specs.funcs = goya_state_dump_funcs;\n}\n\nstatic u32 goya_get_sob_addr(struct hl_device *hdev, u32 sob_id)\n{\n\treturn 0;\n}\n\nstatic u32 *goya_get_stream_master_qid_arr(void)\n{\n\treturn NULL;\n}\n\nstatic int goya_get_monitor_dump(struct hl_device *hdev, void *data)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void goya_check_if_razwi_happened(struct hl_device *hdev)\n{\n}\n\nstatic int goya_scrub_device_dram(struct hl_device *hdev, u64 val)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int goya_set_dram_properties(struct hl_device *hdev)\n{\n\treturn 0;\n}\n\nstatic int goya_set_binning_masks(struct hl_device *hdev)\n{\n\treturn 0;\n}\n\nstatic int goya_send_device_activity(struct hl_device *hdev, bool open)\n{\n\treturn 0;\n}\n\nstatic const struct hl_asic_funcs goya_funcs = {\n\t.early_init = goya_early_init,\n\t.early_fini = goya_early_fini,\n\t.late_init = goya_late_init,\n\t.late_fini = goya_late_fini,\n\t.sw_init = goya_sw_init,\n\t.sw_fini = goya_sw_fini,\n\t.hw_init = goya_hw_init,\n\t.hw_fini = goya_hw_fini,\n\t.halt_engines = goya_halt_engines,\n\t.suspend = goya_suspend,\n\t.resume = goya_resume,\n\t.mmap = goya_mmap,\n\t.ring_doorbell = goya_ring_doorbell,\n\t.pqe_write = goya_pqe_write,\n\t.asic_dma_alloc_coherent = goya_dma_alloc_coherent,\n\t.asic_dma_free_coherent = goya_dma_free_coherent,\n\t.scrub_device_mem = goya_scrub_device_mem,\n\t.scrub_device_dram = goya_scrub_device_dram,\n\t.get_int_queue_base = goya_get_int_queue_base,\n\t.test_queues = goya_test_queues,\n\t.asic_dma_pool_zalloc = goya_dma_pool_zalloc,\n\t.asic_dma_pool_free = goya_dma_pool_free,\n\t.cpu_accessible_dma_pool_alloc = goya_cpu_accessible_dma_pool_alloc,\n\t.cpu_accessible_dma_pool_free = goya_cpu_accessible_dma_pool_free,\n\t.hl_dma_unmap_sgtable = hl_dma_unmap_sgtable,\n\t.cs_parser = goya_cs_parser,\n\t.asic_dma_map_sgtable = hl_dma_map_sgtable,\n\t.add_end_of_cb_packets = goya_add_end_of_cb_packets,\n\t.update_eq_ci = goya_update_eq_ci,\n\t.context_switch = goya_context_switch,\n\t.restore_phase_topology = goya_restore_phase_topology,\n\t.debugfs_read_dma = goya_debugfs_read_dma,\n\t.add_device_attr = goya_add_device_attr,\n\t.handle_eqe = goya_handle_eqe,\n\t.get_events_stat = goya_get_events_stat,\n\t.read_pte = goya_read_pte,\n\t.write_pte = goya_write_pte,\n\t.mmu_invalidate_cache = goya_mmu_invalidate_cache,\n\t.mmu_invalidate_cache_range = goya_mmu_invalidate_cache_range,\n\t.mmu_prefetch_cache_range = NULL,\n\t.send_heartbeat = goya_send_heartbeat,\n\t.debug_coresight = goya_debug_coresight,\n\t.is_device_idle = goya_is_device_idle,\n\t.compute_reset_late_init = goya_compute_reset_late_init,\n\t.hw_queues_lock = goya_hw_queues_lock,\n\t.hw_queues_unlock = goya_hw_queues_unlock,\n\t.get_pci_id = goya_get_pci_id,\n\t.get_eeprom_data = goya_get_eeprom_data,\n\t.get_monitor_dump = goya_get_monitor_dump,\n\t.send_cpu_message = goya_send_cpu_message,\n\t.pci_bars_map = goya_pci_bars_map,\n\t.init_iatu = goya_init_iatu,\n\t.rreg = hl_rreg,\n\t.wreg = hl_wreg,\n\t.halt_coresight = goya_halt_coresight,\n\t.ctx_init = goya_ctx_init,\n\t.ctx_fini = goya_ctx_fini,\n\t.pre_schedule_cs = goya_pre_schedule_cs,\n\t.get_queue_id_for_cq = goya_get_queue_id_for_cq,\n\t.load_firmware_to_device = goya_load_firmware_to_device,\n\t.load_boot_fit_to_device = goya_load_boot_fit_to_device,\n\t.get_signal_cb_size = goya_get_signal_cb_size,\n\t.get_wait_cb_size = goya_get_wait_cb_size,\n\t.gen_signal_cb = goya_gen_signal_cb,\n\t.gen_wait_cb = goya_gen_wait_cb,\n\t.reset_sob = goya_reset_sob,\n\t.reset_sob_group = goya_reset_sob_group,\n\t.get_device_time = goya_get_device_time,\n\t.pb_print_security_errors = NULL,\n\t.collective_wait_init_cs = goya_collective_wait_init_cs,\n\t.collective_wait_create_jobs = goya_collective_wait_create_jobs,\n\t.get_dec_base_addr = NULL,\n\t.scramble_addr = hl_mmu_scramble_addr,\n\t.descramble_addr = hl_mmu_descramble_addr,\n\t.ack_protection_bits_errors = goya_ack_protection_bits_errors,\n\t.get_hw_block_id = goya_get_hw_block_id,\n\t.hw_block_mmap = goya_block_mmap,\n\t.enable_events_from_fw = goya_enable_events_from_fw,\n\t.ack_mmu_errors = goya_ack_mmu_page_fault_or_access_error,\n\t.map_pll_idx_to_fw_idx = goya_map_pll_idx_to_fw_idx,\n\t.init_firmware_preload_params = goya_init_firmware_preload_params,\n\t.init_firmware_loader = goya_init_firmware_loader,\n\t.init_cpu_scrambler_dram = goya_cpu_init_scrambler_dram,\n\t.state_dump_init = goya_state_dump_init,\n\t.get_sob_addr = &goya_get_sob_addr,\n\t.set_pci_memory_regions = goya_set_pci_memory_regions,\n\t.get_stream_master_qid_arr = goya_get_stream_master_qid_arr,\n\t.check_if_razwi_happened = goya_check_if_razwi_happened,\n\t.mmu_get_real_page_size = hl_mmu_get_real_page_size,\n\t.access_dev_mem = hl_access_dev_mem,\n\t.set_dram_bar_base = goya_set_ddr_bar_base,\n\t.send_device_activity = goya_send_device_activity,\n\t.set_dram_properties = goya_set_dram_properties,\n\t.set_binning_masks = goya_set_binning_masks,\n};\n\n \nvoid goya_set_asic_funcs(struct hl_device *hdev)\n{\n\thdev->asic_funcs = &goya_funcs;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}