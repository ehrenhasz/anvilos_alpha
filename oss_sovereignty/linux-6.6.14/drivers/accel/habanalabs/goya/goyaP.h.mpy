{
  "module_name": "goyaP.h",
  "hash_id": "d350cabf1165b9899734730cd3b59f437fc070a4731f286aecc75a64f21e29d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/goya/goyaP.h",
  "human_readable_source": " \n\n#ifndef GOYAP_H_\n#define GOYAP_H_\n\n#include <uapi/drm/habanalabs_accel.h>\n#include \"../common/habanalabs.h\"\n#include \"../include/common/hl_boot_if.h\"\n#include \"../include/goya/goya_packets.h\"\n#include \"../include/goya/goya.h\"\n#include \"../include/goya/goya_async_events.h\"\n#include \"../include/goya/goya_fw_if.h\"\n\n#define NUMBER_OF_CMPLT_QUEUES\t\t5\n#define NUMBER_OF_EXT_HW_QUEUES\t\t5\n#define NUMBER_OF_CPU_HW_QUEUES\t\t1\n#define NUMBER_OF_INT_HW_QUEUES\t\t9\n#define NUMBER_OF_HW_QUEUES\t\t(NUMBER_OF_EXT_HW_QUEUES + \\\n\t\t\t\t\tNUMBER_OF_CPU_HW_QUEUES + \\\n\t\t\t\t\tNUMBER_OF_INT_HW_QUEUES)\n\n \n#define NUMBER_OF_INTERRUPTS\t\t(NUMBER_OF_CMPLT_QUEUES + 1)\n\n#if (NUMBER_OF_INTERRUPTS > GOYA_MSIX_ENTRIES)\n#error \"Number of MSIX interrupts must be smaller or equal to GOYA_MSIX_ENTRIES\"\n#endif\n\n#define QMAN_FENCE_TIMEOUT_USEC\t\t10000\t\t \n\n#define QMAN_STOP_TIMEOUT_USEC\t\t100000\t\t \n\n#define CORESIGHT_TIMEOUT_USEC\t\t100000\t\t \n\n#define GOYA_CPU_TIMEOUT_USEC\t\t15000000\t \n\n#define TPC_ENABLED_MASK\t\t0xFF\n\n#define PLL_HIGH_DEFAULT\t\t1575000000\t \n\n#define MAX_POWER_DEFAULT\t\t200000\t\t \n\n#define DC_POWER_DEFAULT\t\t20000\t\t \n\n#define DRAM_PHYS_DEFAULT_SIZE\t\t0x100000000ull\t \n\n#define GOYA_DEFAULT_CARD_NAME\t\t\"HL1000\"\n\n#define GOYA_MAX_PENDING_CS\t\t64\n\n#if !IS_MAX_PENDING_CS_VALID(GOYA_MAX_PENDING_CS)\n#error \"GOYA_MAX_PENDING_CS must be power of 2 and greater than 1\"\n#endif\n\n \n\n#define CPU_FW_IMAGE_SIZE\t\t0x10000000\t \n#define MMU_PAGE_TABLES_SIZE\t\t0x0FC00000\t \n#define MMU_DRAM_DEFAULT_PAGE_SIZE\t0x00200000\t \n#define MMU_CACHE_MNG_SIZE\t\t0x00001000\t \n\n#define CPU_FW_IMAGE_ADDR\t\tDRAM_PHYS_BASE\n#define MMU_PAGE_TABLES_ADDR\t\t(CPU_FW_IMAGE_ADDR + CPU_FW_IMAGE_SIZE)\n#define MMU_DRAM_DEFAULT_PAGE_ADDR\t(MMU_PAGE_TABLES_ADDR + \\\n\t\t\t\t\t\tMMU_PAGE_TABLES_SIZE)\n#define MMU_CACHE_MNG_ADDR\t\t(MMU_DRAM_DEFAULT_PAGE_ADDR + \\\n\t\t\t\t\tMMU_DRAM_DEFAULT_PAGE_SIZE)\n#define DRAM_DRIVER_END_ADDR\t\t(MMU_CACHE_MNG_ADDR + \\\n\t\t\t\t\t\tMMU_CACHE_MNG_SIZE)\n\n#define DRAM_BASE_ADDR_USER\t\t0x20000000\n\n#if (DRAM_DRIVER_END_ADDR > DRAM_BASE_ADDR_USER)\n#error \"Driver must reserve no more than 512MB\"\n#endif\n\n \n\n#define MME_QMAN_BASE_OFFSET\t0x000000\t \n#define MME_QMAN_LENGTH\t\t64\n#define TPC_QMAN_LENGTH\t\t64\n\n#define TPC0_QMAN_BASE_OFFSET\t(MME_QMAN_BASE_OFFSET + \\\n\t\t\t\t(MME_QMAN_LENGTH * QMAN_PQ_ENTRY_SIZE))\n#define TPC1_QMAN_BASE_OFFSET\t(TPC0_QMAN_BASE_OFFSET + \\\n\t\t\t\t(TPC_QMAN_LENGTH * QMAN_PQ_ENTRY_SIZE))\n#define TPC2_QMAN_BASE_OFFSET\t(TPC1_QMAN_BASE_OFFSET + \\\n\t\t\t\t(TPC_QMAN_LENGTH * QMAN_PQ_ENTRY_SIZE))\n#define TPC3_QMAN_BASE_OFFSET\t(TPC2_QMAN_BASE_OFFSET + \\\n\t\t\t\t(TPC_QMAN_LENGTH * QMAN_PQ_ENTRY_SIZE))\n#define TPC4_QMAN_BASE_OFFSET\t(TPC3_QMAN_BASE_OFFSET + \\\n\t\t\t\t(TPC_QMAN_LENGTH * QMAN_PQ_ENTRY_SIZE))\n#define TPC5_QMAN_BASE_OFFSET\t(TPC4_QMAN_BASE_OFFSET + \\\n\t\t\t\t(TPC_QMAN_LENGTH * QMAN_PQ_ENTRY_SIZE))\n#define TPC6_QMAN_BASE_OFFSET\t(TPC5_QMAN_BASE_OFFSET + \\\n\t\t\t\t(TPC_QMAN_LENGTH * QMAN_PQ_ENTRY_SIZE))\n#define TPC7_QMAN_BASE_OFFSET\t(TPC6_QMAN_BASE_OFFSET + \\\n\t\t\t\t(TPC_QMAN_LENGTH * QMAN_PQ_ENTRY_SIZE))\n\n#define SRAM_DRIVER_RES_OFFSET\t(TPC7_QMAN_BASE_OFFSET + \\\n\t\t\t\t(TPC_QMAN_LENGTH * QMAN_PQ_ENTRY_SIZE))\n\n#if (SRAM_DRIVER_RES_OFFSET >= GOYA_KMD_SRAM_RESERVED_SIZE_FROM_START)\n#error \"MME/TPC QMANs SRAM space exceeds limit\"\n#endif\n\n#define SRAM_USER_BASE_OFFSET\tGOYA_KMD_SRAM_RESERVED_SIZE_FROM_START\n\n \n#define VA_HOST_SPACE_START\t0x1000000000000ull\t \n#define VA_HOST_SPACE_END\t0x3FF8000000000ull\t \n#define VA_HOST_SPACE_SIZE\t(VA_HOST_SPACE_END - \\\n\t\t\t\t\tVA_HOST_SPACE_START)  \n\n#define VA_DDR_SPACE_START\t0x800000000ull\t\t \n#define VA_DDR_SPACE_END\t0x2000000000ull\t\t \n#define VA_DDR_SPACE_SIZE\t(VA_DDR_SPACE_END - \\\n\t\t\t\t\tVA_DDR_SPACE_START)\t \n\n#if (HL_CPU_ACCESSIBLE_MEM_SIZE != SZ_2M)\n#error \"HL_CPU_ACCESSIBLE_MEM_SIZE must be exactly 2MB to enable MMU mapping\"\n#endif\n\n#define VA_CPU_ACCESSIBLE_MEM_ADDR\t0x8000000000ull\n\n#define DMA_MAX_TRANSFER_SIZE\tU32_MAX\n\n#define HW_CAP_PLL\t\t0x00000001\n#define HW_CAP_DDR_0\t\t0x00000002\n#define HW_CAP_DDR_1\t\t0x00000004\n#define HW_CAP_MME\t\t0x00000008\n#define HW_CAP_CPU\t\t0x00000010\n#define HW_CAP_DMA\t\t0x00000020\n#define HW_CAP_MSIX\t\t0x00000040\n#define HW_CAP_CPU_Q\t\t0x00000080\n#define HW_CAP_MMU\t\t0x00000100\n#define HW_CAP_TPC_MBIST\t0x00000200\n#define HW_CAP_GOLDEN\t\t0x00000400\n#define HW_CAP_TPC\t\t0x00000800\n\nstruct goya_work_freq {\n\tstruct hl_device *hdev;\n\tstruct delayed_work work_freq;\n};\n\nstruct goya_device {\n\t \n\tspinlock_t\thw_queues_lock;\n\tstruct goya_work_freq\t*goya_work;\n\n\tu64\t\tmme_clk;\n\tu64\t\ttpc_clk;\n\tu64\t\tic_clk;\n\n\tu64\t\tddr_bar_cur_addr;\n\tu32\t\tevents_stat[GOYA_ASYNC_EVENT_ID_SIZE];\n\tu32\t\tevents_stat_aggregate[GOYA_ASYNC_EVENT_ID_SIZE];\n\tu32\t\thw_cap_initialized;\n\tu8\t\tdevice_cpu_mmu_mappings_done;\n\n\tenum hl_pll_frequency\t\tcurr_pll_profile;\n\tenum hl_pm_mng_profile\t\tpm_mng_profile;\n};\n\nint goya_set_fixed_properties(struct hl_device *hdev);\nint goya_mmu_init(struct hl_device *hdev);\nvoid goya_init_dma_qmans(struct hl_device *hdev);\nvoid goya_init_mme_qmans(struct hl_device *hdev);\nvoid goya_init_tpc_qmans(struct hl_device *hdev);\nint goya_init_cpu_queues(struct hl_device *hdev);\nvoid goya_init_security(struct hl_device *hdev);\nvoid goya_ack_protection_bits_errors(struct hl_device *hdev);\nint goya_late_init(struct hl_device *hdev);\nvoid goya_late_fini(struct hl_device *hdev);\n\nvoid goya_ring_doorbell(struct hl_device *hdev, u32 hw_queue_id, u32 pi);\nvoid goya_pqe_write(struct hl_device *hdev, __le64 *pqe, struct hl_bd *bd);\nvoid goya_update_eq_ci(struct hl_device *hdev, u32 val);\nvoid goya_restore_phase_topology(struct hl_device *hdev);\nint goya_context_switch(struct hl_device *hdev, u32 asid);\n\nint goya_debugfs_i2c_read(struct hl_device *hdev, u8 i2c_bus,\n\t\t\tu8 i2c_addr, u8 i2c_reg, u32 *val);\nint goya_debugfs_i2c_write(struct hl_device *hdev, u8 i2c_bus,\n\t\t\tu8 i2c_addr, u8 i2c_reg, u32 val);\nvoid goya_debugfs_led_set(struct hl_device *hdev, u8 led, u8 state);\n\nint goya_test_queue(struct hl_device *hdev, u32 hw_queue_id);\nint goya_test_queues(struct hl_device *hdev);\nint goya_test_cpu_queue(struct hl_device *hdev);\nint goya_send_cpu_message(struct hl_device *hdev, u32 *msg, u16 len,\n\t\t\t\tu32 timeout, u64 *result);\n\nlong goya_get_temperature(struct hl_device *hdev, int sensor_index, u32 attr);\nlong goya_get_voltage(struct hl_device *hdev, int sensor_index, u32 attr);\nlong goya_get_current(struct hl_device *hdev, int sensor_index, u32 attr);\nlong goya_get_fan_speed(struct hl_device *hdev, int sensor_index, u32 attr);\nlong goya_get_pwm_info(struct hl_device *hdev, int sensor_index, u32 attr);\nvoid goya_set_pwm_info(struct hl_device *hdev, int sensor_index, u32 attr,\n\t\t\tlong value);\nu64 goya_get_max_power(struct hl_device *hdev);\nvoid goya_set_max_power(struct hl_device *hdev, u64 value);\n\nvoid goya_set_pll_profile(struct hl_device *hdev, enum hl_pll_frequency freq);\nvoid goya_add_device_attr(struct hl_device *hdev, struct attribute_group *dev_clk_attr_grp,\n\t\t\t\tstruct attribute_group *dev_vrm_attr_grp);\nint goya_cpucp_info_get(struct hl_device *hdev);\nint goya_debug_coresight(struct hl_device *hdev, struct hl_ctx *ctx, void *data);\nvoid goya_halt_coresight(struct hl_device *hdev, struct hl_ctx *ctx);\n\nint goya_suspend(struct hl_device *hdev);\nint goya_resume(struct hl_device *hdev);\n\nvoid goya_handle_eqe(struct hl_device *hdev, struct hl_eq_entry *eq_entry);\nvoid *goya_get_events_stat(struct hl_device *hdev, bool aggregate, u32 *size);\n\nvoid goya_add_end_of_cb_packets(struct hl_device *hdev, void *kernel_address,\n\t\t\t\tu32 len, u32 original_len, u64 cq_addr, u32 cq_val,\n\t\t\t\tu32 msix_vec, bool eb);\nint goya_cs_parser(struct hl_device *hdev, struct hl_cs_parser *parser);\nint goya_scrub_device_mem(struct hl_device *hdev);\nvoid *goya_get_int_queue_base(struct hl_device *hdev, u32 queue_id,\n\t\t\t\tdma_addr_t *dma_handle,\tu16 *queue_len);\nu32 goya_get_dma_desc_list_size(struct hl_device *hdev, struct sg_table *sgt);\nint goya_send_heartbeat(struct hl_device *hdev);\nvoid *goya_cpu_accessible_dma_pool_alloc(struct hl_device *hdev, size_t size,\n\t\t\t\t\tdma_addr_t *dma_handle);\nvoid goya_cpu_accessible_dma_pool_free(struct hl_device *hdev, size_t size,\n\t\t\t\t\tvoid *vaddr);\nvoid goya_mmu_remove_device_cpu_mappings(struct hl_device *hdev);\n\nu32 goya_get_queue_id_for_cq(struct hl_device *hdev, u32 cq_idx);\nu64 goya_get_device_time(struct hl_device *hdev);\nint goya_set_frequency(struct hl_device *hdev, enum hl_pll_frequency freq);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}