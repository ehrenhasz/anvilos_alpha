{
  "module_name": "goya_hwmgr.c",
  "hash_id": "cdd2bbd21cc7bbc52bcc999e6fb55224cee0e96efbac9bf78788b15381f23e3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/habanalabs/goya/goya_hwmgr.c",
  "human_readable_source": "\n\n \n\n#include \"goyaP.h\"\n\nvoid goya_set_pll_profile(struct hl_device *hdev, enum hl_pll_frequency freq)\n{\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (!hdev->pdev)\n\t\treturn;\n\n\tswitch (freq) {\n\tcase PLL_HIGH:\n\t\thl_fw_set_frequency(hdev, HL_GOYA_MME_PLL, hdev->high_pll);\n\t\thl_fw_set_frequency(hdev, HL_GOYA_TPC_PLL, hdev->high_pll);\n\t\thl_fw_set_frequency(hdev, HL_GOYA_IC_PLL, hdev->high_pll);\n\t\tbreak;\n\tcase PLL_LOW:\n\t\thl_fw_set_frequency(hdev, HL_GOYA_MME_PLL, GOYA_PLL_FREQ_LOW);\n\t\thl_fw_set_frequency(hdev, HL_GOYA_TPC_PLL, GOYA_PLL_FREQ_LOW);\n\t\thl_fw_set_frequency(hdev, HL_GOYA_IC_PLL, GOYA_PLL_FREQ_LOW);\n\t\tbreak;\n\tcase PLL_LAST:\n\t\thl_fw_set_frequency(hdev, HL_GOYA_MME_PLL, goya->mme_clk);\n\t\thl_fw_set_frequency(hdev, HL_GOYA_TPC_PLL, goya->tpc_clk);\n\t\thl_fw_set_frequency(hdev, HL_GOYA_IC_PLL, goya->ic_clk);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdev->dev, \"unknown frequency setting\\n\");\n\t}\n}\n\nstatic ssize_t mme_clk_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tlong value;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\tvalue = hl_fw_get_frequency(hdev, HL_GOYA_MME_PLL, false);\n\n\tif (value < 0)\n\t\treturn value;\n\n\treturn sprintf(buf, \"%lu\\n\", value);\n}\n\nstatic ssize_t mme_clk_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tstruct goya_device *goya = hdev->asic_specific;\n\tint rc;\n\tlong value;\n\n\tif (!hl_device_operational(hdev, NULL)) {\n\t\tcount = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tif (goya->pm_mng_profile == PM_AUTO) {\n\t\tcount = -EPERM;\n\t\tgoto fail;\n\t}\n\n\trc = kstrtoul(buf, 0, &value);\n\n\tif (rc) {\n\t\tcount = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\thl_fw_set_frequency(hdev, HL_GOYA_MME_PLL, value);\n\tgoya->mme_clk = value;\n\nfail:\n\treturn count;\n}\n\nstatic ssize_t tpc_clk_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tlong value;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\tvalue = hl_fw_get_frequency(hdev, HL_GOYA_TPC_PLL, false);\n\n\tif (value < 0)\n\t\treturn value;\n\n\treturn sprintf(buf, \"%lu\\n\", value);\n}\n\nstatic ssize_t tpc_clk_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tstruct goya_device *goya = hdev->asic_specific;\n\tint rc;\n\tlong value;\n\n\tif (!hl_device_operational(hdev, NULL)) {\n\t\tcount = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tif (goya->pm_mng_profile == PM_AUTO) {\n\t\tcount = -EPERM;\n\t\tgoto fail;\n\t}\n\n\trc = kstrtoul(buf, 0, &value);\n\n\tif (rc) {\n\t\tcount = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\thl_fw_set_frequency(hdev, HL_GOYA_TPC_PLL, value);\n\tgoya->tpc_clk = value;\n\nfail:\n\treturn count;\n}\n\nstatic ssize_t ic_clk_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tlong value;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\tvalue = hl_fw_get_frequency(hdev, HL_GOYA_IC_PLL, false);\n\n\tif (value < 0)\n\t\treturn value;\n\n\treturn sprintf(buf, \"%lu\\n\", value);\n}\n\nstatic ssize_t ic_clk_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tstruct goya_device *goya = hdev->asic_specific;\n\tint rc;\n\tlong value;\n\n\tif (!hl_device_operational(hdev, NULL)) {\n\t\tcount = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tif (goya->pm_mng_profile == PM_AUTO) {\n\t\tcount = -EPERM;\n\t\tgoto fail;\n\t}\n\n\trc = kstrtoul(buf, 0, &value);\n\n\tif (rc) {\n\t\tcount = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\thl_fw_set_frequency(hdev, HL_GOYA_IC_PLL, value);\n\tgoya->ic_clk = value;\n\nfail:\n\treturn count;\n}\n\nstatic ssize_t mme_clk_curr_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tlong value;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\tvalue = hl_fw_get_frequency(hdev, HL_GOYA_MME_PLL, true);\n\n\tif (value < 0)\n\t\treturn value;\n\n\treturn sprintf(buf, \"%lu\\n\", value);\n}\n\nstatic ssize_t tpc_clk_curr_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tlong value;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\tvalue = hl_fw_get_frequency(hdev, HL_GOYA_TPC_PLL, true);\n\n\tif (value < 0)\n\t\treturn value;\n\n\treturn sprintf(buf, \"%lu\\n\", value);\n}\n\nstatic ssize_t ic_clk_curr_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tlong value;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\tvalue = hl_fw_get_frequency(hdev, HL_GOYA_IC_PLL, true);\n\n\tif (value < 0)\n\t\treturn value;\n\n\treturn sprintf(buf, \"%lu\\n\", value);\n}\n\nstatic ssize_t pm_mng_profile_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"%s\\n\",\n\t\t\t(goya->pm_mng_profile == PM_AUTO) ? \"auto\" :\n\t\t\t(goya->pm_mng_profile == PM_MANUAL) ? \"manual\" :\n\t\t\t\"unknown\");\n}\n\nstatic ssize_t pm_mng_profile_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tstruct goya_device *goya = hdev->asic_specific;\n\n\tif (!hl_device_operational(hdev, NULL)) {\n\t\tcount = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&hdev->fpriv_list_lock);\n\n\tif (hdev->is_compute_ctx_active) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"Can't change PM profile while compute context is opened on the device\\n\");\n\t\tcount = -EPERM;\n\t\tgoto unlock_mutex;\n\t}\n\n\tif (strncmp(\"auto\", buf, strlen(\"auto\")) == 0) {\n\t\t \n\t\tif (goya->pm_mng_profile == PM_MANUAL) {\n\t\t\tgoya->curr_pll_profile = PLL_HIGH;\n\t\t\tgoya->pm_mng_profile = PM_AUTO;\n\t\t\tgoya_set_frequency(hdev, PLL_LOW);\n\t\t}\n\t} else if (strncmp(\"manual\", buf, strlen(\"manual\")) == 0) {\n\t\tif (goya->pm_mng_profile == PM_AUTO) {\n\t\t\t \n\t\t\tgoya->pm_mng_profile = PM_MANUAL;\n\n\t\t\tmutex_unlock(&hdev->fpriv_list_lock);\n\n\t\t\t \n\t\t\tif (goya->goya_work)\n\t\t\t\tflush_delayed_work(&goya->goya_work->work_freq);\n\n\t\t\treturn count;\n\t\t}\n\t} else {\n\t\tdev_err(hdev->dev, \"value should be auto or manual\\n\");\n\t\tcount = -EINVAL;\n\t}\n\nunlock_mutex:\n\tmutex_unlock(&hdev->fpriv_list_lock);\nout:\n\treturn count;\n}\n\nstatic ssize_t high_pll_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\n\tif (!hl_device_operational(hdev, NULL))\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"%u\\n\", hdev->high_pll);\n}\n\nstatic ssize_t high_pll_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tlong value;\n\tint rc;\n\n\tif (!hl_device_operational(hdev, NULL)) {\n\t\tcount = -ENODEV;\n\t\tgoto out;\n\t}\n\n\trc = kstrtoul(buf, 0, &value);\n\n\tif (rc) {\n\t\tcount = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thdev->high_pll = value;\n\nout:\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(high_pll);\nstatic DEVICE_ATTR_RW(ic_clk);\nstatic DEVICE_ATTR_RO(ic_clk_curr);\nstatic DEVICE_ATTR_RW(mme_clk);\nstatic DEVICE_ATTR_RO(mme_clk_curr);\nstatic DEVICE_ATTR_RW(pm_mng_profile);\nstatic DEVICE_ATTR_RW(tpc_clk);\nstatic DEVICE_ATTR_RO(tpc_clk_curr);\n\nstatic struct attribute *goya_clk_dev_attrs[] = {\n\t&dev_attr_high_pll.attr,\n\t&dev_attr_ic_clk.attr,\n\t&dev_attr_ic_clk_curr.attr,\n\t&dev_attr_mme_clk.attr,\n\t&dev_attr_mme_clk_curr.attr,\n\t&dev_attr_pm_mng_profile.attr,\n\t&dev_attr_tpc_clk.attr,\n\t&dev_attr_tpc_clk_curr.attr,\n\tNULL,\n};\n\nstatic ssize_t infineon_ver_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct hl_device *hdev = dev_get_drvdata(dev);\n\tstruct cpucp_info *cpucp_info;\n\n\tcpucp_info = &hdev->asic_prop.cpucp_info;\n\n\treturn sprintf(buf, \"%#04x\\n\", le32_to_cpu(cpucp_info->infineon_version));\n}\n\nstatic DEVICE_ATTR_RO(infineon_ver);\n\nstatic struct attribute *goya_vrm_dev_attrs[] = {\n\t&dev_attr_infineon_ver.attr,\n\tNULL,\n};\n\nvoid goya_add_device_attr(struct hl_device *hdev, struct attribute_group *dev_clk_attr_grp,\n\t\t\t\tstruct attribute_group *dev_vrm_attr_grp)\n{\n\tdev_clk_attr_grp->attrs = goya_clk_dev_attrs;\n\tdev_vrm_attr_grp->attrs = goya_vrm_dev_attrs;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}