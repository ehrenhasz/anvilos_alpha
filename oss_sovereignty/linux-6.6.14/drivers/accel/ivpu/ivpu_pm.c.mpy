{
  "module_name": "ivpu_pm.c",
  "hash_id": "e99595b6e8e57f502f2146498127a17fd4a7c6c2106b11bc382b40f76612e361",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/ivpu/ivpu_pm.c",
  "human_readable_source": "\n \n\n#include <linux/highmem.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/reboot.h>\n\n#include \"vpu_boot_api.h\"\n#include \"ivpu_drv.h\"\n#include \"ivpu_hw.h\"\n#include \"ivpu_fw.h\"\n#include \"ivpu_ipc.h\"\n#include \"ivpu_job.h\"\n#include \"ivpu_mmu.h\"\n#include \"ivpu_pm.h\"\n\nstatic bool ivpu_disable_recovery;\nmodule_param_named_unsafe(disable_recovery, ivpu_disable_recovery, bool, 0644);\nMODULE_PARM_DESC(disable_recovery, \"Disables recovery when VPU hang is detected\");\n\n#define PM_RESCHEDULE_LIMIT     5\n\nstatic void ivpu_pm_prepare_cold_boot(struct ivpu_device *vdev)\n{\n\tstruct ivpu_fw_info *fw = vdev->fw;\n\n\tivpu_cmdq_reset_all_contexts(vdev);\n\tivpu_ipc_reset(vdev);\n\tivpu_fw_load(vdev);\n\tfw->entry_point = fw->cold_boot_entry_point;\n}\n\nstatic void ivpu_pm_prepare_warm_boot(struct ivpu_device *vdev)\n{\n\tstruct ivpu_fw_info *fw = vdev->fw;\n\tstruct vpu_boot_params *bp = fw->mem->kvaddr;\n\n\tif (!bp->save_restore_ret_address) {\n\t\tivpu_pm_prepare_cold_boot(vdev);\n\t\treturn;\n\t}\n\n\tivpu_dbg(vdev, FW_BOOT, \"Save/restore entry point %llx\", bp->save_restore_ret_address);\n\tfw->entry_point = bp->save_restore_ret_address;\n}\n\nstatic int ivpu_suspend(struct ivpu_device *vdev)\n{\n\tint ret;\n\n\tret = ivpu_shutdown(vdev);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to shutdown VPU: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int ivpu_resume(struct ivpu_device *vdev)\n{\n\tint ret;\n\nretry:\n\tret = ivpu_hw_power_up(vdev);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to power up HW: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ivpu_mmu_enable(vdev);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to resume MMU: %d\\n\", ret);\n\t\tivpu_hw_power_down(vdev);\n\t\treturn ret;\n\t}\n\n\tret = ivpu_boot(vdev);\n\tif (ret) {\n\t\tivpu_mmu_disable(vdev);\n\t\tivpu_hw_power_down(vdev);\n\t\tif (!ivpu_fw_is_cold_boot(vdev)) {\n\t\t\tivpu_warn(vdev, \"Failed to resume the FW: %d. Retrying cold boot..\\n\", ret);\n\t\t\tivpu_pm_prepare_cold_boot(vdev);\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tivpu_err(vdev, \"Failed to resume the FW: %d\\n\", ret);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void ivpu_pm_recovery_work(struct work_struct *work)\n{\n\tstruct ivpu_pm_info *pm = container_of(work, struct ivpu_pm_info, recovery_work);\n\tstruct ivpu_device *vdev = pm->vdev;\n\tchar *evt[2] = {\"IVPU_PM_EVENT=IVPU_RECOVER\", NULL};\n\tint ret;\n\nretry:\n\tret = pci_try_reset_function(to_pci_dev(vdev->drm.dev));\n\tif (ret == -EAGAIN && !drm_dev_is_unplugged(&vdev->drm)) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\tif (ret && ret != -EAGAIN)\n\t\tivpu_err(vdev, \"Failed to reset VPU: %d\\n\", ret);\n\n\tkobject_uevent_env(&vdev->drm.dev->kobj, KOBJ_CHANGE, evt);\n}\n\nvoid ivpu_pm_schedule_recovery(struct ivpu_device *vdev)\n{\n\tstruct ivpu_pm_info *pm = vdev->pm;\n\n\tif (ivpu_disable_recovery) {\n\t\tivpu_err(vdev, \"Recovery not available when disable_recovery param is set\\n\");\n\t\treturn;\n\t}\n\n\tif (ivpu_is_fpga(vdev)) {\n\t\tivpu_err(vdev, \"Recovery not available on FPGA\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (atomic_cmpxchg(&pm->in_reset, 0, 1) == 0) {\n\t\tivpu_hw_irq_disable(vdev);\n\t\tqueue_work(system_long_wq, &pm->recovery_work);\n\t}\n}\n\nint ivpu_pm_suspend_cb(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct ivpu_device *vdev = to_ivpu_device(drm);\n\tunsigned long timeout;\n\n\tivpu_dbg(vdev, PM, \"Suspend..\\n\");\n\n\ttimeout = jiffies + msecs_to_jiffies(vdev->timeout.tdr);\n\twhile (!ivpu_hw_is_idle(vdev)) {\n\t\tcond_resched();\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tivpu_err(vdev, \"Failed to enter idle on system suspend\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tivpu_suspend(vdev);\n\tivpu_pm_prepare_warm_boot(vdev);\n\n\tpci_save_state(to_pci_dev(dev));\n\tpci_set_power_state(to_pci_dev(dev), PCI_D3hot);\n\n\tivpu_dbg(vdev, PM, \"Suspend done.\\n\");\n\n\treturn 0;\n}\n\nint ivpu_pm_resume_cb(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct ivpu_device *vdev = to_ivpu_device(drm);\n\tint ret;\n\n\tivpu_dbg(vdev, PM, \"Resume..\\n\");\n\n\tpci_set_power_state(to_pci_dev(dev), PCI_D0);\n\tpci_restore_state(to_pci_dev(dev));\n\n\tret = ivpu_resume(vdev);\n\tif (ret)\n\t\tivpu_err(vdev, \"Failed to resume: %d\\n\", ret);\n\n\tivpu_dbg(vdev, PM, \"Resume done.\\n\");\n\n\treturn ret;\n}\n\nint ivpu_pm_runtime_suspend_cb(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct ivpu_device *vdev = to_ivpu_device(drm);\n\tint ret;\n\n\tivpu_dbg(vdev, PM, \"Runtime suspend..\\n\");\n\n\tif (!ivpu_hw_is_idle(vdev) && vdev->pm->suspend_reschedule_counter) {\n\t\tivpu_dbg(vdev, PM, \"Failed to enter idle, rescheduling suspend, retries left %d\\n\",\n\t\t\t vdev->pm->suspend_reschedule_counter);\n\t\tpm_schedule_suspend(dev, vdev->timeout.reschedule_suspend);\n\t\tvdev->pm->suspend_reschedule_counter--;\n\t\treturn -EAGAIN;\n\t}\n\n\tret = ivpu_suspend(vdev);\n\tif (ret)\n\t\tivpu_err(vdev, \"Failed to set suspend VPU: %d\\n\", ret);\n\n\tif (!vdev->pm->suspend_reschedule_counter) {\n\t\tivpu_warn(vdev, \"VPU failed to enter idle, force suspended.\\n\");\n\t\tivpu_pm_prepare_cold_boot(vdev);\n\t} else {\n\t\tivpu_pm_prepare_warm_boot(vdev);\n\t}\n\n\tvdev->pm->suspend_reschedule_counter = PM_RESCHEDULE_LIMIT;\n\n\tivpu_dbg(vdev, PM, \"Runtime suspend done.\\n\");\n\n\treturn 0;\n}\n\nint ivpu_pm_runtime_resume_cb(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct ivpu_device *vdev = to_ivpu_device(drm);\n\tint ret;\n\n\tivpu_dbg(vdev, PM, \"Runtime resume..\\n\");\n\n\tret = ivpu_resume(vdev);\n\tif (ret)\n\t\tivpu_err(vdev, \"Failed to set RESUME state: %d\\n\", ret);\n\n\tivpu_dbg(vdev, PM, \"Runtime resume done.\\n\");\n\n\treturn ret;\n}\n\nint ivpu_rpm_get(struct ivpu_device *vdev)\n{\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(vdev->drm.dev);\n\tif (!drm_WARN_ON(&vdev->drm, ret < 0))\n\t\tvdev->pm->suspend_reschedule_counter = PM_RESCHEDULE_LIMIT;\n\n\treturn ret;\n}\n\nvoid ivpu_rpm_put(struct ivpu_device *vdev)\n{\n\tpm_runtime_mark_last_busy(vdev->drm.dev);\n\tpm_runtime_put_autosuspend(vdev->drm.dev);\n}\n\nvoid ivpu_pm_reset_prepare_cb(struct pci_dev *pdev)\n{\n\tstruct ivpu_device *vdev = pci_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(vdev->drm.dev);\n\n\tivpu_dbg(vdev, PM, \"Pre-reset..\\n\");\n\tatomic_inc(&vdev->pm->reset_counter);\n\tatomic_set(&vdev->pm->in_reset, 1);\n\tivpu_prepare_for_reset(vdev);\n\tivpu_hw_reset(vdev);\n\tivpu_pm_prepare_cold_boot(vdev);\n\tivpu_jobs_abort_all(vdev);\n\tivpu_dbg(vdev, PM, \"Pre-reset done.\\n\");\n}\n\nvoid ivpu_pm_reset_done_cb(struct pci_dev *pdev)\n{\n\tstruct ivpu_device *vdev = pci_get_drvdata(pdev);\n\tint ret;\n\n\tivpu_dbg(vdev, PM, \"Post-reset..\\n\");\n\tret = ivpu_resume(vdev);\n\tif (ret)\n\t\tivpu_err(vdev, \"Failed to set RESUME state: %d\\n\", ret);\n\tatomic_set(&vdev->pm->in_reset, 0);\n\tivpu_dbg(vdev, PM, \"Post-reset done.\\n\");\n\n\tpm_runtime_put_autosuspend(vdev->drm.dev);\n}\n\nint ivpu_pm_init(struct ivpu_device *vdev)\n{\n\tstruct device *dev = vdev->drm.dev;\n\tstruct ivpu_pm_info *pm = vdev->pm;\n\n\tpm->vdev = vdev;\n\tpm->suspend_reschedule_counter = PM_RESCHEDULE_LIMIT;\n\n\tatomic_set(&pm->in_reset, 0);\n\tINIT_WORK(&pm->recovery_work, ivpu_pm_recovery_work);\n\n\tpm_runtime_use_autosuspend(dev);\n\n\tif (ivpu_disable_recovery)\n\t\tpm_runtime_set_autosuspend_delay(dev, -1);\n\telse if (ivpu_is_silicon(vdev))\n\t\tpm_runtime_set_autosuspend_delay(dev, 100);\n\telse\n\t\tpm_runtime_set_autosuspend_delay(dev, 60000);\n\n\treturn 0;\n}\n\nvoid ivpu_pm_cancel_recovery(struct ivpu_device *vdev)\n{\n\tcancel_work_sync(&vdev->pm->recovery_work);\n}\n\nvoid ivpu_pm_enable(struct ivpu_device *vdev)\n{\n\tstruct device *dev = vdev->drm.dev;\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_allow(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n}\n\nvoid ivpu_pm_disable(struct ivpu_device *vdev)\n{\n\tpm_runtime_get_noresume(vdev->drm.dev);\n\tpm_runtime_forbid(vdev->drm.dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}