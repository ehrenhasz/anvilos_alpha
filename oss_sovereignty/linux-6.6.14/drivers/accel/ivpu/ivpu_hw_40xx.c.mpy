{
  "module_name": "ivpu_hw_40xx.c",
  "hash_id": "7b0eb988ee71651f2a8bdfb7495975dd9eecf63fa3df3091aa38dcebc0a773cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/ivpu/ivpu_hw_40xx.c",
  "human_readable_source": "\n \n\n#include \"ivpu_drv.h\"\n#include \"ivpu_fw.h\"\n#include \"ivpu_hw.h\"\n#include \"ivpu_hw_40xx_reg.h\"\n#include \"ivpu_hw_reg_io.h\"\n#include \"ivpu_ipc.h\"\n#include \"ivpu_mmu.h\"\n#include \"ivpu_pm.h\"\n\n#include <linux/dmi.h>\n\n#define TILE_MAX_NUM                 6\n#define TILE_MAX_MASK                0x3f\n\n#define LNL_HW_ID                    0x4040\n\n#define SKU_TILE_SHIFT               0u\n#define SKU_TILE_MASK                0x0000ffffu\n#define SKU_HW_ID_SHIFT              16u\n#define SKU_HW_ID_MASK               0xffff0000u\n\n#define PLL_CONFIG_DEFAULT           0x1\n#define PLL_CDYN_DEFAULT             0x80\n#define PLL_EPP_DEFAULT              0x80\n#define PLL_REF_CLK_FREQ\t     (50 * 1000000)\n#define PLL_RATIO_TO_FREQ(x)\t     ((x) * PLL_REF_CLK_FREQ)\n\n#define PLL_PROFILING_FREQ_DEFAULT   38400000\n#define PLL_PROFILING_FREQ_HIGH      400000000\n\n#define TIM_SAFE_ENABLE\t\t     0xf1d0dead\n#define TIM_WATCHDOG_RESET_VALUE     0xffffffff\n\n#define TIMEOUT_US\t\t     (150 * USEC_PER_MSEC)\n#define PWR_ISLAND_STATUS_TIMEOUT_US (5 * USEC_PER_MSEC)\n#define PLL_TIMEOUT_US\t\t     (1500 * USEC_PER_MSEC)\n\n#define WEIGHTS_DEFAULT              0xf711f711u\n#define WEIGHTS_ATS_DEFAULT          0x0000f711u\n\n#define ICB_0_IRQ_MASK ((REG_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, HOST_IPC_FIFO_INT)) | \\\n\t\t\t(REG_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, MMU_IRQ_0_INT)) | \\\n\t\t\t(REG_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, MMU_IRQ_1_INT)) | \\\n\t\t\t(REG_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, MMU_IRQ_2_INT)) | \\\n\t\t\t(REG_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, NOC_FIREWALL_INT)) | \\\n\t\t\t(REG_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, CPU_INT_REDIRECT_0_INT)) | \\\n\t\t\t(REG_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, CPU_INT_REDIRECT_1_INT)))\n\n#define ICB_1_IRQ_MASK ((REG_FLD(VPU_40XX_HOST_SS_ICB_STATUS_1, CPU_INT_REDIRECT_2_INT)) | \\\n\t\t\t(REG_FLD(VPU_40XX_HOST_SS_ICB_STATUS_1, CPU_INT_REDIRECT_3_INT)) | \\\n\t\t\t(REG_FLD(VPU_40XX_HOST_SS_ICB_STATUS_1, CPU_INT_REDIRECT_4_INT)))\n\n#define ICB_0_1_IRQ_MASK ((((u64)ICB_1_IRQ_MASK) << 32) | ICB_0_IRQ_MASK)\n\n#define BUTTRESS_IRQ_MASK ((REG_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, ATS_ERR)) | \\\n\t\t\t   (REG_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, CFI0_ERR)) | \\\n\t\t\t   (REG_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, CFI1_ERR)) | \\\n\t\t\t   (REG_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, IMR0_ERR)) | \\\n\t\t\t   (REG_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, IMR1_ERR)) | \\\n\t\t\t   (REG_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, SURV_ERR)))\n\n#define BUTTRESS_IRQ_ENABLE_MASK ((u32)~BUTTRESS_IRQ_MASK)\n#define BUTTRESS_IRQ_DISABLE_MASK ((u32)-1)\n\n#define ITF_FIREWALL_VIOLATION_MASK ((REG_FLD(VPU_40XX_HOST_SS_FW_SOC_IRQ_EN, CSS_ROM_CMX)) | \\\n\t\t\t\t     (REG_FLD(VPU_40XX_HOST_SS_FW_SOC_IRQ_EN, CSS_DBG)) | \\\n\t\t\t\t     (REG_FLD(VPU_40XX_HOST_SS_FW_SOC_IRQ_EN, CSS_CTRL)) | \\\n\t\t\t\t     (REG_FLD(VPU_40XX_HOST_SS_FW_SOC_IRQ_EN, DEC400)) | \\\n\t\t\t\t     (REG_FLD(VPU_40XX_HOST_SS_FW_SOC_IRQ_EN, MSS_NCE)) | \\\n\t\t\t\t     (REG_FLD(VPU_40XX_HOST_SS_FW_SOC_IRQ_EN, MSS_MBI)) | \\\n\t\t\t\t     (REG_FLD(VPU_40XX_HOST_SS_FW_SOC_IRQ_EN, MSS_MBI_CMX)))\n\nstatic char *ivpu_platform_to_str(u32 platform)\n{\n\tswitch (platform) {\n\tcase IVPU_PLATFORM_SILICON:\n\t\treturn \"IVPU_PLATFORM_SILICON\";\n\tcase IVPU_PLATFORM_SIMICS:\n\t\treturn \"IVPU_PLATFORM_SIMICS\";\n\tcase IVPU_PLATFORM_FPGA:\n\t\treturn \"IVPU_PLATFORM_FPGA\";\n\tdefault:\n\t\treturn \"Invalid platform\";\n\t}\n}\n\nstatic const struct dmi_system_id ivpu_dmi_platform_simulation[] = {\n\t{\n\t\t.ident = \"Intel Simics\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"lnlrvp\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VERSION, \"1.0\"),\n\t\t\tDMI_MATCH(DMI_BOARD_SERIAL, \"123456789\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Intel Simics\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Simics\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic void ivpu_hw_read_platform(struct ivpu_device *vdev)\n{\n\tif (dmi_check_system(ivpu_dmi_platform_simulation))\n\t\tvdev->platform = IVPU_PLATFORM_SIMICS;\n\telse\n\t\tvdev->platform = IVPU_PLATFORM_SILICON;\n\n\tivpu_dbg(vdev, MISC, \"Platform type: %s (%d)\\n\",\n\t\t ivpu_platform_to_str(vdev->platform), vdev->platform);\n}\n\nstatic void ivpu_hw_wa_init(struct ivpu_device *vdev)\n{\n\tvdev->wa.punit_disabled = ivpu_is_fpga(vdev);\n\tvdev->wa.clear_runtime_mem = false;\n\n\tif (ivpu_hw_gen(vdev) == IVPU_HW_40XX)\n\t\tvdev->wa.disable_clock_relinquish = true;\n\n\tIVPU_PRINT_WA(punit_disabled);\n\tIVPU_PRINT_WA(clear_runtime_mem);\n\tIVPU_PRINT_WA(disable_clock_relinquish);\n}\n\nstatic void ivpu_hw_timeouts_init(struct ivpu_device *vdev)\n{\n\tif (ivpu_is_fpga(vdev)) {\n\t\tvdev->timeout.boot = 100000;\n\t\tvdev->timeout.jsm = 50000;\n\t\tvdev->timeout.tdr = 2000000;\n\t\tvdev->timeout.reschedule_suspend = 1000;\n\t} else if (ivpu_is_simics(vdev)) {\n\t\tvdev->timeout.boot = 50;\n\t\tvdev->timeout.jsm = 500;\n\t\tvdev->timeout.tdr = 10000;\n\t\tvdev->timeout.reschedule_suspend = 10;\n\t} else {\n\t\tvdev->timeout.boot = 1000;\n\t\tvdev->timeout.jsm = 500;\n\t\tvdev->timeout.tdr = 2000;\n\t\tvdev->timeout.reschedule_suspend = 10;\n\t}\n}\n\nstatic int ivpu_pll_wait_for_cmd_send(struct ivpu_device *vdev)\n{\n\treturn REGB_POLL_FLD(VPU_40XX_BUTTRESS_WP_REQ_CMD, SEND, 0, PLL_TIMEOUT_US);\n}\n\nstatic int ivpu_pll_cmd_send(struct ivpu_device *vdev, u16 min_ratio, u16 max_ratio,\n\t\t\t     u16 target_ratio, u16 epp, u16 config, u16 cdyn)\n{\n\tint ret;\n\tu32 val;\n\n\tret = ivpu_pll_wait_for_cmd_send(vdev);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to sync before WP request: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tval = REGB_RD32(VPU_40XX_BUTTRESS_WP_REQ_PAYLOAD0);\n\tval = REG_SET_FLD_NUM(VPU_40XX_BUTTRESS_WP_REQ_PAYLOAD0, MIN_RATIO, min_ratio, val);\n\tval = REG_SET_FLD_NUM(VPU_40XX_BUTTRESS_WP_REQ_PAYLOAD0, MAX_RATIO, max_ratio, val);\n\tREGB_WR32(VPU_40XX_BUTTRESS_WP_REQ_PAYLOAD0, val);\n\n\tval = REGB_RD32(VPU_40XX_BUTTRESS_WP_REQ_PAYLOAD1);\n\tval = REG_SET_FLD_NUM(VPU_40XX_BUTTRESS_WP_REQ_PAYLOAD1, TARGET_RATIO, target_ratio, val);\n\tval = REG_SET_FLD_NUM(VPU_40XX_BUTTRESS_WP_REQ_PAYLOAD1, EPP, epp, val);\n\tREGB_WR32(VPU_40XX_BUTTRESS_WP_REQ_PAYLOAD1, val);\n\n\tval = REGB_RD32(VPU_40XX_BUTTRESS_WP_REQ_PAYLOAD2);\n\tval = REG_SET_FLD_NUM(VPU_40XX_BUTTRESS_WP_REQ_PAYLOAD2, CONFIG, config, val);\n\tval = REG_SET_FLD_NUM(VPU_40XX_BUTTRESS_WP_REQ_PAYLOAD2, CDYN, cdyn, val);\n\tREGB_WR32(VPU_40XX_BUTTRESS_WP_REQ_PAYLOAD2, val);\n\n\tval = REGB_RD32(VPU_40XX_BUTTRESS_WP_REQ_CMD);\n\tval = REG_SET_FLD(VPU_40XX_BUTTRESS_WP_REQ_CMD, SEND, val);\n\tREGB_WR32(VPU_40XX_BUTTRESS_WP_REQ_CMD, val);\n\n\tret = ivpu_pll_wait_for_cmd_send(vdev);\n\tif (ret)\n\t\tivpu_err(vdev, \"Failed to sync after WP request: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int ivpu_pll_wait_for_status_ready(struct ivpu_device *vdev)\n{\n\treturn REGB_POLL_FLD(VPU_40XX_BUTTRESS_VPU_STATUS, READY, 1, PLL_TIMEOUT_US);\n}\n\nstatic int ivpu_wait_for_clock_own_resource_ack(struct ivpu_device *vdev)\n{\n\tif (ivpu_is_simics(vdev))\n\t\treturn 0;\n\n\treturn REGB_POLL_FLD(VPU_40XX_BUTTRESS_VPU_STATUS, CLOCK_RESOURCE_OWN_ACK, 1, TIMEOUT_US);\n}\n\nstatic void ivpu_pll_init_frequency_ratios(struct ivpu_device *vdev)\n{\n\tstruct ivpu_hw_info *hw = vdev->hw;\n\tu8 fuse_min_ratio, fuse_pn_ratio, fuse_max_ratio;\n\tu32 fmin_fuse, fmax_fuse;\n\n\tfmin_fuse = REGB_RD32(VPU_40XX_BUTTRESS_FMIN_FUSE);\n\tfuse_min_ratio = REG_GET_FLD(VPU_40XX_BUTTRESS_FMIN_FUSE, MIN_RATIO, fmin_fuse);\n\tfuse_pn_ratio = REG_GET_FLD(VPU_40XX_BUTTRESS_FMIN_FUSE, PN_RATIO, fmin_fuse);\n\n\tfmax_fuse = REGB_RD32(VPU_40XX_BUTTRESS_FMAX_FUSE);\n\tfuse_max_ratio = REG_GET_FLD(VPU_40XX_BUTTRESS_FMAX_FUSE, MAX_RATIO, fmax_fuse);\n\n\thw->pll.min_ratio = clamp_t(u8, ivpu_pll_min_ratio, fuse_min_ratio, fuse_max_ratio);\n\thw->pll.max_ratio = clamp_t(u8, ivpu_pll_max_ratio, hw->pll.min_ratio, fuse_max_ratio);\n\thw->pll.pn_ratio = clamp_t(u8, fuse_pn_ratio, hw->pll.min_ratio, hw->pll.max_ratio);\n}\n\nstatic int ivpu_pll_drive(struct ivpu_device *vdev, bool enable)\n{\n\tu16 config = enable ? PLL_CONFIG_DEFAULT : 0;\n\tu16 cdyn = enable ? PLL_CDYN_DEFAULT : 0;\n\tu16 epp = enable ? PLL_EPP_DEFAULT : 0;\n\tstruct ivpu_hw_info *hw = vdev->hw;\n\tu16 target_ratio = hw->pll.pn_ratio;\n\tint ret;\n\n\tivpu_dbg(vdev, PM, \"PLL workpoint request: %u Hz, epp: 0x%x, config: 0x%x, cdyn: 0x%x\\n\",\n\t\t PLL_RATIO_TO_FREQ(target_ratio), epp, config, cdyn);\n\n\tret = ivpu_pll_cmd_send(vdev, hw->pll.min_ratio, hw->pll.max_ratio,\n\t\t\t\ttarget_ratio, epp, config, cdyn);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to send PLL workpoint request: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (enable) {\n\t\tret = ivpu_pll_wait_for_status_ready(vdev);\n\t\tif (ret) {\n\t\t\tivpu_err(vdev, \"Timed out waiting for PLL ready status\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ivpu_pll_enable(struct ivpu_device *vdev)\n{\n\treturn ivpu_pll_drive(vdev, true);\n}\n\nstatic int ivpu_pll_disable(struct ivpu_device *vdev)\n{\n\treturn ivpu_pll_drive(vdev, false);\n}\n\nstatic void ivpu_boot_host_ss_rst_drive(struct ivpu_device *vdev, bool enable)\n{\n\tu32 val = REGV_RD32(VPU_40XX_HOST_SS_CPR_RST_EN);\n\n\tif (enable) {\n\t\tval = REG_SET_FLD(VPU_40XX_HOST_SS_CPR_RST_EN, TOP_NOC, val);\n\t\tval = REG_SET_FLD(VPU_40XX_HOST_SS_CPR_RST_EN, DSS_MAS, val);\n\t\tval = REG_SET_FLD(VPU_40XX_HOST_SS_CPR_RST_EN, CSS_MAS, val);\n\t} else {\n\t\tval = REG_CLR_FLD(VPU_40XX_HOST_SS_CPR_RST_EN, TOP_NOC, val);\n\t\tval = REG_CLR_FLD(VPU_40XX_HOST_SS_CPR_RST_EN, DSS_MAS, val);\n\t\tval = REG_CLR_FLD(VPU_40XX_HOST_SS_CPR_RST_EN, CSS_MAS, val);\n\t}\n\n\tREGV_WR32(VPU_40XX_HOST_SS_CPR_RST_EN, val);\n}\n\nstatic void ivpu_boot_host_ss_clk_drive(struct ivpu_device *vdev, bool enable)\n{\n\tu32 val = REGV_RD32(VPU_40XX_HOST_SS_CPR_CLK_EN);\n\n\tif (enable) {\n\t\tval = REG_SET_FLD(VPU_40XX_HOST_SS_CPR_CLK_EN, TOP_NOC, val);\n\t\tval = REG_SET_FLD(VPU_40XX_HOST_SS_CPR_CLK_EN, DSS_MAS, val);\n\t\tval = REG_SET_FLD(VPU_40XX_HOST_SS_CPR_CLK_EN, CSS_MAS, val);\n\t} else {\n\t\tval = REG_CLR_FLD(VPU_40XX_HOST_SS_CPR_CLK_EN, TOP_NOC, val);\n\t\tval = REG_CLR_FLD(VPU_40XX_HOST_SS_CPR_CLK_EN, DSS_MAS, val);\n\t\tval = REG_CLR_FLD(VPU_40XX_HOST_SS_CPR_CLK_EN, CSS_MAS, val);\n\t}\n\n\tREGV_WR32(VPU_40XX_HOST_SS_CPR_CLK_EN, val);\n}\n\nstatic int ivpu_boot_noc_qreqn_check(struct ivpu_device *vdev, u32 exp_val)\n{\n\tu32 val = REGV_RD32(VPU_40XX_HOST_SS_NOC_QREQN);\n\n\tif (!REG_TEST_FLD_NUM(VPU_40XX_HOST_SS_NOC_QREQN, TOP_SOCMMIO, exp_val, val))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int ivpu_boot_noc_qacceptn_check(struct ivpu_device *vdev, u32 exp_val)\n{\n\tu32 val = REGV_RD32(VPU_40XX_HOST_SS_NOC_QACCEPTN);\n\n\tif (!REG_TEST_FLD_NUM(VPU_40XX_HOST_SS_NOC_QACCEPTN, TOP_SOCMMIO, exp_val, val))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int ivpu_boot_noc_qdeny_check(struct ivpu_device *vdev, u32 exp_val)\n{\n\tu32 val = REGV_RD32(VPU_40XX_HOST_SS_NOC_QDENY);\n\n\tif (!REG_TEST_FLD_NUM(VPU_40XX_HOST_SS_NOC_QDENY, TOP_SOCMMIO, exp_val, val))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int ivpu_boot_top_noc_qrenqn_check(struct ivpu_device *vdev, u32 exp_val)\n{\n\tu32 val = REGV_RD32(VPU_40XX_TOP_NOC_QREQN);\n\n\tif (!REG_TEST_FLD_NUM(VPU_40XX_TOP_NOC_QREQN, CPU_CTRL, exp_val, val) ||\n\t    !REG_TEST_FLD_NUM(VPU_40XX_TOP_NOC_QREQN, HOSTIF_L2CACHE, exp_val, val))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int ivpu_boot_top_noc_qacceptn_check(struct ivpu_device *vdev, u32 exp_val)\n{\n\tu32 val = REGV_RD32(VPU_40XX_TOP_NOC_QACCEPTN);\n\n\tif (!REG_TEST_FLD_NUM(VPU_40XX_TOP_NOC_QACCEPTN, CPU_CTRL, exp_val, val) ||\n\t    !REG_TEST_FLD_NUM(VPU_40XX_TOP_NOC_QACCEPTN, HOSTIF_L2CACHE, exp_val, val))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int ivpu_boot_top_noc_qdeny_check(struct ivpu_device *vdev, u32 exp_val)\n{\n\tu32 val = REGV_RD32(VPU_40XX_TOP_NOC_QDENY);\n\n\tif (!REG_TEST_FLD_NUM(VPU_40XX_TOP_NOC_QDENY, CPU_CTRL, exp_val, val) ||\n\t    !REG_TEST_FLD_NUM(VPU_40XX_TOP_NOC_QDENY, HOSTIF_L2CACHE, exp_val, val))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void ivpu_boot_idle_gen_drive(struct ivpu_device *vdev, bool enable)\n{\n\tu32 val = REGV_RD32(VPU_40XX_HOST_SS_AON_IDLE_GEN);\n\n\tif (enable)\n\t\tval = REG_SET_FLD(VPU_40XX_HOST_SS_AON_IDLE_GEN, EN, val);\n\telse\n\t\tval = REG_CLR_FLD(VPU_40XX_HOST_SS_AON_IDLE_GEN, EN, val);\n\n\tREGV_WR32(VPU_40XX_HOST_SS_AON_IDLE_GEN, val);\n}\n\nstatic int ivpu_boot_host_ss_check(struct ivpu_device *vdev)\n{\n\tint ret;\n\n\tret = ivpu_boot_noc_qreqn_check(vdev, 0x0);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed qreqn check: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ivpu_boot_noc_qacceptn_check(vdev, 0x0);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed qacceptn check: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ivpu_boot_noc_qdeny_check(vdev, 0x0);\n\tif (ret)\n\t\tivpu_err(vdev, \"Failed qdeny check %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int ivpu_boot_host_ss_axi_drive(struct ivpu_device *vdev, bool enable)\n{\n\tint ret;\n\tu32 val;\n\n\tval = REGV_RD32(VPU_40XX_HOST_SS_NOC_QREQN);\n\tif (enable)\n\t\tval = REG_SET_FLD(VPU_40XX_HOST_SS_NOC_QREQN, TOP_SOCMMIO, val);\n\telse\n\t\tval = REG_CLR_FLD(VPU_40XX_HOST_SS_NOC_QREQN, TOP_SOCMMIO, val);\n\tREGV_WR32(VPU_40XX_HOST_SS_NOC_QREQN, val);\n\n\tret = ivpu_boot_noc_qacceptn_check(vdev, enable ? 0x1 : 0x0);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed qacceptn check: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ivpu_boot_noc_qdeny_check(vdev, 0x0);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed qdeny check: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (enable) {\n\t\tREGB_WR32(VPU_40XX_BUTTRESS_PORT_ARBITRATION_WEIGHTS, WEIGHTS_DEFAULT);\n\t\tREGB_WR32(VPU_40XX_BUTTRESS_PORT_ARBITRATION_WEIGHTS_ATS, WEIGHTS_ATS_DEFAULT);\n\t}\n\n\treturn ret;\n}\n\nstatic int ivpu_boot_host_ss_axi_enable(struct ivpu_device *vdev)\n{\n\treturn ivpu_boot_host_ss_axi_drive(vdev, true);\n}\n\nstatic int ivpu_boot_host_ss_top_noc_drive(struct ivpu_device *vdev, bool enable)\n{\n\tint ret;\n\tu32 val;\n\n\tval = REGV_RD32(VPU_40XX_TOP_NOC_QREQN);\n\tif (enable) {\n\t\tval = REG_SET_FLD(VPU_40XX_TOP_NOC_QREQN, CPU_CTRL, val);\n\t\tval = REG_SET_FLD(VPU_40XX_TOP_NOC_QREQN, HOSTIF_L2CACHE, val);\n\t} else {\n\t\tval = REG_CLR_FLD(VPU_40XX_TOP_NOC_QREQN, CPU_CTRL, val);\n\t\tval = REG_CLR_FLD(VPU_40XX_TOP_NOC_QREQN, HOSTIF_L2CACHE, val);\n\t}\n\tREGV_WR32(VPU_40XX_TOP_NOC_QREQN, val);\n\n\tret = ivpu_boot_top_noc_qacceptn_check(vdev, enable ? 0x1 : 0x0);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed qacceptn check: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ivpu_boot_top_noc_qdeny_check(vdev, 0x0);\n\tif (ret)\n\t\tivpu_err(vdev, \"Failed qdeny check: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int ivpu_boot_host_ss_top_noc_enable(struct ivpu_device *vdev)\n{\n\treturn ivpu_boot_host_ss_top_noc_drive(vdev, true);\n}\n\nstatic void ivpu_boot_pwr_island_trickle_drive(struct ivpu_device *vdev, bool enable)\n{\n\tu32 val = REGV_RD32(VPU_40XX_HOST_SS_AON_PWR_ISLAND_TRICKLE_EN0);\n\n\tif (enable)\n\t\tval = REG_SET_FLD(VPU_40XX_HOST_SS_AON_PWR_ISLAND_TRICKLE_EN0, CSS_CPU, val);\n\telse\n\t\tval = REG_CLR_FLD(VPU_40XX_HOST_SS_AON_PWR_ISLAND_TRICKLE_EN0, CSS_CPU, val);\n\n\tREGV_WR32(VPU_40XX_HOST_SS_AON_PWR_ISLAND_TRICKLE_EN0, val);\n\n\tif (enable)\n\t\tndelay(500);\n}\n\nstatic void ivpu_boot_pwr_island_drive(struct ivpu_device *vdev, bool enable)\n{\n\tu32 val = REGV_RD32(VPU_40XX_HOST_SS_AON_PWR_ISLAND_EN0);\n\n\tif (enable)\n\t\tval = REG_SET_FLD(VPU_40XX_HOST_SS_AON_PWR_ISLAND_EN0, CSS_CPU, val);\n\telse\n\t\tval = REG_CLR_FLD(VPU_40XX_HOST_SS_AON_PWR_ISLAND_EN0, CSS_CPU, val);\n\n\tREGV_WR32(VPU_40XX_HOST_SS_AON_PWR_ISLAND_EN0, val);\n\n\tif (!enable)\n\t\tndelay(500);\n}\n\nstatic int ivpu_boot_wait_for_pwr_island_status(struct ivpu_device *vdev, u32 exp_val)\n{\n\tif (ivpu_is_fpga(vdev))\n\t\treturn 0;\n\n\treturn REGV_POLL_FLD(VPU_40XX_HOST_SS_AON_PWR_ISLAND_STATUS0, CSS_CPU,\n\t\t\t     exp_val, PWR_ISLAND_STATUS_TIMEOUT_US);\n}\n\nstatic void ivpu_boot_pwr_island_isolation_drive(struct ivpu_device *vdev, bool enable)\n{\n\tu32 val = REGV_RD32(VPU_40XX_HOST_SS_AON_PWR_ISO_EN0);\n\n\tif (enable)\n\t\tval = REG_SET_FLD(VPU_40XX_HOST_SS_AON_PWR_ISO_EN0, CSS_CPU, val);\n\telse\n\t\tval = REG_CLR_FLD(VPU_40XX_HOST_SS_AON_PWR_ISO_EN0, CSS_CPU, val);\n\n\tREGV_WR32(VPU_40XX_HOST_SS_AON_PWR_ISO_EN0, val);\n}\n\nstatic void ivpu_boot_no_snoop_enable(struct ivpu_device *vdev)\n{\n\tu32 val = REGV_RD32(VPU_40XX_HOST_IF_TCU_PTW_OVERRIDES);\n\n\tval = REG_SET_FLD(VPU_40XX_HOST_IF_TCU_PTW_OVERRIDES, SNOOP_OVERRIDE_EN, val);\n\tval = REG_CLR_FLD(VPU_40XX_HOST_IF_TCU_PTW_OVERRIDES, AW_SNOOP_OVERRIDE, val);\n\tval = REG_CLR_FLD(VPU_40XX_HOST_IF_TCU_PTW_OVERRIDES, AR_SNOOP_OVERRIDE, val);\n\n\tREGV_WR32(VPU_40XX_HOST_IF_TCU_PTW_OVERRIDES, val);\n}\n\nstatic void ivpu_boot_tbu_mmu_enable(struct ivpu_device *vdev)\n{\n\tu32 val = REGV_RD32(VPU_40XX_HOST_IF_TBU_MMUSSIDV);\n\n\tval = REG_SET_FLD(VPU_40XX_HOST_IF_TBU_MMUSSIDV, TBU0_AWMMUSSIDV, val);\n\tval = REG_SET_FLD(VPU_40XX_HOST_IF_TBU_MMUSSIDV, TBU0_ARMMUSSIDV, val);\n\tval = REG_SET_FLD(VPU_40XX_HOST_IF_TBU_MMUSSIDV, TBU1_AWMMUSSIDV, val);\n\tval = REG_SET_FLD(VPU_40XX_HOST_IF_TBU_MMUSSIDV, TBU1_ARMMUSSIDV, val);\n\tval = REG_SET_FLD(VPU_40XX_HOST_IF_TBU_MMUSSIDV, TBU2_AWMMUSSIDV, val);\n\tval = REG_SET_FLD(VPU_40XX_HOST_IF_TBU_MMUSSIDV, TBU2_ARMMUSSIDV, val);\n\n\tREGV_WR32(VPU_40XX_HOST_IF_TBU_MMUSSIDV, val);\n}\n\nstatic int ivpu_boot_cpu_noc_qacceptn_check(struct ivpu_device *vdev, u32 exp_val)\n{\n\tu32 val = REGV_RD32(VPU_40XX_CPU_SS_CPR_NOC_QACCEPTN);\n\n\tif (!REG_TEST_FLD_NUM(VPU_40XX_CPU_SS_CPR_NOC_QACCEPTN, TOP_MMIO, exp_val, val))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int ivpu_boot_cpu_noc_qdeny_check(struct ivpu_device *vdev, u32 exp_val)\n{\n\tu32 val = REGV_RD32(VPU_40XX_CPU_SS_CPR_NOC_QDENY);\n\n\tif (!REG_TEST_FLD_NUM(VPU_40XX_CPU_SS_CPR_NOC_QDENY, TOP_MMIO, exp_val, val))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int ivpu_boot_pwr_domain_enable(struct ivpu_device *vdev)\n{\n\tint ret;\n\n\tret = ivpu_wait_for_clock_own_resource_ack(vdev);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Timed out waiting for clock own resource ACK\\n\");\n\t\treturn ret;\n\t}\n\n\tivpu_boot_pwr_island_trickle_drive(vdev, true);\n\tivpu_boot_pwr_island_drive(vdev, true);\n\n\tret = ivpu_boot_wait_for_pwr_island_status(vdev, 0x1);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Timed out waiting for power island status\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ivpu_boot_top_noc_qrenqn_check(vdev, 0x0);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed qrenqn check %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tivpu_boot_host_ss_clk_drive(vdev, true);\n\tivpu_boot_host_ss_rst_drive(vdev, true);\n\tivpu_boot_pwr_island_isolation_drive(vdev, false);\n\n\treturn ret;\n}\n\nstatic int ivpu_boot_soc_cpu_drive(struct ivpu_device *vdev, bool enable)\n{\n\tint ret;\n\tu32 val;\n\n\tval = REGV_RD32(VPU_40XX_CPU_SS_CPR_NOC_QREQN);\n\tif (enable)\n\t\tval = REG_SET_FLD(VPU_40XX_CPU_SS_CPR_NOC_QREQN, TOP_MMIO, val);\n\telse\n\t\tval = REG_CLR_FLD(VPU_40XX_CPU_SS_CPR_NOC_QREQN, TOP_MMIO, val);\n\tREGV_WR32(VPU_40XX_CPU_SS_CPR_NOC_QREQN, val);\n\n\tret = ivpu_boot_cpu_noc_qacceptn_check(vdev, enable ? 0x1 : 0x0);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed qacceptn check: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ivpu_boot_cpu_noc_qdeny_check(vdev, 0x0);\n\tif (ret)\n\t\tivpu_err(vdev, \"Failed qdeny check: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int ivpu_boot_soc_cpu_enable(struct ivpu_device *vdev)\n{\n\treturn ivpu_boot_soc_cpu_drive(vdev, true);\n}\n\nstatic int ivpu_boot_soc_cpu_boot(struct ivpu_device *vdev)\n{\n\tint ret;\n\tu32 val;\n\tu64 val64;\n\n\tret = ivpu_boot_soc_cpu_enable(vdev);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to enable SOC CPU: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tval64 = vdev->fw->entry_point;\n\tval64 <<= ffs(VPU_40XX_HOST_SS_VERIFICATION_ADDRESS_LO_IMAGE_LOCATION_MASK) - 1;\n\tREGV_WR64(VPU_40XX_HOST_SS_VERIFICATION_ADDRESS_LO, val64);\n\n\tval = REGV_RD32(VPU_40XX_HOST_SS_VERIFICATION_ADDRESS_LO);\n\tval = REG_SET_FLD(VPU_40XX_HOST_SS_VERIFICATION_ADDRESS_LO, DONE, val);\n\tREGV_WR32(VPU_40XX_HOST_SS_VERIFICATION_ADDRESS_LO, val);\n\n\tivpu_dbg(vdev, PM, \"Booting firmware, mode: %s\\n\",\n\t\t ivpu_fw_is_cold_boot(vdev) ? \"cold boot\" : \"resume\");\n\n\treturn 0;\n}\n\nstatic int ivpu_boot_d0i3_drive(struct ivpu_device *vdev, bool enable)\n{\n\tint ret;\n\tu32 val;\n\n\tret = REGB_POLL_FLD(VPU_40XX_BUTTRESS_D0I3_CONTROL, INPROGRESS, 0, TIMEOUT_US);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to sync before D0i3 transition: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tval = REGB_RD32(VPU_40XX_BUTTRESS_D0I3_CONTROL);\n\tif (enable)\n\t\tval = REG_SET_FLD(VPU_40XX_BUTTRESS_D0I3_CONTROL, I3, val);\n\telse\n\t\tval = REG_CLR_FLD(VPU_40XX_BUTTRESS_D0I3_CONTROL, I3, val);\n\tREGB_WR32(VPU_40XX_BUTTRESS_D0I3_CONTROL, val);\n\n\tret = REGB_POLL_FLD(VPU_40XX_BUTTRESS_D0I3_CONTROL, INPROGRESS, 0, TIMEOUT_US);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to sync after D0i3 transition: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool ivpu_tile_disable_check(u32 config)\n{\n\t \n\tif (config == 0)\n\t\treturn true;\n\n\tif (config > BIT(TILE_MAX_NUM - 1))\n\t\treturn false;\n\n\tif ((config & (config - 1)) == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int ivpu_hw_40xx_info_init(struct ivpu_device *vdev)\n{\n\tstruct ivpu_hw_info *hw = vdev->hw;\n\tu32 tile_disable;\n\tu32 tile_enable;\n\tu32 fuse;\n\n\tfuse = REGB_RD32(VPU_40XX_BUTTRESS_TILE_FUSE);\n\tif (!REG_TEST_FLD(VPU_40XX_BUTTRESS_TILE_FUSE, VALID, fuse)) {\n\t\tivpu_err(vdev, \"Fuse: invalid (0x%x)\\n\", fuse);\n\t\treturn -EIO;\n\t}\n\n\ttile_disable = REG_GET_FLD(VPU_40XX_BUTTRESS_TILE_FUSE, CONFIG, fuse);\n\tif (!ivpu_tile_disable_check(tile_disable)) {\n\t\tivpu_err(vdev, \"Fuse: Invalid tile disable config (0x%x)\\n\", tile_disable);\n\t\treturn -EIO;\n\t}\n\n\tif (tile_disable)\n\t\tivpu_dbg(vdev, MISC, \"Fuse: %d tiles enabled. Tile number %d disabled\\n\",\n\t\t\t TILE_MAX_NUM - 1, ffs(tile_disable) - 1);\n\telse\n\t\tivpu_dbg(vdev, MISC, \"Fuse: All %d tiles enabled\\n\", TILE_MAX_NUM);\n\n\ttile_enable = (~tile_disable) & TILE_MAX_MASK;\n\n\thw->sku = REG_SET_FLD_NUM(SKU, HW_ID, LNL_HW_ID, hw->sku);\n\thw->sku = REG_SET_FLD_NUM(SKU, TILE, tile_enable, hw->sku);\n\thw->tile_fuse = tile_disable;\n\thw->pll.profiling_freq = PLL_PROFILING_FREQ_DEFAULT;\n\n\tivpu_pll_init_frequency_ratios(vdev);\n\n\tivpu_hw_init_range(&vdev->hw->ranges.global, 0x80000000, SZ_512M);\n\tivpu_hw_init_range(&vdev->hw->ranges.user,   0x80000000, SZ_256M);\n\tivpu_hw_init_range(&vdev->hw->ranges.shave,  0x80000000 + SZ_256M, SZ_2G - SZ_256M);\n\tivpu_hw_init_range(&vdev->hw->ranges.dma,   0x200000000, SZ_8G);\n\n\tivpu_hw_read_platform(vdev);\n\tivpu_hw_wa_init(vdev);\n\tivpu_hw_timeouts_init(vdev);\n\n\treturn 0;\n}\n\nstatic int ivpu_hw_40xx_reset(struct ivpu_device *vdev)\n{\n\tint ret;\n\tu32 val;\n\n\tret = REGB_POLL_FLD(VPU_40XX_BUTTRESS_IP_RESET, TRIGGER, 0, TIMEOUT_US);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Wait for *_TRIGGER timed out\\n\");\n\t\treturn ret;\n\t}\n\n\tval = REGB_RD32(VPU_40XX_BUTTRESS_IP_RESET);\n\tval = REG_SET_FLD(VPU_40XX_BUTTRESS_IP_RESET, TRIGGER, val);\n\tREGB_WR32(VPU_40XX_BUTTRESS_IP_RESET, val);\n\n\tret = REGB_POLL_FLD(VPU_40XX_BUTTRESS_IP_RESET, TRIGGER, 0, TIMEOUT_US);\n\tif (ret)\n\t\tivpu_err(vdev, \"Timed out waiting for RESET completion\\n\");\n\n\treturn ret;\n}\n\nstatic int ivpu_hw_40xx_d0i3_enable(struct ivpu_device *vdev)\n{\n\tint ret;\n\n\tif (IVPU_WA(punit_disabled))\n\t\treturn 0;\n\n\tret = ivpu_boot_d0i3_drive(vdev, true);\n\tif (ret)\n\t\tivpu_err(vdev, \"Failed to enable D0i3: %d\\n\", ret);\n\n\tudelay(5);  \n\n\treturn ret;\n}\n\nstatic int ivpu_hw_40xx_d0i3_disable(struct ivpu_device *vdev)\n{\n\tint ret;\n\n\tif (IVPU_WA(punit_disabled))\n\t\treturn 0;\n\n\tret = ivpu_boot_d0i3_drive(vdev, false);\n\tif (ret)\n\t\tivpu_err(vdev, \"Failed to disable D0i3: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void ivpu_hw_40xx_profiling_freq_reg_set(struct ivpu_device *vdev)\n{\n\tu32 val = REGB_RD32(VPU_40XX_BUTTRESS_VPU_STATUS);\n\n\tif (vdev->hw->pll.profiling_freq == PLL_PROFILING_FREQ_DEFAULT)\n\t\tval = REG_CLR_FLD(VPU_40XX_BUTTRESS_VPU_STATUS, PERF_CLK, val);\n\telse\n\t\tval = REG_SET_FLD(VPU_40XX_BUTTRESS_VPU_STATUS, PERF_CLK, val);\n\n\tREGB_WR32(VPU_40XX_BUTTRESS_VPU_STATUS, val);\n}\n\nstatic void ivpu_hw_40xx_ats_print(struct ivpu_device *vdev)\n{\n\tivpu_dbg(vdev, MISC, \"Buttress ATS: %s\\n\",\n\t\t REGB_RD32(VPU_40XX_BUTTRESS_HM_ATS) ? \"Enable\" : \"Disable\");\n}\n\nstatic void ivpu_hw_40xx_clock_relinquish_disable(struct ivpu_device *vdev)\n{\n\tu32 val = REGB_RD32(VPU_40XX_BUTTRESS_VPU_STATUS);\n\n\tval = REG_SET_FLD(VPU_40XX_BUTTRESS_VPU_STATUS, DISABLE_CLK_RELINQUISH, val);\n\tREGB_WR32(VPU_40XX_BUTTRESS_VPU_STATUS, val);\n}\n\nstatic int ivpu_hw_40xx_power_up(struct ivpu_device *vdev)\n{\n\tint ret;\n\n\tret = ivpu_hw_40xx_reset(vdev);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to reset HW: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ivpu_hw_40xx_d0i3_disable(vdev);\n\tif (ret)\n\t\tivpu_warn(vdev, \"Failed to disable D0I3: %d\\n\", ret);\n\n\tret = ivpu_pll_enable(vdev);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to enable PLL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (IVPU_WA(disable_clock_relinquish))\n\t\tivpu_hw_40xx_clock_relinquish_disable(vdev);\n\tivpu_hw_40xx_profiling_freq_reg_set(vdev);\n\tivpu_hw_40xx_ats_print(vdev);\n\n\tret = ivpu_boot_host_ss_check(vdev);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to configure host SS: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tivpu_boot_idle_gen_drive(vdev, false);\n\n\tret = ivpu_boot_pwr_domain_enable(vdev);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to enable power domain: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ivpu_boot_host_ss_axi_enable(vdev);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to enable AXI: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ivpu_boot_host_ss_top_noc_enable(vdev);\n\tif (ret)\n\t\tivpu_err(vdev, \"Failed to enable TOP NOC: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int ivpu_hw_40xx_boot_fw(struct ivpu_device *vdev)\n{\n\tint ret;\n\n\tivpu_boot_no_snoop_enable(vdev);\n\tivpu_boot_tbu_mmu_enable(vdev);\n\n\tret = ivpu_boot_soc_cpu_boot(vdev);\n\tif (ret)\n\t\tivpu_err(vdev, \"Failed to boot SOC CPU: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic bool ivpu_hw_40xx_is_idle(struct ivpu_device *vdev)\n{\n\tu32 val;\n\n\tif (IVPU_WA(punit_disabled))\n\t\treturn true;\n\n\tval = REGB_RD32(VPU_40XX_BUTTRESS_VPU_STATUS);\n\treturn REG_TEST_FLD(VPU_40XX_BUTTRESS_VPU_STATUS, READY, val) &&\n\t       REG_TEST_FLD(VPU_40XX_BUTTRESS_VPU_STATUS, IDLE, val);\n}\n\nstatic int ivpu_hw_40xx_power_down(struct ivpu_device *vdev)\n{\n\tint ret = 0;\n\n\tif (!ivpu_hw_40xx_is_idle(vdev) && ivpu_hw_40xx_reset(vdev))\n\t\tivpu_warn(vdev, \"Failed to reset the VPU\\n\");\n\n\tif (ivpu_pll_disable(vdev)) {\n\t\tivpu_err(vdev, \"Failed to disable PLL\\n\");\n\t\tret = -EIO;\n\t}\n\n\tif (ivpu_hw_40xx_d0i3_enable(vdev)) {\n\t\tivpu_err(vdev, \"Failed to enter D0I3\\n\");\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic void ivpu_hw_40xx_wdt_disable(struct ivpu_device *vdev)\n{\n\tu32 val;\n\n\tREGV_WR32(VPU_40XX_CPU_SS_TIM_SAFE, TIM_SAFE_ENABLE);\n\tREGV_WR32(VPU_40XX_CPU_SS_TIM_WATCHDOG, TIM_WATCHDOG_RESET_VALUE);\n\n\tREGV_WR32(VPU_40XX_CPU_SS_TIM_SAFE, TIM_SAFE_ENABLE);\n\tREGV_WR32(VPU_40XX_CPU_SS_TIM_WDOG_EN, 0);\n\n\tval = REGV_RD32(VPU_40XX_CPU_SS_TIM_GEN_CONFIG);\n\tval = REG_CLR_FLD(VPU_40XX_CPU_SS_TIM_GEN_CONFIG, WDOG_TO_INT_CLR, val);\n\tREGV_WR32(VPU_40XX_CPU_SS_TIM_GEN_CONFIG, val);\n}\n\n \nstatic u32 ivpu_hw_40xx_reg_pll_freq_get(struct ivpu_device *vdev)\n{\n\tu32 pll_curr_ratio;\n\n\tpll_curr_ratio = REGB_RD32(VPU_40XX_BUTTRESS_PLL_FREQ);\n\tpll_curr_ratio &= VPU_40XX_BUTTRESS_PLL_FREQ_RATIO_MASK;\n\n\treturn PLL_RATIO_TO_FREQ(pll_curr_ratio);\n}\n\nstatic u32 ivpu_hw_40xx_reg_telemetry_offset_get(struct ivpu_device *vdev)\n{\n\treturn REGB_RD32(VPU_40XX_BUTTRESS_VPU_TELEMETRY_OFFSET);\n}\n\nstatic u32 ivpu_hw_40xx_reg_telemetry_size_get(struct ivpu_device *vdev)\n{\n\treturn REGB_RD32(VPU_40XX_BUTTRESS_VPU_TELEMETRY_SIZE);\n}\n\nstatic u32 ivpu_hw_40xx_reg_telemetry_enable_get(struct ivpu_device *vdev)\n{\n\treturn REGB_RD32(VPU_40XX_BUTTRESS_VPU_TELEMETRY_ENABLE);\n}\n\nstatic void ivpu_hw_40xx_reg_db_set(struct ivpu_device *vdev, u32 db_id)\n{\n\tu32 reg_stride = VPU_40XX_CPU_SS_DOORBELL_1 - VPU_40XX_CPU_SS_DOORBELL_0;\n\tu32 val = REG_FLD(VPU_40XX_CPU_SS_DOORBELL_0, SET);\n\n\tREGV_WR32I(VPU_40XX_CPU_SS_DOORBELL_0, reg_stride, db_id, val);\n}\n\nstatic u32 ivpu_hw_40xx_reg_ipc_rx_addr_get(struct ivpu_device *vdev)\n{\n\treturn REGV_RD32(VPU_40XX_HOST_SS_TIM_IPC_FIFO_ATM);\n}\n\nstatic u32 ivpu_hw_40xx_reg_ipc_rx_count_get(struct ivpu_device *vdev)\n{\n\tu32 count = REGV_RD32_SILENT(VPU_40XX_HOST_SS_TIM_IPC_FIFO_STAT);\n\n\treturn REG_GET_FLD(VPU_40XX_HOST_SS_TIM_IPC_FIFO_STAT, FILL_LEVEL, count);\n}\n\nstatic void ivpu_hw_40xx_reg_ipc_tx_set(struct ivpu_device *vdev, u32 vpu_addr)\n{\n\tREGV_WR32(VPU_40XX_CPU_SS_TIM_IPC_FIFO, vpu_addr);\n}\n\nstatic void ivpu_hw_40xx_irq_clear(struct ivpu_device *vdev)\n{\n\tREGV_WR64(VPU_40XX_HOST_SS_ICB_CLEAR_0, ICB_0_1_IRQ_MASK);\n}\n\nstatic void ivpu_hw_40xx_irq_enable(struct ivpu_device *vdev)\n{\n\tREGV_WR32(VPU_40XX_HOST_SS_FW_SOC_IRQ_EN, ITF_FIREWALL_VIOLATION_MASK);\n\tREGV_WR64(VPU_40XX_HOST_SS_ICB_ENABLE_0, ICB_0_1_IRQ_MASK);\n\tREGB_WR32(VPU_40XX_BUTTRESS_LOCAL_INT_MASK, BUTTRESS_IRQ_ENABLE_MASK);\n\tREGB_WR32(VPU_40XX_BUTTRESS_GLOBAL_INT_MASK, 0x0);\n}\n\nstatic void ivpu_hw_40xx_irq_disable(struct ivpu_device *vdev)\n{\n\tREGB_WR32(VPU_40XX_BUTTRESS_GLOBAL_INT_MASK, 0x1);\n\tREGB_WR32(VPU_40XX_BUTTRESS_LOCAL_INT_MASK, BUTTRESS_IRQ_DISABLE_MASK);\n\tREGV_WR64(VPU_40XX_HOST_SS_ICB_ENABLE_0, 0x0ull);\n\tREGV_WR32(VPU_40XX_HOST_SS_FW_SOC_IRQ_EN, 0x0ul);\n}\n\nstatic void ivpu_hw_40xx_irq_wdt_nce_handler(struct ivpu_device *vdev)\n{\n\t \n\tivpu_pm_schedule_recovery(vdev);\n}\n\nstatic void ivpu_hw_40xx_irq_wdt_mss_handler(struct ivpu_device *vdev)\n{\n\tivpu_hw_wdt_disable(vdev);\n\tivpu_pm_schedule_recovery(vdev);\n}\n\nstatic void ivpu_hw_40xx_irq_noc_firewall_handler(struct ivpu_device *vdev)\n{\n\tivpu_pm_schedule_recovery(vdev);\n}\n\n \nstatic irqreturn_t ivpu_hw_40xx_irqv_handler(struct ivpu_device *vdev, int irq)\n{\n\tu32 status = REGV_RD32(VPU_40XX_HOST_SS_ICB_STATUS_0) & ICB_0_IRQ_MASK;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tREGV_WR32(VPU_40XX_HOST_SS_ICB_CLEAR_0, status);\n\n\tif (REG_TEST_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, MMU_IRQ_0_INT, status))\n\t\tivpu_mmu_irq_evtq_handler(vdev);\n\n\tif (REG_TEST_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, HOST_IPC_FIFO_INT, status))\n\t\tret |= ivpu_ipc_irq_handler(vdev);\n\n\tif (REG_TEST_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, MMU_IRQ_1_INT, status))\n\t\tivpu_dbg(vdev, IRQ, \"MMU sync complete\\n\");\n\n\tif (REG_TEST_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, MMU_IRQ_2_INT, status))\n\t\tivpu_mmu_irq_gerr_handler(vdev);\n\n\tif (REG_TEST_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, CPU_INT_REDIRECT_0_INT, status))\n\t\tivpu_hw_40xx_irq_wdt_mss_handler(vdev);\n\n\tif (REG_TEST_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, CPU_INT_REDIRECT_1_INT, status))\n\t\tivpu_hw_40xx_irq_wdt_nce_handler(vdev);\n\n\tif (REG_TEST_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, NOC_FIREWALL_INT, status))\n\t\tivpu_hw_40xx_irq_noc_firewall_handler(vdev);\n\n\treturn ret;\n}\n\n \nstatic irqreturn_t ivpu_hw_40xx_irqb_handler(struct ivpu_device *vdev, int irq)\n{\n\tbool schedule_recovery = false;\n\tu32 status = REGB_RD32(VPU_40XX_BUTTRESS_INTERRUPT_STAT) & BUTTRESS_IRQ_MASK;\n\n\tif (status == 0)\n\t\treturn IRQ_NONE;\n\n\tif (REG_TEST_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, FREQ_CHANGE, status))\n\t\tivpu_dbg(vdev, IRQ, \"FREQ_CHANGE\");\n\n\tif (REG_TEST_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, ATS_ERR, status)) {\n\t\tivpu_err(vdev, \"ATS_ERR LOG1 0x%08x ATS_ERR_LOG2 0x%08x\\n\",\n\t\t\t REGB_RD32(VPU_40XX_BUTTRESS_ATS_ERR_LOG1),\n\t\t\t REGB_RD32(VPU_40XX_BUTTRESS_ATS_ERR_LOG2));\n\t\tREGB_WR32(VPU_40XX_BUTTRESS_ATS_ERR_CLEAR, 0x1);\n\t\tschedule_recovery = true;\n\t}\n\n\tif (REG_TEST_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, CFI0_ERR, status)) {\n\t\tivpu_err(vdev, \"CFI0_ERR 0x%08x\", REGB_RD32(VPU_40XX_BUTTRESS_CFI0_ERR_LOG));\n\t\tREGB_WR32(VPU_40XX_BUTTRESS_CFI0_ERR_CLEAR, 0x1);\n\t\tschedule_recovery = true;\n\t}\n\n\tif (REG_TEST_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, CFI1_ERR, status)) {\n\t\tivpu_err(vdev, \"CFI1_ERR 0x%08x\", REGB_RD32(VPU_40XX_BUTTRESS_CFI1_ERR_LOG));\n\t\tREGB_WR32(VPU_40XX_BUTTRESS_CFI1_ERR_CLEAR, 0x1);\n\t\tschedule_recovery = true;\n\t}\n\n\tif (REG_TEST_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, IMR0_ERR, status)) {\n\t\tivpu_err(vdev, \"IMR_ERR_CFI0 LOW: 0x%08x HIGH: 0x%08x\",\n\t\t\t REGB_RD32(VPU_40XX_BUTTRESS_IMR_ERR_CFI0_LOW),\n\t\t\t REGB_RD32(VPU_40XX_BUTTRESS_IMR_ERR_CFI0_HIGH));\n\t\tREGB_WR32(VPU_40XX_BUTTRESS_IMR_ERR_CFI0_CLEAR, 0x1);\n\t\tschedule_recovery = true;\n\t}\n\n\tif (REG_TEST_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, IMR1_ERR, status)) {\n\t\tivpu_err(vdev, \"IMR_ERR_CFI1 LOW: 0x%08x HIGH: 0x%08x\",\n\t\t\t REGB_RD32(VPU_40XX_BUTTRESS_IMR_ERR_CFI1_LOW),\n\t\t\t REGB_RD32(VPU_40XX_BUTTRESS_IMR_ERR_CFI1_HIGH));\n\t\tREGB_WR32(VPU_40XX_BUTTRESS_IMR_ERR_CFI1_CLEAR, 0x1);\n\t\tschedule_recovery = true;\n\t}\n\n\tif (REG_TEST_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, SURV_ERR, status)) {\n\t\tivpu_err(vdev, \"Survivability error detected\\n\");\n\t\tschedule_recovery = true;\n\t}\n\n\t \n\tREGB_WR32(VPU_40XX_BUTTRESS_INTERRUPT_STAT, status);\n\n\tif (schedule_recovery)\n\t\tivpu_pm_schedule_recovery(vdev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ivpu_hw_40xx_irq_handler(int irq, void *ptr)\n{\n\tstruct ivpu_device *vdev = ptr;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tREGB_WR32(VPU_40XX_BUTTRESS_GLOBAL_INT_MASK, 0x1);\n\n\tret |= ivpu_hw_40xx_irqv_handler(vdev, irq);\n\tret |= ivpu_hw_40xx_irqb_handler(vdev, irq);\n\n\t \n\tREGB_WR32(VPU_40XX_BUTTRESS_GLOBAL_INT_MASK, 0x0);\n\n\tif (ret & IRQ_WAKE_THREAD)\n\t\treturn IRQ_WAKE_THREAD;\n\n\treturn ret;\n}\n\nstatic void ivpu_hw_40xx_diagnose_failure(struct ivpu_device *vdev)\n{\n\tu32 irqv = REGV_RD32(VPU_40XX_HOST_SS_ICB_STATUS_0) & ICB_0_IRQ_MASK;\n\tu32 irqb = REGB_RD32(VPU_40XX_BUTTRESS_INTERRUPT_STAT) & BUTTRESS_IRQ_MASK;\n\n\tif (ivpu_hw_40xx_reg_ipc_rx_count_get(vdev))\n\t\tivpu_err(vdev, \"IPC FIFO queue not empty, missed IPC IRQ\");\n\n\tif (REG_TEST_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, CPU_INT_REDIRECT_0_INT, irqv))\n\t\tivpu_err(vdev, \"WDT MSS timeout detected\\n\");\n\n\tif (REG_TEST_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, CPU_INT_REDIRECT_1_INT, irqv))\n\t\tivpu_err(vdev, \"WDT NCE timeout detected\\n\");\n\n\tif (REG_TEST_FLD(VPU_40XX_HOST_SS_ICB_STATUS_0, NOC_FIREWALL_INT, irqv))\n\t\tivpu_err(vdev, \"NOC Firewall irq detected\\n\");\n\n\tif (REG_TEST_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, ATS_ERR, irqb)) {\n\t\tivpu_err(vdev, \"ATS_ERR_LOG1 0x%08x ATS_ERR_LOG2 0x%08x\\n\",\n\t\t\t REGB_RD32(VPU_40XX_BUTTRESS_ATS_ERR_LOG1),\n\t\t\t REGB_RD32(VPU_40XX_BUTTRESS_ATS_ERR_LOG2));\n\t}\n\n\tif (REG_TEST_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, CFI0_ERR, irqb))\n\t\tivpu_err(vdev, \"CFI0_ERR_LOG 0x%08x\\n\", REGB_RD32(VPU_40XX_BUTTRESS_CFI0_ERR_LOG));\n\n\tif (REG_TEST_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, CFI1_ERR, irqb))\n\t\tivpu_err(vdev, \"CFI1_ERR_LOG 0x%08x\\n\", REGB_RD32(VPU_40XX_BUTTRESS_CFI1_ERR_LOG));\n\n\tif (REG_TEST_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, IMR0_ERR, irqb))\n\t\tivpu_err(vdev, \"IMR_ERR_CFI0 LOW: 0x%08x HIGH: 0x%08x\\n\",\n\t\t\t REGB_RD32(VPU_40XX_BUTTRESS_IMR_ERR_CFI0_LOW),\n\t\t\t REGB_RD32(VPU_40XX_BUTTRESS_IMR_ERR_CFI0_HIGH));\n\n\tif (REG_TEST_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, IMR1_ERR, irqb))\n\t\tivpu_err(vdev, \"IMR_ERR_CFI1 LOW: 0x%08x HIGH: 0x%08x\\n\",\n\t\t\t REGB_RD32(VPU_40XX_BUTTRESS_IMR_ERR_CFI1_LOW),\n\t\t\t REGB_RD32(VPU_40XX_BUTTRESS_IMR_ERR_CFI1_HIGH));\n\n\tif (REG_TEST_FLD(VPU_40XX_BUTTRESS_INTERRUPT_STAT, SURV_ERR, irqb))\n\t\tivpu_err(vdev, \"Survivability error detected\\n\");\n}\n\nconst struct ivpu_hw_ops ivpu_hw_40xx_ops = {\n\t.info_init = ivpu_hw_40xx_info_init,\n\t.power_up = ivpu_hw_40xx_power_up,\n\t.is_idle = ivpu_hw_40xx_is_idle,\n\t.power_down = ivpu_hw_40xx_power_down,\n\t.reset = ivpu_hw_40xx_reset,\n\t.boot_fw = ivpu_hw_40xx_boot_fw,\n\t.wdt_disable = ivpu_hw_40xx_wdt_disable,\n\t.diagnose_failure = ivpu_hw_40xx_diagnose_failure,\n\t.reg_pll_freq_get = ivpu_hw_40xx_reg_pll_freq_get,\n\t.reg_telemetry_offset_get = ivpu_hw_40xx_reg_telemetry_offset_get,\n\t.reg_telemetry_size_get = ivpu_hw_40xx_reg_telemetry_size_get,\n\t.reg_telemetry_enable_get = ivpu_hw_40xx_reg_telemetry_enable_get,\n\t.reg_db_set = ivpu_hw_40xx_reg_db_set,\n\t.reg_ipc_rx_addr_get = ivpu_hw_40xx_reg_ipc_rx_addr_get,\n\t.reg_ipc_rx_count_get = ivpu_hw_40xx_reg_ipc_rx_count_get,\n\t.reg_ipc_tx_set = ivpu_hw_40xx_reg_ipc_tx_set,\n\t.irq_clear = ivpu_hw_40xx_irq_clear,\n\t.irq_enable = ivpu_hw_40xx_irq_enable,\n\t.irq_disable = ivpu_hw_40xx_irq_disable,\n\t.irq_handler = ivpu_hw_40xx_irq_handler,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}