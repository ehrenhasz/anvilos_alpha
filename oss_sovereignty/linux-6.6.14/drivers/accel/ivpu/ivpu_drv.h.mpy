{
  "module_name": "ivpu_drv.h",
  "hash_id": "7ca0d0f1d3aafe3824e86c3bb5e760915efa9a497fe3a6e25f31cbcc62592ff0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/ivpu/ivpu_drv.h",
  "human_readable_source": " \n \n\n#ifndef __IVPU_DRV_H__\n#define __IVPU_DRV_H__\n\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_mm.h>\n#include <drm/drm_print.h>\n\n#include <linux/pci.h>\n#include <linux/xarray.h>\n#include <uapi/drm/ivpu_accel.h>\n\n#include \"ivpu_mmu_context.h\"\n\n#define DRIVER_NAME \"intel_vpu\"\n#define DRIVER_DESC \"Driver for Intel Versatile Processing Unit (VPU)\"\n#define DRIVER_DATE \"20230117\"\n\n#define PCI_DEVICE_ID_MTL   0x7d1d\n#define PCI_DEVICE_ID_ARL   0xad1d\n#define PCI_DEVICE_ID_LNL   0x643e\n\n#define IVPU_HW_37XX\t37\n#define IVPU_HW_40XX\t40\n\n#define IVPU_GLOBAL_CONTEXT_MMU_SSID 0\n \n#define IVPU_USER_CONTEXT_MIN_SSID   2\n#define IVPU_USER_CONTEXT_MAX_SSID   (IVPU_USER_CONTEXT_MIN_SSID + 63)\n\n#define IVPU_NUM_ENGINES\t     2\n\n#define IVPU_PLATFORM_SILICON 0\n#define IVPU_PLATFORM_SIMICS  2\n#define IVPU_PLATFORM_FPGA    3\n#define IVPU_PLATFORM_INVALID 8\n\n#define IVPU_DBG_REG\t BIT(0)\n#define IVPU_DBG_IRQ\t BIT(1)\n#define IVPU_DBG_MMU\t BIT(2)\n#define IVPU_DBG_FILE\t BIT(3)\n#define IVPU_DBG_MISC\t BIT(4)\n#define IVPU_DBG_FW_BOOT BIT(5)\n#define IVPU_DBG_PM\t BIT(6)\n#define IVPU_DBG_IPC\t BIT(7)\n#define IVPU_DBG_BO\t BIT(8)\n#define IVPU_DBG_JOB\t BIT(9)\n#define IVPU_DBG_JSM\t BIT(10)\n#define IVPU_DBG_KREF\t BIT(11)\n#define IVPU_DBG_RPM\t BIT(12)\n\n#define ivpu_err(vdev, fmt, ...) \\\n\tdrm_err(&(vdev)->drm, \"%s(): \" fmt, __func__, ##__VA_ARGS__)\n\n#define ivpu_err_ratelimited(vdev, fmt, ...) \\\n\tdrm_err_ratelimited(&(vdev)->drm, \"%s(): \" fmt, __func__, ##__VA_ARGS__)\n\n#define ivpu_warn(vdev, fmt, ...) \\\n\tdrm_warn(&(vdev)->drm, \"%s(): \" fmt, __func__, ##__VA_ARGS__)\n\n#define ivpu_warn_ratelimited(vdev, fmt, ...) \\\n\tdrm_err_ratelimited(&(vdev)->drm, \"%s(): \" fmt, __func__, ##__VA_ARGS__)\n\n#define ivpu_info(vdev, fmt, ...) drm_info(&(vdev)->drm, fmt, ##__VA_ARGS__)\n\n#define ivpu_dbg(vdev, type, fmt, args...) do {                                \\\n\tif (unlikely(IVPU_DBG_##type & ivpu_dbg_mask))                         \\\n\t\tdev_dbg((vdev)->drm.dev, \"[%s] \" fmt, #type, ##args);          \\\n} while (0)\n\n#define IVPU_WA(wa_name) (vdev->wa.wa_name)\n\n#define IVPU_PRINT_WA(wa_name) do {\t\t\t\t\t\\\n\tif (IVPU_WA(wa_name))\t\t\t\t\t\t\\\n\t\tivpu_dbg(vdev, MISC, \"Using WA: \" #wa_name \"\\n\");\t\\\n} while (0)\n\nstruct ivpu_wa_table {\n\tbool punit_disabled;\n\tbool clear_runtime_mem;\n\tbool d3hot_after_power_off;\n\tbool interrupt_clear_with_0;\n\tbool disable_clock_relinquish;\n};\n\nstruct ivpu_hw_info;\nstruct ivpu_mmu_info;\nstruct ivpu_fw_info;\nstruct ivpu_ipc_info;\nstruct ivpu_pm_info;\n\nstruct ivpu_device {\n\tstruct drm_device drm;\n\tvoid __iomem *regb;\n\tvoid __iomem *regv;\n\tu32 platform;\n\tu32 irq;\n\n\tstruct ivpu_wa_table wa;\n\tstruct ivpu_hw_info *hw;\n\tstruct ivpu_mmu_info *mmu;\n\tstruct ivpu_fw_info *fw;\n\tstruct ivpu_ipc_info *ipc;\n\tstruct ivpu_pm_info *pm;\n\n\tstruct ivpu_mmu_context gctx;\n\tstruct xarray context_xa;\n\tstruct xa_limit context_xa_limit;\n\n\tstruct xarray submitted_jobs_xa;\n\tstruct task_struct *job_done_thread;\n\n\tatomic64_t unique_id_counter;\n\n\tstruct {\n\t\tint boot;\n\t\tint jsm;\n\t\tint tdr;\n\t\tint reschedule_suspend;\n\t} timeout;\n};\n\n \nstruct ivpu_file_priv {\n\tstruct kref ref;\n\tstruct ivpu_device *vdev;\n\tstruct mutex lock;  \n\tstruct ivpu_cmdq *cmdq[IVPU_NUM_ENGINES];\n\tstruct ivpu_mmu_context ctx;\n\tu32 priority;\n\tbool has_mmu_faults;\n};\n\nextern int ivpu_dbg_mask;\nextern u8 ivpu_pll_min_ratio;\nextern u8 ivpu_pll_max_ratio;\nextern bool ivpu_disable_mmu_cont_pages;\n\n#define IVPU_TEST_MODE_DISABLED  0\n#define IVPU_TEST_MODE_FW_TEST   1\n#define IVPU_TEST_MODE_NULL_HW   2\nextern int ivpu_test_mode;\n\nstruct ivpu_file_priv *ivpu_file_priv_get(struct ivpu_file_priv *file_priv);\nstruct ivpu_file_priv *ivpu_file_priv_get_by_ctx_id(struct ivpu_device *vdev, unsigned long id);\nvoid ivpu_file_priv_put(struct ivpu_file_priv **link);\n\nint ivpu_boot(struct ivpu_device *vdev);\nint ivpu_shutdown(struct ivpu_device *vdev);\nvoid ivpu_prepare_for_reset(struct ivpu_device *vdev);\n\nstatic inline u8 ivpu_revision(struct ivpu_device *vdev)\n{\n\treturn to_pci_dev(vdev->drm.dev)->revision;\n}\n\nstatic inline u16 ivpu_device_id(struct ivpu_device *vdev)\n{\n\treturn to_pci_dev(vdev->drm.dev)->device;\n}\n\nstatic inline int ivpu_hw_gen(struct ivpu_device *vdev)\n{\n\tswitch (ivpu_device_id(vdev)) {\n\tcase PCI_DEVICE_ID_MTL:\n\tcase PCI_DEVICE_ID_ARL:\n\t\treturn IVPU_HW_37XX;\n\tcase PCI_DEVICE_ID_LNL:\n\t\treturn IVPU_HW_40XX;\n\tdefault:\n\t\tivpu_err(vdev, \"Unknown VPU device\\n\");\n\t\treturn 0;\n\t}\n}\n\nstatic inline struct ivpu_device *to_ivpu_device(struct drm_device *dev)\n{\n\treturn container_of(dev, struct ivpu_device, drm);\n}\n\nstatic inline u32 ivpu_get_context_count(struct ivpu_device *vdev)\n{\n\tstruct xa_limit ctx_limit = vdev->context_xa_limit;\n\n\treturn (ctx_limit.max - ctx_limit.min + 1);\n}\n\nstatic inline u32 ivpu_get_platform(struct ivpu_device *vdev)\n{\n\tWARN_ON_ONCE(vdev->platform == IVPU_PLATFORM_INVALID);\n\treturn vdev->platform;\n}\n\nstatic inline bool ivpu_is_silicon(struct ivpu_device *vdev)\n{\n\treturn ivpu_get_platform(vdev) == IVPU_PLATFORM_SILICON;\n}\n\nstatic inline bool ivpu_is_simics(struct ivpu_device *vdev)\n{\n\treturn ivpu_get_platform(vdev) == IVPU_PLATFORM_SIMICS;\n}\n\nstatic inline bool ivpu_is_fpga(struct ivpu_device *vdev)\n{\n\treturn ivpu_get_platform(vdev) == IVPU_PLATFORM_FPGA;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}