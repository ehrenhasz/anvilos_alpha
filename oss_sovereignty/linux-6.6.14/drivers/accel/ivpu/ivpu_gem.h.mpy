{
  "module_name": "ivpu_gem.h",
  "hash_id": "65307da13d4c9d48be72e3f1f418494f1f18681cfc127cc2b6139ef75913078e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/ivpu/ivpu_gem.h",
  "human_readable_source": " \n \n#ifndef __IVPU_GEM_H__\n#define __IVPU_GEM_H__\n\n#include <drm/drm_gem.h>\n#include <drm/drm_mm.h>\n\nstruct dma_buf;\nstruct ivpu_bo_ops;\nstruct ivpu_file_priv;\n\nstruct ivpu_bo {\n\tstruct drm_gem_object base;\n\tconst struct ivpu_bo_ops *ops;\n\n\tstruct ivpu_mmu_context *ctx;\n\tstruct list_head ctx_node;\n\tstruct drm_mm_node mm_node;\n\n\tstruct mutex lock;  \n\tstruct sg_table *sgt;\n\tstruct page **pages;\n\tbool mmu_mapped;\n\n\tvoid *kvaddr;\n\tu64 vpu_addr;\n\tu32 handle;\n\tu32 flags;\n\tuintptr_t user_ptr;\n\tu32 job_status;\n};\n\nenum ivpu_bo_type {\n\tIVPU_BO_TYPE_SHMEM = 1,\n\tIVPU_BO_TYPE_INTERNAL,\n\tIVPU_BO_TYPE_PRIME,\n};\n\nstruct ivpu_bo_ops {\n\tenum ivpu_bo_type type;\n\tconst char *name;\n\tint (*alloc_pages)(struct ivpu_bo *bo);\n\tvoid (*free_pages)(struct ivpu_bo *bo);\n\tint (*map_pages)(struct ivpu_bo *bo);\n\tvoid (*unmap_pages)(struct ivpu_bo *bo);\n};\n\nint ivpu_bo_pin(struct ivpu_bo *bo);\nvoid ivpu_bo_remove_all_bos_from_context(struct ivpu_mmu_context *ctx);\nvoid ivpu_bo_list(struct drm_device *dev, struct drm_printer *p);\nvoid ivpu_bo_list_print(struct drm_device *dev);\n\nstruct ivpu_bo *\nivpu_bo_alloc_internal(struct ivpu_device *vdev, u64 vpu_addr, u64 size, u32 flags);\nvoid ivpu_bo_free_internal(struct ivpu_bo *bo);\nstruct drm_gem_object *ivpu_gem_prime_import(struct drm_device *dev, struct dma_buf *dma_buf);\nvoid ivpu_bo_unmap_sgt_and_remove_from_context(struct ivpu_bo *bo);\n\nint ivpu_bo_create_ioctl(struct drm_device *dev, void *data, struct drm_file *file);\nint ivpu_bo_info_ioctl(struct drm_device *dev, void *data, struct drm_file *file);\nint ivpu_bo_wait_ioctl(struct drm_device *dev, void *data, struct drm_file *file);\n\nstatic inline struct ivpu_bo *to_ivpu_bo(struct drm_gem_object *obj)\n{\n\treturn container_of(obj, struct ivpu_bo, base);\n}\n\nstatic inline struct page *ivpu_bo_get_page(struct ivpu_bo *bo, u64 offset)\n{\n\tif (offset > bo->base.size || !bo->pages)\n\t\treturn NULL;\n\n\treturn bo->pages[offset / PAGE_SIZE];\n}\n\nstatic inline u32 ivpu_bo_cache_mode(struct ivpu_bo *bo)\n{\n\treturn bo->flags & DRM_IVPU_BO_CACHE_MASK;\n}\n\nstatic inline bool ivpu_bo_is_snooped(struct ivpu_bo *bo)\n{\n\treturn ivpu_bo_cache_mode(bo) == DRM_IVPU_BO_CACHED;\n}\n\nstatic inline pgprot_t ivpu_bo_pgprot(struct ivpu_bo *bo, pgprot_t prot)\n{\n\tif (bo->flags & DRM_IVPU_BO_WC)\n\t\treturn pgprot_writecombine(prot);\n\n\tif (bo->flags & DRM_IVPU_BO_UNCACHED)\n\t\treturn pgprot_noncached(prot);\n\n\treturn prot;\n}\n\nstatic inline struct ivpu_device *ivpu_bo_to_vdev(struct ivpu_bo *bo)\n{\n\treturn to_ivpu_device(bo->base.dev);\n}\n\nstatic inline void *ivpu_to_cpu_addr(struct ivpu_bo *bo, u32 vpu_addr)\n{\n\tif (vpu_addr < bo->vpu_addr)\n\t\treturn NULL;\n\n\tif (vpu_addr >= (bo->vpu_addr + bo->base.size))\n\t\treturn NULL;\n\n\treturn bo->kvaddr + (vpu_addr - bo->vpu_addr);\n}\n\nstatic inline u32 cpu_to_vpu_addr(struct ivpu_bo *bo, void *cpu_addr)\n{\n\tif (cpu_addr < bo->kvaddr)\n\t\treturn 0;\n\n\tif (cpu_addr >= (bo->kvaddr + bo->base.size))\n\t\treturn 0;\n\n\treturn bo->vpu_addr + (cpu_addr - bo->kvaddr);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}