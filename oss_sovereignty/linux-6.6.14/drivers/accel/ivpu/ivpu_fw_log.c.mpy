{
  "module_name": "ivpu_fw_log.c",
  "hash_id": "76b70f594b211a5a49d4e8bfd3f0b0ec86d382540a7ed6f7c62599074b6e268c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/ivpu/ivpu_fw_log.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/moduleparam.h>\n\n#include \"vpu_boot_api.h\"\n#include \"ivpu_drv.h\"\n#include \"ivpu_fw.h\"\n#include \"ivpu_fw_log.h\"\n#include \"ivpu_gem.h\"\n\n#define IVPU_FW_LOG_LINE_LENGTH\t  256\n\nunsigned int ivpu_log_level = IVPU_FW_LOG_ERROR;\nmodule_param(ivpu_log_level, uint, 0444);\nMODULE_PARM_DESC(ivpu_log_level,\n\t\t \"VPU firmware default trace level: debug=\" __stringify(IVPU_FW_LOG_DEBUG)\n\t\t \" info=\" __stringify(IVPU_FW_LOG_INFO)\n\t\t \" warn=\" __stringify(IVPU_FW_LOG_WARN)\n\t\t \" error=\" __stringify(IVPU_FW_LOG_ERROR)\n\t\t \" fatal=\" __stringify(IVPU_FW_LOG_FATAL));\n\nstatic int fw_log_ptr(struct ivpu_device *vdev, struct ivpu_bo *bo, u32 *offset,\n\t\t      struct vpu_tracing_buffer_header **log_header)\n{\n\tstruct vpu_tracing_buffer_header *log;\n\n\tif ((*offset + sizeof(*log)) > bo->base.size)\n\t\treturn -EINVAL;\n\n\tlog = bo->kvaddr + *offset;\n\n\tif (log->vpu_canary_start != VPU_TRACING_BUFFER_CANARY)\n\t\treturn -EINVAL;\n\n\tif (log->header_size < sizeof(*log) || log->header_size > 1024) {\n\t\tivpu_dbg(vdev, FW_BOOT, \"Invalid header size 0x%x\\n\", log->header_size);\n\t\treturn -EINVAL;\n\t}\n\tif ((char *)log + log->size > (char *)bo->kvaddr + bo->base.size) {\n\t\tivpu_dbg(vdev, FW_BOOT, \"Invalid log size 0x%x\\n\", log->size);\n\t\treturn -EINVAL;\n\t}\n\n\t*log_header = log;\n\t*offset += log->size;\n\n\tivpu_dbg(vdev, FW_BOOT,\n\t\t \"FW log name \\\"%s\\\", write offset 0x%x size 0x%x, wrap count %d, hdr version %d size %d format %d, alignment %d\",\n\t\t log->name, log->write_index, log->size, log->wrap_count, log->header_version,\n\t\t log->header_size, log->format, log->alignment);\n\n\treturn 0;\n}\n\nstatic void buffer_print(char *buffer, u32 size, struct drm_printer *p)\n{\n\tchar line[IVPU_FW_LOG_LINE_LENGTH];\n\tu32 index = 0;\n\n\tif (!size || !buffer)\n\t\treturn;\n\n\twhile (size--) {\n\t\tif (*buffer == '\\n' || *buffer == 0) {\n\t\t\tline[index] = 0;\n\t\t\tif (index != 0)\n\t\t\t\tdrm_printf(p, \"%s\\n\", line);\n\t\t\tindex = 0;\n\t\t\tbuffer++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (index == IVPU_FW_LOG_LINE_LENGTH - 1) {\n\t\t\tline[index] = 0;\n\t\t\tindex = 0;\n\t\t\tdrm_printf(p, \"%s\\n\", line);\n\t\t}\n\t\tif (*buffer != '\\r' && (isprint(*buffer) || iscntrl(*buffer)))\n\t\t\tline[index++] = *buffer;\n\t\tbuffer++;\n\t}\n\tline[index] = 0;\n\tif (index != 0)\n\t\tdrm_printf(p, \"%s\\n\", line);\n}\n\nstatic void fw_log_print_buffer(struct ivpu_device *vdev, struct vpu_tracing_buffer_header *log,\n\t\t\t\tconst char *prefix, bool only_new_msgs, struct drm_printer *p)\n{\n\tchar *log_buffer = (void *)log + log->header_size;\n\tu32 log_size = log->size - log->header_size;\n\tu32 log_start = log->read_index;\n\tu32 log_end = log->write_index;\n\n\tif (!(log->write_index || log->wrap_count) ||\n\t    (log->write_index == log->read_index && only_new_msgs)) {\n\t\tdrm_printf(p, \"==== %s \\\"%s\\\" log empty ====\\n\", prefix, log->name);\n\t\treturn;\n\t}\n\n\tdrm_printf(p, \"==== %s \\\"%s\\\" log start ====\\n\", prefix, log->name);\n\tif (log->write_index > log->read_index) {\n\t\tbuffer_print(log_buffer + log_start, log_end - log_start, p);\n\t} else {\n\t\tbuffer_print(log_buffer + log_end, log_size - log_end, p);\n\t\tbuffer_print(log_buffer, log_end, p);\n\t}\n\tdrm_printf(p, \"\\x1b[0m\");\n\tdrm_printf(p, \"==== %s \\\"%s\\\" log end   ====\\n\", prefix, log->name);\n}\n\nvoid ivpu_fw_log_print(struct ivpu_device *vdev, bool only_new_msgs, struct drm_printer *p)\n{\n\tstruct vpu_tracing_buffer_header *log_header;\n\tu32 next = 0;\n\n\twhile (fw_log_ptr(vdev, vdev->fw->mem_log_crit, &next, &log_header) == 0)\n\t\tfw_log_print_buffer(vdev, log_header, \"VPU critical\", only_new_msgs, p);\n\n\tnext = 0;\n\twhile (fw_log_ptr(vdev, vdev->fw->mem_log_verb, &next, &log_header) == 0)\n\t\tfw_log_print_buffer(vdev, log_header, \"VPU verbose\", only_new_msgs, p);\n}\n\nvoid ivpu_fw_log_clear(struct ivpu_device *vdev)\n{\n\tstruct vpu_tracing_buffer_header *log_header;\n\tu32 next = 0;\n\n\twhile (fw_log_ptr(vdev, vdev->fw->mem_log_crit, &next, &log_header) == 0)\n\t\tlog_header->read_index = log_header->write_index;\n\n\tnext = 0;\n\twhile (fw_log_ptr(vdev, vdev->fw->mem_log_verb, &next, &log_header) == 0)\n\t\tlog_header->read_index = log_header->write_index;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}