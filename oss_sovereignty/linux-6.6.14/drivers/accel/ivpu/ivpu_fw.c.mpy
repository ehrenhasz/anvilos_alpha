{
  "module_name": "ivpu_fw.c",
  "hash_id": "3af2e85f0b4ae11b0847ab77392573ff2fe24534afac49eb380d78d5fbaaeee4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/ivpu/ivpu_fw.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/highmem.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n\n#include \"vpu_boot_api.h\"\n#include \"ivpu_drv.h\"\n#include \"ivpu_fw.h\"\n#include \"ivpu_fw_log.h\"\n#include \"ivpu_gem.h\"\n#include \"ivpu_hw.h\"\n#include \"ivpu_ipc.h\"\n#include \"ivpu_pm.h\"\n\n#define FW_GLOBAL_MEM_START\t(2ull * SZ_1G)\n#define FW_GLOBAL_MEM_END\t(3ull * SZ_1G)\n#define FW_SHARED_MEM_SIZE\tSZ_256M  \n#define FW_SHARED_MEM_ALIGNMENT\tSZ_128K  \n#define FW_RUNTIME_MAX_SIZE\tSZ_512M\n#define FW_SHAVE_NN_MAX_SIZE\tSZ_2M\n#define FW_RUNTIME_MIN_ADDR\t(FW_GLOBAL_MEM_START)\n#define FW_RUNTIME_MAX_ADDR\t(FW_GLOBAL_MEM_END - FW_SHARED_MEM_SIZE)\n#define FW_VERSION_HEADER_SIZE\tSZ_4K\n#define FW_FILE_IMAGE_OFFSET\t(VPU_FW_HEADER_SIZE + FW_VERSION_HEADER_SIZE)\n\n#define WATCHDOG_MSS_REDIRECT\t32\n#define WATCHDOG_NCE_REDIRECT\t33\n\n#define ADDR_TO_L2_CACHE_CFG(addr) ((addr) >> 31)\n\n#define IVPU_FW_CHECK_API(vdev, fw_hdr, name, min_major) \\\n\tivpu_fw_check_api(vdev, fw_hdr, #name, \\\n\t\t\t  VPU_##name##_API_VER_INDEX, \\\n\t\t\t  VPU_##name##_API_VER_MAJOR, \\\n\t\t\t  VPU_##name##_API_VER_MINOR, min_major)\n\nstatic char *ivpu_firmware;\nmodule_param_named_unsafe(firmware, ivpu_firmware, charp, 0644);\nMODULE_PARM_DESC(firmware, \"VPU firmware binary in /lib/firmware/..\");\n\n \nstatic struct {\n\tint gen;\n\tconst char *name;\n} fw_names[] = {\n\t{ IVPU_HW_37XX, \"vpu_37xx.bin\" },\n\t{ IVPU_HW_37XX, \"mtl_vpu.bin\" },\n\t{ IVPU_HW_37XX, \"intel/vpu/vpu_37xx_v0.0.bin\" },\n\t{ IVPU_HW_40XX, \"vpu_40xx.bin\" },\n\t{ IVPU_HW_40XX, \"intel/vpu/vpu_40xx_v0.0.bin\" },\n};\n\nstatic int ivpu_fw_request(struct ivpu_device *vdev)\n{\n\tint ret = -ENOENT;\n\tint i;\n\n\tif (ivpu_firmware) {\n\t\tret = request_firmware(&vdev->fw->file, ivpu_firmware, vdev->drm.dev);\n\t\tif (!ret)\n\t\t\tvdev->fw->name = ivpu_firmware;\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(fw_names); i++) {\n\t\tif (fw_names[i].gen != ivpu_hw_gen(vdev))\n\t\t\tcontinue;\n\n\t\tret = firmware_request_nowarn(&vdev->fw->file, fw_names[i].name, vdev->drm.dev);\n\t\tif (!ret) {\n\t\t\tvdev->fw->name = fw_names[i].name;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tivpu_err(vdev, \"Failed to request firmware: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int\nivpu_fw_check_api(struct ivpu_device *vdev, const struct vpu_firmware_header *fw_hdr,\n\t\t  const char *str, int index, u16 expected_major, u16 expected_minor,\n\t\t  u16 min_major)\n{\n\tu16 major = (u16)(fw_hdr->api_version[index] >> 16);\n\tu16 minor = (u16)(fw_hdr->api_version[index]);\n\n\tif (major < min_major) {\n\t\tivpu_err(vdev, \"Incompatible FW %s API version: %d.%d, required %d.0 or later\\n\",\n\t\t\t str, major, minor, min_major);\n\t\treturn -EINVAL;\n\t}\n\tif (major != expected_major) {\n\t\tivpu_warn(vdev, \"Major FW %s API version different: %d.%d (expected %d.%d)\\n\",\n\t\t\t  str, major, minor, expected_major, expected_minor);\n\t}\n\tivpu_dbg(vdev, FW_BOOT, \"FW %s API version: %d.%d (expected %d.%d)\\n\",\n\t\t str, major, minor, expected_major, expected_minor);\n\n\treturn 0;\n}\n\nstatic int ivpu_fw_parse(struct ivpu_device *vdev)\n{\n\tstruct ivpu_fw_info *fw = vdev->fw;\n\tconst struct vpu_firmware_header *fw_hdr = (const void *)fw->file->data;\n\tu64 runtime_addr, image_load_addr, runtime_size, image_size;\n\n\tif (fw->file->size <= FW_FILE_IMAGE_OFFSET) {\n\t\tivpu_err(vdev, \"Firmware file is too small: %zu\\n\", fw->file->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fw_hdr->header_version != VPU_FW_HEADER_VERSION) {\n\t\tivpu_err(vdev, \"Invalid firmware header version: %u\\n\", fw_hdr->header_version);\n\t\treturn -EINVAL;\n\t}\n\n\truntime_addr = fw_hdr->boot_params_load_address;\n\truntime_size = fw_hdr->runtime_size;\n\timage_load_addr = fw_hdr->image_load_address;\n\timage_size = fw_hdr->image_size;\n\n\tif (runtime_addr < FW_RUNTIME_MIN_ADDR || runtime_addr > FW_RUNTIME_MAX_ADDR) {\n\t\tivpu_err(vdev, \"Invalid firmware runtime address: 0x%llx\\n\", runtime_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tif (runtime_size < fw->file->size || runtime_size > FW_RUNTIME_MAX_SIZE) {\n\t\tivpu_err(vdev, \"Invalid firmware runtime size: %llu\\n\", runtime_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (FW_FILE_IMAGE_OFFSET + image_size > fw->file->size) {\n\t\tivpu_err(vdev, \"Invalid image size: %llu\\n\", image_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (image_load_addr < runtime_addr ||\n\t    image_load_addr + image_size > runtime_addr + runtime_size) {\n\t\tivpu_err(vdev, \"Invalid firmware load address size: 0x%llx and size %llu\\n\",\n\t\t\t image_load_addr, image_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fw_hdr->shave_nn_fw_size > FW_SHAVE_NN_MAX_SIZE) {\n\t\tivpu_err(vdev, \"SHAVE NN firmware is too big: %u\\n\", fw_hdr->shave_nn_fw_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fw_hdr->entry_point < image_load_addr ||\n\t    fw_hdr->entry_point >= image_load_addr + image_size) {\n\t\tivpu_err(vdev, \"Invalid entry point: 0x%llx\\n\", fw_hdr->entry_point);\n\t\treturn -EINVAL;\n\t}\n\tivpu_dbg(vdev, FW_BOOT, \"Header version: 0x%x, format 0x%x\\n\",\n\t\t fw_hdr->header_version, fw_hdr->image_format);\n\n\tivpu_info(vdev, \"Firmware: %s, version: %s\", fw->name,\n\t\t  (const char *)fw_hdr + VPU_FW_HEADER_SIZE);\n\n\tif (IVPU_FW_CHECK_API(vdev, fw_hdr, BOOT, 3))\n\t\treturn -EINVAL;\n\tif (IVPU_FW_CHECK_API(vdev, fw_hdr, JSM, 3))\n\t\treturn -EINVAL;\n\n\tfw->runtime_addr = runtime_addr;\n\tfw->runtime_size = runtime_size;\n\tfw->image_load_offset = image_load_addr - runtime_addr;\n\tfw->image_size = image_size;\n\tfw->shave_nn_size = PAGE_ALIGN(fw_hdr->shave_nn_fw_size);\n\n\tfw->cold_boot_entry_point = fw_hdr->entry_point;\n\tfw->entry_point = fw->cold_boot_entry_point;\n\n\tfw->trace_level = min_t(u32, ivpu_log_level, IVPU_FW_LOG_FATAL);\n\tfw->trace_destination_mask = VPU_TRACE_DESTINATION_VERBOSE_TRACING;\n\tfw->trace_hw_component_mask = -1;\n\n\tivpu_dbg(vdev, FW_BOOT, \"Size: file %lu image %u runtime %u shavenn %u\\n\",\n\t\t fw->file->size, fw->image_size, fw->runtime_size, fw->shave_nn_size);\n\tivpu_dbg(vdev, FW_BOOT, \"Address: runtime 0x%llx, load 0x%llx, entry point 0x%llx\\n\",\n\t\t fw->runtime_addr, image_load_addr, fw->entry_point);\n\n\treturn 0;\n}\n\nstatic void ivpu_fw_release(struct ivpu_device *vdev)\n{\n\trelease_firmware(vdev->fw->file);\n}\n\nstatic int ivpu_fw_update_global_range(struct ivpu_device *vdev)\n{\n\tstruct ivpu_fw_info *fw = vdev->fw;\n\tu64 start = ALIGN(fw->runtime_addr + fw->runtime_size, FW_SHARED_MEM_ALIGNMENT);\n\tu64 size = FW_SHARED_MEM_SIZE;\n\n\tif (start + size > FW_GLOBAL_MEM_END) {\n\t\tivpu_err(vdev, \"No space for shared region, start %lld, size %lld\\n\", start, size);\n\t\treturn -EINVAL;\n\t}\n\n\tivpu_hw_init_range(&vdev->hw->ranges.global, start, size);\n\treturn 0;\n}\n\nstatic int ivpu_fw_mem_init(struct ivpu_device *vdev)\n{\n\tstruct ivpu_fw_info *fw = vdev->fw;\n\tint log_verb_size;\n\tint ret;\n\n\tret = ivpu_fw_update_global_range(vdev);\n\tif (ret)\n\t\treturn ret;\n\n\tfw->mem = ivpu_bo_alloc_internal(vdev, fw->runtime_addr, fw->runtime_size, DRM_IVPU_BO_WC);\n\tif (!fw->mem) {\n\t\tivpu_err(vdev, \"Failed to allocate firmware runtime memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfw->mem_log_crit = ivpu_bo_alloc_internal(vdev, 0, IVPU_FW_CRITICAL_BUFFER_SIZE,\n\t\t\t\t\t\t  DRM_IVPU_BO_CACHED);\n\tif (!fw->mem_log_crit) {\n\t\tivpu_err(vdev, \"Failed to allocate critical log buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_fw_mem;\n\t}\n\n\tif (ivpu_log_level <= IVPU_FW_LOG_INFO)\n\t\tlog_verb_size = IVPU_FW_VERBOSE_BUFFER_LARGE_SIZE;\n\telse\n\t\tlog_verb_size = IVPU_FW_VERBOSE_BUFFER_SMALL_SIZE;\n\n\tfw->mem_log_verb = ivpu_bo_alloc_internal(vdev, 0, log_verb_size, DRM_IVPU_BO_CACHED);\n\tif (!fw->mem_log_verb) {\n\t\tivpu_err(vdev, \"Failed to allocate verbose log buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_log_crit;\n\t}\n\n\tif (fw->shave_nn_size) {\n\t\tfw->mem_shave_nn = ivpu_bo_alloc_internal(vdev, vdev->hw->ranges.shave.start,\n\t\t\t\t\t\t\t  fw->shave_nn_size, DRM_IVPU_BO_UNCACHED);\n\t\tif (!fw->mem_shave_nn) {\n\t\t\tivpu_err(vdev, \"Failed to allocate shavenn buffer\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_log_verb;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_free_log_verb:\n\tivpu_bo_free_internal(fw->mem_log_verb);\nerr_free_log_crit:\n\tivpu_bo_free_internal(fw->mem_log_crit);\nerr_free_fw_mem:\n\tivpu_bo_free_internal(fw->mem);\n\treturn ret;\n}\n\nstatic void ivpu_fw_mem_fini(struct ivpu_device *vdev)\n{\n\tstruct ivpu_fw_info *fw = vdev->fw;\n\n\tif (fw->mem_shave_nn) {\n\t\tivpu_bo_free_internal(fw->mem_shave_nn);\n\t\tfw->mem_shave_nn = NULL;\n\t}\n\n\tivpu_bo_free_internal(fw->mem_log_verb);\n\tivpu_bo_free_internal(fw->mem_log_crit);\n\tivpu_bo_free_internal(fw->mem);\n\n\tfw->mem_log_verb = NULL;\n\tfw->mem_log_crit = NULL;\n\tfw->mem = NULL;\n}\n\nint ivpu_fw_init(struct ivpu_device *vdev)\n{\n\tint ret;\n\n\tret = ivpu_fw_request(vdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ivpu_fw_parse(vdev);\n\tif (ret)\n\t\tgoto err_fw_release;\n\n\tret = ivpu_fw_mem_init(vdev);\n\tif (ret)\n\t\tgoto err_fw_release;\n\n\treturn 0;\n\nerr_fw_release:\n\tivpu_fw_release(vdev);\n\treturn ret;\n}\n\nvoid ivpu_fw_fini(struct ivpu_device *vdev)\n{\n\tivpu_fw_mem_fini(vdev);\n\tivpu_fw_release(vdev);\n}\n\nint ivpu_fw_load(struct ivpu_device *vdev)\n{\n\tstruct ivpu_fw_info *fw = vdev->fw;\n\tu64 image_end_offset = fw->image_load_offset + fw->image_size;\n\n\tmemset(fw->mem->kvaddr, 0, fw->image_load_offset);\n\tmemcpy(fw->mem->kvaddr + fw->image_load_offset,\n\t       fw->file->data + FW_FILE_IMAGE_OFFSET, fw->image_size);\n\n\tif (IVPU_WA(clear_runtime_mem)) {\n\t\tu8 *start = fw->mem->kvaddr + image_end_offset;\n\t\tu64 size = fw->mem->base.size - image_end_offset;\n\n\t\tmemset(start, 0, size);\n\t}\n\n\twmb();  \n\n\treturn 0;\n}\n\nstatic void ivpu_fw_boot_params_print(struct ivpu_device *vdev, struct vpu_boot_params *boot_params)\n{\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.magic = 0x%x\\n\",\n\t\t boot_params->magic);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.vpu_id = 0x%x\\n\",\n\t\t boot_params->vpu_id);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.vpu_count = 0x%x\\n\",\n\t\t boot_params->vpu_count);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.frequency = %u\\n\",\n\t\t boot_params->frequency);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.perf_clk_frequency = %u\\n\",\n\t\t boot_params->perf_clk_frequency);\n\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.ipc_header_area_start = 0x%llx\\n\",\n\t\t boot_params->ipc_header_area_start);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.ipc_header_area_size = 0x%x\\n\",\n\t\t boot_params->ipc_header_area_size);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.shared_region_base = 0x%llx\\n\",\n\t\t boot_params->shared_region_base);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.shared_region_size = 0x%x\\n\",\n\t\t boot_params->shared_region_size);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.ipc_payload_area_start = 0x%llx\\n\",\n\t\t boot_params->ipc_payload_area_start);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.ipc_payload_area_size = 0x%x\\n\",\n\t\t boot_params->ipc_payload_area_size);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.global_aliased_pio_base = 0x%llx\\n\",\n\t\t boot_params->global_aliased_pio_base);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.global_aliased_pio_size = 0x%x\\n\",\n\t\t boot_params->global_aliased_pio_size);\n\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.autoconfig = 0x%x\\n\",\n\t\t boot_params->autoconfig);\n\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.cache_defaults[VPU_BOOT_L2_CACHE_CFG_NN].use = 0x%x\\n\",\n\t\t boot_params->cache_defaults[VPU_BOOT_L2_CACHE_CFG_NN].use);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.cache_defaults[VPU_BOOT_L2_CACHE_CFG_NN].cfg = 0x%x\\n\",\n\t\t boot_params->cache_defaults[VPU_BOOT_L2_CACHE_CFG_NN].cfg);\n\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.global_memory_allocator_base = 0x%llx\\n\",\n\t\t boot_params->global_memory_allocator_base);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.global_memory_allocator_size = 0x%x\\n\",\n\t\t boot_params->global_memory_allocator_size);\n\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.shave_nn_fw_base = 0x%llx\\n\",\n\t\t boot_params->shave_nn_fw_base);\n\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.watchdog_irq_mss = 0x%x\\n\",\n\t\t boot_params->watchdog_irq_mss);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.watchdog_irq_nce = 0x%x\\n\",\n\t\t boot_params->watchdog_irq_nce);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.host_to_vpu_irq = 0x%x\\n\",\n\t\t boot_params->host_to_vpu_irq);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.job_done_irq = 0x%x\\n\",\n\t\t boot_params->job_done_irq);\n\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.host_version_id = 0x%x\\n\",\n\t\t boot_params->host_version_id);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.si_stepping = 0x%x\\n\",\n\t\t boot_params->si_stepping);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.device_id = 0x%llx\\n\",\n\t\t boot_params->device_id);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.feature_exclusion = 0x%llx\\n\",\n\t\t boot_params->feature_exclusion);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.sku = 0x%llx\\n\",\n\t\t boot_params->sku);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.min_freq_pll_ratio = 0x%x\\n\",\n\t\t boot_params->min_freq_pll_ratio);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.pn_freq_pll_ratio = 0x%x\\n\",\n\t\t boot_params->pn_freq_pll_ratio);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.max_freq_pll_ratio = 0x%x\\n\",\n\t\t boot_params->max_freq_pll_ratio);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.default_trace_level = 0x%x\\n\",\n\t\t boot_params->default_trace_level);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.tracing_buff_message_format_mask = 0x%llx\\n\",\n\t\t boot_params->tracing_buff_message_format_mask);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.trace_destination_mask = 0x%x\\n\",\n\t\t boot_params->trace_destination_mask);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.trace_hw_component_mask = 0x%llx\\n\",\n\t\t boot_params->trace_hw_component_mask);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.boot_type = 0x%x\\n\",\n\t\t boot_params->boot_type);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.punit_telemetry_sram_base = 0x%llx\\n\",\n\t\t boot_params->punit_telemetry_sram_base);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.punit_telemetry_sram_size = 0x%llx\\n\",\n\t\t boot_params->punit_telemetry_sram_size);\n\tivpu_dbg(vdev, FW_BOOT, \"boot_params.vpu_telemetry_enable = 0x%x\\n\",\n\t\t boot_params->vpu_telemetry_enable);\n}\n\nvoid ivpu_fw_boot_params_setup(struct ivpu_device *vdev, struct vpu_boot_params *boot_params)\n{\n\tstruct ivpu_bo *ipc_mem_rx = vdev->ipc->mem_rx;\n\n\t \n\tif (!ivpu_fw_is_cold_boot(vdev)) {\n\t\tboot_params->save_restore_ret_address = 0;\n\t\tvdev->pm->is_warmboot = true;\n\t\twmb();  \n\t\treturn;\n\t}\n\n\tvdev->pm->is_warmboot = false;\n\n\tboot_params->magic = VPU_BOOT_PARAMS_MAGIC;\n\tboot_params->vpu_id = to_pci_dev(vdev->drm.dev)->bus->number;\n\tboot_params->frequency = ivpu_hw_reg_pll_freq_get(vdev);\n\n\t \n\tboot_params->shared_region_base = vdev->hw->ranges.global.start;\n\tboot_params->shared_region_size = vdev->hw->ranges.global.end -\n\t\t\t\t\t  vdev->hw->ranges.global.start;\n\n\tboot_params->ipc_header_area_start = ipc_mem_rx->vpu_addr;\n\tboot_params->ipc_header_area_size = ipc_mem_rx->base.size / 2;\n\n\tboot_params->ipc_payload_area_start = ipc_mem_rx->vpu_addr + ipc_mem_rx->base.size / 2;\n\tboot_params->ipc_payload_area_size = ipc_mem_rx->base.size / 2;\n\n\tboot_params->global_aliased_pio_base = vdev->hw->ranges.user.start;\n\tboot_params->global_aliased_pio_size = ivpu_hw_range_size(&vdev->hw->ranges.user);\n\n\t \n\tboot_params->autoconfig = 1;\n\n\t \n\tboot_params->cache_defaults[VPU_BOOT_L2_CACHE_CFG_NN].use = 1;\n\tboot_params->cache_defaults[VPU_BOOT_L2_CACHE_CFG_NN].cfg =\n\t\tADDR_TO_L2_CACHE_CFG(vdev->hw->ranges.shave.start);\n\n\tif (vdev->fw->mem_shave_nn)\n\t\tboot_params->shave_nn_fw_base = vdev->fw->mem_shave_nn->vpu_addr;\n\n\tboot_params->watchdog_irq_mss = WATCHDOG_MSS_REDIRECT;\n\tboot_params->watchdog_irq_nce = WATCHDOG_NCE_REDIRECT;\n\tboot_params->si_stepping = ivpu_revision(vdev);\n\tboot_params->device_id = ivpu_device_id(vdev);\n\tboot_params->feature_exclusion = vdev->hw->tile_fuse;\n\tboot_params->sku = vdev->hw->sku;\n\n\tboot_params->min_freq_pll_ratio = vdev->hw->pll.min_ratio;\n\tboot_params->pn_freq_pll_ratio = vdev->hw->pll.pn_ratio;\n\tboot_params->max_freq_pll_ratio = vdev->hw->pll.max_ratio;\n\n\tboot_params->default_trace_level = vdev->fw->trace_level;\n\tboot_params->tracing_buff_message_format_mask = BIT(VPU_TRACING_FORMAT_STRING);\n\tboot_params->trace_destination_mask = vdev->fw->trace_destination_mask;\n\tboot_params->trace_hw_component_mask = vdev->fw->trace_hw_component_mask;\n\tboot_params->crit_tracing_buff_addr = vdev->fw->mem_log_crit->vpu_addr;\n\tboot_params->crit_tracing_buff_size = vdev->fw->mem_log_crit->base.size;\n\tboot_params->verbose_tracing_buff_addr = vdev->fw->mem_log_verb->vpu_addr;\n\tboot_params->verbose_tracing_buff_size = vdev->fw->mem_log_verb->base.size;\n\n\tboot_params->punit_telemetry_sram_base = ivpu_hw_reg_telemetry_offset_get(vdev);\n\tboot_params->punit_telemetry_sram_size = ivpu_hw_reg_telemetry_size_get(vdev);\n\tboot_params->vpu_telemetry_enable = ivpu_hw_reg_telemetry_enable_get(vdev);\n\n\twmb();  \n\n\tivpu_fw_boot_params_print(vdev, boot_params);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}