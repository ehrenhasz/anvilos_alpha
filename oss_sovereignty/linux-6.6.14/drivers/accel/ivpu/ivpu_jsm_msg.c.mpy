{
  "module_name": "ivpu_jsm_msg.c",
  "hash_id": "2f5e19400b8fd7f1ceb6116ee302109419872469d03aa39b61231867109f3744",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/ivpu/ivpu_jsm_msg.c",
  "human_readable_source": "\n \n\n#include \"ivpu_drv.h\"\n#include \"ivpu_ipc.h\"\n#include \"ivpu_jsm_msg.h\"\n\nint ivpu_jsm_register_db(struct ivpu_device *vdev, u32 ctx_id, u32 db_id,\n\t\t\t u64 jobq_base, u32 jobq_size)\n{\n\tstruct vpu_jsm_msg req = { .type = VPU_JSM_MSG_REGISTER_DB };\n\tstruct vpu_jsm_msg resp;\n\tint ret = 0;\n\n\treq.payload.register_db.db_idx = db_id;\n\treq.payload.register_db.jobq_base = jobq_base;\n\treq.payload.register_db.jobq_size = jobq_size;\n\treq.payload.register_db.host_ssid = ctx_id;\n\n\tret = ivpu_ipc_send_receive(vdev, &req, VPU_JSM_MSG_REGISTER_DB_DONE, &resp,\n\t\t\t\t    VPU_IPC_CHAN_ASYNC_CMD, vdev->timeout.jsm);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to register doorbell %d: %d\\n\", db_id, ret);\n\t\treturn ret;\n\t}\n\n\tivpu_dbg(vdev, JSM, \"Doorbell %d registered to context %d\\n\", db_id, ctx_id);\n\n\treturn 0;\n}\n\nint ivpu_jsm_unregister_db(struct ivpu_device *vdev, u32 db_id)\n{\n\tstruct vpu_jsm_msg req = { .type = VPU_JSM_MSG_UNREGISTER_DB };\n\tstruct vpu_jsm_msg resp;\n\tint ret = 0;\n\n\treq.payload.unregister_db.db_idx = db_id;\n\n\tret = ivpu_ipc_send_receive(vdev, &req, VPU_JSM_MSG_UNREGISTER_DB_DONE, &resp,\n\t\t\t\t    VPU_IPC_CHAN_ASYNC_CMD, vdev->timeout.jsm);\n\tif (ret) {\n\t\tivpu_warn(vdev, \"Failed to unregister doorbell %d: %d\\n\", db_id, ret);\n\t\treturn ret;\n\t}\n\n\tivpu_dbg(vdev, JSM, \"Doorbell %d unregistered\\n\", db_id);\n\n\treturn 0;\n}\n\nint ivpu_jsm_get_heartbeat(struct ivpu_device *vdev, u32 engine, u64 *heartbeat)\n{\n\tstruct vpu_jsm_msg req = { .type = VPU_JSM_MSG_QUERY_ENGINE_HB };\n\tstruct vpu_jsm_msg resp;\n\tint ret;\n\n\tif (engine > VPU_ENGINE_COPY)\n\t\treturn -EINVAL;\n\n\treq.payload.query_engine_hb.engine_idx = engine;\n\n\tret = ivpu_ipc_send_receive(vdev, &req, VPU_JSM_MSG_QUERY_ENGINE_HB_DONE, &resp,\n\t\t\t\t    VPU_IPC_CHAN_ASYNC_CMD, vdev->timeout.jsm);\n\tif (ret) {\n\t\tivpu_err(vdev, \"Failed to get heartbeat from engine %d: %d\\n\", engine, ret);\n\t\treturn ret;\n\t}\n\n\t*heartbeat = resp.payload.query_engine_hb_done.heartbeat;\n\treturn ret;\n}\n\nint ivpu_jsm_reset_engine(struct ivpu_device *vdev, u32 engine)\n{\n\tstruct vpu_jsm_msg req = { .type = VPU_JSM_MSG_ENGINE_RESET };\n\tstruct vpu_jsm_msg resp;\n\tint ret;\n\n\tif (engine > VPU_ENGINE_COPY)\n\t\treturn -EINVAL;\n\n\treq.payload.engine_reset.engine_idx = engine;\n\n\tret = ivpu_ipc_send_receive(vdev, &req, VPU_JSM_MSG_ENGINE_RESET_DONE, &resp,\n\t\t\t\t    VPU_IPC_CHAN_ASYNC_CMD, vdev->timeout.jsm);\n\tif (ret)\n\t\tivpu_err(vdev, \"Failed to reset engine %d: %d\\n\", engine, ret);\n\n\treturn ret;\n}\n\nint ivpu_jsm_preempt_engine(struct ivpu_device *vdev, u32 engine, u32 preempt_id)\n{\n\tstruct vpu_jsm_msg req = { .type = VPU_JSM_MSG_ENGINE_PREEMPT };\n\tstruct vpu_jsm_msg resp;\n\tint ret;\n\n\tif (engine > VPU_ENGINE_COPY)\n\t\treturn -EINVAL;\n\n\treq.payload.engine_preempt.engine_idx = engine;\n\treq.payload.engine_preempt.preempt_id = preempt_id;\n\n\tret = ivpu_ipc_send_receive(vdev, &req, VPU_JSM_MSG_ENGINE_PREEMPT_DONE, &resp,\n\t\t\t\t    VPU_IPC_CHAN_ASYNC_CMD, vdev->timeout.jsm);\n\tif (ret)\n\t\tivpu_err(vdev, \"Failed to preempt engine %d: %d\\n\", engine, ret);\n\n\treturn ret;\n}\n\nint ivpu_jsm_dyndbg_control(struct ivpu_device *vdev, char *command, size_t size)\n{\n\tstruct vpu_jsm_msg req = { .type = VPU_JSM_MSG_DYNDBG_CONTROL };\n\tstruct vpu_jsm_msg resp;\n\tint ret;\n\n\tstrscpy(req.payload.dyndbg_control.dyndbg_cmd, command, VPU_DYNDBG_CMD_MAX_LEN);\n\n\tret = ivpu_ipc_send_receive(vdev, &req, VPU_JSM_MSG_DYNDBG_CONTROL_RSP, &resp,\n\t\t\t\t    VPU_IPC_CHAN_ASYNC_CMD, vdev->timeout.jsm);\n\tif (ret)\n\t\tivpu_warn(vdev, \"Failed to send command \\\"%s\\\": ret %d\\n\", command, ret);\n\n\treturn ret;\n}\n\nint ivpu_jsm_trace_get_capability(struct ivpu_device *vdev, u32 *trace_destination_mask,\n\t\t\t\t  u64 *trace_hw_component_mask)\n{\n\tstruct vpu_jsm_msg req = { .type = VPU_JSM_MSG_TRACE_GET_CAPABILITY };\n\tstruct vpu_jsm_msg resp;\n\tint ret;\n\n\tret = ivpu_ipc_send_receive(vdev, &req, VPU_JSM_MSG_TRACE_GET_CAPABILITY_RSP, &resp,\n\t\t\t\t    VPU_IPC_CHAN_ASYNC_CMD, vdev->timeout.jsm);\n\tif (ret) {\n\t\tivpu_warn(vdev, \"Failed to get trace capability: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*trace_destination_mask = resp.payload.trace_capability.trace_destination_mask;\n\t*trace_hw_component_mask = resp.payload.trace_capability.trace_hw_component_mask;\n\n\treturn ret;\n}\n\nint ivpu_jsm_trace_set_config(struct ivpu_device *vdev, u32 trace_level, u32 trace_destination_mask,\n\t\t\t      u64 trace_hw_component_mask)\n{\n\tstruct vpu_jsm_msg req = { .type = VPU_JSM_MSG_TRACE_SET_CONFIG };\n\tstruct vpu_jsm_msg resp;\n\tint ret;\n\n\treq.payload.trace_config.trace_level = trace_level;\n\treq.payload.trace_config.trace_destination_mask = trace_destination_mask;\n\treq.payload.trace_config.trace_hw_component_mask = trace_hw_component_mask;\n\n\tret = ivpu_ipc_send_receive(vdev, &req, VPU_JSM_MSG_TRACE_SET_CONFIG_RSP, &resp,\n\t\t\t\t    VPU_IPC_CHAN_ASYNC_CMD, vdev->timeout.jsm);\n\tif (ret)\n\t\tivpu_warn(vdev, \"Failed to set config: %d\\n\", ret);\n\n\treturn ret;\n}\n\nint ivpu_jsm_context_release(struct ivpu_device *vdev, u32 host_ssid)\n{\n\tstruct vpu_jsm_msg req = { .type = VPU_JSM_MSG_SSID_RELEASE };\n\tstruct vpu_jsm_msg resp;\n\n\treq.payload.ssid_release.host_ssid = host_ssid;\n\n\treturn ivpu_ipc_send_receive(vdev, &req, VPU_JSM_MSG_SSID_RELEASE_DONE, &resp,\n\t\t\t\t     VPU_IPC_CHAN_ASYNC_CMD, vdev->timeout.jsm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}