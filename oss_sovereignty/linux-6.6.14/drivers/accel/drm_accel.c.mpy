{
  "module_name": "drm_accel.c",
  "hash_id": "0d62df08819d3812a7994a8bada397b12755e9f0c974a4139a15390551e0988f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/drm_accel.c",
  "human_readable_source": "\n\n \n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/idr.h>\n\n#include <drm/drm_accel.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_print.h>\n\nstatic DEFINE_SPINLOCK(accel_minor_lock);\nstatic struct idr accel_minors_idr;\n\nstatic struct dentry *accel_debugfs_root;\nstatic struct class *accel_class;\n\nstatic struct device_type accel_sysfs_device_minor = {\n\t.name = \"accel_minor\"\n};\n\nstatic char *accel_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"accel/%s\", dev_name(dev));\n}\n\nstatic int accel_sysfs_init(void)\n{\n\taccel_class = class_create(\"accel\");\n\tif (IS_ERR(accel_class))\n\t\treturn PTR_ERR(accel_class);\n\n\taccel_class->devnode = accel_devnode;\n\n\treturn 0;\n}\n\nstatic void accel_sysfs_destroy(void)\n{\n\tif (IS_ERR_OR_NULL(accel_class))\n\t\treturn;\n\tclass_destroy(accel_class);\n\taccel_class = NULL;\n}\n\nstatic int accel_name_info(struct seq_file *m, void *data)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *) m->private;\n\tstruct drm_minor *minor = node->minor;\n\tstruct drm_device *dev = minor->dev;\n\tstruct drm_master *master;\n\n\tmutex_lock(&dev->master_mutex);\n\tmaster = dev->master;\n\tseq_printf(m, \"%s\", dev->driver->name);\n\tif (dev->dev)\n\t\tseq_printf(m, \" dev=%s\", dev_name(dev->dev));\n\tif (master && master->unique)\n\t\tseq_printf(m, \" master=%s\", master->unique);\n\tif (dev->unique)\n\t\tseq_printf(m, \" unique=%s\", dev->unique);\n\tseq_puts(m, \"\\n\");\n\tmutex_unlock(&dev->master_mutex);\n\n\treturn 0;\n}\n\nstatic const struct drm_info_list accel_debugfs_list[] = {\n\t{\"name\", accel_name_info, 0}\n};\n#define ACCEL_DEBUGFS_ENTRIES ARRAY_SIZE(accel_debugfs_list)\n\n \nvoid accel_debugfs_init(struct drm_minor *minor, int minor_id)\n{\n\tstruct drm_device *dev = minor->dev;\n\tchar name[64];\n\n\tINIT_LIST_HEAD(&minor->debugfs_list);\n\tmutex_init(&minor->debugfs_lock);\n\tsprintf(name, \"%d\", minor_id);\n\tminor->debugfs_root = debugfs_create_dir(name, accel_debugfs_root);\n\n\tdrm_debugfs_create_files(accel_debugfs_list, ACCEL_DEBUGFS_ENTRIES,\n\t\t\t\t minor->debugfs_root, minor);\n\n\tif (dev->driver->debugfs_init)\n\t\tdev->driver->debugfs_init(minor);\n}\n\n \nvoid accel_set_device_instance_params(struct device *kdev, int index)\n{\n\tkdev->devt = MKDEV(ACCEL_MAJOR, index);\n\tkdev->class = accel_class;\n\tkdev->type = &accel_sysfs_device_minor;\n}\n\n \nint accel_minor_alloc(void)\n{\n\tunsigned long flags;\n\tint r;\n\n\tspin_lock_irqsave(&accel_minor_lock, flags);\n\tr = idr_alloc(&accel_minors_idr, NULL, 0, ACCEL_MAX_MINORS, GFP_NOWAIT);\n\tspin_unlock_irqrestore(&accel_minor_lock, flags);\n\n\treturn r;\n}\n\n \nvoid accel_minor_remove(int index)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&accel_minor_lock, flags);\n\tidr_remove(&accel_minors_idr, index);\n\tspin_unlock_irqrestore(&accel_minor_lock, flags);\n}\n\n \nvoid accel_minor_replace(struct drm_minor *minor, int index)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&accel_minor_lock, flags);\n\tidr_replace(&accel_minors_idr, minor, index);\n\tspin_unlock_irqrestore(&accel_minor_lock, flags);\n}\n\n \nstatic struct drm_minor *accel_minor_acquire(unsigned int minor_id)\n{\n\tstruct drm_minor *minor;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&accel_minor_lock, flags);\n\tminor = idr_find(&accel_minors_idr, minor_id);\n\tif (minor)\n\t\tdrm_dev_get(minor->dev);\n\tspin_unlock_irqrestore(&accel_minor_lock, flags);\n\n\tif (!minor) {\n\t\treturn ERR_PTR(-ENODEV);\n\t} else if (drm_dev_is_unplugged(minor->dev)) {\n\t\tdrm_dev_put(minor->dev);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\treturn minor;\n}\n\nstatic void accel_minor_release(struct drm_minor *minor)\n{\n\tdrm_dev_put(minor->dev);\n}\n\n \nint accel_open(struct inode *inode, struct file *filp)\n{\n\tstruct drm_device *dev;\n\tstruct drm_minor *minor;\n\tint retcode;\n\n\tminor = accel_minor_acquire(iminor(inode));\n\tif (IS_ERR(minor))\n\t\treturn PTR_ERR(minor);\n\n\tdev = minor->dev;\n\n\tatomic_fetch_inc(&dev->open_count);\n\n\t \n\tfilp->f_mapping = dev->anon_inode->i_mapping;\n\n\tretcode = drm_open_helper(filp, minor);\n\tif (retcode)\n\t\tgoto err_undo;\n\n\treturn 0;\n\nerr_undo:\n\tatomic_dec(&dev->open_count);\n\taccel_minor_release(minor);\n\treturn retcode;\n}\nEXPORT_SYMBOL_GPL(accel_open);\n\nstatic int accel_stub_open(struct inode *inode, struct file *filp)\n{\n\tconst struct file_operations *new_fops;\n\tstruct drm_minor *minor;\n\tint err;\n\n\tminor = accel_minor_acquire(iminor(inode));\n\tif (IS_ERR(minor))\n\t\treturn PTR_ERR(minor);\n\n\tnew_fops = fops_get(minor->dev->driver->fops);\n\tif (!new_fops) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\treplace_fops(filp, new_fops);\n\tif (filp->f_op->open)\n\t\terr = filp->f_op->open(inode, filp);\n\telse\n\t\terr = 0;\n\nout:\n\taccel_minor_release(minor);\n\n\treturn err;\n}\n\nstatic const struct file_operations accel_stub_fops = {\n\t.owner = THIS_MODULE,\n\t.open = accel_stub_open,\n\t.llseek = noop_llseek,\n};\n\nvoid accel_core_exit(void)\n{\n\tunregister_chrdev(ACCEL_MAJOR, \"accel\");\n\tdebugfs_remove(accel_debugfs_root);\n\taccel_sysfs_destroy();\n\tidr_destroy(&accel_minors_idr);\n}\n\nint __init accel_core_init(void)\n{\n\tint ret;\n\n\tidr_init(&accel_minors_idr);\n\n\tret = accel_sysfs_init();\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Cannot create ACCEL class: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\taccel_debugfs_root = debugfs_create_dir(\"accel\", NULL);\n\n\tret = register_chrdev(ACCEL_MAJOR, \"accel\", &accel_stub_fops);\n\tif (ret < 0)\n\t\tDRM_ERROR(\"Cannot register ACCEL major: %d\\n\", ret);\n\nerror:\n\t \n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}