{
  "module_name": "qaic_drv.c",
  "hash_id": "a4acfd3921bc826925d633e7936ede4fda1cd7b844b7c1b1fd7f5e45b31eb6ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accel/qaic/qaic_drv.c",
  "human_readable_source": "\n\n \n \n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/mhi.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <drm/drm_accel.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_ioctl.h>\n#include <uapi/drm/qaic_accel.h>\n\n#include \"mhi_controller.h\"\n#include \"qaic.h\"\n\nMODULE_IMPORT_NS(DMA_BUF);\n\n#define PCI_DEV_AIC100\t\t\t0xa100\n#define QAIC_NAME\t\t\t\"qaic\"\n#define QAIC_DESC\t\t\t\"Qualcomm Cloud AI Accelerators\"\n#define CNTL_MAJOR\t\t\t5\n#define CNTL_MINOR\t\t\t0\n\nbool datapath_polling;\nmodule_param(datapath_polling, bool, 0400);\nMODULE_PARM_DESC(datapath_polling, \"Operate the datapath in polling mode\");\nstatic bool link_up;\nstatic DEFINE_IDA(qaic_usrs);\n\nstatic int qaic_create_drm_device(struct qaic_device *qdev, s32 partition_id);\nstatic void qaic_destroy_drm_device(struct qaic_device *qdev, s32 partition_id);\n\nstatic void free_usr(struct kref *kref)\n{\n\tstruct qaic_user *usr = container_of(kref, struct qaic_user, ref_count);\n\n\tcleanup_srcu_struct(&usr->qddev_lock);\n\tida_free(&qaic_usrs, usr->handle);\n\tkfree(usr);\n}\n\nstatic int qaic_open(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct qaic_drm_device *qddev = dev->dev_private;\n\tstruct qaic_device *qdev = qddev->qdev;\n\tstruct qaic_user *usr;\n\tint rcu_id;\n\tint ret;\n\n\trcu_id = srcu_read_lock(&qdev->dev_lock);\n\tif (qdev->in_reset) {\n\t\tret = -ENODEV;\n\t\tgoto dev_unlock;\n\t}\n\n\tusr = kmalloc(sizeof(*usr), GFP_KERNEL);\n\tif (!usr) {\n\t\tret = -ENOMEM;\n\t\tgoto dev_unlock;\n\t}\n\n\tusr->handle = ida_alloc(&qaic_usrs, GFP_KERNEL);\n\tif (usr->handle < 0) {\n\t\tret = usr->handle;\n\t\tgoto free_usr;\n\t}\n\tusr->qddev = qddev;\n\tatomic_set(&usr->chunk_id, 0);\n\tinit_srcu_struct(&usr->qddev_lock);\n\tkref_init(&usr->ref_count);\n\n\tret = mutex_lock_interruptible(&qddev->users_mutex);\n\tif (ret)\n\t\tgoto cleanup_usr;\n\n\tlist_add(&usr->node, &qddev->users);\n\tmutex_unlock(&qddev->users_mutex);\n\n\tfile->driver_priv = usr;\n\n\tsrcu_read_unlock(&qdev->dev_lock, rcu_id);\n\treturn 0;\n\ncleanup_usr:\n\tcleanup_srcu_struct(&usr->qddev_lock);\n\tida_free(&qaic_usrs, usr->handle);\nfree_usr:\n\tkfree(usr);\ndev_unlock:\n\tsrcu_read_unlock(&qdev->dev_lock, rcu_id);\n\treturn ret;\n}\n\nstatic void qaic_postclose(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct qaic_user *usr = file->driver_priv;\n\tstruct qaic_drm_device *qddev;\n\tstruct qaic_device *qdev;\n\tint qdev_rcu_id;\n\tint usr_rcu_id;\n\tint i;\n\n\tqddev = usr->qddev;\n\tusr_rcu_id = srcu_read_lock(&usr->qddev_lock);\n\tif (qddev) {\n\t\tqdev = qddev->qdev;\n\t\tqdev_rcu_id = srcu_read_lock(&qdev->dev_lock);\n\t\tif (!qdev->in_reset) {\n\t\t\tqaic_release_usr(qdev, usr);\n\t\t\tfor (i = 0; i < qdev->num_dbc; ++i)\n\t\t\t\tif (qdev->dbc[i].usr && qdev->dbc[i].usr->handle == usr->handle)\n\t\t\t\t\trelease_dbc(qdev, i);\n\t\t}\n\t\tsrcu_read_unlock(&qdev->dev_lock, qdev_rcu_id);\n\n\t\tmutex_lock(&qddev->users_mutex);\n\t\tif (!list_empty(&usr->node))\n\t\t\tlist_del_init(&usr->node);\n\t\tmutex_unlock(&qddev->users_mutex);\n\t}\n\n\tsrcu_read_unlock(&usr->qddev_lock, usr_rcu_id);\n\tkref_put(&usr->ref_count, free_usr);\n\n\tfile->driver_priv = NULL;\n}\n\nDEFINE_DRM_ACCEL_FOPS(qaic_accel_fops);\n\nstatic const struct drm_ioctl_desc qaic_drm_ioctls[] = {\n\tDRM_IOCTL_DEF_DRV(QAIC_MANAGE, qaic_manage_ioctl, 0),\n\tDRM_IOCTL_DEF_DRV(QAIC_CREATE_BO, qaic_create_bo_ioctl, 0),\n\tDRM_IOCTL_DEF_DRV(QAIC_MMAP_BO, qaic_mmap_bo_ioctl, 0),\n\tDRM_IOCTL_DEF_DRV(QAIC_ATTACH_SLICE_BO, qaic_attach_slice_bo_ioctl, 0),\n\tDRM_IOCTL_DEF_DRV(QAIC_EXECUTE_BO, qaic_execute_bo_ioctl, 0),\n\tDRM_IOCTL_DEF_DRV(QAIC_PARTIAL_EXECUTE_BO, qaic_partial_execute_bo_ioctl, 0),\n\tDRM_IOCTL_DEF_DRV(QAIC_WAIT_BO, qaic_wait_bo_ioctl, 0),\n\tDRM_IOCTL_DEF_DRV(QAIC_PERF_STATS_BO, qaic_perf_stats_bo_ioctl, 0),\n};\n\nstatic const struct drm_driver qaic_accel_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_COMPUTE_ACCEL,\n\n\t.name\t\t\t= QAIC_NAME,\n\t.desc\t\t\t= QAIC_DESC,\n\t.date\t\t\t= \"20190618\",\n\n\t.fops\t\t\t= &qaic_accel_fops,\n\t.open\t\t\t= qaic_open,\n\t.postclose\t\t= qaic_postclose,\n\n\t.ioctls\t\t\t= qaic_drm_ioctls,\n\t.num_ioctls\t\t= ARRAY_SIZE(qaic_drm_ioctls),\n\t.gem_prime_import\t= qaic_gem_prime_import,\n};\n\nstatic int qaic_create_drm_device(struct qaic_device *qdev, s32 partition_id)\n{\n\tstruct qaic_drm_device *qddev;\n\tstruct drm_device *ddev;\n\tstruct device *pdev;\n\tint ret;\n\n\t \n\tif (partition_id != QAIC_NO_PARTITION)\n\t\treturn -EINVAL;\n\n\tpdev = &qdev->pdev->dev;\n\n\tqddev = kzalloc(sizeof(*qddev), GFP_KERNEL);\n\tif (!qddev)\n\t\treturn -ENOMEM;\n\n\tddev = drm_dev_alloc(&qaic_accel_driver, pdev);\n\tif (IS_ERR(ddev)) {\n\t\tret = PTR_ERR(ddev);\n\t\tgoto ddev_fail;\n\t}\n\n\tddev->dev_private = qddev;\n\tqddev->ddev = ddev;\n\n\tqddev->qdev = qdev;\n\tqddev->partition_id = partition_id;\n\tINIT_LIST_HEAD(&qddev->users);\n\tmutex_init(&qddev->users_mutex);\n\n\tqdev->qddev = qddev;\n\n\tret = drm_dev_register(ddev, 0);\n\tif (ret) {\n\t\tpci_dbg(qdev->pdev, \"%s: drm_dev_register failed %d\\n\", __func__, ret);\n\t\tgoto drm_reg_fail;\n\t}\n\n\treturn 0;\n\ndrm_reg_fail:\n\tmutex_destroy(&qddev->users_mutex);\n\tqdev->qddev = NULL;\n\tdrm_dev_put(ddev);\nddev_fail:\n\tkfree(qddev);\n\treturn ret;\n}\n\nstatic void qaic_destroy_drm_device(struct qaic_device *qdev, s32 partition_id)\n{\n\tstruct qaic_drm_device *qddev;\n\tstruct qaic_user *usr;\n\n\tqddev = qdev->qddev;\n\tqdev->qddev = NULL;\n\tif (!qddev)\n\t\treturn;\n\n\t \n\tmutex_lock(&qddev->users_mutex);\n\twhile (!list_empty(&qddev->users)) {\n\t\tusr = list_first_entry(&qddev->users, struct qaic_user, node);\n\t\tlist_del_init(&usr->node);\n\t\tkref_get(&usr->ref_count);\n\t\tusr->qddev = NULL;\n\t\tmutex_unlock(&qddev->users_mutex);\n\t\tsynchronize_srcu(&usr->qddev_lock);\n\t\tkref_put(&usr->ref_count, free_usr);\n\t\tmutex_lock(&qddev->users_mutex);\n\t}\n\tmutex_unlock(&qddev->users_mutex);\n\n\tif (qddev->ddev) {\n\t\tdrm_dev_unregister(qddev->ddev);\n\t\tdrm_dev_put(qddev->ddev);\n\t}\n\n\tkfree(qddev);\n}\n\nstatic int qaic_mhi_probe(struct mhi_device *mhi_dev, const struct mhi_device_id *id)\n{\n\tu16 major = -1, minor = -1;\n\tstruct qaic_device *qdev;\n\tint ret;\n\n\t \n\n\tqdev = pci_get_drvdata(to_pci_dev(mhi_dev->mhi_cntrl->cntrl_dev));\n\n\tqdev->in_reset = false;\n\n\tdev_set_drvdata(&mhi_dev->dev, qdev);\n\tqdev->cntl_ch = mhi_dev;\n\n\tret = qaic_control_open(qdev);\n\tif (ret) {\n\t\tpci_dbg(qdev->pdev, \"%s: control_open failed %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = get_cntl_version(qdev, NULL, &major, &minor);\n\tif (ret || major != CNTL_MAJOR || minor > CNTL_MINOR) {\n\t\tpci_err(qdev->pdev, \"%s: Control protocol version (%d.%d) not supported. Supported version is (%d.%d). Ret: %d\\n\",\n\t\t\t__func__, major, minor, CNTL_MAJOR, CNTL_MINOR, ret);\n\t\tret = -EINVAL;\n\t\tgoto close_control;\n\t}\n\n\tret = qaic_create_drm_device(qdev, QAIC_NO_PARTITION);\n\n\treturn ret;\n\nclose_control:\n\tqaic_control_close(qdev);\n\treturn ret;\n}\n\nstatic void qaic_mhi_remove(struct mhi_device *mhi_dev)\n{\n \n}\n\nstatic void qaic_notify_reset(struct qaic_device *qdev)\n{\n\tint i;\n\n\tqdev->in_reset = true;\n\t \n\twake_all_cntl(qdev);\n\tfor (i = 0; i < qdev->num_dbc; ++i)\n\t\twakeup_dbc(qdev, i);\n\tsynchronize_srcu(&qdev->dev_lock);\n}\n\nvoid qaic_dev_reset_clean_local_state(struct qaic_device *qdev, bool exit_reset)\n{\n\tint i;\n\n\tqaic_notify_reset(qdev);\n\n\t \n\tqaic_destroy_drm_device(qdev, QAIC_NO_PARTITION);\n\n\t \n\tfor (i = 0; i < qdev->num_dbc; ++i)\n\t\trelease_dbc(qdev, i);\n\n\tif (exit_reset)\n\t\tqdev->in_reset = false;\n}\n\nstatic struct qaic_device *create_qdev(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct qaic_device *qdev;\n\tint i;\n\n\tqdev = devm_kzalloc(&pdev->dev, sizeof(*qdev), GFP_KERNEL);\n\tif (!qdev)\n\t\treturn NULL;\n\n\tif (id->device == PCI_DEV_AIC100) {\n\t\tqdev->num_dbc = 16;\n\t\tqdev->dbc = devm_kcalloc(&pdev->dev, qdev->num_dbc, sizeof(*qdev->dbc), GFP_KERNEL);\n\t\tif (!qdev->dbc)\n\t\t\treturn NULL;\n\t}\n\n\tqdev->cntl_wq = alloc_workqueue(\"qaic_cntl\", WQ_UNBOUND, 0);\n\tif (!qdev->cntl_wq)\n\t\treturn NULL;\n\n\tpci_set_drvdata(pdev, qdev);\n\tqdev->pdev = pdev;\n\n\tmutex_init(&qdev->cntl_mutex);\n\tINIT_LIST_HEAD(&qdev->cntl_xfer_list);\n\tinit_srcu_struct(&qdev->dev_lock);\n\n\tfor (i = 0; i < qdev->num_dbc; ++i) {\n\t\tspin_lock_init(&qdev->dbc[i].xfer_lock);\n\t\tqdev->dbc[i].qdev = qdev;\n\t\tqdev->dbc[i].id = i;\n\t\tINIT_LIST_HEAD(&qdev->dbc[i].xfer_list);\n\t\tinit_srcu_struct(&qdev->dbc[i].ch_lock);\n\t\tinit_waitqueue_head(&qdev->dbc[i].dbc_release);\n\t\tINIT_LIST_HEAD(&qdev->dbc[i].bo_lists);\n\t}\n\n\treturn qdev;\n}\n\nstatic void cleanup_qdev(struct qaic_device *qdev)\n{\n\tint i;\n\n\tfor (i = 0; i < qdev->num_dbc; ++i)\n\t\tcleanup_srcu_struct(&qdev->dbc[i].ch_lock);\n\tcleanup_srcu_struct(&qdev->dev_lock);\n\tpci_set_drvdata(qdev->pdev, NULL);\n\tdestroy_workqueue(qdev->cntl_wq);\n}\n\nstatic int init_pci(struct qaic_device *qdev, struct pci_dev *pdev)\n{\n\tint bars;\n\tint ret;\n\n\tbars = pci_select_bars(pdev, IORESOURCE_MEM);\n\n\t \n\tif (bars != (BIT(0) | BIT(2) | BIT(4))) {\n\t\tpci_dbg(pdev, \"%s: expected BARs 0, 2, and 4 not found in device. Found 0x%x\\n\",\n\t\t\t__func__, bars);\n\t\treturn -EINVAL;\n\t}\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (ret)\n\t\treturn ret;\n\tret = dma_set_max_seg_size(&pdev->dev, UINT_MAX);\n\tif (ret)\n\t\treturn ret;\n\n\tqdev->bar_0 = devm_ioremap_resource(&pdev->dev, &pdev->resource[0]);\n\tif (IS_ERR(qdev->bar_0))\n\t\treturn PTR_ERR(qdev->bar_0);\n\n\tqdev->bar_2 = devm_ioremap_resource(&pdev->dev, &pdev->resource[2]);\n\tif (IS_ERR(qdev->bar_2))\n\t\treturn PTR_ERR(qdev->bar_2);\n\n\t \n\tpci_set_master(pdev);\n\n\treturn 0;\n}\n\nstatic int init_msi(struct qaic_device *qdev, struct pci_dev *pdev)\n{\n\tint mhi_irq;\n\tint ret;\n\tint i;\n\n\t \n\tret = pci_alloc_irq_vectors(pdev, 1, 32, PCI_IRQ_MSI);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret < 32) {\n\t\tpci_err(pdev, \"%s: Requested 32 MSIs. Obtained %d MSIs which is less than the 32 required.\\n\",\n\t\t\t__func__, ret);\n\t\treturn -ENODEV;\n\t}\n\n\tmhi_irq = pci_irq_vector(pdev, 0);\n\tif (mhi_irq < 0)\n\t\treturn mhi_irq;\n\n\tfor (i = 0; i < qdev->num_dbc; ++i) {\n\t\tret = devm_request_threaded_irq(&pdev->dev, pci_irq_vector(pdev, i + 1),\n\t\t\t\t\t\tdbc_irq_handler, dbc_irq_threaded_fn, IRQF_SHARED,\n\t\t\t\t\t\t\"qaic_dbc\", &qdev->dbc[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (datapath_polling) {\n\t\t\tqdev->dbc[i].irq = pci_irq_vector(pdev, i + 1);\n\t\t\tdisable_irq_nosync(qdev->dbc[i].irq);\n\t\t\tINIT_WORK(&qdev->dbc[i].poll_work, irq_polling_work);\n\t\t}\n\t}\n\n\treturn mhi_irq;\n}\n\nstatic int qaic_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct qaic_device *qdev;\n\tint mhi_irq;\n\tint ret;\n\tint i;\n\n\tqdev = create_qdev(pdev, id);\n\tif (!qdev)\n\t\treturn -ENOMEM;\n\n\tret = init_pci(qdev, pdev);\n\tif (ret)\n\t\tgoto cleanup_qdev;\n\n\tfor (i = 0; i < qdev->num_dbc; ++i)\n\t\tqdev->dbc[i].dbc_base = qdev->bar_2 + QAIC_DBC_OFF(i);\n\n\tmhi_irq = init_msi(qdev, pdev);\n\tif (mhi_irq < 0) {\n\t\tret = mhi_irq;\n\t\tgoto cleanup_qdev;\n\t}\n\n\tqdev->mhi_cntrl = qaic_mhi_register_controller(pdev, qdev->bar_0, mhi_irq);\n\tif (IS_ERR(qdev->mhi_cntrl)) {\n\t\tret = PTR_ERR(qdev->mhi_cntrl);\n\t\tgoto cleanup_qdev;\n\t}\n\n\treturn 0;\n\ncleanup_qdev:\n\tcleanup_qdev(qdev);\n\treturn ret;\n}\n\nstatic void qaic_pci_remove(struct pci_dev *pdev)\n{\n\tstruct qaic_device *qdev = pci_get_drvdata(pdev);\n\n\tif (!qdev)\n\t\treturn;\n\n\tqaic_dev_reset_clean_local_state(qdev, false);\n\tqaic_mhi_free_controller(qdev->mhi_cntrl, link_up);\n\tcleanup_qdev(qdev);\n}\n\nstatic void qaic_pci_shutdown(struct pci_dev *pdev)\n{\n\t \n\tlink_up = true;\n\tqaic_pci_remove(pdev);\n}\n\nstatic pci_ers_result_t qaic_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t error)\n{\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\nstatic void qaic_pci_reset_prepare(struct pci_dev *pdev)\n{\n\tstruct qaic_device *qdev = pci_get_drvdata(pdev);\n\n\tqaic_notify_reset(qdev);\n\tqaic_mhi_start_reset(qdev->mhi_cntrl);\n\tqaic_dev_reset_clean_local_state(qdev, false);\n}\n\nstatic void qaic_pci_reset_done(struct pci_dev *pdev)\n{\n\tstruct qaic_device *qdev = pci_get_drvdata(pdev);\n\n\tqdev->in_reset = false;\n\tqaic_mhi_reset_done(qdev->mhi_cntrl);\n}\n\nstatic const struct mhi_device_id qaic_mhi_match_table[] = {\n\t{ .chan = \"QAIC_CONTROL\", },\n\t{},\n};\n\nstatic struct mhi_driver qaic_mhi_driver = {\n\t.id_table = qaic_mhi_match_table,\n\t.remove = qaic_mhi_remove,\n\t.probe = qaic_mhi_probe,\n\t.ul_xfer_cb = qaic_mhi_ul_xfer_cb,\n\t.dl_xfer_cb = qaic_mhi_dl_xfer_cb,\n\t.driver = {\n\t\t.name = \"qaic_mhi\",\n\t},\n};\n\nstatic const struct pci_device_id qaic_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QCOM, PCI_DEV_AIC100), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, qaic_ids);\n\nstatic const struct pci_error_handlers qaic_pci_err_handler = {\n\t.error_detected = qaic_pci_error_detected,\n\t.reset_prepare = qaic_pci_reset_prepare,\n\t.reset_done = qaic_pci_reset_done,\n};\n\nstatic struct pci_driver qaic_pci_driver = {\n\t.name = QAIC_NAME,\n\t.id_table = qaic_ids,\n\t.probe = qaic_pci_probe,\n\t.remove = qaic_pci_remove,\n\t.shutdown = qaic_pci_shutdown,\n\t.err_handler = &qaic_pci_err_handler,\n};\n\nstatic int __init qaic_init(void)\n{\n\tint ret;\n\n\tret = mhi_driver_register(&qaic_mhi_driver);\n\tif (ret) {\n\t\tpr_debug(\"qaic: mhi_driver_register failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pci_register_driver(&qaic_pci_driver);\n\tif (ret) {\n\t\tpr_debug(\"qaic: pci_register_driver failed %d\\n\", ret);\n\t\tgoto free_mhi;\n\t}\n\n\treturn 0;\n\nfree_mhi:\n\tmhi_driver_unregister(&qaic_mhi_driver);\n\treturn ret;\n}\n\nstatic void __exit qaic_exit(void)\n{\n\t \n\tlink_up = true;\n\tpci_unregister_driver(&qaic_pci_driver);\n\tmhi_driver_unregister(&qaic_mhi_driver);\n}\n\nmodule_init(qaic_init);\nmodule_exit(qaic_exit);\n\nMODULE_AUTHOR(QAIC_DESC \" Kernel Driver Team\");\nMODULE_DESCRIPTION(QAIC_DESC \" Accel Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}