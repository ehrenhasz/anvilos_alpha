{
  "module_name": "arch_numa.c",
  "hash_id": "9e8a454373848b1a3611e830f1ed94243708bc74c3e5cd4271b1d612dccc12cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/arch_numa.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"NUMA: \" fmt\n\n#include <linux/acpi.h>\n#include <linux/memblock.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#include <asm/sections.h>\n\nstruct pglist_data *node_data[MAX_NUMNODES] __read_mostly;\nEXPORT_SYMBOL(node_data);\nnodemask_t numa_nodes_parsed __initdata;\nstatic int cpu_to_node_map[NR_CPUS] = { [0 ... NR_CPUS-1] = NUMA_NO_NODE };\n\nstatic int numa_distance_cnt;\nstatic u8 *numa_distance;\nbool numa_off;\n\nstatic __init int numa_parse_early_param(char *opt)\n{\n\tif (!opt)\n\t\treturn -EINVAL;\n\tif (str_has_prefix(opt, \"off\"))\n\t\tnuma_off = true;\n\n\treturn 0;\n}\nearly_param(\"numa\", numa_parse_early_param);\n\ncpumask_var_t node_to_cpumask_map[MAX_NUMNODES];\nEXPORT_SYMBOL(node_to_cpumask_map);\n\n#ifdef CONFIG_DEBUG_PER_CPU_MAPS\n\n \nconst struct cpumask *cpumask_of_node(int node)\n{\n\n\tif (node == NUMA_NO_NODE)\n\t\treturn cpu_all_mask;\n\n\tif (WARN_ON(node < 0 || node >= nr_node_ids))\n\t\treturn cpu_none_mask;\n\n\tif (WARN_ON(node_to_cpumask_map[node] == NULL))\n\t\treturn cpu_online_mask;\n\n\treturn node_to_cpumask_map[node];\n}\nEXPORT_SYMBOL(cpumask_of_node);\n\n#endif\n\nstatic void numa_update_cpu(unsigned int cpu, bool remove)\n{\n\tint nid = cpu_to_node(cpu);\n\n\tif (nid == NUMA_NO_NODE)\n\t\treturn;\n\n\tif (remove)\n\t\tcpumask_clear_cpu(cpu, node_to_cpumask_map[nid]);\n\telse\n\t\tcpumask_set_cpu(cpu, node_to_cpumask_map[nid]);\n}\n\nvoid numa_add_cpu(unsigned int cpu)\n{\n\tnuma_update_cpu(cpu, false);\n}\n\nvoid numa_remove_cpu(unsigned int cpu)\n{\n\tnuma_update_cpu(cpu, true);\n}\n\nvoid numa_clear_node(unsigned int cpu)\n{\n\tnuma_remove_cpu(cpu);\n\tset_cpu_numa_node(cpu, NUMA_NO_NODE);\n}\n\n \nstatic void __init setup_node_to_cpumask_map(void)\n{\n\tint node;\n\n\t \n\tif (nr_node_ids == MAX_NUMNODES)\n\t\tsetup_nr_node_ids();\n\n\t \n\tfor (node = 0; node < nr_node_ids; node++) {\n\t\talloc_bootmem_cpumask_var(&node_to_cpumask_map[node]);\n\t\tcpumask_clear(node_to_cpumask_map[node]);\n\t}\n\n\t \n\tpr_debug(\"Node to cpumask map for %u nodes\\n\", nr_node_ids);\n}\n\n \nvoid numa_store_cpu_info(unsigned int cpu)\n{\n\tset_cpu_numa_node(cpu, cpu_to_node_map[cpu]);\n}\n\nvoid __init early_map_cpu_to_node(unsigned int cpu, int nid)\n{\n\t \n\tif (nid < 0 || nid >= MAX_NUMNODES || numa_off)\n\t\tnid = 0;\n\n\tcpu_to_node_map[cpu] = nid;\n\n\t \n\tif (!cpu)\n\t\tset_cpu_numa_node(cpu, nid);\n}\n\n#ifdef CONFIG_HAVE_SETUP_PER_CPU_AREA\nunsigned long __per_cpu_offset[NR_CPUS] __read_mostly;\nEXPORT_SYMBOL(__per_cpu_offset);\n\nstatic int __init early_cpu_to_node(int cpu)\n{\n\treturn cpu_to_node_map[cpu];\n}\n\nstatic int __init pcpu_cpu_distance(unsigned int from, unsigned int to)\n{\n\treturn node_distance(early_cpu_to_node(from), early_cpu_to_node(to));\n}\n\nvoid __init setup_per_cpu_areas(void)\n{\n\tunsigned long delta;\n\tunsigned int cpu;\n\tint rc = -EINVAL;\n\n\tif (pcpu_chosen_fc != PCPU_FC_PAGE) {\n\t\t \n\t\trc = pcpu_embed_first_chunk(PERCPU_MODULE_RESERVE,\n\t\t\t\t\t    PERCPU_DYNAMIC_RESERVE, PAGE_SIZE,\n\t\t\t\t\t    pcpu_cpu_distance,\n\t\t\t\t\t    early_cpu_to_node);\n#ifdef CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK\n\t\tif (rc < 0)\n\t\t\tpr_warn(\"PERCPU: %s allocator failed (%d), falling back to page size\\n\",\n\t\t\t\t   pcpu_fc_names[pcpu_chosen_fc], rc);\n#endif\n\t}\n\n#ifdef CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK\n\tif (rc < 0)\n\t\trc = pcpu_page_first_chunk(PERCPU_MODULE_RESERVE, early_cpu_to_node);\n#endif\n\tif (rc < 0)\n\t\tpanic(\"Failed to initialize percpu areas (err=%d).\", rc);\n\n\tdelta = (unsigned long)pcpu_base_addr - (unsigned long)__per_cpu_start;\n\tfor_each_possible_cpu(cpu)\n\t\t__per_cpu_offset[cpu] = delta + pcpu_unit_offsets[cpu];\n}\n#endif\n\n \nint __init numa_add_memblk(int nid, u64 start, u64 end)\n{\n\tint ret;\n\n\tret = memblock_set_node(start, (end - start), &memblock.memory, nid);\n\tif (ret < 0) {\n\t\tpr_err(\"memblock [0x%llx - 0x%llx] failed to add on node %d\\n\",\n\t\t\tstart, (end - 1), nid);\n\t\treturn ret;\n\t}\n\n\tnode_set(nid, numa_nodes_parsed);\n\treturn ret;\n}\n\n \nstatic void __init setup_node_data(int nid, u64 start_pfn, u64 end_pfn)\n{\n\tconst size_t nd_size = roundup(sizeof(pg_data_t), SMP_CACHE_BYTES);\n\tu64 nd_pa;\n\tvoid *nd;\n\tint tnid;\n\n\tif (start_pfn >= end_pfn)\n\t\tpr_info(\"Initmem setup node %d [<memory-less node>]\\n\", nid);\n\n\tnd_pa = memblock_phys_alloc_try_nid(nd_size, SMP_CACHE_BYTES, nid);\n\tif (!nd_pa)\n\t\tpanic(\"Cannot allocate %zu bytes for node %d data\\n\",\n\t\t      nd_size, nid);\n\n\tnd = __va(nd_pa);\n\n\t \n\tpr_info(\"NODE_DATA [mem %#010Lx-%#010Lx]\\n\",\n\t\tnd_pa, nd_pa + nd_size - 1);\n\ttnid = early_pfn_to_nid(nd_pa >> PAGE_SHIFT);\n\tif (tnid != nid)\n\t\tpr_info(\"NODE_DATA(%d) on node %d\\n\", nid, tnid);\n\n\tnode_data[nid] = nd;\n\tmemset(NODE_DATA(nid), 0, sizeof(pg_data_t));\n\tNODE_DATA(nid)->node_id = nid;\n\tNODE_DATA(nid)->node_start_pfn = start_pfn;\n\tNODE_DATA(nid)->node_spanned_pages = end_pfn - start_pfn;\n}\n\n \nvoid __init numa_free_distance(void)\n{\n\tsize_t size;\n\n\tif (!numa_distance)\n\t\treturn;\n\n\tsize = numa_distance_cnt * numa_distance_cnt *\n\t\tsizeof(numa_distance[0]);\n\n\tmemblock_free(numa_distance, size);\n\tnuma_distance_cnt = 0;\n\tnuma_distance = NULL;\n}\n\n \nstatic int __init numa_alloc_distance(void)\n{\n\tsize_t size;\n\tint i, j;\n\n\tsize = nr_node_ids * nr_node_ids * sizeof(numa_distance[0]);\n\tnuma_distance = memblock_alloc(size, PAGE_SIZE);\n\tif (WARN_ON(!numa_distance))\n\t\treturn -ENOMEM;\n\n\tnuma_distance_cnt = nr_node_ids;\n\n\t \n\tfor (i = 0; i < numa_distance_cnt; i++)\n\t\tfor (j = 0; j < numa_distance_cnt; j++)\n\t\t\tnuma_distance[i * numa_distance_cnt + j] = i == j ?\n\t\t\t\tLOCAL_DISTANCE : REMOTE_DISTANCE;\n\n\tpr_debug(\"Initialized distance table, cnt=%d\\n\", numa_distance_cnt);\n\n\treturn 0;\n}\n\n \nvoid __init numa_set_distance(int from, int to, int distance)\n{\n\tif (!numa_distance) {\n\t\tpr_warn_once(\"Warning: distance table not allocated yet\\n\");\n\t\treturn;\n\t}\n\n\tif (from >= numa_distance_cnt || to >= numa_distance_cnt ||\n\t\t\tfrom < 0 || to < 0) {\n\t\tpr_warn_once(\"Warning: node ids are out of bound, from=%d to=%d distance=%d\\n\",\n\t\t\t    from, to, distance);\n\t\treturn;\n\t}\n\n\tif ((u8)distance != distance ||\n\t    (from == to && distance != LOCAL_DISTANCE)) {\n\t\tpr_warn_once(\"Warning: invalid distance parameter, from=%d to=%d distance=%d\\n\",\n\t\t\t     from, to, distance);\n\t\treturn;\n\t}\n\n\tnuma_distance[from * numa_distance_cnt + to] = distance;\n}\n\n \nint __node_distance(int from, int to)\n{\n\tif (from >= numa_distance_cnt || to >= numa_distance_cnt)\n\t\treturn from == to ? LOCAL_DISTANCE : REMOTE_DISTANCE;\n\treturn numa_distance[from * numa_distance_cnt + to];\n}\nEXPORT_SYMBOL(__node_distance);\n\nstatic int __init numa_register_nodes(void)\n{\n\tint nid;\n\tstruct memblock_region *mblk;\n\n\t \n\tfor_each_mem_region(mblk) {\n\t\tint mblk_nid = memblock_get_region_node(mblk);\n\t\tphys_addr_t start = mblk->base;\n\t\tphys_addr_t end = mblk->base + mblk->size - 1;\n\n\t\tif (mblk_nid == NUMA_NO_NODE || mblk_nid >= MAX_NUMNODES) {\n\t\t\tpr_warn(\"Warning: invalid memblk node %d [mem %pap-%pap]\\n\",\n\t\t\t\tmblk_nid, &start, &end);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tfor_each_node_mask(nid, numa_nodes_parsed) {\n\t\tunsigned long start_pfn, end_pfn;\n\n\t\tget_pfn_range_for_nid(nid, &start_pfn, &end_pfn);\n\t\tsetup_node_data(nid, start_pfn, end_pfn);\n\t\tnode_set_online(nid);\n\t}\n\n\t \n\tnode_possible_map = numa_nodes_parsed;\n\n\treturn 0;\n}\n\nstatic int __init numa_init(int (*init_func)(void))\n{\n\tint ret;\n\n\tnodes_clear(numa_nodes_parsed);\n\tnodes_clear(node_possible_map);\n\tnodes_clear(node_online_map);\n\n\tret = numa_alloc_distance();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = init_func();\n\tif (ret < 0)\n\t\tgoto out_free_distance;\n\n\tif (nodes_empty(numa_nodes_parsed)) {\n\t\tpr_info(\"No NUMA configuration found\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_free_distance;\n\t}\n\n\tret = numa_register_nodes();\n\tif (ret < 0)\n\t\tgoto out_free_distance;\n\n\tsetup_node_to_cpumask_map();\n\n\treturn 0;\nout_free_distance:\n\tnuma_free_distance();\n\treturn ret;\n}\n\n \nstatic int __init dummy_numa_init(void)\n{\n\tphys_addr_t start = memblock_start_of_DRAM();\n\tphys_addr_t end = memblock_end_of_DRAM() - 1;\n\tint ret;\n\n\tif (numa_off)\n\t\tpr_info(\"NUMA disabled\\n\");  \n\tpr_info(\"Faking a node at [mem %pap-%pap]\\n\", &start, &end);\n\n\tret = numa_add_memblk(0, start, end + 1);\n\tif (ret) {\n\t\tpr_err(\"NUMA init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tnuma_off = true;\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI_NUMA\nstatic int __init arch_acpi_numa_init(void)\n{\n\tint ret;\n\n\tret = acpi_numa_init();\n\tif (ret) {\n\t\tpr_info(\"Failed to initialise from firmware\\n\");\n\t\treturn ret;\n\t}\n\n\treturn srat_disabled() ? -EINVAL : 0;\n}\n#else\nstatic int __init arch_acpi_numa_init(void)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\n \nvoid __init arch_numa_init(void)\n{\n\tif (!numa_off) {\n\t\tif (!acpi_disabled && !numa_init(arch_acpi_numa_init))\n\t\t\treturn;\n\t\tif (acpi_disabled && !numa_init(of_numa_init))\n\t\t\treturn;\n\t}\n\n\tnuma_init(dummy_numa_init);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}