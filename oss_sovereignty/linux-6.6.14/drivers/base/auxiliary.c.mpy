{
  "module_name": "auxiliary.c",
  "hash_id": "68d0511a146a9ddccaf69fed752083c6139252a13a531176d9474622727b4be5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/auxiliary.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s:%s: \" fmt, KBUILD_MODNAME, __func__\n\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/string.h>\n#include <linux/auxiliary_bus.h>\n#include \"base.h\"\n\n \n\n \n\n \n\nstatic const struct auxiliary_device_id *auxiliary_match_id(const struct auxiliary_device_id *id,\n\t\t\t\t\t\t\t    const struct auxiliary_device *auxdev)\n{\n\tfor (; id->name[0]; id++) {\n\t\tconst char *p = strrchr(dev_name(&auxdev->dev), '.');\n\t\tint match_size;\n\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tmatch_size = p - dev_name(&auxdev->dev);\n\n\t\t \n\t\tif (strlen(id->name) == match_size &&\n\t\t    !strncmp(dev_name(&auxdev->dev), id->name, match_size))\n\t\t\treturn id;\n\t}\n\treturn NULL;\n}\n\nstatic int auxiliary_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct auxiliary_device *auxdev = to_auxiliary_dev(dev);\n\tstruct auxiliary_driver *auxdrv = to_auxiliary_drv(drv);\n\n\treturn !!auxiliary_match_id(auxdrv->id_table, auxdev);\n}\n\nstatic int auxiliary_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst char *name, *p;\n\n\tname = dev_name(dev);\n\tp = strrchr(name, '.');\n\n\treturn add_uevent_var(env, \"MODALIAS=%s%.*s\", AUXILIARY_MODULE_PREFIX,\n\t\t\t      (int)(p - name), name);\n}\n\nstatic const struct dev_pm_ops auxiliary_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(pm_generic_runtime_suspend, pm_generic_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_generic_suspend, pm_generic_resume)\n};\n\nstatic int auxiliary_bus_probe(struct device *dev)\n{\n\tstruct auxiliary_driver *auxdrv = to_auxiliary_drv(dev->driver);\n\tstruct auxiliary_device *auxdev = to_auxiliary_dev(dev);\n\tint ret;\n\n\tret = dev_pm_domain_attach(dev, true);\n\tif (ret) {\n\t\tdev_warn(dev, \"Failed to attach to PM Domain : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = auxdrv->probe(auxdev, auxiliary_match_id(auxdrv->id_table, auxdev));\n\tif (ret)\n\t\tdev_pm_domain_detach(dev, true);\n\n\treturn ret;\n}\n\nstatic void auxiliary_bus_remove(struct device *dev)\n{\n\tstruct auxiliary_driver *auxdrv = to_auxiliary_drv(dev->driver);\n\tstruct auxiliary_device *auxdev = to_auxiliary_dev(dev);\n\n\tif (auxdrv->remove)\n\t\tauxdrv->remove(auxdev);\n\tdev_pm_domain_detach(dev, true);\n}\n\nstatic void auxiliary_bus_shutdown(struct device *dev)\n{\n\tstruct auxiliary_driver *auxdrv = NULL;\n\tstruct auxiliary_device *auxdev;\n\n\tif (dev->driver) {\n\t\tauxdrv = to_auxiliary_drv(dev->driver);\n\t\tauxdev = to_auxiliary_dev(dev);\n\t}\n\n\tif (auxdrv && auxdrv->shutdown)\n\t\tauxdrv->shutdown(auxdev);\n}\n\nstatic struct bus_type auxiliary_bus_type = {\n\t.name = \"auxiliary\",\n\t.probe = auxiliary_bus_probe,\n\t.remove = auxiliary_bus_remove,\n\t.shutdown = auxiliary_bus_shutdown,\n\t.match = auxiliary_match,\n\t.uevent = auxiliary_uevent,\n\t.pm = &auxiliary_dev_pm_ops,\n};\n\n \nint auxiliary_device_init(struct auxiliary_device *auxdev)\n{\n\tstruct device *dev = &auxdev->dev;\n\n\tif (!dev->parent) {\n\t\tpr_err(\"auxiliary_device has a NULL dev->parent\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!auxdev->name) {\n\t\tpr_err(\"auxiliary_device has a NULL name\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev->bus = &auxiliary_bus_type;\n\tdevice_initialize(&auxdev->dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(auxiliary_device_init);\n\n \nint __auxiliary_device_add(struct auxiliary_device *auxdev, const char *modname)\n{\n\tstruct device *dev = &auxdev->dev;\n\tint ret;\n\n\tif (!modname) {\n\t\tdev_err(dev, \"auxiliary device modname is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = dev_set_name(dev, \"%s.%s.%d\", modname, auxdev->name, auxdev->id);\n\tif (ret) {\n\t\tdev_err(dev, \"auxiliary device dev_set_name failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = device_add(dev);\n\tif (ret)\n\t\tdev_err(dev, \"adding auxiliary device failed!: %d\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__auxiliary_device_add);\n\n \nstruct auxiliary_device *auxiliary_find_device(struct device *start,\n\t\t\t\t\t       const void *data,\n\t\t\t\t\t       int (*match)(struct device *dev, const void *data))\n{\n\tstruct device *dev;\n\n\tdev = bus_find_device(&auxiliary_bus_type, start, data, match);\n\tif (!dev)\n\t\treturn NULL;\n\n\treturn to_auxiliary_dev(dev);\n}\nEXPORT_SYMBOL_GPL(auxiliary_find_device);\n\n \nint __auxiliary_driver_register(struct auxiliary_driver *auxdrv,\n\t\t\t\tstruct module *owner, const char *modname)\n{\n\tint ret;\n\n\tif (WARN_ON(!auxdrv->probe) || WARN_ON(!auxdrv->id_table))\n\t\treturn -EINVAL;\n\n\tif (auxdrv->name)\n\t\tauxdrv->driver.name = kasprintf(GFP_KERNEL, \"%s.%s\", modname,\n\t\t\t\t\t\tauxdrv->name);\n\telse\n\t\tauxdrv->driver.name = kasprintf(GFP_KERNEL, \"%s\", modname);\n\tif (!auxdrv->driver.name)\n\t\treturn -ENOMEM;\n\n\tauxdrv->driver.owner = owner;\n\tauxdrv->driver.bus = &auxiliary_bus_type;\n\tauxdrv->driver.mod_name = modname;\n\n\tret = driver_register(&auxdrv->driver);\n\tif (ret)\n\t\tkfree(auxdrv->driver.name);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__auxiliary_driver_register);\n\n \nvoid auxiliary_driver_unregister(struct auxiliary_driver *auxdrv)\n{\n\tdriver_unregister(&auxdrv->driver);\n\tkfree(auxdrv->driver.name);\n}\nEXPORT_SYMBOL_GPL(auxiliary_driver_unregister);\n\nvoid __init auxiliary_bus_init(void)\n{\n\tWARN_ON(bus_register(&auxiliary_bus_type));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}