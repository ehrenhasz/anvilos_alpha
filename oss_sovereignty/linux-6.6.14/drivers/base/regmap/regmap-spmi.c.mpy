{
  "module_name": "regmap-spmi.c",
  "hash_id": "b49b61b46b5f63a3d86d48fb8563de7ad68339d3ddf3ad0d197dce620ce33088",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regmap-spmi.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/regmap.h>\n#include <linux/spmi.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int regmap_spmi_base_read(void *context,\n\t\t\t\t const void *reg, size_t reg_size,\n\t\t\t\t void *val, size_t val_size)\n{\n\tu8 addr = *(u8 *)reg;\n\tint err = 0;\n\n\tBUG_ON(reg_size != 1);\n\n\twhile (val_size-- && !err)\n\t\terr = spmi_register_read(context, addr++, val++);\n\n\treturn err;\n}\n\nstatic int regmap_spmi_base_gather_write(void *context,\n\t\t\t\t\t const void *reg, size_t reg_size,\n\t\t\t\t\t const void *val, size_t val_size)\n{\n\tconst u8 *data = val;\n\tu8 addr = *(u8 *)reg;\n\tint err = 0;\n\n\tBUG_ON(reg_size != 1);\n\n\t \n\tif (addr == 0 && val_size) {\n\t\terr = spmi_register_zero_write(context, *data);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\tdata++;\n\t\taddr++;\n\t\tval_size--;\n\t}\n\n\twhile (val_size) {\n\t\terr = spmi_register_write(context, addr, *data);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\tdata++;\n\t\taddr++;\n\t\tval_size--;\n\t}\n\nerr_out:\n\treturn err;\n}\n\nstatic int regmap_spmi_base_write(void *context, const void *data,\n\t\t\t\t  size_t count)\n{\n\tBUG_ON(count < 1);\n\treturn regmap_spmi_base_gather_write(context, data, 1, data + 1,\n\t\t\t\t\t     count - 1);\n}\n\nstatic const struct regmap_bus regmap_spmi_base = {\n\t.read\t\t\t\t= regmap_spmi_base_read,\n\t.write\t\t\t\t= regmap_spmi_base_write,\n\t.gather_write\t\t\t= regmap_spmi_base_gather_write,\n\t.reg_format_endian_default\t= REGMAP_ENDIAN_NATIVE,\n\t.val_format_endian_default\t= REGMAP_ENDIAN_NATIVE,\n};\n\nstruct regmap *__regmap_init_spmi_base(struct spmi_device *sdev,\n\t\t\t\t       const struct regmap_config *config,\n\t\t\t\t       struct lock_class_key *lock_key,\n\t\t\t\t       const char *lock_name)\n{\n\treturn __regmap_init(&sdev->dev, &regmap_spmi_base, sdev, config,\n\t\t\t     lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__regmap_init_spmi_base);\n\nstruct regmap *__devm_regmap_init_spmi_base(struct spmi_device *sdev,\n\t\t\t\t\t    const struct regmap_config *config,\n\t\t\t\t\t    struct lock_class_key *lock_key,\n\t\t\t\t\t    const char *lock_name)\n{\n\treturn __devm_regmap_init(&sdev->dev, &regmap_spmi_base, sdev, config,\n\t\t\t\t  lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__devm_regmap_init_spmi_base);\n\nstatic int regmap_spmi_ext_read(void *context,\n\t\t\t\tconst void *reg, size_t reg_size,\n\t\t\t\tvoid *val, size_t val_size)\n{\n\tint err = 0;\n\tsize_t len;\n\tu16 addr;\n\n\tBUG_ON(reg_size != 2);\n\n\taddr = *(u16 *)reg;\n\n\t \n\twhile (addr <= 0xFF && val_size) {\n\t\tlen = min_t(size_t, val_size, 16);\n\n\t\terr = spmi_ext_register_read(context, addr, val, len);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\taddr += len;\n\t\tval += len;\n\t\tval_size -= len;\n\t}\n\n\twhile (val_size) {\n\t\tlen = min_t(size_t, val_size, 8);\n\n\t\terr = spmi_ext_register_readl(context, addr, val, len);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\taddr += len;\n\t\tval += len;\n\t\tval_size -= len;\n\t}\n\nerr_out:\n\treturn err;\n}\n\nstatic int regmap_spmi_ext_gather_write(void *context,\n\t\t\t\t\tconst void *reg, size_t reg_size,\n\t\t\t\t\tconst void *val, size_t val_size)\n{\n\tint err = 0;\n\tsize_t len;\n\tu16 addr;\n\n\tBUG_ON(reg_size != 2);\n\n\taddr = *(u16 *)reg;\n\n\twhile (addr <= 0xFF && val_size) {\n\t\tlen = min_t(size_t, val_size, 16);\n\n\t\terr = spmi_ext_register_write(context, addr, val, len);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\taddr += len;\n\t\tval += len;\n\t\tval_size -= len;\n\t}\n\n\twhile (val_size) {\n\t\tlen = min_t(size_t, val_size, 8);\n\n\t\terr = spmi_ext_register_writel(context, addr, val, len);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\taddr += len;\n\t\tval += len;\n\t\tval_size -= len;\n\t}\n\nerr_out:\n\treturn err;\n}\n\nstatic int regmap_spmi_ext_write(void *context, const void *data,\n\t\t\t\t size_t count)\n{\n\tBUG_ON(count < 2);\n\treturn regmap_spmi_ext_gather_write(context, data, 2, data + 2,\n\t\t\t\t\t    count - 2);\n}\n\nstatic const struct regmap_bus regmap_spmi_ext = {\n\t.read\t\t\t\t= regmap_spmi_ext_read,\n\t.write\t\t\t\t= regmap_spmi_ext_write,\n\t.gather_write\t\t\t= regmap_spmi_ext_gather_write,\n\t.reg_format_endian_default\t= REGMAP_ENDIAN_NATIVE,\n\t.val_format_endian_default\t= REGMAP_ENDIAN_NATIVE,\n};\n\nstruct regmap *__regmap_init_spmi_ext(struct spmi_device *sdev,\n\t\t\t\t      const struct regmap_config *config,\n\t\t\t\t      struct lock_class_key *lock_key,\n\t\t\t\t      const char *lock_name)\n{\n\treturn __regmap_init(&sdev->dev, &regmap_spmi_ext, sdev, config,\n\t\t\t     lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__regmap_init_spmi_ext);\n\nstruct regmap *__devm_regmap_init_spmi_ext(struct spmi_device *sdev,\n\t\t\t\t\t   const struct regmap_config *config,\n\t\t\t\t\t   struct lock_class_key *lock_key,\n\t\t\t\t\t   const char *lock_name)\n{\n\treturn __devm_regmap_init(&sdev->dev, &regmap_spmi_ext, sdev, config,\n\t\t\t\t  lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__devm_regmap_init_spmi_ext);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}