{
  "module_name": "regmap-raw-ram.c",
  "hash_id": "2f8cc24e6e783f9cb9822e71dcbf9abd6910d36384582b0fae2bf78af3a4712b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regmap-raw-ram.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/swab.h>\n\n#include \"internal.h\"\n\nstatic unsigned int decode_reg(enum regmap_endian endian, const void *reg)\n{\n\tconst u16 *r = reg;\n\n\tif (endian == REGMAP_ENDIAN_BIG)\n\t\treturn be16_to_cpu(*r);\n\telse\n\t\treturn le16_to_cpu(*r);\n}\n\nstatic int regmap_raw_ram_gather_write(void *context,\n\t\t\t\t       const void *reg, size_t reg_len,\n\t\t\t\t       const void *val, size_t val_len)\n{\n\tstruct regmap_ram_data *data = context;\n\tunsigned int r;\n\tu16 *our_buf = (u16 *)data->vals;\n\tint i;\n\n\tif (reg_len != 2)\n\t\treturn -EINVAL;\n\tif (val_len % 2)\n\t\treturn -EINVAL;\n\n\tr = decode_reg(data->reg_endian, reg);\n\tmemcpy(&our_buf[r], val, val_len);\n\n\tfor (i = 0; i < val_len / 2; i++)\n\t\tdata->written[r + i] = true;\n\t\n\treturn 0;\n}\n\nstatic int regmap_raw_ram_write(void *context, const void *data, size_t count)\n{\n\treturn regmap_raw_ram_gather_write(context, data, 2,\n\t\t\t\t\t   data + 2, count - 2);\n}\n\nstatic int regmap_raw_ram_read(void *context,\n\t\t\t       const void *reg, size_t reg_len,\n\t\t\t       void *val, size_t val_len)\n{\n\tstruct regmap_ram_data *data = context;\n\tunsigned int r;\n\tu16 *our_buf = (u16 *)data->vals;\n\tint i;\n\n\tif (reg_len != 2)\n\t\treturn -EINVAL;\n\tif (val_len % 2)\n\t\treturn -EINVAL;\n\n\tr = decode_reg(data->reg_endian, reg);\n\tmemcpy(val, &our_buf[r], val_len);\n\n\tfor (i = 0; i < val_len / 2; i++)\n\t\tdata->read[r + i] = true;\n\n\treturn 0;\n}\n\nstatic void regmap_raw_ram_free_context(void *context)\n{\n\tstruct regmap_ram_data *data = context;\n\n\tkfree(data->vals);\n\tkfree(data->read);\n\tkfree(data->written);\n\tkfree(data);\n}\n\nstatic const struct regmap_bus regmap_raw_ram = {\n\t.fast_io = true,\n\t.write = regmap_raw_ram_write,\n\t.gather_write = regmap_raw_ram_gather_write,\n\t.read = regmap_raw_ram_read,\n\t.free_context = regmap_raw_ram_free_context,\n};\n\nstruct regmap *__regmap_init_raw_ram(const struct regmap_config *config,\n\t\t\t\t     struct regmap_ram_data *data,\n\t\t\t\t     struct lock_class_key *lock_key,\n\t\t\t\t     const char *lock_name)\n{\n\tstruct regmap *map;\n\n\tif (config->reg_bits != 16)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!config->max_register) {\n\t\tpr_crit(\"No max_register specified for RAM regmap\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tdata->read = kcalloc(sizeof(bool), config->max_register + 1,\n\t\t\t     GFP_KERNEL);\n\tif (!data->read)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata->written = kcalloc(sizeof(bool), config->max_register + 1,\n\t\t\t\tGFP_KERNEL);\n\tif (!data->written)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata->reg_endian = config->reg_format_endian;\n\n\tmap = __regmap_init(NULL, &regmap_raw_ram, data, config,\n\t\t\t    lock_key, lock_name);\n\n\treturn map;\n}\nEXPORT_SYMBOL_GPL(__regmap_init_raw_ram);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}