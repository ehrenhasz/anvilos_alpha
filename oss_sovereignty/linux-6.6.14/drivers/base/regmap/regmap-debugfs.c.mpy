{
  "module_name": "regmap-debugfs.c",
  "hash_id": "17ea3f3d3ac8ff7ee3a34094f380552714481d38bcb02d742641dbc22706eb49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regmap-debugfs.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/list.h>\n\n#include \"internal.h\"\n\nstruct regmap_debugfs_node {\n\tstruct regmap *map;\n\tstruct list_head link;\n};\n\nstatic unsigned int dummy_index;\nstatic struct dentry *regmap_debugfs_root;\nstatic LIST_HEAD(regmap_debugfs_early_list);\nstatic DEFINE_MUTEX(regmap_debugfs_early_lock);\n\n \nstatic size_t regmap_calc_reg_len(int max_val)\n{\n\treturn snprintf(NULL, 0, \"%x\", max_val);\n}\n\nstatic ssize_t regmap_name_read_file(struct file *file,\n\t\t\t\t     char __user *user_buf, size_t count,\n\t\t\t\t     loff_t *ppos)\n{\n\tstruct regmap *map = file->private_data;\n\tconst char *name = \"nodev\";\n\tint ret;\n\tchar *buf;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (map->dev && map->dev->driver)\n\t\tname = map->dev->driver->name;\n\n\tret = snprintf(buf, PAGE_SIZE, \"%s\\n\", name);\n\tif (ret >= PAGE_SIZE) {\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations regmap_name_fops = {\n\t.open = simple_open,\n\t.read = regmap_name_read_file,\n\t.llseek = default_llseek,\n};\n\nstatic void regmap_debugfs_free_dump_cache(struct regmap *map)\n{\n\tstruct regmap_debugfs_off_cache *c;\n\n\twhile (!list_empty(&map->debugfs_off_cache)) {\n\t\tc = list_first_entry(&map->debugfs_off_cache,\n\t\t\t\t     struct regmap_debugfs_off_cache,\n\t\t\t\t     list);\n\t\tlist_del(&c->list);\n\t\tkfree(c);\n\t}\n}\n\nstatic bool regmap_printable(struct regmap *map, unsigned int reg)\n{\n\tif (regmap_precious(map, reg))\n\t\treturn false;\n\n\tif (!regmap_readable(map, reg) && !regmap_cached(map, reg))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic unsigned int regmap_debugfs_get_dump_start(struct regmap *map,\n\t\t\t\t\t\t  unsigned int base,\n\t\t\t\t\t\t  loff_t from,\n\t\t\t\t\t\t  loff_t *pos)\n{\n\tstruct regmap_debugfs_off_cache *c = NULL;\n\tloff_t p = 0;\n\tunsigned int i, ret;\n\tunsigned int fpos_offset;\n\tunsigned int reg_offset;\n\n\t \n\tif (base)\n\t\treturn base;\n\n\t \n\tmutex_lock(&map->cache_lock);\n\ti = base;\n\tif (list_empty(&map->debugfs_off_cache)) {\n\t\tfor (; i <= map->max_register; i += map->reg_stride) {\n\t\t\t \n\t\t\tif (!regmap_printable(map, i)) {\n\t\t\t\tif (c) {\n\t\t\t\t\tc->max = p - 1;\n\t\t\t\t\tc->max_reg = i - map->reg_stride;\n\t\t\t\t\tlist_add_tail(&c->list,\n\t\t\t\t\t\t      &map->debugfs_off_cache);\n\t\t\t\t\tc = NULL;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!c) {\n\t\t\t\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tregmap_debugfs_free_dump_cache(map);\n\t\t\t\t\tmutex_unlock(&map->cache_lock);\n\t\t\t\t\treturn base;\n\t\t\t\t}\n\t\t\t\tc->min = p;\n\t\t\t\tc->base_reg = i;\n\t\t\t}\n\n\t\t\tp += map->debugfs_tot_len;\n\t\t}\n\t}\n\n\t \n\tif (c) {\n\t\tc->max = p - 1;\n\t\tc->max_reg = i - map->reg_stride;\n\t\tlist_add_tail(&c->list,\n\t\t\t      &map->debugfs_off_cache);\n\t}\n\n\t \n\tWARN_ON(list_empty(&map->debugfs_off_cache));\n\tret = base;\n\n\t \n\tlist_for_each_entry(c, &map->debugfs_off_cache, list) {\n\t\tif (from >= c->min && from <= c->max) {\n\t\t\tfpos_offset = from - c->min;\n\t\t\treg_offset = fpos_offset / map->debugfs_tot_len;\n\t\t\t*pos = c->min + (reg_offset * map->debugfs_tot_len);\n\t\t\tmutex_unlock(&map->cache_lock);\n\t\t\treturn c->base_reg + (reg_offset * map->reg_stride);\n\t\t}\n\n\t\t*pos = c->max;\n\t\tret = c->max_reg;\n\t}\n\tmutex_unlock(&map->cache_lock);\n\n\treturn ret;\n}\n\nstatic inline void regmap_calc_tot_len(struct regmap *map,\n\t\t\t\t       void *buf, size_t count)\n{\n\t \n\tif (!map->debugfs_tot_len) {\n\t\tmap->debugfs_reg_len = regmap_calc_reg_len(map->max_register);\n\t\tmap->debugfs_val_len = 2 * map->format.val_bytes;\n\t\tmap->debugfs_tot_len = map->debugfs_reg_len +\n\t\t\tmap->debugfs_val_len + 3;       \n\t}\n}\n\nstatic int regmap_next_readable_reg(struct regmap *map, int reg)\n{\n\tstruct regmap_debugfs_off_cache *c;\n\tint ret = -EINVAL;\n\n\tif (regmap_printable(map, reg + map->reg_stride)) {\n\t\tret = reg + map->reg_stride;\n\t} else {\n\t\tmutex_lock(&map->cache_lock);\n\t\tlist_for_each_entry(c, &map->debugfs_off_cache, list) {\n\t\t\tif (reg > c->max_reg)\n\t\t\t\tcontinue;\n\t\t\tif (reg < c->base_reg) {\n\t\t\t\tret = c->base_reg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&map->cache_lock);\n\t}\n\treturn ret;\n}\n\nstatic ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,\n\t\t\t\t   unsigned int to, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tsize_t buf_pos = 0;\n\tloff_t p = *ppos;\n\tssize_t ret;\n\tint i;\n\tchar *buf;\n\tunsigned int val, start_reg;\n\n\tif (*ppos < 0 || !count)\n\t\treturn -EINVAL;\n\n\tif (count > (PAGE_SIZE << MAX_ORDER))\n\t\tcount = PAGE_SIZE << MAX_ORDER;\n\n\tbuf = kmalloc(count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tregmap_calc_tot_len(map, buf, count);\n\n\t \n\tstart_reg = regmap_debugfs_get_dump_start(map, from, *ppos, &p);\n\n\tfor (i = start_reg; i >= 0 && i <= to;\n\t     i = regmap_next_readable_reg(map, i)) {\n\n\t\t \n\t\tif (p >= *ppos) {\n\t\t\t \n\t\t\tif (buf_pos + map->debugfs_tot_len > count)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tsnprintf(buf + buf_pos, count - buf_pos, \"%.*x: \",\n\t\t\t\t map->debugfs_reg_len, i - from);\n\t\t\tbuf_pos += map->debugfs_reg_len + 2;\n\n\t\t\t \n\t\t\tret = regmap_read(map, i, &val);\n\t\t\tif (ret == 0)\n\t\t\t\tsnprintf(buf + buf_pos, count - buf_pos,\n\t\t\t\t\t \"%.*x\", map->debugfs_val_len, val);\n\t\t\telse\n\t\t\t\tmemset(buf + buf_pos, 'X',\n\t\t\t\t       map->debugfs_val_len);\n\t\t\tbuf_pos += 2 * map->format.val_bytes;\n\n\t\t\tbuf[buf_pos++] = '\\n';\n\t\t}\n\t\tp += map->debugfs_tot_len;\n\t}\n\n\tret = buf_pos;\n\n\tif (copy_to_user(user_buf, buf, buf_pos)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t*ppos += buf_pos;\n\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct regmap *map = file->private_data;\n\n\treturn regmap_read_debugfs(map, 0, map->max_register, user_buf,\n\t\t\t\t   count, ppos);\n}\n\n#undef REGMAP_ALLOW_WRITE_DEBUGFS\n#ifdef REGMAP_ALLOW_WRITE_DEBUGFS\n \nstatic ssize_t regmap_map_write_file(struct file *file,\n\t\t\t\t     const char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tchar *start = buf;\n\tunsigned long reg, value;\n\tstruct regmap *map = file->private_data;\n\tint ret;\n\n\tbuf_size = min(count, (sizeof(buf)-1));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\tbuf[buf_size] = 0;\n\n\twhile (*start == ' ')\n\t\tstart++;\n\treg = simple_strtoul(start, &start, 16);\n\twhile (*start == ' ')\n\t\tstart++;\n\tif (kstrtoul(start, 16, &value))\n\t\treturn -EINVAL;\n\n\t \n\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\n\tret = regmap_write(map, reg, value);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn buf_size;\n}\n#else\n#define regmap_map_write_file NULL\n#endif\n\nstatic const struct file_operations regmap_map_fops = {\n\t.open = simple_open,\n\t.read = regmap_map_read_file,\n\t.write = regmap_map_write_file,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t regmap_range_read_file(struct file *file, char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct regmap_range_node *range = file->private_data;\n\tstruct regmap *map = range->map;\n\n\treturn regmap_read_debugfs(map, range->range_min, range->range_max,\n\t\t\t\t   user_buf, count, ppos);\n}\n\nstatic const struct file_operations regmap_range_fops = {\n\t.open = simple_open,\n\t.read = regmap_range_read_file,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t regmap_reg_ranges_read_file(struct file *file,\n\t\t\t\t\t   char __user *user_buf, size_t count,\n\t\t\t\t\t   loff_t *ppos)\n{\n\tstruct regmap *map = file->private_data;\n\tstruct regmap_debugfs_off_cache *c;\n\tloff_t p = 0;\n\tsize_t buf_pos = 0;\n\tchar *buf;\n\tchar *entry;\n\tint ret;\n\tunsigned int entry_len;\n\n\tif (*ppos < 0 || !count)\n\t\treturn -EINVAL;\n\n\tif (count > (PAGE_SIZE << MAX_ORDER))\n\t\tcount = PAGE_SIZE << MAX_ORDER;\n\n\tbuf = kmalloc(count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tentry = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!entry) {\n\t\tkfree(buf);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tregmap_calc_tot_len(map, buf, count);\n\tregmap_debugfs_get_dump_start(map, 0, *ppos, &p);\n\n\t \n\tp = 0;\n\tmutex_lock(&map->cache_lock);\n\tlist_for_each_entry(c, &map->debugfs_off_cache, list) {\n\t\tentry_len = snprintf(entry, PAGE_SIZE, \"%x-%x\\n\",\n\t\t\t\t     c->base_reg, c->max_reg);\n\t\tif (p >= *ppos) {\n\t\t\tif (buf_pos + entry_len > count)\n\t\t\t\tbreak;\n\t\t\tmemcpy(buf + buf_pos, entry, entry_len);\n\t\t\tbuf_pos += entry_len;\n\t\t}\n\t\tp += entry_len;\n\t}\n\tmutex_unlock(&map->cache_lock);\n\n\tkfree(entry);\n\tret = buf_pos;\n\n\tif (copy_to_user(user_buf, buf, buf_pos)) {\n\t\tret = -EFAULT;\n\t\tgoto out_buf;\n\t}\n\n\t*ppos += buf_pos;\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations regmap_reg_ranges_fops = {\n\t.open = simple_open,\n\t.read = regmap_reg_ranges_read_file,\n\t.llseek = default_llseek,\n};\n\nstatic int regmap_access_show(struct seq_file *s, void *ignored)\n{\n\tstruct regmap *map = s->private;\n\tint i, reg_len;\n\n\treg_len = regmap_calc_reg_len(map->max_register);\n\n\tfor (i = 0; i <= map->max_register; i += map->reg_stride) {\n\t\t \n\t\tif (!regmap_readable(map, i) && !regmap_writeable(map, i))\n\t\t\tcontinue;\n\n\t\t \n\t\tseq_printf(s, \"%.*x: %c %c %c %c\\n\", reg_len, i,\n\t\t\t   regmap_readable(map, i) ? 'y' : 'n',\n\t\t\t   regmap_writeable(map, i) ? 'y' : 'n',\n\t\t\t   regmap_volatile(map, i) ? 'y' : 'n',\n\t\t\t   regmap_precious(map, i) ? 'y' : 'n');\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(regmap_access);\n\nstatic ssize_t regmap_cache_only_write_file(struct file *file,\n\t\t\t\t\t    const char __user *user_buf,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct regmap *map = container_of(file->private_data,\n\t\t\t\t\t  struct regmap, cache_only);\n\tbool new_val, require_sync = false;\n\tint err;\n\n\terr = kstrtobool_from_user(user_buf, count, &new_val);\n\t \n\tif (err)\n\t\treturn count;\n\n\terr = debugfs_file_get(file->f_path.dentry);\n\tif (err)\n\t\treturn err;\n\n\tmap->lock(map->lock_arg);\n\n\tif (new_val && !map->cache_only) {\n\t\tdev_warn(map->dev, \"debugfs cache_only=Y forced\\n\");\n\t\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\t} else if (!new_val && map->cache_only) {\n\t\tdev_warn(map->dev, \"debugfs cache_only=N forced: syncing cache\\n\");\n\t\trequire_sync = true;\n\t}\n\tmap->cache_only = new_val;\n\n\tmap->unlock(map->lock_arg);\n\tdebugfs_file_put(file->f_path.dentry);\n\n\tif (require_sync) {\n\t\terr = regcache_sync(map);\n\t\tif (err)\n\t\t\tdev_err(map->dev, \"Failed to sync cache %d\\n\", err);\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations regmap_cache_only_fops = {\n\t.open = simple_open,\n\t.read = debugfs_read_file_bool,\n\t.write = regmap_cache_only_write_file,\n};\n\nstatic ssize_t regmap_cache_bypass_write_file(struct file *file,\n\t\t\t\t\t      const char __user *user_buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct regmap *map = container_of(file->private_data,\n\t\t\t\t\t  struct regmap, cache_bypass);\n\tbool new_val;\n\tint err;\n\n\terr = kstrtobool_from_user(user_buf, count, &new_val);\n\t \n\tif (err)\n\t\treturn count;\n\n\terr = debugfs_file_get(file->f_path.dentry);\n\tif (err)\n\t\treturn err;\n\n\tmap->lock(map->lock_arg);\n\n\tif (new_val && !map->cache_bypass) {\n\t\tdev_warn(map->dev, \"debugfs cache_bypass=Y forced\\n\");\n\t\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\t} else if (!new_val && map->cache_bypass) {\n\t\tdev_warn(map->dev, \"debugfs cache_bypass=N forced\\n\");\n\t}\n\tmap->cache_bypass = new_val;\n\n\tmap->unlock(map->lock_arg);\n\tdebugfs_file_put(file->f_path.dentry);\n\n\treturn count;\n}\n\nstatic const struct file_operations regmap_cache_bypass_fops = {\n\t.open = simple_open,\n\t.read = debugfs_read_file_bool,\n\t.write = regmap_cache_bypass_write_file,\n};\n\nvoid regmap_debugfs_init(struct regmap *map)\n{\n\tstruct rb_node *next;\n\tstruct regmap_range_node *range_node;\n\tconst char *devname = \"dummy\";\n\tconst char *name = map->name;\n\n\t \n\tif (map->debugfs_disable) {\n\t\tdev_dbg(map->dev, \"regmap locking disabled - not creating debugfs entries\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (!regmap_debugfs_root) {\n\t\tstruct regmap_debugfs_node *node;\n\t\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\t\tif (!node)\n\t\t\treturn;\n\t\tnode->map = map;\n\t\tmutex_lock(&regmap_debugfs_early_lock);\n\t\tlist_add(&node->link, &regmap_debugfs_early_list);\n\t\tmutex_unlock(&regmap_debugfs_early_lock);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&map->debugfs_off_cache);\n\tmutex_init(&map->cache_lock);\n\n\tif (map->dev)\n\t\tdevname = dev_name(map->dev);\n\n\tif (name) {\n\t\tif (!map->debugfs_name) {\n\t\t\tmap->debugfs_name = kasprintf(GFP_KERNEL, \"%s-%s\",\n\t\t\t\t\t      devname, name);\n\t\t\tif (!map->debugfs_name)\n\t\t\t\treturn;\n\t\t}\n\t\tname = map->debugfs_name;\n\t} else {\n\t\tname = devname;\n\t}\n\n\tif (!strcmp(name, \"dummy\")) {\n\t\tkfree(map->debugfs_name);\n\t\tmap->debugfs_name = kasprintf(GFP_KERNEL, \"dummy%d\",\n\t\t\t\t\t\tdummy_index);\n\t\tif (!map->debugfs_name)\n\t\t\treturn;\n\t\tname = map->debugfs_name;\n\t\tdummy_index++;\n\t}\n\n\tmap->debugfs = debugfs_create_dir(name, regmap_debugfs_root);\n\n\tdebugfs_create_file(\"name\", 0400, map->debugfs,\n\t\t\t    map, &regmap_name_fops);\n\n\tdebugfs_create_file(\"range\", 0400, map->debugfs,\n\t\t\t    map, &regmap_reg_ranges_fops);\n\n\tif (map->max_register || regmap_readable(map, 0)) {\n\t\tumode_t registers_mode;\n\n#if defined(REGMAP_ALLOW_WRITE_DEBUGFS)\n\t\tregisters_mode = 0600;\n#else\n\t\tregisters_mode = 0400;\n#endif\n\n\t\tdebugfs_create_file(\"registers\", registers_mode, map->debugfs,\n\t\t\t\t    map, &regmap_map_fops);\n\t\tdebugfs_create_file(\"access\", 0400, map->debugfs,\n\t\t\t\t    map, &regmap_access_fops);\n\t}\n\n\tif (map->cache_type) {\n\t\tdebugfs_create_file(\"cache_only\", 0600, map->debugfs,\n\t\t\t\t    &map->cache_only, &regmap_cache_only_fops);\n\t\tdebugfs_create_bool(\"cache_dirty\", 0400, map->debugfs,\n\t\t\t\t    &map->cache_dirty);\n\t\tdebugfs_create_file(\"cache_bypass\", 0600, map->debugfs,\n\t\t\t\t    &map->cache_bypass,\n\t\t\t\t    &regmap_cache_bypass_fops);\n\t}\n\n\t \n#undef REGMAP_ALLOW_FORCE_WRITE_FIELD_DEBUGFS\n#ifdef REGMAP_ALLOW_FORCE_WRITE_FIELD_DEBUGFS\n\tdebugfs_create_bool(\"force_write_field\", 0600, map->debugfs,\n\t\t\t    &map->force_write_field);\n#endif\n\n\tnext = rb_first(&map->range_tree);\n\twhile (next) {\n\t\trange_node = rb_entry(next, struct regmap_range_node, node);\n\n\t\tif (range_node->name)\n\t\t\tdebugfs_create_file(range_node->name, 0400,\n\t\t\t\t\t    map->debugfs, range_node,\n\t\t\t\t\t    &regmap_range_fops);\n\n\t\tnext = rb_next(&range_node->node);\n\t}\n\n\tif (map->cache_ops && map->cache_ops->debugfs_init)\n\t\tmap->cache_ops->debugfs_init(map);\n}\n\nvoid regmap_debugfs_exit(struct regmap *map)\n{\n\tif (map->debugfs) {\n\t\tdebugfs_remove_recursive(map->debugfs);\n\t\tmutex_lock(&map->cache_lock);\n\t\tregmap_debugfs_free_dump_cache(map);\n\t\tmutex_unlock(&map->cache_lock);\n\t\tkfree(map->debugfs_name);\n\t\tmap->debugfs_name = NULL;\n\t} else {\n\t\tstruct regmap_debugfs_node *node, *tmp;\n\n\t\tmutex_lock(&regmap_debugfs_early_lock);\n\t\tlist_for_each_entry_safe(node, tmp, &regmap_debugfs_early_list,\n\t\t\t\t\t link) {\n\t\t\tif (node->map == map) {\n\t\t\t\tlist_del(&node->link);\n\t\t\t\tkfree(node);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&regmap_debugfs_early_lock);\n\t}\n}\n\nvoid regmap_debugfs_initcall(void)\n{\n\tstruct regmap_debugfs_node *node, *tmp;\n\n\tregmap_debugfs_root = debugfs_create_dir(\"regmap\", NULL);\n\n\tmutex_lock(&regmap_debugfs_early_lock);\n\tlist_for_each_entry_safe(node, tmp, &regmap_debugfs_early_list, link) {\n\t\tregmap_debugfs_init(node->map);\n\t\tlist_del(&node->link);\n\t\tkfree(node);\n\t}\n\tmutex_unlock(&regmap_debugfs_early_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}