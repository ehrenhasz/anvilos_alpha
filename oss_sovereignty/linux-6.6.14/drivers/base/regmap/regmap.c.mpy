{
  "module_name": "regmap.c",
  "hash_id": "677ebbc208e8b8030d691acca3822df57c476f899c553415a421aead61d04dc9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regmap.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/property.h>\n#include <linux/rbtree.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/log2.h>\n#include <linux/hwspinlock.h>\n#include <asm/unaligned.h>\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\n#include \"internal.h\"\n\n \n#undef LOG_DEVICE\n\n#ifdef LOG_DEVICE\nstatic inline bool regmap_should_log(struct regmap *map)\n{\n\treturn (map->dev && strcmp(dev_name(map->dev), LOG_DEVICE) == 0);\n}\n#else\nstatic inline bool regmap_should_log(struct regmap *map) { return false; }\n#endif\n\n\nstatic int _regmap_update_bits(struct regmap *map, unsigned int reg,\n\t\t\t       unsigned int mask, unsigned int val,\n\t\t\t       bool *change, bool force_write);\n\nstatic int _regmap_bus_reg_read(void *context, unsigned int reg,\n\t\t\t\tunsigned int *val);\nstatic int _regmap_bus_read(void *context, unsigned int reg,\n\t\t\t    unsigned int *val);\nstatic int _regmap_bus_formatted_write(void *context, unsigned int reg,\n\t\t\t\t       unsigned int val);\nstatic int _regmap_bus_reg_write(void *context, unsigned int reg,\n\t\t\t\t unsigned int val);\nstatic int _regmap_bus_raw_write(void *context, unsigned int reg,\n\t\t\t\t unsigned int val);\n\nbool regmap_reg_in_ranges(unsigned int reg,\n\t\t\t  const struct regmap_range *ranges,\n\t\t\t  unsigned int nranges)\n{\n\tconst struct regmap_range *r;\n\tint i;\n\n\tfor (i = 0, r = ranges; i < nranges; i++, r++)\n\t\tif (regmap_reg_in_range(reg, r))\n\t\t\treturn true;\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(regmap_reg_in_ranges);\n\nbool regmap_check_range_table(struct regmap *map, unsigned int reg,\n\t\t\t      const struct regmap_access_table *table)\n{\n\t \n\tif (regmap_reg_in_ranges(reg, table->no_ranges, table->n_no_ranges))\n\t\treturn false;\n\n\t \n\tif (!table->n_yes_ranges)\n\t\treturn true;\n\n\treturn regmap_reg_in_ranges(reg, table->yes_ranges,\n\t\t\t\t    table->n_yes_ranges);\n}\nEXPORT_SYMBOL_GPL(regmap_check_range_table);\n\nbool regmap_writeable(struct regmap *map, unsigned int reg)\n{\n\tif (map->max_register && reg > map->max_register)\n\t\treturn false;\n\n\tif (map->writeable_reg)\n\t\treturn map->writeable_reg(map->dev, reg);\n\n\tif (map->wr_table)\n\t\treturn regmap_check_range_table(map, reg, map->wr_table);\n\n\treturn true;\n}\n\nbool regmap_cached(struct regmap *map, unsigned int reg)\n{\n\tint ret;\n\tunsigned int val;\n\n\tif (map->cache_type == REGCACHE_NONE)\n\t\treturn false;\n\n\tif (!map->cache_ops)\n\t\treturn false;\n\n\tif (map->max_register && reg > map->max_register)\n\t\treturn false;\n\n\tmap->lock(map->lock_arg);\n\tret = regcache_read(map, reg, &val);\n\tmap->unlock(map->lock_arg);\n\tif (ret)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool regmap_readable(struct regmap *map, unsigned int reg)\n{\n\tif (!map->reg_read)\n\t\treturn false;\n\n\tif (map->max_register && reg > map->max_register)\n\t\treturn false;\n\n\tif (map->format.format_write)\n\t\treturn false;\n\n\tif (map->readable_reg)\n\t\treturn map->readable_reg(map->dev, reg);\n\n\tif (map->rd_table)\n\t\treturn regmap_check_range_table(map, reg, map->rd_table);\n\n\treturn true;\n}\n\nbool regmap_volatile(struct regmap *map, unsigned int reg)\n{\n\tif (!map->format.format_write && !regmap_readable(map, reg))\n\t\treturn false;\n\n\tif (map->volatile_reg)\n\t\treturn map->volatile_reg(map->dev, reg);\n\n\tif (map->volatile_table)\n\t\treturn regmap_check_range_table(map, reg, map->volatile_table);\n\n\tif (map->cache_ops)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nbool regmap_precious(struct regmap *map, unsigned int reg)\n{\n\tif (!regmap_readable(map, reg))\n\t\treturn false;\n\n\tif (map->precious_reg)\n\t\treturn map->precious_reg(map->dev, reg);\n\n\tif (map->precious_table)\n\t\treturn regmap_check_range_table(map, reg, map->precious_table);\n\n\treturn false;\n}\n\nbool regmap_writeable_noinc(struct regmap *map, unsigned int reg)\n{\n\tif (map->writeable_noinc_reg)\n\t\treturn map->writeable_noinc_reg(map->dev, reg);\n\n\tif (map->wr_noinc_table)\n\t\treturn regmap_check_range_table(map, reg, map->wr_noinc_table);\n\n\treturn true;\n}\n\nbool regmap_readable_noinc(struct regmap *map, unsigned int reg)\n{\n\tif (map->readable_noinc_reg)\n\t\treturn map->readable_noinc_reg(map->dev, reg);\n\n\tif (map->rd_noinc_table)\n\t\treturn regmap_check_range_table(map, reg, map->rd_noinc_table);\n\n\treturn true;\n}\n\nstatic bool regmap_volatile_range(struct regmap *map, unsigned int reg,\n\tsize_t num)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num; i++)\n\t\tif (!regmap_volatile(map, reg + regmap_get_offset(map, i)))\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic void regmap_format_12_20_write(struct regmap *map,\n\t\t\t\t     unsigned int reg, unsigned int val)\n{\n\tu8 *out = map->work_buf;\n\n\tout[0] = reg >> 4;\n\tout[1] = (reg << 4) | (val >> 16);\n\tout[2] = val >> 8;\n\tout[3] = val;\n}\n\n\nstatic void regmap_format_2_6_write(struct regmap *map,\n\t\t\t\t     unsigned int reg, unsigned int val)\n{\n\tu8 *out = map->work_buf;\n\n\t*out = (reg << 6) | val;\n}\n\nstatic void regmap_format_4_12_write(struct regmap *map,\n\t\t\t\t     unsigned int reg, unsigned int val)\n{\n\t__be16 *out = map->work_buf;\n\t*out = cpu_to_be16((reg << 12) | val);\n}\n\nstatic void regmap_format_7_9_write(struct regmap *map,\n\t\t\t\t    unsigned int reg, unsigned int val)\n{\n\t__be16 *out = map->work_buf;\n\t*out = cpu_to_be16((reg << 9) | val);\n}\n\nstatic void regmap_format_7_17_write(struct regmap *map,\n\t\t\t\t    unsigned int reg, unsigned int val)\n{\n\tu8 *out = map->work_buf;\n\n\tout[2] = val;\n\tout[1] = val >> 8;\n\tout[0] = (val >> 16) | (reg << 1);\n}\n\nstatic void regmap_format_10_14_write(struct regmap *map,\n\t\t\t\t    unsigned int reg, unsigned int val)\n{\n\tu8 *out = map->work_buf;\n\n\tout[2] = val;\n\tout[1] = (val >> 8) | (reg << 6);\n\tout[0] = reg >> 2;\n}\n\nstatic void regmap_format_8(void *buf, unsigned int val, unsigned int shift)\n{\n\tu8 *b = buf;\n\n\tb[0] = val << shift;\n}\n\nstatic void regmap_format_16_be(void *buf, unsigned int val, unsigned int shift)\n{\n\tput_unaligned_be16(val << shift, buf);\n}\n\nstatic void regmap_format_16_le(void *buf, unsigned int val, unsigned int shift)\n{\n\tput_unaligned_le16(val << shift, buf);\n}\n\nstatic void regmap_format_16_native(void *buf, unsigned int val,\n\t\t\t\t    unsigned int shift)\n{\n\tu16 v = val << shift;\n\n\tmemcpy(buf, &v, sizeof(v));\n}\n\nstatic void regmap_format_24_be(void *buf, unsigned int val, unsigned int shift)\n{\n\tput_unaligned_be24(val << shift, buf);\n}\n\nstatic void regmap_format_32_be(void *buf, unsigned int val, unsigned int shift)\n{\n\tput_unaligned_be32(val << shift, buf);\n}\n\nstatic void regmap_format_32_le(void *buf, unsigned int val, unsigned int shift)\n{\n\tput_unaligned_le32(val << shift, buf);\n}\n\nstatic void regmap_format_32_native(void *buf, unsigned int val,\n\t\t\t\t    unsigned int shift)\n{\n\tu32 v = val << shift;\n\n\tmemcpy(buf, &v, sizeof(v));\n}\n\nstatic void regmap_parse_inplace_noop(void *buf)\n{\n}\n\nstatic unsigned int regmap_parse_8(const void *buf)\n{\n\tconst u8 *b = buf;\n\n\treturn b[0];\n}\n\nstatic unsigned int regmap_parse_16_be(const void *buf)\n{\n\treturn get_unaligned_be16(buf);\n}\n\nstatic unsigned int regmap_parse_16_le(const void *buf)\n{\n\treturn get_unaligned_le16(buf);\n}\n\nstatic void regmap_parse_16_be_inplace(void *buf)\n{\n\tu16 v = get_unaligned_be16(buf);\n\n\tmemcpy(buf, &v, sizeof(v));\n}\n\nstatic void regmap_parse_16_le_inplace(void *buf)\n{\n\tu16 v = get_unaligned_le16(buf);\n\n\tmemcpy(buf, &v, sizeof(v));\n}\n\nstatic unsigned int regmap_parse_16_native(const void *buf)\n{\n\tu16 v;\n\n\tmemcpy(&v, buf, sizeof(v));\n\treturn v;\n}\n\nstatic unsigned int regmap_parse_24_be(const void *buf)\n{\n\treturn get_unaligned_be24(buf);\n}\n\nstatic unsigned int regmap_parse_32_be(const void *buf)\n{\n\treturn get_unaligned_be32(buf);\n}\n\nstatic unsigned int regmap_parse_32_le(const void *buf)\n{\n\treturn get_unaligned_le32(buf);\n}\n\nstatic void regmap_parse_32_be_inplace(void *buf)\n{\n\tu32 v = get_unaligned_be32(buf);\n\n\tmemcpy(buf, &v, sizeof(v));\n}\n\nstatic void regmap_parse_32_le_inplace(void *buf)\n{\n\tu32 v = get_unaligned_le32(buf);\n\n\tmemcpy(buf, &v, sizeof(v));\n}\n\nstatic unsigned int regmap_parse_32_native(const void *buf)\n{\n\tu32 v;\n\n\tmemcpy(&v, buf, sizeof(v));\n\treturn v;\n}\n\nstatic void regmap_lock_hwlock(void *__map)\n{\n\tstruct regmap *map = __map;\n\n\thwspin_lock_timeout(map->hwlock, UINT_MAX);\n}\n\nstatic void regmap_lock_hwlock_irq(void *__map)\n{\n\tstruct regmap *map = __map;\n\n\thwspin_lock_timeout_irq(map->hwlock, UINT_MAX);\n}\n\nstatic void regmap_lock_hwlock_irqsave(void *__map)\n{\n\tstruct regmap *map = __map;\n\n\thwspin_lock_timeout_irqsave(map->hwlock, UINT_MAX,\n\t\t\t\t    &map->spinlock_flags);\n}\n\nstatic void regmap_unlock_hwlock(void *__map)\n{\n\tstruct regmap *map = __map;\n\n\thwspin_unlock(map->hwlock);\n}\n\nstatic void regmap_unlock_hwlock_irq(void *__map)\n{\n\tstruct regmap *map = __map;\n\n\thwspin_unlock_irq(map->hwlock);\n}\n\nstatic void regmap_unlock_hwlock_irqrestore(void *__map)\n{\n\tstruct regmap *map = __map;\n\n\thwspin_unlock_irqrestore(map->hwlock, &map->spinlock_flags);\n}\n\nstatic void regmap_lock_unlock_none(void *__map)\n{\n\n}\n\nstatic void regmap_lock_mutex(void *__map)\n{\n\tstruct regmap *map = __map;\n\tmutex_lock(&map->mutex);\n}\n\nstatic void regmap_unlock_mutex(void *__map)\n{\n\tstruct regmap *map = __map;\n\tmutex_unlock(&map->mutex);\n}\n\nstatic void regmap_lock_spinlock(void *__map)\n__acquires(&map->spinlock)\n{\n\tstruct regmap *map = __map;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&map->spinlock, flags);\n\tmap->spinlock_flags = flags;\n}\n\nstatic void regmap_unlock_spinlock(void *__map)\n__releases(&map->spinlock)\n{\n\tstruct regmap *map = __map;\n\tspin_unlock_irqrestore(&map->spinlock, map->spinlock_flags);\n}\n\nstatic void regmap_lock_raw_spinlock(void *__map)\n__acquires(&map->raw_spinlock)\n{\n\tstruct regmap *map = __map;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&map->raw_spinlock, flags);\n\tmap->raw_spinlock_flags = flags;\n}\n\nstatic void regmap_unlock_raw_spinlock(void *__map)\n__releases(&map->raw_spinlock)\n{\n\tstruct regmap *map = __map;\n\traw_spin_unlock_irqrestore(&map->raw_spinlock, map->raw_spinlock_flags);\n}\n\nstatic void dev_get_regmap_release(struct device *dev, void *res)\n{\n\t \n}\n\nstatic bool _regmap_range_add(struct regmap *map,\n\t\t\t      struct regmap_range_node *data)\n{\n\tstruct rb_root *root = &map->range_tree;\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\n\twhile (*new) {\n\t\tstruct regmap_range_node *this =\n\t\t\trb_entry(*new, struct regmap_range_node, node);\n\n\t\tparent = *new;\n\t\tif (data->range_max < this->range_min)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (data->range_min > this->range_max)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn false;\n\t}\n\n\trb_link_node(&data->node, parent, new);\n\trb_insert_color(&data->node, root);\n\n\treturn true;\n}\n\nstatic struct regmap_range_node *_regmap_range_lookup(struct regmap *map,\n\t\t\t\t\t\t      unsigned int reg)\n{\n\tstruct rb_node *node = map->range_tree.rb_node;\n\n\twhile (node) {\n\t\tstruct regmap_range_node *this =\n\t\t\trb_entry(node, struct regmap_range_node, node);\n\n\t\tif (reg < this->range_min)\n\t\t\tnode = node->rb_left;\n\t\telse if (reg > this->range_max)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn this;\n\t}\n\n\treturn NULL;\n}\n\nstatic void regmap_range_exit(struct regmap *map)\n{\n\tstruct rb_node *next;\n\tstruct regmap_range_node *range_node;\n\n\tnext = rb_first(&map->range_tree);\n\twhile (next) {\n\t\trange_node = rb_entry(next, struct regmap_range_node, node);\n\t\tnext = rb_next(&range_node->node);\n\t\trb_erase(&range_node->node, &map->range_tree);\n\t\tkfree(range_node);\n\t}\n\n\tkfree(map->selector_work_buf);\n}\n\nstatic int regmap_set_name(struct regmap *map, const struct regmap_config *config)\n{\n\tif (config->name) {\n\t\tconst char *name = kstrdup_const(config->name, GFP_KERNEL);\n\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\n\t\tkfree_const(map->name);\n\t\tmap->name = name;\n\t}\n\n\treturn 0;\n}\n\nint regmap_attach_dev(struct device *dev, struct regmap *map,\n\t\t      const struct regmap_config *config)\n{\n\tstruct regmap **m;\n\tint ret;\n\n\tmap->dev = dev;\n\n\tret = regmap_set_name(map, config);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_debugfs_exit(map);\n\tregmap_debugfs_init(map);\n\n\t \n\tm = devres_alloc(dev_get_regmap_release, sizeof(*m), GFP_KERNEL);\n\tif (!m) {\n\t\tregmap_debugfs_exit(map);\n\t\treturn -ENOMEM;\n\t}\n\t*m = map;\n\tdevres_add(dev, m);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regmap_attach_dev);\n\nstatic enum regmap_endian regmap_get_reg_endian(const struct regmap_bus *bus,\n\t\t\t\t\tconst struct regmap_config *config)\n{\n\tenum regmap_endian endian;\n\n\t \n\tendian = config->reg_format_endian;\n\n\t \n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t \n\tif (bus && bus->reg_format_endian_default)\n\t\tendian = bus->reg_format_endian_default;\n\n\t \n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t \n\treturn REGMAP_ENDIAN_BIG;\n}\n\nenum regmap_endian regmap_get_val_endian(struct device *dev,\n\t\t\t\t\t const struct regmap_bus *bus,\n\t\t\t\t\t const struct regmap_config *config)\n{\n\tstruct fwnode_handle *fwnode = dev ? dev_fwnode(dev) : NULL;\n\tenum regmap_endian endian;\n\n\t \n\tendian = config->val_format_endian;\n\n\t \n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t \n\tif (fwnode_property_read_bool(fwnode, \"big-endian\"))\n\t\tendian = REGMAP_ENDIAN_BIG;\n\telse if (fwnode_property_read_bool(fwnode, \"little-endian\"))\n\t\tendian = REGMAP_ENDIAN_LITTLE;\n\telse if (fwnode_property_read_bool(fwnode, \"native-endian\"))\n\t\tendian = REGMAP_ENDIAN_NATIVE;\n\n\t \n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t \n\tif (bus && bus->val_format_endian_default)\n\t\tendian = bus->val_format_endian_default;\n\n\t \n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t \n\treturn REGMAP_ENDIAN_BIG;\n}\nEXPORT_SYMBOL_GPL(regmap_get_val_endian);\n\nstruct regmap *__regmap_init(struct device *dev,\n\t\t\t     const struct regmap_bus *bus,\n\t\t\t     void *bus_context,\n\t\t\t     const struct regmap_config *config,\n\t\t\t     struct lock_class_key *lock_key,\n\t\t\t     const char *lock_name)\n{\n\tstruct regmap *map;\n\tint ret = -EINVAL;\n\tenum regmap_endian reg_endian, val_endian;\n\tint i, j;\n\n\tif (!config)\n\t\tgoto err;\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (map == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = regmap_set_name(map, config);\n\tif (ret)\n\t\tgoto err_map;\n\n\tret = -EINVAL;  \n\n\tif (config->disable_locking) {\n\t\tmap->lock = map->unlock = regmap_lock_unlock_none;\n\t\tmap->can_sleep = config->can_sleep;\n\t\tregmap_debugfs_disable(map);\n\t} else if (config->lock && config->unlock) {\n\t\tmap->lock = config->lock;\n\t\tmap->unlock = config->unlock;\n\t\tmap->lock_arg = config->lock_arg;\n\t\tmap->can_sleep = config->can_sleep;\n\t} else if (config->use_hwlock) {\n\t\tmap->hwlock = hwspin_lock_request_specific(config->hwlock_id);\n\t\tif (!map->hwlock) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_name;\n\t\t}\n\n\t\tswitch (config->hwlock_mode) {\n\t\tcase HWLOCK_IRQSTATE:\n\t\t\tmap->lock = regmap_lock_hwlock_irqsave;\n\t\t\tmap->unlock = regmap_unlock_hwlock_irqrestore;\n\t\t\tbreak;\n\t\tcase HWLOCK_IRQ:\n\t\t\tmap->lock = regmap_lock_hwlock_irq;\n\t\t\tmap->unlock = regmap_unlock_hwlock_irq;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmap->lock = regmap_lock_hwlock;\n\t\t\tmap->unlock = regmap_unlock_hwlock;\n\t\t\tbreak;\n\t\t}\n\n\t\tmap->lock_arg = map;\n\t} else {\n\t\tif ((bus && bus->fast_io) ||\n\t\t    config->fast_io) {\n\t\t\tif (config->use_raw_spinlock) {\n\t\t\t\traw_spin_lock_init(&map->raw_spinlock);\n\t\t\t\tmap->lock = regmap_lock_raw_spinlock;\n\t\t\t\tmap->unlock = regmap_unlock_raw_spinlock;\n\t\t\t\tlockdep_set_class_and_name(&map->raw_spinlock,\n\t\t\t\t\t\t\t   lock_key, lock_name);\n\t\t\t} else {\n\t\t\t\tspin_lock_init(&map->spinlock);\n\t\t\t\tmap->lock = regmap_lock_spinlock;\n\t\t\t\tmap->unlock = regmap_unlock_spinlock;\n\t\t\t\tlockdep_set_class_and_name(&map->spinlock,\n\t\t\t\t\t\t\t   lock_key, lock_name);\n\t\t\t}\n\t\t} else {\n\t\t\tmutex_init(&map->mutex);\n\t\t\tmap->lock = regmap_lock_mutex;\n\t\t\tmap->unlock = regmap_unlock_mutex;\n\t\t\tmap->can_sleep = true;\n\t\t\tlockdep_set_class_and_name(&map->mutex,\n\t\t\t\t\t\t   lock_key, lock_name);\n\t\t}\n\t\tmap->lock_arg = map;\n\t}\n\n\t \n\tif ((bus && bus->fast_io) || config->fast_io)\n\t\tmap->alloc_flags = GFP_ATOMIC;\n\telse\n\t\tmap->alloc_flags = GFP_KERNEL;\n\n\tmap->reg_base = config->reg_base;\n\n\tmap->format.reg_bytes = DIV_ROUND_UP(config->reg_bits, 8);\n\tmap->format.pad_bytes = config->pad_bits / 8;\n\tmap->format.reg_shift = config->reg_shift;\n\tmap->format.val_bytes = DIV_ROUND_UP(config->val_bits, 8);\n\tmap->format.buf_size = DIV_ROUND_UP(config->reg_bits +\n\t\t\tconfig->val_bits + config->pad_bits, 8);\n\tmap->reg_shift = config->pad_bits % 8;\n\tif (config->reg_stride)\n\t\tmap->reg_stride = config->reg_stride;\n\telse\n\t\tmap->reg_stride = 1;\n\tif (is_power_of_2(map->reg_stride))\n\t\tmap->reg_stride_order = ilog2(map->reg_stride);\n\telse\n\t\tmap->reg_stride_order = -1;\n\tmap->use_single_read = config->use_single_read || !(config->read || (bus && bus->read));\n\tmap->use_single_write = config->use_single_write || !(config->write || (bus && bus->write));\n\tmap->can_multi_write = config->can_multi_write && (config->write || (bus && bus->write));\n\tif (bus) {\n\t\tmap->max_raw_read = bus->max_raw_read;\n\t\tmap->max_raw_write = bus->max_raw_write;\n\t} else if (config->max_raw_read && config->max_raw_write) {\n\t\tmap->max_raw_read = config->max_raw_read;\n\t\tmap->max_raw_write = config->max_raw_write;\n\t}\n\tmap->dev = dev;\n\tmap->bus = bus;\n\tmap->bus_context = bus_context;\n\tmap->max_register = config->max_register;\n\tmap->wr_table = config->wr_table;\n\tmap->rd_table = config->rd_table;\n\tmap->volatile_table = config->volatile_table;\n\tmap->precious_table = config->precious_table;\n\tmap->wr_noinc_table = config->wr_noinc_table;\n\tmap->rd_noinc_table = config->rd_noinc_table;\n\tmap->writeable_reg = config->writeable_reg;\n\tmap->readable_reg = config->readable_reg;\n\tmap->volatile_reg = config->volatile_reg;\n\tmap->precious_reg = config->precious_reg;\n\tmap->writeable_noinc_reg = config->writeable_noinc_reg;\n\tmap->readable_noinc_reg = config->readable_noinc_reg;\n\tmap->cache_type = config->cache_type;\n\n\tspin_lock_init(&map->async_lock);\n\tINIT_LIST_HEAD(&map->async_list);\n\tINIT_LIST_HEAD(&map->async_free);\n\tinit_waitqueue_head(&map->async_waitq);\n\n\tif (config->read_flag_mask ||\n\t    config->write_flag_mask ||\n\t    config->zero_flag_mask) {\n\t\tmap->read_flag_mask = config->read_flag_mask;\n\t\tmap->write_flag_mask = config->write_flag_mask;\n\t} else if (bus) {\n\t\tmap->read_flag_mask = bus->read_flag_mask;\n\t}\n\n\tif (config && config->read && config->write) {\n\t\tmap->reg_read  = _regmap_bus_read;\n\t\tif (config->reg_update_bits)\n\t\t\tmap->reg_update_bits = config->reg_update_bits;\n\n\t\t \n\t\tmap->read = config->read;\n\t\tmap->write = config->write;\n\n\t\treg_endian = REGMAP_ENDIAN_NATIVE;\n\t\tval_endian = REGMAP_ENDIAN_NATIVE;\n\t} else if (!bus) {\n\t\tmap->reg_read  = config->reg_read;\n\t\tmap->reg_write = config->reg_write;\n\t\tmap->reg_update_bits = config->reg_update_bits;\n\n\t\tmap->defer_caching = false;\n\t\tgoto skip_format_initialization;\n\t} else if (!bus->read || !bus->write) {\n\t\tmap->reg_read = _regmap_bus_reg_read;\n\t\tmap->reg_write = _regmap_bus_reg_write;\n\t\tmap->reg_update_bits = bus->reg_update_bits;\n\n\t\tmap->defer_caching = false;\n\t\tgoto skip_format_initialization;\n\t} else {\n\t\tmap->reg_read  = _regmap_bus_read;\n\t\tmap->reg_update_bits = bus->reg_update_bits;\n\t\t \n\t\tmap->read = bus->read;\n\t\tmap->write = bus->write;\n\n\t\treg_endian = regmap_get_reg_endian(bus, config);\n\t\tval_endian = regmap_get_val_endian(dev, bus, config);\n\t}\n\n\tswitch (config->reg_bits + map->reg_shift) {\n\tcase 2:\n\t\tswitch (config->val_bits) {\n\t\tcase 6:\n\t\t\tmap->format.format_write = regmap_format_2_6_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tswitch (config->val_bits) {\n\t\tcase 12:\n\t\t\tmap->format.format_write = regmap_format_4_12_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 7:\n\t\tswitch (config->val_bits) {\n\t\tcase 9:\n\t\t\tmap->format.format_write = regmap_format_7_9_write;\n\t\t\tbreak;\n\t\tcase 17:\n\t\t\tmap->format.format_write = regmap_format_7_17_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 10:\n\t\tswitch (config->val_bits) {\n\t\tcase 14:\n\t\t\tmap->format.format_write = regmap_format_10_14_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 12:\n\t\tswitch (config->val_bits) {\n\t\tcase 20:\n\t\t\tmap->format.format_write = regmap_format_12_20_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 8:\n\t\tmap->format.format_reg = regmap_format_8;\n\t\tbreak;\n\n\tcase 16:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_16_be;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_reg = regmap_format_16_le;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_reg = regmap_format_16_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 24:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_24_be;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 32:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_32_be;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_reg = regmap_format_32_le;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_reg = regmap_format_32_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tgoto err_hwlock;\n\t}\n\n\tif (val_endian == REGMAP_ENDIAN_NATIVE)\n\t\tmap->format.parse_inplace = regmap_parse_inplace_noop;\n\n\tswitch (config->val_bits) {\n\tcase 8:\n\t\tmap->format.format_val = regmap_format_8;\n\t\tmap->format.parse_val = regmap_parse_8;\n\t\tmap->format.parse_inplace = regmap_parse_inplace_noop;\n\t\tbreak;\n\tcase 16:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_16_be;\n\t\t\tmap->format.parse_val = regmap_parse_16_be;\n\t\t\tmap->format.parse_inplace = regmap_parse_16_be_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_val = regmap_format_16_le;\n\t\t\tmap->format.parse_val = regmap_parse_16_le;\n\t\t\tmap->format.parse_inplace = regmap_parse_16_le_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_val = regmap_format_16_native;\n\t\t\tmap->format.parse_val = regmap_parse_16_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_24_be;\n\t\t\tmap->format.parse_val = regmap_parse_24_be;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_32_be;\n\t\t\tmap->format.parse_val = regmap_parse_32_be;\n\t\t\tmap->format.parse_inplace = regmap_parse_32_be_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_val = regmap_format_32_le;\n\t\t\tmap->format.parse_val = regmap_parse_32_le;\n\t\t\tmap->format.parse_inplace = regmap_parse_32_le_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_val = regmap_format_32_native;\n\t\t\tmap->format.parse_val = regmap_parse_32_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (map->format.format_write) {\n\t\tif ((reg_endian != REGMAP_ENDIAN_BIG) ||\n\t\t    (val_endian != REGMAP_ENDIAN_BIG))\n\t\t\tgoto err_hwlock;\n\t\tmap->use_single_write = true;\n\t}\n\n\tif (!map->format.format_write &&\n\t    !(map->format.format_reg && map->format.format_val))\n\t\tgoto err_hwlock;\n\n\tmap->work_buf = kzalloc(map->format.buf_size, GFP_KERNEL);\n\tif (map->work_buf == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_hwlock;\n\t}\n\n\tif (map->format.format_write) {\n\t\tmap->defer_caching = false;\n\t\tmap->reg_write = _regmap_bus_formatted_write;\n\t} else if (map->format.format_val) {\n\t\tmap->defer_caching = true;\n\t\tmap->reg_write = _regmap_bus_raw_write;\n\t}\n\nskip_format_initialization:\n\n\tmap->range_tree = RB_ROOT;\n\tfor (i = 0; i < config->num_ranges; i++) {\n\t\tconst struct regmap_range_cfg *range_cfg = &config->ranges[i];\n\t\tstruct regmap_range_node *new;\n\n\t\t \n\t\tif (range_cfg->range_max < range_cfg->range_min) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: %d < %d\\n\", i,\n\t\t\t\trange_cfg->range_max, range_cfg->range_min);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->range_max > map->max_register) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: %d > %d\\n\", i,\n\t\t\t\trange_cfg->range_max, map->max_register);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->selector_reg > map->max_register) {\n\t\t\tdev_err(map->dev,\n\t\t\t\t\"Invalid range %d: selector out of map\\n\", i);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->window_len == 0) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: window_len 0\\n\",\n\t\t\t\ti);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < config->num_ranges; j++) {\n\t\t\tunsigned int sel_reg = config->ranges[j].selector_reg;\n\t\t\tunsigned int win_min = config->ranges[j].window_start;\n\t\t\tunsigned int win_max = win_min +\n\t\t\t\t\t       config->ranges[j].window_len - 1;\n\n\t\t\t \n\t\t\tif (j == i)\n\t\t\t\tcontinue;\n\n\t\t\tif (range_cfg->range_min <= sel_reg &&\n\t\t\t    sel_reg <= range_cfg->range_max) {\n\t\t\t\tdev_err(map->dev,\n\t\t\t\t\t\"Range %d: selector for %d in window\\n\",\n\t\t\t\t\ti, j);\n\t\t\t\tgoto err_range;\n\t\t\t}\n\n\t\t\tif (!(win_max < range_cfg->range_min ||\n\t\t\t      win_min > range_cfg->range_max)) {\n\t\t\t\tdev_err(map->dev,\n\t\t\t\t\t\"Range %d: window for %d in window\\n\",\n\t\t\t\t\ti, j);\n\t\t\t\tgoto err_range;\n\t\t\t}\n\t\t}\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (new == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tnew->map = map;\n\t\tnew->name = range_cfg->name;\n\t\tnew->range_min = range_cfg->range_min;\n\t\tnew->range_max = range_cfg->range_max;\n\t\tnew->selector_reg = range_cfg->selector_reg;\n\t\tnew->selector_mask = range_cfg->selector_mask;\n\t\tnew->selector_shift = range_cfg->selector_shift;\n\t\tnew->window_start = range_cfg->window_start;\n\t\tnew->window_len = range_cfg->window_len;\n\n\t\tif (!_regmap_range_add(map, new)) {\n\t\t\tdev_err(map->dev, \"Failed to add range %d\\n\", i);\n\t\t\tkfree(new);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (map->selector_work_buf == NULL) {\n\t\t\tmap->selector_work_buf =\n\t\t\t\tkzalloc(map->format.buf_size, GFP_KERNEL);\n\t\t\tif (map->selector_work_buf == NULL) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_range;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = regcache_init(map, config);\n\tif (ret != 0)\n\t\tgoto err_range;\n\n\tif (dev) {\n\t\tret = regmap_attach_dev(dev, map, config);\n\t\tif (ret != 0)\n\t\t\tgoto err_regcache;\n\t} else {\n\t\tregmap_debugfs_init(map);\n\t}\n\n\treturn map;\n\nerr_regcache:\n\tregcache_exit(map);\nerr_range:\n\tregmap_range_exit(map);\n\tkfree(map->work_buf);\nerr_hwlock:\n\tif (map->hwlock)\n\t\thwspin_lock_free(map->hwlock);\nerr_name:\n\tkfree_const(map->name);\nerr_map:\n\tkfree(map);\nerr:\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(__regmap_init);\n\nstatic void devm_regmap_release(struct device *dev, void *res)\n{\n\tregmap_exit(*(struct regmap **)res);\n}\n\nstruct regmap *__devm_regmap_init(struct device *dev,\n\t\t\t\t  const struct regmap_bus *bus,\n\t\t\t\t  void *bus_context,\n\t\t\t\t  const struct regmap_config *config,\n\t\t\t\t  struct lock_class_key *lock_key,\n\t\t\t\t  const char *lock_name)\n{\n\tstruct regmap **ptr, *regmap;\n\n\tptr = devres_alloc(devm_regmap_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tregmap = __regmap_init(dev, bus, bus_context, config,\n\t\t\t       lock_key, lock_name);\n\tif (!IS_ERR(regmap)) {\n\t\t*ptr = regmap;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn regmap;\n}\nEXPORT_SYMBOL_GPL(__devm_regmap_init);\n\nstatic void regmap_field_init(struct regmap_field *rm_field,\n\tstruct regmap *regmap, struct reg_field reg_field)\n{\n\trm_field->regmap = regmap;\n\trm_field->reg = reg_field.reg;\n\trm_field->shift = reg_field.lsb;\n\trm_field->mask = GENMASK(reg_field.msb, reg_field.lsb);\n\n\tWARN_ONCE(rm_field->mask == 0, \"invalid empty mask defined\\n\");\n\n\trm_field->id_size = reg_field.id_size;\n\trm_field->id_offset = reg_field.id_offset;\n}\n\n \nstruct regmap_field *devm_regmap_field_alloc(struct device *dev,\n\t\tstruct regmap *regmap, struct reg_field reg_field)\n{\n\tstruct regmap_field *rm_field = devm_kzalloc(dev,\n\t\t\t\t\tsizeof(*rm_field), GFP_KERNEL);\n\tif (!rm_field)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tregmap_field_init(rm_field, regmap, reg_field);\n\n\treturn rm_field;\n\n}\nEXPORT_SYMBOL_GPL(devm_regmap_field_alloc);\n\n\n \nint regmap_field_bulk_alloc(struct regmap *regmap,\n\t\t\t    struct regmap_field **rm_field,\n\t\t\t    const struct reg_field *reg_field,\n\t\t\t    int num_fields)\n{\n\tstruct regmap_field *rf;\n\tint i;\n\n\trf = kcalloc(num_fields, sizeof(*rf), GFP_KERNEL);\n\tif (!rf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_fields; i++) {\n\t\tregmap_field_init(&rf[i], regmap, reg_field[i]);\n\t\trm_field[i] = &rf[i];\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regmap_field_bulk_alloc);\n\n \nint devm_regmap_field_bulk_alloc(struct device *dev,\n\t\t\t\t struct regmap *regmap,\n\t\t\t\t struct regmap_field **rm_field,\n\t\t\t\t const struct reg_field *reg_field,\n\t\t\t\t int num_fields)\n{\n\tstruct regmap_field *rf;\n\tint i;\n\n\trf = devm_kcalloc(dev, num_fields, sizeof(*rf), GFP_KERNEL);\n\tif (!rf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_fields; i++) {\n\t\tregmap_field_init(&rf[i], regmap, reg_field[i]);\n\t\trm_field[i] = &rf[i];\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_regmap_field_bulk_alloc);\n\n \nvoid regmap_field_bulk_free(struct regmap_field *field)\n{\n\tkfree(field);\n}\nEXPORT_SYMBOL_GPL(regmap_field_bulk_free);\n\n \nvoid devm_regmap_field_bulk_free(struct device *dev,\n\t\t\t\t struct regmap_field *field)\n{\n\tdevm_kfree(dev, field);\n}\nEXPORT_SYMBOL_GPL(devm_regmap_field_bulk_free);\n\n \nvoid devm_regmap_field_free(struct device *dev,\n\tstruct regmap_field *field)\n{\n\tdevm_kfree(dev, field);\n}\nEXPORT_SYMBOL_GPL(devm_regmap_field_free);\n\n \nstruct regmap_field *regmap_field_alloc(struct regmap *regmap,\n\t\tstruct reg_field reg_field)\n{\n\tstruct regmap_field *rm_field = kzalloc(sizeof(*rm_field), GFP_KERNEL);\n\n\tif (!rm_field)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tregmap_field_init(rm_field, regmap, reg_field);\n\n\treturn rm_field;\n}\nEXPORT_SYMBOL_GPL(regmap_field_alloc);\n\n \nvoid regmap_field_free(struct regmap_field *field)\n{\n\tkfree(field);\n}\nEXPORT_SYMBOL_GPL(regmap_field_free);\n\n \nint regmap_reinit_cache(struct regmap *map, const struct regmap_config *config)\n{\n\tint ret;\n\n\tregcache_exit(map);\n\tregmap_debugfs_exit(map);\n\n\tmap->max_register = config->max_register;\n\tmap->writeable_reg = config->writeable_reg;\n\tmap->readable_reg = config->readable_reg;\n\tmap->volatile_reg = config->volatile_reg;\n\tmap->precious_reg = config->precious_reg;\n\tmap->writeable_noinc_reg = config->writeable_noinc_reg;\n\tmap->readable_noinc_reg = config->readable_noinc_reg;\n\tmap->cache_type = config->cache_type;\n\n\tret = regmap_set_name(map, config);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_debugfs_init(map);\n\n\tmap->cache_bypass = false;\n\tmap->cache_only = false;\n\n\treturn regcache_init(map, config);\n}\nEXPORT_SYMBOL_GPL(regmap_reinit_cache);\n\n \nvoid regmap_exit(struct regmap *map)\n{\n\tstruct regmap_async *async;\n\n\tregcache_exit(map);\n\tregmap_debugfs_exit(map);\n\tregmap_range_exit(map);\n\tif (map->bus && map->bus->free_context)\n\t\tmap->bus->free_context(map->bus_context);\n\tkfree(map->work_buf);\n\twhile (!list_empty(&map->async_free)) {\n\t\tasync = list_first_entry_or_null(&map->async_free,\n\t\t\t\t\t\t struct regmap_async,\n\t\t\t\t\t\t list);\n\t\tlist_del(&async->list);\n\t\tkfree(async->work_buf);\n\t\tkfree(async);\n\t}\n\tif (map->hwlock)\n\t\thwspin_lock_free(map->hwlock);\n\tif (map->lock == regmap_lock_mutex)\n\t\tmutex_destroy(&map->mutex);\n\tkfree_const(map->name);\n\tkfree(map->patch);\n\tif (map->bus && map->bus->free_on_exit)\n\t\tkfree(map->bus);\n\tkfree(map);\n}\nEXPORT_SYMBOL_GPL(regmap_exit);\n\nstatic int dev_get_regmap_match(struct device *dev, void *res, void *data)\n{\n\tstruct regmap **r = res;\n\tif (!r || !*r) {\n\t\tWARN_ON(!r || !*r);\n\t\treturn 0;\n\t}\n\n\t \n\tif (data)\n\t\treturn (*r)->name && !strcmp((*r)->name, data);\n\telse\n\t\treturn 1;\n}\n\n \nstruct regmap *dev_get_regmap(struct device *dev, const char *name)\n{\n\tstruct regmap **r = devres_find(dev, dev_get_regmap_release,\n\t\t\t\t\tdev_get_regmap_match, (void *)name);\n\n\tif (!r)\n\t\treturn NULL;\n\treturn *r;\n}\nEXPORT_SYMBOL_GPL(dev_get_regmap);\n\n \nstruct device *regmap_get_device(struct regmap *map)\n{\n\treturn map->dev;\n}\nEXPORT_SYMBOL_GPL(regmap_get_device);\n\nstatic int _regmap_select_page(struct regmap *map, unsigned int *reg,\n\t\t\t       struct regmap_range_node *range,\n\t\t\t       unsigned int val_num)\n{\n\tvoid *orig_work_buf;\n\tunsigned int win_offset;\n\tunsigned int win_page;\n\tbool page_chg;\n\tint ret;\n\n\twin_offset = (*reg - range->range_min) % range->window_len;\n\twin_page = (*reg - range->range_min) / range->window_len;\n\n\tif (val_num > 1) {\n\t\t \n\t\tif (*reg + val_num - 1 > range->range_max)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (val_num > range->window_len - win_offset)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (val_num > 1 ||\n\t    range->window_start + win_offset != range->selector_reg) {\n\t\t \n\t\torig_work_buf = map->work_buf;\n\t\tmap->work_buf = map->selector_work_buf;\n\n\t\tret = _regmap_update_bits(map, range->selector_reg,\n\t\t\t\t\t  range->selector_mask,\n\t\t\t\t\t  win_page << range->selector_shift,\n\t\t\t\t\t  &page_chg, false);\n\n\t\tmap->work_buf = orig_work_buf;\n\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t*reg = range->window_start + win_offset;\n\n\treturn 0;\n}\n\nstatic void regmap_set_work_buf_flag_mask(struct regmap *map, int max_bytes,\n\t\t\t\t\t  unsigned long mask)\n{\n\tu8 *buf;\n\tint i;\n\n\tif (!mask || !map->work_buf)\n\t\treturn;\n\n\tbuf = map->work_buf;\n\n\tfor (i = 0; i < max_bytes; i++)\n\t\tbuf[i] |= (mask >> (8 * i)) & 0xff;\n}\n\nstatic unsigned int regmap_reg_addr(struct regmap *map, unsigned int reg)\n{\n\treg += map->reg_base;\n\n\tif (map->format.reg_shift > 0)\n\t\treg >>= map->format.reg_shift;\n\telse if (map->format.reg_shift < 0)\n\t\treg <<= -(map->format.reg_shift);\n\n\treturn reg;\n}\n\nstatic int _regmap_raw_write_impl(struct regmap *map, unsigned int reg,\n\t\t\t\t  const void *val, size_t val_len, bool noinc)\n{\n\tstruct regmap_range_node *range;\n\tunsigned long flags;\n\tvoid *work_val = map->work_buf + map->format.reg_bytes +\n\t\tmap->format.pad_bytes;\n\tvoid *buf;\n\tint ret = -ENOTSUPP;\n\tsize_t len;\n\tint i;\n\n\t \n\tif (!regmap_writeable_noinc(map, reg)) {\n\t\tfor (i = 0; i < val_len / map->format.val_bytes; i++) {\n\t\t\tunsigned int element =\n\t\t\t\treg + regmap_get_offset(map, i);\n\t\t\tif (!regmap_writeable(map, element) ||\n\t\t\t\tregmap_writeable_noinc(map, element))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!map->cache_bypass && map->format.parse_val) {\n\t\tunsigned int ival, offset;\n\t\tint val_bytes = map->format.val_bytes;\n\n\t\t \n\t\ti = noinc ? val_len - val_bytes : 0;\n\t\tfor (; i < val_len; i += val_bytes) {\n\t\t\tival = map->format.parse_val(val + i);\n\t\t\toffset = noinc ? 0 : regmap_get_offset(map, i / val_bytes);\n\t\t\tret = regcache_write(map, reg + offset, ival);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(map->dev,\n\t\t\t\t\t\"Error in caching of register: %x ret: %d\\n\",\n\t\t\t\t\treg + offset, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tif (map->cache_only) {\n\t\t\tmap->cache_dirty = true;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trange = _regmap_range_lookup(map, reg);\n\tif (range) {\n\t\tint val_num = val_len / map->format.val_bytes;\n\t\tint win_offset = (reg - range->range_min) % range->window_len;\n\t\tint win_residue = range->window_len - win_offset;\n\n\t\t \n\t\twhile (val_num > win_residue) {\n\t\t\tdev_dbg(map->dev, \"Writing window %d/%zu\\n\",\n\t\t\t\twin_residue, val_len / map->format.val_bytes);\n\t\t\tret = _regmap_raw_write_impl(map, reg, val,\n\t\t\t\t\t\t     win_residue *\n\t\t\t\t\t\t     map->format.val_bytes, noinc);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\n\t\t\treg += win_residue;\n\t\t\tval_num -= win_residue;\n\t\t\tval += win_residue * map->format.val_bytes;\n\t\t\tval_len -= win_residue * map->format.val_bytes;\n\n\t\t\twin_offset = (reg - range->range_min) %\n\t\t\t\trange->window_len;\n\t\t\twin_residue = range->window_len - win_offset;\n\t\t}\n\n\t\tret = _regmap_select_page(map, &reg, range, noinc ? 1 : val_num);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\treg = regmap_reg_addr(map, reg);\n\tmap->format.format_reg(map->work_buf, reg, map->reg_shift);\n\tregmap_set_work_buf_flag_mask(map, map->format.reg_bytes,\n\t\t\t\t      map->write_flag_mask);\n\n\t \n\tif (val != work_val && val_len == map->format.val_bytes) {\n\t\tmemcpy(work_val, val, map->format.val_bytes);\n\t\tval = work_val;\n\t}\n\n\tif (map->async && map->bus && map->bus->async_write) {\n\t\tstruct regmap_async *async;\n\n\t\ttrace_regmap_async_write_start(map, reg, val_len);\n\n\t\tspin_lock_irqsave(&map->async_lock, flags);\n\t\tasync = list_first_entry_or_null(&map->async_free,\n\t\t\t\t\t\t struct regmap_async,\n\t\t\t\t\t\t list);\n\t\tif (async)\n\t\t\tlist_del(&async->list);\n\t\tspin_unlock_irqrestore(&map->async_lock, flags);\n\n\t\tif (!async) {\n\t\t\tasync = map->bus->async_alloc();\n\t\t\tif (!async)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tasync->work_buf = kzalloc(map->format.buf_size,\n\t\t\t\t\t\t  GFP_KERNEL | GFP_DMA);\n\t\t\tif (!async->work_buf) {\n\t\t\t\tkfree(async);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tasync->map = map;\n\n\t\t \n\t\tmemcpy(async->work_buf, map->work_buf, map->format.pad_bytes +\n\t\t       map->format.reg_bytes + map->format.val_bytes);\n\n\t\tspin_lock_irqsave(&map->async_lock, flags);\n\t\tlist_add_tail(&async->list, &map->async_list);\n\t\tspin_unlock_irqrestore(&map->async_lock, flags);\n\n\t\tif (val != work_val)\n\t\t\tret = map->bus->async_write(map->bus_context,\n\t\t\t\t\t\t    async->work_buf,\n\t\t\t\t\t\t    map->format.reg_bytes +\n\t\t\t\t\t\t    map->format.pad_bytes,\n\t\t\t\t\t\t    val, val_len, async);\n\t\telse\n\t\t\tret = map->bus->async_write(map->bus_context,\n\t\t\t\t\t\t    async->work_buf,\n\t\t\t\t\t\t    map->format.reg_bytes +\n\t\t\t\t\t\t    map->format.pad_bytes +\n\t\t\t\t\t\t    val_len, NULL, 0, async);\n\n\t\tif (ret != 0) {\n\t\t\tdev_err(map->dev, \"Failed to schedule write: %d\\n\",\n\t\t\t\tret);\n\n\t\t\tspin_lock_irqsave(&map->async_lock, flags);\n\t\t\tlist_move(&async->list, &map->async_free);\n\t\t\tspin_unlock_irqrestore(&map->async_lock, flags);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\ttrace_regmap_hw_write_start(map, reg, val_len / map->format.val_bytes);\n\n\t \n\tif (val == work_val)\n\t\tret = map->write(map->bus_context, map->work_buf,\n\t\t\t\t map->format.reg_bytes +\n\t\t\t\t map->format.pad_bytes +\n\t\t\t\t val_len);\n\telse if (map->bus && map->bus->gather_write)\n\t\tret = map->bus->gather_write(map->bus_context, map->work_buf,\n\t\t\t\t\t     map->format.reg_bytes +\n\t\t\t\t\t     map->format.pad_bytes,\n\t\t\t\t\t     val, val_len);\n\telse\n\t\tret = -ENOTSUPP;\n\n\t \n\tif (ret == -ENOTSUPP) {\n\t\tlen = map->format.reg_bytes + map->format.pad_bytes + val_len;\n\t\tbuf = kzalloc(len, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(buf, map->work_buf, map->format.reg_bytes);\n\t\tmemcpy(buf + map->format.reg_bytes + map->format.pad_bytes,\n\t\t       val, val_len);\n\t\tret = map->write(map->bus_context, buf, len);\n\n\t\tkfree(buf);\n\t} else if (ret != 0 && !map->cache_bypass && map->format.parse_val) {\n\t\t \n\t\tif (map->cache_ops && map->cache_ops->drop)\n\t\t\tmap->cache_ops->drop(map, reg, reg + 1);\n\t}\n\n\ttrace_regmap_hw_write_done(map, reg, val_len / map->format.val_bytes);\n\n\treturn ret;\n}\n\n \nbool regmap_can_raw_write(struct regmap *map)\n{\n\treturn map->write && map->format.format_val && map->format.format_reg;\n}\nEXPORT_SYMBOL_GPL(regmap_can_raw_write);\n\n \nsize_t regmap_get_raw_read_max(struct regmap *map)\n{\n\treturn map->max_raw_read;\n}\nEXPORT_SYMBOL_GPL(regmap_get_raw_read_max);\n\n \nsize_t regmap_get_raw_write_max(struct regmap *map)\n{\n\treturn map->max_raw_write;\n}\nEXPORT_SYMBOL_GPL(regmap_get_raw_write_max);\n\nstatic int _regmap_bus_formatted_write(void *context, unsigned int reg,\n\t\t\t\t       unsigned int val)\n{\n\tint ret;\n\tstruct regmap_range_node *range;\n\tstruct regmap *map = context;\n\n\tWARN_ON(!map->format.format_write);\n\n\trange = _regmap_range_lookup(map, reg);\n\tif (range) {\n\t\tret = _regmap_select_page(map, &reg, range, 1);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\treg = regmap_reg_addr(map, reg);\n\tmap->format.format_write(map, reg, val);\n\n\ttrace_regmap_hw_write_start(map, reg, 1);\n\n\tret = map->write(map->bus_context, map->work_buf, map->format.buf_size);\n\n\ttrace_regmap_hw_write_done(map, reg, 1);\n\n\treturn ret;\n}\n\nstatic int _regmap_bus_reg_write(void *context, unsigned int reg,\n\t\t\t\t unsigned int val)\n{\n\tstruct regmap *map = context;\n\tstruct regmap_range_node *range;\n\tint ret;\n\n\trange = _regmap_range_lookup(map, reg);\n\tif (range) {\n\t\tret = _regmap_select_page(map, &reg, range, 1);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\treg = regmap_reg_addr(map, reg);\n\treturn map->bus->reg_write(map->bus_context, reg, val);\n}\n\nstatic int _regmap_bus_raw_write(void *context, unsigned int reg,\n\t\t\t\t unsigned int val)\n{\n\tstruct regmap *map = context;\n\n\tWARN_ON(!map->format.format_val);\n\n\tmap->format.format_val(map->work_buf + map->format.reg_bytes\n\t\t\t       + map->format.pad_bytes, val, 0);\n\treturn _regmap_raw_write_impl(map, reg,\n\t\t\t\t      map->work_buf +\n\t\t\t\t      map->format.reg_bytes +\n\t\t\t\t      map->format.pad_bytes,\n\t\t\t\t      map->format.val_bytes,\n\t\t\t\t      false);\n}\n\nstatic inline void *_regmap_map_get_context(struct regmap *map)\n{\n\treturn (map->bus || (!map->bus && map->read)) ? map : map->bus_context;\n}\n\nint _regmap_write(struct regmap *map, unsigned int reg,\n\t\t  unsigned int val)\n{\n\tint ret;\n\tvoid *context = _regmap_map_get_context(map);\n\n\tif (!regmap_writeable(map, reg))\n\t\treturn -EIO;\n\n\tif (!map->cache_bypass && !map->defer_caching) {\n\t\tret = regcache_write(map, reg, val);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (map->cache_only) {\n\t\t\tmap->cache_dirty = true;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = map->reg_write(context, reg, val);\n\tif (ret == 0) {\n\t\tif (regmap_should_log(map))\n\t\t\tdev_info(map->dev, \"%x <= %x\\n\", reg, val);\n\n\t\ttrace_regmap_reg_write(map, reg, val);\n\t}\n\n\treturn ret;\n}\n\n \nint regmap_write(struct regmap *map, unsigned int reg, unsigned int val)\n{\n\tint ret;\n\n\tif (!IS_ALIGNED(reg, map->reg_stride))\n\t\treturn -EINVAL;\n\n\tmap->lock(map->lock_arg);\n\n\tret = _regmap_write(map, reg, val);\n\n\tmap->unlock(map->lock_arg);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_write);\n\n \nint regmap_write_async(struct regmap *map, unsigned int reg, unsigned int val)\n{\n\tint ret;\n\n\tif (!IS_ALIGNED(reg, map->reg_stride))\n\t\treturn -EINVAL;\n\n\tmap->lock(map->lock_arg);\n\n\tmap->async = true;\n\n\tret = _regmap_write(map, reg, val);\n\n\tmap->async = false;\n\n\tmap->unlock(map->lock_arg);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_write_async);\n\nint _regmap_raw_write(struct regmap *map, unsigned int reg,\n\t\t      const void *val, size_t val_len, bool noinc)\n{\n\tsize_t val_bytes = map->format.val_bytes;\n\tsize_t val_count = val_len / val_bytes;\n\tsize_t chunk_count, chunk_bytes;\n\tsize_t chunk_regs = val_count;\n\tint ret, i;\n\n\tif (!val_count)\n\t\treturn -EINVAL;\n\n\tif (map->use_single_write)\n\t\tchunk_regs = 1;\n\telse if (map->max_raw_write && val_len > map->max_raw_write)\n\t\tchunk_regs = map->max_raw_write / val_bytes;\n\n\tchunk_count = val_count / chunk_regs;\n\tchunk_bytes = chunk_regs * val_bytes;\n\n\t \n\tfor (i = 0; i < chunk_count; i++) {\n\t\tret = _regmap_raw_write_impl(map, reg, val, chunk_bytes, noinc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treg += regmap_get_offset(map, chunk_regs);\n\t\tval += chunk_bytes;\n\t\tval_len -= chunk_bytes;\n\t}\n\n\t \n\tif (val_len)\n\t\tret = _regmap_raw_write_impl(map, reg, val, val_len, noinc);\n\n\treturn ret;\n}\n\n \nint regmap_raw_write(struct regmap *map, unsigned int reg,\n\t\t     const void *val, size_t val_len)\n{\n\tint ret;\n\n\tif (!regmap_can_raw_write(map))\n\t\treturn -EINVAL;\n\tif (val_len % map->format.val_bytes)\n\t\treturn -EINVAL;\n\n\tmap->lock(map->lock_arg);\n\n\tret = _regmap_raw_write(map, reg, val, val_len, false);\n\n\tmap->unlock(map->lock_arg);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_raw_write);\n\nstatic int regmap_noinc_readwrite(struct regmap *map, unsigned int reg,\n\t\t\t\t  void *val, unsigned int val_len, bool write)\n{\n\tsize_t val_bytes = map->format.val_bytes;\n\tsize_t val_count = val_len / val_bytes;\n\tunsigned int lastval;\n\tu8 *u8p;\n\tu16 *u16p;\n\tu32 *u32p;\n\tint ret;\n\tint i;\n\n\tswitch (val_bytes) {\n\tcase 1:\n\t\tu8p = val;\n\t\tif (write)\n\t\t\tlastval = (unsigned int)u8p[val_count - 1];\n\t\tbreak;\n\tcase 2:\n\t\tu16p = val;\n\t\tif (write)\n\t\t\tlastval = (unsigned int)u16p[val_count - 1];\n\t\tbreak;\n\tcase 4:\n\t\tu32p = val;\n\t\tif (write)\n\t\t\tlastval = (unsigned int)u32p[val_count - 1];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (write) {\n\t\tif (!map->cache_bypass && !map->defer_caching) {\n\t\t\tret = regcache_write(map, reg, lastval);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t\tif (map->cache_only) {\n\t\t\t\tmap->cache_dirty = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tret = map->bus->reg_noinc_write(map->bus_context, reg, val, val_count);\n\t} else {\n\t\tret = map->bus->reg_noinc_read(map->bus_context, reg, val, val_count);\n\t}\n\n\tif (!ret && regmap_should_log(map)) {\n\t\tdev_info(map->dev, \"%x %s [\", reg, write ? \"<=\" : \"=>\");\n\t\tfor (i = 0; i < val_count; i++) {\n\t\t\tswitch (val_bytes) {\n\t\t\tcase 1:\n\t\t\t\tpr_cont(\"%x\", u8p[i]);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tpr_cont(\"%x\", u16p[i]);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tpr_cont(\"%x\", u32p[i]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == (val_count - 1))\n\t\t\t\tpr_cont(\"]\\n\");\n\t\t\telse\n\t\t\t\tpr_cont(\",\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint regmap_noinc_write(struct regmap *map, unsigned int reg,\n\t\t      const void *val, size_t val_len)\n{\n\tsize_t write_len;\n\tint ret;\n\n\tif (!map->write && !(map->bus && map->bus->reg_noinc_write))\n\t\treturn -EINVAL;\n\tif (val_len % map->format.val_bytes)\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(reg, map->reg_stride))\n\t\treturn -EINVAL;\n\tif (val_len == 0)\n\t\treturn -EINVAL;\n\n\tmap->lock(map->lock_arg);\n\n\tif (!regmap_volatile(map, reg) || !regmap_writeable_noinc(map, reg)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (map->bus->reg_noinc_write) {\n\t\tret = regmap_noinc_readwrite(map, reg, (void *)val, val_len, true);\n\t\tgoto out_unlock;\n\t}\n\n\twhile (val_len) {\n\t\tif (map->max_raw_write && map->max_raw_write < val_len)\n\t\t\twrite_len = map->max_raw_write;\n\t\telse\n\t\t\twrite_len = val_len;\n\t\tret = _regmap_raw_write(map, reg, val, write_len, true);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tval = ((u8 *)val) + write_len;\n\t\tval_len -= write_len;\n\t}\n\nout_unlock:\n\tmap->unlock(map->lock_arg);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_noinc_write);\n\n \nint regmap_field_update_bits_base(struct regmap_field *field,\n\t\t\t\t  unsigned int mask, unsigned int val,\n\t\t\t\t  bool *change, bool async, bool force)\n{\n\tmask = (mask << field->shift) & field->mask;\n\n\treturn regmap_update_bits_base(field->regmap, field->reg,\n\t\t\t\t       mask, val << field->shift,\n\t\t\t\t       change, async, force);\n}\nEXPORT_SYMBOL_GPL(regmap_field_update_bits_base);\n\n \nint regmap_field_test_bits(struct regmap_field *field, unsigned int bits)\n{\n\tunsigned int val, ret;\n\n\tret = regmap_field_read(field, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (val & bits) == bits;\n}\nEXPORT_SYMBOL_GPL(regmap_field_test_bits);\n\n \nint regmap_fields_update_bits_base(struct regmap_field *field, unsigned int id,\n\t\t\t\t   unsigned int mask, unsigned int val,\n\t\t\t\t   bool *change, bool async, bool force)\n{\n\tif (id >= field->id_size)\n\t\treturn -EINVAL;\n\n\tmask = (mask << field->shift) & field->mask;\n\n\treturn regmap_update_bits_base(field->regmap,\n\t\t\t\t       field->reg + (field->id_offset * id),\n\t\t\t\t       mask, val << field->shift,\n\t\t\t\t       change, async, force);\n}\nEXPORT_SYMBOL_GPL(regmap_fields_update_bits_base);\n\n \nint regmap_bulk_write(struct regmap *map, unsigned int reg, const void *val,\n\t\t     size_t val_count)\n{\n\tint ret = 0, i;\n\tsize_t val_bytes = map->format.val_bytes;\n\n\tif (!IS_ALIGNED(reg, map->reg_stride))\n\t\treturn -EINVAL;\n\n\t \n\tif (!map->write || !map->format.parse_inplace) {\n\t\tmap->lock(map->lock_arg);\n\t\tfor (i = 0; i < val_count; i++) {\n\t\t\tunsigned int ival;\n\n\t\t\tswitch (val_bytes) {\n\t\t\tcase 1:\n\t\t\t\tival = *(u8 *)(val + (i * val_bytes));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tival = *(u16 *)(val + (i * val_bytes));\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tival = *(u32 *)(val + (i * val_bytes));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = _regmap_write(map,\n\t\t\t\t\t    reg + regmap_get_offset(map, i),\n\t\t\t\t\t    ival);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t}\nout:\n\t\tmap->unlock(map->lock_arg);\n\t} else {\n\t\tvoid *wval;\n\n\t\twval = kmemdup(val, val_count * val_bytes, map->alloc_flags);\n\t\tif (!wval)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < val_count * val_bytes; i += val_bytes)\n\t\t\tmap->format.parse_inplace(wval + i);\n\n\t\tret = regmap_raw_write(map, reg, wval, val_bytes * val_count);\n\n\t\tkfree(wval);\n\t}\n\n\tif (!ret)\n\t\ttrace_regmap_bulk_write(map, reg, val, val_bytes * val_count);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_bulk_write);\n\n \nstatic int _regmap_raw_multi_reg_write(struct regmap *map,\n\t\t\t\t       const struct reg_sequence *regs,\n\t\t\t\t       size_t num_regs)\n{\n\tint ret;\n\tvoid *buf;\n\tint i;\n\tu8 *u8;\n\tsize_t val_bytes = map->format.val_bytes;\n\tsize_t reg_bytes = map->format.reg_bytes;\n\tsize_t pad_bytes = map->format.pad_bytes;\n\tsize_t pair_size = reg_bytes + pad_bytes + val_bytes;\n\tsize_t len = pair_size * num_regs;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tbuf = kzalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\n\tu8 = buf;\n\n\tfor (i = 0; i < num_regs; i++) {\n\t\tunsigned int reg = regs[i].reg;\n\t\tunsigned int val = regs[i].def;\n\t\ttrace_regmap_hw_write_start(map, reg, 1);\n\t\treg = regmap_reg_addr(map, reg);\n\t\tmap->format.format_reg(u8, reg, map->reg_shift);\n\t\tu8 += reg_bytes + pad_bytes;\n\t\tmap->format.format_val(u8, val, 0);\n\t\tu8 += val_bytes;\n\t}\n\tu8 = buf;\n\t*u8 |= map->write_flag_mask;\n\n\tret = map->write(map->bus_context, buf, len);\n\n\tkfree(buf);\n\n\tfor (i = 0; i < num_regs; i++) {\n\t\tint reg = regs[i].reg;\n\t\ttrace_regmap_hw_write_done(map, reg, 1);\n\t}\n\treturn ret;\n}\n\nstatic unsigned int _regmap_register_page(struct regmap *map,\n\t\t\t\t\t  unsigned int reg,\n\t\t\t\t\t  struct regmap_range_node *range)\n{\n\tunsigned int win_page = (reg - range->range_min) / range->window_len;\n\n\treturn win_page;\n}\n\nstatic int _regmap_range_multi_paged_reg_write(struct regmap *map,\n\t\t\t\t\t       struct reg_sequence *regs,\n\t\t\t\t\t       size_t num_regs)\n{\n\tint ret;\n\tint i, n;\n\tstruct reg_sequence *base;\n\tunsigned int this_page = 0;\n\tunsigned int page_change = 0;\n\t \n\tbase = regs;\n\tfor (i = 0, n = 0; i < num_regs; i++, n++) {\n\t\tunsigned int reg = regs[i].reg;\n\t\tstruct regmap_range_node *range;\n\n\t\trange = _regmap_range_lookup(map, reg);\n\t\tif (range) {\n\t\t\tunsigned int win_page = _regmap_register_page(map, reg,\n\t\t\t\t\t\t\t\t      range);\n\n\t\t\tif (i == 0)\n\t\t\t\tthis_page = win_page;\n\t\t\tif (win_page != this_page) {\n\t\t\t\tthis_page = win_page;\n\t\t\t\tpage_change = 1;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tif (page_change || regs[i].delay_us) {\n\n\t\t\t\t \n\t\t\t\tif (regs[i].delay_us && i == 0)\n\t\t\t\t\tn = 1;\n\n\t\t\t\tret = _regmap_raw_multi_reg_write(map, base, n);\n\t\t\t\tif (ret != 0)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tif (regs[i].delay_us) {\n\t\t\t\t\tif (map->can_sleep)\n\t\t\t\t\t\tfsleep(regs[i].delay_us);\n\t\t\t\t\telse\n\t\t\t\t\t\tudelay(regs[i].delay_us);\n\t\t\t\t}\n\n\t\t\t\tbase += n;\n\t\t\t\tn = 0;\n\n\t\t\t\tif (page_change) {\n\t\t\t\t\tret = _regmap_select_page(map,\n\t\t\t\t\t\t\t\t  &base[n].reg,\n\t\t\t\t\t\t\t\t  range, 1);\n\t\t\t\t\tif (ret != 0)\n\t\t\t\t\t\treturn ret;\n\n\t\t\t\t\tpage_change = 0;\n\t\t\t\t}\n\n\t\t}\n\n\t}\n\tif (n > 0)\n\t\treturn _regmap_raw_multi_reg_write(map, base, n);\n\treturn 0;\n}\n\nstatic int _regmap_multi_reg_write(struct regmap *map,\n\t\t\t\t   const struct reg_sequence *regs,\n\t\t\t\t   size_t num_regs)\n{\n\tint i;\n\tint ret;\n\n\tif (!map->can_multi_write) {\n\t\tfor (i = 0; i < num_regs; i++) {\n\t\t\tret = _regmap_write(map, regs[i].reg, regs[i].def);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (regs[i].delay_us) {\n\t\t\t\tif (map->can_sleep)\n\t\t\t\t\tfsleep(regs[i].delay_us);\n\t\t\t\telse\n\t\t\t\t\tudelay(regs[i].delay_us);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!map->format.parse_inplace)\n\t\treturn -EINVAL;\n\n\tif (map->writeable_reg)\n\t\tfor (i = 0; i < num_regs; i++) {\n\t\t\tint reg = regs[i].reg;\n\t\t\tif (!map->writeable_reg(map->dev, reg))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!IS_ALIGNED(reg, map->reg_stride))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\tif (!map->cache_bypass) {\n\t\tfor (i = 0; i < num_regs; i++) {\n\t\t\tunsigned int val = regs[i].def;\n\t\t\tunsigned int reg = regs[i].reg;\n\t\t\tret = regcache_write(map, reg, val);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(map->dev,\n\t\t\t\t\"Error in caching of register: %x ret: %d\\n\",\n\t\t\t\t\t\t\t\treg, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tif (map->cache_only) {\n\t\t\tmap->cache_dirty = true;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tWARN_ON(!map->bus);\n\n\tfor (i = 0; i < num_regs; i++) {\n\t\tunsigned int reg = regs[i].reg;\n\t\tstruct regmap_range_node *range;\n\n\t\t \n\t\trange = _regmap_range_lookup(map, reg);\n\t\tif (range || regs[i].delay_us) {\n\t\t\tsize_t len = sizeof(struct reg_sequence)*num_regs;\n\t\t\tstruct reg_sequence *base = kmemdup(regs, len,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!base)\n\t\t\t\treturn -ENOMEM;\n\t\t\tret = _regmap_range_multi_paged_reg_write(map, base,\n\t\t\t\t\t\t\t\t  num_regs);\n\t\t\tkfree(base);\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn _regmap_raw_multi_reg_write(map, regs, num_regs);\n}\n\n \nint regmap_multi_reg_write(struct regmap *map, const struct reg_sequence *regs,\n\t\t\t   int num_regs)\n{\n\tint ret;\n\n\tmap->lock(map->lock_arg);\n\n\tret = _regmap_multi_reg_write(map, regs, num_regs);\n\n\tmap->unlock(map->lock_arg);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_multi_reg_write);\n\n \nint regmap_multi_reg_write_bypassed(struct regmap *map,\n\t\t\t\t    const struct reg_sequence *regs,\n\t\t\t\t    int num_regs)\n{\n\tint ret;\n\tbool bypass;\n\n\tmap->lock(map->lock_arg);\n\n\tbypass = map->cache_bypass;\n\tmap->cache_bypass = true;\n\n\tret = _regmap_multi_reg_write(map, regs, num_regs);\n\n\tmap->cache_bypass = bypass;\n\n\tmap->unlock(map->lock_arg);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_multi_reg_write_bypassed);\n\n \nint regmap_raw_write_async(struct regmap *map, unsigned int reg,\n\t\t\t   const void *val, size_t val_len)\n{\n\tint ret;\n\n\tif (val_len % map->format.val_bytes)\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(reg, map->reg_stride))\n\t\treturn -EINVAL;\n\n\tmap->lock(map->lock_arg);\n\n\tmap->async = true;\n\n\tret = _regmap_raw_write(map, reg, val, val_len, false);\n\n\tmap->async = false;\n\n\tmap->unlock(map->lock_arg);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_raw_write_async);\n\nstatic int _regmap_raw_read(struct regmap *map, unsigned int reg, void *val,\n\t\t\t    unsigned int val_len, bool noinc)\n{\n\tstruct regmap_range_node *range;\n\tint ret;\n\n\tif (!map->read)\n\t\treturn -EINVAL;\n\n\trange = _regmap_range_lookup(map, reg);\n\tif (range) {\n\t\tret = _regmap_select_page(map, &reg, range,\n\t\t\t\t\t  noinc ? 1 : val_len / map->format.val_bytes);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\treg = regmap_reg_addr(map, reg);\n\tmap->format.format_reg(map->work_buf, reg, map->reg_shift);\n\tregmap_set_work_buf_flag_mask(map, map->format.reg_bytes,\n\t\t\t\t      map->read_flag_mask);\n\ttrace_regmap_hw_read_start(map, reg, val_len / map->format.val_bytes);\n\n\tret = map->read(map->bus_context, map->work_buf,\n\t\t\tmap->format.reg_bytes + map->format.pad_bytes,\n\t\t\tval, val_len);\n\n\ttrace_regmap_hw_read_done(map, reg, val_len / map->format.val_bytes);\n\n\treturn ret;\n}\n\nstatic int _regmap_bus_reg_read(void *context, unsigned int reg,\n\t\t\t\tunsigned int *val)\n{\n\tstruct regmap *map = context;\n\tstruct regmap_range_node *range;\n\tint ret;\n\n\trange = _regmap_range_lookup(map, reg);\n\tif (range) {\n\t\tret = _regmap_select_page(map, &reg, range, 1);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\treg = regmap_reg_addr(map, reg);\n\treturn map->bus->reg_read(map->bus_context, reg, val);\n}\n\nstatic int _regmap_bus_read(void *context, unsigned int reg,\n\t\t\t    unsigned int *val)\n{\n\tint ret;\n\tstruct regmap *map = context;\n\tvoid *work_val = map->work_buf + map->format.reg_bytes +\n\t\tmap->format.pad_bytes;\n\n\tif (!map->format.parse_val)\n\t\treturn -EINVAL;\n\n\tret = _regmap_raw_read(map, reg, work_val, map->format.val_bytes, false);\n\tif (ret == 0)\n\t\t*val = map->format.parse_val(work_val);\n\n\treturn ret;\n}\n\nstatic int _regmap_read(struct regmap *map, unsigned int reg,\n\t\t\tunsigned int *val)\n{\n\tint ret;\n\tvoid *context = _regmap_map_get_context(map);\n\n\tif (!map->cache_bypass) {\n\t\tret = regcache_read(map, reg, val);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (map->cache_only)\n\t\treturn -EBUSY;\n\n\tif (!regmap_readable(map, reg))\n\t\treturn -EIO;\n\n\tret = map->reg_read(context, reg, val);\n\tif (ret == 0) {\n\t\tif (regmap_should_log(map))\n\t\t\tdev_info(map->dev, \"%x => %x\\n\", reg, *val);\n\n\t\ttrace_regmap_reg_read(map, reg, *val);\n\n\t\tif (!map->cache_bypass)\n\t\t\tregcache_write(map, reg, *val);\n\t}\n\n\treturn ret;\n}\n\n \nint regmap_read(struct regmap *map, unsigned int reg, unsigned int *val)\n{\n\tint ret;\n\n\tif (!IS_ALIGNED(reg, map->reg_stride))\n\t\treturn -EINVAL;\n\n\tmap->lock(map->lock_arg);\n\n\tret = _regmap_read(map, reg, val);\n\n\tmap->unlock(map->lock_arg);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_read);\n\n \nint regmap_raw_read(struct regmap *map, unsigned int reg, void *val,\n\t\t    size_t val_len)\n{\n\tsize_t val_bytes = map->format.val_bytes;\n\tsize_t val_count = val_len / val_bytes;\n\tunsigned int v;\n\tint ret, i;\n\n\tif (val_len % map->format.val_bytes)\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(reg, map->reg_stride))\n\t\treturn -EINVAL;\n\tif (val_count == 0)\n\t\treturn -EINVAL;\n\n\tmap->lock(map->lock_arg);\n\n\tif (regmap_volatile_range(map, reg, val_count) || map->cache_bypass ||\n\t    map->cache_type == REGCACHE_NONE) {\n\t\tsize_t chunk_count, chunk_bytes;\n\t\tsize_t chunk_regs = val_count;\n\n\t\tif (!map->cache_bypass && map->cache_only) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!map->read) {\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (map->use_single_read)\n\t\t\tchunk_regs = 1;\n\t\telse if (map->max_raw_read && val_len > map->max_raw_read)\n\t\t\tchunk_regs = map->max_raw_read / val_bytes;\n\n\t\tchunk_count = val_count / chunk_regs;\n\t\tchunk_bytes = chunk_regs * val_bytes;\n\n\t\t \n\t\tfor (i = 0; i < chunk_count; i++) {\n\t\t\tret = _regmap_raw_read(map, reg, val, chunk_bytes, false);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\n\t\t\treg += regmap_get_offset(map, chunk_regs);\n\t\t\tval += chunk_bytes;\n\t\t\tval_len -= chunk_bytes;\n\t\t}\n\n\t\t \n\t\tif (val_len) {\n\t\t\tret = _regmap_raw_read(map, reg, val, val_len, false);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0; i < val_count; i++) {\n\t\t\tret = _regmap_read(map, reg + regmap_get_offset(map, i),\n\t\t\t\t\t   &v);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\n\t\t\tmap->format.format_val(val + (i * val_bytes), v, 0);\n\t\t}\n\t}\n\n out:\n\tmap->unlock(map->lock_arg);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_raw_read);\n\n \nint regmap_noinc_read(struct regmap *map, unsigned int reg,\n\t\t      void *val, size_t val_len)\n{\n\tsize_t read_len;\n\tint ret;\n\n\tif (!map->read)\n\t\treturn -ENOTSUPP;\n\n\tif (val_len % map->format.val_bytes)\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(reg, map->reg_stride))\n\t\treturn -EINVAL;\n\tif (val_len == 0)\n\t\treturn -EINVAL;\n\n\tmap->lock(map->lock_arg);\n\n\tif (!regmap_volatile(map, reg) || !regmap_readable_noinc(map, reg)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (!map->cache_bypass && map->cache_only) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (map->bus->reg_noinc_read) {\n\t\tret = regmap_noinc_readwrite(map, reg, val, val_len, false);\n\t\tgoto out_unlock;\n\t}\n\n\twhile (val_len) {\n\t\tif (map->max_raw_read && map->max_raw_read < val_len)\n\t\t\tread_len = map->max_raw_read;\n\t\telse\n\t\t\tread_len = val_len;\n\t\tret = _regmap_raw_read(map, reg, val, read_len, true);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tval = ((u8 *)val) + read_len;\n\t\tval_len -= read_len;\n\t}\n\nout_unlock:\n\tmap->unlock(map->lock_arg);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_noinc_read);\n\n \nint regmap_field_read(struct regmap_field *field, unsigned int *val)\n{\n\tint ret;\n\tunsigned int reg_val;\n\tret = regmap_read(field->regmap, field->reg, &reg_val);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treg_val &= field->mask;\n\treg_val >>= field->shift;\n\t*val = reg_val;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_field_read);\n\n \nint regmap_fields_read(struct regmap_field *field, unsigned int id,\n\t\t       unsigned int *val)\n{\n\tint ret;\n\tunsigned int reg_val;\n\n\tif (id >= field->id_size)\n\t\treturn -EINVAL;\n\n\tret = regmap_read(field->regmap,\n\t\t\t  field->reg + (field->id_offset * id),\n\t\t\t  &reg_val);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treg_val &= field->mask;\n\treg_val >>= field->shift;\n\t*val = reg_val;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_fields_read);\n\n \nint regmap_bulk_read(struct regmap *map, unsigned int reg, void *val,\n\t\t     size_t val_count)\n{\n\tint ret, i;\n\tsize_t val_bytes = map->format.val_bytes;\n\tbool vol = regmap_volatile_range(map, reg, val_count);\n\n\tif (!IS_ALIGNED(reg, map->reg_stride))\n\t\treturn -EINVAL;\n\tif (val_count == 0)\n\t\treturn -EINVAL;\n\n\tif (map->read && map->format.parse_inplace && (vol || map->cache_type == REGCACHE_NONE)) {\n\t\tret = regmap_raw_read(map, reg, val, val_bytes * val_count);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < val_count * val_bytes; i += val_bytes)\n\t\t\tmap->format.parse_inplace(val + i);\n\t} else {\n\t\tu32 *u32 = val;\n\t\tu16 *u16 = val;\n\t\tu8 *u8 = val;\n\n\t\tmap->lock(map->lock_arg);\n\n\t\tfor (i = 0; i < val_count; i++) {\n\t\t\tunsigned int ival;\n\n\t\t\tret = _regmap_read(map, reg + regmap_get_offset(map, i),\n\t\t\t\t\t   &ival);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\n\t\t\tswitch (map->format.val_bytes) {\n\t\t\tcase 4:\n\t\t\t\tu32[i] = ival;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tu16[i] = ival;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tu8[i] = ival;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\nout:\n\t\tmap->unlock(map->lock_arg);\n\t}\n\n\tif (!ret)\n\t\ttrace_regmap_bulk_read(map, reg, val, val_bytes * val_count);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_bulk_read);\n\nstatic int _regmap_update_bits(struct regmap *map, unsigned int reg,\n\t\t\t       unsigned int mask, unsigned int val,\n\t\t\t       bool *change, bool force_write)\n{\n\tint ret;\n\tunsigned int tmp, orig;\n\n\tif (change)\n\t\t*change = false;\n\n\tif (regmap_volatile(map, reg) && map->reg_update_bits) {\n\t\treg = regmap_reg_addr(map, reg);\n\t\tret = map->reg_update_bits(map->bus_context, reg, mask, val);\n\t\tif (ret == 0 && change)\n\t\t\t*change = true;\n\t} else {\n\t\tret = _regmap_read(map, reg, &orig);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\ttmp = orig & ~mask;\n\t\ttmp |= val & mask;\n\n\t\tif (force_write || (tmp != orig) || map->force_write_field) {\n\t\t\tret = _regmap_write(map, reg, tmp);\n\t\t\tif (ret == 0 && change)\n\t\t\t\t*change = true;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nint regmap_update_bits_base(struct regmap *map, unsigned int reg,\n\t\t\t    unsigned int mask, unsigned int val,\n\t\t\t    bool *change, bool async, bool force)\n{\n\tint ret;\n\n\tmap->lock(map->lock_arg);\n\n\tmap->async = async;\n\n\tret = _regmap_update_bits(map, reg, mask, val, change, force);\n\n\tmap->async = false;\n\n\tmap->unlock(map->lock_arg);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_update_bits_base);\n\n \nint regmap_test_bits(struct regmap *map, unsigned int reg, unsigned int bits)\n{\n\tunsigned int val, ret;\n\n\tret = regmap_read(map, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (val & bits) == bits;\n}\nEXPORT_SYMBOL_GPL(regmap_test_bits);\n\nvoid regmap_async_complete_cb(struct regmap_async *async, int ret)\n{\n\tstruct regmap *map = async->map;\n\tbool wake;\n\n\ttrace_regmap_async_io_complete(map);\n\n\tspin_lock(&map->async_lock);\n\tlist_move(&async->list, &map->async_free);\n\twake = list_empty(&map->async_list);\n\n\tif (ret != 0)\n\t\tmap->async_ret = ret;\n\n\tspin_unlock(&map->async_lock);\n\n\tif (wake)\n\t\twake_up(&map->async_waitq);\n}\nEXPORT_SYMBOL_GPL(regmap_async_complete_cb);\n\nstatic int regmap_async_is_done(struct regmap *map)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&map->async_lock, flags);\n\tret = list_empty(&map->async_list);\n\tspin_unlock_irqrestore(&map->async_lock, flags);\n\n\treturn ret;\n}\n\n \nint regmap_async_complete(struct regmap *map)\n{\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tif (!map->bus || !map->bus->async_write)\n\t\treturn 0;\n\n\ttrace_regmap_async_complete_start(map);\n\n\twait_event(map->async_waitq, regmap_async_is_done(map));\n\n\tspin_lock_irqsave(&map->async_lock, flags);\n\tret = map->async_ret;\n\tmap->async_ret = 0;\n\tspin_unlock_irqrestore(&map->async_lock, flags);\n\n\ttrace_regmap_async_complete_done(map);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_async_complete);\n\n \nint regmap_register_patch(struct regmap *map, const struct reg_sequence *regs,\n\t\t\t  int num_regs)\n{\n\tstruct reg_sequence *p;\n\tint ret;\n\tbool bypass;\n\n\tif (WARN_ONCE(num_regs <= 0, \"invalid registers number (%d)\\n\",\n\t    num_regs))\n\t\treturn 0;\n\n\tp = krealloc(map->patch,\n\t\t     sizeof(struct reg_sequence) * (map->patch_regs + num_regs),\n\t\t     GFP_KERNEL);\n\tif (p) {\n\t\tmemcpy(p + map->patch_regs, regs, num_regs * sizeof(*regs));\n\t\tmap->patch = p;\n\t\tmap->patch_regs += num_regs;\n\t} else {\n\t\treturn -ENOMEM;\n\t}\n\n\tmap->lock(map->lock_arg);\n\n\tbypass = map->cache_bypass;\n\n\tmap->cache_bypass = true;\n\tmap->async = true;\n\n\tret = _regmap_multi_reg_write(map, regs, num_regs);\n\n\tmap->async = false;\n\tmap->cache_bypass = bypass;\n\n\tmap->unlock(map->lock_arg);\n\n\tregmap_async_complete(map);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_register_patch);\n\n \nint regmap_get_val_bytes(struct regmap *map)\n{\n\tif (map->format.format_write)\n\t\treturn -EINVAL;\n\n\treturn map->format.val_bytes;\n}\nEXPORT_SYMBOL_GPL(regmap_get_val_bytes);\n\n \nint regmap_get_max_register(struct regmap *map)\n{\n\treturn map->max_register ? map->max_register : -EINVAL;\n}\nEXPORT_SYMBOL_GPL(regmap_get_max_register);\n\n \nint regmap_get_reg_stride(struct regmap *map)\n{\n\treturn map->reg_stride;\n}\nEXPORT_SYMBOL_GPL(regmap_get_reg_stride);\n\n \nbool regmap_might_sleep(struct regmap *map)\n{\n\treturn map->can_sleep;\n}\nEXPORT_SYMBOL_GPL(regmap_might_sleep);\n\nint regmap_parse_val(struct regmap *map, const void *buf,\n\t\t\tunsigned int *val)\n{\n\tif (!map->format.parse_val)\n\t\treturn -EINVAL;\n\n\t*val = map->format.parse_val(buf);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regmap_parse_val);\n\nstatic int __init regmap_initcall(void)\n{\n\tregmap_debugfs_initcall();\n\n\treturn 0;\n}\npostcore_initcall(regmap_initcall);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}