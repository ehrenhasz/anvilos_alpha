{
  "module_name": "regmap-w1.c",
  "hash_id": "8d7f6eec6b3c37891febbc21c920db2a5627677ed848f520ce66f0a6abc771e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regmap-w1.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/regmap.h>\n#include <linux/module.h>\n#include <linux/w1.h>\n\n#include \"internal.h\"\n\n#define W1_CMD_READ_DATA\t0x69\n#define W1_CMD_WRITE_DATA\t0x6C\n\n \n\nstatic int w1_reg_a8_v8_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct device *dev = context;\n\tstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\n\tint ret = 0;\n\n\tif (reg > 255)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\tif (!w1_reset_select_slave(sl)) {\n\t\tw1_write_8(sl->master, W1_CMD_READ_DATA);\n\t\tw1_write_8(sl->master, reg);\n\t\t*val = w1_read_8(sl->master);\n\t} else {\n\t\tret = -ENODEV;\n\t}\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn ret;\n}\n\nstatic int w1_reg_a8_v8_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct device *dev = context;\n\tstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\n\tint ret = 0;\n\n\tif (reg > 255)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\tif (!w1_reset_select_slave(sl)) {\n\t\tw1_write_8(sl->master, W1_CMD_WRITE_DATA);\n\t\tw1_write_8(sl->master, reg);\n\t\tw1_write_8(sl->master, val);\n\t} else {\n\t\tret = -ENODEV;\n\t}\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn ret;\n}\n\n \n\nstatic int w1_reg_a8_v16_read(void *context, unsigned int reg,\n\t\t\t\tunsigned int *val)\n{\n\tstruct device *dev = context;\n\tstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\n\tint ret = 0;\n\n\tif (reg > 255)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\tif (!w1_reset_select_slave(sl)) {\n\t\tw1_write_8(sl->master, W1_CMD_READ_DATA);\n\t\tw1_write_8(sl->master, reg);\n\t\t*val = w1_read_8(sl->master);\n\t\t*val |= w1_read_8(sl->master)<<8;\n\t} else {\n\t\tret = -ENODEV;\n\t}\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn ret;\n}\n\nstatic int w1_reg_a8_v16_write(void *context, unsigned int reg,\n\t\t\t\tunsigned int val)\n{\n\tstruct device *dev = context;\n\tstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\n\tint ret = 0;\n\n\tif (reg > 255)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\tif (!w1_reset_select_slave(sl)) {\n\t\tw1_write_8(sl->master, W1_CMD_WRITE_DATA);\n\t\tw1_write_8(sl->master, reg);\n\t\tw1_write_8(sl->master, val & 0x00FF);\n\t\tw1_write_8(sl->master, val>>8 & 0x00FF);\n\t} else {\n\t\tret = -ENODEV;\n\t}\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn ret;\n}\n\n \n\nstatic int w1_reg_a16_v16_read(void *context, unsigned int reg,\n\t\t\t\tunsigned int *val)\n{\n\tstruct device *dev = context;\n\tstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\n\tint ret = 0;\n\n\tif (reg > 65535)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\tif (!w1_reset_select_slave(sl)) {\n\t\tw1_write_8(sl->master, W1_CMD_READ_DATA);\n\t\tw1_write_8(sl->master, reg & 0x00FF);\n\t\tw1_write_8(sl->master, reg>>8 & 0x00FF);\n\t\t*val = w1_read_8(sl->master);\n\t\t*val |= w1_read_8(sl->master)<<8;\n\t} else {\n\t\tret = -ENODEV;\n\t}\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn ret;\n}\n\nstatic int w1_reg_a16_v16_write(void *context, unsigned int reg,\n\t\t\t\tunsigned int val)\n{\n\tstruct device *dev = context;\n\tstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\n\tint ret = 0;\n\n\tif (reg > 65535)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\tif (!w1_reset_select_slave(sl)) {\n\t\tw1_write_8(sl->master, W1_CMD_WRITE_DATA);\n\t\tw1_write_8(sl->master, reg & 0x00FF);\n\t\tw1_write_8(sl->master, reg>>8 & 0x00FF);\n\t\tw1_write_8(sl->master, val & 0x00FF);\n\t\tw1_write_8(sl->master, val>>8 & 0x00FF);\n\t} else {\n\t\tret = -ENODEV;\n\t}\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn ret;\n}\n\n \n\nstatic const struct regmap_bus regmap_w1_bus_a8_v8 = {\n\t.reg_read = w1_reg_a8_v8_read,\n\t.reg_write = w1_reg_a8_v8_write,\n};\n\nstatic const struct regmap_bus regmap_w1_bus_a8_v16 = {\n\t.reg_read = w1_reg_a8_v16_read,\n\t.reg_write = w1_reg_a8_v16_write,\n};\n\nstatic const struct regmap_bus regmap_w1_bus_a16_v16 = {\n\t.reg_read = w1_reg_a16_v16_read,\n\t.reg_write = w1_reg_a16_v16_write,\n};\n\nstatic const struct regmap_bus *regmap_get_w1_bus(struct device *w1_dev,\n\t\t\t\t\tconst struct regmap_config *config)\n{\n\tif (config->reg_bits == 8 && config->val_bits == 8)\n\t\treturn &regmap_w1_bus_a8_v8;\n\n\tif (config->reg_bits == 8 && config->val_bits == 16)\n\t\treturn &regmap_w1_bus_a8_v16;\n\n\tif (config->reg_bits == 16 && config->val_bits == 16)\n\t\treturn &regmap_w1_bus_a16_v16;\n\n\treturn ERR_PTR(-ENOTSUPP);\n}\n\nstruct regmap *__regmap_init_w1(struct device *w1_dev,\n\t\t\t\t const struct regmap_config *config,\n\t\t\t\t struct lock_class_key *lock_key,\n\t\t\t\t const char *lock_name)\n{\n\n\tconst struct regmap_bus *bus = regmap_get_w1_bus(w1_dev, config);\n\n\tif (IS_ERR(bus))\n\t\treturn ERR_CAST(bus);\n\n\treturn __regmap_init(w1_dev, bus, w1_dev, config,\n\t\t\t lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__regmap_init_w1);\n\nstruct regmap *__devm_regmap_init_w1(struct device *w1_dev,\n\t\t\t\t const struct regmap_config *config,\n\t\t\t\t struct lock_class_key *lock_key,\n\t\t\t\t const char *lock_name)\n{\n\n\tconst struct regmap_bus *bus = regmap_get_w1_bus(w1_dev, config);\n\n\tif (IS_ERR(bus))\n\t\treturn ERR_CAST(bus);\n\n\treturn __devm_regmap_init(w1_dev, bus, w1_dev, config,\n\t\t\t\t lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__devm_regmap_init_w1);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}