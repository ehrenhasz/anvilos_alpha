{
  "module_name": "regmap-spi-avmm.c",
  "hash_id": "50a3b20989195db2c1219998750a8305f2eb9c9c8c9bba38a0d2b0cf99518c85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regmap-spi-avmm.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/swab.h>\n\n \n\n#define PKT_SOP\t\t\t0x7a\n#define PKT_EOP\t\t\t0x7b\n#define PKT_CHANNEL\t\t0x7c\n#define PKT_ESC\t\t\t0x7d\n\n#define PHY_IDLE\t\t0x4a\n#define PHY_ESC\t\t\t0x4d\n\n#define TRANS_CODE_WRITE\t0x0\n#define TRANS_CODE_SEQ_WRITE\t0x4\n#define TRANS_CODE_READ\t\t0x10\n#define TRANS_CODE_SEQ_READ\t0x14\n#define TRANS_CODE_NO_TRANS\t0x7f\n\n#define SPI_AVMM_XFER_TIMEOUT\t(msecs_to_jiffies(200))\n\n \n#define SPI_AVMM_REG_SIZE\t\t4UL\n \n#define SPI_AVMM_VAL_SIZE\t\t4UL\n\n \n#define MAX_READ_CNT\t\t256UL\n#define MAX_WRITE_CNT\t\t1UL\n\nstruct trans_req_header {\n\tu8 code;\n\tu8 rsvd;\n\t__be16 size;\n\t__be32 addr;\n} __packed;\n\nstruct trans_resp_header {\n\tu8 r_code;\n\tu8 rsvd;\n\t__be16 size;\n} __packed;\n\n#define TRANS_REQ_HD_SIZE\t(sizeof(struct trans_req_header))\n#define TRANS_RESP_HD_SIZE\t(sizeof(struct trans_resp_header))\n\n \n#define TRANS_WR_TX_SIZE(n)\t(TRANS_REQ_HD_SIZE + SPI_AVMM_VAL_SIZE * (n))\n#define TRANS_RD_TX_SIZE\tTRANS_REQ_HD_SIZE\n#define TRANS_TX_MAX\t\tTRANS_WR_TX_SIZE(MAX_WRITE_CNT)\n\n#define TRANS_RD_RX_SIZE(n)\t(SPI_AVMM_VAL_SIZE * (n))\n#define TRANS_WR_RX_SIZE\tTRANS_RESP_HD_SIZE\n#define TRANS_RX_MAX\t\tTRANS_RD_RX_SIZE(MAX_READ_CNT)\n\n \n#define TRANS_BUF_SIZE\t\t((TRANS_TX_MAX > TRANS_RX_MAX) ?\t\\\n\t\t\t\t TRANS_TX_MAX : TRANS_RX_MAX)\n\n \n#define PHY_TX_MAX\t\tALIGN(2 * TRANS_TX_MAX + 4, 4)\n\n \n#define PHY_BUF_SIZE\t\tPHY_TX_MAX\n\n \nstruct spi_avmm_bridge {\n\tstruct spi_device *spi;\n\tunsigned char word_len;\n\tunsigned int trans_len;\n\tunsigned int phy_len;\n\t \n\tchar trans_buf[TRANS_BUF_SIZE];\n\tchar phy_buf[PHY_BUF_SIZE];\n\tvoid (*swap_words)(void *buf, unsigned int len);\n};\n\nstatic void br_swap_words_32(void *buf, unsigned int len)\n{\n\tswab32_array(buf, len / 4);\n}\n\n \nstatic int br_trans_tx_prepare(struct spi_avmm_bridge *br, bool is_read, u32 reg,\n\t\t\t       u32 *wr_val, u32 count)\n{\n\tstruct trans_req_header *header;\n\tunsigned int trans_len;\n\tu8 code;\n\t__le32 *data;\n\tint i;\n\n\tif (is_read) {\n\t\tif (count == 1)\n\t\t\tcode = TRANS_CODE_READ;\n\t\telse\n\t\t\tcode = TRANS_CODE_SEQ_READ;\n\t} else {\n\t\tif (count == 1)\n\t\t\tcode = TRANS_CODE_WRITE;\n\t\telse\n\t\t\tcode = TRANS_CODE_SEQ_WRITE;\n\t}\n\n\theader = (struct trans_req_header *)br->trans_buf;\n\theader->code = code;\n\theader->rsvd = 0;\n\theader->size = cpu_to_be16((u16)count * SPI_AVMM_VAL_SIZE);\n\theader->addr = cpu_to_be32(reg);\n\n\ttrans_len = TRANS_REQ_HD_SIZE;\n\n\tif (!is_read) {\n\t\ttrans_len += SPI_AVMM_VAL_SIZE * count;\n\t\tif (trans_len > sizeof(br->trans_buf))\n\t\t\treturn -ENOMEM;\n\n\t\tdata = (__le32 *)(br->trans_buf + TRANS_REQ_HD_SIZE);\n\n\t\tfor (i = 0; i < count; i++)\n\t\t\t*data++ = cpu_to_le32(*wr_val++);\n\t}\n\n\t \n\tbr->trans_len = trans_len;\n\n\treturn 0;\n}\n\n \nstatic int br_pkt_phy_tx_prepare(struct spi_avmm_bridge *br)\n{\n\tchar *tb, *tb_end, *pb, *pb_limit, *pb_eop = NULL;\n\tunsigned int aligned_phy_len, move_size;\n\tbool need_esc = false;\n\n\ttb = br->trans_buf;\n\ttb_end = tb + br->trans_len;\n\tpb = br->phy_buf;\n\tpb_limit = pb + ARRAY_SIZE(br->phy_buf);\n\n\t*pb++ = PKT_SOP;\n\n\t \n\t*pb++ = PKT_CHANNEL;\n\t*pb++ = 0x0;\n\n\tfor (; pb < pb_limit && tb < tb_end; pb++) {\n\t\tif (need_esc) {\n\t\t\t*pb = *tb++ ^ 0x20;\n\t\t\tneed_esc = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (tb == tb_end - 1 && !pb_eop) {\n\t\t\t*pb = PKT_EOP;\n\t\t\tpb_eop = pb;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tswitch (*tb) {\n\t\tcase PKT_SOP:\n\t\tcase PKT_EOP:\n\t\tcase PKT_CHANNEL:\n\t\tcase PKT_ESC:\n\t\t\t*pb = PKT_ESC;\n\t\t\tneed_esc = true;\n\t\t\tbreak;\n\t\tcase PHY_IDLE:\n\t\tcase PHY_ESC:\n\t\t\t*pb = PHY_ESC;\n\t\t\tneed_esc = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*pb = *tb++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (tb < tb_end)\n\t\treturn -ENOMEM;\n\n\t \n\tbr->phy_len = pb - br->phy_buf;\n\n\tif (br->word_len == 1)\n\t\treturn 0;\n\n\t \n\taligned_phy_len = ALIGN(br->phy_len, br->word_len);\n\tif (aligned_phy_len > sizeof(br->phy_buf))\n\t\treturn -ENOMEM;\n\n\tif (aligned_phy_len == br->phy_len)\n\t\treturn 0;\n\n\t \n\tmove_size = pb - pb_eop;\n\tmemmove(&br->phy_buf[aligned_phy_len - move_size], pb_eop, move_size);\n\n\t \n\tmemset(pb_eop, PHY_IDLE, aligned_phy_len - br->phy_len);\n\n\t \n\tbr->phy_len = aligned_phy_len;\n\n\treturn 0;\n}\n\n \nstatic int br_do_tx(struct spi_avmm_bridge *br)\n{\n\t \n\tif (br->swap_words)\n\t\tbr->swap_words(br->phy_buf, br->phy_len);\n\n\t \n\treturn spi_write(br->spi, br->phy_buf, br->phy_len);\n}\n\n \nstatic int br_do_rx_and_pkt_phy_parse(struct spi_avmm_bridge *br)\n{\n\tbool eop_found = false, channel_found = false, esc_found = false;\n\tbool valid_word = false, last_try = false;\n\tstruct device *dev = &br->spi->dev;\n\tchar *pb, *tb_limit, *tb = NULL;\n\tunsigned long poll_timeout;\n\tint ret, i;\n\n\ttb_limit = br->trans_buf + ARRAY_SIZE(br->trans_buf);\n\tpb = br->phy_buf;\n\tpoll_timeout = jiffies + SPI_AVMM_XFER_TIMEOUT;\n\twhile (tb < tb_limit) {\n\t\tret = spi_read(br->spi, pb, br->word_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (br->swap_words)\n\t\t\tbr->swap_words(pb, br->word_len);\n\n\t\tvalid_word = false;\n\t\tfor (i = 0; i < br->word_len; i++) {\n\t\t\t \n\t\t\tif (!tb && pb[i] != PKT_SOP)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (pb[i] == PHY_IDLE)\n\t\t\t\tcontinue;\n\n\t\t\tvalid_word = true;\n\n\t\t\t \n\t\t\tif (channel_found) {\n\t\t\t\tif (pb[i] != 0) {\n\t\t\t\t\tdev_err(dev, \"%s channel num != 0\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\n\t\t\t\tchannel_found = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (pb[i]) {\n\t\t\tcase PKT_SOP:\n\t\t\t\t \n\t\t\t\ttb = br->trans_buf;\n\t\t\t\teop_found = false;\n\t\t\t\tchannel_found = false;\n\t\t\t\tesc_found = false;\n\t\t\t\tbreak;\n\t\t\tcase PKT_EOP:\n\t\t\t\t \n\t\t\t\tif (esc_found || eop_found)\n\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\teop_found = true;\n\t\t\t\tbreak;\n\t\t\tcase PKT_CHANNEL:\n\t\t\t\tif (esc_found || eop_found)\n\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\tchannel_found = true;\n\t\t\t\tbreak;\n\t\t\tcase PKT_ESC:\n\t\t\tcase PHY_ESC:\n\t\t\t\tif (esc_found)\n\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\tesc_found = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tif (esc_found) {\n\t\t\t\t\t*tb++ = pb[i] ^ 0x20;\n\t\t\t\t\tesc_found = false;\n\t\t\t\t} else {\n\t\t\t\t\t*tb++ = pb[i];\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (eop_found) {\n\t\t\t\t\tbr->trans_len = tb - br->trans_buf;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (valid_word) {\n\t\t\t \n\t\t\tpoll_timeout = jiffies + SPI_AVMM_XFER_TIMEOUT;\n\t\t\tlast_try = false;\n\t\t} else {\n\t\t\t \n\t\t\tif (last_try)\n\t\t\t\treturn -ETIMEDOUT;\n\n\t\t\tif (time_after(jiffies, poll_timeout))\n\t\t\t\tlast_try = true;\n\t\t}\n\t}\n\n\t \n\tdev_err(dev, \"%s transfer buffer is full but rx doesn't end\\n\",\n\t\t__func__);\n\n\treturn -EFAULT;\n}\n\n \nstatic int br_rd_trans_rx_parse(struct spi_avmm_bridge *br,\n\t\t\t\tu32 *val, unsigned int expected_count)\n{\n\tunsigned int i, trans_len = br->trans_len;\n\t__le32 *data;\n\n\tif (expected_count * SPI_AVMM_VAL_SIZE != trans_len)\n\t\treturn -EFAULT;\n\n\tdata = (__le32 *)br->trans_buf;\n\tfor (i = 0; i < expected_count; i++)\n\t\t*val++ = le32_to_cpu(*data++);\n\n\treturn 0;\n}\n\n \nstatic int br_wr_trans_rx_parse(struct spi_avmm_bridge *br,\n\t\t\t\tunsigned int expected_count)\n{\n\tunsigned int trans_len = br->trans_len;\n\tstruct trans_resp_header *resp;\n\tu8 code;\n\tu16 val_len;\n\n\tif (trans_len != TRANS_RESP_HD_SIZE)\n\t\treturn -EFAULT;\n\n\tresp = (struct trans_resp_header *)br->trans_buf;\n\n\tcode = resp->r_code ^ 0x80;\n\tval_len = be16_to_cpu(resp->size);\n\tif (!val_len || val_len != expected_count * SPI_AVMM_VAL_SIZE)\n\t\treturn -EFAULT;\n\n\t \n\tif ((val_len == SPI_AVMM_VAL_SIZE && code != TRANS_CODE_WRITE) ||\n\t    (val_len > SPI_AVMM_VAL_SIZE && code != TRANS_CODE_SEQ_WRITE))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int do_reg_access(void *context, bool is_read, unsigned int reg,\n\t\t\t unsigned int *value, unsigned int count)\n{\n\tstruct spi_avmm_bridge *br = context;\n\tint ret;\n\n\t \n\tbr->trans_len = 0;\n\tbr->phy_len = 0;\n\n\tret = br_trans_tx_prepare(br, is_read, reg, value, count);\n\tif (ret)\n\t\treturn ret;\n\n\tret = br_pkt_phy_tx_prepare(br);\n\tif (ret)\n\t\treturn ret;\n\n\tret = br_do_tx(br);\n\tif (ret)\n\t\treturn ret;\n\n\tret = br_do_rx_and_pkt_phy_parse(br);\n\tif (ret)\n\t\treturn ret;\n\n\tif (is_read)\n\t\treturn br_rd_trans_rx_parse(br, value, count);\n\telse\n\t\treturn br_wr_trans_rx_parse(br, count);\n}\n\nstatic int regmap_spi_avmm_gather_write(void *context,\n\t\t\t\t\tconst void *reg_buf, size_t reg_len,\n\t\t\t\t\tconst void *val_buf, size_t val_len)\n{\n\tif (reg_len != SPI_AVMM_REG_SIZE)\n\t\treturn -EINVAL;\n\n\tif (!IS_ALIGNED(val_len, SPI_AVMM_VAL_SIZE))\n\t\treturn -EINVAL;\n\n\treturn do_reg_access(context, false, *(u32 *)reg_buf, (u32 *)val_buf,\n\t\t\t     val_len / SPI_AVMM_VAL_SIZE);\n}\n\nstatic int regmap_spi_avmm_write(void *context, const void *data, size_t bytes)\n{\n\tif (bytes < SPI_AVMM_REG_SIZE + SPI_AVMM_VAL_SIZE)\n\t\treturn -EINVAL;\n\n\treturn regmap_spi_avmm_gather_write(context, data, SPI_AVMM_REG_SIZE,\n\t\t\t\t\t    data + SPI_AVMM_REG_SIZE,\n\t\t\t\t\t    bytes - SPI_AVMM_REG_SIZE);\n}\n\nstatic int regmap_spi_avmm_read(void *context,\n\t\t\t\tconst void *reg_buf, size_t reg_len,\n\t\t\t\tvoid *val_buf, size_t val_len)\n{\n\tif (reg_len != SPI_AVMM_REG_SIZE)\n\t\treturn -EINVAL;\n\n\tif (!IS_ALIGNED(val_len, SPI_AVMM_VAL_SIZE))\n\t\treturn -EINVAL;\n\n\treturn do_reg_access(context, true, *(u32 *)reg_buf, val_buf,\n\t\t\t     (val_len / SPI_AVMM_VAL_SIZE));\n}\n\nstatic struct spi_avmm_bridge *\nspi_avmm_bridge_ctx_gen(struct spi_device *spi)\n{\n\tstruct spi_avmm_bridge *br;\n\n\tif (!spi)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t \n\tspi->mode = SPI_MODE_1;\n\tspi->bits_per_word = 32;\n\tif (spi_setup(spi)) {\n\t\tspi->bits_per_word = 8;\n\t\tif (spi_setup(spi))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbr = kzalloc(sizeof(*br), GFP_KERNEL);\n\tif (!br)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbr->spi = spi;\n\tbr->word_len = spi->bits_per_word / 8;\n\tif (br->word_len == 4) {\n\t\t \n\t\tbr->swap_words = br_swap_words_32;\n\t}\n\n\treturn br;\n}\n\nstatic void spi_avmm_bridge_ctx_free(void *context)\n{\n\tkfree(context);\n}\n\nstatic const struct regmap_bus regmap_spi_avmm_bus = {\n\t.write = regmap_spi_avmm_write,\n\t.gather_write = regmap_spi_avmm_gather_write,\n\t.read = regmap_spi_avmm_read,\n\t.reg_format_endian_default = REGMAP_ENDIAN_NATIVE,\n\t.val_format_endian_default = REGMAP_ENDIAN_NATIVE,\n\t.max_raw_read = SPI_AVMM_VAL_SIZE * MAX_READ_CNT,\n\t.max_raw_write = SPI_AVMM_VAL_SIZE * MAX_WRITE_CNT,\n\t.free_context = spi_avmm_bridge_ctx_free,\n};\n\nstruct regmap *__regmap_init_spi_avmm(struct spi_device *spi,\n\t\t\t\t      const struct regmap_config *config,\n\t\t\t\t      struct lock_class_key *lock_key,\n\t\t\t\t      const char *lock_name)\n{\n\tstruct spi_avmm_bridge *bridge;\n\tstruct regmap *map;\n\n\tbridge = spi_avmm_bridge_ctx_gen(spi);\n\tif (IS_ERR(bridge))\n\t\treturn ERR_CAST(bridge);\n\n\tmap = __regmap_init(&spi->dev, &regmap_spi_avmm_bus,\n\t\t\t    bridge, config, lock_key, lock_name);\n\tif (IS_ERR(map)) {\n\t\tspi_avmm_bridge_ctx_free(bridge);\n\t\treturn ERR_CAST(map);\n\t}\n\n\treturn map;\n}\nEXPORT_SYMBOL_GPL(__regmap_init_spi_avmm);\n\nstruct regmap *__devm_regmap_init_spi_avmm(struct spi_device *spi,\n\t\t\t\t\t   const struct regmap_config *config,\n\t\t\t\t\t   struct lock_class_key *lock_key,\n\t\t\t\t\t   const char *lock_name)\n{\n\tstruct spi_avmm_bridge *bridge;\n\tstruct regmap *map;\n\n\tbridge = spi_avmm_bridge_ctx_gen(spi);\n\tif (IS_ERR(bridge))\n\t\treturn ERR_CAST(bridge);\n\n\tmap = __devm_regmap_init(&spi->dev, &regmap_spi_avmm_bus,\n\t\t\t\t bridge, config, lock_key, lock_name);\n\tif (IS_ERR(map)) {\n\t\tspi_avmm_bridge_ctx_free(bridge);\n\t\treturn ERR_CAST(map);\n\t}\n\n\treturn map;\n}\nEXPORT_SYMBOL_GPL(__devm_regmap_init_spi_avmm);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}