{
  "module_name": "regcache.c",
  "hash_id": "1675fa1c00826d1f2b25413875daf4f376eb363a1a45e8825c66af9d9f2f6c1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regcache.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/bsearch.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n\n#include \"trace.h\"\n#include \"internal.h\"\n\nstatic const struct regcache_ops *cache_types[] = {\n\t&regcache_rbtree_ops,\n\t&regcache_maple_ops,\n\t&regcache_flat_ops,\n};\n\nstatic int regcache_hw_init(struct regmap *map)\n{\n\tint i, j;\n\tint ret;\n\tint count;\n\tunsigned int reg, val;\n\tvoid *tmp_buf;\n\n\tif (!map->num_reg_defaults_raw)\n\t\treturn -EINVAL;\n\n\t \n\tfor (count = 0, i = 0; i < map->num_reg_defaults_raw; i++)\n\t\tif (regmap_readable(map, i * map->reg_stride) &&\n\t\t    !regmap_volatile(map, i * map->reg_stride))\n\t\t\tcount++;\n\n\t \n\tif (!count) {\n\t\tmap->cache_bypass = true;\n\t\treturn 0;\n\t}\n\n\tmap->num_reg_defaults = count;\n\tmap->reg_defaults = kmalloc_array(count, sizeof(struct reg_default),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!map->reg_defaults)\n\t\treturn -ENOMEM;\n\n\tif (!map->reg_defaults_raw) {\n\t\tbool cache_bypass = map->cache_bypass;\n\t\tdev_warn(map->dev, \"No cache defaults, reading back from HW\\n\");\n\n\t\t \n\t\tmap->cache_bypass = true;\n\t\ttmp_buf = kmalloc(map->cache_size_raw, GFP_KERNEL);\n\t\tif (!tmp_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free;\n\t\t}\n\t\tret = regmap_raw_read(map, 0, tmp_buf,\n\t\t\t\t      map->cache_size_raw);\n\t\tmap->cache_bypass = cache_bypass;\n\t\tif (ret == 0) {\n\t\t\tmap->reg_defaults_raw = tmp_buf;\n\t\t\tmap->cache_free = true;\n\t\t} else {\n\t\t\tkfree(tmp_buf);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0, j = 0; i < map->num_reg_defaults_raw; i++) {\n\t\treg = i * map->reg_stride;\n\n\t\tif (!regmap_readable(map, reg))\n\t\t\tcontinue;\n\n\t\tif (regmap_volatile(map, reg))\n\t\t\tcontinue;\n\n\t\tif (map->reg_defaults_raw) {\n\t\t\tval = regcache_get_val(map, map->reg_defaults_raw, i);\n\t\t} else {\n\t\t\tbool cache_bypass = map->cache_bypass;\n\n\t\t\tmap->cache_bypass = true;\n\t\t\tret = regmap_read(map, reg, &val);\n\t\t\tmap->cache_bypass = cache_bypass;\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(map->dev, \"Failed to read %d: %d\\n\",\n\t\t\t\t\treg, ret);\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t}\n\n\t\tmap->reg_defaults[j].reg = reg;\n\t\tmap->reg_defaults[j].def = val;\n\t\tj++;\n\t}\n\n\treturn 0;\n\nerr_free:\n\tkfree(map->reg_defaults);\n\n\treturn ret;\n}\n\nint regcache_init(struct regmap *map, const struct regmap_config *config)\n{\n\tint ret;\n\tint i;\n\tvoid *tmp_buf;\n\n\tif (map->cache_type == REGCACHE_NONE) {\n\t\tif (config->reg_defaults || config->num_reg_defaults_raw)\n\t\t\tdev_warn(map->dev,\n\t\t\t\t \"No cache used with register defaults set!\\n\");\n\n\t\tmap->cache_bypass = true;\n\t\treturn 0;\n\t}\n\n\tif (config->reg_defaults && !config->num_reg_defaults) {\n\t\tdev_err(map->dev,\n\t\t\t \"Register defaults are set without the number!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (config->num_reg_defaults && !config->reg_defaults) {\n\t\tdev_err(map->dev,\n\t\t\t\"Register defaults number are set without the reg!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < config->num_reg_defaults; i++)\n\t\tif (config->reg_defaults[i].reg % map->reg_stride)\n\t\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(cache_types); i++)\n\t\tif (cache_types[i]->type == map->cache_type)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(cache_types)) {\n\t\tdev_err(map->dev, \"Could not match cache type: %d\\n\",\n\t\t\tmap->cache_type);\n\t\treturn -EINVAL;\n\t}\n\n\tmap->num_reg_defaults = config->num_reg_defaults;\n\tmap->num_reg_defaults_raw = config->num_reg_defaults_raw;\n\tmap->reg_defaults_raw = config->reg_defaults_raw;\n\tmap->cache_word_size = DIV_ROUND_UP(config->val_bits, 8);\n\tmap->cache_size_raw = map->cache_word_size * config->num_reg_defaults_raw;\n\n\tmap->cache = NULL;\n\tmap->cache_ops = cache_types[i];\n\n\tif (!map->cache_ops->read ||\n\t    !map->cache_ops->write ||\n\t    !map->cache_ops->name)\n\t\treturn -EINVAL;\n\n\t \n\tif (config->reg_defaults) {\n\t\ttmp_buf = kmemdup(config->reg_defaults, map->num_reg_defaults *\n\t\t\t\t  sizeof(struct reg_default), GFP_KERNEL);\n\t\tif (!tmp_buf)\n\t\t\treturn -ENOMEM;\n\t\tmap->reg_defaults = tmp_buf;\n\t} else if (map->num_reg_defaults_raw) {\n\t\t \n\t\tret = regcache_hw_init(map);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (map->cache_bypass)\n\t\t\treturn 0;\n\t}\n\n\tif (!map->max_register && map->num_reg_defaults_raw)\n\t\tmap->max_register = (map->num_reg_defaults_raw  - 1) * map->reg_stride;\n\n\tif (map->cache_ops->init) {\n\t\tdev_dbg(map->dev, \"Initializing %s cache\\n\",\n\t\t\tmap->cache_ops->name);\n\t\tret = map->cache_ops->init(map);\n\t\tif (ret)\n\t\t\tgoto err_free;\n\t}\n\treturn 0;\n\nerr_free:\n\tkfree(map->reg_defaults);\n\tif (map->cache_free)\n\t\tkfree(map->reg_defaults_raw);\n\n\treturn ret;\n}\n\nvoid regcache_exit(struct regmap *map)\n{\n\tif (map->cache_type == REGCACHE_NONE)\n\t\treturn;\n\n\tBUG_ON(!map->cache_ops);\n\n\tkfree(map->reg_defaults);\n\tif (map->cache_free)\n\t\tkfree(map->reg_defaults_raw);\n\n\tif (map->cache_ops->exit) {\n\t\tdev_dbg(map->dev, \"Destroying %s cache\\n\",\n\t\t\tmap->cache_ops->name);\n\t\tmap->cache_ops->exit(map);\n\t}\n}\n\n \nint regcache_read(struct regmap *map,\n\t\t  unsigned int reg, unsigned int *value)\n{\n\tint ret;\n\n\tif (map->cache_type == REGCACHE_NONE)\n\t\treturn -EINVAL;\n\n\tBUG_ON(!map->cache_ops);\n\n\tif (!regmap_volatile(map, reg)) {\n\t\tret = map->cache_ops->read(map, reg, value);\n\n\t\tif (ret == 0)\n\t\t\ttrace_regmap_reg_read_cache(map, reg, *value);\n\n\t\treturn ret;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nint regcache_write(struct regmap *map,\n\t\t   unsigned int reg, unsigned int value)\n{\n\tif (map->cache_type == REGCACHE_NONE)\n\t\treturn 0;\n\n\tBUG_ON(!map->cache_ops);\n\n\tif (!regmap_volatile(map, reg))\n\t\treturn map->cache_ops->write(map, reg, value);\n\n\treturn 0;\n}\n\nbool regcache_reg_needs_sync(struct regmap *map, unsigned int reg,\n\t\t\t     unsigned int val)\n{\n\tint ret;\n\n\tif (!regmap_writeable(map, reg))\n\t\treturn false;\n\n\t \n\tif (!map->no_sync_defaults)\n\t\treturn true;\n\n\t \n\tret = regcache_lookup_reg(map, reg);\n\tif (ret >= 0 && val == map->reg_defaults[ret].def)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int regcache_default_sync(struct regmap *map, unsigned int min,\n\t\t\t\t unsigned int max)\n{\n\tunsigned int reg;\n\n\tfor (reg = min; reg <= max; reg += map->reg_stride) {\n\t\tunsigned int val;\n\t\tint ret;\n\n\t\tif (regmap_volatile(map, reg) ||\n\t\t    !regmap_writeable(map, reg))\n\t\t\tcontinue;\n\n\t\tret = regcache_read(map, reg, &val);\n\t\tif (ret == -ENOENT)\n\t\t\tcontinue;\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!regcache_reg_needs_sync(map, reg, val))\n\t\t\tcontinue;\n\n\t\tmap->cache_bypass = true;\n\t\tret = _regmap_write(map, reg, val);\n\t\tmap->cache_bypass = false;\n\t\tif (ret) {\n\t\t\tdev_err(map->dev, \"Unable to sync register %#x. %d\\n\",\n\t\t\t\treg, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(map->dev, \"Synced register %#x, value %#x\\n\", reg, val);\n\t}\n\n\treturn 0;\n}\n\nstatic int rbtree_all(const void *key, const struct rb_node *node)\n{\n\treturn 0;\n}\n\n \nint regcache_sync(struct regmap *map)\n{\n\tint ret = 0;\n\tunsigned int i;\n\tconst char *name;\n\tbool bypass;\n\tstruct rb_node *node;\n\n\tif (WARN_ON(map->cache_type == REGCACHE_NONE))\n\t\treturn -EINVAL;\n\n\tBUG_ON(!map->cache_ops);\n\n\tmap->lock(map->lock_arg);\n\t \n\tbypass = map->cache_bypass;\n\tdev_dbg(map->dev, \"Syncing %s cache\\n\",\n\t\tmap->cache_ops->name);\n\tname = map->cache_ops->name;\n\ttrace_regcache_sync(map, name, \"start\");\n\n\tif (!map->cache_dirty)\n\t\tgoto out;\n\n\t \n\tmap->cache_bypass = true;\n\tfor (i = 0; i < map->patch_regs; i++) {\n\t\tret = _regmap_write(map, map->patch[i].reg, map->patch[i].def);\n\t\tif (ret != 0) {\n\t\t\tdev_err(map->dev, \"Failed to write %x = %x: %d\\n\",\n\t\t\t\tmap->patch[i].reg, map->patch[i].def, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmap->cache_bypass = false;\n\n\tif (map->cache_ops->sync)\n\t\tret = map->cache_ops->sync(map, 0, map->max_register);\n\telse\n\t\tret = regcache_default_sync(map, 0, map->max_register);\n\n\tif (ret == 0)\n\t\tmap->cache_dirty = false;\n\nout:\n\t \n\tmap->cache_bypass = bypass;\n\tmap->no_sync_defaults = false;\n\n\t \n\trb_for_each(node, 0, &map->range_tree, rbtree_all) {\n\t\tstruct regmap_range_node *this =\n\t\t\trb_entry(node, struct regmap_range_node, node);\n\n\t\t \n\t\tif (regcache_read(map, this->selector_reg, &i) != 0)\n\t\t\tcontinue;\n\n\t\tret = _regmap_write(map, this->selector_reg, i);\n\t\tif (ret != 0) {\n\t\t\tdev_err(map->dev, \"Failed to write %x = %x: %d\\n\",\n\t\t\t\tthis->selector_reg, i, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmap->unlock(map->lock_arg);\n\n\tregmap_async_complete(map);\n\n\ttrace_regcache_sync(map, name, \"stop\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regcache_sync);\n\n \nint regcache_sync_region(struct regmap *map, unsigned int min,\n\t\t\t unsigned int max)\n{\n\tint ret = 0;\n\tconst char *name;\n\tbool bypass;\n\n\tif (WARN_ON(map->cache_type == REGCACHE_NONE))\n\t\treturn -EINVAL;\n\n\tBUG_ON(!map->cache_ops);\n\n\tmap->lock(map->lock_arg);\n\n\t \n\tbypass = map->cache_bypass;\n\n\tname = map->cache_ops->name;\n\tdev_dbg(map->dev, \"Syncing %s cache from %d-%d\\n\", name, min, max);\n\n\ttrace_regcache_sync(map, name, \"start region\");\n\n\tif (!map->cache_dirty)\n\t\tgoto out;\n\n\tmap->async = true;\n\n\tif (map->cache_ops->sync)\n\t\tret = map->cache_ops->sync(map, min, max);\n\telse\n\t\tret = regcache_default_sync(map, min, max);\n\nout:\n\t \n\tmap->cache_bypass = bypass;\n\tmap->async = false;\n\tmap->no_sync_defaults = false;\n\tmap->unlock(map->lock_arg);\n\n\tregmap_async_complete(map);\n\n\ttrace_regcache_sync(map, name, \"stop region\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regcache_sync_region);\n\n \nint regcache_drop_region(struct regmap *map, unsigned int min,\n\t\t\t unsigned int max)\n{\n\tint ret = 0;\n\n\tif (!map->cache_ops || !map->cache_ops->drop)\n\t\treturn -EINVAL;\n\n\tmap->lock(map->lock_arg);\n\n\ttrace_regcache_drop_region(map, min, max);\n\n\tret = map->cache_ops->drop(map, min, max);\n\n\tmap->unlock(map->lock_arg);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regcache_drop_region);\n\n \nvoid regcache_cache_only(struct regmap *map, bool enable)\n{\n\tmap->lock(map->lock_arg);\n\tWARN_ON(map->cache_type != REGCACHE_NONE &&\n\t\tmap->cache_bypass && enable);\n\tmap->cache_only = enable;\n\ttrace_regmap_cache_only(map, enable);\n\tmap->unlock(map->lock_arg);\n}\nEXPORT_SYMBOL_GPL(regcache_cache_only);\n\n \nvoid regcache_mark_dirty(struct regmap *map)\n{\n\tmap->lock(map->lock_arg);\n\tmap->cache_dirty = true;\n\tmap->no_sync_defaults = true;\n\tmap->unlock(map->lock_arg);\n}\nEXPORT_SYMBOL_GPL(regcache_mark_dirty);\n\n \nvoid regcache_cache_bypass(struct regmap *map, bool enable)\n{\n\tmap->lock(map->lock_arg);\n\tWARN_ON(map->cache_only && enable);\n\tmap->cache_bypass = enable;\n\ttrace_regmap_cache_bypass(map, enable);\n\tmap->unlock(map->lock_arg);\n}\nEXPORT_SYMBOL_GPL(regcache_cache_bypass);\n\n \nbool regcache_reg_cached(struct regmap *map, unsigned int reg)\n{\n\tunsigned int val;\n\tint ret;\n\n\tmap->lock(map->lock_arg);\n\n\tret = regcache_read(map, reg, &val);\n\n\tmap->unlock(map->lock_arg);\n\n\treturn ret == 0;\n}\nEXPORT_SYMBOL_GPL(regcache_reg_cached);\n\nvoid regcache_set_val(struct regmap *map, void *base, unsigned int idx,\n\t\t      unsigned int val)\n{\n\t \n\tif (map->format.format_val) {\n\t\tmap->format.format_val(base + (map->cache_word_size * idx),\n\t\t\t\t       val, 0);\n\t\treturn;\n\t}\n\n\tswitch (map->cache_word_size) {\n\tcase 1: {\n\t\tu8 *cache = base;\n\n\t\tcache[idx] = val;\n\t\tbreak;\n\t}\n\tcase 2: {\n\t\tu16 *cache = base;\n\n\t\tcache[idx] = val;\n\t\tbreak;\n\t}\n\tcase 4: {\n\t\tu32 *cache = base;\n\n\t\tcache[idx] = val;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nunsigned int regcache_get_val(struct regmap *map, const void *base,\n\t\t\t      unsigned int idx)\n{\n\tif (!base)\n\t\treturn -EINVAL;\n\n\t \n\tif (map->format.parse_val)\n\t\treturn map->format.parse_val(regcache_get_val_addr(map, base,\n\t\t\t\t\t\t\t\t   idx));\n\n\tswitch (map->cache_word_size) {\n\tcase 1: {\n\t\tconst u8 *cache = base;\n\n\t\treturn cache[idx];\n\t}\n\tcase 2: {\n\t\tconst u16 *cache = base;\n\n\t\treturn cache[idx];\n\t}\n\tcase 4: {\n\t\tconst u32 *cache = base;\n\n\t\treturn cache[idx];\n\t}\n\tdefault:\n\t\tBUG();\n\t}\n\t \n\treturn -1;\n}\n\nstatic int regcache_default_cmp(const void *a, const void *b)\n{\n\tconst struct reg_default *_a = a;\n\tconst struct reg_default *_b = b;\n\n\treturn _a->reg - _b->reg;\n}\n\nint regcache_lookup_reg(struct regmap *map, unsigned int reg)\n{\n\tstruct reg_default key;\n\tstruct reg_default *r;\n\n\tkey.reg = reg;\n\tkey.def = 0;\n\n\tr = bsearch(&key, map->reg_defaults, map->num_reg_defaults,\n\t\t    sizeof(struct reg_default), regcache_default_cmp);\n\n\tif (r)\n\t\treturn r - map->reg_defaults;\n\telse\n\t\treturn -ENOENT;\n}\n\nstatic bool regcache_reg_present(unsigned long *cache_present, unsigned int idx)\n{\n\tif (!cache_present)\n\t\treturn true;\n\n\treturn test_bit(idx, cache_present);\n}\n\nint regcache_sync_val(struct regmap *map, unsigned int reg, unsigned int val)\n{\n\tint ret;\n\n\tif (!regcache_reg_needs_sync(map, reg, val))\n\t\treturn 0;\n\n\tmap->cache_bypass = true;\n\n\tret = _regmap_write(map, reg, val);\n\n\tmap->cache_bypass = false;\n\n\tif (ret != 0) {\n\t\tdev_err(map->dev, \"Unable to sync register %#x. %d\\n\",\n\t\t\treg, ret);\n\t\treturn ret;\n\t}\n\tdev_dbg(map->dev, \"Synced register %#x, value %#x\\n\",\n\t\treg, val);\n\n\treturn 0;\n}\n\nstatic int regcache_sync_block_single(struct regmap *map, void *block,\n\t\t\t\t      unsigned long *cache_present,\n\t\t\t\t      unsigned int block_base,\n\t\t\t\t      unsigned int start, unsigned int end)\n{\n\tunsigned int i, regtmp, val;\n\tint ret;\n\n\tfor (i = start; i < end; i++) {\n\t\tregtmp = block_base + (i * map->reg_stride);\n\n\t\tif (!regcache_reg_present(cache_present, i) ||\n\t\t    !regmap_writeable(map, regtmp))\n\t\t\tcontinue;\n\n\t\tval = regcache_get_val(map, block, i);\n\t\tret = regcache_sync_val(map, regtmp, val);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int regcache_sync_block_raw_flush(struct regmap *map, const void **data,\n\t\t\t\t\t unsigned int base, unsigned int cur)\n{\n\tsize_t val_bytes = map->format.val_bytes;\n\tint ret, count;\n\n\tif (*data == NULL)\n\t\treturn 0;\n\n\tcount = (cur - base) / map->reg_stride;\n\n\tdev_dbg(map->dev, \"Writing %zu bytes for %d registers from 0x%x-0x%x\\n\",\n\t\tcount * val_bytes, count, base, cur - map->reg_stride);\n\n\tmap->cache_bypass = true;\n\n\tret = _regmap_raw_write(map, base, *data, count * val_bytes, false);\n\tif (ret)\n\t\tdev_err(map->dev, \"Unable to sync registers %#x-%#x. %d\\n\",\n\t\t\tbase, cur - map->reg_stride, ret);\n\n\tmap->cache_bypass = false;\n\n\t*data = NULL;\n\n\treturn ret;\n}\n\nstatic int regcache_sync_block_raw(struct regmap *map, void *block,\n\t\t\t    unsigned long *cache_present,\n\t\t\t    unsigned int block_base, unsigned int start,\n\t\t\t    unsigned int end)\n{\n\tunsigned int i, val;\n\tunsigned int regtmp = 0;\n\tunsigned int base = 0;\n\tconst void *data = NULL;\n\tint ret;\n\n\tfor (i = start; i < end; i++) {\n\t\tregtmp = block_base + (i * map->reg_stride);\n\n\t\tif (!regcache_reg_present(cache_present, i) ||\n\t\t    !regmap_writeable(map, regtmp)) {\n\t\t\tret = regcache_sync_block_raw_flush(map, &data,\n\t\t\t\t\t\t\t    base, regtmp);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tval = regcache_get_val(map, block, i);\n\t\tif (!regcache_reg_needs_sync(map, regtmp, val)) {\n\t\t\tret = regcache_sync_block_raw_flush(map, &data,\n\t\t\t\t\t\t\t    base, regtmp);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!data) {\n\t\t\tdata = regcache_get_val_addr(map, block, i);\n\t\t\tbase = regtmp;\n\t\t}\n\t}\n\n\treturn regcache_sync_block_raw_flush(map, &data, base, regtmp +\n\t\t\tmap->reg_stride);\n}\n\nint regcache_sync_block(struct regmap *map, void *block,\n\t\t\tunsigned long *cache_present,\n\t\t\tunsigned int block_base, unsigned int start,\n\t\t\tunsigned int end)\n{\n\tif (regmap_can_raw_write(map) && !map->use_single_write)\n\t\treturn regcache_sync_block_raw(map, block, cache_present,\n\t\t\t\t\t       block_base, start, end);\n\telse\n\t\treturn regcache_sync_block_single(map, block, cache_present,\n\t\t\t\t\t\t  block_base, start, end);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}