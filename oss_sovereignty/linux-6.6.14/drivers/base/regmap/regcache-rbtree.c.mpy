{
  "module_name": "regcache-rbtree.c",
  "hash_id": "6dd310f707f16517d38d55474971bbf3b15fb978b42944ce341d92c16f29dd74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regcache-rbtree.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/rbtree.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include \"internal.h\"\n\nstatic int regcache_rbtree_write(struct regmap *map, unsigned int reg,\n\t\t\t\t unsigned int value);\nstatic int regcache_rbtree_exit(struct regmap *map);\n\nstruct regcache_rbtree_node {\n\t \n\tvoid *block;\n\t \n\tunsigned long *cache_present;\n\t \n\tunsigned int base_reg;\n\t \n\tunsigned int blklen;\n\t \n\tstruct rb_node node;\n};\n\nstruct regcache_rbtree_ctx {\n\tstruct rb_root root;\n\tstruct regcache_rbtree_node *cached_rbnode;\n};\n\nstatic inline void regcache_rbtree_get_base_top_reg(\n\tstruct regmap *map,\n\tstruct regcache_rbtree_node *rbnode,\n\tunsigned int *base, unsigned int *top)\n{\n\t*base = rbnode->base_reg;\n\t*top = rbnode->base_reg + ((rbnode->blklen - 1) * map->reg_stride);\n}\n\nstatic unsigned int regcache_rbtree_get_register(struct regmap *map,\n\tstruct regcache_rbtree_node *rbnode, unsigned int idx)\n{\n\treturn regcache_get_val(map, rbnode->block, idx);\n}\n\nstatic void regcache_rbtree_set_register(struct regmap *map,\n\t\t\t\t\t struct regcache_rbtree_node *rbnode,\n\t\t\t\t\t unsigned int idx, unsigned int val)\n{\n\tset_bit(idx, rbnode->cache_present);\n\tregcache_set_val(map, rbnode->block, idx, val);\n}\n\nstatic struct regcache_rbtree_node *regcache_rbtree_lookup(struct regmap *map,\n\t\t\t\t\t\t\t   unsigned int reg)\n{\n\tstruct regcache_rbtree_ctx *rbtree_ctx = map->cache;\n\tstruct rb_node *node;\n\tstruct regcache_rbtree_node *rbnode;\n\tunsigned int base_reg, top_reg;\n\n\trbnode = rbtree_ctx->cached_rbnode;\n\tif (rbnode) {\n\t\tregcache_rbtree_get_base_top_reg(map, rbnode, &base_reg,\n\t\t\t\t\t\t &top_reg);\n\t\tif (reg >= base_reg && reg <= top_reg)\n\t\t\treturn rbnode;\n\t}\n\n\tnode = rbtree_ctx->root.rb_node;\n\twhile (node) {\n\t\trbnode = rb_entry(node, struct regcache_rbtree_node, node);\n\t\tregcache_rbtree_get_base_top_reg(map, rbnode, &base_reg,\n\t\t\t\t\t\t &top_reg);\n\t\tif (reg >= base_reg && reg <= top_reg) {\n\t\t\trbtree_ctx->cached_rbnode = rbnode;\n\t\t\treturn rbnode;\n\t\t} else if (reg > top_reg) {\n\t\t\tnode = node->rb_right;\n\t\t} else if (reg < base_reg) {\n\t\t\tnode = node->rb_left;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int regcache_rbtree_insert(struct regmap *map, struct rb_root *root,\n\t\t\t\t  struct regcache_rbtree_node *rbnode)\n{\n\tstruct rb_node **new, *parent;\n\tstruct regcache_rbtree_node *rbnode_tmp;\n\tunsigned int base_reg_tmp, top_reg_tmp;\n\tunsigned int base_reg;\n\n\tparent = NULL;\n\tnew = &root->rb_node;\n\twhile (*new) {\n\t\trbnode_tmp = rb_entry(*new, struct regcache_rbtree_node, node);\n\t\t \n\t\tregcache_rbtree_get_base_top_reg(map, rbnode_tmp, &base_reg_tmp,\n\t\t\t\t\t\t &top_reg_tmp);\n\t\t \n\t\tbase_reg = rbnode->base_reg;\n\t\tparent = *new;\n\t\t \n\t\tif (base_reg >= base_reg_tmp &&\n\t\t    base_reg <= top_reg_tmp)\n\t\t\treturn 0;\n\t\telse if (base_reg > top_reg_tmp)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse if (base_reg < base_reg_tmp)\n\t\t\tnew = &((*new)->rb_left);\n\t}\n\n\t \n\trb_link_node(&rbnode->node, parent, new);\n\trb_insert_color(&rbnode->node, root);\n\n\treturn 1;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int rbtree_show(struct seq_file *s, void *ignored)\n{\n\tstruct regmap *map = s->private;\n\tstruct regcache_rbtree_ctx *rbtree_ctx = map->cache;\n\tstruct regcache_rbtree_node *n;\n\tstruct rb_node *node;\n\tunsigned int base, top;\n\tsize_t mem_size;\n\tint nodes = 0;\n\tint registers = 0;\n\tint this_registers, average;\n\n\tmap->lock(map->lock_arg);\n\n\tmem_size = sizeof(*rbtree_ctx);\n\n\tfor (node = rb_first(&rbtree_ctx->root); node != NULL;\n\t     node = rb_next(node)) {\n\t\tn = rb_entry(node, struct regcache_rbtree_node, node);\n\t\tmem_size += sizeof(*n);\n\t\tmem_size += (n->blklen * map->cache_word_size);\n\t\tmem_size += BITS_TO_LONGS(n->blklen) * sizeof(long);\n\n\t\tregcache_rbtree_get_base_top_reg(map, n, &base, &top);\n\t\tthis_registers = ((top - base) / map->reg_stride) + 1;\n\t\tseq_printf(s, \"%x-%x (%d)\\n\", base, top, this_registers);\n\n\t\tnodes++;\n\t\tregisters += this_registers;\n\t}\n\n\tif (nodes)\n\t\taverage = registers / nodes;\n\telse\n\t\taverage = 0;\n\n\tseq_printf(s, \"%d nodes, %d registers, average %d registers, used %zu bytes\\n\",\n\t\t   nodes, registers, average, mem_size);\n\n\tmap->unlock(map->lock_arg);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(rbtree);\n\nstatic void rbtree_debugfs_init(struct regmap *map)\n{\n\tdebugfs_create_file(\"rbtree\", 0400, map->debugfs, map, &rbtree_fops);\n}\n#endif\n\nstatic int regcache_rbtree_init(struct regmap *map)\n{\n\tstruct regcache_rbtree_ctx *rbtree_ctx;\n\tint i;\n\tint ret;\n\n\tmap->cache = kmalloc(sizeof *rbtree_ctx, GFP_KERNEL);\n\tif (!map->cache)\n\t\treturn -ENOMEM;\n\n\trbtree_ctx = map->cache;\n\trbtree_ctx->root = RB_ROOT;\n\trbtree_ctx->cached_rbnode = NULL;\n\n\tfor (i = 0; i < map->num_reg_defaults; i++) {\n\t\tret = regcache_rbtree_write(map,\n\t\t\t\t\t    map->reg_defaults[i].reg,\n\t\t\t\t\t    map->reg_defaults[i].def);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tregcache_rbtree_exit(map);\n\treturn ret;\n}\n\nstatic int regcache_rbtree_exit(struct regmap *map)\n{\n\tstruct rb_node *next;\n\tstruct regcache_rbtree_ctx *rbtree_ctx;\n\tstruct regcache_rbtree_node *rbtree_node;\n\n\t \n\trbtree_ctx = map->cache;\n\tif (!rbtree_ctx)\n\t\treturn 0;\n\n\t \n\tnext = rb_first(&rbtree_ctx->root);\n\twhile (next) {\n\t\trbtree_node = rb_entry(next, struct regcache_rbtree_node, node);\n\t\tnext = rb_next(&rbtree_node->node);\n\t\trb_erase(&rbtree_node->node, &rbtree_ctx->root);\n\t\tkfree(rbtree_node->cache_present);\n\t\tkfree(rbtree_node->block);\n\t\tkfree(rbtree_node);\n\t}\n\n\t \n\tkfree(map->cache);\n\tmap->cache = NULL;\n\n\treturn 0;\n}\n\nstatic int regcache_rbtree_read(struct regmap *map,\n\t\t\t\tunsigned int reg, unsigned int *value)\n{\n\tstruct regcache_rbtree_node *rbnode;\n\tunsigned int reg_tmp;\n\n\trbnode = regcache_rbtree_lookup(map, reg);\n\tif (rbnode) {\n\t\treg_tmp = (reg - rbnode->base_reg) / map->reg_stride;\n\t\tif (!test_bit(reg_tmp, rbnode->cache_present))\n\t\t\treturn -ENOENT;\n\t\t*value = regcache_rbtree_get_register(map, rbnode, reg_tmp);\n\t} else {\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int regcache_rbtree_insert_to_block(struct regmap *map,\n\t\t\t\t\t   struct regcache_rbtree_node *rbnode,\n\t\t\t\t\t   unsigned int base_reg,\n\t\t\t\t\t   unsigned int top_reg,\n\t\t\t\t\t   unsigned int reg,\n\t\t\t\t\t   unsigned int value)\n{\n\tunsigned int blklen;\n\tunsigned int pos, offset;\n\tunsigned long *present;\n\tu8 *blk;\n\n\tblklen = (top_reg - base_reg) / map->reg_stride + 1;\n\tpos = (reg - base_reg) / map->reg_stride;\n\toffset = (rbnode->base_reg - base_reg) / map->reg_stride;\n\n\tblk = krealloc(rbnode->block,\n\t\t       blklen * map->cache_word_size,\n\t\t       map->alloc_flags);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\trbnode->block = blk;\n\n\tif (BITS_TO_LONGS(blklen) > BITS_TO_LONGS(rbnode->blklen)) {\n\t\tpresent = krealloc(rbnode->cache_present,\n\t\t\t\t   BITS_TO_LONGS(blklen) * sizeof(*present),\n\t\t\t\t   map->alloc_flags);\n\t\tif (!present)\n\t\t\treturn -ENOMEM;\n\n\t\tmemset(present + BITS_TO_LONGS(rbnode->blklen), 0,\n\t\t       (BITS_TO_LONGS(blklen) - BITS_TO_LONGS(rbnode->blklen))\n\t\t       * sizeof(*present));\n\t} else {\n\t\tpresent = rbnode->cache_present;\n\t}\n\n\t \n\tif (pos == 0) {\n\t\tmemmove(blk + offset * map->cache_word_size,\n\t\t\tblk, rbnode->blklen * map->cache_word_size);\n\t\tbitmap_shift_left(present, present, offset, blklen);\n\t}\n\n\t \n\trbnode->blklen = blklen;\n\trbnode->base_reg = base_reg;\n\trbnode->cache_present = present;\n\n\tregcache_rbtree_set_register(map, rbnode, pos, value);\n\treturn 0;\n}\n\nstatic struct regcache_rbtree_node *\nregcache_rbtree_node_alloc(struct regmap *map, unsigned int reg)\n{\n\tstruct regcache_rbtree_node *rbnode;\n\tconst struct regmap_range *range;\n\tint i;\n\n\trbnode = kzalloc(sizeof(*rbnode), map->alloc_flags);\n\tif (!rbnode)\n\t\treturn NULL;\n\n\t \n\tif (map->rd_table) {\n\t\tfor (i = 0; i < map->rd_table->n_yes_ranges; i++) {\n\t\t\tif (regmap_reg_in_range(reg,\n\t\t\t\t\t\t&map->rd_table->yes_ranges[i]))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i != map->rd_table->n_yes_ranges) {\n\t\t\trange = &map->rd_table->yes_ranges[i];\n\t\t\trbnode->blklen = (range->range_max - range->range_min) /\n\t\t\t\tmap->reg_stride\t+ 1;\n\t\t\trbnode->base_reg = range->range_min;\n\t\t}\n\t}\n\n\tif (!rbnode->blklen) {\n\t\trbnode->blklen = 1;\n\t\trbnode->base_reg = reg;\n\t}\n\n\trbnode->block = kmalloc_array(rbnode->blklen, map->cache_word_size,\n\t\t\t\t      map->alloc_flags);\n\tif (!rbnode->block)\n\t\tgoto err_free;\n\n\trbnode->cache_present = kcalloc(BITS_TO_LONGS(rbnode->blklen),\n\t\t\t\t\tsizeof(*rbnode->cache_present),\n\t\t\t\t\tmap->alloc_flags);\n\tif (!rbnode->cache_present)\n\t\tgoto err_free_block;\n\n\treturn rbnode;\n\nerr_free_block:\n\tkfree(rbnode->block);\nerr_free:\n\tkfree(rbnode);\n\treturn NULL;\n}\n\nstatic int regcache_rbtree_write(struct regmap *map, unsigned int reg,\n\t\t\t\t unsigned int value)\n{\n\tstruct regcache_rbtree_ctx *rbtree_ctx;\n\tstruct regcache_rbtree_node *rbnode, *rbnode_tmp;\n\tstruct rb_node *node;\n\tunsigned int reg_tmp;\n\tint ret;\n\n\trbtree_ctx = map->cache;\n\n\t \n\trbnode = regcache_rbtree_lookup(map, reg);\n\tif (rbnode) {\n\t\treg_tmp = (reg - rbnode->base_reg) / map->reg_stride;\n\t\tregcache_rbtree_set_register(map, rbnode, reg_tmp, value);\n\t} else {\n\t\tunsigned int base_reg, top_reg;\n\t\tunsigned int new_base_reg, new_top_reg;\n\t\tunsigned int min, max;\n\t\tunsigned int max_dist;\n\t\tunsigned int dist, best_dist = UINT_MAX;\n\n\t\tmax_dist = map->reg_stride * sizeof(*rbnode_tmp) /\n\t\t\tmap->cache_word_size;\n\t\tif (reg < max_dist)\n\t\t\tmin = 0;\n\t\telse\n\t\t\tmin = reg - max_dist;\n\t\tmax = reg + max_dist;\n\n\t\t \n\t\tnode = rbtree_ctx->root.rb_node;\n\t\twhile (node) {\n\t\t\trbnode_tmp = rb_entry(node, struct regcache_rbtree_node,\n\t\t\t\t\t      node);\n\n\t\t\tregcache_rbtree_get_base_top_reg(map, rbnode_tmp,\n\t\t\t\t&base_reg, &top_reg);\n\n\t\t\tif (base_reg <= max && top_reg >= min) {\n\t\t\t\tif (reg < base_reg)\n\t\t\t\t\tdist = base_reg - reg;\n\t\t\t\telse if (reg > top_reg)\n\t\t\t\t\tdist = reg - top_reg;\n\t\t\t\telse\n\t\t\t\t\tdist = 0;\n\t\t\t\tif (dist < best_dist) {\n\t\t\t\t\trbnode = rbnode_tmp;\n\t\t\t\t\tbest_dist = dist;\n\t\t\t\t\tnew_base_reg = min(reg, base_reg);\n\t\t\t\t\tnew_top_reg = max(reg, top_reg);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (reg < base_reg)\n\t\t\t\tnode = node->rb_left;\n\t\t\telse if (reg > top_reg)\n\t\t\t\tnode = node->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (rbnode) {\n\t\t\tret = regcache_rbtree_insert_to_block(map, rbnode,\n\t\t\t\t\t\t\t      new_base_reg,\n\t\t\t\t\t\t\t      new_top_reg, reg,\n\t\t\t\t\t\t\t      value);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\trbtree_ctx->cached_rbnode = rbnode;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\trbnode = regcache_rbtree_node_alloc(map, reg);\n\t\tif (!rbnode)\n\t\t\treturn -ENOMEM;\n\t\tregcache_rbtree_set_register(map, rbnode,\n\t\t\t\t\t     (reg - rbnode->base_reg) / map->reg_stride,\n\t\t\t\t\t     value);\n\t\tregcache_rbtree_insert(map, &rbtree_ctx->root, rbnode);\n\t\trbtree_ctx->cached_rbnode = rbnode;\n\t}\n\n\treturn 0;\n}\n\nstatic int regcache_rbtree_sync(struct regmap *map, unsigned int min,\n\t\t\t\tunsigned int max)\n{\n\tstruct regcache_rbtree_ctx *rbtree_ctx;\n\tstruct rb_node *node;\n\tstruct regcache_rbtree_node *rbnode;\n\tunsigned int base_reg, top_reg;\n\tunsigned int start, end;\n\tint ret;\n\n\tmap->async = true;\n\n\trbtree_ctx = map->cache;\n\tfor (node = rb_first(&rbtree_ctx->root); node; node = rb_next(node)) {\n\t\trbnode = rb_entry(node, struct regcache_rbtree_node, node);\n\n\t\tregcache_rbtree_get_base_top_reg(map, rbnode, &base_reg,\n\t\t\t&top_reg);\n\t\tif (base_reg > max)\n\t\t\tbreak;\n\t\tif (top_reg < min)\n\t\t\tcontinue;\n\n\t\tif (min > base_reg)\n\t\t\tstart = (min - base_reg) / map->reg_stride;\n\t\telse\n\t\t\tstart = 0;\n\n\t\tif (max < top_reg)\n\t\t\tend = (max - base_reg) / map->reg_stride + 1;\n\t\telse\n\t\t\tend = rbnode->blklen;\n\n\t\tret = regcache_sync_block(map, rbnode->block,\n\t\t\t\t\t  rbnode->cache_present,\n\t\t\t\t\t  rbnode->base_reg, start, end);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tmap->async = false;\n\n\treturn regmap_async_complete(map);\n}\n\nstatic int regcache_rbtree_drop(struct regmap *map, unsigned int min,\n\t\t\t\tunsigned int max)\n{\n\tstruct regcache_rbtree_ctx *rbtree_ctx;\n\tstruct regcache_rbtree_node *rbnode;\n\tstruct rb_node *node;\n\tunsigned int base_reg, top_reg;\n\tunsigned int start, end;\n\n\trbtree_ctx = map->cache;\n\tfor (node = rb_first(&rbtree_ctx->root); node; node = rb_next(node)) {\n\t\trbnode = rb_entry(node, struct regcache_rbtree_node, node);\n\n\t\tregcache_rbtree_get_base_top_reg(map, rbnode, &base_reg,\n\t\t\t&top_reg);\n\t\tif (base_reg > max)\n\t\t\tbreak;\n\t\tif (top_reg < min)\n\t\t\tcontinue;\n\n\t\tif (min > base_reg)\n\t\t\tstart = (min - base_reg) / map->reg_stride;\n\t\telse\n\t\t\tstart = 0;\n\n\t\tif (max < top_reg)\n\t\t\tend = (max - base_reg) / map->reg_stride + 1;\n\t\telse\n\t\t\tend = rbnode->blklen;\n\n\t\tbitmap_clear(rbnode->cache_present, start, end - start);\n\t}\n\n\treturn 0;\n}\n\nstruct regcache_ops regcache_rbtree_ops = {\n\t.type = REGCACHE_RBTREE,\n\t.name = \"rbtree\",\n\t.init = regcache_rbtree_init,\n\t.exit = regcache_rbtree_exit,\n#ifdef CONFIG_DEBUG_FS\n\t.debugfs_init = rbtree_debugfs_init,\n#endif\n\t.read = regcache_rbtree_read,\n\t.write = regcache_rbtree_write,\n\t.sync = regcache_rbtree_sync,\n\t.drop = regcache_rbtree_drop,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}