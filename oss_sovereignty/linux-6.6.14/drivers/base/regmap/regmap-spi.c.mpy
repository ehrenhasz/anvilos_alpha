{
  "module_name": "regmap-spi.c",
  "hash_id": "20cd5380f0a40b2e0d154a4136d222178d3113ac8e0885d1f66954e190603151",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regmap-spi.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/module.h>\n\n#include \"internal.h\"\n\nstruct regmap_async_spi {\n\tstruct regmap_async core;\n\tstruct spi_message m;\n\tstruct spi_transfer t[2];\n};\n\nstatic void regmap_spi_complete(void *data)\n{\n\tstruct regmap_async_spi *async = data;\n\n\tregmap_async_complete_cb(&async->core, async->m.status);\n}\n\nstatic int regmap_spi_write(void *context, const void *data, size_t count)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\n\treturn spi_write(spi, data, count);\n}\n\nstatic int regmap_spi_gather_write(void *context,\n\t\t\t\t   const void *reg, size_t reg_len,\n\t\t\t\t   const void *val, size_t val_len)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct spi_message m;\n\tstruct spi_transfer t[2] = { { .tx_buf = reg, .len = reg_len, },\n\t\t\t\t     { .tx_buf = val, .len = val_len, }, };\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t[0], &m);\n\tspi_message_add_tail(&t[1], &m);\n\n\treturn spi_sync(spi, &m);\n}\n\nstatic int regmap_spi_async_write(void *context,\n\t\t\t\t  const void *reg, size_t reg_len,\n\t\t\t\t  const void *val, size_t val_len,\n\t\t\t\t  struct regmap_async *a)\n{\n\tstruct regmap_async_spi *async = container_of(a,\n\t\t\t\t\t\t      struct regmap_async_spi,\n\t\t\t\t\t\t      core);\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\n\tasync->t[0].tx_buf = reg;\n\tasync->t[0].len = reg_len;\n\tasync->t[1].tx_buf = val;\n\tasync->t[1].len = val_len;\n\n\tspi_message_init(&async->m);\n\tspi_message_add_tail(&async->t[0], &async->m);\n\tif (val)\n\t\tspi_message_add_tail(&async->t[1], &async->m);\n\n\tasync->m.complete = regmap_spi_complete;\n\tasync->m.context = async;\n\n\treturn spi_async(spi, &async->m);\n}\n\nstatic struct regmap_async *regmap_spi_async_alloc(void)\n{\n\tstruct regmap_async_spi *async_spi;\n\n\tasync_spi = kzalloc(sizeof(*async_spi), GFP_KERNEL);\n\tif (!async_spi)\n\t\treturn NULL;\n\n\treturn &async_spi->core;\n}\n\nstatic int regmap_spi_read(void *context,\n\t\t\t   const void *reg, size_t reg_size,\n\t\t\t   void *val, size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\n\treturn spi_write_then_read(spi, reg, reg_size, val, val_size);\n}\n\nstatic const struct regmap_bus regmap_spi = {\n\t.write = regmap_spi_write,\n\t.gather_write = regmap_spi_gather_write,\n\t.async_write = regmap_spi_async_write,\n\t.async_alloc = regmap_spi_async_alloc,\n\t.read = regmap_spi_read,\n\t.read_flag_mask = 0x80,\n\t.reg_format_endian_default = REGMAP_ENDIAN_BIG,\n\t.val_format_endian_default = REGMAP_ENDIAN_BIG,\n};\n\nstatic const struct regmap_bus *regmap_get_spi_bus(struct spi_device *spi,\n\t\t\t\t\t\t   const struct regmap_config *config)\n{\n\tsize_t max_size = spi_max_transfer_size(spi);\n\tsize_t max_msg_size, reg_reserve_size;\n\tstruct regmap_bus *bus;\n\n\tif (max_size != SIZE_MAX) {\n\t\tbus = kmemdup(&regmap_spi, sizeof(*bus), GFP_KERNEL);\n\t\tif (!bus)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tmax_msg_size = spi_max_message_size(spi);\n\t\treg_reserve_size = config->reg_bits / BITS_PER_BYTE\n\t\t\t\t + config->pad_bits / BITS_PER_BYTE;\n\t\tif (max_size + reg_reserve_size > max_msg_size)\n\t\t\tmax_size -= reg_reserve_size;\n\n\t\tbus->free_on_exit = true;\n\t\tbus->max_raw_read = max_size;\n\t\tbus->max_raw_write = max_size;\n\n\t\treturn bus;\n\t}\n\n\treturn &regmap_spi;\n}\n\nstruct regmap *__regmap_init_spi(struct spi_device *spi,\n\t\t\t\t const struct regmap_config *config,\n\t\t\t\t struct lock_class_key *lock_key,\n\t\t\t\t const char *lock_name)\n{\n\tconst struct regmap_bus *bus = regmap_get_spi_bus(spi, config);\n\n\tif (IS_ERR(bus))\n\t\treturn ERR_CAST(bus);\n\n\treturn __regmap_init(&spi->dev, bus, &spi->dev, config, lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__regmap_init_spi);\n\nstruct regmap *__devm_regmap_init_spi(struct spi_device *spi,\n\t\t\t\t      const struct regmap_config *config,\n\t\t\t\t      struct lock_class_key *lock_key,\n\t\t\t\t      const char *lock_name)\n{\n\tconst struct regmap_bus *bus = regmap_get_spi_bus(spi, config);\n\n\tif (IS_ERR(bus))\n\t\treturn ERR_CAST(bus);\n\n\treturn __devm_regmap_init(&spi->dev, bus, &spi->dev, config, lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__devm_regmap_init_spi);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}