{
  "module_name": "regmap-mmio.c",
  "hash_id": "2d7dc35ded7d0fd6ed737d0ba2810f1650c4113f63d37ac7dc3cbf6196264cad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regmap-mmio.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/swab.h>\n\n#include \"internal.h\"\n\nstruct regmap_mmio_context {\n\tvoid __iomem *regs;\n\tunsigned int val_bytes;\n\tbool big_endian;\n\n\tbool attached_clk;\n\tstruct clk *clk;\n\n\tvoid (*reg_write)(struct regmap_mmio_context *ctx,\n\t\t\t  unsigned int reg, unsigned int val);\n\tunsigned int (*reg_read)(struct regmap_mmio_context *ctx,\n\t\t\t         unsigned int reg);\n};\n\nstatic int regmap_mmio_regbits_check(size_t reg_bits)\n{\n\tswitch (reg_bits) {\n\tcase 8:\n\tcase 16:\n\tcase 32:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int regmap_mmio_get_min_stride(size_t val_bits)\n{\n\tint min_stride;\n\n\tswitch (val_bits) {\n\tcase 8:\n\t\t \n\t\tmin_stride = 0;\n\t\tbreak;\n\tcase 16:\n\t\tmin_stride = 2;\n\t\tbreak;\n\tcase 32:\n\t\tmin_stride = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn min_stride;\n}\n\nstatic void regmap_mmio_write8(struct regmap_mmio_context *ctx,\n\t\t\t\tunsigned int reg,\n\t\t\t\tunsigned int val)\n{\n\twriteb(val, ctx->regs + reg);\n}\n\nstatic void regmap_mmio_write8_relaxed(struct regmap_mmio_context *ctx,\n\t\t\t\tunsigned int reg,\n\t\t\t\tunsigned int val)\n{\n\twriteb_relaxed(val, ctx->regs + reg);\n}\n\nstatic void regmap_mmio_iowrite8(struct regmap_mmio_context *ctx,\n\t\t\t\t unsigned int reg, unsigned int val)\n{\n\tiowrite8(val, ctx->regs + reg);\n}\n\nstatic void regmap_mmio_write16le(struct regmap_mmio_context *ctx,\n\t\t\t\t  unsigned int reg,\n\t\t\t\t  unsigned int val)\n{\n\twritew(val, ctx->regs + reg);\n}\n\nstatic void regmap_mmio_write16le_relaxed(struct regmap_mmio_context *ctx,\n\t\t\t\t  unsigned int reg,\n\t\t\t\t  unsigned int val)\n{\n\twritew_relaxed(val, ctx->regs + reg);\n}\n\nstatic void regmap_mmio_iowrite16le(struct regmap_mmio_context *ctx,\n\t\t\t\t    unsigned int reg, unsigned int val)\n{\n\tiowrite16(val, ctx->regs + reg);\n}\n\nstatic void regmap_mmio_write16be(struct regmap_mmio_context *ctx,\n\t\t\t\t  unsigned int reg,\n\t\t\t\t  unsigned int val)\n{\n\twritew(swab16(val), ctx->regs + reg);\n}\n\nstatic void regmap_mmio_iowrite16be(struct regmap_mmio_context *ctx,\n\t\t\t\t    unsigned int reg, unsigned int val)\n{\n\tiowrite16be(val, ctx->regs + reg);\n}\n\nstatic void regmap_mmio_write32le(struct regmap_mmio_context *ctx,\n\t\t\t\t  unsigned int reg,\n\t\t\t\t  unsigned int val)\n{\n\twritel(val, ctx->regs + reg);\n}\n\nstatic void regmap_mmio_write32le_relaxed(struct regmap_mmio_context *ctx,\n\t\t\t\t  unsigned int reg,\n\t\t\t\t  unsigned int val)\n{\n\twritel_relaxed(val, ctx->regs + reg);\n}\n\nstatic void regmap_mmio_iowrite32le(struct regmap_mmio_context *ctx,\n\t\t\t\t    unsigned int reg, unsigned int val)\n{\n\tiowrite32(val, ctx->regs + reg);\n}\n\nstatic void regmap_mmio_write32be(struct regmap_mmio_context *ctx,\n\t\t\t\t  unsigned int reg,\n\t\t\t\t  unsigned int val)\n{\n\twritel(swab32(val), ctx->regs + reg);\n}\n\nstatic void regmap_mmio_iowrite32be(struct regmap_mmio_context *ctx,\n\t\t\t\t    unsigned int reg, unsigned int val)\n{\n\tiowrite32be(val, ctx->regs + reg);\n}\n\nstatic int regmap_mmio_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct regmap_mmio_context *ctx = context;\n\tint ret;\n\n\tif (!IS_ERR(ctx->clk)) {\n\t\tret = clk_enable(ctx->clk);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tctx->reg_write(ctx, reg, val);\n\n\tif (!IS_ERR(ctx->clk))\n\t\tclk_disable(ctx->clk);\n\n\treturn 0;\n}\n\nstatic int regmap_mmio_noinc_write(void *context, unsigned int reg,\n\t\t\t\t   const void *val, size_t val_count)\n{\n\tstruct regmap_mmio_context *ctx = context;\n\tint ret = 0;\n\tint i;\n\n\tif (!IS_ERR(ctx->clk)) {\n\t\tret = clk_enable(ctx->clk);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (ctx->big_endian && (ctx->val_bytes > 1)) {\n\t\tswitch (ctx->val_bytes) {\n\t\tcase 2:\n\t\t{\n\t\t\tconst u16 *valp = (const u16 *)val;\n\t\t\tfor (i = 0; i < val_count; i++)\n\t\t\t\twritew(swab16(valp[i]), ctx->regs + reg);\n\t\t\tgoto out_clk;\n\t\t}\n\t\tcase 4:\n\t\t{\n\t\t\tconst u32 *valp = (const u32 *)val;\n\t\t\tfor (i = 0; i < val_count; i++)\n\t\t\t\twritel(swab32(valp[i]), ctx->regs + reg);\n\t\t\tgoto out_clk;\n\t\t}\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_clk;\n\t\t}\n\t}\n\n\tswitch (ctx->val_bytes) {\n\tcase 1:\n\t\twritesb(ctx->regs + reg, (const u8 *)val, val_count);\n\t\tbreak;\n\tcase 2:\n\t\twritesw(ctx->regs + reg, (const u16 *)val, val_count);\n\t\tbreak;\n\tcase 4:\n\t\twritesl(ctx->regs + reg, (const u32 *)val, val_count);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nout_clk:\n\tif (!IS_ERR(ctx->clk))\n\t\tclk_disable(ctx->clk);\n\n\treturn ret;\n}\n\nstatic unsigned int regmap_mmio_read8(struct regmap_mmio_context *ctx,\n\t\t\t\t      unsigned int reg)\n{\n\treturn readb(ctx->regs + reg);\n}\n\nstatic unsigned int regmap_mmio_read8_relaxed(struct regmap_mmio_context *ctx,\n\t\t\t\t      unsigned int reg)\n{\n\treturn readb_relaxed(ctx->regs + reg);\n}\n\nstatic unsigned int regmap_mmio_ioread8(struct regmap_mmio_context *ctx,\n\t\t\t\t\tunsigned int reg)\n{\n\treturn ioread8(ctx->regs + reg);\n}\n\nstatic unsigned int regmap_mmio_read16le(struct regmap_mmio_context *ctx,\n\t\t\t\t         unsigned int reg)\n{\n\treturn readw(ctx->regs + reg);\n}\n\nstatic unsigned int regmap_mmio_read16le_relaxed(struct regmap_mmio_context *ctx,\n\t\t\t\t\t\t unsigned int reg)\n{\n\treturn readw_relaxed(ctx->regs + reg);\n}\n\nstatic unsigned int regmap_mmio_ioread16le(struct regmap_mmio_context *ctx,\n\t\t\t\t\t   unsigned int reg)\n{\n\treturn ioread16(ctx->regs + reg);\n}\n\nstatic unsigned int regmap_mmio_read16be(struct regmap_mmio_context *ctx,\n\t\t\t\t         unsigned int reg)\n{\n\treturn swab16(readw(ctx->regs + reg));\n}\n\nstatic unsigned int regmap_mmio_ioread16be(struct regmap_mmio_context *ctx,\n\t\t\t\t\t   unsigned int reg)\n{\n\treturn ioread16be(ctx->regs + reg);\n}\n\nstatic unsigned int regmap_mmio_read32le(struct regmap_mmio_context *ctx,\n\t\t\t\t         unsigned int reg)\n{\n\treturn readl(ctx->regs + reg);\n}\n\nstatic unsigned int regmap_mmio_read32le_relaxed(struct regmap_mmio_context *ctx,\n\t\t\t\t\t\t unsigned int reg)\n{\n\treturn readl_relaxed(ctx->regs + reg);\n}\n\nstatic unsigned int regmap_mmio_ioread32le(struct regmap_mmio_context *ctx,\n\t\t\t\t\t   unsigned int reg)\n{\n\treturn ioread32(ctx->regs + reg);\n}\n\nstatic unsigned int regmap_mmio_read32be(struct regmap_mmio_context *ctx,\n\t\t\t\t         unsigned int reg)\n{\n\treturn swab32(readl(ctx->regs + reg));\n}\n\nstatic unsigned int regmap_mmio_ioread32be(struct regmap_mmio_context *ctx,\n\t\t\t\t\t   unsigned int reg)\n{\n\treturn ioread32be(ctx->regs + reg);\n}\n\nstatic int regmap_mmio_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct regmap_mmio_context *ctx = context;\n\tint ret;\n\n\tif (!IS_ERR(ctx->clk)) {\n\t\tret = clk_enable(ctx->clk);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t*val = ctx->reg_read(ctx, reg);\n\n\tif (!IS_ERR(ctx->clk))\n\t\tclk_disable(ctx->clk);\n\n\treturn 0;\n}\n\nstatic int regmap_mmio_noinc_read(void *context, unsigned int reg,\n\t\t\t\t  void *val, size_t val_count)\n{\n\tstruct regmap_mmio_context *ctx = context;\n\tint ret = 0;\n\n\tif (!IS_ERR(ctx->clk)) {\n\t\tret = clk_enable(ctx->clk);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tswitch (ctx->val_bytes) {\n\tcase 1:\n\t\treadsb(ctx->regs + reg, (u8 *)val, val_count);\n\t\tbreak;\n\tcase 2:\n\t\treadsw(ctx->regs + reg, (u16 *)val, val_count);\n\t\tbreak;\n\tcase 4:\n\t\treadsl(ctx->regs + reg, (u32 *)val, val_count);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out_clk;\n\t}\n\n\t \n\tif (ctx->big_endian && (ctx->val_bytes > 1)) {\n\t\tswitch (ctx->val_bytes) {\n\t\tcase 2:\n\t\t\tswab16_array(val, val_count);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tswab32_array(val, val_count);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_clk:\n\tif (!IS_ERR(ctx->clk))\n\t\tclk_disable(ctx->clk);\n\n\treturn ret;\n}\n\n\nstatic void regmap_mmio_free_context(void *context)\n{\n\tstruct regmap_mmio_context *ctx = context;\n\n\tif (!IS_ERR(ctx->clk)) {\n\t\tclk_unprepare(ctx->clk);\n\t\tif (!ctx->attached_clk)\n\t\t\tclk_put(ctx->clk);\n\t}\n\tkfree(context);\n}\n\nstatic const struct regmap_bus regmap_mmio = {\n\t.fast_io = true,\n\t.reg_write = regmap_mmio_write,\n\t.reg_read = regmap_mmio_read,\n\t.reg_noinc_write = regmap_mmio_noinc_write,\n\t.reg_noinc_read = regmap_mmio_noinc_read,\n\t.free_context = regmap_mmio_free_context,\n\t.val_format_endian_default = REGMAP_ENDIAN_LITTLE,\n};\n\nstatic struct regmap_mmio_context *regmap_mmio_gen_context(struct device *dev,\n\t\t\t\t\tconst char *clk_id,\n\t\t\t\t\tvoid __iomem *regs,\n\t\t\t\t\tconst struct regmap_config *config)\n{\n\tstruct regmap_mmio_context *ctx;\n\tint min_stride;\n\tint ret;\n\n\tret = regmap_mmio_regbits_check(config->reg_bits);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (config->pad_bits)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmin_stride = regmap_mmio_get_min_stride(config->val_bits);\n\tif (min_stride < 0)\n\t\treturn ERR_PTR(min_stride);\n\n\tif (config->reg_stride && config->reg_stride < min_stride)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (config->use_relaxed_mmio && config->io_port)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->regs = regs;\n\tctx->val_bytes = config->val_bits / 8;\n\tctx->clk = ERR_PTR(-ENODEV);\n\n\tswitch (regmap_get_val_endian(dev, &regmap_mmio, config)) {\n\tcase REGMAP_ENDIAN_DEFAULT:\n\tcase REGMAP_ENDIAN_LITTLE:\n#ifdef __LITTLE_ENDIAN\n\tcase REGMAP_ENDIAN_NATIVE:\n#endif\n\t\tswitch (config->val_bits) {\n\t\tcase 8:\n\t\t\tif (config->io_port) {\n\t\t\t\tctx->reg_read = regmap_mmio_ioread8;\n\t\t\t\tctx->reg_write = regmap_mmio_iowrite8;\n\t\t\t} else if (config->use_relaxed_mmio) {\n\t\t\t\tctx->reg_read = regmap_mmio_read8_relaxed;\n\t\t\t\tctx->reg_write = regmap_mmio_write8_relaxed;\n\t\t\t} else {\n\t\t\t\tctx->reg_read = regmap_mmio_read8;\n\t\t\t\tctx->reg_write = regmap_mmio_write8;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tif (config->io_port) {\n\t\t\t\tctx->reg_read = regmap_mmio_ioread16le;\n\t\t\t\tctx->reg_write = regmap_mmio_iowrite16le;\n\t\t\t} else if (config->use_relaxed_mmio) {\n\t\t\t\tctx->reg_read = regmap_mmio_read16le_relaxed;\n\t\t\t\tctx->reg_write = regmap_mmio_write16le_relaxed;\n\t\t\t} else {\n\t\t\t\tctx->reg_read = regmap_mmio_read16le;\n\t\t\t\tctx->reg_write = regmap_mmio_write16le;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tif (config->io_port) {\n\t\t\t\tctx->reg_read = regmap_mmio_ioread32le;\n\t\t\t\tctx->reg_write = regmap_mmio_iowrite32le;\n\t\t\t} else if (config->use_relaxed_mmio) {\n\t\t\t\tctx->reg_read = regmap_mmio_read32le_relaxed;\n\t\t\t\tctx->reg_write = regmap_mmio_write32le_relaxed;\n\t\t\t} else {\n\t\t\t\tctx->reg_read = regmap_mmio_read32le;\n\t\t\t\tctx->reg_write = regmap_mmio_write32le;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\t\tbreak;\n\tcase REGMAP_ENDIAN_BIG:\n#ifdef __BIG_ENDIAN\n\tcase REGMAP_ENDIAN_NATIVE:\n#endif\n\t\tctx->big_endian = true;\n\t\tswitch (config->val_bits) {\n\t\tcase 8:\n\t\t\tif (config->io_port) {\n\t\t\t\tctx->reg_read = regmap_mmio_ioread8;\n\t\t\t\tctx->reg_write = regmap_mmio_iowrite8;\n\t\t\t} else {\n\t\t\t\tctx->reg_read = regmap_mmio_read8;\n\t\t\t\tctx->reg_write = regmap_mmio_write8;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tif (config->io_port) {\n\t\t\t\tctx->reg_read = regmap_mmio_ioread16be;\n\t\t\t\tctx->reg_write = regmap_mmio_iowrite16be;\n\t\t\t} else {\n\t\t\t\tctx->reg_read = regmap_mmio_read16be;\n\t\t\t\tctx->reg_write = regmap_mmio_write16be;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tif (config->io_port) {\n\t\t\t\tctx->reg_read = regmap_mmio_ioread32be;\n\t\t\t\tctx->reg_write = regmap_mmio_iowrite32be;\n\t\t\t} else {\n\t\t\t\tctx->reg_read = regmap_mmio_read32be;\n\t\t\t\tctx->reg_write = regmap_mmio_write32be;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\tif (clk_id == NULL)\n\t\treturn ctx;\n\n\tctx->clk = clk_get(dev, clk_id);\n\tif (IS_ERR(ctx->clk)) {\n\t\tret = PTR_ERR(ctx->clk);\n\t\tgoto err_free;\n\t}\n\n\tret = clk_prepare(ctx->clk);\n\tif (ret < 0) {\n\t\tclk_put(ctx->clk);\n\t\tgoto err_free;\n\t}\n\n\treturn ctx;\n\nerr_free:\n\tkfree(ctx);\n\n\treturn ERR_PTR(ret);\n}\n\nstruct regmap *__regmap_init_mmio_clk(struct device *dev, const char *clk_id,\n\t\t\t\t      void __iomem *regs,\n\t\t\t\t      const struct regmap_config *config,\n\t\t\t\t      struct lock_class_key *lock_key,\n\t\t\t\t      const char *lock_name)\n{\n\tstruct regmap_mmio_context *ctx;\n\n\tctx = regmap_mmio_gen_context(dev, clk_id, regs, config);\n\tif (IS_ERR(ctx))\n\t\treturn ERR_CAST(ctx);\n\n\treturn __regmap_init(dev, &regmap_mmio, ctx, config,\n\t\t\t     lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__regmap_init_mmio_clk);\n\nstruct regmap *__devm_regmap_init_mmio_clk(struct device *dev,\n\t\t\t\t\t   const char *clk_id,\n\t\t\t\t\t   void __iomem *regs,\n\t\t\t\t\t   const struct regmap_config *config,\n\t\t\t\t\t   struct lock_class_key *lock_key,\n\t\t\t\t\t   const char *lock_name)\n{\n\tstruct regmap_mmio_context *ctx;\n\n\tctx = regmap_mmio_gen_context(dev, clk_id, regs, config);\n\tif (IS_ERR(ctx))\n\t\treturn ERR_CAST(ctx);\n\n\treturn __devm_regmap_init(dev, &regmap_mmio, ctx, config,\n\t\t\t\t  lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__devm_regmap_init_mmio_clk);\n\nint regmap_mmio_attach_clk(struct regmap *map, struct clk *clk)\n{\n\tstruct regmap_mmio_context *ctx = map->bus_context;\n\n\tctx->clk = clk;\n\tctx->attached_clk = true;\n\n\treturn clk_prepare(ctx->clk);\n}\nEXPORT_SYMBOL_GPL(regmap_mmio_attach_clk);\n\nvoid regmap_mmio_detach_clk(struct regmap *map)\n{\n\tstruct regmap_mmio_context *ctx = map->bus_context;\n\n\tclk_unprepare(ctx->clk);\n\n\tctx->attached_clk = false;\n\tctx->clk = NULL;\n}\nEXPORT_SYMBOL_GPL(regmap_mmio_detach_clk);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}