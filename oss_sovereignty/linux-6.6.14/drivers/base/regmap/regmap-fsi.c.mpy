{
  "module_name": "regmap-fsi.c",
  "hash_id": "5f3388aac19cfb51e89ca168b7b1c91d5de1a343512701c412664da0c5a75dec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regmap-fsi.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/fsi.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n#include \"internal.h\"\n\nstatic int regmap_fsi32_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tu32 v;\n\tint ret;\n\n\tret = fsi_slave_read(context, reg, &v, sizeof(v));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = v;\n\treturn 0;\n}\n\nstatic int regmap_fsi32_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tu32 v = val;\n\n\treturn fsi_slave_write(context, reg, &v, sizeof(v));\n}\n\nstatic const struct regmap_bus regmap_fsi32 = {\n\t.reg_write = regmap_fsi32_reg_write,\n\t.reg_read = regmap_fsi32_reg_read,\n};\n\nstatic int regmap_fsi32le_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\t__be32 v;\n\tint ret;\n\n\tret = fsi_slave_read(context, reg, &v, sizeof(v));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = be32_to_cpu(v);\n\treturn 0;\n}\n\nstatic int regmap_fsi32le_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\t__be32 v = cpu_to_be32(val);\n\n\treturn fsi_slave_write(context, reg, &v, sizeof(v));\n}\n\nstatic const struct regmap_bus regmap_fsi32le = {\n\t.reg_write = regmap_fsi32le_reg_write,\n\t.reg_read = regmap_fsi32le_reg_read,\n};\n\nstatic int regmap_fsi16_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tu16 v;\n\tint ret;\n\n\tret = fsi_slave_read(context, reg, &v, sizeof(v));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = v;\n\treturn 0;\n}\n\nstatic int regmap_fsi16_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tu16 v;\n\n\tif (val > 0xffff)\n\t\treturn -EINVAL;\n\n\tv = val;\n\treturn fsi_slave_write(context, reg, &v, sizeof(v));\n}\n\nstatic const struct regmap_bus regmap_fsi16 = {\n\t.reg_write = regmap_fsi16_reg_write,\n\t.reg_read = regmap_fsi16_reg_read,\n};\n\nstatic int regmap_fsi16le_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\t__be16 v;\n\tint ret;\n\n\tret = fsi_slave_read(context, reg, &v, sizeof(v));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = be16_to_cpu(v);\n\treturn 0;\n}\n\nstatic int regmap_fsi16le_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\t__be16 v;\n\n\tif (val > 0xffff)\n\t\treturn -EINVAL;\n\n\tv = cpu_to_be16(val);\n\treturn fsi_slave_write(context, reg, &v, sizeof(v));\n}\n\nstatic const struct regmap_bus regmap_fsi16le = {\n\t.reg_write = regmap_fsi16le_reg_write,\n\t.reg_read = regmap_fsi16le_reg_read,\n};\n\nstatic int regmap_fsi8_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tu8 v;\n\tint ret;\n\n\tret = fsi_slave_read(context, reg, &v, sizeof(v));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = v;\n\treturn 0;\n}\n\nstatic int regmap_fsi8_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tu8 v;\n\n\tif (val > 0xff)\n\t\treturn -EINVAL;\n\n\tv = val;\n\treturn fsi_slave_write(context, reg, &v, sizeof(v));\n}\n\nstatic const struct regmap_bus regmap_fsi8 = {\n\t.reg_write = regmap_fsi8_reg_write,\n\t.reg_read = regmap_fsi8_reg_read,\n};\n\nstatic const struct regmap_bus *regmap_get_fsi_bus(struct fsi_device *fsi_dev,\n\t\t\t\t\t\t   const struct regmap_config *config)\n{\n\tconst struct regmap_bus *bus = NULL;\n\n\tif (config->reg_bits == 8 || config->reg_bits == 16 || config->reg_bits == 32) {\n\t\tswitch (config->val_bits) {\n\t\tcase 8:\n\t\t\tbus = &regmap_fsi8;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tswitch (regmap_get_val_endian(&fsi_dev->dev, NULL, config)) {\n\t\t\tcase REGMAP_ENDIAN_LITTLE:\n#ifdef __LITTLE_ENDIAN\n\t\t\tcase REGMAP_ENDIAN_NATIVE:\n#endif\n\t\t\t\tbus = &regmap_fsi16le;\n\t\t\t\tbreak;\n\t\t\tcase REGMAP_ENDIAN_DEFAULT:\n\t\t\tcase REGMAP_ENDIAN_BIG:\n#ifdef __BIG_ENDIAN\n\t\t\tcase REGMAP_ENDIAN_NATIVE:\n#endif\n\t\t\t\tbus = &regmap_fsi16;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tswitch (regmap_get_val_endian(&fsi_dev->dev, NULL, config)) {\n\t\t\tcase REGMAP_ENDIAN_LITTLE:\n#ifdef __LITTLE_ENDIAN\n\t\t\tcase REGMAP_ENDIAN_NATIVE:\n#endif\n\t\t\t\tbus = &regmap_fsi32le;\n\t\t\t\tbreak;\n\t\t\tcase REGMAP_ENDIAN_DEFAULT:\n\t\t\tcase REGMAP_ENDIAN_BIG:\n#ifdef __BIG_ENDIAN\n\t\t\tcase REGMAP_ENDIAN_NATIVE:\n#endif\n\t\t\t\tbus = &regmap_fsi32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bus ?: ERR_PTR(-EOPNOTSUPP);\n}\n\nstruct regmap *__regmap_init_fsi(struct fsi_device *fsi_dev, const struct regmap_config *config,\n\t\t\t\t struct lock_class_key *lock_key, const char *lock_name)\n{\n\tconst struct regmap_bus *bus = regmap_get_fsi_bus(fsi_dev, config);\n\n\tif (IS_ERR(bus))\n\t\treturn ERR_CAST(bus);\n\n\treturn __regmap_init(&fsi_dev->dev, bus, fsi_dev->slave, config, lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__regmap_init_fsi);\n\nstruct regmap *__devm_regmap_init_fsi(struct fsi_device *fsi_dev,\n\t\t\t\t      const struct regmap_config *config,\n\t\t\t\t      struct lock_class_key *lock_key, const char *lock_name)\n{\n\tconst struct regmap_bus *bus = regmap_get_fsi_bus(fsi_dev, config);\n\n\tif (IS_ERR(bus))\n\t\treturn ERR_CAST(bus);\n\n\treturn __devm_regmap_init(&fsi_dev->dev, bus, fsi_dev->slave, config, lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__devm_regmap_init_fsi);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}