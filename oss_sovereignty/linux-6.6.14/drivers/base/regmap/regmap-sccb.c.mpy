{
  "module_name": "regmap-sccb.c",
  "hash_id": "33ff4c4aa2906930da710105bd7563a7cd7d1cfe47f6f35d9018a149e6c4d571",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regmap-sccb.c",
  "human_readable_source": "\n\n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n#include \"internal.h\"\n\n \nstatic bool sccb_is_available(struct i2c_adapter *adap)\n{\n\tu32 needed_funcs = I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA;\n\n\t \n\n\treturn (i2c_get_functionality(adap) & needed_funcs) == needed_funcs;\n}\n\n \nstatic int regmap_sccb_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tint ret;\n\tunion i2c_smbus_data data;\n\n\ti2c_lock_bus(i2c->adapter, I2C_LOCK_SEGMENT);\n\n\tret = __i2c_smbus_xfer(i2c->adapter, i2c->addr, i2c->flags,\n\t\t\t       I2C_SMBUS_WRITE, reg, I2C_SMBUS_BYTE, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = __i2c_smbus_xfer(i2c->adapter, i2c->addr, i2c->flags,\n\t\t\t       I2C_SMBUS_READ, 0, I2C_SMBUS_BYTE, &data);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*val = data.byte;\nout:\n\ti2c_unlock_bus(i2c->adapter, I2C_LOCK_SEGMENT);\n\n\treturn ret;\n}\n\n \nstatic int regmap_sccb_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\n\treturn i2c_smbus_write_byte_data(i2c, reg, val);\n}\n\nstatic const struct regmap_bus regmap_sccb_bus = {\n\t.reg_write = regmap_sccb_write,\n\t.reg_read = regmap_sccb_read,\n};\n\nstatic const struct regmap_bus *regmap_get_sccb_bus(struct i2c_client *i2c,\n\t\t\t\t\tconst struct regmap_config *config)\n{\n\tif (config->val_bits == 8 && config->reg_bits == 8 &&\n\t\t\tsccb_is_available(i2c->adapter))\n\t\treturn &regmap_sccb_bus;\n\n\treturn ERR_PTR(-ENOTSUPP);\n}\n\nstruct regmap *__regmap_init_sccb(struct i2c_client *i2c,\n\t\t\t\t  const struct regmap_config *config,\n\t\t\t\t  struct lock_class_key *lock_key,\n\t\t\t\t  const char *lock_name)\n{\n\tconst struct regmap_bus *bus = regmap_get_sccb_bus(i2c, config);\n\n\tif (IS_ERR(bus))\n\t\treturn ERR_CAST(bus);\n\n\treturn __regmap_init(&i2c->dev, bus, &i2c->dev, config,\n\t\t\t     lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__regmap_init_sccb);\n\nstruct regmap *__devm_regmap_init_sccb(struct i2c_client *i2c,\n\t\t\t\t       const struct regmap_config *config,\n\t\t\t\t       struct lock_class_key *lock_key,\n\t\t\t\t       const char *lock_name)\n{\n\tconst struct regmap_bus *bus = regmap_get_sccb_bus(i2c, config);\n\n\tif (IS_ERR(bus))\n\t\treturn ERR_CAST(bus);\n\n\treturn __devm_regmap_init(&i2c->dev, bus, &i2c->dev, config,\n\t\t\t\t  lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__devm_regmap_init_sccb);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}