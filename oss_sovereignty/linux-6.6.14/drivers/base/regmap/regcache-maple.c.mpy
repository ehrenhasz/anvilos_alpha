{
  "module_name": "regcache-maple.c",
  "hash_id": "39bb6d6a96eb186a7565727f8c22feb3b4e738b73241c1dbbeac54bdb960ff75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regcache-maple.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/maple_tree.h>\n#include <linux/slab.h>\n\n#include \"internal.h\"\n\nstatic int regcache_maple_read(struct regmap *map,\n\t\t\t       unsigned int reg, unsigned int *value)\n{\n\tstruct maple_tree *mt = map->cache;\n\tMA_STATE(mas, mt, reg, reg);\n\tunsigned long *entry;\n\n\trcu_read_lock();\n\n\tentry = mas_walk(&mas);\n\tif (!entry) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t*value = entry[reg - mas.index];\n\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int regcache_maple_write(struct regmap *map, unsigned int reg,\n\t\t\t\tunsigned int val)\n{\n\tstruct maple_tree *mt = map->cache;\n\tMA_STATE(mas, mt, reg, reg);\n\tunsigned long *entry, *upper, *lower;\n\tunsigned long index, last;\n\tsize_t lower_sz, upper_sz;\n\tint ret;\n\n\trcu_read_lock();\n\n\tentry = mas_walk(&mas);\n\tif (entry) {\n\t\tentry[reg - mas.index] = val;\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\t \n\tmas_set_range(&mas, reg - 1, reg + 1);\n\tindex = reg;\n\tlast = reg;\n\n\tlower = mas_find(&mas, reg - 1);\n\tif (lower) {\n\t\tindex = mas.index;\n\t\tlower_sz = (mas.last - mas.index + 1) * sizeof(unsigned long);\n\t}\n\n\tupper = mas_find(&mas, reg + 1);\n\tif (upper) {\n\t\tlast = mas.last;\n\t\tupper_sz = (mas.last - mas.index + 1) * sizeof(unsigned long);\n\t}\n\n\trcu_read_unlock();\n\n\tentry = kmalloc((last - index + 1) * sizeof(unsigned long),\n\t\t\tmap->alloc_flags);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tif (lower)\n\t\tmemcpy(entry, lower, lower_sz);\n\tentry[reg - index] = val;\n\tif (upper)\n\t\tmemcpy(&entry[reg - index + 1], upper, upper_sz);\n\n\t \n\tmas_lock(&mas);\n\n\tmas_set_range(&mas, index, last);\n\tret = mas_store_gfp(&mas, entry, map->alloc_flags);\n\n\tmas_unlock(&mas);\n\n\tif (ret == 0) {\n\t\tkfree(lower);\n\t\tkfree(upper);\n\t}\n\t\n\treturn ret;\n}\n\nstatic int regcache_maple_drop(struct regmap *map, unsigned int min,\n\t\t\t       unsigned int max)\n{\n\tstruct maple_tree *mt = map->cache;\n\tMA_STATE(mas, mt, min, max);\n\tunsigned long *entry, *lower, *upper;\n\tunsigned long lower_index, lower_last;\n\tunsigned long upper_index, upper_last;\n\tint ret;\n\n\tlower = NULL;\n\tupper = NULL;\n\n\tmas_lock(&mas);\n\n\tmas_for_each(&mas, entry, max) {\n\t\t \n\t\tmas_unlock(&mas);\n\n\t\t \n\t\tif (mas.index < min) {\n\t\t\tlower_index = mas.index;\n\t\t\tlower_last = min -1;\n\n\t\t\tlower = kmemdup(entry, ((min - mas.index) *\n\t\t\t\t\t\tsizeof(unsigned long)),\n\t\t\t\t\tmap->alloc_flags);\n\t\t\tif (!lower) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_unlocked;\n\t\t\t}\n\t\t}\n\n\t\tif (mas.last > max) {\n\t\t\tupper_index = max + 1;\n\t\t\tupper_last = mas.last;\n\n\t\t\tupper = kmemdup(&entry[max + 1],\n\t\t\t\t\t((mas.last - max) *\n\t\t\t\t\t sizeof(unsigned long)),\n\t\t\t\t\tmap->alloc_flags);\n\t\t\tif (!upper) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_unlocked;\n\t\t\t}\n\t\t}\n\n\t\tkfree(entry);\n\t\tmas_lock(&mas);\n\t\tmas_erase(&mas);\n\n\t\t \n\t\tif (lower) {\n\t\t\tmas_set_range(&mas, lower_index, lower_last);\n\t\t\tret = mas_store_gfp(&mas, lower, map->alloc_flags);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t\tlower = NULL;\n\t\t}\n\n\t\tif (upper) {\n\t\t\tmas_set_range(&mas, upper_index, upper_last);\n\t\t\tret = mas_store_gfp(&mas, upper, map->alloc_flags);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t\tupper = NULL;\n\t\t}\n\t}\n\nout:\n\tmas_unlock(&mas);\nout_unlocked:\n\tkfree(lower);\n\tkfree(upper);\n\n\treturn ret;\n}\n\nstatic int regcache_maple_sync_block(struct regmap *map, unsigned long *entry,\n\t\t\t\t     struct ma_state *mas,\n\t\t\t\t     unsigned int min, unsigned int max)\n{\n\tvoid *buf;\n\tunsigned long r;\n\tsize_t val_bytes = map->format.val_bytes;\n\tint ret = 0;\n\n\tmas_pause(mas);\n\trcu_read_unlock();\n\n\t \n\tif (max - min > 1 && regmap_can_raw_write(map)) {\n\t\tbuf = kmalloc(val_bytes * (max - min), map->alloc_flags);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tfor (r = min; r < max; r++) {\n\t\t\tregcache_set_val(map, buf, r - min,\n\t\t\t\t\t entry[r - mas->index]);\n\t\t}\n\n\t\tret = _regmap_raw_write(map, min, buf, (max - min) * val_bytes,\n\t\t\t\t\tfalse);\n\n\t\tkfree(buf);\n\t} else {\n\t\tfor (r = min; r < max; r++) {\n\t\t\tret = _regmap_write(map, r,\n\t\t\t\t\t    entry[r - mas->index]);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\trcu_read_lock();\n\n\treturn ret;\n}\n\nstatic int regcache_maple_sync(struct regmap *map, unsigned int min,\n\t\t\t       unsigned int max)\n{\n\tstruct maple_tree *mt = map->cache;\n\tunsigned long *entry;\n\tMA_STATE(mas, mt, min, max);\n\tunsigned long lmin = min;\n\tunsigned long lmax = max;\n\tunsigned int r, v, sync_start;\n\tint ret;\n\tbool sync_needed = false;\n\n\tmap->cache_bypass = true;\n\n\trcu_read_lock();\n\n\tmas_for_each(&mas, entry, max) {\n\t\tfor (r = max(mas.index, lmin); r <= min(mas.last, lmax); r++) {\n\t\t\tv = entry[r - mas.index];\n\n\t\t\tif (regcache_reg_needs_sync(map, r, v)) {\n\t\t\t\tif (!sync_needed) {\n\t\t\t\t\tsync_start = r;\n\t\t\t\t\tsync_needed = true;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!sync_needed)\n\t\t\t\tcontinue;\n\n\t\t\tret = regcache_maple_sync_block(map, entry, &mas,\n\t\t\t\t\t\t\tsync_start, r);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t\tsync_needed = false;\n\t\t}\n\n\t\tif (sync_needed) {\n\t\t\tret = regcache_maple_sync_block(map, entry, &mas,\n\t\t\t\t\t\t\tsync_start, r);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t\tsync_needed = false;\n\t\t}\n\t}\n\nout:\n\trcu_read_unlock();\n\n\tmap->cache_bypass = false;\n\n\treturn ret;\n}\n\nstatic int regcache_maple_exit(struct regmap *map)\n{\n\tstruct maple_tree *mt = map->cache;\n\tMA_STATE(mas, mt, 0, UINT_MAX);\n\tunsigned int *entry;;\n\n\t \n\tif (!mt)\n\t\treturn 0;\n\n\tmas_lock(&mas);\n\tmas_for_each(&mas, entry, UINT_MAX)\n\t\tkfree(entry);\n\t__mt_destroy(mt);\n\tmas_unlock(&mas);\n\n\tkfree(mt);\n\tmap->cache = NULL;\n\n\treturn 0;\n}\n\nstatic int regcache_maple_insert_block(struct regmap *map, int first,\n\t\t\t\t\tint last)\n{\n\tstruct maple_tree *mt = map->cache;\n\tMA_STATE(mas, mt, first, last);\n\tunsigned long *entry;\n\tint i, ret;\n\n\tentry = kcalloc(last - first + 1, sizeof(unsigned long), map->alloc_flags);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < last - first + 1; i++)\n\t\tentry[i] = map->reg_defaults[first + i].def;\n\n\tmas_lock(&mas);\n\n\tmas_set_range(&mas, map->reg_defaults[first].reg,\n\t\t      map->reg_defaults[last].reg);\n\tret = mas_store_gfp(&mas, entry, map->alloc_flags);\n\n\tmas_unlock(&mas);\n\n\tif (ret)\n\t\tkfree(entry);\n\n\treturn ret;\n}\n\nstatic int regcache_maple_init(struct regmap *map)\n{\n\tstruct maple_tree *mt;\n\tint i;\n\tint ret;\n\tint range_start;\n\n\tmt = kmalloc(sizeof(*mt), GFP_KERNEL);\n\tif (!mt)\n\t\treturn -ENOMEM;\n\tmap->cache = mt;\n\n\tmt_init(mt);\n\n\tif (!map->num_reg_defaults)\n\t\treturn 0;\n\n\trange_start = 0;\n\n\t \n\tfor (i = 1; i < map->num_reg_defaults; i++) {\n\t\tif (map->reg_defaults[i].reg !=\n\t\t    map->reg_defaults[i - 1].reg + 1) {\n\t\t\tret = regcache_maple_insert_block(map, range_start,\n\t\t\t\t\t\t\t  i - 1);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto err;\n\n\t\t\trange_start = i;\n\t\t}\n\t}\n\n\t \n\tret = regcache_maple_insert_block(map, range_start,\n\t\t\t\t\t  map->num_reg_defaults - 1);\n\tif (ret != 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tregcache_maple_exit(map);\n\treturn ret;\n}\n\nstruct regcache_ops regcache_maple_ops = {\n\t.type = REGCACHE_MAPLE,\n\t.name = \"maple\",\n\t.init = regcache_maple_init,\n\t.exit = regcache_maple_exit,\n\t.read = regcache_maple_read,\n\t.write = regcache_maple_write,\n\t.drop = regcache_maple_drop,\n\t.sync = regcache_maple_sync,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}