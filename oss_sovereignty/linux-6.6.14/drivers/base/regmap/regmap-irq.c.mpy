{
  "module_name": "regmap-irq.c",
  "hash_id": "8a018a4a89f7dc2aabe8fa39b4d01afbe3d6ccb7c247ecf32897410e227bae8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regmap-irq.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"internal.h\"\n\nstruct regmap_irq_chip_data {\n\tstruct mutex lock;\n\tstruct irq_chip irq_chip;\n\n\tstruct regmap *map;\n\tconst struct regmap_irq_chip *chip;\n\n\tint irq_base;\n\tstruct irq_domain *domain;\n\n\tint irq;\n\tint wake_count;\n\n\tvoid *status_reg_buf;\n\tunsigned int *main_status_buf;\n\tunsigned int *status_buf;\n\tunsigned int *mask_buf;\n\tunsigned int *mask_buf_def;\n\tunsigned int *wake_buf;\n\tunsigned int *type_buf;\n\tunsigned int *type_buf_def;\n\tunsigned int **config_buf;\n\n\tunsigned int irq_reg_stride;\n\n\tunsigned int (*get_irq_reg)(struct regmap_irq_chip_data *data,\n\t\t\t\t    unsigned int base, int index);\n\n\tunsigned int clear_status:1;\n};\n\nstatic inline const\nstruct regmap_irq *irq_to_regmap_irq(struct regmap_irq_chip_data *data,\n\t\t\t\t     int irq)\n{\n\treturn &data->chip->irqs[irq];\n}\n\nstatic bool regmap_irq_can_bulk_read_status(struct regmap_irq_chip_data *data)\n{\n\tstruct regmap *map = data->map;\n\n\t \n\treturn data->irq_reg_stride == 1 && map->reg_stride == 1 &&\n\t       data->get_irq_reg == regmap_irq_get_irq_reg_linear &&\n\t       !map->use_single_read;\n}\n\nstatic void regmap_irq_lock(struct irq_data *data)\n{\n\tstruct regmap_irq_chip_data *d = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&d->lock);\n}\n\nstatic void regmap_irq_sync_unlock(struct irq_data *data)\n{\n\tstruct regmap_irq_chip_data *d = irq_data_get_irq_chip_data(data);\n\tstruct regmap *map = d->map;\n\tint i, j, ret;\n\tu32 reg;\n\tu32 val;\n\n\tif (d->chip->runtime_pm) {\n\t\tret = pm_runtime_get_sync(map->dev);\n\t\tif (ret < 0)\n\t\t\tdev_err(map->dev, \"IRQ sync failed to resume: %d\\n\",\n\t\t\t\tret);\n\t}\n\n\tif (d->clear_status) {\n\t\tfor (i = 0; i < d->chip->num_regs; i++) {\n\t\t\treg = d->get_irq_reg(d, d->chip->status_base, i);\n\n\t\t\tret = regmap_read(map, reg, &val);\n\t\t\tif (ret)\n\t\t\t\tdev_err(d->map->dev,\n\t\t\t\t\t\"Failed to clear the interrupt status bits\\n\");\n\t\t}\n\n\t\td->clear_status = false;\n\t}\n\n\t \n\tfor (i = 0; i < d->chip->num_regs; i++) {\n\t\tif (d->chip->handle_mask_sync)\n\t\t\td->chip->handle_mask_sync(i, d->mask_buf_def[i],\n\t\t\t\t\t\t  d->mask_buf[i],\n\t\t\t\t\t\t  d->chip->irq_drv_data);\n\n\t\tif (d->chip->mask_base && !d->chip->handle_mask_sync) {\n\t\t\treg = d->get_irq_reg(d, d->chip->mask_base, i);\n\t\t\tret = regmap_update_bits(d->map, reg,\n\t\t\t\t\t\t d->mask_buf_def[i],\n\t\t\t\t\t\t d->mask_buf[i]);\n\t\t\tif (ret)\n\t\t\t\tdev_err(d->map->dev, \"Failed to sync masks in %x\\n\", reg);\n\t\t}\n\n\t\tif (d->chip->unmask_base && !d->chip->handle_mask_sync) {\n\t\t\treg = d->get_irq_reg(d, d->chip->unmask_base, i);\n\t\t\tret = regmap_update_bits(d->map, reg,\n\t\t\t\t\td->mask_buf_def[i], ~d->mask_buf[i]);\n\t\t\tif (ret)\n\t\t\t\tdev_err(d->map->dev, \"Failed to sync masks in %x\\n\",\n\t\t\t\t\treg);\n\t\t}\n\n\t\treg = d->get_irq_reg(d, d->chip->wake_base, i);\n\t\tif (d->wake_buf) {\n\t\t\tif (d->chip->wake_invert)\n\t\t\t\tret = regmap_update_bits(d->map, reg,\n\t\t\t\t\t\t\t d->mask_buf_def[i],\n\t\t\t\t\t\t\t ~d->wake_buf[i]);\n\t\t\telse\n\t\t\t\tret = regmap_update_bits(d->map, reg,\n\t\t\t\t\t\t\t d->mask_buf_def[i],\n\t\t\t\t\t\t\t d->wake_buf[i]);\n\t\t\tif (ret != 0)\n\t\t\t\tdev_err(d->map->dev,\n\t\t\t\t\t\"Failed to sync wakes in %x: %d\\n\",\n\t\t\t\t\treg, ret);\n\t\t}\n\n\t\tif (!d->chip->init_ack_masked)\n\t\t\tcontinue;\n\t\t \n\t\tif (d->mask_buf[i] && (d->chip->ack_base || d->chip->use_ack)) {\n\t\t\treg = d->get_irq_reg(d, d->chip->ack_base, i);\n\n\t\t\t \n\t\t\tif (d->chip->ack_invert)\n\t\t\t\tret = regmap_write(map, reg, ~d->mask_buf[i]);\n\t\t\telse\n\t\t\t\tret = regmap_write(map, reg, d->mask_buf[i]);\n\t\t\tif (d->chip->clear_ack) {\n\t\t\t\tif (d->chip->ack_invert && !ret)\n\t\t\t\t\tret = regmap_write(map, reg, UINT_MAX);\n\t\t\t\telse if (!ret)\n\t\t\t\t\tret = regmap_write(map, reg, 0);\n\t\t\t}\n\t\t\tif (ret != 0)\n\t\t\t\tdev_err(d->map->dev, \"Failed to ack 0x%x: %d\\n\",\n\t\t\t\t\treg, ret);\n\t\t}\n\t}\n\n\tfor (i = 0; i < d->chip->num_config_bases; i++) {\n\t\tfor (j = 0; j < d->chip->num_config_regs; j++) {\n\t\t\treg = d->get_irq_reg(d, d->chip->config_base[i], j);\n\t\t\tret = regmap_write(map, reg, d->config_buf[i][j]);\n\t\t\tif (ret)\n\t\t\t\tdev_err(d->map->dev,\n\t\t\t\t\t\"Failed to write config %x: %d\\n\",\n\t\t\t\t\treg, ret);\n\t\t}\n\t}\n\n\tif (d->chip->runtime_pm)\n\t\tpm_runtime_put(map->dev);\n\n\t \n\tif (d->wake_count < 0)\n\t\tfor (i = d->wake_count; i < 0; i++)\n\t\t\tirq_set_irq_wake(d->irq, 0);\n\telse if (d->wake_count > 0)\n\t\tfor (i = 0; i < d->wake_count; i++)\n\t\t\tirq_set_irq_wake(d->irq, 1);\n\n\td->wake_count = 0;\n\n\tmutex_unlock(&d->lock);\n}\n\nstatic void regmap_irq_enable(struct irq_data *data)\n{\n\tstruct regmap_irq_chip_data *d = irq_data_get_irq_chip_data(data);\n\tstruct regmap *map = d->map;\n\tconst struct regmap_irq *irq_data = irq_to_regmap_irq(d, data->hwirq);\n\tunsigned int reg = irq_data->reg_offset / map->reg_stride;\n\tunsigned int mask;\n\n\t \n\tif (d->chip->type_in_mask && irq_data->type.types_supported)\n\t\tmask = d->type_buf[reg] & irq_data->mask;\n\telse\n\t\tmask = irq_data->mask;\n\n\tif (d->chip->clear_on_unmask)\n\t\td->clear_status = true;\n\n\td->mask_buf[reg] &= ~mask;\n}\n\nstatic void regmap_irq_disable(struct irq_data *data)\n{\n\tstruct regmap_irq_chip_data *d = irq_data_get_irq_chip_data(data);\n\tstruct regmap *map = d->map;\n\tconst struct regmap_irq *irq_data = irq_to_regmap_irq(d, data->hwirq);\n\n\td->mask_buf[irq_data->reg_offset / map->reg_stride] |= irq_data->mask;\n}\n\nstatic int regmap_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct regmap_irq_chip_data *d = irq_data_get_irq_chip_data(data);\n\tstruct regmap *map = d->map;\n\tconst struct regmap_irq *irq_data = irq_to_regmap_irq(d, data->hwirq);\n\tint reg, ret;\n\tconst struct regmap_irq_type *t = &irq_data->type;\n\n\tif ((t->types_supported & type) != type)\n\t\treturn 0;\n\n\treg = t->type_reg_offset / map->reg_stride;\n\n\tif (d->chip->type_in_mask) {\n\t\tret = regmap_irq_set_type_config_simple(&d->type_buf, type,\n\t\t\t\t\t\t\tirq_data, reg, d->chip->irq_drv_data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (d->chip->set_type_config) {\n\t\tret = d->chip->set_type_config(d->config_buf, type, irq_data,\n\t\t\t\t\t       reg, d->chip->irq_drv_data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int regmap_irq_set_wake(struct irq_data *data, unsigned int on)\n{\n\tstruct regmap_irq_chip_data *d = irq_data_get_irq_chip_data(data);\n\tstruct regmap *map = d->map;\n\tconst struct regmap_irq *irq_data = irq_to_regmap_irq(d, data->hwirq);\n\n\tif (on) {\n\t\tif (d->wake_buf)\n\t\t\td->wake_buf[irq_data->reg_offset / map->reg_stride]\n\t\t\t\t&= ~irq_data->mask;\n\t\td->wake_count++;\n\t} else {\n\t\tif (d->wake_buf)\n\t\t\td->wake_buf[irq_data->reg_offset / map->reg_stride]\n\t\t\t\t|= irq_data->mask;\n\t\td->wake_count--;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct irq_chip regmap_irq_chip = {\n\t.irq_bus_lock\t\t= regmap_irq_lock,\n\t.irq_bus_sync_unlock\t= regmap_irq_sync_unlock,\n\t.irq_disable\t\t= regmap_irq_disable,\n\t.irq_enable\t\t= regmap_irq_enable,\n\t.irq_set_type\t\t= regmap_irq_set_type,\n\t.irq_set_wake\t\t= regmap_irq_set_wake,\n};\n\nstatic inline int read_sub_irq_data(struct regmap_irq_chip_data *data,\n\t\t\t\t\t   unsigned int b)\n{\n\tconst struct regmap_irq_chip *chip = data->chip;\n\tstruct regmap *map = data->map;\n\tstruct regmap_irq_sub_irq_map *subreg;\n\tunsigned int reg;\n\tint i, ret = 0;\n\n\tif (!chip->sub_reg_offsets) {\n\t\treg = data->get_irq_reg(data, chip->status_base, b);\n\t\tret = regmap_read(map, reg, &data->status_buf[b]);\n\t} else {\n\t\t \n\t\tsubreg = &chip->sub_reg_offsets[b];\n\t\tfor (i = 0; i < subreg->num_regs; i++) {\n\t\t\tunsigned int offset = subreg->offset[i];\n\t\t\tunsigned int index = offset / map->reg_stride;\n\n\t\t\tret = regmap_read(map, chip->status_base + offset,\n\t\t\t\t\t  &data->status_buf[index]);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic irqreturn_t regmap_irq_thread(int irq, void *d)\n{\n\tstruct regmap_irq_chip_data *data = d;\n\tconst struct regmap_irq_chip *chip = data->chip;\n\tstruct regmap *map = data->map;\n\tint ret, i;\n\tbool handled = false;\n\tu32 reg;\n\n\tif (chip->handle_pre_irq)\n\t\tchip->handle_pre_irq(chip->irq_drv_data);\n\n\tif (chip->runtime_pm) {\n\t\tret = pm_runtime_get_sync(map->dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(map->dev, \"IRQ thread failed to resume: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\n\tif (chip->no_status) {\n\t\t \n\t\tmemset32(data->status_buf, GENMASK(31, 0), chip->num_regs);\n\t} else if (chip->num_main_regs) {\n\t\tunsigned int max_main_bits;\n\t\tunsigned long size;\n\n\t\tsize = chip->num_regs * sizeof(unsigned int);\n\n\t\tmax_main_bits = (chip->num_main_status_bits) ?\n\t\t\t\t chip->num_main_status_bits : chip->num_regs;\n\t\t \n\t\tmemset(data->status_buf, 0, size);\n\n\t\t \n\t\tfor (i = 0; i < chip->num_main_regs; i++) {\n\t\t\treg = data->get_irq_reg(data, chip->main_status, i);\n\t\t\tret = regmap_read(map, reg, &data->main_status_buf[i]);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(map->dev,\n\t\t\t\t\t\"Failed to read IRQ status %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < chip->num_main_regs; i++) {\n\t\t\tunsigned int b;\n\t\t\tconst unsigned long mreg = data->main_status_buf[i];\n\n\t\t\tfor_each_set_bit(b, &mreg, map->format.val_bytes * 8) {\n\t\t\t\tif (i * map->format.val_bytes * 8 + b >\n\t\t\t\t    max_main_bits)\n\t\t\t\t\tbreak;\n\t\t\t\tret = read_sub_irq_data(data, b);\n\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tdev_err(map->dev,\n\t\t\t\t\t\t\"Failed to read IRQ status %d\\n\",\n\t\t\t\t\t\tret);\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t} else if (regmap_irq_can_bulk_read_status(data)) {\n\n\t\tu8 *buf8 = data->status_reg_buf;\n\t\tu16 *buf16 = data->status_reg_buf;\n\t\tu32 *buf32 = data->status_reg_buf;\n\n\t\tBUG_ON(!data->status_reg_buf);\n\n\t\tret = regmap_bulk_read(map, chip->status_base,\n\t\t\t\t       data->status_reg_buf,\n\t\t\t\t       chip->num_regs);\n\t\tif (ret != 0) {\n\t\t\tdev_err(map->dev, \"Failed to read IRQ status: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tfor (i = 0; i < data->chip->num_regs; i++) {\n\t\t\tswitch (map->format.val_bytes) {\n\t\t\tcase 1:\n\t\t\t\tdata->status_buf[i] = buf8[i];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdata->status_buf[i] = buf16[i];\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdata->status_buf[i] = buf32[i];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tfor (i = 0; i < data->chip->num_regs; i++) {\n\t\t\tunsigned int reg = data->get_irq_reg(data,\n\t\t\t\t\tdata->chip->status_base, i);\n\t\t\tret = regmap_read(map, reg, &data->status_buf[i]);\n\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(map->dev,\n\t\t\t\t\t\"Failed to read IRQ status: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (chip->status_invert)\n\t\tfor (i = 0; i < data->chip->num_regs; i++)\n\t\t\tdata->status_buf[i] = ~data->status_buf[i];\n\n\t \n\tfor (i = 0; i < data->chip->num_regs; i++) {\n\t\tdata->status_buf[i] &= ~data->mask_buf[i];\n\n\t\tif (data->status_buf[i] && (chip->ack_base || chip->use_ack)) {\n\t\t\treg = data->get_irq_reg(data, data->chip->ack_base, i);\n\n\t\t\tif (chip->ack_invert)\n\t\t\t\tret = regmap_write(map, reg,\n\t\t\t\t\t\t~data->status_buf[i]);\n\t\t\telse\n\t\t\t\tret = regmap_write(map, reg,\n\t\t\t\t\t\tdata->status_buf[i]);\n\t\t\tif (chip->clear_ack) {\n\t\t\t\tif (chip->ack_invert && !ret)\n\t\t\t\t\tret = regmap_write(map, reg, UINT_MAX);\n\t\t\t\telse if (!ret)\n\t\t\t\t\tret = regmap_write(map, reg, 0);\n\t\t\t}\n\t\t\tif (ret != 0)\n\t\t\t\tdev_err(map->dev, \"Failed to ack 0x%x: %d\\n\",\n\t\t\t\t\treg, ret);\n\t\t}\n\t}\n\n\tfor (i = 0; i < chip->num_irqs; i++) {\n\t\tif (data->status_buf[chip->irqs[i].reg_offset /\n\t\t\t\t     map->reg_stride] & chip->irqs[i].mask) {\n\t\t\thandle_nested_irq(irq_find_mapping(data->domain, i));\n\t\t\thandled = true;\n\t\t}\n\t}\n\nexit:\n\tif (chip->handle_post_irq)\n\t\tchip->handle_post_irq(chip->irq_drv_data);\n\n\tif (chip->runtime_pm)\n\t\tpm_runtime_put(map->dev);\n\n\tif (handled)\n\t\treturn IRQ_HANDLED;\n\telse\n\t\treturn IRQ_NONE;\n}\n\nstatic int regmap_irq_map(struct irq_domain *h, unsigned int virq,\n\t\t\t  irq_hw_number_t hw)\n{\n\tstruct regmap_irq_chip_data *data = h->host_data;\n\n\tirq_set_chip_data(virq, data);\n\tirq_set_chip(virq, &data->irq_chip);\n\tirq_set_nested_thread(virq, 1);\n\tirq_set_parent(virq, data->irq);\n\tirq_set_noprobe(virq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops regmap_domain_ops = {\n\t.map\t= regmap_irq_map,\n\t.xlate\t= irq_domain_xlate_onetwocell,\n};\n\n \nunsigned int regmap_irq_get_irq_reg_linear(struct regmap_irq_chip_data *data,\n\t\t\t\t\t   unsigned int base, int index)\n{\n\tstruct regmap *map = data->map;\n\n\treturn base + index * map->reg_stride * data->irq_reg_stride;\n}\nEXPORT_SYMBOL_GPL(regmap_irq_get_irq_reg_linear);\n\n \nint regmap_irq_set_type_config_simple(unsigned int **buf, unsigned int type,\n\t\t\t\t      const struct regmap_irq *irq_data,\n\t\t\t\t      int idx, void *irq_drv_data)\n{\n\tconst struct regmap_irq_type *t = &irq_data->type;\n\n\tif (t->type_reg_mask)\n\t\tbuf[0][idx] &= ~t->type_reg_mask;\n\telse\n\t\tbuf[0][idx] &= ~(t->type_falling_val |\n\t\t\t\t t->type_rising_val |\n\t\t\t\t t->type_level_low_val |\n\t\t\t\t t->type_level_high_val);\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tbuf[0][idx] |= t->type_falling_val;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tbuf[0][idx] |= t->type_rising_val;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tbuf[0][idx] |= (t->type_falling_val |\n\t\t\t\tt->type_rising_val);\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tbuf[0][idx] |= t->type_level_high_val;\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tbuf[0][idx] |= t->type_level_low_val;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regmap_irq_set_type_config_simple);\n\n \nint regmap_add_irq_chip_fwnode(struct fwnode_handle *fwnode,\n\t\t\t       struct regmap *map, int irq,\n\t\t\t       int irq_flags, int irq_base,\n\t\t\t       const struct regmap_irq_chip *chip,\n\t\t\t       struct regmap_irq_chip_data **data)\n{\n\tstruct regmap_irq_chip_data *d;\n\tint i;\n\tint ret = -ENOMEM;\n\tu32 reg;\n\n\tif (chip->num_regs <= 0)\n\t\treturn -EINVAL;\n\n\tif (chip->clear_on_unmask && (chip->ack_base || chip->use_ack))\n\t\treturn -EINVAL;\n\n\tif (chip->mask_base && chip->unmask_base && !chip->mask_unmask_non_inverted)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < chip->num_irqs; i++) {\n\t\tif (chip->irqs[i].reg_offset % map->reg_stride)\n\t\t\treturn -EINVAL;\n\t\tif (chip->irqs[i].reg_offset / map->reg_stride >=\n\t\t    chip->num_regs)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (irq_base) {\n\t\tirq_base = irq_alloc_descs(irq_base, 0, chip->num_irqs, 0);\n\t\tif (irq_base < 0) {\n\t\t\tdev_warn(map->dev, \"Failed to allocate IRQs: %d\\n\",\n\t\t\t\t irq_base);\n\t\t\treturn irq_base;\n\t\t}\n\t}\n\n\td = kzalloc(sizeof(*d), GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\tif (chip->num_main_regs) {\n\t\td->main_status_buf = kcalloc(chip->num_main_regs,\n\t\t\t\t\t     sizeof(*d->main_status_buf),\n\t\t\t\t\t     GFP_KERNEL);\n\n\t\tif (!d->main_status_buf)\n\t\t\tgoto err_alloc;\n\t}\n\n\td->status_buf = kcalloc(chip->num_regs, sizeof(*d->status_buf),\n\t\t\t\tGFP_KERNEL);\n\tif (!d->status_buf)\n\t\tgoto err_alloc;\n\n\td->mask_buf = kcalloc(chip->num_regs, sizeof(*d->mask_buf),\n\t\t\t      GFP_KERNEL);\n\tif (!d->mask_buf)\n\t\tgoto err_alloc;\n\n\td->mask_buf_def = kcalloc(chip->num_regs, sizeof(*d->mask_buf_def),\n\t\t\t\t  GFP_KERNEL);\n\tif (!d->mask_buf_def)\n\t\tgoto err_alloc;\n\n\tif (chip->wake_base) {\n\t\td->wake_buf = kcalloc(chip->num_regs, sizeof(*d->wake_buf),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!d->wake_buf)\n\t\t\tgoto err_alloc;\n\t}\n\n\tif (chip->type_in_mask) {\n\t\td->type_buf_def = kcalloc(chip->num_regs,\n\t\t\t\t\t  sizeof(*d->type_buf_def), GFP_KERNEL);\n\t\tif (!d->type_buf_def)\n\t\t\tgoto err_alloc;\n\n\t\td->type_buf = kcalloc(chip->num_regs, sizeof(*d->type_buf), GFP_KERNEL);\n\t\tif (!d->type_buf)\n\t\t\tgoto err_alloc;\n\t}\n\n\tif (chip->num_config_bases && chip->num_config_regs) {\n\t\t \n\t\td->config_buf = kcalloc(chip->num_config_bases,\n\t\t\t\t\tsizeof(*d->config_buf), GFP_KERNEL);\n\t\tif (!d->config_buf)\n\t\t\tgoto err_alloc;\n\n\t\tfor (i = 0; i < chip->num_config_bases; i++) {\n\t\t\td->config_buf[i] = kcalloc(chip->num_config_regs,\n\t\t\t\t\t\t   sizeof(**d->config_buf),\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!d->config_buf[i])\n\t\t\t\tgoto err_alloc;\n\t\t}\n\t}\n\n\td->irq_chip = regmap_irq_chip;\n\td->irq_chip.name = chip->name;\n\td->irq = irq;\n\td->map = map;\n\td->chip = chip;\n\td->irq_base = irq_base;\n\n\tif (chip->irq_reg_stride)\n\t\td->irq_reg_stride = chip->irq_reg_stride;\n\telse\n\t\td->irq_reg_stride = 1;\n\n\tif (chip->get_irq_reg)\n\t\td->get_irq_reg = chip->get_irq_reg;\n\telse\n\t\td->get_irq_reg = regmap_irq_get_irq_reg_linear;\n\n\tif (regmap_irq_can_bulk_read_status(d)) {\n\t\td->status_reg_buf = kmalloc_array(chip->num_regs,\n\t\t\t\t\t\t  map->format.val_bytes,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!d->status_reg_buf)\n\t\t\tgoto err_alloc;\n\t}\n\n\tmutex_init(&d->lock);\n\n\tfor (i = 0; i < chip->num_irqs; i++)\n\t\td->mask_buf_def[chip->irqs[i].reg_offset / map->reg_stride]\n\t\t\t|= chip->irqs[i].mask;\n\n\t \n\tfor (i = 0; i < chip->num_regs; i++) {\n\t\td->mask_buf[i] = d->mask_buf_def[i];\n\n\t\tif (chip->handle_mask_sync) {\n\t\t\tret = chip->handle_mask_sync(i, d->mask_buf_def[i],\n\t\t\t\t\t\t     d->mask_buf[i],\n\t\t\t\t\t\t     chip->irq_drv_data);\n\t\t\tif (ret)\n\t\t\t\tgoto err_alloc;\n\t\t}\n\n\t\tif (chip->mask_base && !chip->handle_mask_sync) {\n\t\t\treg = d->get_irq_reg(d, chip->mask_base, i);\n\t\t\tret = regmap_update_bits(d->map, reg,\n\t\t\t\t\t\t d->mask_buf_def[i],\n\t\t\t\t\t\t d->mask_buf[i]);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(map->dev, \"Failed to set masks in 0x%x: %d\\n\",\n\t\t\t\t\treg, ret);\n\t\t\t\tgoto err_alloc;\n\t\t\t}\n\t\t}\n\n\t\tif (chip->unmask_base && !chip->handle_mask_sync) {\n\t\t\treg = d->get_irq_reg(d, chip->unmask_base, i);\n\t\t\tret = regmap_update_bits(d->map, reg,\n\t\t\t\t\td->mask_buf_def[i], ~d->mask_buf[i]);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(map->dev, \"Failed to set masks in 0x%x: %d\\n\",\n\t\t\t\t\treg, ret);\n\t\t\t\tgoto err_alloc;\n\t\t\t}\n\t\t}\n\n\t\tif (!chip->init_ack_masked)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (d->chip->no_status) {\n\t\t\t \n\t\t\td->status_buf[i] = GENMASK(31, 0);\n\t\t} else {\n\t\t\treg = d->get_irq_reg(d, d->chip->status_base, i);\n\t\t\tret = regmap_read(map, reg, &d->status_buf[i]);\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(map->dev, \"Failed to read IRQ status: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tgoto err_alloc;\n\t\t\t}\n\t\t}\n\n\t\tif (chip->status_invert)\n\t\t\td->status_buf[i] = ~d->status_buf[i];\n\n\t\tif (d->status_buf[i] && (chip->ack_base || chip->use_ack)) {\n\t\t\treg = d->get_irq_reg(d, d->chip->ack_base, i);\n\t\t\tif (chip->ack_invert)\n\t\t\t\tret = regmap_write(map, reg,\n\t\t\t\t\t~(d->status_buf[i] & d->mask_buf[i]));\n\t\t\telse\n\t\t\t\tret = regmap_write(map, reg,\n\t\t\t\t\td->status_buf[i] & d->mask_buf[i]);\n\t\t\tif (chip->clear_ack) {\n\t\t\t\tif (chip->ack_invert && !ret)\n\t\t\t\t\tret = regmap_write(map, reg, UINT_MAX);\n\t\t\t\telse if (!ret)\n\t\t\t\t\tret = regmap_write(map, reg, 0);\n\t\t\t}\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(map->dev, \"Failed to ack 0x%x: %d\\n\",\n\t\t\t\t\treg, ret);\n\t\t\t\tgoto err_alloc;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (d->wake_buf) {\n\t\tfor (i = 0; i < chip->num_regs; i++) {\n\t\t\td->wake_buf[i] = d->mask_buf_def[i];\n\t\t\treg = d->get_irq_reg(d, d->chip->wake_base, i);\n\n\t\t\tif (chip->wake_invert)\n\t\t\t\tret = regmap_update_bits(d->map, reg,\n\t\t\t\t\t\t\t d->mask_buf_def[i],\n\t\t\t\t\t\t\t 0);\n\t\t\telse\n\t\t\t\tret = regmap_update_bits(d->map, reg,\n\t\t\t\t\t\t\t d->mask_buf_def[i],\n\t\t\t\t\t\t\t d->wake_buf[i]);\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(map->dev, \"Failed to set masks in 0x%x: %d\\n\",\n\t\t\t\t\treg, ret);\n\t\t\t\tgoto err_alloc;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (irq_base)\n\t\td->domain = irq_domain_create_legacy(fwnode, chip->num_irqs,\n\t\t\t\t\t\t     irq_base, 0,\n\t\t\t\t\t\t     &regmap_domain_ops, d);\n\telse\n\t\td->domain = irq_domain_create_linear(fwnode, chip->num_irqs,\n\t\t\t\t\t\t     &regmap_domain_ops, d);\n\tif (!d->domain) {\n\t\tdev_err(map->dev, \"Failed to create IRQ domain\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tret = request_threaded_irq(irq, NULL, regmap_irq_thread,\n\t\t\t\t   irq_flags | IRQF_ONESHOT,\n\t\t\t\t   chip->name, d);\n\tif (ret != 0) {\n\t\tdev_err(map->dev, \"Failed to request IRQ %d for %s: %d\\n\",\n\t\t\tirq, chip->name, ret);\n\t\tgoto err_domain;\n\t}\n\n\t*data = d;\n\n\treturn 0;\n\nerr_domain:\n\t \nerr_alloc:\n\tkfree(d->type_buf);\n\tkfree(d->type_buf_def);\n\tkfree(d->wake_buf);\n\tkfree(d->mask_buf_def);\n\tkfree(d->mask_buf);\n\tkfree(d->status_buf);\n\tkfree(d->status_reg_buf);\n\tif (d->config_buf) {\n\t\tfor (i = 0; i < chip->num_config_bases; i++)\n\t\t\tkfree(d->config_buf[i]);\n\t\tkfree(d->config_buf);\n\t}\n\tkfree(d);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regmap_add_irq_chip_fwnode);\n\n \nint regmap_add_irq_chip(struct regmap *map, int irq, int irq_flags,\n\t\t\tint irq_base, const struct regmap_irq_chip *chip,\n\t\t\tstruct regmap_irq_chip_data **data)\n{\n\treturn regmap_add_irq_chip_fwnode(dev_fwnode(map->dev), map, irq,\n\t\t\t\t\t  irq_flags, irq_base, chip, data);\n}\nEXPORT_SYMBOL_GPL(regmap_add_irq_chip);\n\n \nvoid regmap_del_irq_chip(int irq, struct regmap_irq_chip_data *d)\n{\n\tunsigned int virq;\n\tint i, hwirq;\n\n\tif (!d)\n\t\treturn;\n\n\tfree_irq(irq, d);\n\n\t \n\tfor (hwirq = 0; hwirq < d->chip->num_irqs; hwirq++) {\n\t\t \n\t\tif (!d->chip->irqs[hwirq].mask)\n\t\t\tcontinue;\n\n\t\t \n\t\tvirq = irq_find_mapping(d->domain, hwirq);\n\t\tif (virq)\n\t\t\tirq_dispose_mapping(virq);\n\t}\n\n\tirq_domain_remove(d->domain);\n\tkfree(d->type_buf);\n\tkfree(d->type_buf_def);\n\tkfree(d->wake_buf);\n\tkfree(d->mask_buf_def);\n\tkfree(d->mask_buf);\n\tkfree(d->status_reg_buf);\n\tkfree(d->status_buf);\n\tif (d->config_buf) {\n\t\tfor (i = 0; i < d->chip->num_config_bases; i++)\n\t\t\tkfree(d->config_buf[i]);\n\t\tkfree(d->config_buf);\n\t}\n\tkfree(d);\n}\nEXPORT_SYMBOL_GPL(regmap_del_irq_chip);\n\nstatic void devm_regmap_irq_chip_release(struct device *dev, void *res)\n{\n\tstruct regmap_irq_chip_data *d = *(struct regmap_irq_chip_data **)res;\n\n\tregmap_del_irq_chip(d->irq, d);\n}\n\nstatic int devm_regmap_irq_chip_match(struct device *dev, void *res, void *data)\n\n{\n\tstruct regmap_irq_chip_data **r = res;\n\n\tif (!r || !*r) {\n\t\tWARN_ON(!r || !*r);\n\t\treturn 0;\n\t}\n\treturn *r == data;\n}\n\n \nint devm_regmap_add_irq_chip_fwnode(struct device *dev,\n\t\t\t\t    struct fwnode_handle *fwnode,\n\t\t\t\t    struct regmap *map, int irq,\n\t\t\t\t    int irq_flags, int irq_base,\n\t\t\t\t    const struct regmap_irq_chip *chip,\n\t\t\t\t    struct regmap_irq_chip_data **data)\n{\n\tstruct regmap_irq_chip_data **ptr, *d;\n\tint ret;\n\n\tptr = devres_alloc(devm_regmap_irq_chip_release, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tret = regmap_add_irq_chip_fwnode(fwnode, map, irq, irq_flags, irq_base,\n\t\t\t\t\t chip, &d);\n\tif (ret < 0) {\n\t\tdevres_free(ptr);\n\t\treturn ret;\n\t}\n\n\t*ptr = d;\n\tdevres_add(dev, ptr);\n\t*data = d;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_regmap_add_irq_chip_fwnode);\n\n \nint devm_regmap_add_irq_chip(struct device *dev, struct regmap *map, int irq,\n\t\t\t     int irq_flags, int irq_base,\n\t\t\t     const struct regmap_irq_chip *chip,\n\t\t\t     struct regmap_irq_chip_data **data)\n{\n\treturn devm_regmap_add_irq_chip_fwnode(dev, dev_fwnode(map->dev), map,\n\t\t\t\t\t       irq, irq_flags, irq_base, chip,\n\t\t\t\t\t       data);\n}\nEXPORT_SYMBOL_GPL(devm_regmap_add_irq_chip);\n\n \nvoid devm_regmap_del_irq_chip(struct device *dev, int irq,\n\t\t\t      struct regmap_irq_chip_data *data)\n{\n\tint rc;\n\n\tWARN_ON(irq != data->irq);\n\trc = devres_release(dev, devm_regmap_irq_chip_release,\n\t\t\t    devm_regmap_irq_chip_match, data);\n\n\tif (rc != 0)\n\t\tWARN_ON(rc);\n}\nEXPORT_SYMBOL_GPL(devm_regmap_del_irq_chip);\n\n \nint regmap_irq_chip_get_base(struct regmap_irq_chip_data *data)\n{\n\tWARN_ON(!data->irq_base);\n\treturn data->irq_base;\n}\nEXPORT_SYMBOL_GPL(regmap_irq_chip_get_base);\n\n \nint regmap_irq_get_virq(struct regmap_irq_chip_data *data, int irq)\n{\n\t \n\tif (!data->chip->irqs[irq].mask)\n\t\treturn -EINVAL;\n\n\treturn irq_create_mapping(data->domain, irq);\n}\nEXPORT_SYMBOL_GPL(regmap_irq_get_virq);\n\n \nstruct irq_domain *regmap_irq_get_domain(struct regmap_irq_chip_data *data)\n{\n\tif (data)\n\t\treturn data->domain;\n\telse\n\t\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(regmap_irq_get_domain);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}