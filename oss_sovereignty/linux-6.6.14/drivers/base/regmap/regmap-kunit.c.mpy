{
  "module_name": "regmap-kunit.c",
  "hash_id": "3af0d1ba9dcbcbc815838b142ff59b9961d58fcaa2d7a89a8e27dc527cda347f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regmap-kunit.c",
  "human_readable_source": "\n\n\n\n\n\n#include <kunit/test.h>\n#include \"internal.h\"\n\n#define BLOCK_TEST_SIZE 12\n\nstatic const struct regmap_config test_regmap_config = {\n\t.max_register = BLOCK_TEST_SIZE,\n\t.reg_stride = 1,\n\t.val_bits = sizeof(unsigned int) * 8,\n};\n\nstruct regcache_types {\n\tenum regcache_type type;\n\tconst char *name;\n};\n\nstatic void case_to_desc(const struct regcache_types *t, char *desc)\n{\n\tstrcpy(desc, t->name);\n}\n\nstatic const struct regcache_types regcache_types_list[] = {\n\t{ REGCACHE_NONE, \"none\" },\n\t{ REGCACHE_FLAT, \"flat\" },\n\t{ REGCACHE_RBTREE, \"rbtree\" },\n\t{ REGCACHE_MAPLE, \"maple\" },\n};\n\nKUNIT_ARRAY_PARAM(regcache_types, regcache_types_list, case_to_desc);\n\nstatic const struct regcache_types real_cache_types_list[] = {\n\t{ REGCACHE_FLAT, \"flat\" },\n\t{ REGCACHE_RBTREE, \"rbtree\" },\n\t{ REGCACHE_MAPLE, \"maple\" },\n};\n\nKUNIT_ARRAY_PARAM(real_cache_types, real_cache_types_list, case_to_desc);\n\nstatic const struct regcache_types sparse_cache_types_list[] = {\n\t{ REGCACHE_RBTREE, \"rbtree\" },\n\t{ REGCACHE_MAPLE, \"maple\" },\n};\n\nKUNIT_ARRAY_PARAM(sparse_cache_types, sparse_cache_types_list, case_to_desc);\n\nstatic struct regmap *gen_regmap(struct regmap_config *config,\n\t\t\t\t struct regmap_ram_data **data)\n{\n\tunsigned int *buf;\n\tstruct regmap *ret;\n\tsize_t size = (config->max_register + 1) * sizeof(unsigned int);\n\tint i;\n\tstruct reg_default *defaults;\n\n\tconfig->disable_locking = config->cache_type == REGCACHE_RBTREE ||\n\t\t\t\t\tconfig->cache_type == REGCACHE_MAPLE;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_random_bytes(buf, size);\n\n\t*data = kzalloc(sizeof(**data), GFP_KERNEL);\n\tif (!(*data))\n\t\treturn ERR_PTR(-ENOMEM);\n\t(*data)->vals = buf;\n\n\tif (config->num_reg_defaults) {\n\t\tdefaults = kcalloc(config->num_reg_defaults,\n\t\t\t\t   sizeof(struct reg_default),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!defaults)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tconfig->reg_defaults = defaults;\n\n\t\tfor (i = 0; i < config->num_reg_defaults; i++) {\n\t\t\tdefaults[i].reg = i * config->reg_stride;\n\t\t\tdefaults[i].def = buf[i * config->reg_stride];\n\t\t}\n\t}\n\n\tret = regmap_init_ram(config, *data);\n\tif (IS_ERR(ret)) {\n\t\tkfree(buf);\n\t\tkfree(*data);\n\t}\n\n\treturn ret;\n}\n\nstatic bool reg_5_false(struct device *context, unsigned int reg)\n{\n\treturn reg != 5;\n}\n\nstatic void basic_read_write(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int val, rval;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\tget_random_bytes(&val, sizeof(val));\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, 0, val));\n\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, 0, &rval));\n\tKUNIT_EXPECT_EQ(test, val, rval);\n\n\t \n\tKUNIT_EXPECT_EQ(test, t->type == REGCACHE_NONE, data->read[0]);\n\n\tregmap_exit(map);\n}\n\nstatic void bulk_write(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int val[BLOCK_TEST_SIZE], rval[BLOCK_TEST_SIZE];\n\tint i;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\tget_random_bytes(&val, sizeof(val));\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_bulk_write(map, 0, val,\n\t\t\t\t\t\t   BLOCK_TEST_SIZE));\n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, i, &rval[i]));\n\n\tKUNIT_EXPECT_MEMEQ(test, val, rval, sizeof(val));\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, t->type == REGCACHE_NONE, data->read[i]);\n\n\tregmap_exit(map);\n}\n\nstatic void bulk_read(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int val[BLOCK_TEST_SIZE], rval[BLOCK_TEST_SIZE];\n\tint i;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\tget_random_bytes(&val, sizeof(val));\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, i, val[i]));\n\tKUNIT_EXPECT_EQ(test, 0, regmap_bulk_read(map, 0, rval,\n\t\t\t\t\t\t  BLOCK_TEST_SIZE));\n\tKUNIT_EXPECT_MEMEQ(test, val, rval, sizeof(val));\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, t->type == REGCACHE_NONE, data->read[i]);\n\n\tregmap_exit(map);\n}\n\nstatic void write_readonly(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int val;\n\tint i;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\tconfig.num_reg_defaults = BLOCK_TEST_SIZE;\n\tconfig.writeable_reg = reg_5_false;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\tget_random_bytes(&val, sizeof(val));\n\n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tdata->written[i] = false;\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, i != 5, regmap_write(map, i, val) == 0);\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, i != 5, data->written[i]);\n\n\tregmap_exit(map);\n}\n\nstatic void read_writeonly(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int val;\n\tint i;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\tconfig.readable_reg = reg_5_false;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tdata->read[i] = false;\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++) {\n\t\tif (t->type != REGCACHE_FLAT) {\n\t\t\tKUNIT_EXPECT_EQ(test, i != 5,\n\t\t\t\t\tregmap_read(map, i, &val) == 0);\n\t\t} else {\n\t\t\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, i, &val));\n\t\t}\n\t}\n\n\t \n\tKUNIT_EXPECT_FALSE(test, data->read[5]);\n\n\tregmap_exit(map);\n}\n\nstatic void reg_defaults(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int rval[BLOCK_TEST_SIZE];\n\tint i;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\tconfig.num_reg_defaults = BLOCK_TEST_SIZE;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_bulk_read(map, 0, rval,\n\t\t\t\t\t\t  BLOCK_TEST_SIZE));\n\tKUNIT_EXPECT_MEMEQ(test, data->vals, rval, sizeof(rval));\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, t->type == REGCACHE_NONE, data->read[i]);\n}\n\nstatic void reg_defaults_read_dev(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int rval[BLOCK_TEST_SIZE];\n\tint i;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\tconfig.num_reg_defaults_raw = BLOCK_TEST_SIZE;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++) {\n\t\tKUNIT_EXPECT_EQ(test, t->type != REGCACHE_NONE, data->read[i]);\n\t\tdata->read[i] = false;\n\t}\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_bulk_read(map, 0, rval,\n\t\t\t\t\t\t  BLOCK_TEST_SIZE));\n\tKUNIT_EXPECT_MEMEQ(test, data->vals, rval, sizeof(rval));\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, t->type == REGCACHE_NONE, data->read[i]);\n}\n\nstatic void register_patch(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tstruct reg_sequence patch[2];\n\tunsigned int rval[BLOCK_TEST_SIZE];\n\tint i;\n\n\t \n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\tconfig.num_reg_defaults = BLOCK_TEST_SIZE;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_bulk_read(map, 0, rval,\n\t\t\t\t\t\t  BLOCK_TEST_SIZE));\n\n\t \n\tpatch[0].reg = 2;\n\tpatch[0].def = rval[2] + 1;\n\tpatch[0].delay_us = 0;\n\tpatch[1].reg = 5;\n\tpatch[1].def = rval[5] + 1;\n\tpatch[1].delay_us = 0;\n\tKUNIT_EXPECT_EQ(test, 0, regmap_register_patch(map, patch,\n\t\t\t\t\t\t       ARRAY_SIZE(patch)));\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++) {\n\t\tswitch (i) {\n\t\tcase 2:\n\t\tcase 5:\n\t\t\tKUNIT_EXPECT_TRUE(test, data->written[i]);\n\t\t\tKUNIT_EXPECT_EQ(test, data->vals[i], rval[i] + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tKUNIT_EXPECT_FALSE(test, data->written[i]);\n\t\t\tKUNIT_EXPECT_EQ(test, data->vals[i], rval[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tregmap_exit(map);\n}\n\nstatic void stride(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int rval;\n\tint i;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\tconfig.reg_stride = 2;\n\tconfig.num_reg_defaults = BLOCK_TEST_SIZE / 2;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++) {\n\t\tdata->read[i] = false;\n\t\tdata->written[i] = false;\n\n\t\tif (i % 2) {\n\t\t\tKUNIT_EXPECT_NE(test, 0, regmap_read(map, i, &rval));\n\t\t\tKUNIT_EXPECT_NE(test, 0, regmap_write(map, i, rval));\n\t\t\tKUNIT_EXPECT_FALSE(test, data->read[i]);\n\t\t\tKUNIT_EXPECT_FALSE(test, data->written[i]);\n\t\t} else {\n\t\t\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, i, &rval));\n\t\t\tKUNIT_EXPECT_EQ(test, data->vals[i], rval);\n\t\t\tKUNIT_EXPECT_EQ(test, t->type == REGCACHE_NONE,\n\t\t\t\t\tdata->read[i]);\n\n\t\t\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, i, rval));\n\t\t\tKUNIT_EXPECT_TRUE(test, data->written[i]);\n\t\t}\n\t}\n\n\tregmap_exit(map);\n}\n\nstatic struct regmap_range_cfg test_range = {\n\t.selector_reg = 1,\n\t.selector_mask = 0xff,\n\n\t.window_start = 4,\n\t.window_len = 10,\n\n\t.range_min = 20,\n\t.range_max = 40,\n};\n\nstatic bool test_range_volatile(struct device *dev, unsigned int reg)\n{\n\tif (reg >= test_range.window_start &&\n\t    reg <= test_range.selector_reg + test_range.window_len)\n\t\treturn true;\n\n\tif (reg >= test_range.range_min && reg <= test_range.range_max)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void basic_ranges(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int val;\n\tint i;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\tconfig.volatile_reg = test_range_volatile;\n\tconfig.ranges = &test_range;\n\tconfig.num_ranges = 1;\n\tconfig.max_register = test_range.range_max;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\tfor (i = test_range.range_min; i < test_range.range_max; i++) {\n\t\tdata->read[i] = false;\n\t\tdata->written[i] = false;\n\t}\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, test_range.selector_reg,\n\t\t\t\t\t      test_range.range_max));\n\n\t \n\tdata->written[test_range.selector_reg] = false;\n\tdata->written[test_range.window_start] = false;\n\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, test_range.range_min, 0));\n\tKUNIT_EXPECT_TRUE(test, data->written[test_range.selector_reg]);\n\tKUNIT_EXPECT_TRUE(test, data->written[test_range.window_start]);\n\n\tdata->written[test_range.selector_reg] = false;\n\tdata->written[test_range.window_start] = false;\n\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map,\n\t\t\t\t\t      test_range.range_min +\n\t\t\t\t\t      test_range.window_len,\n\t\t\t\t\t      0));\n\tKUNIT_EXPECT_TRUE(test, data->written[test_range.selector_reg]);\n\tKUNIT_EXPECT_TRUE(test, data->written[test_range.window_start]);\n\n\t \n\tdata->written[test_range.selector_reg] = false;\n\tdata->read[test_range.window_start] = false;\n\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, test_range.range_min, &val));\n\tKUNIT_EXPECT_TRUE(test, data->written[test_range.selector_reg]);\n\tKUNIT_EXPECT_TRUE(test, data->read[test_range.window_start]);\n\n\tdata->written[test_range.selector_reg] = false;\n\tdata->read[test_range.window_start] = false;\n\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map,\n\t\t\t\t\t     test_range.range_min +\n\t\t\t\t\t     test_range.window_len,\n\t\t\t\t\t     &val));\n\tKUNIT_EXPECT_TRUE(test, data->written[test_range.selector_reg]);\n\tKUNIT_EXPECT_TRUE(test, data->read[test_range.window_start]);\n\n\t \n\tfor (i = test_range.range_min; i < test_range.range_max; i++) {\n\t\tKUNIT_EXPECT_FALSE(test, data->read[i]);\n\t\tKUNIT_EXPECT_FALSE(test, data->written[i]);\n\t}\n\n\tregmap_exit(map);\n}\n\n \nstatic void stress_insert(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int rval, *vals;\n\tsize_t buf_sz;\n\tint i;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\tconfig.max_register = 300;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\tvals = kunit_kcalloc(test, sizeof(unsigned long), config.max_register,\n\t\t\t     GFP_KERNEL);\n\tKUNIT_ASSERT_FALSE(test, vals == NULL);\n\tbuf_sz = sizeof(unsigned long) * config.max_register;\n\n\tget_random_bytes(vals, buf_sz);\n\n\t \n\tfor (i = 0; i < config.max_register; i += 100)\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, i, vals[i]));\n\tfor (i = 0; i < config.max_register; i += 50)\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, i, vals[i]));\n\tfor (i = 0; i < config.max_register; i += 25)\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, i, vals[i]));\n\tfor (i = 0; i < config.max_register; i += 10)\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, i, vals[i]));\n\tfor (i = 0; i < config.max_register; i += 5)\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, i, vals[i]));\n\tfor (i = 0; i < config.max_register; i += 3)\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, i, vals[i]));\n\tfor (i = 0; i < config.max_register; i += 2)\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, i, vals[i]));\n\tfor (i = 0; i < config.max_register; i++)\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, i, vals[i]));\n\n\t \n\tfor (i = 0; i < config.max_register; i ++) {\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, i, &rval));\n\t\tKUNIT_EXPECT_EQ(test, rval, vals[i]);\n\t\tKUNIT_EXPECT_EQ(test, t->type == REGCACHE_NONE, data->read[i]);\n\t}\n\n\tregmap_exit(map);\n}\n\nstatic void cache_bypass(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int val, rval;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\tget_random_bytes(&val, sizeof(val));\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, 0, val));\n\n\t \n\tregcache_cache_bypass(map, true);\n\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, 0, val + 1));\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, 0, &rval));\n\tKUNIT_EXPECT_EQ(test, val + 1, rval);\n\tKUNIT_EXPECT_EQ(test, data->vals[0], rval);\n\n\t \n\tregcache_cache_bypass(map, false);\n\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, 0, &rval));\n\tKUNIT_EXPECT_EQ(test, val, rval);\n\n\tregmap_exit(map);\n}\n\nstatic void cache_sync(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int val[BLOCK_TEST_SIZE];\n\tint i;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\tget_random_bytes(&val, sizeof(val));\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_bulk_write(map, 0, val,\n\t\t\t\t\t\t   BLOCK_TEST_SIZE));\n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tdata->written[i] = false;\n\n\t \n\tregcache_mark_dirty(map);\n\tmemset(data->vals, 0, sizeof(val));\n\tKUNIT_EXPECT_EQ(test, 0, regcache_sync(map));\n\n\t \n\tKUNIT_EXPECT_MEMEQ(test, data->vals, val, sizeof(val));\n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, true, data->written[i]);\n\n\tregmap_exit(map);\n}\n\nstatic void cache_sync_defaults(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int val;\n\tint i;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\tconfig.num_reg_defaults = BLOCK_TEST_SIZE;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\tget_random_bytes(&val, sizeof(val));\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, 2, val));\n\n\t \n\tregcache_mark_dirty(map);\n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tdata->written[i] = false;\n\tKUNIT_EXPECT_EQ(test, 0, regcache_sync(map));\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, i == 2, data->written[i]);\n\n\tregmap_exit(map);\n}\n\nstatic void cache_sync_readonly(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int val;\n\tint i;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\tconfig.writeable_reg = reg_5_false;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, i, &val));\n\n\t \n\tget_random_bytes(&val, sizeof(val));\n\tregcache_cache_only(map, true);\n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, i != 5, regmap_write(map, i, val) == 0);\n\tregcache_cache_only(map, false);\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tdata->written[i] = false;\n\tKUNIT_EXPECT_EQ(test, 0, regcache_sync(map));\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, i != 5, data->written[i]);\n\n\tregmap_exit(map);\n}\n\nstatic void cache_sync_patch(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tstruct reg_sequence patch[2];\n\tunsigned int rval[BLOCK_TEST_SIZE], val;\n\tint i;\n\n\t \n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\tconfig.num_reg_defaults = BLOCK_TEST_SIZE;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_bulk_read(map, 0, rval,\n\t\t\t\t\t\t  BLOCK_TEST_SIZE));\n\n\t \n\tpatch[0].reg = 2;\n\tpatch[0].def = rval[2] + 1;\n\tpatch[0].delay_us = 0;\n\tpatch[1].reg = 5;\n\tpatch[1].def = rval[5] + 1;\n\tpatch[1].delay_us = 0;\n\tKUNIT_EXPECT_EQ(test, 0, regmap_register_patch(map, patch,\n\t\t\t\t\t\t       ARRAY_SIZE(patch)));\n\n\t \n\tregcache_mark_dirty(map);\n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tdata->written[i] = false;\n\tKUNIT_EXPECT_EQ(test, 0, regcache_sync(map));\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++) {\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, i, &val));\n\t\tKUNIT_EXPECT_EQ(test, val, rval[i]);\n\n\t\tswitch (i) {\n\t\tcase 2:\n\t\tcase 5:\n\t\t\tKUNIT_EXPECT_EQ(test, true, data->written[i]);\n\t\t\tKUNIT_EXPECT_EQ(test, data->vals[i], rval[i] + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tKUNIT_EXPECT_EQ(test, false, data->written[i]);\n\t\t\tKUNIT_EXPECT_EQ(test, data->vals[i], rval[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tregmap_exit(map);\n}\n\nstatic void cache_drop(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int rval[BLOCK_TEST_SIZE];\n\tint i;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\tconfig.num_reg_defaults = BLOCK_TEST_SIZE;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tdata->read[i] = false;\n\tKUNIT_EXPECT_EQ(test, 0, regmap_bulk_read(map, 0, rval,\n\t\t\t\t\t\t  BLOCK_TEST_SIZE));\n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++) {\n\t\tKUNIT_EXPECT_FALSE(test, data->read[i]);\n\t\tdata->read[i] = false;\n\t}\n\tKUNIT_EXPECT_MEMEQ(test, data->vals, rval, sizeof(rval));\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regcache_drop_region(map, 3, 5));\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_bulk_read(map, 0, rval,\n\t\t\t\t\t\t  BLOCK_TEST_SIZE));\n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, data->read[i], i >= 3 && i <= 5);\n\tKUNIT_EXPECT_MEMEQ(test, data->vals, rval, sizeof(rval));\n\n\tregmap_exit(map);\n}\n\nstatic void cache_present(struct kunit *test)\n{\n\tstruct regcache_types *t = (struct regcache_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int val;\n\tint i;\n\n\tconfig = test_regmap_config;\n\tconfig.cache_type = t->type;\n\n\tmap = gen_regmap(&config, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tdata->read[i] = false;\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_ASSERT_FALSE(test, regcache_reg_cached(map, i));\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_ASSERT_FALSE(test, data->read[i]);\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, i, &val));\n\n\t \n\tfor (i = 0; i < BLOCK_TEST_SIZE; i++)\n\t\tKUNIT_ASSERT_TRUE(test, regcache_reg_cached(map, i));\n\n\tregmap_exit(map);\n}\n\nstruct raw_test_types {\n\tconst char *name;\n\n\tenum regcache_type cache_type;\n\tenum regmap_endian val_endian;\n};\n\nstatic void raw_to_desc(const struct raw_test_types *t, char *desc)\n{\n\tstrcpy(desc, t->name);\n}\n\nstatic const struct raw_test_types raw_types_list[] = {\n\t{ \"none-little\",   REGCACHE_NONE,   REGMAP_ENDIAN_LITTLE },\n\t{ \"none-big\",      REGCACHE_NONE,   REGMAP_ENDIAN_BIG },\n\t{ \"flat-little\",   REGCACHE_FLAT,   REGMAP_ENDIAN_LITTLE },\n\t{ \"flat-big\",      REGCACHE_FLAT,   REGMAP_ENDIAN_BIG },\n\t{ \"rbtree-little\", REGCACHE_RBTREE, REGMAP_ENDIAN_LITTLE },\n\t{ \"rbtree-big\",    REGCACHE_RBTREE, REGMAP_ENDIAN_BIG },\n\t{ \"maple-little\",  REGCACHE_MAPLE,  REGMAP_ENDIAN_LITTLE },\n\t{ \"maple-big\",     REGCACHE_MAPLE,  REGMAP_ENDIAN_BIG },\n};\n\nKUNIT_ARRAY_PARAM(raw_test_types, raw_types_list, raw_to_desc);\n\nstatic const struct raw_test_types raw_cache_types_list[] = {\n\t{ \"flat-little\",   REGCACHE_FLAT,   REGMAP_ENDIAN_LITTLE },\n\t{ \"flat-big\",      REGCACHE_FLAT,   REGMAP_ENDIAN_BIG },\n\t{ \"rbtree-little\", REGCACHE_RBTREE, REGMAP_ENDIAN_LITTLE },\n\t{ \"rbtree-big\",    REGCACHE_RBTREE, REGMAP_ENDIAN_BIG },\n\t{ \"maple-little\",  REGCACHE_MAPLE,  REGMAP_ENDIAN_LITTLE },\n\t{ \"maple-big\",     REGCACHE_MAPLE,  REGMAP_ENDIAN_BIG },\n};\n\nKUNIT_ARRAY_PARAM(raw_test_cache_types, raw_cache_types_list, raw_to_desc);\n\nstatic const struct regmap_config raw_regmap_config = {\n\t.max_register = BLOCK_TEST_SIZE,\n\n\t.reg_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.reg_bits = 16,\n\t.val_bits = 16,\n};\n\nstatic struct regmap *gen_raw_regmap(struct regmap_config *config,\n\t\t\t\t     struct raw_test_types *test_type,\n\t\t\t\t     struct regmap_ram_data **data)\n{\n\tu16 *buf;\n\tstruct regmap *ret;\n\tsize_t size = (config->max_register + 1) * config->reg_bits / 8;\n\tint i;\n\tstruct reg_default *defaults;\n\n\tconfig->cache_type = test_type->cache_type;\n\tconfig->val_format_endian = test_type->val_endian;\n\tconfig->disable_locking = config->cache_type == REGCACHE_RBTREE ||\n\t\t\t\t\tconfig->cache_type == REGCACHE_MAPLE;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_random_bytes(buf, size);\n\n\t*data = kzalloc(sizeof(**data), GFP_KERNEL);\n\tif (!(*data))\n\t\treturn ERR_PTR(-ENOMEM);\n\t(*data)->vals = (void *)buf;\n\n\tconfig->num_reg_defaults = config->max_register + 1;\n\tdefaults = kcalloc(config->num_reg_defaults,\n\t\t\t   sizeof(struct reg_default),\n\t\t\t   GFP_KERNEL);\n\tif (!defaults)\n\t\treturn ERR_PTR(-ENOMEM);\n\tconfig->reg_defaults = defaults;\n\n\tfor (i = 0; i < config->num_reg_defaults; i++) {\n\t\tdefaults[i].reg = i;\n\t\tswitch (test_type->val_endian) {\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tdefaults[i].def = le16_to_cpu(buf[i]);\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tdefaults[i].def = be16_to_cpu(buf[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\t \n\tif (config->cache_type == REGCACHE_NONE)\n\t\tconfig->num_reg_defaults = 0;\n\n\tret = regmap_init_raw_ram(config, *data);\n\tif (IS_ERR(ret)) {\n\t\tkfree(buf);\n\t\tkfree(*data);\n\t}\n\n\treturn ret;\n}\n\nstatic void raw_read_defaults_single(struct kunit *test)\n{\n\tstruct raw_test_types *t = (struct raw_test_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tunsigned int rval;\n\tint i;\n\n\tconfig = raw_regmap_config;\n\n\tmap = gen_raw_regmap(&config, t, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < config.max_register + 1; i++) {\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, i, &rval));\n\t\tKUNIT_EXPECT_EQ(test, config.reg_defaults[i].def, rval);\n\t}\n\n\tregmap_exit(map);\n}\n\nstatic void raw_read_defaults(struct kunit *test)\n{\n\tstruct raw_test_types *t = (struct raw_test_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tu16 *rval;\n\tu16 def;\n\tsize_t val_len;\n\tint i;\n\n\tconfig = raw_regmap_config;\n\n\tmap = gen_raw_regmap(&config, t, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\tval_len = sizeof(*rval) * (config.max_register + 1);\n\trval = kmalloc(val_len, GFP_KERNEL);\n\tKUNIT_ASSERT_TRUE(test, rval != NULL);\n\tif (!rval)\n\t\treturn;\n\t\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_raw_read(map, 0, rval, val_len));\n\tfor (i = 0; i < config.max_register + 1; i++) {\n\t\tdef = config.reg_defaults[i].def;\n\t\tif (config.val_format_endian == REGMAP_ENDIAN_BIG) {\n\t\t\tKUNIT_EXPECT_EQ(test, def, be16_to_cpu(rval[i]));\n\t\t} else {\n\t\t\tKUNIT_EXPECT_EQ(test, def, le16_to_cpu(rval[i]));\n\t\t}\n\t}\n\t\n\tkfree(rval);\n\tregmap_exit(map);\n}\n\nstatic void raw_write_read_single(struct kunit *test)\n{\n\tstruct raw_test_types *t = (struct raw_test_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tu16 val;\n\tunsigned int rval;\n\n\tconfig = raw_regmap_config;\n\n\tmap = gen_raw_regmap(&config, t, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\tget_random_bytes(&val, sizeof(val));\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, 0, val));\n\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, 0, &rval));\n\tKUNIT_EXPECT_EQ(test, val, rval);\n\n\tregmap_exit(map);\n}\n\nstatic void raw_write(struct kunit *test)\n{\n\tstruct raw_test_types *t = (struct raw_test_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tu16 *hw_buf;\n\tu16 val[2];\n\tunsigned int rval;\n\tint i;\n\n\tconfig = raw_regmap_config;\n\n\tmap = gen_raw_regmap(&config, t, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\thw_buf = (u16 *)data->vals;\n\n\tget_random_bytes(&val, sizeof(val));\n\n\t \n\tKUNIT_EXPECT_EQ(test, 0, regmap_raw_write(map, 2, val, sizeof(val)));\n\n\t \n\tfor (i = 0; i < config.max_register + 1; i++) {\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, i, &rval));\n\n\t\tswitch (i) {\n\t\tcase 2:\n\t\tcase 3:\n\t\t\tif (config.val_format_endian == REGMAP_ENDIAN_BIG) {\n\t\t\t\tKUNIT_EXPECT_EQ(test, rval,\n\t\t\t\t\t\tbe16_to_cpu(val[i % 2]));\n\t\t\t} else {\n\t\t\t\tKUNIT_EXPECT_EQ(test, rval,\n\t\t\t\t\t\tle16_to_cpu(val[i % 2]));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tKUNIT_EXPECT_EQ(test, config.reg_defaults[i].def, rval);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tKUNIT_EXPECT_MEMEQ(test, &hw_buf[2], val, sizeof(val));\n\n\tregmap_exit(map);\n}\n\nstatic void raw_sync(struct kunit *test)\n{\n\tstruct raw_test_types *t = (struct raw_test_types *)test->param_value;\n\tstruct regmap *map;\n\tstruct regmap_config config;\n\tstruct regmap_ram_data *data;\n\tu16 val[2];\n\tu16 *hw_buf;\n\tunsigned int rval;\n\tint i;\n\n\tconfig = raw_regmap_config;\n\n\tmap = gen_raw_regmap(&config, t, &data);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(map));\n\tif (IS_ERR(map))\n\t\treturn;\n\n\thw_buf = (u16 *)data->vals;\n\n\tget_random_bytes(&val, sizeof(val));\n\n\t \n\tregcache_cache_only(map, true);\n\tKUNIT_EXPECT_EQ(test, 0, regmap_raw_write(map, 2, val, sizeof(val)));\n\tif (config.val_format_endian == REGMAP_ENDIAN_BIG)\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, 6,\n\t\t\t\t\t\t      be16_to_cpu(val[0])));\n\telse\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_write(map, 6,\n\t\t\t\t\t\t      le16_to_cpu(val[0])));\n\n\t \n\tfor (i = 0; i < config.max_register + 1; i++) {\n\t\tKUNIT_EXPECT_EQ(test, 0, regmap_read(map, i, &rval));\n\n\t\tswitch (i) {\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 6:\n\t\t\tif (config.val_format_endian == REGMAP_ENDIAN_BIG) {\n\t\t\t\tKUNIT_EXPECT_EQ(test, rval,\n\t\t\t\t\t\tbe16_to_cpu(val[i % 2]));\n\t\t\t} else {\n\t\t\t\tKUNIT_EXPECT_EQ(test, rval,\n\t\t\t\t\t\tle16_to_cpu(val[i % 2]));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tKUNIT_EXPECT_EQ(test, config.reg_defaults[i].def, rval);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t \n\tKUNIT_EXPECT_MEMNEQ(test, &hw_buf[2], val, sizeof(val));\n\tKUNIT_EXPECT_MEMNEQ(test, &hw_buf[6], val, sizeof(u16));\n\n\tfor (i = 0; i < config.max_register + 1; i++)\n\t\tdata->written[i] = false;\n\n\t \n\tregcache_cache_only(map, false);\n\tregcache_mark_dirty(map);\n\tKUNIT_EXPECT_EQ(test, 0, regcache_sync(map));\n\n\t \n\tKUNIT_EXPECT_MEMEQ(test, &hw_buf[2], val, sizeof(val));\n\tKUNIT_EXPECT_MEMEQ(test, &hw_buf[6], val, sizeof(u16));\n\n\tregmap_exit(map);\n}\n\nstatic struct kunit_case regmap_test_cases[] = {\n\tKUNIT_CASE_PARAM(basic_read_write, regcache_types_gen_params),\n\tKUNIT_CASE_PARAM(bulk_write, regcache_types_gen_params),\n\tKUNIT_CASE_PARAM(bulk_read, regcache_types_gen_params),\n\tKUNIT_CASE_PARAM(write_readonly, regcache_types_gen_params),\n\tKUNIT_CASE_PARAM(read_writeonly, regcache_types_gen_params),\n\tKUNIT_CASE_PARAM(reg_defaults, regcache_types_gen_params),\n\tKUNIT_CASE_PARAM(reg_defaults_read_dev, regcache_types_gen_params),\n\tKUNIT_CASE_PARAM(register_patch, regcache_types_gen_params),\n\tKUNIT_CASE_PARAM(stride, regcache_types_gen_params),\n\tKUNIT_CASE_PARAM(basic_ranges, regcache_types_gen_params),\n\tKUNIT_CASE_PARAM(stress_insert, regcache_types_gen_params),\n\tKUNIT_CASE_PARAM(cache_bypass, real_cache_types_gen_params),\n\tKUNIT_CASE_PARAM(cache_sync, real_cache_types_gen_params),\n\tKUNIT_CASE_PARAM(cache_sync_defaults, real_cache_types_gen_params),\n\tKUNIT_CASE_PARAM(cache_sync_readonly, real_cache_types_gen_params),\n\tKUNIT_CASE_PARAM(cache_sync_patch, real_cache_types_gen_params),\n\tKUNIT_CASE_PARAM(cache_drop, sparse_cache_types_gen_params),\n\tKUNIT_CASE_PARAM(cache_present, sparse_cache_types_gen_params),\n\n\tKUNIT_CASE_PARAM(raw_read_defaults_single, raw_test_types_gen_params),\n\tKUNIT_CASE_PARAM(raw_read_defaults, raw_test_types_gen_params),\n\tKUNIT_CASE_PARAM(raw_write_read_single, raw_test_types_gen_params),\n\tKUNIT_CASE_PARAM(raw_write, raw_test_types_gen_params),\n\tKUNIT_CASE_PARAM(raw_sync, raw_test_cache_types_gen_params),\n\t{}\n};\n\nstatic struct kunit_suite regmap_test_suite = {\n\t.name = \"regmap\",\n\t.test_cases = regmap_test_cases,\n};\nkunit_test_suite(regmap_test_suite);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}