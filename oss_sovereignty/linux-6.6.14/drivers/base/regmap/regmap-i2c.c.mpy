{
  "module_name": "regmap-i2c.c",
  "hash_id": "57aa8d1b666f2e8791a8a07154369821365de5255ebe6547a6688c0e6e9f99ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/regmap/regmap-i2c.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/regmap.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n\n#include \"internal.h\"\n\nstatic int regmap_smbus_byte_reg_read(void *context, unsigned int reg,\n\t\t\t\t      unsigned int *val)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tint ret;\n\n\tif (reg > 0xff)\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_read_byte_data(i2c, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\n\treturn 0;\n}\n\nstatic int regmap_smbus_byte_reg_write(void *context, unsigned int reg,\n\t\t\t\t       unsigned int val)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\n\tif (val > 0xff || reg > 0xff)\n\t\treturn -EINVAL;\n\n\treturn i2c_smbus_write_byte_data(i2c, reg, val);\n}\n\nstatic const struct regmap_bus regmap_smbus_byte = {\n\t.reg_write = regmap_smbus_byte_reg_write,\n\t.reg_read = regmap_smbus_byte_reg_read,\n};\n\nstatic int regmap_smbus_word_reg_read(void *context, unsigned int reg,\n\t\t\t\t      unsigned int *val)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tint ret;\n\n\tif (reg > 0xff)\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_read_word_data(i2c, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\n\treturn 0;\n}\n\nstatic int regmap_smbus_word_reg_write(void *context, unsigned int reg,\n\t\t\t\t       unsigned int val)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\n\tif (val > 0xffff || reg > 0xff)\n\t\treturn -EINVAL;\n\n\treturn i2c_smbus_write_word_data(i2c, reg, val);\n}\n\nstatic const struct regmap_bus regmap_smbus_word = {\n\t.reg_write = regmap_smbus_word_reg_write,\n\t.reg_read = regmap_smbus_word_reg_read,\n};\n\nstatic int regmap_smbus_word_read_swapped(void *context, unsigned int reg,\n\t\t\t\t\t  unsigned int *val)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tint ret;\n\n\tif (reg > 0xff)\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_read_word_swapped(i2c, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\n\treturn 0;\n}\n\nstatic int regmap_smbus_word_write_swapped(void *context, unsigned int reg,\n\t\t\t\t\t   unsigned int val)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\n\tif (val > 0xffff || reg > 0xff)\n\t\treturn -EINVAL;\n\n\treturn i2c_smbus_write_word_swapped(i2c, reg, val);\n}\n\nstatic const struct regmap_bus regmap_smbus_word_swapped = {\n\t.reg_write = regmap_smbus_word_write_swapped,\n\t.reg_read = regmap_smbus_word_read_swapped,\n};\n\nstatic int regmap_i2c_write(void *context, const void *data, size_t count)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tint ret;\n\n\tret = i2c_master_send(i2c, data, count);\n\tif (ret == count)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int regmap_i2c_gather_write(void *context,\n\t\t\t\t   const void *reg, size_t reg_size,\n\t\t\t\t   const void *val, size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct i2c_msg xfer[2];\n\tint ret;\n\n\t \n\tif (!i2c_check_functionality(i2c->adapter, I2C_FUNC_NOSTART))\n\t\treturn -ENOTSUPP;\n\n\txfer[0].addr = i2c->addr;\n\txfer[0].flags = 0;\n\txfer[0].len = reg_size;\n\txfer[0].buf = (void *)reg;\n\n\txfer[1].addr = i2c->addr;\n\txfer[1].flags = I2C_M_NOSTART;\n\txfer[1].len = val_size;\n\txfer[1].buf = (void *)val;\n\n\tret = i2c_transfer(i2c->adapter, xfer, 2);\n\tif (ret == 2)\n\t\treturn 0;\n\tif (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int regmap_i2c_read(void *context,\n\t\t\t   const void *reg, size_t reg_size,\n\t\t\t   void *val, size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct i2c_msg xfer[2];\n\tint ret;\n\n\txfer[0].addr = i2c->addr;\n\txfer[0].flags = 0;\n\txfer[0].len = reg_size;\n\txfer[0].buf = (void *)reg;\n\n\txfer[1].addr = i2c->addr;\n\txfer[1].flags = I2C_M_RD;\n\txfer[1].len = val_size;\n\txfer[1].buf = val;\n\n\tret = i2c_transfer(i2c->adapter, xfer, 2);\n\tif (ret == 2)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic const struct regmap_bus regmap_i2c = {\n\t.write = regmap_i2c_write,\n\t.gather_write = regmap_i2c_gather_write,\n\t.read = regmap_i2c_read,\n\t.reg_format_endian_default = REGMAP_ENDIAN_BIG,\n\t.val_format_endian_default = REGMAP_ENDIAN_BIG,\n};\n\nstatic int regmap_i2c_smbus_i2c_write(void *context, const void *data,\n\t\t\t\t      size_t count)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\n\tif (count < 1)\n\t\treturn -EINVAL;\n\n\t--count;\n\treturn i2c_smbus_write_i2c_block_data(i2c, ((u8 *)data)[0], count,\n\t\t\t\t\t      ((u8 *)data + 1));\n}\n\nstatic int regmap_i2c_smbus_i2c_read(void *context, const void *reg,\n\t\t\t\t     size_t reg_size, void *val,\n\t\t\t\t     size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tint ret;\n\n\tif (reg_size != 1 || val_size < 1)\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_read_i2c_block_data(i2c, ((u8 *)reg)[0], val_size, val);\n\tif (ret == val_size)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic const struct regmap_bus regmap_i2c_smbus_i2c_block = {\n\t.write = regmap_i2c_smbus_i2c_write,\n\t.read = regmap_i2c_smbus_i2c_read,\n\t.max_raw_read = I2C_SMBUS_BLOCK_MAX - 1,\n\t.max_raw_write = I2C_SMBUS_BLOCK_MAX - 1,\n};\n\nstatic int regmap_i2c_smbus_i2c_write_reg16(void *context, const void *data,\n\t\t\t\t      size_t count)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\n\tif (count < 2)\n\t\treturn -EINVAL;\n\n\tcount--;\n\treturn i2c_smbus_write_i2c_block_data(i2c, ((u8 *)data)[0], count,\n\t\t\t\t\t      (u8 *)data + 1);\n}\n\nstatic int regmap_i2c_smbus_i2c_read_reg16(void *context, const void *reg,\n\t\t\t\t     size_t reg_size, void *val,\n\t\t\t\t     size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tint ret, count, len = val_size;\n\n\tif (reg_size != 2)\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_write_byte_data(i2c, ((u16 *)reg)[0] & 0xff,\n\t\t\t\t\t((u16 *)reg)[0] >> 8);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcount = 0;\n\tdo {\n\t\t \n\t\tret = i2c_smbus_read_byte(i2c);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t*((u8 *)val++) = ret;\n\t\tcount++;\n\t\tlen--;\n\t} while (len > 0);\n\n\tif (count == val_size)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic const struct regmap_bus regmap_i2c_smbus_i2c_block_reg16 = {\n\t.write = regmap_i2c_smbus_i2c_write_reg16,\n\t.read = regmap_i2c_smbus_i2c_read_reg16,\n\t.max_raw_read = I2C_SMBUS_BLOCK_MAX - 2,\n\t.max_raw_write = I2C_SMBUS_BLOCK_MAX - 2,\n};\n\nstatic const struct regmap_bus *regmap_get_i2c_bus(struct i2c_client *i2c,\n\t\t\t\t\tconst struct regmap_config *config)\n{\n\tconst struct i2c_adapter_quirks *quirks;\n\tconst struct regmap_bus *bus = NULL;\n\tstruct regmap_bus *ret_bus;\n\tu16 max_read = 0, max_write = 0;\n\n\tif (i2c_check_functionality(i2c->adapter, I2C_FUNC_I2C))\n\t\tbus = &regmap_i2c;\n\telse if (config->val_bits == 8 && config->reg_bits == 8 &&\n\t\t i2c_check_functionality(i2c->adapter,\n\t\t\t\t\t I2C_FUNC_SMBUS_I2C_BLOCK))\n\t\tbus = &regmap_i2c_smbus_i2c_block;\n\telse if (config->val_bits == 8 && config->reg_bits == 16 &&\n\t\ti2c_check_functionality(i2c->adapter,\n\t\t\t\t\tI2C_FUNC_SMBUS_I2C_BLOCK))\n\t\tbus = &regmap_i2c_smbus_i2c_block_reg16;\n\telse if (config->val_bits == 16 && config->reg_bits == 8 &&\n\t\t i2c_check_functionality(i2c->adapter,\n\t\t\t\t\t I2C_FUNC_SMBUS_WORD_DATA))\n\t\tswitch (regmap_get_val_endian(&i2c->dev, NULL, config)) {\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tbus = &regmap_smbus_word;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tbus = &regmap_smbus_word_swapped;\n\t\t\tbreak;\n\t\tdefault:\t\t \n\t\t\tbreak;\n\t\t}\n\telse if (config->val_bits == 8 && config->reg_bits == 8 &&\n\t\t i2c_check_functionality(i2c->adapter,\n\t\t\t\t\t I2C_FUNC_SMBUS_BYTE_DATA))\n\t\tbus = &regmap_smbus_byte;\n\n\tif (!bus)\n\t\treturn ERR_PTR(-ENOTSUPP);\n\n\tquirks = i2c->adapter->quirks;\n\tif (quirks) {\n\t\tif (quirks->max_read_len &&\n\t\t    (bus->max_raw_read == 0 || bus->max_raw_read > quirks->max_read_len))\n\t\t\tmax_read = quirks->max_read_len;\n\n\t\tif (quirks->max_write_len &&\n\t\t    (bus->max_raw_write == 0 || bus->max_raw_write > quirks->max_write_len))\n\t\t\tmax_write = quirks->max_write_len;\n\n\t\tif (max_read || max_write) {\n\t\t\tret_bus = kmemdup(bus, sizeof(*bus), GFP_KERNEL);\n\t\t\tif (!ret_bus)\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\tret_bus->free_on_exit = true;\n\t\t\tret_bus->max_raw_read = max_read;\n\t\t\tret_bus->max_raw_write = max_write;\n\t\t\tbus = ret_bus;\n\t\t}\n\t}\n\n\treturn bus;\n}\n\nstruct regmap *__regmap_init_i2c(struct i2c_client *i2c,\n\t\t\t\t const struct regmap_config *config,\n\t\t\t\t struct lock_class_key *lock_key,\n\t\t\t\t const char *lock_name)\n{\n\tconst struct regmap_bus *bus = regmap_get_i2c_bus(i2c, config);\n\n\tif (IS_ERR(bus))\n\t\treturn ERR_CAST(bus);\n\n\treturn __regmap_init(&i2c->dev, bus, &i2c->dev, config,\n\t\t\t     lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__regmap_init_i2c);\n\nstruct regmap *__devm_regmap_init_i2c(struct i2c_client *i2c,\n\t\t\t\t      const struct regmap_config *config,\n\t\t\t\t      struct lock_class_key *lock_key,\n\t\t\t\t      const char *lock_name)\n{\n\tconst struct regmap_bus *bus = regmap_get_i2c_bus(i2c, config);\n\n\tif (IS_ERR(bus))\n\t\treturn ERR_CAST(bus);\n\n\treturn __devm_regmap_init(&i2c->dev, bus, &i2c->dev, config,\n\t\t\t\t  lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__devm_regmap_init_i2c);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}