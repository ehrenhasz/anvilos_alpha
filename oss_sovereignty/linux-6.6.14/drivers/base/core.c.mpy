{
  "module_name": "core.c",
  "hash_id": "452202bc49cdfa57420275847e5a350f596e95f903b79133f5542736900adefa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/core.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/cpufreq.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/fwnode.h>\n#include <linux/init.h>\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/notifier.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/blkdev.h>\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n#include <linux/netdevice.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/mm.h>\n#include <linux/string_helpers.h>\n#include <linux/swiotlb.h>\n#include <linux/sysfs.h>\n#include <linux/dma-map-ops.h>  \n\n#include \"base.h\"\n#include \"physical_location.h\"\n#include \"power/power.h\"\n\n \nstatic LIST_HEAD(deferred_sync);\nstatic unsigned int defer_sync_state_count = 1;\nstatic DEFINE_MUTEX(fwnode_link_lock);\nstatic bool fw_devlink_is_permissive(void);\nstatic void __fw_devlink_link_to_consumers(struct device *dev);\nstatic bool fw_devlink_drv_reg_done;\nstatic bool fw_devlink_best_effort;\n\n \nstatic int __fwnode_link_add(struct fwnode_handle *con,\n\t\t\t     struct fwnode_handle *sup, u8 flags)\n{\n\tstruct fwnode_link *link;\n\n\tlist_for_each_entry(link, &sup->consumers, s_hook)\n\t\tif (link->consumer == con) {\n\t\t\tlink->flags |= flags;\n\t\t\treturn 0;\n\t\t}\n\n\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tlink->supplier = sup;\n\tINIT_LIST_HEAD(&link->s_hook);\n\tlink->consumer = con;\n\tINIT_LIST_HEAD(&link->c_hook);\n\tlink->flags = flags;\n\n\tlist_add(&link->s_hook, &sup->consumers);\n\tlist_add(&link->c_hook, &con->suppliers);\n\tpr_debug(\"%pfwf Linked as a fwnode consumer to %pfwf\\n\",\n\t\t con, sup);\n\n\treturn 0;\n}\n\nint fwnode_link_add(struct fwnode_handle *con, struct fwnode_handle *sup)\n{\n\tint ret;\n\n\tmutex_lock(&fwnode_link_lock);\n\tret = __fwnode_link_add(con, sup, 0);\n\tmutex_unlock(&fwnode_link_lock);\n\treturn ret;\n}\n\n \nstatic void __fwnode_link_del(struct fwnode_link *link)\n{\n\tpr_debug(\"%pfwf Dropping the fwnode link to %pfwf\\n\",\n\t\t link->consumer, link->supplier);\n\tlist_del(&link->s_hook);\n\tlist_del(&link->c_hook);\n\tkfree(link);\n}\n\n \nstatic void __fwnode_link_cycle(struct fwnode_link *link)\n{\n\tpr_debug(\"%pfwf: Relaxing link with %pfwf\\n\",\n\t\t link->consumer, link->supplier);\n\tlink->flags |= FWLINK_FLAG_CYCLE;\n}\n\n \nstatic void fwnode_links_purge_suppliers(struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_link *link, *tmp;\n\n\tmutex_lock(&fwnode_link_lock);\n\tlist_for_each_entry_safe(link, tmp, &fwnode->suppliers, c_hook)\n\t\t__fwnode_link_del(link);\n\tmutex_unlock(&fwnode_link_lock);\n}\n\n \nstatic void fwnode_links_purge_consumers(struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_link *link, *tmp;\n\n\tmutex_lock(&fwnode_link_lock);\n\tlist_for_each_entry_safe(link, tmp, &fwnode->consumers, s_hook)\n\t\t__fwnode_link_del(link);\n\tmutex_unlock(&fwnode_link_lock);\n}\n\n \nvoid fwnode_links_purge(struct fwnode_handle *fwnode)\n{\n\tfwnode_links_purge_suppliers(fwnode);\n\tfwnode_links_purge_consumers(fwnode);\n}\n\nvoid fw_devlink_purge_absent_suppliers(struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_handle *child;\n\n\t \n\tif (fwnode->dev)\n\t\treturn;\n\n\tfwnode->flags |= FWNODE_FLAG_NOT_DEVICE;\n\tfwnode_links_purge_consumers(fwnode);\n\n\tfwnode_for_each_available_child_node(fwnode, child)\n\t\tfw_devlink_purge_absent_suppliers(child);\n}\nEXPORT_SYMBOL_GPL(fw_devlink_purge_absent_suppliers);\n\n \nstatic void __fwnode_links_move_consumers(struct fwnode_handle *from,\n\t\t\t\t\t  struct fwnode_handle *to)\n{\n\tstruct fwnode_link *link, *tmp;\n\n\tlist_for_each_entry_safe(link, tmp, &from->consumers, s_hook) {\n\t\t__fwnode_link_add(link->consumer, to, link->flags);\n\t\t__fwnode_link_del(link);\n\t}\n}\n\n \nstatic void __fw_devlink_pickup_dangling_consumers(struct fwnode_handle *fwnode,\n\t\t\t\t\t\t   struct fwnode_handle *new_sup)\n{\n\tstruct fwnode_handle *child;\n\n\tif (fwnode->dev && fwnode->dev->bus)\n\t\treturn;\n\n\tfwnode->flags |= FWNODE_FLAG_NOT_DEVICE;\n\t__fwnode_links_move_consumers(fwnode, new_sup);\n\n\tfwnode_for_each_available_child_node(fwnode, child)\n\t\t__fw_devlink_pickup_dangling_consumers(child, new_sup);\n}\n\nstatic DEFINE_MUTEX(device_links_lock);\nDEFINE_STATIC_SRCU(device_links_srcu);\n\nstatic inline void device_links_write_lock(void)\n{\n\tmutex_lock(&device_links_lock);\n}\n\nstatic inline void device_links_write_unlock(void)\n{\n\tmutex_unlock(&device_links_lock);\n}\n\nint device_links_read_lock(void) __acquires(&device_links_srcu)\n{\n\treturn srcu_read_lock(&device_links_srcu);\n}\n\nvoid device_links_read_unlock(int idx) __releases(&device_links_srcu)\n{\n\tsrcu_read_unlock(&device_links_srcu, idx);\n}\n\nint device_links_read_lock_held(void)\n{\n\treturn srcu_read_lock_held(&device_links_srcu);\n}\n\nstatic void device_link_synchronize_removal(void)\n{\n\tsynchronize_srcu(&device_links_srcu);\n}\n\nstatic void device_link_remove_from_lists(struct device_link *link)\n{\n\tlist_del_rcu(&link->s_node);\n\tlist_del_rcu(&link->c_node);\n}\n\nstatic bool device_is_ancestor(struct device *dev, struct device *target)\n{\n\twhile (target->parent) {\n\t\ttarget = target->parent;\n\t\tif (dev == target)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline bool device_link_flag_is_sync_state_only(u32 flags)\n{\n\treturn (flags & ~(DL_FLAG_INFERRED | DL_FLAG_CYCLE)) ==\n\t\t(DL_FLAG_SYNC_STATE_ONLY | DL_FLAG_MANAGED);\n}\n\n \nint device_is_dependent(struct device *dev, void *target)\n{\n\tstruct device_link *link;\n\tint ret;\n\n\t \n\tif (dev == target || device_is_ancestor(dev, target))\n\t\treturn 1;\n\n\tret = device_for_each_child(dev, target, device_is_dependent);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_for_each_entry(link, &dev->links.consumers, s_node) {\n\t\tif (device_link_flag_is_sync_state_only(link->flags))\n\t\t\tcontinue;\n\n\t\tif (link->consumer == target)\n\t\t\treturn 1;\n\n\t\tret = device_is_dependent(link->consumer, target);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void device_link_init_status(struct device_link *link,\n\t\t\t\t    struct device *consumer,\n\t\t\t\t    struct device *supplier)\n{\n\tswitch (supplier->links.status) {\n\tcase DL_DEV_PROBING:\n\t\tswitch (consumer->links.status) {\n\t\tcase DL_DEV_PROBING:\n\t\t\t \n\t\t\tlink->status = DL_STATE_CONSUMER_PROBE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlink->status = DL_STATE_DORMANT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DL_DEV_DRIVER_BOUND:\n\t\tswitch (consumer->links.status) {\n\t\tcase DL_DEV_PROBING:\n\t\t\tlink->status = DL_STATE_CONSUMER_PROBE;\n\t\t\tbreak;\n\t\tcase DL_DEV_DRIVER_BOUND:\n\t\t\tlink->status = DL_STATE_ACTIVE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlink->status = DL_STATE_AVAILABLE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DL_DEV_UNBINDING:\n\t\tlink->status = DL_STATE_SUPPLIER_UNBIND;\n\t\tbreak;\n\tdefault:\n\t\tlink->status = DL_STATE_DORMANT;\n\t\tbreak;\n\t}\n}\n\nstatic int device_reorder_to_tail(struct device *dev, void *not_used)\n{\n\tstruct device_link *link;\n\n\t \n\tif (device_is_registered(dev))\n\t\tdevices_kset_move_last(dev);\n\n\tif (device_pm_initialized(dev))\n\t\tdevice_pm_move_last(dev);\n\n\tdevice_for_each_child(dev, NULL, device_reorder_to_tail);\n\tlist_for_each_entry(link, &dev->links.consumers, s_node) {\n\t\tif (device_link_flag_is_sync_state_only(link->flags))\n\t\t\tcontinue;\n\t\tdevice_reorder_to_tail(link->consumer, NULL);\n\t}\n\n\treturn 0;\n}\n\n \nvoid device_pm_move_to_tail(struct device *dev)\n{\n\tint idx;\n\n\tidx = device_links_read_lock();\n\tdevice_pm_lock();\n\tdevice_reorder_to_tail(dev, NULL);\n\tdevice_pm_unlock();\n\tdevice_links_read_unlock(idx);\n}\n\n#define to_devlink(dev)\tcontainer_of((dev), struct device_link, link_dev)\n\nstatic ssize_t status_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tconst char *output;\n\n\tswitch (to_devlink(dev)->status) {\n\tcase DL_STATE_NONE:\n\t\toutput = \"not tracked\";\n\t\tbreak;\n\tcase DL_STATE_DORMANT:\n\t\toutput = \"dormant\";\n\t\tbreak;\n\tcase DL_STATE_AVAILABLE:\n\t\toutput = \"available\";\n\t\tbreak;\n\tcase DL_STATE_CONSUMER_PROBE:\n\t\toutput = \"consumer probing\";\n\t\tbreak;\n\tcase DL_STATE_ACTIVE:\n\t\toutput = \"active\";\n\t\tbreak;\n\tcase DL_STATE_SUPPLIER_UNBIND:\n\t\toutput = \"supplier unbinding\";\n\t\tbreak;\n\tdefault:\n\t\toutput = \"unknown\";\n\t\tbreak;\n\t}\n\n\treturn sysfs_emit(buf, \"%s\\n\", output);\n}\nstatic DEVICE_ATTR_RO(status);\n\nstatic ssize_t auto_remove_on_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct device_link *link = to_devlink(dev);\n\tconst char *output;\n\n\tif (link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)\n\t\toutput = \"supplier unbind\";\n\telse if (link->flags & DL_FLAG_AUTOREMOVE_CONSUMER)\n\t\toutput = \"consumer unbind\";\n\telse\n\t\toutput = \"never\";\n\n\treturn sysfs_emit(buf, \"%s\\n\", output);\n}\nstatic DEVICE_ATTR_RO(auto_remove_on);\n\nstatic ssize_t runtime_pm_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct device_link *link = to_devlink(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!(link->flags & DL_FLAG_PM_RUNTIME));\n}\nstatic DEVICE_ATTR_RO(runtime_pm);\n\nstatic ssize_t sync_state_only_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct device_link *link = to_devlink(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  !!(link->flags & DL_FLAG_SYNC_STATE_ONLY));\n}\nstatic DEVICE_ATTR_RO(sync_state_only);\n\nstatic struct attribute *devlink_attrs[] = {\n\t&dev_attr_status.attr,\n\t&dev_attr_auto_remove_on.attr,\n\t&dev_attr_runtime_pm.attr,\n\t&dev_attr_sync_state_only.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(devlink);\n\nstatic void device_link_release_fn(struct work_struct *work)\n{\n\tstruct device_link *link = container_of(work, struct device_link, rm_work);\n\n\t \n\tdevice_link_synchronize_removal();\n\n\tpm_runtime_release_supplier(link);\n\t \n\tif (link->supplier_preactivated)\n\t\tpm_runtime_put_noidle(link->supplier);\n\n\tpm_request_idle(link->supplier);\n\n\tput_device(link->consumer);\n\tput_device(link->supplier);\n\tkfree(link);\n}\n\nstatic void devlink_dev_release(struct device *dev)\n{\n\tstruct device_link *link = to_devlink(dev);\n\n\tINIT_WORK(&link->rm_work, device_link_release_fn);\n\t \n\tqueue_work(system_long_wq, &link->rm_work);\n}\n\nstatic struct class devlink_class = {\n\t.name = \"devlink\",\n\t.dev_groups = devlink_groups,\n\t.dev_release = devlink_dev_release,\n};\n\nstatic int devlink_add_symlinks(struct device *dev)\n{\n\tint ret;\n\tsize_t len;\n\tstruct device_link *link = to_devlink(dev);\n\tstruct device *sup = link->supplier;\n\tstruct device *con = link->consumer;\n\tchar *buf;\n\n\tlen = max(strlen(dev_bus_name(sup)) + strlen(dev_name(sup)),\n\t\t  strlen(dev_bus_name(con)) + strlen(dev_name(con)));\n\tlen += strlen(\":\");\n\tlen += strlen(\"supplier:\") + 1;\n\tbuf = kzalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = sysfs_create_link(&link->link_dev.kobj, &sup->kobj, \"supplier\");\n\tif (ret)\n\t\tgoto out;\n\n\tret = sysfs_create_link(&link->link_dev.kobj, &con->kobj, \"consumer\");\n\tif (ret)\n\t\tgoto err_con;\n\n\tsnprintf(buf, len, \"consumer:%s:%s\", dev_bus_name(con), dev_name(con));\n\tret = sysfs_create_link(&sup->kobj, &link->link_dev.kobj, buf);\n\tif (ret)\n\t\tgoto err_con_dev;\n\n\tsnprintf(buf, len, \"supplier:%s:%s\", dev_bus_name(sup), dev_name(sup));\n\tret = sysfs_create_link(&con->kobj, &link->link_dev.kobj, buf);\n\tif (ret)\n\t\tgoto err_sup_dev;\n\n\tgoto out;\n\nerr_sup_dev:\n\tsnprintf(buf, len, \"consumer:%s:%s\", dev_bus_name(con), dev_name(con));\n\tsysfs_remove_link(&sup->kobj, buf);\nerr_con_dev:\n\tsysfs_remove_link(&link->link_dev.kobj, \"consumer\");\nerr_con:\n\tsysfs_remove_link(&link->link_dev.kobj, \"supplier\");\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic void devlink_remove_symlinks(struct device *dev)\n{\n\tstruct device_link *link = to_devlink(dev);\n\tsize_t len;\n\tstruct device *sup = link->supplier;\n\tstruct device *con = link->consumer;\n\tchar *buf;\n\n\tsysfs_remove_link(&link->link_dev.kobj, \"consumer\");\n\tsysfs_remove_link(&link->link_dev.kobj, \"supplier\");\n\n\tlen = max(strlen(dev_bus_name(sup)) + strlen(dev_name(sup)),\n\t\t  strlen(dev_bus_name(con)) + strlen(dev_name(con)));\n\tlen += strlen(\":\");\n\tlen += strlen(\"supplier:\") + 1;\n\tbuf = kzalloc(len, GFP_KERNEL);\n\tif (!buf) {\n\t\tWARN(1, \"Unable to properly free device link symlinks!\\n\");\n\t\treturn;\n\t}\n\n\tif (device_is_registered(con)) {\n\t\tsnprintf(buf, len, \"supplier:%s:%s\", dev_bus_name(sup), dev_name(sup));\n\t\tsysfs_remove_link(&con->kobj, buf);\n\t}\n\tsnprintf(buf, len, \"consumer:%s:%s\", dev_bus_name(con), dev_name(con));\n\tsysfs_remove_link(&sup->kobj, buf);\n\tkfree(buf);\n}\n\nstatic struct class_interface devlink_class_intf = {\n\t.class = &devlink_class,\n\t.add_dev = devlink_add_symlinks,\n\t.remove_dev = devlink_remove_symlinks,\n};\n\nstatic int __init devlink_class_init(void)\n{\n\tint ret;\n\n\tret = class_register(&devlink_class);\n\tif (ret)\n\t\treturn ret;\n\n\tret = class_interface_register(&devlink_class_intf);\n\tif (ret)\n\t\tclass_unregister(&devlink_class);\n\n\treturn ret;\n}\npostcore_initcall(devlink_class_init);\n\n#define DL_MANAGED_LINK_FLAGS (DL_FLAG_AUTOREMOVE_CONSUMER | \\\n\t\t\t       DL_FLAG_AUTOREMOVE_SUPPLIER | \\\n\t\t\t       DL_FLAG_AUTOPROBE_CONSUMER  | \\\n\t\t\t       DL_FLAG_SYNC_STATE_ONLY | \\\n\t\t\t       DL_FLAG_INFERRED | \\\n\t\t\t       DL_FLAG_CYCLE)\n\n#define DL_ADD_VALID_FLAGS (DL_MANAGED_LINK_FLAGS | DL_FLAG_STATELESS | \\\n\t\t\t    DL_FLAG_PM_RUNTIME | DL_FLAG_RPM_ACTIVE)\n\n \nstruct device_link *device_link_add(struct device *consumer,\n\t\t\t\t    struct device *supplier, u32 flags)\n{\n\tstruct device_link *link;\n\n\tif (!consumer || !supplier || consumer == supplier ||\n\t    flags & ~DL_ADD_VALID_FLAGS ||\n\t    (flags & DL_FLAG_STATELESS && flags & DL_MANAGED_LINK_FLAGS) ||\n\t    (flags & DL_FLAG_AUTOPROBE_CONSUMER &&\n\t     flags & (DL_FLAG_AUTOREMOVE_CONSUMER |\n\t\t      DL_FLAG_AUTOREMOVE_SUPPLIER)))\n\t\treturn NULL;\n\n\tif (flags & DL_FLAG_PM_RUNTIME && flags & DL_FLAG_RPM_ACTIVE) {\n\t\tif (pm_runtime_get_sync(supplier) < 0) {\n\t\t\tpm_runtime_put_noidle(supplier);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (!(flags & DL_FLAG_STATELESS))\n\t\tflags |= DL_FLAG_MANAGED;\n\n\tif (flags & DL_FLAG_SYNC_STATE_ONLY &&\n\t    !device_link_flag_is_sync_state_only(flags))\n\t\treturn NULL;\n\n\tdevice_links_write_lock();\n\tdevice_pm_lock();\n\n\t \n\tif (!device_pm_initialized(supplier)\n\t    || (!(flags & DL_FLAG_SYNC_STATE_ONLY) &&\n\t\t  device_is_dependent(consumer, supplier))) {\n\t\tlink = NULL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (flags & DL_FLAG_SYNC_STATE_ONLY &&\n\t    consumer->links.status != DL_DEV_NO_DRIVER &&\n\t    consumer->links.status != DL_DEV_PROBING) {\n\t\tlink = NULL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (flags & DL_FLAG_AUTOREMOVE_SUPPLIER)\n\t\tflags &= ~DL_FLAG_AUTOREMOVE_CONSUMER;\n\n\tlist_for_each_entry(link, &supplier->links.consumers, s_node) {\n\t\tif (link->consumer != consumer)\n\t\t\tcontinue;\n\n\t\tif (link->flags & DL_FLAG_INFERRED &&\n\t\t    !(flags & DL_FLAG_INFERRED))\n\t\t\tlink->flags &= ~DL_FLAG_INFERRED;\n\n\t\tif (flags & DL_FLAG_PM_RUNTIME) {\n\t\t\tif (!(link->flags & DL_FLAG_PM_RUNTIME)) {\n\t\t\t\tpm_runtime_new_link(consumer);\n\t\t\t\tlink->flags |= DL_FLAG_PM_RUNTIME;\n\t\t\t}\n\t\t\tif (flags & DL_FLAG_RPM_ACTIVE)\n\t\t\t\trefcount_inc(&link->rpm_active);\n\t\t}\n\n\t\tif (flags & DL_FLAG_STATELESS) {\n\t\t\tkref_get(&link->kref);\n\t\t\tif (link->flags & DL_FLAG_SYNC_STATE_ONLY &&\n\t\t\t    !(link->flags & DL_FLAG_STATELESS)) {\n\t\t\t\tlink->flags |= DL_FLAG_STATELESS;\n\t\t\t\tgoto reorder;\n\t\t\t} else {\n\t\t\t\tlink->flags |= DL_FLAG_STATELESS;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (flags & DL_FLAG_AUTOREMOVE_SUPPLIER) {\n\t\t\tif (link->flags & DL_FLAG_AUTOREMOVE_CONSUMER) {\n\t\t\t\tlink->flags &= ~DL_FLAG_AUTOREMOVE_CONSUMER;\n\t\t\t\tlink->flags |= DL_FLAG_AUTOREMOVE_SUPPLIER;\n\t\t\t}\n\t\t} else if (!(flags & DL_FLAG_AUTOREMOVE_CONSUMER)) {\n\t\t\tlink->flags &= ~(DL_FLAG_AUTOREMOVE_CONSUMER |\n\t\t\t\t\t DL_FLAG_AUTOREMOVE_SUPPLIER);\n\t\t}\n\t\tif (!(link->flags & DL_FLAG_MANAGED)) {\n\t\t\tkref_get(&link->kref);\n\t\t\tlink->flags |= DL_FLAG_MANAGED;\n\t\t\tdevice_link_init_status(link, consumer, supplier);\n\t\t}\n\t\tif (link->flags & DL_FLAG_SYNC_STATE_ONLY &&\n\t\t    !(flags & DL_FLAG_SYNC_STATE_ONLY)) {\n\t\t\tlink->flags &= ~DL_FLAG_SYNC_STATE_ONLY;\n\t\t\tgoto reorder;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\tgoto out;\n\n\trefcount_set(&link->rpm_active, 1);\n\n\tget_device(supplier);\n\tlink->supplier = supplier;\n\tINIT_LIST_HEAD(&link->s_node);\n\tget_device(consumer);\n\tlink->consumer = consumer;\n\tINIT_LIST_HEAD(&link->c_node);\n\tlink->flags = flags;\n\tkref_init(&link->kref);\n\n\tlink->link_dev.class = &devlink_class;\n\tdevice_set_pm_not_required(&link->link_dev);\n\tdev_set_name(&link->link_dev, \"%s:%s--%s:%s\",\n\t\t     dev_bus_name(supplier), dev_name(supplier),\n\t\t     dev_bus_name(consumer), dev_name(consumer));\n\tif (device_register(&link->link_dev)) {\n\t\tput_device(&link->link_dev);\n\t\tlink = NULL;\n\t\tgoto out;\n\t}\n\n\tif (flags & DL_FLAG_PM_RUNTIME) {\n\t\tif (flags & DL_FLAG_RPM_ACTIVE)\n\t\t\trefcount_inc(&link->rpm_active);\n\n\t\tpm_runtime_new_link(consumer);\n\t}\n\n\t \n\tif (flags & DL_FLAG_STATELESS)\n\t\tlink->status = DL_STATE_NONE;\n\telse\n\t\tdevice_link_init_status(link, consumer, supplier);\n\n\t \n\tif (link->status == DL_STATE_CONSUMER_PROBE &&\n\t    flags & DL_FLAG_PM_RUNTIME)\n\t\tpm_runtime_resume(supplier);\n\n\tlist_add_tail_rcu(&link->s_node, &supplier->links.consumers);\n\tlist_add_tail_rcu(&link->c_node, &consumer->links.suppliers);\n\n\tif (flags & DL_FLAG_SYNC_STATE_ONLY) {\n\t\tdev_dbg(consumer,\n\t\t\t\"Linked as a sync state only consumer to %s\\n\",\n\t\t\tdev_name(supplier));\n\t\tgoto out;\n\t}\n\nreorder:\n\t \n\tdevice_reorder_to_tail(consumer, NULL);\n\n\tdev_dbg(consumer, \"Linked as a consumer to %s\\n\", dev_name(supplier));\n\nout:\n\tdevice_pm_unlock();\n\tdevice_links_write_unlock();\n\n\tif ((flags & DL_FLAG_PM_RUNTIME && flags & DL_FLAG_RPM_ACTIVE) && !link)\n\t\tpm_runtime_put(supplier);\n\n\treturn link;\n}\nEXPORT_SYMBOL_GPL(device_link_add);\n\nstatic void __device_link_del(struct kref *kref)\n{\n\tstruct device_link *link = container_of(kref, struct device_link, kref);\n\n\tdev_dbg(link->consumer, \"Dropping the link to %s\\n\",\n\t\tdev_name(link->supplier));\n\n\tpm_runtime_drop_link(link);\n\n\tdevice_link_remove_from_lists(link);\n\tdevice_unregister(&link->link_dev);\n}\n\nstatic void device_link_put_kref(struct device_link *link)\n{\n\tif (link->flags & DL_FLAG_STATELESS)\n\t\tkref_put(&link->kref, __device_link_del);\n\telse if (!device_is_registered(link->consumer))\n\t\t__device_link_del(&link->kref);\n\telse\n\t\tWARN(1, \"Unable to drop a managed device link reference\\n\");\n}\n\n \nvoid device_link_del(struct device_link *link)\n{\n\tdevice_links_write_lock();\n\tdevice_link_put_kref(link);\n\tdevice_links_write_unlock();\n}\nEXPORT_SYMBOL_GPL(device_link_del);\n\n \nvoid device_link_remove(void *consumer, struct device *supplier)\n{\n\tstruct device_link *link;\n\n\tif (WARN_ON(consumer == supplier))\n\t\treturn;\n\n\tdevice_links_write_lock();\n\n\tlist_for_each_entry(link, &supplier->links.consumers, s_node) {\n\t\tif (link->consumer == consumer) {\n\t\t\tdevice_link_put_kref(link);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdevice_links_write_unlock();\n}\nEXPORT_SYMBOL_GPL(device_link_remove);\n\nstatic void device_links_missing_supplier(struct device *dev)\n{\n\tstruct device_link *link;\n\n\tlist_for_each_entry(link, &dev->links.suppliers, c_node) {\n\t\tif (link->status != DL_STATE_CONSUMER_PROBE)\n\t\t\tcontinue;\n\n\t\tif (link->supplier->links.status == DL_DEV_DRIVER_BOUND) {\n\t\t\tWRITE_ONCE(link->status, DL_STATE_AVAILABLE);\n\t\t} else {\n\t\t\tWARN_ON(!(link->flags & DL_FLAG_SYNC_STATE_ONLY));\n\t\t\tWRITE_ONCE(link->status, DL_STATE_DORMANT);\n\t\t}\n\t}\n}\n\nstatic bool dev_is_best_effort(struct device *dev)\n{\n\treturn (fw_devlink_best_effort && dev->can_match) ||\n\t\t(dev->fwnode && (dev->fwnode->flags & FWNODE_FLAG_BEST_EFFORT));\n}\n\nstatic struct fwnode_handle *fwnode_links_check_suppliers(\n\t\t\t\t\t\tstruct fwnode_handle *fwnode)\n{\n\tstruct fwnode_link *link;\n\n\tif (!fwnode || fw_devlink_is_permissive())\n\t\treturn NULL;\n\n\tlist_for_each_entry(link, &fwnode->suppliers, c_hook)\n\t\tif (!(link->flags & FWLINK_FLAG_CYCLE))\n\t\t\treturn link->supplier;\n\n\treturn NULL;\n}\n\n \nint device_links_check_suppliers(struct device *dev)\n{\n\tstruct device_link *link;\n\tint ret = 0, fwnode_ret = 0;\n\tstruct fwnode_handle *sup_fw;\n\n\t \n\tmutex_lock(&fwnode_link_lock);\n\tsup_fw = fwnode_links_check_suppliers(dev->fwnode);\n\tif (sup_fw) {\n\t\tif (!dev_is_best_effort(dev)) {\n\t\t\tfwnode_ret = -EPROBE_DEFER;\n\t\t\tdev_err_probe(dev, -EPROBE_DEFER,\n\t\t\t\t    \"wait for supplier %pfwf\\n\", sup_fw);\n\t\t} else {\n\t\t\tfwnode_ret = -EAGAIN;\n\t\t}\n\t}\n\tmutex_unlock(&fwnode_link_lock);\n\tif (fwnode_ret == -EPROBE_DEFER)\n\t\treturn fwnode_ret;\n\n\tdevice_links_write_lock();\n\n\tlist_for_each_entry(link, &dev->links.suppliers, c_node) {\n\t\tif (!(link->flags & DL_FLAG_MANAGED))\n\t\t\tcontinue;\n\n\t\tif (link->status != DL_STATE_AVAILABLE &&\n\t\t    !(link->flags & DL_FLAG_SYNC_STATE_ONLY)) {\n\n\t\t\tif (dev_is_best_effort(dev) &&\n\t\t\t    link->flags & DL_FLAG_INFERRED &&\n\t\t\t    !link->supplier->can_match) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdevice_links_missing_supplier(dev);\n\t\t\tdev_err_probe(dev, -EPROBE_DEFER,\n\t\t\t\t      \"supplier %s not ready\\n\",\n\t\t\t\t      dev_name(link->supplier));\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tbreak;\n\t\t}\n\t\tWRITE_ONCE(link->status, DL_STATE_CONSUMER_PROBE);\n\t}\n\tdev->links.status = DL_DEV_PROBING;\n\n\tdevice_links_write_unlock();\n\n\treturn ret ? ret : fwnode_ret;\n}\n\n \nstatic void __device_links_queue_sync_state(struct device *dev,\n\t\t\t\t\t    struct list_head *list)\n{\n\tstruct device_link *link;\n\n\tif (!dev_has_sync_state(dev))\n\t\treturn;\n\tif (dev->state_synced)\n\t\treturn;\n\n\tlist_for_each_entry(link, &dev->links.consumers, s_node) {\n\t\tif (!(link->flags & DL_FLAG_MANAGED))\n\t\t\tcontinue;\n\t\tif (link->status != DL_STATE_ACTIVE)\n\t\t\treturn;\n\t}\n\n\t \n\tdev->state_synced = true;\n\n\tif (WARN_ON(!list_empty(&dev->links.defer_sync)))\n\t\treturn;\n\n\tget_device(dev);\n\tlist_add_tail(&dev->links.defer_sync, list);\n}\n\n \nstatic void device_links_flush_sync_list(struct list_head *list,\n\t\t\t\t\t struct device *dont_lock_dev)\n{\n\tstruct device *dev, *tmp;\n\n\tlist_for_each_entry_safe(dev, tmp, list, links.defer_sync) {\n\t\tlist_del_init(&dev->links.defer_sync);\n\n\t\tif (dev != dont_lock_dev)\n\t\t\tdevice_lock(dev);\n\n\t\tdev_sync_state(dev);\n\n\t\tif (dev != dont_lock_dev)\n\t\t\tdevice_unlock(dev);\n\n\t\tput_device(dev);\n\t}\n}\n\nvoid device_links_supplier_sync_state_pause(void)\n{\n\tdevice_links_write_lock();\n\tdefer_sync_state_count++;\n\tdevice_links_write_unlock();\n}\n\nvoid device_links_supplier_sync_state_resume(void)\n{\n\tstruct device *dev, *tmp;\n\tLIST_HEAD(sync_list);\n\n\tdevice_links_write_lock();\n\tif (!defer_sync_state_count) {\n\t\tWARN(true, \"Unmatched sync_state pause/resume!\");\n\t\tgoto out;\n\t}\n\tdefer_sync_state_count--;\n\tif (defer_sync_state_count)\n\t\tgoto out;\n\n\tlist_for_each_entry_safe(dev, tmp, &deferred_sync, links.defer_sync) {\n\t\t \n\t\tlist_del_init(&dev->links.defer_sync);\n\t\t__device_links_queue_sync_state(dev, &sync_list);\n\t}\nout:\n\tdevice_links_write_unlock();\n\n\tdevice_links_flush_sync_list(&sync_list, NULL);\n}\n\nstatic int sync_state_resume_initcall(void)\n{\n\tdevice_links_supplier_sync_state_resume();\n\treturn 0;\n}\nlate_initcall(sync_state_resume_initcall);\n\nstatic void __device_links_supplier_defer_sync(struct device *sup)\n{\n\tif (list_empty(&sup->links.defer_sync) && dev_has_sync_state(sup))\n\t\tlist_add_tail(&sup->links.defer_sync, &deferred_sync);\n}\n\nstatic void device_link_drop_managed(struct device_link *link)\n{\n\tlink->flags &= ~DL_FLAG_MANAGED;\n\tWRITE_ONCE(link->status, DL_STATE_NONE);\n\tkref_put(&link->kref, __device_link_del);\n}\n\nstatic ssize_t waiting_for_supplier_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tbool val;\n\n\tdevice_lock(dev);\n\tmutex_lock(&fwnode_link_lock);\n\tval = !!fwnode_links_check_suppliers(dev->fwnode);\n\tmutex_unlock(&fwnode_link_lock);\n\tdevice_unlock(dev);\n\treturn sysfs_emit(buf, \"%u\\n\", val);\n}\nstatic DEVICE_ATTR_RO(waiting_for_supplier);\n\n \nvoid device_links_force_bind(struct device *dev)\n{\n\tstruct device_link *link, *ln;\n\n\tdevice_links_write_lock();\n\n\tlist_for_each_entry_safe(link, ln, &dev->links.suppliers, c_node) {\n\t\tif (!(link->flags & DL_FLAG_MANAGED))\n\t\t\tcontinue;\n\n\t\tif (link->status != DL_STATE_AVAILABLE) {\n\t\t\tdevice_link_drop_managed(link);\n\t\t\tcontinue;\n\t\t}\n\t\tWRITE_ONCE(link->status, DL_STATE_CONSUMER_PROBE);\n\t}\n\tdev->links.status = DL_DEV_PROBING;\n\n\tdevice_links_write_unlock();\n}\n\n \nvoid device_links_driver_bound(struct device *dev)\n{\n\tstruct device_link *link, *ln;\n\tLIST_HEAD(sync_list);\n\n\t \n\tif (dev->fwnode && dev->fwnode->dev == dev) {\n\t\tstruct fwnode_handle *child;\n\t\tfwnode_links_purge_suppliers(dev->fwnode);\n\t\tmutex_lock(&fwnode_link_lock);\n\t\tfwnode_for_each_available_child_node(dev->fwnode, child)\n\t\t\t__fw_devlink_pickup_dangling_consumers(child,\n\t\t\t\t\t\t\t       dev->fwnode);\n\t\t__fw_devlink_link_to_consumers(dev);\n\t\tmutex_unlock(&fwnode_link_lock);\n\t}\n\tdevice_remove_file(dev, &dev_attr_waiting_for_supplier);\n\n\tdevice_links_write_lock();\n\n\tlist_for_each_entry(link, &dev->links.consumers, s_node) {\n\t\tif (!(link->flags & DL_FLAG_MANAGED))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (link->status == DL_STATE_CONSUMER_PROBE ||\n\t\t    link->status == DL_STATE_ACTIVE)\n\t\t\tcontinue;\n\n\t\tWARN_ON(link->status != DL_STATE_DORMANT);\n\t\tWRITE_ONCE(link->status, DL_STATE_AVAILABLE);\n\n\t\tif (link->flags & DL_FLAG_AUTOPROBE_CONSUMER)\n\t\t\tdriver_deferred_probe_add(link->consumer);\n\t}\n\n\tif (defer_sync_state_count)\n\t\t__device_links_supplier_defer_sync(dev);\n\telse\n\t\t__device_links_queue_sync_state(dev, &sync_list);\n\n\tlist_for_each_entry_safe(link, ln, &dev->links.suppliers, c_node) {\n\t\tstruct device *supplier;\n\n\t\tif (!(link->flags & DL_FLAG_MANAGED))\n\t\t\tcontinue;\n\n\t\tsupplier = link->supplier;\n\t\tif (link->flags & DL_FLAG_SYNC_STATE_ONLY) {\n\t\t\t \n\t\t\tdevice_link_drop_managed(link);\n\t\t} else if (dev_is_best_effort(dev) &&\n\t\t\t   link->flags & DL_FLAG_INFERRED &&\n\t\t\t   link->status != DL_STATE_CONSUMER_PROBE &&\n\t\t\t   !link->supplier->can_match) {\n\t\t\t \n\t\t\tdevice_link_drop_managed(link);\n\t\t} else {\n\t\t\tWARN_ON(link->status != DL_STATE_CONSUMER_PROBE);\n\t\t\tWRITE_ONCE(link->status, DL_STATE_ACTIVE);\n\t\t}\n\n\t\t \n\t\tif (defer_sync_state_count)\n\t\t\t__device_links_supplier_defer_sync(supplier);\n\t\telse\n\t\t\t__device_links_queue_sync_state(supplier, &sync_list);\n\t}\n\n\tdev->links.status = DL_DEV_DRIVER_BOUND;\n\n\tdevice_links_write_unlock();\n\n\tdevice_links_flush_sync_list(&sync_list, dev);\n}\n\n \nstatic void __device_links_no_driver(struct device *dev)\n{\n\tstruct device_link *link, *ln;\n\n\tlist_for_each_entry_safe_reverse(link, ln, &dev->links.suppliers, c_node) {\n\t\tif (!(link->flags & DL_FLAG_MANAGED))\n\t\t\tcontinue;\n\n\t\tif (link->flags & DL_FLAG_AUTOREMOVE_CONSUMER) {\n\t\t\tdevice_link_drop_managed(link);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (link->status != DL_STATE_CONSUMER_PROBE &&\n\t\t    link->status != DL_STATE_ACTIVE)\n\t\t\tcontinue;\n\n\t\tif (link->supplier->links.status == DL_DEV_DRIVER_BOUND) {\n\t\t\tWRITE_ONCE(link->status, DL_STATE_AVAILABLE);\n\t\t} else {\n\t\t\tWARN_ON(!(link->flags & DL_FLAG_SYNC_STATE_ONLY));\n\t\t\tWRITE_ONCE(link->status, DL_STATE_DORMANT);\n\t\t}\n\t}\n\n\tdev->links.status = DL_DEV_NO_DRIVER;\n}\n\n \nvoid device_links_no_driver(struct device *dev)\n{\n\tstruct device_link *link;\n\n\tdevice_links_write_lock();\n\n\tlist_for_each_entry(link, &dev->links.consumers, s_node) {\n\t\tif (!(link->flags & DL_FLAG_MANAGED))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (link->status == DL_STATE_CONSUMER_PROBE ||\n\t\t    link->status == DL_STATE_ACTIVE)\n\t\t\tWRITE_ONCE(link->status, DL_STATE_DORMANT);\n\t}\n\n\t__device_links_no_driver(dev);\n\n\tdevice_links_write_unlock();\n}\n\n \nvoid device_links_driver_cleanup(struct device *dev)\n{\n\tstruct device_link *link, *ln;\n\n\tdevice_links_write_lock();\n\n\tlist_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {\n\t\tif (!(link->flags & DL_FLAG_MANAGED))\n\t\t\tcontinue;\n\n\t\tWARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);\n\t\tWARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);\n\n\t\t \n\t\tif (link->status == DL_STATE_SUPPLIER_UNBIND &&\n\t\t    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)\n\t\t\tdevice_link_drop_managed(link);\n\n\t\tWRITE_ONCE(link->status, DL_STATE_DORMANT);\n\t}\n\n\tlist_del_init(&dev->links.defer_sync);\n\t__device_links_no_driver(dev);\n\n\tdevice_links_write_unlock();\n}\n\n \nbool device_links_busy(struct device *dev)\n{\n\tstruct device_link *link;\n\tbool ret = false;\n\n\tdevice_links_write_lock();\n\n\tlist_for_each_entry(link, &dev->links.consumers, s_node) {\n\t\tif (!(link->flags & DL_FLAG_MANAGED))\n\t\t\tcontinue;\n\n\t\tif (link->status == DL_STATE_CONSUMER_PROBE\n\t\t    || link->status == DL_STATE_ACTIVE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t\tWRITE_ONCE(link->status, DL_STATE_SUPPLIER_UNBIND);\n\t}\n\n\tdev->links.status = DL_DEV_UNBINDING;\n\n\tdevice_links_write_unlock();\n\treturn ret;\n}\n\n \nvoid device_links_unbind_consumers(struct device *dev)\n{\n\tstruct device_link *link;\n\n start:\n\tdevice_links_write_lock();\n\n\tlist_for_each_entry(link, &dev->links.consumers, s_node) {\n\t\tenum device_link_state status;\n\n\t\tif (!(link->flags & DL_FLAG_MANAGED) ||\n\t\t    link->flags & DL_FLAG_SYNC_STATE_ONLY)\n\t\t\tcontinue;\n\n\t\tstatus = link->status;\n\t\tif (status == DL_STATE_CONSUMER_PROBE) {\n\t\t\tdevice_links_write_unlock();\n\n\t\t\twait_for_device_probe();\n\t\t\tgoto start;\n\t\t}\n\t\tWRITE_ONCE(link->status, DL_STATE_SUPPLIER_UNBIND);\n\t\tif (status == DL_STATE_ACTIVE) {\n\t\t\tstruct device *consumer = link->consumer;\n\n\t\t\tget_device(consumer);\n\n\t\t\tdevice_links_write_unlock();\n\n\t\t\tdevice_release_driver_internal(consumer, NULL,\n\t\t\t\t\t\t       consumer->parent);\n\t\t\tput_device(consumer);\n\t\t\tgoto start;\n\t\t}\n\t}\n\n\tdevice_links_write_unlock();\n}\n\n \nstatic void device_links_purge(struct device *dev)\n{\n\tstruct device_link *link, *ln;\n\n\tif (dev->class == &devlink_class)\n\t\treturn;\n\n\t \n\tdevice_links_write_lock();\n\n\tlist_for_each_entry_safe_reverse(link, ln, &dev->links.suppliers, c_node) {\n\t\tWARN_ON(link->status == DL_STATE_ACTIVE);\n\t\t__device_link_del(&link->kref);\n\t}\n\n\tlist_for_each_entry_safe_reverse(link, ln, &dev->links.consumers, s_node) {\n\t\tWARN_ON(link->status != DL_STATE_DORMANT &&\n\t\t\tlink->status != DL_STATE_NONE);\n\t\t__device_link_del(&link->kref);\n\t}\n\n\tdevice_links_write_unlock();\n}\n\n#define FW_DEVLINK_FLAGS_PERMISSIVE\t(DL_FLAG_INFERRED | \\\n\t\t\t\t\t DL_FLAG_SYNC_STATE_ONLY)\n#define FW_DEVLINK_FLAGS_ON\t\t(DL_FLAG_INFERRED | \\\n\t\t\t\t\t DL_FLAG_AUTOPROBE_CONSUMER)\n#define FW_DEVLINK_FLAGS_RPM\t\t(FW_DEVLINK_FLAGS_ON | \\\n\t\t\t\t\t DL_FLAG_PM_RUNTIME)\n\nstatic u32 fw_devlink_flags = FW_DEVLINK_FLAGS_ON;\nstatic int __init fw_devlink_setup(char *arg)\n{\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tif (strcmp(arg, \"off\") == 0) {\n\t\tfw_devlink_flags = 0;\n\t} else if (strcmp(arg, \"permissive\") == 0) {\n\t\tfw_devlink_flags = FW_DEVLINK_FLAGS_PERMISSIVE;\n\t} else if (strcmp(arg, \"on\") == 0) {\n\t\tfw_devlink_flags = FW_DEVLINK_FLAGS_ON;\n\t} else if (strcmp(arg, \"rpm\") == 0) {\n\t\tfw_devlink_flags = FW_DEVLINK_FLAGS_RPM;\n\t}\n\treturn 0;\n}\nearly_param(\"fw_devlink\", fw_devlink_setup);\n\nstatic bool fw_devlink_strict;\nstatic int __init fw_devlink_strict_setup(char *arg)\n{\n\treturn kstrtobool(arg, &fw_devlink_strict);\n}\nearly_param(\"fw_devlink.strict\", fw_devlink_strict_setup);\n\n#define FW_DEVLINK_SYNC_STATE_STRICT\t0\n#define FW_DEVLINK_SYNC_STATE_TIMEOUT\t1\n\n#ifndef CONFIG_FW_DEVLINK_SYNC_STATE_TIMEOUT\nstatic int fw_devlink_sync_state;\n#else\nstatic int fw_devlink_sync_state = FW_DEVLINK_SYNC_STATE_TIMEOUT;\n#endif\n\nstatic int __init fw_devlink_sync_state_setup(char *arg)\n{\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tif (strcmp(arg, \"strict\") == 0) {\n\t\tfw_devlink_sync_state = FW_DEVLINK_SYNC_STATE_STRICT;\n\t\treturn 0;\n\t} else if (strcmp(arg, \"timeout\") == 0) {\n\t\tfw_devlink_sync_state = FW_DEVLINK_SYNC_STATE_TIMEOUT;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\nearly_param(\"fw_devlink.sync_state\", fw_devlink_sync_state_setup);\n\nstatic inline u32 fw_devlink_get_flags(u8 fwlink_flags)\n{\n\tif (fwlink_flags & FWLINK_FLAG_CYCLE)\n\t\treturn FW_DEVLINK_FLAGS_PERMISSIVE | DL_FLAG_CYCLE;\n\n\treturn fw_devlink_flags;\n}\n\nstatic bool fw_devlink_is_permissive(void)\n{\n\treturn fw_devlink_flags == FW_DEVLINK_FLAGS_PERMISSIVE;\n}\n\nbool fw_devlink_is_strict(void)\n{\n\treturn fw_devlink_strict && !fw_devlink_is_permissive();\n}\n\nstatic void fw_devlink_parse_fwnode(struct fwnode_handle *fwnode)\n{\n\tif (fwnode->flags & FWNODE_FLAG_LINKS_ADDED)\n\t\treturn;\n\n\tfwnode_call_int_op(fwnode, add_links);\n\tfwnode->flags |= FWNODE_FLAG_LINKS_ADDED;\n}\n\nstatic void fw_devlink_parse_fwtree(struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_handle *child = NULL;\n\n\tfw_devlink_parse_fwnode(fwnode);\n\n\twhile ((child = fwnode_get_next_available_child_node(fwnode, child)))\n\t\tfw_devlink_parse_fwtree(child);\n}\n\nstatic void fw_devlink_relax_link(struct device_link *link)\n{\n\tif (!(link->flags & DL_FLAG_INFERRED))\n\t\treturn;\n\n\tif (device_link_flag_is_sync_state_only(link->flags))\n\t\treturn;\n\n\tpm_runtime_drop_link(link);\n\tlink->flags = DL_FLAG_MANAGED | FW_DEVLINK_FLAGS_PERMISSIVE;\n\tdev_dbg(link->consumer, \"Relaxing link with %s\\n\",\n\t\tdev_name(link->supplier));\n}\n\nstatic int fw_devlink_no_driver(struct device *dev, void *data)\n{\n\tstruct device_link *link = to_devlink(dev);\n\n\tif (!link->supplier->can_match)\n\t\tfw_devlink_relax_link(link);\n\n\treturn 0;\n}\n\nvoid fw_devlink_drivers_done(void)\n{\n\tfw_devlink_drv_reg_done = true;\n\tdevice_links_write_lock();\n\tclass_for_each_device(&devlink_class, NULL, NULL,\n\t\t\t      fw_devlink_no_driver);\n\tdevice_links_write_unlock();\n}\n\nstatic int fw_devlink_dev_sync_state(struct device *dev, void *data)\n{\n\tstruct device_link *link = to_devlink(dev);\n\tstruct device *sup = link->supplier;\n\n\tif (!(link->flags & DL_FLAG_MANAGED) ||\n\t    link->status == DL_STATE_ACTIVE || sup->state_synced ||\n\t    !dev_has_sync_state(sup))\n\t\treturn 0;\n\n\tif (fw_devlink_sync_state == FW_DEVLINK_SYNC_STATE_STRICT) {\n\t\tdev_warn(sup, \"sync_state() pending due to %s\\n\",\n\t\t\t dev_name(link->consumer));\n\t\treturn 0;\n\t}\n\n\tif (!list_empty(&sup->links.defer_sync))\n\t\treturn 0;\n\n\tdev_warn(sup, \"Timed out. Forcing sync_state()\\n\");\n\tsup->state_synced = true;\n\tget_device(sup);\n\tlist_add_tail(&sup->links.defer_sync, data);\n\n\treturn 0;\n}\n\nvoid fw_devlink_probing_done(void)\n{\n\tLIST_HEAD(sync_list);\n\n\tdevice_links_write_lock();\n\tclass_for_each_device(&devlink_class, NULL, &sync_list,\n\t\t\t      fw_devlink_dev_sync_state);\n\tdevice_links_write_unlock();\n\tdevice_links_flush_sync_list(&sync_list, NULL);\n}\n\n \nvoid __init wait_for_init_devices_probe(void)\n{\n\tif (!fw_devlink_flags || fw_devlink_is_permissive())\n\t\treturn;\n\n\t \n\twait_for_device_probe();\n\n\tpr_info(\"Trying to probe devices needed for running init ...\\n\");\n\tfw_devlink_best_effort = true;\n\tdriver_deferred_probe_trigger();\n\n\t \n\twait_for_device_probe();\n\tfw_devlink_best_effort = false;\n}\n\nstatic void fw_devlink_unblock_consumers(struct device *dev)\n{\n\tstruct device_link *link;\n\n\tif (!fw_devlink_flags || fw_devlink_is_permissive())\n\t\treturn;\n\n\tdevice_links_write_lock();\n\tlist_for_each_entry(link, &dev->links.consumers, s_node)\n\t\tfw_devlink_relax_link(link);\n\tdevice_links_write_unlock();\n}\n\n\nstatic bool fwnode_init_without_drv(struct fwnode_handle *fwnode)\n{\n\tstruct device *dev;\n\tbool ret;\n\n\tif (!(fwnode->flags & FWNODE_FLAG_INITIALIZED))\n\t\treturn false;\n\n\tdev = get_dev_from_fwnode(fwnode);\n\tret = !dev || dev->links.status == DL_DEV_NO_DRIVER;\n\tput_device(dev);\n\n\treturn ret;\n}\n\nstatic bool fwnode_ancestor_init_without_drv(struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_handle *parent;\n\n\tfwnode_for_each_parent_node(fwnode, parent) {\n\t\tif (fwnode_init_without_drv(parent)) {\n\t\t\tfwnode_handle_put(parent);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nstatic bool __fw_devlink_relax_cycles(struct device *con,\n\t\t\t\t struct fwnode_handle *sup_handle)\n{\n\tstruct device *sup_dev = NULL, *par_dev = NULL;\n\tstruct fwnode_link *link;\n\tstruct device_link *dev_link;\n\tbool ret = false;\n\n\tif (!sup_handle)\n\t\treturn false;\n\n\t \n\tif (sup_handle->flags & FWNODE_FLAG_VISITED)\n\t\treturn false;\n\n\tsup_handle->flags |= FWNODE_FLAG_VISITED;\n\n\tsup_dev = get_dev_from_fwnode(sup_handle);\n\n\t \n\tif (sup_dev == con) {\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sup_dev && sup_dev->links.status ==  DL_DEV_DRIVER_BOUND &&\n\t    con->links.status == DL_DEV_NO_DRIVER) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(link, &sup_handle->suppliers, c_hook) {\n\t\tif (__fw_devlink_relax_cycles(con, link->supplier)) {\n\t\t\t__fwnode_link_cycle(link);\n\t\t\tret = true;\n\t\t}\n\t}\n\n\t \n\tif (sup_dev)\n\t\tpar_dev = get_device(sup_dev->parent);\n\telse\n\t\tpar_dev = fwnode_get_next_parent_dev(sup_handle);\n\n\tif (par_dev && __fw_devlink_relax_cycles(con, par_dev->fwnode))\n\t\tret = true;\n\n\tif (!sup_dev)\n\t\tgoto out;\n\n\tlist_for_each_entry(dev_link, &sup_dev->links.suppliers, c_node) {\n\t\t \n\t\tif (device_link_flag_is_sync_state_only(dev_link->flags) &&\n\t\t    !(dev_link->flags & DL_FLAG_CYCLE))\n\t\t\tcontinue;\n\n\t\tif (__fw_devlink_relax_cycles(con,\n\t\t\t\t\t      dev_link->supplier->fwnode)) {\n\t\t\tfw_devlink_relax_link(dev_link);\n\t\t\tdev_link->flags |= DL_FLAG_CYCLE;\n\t\t\tret = true;\n\t\t}\n\t}\n\nout:\n\tsup_handle->flags &= ~FWNODE_FLAG_VISITED;\n\tput_device(sup_dev);\n\tput_device(par_dev);\n\treturn ret;\n}\n\n \nstatic int fw_devlink_create_devlink(struct device *con,\n\t\t\t\t     struct fwnode_handle *sup_handle,\n\t\t\t\t     struct fwnode_link *link)\n{\n\tstruct device *sup_dev;\n\tint ret = 0;\n\tu32 flags;\n\n\tif (con->fwnode == link->consumer)\n\t\tflags = fw_devlink_get_flags(link->flags);\n\telse\n\t\tflags = FW_DEVLINK_FLAGS_PERMISSIVE;\n\n\t \n\tif (sup_handle->flags & FWNODE_FLAG_NEEDS_CHILD_BOUND_ON_ADD &&\n\t    fwnode_is_ancestor_of(sup_handle, con->fwnode))\n\t\treturn -EINVAL;\n\n\t \n\tif (!(flags & DL_FLAG_SYNC_STATE_ONLY)) {\n\t\tdevice_links_write_lock();\n\t\tif (__fw_devlink_relax_cycles(con, sup_handle)) {\n\t\t\t__fwnode_link_cycle(link);\n\t\t\tflags = fw_devlink_get_flags(link->flags);\n\t\t\tdev_info(con, \"Fixed dependency cycle(s) with %pfwf\\n\",\n\t\t\t\t sup_handle);\n\t\t}\n\t\tdevice_links_write_unlock();\n\t}\n\n\tif (sup_handle->flags & FWNODE_FLAG_NOT_DEVICE)\n\t\tsup_dev = fwnode_get_next_parent_dev(sup_handle);\n\telse\n\t\tsup_dev = get_dev_from_fwnode(sup_handle);\n\n\tif (sup_dev) {\n\t\t \n\t\tif (sup_dev->links.status == DL_DEV_NO_DRIVER &&\n\t\t    sup_handle->flags & FWNODE_FLAG_INITIALIZED) {\n\t\t\tdev_dbg(con,\n\t\t\t\t\"Not linking %pfwf - dev might never probe\\n\",\n\t\t\t\tsup_handle);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (con != sup_dev && !device_link_add(con, sup_dev, flags)) {\n\t\t\tdev_err(con, \"Failed to create device link (0x%x) with %s\\n\",\n\t\t\t\tflags, dev_name(sup_dev));\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t \n\tif (fwnode_init_without_drv(sup_handle) ||\n\t    fwnode_ancestor_init_without_drv(sup_handle)) {\n\t\tdev_dbg(con, \"Not linking %pfwf - might never become dev\\n\",\n\t\t\tsup_handle);\n\t\treturn -EINVAL;\n\t}\n\n\tret = -EAGAIN;\nout:\n\tput_device(sup_dev);\n\treturn ret;\n}\n\n \nstatic void __fw_devlink_link_to_consumers(struct device *dev)\n{\n\tstruct fwnode_handle *fwnode = dev->fwnode;\n\tstruct fwnode_link *link, *tmp;\n\n\tlist_for_each_entry_safe(link, tmp, &fwnode->consumers, s_hook) {\n\t\tstruct device *con_dev;\n\t\tbool own_link = true;\n\t\tint ret;\n\n\t\tcon_dev = get_dev_from_fwnode(link->consumer);\n\t\t \n\t\tif (!con_dev) {\n\t\t\tcon_dev = fwnode_get_next_parent_dev(link->consumer);\n\t\t\t \n\t\t\tif (con_dev &&\n\t\t\t    fwnode_is_ancestor_of(con_dev->fwnode, fwnode)) {\n\t\t\t\tput_device(con_dev);\n\t\t\t\tcon_dev = NULL;\n\t\t\t} else {\n\t\t\t\town_link = false;\n\t\t\t}\n\t\t}\n\n\t\tif (!con_dev)\n\t\t\tcontinue;\n\n\t\tret = fw_devlink_create_devlink(con_dev, fwnode, link);\n\t\tput_device(con_dev);\n\t\tif (!own_link || ret == -EAGAIN)\n\t\t\tcontinue;\n\n\t\t__fwnode_link_del(link);\n\t}\n}\n\n \nstatic void __fw_devlink_link_to_suppliers(struct device *dev,\n\t\t\t\t\t   struct fwnode_handle *fwnode)\n{\n\tbool own_link = (dev->fwnode == fwnode);\n\tstruct fwnode_link *link, *tmp;\n\tstruct fwnode_handle *child = NULL;\n\n\tlist_for_each_entry_safe(link, tmp, &fwnode->suppliers, c_hook) {\n\t\tint ret;\n\t\tstruct fwnode_handle *sup = link->supplier;\n\n\t\tret = fw_devlink_create_devlink(dev, sup, link);\n\t\tif (!own_link || ret == -EAGAIN)\n\t\t\tcontinue;\n\n\t\t__fwnode_link_del(link);\n\t}\n\n\t \n\twhile ((child = fwnode_get_next_available_child_node(fwnode, child)))\n\t\t__fw_devlink_link_to_suppliers(dev, child);\n}\n\nstatic void fw_devlink_link_device(struct device *dev)\n{\n\tstruct fwnode_handle *fwnode = dev->fwnode;\n\n\tif (!fw_devlink_flags)\n\t\treturn;\n\n\tfw_devlink_parse_fwtree(fwnode);\n\n\tmutex_lock(&fwnode_link_lock);\n\t__fw_devlink_link_to_consumers(dev);\n\t__fw_devlink_link_to_suppliers(dev, fwnode);\n\tmutex_unlock(&fwnode_link_lock);\n}\n\n \n\nint (*platform_notify)(struct device *dev) = NULL;\nint (*platform_notify_remove)(struct device *dev) = NULL;\nstatic struct kobject *dev_kobj;\n\n \nstatic struct kobject *sysfs_dev_char_kobj;\n\n \nstatic struct kobject *sysfs_dev_block_kobj;\n\nstatic DEFINE_MUTEX(device_hotplug_lock);\n\nvoid lock_device_hotplug(void)\n{\n\tmutex_lock(&device_hotplug_lock);\n}\n\nvoid unlock_device_hotplug(void)\n{\n\tmutex_unlock(&device_hotplug_lock);\n}\n\nint lock_device_hotplug_sysfs(void)\n{\n\tif (mutex_trylock(&device_hotplug_lock))\n\t\treturn 0;\n\n\t \n\tmsleep(5);\n\treturn restart_syscall();\n}\n\n#ifdef CONFIG_BLOCK\nstatic inline int device_is_not_partition(struct device *dev)\n{\n\treturn !(dev->type == &part_type);\n}\n#else\nstatic inline int device_is_not_partition(struct device *dev)\n{\n\treturn 1;\n}\n#endif\n\nstatic void device_platform_notify(struct device *dev)\n{\n\tacpi_device_notify(dev);\n\n\tsoftware_node_notify(dev);\n\n\tif (platform_notify)\n\t\tplatform_notify(dev);\n}\n\nstatic void device_platform_notify_remove(struct device *dev)\n{\n\tif (platform_notify_remove)\n\t\tplatform_notify_remove(dev);\n\n\tsoftware_node_notify_remove(dev);\n\n\tacpi_device_notify_remove(dev);\n}\n\n \nconst char *dev_driver_string(const struct device *dev)\n{\n\tstruct device_driver *drv;\n\n\t \n\tdrv = READ_ONCE(dev->driver);\n\treturn drv ? drv->name : dev_bus_name(dev);\n}\nEXPORT_SYMBOL(dev_driver_string);\n\n#define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)\n\nstatic ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct device_attribute *dev_attr = to_dev_attr(attr);\n\tstruct device *dev = kobj_to_dev(kobj);\n\tssize_t ret = -EIO;\n\n\tif (dev_attr->show)\n\t\tret = dev_attr->show(dev, dev_attr, buf);\n\tif (ret >= (ssize_t)PAGE_SIZE) {\n\t\tprintk(\"dev_attr_show: %pS returned bad count\\n\",\n\t\t\t\tdev_attr->show);\n\t}\n\treturn ret;\n}\n\nstatic ssize_t dev_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct device_attribute *dev_attr = to_dev_attr(attr);\n\tstruct device *dev = kobj_to_dev(kobj);\n\tssize_t ret = -EIO;\n\n\tif (dev_attr->store)\n\t\tret = dev_attr->store(dev, dev_attr, buf, count);\n\treturn ret;\n}\n\nstatic const struct sysfs_ops dev_sysfs_ops = {\n\t.show\t= dev_attr_show,\n\t.store\t= dev_attr_store,\n};\n\n#define to_ext_attr(x) container_of(x, struct dev_ext_attribute, attr)\n\nssize_t device_store_ulong(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t size)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\tint ret;\n\tunsigned long new;\n\n\tret = kstrtoul(buf, 0, &new);\n\tif (ret)\n\t\treturn ret;\n\t*(unsigned long *)(ea->var) = new;\n\t \n\treturn size;\n}\nEXPORT_SYMBOL_GPL(device_store_ulong);\n\nssize_t device_show_ulong(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\treturn sysfs_emit(buf, \"%lx\\n\", *(unsigned long *)(ea->var));\n}\nEXPORT_SYMBOL_GPL(device_show_ulong);\n\nssize_t device_store_int(struct device *dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t const char *buf, size_t size)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\tint ret;\n\tlong new;\n\n\tret = kstrtol(buf, 0, &new);\n\tif (ret)\n\t\treturn ret;\n\n\tif (new > INT_MAX || new < INT_MIN)\n\t\treturn -EINVAL;\n\t*(int *)(ea->var) = new;\n\t \n\treturn size;\n}\nEXPORT_SYMBOL_GPL(device_store_int);\n\nssize_t device_show_int(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\n\treturn sysfs_emit(buf, \"%d\\n\", *(int *)(ea->var));\n}\nEXPORT_SYMBOL_GPL(device_show_int);\n\nssize_t device_store_bool(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t size)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\n\tif (kstrtobool(buf, ea->var) < 0)\n\t\treturn -EINVAL;\n\n\treturn size;\n}\nEXPORT_SYMBOL_GPL(device_store_bool);\n\nssize_t device_show_bool(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\n\treturn sysfs_emit(buf, \"%d\\n\", *(bool *)(ea->var));\n}\nEXPORT_SYMBOL_GPL(device_show_bool);\n\n \nstatic void device_release(struct kobject *kobj)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct device_private *p = dev->p;\n\n\t \n\tdevres_release_all(dev);\n\n\tkfree(dev->dma_range_map);\n\n\tif (dev->release)\n\t\tdev->release(dev);\n\telse if (dev->type && dev->type->release)\n\t\tdev->type->release(dev);\n\telse if (dev->class && dev->class->dev_release)\n\t\tdev->class->dev_release(dev);\n\telse\n\t\tWARN(1, KERN_ERR \"Device '%s' does not have a release() function, it is broken and must be fixed. See Documentation/core-api/kobject.rst.\\n\",\n\t\t\tdev_name(dev));\n\tkfree(p);\n}\n\nstatic const void *device_namespace(const struct kobject *kobj)\n{\n\tconst struct device *dev = kobj_to_dev(kobj);\n\tconst void *ns = NULL;\n\n\tif (dev->class && dev->class->ns_type)\n\t\tns = dev->class->namespace(dev);\n\n\treturn ns;\n}\n\nstatic void device_get_ownership(const struct kobject *kobj, kuid_t *uid, kgid_t *gid)\n{\n\tconst struct device *dev = kobj_to_dev(kobj);\n\n\tif (dev->class && dev->class->get_ownership)\n\t\tdev->class->get_ownership(dev, uid, gid);\n}\n\nstatic const struct kobj_type device_ktype = {\n\t.release\t= device_release,\n\t.sysfs_ops\t= &dev_sysfs_ops,\n\t.namespace\t= device_namespace,\n\t.get_ownership\t= device_get_ownership,\n};\n\n\nstatic int dev_uevent_filter(const struct kobject *kobj)\n{\n\tconst struct kobj_type *ktype = get_ktype(kobj);\n\n\tif (ktype == &device_ktype) {\n\t\tconst struct device *dev = kobj_to_dev(kobj);\n\t\tif (dev->bus)\n\t\t\treturn 1;\n\t\tif (dev->class)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic const char *dev_uevent_name(const struct kobject *kobj)\n{\n\tconst struct device *dev = kobj_to_dev(kobj);\n\n\tif (dev->bus)\n\t\treturn dev->bus->name;\n\tif (dev->class)\n\t\treturn dev->class->name;\n\treturn NULL;\n}\n\nstatic int dev_uevent(const struct kobject *kobj, struct kobj_uevent_env *env)\n{\n\tconst struct device *dev = kobj_to_dev(kobj);\n\tint retval = 0;\n\n\t \n\tif (MAJOR(dev->devt)) {\n\t\tconst char *tmp;\n\t\tconst char *name;\n\t\tumode_t mode = 0;\n\t\tkuid_t uid = GLOBAL_ROOT_UID;\n\t\tkgid_t gid = GLOBAL_ROOT_GID;\n\n\t\tadd_uevent_var(env, \"MAJOR=%u\", MAJOR(dev->devt));\n\t\tadd_uevent_var(env, \"MINOR=%u\", MINOR(dev->devt));\n\t\tname = device_get_devnode(dev, &mode, &uid, &gid, &tmp);\n\t\tif (name) {\n\t\t\tadd_uevent_var(env, \"DEVNAME=%s\", name);\n\t\t\tif (mode)\n\t\t\t\tadd_uevent_var(env, \"DEVMODE=%#o\", mode & 0777);\n\t\t\tif (!uid_eq(uid, GLOBAL_ROOT_UID))\n\t\t\t\tadd_uevent_var(env, \"DEVUID=%u\", from_kuid(&init_user_ns, uid));\n\t\t\tif (!gid_eq(gid, GLOBAL_ROOT_GID))\n\t\t\t\tadd_uevent_var(env, \"DEVGID=%u\", from_kgid(&init_user_ns, gid));\n\t\t\tkfree(tmp);\n\t\t}\n\t}\n\n\tif (dev->type && dev->type->name)\n\t\tadd_uevent_var(env, \"DEVTYPE=%s\", dev->type->name);\n\n\tif (dev->driver)\n\t\tadd_uevent_var(env, \"DRIVER=%s\", dev->driver->name);\n\n\t \n\tof_device_uevent(dev, env);\n\n\t \n\tif (dev->bus && dev->bus->uevent) {\n\t\tretval = dev->bus->uevent(dev, env);\n\t\tif (retval)\n\t\t\tpr_debug(\"device: '%s': %s: bus uevent() returned %d\\n\",\n\t\t\t\t dev_name(dev), __func__, retval);\n\t}\n\n\t \n\tif (dev->class && dev->class->dev_uevent) {\n\t\tretval = dev->class->dev_uevent(dev, env);\n\t\tif (retval)\n\t\t\tpr_debug(\"device: '%s': %s: class uevent() \"\n\t\t\t\t \"returned %d\\n\", dev_name(dev),\n\t\t\t\t __func__, retval);\n\t}\n\n\t \n\tif (dev->type && dev->type->uevent) {\n\t\tretval = dev->type->uevent(dev, env);\n\t\tif (retval)\n\t\t\tpr_debug(\"device: '%s': %s: dev_type uevent() \"\n\t\t\t\t \"returned %d\\n\", dev_name(dev),\n\t\t\t\t __func__, retval);\n\t}\n\n\treturn retval;\n}\n\nstatic const struct kset_uevent_ops device_uevent_ops = {\n\t.filter =\tdev_uevent_filter,\n\t.name =\t\tdev_uevent_name,\n\t.uevent =\tdev_uevent,\n};\n\nstatic ssize_t uevent_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct kobject *top_kobj;\n\tstruct kset *kset;\n\tstruct kobj_uevent_env *env = NULL;\n\tint i;\n\tint len = 0;\n\tint retval;\n\n\t \n\ttop_kobj = &dev->kobj;\n\twhile (!top_kobj->kset && top_kobj->parent)\n\t\ttop_kobj = top_kobj->parent;\n\tif (!top_kobj->kset)\n\t\tgoto out;\n\n\tkset = top_kobj->kset;\n\tif (!kset->uevent_ops || !kset->uevent_ops->uevent)\n\t\tgoto out;\n\n\t \n\tif (kset->uevent_ops && kset->uevent_ops->filter)\n\t\tif (!kset->uevent_ops->filter(&dev->kobj))\n\t\t\tgoto out;\n\n\tenv = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\n\t \n\tretval = kset->uevent_ops->uevent(&dev->kobj, env);\n\tif (retval)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < env->envp_idx; i++)\n\t\tlen += sysfs_emit_at(buf, len, \"%s\\n\", env->envp[i]);\nout:\n\tkfree(env);\n\treturn len;\n}\n\nstatic ssize_t uevent_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint rc;\n\n\trc = kobject_synth_uevent(&dev->kobj, buf, count);\n\n\tif (rc) {\n\t\tdev_err(dev, \"uevent: failed to send synthetic uevent: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(uevent);\n\nstatic ssize_t online_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tbool val;\n\n\tdevice_lock(dev);\n\tval = !dev->offline;\n\tdevice_unlock(dev);\n\treturn sysfs_emit(buf, \"%u\\n\", val);\n}\n\nstatic ssize_t online_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tbool val;\n\tint ret;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lock_device_hotplug_sysfs();\n\tif (ret)\n\t\treturn ret;\n\n\tret = val ? device_online(dev) : device_offline(dev);\n\tunlock_device_hotplug();\n\treturn ret < 0 ? ret : count;\n}\nstatic DEVICE_ATTR_RW(online);\n\nstatic ssize_t removable_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tconst char *loc;\n\n\tswitch (dev->removable) {\n\tcase DEVICE_REMOVABLE:\n\t\tloc = \"removable\";\n\t\tbreak;\n\tcase DEVICE_FIXED:\n\t\tloc = \"fixed\";\n\t\tbreak;\n\tdefault:\n\t\tloc = \"unknown\";\n\t}\n\treturn sysfs_emit(buf, \"%s\\n\", loc);\n}\nstatic DEVICE_ATTR_RO(removable);\n\nint device_add_groups(struct device *dev, const struct attribute_group **groups)\n{\n\treturn sysfs_create_groups(&dev->kobj, groups);\n}\nEXPORT_SYMBOL_GPL(device_add_groups);\n\nvoid device_remove_groups(struct device *dev,\n\t\t\t  const struct attribute_group **groups)\n{\n\tsysfs_remove_groups(&dev->kobj, groups);\n}\nEXPORT_SYMBOL_GPL(device_remove_groups);\n\nunion device_attr_group_devres {\n\tconst struct attribute_group *group;\n\tconst struct attribute_group **groups;\n};\n\nstatic void devm_attr_group_remove(struct device *dev, void *res)\n{\n\tunion device_attr_group_devres *devres = res;\n\tconst struct attribute_group *group = devres->group;\n\n\tdev_dbg(dev, \"%s: removing group %p\\n\", __func__, group);\n\tsysfs_remove_group(&dev->kobj, group);\n}\n\nstatic void devm_attr_groups_remove(struct device *dev, void *res)\n{\n\tunion device_attr_group_devres *devres = res;\n\tconst struct attribute_group **groups = devres->groups;\n\n\tdev_dbg(dev, \"%s: removing groups %p\\n\", __func__, groups);\n\tsysfs_remove_groups(&dev->kobj, groups);\n}\n\n \nint devm_device_add_group(struct device *dev, const struct attribute_group *grp)\n{\n\tunion device_attr_group_devres *devres;\n\tint error;\n\n\tdevres = devres_alloc(devm_attr_group_remove,\n\t\t\t      sizeof(*devres), GFP_KERNEL);\n\tif (!devres)\n\t\treturn -ENOMEM;\n\n\terror = sysfs_create_group(&dev->kobj, grp);\n\tif (error) {\n\t\tdevres_free(devres);\n\t\treturn error;\n\t}\n\n\tdevres->group = grp;\n\tdevres_add(dev, devres);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_device_add_group);\n\n \nint devm_device_add_groups(struct device *dev,\n\t\t\t   const struct attribute_group **groups)\n{\n\tunion device_attr_group_devres *devres;\n\tint error;\n\n\tdevres = devres_alloc(devm_attr_groups_remove,\n\t\t\t      sizeof(*devres), GFP_KERNEL);\n\tif (!devres)\n\t\treturn -ENOMEM;\n\n\terror = sysfs_create_groups(&dev->kobj, groups);\n\tif (error) {\n\t\tdevres_free(devres);\n\t\treturn error;\n\t}\n\n\tdevres->groups = groups;\n\tdevres_add(dev, devres);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_device_add_groups);\n\nstatic int device_add_attrs(struct device *dev)\n{\n\tconst struct class *class = dev->class;\n\tconst struct device_type *type = dev->type;\n\tint error;\n\n\tif (class) {\n\t\terror = device_add_groups(dev, class->dev_groups);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (type) {\n\t\terror = device_add_groups(dev, type->groups);\n\t\tif (error)\n\t\t\tgoto err_remove_class_groups;\n\t}\n\n\terror = device_add_groups(dev, dev->groups);\n\tif (error)\n\t\tgoto err_remove_type_groups;\n\n\tif (device_supports_offline(dev) && !dev->offline_disabled) {\n\t\terror = device_create_file(dev, &dev_attr_online);\n\t\tif (error)\n\t\t\tgoto err_remove_dev_groups;\n\t}\n\n\tif (fw_devlink_flags && !fw_devlink_is_permissive() && dev->fwnode) {\n\t\terror = device_create_file(dev, &dev_attr_waiting_for_supplier);\n\t\tif (error)\n\t\t\tgoto err_remove_dev_online;\n\t}\n\n\tif (dev_removable_is_valid(dev)) {\n\t\terror = device_create_file(dev, &dev_attr_removable);\n\t\tif (error)\n\t\t\tgoto err_remove_dev_waiting_for_supplier;\n\t}\n\n\tif (dev_add_physical_location(dev)) {\n\t\terror = device_add_group(dev,\n\t\t\t&dev_attr_physical_location_group);\n\t\tif (error)\n\t\t\tgoto err_remove_dev_removable;\n\t}\n\n\treturn 0;\n\n err_remove_dev_removable:\n\tdevice_remove_file(dev, &dev_attr_removable);\n err_remove_dev_waiting_for_supplier:\n\tdevice_remove_file(dev, &dev_attr_waiting_for_supplier);\n err_remove_dev_online:\n\tdevice_remove_file(dev, &dev_attr_online);\n err_remove_dev_groups:\n\tdevice_remove_groups(dev, dev->groups);\n err_remove_type_groups:\n\tif (type)\n\t\tdevice_remove_groups(dev, type->groups);\n err_remove_class_groups:\n\tif (class)\n\t\tdevice_remove_groups(dev, class->dev_groups);\n\n\treturn error;\n}\n\nstatic void device_remove_attrs(struct device *dev)\n{\n\tconst struct class *class = dev->class;\n\tconst struct device_type *type = dev->type;\n\n\tif (dev->physical_location) {\n\t\tdevice_remove_group(dev, &dev_attr_physical_location_group);\n\t\tkfree(dev->physical_location);\n\t}\n\n\tdevice_remove_file(dev, &dev_attr_removable);\n\tdevice_remove_file(dev, &dev_attr_waiting_for_supplier);\n\tdevice_remove_file(dev, &dev_attr_online);\n\tdevice_remove_groups(dev, dev->groups);\n\n\tif (type)\n\t\tdevice_remove_groups(dev, type->groups);\n\n\tif (class)\n\t\tdevice_remove_groups(dev, class->dev_groups);\n}\n\nstatic ssize_t dev_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\treturn print_dev_t(buf, dev->devt);\n}\nstatic DEVICE_ATTR_RO(dev);\n\n \nstruct kset *devices_kset;\n\n \nstatic void devices_kset_move_before(struct device *deva, struct device *devb)\n{\n\tif (!devices_kset)\n\t\treturn;\n\tpr_debug(\"devices_kset: Moving %s before %s\\n\",\n\t\t dev_name(deva), dev_name(devb));\n\tspin_lock(&devices_kset->list_lock);\n\tlist_move_tail(&deva->kobj.entry, &devb->kobj.entry);\n\tspin_unlock(&devices_kset->list_lock);\n}\n\n \nstatic void devices_kset_move_after(struct device *deva, struct device *devb)\n{\n\tif (!devices_kset)\n\t\treturn;\n\tpr_debug(\"devices_kset: Moving %s after %s\\n\",\n\t\t dev_name(deva), dev_name(devb));\n\tspin_lock(&devices_kset->list_lock);\n\tlist_move(&deva->kobj.entry, &devb->kobj.entry);\n\tspin_unlock(&devices_kset->list_lock);\n}\n\n \nvoid devices_kset_move_last(struct device *dev)\n{\n\tif (!devices_kset)\n\t\treturn;\n\tpr_debug(\"devices_kset: Moving %s to end of list\\n\", dev_name(dev));\n\tspin_lock(&devices_kset->list_lock);\n\tlist_move_tail(&dev->kobj.entry, &devices_kset->list);\n\tspin_unlock(&devices_kset->list_lock);\n}\n\n \nint device_create_file(struct device *dev,\n\t\t       const struct device_attribute *attr)\n{\n\tint error = 0;\n\n\tif (dev) {\n\t\tWARN(((attr->attr.mode & S_IWUGO) && !attr->store),\n\t\t\t\"Attribute %s: write permission without 'store'\\n\",\n\t\t\tattr->attr.name);\n\t\tWARN(((attr->attr.mode & S_IRUGO) && !attr->show),\n\t\t\t\"Attribute %s: read permission without 'show'\\n\",\n\t\t\tattr->attr.name);\n\t\terror = sysfs_create_file(&dev->kobj, &attr->attr);\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(device_create_file);\n\n \nvoid device_remove_file(struct device *dev,\n\t\t\tconst struct device_attribute *attr)\n{\n\tif (dev)\n\t\tsysfs_remove_file(&dev->kobj, &attr->attr);\n}\nEXPORT_SYMBOL_GPL(device_remove_file);\n\n \nbool device_remove_file_self(struct device *dev,\n\t\t\t     const struct device_attribute *attr)\n{\n\tif (dev)\n\t\treturn sysfs_remove_file_self(&dev->kobj, &attr->attr);\n\telse\n\t\treturn false;\n}\nEXPORT_SYMBOL_GPL(device_remove_file_self);\n\n \nint device_create_bin_file(struct device *dev,\n\t\t\t   const struct bin_attribute *attr)\n{\n\tint error = -EINVAL;\n\tif (dev)\n\t\terror = sysfs_create_bin_file(&dev->kobj, attr);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(device_create_bin_file);\n\n \nvoid device_remove_bin_file(struct device *dev,\n\t\t\t    const struct bin_attribute *attr)\n{\n\tif (dev)\n\t\tsysfs_remove_bin_file(&dev->kobj, attr);\n}\nEXPORT_SYMBOL_GPL(device_remove_bin_file);\n\nstatic void klist_children_get(struct klist_node *n)\n{\n\tstruct device_private *p = to_device_private_parent(n);\n\tstruct device *dev = p->device;\n\n\tget_device(dev);\n}\n\nstatic void klist_children_put(struct klist_node *n)\n{\n\tstruct device_private *p = to_device_private_parent(n);\n\tstruct device *dev = p->device;\n\n\tput_device(dev);\n}\n\n \nvoid device_initialize(struct device *dev)\n{\n\tdev->kobj.kset = devices_kset;\n\tkobject_init(&dev->kobj, &device_ktype);\n\tINIT_LIST_HEAD(&dev->dma_pools);\n\tmutex_init(&dev->mutex);\n\tlockdep_set_novalidate_class(&dev->mutex);\n\tspin_lock_init(&dev->devres_lock);\n\tINIT_LIST_HEAD(&dev->devres_head);\n\tdevice_pm_init(dev);\n\tset_dev_node(dev, NUMA_NO_NODE);\n\tINIT_LIST_HEAD(&dev->links.consumers);\n\tINIT_LIST_HEAD(&dev->links.suppliers);\n\tINIT_LIST_HEAD(&dev->links.defer_sync);\n\tdev->links.status = DL_DEV_NO_DRIVER;\n#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \\\n    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \\\n    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)\n\tdev->dma_coherent = dma_default_coherent;\n#endif\n\tswiotlb_dev_init(dev);\n}\nEXPORT_SYMBOL_GPL(device_initialize);\n\nstruct kobject *virtual_device_parent(struct device *dev)\n{\n\tstatic struct kobject *virtual_dir = NULL;\n\n\tif (!virtual_dir)\n\t\tvirtual_dir = kobject_create_and_add(\"virtual\",\n\t\t\t\t\t\t     &devices_kset->kobj);\n\n\treturn virtual_dir;\n}\n\nstruct class_dir {\n\tstruct kobject kobj;\n\tconst struct class *class;\n};\n\n#define to_class_dir(obj) container_of(obj, struct class_dir, kobj)\n\nstatic void class_dir_release(struct kobject *kobj)\n{\n\tstruct class_dir *dir = to_class_dir(kobj);\n\tkfree(dir);\n}\n\nstatic const\nstruct kobj_ns_type_operations *class_dir_child_ns_type(const struct kobject *kobj)\n{\n\tconst struct class_dir *dir = to_class_dir(kobj);\n\treturn dir->class->ns_type;\n}\n\nstatic const struct kobj_type class_dir_ktype = {\n\t.release\t= class_dir_release,\n\t.sysfs_ops\t= &kobj_sysfs_ops,\n\t.child_ns_type\t= class_dir_child_ns_type\n};\n\nstatic struct kobject *class_dir_create_and_add(struct subsys_private *sp,\n\t\t\t\t\t\tstruct kobject *parent_kobj)\n{\n\tstruct class_dir *dir;\n\tint retval;\n\n\tdir = kzalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdir->class = sp->class;\n\tkobject_init(&dir->kobj, &class_dir_ktype);\n\n\tdir->kobj.kset = &sp->glue_dirs;\n\n\tretval = kobject_add(&dir->kobj, parent_kobj, \"%s\", sp->class->name);\n\tif (retval < 0) {\n\t\tkobject_put(&dir->kobj);\n\t\treturn ERR_PTR(retval);\n\t}\n\treturn &dir->kobj;\n}\n\nstatic DEFINE_MUTEX(gdp_mutex);\n\nstatic struct kobject *get_device_parent(struct device *dev,\n\t\t\t\t\t struct device *parent)\n{\n\tstruct subsys_private *sp = class_to_subsys(dev->class);\n\tstruct kobject *kobj = NULL;\n\n\tif (sp) {\n\t\tstruct kobject *parent_kobj;\n\t\tstruct kobject *k;\n\n\t\t \n\t\tif (parent == NULL)\n\t\t\tparent_kobj = virtual_device_parent(dev);\n\t\telse if (parent->class && !dev->class->ns_type) {\n\t\t\tsubsys_put(sp);\n\t\t\treturn &parent->kobj;\n\t\t} else {\n\t\t\tparent_kobj = &parent->kobj;\n\t\t}\n\n\t\tmutex_lock(&gdp_mutex);\n\n\t\t \n\t\tspin_lock(&sp->glue_dirs.list_lock);\n\t\tlist_for_each_entry(k, &sp->glue_dirs.list, entry)\n\t\t\tif (k->parent == parent_kobj) {\n\t\t\t\tkobj = kobject_get(k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tspin_unlock(&sp->glue_dirs.list_lock);\n\t\tif (kobj) {\n\t\t\tmutex_unlock(&gdp_mutex);\n\t\t\tsubsys_put(sp);\n\t\t\treturn kobj;\n\t\t}\n\n\t\t \n\t\tk = class_dir_create_and_add(sp, parent_kobj);\n\t\t \n\t\tmutex_unlock(&gdp_mutex);\n\t\tsubsys_put(sp);\n\t\treturn k;\n\t}\n\n\t \n\tif (!parent && dev->bus) {\n\t\tstruct device *dev_root = bus_get_dev_root(dev->bus);\n\n\t\tif (dev_root) {\n\t\t\tkobj = &dev_root->kobj;\n\t\t\tput_device(dev_root);\n\t\t\treturn kobj;\n\t\t}\n\t}\n\n\tif (parent)\n\t\treturn &parent->kobj;\n\treturn NULL;\n}\n\nstatic inline bool live_in_glue_dir(struct kobject *kobj,\n\t\t\t\t    struct device *dev)\n{\n\tstruct subsys_private *sp;\n\tbool retval;\n\n\tif (!kobj || !dev->class)\n\t\treturn false;\n\n\tsp = class_to_subsys(dev->class);\n\tif (!sp)\n\t\treturn false;\n\n\tif (kobj->kset == &sp->glue_dirs)\n\t\tretval = true;\n\telse\n\t\tretval = false;\n\n\tsubsys_put(sp);\n\treturn retval;\n}\n\nstatic inline struct kobject *get_glue_dir(struct device *dev)\n{\n\treturn dev->kobj.parent;\n}\n\n \nstatic inline bool kobject_has_children(struct kobject *kobj)\n{\n\tWARN_ON_ONCE(kref_read(&kobj->kref) == 0);\n\n\treturn kobj->sd && kobj->sd->dir.subdirs;\n}\n\n \nstatic void cleanup_glue_dir(struct device *dev, struct kobject *glue_dir)\n{\n\tunsigned int ref;\n\n\t \n\tif (!live_in_glue_dir(glue_dir, dev))\n\t\treturn;\n\n\tmutex_lock(&gdp_mutex);\n\t \n\tref = kref_read(&glue_dir->kref);\n\tif (!kobject_has_children(glue_dir) && !--ref)\n\t\tkobject_del(glue_dir);\n\tkobject_put(glue_dir);\n\tmutex_unlock(&gdp_mutex);\n}\n\nstatic int device_add_class_symlinks(struct device *dev)\n{\n\tstruct device_node *of_node = dev_of_node(dev);\n\tstruct subsys_private *sp;\n\tint error;\n\n\tif (of_node) {\n\t\terror = sysfs_create_link(&dev->kobj, of_node_kobj(of_node), \"of_node\");\n\t\tif (error)\n\t\t\tdev_warn(dev, \"Error %d creating of_node link\\n\",error);\n\t\t \n\t}\n\n\tsp = class_to_subsys(dev->class);\n\tif (!sp)\n\t\treturn 0;\n\n\terror = sysfs_create_link(&dev->kobj, &sp->subsys.kobj, \"subsystem\");\n\tif (error)\n\t\tgoto out_devnode;\n\n\tif (dev->parent && device_is_not_partition(dev)) {\n\t\terror = sysfs_create_link(&dev->kobj, &dev->parent->kobj,\n\t\t\t\t\t  \"device\");\n\t\tif (error)\n\t\t\tgoto out_subsys;\n\t}\n\n\t \n\terror = sysfs_create_link(&sp->subsys.kobj, &dev->kobj, dev_name(dev));\n\tif (error)\n\t\tgoto out_device;\n\tgoto exit;\n\nout_device:\n\tsysfs_remove_link(&dev->kobj, \"device\");\nout_subsys:\n\tsysfs_remove_link(&dev->kobj, \"subsystem\");\nout_devnode:\n\tsysfs_remove_link(&dev->kobj, \"of_node\");\nexit:\n\tsubsys_put(sp);\n\treturn error;\n}\n\nstatic void device_remove_class_symlinks(struct device *dev)\n{\n\tstruct subsys_private *sp = class_to_subsys(dev->class);\n\n\tif (dev_of_node(dev))\n\t\tsysfs_remove_link(&dev->kobj, \"of_node\");\n\n\tif (!sp)\n\t\treturn;\n\n\tif (dev->parent && device_is_not_partition(dev))\n\t\tsysfs_remove_link(&dev->kobj, \"device\");\n\tsysfs_remove_link(&dev->kobj, \"subsystem\");\n\tsysfs_delete_link(&sp->subsys.kobj, &dev->kobj, dev_name(dev));\n\tsubsys_put(sp);\n}\n\n \nint dev_set_name(struct device *dev, const char *fmt, ...)\n{\n\tva_list vargs;\n\tint err;\n\n\tva_start(vargs, fmt);\n\terr = kobject_set_name_vargs(&dev->kobj, fmt, vargs);\n\tva_end(vargs);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(dev_set_name);\n\n \nstatic struct kobject *device_to_dev_kobj(struct device *dev)\n{\n\tif (is_blockdev(dev))\n\t\treturn sysfs_dev_block_kobj;\n\telse\n\t\treturn sysfs_dev_char_kobj;\n}\n\nstatic int device_create_sys_dev_entry(struct device *dev)\n{\n\tstruct kobject *kobj = device_to_dev_kobj(dev);\n\tint error = 0;\n\tchar devt_str[15];\n\n\tif (kobj) {\n\t\tformat_dev_t(devt_str, dev->devt);\n\t\terror = sysfs_create_link(kobj, &dev->kobj, devt_str);\n\t}\n\n\treturn error;\n}\n\nstatic void device_remove_sys_dev_entry(struct device *dev)\n{\n\tstruct kobject *kobj = device_to_dev_kobj(dev);\n\tchar devt_str[15];\n\n\tif (kobj) {\n\t\tformat_dev_t(devt_str, dev->devt);\n\t\tsysfs_remove_link(kobj, devt_str);\n\t}\n}\n\nstatic int device_private_init(struct device *dev)\n{\n\tdev->p = kzalloc(sizeof(*dev->p), GFP_KERNEL);\n\tif (!dev->p)\n\t\treturn -ENOMEM;\n\tdev->p->device = dev;\n\tklist_init(&dev->p->klist_children, klist_children_get,\n\t\t   klist_children_put);\n\tINIT_LIST_HEAD(&dev->p->deferred_probe);\n\treturn 0;\n}\n\n \nint device_add(struct device *dev)\n{\n\tstruct subsys_private *sp;\n\tstruct device *parent;\n\tstruct kobject *kobj;\n\tstruct class_interface *class_intf;\n\tint error = -EINVAL;\n\tstruct kobject *glue_dir = NULL;\n\n\tdev = get_device(dev);\n\tif (!dev)\n\t\tgoto done;\n\n\tif (!dev->p) {\n\t\terror = device_private_init(dev);\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t \n\tif (dev->init_name) {\n\t\terror = dev_set_name(dev, \"%s\", dev->init_name);\n\t\tdev->init_name = NULL;\n\t}\n\n\tif (dev_name(dev))\n\t\terror = 0;\n\t \n\telse if (dev->bus && dev->bus->dev_name)\n\t\terror = dev_set_name(dev, \"%s%u\", dev->bus->dev_name, dev->id);\n\telse\n\t\terror = -EINVAL;\n\tif (error)\n\t\tgoto name_error;\n\n\tpr_debug(\"device: '%s': %s\\n\", dev_name(dev), __func__);\n\n\tparent = get_device(dev->parent);\n\tkobj = get_device_parent(dev, parent);\n\tif (IS_ERR(kobj)) {\n\t\terror = PTR_ERR(kobj);\n\t\tgoto parent_error;\n\t}\n\tif (kobj)\n\t\tdev->kobj.parent = kobj;\n\n\t \n\tif (parent && (dev_to_node(dev) == NUMA_NO_NODE))\n\t\tset_dev_node(dev, dev_to_node(parent));\n\n\t \n\t \n\terror = kobject_add(&dev->kobj, dev->kobj.parent, NULL);\n\tif (error) {\n\t\tglue_dir = kobj;\n\t\tgoto Error;\n\t}\n\n\t \n\tdevice_platform_notify(dev);\n\n\terror = device_create_file(dev, &dev_attr_uevent);\n\tif (error)\n\t\tgoto attrError;\n\n\terror = device_add_class_symlinks(dev);\n\tif (error)\n\t\tgoto SymlinkError;\n\terror = device_add_attrs(dev);\n\tif (error)\n\t\tgoto AttrsError;\n\terror = bus_add_device(dev);\n\tif (error)\n\t\tgoto BusError;\n\terror = dpm_sysfs_add(dev);\n\tif (error)\n\t\tgoto DPMError;\n\tdevice_pm_add(dev);\n\n\tif (MAJOR(dev->devt)) {\n\t\terror = device_create_file(dev, &dev_attr_dev);\n\t\tif (error)\n\t\t\tgoto DevAttrError;\n\n\t\terror = device_create_sys_dev_entry(dev);\n\t\tif (error)\n\t\t\tgoto SysEntryError;\n\n\t\tdevtmpfs_create_node(dev);\n\t}\n\n\t \n\tbus_notify(dev, BUS_NOTIFY_ADD_DEVICE);\n\tkobject_uevent(&dev->kobj, KOBJ_ADD);\n\n\t \n\tif (dev->fwnode && !dev->fwnode->dev) {\n\t\tdev->fwnode->dev = dev;\n\t\tfw_devlink_link_device(dev);\n\t}\n\n\tbus_probe_device(dev);\n\n\t \n\tif (dev->fwnode && fw_devlink_drv_reg_done && !dev->can_match)\n\t\tfw_devlink_unblock_consumers(dev);\n\n\tif (parent)\n\t\tklist_add_tail(&dev->p->knode_parent,\n\t\t\t       &parent->p->klist_children);\n\n\tsp = class_to_subsys(dev->class);\n\tif (sp) {\n\t\tmutex_lock(&sp->mutex);\n\t\t \n\t\tklist_add_tail(&dev->p->knode_class, &sp->klist_devices);\n\n\t\t \n\t\tlist_for_each_entry(class_intf, &sp->interfaces, node)\n\t\t\tif (class_intf->add_dev)\n\t\t\t\tclass_intf->add_dev(dev);\n\t\tmutex_unlock(&sp->mutex);\n\t\tsubsys_put(sp);\n\t}\ndone:\n\tput_device(dev);\n\treturn error;\n SysEntryError:\n\tif (MAJOR(dev->devt))\n\t\tdevice_remove_file(dev, &dev_attr_dev);\n DevAttrError:\n\tdevice_pm_remove(dev);\n\tdpm_sysfs_remove(dev);\n DPMError:\n\tdev->driver = NULL;\n\tbus_remove_device(dev);\n BusError:\n\tdevice_remove_attrs(dev);\n AttrsError:\n\tdevice_remove_class_symlinks(dev);\n SymlinkError:\n\tdevice_remove_file(dev, &dev_attr_uevent);\n attrError:\n\tdevice_platform_notify_remove(dev);\n\tkobject_uevent(&dev->kobj, KOBJ_REMOVE);\n\tglue_dir = get_glue_dir(dev);\n\tkobject_del(&dev->kobj);\n Error:\n\tcleanup_glue_dir(dev, glue_dir);\nparent_error:\n\tput_device(parent);\nname_error:\n\tkfree(dev->p);\n\tdev->p = NULL;\n\tgoto done;\n}\nEXPORT_SYMBOL_GPL(device_add);\n\n \nint device_register(struct device *dev)\n{\n\tdevice_initialize(dev);\n\treturn device_add(dev);\n}\nEXPORT_SYMBOL_GPL(device_register);\n\n \nstruct device *get_device(struct device *dev)\n{\n\treturn dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;\n}\nEXPORT_SYMBOL_GPL(get_device);\n\n \nvoid put_device(struct device *dev)\n{\n\t \n\tif (dev)\n\t\tkobject_put(&dev->kobj);\n}\nEXPORT_SYMBOL_GPL(put_device);\n\nbool kill_device(struct device *dev)\n{\n\t \n\tdevice_lock_assert(dev);\n\n\tif (dev->p->dead)\n\t\treturn false;\n\tdev->p->dead = true;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(kill_device);\n\n \nvoid device_del(struct device *dev)\n{\n\tstruct subsys_private *sp;\n\tstruct device *parent = dev->parent;\n\tstruct kobject *glue_dir = NULL;\n\tstruct class_interface *class_intf;\n\tunsigned int noio_flag;\n\n\tdevice_lock(dev);\n\tkill_device(dev);\n\tdevice_unlock(dev);\n\n\tif (dev->fwnode && dev->fwnode->dev == dev)\n\t\tdev->fwnode->dev = NULL;\n\n\t \n\tnoio_flag = memalloc_noio_save();\n\tbus_notify(dev, BUS_NOTIFY_DEL_DEVICE);\n\n\tdpm_sysfs_remove(dev);\n\tif (parent)\n\t\tklist_del(&dev->p->knode_parent);\n\tif (MAJOR(dev->devt)) {\n\t\tdevtmpfs_delete_node(dev);\n\t\tdevice_remove_sys_dev_entry(dev);\n\t\tdevice_remove_file(dev, &dev_attr_dev);\n\t}\n\n\tsp = class_to_subsys(dev->class);\n\tif (sp) {\n\t\tdevice_remove_class_symlinks(dev);\n\n\t\tmutex_lock(&sp->mutex);\n\t\t \n\t\tlist_for_each_entry(class_intf, &sp->interfaces, node)\n\t\t\tif (class_intf->remove_dev)\n\t\t\t\tclass_intf->remove_dev(dev);\n\t\t \n\t\tklist_del(&dev->p->knode_class);\n\t\tmutex_unlock(&sp->mutex);\n\t\tsubsys_put(sp);\n\t}\n\tdevice_remove_file(dev, &dev_attr_uevent);\n\tdevice_remove_attrs(dev);\n\tbus_remove_device(dev);\n\tdevice_pm_remove(dev);\n\tdriver_deferred_probe_del(dev);\n\tdevice_platform_notify_remove(dev);\n\tdevice_links_purge(dev);\n\n\t \n\tdevres_release_all(dev);\n\n\tbus_notify(dev, BUS_NOTIFY_REMOVED_DEVICE);\n\tkobject_uevent(&dev->kobj, KOBJ_REMOVE);\n\tglue_dir = get_glue_dir(dev);\n\tkobject_del(&dev->kobj);\n\tcleanup_glue_dir(dev, glue_dir);\n\tmemalloc_noio_restore(noio_flag);\n\tput_device(parent);\n}\nEXPORT_SYMBOL_GPL(device_del);\n\n \nvoid device_unregister(struct device *dev)\n{\n\tpr_debug(\"device: '%s': %s\\n\", dev_name(dev), __func__);\n\tdevice_del(dev);\n\tput_device(dev);\n}\nEXPORT_SYMBOL_GPL(device_unregister);\n\nstatic struct device *prev_device(struct klist_iter *i)\n{\n\tstruct klist_node *n = klist_prev(i);\n\tstruct device *dev = NULL;\n\tstruct device_private *p;\n\n\tif (n) {\n\t\tp = to_device_private_parent(n);\n\t\tdev = p->device;\n\t}\n\treturn dev;\n}\n\nstatic struct device *next_device(struct klist_iter *i)\n{\n\tstruct klist_node *n = klist_next(i);\n\tstruct device *dev = NULL;\n\tstruct device_private *p;\n\n\tif (n) {\n\t\tp = to_device_private_parent(n);\n\t\tdev = p->device;\n\t}\n\treturn dev;\n}\n\n \nconst char *device_get_devnode(const struct device *dev,\n\t\t\t       umode_t *mode, kuid_t *uid, kgid_t *gid,\n\t\t\t       const char **tmp)\n{\n\tchar *s;\n\n\t*tmp = NULL;\n\n\t \n\tif (dev->type && dev->type->devnode)\n\t\t*tmp = dev->type->devnode(dev, mode, uid, gid);\n\tif (*tmp)\n\t\treturn *tmp;\n\n\t \n\tif (dev->class && dev->class->devnode)\n\t\t*tmp = dev->class->devnode(dev, mode);\n\tif (*tmp)\n\t\treturn *tmp;\n\n\t \n\tif (strchr(dev_name(dev), '!') == NULL)\n\t\treturn dev_name(dev);\n\n\t \n\ts = kstrdup_and_replace(dev_name(dev), '!', '/', GFP_KERNEL);\n\tif (!s)\n\t\treturn NULL;\n\treturn *tmp = s;\n}\n\n \nint device_for_each_child(struct device *parent, void *data,\n\t\t\t  int (*fn)(struct device *dev, void *data))\n{\n\tstruct klist_iter i;\n\tstruct device *child;\n\tint error = 0;\n\n\tif (!parent->p)\n\t\treturn 0;\n\n\tklist_iter_init(&parent->p->klist_children, &i);\n\twhile (!error && (child = next_device(&i)))\n\t\terror = fn(child, data);\n\tklist_iter_exit(&i);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(device_for_each_child);\n\n \nint device_for_each_child_reverse(struct device *parent, void *data,\n\t\t\t\t  int (*fn)(struct device *dev, void *data))\n{\n\tstruct klist_iter i;\n\tstruct device *child;\n\tint error = 0;\n\n\tif (!parent->p)\n\t\treturn 0;\n\n\tklist_iter_init(&parent->p->klist_children, &i);\n\twhile ((child = prev_device(&i)) && !error)\n\t\terror = fn(child, data);\n\tklist_iter_exit(&i);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(device_for_each_child_reverse);\n\n \nstruct device *device_find_child(struct device *parent, void *data,\n\t\t\t\t int (*match)(struct device *dev, void *data))\n{\n\tstruct klist_iter i;\n\tstruct device *child;\n\n\tif (!parent)\n\t\treturn NULL;\n\n\tklist_iter_init(&parent->p->klist_children, &i);\n\twhile ((child = next_device(&i)))\n\t\tif (match(child, data) && get_device(child))\n\t\t\tbreak;\n\tklist_iter_exit(&i);\n\treturn child;\n}\nEXPORT_SYMBOL_GPL(device_find_child);\n\n \nstruct device *device_find_child_by_name(struct device *parent,\n\t\t\t\t\t const char *name)\n{\n\tstruct klist_iter i;\n\tstruct device *child;\n\n\tif (!parent)\n\t\treturn NULL;\n\n\tklist_iter_init(&parent->p->klist_children, &i);\n\twhile ((child = next_device(&i)))\n\t\tif (sysfs_streq(dev_name(child), name) && get_device(child))\n\t\t\tbreak;\n\tklist_iter_exit(&i);\n\treturn child;\n}\nEXPORT_SYMBOL_GPL(device_find_child_by_name);\n\nstatic int match_any(struct device *dev, void *unused)\n{\n\treturn 1;\n}\n\n \nstruct device *device_find_any_child(struct device *parent)\n{\n\treturn device_find_child(parent, NULL, match_any);\n}\nEXPORT_SYMBOL_GPL(device_find_any_child);\n\nint __init devices_init(void)\n{\n\tdevices_kset = kset_create_and_add(\"devices\", &device_uevent_ops, NULL);\n\tif (!devices_kset)\n\t\treturn -ENOMEM;\n\tdev_kobj = kobject_create_and_add(\"dev\", NULL);\n\tif (!dev_kobj)\n\t\tgoto dev_kobj_err;\n\tsysfs_dev_block_kobj = kobject_create_and_add(\"block\", dev_kobj);\n\tif (!sysfs_dev_block_kobj)\n\t\tgoto block_kobj_err;\n\tsysfs_dev_char_kobj = kobject_create_and_add(\"char\", dev_kobj);\n\tif (!sysfs_dev_char_kobj)\n\t\tgoto char_kobj_err;\n\n\treturn 0;\n\n char_kobj_err:\n\tkobject_put(sysfs_dev_block_kobj);\n block_kobj_err:\n\tkobject_put(dev_kobj);\n dev_kobj_err:\n\tkset_unregister(devices_kset);\n\treturn -ENOMEM;\n}\n\nstatic int device_check_offline(struct device *dev, void *not_used)\n{\n\tint ret;\n\n\tret = device_for_each_child(dev, NULL, device_check_offline);\n\tif (ret)\n\t\treturn ret;\n\n\treturn device_supports_offline(dev) && !dev->offline ? -EBUSY : 0;\n}\n\n \nint device_offline(struct device *dev)\n{\n\tint ret;\n\n\tif (dev->offline_disabled)\n\t\treturn -EPERM;\n\n\tret = device_for_each_child(dev, NULL, device_check_offline);\n\tif (ret)\n\t\treturn ret;\n\n\tdevice_lock(dev);\n\tif (device_supports_offline(dev)) {\n\t\tif (dev->offline) {\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tret = dev->bus->offline(dev);\n\t\t\tif (!ret) {\n\t\t\t\tkobject_uevent(&dev->kobj, KOBJ_OFFLINE);\n\t\t\t\tdev->offline = true;\n\t\t\t}\n\t\t}\n\t}\n\tdevice_unlock(dev);\n\n\treturn ret;\n}\n\n \nint device_online(struct device *dev)\n{\n\tint ret = 0;\n\n\tdevice_lock(dev);\n\tif (device_supports_offline(dev)) {\n\t\tif (dev->offline) {\n\t\t\tret = dev->bus->online(dev);\n\t\t\tif (!ret) {\n\t\t\t\tkobject_uevent(&dev->kobj, KOBJ_ONLINE);\n\t\t\t\tdev->offline = false;\n\t\t\t}\n\t\t} else {\n\t\t\tret = 1;\n\t\t}\n\t}\n\tdevice_unlock(dev);\n\n\treturn ret;\n}\n\nstruct root_device {\n\tstruct device dev;\n\tstruct module *owner;\n};\n\nstatic inline struct root_device *to_root_device(struct device *d)\n{\n\treturn container_of(d, struct root_device, dev);\n}\n\nstatic void root_device_release(struct device *dev)\n{\n\tkfree(to_root_device(dev));\n}\n\n \nstruct device *__root_device_register(const char *name, struct module *owner)\n{\n\tstruct root_device *root;\n\tint err = -ENOMEM;\n\n\troot = kzalloc(sizeof(struct root_device), GFP_KERNEL);\n\tif (!root)\n\t\treturn ERR_PTR(err);\n\n\terr = dev_set_name(&root->dev, \"%s\", name);\n\tif (err) {\n\t\tkfree(root);\n\t\treturn ERR_PTR(err);\n\t}\n\n\troot->dev.release = root_device_release;\n\n\terr = device_register(&root->dev);\n\tif (err) {\n\t\tput_device(&root->dev);\n\t\treturn ERR_PTR(err);\n\t}\n\n#ifdef CONFIG_MODULES\t \n\tif (owner) {\n\t\tstruct module_kobject *mk = &owner->mkobj;\n\n\t\terr = sysfs_create_link(&root->dev.kobj, &mk->kobj, \"module\");\n\t\tif (err) {\n\t\t\tdevice_unregister(&root->dev);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\troot->owner = owner;\n\t}\n#endif\n\n\treturn &root->dev;\n}\nEXPORT_SYMBOL_GPL(__root_device_register);\n\n \nvoid root_device_unregister(struct device *dev)\n{\n\tstruct root_device *root = to_root_device(dev);\n\n\tif (root->owner)\n\t\tsysfs_remove_link(&root->dev.kobj, \"module\");\n\n\tdevice_unregister(dev);\n}\nEXPORT_SYMBOL_GPL(root_device_unregister);\n\n\nstatic void device_create_release(struct device *dev)\n{\n\tpr_debug(\"device: '%s': %s\\n\", dev_name(dev), __func__);\n\tkfree(dev);\n}\n\nstatic __printf(6, 0) struct device *\ndevice_create_groups_vargs(const struct class *class, struct device *parent,\n\t\t\t   dev_t devt, void *drvdata,\n\t\t\t   const struct attribute_group **groups,\n\t\t\t   const char *fmt, va_list args)\n{\n\tstruct device *dev = NULL;\n\tint retval = -ENODEV;\n\n\tif (IS_ERR_OR_NULL(class))\n\t\tgoto error;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tdevice_initialize(dev);\n\tdev->devt = devt;\n\tdev->class = class;\n\tdev->parent = parent;\n\tdev->groups = groups;\n\tdev->release = device_create_release;\n\tdev_set_drvdata(dev, drvdata);\n\n\tretval = kobject_set_name_vargs(&dev->kobj, fmt, args);\n\tif (retval)\n\t\tgoto error;\n\n\tretval = device_add(dev);\n\tif (retval)\n\t\tgoto error;\n\n\treturn dev;\n\nerror:\n\tput_device(dev);\n\treturn ERR_PTR(retval);\n}\n\n \nstruct device *device_create(const struct class *class, struct device *parent,\n\t\t\t     dev_t devt, void *drvdata, const char *fmt, ...)\n{\n\tva_list vargs;\n\tstruct device *dev;\n\n\tva_start(vargs, fmt);\n\tdev = device_create_groups_vargs(class, parent, devt, drvdata, NULL,\n\t\t\t\t\t  fmt, vargs);\n\tva_end(vargs);\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(device_create);\n\n \nstruct device *device_create_with_groups(const struct class *class,\n\t\t\t\t\t struct device *parent, dev_t devt,\n\t\t\t\t\t void *drvdata,\n\t\t\t\t\t const struct attribute_group **groups,\n\t\t\t\t\t const char *fmt, ...)\n{\n\tva_list vargs;\n\tstruct device *dev;\n\n\tva_start(vargs, fmt);\n\tdev = device_create_groups_vargs(class, parent, devt, drvdata, groups,\n\t\t\t\t\t fmt, vargs);\n\tva_end(vargs);\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(device_create_with_groups);\n\n \nvoid device_destroy(const struct class *class, dev_t devt)\n{\n\tstruct device *dev;\n\n\tdev = class_find_device_by_devt(class, devt);\n\tif (dev) {\n\t\tput_device(dev);\n\t\tdevice_unregister(dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(device_destroy);\n\n \nint device_rename(struct device *dev, const char *new_name)\n{\n\tstruct kobject *kobj = &dev->kobj;\n\tchar *old_device_name = NULL;\n\tint error;\n\n\tdev = get_device(dev);\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tdev_dbg(dev, \"renaming to %s\\n\", new_name);\n\n\told_device_name = kstrdup(dev_name(dev), GFP_KERNEL);\n\tif (!old_device_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (dev->class) {\n\t\tstruct subsys_private *sp = class_to_subsys(dev->class);\n\n\t\tif (!sp) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = sysfs_rename_link_ns(&sp->subsys.kobj, kobj, old_device_name,\n\t\t\t\t\t     new_name, kobject_namespace(kobj));\n\t\tsubsys_put(sp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = kobject_rename(kobj, new_name);\n\tif (error)\n\t\tgoto out;\n\nout:\n\tput_device(dev);\n\n\tkfree(old_device_name);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(device_rename);\n\nstatic int device_move_class_links(struct device *dev,\n\t\t\t\t   struct device *old_parent,\n\t\t\t\t   struct device *new_parent)\n{\n\tint error = 0;\n\n\tif (old_parent)\n\t\tsysfs_remove_link(&dev->kobj, \"device\");\n\tif (new_parent)\n\t\terror = sysfs_create_link(&dev->kobj, &new_parent->kobj,\n\t\t\t\t\t  \"device\");\n\treturn error;\n}\n\n \nint device_move(struct device *dev, struct device *new_parent,\n\t\tenum dpm_order dpm_order)\n{\n\tint error;\n\tstruct device *old_parent;\n\tstruct kobject *new_parent_kobj;\n\n\tdev = get_device(dev);\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tdevice_pm_lock();\n\tnew_parent = get_device(new_parent);\n\tnew_parent_kobj = get_device_parent(dev, new_parent);\n\tif (IS_ERR(new_parent_kobj)) {\n\t\terror = PTR_ERR(new_parent_kobj);\n\t\tput_device(new_parent);\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"device: '%s': %s: moving to '%s'\\n\", dev_name(dev),\n\t\t __func__, new_parent ? dev_name(new_parent) : \"<NULL>\");\n\terror = kobject_move(&dev->kobj, new_parent_kobj);\n\tif (error) {\n\t\tcleanup_glue_dir(dev, new_parent_kobj);\n\t\tput_device(new_parent);\n\t\tgoto out;\n\t}\n\told_parent = dev->parent;\n\tdev->parent = new_parent;\n\tif (old_parent)\n\t\tklist_remove(&dev->p->knode_parent);\n\tif (new_parent) {\n\t\tklist_add_tail(&dev->p->knode_parent,\n\t\t\t       &new_parent->p->klist_children);\n\t\tset_dev_node(dev, dev_to_node(new_parent));\n\t}\n\n\tif (dev->class) {\n\t\terror = device_move_class_links(dev, old_parent, new_parent);\n\t\tif (error) {\n\t\t\t \n\t\t\tdevice_move_class_links(dev, new_parent, old_parent);\n\t\t\tif (!kobject_move(&dev->kobj, &old_parent->kobj)) {\n\t\t\t\tif (new_parent)\n\t\t\t\t\tklist_remove(&dev->p->knode_parent);\n\t\t\t\tdev->parent = old_parent;\n\t\t\t\tif (old_parent) {\n\t\t\t\t\tklist_add_tail(&dev->p->knode_parent,\n\t\t\t\t\t\t       &old_parent->p->klist_children);\n\t\t\t\t\tset_dev_node(dev, dev_to_node(old_parent));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcleanup_glue_dir(dev, new_parent_kobj);\n\t\t\tput_device(new_parent);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tswitch (dpm_order) {\n\tcase DPM_ORDER_NONE:\n\t\tbreak;\n\tcase DPM_ORDER_DEV_AFTER_PARENT:\n\t\tdevice_pm_move_after(dev, new_parent);\n\t\tdevices_kset_move_after(dev, new_parent);\n\t\tbreak;\n\tcase DPM_ORDER_PARENT_BEFORE_DEV:\n\t\tdevice_pm_move_before(new_parent, dev);\n\t\tdevices_kset_move_before(new_parent, dev);\n\t\tbreak;\n\tcase DPM_ORDER_DEV_LAST:\n\t\tdevice_pm_move_last(dev);\n\t\tdevices_kset_move_last(dev);\n\t\tbreak;\n\t}\n\n\tput_device(old_parent);\nout:\n\tdevice_pm_unlock();\n\tput_device(dev);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(device_move);\n\nstatic int device_attrs_change_owner(struct device *dev, kuid_t kuid,\n\t\t\t\t     kgid_t kgid)\n{\n\tstruct kobject *kobj = &dev->kobj;\n\tconst struct class *class = dev->class;\n\tconst struct device_type *type = dev->type;\n\tint error;\n\n\tif (class) {\n\t\t \n\t\terror = sysfs_groups_change_owner(kobj, class->dev_groups, kuid,\n\t\t\t\t\t\t  kgid);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (type) {\n\t\t \n\t\terror = sysfs_groups_change_owner(kobj, type->groups, kuid,\n\t\t\t\t\t\t  kgid);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\terror = sysfs_groups_change_owner(kobj, dev->groups, kuid, kgid);\n\tif (error)\n\t\treturn error;\n\n\tif (device_supports_offline(dev) && !dev->offline_disabled) {\n\t\t \n\t\terror = sysfs_file_change_owner(kobj, dev_attr_online.attr.name,\n\t\t\t\t\t\tkuid, kgid);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nint device_change_owner(struct device *dev, kuid_t kuid, kgid_t kgid)\n{\n\tint error;\n\tstruct kobject *kobj = &dev->kobj;\n\tstruct subsys_private *sp;\n\n\tdev = get_device(dev);\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\t \n\terror = sysfs_change_owner(kobj, kuid, kgid);\n\tif (error)\n\t\tgoto out;\n\n\t \n\terror = sysfs_file_change_owner(kobj, dev_attr_uevent.attr.name, kuid,\n\t\t\t\t\tkgid);\n\tif (error)\n\t\tgoto out;\n\n\t \n\terror = device_attrs_change_owner(dev, kuid, kgid);\n\tif (error)\n\t\tgoto out;\n\n\terror = dpm_sysfs_change_owner(dev, kuid, kgid);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tsp = class_to_subsys(dev->class);\n\tif (!sp) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\terror = sysfs_link_change_owner(&sp->subsys.kobj, &dev->kobj, dev_name(dev), kuid, kgid);\n\tsubsys_put(sp);\n\nout:\n\tput_device(dev);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(device_change_owner);\n\n \nvoid device_shutdown(void)\n{\n\tstruct device *dev, *parent;\n\n\twait_for_device_probe();\n\tdevice_block_probing();\n\n\tcpufreq_suspend();\n\n\tspin_lock(&devices_kset->list_lock);\n\t \n\twhile (!list_empty(&devices_kset->list)) {\n\t\tdev = list_entry(devices_kset->list.prev, struct device,\n\t\t\t\tkobj.entry);\n\n\t\t \n\t\tparent = get_device(dev->parent);\n\t\tget_device(dev);\n\t\t \n\t\tlist_del_init(&dev->kobj.entry);\n\t\tspin_unlock(&devices_kset->list_lock);\n\n\t\t \n\t\tif (parent)\n\t\t\tdevice_lock(parent);\n\t\tdevice_lock(dev);\n\n\t\t \n\t\tpm_runtime_get_noresume(dev);\n\t\tpm_runtime_barrier(dev);\n\n\t\tif (dev->class && dev->class->shutdown_pre) {\n\t\t\tif (initcall_debug)\n\t\t\t\tdev_info(dev, \"shutdown_pre\\n\");\n\t\t\tdev->class->shutdown_pre(dev);\n\t\t}\n\t\tif (dev->bus && dev->bus->shutdown) {\n\t\t\tif (initcall_debug)\n\t\t\t\tdev_info(dev, \"shutdown\\n\");\n\t\t\tdev->bus->shutdown(dev);\n\t\t} else if (dev->driver && dev->driver->shutdown) {\n\t\t\tif (initcall_debug)\n\t\t\t\tdev_info(dev, \"shutdown\\n\");\n\t\t\tdev->driver->shutdown(dev);\n\t\t}\n\n\t\tdevice_unlock(dev);\n\t\tif (parent)\n\t\t\tdevice_unlock(parent);\n\n\t\tput_device(dev);\n\t\tput_device(parent);\n\n\t\tspin_lock(&devices_kset->list_lock);\n\t}\n\tspin_unlock(&devices_kset->list_lock);\n}\n\n \n\n#ifdef CONFIG_PRINTK\nstatic void\nset_dev_info(const struct device *dev, struct dev_printk_info *dev_info)\n{\n\tconst char *subsys;\n\n\tmemset(dev_info, 0, sizeof(*dev_info));\n\n\tif (dev->class)\n\t\tsubsys = dev->class->name;\n\telse if (dev->bus)\n\t\tsubsys = dev->bus->name;\n\telse\n\t\treturn;\n\n\tstrscpy(dev_info->subsystem, subsys, sizeof(dev_info->subsystem));\n\n\t \n\tif (MAJOR(dev->devt)) {\n\t\tchar c;\n\n\t\tif (strcmp(subsys, \"block\") == 0)\n\t\t\tc = 'b';\n\t\telse\n\t\t\tc = 'c';\n\n\t\tsnprintf(dev_info->device, sizeof(dev_info->device),\n\t\t\t \"%c%u:%u\", c, MAJOR(dev->devt), MINOR(dev->devt));\n\t} else if (strcmp(subsys, \"net\") == 0) {\n\t\tstruct net_device *net = to_net_dev(dev);\n\n\t\tsnprintf(dev_info->device, sizeof(dev_info->device),\n\t\t\t \"n%u\", net->ifindex);\n\t} else {\n\t\tsnprintf(dev_info->device, sizeof(dev_info->device),\n\t\t\t \"+%s:%s\", subsys, dev_name(dev));\n\t}\n}\n\nint dev_vprintk_emit(int level, const struct device *dev,\n\t\t     const char *fmt, va_list args)\n{\n\tstruct dev_printk_info dev_info;\n\n\tset_dev_info(dev, &dev_info);\n\n\treturn vprintk_emit(0, level, &dev_info, fmt, args);\n}\nEXPORT_SYMBOL(dev_vprintk_emit);\n\nint dev_printk_emit(int level, const struct device *dev, const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\n\tr = dev_vprintk_emit(level, dev, fmt, args);\n\n\tva_end(args);\n\n\treturn r;\n}\nEXPORT_SYMBOL(dev_printk_emit);\n\nstatic void __dev_printk(const char *level, const struct device *dev,\n\t\t\tstruct va_format *vaf)\n{\n\tif (dev)\n\t\tdev_printk_emit(level[1] - '0', dev, \"%s %s: %pV\",\n\t\t\t\tdev_driver_string(dev), dev_name(dev), vaf);\n\telse\n\t\tprintk(\"%s(NULL device *): %pV\", level, vaf);\n}\n\nvoid _dev_printk(const char *level, const struct device *dev,\n\t\t const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__dev_printk(level, dev, &vaf);\n\n\tva_end(args);\n}\nEXPORT_SYMBOL(_dev_printk);\n\n#define define_dev_printk_level(func, kern_level)\t\t\\\nvoid func(const struct device *dev, const char *fmt, ...)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct va_format vaf;\t\t\t\t\t\\\n\tva_list args;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tva_start(args, fmt);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tvaf.fmt = fmt;\t\t\t\t\t\t\\\n\tvaf.va = &args;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t__dev_printk(kern_level, dev, &vaf);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tva_end(args);\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(func);\n\ndefine_dev_printk_level(_dev_emerg, KERN_EMERG);\ndefine_dev_printk_level(_dev_alert, KERN_ALERT);\ndefine_dev_printk_level(_dev_crit, KERN_CRIT);\ndefine_dev_printk_level(_dev_err, KERN_ERR);\ndefine_dev_printk_level(_dev_warn, KERN_WARNING);\ndefine_dev_printk_level(_dev_notice, KERN_NOTICE);\ndefine_dev_printk_level(_dev_info, KERN_INFO);\n\n#endif\n\n \nint dev_err_probe(const struct device *dev, int err, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (err != -EPROBE_DEFER) {\n\t\tdev_err(dev, \"error %pe: %pV\", ERR_PTR(err), &vaf);\n\t} else {\n\t\tdevice_set_deferred_probe_reason(dev, &vaf);\n\t\tdev_dbg(dev, \"error %pe: %pV\", ERR_PTR(err), &vaf);\n\t}\n\n\tva_end(args);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(dev_err_probe);\n\nstatic inline bool fwnode_is_primary(struct fwnode_handle *fwnode)\n{\n\treturn fwnode && !IS_ERR(fwnode->secondary);\n}\n\n \nvoid set_primary_fwnode(struct device *dev, struct fwnode_handle *fwnode)\n{\n\tstruct device *parent = dev->parent;\n\tstruct fwnode_handle *fn = dev->fwnode;\n\n\tif (fwnode) {\n\t\tif (fwnode_is_primary(fn))\n\t\t\tfn = fn->secondary;\n\n\t\tif (fn) {\n\t\t\tWARN_ON(fwnode->secondary);\n\t\t\tfwnode->secondary = fn;\n\t\t}\n\t\tdev->fwnode = fwnode;\n\t} else {\n\t\tif (fwnode_is_primary(fn)) {\n\t\t\tdev->fwnode = fn->secondary;\n\n\t\t\t \n\t\t\tif (parent && fn == parent->fwnode)\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tfn->secondary = NULL;\n\t\t} else {\n\t\t\tdev->fwnode = NULL;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(set_primary_fwnode);\n\n \nvoid set_secondary_fwnode(struct device *dev, struct fwnode_handle *fwnode)\n{\n\tif (fwnode)\n\t\tfwnode->secondary = ERR_PTR(-ENODEV);\n\n\tif (fwnode_is_primary(dev->fwnode))\n\t\tdev->fwnode->secondary = fwnode;\n\telse\n\t\tdev->fwnode = fwnode;\n}\nEXPORT_SYMBOL_GPL(set_secondary_fwnode);\n\n \nvoid device_set_of_node_from_dev(struct device *dev, const struct device *dev2)\n{\n\tof_node_put(dev->of_node);\n\tdev->of_node = of_node_get(dev2->of_node);\n\tdev->of_node_reused = true;\n}\nEXPORT_SYMBOL_GPL(device_set_of_node_from_dev);\n\nvoid device_set_node(struct device *dev, struct fwnode_handle *fwnode)\n{\n\tdev->fwnode = fwnode;\n\tdev->of_node = to_of_node(fwnode);\n}\nEXPORT_SYMBOL_GPL(device_set_node);\n\nint device_match_name(struct device *dev, const void *name)\n{\n\treturn sysfs_streq(dev_name(dev), name);\n}\nEXPORT_SYMBOL_GPL(device_match_name);\n\nint device_match_of_node(struct device *dev, const void *np)\n{\n\treturn dev->of_node == np;\n}\nEXPORT_SYMBOL_GPL(device_match_of_node);\n\nint device_match_fwnode(struct device *dev, const void *fwnode)\n{\n\treturn dev_fwnode(dev) == fwnode;\n}\nEXPORT_SYMBOL_GPL(device_match_fwnode);\n\nint device_match_devt(struct device *dev, const void *pdevt)\n{\n\treturn dev->devt == *(dev_t *)pdevt;\n}\nEXPORT_SYMBOL_GPL(device_match_devt);\n\nint device_match_acpi_dev(struct device *dev, const void *adev)\n{\n\treturn ACPI_COMPANION(dev) == adev;\n}\nEXPORT_SYMBOL(device_match_acpi_dev);\n\nint device_match_acpi_handle(struct device *dev, const void *handle)\n{\n\treturn ACPI_HANDLE(dev) == handle;\n}\nEXPORT_SYMBOL(device_match_acpi_handle);\n\nint device_match_any(struct device *dev, const void *unused)\n{\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(device_match_any);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}