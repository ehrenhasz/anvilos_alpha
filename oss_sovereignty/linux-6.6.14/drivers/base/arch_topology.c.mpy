{
  "module_name": "arch_topology.c",
  "hash_id": "e7a8041b66a6762fd9f1680aa3150cc905b7ff9c70e4e1205a5a6aec98cf7570",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/arch_topology.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/cacheinfo.h>\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/init.h>\n#include <linux/rcupdate.h>\n#include <linux/sched.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/thermal_pressure.h>\n\nstatic DEFINE_PER_CPU(struct scale_freq_data __rcu *, sft_data);\nstatic struct cpumask scale_freq_counters_mask;\nstatic bool scale_freq_invariant;\nstatic DEFINE_PER_CPU(u32, freq_factor) = 1;\n\nstatic bool supports_scale_freq_counters(const struct cpumask *cpus)\n{\n\treturn cpumask_subset(cpus, &scale_freq_counters_mask);\n}\n\nbool topology_scale_freq_invariant(void)\n{\n\treturn cpufreq_supports_freq_invariance() ||\n\t       supports_scale_freq_counters(cpu_online_mask);\n}\n\nstatic void update_scale_freq_invariant(bool status)\n{\n\tif (scale_freq_invariant == status)\n\t\treturn;\n\n\t \n\tif (topology_scale_freq_invariant() == status) {\n\t\tscale_freq_invariant = status;\n\t\trebuild_sched_domains_energy();\n\t}\n}\n\nvoid topology_set_scale_freq_source(struct scale_freq_data *data,\n\t\t\t\t    const struct cpumask *cpus)\n{\n\tstruct scale_freq_data *sfd;\n\tint cpu;\n\n\t \n\tif (cpumask_empty(&scale_freq_counters_mask))\n\t\tscale_freq_invariant = topology_scale_freq_invariant();\n\n\trcu_read_lock();\n\n\tfor_each_cpu(cpu, cpus) {\n\t\tsfd = rcu_dereference(*per_cpu_ptr(&sft_data, cpu));\n\n\t\t \n\t\tif (!sfd || sfd->source != SCALE_FREQ_SOURCE_ARCH) {\n\t\t\trcu_assign_pointer(per_cpu(sft_data, cpu), data);\n\t\t\tcpumask_set_cpu(cpu, &scale_freq_counters_mask);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tupdate_scale_freq_invariant(true);\n}\nEXPORT_SYMBOL_GPL(topology_set_scale_freq_source);\n\nvoid topology_clear_scale_freq_source(enum scale_freq_source source,\n\t\t\t\t      const struct cpumask *cpus)\n{\n\tstruct scale_freq_data *sfd;\n\tint cpu;\n\n\trcu_read_lock();\n\n\tfor_each_cpu(cpu, cpus) {\n\t\tsfd = rcu_dereference(*per_cpu_ptr(&sft_data, cpu));\n\n\t\tif (sfd && sfd->source == source) {\n\t\t\trcu_assign_pointer(per_cpu(sft_data, cpu), NULL);\n\t\t\tcpumask_clear_cpu(cpu, &scale_freq_counters_mask);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\t \n\tsynchronize_rcu();\n\n\tupdate_scale_freq_invariant(false);\n}\nEXPORT_SYMBOL_GPL(topology_clear_scale_freq_source);\n\nvoid topology_scale_freq_tick(void)\n{\n\tstruct scale_freq_data *sfd = rcu_dereference_sched(*this_cpu_ptr(&sft_data));\n\n\tif (sfd)\n\t\tsfd->set_freq_scale();\n}\n\nDEFINE_PER_CPU(unsigned long, arch_freq_scale) = SCHED_CAPACITY_SCALE;\nEXPORT_PER_CPU_SYMBOL_GPL(arch_freq_scale);\n\nvoid topology_set_freq_scale(const struct cpumask *cpus, unsigned long cur_freq,\n\t\t\t     unsigned long max_freq)\n{\n\tunsigned long scale;\n\tint i;\n\n\tif (WARN_ON_ONCE(!cur_freq || !max_freq))\n\t\treturn;\n\n\t \n\tif (supports_scale_freq_counters(cpus))\n\t\treturn;\n\n\tscale = (cur_freq << SCHED_CAPACITY_SHIFT) / max_freq;\n\n\tfor_each_cpu(i, cpus)\n\t\tper_cpu(arch_freq_scale, i) = scale;\n}\n\nDEFINE_PER_CPU(unsigned long, cpu_scale) = SCHED_CAPACITY_SCALE;\nEXPORT_PER_CPU_SYMBOL_GPL(cpu_scale);\n\nvoid topology_set_cpu_scale(unsigned int cpu, unsigned long capacity)\n{\n\tper_cpu(cpu_scale, cpu) = capacity;\n}\n\nDEFINE_PER_CPU(unsigned long, thermal_pressure);\n\n \nvoid topology_update_thermal_pressure(const struct cpumask *cpus,\n\t\t\t\t      unsigned long capped_freq)\n{\n\tunsigned long max_capacity, capacity, th_pressure;\n\tu32 max_freq;\n\tint cpu;\n\n\tcpu = cpumask_first(cpus);\n\tmax_capacity = arch_scale_cpu_capacity(cpu);\n\tmax_freq = per_cpu(freq_factor, cpu);\n\n\t \n\tcapped_freq /= 1000;\n\n\t \n\tif (max_freq <= capped_freq)\n\t\tcapacity = max_capacity;\n\telse\n\t\tcapacity = mult_frac(max_capacity, capped_freq, max_freq);\n\n\tth_pressure = max_capacity - capacity;\n\n\ttrace_thermal_pressure_update(cpu, th_pressure);\n\n\tfor_each_cpu(cpu, cpus)\n\t\tWRITE_ONCE(per_cpu(thermal_pressure, cpu), th_pressure);\n}\nEXPORT_SYMBOL_GPL(topology_update_thermal_pressure);\n\nstatic ssize_t cpu_capacity_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct cpu *cpu = container_of(dev, struct cpu, dev);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", topology_get_cpu_scale(cpu->dev.id));\n}\n\nstatic void update_topology_flags_workfn(struct work_struct *work);\nstatic DECLARE_WORK(update_topology_flags_work, update_topology_flags_workfn);\n\nstatic DEVICE_ATTR_RO(cpu_capacity);\n\nstatic int register_cpu_capacity_sysctl(void)\n{\n\tint i;\n\tstruct device *cpu;\n\n\tfor_each_possible_cpu(i) {\n\t\tcpu = get_cpu_device(i);\n\t\tif (!cpu) {\n\t\t\tpr_err(\"%s: too early to get CPU%d device!\\n\",\n\t\t\t       __func__, i);\n\t\t\tcontinue;\n\t\t}\n\t\tdevice_create_file(cpu, &dev_attr_cpu_capacity);\n\t}\n\n\treturn 0;\n}\nsubsys_initcall(register_cpu_capacity_sysctl);\n\nstatic int update_topology;\n\nint topology_update_cpu_topology(void)\n{\n\treturn update_topology;\n}\n\n \nstatic void update_topology_flags_workfn(struct work_struct *work)\n{\n\tupdate_topology = 1;\n\trebuild_sched_domains();\n\tpr_debug(\"sched_domain hierarchy rebuilt, flags updated\\n\");\n\tupdate_topology = 0;\n}\n\nstatic u32 *raw_capacity;\n\nstatic int free_raw_capacity(void)\n{\n\tkfree(raw_capacity);\n\traw_capacity = NULL;\n\n\treturn 0;\n}\n\nvoid topology_normalize_cpu_scale(void)\n{\n\tu64 capacity;\n\tu64 capacity_scale;\n\tint cpu;\n\n\tif (!raw_capacity)\n\t\treturn;\n\n\tcapacity_scale = 1;\n\tfor_each_possible_cpu(cpu) {\n\t\tcapacity = raw_capacity[cpu] * per_cpu(freq_factor, cpu);\n\t\tcapacity_scale = max(capacity, capacity_scale);\n\t}\n\n\tpr_debug(\"cpu_capacity: capacity_scale=%llu\\n\", capacity_scale);\n\tfor_each_possible_cpu(cpu) {\n\t\tcapacity = raw_capacity[cpu] * per_cpu(freq_factor, cpu);\n\t\tcapacity = div64_u64(capacity << SCHED_CAPACITY_SHIFT,\n\t\t\tcapacity_scale);\n\t\ttopology_set_cpu_scale(cpu, capacity);\n\t\tpr_debug(\"cpu_capacity: CPU%d cpu_capacity=%lu\\n\",\n\t\t\tcpu, topology_get_cpu_scale(cpu));\n\t}\n}\n\nbool __init topology_parse_cpu_capacity(struct device_node *cpu_node, int cpu)\n{\n\tstruct clk *cpu_clk;\n\tstatic bool cap_parsing_failed;\n\tint ret;\n\tu32 cpu_capacity;\n\n\tif (cap_parsing_failed)\n\t\treturn false;\n\n\tret = of_property_read_u32(cpu_node, \"capacity-dmips-mhz\",\n\t\t\t\t   &cpu_capacity);\n\tif (!ret) {\n\t\tif (!raw_capacity) {\n\t\t\traw_capacity = kcalloc(num_possible_cpus(),\n\t\t\t\t\t       sizeof(*raw_capacity),\n\t\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!raw_capacity) {\n\t\t\t\tcap_parsing_failed = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\traw_capacity[cpu] = cpu_capacity;\n\t\tpr_debug(\"cpu_capacity: %pOF cpu_capacity=%u (raw)\\n\",\n\t\t\tcpu_node, raw_capacity[cpu]);\n\n\t\t \n\t\tcpu_clk = of_clk_get(cpu_node, 0);\n\t\tif (!PTR_ERR_OR_ZERO(cpu_clk)) {\n\t\t\tper_cpu(freq_factor, cpu) =\n\t\t\t\tclk_get_rate(cpu_clk) / 1000;\n\t\t\tclk_put(cpu_clk);\n\t\t}\n\t} else {\n\t\tif (raw_capacity) {\n\t\t\tpr_err(\"cpu_capacity: missing %pOF raw capacity\\n\",\n\t\t\t\tcpu_node);\n\t\t\tpr_err(\"cpu_capacity: partial information: fallback to 1024 for all CPUs\\n\");\n\t\t}\n\t\tcap_parsing_failed = true;\n\t\tfree_raw_capacity();\n\t}\n\n\treturn !ret;\n}\n\n#ifdef CONFIG_ACPI_CPPC_LIB\n#include <acpi/cppc_acpi.h>\n\nvoid topology_init_cpu_capacity_cppc(void)\n{\n\tstruct cppc_perf_caps perf_caps;\n\tint cpu;\n\n\tif (likely(!acpi_cpc_valid()))\n\t\treturn;\n\n\traw_capacity = kcalloc(num_possible_cpus(), sizeof(*raw_capacity),\n\t\t\t       GFP_KERNEL);\n\tif (!raw_capacity)\n\t\treturn;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (!cppc_get_perf_caps(cpu, &perf_caps) &&\n\t\t    (perf_caps.highest_perf >= perf_caps.nominal_perf) &&\n\t\t    (perf_caps.highest_perf >= perf_caps.lowest_perf)) {\n\t\t\traw_capacity[cpu] = perf_caps.highest_perf;\n\t\t\tpr_debug(\"cpu_capacity: CPU%d cpu_capacity=%u (raw).\\n\",\n\t\t\t\t cpu, raw_capacity[cpu]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_err(\"cpu_capacity: CPU%d missing/invalid highest performance.\\n\", cpu);\n\t\tpr_err(\"cpu_capacity: partial information: fallback to 1024 for all CPUs\\n\");\n\t\tgoto exit;\n\t}\n\n\ttopology_normalize_cpu_scale();\n\tschedule_work(&update_topology_flags_work);\n\tpr_debug(\"cpu_capacity: cpu_capacity initialization done\\n\");\n\nexit:\n\tfree_raw_capacity();\n}\n#endif\n\n#ifdef CONFIG_CPU_FREQ\nstatic cpumask_var_t cpus_to_visit;\nstatic void parsing_done_workfn(struct work_struct *work);\nstatic DECLARE_WORK(parsing_done_work, parsing_done_workfn);\n\nstatic int\ninit_cpu_capacity_callback(struct notifier_block *nb,\n\t\t\t   unsigned long val,\n\t\t\t   void *data)\n{\n\tstruct cpufreq_policy *policy = data;\n\tint cpu;\n\n\tif (!raw_capacity)\n\t\treturn 0;\n\n\tif (val != CPUFREQ_CREATE_POLICY)\n\t\treturn 0;\n\n\tpr_debug(\"cpu_capacity: init cpu capacity for CPUs [%*pbl] (to_visit=%*pbl)\\n\",\n\t\t cpumask_pr_args(policy->related_cpus),\n\t\t cpumask_pr_args(cpus_to_visit));\n\n\tcpumask_andnot(cpus_to_visit, cpus_to_visit, policy->related_cpus);\n\n\tfor_each_cpu(cpu, policy->related_cpus)\n\t\tper_cpu(freq_factor, cpu) = policy->cpuinfo.max_freq / 1000;\n\n\tif (cpumask_empty(cpus_to_visit)) {\n\t\ttopology_normalize_cpu_scale();\n\t\tschedule_work(&update_topology_flags_work);\n\t\tfree_raw_capacity();\n\t\tpr_debug(\"cpu_capacity: parsing done\\n\");\n\t\tschedule_work(&parsing_done_work);\n\t}\n\n\treturn 0;\n}\n\nstatic struct notifier_block init_cpu_capacity_notifier = {\n\t.notifier_call = init_cpu_capacity_callback,\n};\n\nstatic int __init register_cpufreq_notifier(void)\n{\n\tint ret;\n\n\t \n\tif (!acpi_disabled || !raw_capacity)\n\t\treturn -EINVAL;\n\n\tif (!alloc_cpumask_var(&cpus_to_visit, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpumask_copy(cpus_to_visit, cpu_possible_mask);\n\n\tret = cpufreq_register_notifier(&init_cpu_capacity_notifier,\n\t\t\t\t\tCPUFREQ_POLICY_NOTIFIER);\n\n\tif (ret)\n\t\tfree_cpumask_var(cpus_to_visit);\n\n\treturn ret;\n}\ncore_initcall(register_cpufreq_notifier);\n\nstatic void parsing_done_workfn(struct work_struct *work)\n{\n\tcpufreq_unregister_notifier(&init_cpu_capacity_notifier,\n\t\t\t\t\t CPUFREQ_POLICY_NOTIFIER);\n\tfree_cpumask_var(cpus_to_visit);\n}\n\n#else\ncore_initcall(free_raw_capacity);\n#endif\n\n#if defined(CONFIG_ARM64) || defined(CONFIG_RISCV)\n \nstatic int __init get_cpu_for_node(struct device_node *node)\n{\n\tstruct device_node *cpu_node;\n\tint cpu;\n\n\tcpu_node = of_parse_phandle(node, \"cpu\", 0);\n\tif (!cpu_node)\n\t\treturn -1;\n\n\tcpu = of_cpu_node_to_id(cpu_node);\n\tif (cpu >= 0)\n\t\ttopology_parse_cpu_capacity(cpu_node, cpu);\n\telse\n\t\tpr_info(\"CPU node for %pOF exist but the possible cpu range is :%*pbl\\n\",\n\t\t\tcpu_node, cpumask_pr_args(cpu_possible_mask));\n\n\tof_node_put(cpu_node);\n\treturn cpu;\n}\n\nstatic int __init parse_core(struct device_node *core, int package_id,\n\t\t\t     int cluster_id, int core_id)\n{\n\tchar name[20];\n\tbool leaf = true;\n\tint i = 0;\n\tint cpu;\n\tstruct device_node *t;\n\n\tdo {\n\t\tsnprintf(name, sizeof(name), \"thread%d\", i);\n\t\tt = of_get_child_by_name(core, name);\n\t\tif (t) {\n\t\t\tleaf = false;\n\t\t\tcpu = get_cpu_for_node(t);\n\t\t\tif (cpu >= 0) {\n\t\t\t\tcpu_topology[cpu].package_id = package_id;\n\t\t\t\tcpu_topology[cpu].cluster_id = cluster_id;\n\t\t\t\tcpu_topology[cpu].core_id = core_id;\n\t\t\t\tcpu_topology[cpu].thread_id = i;\n\t\t\t} else if (cpu != -ENODEV) {\n\t\t\t\tpr_err(\"%pOF: Can't get CPU for thread\\n\", t);\n\t\t\t\tof_node_put(t);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tof_node_put(t);\n\t\t}\n\t\ti++;\n\t} while (t);\n\n\tcpu = get_cpu_for_node(core);\n\tif (cpu >= 0) {\n\t\tif (!leaf) {\n\t\t\tpr_err(\"%pOF: Core has both threads and CPU\\n\",\n\t\t\t       core);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcpu_topology[cpu].package_id = package_id;\n\t\tcpu_topology[cpu].cluster_id = cluster_id;\n\t\tcpu_topology[cpu].core_id = core_id;\n\t} else if (leaf && cpu != -ENODEV) {\n\t\tpr_err(\"%pOF: Can't get CPU for leaf core\\n\", core);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init parse_cluster(struct device_node *cluster, int package_id,\n\t\t\t\tint cluster_id, int depth)\n{\n\tchar name[20];\n\tbool leaf = true;\n\tbool has_cores = false;\n\tstruct device_node *c;\n\tint core_id = 0;\n\tint i, ret;\n\n\t \n\ti = 0;\n\tdo {\n\t\tsnprintf(name, sizeof(name), \"cluster%d\", i);\n\t\tc = of_get_child_by_name(cluster, name);\n\t\tif (c) {\n\t\t\tleaf = false;\n\t\t\tret = parse_cluster(c, package_id, i, depth + 1);\n\t\t\tif (depth > 0)\n\t\t\t\tpr_warn(\"Topology for clusters of clusters not yet supported\\n\");\n\t\t\tof_node_put(c);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\ti++;\n\t} while (c);\n\n\t \n\ti = 0;\n\tdo {\n\t\tsnprintf(name, sizeof(name), \"core%d\", i);\n\t\tc = of_get_child_by_name(cluster, name);\n\t\tif (c) {\n\t\t\thas_cores = true;\n\n\t\t\tif (depth == 0) {\n\t\t\t\tpr_err(\"%pOF: cpu-map children should be clusters\\n\",\n\t\t\t\t       c);\n\t\t\t\tof_node_put(c);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (leaf) {\n\t\t\t\tret = parse_core(c, package_id, cluster_id,\n\t\t\t\t\t\t core_id++);\n\t\t\t} else {\n\t\t\t\tpr_err(\"%pOF: Non-leaf cluster with core %s\\n\",\n\t\t\t\t       cluster, name);\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\n\t\t\tof_node_put(c);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\ti++;\n\t} while (c);\n\n\tif (leaf && !has_cores)\n\t\tpr_warn(\"%pOF: empty cluster\\n\", cluster);\n\n\treturn 0;\n}\n\nstatic int __init parse_socket(struct device_node *socket)\n{\n\tchar name[20];\n\tstruct device_node *c;\n\tbool has_socket = false;\n\tint package_id = 0, ret;\n\n\tdo {\n\t\tsnprintf(name, sizeof(name), \"socket%d\", package_id);\n\t\tc = of_get_child_by_name(socket, name);\n\t\tif (c) {\n\t\t\thas_socket = true;\n\t\t\tret = parse_cluster(c, package_id, -1, 0);\n\t\t\tof_node_put(c);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tpackage_id++;\n\t} while (c);\n\n\tif (!has_socket)\n\t\tret = parse_cluster(socket, 0, -1, 0);\n\n\treturn ret;\n}\n\nstatic int __init parse_dt_topology(void)\n{\n\tstruct device_node *cn, *map;\n\tint ret = 0;\n\tint cpu;\n\n\tcn = of_find_node_by_path(\"/cpus\");\n\tif (!cn) {\n\t\tpr_err(\"No CPU information found in DT\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tmap = of_get_child_by_name(cn, \"cpu-map\");\n\tif (!map)\n\t\tgoto out;\n\n\tret = parse_socket(map);\n\tif (ret != 0)\n\t\tgoto out_map;\n\n\ttopology_normalize_cpu_scale();\n\n\t \n\tfor_each_possible_cpu(cpu)\n\t\tif (cpu_topology[cpu].package_id < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\nout_map:\n\tof_node_put(map);\nout:\n\tof_node_put(cn);\n\treturn ret;\n}\n#endif\n\n \nstruct cpu_topology cpu_topology[NR_CPUS];\nEXPORT_SYMBOL_GPL(cpu_topology);\n\nconst struct cpumask *cpu_coregroup_mask(int cpu)\n{\n\tconst cpumask_t *core_mask = cpumask_of_node(cpu_to_node(cpu));\n\n\t \n\tif (cpumask_subset(&cpu_topology[cpu].core_sibling, core_mask)) {\n\t\t \n\t\tcore_mask = &cpu_topology[cpu].core_sibling;\n\t}\n\n\tif (last_level_cache_is_valid(cpu)) {\n\t\tif (cpumask_subset(&cpu_topology[cpu].llc_sibling, core_mask))\n\t\t\tcore_mask = &cpu_topology[cpu].llc_sibling;\n\t}\n\n\t \n\tif (IS_ENABLED(CONFIG_SCHED_CLUSTER) &&\n\t    cpumask_subset(core_mask, &cpu_topology[cpu].cluster_sibling))\n\t\tcore_mask = &cpu_topology[cpu].cluster_sibling;\n\n\treturn core_mask;\n}\n\nconst struct cpumask *cpu_clustergroup_mask(int cpu)\n{\n\t \n\tif (cpumask_subset(cpu_coregroup_mask(cpu),\n\t\t\t   &cpu_topology[cpu].cluster_sibling))\n\t\treturn topology_sibling_cpumask(cpu);\n\n\treturn &cpu_topology[cpu].cluster_sibling;\n}\n\nvoid update_siblings_masks(unsigned int cpuid)\n{\n\tstruct cpu_topology *cpu_topo, *cpuid_topo = &cpu_topology[cpuid];\n\tint cpu, ret;\n\n\tret = detect_cache_attributes(cpuid);\n\tif (ret && ret != -ENOENT)\n\t\tpr_info(\"Early cacheinfo allocation failed, ret = %d\\n\", ret);\n\n\t \n\tfor_each_online_cpu(cpu) {\n\t\tcpu_topo = &cpu_topology[cpu];\n\n\t\tif (last_level_cache_is_shared(cpu, cpuid)) {\n\t\t\tcpumask_set_cpu(cpu, &cpuid_topo->llc_sibling);\n\t\t\tcpumask_set_cpu(cpuid, &cpu_topo->llc_sibling);\n\t\t}\n\n\t\tif (cpuid_topo->package_id != cpu_topo->package_id)\n\t\t\tcontinue;\n\n\t\tcpumask_set_cpu(cpuid, &cpu_topo->core_sibling);\n\t\tcpumask_set_cpu(cpu, &cpuid_topo->core_sibling);\n\n\t\tif (cpuid_topo->cluster_id != cpu_topo->cluster_id)\n\t\t\tcontinue;\n\n\t\tif (cpuid_topo->cluster_id >= 0) {\n\t\t\tcpumask_set_cpu(cpu, &cpuid_topo->cluster_sibling);\n\t\t\tcpumask_set_cpu(cpuid, &cpu_topo->cluster_sibling);\n\t\t}\n\n\t\tif (cpuid_topo->core_id != cpu_topo->core_id)\n\t\t\tcontinue;\n\n\t\tcpumask_set_cpu(cpuid, &cpu_topo->thread_sibling);\n\t\tcpumask_set_cpu(cpu, &cpuid_topo->thread_sibling);\n\t}\n}\n\nstatic void clear_cpu_topology(int cpu)\n{\n\tstruct cpu_topology *cpu_topo = &cpu_topology[cpu];\n\n\tcpumask_clear(&cpu_topo->llc_sibling);\n\tcpumask_set_cpu(cpu, &cpu_topo->llc_sibling);\n\n\tcpumask_clear(&cpu_topo->cluster_sibling);\n\tcpumask_set_cpu(cpu, &cpu_topo->cluster_sibling);\n\n\tcpumask_clear(&cpu_topo->core_sibling);\n\tcpumask_set_cpu(cpu, &cpu_topo->core_sibling);\n\tcpumask_clear(&cpu_topo->thread_sibling);\n\tcpumask_set_cpu(cpu, &cpu_topo->thread_sibling);\n}\n\nvoid __init reset_cpu_topology(void)\n{\n\tunsigned int cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cpu_topology *cpu_topo = &cpu_topology[cpu];\n\n\t\tcpu_topo->thread_id = -1;\n\t\tcpu_topo->core_id = -1;\n\t\tcpu_topo->cluster_id = -1;\n\t\tcpu_topo->package_id = -1;\n\n\t\tclear_cpu_topology(cpu);\n\t}\n}\n\nvoid remove_cpu_topology(unsigned int cpu)\n{\n\tint sibling;\n\n\tfor_each_cpu(sibling, topology_core_cpumask(cpu))\n\t\tcpumask_clear_cpu(cpu, topology_core_cpumask(sibling));\n\tfor_each_cpu(sibling, topology_sibling_cpumask(cpu))\n\t\tcpumask_clear_cpu(cpu, topology_sibling_cpumask(sibling));\n\tfor_each_cpu(sibling, topology_cluster_cpumask(cpu))\n\t\tcpumask_clear_cpu(cpu, topology_cluster_cpumask(sibling));\n\tfor_each_cpu(sibling, topology_llc_cpumask(cpu))\n\t\tcpumask_clear_cpu(cpu, topology_llc_cpumask(sibling));\n\n\tclear_cpu_topology(cpu);\n}\n\n__weak int __init parse_acpi_topology(void)\n{\n\treturn 0;\n}\n\n#if defined(CONFIG_ARM64) || defined(CONFIG_RISCV)\nvoid __init init_cpu_topology(void)\n{\n\tint cpu, ret;\n\n\treset_cpu_topology();\n\tret = parse_acpi_topology();\n\tif (!ret)\n\t\tret = of_have_populated_dt() && parse_dt_topology();\n\n\tif (ret) {\n\t\t \n\t\treset_cpu_topology();\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tret = fetch_cache_info(cpu);\n\t\tif (!ret)\n\t\t\tcontinue;\n\t\telse if (ret != -ENOENT)\n\t\t\tpr_err(\"Early cacheinfo failed, ret = %d\\n\", ret);\n\t\treturn;\n\t}\n}\n\nvoid store_cpu_topology(unsigned int cpuid)\n{\n\tstruct cpu_topology *cpuid_topo = &cpu_topology[cpuid];\n\n\tif (cpuid_topo->package_id != -1)\n\t\tgoto topology_populated;\n\n\tcpuid_topo->thread_id = -1;\n\tcpuid_topo->core_id = cpuid;\n\tcpuid_topo->package_id = cpu_to_node(cpuid);\n\n\tpr_debug(\"CPU%u: package %d core %d thread %d\\n\",\n\t\t cpuid, cpuid_topo->package_id, cpuid_topo->core_id,\n\t\t cpuid_topo->thread_id);\n\ntopology_populated:\n\tupdate_siblings_masks(cpuid);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}