{
  "module_name": "firmware.h",
  "hash_id": "1eb970753eb5fd360089f1f898425661ddc2fd7657582345650b5d9988db223f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/firmware_loader/firmware.h",
  "human_readable_source": " \n#ifndef __FIRMWARE_LOADER_H\n#define __FIRMWARE_LOADER_H\n\n#include <linux/bitops.h>\n#include <linux/firmware.h>\n#include <linux/types.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/completion.h>\n\n \nenum fw_opt {\n\tFW_OPT_UEVENT\t\t\t= BIT(0),\n\tFW_OPT_NOWAIT\t\t\t= BIT(1),\n\tFW_OPT_USERHELPER\t\t= BIT(2),\n\tFW_OPT_NO_WARN\t\t\t= BIT(3),\n\tFW_OPT_NOCACHE\t\t\t= BIT(4),\n\tFW_OPT_NOFALLBACK_SYSFS\t\t= BIT(5),\n\tFW_OPT_FALLBACK_PLATFORM\t= BIT(6),\n\tFW_OPT_PARTIAL\t\t\t= BIT(7),\n};\n\nenum fw_status {\n\tFW_STATUS_UNKNOWN,\n\tFW_STATUS_LOADING,\n\tFW_STATUS_DONE,\n\tFW_STATUS_ABORTED,\n};\n\n \nstruct fw_state {\n\tstruct completion completion;\n\tenum fw_status status;\n};\n\nstruct fw_priv {\n\tstruct kref ref;\n\tstruct list_head list;\n\tstruct firmware_cache *fwc;\n\tstruct fw_state fw_st;\n\tvoid *data;\n\tsize_t size;\n\tsize_t allocated_size;\n\tsize_t offset;\n\tu32 opt_flags;\n#ifdef CONFIG_FW_LOADER_PAGED_BUF\n\tbool is_paged_buf;\n\tstruct page **pages;\n\tint nr_pages;\n\tint page_array_size;\n#endif\n#ifdef CONFIG_FW_LOADER_USER_HELPER\n\tbool need_uevent;\n\tstruct list_head pending_list;\n#endif\n\tconst char *fw_name;\n};\n\nextern struct mutex fw_lock;\nextern struct firmware_cache fw_cache;\n\nstatic inline bool __fw_state_check(struct fw_priv *fw_priv,\n\t\t\t\t    enum fw_status status)\n{\n\tstruct fw_state *fw_st = &fw_priv->fw_st;\n\n\treturn fw_st->status == status;\n}\n\nstatic inline int __fw_state_wait_common(struct fw_priv *fw_priv, long timeout)\n{\n\tstruct fw_state *fw_st = &fw_priv->fw_st;\n\tlong ret;\n\n\tret = wait_for_completion_killable_timeout(&fw_st->completion, timeout);\n\tif (ret != 0 && fw_st->status == FW_STATUS_ABORTED)\n\t\treturn -ENOENT;\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic inline void __fw_state_set(struct fw_priv *fw_priv,\n\t\t\t\t  enum fw_status status)\n{\n\tstruct fw_state *fw_st = &fw_priv->fw_st;\n\n\tWRITE_ONCE(fw_st->status, status);\n\n\tif (status == FW_STATUS_DONE || status == FW_STATUS_ABORTED) {\n#ifdef CONFIG_FW_LOADER_USER_HELPER\n\t\t \n\t\tlist_del_init(&fw_priv->pending_list);\n#endif\n\t\tcomplete_all(&fw_st->completion);\n\t}\n}\n\nstatic inline void fw_state_aborted(struct fw_priv *fw_priv)\n{\n\t__fw_state_set(fw_priv, FW_STATUS_ABORTED);\n}\n\nstatic inline bool fw_state_is_aborted(struct fw_priv *fw_priv)\n{\n\treturn __fw_state_check(fw_priv, FW_STATUS_ABORTED);\n}\n\nstatic inline void fw_state_start(struct fw_priv *fw_priv)\n{\n\t__fw_state_set(fw_priv, FW_STATUS_LOADING);\n}\n\nstatic inline void fw_state_done(struct fw_priv *fw_priv)\n{\n\t__fw_state_set(fw_priv, FW_STATUS_DONE);\n}\n\nstatic inline bool fw_state_is_done(struct fw_priv *fw_priv)\n{\n\treturn __fw_state_check(fw_priv, FW_STATUS_DONE);\n}\n\nstatic inline bool fw_state_is_loading(struct fw_priv *fw_priv)\n{\n\treturn __fw_state_check(fw_priv, FW_STATUS_LOADING);\n}\n\nint alloc_lookup_fw_priv(const char *fw_name, struct firmware_cache *fwc,\n\t\t\t struct fw_priv **fw_priv, void *dbuf, size_t size,\n\t\t\t size_t offset, u32 opt_flags);\nint assign_fw(struct firmware *fw, struct device *device);\nvoid free_fw_priv(struct fw_priv *fw_priv);\nvoid fw_state_init(struct fw_priv *fw_priv);\n\n#ifdef CONFIG_FW_LOADER\nbool firmware_is_builtin(const struct firmware *fw);\nbool firmware_request_builtin_buf(struct firmware *fw, const char *name,\n\t\t\t\t  void *buf, size_t size);\n#else  \nstatic inline bool firmware_is_builtin(const struct firmware *fw)\n{\n\treturn false;\n}\nstatic inline bool firmware_request_builtin_buf(struct firmware *fw,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tvoid *buf, size_t size)\n{\n\treturn false;\n}\n#endif\n\n#ifdef CONFIG_FW_LOADER_PAGED_BUF\nvoid fw_free_paged_buf(struct fw_priv *fw_priv);\nint fw_grow_paged_buf(struct fw_priv *fw_priv, int pages_needed);\nint fw_map_paged_buf(struct fw_priv *fw_priv);\nbool fw_is_paged_buf(struct fw_priv *fw_priv);\n#else\nstatic inline void fw_free_paged_buf(struct fw_priv *fw_priv) {}\nstatic inline int fw_grow_paged_buf(struct fw_priv *fw_priv, int pages_needed) { return -ENXIO; }\nstatic inline int fw_map_paged_buf(struct fw_priv *fw_priv) { return -ENXIO; }\nstatic inline bool fw_is_paged_buf(struct fw_priv *fw_priv) { return false; }\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}