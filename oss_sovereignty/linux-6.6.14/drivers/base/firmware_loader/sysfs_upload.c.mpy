{
  "module_name": "sysfs_upload.c",
  "hash_id": "a411a8f5ece96df23b698d9396c6db3aa37091aa17a2bc38384cdc45e6c1096e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/firmware_loader/sysfs_upload.c",
  "human_readable_source": "\n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"sysfs_upload.h\"\n\n \n\nstatic const char * const fw_upload_prog_str[] = {\n\t[FW_UPLOAD_PROG_IDLE]\t      = \"idle\",\n\t[FW_UPLOAD_PROG_RECEIVING]    = \"receiving\",\n\t[FW_UPLOAD_PROG_PREPARING]    = \"preparing\",\n\t[FW_UPLOAD_PROG_TRANSFERRING] = \"transferring\",\n\t[FW_UPLOAD_PROG_PROGRAMMING]  = \"programming\"\n};\n\nstatic const char * const fw_upload_err_str[] = {\n\t[FW_UPLOAD_ERR_NONE]\t     = \"none\",\n\t[FW_UPLOAD_ERR_HW_ERROR]     = \"hw-error\",\n\t[FW_UPLOAD_ERR_TIMEOUT]\t     = \"timeout\",\n\t[FW_UPLOAD_ERR_CANCELED]     = \"user-abort\",\n\t[FW_UPLOAD_ERR_BUSY]\t     = \"device-busy\",\n\t[FW_UPLOAD_ERR_INVALID_SIZE] = \"invalid-file-size\",\n\t[FW_UPLOAD_ERR_RW_ERROR]     = \"read-write-error\",\n\t[FW_UPLOAD_ERR_WEAROUT]\t     = \"flash-wearout\",\n};\n\nstatic const char *fw_upload_progress(struct device *dev,\n\t\t\t\t      enum fw_upload_prog prog)\n{\n\tconst char *status = \"unknown-status\";\n\n\tif (prog < FW_UPLOAD_PROG_MAX)\n\t\tstatus = fw_upload_prog_str[prog];\n\telse\n\t\tdev_err(dev, \"Invalid status during secure update: %d\\n\", prog);\n\n\treturn status;\n}\n\nstatic const char *fw_upload_error(struct device *dev,\n\t\t\t\t   enum fw_upload_err err_code)\n{\n\tconst char *error = \"unknown-error\";\n\n\tif (err_code < FW_UPLOAD_ERR_MAX)\n\t\terror = fw_upload_err_str[err_code];\n\telse\n\t\tdev_err(dev, \"Invalid error code during secure update: %d\\n\",\n\t\t\terr_code);\n\n\treturn error;\n}\n\nstatic ssize_t\nstatus_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct fw_upload_priv *fwlp = to_fw_sysfs(dev)->fw_upload_priv;\n\n\treturn sysfs_emit(buf, \"%s\\n\", fw_upload_progress(dev, fwlp->progress));\n}\nDEVICE_ATTR_RO(status);\n\nstatic ssize_t\nerror_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct fw_upload_priv *fwlp = to_fw_sysfs(dev)->fw_upload_priv;\n\tint ret;\n\n\tmutex_lock(&fwlp->lock);\n\n\tif (fwlp->progress != FW_UPLOAD_PROG_IDLE)\n\t\tret = -EBUSY;\n\telse if (!fwlp->err_code)\n\t\tret = 0;\n\telse\n\t\tret = sysfs_emit(buf, \"%s:%s\\n\",\n\t\t\t\t fw_upload_progress(dev, fwlp->err_progress),\n\t\t\t\t fw_upload_error(dev, fwlp->err_code));\n\n\tmutex_unlock(&fwlp->lock);\n\n\treturn ret;\n}\nDEVICE_ATTR_RO(error);\n\nstatic ssize_t cancel_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct fw_upload_priv *fwlp = to_fw_sysfs(dev)->fw_upload_priv;\n\tint ret = count;\n\tbool cancel;\n\n\tif (kstrtobool(buf, &cancel) || !cancel)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&fwlp->lock);\n\tif (fwlp->progress == FW_UPLOAD_PROG_IDLE)\n\t\tret = -ENODEV;\n\n\tfwlp->ops->cancel(fwlp->fw_upload);\n\tmutex_unlock(&fwlp->lock);\n\n\treturn ret;\n}\nDEVICE_ATTR_WO(cancel);\n\nstatic ssize_t remaining_size_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct fw_upload_priv *fwlp = to_fw_sysfs(dev)->fw_upload_priv;\n\n\treturn sysfs_emit(buf, \"%u\\n\", fwlp->remaining_size);\n}\nDEVICE_ATTR_RO(remaining_size);\n\numode_t\nfw_upload_is_visible(struct kobject *kobj, struct attribute *attr, int n)\n{\n\tstatic struct fw_sysfs *fw_sysfs;\n\n\tfw_sysfs = to_fw_sysfs(kobj_to_dev(kobj));\n\n\tif (fw_sysfs->fw_upload_priv || attr == &dev_attr_loading.attr)\n\t\treturn attr->mode;\n\n\treturn 0;\n}\n\nstatic void fw_upload_update_progress(struct fw_upload_priv *fwlp,\n\t\t\t\t      enum fw_upload_prog new_progress)\n{\n\tmutex_lock(&fwlp->lock);\n\tfwlp->progress = new_progress;\n\tmutex_unlock(&fwlp->lock);\n}\n\nstatic void fw_upload_set_error(struct fw_upload_priv *fwlp,\n\t\t\t\tenum fw_upload_err err_code)\n{\n\tmutex_lock(&fwlp->lock);\n\tfwlp->err_progress = fwlp->progress;\n\tfwlp->err_code = err_code;\n\tmutex_unlock(&fwlp->lock);\n}\n\nstatic void fw_upload_prog_complete(struct fw_upload_priv *fwlp)\n{\n\tmutex_lock(&fwlp->lock);\n\tfwlp->progress = FW_UPLOAD_PROG_IDLE;\n\tmutex_unlock(&fwlp->lock);\n}\n\nstatic void fw_upload_main(struct work_struct *work)\n{\n\tstruct fw_upload_priv *fwlp;\n\tstruct fw_sysfs *fw_sysfs;\n\tu32 written = 0, offset = 0;\n\tenum fw_upload_err ret;\n\tstruct device *fw_dev;\n\tstruct fw_upload *fwl;\n\n\tfwlp = container_of(work, struct fw_upload_priv, work);\n\tfwl = fwlp->fw_upload;\n\tfw_sysfs = (struct fw_sysfs *)fwl->priv;\n\tfw_dev = &fw_sysfs->dev;\n\n\tfw_upload_update_progress(fwlp, FW_UPLOAD_PROG_PREPARING);\n\tret = fwlp->ops->prepare(fwl, fwlp->data, fwlp->remaining_size);\n\tif (ret != FW_UPLOAD_ERR_NONE) {\n\t\tfw_upload_set_error(fwlp, ret);\n\t\tgoto putdev_exit;\n\t}\n\n\tfw_upload_update_progress(fwlp, FW_UPLOAD_PROG_TRANSFERRING);\n\twhile (fwlp->remaining_size) {\n\t\tret = fwlp->ops->write(fwl, fwlp->data, offset,\n\t\t\t\t\tfwlp->remaining_size, &written);\n\t\tif (ret != FW_UPLOAD_ERR_NONE || !written) {\n\t\t\tif (ret == FW_UPLOAD_ERR_NONE) {\n\t\t\t\tdev_warn(fw_dev, \"write-op wrote zero data\\n\");\n\t\t\t\tret = FW_UPLOAD_ERR_RW_ERROR;\n\t\t\t}\n\t\t\tfw_upload_set_error(fwlp, ret);\n\t\t\tgoto done;\n\t\t}\n\n\t\tfwlp->remaining_size -= written;\n\t\toffset += written;\n\t}\n\n\tfw_upload_update_progress(fwlp, FW_UPLOAD_PROG_PROGRAMMING);\n\tret = fwlp->ops->poll_complete(fwl);\n\tif (ret != FW_UPLOAD_ERR_NONE)\n\t\tfw_upload_set_error(fwlp, ret);\n\ndone:\n\tif (fwlp->ops->cleanup)\n\t\tfwlp->ops->cleanup(fwl);\n\nputdev_exit:\n\tput_device(fw_dev->parent);\n\n\t \n\tmutex_lock(&fw_lock);\n\tfw_free_paged_buf(fw_sysfs->fw_priv);\n\tfw_state_init(fw_sysfs->fw_priv);\n\tmutex_unlock(&fw_lock);\n\tfwlp->data = NULL;\n\tfw_upload_prog_complete(fwlp);\n}\n\n \nint fw_upload_start(struct fw_sysfs *fw_sysfs)\n{\n\tstruct fw_priv *fw_priv = fw_sysfs->fw_priv;\n\tstruct device *fw_dev = &fw_sysfs->dev;\n\tstruct fw_upload_priv *fwlp;\n\n\tif (!fw_sysfs->fw_upload_priv)\n\t\treturn 0;\n\n\tif (!fw_priv->size) {\n\t\tfw_free_paged_buf(fw_priv);\n\t\tfw_state_init(fw_sysfs->fw_priv);\n\t\treturn 0;\n\t}\n\n\tfwlp = fw_sysfs->fw_upload_priv;\n\tmutex_lock(&fwlp->lock);\n\n\t \n\tif (fwlp->progress != FW_UPLOAD_PROG_IDLE) {\n\t\tmutex_unlock(&fwlp->lock);\n\t\treturn -EBUSY;\n\t}\n\n\tget_device(fw_dev->parent);  \n\n\tfwlp->progress = FW_UPLOAD_PROG_RECEIVING;\n\tfwlp->err_code = 0;\n\tfwlp->remaining_size = fw_priv->size;\n\tfwlp->data = fw_priv->data;\n\n\tpr_debug(\"%s: fw-%s fw_priv=%p data=%p size=%u\\n\",\n\t\t __func__, fw_priv->fw_name,\n\t\t fw_priv, fw_priv->data,\n\t\t (unsigned int)fw_priv->size);\n\n\tqueue_work(system_long_wq, &fwlp->work);\n\tmutex_unlock(&fwlp->lock);\n\n\treturn 0;\n}\n\nvoid fw_upload_free(struct fw_sysfs *fw_sysfs)\n{\n\tstruct fw_upload_priv *fw_upload_priv = fw_sysfs->fw_upload_priv;\n\n\tfree_fw_priv(fw_sysfs->fw_priv);\n\tkfree(fw_upload_priv->fw_upload);\n\tkfree(fw_upload_priv);\n}\n\n \nstruct fw_upload *\nfirmware_upload_register(struct module *module, struct device *parent,\n\t\t\t const char *name, const struct fw_upload_ops *ops,\n\t\t\t void *dd_handle)\n{\n\tu32 opt_flags = FW_OPT_NOCACHE;\n\tstruct fw_upload *fw_upload;\n\tstruct fw_upload_priv *fw_upload_priv;\n\tstruct fw_sysfs *fw_sysfs;\n\tstruct fw_priv *fw_priv;\n\tstruct device *fw_dev;\n\tint ret;\n\n\tif (!name || name[0] == '\\0')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!ops || !ops->cancel || !ops->prepare ||\n\t    !ops->write || !ops->poll_complete) {\n\t\tdev_err(parent, \"Attempt to register without all required ops\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!try_module_get(module))\n\t\treturn ERR_PTR(-EFAULT);\n\n\tfw_upload = kzalloc(sizeof(*fw_upload), GFP_KERNEL);\n\tif (!fw_upload) {\n\t\tret = -ENOMEM;\n\t\tgoto exit_module_put;\n\t}\n\n\tfw_upload_priv = kzalloc(sizeof(*fw_upload_priv), GFP_KERNEL);\n\tif (!fw_upload_priv) {\n\t\tret = -ENOMEM;\n\t\tgoto free_fw_upload;\n\t}\n\n\tfw_upload_priv->fw_upload = fw_upload;\n\tfw_upload_priv->ops = ops;\n\tmutex_init(&fw_upload_priv->lock);\n\tfw_upload_priv->module = module;\n\tfw_upload_priv->name = name;\n\tfw_upload_priv->err_code = 0;\n\tfw_upload_priv->progress = FW_UPLOAD_PROG_IDLE;\n\tINIT_WORK(&fw_upload_priv->work, fw_upload_main);\n\tfw_upload->dd_handle = dd_handle;\n\n\tfw_sysfs = fw_create_instance(NULL, name, parent, opt_flags);\n\tif (IS_ERR(fw_sysfs)) {\n\t\tret = PTR_ERR(fw_sysfs);\n\t\tgoto free_fw_upload_priv;\n\t}\n\tfw_upload->priv = fw_sysfs;\n\tfw_sysfs->fw_upload_priv = fw_upload_priv;\n\tfw_dev = &fw_sysfs->dev;\n\n\tret = alloc_lookup_fw_priv(name, &fw_cache, &fw_priv,  NULL, 0, 0,\n\t\t\t\t   FW_OPT_NOCACHE);\n\tif (ret != 0) {\n\t\tif (ret > 0)\n\t\t\tret = -EINVAL;\n\t\tgoto free_fw_sysfs;\n\t}\n\tfw_priv->is_paged_buf = true;\n\tfw_sysfs->fw_priv = fw_priv;\n\n\tret = device_add(fw_dev);\n\tif (ret) {\n\t\tdev_err(fw_dev, \"%s: device_register failed\\n\", __func__);\n\t\tput_device(fw_dev);\n\t\tgoto exit_module_put;\n\t}\n\n\treturn fw_upload;\n\nfree_fw_sysfs:\n\tkfree(fw_sysfs);\n\nfree_fw_upload_priv:\n\tkfree(fw_upload_priv);\n\nfree_fw_upload:\n\tkfree(fw_upload);\n\nexit_module_put:\n\tmodule_put(module);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(firmware_upload_register);\n\n \nvoid firmware_upload_unregister(struct fw_upload *fw_upload)\n{\n\tstruct fw_sysfs *fw_sysfs = fw_upload->priv;\n\tstruct fw_upload_priv *fw_upload_priv = fw_sysfs->fw_upload_priv;\n\tstruct module *module = fw_upload_priv->module;\n\n\tmutex_lock(&fw_upload_priv->lock);\n\tif (fw_upload_priv->progress == FW_UPLOAD_PROG_IDLE) {\n\t\tmutex_unlock(&fw_upload_priv->lock);\n\t\tgoto unregister;\n\t}\n\n\tfw_upload_priv->ops->cancel(fw_upload);\n\tmutex_unlock(&fw_upload_priv->lock);\n\n\t \n\tflush_work(&fw_upload_priv->work);\n\nunregister:\n\tdevice_unregister(&fw_sysfs->dev);\n\tmodule_put(module);\n}\nEXPORT_SYMBOL_GPL(firmware_upload_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}