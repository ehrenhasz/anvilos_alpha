{
  "module_name": "fallback.c",
  "hash_id": "b3ec63ae9fef7843e34f70761c2865ab2784f8598856d403ea0ed376f3485ba6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/firmware_loader/fallback.c",
  "human_readable_source": "\n\n#include <linux/types.h>\n#include <linux/kconfig.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <linux/umh.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n\n#include \"fallback.h\"\n#include \"firmware.h\"\n\n \n\n \nvoid fw_fallback_set_cache_timeout(void)\n{\n\tfw_fallback_config.old_timeout = __firmware_loading_timeout();\n\t__fw_fallback_set_timeout(10);\n}\n\n \nvoid fw_fallback_set_default_timeout(void)\n{\n\t__fw_fallback_set_timeout(fw_fallback_config.old_timeout);\n}\n\nstatic long firmware_loading_timeout(void)\n{\n\treturn __firmware_loading_timeout() > 0 ?\n\t\t__firmware_loading_timeout() * HZ : MAX_JIFFY_OFFSET;\n}\n\nstatic inline int fw_sysfs_wait_timeout(struct fw_priv *fw_priv,  long timeout)\n{\n\treturn __fw_state_wait_common(fw_priv, timeout);\n}\n\nstatic LIST_HEAD(pending_fw_head);\n\nvoid kill_pending_fw_fallback_reqs(bool only_kill_custom)\n{\n\tstruct fw_priv *fw_priv;\n\tstruct fw_priv *next;\n\n\tmutex_lock(&fw_lock);\n\tlist_for_each_entry_safe(fw_priv, next, &pending_fw_head,\n\t\t\t\t pending_list) {\n\t\tif (!fw_priv->need_uevent || !only_kill_custom)\n\t\t\t __fw_load_abort(fw_priv);\n\t}\n\tmutex_unlock(&fw_lock);\n}\n\n \nstatic int fw_load_sysfs_fallback(struct fw_sysfs *fw_sysfs, long timeout)\n{\n\tint retval = 0;\n\tstruct device *f_dev = &fw_sysfs->dev;\n\tstruct fw_priv *fw_priv = fw_sysfs->fw_priv;\n\n\t \n\tif (!fw_priv->data)\n\t\tfw_priv->is_paged_buf = true;\n\n\tdev_set_uevent_suppress(f_dev, true);\n\n\tretval = device_add(f_dev);\n\tif (retval) {\n\t\tdev_err(f_dev, \"%s: device_register failed\\n\", __func__);\n\t\tgoto err_put_dev;\n\t}\n\n\tmutex_lock(&fw_lock);\n\tif (fw_state_is_aborted(fw_priv)) {\n\t\tmutex_unlock(&fw_lock);\n\t\tretval = -EINTR;\n\t\tgoto out;\n\t}\n\tlist_add(&fw_priv->pending_list, &pending_fw_head);\n\tmutex_unlock(&fw_lock);\n\n\tif (fw_priv->opt_flags & FW_OPT_UEVENT) {\n\t\tfw_priv->need_uevent = true;\n\t\tdev_set_uevent_suppress(f_dev, false);\n\t\tdev_dbg(f_dev, \"firmware: requesting %s\\n\", fw_priv->fw_name);\n\t\tkobject_uevent(&fw_sysfs->dev.kobj, KOBJ_ADD);\n\t} else {\n\t\ttimeout = MAX_JIFFY_OFFSET;\n\t}\n\n\tretval = fw_sysfs_wait_timeout(fw_priv, timeout);\n\tif (retval < 0 && retval != -ENOENT) {\n\t\tmutex_lock(&fw_lock);\n\t\tfw_load_abort(fw_sysfs);\n\t\tmutex_unlock(&fw_lock);\n\t}\n\n\tif (fw_state_is_aborted(fw_priv)) {\n\t\tif (retval == -ERESTARTSYS)\n\t\t\tretval = -EINTR;\n\t} else if (fw_priv->is_paged_buf && !fw_priv->data)\n\t\tretval = -ENOMEM;\n\nout:\n\tdevice_del(f_dev);\nerr_put_dev:\n\tput_device(f_dev);\n\treturn retval;\n}\n\nstatic int fw_load_from_user_helper(struct firmware *firmware,\n\t\t\t\t    const char *name, struct device *device,\n\t\t\t\t    u32 opt_flags)\n{\n\tstruct fw_sysfs *fw_sysfs;\n\tlong timeout;\n\tint ret;\n\n\ttimeout = firmware_loading_timeout();\n\tif (opt_flags & FW_OPT_NOWAIT) {\n\t\ttimeout = usermodehelper_read_lock_wait(timeout);\n\t\tif (!timeout) {\n\t\t\tdev_dbg(device, \"firmware: %s loading timed out\\n\",\n\t\t\t\tname);\n\t\t\treturn -EBUSY;\n\t\t}\n\t} else {\n\t\tret = usermodehelper_read_trylock();\n\t\tif (WARN_ON(ret)) {\n\t\t\tdev_err(device, \"firmware: %s will not be loaded\\n\",\n\t\t\t\tname);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfw_sysfs = fw_create_instance(firmware, name, device, opt_flags);\n\tif (IS_ERR(fw_sysfs)) {\n\t\tret = PTR_ERR(fw_sysfs);\n\t\tgoto out_unlock;\n\t}\n\n\tfw_sysfs->fw_priv = firmware->priv;\n\tret = fw_load_sysfs_fallback(fw_sysfs, timeout);\n\n\tif (!ret)\n\t\tret = assign_fw(firmware, device);\n\nout_unlock:\n\tusermodehelper_read_unlock();\n\n\treturn ret;\n}\n\nstatic bool fw_force_sysfs_fallback(u32 opt_flags)\n{\n\tif (fw_fallback_config.force_sysfs_fallback)\n\t\treturn true;\n\tif (!(opt_flags & FW_OPT_USERHELPER))\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool fw_run_sysfs_fallback(u32 opt_flags)\n{\n\tint ret;\n\n\tif (fw_fallback_config.ignore_sysfs_fallback) {\n\t\tpr_info_once(\"Ignoring firmware sysfs fallback due to sysctl knob\\n\");\n\t\treturn false;\n\t}\n\n\tif ((opt_flags & FW_OPT_NOFALLBACK_SYSFS))\n\t\treturn false;\n\n\t \n\tret = security_kernel_load_data(LOADING_FIRMWARE, true);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn fw_force_sysfs_fallback(opt_flags);\n}\n\n \nint firmware_fallback_sysfs(struct firmware *fw, const char *name,\n\t\t\t    struct device *device,\n\t\t\t    u32 opt_flags,\n\t\t\t    int ret)\n{\n\tif (!fw_run_sysfs_fallback(opt_flags))\n\t\treturn ret;\n\n\tif (!(opt_flags & FW_OPT_NO_WARN))\n\t\tdev_warn(device, \"Falling back to sysfs fallback for: %s\\n\",\n\t\t\t\t name);\n\telse\n\t\tdev_dbg(device, \"Falling back to sysfs fallback for: %s\\n\",\n\t\t\t\tname);\n\treturn fw_load_from_user_helper(fw, name, device, opt_flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}