{
  "module_name": "sysfs.c",
  "hash_id": "cab967f8ac87b5759a114b02e94b1eb4d28fb1cbcb7245b6e2e98dfcc882e966",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/firmware_loader/sysfs.c",
  "human_readable_source": "\n\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"sysfs.h\"\n\n \n\nvoid __fw_load_abort(struct fw_priv *fw_priv)\n{\n\t \n\tif (fw_state_is_aborted(fw_priv) || fw_state_is_done(fw_priv))\n\t\treturn;\n\n\tfw_state_aborted(fw_priv);\n}\n\n#ifdef CONFIG_FW_LOADER_USER_HELPER\nstatic ssize_t timeout_show(const struct class *class, const struct class_attribute *attr,\n\t\t\t    char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", __firmware_loading_timeout());\n}\n\n \nstatic ssize_t timeout_store(const struct class *class, const struct class_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tint tmp_loading_timeout = simple_strtol(buf, NULL, 10);\n\n\tif (tmp_loading_timeout < 0)\n\t\ttmp_loading_timeout = 0;\n\n\t__fw_fallback_set_timeout(tmp_loading_timeout);\n\n\treturn count;\n}\nstatic CLASS_ATTR_RW(timeout);\n\nstatic struct attribute *firmware_class_attrs[] = {\n\t&class_attr_timeout.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(firmware_class);\n\nstatic int do_firmware_uevent(const struct fw_sysfs *fw_sysfs, struct kobj_uevent_env *env)\n{\n\tif (add_uevent_var(env, \"FIRMWARE=%s\", fw_sysfs->fw_priv->fw_name))\n\t\treturn -ENOMEM;\n\tif (add_uevent_var(env, \"TIMEOUT=%i\", __firmware_loading_timeout()))\n\t\treturn -ENOMEM;\n\tif (add_uevent_var(env, \"ASYNC=%d\", fw_sysfs->nowait))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int firmware_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct fw_sysfs *fw_sysfs = to_fw_sysfs(dev);\n\tint err = 0;\n\n\tmutex_lock(&fw_lock);\n\tif (fw_sysfs->fw_priv)\n\t\terr = do_firmware_uevent(fw_sysfs, env);\n\tmutex_unlock(&fw_lock);\n\treturn err;\n}\n#endif  \n\nstatic void fw_dev_release(struct device *dev)\n{\n\tstruct fw_sysfs *fw_sysfs = to_fw_sysfs(dev);\n\n\tif (fw_sysfs->fw_upload_priv)\n\t\tfw_upload_free(fw_sysfs);\n\n\tkfree(fw_sysfs);\n}\n\nstatic struct class firmware_class = {\n\t.name\t\t= \"firmware\",\n#ifdef CONFIG_FW_LOADER_USER_HELPER\n\t.class_groups\t= firmware_class_groups,\n\t.dev_uevent\t= firmware_uevent,\n#endif\n\t.dev_release\t= fw_dev_release,\n};\n\nint register_sysfs_loader(void)\n{\n\tint ret = class_register(&firmware_class);\n\n\tif (ret != 0)\n\t\treturn ret;\n\treturn register_firmware_config_sysctl();\n}\n\nvoid unregister_sysfs_loader(void)\n{\n\tunregister_firmware_config_sysctl();\n\tclass_unregister(&firmware_class);\n}\n\nstatic ssize_t firmware_loading_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct fw_sysfs *fw_sysfs = to_fw_sysfs(dev);\n\tint loading = 0;\n\n\tmutex_lock(&fw_lock);\n\tif (fw_sysfs->fw_priv)\n\t\tloading = fw_state_is_loading(fw_sysfs->fw_priv);\n\tmutex_unlock(&fw_lock);\n\n\treturn sysfs_emit(buf, \"%d\\n\", loading);\n}\n\n \nstatic ssize_t firmware_loading_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct fw_sysfs *fw_sysfs = to_fw_sysfs(dev);\n\tstruct fw_priv *fw_priv;\n\tssize_t written = count;\n\tint loading = simple_strtol(buf, NULL, 10);\n\n\tmutex_lock(&fw_lock);\n\tfw_priv = fw_sysfs->fw_priv;\n\tif (fw_state_is_aborted(fw_priv) || fw_state_is_done(fw_priv))\n\t\tgoto out;\n\n\tswitch (loading) {\n\tcase 1:\n\t\t \n\t\tfw_free_paged_buf(fw_priv);\n\t\tfw_state_start(fw_priv);\n\t\tbreak;\n\tcase 0:\n\t\tif (fw_state_is_loading(fw_priv)) {\n\t\t\tint rc;\n\n\t\t\t \n\t\t\trc = fw_map_paged_buf(fw_priv);\n\t\t\tif (rc)\n\t\t\t\tdev_err(dev, \"%s: map pages failed\\n\",\n\t\t\t\t\t__func__);\n\t\t\telse\n\t\t\t\trc = security_kernel_post_load_data(fw_priv->data,\n\t\t\t\t\t\t\t\t    fw_priv->size,\n\t\t\t\t\t\t\t\t    LOADING_FIRMWARE,\n\t\t\t\t\t\t\t\t    \"blob\");\n\n\t\t\t \n\t\t\tif (rc) {\n\t\t\t\tfw_state_aborted(fw_priv);\n\t\t\t\twritten = rc;\n\t\t\t} else {\n\t\t\t\tfw_state_done(fw_priv);\n\n\t\t\t\t \n\t\t\t\trc = fw_upload_start(fw_sysfs);\n\t\t\t\tif (rc)\n\t\t\t\t\twritten = rc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdev_err(dev, \"%s: unexpected value (%d)\\n\", __func__, loading);\n\t\tfallthrough;\n\tcase -1:\n\t\tfw_load_abort(fw_sysfs);\n\t\tif (fw_sysfs->fw_upload_priv)\n\t\t\tfw_state_init(fw_sysfs->fw_priv);\n\n\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&fw_lock);\n\treturn written;\n}\n\nDEVICE_ATTR(loading, 0644, firmware_loading_show, firmware_loading_store);\n\nstatic void firmware_rw_data(struct fw_priv *fw_priv, char *buffer,\n\t\t\t     loff_t offset, size_t count, bool read)\n{\n\tif (read)\n\t\tmemcpy(buffer, fw_priv->data + offset, count);\n\telse\n\t\tmemcpy(fw_priv->data + offset, buffer, count);\n}\n\nstatic void firmware_rw(struct fw_priv *fw_priv, char *buffer,\n\t\t\tloff_t offset, size_t count, bool read)\n{\n\twhile (count) {\n\t\tint page_nr = offset >> PAGE_SHIFT;\n\t\tint page_ofs = offset & (PAGE_SIZE - 1);\n\t\tint page_cnt = min_t(size_t, PAGE_SIZE - page_ofs, count);\n\n\t\tif (read)\n\t\t\tmemcpy_from_page(buffer, fw_priv->pages[page_nr],\n\t\t\t\t\t page_ofs, page_cnt);\n\t\telse\n\t\t\tmemcpy_to_page(fw_priv->pages[page_nr], page_ofs,\n\t\t\t\t       buffer, page_cnt);\n\n\t\tbuffer += page_cnt;\n\t\toffset += page_cnt;\n\t\tcount -= page_cnt;\n\t}\n}\n\nstatic ssize_t firmware_data_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t  struct bin_attribute *bin_attr,\n\t\t\t\t  char *buffer, loff_t offset, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct fw_sysfs *fw_sysfs = to_fw_sysfs(dev);\n\tstruct fw_priv *fw_priv;\n\tssize_t ret_count;\n\n\tmutex_lock(&fw_lock);\n\tfw_priv = fw_sysfs->fw_priv;\n\tif (!fw_priv || fw_state_is_done(fw_priv)) {\n\t\tret_count = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (offset > fw_priv->size) {\n\t\tret_count = 0;\n\t\tgoto out;\n\t}\n\tif (count > fw_priv->size - offset)\n\t\tcount = fw_priv->size - offset;\n\n\tret_count = count;\n\n\tif (fw_priv->data)\n\t\tfirmware_rw_data(fw_priv, buffer, offset, count, true);\n\telse\n\t\tfirmware_rw(fw_priv, buffer, offset, count, true);\n\nout:\n\tmutex_unlock(&fw_lock);\n\treturn ret_count;\n}\n\nstatic int fw_realloc_pages(struct fw_sysfs *fw_sysfs, int min_size)\n{\n\tint err;\n\n\terr = fw_grow_paged_buf(fw_sysfs->fw_priv,\n\t\t\t\tPAGE_ALIGN(min_size) >> PAGE_SHIFT);\n\tif (err)\n\t\tfw_load_abort(fw_sysfs);\n\treturn err;\n}\n\n \nstatic ssize_t firmware_data_write(struct file *filp, struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *bin_attr,\n\t\t\t\t   char *buffer, loff_t offset, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct fw_sysfs *fw_sysfs = to_fw_sysfs(dev);\n\tstruct fw_priv *fw_priv;\n\tssize_t retval;\n\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\tmutex_lock(&fw_lock);\n\tfw_priv = fw_sysfs->fw_priv;\n\tif (!fw_priv || fw_state_is_done(fw_priv)) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (fw_priv->data) {\n\t\tif (offset + count > fw_priv->allocated_size) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfirmware_rw_data(fw_priv, buffer, offset, count, false);\n\t\tretval = count;\n\t} else {\n\t\tretval = fw_realloc_pages(fw_sysfs, offset + count);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\tretval = count;\n\t\tfirmware_rw(fw_priv, buffer, offset, count, false);\n\t}\n\n\tfw_priv->size = max_t(size_t, offset + count, fw_priv->size);\nout:\n\tmutex_unlock(&fw_lock);\n\treturn retval;\n}\n\nstatic struct bin_attribute firmware_attr_data = {\n\t.attr = { .name = \"data\", .mode = 0644 },\n\t.size = 0,\n\t.read = firmware_data_read,\n\t.write = firmware_data_write,\n};\n\nstatic struct attribute *fw_dev_attrs[] = {\n\t&dev_attr_loading.attr,\n#ifdef CONFIG_FW_UPLOAD\n\t&dev_attr_cancel.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_error.attr,\n\t&dev_attr_remaining_size.attr,\n#endif\n\tNULL\n};\n\nstatic struct bin_attribute *fw_dev_bin_attrs[] = {\n\t&firmware_attr_data,\n\tNULL\n};\n\nstatic const struct attribute_group fw_dev_attr_group = {\n\t.attrs = fw_dev_attrs,\n\t.bin_attrs = fw_dev_bin_attrs,\n#ifdef CONFIG_FW_UPLOAD\n\t.is_visible = fw_upload_is_visible,\n#endif\n};\n\nstatic const struct attribute_group *fw_dev_attr_groups[] = {\n\t&fw_dev_attr_group,\n\tNULL\n};\n\nstruct fw_sysfs *\nfw_create_instance(struct firmware *firmware, const char *fw_name,\n\t\t   struct device *device, u32 opt_flags)\n{\n\tstruct fw_sysfs *fw_sysfs;\n\tstruct device *f_dev;\n\n\tfw_sysfs = kzalloc(sizeof(*fw_sysfs), GFP_KERNEL);\n\tif (!fw_sysfs) {\n\t\tfw_sysfs = ERR_PTR(-ENOMEM);\n\t\tgoto exit;\n\t}\n\n\tfw_sysfs->nowait = !!(opt_flags & FW_OPT_NOWAIT);\n\tfw_sysfs->fw = firmware;\n\tf_dev = &fw_sysfs->dev;\n\n\tdevice_initialize(f_dev);\n\tdev_set_name(f_dev, \"%s\", fw_name);\n\tf_dev->parent = device;\n\tf_dev->class = &firmware_class;\n\tf_dev->groups = fw_dev_attr_groups;\nexit:\n\treturn fw_sysfs;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}