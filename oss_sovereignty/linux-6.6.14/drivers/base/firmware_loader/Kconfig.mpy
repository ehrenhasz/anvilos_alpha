{
  "module_name": "Kconfig",
  "hash_id": "7777a2eb938bffb002bc26efd6d38935e681c025d1971c462ca73763176faf77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/firmware_loader/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\nmenu \"Firmware loader\"\n\nconfig FW_LOADER\n\ttristate \"Firmware loading facility\" if EXPERT\n\tselect CRYPTO_HASH if FW_LOADER_DEBUG\n\tselect CRYPTO_SHA256 if FW_LOADER_DEBUG\n\tdefault y\n\thelp\n\t  This enables the firmware loading facility in the kernel. The kernel\n\t  will first look for built-in firmware, if it has any. Next, it will\n\t  look for the requested firmware in a series of filesystem paths:\n\n\t\to firmware_class path module parameter or kernel boot param\n\t\to /lib/firmware/updates/UTS_RELEASE\n\t\to /lib/firmware/updates\n\t\to /lib/firmware/UTS_RELEASE\n\t\to /lib/firmware\n\n\t  Enabling this feature only increases your kernel image by about\n\t  828 bytes, enable this option unless you are certain you don't\n\t  need firmware.\n\n\t  You typically want this built-in (=y) but you can also enable this\n\t  as a module, in which case the firmware_class module will be built.\n\t  You also want to be sure to enable this built-in if you are going to\n\t  enable built-in firmware (CONFIG_EXTRA_FIRMWARE).\n\nconfig FW_LOADER_DEBUG\n\tbool \"Log filenames and checksums for loaded firmware\"\n\tdepends on CRYPTO = FW_LOADER || CRYPTO=y\n\tdepends on DYNAMIC_DEBUG\n\tdepends on FW_LOADER\n\tdefault FW_LOADER\n\thelp\n\t  Select this option to use dynamic debug to log firmware filenames and\n\t  SHA256 checksums to the kernel log for each firmware file that is\n\t  loaded.\n\nif FW_LOADER\n\nconfig FW_LOADER_PAGED_BUF\n\tbool\n\nconfig FW_LOADER_SYSFS\n\tbool\n\nconfig EXTRA_FIRMWARE\n\tstring \"Build named firmware blobs into the kernel binary\"\n\thelp\n\t  Device drivers which require firmware can typically deal with\n\t  having the kernel load firmware from the various supported\n\t  /lib/firmware/ paths. This option enables you to build into the\n\t  kernel firmware files. Built-in firmware searches are preceded\n\t  over firmware lookups using your filesystem over the supported\n\t  /lib/firmware paths documented on CONFIG_FW_LOADER.\n\n\t  This may be useful for testing or if the firmware is required early on\n\t  in boot and cannot rely on the firmware being placed in an initrd or\n\t  initramfs.\n\n\t  This option is a string and takes the (space-separated) names of the\n\t  firmware files -- the same names that appear in MODULE_FIRMWARE()\n\t  and request_firmware() in the source. These files should exist under\n\t  the directory specified by the EXTRA_FIRMWARE_DIR option, which is\n\t  /lib/firmware by default.\n\n\t  For example, you might set CONFIG_EXTRA_FIRMWARE=\"usb8388.bin\", copy\n\t  the usb8388.bin file into /lib/firmware, and build the kernel. Then\n\t  any request_firmware(\"usb8388.bin\") will be satisfied internally\n\t  inside the kernel without ever looking at your filesystem at runtime.\n\n\t  WARNING: If you include additional firmware files into your binary\n\t  kernel image that are not available under the terms of the GPL,\n\t  then it may be a violation of the GPL to distribute the resulting\n\t  image since it combines both GPL and non-GPL work. You should\n\t  consult a lawyer of your own before distributing such an image.\n\n\t  NOTE: Compressed files are not supported in EXTRA_FIRMWARE.\n\nconfig EXTRA_FIRMWARE_DIR\n\tstring \"Firmware blobs root directory\"\n\tdepends on EXTRA_FIRMWARE != \"\"\n\tdefault \"/lib/firmware\"\n\thelp\n\t  This option controls the directory in which the kernel build system\n\t  looks for the firmware files listed in the EXTRA_FIRMWARE option.\n\nconfig FW_LOADER_USER_HELPER\n\tbool \"Enable the firmware sysfs fallback mechanism\"\n\tselect FW_LOADER_SYSFS\n\tselect FW_LOADER_PAGED_BUF\n\thelp\n\t  This option enables a sysfs loading facility to enable firmware\n\t  loading to the kernel through userspace as a fallback mechanism\n\t  if and only if the kernel's direct filesystem lookup for the\n\t  firmware failed using the different /lib/firmware/ paths, or the\n\t  path specified in the firmware_class path module parameter, or the\n\t  firmware_class path kernel boot parameter if the firmware_class is\n\t  built-in. For details on how to work with the sysfs fallback mechanism\n\t  refer to Documentation/driver-api/firmware/fallback-mechanisms.rst.\n\n\t  The direct filesystem lookup for firmware is always used first now.\n\n\t  If the kernel's direct filesystem lookup for firmware fails to find\n\t  the requested firmware a sysfs fallback loading facility is made\n\t  available and userspace is informed about this through uevents.\n\t  The uevent can be suppressed if the driver explicitly requested it,\n\t  this is known as the driver using the custom fallback mechanism.\n\t  If the custom fallback mechanism is used userspace must always\n\t  acknowledge failure to find firmware as the timeout for the fallback\n\t  mechanism is disabled, and failed requests will linger forever.\n\n\t  This used to be the default firmware loading facility, and udev used\n\t  to listen for uvents to load firmware for the kernel. The firmware\n\t  loading facility functionality in udev has been removed, as such it\n\t  can no longer be relied upon as a fallback mechanism. Linux no longer\n\t  relies on or uses a fallback mechanism in userspace. If you need to\n\t  rely on one refer to the permissively licensed firmwared:\n\n\t  https://github.com/teg/firmwared\n\n\t  Since this was the default firmware loading facility at one point,\n\t  old userspace may exist which relies upon it, and as such this\n\t  mechanism can never be removed from the kernel.\n\n\t  You should only enable this functionality if you are certain you\n\t  require a fallback mechanism and have a userspace mechanism ready to\n\t  load firmware in case it is not found. One main reason for this may\n\t  be if you have drivers which require firmware built-in and for\n\t  whatever reason cannot place the required firmware in initramfs.\n\t  Another reason kernels may have this feature enabled is to support a\n\t  driver which explicitly relies on this fallback mechanism. Only two\n\t  drivers need this today:\n\n\t    o CONFIG_LEDS_LP55XX_COMMON\n\t    o CONFIG_DELL_RBU\n\n\t  Outside of supporting the above drivers, another reason for needing\n\t  this may be that your firmware resides outside of the paths the kernel\n\t  looks for and cannot possibly be specified using the firmware_class\n\t  path module parameter or kernel firmware_class path boot parameter\n\t  if firmware_class is built-in.\n\n\t  A modern use case may be to temporarily mount a custom partition\n\t  during provisioning which is only accessible to userspace, and then\n\t  to use it to look for and fetch the required firmware. Such type of\n\t  driver functionality may not even ever be desirable upstream by\n\t  vendors, and as such is only required to be supported as an interface\n\t  for provisioning. Since udev's firmware loading facility has been\n\t  removed you can use firmwared or a fork of it to customize how you\n\t  want to load firmware based on uevents issued.\n\n\t  Enabling this option will increase your kernel image size by about\n\t  13436 bytes.\n\n\t  If you are unsure about this, say N here, unless you are Linux\n\t  distribution and need to support the above two drivers, or you are\n\t  certain you need to support some really custom firmware loading\n\t  facility in userspace.\n\nconfig FW_LOADER_USER_HELPER_FALLBACK\n\tbool \"Force the firmware sysfs fallback mechanism when possible\"\n\tdepends on FW_LOADER_USER_HELPER\n\thelp\n\t  Enabling this option forces a sysfs userspace fallback mechanism\n\t  to be used for all firmware requests which explicitly do not disable a\n\t  a fallback mechanism. Firmware calls which do prohibit a fallback\n\t  mechanism is request_firmware_direct(). This option is kept for\n\t  backward compatibility purposes given this precise mechanism can also\n\t  be enabled by setting the proc sysctl value to true:\n\n\t       /proc/sys/kernel/firmware_config/force_sysfs_fallback\n\n\t  If you are unsure about this, say N here.\n\nconfig FW_LOADER_COMPRESS\n\tbool \"Enable compressed firmware support\"\n\thelp\n\t  This option enables the support for loading compressed firmware\n\t  files. The caller of firmware API receives the decompressed file\n\t  content. The compressed file is loaded as a fallback, only after\n\t  loading the raw file failed at first.\n\n\t  Compressed firmware support does not apply to firmware images\n\t  that are built into the kernel image (CONFIG_EXTRA_FIRMWARE).\n\nif FW_LOADER_COMPRESS\nconfig FW_LOADER_COMPRESS_XZ\n\tbool \"Enable XZ-compressed firmware support\"\n\tselect FW_LOADER_PAGED_BUF\n\tselect XZ_DEC\n\tdefault y\n\thelp\n\t  This option adds the support for XZ-compressed files.\n\t  The files have to be compressed with either none or crc32\n\t  integrity check type (pass \"-C crc32\" option to xz command).\n\nconfig FW_LOADER_COMPRESS_ZSTD\n\tbool \"Enable ZSTD-compressed firmware support\"\n\tselect ZSTD_DECOMPRESS\n\thelp\n\t  This option adds the support for ZSTD-compressed files.\n\nendif # FW_LOADER_COMPRESS\n\nconfig FW_CACHE\n\tbool \"Enable firmware caching during suspend\"\n\tdepends on PM_SLEEP\n\tdefault y if PM_SLEEP\n\thelp\n\t  Because firmware caching generates uevent messages that are sent\n\t  over a netlink socket, it can prevent suspend on many platforms.\n\t  It is also not always useful, so on such platforms we have the\n\t  option.\n\n\t  If unsure, say Y.\n\nconfig FW_UPLOAD\n\tbool \"Enable users to initiate firmware updates using sysfs\"\n\tselect FW_LOADER_SYSFS\n\tselect FW_LOADER_PAGED_BUF\n\thelp\n\t  Enabling this option will allow device drivers to expose a persistent\n\t  sysfs interface that allows firmware updates to be initiated from\n\t  userspace. For example, FPGA based PCIe cards load firmware and FPGA\n\t  images from local FLASH when the card boots. The images in FLASH may\n\t  be updated with new images provided by the user. Enable this device\n\t  to support cards that rely on user-initiated updates for firmware files.\n\n\t  If unsure, say N.\n\nendif # FW_LOADER\nendmenu\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}