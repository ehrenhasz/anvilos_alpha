{
  "module_name": "main.c",
  "hash_id": "b45d15b61aae72f67ebb8b06bce8fa1b42a8b955e5680176194db107bdef7d88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/firmware_loader/main.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/capability.h>\n#include <linux/device.h>\n#include <linux/kernel_read_file.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/initrd.h>\n#include <linux/timer.h>\n#include <linux/vmalloc.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/async.h>\n#include <linux/pm.h>\n#include <linux/suspend.h>\n#include <linux/syscore_ops.h>\n#include <linux/reboot.h>\n#include <linux/security.h>\n#include <linux/zstd.h>\n#include <linux/xz.h>\n\n#include <generated/utsrelease.h>\n\n#include \"../base.h\"\n#include \"firmware.h\"\n#include \"fallback.h\"\n\nMODULE_AUTHOR(\"Manuel Estrada Sainz\");\nMODULE_DESCRIPTION(\"Multi purpose firmware loading support\");\nMODULE_LICENSE(\"GPL\");\n\nstruct firmware_cache {\n\t \n\tspinlock_t lock;\n\tstruct list_head head;\n\tint state;\n\n#ifdef CONFIG_FW_CACHE\n\t \n\tspinlock_t name_lock;\n\tstruct list_head fw_names;\n\n\tstruct delayed_work work;\n\n\tstruct notifier_block   pm_notify;\n#endif\n};\n\nstruct fw_cache_entry {\n\tstruct list_head list;\n\tconst char *name;\n};\n\nstruct fw_name_devm {\n\tunsigned long magic;\n\tconst char *name;\n};\n\nstatic inline struct fw_priv *to_fw_priv(struct kref *ref)\n{\n\treturn container_of(ref, struct fw_priv, ref);\n}\n\n#define\tFW_LOADER_NO_CACHE\t0\n#define\tFW_LOADER_START_CACHE\t1\n\n \nDEFINE_MUTEX(fw_lock);\n\nstruct firmware_cache fw_cache;\n\nvoid fw_state_init(struct fw_priv *fw_priv)\n{\n\tstruct fw_state *fw_st = &fw_priv->fw_st;\n\n\tinit_completion(&fw_st->completion);\n\tfw_st->status = FW_STATUS_UNKNOWN;\n}\n\nstatic inline int fw_state_wait(struct fw_priv *fw_priv)\n{\n\treturn __fw_state_wait_common(fw_priv, MAX_SCHEDULE_TIMEOUT);\n}\n\nstatic void fw_cache_piggyback_on_request(struct fw_priv *fw_priv);\n\nstatic struct fw_priv *__allocate_fw_priv(const char *fw_name,\n\t\t\t\t\t  struct firmware_cache *fwc,\n\t\t\t\t\t  void *dbuf,\n\t\t\t\t\t  size_t size,\n\t\t\t\t\t  size_t offset,\n\t\t\t\t\t  u32 opt_flags)\n{\n\tstruct fw_priv *fw_priv;\n\n\t \n\tif ((opt_flags & FW_OPT_PARTIAL) && !dbuf)\n\t\treturn NULL;\n\n\t \n\tif (offset != 0 && !(opt_flags & FW_OPT_PARTIAL))\n\t\treturn NULL;\n\n\tfw_priv = kzalloc(sizeof(*fw_priv), GFP_ATOMIC);\n\tif (!fw_priv)\n\t\treturn NULL;\n\n\tfw_priv->fw_name = kstrdup_const(fw_name, GFP_ATOMIC);\n\tif (!fw_priv->fw_name) {\n\t\tkfree(fw_priv);\n\t\treturn NULL;\n\t}\n\n\tkref_init(&fw_priv->ref);\n\tfw_priv->fwc = fwc;\n\tfw_priv->data = dbuf;\n\tfw_priv->allocated_size = size;\n\tfw_priv->offset = offset;\n\tfw_priv->opt_flags = opt_flags;\n\tfw_state_init(fw_priv);\n#ifdef CONFIG_FW_LOADER_USER_HELPER\n\tINIT_LIST_HEAD(&fw_priv->pending_list);\n#endif\n\n\tpr_debug(\"%s: fw-%s fw_priv=%p\\n\", __func__, fw_name, fw_priv);\n\n\treturn fw_priv;\n}\n\nstatic struct fw_priv *__lookup_fw_priv(const char *fw_name)\n{\n\tstruct fw_priv *tmp;\n\tstruct firmware_cache *fwc = &fw_cache;\n\n\tlist_for_each_entry(tmp, &fwc->head, list)\n\t\tif (!strcmp(tmp->fw_name, fw_name))\n\t\t\treturn tmp;\n\treturn NULL;\n}\n\n \nint alloc_lookup_fw_priv(const char *fw_name, struct firmware_cache *fwc,\n\t\t\t struct fw_priv **fw_priv, void *dbuf, size_t size,\n\t\t\t size_t offset, u32 opt_flags)\n{\n\tstruct fw_priv *tmp;\n\n\tspin_lock(&fwc->lock);\n\t \n\tif (!(opt_flags & (FW_OPT_NOCACHE | FW_OPT_PARTIAL))) {\n\t\ttmp = __lookup_fw_priv(fw_name);\n\t\tif (tmp) {\n\t\t\tkref_get(&tmp->ref);\n\t\t\tspin_unlock(&fwc->lock);\n\t\t\t*fw_priv = tmp;\n\t\t\tpr_debug(\"batched request - sharing the same struct fw_priv and lookup for multiple requests\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\ttmp = __allocate_fw_priv(fw_name, fwc, dbuf, size, offset, opt_flags);\n\tif (tmp) {\n\t\tINIT_LIST_HEAD(&tmp->list);\n\t\tif (!(opt_flags & FW_OPT_NOCACHE))\n\t\t\tlist_add(&tmp->list, &fwc->head);\n\t}\n\tspin_unlock(&fwc->lock);\n\n\t*fw_priv = tmp;\n\n\treturn tmp ? 0 : -ENOMEM;\n}\n\nstatic void __free_fw_priv(struct kref *ref)\n\t__releases(&fwc->lock)\n{\n\tstruct fw_priv *fw_priv = to_fw_priv(ref);\n\tstruct firmware_cache *fwc = fw_priv->fwc;\n\n\tpr_debug(\"%s: fw-%s fw_priv=%p data=%p size=%u\\n\",\n\t\t __func__, fw_priv->fw_name, fw_priv, fw_priv->data,\n\t\t (unsigned int)fw_priv->size);\n\n\tlist_del(&fw_priv->list);\n\tspin_unlock(&fwc->lock);\n\n\tif (fw_is_paged_buf(fw_priv))\n\t\tfw_free_paged_buf(fw_priv);\n\telse if (!fw_priv->allocated_size)\n\t\tvfree(fw_priv->data);\n\n\tkfree_const(fw_priv->fw_name);\n\tkfree(fw_priv);\n}\n\nvoid free_fw_priv(struct fw_priv *fw_priv)\n{\n\tstruct firmware_cache *fwc = fw_priv->fwc;\n\tspin_lock(&fwc->lock);\n\tif (!kref_put(&fw_priv->ref, __free_fw_priv))\n\t\tspin_unlock(&fwc->lock);\n}\n\n#ifdef CONFIG_FW_LOADER_PAGED_BUF\nbool fw_is_paged_buf(struct fw_priv *fw_priv)\n{\n\treturn fw_priv->is_paged_buf;\n}\n\nvoid fw_free_paged_buf(struct fw_priv *fw_priv)\n{\n\tint i;\n\n\tif (!fw_priv->pages)\n\t\treturn;\n\n\tvunmap(fw_priv->data);\n\n\tfor (i = 0; i < fw_priv->nr_pages; i++)\n\t\t__free_page(fw_priv->pages[i]);\n\tkvfree(fw_priv->pages);\n\tfw_priv->pages = NULL;\n\tfw_priv->page_array_size = 0;\n\tfw_priv->nr_pages = 0;\n\tfw_priv->data = NULL;\n\tfw_priv->size = 0;\n}\n\nint fw_grow_paged_buf(struct fw_priv *fw_priv, int pages_needed)\n{\n\t \n\tif (fw_priv->page_array_size < pages_needed) {\n\t\tint new_array_size = max(pages_needed,\n\t\t\t\t\t fw_priv->page_array_size * 2);\n\t\tstruct page **new_pages;\n\n\t\tnew_pages = kvmalloc_array(new_array_size, sizeof(void *),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!new_pages)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(new_pages, fw_priv->pages,\n\t\t       fw_priv->page_array_size * sizeof(void *));\n\t\tmemset(&new_pages[fw_priv->page_array_size], 0, sizeof(void *) *\n\t\t       (new_array_size - fw_priv->page_array_size));\n\t\tkvfree(fw_priv->pages);\n\t\tfw_priv->pages = new_pages;\n\t\tfw_priv->page_array_size = new_array_size;\n\t}\n\n\twhile (fw_priv->nr_pages < pages_needed) {\n\t\tfw_priv->pages[fw_priv->nr_pages] =\n\t\t\talloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\n\t\tif (!fw_priv->pages[fw_priv->nr_pages])\n\t\t\treturn -ENOMEM;\n\t\tfw_priv->nr_pages++;\n\t}\n\n\treturn 0;\n}\n\nint fw_map_paged_buf(struct fw_priv *fw_priv)\n{\n\t \n\tif (!fw_priv->pages)\n\t\treturn 0;\n\n\tvunmap(fw_priv->data);\n\tfw_priv->data = vmap(fw_priv->pages, fw_priv->nr_pages, 0,\n\t\t\t     PAGE_KERNEL_RO);\n\tif (!fw_priv->data)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n#endif\n\n \n#ifdef CONFIG_FW_LOADER_COMPRESS_ZSTD\nstatic int fw_decompress_zstd(struct device *dev, struct fw_priv *fw_priv,\n\t\t\t      size_t in_size, const void *in_buffer)\n{\n\tsize_t len, out_size, workspace_size;\n\tvoid *workspace, *out_buf;\n\tzstd_dctx *ctx;\n\tint err;\n\n\tif (fw_priv->allocated_size) {\n\t\tout_size = fw_priv->allocated_size;\n\t\tout_buf = fw_priv->data;\n\t} else {\n\t\tzstd_frame_header params;\n\n\t\tif (zstd_get_frame_header(&params, in_buffer, in_size) ||\n\t\t    params.frameContentSize == ZSTD_CONTENTSIZE_UNKNOWN) {\n\t\t\tdev_dbg(dev, \"%s: invalid zstd header\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tout_size = params.frameContentSize;\n\t\tout_buf = vzalloc(out_size);\n\t\tif (!out_buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tworkspace_size = zstd_dctx_workspace_bound();\n\tworkspace = kvzalloc(workspace_size, GFP_KERNEL);\n\tif (!workspace) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tctx = zstd_init_dctx(workspace, workspace_size);\n\tif (!ctx) {\n\t\tdev_dbg(dev, \"%s: failed to initialize context\\n\", __func__);\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tlen = zstd_decompress_dctx(ctx, out_buf, out_size, in_buffer, in_size);\n\tif (zstd_is_error(len)) {\n\t\tdev_dbg(dev, \"%s: failed to decompress: %d\\n\", __func__,\n\t\t\tzstd_get_error_code(len));\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (!fw_priv->allocated_size)\n\t\tfw_priv->data = out_buf;\n\tfw_priv->size = len;\n\terr = 0;\n\n error:\n\tkvfree(workspace);\n\tif (err && !fw_priv->allocated_size)\n\t\tvfree(out_buf);\n\treturn err;\n}\n#endif  \n\n \n#ifdef CONFIG_FW_LOADER_COMPRESS_XZ\n \nstatic int fw_decompress_xz_error(struct device *dev, enum xz_ret xz_ret)\n{\n\tif (xz_ret != XZ_STREAM_END) {\n\t\tdev_warn(dev, \"xz decompression failed (xz_ret=%d)\\n\", xz_ret);\n\t\treturn xz_ret == XZ_MEM_ERROR ? -ENOMEM : -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int fw_decompress_xz_single(struct device *dev, struct fw_priv *fw_priv,\n\t\t\t\t   size_t in_size, const void *in_buffer)\n{\n\tstruct xz_dec *xz_dec;\n\tstruct xz_buf xz_buf;\n\tenum xz_ret xz_ret;\n\n\txz_dec = xz_dec_init(XZ_SINGLE, (u32)-1);\n\tif (!xz_dec)\n\t\treturn -ENOMEM;\n\n\txz_buf.in_size = in_size;\n\txz_buf.in = in_buffer;\n\txz_buf.in_pos = 0;\n\txz_buf.out_size = fw_priv->allocated_size;\n\txz_buf.out = fw_priv->data;\n\txz_buf.out_pos = 0;\n\n\txz_ret = xz_dec_run(xz_dec, &xz_buf);\n\txz_dec_end(xz_dec);\n\n\tfw_priv->size = xz_buf.out_pos;\n\treturn fw_decompress_xz_error(dev, xz_ret);\n}\n\n \nstatic int fw_decompress_xz_pages(struct device *dev, struct fw_priv *fw_priv,\n\t\t\t\t  size_t in_size, const void *in_buffer)\n{\n\tstruct xz_dec *xz_dec;\n\tstruct xz_buf xz_buf;\n\tenum xz_ret xz_ret;\n\tstruct page *page;\n\tint err = 0;\n\n\txz_dec = xz_dec_init(XZ_DYNALLOC, (u32)-1);\n\tif (!xz_dec)\n\t\treturn -ENOMEM;\n\n\txz_buf.in_size = in_size;\n\txz_buf.in = in_buffer;\n\txz_buf.in_pos = 0;\n\n\tfw_priv->is_paged_buf = true;\n\tfw_priv->size = 0;\n\tdo {\n\t\tif (fw_grow_paged_buf(fw_priv, fw_priv->nr_pages + 1)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tpage = fw_priv->pages[fw_priv->nr_pages - 1];\n\t\txz_buf.out = kmap_local_page(page);\n\t\txz_buf.out_pos = 0;\n\t\txz_buf.out_size = PAGE_SIZE;\n\t\txz_ret = xz_dec_run(xz_dec, &xz_buf);\n\t\tkunmap_local(xz_buf.out);\n\t\tfw_priv->size += xz_buf.out_pos;\n\t\t \n\t\tif (xz_buf.out_pos != PAGE_SIZE)\n\t\t\tbreak;\n\t} while (xz_ret == XZ_OK);\n\n\terr = fw_decompress_xz_error(dev, xz_ret);\n\tif (!err)\n\t\terr = fw_map_paged_buf(fw_priv);\n\n out:\n\txz_dec_end(xz_dec);\n\treturn err;\n}\n\nstatic int fw_decompress_xz(struct device *dev, struct fw_priv *fw_priv,\n\t\t\t    size_t in_size, const void *in_buffer)\n{\n\t \n\tif (fw_priv->data)\n\t\treturn fw_decompress_xz_single(dev, fw_priv, in_size, in_buffer);\n\telse\n\t\treturn fw_decompress_xz_pages(dev, fw_priv, in_size, in_buffer);\n}\n#endif  \n\n \nstatic char fw_path_para[256];\nstatic const char * const fw_path[] = {\n\tfw_path_para,\n\t\"/lib/firmware/updates/\" UTS_RELEASE,\n\t\"/lib/firmware/updates\",\n\t\"/lib/firmware/\" UTS_RELEASE,\n\t\"/lib/firmware\"\n};\n\n \nmodule_param_string(path, fw_path_para, sizeof(fw_path_para), 0644);\nMODULE_PARM_DESC(path, \"customized firmware image search path with a higher priority than default path\");\n\nstatic int\nfw_get_filesystem_firmware(struct device *device, struct fw_priv *fw_priv,\n\t\t\t   const char *suffix,\n\t\t\t   int (*decompress)(struct device *dev,\n\t\t\t\t\t     struct fw_priv *fw_priv,\n\t\t\t\t\t     size_t in_size,\n\t\t\t\t\t     const void *in_buffer))\n{\n\tsize_t size;\n\tint i, len, maxlen = 0;\n\tint rc = -ENOENT;\n\tchar *path, *nt = NULL;\n\tsize_t msize = INT_MAX;\n\tvoid *buffer = NULL;\n\n\t \n\tif (!decompress && fw_priv->data) {\n\t\tbuffer = fw_priv->data;\n\t\tmsize = fw_priv->allocated_size;\n\t}\n\n\tpath = __getname();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twait_for_initramfs();\n\tfor (i = 0; i < ARRAY_SIZE(fw_path); i++) {\n\t\tsize_t file_size = 0;\n\t\tsize_t *file_size_ptr = NULL;\n\n\t\t \n\t\tif (!fw_path[i][0])\n\t\t\tcontinue;\n\n\t\t \n\t\tmaxlen = strlen(fw_path[i]);\n\t\tif (i == 0) {\n\t\t\tnt = strchr(fw_path[i], '\\n');\n\t\t\tif (nt)\n\t\t\t\tmaxlen = nt - fw_path[i];\n\t\t}\n\n\t\tlen = snprintf(path, PATH_MAX, \"%.*s/%s%s\",\n\t\t\t       maxlen, fw_path[i],\n\t\t\t       fw_priv->fw_name, suffix);\n\t\tif (len >= PATH_MAX) {\n\t\t\trc = -ENAMETOOLONG;\n\t\t\tbreak;\n\t\t}\n\n\t\tfw_priv->size = 0;\n\n\t\t \n\t\tif ((fw_priv->opt_flags & FW_OPT_PARTIAL) && buffer)\n\t\t\tfile_size_ptr = &file_size;\n\n\t\t \n\t\trc = kernel_read_file_from_path_initns(path, fw_priv->offset,\n\t\t\t\t\t\t       &buffer, msize,\n\t\t\t\t\t\t       file_size_ptr,\n\t\t\t\t\t\t       READING_FIRMWARE);\n\t\tif (rc < 0) {\n\t\t\tif (rc != -ENOENT)\n\t\t\t\tdev_warn(device, \"loading %s failed with error %d\\n\",\n\t\t\t\t\t path, rc);\n\t\t\telse\n\t\t\t\tdev_dbg(device, \"loading %s failed for no such file or directory.\\n\",\n\t\t\t\t\t path);\n\t\t\tcontinue;\n\t\t}\n\t\tsize = rc;\n\t\trc = 0;\n\n\t\tdev_dbg(device, \"Loading firmware from %s\\n\", path);\n\t\tif (decompress) {\n\t\t\tdev_dbg(device, \"f/w decompressing %s\\n\",\n\t\t\t\tfw_priv->fw_name);\n\t\t\trc = decompress(device, fw_priv, size, buffer);\n\t\t\t \n\t\t\tvfree(buffer);\n\t\t\tbuffer = NULL;\n\t\t\tif (rc) {\n\t\t\t\tfw_free_paged_buf(fw_priv);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_dbg(device, \"direct-loading %s\\n\",\n\t\t\t\tfw_priv->fw_name);\n\t\t\tif (!fw_priv->data)\n\t\t\t\tfw_priv->data = buffer;\n\t\t\tfw_priv->size = size;\n\t\t}\n\t\tfw_state_done(fw_priv);\n\t\tbreak;\n\t}\n\t__putname(path);\n\n\treturn rc;\n}\n\n \nstatic void firmware_free_data(const struct firmware *fw)\n{\n\t \n\tif (!fw->priv) {\n\t\tvfree(fw->data);\n\t\treturn;\n\t}\n\tfree_fw_priv(fw->priv);\n}\n\n \nstatic void fw_set_page_data(struct fw_priv *fw_priv, struct firmware *fw)\n{\n\tfw->priv = fw_priv;\n\tfw->size = fw_priv->size;\n\tfw->data = fw_priv->data;\n\n\tpr_debug(\"%s: fw-%s fw_priv=%p data=%p size=%u\\n\",\n\t\t __func__, fw_priv->fw_name, fw_priv, fw_priv->data,\n\t\t (unsigned int)fw_priv->size);\n}\n\n#ifdef CONFIG_FW_CACHE\nstatic void fw_name_devm_release(struct device *dev, void *res)\n{\n\tstruct fw_name_devm *fwn = res;\n\n\tif (fwn->magic == (unsigned long)&fw_cache)\n\t\tpr_debug(\"%s: fw_name-%s devm-%p released\\n\",\n\t\t\t\t__func__, fwn->name, res);\n\tkfree_const(fwn->name);\n}\n\nstatic int fw_devm_match(struct device *dev, void *res,\n\t\tvoid *match_data)\n{\n\tstruct fw_name_devm *fwn = res;\n\n\treturn (fwn->magic == (unsigned long)&fw_cache) &&\n\t\t!strcmp(fwn->name, match_data);\n}\n\nstatic struct fw_name_devm *fw_find_devm_name(struct device *dev,\n\t\tconst char *name)\n{\n\tstruct fw_name_devm *fwn;\n\n\tfwn = devres_find(dev, fw_name_devm_release,\n\t\t\t  fw_devm_match, (void *)name);\n\treturn fwn;\n}\n\nstatic bool fw_cache_is_setup(struct device *dev, const char *name)\n{\n\tstruct fw_name_devm *fwn;\n\n\tfwn = fw_find_devm_name(dev, name);\n\tif (fwn)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int fw_add_devm_name(struct device *dev, const char *name)\n{\n\tstruct fw_name_devm *fwn;\n\n\tif (fw_cache_is_setup(dev, name))\n\t\treturn 0;\n\n\tfwn = devres_alloc(fw_name_devm_release, sizeof(struct fw_name_devm),\n\t\t\t   GFP_KERNEL);\n\tif (!fwn)\n\t\treturn -ENOMEM;\n\tfwn->name = kstrdup_const(name, GFP_KERNEL);\n\tif (!fwn->name) {\n\t\tdevres_free(fwn);\n\t\treturn -ENOMEM;\n\t}\n\n\tfwn->magic = (unsigned long)&fw_cache;\n\tdevres_add(dev, fwn);\n\n\treturn 0;\n}\n#else\nstatic bool fw_cache_is_setup(struct device *dev, const char *name)\n{\n\treturn false;\n}\n\nstatic int fw_add_devm_name(struct device *dev, const char *name)\n{\n\treturn 0;\n}\n#endif\n\nint assign_fw(struct firmware *fw, struct device *device)\n{\n\tstruct fw_priv *fw_priv = fw->priv;\n\tint ret;\n\n\tmutex_lock(&fw_lock);\n\tif (!fw_priv->size || fw_state_is_aborted(fw_priv)) {\n\t\tmutex_unlock(&fw_lock);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\t \n\tif (device && (fw_priv->opt_flags & FW_OPT_UEVENT) &&\n\t    !(fw_priv->opt_flags & FW_OPT_NOCACHE)) {\n\t\tret = fw_add_devm_name(device, fw_priv->fw_name);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&fw_lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (!(fw_priv->opt_flags & FW_OPT_NOCACHE) &&\n\t    fw_priv->fwc->state == FW_LOADER_START_CACHE)\n\t\tfw_cache_piggyback_on_request(fw_priv);\n\n\t \n\tfw_set_page_data(fw_priv, fw);\n\tmutex_unlock(&fw_lock);\n\treturn 0;\n}\n\n \nstatic int\n_request_firmware_prepare(struct firmware **firmware_p, const char *name,\n\t\t\t  struct device *device, void *dbuf, size_t size,\n\t\t\t  size_t offset, u32 opt_flags)\n{\n\tstruct firmware *firmware;\n\tstruct fw_priv *fw_priv;\n\tint ret;\n\n\t*firmware_p = firmware = kzalloc(sizeof(*firmware), GFP_KERNEL);\n\tif (!firmware) {\n\t\tdev_err(device, \"%s: kmalloc(struct firmware) failed\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (firmware_request_builtin_buf(firmware, name, dbuf, size)) {\n\t\tdev_dbg(device, \"using built-in %s\\n\", name);\n\t\treturn 0;  \n\t}\n\n\tret = alloc_lookup_fw_priv(name, &fw_cache, &fw_priv, dbuf, size,\n\t\t\t\t   offset, opt_flags);\n\n\t \n\tfirmware->priv = fw_priv;\n\n\tif (ret > 0) {\n\t\tret = fw_state_wait(fw_priv);\n\t\tif (!ret) {\n\t\t\tfw_set_page_data(fw_priv, firmware);\n\t\t\treturn 0;  \n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 1;  \n}\n\n \nstatic void fw_abort_batch_reqs(struct firmware *fw)\n{\n\tstruct fw_priv *fw_priv;\n\n\t \n\tif (!fw || !fw->priv)\n\t\treturn;\n\n\tfw_priv = fw->priv;\n\tmutex_lock(&fw_lock);\n\tif (!fw_state_is_aborted(fw_priv))\n\t\tfw_state_aborted(fw_priv);\n\tmutex_unlock(&fw_lock);\n}\n\n#if defined(CONFIG_FW_LOADER_DEBUG)\n#include <crypto/hash.h>\n#include <crypto/sha2.h>\n\nstatic void fw_log_firmware_info(const struct firmware *fw, const char *name, struct device *device)\n{\n\tstruct shash_desc *shash;\n\tstruct crypto_shash *alg;\n\tu8 *sha256buf;\n\tchar *outbuf;\n\n\talg = crypto_alloc_shash(\"sha256\", 0, 0);\n\tif (IS_ERR(alg))\n\t\treturn;\n\n\tsha256buf = kmalloc(SHA256_DIGEST_SIZE, GFP_KERNEL);\n\toutbuf = kmalloc(SHA256_BLOCK_SIZE + 1, GFP_KERNEL);\n\tshash = kmalloc(sizeof(*shash) + crypto_shash_descsize(alg), GFP_KERNEL);\n\tif (!sha256buf || !outbuf || !shash)\n\t\tgoto out_free;\n\n\tshash->tfm = alg;\n\n\tif (crypto_shash_digest(shash, fw->data, fw->size, sha256buf) < 0)\n\t\tgoto out_shash;\n\n\tfor (int i = 0; i < SHA256_DIGEST_SIZE; i++)\n\t\tsprintf(&outbuf[i * 2], \"%02x\", sha256buf[i]);\n\toutbuf[SHA256_BLOCK_SIZE] = 0;\n\tdev_dbg(device, \"Loaded FW: %s, sha256: %s\\n\", name, outbuf);\n\nout_shash:\n\tcrypto_free_shash(alg);\nout_free:\n\tkfree(shash);\n\tkfree(outbuf);\n\tkfree(sha256buf);\n}\n#else\nstatic void fw_log_firmware_info(const struct firmware *fw, const char *name,\n\t\t\t\t struct device *device)\n{}\n#endif\n\n \nstatic int\n_request_firmware(const struct firmware **firmware_p, const char *name,\n\t\t  struct device *device, void *buf, size_t size,\n\t\t  size_t offset, u32 opt_flags)\n{\n\tstruct firmware *fw = NULL;\n\tstruct cred *kern_cred = NULL;\n\tconst struct cred *old_cred;\n\tbool nondirect = false;\n\tint ret;\n\n\tif (!firmware_p)\n\t\treturn -EINVAL;\n\n\tif (!name || name[0] == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = _request_firmware_prepare(&fw, name, device, buf, size,\n\t\t\t\t\toffset, opt_flags);\n\tif (ret <= 0)  \n\t\tgoto out;\n\n\t \n\tkern_cred = prepare_kernel_cred(&init_task);\n\tif (!kern_cred) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\told_cred = override_creds(kern_cred);\n\n\tret = fw_get_filesystem_firmware(device, fw->priv, \"\", NULL);\n\n\t \n\tif (!(opt_flags & FW_OPT_PARTIAL))\n\t\tnondirect = true;\n\n#ifdef CONFIG_FW_LOADER_COMPRESS_ZSTD\n\tif (ret == -ENOENT && nondirect)\n\t\tret = fw_get_filesystem_firmware(device, fw->priv, \".zst\",\n\t\t\t\t\t\t fw_decompress_zstd);\n#endif\n#ifdef CONFIG_FW_LOADER_COMPRESS_XZ\n\tif (ret == -ENOENT && nondirect)\n\t\tret = fw_get_filesystem_firmware(device, fw->priv, \".xz\",\n\t\t\t\t\t\t fw_decompress_xz);\n#endif\n\tif (ret == -ENOENT && nondirect)\n\t\tret = firmware_fallback_platform(fw->priv);\n\n\tif (ret) {\n\t\tif (!(opt_flags & FW_OPT_NO_WARN))\n\t\t\tdev_warn(device,\n\t\t\t\t \"Direct firmware load for %s failed with error %d\\n\",\n\t\t\t\t name, ret);\n\t\tif (nondirect)\n\t\t\tret = firmware_fallback_sysfs(fw, name, device,\n\t\t\t\t\t\t      opt_flags, ret);\n\t} else\n\t\tret = assign_fw(fw, device);\n\n\trevert_creds(old_cred);\n\tput_cred(kern_cred);\n\nout:\n\tif (ret < 0) {\n\t\tfw_abort_batch_reqs(fw);\n\t\trelease_firmware(fw);\n\t\tfw = NULL;\n\t} else {\n\t\tfw_log_firmware_info(fw, name, device);\n\t}\n\n\t*firmware_p = fw;\n\treturn ret;\n}\n\n \nint\nrequest_firmware(const struct firmware **firmware_p, const char *name,\n\t\t struct device *device)\n{\n\tint ret;\n\n\t \n\t__module_get(THIS_MODULE);\n\tret = _request_firmware(firmware_p, name, device, NULL, 0, 0,\n\t\t\t\tFW_OPT_UEVENT);\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}\nEXPORT_SYMBOL(request_firmware);\n\n \nint firmware_request_nowarn(const struct firmware **firmware, const char *name,\n\t\t\t    struct device *device)\n{\n\tint ret;\n\n\t \n\t__module_get(THIS_MODULE);\n\tret = _request_firmware(firmware, name, device, NULL, 0, 0,\n\t\t\t\tFW_OPT_UEVENT | FW_OPT_NO_WARN);\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(firmware_request_nowarn);\n\n \nint request_firmware_direct(const struct firmware **firmware_p,\n\t\t\t    const char *name, struct device *device)\n{\n\tint ret;\n\n\t__module_get(THIS_MODULE);\n\tret = _request_firmware(firmware_p, name, device, NULL, 0, 0,\n\t\t\t\tFW_OPT_UEVENT | FW_OPT_NO_WARN |\n\t\t\t\tFW_OPT_NOFALLBACK_SYSFS);\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(request_firmware_direct);\n\n \nint firmware_request_platform(const struct firmware **firmware,\n\t\t\t      const char *name, struct device *device)\n{\n\tint ret;\n\n\t \n\t__module_get(THIS_MODULE);\n\tret = _request_firmware(firmware, name, device, NULL, 0, 0,\n\t\t\t\tFW_OPT_UEVENT | FW_OPT_FALLBACK_PLATFORM);\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(firmware_request_platform);\n\n \nint firmware_request_cache(struct device *device, const char *name)\n{\n\tint ret;\n\n\tmutex_lock(&fw_lock);\n\tret = fw_add_devm_name(device, name);\n\tmutex_unlock(&fw_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(firmware_request_cache);\n\n \nint\nrequest_firmware_into_buf(const struct firmware **firmware_p, const char *name,\n\t\t\t  struct device *device, void *buf, size_t size)\n{\n\tint ret;\n\n\tif (fw_cache_is_setup(device, name))\n\t\treturn -EOPNOTSUPP;\n\n\t__module_get(THIS_MODULE);\n\tret = _request_firmware(firmware_p, name, device, buf, size, 0,\n\t\t\t\tFW_OPT_UEVENT | FW_OPT_NOCACHE);\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}\nEXPORT_SYMBOL(request_firmware_into_buf);\n\n \nint\nrequest_partial_firmware_into_buf(const struct firmware **firmware_p,\n\t\t\t\t  const char *name, struct device *device,\n\t\t\t\t  void *buf, size_t size, size_t offset)\n{\n\tint ret;\n\n\tif (fw_cache_is_setup(device, name))\n\t\treturn -EOPNOTSUPP;\n\n\t__module_get(THIS_MODULE);\n\tret = _request_firmware(firmware_p, name, device, buf, size, offset,\n\t\t\t\tFW_OPT_UEVENT | FW_OPT_NOCACHE |\n\t\t\t\tFW_OPT_PARTIAL);\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}\nEXPORT_SYMBOL(request_partial_firmware_into_buf);\n\n \nvoid release_firmware(const struct firmware *fw)\n{\n\tif (fw) {\n\t\tif (!firmware_is_builtin(fw))\n\t\t\tfirmware_free_data(fw);\n\t\tkfree(fw);\n\t}\n}\nEXPORT_SYMBOL(release_firmware);\n\n \nstruct firmware_work {\n\tstruct work_struct work;\n\tstruct module *module;\n\tconst char *name;\n\tstruct device *device;\n\tvoid *context;\n\tvoid (*cont)(const struct firmware *fw, void *context);\n\tu32 opt_flags;\n};\n\nstatic void request_firmware_work_func(struct work_struct *work)\n{\n\tstruct firmware_work *fw_work;\n\tconst struct firmware *fw;\n\n\tfw_work = container_of(work, struct firmware_work, work);\n\n\t_request_firmware(&fw, fw_work->name, fw_work->device, NULL, 0, 0,\n\t\t\t  fw_work->opt_flags);\n\tfw_work->cont(fw, fw_work->context);\n\tput_device(fw_work->device);  \n\n\tmodule_put(fw_work->module);\n\tkfree_const(fw_work->name);\n\tkfree(fw_work);\n}\n\n \nint\nrequest_firmware_nowait(\n\tstruct module *module, bool uevent,\n\tconst char *name, struct device *device, gfp_t gfp, void *context,\n\tvoid (*cont)(const struct firmware *fw, void *context))\n{\n\tstruct firmware_work *fw_work;\n\n\tfw_work = kzalloc(sizeof(struct firmware_work), gfp);\n\tif (!fw_work)\n\t\treturn -ENOMEM;\n\n\tfw_work->module = module;\n\tfw_work->name = kstrdup_const(name, gfp);\n\tif (!fw_work->name) {\n\t\tkfree(fw_work);\n\t\treturn -ENOMEM;\n\t}\n\tfw_work->device = device;\n\tfw_work->context = context;\n\tfw_work->cont = cont;\n\tfw_work->opt_flags = FW_OPT_NOWAIT |\n\t\t(uevent ? FW_OPT_UEVENT : FW_OPT_USERHELPER);\n\n\tif (!uevent && fw_cache_is_setup(device, name)) {\n\t\tkfree_const(fw_work->name);\n\t\tkfree(fw_work);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!try_module_get(module)) {\n\t\tkfree_const(fw_work->name);\n\t\tkfree(fw_work);\n\t\treturn -EFAULT;\n\t}\n\n\tget_device(fw_work->device);\n\tINIT_WORK(&fw_work->work, request_firmware_work_func);\n\tschedule_work(&fw_work->work);\n\treturn 0;\n}\nEXPORT_SYMBOL(request_firmware_nowait);\n\n#ifdef CONFIG_FW_CACHE\nstatic ASYNC_DOMAIN_EXCLUSIVE(fw_cache_domain);\n\n \nstatic int cache_firmware(const char *fw_name)\n{\n\tint ret;\n\tconst struct firmware *fw;\n\n\tpr_debug(\"%s: %s\\n\", __func__, fw_name);\n\n\tret = request_firmware(&fw, fw_name, NULL);\n\tif (!ret)\n\t\tkfree(fw);\n\n\tpr_debug(\"%s: %s ret=%d\\n\", __func__, fw_name, ret);\n\n\treturn ret;\n}\n\nstatic struct fw_priv *lookup_fw_priv(const char *fw_name)\n{\n\tstruct fw_priv *tmp;\n\tstruct firmware_cache *fwc = &fw_cache;\n\n\tspin_lock(&fwc->lock);\n\ttmp = __lookup_fw_priv(fw_name);\n\tspin_unlock(&fwc->lock);\n\n\treturn tmp;\n}\n\n \nstatic int uncache_firmware(const char *fw_name)\n{\n\tstruct fw_priv *fw_priv;\n\tstruct firmware fw;\n\n\tpr_debug(\"%s: %s\\n\", __func__, fw_name);\n\n\tif (firmware_request_builtin(&fw, fw_name))\n\t\treturn 0;\n\n\tfw_priv = lookup_fw_priv(fw_name);\n\tif (fw_priv) {\n\t\tfree_fw_priv(fw_priv);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic struct fw_cache_entry *alloc_fw_cache_entry(const char *name)\n{\n\tstruct fw_cache_entry *fce;\n\n\tfce = kzalloc(sizeof(*fce), GFP_ATOMIC);\n\tif (!fce)\n\t\tgoto exit;\n\n\tfce->name = kstrdup_const(name, GFP_ATOMIC);\n\tif (!fce->name) {\n\t\tkfree(fce);\n\t\tfce = NULL;\n\t\tgoto exit;\n\t}\nexit:\n\treturn fce;\n}\n\nstatic int __fw_entry_found(const char *name)\n{\n\tstruct firmware_cache *fwc = &fw_cache;\n\tstruct fw_cache_entry *fce;\n\n\tlist_for_each_entry(fce, &fwc->fw_names, list) {\n\t\tif (!strcmp(fce->name, name))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void fw_cache_piggyback_on_request(struct fw_priv *fw_priv)\n{\n\tconst char *name = fw_priv->fw_name;\n\tstruct firmware_cache *fwc = fw_priv->fwc;\n\tstruct fw_cache_entry *fce;\n\n\tspin_lock(&fwc->name_lock);\n\tif (__fw_entry_found(name))\n\t\tgoto found;\n\n\tfce = alloc_fw_cache_entry(name);\n\tif (fce) {\n\t\tlist_add(&fce->list, &fwc->fw_names);\n\t\tkref_get(&fw_priv->ref);\n\t\tpr_debug(\"%s: fw: %s\\n\", __func__, name);\n\t}\nfound:\n\tspin_unlock(&fwc->name_lock);\n}\n\nstatic void free_fw_cache_entry(struct fw_cache_entry *fce)\n{\n\tkfree_const(fce->name);\n\tkfree(fce);\n}\n\nstatic void __async_dev_cache_fw_image(void *fw_entry,\n\t\t\t\t       async_cookie_t cookie)\n{\n\tstruct fw_cache_entry *fce = fw_entry;\n\tstruct firmware_cache *fwc = &fw_cache;\n\tint ret;\n\n\tret = cache_firmware(fce->name);\n\tif (ret) {\n\t\tspin_lock(&fwc->name_lock);\n\t\tlist_del(&fce->list);\n\t\tspin_unlock(&fwc->name_lock);\n\n\t\tfree_fw_cache_entry(fce);\n\t}\n}\n\n \nstatic void dev_create_fw_entry(struct device *dev, void *res,\n\t\t\t\tvoid *data)\n{\n\tstruct fw_name_devm *fwn = res;\n\tconst char *fw_name = fwn->name;\n\tstruct list_head *head = data;\n\tstruct fw_cache_entry *fce;\n\n\tfce = alloc_fw_cache_entry(fw_name);\n\tif (fce)\n\t\tlist_add(&fce->list, head);\n}\n\nstatic int devm_name_match(struct device *dev, void *res,\n\t\t\t   void *match_data)\n{\n\tstruct fw_name_devm *fwn = res;\n\treturn (fwn->magic == (unsigned long)match_data);\n}\n\nstatic void dev_cache_fw_image(struct device *dev, void *data)\n{\n\tLIST_HEAD(todo);\n\tstruct fw_cache_entry *fce;\n\tstruct fw_cache_entry *fce_next;\n\tstruct firmware_cache *fwc = &fw_cache;\n\n\tdevres_for_each_res(dev, fw_name_devm_release,\n\t\t\t    devm_name_match, &fw_cache,\n\t\t\t    dev_create_fw_entry, &todo);\n\n\tlist_for_each_entry_safe(fce, fce_next, &todo, list) {\n\t\tlist_del(&fce->list);\n\n\t\tspin_lock(&fwc->name_lock);\n\t\t \n\t\tif (!__fw_entry_found(fce->name)) {\n\t\t\tlist_add(&fce->list, &fwc->fw_names);\n\t\t} else {\n\t\t\tfree_fw_cache_entry(fce);\n\t\t\tfce = NULL;\n\t\t}\n\t\tspin_unlock(&fwc->name_lock);\n\n\t\tif (fce)\n\t\t\tasync_schedule_domain(__async_dev_cache_fw_image,\n\t\t\t\t\t      (void *)fce,\n\t\t\t\t\t      &fw_cache_domain);\n\t}\n}\n\nstatic void __device_uncache_fw_images(void)\n{\n\tstruct firmware_cache *fwc = &fw_cache;\n\tstruct fw_cache_entry *fce;\n\n\tspin_lock(&fwc->name_lock);\n\twhile (!list_empty(&fwc->fw_names)) {\n\t\tfce = list_entry(fwc->fw_names.next,\n\t\t\t\tstruct fw_cache_entry, list);\n\t\tlist_del(&fce->list);\n\t\tspin_unlock(&fwc->name_lock);\n\n\t\tuncache_firmware(fce->name);\n\t\tfree_fw_cache_entry(fce);\n\n\t\tspin_lock(&fwc->name_lock);\n\t}\n\tspin_unlock(&fwc->name_lock);\n}\n\n \nstatic void device_cache_fw_images(void)\n{\n\tstruct firmware_cache *fwc = &fw_cache;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\t \n\tcancel_delayed_work_sync(&fwc->work);\n\n\tfw_fallback_set_cache_timeout();\n\n\tmutex_lock(&fw_lock);\n\tfwc->state = FW_LOADER_START_CACHE;\n\tdpm_for_each_dev(NULL, dev_cache_fw_image);\n\tmutex_unlock(&fw_lock);\n\n\t \n\tasync_synchronize_full_domain(&fw_cache_domain);\n\n\tfw_fallback_set_default_timeout();\n}\n\n \nstatic void device_uncache_fw_images(void)\n{\n\tpr_debug(\"%s\\n\", __func__);\n\t__device_uncache_fw_images();\n}\n\nstatic void device_uncache_fw_images_work(struct work_struct *work)\n{\n\tdevice_uncache_fw_images();\n}\n\n \nstatic void device_uncache_fw_images_delay(unsigned long delay)\n{\n\tqueue_delayed_work(system_power_efficient_wq, &fw_cache.work,\n\t\t\t   msecs_to_jiffies(delay));\n}\n\nstatic int fw_pm_notify(struct notifier_block *notify_block,\n\t\t\tunsigned long mode, void *unused)\n{\n\tswitch (mode) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\tcase PM_RESTORE_PREPARE:\n\t\t \n\t\tkill_pending_fw_fallback_reqs(true);\n\t\tdevice_cache_fw_images();\n\t\tbreak;\n\n\tcase PM_POST_SUSPEND:\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_RESTORE:\n\t\t \n\t\tmutex_lock(&fw_lock);\n\t\tfw_cache.state = FW_LOADER_NO_CACHE;\n\t\tmutex_unlock(&fw_lock);\n\n\t\tdevice_uncache_fw_images_delay(10 * MSEC_PER_SEC);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fw_suspend(void)\n{\n\tfw_cache.state = FW_LOADER_NO_CACHE;\n\treturn 0;\n}\n\nstatic struct syscore_ops fw_syscore_ops = {\n\t.suspend = fw_suspend,\n};\n\nstatic int __init register_fw_pm_ops(void)\n{\n\tint ret;\n\n\tspin_lock_init(&fw_cache.name_lock);\n\tINIT_LIST_HEAD(&fw_cache.fw_names);\n\n\tINIT_DELAYED_WORK(&fw_cache.work,\n\t\t\t  device_uncache_fw_images_work);\n\n\tfw_cache.pm_notify.notifier_call = fw_pm_notify;\n\tret = register_pm_notifier(&fw_cache.pm_notify);\n\tif (ret)\n\t\treturn ret;\n\n\tregister_syscore_ops(&fw_syscore_ops);\n\n\treturn ret;\n}\n\nstatic inline void unregister_fw_pm_ops(void)\n{\n\tunregister_syscore_ops(&fw_syscore_ops);\n\tunregister_pm_notifier(&fw_cache.pm_notify);\n}\n#else\nstatic void fw_cache_piggyback_on_request(struct fw_priv *fw_priv)\n{\n}\nstatic inline int register_fw_pm_ops(void)\n{\n\treturn 0;\n}\nstatic inline void unregister_fw_pm_ops(void)\n{\n}\n#endif\n\nstatic void __init fw_cache_init(void)\n{\n\tspin_lock_init(&fw_cache.lock);\n\tINIT_LIST_HEAD(&fw_cache.head);\n\tfw_cache.state = FW_LOADER_NO_CACHE;\n}\n\nstatic int fw_shutdown_notify(struct notifier_block *unused1,\n\t\t\t      unsigned long unused2, void *unused3)\n{\n\t \n\tkill_pending_fw_fallback_reqs(false);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block fw_shutdown_nb = {\n\t.notifier_call = fw_shutdown_notify,\n};\n\nstatic int __init firmware_class_init(void)\n{\n\tint ret;\n\n\t \n\tfw_cache_init();\n\n\tret = register_fw_pm_ops();\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_reboot_notifier(&fw_shutdown_nb);\n\tif (ret)\n\t\tgoto out;\n\n\treturn register_sysfs_loader();\n\nout:\n\tunregister_fw_pm_ops();\n\treturn ret;\n}\n\nstatic void __exit firmware_class_exit(void)\n{\n\tunregister_fw_pm_ops();\n\tunregister_reboot_notifier(&fw_shutdown_nb);\n\tunregister_sysfs_loader();\n}\n\nfs_initcall(firmware_class_init);\nmodule_exit(firmware_class_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}