{
  "module_name": "isa.c",
  "hash_id": "2cd334b9616cd19aed531578c1801474b9f1a11747b2a6f29ae66ea0bc781a1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/isa.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/dma-mapping.h>\n#include <linux/isa.h>\n\nstatic struct device isa_bus = {\n\t.init_name\t= \"isa\"\n};\n\nstruct isa_dev {\n\tstruct device dev;\n\tstruct device *next;\n\tunsigned int id;\n};\n\n#define to_isa_dev(x) container_of((x), struct isa_dev, dev)\n\nstatic int isa_bus_match(struct device *dev, struct device_driver *driver)\n{\n\tstruct isa_driver *isa_driver = to_isa_driver(driver);\n\n\tif (dev->platform_data == isa_driver) {\n\t\tif (!isa_driver->match ||\n\t\t\tisa_driver->match(dev, to_isa_dev(dev)->id))\n\t\t\treturn 1;\n\t\tdev->platform_data = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int isa_bus_probe(struct device *dev)\n{\n\tstruct isa_driver *isa_driver = dev->platform_data;\n\n\tif (isa_driver && isa_driver->probe)\n\t\treturn isa_driver->probe(dev, to_isa_dev(dev)->id);\n\n\treturn 0;\n}\n\nstatic void isa_bus_remove(struct device *dev)\n{\n\tstruct isa_driver *isa_driver = dev->platform_data;\n\n\tif (isa_driver && isa_driver->remove)\n\t\tisa_driver->remove(dev, to_isa_dev(dev)->id);\n}\n\nstatic void isa_bus_shutdown(struct device *dev)\n{\n\tstruct isa_driver *isa_driver = dev->platform_data;\n\n\tif (isa_driver && isa_driver->shutdown)\n\t\tisa_driver->shutdown(dev, to_isa_dev(dev)->id);\n}\n\nstatic int isa_bus_suspend(struct device *dev, pm_message_t state)\n{\n\tstruct isa_driver *isa_driver = dev->platform_data;\n\n\tif (isa_driver && isa_driver->suspend)\n\t\treturn isa_driver->suspend(dev, to_isa_dev(dev)->id, state);\n\n\treturn 0;\n}\n\nstatic int isa_bus_resume(struct device *dev)\n{\n\tstruct isa_driver *isa_driver = dev->platform_data;\n\n\tif (isa_driver && isa_driver->resume)\n\t\treturn isa_driver->resume(dev, to_isa_dev(dev)->id);\n\n\treturn 0;\n}\n\nstatic struct bus_type isa_bus_type = {\n\t.name\t\t= \"isa\",\n\t.match\t\t= isa_bus_match,\n\t.probe\t\t= isa_bus_probe,\n\t.remove\t\t= isa_bus_remove,\n\t.shutdown\t= isa_bus_shutdown,\n\t.suspend\t= isa_bus_suspend,\n\t.resume\t\t= isa_bus_resume\n};\n\nstatic void isa_dev_release(struct device *dev)\n{\n\tkfree(to_isa_dev(dev));\n}\n\nvoid isa_unregister_driver(struct isa_driver *isa_driver)\n{\n\tstruct device *dev = isa_driver->devices;\n\n\twhile (dev) {\n\t\tstruct device *tmp = to_isa_dev(dev)->next;\n\t\tdevice_unregister(dev);\n\t\tdev = tmp;\n\t}\n\tdriver_unregister(&isa_driver->driver);\n}\nEXPORT_SYMBOL_GPL(isa_unregister_driver);\n\nint isa_register_driver(struct isa_driver *isa_driver, unsigned int ndev)\n{\n\tint error;\n\tunsigned int id;\n\n\tisa_driver->driver.bus\t= &isa_bus_type;\n\tisa_driver->devices\t= NULL;\n\n\terror = driver_register(&isa_driver->driver);\n\tif (error)\n\t\treturn error;\n\n\tfor (id = 0; id < ndev; id++) {\n\t\tstruct isa_dev *isa_dev;\n\n\t\tisa_dev = kzalloc(sizeof *isa_dev, GFP_KERNEL);\n\t\tif (!isa_dev) {\n\t\t\terror = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tisa_dev->dev.parent\t= &isa_bus;\n\t\tisa_dev->dev.bus\t= &isa_bus_type;\n\n\t\tdev_set_name(&isa_dev->dev, \"%s.%u\",\n\t\t\t     isa_driver->driver.name, id);\n\t\tisa_dev->dev.platform_data\t= isa_driver;\n\t\tisa_dev->dev.release\t\t= isa_dev_release;\n\t\tisa_dev->id\t\t\t= id;\n\n\t\tisa_dev->dev.coherent_dma_mask = DMA_BIT_MASK(24);\n\t\tisa_dev->dev.dma_mask = &isa_dev->dev.coherent_dma_mask;\n\n\t\terror = device_register(&isa_dev->dev);\n\t\tif (error) {\n\t\t\tput_device(&isa_dev->dev);\n\t\t\tbreak;\n\t\t}\n\n\t\tisa_dev->next = isa_driver->devices;\n\t\tisa_driver->devices = &isa_dev->dev;\n\t}\n\n\tif (!error && !isa_driver->devices)\n\t\terror = -ENODEV;\n\n\tif (error)\n\t\tisa_unregister_driver(isa_driver);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(isa_register_driver);\n\nstatic int __init isa_bus_init(void)\n{\n\tint error;\n\n\terror = bus_register(&isa_bus_type);\n\tif (!error) {\n\t\terror = device_register(&isa_bus);\n\t\tif (error)\n\t\t\tbus_unregister(&isa_bus_type);\n\t}\n\treturn error;\n}\n\npostcore_initcall(isa_bus_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}