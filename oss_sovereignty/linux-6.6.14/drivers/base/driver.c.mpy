{
  "module_name": "driver.c",
  "hash_id": "169938bfb790ea67971983317aed6ea2c5552cb358580bc4c9478571fec59088",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/driver.c",
  "human_readable_source": "\n \n\n#include <linux/device/driver.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/sysfs.h>\n#include \"base.h\"\n\nstatic struct device *next_device(struct klist_iter *i)\n{\n\tstruct klist_node *n = klist_next(i);\n\tstruct device *dev = NULL;\n\tstruct device_private *dev_prv;\n\n\tif (n) {\n\t\tdev_prv = to_device_private_driver(n);\n\t\tdev = dev_prv->device;\n\t}\n\treturn dev;\n}\n\n \nint driver_set_override(struct device *dev, const char **override,\n\t\t\tconst char *s, size_t len)\n{\n\tconst char *new, *old;\n\tchar *cp;\n\n\tif (!override || !s)\n\t\treturn -EINVAL;\n\n\t \n\tif (len >= (PAGE_SIZE - 1))\n\t\treturn -EINVAL;\n\n\t \n\tlen = strlen(s);\n\n\tif (!len) {\n\t\t \n\t\tdevice_lock(dev);\n\t\told = *override;\n\t\t*override = NULL;\n\t\tdevice_unlock(dev);\n\t\tkfree(old);\n\n\t\treturn 0;\n\t}\n\n\tcp = strnchr(s, len, '\\n');\n\tif (cp)\n\t\tlen = cp - s;\n\n\tnew = kstrndup(s, len, GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tdevice_lock(dev);\n\told = *override;\n\tif (cp != s) {\n\t\t*override = new;\n\t} else {\n\t\t \n\t\tkfree(new);\n\t\t*override = NULL;\n\t}\n\tdevice_unlock(dev);\n\n\tkfree(old);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(driver_set_override);\n\n \nint driver_for_each_device(struct device_driver *drv, struct device *start,\n\t\t\t   void *data, int (*fn)(struct device *, void *))\n{\n\tstruct klist_iter i;\n\tstruct device *dev;\n\tint error = 0;\n\n\tif (!drv)\n\t\treturn -EINVAL;\n\n\tklist_iter_init_node(&drv->p->klist_devices, &i,\n\t\t\t     start ? &start->p->knode_driver : NULL);\n\twhile (!error && (dev = next_device(&i)))\n\t\terror = fn(dev, data);\n\tklist_iter_exit(&i);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(driver_for_each_device);\n\n \nstruct device *driver_find_device(struct device_driver *drv,\n\t\t\t\t  struct device *start, const void *data,\n\t\t\t\t  int (*match)(struct device *dev, const void *data))\n{\n\tstruct klist_iter i;\n\tstruct device *dev;\n\n\tif (!drv || !drv->p)\n\t\treturn NULL;\n\n\tklist_iter_init_node(&drv->p->klist_devices, &i,\n\t\t\t     (start ? &start->p->knode_driver : NULL));\n\twhile ((dev = next_device(&i)))\n\t\tif (match(dev, data) && get_device(dev))\n\t\t\tbreak;\n\tklist_iter_exit(&i);\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(driver_find_device);\n\n \nint driver_create_file(struct device_driver *drv,\n\t\t       const struct driver_attribute *attr)\n{\n\tint error;\n\n\tif (drv)\n\t\terror = sysfs_create_file(&drv->p->kobj, &attr->attr);\n\telse\n\t\terror = -EINVAL;\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(driver_create_file);\n\n \nvoid driver_remove_file(struct device_driver *drv,\n\t\t\tconst struct driver_attribute *attr)\n{\n\tif (drv)\n\t\tsysfs_remove_file(&drv->p->kobj, &attr->attr);\n}\nEXPORT_SYMBOL_GPL(driver_remove_file);\n\nint driver_add_groups(struct device_driver *drv,\n\t\t      const struct attribute_group **groups)\n{\n\treturn sysfs_create_groups(&drv->p->kobj, groups);\n}\n\nvoid driver_remove_groups(struct device_driver *drv,\n\t\t\t  const struct attribute_group **groups)\n{\n\tsysfs_remove_groups(&drv->p->kobj, groups);\n}\n\n \nint driver_register(struct device_driver *drv)\n{\n\tint ret;\n\tstruct device_driver *other;\n\n\tif (!bus_is_registered(drv->bus)) {\n\t\tpr_err(\"Driver '%s' was unable to register with bus_type '%s' because the bus was not initialized.\\n\",\n\t\t\t   drv->name, drv->bus->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((drv->bus->probe && drv->probe) ||\n\t    (drv->bus->remove && drv->remove) ||\n\t    (drv->bus->shutdown && drv->shutdown))\n\t\tpr_warn(\"Driver '%s' needs updating - please use \"\n\t\t\t\"bus_type methods\\n\", drv->name);\n\n\tother = driver_find(drv->name, drv->bus);\n\tif (other) {\n\t\tpr_err(\"Error: Driver '%s' is already registered, \"\n\t\t\t\"aborting...\\n\", drv->name);\n\t\treturn -EBUSY;\n\t}\n\n\tret = bus_add_driver(drv);\n\tif (ret)\n\t\treturn ret;\n\tret = driver_add_groups(drv, drv->groups);\n\tif (ret) {\n\t\tbus_remove_driver(drv);\n\t\treturn ret;\n\t}\n\tkobject_uevent(&drv->p->kobj, KOBJ_ADD);\n\tdeferred_probe_extend_timeout();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(driver_register);\n\n \nvoid driver_unregister(struct device_driver *drv)\n{\n\tif (!drv || !drv->p) {\n\t\tWARN(1, \"Unexpected driver unregister!\\n\");\n\t\treturn;\n\t}\n\tdriver_remove_groups(drv, drv->groups);\n\tbus_remove_driver(drv);\n}\nEXPORT_SYMBOL_GPL(driver_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}