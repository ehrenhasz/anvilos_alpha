{
  "module_name": "node.c",
  "hash_id": "02d5197c514a4cd0b51c53183e910aee2f91560a02aeae7707a6ed6d301a648d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/node.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/vmstat.h>\n#include <linux/notifier.h>\n#include <linux/node.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/cpumask.h>\n#include <linux/topology.h>\n#include <linux/nodemask.h>\n#include <linux/cpu.h>\n#include <linux/device.h>\n#include <linux/pm_runtime.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n\nstatic struct bus_type node_subsys = {\n\t.name = \"node\",\n\t.dev_name = \"node\",\n};\n\nstatic inline ssize_t cpumap_read(struct file *file, struct kobject *kobj,\n\t\t\t\t  struct bin_attribute *attr, char *buf,\n\t\t\t\t  loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct node *node_dev = to_node(dev);\n\tcpumask_var_t mask;\n\tssize_t n;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn 0;\n\n\tcpumask_and(mask, cpumask_of_node(node_dev->dev.id), cpu_online_mask);\n\tn = cpumap_print_bitmask_to_buf(buf, mask, off, count);\n\tfree_cpumask_var(mask);\n\n\treturn n;\n}\n\nstatic BIN_ATTR_RO(cpumap, CPUMAP_FILE_MAX_BYTES);\n\nstatic inline ssize_t cpulist_read(struct file *file, struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *attr, char *buf,\n\t\t\t\t   loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct node *node_dev = to_node(dev);\n\tcpumask_var_t mask;\n\tssize_t n;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn 0;\n\n\tcpumask_and(mask, cpumask_of_node(node_dev->dev.id), cpu_online_mask);\n\tn = cpumap_print_list_to_buf(buf, mask, off, count);\n\tfree_cpumask_var(mask);\n\n\treturn n;\n}\n\nstatic BIN_ATTR_RO(cpulist, CPULIST_FILE_MAX_BYTES);\n\n \nstruct node_access_nodes {\n\tstruct device\t\tdev;\n\tstruct list_head\tlist_node;\n\tunsigned int\t\taccess;\n#ifdef CONFIG_HMEM_REPORTING\n\tstruct node_hmem_attrs\thmem_attrs;\n#endif\n};\n#define to_access_nodes(dev) container_of(dev, struct node_access_nodes, dev)\n\nstatic struct attribute *node_init_access_node_attrs[] = {\n\tNULL,\n};\n\nstatic struct attribute *node_targ_access_node_attrs[] = {\n\tNULL,\n};\n\nstatic const struct attribute_group initiators = {\n\t.name\t= \"initiators\",\n\t.attrs\t= node_init_access_node_attrs,\n};\n\nstatic const struct attribute_group targets = {\n\t.name\t= \"targets\",\n\t.attrs\t= node_targ_access_node_attrs,\n};\n\nstatic const struct attribute_group *node_access_node_groups[] = {\n\t&initiators,\n\t&targets,\n\tNULL,\n};\n\nstatic void node_remove_accesses(struct node *node)\n{\n\tstruct node_access_nodes *c, *cnext;\n\n\tlist_for_each_entry_safe(c, cnext, &node->access_list, list_node) {\n\t\tlist_del(&c->list_node);\n\t\tdevice_unregister(&c->dev);\n\t}\n}\n\nstatic void node_access_release(struct device *dev)\n{\n\tkfree(to_access_nodes(dev));\n}\n\nstatic struct node_access_nodes *node_init_node_access(struct node *node,\n\t\t\t\t\t\t       unsigned int access)\n{\n\tstruct node_access_nodes *access_node;\n\tstruct device *dev;\n\n\tlist_for_each_entry(access_node, &node->access_list, list_node)\n\t\tif (access_node->access == access)\n\t\t\treturn access_node;\n\n\taccess_node = kzalloc(sizeof(*access_node), GFP_KERNEL);\n\tif (!access_node)\n\t\treturn NULL;\n\n\taccess_node->access = access;\n\tdev = &access_node->dev;\n\tdev->parent = &node->dev;\n\tdev->release = node_access_release;\n\tdev->groups = node_access_node_groups;\n\tif (dev_set_name(dev, \"access%u\", access))\n\t\tgoto free;\n\n\tif (device_register(dev))\n\t\tgoto free_name;\n\n\tpm_runtime_no_callbacks(dev);\n\tlist_add_tail(&access_node->list_node, &node->access_list);\n\treturn access_node;\nfree_name:\n\tkfree_const(dev->kobj.name);\nfree:\n\tkfree(access_node);\n\treturn NULL;\n}\n\n#ifdef CONFIG_HMEM_REPORTING\n#define ACCESS_ATTR(property)\t\t\t\t\t\t\\\nstatic ssize_t property##_show(struct device *dev,\t\t\t\\\n\t\t\t   struct device_attribute *attr,\t\t\\\n\t\t\t   char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn sysfs_emit(buf, \"%u\\n\",\t\t\t\t\t\\\n\t\t\t  to_access_nodes(dev)->hmem_attrs.property);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(property)\n\nACCESS_ATTR(read_bandwidth);\nACCESS_ATTR(read_latency);\nACCESS_ATTR(write_bandwidth);\nACCESS_ATTR(write_latency);\n\nstatic struct attribute *access_attrs[] = {\n\t&dev_attr_read_bandwidth.attr,\n\t&dev_attr_read_latency.attr,\n\t&dev_attr_write_bandwidth.attr,\n\t&dev_attr_write_latency.attr,\n\tNULL,\n};\n\n \nvoid node_set_perf_attrs(unsigned int nid, struct node_hmem_attrs *hmem_attrs,\n\t\t\t unsigned int access)\n{\n\tstruct node_access_nodes *c;\n\tstruct node *node;\n\tint i;\n\n\tif (WARN_ON_ONCE(!node_online(nid)))\n\t\treturn;\n\n\tnode = node_devices[nid];\n\tc = node_init_node_access(node, access);\n\tif (!c)\n\t\treturn;\n\n\tc->hmem_attrs = *hmem_attrs;\n\tfor (i = 0; access_attrs[i] != NULL; i++) {\n\t\tif (sysfs_add_file_to_group(&c->dev.kobj, access_attrs[i],\n\t\t\t\t\t    \"initiators\")) {\n\t\t\tpr_info(\"failed to add performance attribute to node %d\\n\",\n\t\t\t\tnid);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstruct node_cache_info {\n\tstruct device dev;\n\tstruct list_head node;\n\tstruct node_cache_attrs cache_attrs;\n};\n#define to_cache_info(device) container_of(device, struct node_cache_info, dev)\n\n#define CACHE_ATTR(name, fmt) \t\t\t\t\t\t\\\nstatic ssize_t name##_show(struct device *dev,\t\t\t\t\\\n\t\t\t   struct device_attribute *attr,\t\t\\\n\t\t\t   char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn sysfs_emit(buf, fmt \"\\n\",\t\t\t\t\\\n\t\t\t  to_cache_info(dev)->cache_attrs.name);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(name);\n\nCACHE_ATTR(size, \"%llu\")\nCACHE_ATTR(line_size, \"%u\")\nCACHE_ATTR(indexing, \"%u\")\nCACHE_ATTR(write_policy, \"%u\")\n\nstatic struct attribute *cache_attrs[] = {\n\t&dev_attr_indexing.attr,\n\t&dev_attr_size.attr,\n\t&dev_attr_line_size.attr,\n\t&dev_attr_write_policy.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(cache);\n\nstatic void node_cache_release(struct device *dev)\n{\n\tkfree(dev);\n}\n\nstatic void node_cacheinfo_release(struct device *dev)\n{\n\tstruct node_cache_info *info = to_cache_info(dev);\n\tkfree(info);\n}\n\nstatic void node_init_cache_dev(struct node *node)\n{\n\tstruct device *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn;\n\n\tdevice_initialize(dev);\n\tdev->parent = &node->dev;\n\tdev->release = node_cache_release;\n\tif (dev_set_name(dev, \"memory_side_cache\"))\n\t\tgoto put_device;\n\n\tif (device_add(dev))\n\t\tgoto put_device;\n\n\tpm_runtime_no_callbacks(dev);\n\tnode->cache_dev = dev;\n\treturn;\nput_device:\n\tput_device(dev);\n}\n\n \nvoid node_add_cache(unsigned int nid, struct node_cache_attrs *cache_attrs)\n{\n\tstruct node_cache_info *info;\n\tstruct device *dev;\n\tstruct node *node;\n\n\tif (!node_online(nid) || !node_devices[nid])\n\t\treturn;\n\n\tnode = node_devices[nid];\n\tlist_for_each_entry(info, &node->cache_attrs, node) {\n\t\tif (info->cache_attrs.level == cache_attrs->level) {\n\t\t\tdev_warn(&node->dev,\n\t\t\t\t\"attempt to add duplicate cache level:%d\\n\",\n\t\t\t\tcache_attrs->level);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!node->cache_dev)\n\t\tnode_init_cache_dev(node);\n\tif (!node->cache_dev)\n\t\treturn;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn;\n\n\tdev = &info->dev;\n\tdevice_initialize(dev);\n\tdev->parent = node->cache_dev;\n\tdev->release = node_cacheinfo_release;\n\tdev->groups = cache_groups;\n\tif (dev_set_name(dev, \"index%d\", cache_attrs->level))\n\t\tgoto put_device;\n\n\tinfo->cache_attrs = *cache_attrs;\n\tif (device_add(dev)) {\n\t\tdev_warn(&node->dev, \"failed to add cache level:%d\\n\",\n\t\t\t cache_attrs->level);\n\t\tgoto put_device;\n\t}\n\tpm_runtime_no_callbacks(dev);\n\tlist_add_tail(&info->node, &node->cache_attrs);\n\treturn;\nput_device:\n\tput_device(dev);\n}\n\nstatic void node_remove_caches(struct node *node)\n{\n\tstruct node_cache_info *info, *next;\n\n\tif (!node->cache_dev)\n\t\treturn;\n\n\tlist_for_each_entry_safe(info, next, &node->cache_attrs, node) {\n\t\tlist_del(&info->node);\n\t\tdevice_unregister(&info->dev);\n\t}\n\tdevice_unregister(node->cache_dev);\n}\n\nstatic void node_init_caches(unsigned int nid)\n{\n\tINIT_LIST_HEAD(&node_devices[nid]->cache_attrs);\n}\n#else\nstatic void node_init_caches(unsigned int nid) { }\nstatic void node_remove_caches(struct node *node) { }\n#endif\n\n#define K(x) ((x) << (PAGE_SHIFT - 10))\nstatic ssize_t node_read_meminfo(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint len = 0;\n\tint nid = dev->id;\n\tstruct pglist_data *pgdat = NODE_DATA(nid);\n\tstruct sysinfo i;\n\tunsigned long sreclaimable, sunreclaimable;\n\tunsigned long swapcached = 0;\n\n\tsi_meminfo_node(&i, nid);\n\tsreclaimable = node_page_state_pages(pgdat, NR_SLAB_RECLAIMABLE_B);\n\tsunreclaimable = node_page_state_pages(pgdat, NR_SLAB_UNRECLAIMABLE_B);\n#ifdef CONFIG_SWAP\n\tswapcached = node_page_state_pages(pgdat, NR_SWAPCACHE);\n#endif\n\tlen = sysfs_emit_at(buf, len,\n\t\t\t    \"Node %d MemTotal:       %8lu kB\\n\"\n\t\t\t    \"Node %d MemFree:        %8lu kB\\n\"\n\t\t\t    \"Node %d MemUsed:        %8lu kB\\n\"\n\t\t\t    \"Node %d SwapCached:     %8lu kB\\n\"\n\t\t\t    \"Node %d Active:         %8lu kB\\n\"\n\t\t\t    \"Node %d Inactive:       %8lu kB\\n\"\n\t\t\t    \"Node %d Active(anon):   %8lu kB\\n\"\n\t\t\t    \"Node %d Inactive(anon): %8lu kB\\n\"\n\t\t\t    \"Node %d Active(file):   %8lu kB\\n\"\n\t\t\t    \"Node %d Inactive(file): %8lu kB\\n\"\n\t\t\t    \"Node %d Unevictable:    %8lu kB\\n\"\n\t\t\t    \"Node %d Mlocked:        %8lu kB\\n\",\n\t\t\t    nid, K(i.totalram),\n\t\t\t    nid, K(i.freeram),\n\t\t\t    nid, K(i.totalram - i.freeram),\n\t\t\t    nid, K(swapcached),\n\t\t\t    nid, K(node_page_state(pgdat, NR_ACTIVE_ANON) +\n\t\t\t\t   node_page_state(pgdat, NR_ACTIVE_FILE)),\n\t\t\t    nid, K(node_page_state(pgdat, NR_INACTIVE_ANON) +\n\t\t\t\t   node_page_state(pgdat, NR_INACTIVE_FILE)),\n\t\t\t    nid, K(node_page_state(pgdat, NR_ACTIVE_ANON)),\n\t\t\t    nid, K(node_page_state(pgdat, NR_INACTIVE_ANON)),\n\t\t\t    nid, K(node_page_state(pgdat, NR_ACTIVE_FILE)),\n\t\t\t    nid, K(node_page_state(pgdat, NR_INACTIVE_FILE)),\n\t\t\t    nid, K(node_page_state(pgdat, NR_UNEVICTABLE)),\n\t\t\t    nid, K(sum_zone_node_page_state(nid, NR_MLOCK)));\n\n#ifdef CONFIG_HIGHMEM\n\tlen += sysfs_emit_at(buf, len,\n\t\t\t     \"Node %d HighTotal:      %8lu kB\\n\"\n\t\t\t     \"Node %d HighFree:       %8lu kB\\n\"\n\t\t\t     \"Node %d LowTotal:       %8lu kB\\n\"\n\t\t\t     \"Node %d LowFree:        %8lu kB\\n\",\n\t\t\t     nid, K(i.totalhigh),\n\t\t\t     nid, K(i.freehigh),\n\t\t\t     nid, K(i.totalram - i.totalhigh),\n\t\t\t     nid, K(i.freeram - i.freehigh));\n#endif\n\tlen += sysfs_emit_at(buf, len,\n\t\t\t     \"Node %d Dirty:          %8lu kB\\n\"\n\t\t\t     \"Node %d Writeback:      %8lu kB\\n\"\n\t\t\t     \"Node %d FilePages:      %8lu kB\\n\"\n\t\t\t     \"Node %d Mapped:         %8lu kB\\n\"\n\t\t\t     \"Node %d AnonPages:      %8lu kB\\n\"\n\t\t\t     \"Node %d Shmem:          %8lu kB\\n\"\n\t\t\t     \"Node %d KernelStack:    %8lu kB\\n\"\n#ifdef CONFIG_SHADOW_CALL_STACK\n\t\t\t     \"Node %d ShadowCallStack:%8lu kB\\n\"\n#endif\n\t\t\t     \"Node %d PageTables:     %8lu kB\\n\"\n\t\t\t     \"Node %d SecPageTables:  %8lu kB\\n\"\n\t\t\t     \"Node %d NFS_Unstable:   %8lu kB\\n\"\n\t\t\t     \"Node %d Bounce:         %8lu kB\\n\"\n\t\t\t     \"Node %d WritebackTmp:   %8lu kB\\n\"\n\t\t\t     \"Node %d KReclaimable:   %8lu kB\\n\"\n\t\t\t     \"Node %d Slab:           %8lu kB\\n\"\n\t\t\t     \"Node %d SReclaimable:   %8lu kB\\n\"\n\t\t\t     \"Node %d SUnreclaim:     %8lu kB\\n\"\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\t     \"Node %d AnonHugePages:  %8lu kB\\n\"\n\t\t\t     \"Node %d ShmemHugePages: %8lu kB\\n\"\n\t\t\t     \"Node %d ShmemPmdMapped: %8lu kB\\n\"\n\t\t\t     \"Node %d FileHugePages:  %8lu kB\\n\"\n\t\t\t     \"Node %d FilePmdMapped:  %8lu kB\\n\"\n#endif\n#ifdef CONFIG_UNACCEPTED_MEMORY\n\t\t\t     \"Node %d Unaccepted:     %8lu kB\\n\"\n#endif\n\t\t\t     ,\n\t\t\t     nid, K(node_page_state(pgdat, NR_FILE_DIRTY)),\n\t\t\t     nid, K(node_page_state(pgdat, NR_WRITEBACK)),\n\t\t\t     nid, K(node_page_state(pgdat, NR_FILE_PAGES)),\n\t\t\t     nid, K(node_page_state(pgdat, NR_FILE_MAPPED)),\n\t\t\t     nid, K(node_page_state(pgdat, NR_ANON_MAPPED)),\n\t\t\t     nid, K(i.sharedram),\n\t\t\t     nid, node_page_state(pgdat, NR_KERNEL_STACK_KB),\n#ifdef CONFIG_SHADOW_CALL_STACK\n\t\t\t     nid, node_page_state(pgdat, NR_KERNEL_SCS_KB),\n#endif\n\t\t\t     nid, K(node_page_state(pgdat, NR_PAGETABLE)),\n\t\t\t     nid, K(node_page_state(pgdat, NR_SECONDARY_PAGETABLE)),\n\t\t\t     nid, 0UL,\n\t\t\t     nid, K(sum_zone_node_page_state(nid, NR_BOUNCE)),\n\t\t\t     nid, K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),\n\t\t\t     nid, K(sreclaimable +\n\t\t\t\t    node_page_state(pgdat, NR_KERNEL_MISC_RECLAIMABLE)),\n\t\t\t     nid, K(sreclaimable + sunreclaimable),\n\t\t\t     nid, K(sreclaimable),\n\t\t\t     nid, K(sunreclaimable)\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\t     ,\n\t\t\t     nid, K(node_page_state(pgdat, NR_ANON_THPS)),\n\t\t\t     nid, K(node_page_state(pgdat, NR_SHMEM_THPS)),\n\t\t\t     nid, K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)),\n\t\t\t     nid, K(node_page_state(pgdat, NR_FILE_THPS)),\n\t\t\t     nid, K(node_page_state(pgdat, NR_FILE_PMDMAPPED))\n#endif\n#ifdef CONFIG_UNACCEPTED_MEMORY\n\t\t\t     ,\n\t\t\t     nid, K(sum_zone_node_page_state(nid, NR_UNACCEPTED))\n#endif\n\t\t\t    );\n\tlen += hugetlb_report_node_meminfo(buf, len, nid);\n\treturn len;\n}\n\n#undef K\nstatic DEVICE_ATTR(meminfo, 0444, node_read_meminfo, NULL);\n\nstatic ssize_t node_read_numastat(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tfold_vm_numa_events();\n\treturn sysfs_emit(buf,\n\t\t\t  \"numa_hit %lu\\n\"\n\t\t\t  \"numa_miss %lu\\n\"\n\t\t\t  \"numa_foreign %lu\\n\"\n\t\t\t  \"interleave_hit %lu\\n\"\n\t\t\t  \"local_node %lu\\n\"\n\t\t\t  \"other_node %lu\\n\",\n\t\t\t  sum_zone_numa_event_state(dev->id, NUMA_HIT),\n\t\t\t  sum_zone_numa_event_state(dev->id, NUMA_MISS),\n\t\t\t  sum_zone_numa_event_state(dev->id, NUMA_FOREIGN),\n\t\t\t  sum_zone_numa_event_state(dev->id, NUMA_INTERLEAVE_HIT),\n\t\t\t  sum_zone_numa_event_state(dev->id, NUMA_LOCAL),\n\t\t\t  sum_zone_numa_event_state(dev->id, NUMA_OTHER));\n}\nstatic DEVICE_ATTR(numastat, 0444, node_read_numastat, NULL);\n\nstatic ssize_t node_read_vmstat(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint nid = dev->id;\n\tstruct pglist_data *pgdat = NODE_DATA(nid);\n\tint i;\n\tint len = 0;\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tlen += sysfs_emit_at(buf, len, \"%s %lu\\n\",\n\t\t\t\t     zone_stat_name(i),\n\t\t\t\t     sum_zone_node_page_state(nid, i));\n\n#ifdef CONFIG_NUMA\n\tfold_vm_numa_events();\n\tfor (i = 0; i < NR_VM_NUMA_EVENT_ITEMS; i++)\n\t\tlen += sysfs_emit_at(buf, len, \"%s %lu\\n\",\n\t\t\t\t     numa_stat_name(i),\n\t\t\t\t     sum_zone_numa_event_state(nid, i));\n\n#endif\n\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {\n\t\tunsigned long pages = node_page_state_pages(pgdat, i);\n\n\t\tif (vmstat_item_print_in_thp(i))\n\t\t\tpages /= HPAGE_PMD_NR;\n\t\tlen += sysfs_emit_at(buf, len, \"%s %lu\\n\", node_stat_name(i),\n\t\t\t\t     pages);\n\t}\n\n\treturn len;\n}\nstatic DEVICE_ATTR(vmstat, 0444, node_read_vmstat, NULL);\n\nstatic ssize_t node_read_distance(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tint nid = dev->id;\n\tint len = 0;\n\tint i;\n\n\t \n\tBUILD_BUG_ON(MAX_NUMNODES * 4 > PAGE_SIZE);\n\n\tfor_each_online_node(i) {\n\t\tlen += sysfs_emit_at(buf, len, \"%s%d\",\n\t\t\t\t     i ? \" \" : \"\", node_distance(nid, i));\n\t}\n\n\tlen += sysfs_emit_at(buf, len, \"\\n\");\n\treturn len;\n}\nstatic DEVICE_ATTR(distance, 0444, node_read_distance, NULL);\n\nstatic struct attribute *node_dev_attrs[] = {\n\t&dev_attr_meminfo.attr,\n\t&dev_attr_numastat.attr,\n\t&dev_attr_distance.attr,\n\t&dev_attr_vmstat.attr,\n\tNULL\n};\n\nstatic struct bin_attribute *node_dev_bin_attrs[] = {\n\t&bin_attr_cpumap,\n\t&bin_attr_cpulist,\n\tNULL\n};\n\nstatic const struct attribute_group node_dev_group = {\n\t.attrs = node_dev_attrs,\n\t.bin_attrs = node_dev_bin_attrs\n};\n\nstatic const struct attribute_group *node_dev_groups[] = {\n\t&node_dev_group,\n#ifdef CONFIG_HAVE_ARCH_NODE_DEV_GROUP\n\t&arch_node_dev_group,\n#endif\n#ifdef CONFIG_MEMORY_FAILURE\n\t&memory_failure_attr_group,\n#endif\n\tNULL\n};\n\nstatic void node_device_release(struct device *dev)\n{\n\tkfree(to_node(dev));\n}\n\n \nstatic int register_node(struct node *node, int num)\n{\n\tint error;\n\n\tnode->dev.id = num;\n\tnode->dev.bus = &node_subsys;\n\tnode->dev.release = node_device_release;\n\tnode->dev.groups = node_dev_groups;\n\terror = device_register(&node->dev);\n\n\tif (error) {\n\t\tput_device(&node->dev);\n\t} else {\n\t\thugetlb_register_node(node);\n\t\tcompaction_register_node(node);\n\t}\n\n\treturn error;\n}\n\n \nvoid unregister_node(struct node *node)\n{\n\thugetlb_unregister_node(node);\n\tcompaction_unregister_node(node);\n\tnode_remove_accesses(node);\n\tnode_remove_caches(node);\n\tdevice_unregister(&node->dev);\n}\n\nstruct node *node_devices[MAX_NUMNODES];\n\n \nint register_cpu_under_node(unsigned int cpu, unsigned int nid)\n{\n\tint ret;\n\tstruct device *obj;\n\n\tif (!node_online(nid))\n\t\treturn 0;\n\n\tobj = get_cpu_device(cpu);\n\tif (!obj)\n\t\treturn 0;\n\n\tret = sysfs_create_link(&node_devices[nid]->dev.kobj,\n\t\t\t\t&obj->kobj,\n\t\t\t\tkobject_name(&obj->kobj));\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_create_link(&obj->kobj,\n\t\t\t\t &node_devices[nid]->dev.kobj,\n\t\t\t\t kobject_name(&node_devices[nid]->dev.kobj));\n}\n\n \nint register_memory_node_under_compute_node(unsigned int mem_nid,\n\t\t\t\t\t    unsigned int cpu_nid,\n\t\t\t\t\t    unsigned int access)\n{\n\tstruct node *init_node, *targ_node;\n\tstruct node_access_nodes *initiator, *target;\n\tint ret;\n\n\tif (!node_online(cpu_nid) || !node_online(mem_nid))\n\t\treturn -ENODEV;\n\n\tinit_node = node_devices[cpu_nid];\n\ttarg_node = node_devices[mem_nid];\n\tinitiator = node_init_node_access(init_node, access);\n\ttarget = node_init_node_access(targ_node, access);\n\tif (!initiator || !target)\n\t\treturn -ENOMEM;\n\n\tret = sysfs_add_link_to_group(&initiator->dev.kobj, \"targets\",\n\t\t\t\t      &targ_node->dev.kobj,\n\t\t\t\t      dev_name(&targ_node->dev));\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_add_link_to_group(&target->dev.kobj, \"initiators\",\n\t\t\t\t      &init_node->dev.kobj,\n\t\t\t\t      dev_name(&init_node->dev));\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n err:\n\tsysfs_remove_link_from_group(&initiator->dev.kobj, \"targets\",\n\t\t\t\t     dev_name(&targ_node->dev));\n\treturn ret;\n}\n\nint unregister_cpu_under_node(unsigned int cpu, unsigned int nid)\n{\n\tstruct device *obj;\n\n\tif (!node_online(nid))\n\t\treturn 0;\n\n\tobj = get_cpu_device(cpu);\n\tif (!obj)\n\t\treturn 0;\n\n\tsysfs_remove_link(&node_devices[nid]->dev.kobj,\n\t\t\t  kobject_name(&obj->kobj));\n\tsysfs_remove_link(&obj->kobj,\n\t\t\t  kobject_name(&node_devices[nid]->dev.kobj));\n\n\treturn 0;\n}\n\n#ifdef CONFIG_MEMORY_HOTPLUG\nstatic int __ref get_nid_for_pfn(unsigned long pfn)\n{\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn early_pfn_to_nid(pfn);\n#endif\n\treturn pfn_to_nid(pfn);\n}\n\nstatic void do_register_memory_block_under_node(int nid,\n\t\t\t\t\t\tstruct memory_block *mem_blk,\n\t\t\t\t\t\tenum meminit_context context)\n{\n\tint ret;\n\n\tmemory_block_add_nid(mem_blk, nid, context);\n\n\tret = sysfs_create_link_nowarn(&node_devices[nid]->dev.kobj,\n\t\t\t\t       &mem_blk->dev.kobj,\n\t\t\t\t       kobject_name(&mem_blk->dev.kobj));\n\tif (ret && ret != -EEXIST)\n\t\tdev_err_ratelimited(&node_devices[nid]->dev,\n\t\t\t\t    \"can't create link to %s in sysfs (%d)\\n\",\n\t\t\t\t    kobject_name(&mem_blk->dev.kobj), ret);\n\n\tret = sysfs_create_link_nowarn(&mem_blk->dev.kobj,\n\t\t\t\t&node_devices[nid]->dev.kobj,\n\t\t\t\tkobject_name(&node_devices[nid]->dev.kobj));\n\tif (ret && ret != -EEXIST)\n\t\tdev_err_ratelimited(&mem_blk->dev,\n\t\t\t\t    \"can't create link to %s in sysfs (%d)\\n\",\n\t\t\t\t    kobject_name(&node_devices[nid]->dev.kobj),\n\t\t\t\t    ret);\n}\n\n \nstatic int register_mem_block_under_node_early(struct memory_block *mem_blk,\n\t\t\t\t\t       void *arg)\n{\n\tunsigned long memory_block_pfns = memory_block_size_bytes() / PAGE_SIZE;\n\tunsigned long start_pfn = section_nr_to_pfn(mem_blk->start_section_nr);\n\tunsigned long end_pfn = start_pfn + memory_block_pfns - 1;\n\tint nid = *(int *)arg;\n\tunsigned long pfn;\n\n\tfor (pfn = start_pfn; pfn <= end_pfn; pfn++) {\n\t\tint page_nid;\n\n\t\t \n\t\tif (!pfn_in_present_section(pfn)) {\n\t\t\tpfn = round_down(pfn + PAGES_PER_SECTION,\n\t\t\t\t\t PAGES_PER_SECTION) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tpage_nid = get_nid_for_pfn(pfn);\n\t\tif (page_nid < 0)\n\t\t\tcontinue;\n\t\tif (page_nid != nid)\n\t\t\tcontinue;\n\n\t\tdo_register_memory_block_under_node(nid, mem_blk, MEMINIT_EARLY);\n\t\treturn 0;\n\t}\n\t \n\treturn 0;\n}\n\n \nstatic int register_mem_block_under_node_hotplug(struct memory_block *mem_blk,\n\t\t\t\t\t\t void *arg)\n{\n\tint nid = *(int *)arg;\n\n\tdo_register_memory_block_under_node(nid, mem_blk, MEMINIT_HOTPLUG);\n\treturn 0;\n}\n\n \nvoid unregister_memory_block_under_nodes(struct memory_block *mem_blk)\n{\n\tif (mem_blk->nid == NUMA_NO_NODE)\n\t\treturn;\n\n\tsysfs_remove_link(&node_devices[mem_blk->nid]->dev.kobj,\n\t\t\t  kobject_name(&mem_blk->dev.kobj));\n\tsysfs_remove_link(&mem_blk->dev.kobj,\n\t\t\t  kobject_name(&node_devices[mem_blk->nid]->dev.kobj));\n}\n\nvoid register_memory_blocks_under_node(int nid, unsigned long start_pfn,\n\t\t\t\t       unsigned long end_pfn,\n\t\t\t\t       enum meminit_context context)\n{\n\twalk_memory_blocks_func_t func;\n\n\tif (context == MEMINIT_HOTPLUG)\n\t\tfunc = register_mem_block_under_node_hotplug;\n\telse\n\t\tfunc = register_mem_block_under_node_early;\n\n\twalk_memory_blocks(PFN_PHYS(start_pfn), PFN_PHYS(end_pfn - start_pfn),\n\t\t\t   (void *)&nid, func);\n\treturn;\n}\n#endif  \n\nint __register_one_node(int nid)\n{\n\tint error;\n\tint cpu;\n\tstruct node *node;\n\n\tnode = kzalloc(sizeof(struct node), GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&node->access_list);\n\tnode_devices[nid] = node;\n\n\terror = register_node(node_devices[nid], nid);\n\n\t \n\tfor_each_present_cpu(cpu) {\n\t\tif (cpu_to_node(cpu) == nid)\n\t\t\tregister_cpu_under_node(cpu, nid);\n\t}\n\n\tnode_init_caches(nid);\n\n\treturn error;\n}\n\nvoid unregister_one_node(int nid)\n{\n\tif (!node_devices[nid])\n\t\treturn;\n\n\tunregister_node(node_devices[nid]);\n\tnode_devices[nid] = NULL;\n}\n\n \n\nstruct node_attr {\n\tstruct device_attribute attr;\n\tenum node_states state;\n};\n\nstatic ssize_t show_node_state(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct node_attr *na = container_of(attr, struct node_attr, attr);\n\n\treturn sysfs_emit(buf, \"%*pbl\\n\",\n\t\t\t  nodemask_pr_args(&node_states[na->state]));\n}\n\n#define _NODE_ATTR(name, state) \\\n\t{ __ATTR(name, 0444, show_node_state, NULL), state }\n\nstatic struct node_attr node_state_attr[] = {\n\t[N_POSSIBLE] = _NODE_ATTR(possible, N_POSSIBLE),\n\t[N_ONLINE] = _NODE_ATTR(online, N_ONLINE),\n\t[N_NORMAL_MEMORY] = _NODE_ATTR(has_normal_memory, N_NORMAL_MEMORY),\n#ifdef CONFIG_HIGHMEM\n\t[N_HIGH_MEMORY] = _NODE_ATTR(has_high_memory, N_HIGH_MEMORY),\n#endif\n\t[N_MEMORY] = _NODE_ATTR(has_memory, N_MEMORY),\n\t[N_CPU] = _NODE_ATTR(has_cpu, N_CPU),\n\t[N_GENERIC_INITIATOR] = _NODE_ATTR(has_generic_initiator,\n\t\t\t\t\t   N_GENERIC_INITIATOR),\n};\n\nstatic struct attribute *node_state_attrs[] = {\n\t&node_state_attr[N_POSSIBLE].attr.attr,\n\t&node_state_attr[N_ONLINE].attr.attr,\n\t&node_state_attr[N_NORMAL_MEMORY].attr.attr,\n#ifdef CONFIG_HIGHMEM\n\t&node_state_attr[N_HIGH_MEMORY].attr.attr,\n#endif\n\t&node_state_attr[N_MEMORY].attr.attr,\n\t&node_state_attr[N_CPU].attr.attr,\n\t&node_state_attr[N_GENERIC_INITIATOR].attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group memory_root_attr_group = {\n\t.attrs = node_state_attrs,\n};\n\nstatic const struct attribute_group *cpu_root_attr_groups[] = {\n\t&memory_root_attr_group,\n\tNULL,\n};\n\nvoid __init node_dev_init(void)\n{\n\tint ret, i;\n\n \tBUILD_BUG_ON(ARRAY_SIZE(node_state_attr) != NR_NODE_STATES);\n \tBUILD_BUG_ON(ARRAY_SIZE(node_state_attrs)-1 != NR_NODE_STATES);\n\n\tret = subsys_system_register(&node_subsys, cpu_root_attr_groups);\n\tif (ret)\n\t\tpanic(\"%s() failed to register subsystem: %d\\n\", __func__, ret);\n\n\t \n\tfor_each_online_node(i) {\n\t\tret = register_one_node(i);\n\t\tif (ret)\n\t\t\tpanic(\"%s() failed to add node: %d\\n\", __func__, ret);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}