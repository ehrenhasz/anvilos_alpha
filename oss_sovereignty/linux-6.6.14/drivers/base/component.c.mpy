{
  "module_name": "component.c",
  "hash_id": "aabd6162dc55def43f23718d0cb38314e15d139f9bff151670b9a0dca2b2a7b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/component.c",
  "human_readable_source": "\n \n#include <linux/component.h>\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n\n \n\nstruct component;\n\nstruct component_match_array {\n\tvoid *data;\n\tint (*compare)(struct device *, void *);\n\tint (*compare_typed)(struct device *, int, void *);\n\tvoid (*release)(struct device *, void *);\n\tstruct component *component;\n\tbool duplicate;\n};\n\nstruct component_match {\n\tsize_t alloc;\n\tsize_t num;\n\tstruct component_match_array *compare;\n};\n\nstruct aggregate_device {\n\tstruct list_head node;\n\tbool bound;\n\n\tconst struct component_master_ops *ops;\n\tstruct device *parent;\n\tstruct component_match *match;\n};\n\nstruct component {\n\tstruct list_head node;\n\tstruct aggregate_device *adev;\n\tbool bound;\n\n\tconst struct component_ops *ops;\n\tint subcomponent;\n\tstruct device *dev;\n};\n\nstatic DEFINE_MUTEX(component_mutex);\nstatic LIST_HEAD(component_list);\nstatic LIST_HEAD(aggregate_devices);\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic struct dentry *component_debugfs_dir;\n\nstatic int component_devices_show(struct seq_file *s, void *data)\n{\n\tstruct aggregate_device *m = s->private;\n\tstruct component_match *match = m->match;\n\tsize_t i;\n\n\tmutex_lock(&component_mutex);\n\tseq_printf(s, \"%-40s %20s\\n\", \"aggregate_device name\", \"status\");\n\tseq_puts(s, \"-------------------------------------------------------------\\n\");\n\tseq_printf(s, \"%-40s %20s\\n\\n\",\n\t\t   dev_name(m->parent), m->bound ? \"bound\" : \"not bound\");\n\n\tseq_printf(s, \"%-40s %20s\\n\", \"device name\", \"status\");\n\tseq_puts(s, \"-------------------------------------------------------------\\n\");\n\tfor (i = 0; i < match->num; i++) {\n\t\tstruct component *component = match->compare[i].component;\n\n\t\tseq_printf(s, \"%-40s %20s\\n\",\n\t\t\t   component ? dev_name(component->dev) : \"(unknown)\",\n\t\t\t   component ? (component->bound ? \"bound\" : \"not bound\") : \"not registered\");\n\t}\n\tmutex_unlock(&component_mutex);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(component_devices);\n\nstatic int __init component_debug_init(void)\n{\n\tcomponent_debugfs_dir = debugfs_create_dir(\"device_component\", NULL);\n\n\treturn 0;\n}\n\ncore_initcall(component_debug_init);\n\nstatic void component_debugfs_add(struct aggregate_device *m)\n{\n\tdebugfs_create_file(dev_name(m->parent), 0444, component_debugfs_dir, m,\n\t\t\t    &component_devices_fops);\n}\n\nstatic void component_debugfs_del(struct aggregate_device *m)\n{\n\tdebugfs_lookup_and_remove(dev_name(m->parent), component_debugfs_dir);\n}\n\n#else\n\nstatic void component_debugfs_add(struct aggregate_device *m)\n{ }\n\nstatic void component_debugfs_del(struct aggregate_device *m)\n{ }\n\n#endif\n\nstatic struct aggregate_device *__aggregate_find(struct device *parent,\n\tconst struct component_master_ops *ops)\n{\n\tstruct aggregate_device *m;\n\n\tlist_for_each_entry(m, &aggregate_devices, node)\n\t\tif (m->parent == parent && (!ops || m->ops == ops))\n\t\t\treturn m;\n\n\treturn NULL;\n}\n\nstatic struct component *find_component(struct aggregate_device *adev,\n\tstruct component_match_array *mc)\n{\n\tstruct component *c;\n\n\tlist_for_each_entry(c, &component_list, node) {\n\t\tif (c->adev && c->adev != adev)\n\t\t\tcontinue;\n\n\t\tif (mc->compare && mc->compare(c->dev, mc->data))\n\t\t\treturn c;\n\n\t\tif (mc->compare_typed &&\n\t\t    mc->compare_typed(c->dev, c->subcomponent, mc->data))\n\t\t\treturn c;\n\t}\n\n\treturn NULL;\n}\n\nstatic int find_components(struct aggregate_device *adev)\n{\n\tstruct component_match *match = adev->match;\n\tsize_t i;\n\tint ret = 0;\n\n\t \n\tfor (i = 0; i < match->num; i++) {\n\t\tstruct component_match_array *mc = &match->compare[i];\n\t\tstruct component *c;\n\n\t\tdev_dbg(adev->parent, \"Looking for component %zu\\n\", i);\n\n\t\tif (match->compare[i].component)\n\t\t\tcontinue;\n\n\t\tc = find_component(adev, mc);\n\t\tif (!c) {\n\t\t\tret = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(adev->parent, \"found component %s, duplicate %u\\n\",\n\t\t\tdev_name(c->dev), !!c->adev);\n\n\t\t \n\t\tmatch->compare[i].duplicate = !!c->adev;\n\t\tmatch->compare[i].component = c;\n\t\tc->adev = adev;\n\t}\n\treturn ret;\n}\n\n \nstatic void remove_component(struct aggregate_device *adev, struct component *c)\n{\n\tsize_t i;\n\n\t \n\tfor (i = 0; i < adev->match->num; i++)\n\t\tif (adev->match->compare[i].component == c)\n\t\t\tadev->match->compare[i].component = NULL;\n}\n\n \nstatic int try_to_bring_up_aggregate_device(struct aggregate_device *adev,\n\tstruct component *component)\n{\n\tint ret;\n\n\tdev_dbg(adev->parent, \"trying to bring up adev\\n\");\n\n\tif (find_components(adev)) {\n\t\tdev_dbg(adev->parent, \"master has incomplete components\\n\");\n\t\treturn 0;\n\t}\n\n\tif (component && component->adev != adev) {\n\t\tdev_dbg(adev->parent, \"master is not for this component (%s)\\n\",\n\t\t\tdev_name(component->dev));\n\t\treturn 0;\n\t}\n\n\tif (!devres_open_group(adev->parent, adev, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\t \n\tret = adev->ops->bind(adev->parent);\n\tif (ret < 0) {\n\t\tdevres_release_group(adev->parent, NULL);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_info(adev->parent, \"adev bind failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdevres_close_group(adev->parent, NULL);\n\tadev->bound = true;\n\treturn 1;\n}\n\nstatic int try_to_bring_up_masters(struct component *component)\n{\n\tstruct aggregate_device *adev;\n\tint ret = 0;\n\n\tlist_for_each_entry(adev, &aggregate_devices, node) {\n\t\tif (!adev->bound) {\n\t\t\tret = try_to_bring_up_aggregate_device(adev, component);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void take_down_aggregate_device(struct aggregate_device *adev)\n{\n\tif (adev->bound) {\n\t\tadev->ops->unbind(adev->parent);\n\t\tdevres_release_group(adev->parent, adev);\n\t\tadev->bound = false;\n\t}\n}\n\n \nint component_compare_of(struct device *dev, void *data)\n{\n\treturn device_match_of_node(dev, data);\n}\nEXPORT_SYMBOL_GPL(component_compare_of);\n\n \nvoid component_release_of(struct device *dev, void *data)\n{\n\tof_node_put(data);\n}\nEXPORT_SYMBOL_GPL(component_release_of);\n\n \nint component_compare_dev(struct device *dev, void *data)\n{\n\treturn dev == data;\n}\nEXPORT_SYMBOL_GPL(component_compare_dev);\n\n \nint component_compare_dev_name(struct device *dev, void *data)\n{\n\treturn device_match_name(dev, data);\n}\nEXPORT_SYMBOL_GPL(component_compare_dev_name);\n\nstatic void devm_component_match_release(struct device *parent, void *res)\n{\n\tstruct component_match *match = res;\n\tunsigned int i;\n\n\tfor (i = 0; i < match->num; i++) {\n\t\tstruct component_match_array *mc = &match->compare[i];\n\n\t\tif (mc->release)\n\t\t\tmc->release(parent, mc->data);\n\t}\n\n\tkfree(match->compare);\n}\n\nstatic int component_match_realloc(struct component_match *match, size_t num)\n{\n\tstruct component_match_array *new;\n\n\tif (match->alloc == num)\n\t\treturn 0;\n\n\tnew = kmalloc_array(num, sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (match->compare) {\n\t\tmemcpy(new, match->compare, sizeof(*new) *\n\t\t\t\t\t    min(match->num, num));\n\t\tkfree(match->compare);\n\t}\n\tmatch->compare = new;\n\tmatch->alloc = num;\n\n\treturn 0;\n}\n\nstatic void __component_match_add(struct device *parent,\n\tstruct component_match **matchptr,\n\tvoid (*release)(struct device *, void *),\n\tint (*compare)(struct device *, void *),\n\tint (*compare_typed)(struct device *, int, void *),\n\tvoid *compare_data)\n{\n\tstruct component_match *match = *matchptr;\n\n\tif (IS_ERR(match))\n\t\treturn;\n\n\tif (!match) {\n\t\tmatch = devres_alloc(devm_component_match_release,\n\t\t\t\t     sizeof(*match), GFP_KERNEL);\n\t\tif (!match) {\n\t\t\t*matchptr = ERR_PTR(-ENOMEM);\n\t\t\treturn;\n\t\t}\n\n\t\tdevres_add(parent, match);\n\n\t\t*matchptr = match;\n\t}\n\n\tif (match->num == match->alloc) {\n\t\tsize_t new_size = match->alloc + 16;\n\t\tint ret;\n\n\t\tret = component_match_realloc(match, new_size);\n\t\tif (ret) {\n\t\t\t*matchptr = ERR_PTR(ret);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmatch->compare[match->num].compare = compare;\n\tmatch->compare[match->num].compare_typed = compare_typed;\n\tmatch->compare[match->num].release = release;\n\tmatch->compare[match->num].data = compare_data;\n\tmatch->compare[match->num].component = NULL;\n\tmatch->num++;\n}\n\n \nvoid component_match_add_release(struct device *parent,\n\tstruct component_match **matchptr,\n\tvoid (*release)(struct device *, void *),\n\tint (*compare)(struct device *, void *), void *compare_data)\n{\n\t__component_match_add(parent, matchptr, release, compare, NULL,\n\t\t\t      compare_data);\n}\nEXPORT_SYMBOL(component_match_add_release);\n\n \nvoid component_match_add_typed(struct device *parent,\n\tstruct component_match **matchptr,\n\tint (*compare_typed)(struct device *, int, void *), void *compare_data)\n{\n\t__component_match_add(parent, matchptr, NULL, NULL, compare_typed,\n\t\t\t      compare_data);\n}\nEXPORT_SYMBOL(component_match_add_typed);\n\nstatic void free_aggregate_device(struct aggregate_device *adev)\n{\n\tstruct component_match *match = adev->match;\n\tint i;\n\n\tcomponent_debugfs_del(adev);\n\tlist_del(&adev->node);\n\n\tif (match) {\n\t\tfor (i = 0; i < match->num; i++) {\n\t\t\tstruct component *c = match->compare[i].component;\n\t\t\tif (c)\n\t\t\t\tc->adev = NULL;\n\t\t}\n\t}\n\n\tkfree(adev);\n}\n\n \nint component_master_add_with_match(struct device *parent,\n\tconst struct component_master_ops *ops,\n\tstruct component_match *match)\n{\n\tstruct aggregate_device *adev;\n\tint ret;\n\n\t \n\tret = component_match_realloc(match, match->num);\n\tif (ret)\n\t\treturn ret;\n\n\tadev = kzalloc(sizeof(*adev), GFP_KERNEL);\n\tif (!adev)\n\t\treturn -ENOMEM;\n\n\tadev->parent = parent;\n\tadev->ops = ops;\n\tadev->match = match;\n\n\tcomponent_debugfs_add(adev);\n\t \n\tmutex_lock(&component_mutex);\n\tlist_add(&adev->node, &aggregate_devices);\n\n\tret = try_to_bring_up_aggregate_device(adev, NULL);\n\n\tif (ret < 0)\n\t\tfree_aggregate_device(adev);\n\n\tmutex_unlock(&component_mutex);\n\n\treturn ret < 0 ? ret : 0;\n}\nEXPORT_SYMBOL_GPL(component_master_add_with_match);\n\n \nvoid component_master_del(struct device *parent,\n\tconst struct component_master_ops *ops)\n{\n\tstruct aggregate_device *adev;\n\n\tmutex_lock(&component_mutex);\n\tadev = __aggregate_find(parent, ops);\n\tif (adev) {\n\t\ttake_down_aggregate_device(adev);\n\t\tfree_aggregate_device(adev);\n\t}\n\tmutex_unlock(&component_mutex);\n}\nEXPORT_SYMBOL_GPL(component_master_del);\n\nstatic void component_unbind(struct component *component,\n\tstruct aggregate_device *adev, void *data)\n{\n\tWARN_ON(!component->bound);\n\n\tif (component->ops && component->ops->unbind)\n\t\tcomponent->ops->unbind(component->dev, adev->parent, data);\n\tcomponent->bound = false;\n\n\t \n\tdevres_release_group(component->dev, component);\n}\n\n \nvoid component_unbind_all(struct device *parent, void *data)\n{\n\tstruct aggregate_device *adev;\n\tstruct component *c;\n\tsize_t i;\n\n\tWARN_ON(!mutex_is_locked(&component_mutex));\n\n\tadev = __aggregate_find(parent, NULL);\n\tif (!adev)\n\t\treturn;\n\n\t \n\tfor (i = adev->match->num; i--; )\n\t\tif (!adev->match->compare[i].duplicate) {\n\t\t\tc = adev->match->compare[i].component;\n\t\t\tcomponent_unbind(c, adev, data);\n\t\t}\n}\nEXPORT_SYMBOL_GPL(component_unbind_all);\n\nstatic int component_bind(struct component *component, struct aggregate_device *adev,\n\tvoid *data)\n{\n\tint ret;\n\n\t \n\tif (!devres_open_group(adev->parent, NULL, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\t \n\tif (!devres_open_group(component->dev, component, GFP_KERNEL)) {\n\t\tdevres_release_group(adev->parent, NULL);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_dbg(adev->parent, \"binding %s (ops %ps)\\n\",\n\t\tdev_name(component->dev), component->ops);\n\n\tret = component->ops->bind(component->dev, adev->parent, data);\n\tif (!ret) {\n\t\tcomponent->bound = true;\n\n\t\t \n\t\tdevres_close_group(component->dev, NULL);\n\t\tdevres_remove_group(adev->parent, NULL);\n\n\t\tdev_info(adev->parent, \"bound %s (ops %ps)\\n\",\n\t\t\t dev_name(component->dev), component->ops);\n\t} else {\n\t\tdevres_release_group(component->dev, NULL);\n\t\tdevres_release_group(adev->parent, NULL);\n\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(adev->parent, \"failed to bind %s (ops %ps): %d\\n\",\n\t\t\t\tdev_name(component->dev), component->ops, ret);\n\t}\n\n\treturn ret;\n}\n\n \nint component_bind_all(struct device *parent, void *data)\n{\n\tstruct aggregate_device *adev;\n\tstruct component *c;\n\tsize_t i;\n\tint ret = 0;\n\n\tWARN_ON(!mutex_is_locked(&component_mutex));\n\n\tadev = __aggregate_find(parent, NULL);\n\tif (!adev)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < adev->match->num; i++)\n\t\tif (!adev->match->compare[i].duplicate) {\n\t\t\tc = adev->match->compare[i].component;\n\t\t\tret = component_bind(c, adev, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\tif (ret != 0) {\n\t\tfor (; i > 0; i--)\n\t\t\tif (!adev->match->compare[i - 1].duplicate) {\n\t\t\t\tc = adev->match->compare[i - 1].component;\n\t\t\t\tcomponent_unbind(c, adev, data);\n\t\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(component_bind_all);\n\nstatic int __component_add(struct device *dev, const struct component_ops *ops,\n\tint subcomponent)\n{\n\tstruct component *component;\n\tint ret;\n\n\tcomponent = kzalloc(sizeof(*component), GFP_KERNEL);\n\tif (!component)\n\t\treturn -ENOMEM;\n\n\tcomponent->ops = ops;\n\tcomponent->dev = dev;\n\tcomponent->subcomponent = subcomponent;\n\n\tdev_dbg(dev, \"adding component (ops %ps)\\n\", ops);\n\n\tmutex_lock(&component_mutex);\n\tlist_add_tail(&component->node, &component_list);\n\n\tret = try_to_bring_up_masters(component);\n\tif (ret < 0) {\n\t\tif (component->adev)\n\t\t\tremove_component(component->adev, component);\n\t\tlist_del(&component->node);\n\n\t\tkfree(component);\n\t}\n\tmutex_unlock(&component_mutex);\n\n\treturn ret < 0 ? ret : 0;\n}\n\n \nint component_add_typed(struct device *dev, const struct component_ops *ops,\n\tint subcomponent)\n{\n\tif (WARN_ON(subcomponent == 0))\n\t\treturn -EINVAL;\n\n\treturn __component_add(dev, ops, subcomponent);\n}\nEXPORT_SYMBOL_GPL(component_add_typed);\n\n \nint component_add(struct device *dev, const struct component_ops *ops)\n{\n\treturn __component_add(dev, ops, 0);\n}\nEXPORT_SYMBOL_GPL(component_add);\n\n \nvoid component_del(struct device *dev, const struct component_ops *ops)\n{\n\tstruct component *c, *component = NULL;\n\n\tmutex_lock(&component_mutex);\n\tlist_for_each_entry(c, &component_list, node)\n\t\tif (c->dev == dev && c->ops == ops) {\n\t\t\tlist_del(&c->node);\n\t\t\tcomponent = c;\n\t\t\tbreak;\n\t\t}\n\n\tif (component && component->adev) {\n\t\ttake_down_aggregate_device(component->adev);\n\t\tremove_component(component->adev, component);\n\t}\n\n\tmutex_unlock(&component_mutex);\n\n\tWARN_ON(!component);\n\tkfree(component);\n}\nEXPORT_SYMBOL_GPL(component_del);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}