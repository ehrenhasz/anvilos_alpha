{
  "module_name": "platform-msi.c",
  "hash_id": "3ec1120f5f54be5d90f18b681539c1160bc5747b37129b26b2ac3a0028de3de5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/platform-msi.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/idr.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/msi.h>\n#include <linux/slab.h>\n\n#define DEV_ID_SHIFT\t21\n#define MAX_DEV_MSIS\t(1 << (32 - DEV_ID_SHIFT))\n\n \nstruct platform_msi_priv_data {\n\tstruct device\t\t\t*dev;\n\tvoid\t\t\t\t*host_data;\n\tmsi_alloc_info_t\t\targ;\n\tirq_write_msi_msg_t\t\twrite_msg;\n\tint\t\t\t\tdevid;\n};\n\n \nstatic DEFINE_IDA(platform_msi_devid_ida);\n\n#ifdef GENERIC_MSI_DOMAIN_OPS\n \nstatic irq_hw_number_t platform_msi_calc_hwirq(struct msi_desc *desc)\n{\n\tu32 devid = desc->dev->msi.data->platform_data->devid;\n\n\treturn (devid << (32 - DEV_ID_SHIFT)) | desc->msi_index;\n}\n\nstatic void platform_msi_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc)\n{\n\targ->desc = desc;\n\targ->hwirq = platform_msi_calc_hwirq(desc);\n}\n\nstatic int platform_msi_init(struct irq_domain *domain,\n\t\t\t     struct msi_domain_info *info,\n\t\t\t     unsigned int virq, irq_hw_number_t hwirq,\n\t\t\t     msi_alloc_info_t *arg)\n{\n\treturn irq_domain_set_hwirq_and_chip(domain, virq, hwirq,\n\t\t\t\t\t     info->chip, info->chip_data);\n}\n\nstatic void platform_msi_set_proxy_dev(msi_alloc_info_t *arg)\n{\n\targ->flags |= MSI_ALLOC_FLAGS_PROXY_DEVICE;\n}\n#else\n#define platform_msi_set_desc\t\tNULL\n#define platform_msi_init\t\tNULL\n#define platform_msi_set_proxy_dev(x)\tdo {} while(0)\n#endif\n\nstatic void platform_msi_update_dom_ops(struct msi_domain_info *info)\n{\n\tstruct msi_domain_ops *ops = info->ops;\n\n\tBUG_ON(!ops);\n\n\tif (ops->msi_init == NULL)\n\t\tops->msi_init = platform_msi_init;\n\tif (ops->set_desc == NULL)\n\t\tops->set_desc = platform_msi_set_desc;\n}\n\nstatic void platform_msi_write_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct msi_desc *desc = irq_data_get_msi_desc(data);\n\n\tdesc->dev->msi.data->platform_data->write_msg(desc, msg);\n}\n\nstatic void platform_msi_update_chip_ops(struct msi_domain_info *info)\n{\n\tstruct irq_chip *chip = info->chip;\n\n\tBUG_ON(!chip);\n\tif (!chip->irq_mask)\n\t\tchip->irq_mask = irq_chip_mask_parent;\n\tif (!chip->irq_unmask)\n\t\tchip->irq_unmask = irq_chip_unmask_parent;\n\tif (!chip->irq_eoi)\n\t\tchip->irq_eoi = irq_chip_eoi_parent;\n\tif (!chip->irq_set_affinity)\n\t\tchip->irq_set_affinity = msi_domain_set_affinity;\n\tif (!chip->irq_write_msi_msg)\n\t\tchip->irq_write_msi_msg = platform_msi_write_msg;\n\tif (WARN_ON((info->flags & MSI_FLAG_LEVEL_CAPABLE) &&\n\t\t    !(chip->flags & IRQCHIP_SUPPORTS_LEVEL_MSI)))\n\t\tinfo->flags &= ~MSI_FLAG_LEVEL_CAPABLE;\n}\n\n \nstruct irq_domain *platform_msi_create_irq_domain(struct fwnode_handle *fwnode,\n\t\t\t\t\t\t  struct msi_domain_info *info,\n\t\t\t\t\t\t  struct irq_domain *parent)\n{\n\tstruct irq_domain *domain;\n\n\tif (info->flags & MSI_FLAG_USE_DEF_DOM_OPS)\n\t\tplatform_msi_update_dom_ops(info);\n\tif (info->flags & MSI_FLAG_USE_DEF_CHIP_OPS)\n\t\tplatform_msi_update_chip_ops(info);\n\tinfo->flags |= MSI_FLAG_DEV_SYSFS | MSI_FLAG_ALLOC_SIMPLE_MSI_DESCS |\n\t\t       MSI_FLAG_FREE_MSI_DESCS;\n\n\tdomain = msi_create_irq_domain(fwnode, info, parent);\n\tif (domain)\n\t\tirq_domain_update_bus_token(domain, DOMAIN_BUS_PLATFORM_MSI);\n\n\treturn domain;\n}\nEXPORT_SYMBOL_GPL(platform_msi_create_irq_domain);\n\nstatic int platform_msi_alloc_priv_data(struct device *dev, unsigned int nvec,\n\t\t\t\t\tirq_write_msi_msg_t write_msi_msg)\n{\n\tstruct platform_msi_priv_data *datap;\n\tint err;\n\n\t \n\tif (!dev->msi.domain || !write_msi_msg || !nvec || nvec > MAX_DEV_MSIS)\n\t\treturn -EINVAL;\n\n\tif (dev->msi.domain->bus_token != DOMAIN_BUS_PLATFORM_MSI) {\n\t\tdev_err(dev, \"Incompatible msi_domain, giving up\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = msi_setup_device_data(dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (dev->msi.data->platform_data)\n\t\treturn -EBUSY;\n\n\tdatap = kzalloc(sizeof(*datap), GFP_KERNEL);\n\tif (!datap)\n\t\treturn -ENOMEM;\n\n\tdatap->devid = ida_simple_get(&platform_msi_devid_ida,\n\t\t\t\t      0, 1 << DEV_ID_SHIFT, GFP_KERNEL);\n\tif (datap->devid < 0) {\n\t\terr = datap->devid;\n\t\tkfree(datap);\n\t\treturn err;\n\t}\n\n\tdatap->write_msg = write_msi_msg;\n\tdatap->dev = dev;\n\tdev->msi.data->platform_data = datap;\n\treturn 0;\n}\n\nstatic void platform_msi_free_priv_data(struct device *dev)\n{\n\tstruct platform_msi_priv_data *data = dev->msi.data->platform_data;\n\n\tdev->msi.data->platform_data = NULL;\n\tida_simple_remove(&platform_msi_devid_ida, data->devid);\n\tkfree(data);\n}\n\n \nint platform_msi_domain_alloc_irqs(struct device *dev, unsigned int nvec,\n\t\t\t\t   irq_write_msi_msg_t write_msi_msg)\n{\n\tint err;\n\n\terr = platform_msi_alloc_priv_data(dev, nvec, write_msi_msg);\n\tif (err)\n\t\treturn err;\n\n\terr = msi_domain_alloc_irqs_range(dev, MSI_DEFAULT_DOMAIN, 0, nvec - 1);\n\tif (err)\n\t\tplatform_msi_free_priv_data(dev);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(platform_msi_domain_alloc_irqs);\n\n \nvoid platform_msi_domain_free_irqs(struct device *dev)\n{\n\tmsi_domain_free_irqs_all(dev, MSI_DEFAULT_DOMAIN);\n\tplatform_msi_free_priv_data(dev);\n}\nEXPORT_SYMBOL_GPL(platform_msi_domain_free_irqs);\n\n \nvoid *platform_msi_get_host_data(struct irq_domain *domain)\n{\n\tstruct platform_msi_priv_data *data = domain->host_data;\n\n\treturn data->host_data;\n}\n\nstatic struct lock_class_key platform_device_msi_lock_class;\n\n \nstruct irq_domain *\n__platform_msi_create_device_domain(struct device *dev,\n\t\t\t\t    unsigned int nvec,\n\t\t\t\t    bool is_tree,\n\t\t\t\t    irq_write_msi_msg_t write_msi_msg,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data)\n{\n\tstruct platform_msi_priv_data *data;\n\tstruct irq_domain *domain;\n\tint err;\n\n\terr = platform_msi_alloc_priv_data(dev, nvec, write_msi_msg);\n\tif (err)\n\t\treturn NULL;\n\n\t \n\tlockdep_set_class(&dev->msi.data->mutex, &platform_device_msi_lock_class);\n\n\tdata = dev->msi.data->platform_data;\n\tdata->host_data = host_data;\n\tdomain = irq_domain_create_hierarchy(dev->msi.domain, 0,\n\t\t\t\t\t     is_tree ? 0 : nvec,\n\t\t\t\t\t     dev->fwnode, ops, data);\n\tif (!domain)\n\t\tgoto free_priv;\n\n\tplatform_msi_set_proxy_dev(&data->arg);\n\terr = msi_domain_prepare_irqs(domain->parent, dev, nvec, &data->arg);\n\tif (err)\n\t\tgoto free_domain;\n\n\treturn domain;\n\nfree_domain:\n\tirq_domain_remove(domain);\nfree_priv:\n\tplatform_msi_free_priv_data(dev);\n\treturn NULL;\n}\n\n \nvoid platform_msi_device_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t     unsigned int nr_irqs)\n{\n\tstruct platform_msi_priv_data *data = domain->host_data;\n\n\tmsi_lock_descs(data->dev);\n\tmsi_domain_depopulate_descs(data->dev, virq, nr_irqs);\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n\tmsi_free_msi_descs_range(data->dev, virq, virq + nr_irqs - 1);\n\tmsi_unlock_descs(data->dev);\n}\n\n \nint platform_msi_device_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t     unsigned int nr_irqs)\n{\n\tstruct platform_msi_priv_data *data = domain->host_data;\n\tstruct device *dev = data->dev;\n\n\treturn msi_domain_populate_irqs(domain->parent, dev, virq, nr_irqs, &data->arg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}