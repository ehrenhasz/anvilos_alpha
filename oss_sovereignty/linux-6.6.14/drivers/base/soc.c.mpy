{
  "module_name": "soc.c",
  "hash_id": "50036d1948054a8672cdbdecdd6546768f4488a3b6d6122e8d9dfad322f83086",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/soc.c",
  "human_readable_source": "\n \n\n#include <linux/sysfs.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/spinlock.h>\n#include <linux/sys_soc.h>\n#include <linux/err.h>\n#include <linux/glob.h>\n\nstatic DEFINE_IDA(soc_ida);\n\n \nstatic ssize_t soc_info_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf);\n\nstruct soc_device {\n\tstruct device dev;\n\tstruct soc_device_attribute *attr;\n\tint soc_dev_num;\n};\n\nstatic struct bus_type soc_bus_type = {\n\t.name  = \"soc\",\n};\nstatic bool soc_bus_registered;\n\nstatic DEVICE_ATTR(machine,\t\t0444, soc_info_show,  NULL);\nstatic DEVICE_ATTR(family,\t\t0444, soc_info_show,  NULL);\nstatic DEVICE_ATTR(serial_number,\t0444, soc_info_show,  NULL);\nstatic DEVICE_ATTR(soc_id,\t\t0444, soc_info_show,  NULL);\nstatic DEVICE_ATTR(revision,\t\t0444, soc_info_show,  NULL);\n\nstruct device *soc_device_to_device(struct soc_device *soc_dev)\n{\n\treturn &soc_dev->dev;\n}\n\nstatic umode_t soc_attribute_mode(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tint index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct soc_device *soc_dev = container_of(dev, struct soc_device, dev);\n\n\tif ((attr == &dev_attr_machine.attr) && soc_dev->attr->machine)\n\t\treturn attr->mode;\n\tif ((attr == &dev_attr_family.attr) && soc_dev->attr->family)\n\t\treturn attr->mode;\n\tif ((attr == &dev_attr_revision.attr) && soc_dev->attr->revision)\n\t\treturn attr->mode;\n\tif ((attr == &dev_attr_serial_number.attr) && soc_dev->attr->serial_number)\n\t\treturn attr->mode;\n\tif ((attr == &dev_attr_soc_id.attr) && soc_dev->attr->soc_id)\n\t\treturn attr->mode;\n\n\t \n\treturn 0;\n}\n\nstatic ssize_t soc_info_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct soc_device *soc_dev = container_of(dev, struct soc_device, dev);\n\tconst char *output;\n\n\tif (attr == &dev_attr_machine)\n\t\toutput = soc_dev->attr->machine;\n\telse if (attr == &dev_attr_family)\n\t\toutput = soc_dev->attr->family;\n\telse if (attr == &dev_attr_revision)\n\t\toutput = soc_dev->attr->revision;\n\telse if (attr == &dev_attr_serial_number)\n\t\toutput = soc_dev->attr->serial_number;\n\telse if (attr == &dev_attr_soc_id)\n\t\toutput = soc_dev->attr->soc_id;\n\telse\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(buf, \"%s\\n\", output);\n}\n\nstatic struct attribute *soc_attr[] = {\n\t&dev_attr_machine.attr,\n\t&dev_attr_family.attr,\n\t&dev_attr_serial_number.attr,\n\t&dev_attr_soc_id.attr,\n\t&dev_attr_revision.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group soc_attr_group = {\n\t.attrs = soc_attr,\n\t.is_visible = soc_attribute_mode,\n};\n\nstatic void soc_release(struct device *dev)\n{\n\tstruct soc_device *soc_dev = container_of(dev, struct soc_device, dev);\n\n\tida_simple_remove(&soc_ida, soc_dev->soc_dev_num);\n\tkfree(soc_dev->dev.groups);\n\tkfree(soc_dev);\n}\n\nstatic void soc_device_get_machine(struct soc_device_attribute *soc_dev_attr)\n{\n\tstruct device_node *np;\n\n\tif (soc_dev_attr->machine)\n\t\treturn;\n\n\tnp = of_find_node_by_path(\"/\");\n\tof_property_read_string(np, \"model\", &soc_dev_attr->machine);\n\tof_node_put(np);\n}\n\nstatic struct soc_device_attribute *early_soc_dev_attr;\n\nstruct soc_device *soc_device_register(struct soc_device_attribute *soc_dev_attr)\n{\n\tstruct soc_device *soc_dev;\n\tconst struct attribute_group **soc_attr_groups;\n\tint ret;\n\n\tsoc_device_get_machine(soc_dev_attr);\n\n\tif (!soc_bus_registered) {\n\t\tif (early_soc_dev_attr)\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\tearly_soc_dev_attr = soc_dev_attr;\n\t\treturn NULL;\n\t}\n\n\tsoc_dev = kzalloc(sizeof(*soc_dev), GFP_KERNEL);\n\tif (!soc_dev) {\n\t\tret = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tsoc_attr_groups = kcalloc(3, sizeof(*soc_attr_groups), GFP_KERNEL);\n\tif (!soc_attr_groups) {\n\t\tret = -ENOMEM;\n\t\tgoto out2;\n\t}\n\tsoc_attr_groups[0] = &soc_attr_group;\n\tsoc_attr_groups[1] = soc_dev_attr->custom_attr_group;\n\n\t \n\tret = ida_simple_get(&soc_ida, 0, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto out3;\n\tsoc_dev->soc_dev_num = ret;\n\n\tsoc_dev->attr = soc_dev_attr;\n\tsoc_dev->dev.bus = &soc_bus_type;\n\tsoc_dev->dev.groups = soc_attr_groups;\n\tsoc_dev->dev.release = soc_release;\n\n\tdev_set_name(&soc_dev->dev, \"soc%d\", soc_dev->soc_dev_num);\n\n\tret = device_register(&soc_dev->dev);\n\tif (ret) {\n\t\tput_device(&soc_dev->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn soc_dev;\n\nout3:\n\tkfree(soc_attr_groups);\nout2:\n\tkfree(soc_dev);\nout1:\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(soc_device_register);\n\n \nvoid soc_device_unregister(struct soc_device *soc_dev)\n{\n\tdevice_unregister(&soc_dev->dev);\n\tearly_soc_dev_attr = NULL;\n}\nEXPORT_SYMBOL_GPL(soc_device_unregister);\n\nstatic int __init soc_bus_register(void)\n{\n\tint ret;\n\n\tret = bus_register(&soc_bus_type);\n\tif (ret)\n\t\treturn ret;\n\tsoc_bus_registered = true;\n\n\tif (early_soc_dev_attr)\n\t\treturn PTR_ERR(soc_device_register(early_soc_dev_attr));\n\n\treturn 0;\n}\ncore_initcall(soc_bus_register);\n\nstatic int soc_device_match_attr(const struct soc_device_attribute *attr,\n\t\t\t\t const struct soc_device_attribute *match)\n{\n\tif (match->machine &&\n\t    (!attr->machine || !glob_match(match->machine, attr->machine)))\n\t\treturn 0;\n\n\tif (match->family &&\n\t    (!attr->family || !glob_match(match->family, attr->family)))\n\t\treturn 0;\n\n\tif (match->revision &&\n\t    (!attr->revision || !glob_match(match->revision, attr->revision)))\n\t\treturn 0;\n\n\tif (match->soc_id &&\n\t    (!attr->soc_id || !glob_match(match->soc_id, attr->soc_id)))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int soc_device_match_one(struct device *dev, void *arg)\n{\n\tstruct soc_device *soc_dev = container_of(dev, struct soc_device, dev);\n\n\treturn soc_device_match_attr(soc_dev->attr, arg);\n}\n\n \nconst struct soc_device_attribute *soc_device_match(\n\tconst struct soc_device_attribute *matches)\n{\n\tint ret;\n\n\tif (!matches)\n\t\treturn NULL;\n\n\twhile (matches->machine || matches->family || matches->revision ||\n\t       matches->soc_id) {\n\t\tret = bus_for_each_dev(&soc_bus_type, NULL, (void *)matches,\n\t\t\t\t       soc_device_match_one);\n\t\tif (ret < 0 && early_soc_dev_attr)\n\t\t\tret = soc_device_match_attr(early_soc_dev_attr,\n\t\t\t\t\t\t    matches);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t\tif (ret)\n\t\t\treturn matches;\n\n\t\tmatches++;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(soc_device_match);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}