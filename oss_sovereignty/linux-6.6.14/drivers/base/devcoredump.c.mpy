{
  "module_name": "devcoredump.c",
  "hash_id": "3817559b44d958a83efd4f115fa8d05466ccabcf269ab6ed3258490ccea7f0ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/devcoredump.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/devcoredump.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/workqueue.h>\n\nstatic struct class devcd_class;\n\n \nstatic bool devcd_disabled;\n\n \n#define DEVCD_TIMEOUT\t(HZ * 60 * 5)\n\nstruct devcd_entry {\n\tstruct device devcd_dev;\n\tvoid *data;\n\tsize_t datalen;\n\t \n\tstruct mutex mutex;\n\tbool delete_work;\n\tstruct module *owner;\n\tssize_t (*read)(char *buffer, loff_t offset, size_t count,\n\t\t\tvoid *data, size_t datalen);\n\tvoid (*free)(void *data);\n\tstruct delayed_work del_wk;\n\tstruct device *failing_dev;\n};\n\nstatic struct devcd_entry *dev_to_devcd(struct device *dev)\n{\n\treturn container_of(dev, struct devcd_entry, devcd_dev);\n}\n\nstatic void devcd_dev_release(struct device *dev)\n{\n\tstruct devcd_entry *devcd = dev_to_devcd(dev);\n\n\tdevcd->free(devcd->data);\n\tmodule_put(devcd->owner);\n\n\t \n\tif (devcd->failing_dev->kobj.sd)\n\t\tsysfs_delete_link(&devcd->failing_dev->kobj, &dev->kobj,\n\t\t\t\t  \"devcoredump\");\n\n\tput_device(devcd->failing_dev);\n\tkfree(devcd);\n}\n\nstatic void devcd_del(struct work_struct *wk)\n{\n\tstruct devcd_entry *devcd;\n\n\tdevcd = container_of(wk, struct devcd_entry, del_wk.work);\n\n\tdevice_del(&devcd->devcd_dev);\n\tput_device(&devcd->devcd_dev);\n}\n\nstatic ssize_t devcd_data_read(struct file *filp, struct kobject *kobj,\n\t\t\t       struct bin_attribute *bin_attr,\n\t\t\t       char *buffer, loff_t offset, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct devcd_entry *devcd = dev_to_devcd(dev);\n\n\treturn devcd->read(buffer, offset, count, devcd->data, devcd->datalen);\n}\n\nstatic ssize_t devcd_data_write(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr,\n\t\t\t\tchar *buffer, loff_t offset, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct devcd_entry *devcd = dev_to_devcd(dev);\n\n\tmutex_lock(&devcd->mutex);\n\tif (!devcd->delete_work) {\n\t\tdevcd->delete_work = true;\n\t\tmod_delayed_work(system_wq, &devcd->del_wk, 0);\n\t}\n\tmutex_unlock(&devcd->mutex);\n\n\treturn count;\n}\n\nstatic struct bin_attribute devcd_attr_data = {\n\t.attr = { .name = \"data\", .mode = S_IRUSR | S_IWUSR, },\n\t.size = 0,\n\t.read = devcd_data_read,\n\t.write = devcd_data_write,\n};\n\nstatic struct bin_attribute *devcd_dev_bin_attrs[] = {\n\t&devcd_attr_data, NULL,\n};\n\nstatic const struct attribute_group devcd_dev_group = {\n\t.bin_attrs = devcd_dev_bin_attrs,\n};\n\nstatic const struct attribute_group *devcd_dev_groups[] = {\n\t&devcd_dev_group, NULL,\n};\n\nstatic int devcd_free(struct device *dev, void *data)\n{\n\tstruct devcd_entry *devcd = dev_to_devcd(dev);\n\n\tmutex_lock(&devcd->mutex);\n\tif (!devcd->delete_work)\n\t\tdevcd->delete_work = true;\n\n\tflush_delayed_work(&devcd->del_wk);\n\tmutex_unlock(&devcd->mutex);\n\treturn 0;\n}\n\nstatic ssize_t disabled_show(const struct class *class, const struct class_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", devcd_disabled);\n}\n\n \n\nstatic ssize_t disabled_store(const struct class *class, const struct class_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tlong tmp = simple_strtol(buf, NULL, 10);\n\n\t \n\tif (tmp != 1)\n\t\treturn -EINVAL;\n\n\tdevcd_disabled = true;\n\n\tclass_for_each_device(&devcd_class, NULL, NULL, devcd_free);\n\n\treturn count;\n}\nstatic CLASS_ATTR_RW(disabled);\n\nstatic struct attribute *devcd_class_attrs[] = {\n\t&class_attr_disabled.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(devcd_class);\n\nstatic struct class devcd_class = {\n\t.name\t\t= \"devcoredump\",\n\t.dev_release\t= devcd_dev_release,\n\t.dev_groups\t= devcd_dev_groups,\n\t.class_groups\t= devcd_class_groups,\n};\n\nstatic ssize_t devcd_readv(char *buffer, loff_t offset, size_t count,\n\t\t\t   void *data, size_t datalen)\n{\n\treturn memory_read_from_buffer(buffer, count, &offset, data, datalen);\n}\n\nstatic void devcd_freev(void *data)\n{\n\tvfree(data);\n}\n\n \nvoid dev_coredumpv(struct device *dev, void *data, size_t datalen,\n\t\t   gfp_t gfp)\n{\n\tdev_coredumpm(dev, NULL, data, datalen, gfp, devcd_readv, devcd_freev);\n}\nEXPORT_SYMBOL_GPL(dev_coredumpv);\n\nstatic int devcd_match_failing(struct device *dev, const void *failing)\n{\n\tstruct devcd_entry *devcd = dev_to_devcd(dev);\n\n\treturn devcd->failing_dev == failing;\n}\n\n \nstatic void devcd_free_sgtable(void *data)\n{\n\t_devcd_free_sgtable(data);\n}\n\n \nstatic ssize_t devcd_read_from_sgtable(char *buffer, loff_t offset,\n\t\t\t\t       size_t buf_len, void *data,\n\t\t\t\t       size_t data_len)\n{\n\tstruct scatterlist *table = data;\n\n\tif (offset > data_len)\n\t\treturn -EINVAL;\n\n\tif (offset + buf_len > data_len)\n\t\tbuf_len = data_len - offset;\n\treturn sg_pcopy_to_buffer(table, sg_nents(table), buffer, buf_len,\n\t\t\t\t  offset);\n}\n\n \nvoid dev_coredumpm(struct device *dev, struct module *owner,\n\t\t   void *data, size_t datalen, gfp_t gfp,\n\t\t   ssize_t (*read)(char *buffer, loff_t offset, size_t count,\n\t\t\t\t   void *data, size_t datalen),\n\t\t   void (*free)(void *data))\n{\n\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n\tstruct devcd_entry *devcd;\n\tstruct device *existing;\n\n\tif (devcd_disabled)\n\t\tgoto free;\n\n\texisting = class_find_device(&devcd_class, NULL, dev,\n\t\t\t\t     devcd_match_failing);\n\tif (existing) {\n\t\tput_device(existing);\n\t\tgoto free;\n\t}\n\n\tif (!try_module_get(owner))\n\t\tgoto free;\n\n\tdevcd = kzalloc(sizeof(*devcd), gfp);\n\tif (!devcd)\n\t\tgoto put_module;\n\n\tdevcd->owner = owner;\n\tdevcd->data = data;\n\tdevcd->datalen = datalen;\n\tdevcd->read = read;\n\tdevcd->free = free;\n\tdevcd->failing_dev = get_device(dev);\n\tdevcd->delete_work = false;\n\n\tmutex_init(&devcd->mutex);\n\tdevice_initialize(&devcd->devcd_dev);\n\n\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n\t\t     atomic_inc_return(&devcd_count));\n\tdevcd->devcd_dev.class = &devcd_class;\n\n\tmutex_lock(&devcd->mutex);\n\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n\tif (device_add(&devcd->devcd_dev))\n\t\tgoto put_device;\n\n\t \n\tif (sysfs_create_link(&devcd->devcd_dev.kobj, &dev->kobj,\n\t\t\t      \"failing_device\") ||\n\t    sysfs_create_link(&dev->kobj, &devcd->devcd_dev.kobj,\n\t\t              \"devcoredump\"))\n\t\tdev_warn(dev, \"devcoredump create_link failed\\n\");\n\n\tdev_set_uevent_suppress(&devcd->devcd_dev, false);\n\tkobject_uevent(&devcd->devcd_dev.kobj, KOBJ_ADD);\n\tINIT_DELAYED_WORK(&devcd->del_wk, devcd_del);\n\tschedule_delayed_work(&devcd->del_wk, DEVCD_TIMEOUT);\n\tmutex_unlock(&devcd->mutex);\n\treturn;\n put_device:\n\tput_device(&devcd->devcd_dev);\n\tmutex_unlock(&devcd->mutex);\n put_module:\n\tmodule_put(owner);\n free:\n\tfree(data);\n}\nEXPORT_SYMBOL_GPL(dev_coredumpm);\n\n \nvoid dev_coredumpsg(struct device *dev, struct scatterlist *table,\n\t\t    size_t datalen, gfp_t gfp)\n{\n\tdev_coredumpm(dev, NULL, table, datalen, gfp, devcd_read_from_sgtable,\n\t\t      devcd_free_sgtable);\n}\nEXPORT_SYMBOL_GPL(dev_coredumpsg);\n\nstatic int __init devcoredump_init(void)\n{\n\treturn class_register(&devcd_class);\n}\n__initcall(devcoredump_init);\n\nstatic void __exit devcoredump_exit(void)\n{\n\tclass_for_each_device(&devcd_class, NULL, NULL, devcd_free);\n\tclass_unregister(&devcd_class);\n}\n__exitcall(devcoredump_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}