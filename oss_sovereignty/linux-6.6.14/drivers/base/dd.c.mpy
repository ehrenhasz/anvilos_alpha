{
  "module_name": "dd.c",
  "hash_id": "d62ed759f9dbabacdc24c09a8124fb34e9653b9d52084fc9404d914ccca5c728",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/dd.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/dma-map-ops.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/async.h>\n#include <linux/pm_runtime.h>\n#include <linux/pinctrl/devinfo.h>\n#include <linux/slab.h>\n\n#include \"base.h\"\n#include \"power/power.h\"\n\n \nstatic DEFINE_MUTEX(deferred_probe_mutex);\nstatic LIST_HEAD(deferred_probe_pending_list);\nstatic LIST_HEAD(deferred_probe_active_list);\nstatic atomic_t deferred_trigger_count = ATOMIC_INIT(0);\nstatic bool initcalls_done;\n\n \n#define ASYNC_DRV_NAMES_MAX_LEN\t256\nstatic char async_probe_drv_names[ASYNC_DRV_NAMES_MAX_LEN];\nstatic bool async_probe_default;\n\n \nstatic bool defer_all_probes;\n\nstatic void __device_set_deferred_probe_reason(const struct device *dev, char *reason)\n{\n\tkfree(dev->p->deferred_probe_reason);\n\tdev->p->deferred_probe_reason = reason;\n}\n\n \nstatic void deferred_probe_work_func(struct work_struct *work)\n{\n\tstruct device *dev;\n\tstruct device_private *private;\n\t \n\tmutex_lock(&deferred_probe_mutex);\n\twhile (!list_empty(&deferred_probe_active_list)) {\n\t\tprivate = list_first_entry(&deferred_probe_active_list,\n\t\t\t\t\ttypeof(*dev->p), deferred_probe);\n\t\tdev = private->device;\n\t\tlist_del_init(&private->deferred_probe);\n\n\t\tget_device(dev);\n\n\t\t__device_set_deferred_probe_reason(dev, NULL);\n\n\t\t \n\t\tmutex_unlock(&deferred_probe_mutex);\n\n\t\t \n\t\tdevice_pm_move_to_tail(dev);\n\n\t\tdev_dbg(dev, \"Retrying from deferred list\\n\");\n\t\tbus_probe_device(dev);\n\t\tmutex_lock(&deferred_probe_mutex);\n\n\t\tput_device(dev);\n\t}\n\tmutex_unlock(&deferred_probe_mutex);\n}\nstatic DECLARE_WORK(deferred_probe_work, deferred_probe_work_func);\n\nvoid driver_deferred_probe_add(struct device *dev)\n{\n\tif (!dev->can_match)\n\t\treturn;\n\n\tmutex_lock(&deferred_probe_mutex);\n\tif (list_empty(&dev->p->deferred_probe)) {\n\t\tdev_dbg(dev, \"Added to deferred list\\n\");\n\t\tlist_add_tail(&dev->p->deferred_probe, &deferred_probe_pending_list);\n\t}\n\tmutex_unlock(&deferred_probe_mutex);\n}\n\nvoid driver_deferred_probe_del(struct device *dev)\n{\n\tmutex_lock(&deferred_probe_mutex);\n\tif (!list_empty(&dev->p->deferred_probe)) {\n\t\tdev_dbg(dev, \"Removed from deferred list\\n\");\n\t\tlist_del_init(&dev->p->deferred_probe);\n\t\t__device_set_deferred_probe_reason(dev, NULL);\n\t}\n\tmutex_unlock(&deferred_probe_mutex);\n}\n\nstatic bool driver_deferred_probe_enable;\n \nvoid driver_deferred_probe_trigger(void)\n{\n\tif (!driver_deferred_probe_enable)\n\t\treturn;\n\n\t \n\tmutex_lock(&deferred_probe_mutex);\n\tatomic_inc(&deferred_trigger_count);\n\tlist_splice_tail_init(&deferred_probe_pending_list,\n\t\t\t      &deferred_probe_active_list);\n\tmutex_unlock(&deferred_probe_mutex);\n\n\t \n\tqueue_work(system_unbound_wq, &deferred_probe_work);\n}\n\n \nvoid device_block_probing(void)\n{\n\tdefer_all_probes = true;\n\t \n\twait_for_device_probe();\n}\n\n \nvoid device_unblock_probing(void)\n{\n\tdefer_all_probes = false;\n\tdriver_deferred_probe_trigger();\n}\n\n \nvoid device_set_deferred_probe_reason(const struct device *dev, struct va_format *vaf)\n{\n\tconst char *drv = dev_driver_string(dev);\n\tchar *reason;\n\n\tmutex_lock(&deferred_probe_mutex);\n\n\treason = kasprintf(GFP_KERNEL, \"%s: %pV\", drv, vaf);\n\t__device_set_deferred_probe_reason(dev, reason);\n\n\tmutex_unlock(&deferred_probe_mutex);\n}\n\n \nstatic int deferred_devs_show(struct seq_file *s, void *data)\n{\n\tstruct device_private *curr;\n\n\tmutex_lock(&deferred_probe_mutex);\n\n\tlist_for_each_entry(curr, &deferred_probe_pending_list, deferred_probe)\n\t\tseq_printf(s, \"%s\\t%s\", dev_name(curr->device),\n\t\t\t   curr->device->p->deferred_probe_reason ?: \"\\n\");\n\n\tmutex_unlock(&deferred_probe_mutex);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(deferred_devs);\n\n#ifdef CONFIG_MODULES\nstatic int driver_deferred_probe_timeout = 10;\n#else\nstatic int driver_deferred_probe_timeout;\n#endif\n\nstatic int __init deferred_probe_timeout_setup(char *str)\n{\n\tint timeout;\n\n\tif (!kstrtoint(str, 10, &timeout))\n\t\tdriver_deferred_probe_timeout = timeout;\n\treturn 1;\n}\n__setup(\"deferred_probe_timeout=\", deferred_probe_timeout_setup);\n\n \nint driver_deferred_probe_check_state(struct device *dev)\n{\n\tif (!IS_ENABLED(CONFIG_MODULES) && initcalls_done) {\n\t\tdev_warn(dev, \"ignoring dependency for device, assuming no driver\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!driver_deferred_probe_timeout && initcalls_done) {\n\t\tdev_warn(dev, \"deferred probe timeout, ignoring dependency\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn -EPROBE_DEFER;\n}\nEXPORT_SYMBOL_GPL(driver_deferred_probe_check_state);\n\nstatic void deferred_probe_timeout_work_func(struct work_struct *work)\n{\n\tstruct device_private *p;\n\n\tfw_devlink_drivers_done();\n\n\tdriver_deferred_probe_timeout = 0;\n\tdriver_deferred_probe_trigger();\n\tflush_work(&deferred_probe_work);\n\n\tmutex_lock(&deferred_probe_mutex);\n\tlist_for_each_entry(p, &deferred_probe_pending_list, deferred_probe)\n\t\tdev_info(p->device, \"deferred probe pending\\n\");\n\tmutex_unlock(&deferred_probe_mutex);\n\n\tfw_devlink_probing_done();\n}\nstatic DECLARE_DELAYED_WORK(deferred_probe_timeout_work, deferred_probe_timeout_work_func);\n\nvoid deferred_probe_extend_timeout(void)\n{\n\t \n\tif (cancel_delayed_work(&deferred_probe_timeout_work)) {\n\t\tschedule_delayed_work(&deferred_probe_timeout_work,\n\t\t\t\tdriver_deferred_probe_timeout * HZ);\n\t\tpr_debug(\"Extended deferred probe timeout by %d secs\\n\",\n\t\t\t\t\tdriver_deferred_probe_timeout);\n\t}\n}\n\n \nstatic int deferred_probe_initcall(void)\n{\n\tdebugfs_create_file(\"devices_deferred\", 0444, NULL, NULL,\n\t\t\t    &deferred_devs_fops);\n\n\tdriver_deferred_probe_enable = true;\n\tdriver_deferred_probe_trigger();\n\t \n\tflush_work(&deferred_probe_work);\n\tinitcalls_done = true;\n\n\tif (!IS_ENABLED(CONFIG_MODULES))\n\t\tfw_devlink_drivers_done();\n\n\t \n\tdriver_deferred_probe_trigger();\n\tflush_work(&deferred_probe_work);\n\n\tif (driver_deferred_probe_timeout > 0) {\n\t\tschedule_delayed_work(&deferred_probe_timeout_work,\n\t\t\tdriver_deferred_probe_timeout * HZ);\n\t}\n\n\tif (!IS_ENABLED(CONFIG_MODULES))\n\t\tfw_devlink_probing_done();\n\n\treturn 0;\n}\nlate_initcall(deferred_probe_initcall);\n\nstatic void __exit deferred_probe_exit(void)\n{\n\tdebugfs_lookup_and_remove(\"devices_deferred\", NULL);\n}\n__exitcall(deferred_probe_exit);\n\n \nbool device_is_bound(struct device *dev)\n{\n\treturn dev->p && klist_node_attached(&dev->p->knode_driver);\n}\n\nstatic void driver_bound(struct device *dev)\n{\n\tif (device_is_bound(dev)) {\n\t\tpr_warn(\"%s: device %s already bound\\n\",\n\t\t\t__func__, kobject_name(&dev->kobj));\n\t\treturn;\n\t}\n\n\tpr_debug(\"driver: '%s': %s: bound to device '%s'\\n\", dev->driver->name,\n\t\t __func__, dev_name(dev));\n\n\tklist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);\n\tdevice_links_driver_bound(dev);\n\n\tdevice_pm_check_callbacks(dev);\n\n\t \n\tdriver_deferred_probe_del(dev);\n\tdriver_deferred_probe_trigger();\n\n\tbus_notify(dev, BUS_NOTIFY_BOUND_DRIVER);\n\tkobject_uevent(&dev->kobj, KOBJ_BIND);\n}\n\nstatic ssize_t coredump_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tdevice_lock(dev);\n\tdev->driver->coredump(dev);\n\tdevice_unlock(dev);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(coredump);\n\nstatic int driver_sysfs_add(struct device *dev)\n{\n\tint ret;\n\n\tbus_notify(dev, BUS_NOTIFY_BIND_DRIVER);\n\n\tret = sysfs_create_link(&dev->driver->p->kobj, &dev->kobj,\n\t\t\t\tkobject_name(&dev->kobj));\n\tif (ret)\n\t\tgoto fail;\n\n\tret = sysfs_create_link(&dev->kobj, &dev->driver->p->kobj,\n\t\t\t\t\"driver\");\n\tif (ret)\n\t\tgoto rm_dev;\n\n\tif (!IS_ENABLED(CONFIG_DEV_COREDUMP) || !dev->driver->coredump)\n\t\treturn 0;\n\n\tret = device_create_file(dev, &dev_attr_coredump);\n\tif (!ret)\n\t\treturn 0;\n\n\tsysfs_remove_link(&dev->kobj, \"driver\");\n\nrm_dev:\n\tsysfs_remove_link(&dev->driver->p->kobj,\n\t\t\t  kobject_name(&dev->kobj));\n\nfail:\n\treturn ret;\n}\n\nstatic void driver_sysfs_remove(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\n\tif (drv) {\n\t\tif (drv->coredump)\n\t\t\tdevice_remove_file(dev, &dev_attr_coredump);\n\t\tsysfs_remove_link(&drv->p->kobj, kobject_name(&dev->kobj));\n\t\tsysfs_remove_link(&dev->kobj, \"driver\");\n\t}\n}\n\n \nint device_bind_driver(struct device *dev)\n{\n\tint ret;\n\n\tret = driver_sysfs_add(dev);\n\tif (!ret) {\n\t\tdevice_links_force_bind(dev);\n\t\tdriver_bound(dev);\n\t}\n\telse\n\t\tbus_notify(dev, BUS_NOTIFY_DRIVER_NOT_BOUND);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(device_bind_driver);\n\nstatic atomic_t probe_count = ATOMIC_INIT(0);\nstatic DECLARE_WAIT_QUEUE_HEAD(probe_waitqueue);\n\nstatic ssize_t state_synced_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tint ret = 0;\n\n\tif (strcmp(\"1\", buf))\n\t\treturn -EINVAL;\n\n\tdevice_lock(dev);\n\tif (!dev->state_synced) {\n\t\tdev->state_synced = true;\n\t\tdev_sync_state(dev);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\tdevice_unlock(dev);\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t state_synced_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tbool val;\n\n\tdevice_lock(dev);\n\tval = dev->state_synced;\n\tdevice_unlock(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", val);\n}\nstatic DEVICE_ATTR_RW(state_synced);\n\nstatic void device_unbind_cleanup(struct device *dev)\n{\n\tdevres_release_all(dev);\n\tarch_teardown_dma_ops(dev);\n\tkfree(dev->dma_range_map);\n\tdev->dma_range_map = NULL;\n\tdev->driver = NULL;\n\tdev_set_drvdata(dev, NULL);\n\tif (dev->pm_domain && dev->pm_domain->dismiss)\n\t\tdev->pm_domain->dismiss(dev);\n\tpm_runtime_reinit(dev);\n\tdev_pm_set_driver_flags(dev, 0);\n}\n\nstatic void device_remove(struct device *dev)\n{\n\tdevice_remove_file(dev, &dev_attr_state_synced);\n\tdevice_remove_groups(dev, dev->driver->dev_groups);\n\n\tif (dev->bus && dev->bus->remove)\n\t\tdev->bus->remove(dev);\n\telse if (dev->driver->remove)\n\t\tdev->driver->remove(dev);\n}\n\nstatic int call_driver_probe(struct device *dev, struct device_driver *drv)\n{\n\tint ret = 0;\n\n\tif (dev->bus->probe)\n\t\tret = dev->bus->probe(dev);\n\telse if (drv->probe)\n\t\tret = drv->probe(dev);\n\n\tswitch (ret) {\n\tcase 0:\n\t\tbreak;\n\tcase -EPROBE_DEFER:\n\t\t \n\t\tdev_dbg(dev, \"Driver %s requests probe deferral\\n\", drv->name);\n\t\tbreak;\n\tcase -ENODEV:\n\tcase -ENXIO:\n\t\tpr_debug(\"%s: probe of %s rejects match %d\\n\",\n\t\t\t drv->name, dev_name(dev), ret);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tpr_warn(\"%s: probe of %s failed with error %d\\n\",\n\t\t\tdrv->name, dev_name(dev), ret);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int really_probe(struct device *dev, struct device_driver *drv)\n{\n\tbool test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &&\n\t\t\t   !drv->suppress_bind_attrs;\n\tint ret, link_ret;\n\n\tif (defer_all_probes) {\n\t\t \n\t\tdev_dbg(dev, \"Driver %s force probe deferral\\n\", drv->name);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tlink_ret = device_links_check_suppliers(dev);\n\tif (link_ret == -EPROBE_DEFER)\n\t\treturn link_ret;\n\n\tpr_debug(\"bus: '%s': %s: probing driver %s with device %s\\n\",\n\t\t drv->bus->name, __func__, drv->name, dev_name(dev));\n\tif (!list_empty(&dev->devres_head)) {\n\t\tdev_crit(dev, \"Resources present before probing\\n\");\n\t\tret = -EBUSY;\n\t\tgoto done;\n\t}\n\nre_probe:\n\tdev->driver = drv;\n\n\t \n\tret = pinctrl_bind_pins(dev);\n\tif (ret)\n\t\tgoto pinctrl_bind_failed;\n\n\tif (dev->bus->dma_configure) {\n\t\tret = dev->bus->dma_configure(dev);\n\t\tif (ret)\n\t\t\tgoto pinctrl_bind_failed;\n\t}\n\n\tret = driver_sysfs_add(dev);\n\tif (ret) {\n\t\tpr_err(\"%s: driver_sysfs_add(%s) failed\\n\",\n\t\t       __func__, dev_name(dev));\n\t\tgoto sysfs_failed;\n\t}\n\n\tif (dev->pm_domain && dev->pm_domain->activate) {\n\t\tret = dev->pm_domain->activate(dev);\n\t\tif (ret)\n\t\t\tgoto probe_failed;\n\t}\n\n\tret = call_driver_probe(dev, drv);\n\tif (ret) {\n\t\t \n\t\tif (link_ret == -EAGAIN)\n\t\t\tret = -EPROBE_DEFER;\n\n\t\t \n\t\tret = -ret;\n\t\tgoto probe_failed;\n\t}\n\n\tret = device_add_groups(dev, drv->dev_groups);\n\tif (ret) {\n\t\tdev_err(dev, \"device_add_groups() failed\\n\");\n\t\tgoto dev_groups_failed;\n\t}\n\n\tif (dev_has_sync_state(dev)) {\n\t\tret = device_create_file(dev, &dev_attr_state_synced);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"state_synced sysfs add failed\\n\");\n\t\t\tgoto dev_sysfs_state_synced_failed;\n\t\t}\n\t}\n\n\tif (test_remove) {\n\t\ttest_remove = false;\n\n\t\tdevice_remove(dev);\n\t\tdriver_sysfs_remove(dev);\n\t\tif (dev->bus && dev->bus->dma_cleanup)\n\t\t\tdev->bus->dma_cleanup(dev);\n\t\tdevice_unbind_cleanup(dev);\n\n\t\tgoto re_probe;\n\t}\n\n\tpinctrl_init_done(dev);\n\n\tif (dev->pm_domain && dev->pm_domain->sync)\n\t\tdev->pm_domain->sync(dev);\n\n\tdriver_bound(dev);\n\tpr_debug(\"bus: '%s': %s: bound device %s to driver %s\\n\",\n\t\t drv->bus->name, __func__, dev_name(dev), drv->name);\n\tgoto done;\n\ndev_sysfs_state_synced_failed:\ndev_groups_failed:\n\tdevice_remove(dev);\nprobe_failed:\n\tdriver_sysfs_remove(dev);\nsysfs_failed:\n\tbus_notify(dev, BUS_NOTIFY_DRIVER_NOT_BOUND);\n\tif (dev->bus && dev->bus->dma_cleanup)\n\t\tdev->bus->dma_cleanup(dev);\npinctrl_bind_failed:\n\tdevice_links_no_driver(dev);\n\tdevice_unbind_cleanup(dev);\ndone:\n\treturn ret;\n}\n\n \nstatic int really_probe_debug(struct device *dev, struct device_driver *drv)\n{\n\tktime_t calltime, rettime;\n\tint ret;\n\n\tcalltime = ktime_get();\n\tret = really_probe(dev, drv);\n\trettime = ktime_get();\n\t \n\tprintk(KERN_DEBUG \"probe of %s returned %d after %lld usecs\\n\",\n\t\t dev_name(dev), ret, ktime_us_delta(rettime, calltime));\n\treturn ret;\n}\n\n \nbool __init driver_probe_done(void)\n{\n\tint local_probe_count = atomic_read(&probe_count);\n\n\tpr_debug(\"%s: probe_count = %d\\n\", __func__, local_probe_count);\n\treturn !local_probe_count;\n}\n\n \nvoid wait_for_device_probe(void)\n{\n\t \n\tflush_work(&deferred_probe_work);\n\n\t \n\twait_event(probe_waitqueue, atomic_read(&probe_count) == 0);\n\tasync_synchronize_full();\n}\nEXPORT_SYMBOL_GPL(wait_for_device_probe);\n\nstatic int __driver_probe_device(struct device_driver *drv, struct device *dev)\n{\n\tint ret = 0;\n\n\tif (dev->p->dead || !device_is_registered(dev))\n\t\treturn -ENODEV;\n\tif (dev->driver)\n\t\treturn -EBUSY;\n\n\tdev->can_match = true;\n\tpr_debug(\"bus: '%s': %s: matched device %s with driver %s\\n\",\n\t\t drv->bus->name, __func__, dev_name(dev), drv->name);\n\n\tpm_runtime_get_suppliers(dev);\n\tif (dev->parent)\n\t\tpm_runtime_get_sync(dev->parent);\n\n\tpm_runtime_barrier(dev);\n\tif (initcall_debug)\n\t\tret = really_probe_debug(dev, drv);\n\telse\n\t\tret = really_probe(dev, drv);\n\tpm_request_idle(dev);\n\n\tif (dev->parent)\n\t\tpm_runtime_put(dev->parent);\n\n\tpm_runtime_put_suppliers(dev);\n\treturn ret;\n}\n\n \nstatic int driver_probe_device(struct device_driver *drv, struct device *dev)\n{\n\tint trigger_count = atomic_read(&deferred_trigger_count);\n\tint ret;\n\n\tatomic_inc(&probe_count);\n\tret = __driver_probe_device(drv, dev);\n\tif (ret == -EPROBE_DEFER || ret == EPROBE_DEFER) {\n\t\tdriver_deferred_probe_add(dev);\n\n\t\t \n\t\tif (trigger_count != atomic_read(&deferred_trigger_count) &&\n\t\t    !defer_all_probes)\n\t\t\tdriver_deferred_probe_trigger();\n\t}\n\tatomic_dec(&probe_count);\n\twake_up_all(&probe_waitqueue);\n\treturn ret;\n}\n\nstatic inline bool cmdline_requested_async_probing(const char *drv_name)\n{\n\tbool async_drv;\n\n\tasync_drv = parse_option_str(async_probe_drv_names, drv_name);\n\n\treturn (async_probe_default != async_drv);\n}\n\n \nstatic int __init save_async_options(char *buf)\n{\n\tif (strlen(buf) >= ASYNC_DRV_NAMES_MAX_LEN)\n\t\tpr_warn(\"Too long list of driver names for 'driver_async_probe'!\\n\");\n\n\tstrscpy(async_probe_drv_names, buf, ASYNC_DRV_NAMES_MAX_LEN);\n\tasync_probe_default = parse_option_str(async_probe_drv_names, \"*\");\n\n\treturn 1;\n}\n__setup(\"driver_async_probe=\", save_async_options);\n\nstatic bool driver_allows_async_probing(struct device_driver *drv)\n{\n\tswitch (drv->probe_type) {\n\tcase PROBE_PREFER_ASYNCHRONOUS:\n\t\treturn true;\n\n\tcase PROBE_FORCE_SYNCHRONOUS:\n\t\treturn false;\n\n\tdefault:\n\t\tif (cmdline_requested_async_probing(drv->name))\n\t\t\treturn true;\n\n\t\tif (module_requested_async_probing(drv->owner))\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n}\n\nstruct device_attach_data {\n\tstruct device *dev;\n\n\t \n\tbool check_async;\n\n\t \n\tbool want_async;\n\n\t \n\tbool have_async;\n};\n\nstatic int __device_attach_driver(struct device_driver *drv, void *_data)\n{\n\tstruct device_attach_data *data = _data;\n\tstruct device *dev = data->dev;\n\tbool async_allowed;\n\tint ret;\n\n\tret = driver_match_device(drv, dev);\n\tif (ret == 0) {\n\t\t \n\t\treturn 0;\n\t} else if (ret == -EPROBE_DEFER) {\n\t\tdev_dbg(dev, \"Device match requests probe deferral\\n\");\n\t\tdev->can_match = true;\n\t\tdriver_deferred_probe_add(dev);\n\t\t \n\t\treturn ret;\n\t} else if (ret < 0) {\n\t\tdev_dbg(dev, \"Bus failed to match device: %d\\n\", ret);\n\t\treturn ret;\n\t}  \n\n\tasync_allowed = driver_allows_async_probing(drv);\n\n\tif (async_allowed)\n\t\tdata->have_async = true;\n\n\tif (data->check_async && async_allowed != data->want_async)\n\t\treturn 0;\n\n\t \n\tret = driver_probe_device(drv, dev);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn ret == 0;\n}\n\nstatic void __device_attach_async_helper(void *_dev, async_cookie_t cookie)\n{\n\tstruct device *dev = _dev;\n\tstruct device_attach_data data = {\n\t\t.dev\t\t= dev,\n\t\t.check_async\t= true,\n\t\t.want_async\t= true,\n\t};\n\n\tdevice_lock(dev);\n\n\t \n\tif (dev->p->dead || dev->driver)\n\t\tgoto out_unlock;\n\n\tif (dev->parent)\n\t\tpm_runtime_get_sync(dev->parent);\n\n\tbus_for_each_drv(dev->bus, NULL, &data, __device_attach_driver);\n\tdev_dbg(dev, \"async probe completed\\n\");\n\n\tpm_request_idle(dev);\n\n\tif (dev->parent)\n\t\tpm_runtime_put(dev->parent);\nout_unlock:\n\tdevice_unlock(dev);\n\n\tput_device(dev);\n}\n\nstatic int __device_attach(struct device *dev, bool allow_async)\n{\n\tint ret = 0;\n\tbool async = false;\n\n\tdevice_lock(dev);\n\tif (dev->p->dead) {\n\t\tgoto out_unlock;\n\t} else if (dev->driver) {\n\t\tif (device_is_bound(dev)) {\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tret = device_bind_driver(dev);\n\t\tif (ret == 0)\n\t\t\tret = 1;\n\t\telse {\n\t\t\tdev->driver = NULL;\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tstruct device_attach_data data = {\n\t\t\t.dev = dev,\n\t\t\t.check_async = allow_async,\n\t\t\t.want_async = false,\n\t\t};\n\n\t\tif (dev->parent)\n\t\t\tpm_runtime_get_sync(dev->parent);\n\n\t\tret = bus_for_each_drv(dev->bus, NULL, &data,\n\t\t\t\t\t__device_attach_driver);\n\t\tif (!ret && allow_async && data.have_async) {\n\t\t\t \n\t\t\tdev_dbg(dev, \"scheduling asynchronous probe\\n\");\n\t\t\tget_device(dev);\n\t\t\tasync = true;\n\t\t} else {\n\t\t\tpm_request_idle(dev);\n\t\t}\n\n\t\tif (dev->parent)\n\t\t\tpm_runtime_put(dev->parent);\n\t}\nout_unlock:\n\tdevice_unlock(dev);\n\tif (async)\n\t\tasync_schedule_dev(__device_attach_async_helper, dev);\n\treturn ret;\n}\n\n \nint device_attach(struct device *dev)\n{\n\treturn __device_attach(dev, false);\n}\nEXPORT_SYMBOL_GPL(device_attach);\n\nvoid device_initial_probe(struct device *dev)\n{\n\t__device_attach(dev, true);\n}\n\n \nstatic void __device_driver_lock(struct device *dev, struct device *parent)\n{\n\tif (parent && dev->bus->need_parent_lock)\n\t\tdevice_lock(parent);\n\tdevice_lock(dev);\n}\n\n \nstatic void __device_driver_unlock(struct device *dev, struct device *parent)\n{\n\tdevice_unlock(dev);\n\tif (parent && dev->bus->need_parent_lock)\n\t\tdevice_unlock(parent);\n}\n\n \nint device_driver_attach(struct device_driver *drv, struct device *dev)\n{\n\tint ret;\n\n\t__device_driver_lock(dev, dev->parent);\n\tret = __driver_probe_device(drv, dev);\n\t__device_driver_unlock(dev, dev->parent);\n\n\t \n\tif (ret > 0)\n\t\tret = -ret;\n\tif (ret == -EPROBE_DEFER)\n\t\treturn -EAGAIN;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(device_driver_attach);\n\nstatic void __driver_attach_async_helper(void *_dev, async_cookie_t cookie)\n{\n\tstruct device *dev = _dev;\n\tstruct device_driver *drv;\n\tint ret;\n\n\t__device_driver_lock(dev, dev->parent);\n\tdrv = dev->p->async_driver;\n\tdev->p->async_driver = NULL;\n\tret = driver_probe_device(drv, dev);\n\t__device_driver_unlock(dev, dev->parent);\n\n\tdev_dbg(dev, \"driver %s async attach completed: %d\\n\", drv->name, ret);\n\n\tput_device(dev);\n}\n\nstatic int __driver_attach(struct device *dev, void *data)\n{\n\tstruct device_driver *drv = data;\n\tbool async = false;\n\tint ret;\n\n\t \n\n\tret = driver_match_device(drv, dev);\n\tif (ret == 0) {\n\t\t \n\t\treturn 0;\n\t} else if (ret == -EPROBE_DEFER) {\n\t\tdev_dbg(dev, \"Device match requests probe deferral\\n\");\n\t\tdev->can_match = true;\n\t\tdriver_deferred_probe_add(dev);\n\t\t \n\t\treturn 0;\n\t} else if (ret < 0) {\n\t\tdev_dbg(dev, \"Bus failed to match device: %d\\n\", ret);\n\t\t \n\t\treturn 0;\n\t}  \n\n\tif (driver_allows_async_probing(drv)) {\n\t\t \n\t\tdev_dbg(dev, \"probing driver %s asynchronously\\n\", drv->name);\n\t\tdevice_lock(dev);\n\t\tif (!dev->driver && !dev->p->async_driver) {\n\t\t\tget_device(dev);\n\t\t\tdev->p->async_driver = drv;\n\t\t\tasync = true;\n\t\t}\n\t\tdevice_unlock(dev);\n\t\tif (async)\n\t\t\tasync_schedule_dev(__driver_attach_async_helper, dev);\n\t\treturn 0;\n\t}\n\n\t__device_driver_lock(dev, dev->parent);\n\tdriver_probe_device(drv, dev);\n\t__device_driver_unlock(dev, dev->parent);\n\n\treturn 0;\n}\n\n \nint driver_attach(struct device_driver *drv)\n{\n\treturn bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);\n}\nEXPORT_SYMBOL_GPL(driver_attach);\n\n \nstatic void __device_release_driver(struct device *dev, struct device *parent)\n{\n\tstruct device_driver *drv;\n\n\tdrv = dev->driver;\n\tif (drv) {\n\t\tpm_runtime_get_sync(dev);\n\n\t\twhile (device_links_busy(dev)) {\n\t\t\t__device_driver_unlock(dev, parent);\n\n\t\t\tdevice_links_unbind_consumers(dev);\n\n\t\t\t__device_driver_lock(dev, parent);\n\t\t\t \n\t\t\tif (dev->driver != drv) {\n\t\t\t\tpm_runtime_put(dev);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tdriver_sysfs_remove(dev);\n\n\t\tbus_notify(dev, BUS_NOTIFY_UNBIND_DRIVER);\n\n\t\tpm_runtime_put_sync(dev);\n\n\t\tdevice_remove(dev);\n\n\t\tif (dev->bus && dev->bus->dma_cleanup)\n\t\t\tdev->bus->dma_cleanup(dev);\n\n\t\tdevice_unbind_cleanup(dev);\n\t\tdevice_links_driver_cleanup(dev);\n\n\t\tklist_remove(&dev->p->knode_driver);\n\t\tdevice_pm_check_callbacks(dev);\n\n\t\tbus_notify(dev, BUS_NOTIFY_UNBOUND_DRIVER);\n\t\tkobject_uevent(&dev->kobj, KOBJ_UNBIND);\n\t}\n}\n\nvoid device_release_driver_internal(struct device *dev,\n\t\t\t\t    struct device_driver *drv,\n\t\t\t\t    struct device *parent)\n{\n\t__device_driver_lock(dev, parent);\n\n\tif (!drv || drv == dev->driver)\n\t\t__device_release_driver(dev, parent);\n\n\t__device_driver_unlock(dev, parent);\n}\n\n \nvoid device_release_driver(struct device *dev)\n{\n\t \n\tdevice_release_driver_internal(dev, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(device_release_driver);\n\n \nvoid device_driver_detach(struct device *dev)\n{\n\tdevice_release_driver_internal(dev, NULL, dev->parent);\n}\n\n \nvoid driver_detach(struct device_driver *drv)\n{\n\tstruct device_private *dev_prv;\n\tstruct device *dev;\n\n\tif (driver_allows_async_probing(drv))\n\t\tasync_synchronize_full();\n\n\tfor (;;) {\n\t\tspin_lock(&drv->p->klist_devices.k_lock);\n\t\tif (list_empty(&drv->p->klist_devices.k_list)) {\n\t\t\tspin_unlock(&drv->p->klist_devices.k_lock);\n\t\t\tbreak;\n\t\t}\n\t\tdev_prv = list_last_entry(&drv->p->klist_devices.k_list,\n\t\t\t\t     struct device_private,\n\t\t\t\t     knode_driver.n_node);\n\t\tdev = dev_prv->device;\n\t\tget_device(dev);\n\t\tspin_unlock(&drv->p->klist_devices.k_lock);\n\t\tdevice_release_driver_internal(dev, drv, dev->parent);\n\t\tput_device(dev);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}