{
  "module_name": "swnode.c",
  "hash_id": "2d86b3753298b2221876a0bbcf90355707a63ba8c804aa6bf17081c88637e691",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/swnode.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include \"base.h\"\n\nstruct swnode {\n\tstruct kobject kobj;\n\tstruct fwnode_handle fwnode;\n\tconst struct software_node *node;\n\tint id;\n\n\t \n\tstruct ida child_ids;\n\tstruct list_head entry;\n\tstruct list_head children;\n\tstruct swnode *parent;\n\n\tunsigned int allocated:1;\n\tunsigned int managed:1;\n};\n\nstatic DEFINE_IDA(swnode_root_ids);\nstatic struct kset *swnode_kset;\n\n#define kobj_to_swnode(_kobj_) container_of(_kobj_, struct swnode, kobj)\n\nstatic const struct fwnode_operations software_node_ops;\n\nbool is_software_node(const struct fwnode_handle *fwnode)\n{\n\treturn !IS_ERR_OR_NULL(fwnode) && fwnode->ops == &software_node_ops;\n}\nEXPORT_SYMBOL_GPL(is_software_node);\n\n#define to_swnode(__fwnode)\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\ttypeof(__fwnode) __to_swnode_fwnode = __fwnode;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tis_software_node(__to_swnode_fwnode) ?\t\t\t\\\n\t\t\tcontainer_of(__to_swnode_fwnode,\t\t\\\n\t\t\t\t     struct swnode, fwnode) : NULL;\t\\\n\t})\n\nstatic inline struct swnode *dev_to_swnode(struct device *dev)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\n\tif (!fwnode)\n\t\treturn NULL;\n\n\tif (!is_software_node(fwnode))\n\t\tfwnode = fwnode->secondary;\n\n\treturn to_swnode(fwnode);\n}\n\nstatic struct swnode *\nsoftware_node_to_swnode(const struct software_node *node)\n{\n\tstruct swnode *swnode = NULL;\n\tstruct kobject *k;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspin_lock(&swnode_kset->list_lock);\n\n\tlist_for_each_entry(k, &swnode_kset->list, entry) {\n\t\tswnode = kobj_to_swnode(k);\n\t\tif (swnode->node == node)\n\t\t\tbreak;\n\t\tswnode = NULL;\n\t}\n\n\tspin_unlock(&swnode_kset->list_lock);\n\n\treturn swnode;\n}\n\nconst struct software_node *to_software_node(const struct fwnode_handle *fwnode)\n{\n\tconst struct swnode *swnode = to_swnode(fwnode);\n\n\treturn swnode ? swnode->node : NULL;\n}\nEXPORT_SYMBOL_GPL(to_software_node);\n\nstruct fwnode_handle *software_node_fwnode(const struct software_node *node)\n{\n\tstruct swnode *swnode = software_node_to_swnode(node);\n\n\treturn swnode ? &swnode->fwnode : NULL;\n}\nEXPORT_SYMBOL_GPL(software_node_fwnode);\n\n \n \n\nstatic const struct property_entry *\nproperty_entry_get(const struct property_entry *prop, const char *name)\n{\n\tif (!prop)\n\t\treturn NULL;\n\n\tfor (; prop->name; prop++)\n\t\tif (!strcmp(name, prop->name))\n\t\t\treturn prop;\n\n\treturn NULL;\n}\n\nstatic const void *property_get_pointer(const struct property_entry *prop)\n{\n\tif (!prop->length)\n\t\treturn NULL;\n\n\treturn prop->is_inline ? &prop->value : prop->pointer;\n}\n\nstatic const void *property_entry_find(const struct property_entry *props,\n\t\t\t\t       const char *propname, size_t length)\n{\n\tconst struct property_entry *prop;\n\tconst void *pointer;\n\n\tprop = property_entry_get(props, propname);\n\tif (!prop)\n\t\treturn ERR_PTR(-EINVAL);\n\tpointer = property_get_pointer(prop);\n\tif (!pointer)\n\t\treturn ERR_PTR(-ENODATA);\n\tif (length > prop->length)\n\t\treturn ERR_PTR(-EOVERFLOW);\n\treturn pointer;\n}\n\nstatic int\nproperty_entry_count_elems_of_size(const struct property_entry *props,\n\t\t\t\t   const char *propname, size_t length)\n{\n\tconst struct property_entry *prop;\n\n\tprop = property_entry_get(props, propname);\n\tif (!prop)\n\t\treturn -EINVAL;\n\n\treturn prop->length / length;\n}\n\nstatic int property_entry_read_int_array(const struct property_entry *props,\n\t\t\t\t\t const char *name,\n\t\t\t\t\t unsigned int elem_size, void *val,\n\t\t\t\t\t size_t nval)\n{\n\tconst void *pointer;\n\tsize_t length;\n\n\tif (!val)\n\t\treturn property_entry_count_elems_of_size(props, name,\n\t\t\t\t\t\t\t  elem_size);\n\n\tif (!is_power_of_2(elem_size) || elem_size > sizeof(u64))\n\t\treturn -ENXIO;\n\n\tlength = nval * elem_size;\n\n\tpointer = property_entry_find(props, name, length);\n\tif (IS_ERR(pointer))\n\t\treturn PTR_ERR(pointer);\n\n\tmemcpy(val, pointer, length);\n\treturn 0;\n}\n\nstatic int property_entry_read_string_array(const struct property_entry *props,\n\t\t\t\t\t    const char *propname,\n\t\t\t\t\t    const char **strings, size_t nval)\n{\n\tconst void *pointer;\n\tsize_t length;\n\tint array_len;\n\n\t \n\tarray_len = property_entry_count_elems_of_size(props, propname,\n\t\t\t\t\t\t       sizeof(const char *));\n\tif (array_len < 0)\n\t\treturn array_len;\n\n\t \n\tif (!strings)\n\t\treturn array_len;\n\n\tarray_len = min_t(size_t, nval, array_len);\n\tlength = array_len * sizeof(*strings);\n\n\tpointer = property_entry_find(props, propname, length);\n\tif (IS_ERR(pointer))\n\t\treturn PTR_ERR(pointer);\n\n\tmemcpy(strings, pointer, length);\n\n\treturn array_len;\n}\n\nstatic void property_entry_free_data(const struct property_entry *p)\n{\n\tconst char * const *src_str;\n\tsize_t i, nval;\n\n\tif (p->type == DEV_PROP_STRING) {\n\t\tsrc_str = property_get_pointer(p);\n\t\tnval = p->length / sizeof(*src_str);\n\t\tfor (i = 0; i < nval; i++)\n\t\t\tkfree(src_str[i]);\n\t}\n\n\tif (!p->is_inline)\n\t\tkfree(p->pointer);\n\n\tkfree(p->name);\n}\n\nstatic bool property_copy_string_array(const char **dst_ptr,\n\t\t\t\t       const char * const *src_ptr,\n\t\t\t\t       size_t nval)\n{\n\tint i;\n\n\tfor (i = 0; i < nval; i++) {\n\t\tdst_ptr[i] = kstrdup(src_ptr[i], GFP_KERNEL);\n\t\tif (!dst_ptr[i] && src_ptr[i]) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tkfree(dst_ptr[i]);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic int property_entry_copy_data(struct property_entry *dst,\n\t\t\t\t    const struct property_entry *src)\n{\n\tconst void *pointer = property_get_pointer(src);\n\tvoid *dst_ptr;\n\tsize_t nval;\n\n\t \n\tif (!src->is_inline && !src->length)\n\t\treturn -ENODATA;\n\n\t \n\tif (src->type == DEV_PROP_REF && src->is_inline)\n\t\treturn -EINVAL;\n\n\tif (src->length <= sizeof(dst->value)) {\n\t\tdst_ptr = &dst->value;\n\t\tdst->is_inline = true;\n\t} else {\n\t\tdst_ptr = kmalloc(src->length, GFP_KERNEL);\n\t\tif (!dst_ptr)\n\t\t\treturn -ENOMEM;\n\t\tdst->pointer = dst_ptr;\n\t}\n\n\tif (src->type == DEV_PROP_STRING) {\n\t\tnval = src->length / sizeof(const char *);\n\t\tif (!property_copy_string_array(dst_ptr, pointer, nval)) {\n\t\t\tif (!dst->is_inline)\n\t\t\t\tkfree(dst->pointer);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tmemcpy(dst_ptr, pointer, src->length);\n\t}\n\n\tdst->length = src->length;\n\tdst->type = src->type;\n\tdst->name = kstrdup(src->name, GFP_KERNEL);\n\tif (!dst->name) {\n\t\tproperty_entry_free_data(dst);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstruct property_entry *\nproperty_entries_dup(const struct property_entry *properties)\n{\n\tstruct property_entry *p;\n\tint i, n = 0;\n\tint ret;\n\n\tif (!properties)\n\t\treturn NULL;\n\n\twhile (properties[n].name)\n\t\tn++;\n\n\tp = kcalloc(n + 1, sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < n; i++) {\n\t\tret = property_entry_copy_data(&p[i], &properties[i]);\n\t\tif (ret) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tproperty_entry_free_data(&p[i]);\n\t\t\tkfree(p);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn p;\n}\nEXPORT_SYMBOL_GPL(property_entries_dup);\n\n \nvoid property_entries_free(const struct property_entry *properties)\n{\n\tconst struct property_entry *p;\n\n\tif (!properties)\n\t\treturn;\n\n\tfor (p = properties; p->name; p++)\n\t\tproperty_entry_free_data(p);\n\n\tkfree(properties);\n}\nEXPORT_SYMBOL_GPL(property_entries_free);\n\n \n \n\nstatic struct fwnode_handle *software_node_get(struct fwnode_handle *fwnode)\n{\n\tstruct swnode *swnode = to_swnode(fwnode);\n\n\tkobject_get(&swnode->kobj);\n\n\treturn &swnode->fwnode;\n}\n\nstatic void software_node_put(struct fwnode_handle *fwnode)\n{\n\tstruct swnode *swnode = to_swnode(fwnode);\n\n\tkobject_put(&swnode->kobj);\n}\n\nstatic bool software_node_property_present(const struct fwnode_handle *fwnode,\n\t\t\t\t\t   const char *propname)\n{\n\tstruct swnode *swnode = to_swnode(fwnode);\n\n\treturn !!property_entry_get(swnode->node->properties, propname);\n}\n\nstatic int software_node_read_int_array(const struct fwnode_handle *fwnode,\n\t\t\t\t\tconst char *propname,\n\t\t\t\t\tunsigned int elem_size, void *val,\n\t\t\t\t\tsize_t nval)\n{\n\tstruct swnode *swnode = to_swnode(fwnode);\n\n\treturn property_entry_read_int_array(swnode->node->properties, propname,\n\t\t\t\t\t     elem_size, val, nval);\n}\n\nstatic int software_node_read_string_array(const struct fwnode_handle *fwnode,\n\t\t\t\t\t   const char *propname,\n\t\t\t\t\t   const char **val, size_t nval)\n{\n\tstruct swnode *swnode = to_swnode(fwnode);\n\n\treturn property_entry_read_string_array(swnode->node->properties,\n\t\t\t\t\t\tpropname, val, nval);\n}\n\nstatic const char *\nsoftware_node_get_name(const struct fwnode_handle *fwnode)\n{\n\tconst struct swnode *swnode = to_swnode(fwnode);\n\n\treturn kobject_name(&swnode->kobj);\n}\n\nstatic const char *\nsoftware_node_get_name_prefix(const struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_handle *parent;\n\tconst char *prefix;\n\n\tparent = fwnode_get_parent(fwnode);\n\tif (!parent)\n\t\treturn \"\";\n\n\t \n\twhile (is_software_node(parent))\n\t\tparent = fwnode_get_next_parent(parent);\n\n\tprefix = fwnode_get_name_prefix(parent);\n\tfwnode_handle_put(parent);\n\n\t \n\treturn prefix ?: \"/\";\n}\n\nstatic struct fwnode_handle *\nsoftware_node_get_parent(const struct fwnode_handle *fwnode)\n{\n\tstruct swnode *swnode = to_swnode(fwnode);\n\n\tif (!swnode || !swnode->parent)\n\t\treturn NULL;\n\n\treturn fwnode_handle_get(&swnode->parent->fwnode);\n}\n\nstatic struct fwnode_handle *\nsoftware_node_get_next_child(const struct fwnode_handle *fwnode,\n\t\t\t     struct fwnode_handle *child)\n{\n\tstruct swnode *p = to_swnode(fwnode);\n\tstruct swnode *c = to_swnode(child);\n\n\tif (!p || list_empty(&p->children) ||\n\t    (c && list_is_last(&c->entry, &p->children))) {\n\t\tfwnode_handle_put(child);\n\t\treturn NULL;\n\t}\n\n\tif (c)\n\t\tc = list_next_entry(c, entry);\n\telse\n\t\tc = list_first_entry(&p->children, struct swnode, entry);\n\n\tfwnode_handle_put(child);\n\treturn fwnode_handle_get(&c->fwnode);\n}\n\nstatic struct fwnode_handle *\nsoftware_node_get_named_child_node(const struct fwnode_handle *fwnode,\n\t\t\t\t   const char *childname)\n{\n\tstruct swnode *swnode = to_swnode(fwnode);\n\tstruct swnode *child;\n\n\tif (!swnode || list_empty(&swnode->children))\n\t\treturn NULL;\n\n\tlist_for_each_entry(child, &swnode->children, entry) {\n\t\tif (!strcmp(childname, kobject_name(&child->kobj))) {\n\t\t\tkobject_get(&child->kobj);\n\t\t\treturn &child->fwnode;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int\nsoftware_node_get_reference_args(const struct fwnode_handle *fwnode,\n\t\t\t\t const char *propname, const char *nargs_prop,\n\t\t\t\t unsigned int nargs, unsigned int index,\n\t\t\t\t struct fwnode_reference_args *args)\n{\n\tstruct swnode *swnode = to_swnode(fwnode);\n\tconst struct software_node_ref_args *ref_array;\n\tconst struct software_node_ref_args *ref;\n\tconst struct property_entry *prop;\n\tstruct fwnode_handle *refnode;\n\tu32 nargs_prop_val;\n\tint error;\n\tint i;\n\n\tprop = property_entry_get(swnode->node->properties, propname);\n\tif (!prop)\n\t\treturn -ENOENT;\n\n\tif (prop->type != DEV_PROP_REF)\n\t\treturn -EINVAL;\n\n\t \n\tif (prop->is_inline)\n\t\treturn -EINVAL;\n\n\tif (index * sizeof(*ref) >= prop->length)\n\t\treturn -ENOENT;\n\n\tref_array = prop->pointer;\n\tref = &ref_array[index];\n\n\trefnode = software_node_fwnode(ref->node);\n\tif (!refnode)\n\t\treturn -ENOENT;\n\n\tif (nargs_prop) {\n\t\terror = property_entry_read_int_array(ref->node->properties,\n\t\t\t\t\t\t      nargs_prop, sizeof(u32),\n\t\t\t\t\t\t      &nargs_prop_val, 1);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tnargs = nargs_prop_val;\n\t}\n\n\tif (nargs > NR_FWNODE_REFERENCE_ARGS)\n\t\treturn -EINVAL;\n\n\tif (!args)\n\t\treturn 0;\n\n\targs->fwnode = software_node_get(refnode);\n\targs->nargs = nargs;\n\n\tfor (i = 0; i < nargs; i++)\n\t\targs->args[i] = ref->args[i];\n\n\treturn 0;\n}\n\nstatic struct fwnode_handle *\nswnode_graph_find_next_port(const struct fwnode_handle *parent,\n\t\t\t    struct fwnode_handle *port)\n{\n\tstruct fwnode_handle *old = port;\n\n\twhile ((port = software_node_get_next_child(parent, old))) {\n\t\t \n\t\tif (!strncmp(to_swnode(port)->node->name, \"port@\",\n\t\t\t     strlen(\"port@\")))\n\t\t\treturn port;\n\t\told = port;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct fwnode_handle *\nsoftware_node_graph_get_next_endpoint(const struct fwnode_handle *fwnode,\n\t\t\t\t      struct fwnode_handle *endpoint)\n{\n\tstruct swnode *swnode = to_swnode(fwnode);\n\tstruct fwnode_handle *parent;\n\tstruct fwnode_handle *port;\n\n\tif (!swnode)\n\t\treturn NULL;\n\n\tif (endpoint) {\n\t\tport = software_node_get_parent(endpoint);\n\t\tparent = software_node_get_parent(port);\n\t} else {\n\t\tparent = software_node_get_named_child_node(fwnode, \"ports\");\n\t\tif (!parent)\n\t\t\tparent = software_node_get(&swnode->fwnode);\n\n\t\tport = swnode_graph_find_next_port(parent, NULL);\n\t}\n\n\tfor (; port; port = swnode_graph_find_next_port(parent, port)) {\n\t\tendpoint = software_node_get_next_child(port, endpoint);\n\t\tif (endpoint) {\n\t\t\tfwnode_handle_put(port);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfwnode_handle_put(parent);\n\n\treturn endpoint;\n}\n\nstatic struct fwnode_handle *\nsoftware_node_graph_get_remote_endpoint(const struct fwnode_handle *fwnode)\n{\n\tstruct swnode *swnode = to_swnode(fwnode);\n\tconst struct software_node_ref_args *ref;\n\tconst struct property_entry *prop;\n\n\tif (!swnode)\n\t\treturn NULL;\n\n\tprop = property_entry_get(swnode->node->properties, \"remote-endpoint\");\n\tif (!prop || prop->type != DEV_PROP_REF || prop->is_inline)\n\t\treturn NULL;\n\n\tref = prop->pointer;\n\n\treturn software_node_get(software_node_fwnode(ref[0].node));\n}\n\nstatic struct fwnode_handle *\nsoftware_node_graph_get_port_parent(struct fwnode_handle *fwnode)\n{\n\tstruct swnode *swnode = to_swnode(fwnode);\n\n\tswnode = swnode->parent;\n\tif (swnode && !strcmp(swnode->node->name, \"ports\"))\n\t\tswnode = swnode->parent;\n\n\treturn swnode ? software_node_get(&swnode->fwnode) : NULL;\n}\n\nstatic int\nsoftware_node_graph_parse_endpoint(const struct fwnode_handle *fwnode,\n\t\t\t\t   struct fwnode_endpoint *endpoint)\n{\n\tstruct swnode *swnode = to_swnode(fwnode);\n\tconst char *parent_name = swnode->parent->node->name;\n\tint ret;\n\n\tif (strlen(\"port@\") >= strlen(parent_name) ||\n\t    strncmp(parent_name, \"port@\", strlen(\"port@\")))\n\t\treturn -EINVAL;\n\n\t \n\tret = kstrtou32(parent_name + strlen(\"port@\"), 10, &endpoint->port);\n\tif (ret)\n\t\treturn ret;\n\n\tendpoint->id = swnode->id;\n\tendpoint->local_fwnode = fwnode;\n\n\treturn 0;\n}\n\nstatic const struct fwnode_operations software_node_ops = {\n\t.get = software_node_get,\n\t.put = software_node_put,\n\t.property_present = software_node_property_present,\n\t.property_read_int_array = software_node_read_int_array,\n\t.property_read_string_array = software_node_read_string_array,\n\t.get_name = software_node_get_name,\n\t.get_name_prefix = software_node_get_name_prefix,\n\t.get_parent = software_node_get_parent,\n\t.get_next_child_node = software_node_get_next_child,\n\t.get_named_child_node = software_node_get_named_child_node,\n\t.get_reference_args = software_node_get_reference_args,\n\t.graph_get_next_endpoint = software_node_graph_get_next_endpoint,\n\t.graph_get_remote_endpoint = software_node_graph_get_remote_endpoint,\n\t.graph_get_port_parent = software_node_graph_get_port_parent,\n\t.graph_parse_endpoint = software_node_graph_parse_endpoint,\n};\n\n \n\n \nconst struct software_node *\nsoftware_node_find_by_name(const struct software_node *parent, const char *name)\n{\n\tstruct swnode *swnode = NULL;\n\tstruct kobject *k;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tspin_lock(&swnode_kset->list_lock);\n\n\tlist_for_each_entry(k, &swnode_kset->list, entry) {\n\t\tswnode = kobj_to_swnode(k);\n\t\tif (parent == swnode->node->parent && swnode->node->name &&\n\t\t    !strcmp(name, swnode->node->name)) {\n\t\t\tkobject_get(&swnode->kobj);\n\t\t\tbreak;\n\t\t}\n\t\tswnode = NULL;\n\t}\n\n\tspin_unlock(&swnode_kset->list_lock);\n\n\treturn swnode ? swnode->node : NULL;\n}\nEXPORT_SYMBOL_GPL(software_node_find_by_name);\n\nstatic struct software_node *software_node_alloc(const struct property_entry *properties)\n{\n\tstruct property_entry *props;\n\tstruct software_node *node;\n\n\tprops = property_entries_dup(properties);\n\tif (IS_ERR(props))\n\t\treturn ERR_CAST(props);\n\n\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\tif (!node) {\n\t\tproperty_entries_free(props);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tnode->properties = props;\n\n\treturn node;\n}\n\nstatic void software_node_free(const struct software_node *node)\n{\n\tproperty_entries_free(node->properties);\n\tkfree(node);\n}\n\nstatic void software_node_release(struct kobject *kobj)\n{\n\tstruct swnode *swnode = kobj_to_swnode(kobj);\n\n\tif (swnode->parent) {\n\t\tida_simple_remove(&swnode->parent->child_ids, swnode->id);\n\t\tlist_del(&swnode->entry);\n\t} else {\n\t\tida_simple_remove(&swnode_root_ids, swnode->id);\n\t}\n\n\tif (swnode->allocated)\n\t\tsoftware_node_free(swnode->node);\n\n\tida_destroy(&swnode->child_ids);\n\tkfree(swnode);\n}\n\nstatic const struct kobj_type software_node_type = {\n\t.release = software_node_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n};\n\nstatic struct fwnode_handle *\nswnode_register(const struct software_node *node, struct swnode *parent,\n\t\tunsigned int allocated)\n{\n\tstruct swnode *swnode;\n\tint ret;\n\n\tswnode = kzalloc(sizeof(*swnode), GFP_KERNEL);\n\tif (!swnode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = ida_simple_get(parent ? &parent->child_ids : &swnode_root_ids,\n\t\t\t     0, 0, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tkfree(swnode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tswnode->id = ret;\n\tswnode->node = node;\n\tswnode->parent = parent;\n\tswnode->kobj.kset = swnode_kset;\n\tfwnode_init(&swnode->fwnode, &software_node_ops);\n\n\tida_init(&swnode->child_ids);\n\tINIT_LIST_HEAD(&swnode->entry);\n\tINIT_LIST_HEAD(&swnode->children);\n\n\tif (node->name)\n\t\tret = kobject_init_and_add(&swnode->kobj, &software_node_type,\n\t\t\t\t\t   parent ? &parent->kobj : NULL,\n\t\t\t\t\t   \"%s\", node->name);\n\telse\n\t\tret = kobject_init_and_add(&swnode->kobj, &software_node_type,\n\t\t\t\t\t   parent ? &parent->kobj : NULL,\n\t\t\t\t\t   \"node%d\", swnode->id);\n\tif (ret) {\n\t\tkobject_put(&swnode->kobj);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tswnode->allocated = allocated;\n\n\tif (parent)\n\t\tlist_add_tail(&swnode->entry, &parent->children);\n\n\tkobject_uevent(&swnode->kobj, KOBJ_ADD);\n\treturn &swnode->fwnode;\n}\n\n \nint software_node_register_node_group(const struct software_node **node_group)\n{\n\tunsigned int i;\n\tint ret;\n\n\tif (!node_group)\n\t\treturn 0;\n\n\tfor (i = 0; node_group[i]; i++) {\n\t\tret = software_node_register(node_group[i]);\n\t\tif (ret) {\n\t\t\tsoftware_node_unregister_node_group(node_group);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(software_node_register_node_group);\n\n \nvoid software_node_unregister_node_group(\n\t\tconst struct software_node **node_group)\n{\n\tunsigned int i = 0;\n\n\tif (!node_group)\n\t\treturn;\n\n\twhile (node_group[i])\n\t\ti++;\n\n\twhile (i--)\n\t\tsoftware_node_unregister(node_group[i]);\n}\nEXPORT_SYMBOL_GPL(software_node_unregister_node_group);\n\n \nint software_node_register(const struct software_node *node)\n{\n\tstruct swnode *parent = software_node_to_swnode(node->parent);\n\n\tif (software_node_to_swnode(node))\n\t\treturn -EEXIST;\n\n\tif (node->parent && !parent)\n\t\treturn -EINVAL;\n\n\treturn PTR_ERR_OR_ZERO(swnode_register(node, parent, 0));\n}\nEXPORT_SYMBOL_GPL(software_node_register);\n\n \nvoid software_node_unregister(const struct software_node *node)\n{\n\tstruct swnode *swnode;\n\n\tswnode = software_node_to_swnode(node);\n\tif (swnode)\n\t\tfwnode_remove_software_node(&swnode->fwnode);\n}\nEXPORT_SYMBOL_GPL(software_node_unregister);\n\nstruct fwnode_handle *\nfwnode_create_software_node(const struct property_entry *properties,\n\t\t\t    const struct fwnode_handle *parent)\n{\n\tstruct fwnode_handle *fwnode;\n\tstruct software_node *node;\n\tstruct swnode *p;\n\n\tif (IS_ERR(parent))\n\t\treturn ERR_CAST(parent);\n\n\tp = to_swnode(parent);\n\tif (parent && !p)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnode = software_node_alloc(properties);\n\tif (IS_ERR(node))\n\t\treturn ERR_CAST(node);\n\n\tnode->parent = p ? p->node : NULL;\n\n\tfwnode = swnode_register(node, p, 1);\n\tif (IS_ERR(fwnode))\n\t\tsoftware_node_free(node);\n\n\treturn fwnode;\n}\nEXPORT_SYMBOL_GPL(fwnode_create_software_node);\n\nvoid fwnode_remove_software_node(struct fwnode_handle *fwnode)\n{\n\tstruct swnode *swnode = to_swnode(fwnode);\n\n\tif (!swnode)\n\t\treturn;\n\n\tkobject_put(&swnode->kobj);\n}\nEXPORT_SYMBOL_GPL(fwnode_remove_software_node);\n\n \nint device_add_software_node(struct device *dev, const struct software_node *node)\n{\n\tstruct swnode *swnode;\n\tint ret;\n\n\t \n\tif (dev_to_swnode(dev))\n\t\treturn -EBUSY;\n\n\tswnode = software_node_to_swnode(node);\n\tif (swnode) {\n\t\tkobject_get(&swnode->kobj);\n\t} else {\n\t\tret = software_node_register(node);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswnode = software_node_to_swnode(node);\n\t}\n\n\tset_secondary_fwnode(dev, &swnode->fwnode);\n\n\t \n\tif (device_is_registered(dev))\n\t\tsoftware_node_notify(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(device_add_software_node);\n\n \nvoid device_remove_software_node(struct device *dev)\n{\n\tstruct swnode *swnode;\n\n\tswnode = dev_to_swnode(dev);\n\tif (!swnode)\n\t\treturn;\n\n\tif (device_is_registered(dev))\n\t\tsoftware_node_notify_remove(dev);\n\n\tset_secondary_fwnode(dev, NULL);\n\tkobject_put(&swnode->kobj);\n}\nEXPORT_SYMBOL_GPL(device_remove_software_node);\n\n \nint device_create_managed_software_node(struct device *dev,\n\t\t\t\t\tconst struct property_entry *properties,\n\t\t\t\t\tconst struct software_node *parent)\n{\n\tstruct fwnode_handle *p = software_node_fwnode(parent);\n\tstruct fwnode_handle *fwnode;\n\n\tif (parent && !p)\n\t\treturn -EINVAL;\n\n\tfwnode = fwnode_create_software_node(properties, p);\n\tif (IS_ERR(fwnode))\n\t\treturn PTR_ERR(fwnode);\n\n\tto_swnode(fwnode)->managed = true;\n\tset_secondary_fwnode(dev, fwnode);\n\n\tif (device_is_registered(dev))\n\t\tsoftware_node_notify(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(device_create_managed_software_node);\n\nvoid software_node_notify(struct device *dev)\n{\n\tstruct swnode *swnode;\n\tint ret;\n\n\tswnode = dev_to_swnode(dev);\n\tif (!swnode)\n\t\treturn;\n\n\tret = sysfs_create_link(&dev->kobj, &swnode->kobj, \"software_node\");\n\tif (ret)\n\t\treturn;\n\n\tret = sysfs_create_link(&swnode->kobj, &dev->kobj, dev_name(dev));\n\tif (ret) {\n\t\tsysfs_remove_link(&dev->kobj, \"software_node\");\n\t\treturn;\n\t}\n\n\tkobject_get(&swnode->kobj);\n}\n\nvoid software_node_notify_remove(struct device *dev)\n{\n\tstruct swnode *swnode;\n\n\tswnode = dev_to_swnode(dev);\n\tif (!swnode)\n\t\treturn;\n\n\tsysfs_remove_link(&swnode->kobj, dev_name(dev));\n\tsysfs_remove_link(&dev->kobj, \"software_node\");\n\tkobject_put(&swnode->kobj);\n\n\tif (swnode->managed) {\n\t\tset_secondary_fwnode(dev, NULL);\n\t\tkobject_put(&swnode->kobj);\n\t}\n}\n\nstatic int __init software_node_init(void)\n{\n\tswnode_kset = kset_create_and_add(\"software_nodes\", NULL, kernel_kobj);\n\tif (!swnode_kset)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\npostcore_initcall(software_node_init);\n\nstatic void __exit software_node_exit(void)\n{\n\tida_destroy(&swnode_root_ids);\n\tkset_unregister(swnode_kset);\n}\n__exitcall(software_node_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}