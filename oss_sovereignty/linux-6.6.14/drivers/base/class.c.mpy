{
  "module_name": "class.c",
  "hash_id": "76eb00d848b55befddd7ceae2a5723b8fdf8432cc5080b84d46d76cf6eacf4be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/class.c",
  "human_readable_source": "\n \n\n#include <linux/device/class.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kdev_t.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/mutex.h>\n#include \"base.h\"\n\n \nstatic struct kset *class_kset;\n\n#define to_class_attr(_attr) container_of(_attr, struct class_attribute, attr)\n\n \nstruct subsys_private *class_to_subsys(const struct class *class)\n{\n\tstruct subsys_private *sp = NULL;\n\tstruct kobject *kobj;\n\n\tif (!class || !class_kset)\n\t\treturn NULL;\n\n\tspin_lock(&class_kset->list_lock);\n\n\tif (list_empty(&class_kset->list))\n\t\tgoto done;\n\n\tlist_for_each_entry(kobj, &class_kset->list, entry) {\n\t\tstruct kset *kset = container_of(kobj, struct kset, kobj);\n\n\t\tsp = container_of_const(kset, struct subsys_private, subsys);\n\t\tif (sp->class == class)\n\t\t\tgoto done;\n\t}\n\tsp = NULL;\ndone:\n\tsp = subsys_get(sp);\n\tspin_unlock(&class_kset->list_lock);\n\treturn sp;\n}\n\nstatic ssize_t class_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct class_attribute *class_attr = to_class_attr(attr);\n\tstruct subsys_private *cp = to_subsys_private(kobj);\n\tssize_t ret = -EIO;\n\n\tif (class_attr->show)\n\t\tret = class_attr->show(cp->class, class_attr, buf);\n\treturn ret;\n}\n\nstatic ssize_t class_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct class_attribute *class_attr = to_class_attr(attr);\n\tstruct subsys_private *cp = to_subsys_private(kobj);\n\tssize_t ret = -EIO;\n\n\tif (class_attr->store)\n\t\tret = class_attr->store(cp->class, class_attr, buf, count);\n\treturn ret;\n}\n\nstatic void class_release(struct kobject *kobj)\n{\n\tstruct subsys_private *cp = to_subsys_private(kobj);\n\tconst struct class *class = cp->class;\n\n\tpr_debug(\"class '%s': release.\\n\", class->name);\n\n\tif (class->class_release)\n\t\tclass->class_release(class);\n\telse\n\t\tpr_debug(\"class '%s' does not have a release() function, \"\n\t\t\t \"be careful\\n\", class->name);\n\n\tlockdep_unregister_key(&cp->lock_key);\n\tkfree(cp);\n}\n\nstatic const struct kobj_ns_type_operations *class_child_ns_type(const struct kobject *kobj)\n{\n\tconst struct subsys_private *cp = to_subsys_private(kobj);\n\tconst struct class *class = cp->class;\n\n\treturn class->ns_type;\n}\n\nstatic const struct sysfs_ops class_sysfs_ops = {\n\t.show\t   = class_attr_show,\n\t.store\t   = class_attr_store,\n};\n\nstatic const struct kobj_type class_ktype = {\n\t.sysfs_ops\t= &class_sysfs_ops,\n\t.release\t= class_release,\n\t.child_ns_type\t= class_child_ns_type,\n};\n\nint class_create_file_ns(const struct class *cls, const struct class_attribute *attr,\n\t\t\t const void *ns)\n{\n\tstruct subsys_private *sp = class_to_subsys(cls);\n\tint error;\n\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\terror = sysfs_create_file_ns(&sp->subsys.kobj, &attr->attr, ns);\n\tsubsys_put(sp);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(class_create_file_ns);\n\nvoid class_remove_file_ns(const struct class *cls, const struct class_attribute *attr,\n\t\t\t  const void *ns)\n{\n\tstruct subsys_private *sp = class_to_subsys(cls);\n\n\tif (!sp)\n\t\treturn;\n\n\tsysfs_remove_file_ns(&sp->subsys.kobj, &attr->attr, ns);\n\tsubsys_put(sp);\n}\nEXPORT_SYMBOL_GPL(class_remove_file_ns);\n\nstatic struct device *klist_class_to_dev(struct klist_node *n)\n{\n\tstruct device_private *p = to_device_private_class(n);\n\treturn p->device;\n}\n\nstatic void klist_class_dev_get(struct klist_node *n)\n{\n\tstruct device *dev = klist_class_to_dev(n);\n\n\tget_device(dev);\n}\n\nstatic void klist_class_dev_put(struct klist_node *n)\n{\n\tstruct device *dev = klist_class_to_dev(n);\n\n\tput_device(dev);\n}\n\nint class_register(const struct class *cls)\n{\n\tstruct subsys_private *cp;\n\tstruct lock_class_key *key;\n\tint error;\n\n\tpr_debug(\"device class '%s': registering\\n\", cls->name);\n\n\tcp = kzalloc(sizeof(*cp), GFP_KERNEL);\n\tif (!cp)\n\t\treturn -ENOMEM;\n\tklist_init(&cp->klist_devices, klist_class_dev_get, klist_class_dev_put);\n\tINIT_LIST_HEAD(&cp->interfaces);\n\tkset_init(&cp->glue_dirs);\n\tkey = &cp->lock_key;\n\tlockdep_register_key(key);\n\t__mutex_init(&cp->mutex, \"subsys mutex\", key);\n\terror = kobject_set_name(&cp->subsys.kobj, \"%s\", cls->name);\n\tif (error) {\n\t\tkfree(cp);\n\t\treturn error;\n\t}\n\n\tcp->subsys.kobj.kset = class_kset;\n\tcp->subsys.kobj.ktype = &class_ktype;\n\tcp->class = cls;\n\n\terror = kset_register(&cp->subsys);\n\tif (error)\n\t\tgoto err_out;\n\n\terror = sysfs_create_groups(&cp->subsys.kobj, cls->class_groups);\n\tif (error) {\n\t\tkobject_del(&cp->subsys.kobj);\n\t\tkfree_const(cp->subsys.kobj.name);\n\t\tgoto err_out;\n\t}\n\treturn 0;\n\nerr_out:\n\tlockdep_unregister_key(key);\n\tkfree(cp);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(class_register);\n\nvoid class_unregister(const struct class *cls)\n{\n\tstruct subsys_private *sp = class_to_subsys(cls);\n\n\tif (!sp)\n\t\treturn;\n\n\tpr_debug(\"device class '%s': unregistering\\n\", cls->name);\n\n\tsysfs_remove_groups(&sp->subsys.kobj, cls->class_groups);\n\tkset_unregister(&sp->subsys);\n\tsubsys_put(sp);\n}\nEXPORT_SYMBOL_GPL(class_unregister);\n\nstatic void class_create_release(const struct class *cls)\n{\n\tpr_debug(\"%s called for %s\\n\", __func__, cls->name);\n\tkfree(cls);\n}\n\n \nstruct class *class_create(const char *name)\n{\n\tstruct class *cls;\n\tint retval;\n\n\tcls = kzalloc(sizeof(*cls), GFP_KERNEL);\n\tif (!cls) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tcls->name = name;\n\tcls->class_release = class_create_release;\n\n\tretval = class_register(cls);\n\tif (retval)\n\t\tgoto error;\n\n\treturn cls;\n\nerror:\n\tkfree(cls);\n\treturn ERR_PTR(retval);\n}\nEXPORT_SYMBOL_GPL(class_create);\n\n \nvoid class_destroy(const struct class *cls)\n{\n\tif (IS_ERR_OR_NULL(cls))\n\t\treturn;\n\n\tclass_unregister(cls);\n}\nEXPORT_SYMBOL_GPL(class_destroy);\n\n \nvoid class_dev_iter_init(struct class_dev_iter *iter, const struct class *class,\n\t\t\t const struct device *start, const struct device_type *type)\n{\n\tstruct subsys_private *sp = class_to_subsys(class);\n\tstruct klist_node *start_knode = NULL;\n\n\tif (!sp)\n\t\treturn;\n\n\tif (start)\n\t\tstart_knode = &start->p->knode_class;\n\tklist_iter_init_node(&sp->klist_devices, &iter->ki, start_knode);\n\titer->type = type;\n\titer->sp = sp;\n}\nEXPORT_SYMBOL_GPL(class_dev_iter_init);\n\n \nstruct device *class_dev_iter_next(struct class_dev_iter *iter)\n{\n\tstruct klist_node *knode;\n\tstruct device *dev;\n\n\twhile (1) {\n\t\tknode = klist_next(&iter->ki);\n\t\tif (!knode)\n\t\t\treturn NULL;\n\t\tdev = klist_class_to_dev(knode);\n\t\tif (!iter->type || iter->type == dev->type)\n\t\t\treturn dev;\n\t}\n}\nEXPORT_SYMBOL_GPL(class_dev_iter_next);\n\n \nvoid class_dev_iter_exit(struct class_dev_iter *iter)\n{\n\tklist_iter_exit(&iter->ki);\n\tsubsys_put(iter->sp);\n}\nEXPORT_SYMBOL_GPL(class_dev_iter_exit);\n\n \nint class_for_each_device(const struct class *class, const struct device *start,\n\t\t\t  void *data, int (*fn)(struct device *, void *))\n{\n\tstruct subsys_private *sp = class_to_subsys(class);\n\tstruct class_dev_iter iter;\n\tstruct device *dev;\n\tint error = 0;\n\n\tif (!class)\n\t\treturn -EINVAL;\n\tif (!sp) {\n\t\tWARN(1, \"%s called for class '%s' before it was initialized\",\n\t\t     __func__, class->name);\n\t\treturn -EINVAL;\n\t}\n\n\tclass_dev_iter_init(&iter, class, start, NULL);\n\twhile ((dev = class_dev_iter_next(&iter))) {\n\t\terror = fn(dev, data);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\tclass_dev_iter_exit(&iter);\n\tsubsys_put(sp);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(class_for_each_device);\n\n \nstruct device *class_find_device(const struct class *class, const struct device *start,\n\t\t\t\t const void *data,\n\t\t\t\t int (*match)(struct device *, const void *))\n{\n\tstruct subsys_private *sp = class_to_subsys(class);\n\tstruct class_dev_iter iter;\n\tstruct device *dev;\n\n\tif (!class)\n\t\treturn NULL;\n\tif (!sp) {\n\t\tWARN(1, \"%s called for class '%s' before it was initialized\",\n\t\t     __func__, class->name);\n\t\treturn NULL;\n\t}\n\n\tclass_dev_iter_init(&iter, class, start, NULL);\n\twhile ((dev = class_dev_iter_next(&iter))) {\n\t\tif (match(dev, data)) {\n\t\t\tget_device(dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\tclass_dev_iter_exit(&iter);\n\tsubsys_put(sp);\n\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(class_find_device);\n\nint class_interface_register(struct class_interface *class_intf)\n{\n\tstruct subsys_private *sp;\n\tconst struct class *parent;\n\tstruct class_dev_iter iter;\n\tstruct device *dev;\n\n\tif (!class_intf || !class_intf->class)\n\t\treturn -ENODEV;\n\n\tparent = class_intf->class;\n\tsp = class_to_subsys(parent);\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\t \n\n\tmutex_lock(&sp->mutex);\n\tlist_add_tail(&class_intf->node, &sp->interfaces);\n\tif (class_intf->add_dev) {\n\t\tclass_dev_iter_init(&iter, parent, NULL, NULL);\n\t\twhile ((dev = class_dev_iter_next(&iter)))\n\t\t\tclass_intf->add_dev(dev);\n\t\tclass_dev_iter_exit(&iter);\n\t}\n\tmutex_unlock(&sp->mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(class_interface_register);\n\nvoid class_interface_unregister(struct class_interface *class_intf)\n{\n\tstruct subsys_private *sp;\n\tconst struct class *parent = class_intf->class;\n\tstruct class_dev_iter iter;\n\tstruct device *dev;\n\n\tif (!parent)\n\t\treturn;\n\n\tsp = class_to_subsys(parent);\n\tif (!sp)\n\t\treturn;\n\n\tmutex_lock(&sp->mutex);\n\tlist_del_init(&class_intf->node);\n\tif (class_intf->remove_dev) {\n\t\tclass_dev_iter_init(&iter, parent, NULL, NULL);\n\t\twhile ((dev = class_dev_iter_next(&iter)))\n\t\t\tclass_intf->remove_dev(dev);\n\t\tclass_dev_iter_exit(&iter);\n\t}\n\tmutex_unlock(&sp->mutex);\n\n\t \n\tsubsys_put(sp);\n\tsubsys_put(sp);\n}\nEXPORT_SYMBOL_GPL(class_interface_unregister);\n\nssize_t show_class_attr_string(const struct class *class,\n\t\t\t       const struct class_attribute *attr, char *buf)\n{\n\tstruct class_attribute_string *cs;\n\n\tcs = container_of(attr, struct class_attribute_string, attr);\n\treturn sysfs_emit(buf, \"%s\\n\", cs->str);\n}\n\nEXPORT_SYMBOL_GPL(show_class_attr_string);\n\nstruct class_compat {\n\tstruct kobject *kobj;\n};\n\n \nstruct class_compat *class_compat_register(const char *name)\n{\n\tstruct class_compat *cls;\n\n\tcls = kmalloc(sizeof(struct class_compat), GFP_KERNEL);\n\tif (!cls)\n\t\treturn NULL;\n\tcls->kobj = kobject_create_and_add(name, &class_kset->kobj);\n\tif (!cls->kobj) {\n\t\tkfree(cls);\n\t\treturn NULL;\n\t}\n\treturn cls;\n}\nEXPORT_SYMBOL_GPL(class_compat_register);\n\n \nvoid class_compat_unregister(struct class_compat *cls)\n{\n\tkobject_put(cls->kobj);\n\tkfree(cls);\n}\nEXPORT_SYMBOL_GPL(class_compat_unregister);\n\n \nint class_compat_create_link(struct class_compat *cls, struct device *dev,\n\t\t\t     struct device *device_link)\n{\n\tint error;\n\n\terror = sysfs_create_link(cls->kobj, &dev->kobj, dev_name(dev));\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (device_link) {\n\t\terror = sysfs_create_link(&dev->kobj, &device_link->kobj,\n\t\t\t\t\t  \"device\");\n\t\tif (error)\n\t\t\tsysfs_remove_link(cls->kobj, dev_name(dev));\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(class_compat_create_link);\n\n \nvoid class_compat_remove_link(struct class_compat *cls, struct device *dev,\n\t\t\t      struct device *device_link)\n{\n\tif (device_link)\n\t\tsysfs_remove_link(&dev->kobj, \"device\");\n\tsysfs_remove_link(cls->kobj, dev_name(dev));\n}\nEXPORT_SYMBOL_GPL(class_compat_remove_link);\n\n \nbool class_is_registered(const struct class *class)\n{\n\tstruct subsys_private *sp = class_to_subsys(class);\n\tbool is_initialized = false;\n\n\tif (sp) {\n\t\tis_initialized = true;\n\t\tsubsys_put(sp);\n\t}\n\treturn is_initialized;\n}\nEXPORT_SYMBOL_GPL(class_is_registered);\n\nint __init classes_init(void)\n{\n\tclass_kset = kset_create_and_add(\"class\", NULL, NULL);\n\tif (!class_kset)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}