{
  "module_name": "bus.c",
  "hash_id": "0bfdb4ccea5a2e64d0c7f94579f6af8f231b42e0d45b7379fedb4c4a4a4e1040",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/bus.c",
  "human_readable_source": "\n \n\n#include <linux/async.h>\n#include <linux/device/bus.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/sysfs.h>\n#include \"base.h\"\n#include \"power/power.h\"\n\n \nstatic struct kset *system_kset;\n\n \nstatic struct kset *bus_kset;\n\n#define to_bus_attr(_attr) container_of(_attr, struct bus_attribute, attr)\n\n \n\n#define to_drv_attr(_attr) container_of(_attr, struct driver_attribute, attr)\n\n#define DRIVER_ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store) \\\n\tstruct driver_attribute driver_attr_##_name =\t\t\\\n\t\t__ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store)\n\nstatic int __must_check bus_rescan_devices_helper(struct device *dev,\n\t\t\t\t\t\tvoid *data);\n\n \nstatic struct subsys_private *bus_to_subsys(const struct bus_type *bus)\n{\n\tstruct subsys_private *sp = NULL;\n\tstruct kobject *kobj;\n\n\tif (!bus || !bus_kset)\n\t\treturn NULL;\n\n\tspin_lock(&bus_kset->list_lock);\n\n\tif (list_empty(&bus_kset->list))\n\t\tgoto done;\n\n\tlist_for_each_entry(kobj, &bus_kset->list, entry) {\n\t\tstruct kset *kset = container_of(kobj, struct kset, kobj);\n\n\t\tsp = container_of_const(kset, struct subsys_private, subsys);\n\t\tif (sp->bus == bus)\n\t\t\tgoto done;\n\t}\n\tsp = NULL;\ndone:\n\tsp = subsys_get(sp);\n\tspin_unlock(&bus_kset->list_lock);\n\treturn sp;\n}\n\nstatic const struct bus_type *bus_get(const struct bus_type *bus)\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\n\tif (sp)\n\t\treturn bus;\n\treturn NULL;\n}\n\nstatic void bus_put(const struct bus_type *bus)\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\n\t \n\tsubsys_put(sp);\n\tsubsys_put(sp);\n}\n\nstatic ssize_t drv_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct driver_attribute *drv_attr = to_drv_attr(attr);\n\tstruct driver_private *drv_priv = to_driver(kobj);\n\tssize_t ret = -EIO;\n\n\tif (drv_attr->show)\n\t\tret = drv_attr->show(drv_priv->driver, buf);\n\treturn ret;\n}\n\nstatic ssize_t drv_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct driver_attribute *drv_attr = to_drv_attr(attr);\n\tstruct driver_private *drv_priv = to_driver(kobj);\n\tssize_t ret = -EIO;\n\n\tif (drv_attr->store)\n\t\tret = drv_attr->store(drv_priv->driver, buf, count);\n\treturn ret;\n}\n\nstatic const struct sysfs_ops driver_sysfs_ops = {\n\t.show\t= drv_attr_show,\n\t.store\t= drv_attr_store,\n};\n\nstatic void driver_release(struct kobject *kobj)\n{\n\tstruct driver_private *drv_priv = to_driver(kobj);\n\n\tpr_debug(\"driver: '%s': %s\\n\", kobject_name(kobj), __func__);\n\tkfree(drv_priv);\n}\n\nstatic const struct kobj_type driver_ktype = {\n\t.sysfs_ops\t= &driver_sysfs_ops,\n\t.release\t= driver_release,\n};\n\n \nstatic ssize_t bus_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct bus_attribute *bus_attr = to_bus_attr(attr);\n\tstruct subsys_private *subsys_priv = to_subsys_private(kobj);\n\tssize_t ret = 0;\n\n\tif (bus_attr->show)\n\t\tret = bus_attr->show(subsys_priv->bus, buf);\n\treturn ret;\n}\n\nstatic ssize_t bus_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct bus_attribute *bus_attr = to_bus_attr(attr);\n\tstruct subsys_private *subsys_priv = to_subsys_private(kobj);\n\tssize_t ret = 0;\n\n\tif (bus_attr->store)\n\t\tret = bus_attr->store(subsys_priv->bus, buf, count);\n\treturn ret;\n}\n\nstatic const struct sysfs_ops bus_sysfs_ops = {\n\t.show\t= bus_attr_show,\n\t.store\t= bus_attr_store,\n};\n\nint bus_create_file(const struct bus_type *bus, struct bus_attribute *attr)\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\tint error;\n\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\terror = sysfs_create_file(&sp->subsys.kobj, &attr->attr);\n\n\tsubsys_put(sp);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(bus_create_file);\n\nvoid bus_remove_file(const struct bus_type *bus, struct bus_attribute *attr)\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\n\tif (!sp)\n\t\treturn;\n\n\tsysfs_remove_file(&sp->subsys.kobj, &attr->attr);\n\tsubsys_put(sp);\n}\nEXPORT_SYMBOL_GPL(bus_remove_file);\n\nstatic void bus_release(struct kobject *kobj)\n{\n\tstruct subsys_private *priv = to_subsys_private(kobj);\n\n\tlockdep_unregister_key(&priv->lock_key);\n\tkfree(priv);\n}\n\nstatic const struct kobj_type bus_ktype = {\n\t.sysfs_ops\t= &bus_sysfs_ops,\n\t.release\t= bus_release,\n};\n\nstatic int bus_uevent_filter(const struct kobject *kobj)\n{\n\tconst struct kobj_type *ktype = get_ktype(kobj);\n\n\tif (ktype == &bus_ktype)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic const struct kset_uevent_ops bus_uevent_ops = {\n\t.filter = bus_uevent_filter,\n};\n\n \nstatic ssize_t unbind_store(struct device_driver *drv, const char *buf,\n\t\t\t    size_t count)\n{\n\tconst struct bus_type *bus = bus_get(drv->bus);\n\tstruct device *dev;\n\tint err = -ENODEV;\n\n\tdev = bus_find_device_by_name(bus, NULL, buf);\n\tif (dev && dev->driver == drv) {\n\t\tdevice_driver_detach(dev);\n\t\terr = count;\n\t}\n\tput_device(dev);\n\tbus_put(bus);\n\treturn err;\n}\nstatic DRIVER_ATTR_IGNORE_LOCKDEP(unbind, 0200, NULL, unbind_store);\n\n \nstatic ssize_t bind_store(struct device_driver *drv, const char *buf,\n\t\t\t  size_t count)\n{\n\tconst struct bus_type *bus = bus_get(drv->bus);\n\tstruct device *dev;\n\tint err = -ENODEV;\n\n\tdev = bus_find_device_by_name(bus, NULL, buf);\n\tif (dev && driver_match_device(drv, dev)) {\n\t\terr = device_driver_attach(drv, dev);\n\t\tif (!err) {\n\t\t\t \n\t\t\terr = count;\n\t\t}\n\t}\n\tput_device(dev);\n\tbus_put(bus);\n\treturn err;\n}\nstatic DRIVER_ATTR_IGNORE_LOCKDEP(bind, 0200, NULL, bind_store);\n\nstatic ssize_t drivers_autoprobe_show(const struct bus_type *bus, char *buf)\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\tint ret;\n\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\tret = sysfs_emit(buf, \"%d\\n\", sp->drivers_autoprobe);\n\tsubsys_put(sp);\n\treturn ret;\n}\n\nstatic ssize_t drivers_autoprobe_store(const struct bus_type *bus,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\tif (buf[0] == '0')\n\t\tsp->drivers_autoprobe = 0;\n\telse\n\t\tsp->drivers_autoprobe = 1;\n\n\tsubsys_put(sp);\n\treturn count;\n}\n\nstatic ssize_t drivers_probe_store(const struct bus_type *bus,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct device *dev;\n\tint err = -EINVAL;\n\n\tdev = bus_find_device_by_name(bus, NULL, buf);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tif (bus_rescan_devices_helper(dev, NULL) == 0)\n\t\terr = count;\n\tput_device(dev);\n\treturn err;\n}\n\nstatic struct device *next_device(struct klist_iter *i)\n{\n\tstruct klist_node *n = klist_next(i);\n\tstruct device *dev = NULL;\n\tstruct device_private *dev_prv;\n\n\tif (n) {\n\t\tdev_prv = to_device_private_bus(n);\n\t\tdev = dev_prv->device;\n\t}\n\treturn dev;\n}\n\n \nint bus_for_each_dev(const struct bus_type *bus, struct device *start,\n\t\t     void *data, int (*fn)(struct device *, void *))\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\tstruct klist_iter i;\n\tstruct device *dev;\n\tint error = 0;\n\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\tklist_iter_init_node(&sp->klist_devices, &i,\n\t\t\t     (start ? &start->p->knode_bus : NULL));\n\twhile (!error && (dev = next_device(&i)))\n\t\terror = fn(dev, data);\n\tklist_iter_exit(&i);\n\tsubsys_put(sp);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(bus_for_each_dev);\n\n \nstruct device *bus_find_device(const struct bus_type *bus,\n\t\t\t       struct device *start, const void *data,\n\t\t\t       int (*match)(struct device *dev, const void *data))\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\tstruct klist_iter i;\n\tstruct device *dev;\n\n\tif (!sp)\n\t\treturn NULL;\n\n\tklist_iter_init_node(&sp->klist_devices, &i,\n\t\t\t     (start ? &start->p->knode_bus : NULL));\n\twhile ((dev = next_device(&i)))\n\t\tif (match(dev, data) && get_device(dev))\n\t\t\tbreak;\n\tklist_iter_exit(&i);\n\tsubsys_put(sp);\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(bus_find_device);\n\nstatic struct device_driver *next_driver(struct klist_iter *i)\n{\n\tstruct klist_node *n = klist_next(i);\n\tstruct driver_private *drv_priv;\n\n\tif (n) {\n\t\tdrv_priv = container_of(n, struct driver_private, knode_bus);\n\t\treturn drv_priv->driver;\n\t}\n\treturn NULL;\n}\n\n \nint bus_for_each_drv(const struct bus_type *bus, struct device_driver *start,\n\t\t     void *data, int (*fn)(struct device_driver *, void *))\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\tstruct klist_iter i;\n\tstruct device_driver *drv;\n\tint error = 0;\n\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\tklist_iter_init_node(&sp->klist_drivers, &i,\n\t\t\t     start ? &start->p->knode_bus : NULL);\n\twhile ((drv = next_driver(&i)) && !error)\n\t\terror = fn(drv, data);\n\tklist_iter_exit(&i);\n\tsubsys_put(sp);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(bus_for_each_drv);\n\n \nint bus_add_device(struct device *dev)\n{\n\tstruct subsys_private *sp = bus_to_subsys(dev->bus);\n\tint error;\n\n\tif (!sp) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\n\tpr_debug(\"bus: '%s': add device %s\\n\", sp->bus->name, dev_name(dev));\n\n\terror = device_add_groups(dev, sp->bus->dev_groups);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = sysfs_create_link(&sp->devices_kset->kobj, &dev->kobj, dev_name(dev));\n\tif (error)\n\t\tgoto out_groups;\n\n\terror = sysfs_create_link(&dev->kobj, &sp->subsys.kobj, \"subsystem\");\n\tif (error)\n\t\tgoto out_subsys;\n\n\tklist_add_tail(&dev->p->knode_bus, &sp->klist_devices);\n\treturn 0;\n\nout_subsys:\n\tsysfs_remove_link(&sp->devices_kset->kobj, dev_name(dev));\nout_groups:\n\tdevice_remove_groups(dev, sp->bus->dev_groups);\nout_put:\n\tsubsys_put(sp);\n\treturn error;\n}\n\n \nvoid bus_probe_device(struct device *dev)\n{\n\tstruct subsys_private *sp = bus_to_subsys(dev->bus);\n\tstruct subsys_interface *sif;\n\n\tif (!sp)\n\t\treturn;\n\n\tif (sp->drivers_autoprobe)\n\t\tdevice_initial_probe(dev);\n\n\tmutex_lock(&sp->mutex);\n\tlist_for_each_entry(sif, &sp->interfaces, node)\n\t\tif (sif->add_dev)\n\t\t\tsif->add_dev(dev, sif);\n\tmutex_unlock(&sp->mutex);\n\tsubsys_put(sp);\n}\n\n \nvoid bus_remove_device(struct device *dev)\n{\n\tstruct subsys_private *sp = bus_to_subsys(dev->bus);\n\tstruct subsys_interface *sif;\n\n\tif (!sp)\n\t\treturn;\n\n\tmutex_lock(&sp->mutex);\n\tlist_for_each_entry(sif, &sp->interfaces, node)\n\t\tif (sif->remove_dev)\n\t\t\tsif->remove_dev(dev, sif);\n\tmutex_unlock(&sp->mutex);\n\n\tsysfs_remove_link(&dev->kobj, \"subsystem\");\n\tsysfs_remove_link(&sp->devices_kset->kobj, dev_name(dev));\n\tdevice_remove_groups(dev, dev->bus->dev_groups);\n\tif (klist_node_attached(&dev->p->knode_bus))\n\t\tklist_del(&dev->p->knode_bus);\n\n\tpr_debug(\"bus: '%s': remove device %s\\n\",\n\t\t dev->bus->name, dev_name(dev));\n\tdevice_release_driver(dev);\n\n\t \n\tsubsys_put(sp);\n\tsubsys_put(sp);\n}\n\nstatic int __must_check add_bind_files(struct device_driver *drv)\n{\n\tint ret;\n\n\tret = driver_create_file(drv, &driver_attr_unbind);\n\tif (ret == 0) {\n\t\tret = driver_create_file(drv, &driver_attr_bind);\n\t\tif (ret)\n\t\t\tdriver_remove_file(drv, &driver_attr_unbind);\n\t}\n\treturn ret;\n}\n\nstatic void remove_bind_files(struct device_driver *drv)\n{\n\tdriver_remove_file(drv, &driver_attr_bind);\n\tdriver_remove_file(drv, &driver_attr_unbind);\n}\n\nstatic BUS_ATTR_WO(drivers_probe);\nstatic BUS_ATTR_RW(drivers_autoprobe);\n\nstatic int add_probe_files(const struct bus_type *bus)\n{\n\tint retval;\n\n\tretval = bus_create_file(bus, &bus_attr_drivers_probe);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = bus_create_file(bus, &bus_attr_drivers_autoprobe);\n\tif (retval)\n\t\tbus_remove_file(bus, &bus_attr_drivers_probe);\nout:\n\treturn retval;\n}\n\nstatic void remove_probe_files(const struct bus_type *bus)\n{\n\tbus_remove_file(bus, &bus_attr_drivers_autoprobe);\n\tbus_remove_file(bus, &bus_attr_drivers_probe);\n}\n\nstatic ssize_t uevent_store(struct device_driver *drv, const char *buf,\n\t\t\t    size_t count)\n{\n\tint rc;\n\n\trc = kobject_synth_uevent(&drv->p->kobj, buf, count);\n\treturn rc ? rc : count;\n}\nstatic DRIVER_ATTR_WO(uevent);\n\n \nint bus_add_driver(struct device_driver *drv)\n{\n\tstruct subsys_private *sp = bus_to_subsys(drv->bus);\n\tstruct driver_private *priv;\n\tint error = 0;\n\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\t \n\tpr_debug(\"bus: '%s': add driver %s\\n\", sp->bus->name, drv->name);\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\terror = -ENOMEM;\n\t\tgoto out_put_bus;\n\t}\n\tklist_init(&priv->klist_devices, NULL, NULL);\n\tpriv->driver = drv;\n\tdrv->p = priv;\n\tpriv->kobj.kset = sp->drivers_kset;\n\terror = kobject_init_and_add(&priv->kobj, &driver_ktype, NULL,\n\t\t\t\t     \"%s\", drv->name);\n\tif (error)\n\t\tgoto out_unregister;\n\n\tklist_add_tail(&priv->knode_bus, &sp->klist_drivers);\n\tif (sp->drivers_autoprobe) {\n\t\terror = driver_attach(drv);\n\t\tif (error)\n\t\t\tgoto out_del_list;\n\t}\n\tmodule_add_driver(drv->owner, drv);\n\n\terror = driver_create_file(drv, &driver_attr_uevent);\n\tif (error) {\n\t\tprintk(KERN_ERR \"%s: uevent attr (%s) failed\\n\",\n\t\t\t__func__, drv->name);\n\t}\n\terror = driver_add_groups(drv, sp->bus->drv_groups);\n\tif (error) {\n\t\t \n\t\tprintk(KERN_ERR \"%s: driver_add_groups(%s) failed\\n\",\n\t\t\t__func__, drv->name);\n\t}\n\n\tif (!drv->suppress_bind_attrs) {\n\t\terror = add_bind_files(drv);\n\t\tif (error) {\n\t\t\t \n\t\t\tprintk(KERN_ERR \"%s: add_bind_files(%s) failed\\n\",\n\t\t\t\t__func__, drv->name);\n\t\t}\n\t}\n\n\treturn 0;\n\nout_del_list:\n\tklist_del(&priv->knode_bus);\nout_unregister:\n\tkobject_put(&priv->kobj);\n\t \n\tdrv->p = NULL;\nout_put_bus:\n\tsubsys_put(sp);\n\treturn error;\n}\n\n \nvoid bus_remove_driver(struct device_driver *drv)\n{\n\tstruct subsys_private *sp = bus_to_subsys(drv->bus);\n\n\tif (!sp)\n\t\treturn;\n\n\tpr_debug(\"bus: '%s': remove driver %s\\n\", sp->bus->name, drv->name);\n\n\tif (!drv->suppress_bind_attrs)\n\t\tremove_bind_files(drv);\n\tdriver_remove_groups(drv, sp->bus->drv_groups);\n\tdriver_remove_file(drv, &driver_attr_uevent);\n\tklist_remove(&drv->p->knode_bus);\n\tdriver_detach(drv);\n\tmodule_remove_driver(drv);\n\tkobject_put(&drv->p->kobj);\n\n\t \n\tsubsys_put(sp);\n\tsubsys_put(sp);\n}\n\n \nstatic int __must_check bus_rescan_devices_helper(struct device *dev,\n\t\t\t\t\t\t  void *data)\n{\n\tint ret = 0;\n\n\tif (!dev->driver) {\n\t\tif (dev->parent && dev->bus->need_parent_lock)\n\t\t\tdevice_lock(dev->parent);\n\t\tret = device_attach(dev);\n\t\tif (dev->parent && dev->bus->need_parent_lock)\n\t\t\tdevice_unlock(dev->parent);\n\t}\n\treturn ret < 0 ? ret : 0;\n}\n\n \nint bus_rescan_devices(const struct bus_type *bus)\n{\n\treturn bus_for_each_dev(bus, NULL, NULL, bus_rescan_devices_helper);\n}\nEXPORT_SYMBOL_GPL(bus_rescan_devices);\n\n \nint device_reprobe(struct device *dev)\n{\n\tif (dev->driver)\n\t\tdevice_driver_detach(dev);\n\treturn bus_rescan_devices_helper(dev, NULL);\n}\nEXPORT_SYMBOL_GPL(device_reprobe);\n\nstatic void klist_devices_get(struct klist_node *n)\n{\n\tstruct device_private *dev_prv = to_device_private_bus(n);\n\tstruct device *dev = dev_prv->device;\n\n\tget_device(dev);\n}\n\nstatic void klist_devices_put(struct klist_node *n)\n{\n\tstruct device_private *dev_prv = to_device_private_bus(n);\n\tstruct device *dev = dev_prv->device;\n\n\tput_device(dev);\n}\n\nstatic ssize_t bus_uevent_store(const struct bus_type *bus,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\tint ret;\n\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\tret = kobject_synth_uevent(&sp->subsys.kobj, buf, count);\n\tsubsys_put(sp);\n\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\n \nstatic struct bus_attribute bus_attr_uevent = __ATTR(uevent, 0200, NULL,\n\t\t\t\t\t\t     bus_uevent_store);\n\n \nint bus_register(const struct bus_type *bus)\n{\n\tint retval;\n\tstruct subsys_private *priv;\n\tstruct kobject *bus_kobj;\n\tstruct lock_class_key *key;\n\n\tpriv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->bus = bus;\n\n\tBLOCKING_INIT_NOTIFIER_HEAD(&priv->bus_notifier);\n\n\tbus_kobj = &priv->subsys.kobj;\n\tretval = kobject_set_name(bus_kobj, \"%s\", bus->name);\n\tif (retval)\n\t\tgoto out;\n\n\tbus_kobj->kset = bus_kset;\n\tbus_kobj->ktype = &bus_ktype;\n\tpriv->drivers_autoprobe = 1;\n\n\tretval = kset_register(&priv->subsys);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = bus_create_file(bus, &bus_attr_uevent);\n\tif (retval)\n\t\tgoto bus_uevent_fail;\n\n\tpriv->devices_kset = kset_create_and_add(\"devices\", NULL, bus_kobj);\n\tif (!priv->devices_kset) {\n\t\tretval = -ENOMEM;\n\t\tgoto bus_devices_fail;\n\t}\n\n\tpriv->drivers_kset = kset_create_and_add(\"drivers\", NULL, bus_kobj);\n\tif (!priv->drivers_kset) {\n\t\tretval = -ENOMEM;\n\t\tgoto bus_drivers_fail;\n\t}\n\n\tINIT_LIST_HEAD(&priv->interfaces);\n\tkey = &priv->lock_key;\n\tlockdep_register_key(key);\n\t__mutex_init(&priv->mutex, \"subsys mutex\", key);\n\tklist_init(&priv->klist_devices, klist_devices_get, klist_devices_put);\n\tklist_init(&priv->klist_drivers, NULL, NULL);\n\n\tretval = add_probe_files(bus);\n\tif (retval)\n\t\tgoto bus_probe_files_fail;\n\n\tretval = sysfs_create_groups(bus_kobj, bus->bus_groups);\n\tif (retval)\n\t\tgoto bus_groups_fail;\n\n\tpr_debug(\"bus: '%s': registered\\n\", bus->name);\n\treturn 0;\n\nbus_groups_fail:\n\tremove_probe_files(bus);\nbus_probe_files_fail:\n\tkset_unregister(priv->drivers_kset);\nbus_drivers_fail:\n\tkset_unregister(priv->devices_kset);\nbus_devices_fail:\n\tbus_remove_file(bus, &bus_attr_uevent);\nbus_uevent_fail:\n\tkset_unregister(&priv->subsys);\nout:\n\tkfree(priv);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(bus_register);\n\n \nvoid bus_unregister(const struct bus_type *bus)\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\tstruct kobject *bus_kobj;\n\n\tif (!sp)\n\t\treturn;\n\n\tpr_debug(\"bus: '%s': unregistering\\n\", bus->name);\n\tif (sp->dev_root)\n\t\tdevice_unregister(sp->dev_root);\n\n\tbus_kobj = &sp->subsys.kobj;\n\tsysfs_remove_groups(bus_kobj, bus->bus_groups);\n\tremove_probe_files(bus);\n\tbus_remove_file(bus, &bus_attr_uevent);\n\n\tkset_unregister(sp->drivers_kset);\n\tkset_unregister(sp->devices_kset);\n\tkset_unregister(&sp->subsys);\n\tsubsys_put(sp);\n}\nEXPORT_SYMBOL_GPL(bus_unregister);\n\nint bus_register_notifier(const struct bus_type *bus, struct notifier_block *nb)\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\tint retval;\n\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\tretval = blocking_notifier_chain_register(&sp->bus_notifier, nb);\n\tsubsys_put(sp);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(bus_register_notifier);\n\nint bus_unregister_notifier(const struct bus_type *bus, struct notifier_block *nb)\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\tint retval;\n\n\tif (!sp)\n\t\treturn -EINVAL;\n\tretval = blocking_notifier_chain_unregister(&sp->bus_notifier, nb);\n\tsubsys_put(sp);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(bus_unregister_notifier);\n\nvoid bus_notify(struct device *dev, enum bus_notifier_event value)\n{\n\tstruct subsys_private *sp = bus_to_subsys(dev->bus);\n\n\tif (!sp)\n\t\treturn;\n\n\tblocking_notifier_call_chain(&sp->bus_notifier, value, dev);\n\tsubsys_put(sp);\n}\n\nstruct kset *bus_get_kset(const struct bus_type *bus)\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\tstruct kset *kset;\n\n\tif (!sp)\n\t\treturn NULL;\n\n\tkset = &sp->subsys;\n\tsubsys_put(sp);\n\n\treturn kset;\n}\nEXPORT_SYMBOL_GPL(bus_get_kset);\n\n \nstatic void device_insertion_sort_klist(struct device *a, struct list_head *list,\n\t\t\t\t\tint (*compare)(const struct device *a,\n\t\t\t\t\t\t\tconst struct device *b))\n{\n\tstruct klist_node *n;\n\tstruct device_private *dev_prv;\n\tstruct device *b;\n\n\tlist_for_each_entry(n, list, n_node) {\n\t\tdev_prv = to_device_private_bus(n);\n\t\tb = dev_prv->device;\n\t\tif (compare(a, b) <= 0) {\n\t\t\tlist_move_tail(&a->p->knode_bus.n_node,\n\t\t\t\t       &b->p->knode_bus.n_node);\n\t\t\treturn;\n\t\t}\n\t}\n\tlist_move_tail(&a->p->knode_bus.n_node, list);\n}\n\nvoid bus_sort_breadthfirst(struct bus_type *bus,\n\t\t\t   int (*compare)(const struct device *a,\n\t\t\t\t\t  const struct device *b))\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\tLIST_HEAD(sorted_devices);\n\tstruct klist_node *n, *tmp;\n\tstruct device_private *dev_prv;\n\tstruct device *dev;\n\tstruct klist *device_klist;\n\n\tif (!sp)\n\t\treturn;\n\tdevice_klist = &sp->klist_devices;\n\n\tspin_lock(&device_klist->k_lock);\n\tlist_for_each_entry_safe(n, tmp, &device_klist->k_list, n_node) {\n\t\tdev_prv = to_device_private_bus(n);\n\t\tdev = dev_prv->device;\n\t\tdevice_insertion_sort_klist(dev, &sorted_devices, compare);\n\t}\n\tlist_splice(&sorted_devices, &device_klist->k_list);\n\tspin_unlock(&device_klist->k_lock);\n\tsubsys_put(sp);\n}\nEXPORT_SYMBOL_GPL(bus_sort_breadthfirst);\n\nstruct subsys_dev_iter {\n\tstruct klist_iter\t\tki;\n\tconst struct device_type\t*type;\n};\n\n \nstatic void subsys_dev_iter_init(struct subsys_dev_iter *iter, struct subsys_private *sp,\n\t\t\t\t struct device *start, const struct device_type *type)\n{\n\tstruct klist_node *start_knode = NULL;\n\n\tif (start)\n\t\tstart_knode = &start->p->knode_bus;\n\tklist_iter_init_node(&sp->klist_devices, &iter->ki, start_knode);\n\titer->type = type;\n}\n\n \nstatic struct device *subsys_dev_iter_next(struct subsys_dev_iter *iter)\n{\n\tstruct klist_node *knode;\n\tstruct device *dev;\n\n\tfor (;;) {\n\t\tknode = klist_next(&iter->ki);\n\t\tif (!knode)\n\t\t\treturn NULL;\n\t\tdev = to_device_private_bus(knode)->device;\n\t\tif (!iter->type || iter->type == dev->type)\n\t\t\treturn dev;\n\t}\n}\n\n \nstatic void subsys_dev_iter_exit(struct subsys_dev_iter *iter)\n{\n\tklist_iter_exit(&iter->ki);\n}\n\nint subsys_interface_register(struct subsys_interface *sif)\n{\n\tstruct subsys_private *sp;\n\tstruct subsys_dev_iter iter;\n\tstruct device *dev;\n\n\tif (!sif || !sif->subsys)\n\t\treturn -ENODEV;\n\n\tsp = bus_to_subsys(sif->subsys);\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\t \n\n\tmutex_lock(&sp->mutex);\n\tlist_add_tail(&sif->node, &sp->interfaces);\n\tif (sif->add_dev) {\n\t\tsubsys_dev_iter_init(&iter, sp, NULL, NULL);\n\t\twhile ((dev = subsys_dev_iter_next(&iter)))\n\t\t\tsif->add_dev(dev, sif);\n\t\tsubsys_dev_iter_exit(&iter);\n\t}\n\tmutex_unlock(&sp->mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(subsys_interface_register);\n\nvoid subsys_interface_unregister(struct subsys_interface *sif)\n{\n\tstruct subsys_private *sp;\n\tstruct subsys_dev_iter iter;\n\tstruct device *dev;\n\n\tif (!sif || !sif->subsys)\n\t\treturn;\n\n\tsp = bus_to_subsys(sif->subsys);\n\tif (!sp)\n\t\treturn;\n\n\tmutex_lock(&sp->mutex);\n\tlist_del_init(&sif->node);\n\tif (sif->remove_dev) {\n\t\tsubsys_dev_iter_init(&iter, sp, NULL, NULL);\n\t\twhile ((dev = subsys_dev_iter_next(&iter)))\n\t\t\tsif->remove_dev(dev, sif);\n\t\tsubsys_dev_iter_exit(&iter);\n\t}\n\tmutex_unlock(&sp->mutex);\n\n\t \n\tsubsys_put(sp);\n\tsubsys_put(sp);\n}\nEXPORT_SYMBOL_GPL(subsys_interface_unregister);\n\nstatic void system_root_device_release(struct device *dev)\n{\n\tkfree(dev);\n}\n\nstatic int subsys_register(struct bus_type *subsys,\n\t\t\t   const struct attribute_group **groups,\n\t\t\t   struct kobject *parent_of_root)\n{\n\tstruct subsys_private *sp;\n\tstruct device *dev;\n\tint err;\n\n\terr = bus_register(subsys);\n\tif (err < 0)\n\t\treturn err;\n\n\tsp = bus_to_subsys(subsys);\n\tif (!sp) {\n\t\terr = -EINVAL;\n\t\tgoto err_sp;\n\t}\n\n\tdev = kzalloc(sizeof(struct device), GFP_KERNEL);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_dev;\n\t}\n\n\terr = dev_set_name(dev, \"%s\", subsys->name);\n\tif (err < 0)\n\t\tgoto err_name;\n\n\tdev->kobj.parent = parent_of_root;\n\tdev->groups = groups;\n\tdev->release = system_root_device_release;\n\n\terr = device_register(dev);\n\tif (err < 0)\n\t\tgoto err_dev_reg;\n\n\tsp->dev_root = dev;\n\tsubsys_put(sp);\n\treturn 0;\n\nerr_dev_reg:\n\tput_device(dev);\n\tdev = NULL;\nerr_name:\n\tkfree(dev);\nerr_dev:\n\tsubsys_put(sp);\nerr_sp:\n\tbus_unregister(subsys);\n\treturn err;\n}\n\n \nint subsys_system_register(struct bus_type *subsys,\n\t\t\t   const struct attribute_group **groups)\n{\n\treturn subsys_register(subsys, groups, &system_kset->kobj);\n}\nEXPORT_SYMBOL_GPL(subsys_system_register);\n\n \nint subsys_virtual_register(struct bus_type *subsys,\n\t\t\t    const struct attribute_group **groups)\n{\n\tstruct kobject *virtual_dir;\n\n\tvirtual_dir = virtual_device_parent(NULL);\n\tif (!virtual_dir)\n\t\treturn -ENOMEM;\n\n\treturn subsys_register(subsys, groups, virtual_dir);\n}\nEXPORT_SYMBOL_GPL(subsys_virtual_register);\n\n \nstruct device_driver *driver_find(const char *name, const struct bus_type *bus)\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\tstruct kobject *k;\n\tstruct driver_private *priv;\n\n\tif (!sp)\n\t\treturn NULL;\n\n\tk = kset_find_obj(sp->drivers_kset, name);\n\tsubsys_put(sp);\n\tif (!k)\n\t\treturn NULL;\n\n\tpriv = to_driver(k);\n\n\t \n\tkobject_put(k);\n\treturn priv->driver;\n}\nEXPORT_SYMBOL_GPL(driver_find);\n\n \nbool bus_is_registered(const struct bus_type *bus)\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\tbool is_initialized = false;\n\n\tif (sp) {\n\t\tis_initialized = true;\n\t\tsubsys_put(sp);\n\t}\n\treturn is_initialized;\n}\n\n \nstruct device *bus_get_dev_root(const struct bus_type *bus)\n{\n\tstruct subsys_private *sp = bus_to_subsys(bus);\n\tstruct device *dev_root;\n\n\tif (!sp)\n\t\treturn NULL;\n\n\tdev_root = get_device(sp->dev_root);\n\tsubsys_put(sp);\n\treturn dev_root;\n}\nEXPORT_SYMBOL_GPL(bus_get_dev_root);\n\nint __init buses_init(void)\n{\n\tbus_kset = kset_create_and_add(\"bus\", &bus_uevent_ops, NULL);\n\tif (!bus_kset)\n\t\treturn -ENOMEM;\n\n\tsystem_kset = kset_create_and_add(\"system\", NULL, &devices_kset->kobj);\n\tif (!system_kset)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}