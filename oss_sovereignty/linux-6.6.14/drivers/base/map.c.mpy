{
  "module_name": "map.c",
  "hash_id": "0dd5c5b71369385a989a4d105e89a21a53c58497bdb9360bd6e09af2f390a3c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/map.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kdev_t.h>\n#include <linux/kobject.h>\n#include <linux/kobj_map.h>\n\nstruct kobj_map {\n\tstruct probe {\n\t\tstruct probe *next;\n\t\tdev_t dev;\n\t\tunsigned long range;\n\t\tstruct module *owner;\n\t\tkobj_probe_t *get;\n\t\tint (*lock)(dev_t, void *);\n\t\tvoid *data;\n\t} *probes[255];\n\tstruct mutex *lock;\n};\n\nint kobj_map(struct kobj_map *domain, dev_t dev, unsigned long range,\n\t     struct module *module, kobj_probe_t *probe,\n\t     int (*lock)(dev_t, void *), void *data)\n{\n\tunsigned int n = MAJOR(dev + range - 1) - MAJOR(dev) + 1;\n\tunsigned int index = MAJOR(dev);\n\tunsigned int i;\n\tstruct probe *p;\n\n\tif (n > 255)\n\t\tn = 255;\n\n\tp = kmalloc_array(n, sizeof(struct probe), GFP_KERNEL);\n\tif (p == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < n; i++, p++) {\n\t\tp->owner = module;\n\t\tp->get = probe;\n\t\tp->lock = lock;\n\t\tp->dev = dev;\n\t\tp->range = range;\n\t\tp->data = data;\n\t}\n\tmutex_lock(domain->lock);\n\tfor (i = 0, p -= n; i < n; i++, p++, index++) {\n\t\tstruct probe **s = &domain->probes[index % 255];\n\t\twhile (*s && (*s)->range < range)\n\t\t\ts = &(*s)->next;\n\t\tp->next = *s;\n\t\t*s = p;\n\t}\n\tmutex_unlock(domain->lock);\n\treturn 0;\n}\n\nvoid kobj_unmap(struct kobj_map *domain, dev_t dev, unsigned long range)\n{\n\tunsigned int n = MAJOR(dev + range - 1) - MAJOR(dev) + 1;\n\tunsigned int index = MAJOR(dev);\n\tunsigned int i;\n\tstruct probe *found = NULL;\n\n\tif (n > 255)\n\t\tn = 255;\n\n\tmutex_lock(domain->lock);\n\tfor (i = 0; i < n; i++, index++) {\n\t\tstruct probe **s;\n\t\tfor (s = &domain->probes[index % 255]; *s; s = &(*s)->next) {\n\t\t\tstruct probe *p = *s;\n\t\t\tif (p->dev == dev && p->range == range) {\n\t\t\t\t*s = p->next;\n\t\t\t\tif (!found)\n\t\t\t\t\tfound = p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(domain->lock);\n\tkfree(found);\n}\n\nstruct kobject *kobj_lookup(struct kobj_map *domain, dev_t dev, int *index)\n{\n\tstruct kobject *kobj;\n\tstruct probe *p;\n\tunsigned long best = ~0UL;\n\nretry:\n\tmutex_lock(domain->lock);\n\tfor (p = domain->probes[MAJOR(dev) % 255]; p; p = p->next) {\n\t\tstruct kobject *(*probe)(dev_t, int *, void *);\n\t\tstruct module *owner;\n\t\tvoid *data;\n\n\t\tif (p->dev > dev || p->dev + p->range - 1 < dev)\n\t\t\tcontinue;\n\t\tif (p->range - 1 >= best)\n\t\t\tbreak;\n\t\tif (!try_module_get(p->owner))\n\t\t\tcontinue;\n\t\towner = p->owner;\n\t\tdata = p->data;\n\t\tprobe = p->get;\n\t\tbest = p->range - 1;\n\t\t*index = dev - p->dev;\n\t\tif (p->lock && p->lock(dev, data) < 0) {\n\t\t\tmodule_put(owner);\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_unlock(domain->lock);\n\t\tkobj = probe(dev, index, data);\n\t\t \n\t\tmodule_put(owner);\n\t\tif (kobj)\n\t\t\treturn kobj;\n\t\tgoto retry;\n\t}\n\tmutex_unlock(domain->lock);\n\treturn NULL;\n}\n\nstruct kobj_map *kobj_map_init(kobj_probe_t *base_probe, struct mutex *lock)\n{\n\tstruct kobj_map *p = kmalloc(sizeof(struct kobj_map), GFP_KERNEL);\n\tstruct probe *base = kzalloc(sizeof(*base), GFP_KERNEL);\n\tint i;\n\n\tif ((p == NULL) || (base == NULL)) {\n\t\tkfree(p);\n\t\tkfree(base);\n\t\treturn NULL;\n\t}\n\n\tbase->dev = 1;\n\tbase->range = ~0;\n\tbase->get = base_probe;\n\tfor (i = 0; i < 255; i++)\n\t\tp->probes[i] = base;\n\tp->lock = lock;\n\treturn p;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}