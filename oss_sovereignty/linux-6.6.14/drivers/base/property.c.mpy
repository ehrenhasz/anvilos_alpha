{
  "module_name": "property.c",
  "hash_id": "9f328aa6b4bb4222e825b1a7b1568d4e44233eb34e76497de514549a1ba7a9a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/property.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_graph.h>\n#include <linux/of_irq.h>\n#include <linux/property.h>\n#include <linux/phy.h>\n\nstruct fwnode_handle *__dev_fwnode(struct device *dev)\n{\n\treturn IS_ENABLED(CONFIG_OF) && dev->of_node ?\n\t\tof_fwnode_handle(dev->of_node) : dev->fwnode;\n}\nEXPORT_SYMBOL_GPL(__dev_fwnode);\n\nconst struct fwnode_handle *__dev_fwnode_const(const struct device *dev)\n{\n\treturn IS_ENABLED(CONFIG_OF) && dev->of_node ?\n\t\tof_fwnode_handle(dev->of_node) : dev->fwnode;\n}\nEXPORT_SYMBOL_GPL(__dev_fwnode_const);\n\n \nbool device_property_present(const struct device *dev, const char *propname)\n{\n\treturn fwnode_property_present(dev_fwnode(dev), propname);\n}\nEXPORT_SYMBOL_GPL(device_property_present);\n\n \nbool fwnode_property_present(const struct fwnode_handle *fwnode,\n\t\t\t     const char *propname)\n{\n\tbool ret;\n\n\tif (IS_ERR_OR_NULL(fwnode))\n\t\treturn false;\n\n\tret = fwnode_call_bool_op(fwnode, property_present, propname);\n\tif (ret)\n\t\treturn ret;\n\n\treturn fwnode_call_bool_op(fwnode->secondary, property_present, propname);\n}\nEXPORT_SYMBOL_GPL(fwnode_property_present);\n\n \nint device_property_read_u8_array(const struct device *dev, const char *propname,\n\t\t\t\t  u8 *val, size_t nval)\n{\n\treturn fwnode_property_read_u8_array(dev_fwnode(dev), propname, val, nval);\n}\nEXPORT_SYMBOL_GPL(device_property_read_u8_array);\n\n \nint device_property_read_u16_array(const struct device *dev, const char *propname,\n\t\t\t\t   u16 *val, size_t nval)\n{\n\treturn fwnode_property_read_u16_array(dev_fwnode(dev), propname, val, nval);\n}\nEXPORT_SYMBOL_GPL(device_property_read_u16_array);\n\n \nint device_property_read_u32_array(const struct device *dev, const char *propname,\n\t\t\t\t   u32 *val, size_t nval)\n{\n\treturn fwnode_property_read_u32_array(dev_fwnode(dev), propname, val, nval);\n}\nEXPORT_SYMBOL_GPL(device_property_read_u32_array);\n\n \nint device_property_read_u64_array(const struct device *dev, const char *propname,\n\t\t\t\t   u64 *val, size_t nval)\n{\n\treturn fwnode_property_read_u64_array(dev_fwnode(dev), propname, val, nval);\n}\nEXPORT_SYMBOL_GPL(device_property_read_u64_array);\n\n \nint device_property_read_string_array(const struct device *dev, const char *propname,\n\t\t\t\t      const char **val, size_t nval)\n{\n\treturn fwnode_property_read_string_array(dev_fwnode(dev), propname, val, nval);\n}\nEXPORT_SYMBOL_GPL(device_property_read_string_array);\n\n \nint device_property_read_string(const struct device *dev, const char *propname,\n\t\t\t\tconst char **val)\n{\n\treturn fwnode_property_read_string(dev_fwnode(dev), propname, val);\n}\nEXPORT_SYMBOL_GPL(device_property_read_string);\n\n \nint device_property_match_string(const struct device *dev, const char *propname,\n\t\t\t\t const char *string)\n{\n\treturn fwnode_property_match_string(dev_fwnode(dev), propname, string);\n}\nEXPORT_SYMBOL_GPL(device_property_match_string);\n\nstatic int fwnode_property_read_int_array(const struct fwnode_handle *fwnode,\n\t\t\t\t\t  const char *propname,\n\t\t\t\t\t  unsigned int elem_size, void *val,\n\t\t\t\t\t  size_t nval)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(fwnode))\n\t\treturn -EINVAL;\n\n\tret = fwnode_call_int_op(fwnode, property_read_int_array, propname,\n\t\t\t\t elem_size, val, nval);\n\tif (ret != -EINVAL)\n\t\treturn ret;\n\n\treturn fwnode_call_int_op(fwnode->secondary, property_read_int_array, propname,\n\t\t\t\t  elem_size, val, nval);\n}\n\n \nint fwnode_property_read_u8_array(const struct fwnode_handle *fwnode,\n\t\t\t\t  const char *propname, u8 *val, size_t nval)\n{\n\treturn fwnode_property_read_int_array(fwnode, propname, sizeof(u8),\n\t\t\t\t\t      val, nval);\n}\nEXPORT_SYMBOL_GPL(fwnode_property_read_u8_array);\n\n \nint fwnode_property_read_u16_array(const struct fwnode_handle *fwnode,\n\t\t\t\t   const char *propname, u16 *val, size_t nval)\n{\n\treturn fwnode_property_read_int_array(fwnode, propname, sizeof(u16),\n\t\t\t\t\t      val, nval);\n}\nEXPORT_SYMBOL_GPL(fwnode_property_read_u16_array);\n\n \nint fwnode_property_read_u32_array(const struct fwnode_handle *fwnode,\n\t\t\t\t   const char *propname, u32 *val, size_t nval)\n{\n\treturn fwnode_property_read_int_array(fwnode, propname, sizeof(u32),\n\t\t\t\t\t      val, nval);\n}\nEXPORT_SYMBOL_GPL(fwnode_property_read_u32_array);\n\n \nint fwnode_property_read_u64_array(const struct fwnode_handle *fwnode,\n\t\t\t\t   const char *propname, u64 *val, size_t nval)\n{\n\treturn fwnode_property_read_int_array(fwnode, propname, sizeof(u64),\n\t\t\t\t\t      val, nval);\n}\nEXPORT_SYMBOL_GPL(fwnode_property_read_u64_array);\n\n \nint fwnode_property_read_string_array(const struct fwnode_handle *fwnode,\n\t\t\t\t      const char *propname, const char **val,\n\t\t\t\t      size_t nval)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(fwnode))\n\t\treturn -EINVAL;\n\n\tret = fwnode_call_int_op(fwnode, property_read_string_array, propname,\n\t\t\t\t val, nval);\n\tif (ret != -EINVAL)\n\t\treturn ret;\n\n\treturn fwnode_call_int_op(fwnode->secondary, property_read_string_array, propname,\n\t\t\t\t  val, nval);\n}\nEXPORT_SYMBOL_GPL(fwnode_property_read_string_array);\n\n \nint fwnode_property_read_string(const struct fwnode_handle *fwnode,\n\t\t\t\tconst char *propname, const char **val)\n{\n\tint ret = fwnode_property_read_string_array(fwnode, propname, val, 1);\n\n\treturn ret < 0 ? ret : 0;\n}\nEXPORT_SYMBOL_GPL(fwnode_property_read_string);\n\n \nint fwnode_property_match_string(const struct fwnode_handle *fwnode,\n\tconst char *propname, const char *string)\n{\n\tconst char **values;\n\tint nval, ret;\n\n\tnval = fwnode_property_read_string_array(fwnode, propname, NULL, 0);\n\tif (nval < 0)\n\t\treturn nval;\n\n\tif (nval == 0)\n\t\treturn -ENODATA;\n\n\tvalues = kcalloc(nval, sizeof(*values), GFP_KERNEL);\n\tif (!values)\n\t\treturn -ENOMEM;\n\n\tret = fwnode_property_read_string_array(fwnode, propname, values, nval);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tret = match_string(values, nval, string);\n\tif (ret < 0)\n\t\tret = -ENODATA;\n\nout_free:\n\tkfree(values);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(fwnode_property_match_string);\n\n \nint fwnode_property_get_reference_args(const struct fwnode_handle *fwnode,\n\t\t\t\t       const char *prop, const char *nargs_prop,\n\t\t\t\t       unsigned int nargs, unsigned int index,\n\t\t\t\t       struct fwnode_reference_args *args)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(fwnode))\n\t\treturn -ENOENT;\n\n\tret = fwnode_call_int_op(fwnode, get_reference_args, prop, nargs_prop,\n\t\t\t\t nargs, index, args);\n\tif (ret == 0)\n\t\treturn ret;\n\n\tif (IS_ERR_OR_NULL(fwnode->secondary))\n\t\treturn ret;\n\n\treturn fwnode_call_int_op(fwnode->secondary, get_reference_args, prop, nargs_prop,\n\t\t\t\t  nargs, index, args);\n}\nEXPORT_SYMBOL_GPL(fwnode_property_get_reference_args);\n\n \nstruct fwnode_handle *fwnode_find_reference(const struct fwnode_handle *fwnode,\n\t\t\t\t\t    const char *name,\n\t\t\t\t\t    unsigned int index)\n{\n\tstruct fwnode_reference_args args;\n\tint ret;\n\n\tret = fwnode_property_get_reference_args(fwnode, name, NULL, 0, index,\n\t\t\t\t\t\t &args);\n\treturn ret ? ERR_PTR(ret) : args.fwnode;\n}\nEXPORT_SYMBOL_GPL(fwnode_find_reference);\n\n \nconst char *fwnode_get_name(const struct fwnode_handle *fwnode)\n{\n\treturn fwnode_call_ptr_op(fwnode, get_name);\n}\nEXPORT_SYMBOL_GPL(fwnode_get_name);\n\n \nconst char *fwnode_get_name_prefix(const struct fwnode_handle *fwnode)\n{\n\treturn fwnode_call_ptr_op(fwnode, get_name_prefix);\n}\n\n \nstruct fwnode_handle *fwnode_get_parent(const struct fwnode_handle *fwnode)\n{\n\treturn fwnode_call_ptr_op(fwnode, get_parent);\n}\nEXPORT_SYMBOL_GPL(fwnode_get_parent);\n\n \nstruct fwnode_handle *fwnode_get_next_parent(struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_handle *parent = fwnode_get_parent(fwnode);\n\n\tfwnode_handle_put(fwnode);\n\n\treturn parent;\n}\nEXPORT_SYMBOL_GPL(fwnode_get_next_parent);\n\n \nstruct device *fwnode_get_next_parent_dev(const struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_handle *parent;\n\tstruct device *dev;\n\n\tfwnode_for_each_parent_node(fwnode, parent) {\n\t\tdev = get_dev_from_fwnode(parent);\n\t\tif (dev) {\n\t\t\tfwnode_handle_put(parent);\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nunsigned int fwnode_count_parents(const struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_handle *parent;\n\tunsigned int count = 0;\n\n\tfwnode_for_each_parent_node(fwnode, parent)\n\t\tcount++;\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(fwnode_count_parents);\n\n \nstruct fwnode_handle *fwnode_get_nth_parent(struct fwnode_handle *fwnode,\n\t\t\t\t\t    unsigned int depth)\n{\n\tstruct fwnode_handle *parent;\n\n\tif (depth == 0)\n\t\treturn fwnode_handle_get(fwnode);\n\n\tfwnode_for_each_parent_node(fwnode, parent) {\n\t\tif (--depth == 0)\n\t\t\treturn parent;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(fwnode_get_nth_parent);\n\n \nbool fwnode_is_ancestor_of(const struct fwnode_handle *ancestor, const struct fwnode_handle *child)\n{\n\tstruct fwnode_handle *parent;\n\n\tif (IS_ERR_OR_NULL(ancestor))\n\t\treturn false;\n\n\tif (child == ancestor)\n\t\treturn true;\n\n\tfwnode_for_each_parent_node(child, parent) {\n\t\tif (parent == ancestor) {\n\t\t\tfwnode_handle_put(parent);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n \nstruct fwnode_handle *\nfwnode_get_next_child_node(const struct fwnode_handle *fwnode,\n\t\t\t   struct fwnode_handle *child)\n{\n\treturn fwnode_call_ptr_op(fwnode, get_next_child_node, child);\n}\nEXPORT_SYMBOL_GPL(fwnode_get_next_child_node);\n\n \nstruct fwnode_handle *\nfwnode_get_next_available_child_node(const struct fwnode_handle *fwnode,\n\t\t\t\t     struct fwnode_handle *child)\n{\n\tstruct fwnode_handle *next_child = child;\n\n\tif (IS_ERR_OR_NULL(fwnode))\n\t\treturn NULL;\n\n\tdo {\n\t\tnext_child = fwnode_get_next_child_node(fwnode, next_child);\n\t\tif (!next_child)\n\t\t\treturn NULL;\n\t} while (!fwnode_device_is_available(next_child));\n\n\treturn next_child;\n}\nEXPORT_SYMBOL_GPL(fwnode_get_next_available_child_node);\n\n \nstruct fwnode_handle *device_get_next_child_node(const struct device *dev,\n\t\t\t\t\t\t struct fwnode_handle *child)\n{\n\tconst struct fwnode_handle *fwnode = dev_fwnode(dev);\n\tstruct fwnode_handle *next;\n\n\tif (IS_ERR_OR_NULL(fwnode))\n\t\treturn NULL;\n\n\t \n\tnext = fwnode_get_next_child_node(fwnode, child);\n\tif (next)\n\t\treturn next;\n\n\t \n\treturn fwnode_get_next_child_node(fwnode->secondary, child);\n}\nEXPORT_SYMBOL_GPL(device_get_next_child_node);\n\n \nstruct fwnode_handle *\nfwnode_get_named_child_node(const struct fwnode_handle *fwnode,\n\t\t\t    const char *childname)\n{\n\treturn fwnode_call_ptr_op(fwnode, get_named_child_node, childname);\n}\nEXPORT_SYMBOL_GPL(fwnode_get_named_child_node);\n\n \nstruct fwnode_handle *device_get_named_child_node(const struct device *dev,\n\t\t\t\t\t\t  const char *childname)\n{\n\treturn fwnode_get_named_child_node(dev_fwnode(dev), childname);\n}\nEXPORT_SYMBOL_GPL(device_get_named_child_node);\n\n \nstruct fwnode_handle *fwnode_handle_get(struct fwnode_handle *fwnode)\n{\n\tif (!fwnode_has_op(fwnode, get))\n\t\treturn fwnode;\n\n\treturn fwnode_call_ptr_op(fwnode, get);\n}\nEXPORT_SYMBOL_GPL(fwnode_handle_get);\n\n \nvoid fwnode_handle_put(struct fwnode_handle *fwnode)\n{\n\tfwnode_call_void_op(fwnode, put);\n}\nEXPORT_SYMBOL_GPL(fwnode_handle_put);\n\n \nbool fwnode_device_is_available(const struct fwnode_handle *fwnode)\n{\n\tif (IS_ERR_OR_NULL(fwnode))\n\t\treturn false;\n\n\tif (!fwnode_has_op(fwnode, device_is_available))\n\t\treturn true;\n\n\treturn fwnode_call_bool_op(fwnode, device_is_available);\n}\nEXPORT_SYMBOL_GPL(fwnode_device_is_available);\n\n \nunsigned int device_get_child_node_count(const struct device *dev)\n{\n\tstruct fwnode_handle *child;\n\tunsigned int count = 0;\n\n\tdevice_for_each_child_node(dev, child)\n\t\tcount++;\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(device_get_child_node_count);\n\nbool device_dma_supported(const struct device *dev)\n{\n\treturn fwnode_call_bool_op(dev_fwnode(dev), device_dma_supported);\n}\nEXPORT_SYMBOL_GPL(device_dma_supported);\n\nenum dev_dma_attr device_get_dma_attr(const struct device *dev)\n{\n\tif (!fwnode_has_op(dev_fwnode(dev), device_get_dma_attr))\n\t\treturn DEV_DMA_NOT_SUPPORTED;\n\n\treturn fwnode_call_int_op(dev_fwnode(dev), device_get_dma_attr);\n}\nEXPORT_SYMBOL_GPL(device_get_dma_attr);\n\n \nint fwnode_get_phy_mode(const struct fwnode_handle *fwnode)\n{\n\tconst char *pm;\n\tint err, i;\n\n\terr = fwnode_property_read_string(fwnode, \"phy-mode\", &pm);\n\tif (err < 0)\n\t\terr = fwnode_property_read_string(fwnode,\n\t\t\t\t\t\t  \"phy-connection-type\", &pm);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < PHY_INTERFACE_MODE_MAX; i++)\n\t\tif (!strcasecmp(pm, phy_modes(i)))\n\t\t\treturn i;\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(fwnode_get_phy_mode);\n\n \nint device_get_phy_mode(struct device *dev)\n{\n\treturn fwnode_get_phy_mode(dev_fwnode(dev));\n}\nEXPORT_SYMBOL_GPL(device_get_phy_mode);\n\n \nvoid __iomem *fwnode_iomap(struct fwnode_handle *fwnode, int index)\n{\n\treturn fwnode_call_ptr_op(fwnode, iomap, index);\n}\nEXPORT_SYMBOL(fwnode_iomap);\n\n \nint fwnode_irq_get(const struct fwnode_handle *fwnode, unsigned int index)\n{\n\tint ret;\n\n\tret = fwnode_call_int_op(fwnode, irq_get, index);\n\t \n\tif (ret == 0)\n\t\treturn -EINVAL;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fwnode_irq_get);\n\n \nint fwnode_irq_get_byname(const struct fwnode_handle *fwnode, const char *name)\n{\n\tint index;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tindex = fwnode_property_match_string(fwnode, \"interrupt-names\",  name);\n\tif (index < 0)\n\t\treturn index;\n\n\treturn fwnode_irq_get(fwnode, index);\n}\nEXPORT_SYMBOL(fwnode_irq_get_byname);\n\n \nstruct fwnode_handle *\nfwnode_graph_get_next_endpoint(const struct fwnode_handle *fwnode,\n\t\t\t       struct fwnode_handle *prev)\n{\n\tstruct fwnode_handle *ep, *port_parent = NULL;\n\tconst struct fwnode_handle *parent;\n\n\t \n\tif (prev) {\n\t\tport_parent = fwnode_graph_get_port_parent(prev);\n\t\tparent = port_parent;\n\t} else {\n\t\tparent = fwnode;\n\t}\n\tif (IS_ERR_OR_NULL(parent))\n\t\treturn NULL;\n\n\tep = fwnode_call_ptr_op(parent, graph_get_next_endpoint, prev);\n\tif (ep)\n\t\tgoto out_put_port_parent;\n\n\tep = fwnode_graph_get_next_endpoint(parent->secondary, NULL);\n\nout_put_port_parent:\n\tfwnode_handle_put(port_parent);\n\treturn ep;\n}\nEXPORT_SYMBOL_GPL(fwnode_graph_get_next_endpoint);\n\n \nstruct fwnode_handle *\nfwnode_graph_get_port_parent(const struct fwnode_handle *endpoint)\n{\n\tstruct fwnode_handle *port, *parent;\n\n\tport = fwnode_get_parent(endpoint);\n\tparent = fwnode_call_ptr_op(port, graph_get_port_parent);\n\n\tfwnode_handle_put(port);\n\n\treturn parent;\n}\nEXPORT_SYMBOL_GPL(fwnode_graph_get_port_parent);\n\n \nstruct fwnode_handle *\nfwnode_graph_get_remote_port_parent(const struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_handle *endpoint, *parent;\n\n\tendpoint = fwnode_graph_get_remote_endpoint(fwnode);\n\tparent = fwnode_graph_get_port_parent(endpoint);\n\n\tfwnode_handle_put(endpoint);\n\n\treturn parent;\n}\nEXPORT_SYMBOL_GPL(fwnode_graph_get_remote_port_parent);\n\n \nstruct fwnode_handle *\nfwnode_graph_get_remote_port(const struct fwnode_handle *fwnode)\n{\n\treturn fwnode_get_next_parent(fwnode_graph_get_remote_endpoint(fwnode));\n}\nEXPORT_SYMBOL_GPL(fwnode_graph_get_remote_port);\n\n \nstruct fwnode_handle *\nfwnode_graph_get_remote_endpoint(const struct fwnode_handle *fwnode)\n{\n\treturn fwnode_call_ptr_op(fwnode, graph_get_remote_endpoint);\n}\nEXPORT_SYMBOL_GPL(fwnode_graph_get_remote_endpoint);\n\nstatic bool fwnode_graph_remote_available(struct fwnode_handle *ep)\n{\n\tstruct fwnode_handle *dev_node;\n\tbool available;\n\n\tdev_node = fwnode_graph_get_remote_port_parent(ep);\n\tavailable = fwnode_device_is_available(dev_node);\n\tfwnode_handle_put(dev_node);\n\n\treturn available;\n}\n\n \nstruct fwnode_handle *\nfwnode_graph_get_endpoint_by_id(const struct fwnode_handle *fwnode,\n\t\t\t\tu32 port, u32 endpoint, unsigned long flags)\n{\n\tstruct fwnode_handle *ep, *best_ep = NULL;\n\tunsigned int best_ep_id = 0;\n\tbool endpoint_next = flags & FWNODE_GRAPH_ENDPOINT_NEXT;\n\tbool enabled_only = !(flags & FWNODE_GRAPH_DEVICE_DISABLED);\n\n\tfwnode_graph_for_each_endpoint(fwnode, ep) {\n\t\tstruct fwnode_endpoint fwnode_ep = { 0 };\n\t\tint ret;\n\n\t\tif (enabled_only && !fwnode_graph_remote_available(ep))\n\t\t\tcontinue;\n\n\t\tret = fwnode_graph_parse_endpoint(ep, &fwnode_ep);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tif (fwnode_ep.port != port)\n\t\t\tcontinue;\n\n\t\tif (fwnode_ep.id == endpoint)\n\t\t\treturn ep;\n\n\t\tif (!endpoint_next)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (fwnode_ep.id < endpoint ||\n\t\t    (best_ep && best_ep_id < fwnode_ep.id))\n\t\t\tcontinue;\n\n\t\tfwnode_handle_put(best_ep);\n\t\tbest_ep = fwnode_handle_get(ep);\n\t\tbest_ep_id = fwnode_ep.id;\n\t}\n\n\treturn best_ep;\n}\nEXPORT_SYMBOL_GPL(fwnode_graph_get_endpoint_by_id);\n\n \nunsigned int fwnode_graph_get_endpoint_count(const struct fwnode_handle *fwnode,\n\t\t\t\t\t     unsigned long flags)\n{\n\tstruct fwnode_handle *ep;\n\tunsigned int count = 0;\n\n\tfwnode_graph_for_each_endpoint(fwnode, ep) {\n\t\tif (flags & FWNODE_GRAPH_DEVICE_DISABLED ||\n\t\t    fwnode_graph_remote_available(ep))\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(fwnode_graph_get_endpoint_count);\n\n \nint fwnode_graph_parse_endpoint(const struct fwnode_handle *fwnode,\n\t\t\t\tstruct fwnode_endpoint *endpoint)\n{\n\tmemset(endpoint, 0, sizeof(*endpoint));\n\n\treturn fwnode_call_int_op(fwnode, graph_parse_endpoint, endpoint);\n}\nEXPORT_SYMBOL(fwnode_graph_parse_endpoint);\n\nconst void *device_get_match_data(const struct device *dev)\n{\n\treturn fwnode_call_ptr_op(dev_fwnode(dev), device_get_match_data, dev);\n}\nEXPORT_SYMBOL_GPL(device_get_match_data);\n\nstatic unsigned int fwnode_graph_devcon_matches(const struct fwnode_handle *fwnode,\n\t\t\t\t\t\tconst char *con_id, void *data,\n\t\t\t\t\t\tdevcon_match_fn_t match,\n\t\t\t\t\t\tvoid **matches,\n\t\t\t\t\t\tunsigned int matches_len)\n{\n\tstruct fwnode_handle *node;\n\tstruct fwnode_handle *ep;\n\tunsigned int count = 0;\n\tvoid *ret;\n\n\tfwnode_graph_for_each_endpoint(fwnode, ep) {\n\t\tif (matches && count >= matches_len) {\n\t\t\tfwnode_handle_put(ep);\n\t\t\tbreak;\n\t\t}\n\n\t\tnode = fwnode_graph_get_remote_port_parent(ep);\n\t\tif (!fwnode_device_is_available(node)) {\n\t\t\tfwnode_handle_put(node);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = match(node, con_id, data);\n\t\tfwnode_handle_put(node);\n\t\tif (ret) {\n\t\t\tif (matches)\n\t\t\t\tmatches[count] = ret;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic unsigned int fwnode_devcon_matches(const struct fwnode_handle *fwnode,\n\t\t\t\t\t  const char *con_id, void *data,\n\t\t\t\t\t  devcon_match_fn_t match,\n\t\t\t\t\t  void **matches,\n\t\t\t\t\t  unsigned int matches_len)\n{\n\tstruct fwnode_handle *node;\n\tunsigned int count = 0;\n\tunsigned int i;\n\tvoid *ret;\n\n\tfor (i = 0; ; i++) {\n\t\tif (matches && count >= matches_len)\n\t\t\tbreak;\n\n\t\tnode = fwnode_find_reference(fwnode, con_id, i);\n\t\tif (IS_ERR(node))\n\t\t\tbreak;\n\n\t\tret = match(node, NULL, data);\n\t\tfwnode_handle_put(node);\n\t\tif (ret) {\n\t\t\tif (matches)\n\t\t\t\tmatches[count] = ret;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\n \nvoid *fwnode_connection_find_match(const struct fwnode_handle *fwnode,\n\t\t\t\t   const char *con_id, void *data,\n\t\t\t\t   devcon_match_fn_t match)\n{\n\tunsigned int count;\n\tvoid *ret;\n\n\tif (!fwnode || !match)\n\t\treturn NULL;\n\n\tcount = fwnode_graph_devcon_matches(fwnode, con_id, data, match, &ret, 1);\n\tif (count)\n\t\treturn ret;\n\n\tcount = fwnode_devcon_matches(fwnode, con_id, data, match, &ret, 1);\n\treturn count ? ret : NULL;\n}\nEXPORT_SYMBOL_GPL(fwnode_connection_find_match);\n\n \nint fwnode_connection_find_matches(const struct fwnode_handle *fwnode,\n\t\t\t\t   const char *con_id, void *data,\n\t\t\t\t   devcon_match_fn_t match,\n\t\t\t\t   void **matches, unsigned int matches_len)\n{\n\tunsigned int count_graph;\n\tunsigned int count_ref;\n\n\tif (!fwnode || !match)\n\t\treturn -EINVAL;\n\n\tcount_graph = fwnode_graph_devcon_matches(fwnode, con_id, data, match,\n\t\t\t\t\t\t  matches, matches_len);\n\n\tif (matches) {\n\t\tmatches += count_graph;\n\t\tmatches_len -= count_graph;\n\t}\n\n\tcount_ref = fwnode_devcon_matches(fwnode, con_id, data, match,\n\t\t\t\t\t  matches, matches_len);\n\n\treturn count_graph + count_ref;\n}\nEXPORT_SYMBOL_GPL(fwnode_connection_find_matches);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}